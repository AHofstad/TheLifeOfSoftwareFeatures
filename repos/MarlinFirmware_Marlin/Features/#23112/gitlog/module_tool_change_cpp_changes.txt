commit 994aa9f6923e2307d13badd26a15e6d57525955f
Author: plampix <plampix@users.noreply.github.com>
Date:   Fri Jan 5 00:09:53 2024 +0100

    ‚ö°Ô∏è Slimmer null T command (#26615)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 373dcf3142..b5cacc2f3b 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -15,20 +15,22 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 #include "../inc/MarlinConfigPre.h"
 
+#if HAS_TOOLCHANGE
+
 #include "tool_change.h"
 
 #include "motion.h"
 #include "planner.h"
 #include "temperature.h"
 
 #include "../MarlinCore.h"
 #include "../gcode/gcode.h"
 
 //#define DEBUG_TOOL_CHANGE
@@ -1622,10 +1624,12 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
     current_position.e = resume_current_e;
 
     planner.synchronize();
     planner.set_e_position_mm(current_position.e); // New extruder primed and ready
 
     DEBUG_ECHOLNPGM("Migration Complete");
     return true;
   }
 
 #endif // TOOLCHANGE_MIGRATION_FEATURE
+
+#endif // HAS_TOOLCHANGE

commit 425af4240b222448ab2ebe5c5d152adeed2079a4
Author: studiodyne <42887851+studiodyne@users.noreply.github.com>
Date:   Wed Dec 6 06:05:48 2023 +0100

    üêõ Fix tool-change E prime (#26494)
    
    Followup to #17248

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 22982fa91a..373dcf3142 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -1021,21 +1021,21 @@ void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.
    * Sequence to Prime the currently selected extruder
    * Raise Z, move the ToolChange_Park if enabled, prime the extruder, move back.
    */
   void tool_change_prime() {
 
     DEBUG_SECTION(tcp, "tool_change_prime", true);
 
     if (!too_cold(active_extruder)) {
       destination = current_position; // Remember the old position
 
-      const bool ok = TERN1(TOOLCHANGE_PARK, all_axes_homed() && toolchange_settings.enable_park);
+      const bool ok = TERN0(TOOLCHANGE_PARK, all_axes_homed() && toolchange_settings.enable_park);
 
       #if HAS_FAN && TOOLCHANGE_FS_FAN >= 0
         // Store and stop fan. Restored on any exit.
         REMEMBER(fan, thermalManager.fan_speed[TOOLCHANGE_FS_FAN], 0);
       #endif
 
       // Z raise
       if (ok) {
         // Do a small lift to avoid the workpiece in the move back (below)
         current_position.z += toolchange_settings.z_raise;
@@ -1073,21 +1073,34 @@ void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.
           #if ENABLED(TOOLCHANGE_NO_RETURN)
             destination.x = current_position.x;
             destination.y = current_position.y;
           #endif
           do_blocking_move_to_xy(destination, MMM_TO_MMS(TOOLCHANGE_PARK_XY_FEEDRATE));
           do_blocking_move_to_z(destination.z, planner.settings.max_feedrate_mm_s[Z_AXIS]);
           planner.synchronize();
         }
       #endif
 
+      // Clone previous position
       extruder_cutting_recover(destination.e); // Cutting recover
+
+      // Retract if previously retracted
+      #if ENABLED(FWRETRACT)
+        if (fwretract.retracted[active_extruder])
+          unscaled_e_move(-fwretract.settings.retract_length, fwretract.settings.retract_feedrate_mm_s);
+      #endif
+
+      // If resume_position is negative
+      if (current_position.e < 0) unscaled_e_move(current_position.e, MMM_TO_MMS(toolchange_settings.retract_speed));
+
+      planner.synchronize();
+      planner.set_e_position_mm(current_position.e); // Extruder primed and ready
     }
   }
 
 #endif // TOOLCHANGE_FILAMENT_SWAP
 
 /**
  * Perform a tool-change, which may result in moving the
  * previous tool out of the way and the new tool into place.
  */
 void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
@@ -1590,20 +1603,23 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
 
     // Perform the tool change
     tool_change(migration_extruder);
 
     // Retract if previously retracted
     #if ENABLED(FWRETRACT)
       if (fwretract.retracted[active_extruder])
         unscaled_e_move(-fwretract.settings.retract_length, fwretract.settings.retract_feedrate_mm_s);
     #endif
 
+    // If resume_position is negative
+    if (resume_current_e < 0) unscaled_e_move(resume_current_e, MMM_TO_MMS(toolchange_settings.retract_speed));
+
     // If no available extruder
     if (EXTRUDERS < 2 || active_extruder >= EXTRUDERS - 2 || active_extruder == migration.last)
       migration.automode = false;
 
     migration.in_progress = false;
 
     current_position.e = resume_current_e;
 
     planner.synchronize();
     planner.set_e_position_mm(current_position.e); // New extruder primed and ready

commit 4b0b00c8da5eb193bb157d42e788da9586ed5ba7
Author: studiodyne <42887851+studiodyne@users.noreply.github.com>
Date:   Fri Oct 20 03:23:23 2023 +0200

    ‚ú® Tool Migration-specific settings (#26244)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index b33b642966..22982fa91a 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -27,23 +27,20 @@
 #include "motion.h"
 #include "planner.h"
 #include "temperature.h"
 
 #include "../MarlinCore.h"
 #include "../gcode/gcode.h"
 
 //#define DEBUG_TOOL_CHANGE
 //#define DEBUG_TOOLCHANGE_FILAMENT_SWAP
 
-#define DEBUG_OUT ENABLED(DEBUG_TOOL_CHANGE)
-#include "../core/debug_out.h"
-
 #if HAS_MULTI_EXTRUDER
   toolchange_settings_t toolchange_settings;  // Initialized by settings.load()
 #endif
 
 #if ENABLED(TOOLCHANGE_MIGRATION_FEATURE)
   migration_settings_t migration = migration_defaults;
 #endif
 
 #if ENABLED(TOOLCHANGE_FS_INIT_BEFORE_SWAP)
   Flags<EXTRUDERS> toolchange_extruder_ready;
@@ -147,20 +144,23 @@
 
 #endif // SWITCHING_NOZZLE
 
 // Move to position routines
 void _line_to_current(const AxisEnum fr_axis, const float fscale=1) {
   line_to_current_position(planner.settings.max_feedrate_mm_s[fr_axis] * fscale);
 }
 void slow_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.2f); }
 void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.5f); }
 
+#define DEBUG_OUT ENABLED(DEBUG_TOOL_CHANGE)
+#include "../core/debug_out.h"
+
 #if ENABLED(MAGNETIC_PARKING_EXTRUDER)
 
   float parkingposx[2],           // M951 R L
         parkinggrabdistance,      // M951 I
         parkingslowspeed,         // M951 J
         parkinghighspeed,         // M951 H
         parkingtraveldistance,    // M951 D
         compensationmultiplier;
 
   inline void magnetic_parking_extruder_tool_change(const uint8_t new_tool) {
@@ -888,25 +888,22 @@ void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.
     DEBUG_POS("New extruder (parked)", current_position);
   }
 
 #endif // DUAL_X_CARRIAGE
 
 /**
  * Prime active tool using TOOLCHANGE_FILAMENT_SWAP settings
  */
 #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
 
-  #ifdef DEBUG_TOOLCHANGE_FILAMENT_SWAP
-    #define FS_DEBUG(V...) SERIAL_ECHOLNPGM("DEBUG: " V)
-  #else
-    #define FS_DEBUG(...) NOOP
-  #endif
+  #define DEBUG_OUT ENABLED(DEBUG_TOOLCHANGE_FILAMENT_SWAP)
+  #include "../core/debug_out.h"
 
   // Define any variables required
   static Flags<EXTRUDERS> extruder_was_primed; // Extruders primed status
 
   #if ENABLED(TOOLCHANGE_FS_PRIME_FIRST_USED)
     bool enable_first_prime; // As set by M217 V
   #endif
 
   // Cool down with fan
   inline void filament_swap_cooling() {
@@ -934,107 +931,106 @@ void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.
   /**
    * Cutting recovery -- Recover from cutting retraction that occurs at the end of nozzle priming
    *
    * If the active_extruder is up to temp (!too_cold):
    *  Extrude filament distance = toolchange_settings.extra_resume + toolchange_settings.wipe_retract
    *  current_position.e = e;
    *  sync_plan_position_e();
    */
   void extruder_cutting_recover(const_float_t e) {
     if (too_cold(active_extruder)) return;
-
     const float dist = toolchange_settings.extra_resume + toolchange_settings.wipe_retract;
-    FS_DEBUG("Performing Cutting Recover | Distance: ", dist, " | Speed: ", MMM_TO_MMS(toolchange_settings.unretract_speed), "mm/s");
+    DEBUG_ECHOLNPGM("Performing Cutting Recover | Distance: ", dist, " | Speed: ", MMM_TO_MMS(toolchange_settings.unretract_speed), "mm/s");
     unscaled_e_move(dist, MMM_TO_MMS(toolchange_settings.unretract_speed));
 
-    FS_DEBUG("Set E position: ", e);
+    DEBUG_ECHOLNPGM("Set E position: ", e);
     current_position.e = e;
     sync_plan_position_e(); // Resume new E Position
   }
 
   /**
    * Prime the currently selected extruder (Filament loading only)
    * Leave the E position unchanged so subsequent extrusion works properly.
    *
    * If too_cold(toolID) returns TRUE -> returns without moving extruder.
    * Extruders filament = swap_length + extra prime, then performs cutting retraction if enabled.
    * If cooling fan is enabled, calls filament_swap_cooling();
    */
   void extruder_prime() {
     if (too_cold(active_extruder)) {
-      FS_DEBUG("Priming Aborted -  Nozzle Too Cold!");
+      DEBUG_ECHOLNPGM("Priming Aborted -  Nozzle Too Cold!");
       return; // Extruder too cold to prime
     }
 
     feedRate_t fr_mm_s = MMM_TO_MMS(toolchange_settings.unretract_speed); // Set default speed for unretract
 
     const float resume_current_e = current_position.e;
 
     #if ENABLED(TOOLCHANGE_FS_SLOW_FIRST_PRIME)
       /**
        * Perform first unretract movement at the slower Prime_Speed to avoid breakage on first prime
        */
       static Flags<EXTRUDERS> extruder_did_first_prime;  // Extruders first priming status
       if (!extruder_did_first_prime[active_extruder]) {
         extruder_did_first_prime.set(active_extruder);   // Log first prime complete
         // new nozzle - prime at user-specified speed.
         const feedRate_t prime_mm_s = MMM_TO_MMS(toolchange_settings.prime_speed);
-        FS_DEBUG("First time priming T", active_extruder, ", reducing speed from ", fr_mm_s, " to ",  prime_mm_s, "mm/s");
+        DEBUG_ECHOLNPGM("First time priming T", active_extruder, ", reducing speed from ", fr_mm_s, " to ",  prime_mm_s, "mm/s");
         fr_mm_s = prime_mm_s;
         unscaled_e_move(0, fr_mm_s);      // Init planner with 0 length move
       }
     #endif
 
     // Calculate and perform the priming distance
     if (toolchange_settings.extra_prime >= 0) {
       // Positive extra_prime value
       // - Return filament at speed (fr_mm_s) then extra_prime at prime speed
-      FS_DEBUG("Loading Filament for T", active_extruder, " | Distance: ", toolchange_settings.swap_length, " | Speed: ", fr_mm_s, "mm/s");
+      DEBUG_ECHOLNPGM("Loading Filament for T", active_extruder, " | Distance: ", toolchange_settings.swap_length, " | Speed: ", fr_mm_s, "mm/s");
       unscaled_e_move(toolchange_settings.swap_length, fr_mm_s); // Prime (Unretract) filament by extruding equal to Swap Length (Unretract)
 
       if (toolchange_settings.extra_prime > 0) {
-        FS_DEBUG("Performing Extra Priming for T", active_extruder, " | Distance: ", toolchange_settings.extra_prime, " | Speed: ", MMM_TO_MMS(toolchange_settings.prime_speed), "mm/s");
+        DEBUG_ECHOLNPGM("Performing Extra Priming for T", active_extruder, " | Distance: ", toolchange_settings.extra_prime, " | Speed: ", MMM_TO_MMS(toolchange_settings.prime_speed), "mm/s");
         unscaled_e_move(toolchange_settings.extra_prime, MMM_TO_MMS(toolchange_settings.prime_speed)); // Extra Prime Distance
       }
     }
     else {
       // Negative extra_prime value
       // - Unretract distance (swap length) is reduced by the value of extra_prime
       const float eswap = toolchange_settings.swap_length + toolchange_settings.extra_prime;
-      FS_DEBUG("Negative ExtraPrime value - Swap Return Length has been reduced from ", toolchange_settings.swap_length, " to ", eswap);
-      FS_DEBUG("Loading Filament for T", active_extruder, " | Distance: ", eswap, " | Speed: ", fr_mm_s, "mm/s");
+      DEBUG_ECHOLNPGM("Negative ExtraPrime value - Swap Return Length has been reduced from ", toolchange_settings.swap_length, " to ", eswap);
+      DEBUG_ECHOLNPGM("Loading Filament for T", active_extruder, " | Distance: ", eswap, " | Speed: ", fr_mm_s, "mm/s");
       unscaled_e_move(eswap, fr_mm_s);
     }
 
     extruder_was_primed.set(active_extruder); // Log that this extruder has been primed
 
     // Cutting retraction
     #if TOOLCHANGE_FS_WIPE_RETRACT
-      FS_DEBUG("Performing Cutting Retraction | Distance: ", -toolchange_settings.wipe_retract, " | Speed: ", MMM_TO_MMS(toolchange_settings.retract_speed), "mm/s");
+      DEBUG_ECHOLNPGM("Performing Cutting Retraction | Distance: ", -toolchange_settings.wipe_retract, " | Speed: ", MMM_TO_MMS(toolchange_settings.retract_speed), "mm/s");
       unscaled_e_move(-toolchange_settings.wipe_retract, MMM_TO_MMS(toolchange_settings.retract_speed));
     #endif
 
     // Leave E unchanged when priming
     current_position.e = resume_current_e;
     sync_plan_position_e();
 
     // Cool down with fan
     filament_swap_cooling();
   }
 
   /**
    * Sequence to Prime the currently selected extruder
    * Raise Z, move the ToolChange_Park if enabled, prime the extruder, move back.
    */
   void tool_change_prime() {
 
-    FS_DEBUG(">>> tool_change_prime()");
+    DEBUG_SECTION(tcp, "tool_change_prime", true);
 
     if (!too_cold(active_extruder)) {
       destination = current_position; // Remember the old position
 
       const bool ok = TERN1(TOOLCHANGE_PARK, all_axes_homed() && toolchange_settings.enable_park);
 
       #if HAS_FAN && TOOLCHANGE_FS_FAN >= 0
         // Store and stop fan. Restored on any exit.
         REMEMBER(fan, thermalManager.fan_speed[TOOLCHANGE_FS_FAN], 0);
       #endif
@@ -1079,23 +1075,20 @@ void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.
             destination.y = current_position.y;
           #endif
           do_blocking_move_to_xy(destination, MMM_TO_MMS(TOOLCHANGE_PARK_XY_FEEDRATE));
           do_blocking_move_to_z(destination.z, planner.settings.max_feedrate_mm_s[Z_AXIS]);
           planner.synchronize();
         }
       #endif
 
       extruder_cutting_recover(destination.e); // Cutting recover
     }
-
-    FS_DEBUG("<<< tool_change_prime");
-
   }
 
 #endif // TOOLCHANGE_FILAMENT_SWAP
 
 /**
  * Perform a tool-change, which may result in moving the
  * previous tool out of the way and the new tool into place.
  */
 void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
 
@@ -1196,21 +1189,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
       #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
         const bool should_swap = can_move_away && toolchange_settings.swap_length;
         if (should_swap) {
           if (too_cold(old_tool)) {
             // If SingleNozzle setup is too cold, unable to perform tool_change.
             if (ENABLED(SINGLENOZZLE)) { active_extruder = new_tool; return; }
           }
           else if (extruder_was_primed[old_tool]) {
             // Retract the old extruder if it was previously primed
             // To-Do: Should SingleNozzle always retract?
-            FS_DEBUG("Retracting Filament for T", old_tool, ". | Distance: ", toolchange_settings.swap_length, " | Speed: ", MMM_TO_MMS(toolchange_settings.retract_speed), "mm/s");
+            DEBUG_ECHOLNPGM("Retracting Filament for T", old_tool, ". | Distance: ", toolchange_settings.swap_length, " | Speed: ", MMM_TO_MMS(toolchange_settings.retract_speed), "mm/s");
             unscaled_e_move(-toolchange_settings.swap_length, MMM_TO_MMS(toolchange_settings.retract_speed));
           }
         }
       #endif
 
       TERN_(SWITCHING_NOZZLE_TWO_SERVOS, raise_nozzle(old_tool));
 
       REMEMBER(fr, feedrate_mm_s, XY_PROBE_FEEDRATE_MM_S);
 
       #if HAS_SOFTWARE_ENDSTOPS
@@ -1560,34 +1553,63 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
     #if HAS_MULTI_HOTEND
       thermalManager.setTargetHotend(thermalManager.degTargetHotend(active_extruder), migration_extruder);
       TERN_(AUTOTEMP, planner.autotemp_update());
       thermalManager.set_heating_message(0);
       thermalManager.wait_for_hotend(active_extruder);
     #endif
 
     // Migrate Linear Advance K factor to the new extruder
     TERN_(LIN_ADVANCE, planner.extruder_advance_K[active_extruder] = planner.extruder_advance_K[migration_extruder]);
 
+    // Temporary migration toolchange_settings restored on exit. i.e., before next tool_change().
+    #if defined(MIGRATION_FS_EXTRA_PRIME) \
+     || defined(MIGRATION_FS_WIPE_RETRACT) \
+     || defined(MIGRATION_FS_FAN_SPEED) \
+     || defined(MIGRATION_FS_FAN_TIME) \
+     || defined(MIGRATION_ZRAISE) \
+     || defined(TOOLCHANGE_MIGRATION_DO_PARK)
+      REMEMBER(tmp_mig_settings, toolchange_settings);
+      #ifdef MIGRATION_FS_EXTRA_PRIME
+        toolchange_settings.extra_prime = MIGRATION_FS_EXTRA_PRIME;
+      #endif
+      #ifdef MIGRATION_FS_WIPE_RETRACT
+        toolchange_settings.wipe_retract = MIGRATION_FS_WIPE_RETRACT;
+      #endif
+      #ifdef MIGRATION_FS_FAN_SPEED
+        toolchange_settings.fan_speed = MIGRATION_FS_FAN_SPEED;
+      #endif
+      #ifdef MIGRATION_FS_FAN_TIME
+        toolchange_settings.fan_time = MIGRATION_FS_FAN_TIME;
+      #endif
+      #ifdef MIGRATION_ZRAISE
+        toolchange_settings.z_raise = MIGRATION_ZRAISE;
+      #endif
+      #ifdef TOOLCHANGE_MIGRATION_DO_PARK
+        toolchange_settings.enable_park = ENABLED(TOOLCHANGE_MIGRATION_DO_PARK);
+      #endif
+    #endif
+
     // Perform the tool change
     tool_change(migration_extruder);
 
     // Retract if previously retracted
     #if ENABLED(FWRETRACT)
       if (fwretract.retracted[active_extruder])
         unscaled_e_move(-fwretract.settings.retract_length, fwretract.settings.retract_feedrate_mm_s);
     #endif
 
     // If no available extruder
     if (EXTRUDERS < 2 || active_extruder >= EXTRUDERS - 2 || active_extruder == migration.last)
       migration.automode = false;
 
     migration.in_progress = false;
 
     current_position.e = resume_current_e;
 
     planner.synchronize();
     planner.set_e_position_mm(current_position.e); // New extruder primed and ready
+
     DEBUG_ECHOLNPGM("Migration Complete");
     return true;
   }
 
 #endif // TOOLCHANGE_MIGRATION_FEATURE

commit 61591fd23369a03063a42f57a174c51f995c7efb
Author: studiodyne <42887851+studiodyne@users.noreply.github.com>
Date:   Tue Oct 10 00:50:09 2023 +0200

    üêõ Fix tool-change E prime (#26237)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 622877667d..b33b642966 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -933,46 +933,49 @@ void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.
 
   /**
    * Cutting recovery -- Recover from cutting retraction that occurs at the end of nozzle priming
    *
    * If the active_extruder is up to temp (!too_cold):
    *  Extrude filament distance = toolchange_settings.extra_resume + toolchange_settings.wipe_retract
    *  current_position.e = e;
    *  sync_plan_position_e();
    */
   void extruder_cutting_recover(const_float_t e) {
-    if (!too_cold(active_extruder)) {
-      const float dist = toolchange_settings.extra_resume + toolchange_settings.wipe_retract;
-      FS_DEBUG("Performing Cutting Recover | Distance: ", dist, " | Speed: ", MMM_TO_MMS(toolchange_settings.unretract_speed), "mm/s");
-      unscaled_e_move(dist, MMM_TO_MMS(toolchange_settings.unretract_speed));
-      planner.synchronize();
-      FS_DEBUG("Set position to: ", e);
-      current_position.e = e;
-      sync_plan_position_e(); // Resume new E Position
-    }
+    if (too_cold(active_extruder)) return;
+
+    const float dist = toolchange_settings.extra_resume + toolchange_settings.wipe_retract;
+    FS_DEBUG("Performing Cutting Recover | Distance: ", dist, " | Speed: ", MMM_TO_MMS(toolchange_settings.unretract_speed), "mm/s");
+    unscaled_e_move(dist, MMM_TO_MMS(toolchange_settings.unretract_speed));
+
+    FS_DEBUG("Set E position: ", e);
+    current_position.e = e;
+    sync_plan_position_e(); // Resume new E Position
   }
 
   /**
    * Prime the currently selected extruder (Filament loading only)
+   * Leave the E position unchanged so subsequent extrusion works properly.
    *
    * If too_cold(toolID) returns TRUE -> returns without moving extruder.
    * Extruders filament = swap_length + extra prime, then performs cutting retraction if enabled.
    * If cooling fan is enabled, calls filament_swap_cooling();
    */
   void extruder_prime() {
     if (too_cold(active_extruder)) {
       FS_DEBUG("Priming Aborted -  Nozzle Too Cold!");
       return; // Extruder too cold to prime
     }
 
     feedRate_t fr_mm_s = MMM_TO_MMS(toolchange_settings.unretract_speed); // Set default speed for unretract
 
+    const float resume_current_e = current_position.e;
+
     #if ENABLED(TOOLCHANGE_FS_SLOW_FIRST_PRIME)
       /**
        * Perform first unretract movement at the slower Prime_Speed to avoid breakage on first prime
        */
       static Flags<EXTRUDERS> extruder_did_first_prime;  // Extruders first priming status
       if (!extruder_did_first_prime[active_extruder]) {
         extruder_did_first_prime.set(active_extruder);   // Log first prime complete
         // new nozzle - prime at user-specified speed.
         const feedRate_t prime_mm_s = MMM_TO_MMS(toolchange_settings.prime_speed);
         FS_DEBUG("First time priming T", active_extruder, ", reducing speed from ", fr_mm_s, " to ",  prime_mm_s, "mm/s");
@@ -1003,20 +1006,24 @@ void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.
     }
 
     extruder_was_primed.set(active_extruder); // Log that this extruder has been primed
 
     // Cutting retraction
     #if TOOLCHANGE_FS_WIPE_RETRACT
       FS_DEBUG("Performing Cutting Retraction | Distance: ", -toolchange_settings.wipe_retract, " | Speed: ", MMM_TO_MMS(toolchange_settings.retract_speed), "mm/s");
       unscaled_e_move(-toolchange_settings.wipe_retract, MMM_TO_MMS(toolchange_settings.retract_speed));
     #endif
 
+    // Leave E unchanged when priming
+    current_position.e = resume_current_e;
+    sync_plan_position_e();
+
     // Cool down with fan
     filament_swap_cooling();
   }
 
   /**
    * Sequence to Prime the currently selected extruder
    * Raise Z, move the ToolChange_Park if enabled, prime the extruder, move back.
    */
   void tool_change_prime() {
 
@@ -1054,31 +1061,33 @@ void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.
               current_position.u = toolchange_settings.change_point.u,
               current_position.v = toolchange_settings.change_point.v,
               current_position.w = toolchange_settings.change_point.w
             );
           #endif
           planner.buffer_line(current_position, MMM_TO_MMS(TOOLCHANGE_PARK_XY_FEEDRATE), active_extruder);
           planner.synchronize();
         }
       #endif
 
+      // Prime without changing E
       extruder_prime();
 
       // Move back
       #if ENABLED(TOOLCHANGE_PARK)
         if (ok) {
           #if ENABLED(TOOLCHANGE_NO_RETURN)
-            const float temp = destination.z;
-            destination = current_position;
-            destination.z = temp;
+            destination.x = current_position.x;
+            destination.y = current_position.y;
           #endif
-          prepare_internal_move_to_destination(TERN(TOOLCHANGE_NO_RETURN, planner.settings.max_feedrate_mm_s[Z_AXIS], MMM_TO_MMS(TOOLCHANGE_PARK_XY_FEEDRATE)));
+          do_blocking_move_to_xy(destination, MMM_TO_MMS(TOOLCHANGE_PARK_XY_FEEDRATE));
+          do_blocking_move_to_z(destination.z, planner.settings.max_feedrate_mm_s[Z_AXIS]);
+          planner.synchronize();
         }
       #endif
 
       extruder_cutting_recover(destination.e); // Cutting recover
     }
 
     FS_DEBUG("<<< tool_change_prime");
 
   }
 

commit 047bce0cdd8599d3ea9b85d173f8d79a0802adf1
Author: Dipl.-Ing. Raoul Rubien, BSc <rubienr@sbox.tugraz.at>
Date:   Mon Oct 9 02:22:40 2023 +0200

    üîß More angles for 2x Servo Switching Nozzle (#26303)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 4c286c81a0..622877667d 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -120,23 +120,22 @@
   }
 
 #endif // DO_SWITCH_EXTRUDER
 
 #if ENABLED(SWITCHING_NOZZLE)
 
   #if SWITCHING_NOZZLE_TWO_SERVOS
 
     inline void _move_nozzle_servo(const uint8_t e, const uint8_t angle_index) {
       constexpr int8_t  sns_index[2] = { SWITCHING_NOZZLE_SERVO_NR, SWITCHING_NOZZLE_E1_SERVO_NR };
-      constexpr int16_t sns_angles[2] = SWITCHING_NOZZLE_SERVO_ANGLES;
       planner.synchronize();
-      servo[sns_index[e]].move(sns_angles[angle_index]);
+      servo[sns_index[e]].move(servo_angles[sns_index[e]][angle_index]);
       safe_delay(SWITCHING_NOZZLE_SERVO_DWELL);
     }
 
     void lower_nozzle(const uint8_t e) { _move_nozzle_servo(e, 0); }
     void raise_nozzle(const uint8_t e) { _move_nozzle_servo(e, 1); }
 
   #else
 
     void move_nozzle_servo(const uint8_t angle_index) {
       planner.synchronize();

commit 9135e3f7d3fd0d634656f1c54c70a0ba1f878bfd
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jul 20 21:10:03 2023 -0500

    üö∏ Revert M206 Home Offset behavior (#25996)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index d65b3fb32a..4c286c81a0 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -1410,33 +1410,27 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
       move_extruder_servo(active_extruder);
     #endif
 
     TERN_(HAS_FANMUX, fanmux_switch(active_extruder));
 
     if (ENABLED(EVENT_GCODE_TOOLCHANGE_ALWAYS_RUN) || !no_move) {
 
       #if ANY(TC_GCODE_USE_GLOBAL_X, TC_GCODE_USE_GLOBAL_Y, TC_GCODE_USE_GLOBAL_Z)
         // G0/G1/G2/G3/G5 moves are relative to the active tool.
         // Shift the workspace to make custom moves relative to T0.
-        xyz_pos_t old_position_shift;
+        xyz_pos_t old_workspace_offset;
         if (new_tool > 0) {
-          old_position_shift = position_shift;
+          old_workspace_offset = workspace_offset;
           const xyz_pos_t &he = hotend_offset[new_tool];
-          #if ENABLED(TC_GCODE_USE_GLOBAL_X)
-            position_shift.x -= he.x; update_workspace_offset(X_AXIS);
-          #endif
-          #if ENABLED(TC_GCODE_USE_GLOBAL_Y)
-            position_shift.y -= he.y; update_workspace_offset(Y_AXIS);
-          #endif
-          #if ENABLED(TC_GCODE_USE_GLOBAL_Z)
-            position_shift.z -= he.z; update_workspace_offset(Z_AXIS);
-          #endif
+          TERN_(TC_GCODE_USE_GLOBAL_X, workspace_offset.x -= he.x);
+          TERN_(TC_GCODE_USE_GLOBAL_Y, workspace_offset.y -= he.y);
+          TERN_(TC_GCODE_USE_GLOBAL_Z, workspace_offset.z -= he.z);
         }
       #endif
 
       switch (new_tool) {
         default: break;
         #ifdef EVENT_GCODE_TOOLCHANGE_T0
           case 0: gcode.process_subcommands_now(F(EVENT_GCODE_TOOLCHANGE_T0)); break;
         #endif
         #ifdef EVENT_GCODE_TOOLCHANGE_T1
           case 1: gcode.process_subcommands_now(F(EVENT_GCODE_TOOLCHANGE_T1)); break;
@@ -1455,26 +1449,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
         #endif
         #ifdef EVENT_GCODE_TOOLCHANGE_T6
           case 6: gcode.process_subcommands_now(F(EVENT_GCODE_TOOLCHANGE_T6)); break;
         #endif
         #ifdef EVENT_GCODE_TOOLCHANGE_T7
           case 7: gcode.process_subcommands_now(F(EVENT_GCODE_TOOLCHANGE_T7)); break;
         #endif
       }
 
       #if ANY(TC_GCODE_USE_GLOBAL_X, TC_GCODE_USE_GLOBAL_Y, TC_GCODE_USE_GLOBAL_Z)
-        if (new_tool > 0) {
-          position_shift = old_position_shift;
-          TERN_(TC_GCODE_USE_GLOBAL_X, update_workspace_offset(X_AXIS));
-          TERN_(TC_GCODE_USE_GLOBAL_Y, update_workspace_offset(Y_AXIS));
-          TERN_(TC_GCODE_USE_GLOBAL_Z, update_workspace_offset(Z_AXIS));
-        }
+        if (new_tool > 0) workspace_offset = old_workspace_offset;
       #endif
 
       // If using MECHANICAL_SWITCHING extruder/nozzle, set HOTEND_OFFSET in Z axis after running EVENT_GCODE_TOOLCHANGE
       // so that nozzle does not lower below print surface if new hotend Z offset is higher than old hotend Z offset.
       #if ANY(MECHANICAL_SWITCHING_EXTRUDER, MECHANICAL_SWITCHING_NOZZLE)
         #if HAS_HOTEND_OFFSET
           xyz_pos_t diff = hotend_offset[new_tool] - hotend_offset[old_tool];
           TERN_(DUAL_X_CARRIAGE, diff.x = 0);
         #else
           constexpr xyz_pos_t diff{0};

commit 35016633d843ba393eb17cf5fd1dba03764821dd
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jun 6 02:58:28 2023 -0500

    ü©π Conditional include probe.h

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 21f5ce80b5..d65b3fb32a 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -17,21 +17,20 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 #include "../inc/MarlinConfigPre.h"
 
 #include "tool_change.h"
 
-#include "probe.h"
 #include "motion.h"
 #include "planner.h"
 #include "temperature.h"
 
 #include "../MarlinCore.h"
 #include "../gcode/gcode.h"
 
 //#define DEBUG_TOOL_CHANGE
 //#define DEBUG_TOOLCHANGE_FILAMENT_SWAP
 
@@ -85,20 +84,24 @@
 #endif
 
 #if HAS_MARLINUI_MENU
   #include "../lcd/marlinui.h"
 #endif
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   #include "../feature/pause.h"
 #endif
 
+#if HAS_BED_PROBE
+  #include "probe.h"
+#endif
+
 #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
   #if TOOLCHANGE_FS_WIPE_RETRACT <= 0
     #undef TOOLCHANGE_FS_WIPE_RETRACT
     #define TOOLCHANGE_FS_WIPE_RETRACT 0
   #endif
 #endif
 
 #if DO_SWITCH_EXTRUDER
 
   #if EXTRUDERS > 3

commit 86c811660ebf0b3fcbae2f34273d4c9d0c22abc4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:30:34 2023 -0500

    üßë‚Äçüíª Remove LOOP macros (#25917)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index d4c2fcb675..21f5ce80b5 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -243,21 +243,21 @@ void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.
 
     planner.buffer_line(current_position, mpe_settings.fast_feedrate, new_tool);
     planner.synchronize();
 
     DEBUG_ECHOLNPGM("Autopark done.");
   }
 
 #elif ENABLED(PARKING_EXTRUDER)
 
   void pe_solenoid_init() {
-    LOOP_LE_N(n, 1) pe_solenoid_set_pin_state(n, !PARKING_EXTRUDER_SOLENOIDS_PINS_ACTIVE);
+    for (uint8_t n = 0; n <= 1; ++n) pe_solenoid_set_pin_state(n, !PARKING_EXTRUDER_SOLENOIDS_PINS_ACTIVE);
   }
 
   void pe_solenoid_set_pin_state(const uint8_t extruder_num, const uint8_t state) {
     switch (extruder_num) {
       case 1: OUT_WRITE(SOL1_PIN, state); break;
       default: OUT_WRITE(SOL0_PIN, state); break;
     }
     #if PARKING_EXTRUDER_SOLENOIDS_DELAY > 0
       gcode.dwell(PARKING_EXTRUDER_SOLENOIDS_DELAY);
     #endif

commit 2691167afe02fbbe74b0fdca2c28a49fac635741
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:26:02 2023 -0500

    üßë‚Äçüíª Dump BOTH and EITHER macros (#25908)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index cce3669355..d4c2fcb675 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -1158,21 +1158,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
     #if ENABLED(TOOLCHANGE_FS_PRIME_FIRST_USED)
       if (enable_first_prime && old_tool == 0 && new_tool == 0 && !extruder_was_primed[0]) {
         tool_change_prime();
         TERN_(TOOLCHANGE_FS_INIT_BEFORE_SWAP, toolchange_extruder_ready.set(old_tool)); // Primed and initialized
       }
     #endif
 
     if (new_tool != old_tool || TERN0(PARKING_EXTRUDER, extruder_parked)) { // PARKING_EXTRUDER may need to attach old_tool when homing
       destination = current_position;
 
-      #if BOTH(TOOLCHANGE_FILAMENT_SWAP, HAS_FAN) && TOOLCHANGE_FS_FAN >= 0
+      #if ALL(TOOLCHANGE_FILAMENT_SWAP, HAS_FAN) && TOOLCHANGE_FS_FAN >= 0
         // Store and stop fan. Restored on any exit.
         REMEMBER(fan, thermalManager.fan_speed[TOOLCHANGE_FS_FAN], 0);
       #endif
 
       // Z raise before retraction
       #if ENABLED(TOOLCHANGE_ZRAISE_BEFORE_RETRACT) && !HAS_SWITCHING_NOZZLE
         if (can_move_away && TERN1(TOOLCHANGE_PARK, toolchange_settings.enable_park)) {
           // Do a small lift to avoid the workpiece in the move back (below)
           current_position.z += toolchange_settings.z_raise;
           TERN_(HAS_SOFTWARE_ENDSTOPS, NOMORE(current_position.z, soft_endstop.max.z));
@@ -1270,21 +1270,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
           const float newz = current_position.z + _MAX(-diff.z, 0.0);
 
           // Check if Z has space to compensate at least z_offset, and if not, just abort now
           const float maxz = _MIN(TERN(HAS_SOFTWARE_ENDSTOPS, soft_endstop.max.z, Z_MAX_POS), Z_MAX_POS);
           if (newz > maxz) return;
 
           current_position.z = _MIN(newz + toolchange_settings.z_raise, maxz);
           fast_line_to_current(Z_AXIS);
         }
         move_nozzle_servo(new_tool);
-      #elif EITHER(MECHANICAL_SWITCHING_EXTRUDER, MECHANICAL_SWITCHING_NOZZLE)
+      #elif ANY(MECHANICAL_SWITCHING_EXTRUDER, MECHANICAL_SWITCHING_NOZZLE)
         if (!no_move) {
           current_position.z = _MIN(current_position.z + toolchange_settings.z_raise, _MIN(TERN(HAS_SOFTWARE_ENDSTOPS, soft_endstop.max.z, Z_MAX_POS), Z_MAX_POS));
           fast_line_to_current(Z_AXIS);
         }
       #endif
 
       IF_DISABLED(DUAL_X_CARRIAGE, active_extruder = new_tool); // Set the new active extruder
 
       TERN_(TOOL_SENSOR, tool_sensor_disabled = false);
 
@@ -1301,21 +1301,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
         //LOOP_NUM_AXES(i) update_software_endstops(i); // or modify the constrain function
         const bool safe_to_move = current_position.z < delta_clip_start_height - 1;
       #else
         constexpr bool safe_to_move = true;
       #endif
 
       // Return to position and lower again
       const bool should_move = safe_to_move && !no_move && IsRunning();
       if (should_move) {
 
-        #if EITHER(SINGLENOZZLE_STANDBY_TEMP, SINGLENOZZLE_STANDBY_FAN)
+        #if ANY(SINGLENOZZLE_STANDBY_TEMP, SINGLENOZZLE_STANDBY_FAN)
           thermalManager.singlenozzle_change(old_tool, new_tool);
         #endif
 
         #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
           if (should_swap && !too_cold(active_extruder))
             extruder_prime(); // Prime selected Extruder
         #endif
 
         // Prevent a move outside physical bounds
         #if ENABLED(MAGNETIC_SWITCHING_TOOLHEAD)
@@ -1462,21 +1462,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
         if (new_tool > 0) {
           position_shift = old_position_shift;
           TERN_(TC_GCODE_USE_GLOBAL_X, update_workspace_offset(X_AXIS));
           TERN_(TC_GCODE_USE_GLOBAL_Y, update_workspace_offset(Y_AXIS));
           TERN_(TC_GCODE_USE_GLOBAL_Z, update_workspace_offset(Z_AXIS));
         }
       #endif
 
       // If using MECHANICAL_SWITCHING extruder/nozzle, set HOTEND_OFFSET in Z axis after running EVENT_GCODE_TOOLCHANGE
       // so that nozzle does not lower below print surface if new hotend Z offset is higher than old hotend Z offset.
-      #if EITHER(MECHANICAL_SWITCHING_EXTRUDER, MECHANICAL_SWITCHING_NOZZLE)
+      #if ANY(MECHANICAL_SWITCHING_EXTRUDER, MECHANICAL_SWITCHING_NOZZLE)
         #if HAS_HOTEND_OFFSET
           xyz_pos_t diff = hotend_offset[new_tool] - hotend_offset[old_tool];
           TERN_(DUAL_X_CARRIAGE, diff.x = 0);
         #else
           constexpr xyz_pos_t diff{0};
         #endif
 
         if (!no_move) {
           // Move to new hotend Z offset and reverse Z_RAISE
           do_blocking_move_to_z(

commit f0f7ec88823318c7d778e42b4dc7604120943032
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Apr 23 00:47:44 2023 -0500

    üßë‚Äçüíª Stepper::set_directions() => apply_directions()

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index a91f6f742d..cce3669355 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -873,21 +873,21 @@ void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.
         DEBUG_ECHOLNPGM("DXC Full Control curr.x=", current_position.x, " dest.x=", destination.x);
         break;
       case DXC_AUTO_PARK_MODE:
         idex_set_parked();
         break;
       default:
         break;
     }
 
     // Ensure X axis DIR pertains to the correct carriage
-    stepper.set_directions();
+    stepper.apply_directions();
 
     DEBUG_ECHOLNPGM("Active extruder parked: ", active_extruder_parked ? "yes" : "no");
     DEBUG_POS("New extruder (parked)", current_position);
   }
 
 #endif // DUAL_X_CARRIAGE
 
 /**
  * Prime active tool using TOOLCHANGE_FILAMENT_SWAP settings
  */

commit 161b99cb54f5d6d183877902581d3d77e8a1fa78
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Apr 14 01:08:51 2023 -0500

    üêõ Fix some bad feedrates (#25672)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 43a50505ef..a91f6f742d 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -950,74 +950,73 @@ void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.
   }
 
   /**
    * Prime the currently selected extruder (Filament loading only)
    *
    * If too_cold(toolID) returns TRUE -> returns without moving extruder.
    * Extruders filament = swap_length + extra prime, then performs cutting retraction if enabled.
    * If cooling fan is enabled, calls filament_swap_cooling();
    */
   void extruder_prime() {
-
     if (too_cold(active_extruder)) {
       FS_DEBUG("Priming Aborted -  Nozzle Too Cold!");
       return; // Extruder too cold to prime
     }
 
-    float fr = toolchange_settings.unretract_speed; // Set default speed for unretract
+    feedRate_t fr_mm_s = MMM_TO_MMS(toolchange_settings.unretract_speed); // Set default speed for unretract
 
     #if ENABLED(TOOLCHANGE_FS_SLOW_FIRST_PRIME)
       /**
        * Perform first unretract movement at the slower Prime_Speed to avoid breakage on first prime
        */
       static Flags<EXTRUDERS> extruder_did_first_prime;  // Extruders first priming status
       if (!extruder_did_first_prime[active_extruder]) {
         extruder_did_first_prime.set(active_extruder);   // Log first prime complete
         // new nozzle - prime at user-specified speed.
-        FS_DEBUG("First time priming T", active_extruder, ", reducing speed from ", MMM_TO_MMS(fr), " to ",  MMM_TO_MMS(toolchange_settings.prime_speed), "mm/s");
-        fr = toolchange_settings.prime_speed;
-        unscaled_e_move(0, MMM_TO_MMS(fr));      // Init planner with 0 length move
+        const feedRate_t prime_mm_s = MMM_TO_MMS(toolchange_settings.prime_speed);
+        FS_DEBUG("First time priming T", active_extruder, ", reducing speed from ", fr_mm_s, " to ",  prime_mm_s, "mm/s");
+        fr_mm_s = prime_mm_s;
+        unscaled_e_move(0, fr_mm_s);      // Init planner with 0 length move
       }
     #endif
 
     // Calculate and perform the priming distance
     if (toolchange_settings.extra_prime >= 0) {
       // Positive extra_prime value
-      // - Return filament at speed (fr) then extra_prime at prime speed
-      FS_DEBUG("Loading Filament for T", active_extruder, " | Distance: ", toolchange_settings.swap_length, " | Speed: ", MMM_TO_MMS(fr), "mm/s");
-      unscaled_e_move(toolchange_settings.swap_length, MMM_TO_MMS(fr)); // Prime (Unretract) filament by extruding equal to Swap Length (Unretract)
+      // - Return filament at speed (fr_mm_s) then extra_prime at prime speed
+      FS_DEBUG("Loading Filament for T", active_extruder, " | Distance: ", toolchange_settings.swap_length, " | Speed: ", fr_mm_s, "mm/s");
+      unscaled_e_move(toolchange_settings.swap_length, fr_mm_s); // Prime (Unretract) filament by extruding equal to Swap Length (Unretract)
 
       if (toolchange_settings.extra_prime > 0) {
         FS_DEBUG("Performing Extra Priming for T", active_extruder, " | Distance: ", toolchange_settings.extra_prime, " | Speed: ", MMM_TO_MMS(toolchange_settings.prime_speed), "mm/s");
         unscaled_e_move(toolchange_settings.extra_prime, MMM_TO_MMS(toolchange_settings.prime_speed)); // Extra Prime Distance
       }
     }
     else {
       // Negative extra_prime value
       // - Unretract distance (swap length) is reduced by the value of extra_prime
       const float eswap = toolchange_settings.swap_length + toolchange_settings.extra_prime;
       FS_DEBUG("Negative ExtraPrime value - Swap Return Length has been reduced from ", toolchange_settings.swap_length, " to ", eswap);
-      FS_DEBUG("Loading Filament for T", active_extruder, " | Distance: ", eswap, " | Speed: ", MMM_TO_MMS(fr), "mm/s");
-      unscaled_e_move(eswap, MMM_TO_MMS(fr));
+      FS_DEBUG("Loading Filament for T", active_extruder, " | Distance: ", eswap, " | Speed: ", fr_mm_s, "mm/s");
+      unscaled_e_move(eswap, fr_mm_s);
     }
 
     extruder_was_primed.set(active_extruder); // Log that this extruder has been primed
 
     // Cutting retraction
     #if TOOLCHANGE_FS_WIPE_RETRACT
       FS_DEBUG("Performing Cutting Retraction | Distance: ", -toolchange_settings.wipe_retract, " | Speed: ", MMM_TO_MMS(toolchange_settings.retract_speed), "mm/s");
       unscaled_e_move(-toolchange_settings.wipe_retract, MMM_TO_MMS(toolchange_settings.retract_speed));
     #endif
 
     // Cool down with fan
     filament_swap_cooling();
-
   }
 
   /**
    * Sequence to Prime the currently selected extruder
    * Raise Z, move the ToolChange_Park if enabled, prime the extruder, move back.
    */
   void tool_change_prime() {
 
     FS_DEBUG(">>> tool_change_prime()");
 

commit de0cd660705668f2e9f1e0cb8fff80b40be0f4e6
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Mar 28 05:39:35 2023 -0500

    üé® Misc. cleanup

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 9955a0f1b0..43a50505ef 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -428,21 +428,20 @@ void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.
         safe_delay(5);
       }
       else {
         sensor_tries++;
         if (sensor_tries > 10) return -1;
         safe_delay(5);
       }
     }
   }
 
-
 #endif // TOOL_SENSOR
 
 #if ENABLED(SWITCHING_TOOLHEAD)
 
   inline void switching_toolhead_lock(const bool locked) {
     #ifdef SWITCHING_TOOLHEAD_SERVO_ANGLES
       const uint16_t swt_angles[2] = SWITCHING_TOOLHEAD_SERVO_ANGLES;
       servo[SWITCHING_TOOLHEAD_SERVO_NR].move(swt_angles[locked ? 0 : 1]);
     #elif PIN_EXISTS(SWT_SOLENOID)
       OUT_WRITE(SWT_SOLENOID_PIN, locked);

commit e977232735abd759678e8665759dbc214df88202
Author: EvilGremlin <22657714+EvilGremlin@users.noreply.github.com>
Date:   Sat Mar 4 05:43:20 2023 +0300

    ‚ú® Switching extruder/nozzle without servo (e.g., Dondolo) (#24553)
    
    Co-authored-by: Anson Liu <ansonl@users.noreply.github.com>

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 0defced87e..9955a0f1b0 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -1166,21 +1166,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
 
     if (new_tool != old_tool || TERN0(PARKING_EXTRUDER, extruder_parked)) { // PARKING_EXTRUDER may need to attach old_tool when homing
       destination = current_position;
 
       #if BOTH(TOOLCHANGE_FILAMENT_SWAP, HAS_FAN) && TOOLCHANGE_FS_FAN >= 0
         // Store and stop fan. Restored on any exit.
         REMEMBER(fan, thermalManager.fan_speed[TOOLCHANGE_FS_FAN], 0);
       #endif
 
       // Z raise before retraction
-      #if ENABLED(TOOLCHANGE_ZRAISE_BEFORE_RETRACT) && DISABLED(SWITCHING_NOZZLE)
+      #if ENABLED(TOOLCHANGE_ZRAISE_BEFORE_RETRACT) && !HAS_SWITCHING_NOZZLE
         if (can_move_away && TERN1(TOOLCHANGE_PARK, toolchange_settings.enable_park)) {
           // Do a small lift to avoid the workpiece in the move back (below)
           current_position.z += toolchange_settings.z_raise;
           TERN_(HAS_SOFTWARE_ENDSTOPS, NOMORE(current_position.z, soft_endstop.max.z));
           fast_line_to_current(Z_AXIS);
           planner.synchronize();
         }
       #endif
 
       // Unload / Retract
@@ -1210,31 +1210,31 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
         #else
           #define _EXT_ARGS
         #endif
         update_software_endstops(X_AXIS _EXT_ARGS);
         #if DISABLED(DUAL_X_CARRIAGE)
           update_software_endstops(Y_AXIS _EXT_ARGS);
           update_software_endstops(Z_AXIS _EXT_ARGS);
         #endif
       #endif
 
-      #if DISABLED(TOOLCHANGE_ZRAISE_BEFORE_RETRACT) && DISABLED(SWITCHING_NOZZLE)
+      #if NONE(TOOLCHANGE_ZRAISE_BEFORE_RETRACT, HAS_SWITCHING_NOZZLE)
         if (can_move_away && TERN1(TOOLCHANGE_PARK, toolchange_settings.enable_park)) {
           // Do a small lift to avoid the workpiece in the move back (below)
           current_position.z += toolchange_settings.z_raise;
           TERN_(HAS_SOFTWARE_ENDSTOPS, NOMORE(current_position.z, soft_endstop.max.z));
           fast_line_to_current(Z_AXIS);
         }
       #endif
 
       // Toolchange park
-      #if ENABLED(TOOLCHANGE_PARK) && DISABLED(SWITCHING_NOZZLE)
+      #if ENABLED(TOOLCHANGE_PARK) && !HAS_SWITCHING_NOZZLE
         if (can_move_away && toolchange_settings.enable_park) {
           IF_DISABLED(TOOLCHANGE_PARK_Y_ONLY, current_position.x = toolchange_settings.change_point.x);
           IF_DISABLED(TOOLCHANGE_PARK_X_ONLY, current_position.y = toolchange_settings.change_point.y);
           #if NONE(TOOLCHANGE_PARK_X_ONLY, TOOLCHANGE_PARK_Y_ONLY)
             SECONDARY_AXIS_CODE(
               current_position.i = toolchange_settings.change_point.i,
               current_position.j = toolchange_settings.change_point.j,
               current_position.k = toolchange_settings.change_point.k,
               current_position.u = toolchange_settings.change_point.u,
               current_position.v = toolchange_settings.change_point.v,
@@ -1272,20 +1272,25 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
           const float newz = current_position.z + _MAX(-diff.z, 0.0);
 
           // Check if Z has space to compensate at least z_offset, and if not, just abort now
           const float maxz = _MIN(TERN(HAS_SOFTWARE_ENDSTOPS, soft_endstop.max.z, Z_MAX_POS), Z_MAX_POS);
           if (newz > maxz) return;
 
           current_position.z = _MIN(newz + toolchange_settings.z_raise, maxz);
           fast_line_to_current(Z_AXIS);
         }
         move_nozzle_servo(new_tool);
+      #elif EITHER(MECHANICAL_SWITCHING_EXTRUDER, MECHANICAL_SWITCHING_NOZZLE)
+        if (!no_move) {
+          current_position.z = _MIN(current_position.z + toolchange_settings.z_raise, _MIN(TERN(HAS_SOFTWARE_ENDSTOPS, soft_endstop.max.z, Z_MAX_POS), Z_MAX_POS));
+          fast_line_to_current(Z_AXIS);
+        }
       #endif
 
       IF_DISABLED(DUAL_X_CARRIAGE, active_extruder = new_tool); // Set the new active extruder
 
       TERN_(TOOL_SENSOR, tool_sensor_disabled = false);
 
       (void)check_tool_sensor_stats(active_extruder, true);
 
       // The newly-selected extruder XYZ is actually at...
       DEBUG_ECHOLNPGM("Offset Tool XYZ by { ", diff.x, ", ", diff.y, ", ", diff.z, " }");
@@ -1336,29 +1341,33 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
               do_blocking_move_to_z(destination.z, planner.settings.max_feedrate_mm_s[Z_AXIS]);
 
           #else
             // Move back to the original (or adjusted) position
             DEBUG_POS("Move back", destination);
 
             #if ENABLED(TOOLCHANGE_PARK)
               if (toolchange_settings.enable_park) do_blocking_move_to_xy_z(destination, destination.z, MMM_TO_MMS(TOOLCHANGE_PARK_XY_FEEDRATE));
             #else
               do_blocking_move_to_xy(destination, planner.settings.max_feedrate_mm_s[X_AXIS]);
-              do_blocking_move_to_z(destination.z, planner.settings.max_feedrate_mm_s[Z_AXIS]);
-              SECONDARY_AXIS_CODE(
-                do_blocking_move_to_i(destination.i, planner.settings.max_feedrate_mm_s[I_AXIS]),
-                do_blocking_move_to_j(destination.j, planner.settings.max_feedrate_mm_s[J_AXIS]),
-                do_blocking_move_to_k(destination.k, planner.settings.max_feedrate_mm_s[K_AXIS]),
-                do_blocking_move_to_u(destination.u, planner.settings.max_feedrate_mm_s[U_AXIS]),
-                do_blocking_move_to_v(destination.v, planner.settings.max_feedrate_mm_s[V_AXIS]),
-                do_blocking_move_to_w(destination.w, planner.settings.max_feedrate_mm_s[W_AXIS])
-              );
+
+              // If using MECHANICAL_SWITCHING extruder/nozzle, set HOTEND_OFFSET in Z axis after running EVENT_GCODE_TOOLCHANGE below.
+              #if NONE(MECHANICAL_SWITCHING_EXTRUDER, MECHANICAL_SWITCHING_NOZZLE)
+                do_blocking_move_to_z(destination.z, planner.settings.max_feedrate_mm_s[Z_AXIS]);
+                SECONDARY_AXIS_CODE(
+                  do_blocking_move_to_i(destination.i, planner.settings.max_feedrate_mm_s[I_AXIS]),
+                  do_blocking_move_to_j(destination.j, planner.settings.max_feedrate_mm_s[J_AXIS]),
+                  do_blocking_move_to_k(destination.k, planner.settings.max_feedrate_mm_s[K_AXIS]),
+                  do_blocking_move_to_u(destination.u, planner.settings.max_feedrate_mm_s[U_AXIS]),
+                  do_blocking_move_to_v(destination.v, planner.settings.max_feedrate_mm_s[V_AXIS]),
+                  do_blocking_move_to_w(destination.w, planner.settings.max_feedrate_mm_s[W_AXIS])
+                );
+              #endif
             #endif
 
           #endif
         }
 
         else DEBUG_ECHOLNPGM("Move back skipped");
 
         #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
           if (should_swap && !too_cold(active_extruder)) {
             extruder_cutting_recover(0); // New extruder primed and set to 0
@@ -1366,21 +1375,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
             // Restart Fan
             #if HAS_FAN && TOOLCHANGE_FS_FAN >= 0
               RESTORE(fan);
             #endif
           }
         #endif
 
         TERN_(DUAL_X_CARRIAGE, idex_set_parked(false));
       }
 
-      #if ENABLED(SWITCHING_NOZZLE)
+      #if HAS_SWITCHING_NOZZLE
         // Move back down. (Including when the new tool is higher.)
         if (!should_move)
           do_blocking_move_to_z(destination.z, planner.settings.max_feedrate_mm_s[Z_AXIS]);
       #endif
 
       TERN_(SWITCHING_NOZZLE_TWO_SERVOS, lower_nozzle(new_tool));
 
     } // (new_tool != old_tool)
 
     planner.synchronize();
@@ -1453,20 +1462,43 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
 
       #if ANY(TC_GCODE_USE_GLOBAL_X, TC_GCODE_USE_GLOBAL_Y, TC_GCODE_USE_GLOBAL_Z)
         if (new_tool > 0) {
           position_shift = old_position_shift;
           TERN_(TC_GCODE_USE_GLOBAL_X, update_workspace_offset(X_AXIS));
           TERN_(TC_GCODE_USE_GLOBAL_Y, update_workspace_offset(Y_AXIS));
           TERN_(TC_GCODE_USE_GLOBAL_Z, update_workspace_offset(Z_AXIS));
         }
       #endif
 
+      // If using MECHANICAL_SWITCHING extruder/nozzle, set HOTEND_OFFSET in Z axis after running EVENT_GCODE_TOOLCHANGE
+      // so that nozzle does not lower below print surface if new hotend Z offset is higher than old hotend Z offset.
+      #if EITHER(MECHANICAL_SWITCHING_EXTRUDER, MECHANICAL_SWITCHING_NOZZLE)
+        #if HAS_HOTEND_OFFSET
+          xyz_pos_t diff = hotend_offset[new_tool] - hotend_offset[old_tool];
+          TERN_(DUAL_X_CARRIAGE, diff.x = 0);
+        #else
+          constexpr xyz_pos_t diff{0};
+        #endif
+
+        if (!no_move) {
+          // Move to new hotend Z offset and reverse Z_RAISE
+          do_blocking_move_to_z(
+            _MIN(
+              _MAX((destination.z - diff.z) - toolchange_settings.z_raise,
+              _MAX(TERN(HAS_SOFTWARE_ENDSTOPS, soft_endstop.min.z, Z_MIN_POS), Z_MIN_POS)
+            ),
+            _MIN(TERN(HAS_SOFTWARE_ENDSTOPS, soft_endstop.max.z, Z_MAX_POS), Z_MAX_POS)),
+            planner.settings.max_feedrate_mm_s[Z_AXIS]
+          );
+        }
+      #endif
+
       #ifdef EVENT_GCODE_AFTER_TOOLCHANGE
         if (TERN1(DUAL_X_CARRIAGE, dual_x_carriage_mode == DXC_AUTO_PARK_MODE))
           gcode.process_subcommands_now(F(EVENT_GCODE_AFTER_TOOLCHANGE));
       #endif
     }
 
     SERIAL_ECHOLNPGM(STR_ACTIVE_EXTRUDER, active_extruder);
 
   #endif // HAS_MULTI_EXTRUDER
 }

commit 4f212e50b6ad402ae34e7c9ed35ec9168bae6221
Author: Anson Liu <ansonl@users.noreply.github.com>
Date:   Mon Feb 20 19:49:15 2023 -0500

    ‚ú® TC_GCODE_USE_GLOBAL_* (#25399)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 16b562e482..0defced87e 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -23,45 +23,40 @@
 #include "../inc/MarlinConfigPre.h"
 
 #include "tool_change.h"
 
 #include "probe.h"
 #include "motion.h"
 #include "planner.h"
 #include "temperature.h"
 
 #include "../MarlinCore.h"
+#include "../gcode/gcode.h"
 
 //#define DEBUG_TOOL_CHANGE
 //#define DEBUG_TOOLCHANGE_FILAMENT_SWAP
 
 #define DEBUG_OUT ENABLED(DEBUG_TOOL_CHANGE)
 #include "../core/debug_out.h"
 
 #if HAS_MULTI_EXTRUDER
   toolchange_settings_t toolchange_settings;  // Initialized by settings.load()
 #endif
 
 #if ENABLED(TOOLCHANGE_MIGRATION_FEATURE)
   migration_settings_t migration = migration_defaults;
 #endif
 
 #if ENABLED(TOOLCHANGE_FS_INIT_BEFORE_SWAP)
   Flags<EXTRUDERS> toolchange_extruder_ready;
 #endif
 
-#if EITHER(MAGNETIC_PARKING_EXTRUDER, TOOL_SENSOR) \
-  || defined(EVENT_GCODE_TOOLCHANGE_T0) || defined(EVENT_GCODE_TOOLCHANGE_T1) || defined(EVENT_GCODE_AFTER_TOOLCHANGE) \
-  || (ENABLED(PARKING_EXTRUDER) && PARKING_EXTRUDER_SOLENOIDS_DELAY > 0)
-  #include "../gcode/gcode.h"
-#endif
-
 #if ENABLED(TOOL_SENSOR)
   #include "../lcd/marlinui.h"
 #endif
 
 #if ENABLED(DUAL_X_CARRIAGE)
   #include "stepper.h"
 #endif
 
 #if ANY(SWITCHING_EXTRUDER, SWITCHING_NOZZLE, SWITCHING_TOOLHEAD)
   #include "servo.h"
@@ -91,21 +86,20 @@
 
 #if HAS_MARLINUI_MENU
   #include "../lcd/marlinui.h"
 #endif
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   #include "../feature/pause.h"
 #endif
 
 #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
-  #include "../gcode/gcode.h"
   #if TOOLCHANGE_FS_WIPE_RETRACT <= 0
     #undef TOOLCHANGE_FS_WIPE_RETRACT
     #define TOOLCHANGE_FS_WIPE_RETRACT 0
   #endif
 #endif
 
 #if DO_SWITCH_EXTRUDER
 
   #if EXTRUDERS > 3
     #define _SERVO_NR(E) ((E) < 2 ? SWITCHING_EXTRUDER_SERVO_NR : SWITCHING_EXTRUDER_E23_SERVO_NR)
@@ -979,21 +973,21 @@ void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.
       static Flags<EXTRUDERS> extruder_did_first_prime;  // Extruders first priming status
       if (!extruder_did_first_prime[active_extruder]) {
         extruder_did_first_prime.set(active_extruder);   // Log first prime complete
         // new nozzle - prime at user-specified speed.
         FS_DEBUG("First time priming T", active_extruder, ", reducing speed from ", MMM_TO_MMS(fr), " to ",  MMM_TO_MMS(toolchange_settings.prime_speed), "mm/s");
         fr = toolchange_settings.prime_speed;
         unscaled_e_move(0, MMM_TO_MMS(fr));      // Init planner with 0 length move
       }
     #endif
 
-    //Calculate and perform the priming distance
+    // Calculate and perform the priming distance
     if (toolchange_settings.extra_prime >= 0) {
       // Positive extra_prime value
       // - Return filament at speed (fr) then extra_prime at prime speed
       FS_DEBUG("Loading Filament for T", active_extruder, " | Distance: ", toolchange_settings.swap_length, " | Speed: ", MMM_TO_MMS(fr), "mm/s");
       unscaled_e_move(toolchange_settings.swap_length, MMM_TO_MMS(fr)); // Prime (Unretract) filament by extruding equal to Swap Length (Unretract)
 
       if (toolchange_settings.extra_prime > 0) {
         FS_DEBUG("Performing Extra Priming for T", active_extruder, " | Distance: ", toolchange_settings.extra_prime, " | Speed: ", MMM_TO_MMS(toolchange_settings.prime_speed), "mm/s");
         unscaled_e_move(toolchange_settings.extra_prime, MMM_TO_MMS(toolchange_settings.prime_speed)); // Extra Prime Distance
       }
@@ -1402,28 +1396,75 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
     #endif
 
     #if DO_SWITCH_EXTRUDER
       planner.synchronize();
       move_extruder_servo(active_extruder);
     #endif
 
     TERN_(HAS_FANMUX, fanmux_switch(active_extruder));
 
     if (ENABLED(EVENT_GCODE_TOOLCHANGE_ALWAYS_RUN) || !no_move) {
-      #ifdef EVENT_GCODE_TOOLCHANGE_T0
-        if (new_tool == 0)
-          gcode.process_subcommands_now(F(EVENT_GCODE_TOOLCHANGE_T0));
+
+      #if ANY(TC_GCODE_USE_GLOBAL_X, TC_GCODE_USE_GLOBAL_Y, TC_GCODE_USE_GLOBAL_Z)
+        // G0/G1/G2/G3/G5 moves are relative to the active tool.
+        // Shift the workspace to make custom moves relative to T0.
+        xyz_pos_t old_position_shift;
+        if (new_tool > 0) {
+          old_position_shift = position_shift;
+          const xyz_pos_t &he = hotend_offset[new_tool];
+          #if ENABLED(TC_GCODE_USE_GLOBAL_X)
+            position_shift.x -= he.x; update_workspace_offset(X_AXIS);
+          #endif
+          #if ENABLED(TC_GCODE_USE_GLOBAL_Y)
+            position_shift.y -= he.y; update_workspace_offset(Y_AXIS);
+          #endif
+          #if ENABLED(TC_GCODE_USE_GLOBAL_Z)
+            position_shift.z -= he.z; update_workspace_offset(Z_AXIS);
+          #endif
+        }
       #endif
 
-      #ifdef EVENT_GCODE_TOOLCHANGE_T1
-        if (new_tool == 1)
-          gcode.process_subcommands_now(F(EVENT_GCODE_TOOLCHANGE_T1));
+      switch (new_tool) {
+        default: break;
+        #ifdef EVENT_GCODE_TOOLCHANGE_T0
+          case 0: gcode.process_subcommands_now(F(EVENT_GCODE_TOOLCHANGE_T0)); break;
+        #endif
+        #ifdef EVENT_GCODE_TOOLCHANGE_T1
+          case 1: gcode.process_subcommands_now(F(EVENT_GCODE_TOOLCHANGE_T1)); break;
+        #endif
+        #ifdef EVENT_GCODE_TOOLCHANGE_T2
+          case 2: gcode.process_subcommands_now(F(EVENT_GCODE_TOOLCHANGE_T2)); break;
+        #endif
+        #ifdef EVENT_GCODE_TOOLCHANGE_T3
+          case 3: gcode.process_subcommands_now(F(EVENT_GCODE_TOOLCHANGE_T3)); break;
+        #endif
+        #ifdef EVENT_GCODE_TOOLCHANGE_T4
+          case 4: gcode.process_subcommands_now(F(EVENT_GCODE_TOOLCHANGE_T4)); break;
+        #endif
+        #ifdef EVENT_GCODE_TOOLCHANGE_T5
+          case 5: gcode.process_subcommands_now(F(EVENT_GCODE_TOOLCHANGE_T5)); break;
+        #endif
+        #ifdef EVENT_GCODE_TOOLCHANGE_T6
+          case 6: gcode.process_subcommands_now(F(EVENT_GCODE_TOOLCHANGE_T6)); break;
+        #endif
+        #ifdef EVENT_GCODE_TOOLCHANGE_T7
+          case 7: gcode.process_subcommands_now(F(EVENT_GCODE_TOOLCHANGE_T7)); break;
+        #endif
+      }
+
+      #if ANY(TC_GCODE_USE_GLOBAL_X, TC_GCODE_USE_GLOBAL_Y, TC_GCODE_USE_GLOBAL_Z)
+        if (new_tool > 0) {
+          position_shift = old_position_shift;
+          TERN_(TC_GCODE_USE_GLOBAL_X, update_workspace_offset(X_AXIS));
+          TERN_(TC_GCODE_USE_GLOBAL_Y, update_workspace_offset(Y_AXIS));
+          TERN_(TC_GCODE_USE_GLOBAL_Z, update_workspace_offset(Z_AXIS));
+        }
       #endif
 
       #ifdef EVENT_GCODE_AFTER_TOOLCHANGE
         if (TERN1(DUAL_X_CARRIAGE, dual_x_carriage_mode == DXC_AUTO_PARK_MODE))
           gcode.process_subcommands_now(F(EVENT_GCODE_AFTER_TOOLCHANGE));
       #endif
     }
 
     SERIAL_ECHOLNPGM(STR_ACTIVE_EXTRUDER, active_extruder);
 

commit a6b677f0ac5f8a29bb5226eb0e43756969629319
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Feb 8 20:29:37 2023 -0600

    ü©π Extra axes for Tool Change

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 74e99ac093..16b562e482 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -1343,20 +1343,28 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
 
           #else
             // Move back to the original (or adjusted) position
             DEBUG_POS("Move back", destination);
 
             #if ENABLED(TOOLCHANGE_PARK)
               if (toolchange_settings.enable_park) do_blocking_move_to_xy_z(destination, destination.z, MMM_TO_MMS(TOOLCHANGE_PARK_XY_FEEDRATE));
             #else
               do_blocking_move_to_xy(destination, planner.settings.max_feedrate_mm_s[X_AXIS]);
               do_blocking_move_to_z(destination.z, planner.settings.max_feedrate_mm_s[Z_AXIS]);
+              SECONDARY_AXIS_CODE(
+                do_blocking_move_to_i(destination.i, planner.settings.max_feedrate_mm_s[I_AXIS]),
+                do_blocking_move_to_j(destination.j, planner.settings.max_feedrate_mm_s[J_AXIS]),
+                do_blocking_move_to_k(destination.k, planner.settings.max_feedrate_mm_s[K_AXIS]),
+                do_blocking_move_to_u(destination.u, planner.settings.max_feedrate_mm_s[U_AXIS]),
+                do_blocking_move_to_v(destination.v, planner.settings.max_feedrate_mm_s[V_AXIS]),
+                do_blocking_move_to_w(destination.w, planner.settings.max_feedrate_mm_s[W_AXIS])
+              );
             #endif
 
           #endif
         }
 
         else DEBUG_ECHOLNPGM("Move back skipped");
 
         #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
           if (should_swap && !too_cold(active_extruder)) {
             extruder_cutting_recover(0); // New extruder primed and set to 0

commit b7c23631c5840e2338cae531b171459e9e9c5301
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Sun Jan 22 15:08:37 2023 +1300

    üêõ Fix misc. UI issues (#25252)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 7322098c0b..74e99ac093 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -922,21 +922,21 @@ void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.
     #endif
   }
 
   /**
    * Check if too cold to move the specified tool
    *
    * Returns TRUE if too cold to move (also echos message: STR_ERR_HOTEND_TOO_COLD)
    * Returns FALSE if able to  move.
    */
   bool too_cold(uint8_t toolID){
-    if (TERN0(PREVENT_COLD_EXTRUSION, !DEBUGGING(DRYRUN) && thermalManager.targetTooColdToExtrude(toolID))) {
+    if (!DEBUGGING(DRYRUN) && thermalManager.targetTooColdToExtrude(toolID)) {
       SERIAL_ECHO_MSG(STR_ERR_HOTEND_TOO_COLD);
       return true;
     }
     return false;
   }
 
   /**
    * Cutting recovery -- Recover from cutting retraction that occurs at the end of nozzle priming
    *
    * If the active_extruder is up to temp (!too_cold):
@@ -1422,26 +1422,24 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
   #endif // HAS_MULTI_EXTRUDER
 }
 
 #if ENABLED(TOOLCHANGE_MIGRATION_FEATURE)
 
   #define DEBUG_OUT ENABLED(DEBUG_TOOLCHANGE_MIGRATION_FEATURE)
   #include "../core/debug_out.h"
 
   bool extruder_migration() {
 
-    #if ENABLED(PREVENT_COLD_EXTRUSION)
-      if (thermalManager.targetTooColdToExtrude(active_extruder)) {
-        DEBUG_ECHOLNPGM("Migration Source Too Cold");
-        return false;
-      }
-    #endif
+    if (thermalManager.targetTooColdToExtrude(active_extruder)) {
+      DEBUG_ECHOLNPGM("Migration Source Too Cold");
+      return false;
+    }
 
     // No auto-migration or specified target?
     if (!migration.target && active_extruder >= migration.last) {
       DEBUG_ECHO_MSG("No Migration Target");
       DEBUG_ECHO_MSG("Target: ", migration.target, " Last: ", migration.last, " Active: ", active_extruder);
       migration.automode = false;
       return false;
     }
 
     // Migrate to a target or the next extruder

commit 909442cb88b5efcc99755a899b7081d0fb766c2f
Author: Vasily Evseenko <svpcom@gmail.com>
Date:   Sun Nov 27 04:26:40 2022 +0300

    üçª Fix Z increase on toolchange without UBL (#22942)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index a0939d155a..7322098c0b 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -1150,22 +1150,22 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
 
     #if ENABLED(DUAL_X_CARRIAGE)
       const bool idex_full_control = dual_x_carriage_mode == DXC_FULL_CONTROL_MODE;
     #else
       constexpr bool idex_full_control = false;
     #endif
 
     const uint8_t old_tool = active_extruder;
     const bool can_move_away = !no_move && !idex_full_control;
 
-    #if HAS_LEVELING
-      // Set current position to the physical position
+    #if ENABLED(AUTO_BED_LEVELING_UBL)
+      // Workaround for UBL mesh boundary, possibly?
       TEMPORARY_BED_LEVELING_STATE(false);
     #endif
 
     // First tool priming. To prime again, reboot the machine. -- Should only occur for first T0 after powerup!
     #if ENABLED(TOOLCHANGE_FS_PRIME_FIRST_USED)
       if (enable_first_prime && old_tool == 0 && new_tool == 0 && !extruder_was_primed[0]) {
         tool_change_prime();
         TERN_(TOOLCHANGE_FS_INIT_BEFORE_SWAP, toolchange_extruder_ready.set(old_tool)); // Primed and initialized
       }
     #endif

commit 6e1f0be215235c96113c74a6fda345e11626ce28
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Oct 24 17:04:55 2022 -0500

    ü©π Allow for last non-servo extruder

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index cd18462be3..a0939d155a 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -108,21 +108,22 @@
 #if DO_SWITCH_EXTRUDER
 
   #if EXTRUDERS > 3
     #define _SERVO_NR(E) ((E) < 2 ? SWITCHING_EXTRUDER_SERVO_NR : SWITCHING_EXTRUDER_E23_SERVO_NR)
   #else
     #define _SERVO_NR(E) SWITCHING_EXTRUDER_SERVO_NR
   #endif
 
   void move_extruder_servo(const uint8_t e) {
     planner.synchronize();
-    if (e < EXTRUDERS) {
+    constexpr bool evenExtruders = !(EXTRUDERS & 1);
+    if (evenExtruders || e < EXTRUDERS - 1) {
       servo[_SERVO_NR(e)].move(servo_angles[_SERVO_NR(e)][e & 1]);
       safe_delay(500);
     }
   }
 
 #endif // DO_SWITCH_EXTRUDER
 
 #if ENABLED(SWITCHING_NOZZLE)
 
   #if SWITCHING_NOZZLE_TWO_SERVOS

commit f4dc9d572be3b9858539a5115f275e4b6e626f8e
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Tue Oct 25 10:47:23 2022 +1300

    üêõ Fix move_extruder_servo (#24908)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 80aedd3bdd..cd18462be3 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -108,21 +108,21 @@
 #if DO_SWITCH_EXTRUDER
 
   #if EXTRUDERS > 3
     #define _SERVO_NR(E) ((E) < 2 ? SWITCHING_EXTRUDER_SERVO_NR : SWITCHING_EXTRUDER_E23_SERVO_NR)
   #else
     #define _SERVO_NR(E) SWITCHING_EXTRUDER_SERVO_NR
   #endif
 
   void move_extruder_servo(const uint8_t e) {
     planner.synchronize();
-    if ((EXTRUDERS & 1) && e < EXTRUDERS - 1) {
+    if (e < EXTRUDERS) {
       servo[_SERVO_NR(e)].move(servo_angles[_SERVO_NR(e)][e & 1]);
       safe_delay(500);
     }
   }
 
 #endif // DO_SWITCH_EXTRUDER
 
 #if ENABLED(SWITCHING_NOZZLE)
 
   #if SWITCHING_NOZZLE_TWO_SERVOS

commit 02c43f44c73b76c8d8d1e48b8e595ced62da2459
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Fri Oct 21 14:03:38 2022 -0400

    ‚ú® Controllerfan PWM scaling, kickstart (#24873)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 4eb72a5b7d..80aedd3bdd 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -910,21 +910,21 @@ void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.
 
   #if ENABLED(TOOLCHANGE_FS_PRIME_FIRST_USED)
     bool enable_first_prime; // As set by M217 V
   #endif
 
   // Cool down with fan
   inline void filament_swap_cooling() {
     #if HAS_FAN && TOOLCHANGE_FS_FAN >= 0
       thermalManager.fan_speed[TOOLCHANGE_FS_FAN] = toolchange_settings.fan_speed;
       gcode.dwell(SEC_TO_MS(toolchange_settings.fan_time));
-      thermalManager.fan_speed[TOOLCHANGE_FS_FAN] = 0;
+      thermalManager.fan_speed[TOOLCHANGE_FS_FAN] = FAN_OFF_PWM;
     #endif
   }
 
   /**
    * Check if too cold to move the specified tool
    *
    * Returns TRUE if too cold to move (also echos message: STR_ERR_HOTEND_TOO_COLD)
    * Returns FALSE if able to  move.
    */
   bool too_cold(uint8_t toolID){

commit 6cc11b76fd499162e644468bc278eda7b3471041
Author: Adam <54421854+aamott@users.noreply.github.com>
Date:   Sat Oct 1 10:49:12 2022 -0600

    ü©π Fix Switching Toolhead compile (#24814)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 0ff0856ddd..4eb72a5b7d 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -433,34 +433,37 @@ void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.
         safe_delay(5);
       }
       else {
         sensor_tries++;
         if (sensor_tries > 10) return -1;
         safe_delay(5);
       }
     }
   }
 
+
+#endif // TOOL_SENSOR
+
+#if ENABLED(SWITCHING_TOOLHEAD)
+
   inline void switching_toolhead_lock(const bool locked) {
     #ifdef SWITCHING_TOOLHEAD_SERVO_ANGLES
       const uint16_t swt_angles[2] = SWITCHING_TOOLHEAD_SERVO_ANGLES;
       servo[SWITCHING_TOOLHEAD_SERVO_NR].move(swt_angles[locked ? 0 : 1]);
     #elif PIN_EXISTS(SWT_SOLENOID)
       OUT_WRITE(SWT_SOLENOID_PIN, locked);
       gcode.dwell(10);
     #else
       #error "No toolhead locking mechanism configured."
     #endif
   }
 
-  #include <bitset>
-
   void swt_init() {
     switching_toolhead_lock(true);
 
     #if ENABLED(TOOL_SENSOR)
       // Init tool sensors
       #if PIN_EXISTS(TOOL_SENSOR1)
         SET_INPUT_PULLUP(TOOL_SENSOR1_PIN);
       #endif
       #if PIN_EXISTS(TOOL_SENSOR2)
         SET_INPUT_PULLUP(TOOL_SENSOR2_PIN);
@@ -487,24 +490,20 @@ void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.
       if (check_tool_sensor_stats(0)) {
         LCD_MESSAGE_F("TC error");
         switching_toolhead_lock(false);
         while (check_tool_sensor_stats(0)) { /* nada */ }
         switching_toolhead_lock(true);
       }
       LCD_MESSAGE_F("TC Success");
     #endif // TOOL_SENSOR
   }
 
-#endif // TOOL_SENSOR
-
-#if ENABLED(SWITCHING_TOOLHEAD)
-
   inline void switching_toolhead_tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
     if (no_move) return;
 
     constexpr float toolheadposx[] = SWITCHING_TOOLHEAD_X_POS;
     const float placexpos = toolheadposx[active_extruder],
                 grabxpos = toolheadposx[new_tool];
 
     (void)check_tool_sensor_stats(active_extruder, true);
 
     /**

commit 9e5c143b87e4fc97a875e56aa9ec7d411c36d923
Author: studiodyne <diabolomix@hotmail.fr>
Date:   Sun Aug 28 00:43:32 2022 +0200

    ‚ú® M217 G wipe retract length

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index dbd95121dc..0ff0856ddd 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -933,27 +933,27 @@ void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.
       SERIAL_ECHO_MSG(STR_ERR_HOTEND_TOO_COLD);
       return true;
     }
     return false;
   }
 
   /**
    * Cutting recovery -- Recover from cutting retraction that occurs at the end of nozzle priming
    *
    * If the active_extruder is up to temp (!too_cold):
-   *  Extrude filament distance = toolchange_settings.extra_resume + TOOLCHANGE_FS_WIPE_RETRACT
+   *  Extrude filament distance = toolchange_settings.extra_resume + toolchange_settings.wipe_retract
    *  current_position.e = e;
    *  sync_plan_position_e();
    */
   void extruder_cutting_recover(const_float_t e) {
     if (!too_cold(active_extruder)) {
-      const float dist = toolchange_settings.extra_resume + (TOOLCHANGE_FS_WIPE_RETRACT);
+      const float dist = toolchange_settings.extra_resume + toolchange_settings.wipe_retract;
       FS_DEBUG("Performing Cutting Recover | Distance: ", dist, " | Speed: ", MMM_TO_MMS(toolchange_settings.unretract_speed), "mm/s");
       unscaled_e_move(dist, MMM_TO_MMS(toolchange_settings.unretract_speed));
       planner.synchronize();
       FS_DEBUG("Set position to: ", e);
       current_position.e = e;
       sync_plan_position_e(); // Resume new E Position
     }
   }
 
   /**
@@ -966,31 +966,31 @@ void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.
   void extruder_prime() {
 
     if (too_cold(active_extruder)) {
       FS_DEBUG("Priming Aborted -  Nozzle Too Cold!");
       return; // Extruder too cold to prime
     }
 
     float fr = toolchange_settings.unretract_speed; // Set default speed for unretract
 
     #if ENABLED(TOOLCHANGE_FS_SLOW_FIRST_PRIME)
-    /*
-     * Perform first unretract movement at the slower Prime_Speed to avoid breakage on first prime
-     */
-    static Flags<EXTRUDERS> extruder_did_first_prime;  // Extruders first priming status
-    if (!extruder_did_first_prime[active_extruder]) {
-      extruder_did_first_prime.set(active_extruder);   // Log first prime complete
-      // new nozzle - prime at user-specified speed.
-      FS_DEBUG("First time priming T", active_extruder, ", reducing speed from ", MMM_TO_MMS(fr), " to ",  MMM_TO_MMS(toolchange_settings.prime_speed), "mm/s");
-      fr = toolchange_settings.prime_speed;
-      unscaled_e_move(0, MMM_TO_MMS(fr));      // Init planner with 0 length move
-    }
+      /**
+       * Perform first unretract movement at the slower Prime_Speed to avoid breakage on first prime
+       */
+      static Flags<EXTRUDERS> extruder_did_first_prime;  // Extruders first priming status
+      if (!extruder_did_first_prime[active_extruder]) {
+        extruder_did_first_prime.set(active_extruder);   // Log first prime complete
+        // new nozzle - prime at user-specified speed.
+        FS_DEBUG("First time priming T", active_extruder, ", reducing speed from ", MMM_TO_MMS(fr), " to ",  MMM_TO_MMS(toolchange_settings.prime_speed), "mm/s");
+        fr = toolchange_settings.prime_speed;
+        unscaled_e_move(0, MMM_TO_MMS(fr));      // Init planner with 0 length move
+      }
     #endif
 
     //Calculate and perform the priming distance
     if (toolchange_settings.extra_prime >= 0) {
       // Positive extra_prime value
       // - Return filament at speed (fr) then extra_prime at prime speed
       FS_DEBUG("Loading Filament for T", active_extruder, " | Distance: ", toolchange_settings.swap_length, " | Speed: ", MMM_TO_MMS(fr), "mm/s");
       unscaled_e_move(toolchange_settings.swap_length, MMM_TO_MMS(fr)); // Prime (Unretract) filament by extruding equal to Swap Length (Unretract)
 
       if (toolchange_settings.extra_prime > 0) {
@@ -1004,22 +1004,22 @@ void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.
       const float eswap = toolchange_settings.swap_length + toolchange_settings.extra_prime;
       FS_DEBUG("Negative ExtraPrime value - Swap Return Length has been reduced from ", toolchange_settings.swap_length, " to ", eswap);
       FS_DEBUG("Loading Filament for T", active_extruder, " | Distance: ", eswap, " | Speed: ", MMM_TO_MMS(fr), "mm/s");
       unscaled_e_move(eswap, MMM_TO_MMS(fr));
     }
 
     extruder_was_primed.set(active_extruder); // Log that this extruder has been primed
 
     // Cutting retraction
     #if TOOLCHANGE_FS_WIPE_RETRACT
-      FS_DEBUG("Performing Cutting Retraction | Distance: ", -(TOOLCHANGE_FS_WIPE_RETRACT), " | Speed: ", MMM_TO_MMS(toolchange_settings.retract_speed), "mm/s");
-      unscaled_e_move(-(TOOLCHANGE_FS_WIPE_RETRACT), MMM_TO_MMS(toolchange_settings.retract_speed));
+      FS_DEBUG("Performing Cutting Retraction | Distance: ", -toolchange_settings.wipe_retract, " | Speed: ", MMM_TO_MMS(toolchange_settings.retract_speed), "mm/s");
+      unscaled_e_move(-toolchange_settings.wipe_retract, MMM_TO_MMS(toolchange_settings.retract_speed));
     #endif
 
     // Cool down with fan
     filament_swap_cooling();
 
   }
 
   /**
    * Sequence to Prime the currently selected extruder
    * Raise Z, move the ToolChange_Park if enabled, prime the extruder, move back.

commit 91f9e1671f5bb2dc8ba00adce022cd74f5267c39
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sat Jul 30 22:55:32 2022 -0400

    ‚ú® Configurable Switching Nozzle dwell (#24304)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 4b292c92f9..dbd95121dc 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -125,32 +125,32 @@
 
 #if ENABLED(SWITCHING_NOZZLE)
 
   #if SWITCHING_NOZZLE_TWO_SERVOS
 
     inline void _move_nozzle_servo(const uint8_t e, const uint8_t angle_index) {
       constexpr int8_t  sns_index[2] = { SWITCHING_NOZZLE_SERVO_NR, SWITCHING_NOZZLE_E1_SERVO_NR };
       constexpr int16_t sns_angles[2] = SWITCHING_NOZZLE_SERVO_ANGLES;
       planner.synchronize();
       servo[sns_index[e]].move(sns_angles[angle_index]);
-      safe_delay(500);
+      safe_delay(SWITCHING_NOZZLE_SERVO_DWELL);
     }
 
     void lower_nozzle(const uint8_t e) { _move_nozzle_servo(e, 0); }
     void raise_nozzle(const uint8_t e) { _move_nozzle_servo(e, 1); }
 
   #else
 
     void move_nozzle_servo(const uint8_t angle_index) {
       planner.synchronize();
       servo[SWITCHING_NOZZLE_SERVO_NR].move(servo_angles[SWITCHING_NOZZLE_SERVO_NR][angle_index]);
-      safe_delay(500);
+      safe_delay(SWITCHING_NOZZLE_SERVO_DWELL);
     }
 
   #endif
 
 #endif // SWITCHING_NOZZLE
 
 // Move to position routines
 void _line_to_current(const AxisEnum fr_axis, const float fscale=1) {
   line_to_current_position(planner.settings.max_feedrate_mm_s[fr_axis] * fscale);
 }

commit e4e6abe5af0f97ff5cb0c9334cb298d3584968e3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 9 00:51:08 2022 -0500

    üßë‚Äçüíª Remove servo macros

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index e2f1443048..4b292c92f9 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -109,47 +109,47 @@
 
   #if EXTRUDERS > 3
     #define _SERVO_NR(E) ((E) < 2 ? SWITCHING_EXTRUDER_SERVO_NR : SWITCHING_EXTRUDER_E23_SERVO_NR)
   #else
     #define _SERVO_NR(E) SWITCHING_EXTRUDER_SERVO_NR
   #endif
 
   void move_extruder_servo(const uint8_t e) {
     planner.synchronize();
     if ((EXTRUDERS & 1) && e < EXTRUDERS - 1) {
-      MOVE_SERVO(_SERVO_NR(e), servo_angles[_SERVO_NR(e)][e & 1]);
+      servo[_SERVO_NR(e)].move(servo_angles[_SERVO_NR(e)][e & 1]);
       safe_delay(500);
     }
   }
 
 #endif // DO_SWITCH_EXTRUDER
 
 #if ENABLED(SWITCHING_NOZZLE)
 
   #if SWITCHING_NOZZLE_TWO_SERVOS
 
     inline void _move_nozzle_servo(const uint8_t e, const uint8_t angle_index) {
       constexpr int8_t  sns_index[2] = { SWITCHING_NOZZLE_SERVO_NR, SWITCHING_NOZZLE_E1_SERVO_NR };
       constexpr int16_t sns_angles[2] = SWITCHING_NOZZLE_SERVO_ANGLES;
       planner.synchronize();
-      MOVE_SERVO(sns_index[e], sns_angles[angle_index]);
+      servo[sns_index[e]].move(sns_angles[angle_index]);
       safe_delay(500);
     }
 
     void lower_nozzle(const uint8_t e) { _move_nozzle_servo(e, 0); }
     void raise_nozzle(const uint8_t e) { _move_nozzle_servo(e, 1); }
 
   #else
 
     void move_nozzle_servo(const uint8_t angle_index) {
       planner.synchronize();
-      MOVE_SERVO(SWITCHING_NOZZLE_SERVO_NR, servo_angles[SWITCHING_NOZZLE_SERVO_NR][angle_index]);
+      servo[SWITCHING_NOZZLE_SERVO_NR].move(servo_angles[SWITCHING_NOZZLE_SERVO_NR][angle_index]);
       safe_delay(500);
     }
 
   #endif
 
 #endif // SWITCHING_NOZZLE
 
 // Move to position routines
 void _line_to_current(const AxisEnum fr_axis, const float fscale=1) {
   line_to_current_position(planner.settings.max_feedrate_mm_s[fr_axis] * fscale);
@@ -436,21 +436,21 @@ void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.
         sensor_tries++;
         if (sensor_tries > 10) return -1;
         safe_delay(5);
       }
     }
   }
 
   inline void switching_toolhead_lock(const bool locked) {
     #ifdef SWITCHING_TOOLHEAD_SERVO_ANGLES
       const uint16_t swt_angles[2] = SWITCHING_TOOLHEAD_SERVO_ANGLES;
-      MOVE_SERVO(SWITCHING_TOOLHEAD_SERVO_NR, swt_angles[locked ? 0 : 1]);
+      servo[SWITCHING_TOOLHEAD_SERVO_NR].move(swt_angles[locked ? 0 : 1]);
     #elif PIN_EXISTS(SWT_SOLENOID)
       OUT_WRITE(SWT_SOLENOID_PIN, locked);
       gcode.dwell(10);
     #else
       #error "No toolhead locking mechanism configured."
     #endif
   }
 
   #include <bitset>
 

commit 6ee34331b7a0e5ea82768f4df5f3956ce5322742
Author: Robert Brenckman <Robbery525@gmail.com>
Date:   Sun Apr 10 01:24:07 2022 -0400

    üêõ Fix Tool Change priming (#21142)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 588322caa5..e2f1443048 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -25,31 +25,31 @@
 #include "tool_change.h"
 
 #include "probe.h"
 #include "motion.h"
 #include "planner.h"
 #include "temperature.h"
 
 #include "../MarlinCore.h"
 
 //#define DEBUG_TOOL_CHANGE
+//#define DEBUG_TOOLCHANGE_FILAMENT_SWAP
 
 #define DEBUG_OUT ENABLED(DEBUG_TOOL_CHANGE)
 #include "../core/debug_out.h"
 
 #if HAS_MULTI_EXTRUDER
   toolchange_settings_t toolchange_settings;  // Initialized by settings.load()
 #endif
 
 #if ENABLED(TOOLCHANGE_MIGRATION_FEATURE)
   migration_settings_t migration = migration_defaults;
-  bool enable_first_prime;
 #endif
 
 #if ENABLED(TOOLCHANGE_FS_INIT_BEFORE_SWAP)
   Flags<EXTRUDERS> toolchange_extruder_ready;
 #endif
 
 #if EITHER(MAGNETIC_PARKING_EXTRUDER, TOOL_SENSOR) \
   || defined(EVENT_GCODE_TOOLCHANGE_T0) || defined(EVENT_GCODE_TOOLCHANGE_T1) || defined(EVENT_GCODE_AFTER_TOOLCHANGE) \
   || (ENABLED(PARKING_EXTRUDER) && PARKING_EXTRUDER_SOLENOIDS_DELAY > 0)
   #include "../gcode/gcode.h"
@@ -143,20 +143,21 @@
     void move_nozzle_servo(const uint8_t angle_index) {
       planner.synchronize();
       MOVE_SERVO(SWITCHING_NOZZLE_SERVO_NR, servo_angles[SWITCHING_NOZZLE_SERVO_NR][angle_index]);
       safe_delay(500);
     }
 
   #endif
 
 #endif // SWITCHING_NOZZLE
 
+// Move to position routines
 void _line_to_current(const AxisEnum fr_axis, const float fscale=1) {
   line_to_current_position(planner.settings.max_feedrate_mm_s[fr_axis] * fscale);
 }
 void slow_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.2f); }
 void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.5f); }
 
 #if ENABLED(MAGNETIC_PARKING_EXTRUDER)
 
   float parkingposx[2],           // M951 R L
         parkinggrabdistance,      // M951 I
@@ -892,24 +893,149 @@ void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.
     DEBUG_POS("New extruder (parked)", current_position);
   }
 
 #endif // DUAL_X_CARRIAGE
 
 /**
  * Prime active tool using TOOLCHANGE_FILAMENT_SWAP settings
  */
 #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
 
+  #ifdef DEBUG_TOOLCHANGE_FILAMENT_SWAP
+    #define FS_DEBUG(V...) SERIAL_ECHOLNPGM("DEBUG: " V)
+  #else
+    #define FS_DEBUG(...) NOOP
+  #endif
+
+  // Define any variables required
+  static Flags<EXTRUDERS> extruder_was_primed; // Extruders primed status
+
+  #if ENABLED(TOOLCHANGE_FS_PRIME_FIRST_USED)
+    bool enable_first_prime; // As set by M217 V
+  #endif
+
+  // Cool down with fan
+  inline void filament_swap_cooling() {
+    #if HAS_FAN && TOOLCHANGE_FS_FAN >= 0
+      thermalManager.fan_speed[TOOLCHANGE_FS_FAN] = toolchange_settings.fan_speed;
+      gcode.dwell(SEC_TO_MS(toolchange_settings.fan_time));
+      thermalManager.fan_speed[TOOLCHANGE_FS_FAN] = 0;
+    #endif
+  }
+
+  /**
+   * Check if too cold to move the specified tool
+   *
+   * Returns TRUE if too cold to move (also echos message: STR_ERR_HOTEND_TOO_COLD)
+   * Returns FALSE if able to  move.
+   */
+  bool too_cold(uint8_t toolID){
+    if (TERN0(PREVENT_COLD_EXTRUSION, !DEBUGGING(DRYRUN) && thermalManager.targetTooColdToExtrude(toolID))) {
+      SERIAL_ECHO_MSG(STR_ERR_HOTEND_TOO_COLD);
+      return true;
+    }
+    return false;
+  }
+
+  /**
+   * Cutting recovery -- Recover from cutting retraction that occurs at the end of nozzle priming
+   *
+   * If the active_extruder is up to temp (!too_cold):
+   *  Extrude filament distance = toolchange_settings.extra_resume + TOOLCHANGE_FS_WIPE_RETRACT
+   *  current_position.e = e;
+   *  sync_plan_position_e();
+   */
+  void extruder_cutting_recover(const_float_t e) {
+    if (!too_cold(active_extruder)) {
+      const float dist = toolchange_settings.extra_resume + (TOOLCHANGE_FS_WIPE_RETRACT);
+      FS_DEBUG("Performing Cutting Recover | Distance: ", dist, " | Speed: ", MMM_TO_MMS(toolchange_settings.unretract_speed), "mm/s");
+      unscaled_e_move(dist, MMM_TO_MMS(toolchange_settings.unretract_speed));
+      planner.synchronize();
+      FS_DEBUG("Set position to: ", e);
+      current_position.e = e;
+      sync_plan_position_e(); // Resume new E Position
+    }
+  }
+
+  /**
+   * Prime the currently selected extruder (Filament loading only)
+   *
+   * If too_cold(toolID) returns TRUE -> returns without moving extruder.
+   * Extruders filament = swap_length + extra prime, then performs cutting retraction if enabled.
+   * If cooling fan is enabled, calls filament_swap_cooling();
+   */
+  void extruder_prime() {
+
+    if (too_cold(active_extruder)) {
+      FS_DEBUG("Priming Aborted -  Nozzle Too Cold!");
+      return; // Extruder too cold to prime
+    }
+
+    float fr = toolchange_settings.unretract_speed; // Set default speed for unretract
+
+    #if ENABLED(TOOLCHANGE_FS_SLOW_FIRST_PRIME)
+    /*
+     * Perform first unretract movement at the slower Prime_Speed to avoid breakage on first prime
+     */
+    static Flags<EXTRUDERS> extruder_did_first_prime;  // Extruders first priming status
+    if (!extruder_did_first_prime[active_extruder]) {
+      extruder_did_first_prime.set(active_extruder);   // Log first prime complete
+      // new nozzle - prime at user-specified speed.
+      FS_DEBUG("First time priming T", active_extruder, ", reducing speed from ", MMM_TO_MMS(fr), " to ",  MMM_TO_MMS(toolchange_settings.prime_speed), "mm/s");
+      fr = toolchange_settings.prime_speed;
+      unscaled_e_move(0, MMM_TO_MMS(fr));      // Init planner with 0 length move
+    }
+    #endif
+
+    //Calculate and perform the priming distance
+    if (toolchange_settings.extra_prime >= 0) {
+      // Positive extra_prime value
+      // - Return filament at speed (fr) then extra_prime at prime speed
+      FS_DEBUG("Loading Filament for T", active_extruder, " | Distance: ", toolchange_settings.swap_length, " | Speed: ", MMM_TO_MMS(fr), "mm/s");
+      unscaled_e_move(toolchange_settings.swap_length, MMM_TO_MMS(fr)); // Prime (Unretract) filament by extruding equal to Swap Length (Unretract)
+
+      if (toolchange_settings.extra_prime > 0) {
+        FS_DEBUG("Performing Extra Priming for T", active_extruder, " | Distance: ", toolchange_settings.extra_prime, " | Speed: ", MMM_TO_MMS(toolchange_settings.prime_speed), "mm/s");
+        unscaled_e_move(toolchange_settings.extra_prime, MMM_TO_MMS(toolchange_settings.prime_speed)); // Extra Prime Distance
+      }
+    }
+    else {
+      // Negative extra_prime value
+      // - Unretract distance (swap length) is reduced by the value of extra_prime
+      const float eswap = toolchange_settings.swap_length + toolchange_settings.extra_prime;
+      FS_DEBUG("Negative ExtraPrime value - Swap Return Length has been reduced from ", toolchange_settings.swap_length, " to ", eswap);
+      FS_DEBUG("Loading Filament for T", active_extruder, " | Distance: ", eswap, " | Speed: ", MMM_TO_MMS(fr), "mm/s");
+      unscaled_e_move(eswap, MMM_TO_MMS(fr));
+    }
+
+    extruder_was_primed.set(active_extruder); // Log that this extruder has been primed
+
+    // Cutting retraction
+    #if TOOLCHANGE_FS_WIPE_RETRACT
+      FS_DEBUG("Performing Cutting Retraction | Distance: ", -(TOOLCHANGE_FS_WIPE_RETRACT), " | Speed: ", MMM_TO_MMS(toolchange_settings.retract_speed), "mm/s");
+      unscaled_e_move(-(TOOLCHANGE_FS_WIPE_RETRACT), MMM_TO_MMS(toolchange_settings.retract_speed));
+    #endif
+
+    // Cool down with fan
+    filament_swap_cooling();
+
+  }
+
+  /**
+   * Sequence to Prime the currently selected extruder
+   * Raise Z, move the ToolChange_Park if enabled, prime the extruder, move back.
+   */
   void tool_change_prime() {
-    if (toolchange_settings.extra_prime > 0
-      && TERN(PREVENT_COLD_EXTRUSION, !thermalManager.targetTooColdToExtrude(active_extruder), 1)
-    ) {
+
+    FS_DEBUG(">>> tool_change_prime()");
+
+    if (!too_cold(active_extruder)) {
       destination = current_position; // Remember the old position
 
       const bool ok = TERN1(TOOLCHANGE_PARK, all_axes_homed() && toolchange_settings.enable_park);
 
       #if HAS_FAN && TOOLCHANGE_FS_FAN >= 0
         // Store and stop fan. Restored on any exit.
         REMEMBER(fan, thermalManager.fan_speed[TOOLCHANGE_FS_FAN], 0);
       #endif
 
       // Z raise
@@ -934,54 +1060,39 @@ void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.
               current_position.u = toolchange_settings.change_point.u,
               current_position.v = toolchange_settings.change_point.v,
               current_position.w = toolchange_settings.change_point.w
             );
           #endif
           planner.buffer_line(current_position, MMM_TO_MMS(TOOLCHANGE_PARK_XY_FEEDRATE), active_extruder);
           planner.synchronize();
         }
       #endif
 
-      // Prime (All distances are added and slowed down to ensure secure priming in all circumstances)
-      unscaled_e_move(toolchange_settings.swap_length + toolchange_settings.extra_prime, MMM_TO_MMS(toolchange_settings.prime_speed));
-
-      // Cutting retraction
-      #if TOOLCHANGE_FS_WIPE_RETRACT
-        unscaled_e_move(-(TOOLCHANGE_FS_WIPE_RETRACT), MMM_TO_MMS(toolchange_settings.retract_speed));
-      #endif
-
-      // Cool down with fan
-      #if HAS_FAN && TOOLCHANGE_FS_FAN >= 0
-        thermalManager.fan_speed[TOOLCHANGE_FS_FAN] = toolchange_settings.fan_speed;
-        gcode.dwell(SEC_TO_MS(toolchange_settings.fan_time));
-        thermalManager.fan_speed[TOOLCHANGE_FS_FAN] = 0;
-      #endif
+      extruder_prime();
 
       // Move back
       #if ENABLED(TOOLCHANGE_PARK)
         if (ok) {
           #if ENABLED(TOOLCHANGE_NO_RETURN)
             const float temp = destination.z;
             destination = current_position;
             destination.z = temp;
           #endif
           prepare_internal_move_to_destination(TERN(TOOLCHANGE_NO_RETURN, planner.settings.max_feedrate_mm_s[Z_AXIS], MMM_TO_MMS(TOOLCHANGE_PARK_XY_FEEDRATE)));
         }
       #endif
 
-      // Cutting recover
-      unscaled_e_move(toolchange_settings.extra_resume + TOOLCHANGE_FS_WIPE_RETRACT, MMM_TO_MMS(toolchange_settings.unretract_speed));
-
-      // Resume at the old E position
-      current_position.e = destination.e;
-      sync_plan_position_e();
+      extruder_cutting_recover(destination.e); // Cutting recover
     }
+
+    FS_DEBUG("<<< tool_change_prime");
+
   }
 
 #endif // TOOLCHANGE_FILAMENT_SWAP
 
 /**
  * Perform a tool-change, which may result in moving the
  * previous tool out of the way and the new tool into place.
  */
 void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
 
@@ -1044,26 +1155,24 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
     #endif
 
     const uint8_t old_tool = active_extruder;
     const bool can_move_away = !no_move && !idex_full_control;
 
     #if HAS_LEVELING
       // Set current position to the physical position
       TEMPORARY_BED_LEVELING_STATE(false);
     #endif
 
-    // First tool priming. To prime again, reboot the machine.
+    // First tool priming. To prime again, reboot the machine. -- Should only occur for first T0 after powerup!
     #if ENABLED(TOOLCHANGE_FS_PRIME_FIRST_USED)
-      static bool first_tool_is_primed = false;
-      if (new_tool == old_tool && !first_tool_is_primed && enable_first_prime) {
+      if (enable_first_prime && old_tool == 0 && new_tool == 0 && !extruder_was_primed[0]) {
         tool_change_prime();
-        first_tool_is_primed = true;
         TERN_(TOOLCHANGE_FS_INIT_BEFORE_SWAP, toolchange_extruder_ready.set(old_tool)); // Primed and initialized
       }
     #endif
 
     if (new_tool != old_tool || TERN0(PARKING_EXTRUDER, extruder_parked)) { // PARKING_EXTRUDER may need to attach old_tool when homing
       destination = current_position;
 
       #if BOTH(TOOLCHANGE_FILAMENT_SWAP, HAS_FAN) && TOOLCHANGE_FS_FAN >= 0
         // Store and stop fan. Restored on any exit.
         REMEMBER(fan, thermalManager.fan_speed[TOOLCHANGE_FS_FAN], 0);
@@ -1075,34 +1184,31 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
           // Do a small lift to avoid the workpiece in the move back (below)
           current_position.z += toolchange_settings.z_raise;
           TERN_(HAS_SOFTWARE_ENDSTOPS, NOMORE(current_position.z, soft_endstop.max.z));
           fast_line_to_current(Z_AXIS);
           planner.synchronize();
         }
       #endif
 
       // Unload / Retract
       #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
-        const bool should_swap = can_move_away && toolchange_settings.swap_length,
-                   too_cold = TERN0(PREVENT_COLD_EXTRUSION,
-                     !DEBUGGING(DRYRUN) && (thermalManager.targetTooColdToExtrude(old_tool) || thermalManager.targetTooColdToExtrude(new_tool))
-                   );
+        const bool should_swap = can_move_away && toolchange_settings.swap_length;
         if (should_swap) {
-          if (too_cold) {
-            SERIAL_ECHO_MSG(STR_ERR_HOTEND_TOO_COLD);
+          if (too_cold(old_tool)) {
+            // If SingleNozzle setup is too cold, unable to perform tool_change.
             if (ENABLED(SINGLENOZZLE)) { active_extruder = new_tool; return; }
           }
-          else {
-            // For first new tool, change without unloading the old. 'Just prime/init the new'
-            if (TERN1(TOOLCHANGE_FS_PRIME_FIRST_USED, first_tool_is_primed))
-              unscaled_e_move(-toolchange_settings.swap_length, MMM_TO_MMS(toolchange_settings.retract_speed));
-            TERN_(TOOLCHANGE_FS_PRIME_FIRST_USED, first_tool_is_primed = true); // The first new tool will be primed by toolchanging
+          else if (extruder_was_primed[old_tool]) {
+            // Retract the old extruder if it was previously primed
+            // To-Do: Should SingleNozzle always retract?
+            FS_DEBUG("Retracting Filament for T", old_tool, ". | Distance: ", toolchange_settings.swap_length, " | Speed: ", MMM_TO_MMS(toolchange_settings.retract_speed), "mm/s");
+            unscaled_e_move(-toolchange_settings.swap_length, MMM_TO_MMS(toolchange_settings.retract_speed));
           }
         }
       #endif
 
       TERN_(SWITCHING_NOZZLE_TWO_SERVOS, raise_nozzle(old_tool));
 
       REMEMBER(fr, feedrate_mm_s, XY_PROBE_FEEDRATE_MM_S);
 
       #if HAS_SOFTWARE_ENDSTOPS
         #if HAS_HOTEND_OFFSET
@@ -1203,50 +1309,22 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
 
       // Return to position and lower again
       const bool should_move = safe_to_move && !no_move && IsRunning();
       if (should_move) {
 
         #if EITHER(SINGLENOZZLE_STANDBY_TEMP, SINGLENOZZLE_STANDBY_FAN)
           thermalManager.singlenozzle_change(old_tool, new_tool);
         #endif
 
         #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
-          if (should_swap && !too_cold) {
-
-            float fr = toolchange_settings.unretract_speed;
-
-            #if ENABLED(TOOLCHANGE_FS_INIT_BEFORE_SWAP)
-              if (!toolchange_extruder_ready[new_tool]) {
-                toolchange_extruder_ready.set(new_tool);
-                fr = toolchange_settings.prime_speed;       // Next move is a prime
-                unscaled_e_move(0, MMM_TO_MMS(fr));         // Init planner with 0 length move
-              }
-            #endif
-
-            // Unretract (or Prime)
-            unscaled_e_move(toolchange_settings.swap_length, MMM_TO_MMS(fr));
-
-            // Extra Prime
-            unscaled_e_move(toolchange_settings.extra_prime, MMM_TO_MMS(toolchange_settings.prime_speed));
-
-            // Cutting retraction
-            #if TOOLCHANGE_FS_WIPE_RETRACT
-              unscaled_e_move(-(TOOLCHANGE_FS_WIPE_RETRACT), MMM_TO_MMS(toolchange_settings.retract_speed));
-            #endif
-
-            // Cool down with fan
-            #if HAS_FAN && TOOLCHANGE_FS_FAN >= 0
-              thermalManager.fan_speed[TOOLCHANGE_FS_FAN] = toolchange_settings.fan_speed;
-              gcode.dwell(SEC_TO_MS(toolchange_settings.fan_time));
-              thermalManager.fan_speed[TOOLCHANGE_FS_FAN] = 0;
-            #endif
-          }
+          if (should_swap && !too_cold(active_extruder))
+            extruder_prime(); // Prime selected Extruder
         #endif
 
         // Prevent a move outside physical bounds
         #if ENABLED(MAGNETIC_SWITCHING_TOOLHEAD)
           // If the original position is within tool store area, go to X origin at once
           if (destination.y < SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_CLEAR) {
             current_position.x = X_MIN_POS;
             planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], new_tool);
             planner.synchronize();
           }
@@ -1273,25 +1351,22 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
               do_blocking_move_to_xy(destination, planner.settings.max_feedrate_mm_s[X_AXIS]);
               do_blocking_move_to_z(destination.z, planner.settings.max_feedrate_mm_s[Z_AXIS]);
             #endif
 
           #endif
         }
 
         else DEBUG_ECHOLNPGM("Move back skipped");
 
         #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
-          if (should_swap && !too_cold) {
-            // Cutting recover
-            unscaled_e_move(toolchange_settings.extra_resume + TOOLCHANGE_FS_WIPE_RETRACT, MMM_TO_MMS(toolchange_settings.unretract_speed));
-            current_position.e = 0;
-            sync_plan_position_e(); // New extruder primed and set to 0
+          if (should_swap && !too_cold(active_extruder)) {
+            extruder_cutting_recover(0); // New extruder primed and set to 0
 
             // Restart Fan
             #if HAS_FAN && TOOLCHANGE_FS_FAN >= 0
               RESTORE(fan);
             #endif
           }
         #endif
 
         TERN_(DUAL_X_CARRIAGE, idex_set_parked(false));
       }
@@ -1335,21 +1410,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
         if (new_tool == 1)
           gcode.process_subcommands_now(F(EVENT_GCODE_TOOLCHANGE_T1));
       #endif
 
       #ifdef EVENT_GCODE_AFTER_TOOLCHANGE
         if (TERN1(DUAL_X_CARRIAGE, dual_x_carriage_mode == DXC_AUTO_PARK_MODE))
           gcode.process_subcommands_now(F(EVENT_GCODE_AFTER_TOOLCHANGE));
       #endif
     }
 
-    SERIAL_ECHO_MSG(STR_ACTIVE_EXTRUDER, active_extruder);
+    SERIAL_ECHOLNPGM(STR_ACTIVE_EXTRUDER, active_extruder);
 
   #endif // HAS_MULTI_EXTRUDER
 }
 
 #if ENABLED(TOOLCHANGE_MIGRATION_FEATURE)
 
   #define DEBUG_OUT ENABLED(DEBUG_TOOLCHANGE_MIGRATION_FEATURE)
   #include "../core/debug_out.h"
 
   bool extruder_migration() {

commit 6567e0e0aa0dc429dcfc65870a7471b55c63f506
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 9 19:17:04 2022 -0500

    üé® Misc. 9-axis cleanup

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 95076c96d2..588322caa5 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -926,21 +926,21 @@ void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.
         if (ok) {
           IF_DISABLED(TOOLCHANGE_PARK_Y_ONLY, current_position.x = toolchange_settings.change_point.x);
           IF_DISABLED(TOOLCHANGE_PARK_X_ONLY, current_position.y = toolchange_settings.change_point.y);
           #if NONE(TOOLCHANGE_PARK_X_ONLY, TOOLCHANGE_PARK_Y_ONLY)
             SECONDARY_AXIS_CODE(
               current_position.i = toolchange_settings.change_point.i,
               current_position.j = toolchange_settings.change_point.j,
               current_position.k = toolchange_settings.change_point.k,
               current_position.u = toolchange_settings.change_point.u,
               current_position.v = toolchange_settings.change_point.v,
-              current_position.w = toolchange_settings.change_point.w,
+              current_position.w = toolchange_settings.change_point.w
             );
           #endif
           planner.buffer_line(current_position, MMM_TO_MMS(TOOLCHANGE_PARK_XY_FEEDRATE), active_extruder);
           planner.synchronize();
         }
       #endif
 
       // Prime (All distances are added and slowed down to ensure secure priming in all circumstances)
       unscaled_e_move(toolchange_settings.swap_length + toolchange_settings.extra_prime, MMM_TO_MMS(toolchange_settings.prime_speed));
 
@@ -1131,21 +1131,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
         if (can_move_away && toolchange_settings.enable_park) {
           IF_DISABLED(TOOLCHANGE_PARK_Y_ONLY, current_position.x = toolchange_settings.change_point.x);
           IF_DISABLED(TOOLCHANGE_PARK_X_ONLY, current_position.y = toolchange_settings.change_point.y);
           #if NONE(TOOLCHANGE_PARK_X_ONLY, TOOLCHANGE_PARK_Y_ONLY)
             SECONDARY_AXIS_CODE(
               current_position.i = toolchange_settings.change_point.i,
               current_position.j = toolchange_settings.change_point.j,
               current_position.k = toolchange_settings.change_point.k,
               current_position.u = toolchange_settings.change_point.u,
               current_position.v = toolchange_settings.change_point.v,
-              current_position.w = toolchange_settings.change_point.w,
+              current_position.w = toolchange_settings.change_point.w
             );
           #endif
           planner.buffer_line(current_position, MMM_TO_MMS(TOOLCHANGE_PARK_XY_FEEDRATE), old_tool);
           planner.synchronize();
         }
       #endif
 
       #if HAS_HOTEND_OFFSET
         xyz_pos_t diff = hotend_offset[new_tool] - hotend_offset[old_tool];
         TERN_(DUAL_X_CARRIAGE, diff.x = 0);

commit c4873a64ecd54dc0bbccb1eaeecd1b5ae2f6aef5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Apr 3 16:14:02 2022 -0500

    üßë‚Äçüíª General and Axis-based bitfield flags (#23989)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 8a62d00782..95076c96d2 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -39,21 +39,21 @@
 #if HAS_MULTI_EXTRUDER
   toolchange_settings_t toolchange_settings;  // Initialized by settings.load()
 #endif
 
 #if ENABLED(TOOLCHANGE_MIGRATION_FEATURE)
   migration_settings_t migration = migration_defaults;
   bool enable_first_prime;
 #endif
 
 #if ENABLED(TOOLCHANGE_FS_INIT_BEFORE_SWAP)
-  bool toolchange_extruder_ready[EXTRUDERS];
+  Flags<EXTRUDERS> toolchange_extruder_ready;
 #endif
 
 #if EITHER(MAGNETIC_PARKING_EXTRUDER, TOOL_SENSOR) \
   || defined(EVENT_GCODE_TOOLCHANGE_T0) || defined(EVENT_GCODE_TOOLCHANGE_T1) || defined(EVENT_GCODE_AFTER_TOOLCHANGE) \
   || (ENABLED(PARKING_EXTRUDER) && PARKING_EXTRUDER_SOLENOIDS_DELAY > 0)
   #include "../gcode/gcode.h"
 #endif
 
 #if ENABLED(TOOL_SENSOR)
   #include "../lcd/marlinui.h"
@@ -1050,21 +1050,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
       // Set current position to the physical position
       TEMPORARY_BED_LEVELING_STATE(false);
     #endif
 
     // First tool priming. To prime again, reboot the machine.
     #if ENABLED(TOOLCHANGE_FS_PRIME_FIRST_USED)
       static bool first_tool_is_primed = false;
       if (new_tool == old_tool && !first_tool_is_primed && enable_first_prime) {
         tool_change_prime();
         first_tool_is_primed = true;
-        TERN_(TOOLCHANGE_FS_INIT_BEFORE_SWAP, toolchange_extruder_ready[old_tool] = true); // Primed and initialized
+        TERN_(TOOLCHANGE_FS_INIT_BEFORE_SWAP, toolchange_extruder_ready.set(old_tool)); // Primed and initialized
       }
     #endif
 
     if (new_tool != old_tool || TERN0(PARKING_EXTRUDER, extruder_parked)) { // PARKING_EXTRUDER may need to attach old_tool when homing
       destination = current_position;
 
       #if BOTH(TOOLCHANGE_FILAMENT_SWAP, HAS_FAN) && TOOLCHANGE_FS_FAN >= 0
         // Store and stop fan. Restored on any exit.
         REMEMBER(fan, thermalManager.fan_speed[TOOLCHANGE_FS_FAN], 0);
       #endif
@@ -1209,21 +1209,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
           thermalManager.singlenozzle_change(old_tool, new_tool);
         #endif
 
         #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
           if (should_swap && !too_cold) {
 
             float fr = toolchange_settings.unretract_speed;
 
             #if ENABLED(TOOLCHANGE_FS_INIT_BEFORE_SWAP)
               if (!toolchange_extruder_ready[new_tool]) {
-                toolchange_extruder_ready[new_tool] = true;
+                toolchange_extruder_ready.set(new_tool);
                 fr = toolchange_settings.prime_speed;       // Next move is a prime
                 unscaled_e_move(0, MMM_TO_MMS(fr));         // Init planner with 0 length move
               }
             #endif
 
             // Unretract (or Prime)
             unscaled_e_move(toolchange_settings.swap_length, MMM_TO_MMS(fr));
 
             // Extra Prime
             unscaled_e_move(toolchange_settings.extra_prime, MMM_TO_MMS(toolchange_settings.prime_speed));
@@ -1394,21 +1394,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
     planner.synchronize();
 
     // Remember position before migration
     const float resume_current_e = current_position.e;
 
     // Migrate the flow
     planner.set_flow(migration_extruder, planner.flow_percentage[active_extruder]);
 
     // Migrate the retracted state
     #if ENABLED(FWRETRACT)
-      fwretract.retracted[migration_extruder] = fwretract.retracted[active_extruder];
+      fwretract.retracted.set(migration_extruder, fwretract.retracted[active_extruder]);
     #endif
 
     // Migrate the temperature to the new hotend
     #if HAS_MULTI_HOTEND
       thermalManager.setTargetHotend(thermalManager.degTargetHotend(active_extruder), migration_extruder);
       TERN_(AUTOTEMP, planner.autotemp_update());
       thermalManager.set_heating_message(0);
       thermalManager.wait_for_hotend(active_extruder);
     #endif
 

commit e5b651f407fcb743e2d00c45b0d361fb98230efb
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Fri Apr 1 07:10:38 2022 +0200

    ‚ú® Support for up to 9 axes (linear, rotary) (#23112)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 26815642db..8a62d00782 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -919,20 +919,30 @@ void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.
         TERN_(HAS_SOFTWARE_ENDSTOPS, NOMORE(current_position.z, soft_endstop.max.z));
         fast_line_to_current(Z_AXIS);
         planner.synchronize();
       }
 
       // Park
       #if ENABLED(TOOLCHANGE_PARK)
         if (ok) {
           IF_DISABLED(TOOLCHANGE_PARK_Y_ONLY, current_position.x = toolchange_settings.change_point.x);
           IF_DISABLED(TOOLCHANGE_PARK_X_ONLY, current_position.y = toolchange_settings.change_point.y);
+          #if NONE(TOOLCHANGE_PARK_X_ONLY, TOOLCHANGE_PARK_Y_ONLY)
+            SECONDARY_AXIS_CODE(
+              current_position.i = toolchange_settings.change_point.i,
+              current_position.j = toolchange_settings.change_point.j,
+              current_position.k = toolchange_settings.change_point.k,
+              current_position.u = toolchange_settings.change_point.u,
+              current_position.v = toolchange_settings.change_point.v,
+              current_position.w = toolchange_settings.change_point.w,
+            );
+          #endif
           planner.buffer_line(current_position, MMM_TO_MMS(TOOLCHANGE_PARK_XY_FEEDRATE), active_extruder);
           planner.synchronize();
         }
       #endif
 
       // Prime (All distances are added and slowed down to ensure secure priming in all circumstances)
       unscaled_e_move(toolchange_settings.swap_length + toolchange_settings.extra_prime, MMM_TO_MMS(toolchange_settings.prime_speed));
 
       // Cutting retraction
       #if TOOLCHANGE_FS_WIPE_RETRACT
@@ -1114,20 +1124,30 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
           TERN_(HAS_SOFTWARE_ENDSTOPS, NOMORE(current_position.z, soft_endstop.max.z));
           fast_line_to_current(Z_AXIS);
         }
       #endif
 
       // Toolchange park
       #if ENABLED(TOOLCHANGE_PARK) && DISABLED(SWITCHING_NOZZLE)
         if (can_move_away && toolchange_settings.enable_park) {
           IF_DISABLED(TOOLCHANGE_PARK_Y_ONLY, current_position.x = toolchange_settings.change_point.x);
           IF_DISABLED(TOOLCHANGE_PARK_X_ONLY, current_position.y = toolchange_settings.change_point.y);
+          #if NONE(TOOLCHANGE_PARK_X_ONLY, TOOLCHANGE_PARK_Y_ONLY)
+            SECONDARY_AXIS_CODE(
+              current_position.i = toolchange_settings.change_point.i,
+              current_position.j = toolchange_settings.change_point.j,
+              current_position.k = toolchange_settings.change_point.k,
+              current_position.u = toolchange_settings.change_point.u,
+              current_position.v = toolchange_settings.change_point.v,
+              current_position.w = toolchange_settings.change_point.w,
+            );
+          #endif
           planner.buffer_line(current_position, MMM_TO_MMS(TOOLCHANGE_PARK_XY_FEEDRATE), old_tool);
           planner.synchronize();
         }
       #endif
 
       #if HAS_HOTEND_OFFSET
         xyz_pos_t diff = hotend_offset[new_tool] - hotend_offset[old_tool];
         TERN_(DUAL_X_CARRIAGE, diff.x = 0);
       #else
         constexpr xyz_pos_t diff{0};
@@ -1168,21 +1188,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
       (void)check_tool_sensor_stats(active_extruder, true);
 
       // The newly-selected extruder XYZ is actually at...
       DEBUG_ECHOLNPGM("Offset Tool XYZ by { ", diff.x, ", ", diff.y, ", ", diff.z, " }");
       current_position += diff;
 
       // Tell the planner the new "current position"
       sync_plan_position();
 
       #if ENABLED(DELTA)
-        //LOOP_LINEAR_AXES(i) update_software_endstops(i); // or modify the constrain function
+        //LOOP_NUM_AXES(i) update_software_endstops(i); // or modify the constrain function
         const bool safe_to_move = current_position.z < delta_clip_start_height - 1;
       #else
         constexpr bool safe_to_move = true;
       #endif
 
       // Return to position and lower again
       const bool should_move = safe_to_move && !no_move && IsRunning();
       if (should_move) {
 
         #if EITHER(SINGLENOZZLE_STANDBY_TEMP, SINGLENOZZLE_STANDBY_FAN)

commit 8ba6e8a74d1ddd963881dcd77e26a5dc0a7b6096
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Mar 22 20:31:36 2022 -0500

    üé® Clean up tool change with tool sensor

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index ceed05dcf3..26815642db 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -378,79 +378,73 @@ void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.
       pe_solenoid_set_pin_state(active_extruder, !PARKING_EXTRUDER_SOLENOIDS_PINS_ACTIVE);
       // Engage new extruder magnetic field
       pe_solenoid_set_pin_state(new_tool, PARKING_EXTRUDER_SOLENOIDS_PINS_ACTIVE);
     }
 
     do_solenoid_activation = true; // Activate solenoid for subsequent tool_change()
   }
 
 #endif // PARKING_EXTRUDER
 
-#if ENABLED(SWITCHING_TOOLHEAD)
+#if ENABLED(TOOL_SENSOR)
+
+  bool tool_sensor_disabled; // = false
 
   // Return a bitmask of tool sensor states
   inline uint8_t poll_tool_sensor_pins() {
     return (0
-      #if ENABLED(TOOL_SENSOR)
-        #if PIN_EXISTS(TOOL_SENSOR1)
-          | (READ(TOOL_SENSOR1_PIN) << 0)
-        #endif
-        #if PIN_EXISTS(TOOL_SENSOR2)
-          | (READ(TOOL_SENSOR2_PIN) << 1)
-        #endif
-        #if PIN_EXISTS(TOOL_SENSOR3)
-          | (READ(TOOL_SENSOR3_PIN) << 2)
-        #endif
-        #if PIN_EXISTS(TOOL_SENSOR4)
-          | (READ(TOOL_SENSOR4_PIN) << 3)
-        #endif
-        #if PIN_EXISTS(TOOL_SENSOR5)
-          | (READ(TOOL_SENSOR5_PIN) << 4)
-        #endif
-        #if PIN_EXISTS(TOOL_SENSOR6)
-          | (READ(TOOL_SENSOR6_PIN) << 5)
-        #endif
-        #if PIN_EXISTS(TOOL_SENSOR7)
-          | (READ(TOOL_SENSOR7_PIN) << 6)
-        #endif
-        #if PIN_EXISTS(TOOL_SENSOR8)
-          | (READ(TOOL_SENSOR8_PIN) << 7)
-        #endif
+      #if PIN_EXISTS(TOOL_SENSOR1)
+        | (READ(TOOL_SENSOR1_PIN) << 0)
+      #endif
+      #if PIN_EXISTS(TOOL_SENSOR2)
+        | (READ(TOOL_SENSOR2_PIN) << 1)
+      #endif
+      #if PIN_EXISTS(TOOL_SENSOR3)
+        | (READ(TOOL_SENSOR3_PIN) << 2)
+      #endif
+      #if PIN_EXISTS(TOOL_SENSOR4)
+        | (READ(TOOL_SENSOR4_PIN) << 3)
+      #endif
+      #if PIN_EXISTS(TOOL_SENSOR5)
+        | (READ(TOOL_SENSOR5_PIN) << 4)
+      #endif
+      #if PIN_EXISTS(TOOL_SENSOR6)
+        | (READ(TOOL_SENSOR6_PIN) << 5)
+      #endif
+      #if PIN_EXISTS(TOOL_SENSOR7)
+        | (READ(TOOL_SENSOR7_PIN) << 6)
+      #endif
+      #if PIN_EXISTS(TOOL_SENSOR8)
+        | (READ(TOOL_SENSOR8_PIN) << 7)
       #endif
     );
   }
 
-  #if ENABLED(TOOL_SENSOR)
-
-    bool tool_sensor_disabled; // = false
-
-    uint8_t check_tool_sensor_stats(const uint8_t tool_index, const bool kill_on_error/*=false*/, const bool disable/*=false*/) {
-      static uint8_t sensor_tries; // = 0
-      for (;;) {
-        if (poll_tool_sensor_pins() == _BV(tool_index)) {
-          sensor_tries = 0;
-          return tool_index;
-        }
-        else if (kill_on_error && (!tool_sensor_disabled || disable)) {
-          sensor_tries++;
-          if (sensor_tries > 10) kill(F("Tool Sensor error"));
-          safe_delay(5);
-        }
-        else {
-          sensor_tries++;
-          if (sensor_tries > 10) return -1;
-          safe_delay(5);
-        }
+  uint8_t check_tool_sensor_stats(const uint8_t tool_index, const bool kill_on_error/*=false*/, const bool disable/*=false*/) {
+    static uint8_t sensor_tries; // = 0
+    for (;;) {
+      if (poll_tool_sensor_pins() == _BV(tool_index)) {
+        sensor_tries = 0;
+        return tool_index;
+      }
+      else if (kill_on_error && (!tool_sensor_disabled || disable)) {
+        sensor_tries++;
+        if (sensor_tries > 10) kill(F("Tool Sensor error"));
+        safe_delay(5);
+      }
+      else {
+        sensor_tries++;
+        if (sensor_tries > 10) return -1;
+        safe_delay(5);
       }
     }
-
-  #endif
+  }
 
   inline void switching_toolhead_lock(const bool locked) {
     #ifdef SWITCHING_TOOLHEAD_SERVO_ANGLES
       const uint16_t swt_angles[2] = SWITCHING_TOOLHEAD_SERVO_ANGLES;
       MOVE_SERVO(SWITCHING_TOOLHEAD_SERVO_NR, swt_angles[locked ? 0 : 1]);
     #elif PIN_EXISTS(SWT_SOLENOID)
       OUT_WRITE(SWT_SOLENOID_PIN, locked);
       gcode.dwell(10);
     #else
       #error "No toolhead locking mechanism configured."
@@ -489,23 +483,27 @@ void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.
         SET_INPUT_PULLUP(TOOL_SENSOR8_PIN);
       #endif
 
       if (check_tool_sensor_stats(0)) {
         LCD_MESSAGE_F("TC error");
         switching_toolhead_lock(false);
         while (check_tool_sensor_stats(0)) { /* nada */ }
         switching_toolhead_lock(true);
       }
       LCD_MESSAGE_F("TC Success");
-    #endif
+    #endif // TOOL_SENSOR
   }
 
+#endif // TOOL_SENSOR
+
+#if ENABLED(SWITCHING_TOOLHEAD)
+
   inline void switching_toolhead_tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
     if (no_move) return;
 
     constexpr float toolheadposx[] = SWITCHING_TOOLHEAD_X_POS;
     const float placexpos = toolheadposx[active_extruder],
                 grabxpos = toolheadposx[new_tool];
 
     (void)check_tool_sensor_stats(active_extruder, true);
 
     /**

commit d3e3e6a4917969eba85f88e5de0366cc9a2eb4f1
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Mar 22 18:14:17 2022 -0500

    ü©π No PE_MAGNET_ON_STATE without PARKING_EXTRUDER

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index f2767f2b5b..ceed05dcf3 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -1285,21 +1285,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
       #endif
 
       TERN_(SWITCHING_NOZZLE_TWO_SERVOS, lower_nozzle(new_tool));
 
     } // (new_tool != old_tool)
 
     planner.synchronize();
 
     #if ENABLED(EXT_SOLENOID) && DISABLED(PARKING_EXTRUDER)
       disable_all_solenoids();
-      enable_solenoid_on_active_extruder();
+      enable_solenoid(active_extruder);
     #endif
 
     #if HAS_PRUSA_MMU1
       if (new_tool >= E_STEPPERS) return invalid_extruder_error(new_tool);
       select_multiplexed_stepper(new_tool);
     #endif
 
     #if DO_SWITCH_EXTRUDER
       planner.synchronize();
       move_extruder_servo(active_extruder);

commit ab46b7e2f298826a5512569d6e79bb59a7a6b8ea
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jan 25 15:33:03 2022 -0600

    üßë‚Äçüíª HAS_MARLINUI_MENU, HAS_MANUAL_MOVE_MENU

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 285b4cba84..f2767f2b5b 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -82,21 +82,21 @@
 #if HAS_FANMUX
   #include "../feature/fanmux.h"
 #endif
 
 #if HAS_PRUSA_MMU1
   #include "../feature/mmu/mmu.h"
 #elif HAS_PRUSA_MMU2
   #include "../feature/mmu/mmu2.h"
 #endif
 
-#if HAS_LCD_MENU
+#if HAS_MARLINUI_MENU
   #include "../lcd/marlinui.h"
 #endif
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   #include "../feature/pause.h"
 #endif
 
 #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
   #include "../gcode/gcode.h"
   #if TOOLCHANGE_FS_WIPE_RETRACT <= 0
@@ -1020,21 +1020,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
     #endif
 
     if (new_tool >= EXTRUDERS)
       return invalid_extruder_error(new_tool);
 
     if (!no_move && homing_needed()) {
       no_move = true;
       DEBUG_ECHOLNPGM("No move (not homed)");
     }
 
-    TERN_(HAS_LCD_MENU, if (!no_move) ui.update());
+    TERN_(HAS_MARLINUI_MENU, if (!no_move) ui.update());
 
     #if ENABLED(DUAL_X_CARRIAGE)
       const bool idex_full_control = dual_x_carriage_mode == DXC_FULL_CONTROL_MODE;
     #else
       constexpr bool idex_full_control = false;
     #endif
 
     const uint8_t old_tool = active_extruder;
     const bool can_move_away = !no_move && !idex_full_control;
 

commit d2b0939118827c49610058c41f521b789c827477
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Mon Oct 18 02:01:28 2021 -0400

    Fix Tool Change Park (#22968)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 81d85573af..285b4cba84 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -947,21 +947,21 @@ void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.
         gcode.dwell(SEC_TO_MS(toolchange_settings.fan_time));
         thermalManager.fan_speed[TOOLCHANGE_FS_FAN] = 0;
       #endif
 
       // Move back
       #if ENABLED(TOOLCHANGE_PARK)
         if (ok) {
           #if ENABLED(TOOLCHANGE_NO_RETURN)
             const float temp = destination.z;
             destination = current_position;
-            destination.z = temp.z;
+            destination.z = temp;
           #endif
           prepare_internal_move_to_destination(TERN(TOOLCHANGE_NO_RETURN, planner.settings.max_feedrate_mm_s[Z_AXIS], MMM_TO_MMS(TOOLCHANGE_PARK_XY_FEEDRATE)));
         }
       #endif
 
       // Cutting recover
       unscaled_e_move(toolchange_settings.extra_resume + TOOLCHANGE_FS_WIPE_RETRACT, MMM_TO_MMS(toolchange_settings.unretract_speed));
 
       // Resume at the old E position
       current_position.e = destination.e;

commit 95662d3aed0a31ea832407c042a5b0c56cd8a2db
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Fri Oct 15 15:56:59 2021 -0400

    ‚ú® Add option EVENT_GCODE_TOOLCHANGE_ALWAYS_RUN (#22960)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index b968537e71..81d85573af 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -1300,21 +1300,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
       select_multiplexed_stepper(new_tool);
     #endif
 
     #if DO_SWITCH_EXTRUDER
       planner.synchronize();
       move_extruder_servo(active_extruder);
     #endif
 
     TERN_(HAS_FANMUX, fanmux_switch(active_extruder));
 
-    if (!no_move) {
+    if (ENABLED(EVENT_GCODE_TOOLCHANGE_ALWAYS_RUN) || !no_move) {
       #ifdef EVENT_GCODE_TOOLCHANGE_T0
         if (new_tool == 0)
           gcode.process_subcommands_now(F(EVENT_GCODE_TOOLCHANGE_T0));
       #endif
 
       #ifdef EVENT_GCODE_TOOLCHANGE_T1
         if (new_tool == 1)
           gcode.process_subcommands_now(F(EVENT_GCODE_TOOLCHANGE_T1));
       #endif
 

commit 65b950a489c35b1d5547da3a504af4dad8cde3d7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 28 20:15:52 2021 -0500

    üé® Apply F() to kill / sendinfoscreen

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 7ac13e55cf..b968537e71 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -425,21 +425,21 @@ void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.
 
     uint8_t check_tool_sensor_stats(const uint8_t tool_index, const bool kill_on_error/*=false*/, const bool disable/*=false*/) {
       static uint8_t sensor_tries; // = 0
       for (;;) {
         if (poll_tool_sensor_pins() == _BV(tool_index)) {
           sensor_tries = 0;
           return tool_index;
         }
         else if (kill_on_error && (!tool_sensor_disabled || disable)) {
           sensor_tries++;
-          if (sensor_tries > 10) kill(PSTR("Tool Sensor error"));
+          if (sensor_tries > 10) kill(F("Tool Sensor error"));
           safe_delay(5);
         }
         else {
           sensor_tries++;
           if (sensor_tries > 10) return -1;
           safe_delay(5);
         }
       }
     }
 

commit 7f1286a11f87065c4e666985e679cf9c77d668bf
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 25 17:05:11 2021 -0500

    üé® Apply F() to status message

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index b695c9408c..7ac13e55cf 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -483,26 +483,26 @@ void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.
         SET_INPUT_PULLUP(TOOL_SENSOR6_PIN);
       #endif
       #if PIN_EXISTS(TOOL_SENSOR7)
         SET_INPUT_PULLUP(TOOL_SENSOR7_PIN);
       #endif
       #if PIN_EXISTS(TOOL_SENSOR8)
         SET_INPUT_PULLUP(TOOL_SENSOR8_PIN);
       #endif
 
       if (check_tool_sensor_stats(0)) {
-        ui.set_status_P("TC error");
+        LCD_MESSAGE_F("TC error");
         switching_toolhead_lock(false);
         while (check_tool_sensor_stats(0)) { /* nada */ }
         switching_toolhead_lock(true);
       }
-      ui.set_status_P("TC Success");
+      LCD_MESSAGE_F("TC Success");
     #endif
   }
 
   inline void switching_toolhead_tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
     if (no_move) return;
 
     constexpr float toolheadposx[] = SWITCHING_TOOLHEAD_X_POS;
     const float placexpos = toolheadposx[active_extruder],
                 grabxpos = toolheadposx[new_tool];
 

commit 59dac3a7e41ae7964686d9dff56baba821a278f7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 25 18:43:52 2021 -0500

    üé® Apply F() to G-code subcommands

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index cb551647d7..b695c9408c 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -1303,31 +1303,31 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
     #if DO_SWITCH_EXTRUDER
       planner.synchronize();
       move_extruder_servo(active_extruder);
     #endif
 
     TERN_(HAS_FANMUX, fanmux_switch(active_extruder));
 
     if (!no_move) {
       #ifdef EVENT_GCODE_TOOLCHANGE_T0
         if (new_tool == 0)
-          gcode.process_subcommands_now_P(PSTR(EVENT_GCODE_TOOLCHANGE_T0));
+          gcode.process_subcommands_now(F(EVENT_GCODE_TOOLCHANGE_T0));
       #endif
 
       #ifdef EVENT_GCODE_TOOLCHANGE_T1
         if (new_tool == 1)
-          gcode.process_subcommands_now_P(PSTR(EVENT_GCODE_TOOLCHANGE_T1));
+          gcode.process_subcommands_now(F(EVENT_GCODE_TOOLCHANGE_T1));
       #endif
 
       #ifdef EVENT_GCODE_AFTER_TOOLCHANGE
         if (TERN1(DUAL_X_CARRIAGE, dual_x_carriage_mode == DXC_AUTO_PARK_MODE))
-          gcode.process_subcommands_now_P(PSTR(EVENT_GCODE_AFTER_TOOLCHANGE));
+          gcode.process_subcommands_now(F(EVENT_GCODE_AFTER_TOOLCHANGE));
       #endif
     }
 
     SERIAL_ECHO_MSG(STR_ACTIVE_EXTRUDER, active_extruder);
 
   #endif // HAS_MULTI_EXTRUDER
 }
 
 #if ENABLED(TOOLCHANGE_MIGRATION_FEATURE)
 

commit 754b31918a73cb08c322102be5d3926d2ac59c18
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 9 04:57:05 2021 -0500

    üé® Fewer serial macros

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 8fffb2e640..cb551647d7 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -182,74 +182,74 @@ void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.
      *   3. Move to park position of new extruder
      *   4. Move high speed to approach park position of old extruder
      *   5. Move to park position of old extruder
      *   6. Move to starting position
      */
 
     // STEP 1
 
     current_position.x = mpe_settings.parking_xpos[new_tool] + offsetcompensation;
 
-    DEBUG_ECHOPAIR("(1) Move extruder ", new_tool);
+    DEBUG_ECHOPGM("(1) Move extruder ", new_tool);
     DEBUG_POS(" to new extruder ParkPos", current_position);
 
     planner.buffer_line(current_position, mpe_settings.fast_feedrate, new_tool);
     planner.synchronize();
 
     // STEP 2
 
     current_position.x = grabpos + offsetcompensation;
 
-    DEBUG_ECHOPAIR("(2) Couple extruder ", new_tool);
+    DEBUG_ECHOPGM("(2) Couple extruder ", new_tool);
     DEBUG_POS(" to new extruder GrabPos", current_position);
 
     planner.buffer_line(current_position, mpe_settings.slow_feedrate, new_tool);
     planner.synchronize();
 
     // Delay before moving tool, to allow magnetic coupling
     gcode.dwell(150);
 
     // STEP 3
 
     current_position.x = mpe_settings.parking_xpos[new_tool] + offsetcompensation;
 
-    DEBUG_ECHOPAIR("(3) Move extruder ", new_tool);
+    DEBUG_ECHOPGM("(3) Move extruder ", new_tool);
     DEBUG_POS(" back to new extruder ParkPos", current_position);
 
     planner.buffer_line(current_position, mpe_settings.slow_feedrate, new_tool);
     planner.synchronize();
 
     // STEP 4
 
     current_position.x = mpe_settings.parking_xpos[active_extruder] + (active_extruder == 0 ? MPE_TRAVEL_DISTANCE : -MPE_TRAVEL_DISTANCE) + offsetcompensation;
 
-    DEBUG_ECHOPAIR("(4) Move extruder ", new_tool);
+    DEBUG_ECHOPGM("(4) Move extruder ", new_tool);
     DEBUG_POS(" close to old extruder ParkPos", current_position);
 
     planner.buffer_line(current_position, mpe_settings.fast_feedrate, new_tool);
     planner.synchronize();
 
     // STEP 5
 
     current_position.x = mpe_settings.parking_xpos[active_extruder] + offsetcompensation;
 
-    DEBUG_ECHOPAIR("(5) Park extruder ", new_tool);
+    DEBUG_ECHOPGM("(5) Park extruder ", new_tool);
     DEBUG_POS(" at old extruder ParkPos", current_position);
 
     planner.buffer_line(current_position, mpe_settings.slow_feedrate, new_tool);
     planner.synchronize();
 
     // STEP 6
 
     current_position.x = oldx;
 
-    DEBUG_ECHOPAIR("(6) Move extruder ", new_tool);
+    DEBUG_ECHOPGM("(6) Move extruder ", new_tool);
     DEBUG_POS(" to starting position", current_position);
 
     planner.buffer_line(current_position, mpe_settings.fast_feedrate, new_tool);
     planner.synchronize();
 
     DEBUG_ECHOLNPGM("Autopark done.");
   }
 
 #elif ENABLED(PARKING_EXTRUDER)
 
@@ -270,23 +270,23 @@ void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.
   bool extruder_parked = true, do_solenoid_activation = true;
 
   // Modifies tool_change() behavior based on homing side
   bool parking_extruder_unpark_after_homing(const uint8_t final_tool, bool homed_towards_final_tool) {
     do_solenoid_activation = false; // Tell parking_extruder_tool_change to skip solenoid activation
 
     if (!extruder_parked) return false; // nothing to do
 
     if (homed_towards_final_tool) {
       pe_solenoid_magnet_off(1 - final_tool);
-      DEBUG_ECHOLNPAIR("Disengage magnet", 1 - final_tool);
+      DEBUG_ECHOLNPGM("Disengage magnet", 1 - final_tool);
       pe_solenoid_magnet_on(final_tool);
-      DEBUG_ECHOLNPAIR("Engage magnet", final_tool);
+      DEBUG_ECHOLNPGM("Engage magnet", final_tool);
       parking_extruder_set_parked(false);
       return false;
     }
 
     return true;
   }
 
   inline void parking_extruder_tool_change(const uint8_t new_tool, bool no_move) {
     if (!no_move) {
 
@@ -311,21 +311,21 @@ void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.
        */
 
       // STEP 1
 
       DEBUG_POS("Start PE Tool-Change", current_position);
 
       // Don't park the active_extruder unless unparked
       if (!extruder_parked) {
         current_position.x = parkingposx[active_extruder] + x_offset;
 
-        DEBUG_ECHOLNPAIR("(1) Park extruder ", active_extruder);
+        DEBUG_ECHOLNPGM("(1) Park extruder ", active_extruder);
         DEBUG_POS("Moving ParkPos", current_position);
 
         fast_line_to_current(X_AXIS);
 
         // STEP 2
 
         planner.synchronize();
         DEBUG_ECHOLNPGM("(2) Disengage magnet");
         pe_solenoid_magnet_off(active_extruder);
 
@@ -514,21 +514,21 @@ void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.
      * 3. Move to the new toolhead
      * 4. Grab and lock the new toolhead
      */
 
     // 1. Move to switch position of current toolhead
 
     DEBUG_POS("Start ST Tool-Change", current_position);
 
     current_position.x = placexpos;
 
-    DEBUG_ECHOLNPAIR("(1) Place old tool ", active_extruder);
+    DEBUG_ECHOLNPGM("(1) Place old tool ", active_extruder);
     DEBUG_POS("Move X SwitchPos", current_position);
 
     fast_line_to_current(X_AXIS);
 
     current_position.y = SWITCHING_TOOLHEAD_Y_POS - (SWITCHING_TOOLHEAD_Y_SECURITY);
 
     DEBUG_SYNCHRONIZE();
     DEBUG_POS("Move Y SwitchPos + Security", current_position);
 
     slow_line_to_current(Y_AXIS);
@@ -620,21 +620,21 @@ void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.
      * 3. Move to the new toolhead
      * 4. Grab the new toolhead and move to security position
      */
 
     DEBUG_POS("Start MST Tool-Change", current_position);
 
     // 1. Move to switch position current toolhead
 
     current_position.y = SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_CLEAR;
 
-    SERIAL_ECHOLNPAIR("(1) Place old tool ", active_extruder);
+    SERIAL_ECHOLNPGM("(1) Place old tool ", active_extruder);
     DEBUG_POS("Move Y SwitchPos + Security", current_position);
 
     fast_line_to_current(Y_AXIS);
 
     current_position.x = placexclear;
 
     DEBUG_SYNCHRONIZE();
     DEBUG_POS("Move X SwitchPos + Security", current_position);
 
     fast_line_to_current(X_AXIS);
@@ -752,31 +752,31 @@ void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.
 
     // 1. Raise Z-Axis to give enough clearance
 
     current_position.z += SWITCHING_TOOLHEAD_Z_HOP;
     DEBUG_POS("(1) Raise Z-Axis ", current_position);
     fast_line_to_current(Z_AXIS);
 
     // 2. Move to position near active extruder parking
 
     DEBUG_SYNCHRONIZE();
-    DEBUG_ECHOLNPAIR("(2) Move near active extruder parking", active_extruder);
+    DEBUG_ECHOLNPGM("(2) Move near active extruder parking", active_extruder);
     DEBUG_POS("Moving ParkPos", current_position);
 
     current_position.set(hoffs.x + placexpos,
                          hoffs.y + SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_CLEAR);
     fast_line_to_current(X_AXIS);
 
     // 3. Move gently to park position of active extruder
 
     DEBUG_SYNCHRONIZE();
-    SERIAL_ECHOLNPAIR("(3) Move gently to park position of active extruder", active_extruder);
+    SERIAL_ECHOLNPGM("(3) Move gently to park position of active extruder", active_extruder);
     DEBUG_POS("Moving ParkPos", current_position);
 
     current_position.y -= SWITCHING_TOOLHEAD_Y_CLEAR;
     slow_line_to_current(Y_AXIS);
 
     // 4. Disengage magnetic field, wait for delay
 
     planner.synchronize();
     DEBUG_ECHOLNPGM("(4) Disengage magnet");
     est_deactivate_solenoid();
@@ -851,53 +851,53 @@ void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.
       case DXC_MIRRORED_MODE:     DEBUG_ECHOLNPGM("MIRRORED");     break;
     }
 
     // Get the home position of the currently-active tool
     const float xhome = x_home_pos(active_extruder);
 
     if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE                  // If Auto-Park mode is enabled
         && IsRunning() && !no_move                                  // ...and movement is permitted
         && (delayed_move_time || current_position.x != xhome)       // ...and delayed_move_time is set OR not "already parked"...
     ) {
-      DEBUG_ECHOLNPAIR("MoveX to ", xhome);
+      DEBUG_ECHOLNPGM("MoveX to ", xhome);
       current_position.x = xhome;
       line_to_current_position(planner.settings.max_feedrate_mm_s[X_AXIS]);   // Park the current head
       planner.synchronize();
     }
 
     // Activate the new extruder ahead of calling set_axis_is_at_home!
     active_extruder = new_tool;
 
     // This function resets the max/min values - the current position may be overwritten below.
     set_axis_is_at_home(X_AXIS);
 
     DEBUG_POS("New Extruder", current_position);
 
     switch (dual_x_carriage_mode) {
       case DXC_FULL_CONTROL_MODE:
         // New current position is the position of the activated extruder
         current_position.x = inactive_extruder_x;
         // Save the inactive extruder's position (from the old current_position)
         inactive_extruder_x = destination.x;
-        DEBUG_ECHOLNPAIR("DXC Full Control curr.x=", current_position.x, " dest.x=", destination.x);
+        DEBUG_ECHOLNPGM("DXC Full Control curr.x=", current_position.x, " dest.x=", destination.x);
         break;
       case DXC_AUTO_PARK_MODE:
         idex_set_parked();
         break;
       default:
         break;
     }
 
     // Ensure X axis DIR pertains to the correct carriage
     stepper.set_directions();
 
-    DEBUG_ECHOLNPAIR("Active extruder parked: ", active_extruder_parked ? "yes" : "no");
+    DEBUG_ECHOLNPGM("Active extruder parked: ", active_extruder_parked ? "yes" : "no");
     DEBUG_POS("New extruder (parked)", current_position);
   }
 
 #endif // DUAL_X_CARRIAGE
 
 /**
  * Prime active tool using TOOLCHANGE_FILAMENT_SWAP settings
  */
 #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
 
@@ -1163,21 +1163,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
         move_nozzle_servo(new_tool);
       #endif
 
       IF_DISABLED(DUAL_X_CARRIAGE, active_extruder = new_tool); // Set the new active extruder
 
       TERN_(TOOL_SENSOR, tool_sensor_disabled = false);
 
       (void)check_tool_sensor_stats(active_extruder, true);
 
       // The newly-selected extruder XYZ is actually at...
-      DEBUG_ECHOLNPAIR("Offset Tool XYZ by { ", diff.x, ", ", diff.y, ", ", diff.z, " }");
+      DEBUG_ECHOLNPGM("Offset Tool XYZ by { ", diff.x, ", ", diff.y, ", ", diff.z, " }");
       current_position += diff;
 
       // Tell the planner the new "current position"
       sync_plan_position();
 
       #if ENABLED(DELTA)
         //LOOP_LINEAR_AXES(i) update_software_endstops(i); // or modify the constrain function
         const bool safe_to_move = current_position.z < delta_clip_start_height - 1;
       #else
         constexpr bool safe_to_move = true;

commit 536cf287a6f642aa3eccd290b421b0e3869f018a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Aug 21 18:00:55 2021 -0500

    üé® Misc code and spacing cleanup

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 6d69b8722d..8fffb2e640 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -911,23 +911,21 @@ void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.
 
       #if HAS_FAN && TOOLCHANGE_FS_FAN >= 0
         // Store and stop fan. Restored on any exit.
         REMEMBER(fan, thermalManager.fan_speed[TOOLCHANGE_FS_FAN], 0);
       #endif
 
       // Z raise
       if (ok) {
         // Do a small lift to avoid the workpiece in the move back (below)
         current_position.z += toolchange_settings.z_raise;
-        #if HAS_SOFTWARE_ENDSTOPS
-          NOMORE(current_position.z, soft_endstop.max.z);
-        #endif
+        TERN_(HAS_SOFTWARE_ENDSTOPS, NOMORE(current_position.z, soft_endstop.max.z));
         fast_line_to_current(Z_AXIS);
         planner.synchronize();
       }
 
       // Park
       #if ENABLED(TOOLCHANGE_PARK)
         if (ok) {
           IF_DISABLED(TOOLCHANGE_PARK_Y_ONLY, current_position.x = toolchange_settings.change_point.x);
           IF_DISABLED(TOOLCHANGE_PARK_X_ONLY, current_position.y = toolchange_settings.change_point.y);
           planner.buffer_line(current_position, MMM_TO_MMS(TOOLCHANGE_PARK_XY_FEEDRATE), active_extruder);
@@ -1061,23 +1059,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
       #if BOTH(TOOLCHANGE_FILAMENT_SWAP, HAS_FAN) && TOOLCHANGE_FS_FAN >= 0
         // Store and stop fan. Restored on any exit.
         REMEMBER(fan, thermalManager.fan_speed[TOOLCHANGE_FS_FAN], 0);
       #endif
 
       // Z raise before retraction
       #if ENABLED(TOOLCHANGE_ZRAISE_BEFORE_RETRACT) && DISABLED(SWITCHING_NOZZLE)
         if (can_move_away && TERN1(TOOLCHANGE_PARK, toolchange_settings.enable_park)) {
           // Do a small lift to avoid the workpiece in the move back (below)
           current_position.z += toolchange_settings.z_raise;
-          #if HAS_SOFTWARE_ENDSTOPS
-            NOMORE(current_position.z, soft_endstop.max.z);
-          #endif
+          TERN_(HAS_SOFTWARE_ENDSTOPS, NOMORE(current_position.z, soft_endstop.max.z));
           fast_line_to_current(Z_AXIS);
           planner.synchronize();
         }
       #endif
 
       // Unload / Retract
       #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
         const bool should_swap = can_move_away && toolchange_settings.swap_length,
                    too_cold = TERN0(PREVENT_COLD_EXTRUSION,
                      !DEBUGGING(DRYRUN) && (thermalManager.targetTooColdToExtrude(old_tool) || thermalManager.targetTooColdToExtrude(new_tool))
@@ -1110,23 +1106,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
         #if DISABLED(DUAL_X_CARRIAGE)
           update_software_endstops(Y_AXIS _EXT_ARGS);
           update_software_endstops(Z_AXIS _EXT_ARGS);
         #endif
       #endif
 
       #if DISABLED(TOOLCHANGE_ZRAISE_BEFORE_RETRACT) && DISABLED(SWITCHING_NOZZLE)
         if (can_move_away && TERN1(TOOLCHANGE_PARK, toolchange_settings.enable_park)) {
           // Do a small lift to avoid the workpiece in the move back (below)
           current_position.z += toolchange_settings.z_raise;
-          #if HAS_SOFTWARE_ENDSTOPS
-            NOMORE(current_position.z, soft_endstop.max.z);
-          #endif
+          TERN_(HAS_SOFTWARE_ENDSTOPS, NOMORE(current_position.z, soft_endstop.max.z));
           fast_line_to_current(Z_AXIS);
         }
       #endif
 
       // Toolchange park
       #if ENABLED(TOOLCHANGE_PARK) && DISABLED(SWITCHING_NOZZLE)
         if (can_move_away && toolchange_settings.enable_park) {
           IF_DISABLED(TOOLCHANGE_PARK_Y_ONLY, current_position.x = toolchange_settings.change_point.x);
           IF_DISABLED(TOOLCHANGE_PARK_X_ONLY, current_position.y = toolchange_settings.change_point.y);
           planner.buffer_line(current_position, MMM_TO_MMS(TOOLCHANGE_PARK_XY_FEEDRATE), old_tool);

commit 53a5cd0c380851ceab9545c652d67d3d688cf693
Author: Bob Anthony <42719046+bob-anthony@users.noreply.github.com>
Date:   Tue Aug 3 23:45:08 2021 -0500

    üêõ Fix extra E move in toolchange with ..._NO_RETURN (#22504)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 5b478caa1a..6d69b8722d 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -947,25 +947,25 @@ void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.
       #if HAS_FAN && TOOLCHANGE_FS_FAN >= 0
         thermalManager.fan_speed[TOOLCHANGE_FS_FAN] = toolchange_settings.fan_speed;
         gcode.dwell(SEC_TO_MS(toolchange_settings.fan_time));
         thermalManager.fan_speed[TOOLCHANGE_FS_FAN] = 0;
       #endif
 
       // Move back
       #if ENABLED(TOOLCHANGE_PARK)
         if (ok) {
           #if ENABLED(TOOLCHANGE_NO_RETURN)
-            destination.set(current_position.x, current_position.y);
-            prepare_internal_move_to_destination(planner.settings.max_feedrate_mm_s[Z_AXIS]);
-          #else
-            prepare_internal_move_to_destination(MMM_TO_MMS(TOOLCHANGE_PARK_XY_FEEDRATE));
+            const float temp = destination.z;
+            destination = current_position;
+            destination.z = temp.z;
           #endif
+          prepare_internal_move_to_destination(TERN(TOOLCHANGE_NO_RETURN, planner.settings.max_feedrate_mm_s[Z_AXIS], MMM_TO_MMS(TOOLCHANGE_PARK_XY_FEEDRATE)));
         }
       #endif
 
       // Cutting recover
       unscaled_e_move(toolchange_settings.extra_resume + TOOLCHANGE_FS_WIPE_RETRACT, MMM_TO_MMS(toolchange_settings.unretract_speed));
 
       // Resume at the old E position
       current_position.e = destination.e;
       sync_plan_position_e();
     }

commit 7726af9c5348c1c7d0fd9a56eca87d00cd75fee6
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Sat Jun 5 09:18:47 2021 +0200

    üèóÔ∏è Support for up to 6 linear axes (#19112)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 3abab802ab..5b478caa1a 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -42,21 +42,23 @@
 
 #if ENABLED(TOOLCHANGE_MIGRATION_FEATURE)
   migration_settings_t migration = migration_defaults;
   bool enable_first_prime;
 #endif
 
 #if ENABLED(TOOLCHANGE_FS_INIT_BEFORE_SWAP)
   bool toolchange_extruder_ready[EXTRUDERS];
 #endif
 
-#if EITHER(MAGNETIC_PARKING_EXTRUDER, TOOL_SENSOR) || defined(EVENT_GCODE_AFTER_TOOLCHANGE) || (ENABLED(PARKING_EXTRUDER) && PARKING_EXTRUDER_SOLENOIDS_DELAY > 0)
+#if EITHER(MAGNETIC_PARKING_EXTRUDER, TOOL_SENSOR) \
+  || defined(EVENT_GCODE_TOOLCHANGE_T0) || defined(EVENT_GCODE_TOOLCHANGE_T1) || defined(EVENT_GCODE_AFTER_TOOLCHANGE) \
+  || (ENABLED(PARKING_EXTRUDER) && PARKING_EXTRUDER_SOLENOIDS_DELAY > 0)
   #include "../gcode/gcode.h"
 #endif
 
 #if ENABLED(TOOL_SENSOR)
   #include "../lcd/marlinui.h"
 #endif
 
 #if ENABLED(DUAL_X_CARRIAGE)
   #include "stepper.h"
 #endif
@@ -1304,24 +1306,36 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
       select_multiplexed_stepper(new_tool);
     #endif
 
     #if DO_SWITCH_EXTRUDER
       planner.synchronize();
       move_extruder_servo(active_extruder);
     #endif
 
     TERN_(HAS_FANMUX, fanmux_switch(active_extruder));
 
-    #ifdef EVENT_GCODE_AFTER_TOOLCHANGE
-      if (!no_move && TERN1(DUAL_X_CARRIAGE, dual_x_carriage_mode == DXC_AUTO_PARK_MODE))
-        gcode.process_subcommands_now_P(PSTR(EVENT_GCODE_AFTER_TOOLCHANGE));
-    #endif
+    if (!no_move) {
+      #ifdef EVENT_GCODE_TOOLCHANGE_T0
+        if (new_tool == 0)
+          gcode.process_subcommands_now_P(PSTR(EVENT_GCODE_TOOLCHANGE_T0));
+      #endif
+
+      #ifdef EVENT_GCODE_TOOLCHANGE_T1
+        if (new_tool == 1)
+          gcode.process_subcommands_now_P(PSTR(EVENT_GCODE_TOOLCHANGE_T1));
+      #endif
+
+      #ifdef EVENT_GCODE_AFTER_TOOLCHANGE
+        if (TERN1(DUAL_X_CARRIAGE, dual_x_carriage_mode == DXC_AUTO_PARK_MODE))
+          gcode.process_subcommands_now_P(PSTR(EVENT_GCODE_AFTER_TOOLCHANGE));
+      #endif
+    }
 
     SERIAL_ECHO_MSG(STR_ACTIVE_EXTRUDER, active_extruder);
 
   #endif // HAS_MULTI_EXTRUDER
 }
 
 #if ENABLED(TOOLCHANGE_MIGRATION_FEATURE)
 
   #define DEBUG_OUT ENABLED(DEBUG_TOOLCHANGE_MIGRATION_FEATURE)
   #include "../core/debug_out.h"

commit d8c4be375c24f0cda27ff8079b78985e5b8afa97
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 22 17:56:31 2021 -0500

    üé® Null heating message method

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index cc34acc14f..3abab802ab 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -1375,21 +1375,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
 
     // Migrate the retracted state
     #if ENABLED(FWRETRACT)
       fwretract.retracted[migration_extruder] = fwretract.retracted[active_extruder];
     #endif
 
     // Migrate the temperature to the new hotend
     #if HAS_MULTI_HOTEND
       thermalManager.setTargetHotend(thermalManager.degTargetHotend(active_extruder), migration_extruder);
       TERN_(AUTOTEMP, planner.autotemp_update());
-      TERN_(HAS_STATUS_MESSAGE, thermalManager.set_heating_message(0));
+      thermalManager.set_heating_message(0);
       thermalManager.wait_for_hotend(active_extruder);
     #endif
 
     // Migrate Linear Advance K factor to the new extruder
     TERN_(LIN_ADVANCE, planner.extruder_advance_K[active_extruder] = planner.extruder_advance_K[migration_extruder]);
 
     // Perform the tool change
     tool_change(migration_extruder);
 
     // Retract if previously retracted

commit 2de54dab84d82ef69fb9ac3bd9025444f4f84813
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri May 21 08:23:09 2021 -0500

    üé® Move HAS_EXTRUDERS

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 03e85fdd84..cc34acc14f 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -815,21 +815,21 @@ void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.
     // 9. Apply Z hotend offset to current position
 
     DEBUG_POS("(9) Applying Z-offset", current_position);
     current_position.z += hoffs.z - hotend_offset[new_tool].z;
 
     DEBUG_POS("EMST Tool-Change done.", current_position);
   }
 
 #endif // ELECTROMAGNETIC_SWITCHING_TOOLHEAD
 
-#if EXTRUDERS
+#if HAS_EXTRUDERS
   inline void invalid_extruder_error(const uint8_t e) {
     SERIAL_ECHO_START();
     SERIAL_CHAR('T'); SERIAL_ECHO(e);
     SERIAL_CHAR(' '); SERIAL_ECHOLNPGM(STR_INVALID_EXTRUDER);
   }
 #endif
 
 #if ENABLED(DUAL_X_CARRIAGE)
 
   /**

commit a6e5492b088add3589aeac168136369f21614e60
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 18 22:51:19 2021 -0500

    ‚ôªÔ∏è Refactor axis counts and loops

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 559caa7f98..03e85fdd84 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -1174,21 +1174,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
       (void)check_tool_sensor_stats(active_extruder, true);
 
       // The newly-selected extruder XYZ is actually at...
       DEBUG_ECHOLNPAIR("Offset Tool XYZ by { ", diff.x, ", ", diff.y, ", ", diff.z, " }");
       current_position += diff;
 
       // Tell the planner the new "current position"
       sync_plan_position();
 
       #if ENABLED(DELTA)
-        //LOOP_XYZ(i) update_software_endstops(i); // or modify the constrain function
+        //LOOP_LINEAR_AXES(i) update_software_endstops(i); // or modify the constrain function
         const bool safe_to_move = current_position.z < delta_clip_start_height - 1;
       #else
         constexpr bool safe_to_move = true;
       #endif
 
       // Return to position and lower again
       const bool should_move = safe_to_move && !no_move && IsRunning();
       if (should_move) {
 
         #if EITHER(SINGLENOZZLE_STANDBY_TEMP, SINGLENOZZLE_STANDBY_FAN)

commit 0c8a53e507fa792b114a89fe6902f4efe4ed2fe8
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue May 11 10:47:32 2021 -0500

    :art: Misc. code cleanup

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 0c5673b31c..559caa7f98 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -106,24 +106,21 @@
 #if DO_SWITCH_EXTRUDER
 
   #if EXTRUDERS > 3
     #define _SERVO_NR(E) ((E) < 2 ? SWITCHING_EXTRUDER_SERVO_NR : SWITCHING_EXTRUDER_E23_SERVO_NR)
   #else
     #define _SERVO_NR(E) SWITCHING_EXTRUDER_SERVO_NR
   #endif
 
   void move_extruder_servo(const uint8_t e) {
     planner.synchronize();
-    #if EXTRUDERS & 1
-      if (e < EXTRUDERS - 1)
-    #endif
-    {
+    if ((EXTRUDERS & 1) && e < EXTRUDERS - 1) {
       MOVE_SERVO(_SERVO_NR(e), servo_angles[_SERVO_NR(e)][e & 1]);
       safe_delay(500);
     }
   }
 
 #endif // DO_SWITCH_EXTRUDER
 
 #if ENABLED(SWITCHING_NOZZLE)
 
   #if SWITCHING_NOZZLE_TWO_SERVOS

commit ef9ca61039514efef6e2bf100c4b6b1db8f0316c
Author: ellensp <ellensp@hotmail.com>
Date:   Sat May 1 20:21:18 2021 +1200

    Fix Singlenozzle Standby issues (#21759)
    
    Fixes #21758
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 2e5e59c0af..0c5673b31c 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -1187,21 +1187,23 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
         //LOOP_XYZ(i) update_software_endstops(i); // or modify the constrain function
         const bool safe_to_move = current_position.z < delta_clip_start_height - 1;
       #else
         constexpr bool safe_to_move = true;
       #endif
 
       // Return to position and lower again
       const bool should_move = safe_to_move && !no_move && IsRunning();
       if (should_move) {
 
-        TERN_(SINGLENOZZLE_STANDBY_TEMP, thermalManager.singlenozzle_change(old_tool, new_tool));
+        #if EITHER(SINGLENOZZLE_STANDBY_TEMP, SINGLENOZZLE_STANDBY_FAN)
+          thermalManager.singlenozzle_change(old_tool, new_tool);
+        #endif
 
         #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
           if (should_swap && !too_cold) {
 
             float fr = toolchange_settings.unretract_speed;
 
             #if ENABLED(TOOLCHANGE_FS_INIT_BEFORE_SWAP)
               if (!toolchange_extruder_ready[new_tool]) {
                 toolchange_extruder_ready[new_tool] = true;
                 fr = toolchange_settings.prime_speed;       // Next move is a prime

commit dfcccb63a1f3d8098ebfef8c64753f735bcf0b0d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Apr 24 05:20:55 2021 -0500

    Use temperature accessors

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 8354b8b86a..2e5e59c0af 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -1374,21 +1374,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
     // Migrate the flow
     planner.set_flow(migration_extruder, planner.flow_percentage[active_extruder]);
 
     // Migrate the retracted state
     #if ENABLED(FWRETRACT)
       fwretract.retracted[migration_extruder] = fwretract.retracted[active_extruder];
     #endif
 
     // Migrate the temperature to the new hotend
     #if HAS_MULTI_HOTEND
-      thermalManager.setTargetHotend(thermalManager.temp_hotend[active_extruder].target, migration_extruder);
+      thermalManager.setTargetHotend(thermalManager.degTargetHotend(active_extruder), migration_extruder);
       TERN_(AUTOTEMP, planner.autotemp_update());
       TERN_(HAS_STATUS_MESSAGE, thermalManager.set_heating_message(0));
       thermalManager.wait_for_hotend(active_extruder);
     #endif
 
     // Migrate Linear Advance K factor to the new extruder
     TERN_(LIN_ADVANCE, planner.extruder_advance_K[active_extruder] = planner.extruder_advance_K[migration_extruder]);
 
     // Perform the tool change
     tool_change(migration_extruder);

commit 3bddbb1110b6ca13a291de426553839b99cae102
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Apr 23 19:06:55 2021 -0500

    Clean up formatting, wrap macros

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 2b8a434172..8354b8b86a 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -1047,22 +1047,20 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
     #endif
 
     // First tool priming. To prime again, reboot the machine.
     #if ENABLED(TOOLCHANGE_FS_PRIME_FIRST_USED)
       static bool first_tool_is_primed = false;
       if (new_tool == old_tool && !first_tool_is_primed && enable_first_prime) {
         tool_change_prime();
         first_tool_is_primed = true;
         TERN_(TOOLCHANGE_FS_INIT_BEFORE_SWAP, toolchange_extruder_ready[old_tool] = true); // Primed and initialized
       }
-    #else
-      constexpr bool first_tool_is_primed = true;
     #endif
 
     if (new_tool != old_tool || TERN0(PARKING_EXTRUDER, extruder_parked)) { // PARKING_EXTRUDER may need to attach old_tool when homing
       destination = current_position;
 
       #if BOTH(TOOLCHANGE_FILAMENT_SWAP, HAS_FAN) && TOOLCHANGE_FS_FAN >= 0
         // Store and stop fan. Restored on any exit.
         REMEMBER(fan, thermalManager.fan_speed[TOOLCHANGE_FS_FAN], 0);
       #endif
 
@@ -1085,21 +1083,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
                    too_cold = TERN0(PREVENT_COLD_EXTRUSION,
                      !DEBUGGING(DRYRUN) && (thermalManager.targetTooColdToExtrude(old_tool) || thermalManager.targetTooColdToExtrude(new_tool))
                    );
         if (should_swap) {
           if (too_cold) {
             SERIAL_ECHO_MSG(STR_ERR_HOTEND_TOO_COLD);
             if (ENABLED(SINGLENOZZLE)) { active_extruder = new_tool; return; }
           }
           else {
             // For first new tool, change without unloading the old. 'Just prime/init the new'
-            if (first_tool_is_primed)
+            if (TERN1(TOOLCHANGE_FS_PRIME_FIRST_USED, first_tool_is_primed))
               unscaled_e_move(-toolchange_settings.swap_length, MMM_TO_MMS(toolchange_settings.retract_speed));
             TERN_(TOOLCHANGE_FS_PRIME_FIRST_USED, first_tool_is_primed = true); // The first new tool will be primed by toolchanging
           }
         }
       #endif
 
       TERN_(SWITCHING_NOZZLE_TWO_SERVOS, raise_nozzle(old_tool));
 
       REMEMBER(fr, feedrate_mm_s, XY_PROBE_FEEDRATE_MM_S);
 

commit 553487cc8ab348939c6033910c0aa11d230b2ad6
Author: MangaValk <patrickvalkmanga@hotmail.com>
Date:   Fri Apr 16 15:02:31 2021 +0200

    Tool sensors (#17239)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 080c1e629b..2b8a434172 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -42,24 +42,28 @@
 
 #if ENABLED(TOOLCHANGE_MIGRATION_FEATURE)
   migration_settings_t migration = migration_defaults;
   bool enable_first_prime;
 #endif
 
 #if ENABLED(TOOLCHANGE_FS_INIT_BEFORE_SWAP)
   bool toolchange_extruder_ready[EXTRUDERS];
 #endif
 
-#if ENABLED(MAGNETIC_PARKING_EXTRUDER) || defined(EVENT_GCODE_AFTER_TOOLCHANGE) || (ENABLED(PARKING_EXTRUDER) && PARKING_EXTRUDER_SOLENOIDS_DELAY > 0)
+#if EITHER(MAGNETIC_PARKING_EXTRUDER, TOOL_SENSOR) || defined(EVENT_GCODE_AFTER_TOOLCHANGE) || (ENABLED(PARKING_EXTRUDER) && PARKING_EXTRUDER_SOLENOIDS_DELAY > 0)
   #include "../gcode/gcode.h"
 #endif
 
+#if ENABLED(TOOL_SENSOR)
+  #include "../lcd/marlinui.h"
+#endif
+
 #if ENABLED(DUAL_X_CARRIAGE)
   #include "stepper.h"
 #endif
 
 #if ANY(SWITCHING_EXTRUDER, SWITCHING_NOZZLE, SWITCHING_TOOLHEAD)
   #include "servo.h"
 #endif
 
 #if ENABLED(EXT_SOLENOID) && DISABLED(PARKING_EXTRUDER)
   #include "../feature/solenoid.h"
@@ -140,25 +144,25 @@
     void move_nozzle_servo(const uint8_t angle_index) {
       planner.synchronize();
       MOVE_SERVO(SWITCHING_NOZZLE_SERVO_NR, servo_angles[SWITCHING_NOZZLE_SERVO_NR][angle_index]);
       safe_delay(500);
     }
 
   #endif
 
 #endif // SWITCHING_NOZZLE
 
-inline void _line_to_current(const AxisEnum fr_axis, const float fscale=1) {
+void _line_to_current(const AxisEnum fr_axis, const float fscale=1) {
   line_to_current_position(planner.settings.max_feedrate_mm_s[fr_axis] * fscale);
 }
-inline void slow_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.5f); }
-inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis); }
+void slow_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.2f); }
+void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.5f); }
 
 #if ENABLED(MAGNETIC_PARKING_EXTRUDER)
 
   float parkingposx[2],           // M951 R L
         parkinggrabdistance,      // M951 I
         parkingslowspeed,         // M951 J
         parkinghighspeed,         // M951 H
         parkingtraveldistance,    // M951 D
         compensationmultiplier;
 
@@ -363,48 +367,155 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
 
       DEBUG_SYNCHRONIZE();
       DEBUG_POS("(6) Move midway between hotends", current_position);
 
       fast_line_to_current(X_AXIS);
       planner.synchronize(); // Always sync the final move
 
       DEBUG_POS("PE Tool-Change done.", current_position);
       parking_extruder_set_parked(false);
     }
-    else if (do_solenoid_activation) { // && nomove == true
+    else if (do_solenoid_activation) {
       // Deactivate current extruder solenoid
       pe_solenoid_set_pin_state(active_extruder, !PARKING_EXTRUDER_SOLENOIDS_PINS_ACTIVE);
       // Engage new extruder magnetic field
       pe_solenoid_set_pin_state(new_tool, PARKING_EXTRUDER_SOLENOIDS_PINS_ACTIVE);
     }
 
     do_solenoid_activation = true; // Activate solenoid for subsequent tool_change()
   }
 
 #endif // PARKING_EXTRUDER
 
 #if ENABLED(SWITCHING_TOOLHEAD)
 
-  inline void swt_lock(const bool locked=true) {
-    const uint16_t swt_angles[2] = SWITCHING_TOOLHEAD_SERVO_ANGLES;
-    MOVE_SERVO(SWITCHING_TOOLHEAD_SERVO_NR, swt_angles[locked ? 0 : 1]);
+  // Return a bitmask of tool sensor states
+  inline uint8_t poll_tool_sensor_pins() {
+    return (0
+      #if ENABLED(TOOL_SENSOR)
+        #if PIN_EXISTS(TOOL_SENSOR1)
+          | (READ(TOOL_SENSOR1_PIN) << 0)
+        #endif
+        #if PIN_EXISTS(TOOL_SENSOR2)
+          | (READ(TOOL_SENSOR2_PIN) << 1)
+        #endif
+        #if PIN_EXISTS(TOOL_SENSOR3)
+          | (READ(TOOL_SENSOR3_PIN) << 2)
+        #endif
+        #if PIN_EXISTS(TOOL_SENSOR4)
+          | (READ(TOOL_SENSOR4_PIN) << 3)
+        #endif
+        #if PIN_EXISTS(TOOL_SENSOR5)
+          | (READ(TOOL_SENSOR5_PIN) << 4)
+        #endif
+        #if PIN_EXISTS(TOOL_SENSOR6)
+          | (READ(TOOL_SENSOR6_PIN) << 5)
+        #endif
+        #if PIN_EXISTS(TOOL_SENSOR7)
+          | (READ(TOOL_SENSOR7_PIN) << 6)
+        #endif
+        #if PIN_EXISTS(TOOL_SENSOR8)
+          | (READ(TOOL_SENSOR8_PIN) << 7)
+        #endif
+      #endif
+    );
+  }
+
+  #if ENABLED(TOOL_SENSOR)
+
+    bool tool_sensor_disabled; // = false
+
+    uint8_t check_tool_sensor_stats(const uint8_t tool_index, const bool kill_on_error/*=false*/, const bool disable/*=false*/) {
+      static uint8_t sensor_tries; // = 0
+      for (;;) {
+        if (poll_tool_sensor_pins() == _BV(tool_index)) {
+          sensor_tries = 0;
+          return tool_index;
+        }
+        else if (kill_on_error && (!tool_sensor_disabled || disable)) {
+          sensor_tries++;
+          if (sensor_tries > 10) kill(PSTR("Tool Sensor error"));
+          safe_delay(5);
+        }
+        else {
+          sensor_tries++;
+          if (sensor_tries > 10) return -1;
+          safe_delay(5);
+        }
+      }
+    }
+
+  #endif
+
+  inline void switching_toolhead_lock(const bool locked) {
+    #ifdef SWITCHING_TOOLHEAD_SERVO_ANGLES
+      const uint16_t swt_angles[2] = SWITCHING_TOOLHEAD_SERVO_ANGLES;
+      MOVE_SERVO(SWITCHING_TOOLHEAD_SERVO_NR, swt_angles[locked ? 0 : 1]);
+    #elif PIN_EXISTS(SWT_SOLENOID)
+      OUT_WRITE(SWT_SOLENOID_PIN, locked);
+      gcode.dwell(10);
+    #else
+      #error "No toolhead locking mechanism configured."
+    #endif
   }
 
-  void swt_init() { swt_lock(); }
+  #include <bitset>
+
+  void swt_init() {
+    switching_toolhead_lock(true);
+
+    #if ENABLED(TOOL_SENSOR)
+      // Init tool sensors
+      #if PIN_EXISTS(TOOL_SENSOR1)
+        SET_INPUT_PULLUP(TOOL_SENSOR1_PIN);
+      #endif
+      #if PIN_EXISTS(TOOL_SENSOR2)
+        SET_INPUT_PULLUP(TOOL_SENSOR2_PIN);
+      #endif
+      #if PIN_EXISTS(TOOL_SENSOR3)
+        SET_INPUT_PULLUP(TOOL_SENSOR3_PIN);
+      #endif
+      #if PIN_EXISTS(TOOL_SENSOR4)
+        SET_INPUT_PULLUP(TOOL_SENSOR4_PIN);
+      #endif
+      #if PIN_EXISTS(TOOL_SENSOR5)
+        SET_INPUT_PULLUP(TOOL_SENSOR5_PIN);
+      #endif
+      #if PIN_EXISTS(TOOL_SENSOR6)
+        SET_INPUT_PULLUP(TOOL_SENSOR6_PIN);
+      #endif
+      #if PIN_EXISTS(TOOL_SENSOR7)
+        SET_INPUT_PULLUP(TOOL_SENSOR7_PIN);
+      #endif
+      #if PIN_EXISTS(TOOL_SENSOR8)
+        SET_INPUT_PULLUP(TOOL_SENSOR8_PIN);
+      #endif
+
+      if (check_tool_sensor_stats(0)) {
+        ui.set_status_P("TC error");
+        switching_toolhead_lock(false);
+        while (check_tool_sensor_stats(0)) { /* nada */ }
+        switching_toolhead_lock(true);
+      }
+      ui.set_status_P("TC Success");
+    #endif
+  }
 
   inline void switching_toolhead_tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
     if (no_move) return;
 
     constexpr float toolheadposx[] = SWITCHING_TOOLHEAD_X_POS;
     const float placexpos = toolheadposx[active_extruder],
                 grabxpos = toolheadposx[new_tool];
 
+    (void)check_tool_sensor_stats(active_extruder, true);
+
     /**
      * 1. Move to switch position of current toolhead
      * 2. Unlock tool and drop it in the dock
      * 3. Move to the new toolhead
      * 4. Grab and lock the new toolhead
      */
 
     // 1. Move to switch position of current toolhead
 
     DEBUG_POS("Start ST Tool-Change", current_position);
@@ -414,79 +525,87 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
     DEBUG_ECHOLNPAIR("(1) Place old tool ", active_extruder);
     DEBUG_POS("Move X SwitchPos", current_position);
 
     fast_line_to_current(X_AXIS);
 
     current_position.y = SWITCHING_TOOLHEAD_Y_POS - (SWITCHING_TOOLHEAD_Y_SECURITY);
 
     DEBUG_SYNCHRONIZE();
     DEBUG_POS("Move Y SwitchPos + Security", current_position);
 
-    fast_line_to_current(Y_AXIS);
+    slow_line_to_current(Y_AXIS);
 
     // 2. Unlock tool and drop it in the dock
+    TERN_(TOOL_SENSOR, tool_sensor_disabled = true);
 
     planner.synchronize();
     DEBUG_ECHOLNPGM("(2) Unlock and Place Toolhead");
-    swt_lock(false);
+    switching_toolhead_lock(false);
     safe_delay(500);
 
     current_position.y = SWITCHING_TOOLHEAD_Y_POS;
     DEBUG_POS("Move Y SwitchPos", current_position);
     slow_line_to_current(Y_AXIS);
 
     // Wait for move to complete, then another 0.2s
     planner.synchronize();
     safe_delay(200);
 
     current_position.y -= SWITCHING_TOOLHEAD_Y_CLEAR;
     DEBUG_POS("Move back Y clear", current_position);
-    fast_line_to_current(Y_AXIS); // move away from docked toolhead
+    slow_line_to_current(Y_AXIS); // move away from docked toolhead
+
+    (void)check_tool_sensor_stats(active_extruder);
 
     // 3. Move to the new toolhead
 
     current_position.x = grabxpos;
 
     DEBUG_SYNCHRONIZE();
     DEBUG_ECHOLNPGM("(3) Move to new toolhead position");
     DEBUG_POS("Move to new toolhead X", current_position);
 
     fast_line_to_current(X_AXIS);
 
     current_position.y = SWITCHING_TOOLHEAD_Y_POS - (SWITCHING_TOOLHEAD_Y_SECURITY);
 
     DEBUG_SYNCHRONIZE();
     DEBUG_POS("Move Y SwitchPos + Security", current_position);
 
-    fast_line_to_current(Y_AXIS);
+    slow_line_to_current(Y_AXIS);
 
     // 4. Grab and lock the new toolhead
 
     current_position.y = SWITCHING_TOOLHEAD_Y_POS;
 
     DEBUG_SYNCHRONIZE();
     DEBUG_ECHOLNPGM("(4) Grab and lock new toolhead");
     DEBUG_POS("Move Y SwitchPos", current_position);
 
     slow_line_to_current(Y_AXIS);
 
     // Wait for move to finish, pause 0.2s, move servo, pause 0.5s
     planner.synchronize();
     safe_delay(200);
-    swt_lock();
+
+    (void)check_tool_sensor_stats(new_tool, true, true);
+
+    switching_toolhead_lock(true);
     safe_delay(500);
 
     current_position.y -= SWITCHING_TOOLHEAD_Y_CLEAR;
     DEBUG_POS("Move back Y clear", current_position);
-    fast_line_to_current(Y_AXIS); // Move away from docked toolhead
+    slow_line_to_current(Y_AXIS); // Move away from docked toolhead
     planner.synchronize();        // Always sync the final move
 
+    (void)check_tool_sensor_stats(new_tool, true, true);
+
     DEBUG_POS("ST Tool-Change done.", current_position);
   }
 
 #elif ENABLED(MAGNETIC_SWITCHING_TOOLHEAD)
 
   inline void magnetic_switching_toolhead_tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
     if (no_move) return;
 
     constexpr float toolheadposx[] = SWITCHING_TOOLHEAD_X_POS,
                     toolheadclearx[] = SWITCHING_TOOLHEAD_X_SECURITY;
@@ -1046,22 +1165,25 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
           // Check if Z has space to compensate at least z_offset, and if not, just abort now
           const float maxz = _MIN(TERN(HAS_SOFTWARE_ENDSTOPS, soft_endstop.max.z, Z_MAX_POS), Z_MAX_POS);
           if (newz > maxz) return;
 
           current_position.z = _MIN(newz + toolchange_settings.z_raise, maxz);
           fast_line_to_current(Z_AXIS);
         }
         move_nozzle_servo(new_tool);
       #endif
 
-      // Set the new active extruder
-      if (DISABLED(DUAL_X_CARRIAGE)) active_extruder = new_tool;
+      IF_DISABLED(DUAL_X_CARRIAGE, active_extruder = new_tool); // Set the new active extruder
+
+      TERN_(TOOL_SENSOR, tool_sensor_disabled = false);
+
+      (void)check_tool_sensor_stats(active_extruder, true);
 
       // The newly-selected extruder XYZ is actually at...
       DEBUG_ECHOLNPAIR("Offset Tool XYZ by { ", diff.x, ", ", diff.y, ", ", diff.z, " }");
       current_position += diff;
 
       // Tell the planner the new "current position"
       sync_plan_position();
 
       #if ENABLED(DELTA)
         //LOOP_XYZ(i) update_software_endstops(i); // or modify the constrain function

commit 2d1d628340a6b4dd38ae808e6423438fa153de57
Author: Luca Zimmermann <soundstorm@users.noreply.github.com>
Date:   Fri Apr 16 11:01:50 2021 +0200

    Always swap with PRIME_FIRST_USED disabled (#21622)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 3dd63e814c..080c1e629b 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -921,27 +921,29 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
 
     const uint8_t old_tool = active_extruder;
     const bool can_move_away = !no_move && !idex_full_control;
 
     #if HAS_LEVELING
       // Set current position to the physical position
       TEMPORARY_BED_LEVELING_STATE(false);
     #endif
 
     // First tool priming. To prime again, reboot the machine.
-    #if BOTH(TOOLCHANGE_FILAMENT_SWAP, TOOLCHANGE_FS_PRIME_FIRST_USED)
+    #if ENABLED(TOOLCHANGE_FS_PRIME_FIRST_USED)
       static bool first_tool_is_primed = false;
       if (new_tool == old_tool && !first_tool_is_primed && enable_first_prime) {
         tool_change_prime();
         first_tool_is_primed = true;
-        toolchange_extruder_ready[old_tool] = true; // Primed and initialized
+        TERN_(TOOLCHANGE_FS_INIT_BEFORE_SWAP, toolchange_extruder_ready[old_tool] = true); // Primed and initialized
       }
+    #else
+      constexpr bool first_tool_is_primed = true;
     #endif
 
     if (new_tool != old_tool || TERN0(PARKING_EXTRUDER, extruder_parked)) { // PARKING_EXTRUDER may need to attach old_tool when homing
       destination = current_position;
 
       #if BOTH(TOOLCHANGE_FILAMENT_SWAP, HAS_FAN) && TOOLCHANGE_FS_FAN >= 0
         // Store and stop fan. Restored on any exit.
         REMEMBER(fan, thermalManager.fan_speed[TOOLCHANGE_FS_FAN], 0);
       #endif
 
@@ -963,26 +965,24 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
         const bool should_swap = can_move_away && toolchange_settings.swap_length,
                    too_cold = TERN0(PREVENT_COLD_EXTRUSION,
                      !DEBUGGING(DRYRUN) && (thermalManager.targetTooColdToExtrude(old_tool) || thermalManager.targetTooColdToExtrude(new_tool))
                    );
         if (should_swap) {
           if (too_cold) {
             SERIAL_ECHO_MSG(STR_ERR_HOTEND_TOO_COLD);
             if (ENABLED(SINGLENOZZLE)) { active_extruder = new_tool; return; }
           }
           else {
-            #if ENABLED(TOOLCHANGE_FS_PRIME_FIRST_USED)
-              // For first new tool, change without unloading the old. 'Just prime/init the new'
-              if (first_tool_is_primed)
-                unscaled_e_move(-toolchange_settings.swap_length, MMM_TO_MMS(toolchange_settings.retract_speed));
-              first_tool_is_primed = true; // The first new tool will be primed by toolchanging
-            #endif
+            // For first new tool, change without unloading the old. 'Just prime/init the new'
+            if (first_tool_is_primed)
+              unscaled_e_move(-toolchange_settings.swap_length, MMM_TO_MMS(toolchange_settings.retract_speed));
+            TERN_(TOOLCHANGE_FS_PRIME_FIRST_USED, first_tool_is_primed = true); // The first new tool will be primed by toolchanging
           }
         }
       #endif
 
       TERN_(SWITCHING_NOZZLE_TWO_SERVOS, raise_nozzle(old_tool));
 
       REMEMBER(fr, feedrate_mm_s, XY_PROBE_FEEDRATE_MM_S);
 
       #if HAS_SOFTWARE_ENDSTOPS
         #if HAS_HOTEND_OFFSET

commit a5d6f6ac9880090d2412bbea0027885b95c98ea2
Author: espr14 <espr14@gmail.com>
Date:   Tue Apr 13 03:10:21 2021 +0200

    Fix Resume Print with UBL (#21564)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 0475af6ad2..3dd63e814c 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -829,23 +829,24 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
       #if HAS_FAN && TOOLCHANGE_FS_FAN >= 0
         thermalManager.fan_speed[TOOLCHANGE_FS_FAN] = toolchange_settings.fan_speed;
         gcode.dwell(SEC_TO_MS(toolchange_settings.fan_time));
         thermalManager.fan_speed[TOOLCHANGE_FS_FAN] = 0;
       #endif
 
       // Move back
       #if ENABLED(TOOLCHANGE_PARK)
         if (ok) {
           #if ENABLED(TOOLCHANGE_NO_RETURN)
-            do_blocking_move_to_z(destination.z, planner.settings.max_feedrate_mm_s[Z_AXIS]);
+            destination.set(current_position.x, current_position.y);
+            prepare_internal_move_to_destination(planner.settings.max_feedrate_mm_s[Z_AXIS]);
           #else
-            do_blocking_move_to(destination, MMM_TO_MMS(TOOLCHANGE_PARK_XY_FEEDRATE));
+            prepare_internal_move_to_destination(MMM_TO_MMS(TOOLCHANGE_PARK_XY_FEEDRATE));
           #endif
         }
       #endif
 
       // Cutting recover
       unscaled_e_move(toolchange_settings.extra_resume + TOOLCHANGE_FS_WIPE_RETRACT, MMM_TO_MMS(toolchange_settings.unretract_speed));
 
       // Resume at the old E position
       current_position.e = destination.e;
       sync_plan_position_e();

commit 4a1d2d816c4dff8b3c3e472f7b8022362e1ad109
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 12 19:34:31 2021 -0500

    Update old-style axis indexes

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 1ed395dfe4..0475af6ad2 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -839,23 +839,23 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
             do_blocking_move_to_z(destination.z, planner.settings.max_feedrate_mm_s[Z_AXIS]);
           #else
             do_blocking_move_to(destination, MMM_TO_MMS(TOOLCHANGE_PARK_XY_FEEDRATE));
           #endif
         }
       #endif
 
       // Cutting recover
       unscaled_e_move(toolchange_settings.extra_resume + TOOLCHANGE_FS_WIPE_RETRACT, MMM_TO_MMS(toolchange_settings.unretract_speed));
 
-      planner.synchronize();
+      // Resume at the old E position
       current_position.e = destination.e;
-      sync_plan_position_e(); // Resume at the old E position
+      sync_plan_position_e();
     }
   }
 
 #endif // TOOLCHANGE_FILAMENT_SWAP
 
 /**
  * Perform a tool-change, which may result in moving the
  * previous tool out of the way and the new tool into place.
  */
 void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {

commit 1a2cbe100c279b0dd12a70f5e9179a6f9b555e32
Author: Ramiro Polla <ramiropolla@users.noreply.github.com>
Date:   Fri Apr 9 04:03:34 2021 +0200

    Macros to eliminate 'f + 0.0' (#21568)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index ab0595c58b..1ed395dfe4 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -352,21 +352,21 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
 
       current_position.x = grabpos;
 
       DEBUG_SYNCHRONIZE();
       DEBUG_POS("(5) Unpark extruder", current_position);
 
       slow_line_to_current(X_AXIS);
 
       // STEP 6
 
-      current_position.x = midpos - TERN0(HAS_HOTEND_OFFSET, hotend_offset[new_tool].x);
+      current_position.x = DIFF_TERN(HAS_HOTEND_OFFSET, midpos, hotend_offset[new_tool].x);
 
       DEBUG_SYNCHRONIZE();
       DEBUG_POS("(6) Move midway between hotends", current_position);
 
       fast_line_to_current(X_AXIS);
       planner.synchronize(); // Always sync the final move
 
       DEBUG_POS("PE Tool-Change done.", current_position);
       parking_extruder_set_parked(false);
     }

commit d61bc2d136cd18081f2e6a76d10c7cd90b4b80e1
Author: Radim Karni≈° <57687985+radimkarnis@users.noreply.github.com>
Date:   Wed Apr 7 21:41:38 2021 +0200

    Park Magnetic Switching Toolhead at the very end (#21552)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 71dd6d40ec..ab0595c58b 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -1105,21 +1105,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
               gcode.dwell(SEC_TO_MS(toolchange_settings.fan_time));
               thermalManager.fan_speed[TOOLCHANGE_FS_FAN] = 0;
             #endif
           }
         #endif
 
         // Prevent a move outside physical bounds
         #if ENABLED(MAGNETIC_SWITCHING_TOOLHEAD)
           // If the original position is within tool store area, go to X origin at once
           if (destination.y < SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_CLEAR) {
-            current_position.x = 0;
+            current_position.x = X_MIN_POS;
             planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], new_tool);
             planner.synchronize();
           }
         #else
           apply_motion_limits(destination);
         #endif
 
         // Should the nozzle move back to the old position?
         if (can_move_away) {
           #if ENABLED(TOOLCHANGE_NO_RETURN)

commit 930752d46e6aacb484ea89dacae6baf823d78d62
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Wed Mar 24 10:12:57 2021 -0500

    Ender 3 V2 Status Line (#21369)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 0ed3d15b45..71dd6d40ec 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -1255,21 +1255,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
 
     // Migrate the retracted state
     #if ENABLED(FWRETRACT)
       fwretract.retracted[migration_extruder] = fwretract.retracted[active_extruder];
     #endif
 
     // Migrate the temperature to the new hotend
     #if HAS_MULTI_HOTEND
       thermalManager.setTargetHotend(thermalManager.temp_hotend[active_extruder].target, migration_extruder);
       TERN_(AUTOTEMP, planner.autotemp_update());
-      TERN_(HAS_DISPLAY, thermalManager.set_heating_message(0));
+      TERN_(HAS_STATUS_MESSAGE, thermalManager.set_heating_message(0));
       thermalManager.wait_for_hotend(active_extruder);
     #endif
 
     // Migrate Linear Advance K factor to the new extruder
     TERN_(LIN_ADVANCE, planner.extruder_advance_K[active_extruder] = planner.extruder_advance_K[migration_extruder]);
 
     // Perform the tool change
     tool_change(migration_extruder);
 
     // Retract if previously retracted

commit e7c711996bd3080f5e343eff5556736cbf2e2416
Author: X-Ryl669 <boite.pour.spam@gmail.com>
Date:   Mon Feb 8 07:37:24 2021 +0100

    Serial refactor. Default 8-bit ECHO to int, not char (#20985)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 191617be30..0ed3d15b45 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -179,74 +179,74 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
      *   3. Move to park position of new extruder
      *   4. Move high speed to approach park position of old extruder
      *   5. Move to park position of old extruder
      *   6. Move to starting position
      */
 
     // STEP 1
 
     current_position.x = mpe_settings.parking_xpos[new_tool] + offsetcompensation;
 
-    DEBUG_ECHOPAIR("(1) Move extruder ", int(new_tool));
+    DEBUG_ECHOPAIR("(1) Move extruder ", new_tool);
     DEBUG_POS(" to new extruder ParkPos", current_position);
 
     planner.buffer_line(current_position, mpe_settings.fast_feedrate, new_tool);
     planner.synchronize();
 
     // STEP 2
 
     current_position.x = grabpos + offsetcompensation;
 
-    DEBUG_ECHOPAIR("(2) Couple extruder ", int(new_tool));
+    DEBUG_ECHOPAIR("(2) Couple extruder ", new_tool);
     DEBUG_POS(" to new extruder GrabPos", current_position);
 
     planner.buffer_line(current_position, mpe_settings.slow_feedrate, new_tool);
     planner.synchronize();
 
     // Delay before moving tool, to allow magnetic coupling
     gcode.dwell(150);
 
     // STEP 3
 
     current_position.x = mpe_settings.parking_xpos[new_tool] + offsetcompensation;
 
-    DEBUG_ECHOPAIR("(3) Move extruder ", int(new_tool));
+    DEBUG_ECHOPAIR("(3) Move extruder ", new_tool);
     DEBUG_POS(" back to new extruder ParkPos", current_position);
 
     planner.buffer_line(current_position, mpe_settings.slow_feedrate, new_tool);
     planner.synchronize();
 
     // STEP 4
 
     current_position.x = mpe_settings.parking_xpos[active_extruder] + (active_extruder == 0 ? MPE_TRAVEL_DISTANCE : -MPE_TRAVEL_DISTANCE) + offsetcompensation;
 
-    DEBUG_ECHOPAIR("(4) Move extruder ", int(new_tool));
+    DEBUG_ECHOPAIR("(4) Move extruder ", new_tool);
     DEBUG_POS(" close to old extruder ParkPos", current_position);
 
     planner.buffer_line(current_position, mpe_settings.fast_feedrate, new_tool);
     planner.synchronize();
 
     // STEP 5
 
     current_position.x = mpe_settings.parking_xpos[active_extruder] + offsetcompensation;
 
-    DEBUG_ECHOPAIR("(5) Park extruder ", int(new_tool));
+    DEBUG_ECHOPAIR("(5) Park extruder ", new_tool);
     DEBUG_POS(" at old extruder ParkPos", current_position);
 
     planner.buffer_line(current_position, mpe_settings.slow_feedrate, new_tool);
     planner.synchronize();
 
     // STEP 6
 
     current_position.x = oldx;
 
-    DEBUG_ECHOPAIR("(6) Move extruder ", int(new_tool));
+    DEBUG_ECHOPAIR("(6) Move extruder ", new_tool);
     DEBUG_POS(" to starting position", current_position);
 
     planner.buffer_line(current_position, mpe_settings.fast_feedrate, new_tool);
     planner.synchronize();
 
     DEBUG_ECHOLNPGM("Autopark done.");
   }
 
 #elif ENABLED(PARKING_EXTRUDER)
 
@@ -267,23 +267,23 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
   bool extruder_parked = true, do_solenoid_activation = true;
 
   // Modifies tool_change() behavior based on homing side
   bool parking_extruder_unpark_after_homing(const uint8_t final_tool, bool homed_towards_final_tool) {
     do_solenoid_activation = false; // Tell parking_extruder_tool_change to skip solenoid activation
 
     if (!extruder_parked) return false; // nothing to do
 
     if (homed_towards_final_tool) {
       pe_solenoid_magnet_off(1 - final_tool);
-      DEBUG_ECHOLNPAIR("Disengage magnet", (int)(1 - final_tool));
+      DEBUG_ECHOLNPAIR("Disengage magnet", 1 - final_tool);
       pe_solenoid_magnet_on(final_tool);
-      DEBUG_ECHOLNPAIR("Engage magnet", (int)final_tool);
+      DEBUG_ECHOLNPAIR("Engage magnet", final_tool);
       parking_extruder_set_parked(false);
       return false;
     }
 
     return true;
   }
 
   inline void parking_extruder_tool_change(const uint8_t new_tool, bool no_move) {
     if (!no_move) {
 
@@ -308,21 +308,21 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
        */
 
       // STEP 1
 
       DEBUG_POS("Start PE Tool-Change", current_position);
 
       // Don't park the active_extruder unless unparked
       if (!extruder_parked) {
         current_position.x = parkingposx[active_extruder] + x_offset;
 
-        DEBUG_ECHOLNPAIR("(1) Park extruder ", int(active_extruder));
+        DEBUG_ECHOLNPAIR("(1) Park extruder ", active_extruder);
         DEBUG_POS("Moving ParkPos", current_position);
 
         fast_line_to_current(X_AXIS);
 
         // STEP 2
 
         planner.synchronize();
         DEBUG_ECHOLNPGM("(2) Disengage magnet");
         pe_solenoid_magnet_off(active_extruder);
 
@@ -404,21 +404,21 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
      * 3. Move to the new toolhead
      * 4. Grab and lock the new toolhead
      */
 
     // 1. Move to switch position of current toolhead
 
     DEBUG_POS("Start ST Tool-Change", current_position);
 
     current_position.x = placexpos;
 
-    DEBUG_ECHOLNPAIR("(1) Place old tool ", int(active_extruder));
+    DEBUG_ECHOLNPAIR("(1) Place old tool ", active_extruder);
     DEBUG_POS("Move X SwitchPos", current_position);
 
     fast_line_to_current(X_AXIS);
 
     current_position.y = SWITCHING_TOOLHEAD_Y_POS - (SWITCHING_TOOLHEAD_Y_SECURITY);
 
     DEBUG_SYNCHRONIZE();
     DEBUG_POS("Move Y SwitchPos + Security", current_position);
 
     fast_line_to_current(Y_AXIS);
@@ -502,21 +502,21 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
      * 3. Move to the new toolhead
      * 4. Grab the new toolhead and move to security position
      */
 
     DEBUG_POS("Start MST Tool-Change", current_position);
 
     // 1. Move to switch position current toolhead
 
     current_position.y = SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_CLEAR;
 
-    SERIAL_ECHOLNPAIR("(1) Place old tool ", int(active_extruder));
+    SERIAL_ECHOLNPAIR("(1) Place old tool ", active_extruder);
     DEBUG_POS("Move Y SwitchPos + Security", current_position);
 
     fast_line_to_current(Y_AXIS);
 
     current_position.x = placexclear;
 
     DEBUG_SYNCHRONIZE();
     DEBUG_POS("Move X SwitchPos + Security", current_position);
 
     fast_line_to_current(X_AXIS);
@@ -702,21 +702,21 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
     current_position.z += hoffs.z - hotend_offset[new_tool].z;
 
     DEBUG_POS("EMST Tool-Change done.", current_position);
   }
 
 #endif // ELECTROMAGNETIC_SWITCHING_TOOLHEAD
 
 #if EXTRUDERS
   inline void invalid_extruder_error(const uint8_t e) {
     SERIAL_ECHO_START();
-    SERIAL_CHAR('T'); SERIAL_ECHO((int)e);
+    SERIAL_CHAR('T'); SERIAL_ECHO(e);
     SERIAL_CHAR(' '); SERIAL_ECHOLNPGM(STR_INVALID_EXTRUDER);
   }
 #endif
 
 #if ENABLED(DUAL_X_CARRIAGE)
 
   /**
    * @brief Dual X Tool Change
    * @details Change tools, with extra behavior based on current mode
    *
@@ -1189,21 +1189,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
       move_extruder_servo(active_extruder);
     #endif
 
     TERN_(HAS_FANMUX, fanmux_switch(active_extruder));
 
     #ifdef EVENT_GCODE_AFTER_TOOLCHANGE
       if (!no_move && TERN1(DUAL_X_CARRIAGE, dual_x_carriage_mode == DXC_AUTO_PARK_MODE))
         gcode.process_subcommands_now_P(PSTR(EVENT_GCODE_AFTER_TOOLCHANGE));
     #endif
 
-    SERIAL_ECHO_MSG(STR_ACTIVE_EXTRUDER, int(active_extruder));
+    SERIAL_ECHO_MSG(STR_ACTIVE_EXTRUDER, active_extruder);
 
   #endif // HAS_MULTI_EXTRUDER
 }
 
 #if ENABLED(TOOLCHANGE_MIGRATION_FEATURE)
 
   #define DEBUG_OUT ENABLED(DEBUG_TOOLCHANGE_MIGRATION_FEATURE)
   #include "../core/debug_out.h"
 
   bool extruder_migration() {

commit 708ea3d0bb82f067424c75636c28a549aa3d3b06
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Feb 4 23:22:42 2021 -0600

    Use serial shorthand

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 4278e6be26..191617be30 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -1189,22 +1189,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
       move_extruder_servo(active_extruder);
     #endif
 
     TERN_(HAS_FANMUX, fanmux_switch(active_extruder));
 
     #ifdef EVENT_GCODE_AFTER_TOOLCHANGE
       if (!no_move && TERN1(DUAL_X_CARRIAGE, dual_x_carriage_mode == DXC_AUTO_PARK_MODE))
         gcode.process_subcommands_now_P(PSTR(EVENT_GCODE_AFTER_TOOLCHANGE));
     #endif
 
-    SERIAL_ECHO_START();
-    SERIAL_ECHOLNPAIR(STR_ACTIVE_EXTRUDER, int(active_extruder));
+    SERIAL_ECHO_MSG(STR_ACTIVE_EXTRUDER, int(active_extruder));
 
   #endif // HAS_MULTI_EXTRUDER
 }
 
 #if ENABLED(TOOLCHANGE_MIGRATION_FEATURE)
 
   #define DEBUG_OUT ENABLED(DEBUG_TOOLCHANGE_MIGRATION_FEATURE)
   #include "../core/debug_out.h"
 
   bool extruder_migration() {

commit 27366197f3380627af365b005702bbe16393a18a
Author: X-Ryl669 <boite.pour.spam@gmail.com>
Date:   Mon Feb 1 00:21:27 2021 +0100

    Serial refactor followup (#20932)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 867ae5d927..4278e6be26 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -702,21 +702,21 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
     current_position.z += hoffs.z - hotend_offset[new_tool].z;
 
     DEBUG_POS("EMST Tool-Change done.", current_position);
   }
 
 #endif // ELECTROMAGNETIC_SWITCHING_TOOLHEAD
 
 #if EXTRUDERS
   inline void invalid_extruder_error(const uint8_t e) {
     SERIAL_ECHO_START();
-    SERIAL_CHAR('T'); SERIAL_ECHO(int(e));
+    SERIAL_CHAR('T'); SERIAL_ECHO((int)e);
     SERIAL_CHAR(' '); SERIAL_ECHOLNPGM(STR_INVALID_EXTRUDER);
   }
 #endif
 
 #if ENABLED(DUAL_X_CARRIAGE)
 
   /**
    * @brief Dual X Tool Change
    * @details Change tools, with extra behavior based on current mode
    *

commit b8186b50817d33999a414400d82d876da7b40ee9
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jan 25 08:32:58 2021 -0600

    Apply SEC_TO_MS and other fixes

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 052b8cd34a..867ae5d927 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -821,21 +821,21 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
       unscaled_e_move(toolchange_settings.swap_length + toolchange_settings.extra_prime, MMM_TO_MMS(toolchange_settings.prime_speed));
 
       // Cutting retraction
       #if TOOLCHANGE_FS_WIPE_RETRACT
         unscaled_e_move(-(TOOLCHANGE_FS_WIPE_RETRACT), MMM_TO_MMS(toolchange_settings.retract_speed));
       #endif
 
       // Cool down with fan
       #if HAS_FAN && TOOLCHANGE_FS_FAN >= 0
         thermalManager.fan_speed[TOOLCHANGE_FS_FAN] = toolchange_settings.fan_speed;
-        gcode.dwell(toolchange_settings.fan_time * 1000);
+        gcode.dwell(SEC_TO_MS(toolchange_settings.fan_time));
         thermalManager.fan_speed[TOOLCHANGE_FS_FAN] = 0;
       #endif
 
       // Move back
       #if ENABLED(TOOLCHANGE_PARK)
         if (ok) {
           #if ENABLED(TOOLCHANGE_NO_RETURN)
             do_blocking_move_to_z(destination.z, planner.settings.max_feedrate_mm_s[Z_AXIS]);
           #else
             do_blocking_move_to(destination, MMM_TO_MMS(TOOLCHANGE_PARK_XY_FEEDRATE));
@@ -1095,21 +1095,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
             unscaled_e_move(toolchange_settings.extra_prime, MMM_TO_MMS(toolchange_settings.prime_speed));
 
             // Cutting retraction
             #if TOOLCHANGE_FS_WIPE_RETRACT
               unscaled_e_move(-(TOOLCHANGE_FS_WIPE_RETRACT), MMM_TO_MMS(toolchange_settings.retract_speed));
             #endif
 
             // Cool down with fan
             #if HAS_FAN && TOOLCHANGE_FS_FAN >= 0
               thermalManager.fan_speed[TOOLCHANGE_FS_FAN] = toolchange_settings.fan_speed;
-              gcode.dwell(toolchange_settings.fan_time * 1000);
+              gcode.dwell(SEC_TO_MS(toolchange_settings.fan_time));
               thermalManager.fan_speed[TOOLCHANGE_FS_FAN] = 0;
             #endif
           }
         #endif
 
         // Prevent a move outside physical bounds
         #if ENABLED(MAGNETIC_SWITCHING_TOOLHEAD)
           // If the original position is within tool store area, go to X origin at once
           if (destination.y < SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_CLEAR) {
             current_position.x = 0;

commit 3f90ecfd77b608908d9a945a79518842f6d4471e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jan 19 20:58:50 2021 -0600

    Move singlenozzle temp/fan (#20829)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 95f32f2faa..052b8cd34a 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -42,28 +42,20 @@
 
 #if ENABLED(TOOLCHANGE_MIGRATION_FEATURE)
   migration_settings_t migration = migration_defaults;
   bool enable_first_prime;
 #endif
 
 #if ENABLED(TOOLCHANGE_FS_INIT_BEFORE_SWAP)
   bool toolchange_extruder_ready[EXTRUDERS];
 #endif
 
-#if ENABLED(SINGLENOZZLE_STANDBY_TEMP)
-  uint16_t singlenozzle_temp[EXTRUDERS];
-#endif
-
-#if BOTH(HAS_FAN, SINGLENOZZLE_STANDBY_FAN)
-  uint8_t singlenozzle_fan_speed[EXTRUDERS];
-#endif
-
 #if ENABLED(MAGNETIC_PARKING_EXTRUDER) || defined(EVENT_GCODE_AFTER_TOOLCHANGE) || (ENABLED(PARKING_EXTRUDER) && PARKING_EXTRUDER_SOLENOIDS_DELAY > 0)
   #include "../gcode/gcode.h"
 #endif
 
 #if ENABLED(DUAL_X_CARRIAGE)
   #include "stepper.h"
 #endif
 
 #if ANY(SWITCHING_EXTRUDER, SWITCHING_NOZZLE, SWITCHING_TOOLHEAD)
   #include "servo.h"
@@ -1074,34 +1066,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
         //LOOP_XYZ(i) update_software_endstops(i); // or modify the constrain function
         const bool safe_to_move = current_position.z < delta_clip_start_height - 1;
       #else
         constexpr bool safe_to_move = true;
       #endif
 
       // Return to position and lower again
       const bool should_move = safe_to_move && !no_move && IsRunning();
       if (should_move) {
 
-        #if BOTH(HAS_FAN, SINGLENOZZLE_STANDBY_FAN)
-          singlenozzle_fan_speed[old_tool] = thermalManager.fan_speed[0];
-          thermalManager.fan_speed[0] = singlenozzle_fan_speed[new_tool];
-        #endif
-
-        #if ENABLED(SINGLENOZZLE_STANDBY_TEMP)
-          singlenozzle_temp[old_tool] = thermalManager.temp_hotend[0].target;
-          if (singlenozzle_temp[new_tool] && singlenozzle_temp[new_tool] != singlenozzle_temp[old_tool]) {
-            thermalManager.setTargetHotend(singlenozzle_temp[new_tool], 0);
-            TERN_(AUTOTEMP, planner.autotemp_update());
-            TERN_(HAS_DISPLAY, thermalManager.set_heating_message(0));
-            (void)thermalManager.wait_for_hotend(0, false);  // Wait for heating or cooling
-          }
-        #endif
+        TERN_(SINGLENOZZLE_STANDBY_TEMP, thermalManager.singlenozzle_change(old_tool, new_tool));
 
         #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
           if (should_swap && !too_cold) {
 
             float fr = toolchange_settings.unretract_speed;
 
             #if ENABLED(TOOLCHANGE_FS_INIT_BEFORE_SWAP)
               if (!toolchange_extruder_ready[new_tool]) {
                 toolchange_extruder_ready[new_tool] = true;
                 fr = toolchange_settings.prime_speed;       // Next move is a prime

commit 1b19eed195cbfe182a7c6c357603eb08c011123d
Author: zeleps <39417467+zeleps@users.noreply.github.com>
Date:   Sun Jan 17 07:08:48 2021 +0200

    Fix Tramming Wizard behavior (#20796)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 7f581131d8..95f32f2faa 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -911,21 +911,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
     #endif
 
     if (new_tool >= EXTRUDERS)
       return invalid_extruder_error(new_tool);
 
     if (!no_move && homing_needed()) {
       no_move = true;
       DEBUG_ECHOLNPGM("No move (not homed)");
     }
 
-    TERN_(HAS_LCD_MENU, if (!no_move) ui.return_to_status());
+    TERN_(HAS_LCD_MENU, if (!no_move) ui.update());
 
     #if ENABLED(DUAL_X_CARRIAGE)
       const bool idex_full_control = dual_x_carriage_mode == DXC_FULL_CONTROL_MODE;
     #else
       constexpr bool idex_full_control = false;
     #endif
 
     const uint8_t old_tool = active_extruder;
     const bool can_move_away = !no_move && !idex_full_control;
 

commit 2f17f2207a056bef5449869161fa56e50011da31
Author: zeleps <39417467+zeleps@users.noreply.github.com>
Date:   Tue Jan 5 07:48:42 2021 +0200

    Don't apply hotend_offset.z to Z soft endstops (#20675)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index f3f3ee0595..7f581131d8 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -285,22 +285,20 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
       DEBUG_ECHOLNPAIR("Disengage magnet", (int)(1 - final_tool));
       pe_solenoid_magnet_on(final_tool);
       DEBUG_ECHOLNPAIR("Engage magnet", (int)final_tool);
       parking_extruder_set_parked(false);
       return false;
     }
 
     return true;
   }
 
-  void parking_extruder_set_parked() { extruder_parked = true; }
-
   inline void parking_extruder_tool_change(const uint8_t new_tool, bool no_move) {
     if (!no_move) {
 
       constexpr float parkingposx[] = PARKING_EXTRUDER_PARKING_X;
 
       #if HAS_HOTEND_OFFSET
         const float x_offset = hotend_offset[active_extruder].x;
       #else
         constexpr float x_offset = 0;
       #endif
@@ -371,21 +369,21 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
 
       current_position.x = midpos - TERN0(HAS_HOTEND_OFFSET, hotend_offset[new_tool].x);
 
       DEBUG_SYNCHRONIZE();
       DEBUG_POS("(6) Move midway between hotends", current_position);
 
       fast_line_to_current(X_AXIS);
       planner.synchronize(); // Always sync the final move
 
       DEBUG_POS("PE Tool-Change done.", current_position);
-      extruder_parked = false;
+      parking_extruder_set_parked(false);
     }
     else if (do_solenoid_activation) { // && nomove == true
       // Deactivate current extruder solenoid
       pe_solenoid_set_pin_state(active_extruder, !PARKING_EXTRUDER_SOLENOIDS_PINS_ACTIVE);
       // Engage new extruder magnetic field
       pe_solenoid_set_pin_state(new_tool, PARKING_EXTRUDER_SOLENOIDS_PINS_ACTIVE);
     }
 
     do_solenoid_activation = true; // Activate solenoid for subsequent tool_change()
   }

commit d2e1e9a0ac260c56026279ac5657fe81ec399c77
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jan 4 23:35:56 2021 -0600

    Indent tool_change_prime

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index cfa2e3c714..f3f3ee0595 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -786,89 +786,90 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
     DEBUG_POS("New extruder (parked)", current_position);
   }
 
 #endif // DUAL_X_CARRIAGE
 
 /**
  * Prime active tool using TOOLCHANGE_FILAMENT_SWAP settings
  */
 #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
 
-void tool_change_prime() {
-  if (toolchange_settings.extra_prime > 0
-    && TERN(PREVENT_COLD_EXTRUSION, !thermalManager.targetTooColdToExtrude(active_extruder), 1)
-  ) {
-    destination = current_position; // Remember the old position
-
-    const bool ok = TERN1(TOOLCHANGE_PARK, all_axes_homed() && toolchange_settings.enable_park);
+  void tool_change_prime() {
+    if (toolchange_settings.extra_prime > 0
+      && TERN(PREVENT_COLD_EXTRUSION, !thermalManager.targetTooColdToExtrude(active_extruder), 1)
+    ) {
+      destination = current_position; // Remember the old position
 
-    #if HAS_FAN && TOOLCHANGE_FS_FAN >= 0
-      // Store and stop fan. Restored on any exit.
-      REMEMBER(fan, thermalManager.fan_speed[TOOLCHANGE_FS_FAN], 0);
-    #endif
+      const bool ok = TERN1(TOOLCHANGE_PARK, all_axes_homed() && toolchange_settings.enable_park);
 
-    // Z raise
-    if (ok) {
-      // Do a small lift to avoid the workpiece in the move back (below)
-      current_position.z += toolchange_settings.z_raise;
-      #if HAS_SOFTWARE_ENDSTOPS
-        NOMORE(current_position.z, soft_endstop.max.z);
+      #if HAS_FAN && TOOLCHANGE_FS_FAN >= 0
+        // Store and stop fan. Restored on any exit.
+        REMEMBER(fan, thermalManager.fan_speed[TOOLCHANGE_FS_FAN], 0);
       #endif
-      fast_line_to_current(Z_AXIS);
-      planner.synchronize();
-    }
 
-    // Park
-    #if ENABLED(TOOLCHANGE_PARK)
+      // Z raise
       if (ok) {
-        IF_DISABLED(TOOLCHANGE_PARK_Y_ONLY, current_position.x = toolchange_settings.change_point.x);
-        IF_DISABLED(TOOLCHANGE_PARK_X_ONLY, current_position.y = toolchange_settings.change_point.y);
-        planner.buffer_line(current_position, MMM_TO_MMS(TOOLCHANGE_PARK_XY_FEEDRATE), active_extruder);
+        // Do a small lift to avoid the workpiece in the move back (below)
+        current_position.z += toolchange_settings.z_raise;
+        #if HAS_SOFTWARE_ENDSTOPS
+          NOMORE(current_position.z, soft_endstop.max.z);
+        #endif
+        fast_line_to_current(Z_AXIS);
         planner.synchronize();
       }
-    #endif
 
-    // Prime (All distances are added and slowed down to ensure secure priming in all circumstances)
-    unscaled_e_move(toolchange_settings.swap_length + toolchange_settings.extra_prime, MMM_TO_MMS(toolchange_settings.prime_speed));
+      // Park
+      #if ENABLED(TOOLCHANGE_PARK)
+        if (ok) {
+          IF_DISABLED(TOOLCHANGE_PARK_Y_ONLY, current_position.x = toolchange_settings.change_point.x);
+          IF_DISABLED(TOOLCHANGE_PARK_X_ONLY, current_position.y = toolchange_settings.change_point.y);
+          planner.buffer_line(current_position, MMM_TO_MMS(TOOLCHANGE_PARK_XY_FEEDRATE), active_extruder);
+          planner.synchronize();
+        }
+      #endif
 
-    // Cutting retraction
-    #if TOOLCHANGE_FS_WIPE_RETRACT
-      unscaled_e_move(-(TOOLCHANGE_FS_WIPE_RETRACT), MMM_TO_MMS(toolchange_settings.retract_speed));
-    #endif
+      // Prime (All distances are added and slowed down to ensure secure priming in all circumstances)
+      unscaled_e_move(toolchange_settings.swap_length + toolchange_settings.extra_prime, MMM_TO_MMS(toolchange_settings.prime_speed));
 
-    // Cool down with fan
-    #if HAS_FAN && TOOLCHANGE_FS_FAN >= 0
-      thermalManager.fan_speed[TOOLCHANGE_FS_FAN] = toolchange_settings.fan_speed;
-      gcode.dwell(toolchange_settings.fan_time * 1000);
-      thermalManager.fan_speed[TOOLCHANGE_FS_FAN] = 0;
-    #endif
+      // Cutting retraction
+      #if TOOLCHANGE_FS_WIPE_RETRACT
+        unscaled_e_move(-(TOOLCHANGE_FS_WIPE_RETRACT), MMM_TO_MMS(toolchange_settings.retract_speed));
+      #endif
 
-    // Move back
-    #if ENABLED(TOOLCHANGE_PARK)
-      if (ok) {
-        #if ENABLED(TOOLCHANGE_NO_RETURN)
-          do_blocking_move_to_z(destination.z, planner.settings.max_feedrate_mm_s[Z_AXIS]);
-        #else
-          do_blocking_move_to(destination, MMM_TO_MMS(TOOLCHANGE_PARK_XY_FEEDRATE));
-        #endif
-      }
-    #endif
+      // Cool down with fan
+      #if HAS_FAN && TOOLCHANGE_FS_FAN >= 0
+        thermalManager.fan_speed[TOOLCHANGE_FS_FAN] = toolchange_settings.fan_speed;
+        gcode.dwell(toolchange_settings.fan_time * 1000);
+        thermalManager.fan_speed[TOOLCHANGE_FS_FAN] = 0;
+      #endif
+
+      // Move back
+      #if ENABLED(TOOLCHANGE_PARK)
+        if (ok) {
+          #if ENABLED(TOOLCHANGE_NO_RETURN)
+            do_blocking_move_to_z(destination.z, planner.settings.max_feedrate_mm_s[Z_AXIS]);
+          #else
+            do_blocking_move_to(destination, MMM_TO_MMS(TOOLCHANGE_PARK_XY_FEEDRATE));
+          #endif
+        }
+      #endif
 
-    // Cutting recover
-    unscaled_e_move(toolchange_settings.extra_resume + TOOLCHANGE_FS_WIPE_RETRACT, MMM_TO_MMS(toolchange_settings.unretract_speed));
+      // Cutting recover
+      unscaled_e_move(toolchange_settings.extra_resume + TOOLCHANGE_FS_WIPE_RETRACT, MMM_TO_MMS(toolchange_settings.unretract_speed));
 
-    planner.synchronize();
-    current_position.e = destination.e;
-    sync_plan_position_e(); // Resume at the old E position
+      planner.synchronize();
+      current_position.e = destination.e;
+      sync_plan_position_e(); // Resume at the old E position
+    }
   }
-}
-#endif
+
+#endif // TOOLCHANGE_FILAMENT_SWAP
 
 /**
  * Perform a tool-change, which may result in moving the
  * previous tool out of the way and the new tool into place.
  */
 void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
 
   if (TERN0(MAGNETIC_SWITCHING_TOOLHEAD, new_tool == active_extruder))
     return;
 

commit c0a3931595a18bf0cb7e1eb381483aeb520dd5a9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jan 4 23:09:35 2021 -0600

    Clarify solenoid active / magnet-on state

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 7e78b5fec3..cfa2e3c714 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -252,48 +252,47 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
 
     planner.buffer_line(current_position, mpe_settings.fast_feedrate, new_tool);
     planner.synchronize();
 
     DEBUG_ECHOLNPGM("Autopark done.");
   }
 
 #elif ENABLED(PARKING_EXTRUDER)
 
   void pe_solenoid_init() {
-    LOOP_LE_N(n, 1)
-      TERN(PARKING_EXTRUDER_SOLENOIDS_INVERT, pe_activate_solenoid, pe_deactivate_solenoid)(n);
+    LOOP_LE_N(n, 1) pe_solenoid_set_pin_state(n, !PARKING_EXTRUDER_SOLENOIDS_PINS_ACTIVE);
   }
 
-  void pe_set_solenoid(const uint8_t extruder_num, const uint8_t state) {
+  void pe_solenoid_set_pin_state(const uint8_t extruder_num, const uint8_t state) {
     switch (extruder_num) {
       case 1: OUT_WRITE(SOL1_PIN, state); break;
       default: OUT_WRITE(SOL0_PIN, state); break;
     }
     #if PARKING_EXTRUDER_SOLENOIDS_DELAY > 0
       gcode.dwell(PARKING_EXTRUDER_SOLENOIDS_DELAY);
     #endif
   }
 
   bool extruder_parked = true, do_solenoid_activation = true;
 
   // Modifies tool_change() behavior based on homing side
   bool parking_extruder_unpark_after_homing(const uint8_t final_tool, bool homed_towards_final_tool) {
     do_solenoid_activation = false; // Tell parking_extruder_tool_change to skip solenoid activation
 
     if (!extruder_parked) return false; // nothing to do
 
     if (homed_towards_final_tool) {
-      pe_deactivate_solenoid(1 - final_tool);
+      pe_solenoid_magnet_off(1 - final_tool);
       DEBUG_ECHOLNPAIR("Disengage magnet", (int)(1 - final_tool));
-      pe_activate_solenoid(final_tool);
+      pe_solenoid_magnet_on(final_tool);
       DEBUG_ECHOLNPAIR("Engage magnet", (int)final_tool);
-      extruder_parked = false;
+      parking_extruder_set_parked(false);
       return false;
     }
 
     return true;
   }
 
   void parking_extruder_set_parked() { extruder_parked = true; }
 
   inline void parking_extruder_tool_change(const uint8_t new_tool, bool no_move) {
     if (!no_move) {
@@ -328,40 +327,40 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
 
         DEBUG_ECHOLNPAIR("(1) Park extruder ", int(active_extruder));
         DEBUG_POS("Moving ParkPos", current_position);
 
         fast_line_to_current(X_AXIS);
 
         // STEP 2
 
         planner.synchronize();
         DEBUG_ECHOLNPGM("(2) Disengage magnet");
-        pe_deactivate_solenoid(active_extruder);
+        pe_solenoid_magnet_off(active_extruder);
 
         // STEP 3
 
         current_position.x += active_extruder ? -10 : 10; // move 10mm away from parked extruder
 
         DEBUG_ECHOLNPGM("(3) Move near new extruder");
         DEBUG_POS("Move away from parked extruder", current_position);
 
         fast_line_to_current(X_AXIS);
       }
 
       // STEP 4
 
       planner.synchronize();
       DEBUG_ECHOLNPGM("(4) Engage magnetic field");
 
       // Just save power for inverted magnets
-      TERN_(PARKING_EXTRUDER_SOLENOIDS_INVERT, pe_activate_solenoid(active_extruder));
-      pe_activate_solenoid(new_tool);
+      TERN_(PARKING_EXTRUDER_SOLENOIDS_INVERT, pe_solenoid_magnet_on(active_extruder));
+      pe_solenoid_magnet_on(new_tool);
 
       // STEP 5
 
       current_position.x = grabpos + (new_tool ? -10 : 10);
       fast_line_to_current(X_AXIS);
 
       current_position.x = grabpos;
 
       DEBUG_SYNCHRONIZE();
       DEBUG_POS("(5) Unpark extruder", current_position);
@@ -375,24 +374,24 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
       DEBUG_SYNCHRONIZE();
       DEBUG_POS("(6) Move midway between hotends", current_position);
 
       fast_line_to_current(X_AXIS);
       planner.synchronize(); // Always sync the final move
 
       DEBUG_POS("PE Tool-Change done.", current_position);
       extruder_parked = false;
     }
     else if (do_solenoid_activation) { // && nomove == true
-      // Deactivate old extruder solenoid
-      TERN(PARKING_EXTRUDER_SOLENOIDS_INVERT, pe_activate_solenoid, pe_deactivate_solenoid)(active_extruder);
-      // Only engage magnetic field for new extruder
-      TERN(PARKING_EXTRUDER_SOLENOIDS_INVERT, pe_deactivate_solenoid, pe_activate_solenoid)(new_tool);
+      // Deactivate current extruder solenoid
+      pe_solenoid_set_pin_state(active_extruder, !PARKING_EXTRUDER_SOLENOIDS_PINS_ACTIVE);
+      // Engage new extruder magnetic field
+      pe_solenoid_set_pin_state(new_tool, PARKING_EXTRUDER_SOLENOIDS_PINS_ACTIVE);
     }
 
     do_solenoid_activation = true; // Activate solenoid for subsequent tool_change()
   }
 
 #endif // PARKING_EXTRUDER
 
 #if ENABLED(SWITCHING_TOOLHEAD)
 
   inline void swt_lock(const bool locked=true) {
@@ -1142,24 +1141,22 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
         #else
           apply_motion_limits(destination);
         #endif
 
         // Should the nozzle move back to the old position?
         if (can_move_away) {
           #if ENABLED(TOOLCHANGE_NO_RETURN)
             // Just move back down
             DEBUG_ECHOLNPGM("Move back Z only");
 
-            #if ENABLED(TOOLCHANGE_PARK)
-              if (toolchange_settings.enable_park)
-            #endif
-            do_blocking_move_to_z(destination.z, planner.settings.max_feedrate_mm_s[Z_AXIS]);
+            if (TERN1(TOOLCHANGE_PARK, toolchange_settings.enable_park))
+              do_blocking_move_to_z(destination.z, planner.settings.max_feedrate_mm_s[Z_AXIS]);
 
           #else
             // Move back to the original (or adjusted) position
             DEBUG_POS("Move back", destination);
 
             #if ENABLED(TOOLCHANGE_PARK)
               if (toolchange_settings.enable_park) do_blocking_move_to_xy_z(destination, destination.z, MMM_TO_MMS(TOOLCHANGE_PARK_XY_FEEDRATE));
             #else
               do_blocking_move_to_xy(destination, planner.settings.max_feedrate_mm_s[X_AXIS]);
               do_blocking_move_to_z(destination.z, planner.settings.max_feedrate_mm_s[Z_AXIS]);

commit 3a99d001ff87e33533af324f28d50977eec1c1b7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jan 4 19:01:45 2021 -0600

    Solenoid cleanups
    
    Followups to #20473 ahead of #20675

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index a310442126..7e78b5fec3 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -253,25 +253,21 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
     planner.buffer_line(current_position, mpe_settings.fast_feedrate, new_tool);
     planner.synchronize();
 
     DEBUG_ECHOLNPGM("Autopark done.");
   }
 
 #elif ENABLED(PARKING_EXTRUDER)
 
   void pe_solenoid_init() {
     LOOP_LE_N(n, 1)
-      #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
-        pe_activate_solenoid(n);
-      #else
-        pe_deactivate_solenoid(n);
-      #endif
+      TERN(PARKING_EXTRUDER_SOLENOIDS_INVERT, pe_activate_solenoid, pe_deactivate_solenoid)(n);
   }
 
   void pe_set_solenoid(const uint8_t extruder_num, const uint8_t state) {
     switch (extruder_num) {
       case 1: OUT_WRITE(SOL1_PIN, state); break;
       default: OUT_WRITE(SOL0_PIN, state); break;
     }
     #if PARKING_EXTRUDER_SOLENOIDS_DELAY > 0
       gcode.dwell(PARKING_EXTRUDER_SOLENOIDS_DELAY);
     #endif

commit 815c636449e399651ee0751b63ed36f2d28415e0
Author: zeleps <39417467+zeleps@users.noreply.github.com>
Date:   Fri Jan 1 22:54:44 2021 +0200

    Fix PARKING_EXTRUDER homing with solenoid (#20473)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index a981931917..a310442126 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -270,20 +270,42 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
   void pe_set_solenoid(const uint8_t extruder_num, const uint8_t state) {
     switch (extruder_num) {
       case 1: OUT_WRITE(SOL1_PIN, state); break;
       default: OUT_WRITE(SOL0_PIN, state); break;
     }
     #if PARKING_EXTRUDER_SOLENOIDS_DELAY > 0
       gcode.dwell(PARKING_EXTRUDER_SOLENOIDS_DELAY);
     #endif
   }
 
+  bool extruder_parked = true, do_solenoid_activation = true;
+
+  // Modifies tool_change() behavior based on homing side
+  bool parking_extruder_unpark_after_homing(const uint8_t final_tool, bool homed_towards_final_tool) {
+    do_solenoid_activation = false; // Tell parking_extruder_tool_change to skip solenoid activation
+
+    if (!extruder_parked) return false; // nothing to do
+
+    if (homed_towards_final_tool) {
+      pe_deactivate_solenoid(1 - final_tool);
+      DEBUG_ECHOLNPAIR("Disengage magnet", (int)(1 - final_tool));
+      pe_activate_solenoid(final_tool);
+      DEBUG_ECHOLNPAIR("Engage magnet", (int)final_tool);
+      extruder_parked = false;
+      return false;
+    }
+
+    return true;
+  }
+
+  void parking_extruder_set_parked() { extruder_parked = true; }
+
   inline void parking_extruder_tool_change(const uint8_t new_tool, bool no_move) {
     if (!no_move) {
 
       constexpr float parkingposx[] = PARKING_EXTRUDER_PARKING_X;
 
       #if HAS_HOTEND_OFFSET
         const float x_offset = hotend_offset[active_extruder].x;
       #else
         constexpr float x_offset = 0;
       #endif
@@ -297,41 +319,44 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
        * 3. Move near new extruder
        * 4. Engage magnetic field for new extruder
        * 5. Move to parking incl. offset of new extruder
        * 6. Lower Z-Axis
        */
 
       // STEP 1
 
       DEBUG_POS("Start PE Tool-Change", current_position);
 
-      current_position.x = parkingposx[active_extruder] + x_offset;
+      // Don't park the active_extruder unless unparked
+      if (!extruder_parked) {
+        current_position.x = parkingposx[active_extruder] + x_offset;
 
-      DEBUG_ECHOLNPAIR("(1) Park extruder ", int(active_extruder));
-      DEBUG_POS("Moving ParkPos", current_position);
+        DEBUG_ECHOLNPAIR("(1) Park extruder ", int(active_extruder));
+        DEBUG_POS("Moving ParkPos", current_position);
 
-      fast_line_to_current(X_AXIS);
+        fast_line_to_current(X_AXIS);
 
-      // STEP 2
+        // STEP 2
 
-      planner.synchronize();
-      DEBUG_ECHOLNPGM("(2) Disengage magnet");
-      pe_deactivate_solenoid(active_extruder);
+        planner.synchronize();
+        DEBUG_ECHOLNPGM("(2) Disengage magnet");
+        pe_deactivate_solenoid(active_extruder);
 
-      // STEP 3
+        // STEP 3
 
-      current_position.x += active_extruder ? -10 : 10; // move 10mm away from parked extruder
+        current_position.x += active_extruder ? -10 : 10; // move 10mm away from parked extruder
 
-      DEBUG_ECHOLNPGM("(3) Move near new extruder");
-      DEBUG_POS("Move away from parked extruder", current_position);
+        DEBUG_ECHOLNPGM("(3) Move near new extruder");
+        DEBUG_POS("Move away from parked extruder", current_position);
 
-      fast_line_to_current(X_AXIS);
+        fast_line_to_current(X_AXIS);
+      }
 
       // STEP 4
 
       planner.synchronize();
       DEBUG_ECHOLNPGM("(4) Engage magnetic field");
 
       // Just save power for inverted magnets
       TERN_(PARKING_EXTRUDER_SOLENOIDS_INVERT, pe_activate_solenoid(active_extruder));
       pe_activate_solenoid(new_tool);
 
@@ -351,27 +376,30 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
 
       current_position.x = midpos - TERN0(HAS_HOTEND_OFFSET, hotend_offset[new_tool].x);
 
       DEBUG_SYNCHRONIZE();
       DEBUG_POS("(6) Move midway between hotends", current_position);
 
       fast_line_to_current(X_AXIS);
       planner.synchronize(); // Always sync the final move
 
       DEBUG_POS("PE Tool-Change done.", current_position);
+      extruder_parked = false;
     }
-    else { // nomove == true
+    else if (do_solenoid_activation) { // && nomove == true
+      // Deactivate old extruder solenoid
+      TERN(PARKING_EXTRUDER_SOLENOIDS_INVERT, pe_activate_solenoid, pe_deactivate_solenoid)(active_extruder);
       // Only engage magnetic field for new extruder
-      pe_activate_solenoid(new_tool);
-      // Just save power for inverted magnets
-      TERN_(PARKING_EXTRUDER_SOLENOIDS_INVERT, pe_activate_solenoid(active_extruder));
+      TERN(PARKING_EXTRUDER_SOLENOIDS_INVERT, pe_deactivate_solenoid, pe_activate_solenoid)(new_tool);
     }
+
+    do_solenoid_activation = true; // Activate solenoid for subsequent tool_change()
   }
 
 #endif // PARKING_EXTRUDER
 
 #if ENABLED(SWITCHING_TOOLHEAD)
 
   inline void swt_lock(const bool locked=true) {
     const uint16_t swt_angles[2] = SWITCHING_TOOLHEAD_SERVO_ANGLES;
     MOVE_SERVO(SWITCHING_TOOLHEAD_SERVO_NR, swt_angles[locked ? 0 : 1]);
   }
@@ -915,21 +943,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
     // First tool priming. To prime again, reboot the machine.
     #if BOTH(TOOLCHANGE_FILAMENT_SWAP, TOOLCHANGE_FS_PRIME_FIRST_USED)
       static bool first_tool_is_primed = false;
       if (new_tool == old_tool && !first_tool_is_primed && enable_first_prime) {
         tool_change_prime();
         first_tool_is_primed = true;
         toolchange_extruder_ready[old_tool] = true; // Primed and initialized
       }
     #endif
 
-    if (new_tool != old_tool) {
+    if (new_tool != old_tool || TERN0(PARKING_EXTRUDER, extruder_parked)) { // PARKING_EXTRUDER may need to attach old_tool when homing
       destination = current_position;
 
       #if BOTH(TOOLCHANGE_FILAMENT_SWAP, HAS_FAN) && TOOLCHANGE_FS_FAN >= 0
         // Store and stop fan. Restored on any exit.
         REMEMBER(fan, thermalManager.fan_speed[TOOLCHANGE_FS_FAN], 0);
       #endif
 
       // Z raise before retraction
       #if ENABLED(TOOLCHANGE_ZRAISE_BEFORE_RETRACT) && DISABLED(SWITCHING_NOZZLE)
         if (can_move_away && TERN1(TOOLCHANGE_PARK, toolchange_settings.enable_park)) {

commit 41529b65988a58ba512977e0fe1692aaeeb6c811
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Wed Nov 18 08:27:21 2020 +0100

    SMUFF (MMU2 clone) support (#19912)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index d77901f029..a981931917 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -66,38 +66,36 @@
 #endif
 
 #if ANY(SWITCHING_EXTRUDER, SWITCHING_NOZZLE, SWITCHING_TOOLHEAD)
   #include "servo.h"
 #endif
 
 #if ENABLED(EXT_SOLENOID) && DISABLED(PARKING_EXTRUDER)
   #include "../feature/solenoid.h"
 #endif
 
-#if ENABLED(MK2_MULTIPLEXER)
-  #include "../feature/snmm.h"
-#endif
-
 #if ENABLED(MIXING_EXTRUDER)
   #include "../feature/mixing.h"
 #endif
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if HAS_FANMUX
   #include "../feature/fanmux.h"
 #endif
 
-#if ENABLED(PRUSA_MMU2)
-  #include "../feature/mmu2/mmu2.h"
+#if HAS_PRUSA_MMU1
+  #include "../feature/mmu/mmu.h"
+#elif HAS_PRUSA_MMU2
+  #include "../feature/mmu/mmu2.h"
 #endif
 
 #if HAS_LCD_MENU
   #include "../lcd/marlinui.h"
 #endif
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   #include "../feature/pause.h"
 #endif
 
@@ -856,21 +854,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
     UNUSED(no_move);
 
     if (new_tool >= MIXING_VIRTUAL_TOOLS)
       return invalid_extruder_error(new_tool);
 
     #if MIXING_VIRTUAL_TOOLS > 1
       // T0-Tnnn: Switch virtual tool by changing the index to the mix
       mixer.T(new_tool);
     #endif
 
-  #elif ENABLED(PRUSA_MMU2)
+  #elif HAS_PRUSA_MMU2
 
     UNUSED(no_move);
 
     mmu2.tool_change(new_tool);
 
   #elif EXTRUDERS == 0
 
     // Nothing to do
     UNUSED(new_tool); UNUSED(no_move);
 
@@ -1164,34 +1162,32 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
 
         TERN_(DUAL_X_CARRIAGE, idex_set_parked(false));
       }
 
       #if ENABLED(SWITCHING_NOZZLE)
         // Move back down. (Including when the new tool is higher.)
         if (!should_move)
           do_blocking_move_to_z(destination.z, planner.settings.max_feedrate_mm_s[Z_AXIS]);
       #endif
 
-      TERN_(PRUSA_MMU2, mmu2.tool_change(new_tool));
-
       TERN_(SWITCHING_NOZZLE_TWO_SERVOS, lower_nozzle(new_tool));
 
     } // (new_tool != old_tool)
 
     planner.synchronize();
 
     #if ENABLED(EXT_SOLENOID) && DISABLED(PARKING_EXTRUDER)
       disable_all_solenoids();
       enable_solenoid_on_active_extruder();
     #endif
 
-    #if ENABLED(MK2_MULTIPLEXER)
+    #if HAS_PRUSA_MMU1
       if (new_tool >= E_STEPPERS) return invalid_extruder_error(new_tool);
       select_multiplexed_stepper(new_tool);
     #endif
 
     #if DO_SWITCH_EXTRUDER
       planner.synchronize();
       move_extruder_servo(active_extruder);
     #endif
 
     TERN_(HAS_FANMUX, fanmux_switch(active_extruder));

commit 5013fdaf796f695c1e1db55e6fd0c59e15aae25c
Author: Jason Smith <jason.inet@gmail.com>
Date:   Sun Nov 8 00:15:30 2020 -0800

    Fix tool-change servo index for E2 and up (#20060)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 0d0ef46059..d77901f029 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -116,21 +116,21 @@
   #else
     #define _SERVO_NR(E) SWITCHING_EXTRUDER_SERVO_NR
   #endif
 
   void move_extruder_servo(const uint8_t e) {
     planner.synchronize();
     #if EXTRUDERS & 1
       if (e < EXTRUDERS - 1)
     #endif
     {
-      MOVE_SERVO(_SERVO_NR(e), servo_angles[_SERVO_NR(e)][e]);
+      MOVE_SERVO(_SERVO_NR(e), servo_angles[_SERVO_NR(e)][e & 1]);
       safe_delay(500);
     }
   }
 
 #endif // DO_SWITCH_EXTRUDER
 
 #if ENABLED(SWITCHING_NOZZLE)
 
   #if SWITCHING_NOZZLE_TWO_SERVOS
 

commit 06bf3ccfb7a19c972e5f40816d49e3860711f976
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Nov 7 18:28:29 2020 -0600

    Add alternative TERN macros

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 1cdafe019d..0d0ef46059 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -792,22 +792,22 @@ void tool_change_prime() {
       #if HAS_SOFTWARE_ENDSTOPS
         NOMORE(current_position.z, soft_endstop.max.z);
       #endif
       fast_line_to_current(Z_AXIS);
       planner.synchronize();
     }
 
     // Park
     #if ENABLED(TOOLCHANGE_PARK)
       if (ok) {
-        TERN(TOOLCHANGE_PARK_Y_ONLY,,current_position.x = toolchange_settings.change_point.x);
-        TERN(TOOLCHANGE_PARK_X_ONLY,,current_position.y = toolchange_settings.change_point.y);
+        IF_DISABLED(TOOLCHANGE_PARK_Y_ONLY, current_position.x = toolchange_settings.change_point.x);
+        IF_DISABLED(TOOLCHANGE_PARK_X_ONLY, current_position.y = toolchange_settings.change_point.y);
         planner.buffer_line(current_position, MMM_TO_MMS(TOOLCHANGE_PARK_XY_FEEDRATE), active_extruder);
         planner.synchronize();
       }
     #endif
 
     // Prime (All distances are added and slowed down to ensure secure priming in all circumstances)
     unscaled_e_move(toolchange_settings.swap_length + toolchange_settings.extra_prime, MMM_TO_MMS(toolchange_settings.prime_speed));
 
     // Cutting retraction
     #if TOOLCHANGE_FS_WIPE_RETRACT
@@ -991,22 +991,22 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
           #if HAS_SOFTWARE_ENDSTOPS
             NOMORE(current_position.z, soft_endstop.max.z);
           #endif
           fast_line_to_current(Z_AXIS);
         }
       #endif
 
       // Toolchange park
       #if ENABLED(TOOLCHANGE_PARK) && DISABLED(SWITCHING_NOZZLE)
         if (can_move_away && toolchange_settings.enable_park) {
-          TERN(TOOLCHANGE_PARK_Y_ONLY,,current_position.x = toolchange_settings.change_point.x);
-          TERN(TOOLCHANGE_PARK_X_ONLY,,current_position.y = toolchange_settings.change_point.y);
+          IF_DISABLED(TOOLCHANGE_PARK_Y_ONLY, current_position.x = toolchange_settings.change_point.x);
+          IF_DISABLED(TOOLCHANGE_PARK_X_ONLY, current_position.y = toolchange_settings.change_point.y);
           planner.buffer_line(current_position, MMM_TO_MMS(TOOLCHANGE_PARK_XY_FEEDRATE), old_tool);
           planner.synchronize();
         }
       #endif
 
       #if HAS_HOTEND_OFFSET
         xyz_pos_t diff = hotend_offset[new_tool] - hotend_offset[old_tool];
         TERN_(DUAL_X_CARRIAGE, diff.x = 0);
       #else
         constexpr xyz_pos_t diff{0};

commit 21ce39aa9b304d627e6f2f7eecde873c7edb7af9
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Oct 19 04:24:57 2020 -0500

    Use PGM serial strings

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 2c1a1a6017..1cdafe019d 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -1202,69 +1202,60 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
     #endif
 
     SERIAL_ECHO_START();
     SERIAL_ECHOLNPAIR(STR_ACTIVE_EXTRUDER, int(active_extruder));
 
   #endif // HAS_MULTI_EXTRUDER
 }
 
 #if ENABLED(TOOLCHANGE_MIGRATION_FEATURE)
 
+  #define DEBUG_OUT ENABLED(DEBUG_TOOLCHANGE_MIGRATION_FEATURE)
+  #include "../core/debug_out.h"
+
   bool extruder_migration() {
 
     #if ENABLED(PREVENT_COLD_EXTRUSION)
       if (thermalManager.targetTooColdToExtrude(active_extruder)) {
-        #if ENABLED(DEBUG_TOOLCHANGE_MIGRATION_FEATURE)
-          SERIAL_ECHOLN("Migration Source Too Cold");
-        #endif
+        DEBUG_ECHOLNPGM("Migration Source Too Cold");
         return false;
       }
     #endif
 
     // No auto-migration or specified target?
     if (!migration.target && active_extruder >= migration.last) {
-      #if ENABLED(DEBUG_TOOLCHANGE_MIGRATION_FEATURE)
-        SERIAL_ECHO_MSG("No Migration Target");
-        SERIAL_ECHO_MSG("Target: ", migration.target,
-                        " Last: ", migration.last,
-                        " Active: ", active_extruder);
-      #endif
+      DEBUG_ECHO_MSG("No Migration Target");
+      DEBUG_ECHO_MSG("Target: ", migration.target, " Last: ", migration.last, " Active: ", active_extruder);
       migration.automode = false;
       return false;
     }
 
     // Migrate to a target or the next extruder
 
     uint8_t migration_extruder = active_extruder;
 
     if (migration.target) {
-      #if ENABLED(DEBUG_TOOLCHANGE_MIGRATION_FEATURE)
-        SERIAL_ECHOLN("Migration using fixed target");
-      #endif
+      DEBUG_ECHOLNPGM("Migration using fixed target");
       // Specified target ok?
       const int16_t t = migration.target - 1;
       if (t != active_extruder) migration_extruder = t;
     }
     else if (migration.automode && migration_extruder < migration.last && migration_extruder < EXTRUDERS - 1)
       migration_extruder++;
 
     if (migration_extruder == active_extruder) {
-      #if ENABLED(DEBUG_TOOLCHANGE_MIGRATION_FEATURE)
-        SERIAL_ECHOLN("Migration source matches active");
-      #endif
+      DEBUG_ECHOLNPGM("Migration source matches active");
       return false;
     }
 
     // Migration begins
-    #if ENABLED(DEBUG_TOOLCHANGE_MIGRATION_FEATURE)
-      SERIAL_ECHOLN("Beginning migration");
-    #endif
+    DEBUG_ECHOLNPGM("Beginning migration");
 
     migration.in_progress = true; // Prevent runout script
     planner.synchronize();
 
     // Remember position before migration
     const float resume_current_e = current_position.e;
 
     // Migrate the flow
     planner.set_flow(migration_extruder, planner.flow_percentage[active_extruder]);
 
@@ -1296,17 +1287,15 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
     // If no available extruder
     if (EXTRUDERS < 2 || active_extruder >= EXTRUDERS - 2 || active_extruder == migration.last)
       migration.automode = false;
 
     migration.in_progress = false;
 
     current_position.e = resume_current_e;
 
     planner.synchronize();
     planner.set_e_position_mm(current_position.e); // New extruder primed and ready
-    #if ENABLED(DEBUG_TOOLCHANGE_MIGRATION_FEATURE)
-      SERIAL_ECHOLN("Migration Complete");
-    #endif
+    DEBUG_ECHOLNPGM("Migration Complete");
     return true;
   }
 
 #endif // TOOLCHANGE_MIGRATION_FEATURE

commit eaf6777a6643a6fab23ceaaa4699cb2466ea6b83
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Oct 16 19:36:25 2020 -0500

    Rename ultralcd => marlinui

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 968e654aa3..2c1a1a6017 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -87,21 +87,21 @@
 
 #if HAS_FANMUX
   #include "../feature/fanmux.h"
 #endif
 
 #if ENABLED(PRUSA_MMU2)
   #include "../feature/mmu2/mmu2.h"
 #endif
 
 #if HAS_LCD_MENU
-  #include "../lcd/ultralcd.h"
+  #include "../lcd/marlinui.h"
 #endif
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   #include "../feature/pause.h"
 #endif
 
 #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
   #include "../gcode/gcode.h"
   #if TOOLCHANGE_FS_WIPE_RETRACT <= 0
     #undef TOOLCHANGE_FS_WIPE_RETRACT

commit 418b3e5ee26c0284561f07cf462af27971715d12
Author: nb-rapidia <43864438+nb-rapidia@users.noreply.github.com>
Date:   Fri Oct 16 14:59:55 2020 -0700

    Fix IDEX layer shift and DIR states (#19756)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 4ab818f41d..968e654aa3 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -54,20 +54,24 @@
 #endif
 
 #if BOTH(HAS_FAN, SINGLENOZZLE_STANDBY_FAN)
   uint8_t singlenozzle_fan_speed[EXTRUDERS];
 #endif
 
 #if ENABLED(MAGNETIC_PARKING_EXTRUDER) || defined(EVENT_GCODE_AFTER_TOOLCHANGE) || (ENABLED(PARKING_EXTRUDER) && PARKING_EXTRUDER_SOLENOIDS_DELAY > 0)
   #include "../gcode/gcode.h"
 #endif
 
+#if ENABLED(DUAL_X_CARRIAGE)
+  #include "stepper.h"
+#endif
+
 #if ANY(SWITCHING_EXTRUDER, SWITCHING_NOZZLE, SWITCHING_TOOLHEAD)
   #include "servo.h"
 #endif
 
 #if ENABLED(EXT_SOLENOID) && DISABLED(PARKING_EXTRUDER)
   #include "../feature/solenoid.h"
 #endif
 
 #if ENABLED(MK2_MULTIPLEXER)
   #include "../feature/snmm.h"
@@ -694,69 +698,76 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
 #if EXTRUDERS
   inline void invalid_extruder_error(const uint8_t e) {
     SERIAL_ECHO_START();
     SERIAL_CHAR('T'); SERIAL_ECHO(int(e));
     SERIAL_CHAR(' '); SERIAL_ECHOLNPGM(STR_INVALID_EXTRUDER);
   }
 #endif
 
 #if ENABLED(DUAL_X_CARRIAGE)
 
+  /**
+   * @brief Dual X Tool Change
+   * @details Change tools, with extra behavior based on current mode
+   *
+   * @param new_tool Tool index to activate
+   * @param no_move Flag indicating no moves should take place
+   */
   inline void dualx_tool_change(const uint8_t new_tool, bool &no_move) {
 
     DEBUG_ECHOPGM("Dual X Carriage Mode ");
     switch (dual_x_carriage_mode) {
       case DXC_FULL_CONTROL_MODE: DEBUG_ECHOLNPGM("FULL_CONTROL"); break;
       case DXC_AUTO_PARK_MODE:    DEBUG_ECHOLNPGM("AUTO_PARK");    break;
       case DXC_DUPLICATION_MODE:  DEBUG_ECHOLNPGM("DUPLICATION");  break;
       case DXC_MIRRORED_MODE:     DEBUG_ECHOLNPGM("MIRRORED");     break;
     }
 
+    // Get the home position of the currently-active tool
     const float xhome = x_home_pos(active_extruder);
-    if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE
-        && IsRunning() && !no_move
-        && (delayed_move_time || current_position.x != xhome)
-    ) {
 
+    if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE                  // If Auto-Park mode is enabled
+        && IsRunning() && !no_move                                  // ...and movement is permitted
+        && (delayed_move_time || current_position.x != xhome)       // ...and delayed_move_time is set OR not "already parked"...
+    ) {
       DEBUG_ECHOLNPAIR("MoveX to ", xhome);
-
-      // Park old head
       current_position.x = xhome;
-      line_to_current_position(planner.settings.max_feedrate_mm_s[X_AXIS]);
+      line_to_current_position(planner.settings.max_feedrate_mm_s[X_AXIS]);   // Park the current head
       planner.synchronize();
     }
 
     // Activate the new extruder ahead of calling set_axis_is_at_home!
     active_extruder = new_tool;
 
     // This function resets the max/min values - the current position may be overwritten below.
     set_axis_is_at_home(X_AXIS);
 
     DEBUG_POS("New Extruder", current_position);
 
     switch (dual_x_carriage_mode) {
       case DXC_FULL_CONTROL_MODE:
         // New current position is the position of the activated extruder
-        current_position.x = inactive_extruder_x_pos;
+        current_position.x = inactive_extruder_x;
         // Save the inactive extruder's position (from the old current_position)
-        inactive_extruder_x_pos = destination.x;
+        inactive_extruder_x = destination.x;
+        DEBUG_ECHOLNPAIR("DXC Full Control curr.x=", current_position.x, " dest.x=", destination.x);
         break;
       case DXC_AUTO_PARK_MODE:
-        // record current raised toolhead position for use by unpark
-        raised_parked_position = current_position;
-        active_extruder_parked = true;
-        delayed_move_time = 0;
+        idex_set_parked();
         break;
       default:
         break;
     }
 
+    // Ensure X axis DIR pertains to the correct carriage
+    stepper.set_directions();
+
     DEBUG_ECHOLNPAIR("Active extruder parked: ", active_extruder_parked ? "yes" : "no");
     DEBUG_POS("New extruder (parked)", current_position);
   }
 
 #endif // DUAL_X_CARRIAGE
 
 /**
  * Prime active tool using TOOLCHANGE_FILAMENT_SWAP settings
  */
 #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
@@ -868,21 +879,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
     UNUSED(no_move);
 
     if (new_tool) invalid_extruder_error(new_tool);
     return;
 
   #elif HAS_MULTI_EXTRUDER
 
     planner.synchronize();
 
     #if ENABLED(DUAL_X_CARRIAGE)  // Only T0 allowed if the Printer is in DXC_DUPLICATION_MODE or DXC_MIRRORED_MODE
-      if (new_tool != 0 && dxc_is_duplicating())
+      if (new_tool != 0 && idex_is_duplicating())
          return invalid_extruder_error(new_tool);
     #endif
 
     if (new_tool >= EXTRUDERS)
       return invalid_extruder_error(new_tool);
 
     if (!no_move && homing_needed()) {
       no_move = true;
       DEBUG_ECHOLNPGM("No move (not homed)");
     }
@@ -1144,21 +1155,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
             current_position.e = 0;
             sync_plan_position_e(); // New extruder primed and set to 0
 
             // Restart Fan
             #if HAS_FAN && TOOLCHANGE_FS_FAN >= 0
               RESTORE(fan);
             #endif
           }
         #endif
 
-        TERN_(DUAL_X_CARRIAGE, active_extruder_parked = false);
+        TERN_(DUAL_X_CARRIAGE, idex_set_parked(false));
       }
 
       #if ENABLED(SWITCHING_NOZZLE)
         // Move back down. (Including when the new tool is higher.)
         if (!should_move)
           do_blocking_move_to_z(destination.z, planner.settings.max_feedrate_mm_s[Z_AXIS]);
       #endif
 
       TERN_(PRUSA_MMU2, mmu2.tool_change(new_tool));
 

commit 193c0a52d9f1fbd31e42a29734f551aa26ed269a
Author: Earle F. Philhower, III <earlephilhower@yahoo.com>
Date:   Mon Oct 12 14:48:04 2020 -0700

    Add loose soft endstop state, apply to UBL fine-tune (#19681)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 0f823cfbd0..4ab818f41d 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -1010,28 +1010,24 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
       #elif ENABLED(SWITCHING_TOOLHEAD)                                 // Switching Toolhead
         switching_toolhead_tool_change(new_tool, no_move);
       #elif ENABLED(MAGNETIC_SWITCHING_TOOLHEAD)                        // Magnetic Switching Toolhead
         magnetic_switching_toolhead_tool_change(new_tool, no_move);
       #elif ENABLED(ELECTROMAGNETIC_SWITCHING_TOOLHEAD)                 // Magnetic Switching ToolChanger
         em_switching_toolhead_tool_change(new_tool, no_move);
       #elif ENABLED(SWITCHING_NOZZLE) && !SWITCHING_NOZZLE_TWO_SERVOS   // Switching Nozzle (single servo)
         // Raise by a configured distance to avoid workpiece, except with
         // SWITCHING_NOZZLE_TWO_SERVOS, as both nozzles will lift instead.
         if (!no_move) {
-          #if HAS_SOFTWARE_ENDSTOPS
-            const float maxz = _MIN(soft_endstop.max.z, Z_MAX_POS);
-          #else
-            constexpr float maxz = Z_MAX_POS;
-          #endif
+          const float newz = current_position.z + _MAX(-diff.z, 0.0);
 
           // Check if Z has space to compensate at least z_offset, and if not, just abort now
-          const float newz = current_position.z + _MAX(-diff.z, 0.0);
+          const float maxz = _MIN(TERN(HAS_SOFTWARE_ENDSTOPS, soft_endstop.max.z, Z_MAX_POS), Z_MAX_POS);
           if (newz > maxz) return;
 
           current_position.z = _MIN(newz + toolchange_settings.z_raise, maxz);
           fast_line_to_current(Z_AXIS);
         }
         move_nozzle_servo(new_tool);
       #endif
 
       // Set the new active extruder
       if (DISABLED(DUAL_X_CARRIAGE)) active_extruder = new_tool;

commit 76d8d1742c1d4a1efe0fd6c0645d3fc656bfd0b2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 20 18:29:08 2020 -0500

    Add multi-extruder condition

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 8557560266..0f823cfbd0 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -29,21 +29,21 @@
 #include "planner.h"
 #include "temperature.h"
 
 #include "../MarlinCore.h"
 
 //#define DEBUG_TOOL_CHANGE
 
 #define DEBUG_OUT ENABLED(DEBUG_TOOL_CHANGE)
 #include "../core/debug_out.h"
 
-#if EXTRUDERS > 1
+#if HAS_MULTI_EXTRUDER
   toolchange_settings_t toolchange_settings;  // Initialized by settings.load()
 #endif
 
 #if ENABLED(TOOLCHANGE_MIGRATION_FEATURE)
   migration_settings_t migration = migration_defaults;
   bool enable_first_prime;
 #endif
 
 #if ENABLED(TOOLCHANGE_FS_INIT_BEFORE_SWAP)
   bool toolchange_extruder_ready[EXTRUDERS];
@@ -863,21 +863,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
     // Nothing to do
     UNUSED(new_tool); UNUSED(no_move);
 
   #elif EXTRUDERS < 2
 
     UNUSED(no_move);
 
     if (new_tool) invalid_extruder_error(new_tool);
     return;
 
-  #else // EXTRUDERS > 1
+  #elif HAS_MULTI_EXTRUDER
 
     planner.synchronize();
 
     #if ENABLED(DUAL_X_CARRIAGE)  // Only T0 allowed if the Printer is in DXC_DUPLICATION_MODE or DXC_MIRRORED_MODE
       if (new_tool != 0 && dxc_is_duplicating())
          return invalid_extruder_error(new_tool);
     #endif
 
     if (new_tool >= EXTRUDERS)
       return invalid_extruder_error(new_tool);
@@ -1190,21 +1190,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
     TERN_(HAS_FANMUX, fanmux_switch(active_extruder));
 
     #ifdef EVENT_GCODE_AFTER_TOOLCHANGE
       if (!no_move && TERN1(DUAL_X_CARRIAGE, dual_x_carriage_mode == DXC_AUTO_PARK_MODE))
         gcode.process_subcommands_now_P(PSTR(EVENT_GCODE_AFTER_TOOLCHANGE));
     #endif
 
     SERIAL_ECHO_START();
     SERIAL_ECHOLNPAIR(STR_ACTIVE_EXTRUDER, int(active_extruder));
 
-  #endif // EXTRUDERS > 1
+  #endif // HAS_MULTI_EXTRUDER
 }
 
 #if ENABLED(TOOLCHANGE_MIGRATION_FEATURE)
 
   bool extruder_migration() {
 
     #if ENABLED(PREVENT_COLD_EXTRUSION)
       if (thermalManager.targetTooColdToExtrude(active_extruder)) {
         #if ENABLED(DEBUG_TOOLCHANGE_MIGRATION_FEATURE)
           SERIAL_ECHOLN("Migration Source Too Cold");

commit a12ac5e1754f0f66babde400a0406b6cdbff983e
Author: swissnorp <67485708+swissnorp@users.noreply.github.com>
Date:   Thu Aug 27 23:05:53 2020 +0200

    Mark axes not-homed with HOME_AFTER_DEACTIVATE (#18907)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index d1017cea80..8557560266 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -167,21 +167,21 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
         parkinghighspeed,         // M951 H
         parkingtraveldistance,    // M951 D
         compensationmultiplier;
 
   inline void magnetic_parking_extruder_tool_change(const uint8_t new_tool) {
 
     const float oldx = current_position.x,
                 grabpos = mpe_settings.parking_xpos[new_tool] + (new_tool ? mpe_settings.grab_distance : -mpe_settings.grab_distance),
                 offsetcompensation = TERN0(HAS_HOTEND_OFFSET, hotend_offset[active_extruder].x * mpe_settings.compensation_factor);
 
-    if (axis_unhomed_error(_BV(X_AXIS))) return;
+    if (homing_needed_error(_BV(X_AXIS))) return;
 
     /**
      * Z Lift and Nozzle Offset shift ar defined in caller method to work equal with any Multi Hotend realization
      *
      * Steps:
      *   1. Move high speed to park position of new extruder
      *   2. Move to couple position of new extruder (this also discouple the old extruder)
      *   3. Move to park position of new extruder
      *   4. Move high speed to approach park position of old extruder
      *   5. Move to park position of old extruder

commit 837dc4727de20856ed9e633d42fce906d8702a15
Author: cbaugher <kb9ydn@gmail.com>
Date:   Sun Aug 9 15:46:47 2020 -0500

    Tool-change Z move followup (#18963)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 5d2dc7d3be..d1017cea80 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -1126,21 +1126,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
             do_blocking_move_to_z(destination.z, planner.settings.max_feedrate_mm_s[Z_AXIS]);
 
           #else
             // Move back to the original (or adjusted) position
             DEBUG_POS("Move back", destination);
 
             #if ENABLED(TOOLCHANGE_PARK)
               if (toolchange_settings.enable_park) do_blocking_move_to_xy_z(destination, destination.z, MMM_TO_MMS(TOOLCHANGE_PARK_XY_FEEDRATE));
             #else
               do_blocking_move_to_xy(destination, planner.settings.max_feedrate_mm_s[X_AXIS]);
-              do_blocking_move_to_z(destination, planner.settings.max_feedrate_mm_s[Z_AXIS]);
+              do_blocking_move_to_z(destination.z, planner.settings.max_feedrate_mm_s[Z_AXIS]);
             #endif
 
           #endif
         }
 
         else DEBUG_ECHOLNPGM("Move back skipped");
 
         #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
           if (should_swap && !too_cold) {
             // Cutting recover

commit 7b2f7a94fa596e4fd24e6f7b318c68514fcf1806
Author: cbaugher <kb9ydn@gmail.com>
Date:   Fri Aug 7 18:06:25 2020 -0500

    Fix Z height after tool change (#18951)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 225f4cbb91..5d2dc7d3be 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -1125,21 +1125,22 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
             #endif
             do_blocking_move_to_z(destination.z, planner.settings.max_feedrate_mm_s[Z_AXIS]);
 
           #else
             // Move back to the original (or adjusted) position
             DEBUG_POS("Move back", destination);
 
             #if ENABLED(TOOLCHANGE_PARK)
               if (toolchange_settings.enable_park) do_blocking_move_to_xy_z(destination, destination.z, MMM_TO_MMS(TOOLCHANGE_PARK_XY_FEEDRATE));
             #else
-              do_blocking_move_to_xy(destination);
+              do_blocking_move_to_xy(destination, planner.settings.max_feedrate_mm_s[X_AXIS]);
+              do_blocking_move_to_z(destination, planner.settings.max_feedrate_mm_s[Z_AXIS]);
             #endif
 
           #endif
         }
 
         else DEBUG_ECHOLNPGM("Move back skipped");
 
         #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
           if (should_swap && !too_cold) {
             // Cutting recover

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index b5c2084950..225f4cbb91 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -9,21 +9,21 @@
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 #include "../inc/MarlinConfigPre.h"
 
 #include "tool_change.h"
 
 #include "probe.h"
 #include "motion.h"
 #include "planner.h"

commit b40440cf3846bca4a0a10bb43d6d60f725a26cfe
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jul 14 17:58:37 2020 -0500

    Tool-change debug option

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 3a283f8357..b5c2084950 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -24,21 +24,23 @@
 
 #include "tool_change.h"
 
 #include "probe.h"
 #include "motion.h"
 #include "planner.h"
 #include "temperature.h"
 
 #include "../MarlinCore.h"
 
-#define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
+//#define DEBUG_TOOL_CHANGE
+
+#define DEBUG_OUT ENABLED(DEBUG_TOOL_CHANGE)
 #include "../core/debug_out.h"
 
 #if EXTRUDERS > 1
   toolchange_settings_t toolchange_settings;  // Initialized by settings.load()
 #endif
 
 #if ENABLED(TOOLCHANGE_MIGRATION_FEATURE)
   migration_settings_t migration = migration_defaults;
   bool enable_first_prime;
 #endif
@@ -183,90 +185,80 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
      *   3. Move to park position of new extruder
      *   4. Move high speed to approach park position of old extruder
      *   5. Move to park position of old extruder
      *   6. Move to starting position
      */
 
     // STEP 1
 
     current_position.x = mpe_settings.parking_xpos[new_tool] + offsetcompensation;
 
-    if (DEBUGGING(LEVELING)) {
-      DEBUG_ECHOPAIR("(1) Move extruder ", int(new_tool));
-      DEBUG_POS(" to new extruder ParkPos", current_position);
-    }
+    DEBUG_ECHOPAIR("(1) Move extruder ", int(new_tool));
+    DEBUG_POS(" to new extruder ParkPos", current_position);
 
     planner.buffer_line(current_position, mpe_settings.fast_feedrate, new_tool);
     planner.synchronize();
 
     // STEP 2
 
     current_position.x = grabpos + offsetcompensation;
 
-    if (DEBUGGING(LEVELING)) {
-      DEBUG_ECHOPAIR("(2) Couple extruder ", int(new_tool));
-      DEBUG_POS(" to new extruder GrabPos", current_position);
-    }
+    DEBUG_ECHOPAIR("(2) Couple extruder ", int(new_tool));
+    DEBUG_POS(" to new extruder GrabPos", current_position);
 
     planner.buffer_line(current_position, mpe_settings.slow_feedrate, new_tool);
     planner.synchronize();
 
     // Delay before moving tool, to allow magnetic coupling
     gcode.dwell(150);
 
     // STEP 3
 
     current_position.x = mpe_settings.parking_xpos[new_tool] + offsetcompensation;
-    if (DEBUGGING(LEVELING)) {
-      DEBUG_ECHOPAIR("(3) Move extruder ", int(new_tool));
-      DEBUG_POS(" back to new extruder ParkPos", current_position);
-    }
+
+    DEBUG_ECHOPAIR("(3) Move extruder ", int(new_tool));
+    DEBUG_POS(" back to new extruder ParkPos", current_position);
 
     planner.buffer_line(current_position, mpe_settings.slow_feedrate, new_tool);
     planner.synchronize();
 
     // STEP 4
 
     current_position.x = mpe_settings.parking_xpos[active_extruder] + (active_extruder == 0 ? MPE_TRAVEL_DISTANCE : -MPE_TRAVEL_DISTANCE) + offsetcompensation;
-    if (DEBUGGING(LEVELING)) {
-      DEBUG_ECHOPAIR("(4) Move extruder ", int(new_tool));
-      DEBUG_POS(" close to old extruder ParkPos", current_position);
-    }
+
+    DEBUG_ECHOPAIR("(4) Move extruder ", int(new_tool));
+    DEBUG_POS(" close to old extruder ParkPos", current_position);
 
     planner.buffer_line(current_position, mpe_settings.fast_feedrate, new_tool);
     planner.synchronize();
 
     // STEP 5
 
     current_position.x = mpe_settings.parking_xpos[active_extruder] + offsetcompensation;
 
-    if (DEBUGGING(LEVELING)) {
-      DEBUG_ECHOPAIR("(5) Park extruder ", int(new_tool));
-      DEBUG_POS(" at old extruder ParkPos", current_position);
-    }
+    DEBUG_ECHOPAIR("(5) Park extruder ", int(new_tool));
+    DEBUG_POS(" at old extruder ParkPos", current_position);
 
     planner.buffer_line(current_position, mpe_settings.slow_feedrate, new_tool);
     planner.synchronize();
 
     // STEP 6
 
     current_position.x = oldx;
 
-    if (DEBUGGING(LEVELING)) {
-      DEBUG_ECHOPAIR("(6) Move extruder ", int(new_tool));
-      DEBUG_POS(" to starting position", current_position);
-    }
+    DEBUG_ECHOPAIR("(6) Move extruder ", int(new_tool));
+    DEBUG_POS(" to starting position", current_position);
 
     planner.buffer_line(current_position, mpe_settings.fast_feedrate, new_tool);
     planner.synchronize();
 
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Autopark done.");
+    DEBUG_ECHOLNPGM("Autopark done.");
   }
 
 #elif ENABLED(PARKING_EXTRUDER)
 
   void pe_solenoid_init() {
     LOOP_LE_N(n, 1)
       #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
         pe_activate_solenoid(n);
       #else
         pe_deactivate_solenoid(n);
@@ -301,75 +293,76 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
        * 1. Move to park position of old extruder
        * 2. Disengage magnetic field, wait for delay
        * 3. Move near new extruder
        * 4. Engage magnetic field for new extruder
        * 5. Move to parking incl. offset of new extruder
        * 6. Lower Z-Axis
        */
 
       // STEP 1
 
-      if (DEBUGGING(LEVELING)) DEBUG_POS("Start PE Tool-Change", current_position);
+      DEBUG_POS("Start PE Tool-Change", current_position);
 
       current_position.x = parkingposx[active_extruder] + x_offset;
-      if (DEBUGGING(LEVELING)) {
-        DEBUG_ECHOLNPAIR("(1) Park extruder ", int(active_extruder));
-        DEBUG_POS("Moving ParkPos", current_position);
-      }
+
+      DEBUG_ECHOLNPAIR("(1) Park extruder ", int(active_extruder));
+      DEBUG_POS("Moving ParkPos", current_position);
+
       fast_line_to_current(X_AXIS);
 
       // STEP 2
 
       planner.synchronize();
-      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(2) Disengage magnet");
+      DEBUG_ECHOLNPGM("(2) Disengage magnet");
       pe_deactivate_solenoid(active_extruder);
 
       // STEP 3
 
       current_position.x += active_extruder ? -10 : 10; // move 10mm away from parked extruder
-      if (DEBUGGING(LEVELING)) {
-        DEBUG_ECHOLNPGM("(3) Move near new extruder");
-        DEBUG_POS("Move away from parked extruder", current_position);
-      }
+
+      DEBUG_ECHOLNPGM("(3) Move near new extruder");
+      DEBUG_POS("Move away from parked extruder", current_position);
+
       fast_line_to_current(X_AXIS);
 
       // STEP 4
 
       planner.synchronize();
-      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(4) Engage magnetic field");
+      DEBUG_ECHOLNPGM("(4) Engage magnetic field");
+
       // Just save power for inverted magnets
       TERN_(PARKING_EXTRUDER_SOLENOIDS_INVERT, pe_activate_solenoid(active_extruder));
       pe_activate_solenoid(new_tool);
 
       // STEP 5
 
       current_position.x = grabpos + (new_tool ? -10 : 10);
       fast_line_to_current(X_AXIS);
 
       current_position.x = grabpos;
-      if (DEBUGGING(LEVELING)) {
-        planner.synchronize();
-        DEBUG_POS("(5) Unpark extruder", current_position);
-      }
+
+      DEBUG_SYNCHRONIZE();
+      DEBUG_POS("(5) Unpark extruder", current_position);
+
       slow_line_to_current(X_AXIS);
 
       // STEP 6
 
       current_position.x = midpos - TERN0(HAS_HOTEND_OFFSET, hotend_offset[new_tool].x);
-      if (DEBUGGING(LEVELING)) {
-        planner.synchronize();
-        DEBUG_POS("(6) Move midway between hotends", current_position);
-      }
+
+      DEBUG_SYNCHRONIZE();
+      DEBUG_POS("(6) Move midway between hotends", current_position);
+
       fast_line_to_current(X_AXIS);
       planner.synchronize(); // Always sync the final move
 
-      if (DEBUGGING(LEVELING)) DEBUG_POS("PE Tool-Change done.", current_position);
+      DEBUG_POS("PE Tool-Change done.", current_position);
     }
     else { // nomove == true
       // Only engage magnetic field for new extruder
       pe_activate_solenoid(new_tool);
       // Just save power for inverted magnets
       TERN_(PARKING_EXTRUDER_SOLENOIDS_INVERT, pe_activate_solenoid(active_extruder));
     }
   }
 
 #endif // PARKING_EXTRUDER
@@ -392,94 +385,94 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
 
     /**
      * 1. Move to switch position of current toolhead
      * 2. Unlock tool and drop it in the dock
      * 3. Move to the new toolhead
      * 4. Grab and lock the new toolhead
      */
 
     // 1. Move to switch position of current toolhead
 
-    if (DEBUGGING(LEVELING)) DEBUG_POS("Start ST Tool-Change", current_position);
+    DEBUG_POS("Start ST Tool-Change", current_position);
 
     current_position.x = placexpos;
-    if (DEBUGGING(LEVELING)) {
-      DEBUG_ECHOLNPAIR("(1) Place old tool ", int(active_extruder));
-      DEBUG_POS("Move X SwitchPos", current_position);
-    }
+
+    DEBUG_ECHOLNPAIR("(1) Place old tool ", int(active_extruder));
+    DEBUG_POS("Move X SwitchPos", current_position);
+
     fast_line_to_current(X_AXIS);
 
     current_position.y = SWITCHING_TOOLHEAD_Y_POS - (SWITCHING_TOOLHEAD_Y_SECURITY);
-    if (DEBUGGING(LEVELING)) {
-      planner.synchronize();
-      DEBUG_POS("Move Y SwitchPos + Security", current_position);
-    }
+
+    DEBUG_SYNCHRONIZE();
+    DEBUG_POS("Move Y SwitchPos + Security", current_position);
+
     fast_line_to_current(Y_AXIS);
 
     // 2. Unlock tool and drop it in the dock
 
     planner.synchronize();
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(2) Unlock and Place Toolhead");
+    DEBUG_ECHOLNPGM("(2) Unlock and Place Toolhead");
     swt_lock(false);
     safe_delay(500);
 
     current_position.y = SWITCHING_TOOLHEAD_Y_POS;
-    if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos", current_position);
+    DEBUG_POS("Move Y SwitchPos", current_position);
     slow_line_to_current(Y_AXIS);
 
     // Wait for move to complete, then another 0.2s
     planner.synchronize();
     safe_delay(200);
 
     current_position.y -= SWITCHING_TOOLHEAD_Y_CLEAR;
-    if (DEBUGGING(LEVELING)) DEBUG_POS("Move back Y clear", current_position);
+    DEBUG_POS("Move back Y clear", current_position);
     fast_line_to_current(Y_AXIS); // move away from docked toolhead
 
     // 3. Move to the new toolhead
 
     current_position.x = grabxpos;
-    if (DEBUGGING(LEVELING)) {
-      planner.synchronize();
-      DEBUG_ECHOLNPGM("(3) Move to new toolhead position");
-      DEBUG_POS("Move to new toolhead X", current_position);
-    }
+
+    DEBUG_SYNCHRONIZE();
+    DEBUG_ECHOLNPGM("(3) Move to new toolhead position");
+    DEBUG_POS("Move to new toolhead X", current_position);
+
     fast_line_to_current(X_AXIS);
 
     current_position.y = SWITCHING_TOOLHEAD_Y_POS - (SWITCHING_TOOLHEAD_Y_SECURITY);
-    if (DEBUGGING(LEVELING)) {
-      planner.synchronize();
-      DEBUG_POS("Move Y SwitchPos + Security", current_position);
-    }
+
+    DEBUG_SYNCHRONIZE();
+    DEBUG_POS("Move Y SwitchPos + Security", current_position);
+
     fast_line_to_current(Y_AXIS);
 
     // 4. Grab and lock the new toolhead
 
     current_position.y = SWITCHING_TOOLHEAD_Y_POS;
-    if (DEBUGGING(LEVELING)) {
-      planner.synchronize();
-      DEBUG_ECHOLNPGM("(4) Grab and lock new toolhead");
-      DEBUG_POS("Move Y SwitchPos", current_position);
-    }
+
+    DEBUG_SYNCHRONIZE();
+    DEBUG_ECHOLNPGM("(4) Grab and lock new toolhead");
+    DEBUG_POS("Move Y SwitchPos", current_position);
+
     slow_line_to_current(Y_AXIS);
 
     // Wait for move to finish, pause 0.2s, move servo, pause 0.5s
     planner.synchronize();
     safe_delay(200);
     swt_lock();
     safe_delay(500);
 
     current_position.y -= SWITCHING_TOOLHEAD_Y_CLEAR;
-    if (DEBUGGING(LEVELING)) DEBUG_POS("Move back Y clear", current_position);
+    DEBUG_POS("Move back Y clear", current_position);
     fast_line_to_current(Y_AXIS); // Move away from docked toolhead
     planner.synchronize();        // Always sync the final move
 
-    if (DEBUGGING(LEVELING)) DEBUG_POS("ST Tool-Change done.", current_position);
+    DEBUG_POS("ST Tool-Change done.", current_position);
   }
 
 #elif ENABLED(MAGNETIC_SWITCHING_TOOLHEAD)
 
   inline void magnetic_switching_toolhead_tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
     if (no_move) return;
 
     constexpr float toolheadposx[] = SWITCHING_TOOLHEAD_X_POS,
                     toolheadclearx[] = SWITCHING_TOOLHEAD_X_SECURITY;
 
@@ -488,125 +481,119 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
                 grabxpos = toolheadposx[new_tool],
                 grabxclear = toolheadclearx[new_tool];
 
     /**
      * 1. Move to switch position of current toolhead
      * 2. Release and place toolhead in the dock
      * 3. Move to the new toolhead
      * 4. Grab the new toolhead and move to security position
      */
 
-    if (DEBUGGING(LEVELING)) DEBUG_POS("Start MST Tool-Change", current_position);
+    DEBUG_POS("Start MST Tool-Change", current_position);
 
     // 1. Move to switch position current toolhead
 
     current_position.y = SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_CLEAR;
-    if (DEBUGGING(LEVELING)) {
-      SERIAL_ECHOLNPAIR("(1) Place old tool ", int(active_extruder));
-      DEBUG_POS("Move Y SwitchPos + Security", current_position);
-    }
+
+    SERIAL_ECHOLNPAIR("(1) Place old tool ", int(active_extruder));
+    DEBUG_POS("Move Y SwitchPos + Security", current_position);
+
     fast_line_to_current(Y_AXIS);
 
     current_position.x = placexclear;
-    if (DEBUGGING(LEVELING)) {
-      planner.synchronize();
-      DEBUG_POS("Move X SwitchPos + Security", current_position);
-    }
+
+    DEBUG_SYNCHRONIZE();
+    DEBUG_POS("Move X SwitchPos + Security", current_position);
+
     fast_line_to_current(X_AXIS);
 
     current_position.y = SWITCHING_TOOLHEAD_Y_POS;
-    if (DEBUGGING(LEVELING)) {
-      planner.synchronize();
-      DEBUG_POS("Move Y SwitchPos", current_position);
-    }
+
+    DEBUG_SYNCHRONIZE();
+    DEBUG_POS("Move Y SwitchPos", current_position);
+
     fast_line_to_current(Y_AXIS);
 
     current_position.x = placexpos;
-    if (DEBUGGING(LEVELING)) {
-      planner.synchronize();
-      DEBUG_POS("Move X SwitchPos", current_position);
-    }
+
+    DEBUG_SYNCHRONIZE();
+    DEBUG_POS("Move X SwitchPos", current_position);
+
     line_to_current_position(planner.settings.max_feedrate_mm_s[X_AXIS] * 0.25f);
 
     // 2. Release and place toolhead in the dock
 
-    if (DEBUGGING(LEVELING)) {
-      planner.synchronize();
-      DEBUG_ECHOLNPGM("(2) Release and Place Toolhead");
-    }
+    DEBUG_SYNCHRONIZE();
+    DEBUG_ECHOLNPGM("(2) Release and Place Toolhead");
 
     current_position.y = SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_RELEASE;
-    if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos + Release", current_position);
+    DEBUG_POS("Move Y SwitchPos + Release", current_position);
     line_to_current_position(planner.settings.max_feedrate_mm_s[Y_AXIS] * 0.1f);
 
     current_position.y = SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_SECURITY;
-    if (DEBUGGING(LEVELING)) {
-      planner.synchronize();
-      DEBUG_POS("Move Y SwitchPos + Security", current_position);
-    }
+
+    DEBUG_SYNCHRONIZE();
+    DEBUG_POS("Move Y SwitchPos + Security", current_position);
+
     line_to_current_position(planner.settings.max_feedrate_mm_s[Y_AXIS]);
 
     // 3. Move to new toolhead position
 
-    if (DEBUGGING(LEVELING)) {
-      planner.synchronize();
-      DEBUG_ECHOLNPGM("(3) Move to new toolhead position");
-    }
+    DEBUG_SYNCHRONIZE();
+    DEBUG_ECHOLNPGM("(3) Move to new toolhead position");
 
     current_position.x = grabxpos;
-    if (DEBUGGING(LEVELING)) DEBUG_POS("Move to new toolhead X", current_position);
+    DEBUG_POS("Move to new toolhead X", current_position);
     fast_line_to_current(X_AXIS);
 
     // 4. Grab the new toolhead and move to security position
 
-    if (DEBUGGING(LEVELING)) {
-      planner.synchronize();
-      DEBUG_ECHOLNPGM("(4) Grab new toolhead, move to security position");
-    }
+    DEBUG_SYNCHRONIZE();
+    DEBUG_ECHOLNPGM("(4) Grab new toolhead, move to security position");
 
     current_position.y = SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_RELEASE;
-    if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos + Release", current_position);
+    DEBUG_POS("Move Y SwitchPos + Release", current_position);
     line_to_current_position(planner.settings.max_feedrate_mm_s[Y_AXIS]);
 
     current_position.y = SWITCHING_TOOLHEAD_Y_POS;
-    if (DEBUGGING(LEVELING)) {
-      planner.synchronize();
-      DEBUG_POS("Move Y SwitchPos", current_position);
-    }
+
+    DEBUG_SYNCHRONIZE();
+    DEBUG_POS("Move Y SwitchPos", current_position);
+
     _line_to_current(Y_AXIS, 0.2f);
 
     #if ENABLED(PRIME_BEFORE_REMOVE) && (SWITCHING_TOOLHEAD_PRIME_MM || SWITCHING_TOOLHEAD_RETRACT_MM)
       #if SWITCHING_TOOLHEAD_PRIME_MM
         current_position.e += SWITCHING_TOOLHEAD_PRIME_MM;
         planner.buffer_line(current_position, MMM_TO_MMS(SWITCHING_TOOLHEAD_PRIME_FEEDRATE), new_tool);
       #endif
       #if SWITCHING_TOOLHEAD_RETRACT_MM
         current_position.e -= SWITCHING_TOOLHEAD_RETRACT_MM;
         planner.buffer_line(current_position, MMM_TO_MMS(SWITCHING_TOOLHEAD_RETRACT_FEEDRATE), new_tool);
       #endif
     #else
       planner.synchronize();
       safe_delay(100); // Give switch time to settle
     #endif
 
     current_position.x = grabxclear;
-    if (DEBUGGING(LEVELING)) DEBUG_POS("Move to new toolhead X + Security", current_position);
+    DEBUG_POS("Move to new toolhead X + Security", current_position);
     _line_to_current(X_AXIS, 0.1f);
     planner.synchronize();
     safe_delay(100); // Give switch time to settle
 
     current_position.y += SWITCHING_TOOLHEAD_Y_CLEAR;
-    if (DEBUGGING(LEVELING)) DEBUG_POS("Move back Y clear", current_position);
+    DEBUG_POS("Move back Y clear", current_position);
     fast_line_to_current(Y_AXIS); // move away from docked toolhead
     planner.synchronize(); // Always sync last tool-change move
 
-    if (DEBUGGING(LEVELING)) DEBUG_POS("MST Tool-Change done.", current_position);
+    DEBUG_POS("MST Tool-Change done.", current_position);
   }
 
 #elif ENABLED(ELECTROMAGNETIC_SWITCHING_TOOLHEAD)
 
   inline void est_activate_solenoid()   { OUT_WRITE(SOL0_PIN, HIGH); }
   inline void est_deactivate_solenoid() { OUT_WRITE(SOL0_PIN, LOW); }
   void est_init() { est_activate_solenoid(); }
 
   inline void em_switching_toolhead_tool_change(const uint8_t new_tool, bool no_move) {
     if (no_move) return;
@@ -621,165 +608,157 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
      * 2. Move to position near active extruder parking
      * 3. Move gently to park position of active extruder
      * 4. Disengage magnetic field, wait for delay
      * 5. Leave extruder and move to position near new extruder parking
      * 6. Move gently to park position of new extruder
      * 7. Engage magnetic field for new extruder parking
      * 8. Unpark extruder
      * 9. Apply Z hotend offset to current position
      */
 
-    if (DEBUGGING(LEVELING)) DEBUG_POS("Start EMST Tool-Change", current_position);
+    DEBUG_POS("Start EMST Tool-Change", current_position);
 
     // 1. Raise Z-Axis to give enough clearance
 
     current_position.z += SWITCHING_TOOLHEAD_Z_HOP;
-    if (DEBUGGING(LEVELING)) DEBUG_POS("(1) Raise Z-Axis ", current_position);
+    DEBUG_POS("(1) Raise Z-Axis ", current_position);
     fast_line_to_current(Z_AXIS);
 
     // 2. Move to position near active extruder parking
 
-    if (DEBUGGING(LEVELING)) {
-      planner.synchronize();
-      SERIAL_ECHOLNPAIR("(2) Move near active extruder parking", active_extruder);
-      DEBUG_POS("Moving ParkPos", current_position);
-    }
+    DEBUG_SYNCHRONIZE();
+    DEBUG_ECHOLNPAIR("(2) Move near active extruder parking", active_extruder);
+    DEBUG_POS("Moving ParkPos", current_position);
+
     current_position.set(hoffs.x + placexpos,
                          hoffs.y + SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_CLEAR);
     fast_line_to_current(X_AXIS);
 
     // 3. Move gently to park position of active extruder
 
-    if (DEBUGGING(LEVELING)) {
-      planner.synchronize();
-      SERIAL_ECHOLNPAIR("(3) Move gently to park position of active extruder", active_extruder);
-      DEBUG_POS("Moving ParkPos", current_position);
-    }
+    DEBUG_SYNCHRONIZE();
+    SERIAL_ECHOLNPAIR("(3) Move gently to park position of active extruder", active_extruder);
+    DEBUG_POS("Moving ParkPos", current_position);
 
     current_position.y -= SWITCHING_TOOLHEAD_Y_CLEAR;
     slow_line_to_current(Y_AXIS);
 
     // 4. Disengage magnetic field, wait for delay
 
     planner.synchronize();
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(4) Disengage magnet");
+    DEBUG_ECHOLNPGM("(4) Disengage magnet");
     est_deactivate_solenoid();
 
     // 5. Leave extruder and move to position near new extruder parking
 
-    if (DEBUGGING(LEVELING)) {
-      DEBUG_ECHOLNPGM("(5) Move near new extruder parking");
-      DEBUG_POS("Moving ParkPos", current_position);
-    }
+    DEBUG_ECHOLNPGM("(5) Move near new extruder parking");
+    DEBUG_POS("Moving ParkPos", current_position);
 
     current_position.y += SWITCHING_TOOLHEAD_Y_CLEAR;
     slow_line_to_current(Y_AXIS);
     current_position.set(hoffs.x + grabxpos,
                          hoffs.y + SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_CLEAR);
     fast_line_to_current(X_AXIS);
 
     // 6. Move gently to park position of new extruder
 
     current_position.y -= SWITCHING_TOOLHEAD_Y_CLEAR;
     if (DEBUGGING(LEVELING)) {
       planner.synchronize();
       DEBUG_ECHOLNPGM("(6) Move near new extruder");
     }
     slow_line_to_current(Y_AXIS);
 
     // 7. Engage magnetic field for new extruder parking
 
-    planner.synchronize();
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(7) Engage magnetic field");
+    DEBUG_SYNCHRONIZE();
+    DEBUG_ECHOLNPGM("(7) Engage magnetic field");
     est_activate_solenoid();
 
     // 8. Unpark extruder
 
     current_position.y += SWITCHING_TOOLHEAD_Y_CLEAR;
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(8) Unpark extruder");
+    DEBUG_ECHOLNPGM("(8) Unpark extruder");
     slow_line_to_current(X_AXIS);
     planner.synchronize(); // Always sync the final move
 
     // 9. Apply Z hotend offset to current position
 
-    if (DEBUGGING(LEVELING)) DEBUG_POS("(9) Applying Z-offset", current_position);
+    DEBUG_POS("(9) Applying Z-offset", current_position);
     current_position.z += hoffs.z - hotend_offset[new_tool].z;
 
-    if (DEBUGGING(LEVELING)) DEBUG_POS("EMST Tool-Change done.", current_position);
+    DEBUG_POS("EMST Tool-Change done.", current_position);
   }
 
 #endif // ELECTROMAGNETIC_SWITCHING_TOOLHEAD
 
 #if EXTRUDERS
   inline void invalid_extruder_error(const uint8_t e) {
     SERIAL_ECHO_START();
     SERIAL_CHAR('T'); SERIAL_ECHO(int(e));
     SERIAL_CHAR(' '); SERIAL_ECHOLNPGM(STR_INVALID_EXTRUDER);
   }
 #endif
 
 #if ENABLED(DUAL_X_CARRIAGE)
 
   inline void dualx_tool_change(const uint8_t new_tool, bool &no_move) {
-    if (DEBUGGING(LEVELING)) {
-      DEBUG_ECHOPGM("Dual X Carriage Mode ");
-      switch (dual_x_carriage_mode) {
-        case DXC_FULL_CONTROL_MODE: DEBUG_ECHOLNPGM("FULL_CONTROL"); break;
-        case DXC_AUTO_PARK_MODE:    DEBUG_ECHOLNPGM("AUTO_PARK");    break;
-        case DXC_DUPLICATION_MODE:  DEBUG_ECHOLNPGM("DUPLICATION");  break;
-        case DXC_MIRRORED_MODE:     DEBUG_ECHOLNPGM("MIRRORED");     break;
-      }
+
+    DEBUG_ECHOPGM("Dual X Carriage Mode ");
+    switch (dual_x_carriage_mode) {
+      case DXC_FULL_CONTROL_MODE: DEBUG_ECHOLNPGM("FULL_CONTROL"); break;
+      case DXC_AUTO_PARK_MODE:    DEBUG_ECHOLNPGM("AUTO_PARK");    break;
+      case DXC_DUPLICATION_MODE:  DEBUG_ECHOLNPGM("DUPLICATION");  break;
+      case DXC_MIRRORED_MODE:     DEBUG_ECHOLNPGM("MIRRORED");     break;
     }
 
     const float xhome = x_home_pos(active_extruder);
     if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE
         && IsRunning() && !no_move
         && (delayed_move_time || current_position.x != xhome)
     ) {
 
-      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("MoveX to ", xhome);
+      DEBUG_ECHOLNPAIR("MoveX to ", xhome);
 
       // Park old head
       current_position.x = xhome;
       line_to_current_position(planner.settings.max_feedrate_mm_s[X_AXIS]);
       planner.synchronize();
     }
 
     // Activate the new extruder ahead of calling set_axis_is_at_home!
     active_extruder = new_tool;
 
     // This function resets the max/min values - the current position may be overwritten below.
     set_axis_is_at_home(X_AXIS);
 
-    if (DEBUGGING(LEVELING)) DEBUG_POS("New Extruder", current_position);
+    DEBUG_POS("New Extruder", current_position);
 
     switch (dual_x_carriage_mode) {
       case DXC_FULL_CONTROL_MODE:
         // New current position is the position of the activated extruder
         current_position.x = inactive_extruder_x_pos;
         // Save the inactive extruder's position (from the old current_position)
         inactive_extruder_x_pos = destination.x;
         break;
       case DXC_AUTO_PARK_MODE:
         // record current raised toolhead position for use by unpark
         raised_parked_position = current_position;
         active_extruder_parked = true;
         delayed_move_time = 0;
         break;
       default:
         break;
     }
 
-    if (DEBUGGING(LEVELING)) {
-      DEBUG_ECHOLNPAIR("Active extruder parked: ", active_extruder_parked ? "yes" : "no");
-      DEBUG_POS("New extruder (parked)", current_position);
-    }
+    DEBUG_ECHOLNPAIR("Active extruder parked: ", active_extruder_parked ? "yes" : "no");
+    DEBUG_POS("New extruder (parked)", current_position);
   }
 
 #endif // DUAL_X_CARRIAGE
 
 /**
  * Prime active tool using TOOLCHANGE_FILAMENT_SWAP settings
  */
 #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
 
 void tool_change_prime() {
@@ -898,21 +877,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
     #if ENABLED(DUAL_X_CARRIAGE)  // Only T0 allowed if the Printer is in DXC_DUPLICATION_MODE or DXC_MIRRORED_MODE
       if (new_tool != 0 && dxc_is_duplicating())
          return invalid_extruder_error(new_tool);
     #endif
 
     if (new_tool >= EXTRUDERS)
       return invalid_extruder_error(new_tool);
 
     if (!no_move && homing_needed()) {
       no_move = true;
-      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("No move (not homed)");
+      DEBUG_ECHOLNPGM("No move (not homed)");
     }
 
     TERN_(HAS_LCD_MENU, if (!no_move) ui.return_to_status());
 
     #if ENABLED(DUAL_X_CARRIAGE)
       const bool idex_full_control = dual_x_carriage_mode == DXC_FULL_CONTROL_MODE;
     #else
       constexpr bool idex_full_control = false;
     #endif
 
@@ -1051,21 +1030,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
           current_position.z = _MIN(newz + toolchange_settings.z_raise, maxz);
           fast_line_to_current(Z_AXIS);
         }
         move_nozzle_servo(new_tool);
       #endif
 
       // Set the new active extruder
       if (DISABLED(DUAL_X_CARRIAGE)) active_extruder = new_tool;
 
       // The newly-selected extruder XYZ is actually at...
-      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Offset Tool XYZ by { ", diff.x, ", ", diff.y, ", ", diff.z, " }");
+      DEBUG_ECHOLNPAIR("Offset Tool XYZ by { ", diff.x, ", ", diff.y, ", ", diff.z, " }");
       current_position += diff;
 
       // Tell the planner the new "current position"
       sync_plan_position();
 
       #if ENABLED(DELTA)
         //LOOP_XYZ(i) update_software_endstops(i); // or modify the constrain function
         const bool safe_to_move = current_position.z < delta_clip_start_height - 1;
       #else
         constexpr bool safe_to_move = true;
@@ -1132,41 +1111,41 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
             planner.synchronize();
           }
         #else
           apply_motion_limits(destination);
         #endif
 
         // Should the nozzle move back to the old position?
         if (can_move_away) {
           #if ENABLED(TOOLCHANGE_NO_RETURN)
             // Just move back down
-            if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Move back Z only");
+            DEBUG_ECHOLNPGM("Move back Z only");
 
             #if ENABLED(TOOLCHANGE_PARK)
               if (toolchange_settings.enable_park)
             #endif
             do_blocking_move_to_z(destination.z, planner.settings.max_feedrate_mm_s[Z_AXIS]);
 
           #else
             // Move back to the original (or adjusted) position
-            if (DEBUGGING(LEVELING)) DEBUG_POS("Move back", destination);
+            DEBUG_POS("Move back", destination);
 
             #if ENABLED(TOOLCHANGE_PARK)
               if (toolchange_settings.enable_park) do_blocking_move_to_xy_z(destination, destination.z, MMM_TO_MMS(TOOLCHANGE_PARK_XY_FEEDRATE));
             #else
               do_blocking_move_to_xy(destination);
             #endif
 
           #endif
         }
 
-        else if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Move back skipped");
+        else DEBUG_ECHOLNPGM("Move back skipped");
 
         #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
           if (should_swap && !too_cold) {
             // Cutting recover
             unscaled_e_move(toolchange_settings.extra_resume + TOOLCHANGE_FS_WIPE_RETRACT, MMM_TO_MMS(toolchange_settings.unretract_speed));
             current_position.e = 0;
             sync_plan_position_e(); // New extruder primed and set to 0
 
             // Restart Fan
             #if HAS_FAN && TOOLCHANGE_FS_FAN >= 0

commit c1dcc56a0b5bc110289ac9c4aeefa8263c5174d4
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sat Jun 27 22:57:01 2020 -0400

    Tool Change Migration fixes and debugging (#18448)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 8aa367555d..3a283f8357 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -1215,47 +1215,69 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
     #endif
 
     SERIAL_ECHO_START();
     SERIAL_ECHOLNPAIR(STR_ACTIVE_EXTRUDER, int(active_extruder));
 
   #endif // EXTRUDERS > 1
 }
 
 #if ENABLED(TOOLCHANGE_MIGRATION_FEATURE)
 
-  void extruder_migration() {
+  bool extruder_migration() {
 
     #if ENABLED(PREVENT_COLD_EXTRUSION)
-      if (thermalManager.targetTooColdToExtrude(active_extruder)) return;
+      if (thermalManager.targetTooColdToExtrude(active_extruder)) {
+        #if ENABLED(DEBUG_TOOLCHANGE_MIGRATION_FEATURE)
+          SERIAL_ECHOLN("Migration Source Too Cold");
+        #endif
+        return false;
+      }
     #endif
 
     // No auto-migration or specified target?
     if (!migration.target && active_extruder >= migration.last) {
+      #if ENABLED(DEBUG_TOOLCHANGE_MIGRATION_FEATURE)
+        SERIAL_ECHO_MSG("No Migration Target");
+        SERIAL_ECHO_MSG("Target: ", migration.target,
+                        " Last: ", migration.last,
+                        " Active: ", active_extruder);
+      #endif
       migration.automode = false;
-      return;
+      return false;
     }
 
     // Migrate to a target or the next extruder
 
     uint8_t migration_extruder = active_extruder;
 
     if (migration.target) {
+      #if ENABLED(DEBUG_TOOLCHANGE_MIGRATION_FEATURE)
+        SERIAL_ECHOLN("Migration using fixed target");
+      #endif
       // Specified target ok?
       const int16_t t = migration.target - 1;
       if (t != active_extruder) migration_extruder = t;
     }
     else if (migration.automode && migration_extruder < migration.last && migration_extruder < EXTRUDERS - 1)
       migration_extruder++;
 
-    if (migration_extruder == active_extruder) return;
+    if (migration_extruder == active_extruder) {
+      #if ENABLED(DEBUG_TOOLCHANGE_MIGRATION_FEATURE)
+        SERIAL_ECHOLN("Migration source matches active");
+      #endif
+      return false;
+    }
 
     // Migration begins
+    #if ENABLED(DEBUG_TOOLCHANGE_MIGRATION_FEATURE)
+      SERIAL_ECHOLN("Beginning migration");
+    #endif
 
     migration.in_progress = true; // Prevent runout script
     planner.synchronize();
 
     // Remember position before migration
     const float resume_current_e = current_position.e;
 
     // Migrate the flow
     planner.set_flow(migration_extruder, planner.flow_percentage[active_extruder]);
 
@@ -1287,13 +1309,17 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
     // If no available extruder
     if (EXTRUDERS < 2 || active_extruder >= EXTRUDERS - 2 || active_extruder == migration.last)
       migration.automode = false;
 
     migration.in_progress = false;
 
     current_position.e = resume_current_e;
 
     planner.synchronize();
     planner.set_e_position_mm(current_position.e); // New extruder primed and ready
+    #if ENABLED(DEBUG_TOOLCHANGE_MIGRATION_FEATURE)
+      SERIAL_ECHOLN("Migration Complete");
+    #endif
+    return true;
   }
 
 #endif // TOOLCHANGE_MIGRATION_FEATURE

commit 955971486b5c53b93b7ac9447dee3379bb6d6aef
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Mon Jun 15 17:26:09 2020 -0400

    Fix toolchange compile error (#18312)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 36830f2c6e..8aa367555d 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -960,24 +960,26 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
         const bool should_swap = can_move_away && toolchange_settings.swap_length,
                    too_cold = TERN0(PREVENT_COLD_EXTRUSION,
                      !DEBUGGING(DRYRUN) && (thermalManager.targetTooColdToExtrude(old_tool) || thermalManager.targetTooColdToExtrude(new_tool))
                    );
         if (should_swap) {
           if (too_cold) {
             SERIAL_ECHO_MSG(STR_ERR_HOTEND_TOO_COLD);
             if (ENABLED(SINGLENOZZLE)) { active_extruder = new_tool; return; }
           }
           else {
-            // If first new tool, toolchange without unloading the old not initialized 'Just prime/init the new'
-            if (first_tool_is_primed)
-              unscaled_e_move(-toolchange_settings.swap_length, MMM_TO_MMS(toolchange_settings.retract_speed));
-            first_tool_is_primed = true; // The first new tool will be primed by toolchanging
+            #if ENABLED(TOOLCHANGE_FS_PRIME_FIRST_USED)
+              // For first new tool, change without unloading the old. 'Just prime/init the new'
+              if (first_tool_is_primed)
+                unscaled_e_move(-toolchange_settings.swap_length, MMM_TO_MMS(toolchange_settings.retract_speed));
+              first_tool_is_primed = true; // The first new tool will be primed by toolchanging
+            #endif
           }
         }
       #endif
 
       TERN_(SWITCHING_NOZZLE_TWO_SERVOS, raise_nozzle(old_tool));
 
       REMEMBER(fr, feedrate_mm_s, XY_PROBE_FEEDRATE_MM_S);
 
       #if HAS_SOFTWARE_ENDSTOPS
         #if HAS_HOTEND_OFFSET

commit 36efe75ad13a8df9f642cde1fe067358d9fa8d25
Author: studiodyne <42887851+studiodyne@users.noreply.github.com>
Date:   Sun May 3 07:32:25 2020 +0200

    Followup for Tool Migration (#17800)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index c0f7909a3c..36830f2c6e 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -783,20 +783,25 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
 #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
 
 void tool_change_prime() {
   if (toolchange_settings.extra_prime > 0
     && TERN(PREVENT_COLD_EXTRUSION, !thermalManager.targetTooColdToExtrude(active_extruder), 1)
   ) {
     destination = current_position; // Remember the old position
 
     const bool ok = TERN1(TOOLCHANGE_PARK, all_axes_homed() && toolchange_settings.enable_park);
 
+    #if HAS_FAN && TOOLCHANGE_FS_FAN >= 0
+      // Store and stop fan. Restored on any exit.
+      REMEMBER(fan, thermalManager.fan_speed[TOOLCHANGE_FS_FAN], 0);
+    #endif
+
     // Z raise
     if (ok) {
       // Do a small lift to avoid the workpiece in the move back (below)
       current_position.z += toolchange_settings.z_raise;
       #if HAS_SOFTWARE_ENDSTOPS
         NOMORE(current_position.z, soft_endstop.max.z);
       #endif
       fast_line_to_current(Z_AXIS);
       planner.synchronize();
     }
@@ -813,25 +818,24 @@ void tool_change_prime() {
 
     // Prime (All distances are added and slowed down to ensure secure priming in all circumstances)
     unscaled_e_move(toolchange_settings.swap_length + toolchange_settings.extra_prime, MMM_TO_MMS(toolchange_settings.prime_speed));
 
     // Cutting retraction
     #if TOOLCHANGE_FS_WIPE_RETRACT
       unscaled_e_move(-(TOOLCHANGE_FS_WIPE_RETRACT), MMM_TO_MMS(toolchange_settings.retract_speed));
     #endif
 
     // Cool down with fan
-    #if TOOLCHANGE_FS_FAN >= 0 && HAS_FAN
-      const int16_t fansp = thermalManager.fan_speed[TOOLCHANGE_FS_FAN];
+    #if HAS_FAN && TOOLCHANGE_FS_FAN >= 0
       thermalManager.fan_speed[TOOLCHANGE_FS_FAN] = toolchange_settings.fan_speed;
       gcode.dwell(toolchange_settings.fan_time * 1000);
-      thermalManager.fan_speed[TOOLCHANGE_FS_FAN] = fansp;
+      thermalManager.fan_speed[TOOLCHANGE_FS_FAN] = 0;
     #endif
 
     // Move back
     #if ENABLED(TOOLCHANGE_PARK)
       if (ok) {
         #if ENABLED(TOOLCHANGE_NO_RETURN)
           do_blocking_move_to_z(destination.z, planner.settings.max_feedrate_mm_s[Z_AXIS]);
         #else
           do_blocking_move_to(destination, MMM_TO_MMS(TOOLCHANGE_PARK_XY_FEEDRATE));
         #endif
@@ -926,20 +930,25 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
       if (new_tool == old_tool && !first_tool_is_primed && enable_first_prime) {
         tool_change_prime();
         first_tool_is_primed = true;
         toolchange_extruder_ready[old_tool] = true; // Primed and initialized
       }
     #endif
 
     if (new_tool != old_tool) {
       destination = current_position;
 
+      #if BOTH(TOOLCHANGE_FILAMENT_SWAP, HAS_FAN) && TOOLCHANGE_FS_FAN >= 0
+        // Store and stop fan. Restored on any exit.
+        REMEMBER(fan, thermalManager.fan_speed[TOOLCHANGE_FS_FAN], 0);
+      #endif
+
       // Z raise before retraction
       #if ENABLED(TOOLCHANGE_ZRAISE_BEFORE_RETRACT) && DISABLED(SWITCHING_NOZZLE)
         if (can_move_away && TERN1(TOOLCHANGE_PARK, toolchange_settings.enable_park)) {
           // Do a small lift to avoid the workpiece in the move back (below)
           current_position.z += toolchange_settings.z_raise;
           #if HAS_SOFTWARE_ENDSTOPS
             NOMORE(current_position.z, soft_endstop.max.z);
           #endif
           fast_line_to_current(Z_AXIS);
           planner.synchronize();
@@ -1097,25 +1106,24 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
 
             // Extra Prime
             unscaled_e_move(toolchange_settings.extra_prime, MMM_TO_MMS(toolchange_settings.prime_speed));
 
             // Cutting retraction
             #if TOOLCHANGE_FS_WIPE_RETRACT
               unscaled_e_move(-(TOOLCHANGE_FS_WIPE_RETRACT), MMM_TO_MMS(toolchange_settings.retract_speed));
             #endif
 
             // Cool down with fan
-            #if TOOLCHANGE_FS_FAN >= 0 && HAS_FAN
-              const int16_t fansp = thermalManager.fan_speed[TOOLCHANGE_FS_FAN];
+            #if HAS_FAN && TOOLCHANGE_FS_FAN >= 0
               thermalManager.fan_speed[TOOLCHANGE_FS_FAN] = toolchange_settings.fan_speed;
               gcode.dwell(toolchange_settings.fan_time * 1000);
-              thermalManager.fan_speed[TOOLCHANGE_FS_FAN] = fansp;
+              thermalManager.fan_speed[TOOLCHANGE_FS_FAN] = 0;
             #endif
           }
         #endif
 
         // Prevent a move outside physical bounds
         #if ENABLED(MAGNETIC_SWITCHING_TOOLHEAD)
           // If the original position is within tool store area, go to X origin at once
           if (destination.y < SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_CLEAR) {
             current_position.x = 0;
             planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], new_tool);
@@ -1150,20 +1158,25 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
         }
 
         else if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Move back skipped");
 
         #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
           if (should_swap && !too_cold) {
             // Cutting recover
             unscaled_e_move(toolchange_settings.extra_resume + TOOLCHANGE_FS_WIPE_RETRACT, MMM_TO_MMS(toolchange_settings.unretract_speed));
             current_position.e = 0;
             sync_plan_position_e(); // New extruder primed and set to 0
+
+            // Restart Fan
+            #if HAS_FAN && TOOLCHANGE_FS_FAN >= 0
+              RESTORE(fan);
+            #endif
           }
         #endif
 
         TERN_(DUAL_X_CARRIAGE, active_extruder_parked = false);
       }
 
       #if ENABLED(SWITCHING_NOZZLE)
         // Move back down. (Including when the new tool is higher.)
         if (!should_move)
           do_blocking_move_to_z(destination.z, planner.settings.max_feedrate_mm_s[Z_AXIS]);
@@ -1250,20 +1263,23 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
     #endif
 
     // Migrate the temperature to the new hotend
     #if HAS_MULTI_HOTEND
       thermalManager.setTargetHotend(thermalManager.temp_hotend[active_extruder].target, migration_extruder);
       TERN_(AUTOTEMP, planner.autotemp_update());
       TERN_(HAS_DISPLAY, thermalManager.set_heating_message(0));
       thermalManager.wait_for_hotend(active_extruder);
     #endif
 
+    // Migrate Linear Advance K factor to the new extruder
+    TERN_(LIN_ADVANCE, planner.extruder_advance_K[active_extruder] = planner.extruder_advance_K[migration_extruder]);
+
     // Perform the tool change
     tool_change(migration_extruder);
 
     // Retract if previously retracted
     #if ENABLED(FWRETRACT)
       if (fwretract.retracted[active_extruder])
         unscaled_e_move(-fwretract.settings.retract_length, fwretract.settings.retract_feedrate_mm_s);
     #endif
 
     // If no available extruder

commit 89b17b54637200838e52ae39a9e4b23f3c2f8d35
Author: studiodyne <42887851+studiodyne@users.noreply.github.com>
Date:   Tue Apr 28 07:21:23 2020 +0200

    Followup fixes for singlenozzle, etc. (#17712)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 9908d37cda..c0f7909a3c 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -40,25 +40,26 @@
 
 #if ENABLED(TOOLCHANGE_MIGRATION_FEATURE)
   migration_settings_t migration = migration_defaults;
   bool enable_first_prime;
 #endif
 
 #if ENABLED(TOOLCHANGE_FS_INIT_BEFORE_SWAP)
   bool toolchange_extruder_ready[EXTRUDERS];
 #endif
 
-#if ENABLED(SINGLENOZZLE)
+#if ENABLED(SINGLENOZZLE_STANDBY_TEMP)
   uint16_t singlenozzle_temp[EXTRUDERS];
-  #if HAS_FAN
-    uint8_t singlenozzle_fan_speed[EXTRUDERS];
-  #endif
+#endif
+
+#if BOTH(HAS_FAN, SINGLENOZZLE_STANDBY_FAN)
+  uint8_t singlenozzle_fan_speed[EXTRUDERS];
 #endif
 
 #if ENABLED(MAGNETIC_PARKING_EXTRUDER) || defined(EVENT_GCODE_AFTER_TOOLCHANGE) || (ENABLED(PARKING_EXTRUDER) && PARKING_EXTRUDER_SOLENOIDS_DELAY > 0)
   #include "../gcode/gcode.h"
 #endif
 
 #if ANY(SWITCHING_EXTRUDER, SWITCHING_NOZZLE, SWITCHING_TOOLHEAD)
   #include "servo.h"
 #endif
 
@@ -815,21 +816,21 @@ void tool_change_prime() {
 
     // Cutting retraction
     #if TOOLCHANGE_FS_WIPE_RETRACT
       unscaled_e_move(-(TOOLCHANGE_FS_WIPE_RETRACT), MMM_TO_MMS(toolchange_settings.retract_speed));
     #endif
 
     // Cool down with fan
     #if TOOLCHANGE_FS_FAN >= 0 && HAS_FAN
       const int16_t fansp = thermalManager.fan_speed[TOOLCHANGE_FS_FAN];
       thermalManager.fan_speed[TOOLCHANGE_FS_FAN] = toolchange_settings.fan_speed;
-      safe_delay(toolchange_settings.fan_time * 1000);
+      gcode.dwell(toolchange_settings.fan_time * 1000);
       thermalManager.fan_speed[TOOLCHANGE_FS_FAN] = fansp;
     #endif
 
     // Move back
     #if ENABLED(TOOLCHANGE_PARK)
       if (ok) {
         #if ENABLED(TOOLCHANGE_NO_RETURN)
           do_blocking_move_to_z(destination.z, planner.settings.max_feedrate_mm_s[Z_AXIS]);
         #else
           do_blocking_move_to(destination, MMM_TO_MMS(TOOLCHANGE_PARK_XY_FEEDRATE));
@@ -927,21 +928,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
         first_tool_is_primed = true;
         toolchange_extruder_ready[old_tool] = true; // Primed and initialized
       }
     #endif
 
     if (new_tool != old_tool) {
       destination = current_position;
 
       // Z raise before retraction
       #if ENABLED(TOOLCHANGE_ZRAISE_BEFORE_RETRACT) && DISABLED(SWITCHING_NOZZLE)
-        if (can_move_away && TERN1(toolchange_settings.enable_park)) {
+        if (can_move_away && TERN1(TOOLCHANGE_PARK, toolchange_settings.enable_park)) {
           // Do a small lift to avoid the workpiece in the move back (below)
           current_position.z += toolchange_settings.z_raise;
           #if HAS_SOFTWARE_ENDSTOPS
             NOMORE(current_position.z, soft_endstop.max.z);
           #endif
           fast_line_to_current(Z_AXIS);
           planner.synchronize();
         }
       #endif
 
@@ -949,22 +950,26 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
       #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
         const bool should_swap = can_move_away && toolchange_settings.swap_length,
                    too_cold = TERN0(PREVENT_COLD_EXTRUSION,
                      !DEBUGGING(DRYRUN) && (thermalManager.targetTooColdToExtrude(old_tool) || thermalManager.targetTooColdToExtrude(new_tool))
                    );
         if (should_swap) {
           if (too_cold) {
             SERIAL_ECHO_MSG(STR_ERR_HOTEND_TOO_COLD);
             if (ENABLED(SINGLENOZZLE)) { active_extruder = new_tool; return; }
           }
-          else
-            unscaled_e_move(-toolchange_settings.swap_length, MMM_TO_MMS(toolchange_settings.retract_speed));
+          else {
+            // If first new tool, toolchange without unloading the old not initialized 'Just prime/init the new'
+            if (first_tool_is_primed)
+              unscaled_e_move(-toolchange_settings.swap_length, MMM_TO_MMS(toolchange_settings.retract_speed));
+            first_tool_is_primed = true; // The first new tool will be primed by toolchanging
+          }
         }
       #endif
 
       TERN_(SWITCHING_NOZZLE_TWO_SERVOS, raise_nozzle(old_tool));
 
       REMEMBER(fr, feedrate_mm_s, XY_PROBE_FEEDRATE_MM_S);
 
       #if HAS_SOFTWARE_ENDSTOPS
         #if HAS_HOTEND_OFFSET
           #define _EXT_ARGS , old_tool, new_tool
@@ -1052,29 +1057,30 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
         //LOOP_XYZ(i) update_software_endstops(i); // or modify the constrain function
         const bool safe_to_move = current_position.z < delta_clip_start_height - 1;
       #else
         constexpr bool safe_to_move = true;
       #endif
 
       // Return to position and lower again
       const bool should_move = safe_to_move && !no_move && IsRunning();
       if (should_move) {
 
-        #if ENABLED(SINGLENOZZLE)
-          #if HAS_FAN
-            singlenozzle_fan_speed[old_tool] = thermalManager.fan_speed[0];
-            thermalManager.fan_speed[0] = singlenozzle_fan_speed[new_tool];
-          #endif
+        #if BOTH(HAS_FAN, SINGLENOZZLE_STANDBY_FAN)
+          singlenozzle_fan_speed[old_tool] = thermalManager.fan_speed[0];
+          thermalManager.fan_speed[0] = singlenozzle_fan_speed[new_tool];
+        #endif
 
+        #if ENABLED(SINGLENOZZLE_STANDBY_TEMP)
           singlenozzle_temp[old_tool] = thermalManager.temp_hotend[0].target;
           if (singlenozzle_temp[new_tool] && singlenozzle_temp[new_tool] != singlenozzle_temp[old_tool]) {
             thermalManager.setTargetHotend(singlenozzle_temp[new_tool], 0);
+            TERN_(AUTOTEMP, planner.autotemp_update());
             TERN_(HAS_DISPLAY, thermalManager.set_heating_message(0));
             (void)thermalManager.wait_for_hotend(0, false);  // Wait for heating or cooling
           }
         #endif
 
         #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
           if (should_swap && !too_cold) {
 
             float fr = toolchange_settings.unretract_speed;
 
@@ -1094,21 +1100,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
 
             // Cutting retraction
             #if TOOLCHANGE_FS_WIPE_RETRACT
               unscaled_e_move(-(TOOLCHANGE_FS_WIPE_RETRACT), MMM_TO_MMS(toolchange_settings.retract_speed));
             #endif
 
             // Cool down with fan
             #if TOOLCHANGE_FS_FAN >= 0 && HAS_FAN
               const int16_t fansp = thermalManager.fan_speed[TOOLCHANGE_FS_FAN];
               thermalManager.fan_speed[TOOLCHANGE_FS_FAN] = toolchange_settings.fan_speed;
-              safe_delay(toolchange_settings.fan_time * 1000);
+              gcode.dwell(toolchange_settings.fan_time * 1000);
               thermalManager.fan_speed[TOOLCHANGE_FS_FAN] = fansp;
             #endif
           }
         #endif
 
         // Prevent a move outside physical bounds
         #if ENABLED(MAGNETIC_SWITCHING_TOOLHEAD)
           // If the original position is within tool store area, go to X origin at once
           if (destination.y < SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_CLEAR) {
             current_position.x = 0;
@@ -1238,24 +1244,23 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
     // Migrate the flow
     planner.set_flow(migration_extruder, planner.flow_percentage[active_extruder]);
 
     // Migrate the retracted state
     #if ENABLED(FWRETRACT)
       fwretract.retracted[migration_extruder] = fwretract.retracted[active_extruder];
     #endif
 
     // Migrate the temperature to the new hotend
     #if HAS_MULTI_HOTEND
-      thermalManager.setTargetHotend(thermalManager.degTargetHotend(active_extruder), migration_extruder);
-      #if HAS_DISPLAY
-        thermalManager.set_heating_message(0);
-      #endif
+      thermalManager.setTargetHotend(thermalManager.temp_hotend[active_extruder].target, migration_extruder);
+      TERN_(AUTOTEMP, planner.autotemp_update());
+      TERN_(HAS_DISPLAY, thermalManager.set_heating_message(0));
       thermalManager.wait_for_hotend(active_extruder);
     #endif
 
     // Perform the tool change
     tool_change(migration_extruder);
 
     // Retract if previously retracted
     #if ENABLED(FWRETRACT)
       if (fwretract.retracted[active_extruder])
         unscaled_e_move(-fwretract.settings.retract_length, fwretract.settings.retract_feedrate_mm_s);

commit c4d57462dc96f7da5c9e46600a9c6c2da41f537e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 27 04:49:31 2020 -0500

    Apply HAS_MULTI_HOTEND

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index c1060c1233..9908d37cda 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -1237,21 +1237,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
 
     // Migrate the flow
     planner.set_flow(migration_extruder, planner.flow_percentage[active_extruder]);
 
     // Migrate the retracted state
     #if ENABLED(FWRETRACT)
       fwretract.retracted[migration_extruder] = fwretract.retracted[active_extruder];
     #endif
 
     // Migrate the temperature to the new hotend
-    #if HOTENDS > 1
+    #if HAS_MULTI_HOTEND
       thermalManager.setTargetHotend(thermalManager.degTargetHotend(active_extruder), migration_extruder);
       #if HAS_DISPLAY
         thermalManager.set_heating_message(0);
       #endif
       thermalManager.wait_for_hotend(active_extruder);
     #endif
 
     // Perform the tool change
     tool_change(migration_extruder);
 

commit 8b3c7dda755ebce5bd57a7ce52891a137ea12b35
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 27 04:41:18 2020 -0500

    Add HAS_FAN and others

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index d7f6ef15cc..c1060c1233 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -42,21 +42,21 @@
   migration_settings_t migration = migration_defaults;
   bool enable_first_prime;
 #endif
 
 #if ENABLED(TOOLCHANGE_FS_INIT_BEFORE_SWAP)
   bool toolchange_extruder_ready[EXTRUDERS];
 #endif
 
 #if ENABLED(SINGLENOZZLE)
   uint16_t singlenozzle_temp[EXTRUDERS];
-  #if FAN_COUNT > 0
+  #if HAS_FAN
     uint8_t singlenozzle_fan_speed[EXTRUDERS];
   #endif
 #endif
 
 #if ENABLED(MAGNETIC_PARKING_EXTRUDER) || defined(EVENT_GCODE_AFTER_TOOLCHANGE) || (ENABLED(PARKING_EXTRUDER) && PARKING_EXTRUDER_SOLENOIDS_DELAY > 0)
   #include "../gcode/gcode.h"
 #endif
 
 #if ANY(SWITCHING_EXTRUDER, SWITCHING_NOZZLE, SWITCHING_TOOLHEAD)
   #include "servo.h"
@@ -812,21 +812,21 @@ void tool_change_prime() {
 
     // Prime (All distances are added and slowed down to ensure secure priming in all circumstances)
     unscaled_e_move(toolchange_settings.swap_length + toolchange_settings.extra_prime, MMM_TO_MMS(toolchange_settings.prime_speed));
 
     // Cutting retraction
     #if TOOLCHANGE_FS_WIPE_RETRACT
       unscaled_e_move(-(TOOLCHANGE_FS_WIPE_RETRACT), MMM_TO_MMS(toolchange_settings.retract_speed));
     #endif
 
     // Cool down with fan
-    #if TOOLCHANGE_FS_FAN >= 0 && FAN_COUNT > 0
+    #if TOOLCHANGE_FS_FAN >= 0 && HAS_FAN
       const int16_t fansp = thermalManager.fan_speed[TOOLCHANGE_FS_FAN];
       thermalManager.fan_speed[TOOLCHANGE_FS_FAN] = toolchange_settings.fan_speed;
       safe_delay(toolchange_settings.fan_time * 1000);
       thermalManager.fan_speed[TOOLCHANGE_FS_FAN] = fansp;
     #endif
 
     // Move back
     #if ENABLED(TOOLCHANGE_PARK)
       if (ok) {
         #if ENABLED(TOOLCHANGE_NO_RETURN)
@@ -1053,21 +1053,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
         const bool safe_to_move = current_position.z < delta_clip_start_height - 1;
       #else
         constexpr bool safe_to_move = true;
       #endif
 
       // Return to position and lower again
       const bool should_move = safe_to_move && !no_move && IsRunning();
       if (should_move) {
 
         #if ENABLED(SINGLENOZZLE)
-          #if FAN_COUNT > 0
+          #if HAS_FAN
             singlenozzle_fan_speed[old_tool] = thermalManager.fan_speed[0];
             thermalManager.fan_speed[0] = singlenozzle_fan_speed[new_tool];
           #endif
 
           singlenozzle_temp[old_tool] = thermalManager.temp_hotend[0].target;
           if (singlenozzle_temp[new_tool] && singlenozzle_temp[new_tool] != singlenozzle_temp[old_tool]) {
             thermalManager.setTargetHotend(singlenozzle_temp[new_tool], 0);
             TERN_(HAS_DISPLAY, thermalManager.set_heating_message(0));
             (void)thermalManager.wait_for_hotend(0, false);  // Wait for heating or cooling
           }
@@ -1091,21 +1091,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
 
             // Extra Prime
             unscaled_e_move(toolchange_settings.extra_prime, MMM_TO_MMS(toolchange_settings.prime_speed));
 
             // Cutting retraction
             #if TOOLCHANGE_FS_WIPE_RETRACT
               unscaled_e_move(-(TOOLCHANGE_FS_WIPE_RETRACT), MMM_TO_MMS(toolchange_settings.retract_speed));
             #endif
 
             // Cool down with fan
-            #if TOOLCHANGE_FS_FAN >= 0 && FAN_COUNT > 0
+            #if TOOLCHANGE_FS_FAN >= 0 && HAS_FAN
               const int16_t fansp = thermalManager.fan_speed[TOOLCHANGE_FS_FAN];
               thermalManager.fan_speed[TOOLCHANGE_FS_FAN] = toolchange_settings.fan_speed;
               safe_delay(toolchange_settings.fan_time * 1000);
               thermalManager.fan_speed[TOOLCHANGE_FS_FAN] = fansp;
             #endif
           }
         #endif
 
         // Prevent a move outside physical bounds
         #if ENABLED(MAGNETIC_SWITCHING_TOOLHEAD)

commit 28518c2352efb71e335990413f93220347410618
Author: studiodyne <42887851+studiodyne@users.noreply.github.com>
Date:   Sat Apr 25 19:20:42 2020 +0200

    Save/Restore leveling on toolchange for singlenozzle too (#17682)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 64c0503c48..d7f6ef15cc 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -907,21 +907,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
 
     #if ENABLED(DUAL_X_CARRIAGE)
       const bool idex_full_control = dual_x_carriage_mode == DXC_FULL_CONTROL_MODE;
     #else
       constexpr bool idex_full_control = false;
     #endif
 
     const uint8_t old_tool = active_extruder;
     const bool can_move_away = !no_move && !idex_full_control;
 
-    #if HAS_LEVELING && DISABLED(SINGLENOZZLE)
+    #if HAS_LEVELING
       // Set current position to the physical position
       TEMPORARY_BED_LEVELING_STATE(false);
     #endif
 
     // First tool priming. To prime again, reboot the machine.
     #if BOTH(TOOLCHANGE_FILAMENT_SWAP, TOOLCHANGE_FS_PRIME_FIRST_USED)
       static bool first_tool_is_primed = false;
       if (new_tool == old_tool && !first_tool_is_primed && enable_first_prime) {
         tool_change_prime();
         first_tool_is_primed = true;

commit 44b71103dfb7ac66847122ca2eda475beb16b4a1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Apr 23 16:19:51 2020 -0500

    Patch tool_change typo

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 210d220e7b..64c0503c48 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -940,21 +940,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
           #if HAS_SOFTWARE_ENDSTOPS
             NOMORE(current_position.z, soft_endstop.max.z);
           #endif
           fast_line_to_current(Z_AXIS);
           planner.synchronize();
         }
       #endif
 
       // Unload / Retract
       #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
-        const bool should_swap = can_move_away && toolchange_settings.swap_length;
+        const bool should_swap = can_move_away && toolchange_settings.swap_length,
                    too_cold = TERN0(PREVENT_COLD_EXTRUSION,
                      !DEBUGGING(DRYRUN) && (thermalManager.targetTooColdToExtrude(old_tool) || thermalManager.targetTooColdToExtrude(new_tool))
                    );
         if (should_swap) {
           if (too_cold) {
             SERIAL_ECHO_MSG(STR_ERR_HOTEND_TOO_COLD);
             if (ENABLED(SINGLENOZZLE)) { active_extruder = new_tool; return; }
           }
           else
             unscaled_e_move(-toolchange_settings.swap_length, MMM_TO_MMS(toolchange_settings.retract_speed));

commit 2f6262c27b11598293839f6d46f3b340ee6a1f4c
Author: studiodyne <42887851+studiodyne@users.noreply.github.com>
Date:   Thu Apr 23 04:03:28 2020 +0200

    Automatic Tool Migration feature (#17248)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 23925d630c..210d220e7b 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -31,20 +31,29 @@
 
 #include "../MarlinCore.h"
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../core/debug_out.h"
 
 #if EXTRUDERS > 1
   toolchange_settings_t toolchange_settings;  // Initialized by settings.load()
 #endif
 
+#if ENABLED(TOOLCHANGE_MIGRATION_FEATURE)
+  migration_settings_t migration = migration_defaults;
+  bool enable_first_prime;
+#endif
+
+#if ENABLED(TOOLCHANGE_FS_INIT_BEFORE_SWAP)
+  bool toolchange_extruder_ready[EXTRUDERS];
+#endif
+
 #if ENABLED(SINGLENOZZLE)
   uint16_t singlenozzle_temp[EXTRUDERS];
   #if FAN_COUNT > 0
     uint8_t singlenozzle_fan_speed[EXTRUDERS];
   #endif
 #endif
 
 #if ENABLED(MAGNETIC_PARKING_EXTRUDER) || defined(EVENT_GCODE_AFTER_TOOLCHANGE) || (ENABLED(PARKING_EXTRUDER) && PARKING_EXTRUDER_SOLENOIDS_DELAY > 0)
   #include "../gcode/gcode.h"
 #endif
@@ -78,20 +87,28 @@
 #endif
 
 #if HAS_LCD_MENU
   #include "../lcd/ultralcd.h"
 #endif
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   #include "../feature/pause.h"
 #endif
 
+#if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
+  #include "../gcode/gcode.h"
+  #if TOOLCHANGE_FS_WIPE_RETRACT <= 0
+    #undef TOOLCHANGE_FS_WIPE_RETRACT
+    #define TOOLCHANGE_FS_WIPE_RETRACT 0
+  #endif
+#endif
+
 #if DO_SWITCH_EXTRUDER
 
   #if EXTRUDERS > 3
     #define _SERVO_NR(E) ((E) < 2 ? SWITCHING_EXTRUDER_SERVO_NR : SWITCHING_EXTRUDER_E23_SERVO_NR)
   #else
     #define _SERVO_NR(E) SWITCHING_EXTRUDER_SERVO_NR
   #endif
 
   void move_extruder_servo(const uint8_t e) {
     planner.synchronize();
@@ -752,20 +769,91 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
     }
 
     if (DEBUGGING(LEVELING)) {
       DEBUG_ECHOLNPAIR("Active extruder parked: ", active_extruder_parked ? "yes" : "no");
       DEBUG_POS("New extruder (parked)", current_position);
     }
   }
 
 #endif // DUAL_X_CARRIAGE
 
+/**
+ * Prime active tool using TOOLCHANGE_FILAMENT_SWAP settings
+ */
+#if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
+
+void tool_change_prime() {
+  if (toolchange_settings.extra_prime > 0
+    && TERN(PREVENT_COLD_EXTRUSION, !thermalManager.targetTooColdToExtrude(active_extruder), 1)
+  ) {
+    destination = current_position; // Remember the old position
+
+    const bool ok = TERN1(TOOLCHANGE_PARK, all_axes_homed() && toolchange_settings.enable_park);
+
+    // Z raise
+    if (ok) {
+      // Do a small lift to avoid the workpiece in the move back (below)
+      current_position.z += toolchange_settings.z_raise;
+      #if HAS_SOFTWARE_ENDSTOPS
+        NOMORE(current_position.z, soft_endstop.max.z);
+      #endif
+      fast_line_to_current(Z_AXIS);
+      planner.synchronize();
+    }
+
+    // Park
+    #if ENABLED(TOOLCHANGE_PARK)
+      if (ok) {
+        TERN(TOOLCHANGE_PARK_Y_ONLY,,current_position.x = toolchange_settings.change_point.x);
+        TERN(TOOLCHANGE_PARK_X_ONLY,,current_position.y = toolchange_settings.change_point.y);
+        planner.buffer_line(current_position, MMM_TO_MMS(TOOLCHANGE_PARK_XY_FEEDRATE), active_extruder);
+        planner.synchronize();
+      }
+    #endif
+
+    // Prime (All distances are added and slowed down to ensure secure priming in all circumstances)
+    unscaled_e_move(toolchange_settings.swap_length + toolchange_settings.extra_prime, MMM_TO_MMS(toolchange_settings.prime_speed));
+
+    // Cutting retraction
+    #if TOOLCHANGE_FS_WIPE_RETRACT
+      unscaled_e_move(-(TOOLCHANGE_FS_WIPE_RETRACT), MMM_TO_MMS(toolchange_settings.retract_speed));
+    #endif
+
+    // Cool down with fan
+    #if TOOLCHANGE_FS_FAN >= 0 && FAN_COUNT > 0
+      const int16_t fansp = thermalManager.fan_speed[TOOLCHANGE_FS_FAN];
+      thermalManager.fan_speed[TOOLCHANGE_FS_FAN] = toolchange_settings.fan_speed;
+      safe_delay(toolchange_settings.fan_time * 1000);
+      thermalManager.fan_speed[TOOLCHANGE_FS_FAN] = fansp;
+    #endif
+
+    // Move back
+    #if ENABLED(TOOLCHANGE_PARK)
+      if (ok) {
+        #if ENABLED(TOOLCHANGE_NO_RETURN)
+          do_blocking_move_to_z(destination.z, planner.settings.max_feedrate_mm_s[Z_AXIS]);
+        #else
+          do_blocking_move_to(destination, MMM_TO_MMS(TOOLCHANGE_PARK_XY_FEEDRATE));
+        #endif
+      }
+    #endif
+
+    // Cutting recover
+    unscaled_e_move(toolchange_settings.extra_resume + TOOLCHANGE_FS_WIPE_RETRACT, MMM_TO_MMS(toolchange_settings.unretract_speed));
+
+    planner.synchronize();
+    current_position.e = destination.e;
+    sync_plan_position_e(); // Resume at the old E position
+  }
+}
+#endif
+
 /**
  * Perform a tool-change, which may result in moving the
  * previous tool out of the way and the new tool into place.
  */
 void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
 
   if (TERN0(MAGNETIC_SWITCHING_TOOLHEAD, new_tool == active_extruder))
     return;
 
   #if ENABLED(MIXING_EXTRUDER)
@@ -819,83 +907,101 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
 
     #if ENABLED(DUAL_X_CARRIAGE)
       const bool idex_full_control = dual_x_carriage_mode == DXC_FULL_CONTROL_MODE;
     #else
       constexpr bool idex_full_control = false;
     #endif
 
     const uint8_t old_tool = active_extruder;
     const bool can_move_away = !no_move && !idex_full_control;
 
-    #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
-      const bool should_swap = can_move_away && toolchange_settings.swap_length;
-      #if ENABLED(PREVENT_COLD_EXTRUSION)
-        const bool too_cold = !DEBUGGING(DRYRUN) && (thermalManager.targetTooColdToExtrude(old_tool) || thermalManager.targetTooColdToExtrude(new_tool));
-      #else
-        constexpr bool too_cold = false;
-      #endif
-      if (should_swap) {
-        if (too_cold) {
-          SERIAL_ECHO_MSG(STR_ERR_HOTEND_TOO_COLD);
-          #if ENABLED(SINGLENOZZLE)
-            active_extruder = new_tool;
-            return;
-          #endif
-        }
-        else {
-          #if ENABLED(ADVANCED_PAUSE_FEATURE)
-            unscaled_e_move(-toolchange_settings.swap_length, MMM_TO_MMS(toolchange_settings.retract_speed));
-          #else
-            current_position.e -= toolchange_settings.swap_length / planner.e_factor[old_tool];
-            planner.buffer_line(current_position, MMM_TO_MMS(toolchange_settings.retract_speed), old_tool);
-            planner.synchronize();
-          #endif
-        }
-      }
-    #endif // TOOLCHANGE_FILAMENT_SWAP
-
     #if HAS_LEVELING && DISABLED(SINGLENOZZLE)
       // Set current position to the physical position
       TEMPORARY_BED_LEVELING_STATE(false);
     #endif
 
+    // First tool priming. To prime again, reboot the machine.
+    #if BOTH(TOOLCHANGE_FILAMENT_SWAP, TOOLCHANGE_FS_PRIME_FIRST_USED)
+      static bool first_tool_is_primed = false;
+      if (new_tool == old_tool && !first_tool_is_primed && enable_first_prime) {
+        tool_change_prime();
+        first_tool_is_primed = true;
+        toolchange_extruder_ready[old_tool] = true; // Primed and initialized
+      }
+    #endif
+
     if (new_tool != old_tool) {
+      destination = current_position;
+
+      // Z raise before retraction
+      #if ENABLED(TOOLCHANGE_ZRAISE_BEFORE_RETRACT) && DISABLED(SWITCHING_NOZZLE)
+        if (can_move_away && TERN1(toolchange_settings.enable_park)) {
+          // Do a small lift to avoid the workpiece in the move back (below)
+          current_position.z += toolchange_settings.z_raise;
+          #if HAS_SOFTWARE_ENDSTOPS
+            NOMORE(current_position.z, soft_endstop.max.z);
+          #endif
+          fast_line_to_current(Z_AXIS);
+          planner.synchronize();
+        }
+      #endif
+
+      // Unload / Retract
+      #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
+        const bool should_swap = can_move_away && toolchange_settings.swap_length;
+                   too_cold = TERN0(PREVENT_COLD_EXTRUSION,
+                     !DEBUGGING(DRYRUN) && (thermalManager.targetTooColdToExtrude(old_tool) || thermalManager.targetTooColdToExtrude(new_tool))
+                   );
+        if (should_swap) {
+          if (too_cold) {
+            SERIAL_ECHO_MSG(STR_ERR_HOTEND_TOO_COLD);
+            if (ENABLED(SINGLENOZZLE)) { active_extruder = new_tool; return; }
+          }
+          else
+            unscaled_e_move(-toolchange_settings.swap_length, MMM_TO_MMS(toolchange_settings.retract_speed));
+        }
+      #endif
 
       TERN_(SWITCHING_NOZZLE_TWO_SERVOS, raise_nozzle(old_tool));
 
       REMEMBER(fr, feedrate_mm_s, XY_PROBE_FEEDRATE_MM_S);
 
       #if HAS_SOFTWARE_ENDSTOPS
         #if HAS_HOTEND_OFFSET
           #define _EXT_ARGS , old_tool, new_tool
         #else
           #define _EXT_ARGS
         #endif
         update_software_endstops(X_AXIS _EXT_ARGS);
         #if DISABLED(DUAL_X_CARRIAGE)
           update_software_endstops(Y_AXIS _EXT_ARGS);
           update_software_endstops(Z_AXIS _EXT_ARGS);
         #endif
       #endif
 
-      destination = current_position;
-
-      #if DISABLED(SWITCHING_NOZZLE)
-        if (can_move_away) {
+      #if DISABLED(TOOLCHANGE_ZRAISE_BEFORE_RETRACT) && DISABLED(SWITCHING_NOZZLE)
+        if (can_move_away && TERN1(TOOLCHANGE_PARK, toolchange_settings.enable_park)) {
           // Do a small lift to avoid the workpiece in the move back (below)
           current_position.z += toolchange_settings.z_raise;
           #if HAS_SOFTWARE_ENDSTOPS
             NOMORE(current_position.z, soft_endstop.max.z);
           #endif
           fast_line_to_current(Z_AXIS);
-          TERN_(TOOLCHANGE_PARK, current_position = toolchange_settings.change_point);
-          planner.buffer_line(current_position, feedrate_mm_s, old_tool);
+        }
+      #endif
+
+      // Toolchange park
+      #if ENABLED(TOOLCHANGE_PARK) && DISABLED(SWITCHING_NOZZLE)
+        if (can_move_away && toolchange_settings.enable_park) {
+          TERN(TOOLCHANGE_PARK_Y_ONLY,,current_position.x = toolchange_settings.change_point.x);
+          TERN(TOOLCHANGE_PARK_X_ONLY,,current_position.y = toolchange_settings.change_point.y);
+          planner.buffer_line(current_position, MMM_TO_MMS(TOOLCHANGE_PARK_XY_FEEDRATE), old_tool);
           planner.synchronize();
         }
       #endif
 
       #if HAS_HOTEND_OFFSET
         xyz_pos_t diff = hotend_offset[new_tool] - hotend_offset[old_tool];
         TERN_(DUAL_X_CARRIAGE, diff.x = 0);
       #else
         constexpr xyz_pos_t diff{0};
       #endif
@@ -925,104 +1031,143 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
           // Check if Z has space to compensate at least z_offset, and if not, just abort now
           const float newz = current_position.z + _MAX(-diff.z, 0.0);
           if (newz > maxz) return;
 
           current_position.z = _MIN(newz + toolchange_settings.z_raise, maxz);
           fast_line_to_current(Z_AXIS);
         }
         move_nozzle_servo(new_tool);
       #endif
 
-      #if DISABLED(DUAL_X_CARRIAGE)
-        active_extruder = new_tool; // Set the new active extruder
-      #endif
+      // Set the new active extruder
+      if (DISABLED(DUAL_X_CARRIAGE)) active_extruder = new_tool;
 
       // The newly-selected extruder XYZ is actually at...
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Offset Tool XYZ by { ", diff.x, ", ", diff.y, ", ", diff.z, " }");
       current_position += diff;
 
       // Tell the planner the new "current position"
       sync_plan_position();
 
       #if ENABLED(DELTA)
         //LOOP_XYZ(i) update_software_endstops(i); // or modify the constrain function
         const bool safe_to_move = current_position.z < delta_clip_start_height - 1;
       #else
         constexpr bool safe_to_move = true;
       #endif
 
       // Return to position and lower again
-      if (safe_to_move && !no_move && IsRunning()) {
+      const bool should_move = safe_to_move && !no_move && IsRunning();
+      if (should_move) {
 
         #if ENABLED(SINGLENOZZLE)
           #if FAN_COUNT > 0
             singlenozzle_fan_speed[old_tool] = thermalManager.fan_speed[0];
             thermalManager.fan_speed[0] = singlenozzle_fan_speed[new_tool];
           #endif
 
           singlenozzle_temp[old_tool] = thermalManager.temp_hotend[0].target;
           if (singlenozzle_temp[new_tool] && singlenozzle_temp[new_tool] != singlenozzle_temp[old_tool]) {
             thermalManager.setTargetHotend(singlenozzle_temp[new_tool], 0);
             TERN_(HAS_DISPLAY, thermalManager.set_heating_message(0));
             (void)thermalManager.wait_for_hotend(0, false);  // Wait for heating or cooling
           }
         #endif
 
         #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
           if (should_swap && !too_cold) {
-            #if ENABLED(ADVANCED_PAUSE_FEATURE)
-              unscaled_e_move(toolchange_settings.swap_length, MMM_TO_MMS(toolchange_settings.prime_speed));
-              unscaled_e_move(toolchange_settings.extra_prime, ADVANCED_PAUSE_PURGE_FEEDRATE);
-            #else
-              current_position.e += toolchange_settings.swap_length / planner.e_factor[new_tool];
-              planner.buffer_line(current_position, MMM_TO_MMS(toolchange_settings.prime_speed), new_tool);
-              current_position.e += toolchange_settings.extra_prime / planner.e_factor[new_tool];
-              planner.buffer_line(current_position, MMM_TO_MMS(toolchange_settings.prime_speed * 0.2f), new_tool);
+
+            float fr = toolchange_settings.unretract_speed;
+
+            #if ENABLED(TOOLCHANGE_FS_INIT_BEFORE_SWAP)
+              if (!toolchange_extruder_ready[new_tool]) {
+                toolchange_extruder_ready[new_tool] = true;
+                fr = toolchange_settings.prime_speed;       // Next move is a prime
+                unscaled_e_move(0, MMM_TO_MMS(fr));         // Init planner with 0 length move
+              }
+            #endif
+
+            // Unretract (or Prime)
+            unscaled_e_move(toolchange_settings.swap_length, MMM_TO_MMS(fr));
+
+            // Extra Prime
+            unscaled_e_move(toolchange_settings.extra_prime, MMM_TO_MMS(toolchange_settings.prime_speed));
+
+            // Cutting retraction
+            #if TOOLCHANGE_FS_WIPE_RETRACT
+              unscaled_e_move(-(TOOLCHANGE_FS_WIPE_RETRACT), MMM_TO_MMS(toolchange_settings.retract_speed));
+            #endif
+
+            // Cool down with fan
+            #if TOOLCHANGE_FS_FAN >= 0 && FAN_COUNT > 0
+              const int16_t fansp = thermalManager.fan_speed[TOOLCHANGE_FS_FAN];
+              thermalManager.fan_speed[TOOLCHANGE_FS_FAN] = toolchange_settings.fan_speed;
+              safe_delay(toolchange_settings.fan_time * 1000);
+              thermalManager.fan_speed[TOOLCHANGE_FS_FAN] = fansp;
             #endif
-            planner.synchronize();
-            planner.set_e_position_mm((destination.e = current_position.e = current_position.e - (TOOLCHANGE_FIL_EXTRA_PRIME)));
           }
         #endif
 
         // Prevent a move outside physical bounds
         #if ENABLED(MAGNETIC_SWITCHING_TOOLHEAD)
           // If the original position is within tool store area, go to X origin at once
           if (destination.y < SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_CLEAR) {
             current_position.x = 0;
             planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], new_tool);
             planner.synchronize();
           }
         #else
           apply_motion_limits(destination);
         #endif
 
         // Should the nozzle move back to the old position?
         if (can_move_away) {
           #if ENABLED(TOOLCHANGE_NO_RETURN)
             // Just move back down
             if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Move back Z only");
+
+            #if ENABLED(TOOLCHANGE_PARK)
+              if (toolchange_settings.enable_park)
+            #endif
             do_blocking_move_to_z(destination.z, planner.settings.max_feedrate_mm_s[Z_AXIS]);
+
           #else
             // Move back to the original (or adjusted) position
             if (DEBUGGING(LEVELING)) DEBUG_POS("Move back", destination);
-            do_blocking_move_to(destination);
+
+            #if ENABLED(TOOLCHANGE_PARK)
+              if (toolchange_settings.enable_park) do_blocking_move_to_xy_z(destination, destination.z, MMM_TO_MMS(TOOLCHANGE_PARK_XY_FEEDRATE));
+            #else
+              do_blocking_move_to_xy(destination);
+            #endif
+
           #endif
         }
+
         else if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Move back skipped");
 
+        #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
+          if (should_swap && !too_cold) {
+            // Cutting recover
+            unscaled_e_move(toolchange_settings.extra_resume + TOOLCHANGE_FS_WIPE_RETRACT, MMM_TO_MMS(toolchange_settings.unretract_speed));
+            current_position.e = 0;
+            sync_plan_position_e(); // New extruder primed and set to 0
+          }
+        #endif
+
         TERN_(DUAL_X_CARRIAGE, active_extruder_parked = false);
       }
+
       #if ENABLED(SWITCHING_NOZZLE)
-        else {
-          // Move back down. (Including when the new tool is higher.)
+        // Move back down. (Including when the new tool is higher.)
+        if (!should_move)
           do_blocking_move_to_z(destination.z, planner.settings.max_feedrate_mm_s[Z_AXIS]);
-        }
       #endif
 
       TERN_(PRUSA_MMU2, mmu2.tool_change(new_tool));
 
       TERN_(SWITCHING_NOZZLE_TWO_SERVOS, lower_nozzle(new_tool));
 
     } // (new_tool != old_tool)
 
     planner.synchronize();
 
@@ -1046,10 +1191,86 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
     #ifdef EVENT_GCODE_AFTER_TOOLCHANGE
       if (!no_move && TERN1(DUAL_X_CARRIAGE, dual_x_carriage_mode == DXC_AUTO_PARK_MODE))
         gcode.process_subcommands_now_P(PSTR(EVENT_GCODE_AFTER_TOOLCHANGE));
     #endif
 
     SERIAL_ECHO_START();
     SERIAL_ECHOLNPAIR(STR_ACTIVE_EXTRUDER, int(active_extruder));
 
   #endif // EXTRUDERS > 1
 }
+
+#if ENABLED(TOOLCHANGE_MIGRATION_FEATURE)
+
+  void extruder_migration() {
+
+    #if ENABLED(PREVENT_COLD_EXTRUSION)
+      if (thermalManager.targetTooColdToExtrude(active_extruder)) return;
+    #endif
+
+    // No auto-migration or specified target?
+    if (!migration.target && active_extruder >= migration.last) {
+      migration.automode = false;
+      return;
+    }
+
+    // Migrate to a target or the next extruder
+
+    uint8_t migration_extruder = active_extruder;
+
+    if (migration.target) {
+      // Specified target ok?
+      const int16_t t = migration.target - 1;
+      if (t != active_extruder) migration_extruder = t;
+    }
+    else if (migration.automode && migration_extruder < migration.last && migration_extruder < EXTRUDERS - 1)
+      migration_extruder++;
+
+    if (migration_extruder == active_extruder) return;
+
+    // Migration begins
+
+    migration.in_progress = true; // Prevent runout script
+    planner.synchronize();
+
+    // Remember position before migration
+    const float resume_current_e = current_position.e;
+
+    // Migrate the flow
+    planner.set_flow(migration_extruder, planner.flow_percentage[active_extruder]);
+
+    // Migrate the retracted state
+    #if ENABLED(FWRETRACT)
+      fwretract.retracted[migration_extruder] = fwretract.retracted[active_extruder];
+    #endif
+
+    // Migrate the temperature to the new hotend
+    #if HOTENDS > 1
+      thermalManager.setTargetHotend(thermalManager.degTargetHotend(active_extruder), migration_extruder);
+      #if HAS_DISPLAY
+        thermalManager.set_heating_message(0);
+      #endif
+      thermalManager.wait_for_hotend(active_extruder);
+    #endif
+
+    // Perform the tool change
+    tool_change(migration_extruder);
+
+    // Retract if previously retracted
+    #if ENABLED(FWRETRACT)
+      if (fwretract.retracted[active_extruder])
+        unscaled_e_move(-fwretract.settings.retract_length, fwretract.settings.retract_feedrate_mm_s);
+    #endif
+
+    // If no available extruder
+    if (EXTRUDERS < 2 || active_extruder >= EXTRUDERS - 2 || active_extruder == migration.last)
+      migration.automode = false;
+
+    migration.in_progress = false;
+
+    current_position.e = resume_current_e;
+
+    planner.synchronize();
+    planner.set_e_position_mm(current_position.e); // New extruder primed and ready
+  }
+
+#endif // TOOLCHANGE_MIGRATION_FEATURE

commit 6d90d1e1f552dca5e21bc61b676b8e8ce731b280
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 22 16:35:03 2020 -0500

    Apply TERN to compact code (#17619)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index b30e72eace..23925d630c 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -145,25 +145,21 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
         parkinggrabdistance,      // M951 I
         parkingslowspeed,         // M951 J
         parkinghighspeed,         // M951 H
         parkingtraveldistance,    // M951 D
         compensationmultiplier;
 
   inline void magnetic_parking_extruder_tool_change(const uint8_t new_tool) {
 
     const float oldx = current_position.x,
                 grabpos = mpe_settings.parking_xpos[new_tool] + (new_tool ? mpe_settings.grab_distance : -mpe_settings.grab_distance),
-                offsetcompensation = (0
-                  #if HAS_HOTEND_OFFSET
-                    + hotend_offset[active_extruder].x * mpe_settings.compensation_factor
-                  #endif
-                );
+                offsetcompensation = TERN0(HAS_HOTEND_OFFSET, hotend_offset[active_extruder].x * mpe_settings.compensation_factor);
 
     if (axis_unhomed_error(_BV(X_AXIS))) return;
 
     /**
      * Z Lift and Nozzle Offset shift ar defined in caller method to work equal with any Multi Hotend realization
      *
      * Steps:
      *   1. Move high speed to park position of new extruder
      *   2. Move to couple position of new extruder (this also discouple the old extruder)
      *   3. Move to park position of new extruder
@@ -315,59 +311,53 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
       if (DEBUGGING(LEVELING)) {
         DEBUG_ECHOLNPGM("(3) Move near new extruder");
         DEBUG_POS("Move away from parked extruder", current_position);
       }
       fast_line_to_current(X_AXIS);
 
       // STEP 4
 
       planner.synchronize();
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(4) Engage magnetic field");
-      #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
-        pe_activate_solenoid(active_extruder); // Just save power for inverted magnets
-      #endif
+      // Just save power for inverted magnets
+      TERN_(PARKING_EXTRUDER_SOLENOIDS_INVERT, pe_activate_solenoid(active_extruder));
       pe_activate_solenoid(new_tool);
 
       // STEP 5
 
       current_position.x = grabpos + (new_tool ? -10 : 10);
       fast_line_to_current(X_AXIS);
 
       current_position.x = grabpos;
       if (DEBUGGING(LEVELING)) {
         planner.synchronize();
         DEBUG_POS("(5) Unpark extruder", current_position);
       }
       slow_line_to_current(X_AXIS);
 
       // STEP 6
 
-      current_position.x = midpos
-        #if HAS_HOTEND_OFFSET
-          - hotend_offset[new_tool].x
-        #endif
-      ;
+      current_position.x = midpos - TERN0(HAS_HOTEND_OFFSET, hotend_offset[new_tool].x);
       if (DEBUGGING(LEVELING)) {
         planner.synchronize();
         DEBUG_POS("(6) Move midway between hotends", current_position);
       }
       fast_line_to_current(X_AXIS);
       planner.synchronize(); // Always sync the final move
 
       if (DEBUGGING(LEVELING)) DEBUG_POS("PE Tool-Change done.", current_position);
     }
     else { // nomove == true
       // Only engage magnetic field for new extruder
       pe_activate_solenoid(new_tool);
-      #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
-        pe_activate_solenoid(active_extruder); // Just save power for inverted magnets
-      #endif
+      // Just save power for inverted magnets
+      TERN_(PARKING_EXTRUDER_SOLENOIDS_INVERT, pe_activate_solenoid(active_extruder));
     }
   }
 
 #endif // PARKING_EXTRUDER
 
 #if ENABLED(SWITCHING_TOOLHEAD)
 
   inline void swt_lock(const bool locked=true) {
     const uint16_t swt_angles[2] = SWITCHING_TOOLHEAD_SERVO_ANGLES;
     MOVE_SERVO(SWITCHING_TOOLHEAD_SERVO_NR, swt_angles[locked ? 0 : 1]);
@@ -768,23 +758,22 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
   }
 
 #endif // DUAL_X_CARRIAGE
 
 /**
  * Perform a tool-change, which may result in moving the
  * previous tool out of the way and the new tool into place.
  */
 void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
 
-  #if ENABLED(MAGNETIC_SWITCHING_TOOLHEAD)
-    if (new_tool == active_extruder) return;
-  #endif
+  if (TERN0(MAGNETIC_SWITCHING_TOOLHEAD, new_tool == active_extruder))
+    return;
 
   #if ENABLED(MIXING_EXTRUDER)
 
     UNUSED(no_move);
 
     if (new_tool >= MIXING_VIRTUAL_TOOLS)
       return invalid_extruder_error(new_tool);
 
     #if MIXING_VIRTUAL_TOOLS > 1
       // T0-Tnnn: Switch virtual tool by changing the index to the mix
@@ -819,23 +808,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
     #endif
 
     if (new_tool >= EXTRUDERS)
       return invalid_extruder_error(new_tool);
 
     if (!no_move && homing_needed()) {
       no_move = true;
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("No move (not homed)");
     }
 
-    #if HAS_LCD_MENU
-      if (!no_move) ui.return_to_status();
-    #endif
+    TERN_(HAS_LCD_MENU, if (!no_move) ui.return_to_status());
 
     #if ENABLED(DUAL_X_CARRIAGE)
       const bool idex_full_control = dual_x_carriage_mode == DXC_FULL_CONTROL_MODE;
     #else
       constexpr bool idex_full_control = false;
     #endif
 
     const uint8_t old_tool = active_extruder;
     const bool can_move_away = !no_move && !idex_full_control;
 
@@ -866,23 +853,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
       }
     #endif // TOOLCHANGE_FILAMENT_SWAP
 
     #if HAS_LEVELING && DISABLED(SINGLENOZZLE)
       // Set current position to the physical position
       TEMPORARY_BED_LEVELING_STATE(false);
     #endif
 
     if (new_tool != old_tool) {
 
-      #if SWITCHING_NOZZLE_TWO_SERVOS
-        raise_nozzle(old_tool);
-      #endif
+      TERN_(SWITCHING_NOZZLE_TWO_SERVOS, raise_nozzle(old_tool));
 
       REMEMBER(fr, feedrate_mm_s, XY_PROBE_FEEDRATE_MM_S);
 
       #if HAS_SOFTWARE_ENDSTOPS
         #if HAS_HOTEND_OFFSET
           #define _EXT_ARGS , old_tool, new_tool
         #else
           #define _EXT_ARGS
         #endif
         update_software_endstops(X_AXIS _EXT_ARGS);
@@ -895,33 +880,29 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
       destination = current_position;
 
       #if DISABLED(SWITCHING_NOZZLE)
         if (can_move_away) {
           // Do a small lift to avoid the workpiece in the move back (below)
           current_position.z += toolchange_settings.z_raise;
           #if HAS_SOFTWARE_ENDSTOPS
             NOMORE(current_position.z, soft_endstop.max.z);
           #endif
           fast_line_to_current(Z_AXIS);
-          #if ENABLED(TOOLCHANGE_PARK)
-            current_position = toolchange_settings.change_point;
-          #endif
+          TERN_(TOOLCHANGE_PARK, current_position = toolchange_settings.change_point);
           planner.buffer_line(current_position, feedrate_mm_s, old_tool);
           planner.synchronize();
         }
       #endif
 
       #if HAS_HOTEND_OFFSET
         xyz_pos_t diff = hotend_offset[new_tool] - hotend_offset[old_tool];
-        #if ENABLED(DUAL_X_CARRIAGE)
-          diff.x = 0;
-        #endif
+        TERN_(DUAL_X_CARRIAGE, diff.x = 0);
       #else
         constexpr xyz_pos_t diff{0};
       #endif
 
       #if ENABLED(DUAL_X_CARRIAGE)
         dualx_tool_change(new_tool, no_move);
       #elif ENABLED(PARKING_EXTRUDER)                                   // Dual Parking extruder
         parking_extruder_tool_change(new_tool, no_move);
       #elif ENABLED(MAGNETIC_PARKING_EXTRUDER)                          // Magnetic Parking extruder
         magnetic_parking_extruder_tool_change(new_tool);
@@ -974,23 +955,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
 
         #if ENABLED(SINGLENOZZLE)
           #if FAN_COUNT > 0
             singlenozzle_fan_speed[old_tool] = thermalManager.fan_speed[0];
             thermalManager.fan_speed[0] = singlenozzle_fan_speed[new_tool];
           #endif
 
           singlenozzle_temp[old_tool] = thermalManager.temp_hotend[0].target;
           if (singlenozzle_temp[new_tool] && singlenozzle_temp[new_tool] != singlenozzle_temp[old_tool]) {
             thermalManager.setTargetHotend(singlenozzle_temp[new_tool], 0);
-            #if HAS_DISPLAY
-              thermalManager.set_heating_message(0);
-            #endif
+            TERN_(HAS_DISPLAY, thermalManager.set_heating_message(0));
             (void)thermalManager.wait_for_hotend(0, false);  // Wait for heating or cooling
           }
         #endif
 
         #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
           if (should_swap && !too_cold) {
             #if ENABLED(ADVANCED_PAUSE_FEATURE)
               unscaled_e_move(toolchange_settings.swap_length, MMM_TO_MMS(toolchange_settings.prime_speed));
               unscaled_e_move(toolchange_settings.extra_prime, ADVANCED_PAUSE_PURGE_FEEDRATE);
             #else
@@ -1023,61 +1002,53 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
             if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Move back Z only");
             do_blocking_move_to_z(destination.z, planner.settings.max_feedrate_mm_s[Z_AXIS]);
           #else
             // Move back to the original (or adjusted) position
             if (DEBUGGING(LEVELING)) DEBUG_POS("Move back", destination);
             do_blocking_move_to(destination);
           #endif
         }
         else if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Move back skipped");
 
-        #if ENABLED(DUAL_X_CARRIAGE)
-          active_extruder_parked = false;
-        #endif
+        TERN_(DUAL_X_CARRIAGE, active_extruder_parked = false);
       }
       #if ENABLED(SWITCHING_NOZZLE)
         else {
           // Move back down. (Including when the new tool is higher.)
           do_blocking_move_to_z(destination.z, planner.settings.max_feedrate_mm_s[Z_AXIS]);
         }
       #endif
 
-      #if ENABLED(PRUSA_MMU2)
-        mmu2.tool_change(new_tool);
-      #endif
+      TERN_(PRUSA_MMU2, mmu2.tool_change(new_tool));
 
-      #if SWITCHING_NOZZLE_TWO_SERVOS
-        lower_nozzle(new_tool);
-      #endif
+      TERN_(SWITCHING_NOZZLE_TWO_SERVOS, lower_nozzle(new_tool));
 
     } // (new_tool != old_tool)
 
     planner.synchronize();
 
     #if ENABLED(EXT_SOLENOID) && DISABLED(PARKING_EXTRUDER)
       disable_all_solenoids();
       enable_solenoid_on_active_extruder();
     #endif
 
     #if ENABLED(MK2_MULTIPLEXER)
       if (new_tool >= E_STEPPERS) return invalid_extruder_error(new_tool);
       select_multiplexed_stepper(new_tool);
     #endif
 
     #if DO_SWITCH_EXTRUDER
       planner.synchronize();
       move_extruder_servo(active_extruder);
     #endif
 
-    #if HAS_FANMUX
-      fanmux_switch(active_extruder);
-    #endif
+    TERN_(HAS_FANMUX, fanmux_switch(active_extruder));
 
     #ifdef EVENT_GCODE_AFTER_TOOLCHANGE
       if (!no_move && TERN1(DUAL_X_CARRIAGE, dual_x_carriage_mode == DXC_AUTO_PARK_MODE))
         gcode.process_subcommands_now_P(PSTR(EVENT_GCODE_AFTER_TOOLCHANGE));
     #endif
 
     SERIAL_ECHO_START();
     SERIAL_ECHOLNPAIR(STR_ACTIVE_EXTRUDER, int(active_extruder));
 
   #endif // EXTRUDERS > 1

commit 6ce0c94d125c62107f65a373bf7fd8e6337e9e4f
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Mon Apr 13 18:23:54 2020 -0400

    Fix bad comparison (#17470)
    
    * Suggested message change
    
    * Fix Bad Comparison
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 658671fb7e..b30e72eace 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -814,21 +814,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
     planner.synchronize();
 
     #if ENABLED(DUAL_X_CARRIAGE)  // Only T0 allowed if the Printer is in DXC_DUPLICATION_MODE or DXC_MIRRORED_MODE
       if (new_tool != 0 && dxc_is_duplicating())
          return invalid_extruder_error(new_tool);
     #endif
 
     if (new_tool >= EXTRUDERS)
       return invalid_extruder_error(new_tool);
 
-    if (!no_move && !homing_needed()) {
+    if (!no_move && homing_needed()) {
       no_move = true;
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("No move (not homed)");
     }
 
     #if HAS_LCD_MENU
       if (!no_move) ui.return_to_status();
     #endif
 
     #if ENABLED(DUAL_X_CARRIAGE)
       const bool idex_full_control = dual_x_carriage_mode == DXC_FULL_CONTROL_MODE;

commit bc01d8d023e1dc95d4cbff50fc22edde5a6ff3f4
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Fri Apr 3 20:17:05 2020 -0400

    Toolchange touchup (#17395)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 2471581c8c..658671fb7e 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -814,21 +814,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
     planner.synchronize();
 
     #if ENABLED(DUAL_X_CARRIAGE)  // Only T0 allowed if the Printer is in DXC_DUPLICATION_MODE or DXC_MIRRORED_MODE
       if (new_tool != 0 && dxc_is_duplicating())
          return invalid_extruder_error(new_tool);
     #endif
 
     if (new_tool >= EXTRUDERS)
       return invalid_extruder_error(new_tool);
 
-    if (!no_move && !all_axes_homed()) {
+    if (!no_move && !homing_needed()) {
       no_move = true;
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("No move (not homed)");
     }
 
     #if HAS_LCD_MENU
       if (!no_move) ui.return_to_status();
     #endif
 
     #if ENABLED(DUAL_X_CARRIAGE)
       const bool idex_full_control = dual_x_carriage_mode == DXC_FULL_CONTROL_MODE;
@@ -1066,19 +1066,19 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
     #if DO_SWITCH_EXTRUDER
       planner.synchronize();
       move_extruder_servo(active_extruder);
     #endif
 
     #if HAS_FANMUX
       fanmux_switch(active_extruder);
     #endif
 
     #ifdef EVENT_GCODE_AFTER_TOOLCHANGE
-      if (!no_move)
+      if (!no_move && TERN1(DUAL_X_CARRIAGE, dual_x_carriage_mode == DXC_AUTO_PARK_MODE))
         gcode.process_subcommands_now_P(PSTR(EVENT_GCODE_AFTER_TOOLCHANGE));
     #endif
 
     SERIAL_ECHO_START();
     SERIAL_ECHOLNPAIR(STR_ACTIVE_EXTRUDER, int(active_extruder));
 
   #endif // EXTRUDERS > 1
 }

commit 765a9f3471b8a6b67c23f79cc6965e2f795f284a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 29 16:26:55 2020 -0500

    do_pause_e_move => unscaled_e_move

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 0d91669973..2471581c8c 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -849,21 +849,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
       if (should_swap) {
         if (too_cold) {
           SERIAL_ECHO_MSG(STR_ERR_HOTEND_TOO_COLD);
           #if ENABLED(SINGLENOZZLE)
             active_extruder = new_tool;
             return;
           #endif
         }
         else {
           #if ENABLED(ADVANCED_PAUSE_FEATURE)
-            do_pause_e_move(-toolchange_settings.swap_length, MMM_TO_MMS(toolchange_settings.retract_speed));
+            unscaled_e_move(-toolchange_settings.swap_length, MMM_TO_MMS(toolchange_settings.retract_speed));
           #else
             current_position.e -= toolchange_settings.swap_length / planner.e_factor[old_tool];
             planner.buffer_line(current_position, MMM_TO_MMS(toolchange_settings.retract_speed), old_tool);
             planner.synchronize();
           #endif
         }
       }
     #endif // TOOLCHANGE_FILAMENT_SWAP
 
     #if HAS_LEVELING && DISABLED(SINGLENOZZLE)
@@ -984,22 +984,22 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
             #if HAS_DISPLAY
               thermalManager.set_heating_message(0);
             #endif
             (void)thermalManager.wait_for_hotend(0, false);  // Wait for heating or cooling
           }
         #endif
 
         #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
           if (should_swap && !too_cold) {
             #if ENABLED(ADVANCED_PAUSE_FEATURE)
-              do_pause_e_move(toolchange_settings.swap_length, MMM_TO_MMS(toolchange_settings.prime_speed));
-              do_pause_e_move(toolchange_settings.extra_prime, ADVANCED_PAUSE_PURGE_FEEDRATE);
+              unscaled_e_move(toolchange_settings.swap_length, MMM_TO_MMS(toolchange_settings.prime_speed));
+              unscaled_e_move(toolchange_settings.extra_prime, ADVANCED_PAUSE_PURGE_FEEDRATE);
             #else
               current_position.e += toolchange_settings.swap_length / planner.e_factor[new_tool];
               planner.buffer_line(current_position, MMM_TO_MMS(toolchange_settings.prime_speed), new_tool);
               current_position.e += toolchange_settings.extra_prime / planner.e_factor[new_tool];
               planner.buffer_line(current_position, MMM_TO_MMS(toolchange_settings.prime_speed * 0.2f), new_tool);
             #endif
             planner.synchronize();
             planner.set_e_position_mm((destination.e = current_position.e = current_position.e - (TOOLCHANGE_FIL_EXTRA_PRIME)));
           }
         #endif

commit 118bd2f8b2a1f81884cb55a8fc00b708a51aa15b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 13 23:18:16 2020 -0500

    Apply loop shorthand macros (#17159)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 3a6e7b20ce..0d91669973 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -244,21 +244,21 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
 
     planner.buffer_line(current_position, mpe_settings.fast_feedrate, new_tool);
     planner.synchronize();
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Autopark done.");
   }
 
 #elif ENABLED(PARKING_EXTRUDER)
 
   void pe_solenoid_init() {
-    for (uint8_t n = 0; n <= 1; ++n)
+    LOOP_LE_N(n, 1)
       #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
         pe_activate_solenoid(n);
       #else
         pe_deactivate_solenoid(n);
       #endif
   }
 
   void pe_set_solenoid(const uint8_t extruder_num, const uint8_t state) {
     switch (extruder_num) {
       case 1: OUT_WRITE(SOL1_PIN, state); break;

commit 6bead0c1b04152f6a291d851f6cd4029fe0fc616
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 13 16:29:29 2020 -0500

    Shorter paths to HAL, ExtUI (#17156)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 2a8fd42198..3a6e7b20ce 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -67,21 +67,21 @@
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if HAS_FANMUX
   #include "../feature/fanmux.h"
 #endif
 
 #if ENABLED(PRUSA_MMU2)
-  #include "../feature/prusa_MMU2/mmu2.h"
+  #include "../feature/mmu2/mmu2.h"
 #endif
 
 #if HAS_LCD_MENU
   #include "../lcd/ultralcd.h"
 #endif
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   #include "../feature/pause.h"
 #endif
 

commit 57f488738bd1cf3830910758e4332c39ce819b46
Author: MangaValk <patrickvalkmanga@hotmail.com>
Date:   Sun Mar 8 22:13:41 2020 +0100

    [ToolChanger] Lock the current tool at power-up (#17093)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 021878c1ea..2a8fd42198 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -361,25 +361,30 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
       #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
         pe_activate_solenoid(active_extruder); // Just save power for inverted magnets
       #endif
     }
   }
 
 #endif // PARKING_EXTRUDER
 
 #if ENABLED(SWITCHING_TOOLHEAD)
 
+  inline void swt_lock(const bool locked=true) {
+    const uint16_t swt_angles[2] = SWITCHING_TOOLHEAD_SERVO_ANGLES;
+    MOVE_SERVO(SWITCHING_TOOLHEAD_SERVO_NR, swt_angles[locked ? 0 : 1]);
+  }
+
+  void swt_init() { swt_lock(); }
+
   inline void switching_toolhead_tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
     if (no_move) return;
 
-    constexpr uint16_t angles[2] = SWITCHING_TOOLHEAD_SERVO_ANGLES;
-
     constexpr float toolheadposx[] = SWITCHING_TOOLHEAD_X_POS;
     const float placexpos = toolheadposx[active_extruder],
                 grabxpos = toolheadposx[new_tool];
 
     /**
      * 1. Move to switch position of current toolhead
      * 2. Unlock tool and drop it in the dock
      * 3. Move to the new toolhead
      * 4. Grab and lock the new toolhead
      */
@@ -399,21 +404,21 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
     if (DEBUGGING(LEVELING)) {
       planner.synchronize();
       DEBUG_POS("Move Y SwitchPos + Security", current_position);
     }
     fast_line_to_current(Y_AXIS);
 
     // 2. Unlock tool and drop it in the dock
 
     planner.synchronize();
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(2) Unlock and Place Toolhead");
-    MOVE_SERVO(SWITCHING_TOOLHEAD_SERVO_NR, angles[1]);
+    swt_lock(false);
     safe_delay(500);
 
     current_position.y = SWITCHING_TOOLHEAD_Y_POS;
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos", current_position);
     slow_line_to_current(Y_AXIS);
 
     // Wait for move to complete, then another 0.2s
     planner.synchronize();
     safe_delay(200);
 
@@ -444,21 +449,21 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
     if (DEBUGGING(LEVELING)) {
       planner.synchronize();
       DEBUG_ECHOLNPGM("(4) Grab and lock new toolhead");
       DEBUG_POS("Move Y SwitchPos", current_position);
     }
     slow_line_to_current(Y_AXIS);
 
     // Wait for move to finish, pause 0.2s, move servo, pause 0.5s
     planner.synchronize();
     safe_delay(200);
-    MOVE_SERVO(SWITCHING_TOOLHEAD_SERVO_NR, angles[0]);
+    swt_lock();
     safe_delay(500);
 
     current_position.y -= SWITCHING_TOOLHEAD_Y_CLEAR;
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move back Y clear", current_position);
     fast_line_to_current(Y_AXIS); // Move away from docked toolhead
     planner.synchronize();        // Always sync the final move
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("ST Tool-Change done.", current_position);
   }
 

commit e78f607ef33044eecde744e77beea87532817c47
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Feb 26 03:02:03 2020 -0600

    Use a STR_ prefix for non-translated strings

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index cf104e7b5a..021878c1ea 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -693,21 +693,21 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("EMST Tool-Change done.", current_position);
   }
 
 #endif // ELECTROMAGNETIC_SWITCHING_TOOLHEAD
 
 #if EXTRUDERS
   inline void invalid_extruder_error(const uint8_t e) {
     SERIAL_ECHO_START();
     SERIAL_CHAR('T'); SERIAL_ECHO(int(e));
-    SERIAL_CHAR(' '); SERIAL_ECHOLNPGM(MSG_INVALID_EXTRUDER);
+    SERIAL_CHAR(' '); SERIAL_ECHOLNPGM(STR_INVALID_EXTRUDER);
   }
 #endif
 
 #if ENABLED(DUAL_X_CARRIAGE)
 
   inline void dualx_tool_change(const uint8_t new_tool, bool &no_move) {
     if (DEBUGGING(LEVELING)) {
       DEBUG_ECHOPGM("Dual X Carriage Mode ");
       switch (dual_x_carriage_mode) {
         case DXC_FULL_CONTROL_MODE: DEBUG_ECHOLNPGM("FULL_CONTROL"); break;
@@ -836,21 +836,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
 
     #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
       const bool should_swap = can_move_away && toolchange_settings.swap_length;
       #if ENABLED(PREVENT_COLD_EXTRUSION)
         const bool too_cold = !DEBUGGING(DRYRUN) && (thermalManager.targetTooColdToExtrude(old_tool) || thermalManager.targetTooColdToExtrude(new_tool));
       #else
         constexpr bool too_cold = false;
       #endif
       if (should_swap) {
         if (too_cold) {
-          SERIAL_ECHO_MSG(MSG_ERR_HOTEND_TOO_COLD);
+          SERIAL_ECHO_MSG(STR_ERR_HOTEND_TOO_COLD);
           #if ENABLED(SINGLENOZZLE)
             active_extruder = new_tool;
             return;
           #endif
         }
         else {
           #if ENABLED(ADVANCED_PAUSE_FEATURE)
             do_pause_e_move(-toolchange_settings.swap_length, MMM_TO_MMS(toolchange_settings.retract_speed));
           #else
             current_position.e -= toolchange_settings.swap_length / planner.e_factor[old_tool];
@@ -1066,14 +1066,14 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
     #if HAS_FANMUX
       fanmux_switch(active_extruder);
     #endif
 
     #ifdef EVENT_GCODE_AFTER_TOOLCHANGE
       if (!no_move)
         gcode.process_subcommands_now_P(PSTR(EVENT_GCODE_AFTER_TOOLCHANGE));
     #endif
 
     SERIAL_ECHO_START();
-    SERIAL_ECHOLNPAIR(MSG_ACTIVE_EXTRUDER, int(active_extruder));
+    SERIAL_ECHOLNPAIR(STR_ACTIVE_EXTRUDER, int(active_extruder));
 
   #endif // EXTRUDERS > 1
 }

commit 4250a9890818372f13da6baab1dd09170191dbb1
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Wed Feb 26 01:12:14 2020 -0500

    Toolchange improvements (#16979)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 28baa4047d..cf104e7b5a 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -38,22 +38,22 @@
   toolchange_settings_t toolchange_settings;  // Initialized by settings.load()
 #endif
 
 #if ENABLED(SINGLENOZZLE)
   uint16_t singlenozzle_temp[EXTRUDERS];
   #if FAN_COUNT > 0
     uint8_t singlenozzle_fan_speed[EXTRUDERS];
   #endif
 #endif
 
-#if ENABLED(MAGNETIC_PARKING_EXTRUDER) || (ENABLED(PARKING_EXTRUDER) && PARKING_EXTRUDER_SOLENOIDS_DELAY > 0)
-  #include "../gcode/gcode.h" // for dwell()
+#if ENABLED(MAGNETIC_PARKING_EXTRUDER) || defined(EVENT_GCODE_AFTER_TOOLCHANGE) || (ENABLED(PARKING_EXTRUDER) && PARKING_EXTRUDER_SOLENOIDS_DELAY > 0)
+  #include "../gcode/gcode.h"
 #endif
 
 #if ANY(SWITCHING_EXTRUDER, SWITCHING_NOZZLE, SWITCHING_TOOLHEAD)
   #include "servo.h"
 #endif
 
 #if ENABLED(EXT_SOLENOID) && DISABLED(PARKING_EXTRUDER)
   #include "../feature/solenoid.h"
 #endif
 
@@ -854,21 +854,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
             do_pause_e_move(-toolchange_settings.swap_length, MMM_TO_MMS(toolchange_settings.retract_speed));
           #else
             current_position.e -= toolchange_settings.swap_length / planner.e_factor[old_tool];
             planner.buffer_line(current_position, MMM_TO_MMS(toolchange_settings.retract_speed), old_tool);
             planner.synchronize();
           #endif
         }
       }
     #endif // TOOLCHANGE_FILAMENT_SWAP
 
-    #if HAS_LEVELING
+    #if HAS_LEVELING && DISABLED(SINGLENOZZLE)
       // Set current position to the physical position
       TEMPORARY_BED_LEVELING_STATE(false);
     #endif
 
     if (new_tool != old_tool) {
 
       #if SWITCHING_NOZZLE_TWO_SERVOS
         raise_nozzle(old_tool);
       #endif
 
@@ -1061,18 +1061,19 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
     #if DO_SWITCH_EXTRUDER
       planner.synchronize();
       move_extruder_servo(active_extruder);
     #endif
 
     #if HAS_FANMUX
       fanmux_switch(active_extruder);
     #endif
 
     #ifdef EVENT_GCODE_AFTER_TOOLCHANGE
-      gcode.process_subcommands_now_P(EVENT_GCODE_AFTER_TOOLCHANGE);
+      if (!no_move)
+        gcode.process_subcommands_now_P(PSTR(EVENT_GCODE_AFTER_TOOLCHANGE));
     #endif
 
     SERIAL_ECHO_START();
     SERIAL_ECHOLNPAIR(MSG_ACTIVE_EXTRUDER, int(active_extruder));
 
   #endif // EXTRUDERS > 1
 }

commit bfad23d3e2e590b257ebe4317d7b14cc2dd3435c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 3 08:00:57 2020 -0600

    (c) 2020

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index b42722b87c..28baa4047d 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit 9bb8176d341e769af5080cc22a45a433d75b8318
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Wed Jan 29 01:06:06 2020 -0500

    Fix Toolchange (!no_move) return to status (#16699)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 324b979570..b42722b87c 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -814,20 +814,24 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
     #endif
 
     if (new_tool >= EXTRUDERS)
       return invalid_extruder_error(new_tool);
 
     if (!no_move && !all_axes_homed()) {
       no_move = true;
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("No move (not homed)");
     }
 
+    #if HAS_LCD_MENU
+      if (!no_move) ui.return_to_status();
+    #endif
+
     #if ENABLED(DUAL_X_CARRIAGE)
       const bool idex_full_control = dual_x_carriage_mode == DXC_FULL_CONTROL_MODE;
     #else
       constexpr bool idex_full_control = false;
     #endif
 
     const uint8_t old_tool = active_extruder;
     const bool can_move_away = !no_move && !idex_full_control;
 
     #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)

commit 131acf304b4d09466e916cbe31ff3cf3f2913804
Author: Jason Smith <jason.inet@gmail.com>
Date:   Mon Jan 27 13:57:22 2020 -0800

    Fix Manual Bed Leveling with multiple extruders (#16688)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 45c5805f4d..324b979570 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -814,24 +814,20 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
     #endif
 
     if (new_tool >= EXTRUDERS)
       return invalid_extruder_error(new_tool);
 
     if (!no_move && !all_axes_homed()) {
       no_move = true;
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("No move (not homed)");
     }
 
-    #if HAS_LCD_MENU
-      ui.return_to_status();
-    #endif
-
     #if ENABLED(DUAL_X_CARRIAGE)
       const bool idex_full_control = dual_x_carriage_mode == DXC_FULL_CONTROL_MODE;
     #else
       constexpr bool idex_full_control = false;
     #endif
 
     const uint8_t old_tool = active_extruder;
     const bool can_move_away = !no_move && !idex_full_control;
 
     #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)

commit 79810b7fcb4149896180d757e2fbb1ec7a8fc217
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue Jan 21 03:51:23 2020 -0500

    G12 defaults per tool. Event G-code for post-toolchange (#16554)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 021da6f3d4..45c5805f4d 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -1060,15 +1060,19 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
 
     #if DO_SWITCH_EXTRUDER
       planner.synchronize();
       move_extruder_servo(active_extruder);
     #endif
 
     #if HAS_FANMUX
       fanmux_switch(active_extruder);
     #endif
 
+    #ifdef EVENT_GCODE_AFTER_TOOLCHANGE
+      gcode.process_subcommands_now_P(EVENT_GCODE_AFTER_TOOLCHANGE);
+    #endif
+
     SERIAL_ECHO_START();
     SERIAL_ECHOLNPAIR(MSG_ACTIVE_EXTRUDER, int(active_extruder));
 
   #endif // EXTRUDERS > 1
 }

commit 0391e5bcc735d25c4618026f2656161c2631e592
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Fri Jan 10 23:12:21 2020 +0100

    Prevent Z misaligment on tool change (#16518)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 92be95eb9f..021da6f3d4 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -922,34 +922,43 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
         magnetic_parking_extruder_tool_change(new_tool);
       #elif ENABLED(SWITCHING_TOOLHEAD)                                 // Switching Toolhead
         switching_toolhead_tool_change(new_tool, no_move);
       #elif ENABLED(MAGNETIC_SWITCHING_TOOLHEAD)                        // Magnetic Switching Toolhead
         magnetic_switching_toolhead_tool_change(new_tool, no_move);
       #elif ENABLED(ELECTROMAGNETIC_SWITCHING_TOOLHEAD)                 // Magnetic Switching ToolChanger
         em_switching_toolhead_tool_change(new_tool, no_move);
       #elif ENABLED(SWITCHING_NOZZLE) && !SWITCHING_NOZZLE_TWO_SERVOS   // Switching Nozzle (single servo)
         // Raise by a configured distance to avoid workpiece, except with
         // SWITCHING_NOZZLE_TWO_SERVOS, as both nozzles will lift instead.
-        current_position.z += _MAX(-diff.z, 0.0) + toolchange_settings.z_raise;
-        #if HAS_SOFTWARE_ENDSTOPS
-          NOMORE(current_position.z, soft_endstop.max.z);
-        #endif
-        if (!no_move) fast_line_to_current(Z_AXIS);
+        if (!no_move) {
+          #if HAS_SOFTWARE_ENDSTOPS
+            const float maxz = _MIN(soft_endstop.max.z, Z_MAX_POS);
+          #else
+            constexpr float maxz = Z_MAX_POS;
+          #endif
+
+          // Check if Z has space to compensate at least z_offset, and if not, just abort now
+          const float newz = current_position.z + _MAX(-diff.z, 0.0);
+          if (newz > maxz) return;
+
+          current_position.z = _MIN(newz + toolchange_settings.z_raise, maxz);
+          fast_line_to_current(Z_AXIS);
+        }
         move_nozzle_servo(new_tool);
       #endif
 
       #if DISABLED(DUAL_X_CARRIAGE)
         active_extruder = new_tool; // Set the new active extruder
       #endif
 
       // The newly-selected extruder XYZ is actually at...
-      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Offset Tool XY by { ", diff.x, ", ", diff.y, ", ", diff.z, " }");
+      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Offset Tool XYZ by { ", diff.x, ", ", diff.y, ", ", diff.z, " }");
       current_position += diff;
 
       // Tell the planner the new "current position"
       sync_plan_position();
 
       #if ENABLED(DELTA)
         //LOOP_XYZ(i) update_software_endstops(i); // or modify the constrain function
         const bool safe_to_move = current_position.z < delta_clip_start_height - 1;
       #else
         constexpr bool safe_to_move = true;

commit d0e1166cce60381fbdad1105d13765806a525d99
Author: Dirk O. Kaar <19971886+dok-net@users.noreply.github.com>
Date:   Fri Jan 3 02:01:38 2020 +0100

    Fix Visual Micro "Arduino IDE for Visual Studio" support (#16418)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index b392e751d5..92be95eb9f 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -22,21 +22,21 @@
 
 #include "../inc/MarlinConfigPre.h"
 
 #include "tool_change.h"
 
 #include "probe.h"
 #include "motion.h"
 #include "planner.h"
 #include "temperature.h"
 
-#include "../Marlin.h"
+#include "../MarlinCore.h"
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../core/debug_out.h"
 
 #if EXTRUDERS > 1
   toolchange_settings_t toolchange_settings;  // Initialized by settings.load()
 #endif
 
 #if ENABLED(SINGLENOZZLE)
   uint16_t singlenozzle_temp[EXTRUDERS];

commit 46763efb75ee92e0979adfd3988607c0a32eaf25
Author: Jason Smith <jason.inet@gmail.com>
Date:   Wed Oct 9 17:48:00 2019 -0700

    Fix tool-change move with hotend offset (#15491)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 0af205695b..b392e751d5 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -899,21 +899,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
           fast_line_to_current(Z_AXIS);
           #if ENABLED(TOOLCHANGE_PARK)
             current_position = toolchange_settings.change_point;
           #endif
           planner.buffer_line(current_position, feedrate_mm_s, old_tool);
           planner.synchronize();
         }
       #endif
 
       #if HAS_HOTEND_OFFSET
-        xyz_pos_t diff = hotend_offset[new_tool];
+        xyz_pos_t diff = hotend_offset[new_tool] - hotend_offset[old_tool];
         #if ENABLED(DUAL_X_CARRIAGE)
           diff.x = 0;
         #endif
       #else
         constexpr xyz_pos_t diff{0};
       #endif
 
       #if ENABLED(DUAL_X_CARRIAGE)
         dualx_tool_change(new_tool, no_move);
       #elif ENABLED(PARKING_EXTRUDER)                                   // Dual Parking extruder

commit e6055dce76d19b3851138e71bed28f6b146e68b2
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Oct 8 22:07:56 2019 -0500

    Followup to position refactor

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index cd6d21bae7..0af205695b 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -922,21 +922,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
         magnetic_parking_extruder_tool_change(new_tool);
       #elif ENABLED(SWITCHING_TOOLHEAD)                                 // Switching Toolhead
         switching_toolhead_tool_change(new_tool, no_move);
       #elif ENABLED(MAGNETIC_SWITCHING_TOOLHEAD)                        // Magnetic Switching Toolhead
         magnetic_switching_toolhead_tool_change(new_tool, no_move);
       #elif ENABLED(ELECTROMAGNETIC_SWITCHING_TOOLHEAD)                 // Magnetic Switching ToolChanger
         em_switching_toolhead_tool_change(new_tool, no_move);
       #elif ENABLED(SWITCHING_NOZZLE) && !SWITCHING_NOZZLE_TWO_SERVOS   // Switching Nozzle (single servo)
         // Raise by a configured distance to avoid workpiece, except with
         // SWITCHING_NOZZLE_TWO_SERVOS, as both nozzles will lift instead.
-        current_position.z += _MAX(-zdiff, 0.0) + toolchange_settings.z_raise;
+        current_position.z += _MAX(-diff.z, 0.0) + toolchange_settings.z_raise;
         #if HAS_SOFTWARE_ENDSTOPS
           NOMORE(current_position.z, soft_endstop.max.z);
         #endif
         if (!no_move) fast_line_to_current(Z_AXIS);
         move_nozzle_servo(new_tool);
       #endif
 
       #if DISABLED(DUAL_X_CARRIAGE)
         active_extruder = new_tool; // Set the new active extruder
       #endif

commit 50e4545255605eb506c20eb107270038b0fe7bdb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 29 04:25:39 2019 -0500

    Add custom types for position (#15204)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 6178a7ce5d..cd6d21bae7 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -126,123 +126,123 @@
     void move_nozzle_servo(const uint8_t angle_index) {
       planner.synchronize();
       MOVE_SERVO(SWITCHING_NOZZLE_SERVO_NR, servo_angles[SWITCHING_NOZZLE_SERVO_NR][angle_index]);
       safe_delay(500);
     }
 
   #endif
 
 #endif // SWITCHING_NOZZLE
 
-inline void _line_to_current(const AxisEnum fr_axis, const float fscale=1.0f) {
-  planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[fr_axis] * fscale, active_extruder);
+inline void _line_to_current(const AxisEnum fr_axis, const float fscale=1) {
+  line_to_current_position(planner.settings.max_feedrate_mm_s[fr_axis] * fscale);
 }
 inline void slow_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.5f); }
 inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis); }
 
 #if ENABLED(MAGNETIC_PARKING_EXTRUDER)
 
   float parkingposx[2],           // M951 R L
         parkinggrabdistance,      // M951 I
         parkingslowspeed,         // M951 J
         parkinghighspeed,         // M951 H
         parkingtraveldistance,    // M951 D
         compensationmultiplier;
 
   inline void magnetic_parking_extruder_tool_change(const uint8_t new_tool) {
 
-    const float oldx = current_position[X_AXIS],
+    const float oldx = current_position.x,
                 grabpos = mpe_settings.parking_xpos[new_tool] + (new_tool ? mpe_settings.grab_distance : -mpe_settings.grab_distance),
                 offsetcompensation = (0
                   #if HAS_HOTEND_OFFSET
-                    + hotend_offset[X_AXIS][active_extruder] * mpe_settings.compensation_factor
+                    + hotend_offset[active_extruder].x * mpe_settings.compensation_factor
                   #endif
                 );
 
     if (axis_unhomed_error(_BV(X_AXIS))) return;
 
     /**
      * Z Lift and Nozzle Offset shift ar defined in caller method to work equal with any Multi Hotend realization
      *
      * Steps:
      *   1. Move high speed to park position of new extruder
      *   2. Move to couple position of new extruder (this also discouple the old extruder)
      *   3. Move to park position of new extruder
      *   4. Move high speed to approach park position of old extruder
      *   5. Move to park position of old extruder
      *   6. Move to starting position
      */
 
     // STEP 1
 
-    current_position[X_AXIS] = mpe_settings.parking_xpos[new_tool] + offsetcompensation;
+    current_position.x = mpe_settings.parking_xpos[new_tool] + offsetcompensation;
 
     if (DEBUGGING(LEVELING)) {
       DEBUG_ECHOPAIR("(1) Move extruder ", int(new_tool));
       DEBUG_POS(" to new extruder ParkPos", current_position);
     }
 
     planner.buffer_line(current_position, mpe_settings.fast_feedrate, new_tool);
     planner.synchronize();
 
     // STEP 2
 
-    current_position[X_AXIS] = grabpos + offsetcompensation;
+    current_position.x = grabpos + offsetcompensation;
 
     if (DEBUGGING(LEVELING)) {
       DEBUG_ECHOPAIR("(2) Couple extruder ", int(new_tool));
       DEBUG_POS(" to new extruder GrabPos", current_position);
     }
 
     planner.buffer_line(current_position, mpe_settings.slow_feedrate, new_tool);
     planner.synchronize();
 
     // Delay before moving tool, to allow magnetic coupling
     gcode.dwell(150);
 
     // STEP 3
 
-    current_position[X_AXIS] = mpe_settings.parking_xpos[new_tool] + offsetcompensation;
+    current_position.x = mpe_settings.parking_xpos[new_tool] + offsetcompensation;
     if (DEBUGGING(LEVELING)) {
       DEBUG_ECHOPAIR("(3) Move extruder ", int(new_tool));
       DEBUG_POS(" back to new extruder ParkPos", current_position);
     }
 
     planner.buffer_line(current_position, mpe_settings.slow_feedrate, new_tool);
     planner.synchronize();
 
     // STEP 4
 
-    current_position[X_AXIS] = mpe_settings.parking_xpos[active_extruder] + (active_extruder == 0 ? MPE_TRAVEL_DISTANCE : -MPE_TRAVEL_DISTANCE) + offsetcompensation;
+    current_position.x = mpe_settings.parking_xpos[active_extruder] + (active_extruder == 0 ? MPE_TRAVEL_DISTANCE : -MPE_TRAVEL_DISTANCE) + offsetcompensation;
     if (DEBUGGING(LEVELING)) {
       DEBUG_ECHOPAIR("(4) Move extruder ", int(new_tool));
       DEBUG_POS(" close to old extruder ParkPos", current_position);
     }
 
     planner.buffer_line(current_position, mpe_settings.fast_feedrate, new_tool);
     planner.synchronize();
 
     // STEP 5
 
-    current_position[X_AXIS] = mpe_settings.parking_xpos[active_extruder] + offsetcompensation;
+    current_position.x = mpe_settings.parking_xpos[active_extruder] + offsetcompensation;
 
     if (DEBUGGING(LEVELING)) {
       DEBUG_ECHOPAIR("(5) Park extruder ", int(new_tool));
       DEBUG_POS(" at old extruder ParkPos", current_position);
     }
 
     planner.buffer_line(current_position, mpe_settings.slow_feedrate, new_tool);
     planner.synchronize();
 
     // STEP 6
 
-    current_position[X_AXIS] = oldx;
+    current_position.x = oldx;
 
     if (DEBUGGING(LEVELING)) {
       DEBUG_ECHOPAIR("(6) Move extruder ", int(new_tool));
       DEBUG_POS(" to starting position", current_position);
     }
 
     planner.buffer_line(current_position, mpe_settings.fast_feedrate, new_tool);
     planner.synchronize();
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Autopark done.");
@@ -268,89 +268,89 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
       gcode.dwell(PARKING_EXTRUDER_SOLENOIDS_DELAY);
     #endif
   }
 
   inline void parking_extruder_tool_change(const uint8_t new_tool, bool no_move) {
     if (!no_move) {
 
       constexpr float parkingposx[] = PARKING_EXTRUDER_PARKING_X;
 
       #if HAS_HOTEND_OFFSET
-        const float x_offset = hotend_offset[X_AXIS][active_extruder];
+        const float x_offset = hotend_offset[active_extruder].x;
       #else
         constexpr float x_offset = 0;
       #endif
 
-      const float midpos = (parkingposx[0] + parkingposx[1]) * 0.5 + x_offset,
+      const float midpos = (parkingposx[0] + parkingposx[1]) * 0.5f + x_offset,
                   grabpos = parkingposx[new_tool] + (new_tool ? PARKING_EXTRUDER_GRAB_DISTANCE : -(PARKING_EXTRUDER_GRAB_DISTANCE)) + x_offset;
 
       /**
        * 1. Move to park position of old extruder
        * 2. Disengage magnetic field, wait for delay
        * 3. Move near new extruder
        * 4. Engage magnetic field for new extruder
        * 5. Move to parking incl. offset of new extruder
        * 6. Lower Z-Axis
        */
 
       // STEP 1
 
       if (DEBUGGING(LEVELING)) DEBUG_POS("Start PE Tool-Change", current_position);
 
-      current_position[X_AXIS] = parkingposx[active_extruder] + x_offset;
+      current_position.x = parkingposx[active_extruder] + x_offset;
       if (DEBUGGING(LEVELING)) {
         DEBUG_ECHOLNPAIR("(1) Park extruder ", int(active_extruder));
         DEBUG_POS("Moving ParkPos", current_position);
       }
       fast_line_to_current(X_AXIS);
 
       // STEP 2
 
       planner.synchronize();
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(2) Disengage magnet");
       pe_deactivate_solenoid(active_extruder);
 
       // STEP 3
 
-      current_position[X_AXIS] += active_extruder ? -10 : 10; // move 10mm away from parked extruder
+      current_position.x += active_extruder ? -10 : 10; // move 10mm away from parked extruder
       if (DEBUGGING(LEVELING)) {
         DEBUG_ECHOLNPGM("(3) Move near new extruder");
         DEBUG_POS("Move away from parked extruder", current_position);
       }
       fast_line_to_current(X_AXIS);
 
       // STEP 4
 
       planner.synchronize();
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(4) Engage magnetic field");
       #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
         pe_activate_solenoid(active_extruder); // Just save power for inverted magnets
       #endif
       pe_activate_solenoid(new_tool);
 
       // STEP 5
 
-      current_position[X_AXIS] = grabpos + (new_tool ? -10 : 10);
+      current_position.x = grabpos + (new_tool ? -10 : 10);
       fast_line_to_current(X_AXIS);
 
-      current_position[X_AXIS] = grabpos;
+      current_position.x = grabpos;
       if (DEBUGGING(LEVELING)) {
         planner.synchronize();
         DEBUG_POS("(5) Unpark extruder", current_position);
       }
       slow_line_to_current(X_AXIS);
 
       // STEP 6
 
-      current_position[X_AXIS] = midpos
+      current_position.x = midpos
         #if HAS_HOTEND_OFFSET
-          - hotend_offset[X_AXIS][new_tool]
+          - hotend_offset[new_tool].x
         #endif
       ;
       if (DEBUGGING(LEVELING)) {
         planner.synchronize();
         DEBUG_POS("(6) Move midway between hotends", current_position);
       }
       fast_line_to_current(X_AXIS);
       planner.synchronize(); // Always sync the final move
 
       if (DEBUGGING(LEVELING)) DEBUG_POS("PE Tool-Change done.", current_position);
@@ -381,87 +381,87 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
      * 1. Move to switch position of current toolhead
      * 2. Unlock tool and drop it in the dock
      * 3. Move to the new toolhead
      * 4. Grab and lock the new toolhead
      */
 
     // 1. Move to switch position of current toolhead
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("Start ST Tool-Change", current_position);
 
-    current_position[X_AXIS] = placexpos;
+    current_position.x = placexpos;
     if (DEBUGGING(LEVELING)) {
       DEBUG_ECHOLNPAIR("(1) Place old tool ", int(active_extruder));
       DEBUG_POS("Move X SwitchPos", current_position);
     }
     fast_line_to_current(X_AXIS);
 
-    current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS - (SWITCHING_TOOLHEAD_Y_SECURITY);
+    current_position.y = SWITCHING_TOOLHEAD_Y_POS - (SWITCHING_TOOLHEAD_Y_SECURITY);
     if (DEBUGGING(LEVELING)) {
       planner.synchronize();
       DEBUG_POS("Move Y SwitchPos + Security", current_position);
     }
     fast_line_to_current(Y_AXIS);
 
     // 2. Unlock tool and drop it in the dock
 
     planner.synchronize();
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(2) Unlock and Place Toolhead");
     MOVE_SERVO(SWITCHING_TOOLHEAD_SERVO_NR, angles[1]);
     safe_delay(500);
 
-    current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS;
+    current_position.y = SWITCHING_TOOLHEAD_Y_POS;
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos", current_position);
     slow_line_to_current(Y_AXIS);
 
     // Wait for move to complete, then another 0.2s
     planner.synchronize();
     safe_delay(200);
 
-    current_position[Y_AXIS] -= SWITCHING_TOOLHEAD_Y_CLEAR;
+    current_position.y -= SWITCHING_TOOLHEAD_Y_CLEAR;
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move back Y clear", current_position);
     fast_line_to_current(Y_AXIS); // move away from docked toolhead
 
     // 3. Move to the new toolhead
 
-    current_position[X_AXIS] = grabxpos;
+    current_position.x = grabxpos;
     if (DEBUGGING(LEVELING)) {
       planner.synchronize();
       DEBUG_ECHOLNPGM("(3) Move to new toolhead position");
       DEBUG_POS("Move to new toolhead X", current_position);
     }
     fast_line_to_current(X_AXIS);
 
-    current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS - (SWITCHING_TOOLHEAD_Y_SECURITY);
+    current_position.y = SWITCHING_TOOLHEAD_Y_POS - (SWITCHING_TOOLHEAD_Y_SECURITY);
     if (DEBUGGING(LEVELING)) {
       planner.synchronize();
       DEBUG_POS("Move Y SwitchPos + Security", current_position);
     }
     fast_line_to_current(Y_AXIS);
 
     // 4. Grab and lock the new toolhead
 
-    current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS;
+    current_position.y = SWITCHING_TOOLHEAD_Y_POS;
     if (DEBUGGING(LEVELING)) {
       planner.synchronize();
       DEBUG_ECHOLNPGM("(4) Grab and lock new toolhead");
       DEBUG_POS("Move Y SwitchPos", current_position);
     }
     slow_line_to_current(Y_AXIS);
 
     // Wait for move to finish, pause 0.2s, move servo, pause 0.5s
     planner.synchronize();
     safe_delay(200);
     MOVE_SERVO(SWITCHING_TOOLHEAD_SERVO_NR, angles[0]);
     safe_delay(500);
 
-    current_position[Y_AXIS] -= SWITCHING_TOOLHEAD_Y_CLEAR;
+    current_position.y -= SWITCHING_TOOLHEAD_Y_CLEAR;
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move back Y clear", current_position);
     fast_line_to_current(Y_AXIS); // Move away from docked toolhead
     planner.synchronize();        // Always sync the final move
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("ST Tool-Change done.", current_position);
   }
 
 #elif ENABLED(MAGNETIC_SWITCHING_TOOLHEAD)
 
   inline void magnetic_switching_toolhead_tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
@@ -479,224 +479,224 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
      * 1. Move to switch position of current toolhead
      * 2. Release and place toolhead in the dock
      * 3. Move to the new toolhead
      * 4. Grab the new toolhead and move to security position
      */
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("Start MST Tool-Change", current_position);
 
     // 1. Move to switch position current toolhead
 
-    current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_CLEAR;
+    current_position.y = SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_CLEAR;
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOLNPAIR("(1) Place old tool ", int(active_extruder));
       DEBUG_POS("Move Y SwitchPos + Security", current_position);
     }
     fast_line_to_current(Y_AXIS);
 
-    current_position[X_AXIS] = placexclear;
+    current_position.x = placexclear;
     if (DEBUGGING(LEVELING)) {
       planner.synchronize();
       DEBUG_POS("Move X SwitchPos + Security", current_position);
     }
     fast_line_to_current(X_AXIS);
 
-    current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS;
+    current_position.y = SWITCHING_TOOLHEAD_Y_POS;
     if (DEBUGGING(LEVELING)) {
       planner.synchronize();
       DEBUG_POS("Move Y SwitchPos", current_position);
     }
     fast_line_to_current(Y_AXIS);
 
-    current_position[X_AXIS] = placexpos;
+    current_position.x = placexpos;
     if (DEBUGGING(LEVELING)) {
       planner.synchronize();
       DEBUG_POS("Move X SwitchPos", current_position);
     }
-    planner.buffer_line(current_position, (planner.settings.max_feedrate_mm_s[X_AXIS] * 0.25), active_extruder);
+    line_to_current_position(planner.settings.max_feedrate_mm_s[X_AXIS] * 0.25f);
 
     // 2. Release and place toolhead in the dock
 
     if (DEBUGGING(LEVELING)) {
       planner.synchronize();
       DEBUG_ECHOLNPGM("(2) Release and Place Toolhead");
     }
 
-    current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_RELEASE;
+    current_position.y = SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_RELEASE;
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos + Release", current_position);
-    planner.buffer_line(current_position, (planner.settings.max_feedrate_mm_s[Y_AXIS] * 0.1), active_extruder);
+    line_to_current_position(planner.settings.max_feedrate_mm_s[Y_AXIS] * 0.1f);
 
-    current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_SECURITY;
+    current_position.y = SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_SECURITY;
     if (DEBUGGING(LEVELING)) {
       planner.synchronize();
       DEBUG_POS("Move Y SwitchPos + Security", current_position);
     }
-    planner.buffer_line(current_position, (planner.settings.max_feedrate_mm_s[Y_AXIS]), active_extruder);
+    line_to_current_position(planner.settings.max_feedrate_mm_s[Y_AXIS]);
 
     // 3. Move to new toolhead position
 
     if (DEBUGGING(LEVELING)) {
       planner.synchronize();
       DEBUG_ECHOLNPGM("(3) Move to new toolhead position");
     }
 
-    current_position[X_AXIS] = grabxpos;
+    current_position.x = grabxpos;
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move to new toolhead X", current_position);
     fast_line_to_current(X_AXIS);
 
     // 4. Grab the new toolhead and move to security position
 
     if (DEBUGGING(LEVELING)) {
       planner.synchronize();
       DEBUG_ECHOLNPGM("(4) Grab new toolhead, move to security position");
     }
 
-    current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_RELEASE;
+    current_position.y = SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_RELEASE;
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos + Release", current_position);
-    planner.buffer_line(current_position, (planner.settings.max_feedrate_mm_s[Y_AXIS]), active_extruder);
+    line_to_current_position(planner.settings.max_feedrate_mm_s[Y_AXIS]);
 
-    current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS;
+    current_position.y = SWITCHING_TOOLHEAD_Y_POS;
     if (DEBUGGING(LEVELING)) {
       planner.synchronize();
       DEBUG_POS("Move Y SwitchPos", current_position);
     }
     _line_to_current(Y_AXIS, 0.2f);
 
     #if ENABLED(PRIME_BEFORE_REMOVE) && (SWITCHING_TOOLHEAD_PRIME_MM || SWITCHING_TOOLHEAD_RETRACT_MM)
       #if SWITCHING_TOOLHEAD_PRIME_MM
-        current_position[E_AXIS] += SWITCHING_TOOLHEAD_PRIME_MM;
+        current_position.e += SWITCHING_TOOLHEAD_PRIME_MM;
         planner.buffer_line(current_position, MMM_TO_MMS(SWITCHING_TOOLHEAD_PRIME_FEEDRATE), new_tool);
       #endif
       #if SWITCHING_TOOLHEAD_RETRACT_MM
-        current_position[E_AXIS] -= SWITCHING_TOOLHEAD_RETRACT_MM;
+        current_position.e -= SWITCHING_TOOLHEAD_RETRACT_MM;
         planner.buffer_line(current_position, MMM_TO_MMS(SWITCHING_TOOLHEAD_RETRACT_FEEDRATE), new_tool);
       #endif
     #else
       planner.synchronize();
       safe_delay(100); // Give switch time to settle
     #endif
 
-    current_position[X_AXIS] = grabxclear;
+    current_position.x = grabxclear;
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move to new toolhead X + Security", current_position);
     _line_to_current(X_AXIS, 0.1f);
     planner.synchronize();
     safe_delay(100); // Give switch time to settle
 
-    current_position[Y_AXIS] += SWITCHING_TOOLHEAD_Y_CLEAR;
+    current_position.y += SWITCHING_TOOLHEAD_Y_CLEAR;
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move back Y clear", current_position);
     fast_line_to_current(Y_AXIS); // move away from docked toolhead
     planner.synchronize(); // Always sync last tool-change move
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("MST Tool-Change done.", current_position);
   }
 
 #elif ENABLED(ELECTROMAGNETIC_SWITCHING_TOOLHEAD)
 
   inline void est_activate_solenoid()   { OUT_WRITE(SOL0_PIN, HIGH); }
   inline void est_deactivate_solenoid() { OUT_WRITE(SOL0_PIN, LOW); }
   void est_init() { est_activate_solenoid(); }
 
   inline void em_switching_toolhead_tool_change(const uint8_t new_tool, bool no_move) {
     if (no_move) return;
 
     constexpr float toolheadposx[] = SWITCHING_TOOLHEAD_X_POS;
     const float placexpos = toolheadposx[active_extruder],
                 grabxpos = toolheadposx[new_tool];
+    const xyz_pos_t &hoffs = hotend_offset[active_extruder];
 
     /**
      * 1. Raise Z-Axis to give enough clearance
      * 2. Move to position near active extruder parking
      * 3. Move gently to park position of active extruder
      * 4. Disengage magnetic field, wait for delay
      * 5. Leave extruder and move to position near new extruder parking
      * 6. Move gently to park position of new extruder
      * 7. Engage magnetic field for new extruder parking
      * 8. Unpark extruder
      * 9. Apply Z hotend offset to current position
      */
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("Start EMST Tool-Change", current_position);
 
     // 1. Raise Z-Axis to give enough clearance
 
-    current_position[Z_AXIS] += SWITCHING_TOOLHEAD_Z_HOP;
+    current_position.z += SWITCHING_TOOLHEAD_Z_HOP;
     if (DEBUGGING(LEVELING)) DEBUG_POS("(1) Raise Z-Axis ", current_position);
     fast_line_to_current(Z_AXIS);
 
     // 2. Move to position near active extruder parking
 
     if (DEBUGGING(LEVELING)) {
       planner.synchronize();
       SERIAL_ECHOLNPAIR("(2) Move near active extruder parking", active_extruder);
       DEBUG_POS("Moving ParkPos", current_position);
     }
-    current_position[X_AXIS] = hotend_offset[X_AXIS][active_extruder] + placexpos;
-    current_position[Y_AXIS] = hotend_offset[Y_AXIS][active_extruder] + SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_CLEAR;
+    current_position.set(hoffs.x + placexpos,
+                         hoffs.y + SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_CLEAR);
     fast_line_to_current(X_AXIS);
 
     // 3. Move gently to park position of active extruder
 
     if (DEBUGGING(LEVELING)) {
       planner.synchronize();
       SERIAL_ECHOLNPAIR("(3) Move gently to park position of active extruder", active_extruder);
       DEBUG_POS("Moving ParkPos", current_position);
     }
 
-    current_position[Y_AXIS] -= SWITCHING_TOOLHEAD_Y_CLEAR;
+    current_position.y -= SWITCHING_TOOLHEAD_Y_CLEAR;
     slow_line_to_current(Y_AXIS);
 
     // 4. Disengage magnetic field, wait for delay
 
     planner.synchronize();
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(4) Disengage magnet");
     est_deactivate_solenoid();
 
     // 5. Leave extruder and move to position near new extruder parking
 
     if (DEBUGGING(LEVELING)) {
       DEBUG_ECHOLNPGM("(5) Move near new extruder parking");
       DEBUG_POS("Moving ParkPos", current_position);
     }
 
-    current_position[Y_AXIS] += SWITCHING_TOOLHEAD_Y_CLEAR;
+    current_position.y += SWITCHING_TOOLHEAD_Y_CLEAR;
     slow_line_to_current(Y_AXIS);
-
-    current_position[X_AXIS] = hotend_offset[X_AXIS][active_extruder] + grabxpos;
-    current_position[Y_AXIS] = hotend_offset[Y_AXIS][active_extruder] + SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_CLEAR;
+    current_position.set(hoffs.x + grabxpos,
+                         hoffs.y + SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_CLEAR);
     fast_line_to_current(X_AXIS);
 
     // 6. Move gently to park position of new extruder
 
-    current_position[Y_AXIS] -= SWITCHING_TOOLHEAD_Y_CLEAR;
+    current_position.y -= SWITCHING_TOOLHEAD_Y_CLEAR;
     if (DEBUGGING(LEVELING)) {
       planner.synchronize();
       DEBUG_ECHOLNPGM("(6) Move near new extruder");
     }
     slow_line_to_current(Y_AXIS);
 
     // 7. Engage magnetic field for new extruder parking
 
     planner.synchronize();
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(7) Engage magnetic field");
     est_activate_solenoid();
 
     // 8. Unpark extruder
 
-    current_position[Y_AXIS] += SWITCHING_TOOLHEAD_Y_CLEAR;
+    current_position.y += SWITCHING_TOOLHEAD_Y_CLEAR;
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(8) Unpark extruder");
     slow_line_to_current(X_AXIS);
     planner.synchronize(); // Always sync the final move
 
     // 9. Apply Z hotend offset to current position
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("(9) Applying Z-offset", current_position);
-    current_position[Z_AXIS] += hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][new_tool];
+    current_position.z += hoffs.z - hotend_offset[new_tool].z;
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("EMST Tool-Change done.", current_position);
   }
 
 #endif // ELECTROMAGNETIC_SWITCHING_TOOLHEAD
 
 #if EXTRUDERS
   inline void invalid_extruder_error(const uint8_t e) {
     SERIAL_ECHO_START();
     SERIAL_CHAR('T'); SERIAL_ECHO(int(e));
@@ -712,49 +712,50 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
       switch (dual_x_carriage_mode) {
         case DXC_FULL_CONTROL_MODE: DEBUG_ECHOLNPGM("FULL_CONTROL"); break;
         case DXC_AUTO_PARK_MODE:    DEBUG_ECHOLNPGM("AUTO_PARK");    break;
         case DXC_DUPLICATION_MODE:  DEBUG_ECHOLNPGM("DUPLICATION");  break;
         case DXC_MIRRORED_MODE:     DEBUG_ECHOLNPGM("MIRRORED");     break;
       }
     }
 
     const float xhome = x_home_pos(active_extruder);
     if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE
-        && IsRunning()
-        && (delayed_move_time || current_position[X_AXIS] != xhome) && ! no_move
+        && IsRunning() && !no_move
+        && (delayed_move_time || current_position.x != xhome)
     ) {
 
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("MoveX to ", xhome);
 
       // Park old head
-      planner.buffer_line(xhome, current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
+      current_position.x = xhome;
+      line_to_current_position(planner.settings.max_feedrate_mm_s[X_AXIS]);
       planner.synchronize();
     }
 
     // Activate the new extruder ahead of calling set_axis_is_at_home!
     active_extruder = new_tool;
 
     // This function resets the max/min values - the current position may be overwritten below.
     set_axis_is_at_home(X_AXIS);
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("New Extruder", current_position);
 
     switch (dual_x_carriage_mode) {
       case DXC_FULL_CONTROL_MODE:
         // New current position is the position of the activated extruder
-        current_position[X_AXIS] = inactive_extruder_x_pos;
+        current_position.x = inactive_extruder_x_pos;
         // Save the inactive extruder's position (from the old current_position)
-        inactive_extruder_x_pos = destination[X_AXIS];
+        inactive_extruder_x_pos = destination.x;
         break;
       case DXC_AUTO_PARK_MODE:
         // record current raised toolhead position for use by unpark
-        COPY(raised_parked_position, current_position);
+        raised_parked_position = current_position;
         active_extruder_parked = true;
         delayed_move_time = 0;
         break;
       default:
         break;
     }
 
     if (DEBUGGING(LEVELING)) {
       DEBUG_ECHOLNPAIR("Active extruder parked: ", active_extruder_parked ? "yes" : "no");
       DEBUG_POS("New extruder (parked)", current_position);
@@ -845,21 +846,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
           SERIAL_ECHO_MSG(MSG_ERR_HOTEND_TOO_COLD);
           #if ENABLED(SINGLENOZZLE)
             active_extruder = new_tool;
             return;
           #endif
         }
         else {
           #if ENABLED(ADVANCED_PAUSE_FEATURE)
             do_pause_e_move(-toolchange_settings.swap_length, MMM_TO_MMS(toolchange_settings.retract_speed));
           #else
-            current_position[E_AXIS] -= toolchange_settings.swap_length / planner.e_factor[old_tool];
+            current_position.e -= toolchange_settings.swap_length / planner.e_factor[old_tool];
             planner.buffer_line(current_position, MMM_TO_MMS(toolchange_settings.retract_speed), old_tool);
             planner.synchronize();
           #endif
         }
       }
     #endif // TOOLCHANGE_FILAMENT_SWAP
 
     #if HAS_LEVELING
       // Set current position to the physical position
       TEMPORARY_BED_LEVELING_STATE(false);
@@ -879,90 +880,84 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
         #else
           #define _EXT_ARGS
         #endif
         update_software_endstops(X_AXIS _EXT_ARGS);
         #if DISABLED(DUAL_X_CARRIAGE)
           update_software_endstops(Y_AXIS _EXT_ARGS);
           update_software_endstops(Z_AXIS _EXT_ARGS);
         #endif
       #endif
 
-      set_destination_from_current();
+      destination = current_position;
 
       #if DISABLED(SWITCHING_NOZZLE)
         if (can_move_away) {
           // Do a small lift to avoid the workpiece in the move back (below)
-          current_position[Z_AXIS] += toolchange_settings.z_raise;
+          current_position.z += toolchange_settings.z_raise;
           #if HAS_SOFTWARE_ENDSTOPS
-            NOMORE(current_position[Z_AXIS], soft_endstop[Z_AXIS].max);
+            NOMORE(current_position.z, soft_endstop.max.z);
           #endif
           fast_line_to_current(Z_AXIS);
           #if ENABLED(TOOLCHANGE_PARK)
-            current_position[X_AXIS] = toolchange_settings.change_point.x;
-            current_position[Y_AXIS] = toolchange_settings.change_point.y;
+            current_position = toolchange_settings.change_point;
           #endif
           planner.buffer_line(current_position, feedrate_mm_s, old_tool);
           planner.synchronize();
         }
       #endif
 
       #if HAS_HOTEND_OFFSET
+        xyz_pos_t diff = hotend_offset[new_tool];
         #if ENABLED(DUAL_X_CARRIAGE)
-          constexpr float xdiff = 0;
-        #else
-          const float xdiff = hotend_offset[X_AXIS][new_tool] - hotend_offset[X_AXIS][old_tool];
+          diff.x = 0;
         #endif
-        const float ydiff = hotend_offset[Y_AXIS][new_tool] - hotend_offset[Y_AXIS][old_tool],
-                    zdiff = hotend_offset[Z_AXIS][new_tool] - hotend_offset[Z_AXIS][old_tool];
       #else
-        constexpr float xdiff = 0, ydiff = 0, zdiff = 0;
+        constexpr xyz_pos_t diff{0};
       #endif
 
       #if ENABLED(DUAL_X_CARRIAGE)
         dualx_tool_change(new_tool, no_move);
       #elif ENABLED(PARKING_EXTRUDER)                                   // Dual Parking extruder
         parking_extruder_tool_change(new_tool, no_move);
       #elif ENABLED(MAGNETIC_PARKING_EXTRUDER)                          // Magnetic Parking extruder
         magnetic_parking_extruder_tool_change(new_tool);
       #elif ENABLED(SWITCHING_TOOLHEAD)                                 // Switching Toolhead
         switching_toolhead_tool_change(new_tool, no_move);
       #elif ENABLED(MAGNETIC_SWITCHING_TOOLHEAD)                        // Magnetic Switching Toolhead
         magnetic_switching_toolhead_tool_change(new_tool, no_move);
       #elif ENABLED(ELECTROMAGNETIC_SWITCHING_TOOLHEAD)                 // Magnetic Switching ToolChanger
         em_switching_toolhead_tool_change(new_tool, no_move);
       #elif ENABLED(SWITCHING_NOZZLE) && !SWITCHING_NOZZLE_TWO_SERVOS   // Switching Nozzle (single servo)
         // Raise by a configured distance to avoid workpiece, except with
         // SWITCHING_NOZZLE_TWO_SERVOS, as both nozzles will lift instead.
-        current_position[Z_AXIS] += _MAX(-zdiff, 0.0) + toolchange_settings.z_raise;
+        current_position.z += _MAX(-zdiff, 0.0) + toolchange_settings.z_raise;
         #if HAS_SOFTWARE_ENDSTOPS
-          NOMORE(current_position[Z_AXIS], soft_endstop[Z_AXIS].max);
+          NOMORE(current_position.z, soft_endstop.max.z);
         #endif
         if (!no_move) fast_line_to_current(Z_AXIS);
         move_nozzle_servo(new_tool);
       #endif
 
-      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Offset Tool XY by { ", xdiff, ", ", ydiff, ", ", zdiff, " }");
-
-      // The newly-selected extruder XY is actually at...
-      current_position[X_AXIS] += xdiff;
-      current_position[Y_AXIS] += ydiff;
-      current_position[Z_AXIS] += zdiff;
+      #if DISABLED(DUAL_X_CARRIAGE)
+        active_extruder = new_tool; // Set the new active extruder
+      #endif
 
-      // Set the new active extruder if not already done in tool specific function above
-      active_extruder = new_tool;
+      // The newly-selected extruder XYZ is actually at...
+      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Offset Tool XY by { ", diff.x, ", ", diff.y, ", ", diff.z, " }");
+      current_position += diff;
 
       // Tell the planner the new "current position"
       sync_plan_position();
 
       #if ENABLED(DELTA)
         //LOOP_XYZ(i) update_software_endstops(i); // or modify the constrain function
-        const bool safe_to_move = current_position[Z_AXIS] < delta_clip_start_height - 1;
+        const bool safe_to_move = current_position.z < delta_clip_start_height - 1;
       #else
         constexpr bool safe_to_move = true;
       #endif
 
       // Return to position and lower again
       if (safe_to_move && !no_move && IsRunning()) {
 
         #if ENABLED(SINGLENOZZLE)
           #if FAN_COUNT > 0
             singlenozzle_fan_speed[old_tool] = thermalManager.fan_speed[0];
@@ -978,64 +973,64 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
             (void)thermalManager.wait_for_hotend(0, false);  // Wait for heating or cooling
           }
         #endif
 
         #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
           if (should_swap && !too_cold) {
             #if ENABLED(ADVANCED_PAUSE_FEATURE)
               do_pause_e_move(toolchange_settings.swap_length, MMM_TO_MMS(toolchange_settings.prime_speed));
               do_pause_e_move(toolchange_settings.extra_prime, ADVANCED_PAUSE_PURGE_FEEDRATE);
             #else
-              current_position[E_AXIS] += toolchange_settings.swap_length / planner.e_factor[new_tool];
+              current_position.e += toolchange_settings.swap_length / planner.e_factor[new_tool];
               planner.buffer_line(current_position, MMM_TO_MMS(toolchange_settings.prime_speed), new_tool);
-              current_position[E_AXIS] += toolchange_settings.extra_prime / planner.e_factor[new_tool];
+              current_position.e += toolchange_settings.extra_prime / planner.e_factor[new_tool];
               planner.buffer_line(current_position, MMM_TO_MMS(toolchange_settings.prime_speed * 0.2f), new_tool);
             #endif
             planner.synchronize();
-            planner.set_e_position_mm((destination[E_AXIS] = current_position[E_AXIS] = current_position[E_AXIS] - (TOOLCHANGE_FIL_EXTRA_PRIME)));
+            planner.set_e_position_mm((destination.e = current_position.e = current_position.e - (TOOLCHANGE_FIL_EXTRA_PRIME)));
           }
         #endif
 
         // Prevent a move outside physical bounds
         #if ENABLED(MAGNETIC_SWITCHING_TOOLHEAD)
           // If the original position is within tool store area, go to X origin at once
-          if (destination[Y_AXIS] < SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_CLEAR) {
-            current_position[X_AXIS] = 0;
+          if (destination.y < SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_CLEAR) {
+            current_position.x = 0;
             planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], new_tool);
             planner.synchronize();
           }
         #else
           apply_motion_limits(destination);
         #endif
 
         // Should the nozzle move back to the old position?
         if (can_move_away) {
           #if ENABLED(TOOLCHANGE_NO_RETURN)
             // Just move back down
             if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Move back Z only");
-            do_blocking_move_to_z(destination[Z_AXIS], planner.settings.max_feedrate_mm_s[Z_AXIS]);
+            do_blocking_move_to_z(destination.z, planner.settings.max_feedrate_mm_s[Z_AXIS]);
           #else
             // Move back to the original (or adjusted) position
             if (DEBUGGING(LEVELING)) DEBUG_POS("Move back", destination);
             do_blocking_move_to(destination);
           #endif
         }
         else if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Move back skipped");
 
         #if ENABLED(DUAL_X_CARRIAGE)
           active_extruder_parked = false;
         #endif
       }
       #if ENABLED(SWITCHING_NOZZLE)
         else {
           // Move back down. (Including when the new tool is higher.)
-          do_blocking_move_to_z(destination[Z_AXIS], planner.settings.max_feedrate_mm_s[Z_AXIS]);
+          do_blocking_move_to_z(destination.z, planner.settings.max_feedrate_mm_s[Z_AXIS]);
         }
       #endif
 
       #if ENABLED(PRUSA_MMU2)
         mmu2.tool_change(new_tool);
       #endif
 
       #if SWITCHING_NOZZLE_TWO_SERVOS
         lower_nozzle(new_tool);
       #endif

commit b2e1f77f58a67ac02503cbe36b22a21e5afaeac0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 25 21:01:29 2019 -0500

    Fix extraneous "Home XYZ First" message

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 608d473454..6178a7ce5d 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -151,21 +151,21 @@ inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_a
   inline void magnetic_parking_extruder_tool_change(const uint8_t new_tool) {
 
     const float oldx = current_position[X_AXIS],
                 grabpos = mpe_settings.parking_xpos[new_tool] + (new_tool ? mpe_settings.grab_distance : -mpe_settings.grab_distance),
                 offsetcompensation = (0
                   #if HAS_HOTEND_OFFSET
                     + hotend_offset[X_AXIS][active_extruder] * mpe_settings.compensation_factor
                   #endif
                 );
 
-    if (axis_unhomed_error(true, false, false)) return;
+    if (axis_unhomed_error(_BV(X_AXIS))) return;
 
     /**
      * Z Lift and Nozzle Offset shift ar defined in caller method to work equal with any Multi Hotend realization
      *
      * Steps:
      *   1. Move high speed to park position of new extruder
      *   2. Move to couple position of new extruder (this also discouple the old extruder)
      *   3. Move to park position of new extruder
      *   4. Move high speed to approach park position of old extruder
      *   5. Move to park position of old extruder

commit 465c6d92307ec613d0b2a7355ce67a60ba23fc0c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Sep 14 03:05:10 2019 -0500

    Simpler Allen Key config. Fixes, cleanups from refactor (#15256)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 1e5af33c98..608d473454 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -126,44 +126,44 @@
     void move_nozzle_servo(const uint8_t angle_index) {
       planner.synchronize();
       MOVE_SERVO(SWITCHING_NOZZLE_SERVO_NR, servo_angles[SWITCHING_NOZZLE_SERVO_NR][angle_index]);
       safe_delay(500);
     }
 
   #endif
 
 #endif // SWITCHING_NOZZLE
 
-inline void fast_line_to_current(const AxisEnum fr_axis) {
-  planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[fr_axis], active_extruder);
+inline void _line_to_current(const AxisEnum fr_axis, const float fscale=1.0f) {
+  planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[fr_axis] * fscale, active_extruder);
 }
+inline void slow_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis, 0.5f); }
+inline void fast_line_to_current(const AxisEnum fr_axis) { _line_to_current(fr_axis); }
 
 #if ENABLED(MAGNETIC_PARKING_EXTRUDER)
 
   float parkingposx[2],           // M951 R L
         parkinggrabdistance,      // M951 I
         parkingslowspeed,         // M951 J
         parkinghighspeed,         // M951 H
         parkingtraveldistance,    // M951 D
         compensationmultiplier;
 
   inline void magnetic_parking_extruder_tool_change(const uint8_t new_tool) {
 
     const float oldx = current_position[X_AXIS],
                 grabpos = mpe_settings.parking_xpos[new_tool] + (new_tool ? mpe_settings.grab_distance : -mpe_settings.grab_distance),
-                offsetcompensation =
+                offsetcompensation = (0
                   #if HAS_HOTEND_OFFSET
-                    hotend_offset[X_AXIS][active_extruder] * mpe_settings.compensation_factor
-                  #else
-                    0
+                    + hotend_offset[X_AXIS][active_extruder] * mpe_settings.compensation_factor
                   #endif
-              ;
+                );
 
     if (axis_unhomed_error(true, false, false)) return;
 
     /**
      * Z Lift and Nozzle Offset shift ar defined in caller method to work equal with any Multi Hotend realization
      *
      * Steps:
      *   1. Move high speed to park position of new extruder
      *   2. Move to couple position of new extruder (this also discouple the old extruder)
      *   3. Move to park position of new extruder
@@ -330,21 +330,21 @@ inline void fast_line_to_current(const AxisEnum fr_axis) {
       // STEP 5
 
       current_position[X_AXIS] = grabpos + (new_tool ? -10 : 10);
       fast_line_to_current(X_AXIS);
 
       current_position[X_AXIS] = grabpos;
       if (DEBUGGING(LEVELING)) {
         planner.synchronize();
         DEBUG_POS("(5) Unpark extruder", current_position);
       }
-      planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS] * 0.5, active_extruder);
+      slow_line_to_current(X_AXIS);
 
       // STEP 6
 
       current_position[X_AXIS] = midpos
         #if HAS_HOTEND_OFFSET
           - hotend_offset[X_AXIS][new_tool]
         #endif
       ;
       if (DEBUGGING(LEVELING)) {
         planner.synchronize();
@@ -404,21 +404,21 @@ inline void fast_line_to_current(const AxisEnum fr_axis) {
 
     // 2. Unlock tool and drop it in the dock
 
     planner.synchronize();
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(2) Unlock and Place Toolhead");
     MOVE_SERVO(SWITCHING_TOOLHEAD_SERVO_NR, angles[1]);
     safe_delay(500);
 
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS;
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos", current_position);
-    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS] * 0.5f, active_extruder);
+    slow_line_to_current(Y_AXIS);
 
     // Wait for move to complete, then another 0.2s
     planner.synchronize();
     safe_delay(200);
 
     current_position[Y_AXIS] -= SWITCHING_TOOLHEAD_Y_CLEAR;
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move back Y clear", current_position);
     fast_line_to_current(Y_AXIS); // move away from docked toolhead
 
     // 3. Move to the new toolhead
@@ -439,21 +439,21 @@ inline void fast_line_to_current(const AxisEnum fr_axis) {
     fast_line_to_current(Y_AXIS);
 
     // 4. Grab and lock the new toolhead
 
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS;
     if (DEBUGGING(LEVELING)) {
       planner.synchronize();
       DEBUG_ECHOLNPGM("(4) Grab and lock new toolhead");
       DEBUG_POS("Move Y SwitchPos", current_position);
     }
-    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS] * 0.5, active_extruder);
+    slow_line_to_current(Y_AXIS);
 
     // Wait for move to finish, pause 0.2s, move servo, pause 0.5s
     planner.synchronize();
     safe_delay(200);
     MOVE_SERVO(SWITCHING_TOOLHEAD_SERVO_NR, angles[0]);
     safe_delay(500);
 
     current_position[Y_AXIS] -= SWITCHING_TOOLHEAD_Y_CLEAR;
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move back Y clear", current_position);
     fast_line_to_current(Y_AXIS); // Move away from docked toolhead
@@ -484,35 +484,35 @@ inline void fast_line_to_current(const AxisEnum fr_axis) {
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("Start MST Tool-Change", current_position);
 
     // 1. Move to switch position current toolhead
 
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_CLEAR;
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOLNPAIR("(1) Place old tool ", int(active_extruder));
       DEBUG_POS("Move Y SwitchPos + Security", current_position);
     }
-    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS], active_extruder);
+    fast_line_to_current(Y_AXIS);
 
     current_position[X_AXIS] = placexclear;
     if (DEBUGGING(LEVELING)) {
       planner.synchronize();
       DEBUG_POS("Move X SwitchPos + Security", current_position);
     }
-    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
+    fast_line_to_current(X_AXIS);
 
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS;
     if (DEBUGGING(LEVELING)) {
       planner.synchronize();
       DEBUG_POS("Move Y SwitchPos", current_position);
     }
-    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS], active_extruder);
+    fast_line_to_current(Y_AXIS);
 
     current_position[X_AXIS] = placexpos;
     if (DEBUGGING(LEVELING)) {
       planner.synchronize();
       DEBUG_POS("Move X SwitchPos", current_position);
     }
     planner.buffer_line(current_position, (planner.settings.max_feedrate_mm_s[X_AXIS] * 0.25), active_extruder);
 
     // 2. Release and place toolhead in the dock
 
@@ -534,63 +534,63 @@ inline void fast_line_to_current(const AxisEnum fr_axis) {
 
     // 3. Move to new toolhead position
 
     if (DEBUGGING(LEVELING)) {
       planner.synchronize();
       DEBUG_ECHOLNPGM("(3) Move to new toolhead position");
     }
 
     current_position[X_AXIS] = grabxpos;
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move to new toolhead X", current_position);
-    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
+    fast_line_to_current(X_AXIS);
 
     // 4. Grab the new toolhead and move to security position
 
     if (DEBUGGING(LEVELING)) {
       planner.synchronize();
       DEBUG_ECHOLNPGM("(4) Grab new toolhead, move to security position");
     }
 
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_RELEASE;
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos + Release", current_position);
     planner.buffer_line(current_position, (planner.settings.max_feedrate_mm_s[Y_AXIS]), active_extruder);
 
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS;
     if (DEBUGGING(LEVELING)) {
       planner.synchronize();
       DEBUG_POS("Move Y SwitchPos", current_position);
     }
-    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS] * 0.2, active_extruder);
+    _line_to_current(Y_AXIS, 0.2f);
 
     #if ENABLED(PRIME_BEFORE_REMOVE) && (SWITCHING_TOOLHEAD_PRIME_MM || SWITCHING_TOOLHEAD_RETRACT_MM)
       #if SWITCHING_TOOLHEAD_PRIME_MM
         current_position[E_AXIS] += SWITCHING_TOOLHEAD_PRIME_MM;
         planner.buffer_line(current_position, MMM_TO_MMS(SWITCHING_TOOLHEAD_PRIME_FEEDRATE), new_tool);
       #endif
       #if SWITCHING_TOOLHEAD_RETRACT_MM
         current_position[E_AXIS] -= SWITCHING_TOOLHEAD_RETRACT_MM;
         planner.buffer_line(current_position, MMM_TO_MMS(SWITCHING_TOOLHEAD_RETRACT_FEEDRATE), new_tool);
       #endif
     #else
       planner.synchronize();
       safe_delay(100); // Give switch time to settle
     #endif
 
     current_position[X_AXIS] = grabxclear;
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move to new toolhead X + Security", current_position);
-    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS] * 0.1, active_extruder);
+    _line_to_current(X_AXIS, 0.1f);
     planner.synchronize();
     safe_delay(100); // Give switch time to settle
 
     current_position[Y_AXIS] += SWITCHING_TOOLHEAD_Y_CLEAR;
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move back Y clear", current_position);
-    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS], active_extruder); // move away from docked toolhead
+    fast_line_to_current(Y_AXIS); // move away from docked toolhead
     planner.synchronize(); // Always sync last tool-change move
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("MST Tool-Change done.", current_position);
   }
 
 #elif ENABLED(ELECTROMAGNETIC_SWITCHING_TOOLHEAD)
 
   inline void est_activate_solenoid()   { OUT_WRITE(SOL0_PIN, HIGH); }
   inline void est_deactivate_solenoid() { OUT_WRITE(SOL0_PIN, LOW); }
   void est_init() { est_activate_solenoid(); }
@@ -613,83 +613,84 @@ inline void fast_line_to_current(const AxisEnum fr_axis) {
      * 8. Unpark extruder
      * 9. Apply Z hotend offset to current position
      */
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("Start EMST Tool-Change", current_position);
 
     // 1. Raise Z-Axis to give enough clearance
 
     current_position[Z_AXIS] += SWITCHING_TOOLHEAD_Z_HOP;
     if (DEBUGGING(LEVELING)) DEBUG_POS("(1) Raise Z-Axis ", current_position);
-    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Z_AXIS], active_extruder);
+    fast_line_to_current(Z_AXIS);
 
     // 2. Move to position near active extruder parking
 
     if (DEBUGGING(LEVELING)) {
       planner.synchronize();
       SERIAL_ECHOLNPAIR("(2) Move near active extruder parking", active_extruder);
       DEBUG_POS("Moving ParkPos", current_position);
     }
-    current_position[X_AXIS] = placexpos + hotend_offset[X_AXIS][active_extruder];
-    current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_CLEAR + hotend_offset[Y_AXIS][active_extruder];
-    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
+    current_position[X_AXIS] = hotend_offset[X_AXIS][active_extruder] + placexpos;
+    current_position[Y_AXIS] = hotend_offset[Y_AXIS][active_extruder] + SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_CLEAR;
+    fast_line_to_current(X_AXIS);
 
     // 3. Move gently to park position of active extruder
 
     if (DEBUGGING(LEVELING)) {
       planner.synchronize();
       SERIAL_ECHOLNPAIR("(3) Move gently to park position of active extruder", active_extruder);
       DEBUG_POS("Moving ParkPos", current_position);
     }
 
     current_position[Y_AXIS] -= SWITCHING_TOOLHEAD_Y_CLEAR;
-    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS] * 0.5, active_extruder);
+    slow_line_to_current(Y_AXIS);
 
     // 4. Disengage magnetic field, wait for delay
 
     planner.synchronize();
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(4) Disengage magnet");
     est_deactivate_solenoid();
 
     // 5. Leave extruder and move to position near new extruder parking
 
     if (DEBUGGING(LEVELING)) {
       DEBUG_ECHOLNPGM("(5) Move near new extruder parking");
       DEBUG_POS("Moving ParkPos", current_position);
     }
 
     current_position[Y_AXIS] += SWITCHING_TOOLHEAD_Y_CLEAR;
-    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS] * 0.5f, active_extruder);
-    current_position[X_AXIS] = grabxpos + hotend_offset[X_AXIS][active_extruder];
-    current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_CLEAR  + hotend_offset[Y_AXIS][active_extruder];
-    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
+    slow_line_to_current(Y_AXIS);
+
+    current_position[X_AXIS] = hotend_offset[X_AXIS][active_extruder] + grabxpos;
+    current_position[Y_AXIS] = hotend_offset[Y_AXIS][active_extruder] + SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_CLEAR;
+    fast_line_to_current(X_AXIS);
 
     // 6. Move gently to park position of new extruder
 
     current_position[Y_AXIS] -= SWITCHING_TOOLHEAD_Y_CLEAR;
     if (DEBUGGING(LEVELING)) {
       planner.synchronize();
       DEBUG_ECHOLNPGM("(6) Move near new extruder");
     }
-    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS] * 0.5f, active_extruder);
+    slow_line_to_current(Y_AXIS);
 
     // 7. Engage magnetic field for new extruder parking
 
     planner.synchronize();
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(7) Engage magnetic field");
     est_activate_solenoid();
 
     // 8. Unpark extruder
 
     current_position[Y_AXIS] += SWITCHING_TOOLHEAD_Y_CLEAR;
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(8) Unpark extruder");
-    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS] * 0.5f, active_extruder);
+    slow_line_to_current(X_AXIS);
     planner.synchronize(); // Always sync the final move
 
     // 9. Apply Z hotend offset to current position
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("(9) Applying Z-offset", current_position);
     current_position[Z_AXIS] += hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][new_tool];
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("EMST Tool-Change done.", current_position);
   }
 

commit 584c86bed1d81548da03681bd3b3c6bd54ae0fe3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 10 02:20:49 2019 -0500

    More "zero extruders" changes (#15213)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 264dd16700..1e5af33c98 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -688,25 +688,27 @@ inline void fast_line_to_current(const AxisEnum fr_axis) {
     // 9. Apply Z hotend offset to current position
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("(9) Applying Z-offset", current_position);
     current_position[Z_AXIS] += hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][new_tool];
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("EMST Tool-Change done.", current_position);
   }
 
 #endif // ELECTROMAGNETIC_SWITCHING_TOOLHEAD
 
-inline void invalid_extruder_error(const uint8_t e) {
-  SERIAL_ECHO_START();
-  SERIAL_CHAR('T'); SERIAL_ECHO(int(e));
-  SERIAL_CHAR(' '); SERIAL_ECHOLNPGM(MSG_INVALID_EXTRUDER);
-}
+#if EXTRUDERS
+  inline void invalid_extruder_error(const uint8_t e) {
+    SERIAL_ECHO_START();
+    SERIAL_CHAR('T'); SERIAL_ECHO(int(e));
+    SERIAL_CHAR(' '); SERIAL_ECHOLNPGM(MSG_INVALID_EXTRUDER);
+  }
+#endif
 
 #if ENABLED(DUAL_X_CARRIAGE)
 
   inline void dualx_tool_change(const uint8_t new_tool, bool &no_move) {
     if (DEBUGGING(LEVELING)) {
       DEBUG_ECHOPGM("Dual X Carriage Mode ");
       switch (dual_x_carriage_mode) {
         case DXC_FULL_CONTROL_MODE: DEBUG_ECHOLNPGM("FULL_CONTROL"); break;
         case DXC_AUTO_PARK_MODE:    DEBUG_ECHOLNPGM("AUTO_PARK");    break;
         case DXC_DUPLICATION_MODE:  DEBUG_ECHOLNPGM("DUPLICATION");  break;
@@ -781,20 +783,25 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
       // T0-Tnnn: Switch virtual tool by changing the index to the mix
       mixer.T(new_tool);
     #endif
 
   #elif ENABLED(PRUSA_MMU2)
 
     UNUSED(no_move);
 
     mmu2.tool_change(new_tool);
 
+  #elif EXTRUDERS == 0
+
+    // Nothing to do
+    UNUSED(new_tool); UNUSED(no_move);
+
   #elif EXTRUDERS < 2
 
     UNUSED(no_move);
 
     if (new_tool) invalid_extruder_error(new_tool);
     return;
 
   #else // EXTRUDERS > 1
 
     planner.synchronize();

commit 369fb2806dfae1be57a3aaee205cd417e3a5f624
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Mon Jul 22 19:08:54 2019 -0600

    Fix compilation warnings, errors (#14704)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 8e27f0d03c..264dd16700 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -763,22 +763,20 @@ inline void invalid_extruder_error(const uint8_t e) {
 /**
  * Perform a tool-change, which may result in moving the
  * previous tool out of the way and the new tool into place.
  */
 void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
 
   #if ENABLED(MAGNETIC_SWITCHING_TOOLHEAD)
     if (new_tool == active_extruder) return;
   #endif
 
-  const uint8_t old_tool = active_extruder;
-
   #if ENABLED(MIXING_EXTRUDER)
 
     UNUSED(no_move);
 
     if (new_tool >= MIXING_VIRTUAL_TOOLS)
       return invalid_extruder_error(new_tool);
 
     #if MIXING_VIRTUAL_TOOLS > 1
       // T0-Tnnn: Switch virtual tool by changing the index to the mix
       mixer.T(new_tool);
@@ -817,20 +815,21 @@ void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
     #if HAS_LCD_MENU
       ui.return_to_status();
     #endif
 
     #if ENABLED(DUAL_X_CARRIAGE)
       const bool idex_full_control = dual_x_carriage_mode == DXC_FULL_CONTROL_MODE;
     #else
       constexpr bool idex_full_control = false;
     #endif
 
+    const uint8_t old_tool = active_extruder;
     const bool can_move_away = !no_move && !idex_full_control;
 
     #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
       const bool should_swap = can_move_away && toolchange_settings.swap_length;
       #if ENABLED(PREVENT_COLD_EXTRUSION)
         const bool too_cold = !DEBUGGING(DRYRUN) && (thermalManager.targetTooColdToExtrude(old_tool) || thermalManager.targetTooColdToExtrude(new_tool));
       #else
         constexpr bool too_cold = false;
       #endif
       if (should_swap) {

commit dc6fa04f6837629c0b5dec66340df5ba5bc564b0
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Jul 21 20:33:37 2019 -0400

    Fix single nozzle temp change, do slower extra prime (#14696)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 78e7f5b4d2..8e27f0d03c 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -139,24 +139,24 @@ inline void fast_line_to_current(const AxisEnum fr_axis) {
 
 #if ENABLED(MAGNETIC_PARKING_EXTRUDER)
 
   float parkingposx[2],           // M951 R L
         parkinggrabdistance,      // M951 I
         parkingslowspeed,         // M951 J
         parkinghighspeed,         // M951 H
         parkingtraveldistance,    // M951 D
         compensationmultiplier;
 
-  inline void magnetic_parking_extruder_tool_change(const uint8_t tmp_extruder) {
+  inline void magnetic_parking_extruder_tool_change(const uint8_t new_tool) {
 
     const float oldx = current_position[X_AXIS],
-                grabpos = mpe_settings.parking_xpos[tmp_extruder] + (tmp_extruder ? mpe_settings.grab_distance : -mpe_settings.grab_distance),
+                grabpos = mpe_settings.parking_xpos[new_tool] + (new_tool ? mpe_settings.grab_distance : -mpe_settings.grab_distance),
                 offsetcompensation =
                   #if HAS_HOTEND_OFFSET
                     hotend_offset[X_AXIS][active_extruder] * mpe_settings.compensation_factor
                   #else
                     0
                   #endif
               ;
 
     if (axis_unhomed_error(true, false, false)) return;
 
@@ -167,89 +167,89 @@ inline void fast_line_to_current(const AxisEnum fr_axis) {
      *   1. Move high speed to park position of new extruder
      *   2. Move to couple position of new extruder (this also discouple the old extruder)
      *   3. Move to park position of new extruder
      *   4. Move high speed to approach park position of old extruder
      *   5. Move to park position of old extruder
      *   6. Move to starting position
      */
 
     // STEP 1
 
-    current_position[X_AXIS] = mpe_settings.parking_xpos[tmp_extruder] + offsetcompensation;
+    current_position[X_AXIS] = mpe_settings.parking_xpos[new_tool] + offsetcompensation;
 
     if (DEBUGGING(LEVELING)) {
-      DEBUG_ECHOPAIR("(1) Move extruder ", int(tmp_extruder));
+      DEBUG_ECHOPAIR("(1) Move extruder ", int(new_tool));
       DEBUG_POS(" to new extruder ParkPos", current_position);
     }
 
-    planner.buffer_line(current_position, mpe_settings.fast_feedrate, tmp_extruder);
+    planner.buffer_line(current_position, mpe_settings.fast_feedrate, new_tool);
     planner.synchronize();
 
     // STEP 2
 
     current_position[X_AXIS] = grabpos + offsetcompensation;
 
     if (DEBUGGING(LEVELING)) {
-      DEBUG_ECHOPAIR("(2) Couple extruder ", int(tmp_extruder));
+      DEBUG_ECHOPAIR("(2) Couple extruder ", int(new_tool));
       DEBUG_POS(" to new extruder GrabPos", current_position);
     }
 
-    planner.buffer_line(current_position, mpe_settings.slow_feedrate, tmp_extruder);
+    planner.buffer_line(current_position, mpe_settings.slow_feedrate, new_tool);
     planner.synchronize();
 
     // Delay before moving tool, to allow magnetic coupling
     gcode.dwell(150);
 
     // STEP 3
 
-    current_position[X_AXIS] = mpe_settings.parking_xpos[tmp_extruder] + offsetcompensation;
+    current_position[X_AXIS] = mpe_settings.parking_xpos[new_tool] + offsetcompensation;
     if (DEBUGGING(LEVELING)) {
-      DEBUG_ECHOPAIR("(3) Move extruder ", int(tmp_extruder));
+      DEBUG_ECHOPAIR("(3) Move extruder ", int(new_tool));
       DEBUG_POS(" back to new extruder ParkPos", current_position);
     }
 
-    planner.buffer_line(current_position, mpe_settings.slow_feedrate, tmp_extruder);
+    planner.buffer_line(current_position, mpe_settings.slow_feedrate, new_tool);
     planner.synchronize();
 
     // STEP 4
 
     current_position[X_AXIS] = mpe_settings.parking_xpos[active_extruder] + (active_extruder == 0 ? MPE_TRAVEL_DISTANCE : -MPE_TRAVEL_DISTANCE) + offsetcompensation;
     if (DEBUGGING(LEVELING)) {
-      DEBUG_ECHOPAIR("(4) Move extruder ", int(tmp_extruder));
+      DEBUG_ECHOPAIR("(4) Move extruder ", int(new_tool));
       DEBUG_POS(" close to old extruder ParkPos", current_position);
     }
 
-    planner.buffer_line(current_position, mpe_settings.fast_feedrate, tmp_extruder);
+    planner.buffer_line(current_position, mpe_settings.fast_feedrate, new_tool);
     planner.synchronize();
 
     // STEP 5
 
     current_position[X_AXIS] = mpe_settings.parking_xpos[active_extruder] + offsetcompensation;
 
     if (DEBUGGING(LEVELING)) {
-      DEBUG_ECHOPAIR("(5) Park extruder ", int(tmp_extruder));
+      DEBUG_ECHOPAIR("(5) Park extruder ", int(new_tool));
       DEBUG_POS(" at old extruder ParkPos", current_position);
     }
 
-    planner.buffer_line(current_position, mpe_settings.slow_feedrate, tmp_extruder);
+    planner.buffer_line(current_position, mpe_settings.slow_feedrate, new_tool);
     planner.synchronize();
 
     // STEP 6
 
     current_position[X_AXIS] = oldx;
 
     if (DEBUGGING(LEVELING)) {
-      DEBUG_ECHOPAIR("(6) Move extruder ", int(tmp_extruder));
+      DEBUG_ECHOPAIR("(6) Move extruder ", int(new_tool));
       DEBUG_POS(" to starting position", current_position);
     }
 
-    planner.buffer_line(current_position, mpe_settings.fast_feedrate, tmp_extruder);
+    planner.buffer_line(current_position, mpe_settings.fast_feedrate, new_tool);
     planner.synchronize();
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Autopark done.");
   }
 
 #elif ENABLED(PARKING_EXTRUDER)
 
   void pe_solenoid_init() {
     for (uint8_t n = 0; n <= 1; ++n)
       #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
@@ -262,33 +262,33 @@ inline void fast_line_to_current(const AxisEnum fr_axis) {
   void pe_set_solenoid(const uint8_t extruder_num, const uint8_t state) {
     switch (extruder_num) {
       case 1: OUT_WRITE(SOL1_PIN, state); break;
       default: OUT_WRITE(SOL0_PIN, state); break;
     }
     #if PARKING_EXTRUDER_SOLENOIDS_DELAY > 0
       gcode.dwell(PARKING_EXTRUDER_SOLENOIDS_DELAY);
     #endif
   }
 
-  inline void parking_extruder_tool_change(const uint8_t tmp_extruder, bool no_move) {
+  inline void parking_extruder_tool_change(const uint8_t new_tool, bool no_move) {
     if (!no_move) {
 
       constexpr float parkingposx[] = PARKING_EXTRUDER_PARKING_X;
 
       #if HAS_HOTEND_OFFSET
         const float x_offset = hotend_offset[X_AXIS][active_extruder];
       #else
         constexpr float x_offset = 0;
       #endif
 
       const float midpos = (parkingposx[0] + parkingposx[1]) * 0.5 + x_offset,
-                  grabpos = parkingposx[tmp_extruder] + (tmp_extruder ? PARKING_EXTRUDER_GRAB_DISTANCE : -(PARKING_EXTRUDER_GRAB_DISTANCE)) + x_offset;
+                  grabpos = parkingposx[new_tool] + (new_tool ? PARKING_EXTRUDER_GRAB_DISTANCE : -(PARKING_EXTRUDER_GRAB_DISTANCE)) + x_offset;
 
       /**
        * 1. Move to park position of old extruder
        * 2. Disengage magnetic field, wait for delay
        * 3. Move near new extruder
        * 4. Engage magnetic field for new extruder
        * 5. Move to parking incl. offset of new extruder
        * 6. Lower Z-Axis
        */
 
@@ -318,71 +318,71 @@ inline void fast_line_to_current(const AxisEnum fr_axis) {
       }
       fast_line_to_current(X_AXIS);
 
       // STEP 4
 
       planner.synchronize();
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(4) Engage magnetic field");
       #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
         pe_activate_solenoid(active_extruder); // Just save power for inverted magnets
       #endif
-      pe_activate_solenoid(tmp_extruder);
+      pe_activate_solenoid(new_tool);
 
       // STEP 5
 
-      current_position[X_AXIS] = grabpos + (tmp_extruder ? -10 : 10);
+      current_position[X_AXIS] = grabpos + (new_tool ? -10 : 10);
       fast_line_to_current(X_AXIS);
 
       current_position[X_AXIS] = grabpos;
       if (DEBUGGING(LEVELING)) {
         planner.synchronize();
         DEBUG_POS("(5) Unpark extruder", current_position);
       }
       planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS] * 0.5, active_extruder);
 
       // STEP 6
 
       current_position[X_AXIS] = midpos
         #if HAS_HOTEND_OFFSET
-          - hotend_offset[X_AXIS][tmp_extruder]
+          - hotend_offset[X_AXIS][new_tool]
         #endif
       ;
       if (DEBUGGING(LEVELING)) {
         planner.synchronize();
         DEBUG_POS("(6) Move midway between hotends", current_position);
       }
       fast_line_to_current(X_AXIS);
       planner.synchronize(); // Always sync the final move
 
       if (DEBUGGING(LEVELING)) DEBUG_POS("PE Tool-Change done.", current_position);
     }
     else { // nomove == true
       // Only engage magnetic field for new extruder
-      pe_activate_solenoid(tmp_extruder);
+      pe_activate_solenoid(new_tool);
       #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
         pe_activate_solenoid(active_extruder); // Just save power for inverted magnets
       #endif
     }
   }
 
 #endif // PARKING_EXTRUDER
 
 #if ENABLED(SWITCHING_TOOLHEAD)
 
-  inline void switching_toolhead_tool_change(const uint8_t tmp_extruder, bool no_move/*=false*/) {
+  inline void switching_toolhead_tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
     if (no_move) return;
 
     constexpr uint16_t angles[2] = SWITCHING_TOOLHEAD_SERVO_ANGLES;
 
     constexpr float toolheadposx[] = SWITCHING_TOOLHEAD_X_POS;
     const float placexpos = toolheadposx[active_extruder],
-                grabxpos = toolheadposx[tmp_extruder];
+                grabxpos = toolheadposx[new_tool];
 
     /**
      * 1. Move to switch position of current toolhead
      * 2. Unlock tool and drop it in the dock
      * 3. Move to the new toolhead
      * 4. Grab and lock the new toolhead
      */
 
     // 1. Move to switch position of current toolhead
 
@@ -457,30 +457,30 @@ inline void fast_line_to_current(const AxisEnum fr_axis) {
     current_position[Y_AXIS] -= SWITCHING_TOOLHEAD_Y_CLEAR;
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move back Y clear", current_position);
     fast_line_to_current(Y_AXIS); // Move away from docked toolhead
     planner.synchronize();        // Always sync the final move
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("ST Tool-Change done.", current_position);
   }
 
 #elif ENABLED(MAGNETIC_SWITCHING_TOOLHEAD)
 
-  inline void magnetic_switching_toolhead_tool_change(const uint8_t tmp_extruder, bool no_move/*=false*/) {
+  inline void magnetic_switching_toolhead_tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
     if (no_move) return;
 
     constexpr float toolheadposx[] = SWITCHING_TOOLHEAD_X_POS,
                     toolheadclearx[] = SWITCHING_TOOLHEAD_X_SECURITY;
 
     const float placexpos = toolheadposx[active_extruder],
                 placexclear = toolheadclearx[active_extruder],
-                grabxpos = toolheadposx[tmp_extruder],
-                grabxclear = toolheadclearx[tmp_extruder];
+                grabxpos = toolheadposx[new_tool],
+                grabxclear = toolheadclearx[new_tool];
 
     /**
      * 1. Move to switch position of current toolhead
      * 2. Release and place toolhead in the dock
      * 3. Move to the new toolhead
      * 4. Grab the new toolhead and move to security position
      */
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("Start MST Tool-Change", current_position);
 
@@ -557,25 +557,25 @@ inline void fast_line_to_current(const AxisEnum fr_axis) {
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS;
     if (DEBUGGING(LEVELING)) {
       planner.synchronize();
       DEBUG_POS("Move Y SwitchPos", current_position);
     }
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS] * 0.2, active_extruder);
 
     #if ENABLED(PRIME_BEFORE_REMOVE) && (SWITCHING_TOOLHEAD_PRIME_MM || SWITCHING_TOOLHEAD_RETRACT_MM)
       #if SWITCHING_TOOLHEAD_PRIME_MM
         current_position[E_AXIS] += SWITCHING_TOOLHEAD_PRIME_MM;
-        planner.buffer_line(current_position, MMM_TO_MMS(SWITCHING_TOOLHEAD_PRIME_FEEDRATE), tmp_extruder);
+        planner.buffer_line(current_position, MMM_TO_MMS(SWITCHING_TOOLHEAD_PRIME_FEEDRATE), new_tool);
       #endif
       #if SWITCHING_TOOLHEAD_RETRACT_MM
         current_position[E_AXIS] -= SWITCHING_TOOLHEAD_RETRACT_MM;
-        planner.buffer_line(current_position, MMM_TO_MMS(SWITCHING_TOOLHEAD_RETRACT_FEEDRATE), tmp_extruder);
+        planner.buffer_line(current_position, MMM_TO_MMS(SWITCHING_TOOLHEAD_RETRACT_FEEDRATE), new_tool);
       #endif
     #else
       planner.synchronize();
       safe_delay(100); // Give switch time to settle
     #endif
 
     current_position[X_AXIS] = grabxclear;
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move to new toolhead X + Security", current_position);
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS] * 0.1, active_extruder);
     planner.synchronize();
@@ -588,26 +588,26 @@ inline void fast_line_to_current(const AxisEnum fr_axis) {
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("MST Tool-Change done.", current_position);
   }
 
 #elif ENABLED(ELECTROMAGNETIC_SWITCHING_TOOLHEAD)
 
   inline void est_activate_solenoid()   { OUT_WRITE(SOL0_PIN, HIGH); }
   inline void est_deactivate_solenoid() { OUT_WRITE(SOL0_PIN, LOW); }
   void est_init() { est_activate_solenoid(); }
 
-  inline void em_switching_toolhead_tool_change(const uint8_t tmp_extruder, bool no_move) {
+  inline void em_switching_toolhead_tool_change(const uint8_t new_tool, bool no_move) {
     if (no_move) return;
 
     constexpr float toolheadposx[] = SWITCHING_TOOLHEAD_X_POS;
     const float placexpos = toolheadposx[active_extruder],
-                grabxpos = toolheadposx[tmp_extruder];
+                grabxpos = toolheadposx[new_tool];
 
     /**
      * 1. Raise Z-Axis to give enough clearance
      * 2. Move to position near active extruder parking
      * 3. Move gently to park position of active extruder
      * 4. Disengage magnetic field, wait for delay
      * 5. Leave extruder and move to position near new extruder parking
      * 6. Move gently to park position of new extruder
      * 7. Engage magnetic field for new extruder parking
      * 8. Unpark extruder
@@ -681,36 +681,36 @@ inline void fast_line_to_current(const AxisEnum fr_axis) {
     // 8. Unpark extruder
 
     current_position[Y_AXIS] += SWITCHING_TOOLHEAD_Y_CLEAR;
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(8) Unpark extruder");
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS] * 0.5f, active_extruder);
     planner.synchronize(); // Always sync the final move
 
     // 9. Apply Z hotend offset to current position
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("(9) Applying Z-offset", current_position);
-    current_position[Z_AXIS] += hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
+    current_position[Z_AXIS] += hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][new_tool];
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("EMST Tool-Change done.", current_position);
   }
 
 #endif // ELECTROMAGNETIC_SWITCHING_TOOLHEAD
 
 inline void invalid_extruder_error(const uint8_t e) {
   SERIAL_ECHO_START();
   SERIAL_CHAR('T'); SERIAL_ECHO(int(e));
   SERIAL_CHAR(' '); SERIAL_ECHOLNPGM(MSG_INVALID_EXTRUDER);
 }
 
 #if ENABLED(DUAL_X_CARRIAGE)
 
-  inline void dualx_tool_change(const uint8_t tmp_extruder, bool &no_move) {
+  inline void dualx_tool_change(const uint8_t new_tool, bool &no_move) {
     if (DEBUGGING(LEVELING)) {
       DEBUG_ECHOPGM("Dual X Carriage Mode ");
       switch (dual_x_carriage_mode) {
         case DXC_FULL_CONTROL_MODE: DEBUG_ECHOLNPGM("FULL_CONTROL"); break;
         case DXC_AUTO_PARK_MODE:    DEBUG_ECHOLNPGM("AUTO_PARK");    break;
         case DXC_DUPLICATION_MODE:  DEBUG_ECHOLNPGM("DUPLICATION");  break;
         case DXC_MIRRORED_MODE:     DEBUG_ECHOLNPGM("MIRRORED");     break;
       }
     }
 
@@ -721,21 +721,21 @@ inline void invalid_extruder_error(const uint8_t e) {
     ) {
 
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("MoveX to ", xhome);
 
       // Park old head
       planner.buffer_line(xhome, current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
       planner.synchronize();
     }
 
     // Activate the new extruder ahead of calling set_axis_is_at_home!
-    active_extruder = tmp_extruder;
+    active_extruder = new_tool;
 
     // This function resets the max/min values - the current position may be overwritten below.
     set_axis_is_at_home(X_AXIS);
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("New Extruder", current_position);
 
     switch (dual_x_carriage_mode) {
       case DXC_FULL_CONTROL_MODE:
         // New current position is the position of the activated extruder
         current_position[X_AXIS] = inactive_extruder_x_pos;
@@ -757,62 +757,64 @@ inline void invalid_extruder_error(const uint8_t e) {
       DEBUG_POS("New extruder (parked)", current_position);
     }
   }
 
 #endif // DUAL_X_CARRIAGE
 
 /**
  * Perform a tool-change, which may result in moving the
  * previous tool out of the way and the new tool into place.
  */
-void tool_change(const uint8_t tmp_extruder, bool no_move/*=false*/) {
+void tool_change(const uint8_t new_tool, bool no_move/*=false*/) {
 
   #if ENABLED(MAGNETIC_SWITCHING_TOOLHEAD)
-    if (tmp_extruder == active_extruder) return;
+    if (new_tool == active_extruder) return;
   #endif
 
+  const uint8_t old_tool = active_extruder;
+
   #if ENABLED(MIXING_EXTRUDER)
 
     UNUSED(no_move);
 
-    if (tmp_extruder >= MIXING_VIRTUAL_TOOLS)
-      return invalid_extruder_error(tmp_extruder);
+    if (new_tool >= MIXING_VIRTUAL_TOOLS)
+      return invalid_extruder_error(new_tool);
 
     #if MIXING_VIRTUAL_TOOLS > 1
       // T0-Tnnn: Switch virtual tool by changing the index to the mix
-      mixer.T(tmp_extruder);
+      mixer.T(new_tool);
     #endif
 
   #elif ENABLED(PRUSA_MMU2)
 
     UNUSED(no_move);
 
-    mmu2.tool_change(tmp_extruder);
+    mmu2.tool_change(new_tool);
 
   #elif EXTRUDERS < 2
 
     UNUSED(no_move);
 
-    if (tmp_extruder) invalid_extruder_error(tmp_extruder);
+    if (new_tool) invalid_extruder_error(new_tool);
     return;
 
   #else // EXTRUDERS > 1
 
     planner.synchronize();
 
     #if ENABLED(DUAL_X_CARRIAGE)  // Only T0 allowed if the Printer is in DXC_DUPLICATION_MODE or DXC_MIRRORED_MODE
-      if (tmp_extruder != 0 && dxc_is_duplicating())
-         return invalid_extruder_error(tmp_extruder);
+      if (new_tool != 0 && dxc_is_duplicating())
+         return invalid_extruder_error(new_tool);
     #endif
 
-    if (tmp_extruder >= EXTRUDERS)
-      return invalid_extruder_error(tmp_extruder);
+    if (new_tool >= EXTRUDERS)
+      return invalid_extruder_error(new_tool);
 
     if (!no_move && !all_axes_homed()) {
       no_move = true;
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("No move (not homed)");
     }
 
     #if HAS_LCD_MENU
       ui.return_to_status();
     #endif
 
@@ -820,60 +822,60 @@ void tool_change(const uint8_t tmp_extruder, bool no_move/*=false*/) {
       const bool idex_full_control = dual_x_carriage_mode == DXC_FULL_CONTROL_MODE;
     #else
       constexpr bool idex_full_control = false;
     #endif
 
     const bool can_move_away = !no_move && !idex_full_control;
 
     #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
       const bool should_swap = can_move_away && toolchange_settings.swap_length;
       #if ENABLED(PREVENT_COLD_EXTRUSION)
-        const bool too_cold = !DEBUGGING(DRYRUN) && (thermalManager.targetTooColdToExtrude(active_extruder) || thermalManager.targetTooColdToExtrude(tmp_extruder));
+        const bool too_cold = !DEBUGGING(DRYRUN) && (thermalManager.targetTooColdToExtrude(old_tool) || thermalManager.targetTooColdToExtrude(new_tool));
       #else
         constexpr bool too_cold = false;
       #endif
       if (should_swap) {
         if (too_cold) {
           SERIAL_ECHO_MSG(MSG_ERR_HOTEND_TOO_COLD);
           #if ENABLED(SINGLENOZZLE)
-            active_extruder = tmp_extruder;
+            active_extruder = new_tool;
             return;
           #endif
         }
         else {
           #if ENABLED(ADVANCED_PAUSE_FEATURE)
             do_pause_e_move(-toolchange_settings.swap_length, MMM_TO_MMS(toolchange_settings.retract_speed));
           #else
-            current_position[E_AXIS] -= toolchange_settings.swap_length / planner.e_factor[active_extruder];
-            planner.buffer_line(current_position, MMM_TO_MMS(toolchange_settings.retract_speed), active_extruder);
+            current_position[E_AXIS] -= toolchange_settings.swap_length / planner.e_factor[old_tool];
+            planner.buffer_line(current_position, MMM_TO_MMS(toolchange_settings.retract_speed), old_tool);
             planner.synchronize();
           #endif
         }
       }
     #endif // TOOLCHANGE_FILAMENT_SWAP
 
     #if HAS_LEVELING
       // Set current position to the physical position
       TEMPORARY_BED_LEVELING_STATE(false);
     #endif
 
-    if (tmp_extruder != active_extruder) {
+    if (new_tool != old_tool) {
 
       #if SWITCHING_NOZZLE_TWO_SERVOS
-        raise_nozzle(active_extruder);
+        raise_nozzle(old_tool);
       #endif
 
       REMEMBER(fr, feedrate_mm_s, XY_PROBE_FEEDRATE_MM_S);
 
       #if HAS_SOFTWARE_ENDSTOPS
         #if HAS_HOTEND_OFFSET
-          #define _EXT_ARGS , active_extruder, tmp_extruder
+          #define _EXT_ARGS , old_tool, new_tool
         #else
           #define _EXT_ARGS
         #endif
         update_software_endstops(X_AXIS _EXT_ARGS);
         #if DISABLED(DUAL_X_CARRIAGE)
           update_software_endstops(Y_AXIS _EXT_ARGS);
           update_software_endstops(Z_AXIS _EXT_ARGS);
         #endif
       #endif
 
@@ -884,119 +886,121 @@ void tool_change(const uint8_t tmp_extruder, bool no_move/*=false*/) {
           // Do a small lift to avoid the workpiece in the move back (below)
           current_position[Z_AXIS] += toolchange_settings.z_raise;
           #if HAS_SOFTWARE_ENDSTOPS
             NOMORE(current_position[Z_AXIS], soft_endstop[Z_AXIS].max);
           #endif
           fast_line_to_current(Z_AXIS);
           #if ENABLED(TOOLCHANGE_PARK)
             current_position[X_AXIS] = toolchange_settings.change_point.x;
             current_position[Y_AXIS] = toolchange_settings.change_point.y;
           #endif
-          planner.buffer_line(current_position, feedrate_mm_s, active_extruder);
+          planner.buffer_line(current_position, feedrate_mm_s, old_tool);
           planner.synchronize();
         }
       #endif
 
       #if HAS_HOTEND_OFFSET
         #if ENABLED(DUAL_X_CARRIAGE)
           constexpr float xdiff = 0;
         #else
-          const float xdiff = hotend_offset[X_AXIS][tmp_extruder] - hotend_offset[X_AXIS][active_extruder];
+          const float xdiff = hotend_offset[X_AXIS][new_tool] - hotend_offset[X_AXIS][old_tool];
         #endif
-        const float ydiff = hotend_offset[Y_AXIS][tmp_extruder] - hotend_offset[Y_AXIS][active_extruder],
-                    zdiff = hotend_offset[Z_AXIS][tmp_extruder] - hotend_offset[Z_AXIS][active_extruder];
+        const float ydiff = hotend_offset[Y_AXIS][new_tool] - hotend_offset[Y_AXIS][old_tool],
+                    zdiff = hotend_offset[Z_AXIS][new_tool] - hotend_offset[Z_AXIS][old_tool];
       #else
         constexpr float xdiff = 0, ydiff = 0, zdiff = 0;
       #endif
 
       #if ENABLED(DUAL_X_CARRIAGE)
-        dualx_tool_change(tmp_extruder, no_move);
+        dualx_tool_change(new_tool, no_move);
       #elif ENABLED(PARKING_EXTRUDER)                                   // Dual Parking extruder
-        parking_extruder_tool_change(tmp_extruder, no_move);
+        parking_extruder_tool_change(new_tool, no_move);
       #elif ENABLED(MAGNETIC_PARKING_EXTRUDER)                          // Magnetic Parking extruder
-        magnetic_parking_extruder_tool_change(tmp_extruder);
+        magnetic_parking_extruder_tool_change(new_tool);
       #elif ENABLED(SWITCHING_TOOLHEAD)                                 // Switching Toolhead
-        switching_toolhead_tool_change(tmp_extruder, no_move);
+        switching_toolhead_tool_change(new_tool, no_move);
       #elif ENABLED(MAGNETIC_SWITCHING_TOOLHEAD)                        // Magnetic Switching Toolhead
-        magnetic_switching_toolhead_tool_change(tmp_extruder, no_move);
+        magnetic_switching_toolhead_tool_change(new_tool, no_move);
       #elif ENABLED(ELECTROMAGNETIC_SWITCHING_TOOLHEAD)                 // Magnetic Switching ToolChanger
-        em_switching_toolhead_tool_change(tmp_extruder, no_move);
+        em_switching_toolhead_tool_change(new_tool, no_move);
       #elif ENABLED(SWITCHING_NOZZLE) && !SWITCHING_NOZZLE_TWO_SERVOS   // Switching Nozzle (single servo)
         // Raise by a configured distance to avoid workpiece, except with
         // SWITCHING_NOZZLE_TWO_SERVOS, as both nozzles will lift instead.
         current_position[Z_AXIS] += _MAX(-zdiff, 0.0) + toolchange_settings.z_raise;
         #if HAS_SOFTWARE_ENDSTOPS
           NOMORE(current_position[Z_AXIS], soft_endstop[Z_AXIS].max);
         #endif
         if (!no_move) fast_line_to_current(Z_AXIS);
-        move_nozzle_servo(tmp_extruder);
+        move_nozzle_servo(new_tool);
       #endif
 
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Offset Tool XY by { ", xdiff, ", ", ydiff, ", ", zdiff, " }");
 
       // The newly-selected extruder XY is actually at...
       current_position[X_AXIS] += xdiff;
       current_position[Y_AXIS] += ydiff;
       current_position[Z_AXIS] += zdiff;
 
       // Set the new active extruder if not already done in tool specific function above
-      active_extruder = tmp_extruder;
+      active_extruder = new_tool;
 
       // Tell the planner the new "current position"
       sync_plan_position();
 
       #if ENABLED(DELTA)
         //LOOP_XYZ(i) update_software_endstops(i); // or modify the constrain function
         const bool safe_to_move = current_position[Z_AXIS] < delta_clip_start_height - 1;
       #else
         constexpr bool safe_to_move = true;
       #endif
 
       // Return to position and lower again
       if (safe_to_move && !no_move && IsRunning()) {
 
         #if ENABLED(SINGLENOZZLE)
           #if FAN_COUNT > 0
-            singlenozzle_fan_speed[active_extruder] = thermalManager.fan_speed[0];
-            thermalManager.fan_speed[0] = singlenozzle_fan_speed[tmp_extruder];
+            singlenozzle_fan_speed[old_tool] = thermalManager.fan_speed[0];
+            thermalManager.fan_speed[0] = singlenozzle_fan_speed[new_tool];
           #endif
 
-          singlenozzle_temp[active_extruder] = thermalManager.temp_hotend[0].target;
-          if (singlenozzle_temp[tmp_extruder] && singlenozzle_temp[tmp_extruder] != singlenozzle_temp[active_extruder]) {
-            thermalManager.setTargetHotend(singlenozzle_temp[tmp_extruder], 0);
+          singlenozzle_temp[old_tool] = thermalManager.temp_hotend[0].target;
+          if (singlenozzle_temp[new_tool] && singlenozzle_temp[new_tool] != singlenozzle_temp[old_tool]) {
+            thermalManager.setTargetHotend(singlenozzle_temp[new_tool], 0);
             #if HAS_DISPLAY
               thermalManager.set_heating_message(0);
             #endif
             (void)thermalManager.wait_for_hotend(0, false);  // Wait for heating or cooling
           }
-          active_extruder = tmp_extruder;
         #endif
 
         #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
           if (should_swap && !too_cold) {
             #if ENABLED(ADVANCED_PAUSE_FEATURE)
-              do_pause_e_move(toolchange_settings.swap_length + toolchange_settings.extra_prime, MMM_TO_MMS(toolchange_settings.prime_speed));
+              do_pause_e_move(toolchange_settings.swap_length, MMM_TO_MMS(toolchange_settings.prime_speed));
+              do_pause_e_move(toolchange_settings.extra_prime, ADVANCED_PAUSE_PURGE_FEEDRATE);
             #else
-              current_position[E_AXIS] += (toolchange_settings.swap_length + toolchange_settings.extra_prime) / planner.e_factor[tmp_extruder];
-              planner.buffer_line(current_position, MMM_TO_MMS(toolchange_settings.prime_speed), tmp_extruder);
+              current_position[E_AXIS] += toolchange_settings.swap_length / planner.e_factor[new_tool];
+              planner.buffer_line(current_position, MMM_TO_MMS(toolchange_settings.prime_speed), new_tool);
+              current_position[E_AXIS] += toolchange_settings.extra_prime / planner.e_factor[new_tool];
+              planner.buffer_line(current_position, MMM_TO_MMS(toolchange_settings.prime_speed * 0.2f), new_tool);
             #endif
             planner.synchronize();
             planner.set_e_position_mm((destination[E_AXIS] = current_position[E_AXIS] = current_position[E_AXIS] - (TOOLCHANGE_FIL_EXTRA_PRIME)));
           }
         #endif
 
         // Prevent a move outside physical bounds
         #if ENABLED(MAGNETIC_SWITCHING_TOOLHEAD)
           // If the original position is within tool store area, go to X origin at once
           if (destination[Y_AXIS] < SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_CLEAR) {
             current_position[X_AXIS] = 0;
-            planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
+            planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], new_tool);
             planner.synchronize();
           }
         #else
           apply_motion_limits(destination);
         #endif
 
         // Should the nozzle move back to the old position?
         if (can_move_away) {
           #if ENABLED(TOOLCHANGE_NO_RETURN)
             // Just move back down
@@ -1015,39 +1019,39 @@ void tool_change(const uint8_t tmp_extruder, bool no_move/*=false*/) {
         #endif
       }
       #if ENABLED(SWITCHING_NOZZLE)
         else {
           // Move back down. (Including when the new tool is higher.)
           do_blocking_move_to_z(destination[Z_AXIS], planner.settings.max_feedrate_mm_s[Z_AXIS]);
         }
       #endif
 
       #if ENABLED(PRUSA_MMU2)
-        mmu2.tool_change(tmp_extruder);
+        mmu2.tool_change(new_tool);
       #endif
 
       #if SWITCHING_NOZZLE_TWO_SERVOS
-        lower_nozzle(active_extruder);
+        lower_nozzle(new_tool);
       #endif
 
-    } // (tmp_extruder != active_extruder)
+    } // (new_tool != old_tool)
 
     planner.synchronize();
 
     #if ENABLED(EXT_SOLENOID) && DISABLED(PARKING_EXTRUDER)
       disable_all_solenoids();
       enable_solenoid_on_active_extruder();
     #endif
 
     #if ENABLED(MK2_MULTIPLEXER)
-      if (tmp_extruder >= E_STEPPERS) return invalid_extruder_error(tmp_extruder);
-      select_multiplexed_stepper(tmp_extruder);
+      if (new_tool >= E_STEPPERS) return invalid_extruder_error(new_tool);
+      select_multiplexed_stepper(new_tool);
     #endif
 
     #if DO_SWITCH_EXTRUDER
       planner.synchronize();
       move_extruder_servo(active_extruder);
     #endif
 
     #if HAS_FANMUX
       fanmux_switch(active_extruder);
     #endif

commit 9cd66f6f7735995d161384015c0c6a9c4149a83d
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sat Jul 20 02:55:34 2019 -0400

    Fix missing include & condition (#14682)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 0efaf337cc..78e7f5b4d2 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -74,20 +74,24 @@
 #endif
 
 #if ENABLED(PRUSA_MMU2)
   #include "../feature/prusa_MMU2/mmu2.h"
 #endif
 
 #if HAS_LCD_MENU
   #include "../lcd/ultralcd.h"
 #endif
 
+#if ENABLED(ADVANCED_PAUSE_FEATURE)
+  #include "../feature/pause.h"
+#endif
+
 #if DO_SWITCH_EXTRUDER
 
   #if EXTRUDERS > 3
     #define _SERVO_NR(E) ((E) < 2 ? SWITCHING_EXTRUDER_SERVO_NR : SWITCHING_EXTRUDER_E23_SERVO_NR)
   #else
     #define _SERVO_NR(E) SWITCHING_EXTRUDER_SERVO_NR
   #endif
 
   void move_extruder_servo(const uint8_t e) {
     planner.synchronize();

commit 00e2f6da8f097215ddb96a83fe6853d26fb6bca4
Author: wookie666 <chemmings60@gmail.com>
Date:   Fri Jul 19 21:07:26 2019 +1000

    Improve magnetic dock switching toolhead (#14663)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 420128f6a9..0efaf337cc 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -342,21 +342,21 @@ inline void fast_line_to_current(const AxisEnum fr_axis) {
           - hotend_offset[X_AXIS][tmp_extruder]
         #endif
       ;
       if (DEBUGGING(LEVELING)) {
         planner.synchronize();
         DEBUG_POS("(6) Move midway between hotends", current_position);
       }
       fast_line_to_current(X_AXIS);
       planner.synchronize(); // Always sync the final move
 
-      DEBUG_ECHOLNPGM("PE Tool-Change done.");
+      if (DEBUGGING(LEVELING)) DEBUG_POS("PE Tool-Change done.", current_position);
     }
     else { // nomove == true
       // Only engage magnetic field for new extruder
       pe_activate_solenoid(tmp_extruder);
       #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
         pe_activate_solenoid(active_extruder); // Just save power for inverted magnets
       #endif
     }
   }
 
@@ -448,51 +448,55 @@ inline void fast_line_to_current(const AxisEnum fr_axis) {
     planner.synchronize();
     safe_delay(200);
     MOVE_SERVO(SWITCHING_TOOLHEAD_SERVO_NR, angles[0]);
     safe_delay(500);
 
     current_position[Y_AXIS] -= SWITCHING_TOOLHEAD_Y_CLEAR;
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move back Y clear", current_position);
     fast_line_to_current(Y_AXIS); // Move away from docked toolhead
     planner.synchronize();        // Always sync the final move
 
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("ST Tool-Change done.");
+    if (DEBUGGING(LEVELING)) DEBUG_POS("ST Tool-Change done.", current_position);
   }
 
 #elif ENABLED(MAGNETIC_SWITCHING_TOOLHEAD)
 
   inline void magnetic_switching_toolhead_tool_change(const uint8_t tmp_extruder, bool no_move/*=false*/) {
     if (no_move) return;
 
-    constexpr float toolheadposx[] = SWITCHING_TOOLHEAD_X_POS;
+    constexpr float toolheadposx[] = SWITCHING_TOOLHEAD_X_POS,
+                    toolheadclearx[] = SWITCHING_TOOLHEAD_X_SECURITY;
+
     const float placexpos = toolheadposx[active_extruder],
-                grabxpos = toolheadposx[tmp_extruder];
+                placexclear = toolheadclearx[active_extruder],
+                grabxpos = toolheadposx[tmp_extruder],
+                grabxclear = toolheadclearx[tmp_extruder];
 
     /**
      * 1. Move to switch position of current toolhead
      * 2. Release and place toolhead in the dock
      * 3. Move to the new toolhead
      * 4. Grab the new toolhead and move to security position
      */
 
-    if (DEBUGGING(LEVELING)) DEBUG_POS("Starting Toolhead change", current_position);
+    if (DEBUGGING(LEVELING)) DEBUG_POS("Start MST Tool-Change", current_position);
 
     // 1. Move to switch position current toolhead
 
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_CLEAR;
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOLNPAIR("(1) Place old tool ", int(active_extruder));
       DEBUG_POS("Move Y SwitchPos + Security", current_position);
     }
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS], active_extruder);
 
-    current_position[X_AXIS] = placexpos + SWITCHING_TOOLHEAD_X_SECURITY;
+    current_position[X_AXIS] = placexclear;
     if (DEBUGGING(LEVELING)) {
       planner.synchronize();
       DEBUG_POS("Move X SwitchPos + Security", current_position);
     }
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
 
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS;
     if (DEBUGGING(LEVELING)) {
       planner.synchronize();
       DEBUG_POS("Move Y SwitchPos", current_position);
@@ -503,103 +507,117 @@ inline void fast_line_to_current(const AxisEnum fr_axis) {
     if (DEBUGGING(LEVELING)) {
       planner.synchronize();
       DEBUG_POS("Move X SwitchPos", current_position);
     }
     planner.buffer_line(current_position, (planner.settings.max_feedrate_mm_s[X_AXIS] * 0.25), active_extruder);
 
     // 2. Release and place toolhead in the dock
 
     if (DEBUGGING(LEVELING)) {
       planner.synchronize();
-      SERIAL_ECHOLNPGM("(2) Release and Place Toolhead");
+      DEBUG_ECHOLNPGM("(2) Release and Place Toolhead");
     }
 
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_RELEASE;
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos + Release", current_position);
     planner.buffer_line(current_position, (planner.settings.max_feedrate_mm_s[Y_AXIS] * 0.1), active_extruder);
 
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_SECURITY;
     if (DEBUGGING(LEVELING)) {
       planner.synchronize();
       DEBUG_POS("Move Y SwitchPos + Security", current_position);
     }
     planner.buffer_line(current_position, (planner.settings.max_feedrate_mm_s[Y_AXIS]), active_extruder);
 
     // 3. Move to new toolhead position
 
     if (DEBUGGING(LEVELING)) {
       planner.synchronize();
-      SERIAL_ECHOLNPGM("(3) Move to new toolhead position");
+      DEBUG_ECHOLNPGM("(3) Move to new toolhead position");
     }
 
     current_position[X_AXIS] = grabxpos;
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move to new toolhead X", current_position);
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
 
     // 4. Grab the new toolhead and move to security position
 
     if (DEBUGGING(LEVELING)) {
       planner.synchronize();
-      SERIAL_ECHOLNPGM("(4) Grab new toolhead and move to security position");
+      DEBUG_ECHOLNPGM("(4) Grab new toolhead, move to security position");
     }
 
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_RELEASE;
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos + Release", current_position);
     planner.buffer_line(current_position, (planner.settings.max_feedrate_mm_s[Y_AXIS]), active_extruder);
 
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS;
     if (DEBUGGING(LEVELING)) {
       planner.synchronize();
       DEBUG_POS("Move Y SwitchPos", current_position);
     }
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS] * 0.2, active_extruder);
-    planner.synchronize();
-    safe_delay(100); // Give switch time to settle
 
-    current_position[X_AXIS] = grabxpos + SWITCHING_TOOLHEAD_X_SECURITY;
+    #if ENABLED(PRIME_BEFORE_REMOVE) && (SWITCHING_TOOLHEAD_PRIME_MM || SWITCHING_TOOLHEAD_RETRACT_MM)
+      #if SWITCHING_TOOLHEAD_PRIME_MM
+        current_position[E_AXIS] += SWITCHING_TOOLHEAD_PRIME_MM;
+        planner.buffer_line(current_position, MMM_TO_MMS(SWITCHING_TOOLHEAD_PRIME_FEEDRATE), tmp_extruder);
+      #endif
+      #if SWITCHING_TOOLHEAD_RETRACT_MM
+        current_position[E_AXIS] -= SWITCHING_TOOLHEAD_RETRACT_MM;
+        planner.buffer_line(current_position, MMM_TO_MMS(SWITCHING_TOOLHEAD_RETRACT_FEEDRATE), tmp_extruder);
+      #endif
+    #else
+      planner.synchronize();
+      safe_delay(100); // Give switch time to settle
+    #endif
+
+    current_position[X_AXIS] = grabxclear;
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move to new toolhead X + Security", current_position);
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS] * 0.1, active_extruder);
     planner.synchronize();
     safe_delay(100); // Give switch time to settle
 
     current_position[Y_AXIS] += SWITCHING_TOOLHEAD_Y_CLEAR;
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move back Y clear", current_position);
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS], active_extruder); // move away from docked toolhead
     planner.synchronize(); // Always sync last tool-change move
+
+    if (DEBUGGING(LEVELING)) DEBUG_POS("MST Tool-Change done.", current_position);
   }
 
 #elif ENABLED(ELECTROMAGNETIC_SWITCHING_TOOLHEAD)
 
   inline void est_activate_solenoid()   { OUT_WRITE(SOL0_PIN, HIGH); }
   inline void est_deactivate_solenoid() { OUT_WRITE(SOL0_PIN, LOW); }
   void est_init() { est_activate_solenoid(); }
 
-  inline void electromagnetic_switching_toolhead(const uint8_t tmp_extruder, bool no_move) {
+  inline void em_switching_toolhead_tool_change(const uint8_t tmp_extruder, bool no_move) {
     if (no_move) return;
 
     constexpr float toolheadposx[] = SWITCHING_TOOLHEAD_X_POS;
     const float placexpos = toolheadposx[active_extruder],
                 grabxpos = toolheadposx[tmp_extruder];
 
     /**
      * 1. Raise Z-Axis to give enough clearance
      * 2. Move to position near active extruder parking
      * 3. Move gently to park position of active extruder
      * 4. Disengage magnetic field, wait for delay
      * 5. Leave extruder and move to position near new extruder parking
      * 6. Move gently to park position of new extruder
      * 7. Engage magnetic field for new extruder parking
      * 8. Unpark extruder
      * 9. Apply Z hotend offset to current position
      */
 
-    if (DEBUGGING(LEVELING)) DEBUG_POS("Starting Autopark", current_position);
+    if (DEBUGGING(LEVELING)) DEBUG_POS("Start EMST Tool-Change", current_position);
 
     // 1. Raise Z-Axis to give enough clearance
 
     current_position[Z_AXIS] += SWITCHING_TOOLHEAD_Z_HOP;
     if (DEBUGGING(LEVELING)) DEBUG_POS("(1) Raise Z-Axis ", current_position);
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Z_AXIS], active_extruder);
 
     // 2. Move to position near active extruder parking
 
     if (DEBUGGING(LEVELING)) {
@@ -617,73 +635,65 @@ inline void fast_line_to_current(const AxisEnum fr_axis) {
       planner.synchronize();
       SERIAL_ECHOLNPAIR("(3) Move gently to park position of active extruder", active_extruder);
       DEBUG_POS("Moving ParkPos", current_position);
     }
 
     current_position[Y_AXIS] -= SWITCHING_TOOLHEAD_Y_CLEAR;
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS] * 0.5, active_extruder);
 
     // 4. Disengage magnetic field, wait for delay
 
-    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(4) Disengage magnet");
-
     planner.synchronize();
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(4) Disengage magnet");
     est_deactivate_solenoid();
 
     // 5. Leave extruder and move to position near new extruder parking
 
     if (DEBUGGING(LEVELING)) {
-      SERIAL_ECHOLNPGM("(5) Move near new extruder parking");
+      DEBUG_ECHOLNPGM("(5) Move near new extruder parking");
       DEBUG_POS("Moving ParkPos", current_position);
     }
 
     current_position[Y_AXIS] += SWITCHING_TOOLHEAD_Y_CLEAR;
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS] * 0.5f, active_extruder);
-
     current_position[X_AXIS] = grabxpos + hotend_offset[X_AXIS][active_extruder];
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_CLEAR  + hotend_offset[Y_AXIS][active_extruder];
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
 
     // 6. Move gently to park position of new extruder
 
+    current_position[Y_AXIS] -= SWITCHING_TOOLHEAD_Y_CLEAR;
     if (DEBUGGING(LEVELING)) {
       planner.synchronize();
-      SERIAL_ECHOLNPGM("(6) Move near new extruder");
+      DEBUG_ECHOLNPGM("(6) Move near new extruder");
     }
-
-    current_position[Y_AXIS] -= SWITCHING_TOOLHEAD_Y_CLEAR;
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS] * 0.5f, active_extruder);
 
     // 7. Engage magnetic field for new extruder parking
 
     planner.synchronize();
-
-    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(7) Engage magnetic field");
-
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(7) Engage magnetic field");
     est_activate_solenoid();
 
     // 8. Unpark extruder
 
-    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(8) Unpark extruder");
-
     current_position[Y_AXIS] += SWITCHING_TOOLHEAD_Y_CLEAR;
-
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(8) Unpark extruder");
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS] * 0.5f, active_extruder);
+    planner.synchronize(); // Always sync the final move
 
     // 9. Apply Z hotend offset to current position
 
+    if (DEBUGGING(LEVELING)) DEBUG_POS("(9) Applying Z-offset", current_position);
     current_position[Z_AXIS] += hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
 
-    if (DEBUGGING(LEVELING)) {
-      planner.synchronize();
-      DEBUG_POS("(9) Applying Z-offset", current_position);
-    }
+    if (DEBUGGING(LEVELING)) DEBUG_POS("EMST Tool-Change done.", current_position);
   }
 
 #endif // ELECTROMAGNETIC_SWITCHING_TOOLHEAD
 
 inline void invalid_extruder_error(const uint8_t e) {
   SERIAL_ECHO_START();
   SERIAL_CHAR('T'); SERIAL_ECHO(int(e));
   SERIAL_CHAR(' '); SERIAL_ECHOLNPGM(MSG_INVALID_EXTRUDER);
 }
 
@@ -898,21 +908,21 @@ void tool_change(const uint8_t tmp_extruder, bool no_move/*=false*/) {
         dualx_tool_change(tmp_extruder, no_move);
       #elif ENABLED(PARKING_EXTRUDER)                                   // Dual Parking extruder
         parking_extruder_tool_change(tmp_extruder, no_move);
       #elif ENABLED(MAGNETIC_PARKING_EXTRUDER)                          // Magnetic Parking extruder
         magnetic_parking_extruder_tool_change(tmp_extruder);
       #elif ENABLED(SWITCHING_TOOLHEAD)                                 // Switching Toolhead
         switching_toolhead_tool_change(tmp_extruder, no_move);
       #elif ENABLED(MAGNETIC_SWITCHING_TOOLHEAD)                        // Magnetic Switching Toolhead
         magnetic_switching_toolhead_tool_change(tmp_extruder, no_move);
       #elif ENABLED(ELECTROMAGNETIC_SWITCHING_TOOLHEAD)                 // Magnetic Switching ToolChanger
-        electromagnetic_switching_toolhead(tmp_extruder, no_move);
+        em_switching_toolhead_tool_change(tmp_extruder, no_move);
       #elif ENABLED(SWITCHING_NOZZLE) && !SWITCHING_NOZZLE_TWO_SERVOS   // Switching Nozzle (single servo)
         // Raise by a configured distance to avoid workpiece, except with
         // SWITCHING_NOZZLE_TWO_SERVOS, as both nozzles will lift instead.
         current_position[Z_AXIS] += _MAX(-zdiff, 0.0) + toolchange_settings.z_raise;
         #if HAS_SOFTWARE_ENDSTOPS
           NOMORE(current_position[Z_AXIS], soft_endstop[Z_AXIS].max);
         #endif
         if (!no_move) fast_line_to_current(Z_AXIS);
         move_nozzle_servo(tmp_extruder);
       #endif

commit 68108789d07af6d68e477a71528e9807c950df9f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jul 18 02:44:08 2019 -0500

    Add'l toolchange syncs

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 9a6a588b5f..420128f6a9 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -128,25 +128,25 @@
   #endif
 
 #endif // SWITCHING_NOZZLE
 
 inline void fast_line_to_current(const AxisEnum fr_axis) {
   planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[fr_axis], active_extruder);
 }
 
 #if ENABLED(MAGNETIC_PARKING_EXTRUDER)
 
-  float parkingposx[2] ,           // M951 R L
-        parkinggrabdistance ,      // M951 I
-        parkingslowspeed,          // M951 J
-        parkinghighspeed ,         // M951 H
-        parkingtraveldistance,     // M951 D
+  float parkingposx[2],           // M951 R L
+        parkinggrabdistance,      // M951 I
+        parkingslowspeed,         // M951 J
+        parkinghighspeed,         // M951 H
+        parkingtraveldistance,    // M951 D
         compensationmultiplier;
 
   inline void magnetic_parking_extruder_tool_change(const uint8_t tmp_extruder) {
 
     const float oldx = current_position[X_AXIS],
                 grabpos = mpe_settings.parking_xpos[tmp_extruder] + (tmp_extruder ? mpe_settings.grab_distance : -mpe_settings.grab_distance),
                 offsetcompensation =
                   #if HAS_HOTEND_OFFSET
                     hotend_offset[X_AXIS][active_extruder] * mpe_settings.compensation_factor
                   #else
@@ -283,81 +283,80 @@ inline void fast_line_to_current(const AxisEnum fr_axis) {
        * 1. Move to park position of old extruder
        * 2. Disengage magnetic field, wait for delay
        * 3. Move near new extruder
        * 4. Engage magnetic field for new extruder
        * 5. Move to parking incl. offset of new extruder
        * 6. Lower Z-Axis
        */
 
       // STEP 1
 
-      if (DEBUGGING(LEVELING)) DEBUG_POS("Start Autopark", current_position);
+      if (DEBUGGING(LEVELING)) DEBUG_POS("Start PE Tool-Change", current_position);
 
       current_position[X_AXIS] = parkingposx[active_extruder] + x_offset;
-
       if (DEBUGGING(LEVELING)) {
         DEBUG_ECHOLNPAIR("(1) Park extruder ", int(active_extruder));
         DEBUG_POS("Moving ParkPos", current_position);
       }
-
       fast_line_to_current(X_AXIS);
-      planner.synchronize();
 
       // STEP 2
 
-      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(2) Disengage magnet ");
-
+      planner.synchronize();
+      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(2) Disengage magnet");
       pe_deactivate_solenoid(active_extruder);
 
       // STEP 3
 
-      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(3) Move near new extruder");
-
       current_position[X_AXIS] += active_extruder ? -10 : 10; // move 10mm away from parked extruder
-
-      if (DEBUGGING(LEVELING)) DEBUG_POS("Move away from parked extruder", current_position);
-
+      if (DEBUGGING(LEVELING)) {
+        DEBUG_ECHOLNPGM("(3) Move near new extruder");
+        DEBUG_POS("Move away from parked extruder", current_position);
+      }
       fast_line_to_current(X_AXIS);
-      planner.synchronize();
 
       // STEP 4
-      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(4) Engage magnetic field");
 
+      planner.synchronize();
+      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(4) Engage magnetic field");
       #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
-        pe_activate_solenoid(active_extruder); //just save power for inverted magnets
+        pe_activate_solenoid(active_extruder); // Just save power for inverted magnets
       #endif
-
       pe_activate_solenoid(tmp_extruder);
 
       // STEP 5
 
       current_position[X_AXIS] = grabpos + (tmp_extruder ? -10 : 10);
       fast_line_to_current(X_AXIS);
+
       current_position[X_AXIS] = grabpos;
-      if (DEBUGGING(LEVELING)) DEBUG_POS("(5) Unpark extruder", current_position);
+      if (DEBUGGING(LEVELING)) {
+        planner.synchronize();
+        DEBUG_POS("(5) Unpark extruder", current_position);
+      }
       planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS] * 0.5, active_extruder);
-      planner.synchronize();
 
       // STEP 6
 
       current_position[X_AXIS] = midpos
         #if HAS_HOTEND_OFFSET
           - hotend_offset[X_AXIS][tmp_extruder]
         #endif
       ;
-
-      if (DEBUGGING(LEVELING)) DEBUG_POS("(6) Move midway between hotends", current_position);
-
+      if (DEBUGGING(LEVELING)) {
+        planner.synchronize();
+        DEBUG_POS("(6) Move midway between hotends", current_position);
+      }
       fast_line_to_current(X_AXIS);
-      planner.synchronize();
+      planner.synchronize(); // Always sync the final move
 
-      DEBUG_ECHOLNPGM("Autopark done.");
+      DEBUG_ECHOLNPGM("PE Tool-Change done.");
     }
     else { // nomove == true
       // Only engage magnetic field for new extruder
       pe_activate_solenoid(tmp_extruder);
       #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
         pe_activate_solenoid(active_extruder); // Just save power for inverted magnets
       #endif
     }
   }
 
@@ -376,100 +375,94 @@ inline void fast_line_to_current(const AxisEnum fr_axis) {
 
     /**
      * 1. Move to switch position of current toolhead
      * 2. Unlock tool and drop it in the dock
      * 3. Move to the new toolhead
      * 4. Grab and lock the new toolhead
      */
 
     // 1. Move to switch position of current toolhead
 
-    if (DEBUGGING(LEVELING)) DEBUG_POS("Starting Toolhead change", current_position);
+    if (DEBUGGING(LEVELING)) DEBUG_POS("Start ST Tool-Change", current_position);
 
     current_position[X_AXIS] = placexpos;
-
     if (DEBUGGING(LEVELING)) {
       DEBUG_ECHOLNPAIR("(1) Place old tool ", int(active_extruder));
       DEBUG_POS("Move X SwitchPos", current_position);
     }
-
     fast_line_to_current(X_AXIS);
-    planner.synchronize();
-
-    current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS - SWITCHING_TOOLHEAD_Y_SECURITY;
-
-    if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos + Security", current_position);
 
+    current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS - (SWITCHING_TOOLHEAD_Y_SECURITY);
+    if (DEBUGGING(LEVELING)) {
+      planner.synchronize();
+      DEBUG_POS("Move Y SwitchPos + Security", current_position);
+    }
     fast_line_to_current(Y_AXIS);
-    planner.synchronize();
 
     // 2. Unlock tool and drop it in the dock
 
+    planner.synchronize();
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(2) Unlock and Place Toolhead");
-
     MOVE_SERVO(SWITCHING_TOOLHEAD_SERVO_NR, angles[1]);
     safe_delay(500);
 
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS;
-
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos", current_position);
+    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS] * 0.5f, active_extruder);
 
-    planner.buffer_line(current_position,(planner.settings.max_feedrate_mm_s[Y_AXIS] * 0.5), active_extruder);
+    // Wait for move to complete, then another 0.2s
     planner.synchronize();
     safe_delay(200);
-    current_position[Y_AXIS] -= SWITCHING_TOOLHEAD_Y_CLEAR;
 
+    current_position[Y_AXIS] -= SWITCHING_TOOLHEAD_Y_CLEAR;
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move back Y clear", current_position);
-
     fast_line_to_current(Y_AXIS); // move away from docked toolhead
-    planner.synchronize();
 
     // 3. Move to the new toolhead
 
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(3) Move to new toolhead position");
-
     current_position[X_AXIS] = grabxpos;
-
-    if (DEBUGGING(LEVELING)) DEBUG_POS("Move to new toolhead X", current_position);
-
+    if (DEBUGGING(LEVELING)) {
+      planner.synchronize();
+      DEBUG_ECHOLNPGM("(3) Move to new toolhead position");
+      DEBUG_POS("Move to new toolhead X", current_position);
+    }
     fast_line_to_current(X_AXIS);
-    planner.synchronize();
-    current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS - SWITCHING_TOOLHEAD_Y_SECURITY;
-
-    if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos + Security", current_position);
 
+    current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS - (SWITCHING_TOOLHEAD_Y_SECURITY);
+    if (DEBUGGING(LEVELING)) {
+      planner.synchronize();
+      DEBUG_POS("Move Y SwitchPos + Security", current_position);
+    }
     fast_line_to_current(Y_AXIS);
-    planner.synchronize();
 
     // 4. Grab and lock the new toolhead
 
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(4) Grab and lock new toolhead ");
-
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS;
-
-    if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos", current_position);
-
+    if (DEBUGGING(LEVELING)) {
+      planner.synchronize();
+      DEBUG_ECHOLNPGM("(4) Grab and lock new toolhead");
+      DEBUG_POS("Move Y SwitchPos", current_position);
+    }
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS] * 0.5, active_extruder);
-    planner.synchronize();
 
+    // Wait for move to finish, pause 0.2s, move servo, pause 0.5s
+    planner.synchronize();
     safe_delay(200);
     MOVE_SERVO(SWITCHING_TOOLHEAD_SERVO_NR, angles[0]);
     safe_delay(500);
 
     current_position[Y_AXIS] -= SWITCHING_TOOLHEAD_Y_CLEAR;
-
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move back Y clear", current_position);
+    fast_line_to_current(Y_AXIS); // Move away from docked toolhead
+    planner.synchronize();        // Always sync the final move
 
-    fast_line_to_current(Y_AXIS); // move away from docked toolhead
-    planner.synchronize();
-
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Toolhead change done.");
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("ST Tool-Change done.");
   }
 
 #elif ENABLED(MAGNETIC_SWITCHING_TOOLHEAD)
 
   inline void magnetic_switching_toolhead_tool_change(const uint8_t tmp_extruder, bool no_move/*=false*/) {
     if (no_move) return;
 
     constexpr float toolheadposx[] = SWITCHING_TOOLHEAD_X_POS;
     const float placexpos = toolheadposx[active_extruder],
                 grabxpos = toolheadposx[tmp_extruder];

commit fac0e63058bff2c743a379e63fd973fe0b562e54
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jul 18 02:17:46 2019 -0500

    Clean up tool-change syncs (#14666)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 910dd2a5c3..9a6a588b5f 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -479,112 +479,106 @@ inline void fast_line_to_current(const AxisEnum fr_axis) {
      * 2. Release and place toolhead in the dock
      * 3. Move to the new toolhead
      * 4. Grab the new toolhead and move to security position
      */
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("Starting Toolhead change", current_position);
 
     // 1. Move to switch position current toolhead
 
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_CLEAR;
-
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOLNPAIR("(1) Place old tool ", int(active_extruder));
       DEBUG_POS("Move Y SwitchPos + Security", current_position);
     }
-
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS], active_extruder);
-    planner.synchronize();
 
     current_position[X_AXIS] = placexpos + SWITCHING_TOOLHEAD_X_SECURITY;
-
-    if (DEBUGGING(LEVELING)) DEBUG_POS("Move X SwitchPos + Security", current_position);
-
+    if (DEBUGGING(LEVELING)) {
+      planner.synchronize();
+      DEBUG_POS("Move X SwitchPos + Security", current_position);
+    }
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
-    planner.synchronize();
 
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS;
-
-    if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos", current_position);
-
+    if (DEBUGGING(LEVELING)) {
+      planner.synchronize();
+      DEBUG_POS("Move Y SwitchPos", current_position);
+    }
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS], active_extruder);
-    planner.synchronize();
 
     current_position[X_AXIS] = placexpos;
-
-    if (DEBUGGING(LEVELING)) DEBUG_POS("Move X SwitchPos", current_position);
-
+    if (DEBUGGING(LEVELING)) {
+      planner.synchronize();
+      DEBUG_POS("Move X SwitchPos", current_position);
+    }
     planner.buffer_line(current_position, (planner.settings.max_feedrate_mm_s[X_AXIS] * 0.25), active_extruder);
-    planner.synchronize();
 
     // 2. Release and place toolhead in the dock
 
-    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(2) Release and Place Toolhead");
+    if (DEBUGGING(LEVELING)) {
+      planner.synchronize();
+      SERIAL_ECHOLNPGM("(2) Release and Place Toolhead");
+    }
 
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_RELEASE;
-
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos + Release", current_position);
-
     planner.buffer_line(current_position, (planner.settings.max_feedrate_mm_s[Y_AXIS] * 0.1), active_extruder);
-    planner.synchronize();
 
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_SECURITY;
-
-    if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos + Security", current_position);
-
+    if (DEBUGGING(LEVELING)) {
+      planner.synchronize();
+      DEBUG_POS("Move Y SwitchPos + Security", current_position);
+    }
     planner.buffer_line(current_position, (planner.settings.max_feedrate_mm_s[Y_AXIS]), active_extruder);
-    planner.synchronize();
 
     // 3. Move to new toolhead position
 
-    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(3) Move to new toolhead position");
+    if (DEBUGGING(LEVELING)) {
+      planner.synchronize();
+      SERIAL_ECHOLNPGM("(3) Move to new toolhead position");
+    }
 
     current_position[X_AXIS] = grabxpos;
-
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move to new toolhead X", current_position);
-
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
-    planner.synchronize();
 
     // 4. Grab the new toolhead and move to security position
 
-    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(4) Grab new toolhead and move to security position");
+    if (DEBUGGING(LEVELING)) {
+      planner.synchronize();
+      SERIAL_ECHOLNPGM("(4) Grab new toolhead and move to security position");
+    }
 
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_RELEASE;
-
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos + Release", current_position);
-
     planner.buffer_line(current_position, (planner.settings.max_feedrate_mm_s[Y_AXIS]), active_extruder);
-    planner.synchronize();
 
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS;
-
-    if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos", current_position);
-
+    if (DEBUGGING(LEVELING)) {
+      planner.synchronize();
+      DEBUG_POS("Move Y SwitchPos", current_position);
+    }
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS] * 0.2, active_extruder);
     planner.synchronize();
-    safe_delay(100);
+    safe_delay(100); // Give switch time to settle
 
     current_position[X_AXIS] = grabxpos + SWITCHING_TOOLHEAD_X_SECURITY;
-
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move to new toolhead X + Security", current_position);
-
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS] * 0.1, active_extruder);
     planner.synchronize();
-    safe_delay(100);
+    safe_delay(100); // Give switch time to settle
 
     current_position[Y_AXIS] += SWITCHING_TOOLHEAD_Y_CLEAR;
-
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move back Y clear", current_position);
-
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS], active_extruder); // move away from docked toolhead
-    planner.synchronize();
+    planner.synchronize(); // Always sync last tool-change move
   }
 
 #elif ENABLED(ELECTROMAGNETIC_SWITCHING_TOOLHEAD)
 
   inline void est_activate_solenoid()   { OUT_WRITE(SOL0_PIN, HIGH); }
   inline void est_deactivate_solenoid() { OUT_WRITE(SOL0_PIN, LOW); }
   void est_init() { est_activate_solenoid(); }
 
   inline void electromagnetic_switching_toolhead(const uint8_t tmp_extruder, bool no_move) {
     if (no_move) return;

commit 42b5ccafc951bdb0e5c2e23ea12704f43563b0d3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jul 17 20:24:25 2019 -0500

    Toss obsolete DEBUG_LEVELING_FEATURE tests

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 7f1f6aab20..910dd2a5c3 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -598,124 +598,105 @@ inline void fast_line_to_current(const AxisEnum fr_axis) {
      * 2. Move to position near active extruder parking
      * 3. Move gently to park position of active extruder
      * 4. Disengage magnetic field, wait for delay
      * 5. Leave extruder and move to position near new extruder parking
      * 6. Move gently to park position of new extruder
      * 7. Engage magnetic field for new extruder parking
      * 8. Unpark extruder
      * 9. Apply Z hotend offset to current position
      */
 
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) DEBUG_POS("Starting Autopark", current_position);
-    #endif
+    if (DEBUGGING(LEVELING)) DEBUG_POS("Starting Autopark", current_position);
 
     // 1. Raise Z-Axis to give enough clearance
 
     current_position[Z_AXIS] += SWITCHING_TOOLHEAD_Z_HOP;
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) DEBUG_POS("(1) Raise Z-Axis ", current_position);
-    #endif
+    if (DEBUGGING(LEVELING)) DEBUG_POS("(1) Raise Z-Axis ", current_position);
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Z_AXIS], active_extruder);
 
     // 2. Move to position near active extruder parking
 
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        planner.synchronize();
-        SERIAL_ECHOLNPAIR("(2) Move near active extruder parking", active_extruder);
-        DEBUG_POS("Moving ParkPos", current_position);
-      }
-    #endif
+    if (DEBUGGING(LEVELING)) {
+      planner.synchronize();
+      SERIAL_ECHOLNPAIR("(2) Move near active extruder parking", active_extruder);
+      DEBUG_POS("Moving ParkPos", current_position);
+    }
     current_position[X_AXIS] = placexpos + hotend_offset[X_AXIS][active_extruder];
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_CLEAR + hotend_offset[Y_AXIS][active_extruder];
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
 
     // 3. Move gently to park position of active extruder
 
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        planner.synchronize();
-        SERIAL_ECHOLNPAIR("(3) Move gently to park position of active extruder", active_extruder);
-        DEBUG_POS("Moving ParkPos", current_position);
-      }
-    #endif
+    if (DEBUGGING(LEVELING)) {
+      planner.synchronize();
+      SERIAL_ECHOLNPAIR("(3) Move gently to park position of active extruder", active_extruder);
+      DEBUG_POS("Moving ParkPos", current_position);
+    }
 
     current_position[Y_AXIS] -= SWITCHING_TOOLHEAD_Y_CLEAR;
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS] * 0.5, active_extruder);
 
     // 4. Disengage magnetic field, wait for delay
 
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(4) Disengage magnet");
-    #endif
+    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(4) Disengage magnet");
 
     planner.synchronize();
     est_deactivate_solenoid();
 
     // 5. Leave extruder and move to position near new extruder parking
 
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        SERIAL_ECHOLNPGM("(5) Move near new extruder parking");
-        DEBUG_POS("Moving ParkPos", current_position);
-      }
-    #endif
+    if (DEBUGGING(LEVELING)) {
+      SERIAL_ECHOLNPGM("(5) Move near new extruder parking");
+      DEBUG_POS("Moving ParkPos", current_position);
+    }
 
     current_position[Y_AXIS] += SWITCHING_TOOLHEAD_Y_CLEAR;
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS] * 0.5f, active_extruder);
 
     current_position[X_AXIS] = grabxpos + hotend_offset[X_AXIS][active_extruder];
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_CLEAR  + hotend_offset[Y_AXIS][active_extruder];
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
 
     // 6. Move gently to park position of new extruder
 
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        planner.synchronize();
-        SERIAL_ECHOLNPGM("(6) Move near new extruder");
-      }
-    #endif
+    if (DEBUGGING(LEVELING)) {
+      planner.synchronize();
+      SERIAL_ECHOLNPGM("(6) Move near new extruder");
+    }
 
     current_position[Y_AXIS] -= SWITCHING_TOOLHEAD_Y_CLEAR;
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS] * 0.5f, active_extruder);
 
     // 7. Engage magnetic field for new extruder parking
 
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(7) Engage magnetic field");
-    #endif
-
     planner.synchronize();
+
+    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(7) Engage magnetic field");
+
     est_activate_solenoid();
 
     // 8. Unpark extruder
 
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(8) Unpark extruder");
-    #endif
+    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(8) Unpark extruder");
 
     current_position[Y_AXIS] += SWITCHING_TOOLHEAD_Y_CLEAR;
 
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS] * 0.5f, active_extruder);
 
     // 9. Apply Z hotend offset to current position
 
     current_position[Z_AXIS] += hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
 
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        planner.synchronize();
-        DEBUG_POS("(9) Applying Z-offset", current_position);
-      }
-    #endif
+    if (DEBUGGING(LEVELING)) {
+      planner.synchronize();
+      DEBUG_POS("(9) Applying Z-offset", current_position);
+    }
   }
 
 #endif // ELECTROMAGNETIC_SWITCHING_TOOLHEAD
 
 inline void invalid_extruder_error(const uint8_t e) {
   SERIAL_ECHO_START();
   SERIAL_CHAR('T'); SERIAL_ECHO(int(e));
   SERIAL_CHAR(' '); SERIAL_ECHOLNPGM(MSG_INVALID_EXTRUDER);
 }
 

commit b8cc61262f5d4f322f537e7eb2ac75bec9490249
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Wed Jul 17 04:41:04 2019 -0400

    Finish G12, update Nozzle::clean (#14642)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 73f3716960..7f1f6aab20 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -815,26 +815,20 @@ void tool_change(const uint8_t tmp_extruder, bool no_move/*=false*/) {
 
   #else // EXTRUDERS > 1
 
     planner.synchronize();
 
     #if ENABLED(DUAL_X_CARRIAGE)  // Only T0 allowed if the Printer is in DXC_DUPLICATION_MODE or DXC_MIRRORED_MODE
       if (tmp_extruder != 0 && dxc_is_duplicating())
          return invalid_extruder_error(tmp_extruder);
     #endif
 
-    #if HAS_LEVELING
-      // Set current position to the physical position
-      const bool leveling_was_active = planner.leveling_active;
-      set_bed_leveling_enabled(false);
-    #endif
-
     if (tmp_extruder >= EXTRUDERS)
       return invalid_extruder_error(tmp_extruder);
 
     if (!no_move && !all_axes_homed()) {
       no_move = true;
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("No move (not homed)");
     }
 
     #if HAS_LCD_MENU
       ui.return_to_status();
@@ -868,20 +862,25 @@ void tool_change(const uint8_t tmp_extruder, bool no_move/*=false*/) {
             do_pause_e_move(-toolchange_settings.swap_length, MMM_TO_MMS(toolchange_settings.retract_speed));
           #else
             current_position[E_AXIS] -= toolchange_settings.swap_length / planner.e_factor[active_extruder];
             planner.buffer_line(current_position, MMM_TO_MMS(toolchange_settings.retract_speed), active_extruder);
             planner.synchronize();
           #endif
         }
       }
     #endif // TOOLCHANGE_FILAMENT_SWAP
 
+    #if HAS_LEVELING
+      // Set current position to the physical position
+      TEMPORARY_BED_LEVELING_STATE(false);
+    #endif
+
     if (tmp_extruder != active_extruder) {
 
       #if SWITCHING_NOZZLE_TWO_SERVOS
         raise_nozzle(active_extruder);
       #endif
 
       REMEMBER(fr, feedrate_mm_s, XY_PROBE_FEEDRATE_MM_S);
 
       #if HAS_SOFTWARE_ENDSTOPS
         #if HAS_HOTEND_OFFSET
@@ -1064,20 +1063,15 @@ void tool_change(const uint8_t tmp_extruder, bool no_move/*=false*/) {
 
     #if DO_SWITCH_EXTRUDER
       planner.synchronize();
       move_extruder_servo(active_extruder);
     #endif
 
     #if HAS_FANMUX
       fanmux_switch(active_extruder);
     #endif
 
-    #if HAS_LEVELING
-      // Restore leveling to re-establish the logical position
-      set_bed_leveling_enabled(leveling_was_active);
-    #endif
-
     SERIAL_ECHO_START();
     SERIAL_ECHOLNPAIR(MSG_ACTIVE_EXTRUDER, int(active_extruder));
 
   #endif // EXTRUDERS > 1
 }

commit 27c487bab744a22aeb580a0471591adba040bc68
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Wed Jul 17 02:12:39 2019 -0600

    Print progress enhancements (#14647)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index c113678a0d..73f3716960 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -975,21 +975,21 @@ void tool_change(const uint8_t tmp_extruder, bool no_move/*=false*/) {
 
         #if ENABLED(SINGLENOZZLE)
           #if FAN_COUNT > 0
             singlenozzle_fan_speed[active_extruder] = thermalManager.fan_speed[0];
             thermalManager.fan_speed[0] = singlenozzle_fan_speed[tmp_extruder];
           #endif
 
           singlenozzle_temp[active_extruder] = thermalManager.temp_hotend[0].target;
           if (singlenozzle_temp[tmp_extruder] && singlenozzle_temp[tmp_extruder] != singlenozzle_temp[active_extruder]) {
             thermalManager.setTargetHotend(singlenozzle_temp[tmp_extruder], 0);
-            #if EITHER(ULTRA_LCD, EXTENSIBLE_UI)
+            #if HAS_DISPLAY
               thermalManager.set_heating_message(0);
             #endif
             (void)thermalManager.wait_for_hotend(0, false);  // Wait for heating or cooling
           }
           active_extruder = tmp_extruder;
         #endif
 
         #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
           if (should_swap && !too_cold) {
             #if ENABLED(ADVANCED_PAUSE_FEATURE)

commit ce02c6cee2bf17590d929d078d71cc37f67e00d1
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Jul 14 12:40:58 2019 -0400

    Variable tool change purge (#14618)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index f32ca32e95..c113678a0d 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -986,30 +986,27 @@ void tool_change(const uint8_t tmp_extruder, bool no_move/*=false*/) {
               thermalManager.set_heating_message(0);
             #endif
             (void)thermalManager.wait_for_hotend(0, false);  // Wait for heating or cooling
           }
           active_extruder = tmp_extruder;
         #endif
 
         #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
           if (should_swap && !too_cold) {
             #if ENABLED(ADVANCED_PAUSE_FEATURE)
-              do_pause_e_move(toolchange_settings.swap_length + TOOLCHANGE_FIL_EXTRA_PRIME, MMM_TO_MMS(toolchange_settings.prime_speed));
+              do_pause_e_move(toolchange_settings.swap_length + toolchange_settings.extra_prime, MMM_TO_MMS(toolchange_settings.prime_speed));
             #else
-              current_position[E_AXIS] += (toolchange_settings.swap_length + TOOLCHANGE_FIL_EXTRA_PRIME) / planner.e_factor[tmp_extruder];
+              current_position[E_AXIS] += (toolchange_settings.swap_length + toolchange_settings.extra_prime) / planner.e_factor[tmp_extruder];
               planner.buffer_line(current_position, MMM_TO_MMS(toolchange_settings.prime_speed), tmp_extruder);
             #endif
             planner.synchronize();
-
-            #if TOOLCHANGE_FIL_EXTRA_PRIME
-              planner.set_e_position_mm((destination[E_AXIS] = current_position[E_AXIS] = current_position[E_AXIS] - (TOOLCHANGE_FIL_EXTRA_PRIME)));
-            #endif
+            planner.set_e_position_mm((destination[E_AXIS] = current_position[E_AXIS] = current_position[E_AXIS] - (TOOLCHANGE_FIL_EXTRA_PRIME)));
           }
         #endif
 
         // Prevent a move outside physical bounds
         #if ENABLED(MAGNETIC_SWITCHING_TOOLHEAD)
           // If the original position is within tool store area, go to X origin at once
           if (destination[Y_AXIS] < SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_CLEAR) {
             current_position[X_AXIS] = 0;
             planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
             planner.synchronize();

commit 750a16ad385dca893d482cb51d8af2ac3f8a1da1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jul 5 18:01:21 2019 -0500

    Fix MIN/MAX function collision with macros

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 5c6d37ad97..f32ca32e95 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -935,21 +935,21 @@ void tool_change(const uint8_t tmp_extruder, bool no_move/*=false*/) {
         magnetic_parking_extruder_tool_change(tmp_extruder);
       #elif ENABLED(SWITCHING_TOOLHEAD)                                 // Switching Toolhead
         switching_toolhead_tool_change(tmp_extruder, no_move);
       #elif ENABLED(MAGNETIC_SWITCHING_TOOLHEAD)                        // Magnetic Switching Toolhead
         magnetic_switching_toolhead_tool_change(tmp_extruder, no_move);
       #elif ENABLED(ELECTROMAGNETIC_SWITCHING_TOOLHEAD)                 // Magnetic Switching ToolChanger
         electromagnetic_switching_toolhead(tmp_extruder, no_move);
       #elif ENABLED(SWITCHING_NOZZLE) && !SWITCHING_NOZZLE_TWO_SERVOS   // Switching Nozzle (single servo)
         // Raise by a configured distance to avoid workpiece, except with
         // SWITCHING_NOZZLE_TWO_SERVOS, as both nozzles will lift instead.
-        current_position[Z_AXIS] += MAX(-zdiff, 0.0) + toolchange_settings.z_raise;
+        current_position[Z_AXIS] += _MAX(-zdiff, 0.0) + toolchange_settings.z_raise;
         #if HAS_SOFTWARE_ENDSTOPS
           NOMORE(current_position[Z_AXIS], soft_endstop[Z_AXIS].max);
         #endif
         if (!no_move) fast_line_to_current(Z_AXIS);
         move_nozzle_servo(tmp_extruder);
       #endif
 
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Offset Tool XY by { ", xdiff, ", ", ydiff, ", ", zdiff, " }");
 
       // The newly-selected extruder XY is actually at...

commit 2f932a11b3bacb50c520fed0549551e2e363a41a
Author: Aliaksei Kvitsinski <aleksei.wm@gmail.com>
Date:   Mon Jul 1 13:55:23 2019 +0300

    Park heads with electromagnet (#14023)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 9ab6db9211..5c6d37ad97 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -303,21 +303,21 @@ inline void fast_line_to_current(const AxisEnum fr_axis) {
       planner.synchronize();
 
       // STEP 2
 
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(2) Disengage magnet ");
 
       pe_deactivate_solenoid(active_extruder);
 
       // STEP 3
 
-      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(3) Move to position near new extruder");
+      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(3) Move near new extruder");
 
       current_position[X_AXIS] += active_extruder ? -10 : 10; // move 10mm away from parked extruder
 
       if (DEBUGGING(LEVELING)) DEBUG_POS("Move away from parked extruder", current_position);
 
       fast_line_to_current(X_AXIS);
       planner.synchronize();
 
       // STEP 4
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(4) Engage magnetic field");
@@ -363,22 +363,22 @@ inline void fast_line_to_current(const AxisEnum fr_axis) {
 
 #endif // PARKING_EXTRUDER
 
 #if ENABLED(SWITCHING_TOOLHEAD)
 
   inline void switching_toolhead_tool_change(const uint8_t tmp_extruder, bool no_move/*=false*/) {
     if (no_move) return;
 
     constexpr uint16_t angles[2] = SWITCHING_TOOLHEAD_SERVO_ANGLES;
 
-    const float toolheadposx[] = SWITCHING_TOOLHEAD_X_POS,
-                placexpos = toolheadposx[active_extruder],
+    constexpr float toolheadposx[] = SWITCHING_TOOLHEAD_X_POS;
+    const float placexpos = toolheadposx[active_extruder],
                 grabxpos = toolheadposx[tmp_extruder];
 
     /**
      * 1. Move to switch position of current toolhead
      * 2. Unlock tool and drop it in the dock
      * 3. Move to the new toolhead
      * 4. Grab and lock the new toolhead
      */
 
     // 1. Move to switch position of current toolhead
@@ -458,29 +458,27 @@ inline void fast_line_to_current(const AxisEnum fr_axis) {
     current_position[Y_AXIS] -= SWITCHING_TOOLHEAD_Y_CLEAR;
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move back Y clear", current_position);
 
     fast_line_to_current(Y_AXIS); // move away from docked toolhead
     planner.synchronize();
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Toolhead change done.");
   }
 
-#endif // SWITCHING_TOOLHEAD
-
-#if ENABLED(MAGNETIC_SWITCHING_TOOLHEAD)
+#elif ENABLED(MAGNETIC_SWITCHING_TOOLHEAD)
 
   inline void magnetic_switching_toolhead_tool_change(const uint8_t tmp_extruder, bool no_move/*=false*/) {
     if (no_move) return;
 
-    const float toolheadposx[] = SWITCHING_TOOLHEAD_X_POS,
-                placexpos = toolheadposx[active_extruder],
+    constexpr float toolheadposx[] = SWITCHING_TOOLHEAD_X_POS;
+    const float placexpos = toolheadposx[active_extruder],
                 grabxpos = toolheadposx[tmp_extruder];
 
     /**
      * 1. Move to switch position of current toolhead
      * 2. Release and place toolhead in the dock
      * 3. Move to the new toolhead
      * 4. Grab the new toolhead and move to security position
      */
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("Starting Toolhead change", current_position);
@@ -575,21 +573,152 @@ inline void fast_line_to_current(const AxisEnum fr_axis) {
     safe_delay(100);
 
     current_position[Y_AXIS] += SWITCHING_TOOLHEAD_Y_CLEAR;
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move back Y clear", current_position);
 
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS], active_extruder); // move away from docked toolhead
     planner.synchronize();
   }
 
-#endif // MAGNETIC_SWITCHING_TOOLHEAD
+#elif ENABLED(ELECTROMAGNETIC_SWITCHING_TOOLHEAD)
+
+  inline void est_activate_solenoid()   { OUT_WRITE(SOL0_PIN, HIGH); }
+  inline void est_deactivate_solenoid() { OUT_WRITE(SOL0_PIN, LOW); }
+  void est_init() { est_activate_solenoid(); }
+
+  inline void electromagnetic_switching_toolhead(const uint8_t tmp_extruder, bool no_move) {
+    if (no_move) return;
+
+    constexpr float toolheadposx[] = SWITCHING_TOOLHEAD_X_POS;
+    const float placexpos = toolheadposx[active_extruder],
+                grabxpos = toolheadposx[tmp_extruder];
+
+    /**
+     * 1. Raise Z-Axis to give enough clearance
+     * 2. Move to position near active extruder parking
+     * 3. Move gently to park position of active extruder
+     * 4. Disengage magnetic field, wait for delay
+     * 5. Leave extruder and move to position near new extruder parking
+     * 6. Move gently to park position of new extruder
+     * 7. Engage magnetic field for new extruder parking
+     * 8. Unpark extruder
+     * 9. Apply Z hotend offset to current position
+     */
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) DEBUG_POS("Starting Autopark", current_position);
+    #endif
+
+    // 1. Raise Z-Axis to give enough clearance
+
+    current_position[Z_AXIS] += SWITCHING_TOOLHEAD_Z_HOP;
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) DEBUG_POS("(1) Raise Z-Axis ", current_position);
+    #endif
+    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Z_AXIS], active_extruder);
+
+    // 2. Move to position near active extruder parking
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) {
+        planner.synchronize();
+        SERIAL_ECHOLNPAIR("(2) Move near active extruder parking", active_extruder);
+        DEBUG_POS("Moving ParkPos", current_position);
+      }
+    #endif
+    current_position[X_AXIS] = placexpos + hotend_offset[X_AXIS][active_extruder];
+    current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_CLEAR + hotend_offset[Y_AXIS][active_extruder];
+    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
+
+    // 3. Move gently to park position of active extruder
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) {
+        planner.synchronize();
+        SERIAL_ECHOLNPAIR("(3) Move gently to park position of active extruder", active_extruder);
+        DEBUG_POS("Moving ParkPos", current_position);
+      }
+    #endif
+
+    current_position[Y_AXIS] -= SWITCHING_TOOLHEAD_Y_CLEAR;
+    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS] * 0.5, active_extruder);
+
+    // 4. Disengage magnetic field, wait for delay
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(4) Disengage magnet");
+    #endif
+
+    planner.synchronize();
+    est_deactivate_solenoid();
+
+    // 5. Leave extruder and move to position near new extruder parking
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) {
+        SERIAL_ECHOLNPGM("(5) Move near new extruder parking");
+        DEBUG_POS("Moving ParkPos", current_position);
+      }
+    #endif
+
+    current_position[Y_AXIS] += SWITCHING_TOOLHEAD_Y_CLEAR;
+    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS] * 0.5f, active_extruder);
+
+    current_position[X_AXIS] = grabxpos + hotend_offset[X_AXIS][active_extruder];
+    current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_CLEAR  + hotend_offset[Y_AXIS][active_extruder];
+    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
+
+    // 6. Move gently to park position of new extruder
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) {
+        planner.synchronize();
+        SERIAL_ECHOLNPGM("(6) Move near new extruder");
+      }
+    #endif
+
+    current_position[Y_AXIS] -= SWITCHING_TOOLHEAD_Y_CLEAR;
+    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS] * 0.5f, active_extruder);
+
+    // 7. Engage magnetic field for new extruder parking
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(7) Engage magnetic field");
+    #endif
+
+    planner.synchronize();
+    est_activate_solenoid();
+
+    // 8. Unpark extruder
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(8) Unpark extruder");
+    #endif
+
+    current_position[Y_AXIS] += SWITCHING_TOOLHEAD_Y_CLEAR;
+
+    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS] * 0.5f, active_extruder);
+
+    // 9. Apply Z hotend offset to current position
+
+    current_position[Z_AXIS] += hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) {
+        planner.synchronize();
+        DEBUG_POS("(9) Applying Z-offset", current_position);
+      }
+    #endif
+  }
+
+#endif // ELECTROMAGNETIC_SWITCHING_TOOLHEAD
 
 inline void invalid_extruder_error(const uint8_t e) {
   SERIAL_ECHO_START();
   SERIAL_CHAR('T'); SERIAL_ECHO(int(e));
   SERIAL_CHAR(' '); SERIAL_ECHOLNPGM(MSG_INVALID_EXTRUDER);
 }
 
 #if ENABLED(DUAL_X_CARRIAGE)
 
   inline void dualx_tool_change(const uint8_t tmp_extruder, bool &no_move) {
@@ -793,29 +922,31 @@ void tool_change(const uint8_t tmp_extruder, bool no_move/*=false*/) {
           const float xdiff = hotend_offset[X_AXIS][tmp_extruder] - hotend_offset[X_AXIS][active_extruder];
         #endif
         const float ydiff = hotend_offset[Y_AXIS][tmp_extruder] - hotend_offset[Y_AXIS][active_extruder],
                     zdiff = hotend_offset[Z_AXIS][tmp_extruder] - hotend_offset[Z_AXIS][active_extruder];
       #else
         constexpr float xdiff = 0, ydiff = 0, zdiff = 0;
       #endif
 
       #if ENABLED(DUAL_X_CARRIAGE)
         dualx_tool_change(tmp_extruder, no_move);
-      #elif ENABLED(PARKING_EXTRUDER) // Dual Parking extruder
+      #elif ENABLED(PARKING_EXTRUDER)                                   // Dual Parking extruder
         parking_extruder_tool_change(tmp_extruder, no_move);
-      #elif ENABLED(MAGNETIC_PARKING_EXTRUDER) // Magnetic Parking extruder
+      #elif ENABLED(MAGNETIC_PARKING_EXTRUDER)                          // Magnetic Parking extruder
         magnetic_parking_extruder_tool_change(tmp_extruder);
-      #elif ENABLED(SWITCHING_TOOLHEAD) // Switching Toolhead
+      #elif ENABLED(SWITCHING_TOOLHEAD)                                 // Switching Toolhead
         switching_toolhead_tool_change(tmp_extruder, no_move);
-      #elif ENABLED(MAGNETIC_SWITCHING_TOOLHEAD) // Magnetic Switching Toolhead
+      #elif ENABLED(MAGNETIC_SWITCHING_TOOLHEAD)                        // Magnetic Switching Toolhead
         magnetic_switching_toolhead_tool_change(tmp_extruder, no_move);
-      #elif ENABLED(SWITCHING_NOZZLE) && !SWITCHING_NOZZLE_TWO_SERVOS
+      #elif ENABLED(ELECTROMAGNETIC_SWITCHING_TOOLHEAD)                 // Magnetic Switching ToolChanger
+        electromagnetic_switching_toolhead(tmp_extruder, no_move);
+      #elif ENABLED(SWITCHING_NOZZLE) && !SWITCHING_NOZZLE_TWO_SERVOS   // Switching Nozzle (single servo)
         // Raise by a configured distance to avoid workpiece, except with
         // SWITCHING_NOZZLE_TWO_SERVOS, as both nozzles will lift instead.
         current_position[Z_AXIS] += MAX(-zdiff, 0.0) + toolchange_settings.z_raise;
         #if HAS_SOFTWARE_ENDSTOPS
           NOMORE(current_position[Z_AXIS], soft_endstop[Z_AXIS].max);
         #endif
         if (!no_move) fast_line_to_current(Z_AXIS);
         move_nozzle_servo(tmp_extruder);
       #endif
 

commit 93cd66ac1146603e8a9911fceb3c63f4351f4d8e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 23:57:50 2019 -0500

    Tweaky change from (C) to (c)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index d85d887d81..9ab6db9211 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -1,16 +1,16 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

commit aa0383a83b7bc45b86753ef9f5adb41da09c76df
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Jun 23 21:00:48 2019 -0400

    Enhance IDEX toolchange auto-return w/ no park, full control (#14117)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index ceb01bfbbc..d85d887d81 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -358,21 +358,21 @@ inline void fast_line_to_current(const AxisEnum fr_axis) {
       #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
         pe_activate_solenoid(active_extruder); // Just save power for inverted magnets
       #endif
     }
   }
 
 #endif // PARKING_EXTRUDER
 
 #if ENABLED(SWITCHING_TOOLHEAD)
 
-  inline void switching_toolhead_tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
+  inline void switching_toolhead_tool_change(const uint8_t tmp_extruder, bool no_move/*=false*/) {
     if (no_move) return;
 
     constexpr uint16_t angles[2] = SWITCHING_TOOLHEAD_SERVO_ANGLES;
 
     const float toolheadposx[] = SWITCHING_TOOLHEAD_X_POS,
                 placexpos = toolheadposx[active_extruder],
                 grabxpos = toolheadposx[tmp_extruder];
 
     /**
      * 1. Move to switch position of current toolhead
@@ -462,21 +462,21 @@ inline void fast_line_to_current(const AxisEnum fr_axis) {
     fast_line_to_current(Y_AXIS); // move away from docked toolhead
     planner.synchronize();
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Toolhead change done.");
   }
 
 #endif // SWITCHING_TOOLHEAD
 
 #if ENABLED(MAGNETIC_SWITCHING_TOOLHEAD)
 
-  inline void magnetic_switching_toolhead_tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
+  inline void magnetic_switching_toolhead_tool_change(const uint8_t tmp_extruder, bool no_move/*=false*/) {
     if (no_move) return;
 
     const float toolheadposx[] = SWITCHING_TOOLHEAD_X_POS,
                 placexpos = toolheadposx[active_extruder],
                 grabxpos = toolheadposx[tmp_extruder];
 
     /**
      * 1. Move to switch position of current toolhead
      * 2. Release and place toolhead in the dock
      * 3. Move to the new toolhead
@@ -646,47 +646,47 @@ inline void invalid_extruder_error(const uint8_t e) {
       DEBUG_POS("New extruder (parked)", current_position);
     }
   }
 
 #endif // DUAL_X_CARRIAGE
 
 /**
  * Perform a tool-change, which may result in moving the
  * previous tool out of the way and the new tool into place.
  */
-void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
+void tool_change(const uint8_t tmp_extruder, bool no_move/*=false*/) {
 
   #if ENABLED(MAGNETIC_SWITCHING_TOOLHEAD)
     if (tmp_extruder == active_extruder) return;
   #endif
 
   #if ENABLED(MIXING_EXTRUDER)
 
-    UNUSED(fr_mm_s); UNUSED(no_move);
+    UNUSED(no_move);
 
     if (tmp_extruder >= MIXING_VIRTUAL_TOOLS)
       return invalid_extruder_error(tmp_extruder);
 
     #if MIXING_VIRTUAL_TOOLS > 1
       // T0-Tnnn: Switch virtual tool by changing the index to the mix
       mixer.T(tmp_extruder);
     #endif
 
   #elif ENABLED(PRUSA_MMU2)
 
-    UNUSED(fr_mm_s); UNUSED(no_move);
+    UNUSED(no_move);
 
     mmu2.tool_change(tmp_extruder);
 
   #elif EXTRUDERS < 2
 
-    UNUSED(fr_mm_s); UNUSED(no_move);
+    UNUSED(no_move);
 
     if (tmp_extruder) invalid_extruder_error(tmp_extruder);
     return;
 
   #else // EXTRUDERS > 1
 
     planner.synchronize();
 
     #if ENABLED(DUAL_X_CARRIAGE)  // Only T0 allowed if the Printer is in DXC_DUPLICATION_MODE or DXC_MIRRORED_MODE
       if (tmp_extruder != 0 && dxc_is_duplicating())
@@ -695,122 +695,126 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
 
     #if HAS_LEVELING
       // Set current position to the physical position
       const bool leveling_was_active = planner.leveling_active;
       set_bed_leveling_enabled(false);
     #endif
 
     if (tmp_extruder >= EXTRUDERS)
       return invalid_extruder_error(tmp_extruder);
 
-    if (!no_move && (!all_axes_homed()
-      #if ENABLED(DUAL_X_CARRIAGE)
-        || dual_x_carriage_mode == DXC_FULL_CONTROL_MODE
-      #endif
-    )) {
+    if (!no_move && !all_axes_homed()) {
       no_move = true;
-      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("No move on toolchange");
+      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("No move (not homed)");
     }
 
     #if HAS_LCD_MENU
       ui.return_to_status();
     #endif
 
+    #if ENABLED(DUAL_X_CARRIAGE)
+      const bool idex_full_control = dual_x_carriage_mode == DXC_FULL_CONTROL_MODE;
+    #else
+      constexpr bool idex_full_control = false;
+    #endif
+
+    const bool can_move_away = !no_move && !idex_full_control;
+
     #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
-      const bool should_swap = !no_move && toolchange_settings.swap_length;
+      const bool should_swap = can_move_away && toolchange_settings.swap_length;
       #if ENABLED(PREVENT_COLD_EXTRUSION)
         const bool too_cold = !DEBUGGING(DRYRUN) && (thermalManager.targetTooColdToExtrude(active_extruder) || thermalManager.targetTooColdToExtrude(tmp_extruder));
       #else
         constexpr bool too_cold = false;
       #endif
       if (should_swap) {
         if (too_cold) {
           SERIAL_ECHO_MSG(MSG_ERR_HOTEND_TOO_COLD);
           #if ENABLED(SINGLENOZZLE)
             active_extruder = tmp_extruder;
             return;
           #endif
         }
         else {
           #if ENABLED(ADVANCED_PAUSE_FEATURE)
             do_pause_e_move(-toolchange_settings.swap_length, MMM_TO_MMS(toolchange_settings.retract_speed));
           #else
             current_position[E_AXIS] -= toolchange_settings.swap_length / planner.e_factor[active_extruder];
             planner.buffer_line(current_position, MMM_TO_MMS(toolchange_settings.retract_speed), active_extruder);
+            planner.synchronize();
           #endif
         }
       }
     #endif // TOOLCHANGE_FILAMENT_SWAP
 
     if (tmp_extruder != active_extruder) {
 
       #if SWITCHING_NOZZLE_TWO_SERVOS
         raise_nozzle(active_extruder);
       #endif
 
-      const float old_feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : feedrate_mm_s;
-      feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
+      REMEMBER(fr, feedrate_mm_s, XY_PROBE_FEEDRATE_MM_S);
 
       #if HAS_SOFTWARE_ENDSTOPS
         #if HAS_HOTEND_OFFSET
           #define _EXT_ARGS , active_extruder, tmp_extruder
         #else
           #define _EXT_ARGS
         #endif
         update_software_endstops(X_AXIS _EXT_ARGS);
         #if DISABLED(DUAL_X_CARRIAGE)
           update_software_endstops(Y_AXIS _EXT_ARGS);
           update_software_endstops(Z_AXIS _EXT_ARGS);
         #endif
       #endif
 
       set_destination_from_current();
 
-      if (!no_move) {
-        #if DISABLED(SWITCHING_NOZZLE)
+      #if DISABLED(SWITCHING_NOZZLE)
+        if (can_move_away) {
           // Do a small lift to avoid the workpiece in the move back (below)
           current_position[Z_AXIS] += toolchange_settings.z_raise;
           #if HAS_SOFTWARE_ENDSTOPS
             NOMORE(current_position[Z_AXIS], soft_endstop[Z_AXIS].max);
           #endif
           fast_line_to_current(Z_AXIS);
           #if ENABLED(TOOLCHANGE_PARK)
             current_position[X_AXIS] = toolchange_settings.change_point.x;
             current_position[Y_AXIS] = toolchange_settings.change_point.y;
           #endif
           planner.buffer_line(current_position, feedrate_mm_s, active_extruder);
-        #endif
-        planner.synchronize();
-      }
+          planner.synchronize();
+        }
+      #endif
 
       #if HAS_HOTEND_OFFSET
         #if ENABLED(DUAL_X_CARRIAGE)
           constexpr float xdiff = 0;
         #else
           const float xdiff = hotend_offset[X_AXIS][tmp_extruder] - hotend_offset[X_AXIS][active_extruder];
         #endif
         const float ydiff = hotend_offset[Y_AXIS][tmp_extruder] - hotend_offset[Y_AXIS][active_extruder],
                     zdiff = hotend_offset[Z_AXIS][tmp_extruder] - hotend_offset[Z_AXIS][active_extruder];
       #else
         constexpr float xdiff = 0, ydiff = 0, zdiff = 0;
       #endif
 
       #if ENABLED(DUAL_X_CARRIAGE)
         dualx_tool_change(tmp_extruder, no_move);
       #elif ENABLED(PARKING_EXTRUDER) // Dual Parking extruder
         parking_extruder_tool_change(tmp_extruder, no_move);
       #elif ENABLED(MAGNETIC_PARKING_EXTRUDER) // Magnetic Parking extruder
         magnetic_parking_extruder_tool_change(tmp_extruder);
       #elif ENABLED(SWITCHING_TOOLHEAD) // Switching Toolhead
-        switching_toolhead_tool_change(tmp_extruder, fr_mm_s, no_move);
+        switching_toolhead_tool_change(tmp_extruder, no_move);
       #elif ENABLED(MAGNETIC_SWITCHING_TOOLHEAD) // Magnetic Switching Toolhead
-        magnetic_switching_toolhead_tool_change(tmp_extruder, fr_mm_s, no_move);
+        magnetic_switching_toolhead_tool_change(tmp_extruder, no_move);
       #elif ENABLED(SWITCHING_NOZZLE) && !SWITCHING_NOZZLE_TWO_SERVOS
         // Raise by a configured distance to avoid workpiece, except with
         // SWITCHING_NOZZLE_TWO_SERVOS, as both nozzles will lift instead.
         current_position[Z_AXIS] += MAX(-zdiff, 0.0) + toolchange_settings.z_raise;
         #if HAS_SOFTWARE_ENDSTOPS
           NOMORE(current_position[Z_AXIS], soft_endstop[Z_AXIS].max);
         #endif
         if (!no_move) fast_line_to_current(Z_AXIS);
         move_nozzle_servo(tmp_extruder);
       #endif
@@ -830,21 +834,20 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
 
       #if ENABLED(DELTA)
         //LOOP_XYZ(i) update_software_endstops(i); // or modify the constrain function
         const bool safe_to_move = current_position[Z_AXIS] < delta_clip_start_height - 1;
       #else
         constexpr bool safe_to_move = true;
       #endif
 
       // Return to position and lower again
       if (safe_to_move && !no_move && IsRunning()) {
-        if (DEBUGGING(LEVELING)) DEBUG_POS("Move back", destination);
 
         #if ENABLED(SINGLENOZZLE)
           #if FAN_COUNT > 0
             singlenozzle_fan_speed[active_extruder] = thermalManager.fan_speed[0];
             thermalManager.fan_speed[0] = singlenozzle_fan_speed[tmp_extruder];
           #endif
 
           singlenozzle_temp[active_extruder] = thermalManager.temp_hotend[0].target;
           if (singlenozzle_temp[tmp_extruder] && singlenozzle_temp[tmp_extruder] != singlenozzle_temp[active_extruder]) {
             thermalManager.setTargetHotend(singlenozzle_temp[tmp_extruder], 0);
@@ -877,27 +880,37 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
           // If the original position is within tool store area, go to X origin at once
           if (destination[Y_AXIS] < SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_CLEAR) {
             current_position[X_AXIS] = 0;
             planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
             planner.synchronize();
           }
         #else
           apply_motion_limits(destination);
         #endif
 
-        // Move back to the original (or tweaked) position
-        do_blocking_move_to(destination);
+        // Should the nozzle move back to the old position?
+        if (can_move_away) {
+          #if ENABLED(TOOLCHANGE_NO_RETURN)
+            // Just move back down
+            if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Move back Z only");
+            do_blocking_move_to_z(destination[Z_AXIS], planner.settings.max_feedrate_mm_s[Z_AXIS]);
+          #else
+            // Move back to the original (or adjusted) position
+            if (DEBUGGING(LEVELING)) DEBUG_POS("Move back", destination);
+            do_blocking_move_to(destination);
+          #endif
+        }
+        else if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Move back skipped");
 
         #if ENABLED(DUAL_X_CARRIAGE)
           active_extruder_parked = false;
         #endif
-        feedrate_mm_s = old_feedrate_mm_s;
       }
       #if ENABLED(SWITCHING_NOZZLE)
         else {
           // Move back down. (Including when the new tool is higher.)
           do_blocking_move_to_z(destination[Z_AXIS], planner.settings.max_feedrate_mm_s[Z_AXIS]);
         }
       #endif
 
       #if ENABLED(PRUSA_MMU2)
         mmu2.tool_change(tmp_extruder);

commit a3f034b95eb42009f9bc744816ec53b9eb2bc1ef
Author: mikeshub <mikesbaker@gmail.com>
Date:   Mon Jun 10 18:01:42 2019 -0500

    FFCP updates. Update XY soft endstops on tool_change (#14125)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 3b97cb60c1..ceb01bfbbc 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -743,22 +743,31 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
 
     if (tmp_extruder != active_extruder) {
 
       #if SWITCHING_NOZZLE_TWO_SERVOS
         raise_nozzle(active_extruder);
       #endif
 
       const float old_feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : feedrate_mm_s;
       feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
 
-      #if HAS_SOFTWARE_ENDSTOPS && ENABLED(DUAL_X_CARRIAGE)
-        update_software_endstops(X_AXIS, active_extruder, tmp_extruder);
+      #if HAS_SOFTWARE_ENDSTOPS
+        #if HAS_HOTEND_OFFSET
+          #define _EXT_ARGS , active_extruder, tmp_extruder
+        #else
+          #define _EXT_ARGS
+        #endif
+        update_software_endstops(X_AXIS _EXT_ARGS);
+        #if DISABLED(DUAL_X_CARRIAGE)
+          update_software_endstops(Y_AXIS _EXT_ARGS);
+          update_software_endstops(Z_AXIS _EXT_ARGS);
+        #endif
       #endif
 
       set_destination_from_current();
 
       if (!no_move) {
         #if DISABLED(SWITCHING_NOZZLE)
           // Do a small lift to avoid the workpiece in the move back (below)
           current_position[Z_AXIS] += toolchange_settings.z_raise;
           #if HAS_SOFTWARE_ENDSTOPS
             NOMORE(current_position[Z_AXIS], soft_endstop[Z_AXIS].max);

commit c6632925e39c883cc4163be2e4135f134cd442fd
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue Apr 23 16:20:59 2019 -0400

    Force no move on IDEX full control mode (#13797)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index aa9e7ed873..3b97cb60c1 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -695,21 +695,25 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
 
     #if HAS_LEVELING
       // Set current position to the physical position
       const bool leveling_was_active = planner.leveling_active;
       set_bed_leveling_enabled(false);
     #endif
 
     if (tmp_extruder >= EXTRUDERS)
       return invalid_extruder_error(tmp_extruder);
 
-    if (!no_move && !all_axes_homed()) {
+    if (!no_move && (!all_axes_homed()
+      #if ENABLED(DUAL_X_CARRIAGE)
+        || dual_x_carriage_mode == DXC_FULL_CONTROL_MODE
+      #endif
+    )) {
       no_move = true;
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("No move on toolchange");
     }
 
     #if HAS_LCD_MENU
       ui.return_to_status();
     #endif
 
     #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
       const bool should_swap = !no_move && toolchange_settings.swap_length;

commit 78d7349fd7df2b0f559c068e20c43d67d3c25072
Author: chai-md <48555545+chai-md@users.noreply.github.com>
Date:   Mon Apr 22 11:06:46 2019 +0900

    Remove extra Z raises in tool change (#13782)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 9108a23ab4..aa9e7ed873 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -273,96 +273,86 @@ inline void fast_line_to_current(const AxisEnum fr_axis) {
       #if HAS_HOTEND_OFFSET
         const float x_offset = hotend_offset[X_AXIS][active_extruder];
       #else
         constexpr float x_offset = 0;
       #endif
 
       const float midpos = (parkingposx[0] + parkingposx[1]) * 0.5 + x_offset,
                   grabpos = parkingposx[tmp_extruder] + (tmp_extruder ? PARKING_EXTRUDER_GRAB_DISTANCE : -(PARKING_EXTRUDER_GRAB_DISTANCE)) + x_offset;
 
       /**
-       * 1. Raise Z-Axis to give enough clearance
-       * 2. Move to park position of old extruder
-       * 3. Disengage magnetic field, wait for delay
-       * 4. Move near new extruder
-       * 5. Engage magnetic field for new extruder
-       * 6. Move to parking incl. offset of new extruder
-       * 7. Lower Z-Axis
+       * 1. Move to park position of old extruder
+       * 2. Disengage magnetic field, wait for delay
+       * 3. Move near new extruder
+       * 4. Engage magnetic field for new extruder
+       * 5. Move to parking incl. offset of new extruder
+       * 6. Lower Z-Axis
        */
 
       // STEP 1
 
       if (DEBUGGING(LEVELING)) DEBUG_POS("Start Autopark", current_position);
 
-      current_position[Z_AXIS] += toolchange_settings.z_raise;
-
-      if (DEBUGGING(LEVELING)) DEBUG_POS("(1) Raise Z-Axis", current_position);
-
-      fast_line_to_current(Z_AXIS);
-      planner.synchronize();
-
-      // STEP 2
-
       current_position[X_AXIS] = parkingposx[active_extruder] + x_offset;
 
       if (DEBUGGING(LEVELING)) {
-        DEBUG_ECHOLNPAIR("(2) Park extruder ", int(active_extruder));
+        DEBUG_ECHOLNPAIR("(1) Park extruder ", int(active_extruder));
         DEBUG_POS("Moving ParkPos", current_position);
       }
 
       fast_line_to_current(X_AXIS);
       planner.synchronize();
 
-      // STEP 3
+      // STEP 2
 
-      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(3) Disengage magnet ");
+      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(2) Disengage magnet ");
 
       pe_deactivate_solenoid(active_extruder);
 
-      // STEP 4
+      // STEP 3
 
-      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(4) Move to position near new extruder");
+      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(3) Move to position near new extruder");
 
       current_position[X_AXIS] += active_extruder ? -10 : 10; // move 10mm away from parked extruder
 
       if (DEBUGGING(LEVELING)) DEBUG_POS("Move away from parked extruder", current_position);
 
       fast_line_to_current(X_AXIS);
       planner.synchronize();
 
-      // STEP 5
-      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(5) Engage magnetic field");
+      // STEP 4
+      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(4) Engage magnetic field");
 
       #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
         pe_activate_solenoid(active_extruder); //just save power for inverted magnets
       #endif
 
       pe_activate_solenoid(tmp_extruder);
 
-      // STEP 6
+      // STEP 5
 
       current_position[X_AXIS] = grabpos + (tmp_extruder ? -10 : 10);
       fast_line_to_current(X_AXIS);
       current_position[X_AXIS] = grabpos;
-      if (DEBUGGING(LEVELING)) DEBUG_POS("(6) Unpark extruder", current_position);
+      if (DEBUGGING(LEVELING)) DEBUG_POS("(5) Unpark extruder", current_position);
       planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS] * 0.5, active_extruder);
       planner.synchronize();
 
-      // STEP 7
+      // STEP 6
 
       current_position[X_AXIS] = midpos
         #if HAS_HOTEND_OFFSET
           - hotend_offset[X_AXIS][tmp_extruder]
         #endif
       ;
 
-      if (DEBUGGING(LEVELING)) DEBUG_POS("(7) Move midway between hotends", current_position);
+      if (DEBUGGING(LEVELING)) DEBUG_POS("(6) Move midway between hotends", current_position);
 
       fast_line_to_current(X_AXIS);
       planner.synchronize();
 
       DEBUG_ECHOLNPGM("Autopark done.");
     }
     else { // nomove == true
       // Only engage magnetic field for new extruder
       pe_activate_solenoid(tmp_extruder);
       #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
@@ -378,98 +368,88 @@ inline void fast_line_to_current(const AxisEnum fr_axis) {
   inline void switching_toolhead_tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
     if (no_move) return;
 
     constexpr uint16_t angles[2] = SWITCHING_TOOLHEAD_SERVO_ANGLES;
 
     const float toolheadposx[] = SWITCHING_TOOLHEAD_X_POS,
                 placexpos = toolheadposx[active_extruder],
                 grabxpos = toolheadposx[tmp_extruder];
 
     /**
-     * 1. Raise Z to give enough clearance
-     * 2. Move to switch position of current toolhead
-     * 3. Unlock tool and drop it in the dock
-     * 4. Move to the new toolhead
-     * 5. Grab and lock the new toolhead
+     * 1. Move to switch position of current toolhead
+     * 2. Unlock tool and drop it in the dock
+     * 3. Move to the new toolhead
+     * 4. Grab and lock the new toolhead
      */
 
-    // 1. Raise Z to give enough clearance
+    // 1. Move to switch position of current toolhead
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("Starting Toolhead change", current_position);
 
-    current_position[Z_AXIS] += toolchange_settings.z_raise;
-
-    if (DEBUGGING(LEVELING)) DEBUG_POS("(1) Raise Z-Axis", current_position);
-
-    fast_line_to_current(Z_AXIS);
-    planner.synchronize();
-
-    // 2. Move to switch position of current toolhead
-
     current_position[X_AXIS] = placexpos;
 
     if (DEBUGGING(LEVELING)) {
-      DEBUG_ECHOLNPAIR("(2) Place old tool ", int(active_extruder));
+      DEBUG_ECHOLNPAIR("(1) Place old tool ", int(active_extruder));
       DEBUG_POS("Move X SwitchPos", current_position);
     }
 
     fast_line_to_current(X_AXIS);
     planner.synchronize();
 
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS - SWITCHING_TOOLHEAD_Y_SECURITY;
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos + Security", current_position);
 
     fast_line_to_current(Y_AXIS);
     planner.synchronize();
 
-    // 3. Unlock tool and drop it in the dock
+    // 2. Unlock tool and drop it in the dock
 
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(3) Unlock and Place Toolhead");
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(2) Unlock and Place Toolhead");
 
     MOVE_SERVO(SWITCHING_TOOLHEAD_SERVO_NR, angles[1]);
     safe_delay(500);
 
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS;
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos", current_position);
 
     planner.buffer_line(current_position,(planner.settings.max_feedrate_mm_s[Y_AXIS] * 0.5), active_extruder);
     planner.synchronize();
     safe_delay(200);
     current_position[Y_AXIS] -= SWITCHING_TOOLHEAD_Y_CLEAR;
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move back Y clear", current_position);
 
     fast_line_to_current(Y_AXIS); // move away from docked toolhead
     planner.synchronize();
 
-    // 4. Move to the new toolhead
+    // 3. Move to the new toolhead
 
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(4) Move to new toolhead position");
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(3) Move to new toolhead position");
 
     current_position[X_AXIS] = grabxpos;
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move to new toolhead X", current_position);
 
     fast_line_to_current(X_AXIS);
     planner.synchronize();
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS - SWITCHING_TOOLHEAD_Y_SECURITY;
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos + Security", current_position);
 
     fast_line_to_current(Y_AXIS);
     planner.synchronize();
 
-    // 5. Grab and lock the new toolhead
+    // 4. Grab and lock the new toolhead
 
-    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(5) Grab and lock new toolhead ");
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(4) Grab and lock new toolhead ");
 
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS;
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos", current_position);
 
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS] * 0.5, active_extruder);
     planner.synchronize();
 
     safe_delay(200);
     MOVE_SERVO(SWITCHING_TOOLHEAD_SERVO_NR, angles[0]);
@@ -490,44 +470,34 @@ inline void fast_line_to_current(const AxisEnum fr_axis) {
 #if ENABLED(MAGNETIC_SWITCHING_TOOLHEAD)
 
   inline void magnetic_switching_toolhead_tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
     if (no_move) return;
 
     const float toolheadposx[] = SWITCHING_TOOLHEAD_X_POS,
                 placexpos = toolheadposx[active_extruder],
                 grabxpos = toolheadposx[tmp_extruder];
 
     /**
-     * 1. Raise Z to give enough clearance
-     * 2. Move to switch position of current toolhead
-     * 3. Release and place toolhead in the dock
-     * 4. Move to the new toolhead
-     * 5. Grab the new toolhead and move to security position
+     * 1. Move to switch position of current toolhead
+     * 2. Release and place toolhead in the dock
+     * 3. Move to the new toolhead
+     * 4. Grab the new toolhead and move to security position
      */
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("Starting Toolhead change", current_position);
 
-    // 1. Raise Z to give enough clearance
-
-    current_position[Z_AXIS] += toolchange_settings.z_raise;
-
-    if (DEBUGGING(LEVELING)) DEBUG_POS("(1) Raise Z-Axis", current_position);
-
-    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Z_AXIS], active_extruder);
-    planner.synchronize();
-
-    // 2. Move to switch position current toolhead
+    // 1. Move to switch position current toolhead
 
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_CLEAR;
 
     if (DEBUGGING(LEVELING)) {
-      SERIAL_ECHOLNPAIR("(2) Place old tool ", int(active_extruder));
+      SERIAL_ECHOLNPAIR("(1) Place old tool ", int(active_extruder));
       DEBUG_POS("Move Y SwitchPos + Security", current_position);
     }
 
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS], active_extruder);
     planner.synchronize();
 
     current_position[X_AXIS] = placexpos + SWITCHING_TOOLHEAD_X_SECURITY;
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move X SwitchPos + Security", current_position);
 
@@ -541,52 +511,52 @@ inline void fast_line_to_current(const AxisEnum fr_axis) {
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS], active_extruder);
     planner.synchronize();
 
     current_position[X_AXIS] = placexpos;
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move X SwitchPos", current_position);
 
     planner.buffer_line(current_position, (planner.settings.max_feedrate_mm_s[X_AXIS] * 0.25), active_extruder);
     planner.synchronize();
 
-    // 3. Release and place toolhead in the dock
+    // 2. Release and place toolhead in the dock
 
-    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(3) Release and Place Toolhead");
+    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(2) Release and Place Toolhead");
 
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_RELEASE;
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos + Release", current_position);
 
     planner.buffer_line(current_position, (planner.settings.max_feedrate_mm_s[Y_AXIS] * 0.1), active_extruder);
     planner.synchronize();
 
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_SECURITY;
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos + Security", current_position);
 
     planner.buffer_line(current_position, (planner.settings.max_feedrate_mm_s[Y_AXIS]), active_extruder);
     planner.synchronize();
 
-    // 4. Move to new toolhead position
+    // 3. Move to new toolhead position
 
-    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(4) Move to new toolhead position");
+    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(3) Move to new toolhead position");
 
     current_position[X_AXIS] = grabxpos;
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move to new toolhead X", current_position);
 
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
     planner.synchronize();
 
-    // 5. Grab the new toolhead and move to security position
+    // 4. Grab the new toolhead and move to security position
 
-    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(5) Grab new toolhead and move to security position");
+    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(4) Grab new toolhead and move to security position");
 
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_RELEASE;
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos + Release", current_position);
 
     planner.buffer_line(current_position, (planner.settings.max_feedrate_mm_s[Y_AXIS]), active_extruder);
     planner.synchronize();
 
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS;
 
@@ -778,28 +748,29 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
 
       #if HAS_SOFTWARE_ENDSTOPS && ENABLED(DUAL_X_CARRIAGE)
         update_software_endstops(X_AXIS, active_extruder, tmp_extruder);
       #endif
 
       set_destination_from_current();
 
       if (!no_move) {
         #if DISABLED(SWITCHING_NOZZLE)
           // Do a small lift to avoid the workpiece in the move back (below)
-          #if ENABLED(TOOLCHANGE_PARK)
-            current_position[X_AXIS] = toolchange_settings.change_point.x;
-            current_position[Y_AXIS] = toolchange_settings.change_point.y;
-          #endif
           current_position[Z_AXIS] += toolchange_settings.z_raise;
           #if HAS_SOFTWARE_ENDSTOPS
             NOMORE(current_position[Z_AXIS], soft_endstop[Z_AXIS].max);
           #endif
+          fast_line_to_current(Z_AXIS);
+          #if ENABLED(TOOLCHANGE_PARK)
+            current_position[X_AXIS] = toolchange_settings.change_point.x;
+            current_position[Y_AXIS] = toolchange_settings.change_point.y;
+          #endif
           planner.buffer_line(current_position, feedrate_mm_s, active_extruder);
         #endif
         planner.synchronize();
       }
 
       #if HAS_HOTEND_OFFSET
         #if ENABLED(DUAL_X_CARRIAGE)
           constexpr float xdiff = 0;
         #else
           const float xdiff = hotend_offset[X_AXIS][tmp_extruder] - hotend_offset[X_AXIS][active_extruder];
@@ -868,24 +839,24 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
               thermalManager.set_heating_message(0);
             #endif
             (void)thermalManager.wait_for_hotend(0, false);  // Wait for heating or cooling
           }
           active_extruder = tmp_extruder;
         #endif
 
         #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
           if (should_swap && !too_cold) {
             #if ENABLED(ADVANCED_PAUSE_FEATURE)
-              do_pause_e_move(toolchange_settings.swap_length + TOOLCHANGE_FIL_EXTRA_PRIME, toolchange_settings.prime_speed);
+              do_pause_e_move(toolchange_settings.swap_length + TOOLCHANGE_FIL_EXTRA_PRIME, MMM_TO_MMS(toolchange_settings.prime_speed));
             #else
               current_position[E_AXIS] += (toolchange_settings.swap_length + TOOLCHANGE_FIL_EXTRA_PRIME) / planner.e_factor[tmp_extruder];
-              planner.buffer_line(current_position, toolchange_settings.prime_speed, tmp_extruder);
+              planner.buffer_line(current_position, MMM_TO_MMS(toolchange_settings.prime_speed), tmp_extruder);
             #endif
             planner.synchronize();
 
             #if TOOLCHANGE_FIL_EXTRA_PRIME
               planner.set_e_position_mm((destination[E_AXIS] = current_position[E_AXIS] = current_position[E_AXIS] - (TOOLCHANGE_FIL_EXTRA_PRIME)));
             #endif
           }
         #endif
 
         // Prevent a move outside physical bounds

commit 2adc37becc3afcb45c6fd9e507d7d4b88c64c69c
Author: chai-md <48555545+chai-md@users.noreply.github.com>
Date:   Fri Apr 12 03:29:17 2019 +0900

    MAGNETIC_SWITCHING_TOOLHEAD (#13629)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index e0de12d285..9108a23ab4 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -480,20 +480,147 @@ inline void fast_line_to_current(const AxisEnum fr_axis) {
     if (DEBUGGING(LEVELING)) DEBUG_POS("Move back Y clear", current_position);
 
     fast_line_to_current(Y_AXIS); // move away from docked toolhead
     planner.synchronize();
 
     if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Toolhead change done.");
   }
 
 #endif // SWITCHING_TOOLHEAD
 
+#if ENABLED(MAGNETIC_SWITCHING_TOOLHEAD)
+
+  inline void magnetic_switching_toolhead_tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
+    if (no_move) return;
+
+    const float toolheadposx[] = SWITCHING_TOOLHEAD_X_POS,
+                placexpos = toolheadposx[active_extruder],
+                grabxpos = toolheadposx[tmp_extruder];
+
+    /**
+     * 1. Raise Z to give enough clearance
+     * 2. Move to switch position of current toolhead
+     * 3. Release and place toolhead in the dock
+     * 4. Move to the new toolhead
+     * 5. Grab the new toolhead and move to security position
+     */
+
+    if (DEBUGGING(LEVELING)) DEBUG_POS("Starting Toolhead change", current_position);
+
+    // 1. Raise Z to give enough clearance
+
+    current_position[Z_AXIS] += toolchange_settings.z_raise;
+
+    if (DEBUGGING(LEVELING)) DEBUG_POS("(1) Raise Z-Axis", current_position);
+
+    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Z_AXIS], active_extruder);
+    planner.synchronize();
+
+    // 2. Move to switch position current toolhead
+
+    current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_CLEAR;
+
+    if (DEBUGGING(LEVELING)) {
+      SERIAL_ECHOLNPAIR("(2) Place old tool ", int(active_extruder));
+      DEBUG_POS("Move Y SwitchPos + Security", current_position);
+    }
+
+    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS], active_extruder);
+    planner.synchronize();
+
+    current_position[X_AXIS] = placexpos + SWITCHING_TOOLHEAD_X_SECURITY;
+
+    if (DEBUGGING(LEVELING)) DEBUG_POS("Move X SwitchPos + Security", current_position);
+
+    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
+    planner.synchronize();
+
+    current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS;
+
+    if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos", current_position);
+
+    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS], active_extruder);
+    planner.synchronize();
+
+    current_position[X_AXIS] = placexpos;
+
+    if (DEBUGGING(LEVELING)) DEBUG_POS("Move X SwitchPos", current_position);
+
+    planner.buffer_line(current_position, (planner.settings.max_feedrate_mm_s[X_AXIS] * 0.25), active_extruder);
+    planner.synchronize();
+
+    // 3. Release and place toolhead in the dock
+
+    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(3) Release and Place Toolhead");
+
+    current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_RELEASE;
+
+    if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos + Release", current_position);
+
+    planner.buffer_line(current_position, (planner.settings.max_feedrate_mm_s[Y_AXIS] * 0.1), active_extruder);
+    planner.synchronize();
+
+    current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_SECURITY;
+
+    if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos + Security", current_position);
+
+    planner.buffer_line(current_position, (planner.settings.max_feedrate_mm_s[Y_AXIS]), active_extruder);
+    planner.synchronize();
+
+    // 4. Move to new toolhead position
+
+    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(4) Move to new toolhead position");
+
+    current_position[X_AXIS] = grabxpos;
+
+    if (DEBUGGING(LEVELING)) DEBUG_POS("Move to new toolhead X", current_position);
+
+    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
+    planner.synchronize();
+
+    // 5. Grab the new toolhead and move to security position
+
+    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(5) Grab new toolhead and move to security position");
+
+    current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_RELEASE;
+
+    if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos + Release", current_position);
+
+    planner.buffer_line(current_position, (planner.settings.max_feedrate_mm_s[Y_AXIS]), active_extruder);
+    planner.synchronize();
+
+    current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS;
+
+    if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos", current_position);
+
+    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS] * 0.2, active_extruder);
+    planner.synchronize();
+    safe_delay(100);
+
+    current_position[X_AXIS] = grabxpos + SWITCHING_TOOLHEAD_X_SECURITY;
+
+    if (DEBUGGING(LEVELING)) DEBUG_POS("Move to new toolhead X + Security", current_position);
+
+    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS] * 0.1, active_extruder);
+    planner.synchronize();
+    safe_delay(100);
+
+    current_position[Y_AXIS] += SWITCHING_TOOLHEAD_Y_CLEAR;
+
+    if (DEBUGGING(LEVELING)) DEBUG_POS("Move back Y clear", current_position);
+
+    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS], active_extruder); // move away from docked toolhead
+    planner.synchronize();
+  }
+
+#endif // MAGNETIC_SWITCHING_TOOLHEAD
+
 inline void invalid_extruder_error(const uint8_t e) {
   SERIAL_ECHO_START();
   SERIAL_CHAR('T'); SERIAL_ECHO(int(e));
   SERIAL_CHAR(' '); SERIAL_ECHOLNPGM(MSG_INVALID_EXTRUDER);
 }
 
 #if ENABLED(DUAL_X_CARRIAGE)
 
   inline void dualx_tool_change(const uint8_t tmp_extruder, bool &no_move) {
     if (DEBUGGING(LEVELING)) {
@@ -550,20 +677,25 @@ inline void invalid_extruder_error(const uint8_t e) {
     }
   }
 
 #endif // DUAL_X_CARRIAGE
 
 /**
  * Perform a tool-change, which may result in moving the
  * previous tool out of the way and the new tool into place.
  */
 void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
+
+  #if ENABLED(MAGNETIC_SWITCHING_TOOLHEAD)
+    if (tmp_extruder == active_extruder) return;
+  #endif
+
   #if ENABLED(MIXING_EXTRUDER)
 
     UNUSED(fr_mm_s); UNUSED(no_move);
 
     if (tmp_extruder >= MIXING_VIRTUAL_TOOLS)
       return invalid_extruder_error(tmp_extruder);
 
     #if MIXING_VIRTUAL_TOOLS > 1
       // T0-Tnnn: Switch virtual tool by changing the index to the mix
       mixer.T(tmp_extruder);
@@ -679,20 +811,22 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
       #endif
 
       #if ENABLED(DUAL_X_CARRIAGE)
         dualx_tool_change(tmp_extruder, no_move);
       #elif ENABLED(PARKING_EXTRUDER) // Dual Parking extruder
         parking_extruder_tool_change(tmp_extruder, no_move);
       #elif ENABLED(MAGNETIC_PARKING_EXTRUDER) // Magnetic Parking extruder
         magnetic_parking_extruder_tool_change(tmp_extruder);
       #elif ENABLED(SWITCHING_TOOLHEAD) // Switching Toolhead
         switching_toolhead_tool_change(tmp_extruder, fr_mm_s, no_move);
+      #elif ENABLED(MAGNETIC_SWITCHING_TOOLHEAD) // Magnetic Switching Toolhead
+        magnetic_switching_toolhead_tool_change(tmp_extruder, fr_mm_s, no_move);
       #elif ENABLED(SWITCHING_NOZZLE) && !SWITCHING_NOZZLE_TWO_SERVOS
         // Raise by a configured distance to avoid workpiece, except with
         // SWITCHING_NOZZLE_TWO_SERVOS, as both nozzles will lift instead.
         current_position[Z_AXIS] += MAX(-zdiff, 0.0) + toolchange_settings.z_raise;
         #if HAS_SOFTWARE_ENDSTOPS
           NOMORE(current_position[Z_AXIS], soft_endstop[Z_AXIS].max);
         #endif
         if (!no_move) fast_line_to_current(Z_AXIS);
         move_nozzle_servo(tmp_extruder);
       #endif
@@ -748,21 +882,30 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
             #endif
             planner.synchronize();
 
             #if TOOLCHANGE_FIL_EXTRA_PRIME
               planner.set_e_position_mm((destination[E_AXIS] = current_position[E_AXIS] = current_position[E_AXIS] - (TOOLCHANGE_FIL_EXTRA_PRIME)));
             #endif
           }
         #endif
 
         // Prevent a move outside physical bounds
-        apply_motion_limits(destination);
+        #if ENABLED(MAGNETIC_SWITCHING_TOOLHEAD)
+          // If the original position is within tool store area, go to X origin at once
+          if (destination[Y_AXIS] < SWITCHING_TOOLHEAD_Y_POS + SWITCHING_TOOLHEAD_Y_CLEAR) {
+            current_position[X_AXIS] = 0;
+            planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
+            planner.synchronize();
+          }
+        #else
+          apply_motion_limits(destination);
+        #endif
 
         // Move back to the original (or tweaked) position
         do_blocking_move_to(destination);
 
         #if ENABLED(DUAL_X_CARRIAGE)
           active_extruder_parked = false;
         #endif
         feedrate_mm_s = old_feedrate_mm_s;
       }
       #if ENABLED(SWITCHING_NOZZLE)

commit 4900c28bf600f86ccbc3943072e9c573a443ecae
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue Apr 9 19:33:40 2019 -0400

    Fix IDEX tool-change, and more (#13614)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index c52f263190..e0de12d285 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -114,21 +114,21 @@
       safe_delay(500);
     }
 
     void lower_nozzle(const uint8_t e) { _move_nozzle_servo(e, 0); }
     void raise_nozzle(const uint8_t e) { _move_nozzle_servo(e, 1); }
 
   #else
 
     void move_nozzle_servo(const uint8_t angle_index) {
       planner.synchronize();
-      MOVE_SERVO(SWITCHING_NOZZLE_SERVO_NR, servo_angles[SWITCHING_NOZZLE_SERVO_NR][e]);
+      MOVE_SERVO(SWITCHING_NOZZLE_SERVO_NR, servo_angles[SWITCHING_NOZZLE_SERVO_NR][angle_index]);
       safe_delay(500);
     }
 
   #endif
 
 #endif // SWITCHING_NOZZLE
 
 inline void fast_line_to_current(const AxisEnum fr_axis) {
   planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[fr_axis], active_extruder);
 }
@@ -512,24 +512,20 @@ inline void invalid_extruder_error(const uint8_t e) {
         && (delayed_move_time || current_position[X_AXIS] != xhome) && ! no_move
     ) {
 
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("MoveX to ", xhome);
 
       // Park old head
       planner.buffer_line(xhome, current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
       planner.synchronize();
     }
 
-    // Apply Y & Z extruder offset (X offset is used as home pos with Dual X)
-    current_position[Y_AXIS] -= hotend_offset[Y_AXIS][active_extruder] - hotend_offset[Y_AXIS][tmp_extruder];
-    current_position[Z_AXIS] -= hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
-
     // Activate the new extruder ahead of calling set_axis_is_at_home!
     active_extruder = tmp_extruder;
 
     // This function resets the max/min values - the current position may be overwritten below.
     set_axis_is_at_home(X_AXIS);
 
     if (DEBUGGING(LEVELING)) DEBUG_POS("New Extruder", current_position);
 
     switch (dual_x_carriage_mode) {
       case DXC_FULL_CONTROL_MODE:
@@ -777,34 +773,20 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
       #endif
 
       #if ENABLED(PRUSA_MMU2)
         mmu2.tool_change(tmp_extruder);
       #endif
 
       #if SWITCHING_NOZZLE_TWO_SERVOS
         lower_nozzle(active_extruder);
       #endif
 
-      #if ENABLED(TOOLCHANGE_FILAMENT_SWAP) && ADVANCED_PAUSE_RESUME_PRIME != 0
-        if (should_swap && !too_cold) {
-          const float resume_eaxis = current_position[E_AXIS];
-          #if ENABLED(ADVANCED_PAUSE_FEATURE)
-            do_pause_e_move(toolchange_settings.swap_length, toolchange_settings.prime_speed);
-          #else
-            current_position[E_AXIS] += (ADVANCED_PAUSE_RESUME_PRIME) / planner.e_factor[active_extruder];
-            planner.buffer_line(current_position, ADVANCED_PAUSE_PURGE_FEEDRATE, active_extruder);
-          #endif
-          planner.synchronize();
-          planner.set_e_position_mm((destination[E_AXIS] = current_position[E_AXIS] = resume_eaxis));
-        }
-      #endif
-
     } // (tmp_extruder != active_extruder)
 
     planner.synchronize();
 
     #if ENABLED(EXT_SOLENOID) && DISABLED(PARKING_EXTRUDER)
       disable_all_solenoids();
       enable_solenoid_on_active_extruder();
     #endif
 
     #if ENABLED(MK2_MULTIPLEXER)

commit fae2b7edc38322e69af954f769fa7953d35f5bba
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 8 17:56:40 2019 -0500

    Update MMU2 code style

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 0de0fcfafc..c52f263190 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -570,21 +570,21 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
 
     #if MIXING_VIRTUAL_TOOLS > 1
       // T0-Tnnn: Switch virtual tool by changing the index to the mix
       mixer.T(tmp_extruder);
     #endif
 
   #elif ENABLED(PRUSA_MMU2)
 
     UNUSED(fr_mm_s); UNUSED(no_move);
 
-    mmu2.toolChange(tmp_extruder);
+    mmu2.tool_change(tmp_extruder);
 
   #elif EXTRUDERS < 2
 
     UNUSED(fr_mm_s); UNUSED(no_move);
 
     if (tmp_extruder) invalid_extruder_error(tmp_extruder);
     return;
 
   #else // EXTRUDERS > 1
 
@@ -770,21 +770,21 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
         feedrate_mm_s = old_feedrate_mm_s;
       }
       #if ENABLED(SWITCHING_NOZZLE)
         else {
           // Move back down. (Including when the new tool is higher.)
           do_blocking_move_to_z(destination[Z_AXIS], planner.settings.max_feedrate_mm_s[Z_AXIS]);
         }
       #endif
 
       #if ENABLED(PRUSA_MMU2)
-        mmu2.toolChange(tmp_extruder);
+        mmu2.tool_change(tmp_extruder);
       #endif
 
       #if SWITCHING_NOZZLE_TWO_SERVOS
         lower_nozzle(active_extruder);
       #endif
 
       #if ENABLED(TOOLCHANGE_FILAMENT_SWAP) && ADVANCED_PAUSE_RESUME_PRIME != 0
         if (should_swap && !too_cold) {
           const float resume_eaxis = current_position[E_AXIS];
           #if ENABLED(ADVANCED_PAUSE_FEATURE)

commit 0dfd76ba55d939920ff7593460e0a9adce6e41ea
Author: VBen <VBen@users.noreply.github.com>
Date:   Fri Apr 5 22:28:32 2019 +0200

    Fix Z hotend offset broken by parking extruder tool change (#13582)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 231f2c7969..0de0fcfafc 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -362,26 +362,20 @@ inline void fast_line_to_current(const AxisEnum fr_axis) {
 
       DEBUG_ECHOLNPGM("Autopark done.");
     }
     else { // nomove == true
       // Only engage magnetic field for new extruder
       pe_activate_solenoid(tmp_extruder);
       #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
         pe_activate_solenoid(active_extruder); // Just save power for inverted magnets
       #endif
     }
-
-    #if HAS_HOTEND_OFFSET
-      current_position[Z_AXIS] += hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
-    #endif
-
-    if (DEBUGGING(LEVELING)) DEBUG_POS("Applying Z-offset", current_position);
   }
 
 #endif // PARKING_EXTRUDER
 
 #if ENABLED(SWITCHING_TOOLHEAD)
 
   inline void switching_toolhead_tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
     if (no_move) return;
 
     constexpr uint16_t angles[2] = SWITCHING_TOOLHEAD_SERVO_ANGLES;

commit 49cf92dc36424cf828436f32e72263eca39a1cc3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 16 23:43:06 2019 -0500

    Extended condition macros (#13419)
    
    Allow `ENABLED`, `DISABLED`, `PIN_EXISTS`, and `BUTTON_EXISTS` to take multiple arguments. Also add:
    - Alias `ANY(...)` for `!DISABLED(...)`
    - Alias `ANY_PIN(...)` for `PIN_EXISTS(a) || PIN_EXISTS(b) ...`
    - Alias `EITHER(A,B)` for `ANY(...)`
    - Alias `ALL(...)` and `BOTH(A,B)` for `ENABLED(...)`
    - `NONE(...)` for `DISABLED(...)`

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 77a0925702..231f2c7969 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -42,21 +42,21 @@
   uint16_t singlenozzle_temp[EXTRUDERS];
   #if FAN_COUNT > 0
     uint8_t singlenozzle_fan_speed[EXTRUDERS];
   #endif
 #endif
 
 #if ENABLED(MAGNETIC_PARKING_EXTRUDER) || (ENABLED(PARKING_EXTRUDER) && PARKING_EXTRUDER_SOLENOIDS_DELAY > 0)
   #include "../gcode/gcode.h" // for dwell()
 #endif
 
-#if ENABLED(SWITCHING_EXTRUDER) || ENABLED(SWITCHING_NOZZLE) || ENABLED(SWITCHING_TOOLHEAD)
+#if ANY(SWITCHING_EXTRUDER, SWITCHING_NOZZLE, SWITCHING_TOOLHEAD)
   #include "servo.h"
 #endif
 
 #if ENABLED(EXT_SOLENOID) && DISABLED(PARKING_EXTRUDER)
   #include "../feature/solenoid.h"
 #endif
 
 #if ENABLED(MK2_MULTIPLEXER)
   #include "../feature/snmm.h"
 #endif
@@ -733,21 +733,21 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
 
         #if ENABLED(SINGLENOZZLE)
           #if FAN_COUNT > 0
             singlenozzle_fan_speed[active_extruder] = thermalManager.fan_speed[0];
             thermalManager.fan_speed[0] = singlenozzle_fan_speed[tmp_extruder];
           #endif
 
           singlenozzle_temp[active_extruder] = thermalManager.temp_hotend[0].target;
           if (singlenozzle_temp[tmp_extruder] && singlenozzle_temp[tmp_extruder] != singlenozzle_temp[active_extruder]) {
             thermalManager.setTargetHotend(singlenozzle_temp[tmp_extruder], 0);
-            #if ENABLED(ULTRA_LCD) || ENABLED(EXTENSIBLE_UI)
+            #if EITHER(ULTRA_LCD, EXTENSIBLE_UI)
               thermalManager.set_heating_message(0);
             #endif
             (void)thermalManager.wait_for_hotend(0, false);  // Wait for heating or cooling
           }
           active_extruder = tmp_extruder;
         #endif
 
         #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
           if (should_swap && !too_cold) {
             #if ENABLED(ADVANCED_PAUSE_FEATURE)

commit 09eb30dc05a727e3816ab5a407f02ada18700e23
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Fri Mar 15 23:46:27 2019 -0400

    IDEX Mirror mode based on Formbot / Vivedino Symmetric mode (#13404)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 4a4c3e9545..77a0925702 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -498,24 +498,24 @@ inline void invalid_extruder_error(const uint8_t e) {
   SERIAL_CHAR('T'); SERIAL_ECHO(int(e));
   SERIAL_CHAR(' '); SERIAL_ECHOLNPGM(MSG_INVALID_EXTRUDER);
 }
 
 #if ENABLED(DUAL_X_CARRIAGE)
 
   inline void dualx_tool_change(const uint8_t tmp_extruder, bool &no_move) {
     if (DEBUGGING(LEVELING)) {
       DEBUG_ECHOPGM("Dual X Carriage Mode ");
       switch (dual_x_carriage_mode) {
-        case DXC_FULL_CONTROL_MODE: DEBUG_ECHOLNPGM("DXC_FULL_CONTROL_MODE"); break;
-        case DXC_AUTO_PARK_MODE: DEBUG_ECHOLNPGM("DXC_AUTO_PARK_MODE"); break;
-        case DXC_DUPLICATION_MODE: DEBUG_ECHOLNPGM("DXC_DUPLICATION_MODE"); break;
-        case DXC_SCALED_DUPLICATION_MODE: DEBUG_ECHOLNPGM("DXC_SCALED_DUPLICATION_MODE"); break;
+        case DXC_FULL_CONTROL_MODE: DEBUG_ECHOLNPGM("FULL_CONTROL"); break;
+        case DXC_AUTO_PARK_MODE:    DEBUG_ECHOLNPGM("AUTO_PARK");    break;
+        case DXC_DUPLICATION_MODE:  DEBUG_ECHOLNPGM("DUPLICATION");  break;
+        case DXC_MIRRORED_MODE:     DEBUG_ECHOLNPGM("MIRRORED");     break;
       }
     }
 
     const float xhome = x_home_pos(active_extruder);
     if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE
         && IsRunning()
         && (delayed_move_time || current_position[X_AXIS] != xhome) && ! no_move
     ) {
 
       if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("MoveX to ", xhome);
@@ -589,21 +589,21 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
 
     UNUSED(fr_mm_s); UNUSED(no_move);
 
     if (tmp_extruder) invalid_extruder_error(tmp_extruder);
     return;
 
   #else // EXTRUDERS > 1
 
     planner.synchronize();
 
-    #if ENABLED(DUAL_X_CARRIAGE)  // Only T0 allowed if the Printer is in DXC_DUPLICATION_MODE or DXC_SCALED_DUPLICATION_MODE
+    #if ENABLED(DUAL_X_CARRIAGE)  // Only T0 allowed if the Printer is in DXC_DUPLICATION_MODE or DXC_MIRRORED_MODE
       if (tmp_extruder != 0 && dxc_is_duplicating())
          return invalid_extruder_error(tmp_extruder);
     #endif
 
     #if HAS_LEVELING
       // Set current position to the physical position
       const bool leveling_was_active = planner.leveling_active;
       set_bed_leveling_enabled(false);
     #endif
 

commit f5bcc00570bd5ae2ba0deaa7af0ba4d3ce7c3b02
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Mar 14 02:25:42 2019 -0500

    Unify debugging output with debug_out.h (#13388)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index aa0aa261a0..4a4c3e9545 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -24,20 +24,23 @@
 
 #include "tool_change.h"
 
 #include "probe.h"
 #include "motion.h"
 #include "planner.h"
 #include "temperature.h"
 
 #include "../Marlin.h"
 
+#define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
+#include "../core/debug_out.h"
+
 #if EXTRUDERS > 1
   toolchange_settings_t toolchange_settings;  // Initialized by settings.load()
 #endif
 
 #if ENABLED(SINGLENOZZLE)
   uint16_t singlenozzle_temp[EXTRUDERS];
   #if FAN_COUNT > 0
     uint8_t singlenozzle_fan_speed[EXTRUDERS];
   #endif
 #endif
@@ -162,104 +165,90 @@ inline void fast_line_to_current(const AxisEnum fr_axis) {
      *   3. Move to park position of new extruder
      *   4. Move high speed to approach park position of old extruder
      *   5. Move to park position of old extruder
      *   6. Move to starting position
      */
 
     // STEP 1
 
     current_position[X_AXIS] = mpe_settings.parking_xpos[tmp_extruder] + offsetcompensation;
 
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        SERIAL_ECHOPAIR("(1) Move extruder ", int(tmp_extruder));
-        DEBUG_POS(" to new extruder ParkPos", current_position);
-      }
-    #endif
+    if (DEBUGGING(LEVELING)) {
+      DEBUG_ECHOPAIR("(1) Move extruder ", int(tmp_extruder));
+      DEBUG_POS(" to new extruder ParkPos", current_position);
+    }
 
     planner.buffer_line(current_position, mpe_settings.fast_feedrate, tmp_extruder);
     planner.synchronize();
 
     // STEP 2
 
     current_position[X_AXIS] = grabpos + offsetcompensation;
 
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        SERIAL_ECHOPAIR("(2) Couple extruder ", int(tmp_extruder));
-        DEBUG_POS(" to new extruder GrabPos", current_position);
-      }
-    #endif
+    if (DEBUGGING(LEVELING)) {
+      DEBUG_ECHOPAIR("(2) Couple extruder ", int(tmp_extruder));
+      DEBUG_POS(" to new extruder GrabPos", current_position);
+    }
 
     planner.buffer_line(current_position, mpe_settings.slow_feedrate, tmp_extruder);
     planner.synchronize();
 
     // Delay before moving tool, to allow magnetic coupling
     gcode.dwell(150);
 
     // STEP 3
 
     current_position[X_AXIS] = mpe_settings.parking_xpos[tmp_extruder] + offsetcompensation;
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        SERIAL_ECHOPAIR("(3) Move extruder ", int(tmp_extruder));
-        DEBUG_POS(" back to new extruder ParkPos", current_position);
-      }
-    #endif
+    if (DEBUGGING(LEVELING)) {
+      DEBUG_ECHOPAIR("(3) Move extruder ", int(tmp_extruder));
+      DEBUG_POS(" back to new extruder ParkPos", current_position);
+    }
 
     planner.buffer_line(current_position, mpe_settings.slow_feedrate, tmp_extruder);
     planner.synchronize();
 
     // STEP 4
 
     current_position[X_AXIS] = mpe_settings.parking_xpos[active_extruder] + (active_extruder == 0 ? MPE_TRAVEL_DISTANCE : -MPE_TRAVEL_DISTANCE) + offsetcompensation;
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        SERIAL_ECHOPAIR("(4) Move extruder ", int(tmp_extruder));
-        DEBUG_POS(" close to old extruder ParkPos", current_position);
-      }
-    #endif
+    if (DEBUGGING(LEVELING)) {
+      DEBUG_ECHOPAIR("(4) Move extruder ", int(tmp_extruder));
+      DEBUG_POS(" close to old extruder ParkPos", current_position);
+    }
 
     planner.buffer_line(current_position, mpe_settings.fast_feedrate, tmp_extruder);
     planner.synchronize();
 
     // STEP 5
 
     current_position[X_AXIS] = mpe_settings.parking_xpos[active_extruder] + offsetcompensation;
 
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        SERIAL_ECHOPAIR("(5) Park extruder ", int(tmp_extruder));
-        DEBUG_POS(" at old extruder ParkPos", current_position);
-      }
-    #endif
+    if (DEBUGGING(LEVELING)) {
+      DEBUG_ECHOPAIR("(5) Park extruder ", int(tmp_extruder));
+      DEBUG_POS(" at old extruder ParkPos", current_position);
+    }
 
     planner.buffer_line(current_position, mpe_settings.slow_feedrate, tmp_extruder);
     planner.synchronize();
 
     // STEP 6
 
     current_position[X_AXIS] = oldx;
 
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        SERIAL_ECHOPAIR("(6) Move extruder ", int(tmp_extruder));
-        DEBUG_POS(" to starting position", current_position);
-      }
-    #endif
+    if (DEBUGGING(LEVELING)) {
+      DEBUG_ECHOPAIR("(6) Move extruder ", int(tmp_extruder));
+      DEBUG_POS(" to starting position", current_position);
+    }
 
     planner.buffer_line(current_position, mpe_settings.fast_feedrate, tmp_extruder);
     planner.synchronize();
 
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Autopark done.");
-    #endif
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Autopark done.");
   }
 
 #elif ENABLED(PARKING_EXTRUDER)
 
   void pe_solenoid_init() {
     for (uint8_t n = 0; n <= 1; ++n)
       #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
         pe_activate_solenoid(n);
       #else
         pe_deactivate_solenoid(n);
@@ -295,126 +284,104 @@ inline void fast_line_to_current(const AxisEnum fr_axis) {
        * 2. Move to park position of old extruder
        * 3. Disengage magnetic field, wait for delay
        * 4. Move near new extruder
        * 5. Engage magnetic field for new extruder
        * 6. Move to parking incl. offset of new extruder
        * 7. Lower Z-Axis
        */
 
       // STEP 1
 
-      #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) DEBUG_POS("Start Autopark", current_position);
-      #endif
+      if (DEBUGGING(LEVELING)) DEBUG_POS("Start Autopark", current_position);
 
       current_position[Z_AXIS] += toolchange_settings.z_raise;
 
-      #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) DEBUG_POS("(1) Raise Z-Axis", current_position);
-      #endif
+      if (DEBUGGING(LEVELING)) DEBUG_POS("(1) Raise Z-Axis", current_position);
 
       fast_line_to_current(Z_AXIS);
       planner.synchronize();
 
       // STEP 2
 
       current_position[X_AXIS] = parkingposx[active_extruder] + x_offset;
 
-      #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) {
-          SERIAL_ECHOLNPAIR("(2) Park extruder ", int(active_extruder));
-          DEBUG_POS("Moving ParkPos", current_position);
-        }
-      #endif
+      if (DEBUGGING(LEVELING)) {
+        DEBUG_ECHOLNPAIR("(2) Park extruder ", int(active_extruder));
+        DEBUG_POS("Moving ParkPos", current_position);
+      }
 
       fast_line_to_current(X_AXIS);
       planner.synchronize();
 
       // STEP 3
 
-      #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(3) Disengage magnet ");
-      #endif
+      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(3) Disengage magnet ");
 
       pe_deactivate_solenoid(active_extruder);
 
       // STEP 4
 
-      #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(4) Move to position near new extruder");
-      #endif
+      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(4) Move to position near new extruder");
 
       current_position[X_AXIS] += active_extruder ? -10 : 10; // move 10mm away from parked extruder
 
-      #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) DEBUG_POS("Move away from parked extruder", current_position);
-      #endif
+      if (DEBUGGING(LEVELING)) DEBUG_POS("Move away from parked extruder", current_position);
 
       fast_line_to_current(X_AXIS);
       planner.synchronize();
 
       // STEP 5
-      #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(5) Engage magnetic field");
-      #endif
+      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(5) Engage magnetic field");
 
       #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
         pe_activate_solenoid(active_extruder); //just save power for inverted magnets
       #endif
 
       pe_activate_solenoid(tmp_extruder);
 
       // STEP 6
 
       current_position[X_AXIS] = grabpos + (tmp_extruder ? -10 : 10);
       fast_line_to_current(X_AXIS);
       current_position[X_AXIS] = grabpos;
-      #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) DEBUG_POS("(6) Unpark extruder", current_position);
-      #endif
+      if (DEBUGGING(LEVELING)) DEBUG_POS("(6) Unpark extruder", current_position);
       planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS] * 0.5, active_extruder);
       planner.synchronize();
 
       // STEP 7
 
       current_position[X_AXIS] = midpos
         #if HAS_HOTEND_OFFSET
           - hotend_offset[X_AXIS][tmp_extruder]
         #endif
       ;
 
-      #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) DEBUG_POS("(7) Move midway between hotends", current_position);
-      #endif
+      if (DEBUGGING(LEVELING)) DEBUG_POS("(7) Move midway between hotends", current_position);
 
       fast_line_to_current(X_AXIS);
       planner.synchronize();
 
-      #if ENABLED(DEBUG_LEVELING_FEATURE)
-        SERIAL_ECHOLNPGM("Autopark done.");
-      #endif
+      DEBUG_ECHOLNPGM("Autopark done.");
     }
     else { // nomove == true
       // Only engage magnetic field for new extruder
       pe_activate_solenoid(tmp_extruder);
       #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
         pe_activate_solenoid(active_extruder); // Just save power for inverted magnets
       #endif
     }
 
     #if HAS_HOTEND_OFFSET
       current_position[Z_AXIS] += hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
     #endif
 
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) DEBUG_POS("Applying Z-offset", current_position);
-    #endif
+    if (DEBUGGING(LEVELING)) DEBUG_POS("Applying Z-offset", current_position);
   }
 
 #endif // PARKING_EXTRUDER
 
 #if ENABLED(SWITCHING_TOOLHEAD)
 
   inline void switching_toolhead_tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
     if (no_move) return;
 
     constexpr uint16_t angles[2] = SWITCHING_TOOLHEAD_SERVO_ANGLES;
@@ -426,213 +393,178 @@ inline void fast_line_to_current(const AxisEnum fr_axis) {
     /**
      * 1. Raise Z to give enough clearance
      * 2. Move to switch position of current toolhead
      * 3. Unlock tool and drop it in the dock
      * 4. Move to the new toolhead
      * 5. Grab and lock the new toolhead
      */
 
     // 1. Raise Z to give enough clearance
 
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) DEBUG_POS("Starting Toolhead change", current_position);
-    #endif
+    if (DEBUGGING(LEVELING)) DEBUG_POS("Starting Toolhead change", current_position);
 
     current_position[Z_AXIS] += toolchange_settings.z_raise;
 
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) DEBUG_POS("(1) Raise Z-Axis", current_position);
-    #endif
+    if (DEBUGGING(LEVELING)) DEBUG_POS("(1) Raise Z-Axis", current_position);
 
     fast_line_to_current(Z_AXIS);
     planner.synchronize();
 
     // 2. Move to switch position of current toolhead
 
     current_position[X_AXIS] = placexpos;
 
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        SERIAL_ECHOLNPAIR("(2) Place old tool ", int(active_extruder));
-        DEBUG_POS("Move X SwitchPos", current_position);
-      }
-    #endif
+    if (DEBUGGING(LEVELING)) {
+      DEBUG_ECHOLNPAIR("(2) Place old tool ", int(active_extruder));
+      DEBUG_POS("Move X SwitchPos", current_position);
+    }
 
     fast_line_to_current(X_AXIS);
     planner.synchronize();
 
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS - SWITCHING_TOOLHEAD_Y_SECURITY;
 
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos + Security", current_position);
-    #endif
+    if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos + Security", current_position);
 
     fast_line_to_current(Y_AXIS);
     planner.synchronize();
 
     // 3. Unlock tool and drop it in the dock
 
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(3) Unlock and Place Toolhead");
-    #endif
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(3) Unlock and Place Toolhead");
 
     MOVE_SERVO(SWITCHING_TOOLHEAD_SERVO_NR, angles[1]);
     safe_delay(500);
 
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS;
 
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos", current_position);
-    #endif
+    if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos", current_position);
 
     planner.buffer_line(current_position,(planner.settings.max_feedrate_mm_s[Y_AXIS] * 0.5), active_extruder);
     planner.synchronize();
     safe_delay(200);
     current_position[Y_AXIS] -= SWITCHING_TOOLHEAD_Y_CLEAR;
 
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) DEBUG_POS("Move back Y clear", current_position);
-    #endif
+    if (DEBUGGING(LEVELING)) DEBUG_POS("Move back Y clear", current_position);
 
     fast_line_to_current(Y_AXIS); // move away from docked toolhead
     planner.synchronize();
 
     // 4. Move to the new toolhead
 
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(4) Move to new toolhead position");
-    #endif
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(4) Move to new toolhead position");
 
     current_position[X_AXIS] = grabxpos;
 
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) DEBUG_POS("Move to new toolhead X", current_position);
-    #endif
+    if (DEBUGGING(LEVELING)) DEBUG_POS("Move to new toolhead X", current_position);
 
     fast_line_to_current(X_AXIS);
     planner.synchronize();
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS - SWITCHING_TOOLHEAD_Y_SECURITY;
 
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos + Security", current_position);
-    #endif
+    if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos + Security", current_position);
 
     fast_line_to_current(Y_AXIS);
     planner.synchronize();
 
     // 5. Grab and lock the new toolhead
 
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(5) Grab and lock new toolhead ");
-    #endif
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("(5) Grab and lock new toolhead ");
 
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS;
 
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos", current_position);
-    #endif
+    if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos", current_position);
 
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS] * 0.5, active_extruder);
     planner.synchronize();
 
     safe_delay(200);
     MOVE_SERVO(SWITCHING_TOOLHEAD_SERVO_NR, angles[0]);
     safe_delay(500);
 
     current_position[Y_AXIS] -= SWITCHING_TOOLHEAD_Y_CLEAR;
 
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) DEBUG_POS("Move back Y clear", current_position);
-    #endif
+    if (DEBUGGING(LEVELING)) DEBUG_POS("Move back Y clear", current_position);
 
     fast_line_to_current(Y_AXIS); // move away from docked toolhead
     planner.synchronize();
 
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Toolhead change done.");
-    #endif
+    if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("Toolhead change done.");
   }
 
 #endif // SWITCHING_TOOLHEAD
 
 inline void invalid_extruder_error(const uint8_t e) {
   SERIAL_ECHO_START();
   SERIAL_CHAR('T'); SERIAL_ECHO(int(e));
   SERIAL_CHAR(' '); SERIAL_ECHOLNPGM(MSG_INVALID_EXTRUDER);
 }
 
 #if ENABLED(DUAL_X_CARRIAGE)
 
   inline void dualx_tool_change(const uint8_t tmp_extruder, bool &no_move) {
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        SERIAL_ECHOPGM("Dual X Carriage Mode ");
-        switch (dual_x_carriage_mode) {
-          case DXC_FULL_CONTROL_MODE: SERIAL_ECHOLNPGM("DXC_FULL_CONTROL_MODE"); break;
-          case DXC_AUTO_PARK_MODE: SERIAL_ECHOLNPGM("DXC_AUTO_PARK_MODE"); break;
-          case DXC_DUPLICATION_MODE: SERIAL_ECHOLNPGM("DXC_DUPLICATION_MODE"); break;
-          case DXC_SCALED_DUPLICATION_MODE: SERIAL_ECHOLNPGM("DXC_SCALED_DUPLICATION_MODE"); break;
-        }
+    if (DEBUGGING(LEVELING)) {
+      DEBUG_ECHOPGM("Dual X Carriage Mode ");
+      switch (dual_x_carriage_mode) {
+        case DXC_FULL_CONTROL_MODE: DEBUG_ECHOLNPGM("DXC_FULL_CONTROL_MODE"); break;
+        case DXC_AUTO_PARK_MODE: DEBUG_ECHOLNPGM("DXC_AUTO_PARK_MODE"); break;
+        case DXC_DUPLICATION_MODE: DEBUG_ECHOLNPGM("DXC_DUPLICATION_MODE"); break;
+        case DXC_SCALED_DUPLICATION_MODE: DEBUG_ECHOLNPGM("DXC_SCALED_DUPLICATION_MODE"); break;
       }
-    #endif
+    }
 
     const float xhome = x_home_pos(active_extruder);
     if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE
         && IsRunning()
         && (delayed_move_time || current_position[X_AXIS] != xhome) && ! no_move
     ) {
 
-      #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("MoveX to ", xhome);
-      #endif
+      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("MoveX to ", xhome);
+
       // Park old head
       planner.buffer_line(xhome, current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
       planner.synchronize();
     }
 
     // Apply Y & Z extruder offset (X offset is used as home pos with Dual X)
     current_position[Y_AXIS] -= hotend_offset[Y_AXIS][active_extruder] - hotend_offset[Y_AXIS][tmp_extruder];
     current_position[Z_AXIS] -= hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
 
     // Activate the new extruder ahead of calling set_axis_is_at_home!
     active_extruder = tmp_extruder;
 
     // This function resets the max/min values - the current position may be overwritten below.
     set_axis_is_at_home(X_AXIS);
 
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) DEBUG_POS("New Extruder", current_position);
-    #endif
+    if (DEBUGGING(LEVELING)) DEBUG_POS("New Extruder", current_position);
 
     switch (dual_x_carriage_mode) {
       case DXC_FULL_CONTROL_MODE:
         // New current position is the position of the activated extruder
         current_position[X_AXIS] = inactive_extruder_x_pos;
         // Save the inactive extruder's position (from the old current_position)
         inactive_extruder_x_pos = destination[X_AXIS];
         break;
       case DXC_AUTO_PARK_MODE:
         // record current raised toolhead position for use by unpark
         COPY(raised_parked_position, current_position);
         active_extruder_parked = true;
         delayed_move_time = 0;
         break;
       default:
         break;
     }
 
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        SERIAL_ECHOLNPAIR("Active extruder parked: ", active_extruder_parked ? "yes" : "no");
-        DEBUG_POS("New extruder (parked)", current_position);
-      }
-    #endif
+    if (DEBUGGING(LEVELING)) {
+      DEBUG_ECHOLNPAIR("Active extruder parked: ", active_extruder_parked ? "yes" : "no");
+      DEBUG_POS("New extruder (parked)", current_position);
+    }
   }
 
 #endif // DUAL_X_CARRIAGE
 
 /**
  * Perform a tool-change, which may result in moving the
  * previous tool out of the way and the new tool into place.
  */
 void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
   #if ENABLED(MIXING_EXTRUDER)
@@ -673,23 +605,21 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
       // Set current position to the physical position
       const bool leveling_was_active = planner.leveling_active;
       set_bed_leveling_enabled(false);
     #endif
 
     if (tmp_extruder >= EXTRUDERS)
       return invalid_extruder_error(tmp_extruder);
 
     if (!no_move && !all_axes_homed()) {
       no_move = true;
-      #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("No move on toolchange");
-      #endif
+      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPGM("No move on toolchange");
     }
 
     #if HAS_LCD_MENU
       ui.return_to_status();
     #endif
 
     #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
       const bool should_swap = !no_move && toolchange_settings.swap_length;
       #if ENABLED(PREVENT_COLD_EXTRUSION)
         const bool too_cold = !DEBUGGING(DRYRUN) && (thermalManager.targetTooColdToExtrude(active_extruder) || thermalManager.targetTooColdToExtrude(tmp_extruder));
@@ -770,24 +700,21 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
         // Raise by a configured distance to avoid workpiece, except with
         // SWITCHING_NOZZLE_TWO_SERVOS, as both nozzles will lift instead.
         current_position[Z_AXIS] += MAX(-zdiff, 0.0) + toolchange_settings.z_raise;
         #if HAS_SOFTWARE_ENDSTOPS
           NOMORE(current_position[Z_AXIS], soft_endstop[Z_AXIS].max);
         #endif
         if (!no_move) fast_line_to_current(Z_AXIS);
         move_nozzle_servo(tmp_extruder);
       #endif
 
-      #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING))
-          SERIAL_ECHOLNPAIR("Offset Tool XY by { ", xdiff, ", ", ydiff, ", ", zdiff, " }");
-      #endif
+      if (DEBUGGING(LEVELING)) DEBUG_ECHOLNPAIR("Offset Tool XY by { ", xdiff, ", ", ydiff, ", ", zdiff, " }");
 
       // The newly-selected extruder XY is actually at...
       current_position[X_AXIS] += xdiff;
       current_position[Y_AXIS] += ydiff;
       current_position[Z_AXIS] += zdiff;
 
       // Set the new active extruder if not already done in tool specific function above
       active_extruder = tmp_extruder;
 
       // Tell the planner the new "current position"
@@ -795,23 +722,21 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
 
       #if ENABLED(DELTA)
         //LOOP_XYZ(i) update_software_endstops(i); // or modify the constrain function
         const bool safe_to_move = current_position[Z_AXIS] < delta_clip_start_height - 1;
       #else
         constexpr bool safe_to_move = true;
       #endif
 
       // Return to position and lower again
       if (safe_to_move && !no_move && IsRunning()) {
-        #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) DEBUG_POS("Move back", destination);
-        #endif
+        if (DEBUGGING(LEVELING)) DEBUG_POS("Move back", destination);
 
         #if ENABLED(SINGLENOZZLE)
           #if FAN_COUNT > 0
             singlenozzle_fan_speed[active_extruder] = thermalManager.fan_speed[0];
             thermalManager.fan_speed[0] = singlenozzle_fan_speed[tmp_extruder];
           #endif
 
           singlenozzle_temp[active_extruder] = thermalManager.temp_hotend[0].target;
           if (singlenozzle_temp[tmp_extruder] && singlenozzle_temp[tmp_extruder] != singlenozzle_temp[active_extruder]) {
             thermalManager.setTargetHotend(singlenozzle_temp[tmp_extruder], 0);

commit 87162658c4fa264860d36e02b7d27acb0886c5a4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 13 05:48:36 2019 -0500

    Fix and improve software endstops (#13386)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 674e8ee010..aa0aa261a0 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -732,21 +732,21 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
 
       if (!no_move) {
         #if DISABLED(SWITCHING_NOZZLE)
           // Do a small lift to avoid the workpiece in the move back (below)
           #if ENABLED(TOOLCHANGE_PARK)
             current_position[X_AXIS] = toolchange_settings.change_point.x;
             current_position[Y_AXIS] = toolchange_settings.change_point.y;
           #endif
           current_position[Z_AXIS] += toolchange_settings.z_raise;
           #if HAS_SOFTWARE_ENDSTOPS
-            NOMORE(current_position[Z_AXIS], soft_endstop_max[Z_AXIS]);
+            NOMORE(current_position[Z_AXIS], soft_endstop[Z_AXIS].max);
           #endif
           planner.buffer_line(current_position, feedrate_mm_s, active_extruder);
         #endif
         planner.synchronize();
       }
 
       #if HAS_HOTEND_OFFSET
         #if ENABLED(DUAL_X_CARRIAGE)
           constexpr float xdiff = 0;
         #else
@@ -764,21 +764,21 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
         parking_extruder_tool_change(tmp_extruder, no_move);
       #elif ENABLED(MAGNETIC_PARKING_EXTRUDER) // Magnetic Parking extruder
         magnetic_parking_extruder_tool_change(tmp_extruder);
       #elif ENABLED(SWITCHING_TOOLHEAD) // Switching Toolhead
         switching_toolhead_tool_change(tmp_extruder, fr_mm_s, no_move);
       #elif ENABLED(SWITCHING_NOZZLE) && !SWITCHING_NOZZLE_TWO_SERVOS
         // Raise by a configured distance to avoid workpiece, except with
         // SWITCHING_NOZZLE_TWO_SERVOS, as both nozzles will lift instead.
         current_position[Z_AXIS] += MAX(-zdiff, 0.0) + toolchange_settings.z_raise;
         #if HAS_SOFTWARE_ENDSTOPS
-          NOMORE(current_position[Z_AXIS], soft_endstop_max[Z_AXIS]);
+          NOMORE(current_position[Z_AXIS], soft_endstop[Z_AXIS].max);
         #endif
         if (!no_move) fast_line_to_current(Z_AXIS);
         move_nozzle_servo(tmp_extruder);
       #endif
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING))
           SERIAL_ECHOLNPAIR("Offset Tool XY by { ", xdiff, ", ", ydiff, ", ", zdiff, " }");
       #endif
 
@@ -833,21 +833,21 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
             #endif
             planner.synchronize();
 
             #if TOOLCHANGE_FIL_EXTRA_PRIME
               planner.set_e_position_mm((destination[E_AXIS] = current_position[E_AXIS] = current_position[E_AXIS] - (TOOLCHANGE_FIL_EXTRA_PRIME)));
             #endif
           }
         #endif
 
         // Prevent a move outside physical bounds
-        clamp_to_software_endstops(destination);
+        apply_motion_limits(destination);
 
         // Move back to the original (or tweaked) position
         do_blocking_move_to(destination);
 
         #if ENABLED(DUAL_X_CARRIAGE)
           active_extruder_parked = false;
         #endif
         feedrate_mm_s = old_feedrate_mm_s;
       }
       #if ENABLED(SWITCHING_NOZZLE)

commit a5ea3e2f15a1b6cbfc2e55704475a537d7c0602d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 13 04:09:05 2019 -0500

    Fix hotend offset on switching toolhead change
    
    See commentary at #11623

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 5f1aced021..674e8ee010 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -422,21 +422,20 @@ inline void fast_line_to_current(const AxisEnum fr_axis) {
     const float toolheadposx[] = SWITCHING_TOOLHEAD_X_POS,
                 placexpos = toolheadposx[active_extruder],
                 grabxpos = toolheadposx[tmp_extruder];
 
     /**
      * 1. Raise Z to give enough clearance
      * 2. Move to switch position of current toolhead
      * 3. Unlock tool and drop it in the dock
      * 4. Move to the new toolhead
      * 5. Grab and lock the new toolhead
-     * 6. Apply the z-offset of the new toolhead
      */
 
     // 1. Raise Z to give enough clearance
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("Starting Toolhead change", current_position);
     #endif
 
     current_position[Z_AXIS] += toolchange_settings.z_raise;
 
@@ -541,30 +540,20 @@ inline void fast_line_to_current(const AxisEnum fr_axis) {
 
     current_position[Y_AXIS] -= SWITCHING_TOOLHEAD_Y_CLEAR;
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("Move back Y clear", current_position);
     #endif
 
     fast_line_to_current(Y_AXIS); // move away from docked toolhead
     planner.synchronize();
 
-    // 6. Apply the z-offset of the new toolhead
-
-    #if HAS_HOTEND_OFFSET
-      current_position[Z_AXIS] += hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
-    #endif
-
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) DEBUG_POS("(6) Apply Z offset", current_position);
-    #endif
-
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Toolhead change done.");
     #endif
   }
 
 #endif // SWITCHING_TOOLHEAD
 
 inline void invalid_extruder_error(const uint8_t e) {
   SERIAL_ECHO_START();
   SERIAL_CHAR('T'); SERIAL_ECHO(int(e));

commit 00fc43144af99b257cdc5e935a50688a3448ace2
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Fri Mar 8 21:13:24 2019 -0700

    Follow up fixes to various PRs. (#13334)
    
    - Ensure `MarlinUI:get_progress` is defined for `ExtUI`.
    - Fix for `BACKLASH_SMOOTHING` with small segments.
      `BACKLASH_SMOOTHING` with extremely small segments failed to fully correct due to the correction factor being rounded down. Rounding up ensures the entire backlash will converge to zero even for small segments.
    - Add pinout for the beta revision `EINSY_RETRO`.
    - Update soft endstops with tool offsets (for toolchange et. al. move clamping) (#12568)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 5094e5f5b1..5f1aced021 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -728,58 +728,43 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
 
     if (tmp_extruder != active_extruder) {
 
       #if SWITCHING_NOZZLE_TWO_SERVOS
         raise_nozzle(active_extruder);
       #endif
 
       const float old_feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : feedrate_mm_s;
       feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
 
-      #if ENABLED(DUAL_X_CARRIAGE)
-
-        #if HAS_SOFTWARE_ENDSTOPS
-          // Update the X software endstops early
-          active_extruder = tmp_extruder;
-          update_software_endstops(X_AXIS);
-          active_extruder = !tmp_extruder;
-          const float minx = soft_endstop_min[X_AXIS], maxx = soft_endstop_max[X_AXIS];
-        #else
-          // No software endstops? Use the configured limits
-          const float minx = tmp_extruder ? X2_MIN_POS : X1_MIN_POS,
-                      maxx = tmp_extruder ? X2_MAX_POS : X1_MAX_POS;
-        #endif
-
-        // Don't move the new extruder out of bounds
-        if (!WITHIN(current_position[X_AXIS], minx, maxx)) no_move = true;
-
+      #if HAS_SOFTWARE_ENDSTOPS && ENABLED(DUAL_X_CARRIAGE)
+        update_software_endstops(X_AXIS, active_extruder, tmp_extruder);
       #endif
 
       set_destination_from_current();
 
       if (!no_move) {
         #if DISABLED(SWITCHING_NOZZLE)
           // Do a small lift to avoid the workpiece in the move back (below)
           #if ENABLED(TOOLCHANGE_PARK)
             current_position[X_AXIS] = toolchange_settings.change_point.x;
             current_position[Y_AXIS] = toolchange_settings.change_point.y;
           #endif
           current_position[Z_AXIS] += toolchange_settings.z_raise;
           #if HAS_SOFTWARE_ENDSTOPS
             NOMORE(current_position[Z_AXIS], soft_endstop_max[Z_AXIS]);
           #endif
           planner.buffer_line(current_position, feedrate_mm_s, active_extruder);
         #endif
         planner.synchronize();
       }
 
-      #if HOTENDS > 1
+      #if HAS_HOTEND_OFFSET
         #if ENABLED(DUAL_X_CARRIAGE)
           constexpr float xdiff = 0;
         #else
           const float xdiff = hotend_offset[X_AXIS][tmp_extruder] - hotend_offset[X_AXIS][active_extruder];
         #endif
         const float ydiff = hotend_offset[Y_AXIS][tmp_extruder] - hotend_offset[Y_AXIS][active_extruder],
                     zdiff = hotend_offset[Z_AXIS][tmp_extruder] - hotend_offset[Z_AXIS][active_extruder];
       #else
         constexpr float xdiff = 0, ydiff = 0, zdiff = 0;
       #endif
@@ -907,24 +892,20 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
 
     } // (tmp_extruder != active_extruder)
 
     planner.synchronize();
 
     #if ENABLED(EXT_SOLENOID) && DISABLED(PARKING_EXTRUDER)
       disable_all_solenoids();
       enable_solenoid_on_active_extruder();
     #endif
 
-    #if HAS_SOFTWARE_ENDSTOPS && ENABLED(DUAL_X_CARRIAGE)
-      update_software_endstops(X_AXIS);
-    #endif
-
     #if ENABLED(MK2_MULTIPLEXER)
       if (tmp_extruder >= E_STEPPERS) return invalid_extruder_error(tmp_extruder);
       select_multiplexed_stepper(tmp_extruder);
     #endif
 
     #if DO_SWITCH_EXTRUDER
       planner.synchronize();
       move_extruder_servo(active_extruder);
     #endif
 

commit 645ca7af7ac27af9d6690659dc71ff9867b34b6c
Author: 3dlabsio <shane@warnertci.com>
Date:   Thu Mar 7 00:09:39 2019 -0800

    M141 Heated Chamber, Temperature rework (#12201)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index c160486432..5094e5f5b1 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -831,21 +831,21 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING)) DEBUG_POS("Move back", destination);
         #endif
 
         #if ENABLED(SINGLENOZZLE)
           #if FAN_COUNT > 0
             singlenozzle_fan_speed[active_extruder] = thermalManager.fan_speed[0];
             thermalManager.fan_speed[0] = singlenozzle_fan_speed[tmp_extruder];
           #endif
 
-          singlenozzle_temp[active_extruder] = thermalManager.target_temperature[0];
+          singlenozzle_temp[active_extruder] = thermalManager.temp_hotend[0].target;
           if (singlenozzle_temp[tmp_extruder] && singlenozzle_temp[tmp_extruder] != singlenozzle_temp[active_extruder]) {
             thermalManager.setTargetHotend(singlenozzle_temp[tmp_extruder], 0);
             #if ENABLED(ULTRA_LCD) || ENABLED(EXTENSIBLE_UI)
               thermalManager.set_heating_message(0);
             #endif
             (void)thermalManager.wait_for_hotend(0, false);  // Wait for heating or cooling
           }
           active_extruder = tmp_extruder;
         #endif
 

commit cfdb38eda4b4d993bac4a0e8600e776429b42b6e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Mar 5 06:46:19 2019 -0600

    Allow SERIAL_ECHOPAIR to take up to 12 pairs (#13311)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 289166ef9d..c160486432 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -797,26 +797,22 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
         // SWITCHING_NOZZLE_TWO_SERVOS, as both nozzles will lift instead.
         current_position[Z_AXIS] += MAX(-zdiff, 0.0) + toolchange_settings.z_raise;
         #if HAS_SOFTWARE_ENDSTOPS
           NOMORE(current_position[Z_AXIS], soft_endstop_max[Z_AXIS]);
         #endif
         if (!no_move) fast_line_to_current(Z_AXIS);
         move_nozzle_servo(tmp_extruder);
       #endif
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) {
-          SERIAL_ECHOPAIR("Offset Tool XY by { ", xdiff);
-          SERIAL_ECHOPAIR(", ", ydiff);
-          SERIAL_ECHOPAIR(", ", zdiff);
-          SERIAL_ECHOLNPGM(" }");
-        }
+        if (DEBUGGING(LEVELING))
+          SERIAL_ECHOLNPAIR("Offset Tool XY by { ", xdiff, ", ", ydiff, ", ", zdiff, " }");
       #endif
 
       // The newly-selected extruder XY is actually at...
       current_position[X_AXIS] += xdiff;
       current_position[Y_AXIS] += ydiff;
       current_position[Z_AXIS] += zdiff;
 
       // Set the new active extruder if not already done in tool specific function above
       active_extruder = tmp_extruder;
 

commit bc87e97357496cbd84b855450c33b3f94124fb3c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 4 19:09:31 2019 -0600

    Prevent a tool change move out of bounds

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 322b6b7c06..289166ef9d 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -119,20 +119,24 @@
     void move_nozzle_servo(const uint8_t angle_index) {
       planner.synchronize();
       MOVE_SERVO(SWITCHING_NOZZLE_SERVO_NR, servo_angles[SWITCHING_NOZZLE_SERVO_NR][e]);
       safe_delay(500);
     }
 
   #endif
 
 #endif // SWITCHING_NOZZLE
 
+inline void fast_line_to_current(const AxisEnum fr_axis) {
+  planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[fr_axis], active_extruder);
+}
+
 #if ENABLED(MAGNETIC_PARKING_EXTRUDER)
 
   float parkingposx[2] ,           // M951 R L
         parkinggrabdistance ,      // M951 I
         parkingslowspeed,          // M951 J
         parkinghighspeed ,         // M951 H
         parkingtraveldistance,     // M951 D
         compensationmultiplier;
 
   inline void magnetic_parking_extruder_tool_change(const uint8_t tmp_extruder) {
@@ -301,35 +305,35 @@
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) DEBUG_POS("Start Autopark", current_position);
       #endif
 
       current_position[Z_AXIS] += toolchange_settings.z_raise;
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) DEBUG_POS("(1) Raise Z-Axis", current_position);
       #endif
 
-      planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Z_AXIS], active_extruder);
+      fast_line_to_current(Z_AXIS);
       planner.synchronize();
 
       // STEP 2
 
       current_position[X_AXIS] = parkingposx[active_extruder] + x_offset;
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) {
           SERIAL_ECHOLNPAIR("(2) Park extruder ", int(active_extruder));
           DEBUG_POS("Moving ParkPos", current_position);
         }
       #endif
 
-      planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
+      fast_line_to_current(X_AXIS);
       planner.synchronize();
 
       // STEP 3
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(3) Disengage magnet ");
       #endif
 
       pe_deactivate_solenoid(active_extruder);
 
@@ -338,58 +342,58 @@
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(4) Move to position near new extruder");
       #endif
 
       current_position[X_AXIS] += active_extruder ? -10 : 10; // move 10mm away from parked extruder
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) DEBUG_POS("Move away from parked extruder", current_position);
       #endif
 
-      planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
+      fast_line_to_current(X_AXIS);
       planner.synchronize();
 
       // STEP 5
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(5) Engage magnetic field");
       #endif
 
       #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
         pe_activate_solenoid(active_extruder); //just save power for inverted magnets
       #endif
 
       pe_activate_solenoid(tmp_extruder);
 
       // STEP 6
 
       current_position[X_AXIS] = grabpos + (tmp_extruder ? -10 : 10);
-      planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
+      fast_line_to_current(X_AXIS);
       current_position[X_AXIS] = grabpos;
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) DEBUG_POS("(6) Unpark extruder", current_position);
       #endif
-      planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS]/2, active_extruder);
+      planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS] * 0.5, active_extruder);
       planner.synchronize();
 
       // STEP 7
 
       current_position[X_AXIS] = midpos
         #if HAS_HOTEND_OFFSET
           - hotend_offset[X_AXIS][tmp_extruder]
         #endif
       ;
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) DEBUG_POS("(7) Move midway between hotends", current_position);
       #endif
 
-      planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
+      fast_line_to_current(X_AXIS);
       planner.synchronize();
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         SERIAL_ECHOLNPGM("Autopark done.");
       #endif
     }
     else { // nomove == true
       // Only engage magnetic field for new extruder
       pe_activate_solenoid(tmp_extruder);
       #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
@@ -421,59 +425,59 @@
 
     /**
      * 1. Raise Z to give enough clearance
      * 2. Move to switch position of current toolhead
      * 3. Unlock tool and drop it in the dock
      * 4. Move to the new toolhead
      * 5. Grab and lock the new toolhead
      * 6. Apply the z-offset of the new toolhead
      */
 
-    // STEP 1
+    // 1. Raise Z to give enough clearance
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("Starting Toolhead change", current_position);
     #endif
 
     current_position[Z_AXIS] += toolchange_settings.z_raise;
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("(1) Raise Z-Axis", current_position);
     #endif
 
-    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Z_AXIS], active_extruder);
+    fast_line_to_current(Z_AXIS);
     planner.synchronize();
 
-    // STEP 2
+    // 2. Move to switch position of current toolhead
 
     current_position[X_AXIS] = placexpos;
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) {
         SERIAL_ECHOLNPAIR("(2) Place old tool ", int(active_extruder));
         DEBUG_POS("Move X SwitchPos", current_position);
       }
     #endif
 
-    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
+    fast_line_to_current(X_AXIS);
     planner.synchronize();
 
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS - SWITCHING_TOOLHEAD_Y_SECURITY;
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos + Security", current_position);
     #endif
 
-    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS], active_extruder);
+    fast_line_to_current(Y_AXIS);
     planner.synchronize();
 
-    // STEP 3
+    // 3. Unlock tool and drop it in the dock
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(3) Unlock and Place Toolhead");
     #endif
 
     MOVE_SERVO(SWITCHING_TOOLHEAD_SERVO_NR, angles[1]);
     safe_delay(500);
 
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS;
 
@@ -483,47 +487,47 @@
 
     planner.buffer_line(current_position,(planner.settings.max_feedrate_mm_s[Y_AXIS] * 0.5), active_extruder);
     planner.synchronize();
     safe_delay(200);
     current_position[Y_AXIS] -= SWITCHING_TOOLHEAD_Y_CLEAR;
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("Move back Y clear", current_position);
     #endif
 
-    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS], active_extruder); // move away from docked toolhead
+    fast_line_to_current(Y_AXIS); // move away from docked toolhead
     planner.synchronize();
 
-    // STEP 4
+    // 4. Move to the new toolhead
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(4) Move to new toolhead position");
     #endif
 
     current_position[X_AXIS] = grabxpos;
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("Move to new toolhead X", current_position);
     #endif
 
-    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
+    fast_line_to_current(X_AXIS);
     planner.synchronize();
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS - SWITCHING_TOOLHEAD_Y_SECURITY;
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos + Security", current_position);
     #endif
 
-    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS], active_extruder);
+    fast_line_to_current(Y_AXIS);
     planner.synchronize();
 
-    // STEP 5
+    // 5. Grab and lock the new toolhead
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(5) Grab and lock new toolhead ");
     #endif
 
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS;
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos", current_position);
     #endif
@@ -534,24 +538,24 @@
     safe_delay(200);
     MOVE_SERVO(SWITCHING_TOOLHEAD_SERVO_NR, angles[0]);
     safe_delay(500);
 
     current_position[Y_AXIS] -= SWITCHING_TOOLHEAD_Y_CLEAR;
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("Move back Y clear", current_position);
     #endif
 
-    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS], active_extruder); // move away from docked toolhead
+    fast_line_to_current(Y_AXIS); // move away from docked toolhead
     planner.synchronize();
 
-    // STEP 6
+    // 6. Apply the z-offset of the new toolhead
 
     #if HAS_HOTEND_OFFSET
       current_position[Z_AXIS] += hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
     #endif
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("(6) Apply Z offset", current_position);
     #endif
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
@@ -582,23 +586,21 @@ inline void invalid_extruder_error(const uint8_t e) {
       }
     #endif
 
     const float xhome = x_home_pos(active_extruder);
     if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE
         && IsRunning()
         && (delayed_move_time || current_position[X_AXIS] != xhome) && ! no_move
     ) {
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) {
-          SERIAL_ECHOLNPAIR("MoveX to ", xhome);
-        }
+        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("MoveX to ", xhome);
       #endif
       // Park old head
       planner.buffer_line(xhome, current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
       planner.synchronize();
     }
 
     // Apply Y & Z extruder offset (X offset is used as home pos with Dual X)
     current_position[Y_AXIS] -= hotend_offset[Y_AXIS][active_extruder] - hotend_offset[Y_AXIS][tmp_extruder];
     current_position[Z_AXIS] -= hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
 
@@ -790,21 +792,21 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
         magnetic_parking_extruder_tool_change(tmp_extruder);
       #elif ENABLED(SWITCHING_TOOLHEAD) // Switching Toolhead
         switching_toolhead_tool_change(tmp_extruder, fr_mm_s, no_move);
       #elif ENABLED(SWITCHING_NOZZLE) && !SWITCHING_NOZZLE_TWO_SERVOS
         // Raise by a configured distance to avoid workpiece, except with
         // SWITCHING_NOZZLE_TWO_SERVOS, as both nozzles will lift instead.
         current_position[Z_AXIS] += MAX(-zdiff, 0.0) + toolchange_settings.z_raise;
         #if HAS_SOFTWARE_ENDSTOPS
           NOMORE(current_position[Z_AXIS], soft_endstop_max[Z_AXIS]);
         #endif
-        if (!no_move)planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Z_AXIS], active_extruder);
+        if (!no_move) fast_line_to_current(Z_AXIS);
         move_nozzle_servo(tmp_extruder);
       #endif
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) {
           SERIAL_ECHOPAIR("Offset Tool XY by { ", xdiff);
           SERIAL_ECHOPAIR(", ", ydiff);
           SERIAL_ECHOPAIR(", ", zdiff);
           SERIAL_ECHOLNPGM(" }");
         }
@@ -860,22 +862,26 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
               planner.buffer_line(current_position, toolchange_settings.prime_speed, tmp_extruder);
             #endif
             planner.synchronize();
 
             #if TOOLCHANGE_FIL_EXTRA_PRIME
               planner.set_e_position_mm((destination[E_AXIS] = current_position[E_AXIS] = current_position[E_AXIS] - (TOOLCHANGE_FIL_EXTRA_PRIME)));
             #endif
           }
         #endif
 
+        // Prevent a move outside physical bounds
+        clamp_to_software_endstops(destination);
+
         // Move back to the original (or tweaked) position
         do_blocking_move_to(destination);
+
         #if ENABLED(DUAL_X_CARRIAGE)
           active_extruder_parked = false;
         #endif
         feedrate_mm_s = old_feedrate_mm_s;
       }
       #if ENABLED(SWITCHING_NOZZLE)
         else {
           // Move back down. (Including when the new tool is higher.)
           do_blocking_move_to_z(destination[Z_AXIS], planner.settings.max_feedrate_mm_s[Z_AXIS]);
         }

commit ce40c2e87c92c9c4f86ada6971b542994facfd84
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Feb 14 02:21:42 2019 -0600

    Use do_blocking_move_to(ref, fr)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 22e8b66e8c..322b6b7c06 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -861,21 +861,21 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
             #endif
             planner.synchronize();
 
             #if TOOLCHANGE_FIL_EXTRA_PRIME
               planner.set_e_position_mm((destination[E_AXIS] = current_position[E_AXIS] = current_position[E_AXIS] - (TOOLCHANGE_FIL_EXTRA_PRIME)));
             #endif
           }
         #endif
 
         // Move back to the original (or tweaked) position
-        do_blocking_move_to(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS]);
+        do_blocking_move_to(destination);
         #if ENABLED(DUAL_X_CARRIAGE)
           active_extruder_parked = false;
         #endif
         feedrate_mm_s = old_feedrate_mm_s;
       }
       #if ENABLED(SWITCHING_NOZZLE)
         else {
           // Move back down. (Including when the new tool is higher.)
           do_blocking_move_to_z(destination[Z_AXIS], planner.settings.max_feedrate_mm_s[Z_AXIS]);
         }

commit 0feeef26048883640b37ebe3994730f31ef6e922
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 15:06:53 2019 -0600

    Update copyright in headers

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index c77f7f08e9..22e8b66e8c 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit 894f5c24a8894b6344d2f88cc03d4d977f4af178
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 14:25:35 2019 -0600

    Fix trailing whitespace

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index f561f02a02..c77f7f08e9 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -126,21 +126,21 @@
 
 #endif // SWITCHING_NOZZLE
 
 #if ENABLED(MAGNETIC_PARKING_EXTRUDER)
 
   float parkingposx[2] ,           // M951 R L
         parkinggrabdistance ,      // M951 I
         parkingslowspeed,          // M951 J
         parkinghighspeed ,         // M951 H
         parkingtraveldistance,     // M951 D
-        compensationmultiplier;  
+        compensationmultiplier;
 
   inline void magnetic_parking_extruder_tool_change(const uint8_t tmp_extruder) {
 
     const float oldx = current_position[X_AXIS],
                 grabpos = mpe_settings.parking_xpos[tmp_extruder] + (tmp_extruder ? mpe_settings.grab_distance : -mpe_settings.grab_distance),
                 offsetcompensation =
                   #if HAS_HOTEND_OFFSET
                     hotend_offset[X_AXIS][active_extruder] * mpe_settings.compensation_factor
                   #else
                     0
@@ -171,34 +171,34 @@
         DEBUG_POS(" to new extruder ParkPos", current_position);
       }
     #endif
 
     planner.buffer_line(current_position, mpe_settings.fast_feedrate, tmp_extruder);
     planner.synchronize();
 
     // STEP 2
 
     current_position[X_AXIS] = grabpos + offsetcompensation;
-  
+
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) {
         SERIAL_ECHOPAIR("(2) Couple extruder ", int(tmp_extruder));
         DEBUG_POS(" to new extruder GrabPos", current_position);
       }
     #endif
-  
+
     planner.buffer_line(current_position, mpe_settings.slow_feedrate, tmp_extruder);
     planner.synchronize();
-  
+
     // Delay before moving tool, to allow magnetic coupling
     gcode.dwell(150);
-  
+
     // STEP 3
 
     current_position[X_AXIS] = mpe_settings.parking_xpos[tmp_extruder] + offsetcompensation;
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) {
         SERIAL_ECHOPAIR("(3) Move extruder ", int(tmp_extruder));
         DEBUG_POS(" back to new extruder ParkPos", current_position);
       }
     #endif
 

commit 413e303ad53caca43c123fbfc8c3ee7298ee9219
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Wed Feb 6 07:39:42 2019 -0500

    More Advanced Pause options (#12984)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 44cc7611d5..f561f02a02 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -847,26 +847,30 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
               thermalManager.set_heating_message(0);
             #endif
             (void)thermalManager.wait_for_hotend(0, false);  // Wait for heating or cooling
           }
           active_extruder = tmp_extruder;
         #endif
 
         #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
           if (should_swap && !too_cold) {
             #if ENABLED(ADVANCED_PAUSE_FEATURE)
-              do_pause_e_move(toolchange_settings.swap_length, toolchange_settings.prime_speed);
+              do_pause_e_move(toolchange_settings.swap_length + TOOLCHANGE_FIL_EXTRA_PRIME, toolchange_settings.prime_speed);
             #else
-              current_position[E_AXIS] += toolchange_settings.swap_length / planner.e_factor[tmp_extruder];
+              current_position[E_AXIS] += (toolchange_settings.swap_length + TOOLCHANGE_FIL_EXTRA_PRIME) / planner.e_factor[tmp_extruder];
               planner.buffer_line(current_position, toolchange_settings.prime_speed, tmp_extruder);
             #endif
             planner.synchronize();
+
+            #if TOOLCHANGE_FIL_EXTRA_PRIME
+              planner.set_e_position_mm((destination[E_AXIS] = current_position[E_AXIS] = current_position[E_AXIS] - (TOOLCHANGE_FIL_EXTRA_PRIME)));
+            #endif
           }
         #endif
 
         // Move back to the original (or tweaked) position
         do_blocking_move_to(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS]);
         #if ENABLED(DUAL_X_CARRIAGE)
           active_extruder_parked = false;
         #endif
         feedrate_mm_s = old_feedrate_mm_s;
       }
@@ -877,20 +881,35 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
         }
       #endif
 
       #if ENABLED(PRUSA_MMU2)
         mmu2.toolChange(tmp_extruder);
       #endif
 
       #if SWITCHING_NOZZLE_TWO_SERVOS
         lower_nozzle(active_extruder);
       #endif
+
+      #if ENABLED(TOOLCHANGE_FILAMENT_SWAP) && ADVANCED_PAUSE_RESUME_PRIME != 0
+        if (should_swap && !too_cold) {
+          const float resume_eaxis = current_position[E_AXIS];
+          #if ENABLED(ADVANCED_PAUSE_FEATURE)
+            do_pause_e_move(toolchange_settings.swap_length, toolchange_settings.prime_speed);
+          #else
+            current_position[E_AXIS] += (ADVANCED_PAUSE_RESUME_PRIME) / planner.e_factor[active_extruder];
+            planner.buffer_line(current_position, ADVANCED_PAUSE_PURGE_FEEDRATE, active_extruder);
+          #endif
+          planner.synchronize();
+          planner.set_e_position_mm((destination[E_AXIS] = current_position[E_AXIS] = resume_eaxis));
+        }
+      #endif
+
     } // (tmp_extruder != active_extruder)
 
     planner.synchronize();
 
     #if ENABLED(EXT_SOLENOID) && DISABLED(PARKING_EXTRUDER)
       disable_all_solenoids();
       enable_solenoid_on_active_extruder();
     #endif
 
     #if HAS_SOFTWARE_ENDSTOPS && ENABLED(DUAL_X_CARRIAGE)

commit 524c6c10bf52b9956ca2f68eb3d3074e5cba0706
Author: Rolf Werum <39219447+Weruminger@users.noreply.github.com>
Date:   Wed Feb 6 13:30:53 2019 +0100

    MAGNETIC_PARKING_EXTRUDER (#12351)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 74b51d736c..44cc7611d5 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -35,21 +35,21 @@
   toolchange_settings_t toolchange_settings;  // Initialized by settings.load()
 #endif
 
 #if ENABLED(SINGLENOZZLE)
   uint16_t singlenozzle_temp[EXTRUDERS];
   #if FAN_COUNT > 0
     uint8_t singlenozzle_fan_speed[EXTRUDERS];
   #endif
 #endif
 
-#if ENABLED(PARKING_EXTRUDER) && PARKING_EXTRUDER_SOLENOIDS_DELAY > 0
+#if ENABLED(MAGNETIC_PARKING_EXTRUDER) || (ENABLED(PARKING_EXTRUDER) && PARKING_EXTRUDER_SOLENOIDS_DELAY > 0)
   #include "../gcode/gcode.h" // for dwell()
 #endif
 
 #if ENABLED(SWITCHING_EXTRUDER) || ENABLED(SWITCHING_NOZZLE) || ENABLED(SWITCHING_TOOLHEAD)
   #include "servo.h"
 #endif
 
 #if ENABLED(EXT_SOLENOID) && DISABLED(PARKING_EXTRUDER)
   #include "../feature/solenoid.h"
 #endif
@@ -119,32 +119,157 @@
     void move_nozzle_servo(const uint8_t angle_index) {
       planner.synchronize();
       MOVE_SERVO(SWITCHING_NOZZLE_SERVO_NR, servo_angles[SWITCHING_NOZZLE_SERVO_NR][e]);
       safe_delay(500);
     }
 
   #endif
 
 #endif // SWITCHING_NOZZLE
 
-#if ENABLED(PARKING_EXTRUDER)
+#if ENABLED(MAGNETIC_PARKING_EXTRUDER)
 
-  void pe_magnet_init() {
+  float parkingposx[2] ,           // M951 R L
+        parkinggrabdistance ,      // M951 I
+        parkingslowspeed,          // M951 J
+        parkinghighspeed ,         // M951 H
+        parkingtraveldistance,     // M951 D
+        compensationmultiplier;  
+
+  inline void magnetic_parking_extruder_tool_change(const uint8_t tmp_extruder) {
+
+    const float oldx = current_position[X_AXIS],
+                grabpos = mpe_settings.parking_xpos[tmp_extruder] + (tmp_extruder ? mpe_settings.grab_distance : -mpe_settings.grab_distance),
+                offsetcompensation =
+                  #if HAS_HOTEND_OFFSET
+                    hotend_offset[X_AXIS][active_extruder] * mpe_settings.compensation_factor
+                  #else
+                    0
+                  #endif
+              ;
+
+    if (axis_unhomed_error(true, false, false)) return;
+
+    /**
+     * Z Lift and Nozzle Offset shift ar defined in caller method to work equal with any Multi Hotend realization
+     *
+     * Steps:
+     *   1. Move high speed to park position of new extruder
+     *   2. Move to couple position of new extruder (this also discouple the old extruder)
+     *   3. Move to park position of new extruder
+     *   4. Move high speed to approach park position of old extruder
+     *   5. Move to park position of old extruder
+     *   6. Move to starting position
+     */
+
+    // STEP 1
+
+    current_position[X_AXIS] = mpe_settings.parking_xpos[tmp_extruder] + offsetcompensation;
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) {
+        SERIAL_ECHOPAIR("(1) Move extruder ", int(tmp_extruder));
+        DEBUG_POS(" to new extruder ParkPos", current_position);
+      }
+    #endif
+
+    planner.buffer_line(current_position, mpe_settings.fast_feedrate, tmp_extruder);
+    planner.synchronize();
+
+    // STEP 2
+
+    current_position[X_AXIS] = grabpos + offsetcompensation;
+  
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) {
+        SERIAL_ECHOPAIR("(2) Couple extruder ", int(tmp_extruder));
+        DEBUG_POS(" to new extruder GrabPos", current_position);
+      }
+    #endif
+  
+    planner.buffer_line(current_position, mpe_settings.slow_feedrate, tmp_extruder);
+    planner.synchronize();
+  
+    // Delay before moving tool, to allow magnetic coupling
+    gcode.dwell(150);
+  
+    // STEP 3
+
+    current_position[X_AXIS] = mpe_settings.parking_xpos[tmp_extruder] + offsetcompensation;
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) {
+        SERIAL_ECHOPAIR("(3) Move extruder ", int(tmp_extruder));
+        DEBUG_POS(" back to new extruder ParkPos", current_position);
+      }
+    #endif
+
+    planner.buffer_line(current_position, mpe_settings.slow_feedrate, tmp_extruder);
+    planner.synchronize();
+
+    // STEP 4
+
+    current_position[X_AXIS] = mpe_settings.parking_xpos[active_extruder] + (active_extruder == 0 ? MPE_TRAVEL_DISTANCE : -MPE_TRAVEL_DISTANCE) + offsetcompensation;
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) {
+        SERIAL_ECHOPAIR("(4) Move extruder ", int(tmp_extruder));
+        DEBUG_POS(" close to old extruder ParkPos", current_position);
+      }
+    #endif
+
+    planner.buffer_line(current_position, mpe_settings.fast_feedrate, tmp_extruder);
+    planner.synchronize();
+
+    // STEP 5
+
+    current_position[X_AXIS] = mpe_settings.parking_xpos[active_extruder] + offsetcompensation;
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) {
+        SERIAL_ECHOPAIR("(5) Park extruder ", int(tmp_extruder));
+        DEBUG_POS(" at old extruder ParkPos", current_position);
+      }
+    #endif
+
+    planner.buffer_line(current_position, mpe_settings.slow_feedrate, tmp_extruder);
+    planner.synchronize();
+
+    // STEP 6
+
+    current_position[X_AXIS] = oldx;
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) {
+        SERIAL_ECHOPAIR("(6) Move extruder ", int(tmp_extruder));
+        DEBUG_POS(" to starting position", current_position);
+      }
+    #endif
+
+    planner.buffer_line(current_position, mpe_settings.fast_feedrate, tmp_extruder);
+    planner.synchronize();
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Autopark done.");
+    #endif
+  }
+
+#elif ENABLED(PARKING_EXTRUDER)
+
+  void pe_solenoid_init() {
     for (uint8_t n = 0; n <= 1; ++n)
       #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
-        pe_activate_magnet(n);
+        pe_activate_solenoid(n);
       #else
-        pe_deactivate_magnet(n);
+        pe_deactivate_solenoid(n);
       #endif
   }
 
-  void pe_set_magnet(const uint8_t extruder_num, const uint8_t state) {
+  void pe_set_solenoid(const uint8_t extruder_num, const uint8_t state) {
     switch (extruder_num) {
       case 1: OUT_WRITE(SOL1_PIN, state); break;
       default: OUT_WRITE(SOL0_PIN, state); break;
     }
     #if PARKING_EXTRUDER_SOLENOIDS_DELAY > 0
       gcode.dwell(PARKING_EXTRUDER_SOLENOIDS_DELAY);
     #endif
   }
 
   inline void parking_extruder_tool_change(const uint8_t tmp_extruder, bool no_move) {
@@ -199,21 +324,21 @@
 
       planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
       planner.synchronize();
 
       // STEP 3
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(3) Disengage magnet ");
       #endif
 
-      pe_deactivate_magnet(active_extruder);
+      pe_deactivate_solenoid(active_extruder);
 
       // STEP 4
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(4) Move to position near new extruder");
       #endif
 
       current_position[X_AXIS] += active_extruder ? -10 : 10; // move 10mm away from parked extruder
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
@@ -222,24 +347,24 @@
 
       planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
       planner.synchronize();
 
       // STEP 5
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(5) Engage magnetic field");
       #endif
 
       #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
-        pe_activate_magnet(active_extruder); //just save power for inverted magnets
+        pe_activate_solenoid(active_extruder); //just save power for inverted magnets
       #endif
 
-      pe_activate_magnet(tmp_extruder);
+      pe_activate_solenoid(tmp_extruder);
 
       // STEP 6
 
       current_position[X_AXIS] = grabpos + (tmp_extruder ? -10 : 10);
       planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
       current_position[X_AXIS] = grabpos;
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) DEBUG_POS("(6) Unpark extruder", current_position);
       #endif
       planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS]/2, active_extruder);
@@ -259,23 +384,23 @@
 
       planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
       planner.synchronize();
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         SERIAL_ECHOLNPGM("Autopark done.");
       #endif
     }
     else { // nomove == true
       // Only engage magnetic field for new extruder
-      pe_activate_magnet(tmp_extruder);
+      pe_activate_solenoid(tmp_extruder);
       #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
-        pe_activate_magnet(active_extruder); // Just save power for inverted magnets
+        pe_activate_solenoid(active_extruder); // Just save power for inverted magnets
       #endif
     }
 
     #if HAS_HOTEND_OFFSET
       current_position[Z_AXIS] += hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
     #endif
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("Applying Z-offset", current_position);
     #endif
@@ -654,20 +779,22 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
         const float ydiff = hotend_offset[Y_AXIS][tmp_extruder] - hotend_offset[Y_AXIS][active_extruder],
                     zdiff = hotend_offset[Z_AXIS][tmp_extruder] - hotend_offset[Z_AXIS][active_extruder];
       #else
         constexpr float xdiff = 0, ydiff = 0, zdiff = 0;
       #endif
 
       #if ENABLED(DUAL_X_CARRIAGE)
         dualx_tool_change(tmp_extruder, no_move);
       #elif ENABLED(PARKING_EXTRUDER) // Dual Parking extruder
         parking_extruder_tool_change(tmp_extruder, no_move);
+      #elif ENABLED(MAGNETIC_PARKING_EXTRUDER) // Magnetic Parking extruder
+        magnetic_parking_extruder_tool_change(tmp_extruder);
       #elif ENABLED(SWITCHING_TOOLHEAD) // Switching Toolhead
         switching_toolhead_tool_change(tmp_extruder, fr_mm_s, no_move);
       #elif ENABLED(SWITCHING_NOZZLE) && !SWITCHING_NOZZLE_TWO_SERVOS
         // Raise by a configured distance to avoid workpiece, except with
         // SWITCHING_NOZZLE_TWO_SERVOS, as both nozzles will lift instead.
         current_position[Z_AXIS] += MAX(-zdiff, 0.0) + toolchange_settings.z_raise;
         #if HAS_SOFTWARE_ENDSTOPS
           NOMORE(current_position[Z_AXIS], soft_endstop_max[Z_AXIS]);
         #endif
         if (!no_move)planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Z_AXIS], active_extruder);

commit d4d1b28a06caa57d26e300c1b814b2b8b62120cd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 4 03:41:55 2019 -0600

    Fix some include paths

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index b711fc0fbc..74b51d736c 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -40,21 +40,21 @@
   #if FAN_COUNT > 0
     uint8_t singlenozzle_fan_speed[EXTRUDERS];
   #endif
 #endif
 
 #if ENABLED(PARKING_EXTRUDER) && PARKING_EXTRUDER_SOLENOIDS_DELAY > 0
   #include "../gcode/gcode.h" // for dwell()
 #endif
 
 #if ENABLED(SWITCHING_EXTRUDER) || ENABLED(SWITCHING_NOZZLE) || ENABLED(SWITCHING_TOOLHEAD)
-  #include "../module/servo.h"
+  #include "servo.h"
 #endif
 
 #if ENABLED(EXT_SOLENOID) && DISABLED(PARKING_EXTRUDER)
   #include "../feature/solenoid.h"
 #endif
 
 #if ENABLED(MK2_MULTIPLEXER)
   #include "../feature/snmm.h"
 #endif
 

commit 5cfc1cdacc52ca9e09e40872ab2918d0d88ef0f2
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Sun Feb 3 23:19:56 2019 -0700

    Support SWITCHING_NOZZLE with 2 servos (#13054)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 9ca72266ab..b711fc0fbc 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -93,25 +93,44 @@
     #endif
     {
       MOVE_SERVO(_SERVO_NR(e), servo_angles[_SERVO_NR(e)][e]);
       safe_delay(500);
     }
   }
 
 #endif // DO_SWITCH_EXTRUDER
 
 #if ENABLED(SWITCHING_NOZZLE)
-  void move_nozzle_servo(const uint8_t e) {
-    planner.synchronize();
-    MOVE_SERVO(SWITCHING_NOZZLE_SERVO_NR, servo_angles[SWITCHING_NOZZLE_SERVO_NR][e]);
-    safe_delay(500);
-  }
+
+  #if SWITCHING_NOZZLE_TWO_SERVOS
+
+    inline void _move_nozzle_servo(const uint8_t e, const uint8_t angle_index) {
+      constexpr int8_t  sns_index[2] = { SWITCHING_NOZZLE_SERVO_NR, SWITCHING_NOZZLE_E1_SERVO_NR };
+      constexpr int16_t sns_angles[2] = SWITCHING_NOZZLE_SERVO_ANGLES;
+      planner.synchronize();
+      MOVE_SERVO(sns_index[e], sns_angles[angle_index]);
+      safe_delay(500);
+    }
+
+    void lower_nozzle(const uint8_t e) { _move_nozzle_servo(e, 0); }
+    void raise_nozzle(const uint8_t e) { _move_nozzle_servo(e, 1); }
+
+  #else
+
+    void move_nozzle_servo(const uint8_t angle_index) {
+      planner.synchronize();
+      MOVE_SERVO(SWITCHING_NOZZLE_SERVO_NR, servo_angles[SWITCHING_NOZZLE_SERVO_NR][e]);
+      safe_delay(500);
+    }
+
+  #endif
+
 #endif // SWITCHING_NOZZLE
 
 #if ENABLED(PARKING_EXTRUDER)
 
   void pe_magnet_init() {
     for (uint8_t n = 0; n <= 1; ++n)
       #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
         pe_activate_magnet(n);
       #else
         pe_deactivate_magnet(n);
@@ -574,20 +593,25 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
             do_pause_e_move(-toolchange_settings.swap_length, MMM_TO_MMS(toolchange_settings.retract_speed));
           #else
             current_position[E_AXIS] -= toolchange_settings.swap_length / planner.e_factor[active_extruder];
             planner.buffer_line(current_position, MMM_TO_MMS(toolchange_settings.retract_speed), active_extruder);
           #endif
         }
       }
     #endif // TOOLCHANGE_FILAMENT_SWAP
 
     if (tmp_extruder != active_extruder) {
+
+      #if SWITCHING_NOZZLE_TWO_SERVOS
+        raise_nozzle(active_extruder);
+      #endif
+
       const float old_feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : feedrate_mm_s;
       feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
 
       #if ENABLED(DUAL_X_CARRIAGE)
 
         #if HAS_SOFTWARE_ENDSTOPS
           // Update the X software endstops early
           active_extruder = tmp_extruder;
           update_software_endstops(X_AXIS);
           active_extruder = !tmp_extruder;
@@ -632,22 +656,23 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
       #else
         constexpr float xdiff = 0, ydiff = 0, zdiff = 0;
       #endif
 
       #if ENABLED(DUAL_X_CARRIAGE)
         dualx_tool_change(tmp_extruder, no_move);
       #elif ENABLED(PARKING_EXTRUDER) // Dual Parking extruder
         parking_extruder_tool_change(tmp_extruder, no_move);
       #elif ENABLED(SWITCHING_TOOLHEAD) // Switching Toolhead
         switching_toolhead_tool_change(tmp_extruder, fr_mm_s, no_move);
-      #elif ENABLED(SWITCHING_NOZZLE)
-        // Always raise by a configured distance to avoid workpiece
+      #elif ENABLED(SWITCHING_NOZZLE) && !SWITCHING_NOZZLE_TWO_SERVOS
+        // Raise by a configured distance to avoid workpiece, except with
+        // SWITCHING_NOZZLE_TWO_SERVOS, as both nozzles will lift instead.
         current_position[Z_AXIS] += MAX(-zdiff, 0.0) + toolchange_settings.z_raise;
         #if HAS_SOFTWARE_ENDSTOPS
           NOMORE(current_position[Z_AXIS], soft_endstop_max[Z_AXIS]);
         #endif
         if (!no_move)planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Z_AXIS], active_extruder);
         move_nozzle_servo(tmp_extruder);
       #endif
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) {
@@ -722,20 +747,23 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
         else {
           // Move back down. (Including when the new tool is higher.)
           do_blocking_move_to_z(destination[Z_AXIS], planner.settings.max_feedrate_mm_s[Z_AXIS]);
         }
       #endif
 
       #if ENABLED(PRUSA_MMU2)
         mmu2.toolChange(tmp_extruder);
       #endif
 
+      #if SWITCHING_NOZZLE_TWO_SERVOS
+        lower_nozzle(active_extruder);
+      #endif
     } // (tmp_extruder != active_extruder)
 
     planner.synchronize();
 
     #if ENABLED(EXT_SOLENOID) && DISABLED(PARKING_EXTRUDER)
       disable_all_solenoids();
       enable_solenoid_on_active_extruder();
     #endif
 
     #if HAS_SOFTWARE_ENDSTOPS && ENABLED(DUAL_X_CARRIAGE)

commit a5e33846916e5415146399d03eac334fc5cc71c8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Feb 2 23:30:26 2019 -0600

    Pre-apply cosmetic changes to mixing

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 159adc5fb3..9ca72266ab 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -500,32 +500,31 @@ inline void invalid_extruder_error(const uint8_t e) {
  * previous tool out of the way and the new tool into place.
  */
 void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
   #if ENABLED(MIXING_EXTRUDER)
 
     UNUSED(fr_mm_s); UNUSED(no_move);
 
     if (tmp_extruder >= MIXING_VIRTUAL_TOOLS)
       return invalid_extruder_error(tmp_extruder);
 
-    #if MIXING_VIRTUAL_TOOLS >  1
+    #if MIXING_VIRTUAL_TOOLS > 1
       // T0-Tnnn: Switch virtual tool by changing the index to the mix
-      mixer.T(uint_fast8_t(tmp_extruder));
+      mixer.T(tmp_extruder);
     #endif
 
   #elif ENABLED(PRUSA_MMU2)
 
     UNUSED(fr_mm_s); UNUSED(no_move);
 
     mmu2.toolChange(tmp_extruder);
 
-
   #elif EXTRUDERS < 2
 
     UNUSED(fr_mm_s); UNUSED(no_move);
 
     if (tmp_extruder) invalid_extruder_error(tmp_extruder);
     return;
 
   #else // EXTRUDERS > 1
 
     planner.synchronize();

commit 6a57d0b381db99d67cccd48135cbdd2d831588a7
Author: revilor <oliver.rossmueller@web.de>
Date:   Fri Feb 1 02:10:52 2019 +0100

    Prusa MMU2 (#12967)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 0d79f7c9e4..159adc5fb3 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -63,20 +63,24 @@
 #endif
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if HAS_FANMUX
   #include "../feature/fanmux.h"
 #endif
 
+#if ENABLED(PRUSA_MMU2)
+  #include "../feature/prusa_MMU2/mmu2.h"
+#endif
+
 #if HAS_LCD_MENU
   #include "../lcd/ultralcd.h"
 #endif
 
 #if DO_SWITCH_EXTRUDER
 
   #if EXTRUDERS > 3
     #define _SERVO_NR(E) ((E) < 2 ? SWITCHING_EXTRUDER_SERVO_NR : SWITCHING_EXTRUDER_E23_SERVO_NR)
   #else
     #define _SERVO_NR(E) SWITCHING_EXTRUDER_SERVO_NR
@@ -501,20 +505,27 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
     UNUSED(fr_mm_s); UNUSED(no_move);
 
     if (tmp_extruder >= MIXING_VIRTUAL_TOOLS)
       return invalid_extruder_error(tmp_extruder);
 
     #if MIXING_VIRTUAL_TOOLS >  1
       // T0-Tnnn: Switch virtual tool by changing the index to the mix
       mixer.T(uint_fast8_t(tmp_extruder));
     #endif
 
+  #elif ENABLED(PRUSA_MMU2)
+
+    UNUSED(fr_mm_s); UNUSED(no_move);
+
+    mmu2.toolChange(tmp_extruder);
+
+
   #elif EXTRUDERS < 2
 
     UNUSED(fr_mm_s); UNUSED(no_move);
 
     if (tmp_extruder) invalid_extruder_error(tmp_extruder);
     return;
 
   #else // EXTRUDERS > 1
 
     planner.synchronize();
@@ -707,20 +718,25 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
           active_extruder_parked = false;
         #endif
         feedrate_mm_s = old_feedrate_mm_s;
       }
       #if ENABLED(SWITCHING_NOZZLE)
         else {
           // Move back down. (Including when the new tool is higher.)
           do_blocking_move_to_z(destination[Z_AXIS], planner.settings.max_feedrate_mm_s[Z_AXIS]);
         }
       #endif
+
+      #if ENABLED(PRUSA_MMU2)
+        mmu2.toolChange(tmp_extruder);
+      #endif
+
     } // (tmp_extruder != active_extruder)
 
     planner.synchronize();
 
     #if ENABLED(EXT_SOLENOID) && DISABLED(PARKING_EXTRUDER)
       disable_all_solenoids();
       enable_solenoid_on_active_extruder();
     #endif
 
     #if HAS_SOFTWARE_ENDSTOPS && ENABLED(DUAL_X_CARRIAGE)

commit f4d1f13358426336695100c253c151cb6036ca0f
Author: InsanityAutomation <d.menzel@insanityautomation.com>
Date:   Mon Jan 21 13:50:30 2019 -0500

    Warn on cold extrusion, dont error

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 65fcabd5a7..0d79f7c9e4 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -546,21 +546,21 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
 
     #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
       const bool should_swap = !no_move && toolchange_settings.swap_length;
       #if ENABLED(PREVENT_COLD_EXTRUSION)
         const bool too_cold = !DEBUGGING(DRYRUN) && (thermalManager.targetTooColdToExtrude(active_extruder) || thermalManager.targetTooColdToExtrude(tmp_extruder));
       #else
         constexpr bool too_cold = false;
       #endif
       if (should_swap) {
         if (too_cold) {
-          SERIAL_ERROR_MSG(MSG_ERR_HOTEND_TOO_COLD);
+          SERIAL_ECHO_MSG(MSG_ERR_HOTEND_TOO_COLD);
           #if ENABLED(SINGLENOZZLE)
             active_extruder = tmp_extruder;
             return;
           #endif
         }
         else {
           #if ENABLED(ADVANCED_PAUSE_FEATURE)
             do_pause_e_move(-toolchange_settings.swap_length, MMM_TO_MMS(toolchange_settings.retract_speed));
           #else
             current_position[E_AXIS] -= toolchange_settings.swap_length / planner.e_factor[active_extruder];

commit 082f6a27dece8d1883751d3f2af1c2b0f0b6802c
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sat Jan 12 01:41:48 2019 -0500

    ADAPTIVE_FAN_SLOWING extension to hotend thermal protection (#12853)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 2125736cf5..65fcabd5a7 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -667,22 +667,22 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
       #endif
 
       // Return to position and lower again
       if (safe_to_move && !no_move && IsRunning()) {
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING)) DEBUG_POS("Move back", destination);
         #endif
 
         #if ENABLED(SINGLENOZZLE)
           #if FAN_COUNT > 0
-            singlenozzle_fan_speed[active_extruder] = fan_speed[0];
-            fan_speed[0] = singlenozzle_fan_speed[tmp_extruder];
+            singlenozzle_fan_speed[active_extruder] = thermalManager.fan_speed[0];
+            thermalManager.fan_speed[0] = singlenozzle_fan_speed[tmp_extruder];
           #endif
 
           singlenozzle_temp[active_extruder] = thermalManager.target_temperature[0];
           if (singlenozzle_temp[tmp_extruder] && singlenozzle_temp[tmp_extruder] != singlenozzle_temp[active_extruder]) {
             thermalManager.setTargetHotend(singlenozzle_temp[tmp_extruder], 0);
             #if ENABLED(ULTRA_LCD) || ENABLED(EXTENSIBLE_UI)
               thermalManager.set_heating_message(0);
             #endif
             (void)thermalManager.wait_for_hotend(0, false);  // Wait for heating or cooling
           }

commit 60cb36bef3644640f2eb1c9d2b30189e41e81ef2
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Tue Jan 1 14:17:48 2019 -0700

    Misc. improvements (#12747)
    
    * Make ExtUI respect MAXTEMP limits
      - Temperatures are now clamped by MAXTEMP limits rather than arbitrary values.
    * Speed up USB init, add status
      - Speed up USB initialization
      - Show status message if init failed
    * Enable status messages for EXTENSIBLE_UI
    * Adjust max limit to MAX_TEMP - 15
    * Misc. tweaks to formatting, const, etc.

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 81dbe9043f..2125736cf5 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -674,21 +674,21 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
 
         #if ENABLED(SINGLENOZZLE)
           #if FAN_COUNT > 0
             singlenozzle_fan_speed[active_extruder] = fan_speed[0];
             fan_speed[0] = singlenozzle_fan_speed[tmp_extruder];
           #endif
 
           singlenozzle_temp[active_extruder] = thermalManager.target_temperature[0];
           if (singlenozzle_temp[tmp_extruder] && singlenozzle_temp[tmp_extruder] != singlenozzle_temp[active_extruder]) {
             thermalManager.setTargetHotend(singlenozzle_temp[tmp_extruder], 0);
-            #if ENABLED(ULTRA_LCD)
+            #if ENABLED(ULTRA_LCD) || ENABLED(EXTENSIBLE_UI)
               thermalManager.set_heating_message(0);
             #endif
             (void)thermalManager.wait_for_hotend(0, false);  // Wait for heating or cooling
           }
           active_extruder = tmp_extruder;
         #endif
 
         #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
           if (should_swap && !too_cold) {
             #if ENABLED(ADVANCED_PAUSE_FEATURE)

commit c98623983774b9773800bc7dcef695c4bad81c0e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Nov 29 16:58:58 2018 -0600

    A single SERIAL_ECHO macro type (#12557)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index a4e202c515..81dbe9043f 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -546,22 +546,21 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
 
     #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
       const bool should_swap = !no_move && toolchange_settings.swap_length;
       #if ENABLED(PREVENT_COLD_EXTRUSION)
         const bool too_cold = !DEBUGGING(DRYRUN) && (thermalManager.targetTooColdToExtrude(active_extruder) || thermalManager.targetTooColdToExtrude(tmp_extruder));
       #else
         constexpr bool too_cold = false;
       #endif
       if (should_swap) {
         if (too_cold) {
-          SERIAL_ERROR_START();
-          SERIAL_ERRORLNPGM(MSG_ERR_HOTEND_TOO_COLD);
+          SERIAL_ERROR_MSG(MSG_ERR_HOTEND_TOO_COLD);
           #if ENABLED(SINGLENOZZLE)
             active_extruder = tmp_extruder;
             return;
           #endif
         }
         else {
           #if ENABLED(ADVANCED_PAUSE_FEATURE)
             do_pause_e_move(-toolchange_settings.swap_length, MMM_TO_MMS(toolchange_settings.retract_speed));
           #else
             current_position[E_AXIS] -= toolchange_settings.swap_length / planner.e_factor[active_extruder];

commit 4bcb63b7052c56fc8188287007d4d65140b219aa
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Mon Nov 19 23:04:11 2018 -0700

    Fix for #12482 (#12483)
    
    Fix Z-move to uninitialized position in SWITCHING_EXTRUDERS tool_change (no_move=true)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index ba500c5713..a4e202c515 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -89,27 +89,25 @@
     #endif
     {
       MOVE_SERVO(_SERVO_NR(e), servo_angles[_SERVO_NR(e)][e]);
       safe_delay(500);
     }
   }
 
 #endif // DO_SWITCH_EXTRUDER
 
 #if ENABLED(SWITCHING_NOZZLE)
-
   void move_nozzle_servo(const uint8_t e) {
     planner.synchronize();
     MOVE_SERVO(SWITCHING_NOZZLE_SERVO_NR, servo_angles[SWITCHING_NOZZLE_SERVO_NR][e]);
     safe_delay(500);
   }
-
 #endif // SWITCHING_NOZZLE
 
 #if ENABLED(PARKING_EXTRUDER)
 
   void pe_magnet_init() {
     for (uint8_t n = 0; n <= 1; ++n)
       #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
         pe_activate_magnet(n);
       #else
         pe_deactivate_magnet(n);
@@ -589,22 +587,23 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
           // No software endstops? Use the configured limits
           const float minx = tmp_extruder ? X2_MIN_POS : X1_MIN_POS,
                       maxx = tmp_extruder ? X2_MAX_POS : X1_MAX_POS;
         #endif
 
         // Don't move the new extruder out of bounds
         if (!WITHIN(current_position[X_AXIS], minx, maxx)) no_move = true;
 
       #endif
 
+      set_destination_from_current();
+
       if (!no_move) {
-        set_destination_from_current();
         #if DISABLED(SWITCHING_NOZZLE)
           // Do a small lift to avoid the workpiece in the move back (below)
           #if ENABLED(TOOLCHANGE_PARK)
             current_position[X_AXIS] = toolchange_settings.change_point.x;
             current_position[Y_AXIS] = toolchange_settings.change_point.y;
           #endif
           current_position[Z_AXIS] += toolchange_settings.z_raise;
           #if HAS_SOFTWARE_ENDSTOPS
             NOMORE(current_position[Z_AXIS], soft_endstop_max[Z_AXIS]);
           #endif

commit 90a58488b50862563f82338c4fa47bdf22e434ce
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Tue Nov 20 06:59:48 2018 +0100

    Corrected unused var, default switch, Travis tests (#12477)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index da0d6afbf5..ba500c5713 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -472,20 +472,22 @@ inline void invalid_extruder_error(const uint8_t e) {
         current_position[X_AXIS] = inactive_extruder_x_pos;
         // Save the inactive extruder's position (from the old current_position)
         inactive_extruder_x_pos = destination[X_AXIS];
         break;
       case DXC_AUTO_PARK_MODE:
         // record current raised toolhead position for use by unpark
         COPY(raised_parked_position, current_position);
         active_extruder_parked = true;
         delayed_move_time = 0;
         break;
+      default:
+        break;
     }
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) {
         SERIAL_ECHOLNPAIR("Active extruder parked: ", active_extruder_parked ? "yes" : "no");
         DEBUG_POS("New extruder (parked)", current_position);
       }
     #endif
   }
 

commit 7a075a5dc99b8769061b197854af70aefccbdae8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Nov 16 01:29:06 2018 -0600

    Tweak extruder errors

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index b716c01925..da0d6afbf5 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -410,24 +410,22 @@
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Toolhead change done.");
     #endif
   }
 
 #endif // SWITCHING_TOOLHEAD
 
 inline void invalid_extruder_error(const uint8_t e) {
   SERIAL_ECHO_START();
-  SERIAL_CHAR('T');
-  SERIAL_ECHO_F(e, DEC);
-  SERIAL_CHAR(' ');
-  SERIAL_ECHOLNPGM(MSG_INVALID_EXTRUDER);
+  SERIAL_CHAR('T'); SERIAL_ECHO(int(e));
+  SERIAL_CHAR(' '); SERIAL_ECHOLNPGM(MSG_INVALID_EXTRUDER);
 }
 
 #if ENABLED(DUAL_X_CARRIAGE)
 
   inline void dualx_tool_change(const uint8_t tmp_extruder, bool &no_move) {
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) {
         SERIAL_ECHOPGM("Dual X Carriage Mode ");
         switch (dual_x_carriage_mode) {
           case DXC_FULL_CONTROL_MODE: SERIAL_ECHOLNPGM("DXC_FULL_CONTROL_MODE"); break;

commit d2bb53702a5b8bc03d6691230f252a21ca3ee375
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Nov 14 17:33:04 2018 -0600

    Optimize target_extruder, ignore T with mixing (#12432)
    
    * Optimize target_extruder, ignore T with mixing
    * Give G-code Tn parity with tool_change

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index a8a2ba3cfb..b716c01925 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -493,38 +493,38 @@ inline void invalid_extruder_error(const uint8_t e) {
 
 #endif // DUAL_X_CARRIAGE
 
 /**
  * Perform a tool-change, which may result in moving the
  * previous tool out of the way and the new tool into place.
  */
 void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
   #if ENABLED(MIXING_EXTRUDER)
 
-    UNUSED(fr_mm_s);
-    UNUSED(no_move);
+    UNUSED(fr_mm_s); UNUSED(no_move);
+
     if (tmp_extruder >= MIXING_VIRTUAL_TOOLS)
       return invalid_extruder_error(tmp_extruder);
 
     #if MIXING_VIRTUAL_TOOLS >  1
       // T0-Tnnn: Switch virtual tool by changing the index to the mix
       mixer.T(uint_fast8_t(tmp_extruder));
     #endif
 
   #elif EXTRUDERS < 2
 
-    UNUSED(fr_mm_s);
-    UNUSED(no_move);
+    UNUSED(fr_mm_s); UNUSED(no_move);
+
     if (tmp_extruder) invalid_extruder_error(tmp_extruder);
     return;
 
-  #else
+  #else // EXTRUDERS > 1
 
     planner.synchronize();
 
     #if ENABLED(DUAL_X_CARRIAGE)  // Only T0 allowed if the Printer is in DXC_DUPLICATION_MODE or DXC_SCALED_DUPLICATION_MODE
       if (tmp_extruder != 0 && dxc_is_duplicating())
          return invalid_extruder_error(tmp_extruder);
     #endif
 
     #if HAS_LEVELING
       // Set current position to the physical position
@@ -744,12 +744,12 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
     #endif
 
     #if HAS_LEVELING
       // Restore leveling to re-establish the logical position
       set_bed_leveling_enabled(leveling_was_active);
     #endif
 
     SERIAL_ECHO_START();
     SERIAL_ECHOLNPAIR(MSG_ACTIVE_EXTRUDER, int(active_extruder));
 
-  #endif // EXTRUDERS <= 1 && (!MIXING_EXTRUDER || MIXING_VIRTUAL_TOOLS <= 1)
+  #endif // EXTRUDERS > 1
 }

commit 9ad3aed0ef2ae8875e2aaace43f3507ee994c5d5
Author: AnHardt <github@kitelab.de>
Date:   Tue Nov 13 11:56:10 2018 +0100

    Fix tool-change for MIXING_EXTRUDER with < 2 virtual tools (#12417)
    
    Fix #12416
    
    Better handling of `ENABLED(MIXING_EXTRUDER) && !MIXING_VIRTUAL_TOOLS > 1` -  to not fall through to the general case. Fix compiler warnings for `#elif EXTRUDERS < 2`.

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 274a64ee47..a8a2ba3cfb 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -491,39 +491,42 @@ inline void invalid_extruder_error(const uint8_t e) {
     #endif
   }
 
 #endif // DUAL_X_CARRIAGE
 
 /**
  * Perform a tool-change, which may result in moving the
  * previous tool out of the way and the new tool into place.
  */
 void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
-  #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
+  #if ENABLED(MIXING_EXTRUDER)
 
-      if (tmp_extruder >= MIXING_VIRTUAL_TOOLS)
-        return invalid_extruder_error(tmp_extruder);
+    UNUSED(fr_mm_s);
+    UNUSED(no_move);
+    if (tmp_extruder >= MIXING_VIRTUAL_TOOLS)
+      return invalid_extruder_error(tmp_extruder);
+
+    #if MIXING_VIRTUAL_TOOLS >  1
       // T0-Tnnn: Switch virtual tool by changing the index to the mix
       mixer.T(uint_fast8_t(tmp_extruder));
-      UNUSED(fr_mm_s);
-      UNUSED(no_move);
+    #endif
 
   #elif EXTRUDERS < 2
 
+    UNUSED(fr_mm_s);
+    UNUSED(no_move);
     if (tmp_extruder) invalid_extruder_error(tmp_extruder);
     return;
 
   #else
 
-    #if DISABLED(MIXING_EXTRUDER)
-      planner.synchronize();
-    #endif
+    planner.synchronize();
 
     #if ENABLED(DUAL_X_CARRIAGE)  // Only T0 allowed if the Printer is in DXC_DUPLICATION_MODE or DXC_SCALED_DUPLICATION_MODE
       if (tmp_extruder != 0 && dxc_is_duplicating())
          return invalid_extruder_error(tmp_extruder);
     #endif
 
     #if HAS_LEVELING
       // Set current position to the physical position
       const bool leveling_was_active = planner.leveling_active;
       set_bed_leveling_enabled(false);

commit a0c795b097a30eff006c8dff178abf5f1f1907fa
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Nov 11 12:16:24 2018 -0600

    Encapsulate common display code in a singleton (#12395)
    
    * Encapsulate common LCD code in a singleton
    * Depend more UBL code on UBL_DEVEL_DEBUGGING
      - Since most users don't need the debugging on at all times, this helps reduce the default build size for UBL by over 2K, a little closer to fitting on 128K boards.

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 1d255a88fb..274a64ee47 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -533,21 +533,21 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
       return invalid_extruder_error(tmp_extruder);
 
     if (!no_move && !all_axes_homed()) {
       no_move = true;
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("No move on toolchange");
       #endif
     }
 
     #if HAS_LCD_MENU
-      lcd_return_to_status();
+      ui.return_to_status();
     #endif
 
     #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
       const bool should_swap = !no_move && toolchange_settings.swap_length;
       #if ENABLED(PREVENT_COLD_EXTRUSION)
         const bool too_cold = !DEBUGGING(DRYRUN) && (thermalManager.targetTooColdToExtrude(active_extruder) || thermalManager.targetTooColdToExtrude(tmp_extruder));
       #else
         constexpr bool too_cold = false;
       #endif
       if (should_swap) {

commit 7665dff58b53789dd5c8dc3308154a050faacccb
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Fri Nov 9 01:15:07 2018 -0500

    No error on T0 with single-extruder and fix MIXING_EXTRUDER virtual tools (#12375)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index cdaf4294eb..1d255a88fb 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -491,33 +491,34 @@ inline void invalid_extruder_error(const uint8_t e) {
     #endif
   }
 
 #endif // DUAL_X_CARRIAGE
 
 /**
  * Perform a tool-change, which may result in moving the
  * previous tool out of the way and the new tool into place.
  */
 void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
-  #if EXTRUDERS < 2
-
-    return invalid_extruder_error(tmp_extruder);
-
-  #elif ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
+  #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
 
       if (tmp_extruder >= MIXING_VIRTUAL_TOOLS)
         return invalid_extruder_error(tmp_extruder);
       // T0-Tnnn: Switch virtual tool by changing the index to the mix
       mixer.T(uint_fast8_t(tmp_extruder));
       UNUSED(fr_mm_s);
       UNUSED(no_move);
 
+  #elif EXTRUDERS < 2
+
+    if (tmp_extruder) invalid_extruder_error(tmp_extruder);
+    return;
+
   #else
 
     #if DISABLED(MIXING_EXTRUDER)
       planner.synchronize();
     #endif
 
     #if ENABLED(DUAL_X_CARRIAGE)  // Only T0 allowed if the Printer is in DXC_DUPLICATION_MODE or DXC_SCALED_DUPLICATION_MODE
       if (tmp_extruder != 0 && dxc_is_duplicating())
          return invalid_extruder_error(tmp_extruder);
     #endif

commit ef724edd80840739e5a99bcbb39e775fa7a8c289
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 8 09:48:09 2018 -0600

    Apply HAS_LCD_MENU in EEPROM code

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index b5996009f8..cdaf4294eb 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -531,21 +531,21 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
     if (tmp_extruder >= EXTRUDERS)
       return invalid_extruder_error(tmp_extruder);
 
     if (!no_move && !all_axes_homed()) {
       no_move = true;
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("No move on toolchange");
       #endif
     }
 
-    #if ENABLED(ULTIPANEL)
+    #if HAS_LCD_MENU
       lcd_return_to_status();
     #endif
 
     #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
       const bool should_swap = !no_move && toolchange_settings.swap_length;
       #if ENABLED(PREVENT_COLD_EXTRUSION)
         const bool too_cold = !DEBUGGING(DRYRUN) && (thermalManager.targetTooColdToExtrude(active_extruder) || thermalManager.targetTooColdToExtrude(tmp_extruder));
       #else
         constexpr bool too_cold = false;
       #endif

commit 81b1e9d2724d36917f9d3251ed442270eefc4f21
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Nov 6 22:56:23 2018 -0600

    Fix up xdiff, ydiff, zdiff in tool change
    
    Followup to #12137

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index da3fa4f34e..b5996009f8 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -603,25 +603,29 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
           current_position[Z_AXIS] += toolchange_settings.z_raise;
           #if HAS_SOFTWARE_ENDSTOPS
             NOMORE(current_position[Z_AXIS], soft_endstop_max[Z_AXIS]);
           #endif
           planner.buffer_line(current_position, feedrate_mm_s, active_extruder);
         #endif
         planner.synchronize();
       }
 
       #if HOTENDS > 1
-        const float xdiff = hotend_offset[X_AXIS][tmp_extruder] - hotend_offset[X_AXIS][active_extruder],
-                    ydiff = hotend_offset[Y_AXIS][tmp_extruder] - hotend_offset[Y_AXIS][active_extruder],
+        #if ENABLED(DUAL_X_CARRIAGE)
+          constexpr float xdiff = 0;
+        #else
+          const float xdiff = hotend_offset[X_AXIS][tmp_extruder] - hotend_offset[X_AXIS][active_extruder];
+        #endif
+        const float ydiff = hotend_offset[Y_AXIS][tmp_extruder] - hotend_offset[Y_AXIS][active_extruder],
                     zdiff = hotend_offset[Z_AXIS][tmp_extruder] - hotend_offset[Z_AXIS][active_extruder];
       #else
-        const float xdiff = 0, ydiff = 0, zdiff = 0;
+        constexpr float xdiff = 0, ydiff = 0, zdiff = 0;
       #endif
 
       #if ENABLED(DUAL_X_CARRIAGE)
         dualx_tool_change(tmp_extruder, no_move);
       #elif ENABLED(PARKING_EXTRUDER) // Dual Parking extruder
         parking_extruder_tool_change(tmp_extruder, no_move);
       #elif ENABLED(SWITCHING_TOOLHEAD) // Switching Toolhead
         switching_toolhead_tool_change(tmp_extruder, fr_mm_s, no_move);
       #elif ENABLED(SWITCHING_NOZZLE)
         // Always raise by a configured distance to avoid workpiece
@@ -636,23 +640,21 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) {
           SERIAL_ECHOPAIR("Offset Tool XY by { ", xdiff);
           SERIAL_ECHOPAIR(", ", ydiff);
           SERIAL_ECHOPAIR(", ", zdiff);
           SERIAL_ECHOLNPGM(" }");
         }
       #endif
 
       // The newly-selected extruder XY is actually at...
-      #if DISABLED(DUAL_X_CARRIAGE)
-        current_position[X_AXIS] += xdiff;
-      #endif
+      current_position[X_AXIS] += xdiff;
       current_position[Y_AXIS] += ydiff;
       current_position[Z_AXIS] += zdiff;
 
       // Set the new active extruder if not already done in tool specific function above
       active_extruder = tmp_extruder;
 
       // Tell the planner the new "current position"
       sync_plan_position();
 
       #if ENABLED(DELTA)

commit 6471a75a228d8d60416f7b405e888064e7e8c8da
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue Nov 6 22:52:20 2018 -0500

    Combine more tool-change variables (#12137)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index db75f90b6c..da3fa4f34e 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -434,364 +434,316 @@ inline void invalid_extruder_error(const uint8_t e) {
           case DXC_AUTO_PARK_MODE: SERIAL_ECHOLNPGM("DXC_AUTO_PARK_MODE"); break;
           case DXC_DUPLICATION_MODE: SERIAL_ECHOLNPGM("DXC_DUPLICATION_MODE"); break;
           case DXC_SCALED_DUPLICATION_MODE: SERIAL_ECHOLNPGM("DXC_SCALED_DUPLICATION_MODE"); break;
         }
       }
     #endif
 
     const float xhome = x_home_pos(active_extruder);
     if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE
         && IsRunning()
-        && (delayed_move_time || current_position[X_AXIS] != xhome)
+        && (delayed_move_time || current_position[X_AXIS] != xhome) && ! no_move
     ) {
-      float raised_z = current_position[Z_AXIS] + toolchange_settings.z_raise;
-      #if ENABLED(MAX_SOFTWARE_ENDSTOPS)
-        NOMORE(raised_z, soft_endstop_max[Z_AXIS]);
-      #endif
+
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) {
-          SERIAL_ECHOLNPAIR("Raise to ", raised_z);
           SERIAL_ECHOLNPAIR("MoveX to ", xhome);
-          SERIAL_ECHOLNPAIR("Lower to ", current_position[Z_AXIS]);
         }
       #endif
-      // Park old head: 1) raise 2) move to park position 3) lower
-
-      #define CUR_X current_position[X_AXIS]
-      #define CUR_Y current_position[Y_AXIS]
-      #define CUR_Z current_position[Z_AXIS]
-      #define CUR_E current_position[E_AXIS]
-
-      planner.buffer_line(CUR_X, CUR_Y, raised_z, CUR_E, planner.settings.max_feedrate_mm_s[Z_AXIS], active_extruder);
-      planner.buffer_line(xhome, CUR_Y, raised_z, CUR_E, planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
-      planner.buffer_line(xhome, CUR_Y, CUR_Z,    CUR_E, planner.settings.max_feedrate_mm_s[Z_AXIS], active_extruder);
-
+      // Park old head
+      planner.buffer_line(xhome, current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
       planner.synchronize();
     }
 
     // Apply Y & Z extruder offset (X offset is used as home pos with Dual X)
     current_position[Y_AXIS] -= hotend_offset[Y_AXIS][active_extruder] - hotend_offset[Y_AXIS][tmp_extruder];
     current_position[Z_AXIS] -= hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
 
     // Activate the new extruder ahead of calling set_axis_is_at_home!
     active_extruder = tmp_extruder;
 
     // This function resets the max/min values - the current position may be overwritten below.
     set_axis_is_at_home(X_AXIS);
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("New Extruder", current_position);
     #endif
 
-    // Only when auto-parking are carriages safe to move
-    if (dual_x_carriage_mode != DXC_AUTO_PARK_MODE) no_move = true;
-
     switch (dual_x_carriage_mode) {
       case DXC_FULL_CONTROL_MODE:
         // New current position is the position of the activated extruder
         current_position[X_AXIS] = inactive_extruder_x_pos;
         // Save the inactive extruder's position (from the old current_position)
         inactive_extruder_x_pos = destination[X_AXIS];
         break;
       case DXC_AUTO_PARK_MODE:
-        // record raised toolhead position for use by unpark
+        // record current raised toolhead position for use by unpark
         COPY(raised_parked_position, current_position);
-        raised_parked_position[Z_AXIS] += toolchange_settings.z_raise;
-        #if ENABLED(MAX_SOFTWARE_ENDSTOPS)
-          NOMORE(raised_parked_position[Z_AXIS], soft_endstop_max[Z_AXIS]);
-        #endif
         active_extruder_parked = true;
         delayed_move_time = 0;
         break;
     }
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) {
         SERIAL_ECHOLNPAIR("Active extruder parked: ", active_extruder_parked ? "yes" : "no");
         DEBUG_POS("New extruder (parked)", current_position);
       }
     #endif
-
-    // No extra case for HAS_ABL in DUAL_X_CARRIAGE. Does that mean they don't work together?
   }
 
 #endif // DUAL_X_CARRIAGE
 
 /**
  * Perform a tool-change, which may result in moving the
  * previous tool out of the way and the new tool into place.
  */
 void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
-  #if DISABLED(MIXING_EXTRUDER)
-    planner.synchronize();
-  #endif
+  #if EXTRUDERS < 2
 
-  #if ENABLED(DUAL_X_CARRIAGE)  // Only T0 allowed if the Printer is in DXC_DUPLICATION_MODE or DXC_SCALED_DUPLICATION_MODE
-    if (tmp_extruder != 0 && dxc_is_duplicating())
-       return invalid_extruder_error(tmp_extruder);
-  #endif
+    return invalid_extruder_error(tmp_extruder);
 
-  #if HAS_LEVELING
-    // Set current position to the physical position
-    const bool leveling_was_active = planner.leveling_active;
-    set_bed_leveling_enabled(false);
-  #endif
+  #elif ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
 
-  #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
-    if (tmp_extruder >= MIXING_VIRTUAL_TOOLS)
-      return invalid_extruder_error(tmp_extruder);
-    // T0-Tnnn: Switch virtual tool by changing the index to the mix
-    mixer.T(uint_fast8_t(tmp_extruder));
-    UNUSED(fr_mm_s);
-    UNUSED(no_move);
+      if (tmp_extruder >= MIXING_VIRTUAL_TOOLS)
+        return invalid_extruder_error(tmp_extruder);
+      // T0-Tnnn: Switch virtual tool by changing the index to the mix
+      mixer.T(uint_fast8_t(tmp_extruder));
+      UNUSED(fr_mm_s);
+      UNUSED(no_move);
 
-  #else // !MIXING_EXTRUDER || MIXING_VIRTUAL_TOOLS <= 1
+  #else
+
+    #if DISABLED(MIXING_EXTRUDER)
+      planner.synchronize();
+    #endif
+
+    #if ENABLED(DUAL_X_CARRIAGE)  // Only T0 allowed if the Printer is in DXC_DUPLICATION_MODE or DXC_SCALED_DUPLICATION_MODE
+      if (tmp_extruder != 0 && dxc_is_duplicating())
+         return invalid_extruder_error(tmp_extruder);
+    #endif
+
+    #if HAS_LEVELING
+      // Set current position to the physical position
+      const bool leveling_was_active = planner.leveling_active;
+      set_bed_leveling_enabled(false);
+    #endif
 
     if (tmp_extruder >= EXTRUDERS)
       return invalid_extruder_error(tmp_extruder);
 
     if (!no_move && !all_axes_homed()) {
       no_move = true;
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("No move on toolchange");
       #endif
     }
 
-    #if HOTENDS > 1
-
-      const float old_feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : feedrate_mm_s;
-
-      feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
-
-      if (tmp_extruder != active_extruder) {
-
-        #if ENABLED(DUAL_X_CARRIAGE)
+    #if ENABLED(ULTIPANEL)
+      lcd_return_to_status();
+    #endif
 
-          #if HAS_SOFTWARE_ENDSTOPS
-            // Update the X software endstops early
+    #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
+      const bool should_swap = !no_move && toolchange_settings.swap_length;
+      #if ENABLED(PREVENT_COLD_EXTRUSION)
+        const bool too_cold = !DEBUGGING(DRYRUN) && (thermalManager.targetTooColdToExtrude(active_extruder) || thermalManager.targetTooColdToExtrude(tmp_extruder));
+      #else
+        constexpr bool too_cold = false;
+      #endif
+      if (should_swap) {
+        if (too_cold) {
+          SERIAL_ERROR_START();
+          SERIAL_ERRORLNPGM(MSG_ERR_HOTEND_TOO_COLD);
+          #if ENABLED(SINGLENOZZLE)
             active_extruder = tmp_extruder;
-            update_software_endstops(X_AXIS);
-            active_extruder = !tmp_extruder;
-
-            // Don't move the new extruder out of bounds
-            if (!WITHIN(current_position[X_AXIS], soft_endstop_min[X_AXIS], soft_endstop_max[X_AXIS]))
-              no_move = true;
-
-          #else
-              // No software endstops? Use the configured limits
-              if (active_extruder == 0) {
-                if (!WITHIN(current_position[X_AXIS], X2_MIN_POS, X2_MAX_POS))
-                  no_move = true;
-              }
-              else if (!WITHIN(current_position[X_AXIS], X1_MIN_POS, X1_MAX_POS))
-                no_move = true;
-          #endif
-
-          #if HAS_LCD_MENU
-            lcd_return_to_status();
+            return;
           #endif
-
-          if (!no_move) set_destination_from_current();
-          dualx_tool_change(tmp_extruder, no_move); // Can modify no_move
-
-        #else // !DUAL_X_CARRIAGE
-
-          set_destination_from_current();
-
-          const float xdiff = hotend_offset[X_AXIS][tmp_extruder] - hotend_offset[X_AXIS][active_extruder],
-                      ydiff = hotend_offset[Y_AXIS][tmp_extruder] - hotend_offset[Y_AXIS][active_extruder];
-
-          #if ENABLED(PARKING_EXTRUDER) // Dual Parking extruder
-            constexpr float zdiff = 0;
-            parking_extruder_tool_change(tmp_extruder, no_move);
-          #elif ENABLED(SWITCHING_TOOLHEAD) // Switching Toolhead
-            constexpr float zdiff = 0;
-            switching_toolhead_tool_change(tmp_extruder, fr_mm_s, no_move);
+        }
+        else {
+          #if ENABLED(ADVANCED_PAUSE_FEATURE)
+            do_pause_e_move(-toolchange_settings.swap_length, MMM_TO_MMS(toolchange_settings.retract_speed));
           #else
-            const float zdiff = hotend_offset[Z_AXIS][tmp_extruder] - hotend_offset[Z_AXIS][active_extruder];
-            #if ENABLED(SWITCHING_NOZZLE)
-              // Always raise by a configured distance to avoid workpiece
-              current_position[Z_AXIS] += MAX(-zdiff, 0.0) + toolchange_settings.z_raise;
-              planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Z_AXIS], active_extruder);
-              move_nozzle_servo(tmp_extruder);
-            #endif
+            current_position[E_AXIS] -= toolchange_settings.swap_length / planner.e_factor[active_extruder];
+            planner.buffer_line(current_position, MMM_TO_MMS(toolchange_settings.retract_speed), active_extruder);
           #endif
+        }
+      }
+    #endif // TOOLCHANGE_FILAMENT_SWAP
 
-          #if ENABLED(DEBUG_LEVELING_FEATURE)
-            if (DEBUGGING(LEVELING)) {
-              SERIAL_ECHOPAIR("Offset Tool XY by { ", xdiff);
-              SERIAL_ECHOPAIR(", ", ydiff);
-              SERIAL_ECHOPAIR(", ", zdiff);
-              SERIAL_ECHOLNPGM(" }");
-            }
-          #endif
+    if (tmp_extruder != active_extruder) {
+      const float old_feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : feedrate_mm_s;
+      feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
 
-          // The newly-selected extruder XY is actually at...
-          current_position[X_AXIS] += xdiff;
-          current_position[Y_AXIS] += ydiff;
-          current_position[Z_AXIS] += zdiff;
+      #if ENABLED(DUAL_X_CARRIAGE)
 
-          // Set the new active extruder
+        #if HAS_SOFTWARE_ENDSTOPS
+          // Update the X software endstops early
           active_extruder = tmp_extruder;
-
-        #endif // !DUAL_X_CARRIAGE
-
-        // Tell the planner the new "current position"
-        sync_plan_position();
-
-        #if ENABLED(DELTA)
-          //LOOP_XYZ(i) update_software_endstops(i); // or modify the constrain function
-          const bool safe_to_move = current_position[Z_AXIS] < delta_clip_start_height - 1;
+          update_software_endstops(X_AXIS);
+          active_extruder = !tmp_extruder;
+          const float minx = soft_endstop_min[X_AXIS], maxx = soft_endstop_max[X_AXIS];
         #else
-          constexpr bool safe_to_move = true;
+          // No software endstops? Use the configured limits
+          const float minx = tmp_extruder ? X2_MIN_POS : X1_MIN_POS,
+                      maxx = tmp_extruder ? X2_MAX_POS : X1_MAX_POS;
         #endif
 
-        // Raise, move, and lower again
-        if (safe_to_move && !no_move && IsRunning()) {
-          #if DISABLED(SWITCHING_NOZZLE)
-            // Do a small lift to avoid the workpiece in the move back (below)
-            current_position[Z_AXIS] += toolchange_settings.z_raise;
-            planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Z_AXIS], active_extruder);
-          #endif
-          #if ENABLED(DEBUG_LEVELING_FEATURE)
-            if (DEBUGGING(LEVELING)) DEBUG_POS("Move back", destination);
-          #endif
-          #if ENABLED(DUAL_X_CARRIAGE)
-            // Dual x carriage does not properly apply these to current position due to command ordering
-            // So we apply the offsets for y and z to the destination here. X cannot have an offset in this mode
-            // as it is utilized for X2 home position.
-            destination[Y_AXIS] -= hotend_offset[Y_AXIS][active_extruder] - hotend_offset[Y_AXIS][tmp_extruder];
-            destination[Z_AXIS] -= hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
+        // Don't move the new extruder out of bounds
+        if (!WITHIN(current_position[X_AXIS], minx, maxx)) no_move = true;
+
+      #endif
+
+      if (!no_move) {
+        set_destination_from_current();
+        #if DISABLED(SWITCHING_NOZZLE)
+          // Do a small lift to avoid the workpiece in the move back (below)
+          #if ENABLED(TOOLCHANGE_PARK)
+            current_position[X_AXIS] = toolchange_settings.change_point.x;
+            current_position[Y_AXIS] = toolchange_settings.change_point.y;
           #endif
-          // Move back to the original (or tweaked) position
-          do_blocking_move_to(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS]);
-          #if ENABLED(DUAL_X_CARRIAGE)
-            active_extruder_parked = false;
+          current_position[Z_AXIS] += toolchange_settings.z_raise;
+          #if HAS_SOFTWARE_ENDSTOPS
+            NOMORE(current_position[Z_AXIS], soft_endstop_max[Z_AXIS]);
           #endif
-        }
-        #if ENABLED(SWITCHING_NOZZLE)
-          else {
-            // Move back down. (Including when the new tool is higher.)
-            do_blocking_move_to_z(destination[Z_AXIS], planner.settings.max_feedrate_mm_s[Z_AXIS]);
-          }
+          planner.buffer_line(current_position, feedrate_mm_s, active_extruder);
         #endif
-      } // (tmp_extruder != active_extruder)
-
-      planner.synchronize();
+        planner.synchronize();
+      }
 
-      #if ENABLED(EXT_SOLENOID) && DISABLED(PARKING_EXTRUDER)
-        disable_all_solenoids();
-        enable_solenoid_on_active_extruder();
+      #if HOTENDS > 1
+        const float xdiff = hotend_offset[X_AXIS][tmp_extruder] - hotend_offset[X_AXIS][active_extruder],
+                    ydiff = hotend_offset[Y_AXIS][tmp_extruder] - hotend_offset[Y_AXIS][active_extruder],
+                    zdiff = hotend_offset[Z_AXIS][tmp_extruder] - hotend_offset[Z_AXIS][active_extruder];
+      #else
+        const float xdiff = 0, ydiff = 0, zdiff = 0;
       #endif
 
-      feedrate_mm_s = old_feedrate_mm_s;
-
       #if ENABLED(DUAL_X_CARRIAGE)
-        update_software_endstops(X_AXIS);
+        dualx_tool_change(tmp_extruder, no_move);
+      #elif ENABLED(PARKING_EXTRUDER) // Dual Parking extruder
+        parking_extruder_tool_change(tmp_extruder, no_move);
+      #elif ENABLED(SWITCHING_TOOLHEAD) // Switching Toolhead
+        switching_toolhead_tool_change(tmp_extruder, fr_mm_s, no_move);
+      #elif ENABLED(SWITCHING_NOZZLE)
+        // Always raise by a configured distance to avoid workpiece
+        current_position[Z_AXIS] += MAX(-zdiff, 0.0) + toolchange_settings.z_raise;
+        #if HAS_SOFTWARE_ENDSTOPS
+          NOMORE(current_position[Z_AXIS], soft_endstop_max[Z_AXIS]);
+        #endif
+        if (!no_move)planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Z_AXIS], active_extruder);
+        move_nozzle_servo(tmp_extruder);
       #endif
 
-    #else // HOTENDS <= 1
-
-      UNUSED(fr_mm_s);
-      UNUSED(no_move);
-
-      #if ENABLED(MK2_MULTIPLEXER)
-        if (tmp_extruder >= E_STEPPERS) return invalid_extruder_error(tmp_extruder);
-        select_multiplexed_stepper(tmp_extruder);
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        if (DEBUGGING(LEVELING)) {
+          SERIAL_ECHOPAIR("Offset Tool XY by { ", xdiff);
+          SERIAL_ECHOPAIR(", ", ydiff);
+          SERIAL_ECHOPAIR(", ", zdiff);
+          SERIAL_ECHOLNPGM(" }");
+        }
       #endif
 
-      #if ENABLED(SINGLENOZZLE)
-
-        #if ENABLED(PREVENT_COLD_EXTRUSION)
-          if (!DEBUGGING(DRYRUN) && thermalManager.targetTooColdToExtrude(active_extruder) && toolchange_settings.swap_length) {
-            SERIAL_ERROR_START();
-            SERIAL_ERRORLNPGM(MSG_ERR_HOTEND_TOO_COLD);
-            active_extruder = tmp_extruder;
-            return;
-          }
-        #endif
-
-        #if FAN_COUNT > 0
-          singlenozzle_fan_speed[active_extruder] = fan_speed[0];
-          fan_speed[0] = singlenozzle_fan_speed[tmp_extruder];
-        #endif
+      // The newly-selected extruder XY is actually at...
+      #if DISABLED(DUAL_X_CARRIAGE)
+        current_position[X_AXIS] += xdiff;
+      #endif
+      current_position[Y_AXIS] += ydiff;
+      current_position[Z_AXIS] += zdiff;
 
-        if (toolchange_settings.swap_length) {
-          #if ENABLED(ADVANCED_PAUSE_FEATURE)
-            do_pause_e_move(-toolchange_settings.swap_length, MMM_TO_MMS(toolchange_settings.retract_speed));
-          #else
-            current_position[E_AXIS] -= toolchange_settings.swap_length / planner.e_factor[active_extruder];
-            planner.buffer_line(current_position, MMM_TO_MMS(toolchange_settings.retract_speed), active_extruder);
-          #endif
-        }
+      // Set the new active extruder if not already done in tool specific function above
+      active_extruder = tmp_extruder;
 
-        constexpr float snfr =
-          #if ENABLED(SINGLENOZZLE_SWAP_PARK)
-            MMM_TO_MMS(SINGLENOZZLE_PARK_XY_FEEDRATE);
-          #else
-            0
-          #endif
-        ;
+      // Tell the planner the new "current position"
+      sync_plan_position();
 
-        float old_pos[XYZ];
+      #if ENABLED(DELTA)
+        //LOOP_XYZ(i) update_software_endstops(i); // or modify the constrain function
+        const bool safe_to_move = current_position[Z_AXIS] < delta_clip_start_height - 1;
+      #else
+        constexpr bool safe_to_move = true;
+      #endif
 
-        if (!no_move) {
-          COPY(old_pos, current_position);
+      // Return to position and lower again
+      if (safe_to_move && !no_move && IsRunning()) {
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) DEBUG_POS("Move back", destination);
+        #endif
 
-          #if ENABLED(SINGLENOZZLE_SWAP_PARK)
-            current_position[X_AXIS] = toolchange_settings.change_point.x;
-            current_position[Y_AXIS] = toolchange_settings.change_point.y;
+        #if ENABLED(SINGLENOZZLE)
+          #if FAN_COUNT > 0
+            singlenozzle_fan_speed[active_extruder] = fan_speed[0];
+            fan_speed[0] = singlenozzle_fan_speed[tmp_extruder];
           #endif
-          current_position[Z_AXIS] += toolchange_settings.z_raise;
 
-          do_blocking_move_to(current_position, snfr);
-        }
-
-        singlenozzle_temp[active_extruder] = thermalManager.target_temperature[0];
-        if (singlenozzle_temp[tmp_extruder] && singlenozzle_temp[tmp_extruder] != singlenozzle_temp[active_extruder]) {
-          thermalManager.setTargetHotend(singlenozzle_temp[tmp_extruder], 0);
-          #if ENABLED(ULTRA_LCD)
-            thermalManager.set_heating_message(0);
-          #endif
-          (void)thermalManager.wait_for_hotend(0, false);  // Wait for heating or cooling
-        }
+          singlenozzle_temp[active_extruder] = thermalManager.target_temperature[0];
+          if (singlenozzle_temp[tmp_extruder] && singlenozzle_temp[tmp_extruder] != singlenozzle_temp[active_extruder]) {
+            thermalManager.setTargetHotend(singlenozzle_temp[tmp_extruder], 0);
+            #if ENABLED(ULTRA_LCD)
+              thermalManager.set_heating_message(0);
+            #endif
+            (void)thermalManager.wait_for_hotend(0, false);  // Wait for heating or cooling
+          }
+          active_extruder = tmp_extruder;
+        #endif
 
-        active_extruder = tmp_extruder;
+        #if ENABLED(TOOLCHANGE_FILAMENT_SWAP)
+          if (should_swap && !too_cold) {
+            #if ENABLED(ADVANCED_PAUSE_FEATURE)
+              do_pause_e_move(toolchange_settings.swap_length, toolchange_settings.prime_speed);
+            #else
+              current_position[E_AXIS] += toolchange_settings.swap_length / planner.e_factor[tmp_extruder];
+              planner.buffer_line(current_position, toolchange_settings.prime_speed, tmp_extruder);
+            #endif
+            planner.synchronize();
+          }
+        #endif
 
-        if (toolchange_settings.swap_length) {
-          #if ENABLED(ADVANCED_PAUSE_FEATURE)
-            do_pause_e_move(toolchange_settings.swap_length, toolchange_settings.prime_speed);
-          #else
-            current_position[E_AXIS] += toolchange_settings.swap_length / planner.e_factor[tmp_extruder];
-            planner.buffer_line(current_position, toolchange_settings.prime_speed, tmp_extruder);
-          #endif
+        // Move back to the original (or tweaked) position
+        do_blocking_move_to(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS]);
+        #if ENABLED(DUAL_X_CARRIAGE)
+          active_extruder_parked = false;
+        #endif
+        feedrate_mm_s = old_feedrate_mm_s;
+      }
+      #if ENABLED(SWITCHING_NOZZLE)
+        else {
+          // Move back down. (Including when the new tool is higher.)
+          do_blocking_move_to_z(destination[Z_AXIS], planner.settings.max_feedrate_mm_s[Z_AXIS]);
         }
+      #endif
+    } // (tmp_extruder != active_extruder)
 
-        if (!no_move) do_blocking_move_to(old_pos, snfr);
-
-      #elif EXTRUDERS > 1
+    planner.synchronize();
 
-        active_extruder = tmp_extruder;
+    #if ENABLED(EXT_SOLENOID) && DISABLED(PARKING_EXTRUDER)
+      disable_all_solenoids();
+      enable_solenoid_on_active_extruder();
+    #endif
 
-      #endif
+    #if HAS_SOFTWARE_ENDSTOPS && ENABLED(DUAL_X_CARRIAGE)
+      update_software_endstops(X_AXIS);
+    #endif
 
-    #endif // HOTENDS <= 1
+    #if ENABLED(MK2_MULTIPLEXER)
+      if (tmp_extruder >= E_STEPPERS) return invalid_extruder_error(tmp_extruder);
+      select_multiplexed_stepper(tmp_extruder);
+    #endif
 
     #if DO_SWITCH_EXTRUDER
       planner.synchronize();
       move_extruder_servo(active_extruder);
     #endif
 
     #if HAS_FANMUX
       fanmux_switch(active_extruder);
     #endif
 
     #if HAS_LEVELING
       // Restore leveling to re-establish the logical position
       set_bed_leveling_enabled(leveling_was_active);
     #endif
 
     SERIAL_ECHO_START();
     SERIAL_ECHOLNPAIR(MSG_ACTIVE_EXTRUDER, int(active_extruder));
 
-  #endif // !MIXING_EXTRUDER || MIXING_VIRTUAL_TOOLS <= 1
+  #endif // EXTRUDERS <= 1 && (!MIXING_EXTRUDER || MIXING_VIRTUAL_TOOLS <= 1)
 }

commit 5a470d4a494cfb4704d73cfedbcfc8ee9ffc4e60
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Nov 6 18:03:10 2018 -0600

    Apply some tool-change cleanup

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 6bfa5a127c..db75f90b6c 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -122,113 +122,145 @@
       default: OUT_WRITE(SOL0_PIN, state); break;
     }
     #if PARKING_EXTRUDER_SOLENOIDS_DELAY > 0
       gcode.dwell(PARKING_EXTRUDER_SOLENOIDS_DELAY);
     #endif
   }
 
   inline void parking_extruder_tool_change(const uint8_t tmp_extruder, bool no_move) {
     if (!no_move) {
 
-      const float parkingposx[] = PARKING_EXTRUDER_PARKING_X,
-                  midpos = (parkingposx[0] + parkingposx[1]) * 0.5 + hotend_offset[X_AXIS][active_extruder],
-                  grabpos = parkingposx[tmp_extruder] + hotend_offset[X_AXIS][active_extruder]
-                            + (tmp_extruder == 0 ? -(PARKING_EXTRUDER_GRAB_DISTANCE) : PARKING_EXTRUDER_GRAB_DISTANCE);
+      constexpr float parkingposx[] = PARKING_EXTRUDER_PARKING_X;
+
+      #if HAS_HOTEND_OFFSET
+        const float x_offset = hotend_offset[X_AXIS][active_extruder];
+      #else
+        constexpr float x_offset = 0;
+      #endif
+
+      const float midpos = (parkingposx[0] + parkingposx[1]) * 0.5 + x_offset,
+                  grabpos = parkingposx[tmp_extruder] + (tmp_extruder ? PARKING_EXTRUDER_GRAB_DISTANCE : -(PARKING_EXTRUDER_GRAB_DISTANCE)) + x_offset;
+
       /**
        * 1. Raise Z-Axis to give enough clearance
        * 2. Move to park position of old extruder
        * 3. Disengage magnetic field, wait for delay
        * 4. Move near new extruder
        * 5. Engage magnetic field for new extruder
        * 6. Move to parking incl. offset of new extruder
        * 7. Lower Z-Axis
        */
 
       // STEP 1
+
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) DEBUG_POS("Start Autopark", current_position);
       #endif
+
       current_position[Z_AXIS] += toolchange_settings.z_raise;
+
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) DEBUG_POS("(1) Raise Z-Axis", current_position);
       #endif
+
       planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Z_AXIS], active_extruder);
       planner.synchronize();
 
       // STEP 2
-      current_position[X_AXIS] = parkingposx[active_extruder] + hotend_offset[X_AXIS][active_extruder];
+
+      current_position[X_AXIS] = parkingposx[active_extruder] + x_offset;
+
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) {
           SERIAL_ECHOLNPAIR("(2) Park extruder ", int(active_extruder));
           DEBUG_POS("Moving ParkPos", current_position);
         }
       #endif
+
       planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
       planner.synchronize();
 
       // STEP 3
+
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(3) Disengage magnet ");
       #endif
+
       pe_deactivate_magnet(active_extruder);
 
       // STEP 4
+
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(4) Move to position near new extruder");
       #endif
+
       current_position[X_AXIS] += active_extruder ? -10 : 10; // move 10mm away from parked extruder
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) DEBUG_POS("Move away from parked extruder", current_position);
       #endif
+
       planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
       planner.synchronize();
 
       // STEP 5
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(5) Engage magnetic field");
       #endif
 
       #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
         pe_activate_magnet(active_extruder); //just save power for inverted magnets
       #endif
+
       pe_activate_magnet(tmp_extruder);
 
       // STEP 6
+
       current_position[X_AXIS] = grabpos + (tmp_extruder ? -10 : 10);
       planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
       current_position[X_AXIS] = grabpos;
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) DEBUG_POS("(6) Unpark extruder", current_position);
       #endif
       planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS]/2, active_extruder);
       planner.synchronize();
 
-      // Step 7
-      current_position[X_AXIS] = midpos - hotend_offset[X_AXIS][tmp_extruder];
+      // STEP 7
+
+      current_position[X_AXIS] = midpos
+        #if HAS_HOTEND_OFFSET
+          - hotend_offset[X_AXIS][tmp_extruder]
+        #endif
+      ;
+
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) DEBUG_POS("(7) Move midway between hotends", current_position);
       #endif
+
       planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
       planner.synchronize();
+
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         SERIAL_ECHOLNPGM("Autopark done.");
       #endif
     }
     else { // nomove == true
       // Only engage magnetic field for new extruder
       pe_activate_magnet(tmp_extruder);
       #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
         pe_activate_magnet(active_extruder); // Just save power for inverted magnets
       #endif
     }
-    current_position[Z_AXIS] += hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
+
+    #if HAS_HOTEND_OFFSET
+      current_position[Z_AXIS] += hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
+    #endif
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("Applying Z-offset", current_position);
     #endif
   }
 
 #endif // PARKING_EXTRUDER
 
 #if ENABLED(SWITCHING_TOOLHEAD)
 
@@ -244,110 +276,140 @@
     /**
      * 1. Raise Z to give enough clearance
      * 2. Move to switch position of current toolhead
      * 3. Unlock tool and drop it in the dock
      * 4. Move to the new toolhead
      * 5. Grab and lock the new toolhead
      * 6. Apply the z-offset of the new toolhead
      */
 
     // STEP 1
+
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("Starting Toolhead change", current_position);
     #endif
+
     current_position[Z_AXIS] += toolchange_settings.z_raise;
+
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("(1) Raise Z-Axis", current_position);
     #endif
+
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Z_AXIS], active_extruder);
     planner.synchronize();
 
     // STEP 2
+
     current_position[X_AXIS] = placexpos;
+
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) {
         SERIAL_ECHOLNPAIR("(2) Place old tool ", int(active_extruder));
         DEBUG_POS("Move X SwitchPos", current_position);
       }
     #endif
+
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
     planner.synchronize();
 
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS - SWITCHING_TOOLHEAD_Y_SECURITY;
+
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos + Security", current_position);
     #endif
+
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS], active_extruder);
     planner.synchronize();
 
     // STEP 3
+
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(3) Unlock and Place Toolhead");
     #endif
+
     MOVE_SERVO(SWITCHING_TOOLHEAD_SERVO_NR, angles[1]);
     safe_delay(500);
 
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS;
+
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos", current_position);
     #endif
+
     planner.buffer_line(current_position,(planner.settings.max_feedrate_mm_s[Y_AXIS] * 0.5), active_extruder);
     planner.synchronize();
     safe_delay(200);
     current_position[Y_AXIS] -= SWITCHING_TOOLHEAD_Y_CLEAR;
+
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("Move back Y clear", current_position);
     #endif
+
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS], active_extruder); // move away from docked toolhead
     planner.synchronize();
 
     // STEP 4
+
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(4) Move to new toolhead position");
     #endif
+
     current_position[X_AXIS] = grabxpos;
+
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("Move to new toolhead X", current_position);
     #endif
+
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
     planner.synchronize();
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS - SWITCHING_TOOLHEAD_Y_SECURITY;
+
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos + Security", current_position);
     #endif
+
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS], active_extruder);
     planner.synchronize();
 
     // STEP 5
+
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(5) Grab and lock new toolhead ");
     #endif
+
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS;
+
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos", current_position);
     #endif
+
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS] * 0.5, active_extruder);
     planner.synchronize();
 
     safe_delay(200);
     MOVE_SERVO(SWITCHING_TOOLHEAD_SERVO_NR, angles[0]);
     safe_delay(500);
 
     current_position[Y_AXIS] -= SWITCHING_TOOLHEAD_Y_CLEAR;
+
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("Move back Y clear", current_position);
     #endif
+
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS], active_extruder); // move away from docked toolhead
     planner.synchronize();
 
     // STEP 6
-    current_position[Z_AXIS] += hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
+
+    #if HAS_HOTEND_OFFSET
+      current_position[Z_AXIS] += hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
+    #endif
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("(6) Apply Z offset", current_position);
     #endif
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Toolhead change done.");
     #endif
   }
 

commit d1ff22b9830bbb94efea52f4233b2f11ad0a0c4a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Nov 3 03:56:33 2018 -0500

    Revive SCARA's home offset (unimplemented)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index b23414166f..6bfa5a127c 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -616,21 +616,21 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
 
       planner.synchronize();
 
       #if ENABLED(EXT_SOLENOID) && DISABLED(PARKING_EXTRUDER)
         disable_all_solenoids();
         enable_solenoid_on_active_extruder();
       #endif
 
       feedrate_mm_s = old_feedrate_mm_s;
 
-      #if HAS_SOFTWARE_ENDSTOPS && ENABLED(DUAL_X_CARRIAGE)
+      #if ENABLED(DUAL_X_CARRIAGE)
         update_software_endstops(X_AXIS);
       #endif
 
     #else // HOTENDS <= 1
 
       UNUSED(fr_mm_s);
       UNUSED(no_move);
 
       #if ENABLED(MK2_MULTIPLEXER)
         if (tmp_extruder >= E_STEPPERS) return invalid_extruder_error(tmp_extruder);

commit 3583e2b4490e8fd6778d18003641c2fdd333e8a5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Oct 30 16:34:45 2018 -0500

    Followup to Menu Refactor (#12275)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 68864cb2ba..b23414166f 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -63,21 +63,21 @@
 #endif
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if HAS_FANMUX
   #include "../feature/fanmux.h"
 #endif
 
-#if ENABLED(ULTIPANEL)
+#if HAS_LCD_MENU
   #include "../lcd/ultralcd.h"
 #endif
 
 #if DO_SWITCH_EXTRUDER
 
   #if EXTRUDERS > 3
     #define _SERVO_NR(E) ((E) < 2 ? SWITCHING_EXTRUDER_SERVO_NR : SWITCHING_EXTRUDER_E23_SERVO_NR)
   #else
     #define _SERVO_NR(E) SWITCHING_EXTRUDER_SERVO_NR
   #endif
@@ -517,21 +517,21 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
           #else
               // No software endstops? Use the configured limits
               if (active_extruder == 0) {
                 if (!WITHIN(current_position[X_AXIS], X2_MIN_POS, X2_MAX_POS))
                   no_move = true;
               }
               else if (!WITHIN(current_position[X_AXIS], X1_MIN_POS, X1_MAX_POS))
                 no_move = true;
           #endif
 
-          #if ENABLED(ULTIPANEL)
+          #if HAS_LCD_MENU
             lcd_return_to_status();
           #endif
 
           if (!no_move) set_destination_from_current();
           dualx_tool_change(tmp_extruder, no_move); // Can modify no_move
 
         #else // !DUAL_X_CARRIAGE
 
           set_destination_from_current();
 

commit e48cbff10dcc469501c4530e4e4d1da4993e7f49
Author: Roman Moravƒç√≠k <roman.moravcik@gmail.com>
Date:   Wed Oct 24 22:00:07 2018 +0200

    Fixed redefinition warnings of MSG_HOTEND_TOO_COLD. (#12203)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index d7fffae072..68864cb2ba 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -635,21 +635,21 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
       #if ENABLED(MK2_MULTIPLEXER)
         if (tmp_extruder >= E_STEPPERS) return invalid_extruder_error(tmp_extruder);
         select_multiplexed_stepper(tmp_extruder);
       #endif
 
       #if ENABLED(SINGLENOZZLE)
 
         #if ENABLED(PREVENT_COLD_EXTRUSION)
           if (!DEBUGGING(DRYRUN) && thermalManager.targetTooColdToExtrude(active_extruder) && toolchange_settings.swap_length) {
             SERIAL_ERROR_START();
-            SERIAL_ERRORLNPGM(MSG_HOTEND_TOO_COLD);
+            SERIAL_ERRORLNPGM(MSG_ERR_HOTEND_TOO_COLD);
             active_extruder = tmp_extruder;
             return;
           }
         #endif
 
         #if FAN_COUNT > 0
           singlenozzle_fan_speed[active_extruder] = fan_speed[0];
           fan_speed[0] = singlenozzle_fan_speed[tmp_extruder];
         #endif
 

commit 3ec38727305862c881f268e2fc27f8188b5bc767
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Wed Oct 17 12:11:41 2018 -0400

    Single Z raise value for all tool-changing / parking (#12090)
    
    * Universal tool-change Z lift
    * Add TOOLCHANGE_ZRAISE to example configs
    * Park/unpark changes to example configs
    * Implement DEBUG_DXC_MODE

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 57ad09dc0d..d7fffae072 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -13,31 +13,36 @@
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
+#include "../inc/MarlinConfigPre.h"
+
 #include "tool_change.h"
 
 #include "probe.h"
 #include "motion.h"
 #include "planner.h"
 #include "temperature.h"
 
 #include "../Marlin.h"
 
+#if EXTRUDERS > 1
+  toolchange_settings_t toolchange_settings;  // Initialized by settings.load()
+#endif
+
 #if ENABLED(SINGLENOZZLE)
-  singlenozzle_settings_t sn_settings;  // Initialized by settings.load()
   uint16_t singlenozzle_temp[EXTRUDERS];
   #if FAN_COUNT > 0
     uint8_t singlenozzle_fan_speed[EXTRUDERS];
   #endif
 #endif
 
 #if ENABLED(PARKING_EXTRUDER) && PARKING_EXTRUDER_SOLENOIDS_DELAY > 0
   #include "../gcode/gcode.h" // for dwell()
 #endif
 
@@ -135,21 +140,21 @@
        * 4. Move near new extruder
        * 5. Engage magnetic field for new extruder
        * 6. Move to parking incl. offset of new extruder
        * 7. Lower Z-Axis
        */
 
       // STEP 1
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) DEBUG_POS("Start Autopark", current_position);
       #endif
-      current_position[Z_AXIS] += PARKING_EXTRUDER_SECURITY_RAISE;
+      current_position[Z_AXIS] += toolchange_settings.z_raise;
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) DEBUG_POS("(1) Raise Z-Axis", current_position);
       #endif
       planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Z_AXIS], active_extruder);
       planner.synchronize();
 
       // STEP 2
       current_position[X_AXIS] = parkingposx[active_extruder] + hotend_offset[X_AXIS][active_extruder];
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) {
@@ -242,21 +247,21 @@
      * 3. Unlock tool and drop it in the dock
      * 4. Move to the new toolhead
      * 5. Grab and lock the new toolhead
      * 6. Apply the z-offset of the new toolhead
      */
 
     // STEP 1
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("Starting Toolhead change", current_position);
     #endif
-    current_position[Z_AXIS] += SWITCHING_TOOLHEAD_SECURITY_RAISE;
+    current_position[Z_AXIS] += toolchange_settings.z_raise;
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("(1) Raise Z-Axis", current_position);
     #endif
     planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Z_AXIS], active_extruder);
     planner.synchronize();
 
     // STEP 2
     current_position[X_AXIS] = placexpos;
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) {
@@ -369,21 +374,21 @@ inline void invalid_extruder_error(const uint8_t e) {
           case DXC_SCALED_DUPLICATION_MODE: SERIAL_ECHOLNPGM("DXC_SCALED_DUPLICATION_MODE"); break;
         }
       }
     #endif
 
     const float xhome = x_home_pos(active_extruder);
     if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE
         && IsRunning()
         && (delayed_move_time || current_position[X_AXIS] != xhome)
     ) {
-      float raised_z = current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT;
+      float raised_z = current_position[Z_AXIS] + toolchange_settings.z_raise;
       #if ENABLED(MAX_SOFTWARE_ENDSTOPS)
         NOMORE(raised_z, soft_endstop_max[Z_AXIS]);
       #endif
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) {
           SERIAL_ECHOLNPAIR("Raise to ", raised_z);
           SERIAL_ECHOLNPAIR("MoveX to ", xhome);
           SERIAL_ECHOLNPAIR("Lower to ", current_position[Z_AXIS]);
         }
       #endif
@@ -421,21 +426,21 @@ inline void invalid_extruder_error(const uint8_t e) {
     switch (dual_x_carriage_mode) {
       case DXC_FULL_CONTROL_MODE:
         // New current position is the position of the activated extruder
         current_position[X_AXIS] = inactive_extruder_x_pos;
         // Save the inactive extruder's position (from the old current_position)
         inactive_extruder_x_pos = destination[X_AXIS];
         break;
       case DXC_AUTO_PARK_MODE:
         // record raised toolhead position for use by unpark
         COPY(raised_parked_position, current_position);
-        raised_parked_position[Z_AXIS] += TOOLCHANGE_UNPARK_ZLIFT;
+        raised_parked_position[Z_AXIS] += toolchange_settings.z_raise;
         #if ENABLED(MAX_SOFTWARE_ENDSTOPS)
           NOMORE(raised_parked_position[Z_AXIS], soft_endstop_max[Z_AXIS]);
         #endif
         active_extruder_parked = true;
         delayed_move_time = 0;
         break;
     }
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) {
@@ -535,22 +540,22 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
 
           #if ENABLED(PARKING_EXTRUDER) // Dual Parking extruder
             constexpr float zdiff = 0;
             parking_extruder_tool_change(tmp_extruder, no_move);
           #elif ENABLED(SWITCHING_TOOLHEAD) // Switching Toolhead
             constexpr float zdiff = 0;
             switching_toolhead_tool_change(tmp_extruder, fr_mm_s, no_move);
           #else
             const float zdiff = hotend_offset[Z_AXIS][tmp_extruder] - hotend_offset[Z_AXIS][active_extruder];
             #if ENABLED(SWITCHING_NOZZLE)
-              // Always raise by at least 1 to avoid workpiece
-              current_position[Z_AXIS] += MAX(-zdiff, 0.0) + 1;
+              // Always raise by a configured distance to avoid workpiece
+              current_position[Z_AXIS] += MAX(-zdiff, 0.0) + toolchange_settings.z_raise;
               planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Z_AXIS], active_extruder);
               move_nozzle_servo(tmp_extruder);
             #endif
           #endif
 
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) {
               SERIAL_ECHOPAIR("Offset Tool XY by { ", xdiff);
               SERIAL_ECHOPAIR(", ", ydiff);
               SERIAL_ECHOPAIR(", ", zdiff);
@@ -575,21 +580,21 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
           //LOOP_XYZ(i) update_software_endstops(i); // or modify the constrain function
           const bool safe_to_move = current_position[Z_AXIS] < delta_clip_start_height - 1;
         #else
           constexpr bool safe_to_move = true;
         #endif
 
         // Raise, move, and lower again
         if (safe_to_move && !no_move && IsRunning()) {
           #if DISABLED(SWITCHING_NOZZLE)
             // Do a small lift to avoid the workpiece in the move back (below)
-            current_position[Z_AXIS] += 1.0;
+            current_position[Z_AXIS] += toolchange_settings.z_raise;
             planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Z_AXIS], active_extruder);
           #endif
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) DEBUG_POS("Move back", destination);
           #endif
           #if ENABLED(DUAL_X_CARRIAGE)
             // Dual x carriage does not properly apply these to current position due to command ordering
             // So we apply the offsets for y and z to the destination here. X cannot have an offset in this mode
             // as it is utilized for X2 home position.
             destination[Y_AXIS] -= hotend_offset[Y_AXIS][active_extruder] - hotend_offset[Y_AXIS][tmp_extruder];
@@ -628,81 +633,81 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
       UNUSED(no_move);
 
       #if ENABLED(MK2_MULTIPLEXER)
         if (tmp_extruder >= E_STEPPERS) return invalid_extruder_error(tmp_extruder);
         select_multiplexed_stepper(tmp_extruder);
       #endif
 
       #if ENABLED(SINGLENOZZLE)
 
         #if ENABLED(PREVENT_COLD_EXTRUSION)
-          if (!DEBUGGING(DRYRUN) && thermalManager.targetTooColdToExtrude(active_extruder) && sn_settings.swap_length) {
+          if (!DEBUGGING(DRYRUN) && thermalManager.targetTooColdToExtrude(active_extruder) && toolchange_settings.swap_length) {
             SERIAL_ERROR_START();
             SERIAL_ERRORLNPGM(MSG_HOTEND_TOO_COLD);
             active_extruder = tmp_extruder;
             return;
           }
         #endif
 
         #if FAN_COUNT > 0
           singlenozzle_fan_speed[active_extruder] = fan_speed[0];
           fan_speed[0] = singlenozzle_fan_speed[tmp_extruder];
         #endif
 
-        if (sn_settings.swap_length) {
+        if (toolchange_settings.swap_length) {
           #if ENABLED(ADVANCED_PAUSE_FEATURE)
-            do_pause_e_move(-sn_settings.swap_length, MMM_TO_MMS(sn_settings.retract_speed));
+            do_pause_e_move(-toolchange_settings.swap_length, MMM_TO_MMS(toolchange_settings.retract_speed));
           #else
-            current_position[E_AXIS] -= sn_settings.swap_length / planner.e_factor[active_extruder];
-            planner.buffer_line(current_position, MMM_TO_MMS(sn_settings.retract_speed), active_extruder);
+            current_position[E_AXIS] -= toolchange_settings.swap_length / planner.e_factor[active_extruder];
+            planner.buffer_line(current_position, MMM_TO_MMS(toolchange_settings.retract_speed), active_extruder);
           #endif
         }
 
         constexpr float snfr =
           #if ENABLED(SINGLENOZZLE_SWAP_PARK)
             MMM_TO_MMS(SINGLENOZZLE_PARK_XY_FEEDRATE);
           #else
             0
           #endif
         ;
 
         float old_pos[XYZ];
 
         if (!no_move) {
           COPY(old_pos, current_position);
 
           #if ENABLED(SINGLENOZZLE_SWAP_PARK)
-            current_position[X_AXIS] = sn_settings.change_point.x;
-            current_position[Y_AXIS] = sn_settings.change_point.y;
+            current_position[X_AXIS] = toolchange_settings.change_point.x;
+            current_position[Y_AXIS] = toolchange_settings.change_point.y;
           #endif
-          current_position[Z_AXIS] += sn_settings.z_raise;
+          current_position[Z_AXIS] += toolchange_settings.z_raise;
 
           do_blocking_move_to(current_position, snfr);
         }
 
         singlenozzle_temp[active_extruder] = thermalManager.target_temperature[0];
         if (singlenozzle_temp[tmp_extruder] && singlenozzle_temp[tmp_extruder] != singlenozzle_temp[active_extruder]) {
           thermalManager.setTargetHotend(singlenozzle_temp[tmp_extruder], 0);
           #if ENABLED(ULTRA_LCD)
             thermalManager.set_heating_message(0);
           #endif
           (void)thermalManager.wait_for_hotend(0, false);  // Wait for heating or cooling
         }
 
         active_extruder = tmp_extruder;
 
-        if (sn_settings.swap_length) {
+        if (toolchange_settings.swap_length) {
           #if ENABLED(ADVANCED_PAUSE_FEATURE)
-            do_pause_e_move(sn_settings.swap_length, sn_settings.prime_speed);
+            do_pause_e_move(toolchange_settings.swap_length, toolchange_settings.prime_speed);
           #else
-            current_position[E_AXIS] += sn_settings.swap_length / planner.e_factor[tmp_extruder];
-            planner.buffer_line(current_position, sn_settings.prime_speed, tmp_extruder);
+            current_position[E_AXIS] += toolchange_settings.swap_length / planner.e_factor[tmp_extruder];
+            planner.buffer_line(current_position, toolchange_settings.prime_speed, tmp_extruder);
           #endif
         }
 
         if (!no_move) do_blocking_move_to(old_pos, snfr);
 
       #elif EXTRUDERS > 1
 
         active_extruder = tmp_extruder;
 
       #endif

commit f56968ba0b8d4eaccbc9b0c7834cf0cd2f5872d8
Author: AnHardt <github@kitelab.de>
Date:   Tue Oct 16 10:38:57 2018 +0200

    New Continuous Filament Mixer (#12098)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 6d1695870d..57ad09dc0d 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -349,33 +349,20 @@
 #endif // SWITCHING_TOOLHEAD
 
 inline void invalid_extruder_error(const uint8_t e) {
   SERIAL_ECHO_START();
   SERIAL_CHAR('T');
   SERIAL_ECHO_F(e, DEC);
   SERIAL_CHAR(' ');
   SERIAL_ECHOLNPGM(MSG_INVALID_EXTRUDER);
 }
 
-#if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
-
-  inline void mixing_tool_change(const uint8_t tmp_extruder) {
-    if (tmp_extruder >= MIXING_VIRTUAL_TOOLS)
-      return invalid_extruder_error(tmp_extruder);
-
-    // T0-Tnnn: Switch virtual tool by changing the mix
-    for (uint8_t j = 0; j < MIXING_STEPPERS; j++)
-      mixing_factor[j] = mixing_virtual_tool_mix[tmp_extruder][j];
-  }
-
-#endif // MIXING_EXTRUDER && MIXING_VIRTUAL_TOOLS > 1
-
 #if ENABLED(DUAL_X_CARRIAGE)
 
   inline void dualx_tool_change(const uint8_t tmp_extruder, bool &no_move) {
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) {
         SERIAL_ECHOPGM("Dual X Carriage Mode ");
         switch (dual_x_carriage_mode) {
           case DXC_FULL_CONTROL_MODE: SERIAL_ECHOLNPGM("DXC_FULL_CONTROL_MODE"); break;
           case DXC_AUTO_PARK_MODE: SERIAL_ECHOLNPGM("DXC_AUTO_PARK_MODE"); break;
           case DXC_DUPLICATION_MODE: SERIAL_ECHOLNPGM("DXC_DUPLICATION_MODE"); break;
@@ -460,36 +447,42 @@ inline void invalid_extruder_error(const uint8_t e) {
     // No extra case for HAS_ABL in DUAL_X_CARRIAGE. Does that mean they don't work together?
   }
 
 #endif // DUAL_X_CARRIAGE
 
 /**
  * Perform a tool-change, which may result in moving the
  * previous tool out of the way and the new tool into place.
  */
 void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
-  planner.synchronize();
+  #if DISABLED(MIXING_EXTRUDER)
+    planner.synchronize();
+  #endif
 
   #if ENABLED(DUAL_X_CARRIAGE)  // Only T0 allowed if the Printer is in DXC_DUPLICATION_MODE or DXC_SCALED_DUPLICATION_MODE
     if (tmp_extruder != 0 && dxc_is_duplicating())
        return invalid_extruder_error(tmp_extruder);
   #endif
 
   #if HAS_LEVELING
     // Set current position to the physical position
     const bool leveling_was_active = planner.leveling_active;
     set_bed_leveling_enabled(false);
   #endif
 
   #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
-
-    mixing_tool_change(tmp_extruder);
+    if (tmp_extruder >= MIXING_VIRTUAL_TOOLS)
+      return invalid_extruder_error(tmp_extruder);
+    // T0-Tnnn: Switch virtual tool by changing the index to the mix
+    mixer.T(uint_fast8_t(tmp_extruder));
+    UNUSED(fr_mm_s);
+    UNUSED(no_move);
 
   #else // !MIXING_EXTRUDER || MIXING_VIRTUAL_TOOLS <= 1
 
     if (tmp_extruder >= EXTRUDERS)
       return invalid_extruder_error(tmp_extruder);
 
     if (!no_move && !all_axes_homed()) {
       no_move = true;
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("No move on toolchange");

commit 951b25163e8b9e09212594b47c26434f23dc1a1e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Oct 13 23:08:20 2018 -0500

    Extend M217 with configurable park/raise (#12076)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 0d4b0b0fd6..6d1695870d 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -28,24 +28,20 @@
 #include "temperature.h"
 
 #include "../Marlin.h"
 
 #if ENABLED(SINGLENOZZLE)
   singlenozzle_settings_t sn_settings;  // Initialized by settings.load()
   uint16_t singlenozzle_temp[EXTRUDERS];
   #if FAN_COUNT > 0
     uint8_t singlenozzle_fan_speed[EXTRUDERS];
   #endif
-  #if ENABLED(SINGLENOZZLE_SWAP_PARK)
-    #include "../libs/point_t.h"
-    const point_t singlenozzle_change_point = SINGLENOZZLE_TOOLCHANGE_POSITION;
-  #endif
 #endif
 
 #if ENABLED(PARKING_EXTRUDER) && PARKING_EXTRUDER_SOLENOIDS_DELAY > 0
   #include "../gcode/gcode.h" // for dwell()
 #endif
 
 #if ENABLED(SWITCHING_EXTRUDER) || ENABLED(SWITCHING_NOZZLE) || ENABLED(SWITCHING_TOOLHEAD)
   #include "../module/servo.h"
 #endif
 
@@ -652,47 +648,49 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
             active_extruder = tmp_extruder;
             return;
           }
         #endif
 
         #if FAN_COUNT > 0
           singlenozzle_fan_speed[active_extruder] = fan_speed[0];
           fan_speed[0] = singlenozzle_fan_speed[tmp_extruder];
         #endif
 
-        if (!no_move) set_destination_from_current();
-
         if (sn_settings.swap_length) {
           #if ENABLED(ADVANCED_PAUSE_FEATURE)
             do_pause_e_move(-sn_settings.swap_length, MMM_TO_MMS(sn_settings.retract_speed));
           #else
             current_position[E_AXIS] -= sn_settings.swap_length / planner.e_factor[active_extruder];
             planner.buffer_line(current_position, MMM_TO_MMS(sn_settings.retract_speed), active_extruder);
           #endif
         }
 
-        if (!no_move) {
-          current_position[Z_AXIS] += (
-            #if ENABLED(SINGLENOZZLE_SWAP_PARK)
-              singlenozzle_change_point.z
-            #else
-              SINGLENOZZLE_TOOLCHANGE_ZRAISE
-            #endif
-          );
+        constexpr float snfr =
+          #if ENABLED(SINGLENOZZLE_SWAP_PARK)
+            MMM_TO_MMS(SINGLENOZZLE_PARK_XY_FEEDRATE);
+          #else
+            0
+          #endif
+        ;
+
+        float old_pos[XYZ];
 
-          planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Z_AXIS], active_extruder);
+        if (!no_move) {
+          COPY(old_pos, current_position);
 
           #if ENABLED(SINGLENOZZLE_SWAP_PARK)
-            current_position[X_AXIS] = singlenozzle_change_point.x;
-            current_position[Y_AXIS] = singlenozzle_change_point.y;
-            planner.buffer_line(current_position, MMM_TO_MMS(SINGLENOZZLE_PARK_XY_FEEDRATE), active_extruder);
+            current_position[X_AXIS] = sn_settings.change_point.x;
+            current_position[Y_AXIS] = sn_settings.change_point.y;
           #endif
+          current_position[Z_AXIS] += sn_settings.z_raise;
+
+          do_blocking_move_to(current_position, snfr);
         }
 
         singlenozzle_temp[active_extruder] = thermalManager.target_temperature[0];
         if (singlenozzle_temp[tmp_extruder] && singlenozzle_temp[tmp_extruder] != singlenozzle_temp[active_extruder]) {
           thermalManager.setTargetHotend(singlenozzle_temp[tmp_extruder], 0);
           #if ENABLED(ULTRA_LCD)
             thermalManager.set_heating_message(0);
           #endif
           (void)thermalManager.wait_for_hotend(0, false);  // Wait for heating or cooling
         }
@@ -701,29 +699,21 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
 
         if (sn_settings.swap_length) {
           #if ENABLED(ADVANCED_PAUSE_FEATURE)
             do_pause_e_move(sn_settings.swap_length, sn_settings.prime_speed);
           #else
             current_position[E_AXIS] += sn_settings.swap_length / planner.e_factor[tmp_extruder];
             planner.buffer_line(current_position, sn_settings.prime_speed, tmp_extruder);
           #endif
         }
 
-        if (!no_move) {
-          #if ENABLED(SINGLENOZZLE_SWAP_PARK)
-            current_position[X_AXIS] = destination[X_AXIS];
-            current_position[Y_AXIS] = destination[Y_AXIS];
-            planner.buffer_line(current_position, MMM_TO_MMS(SINGLENOZZLE_PARK_XY_FEEDRATE), active_extruder);
-          #endif
-
-          do_blocking_move_to(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS]);
-        }
+        if (!no_move) do_blocking_move_to(old_pos, snfr);
 
       #elif EXTRUDERS > 1
 
         active_extruder = tmp_extruder;
 
       #endif
 
     #endif // HOTENDS <= 1
 
     #if DO_SWITCH_EXTRUDER

commit a44ef2789759c80cefb199e55ce5b1a2fd7b82cc
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 12 15:19:03 2018 -0500

    Outdent singlenozzle toolchange code

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index e04419c8b2..0d4b0b0fd6 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -636,103 +636,100 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
     #else // HOTENDS <= 1
 
       UNUSED(fr_mm_s);
       UNUSED(no_move);
 
       #if ENABLED(MK2_MULTIPLEXER)
         if (tmp_extruder >= E_STEPPERS) return invalid_extruder_error(tmp_extruder);
         select_multiplexed_stepper(tmp_extruder);
       #endif
 
-      #if EXTRUDERS > 1
+      #if ENABLED(SINGLENOZZLE)
 
-        #if ENABLED(SINGLENOZZLE)
+        #if ENABLED(PREVENT_COLD_EXTRUSION)
+          if (!DEBUGGING(DRYRUN) && thermalManager.targetTooColdToExtrude(active_extruder) && sn_settings.swap_length) {
+            SERIAL_ERROR_START();
+            SERIAL_ERRORLNPGM(MSG_HOTEND_TOO_COLD);
+            active_extruder = tmp_extruder;
+            return;
+          }
+        #endif
 
-          #if ENABLED(PREVENT_COLD_EXTRUSION)
-            if (!DEBUGGING(DRYRUN) && thermalManager.targetTooColdToExtrude(active_extruder) && sn_settings.swap_length) {
-              SERIAL_ERROR_START();
-              SERIAL_ERRORLNPGM(MSG_HOTEND_TOO_COLD);
-              active_extruder = tmp_extruder;
-              return;
-            }
-          #endif
+        #if FAN_COUNT > 0
+          singlenozzle_fan_speed[active_extruder] = fan_speed[0];
+          fan_speed[0] = singlenozzle_fan_speed[tmp_extruder];
+        #endif
 
-          #if FAN_COUNT > 0
-            singlenozzle_fan_speed[active_extruder] = fan_speed[0];
-            fan_speed[0] = singlenozzle_fan_speed[tmp_extruder];
-          #endif
+        if (!no_move) set_destination_from_current();
 
-          if (!no_move) set_destination_from_current();
+        if (sn_settings.swap_length) {
+          #if ENABLED(ADVANCED_PAUSE_FEATURE)
+            do_pause_e_move(-sn_settings.swap_length, MMM_TO_MMS(sn_settings.retract_speed));
+          #else
+            current_position[E_AXIS] -= sn_settings.swap_length / planner.e_factor[active_extruder];
+            planner.buffer_line(current_position, MMM_TO_MMS(sn_settings.retract_speed), active_extruder);
+          #endif
+        }
 
-          if (sn_settings.swap_length) {
-            #if ENABLED(ADVANCED_PAUSE_FEATURE)
-              do_pause_e_move(-sn_settings.swap_length, MMM_TO_MMS(sn_settings.retract_speed));
+        if (!no_move) {
+          current_position[Z_AXIS] += (
+            #if ENABLED(SINGLENOZZLE_SWAP_PARK)
+              singlenozzle_change_point.z
             #else
-              current_position[E_AXIS] -= sn_settings.swap_length / planner.e_factor[active_extruder];
-              planner.buffer_line(current_position, MMM_TO_MMS(sn_settings.retract_speed), active_extruder);
+              SINGLENOZZLE_TOOLCHANGE_ZRAISE
             #endif
-          }
+          );
 
-          if (!no_move) {
-            current_position[Z_AXIS] += (
-              #if ENABLED(SINGLENOZZLE_SWAP_PARK)
-                singlenozzle_change_point.z
-              #else
-                SINGLENOZZLE_TOOLCHANGE_ZRAISE
-              #endif
-            );
-
-            planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Z_AXIS], active_extruder);
+          planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Z_AXIS], active_extruder);
 
-            #if ENABLED(SINGLENOZZLE_SWAP_PARK)
-              current_position[X_AXIS] = singlenozzle_change_point.x;
-              current_position[Y_AXIS] = singlenozzle_change_point.y;
-              planner.buffer_line(current_position, MMM_TO_MMS(SINGLENOZZLE_PARK_XY_FEEDRATE), active_extruder);
-            #endif
-          }
+          #if ENABLED(SINGLENOZZLE_SWAP_PARK)
+            current_position[X_AXIS] = singlenozzle_change_point.x;
+            current_position[Y_AXIS] = singlenozzle_change_point.y;
+            planner.buffer_line(current_position, MMM_TO_MMS(SINGLENOZZLE_PARK_XY_FEEDRATE), active_extruder);
+          #endif
+        }
 
-          singlenozzle_temp[active_extruder] = thermalManager.target_temperature[0];
-          if (singlenozzle_temp[tmp_extruder] && singlenozzle_temp[tmp_extruder] != singlenozzle_temp[active_extruder]) {
-            thermalManager.setTargetHotend(singlenozzle_temp[tmp_extruder], 0);
-            #if ENABLED(ULTRA_LCD)
-              thermalManager.set_heating_message(0);
-            #endif
-            (void)thermalManager.wait_for_hotend(0, false);  // Wait for heating or cooling
-          }
+        singlenozzle_temp[active_extruder] = thermalManager.target_temperature[0];
+        if (singlenozzle_temp[tmp_extruder] && singlenozzle_temp[tmp_extruder] != singlenozzle_temp[active_extruder]) {
+          thermalManager.setTargetHotend(singlenozzle_temp[tmp_extruder], 0);
+          #if ENABLED(ULTRA_LCD)
+            thermalManager.set_heating_message(0);
+          #endif
+          (void)thermalManager.wait_for_hotend(0, false);  // Wait for heating or cooling
+        }
 
-          active_extruder = tmp_extruder;
+        active_extruder = tmp_extruder;
 
-          if (sn_settings.swap_length) {
-            #if ENABLED(ADVANCED_PAUSE_FEATURE)
-              do_pause_e_move(sn_settings.swap_length, sn_settings.prime_speed);
-            #else
-              current_position[E_AXIS] += sn_settings.swap_length / planner.e_factor[tmp_extruder];
-              planner.buffer_line(current_position, sn_settings.prime_speed, tmp_extruder);
-            #endif
-          }
+        if (sn_settings.swap_length) {
+          #if ENABLED(ADVANCED_PAUSE_FEATURE)
+            do_pause_e_move(sn_settings.swap_length, sn_settings.prime_speed);
+          #else
+            current_position[E_AXIS] += sn_settings.swap_length / planner.e_factor[tmp_extruder];
+            planner.buffer_line(current_position, sn_settings.prime_speed, tmp_extruder);
+          #endif
+        }
 
-          if (!no_move) {
-            #if ENABLED(SINGLENOZZLE_SWAP_PARK)
-              current_position[X_AXIS] = destination[X_AXIS];
-              current_position[Y_AXIS] = destination[Y_AXIS];
-              planner.buffer_line(current_position, MMM_TO_MMS(SINGLENOZZLE_PARK_XY_FEEDRATE), active_extruder);
-            #endif
+        if (!no_move) {
+          #if ENABLED(SINGLENOZZLE_SWAP_PARK)
+            current_position[X_AXIS] = destination[X_AXIS];
+            current_position[Y_AXIS] = destination[Y_AXIS];
+            planner.buffer_line(current_position, MMM_TO_MMS(SINGLENOZZLE_PARK_XY_FEEDRATE), active_extruder);
+          #endif
 
-            do_blocking_move_to(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS]);
-          }
-        #else // !SINGLENOZZLE
+          do_blocking_move_to(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS]);
+        }
 
-          active_extruder = tmp_extruder;
+      #elif EXTRUDERS > 1
 
-        #endif // !SINGLENOZZLE
+        active_extruder = tmp_extruder;
 
-      #endif // EXTRUDERS > 1
+      #endif
 
     #endif // HOTENDS <= 1
 
     #if DO_SWITCH_EXTRUDER
       planner.synchronize();
       move_extruder_servo(active_extruder);
     #endif
 
     #if HAS_FANMUX
       fanmux_switch(active_extruder);

commit d338e4d875235d5b9020a5f6e7d902d15756d48b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 12 15:15:20 2018 -0500

    Fix singlenozzle toolchange cold extrusion test

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 6cf8b8d502..e04419c8b2 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -641,21 +641,21 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
       #if ENABLED(MK2_MULTIPLEXER)
         if (tmp_extruder >= E_STEPPERS) return invalid_extruder_error(tmp_extruder);
         select_multiplexed_stepper(tmp_extruder);
       #endif
 
       #if EXTRUDERS > 1
 
         #if ENABLED(SINGLENOZZLE)
 
           #if ENABLED(PREVENT_COLD_EXTRUSION)
-            if ((!DEBUGGING(DRYRUN) && thermalManager.targetTooColdToExtrude(active_extruder)) || sn_settings.swap_length == 0) {
+            if (!DEBUGGING(DRYRUN) && thermalManager.targetTooColdToExtrude(active_extruder) && sn_settings.swap_length) {
               SERIAL_ERROR_START();
               SERIAL_ERRORLNPGM(MSG_HOTEND_TOO_COLD);
               active_extruder = tmp_extruder;
               return;
             }
           #endif
 
           #if FAN_COUNT > 0
             singlenozzle_fan_speed[active_extruder] = fan_speed[0];
             fan_speed[0] = singlenozzle_fan_speed[tmp_extruder];

commit 3cb5517ddbafdb0efb0cd24bb29be51ef0b0f2a9
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Wed Oct 10 17:49:59 2018 -0400

    Make singlenozzle tool-change honor no_move (#12056)
    
    ...Set no move earlier so it applies

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index abbae3ac39..6cf8b8d502 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -486,33 +486,34 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
 
   #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
 
     mixing_tool_change(tmp_extruder);
 
   #else // !MIXING_EXTRUDER || MIXING_VIRTUAL_TOOLS <= 1
 
     if (tmp_extruder >= EXTRUDERS)
       return invalid_extruder_error(tmp_extruder);
 
+    if (!no_move && !all_axes_homed()) {
+      no_move = true;
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("No move on toolchange");
+      #endif
+    }
+
     #if HOTENDS > 1
 
       const float old_feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : feedrate_mm_s;
 
       feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
 
       if (tmp_extruder != active_extruder) {
-        if (!no_move && axis_unhomed_error()) {
-          no_move = true;
-          #if ENABLED(DEBUG_LEVELING_FEATURE)
-            if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("No move on toolchange");
-          #endif
-        }
 
         #if ENABLED(DUAL_X_CARRIAGE)
 
           #if HAS_SOFTWARE_ENDSTOPS
             // Update the X software endstops early
             active_extruder = tmp_extruder;
             update_software_endstops(X_AXIS);
             active_extruder = !tmp_extruder;
 
             // Don't move the new extruder out of bounds
@@ -640,59 +641,61 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
       #if ENABLED(MK2_MULTIPLEXER)
         if (tmp_extruder >= E_STEPPERS) return invalid_extruder_error(tmp_extruder);
         select_multiplexed_stepper(tmp_extruder);
       #endif
 
       #if EXTRUDERS > 1
 
         #if ENABLED(SINGLENOZZLE)
 
           #if ENABLED(PREVENT_COLD_EXTRUSION)
-            if (!DEBUGGING(DRYRUN) && thermalManager.targetTooColdToExtrude(active_extruder)) {
+            if ((!DEBUGGING(DRYRUN) && thermalManager.targetTooColdToExtrude(active_extruder)) || sn_settings.swap_length == 0) {
               SERIAL_ERROR_START();
               SERIAL_ERRORLNPGM(MSG_HOTEND_TOO_COLD);
               active_extruder = tmp_extruder;
               return;
             }
           #endif
 
           #if FAN_COUNT > 0
             singlenozzle_fan_speed[active_extruder] = fan_speed[0];
             fan_speed[0] = singlenozzle_fan_speed[tmp_extruder];
           #endif
 
-          set_destination_from_current();
+          if (!no_move) set_destination_from_current();
 
           if (sn_settings.swap_length) {
             #if ENABLED(ADVANCED_PAUSE_FEATURE)
               do_pause_e_move(-sn_settings.swap_length, MMM_TO_MMS(sn_settings.retract_speed));
             #else
               current_position[E_AXIS] -= sn_settings.swap_length / planner.e_factor[active_extruder];
               planner.buffer_line(current_position, MMM_TO_MMS(sn_settings.retract_speed), active_extruder);
             #endif
           }
 
-          current_position[Z_AXIS] += (
-            #if ENABLED(SINGLENOZZLE_SWAP_PARK)
-              singlenozzle_change_point.z
-            #else
-              SINGLENOZZLE_TOOLCHANGE_ZRAISE
-            #endif
-          );
+          if (!no_move) {
+            current_position[Z_AXIS] += (
+              #if ENABLED(SINGLENOZZLE_SWAP_PARK)
+                singlenozzle_change_point.z
+              #else
+                SINGLENOZZLE_TOOLCHANGE_ZRAISE
+              #endif
+            );
 
-          planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Z_AXIS], active_extruder);
+            planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Z_AXIS], active_extruder);
 
-          #if ENABLED(SINGLENOZZLE_SWAP_PARK)
-            current_position[X_AXIS] = singlenozzle_change_point.x;
-            current_position[Y_AXIS] = singlenozzle_change_point.y;
-            planner.buffer_line(current_position, MMM_TO_MMS(SINGLENOZZLE_PARK_XY_FEEDRATE), active_extruder);
-          #endif
+            #if ENABLED(SINGLENOZZLE_SWAP_PARK)
+              current_position[X_AXIS] = singlenozzle_change_point.x;
+              current_position[Y_AXIS] = singlenozzle_change_point.y;
+              planner.buffer_line(current_position, MMM_TO_MMS(SINGLENOZZLE_PARK_XY_FEEDRATE), active_extruder);
+            #endif
+          }
 
           singlenozzle_temp[active_extruder] = thermalManager.target_temperature[0];
           if (singlenozzle_temp[tmp_extruder] && singlenozzle_temp[tmp_extruder] != singlenozzle_temp[active_extruder]) {
             thermalManager.setTargetHotend(singlenozzle_temp[tmp_extruder], 0);
             #if ENABLED(ULTRA_LCD)
               thermalManager.set_heating_message(0);
             #endif
             (void)thermalManager.wait_for_hotend(0, false);  // Wait for heating or cooling
           }
 
@@ -700,28 +703,29 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
 
           if (sn_settings.swap_length) {
             #if ENABLED(ADVANCED_PAUSE_FEATURE)
               do_pause_e_move(sn_settings.swap_length, sn_settings.prime_speed);
             #else
               current_position[E_AXIS] += sn_settings.swap_length / planner.e_factor[tmp_extruder];
               planner.buffer_line(current_position, sn_settings.prime_speed, tmp_extruder);
             #endif
           }
 
-          #if ENABLED(SINGLENOZZLE_SWAP_PARK)
-            current_position[X_AXIS] = destination[X_AXIS];
-            current_position[Y_AXIS] = destination[Y_AXIS];
-            planner.buffer_line(current_position, MMM_TO_MMS(SINGLENOZZLE_PARK_XY_FEEDRATE), active_extruder);
-          #endif
-
-          do_blocking_move_to(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS]);
+          if (!no_move) {
+            #if ENABLED(SINGLENOZZLE_SWAP_PARK)
+              current_position[X_AXIS] = destination[X_AXIS];
+              current_position[Y_AXIS] = destination[Y_AXIS];
+              planner.buffer_line(current_position, MMM_TO_MMS(SINGLENOZZLE_PARK_XY_FEEDRATE), active_extruder);
+            #endif
 
+            do_blocking_move_to(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS]);
+          }
         #else // !SINGLENOZZLE
 
           active_extruder = tmp_extruder;
 
         #endif // !SINGLENOZZLE
 
       #endif // EXTRUDERS > 1
 
     #endif // HOTENDS <= 1
 

commit b2c1cd7eda5aaec3ec9ef5322e9502025ce2a2f2
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Wed Oct 10 10:57:48 2018 -0400

    Allow cold change of active extruder (#12055)
    
    Followup to #11994

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index bfd79a3d64..abbae3ac39 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -643,20 +643,21 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
       #endif
 
       #if EXTRUDERS > 1
 
         #if ENABLED(SINGLENOZZLE)
 
           #if ENABLED(PREVENT_COLD_EXTRUSION)
             if (!DEBUGGING(DRYRUN) && thermalManager.targetTooColdToExtrude(active_extruder)) {
               SERIAL_ERROR_START();
               SERIAL_ERRORLNPGM(MSG_HOTEND_TOO_COLD);
+              active_extruder = tmp_extruder;
               return;
             }
           #endif
 
           #if FAN_COUNT > 0
             singlenozzle_fan_speed[active_extruder] = fan_speed[0];
             fan_speed[0] = singlenozzle_fan_speed[tmp_extruder];
           #endif
 
           set_destination_from_current();

commit d556dc18650e2185791834d7fe70b4acf45254bc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Oct 10 09:45:20 2018 -0500

    Fix and improve EEPROM storage (#12054)
    
    * Clean up Temperature PID
    * Improve EEPROM read/write/validate
    * Group `SINGLENOZZLE` saved settings
    * Group planner saved settings
    * Group filament change saved settings
    * Group skew saved settings
    * Group `FWRETRACT` saved settings

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 9b0c11dcfd..bfd79a3d64 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -23,23 +23,21 @@
 #include "tool_change.h"
 
 #include "probe.h"
 #include "motion.h"
 #include "planner.h"
 #include "temperature.h"
 
 #include "../Marlin.h"
 
 #if ENABLED(SINGLENOZZLE)
-  float singlenozzle_swap_length      = SINGLENOZZLE_SWAP_LENGTH;
-  int16_t singlenozzle_prime_speed    = SINGLENOZZLE_SWAP_PRIME_SPEED,
-          singlenozzle_retract_speed  = SINGLENOZZLE_SWAP_RETRACT_SPEED;
+  singlenozzle_settings_t sn_settings;  // Initialized by settings.load()
   uint16_t singlenozzle_temp[EXTRUDERS];
   #if FAN_COUNT > 0
     uint8_t singlenozzle_fan_speed[EXTRUDERS];
   #endif
   #if ENABLED(SINGLENOZZLE_SWAP_PARK)
     #include "../libs/point_t.h"
     const point_t singlenozzle_change_point = SINGLENOZZLE_TOOLCHANGE_POSITION;
   #endif
 #endif
 
@@ -145,78 +143,78 @@
        */
 
       // STEP 1
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) DEBUG_POS("Start Autopark", current_position);
       #endif
       current_position[Z_AXIS] += PARKING_EXTRUDER_SECURITY_RAISE;
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) DEBUG_POS("(1) Raise Z-Axis", current_position);
       #endif
-      planner.buffer_line(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
+      planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Z_AXIS], active_extruder);
       planner.synchronize();
 
       // STEP 2
       current_position[X_AXIS] = parkingposx[active_extruder] + hotend_offset[X_AXIS][active_extruder];
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) {
           SERIAL_ECHOLNPAIR("(2) Park extruder ", int(active_extruder));
           DEBUG_POS("Moving ParkPos", current_position);
         }
       #endif
-      planner.buffer_line(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
+      planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
       planner.synchronize();
 
       // STEP 3
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(3) Disengage magnet ");
       #endif
       pe_deactivate_magnet(active_extruder);
 
       // STEP 4
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(4) Move to position near new extruder");
       #endif
       current_position[X_AXIS] += active_extruder ? -10 : 10; // move 10mm away from parked extruder
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) DEBUG_POS("Move away from parked extruder", current_position);
       #endif
-      planner.buffer_line(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
+      planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
       planner.synchronize();
 
       // STEP 5
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(5) Engage magnetic field");
       #endif
 
       #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
         pe_activate_magnet(active_extruder); //just save power for inverted magnets
       #endif
       pe_activate_magnet(tmp_extruder);
 
       // STEP 6
       current_position[X_AXIS] = grabpos + (tmp_extruder ? -10 : 10);
-      planner.buffer_line(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
+      planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
       current_position[X_AXIS] = grabpos;
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) DEBUG_POS("(6) Unpark extruder", current_position);
       #endif
-      planner.buffer_line(current_position, planner.max_feedrate_mm_s[X_AXIS]/2, active_extruder);
+      planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS]/2, active_extruder);
       planner.synchronize();
 
       // Step 7
       current_position[X_AXIS] = midpos - hotend_offset[X_AXIS][tmp_extruder];
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) DEBUG_POS("(7) Move midway between hotends", current_position);
       #endif
-      planner.buffer_line(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
+      planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
       planner.synchronize();
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         SERIAL_ECHOLNPGM("Autopark done.");
       #endif
     }
     else { // nomove == true
       // Only engage magnetic field for new extruder
       pe_activate_magnet(tmp_extruder);
       #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
         pe_activate_magnet(active_extruder); // Just save power for inverted magnets
@@ -252,99 +250,99 @@
      */
 
     // STEP 1
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("Starting Toolhead change", current_position);
     #endif
     current_position[Z_AXIS] += SWITCHING_TOOLHEAD_SECURITY_RAISE;
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("(1) Raise Z-Axis", current_position);
     #endif
-    planner.buffer_line(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
+    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Z_AXIS], active_extruder);
     planner.synchronize();
 
     // STEP 2
     current_position[X_AXIS] = placexpos;
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) {
         SERIAL_ECHOLNPAIR("(2) Place old tool ", int(active_extruder));
         DEBUG_POS("Move X SwitchPos", current_position);
       }
     #endif
-    planner.buffer_line(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
+    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
     planner.synchronize();
 
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS - SWITCHING_TOOLHEAD_Y_SECURITY;
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos + Security", current_position);
     #endif
-    planner.buffer_line(current_position, planner.max_feedrate_mm_s[Y_AXIS], active_extruder);
+    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS], active_extruder);
     planner.synchronize();
 
     // STEP 3
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(3) Unlock and Place Toolhead");
     #endif
     MOVE_SERVO(SWITCHING_TOOLHEAD_SERVO_NR, angles[1]);
     safe_delay(500);
 
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS;
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos", current_position);
     #endif
-    planner.buffer_line(current_position,(planner.max_feedrate_mm_s[Y_AXIS] * 0.5), active_extruder);
+    planner.buffer_line(current_position,(planner.settings.max_feedrate_mm_s[Y_AXIS] * 0.5), active_extruder);
     planner.synchronize();
     safe_delay(200);
     current_position[Y_AXIS] -= SWITCHING_TOOLHEAD_Y_CLEAR;
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("Move back Y clear", current_position);
     #endif
-    planner.buffer_line(current_position, planner.max_feedrate_mm_s[Y_AXIS], active_extruder); // move away from docked toolhead
+    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS], active_extruder); // move away from docked toolhead
     planner.synchronize();
 
     // STEP 4
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(4) Move to new toolhead position");
     #endif
     current_position[X_AXIS] = grabxpos;
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("Move to new toolhead X", current_position);
     #endif
-    planner.buffer_line(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
+    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
     planner.synchronize();
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS - SWITCHING_TOOLHEAD_Y_SECURITY;
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos + Security", current_position);
     #endif
-    planner.buffer_line(current_position, planner.max_feedrate_mm_s[Y_AXIS], active_extruder);
+    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS], active_extruder);
     planner.synchronize();
 
     // STEP 5
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(5) Grab and lock new toolhead ");
     #endif
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS;
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos", current_position);
     #endif
-    planner.buffer_line(current_position, planner.max_feedrate_mm_s[Y_AXIS] * 0.5, active_extruder);
+    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS] * 0.5, active_extruder);
     planner.synchronize();
 
     safe_delay(200);
     MOVE_SERVO(SWITCHING_TOOLHEAD_SERVO_NR, angles[0]);
     safe_delay(500);
 
     current_position[Y_AXIS] -= SWITCHING_TOOLHEAD_Y_CLEAR;
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("Move back Y clear", current_position);
     #endif
-    planner.buffer_line(current_position, planner.max_feedrate_mm_s[Y_AXIS], active_extruder); // move away from docked toolhead
+    planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Y_AXIS], active_extruder); // move away from docked toolhead
     planner.synchronize();
 
     // STEP 6
     current_position[Z_AXIS] += hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("(6) Apply Z offset", current_position);
     #endif
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
@@ -406,23 +404,23 @@ inline void invalid_extruder_error(const uint8_t e) {
           SERIAL_ECHOLNPAIR("Lower to ", current_position[Z_AXIS]);
         }
       #endif
       // Park old head: 1) raise 2) move to park position 3) lower
 
       #define CUR_X current_position[X_AXIS]
       #define CUR_Y current_position[Y_AXIS]
       #define CUR_Z current_position[Z_AXIS]
       #define CUR_E current_position[E_AXIS]
 
-      planner.buffer_line(CUR_X, CUR_Y, raised_z, CUR_E, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
-      planner.buffer_line(xhome, CUR_Y, raised_z, CUR_E, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
-      planner.buffer_line(xhome, CUR_Y, CUR_Z,    CUR_E, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
+      planner.buffer_line(CUR_X, CUR_Y, raised_z, CUR_E, planner.settings.max_feedrate_mm_s[Z_AXIS], active_extruder);
+      planner.buffer_line(xhome, CUR_Y, raised_z, CUR_E, planner.settings.max_feedrate_mm_s[X_AXIS], active_extruder);
+      planner.buffer_line(xhome, CUR_Y, CUR_Z,    CUR_E, planner.settings.max_feedrate_mm_s[Z_AXIS], active_extruder);
 
       planner.synchronize();
     }
 
     // Apply Y & Z extruder offset (X offset is used as home pos with Dual X)
     current_position[Y_AXIS] -= hotend_offset[Y_AXIS][active_extruder] - hotend_offset[Y_AXIS][tmp_extruder];
     current_position[Z_AXIS] -= hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
 
     // Activate the new extruder ahead of calling set_axis_is_at_home!
     active_extruder = tmp_extruder;
@@ -549,21 +547,21 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
             constexpr float zdiff = 0;
             parking_extruder_tool_change(tmp_extruder, no_move);
           #elif ENABLED(SWITCHING_TOOLHEAD) // Switching Toolhead
             constexpr float zdiff = 0;
             switching_toolhead_tool_change(tmp_extruder, fr_mm_s, no_move);
           #else
             const float zdiff = hotend_offset[Z_AXIS][tmp_extruder] - hotend_offset[Z_AXIS][active_extruder];
             #if ENABLED(SWITCHING_NOZZLE)
               // Always raise by at least 1 to avoid workpiece
               current_position[Z_AXIS] += MAX(-zdiff, 0.0) + 1;
-              planner.buffer_line(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
+              planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Z_AXIS], active_extruder);
               move_nozzle_servo(tmp_extruder);
             #endif
           #endif
 
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) {
               SERIAL_ECHOPAIR("Offset Tool XY by { ", xdiff);
               SERIAL_ECHOPAIR(", ", ydiff);
               SERIAL_ECHOPAIR(", ", zdiff);
               SERIAL_ECHOLNPGM(" }");
@@ -588,42 +586,42 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
           const bool safe_to_move = current_position[Z_AXIS] < delta_clip_start_height - 1;
         #else
           constexpr bool safe_to_move = true;
         #endif
 
         // Raise, move, and lower again
         if (safe_to_move && !no_move && IsRunning()) {
           #if DISABLED(SWITCHING_NOZZLE)
             // Do a small lift to avoid the workpiece in the move back (below)
             current_position[Z_AXIS] += 1.0;
-            planner.buffer_line(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
+            planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Z_AXIS], active_extruder);
           #endif
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) DEBUG_POS("Move back", destination);
           #endif
           #if ENABLED(DUAL_X_CARRIAGE)
             // Dual x carriage does not properly apply these to current position due to command ordering
             // So we apply the offsets for y and z to the destination here. X cannot have an offset in this mode
             // as it is utilized for X2 home position.
             destination[Y_AXIS] -= hotend_offset[Y_AXIS][active_extruder] - hotend_offset[Y_AXIS][tmp_extruder];
             destination[Z_AXIS] -= hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
           #endif
           // Move back to the original (or tweaked) position
           do_blocking_move_to(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS]);
           #if ENABLED(DUAL_X_CARRIAGE)
             active_extruder_parked = false;
           #endif
         }
         #if ENABLED(SWITCHING_NOZZLE)
           else {
             // Move back down. (Including when the new tool is higher.)
-            do_blocking_move_to_z(destination[Z_AXIS], planner.max_feedrate_mm_s[Z_AXIS]);
+            do_blocking_move_to_z(destination[Z_AXIS], planner.settings.max_feedrate_mm_s[Z_AXIS]);
           }
         #endif
       } // (tmp_extruder != active_extruder)
 
       planner.synchronize();
 
       #if ENABLED(EXT_SOLENOID) && DISABLED(PARKING_EXTRUDER)
         disable_all_solenoids();
         enable_solenoid_on_active_extruder();
       #endif
@@ -656,62 +654,62 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
             }
           #endif
 
           #if FAN_COUNT > 0
             singlenozzle_fan_speed[active_extruder] = fan_speed[0];
             fan_speed[0] = singlenozzle_fan_speed[tmp_extruder];
           #endif
 
           set_destination_from_current();
 
-          if (singlenozzle_swap_length) {
+          if (sn_settings.swap_length) {
             #if ENABLED(ADVANCED_PAUSE_FEATURE)
-              do_pause_e_move(-singlenozzle_swap_length, MMM_TO_MMS(singlenozzle_retract_speed));
+              do_pause_e_move(-sn_settings.swap_length, MMM_TO_MMS(sn_settings.retract_speed));
             #else
-              current_position[E_AXIS] -= singlenozzle_swap_length / planner.e_factor[active_extruder];
-              planner.buffer_line(current_position, MMM_TO_MMS(singlenozzle_retract_speed), active_extruder);
+              current_position[E_AXIS] -= sn_settings.swap_length / planner.e_factor[active_extruder];
+              planner.buffer_line(current_position, MMM_TO_MMS(sn_settings.retract_speed), active_extruder);
             #endif
           }
 
           current_position[Z_AXIS] += (
             #if ENABLED(SINGLENOZZLE_SWAP_PARK)
               singlenozzle_change_point.z
             #else
               SINGLENOZZLE_TOOLCHANGE_ZRAISE
             #endif
           );
 
-          planner.buffer_line(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
+          planner.buffer_line(current_position, planner.settings.max_feedrate_mm_s[Z_AXIS], active_extruder);
 
           #if ENABLED(SINGLENOZZLE_SWAP_PARK)
             current_position[X_AXIS] = singlenozzle_change_point.x;
             current_position[Y_AXIS] = singlenozzle_change_point.y;
             planner.buffer_line(current_position, MMM_TO_MMS(SINGLENOZZLE_PARK_XY_FEEDRATE), active_extruder);
           #endif
 
           singlenozzle_temp[active_extruder] = thermalManager.target_temperature[0];
           if (singlenozzle_temp[tmp_extruder] && singlenozzle_temp[tmp_extruder] != singlenozzle_temp[active_extruder]) {
             thermalManager.setTargetHotend(singlenozzle_temp[tmp_extruder], 0);
             #if ENABLED(ULTRA_LCD)
               thermalManager.set_heating_message(0);
             #endif
             (void)thermalManager.wait_for_hotend(0, false);  // Wait for heating or cooling
           }
 
           active_extruder = tmp_extruder;
 
-          if (singlenozzle_swap_length) {
+          if (sn_settings.swap_length) {
             #if ENABLED(ADVANCED_PAUSE_FEATURE)
-              do_pause_e_move(singlenozzle_swap_length, singlenozzle_prime_speed);
+              do_pause_e_move(sn_settings.swap_length, sn_settings.prime_speed);
             #else
-              current_position[E_AXIS] += singlenozzle_swap_length / planner.e_factor[tmp_extruder];
-              planner.buffer_line(current_position, singlenozzle_prime_speed, tmp_extruder);
+              current_position[E_AXIS] += sn_settings.swap_length / planner.e_factor[tmp_extruder];
+              planner.buffer_line(current_position, sn_settings.prime_speed, tmp_extruder);
             #endif
           }
 
           #if ENABLED(SINGLENOZZLE_SWAP_PARK)
             current_position[X_AXIS] = destination[X_AXIS];
             current_position[Y_AXIS] = destination[Y_AXIS];
             planner.buffer_line(current_position, MMM_TO_MMS(SINGLENOZZLE_PARK_XY_FEEDRATE), active_extruder);
           #endif
 
           do_blocking_move_to(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS]);

commit ee253991d4eeecacd022833ca72eff1c344b54ba
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Mon Oct 8 16:39:55 2018 -0400

    Various fixups for single-nozzle filament swap (#12036)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 36a89e951f..9b0c11dcfd 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -656,45 +656,45 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
             }
           #endif
 
           #if FAN_COUNT > 0
             singlenozzle_fan_speed[active_extruder] = fan_speed[0];
             fan_speed[0] = singlenozzle_fan_speed[tmp_extruder];
           #endif
 
           set_destination_from_current();
 
+          if (singlenozzle_swap_length) {
+            #if ENABLED(ADVANCED_PAUSE_FEATURE)
+              do_pause_e_move(-singlenozzle_swap_length, MMM_TO_MMS(singlenozzle_retract_speed));
+            #else
+              current_position[E_AXIS] -= singlenozzle_swap_length / planner.e_factor[active_extruder];
+              planner.buffer_line(current_position, MMM_TO_MMS(singlenozzle_retract_speed), active_extruder);
+            #endif
+          }
+
           current_position[Z_AXIS] += (
             #if ENABLED(SINGLENOZZLE_SWAP_PARK)
               singlenozzle_change_point.z
             #else
               SINGLENOZZLE_TOOLCHANGE_ZRAISE
             #endif
           );
 
           planner.buffer_line(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
 
           #if ENABLED(SINGLENOZZLE_SWAP_PARK)
             current_position[X_AXIS] = singlenozzle_change_point.x;
             current_position[Y_AXIS] = singlenozzle_change_point.y;
-            planner.buffer_line(current_position, planner.max_feedrate_mm_s[Y_AXIS], active_extruder);
+            planner.buffer_line(current_position, MMM_TO_MMS(SINGLENOZZLE_PARK_XY_FEEDRATE), active_extruder);
           #endif
 
-          if (singlenozzle_swap_length) {
-            #if ENABLED(ADVANCED_PAUSE_FEATURE)
-              do_pause_e_move(-singlenozzle_swap_length, MMM_TO_MMS(singlenozzle_retract_speed));
-            #else
-              current_position[E_AXIS] -= singlenozzle_swap_length / planner.e_factor[active_extruder];
-              planner.buffer_line(current_position, MMM_TO_MMS(singlenozzle_retract_speed), active_extruder);
-            #endif
-          }
-
           singlenozzle_temp[active_extruder] = thermalManager.target_temperature[0];
           if (singlenozzle_temp[tmp_extruder] && singlenozzle_temp[tmp_extruder] != singlenozzle_temp[active_extruder]) {
             thermalManager.setTargetHotend(singlenozzle_temp[tmp_extruder], 0);
             #if ENABLED(ULTRA_LCD)
               thermalManager.set_heating_message(0);
             #endif
             (void)thermalManager.wait_for_hotend(0, false);  // Wait for heating or cooling
           }
 
           active_extruder = tmp_extruder;
@@ -704,21 +704,21 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
               do_pause_e_move(singlenozzle_swap_length, singlenozzle_prime_speed);
             #else
               current_position[E_AXIS] += singlenozzle_swap_length / planner.e_factor[tmp_extruder];
               planner.buffer_line(current_position, singlenozzle_prime_speed, tmp_extruder);
             #endif
           }
 
           #if ENABLED(SINGLENOZZLE_SWAP_PARK)
             current_position[X_AXIS] = destination[X_AXIS];
             current_position[Y_AXIS] = destination[Y_AXIS];
-            planner.buffer_line(current_position, planner.max_feedrate_mm_s[Y_AXIS], active_extruder);
+            planner.buffer_line(current_position, MMM_TO_MMS(SINGLENOZZLE_PARK_XY_FEEDRATE), active_extruder);
           #endif
 
           do_blocking_move_to(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS]);
 
         #else // !SINGLENOZZLE
 
           active_extruder = tmp_extruder;
 
         #endif // !SINGLENOZZLE
 

commit 74cd6cb4fc90e4c483e7a97a313c0257790f1375
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Oct 7 18:06:14 2018 -0400

    Single nozzle filament change (#11994)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 2b840491c8..36a89e951f 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -18,23 +18,38 @@
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
 #include "tool_change.h"
 
 #include "probe.h"
 #include "motion.h"
 #include "planner.h"
+#include "temperature.h"
 
 #include "../Marlin.h"
 
+#if ENABLED(SINGLENOZZLE)
+  float singlenozzle_swap_length      = SINGLENOZZLE_SWAP_LENGTH;
+  int16_t singlenozzle_prime_speed    = SINGLENOZZLE_SWAP_PRIME_SPEED,
+          singlenozzle_retract_speed  = SINGLENOZZLE_SWAP_RETRACT_SPEED;
+  uint16_t singlenozzle_temp[EXTRUDERS];
+  #if FAN_COUNT > 0
+    uint8_t singlenozzle_fan_speed[EXTRUDERS];
+  #endif
+  #if ENABLED(SINGLENOZZLE_SWAP_PARK)
+    #include "../libs/point_t.h"
+    const point_t singlenozzle_change_point = SINGLENOZZLE_TOOLCHANGE_POSITION;
+  #endif
+#endif
+
 #if ENABLED(PARKING_EXTRUDER) && PARKING_EXTRUDER_SOLENOIDS_DELAY > 0
   #include "../gcode/gcode.h" // for dwell()
 #endif
 
 #if ENABLED(SWITCHING_EXTRUDER) || ENABLED(SWITCHING_NOZZLE) || ENABLED(SWITCHING_TOOLHEAD)
   #include "../module/servo.h"
 #endif
 
 #if ENABLED(EXT_SOLENOID) && DISABLED(PARKING_EXTRUDER)
   #include "../feature/solenoid.h"
@@ -618,30 +633,103 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
       #if HAS_SOFTWARE_ENDSTOPS && ENABLED(DUAL_X_CARRIAGE)
         update_software_endstops(X_AXIS);
       #endif
 
     #else // HOTENDS <= 1
 
       UNUSED(fr_mm_s);
       UNUSED(no_move);
 
       #if ENABLED(MK2_MULTIPLEXER)
-        if (tmp_extruder >= E_STEPPERS)
-          return invalid_extruder_error(tmp_extruder);
-
+        if (tmp_extruder >= E_STEPPERS) return invalid_extruder_error(tmp_extruder);
         select_multiplexed_stepper(tmp_extruder);
       #endif
 
       #if EXTRUDERS > 1
-        // Set the new active extruder
-        active_extruder = tmp_extruder;
-      #endif
+
+        #if ENABLED(SINGLENOZZLE)
+
+          #if ENABLED(PREVENT_COLD_EXTRUSION)
+            if (!DEBUGGING(DRYRUN) && thermalManager.targetTooColdToExtrude(active_extruder)) {
+              SERIAL_ERROR_START();
+              SERIAL_ERRORLNPGM(MSG_HOTEND_TOO_COLD);
+              return;
+            }
+          #endif
+
+          #if FAN_COUNT > 0
+            singlenozzle_fan_speed[active_extruder] = fan_speed[0];
+            fan_speed[0] = singlenozzle_fan_speed[tmp_extruder];
+          #endif
+
+          set_destination_from_current();
+
+          current_position[Z_AXIS] += (
+            #if ENABLED(SINGLENOZZLE_SWAP_PARK)
+              singlenozzle_change_point.z
+            #else
+              SINGLENOZZLE_TOOLCHANGE_ZRAISE
+            #endif
+          );
+
+          planner.buffer_line(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
+
+          #if ENABLED(SINGLENOZZLE_SWAP_PARK)
+            current_position[X_AXIS] = singlenozzle_change_point.x;
+            current_position[Y_AXIS] = singlenozzle_change_point.y;
+            planner.buffer_line(current_position, planner.max_feedrate_mm_s[Y_AXIS], active_extruder);
+          #endif
+
+          if (singlenozzle_swap_length) {
+            #if ENABLED(ADVANCED_PAUSE_FEATURE)
+              do_pause_e_move(-singlenozzle_swap_length, MMM_TO_MMS(singlenozzle_retract_speed));
+            #else
+              current_position[E_AXIS] -= singlenozzle_swap_length / planner.e_factor[active_extruder];
+              planner.buffer_line(current_position, MMM_TO_MMS(singlenozzle_retract_speed), active_extruder);
+            #endif
+          }
+
+          singlenozzle_temp[active_extruder] = thermalManager.target_temperature[0];
+          if (singlenozzle_temp[tmp_extruder] && singlenozzle_temp[tmp_extruder] != singlenozzle_temp[active_extruder]) {
+            thermalManager.setTargetHotend(singlenozzle_temp[tmp_extruder], 0);
+            #if ENABLED(ULTRA_LCD)
+              thermalManager.set_heating_message(0);
+            #endif
+            (void)thermalManager.wait_for_hotend(0, false);  // Wait for heating or cooling
+          }
+
+          active_extruder = tmp_extruder;
+
+          if (singlenozzle_swap_length) {
+            #if ENABLED(ADVANCED_PAUSE_FEATURE)
+              do_pause_e_move(singlenozzle_swap_length, singlenozzle_prime_speed);
+            #else
+              current_position[E_AXIS] += singlenozzle_swap_length / planner.e_factor[tmp_extruder];
+              planner.buffer_line(current_position, singlenozzle_prime_speed, tmp_extruder);
+            #endif
+          }
+
+          #if ENABLED(SINGLENOZZLE_SWAP_PARK)
+            current_position[X_AXIS] = destination[X_AXIS];
+            current_position[Y_AXIS] = destination[Y_AXIS];
+            planner.buffer_line(current_position, planner.max_feedrate_mm_s[Y_AXIS], active_extruder);
+          #endif
+
+          do_blocking_move_to(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS]);
+
+        #else // !SINGLENOZZLE
+
+          active_extruder = tmp_extruder;
+
+        #endif // !SINGLENOZZLE
+
+      #endif // EXTRUDERS > 1
 
     #endif // HOTENDS <= 1
 
     #if DO_SWITCH_EXTRUDER
       planner.synchronize();
       move_extruder_servo(active_extruder);
     #endif
 
     #if HAS_FANMUX
       fanmux_switch(active_extruder);

commit 1104054d7347668a61e90fb6216e22afae2ef9f3
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Mon Sep 24 10:40:48 2018 -0400

    2.0 IDEX Independent z offset and other fixes (#11862)
    
    * Add Formbot Raptor board
    
    Co-Authored-By: InsanityAutomation <insanityautomation@users.noreply.github.com>
    
    * Add a second Z probe Z offset
    
    Co-Authored-By: InsanityAutomation <insanityautomation@users.noreply.github.com>
    
    * Modify method to utilize live adjustment of hotend z offset
    
    Should probably move config option to babystepping and rename as it may now apply to all multiextruder systems
    
    * Move config item and catchup other code to current method

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 3b66da2217..2b840491c8 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -15,27 +15,26 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
 #include "tool_change.h"
 
+#include "probe.h"
 #include "motion.h"
 #include "planner.h"
 
 #include "../Marlin.h"
 
-#include "../inc/MarlinConfig.h"
-
 #if ENABLED(PARKING_EXTRUDER) && PARKING_EXTRUDER_SOLENOIDS_DELAY > 0
   #include "../gcode/gcode.h" // for dwell()
 #endif
 
 #if ENABLED(SWITCHING_EXTRUDER) || ENABLED(SWITCHING_NOZZLE) || ENABLED(SWITCHING_TOOLHEAD)
   #include "../module/servo.h"
 #endif
 
 #if ENABLED(EXT_SOLENOID) && DISABLED(PARKING_EXTRUDER)
   #include "../feature/solenoid.h"
@@ -50,20 +49,24 @@
 #endif
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if HAS_FANMUX
   #include "../feature/fanmux.h"
 #endif
 
+#if ENABLED(ULTIPANEL)
+  #include "../lcd/ultralcd.h"
+#endif
+
 #if DO_SWITCH_EXTRUDER
 
   #if EXTRUDERS > 3
     #define _SERVO_NR(E) ((E) < 2 ? SWITCHING_EXTRUDER_SERVO_NR : SWITCHING_EXTRUDER_E23_SERVO_NR)
   #else
     #define _SERVO_NR(E) SWITCHING_EXTRUDER_SERVO_NR
   #endif
 
   void move_extruder_servo(const uint8_t e) {
     planner.synchronize();
@@ -491,25 +494,38 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
           #endif
         }
 
         #if ENABLED(DUAL_X_CARRIAGE)
 
           #if HAS_SOFTWARE_ENDSTOPS
             // Update the X software endstops early
             active_extruder = tmp_extruder;
             update_software_endstops(X_AXIS);
             active_extruder = !tmp_extruder;
+
+            // Don't move the new extruder out of bounds
+            if (!WITHIN(current_position[X_AXIS], soft_endstop_min[X_AXIS], soft_endstop_max[X_AXIS]))
+              no_move = true;
+
+          #else
+              // No software endstops? Use the configured limits
+              if (active_extruder == 0) {
+                if (!WITHIN(current_position[X_AXIS], X2_MIN_POS, X2_MAX_POS))
+                  no_move = true;
+              }
+              else if (!WITHIN(current_position[X_AXIS], X1_MIN_POS, X1_MAX_POS))
+                no_move = true;
           #endif
 
-          // Don't move the new extruder out of bounds
-          if (!WITHIN(current_position[X_AXIS], soft_endstop_min[X_AXIS], soft_endstop_max[X_AXIS]))
-            no_move = true;
+          #if ENABLED(ULTIPANEL)
+            lcd_return_to_status();
+          #endif
 
           if (!no_move) set_destination_from_current();
           dualx_tool_change(tmp_extruder, no_move); // Can modify no_move
 
         #else // !DUAL_X_CARRIAGE
 
           set_destination_from_current();
 
           const float xdiff = hotend_offset[X_AXIS][tmp_extruder] - hotend_offset[X_AXIS][active_extruder],
                       ydiff = hotend_offset[Y_AXIS][tmp_extruder] - hotend_offset[Y_AXIS][active_extruder];
@@ -562,20 +578,27 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
         // Raise, move, and lower again
         if (safe_to_move && !no_move && IsRunning()) {
           #if DISABLED(SWITCHING_NOZZLE)
             // Do a small lift to avoid the workpiece in the move back (below)
             current_position[Z_AXIS] += 1.0;
             planner.buffer_line(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
           #endif
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) DEBUG_POS("Move back", destination);
           #endif
+          #if ENABLED(DUAL_X_CARRIAGE)
+            // Dual x carriage does not properly apply these to current position due to command ordering
+            // So we apply the offsets for y and z to the destination here. X cannot have an offset in this mode
+            // as it is utilized for X2 home position.
+            destination[Y_AXIS] -= hotend_offset[Y_AXIS][active_extruder] - hotend_offset[Y_AXIS][tmp_extruder];
+            destination[Z_AXIS] -= hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
+          #endif
           // Move back to the original (or tweaked) position
           do_blocking_move_to(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS]);
           #if ENABLED(DUAL_X_CARRIAGE)
             active_extruder_parked = false;
           #endif
         }
         #if ENABLED(SWITCHING_NOZZLE)
           else {
             // Move back down. (Including when the new tool is higher.)
             do_blocking_move_to_z(destination[Z_AXIS], planner.max_feedrate_mm_s[Z_AXIS]);

commit 17494099a96fb6bc5a27b98ac2aa458273378880
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 19 03:01:55 2018 -0500

    Fix parking_extruder_tool_change
    
    Fix #11872

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index a1e6f3c17c..3b66da2217 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -102,21 +102,21 @@
   void pe_set_magnet(const uint8_t extruder_num, const uint8_t state) {
     switch (extruder_num) {
       case 1: OUT_WRITE(SOL1_PIN, state); break;
       default: OUT_WRITE(SOL0_PIN, state); break;
     }
     #if PARKING_EXTRUDER_SOLENOIDS_DELAY > 0
       gcode.dwell(PARKING_EXTRUDER_SOLENOIDS_DELAY);
     #endif
   }
 
-  inline void parking_extruder_tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
+  inline void parking_extruder_tool_change(const uint8_t tmp_extruder, bool no_move) {
     if (!no_move) {
 
       const float parkingposx[] = PARKING_EXTRUDER_PARKING_X,
                   midpos = (parkingposx[0] + parkingposx[1]) * 0.5 + hotend_offset[X_AXIS][active_extruder],
                   grabpos = parkingposx[tmp_extruder] + hotend_offset[X_AXIS][active_extruder]
                             + (tmp_extruder == 0 ? -(PARKING_EXTRUDER_GRAB_DISTANCE) : PARKING_EXTRUDER_GRAB_DISTANCE);
       /**
        * 1. Raise Z-Axis to give enough clearance
        * 2. Move to park position of old extruder
        * 3. Disengage magnetic field, wait for delay

commit 0780913848eea5048947808dfcc9143131f094d3
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Mon Sep 17 01:06:22 2018 -0500

    IDEX Improvements (#11848)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index a1cb42aa23..a1e6f3c17c 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -359,20 +359,22 @@ inline void invalid_extruder_error(const uint8_t e) {
 
 #if ENABLED(DUAL_X_CARRIAGE)
 
   inline void dualx_tool_change(const uint8_t tmp_extruder, bool &no_move) {
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) {
         SERIAL_ECHOPGM("Dual X Carriage Mode ");
         switch (dual_x_carriage_mode) {
           case DXC_FULL_CONTROL_MODE: SERIAL_ECHOLNPGM("DXC_FULL_CONTROL_MODE"); break;
           case DXC_AUTO_PARK_MODE: SERIAL_ECHOLNPGM("DXC_AUTO_PARK_MODE"); break;
+          case DXC_DUPLICATION_MODE: SERIAL_ECHOLNPGM("DXC_DUPLICATION_MODE"); break;
+          case DXC_SCALED_DUPLICATION_MODE: SERIAL_ECHOLNPGM("DXC_SCALED_DUPLICATION_MODE"); break;
         }
       }
     #endif
 
     const float xhome = x_home_pos(active_extruder);
     if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE
         && IsRunning()
         && (delayed_move_time || current_position[X_AXIS] != xhome)
     ) {
       float raised_z = current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT;
@@ -448,23 +450,22 @@ inline void invalid_extruder_error(const uint8_t e) {
 
 #endif // DUAL_X_CARRIAGE
 
 /**
  * Perform a tool-change, which may result in moving the
  * previous tool out of the way and the new tool into place.
  */
 void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
   planner.synchronize();
 
-  #if ENABLED(DUAL_X_CARRIAGE)
-    // Only T0 allowed in DXC_DUPLICATION_MODE
-    if (tmp_extruder != 0 && dual_x_carriage_mode == DXC_DUPLICATION_MODE)
+  #if ENABLED(DUAL_X_CARRIAGE)  // Only T0 allowed if the Printer is in DXC_DUPLICATION_MODE or DXC_SCALED_DUPLICATION_MODE
+    if (tmp_extruder != 0 && dxc_is_duplicating())
        return invalid_extruder_error(tmp_extruder);
   #endif
 
   #if HAS_LEVELING
     // Set current position to the physical position
     const bool leveling_was_active = planner.leveling_active;
     set_bed_leveling_enabled(false);
   #endif
 
   #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1

commit c437bb08f12f1c0535cc78a761b49a18f2dc2a12
Author: Thomas Moore <tcm0116@users.noreply.github.com>
Date:   Sun Sep 16 22:24:15 2018 -0400

    Overhaul of the planner (#11578)
    
    - Move FWRETRACT to the planner
    - Combine leveling, skew, etc. in a single modifier method
    - Have kinematic and non-kinematic moves call one planner method

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 7c4b52aa8b..a1cb42aa23 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -127,78 +127,78 @@
        */
 
       // STEP 1
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) DEBUG_POS("Start Autopark", current_position);
       #endif
       current_position[Z_AXIS] += PARKING_EXTRUDER_SECURITY_RAISE;
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) DEBUG_POS("(1) Raise Z-Axis", current_position);
       #endif
-      planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
+      planner.buffer_line(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
       planner.synchronize();
 
       // STEP 2
       current_position[X_AXIS] = parkingposx[active_extruder] + hotend_offset[X_AXIS][active_extruder];
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) {
           SERIAL_ECHOLNPAIR("(2) Park extruder ", int(active_extruder));
           DEBUG_POS("Moving ParkPos", current_position);
         }
       #endif
-      planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
+      planner.buffer_line(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
       planner.synchronize();
 
       // STEP 3
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(3) Disengage magnet ");
       #endif
       pe_deactivate_magnet(active_extruder);
 
       // STEP 4
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(4) Move to position near new extruder");
       #endif
       current_position[X_AXIS] += active_extruder ? -10 : 10; // move 10mm away from parked extruder
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) DEBUG_POS("Move away from parked extruder", current_position);
       #endif
-      planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
+      planner.buffer_line(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
       planner.synchronize();
 
       // STEP 5
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(5) Engage magnetic field");
       #endif
 
       #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
         pe_activate_magnet(active_extruder); //just save power for inverted magnets
       #endif
       pe_activate_magnet(tmp_extruder);
 
       // STEP 6
       current_position[X_AXIS] = grabpos + (tmp_extruder ? -10 : 10);
-      planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
+      planner.buffer_line(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
       current_position[X_AXIS] = grabpos;
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) DEBUG_POS("(6) Unpark extruder", current_position);
       #endif
-      planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS]/2, active_extruder);
+      planner.buffer_line(current_position, planner.max_feedrate_mm_s[X_AXIS]/2, active_extruder);
       planner.synchronize();
 
       // Step 7
       current_position[X_AXIS] = midpos - hotend_offset[X_AXIS][tmp_extruder];
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) DEBUG_POS("(7) Move midway between hotends", current_position);
       #endif
-      planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
+      planner.buffer_line(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
       planner.synchronize();
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         SERIAL_ECHOLNPGM("Autopark done.");
       #endif
     }
     else { // nomove == true
       // Only engage magnetic field for new extruder
       pe_activate_magnet(tmp_extruder);
       #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
         pe_activate_magnet(active_extruder); // Just save power for inverted magnets
@@ -234,99 +234,99 @@
      */
 
     // STEP 1
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("Starting Toolhead change", current_position);
     #endif
     current_position[Z_AXIS] += SWITCHING_TOOLHEAD_SECURITY_RAISE;
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("(1) Raise Z-Axis", current_position);
     #endif
-    planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
+    planner.buffer_line(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
     planner.synchronize();
 
     // STEP 2
     current_position[X_AXIS] = placexpos;
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) {
         SERIAL_ECHOLNPAIR("(2) Place old tool ", int(active_extruder));
         DEBUG_POS("Move X SwitchPos", current_position);
       }
     #endif
-    planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
+    planner.buffer_line(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
     planner.synchronize();
 
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS - SWITCHING_TOOLHEAD_Y_SECURITY;
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos + Security", current_position);
     #endif
-    planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Y_AXIS], active_extruder);
+    planner.buffer_line(current_position, planner.max_feedrate_mm_s[Y_AXIS], active_extruder);
     planner.synchronize();
 
     // STEP 3
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(3) Unlock and Place Toolhead");
     #endif
     MOVE_SERVO(SWITCHING_TOOLHEAD_SERVO_NR, angles[1]);
     safe_delay(500);
 
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS;
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos", current_position);
     #endif
-    planner.buffer_line_kinematic(current_position,(planner.max_feedrate_mm_s[Y_AXIS] * 0.5), active_extruder);
+    planner.buffer_line(current_position,(planner.max_feedrate_mm_s[Y_AXIS] * 0.5), active_extruder);
     planner.synchronize();
     safe_delay(200);
     current_position[Y_AXIS] -= SWITCHING_TOOLHEAD_Y_CLEAR;
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("Move back Y clear", current_position);
     #endif
-    planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Y_AXIS], active_extruder); // move away from docked toolhead
+    planner.buffer_line(current_position, planner.max_feedrate_mm_s[Y_AXIS], active_extruder); // move away from docked toolhead
     planner.synchronize();
 
     // STEP 4
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(4) Move to new toolhead position");
     #endif
     current_position[X_AXIS] = grabxpos;
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("Move to new toolhead X", current_position);
     #endif
-    planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
+    planner.buffer_line(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
     planner.synchronize();
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS - SWITCHING_TOOLHEAD_Y_SECURITY;
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos + Security", current_position);
     #endif
-    planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Y_AXIS], active_extruder);
+    planner.buffer_line(current_position, planner.max_feedrate_mm_s[Y_AXIS], active_extruder);
     planner.synchronize();
 
     // STEP 5
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(5) Grab and lock new toolhead ");
     #endif
     current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS;
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos", current_position);
     #endif
-    planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Y_AXIS] * 0.5, active_extruder);
+    planner.buffer_line(current_position, planner.max_feedrate_mm_s[Y_AXIS] * 0.5, active_extruder);
     planner.synchronize();
 
     safe_delay(200);
     MOVE_SERVO(SWITCHING_TOOLHEAD_SERVO_NR, angles[0]);
     safe_delay(500);
 
     current_position[Y_AXIS] -= SWITCHING_TOOLHEAD_Y_CLEAR;
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("Move back Y clear", current_position);
     #endif
-    planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Y_AXIS], active_extruder); // move away from docked toolhead
+    planner.buffer_line(current_position, planner.max_feedrate_mm_s[Y_AXIS], active_extruder); // move away from docked toolhead
     planner.synchronize();
 
     // STEP 6
     current_position[Z_AXIS] += hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("(6) Apply Z offset", current_position);
     #endif
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
@@ -517,21 +517,21 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
             constexpr float zdiff = 0;
             parking_extruder_tool_change(tmp_extruder, no_move);
           #elif ENABLED(SWITCHING_TOOLHEAD) // Switching Toolhead
             constexpr float zdiff = 0;
             switching_toolhead_tool_change(tmp_extruder, fr_mm_s, no_move);
           #else
             const float zdiff = hotend_offset[Z_AXIS][tmp_extruder] - hotend_offset[Z_AXIS][active_extruder];
             #if ENABLED(SWITCHING_NOZZLE)
               // Always raise by at least 1 to avoid workpiece
               current_position[Z_AXIS] += MAX(-zdiff, 0.0) + 1;
-              planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
+              planner.buffer_line(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
               move_nozzle_servo(tmp_extruder);
             #endif
           #endif
 
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) {
               SERIAL_ECHOPAIR("Offset Tool XY by { ", xdiff);
               SERIAL_ECHOPAIR(", ", ydiff);
               SERIAL_ECHOPAIR(", ", zdiff);
               SERIAL_ECHOLNPGM(" }");
@@ -542,35 +542,35 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
           current_position[X_AXIS] += xdiff;
           current_position[Y_AXIS] += ydiff;
           current_position[Z_AXIS] += zdiff;
 
           // Set the new active extruder
           active_extruder = tmp_extruder;
 
         #endif // !DUAL_X_CARRIAGE
 
         // Tell the planner the new "current position"
-        SYNC_PLAN_POSITION_KINEMATIC();
+        sync_plan_position();
 
         #if ENABLED(DELTA)
           //LOOP_XYZ(i) update_software_endstops(i); // or modify the constrain function
           const bool safe_to_move = current_position[Z_AXIS] < delta_clip_start_height - 1;
         #else
           constexpr bool safe_to_move = true;
         #endif
 
         // Raise, move, and lower again
         if (safe_to_move && !no_move && IsRunning()) {
           #if DISABLED(SWITCHING_NOZZLE)
             // Do a small lift to avoid the workpiece in the move back (below)
             current_position[Z_AXIS] += 1.0;
-            planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
+            planner.buffer_line(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
           #endif
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) DEBUG_POS("Move back", destination);
           #endif
           // Move back to the original (or tweaked) position
           do_blocking_move_to(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS]);
           #if ENABLED(DUAL_X_CARRIAGE)
             active_extruder_parked = false;
           #endif
         }

commit d882717d98d08ba7a47234eacf291b2d82288f13
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 10 23:09:26 2018 -0500

    Save some PROGMEM with constexpr (#11798)
    
    When possible, make `active_extruder` a `constexpr` to save some PROGMEM.

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 13f391eda4..7c4b52aa8b 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -151,40 +151,40 @@
       // STEP 3
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(3) Disengage magnet ");
       #endif
       pe_deactivate_magnet(active_extruder);
 
       // STEP 4
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(4) Move to position near new extruder");
       #endif
-      current_position[X_AXIS] += (active_extruder == 0 ? 10 : -10); // move 10mm away from parked extruder
+      current_position[X_AXIS] += active_extruder ? -10 : 10; // move 10mm away from parked extruder
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) DEBUG_POS("Move away from parked extruder", current_position);
       #endif
       planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
       planner.synchronize();
 
       // STEP 5
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(5) Engage magnetic field");
       #endif
 
       #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
         pe_activate_magnet(active_extruder); //just save power for inverted magnets
       #endif
       pe_activate_magnet(tmp_extruder);
 
       // STEP 6
-      current_position[X_AXIS] = grabpos + (tmp_extruder == 0 ? (+10) : (-10));
+      current_position[X_AXIS] = grabpos + (tmp_extruder ? -10 : 10);
       planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
       current_position[X_AXIS] = grabpos;
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) DEBUG_POS("(6) Unpark extruder", current_position);
       #endif
       planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS]/2, active_extruder);
       planner.synchronize();
 
       // Step 7
       current_position[X_AXIS] = midpos - hotend_offset[X_AXIS][tmp_extruder];
@@ -386,23 +386,23 @@ inline void invalid_extruder_error(const uint8_t e) {
           SERIAL_ECHOLNPAIR("Lower to ", current_position[Z_AXIS]);
         }
       #endif
       // Park old head: 1) raise 2) move to park position 3) lower
 
       #define CUR_X current_position[X_AXIS]
       #define CUR_Y current_position[Y_AXIS]
       #define CUR_Z current_position[Z_AXIS]
       #define CUR_E current_position[E_AXIS]
 
-      planner.buffer_line( CUR_X, CUR_Y, raised_z, CUR_E, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
-      planner.buffer_line( xhome, CUR_Y, raised_z, CUR_E, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
-      planner.buffer_line( xhome, CUR_Y, CUR_Z,    CUR_E, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
+      planner.buffer_line(CUR_X, CUR_Y, raised_z, CUR_E, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
+      planner.buffer_line(xhome, CUR_Y, raised_z, CUR_E, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
+      planner.buffer_line(xhome, CUR_Y, CUR_Z,    CUR_E, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
 
       planner.synchronize();
     }
 
     // Apply Y & Z extruder offset (X offset is used as home pos with Dual X)
     current_position[Y_AXIS] -= hotend_offset[Y_AXIS][active_extruder] - hotend_offset[Y_AXIS][tmp_extruder];
     current_position[Z_AXIS] -= hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
 
     // Activate the new extruder ahead of calling set_axis_is_at_home!
     active_extruder = tmp_extruder;
@@ -600,34 +600,36 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
       UNUSED(fr_mm_s);
       UNUSED(no_move);
 
       #if ENABLED(MK2_MULTIPLEXER)
         if (tmp_extruder >= E_STEPPERS)
           return invalid_extruder_error(tmp_extruder);
 
         select_multiplexed_stepper(tmp_extruder);
       #endif
 
-      // Set the new active extruder
-      active_extruder = tmp_extruder;
+      #if EXTRUDERS > 1
+        // Set the new active extruder
+        active_extruder = tmp_extruder;
+      #endif
 
     #endif // HOTENDS <= 1
 
     #if DO_SWITCH_EXTRUDER
       planner.synchronize();
       move_extruder_servo(active_extruder);
     #endif
 
     #if HAS_FANMUX
       fanmux_switch(active_extruder);
     #endif
 
     #if HAS_LEVELING
       // Restore leveling to re-establish the logical position
       set_bed_leveling_enabled(leveling_was_active);
     #endif
 
     SERIAL_ECHO_START();
-    SERIAL_ECHOLNPAIR(MSG_ACTIVE_EXTRUDER, (int)active_extruder);
+    SERIAL_ECHOLNPAIR(MSG_ACTIVE_EXTRUDER, int(active_extruder));
 
   #endif // !MIXING_EXTRUDER || MIXING_VIRTUAL_TOOLS <= 1
 }

commit e25d2ae4a2063d30330facf81c4b2b93cd63dda6
Author: Kevin <kevinbayer8@gmail.com>
Date:   Sat Sep 8 08:43:24 2018 +0200

    [2.0.x] SWITCHING_TOOLHEAD (#11623)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 341ec109da..13f391eda4 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -26,21 +26,21 @@
 #include "planner.h"
 
 #include "../Marlin.h"
 
 #include "../inc/MarlinConfig.h"
 
 #if ENABLED(PARKING_EXTRUDER) && PARKING_EXTRUDER_SOLENOIDS_DELAY > 0
   #include "../gcode/gcode.h" // for dwell()
 #endif
 
-#if ENABLED(SWITCHING_EXTRUDER) || ENABLED(SWITCHING_NOZZLE)
+#if ENABLED(SWITCHING_EXTRUDER) || ENABLED(SWITCHING_NOZZLE) || ENABLED(SWITCHING_TOOLHEAD)
   #include "../module/servo.h"
 #endif
 
 #if ENABLED(EXT_SOLENOID) && DISABLED(PARKING_EXTRUDER)
   #include "../feature/solenoid.h"
 #endif
 
 #if ENABLED(MK2_MULTIPLEXER)
   #include "../feature/snmm.h"
 #endif
@@ -206,20 +206,143 @@
     }
     current_position[Z_AXIS] += hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS("Applying Z-offset", current_position);
     #endif
   }
 
 #endif // PARKING_EXTRUDER
 
+#if ENABLED(SWITCHING_TOOLHEAD)
+
+  inline void switching_toolhead_tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
+    if (no_move) return;
+
+    constexpr uint16_t angles[2] = SWITCHING_TOOLHEAD_SERVO_ANGLES;
+
+    const float toolheadposx[] = SWITCHING_TOOLHEAD_X_POS,
+                placexpos = toolheadposx[active_extruder],
+                grabxpos = toolheadposx[tmp_extruder];
+
+    /**
+     * 1. Raise Z to give enough clearance
+     * 2. Move to switch position of current toolhead
+     * 3. Unlock tool and drop it in the dock
+     * 4. Move to the new toolhead
+     * 5. Grab and lock the new toolhead
+     * 6. Apply the z-offset of the new toolhead
+     */
+
+    // STEP 1
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) DEBUG_POS("Starting Toolhead change", current_position);
+    #endif
+    current_position[Z_AXIS] += SWITCHING_TOOLHEAD_SECURITY_RAISE;
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) DEBUG_POS("(1) Raise Z-Axis", current_position);
+    #endif
+    planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
+    planner.synchronize();
+
+    // STEP 2
+    current_position[X_AXIS] = placexpos;
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) {
+        SERIAL_ECHOLNPAIR("(2) Place old tool ", int(active_extruder));
+        DEBUG_POS("Move X SwitchPos", current_position);
+      }
+    #endif
+    planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
+    planner.synchronize();
+
+    current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS - SWITCHING_TOOLHEAD_Y_SECURITY;
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos + Security", current_position);
+    #endif
+    planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Y_AXIS], active_extruder);
+    planner.synchronize();
+
+    // STEP 3
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(3) Unlock and Place Toolhead");
+    #endif
+    MOVE_SERVO(SWITCHING_TOOLHEAD_SERVO_NR, angles[1]);
+    safe_delay(500);
+
+    current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS;
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos", current_position);
+    #endif
+    planner.buffer_line_kinematic(current_position,(planner.max_feedrate_mm_s[Y_AXIS] * 0.5), active_extruder);
+    planner.synchronize();
+    safe_delay(200);
+    current_position[Y_AXIS] -= SWITCHING_TOOLHEAD_Y_CLEAR;
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) DEBUG_POS("Move back Y clear", current_position);
+    #endif
+    planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Y_AXIS], active_extruder); // move away from docked toolhead
+    planner.synchronize();
+
+    // STEP 4
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(4) Move to new toolhead position");
+    #endif
+    current_position[X_AXIS] = grabxpos;
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) DEBUG_POS("Move to new toolhead X", current_position);
+    #endif
+    planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
+    planner.synchronize();
+    current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS - SWITCHING_TOOLHEAD_Y_SECURITY;
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos + Security", current_position);
+    #endif
+    planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Y_AXIS], active_extruder);
+    planner.synchronize();
+
+    // STEP 5
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(5) Grab and lock new toolhead ");
+    #endif
+    current_position[Y_AXIS] = SWITCHING_TOOLHEAD_Y_POS;
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) DEBUG_POS("Move Y SwitchPos", current_position);
+    #endif
+    planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Y_AXIS] * 0.5, active_extruder);
+    planner.synchronize();
+
+    safe_delay(200);
+    MOVE_SERVO(SWITCHING_TOOLHEAD_SERVO_NR, angles[0]);
+    safe_delay(500);
+
+    current_position[Y_AXIS] -= SWITCHING_TOOLHEAD_Y_CLEAR;
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) DEBUG_POS("Move back Y clear", current_position);
+    #endif
+    planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Y_AXIS], active_extruder); // move away from docked toolhead
+    planner.synchronize();
+
+    // STEP 6
+    current_position[Z_AXIS] += hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) DEBUG_POS("(6) Apply Z offset", current_position);
+    #endif
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Toolhead change done.");
+    #endif
+  }
+
+#endif // SWITCHING_TOOLHEAD
+
 inline void invalid_extruder_error(const uint8_t e) {
   SERIAL_ECHO_START();
   SERIAL_CHAR('T');
   SERIAL_ECHO_F(e, DEC);
   SERIAL_CHAR(' ');
   SERIAL_ECHOLNPGM(MSG_INVALID_EXTRUDER);
 }
 
 #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
 
@@ -379,33 +502,38 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
           // Don't move the new extruder out of bounds
           if (!WITHIN(current_position[X_AXIS], soft_endstop_min[X_AXIS], soft_endstop_max[X_AXIS]))
             no_move = true;
 
           if (!no_move) set_destination_from_current();
           dualx_tool_change(tmp_extruder, no_move); // Can modify no_move
 
         #else // !DUAL_X_CARRIAGE
 
           set_destination_from_current();
-          #if ENABLED(PARKING_EXTRUDER) // Dual Parking extruder
-            parking_extruder_tool_change(tmp_extruder, no_move);
-          #endif
 
           const float xdiff = hotend_offset[X_AXIS][tmp_extruder] - hotend_offset[X_AXIS][active_extruder],
-                      ydiff = hotend_offset[Y_AXIS][tmp_extruder] - hotend_offset[Y_AXIS][active_extruder],
-                      zdiff = hotend_offset[Z_AXIS][tmp_extruder] - hotend_offset[Z_AXIS][active_extruder];
+                      ydiff = hotend_offset[Y_AXIS][tmp_extruder] - hotend_offset[Y_AXIS][active_extruder];
 
-          #if ENABLED(SWITCHING_NOZZLE)
-            // Always raise by at least 1 to avoid workpiece
-            current_position[Z_AXIS] += (zdiff < 0.0 ? -zdiff : 0.0) + 1;
-            planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
-            move_nozzle_servo(tmp_extruder);
+          #if ENABLED(PARKING_EXTRUDER) // Dual Parking extruder
+            constexpr float zdiff = 0;
+            parking_extruder_tool_change(tmp_extruder, no_move);
+          #elif ENABLED(SWITCHING_TOOLHEAD) // Switching Toolhead
+            constexpr float zdiff = 0;
+            switching_toolhead_tool_change(tmp_extruder, fr_mm_s, no_move);
+          #else
+            const float zdiff = hotend_offset[Z_AXIS][tmp_extruder] - hotend_offset[Z_AXIS][active_extruder];
+            #if ENABLED(SWITCHING_NOZZLE)
+              // Always raise by at least 1 to avoid workpiece
+              current_position[Z_AXIS] += MAX(-zdiff, 0.0) + 1;
+              planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
+              move_nozzle_servo(tmp_extruder);
+            #endif
           #endif
 
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) {
               SERIAL_ECHOPAIR("Offset Tool XY by { ", xdiff);
               SERIAL_ECHOPAIR(", ", ydiff);
               SERIAL_ECHOPAIR(", ", zdiff);
               SERIAL_ECHOLNPGM(" }");
             }
           #endif

commit 72fdb6bab30f689032e3e330c90f7cf0eebee5c4
Author: scott0122 <39105828+scott0122@users.noreply.github.com>
Date:   Tue Sep 4 12:24:40 2018 +0800

    Fix SWITCHING_NOZZLE zdiff (#11683)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 3c4a62e294..341ec109da 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -413,25 +413,20 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
           // The newly-selected extruder XY is actually at...
           current_position[X_AXIS] += xdiff;
           current_position[Y_AXIS] += ydiff;
           current_position[Z_AXIS] += zdiff;
 
           // Set the new active extruder
           active_extruder = tmp_extruder;
 
         #endif // !DUAL_X_CARRIAGE
 
-        #if ENABLED(SWITCHING_NOZZLE)
-          // The newly-selected extruder Z is actually at...
-          current_position[Z_AXIS] -= zdiff;
-        #endif
-
         // Tell the planner the new "current position"
         SYNC_PLAN_POSITION_KINEMATIC();
 
         #if ENABLED(DELTA)
           //LOOP_XYZ(i) update_software_endstops(i); // or modify the constrain function
           const bool safe_to_move = current_position[Z_AXIS] < delta_clip_start_height - 1;
         #else
           constexpr bool safe_to_move = true;
         #endif
 

commit d1ceaf5550a98049fce5c78983f798d096e43c1f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 3 23:15:31 2018 -0500

    [2.0.x] Followup to IDEX changes (#11707)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 6539e8ec98..3c4a62e294 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -325,23 +325,24 @@ inline void invalid_extruder_error(const uint8_t e) {
 
 #endif // DUAL_X_CARRIAGE
 
 /**
  * Perform a tool-change, which may result in moving the
  * previous tool out of the way and the new tool into place.
  */
 void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
   planner.synchronize();
 
-  #if ENABLED(DUAL_X_CARRIAGE)  // Only T0 allowed if the Printer is in DXC_DUPLICATION_MODE
+  #if ENABLED(DUAL_X_CARRIAGE)
+    // Only T0 allowed in DXC_DUPLICATION_MODE
     if (tmp_extruder != 0 && dual_x_carriage_mode == DXC_DUPLICATION_MODE)
-       return invalid_extruder_error(tmp_extruder); 
+       return invalid_extruder_error(tmp_extruder);
   #endif
 
   #if HAS_LEVELING
     // Set current position to the physical position
     const bool leveling_was_active = planner.leveling_active;
     set_bed_leveling_enabled(false);
   #endif
 
   #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
 

commit 8e18e48d49a3fe61348a2b996a7b5f4c32069002
Merge: 4668c71a75 3e81745e81
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 3 03:55:38 2018 -0500

    Merge pull request #11610 from Freeviv/bugfix-2.0.x
    
    [2.0.x] Editable servo angles

diff --combined Marlin/src/module/tool_change.cpp
index 48d1272625,cd80b3d695..6539e8ec98
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@@ -53,48 -53,43 +53,43 @@@
    #include "../feature/bedlevel/bedlevel.h"
  #endif
  
  #if HAS_FANMUX
    #include "../feature/fanmux.h"
  #endif
  
  #if DO_SWITCH_EXTRUDER
  
    #if EXTRUDERS > 3
-     #define REQ_ANGLES 4
-     #define _SERVO_NR (e < 2 ? SWITCHING_EXTRUDER_SERVO_NR : SWITCHING_EXTRUDER_E23_SERVO_NR)
+     #define _SERVO_NR(E) ((E) < 2 ? SWITCHING_EXTRUDER_SERVO_NR : SWITCHING_EXTRUDER_E23_SERVO_NR)
    #else
-     #define REQ_ANGLES 2
-     #define _SERVO_NR SWITCHING_EXTRUDER_SERVO_NR
+     #define _SERVO_NR(E) SWITCHING_EXTRUDER_SERVO_NR
    #endif
  
    void move_extruder_servo(const uint8_t e) {
-     constexpr int16_t angles[] = SWITCHING_EXTRUDER_SERVO_ANGLES;
-     static_assert(COUNT(angles) == REQ_ANGLES, "SWITCHING_EXTRUDER_SERVO_ANGLES needs " STRINGIFY(REQ_ANGLES) " angles.");
      planner.synchronize();
      #if EXTRUDERS & 1
        if (e < EXTRUDERS - 1)
      #endif
      {
-       MOVE_SERVO(_SERVO_NR, angles[e]);
+       MOVE_SERVO(_SERVO_NR(e), servo_angles[_SERVO_NR(e)][e]);
        safe_delay(500);
      }
    }
  
  #endif // DO_SWITCH_EXTRUDER
  
  #if ENABLED(SWITCHING_NOZZLE)
  
    void move_nozzle_servo(const uint8_t e) {
-     const int16_t angles[2] = SWITCHING_NOZZLE_SERVO_ANGLES;
      planner.synchronize();
-     MOVE_SERVO(SWITCHING_NOZZLE_SERVO_NR, angles[e]);
+     MOVE_SERVO(SWITCHING_NOZZLE_SERVO_NR, servo_angles[SWITCHING_NOZZLE_SERVO_NR][e]);
      safe_delay(500);
    }
  
  #endif // SWITCHING_NOZZLE
  
  #if ENABLED(PARKING_EXTRUDER)
  
    void pe_magnet_init() {
      for (uint8_t n = 0; n <= 1; ++n)
        #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
@@@ -241,20 -236,21 +236,20 @@@ inline void invalid_extruder_error(cons
  
  #if ENABLED(DUAL_X_CARRIAGE)
  
    inline void dualx_tool_change(const uint8_t tmp_extruder, bool &no_move) {
      #if ENABLED(DEBUG_LEVELING_FEATURE)
        if (DEBUGGING(LEVELING)) {
          SERIAL_ECHOPGM("Dual X Carriage Mode ");
          switch (dual_x_carriage_mode) {
            case DXC_FULL_CONTROL_MODE: SERIAL_ECHOLNPGM("DXC_FULL_CONTROL_MODE"); break;
            case DXC_AUTO_PARK_MODE: SERIAL_ECHOLNPGM("DXC_AUTO_PARK_MODE"); break;
 -          case DXC_DUPLICATION_MODE: SERIAL_ECHOLNPGM("DXC_DUPLICATION_MODE"); break;
          }
        }
      #endif
  
      const float xhome = x_home_pos(active_extruder);
      if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE
          && IsRunning()
          && (delayed_move_time || current_position[X_AXIS] != xhome)
      ) {
        float raised_z = current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT;
@@@ -262,30 -258,29 +257,30 @@@
          NOMORE(raised_z, soft_endstop_max[Z_AXIS]);
        #endif
        #if ENABLED(DEBUG_LEVELING_FEATURE)
          if (DEBUGGING(LEVELING)) {
            SERIAL_ECHOLNPAIR("Raise to ", raised_z);
            SERIAL_ECHOLNPAIR("MoveX to ", xhome);
            SERIAL_ECHOLNPAIR("Lower to ", current_position[Z_AXIS]);
          }
        #endif
        // Park old head: 1) raise 2) move to park position 3) lower
 -      for (uint8_t i = 0; i < 3; i++)
 -        planner.buffer_line(
 -          i == 0 ? current_position[X_AXIS] : xhome,
 -          current_position[Y_AXIS],
 -          i == 2 ? current_position[Z_AXIS] : raised_z,
 -          current_position[E_AXIS],
 -          planner.max_feedrate_mm_s[i == 1 ? X_AXIS : Z_AXIS],
 -          active_extruder
 -        );
 +
 +      #define CUR_X current_position[X_AXIS]
 +      #define CUR_Y current_position[Y_AXIS]
 +      #define CUR_Z current_position[Z_AXIS]
 +      #define CUR_E current_position[E_AXIS]
 +
 +      planner.buffer_line( CUR_X, CUR_Y, raised_z, CUR_E, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
 +      planner.buffer_line( xhome, CUR_Y, raised_z, CUR_E, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
 +      planner.buffer_line( xhome, CUR_Y, CUR_Z,    CUR_E, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
 +
        planner.synchronize();
      }
  
      // Apply Y & Z extruder offset (X offset is used as home pos with Dual X)
      current_position[Y_AXIS] -= hotend_offset[Y_AXIS][active_extruder] - hotend_offset[Y_AXIS][tmp_extruder];
      current_position[Z_AXIS] -= hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
  
      // Activate the new extruder ahead of calling set_axis_is_at_home!
      active_extruder = tmp_extruder;
  
@@@ -309,20 -304,34 +304,20 @@@
        case DXC_AUTO_PARK_MODE:
          // record raised toolhead position for use by unpark
          COPY(raised_parked_position, current_position);
          raised_parked_position[Z_AXIS] += TOOLCHANGE_UNPARK_ZLIFT;
          #if ENABLED(MAX_SOFTWARE_ENDSTOPS)
            NOMORE(raised_parked_position[Z_AXIS], soft_endstop_max[Z_AXIS]);
          #endif
          active_extruder_parked = true;
          delayed_move_time = 0;
          break;
 -      case DXC_DUPLICATION_MODE:
 -        // If the new extruder is the left one, set it "parked"
 -        // This triggers the second extruder to move into the duplication position
 -        active_extruder_parked = (active_extruder == 0);
 -        current_position[X_AXIS] = active_extruder_parked ? inactive_extruder_x_pos : destination[X_AXIS] + duplicate_extruder_x_offset;
 -        inactive_extruder_x_pos = destination[X_AXIS];
 -        extruder_duplication_enabled = false;
 -        #if ENABLED(DEBUG_LEVELING_FEATURE)
 -          if (DEBUGGING(LEVELING)) {
 -            SERIAL_ECHOLNPAIR("Set inactive_extruder_x_pos=", inactive_extruder_x_pos);
 -            SERIAL_ECHOLNPGM("Clear extruder_duplication_enabled");
 -          }
 -        #endif
 -        break;
      }
  
      #if ENABLED(DEBUG_LEVELING_FEATURE)
        if (DEBUGGING(LEVELING)) {
          SERIAL_ECHOLNPAIR("Active extruder parked: ", active_extruder_parked ? "yes" : "no");
          DEBUG_POS("New extruder (parked)", current_position);
        }
      #endif
  
      // No extra case for HAS_ABL in DUAL_X_CARRIAGE. Does that mean they don't work together?
@@@ -330,25 -339,20 +325,25 @@@
  
  #endif // DUAL_X_CARRIAGE
  
  /**
   * Perform a tool-change, which may result in moving the
   * previous tool out of the way and the new tool into place.
   */
  void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
    planner.synchronize();
  
 +  #if ENABLED(DUAL_X_CARRIAGE)  // Only T0 allowed if the Printer is in DXC_DUPLICATION_MODE
 +    if (tmp_extruder != 0 && dual_x_carriage_mode == DXC_DUPLICATION_MODE)
 +       return invalid_extruder_error(tmp_extruder); 
 +  #endif
 +
    #if HAS_LEVELING
      // Set current position to the physical position
      const bool leveling_was_active = planner.leveling_active;
      set_bed_leveling_enabled(false);
    #endif
  
    #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
  
      mixing_tool_change(tmp_extruder);
  

commit 7680b64aa66d3aecbc8d682af9912797e59c12aa
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Sun Sep 2 10:18:59 2018 -0500

    IDEX clean up (#11690)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index e4c1cc0f50..48d1272625 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -241,21 +241,20 @@ inline void invalid_extruder_error(const uint8_t e) {
 
 #if ENABLED(DUAL_X_CARRIAGE)
 
   inline void dualx_tool_change(const uint8_t tmp_extruder, bool &no_move) {
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) {
         SERIAL_ECHOPGM("Dual X Carriage Mode ");
         switch (dual_x_carriage_mode) {
           case DXC_FULL_CONTROL_MODE: SERIAL_ECHOLNPGM("DXC_FULL_CONTROL_MODE"); break;
           case DXC_AUTO_PARK_MODE: SERIAL_ECHOLNPGM("DXC_AUTO_PARK_MODE"); break;
-          case DXC_DUPLICATION_MODE: SERIAL_ECHOLNPGM("DXC_DUPLICATION_MODE"); break;
         }
       }
     #endif
 
     const float xhome = x_home_pos(active_extruder);
     if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE
         && IsRunning()
         && (delayed_move_time || current_position[X_AXIS] != xhome)
     ) {
       float raised_z = current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT;
@@ -263,29 +262,30 @@ inline void invalid_extruder_error(const uint8_t e) {
         NOMORE(raised_z, soft_endstop_max[Z_AXIS]);
       #endif
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) {
           SERIAL_ECHOLNPAIR("Raise to ", raised_z);
           SERIAL_ECHOLNPAIR("MoveX to ", xhome);
           SERIAL_ECHOLNPAIR("Lower to ", current_position[Z_AXIS]);
         }
       #endif
       // Park old head: 1) raise 2) move to park position 3) lower
-      for (uint8_t i = 0; i < 3; i++)
-        planner.buffer_line(
-          i == 0 ? current_position[X_AXIS] : xhome,
-          current_position[Y_AXIS],
-          i == 2 ? current_position[Z_AXIS] : raised_z,
-          current_position[E_AXIS],
-          planner.max_feedrate_mm_s[i == 1 ? X_AXIS : Z_AXIS],
-          active_extruder
-        );
+
+      #define CUR_X current_position[X_AXIS]
+      #define CUR_Y current_position[Y_AXIS]
+      #define CUR_Z current_position[Z_AXIS]
+      #define CUR_E current_position[E_AXIS]
+
+      planner.buffer_line( CUR_X, CUR_Y, raised_z, CUR_E, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
+      planner.buffer_line( xhome, CUR_Y, raised_z, CUR_E, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
+      planner.buffer_line( xhome, CUR_Y, CUR_Z,    CUR_E, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
+
       planner.synchronize();
     }
 
     // Apply Y & Z extruder offset (X offset is used as home pos with Dual X)
     current_position[Y_AXIS] -= hotend_offset[Y_AXIS][active_extruder] - hotend_offset[Y_AXIS][tmp_extruder];
     current_position[Z_AXIS] -= hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
 
     // Activate the new extruder ahead of calling set_axis_is_at_home!
     active_extruder = tmp_extruder;
 
@@ -309,34 +309,20 @@ inline void invalid_extruder_error(const uint8_t e) {
       case DXC_AUTO_PARK_MODE:
         // record raised toolhead position for use by unpark
         COPY(raised_parked_position, current_position);
         raised_parked_position[Z_AXIS] += TOOLCHANGE_UNPARK_ZLIFT;
         #if ENABLED(MAX_SOFTWARE_ENDSTOPS)
           NOMORE(raised_parked_position[Z_AXIS], soft_endstop_max[Z_AXIS]);
         #endif
         active_extruder_parked = true;
         delayed_move_time = 0;
         break;
-      case DXC_DUPLICATION_MODE:
-        // If the new extruder is the left one, set it "parked"
-        // This triggers the second extruder to move into the duplication position
-        active_extruder_parked = (active_extruder == 0);
-        current_position[X_AXIS] = active_extruder_parked ? inactive_extruder_x_pos : destination[X_AXIS] + duplicate_extruder_x_offset;
-        inactive_extruder_x_pos = destination[X_AXIS];
-        extruder_duplication_enabled = false;
-        #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) {
-            SERIAL_ECHOLNPAIR("Set inactive_extruder_x_pos=", inactive_extruder_x_pos);
-            SERIAL_ECHOLNPGM("Clear extruder_duplication_enabled");
-          }
-        #endif
-        break;
     }
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) {
         SERIAL_ECHOLNPAIR("Active extruder parked: ", active_extruder_parked ? "yes" : "no");
         DEBUG_POS("New extruder (parked)", current_position);
       }
     #endif
 
     // No extra case for HAS_ABL in DUAL_X_CARRIAGE. Does that mean they don't work together?
@@ -344,20 +330,25 @@ inline void invalid_extruder_error(const uint8_t e) {
 
 #endif // DUAL_X_CARRIAGE
 
 /**
  * Perform a tool-change, which may result in moving the
  * previous tool out of the way and the new tool into place.
  */
 void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
   planner.synchronize();
 
+  #if ENABLED(DUAL_X_CARRIAGE)  // Only T0 allowed if the Printer is in DXC_DUPLICATION_MODE
+    if (tmp_extruder != 0 && dual_x_carriage_mode == DXC_DUPLICATION_MODE)
+       return invalid_extruder_error(tmp_extruder); 
+  #endif
+
   #if HAS_LEVELING
     // Set current position to the physical position
     const bool leveling_was_active = planner.leveling_active;
     set_bed_leveling_enabled(false);
   #endif
 
   #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
 
     mixing_tool_change(tmp_extruder);
 

commit 3e81745e81fea173599b06ac9db7ed776e986808
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Aug 24 21:53:42 2018 -0500

    Fix issues, make optional

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 937d49020e..cd80b3d695 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -53,43 +53,43 @@
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if HAS_FANMUX
   #include "../feature/fanmux.h"
 #endif
 
 #if DO_SWITCH_EXTRUDER
 
   #if EXTRUDERS > 3
-    #define _SERVO_NR (e < 2 ? SWITCHING_EXTRUDER_SERVO_NR : SWITCHING_EXTRUDER_E23_SERVO_NR)
+    #define _SERVO_NR(E) ((E) < 2 ? SWITCHING_EXTRUDER_SERVO_NR : SWITCHING_EXTRUDER_E23_SERVO_NR)
   #else
-    #define _SERVO_NR SWITCHING_EXTRUDER_SERVO_NR
+    #define _SERVO_NR(E) SWITCHING_EXTRUDER_SERVO_NR
   #endif
 
   void move_extruder_servo(const uint8_t e) {
     planner.synchronize();
     #if EXTRUDERS & 1
       if (e < EXTRUDERS - 1)
     #endif
     {
-      MOVE_SERVO(_SERVO_NR, servo_angles[_SERVO_NR][e]);
+      MOVE_SERVO(_SERVO_NR(e), servo_angles[_SERVO_NR(e)][e]);
       safe_delay(500);
     }
   }
 
 #endif // DO_SWITCH_EXTRUDER
 
 #if ENABLED(SWITCHING_NOZZLE)
 
   void move_nozzle_servo(const uint8_t e) {
     planner.synchronize();
-    MOVE_SERVO(SWITCHING_NOZZLE_SERVO_NR, servo_angles[SWITCHING_EXTRUDER_SERVO_NR][e]);
+    MOVE_SERVO(SWITCHING_NOZZLE_SERVO_NR, servo_angles[SWITCHING_NOZZLE_SERVO_NR][e]);
     safe_delay(500);
   }
 
 #endif // SWITCHING_NOZZLE
 
 #if ENABLED(PARKING_EXTRUDER)
 
   void pe_magnet_init() {
     for (uint8_t n = 0; n <= 1; ++n)
       #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)

commit aa80e448e24a27ac0006de4e3d3e93b18c73e3e0
Author: Jan <janschon@uni-bremen.de>
Date:   Tue Aug 7 17:04:46 2018 +0200

    Store servo angles in EEPROM

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index e4c1cc0f50..937d49020e 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -53,48 +53,43 @@
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if HAS_FANMUX
   #include "../feature/fanmux.h"
 #endif
 
 #if DO_SWITCH_EXTRUDER
 
   #if EXTRUDERS > 3
-    #define REQ_ANGLES 4
     #define _SERVO_NR (e < 2 ? SWITCHING_EXTRUDER_SERVO_NR : SWITCHING_EXTRUDER_E23_SERVO_NR)
   #else
-    #define REQ_ANGLES 2
     #define _SERVO_NR SWITCHING_EXTRUDER_SERVO_NR
   #endif
 
   void move_extruder_servo(const uint8_t e) {
-    constexpr int16_t angles[] = SWITCHING_EXTRUDER_SERVO_ANGLES;
-    static_assert(COUNT(angles) == REQ_ANGLES, "SWITCHING_EXTRUDER_SERVO_ANGLES needs " STRINGIFY(REQ_ANGLES) " angles.");
     planner.synchronize();
     #if EXTRUDERS & 1
       if (e < EXTRUDERS - 1)
     #endif
     {
-      MOVE_SERVO(_SERVO_NR, angles[e]);
+      MOVE_SERVO(_SERVO_NR, servo_angles[_SERVO_NR][e]);
       safe_delay(500);
     }
   }
 
 #endif // DO_SWITCH_EXTRUDER
 
 #if ENABLED(SWITCHING_NOZZLE)
 
   void move_nozzle_servo(const uint8_t e) {
-    const int16_t angles[2] = SWITCHING_NOZZLE_SERVO_ANGLES;
     planner.synchronize();
-    MOVE_SERVO(SWITCHING_NOZZLE_SERVO_NR, angles[e]);
+    MOVE_SERVO(SWITCHING_NOZZLE_SERVO_NR, servo_angles[SWITCHING_EXTRUDER_SERVO_NR][e]);
     safe_delay(500);
   }
 
 #endif // SWITCHING_NOZZLE
 
 #if ENABLED(PARKING_EXTRUDER)
 
   void pe_magnet_init() {
     for (uint8_t n = 0; n <= 1; ++n)
       #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)

commit 6dc9553aa5d8b35f54a3890e301c9a02c7aba308
Author: scott0122 <39105828+scott0122@users.noreply.github.com>
Date:   Tue Aug 28 10:25:25 2018 +0800

    Fix SWITCHING_NOZZLE compile error (#11657)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index b65dc617a8..e4c1cc0f50 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -396,32 +396,31 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
           if (!no_move) set_destination_from_current();
           dualx_tool_change(tmp_extruder, no_move); // Can modify no_move
 
         #else // !DUAL_X_CARRIAGE
 
           set_destination_from_current();
           #if ENABLED(PARKING_EXTRUDER) // Dual Parking extruder
             parking_extruder_tool_change(tmp_extruder, no_move);
           #endif
 
+          const float xdiff = hotend_offset[X_AXIS][tmp_extruder] - hotend_offset[X_AXIS][active_extruder],
+                      ydiff = hotend_offset[Y_AXIS][tmp_extruder] - hotend_offset[Y_AXIS][active_extruder],
+                      zdiff = hotend_offset[Z_AXIS][tmp_extruder] - hotend_offset[Z_AXIS][active_extruder];
+
           #if ENABLED(SWITCHING_NOZZLE)
             // Always raise by at least 1 to avoid workpiece
-            const float zdiff = hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
-            current_position[Z_AXIS] += (zdiff > 0.0 ? zdiff : 0.0) + 1;
+            current_position[Z_AXIS] += (zdiff < 0.0 ? -zdiff : 0.0) + 1;
             planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
             move_nozzle_servo(tmp_extruder);
           #endif
 
-          const float xdiff = hotend_offset[X_AXIS][tmp_extruder] - hotend_offset[X_AXIS][active_extruder],
-                      ydiff = hotend_offset[Y_AXIS][tmp_extruder] - hotend_offset[Y_AXIS][active_extruder],
-                      zdiff = hotend_offset[Z_AXIS][tmp_extruder] - hotend_offset[Z_AXIS][active_extruder];
-
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) {
               SERIAL_ECHOPAIR("Offset Tool XY by { ", xdiff);
               SERIAL_ECHOPAIR(", ", ydiff);
               SERIAL_ECHOPAIR(", ", zdiff);
               SERIAL_ECHOLNPGM(" }");
             }
           #endif
 
           // The newly-selected extruder XY is actually at...

commit e2b8fc4f176ea3619096255fb7183d5ef9f701a5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Aug 24 21:03:21 2018 -0500

    Reduce some debug strings

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 15fcc937dc..b65dc617a8 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -115,96 +115,93 @@
   }
 
   inline void parking_extruder_tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
     if (!no_move) {
 
       const float parkingposx[] = PARKING_EXTRUDER_PARKING_X,
                   midpos = (parkingposx[0] + parkingposx[1]) * 0.5 + hotend_offset[X_AXIS][active_extruder],
                   grabpos = parkingposx[tmp_extruder] + hotend_offset[X_AXIS][active_extruder]
                             + (tmp_extruder == 0 ? -(PARKING_EXTRUDER_GRAB_DISTANCE) : PARKING_EXTRUDER_GRAB_DISTANCE);
       /**
-       *  Steps:
-       *    1. Raise Z-Axis to give enough clearance
-       *    2. Move to park position of old extruder
-       *    3. Disengage magnetic field, wait for delay
-       *    4. Move near new extruder
-       *    5. Engage magnetic field for new extruder
-       *    6. Move to parking incl. offset of new extruder
-       *    7. Lower Z-Axis
+       * 1. Raise Z-Axis to give enough clearance
+       * 2. Move to park position of old extruder
+       * 3. Disengage magnetic field, wait for delay
+       * 4. Move near new extruder
+       * 5. Engage magnetic field for new extruder
+       * 6. Move to parking incl. offset of new extruder
+       * 7. Lower Z-Axis
        */
 
       // STEP 1
       #if ENABLED(DEBUG_LEVELING_FEATURE)
-        SERIAL_ECHOLNPGM("Starting Autopark");
-        if (DEBUGGING(LEVELING)) DEBUG_POS("current position:", current_position);
+        if (DEBUGGING(LEVELING)) DEBUG_POS("Start Autopark", current_position);
       #endif
       current_position[Z_AXIS] += PARKING_EXTRUDER_SECURITY_RAISE;
       #if ENABLED(DEBUG_LEVELING_FEATURE)
-        SERIAL_ECHOLNPGM("(1) Raise Z-Axis ");
-        if (DEBUGGING(LEVELING)) DEBUG_POS("Moving to Raised Z-Position", current_position);
+        if (DEBUGGING(LEVELING)) DEBUG_POS("(1) Raise Z-Axis", current_position);
       #endif
       planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
       planner.synchronize();
 
       // STEP 2
       current_position[X_AXIS] = parkingposx[active_extruder] + hotend_offset[X_AXIS][active_extruder];
       #if ENABLED(DEBUG_LEVELING_FEATURE)
-        SERIAL_ECHOLNPAIR("(2) Park extruder ", active_extruder);
-        if (DEBUGGING(LEVELING)) DEBUG_POS("Moving ParkPos", current_position);
+        if (DEBUGGING(LEVELING)) {
+          SERIAL_ECHOLNPAIR("(2) Park extruder ", int(active_extruder));
+          DEBUG_POS("Moving ParkPos", current_position);
+        }
       #endif
       planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
       planner.synchronize();
 
       // STEP 3
       #if ENABLED(DEBUG_LEVELING_FEATURE)
-        SERIAL_ECHOLNPGM("(3) Disengage magnet ");
+        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(3) Disengage magnet ");
       #endif
       pe_deactivate_magnet(active_extruder);
 
       // STEP 4
       #if ENABLED(DEBUG_LEVELING_FEATURE)
-        SERIAL_ECHOLNPGM("(4) Move to position near new extruder");
+        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(4) Move to position near new extruder");
       #endif
       current_position[X_AXIS] += (active_extruder == 0 ? 10 : -10); // move 10mm away from parked extruder
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) DEBUG_POS("Moving away from parked extruder", current_position);
+        if (DEBUGGING(LEVELING)) DEBUG_POS("Move away from parked extruder", current_position);
       #endif
       planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
       planner.synchronize();
 
       // STEP 5
       #if ENABLED(DEBUG_LEVELING_FEATURE)
-        SERIAL_ECHOLNPGM("(5) Engage magnetic field");
+        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("(5) Engage magnetic field");
       #endif
 
       #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
         pe_activate_magnet(active_extruder); //just save power for inverted magnets
       #endif
       pe_activate_magnet(tmp_extruder);
 
       // STEP 6
       current_position[X_AXIS] = grabpos + (tmp_extruder == 0 ? (+10) : (-10));
       planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
       current_position[X_AXIS] = grabpos;
       #if ENABLED(DEBUG_LEVELING_FEATURE)
-        SERIAL_ECHOLNPAIR("(6) Unpark extruder ", tmp_extruder);
-        if (DEBUGGING(LEVELING)) DEBUG_POS("Move UnparkPos", current_position);
+        if (DEBUGGING(LEVELING)) DEBUG_POS("(6) Unpark extruder", current_position);
       #endif
       planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS]/2, active_extruder);
       planner.synchronize();
 
       // Step 7
       current_position[X_AXIS] = midpos - hotend_offset[X_AXIS][tmp_extruder];
       #if ENABLED(DEBUG_LEVELING_FEATURE)
-        SERIAL_ECHOLNPGM("(7) Move midway between hotends");
-        if (DEBUGGING(LEVELING)) DEBUG_POS("Move midway to new extruder", current_position);
+        if (DEBUGGING(LEVELING)) DEBUG_POS("(7) Move midway between hotends", current_position);
       #endif
       planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
       planner.synchronize();
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         SERIAL_ECHOLNPGM("Autopark done.");
       #endif
     }
     else { // nomove == true
       // Only engage magnetic field for new extruder
       pe_activate_magnet(tmp_extruder);

commit acf5ae3083fd1c5c0a8e14703867b676dc56908c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Aug 24 16:35:55 2018 -0500

    !ENABLED => DISABLED

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 9afb6fd297..15fcc937dc 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -30,21 +30,21 @@
 #include "../inc/MarlinConfig.h"
 
 #if ENABLED(PARKING_EXTRUDER) && PARKING_EXTRUDER_SOLENOIDS_DELAY > 0
   #include "../gcode/gcode.h" // for dwell()
 #endif
 
 #if ENABLED(SWITCHING_EXTRUDER) || ENABLED(SWITCHING_NOZZLE)
   #include "../module/servo.h"
 #endif
 
-#if ENABLED(EXT_SOLENOID) && !ENABLED(PARKING_EXTRUDER)
+#if ENABLED(EXT_SOLENOID) && DISABLED(PARKING_EXTRUDER)
   #include "../feature/solenoid.h"
 #endif
 
 #if ENABLED(MK2_MULTIPLEXER)
   #include "../feature/snmm.h"
 #endif
 
 #if ENABLED(MIXING_EXTRUDER)
   #include "../feature/mixing.h"
 #endif
@@ -471,21 +471,21 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
         #if ENABLED(SWITCHING_NOZZLE)
           else {
             // Move back down. (Including when the new tool is higher.)
             do_blocking_move_to_z(destination[Z_AXIS], planner.max_feedrate_mm_s[Z_AXIS]);
           }
         #endif
       } // (tmp_extruder != active_extruder)
 
       planner.synchronize();
 
-      #if ENABLED(EXT_SOLENOID) && !ENABLED(PARKING_EXTRUDER)
+      #if ENABLED(EXT_SOLENOID) && DISABLED(PARKING_EXTRUDER)
         disable_all_solenoids();
         enable_solenoid_on_active_extruder();
       #endif
 
       feedrate_mm_s = old_feedrate_mm_s;
 
       #if HAS_SOFTWARE_ENDSTOPS && ENABLED(DUAL_X_CARRIAGE)
         update_software_endstops(X_AXIS);
       #endif
 

commit 6483285bc5b41a6d1f38e1e52dc046be98ccdc06
Author: Kevin <kevinbayer8@gmail.com>
Date:   Wed Aug 22 07:21:29 2018 +0200

    HOTEND_OFFSET_Z always available (#11603)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 22cb329c39..9afb6fd297 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -408,33 +408,36 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
 
           #if ENABLED(SWITCHING_NOZZLE)
             // Always raise by at least 1 to avoid workpiece
             const float zdiff = hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
             current_position[Z_AXIS] += (zdiff > 0.0 ? zdiff : 0.0) + 1;
             planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
             move_nozzle_servo(tmp_extruder);
           #endif
 
           const float xdiff = hotend_offset[X_AXIS][tmp_extruder] - hotend_offset[X_AXIS][active_extruder],
-                      ydiff = hotend_offset[Y_AXIS][tmp_extruder] - hotend_offset[Y_AXIS][active_extruder];
+                      ydiff = hotend_offset[Y_AXIS][tmp_extruder] - hotend_offset[Y_AXIS][active_extruder],
+                      zdiff = hotend_offset[Z_AXIS][tmp_extruder] - hotend_offset[Z_AXIS][active_extruder];
 
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) {
               SERIAL_ECHOPAIR("Offset Tool XY by { ", xdiff);
               SERIAL_ECHOPAIR(", ", ydiff);
+              SERIAL_ECHOPAIR(", ", zdiff);
               SERIAL_ECHOLNPGM(" }");
             }
           #endif
 
           // The newly-selected extruder XY is actually at...
           current_position[X_AXIS] += xdiff;
           current_position[Y_AXIS] += ydiff;
+          current_position[Z_AXIS] += zdiff;
 
           // Set the new active extruder
           active_extruder = tmp_extruder;
 
         #endif // !DUAL_X_CARRIAGE
 
         #if ENABLED(SWITCHING_NOZZLE)
           // The newly-selected extruder Z is actually at...
           current_position[Z_AXIS] -= zdiff;
         #endif

commit ad12b9b46be2d383542b691e81e4bf8bb465f8cb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Aug 21 09:06:10 2018 -0500

    Fix indentation, whitespace, spelling, formbot pins...

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index dc2c55559a..22cb329c39 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -348,25 +348,25 @@ inline void invalid_extruder_error(const uint8_t e) {
 #endif // DUAL_X_CARRIAGE
 
 /**
  * Perform a tool-change, which may result in moving the
  * previous tool out of the way and the new tool into place.
  */
 void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
   planner.synchronize();
 
   #if HAS_LEVELING
-      // Set current position to the physical position
-      const bool leveling_was_active = planner.leveling_active;
-      set_bed_leveling_enabled(false);
-   #endif
-  
+    // Set current position to the physical position
+    const bool leveling_was_active = planner.leveling_active;
+    set_bed_leveling_enabled(false);
+  #endif
+
   #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
 
     mixing_tool_change(tmp_extruder);
 
   #else // !MIXING_EXTRUDER || MIXING_VIRTUAL_TOOLS <= 1
 
     if (tmp_extruder >= EXTRUDERS)
       return invalid_extruder_error(tmp_extruder);
 
     #if HOTENDS > 1
@@ -504,22 +504,21 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
     #endif // HOTENDS <= 1
 
     #if DO_SWITCH_EXTRUDER
       planner.synchronize();
       move_extruder_servo(active_extruder);
     #endif
 
     #if HAS_FANMUX
       fanmux_switch(active_extruder);
     #endif
-  
+
     #if HAS_LEVELING
-          planner.synchronize();
-          // Restore leveling to re-establish the logical position
-          set_bed_leveling_enabled(leveling_was_active);
+      // Restore leveling to re-establish the logical position
+      set_bed_leveling_enabled(leveling_was_active);
     #endif
-  
+
     SERIAL_ECHO_START();
     SERIAL_ECHOLNPAIR(MSG_ACTIVE_EXTRUDER, (int)active_extruder);
 
   #endif // !MIXING_EXTRUDER || MIXING_VIRTUAL_TOOLS <= 1
 }

commit 9de730b2bf63f800065f912c8d20b750a34918a8
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Wed Aug 15 20:30:52 2018 -0400

    Update tool_change.cpp (#11559)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index c7cdcb167a..dc2c55559a 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -347,20 +347,26 @@ inline void invalid_extruder_error(const uint8_t e) {
 
 #endif // DUAL_X_CARRIAGE
 
 /**
  * Perform a tool-change, which may result in moving the
  * previous tool out of the way and the new tool into place.
  */
 void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
   planner.synchronize();
 
+  #if HAS_LEVELING
+      // Set current position to the physical position
+      const bool leveling_was_active = planner.leveling_active;
+      set_bed_leveling_enabled(false);
+   #endif
+  
   #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
 
     mixing_tool_change(tmp_extruder);
 
   #else // !MIXING_EXTRUDER || MIXING_VIRTUAL_TOOLS <= 1
 
     if (tmp_extruder >= EXTRUDERS)
       return invalid_extruder_error(tmp_extruder);
 
     #if HOTENDS > 1
@@ -370,26 +376,20 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
       feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
 
       if (tmp_extruder != active_extruder) {
         if (!no_move && axis_unhomed_error()) {
           no_move = true;
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("No move on toolchange");
           #endif
         }
 
-        #if HAS_LEVELING
-          // Set current position to the physical position
-          const bool leveling_was_active = planner.leveling_active;
-          set_bed_leveling_enabled(false);
-        #endif
-
         #if ENABLED(DUAL_X_CARRIAGE)
 
           #if HAS_SOFTWARE_ENDSTOPS
             // Update the X software endstops early
             active_extruder = tmp_extruder;
             update_software_endstops(X_AXIS);
             active_extruder = !tmp_extruder;
           #endif
 
           // Don't move the new extruder out of bounds
@@ -432,25 +432,20 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
           // Set the new active extruder
           active_extruder = tmp_extruder;
 
         #endif // !DUAL_X_CARRIAGE
 
         #if ENABLED(SWITCHING_NOZZLE)
           // The newly-selected extruder Z is actually at...
           current_position[Z_AXIS] -= zdiff;
         #endif
 
-        #if HAS_LEVELING
-          // Restore leveling to re-establish the logical position
-          set_bed_leveling_enabled(leveling_was_active);
-        #endif
-
         // Tell the planner the new "current position"
         SYNC_PLAN_POSITION_KINEMATIC();
 
         #if ENABLED(DELTA)
           //LOOP_XYZ(i) update_software_endstops(i); // or modify the constrain function
           const bool safe_to_move = current_position[Z_AXIS] < delta_clip_start_height - 1;
         #else
           constexpr bool safe_to_move = true;
         #endif
 
@@ -509,16 +504,22 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
     #endif // HOTENDS <= 1
 
     #if DO_SWITCH_EXTRUDER
       planner.synchronize();
       move_extruder_servo(active_extruder);
     #endif
 
     #if HAS_FANMUX
       fanmux_switch(active_extruder);
     #endif
-
+  
+    #if HAS_LEVELING
+          planner.synchronize();
+          // Restore leveling to re-establish the logical position
+          set_bed_leveling_enabled(leveling_was_active);
+    #endif
+  
     SERIAL_ECHO_START();
     SERIAL_ECHOLNPAIR(MSG_ACTIVE_EXTRUDER, (int)active_extruder);
 
   #endif // !MIXING_EXTRUDER || MIXING_VIRTUAL_TOOLS <= 1
 }

commit 9c62c47579fdefccdae5bb58dc706a58689eed0f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Aug 3 20:47:29 2018 -0500

    [2.0.x] Fix Dual X Carriage tool change crash (#11447)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 35c52cf7ae..c7cdcb167a 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -370,35 +370,45 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
       feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
 
       if (tmp_extruder != active_extruder) {
         if (!no_move && axis_unhomed_error()) {
           no_move = true;
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("No move on toolchange");
           #endif
         }
 
-        // Save current position to destination, for use later
-        set_destination_from_current();
-
         #if HAS_LEVELING
           // Set current position to the physical position
           const bool leveling_was_active = planner.leveling_active;
           set_bed_leveling_enabled(false);
         #endif
 
         #if ENABLED(DUAL_X_CARRIAGE)
 
+          #if HAS_SOFTWARE_ENDSTOPS
+            // Update the X software endstops early
+            active_extruder = tmp_extruder;
+            update_software_endstops(X_AXIS);
+            active_extruder = !tmp_extruder;
+          #endif
+
+          // Don't move the new extruder out of bounds
+          if (!WITHIN(current_position[X_AXIS], soft_endstop_min[X_AXIS], soft_endstop_max[X_AXIS]))
+            no_move = true;
+
+          if (!no_move) set_destination_from_current();
           dualx_tool_change(tmp_extruder, no_move); // Can modify no_move
 
         #else // !DUAL_X_CARRIAGE
 
+          set_destination_from_current();
           #if ENABLED(PARKING_EXTRUDER) // Dual Parking extruder
             parking_extruder_tool_change(tmp_extruder, no_move);
           #endif
 
           #if ENABLED(SWITCHING_NOZZLE)
             // Always raise by at least 1 to avoid workpiece
             const float zdiff = hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
             current_position[Z_AXIS] += (zdiff > 0.0 ? zdiff : 0.0) + 1;
             planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
             move_nozzle_servo(tmp_extruder);
@@ -417,30 +427,30 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
 
           // The newly-selected extruder XY is actually at...
           current_position[X_AXIS] += xdiff;
           current_position[Y_AXIS] += ydiff;
 
           // Set the new active extruder
           active_extruder = tmp_extruder;
 
         #endif // !DUAL_X_CARRIAGE
 
-        #if HAS_LEVELING
-          // Restore leveling to re-establish the logical position
-          set_bed_leveling_enabled(leveling_was_active);
-        #endif
-
         #if ENABLED(SWITCHING_NOZZLE)
           // The newly-selected extruder Z is actually at...
           current_position[Z_AXIS] -= zdiff;
         #endif
 
+        #if HAS_LEVELING
+          // Restore leveling to re-establish the logical position
+          set_bed_leveling_enabled(leveling_was_active);
+        #endif
+
         // Tell the planner the new "current position"
         SYNC_PLAN_POSITION_KINEMATIC();
 
         #if ENABLED(DELTA)
           //LOOP_XYZ(i) update_software_endstops(i); // or modify the constrain function
           const bool safe_to_move = current_position[Z_AXIS] < delta_clip_start_height - 1;
         #else
           constexpr bool safe_to_move = true;
         #endif
 
@@ -470,20 +480,24 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
 
       planner.synchronize();
 
       #if ENABLED(EXT_SOLENOID) && !ENABLED(PARKING_EXTRUDER)
         disable_all_solenoids();
         enable_solenoid_on_active_extruder();
       #endif
 
       feedrate_mm_s = old_feedrate_mm_s;
 
+      #if HAS_SOFTWARE_ENDSTOPS && ENABLED(DUAL_X_CARRIAGE)
+        update_software_endstops(X_AXIS);
+      #endif
+
     #else // HOTENDS <= 1
 
       UNUSED(fr_mm_s);
       UNUSED(no_move);
 
       #if ENABLED(MK2_MULTIPLEXER)
         if (tmp_extruder >= E_STEPPERS)
           return invalid_extruder_error(tmp_extruder);
 
         select_multiplexed_stepper(tmp_extruder);

commit 16432376ab9ac694e6ac38d21dfcf001e91cbd27
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Sat Jul 28 23:14:46 2018 -0500

    Revert "[2.0.x]Idex and bl touch fixes" (#11407)
    
    * Revert "[2.0.x] bltouch home refinements (#11397)"
    
    This reverts commit 74900f7a70f339071fd1e03176260f61f668d4cd.
    
    * Revert "[2.0.x]Idex and bl touch fixes (#11395)"
    
    This reverts commit 6dafb90c0143d615430138f213a0fd232610119a.

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index bd8264b70d..35c52cf7ae 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -370,38 +370,35 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
       feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
 
       if (tmp_extruder != active_extruder) {
         if (!no_move && axis_unhomed_error()) {
           no_move = true;
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("No move on toolchange");
           #endif
         }
 
-        
+        // Save current position to destination, for use later
+        set_destination_from_current();
 
         #if HAS_LEVELING
           // Set current position to the physical position
           const bool leveling_was_active = planner.leveling_active;
           set_bed_leveling_enabled(false);
         #endif
 
         #if ENABLED(DUAL_X_CARRIAGE)
-          if(current_position[X_AXIS] != x_home_pos(active_extruder))
-            set_destination_from_current();
-          else
-            no_move = true;
+
           dualx_tool_change(tmp_extruder, no_move); // Can modify no_move
 
         #else // !DUAL_X_CARRIAGE
-          // Save current position to destination, for use later
-          set_destination_from_current();
+
           #if ENABLED(PARKING_EXTRUDER) // Dual Parking extruder
             parking_extruder_tool_change(tmp_extruder, no_move);
           #endif
 
           #if ENABLED(SWITCHING_NOZZLE)
             // Always raise by at least 1 to avoid workpiece
             const float zdiff = hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
             current_position[Z_AXIS] += (zdiff > 0.0 ? zdiff : 0.0) + 1;
             planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
             move_nozzle_servo(tmp_extruder);

commit 6dafb90c0143d615430138f213a0fd232610119a
Author: silentninja1 <silent.ninja1@gmail.com>
Date:   Sat Jul 28 11:33:31 2018 -0400

    [2.0.x]Idex and bl touch fixes (#11395)
    
    * Fix BLTouch homing
    
    Deploy at start, dont call generic stow function at finish or raise goes too high before setting 0
    
    * Update tool_change.cpp
    
    * Update motion.cpp
    
    * Update motion.cpp
    
    * Update motion.cpp
    
    * Update motion.cpp
    
    * Change brackets to be more in align of Marlin coding standards

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 35c52cf7ae..bd8264b70d 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -370,35 +370,38 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
       feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
 
       if (tmp_extruder != active_extruder) {
         if (!no_move && axis_unhomed_error()) {
           no_move = true;
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("No move on toolchange");
           #endif
         }
 
-        // Save current position to destination, for use later
-        set_destination_from_current();
+        
 
         #if HAS_LEVELING
           // Set current position to the physical position
           const bool leveling_was_active = planner.leveling_active;
           set_bed_leveling_enabled(false);
         #endif
 
         #if ENABLED(DUAL_X_CARRIAGE)
-
+          if(current_position[X_AXIS] != x_home_pos(active_extruder))
+            set_destination_from_current();
+          else
+            no_move = true;
           dualx_tool_change(tmp_extruder, no_move); // Can modify no_move
 
         #else // !DUAL_X_CARRIAGE
-
+          // Save current position to destination, for use later
+          set_destination_from_current();
           #if ENABLED(PARKING_EXTRUDER) // Dual Parking extruder
             parking_extruder_tool_change(tmp_extruder, no_move);
           #endif
 
           #if ENABLED(SWITCHING_NOZZLE)
             // Always raise by at least 1 to avoid workpiece
             const float zdiff = hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
             current_position[Z_AXIS] += (zdiff > 0.0 ? zdiff : 0.0) + 1;
             planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
             move_nozzle_servo(tmp_extruder);

commit 63a146d42411ab4cc351bb13a3ec698906aceda3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jul 18 20:10:50 2018 -0500

    planner.synchronize at start of tool_change
    
    See https://github.com/MarlinFirmware/Marlin/issues/10949#issuecomment-398540498

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index d013c2c7a1..35c52cf7ae 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -345,20 +345,22 @@ inline void invalid_extruder_error(const uint8_t e) {
     // No extra case for HAS_ABL in DUAL_X_CARRIAGE. Does that mean they don't work together?
   }
 
 #endif // DUAL_X_CARRIAGE
 
 /**
  * Perform a tool-change, which may result in moving the
  * previous tool out of the way and the new tool into place.
  */
 void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
+  planner.synchronize();
+
   #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
 
     mixing_tool_change(tmp_extruder);
 
   #else // !MIXING_EXTRUDER || MIXING_VIRTUAL_TOOLS <= 1
 
     if (tmp_extruder >= EXTRUDERS)
       return invalid_extruder_error(tmp_extruder);
 
     #if HOTENDS > 1

commit f2c3b0d47646c5b56804f2474ae96c0884b783c8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jun 11 21:29:31 2018 -0500

    Use bit flags for homed/known

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 7cad6d1682..d013c2c7a1 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -73,21 +73,21 @@
     planner.synchronize();
     #if EXTRUDERS & 1
       if (e < EXTRUDERS - 1)
     #endif
     {
       MOVE_SERVO(_SERVO_NR, angles[e]);
       safe_delay(500);
     }
   }
 
-#endif // SWITCHING_EXTRUDER
+#endif // DO_SWITCH_EXTRUDER
 
 #if ENABLED(SWITCHING_NOZZLE)
 
   void move_nozzle_servo(const uint8_t e) {
     const int16_t angles[2] = SWITCHING_NOZZLE_SERVO_ANGLES;
     planner.synchronize();
     MOVE_SERVO(SWITCHING_NOZZLE_SERVO_NR, angles[e]);
     safe_delay(500);
   }
 

commit d2647c1f19c9658075e06d4c5f563312ae6aa794
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 22 00:53:00 2018 -0500

    Fix G1 behaviour after tool unpark
    
    Fix #10777 for 2.0.x
    
    Co-Authored-By: Ante Vukorepa <o.orcinus@gmail.com>

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index ee8659e128..7cad6d1682 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -447,20 +447,23 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
           #if DISABLED(SWITCHING_NOZZLE)
             // Do a small lift to avoid the workpiece in the move back (below)
             current_position[Z_AXIS] += 1.0;
             planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
           #endif
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) DEBUG_POS("Move back", destination);
           #endif
           // Move back to the original (or tweaked) position
           do_blocking_move_to(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS]);
+          #if ENABLED(DUAL_X_CARRIAGE)
+            active_extruder_parked = false;
+          #endif
         }
         #if ENABLED(SWITCHING_NOZZLE)
           else {
             // Move back down. (Including when the new tool is higher.)
             do_blocking_move_to_z(destination[Z_AXIS], planner.max_feedrate_mm_s[Z_AXIS]);
           }
         #endif
       } // (tmp_extruder != active_extruder)
 
       planner.synchronize();

commit 3c76bda2d8d1f198a9e6dcb94aca6e383c9d5392
Author: GMagician <GMagician@users.noreply.github.com>
Date:   Fri May 18 20:16:59 2018 +0200

    Fix switching extruder
    
    `DONT_SWITCH` got lost along the way. Replace it with `DO_SWITCH_EXTRUDER` and adjust the code.

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 2701a7707e..ee8659e128 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -50,21 +50,21 @@
 #endif
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
 #if HAS_FANMUX
   #include "../feature/fanmux.h"
 #endif
 
-#if ENABLED(SWITCHING_EXTRUDER)
+#if DO_SWITCH_EXTRUDER
 
   #if EXTRUDERS > 3
     #define REQ_ANGLES 4
     #define _SERVO_NR (e < 2 ? SWITCHING_EXTRUDER_SERVO_NR : SWITCHING_EXTRUDER_E23_SERVO_NR)
   #else
     #define REQ_ANGLES 2
     #define _SERVO_NR SWITCHING_EXTRUDER_SERVO_NR
   #endif
 
   void move_extruder_servo(const uint8_t e) {
@@ -340,22 +340,20 @@ inline void invalid_extruder_error(const uint8_t e) {
         SERIAL_ECHOLNPAIR("Active extruder parked: ", active_extruder_parked ? "yes" : "no");
         DEBUG_POS("New extruder (parked)", current_position);
       }
     #endif
 
     // No extra case for HAS_ABL in DUAL_X_CARRIAGE. Does that mean they don't work together?
   }
 
 #endif // DUAL_X_CARRIAGE
 
-#define DO_SWITCH_EXTRUDER (SWITCHING_EXTRUDER_SERVO_NR != SWITCHING_NOZZLE_SERVO_NR)
-
 /**
  * Perform a tool-change, which may result in moving the
  * previous tool out of the way and the new tool into place.
  */
 void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
   #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
 
     mixing_tool_change(tmp_extruder);
 
   #else // !MIXING_EXTRUDER || MIXING_VIRTUAL_TOOLS <= 1

commit 306f0f2135e4b2aed749a0d1b870abf17d883e38
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 12 01:38:02 2018 -0500

    Move Stepper::synchronize to Planner (#10713)
    
    Co-Authored-By: ejtagle <ejtagle@hotmail.com>

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 2bb071a20e..2701a7707e 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -17,21 +17,20 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
 #include "tool_change.h"
 
 #include "motion.h"
 #include "planner.h"
-#include "stepper.h"
 
 #include "../Marlin.h"
 
 #include "../inc/MarlinConfig.h"
 
 #if ENABLED(PARKING_EXTRUDER) && PARKING_EXTRUDER_SOLENOIDS_DELAY > 0
   #include "../gcode/gcode.h" // for dwell()
 #endif
 
 #if ENABLED(SWITCHING_EXTRUDER) || ENABLED(SWITCHING_NOZZLE)
@@ -64,37 +63,37 @@
     #define REQ_ANGLES 4
     #define _SERVO_NR (e < 2 ? SWITCHING_EXTRUDER_SERVO_NR : SWITCHING_EXTRUDER_E23_SERVO_NR)
   #else
     #define REQ_ANGLES 2
     #define _SERVO_NR SWITCHING_EXTRUDER_SERVO_NR
   #endif
 
   void move_extruder_servo(const uint8_t e) {
     constexpr int16_t angles[] = SWITCHING_EXTRUDER_SERVO_ANGLES;
     static_assert(COUNT(angles) == REQ_ANGLES, "SWITCHING_EXTRUDER_SERVO_ANGLES needs " STRINGIFY(REQ_ANGLES) " angles.");
-    stepper.synchronize();
+    planner.synchronize();
     #if EXTRUDERS & 1
       if (e < EXTRUDERS - 1)
     #endif
     {
       MOVE_SERVO(_SERVO_NR, angles[e]);
       safe_delay(500);
     }
   }
 
 #endif // SWITCHING_EXTRUDER
 
 #if ENABLED(SWITCHING_NOZZLE)
 
   void move_nozzle_servo(const uint8_t e) {
     const int16_t angles[2] = SWITCHING_NOZZLE_SERVO_ANGLES;
-    stepper.synchronize();
+    planner.synchronize();
     MOVE_SERVO(SWITCHING_NOZZLE_SERVO_NR, angles[e]);
     safe_delay(500);
   }
 
 #endif // SWITCHING_NOZZLE
 
 #if ENABLED(PARKING_EXTRUDER)
 
   void pe_magnet_init() {
     for (uint8_t n = 0; n <= 1; ++n)
@@ -137,78 +136,78 @@
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         SERIAL_ECHOLNPGM("Starting Autopark");
         if (DEBUGGING(LEVELING)) DEBUG_POS("current position:", current_position);
       #endif
       current_position[Z_AXIS] += PARKING_EXTRUDER_SECURITY_RAISE;
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         SERIAL_ECHOLNPGM("(1) Raise Z-Axis ");
         if (DEBUGGING(LEVELING)) DEBUG_POS("Moving to Raised Z-Position", current_position);
       #endif
       planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
-      stepper.synchronize();
+      planner.synchronize();
 
       // STEP 2
       current_position[X_AXIS] = parkingposx[active_extruder] + hotend_offset[X_AXIS][active_extruder];
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         SERIAL_ECHOLNPAIR("(2) Park extruder ", active_extruder);
         if (DEBUGGING(LEVELING)) DEBUG_POS("Moving ParkPos", current_position);
       #endif
       planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
-      stepper.synchronize();
+      planner.synchronize();
 
       // STEP 3
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         SERIAL_ECHOLNPGM("(3) Disengage magnet ");
       #endif
       pe_deactivate_magnet(active_extruder);
 
       // STEP 4
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         SERIAL_ECHOLNPGM("(4) Move to position near new extruder");
       #endif
       current_position[X_AXIS] += (active_extruder == 0 ? 10 : -10); // move 10mm away from parked extruder
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(LEVELING)) DEBUG_POS("Moving away from parked extruder", current_position);
       #endif
       planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
-      stepper.synchronize();
+      planner.synchronize();
 
       // STEP 5
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         SERIAL_ECHOLNPGM("(5) Engage magnetic field");
       #endif
 
       #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
         pe_activate_magnet(active_extruder); //just save power for inverted magnets
       #endif
       pe_activate_magnet(tmp_extruder);
 
       // STEP 6
       current_position[X_AXIS] = grabpos + (tmp_extruder == 0 ? (+10) : (-10));
       planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
       current_position[X_AXIS] = grabpos;
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         SERIAL_ECHOLNPAIR("(6) Unpark extruder ", tmp_extruder);
         if (DEBUGGING(LEVELING)) DEBUG_POS("Move UnparkPos", current_position);
       #endif
       planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS]/2, active_extruder);
-      stepper.synchronize();
+      planner.synchronize();
 
       // Step 7
       current_position[X_AXIS] = midpos - hotend_offset[X_AXIS][tmp_extruder];
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         SERIAL_ECHOLNPGM("(7) Move midway between hotends");
         if (DEBUGGING(LEVELING)) DEBUG_POS("Move midway to new extruder", current_position);
       #endif
       planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
-      stepper.synchronize();
+      planner.synchronize();
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         SERIAL_ECHOLNPGM("Autopark done.");
       #endif
     }
     else { // nomove == true
       // Only engage magnetic field for new extruder
       pe_activate_magnet(tmp_extruder);
       #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
         pe_activate_magnet(active_extruder); // Just save power for inverted magnets
       #endif
@@ -276,21 +275,21 @@ inline void invalid_extruder_error(const uint8_t e) {
       // Park old head: 1) raise 2) move to park position 3) lower
       for (uint8_t i = 0; i < 3; i++)
         planner.buffer_line(
           i == 0 ? current_position[X_AXIS] : xhome,
           current_position[Y_AXIS],
           i == 2 ? current_position[Z_AXIS] : raised_z,
           current_position[E_AXIS],
           planner.max_feedrate_mm_s[i == 1 ? X_AXIS : Z_AXIS],
           active_extruder
         );
-      stepper.synchronize();
+      planner.synchronize();
     }
 
     // Apply Y & Z extruder offset (X offset is used as home pos with Dual X)
     current_position[Y_AXIS] -= hotend_offset[Y_AXIS][active_extruder] - hotend_offset[Y_AXIS][tmp_extruder];
     current_position[Z_AXIS] -= hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
 
     // Activate the new extruder ahead of calling set_axis_is_at_home!
     active_extruder = tmp_extruder;
 
     // This function resets the max/min values - the current position may be overwritten below.
@@ -459,21 +458,21 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
           do_blocking_move_to(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS]);
         }
         #if ENABLED(SWITCHING_NOZZLE)
           else {
             // Move back down. (Including when the new tool is higher.)
             do_blocking_move_to_z(destination[Z_AXIS], planner.max_feedrate_mm_s[Z_AXIS]);
           }
         #endif
       } // (tmp_extruder != active_extruder)
 
-      stepper.synchronize();
+      planner.synchronize();
 
       #if ENABLED(EXT_SOLENOID) && !ENABLED(PARKING_EXTRUDER)
         disable_all_solenoids();
         enable_solenoid_on_active_extruder();
       #endif
 
       feedrate_mm_s = old_feedrate_mm_s;
 
     #else // HOTENDS <= 1
 
@@ -486,21 +485,21 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
 
         select_multiplexed_stepper(tmp_extruder);
       #endif
 
       // Set the new active extruder
       active_extruder = tmp_extruder;
 
     #endif // HOTENDS <= 1
 
     #if DO_SWITCH_EXTRUDER
-      stepper.synchronize();
+      planner.synchronize();
       move_extruder_servo(active_extruder);
     #endif
 
     #if HAS_FANMUX
       fanmux_switch(active_extruder);
     #endif
 
     SERIAL_ECHO_START();
     SERIAL_ECHOLNPAIR(MSG_ACTIVE_EXTRUDER, (int)active_extruder);
 

commit 21a47b50f4f6489759e2430bd6273cd7dbd0df82
Author: GMagician <3684609+GMagician@users.noreply.github.com>
Date:   Thu Apr 5 00:06:33 2018 +0200

    Additional tool-change fixes (#10304)
    
    Followup to #10257

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index bbed2cafb3..2bb071a20e 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -391,23 +391,23 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
 
           dualx_tool_change(tmp_extruder, no_move); // Can modify no_move
 
         #else // !DUAL_X_CARRIAGE
 
           #if ENABLED(PARKING_EXTRUDER) // Dual Parking extruder
             parking_extruder_tool_change(tmp_extruder, no_move);
           #endif
 
           #if ENABLED(SWITCHING_NOZZLE)
-            // Always raise by at least 0.3
-            const float z_diff = hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
-            current_position[Z_AXIS] += (z_diff > 0.0 ? z_diff : 0.0) + 0.3;
+            // Always raise by at least 1 to avoid workpiece
+            const float zdiff = hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
+            current_position[Z_AXIS] += (zdiff > 0.0 ? zdiff : 0.0) + 1;
             planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
             move_nozzle_servo(tmp_extruder);
           #endif
 
           const float xdiff = hotend_offset[X_AXIS][tmp_extruder] - hotend_offset[X_AXIS][active_extruder],
                       ydiff = hotend_offset[Y_AXIS][tmp_extruder] - hotend_offset[Y_AXIS][active_extruder];
 
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) {
               SERIAL_ECHOPAIR("Offset Tool XY by { ", xdiff);
@@ -423,39 +423,42 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
           // Set the new active extruder
           active_extruder = tmp_extruder;
 
         #endif // !DUAL_X_CARRIAGE
 
         #if HAS_LEVELING
           // Restore leveling to re-establish the logical position
           set_bed_leveling_enabled(leveling_was_active);
         #endif
 
+        #if ENABLED(SWITCHING_NOZZLE)
+          // The newly-selected extruder Z is actually at...
+          current_position[Z_AXIS] -= zdiff;
+        #endif
+
         // Tell the planner the new "current position"
         SYNC_PLAN_POSITION_KINEMATIC();
 
         #if ENABLED(DELTA)
           //LOOP_XYZ(i) update_software_endstops(i); // or modify the constrain function
           const bool safe_to_move = current_position[Z_AXIS] < delta_clip_start_height - 1;
         #else
           constexpr bool safe_to_move = true;
         #endif
 
-        #if ENABLED(SWITCHING_NOZZLE)
-          destination[Z_AXIS] += z_diff;  // Include the Z restore with the "move back"
-        #endif
-
         // Raise, move, and lower again
         if (safe_to_move && !no_move && IsRunning()) {
-          // Do a small lift to avoid the workpiece in the move back (below)
-          current_position[Z_AXIS] += 1.0;
-          planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
+          #if DISABLED(SWITCHING_NOZZLE)
+            // Do a small lift to avoid the workpiece in the move back (below)
+            current_position[Z_AXIS] += 1.0;
+            planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
+          #endif
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) DEBUG_POS("Move back", destination);
           #endif
           // Move back to the original (or tweaked) position
           do_blocking_move_to(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS]);
         }
         #if ENABLED(SWITCHING_NOZZLE)
           else {
             // Move back down. (Including when the new tool is higher.)
             do_blocking_move_to_z(destination[Z_AXIS], planner.max_feedrate_mm_s[Z_AXIS]);

commit 2672120a97e14d8639de7bbb7ffd9535f621a016
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Mar 29 18:35:16 2018 -0500

    Do a small raise for all move-back

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 6e3938735c..bbed2cafb3 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -437,21 +437,25 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
           //LOOP_XYZ(i) update_software_endstops(i); // or modify the constrain function
           const bool safe_to_move = current_position[Z_AXIS] < delta_clip_start_height - 1;
         #else
           constexpr bool safe_to_move = true;
         #endif
 
         #if ENABLED(SWITCHING_NOZZLE)
           destination[Z_AXIS] += z_diff;  // Include the Z restore with the "move back"
         #endif
 
+        // Raise, move, and lower again
         if (safe_to_move && !no_move && IsRunning()) {
+          // Do a small lift to avoid the workpiece in the move back (below)
+          current_position[Z_AXIS] += 1.0;
+          planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) DEBUG_POS("Move back", destination);
           #endif
           // Move back to the original (or tweaked) position
           do_blocking_move_to(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS]);
         }
         #if ENABLED(SWITCHING_NOZZLE)
           else {
             // Move back down. (Including when the new tool is higher.)
             do_blocking_move_to_z(destination[Z_AXIS], planner.max_feedrate_mm_s[Z_AXIS]);

commit 5acccbacc14521dda4ca6af875f6fa71a0600dda
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Mar 29 18:29:52 2018 -0500

    Simplified leveling-based tool change

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 4913f8ed15..6e3938735c 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -109,22 +109,20 @@
     switch (extruder_num) {
       case 1: OUT_WRITE(SOL1_PIN, state); break;
       default: OUT_WRITE(SOL0_PIN, state); break;
     }
     #if PARKING_EXTRUDER_SOLENOIDS_DELAY > 0
       gcode.dwell(PARKING_EXTRUDER_SOLENOIDS_DELAY);
     #endif
   }
 
   inline void parking_extruder_tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
-    constexpr float z_raise = PARKING_EXTRUDER_SECURITY_RAISE;
-
     if (!no_move) {
 
       const float parkingposx[] = PARKING_EXTRUDER_PARKING_X,
                   midpos = (parkingposx[0] + parkingposx[1]) * 0.5 + hotend_offset[X_AXIS][active_extruder],
                   grabpos = parkingposx[tmp_extruder] + hotend_offset[X_AXIS][active_extruder]
                             + (tmp_extruder == 0 ? -(PARKING_EXTRUDER_GRAB_DISTANCE) : PARKING_EXTRUDER_GRAB_DISTANCE);
       /**
        *  Steps:
        *    1. Raise Z-Axis to give enough clearance
        *    2. Move to park position of old extruder
@@ -133,21 +131,21 @@
        *    5. Engage magnetic field for new extruder
        *    6. Move to parking incl. offset of new extruder
        *    7. Lower Z-Axis
        */
 
       // STEP 1
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         SERIAL_ECHOLNPGM("Starting Autopark");
         if (DEBUGGING(LEVELING)) DEBUG_POS("current position:", current_position);
       #endif
-      current_position[Z_AXIS] += z_raise;
+      current_position[Z_AXIS] += PARKING_EXTRUDER_SECURITY_RAISE;
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         SERIAL_ECHOLNPGM("(1) Raise Z-Axis ");
         if (DEBUGGING(LEVELING)) DEBUG_POS("Moving to Raised Z-Position", current_position);
       #endif
       planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
       stepper.synchronize();
 
       // STEP 2
       current_position[X_AXIS] = parkingposx[active_extruder] + hotend_offset[X_AXIS][active_extruder];
       #if ENABLED(DEBUG_LEVELING_FEATURE)
@@ -343,20 +341,22 @@ inline void invalid_extruder_error(const uint8_t e) {
         SERIAL_ECHOLNPAIR("Active extruder parked: ", active_extruder_parked ? "yes" : "no");
         DEBUG_POS("New extruder (parked)", current_position);
       }
     #endif
 
     // No extra case for HAS_ABL in DUAL_X_CARRIAGE. Does that mean they don't work together?
   }
 
 #endif // DUAL_X_CARRIAGE
 
+#define DO_SWITCH_EXTRUDER (SWITCHING_EXTRUDER_SERVO_NR != SWITCHING_NOZZLE_SERVO_NR)
+
 /**
  * Perform a tool-change, which may result in moving the
  * previous tool out of the way and the new tool into place.
  */
 void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
   #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
 
     mixing_tool_change(tmp_extruder);
 
   #else // !MIXING_EXTRUDER || MIXING_VIRTUAL_TOOLS <= 1
@@ -374,159 +374,79 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
         if (!no_move && axis_unhomed_error()) {
           no_move = true;
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("No move on toolchange");
           #endif
         }
 
         // Save current position to destination, for use later
         set_destination_from_current();
 
+        #if HAS_LEVELING
+          // Set current position to the physical position
+          const bool leveling_was_active = planner.leveling_active;
+          set_bed_leveling_enabled(false);
+        #endif
+
         #if ENABLED(DUAL_X_CARRIAGE)
 
           dualx_tool_change(tmp_extruder, no_move); // Can modify no_move
 
         #else // !DUAL_X_CARRIAGE
 
-          #if ENABLED(PARKING_EXTRUDER)
+          #if ENABLED(PARKING_EXTRUDER) // Dual Parking extruder
             parking_extruder_tool_change(tmp_extruder, no_move);
           #endif
 
           #if ENABLED(SWITCHING_NOZZLE)
-            #define DONT_SWITCH (SWITCHING_EXTRUDER_SERVO_NR == SWITCHING_NOZZLE_SERVO_NR)
-            // <0 if the new nozzle is higher, >0 if lower. A bigger raise when lower.
-            const float z_diff = hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder],
-                        z_raise = 0.3 + (z_diff > 0.0 ? z_diff : 0.0);
-
-            // Always raise by some amount
-            current_position[Z_AXIS] += z_raise;
+            // Always raise by at least 0.3
+            const float z_diff = hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
+            current_position[Z_AXIS] += (z_diff > 0.0 ? z_diff : 0.0) + 0.3;
             planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
             move_nozzle_servo(tmp_extruder);
           #endif
 
-          /**
-           * Set current_position to the position of the new nozzle.
-           * Offsets are based on linear distance, so we need to get
-           * the resulting position in coordinate space.
-           *
-           * - With grid or 3-point leveling, offset XYZ by a tilted vector
-           * - With mesh leveling, update Z for the new position
-           * - Otherwise, just use the raw linear distance
-           *
-           * Software endstops are altered here too. Consider a case where:
-           *   E0 at X=0 ... E1 at X=10
-           * When we switch to E1 now X=10, but E1 can't move left.
-           * To express this we apply the change in XY to the software endstops.
-           * E1 can move farther right than E0, so the right limit is extended.
-           *
-           * Note that we don't adjust the Z software endstops. Why not?
-           * Consider a case where Z=0 (here) and switching to E1 makes Z=1
-           * because the bed is 1mm lower at the new position. As long as
-           * the first nozzle is out of the way, the carriage should be
-           * allowed to move 1mm lower. This technically "breaks" the
-           * Z software endstop. But this is technically correct (and
-           * there is no viable alternative).
-           */
-          #if ABL_PLANAR
-            // Offset extruder, make sure to apply the bed level rotation matrix
-            vector_3 tmp_offset_vec = vector_3(hotend_offset[X_AXIS][tmp_extruder],
-                                               hotend_offset[Y_AXIS][tmp_extruder],
-                                               0),
-                     act_offset_vec = vector_3(hotend_offset[X_AXIS][active_extruder],
-                                               hotend_offset[Y_AXIS][active_extruder],
-                                               0),
-                     offset_vec = tmp_offset_vec - act_offset_vec;
-
-            #if ENABLED(DEBUG_LEVELING_FEATURE)
-              if (DEBUGGING(LEVELING)) {
-                tmp_offset_vec.debug(PSTR("tmp_offset_vec"));
-                act_offset_vec.debug(PSTR("act_offset_vec"));
-                offset_vec.debug(PSTR("offset_vec (BEFORE)"));
-              }
-            #endif
-
-            offset_vec.apply_rotation(planner.bed_level_matrix.transpose(planner.bed_level_matrix));
-
-            #if ENABLED(DEBUG_LEVELING_FEATURE)
-              if (DEBUGGING(LEVELING)) offset_vec.debug(PSTR("offset_vec (AFTER)"));
-            #endif
-
-            // Adjustments to the current position
-            const float xydiff[2] = { offset_vec.x, offset_vec.y };
-            current_position[Z_AXIS] += offset_vec.z;
-
-          #else // !ABL_PLANAR
-
-            const float xydiff[2] = {
-              hotend_offset[X_AXIS][tmp_extruder] - hotend_offset[X_AXIS][active_extruder],
-              hotend_offset[Y_AXIS][tmp_extruder] - hotend_offset[Y_AXIS][active_extruder]
-            };
-
-            #if HAS_MESH && PLANNER_LEVELING
-
-              if (planner.leveling_active) {
-                #if ENABLED(DEBUG_LEVELING_FEATURE)
-                  if (DEBUGGING(LEVELING)) SERIAL_ECHOPAIR("Z before: ", current_position[Z_AXIS]);
-                #endif
-                float x2 = current_position[X_AXIS] + xydiff[X_AXIS],
-                      y2 = current_position[Y_AXIS] + xydiff[Y_AXIS],
-                      z1 = current_position[Z_AXIS], z2 = z1;
-                planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], z1);
-                planner.apply_leveling(x2, y2, z2);
-                current_position[Z_AXIS] += z2 - z1;
-                #if ENABLED(DEBUG_LEVELING_FEATURE)
-                  if (DEBUGGING(LEVELING))
-                    SERIAL_ECHOLNPAIR(" after: ", current_position[Z_AXIS]);
-                #endif
-              }
-
-            #endif // HAS_MESH && PLANNER_LEVELING
-
-          #endif // !HAS_ABL
+          const float xdiff = hotend_offset[X_AXIS][tmp_extruder] - hotend_offset[X_AXIS][active_extruder],
+                      ydiff = hotend_offset[Y_AXIS][tmp_extruder] - hotend_offset[Y_AXIS][active_extruder];
 
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) {
-              SERIAL_ECHOPAIR("Offset Tool XY by { ", xydiff[X_AXIS]);
-              SERIAL_ECHOPAIR(", ", xydiff[Y_AXIS]);
+              SERIAL_ECHOPAIR("Offset Tool XY by { ", xdiff);
+              SERIAL_ECHOPAIR(", ", ydiff);
               SERIAL_ECHOLNPGM(" }");
             }
           #endif
 
           // The newly-selected extruder XY is actually at...
-          current_position[X_AXIS] += xydiff[X_AXIS];
-          current_position[Y_AXIS] += xydiff[Y_AXIS];
+          current_position[X_AXIS] += xdiff;
+          current_position[Y_AXIS] += ydiff;
 
           // Set the new active extruder
           active_extruder = tmp_extruder;
 
         #endif // !DUAL_X_CARRIAGE
 
-        #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) DEBUG_POS("Sync After Toolchange", current_position);
+        #if HAS_LEVELING
+          // Restore leveling to re-establish the logical position
+          set_bed_leveling_enabled(leveling_was_active);
         #endif
 
         // Tell the planner the new "current position"
         SYNC_PLAN_POSITION_KINEMATIC();
 
         #if ENABLED(DELTA)
           //LOOP_XYZ(i) update_software_endstops(i); // or modify the constrain function
-          // Do a small lift to avoid the workpiece in the move back (below)
           const bool safe_to_move = current_position[Z_AXIS] < delta_clip_start_height - 1;
-          if (safe_to_move && !no_move && IsRunning()) {
-            ++current_position[Z_AXIS];
-            planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
-          }
         #else
           constexpr bool safe_to_move = true;
         #endif
 
-        // Move to the "old position" (move the extruder into place)
         #if ENABLED(SWITCHING_NOZZLE)
           destination[Z_AXIS] += z_diff;  // Include the Z restore with the "move back"
         #endif
 
         if (safe_to_move && !no_move && IsRunning()) {
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) DEBUG_POS("Move back", destination);
           #endif
           // Move back to the original (or tweaked) position
           do_blocking_move_to(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS]);
@@ -537,42 +457,42 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
             do_blocking_move_to_z(destination[Z_AXIS], planner.max_feedrate_mm_s[Z_AXIS]);
           }
         #endif
       } // (tmp_extruder != active_extruder)
 
       stepper.synchronize();
 
       #if ENABLED(EXT_SOLENOID) && !ENABLED(PARKING_EXTRUDER)
         disable_all_solenoids();
         enable_solenoid_on_active_extruder();
-      #endif // EXT_SOLENOID
+      #endif
 
       feedrate_mm_s = old_feedrate_mm_s;
 
     #else // HOTENDS <= 1
 
       UNUSED(fr_mm_s);
       UNUSED(no_move);
 
       #if ENABLED(MK2_MULTIPLEXER)
         if (tmp_extruder >= E_STEPPERS)
           return invalid_extruder_error(tmp_extruder);
 
         select_multiplexed_stepper(tmp_extruder);
       #endif
 
       // Set the new active extruder
       active_extruder = tmp_extruder;
 
     #endif // HOTENDS <= 1
 
-    #if ENABLED(SWITCHING_EXTRUDER) && !DONT_SWITCH
+    #if DO_SWITCH_EXTRUDER
       stepper.synchronize();
       move_extruder_servo(active_extruder);
     #endif
 
     #if HAS_FANMUX
       fanmux_switch(active_extruder);
     #endif
 
     SERIAL_ECHO_START();
     SERIAL_ECHOLNPAIR(MSG_ACTIVE_EXTRUDER, (int)active_extruder);

commit d1734a089abe66cf9afa71ce16af524d0f93e106
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Mar 29 18:11:02 2018 -0500

    Split up tool_change for some setups

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 7b3bf480bd..4913f8ed15 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -108,44 +108,263 @@
   void pe_set_magnet(const uint8_t extruder_num, const uint8_t state) {
     switch (extruder_num) {
       case 1: OUT_WRITE(SOL1_PIN, state); break;
       default: OUT_WRITE(SOL0_PIN, state); break;
     }
     #if PARKING_EXTRUDER_SOLENOIDS_DELAY > 0
       gcode.dwell(PARKING_EXTRUDER_SOLENOIDS_DELAY);
     #endif
   }
 
-#endif // PARKING_EXTRUDER
+  inline void parking_extruder_tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
+    constexpr float z_raise = PARKING_EXTRUDER_SECURITY_RAISE;
+
+    if (!no_move) {
+
+      const float parkingposx[] = PARKING_EXTRUDER_PARKING_X,
+                  midpos = (parkingposx[0] + parkingposx[1]) * 0.5 + hotend_offset[X_AXIS][active_extruder],
+                  grabpos = parkingposx[tmp_extruder] + hotend_offset[X_AXIS][active_extruder]
+                            + (tmp_extruder == 0 ? -(PARKING_EXTRUDER_GRAB_DISTANCE) : PARKING_EXTRUDER_GRAB_DISTANCE);
+      /**
+       *  Steps:
+       *    1. Raise Z-Axis to give enough clearance
+       *    2. Move to park position of old extruder
+       *    3. Disengage magnetic field, wait for delay
+       *    4. Move near new extruder
+       *    5. Engage magnetic field for new extruder
+       *    6. Move to parking incl. offset of new extruder
+       *    7. Lower Z-Axis
+       */
+
+      // STEP 1
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        SERIAL_ECHOLNPGM("Starting Autopark");
+        if (DEBUGGING(LEVELING)) DEBUG_POS("current position:", current_position);
+      #endif
+      current_position[Z_AXIS] += z_raise;
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        SERIAL_ECHOLNPGM("(1) Raise Z-Axis ");
+        if (DEBUGGING(LEVELING)) DEBUG_POS("Moving to Raised Z-Position", current_position);
+      #endif
+      planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
+      stepper.synchronize();
+
+      // STEP 2
+      current_position[X_AXIS] = parkingposx[active_extruder] + hotend_offset[X_AXIS][active_extruder];
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        SERIAL_ECHOLNPAIR("(2) Park extruder ", active_extruder);
+        if (DEBUGGING(LEVELING)) DEBUG_POS("Moving ParkPos", current_position);
+      #endif
+      planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
+      stepper.synchronize();
+
+      // STEP 3
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        SERIAL_ECHOLNPGM("(3) Disengage magnet ");
+      #endif
+      pe_deactivate_magnet(active_extruder);
+
+      // STEP 4
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        SERIAL_ECHOLNPGM("(4) Move to position near new extruder");
+      #endif
+      current_position[X_AXIS] += (active_extruder == 0 ? 10 : -10); // move 10mm away from parked extruder
+
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        if (DEBUGGING(LEVELING)) DEBUG_POS("Moving away from parked extruder", current_position);
+      #endif
+      planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
+      stepper.synchronize();
 
+      // STEP 5
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        SERIAL_ECHOLNPGM("(5) Engage magnetic field");
+      #endif
+
+      #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
+        pe_activate_magnet(active_extruder); //just save power for inverted magnets
+      #endif
+      pe_activate_magnet(tmp_extruder);
+
+      // STEP 6
+      current_position[X_AXIS] = grabpos + (tmp_extruder == 0 ? (+10) : (-10));
+      planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
+      current_position[X_AXIS] = grabpos;
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        SERIAL_ECHOLNPAIR("(6) Unpark extruder ", tmp_extruder);
+        if (DEBUGGING(LEVELING)) DEBUG_POS("Move UnparkPos", current_position);
+      #endif
+      planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS]/2, active_extruder);
+      stepper.synchronize();
+
+      // Step 7
+      current_position[X_AXIS] = midpos - hotend_offset[X_AXIS][tmp_extruder];
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        SERIAL_ECHOLNPGM("(7) Move midway between hotends");
+        if (DEBUGGING(LEVELING)) DEBUG_POS("Move midway to new extruder", current_position);
+      #endif
+      planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
+      stepper.synchronize();
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        SERIAL_ECHOLNPGM("Autopark done.");
+      #endif
+    }
+    else { // nomove == true
+      // Only engage magnetic field for new extruder
+      pe_activate_magnet(tmp_extruder);
+      #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
+        pe_activate_magnet(active_extruder); // Just save power for inverted magnets
+      #endif
+    }
+    current_position[Z_AXIS] += hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) DEBUG_POS("Applying Z-offset", current_position);
+    #endif
+  }
+
+#endif // PARKING_EXTRUDER
 
 inline void invalid_extruder_error(const uint8_t e) {
   SERIAL_ECHO_START();
   SERIAL_CHAR('T');
   SERIAL_ECHO_F(e, DEC);
   SERIAL_CHAR(' ');
   SERIAL_ECHOLNPGM(MSG_INVALID_EXTRUDER);
 }
 
-/**
- * Perform a tool-change, which may result in moving the
- * previous tool out of the way and the new tool into place.
- */
-void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
-  #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
+#if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
 
+  inline void mixing_tool_change(const uint8_t tmp_extruder) {
     if (tmp_extruder >= MIXING_VIRTUAL_TOOLS)
       return invalid_extruder_error(tmp_extruder);
 
     // T0-Tnnn: Switch virtual tool by changing the mix
     for (uint8_t j = 0; j < MIXING_STEPPERS; j++)
       mixing_factor[j] = mixing_virtual_tool_mix[tmp_extruder][j];
+  }
+
+#endif // MIXING_EXTRUDER && MIXING_VIRTUAL_TOOLS > 1
+
+#if ENABLED(DUAL_X_CARRIAGE)
+
+  inline void dualx_tool_change(const uint8_t tmp_extruder, bool &no_move) {
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) {
+        SERIAL_ECHOPGM("Dual X Carriage Mode ");
+        switch (dual_x_carriage_mode) {
+          case DXC_FULL_CONTROL_MODE: SERIAL_ECHOLNPGM("DXC_FULL_CONTROL_MODE"); break;
+          case DXC_AUTO_PARK_MODE: SERIAL_ECHOLNPGM("DXC_AUTO_PARK_MODE"); break;
+          case DXC_DUPLICATION_MODE: SERIAL_ECHOLNPGM("DXC_DUPLICATION_MODE"); break;
+        }
+      }
+    #endif
+
+    const float xhome = x_home_pos(active_extruder);
+    if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE
+        && IsRunning()
+        && (delayed_move_time || current_position[X_AXIS] != xhome)
+    ) {
+      float raised_z = current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT;
+      #if ENABLED(MAX_SOFTWARE_ENDSTOPS)
+        NOMORE(raised_z, soft_endstop_max[Z_AXIS]);
+      #endif
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        if (DEBUGGING(LEVELING)) {
+          SERIAL_ECHOLNPAIR("Raise to ", raised_z);
+          SERIAL_ECHOLNPAIR("MoveX to ", xhome);
+          SERIAL_ECHOLNPAIR("Lower to ", current_position[Z_AXIS]);
+        }
+      #endif
+      // Park old head: 1) raise 2) move to park position 3) lower
+      for (uint8_t i = 0; i < 3; i++)
+        planner.buffer_line(
+          i == 0 ? current_position[X_AXIS] : xhome,
+          current_position[Y_AXIS],
+          i == 2 ? current_position[Z_AXIS] : raised_z,
+          current_position[E_AXIS],
+          planner.max_feedrate_mm_s[i == 1 ? X_AXIS : Z_AXIS],
+          active_extruder
+        );
+      stepper.synchronize();
+    }
+
+    // Apply Y & Z extruder offset (X offset is used as home pos with Dual X)
+    current_position[Y_AXIS] -= hotend_offset[Y_AXIS][active_extruder] - hotend_offset[Y_AXIS][tmp_extruder];
+    current_position[Z_AXIS] -= hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
+
+    // Activate the new extruder ahead of calling set_axis_is_at_home!
+    active_extruder = tmp_extruder;
+
+    // This function resets the max/min values - the current position may be overwritten below.
+    set_axis_is_at_home(X_AXIS);
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) DEBUG_POS("New Extruder", current_position);
+    #endif
+
+    // Only when auto-parking are carriages safe to move
+    if (dual_x_carriage_mode != DXC_AUTO_PARK_MODE) no_move = true;
+
+    switch (dual_x_carriage_mode) {
+      case DXC_FULL_CONTROL_MODE:
+        // New current position is the position of the activated extruder
+        current_position[X_AXIS] = inactive_extruder_x_pos;
+        // Save the inactive extruder's position (from the old current_position)
+        inactive_extruder_x_pos = destination[X_AXIS];
+        break;
+      case DXC_AUTO_PARK_MODE:
+        // record raised toolhead position for use by unpark
+        COPY(raised_parked_position, current_position);
+        raised_parked_position[Z_AXIS] += TOOLCHANGE_UNPARK_ZLIFT;
+        #if ENABLED(MAX_SOFTWARE_ENDSTOPS)
+          NOMORE(raised_parked_position[Z_AXIS], soft_endstop_max[Z_AXIS]);
+        #endif
+        active_extruder_parked = true;
+        delayed_move_time = 0;
+        break;
+      case DXC_DUPLICATION_MODE:
+        // If the new extruder is the left one, set it "parked"
+        // This triggers the second extruder to move into the duplication position
+        active_extruder_parked = (active_extruder == 0);
+        current_position[X_AXIS] = active_extruder_parked ? inactive_extruder_x_pos : destination[X_AXIS] + duplicate_extruder_x_offset;
+        inactive_extruder_x_pos = destination[X_AXIS];
+        extruder_duplication_enabled = false;
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) {
+            SERIAL_ECHOLNPAIR("Set inactive_extruder_x_pos=", inactive_extruder_x_pos);
+            SERIAL_ECHOLNPGM("Clear extruder_duplication_enabled");
+          }
+        #endif
+        break;
+    }
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) {
+        SERIAL_ECHOLNPAIR("Active extruder parked: ", active_extruder_parked ? "yes" : "no");
+        DEBUG_POS("New extruder (parked)", current_position);
+      }
+    #endif
+
+    // No extra case for HAS_ABL in DUAL_X_CARRIAGE. Does that mean they don't work together?
+  }
+
+#endif // DUAL_X_CARRIAGE
+
+/**
+ * Perform a tool-change, which may result in moving the
+ * previous tool out of the way and the new tool into place.
+ */
+void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
+  #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
+
+    mixing_tool_change(tmp_extruder);
 
   #else // !MIXING_EXTRUDER || MIXING_VIRTUAL_TOOLS <= 1
 
     if (tmp_extruder >= EXTRUDERS)
       return invalid_extruder_error(tmp_extruder);
 
     #if HOTENDS > 1
 
       const float old_feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : feedrate_mm_s;
 
@@ -157,231 +376,27 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("No move on toolchange");
           #endif
         }
 
         // Save current position to destination, for use later
         set_destination_from_current();
 
         #if ENABLED(DUAL_X_CARRIAGE)
 
-          #if ENABLED(DEBUG_LEVELING_FEATURE)
-            if (DEBUGGING(LEVELING)) {
-              SERIAL_ECHOPGM("Dual X Carriage Mode ");
-              switch (dual_x_carriage_mode) {
-                case DXC_FULL_CONTROL_MODE: SERIAL_ECHOLNPGM("DXC_FULL_CONTROL_MODE"); break;
-                case DXC_AUTO_PARK_MODE: SERIAL_ECHOLNPGM("DXC_AUTO_PARK_MODE"); break;
-                case DXC_DUPLICATION_MODE: SERIAL_ECHOLNPGM("DXC_DUPLICATION_MODE"); break;
-              }
-            }
-          #endif
-
-          const float xhome = x_home_pos(active_extruder);
-          if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE
-              && IsRunning()
-              && (delayed_move_time || current_position[X_AXIS] != xhome)
-          ) {
-            float raised_z = current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT;
-            #if ENABLED(MAX_SOFTWARE_ENDSTOPS)
-              NOMORE(raised_z, soft_endstop_max[Z_AXIS]);
-            #endif
-            #if ENABLED(DEBUG_LEVELING_FEATURE)
-              if (DEBUGGING(LEVELING)) {
-                SERIAL_ECHOLNPAIR("Raise to ", raised_z);
-                SERIAL_ECHOLNPAIR("MoveX to ", xhome);
-                SERIAL_ECHOLNPAIR("Lower to ", current_position[Z_AXIS]);
-              }
-            #endif
-            // Park old head: 1) raise 2) move to park position 3) lower
-            for (uint8_t i = 0; i < 3; i++)
-              planner.buffer_line(
-                i == 0 ? current_position[X_AXIS] : xhome,
-                current_position[Y_AXIS],
-                i == 2 ? current_position[Z_AXIS] : raised_z,
-                current_position[E_AXIS],
-                planner.max_feedrate_mm_s[i == 1 ? X_AXIS : Z_AXIS],
-                active_extruder
-              );
-            stepper.synchronize();
-          }
-
-          // Apply Y & Z extruder offset (X offset is used as home pos with Dual X)
-          current_position[Y_AXIS] -= hotend_offset[Y_AXIS][active_extruder] - hotend_offset[Y_AXIS][tmp_extruder];
-          current_position[Z_AXIS] -= hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
-
-          // Activate the new extruder ahead of calling set_axis_is_at_home!
-          active_extruder = tmp_extruder;
-
-          // This function resets the max/min values - the current position may be overwritten below.
-          set_axis_is_at_home(X_AXIS);
-
-          #if ENABLED(DEBUG_LEVELING_FEATURE)
-            if (DEBUGGING(LEVELING)) DEBUG_POS("New Extruder", current_position);
-          #endif
-
-          // Only when auto-parking are carriages safe to move
-          if (dual_x_carriage_mode != DXC_AUTO_PARK_MODE) no_move = true;
-
-          switch (dual_x_carriage_mode) {
-            case DXC_FULL_CONTROL_MODE:
-              // New current position is the position of the activated extruder
-              current_position[X_AXIS] = inactive_extruder_x_pos;
-              // Save the inactive extruder's position (from the old current_position)
-              inactive_extruder_x_pos = destination[X_AXIS];
-              break;
-            case DXC_AUTO_PARK_MODE:
-              // record raised toolhead position for use by unpark
-              COPY(raised_parked_position, current_position);
-              raised_parked_position[Z_AXIS] += TOOLCHANGE_UNPARK_ZLIFT;
-              #if ENABLED(MAX_SOFTWARE_ENDSTOPS)
-                NOMORE(raised_parked_position[Z_AXIS], soft_endstop_max[Z_AXIS]);
-              #endif
-              active_extruder_parked = true;
-              delayed_move_time = 0;
-              break;
-            case DXC_DUPLICATION_MODE:
-              // If the new extruder is the left one, set it "parked"
-              // This triggers the second extruder to move into the duplication position
-              active_extruder_parked = (active_extruder == 0);
-
-              if (active_extruder_parked)
-                current_position[X_AXIS] = inactive_extruder_x_pos;
-              else
-                current_position[X_AXIS] = destination[X_AXIS] + duplicate_extruder_x_offset;
-              inactive_extruder_x_pos = destination[X_AXIS];
-              extruder_duplication_enabled = false;
-              #if ENABLED(DEBUG_LEVELING_FEATURE)
-                if (DEBUGGING(LEVELING)) {
-                  SERIAL_ECHOLNPAIR("Set inactive_extruder_x_pos=", inactive_extruder_x_pos);
-                  SERIAL_ECHOLNPGM("Clear extruder_duplication_enabled");
-                }
-              #endif
-              break;
-          }
-
-          #if ENABLED(DEBUG_LEVELING_FEATURE)
-            if (DEBUGGING(LEVELING)) {
-              SERIAL_ECHOLNPAIR("Active extruder parked: ", active_extruder_parked ? "yes" : "no");
-              DEBUG_POS("New extruder (parked)", current_position);
-            }
-          #endif
-
-          // No extra case for HAS_ABL in DUAL_X_CARRIAGE. Does that mean they don't work together?
+          dualx_tool_change(tmp_extruder, no_move); // Can modify no_move
 
         #else // !DUAL_X_CARRIAGE
 
-          #if ENABLED(PARKING_EXTRUDER) // Dual Parking extruder
-            float z_raise = PARKING_EXTRUDER_SECURITY_RAISE;
-            if (!no_move) {
-
-              const float parkingposx[] = PARKING_EXTRUDER_PARKING_X,
-                          midpos = (parkingposx[0] + parkingposx[1]) * 0.5 + hotend_offset[X_AXIS][active_extruder],
-                          grabpos = parkingposx[tmp_extruder] + hotend_offset[X_AXIS][active_extruder]
-                                    + (tmp_extruder == 0 ? -(PARKING_EXTRUDER_GRAB_DISTANCE) : PARKING_EXTRUDER_GRAB_DISTANCE);
-              /**
-               *  Steps:
-               *    1. Raise Z-Axis to give enough clearance
-               *    2. Move to park position of old extruder
-               *    3. Disengage magnetic field, wait for delay
-               *    4. Move near new extruder
-               *    5. Engage magnetic field for new extruder
-               *    6. Move to parking incl. offset of new extruder
-               *    7. Lower Z-Axis
-               */
-
-              // STEP 1
-              #if ENABLED(DEBUG_LEVELING_FEATURE)
-                SERIAL_ECHOLNPGM("Starting Autopark");
-                if (DEBUGGING(LEVELING)) DEBUG_POS("current position:", current_position);
-              #endif
-              current_position[Z_AXIS] += z_raise;
-              #if ENABLED(DEBUG_LEVELING_FEATURE)
-                SERIAL_ECHOLNPGM("(1) Raise Z-Axis ");
-                if (DEBUGGING(LEVELING)) DEBUG_POS("Moving to Raised Z-Position", current_position);
-              #endif
-              planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
-              stepper.synchronize();
-
-              // STEP 2
-              current_position[X_AXIS] = parkingposx[active_extruder] + hotend_offset[X_AXIS][active_extruder];
-              #if ENABLED(DEBUG_LEVELING_FEATURE)
-                SERIAL_ECHOLNPAIR("(2) Park extruder ", active_extruder);
-                if (DEBUGGING(LEVELING)) DEBUG_POS("Moving ParkPos", current_position);
-              #endif
-              planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
-              stepper.synchronize();
-
-              // STEP 3
-              #if ENABLED(DEBUG_LEVELING_FEATURE)
-                SERIAL_ECHOLNPGM("(3) Disengage magnet ");
-              #endif
-              pe_deactivate_magnet(active_extruder);
-
-              // STEP 4
-              #if ENABLED(DEBUG_LEVELING_FEATURE)
-                SERIAL_ECHOLNPGM("(4) Move to position near new extruder");
-              #endif
-              current_position[X_AXIS] += (active_extruder == 0 ? 10 : -10); // move 10mm away from parked extruder
-
-              #if ENABLED(DEBUG_LEVELING_FEATURE)
-                if (DEBUGGING(LEVELING)) DEBUG_POS("Moving away from parked extruder", current_position);
-              #endif
-              planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
-              stepper.synchronize();
-
-              // STEP 5
-              #if ENABLED(DEBUG_LEVELING_FEATURE)
-                SERIAL_ECHOLNPGM("(5) Engage magnetic field");
-              #endif
-
-              #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
-                pe_activate_magnet(active_extruder); //just save power for inverted magnets
-              #endif
-              pe_activate_magnet(tmp_extruder);
-
-              // STEP 6
-              current_position[X_AXIS] = grabpos + (tmp_extruder == 0 ? (+10) : (-10));
-              planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
-              current_position[X_AXIS] = grabpos;
-              #if ENABLED(DEBUG_LEVELING_FEATURE)
-                SERIAL_ECHOLNPAIR("(6) Unpark extruder ", tmp_extruder);
-                if (DEBUGGING(LEVELING)) DEBUG_POS("Move UnparkPos", current_position);
-              #endif
-              planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS]/2, active_extruder);
-              stepper.synchronize();
-
-              // Step 7
-              current_position[X_AXIS] = midpos - hotend_offset[X_AXIS][tmp_extruder];
-              #if ENABLED(DEBUG_LEVELING_FEATURE)
-                SERIAL_ECHOLNPGM("(7) Move midway between hotends");
-                if (DEBUGGING(LEVELING)) DEBUG_POS("Move midway to new extruder", current_position);
-              #endif
-              planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
-              stepper.synchronize();
-              #if ENABLED(DEBUG_LEVELING_FEATURE)
-                SERIAL_ECHOLNPGM("Autopark done.");
-              #endif
-            }
-            else { // nomove == true
-              // Only engage magnetic field for new extruder
-              pe_activate_magnet(tmp_extruder);
-              #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
-                pe_activate_magnet(active_extruder); // Just save power for inverted magnets
-              #endif
-            }
-            current_position[Z_AXIS] -= hotend_offset[Z_AXIS][tmp_extruder] - hotend_offset[Z_AXIS][active_extruder]; // Apply Zoffset
-
-            #if ENABLED(DEBUG_LEVELING_FEATURE)
-              if (DEBUGGING(LEVELING)) DEBUG_POS("Applying Z-offset", current_position);
-            #endif
-
-          #endif // dualParking extruder
+          #if ENABLED(PARKING_EXTRUDER)
+            parking_extruder_tool_change(tmp_extruder, no_move);
+          #endif
 
           #if ENABLED(SWITCHING_NOZZLE)
             #define DONT_SWITCH (SWITCHING_EXTRUDER_SERVO_NR == SWITCHING_NOZZLE_SERVO_NR)
             // <0 if the new nozzle is higher, >0 if lower. A bigger raise when lower.
             const float z_diff = hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder],
                         z_raise = 0.3 + (z_diff > 0.0 ? z_diff : 0.0);
 
             // Always raise by some amount
             current_position[Z_AXIS] += z_raise;
             planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);

commit b6a55f08913ed51ffa196892d7325655afacd671
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Mar 29 17:11:05 2018 -0500

    Temporary workaround for tool-change compile error
    
    Pending a more complete solution to tool-change Z deviation.

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index a498c6a1c8..7b3bf480bd 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -439,39 +439,39 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
             const float xydiff[2] = { offset_vec.x, offset_vec.y };
             current_position[Z_AXIS] += offset_vec.z;
 
           #else // !ABL_PLANAR
 
             const float xydiff[2] = {
               hotend_offset[X_AXIS][tmp_extruder] - hotend_offset[X_AXIS][active_extruder],
               hotend_offset[Y_AXIS][tmp_extruder] - hotend_offset[Y_AXIS][active_extruder]
             };
 
-            #if HAS_MESH
+            #if HAS_MESH && PLANNER_LEVELING
 
               if (planner.leveling_active) {
                 #if ENABLED(DEBUG_LEVELING_FEATURE)
                   if (DEBUGGING(LEVELING)) SERIAL_ECHOPAIR("Z before: ", current_position[Z_AXIS]);
                 #endif
                 float x2 = current_position[X_AXIS] + xydiff[X_AXIS],
                       y2 = current_position[Y_AXIS] + xydiff[Y_AXIS],
                       z1 = current_position[Z_AXIS], z2 = z1;
                 planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], z1);
                 planner.apply_leveling(x2, y2, z2);
                 current_position[Z_AXIS] += z2 - z1;
                 #if ENABLED(DEBUG_LEVELING_FEATURE)
                   if (DEBUGGING(LEVELING))
                     SERIAL_ECHOLNPAIR(" after: ", current_position[Z_AXIS]);
                 #endif
               }
 
-            #endif // HAS_MESH
+            #endif // HAS_MESH && PLANNER_LEVELING
 
           #endif // !HAS_ABL
 
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) {
               SERIAL_ECHOPAIR("Offset Tool XY by { ", xydiff[X_AXIS]);
               SERIAL_ECHOPAIR(", ", xydiff[Y_AXIS]);
               SERIAL_ECHOLNPGM(" }");
             }
           #endif

commit bb7236a7502b6a5d5ad17f1b0de792821663652b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 23 13:12:00 2018 -0500

    Z correction on tool-change for all HAS_MESH (#10199)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 0c8727e31d..a498c6a1c8 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -439,39 +439,39 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
             const float xydiff[2] = { offset_vec.x, offset_vec.y };
             current_position[Z_AXIS] += offset_vec.z;
 
           #else // !ABL_PLANAR
 
             const float xydiff[2] = {
               hotend_offset[X_AXIS][tmp_extruder] - hotend_offset[X_AXIS][active_extruder],
               hotend_offset[Y_AXIS][tmp_extruder] - hotend_offset[Y_AXIS][active_extruder]
             };
 
-            #if ENABLED(MESH_BED_LEVELING)
+            #if HAS_MESH
 
               if (planner.leveling_active) {
                 #if ENABLED(DEBUG_LEVELING_FEATURE)
-                  if (DEBUGGING(LEVELING)) SERIAL_ECHOPAIR("Z before MBL: ", current_position[Z_AXIS]);
+                  if (DEBUGGING(LEVELING)) SERIAL_ECHOPAIR("Z before: ", current_position[Z_AXIS]);
                 #endif
                 float x2 = current_position[X_AXIS] + xydiff[X_AXIS],
                       y2 = current_position[Y_AXIS] + xydiff[Y_AXIS],
                       z1 = current_position[Z_AXIS], z2 = z1;
                 planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], z1);
                 planner.apply_leveling(x2, y2, z2);
                 current_position[Z_AXIS] += z2 - z1;
                 #if ENABLED(DEBUG_LEVELING_FEATURE)
                   if (DEBUGGING(LEVELING))
                     SERIAL_ECHOLNPAIR(" after: ", current_position[Z_AXIS]);
                 #endif
               }
 
-            #endif // MESH_BED_LEVELING
+            #endif // HAS_MESH
 
           #endif // !HAS_ABL
 
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) {
               SERIAL_ECHOPAIR("Offset Tool XY by { ", xydiff[X_AXIS]);
               SERIAL_ECHOPAIR(", ", xydiff[Y_AXIS]);
               SERIAL_ECHOLNPGM(" }");
             }
           #endif

commit c6ff39cc14fd2dbc656e41736712a37f755499ec
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Mar 17 16:49:08 2018 -0500

    Spacing cleanup

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 93a16442b2..0c8727e31d 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -496,21 +496,21 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
           //LOOP_XYZ(i) update_software_endstops(i); // or modify the constrain function
           // Do a small lift to avoid the workpiece in the move back (below)
           const bool safe_to_move = current_position[Z_AXIS] < delta_clip_start_height - 1;
           if (safe_to_move && !no_move && IsRunning()) {
             ++current_position[Z_AXIS];
             planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
           }
         #else
           constexpr bool safe_to_move = true;
         #endif
- 
+
         // Move to the "old position" (move the extruder into place)
         #if ENABLED(SWITCHING_NOZZLE)
           destination[Z_AXIS] += z_diff;  // Include the Z restore with the "move back"
         #endif
 
         if (safe_to_move && !no_move && IsRunning()) {
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) DEBUG_POS("Move back", destination);
           #endif
           // Move back to the original (or tweaked) position

commit a6feb58837fa97167f5340abaa7b1175ca858450
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 16 00:46:42 2018 -0500

    Delta support for multiple hotends with offsets (#10118)

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 83cff7a641..93a16442b2 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -375,21 +375,21 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
             #endif
 
           #endif // dualParking extruder
 
           #if ENABLED(SWITCHING_NOZZLE)
             #define DONT_SWITCH (SWITCHING_EXTRUDER_SERVO_NR == SWITCHING_NOZZLE_SERVO_NR)
             // <0 if the new nozzle is higher, >0 if lower. A bigger raise when lower.
             const float z_diff = hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder],
                         z_raise = 0.3 + (z_diff > 0.0 ? z_diff : 0.0);
 
-            // Always raise by some amount (destination copied from current_position earlier)
+            // Always raise by some amount
             current_position[Z_AXIS] += z_raise;
             planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
             move_nozzle_servo(tmp_extruder);
           #endif
 
           /**
            * Set current_position to the position of the new nozzle.
            * Offsets are based on linear distance, so we need to get
            * the resulting position in coordinate space.
            *
@@ -485,25 +485,38 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
 
         #endif // !DUAL_X_CARRIAGE
 
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING)) DEBUG_POS("Sync After Toolchange", current_position);
         #endif
 
         // Tell the planner the new "current position"
         SYNC_PLAN_POSITION_KINEMATIC();
 
+        #if ENABLED(DELTA)
+          //LOOP_XYZ(i) update_software_endstops(i); // or modify the constrain function
+          // Do a small lift to avoid the workpiece in the move back (below)
+          const bool safe_to_move = current_position[Z_AXIS] < delta_clip_start_height - 1;
+          if (safe_to_move && !no_move && IsRunning()) {
+            ++current_position[Z_AXIS];
+            planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
+          }
+        #else
+          constexpr bool safe_to_move = true;
+        #endif
+ 
         // Move to the "old position" (move the extruder into place)
         #if ENABLED(SWITCHING_NOZZLE)
           destination[Z_AXIS] += z_diff;  // Include the Z restore with the "move back"
         #endif
-        if (!no_move && IsRunning()) {
+
+        if (safe_to_move && !no_move && IsRunning()) {
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) DEBUG_POS("Move back", destination);
           #endif
           // Move back to the original (or tweaked) position
           do_blocking_move_to(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS]);
         }
         #if ENABLED(SWITCHING_NOZZLE)
           else {
             // Move back down. (Including when the new tool is higher.)
             do_blocking_move_to_z(destination[Z_AXIS], planner.max_feedrate_mm_s[Z_AXIS]);

commit 2bea1bda569ac7aecc87c0f79a7ceaa7a073a0b4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jan 23 21:17:33 2018 -0600

    Move more strings to PROGMEM

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 0d1e00c2cb..83cff7a641 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -116,21 +116,21 @@
   }
 
 #endif // PARKING_EXTRUDER
 
 
 inline void invalid_extruder_error(const uint8_t e) {
   SERIAL_ECHO_START();
   SERIAL_CHAR('T');
   SERIAL_ECHO_F(e, DEC);
   SERIAL_CHAR(' ');
-  SERIAL_ECHOLN(MSG_INVALID_EXTRUDER);
+  SERIAL_ECHOLNPGM(MSG_INVALID_EXTRUDER);
 }
 
 /**
  * Perform a tool-change, which may result in moving the
  * previous tool out of the way and the new tool into place.
  */
 void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
   #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
 
     if (tmp_extruder >= MIXING_VIRTUAL_TOOLS)

commit fadf9eb2d72d0acaeca417729a9e789f31c4b6f5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Nov 27 14:00:35 2017 -0600

    Simplify midpos calculation

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 9646f972dc..0d1e00c2cb 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -267,21 +267,21 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
 
           // No extra case for HAS_ABL in DUAL_X_CARRIAGE. Does that mean they don't work together?
 
         #else // !DUAL_X_CARRIAGE
 
           #if ENABLED(PARKING_EXTRUDER) // Dual Parking extruder
             float z_raise = PARKING_EXTRUDER_SECURITY_RAISE;
             if (!no_move) {
 
               const float parkingposx[] = PARKING_EXTRUDER_PARKING_X,
-                          midpos = ((parkingposx[1] - parkingposx[0])/2) + parkingposx[0] + hotend_offset[X_AXIS][active_extruder],
+                          midpos = (parkingposx[0] + parkingposx[1]) * 0.5 + hotend_offset[X_AXIS][active_extruder],
                           grabpos = parkingposx[tmp_extruder] + hotend_offset[X_AXIS][active_extruder]
                                     + (tmp_extruder == 0 ? -(PARKING_EXTRUDER_GRAB_DISTANCE) : PARKING_EXTRUDER_GRAB_DISTANCE);
               /**
                *  Steps:
                *    1. Raise Z-Axis to give enough clearance
                *    2. Move to park position of old extruder
                *    3. Disengage magnetic field, wait for delay
                *    4. Move near new extruder
                *    5. Engage magnetic field for new extruder
                *    6. Move to parking incl. offset of new extruder

commit 118ac61e596b18a8751ff1388a69be4adcc7e4a8
Author: GMagician <GMagician@users.noreply.github.com>
Date:   Wed Nov 22 23:44:25 2017 +0100

    [2.0.x] Tool change bad behaviour fix
    
    Previous fix did not work as expected when axeis not homed. It raise Z but never return to original position

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 706ff433ab..9646f972dc 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -486,38 +486,34 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
         #endif // !DUAL_X_CARRIAGE
 
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING)) DEBUG_POS("Sync After Toolchange", current_position);
         #endif
 
         // Tell the planner the new "current position"
         SYNC_PLAN_POSITION_KINEMATIC();
 
         // Move to the "old position" (move the extruder into place)
+        #if ENABLED(SWITCHING_NOZZLE)
+          destination[Z_AXIS] += z_diff;  // Include the Z restore with the "move back"
+        #endif
         if (!no_move && IsRunning()) {
-          #if ENABLED(SWITCHING_NOZZLE)
-            if (z_raise != z_diff)
-              destination[Z_AXIS] += z_diff;  // Include the Z restore with the "move back"
-          #endif
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) DEBUG_POS("Move back", destination);
           #endif
           // Move back to the original (or tweaked) position
           do_blocking_move_to(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS]);
         }
         #if ENABLED(SWITCHING_NOZZLE)
-          // Move back down, if needed. (Including when the new tool is higher.)
-          else if (z_raise != z_diff) {
-            set_destination_from_current(); // Prevent any XY move
-            destination[Z_AXIS] += z_diff;
-            feedrate_mm_s = planner.max_feedrate_mm_s[Z_AXIS];
-            prepare_move_to_destination();
+          else {
+            // Move back down. (Including when the new tool is higher.)
+            do_blocking_move_to_z(destination[Z_AXIS], planner.max_feedrate_mm_s[Z_AXIS]);
           }
         #endif
       } // (tmp_extruder != active_extruder)
 
       stepper.synchronize();
 
       #if ENABLED(EXT_SOLENOID) && !ENABLED(PARKING_EXTRUDER)
         disable_all_solenoids();
         enable_solenoid_on_active_extruder();
       #endif // EXT_SOLENOID

commit a61127a421ab30eb917fdec19f62ce501749148f
Author: GMagician <GMagician@users.noreply.github.com>
Date:   Sun Nov 19 12:26:25 2017 +0100

    [2.0.x] tool change bad behaviours
    
    This will solve 2 issues on tool change.
    1) when no home is done ("no_move" is set) tool change should never move X & Y because... I don't know where I am...only Z should be adjusted to avoid bed collision if other nozzle is lower than current.
    Since no move no bed level matrix should be applied
    2) When SWITCHING_NOZZLE is enabled and system is homed there are two movements to go to destination, but first can move Z to older position and then crash on the bed

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index cb74c59137..706ff433ab 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -487,35 +487,39 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
 
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING)) DEBUG_POS("Sync After Toolchange", current_position);
         #endif
 
         // Tell the planner the new "current position"
         SYNC_PLAN_POSITION_KINEMATIC();
 
         // Move to the "old position" (move the extruder into place)
         if (!no_move && IsRunning()) {
+          #if ENABLED(SWITCHING_NOZZLE)
+            if (z_raise != z_diff)
+              destination[Z_AXIS] += z_diff;  // Include the Z restore with the "move back"
+          #endif
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) DEBUG_POS("Move back", destination);
           #endif
-          prepare_move_to_destination();
+          // Move back to the original (or tweaked) position
+          do_blocking_move_to(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS]);
         }
-
         #if ENABLED(SWITCHING_NOZZLE)
           // Move back down, if needed. (Including when the new tool is higher.)
-          if (z_raise != z_diff) {
+          else if (z_raise != z_diff) {
+            set_destination_from_current(); // Prevent any XY move
             destination[Z_AXIS] += z_diff;
             feedrate_mm_s = planner.max_feedrate_mm_s[Z_AXIS];
             prepare_move_to_destination();
           }
         #endif
-
       } // (tmp_extruder != active_extruder)
 
       stepper.synchronize();
 
       #if ENABLED(EXT_SOLENOID) && !ENABLED(PARKING_EXTRUDER)
         disable_all_solenoids();
         enable_solenoid_on_active_extruder();
       #endif // EXT_SOLENOID
 
       feedrate_mm_s = old_feedrate_mm_s;

commit c0000a0cdc68dc2c9b49e5fcb1a04275fadd49dd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Nov 19 13:39:46 2017 -0600

    Move servo code to modules/servo.*

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 10210653e7..cb74c59137 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -27,20 +27,24 @@
 #include "stepper.h"
 
 #include "../Marlin.h"
 
 #include "../inc/MarlinConfig.h"
 
 #if ENABLED(PARKING_EXTRUDER) && PARKING_EXTRUDER_SOLENOIDS_DELAY > 0
   #include "../gcode/gcode.h" // for dwell()
 #endif
 
+#if ENABLED(SWITCHING_EXTRUDER) || ENABLED(SWITCHING_NOZZLE)
+  #include "../module/servo.h"
+#endif
+
 #if ENABLED(EXT_SOLENOID) && !ENABLED(PARKING_EXTRUDER)
   #include "../feature/solenoid.h"
 #endif
 
 #if ENABLED(MK2_MULTIPLEXER)
   #include "../feature/snmm.h"
 #endif
 
 #if ENABLED(MIXING_EXTRUDER)
   #include "../feature/mixing.h"

commit 06ee6584fdf0d6639e917a4e1c2b456892bff8f4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Nov 11 21:25:24 2017 -0600

    Remove offsets from soft endstops, tool change

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 0bcedc80cb..10210653e7 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -468,28 +468,20 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
             if (DEBUGGING(LEVELING)) {
               SERIAL_ECHOPAIR("Offset Tool XY by { ", xydiff[X_AXIS]);
               SERIAL_ECHOPAIR(", ", xydiff[Y_AXIS]);
               SERIAL_ECHOLNPGM(" }");
             }
           #endif
 
           // The newly-selected extruder XY is actually at...
           current_position[X_AXIS] += xydiff[X_AXIS];
           current_position[Y_AXIS] += xydiff[Y_AXIS];
-          #if HAS_WORKSPACE_OFFSET || ENABLED(DUAL_X_CARRIAGE) || ENABLED(PARKING_EXTRUDER)
-            for (uint8_t i = X_AXIS; i <= Y_AXIS; i++) {
-              #if HAS_POSITION_SHIFT
-                position_shift[i] += xydiff[i];
-              #endif
-              update_software_endstops((AxisEnum)i);
-            }
-          #endif
 
           // Set the new active extruder
           active_extruder = tmp_extruder;
 
         #endif // !DUAL_X_CARRIAGE
 
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING)) DEBUG_POS("Sync After Toolchange", current_position);
         #endif
 

commit 79772219aeb0531cccfa7eb73cea246ceb6dbb6f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Nov 4 21:01:41 2017 -0500

    Fix Fan Multiplexer init

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 8d12a82b90..0bcedc80cb 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -43,20 +43,24 @@
 #endif
 
 #if ENABLED(MIXING_EXTRUDER)
   #include "../feature/mixing.h"
 #endif
 
 #if HAS_LEVELING
   #include "../feature/bedlevel/bedlevel.h"
 #endif
 
+#if HAS_FANMUX
+  #include "../feature/fanmux.h"
+#endif
+
 #if ENABLED(SWITCHING_EXTRUDER)
 
   #if EXTRUDERS > 3
     #define REQ_ANGLES 4
     #define _SERVO_NR (e < 2 ? SWITCHING_EXTRUDER_SERVO_NR : SWITCHING_EXTRUDER_E23_SERVO_NR)
   #else
     #define REQ_ANGLES 2
     #define _SERVO_NR SWITCHING_EXTRUDER_SERVO_NR
   #endif
 
@@ -102,44 +106,20 @@
       case 1: OUT_WRITE(SOL1_PIN, state); break;
       default: OUT_WRITE(SOL0_PIN, state); break;
     }
     #if PARKING_EXTRUDER_SOLENOIDS_DELAY > 0
       gcode.dwell(PARKING_EXTRUDER_SOLENOIDS_DELAY);
     #endif
   }
 
 #endif // PARKING_EXTRUDER
 
-#if HAS_FANMUX
-
-  void fanmux_switch(const uint8_t e) {
-    WRITE(FANMUX0_PIN, TEST(e, 0) ? HIGH : LOW);
-    #if PIN_EXISTS(FANMUX1)
-      WRITE(FANMUX1_PIN, TEST(e, 1) ? HIGH : LOW);
-      #if PIN_EXISTS(FANMUX2)
-        WRITE(FANMUX2, TEST(e, 2) ? HIGH : LOW);
-      #endif
-    #endif
-  }
-
-  FORCE_INLINE void fanmux_init(void){
-    SET_OUTPUT(FANMUX0_PIN);
-    #if PIN_EXISTS(FANMUX1)
-      SET_OUTPUT(FANMUX1_PIN);
-      #if PIN_EXISTS(FANMUX2)
-        SET_OUTPUT(FANMUX2_PIN);
-      #endif
-    #endif
-    fanmux_switch(0);
-  }
-
-#endif // HAS_FANMUX
 
 inline void invalid_extruder_error(const uint8_t e) {
   SERIAL_ECHO_START();
   SERIAL_CHAR('T');
   SERIAL_ECHO_F(e, DEC);
   SERIAL_CHAR(' ');
   SERIAL_ECHOLN(MSG_INVALID_EXTRUDER);
 }
 
 /**

commit f8393a09086f01eafbb8563411da3b237c96b982
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 2 23:59:42 2017 -0500

    Operate in Native Machine Space

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 6c9d72a623..8d12a82b90 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -233,44 +233,44 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) DEBUG_POS("New Extruder", current_position);
           #endif
 
           // Only when auto-parking are carriages safe to move
           if (dual_x_carriage_mode != DXC_AUTO_PARK_MODE) no_move = true;
 
           switch (dual_x_carriage_mode) {
             case DXC_FULL_CONTROL_MODE:
               // New current position is the position of the activated extruder
-              current_position[X_AXIS] = LOGICAL_X_POSITION(inactive_extruder_x_pos);
+              current_position[X_AXIS] = inactive_extruder_x_pos;
               // Save the inactive extruder's position (from the old current_position)
-              inactive_extruder_x_pos = RAW_X_POSITION(destination[X_AXIS]);
+              inactive_extruder_x_pos = destination[X_AXIS];
               break;
             case DXC_AUTO_PARK_MODE:
               // record raised toolhead position for use by unpark
               COPY(raised_parked_position, current_position);
               raised_parked_position[Z_AXIS] += TOOLCHANGE_UNPARK_ZLIFT;
               #if ENABLED(MAX_SOFTWARE_ENDSTOPS)
                 NOMORE(raised_parked_position[Z_AXIS], soft_endstop_max[Z_AXIS]);
               #endif
               active_extruder_parked = true;
               delayed_move_time = 0;
               break;
             case DXC_DUPLICATION_MODE:
               // If the new extruder is the left one, set it "parked"
               // This triggers the second extruder to move into the duplication position
               active_extruder_parked = (active_extruder == 0);
 
               if (active_extruder_parked)
-                current_position[X_AXIS] = LOGICAL_X_POSITION(inactive_extruder_x_pos);
+                current_position[X_AXIS] = inactive_extruder_x_pos;
               else
                 current_position[X_AXIS] = destination[X_AXIS] + duplicate_extruder_x_offset;
-              inactive_extruder_x_pos = RAW_X_POSITION(destination[X_AXIS]);
+              inactive_extruder_x_pos = destination[X_AXIS];
               extruder_duplication_enabled = false;
               #if ENABLED(DEBUG_LEVELING_FEATURE)
                 if (DEBUGGING(LEVELING)) {
                   SERIAL_ECHOLNPAIR("Set inactive_extruder_x_pos=", inactive_extruder_x_pos);
                   SERIAL_ECHOLNPGM("Clear extruder_duplication_enabled");
                 }
               #endif
               break;
           }
 

commit 72156a2029d329c7dc251f5e576103fda691372d
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Sat Oct 21 11:42:26 2017 -0500

    change to better (more clear) names (#8050)
    
    set_destination_to_current() changed to set_destination_from_current()
    
    set_current_to_destination() changed to set_current_from_destination()

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 75fba3d94b..6c9d72a623 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -169,21 +169,21 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
 
       if (tmp_extruder != active_extruder) {
         if (!no_move && axis_unhomed_error()) {
           no_move = true;
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("No move on toolchange");
           #endif
         }
 
         // Save current position to destination, for use later
-        set_destination_to_current();
+        set_destination_from_current();
 
         #if ENABLED(DUAL_X_CARRIAGE)
 
           #if ENABLED(DEBUG_LEVELING_FEATURE)
             if (DEBUGGING(LEVELING)) {
               SERIAL_ECHOPGM("Dual X Carriage Mode ");
               switch (dual_x_carriage_mode) {
                 case DXC_FULL_CONTROL_MODE: SERIAL_ECHOLNPGM("DXC_FULL_CONTROL_MODE"); break;
                 case DXC_AUTO_PARK_MODE: SERIAL_ECHOLNPGM("DXC_AUTO_PARK_MODE"); break;
                 case DXC_DUPLICATION_MODE: SERIAL_ECHOLNPGM("DXC_DUPLICATION_MODE"); break;

commit c0dddd4233d12b52a71e93d50b7ab648f86ff9a5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Oct 14 02:46:05 2017 -0500

    Tweaks to tool_change, GcodeSuite::T()

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index aef82c0299..75fba3d94b 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -288,27 +288,27 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
           #if ENABLED(PARKING_EXTRUDER) // Dual Parking extruder
             float z_raise = PARKING_EXTRUDER_SECURITY_RAISE;
             if (!no_move) {
 
               const float parkingposx[] = PARKING_EXTRUDER_PARKING_X,
                           midpos = ((parkingposx[1] - parkingposx[0])/2) + parkingposx[0] + hotend_offset[X_AXIS][active_extruder],
                           grabpos = parkingposx[tmp_extruder] + hotend_offset[X_AXIS][active_extruder]
                                     + (tmp_extruder == 0 ? -(PARKING_EXTRUDER_GRAB_DISTANCE) : PARKING_EXTRUDER_GRAB_DISTANCE);
               /**
                *  Steps:
-               *    1. raise Z-Axis to have enough clearance
-               *    2. move to park poition of old extruder
-               *    3. disengage magnetc field, wait for delay
-               *    4. move near new extruder
-               *    5. engage magnetic field for new extruder
-               *    6. move to parking incl. offset of new extruder
-               *    7. lower Z-Axis
+               *    1. Raise Z-Axis to give enough clearance
+               *    2. Move to park position of old extruder
+               *    3. Disengage magnetic field, wait for delay
+               *    4. Move near new extruder
+               *    5. Engage magnetic field for new extruder
+               *    6. Move to parking incl. offset of new extruder
+               *    7. Lower Z-Axis
                */
 
               // STEP 1
               #if ENABLED(DEBUG_LEVELING_FEATURE)
                 SERIAL_ECHOLNPGM("Starting Autopark");
                 if (DEBUGGING(LEVELING)) DEBUG_POS("current position:", current_position);
               #endif
               current_position[Z_AXIS] += z_raise;
               #if ENABLED(DEBUG_LEVELING_FEATURE)
                 SERIAL_ECHOLNPGM("(1) Raise Z-Axis ");

commit 3e3911fb81cef6f17f7e77c54f520e2a4579225b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 13 17:21:25 2017 -0500

    Use planner.leveling_active for all leveling systems

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 8594fa9c49..aef82c0299 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -457,21 +457,21 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
 
           #else // !ABL_PLANAR
 
             const float xydiff[2] = {
               hotend_offset[X_AXIS][tmp_extruder] - hotend_offset[X_AXIS][active_extruder],
               hotend_offset[Y_AXIS][tmp_extruder] - hotend_offset[Y_AXIS][active_extruder]
             };
 
             #if ENABLED(MESH_BED_LEVELING)
 
-              if (LEVELING_IS_ACTIVE()) {
+              if (planner.leveling_active) {
                 #if ENABLED(DEBUG_LEVELING_FEATURE)
                   if (DEBUGGING(LEVELING)) SERIAL_ECHOPAIR("Z before MBL: ", current_position[Z_AXIS]);
                 #endif
                 float x2 = current_position[X_AXIS] + xydiff[X_AXIS],
                       y2 = current_position[Y_AXIS] + xydiff[Y_AXIS],
                       z1 = current_position[Z_AXIS], z2 = z1;
                 planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], z1);
                 planner.apply_leveling(x2, y2, z2);
                 current_position[Z_AXIS] += z2 - z1;
                 #if ENABLED(DEBUG_LEVELING_FEATURE)

commit 9a930ebec27008d2e47161d050e7d1f9dd534b66
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 13 10:25:05 2017 -0500

    Make leveling_is_active a macro

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 758044292c..8594fa9c49 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -457,21 +457,21 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
 
           #else // !ABL_PLANAR
 
             const float xydiff[2] = {
               hotend_offset[X_AXIS][tmp_extruder] - hotend_offset[X_AXIS][active_extruder],
               hotend_offset[Y_AXIS][tmp_extruder] - hotend_offset[Y_AXIS][active_extruder]
             };
 
             #if ENABLED(MESH_BED_LEVELING)
 
-              if (leveling_is_active()) {
+              if (LEVELING_IS_ACTIVE()) {
                 #if ENABLED(DEBUG_LEVELING_FEATURE)
                   if (DEBUGGING(LEVELING)) SERIAL_ECHOPAIR("Z before MBL: ", current_position[Z_AXIS]);
                 #endif
                 float x2 = current_position[X_AXIS] + xydiff[X_AXIS],
                       y2 = current_position[Y_AXIS] + xydiff[Y_AXIS],
                       z1 = current_position[Z_AXIS], z2 = z1;
                 planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], z1);
                 planner.apply_leveling(x2, y2, z2);
                 current_position[Z_AXIS] += z2 - z1;
                 #if ENABLED(DEBUG_LEVELING_FEATURE)

commit 0cb00f52d94773411e405ae10a463a4687b70658
Author: Thomas Moore <tcm0116@gmail.com>
Date:   Sat Sep 30 16:06:43 2017 -0500

    Cleanup warnings

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index e5ea339721..758044292c 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -279,22 +279,21 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
               SERIAL_ECHOLNPAIR("Active extruder parked: ", active_extruder_parked ? "yes" : "no");
               DEBUG_POS("New extruder (parked)", current_position);
             }
           #endif
 
           // No extra case for HAS_ABL in DUAL_X_CARRIAGE. Does that mean they don't work together?
 
         #else // !DUAL_X_CARRIAGE
 
           #if ENABLED(PARKING_EXTRUDER) // Dual Parking extruder
-            const float z_diff = hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
-            float z_raise = 0;
+            float z_raise = PARKING_EXTRUDER_SECURITY_RAISE;
             if (!no_move) {
 
               const float parkingposx[] = PARKING_EXTRUDER_PARKING_X,
                           midpos = ((parkingposx[1] - parkingposx[0])/2) + parkingposx[0] + hotend_offset[X_AXIS][active_extruder],
                           grabpos = parkingposx[tmp_extruder] + hotend_offset[X_AXIS][active_extruder]
                                     + (tmp_extruder == 0 ? -(PARKING_EXTRUDER_GRAB_DISTANCE) : PARKING_EXTRUDER_GRAB_DISTANCE);
               /**
                *  Steps:
                *    1. raise Z-Axis to have enough clearance
                *    2. move to park poition of old extruder
@@ -303,21 +302,20 @@ void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool n
                *    5. engage magnetic field for new extruder
                *    6. move to parking incl. offset of new extruder
                *    7. lower Z-Axis
                */
 
               // STEP 1
               #if ENABLED(DEBUG_LEVELING_FEATURE)
                 SERIAL_ECHOLNPGM("Starting Autopark");
                 if (DEBUGGING(LEVELING)) DEBUG_POS("current position:", current_position);
               #endif
-              z_raise = PARKING_EXTRUDER_SECURITY_RAISE;
               current_position[Z_AXIS] += z_raise;
               #if ENABLED(DEBUG_LEVELING_FEATURE)
                 SERIAL_ECHOLNPGM("(1) Raise Z-Axis ");
                 if (DEBUGGING(LEVELING)) DEBUG_POS("Moving to Raised Z-Position", current_position);
               #endif
               planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
               stepper.synchronize();
 
               // STEP 2
               current_position[X_AXIS] = parkingposx[active_extruder] + hotend_offset[X_AXIS][active_extruder];

commit c508e9adecb81f56238dde94e77dc61883b42ffd
Author: GMagician <GMagician@users.noreply.github.com>
Date:   Mon Sep 25 23:18:26 2017 +0200

    Fix compiler error
    
    Added missing include file,
    called 'leveling_is_active()' with no prototipe defined.

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 7363e68f51..e5ea339721 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -39,20 +39,24 @@
 #endif
 
 #if ENABLED(MK2_MULTIPLEXER)
   #include "../feature/snmm.h"
 #endif
 
 #if ENABLED(MIXING_EXTRUDER)
   #include "../feature/mixing.h"
 #endif
 
+#if HAS_LEVELING
+  #include "../feature/bedlevel/bedlevel.h"
+#endif
+
 #if ENABLED(SWITCHING_EXTRUDER)
 
   #if EXTRUDERS > 3
     #define REQ_ANGLES 4
     #define _SERVO_NR (e < 2 ? SWITCHING_EXTRUDER_SERVO_NR : SWITCHING_EXTRUDER_E23_SERVO_NR)
   #else
     #define REQ_ANGLES 2
     #define _SERVO_NR SWITCHING_EXTRUDER_SERVO_NR
   #endif
 

commit 07cf75883f125d569cb2013594a7519074eb34e4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 18 01:05:44 2017 -0500

    Move T (tool change) to cpp

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 68b8d82eaa..7363e68f51 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -77,20 +77,29 @@
     const int16_t angles[2] = SWITCHING_NOZZLE_SERVO_ANGLES;
     stepper.synchronize();
     MOVE_SERVO(SWITCHING_NOZZLE_SERVO_NR, angles[e]);
     safe_delay(500);
   }
 
 #endif // SWITCHING_NOZZLE
 
 #if ENABLED(PARKING_EXTRUDER)
 
+  void pe_magnet_init() {
+    for (uint8_t n = 0; n <= 1; ++n)
+      #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
+        pe_activate_magnet(n);
+      #else
+        pe_deactivate_magnet(n);
+      #endif
+  }
+
   void pe_set_magnet(const uint8_t extruder_num, const uint8_t state) {
     switch (extruder_num) {
       case 1: OUT_WRITE(SOL1_PIN, state); break;
       default: OUT_WRITE(SOL0_PIN, state); break;
     }
     #if PARKING_EXTRUDER_SOLENOIDS_DELAY > 0
       gcode.dwell(PARKING_EXTRUDER_SOLENOIDS_DELAY);
     #endif
   }
 

commit 1a37ebc76dfc2a1e27fcd71590fcea7bc49d980a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 18 00:06:16 2017 -0500

    Move M163-M165 MIXING_EXTRUDER to cpp

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index b8fab7cc80..68b8d82eaa 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -35,20 +35,24 @@
 #endif
 
 #if ENABLED(EXT_SOLENOID) && !ENABLED(PARKING_EXTRUDER)
   #include "../feature/solenoid.h"
 #endif
 
 #if ENABLED(MK2_MULTIPLEXER)
   #include "../feature/snmm.h"
 #endif
 
+#if ENABLED(MIXING_EXTRUDER)
+  #include "../feature/mixing.h"
+#endif
+
 #if ENABLED(SWITCHING_EXTRUDER)
 
   #if EXTRUDERS > 3
     #define REQ_ANGLES 4
     #define _SERVO_NR (e < 2 ? SWITCHING_EXTRUDER_SERVO_NR : SWITCHING_EXTRUDER_E23_SERVO_NR)
   #else
     #define REQ_ANGLES 2
     #define _SERVO_NR SWITCHING_EXTRUDER_SERVO_NR
   #endif
 

commit 75cf17d8165beed9b0392f1edb6e0a8a67b5f874
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 17 16:58:16 2017 -0500

    Move M702 MK2_MULTIPLEXER to cpp

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index a52473cc92..b8fab7cc80 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -31,20 +31,24 @@
 #include "../inc/MarlinConfig.h"
 
 #if ENABLED(PARKING_EXTRUDER) && PARKING_EXTRUDER_SOLENOIDS_DELAY > 0
   #include "../gcode/gcode.h" // for dwell()
 #endif
 
 #if ENABLED(EXT_SOLENOID) && !ENABLED(PARKING_EXTRUDER)
   #include "../feature/solenoid.h"
 #endif
 
+#if ENABLED(MK2_MULTIPLEXER)
+  #include "../feature/snmm.h"
+#endif
+
 #if ENABLED(SWITCHING_EXTRUDER)
 
   #if EXTRUDERS > 3
     #define REQ_ANGLES 4
     #define _SERVO_NR (e < 2 ? SWITCHING_EXTRUDER_SERVO_NR : SWITCHING_EXTRUDER_E23_SERVO_NR)
   #else
     #define REQ_ANGLES 2
     #define _SERVO_NR SWITCHING_EXTRUDER_SERVO_NR
   #endif
 

commit 4a220a8b79ec9c355faa2a0ab640d91dad508217
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 17 03:43:45 2017 -0500

    Move M380_M381 to cpp, solenoid feature

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 665b2bb7f3..a52473cc92 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -27,20 +27,24 @@
 #include "stepper.h"
 
 #include "../Marlin.h"
 
 #include "../inc/MarlinConfig.h"
 
 #if ENABLED(PARKING_EXTRUDER) && PARKING_EXTRUDER_SOLENOIDS_DELAY > 0
   #include "../gcode/gcode.h" // for dwell()
 #endif
 
+#if ENABLED(EXT_SOLENOID) && !ENABLED(PARKING_EXTRUDER)
+  #include "../feature/solenoid.h"
+#endif
+
 #if ENABLED(SWITCHING_EXTRUDER)
 
   #if EXTRUDERS > 3
     #define REQ_ANGLES 4
     #define _SERVO_NR (e < 2 ? SWITCHING_EXTRUDER_SERVO_NR : SWITCHING_EXTRUDER_E23_SERVO_NR)
   #else
     #define REQ_ANGLES 2
     #define _SERVO_NR SWITCHING_EXTRUDER_SERVO_NR
   #endif
 

commit 51f195e698e2cbdbb8f1a97213f0c9553e8fc470
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Sep 15 20:44:40 2017 -0500

    Move dwell to gcode

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
index 17a986e10e..665b2bb7f3 100644
--- a/Marlin/src/module/tool_change.cpp
+++ b/Marlin/src/module/tool_change.cpp
@@ -23,20 +23,24 @@
 #include "tool_change.h"
 
 #include "motion.h"
 #include "planner.h"
 #include "stepper.h"
 
 #include "../Marlin.h"
 
 #include "../inc/MarlinConfig.h"
 
+#if ENABLED(PARKING_EXTRUDER) && PARKING_EXTRUDER_SOLENOIDS_DELAY > 0
+  #include "../gcode/gcode.h" // for dwell()
+#endif
+
 #if ENABLED(SWITCHING_EXTRUDER)
 
   #if EXTRUDERS > 3
     #define REQ_ANGLES 4
     #define _SERVO_NR (e < 2 ? SWITCHING_EXTRUDER_SERVO_NR : SWITCHING_EXTRUDER_E23_SERVO_NR)
   #else
     #define REQ_ANGLES 2
     #define _SERVO_NR SWITCHING_EXTRUDER_SERVO_NR
   #endif
 
@@ -67,21 +71,21 @@
 #endif // SWITCHING_NOZZLE
 
 #if ENABLED(PARKING_EXTRUDER)
 
   void pe_set_magnet(const uint8_t extruder_num, const uint8_t state) {
     switch (extruder_num) {
       case 1: OUT_WRITE(SOL1_PIN, state); break;
       default: OUT_WRITE(SOL0_PIN, state); break;
     }
     #if PARKING_EXTRUDER_SOLENOIDS_DELAY > 0
-      dwell(PARKING_EXTRUDER_SOLENOIDS_DELAY);
+      gcode.dwell(PARKING_EXTRUDER_SOLENOIDS_DELAY);
     #endif
   }
 
 #endif // PARKING_EXTRUDER
 
 #if HAS_FANMUX
 
   void fanmux_switch(const uint8_t e) {
     WRITE(FANMUX0_PIN, TEST(e, 0) ? HIGH : LOW);
     #if PIN_EXISTS(FANMUX1)

commit 4231faf7796ca8adb9ca861b014b65e79f67b376
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 6 06:28:31 2017 -0500

    Initial split-up of G-code handlers by category

diff --git a/Marlin/src/module/tool_change.cpp b/Marlin/src/module/tool_change.cpp
new file mode 100644
index 0000000000..17a986e10e
--- /dev/null
+++ b/Marlin/src/module/tool_change.cpp
@@ -0,0 +1,550 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "tool_change.h"
+
+#include "motion.h"
+#include "planner.h"
+#include "stepper.h"
+
+#include "../Marlin.h"
+
+#include "../inc/MarlinConfig.h"
+
+#if ENABLED(SWITCHING_EXTRUDER)
+
+  #if EXTRUDERS > 3
+    #define REQ_ANGLES 4
+    #define _SERVO_NR (e < 2 ? SWITCHING_EXTRUDER_SERVO_NR : SWITCHING_EXTRUDER_E23_SERVO_NR)
+  #else
+    #define REQ_ANGLES 2
+    #define _SERVO_NR SWITCHING_EXTRUDER_SERVO_NR
+  #endif
+
+  void move_extruder_servo(const uint8_t e) {
+    constexpr int16_t angles[] = SWITCHING_EXTRUDER_SERVO_ANGLES;
+    static_assert(COUNT(angles) == REQ_ANGLES, "SWITCHING_EXTRUDER_SERVO_ANGLES needs " STRINGIFY(REQ_ANGLES) " angles.");
+    stepper.synchronize();
+    #if EXTRUDERS & 1
+      if (e < EXTRUDERS - 1)
+    #endif
+    {
+      MOVE_SERVO(_SERVO_NR, angles[e]);
+      safe_delay(500);
+    }
+  }
+
+#endif // SWITCHING_EXTRUDER
+
+#if ENABLED(SWITCHING_NOZZLE)
+
+  void move_nozzle_servo(const uint8_t e) {
+    const int16_t angles[2] = SWITCHING_NOZZLE_SERVO_ANGLES;
+    stepper.synchronize();
+    MOVE_SERVO(SWITCHING_NOZZLE_SERVO_NR, angles[e]);
+    safe_delay(500);
+  }
+
+#endif // SWITCHING_NOZZLE
+
+#if ENABLED(PARKING_EXTRUDER)
+
+  void pe_set_magnet(const uint8_t extruder_num, const uint8_t state) {
+    switch (extruder_num) {
+      case 1: OUT_WRITE(SOL1_PIN, state); break;
+      default: OUT_WRITE(SOL0_PIN, state); break;
+    }
+    #if PARKING_EXTRUDER_SOLENOIDS_DELAY > 0
+      dwell(PARKING_EXTRUDER_SOLENOIDS_DELAY);
+    #endif
+  }
+
+#endif // PARKING_EXTRUDER
+
+#if HAS_FANMUX
+
+  void fanmux_switch(const uint8_t e) {
+    WRITE(FANMUX0_PIN, TEST(e, 0) ? HIGH : LOW);
+    #if PIN_EXISTS(FANMUX1)
+      WRITE(FANMUX1_PIN, TEST(e, 1) ? HIGH : LOW);
+      #if PIN_EXISTS(FANMUX2)
+        WRITE(FANMUX2, TEST(e, 2) ? HIGH : LOW);
+      #endif
+    #endif
+  }
+
+  FORCE_INLINE void fanmux_init(void){
+    SET_OUTPUT(FANMUX0_PIN);
+    #if PIN_EXISTS(FANMUX1)
+      SET_OUTPUT(FANMUX1_PIN);
+      #if PIN_EXISTS(FANMUX2)
+        SET_OUTPUT(FANMUX2_PIN);
+      #endif
+    #endif
+    fanmux_switch(0);
+  }
+
+#endif // HAS_FANMUX
+
+inline void invalid_extruder_error(const uint8_t e) {
+  SERIAL_ECHO_START();
+  SERIAL_CHAR('T');
+  SERIAL_ECHO_F(e, DEC);
+  SERIAL_CHAR(' ');
+  SERIAL_ECHOLN(MSG_INVALID_EXTRUDER);
+}
+
+/**
+ * Perform a tool-change, which may result in moving the
+ * previous tool out of the way and the new tool into place.
+ */
+void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
+  #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
+
+    if (tmp_extruder >= MIXING_VIRTUAL_TOOLS)
+      return invalid_extruder_error(tmp_extruder);
+
+    // T0-Tnnn: Switch virtual tool by changing the mix
+    for (uint8_t j = 0; j < MIXING_STEPPERS; j++)
+      mixing_factor[j] = mixing_virtual_tool_mix[tmp_extruder][j];
+
+  #else // !MIXING_EXTRUDER || MIXING_VIRTUAL_TOOLS <= 1
+
+    if (tmp_extruder >= EXTRUDERS)
+      return invalid_extruder_error(tmp_extruder);
+
+    #if HOTENDS > 1
+
+      const float old_feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : feedrate_mm_s;
+
+      feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
+
+      if (tmp_extruder != active_extruder) {
+        if (!no_move && axis_unhomed_error()) {
+          no_move = true;
+          #if ENABLED(DEBUG_LEVELING_FEATURE)
+            if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("No move on toolchange");
+          #endif
+        }
+
+        // Save current position to destination, for use later
+        set_destination_to_current();
+
+        #if ENABLED(DUAL_X_CARRIAGE)
+
+          #if ENABLED(DEBUG_LEVELING_FEATURE)
+            if (DEBUGGING(LEVELING)) {
+              SERIAL_ECHOPGM("Dual X Carriage Mode ");
+              switch (dual_x_carriage_mode) {
+                case DXC_FULL_CONTROL_MODE: SERIAL_ECHOLNPGM("DXC_FULL_CONTROL_MODE"); break;
+                case DXC_AUTO_PARK_MODE: SERIAL_ECHOLNPGM("DXC_AUTO_PARK_MODE"); break;
+                case DXC_DUPLICATION_MODE: SERIAL_ECHOLNPGM("DXC_DUPLICATION_MODE"); break;
+              }
+            }
+          #endif
+
+          const float xhome = x_home_pos(active_extruder);
+          if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE
+              && IsRunning()
+              && (delayed_move_time || current_position[X_AXIS] != xhome)
+          ) {
+            float raised_z = current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT;
+            #if ENABLED(MAX_SOFTWARE_ENDSTOPS)
+              NOMORE(raised_z, soft_endstop_max[Z_AXIS]);
+            #endif
+            #if ENABLED(DEBUG_LEVELING_FEATURE)
+              if (DEBUGGING(LEVELING)) {
+                SERIAL_ECHOLNPAIR("Raise to ", raised_z);
+                SERIAL_ECHOLNPAIR("MoveX to ", xhome);
+                SERIAL_ECHOLNPAIR("Lower to ", current_position[Z_AXIS]);
+              }
+            #endif
+            // Park old head: 1) raise 2) move to park position 3) lower
+            for (uint8_t i = 0; i < 3; i++)
+              planner.buffer_line(
+                i == 0 ? current_position[X_AXIS] : xhome,
+                current_position[Y_AXIS],
+                i == 2 ? current_position[Z_AXIS] : raised_z,
+                current_position[E_AXIS],
+                planner.max_feedrate_mm_s[i == 1 ? X_AXIS : Z_AXIS],
+                active_extruder
+              );
+            stepper.synchronize();
+          }
+
+          // Apply Y & Z extruder offset (X offset is used as home pos with Dual X)
+          current_position[Y_AXIS] -= hotend_offset[Y_AXIS][active_extruder] - hotend_offset[Y_AXIS][tmp_extruder];
+          current_position[Z_AXIS] -= hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
+
+          // Activate the new extruder ahead of calling set_axis_is_at_home!
+          active_extruder = tmp_extruder;
+
+          // This function resets the max/min values - the current position may be overwritten below.
+          set_axis_is_at_home(X_AXIS);
+
+          #if ENABLED(DEBUG_LEVELING_FEATURE)
+            if (DEBUGGING(LEVELING)) DEBUG_POS("New Extruder", current_position);
+          #endif
+
+          // Only when auto-parking are carriages safe to move
+          if (dual_x_carriage_mode != DXC_AUTO_PARK_MODE) no_move = true;
+
+          switch (dual_x_carriage_mode) {
+            case DXC_FULL_CONTROL_MODE:
+              // New current position is the position of the activated extruder
+              current_position[X_AXIS] = LOGICAL_X_POSITION(inactive_extruder_x_pos);
+              // Save the inactive extruder's position (from the old current_position)
+              inactive_extruder_x_pos = RAW_X_POSITION(destination[X_AXIS]);
+              break;
+            case DXC_AUTO_PARK_MODE:
+              // record raised toolhead position for use by unpark
+              COPY(raised_parked_position, current_position);
+              raised_parked_position[Z_AXIS] += TOOLCHANGE_UNPARK_ZLIFT;
+              #if ENABLED(MAX_SOFTWARE_ENDSTOPS)
+                NOMORE(raised_parked_position[Z_AXIS], soft_endstop_max[Z_AXIS]);
+              #endif
+              active_extruder_parked = true;
+              delayed_move_time = 0;
+              break;
+            case DXC_DUPLICATION_MODE:
+              // If the new extruder is the left one, set it "parked"
+              // This triggers the second extruder to move into the duplication position
+              active_extruder_parked = (active_extruder == 0);
+
+              if (active_extruder_parked)
+                current_position[X_AXIS] = LOGICAL_X_POSITION(inactive_extruder_x_pos);
+              else
+                current_position[X_AXIS] = destination[X_AXIS] + duplicate_extruder_x_offset;
+              inactive_extruder_x_pos = RAW_X_POSITION(destination[X_AXIS]);
+              extruder_duplication_enabled = false;
+              #if ENABLED(DEBUG_LEVELING_FEATURE)
+                if (DEBUGGING(LEVELING)) {
+                  SERIAL_ECHOLNPAIR("Set inactive_extruder_x_pos=", inactive_extruder_x_pos);
+                  SERIAL_ECHOLNPGM("Clear extruder_duplication_enabled");
+                }
+              #endif
+              break;
+          }
+
+          #if ENABLED(DEBUG_LEVELING_FEATURE)
+            if (DEBUGGING(LEVELING)) {
+              SERIAL_ECHOLNPAIR("Active extruder parked: ", active_extruder_parked ? "yes" : "no");
+              DEBUG_POS("New extruder (parked)", current_position);
+            }
+          #endif
+
+          // No extra case for HAS_ABL in DUAL_X_CARRIAGE. Does that mean they don't work together?
+
+        #else // !DUAL_X_CARRIAGE
+
+          #if ENABLED(PARKING_EXTRUDER) // Dual Parking extruder
+            const float z_diff = hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
+            float z_raise = 0;
+            if (!no_move) {
+
+              const float parkingposx[] = PARKING_EXTRUDER_PARKING_X,
+                          midpos = ((parkingposx[1] - parkingposx[0])/2) + parkingposx[0] + hotend_offset[X_AXIS][active_extruder],
+                          grabpos = parkingposx[tmp_extruder] + hotend_offset[X_AXIS][active_extruder]
+                                    + (tmp_extruder == 0 ? -(PARKING_EXTRUDER_GRAB_DISTANCE) : PARKING_EXTRUDER_GRAB_DISTANCE);
+              /**
+               *  Steps:
+               *    1. raise Z-Axis to have enough clearance
+               *    2. move to park poition of old extruder
+               *    3. disengage magnetc field, wait for delay
+               *    4. move near new extruder
+               *    5. engage magnetic field for new extruder
+               *    6. move to parking incl. offset of new extruder
+               *    7. lower Z-Axis
+               */
+
+              // STEP 1
+              #if ENABLED(DEBUG_LEVELING_FEATURE)
+                SERIAL_ECHOLNPGM("Starting Autopark");
+                if (DEBUGGING(LEVELING)) DEBUG_POS("current position:", current_position);
+              #endif
+              z_raise = PARKING_EXTRUDER_SECURITY_RAISE;
+              current_position[Z_AXIS] += z_raise;
+              #if ENABLED(DEBUG_LEVELING_FEATURE)
+                SERIAL_ECHOLNPGM("(1) Raise Z-Axis ");
+                if (DEBUGGING(LEVELING)) DEBUG_POS("Moving to Raised Z-Position", current_position);
+              #endif
+              planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
+              stepper.synchronize();
+
+              // STEP 2
+              current_position[X_AXIS] = parkingposx[active_extruder] + hotend_offset[X_AXIS][active_extruder];
+              #if ENABLED(DEBUG_LEVELING_FEATURE)
+                SERIAL_ECHOLNPAIR("(2) Park extruder ", active_extruder);
+                if (DEBUGGING(LEVELING)) DEBUG_POS("Moving ParkPos", current_position);
+              #endif
+              planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
+              stepper.synchronize();
+
+              // STEP 3
+              #if ENABLED(DEBUG_LEVELING_FEATURE)
+                SERIAL_ECHOLNPGM("(3) Disengage magnet ");
+              #endif
+              pe_deactivate_magnet(active_extruder);
+
+              // STEP 4
+              #if ENABLED(DEBUG_LEVELING_FEATURE)
+                SERIAL_ECHOLNPGM("(4) Move to position near new extruder");
+              #endif
+              current_position[X_AXIS] += (active_extruder == 0 ? 10 : -10); // move 10mm away from parked extruder
+
+              #if ENABLED(DEBUG_LEVELING_FEATURE)
+                if (DEBUGGING(LEVELING)) DEBUG_POS("Moving away from parked extruder", current_position);
+              #endif
+              planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
+              stepper.synchronize();
+
+              // STEP 5
+              #if ENABLED(DEBUG_LEVELING_FEATURE)
+                SERIAL_ECHOLNPGM("(5) Engage magnetic field");
+              #endif
+
+              #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
+                pe_activate_magnet(active_extruder); //just save power for inverted magnets
+              #endif
+              pe_activate_magnet(tmp_extruder);
+
+              // STEP 6
+              current_position[X_AXIS] = grabpos + (tmp_extruder == 0 ? (+10) : (-10));
+              planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
+              current_position[X_AXIS] = grabpos;
+              #if ENABLED(DEBUG_LEVELING_FEATURE)
+                SERIAL_ECHOLNPAIR("(6) Unpark extruder ", tmp_extruder);
+                if (DEBUGGING(LEVELING)) DEBUG_POS("Move UnparkPos", current_position);
+              #endif
+              planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS]/2, active_extruder);
+              stepper.synchronize();
+
+              // Step 7
+              current_position[X_AXIS] = midpos - hotend_offset[X_AXIS][tmp_extruder];
+              #if ENABLED(DEBUG_LEVELING_FEATURE)
+                SERIAL_ECHOLNPGM("(7) Move midway between hotends");
+                if (DEBUGGING(LEVELING)) DEBUG_POS("Move midway to new extruder", current_position);
+              #endif
+              planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
+              stepper.synchronize();
+              #if ENABLED(DEBUG_LEVELING_FEATURE)
+                SERIAL_ECHOLNPGM("Autopark done.");
+              #endif
+            }
+            else { // nomove == true
+              // Only engage magnetic field for new extruder
+              pe_activate_magnet(tmp_extruder);
+              #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
+                pe_activate_magnet(active_extruder); // Just save power for inverted magnets
+              #endif
+            }
+            current_position[Z_AXIS] -= hotend_offset[Z_AXIS][tmp_extruder] - hotend_offset[Z_AXIS][active_extruder]; // Apply Zoffset
+
+            #if ENABLED(DEBUG_LEVELING_FEATURE)
+              if (DEBUGGING(LEVELING)) DEBUG_POS("Applying Z-offset", current_position);
+            #endif
+
+          #endif // dualParking extruder
+
+          #if ENABLED(SWITCHING_NOZZLE)
+            #define DONT_SWITCH (SWITCHING_EXTRUDER_SERVO_NR == SWITCHING_NOZZLE_SERVO_NR)
+            // <0 if the new nozzle is higher, >0 if lower. A bigger raise when lower.
+            const float z_diff = hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder],
+                        z_raise = 0.3 + (z_diff > 0.0 ? z_diff : 0.0);
+
+            // Always raise by some amount (destination copied from current_position earlier)
+            current_position[Z_AXIS] += z_raise;
+            planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
+            move_nozzle_servo(tmp_extruder);
+          #endif
+
+          /**
+           * Set current_position to the position of the new nozzle.
+           * Offsets are based on linear distance, so we need to get
+           * the resulting position in coordinate space.
+           *
+           * - With grid or 3-point leveling, offset XYZ by a tilted vector
+           * - With mesh leveling, update Z for the new position
+           * - Otherwise, just use the raw linear distance
+           *
+           * Software endstops are altered here too. Consider a case where:
+           *   E0 at X=0 ... E1 at X=10
+           * When we switch to E1 now X=10, but E1 can't move left.
+           * To express this we apply the change in XY to the software endstops.
+           * E1 can move farther right than E0, so the right limit is extended.
+           *
+           * Note that we don't adjust the Z software endstops. Why not?
+           * Consider a case where Z=0 (here) and switching to E1 makes Z=1
+           * because the bed is 1mm lower at the new position. As long as
+           * the first nozzle is out of the way, the carriage should be
+           * allowed to move 1mm lower. This technically "breaks" the
+           * Z software endstop. But this is technically correct (and
+           * there is no viable alternative).
+           */
+          #if ABL_PLANAR
+            // Offset extruder, make sure to apply the bed level rotation matrix
+            vector_3 tmp_offset_vec = vector_3(hotend_offset[X_AXIS][tmp_extruder],
+                                               hotend_offset[Y_AXIS][tmp_extruder],
+                                               0),
+                     act_offset_vec = vector_3(hotend_offset[X_AXIS][active_extruder],
+                                               hotend_offset[Y_AXIS][active_extruder],
+                                               0),
+                     offset_vec = tmp_offset_vec - act_offset_vec;
+
+            #if ENABLED(DEBUG_LEVELING_FEATURE)
+              if (DEBUGGING(LEVELING)) {
+                tmp_offset_vec.debug(PSTR("tmp_offset_vec"));
+                act_offset_vec.debug(PSTR("act_offset_vec"));
+                offset_vec.debug(PSTR("offset_vec (BEFORE)"));
+              }
+            #endif
+
+            offset_vec.apply_rotation(planner.bed_level_matrix.transpose(planner.bed_level_matrix));
+
+            #if ENABLED(DEBUG_LEVELING_FEATURE)
+              if (DEBUGGING(LEVELING)) offset_vec.debug(PSTR("offset_vec (AFTER)"));
+            #endif
+
+            // Adjustments to the current position
+            const float xydiff[2] = { offset_vec.x, offset_vec.y };
+            current_position[Z_AXIS] += offset_vec.z;
+
+          #else // !ABL_PLANAR
+
+            const float xydiff[2] = {
+              hotend_offset[X_AXIS][tmp_extruder] - hotend_offset[X_AXIS][active_extruder],
+              hotend_offset[Y_AXIS][tmp_extruder] - hotend_offset[Y_AXIS][active_extruder]
+            };
+
+            #if ENABLED(MESH_BED_LEVELING)
+
+              if (leveling_is_active()) {
+                #if ENABLED(DEBUG_LEVELING_FEATURE)
+                  if (DEBUGGING(LEVELING)) SERIAL_ECHOPAIR("Z before MBL: ", current_position[Z_AXIS]);
+                #endif
+                float x2 = current_position[X_AXIS] + xydiff[X_AXIS],
+                      y2 = current_position[Y_AXIS] + xydiff[Y_AXIS],
+                      z1 = current_position[Z_AXIS], z2 = z1;
+                planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], z1);
+                planner.apply_leveling(x2, y2, z2);
+                current_position[Z_AXIS] += z2 - z1;
+                #if ENABLED(DEBUG_LEVELING_FEATURE)
+                  if (DEBUGGING(LEVELING))
+                    SERIAL_ECHOLNPAIR(" after: ", current_position[Z_AXIS]);
+                #endif
+              }
+
+            #endif // MESH_BED_LEVELING
+
+          #endif // !HAS_ABL
+
+          #if ENABLED(DEBUG_LEVELING_FEATURE)
+            if (DEBUGGING(LEVELING)) {
+              SERIAL_ECHOPAIR("Offset Tool XY by { ", xydiff[X_AXIS]);
+              SERIAL_ECHOPAIR(", ", xydiff[Y_AXIS]);
+              SERIAL_ECHOLNPGM(" }");
+            }
+          #endif
+
+          // The newly-selected extruder XY is actually at...
+          current_position[X_AXIS] += xydiff[X_AXIS];
+          current_position[Y_AXIS] += xydiff[Y_AXIS];
+          #if HAS_WORKSPACE_OFFSET || ENABLED(DUAL_X_CARRIAGE) || ENABLED(PARKING_EXTRUDER)
+            for (uint8_t i = X_AXIS; i <= Y_AXIS; i++) {
+              #if HAS_POSITION_SHIFT
+                position_shift[i] += xydiff[i];
+              #endif
+              update_software_endstops((AxisEnum)i);
+            }
+          #endif
+
+          // Set the new active extruder
+          active_extruder = tmp_extruder;
+
+        #endif // !DUAL_X_CARRIAGE
+
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) DEBUG_POS("Sync After Toolchange", current_position);
+        #endif
+
+        // Tell the planner the new "current position"
+        SYNC_PLAN_POSITION_KINEMATIC();
+
+        // Move to the "old position" (move the extruder into place)
+        if (!no_move && IsRunning()) {
+          #if ENABLED(DEBUG_LEVELING_FEATURE)
+            if (DEBUGGING(LEVELING)) DEBUG_POS("Move back", destination);
+          #endif
+          prepare_move_to_destination();
+        }
+
+        #if ENABLED(SWITCHING_NOZZLE)
+          // Move back down, if needed. (Including when the new tool is higher.)
+          if (z_raise != z_diff) {
+            destination[Z_AXIS] += z_diff;
+            feedrate_mm_s = planner.max_feedrate_mm_s[Z_AXIS];
+            prepare_move_to_destination();
+          }
+        #endif
+
+      } // (tmp_extruder != active_extruder)
+
+      stepper.synchronize();
+
+      #if ENABLED(EXT_SOLENOID) && !ENABLED(PARKING_EXTRUDER)
+        disable_all_solenoids();
+        enable_solenoid_on_active_extruder();
+      #endif // EXT_SOLENOID
+
+      feedrate_mm_s = old_feedrate_mm_s;
+
+    #else // HOTENDS <= 1
+
+      UNUSED(fr_mm_s);
+      UNUSED(no_move);
+
+      #if ENABLED(MK2_MULTIPLEXER)
+        if (tmp_extruder >= E_STEPPERS)
+          return invalid_extruder_error(tmp_extruder);
+
+        select_multiplexed_stepper(tmp_extruder);
+      #endif
+
+      // Set the new active extruder
+      active_extruder = tmp_extruder;
+
+    #endif // HOTENDS <= 1
+
+    #if ENABLED(SWITCHING_EXTRUDER) && !DONT_SWITCH
+      stepper.synchronize();
+      move_extruder_servo(active_extruder);
+    #endif
+
+    #if HAS_FANMUX
+      fanmux_switch(active_extruder);
+    #endif
+
+    SERIAL_ECHO_START();
+    SERIAL_ECHOLNPAIR(MSG_ACTIVE_EXTRUDER, (int)active_extruder);
+
+  #endif // !MIXING_EXTRUDER || MIXING_VIRTUAL_TOOLS <= 1
+}
