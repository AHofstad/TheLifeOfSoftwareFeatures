commit 1c6cfc3ffeac8fdf2cd6d61529ad864578a4803f
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Tue Jan 30 21:00:02 2024 -0800

    üêõ Fix I/J/K chopper timing (#26736)
    
    Followup to #19112

diff --git a/Marlin/src/module/stepper/trinamic.h b/Marlin/src/module/stepper/trinamic.h
index a9832945a5..3ae784be97 100644
--- a/Marlin/src/module/stepper/trinamic.h
+++ b/Marlin/src/module/stepper/trinamic.h
@@ -241,49 +241,49 @@ void reset_trinamic_drivers();
     #define Z4_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(Z4_STEP_PIN); }while(0)
   #endif
 #endif
 
 // I Stepper
 #if AXIS_IS_TMC(I)
   extern TMC_CLASS(I, I) stepperI;
   static constexpr chopper_timing_t chopper_timing_I = CHOPPER_TIMING_I;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define I_ENABLE_INIT() NOOP
-    #define I_ENABLE_WRITE(STATE) stepperI.toff((STATE)==I_ENABLE_ON ? chopper_timing.toff : 0)
+    #define I_ENABLE_WRITE(STATE) stepperI.toff((STATE)==I_ENABLE_ON ? chopper_timing_I.toff : 0)
     #define I_ENABLE_READ() stepperI.isEnabled()
   #endif
   #if AXIS_HAS_DEDGE(I)
     #define I_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(I_STEP_PIN); }while(0)
   #endif
 #endif
 
 // J Stepper
 #if AXIS_IS_TMC(J)
   extern TMC_CLASS(J, J) stepperJ;
   static constexpr chopper_timing_t chopper_timing_J = CHOPPER_TIMING_J;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define J_ENABLE_INIT() NOOP
-    #define J_ENABLE_WRITE(STATE) stepperJ.toff((STATE)==J_ENABLE_ON ? chopper_timing.toff : 0)
+    #define J_ENABLE_WRITE(STATE) stepperJ.toff((STATE)==J_ENABLE_ON ? chopper_timing_J.toff : 0)
     #define J_ENABLE_READ() stepperJ.isEnabled()
   #endif
   #if AXIS_HAS_DEDGE(J)
     #define J_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(J_STEP_PIN); }while(0)
   #endif
 #endif
 
 // K Stepper
 #if AXIS_IS_TMC(K)
   extern TMC_CLASS(K, K) stepperK;
   static constexpr chopper_timing_t chopper_timing_K = CHOPPER_TIMING_K;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define K_ENABLE_INIT() NOOP
-    #define K_ENABLE_WRITE(STATE) stepperK.toff((STATE)==K_ENABLE_ON ? chopper_timing.toff : 0)
+    #define K_ENABLE_WRITE(STATE) stepperK.toff((STATE)==K_ENABLE_ON ? chopper_timing_K.toff : 0)
     #define K_ENABLE_READ() stepperK.isEnabled()
   #endif
   #if AXIS_HAS_DEDGE(K)
     #define K_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(K_STEP_PIN); }while(0)
   #endif
 #endif
 
 // U Stepper
 #if AXIS_IS_TMC(U)
   extern TMC_CLASS(U, U) stepperU;

commit f281fb473d499d8805fb29d7dd13ec9ef6b10c41
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jun 25 01:31:07 2023 -0500

    üé® Minor code cleanup

diff --git a/Marlin/src/module/stepper/trinamic.h b/Marlin/src/module/stepper/trinamic.h
index d6de5cd002..a9832945a5 100644
--- a/Marlin/src/module/stepper/trinamic.h
+++ b/Marlin/src/module/stepper/trinamic.h
@@ -287,49 +287,49 @@ void reset_trinamic_drivers();
 // U Stepper
 #if AXIS_IS_TMC(U)
   extern TMC_CLASS(U, U) stepperU;
   static constexpr chopper_timing_t chopper_timing_U = CHOPPER_TIMING_U;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define U_ENABLE_INIT() NOOP
     #define U_ENABLE_WRITE(STATE) stepperU.toff((STATE)==U_ENABLE_ON ? chopper_timing_U.toff : 0)
     #define U_ENABLE_READ() stepperU.isEnabled()
   #endif
   #if AXIS_HAS_DEDGE(U)
-    #define U_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(U_STEP_PIN); }while(0)
+    #define U_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(U_STEP_PIN); }while(0)
   #endif
 #endif
 
 // V Stepper
 #if AXIS_IS_TMC(V)
   extern TMC_CLASS(V, V) stepperV;
   static constexpr chopper_timing_t chopper_timing_V = CHOPPER_TIMING_V;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define V_ENABLE_INIT() NOOP
     #define V_ENABLE_WRITE(STATE) stepperV.toff((STATE)==V_ENABLE_ON ? chopper_timing_V.toff : 0)
     #define V_ENABLE_READ() stepperV.isEnabled()
   #endif
   #if AXIS_HAS_DEDGE(V)
-    #define V_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(V_STEP_PIN); }while(0)
+    #define V_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(V_STEP_PIN); }while(0)
   #endif
 #endif
 
 // W Stepper
 #if AXIS_IS_TMC(W)
   extern TMC_CLASS(W, W) stepperW;
   static constexpr chopper_timing_t chopper_timing_W = CHOPPER_TIMING_W;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define W_ENABLE_INIT() NOOP
     #define W_ENABLE_WRITE(STATE) stepperW.toff((STATE)==W_ENABLE_ON ? chopper_timing_W.toff : 0)
     #define W_ENABLE_READ() stepperW.isEnabled()
   #endif
   #if AXIS_HAS_DEDGE(W)
-    #define W_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(W_STEP_PIN); }while(0)
+    #define W_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(W_STEP_PIN); }while(0)
   #endif
 #endif
 
 // E0 Stepper
 #if AXIS_IS_TMC(E0)
   extern TMC_CLASS_E(0) stepperE0;
   #ifndef CHOPPER_TIMING_E0
     #define CHOPPER_TIMING_E0 CHOPPER_TIMING_E
   #endif
   static constexpr chopper_timing_t chopper_timing_E0 = CHOPPER_TIMING_E0;

commit 1f9bfc5c7491d802d242623f8253b1f52c0917a3
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Wed May 10 06:59:25 2023 +1200

    üö∏ Optional X-Axis (#25418)
    
    Co-authored-by: alextrical <35117191+alextrical@users.noreply.github.com>
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper/trinamic.h b/Marlin/src/module/stepper/trinamic.h
index 88c0686fc3..d6de5cd002 100644
--- a/Marlin/src/module/stepper/trinamic.h
+++ b/Marlin/src/module/stepper/trinamic.h
@@ -70,21 +70,21 @@
 
 #define __TMC_CLASS(TYPE, L, I, A) TMCMarlin<CLASS_##TYPE, L, I, A>
 #define _TMC_CLASS(TYPE, LandI, A) __TMC_CLASS(TYPE, LandI, A)
 #define TMC_CLASS(ST, A) _TMC_CLASS(ST##_DRIVER_TYPE, TMC_##ST##_LABEL, A##_AXIS)
 #if ENABLED(DISTINCT_E_FACTORS)
   #define TMC_CLASS_E(N) TMC_CLASS(E##N, E##N)
 #else
   #define TMC_CLASS_E(N) TMC_CLASS(E##N, E)
 #endif
 
-#ifndef CHOPPER_TIMING_X
+#if HAS_X_AXIS && !defined(CHOPPER_TIMING_X)
   #define CHOPPER_TIMING_X CHOPPER_TIMING
 #endif
 #if HAS_Y_AXIS && !defined(CHOPPER_TIMING_Y)
   #define CHOPPER_TIMING_Y CHOPPER_TIMING
 #endif
 #if HAS_Z_AXIS && !defined(CHOPPER_TIMING_Z)
   #define CHOPPER_TIMING_Z CHOPPER_TIMING
 #endif
 #if HAS_I_AXIS && !defined(CHOPPER_TIMING_I)
   #define CHOPPER_TIMING_I CHOPPER_TIMING

commit efc725863ab76cfd32fc8bb136aec7b6d884cef0
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Apr 14 17:14:04 2023 -0500

    üîß Edge Stepping sanity-check (#25674)

diff --git a/Marlin/src/module/stepper/trinamic.h b/Marlin/src/module/stepper/trinamic.h
index 3705543c99..88c0686fc3 100644
--- a/Marlin/src/module/stepper/trinamic.h
+++ b/Marlin/src/module/stepper/trinamic.h
@@ -108,22 +108,20 @@
   #define CHOPPER_TIMING_E CHOPPER_TIMING
 #endif
 
 #if HAS_TMC220x
   void tmc_serial_begin();
 #endif
 
 void restore_trinamic_drivers();
 void reset_trinamic_drivers();
 
-#define AXIS_HAS_DEDGE(A) (AXIS_IS_TMC(A) && ENABLED(EDGE_STEPPING))
-
 // X Stepper
 #if AXIS_IS_TMC(X)
   extern TMC_CLASS(X, X) stepperX;
   static constexpr chopper_timing_t chopper_timing_X = CHOPPER_TIMING_X;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define X_ENABLE_INIT() NOOP
     #define X_ENABLE_WRITE(STATE) stepperX.toff((STATE)==X_ENABLE_ON ? chopper_timing_X.toff : 0)
     #define X_ENABLE_READ() stepperX.isEnabled()
   #endif
   #if AXIS_HAS_DEDGE(X)

commit 98c0cc044d1be2c098335d9656f2d0eadf524129
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Sat Mar 18 00:22:17 2023 -0700

    üîß SQUARE_WAVE_STEPPING => EDGE_STEPPING (#25526)
    
    Co-Authored-By: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper/trinamic.h b/Marlin/src/module/stepper/trinamic.h
index 95bab7652c..3705543c99 100644
--- a/Marlin/src/module/stepper/trinamic.h
+++ b/Marlin/src/module/stepper/trinamic.h
@@ -108,358 +108,358 @@
   #define CHOPPER_TIMING_E CHOPPER_TIMING
 #endif
 
 #if HAS_TMC220x
   void tmc_serial_begin();
 #endif
 
 void restore_trinamic_drivers();
 void reset_trinamic_drivers();
 
-#define AXIS_HAS_SQUARE_WAVE(A) (AXIS_IS_TMC(A) && ENABLED(SQUARE_WAVE_STEPPING))
+#define AXIS_HAS_DEDGE(A) (AXIS_IS_TMC(A) && ENABLED(EDGE_STEPPING))
 
 // X Stepper
 #if AXIS_IS_TMC(X)
   extern TMC_CLASS(X, X) stepperX;
   static constexpr chopper_timing_t chopper_timing_X = CHOPPER_TIMING_X;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define X_ENABLE_INIT() NOOP
     #define X_ENABLE_WRITE(STATE) stepperX.toff((STATE)==X_ENABLE_ON ? chopper_timing_X.toff : 0)
     #define X_ENABLE_READ() stepperX.isEnabled()
   #endif
-  #if AXIS_HAS_SQUARE_WAVE(X)
+  #if AXIS_HAS_DEDGE(X)
     #define X_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(X_STEP_PIN); }while(0)
   #endif
 #endif
 
 // Y Stepper
 #if AXIS_IS_TMC(Y)
   extern TMC_CLASS(Y, Y) stepperY;
   static constexpr chopper_timing_t chopper_timing_Y = CHOPPER_TIMING_Y;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define Y_ENABLE_INIT() NOOP
     #define Y_ENABLE_WRITE(STATE) stepperY.toff((STATE)==Y_ENABLE_ON ? chopper_timing_Y.toff : 0)
     #define Y_ENABLE_READ() stepperY.isEnabled()
   #endif
-  #if AXIS_HAS_SQUARE_WAVE(Y)
+  #if AXIS_HAS_DEDGE(Y)
     #define Y_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(Y_STEP_PIN); }while(0)
   #endif
 #endif
 
 // Z Stepper
 #if AXIS_IS_TMC(Z)
   extern TMC_CLASS(Z, Z) stepperZ;
   static constexpr chopper_timing_t chopper_timing_Z = CHOPPER_TIMING_Z;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define Z_ENABLE_INIT() NOOP
     #define Z_ENABLE_WRITE(STATE) stepperZ.toff((STATE)==Z_ENABLE_ON ? chopper_timing_Z.toff : 0)
     #define Z_ENABLE_READ() stepperZ.isEnabled()
   #endif
-  #if AXIS_HAS_SQUARE_WAVE(Z)
+  #if AXIS_HAS_DEDGE(Z)
     #define Z_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(Z_STEP_PIN); }while(0)
   #endif
 #endif
 
 // X2 Stepper
 #if HAS_X2_ENABLE && AXIS_IS_TMC(X2)
   extern TMC_CLASS(X2, X) stepperX2;
   #ifndef CHOPPER_TIMING_X2
     #define CHOPPER_TIMING_X2 CHOPPER_TIMING_X
   #endif
   static constexpr chopper_timing_t chopper_timing_X2 = CHOPPER_TIMING_X2;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define X2_ENABLE_INIT() NOOP
     #define X2_ENABLE_WRITE(STATE) stepperX2.toff((STATE)==X_ENABLE_ON ? chopper_timing_X2.toff : 0)
     #define X2_ENABLE_READ() stepperX2.isEnabled()
   #endif
-  #if AXIS_HAS_SQUARE_WAVE(X2)
+  #if AXIS_HAS_DEDGE(X2)
     #define X2_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(X2_STEP_PIN); }while(0)
   #endif
 #endif
 
 // Y2 Stepper
 #if HAS_Y2_ENABLE && AXIS_IS_TMC(Y2)
   extern TMC_CLASS(Y2, Y) stepperY2;
   #ifndef CHOPPER_TIMING_Y2
     #define CHOPPER_TIMING_Y2 CHOPPER_TIMING_Y
   #endif
   static constexpr chopper_timing_t chopper_timing_Y2 = CHOPPER_TIMING_Y2;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define Y2_ENABLE_INIT() NOOP
     #define Y2_ENABLE_WRITE(STATE) stepperY2.toff((STATE)==Y_ENABLE_ON ? chopper_timing_Y2.toff : 0)
     #define Y2_ENABLE_READ() stepperY2.isEnabled()
   #endif
-  #if AXIS_HAS_SQUARE_WAVE(Y2)
+  #if AXIS_HAS_DEDGE(Y2)
     #define Y2_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(Y2_STEP_PIN); }while(0)
   #endif
 #endif
 
 // Z2 Stepper
 #if HAS_Z2_ENABLE && AXIS_IS_TMC(Z2)
   extern TMC_CLASS(Z2, Z) stepperZ2;
   #ifndef CHOPPER_TIMING_Z2
     #define CHOPPER_TIMING_Z2 CHOPPER_TIMING_Z
   #endif
   static constexpr chopper_timing_t chopper_timing_Z2 = CHOPPER_TIMING_Z2;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define Z2_ENABLE_INIT() NOOP
     #define Z2_ENABLE_WRITE(STATE) stepperZ2.toff((STATE)==Z_ENABLE_ON ? chopper_timing_Z2.toff : 0)
     #define Z2_ENABLE_READ() stepperZ2.isEnabled()
   #endif
-  #if AXIS_HAS_SQUARE_WAVE(Z2)
+  #if AXIS_HAS_DEDGE(Z2)
     #define Z2_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(Z2_STEP_PIN); }while(0)
   #endif
 #endif
 
 // Z3 Stepper
 #if HAS_Z3_ENABLE && AXIS_IS_TMC(Z3)
   extern TMC_CLASS(Z3, Z) stepperZ3;
   #ifndef CHOPPER_TIMING_Z3
     #define CHOPPER_TIMING_Z3 CHOPPER_TIMING_Z
   #endif
   static constexpr chopper_timing_t chopper_timing_Z3 = CHOPPER_TIMING_Z3;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define Z3_ENABLE_INIT() NOOP
     #define Z3_ENABLE_WRITE(STATE) stepperZ3.toff((STATE)==Z_ENABLE_ON ? chopper_timing_Z3.toff : 0)
     #define Z3_ENABLE_READ() stepperZ3.isEnabled()
   #endif
-  #if AXIS_HAS_SQUARE_WAVE(Z3)
+  #if AXIS_HAS_DEDGE(Z3)
     #define Z3_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(Z3_STEP_PIN); }while(0)
   #endif
 #endif
 
 // Z4 Stepper
 #if HAS_Z4_ENABLE && AXIS_IS_TMC(Z4)
   extern TMC_CLASS(Z4, Z) stepperZ4;
   #ifndef CHOPPER_TIMING_Z4
     #define CHOPPER_TIMING_Z4 CHOPPER_TIMING_Z
   #endif
   static constexpr chopper_timing_t chopper_timing_Z4 = CHOPPER_TIMING_Z4;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define Z4_ENABLE_INIT() NOOP
     #define Z4_ENABLE_WRITE(STATE) stepperZ4.toff((STATE)==Z_ENABLE_ON ? chopper_timing_Z4.toff : 0)
     #define Z4_ENABLE_READ() stepperZ4.isEnabled()
   #endif
-  #if AXIS_HAS_SQUARE_WAVE(Z4)
+  #if AXIS_HAS_DEDGE(Z4)
     #define Z4_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(Z4_STEP_PIN); }while(0)
   #endif
 #endif
 
 // I Stepper
 #if AXIS_IS_TMC(I)
   extern TMC_CLASS(I, I) stepperI;
   static constexpr chopper_timing_t chopper_timing_I = CHOPPER_TIMING_I;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define I_ENABLE_INIT() NOOP
     #define I_ENABLE_WRITE(STATE) stepperI.toff((STATE)==I_ENABLE_ON ? chopper_timing.toff : 0)
     #define I_ENABLE_READ() stepperI.isEnabled()
   #endif
-  #if AXIS_HAS_SQUARE_WAVE(I)
+  #if AXIS_HAS_DEDGE(I)
     #define I_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(I_STEP_PIN); }while(0)
   #endif
 #endif
 
 // J Stepper
 #if AXIS_IS_TMC(J)
   extern TMC_CLASS(J, J) stepperJ;
   static constexpr chopper_timing_t chopper_timing_J = CHOPPER_TIMING_J;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define J_ENABLE_INIT() NOOP
     #define J_ENABLE_WRITE(STATE) stepperJ.toff((STATE)==J_ENABLE_ON ? chopper_timing.toff : 0)
     #define J_ENABLE_READ() stepperJ.isEnabled()
   #endif
-  #if AXIS_HAS_SQUARE_WAVE(J)
+  #if AXIS_HAS_DEDGE(J)
     #define J_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(J_STEP_PIN); }while(0)
   #endif
 #endif
 
 // K Stepper
 #if AXIS_IS_TMC(K)
   extern TMC_CLASS(K, K) stepperK;
   static constexpr chopper_timing_t chopper_timing_K = CHOPPER_TIMING_K;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define K_ENABLE_INIT() NOOP
     #define K_ENABLE_WRITE(STATE) stepperK.toff((STATE)==K_ENABLE_ON ? chopper_timing.toff : 0)
     #define K_ENABLE_READ() stepperK.isEnabled()
   #endif
-  #if AXIS_HAS_SQUARE_WAVE(K)
+  #if AXIS_HAS_DEDGE(K)
     #define K_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(K_STEP_PIN); }while(0)
   #endif
 #endif
 
 // U Stepper
 #if AXIS_IS_TMC(U)
   extern TMC_CLASS(U, U) stepperU;
   static constexpr chopper_timing_t chopper_timing_U = CHOPPER_TIMING_U;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define U_ENABLE_INIT() NOOP
     #define U_ENABLE_WRITE(STATE) stepperU.toff((STATE)==U_ENABLE_ON ? chopper_timing_U.toff : 0)
     #define U_ENABLE_READ() stepperU.isEnabled()
   #endif
-  #if AXIS_HAS_SQUARE_WAVE(U)
+  #if AXIS_HAS_DEDGE(U)
     #define U_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(U_STEP_PIN); }while(0)
   #endif
 #endif
 
 // V Stepper
 #if AXIS_IS_TMC(V)
   extern TMC_CLASS(V, V) stepperV;
   static constexpr chopper_timing_t chopper_timing_V = CHOPPER_TIMING_V;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define V_ENABLE_INIT() NOOP
     #define V_ENABLE_WRITE(STATE) stepperV.toff((STATE)==V_ENABLE_ON ? chopper_timing_V.toff : 0)
     #define V_ENABLE_READ() stepperV.isEnabled()
   #endif
-  #if AXIS_HAS_SQUARE_WAVE(V)
+  #if AXIS_HAS_DEDGE(V)
     #define V_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(V_STEP_PIN); }while(0)
   #endif
 #endif
 
 // W Stepper
 #if AXIS_IS_TMC(W)
   extern TMC_CLASS(W, W) stepperW;
   static constexpr chopper_timing_t chopper_timing_W = CHOPPER_TIMING_W;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define W_ENABLE_INIT() NOOP
     #define W_ENABLE_WRITE(STATE) stepperW.toff((STATE)==W_ENABLE_ON ? chopper_timing_W.toff : 0)
     #define W_ENABLE_READ() stepperW.isEnabled()
   #endif
-  #if AXIS_HAS_SQUARE_WAVE(W)
+  #if AXIS_HAS_DEDGE(W)
     #define W_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(W_STEP_PIN); }while(0)
   #endif
 #endif
 
 // E0 Stepper
 #if AXIS_IS_TMC(E0)
   extern TMC_CLASS_E(0) stepperE0;
   #ifndef CHOPPER_TIMING_E0
     #define CHOPPER_TIMING_E0 CHOPPER_TIMING_E
   #endif
   static constexpr chopper_timing_t chopper_timing_E0 = CHOPPER_TIMING_E0;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define E0_ENABLE_INIT() NOOP
     #define E0_ENABLE_WRITE(STATE) stepperE0.toff((STATE)==E_ENABLE_ON ? chopper_timing_E0.toff : 0)
     #define E0_ENABLE_READ() stepperE0.isEnabled()
   #endif
-  #if AXIS_HAS_SQUARE_WAVE(E0)
+  #if AXIS_HAS_DEDGE(E0)
     #define E0_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(E0_STEP_PIN); }while(0)
   #endif
 #endif
 
 // E1 Stepper
 #if AXIS_IS_TMC(E1)
   extern TMC_CLASS_E(1) stepperE1;
   #ifndef CHOPPER_TIMING_E1
     #define CHOPPER_TIMING_E1 CHOPPER_TIMING_E
   #endif
   static constexpr chopper_timing_t chopper_timing_E1 = CHOPPER_TIMING_E1;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define E1_ENABLE_INIT() NOOP
     #define E1_ENABLE_WRITE(STATE) stepperE1.toff((STATE)==E_ENABLE_ON ? chopper_timing_E1.toff : 0)
     #define E1_ENABLE_READ() stepperE1.isEnabled()
   #endif
-  #if AXIS_HAS_SQUARE_WAVE(E1)
+  #if AXIS_HAS_DEDGE(E1)
     #define E1_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(E1_STEP_PIN); }while(0)
   #endif
 #endif
 
 // E2 Stepper
 #if AXIS_IS_TMC(E2)
   extern TMC_CLASS_E(2) stepperE2;
   #ifndef CHOPPER_TIMING_E2
     #define CHOPPER_TIMING_E2 CHOPPER_TIMING_E
   #endif
   static constexpr chopper_timing_t chopper_timing_E2 = CHOPPER_TIMING_E2;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define E2_ENABLE_INIT() NOOP
     #define E2_ENABLE_WRITE(STATE) stepperE2.toff((STATE)==E_ENABLE_ON ? chopper_timing_E2.toff : 0)
     #define E2_ENABLE_READ() stepperE2.isEnabled()
   #endif
-  #if AXIS_HAS_SQUARE_WAVE(E2)
+  #if AXIS_HAS_DEDGE(E2)
     #define E2_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(E2_STEP_PIN); }while(0)
   #endif
 #endif
 
 // E3 Stepper
 #if AXIS_IS_TMC(E3)
   extern TMC_CLASS_E(3) stepperE3;
   #ifndef CHOPPER_TIMING_E3
     #define CHOPPER_TIMING_E3 CHOPPER_TIMING_E
   #endif
   static constexpr chopper_timing_t chopper_timing_E3 = CHOPPER_TIMING_E3;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define E3_ENABLE_INIT() NOOP
     #define E3_ENABLE_WRITE(STATE) stepperE3.toff((STATE)==E_ENABLE_ON ? chopper_timing_E3.toff : 0)
     #define E3_ENABLE_READ() stepperE3.isEnabled()
   #endif
-  #if AXIS_HAS_SQUARE_WAVE(E3)
+  #if AXIS_HAS_DEDGE(E3)
     #define E3_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(E3_STEP_PIN); }while(0)
   #endif
 #endif
 
 // E4 Stepper
 #if AXIS_IS_TMC(E4)
   extern TMC_CLASS_E(4) stepperE4;
   #ifndef CHOPPER_TIMING_E4
     #define CHOPPER_TIMING_E4 CHOPPER_TIMING_E
   #endif
   static constexpr chopper_timing_t chopper_timing_E4 = CHOPPER_TIMING_E4;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define E4_ENABLE_INIT() NOOP
     #define E4_ENABLE_WRITE(STATE) stepperE4.toff((STATE)==E_ENABLE_ON ? chopper_timing_E4.toff : 0)
     #define E4_ENABLE_READ() stepperE4.isEnabled()
   #endif
-  #if AXIS_HAS_SQUARE_WAVE(E4)
+  #if AXIS_HAS_DEDGE(E4)
     #define E4_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(E4_STEP_PIN); }while(0)
   #endif
 #endif
 
 // E5 Stepper
 #if AXIS_IS_TMC(E5)
   extern TMC_CLASS_E(5) stepperE5;
   #ifndef CHOPPER_TIMING_E5
     #define CHOPPER_TIMING_E5 CHOPPER_TIMING_E
   #endif
   static constexpr chopper_timing_t chopper_timing_E5 = CHOPPER_TIMING_E5;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define E5_ENABLE_INIT() NOOP
     #define E5_ENABLE_WRITE(STATE) stepperE5.toff((STATE)==E_ENABLE_ON ? chopper_timing_E5.toff : 0)
     #define E5_ENABLE_READ() stepperE5.isEnabled()
   #endif
-  #if AXIS_HAS_SQUARE_WAVE(E5)
+  #if AXIS_HAS_DEDGE(E5)
     #define E5_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(E5_STEP_PIN); }while(0)
   #endif
 #endif
 
 // E6 Stepper
 #if AXIS_IS_TMC(E6)
   extern TMC_CLASS_E(6) stepperE6;
   #ifndef CHOPPER_TIMING_E6
     #define CHOPPER_TIMING_E6 CHOPPER_TIMING_E
   #endif
   static constexpr chopper_timing_t chopper_timing_E6 = CHOPPER_TIMING_E6;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define E6_ENABLE_INIT() NOOP
     #define E6_ENABLE_WRITE(STATE) stepperE6.toff((STATE)==E_ENABLE_ON ? chopper_timing_E6.toff : 0)
     #define E6_ENABLE_READ() stepperE6.isEnabled()
   #endif
-  #if AXIS_HAS_SQUARE_WAVE(E6)
+  #if AXIS_HAS_DEDGE(E6)
     #define E6_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(E6_STEP_PIN); }while(0)
   #endif
 #endif
 
 // E7 Stepper
 #if AXIS_IS_TMC(E7)
   extern TMC_CLASS_E(7) stepperE7;
   #ifndef CHOPPER_TIMING_E7
     #define CHOPPER_TIMING_E7 CHOPPER_TIMING_E
   #endif
   static constexpr chopper_timing_t chopper_timing_E7 = CHOPPER_TIMING_E7;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define E7_ENABLE_INIT() NOOP
     #define E7_ENABLE_WRITE(STATE) stepperE7.toff((STATE)==E_ENABLE_ON ? chopper_timing_E7.toff : 0)
     #define E7_ENABLE_READ() stepperE7.isEnabled()
   #endif
-  #if AXIS_HAS_SQUARE_WAVE(E7)
+  #if AXIS_HAS_DEDGE(E7)
     #define E7_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(E7_STEP_PIN); }while(0)
   #endif
 #endif

commit e5b651f407fcb743e2d00c45b0d361fb98230efb
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Fri Apr 1 07:10:38 2022 +0200

    ‚ú® Support for up to 9 axes (linear, rotary) (#23112)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper/trinamic.h b/Marlin/src/module/stepper/trinamic.h
index dd3a64240f..95bab7652c 100644
--- a/Marlin/src/module/stepper/trinamic.h
+++ b/Marlin/src/module/stepper/trinamic.h
@@ -42,20 +42,23 @@
 #define CLASS_TMC5130 TMC5130Stepper
 #define CLASS_TMC5160 TMC5160Stepper
 
 #define TMC_X_LABEL 'X', '0'
 #define TMC_Y_LABEL 'Y', '0'
 #define TMC_Z_LABEL 'Z', '0'
 
 #define TMC_I_LABEL 'I', '0'
 #define TMC_J_LABEL 'J', '0'
 #define TMC_K_LABEL 'K', '0'
+#define TMC_U_LABEL 'U', '0'
+#define TMC_V_LABEL 'V', '0'
+#define TMC_W_LABEL 'W', '0'
 
 #define TMC_X2_LABEL 'X', '2'
 #define TMC_Y2_LABEL 'Y', '2'
 #define TMC_Z2_LABEL 'Z', '2'
 #define TMC_Z3_LABEL 'Z', '3'
 #define TMC_Z4_LABEL 'Z', '4'
 
 #define TMC_E0_LABEL 'E', '0'
 #define TMC_E1_LABEL 'E', '1'
 #define TMC_E2_LABEL 'E', '2'
@@ -85,20 +88,29 @@
 #endif
 #if HAS_I_AXIS && !defined(CHOPPER_TIMING_I)
   #define CHOPPER_TIMING_I CHOPPER_TIMING
 #endif
 #if HAS_J_AXIS && !defined(CHOPPER_TIMING_J)
   #define CHOPPER_TIMING_J CHOPPER_TIMING
 #endif
 #if HAS_K_AXIS && !defined(CHOPPER_TIMING_K)
   #define CHOPPER_TIMING_K CHOPPER_TIMING
 #endif
+#if HAS_U_AXIS && !defined(CHOPPER_TIMING_U)
+  #define CHOPPER_TIMING_U CHOPPER_TIMING
+#endif
+#if HAS_V_AXIS && !defined(CHOPPER_TIMING_V)
+  #define CHOPPER_TIMING_V CHOPPER_TIMING
+#endif
+#if HAS_W_AXIS && !defined(CHOPPER_TIMING_W)
+  #define CHOPPER_TIMING_W CHOPPER_TIMING
+#endif
 #if HAS_EXTRUDERS && !defined(CHOPPER_TIMING_E)
   #define CHOPPER_TIMING_E CHOPPER_TIMING
 #endif
 
 #if HAS_TMC220x
   void tmc_serial_begin();
 #endif
 
 void restore_trinamic_drivers();
 void reset_trinamic_drivers();
@@ -267,20 +279,62 @@ void reset_trinamic_drivers();
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define K_ENABLE_INIT() NOOP
     #define K_ENABLE_WRITE(STATE) stepperK.toff((STATE)==K_ENABLE_ON ? chopper_timing.toff : 0)
     #define K_ENABLE_READ() stepperK.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(K)
     #define K_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(K_STEP_PIN); }while(0)
   #endif
 #endif
 
+// U Stepper
+#if AXIS_IS_TMC(U)
+  extern TMC_CLASS(U, U) stepperU;
+  static constexpr chopper_timing_t chopper_timing_U = CHOPPER_TIMING_U;
+  #if ENABLED(SOFTWARE_DRIVER_ENABLE)
+    #define U_ENABLE_INIT() NOOP
+    #define U_ENABLE_WRITE(STATE) stepperU.toff((STATE)==U_ENABLE_ON ? chopper_timing_U.toff : 0)
+    #define U_ENABLE_READ() stepperU.isEnabled()
+  #endif
+  #if AXIS_HAS_SQUARE_WAVE(U)
+    #define U_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(U_STEP_PIN); }while(0)
+  #endif
+#endif
+
+// V Stepper
+#if AXIS_IS_TMC(V)
+  extern TMC_CLASS(V, V) stepperV;
+  static constexpr chopper_timing_t chopper_timing_V = CHOPPER_TIMING_V;
+  #if ENABLED(SOFTWARE_DRIVER_ENABLE)
+    #define V_ENABLE_INIT() NOOP
+    #define V_ENABLE_WRITE(STATE) stepperV.toff((STATE)==V_ENABLE_ON ? chopper_timing_V.toff : 0)
+    #define V_ENABLE_READ() stepperV.isEnabled()
+  #endif
+  #if AXIS_HAS_SQUARE_WAVE(V)
+    #define V_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(V_STEP_PIN); }while(0)
+  #endif
+#endif
+
+// W Stepper
+#if AXIS_IS_TMC(W)
+  extern TMC_CLASS(W, W) stepperW;
+  static constexpr chopper_timing_t chopper_timing_W = CHOPPER_TIMING_W;
+  #if ENABLED(SOFTWARE_DRIVER_ENABLE)
+    #define W_ENABLE_INIT() NOOP
+    #define W_ENABLE_WRITE(STATE) stepperW.toff((STATE)==W_ENABLE_ON ? chopper_timing_W.toff : 0)
+    #define W_ENABLE_READ() stepperW.isEnabled()
+  #endif
+  #if AXIS_HAS_SQUARE_WAVE(W)
+    #define W_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(W_STEP_PIN); }while(0)
+  #endif
+#endif
+
 // E0 Stepper
 #if AXIS_IS_TMC(E0)
   extern TMC_CLASS_E(0) stepperE0;
   #ifndef CHOPPER_TIMING_E0
     #define CHOPPER_TIMING_E0 CHOPPER_TIMING_E
   #endif
   static constexpr chopper_timing_t chopper_timing_E0 = CHOPPER_TIMING_E0;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define E0_ENABLE_INIT() NOOP
     #define E0_ENABLE_WRITE(STATE) stepperE0.toff((STATE)==E_ENABLE_ON ? chopper_timing_E0.toff : 0)

commit e65c12cf96a226019a7456099078ee5cb03f9a49
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jan 2 09:22:36 2022 -0600

    üßë‚Äçüíª Apply axis conditionals

diff --git a/Marlin/src/module/stepper/trinamic.h b/Marlin/src/module/stepper/trinamic.h
index 9ed9bdf407..dd3a64240f 100644
--- a/Marlin/src/module/stepper/trinamic.h
+++ b/Marlin/src/module/stepper/trinamic.h
@@ -76,27 +76,27 @@
 
 #ifndef CHOPPER_TIMING_X
   #define CHOPPER_TIMING_X CHOPPER_TIMING
 #endif
 #if HAS_Y_AXIS && !defined(CHOPPER_TIMING_Y)
   #define CHOPPER_TIMING_Y CHOPPER_TIMING
 #endif
 #if HAS_Z_AXIS && !defined(CHOPPER_TIMING_Z)
   #define CHOPPER_TIMING_Z CHOPPER_TIMING
 #endif
-#if LINEAR_AXES >= 4 && !defined(CHOPPER_TIMING_I)
+#if HAS_I_AXIS && !defined(CHOPPER_TIMING_I)
   #define CHOPPER_TIMING_I CHOPPER_TIMING
 #endif
-#if LINEAR_AXES >= 5 && !defined(CHOPPER_TIMING_J)
+#if HAS_J_AXIS && !defined(CHOPPER_TIMING_J)
   #define CHOPPER_TIMING_J CHOPPER_TIMING
 #endif
-#if LINEAR_AXES >= 6 && !defined(CHOPPER_TIMING_K)
+#if HAS_K_AXIS && !defined(CHOPPER_TIMING_K)
   #define CHOPPER_TIMING_K CHOPPER_TIMING
 #endif
 #if HAS_EXTRUDERS && !defined(CHOPPER_TIMING_E)
   #define CHOPPER_TIMING_E CHOPPER_TIMING
 #endif
 
 #if HAS_TMC220x
   void tmc_serial_begin();
 #endif
 

commit 02b4e48c6df1604d3de09cbef072f685fe956e92
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Dec 28 05:43:10 2021 -0600

    üö∏ Refine stepper-driver-related G-codes (#23372)

diff --git a/Marlin/src/module/stepper/trinamic.h b/Marlin/src/module/stepper/trinamic.h
index 0a956a70b3..9ed9bdf407 100644
--- a/Marlin/src/module/stepper/trinamic.h
+++ b/Marlin/src/module/stepper/trinamic.h
@@ -67,26 +67,20 @@
 
 #define __TMC_CLASS(TYPE, L, I, A) TMCMarlin<CLASS_##TYPE, L, I, A>
 #define _TMC_CLASS(TYPE, LandI, A) __TMC_CLASS(TYPE, LandI, A)
 #define TMC_CLASS(ST, A) _TMC_CLASS(ST##_DRIVER_TYPE, TMC_##ST##_LABEL, A##_AXIS)
 #if ENABLED(DISTINCT_E_FACTORS)
   #define TMC_CLASS_E(N) TMC_CLASS(E##N, E##N)
 #else
   #define TMC_CLASS_E(N) TMC_CLASS(E##N, E)
 #endif
 
-typedef struct {
-  uint8_t toff;
-  int8_t hend;
-  uint8_t hstrt;
-} chopper_timing_t;
-
 #ifndef CHOPPER_TIMING_X
   #define CHOPPER_TIMING_X CHOPPER_TIMING
 #endif
 #if HAS_Y_AXIS && !defined(CHOPPER_TIMING_Y)
   #define CHOPPER_TIMING_Y CHOPPER_TIMING
 #endif
 #if HAS_Z_AXIS && !defined(CHOPPER_TIMING_Z)
   #define CHOPPER_TIMING_Z CHOPPER_TIMING
 #endif
 #if LINEAR_AXES >= 4 && !defined(CHOPPER_TIMING_I)

commit b88117d6364b8919a8a7df6c80d8132af98a6afc
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Sep 21 06:25:13 2021 -0500

    üé® Fix L64xx enable, clean up conditionals

diff --git a/Marlin/src/module/stepper/trinamic.h b/Marlin/src/module/stepper/trinamic.h
index 7957a1b353..0a956a70b3 100644
--- a/Marlin/src/module/stepper/trinamic.h
+++ b/Marlin/src/module/stepper/trinamic.h
@@ -187,21 +187,21 @@ void reset_trinamic_drivers();
   #endif
 #endif
 
 // Z2 Stepper
 #if HAS_Z2_ENABLE && AXIS_IS_TMC(Z2)
   extern TMC_CLASS(Z2, Z) stepperZ2;
   #ifndef CHOPPER_TIMING_Z2
     #define CHOPPER_TIMING_Z2 CHOPPER_TIMING_Z
   #endif
   static constexpr chopper_timing_t chopper_timing_Z2 = CHOPPER_TIMING_Z2;
-  #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(Z2)
+  #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define Z2_ENABLE_INIT() NOOP
     #define Z2_ENABLE_WRITE(STATE) stepperZ2.toff((STATE)==Z_ENABLE_ON ? chopper_timing_Z2.toff : 0)
     #define Z2_ENABLE_READ() stepperZ2.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(Z2)
     #define Z2_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(Z2_STEP_PIN); }while(0)
   #endif
 #endif
 
 // Z3 Stepper
@@ -280,138 +280,138 @@ void reset_trinamic_drivers();
   #endif
 #endif
 
 // E0 Stepper
 #if AXIS_IS_TMC(E0)
   extern TMC_CLASS_E(0) stepperE0;
   #ifndef CHOPPER_TIMING_E0
     #define CHOPPER_TIMING_E0 CHOPPER_TIMING_E
   #endif
   static constexpr chopper_timing_t chopper_timing_E0 = CHOPPER_TIMING_E0;
-  #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E0)
+  #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define E0_ENABLE_INIT() NOOP
     #define E0_ENABLE_WRITE(STATE) stepperE0.toff((STATE)==E_ENABLE_ON ? chopper_timing_E0.toff : 0)
     #define E0_ENABLE_READ() stepperE0.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(E0)
     #define E0_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(E0_STEP_PIN); }while(0)
   #endif
 #endif
 
 // E1 Stepper
 #if AXIS_IS_TMC(E1)
   extern TMC_CLASS_E(1) stepperE1;
   #ifndef CHOPPER_TIMING_E1
     #define CHOPPER_TIMING_E1 CHOPPER_TIMING_E
   #endif
   static constexpr chopper_timing_t chopper_timing_E1 = CHOPPER_TIMING_E1;
-  #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E1)
+  #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define E1_ENABLE_INIT() NOOP
     #define E1_ENABLE_WRITE(STATE) stepperE1.toff((STATE)==E_ENABLE_ON ? chopper_timing_E1.toff : 0)
     #define E1_ENABLE_READ() stepperE1.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(E1)
     #define E1_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(E1_STEP_PIN); }while(0)
   #endif
 #endif
 
 // E2 Stepper
 #if AXIS_IS_TMC(E2)
   extern TMC_CLASS_E(2) stepperE2;
   #ifndef CHOPPER_TIMING_E2
     #define CHOPPER_TIMING_E2 CHOPPER_TIMING_E
   #endif
   static constexpr chopper_timing_t chopper_timing_E2 = CHOPPER_TIMING_E2;
-  #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E2)
+  #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define E2_ENABLE_INIT() NOOP
     #define E2_ENABLE_WRITE(STATE) stepperE2.toff((STATE)==E_ENABLE_ON ? chopper_timing_E2.toff : 0)
     #define E2_ENABLE_READ() stepperE2.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(E2)
     #define E2_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(E2_STEP_PIN); }while(0)
   #endif
 #endif
 
 // E3 Stepper
 #if AXIS_IS_TMC(E3)
   extern TMC_CLASS_E(3) stepperE3;
   #ifndef CHOPPER_TIMING_E3
     #define CHOPPER_TIMING_E3 CHOPPER_TIMING_E
   #endif
   static constexpr chopper_timing_t chopper_timing_E3 = CHOPPER_TIMING_E3;
-  #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E3)
+  #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define E3_ENABLE_INIT() NOOP
     #define E3_ENABLE_WRITE(STATE) stepperE3.toff((STATE)==E_ENABLE_ON ? chopper_timing_E3.toff : 0)
     #define E3_ENABLE_READ() stepperE3.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(E3)
     #define E3_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(E3_STEP_PIN); }while(0)
   #endif
 #endif
 
 // E4 Stepper
 #if AXIS_IS_TMC(E4)
   extern TMC_CLASS_E(4) stepperE4;
   #ifndef CHOPPER_TIMING_E4
     #define CHOPPER_TIMING_E4 CHOPPER_TIMING_E
   #endif
   static constexpr chopper_timing_t chopper_timing_E4 = CHOPPER_TIMING_E4;
-  #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E4)
+  #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define E4_ENABLE_INIT() NOOP
     #define E4_ENABLE_WRITE(STATE) stepperE4.toff((STATE)==E_ENABLE_ON ? chopper_timing_E4.toff : 0)
     #define E4_ENABLE_READ() stepperE4.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(E4)
     #define E4_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(E4_STEP_PIN); }while(0)
   #endif
 #endif
 
 // E5 Stepper
 #if AXIS_IS_TMC(E5)
   extern TMC_CLASS_E(5) stepperE5;
   #ifndef CHOPPER_TIMING_E5
     #define CHOPPER_TIMING_E5 CHOPPER_TIMING_E
   #endif
   static constexpr chopper_timing_t chopper_timing_E5 = CHOPPER_TIMING_E5;
-  #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E5)
+  #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define E5_ENABLE_INIT() NOOP
     #define E5_ENABLE_WRITE(STATE) stepperE5.toff((STATE)==E_ENABLE_ON ? chopper_timing_E5.toff : 0)
     #define E5_ENABLE_READ() stepperE5.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(E5)
     #define E5_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(E5_STEP_PIN); }while(0)
   #endif
 #endif
 
 // E6 Stepper
 #if AXIS_IS_TMC(E6)
   extern TMC_CLASS_E(6) stepperE6;
   #ifndef CHOPPER_TIMING_E6
     #define CHOPPER_TIMING_E6 CHOPPER_TIMING_E
   #endif
   static constexpr chopper_timing_t chopper_timing_E6 = CHOPPER_TIMING_E6;
-  #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E6)
+  #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define E6_ENABLE_INIT() NOOP
     #define E6_ENABLE_WRITE(STATE) stepperE6.toff((STATE)==E_ENABLE_ON ? chopper_timing_E6.toff : 0)
     #define E6_ENABLE_READ() stepperE6.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(E6)
     #define E6_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(E6_STEP_PIN); }while(0)
   #endif
 #endif
 
 // E7 Stepper
 #if AXIS_IS_TMC(E7)
   extern TMC_CLASS_E(7) stepperE7;
   #ifndef CHOPPER_TIMING_E7
     #define CHOPPER_TIMING_E7 CHOPPER_TIMING_E
   #endif
   static constexpr chopper_timing_t chopper_timing_E7 = CHOPPER_TIMING_E7;
-  #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E7)
+  #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define E7_ENABLE_INIT() NOOP
     #define E7_ENABLE_WRITE(STATE) stepperE7.toff((STATE)==E_ENABLE_ON ? chopper_timing_E7.toff : 0)
     #define E7_ENABLE_READ() stepperE7.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(E7)
     #define E7_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(E7_STEP_PIN); }while(0)
   #endif
 #endif

commit 536cf287a6f642aa3eccd290b421b0e3869f018a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Aug 21 18:00:55 2021 -0500

    üé® Misc code and spacing cleanup

diff --git a/Marlin/src/module/stepper/trinamic.h b/Marlin/src/module/stepper/trinamic.h
index 766f8fced2..7957a1b353 100644
--- a/Marlin/src/module/stepper/trinamic.h
+++ b/Marlin/src/module/stepper/trinamic.h
@@ -114,21 +114,21 @@ void reset_trinamic_drivers();
 // X Stepper
 #if AXIS_IS_TMC(X)
   extern TMC_CLASS(X, X) stepperX;
   static constexpr chopper_timing_t chopper_timing_X = CHOPPER_TIMING_X;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define X_ENABLE_INIT() NOOP
     #define X_ENABLE_WRITE(STATE) stepperX.toff((STATE)==X_ENABLE_ON ? chopper_timing_X.toff : 0)
     #define X_ENABLE_READ() stepperX.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(X)
-    #define X_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(X_STEP_PIN); }while(0)
+    #define X_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(X_STEP_PIN); }while(0)
   #endif
 #endif
 
 // Y Stepper
 #if AXIS_IS_TMC(Y)
   extern TMC_CLASS(Y, Y) stepperY;
   static constexpr chopper_timing_t chopper_timing_Y = CHOPPER_TIMING_Y;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define Y_ENABLE_INIT() NOOP
     #define Y_ENABLE_WRITE(STATE) stepperY.toff((STATE)==Y_ENABLE_ON ? chopper_timing_Y.toff : 0)
@@ -142,106 +142,106 @@ void reset_trinamic_drivers();
 // Z Stepper
 #if AXIS_IS_TMC(Z)
   extern TMC_CLASS(Z, Z) stepperZ;
   static constexpr chopper_timing_t chopper_timing_Z = CHOPPER_TIMING_Z;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define Z_ENABLE_INIT() NOOP
     #define Z_ENABLE_WRITE(STATE) stepperZ.toff((STATE)==Z_ENABLE_ON ? chopper_timing_Z.toff : 0)
     #define Z_ENABLE_READ() stepperZ.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(Z)
-    #define Z_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(Z_STEP_PIN); }while(0)
+    #define Z_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(Z_STEP_PIN); }while(0)
   #endif
 #endif
 
 // X2 Stepper
 #if HAS_X2_ENABLE && AXIS_IS_TMC(X2)
   extern TMC_CLASS(X2, X) stepperX2;
   #ifndef CHOPPER_TIMING_X2
     #define CHOPPER_TIMING_X2 CHOPPER_TIMING_X
   #endif
   static constexpr chopper_timing_t chopper_timing_X2 = CHOPPER_TIMING_X2;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define X2_ENABLE_INIT() NOOP
     #define X2_ENABLE_WRITE(STATE) stepperX2.toff((STATE)==X_ENABLE_ON ? chopper_timing_X2.toff : 0)
     #define X2_ENABLE_READ() stepperX2.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(X2)
-    #define X2_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(X2_STEP_PIN); }while(0)
+    #define X2_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(X2_STEP_PIN); }while(0)
   #endif
 #endif
 
 // Y2 Stepper
 #if HAS_Y2_ENABLE && AXIS_IS_TMC(Y2)
   extern TMC_CLASS(Y2, Y) stepperY2;
   #ifndef CHOPPER_TIMING_Y2
     #define CHOPPER_TIMING_Y2 CHOPPER_TIMING_Y
   #endif
   static constexpr chopper_timing_t chopper_timing_Y2 = CHOPPER_TIMING_Y2;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define Y2_ENABLE_INIT() NOOP
     #define Y2_ENABLE_WRITE(STATE) stepperY2.toff((STATE)==Y_ENABLE_ON ? chopper_timing_Y2.toff : 0)
     #define Y2_ENABLE_READ() stepperY2.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(Y2)
-    #define Y2_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(Y2_STEP_PIN); }while(0)
+    #define Y2_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(Y2_STEP_PIN); }while(0)
   #endif
 #endif
 
 // Z2 Stepper
 #if HAS_Z2_ENABLE && AXIS_IS_TMC(Z2)
   extern TMC_CLASS(Z2, Z) stepperZ2;
   #ifndef CHOPPER_TIMING_Z2
     #define CHOPPER_TIMING_Z2 CHOPPER_TIMING_Z
   #endif
   static constexpr chopper_timing_t chopper_timing_Z2 = CHOPPER_TIMING_Z2;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(Z2)
     #define Z2_ENABLE_INIT() NOOP
     #define Z2_ENABLE_WRITE(STATE) stepperZ2.toff((STATE)==Z_ENABLE_ON ? chopper_timing_Z2.toff : 0)
     #define Z2_ENABLE_READ() stepperZ2.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(Z2)
-    #define Z2_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(Z2_STEP_PIN); }while(0)
+    #define Z2_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(Z2_STEP_PIN); }while(0)
   #endif
 #endif
 
 // Z3 Stepper
 #if HAS_Z3_ENABLE && AXIS_IS_TMC(Z3)
   extern TMC_CLASS(Z3, Z) stepperZ3;
   #ifndef CHOPPER_TIMING_Z3
     #define CHOPPER_TIMING_Z3 CHOPPER_TIMING_Z
   #endif
   static constexpr chopper_timing_t chopper_timing_Z3 = CHOPPER_TIMING_Z3;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define Z3_ENABLE_INIT() NOOP
     #define Z3_ENABLE_WRITE(STATE) stepperZ3.toff((STATE)==Z_ENABLE_ON ? chopper_timing_Z3.toff : 0)
     #define Z3_ENABLE_READ() stepperZ3.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(Z3)
-    #define Z3_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(Z3_STEP_PIN); }while(0)
+    #define Z3_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(Z3_STEP_PIN); }while(0)
   #endif
 #endif
 
 // Z4 Stepper
 #if HAS_Z4_ENABLE && AXIS_IS_TMC(Z4)
   extern TMC_CLASS(Z4, Z) stepperZ4;
   #ifndef CHOPPER_TIMING_Z4
     #define CHOPPER_TIMING_Z4 CHOPPER_TIMING_Z
   #endif
   static constexpr chopper_timing_t chopper_timing_Z4 = CHOPPER_TIMING_Z4;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define Z4_ENABLE_INIT() NOOP
     #define Z4_ENABLE_WRITE(STATE) stepperZ4.toff((STATE)==Z_ENABLE_ON ? chopper_timing_Z4.toff : 0)
     #define Z4_ENABLE_READ() stepperZ4.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(Z4)
-    #define Z4_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(Z4_STEP_PIN); }while(0)
+    #define Z4_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(Z4_STEP_PIN); }while(0)
   #endif
 #endif
 
 // I Stepper
 #if AXIS_IS_TMC(I)
   extern TMC_CLASS(I, I) stepperI;
   static constexpr chopper_timing_t chopper_timing_I = CHOPPER_TIMING_I;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define I_ENABLE_INIT() NOOP
     #define I_ENABLE_WRITE(STATE) stepperI.toff((STATE)==I_ENABLE_ON ? chopper_timing.toff : 0)
@@ -286,132 +286,132 @@ void reset_trinamic_drivers();
   #ifndef CHOPPER_TIMING_E0
     #define CHOPPER_TIMING_E0 CHOPPER_TIMING_E
   #endif
   static constexpr chopper_timing_t chopper_timing_E0 = CHOPPER_TIMING_E0;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E0)
     #define E0_ENABLE_INIT() NOOP
     #define E0_ENABLE_WRITE(STATE) stepperE0.toff((STATE)==E_ENABLE_ON ? chopper_timing_E0.toff : 0)
     #define E0_ENABLE_READ() stepperE0.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(E0)
-    #define E0_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(E0_STEP_PIN); }while(0)
+    #define E0_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(E0_STEP_PIN); }while(0)
   #endif
 #endif
 
 // E1 Stepper
 #if AXIS_IS_TMC(E1)
   extern TMC_CLASS_E(1) stepperE1;
   #ifndef CHOPPER_TIMING_E1
     #define CHOPPER_TIMING_E1 CHOPPER_TIMING_E
   #endif
   static constexpr chopper_timing_t chopper_timing_E1 = CHOPPER_TIMING_E1;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E1)
     #define E1_ENABLE_INIT() NOOP
     #define E1_ENABLE_WRITE(STATE) stepperE1.toff((STATE)==E_ENABLE_ON ? chopper_timing_E1.toff : 0)
     #define E1_ENABLE_READ() stepperE1.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(E1)
-    #define E1_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(E1_STEP_PIN); }while(0)
+    #define E1_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(E1_STEP_PIN); }while(0)
   #endif
 #endif
 
 // E2 Stepper
 #if AXIS_IS_TMC(E2)
   extern TMC_CLASS_E(2) stepperE2;
   #ifndef CHOPPER_TIMING_E2
     #define CHOPPER_TIMING_E2 CHOPPER_TIMING_E
   #endif
   static constexpr chopper_timing_t chopper_timing_E2 = CHOPPER_TIMING_E2;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E2)
     #define E2_ENABLE_INIT() NOOP
     #define E2_ENABLE_WRITE(STATE) stepperE2.toff((STATE)==E_ENABLE_ON ? chopper_timing_E2.toff : 0)
     #define E2_ENABLE_READ() stepperE2.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(E2)
-    #define E2_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(E2_STEP_PIN); }while(0)
+    #define E2_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(E2_STEP_PIN); }while(0)
   #endif
 #endif
 
 // E3 Stepper
 #if AXIS_IS_TMC(E3)
   extern TMC_CLASS_E(3) stepperE3;
   #ifndef CHOPPER_TIMING_E3
     #define CHOPPER_TIMING_E3 CHOPPER_TIMING_E
   #endif
   static constexpr chopper_timing_t chopper_timing_E3 = CHOPPER_TIMING_E3;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E3)
     #define E3_ENABLE_INIT() NOOP
     #define E3_ENABLE_WRITE(STATE) stepperE3.toff((STATE)==E_ENABLE_ON ? chopper_timing_E3.toff : 0)
     #define E3_ENABLE_READ() stepperE3.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(E3)
-    #define E3_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(E3_STEP_PIN); }while(0)
+    #define E3_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(E3_STEP_PIN); }while(0)
   #endif
 #endif
 
 // E4 Stepper
 #if AXIS_IS_TMC(E4)
   extern TMC_CLASS_E(4) stepperE4;
   #ifndef CHOPPER_TIMING_E4
     #define CHOPPER_TIMING_E4 CHOPPER_TIMING_E
   #endif
   static constexpr chopper_timing_t chopper_timing_E4 = CHOPPER_TIMING_E4;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E4)
     #define E4_ENABLE_INIT() NOOP
     #define E4_ENABLE_WRITE(STATE) stepperE4.toff((STATE)==E_ENABLE_ON ? chopper_timing_E4.toff : 0)
     #define E4_ENABLE_READ() stepperE4.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(E4)
-    #define E4_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(E4_STEP_PIN); }while(0)
+    #define E4_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(E4_STEP_PIN); }while(0)
   #endif
 #endif
 
 // E5 Stepper
 #if AXIS_IS_TMC(E5)
   extern TMC_CLASS_E(5) stepperE5;
   #ifndef CHOPPER_TIMING_E5
     #define CHOPPER_TIMING_E5 CHOPPER_TIMING_E
   #endif
   static constexpr chopper_timing_t chopper_timing_E5 = CHOPPER_TIMING_E5;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E5)
     #define E5_ENABLE_INIT() NOOP
     #define E5_ENABLE_WRITE(STATE) stepperE5.toff((STATE)==E_ENABLE_ON ? chopper_timing_E5.toff : 0)
     #define E5_ENABLE_READ() stepperE5.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(E5)
-    #define E5_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(E5_STEP_PIN); }while(0)
+    #define E5_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(E5_STEP_PIN); }while(0)
   #endif
 #endif
 
 // E6 Stepper
 #if AXIS_IS_TMC(E6)
   extern TMC_CLASS_E(6) stepperE6;
   #ifndef CHOPPER_TIMING_E6
     #define CHOPPER_TIMING_E6 CHOPPER_TIMING_E
   #endif
   static constexpr chopper_timing_t chopper_timing_E6 = CHOPPER_TIMING_E6;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E6)
     #define E6_ENABLE_INIT() NOOP
     #define E6_ENABLE_WRITE(STATE) stepperE6.toff((STATE)==E_ENABLE_ON ? chopper_timing_E6.toff : 0)
     #define E6_ENABLE_READ() stepperE6.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(E6)
-    #define E6_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(E6_STEP_PIN); }while(0)
+    #define E6_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(E6_STEP_PIN); }while(0)
   #endif
 #endif
 
 // E7 Stepper
 #if AXIS_IS_TMC(E7)
   extern TMC_CLASS_E(7) stepperE7;
   #ifndef CHOPPER_TIMING_E7
     #define CHOPPER_TIMING_E7 CHOPPER_TIMING_E
   #endif
   static constexpr chopper_timing_t chopper_timing_E7 = CHOPPER_TIMING_E7;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E7)
     #define E7_ENABLE_INIT() NOOP
     #define E7_ENABLE_WRITE(STATE) stepperE7.toff((STATE)==E_ENABLE_ON ? chopper_timing_E7.toff : 0)
     #define E7_ENABLE_READ() stepperE7.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(E7)
-    #define E7_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(E7_STEP_PIN); }while(0)
+    #define E7_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(E7_STEP_PIN); }while(0)
   #endif
 #endif

commit 7726af9c5348c1c7d0fd9a56eca87d00cd75fee6
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Sat Jun 5 09:18:47 2021 +0200

    üèóÔ∏è Support for up to 6 linear axes (#19112)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/stepper/trinamic.h b/Marlin/src/module/stepper/trinamic.h
index 9f7445e4fd..766f8fced2 100644
--- a/Marlin/src/module/stepper/trinamic.h
+++ b/Marlin/src/module/stepper/trinamic.h
@@ -39,20 +39,24 @@
 #define CLASS_TMC2208 TMC2208Stepper
 #define CLASS_TMC2209 TMC2209Stepper
 #define CLASS_TMC2660 TMC2660Stepper
 #define CLASS_TMC5130 TMC5130Stepper
 #define CLASS_TMC5160 TMC5160Stepper
 
 #define TMC_X_LABEL 'X', '0'
 #define TMC_Y_LABEL 'Y', '0'
 #define TMC_Z_LABEL 'Z', '0'
 
+#define TMC_I_LABEL 'I', '0'
+#define TMC_J_LABEL 'J', '0'
+#define TMC_K_LABEL 'K', '0'
+
 #define TMC_X2_LABEL 'X', '2'
 #define TMC_Y2_LABEL 'Y', '2'
 #define TMC_Z2_LABEL 'Z', '2'
 #define TMC_Z3_LABEL 'Z', '3'
 #define TMC_Z4_LABEL 'Z', '4'
 
 #define TMC_E0_LABEL 'E', '0'
 #define TMC_E1_LABEL 'E', '1'
 #define TMC_E2_LABEL 'E', '2'
 #define TMC_E3_LABEL 'E', '3'
@@ -72,27 +76,36 @@
 
 typedef struct {
   uint8_t toff;
   int8_t hend;
   uint8_t hstrt;
 } chopper_timing_t;
 
 #ifndef CHOPPER_TIMING_X
   #define CHOPPER_TIMING_X CHOPPER_TIMING
 #endif
-#ifndef CHOPPER_TIMING_Y
+#if HAS_Y_AXIS && !defined(CHOPPER_TIMING_Y)
   #define CHOPPER_TIMING_Y CHOPPER_TIMING
 #endif
-#ifndef CHOPPER_TIMING_Z
+#if HAS_Z_AXIS && !defined(CHOPPER_TIMING_Z)
   #define CHOPPER_TIMING_Z CHOPPER_TIMING
 #endif
-#ifndef CHOPPER_TIMING_E
+#if LINEAR_AXES >= 4 && !defined(CHOPPER_TIMING_I)
+  #define CHOPPER_TIMING_I CHOPPER_TIMING
+#endif
+#if LINEAR_AXES >= 5 && !defined(CHOPPER_TIMING_J)
+  #define CHOPPER_TIMING_J CHOPPER_TIMING
+#endif
+#if LINEAR_AXES >= 6 && !defined(CHOPPER_TIMING_K)
+  #define CHOPPER_TIMING_K CHOPPER_TIMING
+#endif
+#if HAS_EXTRUDERS && !defined(CHOPPER_TIMING_E)
   #define CHOPPER_TIMING_E CHOPPER_TIMING
 #endif
 
 #if HAS_TMC220x
   void tmc_serial_begin();
 #endif
 
 void restore_trinamic_drivers();
 void reset_trinamic_drivers();
 
@@ -218,20 +231,62 @@ void reset_trinamic_drivers();
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define Z4_ENABLE_INIT() NOOP
     #define Z4_ENABLE_WRITE(STATE) stepperZ4.toff((STATE)==Z_ENABLE_ON ? chopper_timing_Z4.toff : 0)
     #define Z4_ENABLE_READ() stepperZ4.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(Z4)
     #define Z4_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(Z4_STEP_PIN); }while(0)
   #endif
 #endif
 
+// I Stepper
+#if AXIS_IS_TMC(I)
+  extern TMC_CLASS(I, I) stepperI;
+  static constexpr chopper_timing_t chopper_timing_I = CHOPPER_TIMING_I;
+  #if ENABLED(SOFTWARE_DRIVER_ENABLE)
+    #define I_ENABLE_INIT() NOOP
+    #define I_ENABLE_WRITE(STATE) stepperI.toff((STATE)==I_ENABLE_ON ? chopper_timing.toff : 0)
+    #define I_ENABLE_READ() stepperI.isEnabled()
+  #endif
+  #if AXIS_HAS_SQUARE_WAVE(I)
+    #define I_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(I_STEP_PIN); }while(0)
+  #endif
+#endif
+
+// J Stepper
+#if AXIS_IS_TMC(J)
+  extern TMC_CLASS(J, J) stepperJ;
+  static constexpr chopper_timing_t chopper_timing_J = CHOPPER_TIMING_J;
+  #if ENABLED(SOFTWARE_DRIVER_ENABLE)
+    #define J_ENABLE_INIT() NOOP
+    #define J_ENABLE_WRITE(STATE) stepperJ.toff((STATE)==J_ENABLE_ON ? chopper_timing.toff : 0)
+    #define J_ENABLE_READ() stepperJ.isEnabled()
+  #endif
+  #if AXIS_HAS_SQUARE_WAVE(J)
+    #define J_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(J_STEP_PIN); }while(0)
+  #endif
+#endif
+
+// K Stepper
+#if AXIS_IS_TMC(K)
+  extern TMC_CLASS(K, K) stepperK;
+  static constexpr chopper_timing_t chopper_timing_K = CHOPPER_TIMING_K;
+  #if ENABLED(SOFTWARE_DRIVER_ENABLE)
+    #define K_ENABLE_INIT() NOOP
+    #define K_ENABLE_WRITE(STATE) stepperK.toff((STATE)==K_ENABLE_ON ? chopper_timing.toff : 0)
+    #define K_ENABLE_READ() stepperK.isEnabled()
+  #endif
+  #if AXIS_HAS_SQUARE_WAVE(K)
+    #define K_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(K_STEP_PIN); }while(0)
+  #endif
+#endif
+
 // E0 Stepper
 #if AXIS_IS_TMC(E0)
   extern TMC_CLASS_E(0) stepperE0;
   #ifndef CHOPPER_TIMING_E0
     #define CHOPPER_TIMING_E0 CHOPPER_TIMING_E
   #endif
   static constexpr chopper_timing_t chopper_timing_E0 = CHOPPER_TIMING_E0;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E0)
     #define E0_ENABLE_INIT() NOOP
     #define E0_ENABLE_WRITE(STATE) stepperE0.toff((STATE)==E_ENABLE_ON ? chopper_timing_E0.toff : 0)

commit c7f7f2403d3123d360badd4353cb385b38c16095
Author: qwewer0 <57561110+qwewer0@users.noreply.github.com>
Date:   Fri Oct 23 03:46:48 2020 +0200

    Fix Chopper Timing extra axis defaults (#19850)

diff --git a/Marlin/src/module/stepper/trinamic.h b/Marlin/src/module/stepper/trinamic.h
index 7ae2a276db..9f7445e4fd 100644
--- a/Marlin/src/module/stepper/trinamic.h
+++ b/Marlin/src/module/stepper/trinamic.h
@@ -137,89 +137,89 @@ void reset_trinamic_drivers();
   #endif
   #if AXIS_HAS_SQUARE_WAVE(Z)
     #define Z_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(Z_STEP_PIN); }while(0)
   #endif
 #endif
 
 // X2 Stepper
 #if HAS_X2_ENABLE && AXIS_IS_TMC(X2)
   extern TMC_CLASS(X2, X) stepperX2;
   #ifndef CHOPPER_TIMING_X2
-    #define CHOPPER_TIMING_X2 CHOPPER_TIMING_E
+    #define CHOPPER_TIMING_X2 CHOPPER_TIMING_X
   #endif
   static constexpr chopper_timing_t chopper_timing_X2 = CHOPPER_TIMING_X2;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define X2_ENABLE_INIT() NOOP
     #define X2_ENABLE_WRITE(STATE) stepperX2.toff((STATE)==X_ENABLE_ON ? chopper_timing_X2.toff : 0)
     #define X2_ENABLE_READ() stepperX2.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(X2)
     #define X2_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(X2_STEP_PIN); }while(0)
   #endif
 #endif
 
 // Y2 Stepper
 #if HAS_Y2_ENABLE && AXIS_IS_TMC(Y2)
   extern TMC_CLASS(Y2, Y) stepperY2;
   #ifndef CHOPPER_TIMING_Y2
-    #define CHOPPER_TIMING_Y2 CHOPPER_TIMING_E
+    #define CHOPPER_TIMING_Y2 CHOPPER_TIMING_Y
   #endif
   static constexpr chopper_timing_t chopper_timing_Y2 = CHOPPER_TIMING_Y2;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define Y2_ENABLE_INIT() NOOP
     #define Y2_ENABLE_WRITE(STATE) stepperY2.toff((STATE)==Y_ENABLE_ON ? chopper_timing_Y2.toff : 0)
     #define Y2_ENABLE_READ() stepperY2.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(Y2)
     #define Y2_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(Y2_STEP_PIN); }while(0)
   #endif
 #endif
 
 // Z2 Stepper
 #if HAS_Z2_ENABLE && AXIS_IS_TMC(Z2)
   extern TMC_CLASS(Z2, Z) stepperZ2;
   #ifndef CHOPPER_TIMING_Z2
-    #define CHOPPER_TIMING_Z2 CHOPPER_TIMING_E
+    #define CHOPPER_TIMING_Z2 CHOPPER_TIMING_Z
   #endif
   static constexpr chopper_timing_t chopper_timing_Z2 = CHOPPER_TIMING_Z2;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(Z2)
     #define Z2_ENABLE_INIT() NOOP
     #define Z2_ENABLE_WRITE(STATE) stepperZ2.toff((STATE)==Z_ENABLE_ON ? chopper_timing_Z2.toff : 0)
     #define Z2_ENABLE_READ() stepperZ2.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(Z2)
     #define Z2_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(Z2_STEP_PIN); }while(0)
   #endif
 #endif
 
 // Z3 Stepper
 #if HAS_Z3_ENABLE && AXIS_IS_TMC(Z3)
   extern TMC_CLASS(Z3, Z) stepperZ3;
   #ifndef CHOPPER_TIMING_Z3
-    #define CHOPPER_TIMING_Z3 CHOPPER_TIMING_E
+    #define CHOPPER_TIMING_Z3 CHOPPER_TIMING_Z
   #endif
   static constexpr chopper_timing_t chopper_timing_Z3 = CHOPPER_TIMING_Z3;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define Z3_ENABLE_INIT() NOOP
     #define Z3_ENABLE_WRITE(STATE) stepperZ3.toff((STATE)==Z_ENABLE_ON ? chopper_timing_Z3.toff : 0)
     #define Z3_ENABLE_READ() stepperZ3.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(Z3)
     #define Z3_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(Z3_STEP_PIN); }while(0)
   #endif
 #endif
 
 // Z4 Stepper
 #if HAS_Z4_ENABLE && AXIS_IS_TMC(Z4)
   extern TMC_CLASS(Z4, Z) stepperZ4;
   #ifndef CHOPPER_TIMING_Z4
-    #define CHOPPER_TIMING_Z4 CHOPPER_TIMING_E
+    #define CHOPPER_TIMING_Z4 CHOPPER_TIMING_Z
   #endif
   static constexpr chopper_timing_t chopper_timing_Z4 = CHOPPER_TIMING_Z4;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define Z4_ENABLE_INIT() NOOP
     #define Z4_ENABLE_WRITE(STATE) stepperZ4.toff((STATE)==Z_ENABLE_ON ? chopper_timing_Z4.toff : 0)
     #define Z4_ENABLE_READ() stepperZ4.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(Z4)
     #define Z4_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(Z4_STEP_PIN); }while(0)
   #endif

commit c2802d35bb1bcfc20785b0ccf255697b9c08c775
Author: Jago Strong-Wright <jagoosw@protonmail.com>
Date:   Sun Oct 18 04:35:19 2020 +0100

    Distinct Chopper Timing settings (#19781)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/stepper/trinamic.h b/Marlin/src/module/stepper/trinamic.h
index 9cc3404cd2..7ae2a276db 100644
--- a/Marlin/src/module/stepper/trinamic.h
+++ b/Marlin/src/module/stepper/trinamic.h
@@ -69,228 +69,294 @@
 #else
   #define TMC_CLASS_E(N) TMC_CLASS(E##N, E)
 #endif
 
 typedef struct {
   uint8_t toff;
   int8_t hend;
   uint8_t hstrt;
 } chopper_timing_t;
 
-static constexpr chopper_timing_t chopper_timing = CHOPPER_TIMING;
+#ifndef CHOPPER_TIMING_X
+  #define CHOPPER_TIMING_X CHOPPER_TIMING
+#endif
+#ifndef CHOPPER_TIMING_Y
+  #define CHOPPER_TIMING_Y CHOPPER_TIMING
+#endif
+#ifndef CHOPPER_TIMING_Z
+  #define CHOPPER_TIMING_Z CHOPPER_TIMING
+#endif
+#ifndef CHOPPER_TIMING_E
+  #define CHOPPER_TIMING_E CHOPPER_TIMING
+#endif
 
 #if HAS_TMC220x
   void tmc_serial_begin();
 #endif
 
 void restore_trinamic_drivers();
 void reset_trinamic_drivers();
 
 #define AXIS_HAS_SQUARE_WAVE(A) (AXIS_IS_TMC(A) && ENABLED(SQUARE_WAVE_STEPPING))
 
 // X Stepper
 #if AXIS_IS_TMC(X)
   extern TMC_CLASS(X, X) stepperX;
+  static constexpr chopper_timing_t chopper_timing_X = CHOPPER_TIMING_X;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define X_ENABLE_INIT() NOOP
-    #define X_ENABLE_WRITE(STATE) stepperX.toff((STATE)==X_ENABLE_ON ? chopper_timing.toff : 0)
+    #define X_ENABLE_WRITE(STATE) stepperX.toff((STATE)==X_ENABLE_ON ? chopper_timing_X.toff : 0)
     #define X_ENABLE_READ() stepperX.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(X)
     #define X_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(X_STEP_PIN); }while(0)
   #endif
 #endif
 
 // Y Stepper
 #if AXIS_IS_TMC(Y)
   extern TMC_CLASS(Y, Y) stepperY;
+  static constexpr chopper_timing_t chopper_timing_Y = CHOPPER_TIMING_Y;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define Y_ENABLE_INIT() NOOP
-    #define Y_ENABLE_WRITE(STATE) stepperY.toff((STATE)==Y_ENABLE_ON ? chopper_timing.toff : 0)
+    #define Y_ENABLE_WRITE(STATE) stepperY.toff((STATE)==Y_ENABLE_ON ? chopper_timing_Y.toff : 0)
     #define Y_ENABLE_READ() stepperY.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(Y)
     #define Y_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(Y_STEP_PIN); }while(0)
   #endif
 #endif
 
 // Z Stepper
 #if AXIS_IS_TMC(Z)
   extern TMC_CLASS(Z, Z) stepperZ;
+  static constexpr chopper_timing_t chopper_timing_Z = CHOPPER_TIMING_Z;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define Z_ENABLE_INIT() NOOP
-    #define Z_ENABLE_WRITE(STATE) stepperZ.toff((STATE)==Z_ENABLE_ON ? chopper_timing.toff : 0)
+    #define Z_ENABLE_WRITE(STATE) stepperZ.toff((STATE)==Z_ENABLE_ON ? chopper_timing_Z.toff : 0)
     #define Z_ENABLE_READ() stepperZ.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(Z)
     #define Z_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(Z_STEP_PIN); }while(0)
   #endif
 #endif
 
 // X2 Stepper
 #if HAS_X2_ENABLE && AXIS_IS_TMC(X2)
   extern TMC_CLASS(X2, X) stepperX2;
+  #ifndef CHOPPER_TIMING_X2
+    #define CHOPPER_TIMING_X2 CHOPPER_TIMING_E
+  #endif
+  static constexpr chopper_timing_t chopper_timing_X2 = CHOPPER_TIMING_X2;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define X2_ENABLE_INIT() NOOP
-    #define X2_ENABLE_WRITE(STATE) stepperX2.toff((STATE)==X_ENABLE_ON ? chopper_timing.toff : 0)
+    #define X2_ENABLE_WRITE(STATE) stepperX2.toff((STATE)==X_ENABLE_ON ? chopper_timing_X2.toff : 0)
     #define X2_ENABLE_READ() stepperX2.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(X2)
     #define X2_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(X2_STEP_PIN); }while(0)
   #endif
 #endif
 
 // Y2 Stepper
 #if HAS_Y2_ENABLE && AXIS_IS_TMC(Y2)
   extern TMC_CLASS(Y2, Y) stepperY2;
+  #ifndef CHOPPER_TIMING_Y2
+    #define CHOPPER_TIMING_Y2 CHOPPER_TIMING_E
+  #endif
+  static constexpr chopper_timing_t chopper_timing_Y2 = CHOPPER_TIMING_Y2;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define Y2_ENABLE_INIT() NOOP
-    #define Y2_ENABLE_WRITE(STATE) stepperY2.toff((STATE)==Y_ENABLE_ON ? chopper_timing.toff : 0)
+    #define Y2_ENABLE_WRITE(STATE) stepperY2.toff((STATE)==Y_ENABLE_ON ? chopper_timing_Y2.toff : 0)
     #define Y2_ENABLE_READ() stepperY2.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(Y2)
     #define Y2_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(Y2_STEP_PIN); }while(0)
   #endif
 #endif
 
 // Z2 Stepper
 #if HAS_Z2_ENABLE && AXIS_IS_TMC(Z2)
   extern TMC_CLASS(Z2, Z) stepperZ2;
+  #ifndef CHOPPER_TIMING_Z2
+    #define CHOPPER_TIMING_Z2 CHOPPER_TIMING_E
+  #endif
+  static constexpr chopper_timing_t chopper_timing_Z2 = CHOPPER_TIMING_Z2;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(Z2)
     #define Z2_ENABLE_INIT() NOOP
-    #define Z2_ENABLE_WRITE(STATE) stepperZ2.toff((STATE)==Z_ENABLE_ON ? chopper_timing.toff : 0)
+    #define Z2_ENABLE_WRITE(STATE) stepperZ2.toff((STATE)==Z_ENABLE_ON ? chopper_timing_Z2.toff : 0)
     #define Z2_ENABLE_READ() stepperZ2.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(Z2)
     #define Z2_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(Z2_STEP_PIN); }while(0)
   #endif
 #endif
 
 // Z3 Stepper
 #if HAS_Z3_ENABLE && AXIS_IS_TMC(Z3)
   extern TMC_CLASS(Z3, Z) stepperZ3;
+  #ifndef CHOPPER_TIMING_Z3
+    #define CHOPPER_TIMING_Z3 CHOPPER_TIMING_E
+  #endif
+  static constexpr chopper_timing_t chopper_timing_Z3 = CHOPPER_TIMING_Z3;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define Z3_ENABLE_INIT() NOOP
-    #define Z3_ENABLE_WRITE(STATE) stepperZ3.toff((STATE)==Z_ENABLE_ON ? chopper_timing.toff : 0)
+    #define Z3_ENABLE_WRITE(STATE) stepperZ3.toff((STATE)==Z_ENABLE_ON ? chopper_timing_Z3.toff : 0)
     #define Z3_ENABLE_READ() stepperZ3.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(Z3)
     #define Z3_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(Z3_STEP_PIN); }while(0)
   #endif
 #endif
 
 // Z4 Stepper
 #if HAS_Z4_ENABLE && AXIS_IS_TMC(Z4)
   extern TMC_CLASS(Z4, Z) stepperZ4;
+  #ifndef CHOPPER_TIMING_Z4
+    #define CHOPPER_TIMING_Z4 CHOPPER_TIMING_E
+  #endif
+  static constexpr chopper_timing_t chopper_timing_Z4 = CHOPPER_TIMING_Z4;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define Z4_ENABLE_INIT() NOOP
-    #define Z4_ENABLE_WRITE(STATE) stepperZ4.toff((STATE)==Z_ENABLE_ON ? chopper_timing.toff : 0)
+    #define Z4_ENABLE_WRITE(STATE) stepperZ4.toff((STATE)==Z_ENABLE_ON ? chopper_timing_Z4.toff : 0)
     #define Z4_ENABLE_READ() stepperZ4.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(Z4)
     #define Z4_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(Z4_STEP_PIN); }while(0)
   #endif
 #endif
 
 // E0 Stepper
 #if AXIS_IS_TMC(E0)
   extern TMC_CLASS_E(0) stepperE0;
+  #ifndef CHOPPER_TIMING_E0
+    #define CHOPPER_TIMING_E0 CHOPPER_TIMING_E
+  #endif
+  static constexpr chopper_timing_t chopper_timing_E0 = CHOPPER_TIMING_E0;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E0)
     #define E0_ENABLE_INIT() NOOP
-    #define E0_ENABLE_WRITE(STATE) stepperE0.toff((STATE)==E_ENABLE_ON ? chopper_timing.toff : 0)
+    #define E0_ENABLE_WRITE(STATE) stepperE0.toff((STATE)==E_ENABLE_ON ? chopper_timing_E0.toff : 0)
     #define E0_ENABLE_READ() stepperE0.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(E0)
     #define E0_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(E0_STEP_PIN); }while(0)
   #endif
 #endif
 
 // E1 Stepper
 #if AXIS_IS_TMC(E1)
   extern TMC_CLASS_E(1) stepperE1;
+  #ifndef CHOPPER_TIMING_E1
+    #define CHOPPER_TIMING_E1 CHOPPER_TIMING_E
+  #endif
+  static constexpr chopper_timing_t chopper_timing_E1 = CHOPPER_TIMING_E1;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E1)
     #define E1_ENABLE_INIT() NOOP
-    #define E1_ENABLE_WRITE(STATE) stepperE1.toff((STATE)==E_ENABLE_ON ? chopper_timing.toff : 0)
+    #define E1_ENABLE_WRITE(STATE) stepperE1.toff((STATE)==E_ENABLE_ON ? chopper_timing_E1.toff : 0)
     #define E1_ENABLE_READ() stepperE1.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(E1)
     #define E1_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(E1_STEP_PIN); }while(0)
   #endif
 #endif
 
 // E2 Stepper
 #if AXIS_IS_TMC(E2)
   extern TMC_CLASS_E(2) stepperE2;
+  #ifndef CHOPPER_TIMING_E2
+    #define CHOPPER_TIMING_E2 CHOPPER_TIMING_E
+  #endif
+  static constexpr chopper_timing_t chopper_timing_E2 = CHOPPER_TIMING_E2;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E2)
     #define E2_ENABLE_INIT() NOOP
-    #define E2_ENABLE_WRITE(STATE) stepperE2.toff((STATE)==E_ENABLE_ON ? chopper_timing.toff : 0)
+    #define E2_ENABLE_WRITE(STATE) stepperE2.toff((STATE)==E_ENABLE_ON ? chopper_timing_E2.toff : 0)
     #define E2_ENABLE_READ() stepperE2.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(E2)
     #define E2_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(E2_STEP_PIN); }while(0)
   #endif
 #endif
 
 // E3 Stepper
 #if AXIS_IS_TMC(E3)
   extern TMC_CLASS_E(3) stepperE3;
+  #ifndef CHOPPER_TIMING_E3
+    #define CHOPPER_TIMING_E3 CHOPPER_TIMING_E
+  #endif
+  static constexpr chopper_timing_t chopper_timing_E3 = CHOPPER_TIMING_E3;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E3)
     #define E3_ENABLE_INIT() NOOP
-    #define E3_ENABLE_WRITE(STATE) stepperE3.toff((STATE)==E_ENABLE_ON ? chopper_timing.toff : 0)
+    #define E3_ENABLE_WRITE(STATE) stepperE3.toff((STATE)==E_ENABLE_ON ? chopper_timing_E3.toff : 0)
     #define E3_ENABLE_READ() stepperE3.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(E3)
     #define E3_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(E3_STEP_PIN); }while(0)
   #endif
 #endif
 
 // E4 Stepper
 #if AXIS_IS_TMC(E4)
   extern TMC_CLASS_E(4) stepperE4;
+  #ifndef CHOPPER_TIMING_E4
+    #define CHOPPER_TIMING_E4 CHOPPER_TIMING_E
+  #endif
+  static constexpr chopper_timing_t chopper_timing_E4 = CHOPPER_TIMING_E4;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E4)
     #define E4_ENABLE_INIT() NOOP
-    #define E4_ENABLE_WRITE(STATE) stepperE4.toff((STATE)==E_ENABLE_ON ? chopper_timing.toff : 0)
+    #define E4_ENABLE_WRITE(STATE) stepperE4.toff((STATE)==E_ENABLE_ON ? chopper_timing_E4.toff : 0)
     #define E4_ENABLE_READ() stepperE4.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(E4)
     #define E4_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(E4_STEP_PIN); }while(0)
   #endif
 #endif
 
 // E5 Stepper
 #if AXIS_IS_TMC(E5)
   extern TMC_CLASS_E(5) stepperE5;
+  #ifndef CHOPPER_TIMING_E5
+    #define CHOPPER_TIMING_E5 CHOPPER_TIMING_E
+  #endif
+  static constexpr chopper_timing_t chopper_timing_E5 = CHOPPER_TIMING_E5;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E5)
     #define E5_ENABLE_INIT() NOOP
-    #define E5_ENABLE_WRITE(STATE) stepperE5.toff((STATE)==E_ENABLE_ON ? chopper_timing.toff : 0)
+    #define E5_ENABLE_WRITE(STATE) stepperE5.toff((STATE)==E_ENABLE_ON ? chopper_timing_E5.toff : 0)
     #define E5_ENABLE_READ() stepperE5.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(E5)
     #define E5_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(E5_STEP_PIN); }while(0)
   #endif
 #endif
 
 // E6 Stepper
 #if AXIS_IS_TMC(E6)
   extern TMC_CLASS_E(6) stepperE6;
+  #ifndef CHOPPER_TIMING_E6
+    #define CHOPPER_TIMING_E6 CHOPPER_TIMING_E
+  #endif
+  static constexpr chopper_timing_t chopper_timing_E6 = CHOPPER_TIMING_E6;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E6)
     #define E6_ENABLE_INIT() NOOP
-    #define E6_ENABLE_WRITE(STATE) stepperE6.toff((STATE)==E_ENABLE_ON ? chopper_timing.toff : 0)
+    #define E6_ENABLE_WRITE(STATE) stepperE6.toff((STATE)==E_ENABLE_ON ? chopper_timing_E6.toff : 0)
     #define E6_ENABLE_READ() stepperE6.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(E6)
     #define E6_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(E6_STEP_PIN); }while(0)
   #endif
 #endif
 
 // E7 Stepper
 #if AXIS_IS_TMC(E7)
   extern TMC_CLASS_E(7) stepperE7;
+  #ifndef CHOPPER_TIMING_E7
+    #define CHOPPER_TIMING_E7 CHOPPER_TIMING_E
+  #endif
+  static constexpr chopper_timing_t chopper_timing_E7 = CHOPPER_TIMING_E7;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E7)
     #define E7_ENABLE_INIT() NOOP
-    #define E7_ENABLE_WRITE(STATE) stepperE7.toff((STATE)==E_ENABLE_ON ? chopper_timing.toff : 0)
+    #define E7_ENABLE_WRITE(STATE) stepperE7.toff((STATE)==E_ENABLE_ON ? chopper_timing_E7.toff : 0)
     #define E7_ENABLE_READ() stepperE7.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(E7)
     #define E7_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(E7_STEP_PIN); }while(0)
   #endif
 #endif

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/module/stepper/trinamic.h b/Marlin/src/module/stepper/trinamic.h
index 262e20840e..9cc3404cd2 100644
--- a/Marlin/src/module/stepper/trinamic.h
+++ b/Marlin/src/module/stepper/trinamic.h
@@ -9,21 +9,21 @@
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 #pragma once
 
 /**
  * stepper/trinamic.h
  * Stepper driver indirection for Trinamic
  */
 
 #include <TMCStepper.h>

commit bfad23d3e2e590b257ebe4317d7b14cc2dd3435c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 3 08:00:57 2020 -0600

    (c) 2020

diff --git a/Marlin/src/module/stepper/trinamic.h b/Marlin/src/module/stepper/trinamic.h
index afa8847108..262e20840e 100644
--- a/Marlin/src/module/stepper/trinamic.h
+++ b/Marlin/src/module/stepper/trinamic.h
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit 248b7dfa591a34a8aa1c6960944e1a3a468ad1de
Author: yangwenxiong <46896566+yangwenxiong@users.noreply.github.com>
Date:   Sat Jan 25 16:13:39 2020 +0800

    BigTreeTech GTR V1.0 / Support 8 extruders, heaters, temp sensors, fans (#16595)

diff --git a/Marlin/src/module/stepper/trinamic.h b/Marlin/src/module/stepper/trinamic.h
index df4675d817..afa8847108 100644
--- a/Marlin/src/module/stepper/trinamic.h
+++ b/Marlin/src/module/stepper/trinamic.h
@@ -51,20 +51,22 @@
 #define TMC_Z2_LABEL 'Z', '2'
 #define TMC_Z3_LABEL 'Z', '3'
 #define TMC_Z4_LABEL 'Z', '4'
 
 #define TMC_E0_LABEL 'E', '0'
 #define TMC_E1_LABEL 'E', '1'
 #define TMC_E2_LABEL 'E', '2'
 #define TMC_E3_LABEL 'E', '3'
 #define TMC_E4_LABEL 'E', '4'
 #define TMC_E5_LABEL 'E', '5'
+#define TMC_E6_LABEL 'E', '6'
+#define TMC_E7_LABEL 'E', '7'
 
 #define __TMC_CLASS(TYPE, L, I, A) TMCMarlin<CLASS_##TYPE, L, I, A>
 #define _TMC_CLASS(TYPE, LandI, A) __TMC_CLASS(TYPE, LandI, A)
 #define TMC_CLASS(ST, A) _TMC_CLASS(ST##_DRIVER_TYPE, TMC_##ST##_LABEL, A##_AXIS)
 #if ENABLED(DISTINCT_E_FACTORS)
   #define TMC_CLASS_E(N) TMC_CLASS(E##N, E##N)
 #else
   #define TMC_CLASS_E(N) TMC_CLASS(E##N, E)
 #endif
 
@@ -259,10 +261,36 @@ void reset_trinamic_drivers();
   extern TMC_CLASS_E(5) stepperE5;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E5)
     #define E5_ENABLE_INIT() NOOP
     #define E5_ENABLE_WRITE(STATE) stepperE5.toff((STATE)==E_ENABLE_ON ? chopper_timing.toff : 0)
     #define E5_ENABLE_READ() stepperE5.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(E5)
     #define E5_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(E5_STEP_PIN); }while(0)
   #endif
 #endif
+
+// E6 Stepper
+#if AXIS_IS_TMC(E6)
+  extern TMC_CLASS_E(6) stepperE6;
+  #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E6)
+    #define E6_ENABLE_INIT() NOOP
+    #define E6_ENABLE_WRITE(STATE) stepperE6.toff((STATE)==E_ENABLE_ON ? chopper_timing.toff : 0)
+    #define E6_ENABLE_READ() stepperE6.isEnabled()
+  #endif
+  #if AXIS_HAS_SQUARE_WAVE(E6)
+    #define E6_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(E6_STEP_PIN); }while(0)
+  #endif
+#endif
+
+// E7 Stepper
+#if AXIS_IS_TMC(E7)
+  extern TMC_CLASS_E(7) stepperE7;
+  #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E7)
+    #define E7_ENABLE_INIT() NOOP
+    #define E7_ENABLE_WRITE(STATE) stepperE7.toff((STATE)==E_ENABLE_ON ? chopper_timing.toff : 0)
+    #define E7_ENABLE_READ() stepperE7.isEnabled()
+  #endif
+  #if AXIS_HAS_SQUARE_WAVE(E7)
+    #define E7_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(E7_STEP_PIN); }while(0)
+  #endif
+#endif

commit 0fcf2b1110d9f0d362e5aab9cc73d963710e9865
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Mon Jan 20 00:35:07 2020 -0500

    Quad Z stepper support (#16277)

diff --git a/Marlin/src/module/stepper/trinamic.h b/Marlin/src/module/stepper/trinamic.h
index 863e7475bb..df4675d817 100644
--- a/Marlin/src/module/stepper/trinamic.h
+++ b/Marlin/src/module/stepper/trinamic.h
@@ -43,20 +43,21 @@
 #define CLASS_TMC5160 TMC5160Stepper
 
 #define TMC_X_LABEL 'X', '0'
 #define TMC_Y_LABEL 'Y', '0'
 #define TMC_Z_LABEL 'Z', '0'
 
 #define TMC_X2_LABEL 'X', '2'
 #define TMC_Y2_LABEL 'Y', '2'
 #define TMC_Z2_LABEL 'Z', '2'
 #define TMC_Z3_LABEL 'Z', '3'
+#define TMC_Z4_LABEL 'Z', '4'
 
 #define TMC_E0_LABEL 'E', '0'
 #define TMC_E1_LABEL 'E', '1'
 #define TMC_E2_LABEL 'E', '2'
 #define TMC_E3_LABEL 'E', '3'
 #define TMC_E4_LABEL 'E', '4'
 #define TMC_E5_LABEL 'E', '5'
 
 #define __TMC_CLASS(TYPE, L, I, A) TMCMarlin<CLASS_##TYPE, L, I, A>
 #define _TMC_CLASS(TYPE, LandI, A) __TMC_CLASS(TYPE, LandI, A)
@@ -168,20 +169,33 @@ void reset_trinamic_drivers();
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
     #define Z3_ENABLE_INIT() NOOP
     #define Z3_ENABLE_WRITE(STATE) stepperZ3.toff((STATE)==Z_ENABLE_ON ? chopper_timing.toff : 0)
     #define Z3_ENABLE_READ() stepperZ3.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(Z3)
     #define Z3_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(Z3_STEP_PIN); }while(0)
   #endif
 #endif
 
+// Z4 Stepper
+#if HAS_Z4_ENABLE && AXIS_IS_TMC(Z4)
+  extern TMC_CLASS(Z4, Z) stepperZ4;
+  #if ENABLED(SOFTWARE_DRIVER_ENABLE)
+    #define Z4_ENABLE_INIT() NOOP
+    #define Z4_ENABLE_WRITE(STATE) stepperZ4.toff((STATE)==Z_ENABLE_ON ? chopper_timing.toff : 0)
+    #define Z4_ENABLE_READ() stepperZ4.isEnabled()
+  #endif
+  #if AXIS_HAS_SQUARE_WAVE(Z4)
+    #define Z4_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(Z4_STEP_PIN); }while(0)
+  #endif
+#endif
+
 // E0 Stepper
 #if AXIS_IS_TMC(E0)
   extern TMC_CLASS_E(0) stepperE0;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E0)
     #define E0_ENABLE_INIT() NOOP
     #define E0_ENABLE_WRITE(STATE) stepperE0.toff((STATE)==E_ENABLE_ON ? chopper_timing.toff : 0)
     #define E0_ENABLE_READ() stepperE0.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(E0)
     #define E0_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(E0_STEP_PIN); }while(0)

commit 707349d492c2544d32af7287aca4ddbaf1473542
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Jan 19 19:52:01 2020 -0600

    Updates for L64XX

diff --git a/Marlin/src/module/stepper/trinamic.h b/Marlin/src/module/stepper/trinamic.h
index b11d6b2ec2..863e7475bb 100644
--- a/Marlin/src/module/stepper/trinamic.h
+++ b/Marlin/src/module/stepper/trinamic.h
@@ -81,174 +81,174 @@ static constexpr chopper_timing_t chopper_timing = CHOPPER_TIMING;
 
 void restore_trinamic_drivers();
 void reset_trinamic_drivers();
 
 #define AXIS_HAS_SQUARE_WAVE(A) (AXIS_IS_TMC(A) && ENABLED(SQUARE_WAVE_STEPPING))
 
 // X Stepper
 #if AXIS_IS_TMC(X)
   extern TMC_CLASS(X, X) stepperX;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
-    #define X_ENABLE_INIT NOOP
+    #define X_ENABLE_INIT() NOOP
     #define X_ENABLE_WRITE(STATE) stepperX.toff((STATE)==X_ENABLE_ON ? chopper_timing.toff : 0)
     #define X_ENABLE_READ() stepperX.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(X)
     #define X_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(X_STEP_PIN); }while(0)
   #endif
 #endif
 
 // Y Stepper
 #if AXIS_IS_TMC(Y)
   extern TMC_CLASS(Y, Y) stepperY;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
-    #define Y_ENABLE_INIT NOOP
+    #define Y_ENABLE_INIT() NOOP
     #define Y_ENABLE_WRITE(STATE) stepperY.toff((STATE)==Y_ENABLE_ON ? chopper_timing.toff : 0)
     #define Y_ENABLE_READ() stepperY.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(Y)
     #define Y_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(Y_STEP_PIN); }while(0)
   #endif
 #endif
 
 // Z Stepper
 #if AXIS_IS_TMC(Z)
   extern TMC_CLASS(Z, Z) stepperZ;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
-    #define Z_ENABLE_INIT NOOP
+    #define Z_ENABLE_INIT() NOOP
     #define Z_ENABLE_WRITE(STATE) stepperZ.toff((STATE)==Z_ENABLE_ON ? chopper_timing.toff : 0)
     #define Z_ENABLE_READ() stepperZ.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(Z)
     #define Z_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(Z_STEP_PIN); }while(0)
   #endif
 #endif
 
 // X2 Stepper
 #if HAS_X2_ENABLE && AXIS_IS_TMC(X2)
   extern TMC_CLASS(X2, X) stepperX2;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
-    #define X2_ENABLE_INIT NOOP
+    #define X2_ENABLE_INIT() NOOP
     #define X2_ENABLE_WRITE(STATE) stepperX2.toff((STATE)==X_ENABLE_ON ? chopper_timing.toff : 0)
     #define X2_ENABLE_READ() stepperX2.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(X2)
     #define X2_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(X2_STEP_PIN); }while(0)
   #endif
 #endif
 
 // Y2 Stepper
 #if HAS_Y2_ENABLE && AXIS_IS_TMC(Y2)
   extern TMC_CLASS(Y2, Y) stepperY2;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
-    #define Y2_ENABLE_INIT NOOP
+    #define Y2_ENABLE_INIT() NOOP
     #define Y2_ENABLE_WRITE(STATE) stepperY2.toff((STATE)==Y_ENABLE_ON ? chopper_timing.toff : 0)
     #define Y2_ENABLE_READ() stepperY2.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(Y2)
     #define Y2_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(Y2_STEP_PIN); }while(0)
   #endif
 #endif
 
 // Z2 Stepper
 #if HAS_Z2_ENABLE && AXIS_IS_TMC(Z2)
   extern TMC_CLASS(Z2, Z) stepperZ2;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(Z2)
-    #define Z2_ENABLE_INIT NOOP
+    #define Z2_ENABLE_INIT() NOOP
     #define Z2_ENABLE_WRITE(STATE) stepperZ2.toff((STATE)==Z_ENABLE_ON ? chopper_timing.toff : 0)
     #define Z2_ENABLE_READ() stepperZ2.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(Z2)
     #define Z2_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(Z2_STEP_PIN); }while(0)
   #endif
 #endif
 
 // Z3 Stepper
 #if HAS_Z3_ENABLE && AXIS_IS_TMC(Z3)
   extern TMC_CLASS(Z3, Z) stepperZ3;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE)
-    #define Z3_ENABLE_INIT NOOP
+    #define Z3_ENABLE_INIT() NOOP
     #define Z3_ENABLE_WRITE(STATE) stepperZ3.toff((STATE)==Z_ENABLE_ON ? chopper_timing.toff : 0)
     #define Z3_ENABLE_READ() stepperZ3.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(Z3)
     #define Z3_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(Z3_STEP_PIN); }while(0)
   #endif
 #endif
 
 // E0 Stepper
 #if AXIS_IS_TMC(E0)
   extern TMC_CLASS_E(0) stepperE0;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E0)
-    #define E0_ENABLE_INIT NOOP
+    #define E0_ENABLE_INIT() NOOP
     #define E0_ENABLE_WRITE(STATE) stepperE0.toff((STATE)==E_ENABLE_ON ? chopper_timing.toff : 0)
     #define E0_ENABLE_READ() stepperE0.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(E0)
     #define E0_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(E0_STEP_PIN); }while(0)
   #endif
 #endif
 
 // E1 Stepper
 #if AXIS_IS_TMC(E1)
   extern TMC_CLASS_E(1) stepperE1;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E1)
-    #define E1_ENABLE_INIT NOOP
+    #define E1_ENABLE_INIT() NOOP
     #define E1_ENABLE_WRITE(STATE) stepperE1.toff((STATE)==E_ENABLE_ON ? chopper_timing.toff : 0)
     #define E1_ENABLE_READ() stepperE1.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(E1)
     #define E1_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(E1_STEP_PIN); }while(0)
   #endif
 #endif
 
 // E2 Stepper
 #if AXIS_IS_TMC(E2)
   extern TMC_CLASS_E(2) stepperE2;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E2)
-    #define E2_ENABLE_INIT NOOP
+    #define E2_ENABLE_INIT() NOOP
     #define E2_ENABLE_WRITE(STATE) stepperE2.toff((STATE)==E_ENABLE_ON ? chopper_timing.toff : 0)
     #define E2_ENABLE_READ() stepperE2.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(E2)
     #define E2_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(E2_STEP_PIN); }while(0)
   #endif
 #endif
 
 // E3 Stepper
 #if AXIS_IS_TMC(E3)
   extern TMC_CLASS_E(3) stepperE3;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E3)
-    #define E3_ENABLE_INIT NOOP
+    #define E3_ENABLE_INIT() NOOP
     #define E3_ENABLE_WRITE(STATE) stepperE3.toff((STATE)==E_ENABLE_ON ? chopper_timing.toff : 0)
     #define E3_ENABLE_READ() stepperE3.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(E3)
     #define E3_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(E3_STEP_PIN); }while(0)
   #endif
 #endif
 
 // E4 Stepper
 #if AXIS_IS_TMC(E4)
   extern TMC_CLASS_E(4) stepperE4;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E4)
-    #define E4_ENABLE_INIT NOOP
+    #define E4_ENABLE_INIT() NOOP
     #define E4_ENABLE_WRITE(STATE) stepperE4.toff((STATE)==E_ENABLE_ON ? chopper_timing.toff : 0)
     #define E4_ENABLE_READ() stepperE4.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(E4)
     #define E4_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(E4_STEP_PIN); }while(0)
   #endif
 #endif
 
 // E5 Stepper
 #if AXIS_IS_TMC(E5)
   extern TMC_CLASS_E(5) stepperE5;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E5)
-    #define E5_ENABLE_INIT NOOP
+    #define E5_ENABLE_INIT() NOOP
     #define E5_ENABLE_WRITE(STATE) stepperE5.toff((STATE)==E_ENABLE_ON ? chopper_timing.toff : 0)
     #define E5_ENABLE_READ() stepperE5.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(E5)
     #define E5_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(E5_STEP_PIN); }while(0)
   #endif
 #endif

commit 1d0452c41e95f94f78453f293475d4fb3e9c0061
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jan 3 17:11:36 2020 -0600

    Standardize drivers.h values, add class indirection (#16448)

diff --git a/Marlin/src/module/stepper/trinamic.h b/Marlin/src/module/stepper/trinamic.h
index 8c6e9c21aa..b11d6b2ec2 100644
--- a/Marlin/src/module/stepper/trinamic.h
+++ b/Marlin/src/module/stepper/trinamic.h
@@ -27,29 +27,51 @@
  */
 
 #include <TMCStepper.h>
 #if TMCSTEPPER_VERSION < 0x000500
   #error "Update TMCStepper library to 0.5.0 or newer."
 #endif
 
 #include "../../inc/MarlinConfig.h"
 #include "../../feature/tmc_util.h"
 
-#define ____TMC_CLASS(MODEL, A, I, E) TMCMarlin<TMC##MODEL##Stepper, A, I, E>
-#define ___TMC_CLASS(MODEL, A, I, E) ____TMC_CLASS(MODEL, A, I, E)
-#define __TMC_CLASS(MODEL, A, I, E) ___TMC_CLASS(_##MODEL, A, I, E)
-#define _TMC_CLASS(MODEL, L, E) __TMC_CLASS(MODEL, L, E)
+#define CLASS_TMC2130 TMC2130Stepper
+#define CLASS_TMC2160 TMC2160Stepper
+#define CLASS_TMC2208 TMC2208Stepper
+#define CLASS_TMC2209 TMC2209Stepper
+#define CLASS_TMC2660 TMC2660Stepper
+#define CLASS_TMC5130 TMC5130Stepper
+#define CLASS_TMC5160 TMC5160Stepper
+
+#define TMC_X_LABEL 'X', '0'
+#define TMC_Y_LABEL 'Y', '0'
+#define TMC_Z_LABEL 'Z', '0'
+
+#define TMC_X2_LABEL 'X', '2'
+#define TMC_Y2_LABEL 'Y', '2'
+#define TMC_Z2_LABEL 'Z', '2'
+#define TMC_Z3_LABEL 'Z', '3'
+
+#define TMC_E0_LABEL 'E', '0'
+#define TMC_E1_LABEL 'E', '1'
+#define TMC_E2_LABEL 'E', '2'
+#define TMC_E3_LABEL 'E', '3'
+#define TMC_E4_LABEL 'E', '4'
+#define TMC_E5_LABEL 'E', '5'
+
+#define __TMC_CLASS(TYPE, L, I, A) TMCMarlin<CLASS_##TYPE, L, I, A>
+#define _TMC_CLASS(TYPE, LandI, A) __TMC_CLASS(TYPE, LandI, A)
 #define TMC_CLASS(ST, A) _TMC_CLASS(ST##_DRIVER_TYPE, TMC_##ST##_LABEL, A##_AXIS)
 #if ENABLED(DISTINCT_E_FACTORS)
-  #define TMC_CLASS_E(I) TMC_CLASS(E##I, E##I)
+  #define TMC_CLASS_E(N) TMC_CLASS(E##N, E##N)
 #else
-  #define TMC_CLASS_E(I) TMC_CLASS(E##I, E)
+  #define TMC_CLASS_E(N) TMC_CLASS(E##N, E)
 #endif
 
 typedef struct {
   uint8_t toff;
   int8_t hend;
   uint8_t hstrt;
 } chopper_timing_t;
 
 static constexpr chopper_timing_t chopper_timing = CHOPPER_TIMING;
 

commit 66d02210774e6e650d0ccebf929ccda94d930cf1
Author: Jason Smith <jason.inet@gmail.com>
Date:   Wed Sep 25 00:30:07 2019 -0700

    Fix build with more than 2 Trinamic E steppers (#15329)

diff --git a/Marlin/src/module/stepper/trinamic.h b/Marlin/src/module/stepper/trinamic.h
index 7fd50449d8..8c6e9c21aa 100644
--- a/Marlin/src/module/stepper/trinamic.h
+++ b/Marlin/src/module/stepper/trinamic.h
@@ -174,59 +174,59 @@ void reset_trinamic_drivers();
     #define E1_ENABLE_WRITE(STATE) stepperE1.toff((STATE)==E_ENABLE_ON ? chopper_timing.toff : 0)
     #define E1_ENABLE_READ() stepperE1.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(E1)
     #define E1_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(E1_STEP_PIN); }while(0)
   #endif
 #endif
 
 // E2 Stepper
 #if AXIS_IS_TMC(E2)
-  extern TMC_CLASS_E(1) stepperE2;
+  extern TMC_CLASS_E(2) stepperE2;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E2)
     #define E2_ENABLE_INIT NOOP
     #define E2_ENABLE_WRITE(STATE) stepperE2.toff((STATE)==E_ENABLE_ON ? chopper_timing.toff : 0)
     #define E2_ENABLE_READ() stepperE2.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(E2)
     #define E2_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(E2_STEP_PIN); }while(0)
   #endif
 #endif
 
 // E3 Stepper
 #if AXIS_IS_TMC(E3)
-  extern TMC_CLASS_E(1) stepperE3;
+  extern TMC_CLASS_E(3) stepperE3;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E3)
     #define E3_ENABLE_INIT NOOP
     #define E3_ENABLE_WRITE(STATE) stepperE3.toff((STATE)==E_ENABLE_ON ? chopper_timing.toff : 0)
     #define E3_ENABLE_READ() stepperE3.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(E3)
     #define E3_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(E3_STEP_PIN); }while(0)
   #endif
 #endif
 
 // E4 Stepper
 #if AXIS_IS_TMC(E4)
-  extern TMC_CLASS_E(1) stepperE4;
+  extern TMC_CLASS_E(4) stepperE4;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E4)
     #define E4_ENABLE_INIT NOOP
     #define E4_ENABLE_WRITE(STATE) stepperE4.toff((STATE)==E_ENABLE_ON ? chopper_timing.toff : 0)
     #define E4_ENABLE_READ() stepperE4.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(E4)
     #define E4_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(E4_STEP_PIN); }while(0)
   #endif
 #endif
 
 // E5 Stepper
 #if AXIS_IS_TMC(E5)
-  extern TMC_CLASS_E(1) stepperE5;
+  extern TMC_CLASS_E(5) stepperE5;
   #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E5)
     #define E5_ENABLE_INIT NOOP
     #define E5_ENABLE_WRITE(STATE) stepperE5.toff((STATE)==E_ENABLE_ON ? chopper_timing.toff : 0)
     #define E5_ENABLE_READ() stepperE5.isEnabled()
   #endif
   #if AXIS_HAS_SQUARE_WAVE(E5)
     #define E5_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(E5_STEP_PIN); }while(0)
   #endif
 #endif

commit bd2b44c4ed4221d30f3bceac90236632fe6a6411
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Sep 24 17:50:16 2019 -0500

    Require newest TMCStepper

diff --git a/Marlin/src/module/stepper/trinamic.h b/Marlin/src/module/stepper/trinamic.h
index 711d46b658..7fd50449d8 100644
--- a/Marlin/src/module/stepper/trinamic.h
+++ b/Marlin/src/module/stepper/trinamic.h
@@ -20,22 +20,22 @@
  *
  */
 #pragma once
 
 /**
  * stepper/trinamic.h
  * Stepper driver indirection for Trinamic
  */
 
 #include <TMCStepper.h>
-#if TMCSTEPPER_VERSION < 0x000405
-  #error "Update TMCStepper library to 0.4.5 or newer."
+#if TMCSTEPPER_VERSION < 0x000500
+  #error "Update TMCStepper library to 0.5.0 or newer."
 #endif
 
 #include "../../inc/MarlinConfig.h"
 #include "../../feature/tmc_util.h"
 
 #define ____TMC_CLASS(MODEL, A, I, E) TMCMarlin<TMC##MODEL##Stepper, A, I, E>
 #define ___TMC_CLASS(MODEL, A, I, E) ____TMC_CLASS(MODEL, A, I, E)
 #define __TMC_CLASS(MODEL, A, I, E) ___TMC_CLASS(_##MODEL, A, I, E)
 #define _TMC_CLASS(MODEL, L, E) __TMC_CLASS(MODEL, L, E)
 #define TMC_CLASS(ST, A) _TMC_CLASS(ST##_DRIVER_TYPE, TMC_##ST##_LABEL, A##_AXIS)

commit 586b334c2ab61240607e878390ed1d53af86da69
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Aug 31 19:44:45 2019 -0500

    Split up stepper indirection (#15111)

diff --git a/Marlin/src/module/stepper/trinamic.h b/Marlin/src/module/stepper/trinamic.h
new file mode 100644
index 0000000000..711d46b658
--- /dev/null
+++ b/Marlin/src/module/stepper/trinamic.h
@@ -0,0 +1,232 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+#pragma once
+
+/**
+ * stepper/trinamic.h
+ * Stepper driver indirection for Trinamic
+ */
+
+#include <TMCStepper.h>
+#if TMCSTEPPER_VERSION < 0x000405
+  #error "Update TMCStepper library to 0.4.5 or newer."
+#endif
+
+#include "../../inc/MarlinConfig.h"
+#include "../../feature/tmc_util.h"
+
+#define ____TMC_CLASS(MODEL, A, I, E) TMCMarlin<TMC##MODEL##Stepper, A, I, E>
+#define ___TMC_CLASS(MODEL, A, I, E) ____TMC_CLASS(MODEL, A, I, E)
+#define __TMC_CLASS(MODEL, A, I, E) ___TMC_CLASS(_##MODEL, A, I, E)
+#define _TMC_CLASS(MODEL, L, E) __TMC_CLASS(MODEL, L, E)
+#define TMC_CLASS(ST, A) _TMC_CLASS(ST##_DRIVER_TYPE, TMC_##ST##_LABEL, A##_AXIS)
+#if ENABLED(DISTINCT_E_FACTORS)
+  #define TMC_CLASS_E(I) TMC_CLASS(E##I, E##I)
+#else
+  #define TMC_CLASS_E(I) TMC_CLASS(E##I, E)
+#endif
+
+typedef struct {
+  uint8_t toff;
+  int8_t hend;
+  uint8_t hstrt;
+} chopper_timing_t;
+
+static constexpr chopper_timing_t chopper_timing = CHOPPER_TIMING;
+
+#if HAS_TMC220x
+  void tmc_serial_begin();
+#endif
+
+void restore_trinamic_drivers();
+void reset_trinamic_drivers();
+
+#define AXIS_HAS_SQUARE_WAVE(A) (AXIS_IS_TMC(A) && ENABLED(SQUARE_WAVE_STEPPING))
+
+// X Stepper
+#if AXIS_IS_TMC(X)
+  extern TMC_CLASS(X, X) stepperX;
+  #if ENABLED(SOFTWARE_DRIVER_ENABLE)
+    #define X_ENABLE_INIT NOOP
+    #define X_ENABLE_WRITE(STATE) stepperX.toff((STATE)==X_ENABLE_ON ? chopper_timing.toff : 0)
+    #define X_ENABLE_READ() stepperX.isEnabled()
+  #endif
+  #if AXIS_HAS_SQUARE_WAVE(X)
+    #define X_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(X_STEP_PIN); }while(0)
+  #endif
+#endif
+
+// Y Stepper
+#if AXIS_IS_TMC(Y)
+  extern TMC_CLASS(Y, Y) stepperY;
+  #if ENABLED(SOFTWARE_DRIVER_ENABLE)
+    #define Y_ENABLE_INIT NOOP
+    #define Y_ENABLE_WRITE(STATE) stepperY.toff((STATE)==Y_ENABLE_ON ? chopper_timing.toff : 0)
+    #define Y_ENABLE_READ() stepperY.isEnabled()
+  #endif
+  #if AXIS_HAS_SQUARE_WAVE(Y)
+    #define Y_STEP_WRITE(STATE) do{ if (STATE) TOGGLE(Y_STEP_PIN); }while(0)
+  #endif
+#endif
+
+// Z Stepper
+#if AXIS_IS_TMC(Z)
+  extern TMC_CLASS(Z, Z) stepperZ;
+  #if ENABLED(SOFTWARE_DRIVER_ENABLE)
+    #define Z_ENABLE_INIT NOOP
+    #define Z_ENABLE_WRITE(STATE) stepperZ.toff((STATE)==Z_ENABLE_ON ? chopper_timing.toff : 0)
+    #define Z_ENABLE_READ() stepperZ.isEnabled()
+  #endif
+  #if AXIS_HAS_SQUARE_WAVE(Z)
+    #define Z_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(Z_STEP_PIN); }while(0)
+  #endif
+#endif
+
+// X2 Stepper
+#if HAS_X2_ENABLE && AXIS_IS_TMC(X2)
+  extern TMC_CLASS(X2, X) stepperX2;
+  #if ENABLED(SOFTWARE_DRIVER_ENABLE)
+    #define X2_ENABLE_INIT NOOP
+    #define X2_ENABLE_WRITE(STATE) stepperX2.toff((STATE)==X_ENABLE_ON ? chopper_timing.toff : 0)
+    #define X2_ENABLE_READ() stepperX2.isEnabled()
+  #endif
+  #if AXIS_HAS_SQUARE_WAVE(X2)
+    #define X2_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(X2_STEP_PIN); }while(0)
+  #endif
+#endif
+
+// Y2 Stepper
+#if HAS_Y2_ENABLE && AXIS_IS_TMC(Y2)
+  extern TMC_CLASS(Y2, Y) stepperY2;
+  #if ENABLED(SOFTWARE_DRIVER_ENABLE)
+    #define Y2_ENABLE_INIT NOOP
+    #define Y2_ENABLE_WRITE(STATE) stepperY2.toff((STATE)==Y_ENABLE_ON ? chopper_timing.toff : 0)
+    #define Y2_ENABLE_READ() stepperY2.isEnabled()
+  #endif
+  #if AXIS_HAS_SQUARE_WAVE(Y2)
+    #define Y2_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(Y2_STEP_PIN); }while(0)
+  #endif
+#endif
+
+// Z2 Stepper
+#if HAS_Z2_ENABLE && AXIS_IS_TMC(Z2)
+  extern TMC_CLASS(Z2, Z) stepperZ2;
+  #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(Z2)
+    #define Z2_ENABLE_INIT NOOP
+    #define Z2_ENABLE_WRITE(STATE) stepperZ2.toff((STATE)==Z_ENABLE_ON ? chopper_timing.toff : 0)
+    #define Z2_ENABLE_READ() stepperZ2.isEnabled()
+  #endif
+  #if AXIS_HAS_SQUARE_WAVE(Z2)
+    #define Z2_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(Z2_STEP_PIN); }while(0)
+  #endif
+#endif
+
+// Z3 Stepper
+#if HAS_Z3_ENABLE && AXIS_IS_TMC(Z3)
+  extern TMC_CLASS(Z3, Z) stepperZ3;
+  #if ENABLED(SOFTWARE_DRIVER_ENABLE)
+    #define Z3_ENABLE_INIT NOOP
+    #define Z3_ENABLE_WRITE(STATE) stepperZ3.toff((STATE)==Z_ENABLE_ON ? chopper_timing.toff : 0)
+    #define Z3_ENABLE_READ() stepperZ3.isEnabled()
+  #endif
+  #if AXIS_HAS_SQUARE_WAVE(Z3)
+    #define Z3_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(Z3_STEP_PIN); }while(0)
+  #endif
+#endif
+
+// E0 Stepper
+#if AXIS_IS_TMC(E0)
+  extern TMC_CLASS_E(0) stepperE0;
+  #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E0)
+    #define E0_ENABLE_INIT NOOP
+    #define E0_ENABLE_WRITE(STATE) stepperE0.toff((STATE)==E_ENABLE_ON ? chopper_timing.toff : 0)
+    #define E0_ENABLE_READ() stepperE0.isEnabled()
+  #endif
+  #if AXIS_HAS_SQUARE_WAVE(E0)
+    #define E0_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(E0_STEP_PIN); }while(0)
+  #endif
+#endif
+
+// E1 Stepper
+#if AXIS_IS_TMC(E1)
+  extern TMC_CLASS_E(1) stepperE1;
+  #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E1)
+    #define E1_ENABLE_INIT NOOP
+    #define E1_ENABLE_WRITE(STATE) stepperE1.toff((STATE)==E_ENABLE_ON ? chopper_timing.toff : 0)
+    #define E1_ENABLE_READ() stepperE1.isEnabled()
+  #endif
+  #if AXIS_HAS_SQUARE_WAVE(E1)
+    #define E1_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(E1_STEP_PIN); }while(0)
+  #endif
+#endif
+
+// E2 Stepper
+#if AXIS_IS_TMC(E2)
+  extern TMC_CLASS_E(1) stepperE2;
+  #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E2)
+    #define E2_ENABLE_INIT NOOP
+    #define E2_ENABLE_WRITE(STATE) stepperE2.toff((STATE)==E_ENABLE_ON ? chopper_timing.toff : 0)
+    #define E2_ENABLE_READ() stepperE2.isEnabled()
+  #endif
+  #if AXIS_HAS_SQUARE_WAVE(E2)
+    #define E2_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(E2_STEP_PIN); }while(0)
+  #endif
+#endif
+
+// E3 Stepper
+#if AXIS_IS_TMC(E3)
+  extern TMC_CLASS_E(1) stepperE3;
+  #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E3)
+    #define E3_ENABLE_INIT NOOP
+    #define E3_ENABLE_WRITE(STATE) stepperE3.toff((STATE)==E_ENABLE_ON ? chopper_timing.toff : 0)
+    #define E3_ENABLE_READ() stepperE3.isEnabled()
+  #endif
+  #if AXIS_HAS_SQUARE_WAVE(E3)
+    #define E3_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(E3_STEP_PIN); }while(0)
+  #endif
+#endif
+
+// E4 Stepper
+#if AXIS_IS_TMC(E4)
+  extern TMC_CLASS_E(1) stepperE4;
+  #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E4)
+    #define E4_ENABLE_INIT NOOP
+    #define E4_ENABLE_WRITE(STATE) stepperE4.toff((STATE)==E_ENABLE_ON ? chopper_timing.toff : 0)
+    #define E4_ENABLE_READ() stepperE4.isEnabled()
+  #endif
+  #if AXIS_HAS_SQUARE_WAVE(E4)
+    #define E4_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(E4_STEP_PIN); }while(0)
+  #endif
+#endif
+
+// E5 Stepper
+#if AXIS_IS_TMC(E5)
+  extern TMC_CLASS_E(1) stepperE5;
+  #if ENABLED(SOFTWARE_DRIVER_ENABLE) && AXIS_IS_TMC(E5)
+    #define E5_ENABLE_INIT NOOP
+    #define E5_ENABLE_WRITE(STATE) stepperE5.toff((STATE)==E_ENABLE_ON ? chopper_timing.toff : 0)
+    #define E5_ENABLE_READ() stepperE5.isEnabled()
+  #endif
+  #if AXIS_HAS_SQUARE_WAVE(E5)
+    #define E5_STEP_WRITE(STATE) do{ if(STATE) TOGGLE(E5_STEP_PIN); }while(0)
+  #endif
+#endif
