commit 5664c02d077e028f84a24efd96c2eebe97ce8763
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 22 22:43:09 2023 -0500

    üßë‚Äçüíª Generalize SDSUPPORT as HAS_MEDIA
    
    In preparation for single- and multi-volume refactoring.

diff --git a/Marlin/src/sd/SdVolume.cpp b/Marlin/src/sd/SdVolume.cpp
index 8c06c74537..1b8cdbdcae 100644
--- a/Marlin/src/sd/SdVolume.cpp
+++ b/Marlin/src/sd/SdVolume.cpp
@@ -31,7 +31,7 @@
 
 #include "../inc/MarlinConfig.h"
 
-#if ENABLED(SDSUPPORT)
+#if HAS_MEDIA
 
 #include "SdVolume.h"
 
@@ -402,4 +402,4 @@ bool SdVolume::init(DiskIODriver * const dev, const uint8_t part) {
   return true;
 }
 
-#endif // SDSUPPORT
+#endif // HAS_MEDIA

commit 27b828891db155f8b372e4efb9891bdc91bf6d33
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Apr 7 01:33:03 2023 -0500

    üé® Apply const (#25643)

diff --git a/Marlin/src/sd/SdVolume.cpp b/Marlin/src/sd/SdVolume.cpp
index 1b1fdc5a7c..8c06c74537 100644
--- a/Marlin/src/sd/SdVolume.cpp
+++ b/Marlin/src/sd/SdVolume.cpp
@@ -47,7 +47,7 @@
 #endif
 
 // find a contiguous group of clusters
-bool SdVolume::allocContiguous(uint32_t count, uint32_t *curCluster) {
+bool SdVolume::allocContiguous(const uint32_t count, uint32_t * const curCluster) {
   if (ENABLED(SDCARD_READONLY)) return false;
 
   // start of group
@@ -138,7 +138,7 @@ bool SdVolume::cacheFlush() {
   return true;
 }
 
-bool SdVolume::cacheRawBlock(uint32_t blockNumber, bool dirty) {
+bool SdVolume::cacheRawBlock(const uint32_t blockNumber, const bool dirty) {
   if (cacheBlockNumber_ != blockNumber) {
     if (!cacheFlush()) return false;
     if (!sdCard_->readBlock(blockNumber, cacheBuffer_.data)) return false;
@@ -149,7 +149,7 @@ bool SdVolume::cacheRawBlock(uint32_t blockNumber, bool dirty) {
 }
 
 // return the size in bytes of a cluster chain
-bool SdVolume::chainSize(uint32_t cluster, uint32_t *size) {
+bool SdVolume::chainSize(uint32_t cluster, uint32_t * const size) {
   uint32_t s = 0;
   do {
     if (!fatGet(cluster, &cluster)) return false;
@@ -160,7 +160,7 @@ bool SdVolume::chainSize(uint32_t cluster, uint32_t *size) {
 }
 
 // Fetch a FAT entry
-bool SdVolume::fatGet(uint32_t cluster, uint32_t *value) {
+bool SdVolume::fatGet(const uint32_t cluster, uint32_t * const value) {
   uint32_t lba;
   if (cluster > (clusterCount_ + 1)) return false;
   if (FAT12_SUPPORT && fatType_ == 12) {
@@ -195,7 +195,7 @@ bool SdVolume::fatGet(uint32_t cluster, uint32_t *value) {
 }
 
 // Store a FAT entry
-bool SdVolume::fatPut(uint32_t cluster, uint32_t value) {
+bool SdVolume::fatPut(const uint32_t cluster, const uint32_t value) {
   if (ENABLED(SDCARD_READONLY)) return false;
 
   uint32_t lba;
@@ -326,7 +326,7 @@ int32_t SdVolume::freeClusterCount() {
  * Reasons for failure include not finding a valid partition, not finding a valid
  * FAT file system in the specified partition or an I/O error.
  */
-bool SdVolume::init(DiskIODriver* dev, uint8_t part) {
+bool SdVolume::init(DiskIODriver * const dev, const uint8_t part) {
   uint32_t totalBlocks, volumeStartBlock = 0;
   fat32_boot_t *fbs;
 

commit 138340ee99a852bc116e2a436932bed074624fde
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Tue Apr 13 19:34:19 2021 -0300

    Multi-Volume. Select Media for LVGL (#21344)

diff --git a/Marlin/src/sd/SdVolume.cpp b/Marlin/src/sd/SdVolume.cpp
index 7fcebd640d..1b1fdc5a7c 100644
--- a/Marlin/src/sd/SdVolume.cpp
+++ b/Marlin/src/sd/SdVolume.cpp
@@ -41,10 +41,10 @@
   // raw block cache
   uint32_t SdVolume::cacheBlockNumber_;  // current block number
   cache_t  SdVolume::cacheBuffer_;       // 512 byte cache for Sd2Card
-  Sd2Card* SdVolume::sdCard_;            // pointer to SD card object
+  DiskIODriver *SdVolume::sdCard_;       // pointer to SD card object
   bool     SdVolume::cacheDirty_;        // cacheFlush() will write block if true
   uint32_t SdVolume::cacheMirrorBlock_;  // mirror  block for second FAT
-#endif  // USE_MULTIPLE_CARDS
+#endif
 
 // find a contiguous group of clusters
 bool SdVolume::allocContiguous(uint32_t count, uint32_t *curCluster) {
@@ -326,7 +326,7 @@ int32_t SdVolume::freeClusterCount() {
  * Reasons for failure include not finding a valid partition, not finding a valid
  * FAT file system in the specified partition or an I/O error.
  */
-bool SdVolume::init(Sd2Card* dev, uint8_t part) {
+bool SdVolume::init(DiskIODriver* dev, uint8_t part) {
   uint32_t totalBlocks, volumeStartBlock = 0;
   fat32_boot_t *fbs;
 

commit 3b73b115ca9366f0155986b717d4c85c31ed2f80
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 29 20:36:37 2021 -0500

    Apply pointer formatting

diff --git a/Marlin/src/sd/SdVolume.cpp b/Marlin/src/sd/SdVolume.cpp
index e262c8867a..7fcebd640d 100644
--- a/Marlin/src/sd/SdVolume.cpp
+++ b/Marlin/src/sd/SdVolume.cpp
@@ -47,7 +47,7 @@
 #endif  // USE_MULTIPLE_CARDS
 
 // find a contiguous group of clusters
-bool SdVolume::allocContiguous(uint32_t count, uint32_t* curCluster) {
+bool SdVolume::allocContiguous(uint32_t count, uint32_t *curCluster) {
   if (ENABLED(SDCARD_READONLY)) return false;
 
   // start of group
@@ -149,7 +149,7 @@ bool SdVolume::cacheRawBlock(uint32_t blockNumber, bool dirty) {
 }
 
 // return the size in bytes of a cluster chain
-bool SdVolume::chainSize(uint32_t cluster, uint32_t* size) {
+bool SdVolume::chainSize(uint32_t cluster, uint32_t *size) {
   uint32_t s = 0;
   do {
     if (!fatGet(cluster, &cluster)) return false;
@@ -160,7 +160,7 @@ bool SdVolume::chainSize(uint32_t cluster, uint32_t* size) {
 }
 
 // Fetch a FAT entry
-bool SdVolume::fatGet(uint32_t cluster, uint32_t* value) {
+bool SdVolume::fatGet(uint32_t cluster, uint32_t *value) {
   uint32_t lba;
   if (cluster > (clusterCount_ + 1)) return false;
   if (FAT12_SUPPORT && fatType_ == 12) {
@@ -328,7 +328,7 @@ int32_t SdVolume::freeClusterCount() {
  */
 bool SdVolume::init(Sd2Card* dev, uint8_t part) {
   uint32_t totalBlocks, volumeStartBlock = 0;
-  fat32_boot_t* fbs;
+  fat32_boot_t *fbs;
 
   sdCard_ = dev;
   fatType_ = 0;
@@ -342,7 +342,7 @@ bool SdVolume::init(Sd2Card* dev, uint8_t part) {
   if (part) {
     if (part > 4) return false;
     if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
-    part_t* p = &cacheBuffer_.mbr.part[part - 1];
+    part_t *p = &cacheBuffer_.mbr.part[part - 1];
     if ((p->boot & 0x7F) != 0  || p->totalSectors < 100 || p->firstSector == 0)
       return false; // not a valid partition
     volumeStartBlock = p->firstSector;

commit ec23e37a4a31d12febc06922d3fa68446f58d7fb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Oct 24 17:13:10 2020 -0500

    Clean up comments, USB flash, NULLs

diff --git a/Marlin/src/sd/SdVolume.cpp b/Marlin/src/sd/SdVolume.cpp
index 63731f728c..e262c8867a 100644
--- a/Marlin/src/sd/SdVolume.cpp
+++ b/Marlin/src/sd/SdVolume.cpp
@@ -21,6 +21,8 @@
  */
 
 /**
+ * sd/SdVolume.cpp
+ *
  * Arduino SdFat Library
  * Copyright (c) 2009 by William Greiman
  *

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/sd/SdVolume.cpp b/Marlin/src/sd/SdVolume.cpp
index 0effc31aa5..63731f728c 100644
--- a/Marlin/src/sd/SdVolume.cpp
+++ b/Marlin/src/sd/SdVolume.cpp
@@ -16,7 +16,7 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 

commit 801f99edadbf37966f231a8ae4b06fd93ff58cb1
Author: Leandro A. F. Pereira <leandro@hardinfo.org>
Date:   Sat May 30 21:59:29 2020 -0700

    SDCARD_READONLY (#17884)

diff --git a/Marlin/src/sd/SdVolume.cpp b/Marlin/src/sd/SdVolume.cpp
index 1d4c56a344..0effc31aa5 100644
--- a/Marlin/src/sd/SdVolume.cpp
+++ b/Marlin/src/sd/SdVolume.cpp
@@ -46,6 +46,8 @@
 
 // find a contiguous group of clusters
 bool SdVolume::allocContiguous(uint32_t count, uint32_t* curCluster) {
+  if (ENABLED(SDCARD_READONLY)) return false;
+
   // start of group
   uint32_t bgnCluster;
   // end of group
@@ -117,18 +119,20 @@ bool SdVolume::allocContiguous(uint32_t count, uint32_t* curCluster) {
 }
 
 bool SdVolume::cacheFlush() {
-  if (cacheDirty_) {
-    if (!sdCard_->writeBlock(cacheBlockNumber_, cacheBuffer_.data))
-      return false;
-
-    // mirror FAT tables
-    if (cacheMirrorBlock_) {
-      if (!sdCard_->writeBlock(cacheMirrorBlock_, cacheBuffer_.data))
+  #if DISABLED(SDCARD_READONLY)
+    if (cacheDirty_) {
+      if (!sdCard_->writeBlock(cacheBlockNumber_, cacheBuffer_.data))
         return false;
-      cacheMirrorBlock_ = 0;
+
+      // mirror FAT tables
+      if (cacheMirrorBlock_) {
+        if (!sdCard_->writeBlock(cacheMirrorBlock_, cacheBuffer_.data))
+          return false;
+        cacheMirrorBlock_ = 0;
+      }
+      cacheDirty_ = 0;
     }
-    cacheDirty_ = 0;
-  }
+  #endif
   return true;
 }
 
@@ -190,6 +194,8 @@ bool SdVolume::fatGet(uint32_t cluster, uint32_t* value) {
 
 // Store a FAT entry
 bool SdVolume::fatPut(uint32_t cluster, uint32_t value) {
+  if (ENABLED(SDCARD_READONLY)) return false;
+
   uint32_t lba;
   // error if reserved cluster
   if (cluster < 2) return false;

commit bfad23d3e2e590b257ebe4317d7b14cc2dd3435c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 3 08:00:57 2020 -0600

    (c) 2020

diff --git a/Marlin/src/sd/SdVolume.cpp b/Marlin/src/sd/SdVolume.cpp
index 1db562a80a..1d4c56a344 100644
--- a/Marlin/src/sd/SdVolume.cpp
+++ b/Marlin/src/sd/SdVolume.cpp
@@ -1,6 +1,6 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm

commit 43d3463d5d612a300789bdc7a845eb2e8a37786d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Feb 1 03:50:26 2020 -0600

    Misc cleanup, whitespace

diff --git a/Marlin/src/sd/SdVolume.cpp b/Marlin/src/sd/SdVolume.cpp
index 70dfa52e30..1db562a80a 100644
--- a/Marlin/src/sd/SdVolume.cpp
+++ b/Marlin/src/sd/SdVolume.cpp
@@ -292,7 +292,7 @@ int32_t SdVolume::freeClusterCount() {
         if (cacheBuffer_.fat32[i] == 0) free++;
     }
     #ifdef ESP32
-      // Needed to reset the idle task watchdog timer on ESP32 as reading the complete FAT may easily 
+      // Needed to reset the idle task watchdog timer on ESP32 as reading the complete FAT may easily
       // block for 10+ seconds. yield() is insufficient since it blocks lower prio tasks (e.g., idle).
       static millis_t nextTaskTime = 0;
       const millis_t ms = millis();

commit 8d4dd88bf918db66bd611fa0977322d715baffdd
Author: felixstorm <felix.storm@gmx.de>
Date:   Thu Jan 30 19:22:42 2020 +0100

    Fix compile error in SdVolume on ESP32 (#16728)

diff --git a/Marlin/src/sd/SdVolume.cpp b/Marlin/src/sd/SdVolume.cpp
index c51e42108c..70dfa52e30 100644
--- a/Marlin/src/sd/SdVolume.cpp
+++ b/Marlin/src/sd/SdVolume.cpp
@@ -296,7 +296,7 @@ int32_t SdVolume::freeClusterCount() {
       // block for 10+ seconds. yield() is insufficient since it blocks lower prio tasks (e.g., idle).
       static millis_t nextTaskTime = 0;
       const millis_t ms = millis();
-      if (ELAPSED(ms, nextTaskTime) {
+      if (ELAPSED(ms, nextTaskTime)) {
         vTaskDelay(1);            // delay 1 tick (Minimum. Usually 10 or 1 ms depending on skdconfig.h)
         nextTaskTime = ms + 1000; // tickle the task manager again in 1 second
       }

commit e4eaf32b4da705c924087bcb1d9f720fb8beb731
Author: felixstorm <felix.storm@glueckkanja.com>
Date:   Tue Jan 28 01:16:44 2020 +0100

    Prevent SD access from resetting ESP32 (#16690)

diff --git a/Marlin/src/sd/SdVolume.cpp b/Marlin/src/sd/SdVolume.cpp
index 926dd1c7d4..c51e42108c 100644
--- a/Marlin/src/sd/SdVolume.cpp
+++ b/Marlin/src/sd/SdVolume.cpp
@@ -291,6 +291,16 @@ int32_t SdVolume::freeClusterCount() {
       for (uint16_t i = 0; i < n; i++)
         if (cacheBuffer_.fat32[i] == 0) free++;
     }
+    #ifdef ESP32
+      // Needed to reset the idle task watchdog timer on ESP32 as reading the complete FAT may easily 
+      // block for 10+ seconds. yield() is insufficient since it blocks lower prio tasks (e.g., idle).
+      static millis_t nextTaskTime = 0;
+      const millis_t ms = millis();
+      if (ELAPSED(ms, nextTaskTime) {
+        vTaskDelay(1);            // delay 1 tick (Minimum. Usually 10 or 1 ms depending on skdconfig.h)
+        nextTaskTime = ms + 1000; // tickle the task manager again in 1 second
+      }
+    #endif // ESP32
   }
   return free;
 }

commit d0e1166cce60381fbdad1105d13765806a525d99
Author: Dirk O. Kaar <19971886+dok-net@users.noreply.github.com>
Date:   Fri Jan 3 02:01:38 2020 +0100

    Fix Visual Micro "Arduino IDE for Visual Studio" support (#16418)

diff --git a/Marlin/src/sd/SdVolume.cpp b/Marlin/src/sd/SdVolume.cpp
index 0501949406..926dd1c7d4 100644
--- a/Marlin/src/sd/SdVolume.cpp
+++ b/Marlin/src/sd/SdVolume.cpp
@@ -33,7 +33,7 @@
 
 #include "SdVolume.h"
 
-#include "../Marlin.h"
+#include "../MarlinCore.h"
 
 #if !USE_MULTIPLE_CARDS
   // raw block cache

commit 93cd66ac1146603e8a9911fceb3c63f4351f4d8e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 23:57:50 2019 -0500

    Tweaky change from (C) to (c)

diff --git a/Marlin/src/sd/SdVolume.cpp b/Marlin/src/sd/SdVolume.cpp
index f022afe176..0501949406 100644
--- a/Marlin/src/sd/SdVolume.cpp
+++ b/Marlin/src/sd/SdVolume.cpp
@@ -1,9 +1,9 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -22,7 +22,7 @@
 
 /**
  * Arduino SdFat Library
- * Copyright (C) 2009 by William Greiman
+ * Copyright (c) 2009 by William Greiman
  *
  * This file is part of the Arduino Sd2Card Library
  */

commit 0feeef26048883640b37ebe3994730f31ef6e922
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 15:06:53 2019 -0600

    Update copyright in headers

diff --git a/Marlin/src/sd/SdVolume.cpp b/Marlin/src/sd/SdVolume.cpp
index a872eb19d8..f022afe176 100644
--- a/Marlin/src/sd/SdVolume.cpp
+++ b/Marlin/src/sd/SdVolume.cpp
@@ -1,6 +1,6 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm

commit 8b12371e45356aadf175e02e80c87a3df47ea60c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Dec 15 15:17:52 2017 -0600

    Change some hex case

diff --git a/Marlin/src/sd/SdVolume.cpp b/Marlin/src/sd/SdVolume.cpp
index f4d562bb2d..a872eb19d8 100644
--- a/Marlin/src/sd/SdVolume.cpp
+++ b/Marlin/src/sd/SdVolume.cpp
@@ -207,7 +207,7 @@ bool SdVolume::fatPut(uint32_t cluster, uint32_t value) {
     index &= 0x1FF;
     uint8_t tmp = value;
     if (cluster & 1) {
-      tmp = (cacheBuffer_.data[index] & 0XF) | tmp << 4;
+      tmp = (cacheBuffer_.data[index] & 0xF) | tmp << 4;
     }
     cacheBuffer_.data[index] = tmp;
     index++;

commit 9f8b4c5ee858e80a48c35fcf6112f92dee58df79
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Nov 15 00:06:20 2017 -0600

    Patch SD lib files for readability

diff --git a/Marlin/src/sd/SdVolume.cpp b/Marlin/src/sd/SdVolume.cpp
index 710b67cfff..f4d562bb2d 100644
--- a/Marlin/src/sd/SdVolume.cpp
+++ b/Marlin/src/sd/SdVolume.cpp
@@ -35,7 +35,6 @@
 
 #include "../Marlin.h"
 
-//------------------------------------------------------------------------------
 #if !USE_MULTIPLE_CARDS
   // raw block cache
   uint32_t SdVolume::cacheBlockNumber_;  // current block number
@@ -44,7 +43,7 @@
   bool     SdVolume::cacheDirty_;        // cacheFlush() will write block if true
   uint32_t SdVolume::cacheMirrorBlock_;  // mirror  block for second FAT
 #endif  // USE_MULTIPLE_CARDS
-//------------------------------------------------------------------------------
+
 // find a contiguous group of clusters
 bool SdVolume::allocContiguous(uint32_t count, uint32_t* curCluster) {
   // start of group
@@ -78,14 +77,14 @@ bool SdVolume::allocContiguous(uint32_t count, uint32_t* curCluster) {
   // search the FAT for free clusters
   for (uint32_t n = 0;; n++, endCluster++) {
     // can't find space checked all clusters
-    if (n >= clusterCount_) goto FAIL;
+    if (n >= clusterCount_) return false;
 
     // past end - start from beginning of FAT
     if (endCluster > fatEnd) {
       bgnCluster = endCluster = 2;
     }
     uint32_t f;
-    if (!fatGet(endCluster, &f)) goto FAIL;
+    if (!fatGet(endCluster, &f)) return false;
 
     if (f != 0) {
       // cluster in use try next cluster as bgnCluster
@@ -97,16 +96,16 @@ bool SdVolume::allocContiguous(uint32_t count, uint32_t* curCluster) {
     }
   }
   // mark end of chain
-  if (!fatPutEOC(endCluster)) goto FAIL;
+  if (!fatPutEOC(endCluster)) return false;
 
   // link clusters
   while (endCluster > bgnCluster) {
-    if (!fatPut(endCluster - 1, endCluster)) goto FAIL;
+    if (!fatPut(endCluster - 1, endCluster)) return false;
     endCluster--;
   }
   if (*curCluster != 0) {
     // connect chains
-    if (!fatPut(*curCluster, bgnCluster)) goto FAIL;
+    if (!fatPut(*curCluster, bgnCluster)) return false;
   }
   // return first cluster number to caller
   *curCluster = bgnCluster;
@@ -115,111 +114,94 @@ bool SdVolume::allocContiguous(uint32_t count, uint32_t* curCluster) {
   if (setStart) allocSearchStart_ = bgnCluster + 1;
 
   return true;
-  FAIL:
-  return false;
 }
-//------------------------------------------------------------------------------
+
 bool SdVolume::cacheFlush() {
   if (cacheDirty_) {
-    if (!sdCard_->writeBlock(cacheBlockNumber_, cacheBuffer_.data)) {
-      goto FAIL;
-    }
+    if (!sdCard_->writeBlock(cacheBlockNumber_, cacheBuffer_.data))
+      return false;
+
     // mirror FAT tables
     if (cacheMirrorBlock_) {
-      if (!sdCard_->writeBlock(cacheMirrorBlock_, cacheBuffer_.data)) {
-        goto FAIL;
-      }
+      if (!sdCard_->writeBlock(cacheMirrorBlock_, cacheBuffer_.data))
+        return false;
       cacheMirrorBlock_ = 0;
     }
     cacheDirty_ = 0;
   }
   return true;
-  FAIL:
-  return false;
 }
-//------------------------------------------------------------------------------
+
 bool SdVolume::cacheRawBlock(uint32_t blockNumber, bool dirty) {
   if (cacheBlockNumber_ != blockNumber) {
-    if (!cacheFlush()) goto FAIL;
-    if (!sdCard_->readBlock(blockNumber, cacheBuffer_.data)) goto FAIL;
+    if (!cacheFlush()) return false;
+    if (!sdCard_->readBlock(blockNumber, cacheBuffer_.data)) return false;
     cacheBlockNumber_ = blockNumber;
   }
   if (dirty) cacheDirty_ = true;
   return true;
-  FAIL:
-  return false;
 }
-//------------------------------------------------------------------------------
+
 // return the size in bytes of a cluster chain
 bool SdVolume::chainSize(uint32_t cluster, uint32_t* size) {
   uint32_t s = 0;
   do {
-    if (!fatGet(cluster, &cluster)) goto FAIL;
+    if (!fatGet(cluster, &cluster)) return false;
     s += 512UL << clusterSizeShift_;
   } while (!isEOC(cluster));
   *size = s;
   return true;
-  FAIL:
-  return false;
 }
-//------------------------------------------------------------------------------
+
 // Fetch a FAT entry
 bool SdVolume::fatGet(uint32_t cluster, uint32_t* value) {
   uint32_t lba;
-  if (cluster > (clusterCount_ + 1)) goto FAIL;
+  if (cluster > (clusterCount_ + 1)) return false;
   if (FAT12_SUPPORT && fatType_ == 12) {
     uint16_t index = cluster;
     index += index >> 1;
     lba = fatStartBlock_ + (index >> 9);
-    if (!cacheRawBlock(lba, CACHE_FOR_READ)) goto FAIL;
+    if (!cacheRawBlock(lba, CACHE_FOR_READ)) return false;
     index &= 0x1FF;
     uint16_t tmp = cacheBuffer_.data[index];
     index++;
     if (index == 512) {
-      if (!cacheRawBlock(lba + 1, CACHE_FOR_READ)) goto FAIL;
+      if (!cacheRawBlock(lba + 1, CACHE_FOR_READ)) return false;
       index = 0;
     }
     tmp |= cacheBuffer_.data[index] << 8;
     *value = cluster & 1 ? tmp >> 4 : tmp & 0xFFF;
     return true;
   }
-  if (fatType_ == 16) {
+
+  if (fatType_ == 16)
     lba = fatStartBlock_ + (cluster >> 8);
-  }
-  else if (fatType_ == 32) {
+  else if (fatType_ == 32)
     lba = fatStartBlock_ + (cluster >> 7);
-  }
-  else {
-    goto FAIL;
-  }
-  if (lba != cacheBlockNumber_) {
-    if (!cacheRawBlock(lba, CACHE_FOR_READ)) goto FAIL;
-  }
-  if (fatType_ == 16) {
-    *value = cacheBuffer_.fat16[cluster & 0xFF];
-  }
-  else {
-    *value = cacheBuffer_.fat32[cluster & 0x7F] & FAT32MASK;
-  }
+  else
+    return false;
+
+  if (lba != cacheBlockNumber_ && !cacheRawBlock(lba, CACHE_FOR_READ))
+    return false;
+
+  *value = (fatType_ == 16) ? cacheBuffer_.fat16[cluster & 0xFF] : (cacheBuffer_.fat32[cluster & 0x7F] & FAT32MASK);
   return true;
-  FAIL:
-  return false;
 }
-//------------------------------------------------------------------------------
+
 // Store a FAT entry
 bool SdVolume::fatPut(uint32_t cluster, uint32_t value) {
   uint32_t lba;
   // error if reserved cluster
-  if (cluster < 2) goto FAIL;
+  if (cluster < 2) return false;
 
   // error if not in FAT
-  if (cluster > (clusterCount_ + 1)) goto FAIL;
+  if (cluster > (clusterCount_ + 1)) return false;
 
   if (FAT12_SUPPORT && fatType_ == 12) {
     uint16_t index = cluster;
     index += index >> 1;
     lba = fatStartBlock_ + (index >> 9);
-    if (!cacheRawBlock(lba, CACHE_FOR_WRITE)) goto FAIL;
+    if (!cacheRawBlock(lba, CACHE_FOR_WRITE)) return false;
     // mirror second FAT
     if (fatCount_ > 1) cacheMirrorBlock_ = lba + blocksPerFat_;
     index &= 0x1FF;
@@ -232,7 +214,7 @@ bool SdVolume::fatPut(uint32_t cluster, uint32_t value) {
     if (index == 512) {
       lba++;
       index = 0;
-      if (!cacheRawBlock(lba, CACHE_FOR_WRITE)) goto FAIL;
+      if (!cacheRawBlock(lba, CACHE_FOR_WRITE)) return false;
       // mirror second FAT
       if (fatCount_ > 1) cacheMirrorBlock_ = lba + blocksPerFat_;
     }
@@ -243,51 +225,45 @@ bool SdVolume::fatPut(uint32_t cluster, uint32_t value) {
     cacheBuffer_.data[index] = tmp;
     return true;
   }
-  if (fatType_ == 16) {
+
+  if (fatType_ == 16)
     lba = fatStartBlock_ + (cluster >> 8);
-  }
-  else if (fatType_ == 32) {
+  else if (fatType_ == 32)
     lba = fatStartBlock_ + (cluster >> 7);
-  }
-  else {
-    goto FAIL;
-  }
-  if (!cacheRawBlock(lba, CACHE_FOR_WRITE)) goto FAIL;
+  else
+    return false;
+
+  if (!cacheRawBlock(lba, CACHE_FOR_WRITE)) return false;
+
   // store entry
-  if (fatType_ == 16) {
+  if (fatType_ == 16)
     cacheBuffer_.fat16[cluster & 0xFF] = value;
-  }
-  else {
+  else
     cacheBuffer_.fat32[cluster & 0x7F] = value;
-  }
+
   // mirror second FAT
   if (fatCount_ > 1) cacheMirrorBlock_ = lba + blocksPerFat_;
   return true;
-  FAIL:
-  return false;
 }
-//------------------------------------------------------------------------------
+
 // free a cluster chain
 bool SdVolume::freeChain(uint32_t cluster) {
-  uint32_t next;
-
   // clear free cluster location
   allocSearchStart_ = 2;
 
   do {
-    if (!fatGet(cluster, &next)) goto FAIL;
+    uint32_t next;
+    if (!fatGet(cluster, &next)) return false;
 
     // free cluster
-    if (!fatPut(cluster, 0)) goto FAIL;
+    if (!fatPut(cluster, 0)) return false;
 
     cluster = next;
   } while (!isEOC(cluster));
 
   return true;
-  FAIL:
-  return false;
 }
-//------------------------------------------------------------------------------
+
 /** Volume free space in clusters.
  *
  * \return Count of free clusters for success or -1 if an error occurs.
@@ -297,34 +273,28 @@ int32_t SdVolume::freeClusterCount() {
   uint16_t n;
   uint32_t todo = clusterCount_ + 2;
 
-  if (fatType_ == 16) {
+  if (fatType_ == 16)
     n = 256;
-  }
-  else if (fatType_ == 32) {
+  else if (fatType_ == 32)
     n = 128;
-  }
-  else {
-    // put FAT12 here
+  else // put FAT12 here
     return -1;
-  }
 
   for (uint32_t lba = fatStartBlock_; todo; todo -= n, lba++) {
     if (!cacheRawBlock(lba, CACHE_FOR_READ)) return -1;
     NOMORE(n, todo);
     if (fatType_ == 16) {
-      for (uint16_t i = 0; i < n; i++) {
+      for (uint16_t i = 0; i < n; i++)
         if (cacheBuffer_.fat16[i] == 0) free++;
-      }
     }
     else {
-      for (uint16_t i = 0; i < n; i++) {
+      for (uint16_t i = 0; i < n; i++)
         if (cacheBuffer_.fat32[i] == 0) free++;
-      }
     }
   }
   return free;
 }
-//------------------------------------------------------------------------------
+
 /** Initialize a FAT volume.
  *
  * \param[in] dev The SD card where the volume is located.
@@ -334,14 +304,12 @@ int32_t SdVolume::freeClusterCount() {
  * a MBR, Master Boot Record, or zero if the device is formatted as
  * a super floppy with the FAT boot sector in block zero.
  *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.  Reasons for
- * failure include not finding a valid partition, not finding a valid
+ * \return true for success, false for failure.
+ * Reasons for failure include not finding a valid partition, not finding a valid
  * FAT file system in the specified partition or an I/O error.
  */
 bool SdVolume::init(Sd2Card* dev, uint8_t part) {
-  uint32_t totalBlocks;
-  uint32_t volumeStartBlock = 0;
+  uint32_t totalBlocks, volumeStartBlock = 0;
   fat32_boot_t* fbs;
 
   sdCard_ = dev;
@@ -354,25 +322,21 @@ bool SdVolume::init(Sd2Card* dev, uint8_t part) {
   // if part == 0 assume super floppy with FAT boot sector in block zero
   // if part > 0 assume mbr volume with partition table
   if (part) {
-    if (part > 4)goto FAIL;
-    if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) goto FAIL;
+    if (part > 4) return false;
+    if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
     part_t* p = &cacheBuffer_.mbr.part[part - 1];
-    if ((p->boot & 0x7F) != 0  ||
-        p->totalSectors < 100 ||
-        p->firstSector == 0) {
-      // not a valid partition
-      goto FAIL;
-    }
+    if ((p->boot & 0x7F) != 0  || p->totalSectors < 100 || p->firstSector == 0)
+      return false; // not a valid partition
     volumeStartBlock = p->firstSector;
   }
-  if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) goto FAIL;
+  if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) return false;
   fbs = &cacheBuffer_.fbs32;
   if (fbs->bytesPerSector != 512 ||
       fbs->fatCount == 0 ||
       fbs->reservedSectorCount == 0 ||
       fbs->sectorsPerCluster == 0) {
     // not valid FAT volume
-    goto FAIL;
+    return false;
   }
   fatCount_ = fbs->fatCount;
   blocksPerCluster_ = fbs->sectorsPerCluster;
@@ -380,7 +344,7 @@ bool SdVolume::init(Sd2Card* dev, uint8_t part) {
   clusterSizeShift_ = 0;
   while (blocksPerCluster_ != _BV(clusterSizeShift_)) {
     // error if not power of 2
-    if (clusterSizeShift_++ > 7) goto FAIL;
+    if (clusterSizeShift_++ > 7) return false;
   }
   blocksPerFat_ = fbs->sectorsPerFat16 ?
                   fbs->sectorsPerFat16 : fbs->sectorsPerFat32;
@@ -409,18 +373,15 @@ bool SdVolume::init(Sd2Card* dev, uint8_t part) {
   // FAT type is determined by cluster count
   if (clusterCount_ < 4085) {
     fatType_ = 12;
-    if (!FAT12_SUPPORT) goto FAIL;
+    if (!FAT12_SUPPORT) return false;
   }
-  else if (clusterCount_ < 65525) {
+  else if (clusterCount_ < 65525)
     fatType_ = 16;
-  }
   else {
     rootDirStart_ = fbs->fat32RootCluster;
     fatType_ = 32;
   }
   return true;
-  FAIL:
-  return false;
 }
 
 #endif // SDSUPPORT

commit 614a86a380cb23a5e22661f71de5bc2e3168bb11
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 6 06:28:32 2017 -0500

    SD file updates

diff --git a/Marlin/src/sd/SdVolume.cpp b/Marlin/src/sd/SdVolume.cpp
index 4093cb5e04..710b67cfff 100644
--- a/Marlin/src/sd/SdVolume.cpp
+++ b/Marlin/src/sd/SdVolume.cpp
@@ -26,10 +26,15 @@
  *
  * This file is part of the Arduino Sd2Card Library
  */
-#include "Marlin.h"
+
+#include "../inc/MarlinConfig.h"
+
 #if ENABLED(SDSUPPORT)
 
 #include "SdVolume.h"
+
+#include "../Marlin.h"
+
 //------------------------------------------------------------------------------
 #if !USE_MULTIPLE_CARDS
   // raw block cache
@@ -417,4 +422,5 @@ bool SdVolume::init(Sd2Card* dev, uint8_t part) {
   FAIL:
   return false;
 }
-#endif
+
+#endif // SDSUPPORT

commit b66d65f8657efe2ddecfe4a4c255b2d260671ce1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 6 06:28:31 2017 -0500

    Move 'sd' files

diff --git a/Marlin/src/sd/SdVolume.cpp b/Marlin/src/sd/SdVolume.cpp
new file mode 100644
index 0000000000..4093cb5e04
--- /dev/null
+++ b/Marlin/src/sd/SdVolume.cpp
@@ -0,0 +1,420 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * Arduino SdFat Library
+ * Copyright (C) 2009 by William Greiman
+ *
+ * This file is part of the Arduino Sd2Card Library
+ */
+#include "Marlin.h"
+#if ENABLED(SDSUPPORT)
+
+#include "SdVolume.h"
+//------------------------------------------------------------------------------
+#if !USE_MULTIPLE_CARDS
+  // raw block cache
+  uint32_t SdVolume::cacheBlockNumber_;  // current block number
+  cache_t  SdVolume::cacheBuffer_;       // 512 byte cache for Sd2Card
+  Sd2Card* SdVolume::sdCard_;            // pointer to SD card object
+  bool     SdVolume::cacheDirty_;        // cacheFlush() will write block if true
+  uint32_t SdVolume::cacheMirrorBlock_;  // mirror  block for second FAT
+#endif  // USE_MULTIPLE_CARDS
+//------------------------------------------------------------------------------
+// find a contiguous group of clusters
+bool SdVolume::allocContiguous(uint32_t count, uint32_t* curCluster) {
+  // start of group
+  uint32_t bgnCluster;
+  // end of group
+  uint32_t endCluster;
+  // last cluster of FAT
+  uint32_t fatEnd = clusterCount_ + 1;
+
+  // flag to save place to start next search
+  bool setStart;
+
+  // set search start cluster
+  if (*curCluster) {
+    // try to make file contiguous
+    bgnCluster = *curCluster + 1;
+
+    // don't save new start location
+    setStart = false;
+  }
+  else {
+    // start at likely place for free cluster
+    bgnCluster = allocSearchStart_;
+
+    // save next search start if one cluster
+    setStart = count == 1;
+  }
+  // end of group
+  endCluster = bgnCluster;
+
+  // search the FAT for free clusters
+  for (uint32_t n = 0;; n++, endCluster++) {
+    // can't find space checked all clusters
+    if (n >= clusterCount_) goto FAIL;
+
+    // past end - start from beginning of FAT
+    if (endCluster > fatEnd) {
+      bgnCluster = endCluster = 2;
+    }
+    uint32_t f;
+    if (!fatGet(endCluster, &f)) goto FAIL;
+
+    if (f != 0) {
+      // cluster in use try next cluster as bgnCluster
+      bgnCluster = endCluster + 1;
+    }
+    else if ((endCluster - bgnCluster + 1) == count) {
+      // done - found space
+      break;
+    }
+  }
+  // mark end of chain
+  if (!fatPutEOC(endCluster)) goto FAIL;
+
+  // link clusters
+  while (endCluster > bgnCluster) {
+    if (!fatPut(endCluster - 1, endCluster)) goto FAIL;
+    endCluster--;
+  }
+  if (*curCluster != 0) {
+    // connect chains
+    if (!fatPut(*curCluster, bgnCluster)) goto FAIL;
+  }
+  // return first cluster number to caller
+  *curCluster = bgnCluster;
+
+  // remember possible next free cluster
+  if (setStart) allocSearchStart_ = bgnCluster + 1;
+
+  return true;
+  FAIL:
+  return false;
+}
+//------------------------------------------------------------------------------
+bool SdVolume::cacheFlush() {
+  if (cacheDirty_) {
+    if (!sdCard_->writeBlock(cacheBlockNumber_, cacheBuffer_.data)) {
+      goto FAIL;
+    }
+    // mirror FAT tables
+    if (cacheMirrorBlock_) {
+      if (!sdCard_->writeBlock(cacheMirrorBlock_, cacheBuffer_.data)) {
+        goto FAIL;
+      }
+      cacheMirrorBlock_ = 0;
+    }
+    cacheDirty_ = 0;
+  }
+  return true;
+  FAIL:
+  return false;
+}
+//------------------------------------------------------------------------------
+bool SdVolume::cacheRawBlock(uint32_t blockNumber, bool dirty) {
+  if (cacheBlockNumber_ != blockNumber) {
+    if (!cacheFlush()) goto FAIL;
+    if (!sdCard_->readBlock(blockNumber, cacheBuffer_.data)) goto FAIL;
+    cacheBlockNumber_ = blockNumber;
+  }
+  if (dirty) cacheDirty_ = true;
+  return true;
+  FAIL:
+  return false;
+}
+//------------------------------------------------------------------------------
+// return the size in bytes of a cluster chain
+bool SdVolume::chainSize(uint32_t cluster, uint32_t* size) {
+  uint32_t s = 0;
+  do {
+    if (!fatGet(cluster, &cluster)) goto FAIL;
+    s += 512UL << clusterSizeShift_;
+  } while (!isEOC(cluster));
+  *size = s;
+  return true;
+  FAIL:
+  return false;
+}
+//------------------------------------------------------------------------------
+// Fetch a FAT entry
+bool SdVolume::fatGet(uint32_t cluster, uint32_t* value) {
+  uint32_t lba;
+  if (cluster > (clusterCount_ + 1)) goto FAIL;
+  if (FAT12_SUPPORT && fatType_ == 12) {
+    uint16_t index = cluster;
+    index += index >> 1;
+    lba = fatStartBlock_ + (index >> 9);
+    if (!cacheRawBlock(lba, CACHE_FOR_READ)) goto FAIL;
+    index &= 0x1FF;
+    uint16_t tmp = cacheBuffer_.data[index];
+    index++;
+    if (index == 512) {
+      if (!cacheRawBlock(lba + 1, CACHE_FOR_READ)) goto FAIL;
+      index = 0;
+    }
+    tmp |= cacheBuffer_.data[index] << 8;
+    *value = cluster & 1 ? tmp >> 4 : tmp & 0xFFF;
+    return true;
+  }
+  if (fatType_ == 16) {
+    lba = fatStartBlock_ + (cluster >> 8);
+  }
+  else if (fatType_ == 32) {
+    lba = fatStartBlock_ + (cluster >> 7);
+  }
+  else {
+    goto FAIL;
+  }
+  if (lba != cacheBlockNumber_) {
+    if (!cacheRawBlock(lba, CACHE_FOR_READ)) goto FAIL;
+  }
+  if (fatType_ == 16) {
+    *value = cacheBuffer_.fat16[cluster & 0xFF];
+  }
+  else {
+    *value = cacheBuffer_.fat32[cluster & 0x7F] & FAT32MASK;
+  }
+  return true;
+  FAIL:
+  return false;
+}
+//------------------------------------------------------------------------------
+// Store a FAT entry
+bool SdVolume::fatPut(uint32_t cluster, uint32_t value) {
+  uint32_t lba;
+  // error if reserved cluster
+  if (cluster < 2) goto FAIL;
+
+  // error if not in FAT
+  if (cluster > (clusterCount_ + 1)) goto FAIL;
+
+  if (FAT12_SUPPORT && fatType_ == 12) {
+    uint16_t index = cluster;
+    index += index >> 1;
+    lba = fatStartBlock_ + (index >> 9);
+    if (!cacheRawBlock(lba, CACHE_FOR_WRITE)) goto FAIL;
+    // mirror second FAT
+    if (fatCount_ > 1) cacheMirrorBlock_ = lba + blocksPerFat_;
+    index &= 0x1FF;
+    uint8_t tmp = value;
+    if (cluster & 1) {
+      tmp = (cacheBuffer_.data[index] & 0XF) | tmp << 4;
+    }
+    cacheBuffer_.data[index] = tmp;
+    index++;
+    if (index == 512) {
+      lba++;
+      index = 0;
+      if (!cacheRawBlock(lba, CACHE_FOR_WRITE)) goto FAIL;
+      // mirror second FAT
+      if (fatCount_ > 1) cacheMirrorBlock_ = lba + blocksPerFat_;
+    }
+    tmp = value >> 4;
+    if (!(cluster & 1)) {
+      tmp = ((cacheBuffer_.data[index] & 0xF0)) | tmp >> 4;
+    }
+    cacheBuffer_.data[index] = tmp;
+    return true;
+  }
+  if (fatType_ == 16) {
+    lba = fatStartBlock_ + (cluster >> 8);
+  }
+  else if (fatType_ == 32) {
+    lba = fatStartBlock_ + (cluster >> 7);
+  }
+  else {
+    goto FAIL;
+  }
+  if (!cacheRawBlock(lba, CACHE_FOR_WRITE)) goto FAIL;
+  // store entry
+  if (fatType_ == 16) {
+    cacheBuffer_.fat16[cluster & 0xFF] = value;
+  }
+  else {
+    cacheBuffer_.fat32[cluster & 0x7F] = value;
+  }
+  // mirror second FAT
+  if (fatCount_ > 1) cacheMirrorBlock_ = lba + blocksPerFat_;
+  return true;
+  FAIL:
+  return false;
+}
+//------------------------------------------------------------------------------
+// free a cluster chain
+bool SdVolume::freeChain(uint32_t cluster) {
+  uint32_t next;
+
+  // clear free cluster location
+  allocSearchStart_ = 2;
+
+  do {
+    if (!fatGet(cluster, &next)) goto FAIL;
+
+    // free cluster
+    if (!fatPut(cluster, 0)) goto FAIL;
+
+    cluster = next;
+  } while (!isEOC(cluster));
+
+  return true;
+  FAIL:
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Volume free space in clusters.
+ *
+ * \return Count of free clusters for success or -1 if an error occurs.
+ */
+int32_t SdVolume::freeClusterCount() {
+  uint32_t free = 0;
+  uint16_t n;
+  uint32_t todo = clusterCount_ + 2;
+
+  if (fatType_ == 16) {
+    n = 256;
+  }
+  else if (fatType_ == 32) {
+    n = 128;
+  }
+  else {
+    // put FAT12 here
+    return -1;
+  }
+
+  for (uint32_t lba = fatStartBlock_; todo; todo -= n, lba++) {
+    if (!cacheRawBlock(lba, CACHE_FOR_READ)) return -1;
+    NOMORE(n, todo);
+    if (fatType_ == 16) {
+      for (uint16_t i = 0; i < n; i++) {
+        if (cacheBuffer_.fat16[i] == 0) free++;
+      }
+    }
+    else {
+      for (uint16_t i = 0; i < n; i++) {
+        if (cacheBuffer_.fat32[i] == 0) free++;
+      }
+    }
+  }
+  return free;
+}
+//------------------------------------------------------------------------------
+/** Initialize a FAT volume.
+ *
+ * \param[in] dev The SD card where the volume is located.
+ *
+ * \param[in] part The partition to be used.  Legal values for \a part are
+ * 1-4 to use the corresponding partition on a device formatted with
+ * a MBR, Master Boot Record, or zero if the device is formatted as
+ * a super floppy with the FAT boot sector in block zero.
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.  Reasons for
+ * failure include not finding a valid partition, not finding a valid
+ * FAT file system in the specified partition or an I/O error.
+ */
+bool SdVolume::init(Sd2Card* dev, uint8_t part) {
+  uint32_t totalBlocks;
+  uint32_t volumeStartBlock = 0;
+  fat32_boot_t* fbs;
+
+  sdCard_ = dev;
+  fatType_ = 0;
+  allocSearchStart_ = 2;
+  cacheDirty_ = 0;  // cacheFlush() will write block if true
+  cacheMirrorBlock_ = 0;
+  cacheBlockNumber_ = 0xFFFFFFFF;
+
+  // if part == 0 assume super floppy with FAT boot sector in block zero
+  // if part > 0 assume mbr volume with partition table
+  if (part) {
+    if (part > 4)goto FAIL;
+    if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) goto FAIL;
+    part_t* p = &cacheBuffer_.mbr.part[part - 1];
+    if ((p->boot & 0x7F) != 0  ||
+        p->totalSectors < 100 ||
+        p->firstSector == 0) {
+      // not a valid partition
+      goto FAIL;
+    }
+    volumeStartBlock = p->firstSector;
+  }
+  if (!cacheRawBlock(volumeStartBlock, CACHE_FOR_READ)) goto FAIL;
+  fbs = &cacheBuffer_.fbs32;
+  if (fbs->bytesPerSector != 512 ||
+      fbs->fatCount == 0 ||
+      fbs->reservedSectorCount == 0 ||
+      fbs->sectorsPerCluster == 0) {
+    // not valid FAT volume
+    goto FAIL;
+  }
+  fatCount_ = fbs->fatCount;
+  blocksPerCluster_ = fbs->sectorsPerCluster;
+  // determine shift that is same as multiply by blocksPerCluster_
+  clusterSizeShift_ = 0;
+  while (blocksPerCluster_ != _BV(clusterSizeShift_)) {
+    // error if not power of 2
+    if (clusterSizeShift_++ > 7) goto FAIL;
+  }
+  blocksPerFat_ = fbs->sectorsPerFat16 ?
+                  fbs->sectorsPerFat16 : fbs->sectorsPerFat32;
+
+  fatStartBlock_ = volumeStartBlock + fbs->reservedSectorCount;
+
+  // count for FAT16 zero for FAT32
+  rootDirEntryCount_ = fbs->rootDirEntryCount;
+
+  // directory start for FAT16 dataStart for FAT32
+  rootDirStart_ = fatStartBlock_ + fbs->fatCount * blocksPerFat_;
+
+  // data start for FAT16 and FAT32
+  dataStartBlock_ = rootDirStart_ + ((32 * fbs->rootDirEntryCount + 511) / 512);
+
+  // total blocks for FAT16 or FAT32
+  totalBlocks = fbs->totalSectors16 ?
+                fbs->totalSectors16 : fbs->totalSectors32;
+
+  // total data blocks
+  clusterCount_ = totalBlocks - (dataStartBlock_ - volumeStartBlock);
+
+  // divide by cluster size to get cluster count
+  clusterCount_ >>= clusterSizeShift_;
+
+  // FAT type is determined by cluster count
+  if (clusterCount_ < 4085) {
+    fatType_ = 12;
+    if (!FAT12_SUPPORT) goto FAIL;
+  }
+  else if (clusterCount_ < 65525) {
+    fatType_ = 16;
+  }
+  else {
+    rootDirStart_ = fbs->fat32RootCluster;
+    fatType_ = 32;
+  }
+  return true;
+  FAIL:
+  return false;
+}
+#endif
