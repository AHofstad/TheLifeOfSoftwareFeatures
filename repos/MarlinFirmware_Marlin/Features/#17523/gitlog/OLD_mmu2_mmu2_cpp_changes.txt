commit 41529b65988a58ba512977e0fe1692aaeeb6c811
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Wed Nov 18 08:27:21 2020 +0100

    SMUFF (MMU2 clone) support (#19912)

diff --git a/Marlin/src/feature/mmu2/mmu2.cpp b/Marlin/src/feature/mmu2/mmu2.cpp
deleted file mode 100644
index d76476e719..0000000000
--- a/Marlin/src/feature/mmu2/mmu2.cpp
+++ /dev/null
@@ -1,1068 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-#include "../../inc/MarlinConfig.h"
-
-#if ENABLED(PRUSA_MMU2)
-
-#include "mmu2.h"
-#include "../../lcd/menu/menu_mmu2.h"
-
-MMU2 mmu2;
-
-#include "../../gcode/gcode.h"
-#include "../../lcd/marlinui.h"
-#include "../../libs/buzzer.h"
-#include "../../libs/nozzle.h"
-#include "../../module/temperature.h"
-#include "../../module/planner.h"
-#include "../../module/stepper/indirection.h"
-#include "../../MarlinCore.h"
-
-#if ENABLED(HOST_PROMPT_SUPPORT)
-  #include "../../feature/host_actions.h"
-#endif
-
-#if ENABLED(EXTENSIBLE_UI)
-  #include "../../lcd/extui/ui_api.h"
-#endif
-
-#define DEBUG_OUT ENABLED(MMU2_DEBUG)
-#include "../../core/debug_out.h"
-
-#define MMU_TODELAY 100
-#define MMU_TIMEOUT 10
-#define MMU_CMD_TIMEOUT 45000UL // 45s timeout for mmu commands (except P0)
-#define MMU_P0_TIMEOUT 3000UL   // Timeout for P0 command: 3seconds
-
-#define MMU2_COMMAND(S) tx_str_P(PSTR(S "\n"))
-
-#if ENABLED(MMU_EXTRUDER_SENSOR)
-  uint8_t mmu_idl_sens = 0;
-  static bool mmu_loading_flag = false;
-#endif
-
-#define MMU_CMD_NONE 0
-#define MMU_CMD_T0   0x10
-#define MMU_CMD_T1   0x11
-#define MMU_CMD_T2   0x12
-#define MMU_CMD_T3   0x13
-#define MMU_CMD_T4   0x14
-#define MMU_CMD_L0   0x20
-#define MMU_CMD_L1   0x21
-#define MMU_CMD_L2   0x22
-#define MMU_CMD_L3   0x23
-#define MMU_CMD_L4   0x24
-#define MMU_CMD_C0   0x30
-#define MMU_CMD_U0   0x40
-#define MMU_CMD_E0   0x50
-#define MMU_CMD_E1   0x51
-#define MMU_CMD_E2   0x52
-#define MMU_CMD_E3   0x53
-#define MMU_CMD_E4   0x54
-#define MMU_CMD_R0   0x60
-#define MMU_CMD_F0   0x70
-#define MMU_CMD_F1   0x71
-#define MMU_CMD_F2   0x72
-#define MMU_CMD_F3   0x73
-#define MMU_CMD_F4   0x74
-
-#define MMU_REQUIRED_FW_BUILDNR TERN(MMU2_MODE_12V, 132, 126)
-
-#define MMU2_NO_TOOL 99
-#define MMU_BAUD    115200
-
-#define mmuSerial   MMU2_SERIAL
-
-bool MMU2::enabled, MMU2::ready, MMU2::mmu_print_saved;
-#if ENABLED(PRUSA_MMU2_S_MODE)
-  bool MMU2::mmu2s_triggered;
-#endif
-uint8_t MMU2::cmd, MMU2::cmd_arg, MMU2::last_cmd, MMU2::extruder;
-int8_t MMU2::state = 0;
-volatile int8_t MMU2::finda = 1;
-volatile bool MMU2::finda_runout_valid;
-int16_t MMU2::version = -1, MMU2::buildnr = -1;
-millis_t MMU2::prev_request, MMU2::prev_P0_request;
-char MMU2::rx_buffer[MMU_RX_SIZE], MMU2::tx_buffer[MMU_TX_SIZE];
-
-#if BOTH(HAS_LCD_MENU, MMU2_MENUS)
-
-  struct E_Step {
-    float extrude;        //!< extrude distance in mm
-    feedRate_t feedRate;  //!< feed rate in mm/s
-  };
-
-  static constexpr E_Step
-      ramming_sequence[] PROGMEM = { MMU2_RAMMING_SEQUENCE }
-    , load_to_nozzle_sequence[] PROGMEM = { MMU2_LOAD_TO_NOZZLE_SEQUENCE }
-    #if ENABLED(PRUSA_MMU2_S_MODE)
-      , can_load_sequence[] PROGMEM = { MMU2_CAN_LOAD_SEQUENCE }
-      , can_load_increment_sequence[] PROGMEM = { MMU2_CAN_LOAD_INCREMENT_SEQUENCE }
-    #endif
-  ;
-
-#endif // MMU2_MENUS
-
-MMU2::MMU2() {
-  rx_buffer[0] = '\0';
-}
-
-void MMU2::init() {
-
-  set_runout_valid(false);
-
-  #if PIN_EXISTS(MMU2_RST)
-    // TODO use macros for this
-    WRITE(MMU2_RST_PIN, HIGH);
-    SET_OUTPUT(MMU2_RST_PIN);
-  #endif
-
-  mmuSerial.begin(MMU_BAUD);
-  extruder = MMU2_NO_TOOL;
-
-  safe_delay(10);
-  reset();
-  rx_buffer[0] = '\0';
-  state = -1;
-}
-
-void MMU2::reset() {
-  DEBUG_ECHOLNPGM("MMU <= reset");
-
-  #if PIN_EXISTS(MMU2_RST)
-    WRITE(MMU2_RST_PIN, LOW);
-    safe_delay(20);
-    WRITE(MMU2_RST_PIN, HIGH);
-  #else
-    MMU2_COMMAND("X0"); // Send soft reset
-  #endif
-}
-
-uint8_t MMU2::get_current_tool() {
-  return extruder == MMU2_NO_TOOL ? -1 : extruder;
-}
-
-#if EITHER(PRUSA_MMU2_S_MODE, MMU_EXTRUDER_SENSOR)
-  #define FILAMENT_PRESENT() (READ(FIL_RUNOUT1_PIN) != FIL_RUNOUT1_STATE)
-#endif
-
-void MMU2::mmu_loop() {
-
-  switch (state) {
-
-    case 0: break;
-
-    case -1:
-      if (rx_start()) {
-        DEBUG_ECHOLNPGM("MMU => 'start'");
-        DEBUG_ECHOLNPGM("MMU <= 'S1'");
-
-        MMU2_COMMAND("S1");   // Read Version
-        state = -2;
-      }
-      else if (millis() > 3000000) {
-        SERIAL_ECHOLNPGM("MMU not responding - DISABLED");
-        state = 0;
-      }
-      break;
-
-    case -2:
-      if (rx_ok()) {
-        sscanf(rx_buffer, "%uok\n", &version);
-
-        DEBUG_ECHOLNPAIR("MMU => ", version, "\nMMU <= 'S2'");
-
-        MMU2_COMMAND("S2");   // Read Build Number
-        state = -3;
-      }
-      break;
-
-    case -3:
-      if (rx_ok()) {
-        sscanf(rx_buffer, "%uok\n", &buildnr);
-
-        DEBUG_ECHOLNPAIR("MMU => ", buildnr);
-
-        check_version();
-
-        #if ENABLED(MMU2_MODE_12V)
-          DEBUG_ECHOLNPGM("MMU <= 'M1'");
-
-          MMU2_COMMAND("M1");   // Stealth Mode
-          state = -5;
-
-        #else
-          DEBUG_ECHOLNPGM("MMU <= 'P0'");
-
-          MMU2_COMMAND("P0");   // Read FINDA
-          state = -4;
-        #endif
-      }
-      break;
-
-    #if ENABLED(MMU2_MODE_12V)
-    case -5:
-      // response to M1
-      if (rx_ok()) {
-        DEBUG_ECHOLNPGM("MMU => ok");
-
-        DEBUG_ECHOLNPGM("MMU <= 'P0'");
-
-        MMU2_COMMAND("P0");   // Read FINDA
-        state = -4;
-      }
-      break;
-    #endif
-
-    case -4:
-      if (rx_ok()) {
-        sscanf(rx_buffer, "%hhuok\n", &finda);
-
-        DEBUG_ECHOLNPAIR("MMU => ", finda, "\nMMU - ENABLED");
-
-        enabled = true;
-        state = 1;
-        TERN_(PRUSA_MMU2_S_MODE, mmu2s_triggered = false);
-      }
-      break;
-
-    case 1:
-      if (cmd) {
-        if (WITHIN(cmd, MMU_CMD_T0, MMU_CMD_T4)) {
-          // tool change
-          int filament = cmd - MMU_CMD_T0;
-          DEBUG_ECHOLNPAIR("MMU <= T", filament);
-          tx_printf_P(PSTR("T%d\n"), filament);
-          TERN_(MMU_EXTRUDER_SENSOR, mmu_idl_sens = 1); // enable idler sensor, if any
-          state = 3; // wait for response
-        }
-        else if (WITHIN(cmd, MMU_CMD_L0, MMU_CMD_L4)) {
-          // load
-          int filament = cmd - MMU_CMD_L0;
-          DEBUG_ECHOLNPAIR("MMU <= L", filament);
-          tx_printf_P(PSTR("L%d\n"), filament);
-          state = 3; // wait for response
-        }
-        else if (cmd == MMU_CMD_C0) {
-          // continue loading
-          DEBUG_ECHOLNPGM("MMU <= 'C0'");
-          MMU2_COMMAND("C0");
-          state = 3; // wait for response
-        }
-        else if (cmd == MMU_CMD_U0) {
-          // unload current
-          DEBUG_ECHOLNPGM("MMU <= 'U0'");
-
-          MMU2_COMMAND("U0");
-          state = 3; // wait for response
-        }
-        else if (WITHIN(cmd, MMU_CMD_E0, MMU_CMD_E4)) {
-          // eject filament
-          int filament = cmd - MMU_CMD_E0;
-          DEBUG_ECHOLNPAIR("MMU <= E", filament);
-          tx_printf_P(PSTR("E%d\n"), filament);
-          state = 3; // wait for response
-        }
-        else if (cmd == MMU_CMD_R0) {
-          // recover after eject
-          DEBUG_ECHOLNPGM("MMU <= 'R0'");
-          MMU2_COMMAND("R0");
-          state = 3; // wait for response
-        }
-        else if (WITHIN(cmd, MMU_CMD_F0, MMU_CMD_F4)) {
-          // filament type
-          int filament = cmd - MMU_CMD_F0;
-          DEBUG_ECHOPAIR("MMU <= F", filament, " ");
-          DEBUG_ECHO_F(cmd_arg, DEC);
-          DEBUG_EOL();
-          tx_printf_P(PSTR("F%d %d\n"), filament, cmd_arg);
-          state = 3; // wait for response
-        }
-
-        last_cmd = cmd;
-        cmd = MMU_CMD_NONE;
-      }
-      else if (ELAPSED(millis(), prev_P0_request + 300)) {
-        MMU2_COMMAND("P0"); // Read FINDA
-        state = 2; // wait for response
-      }
-
-      TERN_(PRUSA_MMU2_S_MODE, check_filament());
-      break;
-
-    case 2:   // response to command P0
-      if (rx_ok()) {
-        sscanf(rx_buffer, "%hhuok\n", &finda);
-
-        // This is super annoying. Only activate if necessary
-        // if (finda_runout_valid) DEBUG_ECHOLNPAIR_F("MMU <= 'P0'\nMMU => ", finda, 6);
-
-        if (!finda && finda_runout_valid) filament_runout();
-        if (cmd == 0) ready = true;
-        state = 1;
-      }
-      else if (ELAPSED(millis(), prev_request + MMU_P0_TIMEOUT)) // Resend request after timeout (3s)
-        state = 1;
-
-      TERN_(PRUSA_MMU2_S_MODE, check_filament());
-      break;
-
-    case 3:   // response to mmu commands
-      #if ENABLED(MMU_EXTRUDER_SENSOR)
-        if (mmu_idl_sens) {
-          if (FILAMENT_PRESENT() && mmu_loading_flag) {
-            DEBUG_ECHOLNPGM("MMU <= 'A'");
-            MMU2_COMMAND("A"); // send 'abort' request
-            mmu_idl_sens = 0;
-            DEBUG_ECHOLNPGM("MMU IDLER_SENSOR = 0 - ABORT");
-          }
-        }
-      #endif
-
-      if (rx_ok()) {
-        // Response to C0 mmu command in PRUSA_MMU2_S_MODE
-        bool can_reset = true;
-        #if ENABLED(PRUSA_MMU2_S_MODE)
-          if (!mmu2s_triggered && last_cmd == MMU_CMD_C0) {
-            can_reset = false;
-            // MMU ok received but filament sensor not triggered, retrying...
-            DEBUG_ECHOLNPGM("MMU => 'ok' (filament not present in gears)");
-            DEBUG_ECHOLNPGM("MMU <= 'C0' (keep trying)");
-            MMU2_COMMAND("C0");
-          }
-        #endif
-        if (can_reset) {
-          DEBUG_ECHOLNPGM("MMU => 'ok'");
-          ready = true;
-          state = 1;
-          last_cmd = MMU_CMD_NONE;
-        }
-      }
-      else if (ELAPSED(millis(), prev_request + MMU_CMD_TIMEOUT)) {
-        // resend request after timeout
-        if (last_cmd) {
-          DEBUG_ECHOLNPGM("MMU retry");
-          cmd = last_cmd;
-          last_cmd = MMU_CMD_NONE;
-        }
-        state = 1;
-      }
-      TERN_(PRUSA_MMU2_S_MODE, check_filament());
-      break;
-  }
-}
-
-/**
- * Check if MMU was started
- */
-bool MMU2::rx_start() {
-  // check for start message
-  if (rx_str_P(PSTR("start\n"))) {
-    prev_P0_request = millis();
-    return true;
-  }
-  return false;
-}
-
-/**
- * Check if the data received ends with the given string.
- */
-bool MMU2::rx_str_P(const char* str) {
-  uint8_t i = strlen(rx_buffer);
-
-  while (mmuSerial.available()) {
-    rx_buffer[i++] = mmuSerial.read();
-    rx_buffer[i] = '\0';
-
-    if (i == sizeof(rx_buffer) - 1) {
-      DEBUG_ECHOLNPGM("rx buffer overrun");
-      break;
-    }
-  }
-
-  uint8_t len = strlen_P(str);
-
-  if (i < len) return false;
-
-  str += len;
-
-  while (len--) {
-    char c0 = pgm_read_byte(str--), c1 = rx_buffer[i--];
-    if (c0 == c1) continue;
-    if (c0 == '\r' && c1 == '\n') continue;  // match cr as lf
-    if (c0 == '\n' && c1 == '\r') continue;  // match lf as cr
-    return false;
-  }
-  return true;
-}
-
-/**
- * Transfer data to MMU, no argument
- */
-void MMU2::tx_str_P(const char* str) {
-  clear_rx_buffer();
-  uint8_t len = strlen_P(str);
-  LOOP_L_N(i, len) mmuSerial.write(pgm_read_byte(str++));
-  rx_buffer[0] = '\0';
-  prev_request = millis();
-}
-
-/**
- * Transfer data to MMU, single argument
- */
-void MMU2::tx_printf_P(const char* format, int argument = -1) {
-  clear_rx_buffer();
-  uint8_t len = sprintf_P(tx_buffer, format, argument);
-  LOOP_L_N(i, len) mmuSerial.write(tx_buffer[i]);
-  rx_buffer[0] = '\0';
-  prev_request = millis();
-}
-
-/**
- * Transfer data to MMU, two arguments
- */
-void MMU2::tx_printf_P(const char* format, int argument1, int argument2) {
-  clear_rx_buffer();
-  uint8_t len = sprintf_P(tx_buffer, format, argument1, argument2);
-  LOOP_L_N(i, len) mmuSerial.write(tx_buffer[i]);
-  rx_buffer[0] = '\0';
-  prev_request = millis();
-}
-
-/**
- * Empty the rx buffer
- */
-void MMU2::clear_rx_buffer() {
-  while (mmuSerial.available()) mmuSerial.read();
-  rx_buffer[0] = '\0';
-}
-
-/**
- * Check if we received 'ok' from MMU
- */
-bool MMU2::rx_ok() {
-  if (rx_str_P(PSTR("ok\n"))) {
-    prev_P0_request = millis();
-    return true;
-  }
-  return false;
-}
-
-/**
- * Check if MMU has compatible firmware
- */
-void MMU2::check_version() {
-  if (buildnr < MMU_REQUIRED_FW_BUILDNR) {
-    SERIAL_ERROR_MSG("Invalid MMU2 firmware. Version >= " STRINGIFY(MMU_REQUIRED_FW_BUILDNR) " required.");
-    kill(GET_TEXT(MSG_KILL_MMU2_FIRMWARE));
-  }
-}
-
-static void mmu2_not_responding() {
-  LCD_MESSAGEPGM(MSG_MMU2_NOT_RESPONDING);
-  BUZZ(100, 659);
-  BUZZ(200, 698);
-  BUZZ(100, 659);
-  BUZZ(300, 440);
-  BUZZ(100, 659);
-}
-
-#if ENABLED(PRUSA_MMU2_S_MODE)
-
-  bool MMU2::load_to_gears() {
-    command(MMU_CMD_C0);
-    manage_response(true, true);
-    LOOP_L_N(i, MMU2_C0_RETRY) {  // Keep loading until filament reaches gears
-      if (mmu2s_triggered) break;
-      command(MMU_CMD_C0);
-      manage_response(true, true);
-      check_filament();
-    }
-    const bool success = mmu2s_triggered && can_load();
-    if (!success) mmu2_not_responding();
-    return success;
-  }
-
-  /**
-   * Handle tool change
-   */
-  void MMU2::tool_change(const uint8_t index) {
-
-    if (!enabled) return;
-
-    set_runout_valid(false);
-
-    if (index != extruder) {
-
-      DISABLE_AXIS_E0();
-      ui.status_printf_P(0, GET_TEXT(MSG_MMU2_LOADING_FILAMENT), int(index + 1));
-
-      command(MMU_CMD_T0 + index);
-      manage_response(true, true);
-
-      if (load_to_gears()) {
-        extruder = index; // filament change is finished
-        active_extruder = 0;
-        ENABLE_AXIS_E0();
-        SERIAL_ECHO_START();
-        SERIAL_ECHOLNPAIR(STR_ACTIVE_EXTRUDER, int(extruder));
-      }
-      ui.reset_status();
-    }
-
-    set_runout_valid(true);
-  }
-
-  /**
-   * Handle special T?/Tx/Tc commands
-   *
-   * T? Gcode to extrude shouldn't have to follow, load to extruder wheels is done automatically
-   * Tx Same as T?, except nozzle doesn't have to be preheated. Tc must be placed after extruder nozzle is preheated to finish filament load.
-   * Tc Load to nozzle after filament was prepared by Tx and extruder nozzle is already heated.
-   */
-  void MMU2::tool_change(const char* special) {
-
-    if (!enabled) return;
-
-    #if ENABLED(MMU2_MENUS)
-
-      set_runout_valid(false);
-
-      switch (*special) {
-        case '?': {
-          uint8_t index = mmu2_choose_filament();
-          while (!thermalManager.wait_for_hotend(active_extruder, false)) safe_delay(100);
-          load_filament_to_nozzle(index);
-        } break;
-
-        case 'x': {
-          planner.synchronize();
-          uint8_t index = mmu2_choose_filament();
-          DISABLE_AXIS_E0();
-          command(MMU_CMD_T0 + index);
-          manage_response(true, true);
-
-          if (load_to_gears()) {
-            mmu_loop();
-            ENABLE_AXIS_E0();
-            extruder = index;
-            active_extruder = 0;
-          }
-        } break;
-
-        case 'c': {
-          while (!thermalManager.wait_for_hotend(active_extruder, false)) safe_delay(100);
-          execute_extruder_sequence((const E_Step *)load_to_nozzle_sequence, COUNT(load_to_nozzle_sequence));
-        } break;
-      }
-
-      set_runout_valid(true);
-
-    #endif // MMU2_MENUS
-  }
-
-#elif ENABLED(MMU_EXTRUDER_SENSOR)
-
-  /**
-   * Handle tool change
-   */
-  void MMU2::tool_change(const uint8_t index) {
-    if (!enabled) return;
-
-    set_runout_valid(false);
-
-    if (index != extruder) {
-      DISABLE_AXIS_E0();
-      if (FILAMENT_PRESENT()) {
-        DEBUG_ECHOLNPGM("Unloading\n");
-        mmu_loading_flag = false;
-        command(MMU_CMD_U0);
-        manage_response(true, true);
-      }
-      ui.status_printf_P(0, GET_TEXT(MSG_MMU2_LOADING_FILAMENT), int(index + 1));
-      mmu_loading_flag = true;
-      command(MMU_CMD_T0 + index);
-      manage_response(true, true);
-      mmu_continue_loading();
-      command(MMU_CMD_C0);
-      extruder = index;
-      active_extruder = 0;
-
-      ENABLE_AXIS_E0();
-      SERIAL_ECHO_START();
-      SERIAL_ECHOLNPAIR(STR_ACTIVE_EXTRUDER, int(extruder));
-
-      ui.reset_status();
-    }
-
-    set_runout_valid(true);
-  }
-
-  /**
-   * Handle special T?/Tx/Tc commands
-   *
-   * T? Gcode to extrude shouldn't have to follow, load to extruder wheels is done automatically
-   * Tx Same as T?, except nozzle doesn't have to be preheated. Tc must be placed after extruder nozzle is preheated to finish filament load.
-   * Tc Load to nozzle after filament was prepared by Tx and extruder nozzle is already heated.
-   */
-  void MMU2::tool_change(const char* special) {
-    if (!enabled) return;
-
-    #if ENABLED(MMU2_MENUS)
-
-      set_runout_valid(false);
-
-      switch (*special) {
-        case '?': {
-          DEBUG_ECHOLNPGM("case ?\n");
-          uint8_t index = mmu2_choose_filament();
-          while (!thermalManager.wait_for_hotend(active_extruder, false)) safe_delay(100);
-          load_filament_to_nozzle(index);
-        } break;
-
-        case 'x': {
-          DEBUG_ECHOLNPGM("case x\n");
-          planner.synchronize();
-          uint8_t index = mmu2_choose_filament();
-          DISABLE_AXIS_E0();
-          command(MMU_CMD_T0 + index);
-          manage_response(true, true);
-          mmu_continue_loading();
-          command(MMU_CMD_C0);
-          mmu_loop();
-
-          ENABLE_AXIS_E0();
-          extruder = index;
-          active_extruder = 0;
-        } break;
-
-        case 'c': {
-          DEBUG_ECHOLNPGM("case c\n");
-          while (!thermalManager.wait_for_hotend(active_extruder, false)) safe_delay(100);
-          execute_extruder_sequence((const E_Step *)load_to_nozzle_sequence, COUNT(load_to_nozzle_sequence));
-        } break;
-      }
-
-      set_runout_valid(true);
-
-    #endif // MMU2_MENUS
-  }
-
-  void MMU2::mmu_continue_loading() {
-    for (uint8_t i = 0; i < MMU_LOADING_ATTEMPTS_NR; i++) {
-      DEBUG_ECHOLNPAIR("Additional load attempt #", i);
-      if (FILAMENT_PRESENT()) break;
-      command(MMU_CMD_C0);
-      manage_response(true, true);
-    }
-    if (!FILAMENT_PRESENT()) {
-      DEBUG_ECHOLNPGM("Filament never reached sensor, runout");
-      filament_runout();
-    }
-    mmu_idl_sens = 0;
-  }
-
-#elif DISABLED(MMU_EXTRUDER_SENSOR) && DISABLED(PRUSA_MMU2_S_MODE)
-
-/**
- * Handle tool change
- */
-void MMU2::tool_change(const uint8_t index) {
-  if (!enabled) return;
-
-  set_runout_valid(false);
-
-  if (index != extruder) {
-    DISABLE_AXIS_E0();
-    ui.status_printf_P(0, GET_TEXT(MSG_MMU2_LOADING_FILAMENT), int(index + 1));
-    command(MMU_CMD_T0 + index);
-    manage_response(true, true);
-    command(MMU_CMD_C0);
-    extruder = index; //filament change is finished
-    active_extruder = 0;
-    ENABLE_AXIS_E0();
-    SERIAL_ECHO_START();
-    SERIAL_ECHOLNPAIR(STR_ACTIVE_EXTRUDER, int(extruder));
-    ui.reset_status();
-  }
-
-  set_runout_valid(true);
-}
-
-/**
- * Handle special T?/Tx/Tc commands
- *
- * T? Gcode to extrude shouldn't have to follow, load to extruder wheels is done automatically
- * Tx Same as T?, except nozzle doesn't have to be preheated. Tc must be placed after extruder nozzle is preheated to finish filament load.
- * Tc Load to nozzle after filament was prepared by Tx and extruder nozzle is already heated.
- */
-void MMU2::tool_change(const char* special) {
-  if (!enabled) return;
-
-  #if ENABLED(MMU2_MENUS)
-
-    set_runout_valid(false);
-
-    switch (*special) {
-      case '?': {
-        DEBUG_ECHOLNPGM("case ?\n");
-        uint8_t index = mmu2_choose_filament();
-        while (!thermalManager.wait_for_hotend(active_extruder, false)) safe_delay(100);
-        load_filament_to_nozzle(index);
-      } break;
-
-      case 'x': {
-        DEBUG_ECHOLNPGM("case x\n");
-        planner.synchronize();
-        uint8_t index = mmu2_choose_filament();
-        DISABLE_AXIS_E0();
-        command(MMU_CMD_T0 + index);
-        manage_response(true, true);
-        command(MMU_CMD_C0);
-        mmu_loop();
-
-        ENABLE_AXIS_E0();
-        extruder = index;
-        active_extruder = 0;
-      } break;
-
-      case 'c': {
-        DEBUG_ECHOLNPGM("case c\n");
-        while (!thermalManager.wait_for_hotend(active_extruder, false)) safe_delay(100);
-        execute_extruder_sequence((const E_Step *)load_to_nozzle_sequence, COUNT(load_to_nozzle_sequence));
-      } break;
-    }
-
-    set_runout_valid(true);
-
-  #endif
-  }
-
-#endif // MMU_EXTRUDER_SENSOR
-
-/**
- * Set next command
- */
-void MMU2::command(const uint8_t mmu_cmd) {
-  if (!enabled) return;
-  cmd = mmu_cmd;
-  ready = false;
-}
-
-/**
- * Wait for response from MMU
- */
-bool MMU2::get_response() {
-  while (cmd != MMU_CMD_NONE) idle();
-
-  while (!ready) {
-    idle();
-    if (state != 3) break;
-  }
-
-  const bool ret = ready;
-  ready = false;
-
-  return ret;
-}
-
-/**
- * Wait for response and deal with timeout if nexcessary
- */
-void MMU2::manage_response(const bool move_axes, const bool turn_off_nozzle) {
-
-  constexpr xyz_pos_t park_point = NOZZLE_PARK_POINT;
-  bool response = false;
-  mmu_print_saved = false;
-  xyz_pos_t resume_position;
-  int16_t resume_hotend_temp = thermalManager.degTargetHotend(active_extruder);
-
-  KEEPALIVE_STATE(PAUSED_FOR_USER);
-
-  while (!response) {
-
-    response = get_response(); // wait for "ok" from mmu
-
-    if (!response) {          // No "ok" was received in reserved time frame, user will fix the issue on mmu unit
-      if (!mmu_print_saved) { // First occurrence. Save current position, park print head, disable nozzle heater.
-
-        planner.synchronize();
-
-        mmu_print_saved = true;
-
-        SERIAL_ECHOLNPGM("MMU not responding");
-
-        resume_hotend_temp = thermalManager.degTargetHotend(active_extruder);
-        resume_position = current_position;
-
-        if (move_axes && all_axes_homed())
-          nozzle.park(0, park_point /*= NOZZLE_PARK_POINT*/);
-
-        if (turn_off_nozzle) thermalManager.setTargetHotend(0, active_extruder);
-
-        mmu2_not_responding();
-      }
-    }
-    else if (mmu_print_saved) {
-      SERIAL_ECHOLNPGM("MMU starts responding\n");
-
-      if (turn_off_nozzle && resume_hotend_temp) {
-        thermalManager.setTargetHotend(resume_hotend_temp, active_extruder);
-        LCD_MESSAGEPGM(MSG_HEATING);
-        BUZZ(200, 40);
-
-        while (!thermalManager.wait_for_hotend(active_extruder, false)) safe_delay(1000);
-      }
-
-      if (move_axes && all_axes_homed()) {
-        LCD_MESSAGEPGM(MSG_MMU2_RESUMING);
-        BUZZ(198, 404); BUZZ(4, 0); BUZZ(198, 404);
-
-        // Move XY to starting position, then Z
-        do_blocking_move_to_xy(resume_position, feedRate_t(NOZZLE_PARK_XY_FEEDRATE));
-
-        // Move Z_AXIS to saved position
-        do_blocking_move_to_z(resume_position.z, feedRate_t(NOZZLE_PARK_Z_FEEDRATE));
-      }
-      else {
-        BUZZ(198, 404); BUZZ(4, 0); BUZZ(198, 404);
-        LCD_MESSAGEPGM(MSG_MMU2_RESUMING);
-      }
-    }
-  }
-}
-
-void MMU2::set_filament_type(const uint8_t index, const uint8_t filamentType) {
-  if (!enabled) return;
-
-  cmd_arg = filamentType;
-  command(MMU_CMD_F0 + index);
-
-  manage_response(true, true);
-}
-
-void MMU2::filament_runout() {
-  queue.inject_P(PSTR(MMU2_FILAMENT_RUNOUT_SCRIPT));
-  planner.synchronize();
-}
-
-#if ENABLED(PRUSA_MMU2_S_MODE)
-
-  void MMU2::check_filament() {
-    const bool present = FILAMENT_PRESENT();
-    if (cmd == MMU_CMD_NONE && last_cmd == MMU_CMD_C0) {
-      if (present && !mmu2s_triggered) {
-        DEBUG_ECHOLNPGM("MMU <= 'A'");
-        tx_str_P(PSTR("A\n"));
-      }
-      // Slowly spin the extruder during C0
-      else {
-        while (planner.movesplanned() < 3) {
-          current_position.e += 0.25;
-          line_to_current_position(MMM_TO_MMS(120));
-        }
-      }
-    }
-    mmu2s_triggered = present;
-  }
-
-  bool MMU2::can_load() {
-    execute_extruder_sequence((const E_Step *)can_load_sequence, COUNT(can_load_sequence));
-
-    int filament_detected_count = 0;
-    const int steps = (MMU2_CAN_LOAD_RETRACT) / (MMU2_CAN_LOAD_INCREMENT);
-    DEBUG_ECHOLNPGM("MMU can_load:");
-    LOOP_L_N(i, steps) {
-      execute_extruder_sequence((const E_Step *)can_load_increment_sequence, COUNT(can_load_increment_sequence));
-      check_filament(); // Don't trust the idle function
-      DEBUG_CHAR(mmu2s_triggered ? 'O' : 'o');
-      if (mmu2s_triggered) ++filament_detected_count;
-    }
-
-    if (filament_detected_count <= steps - (MMU2_CAN_LOAD_DEVIATION) / (MMU2_CAN_LOAD_INCREMENT)) {
-      DEBUG_ECHOLNPGM(" failed.");
-      return false;
-    }
-
-    DEBUG_ECHOLNPGM(" succeeded.");
-    return true;
-  }
-#endif
-
-#if BOTH(HAS_LCD_MENU, MMU2_MENUS)
-
-  // Load filament into MMU2
-  void MMU2::load_filament(const uint8_t index) {
-    if (!enabled) return;
-    command(MMU_CMD_L0 + index);
-    manage_response(false, false);
-    BUZZ(200, 404);
-  }
-
-  /**
-   * Switch material and load to nozzle
-   */
-  bool MMU2::load_filament_to_nozzle(const uint8_t index) {
-
-    if (!enabled) return false;
-
-    if (thermalManager.tooColdToExtrude(active_extruder)) {
-      BUZZ(200, 404);
-      LCD_ALERTMESSAGEPGM(MSG_HOTEND_TOO_COLD);
-      return false;
-    }
-
-    command(MMU_CMD_T0 + index);
-    manage_response(true, true);
-
-    const bool success = load_to_gears();
-    if (success) {
-      mmu_loop();
-      extruder = index;
-      active_extruder = 0;
-      load_to_nozzle();
-      BUZZ(200, 404);
-    }
-    return success;
-  }
-
-  /**
-   * Load filament to nozzle of multimaterial printer
-   *
-   * This function is used only only after T? (user select filament) and M600 (change filament).
-   * It is not used after T0 .. T4 command (select filament), in such case, gcode is responsible for loading
-   * filament to nozzle.
-   */
-  void MMU2::load_to_nozzle() {
-    if (!enabled) return;
-    execute_extruder_sequence((const E_Step *)load_to_nozzle_sequence, COUNT(load_to_nozzle_sequence));
-  }
-
-  bool MMU2::eject_filament(const uint8_t index, const bool recover) {
-
-    if (!enabled) return false;
-
-    if (thermalManager.tooColdToExtrude(active_extruder)) {
-      BUZZ(200, 404);
-      LCD_ALERTMESSAGEPGM(MSG_HOTEND_TOO_COLD);
-      return false;
-    }
-
-    LCD_MESSAGEPGM(MSG_MMU2_EJECTING_FILAMENT);
-
-    ENABLE_AXIS_E0();
-    current_position.e -= MMU2_FILAMENTCHANGE_EJECT_FEED;
-    line_to_current_position(2500 / 60);
-    planner.synchronize();
-    command(MMU_CMD_E0 + index);
-    manage_response(false, false);
-
-    if (recover)  {
-      LCD_MESSAGEPGM(MSG_MMU2_EJECT_RECOVER);
-      BUZZ(200, 404);
-      TERN_(HOST_PROMPT_SUPPORT, host_prompt_do(PROMPT_USER_CONTINUE, PSTR("MMU2 Eject Recover"), CONTINUE_STR));
-      TERN_(EXTENSIBLE_UI, ExtUI::onUserConfirmRequired_P(PSTR("MMU2 Eject Recover")));
-      wait_for_user_response();
-      BUZZ(200, 404);
-      BUZZ(200, 404);
-
-      command(MMU_CMD_R0);
-      manage_response(false, false);
-    }
-
-    ui.reset_status();
-
-    // no active tool
-    extruder = MMU2_NO_TOOL;
-
-    set_runout_valid(false);
-
-    BUZZ(200, 404);
-
-    DISABLE_AXIS_E0();
-
-    return true;
-  }
-
-  /**
-   * Unload from hotend and retract to MMU
-   */
-  bool MMU2::unload() {
-
-    if (!enabled) return false;
-
-    if (thermalManager.tooColdToExtrude(active_extruder)) {
-      BUZZ(200, 404);
-      LCD_ALERTMESSAGEPGM(MSG_HOTEND_TOO_COLD);
-      return false;
-    }
-
-    filament_ramming();
-
-    command(MMU_CMD_U0);
-    manage_response(false, true);
-
-    BUZZ(200, 404);
-
-    // no active tool
-    extruder = MMU2_NO_TOOL;
-
-    set_runout_valid(false);
-
-    return true;
-  }
-
-  /**
-   * Unload sequence to optimize shape of the tip of the unloaded filament
-   */
-  void MMU2::filament_ramming() {
-    execute_extruder_sequence((const E_Step *)ramming_sequence, sizeof(ramming_sequence) / sizeof(E_Step));
-  }
-
-  void MMU2::execute_extruder_sequence(const E_Step * sequence, int steps) {
-
-    planner.synchronize();
-    ENABLE_AXIS_E0();
-
-    const E_Step* step = sequence;
-
-    LOOP_L_N(i, steps) {
-      const float es = pgm_read_float(&(step->extrude));
-      const feedRate_t fr_mm_m = pgm_read_float(&(step->feedRate));
-
-      DEBUG_ECHO_START();
-      DEBUG_ECHOLNPAIR("E step ", es, "/", fr_mm_m);
-
-      current_position.e += es;
-      line_to_current_position(MMM_TO_MMS(fr_mm_m));
-      planner.synchronize();
-
-      step++;
-    }
-
-    DISABLE_AXIS_E0();
-  }
-
-#endif // HAS_LCD_MENU && MMU2_MENUS
-
-#endif // PRUSA_MMU2

commit 0465e0ae3aaec257618d095f7e2b28ef677dbe4a
Author: Costas Basdekis <costas.basdekis@gmail.com>
Date:   Wed Nov 11 06:39:23 2020 +0000

    Distinct runout states (#19965)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/feature/mmu2/mmu2.cpp b/Marlin/src/feature/mmu2/mmu2.cpp
index c5cf485850..d76476e719 100644
--- a/Marlin/src/feature/mmu2/mmu2.cpp
+++ b/Marlin/src/feature/mmu2/mmu2.cpp
@@ -163,7 +163,7 @@ uint8_t MMU2::get_current_tool() {
 }
 
 #if EITHER(PRUSA_MMU2_S_MODE, MMU_EXTRUDER_SENSOR)
-  #define FILAMENT_PRESENT() (READ(FIL_RUNOUT_PIN) != FIL_RUNOUT_STATE)
+  #define FILAMENT_PRESENT() (READ(FIL_RUNOUT1_PIN) != FIL_RUNOUT1_STATE)
 #endif
 
 void MMU2::mmu_loop() {

commit eaf6777a6643a6fab23ceaaa4699cb2466ea6b83
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Oct 16 19:36:25 2020 -0500

    Rename ultralcd => marlinui

diff --git a/Marlin/src/feature/mmu2/mmu2.cpp b/Marlin/src/feature/mmu2/mmu2.cpp
index 3d635369e4..c5cf485850 100644
--- a/Marlin/src/feature/mmu2/mmu2.cpp
+++ b/Marlin/src/feature/mmu2/mmu2.cpp
@@ -30,7 +30,7 @@
 MMU2 mmu2;
 
 #include "../../gcode/gcode.h"
-#include "../../lcd/ultralcd.h"
+#include "../../lcd/marlinui.h"
 #include "../../libs/buzzer.h"
 #include "../../libs/nozzle.h"
 #include "../../module/temperature.h"

commit 2e1ba73926eeac126dd345b32f40c5b5d4804462
Author: ellensp <ellensp@hotmail.com>
Date:   Sat Oct 3 11:12:17 2020 +1300

    Fix compile of MMU2 with S-mode disabled (#19584)

diff --git a/Marlin/src/feature/mmu2/mmu2.cpp b/Marlin/src/feature/mmu2/mmu2.cpp
index 37a2404c33..3d635369e4 100644
--- a/Marlin/src/feature/mmu2/mmu2.cpp
+++ b/Marlin/src/feature/mmu2/mmu2.cpp
@@ -340,17 +340,17 @@ void MMU2::mmu_loop() {
       #endif
 
       if (rx_ok()) {
-        // response to C0 mmu command in PRUSA_MMU2_S_MODE
+        // Response to C0 mmu command in PRUSA_MMU2_S_MODE
         bool can_reset = true;
-        if (ENABLED(PRUSA_MMU2_S_MODE) && last_cmd == MMU_CMD_C0) {
-          if (!mmu2s_triggered) {
+        #if ENABLED(PRUSA_MMU2_S_MODE)
+          if (!mmu2s_triggered && last_cmd == MMU_CMD_C0) {
             can_reset = false;
             // MMU ok received but filament sensor not triggered, retrying...
             DEBUG_ECHOLNPGM("MMU => 'ok' (filament not present in gears)");
             DEBUG_ECHOLNPGM("MMU <= 'C0' (keep trying)");
             MMU2_COMMAND("C0");
           }
-        }
+        #endif
         if (can_reset) {
           DEBUG_ECHOLNPGM("MMU => 'ok'");
           ready = true;

commit 4424645e04c9e75462d36de8f7a82e67cc9c262e
Author: qwewer0 <57561110+qwewer0@users.noreply.github.com>
Date:   Mon Sep 28 21:53:50 2020 +0200

    Multi-line comments cleanup (#19535)

diff --git a/Marlin/src/feature/mmu2/mmu2.cpp b/Marlin/src/feature/mmu2/mmu2.cpp
index 31fa529d56..37a2404c33 100644
--- a/Marlin/src/feature/mmu2/mmu2.cpp
+++ b/Marlin/src/feature/mmu2/mmu2.cpp
@@ -710,13 +710,11 @@ void MMU2::tool_change(const uint8_t index) {
 }
 
 /**
- *
  * Handle special T?/Tx/Tc commands
  *
  * T? Gcode to extrude shouldn't have to follow, load to extruder wheels is done automatically
  * Tx Same as T?, except nozzle doesn't have to be preheated. Tc must be placed after extruder nozzle is preheated to finish filament load.
  * Tc Load to nozzle after filament was prepared by Tx and extruder nozzle is already heated.
- *
  */
 void MMU2::tool_change(const char* special) {
   if (!enabled) return;
@@ -922,9 +920,7 @@ void MMU2::filament_runout() {
   }
 
   /**
-   *
    * Switch material and load to nozzle
-   *
    */
   bool MMU2::load_filament_to_nozzle(const uint8_t index) {
 

commit 4975e93350ee46aad323aa985f5c53e735aa26cf
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 27 02:01:56 2020 -0500

    Tweak MMU beeps, misc. cleanup

diff --git a/Marlin/src/feature/mmu2/mmu2.cpp b/Marlin/src/feature/mmu2/mmu2.cpp
index 31b179a3e5..31fa529d56 100644
--- a/Marlin/src/feature/mmu2/mmu2.cpp
+++ b/Marlin/src/feature/mmu2/mmu2.cpp
@@ -838,8 +838,7 @@ void MMU2::manage_response(const bool move_axes, const bool turn_off_nozzle) {
 
       if (move_axes && all_axes_homed()) {
         LCD_MESSAGEPGM(MSG_MMU2_RESUMING);
-        BUZZ(200, 404);
-        BUZZ(200, 404);
+        BUZZ(198, 404); BUZZ(4, 0); BUZZ(198, 404);
 
         // Move XY to starting position, then Z
         do_blocking_move_to_xy(resume_position, feedRate_t(NOZZLE_PARK_XY_FEEDRATE));
@@ -848,8 +847,7 @@ void MMU2::manage_response(const bool move_axes, const bool turn_off_nozzle) {
         do_blocking_move_to_z(resume_position.z, feedRate_t(NOZZLE_PARK_Z_FEEDRATE));
       }
       else {
-        BUZZ(200, 404);
-        BUZZ(200, 404);
+        BUZZ(198, 404); BUZZ(4, 0); BUZZ(198, 404);
         LCD_MESSAGEPGM(MSG_MMU2_RESUMING);
       }
     }

commit 88d7f4d7be744ecfecdb531cb48ae42a02403cef
Author: Trocololo <isanchez@neuda.net>
Date:   Sat Sep 26 03:28:01 2020 +0200

    MMU2 S Mode spins the BMG gears during C0 (#19429)

diff --git a/Marlin/src/feature/mmu2/mmu2.cpp b/Marlin/src/feature/mmu2/mmu2.cpp
index 35f2db45a9..31b179a3e5 100644
--- a/Marlin/src/feature/mmu2/mmu2.cpp
+++ b/Marlin/src/feature/mmu2/mmu2.cpp
@@ -54,6 +54,8 @@ MMU2 mmu2;
 #define MMU_CMD_TIMEOUT 45000UL // 45s timeout for mmu commands (except P0)
 #define MMU_P0_TIMEOUT 3000UL   // Timeout for P0 command: 3seconds
 
+#define MMU2_COMMAND(S) tx_str_P(PSTR(S "\n"))
+
 #if ENABLED(MMU_EXTRUDER_SENSOR)
   uint8_t mmu_idl_sens = 0;
   static bool mmu_loading_flag = false;
@@ -152,7 +154,7 @@ void MMU2::reset() {
     safe_delay(20);
     WRITE(MMU2_RST_PIN, HIGH);
   #else
-    tx_str_P(PSTR("X0\n")); // Send soft reset
+    MMU2_COMMAND("X0"); // Send soft reset
   #endif
 }
 
@@ -175,9 +177,7 @@ void MMU2::mmu_loop() {
         DEBUG_ECHOLNPGM("MMU => 'start'");
         DEBUG_ECHOLNPGM("MMU <= 'S1'");
 
-        // send "read version" request
-        tx_str_P(PSTR("S1\n"));
-
+        MMU2_COMMAND("S1");   // Read Version
         state = -2;
       }
       else if (millis() > 3000000) {
@@ -192,7 +192,7 @@ void MMU2::mmu_loop() {
 
         DEBUG_ECHOLNPAIR("MMU => ", version, "\nMMU <= 'S2'");
 
-        tx_str_P(PSTR("S2\n")); // read build number
+        MMU2_COMMAND("S2");   // Read Build Number
         state = -3;
       }
       break;
@@ -208,13 +208,13 @@ void MMU2::mmu_loop() {
         #if ENABLED(MMU2_MODE_12V)
           DEBUG_ECHOLNPGM("MMU <= 'M1'");
 
-          tx_str_P(PSTR("M1\n")); // switch to stealth mode
+          MMU2_COMMAND("M1");   // Stealth Mode
           state = -5;
 
         #else
           DEBUG_ECHOLNPGM("MMU <= 'P0'");
 
-          tx_str_P(PSTR("P0\n")); // read finda
+          MMU2_COMMAND("P0");   // Read FINDA
           state = -4;
         #endif
       }
@@ -228,7 +228,7 @@ void MMU2::mmu_loop() {
 
         DEBUG_ECHOLNPGM("MMU <= 'P0'");
 
-        tx_str_P(PSTR("P0\n")); // read finda
+        MMU2_COMMAND("P0");   // Read FINDA
         state = -4;
       }
       break;
@@ -266,14 +266,14 @@ void MMU2::mmu_loop() {
         else if (cmd == MMU_CMD_C0) {
           // continue loading
           DEBUG_ECHOLNPGM("MMU <= 'C0'");
-          tx_str_P(PSTR("C0\n"));
+          MMU2_COMMAND("C0");
           state = 3; // wait for response
         }
         else if (cmd == MMU_CMD_U0) {
           // unload current
           DEBUG_ECHOLNPGM("MMU <= 'U0'");
 
-          tx_str_P(PSTR("U0\n"));
+          MMU2_COMMAND("U0");
           state = 3; // wait for response
         }
         else if (WITHIN(cmd, MMU_CMD_E0, MMU_CMD_E4)) {
@@ -286,7 +286,7 @@ void MMU2::mmu_loop() {
         else if (cmd == MMU_CMD_R0) {
           // recover after eject
           DEBUG_ECHOLNPGM("MMU <= 'R0'");
-          tx_str_P(PSTR("R0\n"));
+          MMU2_COMMAND("R0");
           state = 3; // wait for response
         }
         else if (WITHIN(cmd, MMU_CMD_F0, MMU_CMD_F4)) {
@@ -303,8 +303,7 @@ void MMU2::mmu_loop() {
         cmd = MMU_CMD_NONE;
       }
       else if (ELAPSED(millis(), prev_P0_request + 300)) {
-        // read FINDA
-        tx_str_P(PSTR("P0\n"));
+        MMU2_COMMAND("P0"); // Read FINDA
         state = 2; // wait for response
       }
 
@@ -332,19 +331,32 @@ void MMU2::mmu_loop() {
       #if ENABLED(MMU_EXTRUDER_SENSOR)
         if (mmu_idl_sens) {
           if (FILAMENT_PRESENT() && mmu_loading_flag) {
-            DEBUG_ECHOLNPGM("MMU <= 'A'\n");
-            tx_str_P(PSTR("A\n")); // send 'abort' request
+            DEBUG_ECHOLNPGM("MMU <= 'A'");
+            MMU2_COMMAND("A"); // send 'abort' request
             mmu_idl_sens = 0;
-            DEBUG_ECHOLNPGM("MMU IDLER_SENSOR = 0 - ABORT\n");
+            DEBUG_ECHOLNPGM("MMU IDLER_SENSOR = 0 - ABORT");
           }
         }
       #endif
 
       if (rx_ok()) {
-        DEBUG_ECHOLNPGM("MMU => 'ok'");
-        ready = true;
-        state = 1;
-        last_cmd = MMU_CMD_NONE;
+        // response to C0 mmu command in PRUSA_MMU2_S_MODE
+        bool can_reset = true;
+        if (ENABLED(PRUSA_MMU2_S_MODE) && last_cmd == MMU_CMD_C0) {
+          if (!mmu2s_triggered) {
+            can_reset = false;
+            // MMU ok received but filament sensor not triggered, retrying...
+            DEBUG_ECHOLNPGM("MMU => 'ok' (filament not present in gears)");
+            DEBUG_ECHOLNPGM("MMU <= 'C0' (keep trying)");
+            MMU2_COMMAND("C0");
+          }
+        }
+        if (can_reset) {
+          DEBUG_ECHOLNPGM("MMU => 'ok'");
+          ready = true;
+          state = 1;
+          last_cmd = MMU_CMD_NONE;
+        }
       }
       else if (ELAPSED(millis(), prev_request + MMU_CMD_TIMEOUT)) {
         // resend request after timeout
@@ -862,9 +874,18 @@ void MMU2::filament_runout() {
 
   void MMU2::check_filament() {
     const bool present = FILAMENT_PRESENT();
-    if (present && !mmu2s_triggered) {
-      DEBUG_ECHOLNPGM("MMU <= 'A'");
-      tx_str_P(PSTR("A\n"));
+    if (cmd == MMU_CMD_NONE && last_cmd == MMU_CMD_C0) {
+      if (present && !mmu2s_triggered) {
+        DEBUG_ECHOLNPGM("MMU <= 'A'");
+        tx_str_P(PSTR("A\n"));
+      }
+      // Slowly spin the extruder during C0
+      else {
+        while (planner.movesplanned() < 3) {
+          current_position.e += 0.25;
+          line_to_current_position(MMM_TO_MMS(120));
+        }
+      }
     }
     mmu2s_triggered = present;
   }

commit 2c61e6ba2802919ec8c2caacc34865335464098f
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Thu Jul 23 22:27:40 2020 -0400

    Add CONTROLLER_FAN_IGNORE_Z (#18735)

diff --git a/Marlin/src/feature/mmu2/mmu2.cpp b/Marlin/src/feature/mmu2/mmu2.cpp
index aeff7918dd..35f2db45a9 100644
--- a/Marlin/src/feature/mmu2/mmu2.cpp
+++ b/Marlin/src/feature/mmu2/mmu2.cpp
@@ -466,7 +466,7 @@ void MMU2::check_version() {
   }
 }
 
-static bool mmu2_not_responding() {
+static void mmu2_not_responding() {
   LCD_MESSAGEPGM(MSG_MMU2_NOT_RESPONDING);
   BUZZ(100, 659);
   BUZZ(200, 698);

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/feature/mmu2/mmu2.cpp b/Marlin/src/feature/mmu2/mmu2.cpp
index e082d847da..aeff7918dd 100644
--- a/Marlin/src/feature/mmu2/mmu2.cpp
+++ b/Marlin/src/feature/mmu2/mmu2.cpp
@@ -16,7 +16,7 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 

commit c02451b602d6ee24d09f4f41269c85c0972a2279
Author: Robby Candra <robbycandra.mail@gmail.com>
Date:   Mon Jul 6 05:42:19 2020 +0700

    Filament Runout Inverting => State (#18537)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/feature/mmu2/mmu2.cpp b/Marlin/src/feature/mmu2/mmu2.cpp
index 2ddfd72647..e082d847da 100644
--- a/Marlin/src/feature/mmu2/mmu2.cpp
+++ b/Marlin/src/feature/mmu2/mmu2.cpp
@@ -161,7 +161,7 @@ uint8_t MMU2::get_current_tool() {
 }
 
 #if EITHER(PRUSA_MMU2_S_MODE, MMU_EXTRUDER_SENSOR)
-  #define FILAMENT_PRESENT() (READ(FIL_RUNOUT_PIN) != FIL_RUNOUT_INVERTING)
+  #define FILAMENT_PRESENT() (READ(FIL_RUNOUT_PIN) != FIL_RUNOUT_STATE)
 #endif
 
 void MMU2::mmu_loop() {

commit 2ec482a10263fbf6eaca7c8cbeb51d20bbe2be18
Author: Bastien R <bastien.rossi@icloud.com>
Date:   Sun May 17 21:52:45 2020 +0200

    MMU2 Extruder Sensor support (#17886)

diff --git a/Marlin/src/feature/mmu2/mmu2.cpp b/Marlin/src/feature/mmu2/mmu2.cpp
index 6c61b714f7..2ddfd72647 100644
--- a/Marlin/src/feature/mmu2/mmu2.cpp
+++ b/Marlin/src/feature/mmu2/mmu2.cpp
@@ -51,8 +51,13 @@ MMU2 mmu2;
 
 #define MMU_TODELAY 100
 #define MMU_TIMEOUT 10
-#define MMU_CMD_TIMEOUT 60000ul // 5min timeout for mmu commands (except P0)
-#define MMU_P0_TIMEOUT 3000ul   // Timeout for P0 command: 3seconds
+#define MMU_CMD_TIMEOUT 45000UL // 45s timeout for mmu commands (except P0)
+#define MMU_P0_TIMEOUT 3000UL   // Timeout for P0 command: 3seconds
+
+#if ENABLED(MMU_EXTRUDER_SENSOR)
+  uint8_t mmu_idl_sens = 0;
+  static bool mmu_loading_flag = false;
+#endif
 
 #define MMU_CMD_NONE 0
 #define MMU_CMD_T0   0x10
@@ -79,11 +84,7 @@ MMU2 mmu2;
 #define MMU_CMD_F3   0x73
 #define MMU_CMD_F4   0x74
 
-#if ENABLED(MMU2_MODE_12V)
-  #define MMU_REQUIRED_FW_BUILDNR 132
-#else
-  #define MMU_REQUIRED_FW_BUILDNR 126
-#endif
+#define MMU_REQUIRED_FW_BUILDNR TERN(MMU2_MODE_12V, 132, 126)
 
 #define MMU2_NO_TOOL 99
 #define MMU_BAUD    115200
@@ -99,7 +100,7 @@ int8_t MMU2::state = 0;
 volatile int8_t MMU2::finda = 1;
 volatile bool MMU2::finda_runout_valid;
 int16_t MMU2::version = -1, MMU2::buildnr = -1;
-millis_t MMU2::last_request, MMU2::next_P0_request;
+millis_t MMU2::prev_request, MMU2::prev_P0_request;
 char MMU2::rx_buffer[MMU_RX_SIZE], MMU2::tx_buffer[MMU_TX_SIZE];
 
 #if BOTH(HAS_LCD_MENU, MMU2_MENUS)
@@ -159,6 +160,10 @@ uint8_t MMU2::get_current_tool() {
   return extruder == MMU2_NO_TOOL ? -1 : extruder;
 }
 
+#if EITHER(PRUSA_MMU2_S_MODE, MMU_EXTRUDER_SENSOR)
+  #define FILAMENT_PRESENT() (READ(FIL_RUNOUT_PIN) != FIL_RUNOUT_INVERTING)
+#endif
+
 void MMU2::mmu_loop() {
 
   switch (state) {
@@ -248,6 +253,7 @@ void MMU2::mmu_loop() {
           int filament = cmd - MMU_CMD_T0;
           DEBUG_ECHOLNPAIR("MMU <= T", filament);
           tx_printf_P(PSTR("T%d\n"), filament);
+          TERN_(MMU_EXTRUDER_SENSOR, mmu_idl_sens = 1); // enable idler sensor, if any
           state = 3; // wait for response
         }
         else if (WITHIN(cmd, MMU_CMD_L0, MMU_CMD_L4)) {
@@ -296,7 +302,7 @@ void MMU2::mmu_loop() {
         last_cmd = cmd;
         cmd = MMU_CMD_NONE;
       }
-      else if (ELAPSED(millis(), next_P0_request)) {
+      else if (ELAPSED(millis(), prev_P0_request + 300)) {
         // read FINDA
         tx_str_P(PSTR("P0\n"));
         state = 2; // wait for response
@@ -312,26 +318,35 @@ void MMU2::mmu_loop() {
         // This is super annoying. Only activate if necessary
         // if (finda_runout_valid) DEBUG_ECHOLNPAIR_F("MMU <= 'P0'\nMMU => ", finda, 6);
 
-        state = 1;
-
-        if (cmd == 0) ready = true;
-
         if (!finda && finda_runout_valid) filament_runout();
+        if (cmd == 0) ready = true;
+        state = 1;
       }
-      else if (ELAPSED(millis(), last_request + MMU_P0_TIMEOUT)) // Resend request after timeout (3s)
+      else if (ELAPSED(millis(), prev_request + MMU_P0_TIMEOUT)) // Resend request after timeout (3s)
         state = 1;
 
       TERN_(PRUSA_MMU2_S_MODE, check_filament());
       break;
 
     case 3:   // response to mmu commands
+      #if ENABLED(MMU_EXTRUDER_SENSOR)
+        if (mmu_idl_sens) {
+          if (FILAMENT_PRESENT() && mmu_loading_flag) {
+            DEBUG_ECHOLNPGM("MMU <= 'A'\n");
+            tx_str_P(PSTR("A\n")); // send 'abort' request
+            mmu_idl_sens = 0;
+            DEBUG_ECHOLNPGM("MMU IDLER_SENSOR = 0 - ABORT\n");
+          }
+        }
+      #endif
+
       if (rx_ok()) {
         DEBUG_ECHOLNPGM("MMU => 'ok'");
         ready = true;
         state = 1;
         last_cmd = MMU_CMD_NONE;
       }
-      else if (ELAPSED(millis(), last_request + MMU_CMD_TIMEOUT)) {
+      else if (ELAPSED(millis(), prev_request + MMU_CMD_TIMEOUT)) {
         // resend request after timeout
         if (last_cmd) {
           DEBUG_ECHOLNPGM("MMU retry");
@@ -351,7 +366,7 @@ void MMU2::mmu_loop() {
 bool MMU2::rx_start() {
   // check for start message
   if (rx_str_P(PSTR("start\n"))) {
-    next_P0_request = millis() + 300;
+    prev_P0_request = millis();
     return true;
   }
   return false;
@@ -397,7 +412,7 @@ void MMU2::tx_str_P(const char* str) {
   uint8_t len = strlen_P(str);
   LOOP_L_N(i, len) mmuSerial.write(pgm_read_byte(str++));
   rx_buffer[0] = '\0';
-  last_request = millis();
+  prev_request = millis();
 }
 
 /**
@@ -408,7 +423,7 @@ void MMU2::tx_printf_P(const char* format, int argument = -1) {
   uint8_t len = sprintf_P(tx_buffer, format, argument);
   LOOP_L_N(i, len) mmuSerial.write(tx_buffer[i]);
   rx_buffer[0] = '\0';
-  last_request = millis();
+  prev_request = millis();
 }
 
 /**
@@ -419,7 +434,7 @@ void MMU2::tx_printf_P(const char* format, int argument1, int argument2) {
   uint8_t len = sprintf_P(tx_buffer, format, argument1, argument2);
   LOOP_L_N(i, len) mmuSerial.write(tx_buffer[i]);
   rx_buffer[0] = '\0';
-  last_request = millis();
+  prev_request = millis();
 }
 
 /**
@@ -435,7 +450,7 @@ void MMU2::clear_rx_buffer() {
  */
 bool MMU2::rx_ok() {
   if (rx_str_P(PSTR("ok\n"))) {
-    next_P0_request = millis() + 300;
+    prev_P0_request = millis();
     return true;
   }
   return false;
@@ -476,32 +491,206 @@ static bool mmu2_not_responding() {
     return success;
   }
 
-#endif
+  /**
+   * Handle tool change
+   */
+  void MMU2::tool_change(const uint8_t index) {
+
+    if (!enabled) return;
+
+    set_runout_valid(false);
+
+    if (index != extruder) {
+
+      DISABLE_AXIS_E0();
+      ui.status_printf_P(0, GET_TEXT(MSG_MMU2_LOADING_FILAMENT), int(index + 1));
+
+      command(MMU_CMD_T0 + index);
+      manage_response(true, true);
+
+      if (load_to_gears()) {
+        extruder = index; // filament change is finished
+        active_extruder = 0;
+        ENABLE_AXIS_E0();
+        SERIAL_ECHO_START();
+        SERIAL_ECHOLNPAIR(STR_ACTIVE_EXTRUDER, int(extruder));
+      }
+      ui.reset_status();
+    }
+
+    set_runout_valid(true);
+  }
+
+  /**
+   * Handle special T?/Tx/Tc commands
+   *
+   * T? Gcode to extrude shouldn't have to follow, load to extruder wheels is done automatically
+   * Tx Same as T?, except nozzle doesn't have to be preheated. Tc must be placed after extruder nozzle is preheated to finish filament load.
+   * Tc Load to nozzle after filament was prepared by Tx and extruder nozzle is already heated.
+   */
+  void MMU2::tool_change(const char* special) {
+
+    if (!enabled) return;
+
+    #if ENABLED(MMU2_MENUS)
+
+      set_runout_valid(false);
+
+      switch (*special) {
+        case '?': {
+          uint8_t index = mmu2_choose_filament();
+          while (!thermalManager.wait_for_hotend(active_extruder, false)) safe_delay(100);
+          load_filament_to_nozzle(index);
+        } break;
+
+        case 'x': {
+          planner.synchronize();
+          uint8_t index = mmu2_choose_filament();
+          DISABLE_AXIS_E0();
+          command(MMU_CMD_T0 + index);
+          manage_response(true, true);
+
+          if (load_to_gears()) {
+            mmu_loop();
+            ENABLE_AXIS_E0();
+            extruder = index;
+            active_extruder = 0;
+          }
+        } break;
+
+        case 'c': {
+          while (!thermalManager.wait_for_hotend(active_extruder, false)) safe_delay(100);
+          execute_extruder_sequence((const E_Step *)load_to_nozzle_sequence, COUNT(load_to_nozzle_sequence));
+        } break;
+      }
+
+      set_runout_valid(true);
+
+    #endif // MMU2_MENUS
+  }
+
+#elif ENABLED(MMU_EXTRUDER_SENSOR)
+
+  /**
+   * Handle tool change
+   */
+  void MMU2::tool_change(const uint8_t index) {
+    if (!enabled) return;
+
+    set_runout_valid(false);
+
+    if (index != extruder) {
+      DISABLE_AXIS_E0();
+      if (FILAMENT_PRESENT()) {
+        DEBUG_ECHOLNPGM("Unloading\n");
+        mmu_loading_flag = false;
+        command(MMU_CMD_U0);
+        manage_response(true, true);
+      }
+      ui.status_printf_P(0, GET_TEXT(MSG_MMU2_LOADING_FILAMENT), int(index + 1));
+      mmu_loading_flag = true;
+      command(MMU_CMD_T0 + index);
+      manage_response(true, true);
+      mmu_continue_loading();
+      command(MMU_CMD_C0);
+      extruder = index;
+      active_extruder = 0;
+
+      ENABLE_AXIS_E0();
+      SERIAL_ECHO_START();
+      SERIAL_ECHOLNPAIR(STR_ACTIVE_EXTRUDER, int(extruder));
+
+      ui.reset_status();
+    }
+
+    set_runout_valid(true);
+  }
+
+  /**
+   * Handle special T?/Tx/Tc commands
+   *
+   * T? Gcode to extrude shouldn't have to follow, load to extruder wheels is done automatically
+   * Tx Same as T?, except nozzle doesn't have to be preheated. Tc must be placed after extruder nozzle is preheated to finish filament load.
+   * Tc Load to nozzle after filament was prepared by Tx and extruder nozzle is already heated.
+   */
+  void MMU2::tool_change(const char* special) {
+    if (!enabled) return;
+
+    #if ENABLED(MMU2_MENUS)
+
+      set_runout_valid(false);
+
+      switch (*special) {
+        case '?': {
+          DEBUG_ECHOLNPGM("case ?\n");
+          uint8_t index = mmu2_choose_filament();
+          while (!thermalManager.wait_for_hotend(active_extruder, false)) safe_delay(100);
+          load_filament_to_nozzle(index);
+        } break;
+
+        case 'x': {
+          DEBUG_ECHOLNPGM("case x\n");
+          planner.synchronize();
+          uint8_t index = mmu2_choose_filament();
+          DISABLE_AXIS_E0();
+          command(MMU_CMD_T0 + index);
+          manage_response(true, true);
+          mmu_continue_loading();
+          command(MMU_CMD_C0);
+          mmu_loop();
+
+          ENABLE_AXIS_E0();
+          extruder = index;
+          active_extruder = 0;
+        } break;
+
+        case 'c': {
+          DEBUG_ECHOLNPGM("case c\n");
+          while (!thermalManager.wait_for_hotend(active_extruder, false)) safe_delay(100);
+          execute_extruder_sequence((const E_Step *)load_to_nozzle_sequence, COUNT(load_to_nozzle_sequence));
+        } break;
+      }
+
+      set_runout_valid(true);
+
+    #endif // MMU2_MENUS
+  }
+
+  void MMU2::mmu_continue_loading() {
+    for (uint8_t i = 0; i < MMU_LOADING_ATTEMPTS_NR; i++) {
+      DEBUG_ECHOLNPAIR("Additional load attempt #", i);
+      if (FILAMENT_PRESENT()) break;
+      command(MMU_CMD_C0);
+      manage_response(true, true);
+    }
+    if (!FILAMENT_PRESENT()) {
+      DEBUG_ECHOLNPGM("Filament never reached sensor, runout");
+      filament_runout();
+    }
+    mmu_idl_sens = 0;
+  }
+
+#elif DISABLED(MMU_EXTRUDER_SENSOR) && DISABLED(PRUSA_MMU2_S_MODE)
 
 /**
  * Handle tool change
  */
-void MMU2::tool_change(uint8_t index) {
-
+void MMU2::tool_change(const uint8_t index) {
   if (!enabled) return;
 
   set_runout_valid(false);
 
   if (index != extruder) {
-
     DISABLE_AXIS_E0();
     ui.status_printf_P(0, GET_TEXT(MSG_MMU2_LOADING_FILAMENT), int(index + 1));
-
     command(MMU_CMD_T0 + index);
     manage_response(true, true);
-
-    if (load_to_gears()) {
-      extruder = index; // filament change is finished
-      active_extruder = 0;
-      ENABLE_AXIS_E0();
-      SERIAL_ECHO_START();
-      SERIAL_ECHOLNPAIR(STR_ACTIVE_EXTRUDER, int(extruder));
-    }
+    command(MMU_CMD_C0);
+    extruder = index; //filament change is finished
+    active_extruder = 0;
+    ENABLE_AXIS_E0();
+    SERIAL_ECHO_START();
+    SERIAL_ECHOLNPAIR(STR_ACTIVE_EXTRUDER, int(extruder));
     ui.reset_status();
   }
 
@@ -518,7 +707,6 @@ void MMU2::tool_change(uint8_t index) {
  *
  */
 void MMU2::tool_change(const char* special) {
-
   if (!enabled) return;
 
   #if ENABLED(MMU2_MENUS)
@@ -527,27 +715,29 @@ void MMU2::tool_change(const char* special) {
 
     switch (*special) {
       case '?': {
+        DEBUG_ECHOLNPGM("case ?\n");
         uint8_t index = mmu2_choose_filament();
         while (!thermalManager.wait_for_hotend(active_extruder, false)) safe_delay(100);
         load_filament_to_nozzle(index);
       } break;
 
       case 'x': {
+        DEBUG_ECHOLNPGM("case x\n");
         planner.synchronize();
         uint8_t index = mmu2_choose_filament();
         DISABLE_AXIS_E0();
         command(MMU_CMD_T0 + index);
         manage_response(true, true);
+        command(MMU_CMD_C0);
+        mmu_loop();
 
-        if (load_to_gears()) {
-          mmu_loop();
-          ENABLE_AXIS_E0();
-          extruder = index;
-          active_extruder = 0;
-        }
+        ENABLE_AXIS_E0();
+        extruder = index;
+        active_extruder = 0;
       } break;
 
       case 'c': {
+        DEBUG_ECHOLNPGM("case c\n");
         while (!thermalManager.wait_for_hotend(active_extruder, false)) safe_delay(100);
         execute_extruder_sequence((const E_Step *)load_to_nozzle_sequence, COUNT(load_to_nozzle_sequence));
       } break;
@@ -556,7 +746,9 @@ void MMU2::tool_change(const char* special) {
     set_runout_valid(true);
 
   #endif
-}
+  }
+
+#endif // MMU_EXTRUDER_SENSOR
 
 /**
  * Set next command
@@ -593,7 +785,7 @@ void MMU2::manage_response(const bool move_axes, const bool turn_off_nozzle) {
   bool response = false;
   mmu_print_saved = false;
   xyz_pos_t resume_position;
-  int16_t resume_hotend_temp;
+  int16_t resume_hotend_temp = thermalManager.degTargetHotend(active_extruder);
 
   KEEPALIVE_STATE(PAUSED_FOR_USER);
 
@@ -652,7 +844,7 @@ void MMU2::manage_response(const bool move_axes, const bool turn_off_nozzle) {
   }
 }
 
-void MMU2::set_filament_type(uint8_t index, uint8_t filamentType) {
+void MMU2::set_filament_type(const uint8_t index, const uint8_t filamentType) {
   if (!enabled) return;
 
   cmd_arg = filamentType;
@@ -667,20 +859,21 @@ void MMU2::filament_runout() {
 }
 
 #if ENABLED(PRUSA_MMU2_S_MODE)
+
   void MMU2::check_filament() {
-    const bool runout = READ(FIL_RUNOUT_PIN) ^ (FIL_RUNOUT_INVERTING);
-    if (runout && !mmu2s_triggered) {
+    const bool present = FILAMENT_PRESENT();
+    if (present && !mmu2s_triggered) {
       DEBUG_ECHOLNPGM("MMU <= 'A'");
       tx_str_P(PSTR("A\n"));
     }
-    mmu2s_triggered = runout;
+    mmu2s_triggered = present;
   }
 
   bool MMU2::can_load() {
     execute_extruder_sequence((const E_Step *)can_load_sequence, COUNT(can_load_sequence));
 
     int filament_detected_count = 0;
-    const int steps = MMU2_CAN_LOAD_RETRACT / MMU2_CAN_LOAD_INCREMENT;
+    const int steps = (MMU2_CAN_LOAD_RETRACT) / (MMU2_CAN_LOAD_INCREMENT);
     DEBUG_ECHOLNPGM("MMU can_load:");
     LOOP_L_N(i, steps) {
       execute_extruder_sequence((const E_Step *)can_load_increment_sequence, COUNT(can_load_increment_sequence));
@@ -689,7 +882,7 @@ void MMU2::filament_runout() {
       if (mmu2s_triggered) ++filament_detected_count;
     }
 
-    if (filament_detected_count <= steps - (MMU2_CAN_LOAD_DEVIATION / MMU2_CAN_LOAD_INCREMENT)) {
+    if (filament_detected_count <= steps - (MMU2_CAN_LOAD_DEVIATION) / (MMU2_CAN_LOAD_INCREMENT)) {
       DEBUG_ECHOLNPGM(" failed.");
       return false;
     }
@@ -702,7 +895,7 @@ void MMU2::filament_runout() {
 #if BOTH(HAS_LCD_MENU, MMU2_MENUS)
 
   // Load filament into MMU2
-  void MMU2::load_filament(uint8_t index) {
+  void MMU2::load_filament(const uint8_t index) {
     if (!enabled) return;
     command(MMU_CMD_L0 + index);
     manage_response(false, false);
@@ -714,7 +907,7 @@ void MMU2::filament_runout() {
    * Switch material and load to nozzle
    *
    */
-  bool MMU2::load_filament_to_nozzle(uint8_t index) {
+  bool MMU2::load_filament_to_nozzle(const uint8_t index) {
 
     if (!enabled) return false;
 
@@ -739,7 +932,6 @@ void MMU2::filament_runout() {
   }
 
   /**
-   *
    * Load filament to nozzle of multimaterial printer
    *
    * This function is used only only after T? (user select filament) and M600 (change filament).
@@ -751,7 +943,7 @@ void MMU2::filament_runout() {
     execute_extruder_sequence((const E_Step *)load_to_nozzle_sequence, COUNT(load_to_nozzle_sequence));
   }
 
-  bool MMU2::eject_filament(uint8_t index, bool recover) {
+  bool MMU2::eject_filament(const uint8_t index, const bool recover) {
 
     if (!enabled) return false;
 
@@ -798,9 +990,7 @@ void MMU2::filament_runout() {
   }
 
   /**
-   *
-   * unload from hotend and retract to MMU
-   *
+   * Unload from hotend and retract to MMU
    */
   bool MMU2::unload() {
 

commit 2c959123e5972920bfb40ac519bfaa5b0b7c6d67
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Apr 28 04:31:59 2020 -0500

    Clean up whitespace

diff --git a/Marlin/src/feature/mmu2/mmu2.cpp b/Marlin/src/feature/mmu2/mmu2.cpp
index 3bb5d9e7ee..6c61b714f7 100644
--- a/Marlin/src/feature/mmu2/mmu2.cpp
+++ b/Marlin/src/feature/mmu2/mmu2.cpp
@@ -301,7 +301,7 @@ void MMU2::mmu_loop() {
         tx_str_P(PSTR("P0\n"));
         state = 2; // wait for response
       }
-      
+
       TERN_(PRUSA_MMU2_S_MODE, check_filament());
       break;
 
@@ -672,13 +672,13 @@ void MMU2::filament_runout() {
     if (runout && !mmu2s_triggered) {
       DEBUG_ECHOLNPGM("MMU <= 'A'");
       tx_str_P(PSTR("A\n"));
-    } 
+    }
     mmu2s_triggered = runout;
   }
 
   bool MMU2::can_load() {
     execute_extruder_sequence((const E_Step *)can_load_sequence, COUNT(can_load_sequence));
-    
+
     int filament_detected_count = 0;
     const int steps = MMU2_CAN_LOAD_RETRACT / MMU2_CAN_LOAD_INCREMENT;
     DEBUG_ECHOLNPGM("MMU can_load:");
@@ -689,7 +689,7 @@ void MMU2::filament_runout() {
       if (mmu2s_triggered) ++filament_detected_count;
     }
 
-    if (filament_detected_count <= steps - (MMU2_CAN_LOAD_DEVIATION / MMU2_CAN_LOAD_INCREMENT)) { 
+    if (filament_detected_count <= steps - (MMU2_CAN_LOAD_DEVIATION / MMU2_CAN_LOAD_INCREMENT)) {
       DEBUG_ECHOLNPGM(" failed.");
       return false;
     }

commit 21067ab06217835d232e9610d8dace2d243428ba
Author: Toni <fuzzelfish+github@gmail.com>
Date:   Sun Apr 26 04:07:21 2020 +0200

    Add Prusa MMU2S settings - beta (#17523)

diff --git a/Marlin/src/feature/mmu2/mmu2.cpp b/Marlin/src/feature/mmu2/mmu2.cpp
index e0b738c5ff..3bb5d9e7ee 100644
--- a/Marlin/src/feature/mmu2/mmu2.cpp
+++ b/Marlin/src/feature/mmu2/mmu2.cpp
@@ -91,6 +91,9 @@ MMU2 mmu2;
 #define mmuSerial   MMU2_SERIAL
 
 bool MMU2::enabled, MMU2::ready, MMU2::mmu_print_saved;
+#if ENABLED(PRUSA_MMU2_S_MODE)
+  bool MMU2::mmu2s_triggered;
+#endif
 uint8_t MMU2::cmd, MMU2::cmd_arg, MMU2::last_cmd, MMU2::extruder;
 int8_t MMU2::state = 0;
 volatile int8_t MMU2::finda = 1;
@@ -106,8 +109,14 @@ char MMU2::rx_buffer[MMU_RX_SIZE], MMU2::tx_buffer[MMU_TX_SIZE];
     feedRate_t feedRate;  //!< feed rate in mm/s
   };
 
-  static constexpr E_Step ramming_sequence[] PROGMEM = { MMU2_RAMMING_SEQUENCE };
-  static constexpr E_Step load_to_nozzle_sequence[] PROGMEM = { MMU2_LOAD_TO_NOZZLE_SEQUENCE };
+  static constexpr E_Step
+      ramming_sequence[] PROGMEM = { MMU2_RAMMING_SEQUENCE }
+    , load_to_nozzle_sequence[] PROGMEM = { MMU2_LOAD_TO_NOZZLE_SEQUENCE }
+    #if ENABLED(PRUSA_MMU2_S_MODE)
+      , can_load_sequence[] PROGMEM = { MMU2_CAN_LOAD_SEQUENCE }
+      , can_load_increment_sequence[] PROGMEM = { MMU2_CAN_LOAD_INCREMENT_SEQUENCE }
+    #endif
+  ;
 
 #endif // MMU2_MENUS
 
@@ -228,6 +237,7 @@ void MMU2::mmu_loop() {
 
         enabled = true;
         state = 1;
+        TERN_(PRUSA_MMU2_S_MODE, mmu2s_triggered = false);
       }
       break;
 
@@ -291,6 +301,8 @@ void MMU2::mmu_loop() {
         tx_str_P(PSTR("P0\n"));
         state = 2; // wait for response
       }
+      
+      TERN_(PRUSA_MMU2_S_MODE, check_filament());
       break;
 
     case 2:   // response to command P0
@@ -309,6 +321,7 @@ void MMU2::mmu_loop() {
       else if (ELAPSED(millis(), last_request + MMU_P0_TIMEOUT)) // Resend request after timeout (3s)
         state = 1;
 
+      TERN_(PRUSA_MMU2_S_MODE, check_filament());
       break;
 
     case 3:   // response to mmu commands
@@ -327,6 +340,7 @@ void MMU2::mmu_loop() {
         }
         state = 1;
       }
+      TERN_(PRUSA_MMU2_S_MODE, check_filament());
       break;
   }
 }
@@ -437,6 +451,33 @@ void MMU2::check_version() {
   }
 }
 
+static bool mmu2_not_responding() {
+  LCD_MESSAGEPGM(MSG_MMU2_NOT_RESPONDING);
+  BUZZ(100, 659);
+  BUZZ(200, 698);
+  BUZZ(100, 659);
+  BUZZ(300, 440);
+  BUZZ(100, 659);
+}
+
+#if ENABLED(PRUSA_MMU2_S_MODE)
+
+  bool MMU2::load_to_gears() {
+    command(MMU_CMD_C0);
+    manage_response(true, true);
+    LOOP_L_N(i, MMU2_C0_RETRY) {  // Keep loading until filament reaches gears
+      if (mmu2s_triggered) break;
+      command(MMU_CMD_C0);
+      manage_response(true, true);
+      check_filament();
+    }
+    const bool success = mmu2s_triggered && can_load();
+    if (!success) mmu2_not_responding();
+    return success;
+  }
+
+#endif
+
 /**
  * Handle tool change
  */
@@ -452,18 +493,15 @@ void MMU2::tool_change(uint8_t index) {
     ui.status_printf_P(0, GET_TEXT(MSG_MMU2_LOADING_FILAMENT), int(index + 1));
 
     command(MMU_CMD_T0 + index);
-
     manage_response(true, true);
 
-    command(MMU_CMD_C0);
-    extruder = index; //filament change is finished
-    active_extruder = 0;
-
-    ENABLE_AXIS_E0();
-
-    SERIAL_ECHO_START();
-    SERIAL_ECHOLNPAIR(STR_ACTIVE_EXTRUDER, int(extruder));
-
+    if (load_to_gears()) {
+      extruder = index; // filament change is finished
+      active_extruder = 0;
+      ENABLE_AXIS_E0();
+      SERIAL_ECHO_START();
+      SERIAL_ECHOLNPAIR(STR_ACTIVE_EXTRUDER, int(extruder));
+    }
     ui.reset_status();
   }
 
@@ -500,12 +538,13 @@ void MMU2::tool_change(const char* special) {
         DISABLE_AXIS_E0();
         command(MMU_CMD_T0 + index);
         manage_response(true, true);
-        command(MMU_CMD_C0);
-        mmu_loop();
 
-        ENABLE_AXIS_E0();
-        extruder = index;
-        active_extruder = 0;
+        if (load_to_gears()) {
+          mmu_loop();
+          ENABLE_AXIS_E0();
+          extruder = index;
+          active_extruder = 0;
+        }
       } break;
 
       case 'c': {
@@ -579,12 +618,7 @@ void MMU2::manage_response(const bool move_axes, const bool turn_off_nozzle) {
 
         if (turn_off_nozzle) thermalManager.setTargetHotend(0, active_extruder);
 
-        LCD_MESSAGEPGM(MSG_MMU2_NOT_RESPONDING);
-        BUZZ(100, 659);
-        BUZZ(200, 698);
-        BUZZ(100, 659);
-        BUZZ(300, 440);
-        BUZZ(100, 659);
+        mmu2_not_responding();
       }
     }
     else if (mmu_print_saved) {
@@ -632,6 +666,39 @@ void MMU2::filament_runout() {
   planner.synchronize();
 }
 
+#if ENABLED(PRUSA_MMU2_S_MODE)
+  void MMU2::check_filament() {
+    const bool runout = READ(FIL_RUNOUT_PIN) ^ (FIL_RUNOUT_INVERTING);
+    if (runout && !mmu2s_triggered) {
+      DEBUG_ECHOLNPGM("MMU <= 'A'");
+      tx_str_P(PSTR("A\n"));
+    } 
+    mmu2s_triggered = runout;
+  }
+
+  bool MMU2::can_load() {
+    execute_extruder_sequence((const E_Step *)can_load_sequence, COUNT(can_load_sequence));
+    
+    int filament_detected_count = 0;
+    const int steps = MMU2_CAN_LOAD_RETRACT / MMU2_CAN_LOAD_INCREMENT;
+    DEBUG_ECHOLNPGM("MMU can_load:");
+    LOOP_L_N(i, steps) {
+      execute_extruder_sequence((const E_Step *)can_load_increment_sequence, COUNT(can_load_increment_sequence));
+      check_filament(); // Don't trust the idle function
+      DEBUG_CHAR(mmu2s_triggered ? 'O' : 'o');
+      if (mmu2s_triggered) ++filament_detected_count;
+    }
+
+    if (filament_detected_count <= steps - (MMU2_CAN_LOAD_DEVIATION / MMU2_CAN_LOAD_INCREMENT)) { 
+      DEBUG_ECHOLNPGM(" failed.");
+      return false;
+    }
+
+    DEBUG_ECHOLNPGM(" succeeded.");
+    return true;
+  }
+#endif
+
 #if BOTH(HAS_LCD_MENU, MMU2_MENUS)
 
   // Load filament into MMU2
@@ -656,20 +723,19 @@ void MMU2::filament_runout() {
       LCD_ALERTMESSAGEPGM(MSG_HOTEND_TOO_COLD);
       return false;
     }
-    else {
-      command(MMU_CMD_T0 + index);
-      manage_response(true, true);
-      command(MMU_CMD_C0);
-      mmu_loop();
 
+    command(MMU_CMD_T0 + index);
+    manage_response(true, true);
+
+    const bool success = load_to_gears();
+    if (success) {
+      mmu_loop();
       extruder = index;
       active_extruder = 0;
-
       load_to_nozzle();
-
       BUZZ(200, 404);
-      return true;
     }
+    return success;
   }
 
   /**

commit d2a5d51f69ff35961d65577f4855e63d123381fd
Author: Ondej Nov <ondrej.novy@firma.seznam.cz>
Date:   Sat Apr 25 05:39:08 2020 +0200

    Add NOZZLE_PARK_Z_RAISE_MIN (#17624)

diff --git a/Marlin/src/feature/mmu2/mmu2.cpp b/Marlin/src/feature/mmu2/mmu2.cpp
index b69557e689..e0b738c5ff 100644
--- a/Marlin/src/feature/mmu2/mmu2.cpp
+++ b/Marlin/src/feature/mmu2/mmu2.cpp
@@ -575,7 +575,7 @@ void MMU2::manage_response(const bool move_axes, const bool turn_off_nozzle) {
         resume_position = current_position;
 
         if (move_axes && all_axes_homed())
-          nozzle.park(2, park_point /*= NOZZLE_PARK_POINT*/);
+          nozzle.park(0, park_point /*= NOZZLE_PARK_POINT*/);
 
         if (turn_off_nozzle) thermalManager.setTargetHotend(0, active_extruder);
 

commit ab2b98e4255b0b9579af9627e884ac3dfc1d30bb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Apr 23 21:42:38 2020 -0500

    Apply composite tests

diff --git a/Marlin/src/feature/mmu2/mmu2.cpp b/Marlin/src/feature/mmu2/mmu2.cpp
index b26cff53b3..b69557e689 100644
--- a/Marlin/src/feature/mmu2/mmu2.cpp
+++ b/Marlin/src/feature/mmu2/mmu2.cpp
@@ -99,7 +99,7 @@ int16_t MMU2::version = -1, MMU2::buildnr = -1;
 millis_t MMU2::last_request, MMU2::next_P0_request;
 char MMU2::rx_buffer[MMU_RX_SIZE], MMU2::tx_buffer[MMU_TX_SIZE];
 
-#if HAS_LCD_MENU && ENABLED(MMU2_MENUS)
+#if BOTH(HAS_LCD_MENU, MMU2_MENUS)
 
   struct E_Step {
     float extrude;        //!< extrude distance in mm
@@ -632,7 +632,7 @@ void MMU2::filament_runout() {
   planner.synchronize();
 }
 
-#if HAS_LCD_MENU && ENABLED(MMU2_MENUS)
+#if BOTH(HAS_LCD_MENU, MMU2_MENUS)
 
   // Load filament into MMU2
   void MMU2::load_filament(uint8_t index) {

commit 6d90d1e1f552dca5e21bc61b676b8e8ce731b280
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 22 16:35:03 2020 -0500

    Apply TERN to compact code (#17619)

diff --git a/Marlin/src/feature/mmu2/mmu2.cpp b/Marlin/src/feature/mmu2/mmu2.cpp
index 27b7f99205..b26cff53b3 100644
--- a/Marlin/src/feature/mmu2/mmu2.cpp
+++ b/Marlin/src/feature/mmu2/mmu2.cpp
@@ -707,12 +707,8 @@ void MMU2::filament_runout() {
     if (recover)  {
       LCD_MESSAGEPGM(MSG_MMU2_EJECT_RECOVER);
       BUZZ(200, 404);
-      #if ENABLED(HOST_PROMPT_SUPPORT)
-        host_prompt_do(PROMPT_USER_CONTINUE, PSTR("MMU2 Eject Recover"), CONTINUE_STR);
-      #endif
-      #if ENABLED(EXTENSIBLE_UI)
-        ExtUI::onUserConfirmRequired_P(PSTR("MMU2 Eject Recover"));
-      #endif
+      TERN_(HOST_PROMPT_SUPPORT, host_prompt_do(PROMPT_USER_CONTINUE, PSTR("MMU2 Eject Recover"), CONTINUE_STR));
+      TERN_(EXTENSIBLE_UI, ExtUI::onUserConfirmRequired_P(PSTR("MMU2 Eject Recover")));
       wait_for_user_response();
       BUZZ(200, 404);
       BUZZ(200, 404);

commit 22da1b2b310158ae3362c54f2534f5f5af30fa83
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 13 14:53:21 2020 -0500

    Rename some "kill" messages

diff --git a/Marlin/src/feature/mmu2/mmu2.cpp b/Marlin/src/feature/mmu2/mmu2.cpp
index 4506883f46..27b7f99205 100644
--- a/Marlin/src/feature/mmu2/mmu2.cpp
+++ b/Marlin/src/feature/mmu2/mmu2.cpp
@@ -433,7 +433,7 @@ bool MMU2::rx_ok() {
 void MMU2::check_version() {
   if (buildnr < MMU_REQUIRED_FW_BUILDNR) {
     SERIAL_ERROR_MSG("Invalid MMU2 firmware. Version >= " STRINGIFY(MMU_REQUIRED_FW_BUILDNR) " required.");
-    kill(GET_TEXT(MSG_MMU2_WRONG_FIRMWARE));
+    kill(GET_TEXT(MSG_KILL_MMU2_FIRMWARE));
   }
 }
 

commit 747b964295118d425ad41cd7593dae48ccf9f14f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 28 03:18:53 2020 -0500

    Clean up user-wait, SD completion (#17315)

diff --git a/Marlin/src/feature/mmu2/mmu2.cpp b/Marlin/src/feature/mmu2/mmu2.cpp
index 2df34176da..4506883f46 100644
--- a/Marlin/src/feature/mmu2/mmu2.cpp
+++ b/Marlin/src/feature/mmu2/mmu2.cpp
@@ -707,14 +707,13 @@ void MMU2::filament_runout() {
     if (recover)  {
       LCD_MESSAGEPGM(MSG_MMU2_EJECT_RECOVER);
       BUZZ(200, 404);
-      wait_for_user = true;
       #if ENABLED(HOST_PROMPT_SUPPORT)
         host_prompt_do(PROMPT_USER_CONTINUE, PSTR("MMU2 Eject Recover"), CONTINUE_STR);
       #endif
       #if ENABLED(EXTENSIBLE_UI)
         ExtUI::onUserConfirmRequired_P(PSTR("MMU2 Eject Recover"));
       #endif
-      while (wait_for_user) idle();
+      wait_for_user_response();
       BUZZ(200, 404);
       BUZZ(200, 404);
 

commit 118bd2f8b2a1f81884cb55a8fc00b708a51aa15b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 13 23:18:16 2020 -0500

    Apply loop shorthand macros (#17159)

diff --git a/Marlin/src/feature/mmu2/mmu2.cpp b/Marlin/src/feature/mmu2/mmu2.cpp
index 895098eb8a..2df34176da 100644
--- a/Marlin/src/feature/mmu2/mmu2.cpp
+++ b/Marlin/src/feature/mmu2/mmu2.cpp
@@ -381,7 +381,7 @@ bool MMU2::rx_str_P(const char* str) {
 void MMU2::tx_str_P(const char* str) {
   clear_rx_buffer();
   uint8_t len = strlen_P(str);
-  for (uint8_t i = 0; i < len; i++) mmuSerial.write(pgm_read_byte(str++));
+  LOOP_L_N(i, len) mmuSerial.write(pgm_read_byte(str++));
   rx_buffer[0] = '\0';
   last_request = millis();
 }
@@ -392,7 +392,7 @@ void MMU2::tx_str_P(const char* str) {
 void MMU2::tx_printf_P(const char* format, int argument = -1) {
   clear_rx_buffer();
   uint8_t len = sprintf_P(tx_buffer, format, argument);
-  for (uint8_t i = 0; i < len; i++) mmuSerial.write(tx_buffer[i]);
+  LOOP_L_N(i, len) mmuSerial.write(tx_buffer[i]);
   rx_buffer[0] = '\0';
   last_request = millis();
 }
@@ -403,7 +403,7 @@ void MMU2::tx_printf_P(const char* format, int argument = -1) {
 void MMU2::tx_printf_P(const char* format, int argument1, int argument2) {
   clear_rx_buffer();
   uint8_t len = sprintf_P(tx_buffer, format, argument1, argument2);
-  for (uint8_t i = 0; i < len; i++) mmuSerial.write(tx_buffer[i]);
+  LOOP_L_N(i, len) mmuSerial.write(tx_buffer[i]);
   rx_buffer[0] = '\0';
   last_request = millis();
 }
@@ -780,7 +780,7 @@ void MMU2::filament_runout() {
 
     const E_Step* step = sequence;
 
-    for (uint8_t i = 0; i < steps; i++) {
+    LOOP_L_N(i, steps) {
       const float es = pgm_read_float(&(step->extrude));
       const feedRate_t fr_mm_m = pgm_read_float(&(step->feedRate));
 

commit 6bead0c1b04152f6a291d851f6cd4029fe0fc616
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 13 16:29:29 2020 -0500

    Shorter paths to HAL, ExtUI (#17156)

diff --git a/Marlin/src/feature/mmu2/mmu2.cpp b/Marlin/src/feature/mmu2/mmu2.cpp
new file mode 100644
index 0000000000..895098eb8a
--- /dev/null
+++ b/Marlin/src/feature/mmu2/mmu2.cpp
@@ -0,0 +1,802 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "../../inc/MarlinConfig.h"
+
+#if ENABLED(PRUSA_MMU2)
+
+#include "mmu2.h"
+#include "../../lcd/menu/menu_mmu2.h"
+
+MMU2 mmu2;
+
+#include "../../gcode/gcode.h"
+#include "../../lcd/ultralcd.h"
+#include "../../libs/buzzer.h"
+#include "../../libs/nozzle.h"
+#include "../../module/temperature.h"
+#include "../../module/planner.h"
+#include "../../module/stepper/indirection.h"
+#include "../../MarlinCore.h"
+
+#if ENABLED(HOST_PROMPT_SUPPORT)
+  #include "../../feature/host_actions.h"
+#endif
+
+#if ENABLED(EXTENSIBLE_UI)
+  #include "../../lcd/extui/ui_api.h"
+#endif
+
+#define DEBUG_OUT ENABLED(MMU2_DEBUG)
+#include "../../core/debug_out.h"
+
+#define MMU_TODELAY 100
+#define MMU_TIMEOUT 10
+#define MMU_CMD_TIMEOUT 60000ul // 5min timeout for mmu commands (except P0)
+#define MMU_P0_TIMEOUT 3000ul   // Timeout for P0 command: 3seconds
+
+#define MMU_CMD_NONE 0
+#define MMU_CMD_T0   0x10
+#define MMU_CMD_T1   0x11
+#define MMU_CMD_T2   0x12
+#define MMU_CMD_T3   0x13
+#define MMU_CMD_T4   0x14
+#define MMU_CMD_L0   0x20
+#define MMU_CMD_L1   0x21
+#define MMU_CMD_L2   0x22
+#define MMU_CMD_L3   0x23
+#define MMU_CMD_L4   0x24
+#define MMU_CMD_C0   0x30
+#define MMU_CMD_U0   0x40
+#define MMU_CMD_E0   0x50
+#define MMU_CMD_E1   0x51
+#define MMU_CMD_E2   0x52
+#define MMU_CMD_E3   0x53
+#define MMU_CMD_E4   0x54
+#define MMU_CMD_R0   0x60
+#define MMU_CMD_F0   0x70
+#define MMU_CMD_F1   0x71
+#define MMU_CMD_F2   0x72
+#define MMU_CMD_F3   0x73
+#define MMU_CMD_F4   0x74
+
+#if ENABLED(MMU2_MODE_12V)
+  #define MMU_REQUIRED_FW_BUILDNR 132
+#else
+  #define MMU_REQUIRED_FW_BUILDNR 126
+#endif
+
+#define MMU2_NO_TOOL 99
+#define MMU_BAUD    115200
+
+#define mmuSerial   MMU2_SERIAL
+
+bool MMU2::enabled, MMU2::ready, MMU2::mmu_print_saved;
+uint8_t MMU2::cmd, MMU2::cmd_arg, MMU2::last_cmd, MMU2::extruder;
+int8_t MMU2::state = 0;
+volatile int8_t MMU2::finda = 1;
+volatile bool MMU2::finda_runout_valid;
+int16_t MMU2::version = -1, MMU2::buildnr = -1;
+millis_t MMU2::last_request, MMU2::next_P0_request;
+char MMU2::rx_buffer[MMU_RX_SIZE], MMU2::tx_buffer[MMU_TX_SIZE];
+
+#if HAS_LCD_MENU && ENABLED(MMU2_MENUS)
+
+  struct E_Step {
+    float extrude;        //!< extrude distance in mm
+    feedRate_t feedRate;  //!< feed rate in mm/s
+  };
+
+  static constexpr E_Step ramming_sequence[] PROGMEM = { MMU2_RAMMING_SEQUENCE };
+  static constexpr E_Step load_to_nozzle_sequence[] PROGMEM = { MMU2_LOAD_TO_NOZZLE_SEQUENCE };
+
+#endif // MMU2_MENUS
+
+MMU2::MMU2() {
+  rx_buffer[0] = '\0';
+}
+
+void MMU2::init() {
+
+  set_runout_valid(false);
+
+  #if PIN_EXISTS(MMU2_RST)
+    // TODO use macros for this
+    WRITE(MMU2_RST_PIN, HIGH);
+    SET_OUTPUT(MMU2_RST_PIN);
+  #endif
+
+  mmuSerial.begin(MMU_BAUD);
+  extruder = MMU2_NO_TOOL;
+
+  safe_delay(10);
+  reset();
+  rx_buffer[0] = '\0';
+  state = -1;
+}
+
+void MMU2::reset() {
+  DEBUG_ECHOLNPGM("MMU <= reset");
+
+  #if PIN_EXISTS(MMU2_RST)
+    WRITE(MMU2_RST_PIN, LOW);
+    safe_delay(20);
+    WRITE(MMU2_RST_PIN, HIGH);
+  #else
+    tx_str_P(PSTR("X0\n")); // Send soft reset
+  #endif
+}
+
+uint8_t MMU2::get_current_tool() {
+  return extruder == MMU2_NO_TOOL ? -1 : extruder;
+}
+
+void MMU2::mmu_loop() {
+
+  switch (state) {
+
+    case 0: break;
+
+    case -1:
+      if (rx_start()) {
+        DEBUG_ECHOLNPGM("MMU => 'start'");
+        DEBUG_ECHOLNPGM("MMU <= 'S1'");
+
+        // send "read version" request
+        tx_str_P(PSTR("S1\n"));
+
+        state = -2;
+      }
+      else if (millis() > 3000000) {
+        SERIAL_ECHOLNPGM("MMU not responding - DISABLED");
+        state = 0;
+      }
+      break;
+
+    case -2:
+      if (rx_ok()) {
+        sscanf(rx_buffer, "%uok\n", &version);
+
+        DEBUG_ECHOLNPAIR("MMU => ", version, "\nMMU <= 'S2'");
+
+        tx_str_P(PSTR("S2\n")); // read build number
+        state = -3;
+      }
+      break;
+
+    case -3:
+      if (rx_ok()) {
+        sscanf(rx_buffer, "%uok\n", &buildnr);
+
+        DEBUG_ECHOLNPAIR("MMU => ", buildnr);
+
+        check_version();
+
+        #if ENABLED(MMU2_MODE_12V)
+          DEBUG_ECHOLNPGM("MMU <= 'M1'");
+
+          tx_str_P(PSTR("M1\n")); // switch to stealth mode
+          state = -5;
+
+        #else
+          DEBUG_ECHOLNPGM("MMU <= 'P0'");
+
+          tx_str_P(PSTR("P0\n")); // read finda
+          state = -4;
+        #endif
+      }
+      break;
+
+    #if ENABLED(MMU2_MODE_12V)
+    case -5:
+      // response to M1
+      if (rx_ok()) {
+        DEBUG_ECHOLNPGM("MMU => ok");
+
+        DEBUG_ECHOLNPGM("MMU <= 'P0'");
+
+        tx_str_P(PSTR("P0\n")); // read finda
+        state = -4;
+      }
+      break;
+    #endif
+
+    case -4:
+      if (rx_ok()) {
+        sscanf(rx_buffer, "%hhuok\n", &finda);
+
+        DEBUG_ECHOLNPAIR("MMU => ", finda, "\nMMU - ENABLED");
+
+        enabled = true;
+        state = 1;
+      }
+      break;
+
+    case 1:
+      if (cmd) {
+        if (WITHIN(cmd, MMU_CMD_T0, MMU_CMD_T4)) {
+          // tool change
+          int filament = cmd - MMU_CMD_T0;
+          DEBUG_ECHOLNPAIR("MMU <= T", filament);
+          tx_printf_P(PSTR("T%d\n"), filament);
+          state = 3; // wait for response
+        }
+        else if (WITHIN(cmd, MMU_CMD_L0, MMU_CMD_L4)) {
+          // load
+          int filament = cmd - MMU_CMD_L0;
+          DEBUG_ECHOLNPAIR("MMU <= L", filament);
+          tx_printf_P(PSTR("L%d\n"), filament);
+          state = 3; // wait for response
+        }
+        else if (cmd == MMU_CMD_C0) {
+          // continue loading
+          DEBUG_ECHOLNPGM("MMU <= 'C0'");
+          tx_str_P(PSTR("C0\n"));
+          state = 3; // wait for response
+        }
+        else if (cmd == MMU_CMD_U0) {
+          // unload current
+          DEBUG_ECHOLNPGM("MMU <= 'U0'");
+
+          tx_str_P(PSTR("U0\n"));
+          state = 3; // wait for response
+        }
+        else if (WITHIN(cmd, MMU_CMD_E0, MMU_CMD_E4)) {
+          // eject filament
+          int filament = cmd - MMU_CMD_E0;
+          DEBUG_ECHOLNPAIR("MMU <= E", filament);
+          tx_printf_P(PSTR("E%d\n"), filament);
+          state = 3; // wait for response
+        }
+        else if (cmd == MMU_CMD_R0) {
+          // recover after eject
+          DEBUG_ECHOLNPGM("MMU <= 'R0'");
+          tx_str_P(PSTR("R0\n"));
+          state = 3; // wait for response
+        }
+        else if (WITHIN(cmd, MMU_CMD_F0, MMU_CMD_F4)) {
+          // filament type
+          int filament = cmd - MMU_CMD_F0;
+          DEBUG_ECHOPAIR("MMU <= F", filament, " ");
+          DEBUG_ECHO_F(cmd_arg, DEC);
+          DEBUG_EOL();
+          tx_printf_P(PSTR("F%d %d\n"), filament, cmd_arg);
+          state = 3; // wait for response
+        }
+
+        last_cmd = cmd;
+        cmd = MMU_CMD_NONE;
+      }
+      else if (ELAPSED(millis(), next_P0_request)) {
+        // read FINDA
+        tx_str_P(PSTR("P0\n"));
+        state = 2; // wait for response
+      }
+      break;
+
+    case 2:   // response to command P0
+      if (rx_ok()) {
+        sscanf(rx_buffer, "%hhuok\n", &finda);
+
+        // This is super annoying. Only activate if necessary
+        // if (finda_runout_valid) DEBUG_ECHOLNPAIR_F("MMU <= 'P0'\nMMU => ", finda, 6);
+
+        state = 1;
+
+        if (cmd == 0) ready = true;
+
+        if (!finda && finda_runout_valid) filament_runout();
+      }
+      else if (ELAPSED(millis(), last_request + MMU_P0_TIMEOUT)) // Resend request after timeout (3s)
+        state = 1;
+
+      break;
+
+    case 3:   // response to mmu commands
+      if (rx_ok()) {
+        DEBUG_ECHOLNPGM("MMU => 'ok'");
+        ready = true;
+        state = 1;
+        last_cmd = MMU_CMD_NONE;
+      }
+      else if (ELAPSED(millis(), last_request + MMU_CMD_TIMEOUT)) {
+        // resend request after timeout
+        if (last_cmd) {
+          DEBUG_ECHOLNPGM("MMU retry");
+          cmd = last_cmd;
+          last_cmd = MMU_CMD_NONE;
+        }
+        state = 1;
+      }
+      break;
+  }
+}
+
+/**
+ * Check if MMU was started
+ */
+bool MMU2::rx_start() {
+  // check for start message
+  if (rx_str_P(PSTR("start\n"))) {
+    next_P0_request = millis() + 300;
+    return true;
+  }
+  return false;
+}
+
+/**
+ * Check if the data received ends with the given string.
+ */
+bool MMU2::rx_str_P(const char* str) {
+  uint8_t i = strlen(rx_buffer);
+
+  while (mmuSerial.available()) {
+    rx_buffer[i++] = mmuSerial.read();
+    rx_buffer[i] = '\0';
+
+    if (i == sizeof(rx_buffer) - 1) {
+      DEBUG_ECHOLNPGM("rx buffer overrun");
+      break;
+    }
+  }
+
+  uint8_t len = strlen_P(str);
+
+  if (i < len) return false;
+
+  str += len;
+
+  while (len--) {
+    char c0 = pgm_read_byte(str--), c1 = rx_buffer[i--];
+    if (c0 == c1) continue;
+    if (c0 == '\r' && c1 == '\n') continue;  // match cr as lf
+    if (c0 == '\n' && c1 == '\r') continue;  // match lf as cr
+    return false;
+  }
+  return true;
+}
+
+/**
+ * Transfer data to MMU, no argument
+ */
+void MMU2::tx_str_P(const char* str) {
+  clear_rx_buffer();
+  uint8_t len = strlen_P(str);
+  for (uint8_t i = 0; i < len; i++) mmuSerial.write(pgm_read_byte(str++));
+  rx_buffer[0] = '\0';
+  last_request = millis();
+}
+
+/**
+ * Transfer data to MMU, single argument
+ */
+void MMU2::tx_printf_P(const char* format, int argument = -1) {
+  clear_rx_buffer();
+  uint8_t len = sprintf_P(tx_buffer, format, argument);
+  for (uint8_t i = 0; i < len; i++) mmuSerial.write(tx_buffer[i]);
+  rx_buffer[0] = '\0';
+  last_request = millis();
+}
+
+/**
+ * Transfer data to MMU, two arguments
+ */
+void MMU2::tx_printf_P(const char* format, int argument1, int argument2) {
+  clear_rx_buffer();
+  uint8_t len = sprintf_P(tx_buffer, format, argument1, argument2);
+  for (uint8_t i = 0; i < len; i++) mmuSerial.write(tx_buffer[i]);
+  rx_buffer[0] = '\0';
+  last_request = millis();
+}
+
+/**
+ * Empty the rx buffer
+ */
+void MMU2::clear_rx_buffer() {
+  while (mmuSerial.available()) mmuSerial.read();
+  rx_buffer[0] = '\0';
+}
+
+/**
+ * Check if we received 'ok' from MMU
+ */
+bool MMU2::rx_ok() {
+  if (rx_str_P(PSTR("ok\n"))) {
+    next_P0_request = millis() + 300;
+    return true;
+  }
+  return false;
+}
+
+/**
+ * Check if MMU has compatible firmware
+ */
+void MMU2::check_version() {
+  if (buildnr < MMU_REQUIRED_FW_BUILDNR) {
+    SERIAL_ERROR_MSG("Invalid MMU2 firmware. Version >= " STRINGIFY(MMU_REQUIRED_FW_BUILDNR) " required.");
+    kill(GET_TEXT(MSG_MMU2_WRONG_FIRMWARE));
+  }
+}
+
+/**
+ * Handle tool change
+ */
+void MMU2::tool_change(uint8_t index) {
+
+  if (!enabled) return;
+
+  set_runout_valid(false);
+
+  if (index != extruder) {
+
+    DISABLE_AXIS_E0();
+    ui.status_printf_P(0, GET_TEXT(MSG_MMU2_LOADING_FILAMENT), int(index + 1));
+
+    command(MMU_CMD_T0 + index);
+
+    manage_response(true, true);
+
+    command(MMU_CMD_C0);
+    extruder = index; //filament change is finished
+    active_extruder = 0;
+
+    ENABLE_AXIS_E0();
+
+    SERIAL_ECHO_START();
+    SERIAL_ECHOLNPAIR(STR_ACTIVE_EXTRUDER, int(extruder));
+
+    ui.reset_status();
+  }
+
+  set_runout_valid(true);
+}
+
+/**
+ *
+ * Handle special T?/Tx/Tc commands
+ *
+ * T? Gcode to extrude shouldn't have to follow, load to extruder wheels is done automatically
+ * Tx Same as T?, except nozzle doesn't have to be preheated. Tc must be placed after extruder nozzle is preheated to finish filament load.
+ * Tc Load to nozzle after filament was prepared by Tx and extruder nozzle is already heated.
+ *
+ */
+void MMU2::tool_change(const char* special) {
+
+  if (!enabled) return;
+
+  #if ENABLED(MMU2_MENUS)
+
+    set_runout_valid(false);
+
+    switch (*special) {
+      case '?': {
+        uint8_t index = mmu2_choose_filament();
+        while (!thermalManager.wait_for_hotend(active_extruder, false)) safe_delay(100);
+        load_filament_to_nozzle(index);
+      } break;
+
+      case 'x': {
+        planner.synchronize();
+        uint8_t index = mmu2_choose_filament();
+        DISABLE_AXIS_E0();
+        command(MMU_CMD_T0 + index);
+        manage_response(true, true);
+        command(MMU_CMD_C0);
+        mmu_loop();
+
+        ENABLE_AXIS_E0();
+        extruder = index;
+        active_extruder = 0;
+      } break;
+
+      case 'c': {
+        while (!thermalManager.wait_for_hotend(active_extruder, false)) safe_delay(100);
+        execute_extruder_sequence((const E_Step *)load_to_nozzle_sequence, COUNT(load_to_nozzle_sequence));
+      } break;
+    }
+
+    set_runout_valid(true);
+
+  #endif
+}
+
+/**
+ * Set next command
+ */
+void MMU2::command(const uint8_t mmu_cmd) {
+  if (!enabled) return;
+  cmd = mmu_cmd;
+  ready = false;
+}
+
+/**
+ * Wait for response from MMU
+ */
+bool MMU2::get_response() {
+  while (cmd != MMU_CMD_NONE) idle();
+
+  while (!ready) {
+    idle();
+    if (state != 3) break;
+  }
+
+  const bool ret = ready;
+  ready = false;
+
+  return ret;
+}
+
+/**
+ * Wait for response and deal with timeout if nexcessary
+ */
+void MMU2::manage_response(const bool move_axes, const bool turn_off_nozzle) {
+
+  constexpr xyz_pos_t park_point = NOZZLE_PARK_POINT;
+  bool response = false;
+  mmu_print_saved = false;
+  xyz_pos_t resume_position;
+  int16_t resume_hotend_temp;
+
+  KEEPALIVE_STATE(PAUSED_FOR_USER);
+
+  while (!response) {
+
+    response = get_response(); // wait for "ok" from mmu
+
+    if (!response) {          // No "ok" was received in reserved time frame, user will fix the issue on mmu unit
+      if (!mmu_print_saved) { // First occurrence. Save current position, park print head, disable nozzle heater.
+
+        planner.synchronize();
+
+        mmu_print_saved = true;
+
+        SERIAL_ECHOLNPGM("MMU not responding");
+
+        resume_hotend_temp = thermalManager.degTargetHotend(active_extruder);
+        resume_position = current_position;
+
+        if (move_axes && all_axes_homed())
+          nozzle.park(2, park_point /*= NOZZLE_PARK_POINT*/);
+
+        if (turn_off_nozzle) thermalManager.setTargetHotend(0, active_extruder);
+
+        LCD_MESSAGEPGM(MSG_MMU2_NOT_RESPONDING);
+        BUZZ(100, 659);
+        BUZZ(200, 698);
+        BUZZ(100, 659);
+        BUZZ(300, 440);
+        BUZZ(100, 659);
+      }
+    }
+    else if (mmu_print_saved) {
+      SERIAL_ECHOLNPGM("MMU starts responding\n");
+
+      if (turn_off_nozzle && resume_hotend_temp) {
+        thermalManager.setTargetHotend(resume_hotend_temp, active_extruder);
+        LCD_MESSAGEPGM(MSG_HEATING);
+        BUZZ(200, 40);
+
+        while (!thermalManager.wait_for_hotend(active_extruder, false)) safe_delay(1000);
+      }
+
+      if (move_axes && all_axes_homed()) {
+        LCD_MESSAGEPGM(MSG_MMU2_RESUMING);
+        BUZZ(200, 404);
+        BUZZ(200, 404);
+
+        // Move XY to starting position, then Z
+        do_blocking_move_to_xy(resume_position, feedRate_t(NOZZLE_PARK_XY_FEEDRATE));
+
+        // Move Z_AXIS to saved position
+        do_blocking_move_to_z(resume_position.z, feedRate_t(NOZZLE_PARK_Z_FEEDRATE));
+      }
+      else {
+        BUZZ(200, 404);
+        BUZZ(200, 404);
+        LCD_MESSAGEPGM(MSG_MMU2_RESUMING);
+      }
+    }
+  }
+}
+
+void MMU2::set_filament_type(uint8_t index, uint8_t filamentType) {
+  if (!enabled) return;
+
+  cmd_arg = filamentType;
+  command(MMU_CMD_F0 + index);
+
+  manage_response(true, true);
+}
+
+void MMU2::filament_runout() {
+  queue.inject_P(PSTR(MMU2_FILAMENT_RUNOUT_SCRIPT));
+  planner.synchronize();
+}
+
+#if HAS_LCD_MENU && ENABLED(MMU2_MENUS)
+
+  // Load filament into MMU2
+  void MMU2::load_filament(uint8_t index) {
+    if (!enabled) return;
+    command(MMU_CMD_L0 + index);
+    manage_response(false, false);
+    BUZZ(200, 404);
+  }
+
+  /**
+   *
+   * Switch material and load to nozzle
+   *
+   */
+  bool MMU2::load_filament_to_nozzle(uint8_t index) {
+
+    if (!enabled) return false;
+
+    if (thermalManager.tooColdToExtrude(active_extruder)) {
+      BUZZ(200, 404);
+      LCD_ALERTMESSAGEPGM(MSG_HOTEND_TOO_COLD);
+      return false;
+    }
+    else {
+      command(MMU_CMD_T0 + index);
+      manage_response(true, true);
+      command(MMU_CMD_C0);
+      mmu_loop();
+
+      extruder = index;
+      active_extruder = 0;
+
+      load_to_nozzle();
+
+      BUZZ(200, 404);
+      return true;
+    }
+  }
+
+  /**
+   *
+   * Load filament to nozzle of multimaterial printer
+   *
+   * This function is used only only after T? (user select filament) and M600 (change filament).
+   * It is not used after T0 .. T4 command (select filament), in such case, gcode is responsible for loading
+   * filament to nozzle.
+   */
+  void MMU2::load_to_nozzle() {
+    if (!enabled) return;
+    execute_extruder_sequence((const E_Step *)load_to_nozzle_sequence, COUNT(load_to_nozzle_sequence));
+  }
+
+  bool MMU2::eject_filament(uint8_t index, bool recover) {
+
+    if (!enabled) return false;
+
+    if (thermalManager.tooColdToExtrude(active_extruder)) {
+      BUZZ(200, 404);
+      LCD_ALERTMESSAGEPGM(MSG_HOTEND_TOO_COLD);
+      return false;
+    }
+
+    LCD_MESSAGEPGM(MSG_MMU2_EJECTING_FILAMENT);
+
+    ENABLE_AXIS_E0();
+    current_position.e -= MMU2_FILAMENTCHANGE_EJECT_FEED;
+    line_to_current_position(2500 / 60);
+    planner.synchronize();
+    command(MMU_CMD_E0 + index);
+    manage_response(false, false);
+
+    if (recover)  {
+      LCD_MESSAGEPGM(MSG_MMU2_EJECT_RECOVER);
+      BUZZ(200, 404);
+      wait_for_user = true;
+      #if ENABLED(HOST_PROMPT_SUPPORT)
+        host_prompt_do(PROMPT_USER_CONTINUE, PSTR("MMU2 Eject Recover"), CONTINUE_STR);
+      #endif
+      #if ENABLED(EXTENSIBLE_UI)
+        ExtUI::onUserConfirmRequired_P(PSTR("MMU2 Eject Recover"));
+      #endif
+      while (wait_for_user) idle();
+      BUZZ(200, 404);
+      BUZZ(200, 404);
+
+      command(MMU_CMD_R0);
+      manage_response(false, false);
+    }
+
+    ui.reset_status();
+
+    // no active tool
+    extruder = MMU2_NO_TOOL;
+
+    set_runout_valid(false);
+
+    BUZZ(200, 404);
+
+    DISABLE_AXIS_E0();
+
+    return true;
+  }
+
+  /**
+   *
+   * unload from hotend and retract to MMU
+   *
+   */
+  bool MMU2::unload() {
+
+    if (!enabled) return false;
+
+    if (thermalManager.tooColdToExtrude(active_extruder)) {
+      BUZZ(200, 404);
+      LCD_ALERTMESSAGEPGM(MSG_HOTEND_TOO_COLD);
+      return false;
+    }
+
+    filament_ramming();
+
+    command(MMU_CMD_U0);
+    manage_response(false, true);
+
+    BUZZ(200, 404);
+
+    // no active tool
+    extruder = MMU2_NO_TOOL;
+
+    set_runout_valid(false);
+
+    return true;
+  }
+
+  /**
+   * Unload sequence to optimize shape of the tip of the unloaded filament
+   */
+  void MMU2::filament_ramming() {
+    execute_extruder_sequence((const E_Step *)ramming_sequence, sizeof(ramming_sequence) / sizeof(E_Step));
+  }
+
+  void MMU2::execute_extruder_sequence(const E_Step * sequence, int steps) {
+
+    planner.synchronize();
+    ENABLE_AXIS_E0();
+
+    const E_Step* step = sequence;
+
+    for (uint8_t i = 0; i < steps; i++) {
+      const float es = pgm_read_float(&(step->extrude));
+      const feedRate_t fr_mm_m = pgm_read_float(&(step->feedRate));
+
+      DEBUG_ECHO_START();
+      DEBUG_ECHOLNPAIR("E step ", es, "/", fr_mm_m);
+
+      current_position.e += es;
+      line_to_current_position(MMM_TO_MMS(fr_mm_m));
+      planner.synchronize();
+
+      step++;
+    }
+
+    DISABLE_AXIS_E0();
+  }
+
+#endif // HAS_LCD_MENU && MMU2_MENUS
+
+#endif // PRUSA_MMU2
