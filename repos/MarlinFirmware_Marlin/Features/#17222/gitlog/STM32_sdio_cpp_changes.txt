commit 921591d2b899000e3181a098a069392ac0ac4b42
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 22 23:15:31 2023 -0500

    üßë‚Äçüíª SDIO_SUPPORT => ONBOARD_SDIO

diff --git a/Marlin/src/HAL/STM32/sdio.cpp b/Marlin/src/HAL/STM32/sdio.cpp
index 72518ef1cc..de388b8e14 100644
--- a/Marlin/src/HAL/STM32/sdio.cpp
+++ b/Marlin/src/HAL/STM32/sdio.cpp
@@ -26,7 +26,7 @@
 
 #include "../../inc/MarlinConfig.h"
 
-#if ENABLED(SDIO_SUPPORT)
+#if ENABLED(ONBOARD_SDIO)
 
 #include "sdio.h"
 
@@ -453,5 +453,5 @@ uint32_t SDIO_GetCardSize() {
   return (uint32_t)(hsd.SdCard.BlockNbr) * (hsd.SdCard.BlockSize);
 }
 
-#endif // SDIO_SUPPORT
+#endif // ONBOARD_SDIO
 #endif // HAL_STM32

commit 73932855609aa949fa13e3570659ce26c43b0ab8
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jan 20 21:17:13 2023 -0600

    SDIO retry, hsd clock, etc.

diff --git a/Marlin/src/HAL/STM32/sdio.cpp b/Marlin/src/HAL/STM32/sdio.cpp
index 41fe90b825..72518ef1cc 100644
--- a/Marlin/src/HAL/STM32/sdio.cpp
+++ b/Marlin/src/HAL/STM32/sdio.cpp
@@ -286,6 +286,9 @@ void HAL_SD_MspInit(SD_HandleTypeDef *hsd) {
 
     go_to_transfer_speed();
 
+    hsd.Init.ClockPowerSave = SDIO_CLOCK_POWER_SAVE_ENABLE;
+    hsd.Init.ClockDiv = 8;
+
     #if PINS_EXIST(SDIO_D1, SDIO_D2, SDIO_D3) // go to 4 bit wide mode if pins are defined
       retry_Cnt = retryCnt;
       for (;;) {
@@ -433,7 +436,10 @@ bool SDIO_WriteBlock(uint32_t block, const uint8_t *src) {
   #else
 
     uint8_t retries = SDIO_READ_RETRIES;
-    while (retries--) if (SDIO_ReadWriteBlock_DMA(block, src, nullptr)) return true;
+    while (retries--) {
+      if (SDIO_ReadWriteBlock_DMA(block, src, nullptr)) return true;
+      delay(10);
+    }
     return false;
 
   #endif

commit f101aeb3ec6a57eaf6af9b4e943ca2a24b6b375a
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jul 9 11:08:53 2022 -0500

    üêõ Fix SDIO for STM32 (#24470)
    
    Followup to #24271

diff --git a/Marlin/src/HAL/STM32/sdio.cpp b/Marlin/src/HAL/STM32/sdio.cpp
index e958d8c3bc..41fe90b825 100644
--- a/Marlin/src/HAL/STM32/sdio.cpp
+++ b/Marlin/src/HAL/STM32/sdio.cpp
@@ -33,227 +33,410 @@
 #include <stdint.h>
 #include <stdbool.h>
 
-// use local drivers
 #if defined(STM32F103xE) || defined(STM32F103xG)
-  #include <stm32f1xx.h>
+  #include <stm32f1xx_hal_rcc_ex.h>
+  #include <stm32f1xx_hal_sd.h>
 #elif defined(STM32F4xx)
-  #include <stm32f4xx.h>
+  #include <stm32f4xx_hal_rcc.h>
+  #include <stm32f4xx_hal_dma.h>
+  #include <stm32f4xx_hal_gpio.h>
+  #include <stm32f4xx_hal_sd.h>
 #elif defined(STM32F7xx)
-  #include <stm32f7xx.h>
+  #include <stm32f7xx_hal_rcc.h>
+  #include <stm32f7xx_hal_dma.h>
+  #include <stm32f7xx_hal_gpio.h>
+  #include <stm32f7xx_hal_sd.h>
 #elif defined(STM32H7xx)
-  #include <stm32h7xx.h>
+  #define SDIO_FOR_STM32H7
+  #include <stm32h7xx_hal_rcc.h>
+  #include <stm32h7xx_hal_dma.h>
+  #include <stm32h7xx_hal_gpio.h>
+  #include <stm32h7xx_hal_sd.h>
 #else
-  #error "SDIO only supported with STM32F103xE, STM32F103xG, STM32F4xx, STM32F7xx, or STM32H7xx."
+  #error "SDIO is only supported with STM32F103xE, STM32F103xG, STM32F4xx, STM32F7xx, and STM32H7xx."
 #endif
 
+// SDIO Max Clock (naming from STM Manual, don't change)
+#define SDIOCLK 48000000
+
 // Target Clock, configurable. Default is 18MHz, from STM32F1
 #ifndef SDIO_CLOCK
   #define SDIO_CLOCK 18000000 // 18 MHz
 #endif
 
-#define SD_TIMEOUT              1000 // ms
+SD_HandleTypeDef hsd;  // SDIO structure
 
-// SDIO Max Clock (naming from STM Manual, don't change)
-#define SDIOCLK 48000000
+static uint32_t clock_to_divider(uint32_t clk) {
+  #ifdef SDIO_FOR_STM32H7
+    // SDMMC_CK frequency = sdmmc_ker_ck / [2 * CLKDIV].
+    uint32_t sdmmc_clk = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SDMMC);
+    return sdmmc_clk / (2U * SDIO_CLOCK) + (sdmmc_clk % (2U * SDIO_CLOCK) != 0);
+  #else
+    // limit the SDIO master clock to 8/3 of PCLK2. See STM32 Manuals
+    // Also limited to no more than 48Mhz (SDIOCLK).
+    const uint32_t pclk2 = HAL_RCC_GetPCLK2Freq();
+    clk = min(clk, (uint32_t)(pclk2 * 8 / 3));
+    clk = min(clk, (uint32_t)SDIOCLK);
+    // Round up divider, so we don't run the card over the speed supported,
+    // and subtract by 2, because STM32 will add 2, as written in the manual:
+    // SDIO_CK frequency = SDIOCLK / [CLKDIV + 2]
+    return pclk2 / clk + (pclk2 % clk != 0) - 2;
+  #endif
+}
 
-#if defined(STM32F1xx)
-  DMA_HandleTypeDef hdma_sdio;
-  extern "C" void DMA2_Channel4_5_IRQHandler(void) {
-    HAL_DMA_IRQHandler(&hdma_sdio);
-  }
-#elif defined(STM32F4xx)
-  DMA_HandleTypeDef hdma_sdio_rx;
-  DMA_HandleTypeDef hdma_sdio_tx;
-  extern "C" void DMA2_Stream3_IRQHandler(void) {
-    HAL_DMA_IRQHandler(&hdma_sdio_rx);
+// Start the SDIO clock
+void HAL_SD_MspInit(SD_HandleTypeDef *hsd) {
+  UNUSED(hsd);
+  #ifdef SDIO_FOR_STM32H7
+    pinmap_pinout(PC_12, PinMap_SD);
+    pinmap_pinout(PD_2,  PinMap_SD);
+    pinmap_pinout(PC_8,  PinMap_SD);
+    #if PINS_EXIST(SDIO_D1, SDIO_D2, SDIO_D3)  // Define D1-D3 only for 4-bit wide SDIO bus
+      pinmap_pinout(PC_9,  PinMap_SD);
+      pinmap_pinout(PC_10, PinMap_SD);
+      pinmap_pinout(PC_11, PinMap_SD);
+    #endif
+    __HAL_RCC_SDMMC1_CLK_ENABLE();
+    HAL_NVIC_EnableIRQ(SDMMC1_IRQn);
+  #else
+    __HAL_RCC_SDIO_CLK_ENABLE();
+  #endif
+}
+
+#ifdef SDIO_FOR_STM32H7
+
+  #define SD_TIMEOUT              1000 // ms
+
+  extern "C" void SDMMC1_IRQHandler(void) { HAL_SD_IRQHandler(&hsd); }
+
+  uint8_t waitingRxCplt = 0, waitingTxCplt = 0;
+  void HAL_SD_TxCpltCallback(SD_HandleTypeDef *hsdio) { waitingTxCplt = 0; }
+  void HAL_SD_RxCpltCallback(SD_HandleTypeDef *hsdio) { waitingRxCplt = 0; }
+
+  void HAL_SD_MspDeInit(SD_HandleTypeDef *hsd) {
+    __HAL_RCC_SDMMC1_FORCE_RESET();   delay(10);
+    __HAL_RCC_SDMMC1_RELEASE_RESET(); delay(10);
   }
 
-  extern "C" void DMA2_Stream6_IRQHandler(void) {
-    HAL_DMA_IRQHandler(&hdma_sdio_tx);
+  bool SDIO_Init() {
+    HAL_StatusTypeDef sd_state = HAL_OK;
+    if (hsd.Instance == SDMMC1) HAL_SD_DeInit(&hsd);
+
+    // HAL SD initialization
+    hsd.Instance = SDMMC1;
+    hsd.Init.ClockEdge = SDMMC_CLOCK_EDGE_RISING;
+    hsd.Init.ClockPowerSave = SDMMC_CLOCK_POWER_SAVE_DISABLE;
+    hsd.Init.BusWide = SDMMC_BUS_WIDE_1B;
+    hsd.Init.HardwareFlowControl = SDMMC_HARDWARE_FLOW_CONTROL_DISABLE;
+    hsd.Init.ClockDiv = clock_to_divider(SDIO_CLOCK);
+    sd_state = HAL_SD_Init(&hsd);
+
+    #if PINS_EXIST(SDIO_D1, SDIO_D2, SDIO_D3)
+      if (sd_state == HAL_OK)
+        sd_state = HAL_SD_ConfigWideBusOperation(&hsd, SDMMC_BUS_WIDE_4B);
+    #endif
+
+    return (sd_state == HAL_OK);
   }
-#elif defined(STM32H7xx)
-  #define __HAL_RCC_SDIO_FORCE_RESET          __HAL_RCC_SDMMC1_FORCE_RESET
-  #define __HAL_RCC_SDIO_RELEASE_RESET        __HAL_RCC_SDMMC1_RELEASE_RESET
-  #define __HAL_RCC_SDIO_CLK_ENABLE           __HAL_RCC_SDMMC1_CLK_ENABLE
-  #define SDIO                                SDMMC1
-  #define SDIO_IRQn                           SDMMC1_IRQn
-  #define SDIO_IRQHandler                     SDMMC1_IRQHandler
-  #define SDIO_CLOCK_EDGE_RISING              SDMMC_CLOCK_EDGE_RISING
-  #define SDIO_CLOCK_POWER_SAVE_DISABLE       SDMMC_CLOCK_POWER_SAVE_DISABLE
-  #define SDIO_BUS_WIDE_1B                    SDMMC_BUS_WIDE_1B
-  #define SDIO_BUS_WIDE_4B                    SDMMC_BUS_WIDE_4B
-  #define SDIO_HARDWARE_FLOW_CONTROL_DISABLE  SDMMC_HARDWARE_FLOW_CONTROL_DISABLE
-#endif
 
-uint8_t waitingRxCplt = 0;
-uint8_t waitingTxCplt = 0;
-SD_HandleTypeDef hsd;
+#else // !SDIO_FOR_STM32H7
 
-extern "C" void SDIO_IRQHandler(void) {
-  HAL_SD_IRQHandler(&hsd);
-}
+  #define SD_TIMEOUT               500 // ms
 
-void HAL_SD_TxCpltCallback(SD_HandleTypeDef *hsdio) {
-  waitingTxCplt = 0;
-}
+  // SDIO retries, configurable. Default is 3, from STM32F1
+  #ifndef SDIO_READ_RETRIES
+    #define SDIO_READ_RETRIES 3
+  #endif
 
-void HAL_SD_RxCpltCallback(SD_HandleTypeDef *hsdio) {
-  waitingRxCplt = 0;
-}
+  // F4 supports one DMA for RX and another for TX, but Marlin will never
+  // do read and write at same time, so we use the same DMA for both.
+  DMA_HandleTypeDef hdma_sdio;
 
-void HAL_SD_MspInit(SD_HandleTypeDef *hsd) {
-  pinmap_pinout(PC_12, PinMap_SD);
-  pinmap_pinout(PD_2, PinMap_SD);
-  pinmap_pinout(PC_8, PinMap_SD);
-  #if PINS_EXIST(SDIO_D1, SDIO_D2, SDIO_D3)  // define D1-D3 only if have a four bit wide SDIO bus
-    // D1-D3
-    pinmap_pinout(PC_9, PinMap_SD);
-    pinmap_pinout(PC_10, PinMap_SD);
-    pinmap_pinout(PC_11, PinMap_SD);
+  #ifdef STM32F1xx
+    #define DMA_IRQ_HANDLER DMA2_Channel4_5_IRQHandler
+  #elif defined(STM32F4xx)
+    #define DMA_IRQ_HANDLER DMA2_Stream3_IRQHandler
+  #else
+    #error "Unknown STM32 architecture."
   #endif
 
-  __HAL_RCC_SDIO_CLK_ENABLE();
-  HAL_NVIC_EnableIRQ(SDIO_IRQn);
+  extern "C" void SDIO_IRQHandler(void) { HAL_SD_IRQHandler(&hsd); }
+  extern "C" void DMA_IRQ_HANDLER(void) { HAL_DMA_IRQHandler(&hdma_sdio); }
+
+  /*
+    SDIO_INIT_CLK_DIV is 118
+    SDIO clock frequency is 48MHz / (TRANSFER_CLOCK_DIV + 2)
+    SDIO init clock frequency should not exceed 400kHz = 48MHz / (118 + 2)
+
+    Default TRANSFER_CLOCK_DIV is 2 (118 / 40)
+    Default SDIO clock frequency is 48MHz / (2 + 2) = 12 MHz
+    This might be too fast for stable SDIO operations
+
+    MKS Robin SDIO seems stable with BusWide 1bit and ClockDiv 8 (i.e., 4.8MHz SDIO clock frequency)
+    More testing is required as there are clearly some 4bit init problems.
+  */
+
+  void go_to_transfer_speed() {
+    /* Default SDIO peripheral configuration for SD card initialization */
+    hsd.Init.ClockEdge           = hsd.Init.ClockEdge;
+    hsd.Init.ClockBypass         = hsd.Init.ClockBypass;
+    hsd.Init.ClockPowerSave      = hsd.Init.ClockPowerSave;
+    hsd.Init.BusWide             = hsd.Init.BusWide;
+    hsd.Init.HardwareFlowControl = hsd.Init.HardwareFlowControl;
+    hsd.Init.ClockDiv            = clock_to_divider(SDIO_CLOCK);
+
+    /* Initialize SDIO peripheral interface with default configuration */
+    SDIO_Init(hsd.Instance, hsd.Init);
+  }
 
-  // DMA Config
-  #if defined(STM32F1xx)
-    __HAL_RCC_DMA2_CLK_ENABLE();
-    HAL_NVIC_EnableIRQ(DMA2_Channel4_5_IRQn);
-    hdma_sdio.Instance = DMA2_Channel4;
-    hdma_sdio.Init.Direction = DMA_PERIPH_TO_MEMORY;
+  void SD_LowLevel_Init() {
+    uint32_t tempreg;
+
+    // Enable GPIO clocks
+    __HAL_RCC_GPIOC_CLK_ENABLE();
+    __HAL_RCC_GPIOD_CLK_ENABLE();
+
+    GPIO_InitTypeDef  GPIO_InitStruct;
+
+    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
+    GPIO_InitStruct.Pull = 1;  // GPIO_NOPULL
+    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
+
+    #if DISABLED(STM32F1xx)
+      GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
+    #endif
+
+    GPIO_InitStruct.Pin = GPIO_PIN_8 | GPIO_PIN_12;  // D0 & SCK
+    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
+
+    #if PINS_EXIST(SDIO_D1, SDIO_D2, SDIO_D3)  // define D1-D3 only if have a four bit wide SDIO bus
+      GPIO_InitStruct.Pin = GPIO_PIN_9 | GPIO_PIN_10 | GPIO_PIN_11;  // D1-D3
+      HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
+    #endif
+
+    // Configure PD.02 CMD line
+    GPIO_InitStruct.Pin = GPIO_PIN_2;
+    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
+
+    // Setup DMA
+    #ifdef STM32F1xx
+      hdma_sdio.Init.Mode = DMA_NORMAL;
+      hdma_sdio.Instance = DMA2_Channel4;
+      HAL_NVIC_EnableIRQ(DMA2_Channel4_5_IRQn);
+    #elif defined(STM32F4xx)
+      hdma_sdio.Init.Mode = DMA_PFCTRL;
+      hdma_sdio.Instance = DMA2_Stream3;
+      hdma_sdio.Init.Channel = DMA_CHANNEL_4;
+      hdma_sdio.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
+      hdma_sdio.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
+      hdma_sdio.Init.MemBurst = DMA_MBURST_INC4;
+      hdma_sdio.Init.PeriphBurst = DMA_PBURST_INC4;
+      HAL_NVIC_EnableIRQ(DMA2_Stream3_IRQn);
+    #endif
+    HAL_NVIC_EnableIRQ(SDIO_IRQn);
     hdma_sdio.Init.PeriphInc = DMA_PINC_DISABLE;
     hdma_sdio.Init.MemInc = DMA_MINC_ENABLE;
     hdma_sdio.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
     hdma_sdio.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
-    hdma_sdio.Init.Mode = DMA_NORMAL;
     hdma_sdio.Init.Priority = DMA_PRIORITY_LOW;
-    HAL_DMA_Init(&hdma_sdio);
+    __HAL_LINKDMA(&hsd, hdmarx, hdma_sdio);
+    __HAL_LINKDMA(&hsd, hdmatx, hdma_sdio);
+
+    #ifdef STM32F1xx
+      __HAL_RCC_SDIO_CLK_ENABLE();
+      __HAL_RCC_DMA2_CLK_ENABLE();
+    #else
+      __HAL_RCC_SDIO_FORCE_RESET();   delay(2);
+      __HAL_RCC_SDIO_RELEASE_RESET(); delay(2);
+      __HAL_RCC_SDIO_CLK_ENABLE();
+
+      __HAL_RCC_DMA2_FORCE_RESET();   delay(2);
+      __HAL_RCC_DMA2_RELEASE_RESET(); delay(2);
+      __HAL_RCC_DMA2_CLK_ENABLE();
+    #endif
+
+    // Initialize the SDIO (with initial <400Khz Clock)
+    tempreg = 0                   // Reset value
+            | SDIO_CLKCR_CLKEN    // Clock enabled
+            | SDIO_INIT_CLK_DIV;  // Clock Divider. Clock = 48000 / (118 + 2) = 400Khz
+                                  // Keep the rest at 0 => HW_Flow Disabled, Rising Clock Edge, Disable CLK ByPass, Bus Width = 0, Power save Disable
+    SDIO->CLKCR = tempreg;
+
+    // Power up the SDIO
+    SDIO_PowerState_ON(SDIO);
+    hsd.Instance = SDIO;
+  }
 
-    __HAL_LINKDMA(hsd, hdmarx ,hdma_sdio);
-    __HAL_LINKDMA(hsd, hdmatx, hdma_sdio);
-  #elif defined(STM32F4xx)
-    __HAL_RCC_DMA2_CLK_ENABLE();
-    HAL_NVIC_EnableIRQ(DMA2_Stream3_IRQn);
-    HAL_NVIC_EnableIRQ(DMA2_Stream6_IRQn);
-    hdma_sdio_rx.Instance = DMA2_Stream3;
-    hdma_sdio_rx.Init.Channel = DMA_CHANNEL_4;
-    hdma_sdio_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
-    hdma_sdio_rx.Init.PeriphInc = DMA_PINC_DISABLE;
-    hdma_sdio_rx.Init.MemInc = DMA_MINC_ENABLE;
-    hdma_sdio_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
-    hdma_sdio_rx.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
-    hdma_sdio_rx.Init.Mode = DMA_PFCTRL;
-    hdma_sdio_rx.Init.Priority = DMA_PRIORITY_LOW;
-    hdma_sdio_rx.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
-    hdma_sdio_rx.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
-    hdma_sdio_rx.Init.MemBurst = DMA_MBURST_INC4;
-    hdma_sdio_rx.Init.PeriphBurst = DMA_PBURST_INC4;
-    HAL_DMA_Init(&hdma_sdio_rx);
-
-    __HAL_LINKDMA(hsd,hdmarx,hdma_sdio_rx);
-
-    hdma_sdio_tx.Instance = DMA2_Stream6;
-    hdma_sdio_tx.Init.Channel = DMA_CHANNEL_4;
-    hdma_sdio_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
-    hdma_sdio_tx.Init.PeriphInc = DMA_PINC_DISABLE;
-    hdma_sdio_tx.Init.MemInc = DMA_MINC_ENABLE;
-    hdma_sdio_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
-    hdma_sdio_tx.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
-    hdma_sdio_tx.Init.Mode = DMA_PFCTRL;
-    hdma_sdio_tx.Init.Priority = DMA_PRIORITY_LOW;
-    hdma_sdio_tx.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
-    hdma_sdio_tx.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
-    hdma_sdio_tx.Init.MemBurst = DMA_MBURST_INC4;
-    hdma_sdio_tx.Init.PeriphBurst = DMA_PBURST_INC4;
-    HAL_DMA_Init(&hdma_sdio_tx);
-
-    __HAL_LINKDMA(hsd,hdmatx,hdma_sdio_tx);
-  #endif
-}
+  bool SDIO_Init() {
+    uint8_t retryCnt = SDIO_READ_RETRIES;
 
-void HAL_SD_MspDeInit(SD_HandleTypeDef *hsd) {
-  #if !defined(STM32F1xx)
-    __HAL_RCC_SDIO_FORCE_RESET();
-    delay(10);
-    __HAL_RCC_SDIO_RELEASE_RESET();
-    delay(10);
-  #endif
-}
+    bool status;
+    hsd.Instance = SDIO;
+    hsd.State = HAL_SD_STATE_RESET;
 
-static uint32_t clock_to_divider(uint32_t clk) {
-  #if defined(STM32H7xx)
-    // SDMMC_CK frequency = sdmmc_ker_ck / [2 * CLKDIV].
-    uint32_t sdmmc_clk     = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SDMMC);
-    return sdmmc_clk / (2U * SDIO_CLOCK) + (sdmmc_clk % (2U * SDIO_CLOCK) != 0);
-  #else
-    // limit the SDIO master clock to 8/3 of PCLK2. See STM32 Manuals
-    // Also limited to no more than 48Mhz (SDIOCLK).
-    const uint32_t pclk2 = HAL_RCC_GetPCLK2Freq();
-    clk = min(clk, (uint32_t)(pclk2 * 8 / 3));
-    clk = min(clk, (uint32_t)SDIOCLK);
-    // Round up divider, so we don't run the card over the speed supported,
-    // and subtract by 2, because STM32 will add 2, as written in the manual:
-    // SDIO_CK frequency = SDIOCLK / [CLKDIV + 2]
-    return pclk2 / clk + (pclk2 % clk != 0) - 2;
-  #endif
-}
+    SD_LowLevel_Init();
 
-bool SDIO_Init() {
-  HAL_StatusTypeDef sd_state = HAL_OK;
-  if (hsd.Instance == SDIO)
-    HAL_SD_DeInit(&hsd);
-
-  /* HAL SD initialization */
-  hsd.Instance = SDIO;
-  hsd.Init.ClockEdge = SDIO_CLOCK_EDGE_RISING;
-  hsd.Init.ClockPowerSave = SDIO_CLOCK_POWER_SAVE_DISABLE;
-  hsd.Init.BusWide = SDIO_BUS_WIDE_1B;
-  hsd.Init.HardwareFlowControl = SDIO_HARDWARE_FLOW_CONTROL_DISABLE;
-  hsd.Init.ClockDiv = clock_to_divider(SDIO_CLOCK);
-  sd_state = HAL_SD_Init(&hsd);
-
-  #if PINS_EXIST(SDIO_D1, SDIO_D2, SDIO_D3)
-    if (sd_state == HAL_OK) {
-      sd_state = HAL_SD_ConfigWideBusOperation(&hsd, SDIO_BUS_WIDE_4B);
+    uint8_t retry_Cnt = retryCnt;
+    for (;;) {
+      hal.watchdog_refresh();
+      status = (bool) HAL_SD_Init(&hsd);
+      if (!status) break;
+      if (!--retry_Cnt) return false;   // return failing status if retries are exhausted
     }
-  #endif
 
-  return (sd_state == HAL_OK) ? true : false;
-}
+    go_to_transfer_speed();
+
+    #if PINS_EXIST(SDIO_D1, SDIO_D2, SDIO_D3) // go to 4 bit wide mode if pins are defined
+      retry_Cnt = retryCnt;
+      for (;;) {
+        hal.watchdog_refresh();
+        if (!HAL_SD_ConfigWideBusOperation(&hsd, SDIO_BUS_WIDE_4B)) break;  // some cards are only 1 bit wide so a pass here is not required
+        if (!--retry_Cnt) break;
+      }
+      if (!retry_Cnt) {  // wide bus failed, go back to one bit wide mode
+        hsd.State = (HAL_SD_StateTypeDef) 0;  // HAL_SD_STATE_RESET
+        SD_LowLevel_Init();
+        retry_Cnt = retryCnt;
+        for (;;) {
+          hal.watchdog_refresh();
+          status = (bool) HAL_SD_Init(&hsd);
+          if (!status) break;
+          if (!--retry_Cnt) return false;   // return failing status if retries are exhausted
+        }
+        go_to_transfer_speed();
+      }
+    #endif
+
+    return true;
+  }
 
-bool SDIO_ReadBlock(uint32_t block, uint8_t *dst) {
-  uint32_t timeout = HAL_GetTick() + SD_TIMEOUT;
+  /**
+   * @brief Read or Write a block
+   * @details Read or Write a block with SDIO
+   *
+   * @param block The block index
+   * @param src The data buffer source for a write
+   * @param dst The data buffer destination for a read
+   *
+   * @return true on success
+   */
+  static bool SDIO_ReadWriteBlock_DMA(uint32_t block, const uint8_t *src, uint8_t *dst) {
+    if (HAL_SD_GetCardState(&hsd) != HAL_SD_CARD_TRANSFER) return false;
+
+    hal.watchdog_refresh();
+
+    HAL_StatusTypeDef ret;
+    if (src) {
+      hdma_sdio.Init.Direction = DMA_MEMORY_TO_PERIPH;
+      HAL_DMA_Init(&hdma_sdio);
+      ret = HAL_SD_WriteBlocks_DMA(&hsd, (uint8_t*)src, block, 1);
+    }
+    else {
+      hdma_sdio.Init.Direction = DMA_PERIPH_TO_MEMORY;
+      HAL_DMA_Init(&hdma_sdio);
+      ret = HAL_SD_ReadBlocks_DMA(&hsd, (uint8_t*)dst, block, 1);
+    }
 
-  while (HAL_SD_GetCardState(&hsd) != HAL_SD_CARD_TRANSFER) {
-    if (HAL_GetTick() >= timeout) return false;
+    if (ret != HAL_OK) {
+      HAL_DMA_Abort_IT(&hdma_sdio);
+      HAL_DMA_DeInit(&hdma_sdio);
+      return false;
+    }
+
+    millis_t timeout = millis() + SD_TIMEOUT;
+    // Wait the transfer
+    while (hsd.State != HAL_SD_STATE_READY) {
+      if (ELAPSED(millis(), timeout)) {
+        HAL_DMA_Abort_IT(&hdma_sdio);
+        HAL_DMA_DeInit(&hdma_sdio);
+        return false;
+      }
+    }
+
+    while (__HAL_DMA_GET_FLAG(&hdma_sdio, __HAL_DMA_GET_TC_FLAG_INDEX(&hdma_sdio)) != 0
+        || __HAL_DMA_GET_FLAG(&hdma_sdio, __HAL_DMA_GET_TE_FLAG_INDEX(&hdma_sdio)) != 0) { /* nada */ }
+
+    HAL_DMA_Abort_IT(&hdma_sdio);
+    HAL_DMA_DeInit(&hdma_sdio);
+
+    timeout = millis() + SD_TIMEOUT;
+    while (HAL_SD_GetCardState(&hsd) != HAL_SD_CARD_TRANSFER) if (ELAPSED(millis(), timeout)) return false;
+
+    return true;
   }
 
-  waitingRxCplt = 1;
-  if (HAL_SD_ReadBlocks_DMA(&hsd, (uint8_t *)dst, block, 1) != HAL_OK)
-    return false;
+#endif // !SDIO_FOR_STM32H7
+
+/**
+ * @brief Read a block
+ * @details Read a block from media with SDIO
+ *
+ * @param block The block index
+ * @param src The block buffer
+ *
+ * @return true on success
+ */
+bool SDIO_ReadBlock(uint32_t block, uint8_t *dst) {
+  #ifdef SDIO_FOR_STM32H7
+
+    uint32_t timeout = HAL_GetTick() + SD_TIMEOUT;
+
+    while (HAL_SD_GetCardState(&hsd) != HAL_SD_CARD_TRANSFER)
+      if (HAL_GetTick() >= timeout) return false;
 
-  timeout = HAL_GetTick() + SD_TIMEOUT;
-  while (waitingRxCplt)
-    if (HAL_GetTick() >= timeout) return false;
+    waitingRxCplt = 1;
+    if (HAL_SD_ReadBlocks_DMA(&hsd, (uint8_t*)dst, block, 1) != HAL_OK)
+      return false;
+
+    timeout = HAL_GetTick() + SD_TIMEOUT;
+    while (waitingRxCplt)
+      if (HAL_GetTick() >= timeout) return false;
+
+    return true;
+
+  #else
+
+    uint8_t retries = SDIO_READ_RETRIES;
+    while (retries--) if (SDIO_ReadWriteBlock_DMA(block, nullptr, dst)) return true;
+    return false;
 
-  return true;
+  #endif
 }
 
+/**
+ * @brief Write a block
+ * @details Write a block to media with SDIO
+ *
+ * @param block The block index
+ * @param src The block data
+ *
+ * @return true on success
+ */
 bool SDIO_WriteBlock(uint32_t block, const uint8_t *src) {
-  uint32_t timeout = HAL_GetTick() + SD_TIMEOUT;
+  #ifdef SDIO_FOR_STM32H7
 
-  while (HAL_SD_GetCardState(&hsd) != HAL_SD_CARD_TRANSFER)
-    if (HAL_GetTick() >= timeout) return false;
+    uint32_t timeout = HAL_GetTick() + SD_TIMEOUT;
 
-  waitingTxCplt = 1;
-  if (HAL_SD_WriteBlocks_DMA(&hsd, (uint8_t *)src, block, 1) != HAL_OK)
-    return false;
+    while (HAL_SD_GetCardState(&hsd) != HAL_SD_CARD_TRANSFER)
+      if (HAL_GetTick() >= timeout) return false;
+
+    waitingTxCplt = 1;
+    if (HAL_SD_WriteBlocks_DMA(&hsd, (uint8_t*)src, block, 1) != HAL_OK)
+      return false;
 
-  timeout = HAL_GetTick() + SD_TIMEOUT;
-  while (waitingTxCplt)
-    if (HAL_GetTick() >= timeout) return false;
+    timeout = HAL_GetTick() + SD_TIMEOUT;
+    while (waitingTxCplt)
+      if (HAL_GetTick() >= timeout) return false;
 
-  return true;
+    return true;
+
+  #else
+
+    uint8_t retries = SDIO_READ_RETRIES;
+    while (retries--) if (SDIO_ReadWriteBlock_DMA(block, src, nullptr)) return true;
+    return false;
+
+  #endif
 }
 
 bool SDIO_IsReady() {

commit c9b97b8d641b974de3023dabf7fedbfa352c232e
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Fri Jun 3 02:23:07 2022 +0200

    üöëÔ∏è Fix SDIO Init bootloop on STM32F1 (#24275)

diff --git a/Marlin/src/HAL/STM32/sdio.cpp b/Marlin/src/HAL/STM32/sdio.cpp
index a58589c43e..e958d8c3bc 100644
--- a/Marlin/src/HAL/STM32/sdio.cpp
+++ b/Marlin/src/HAL/STM32/sdio.cpp
@@ -200,7 +200,8 @@ static uint32_t clock_to_divider(uint32_t clk) {
 
 bool SDIO_Init() {
   HAL_StatusTypeDef sd_state = HAL_OK;
-  HAL_SD_DeInit(&hsd);
+  if (hsd.Instance == SDIO)
+    HAL_SD_DeInit(&hsd);
 
   /* HAL SD initialization */
   hsd.Instance = SDIO;

commit eda61a2cbd1de39001193ca6ebf5c5c22df3878c
Author: BIGTREETECH <38851044+bigtreetech@users.noreply.github.com>
Date:   Thu Jun 2 17:02:06 2022 +0800

    ‚ú® BigTreeTech SKR3 - STM32H743 (#24271)
    
    Co-authored-by: Alan.Ma <alansayyeah@gmail.com>

diff --git a/Marlin/src/HAL/STM32/sdio.cpp b/Marlin/src/HAL/STM32/sdio.cpp
index b26ec768e8..a58589c43e 100644
--- a/Marlin/src/HAL/STM32/sdio.cpp
+++ b/Marlin/src/HAL/STM32/sdio.cpp
@@ -35,42 +35,15 @@
 
 // use local drivers
 #if defined(STM32F103xE) || defined(STM32F103xG)
-  #include <stm32f1xx_hal_rcc_ex.h>
-  #include <stm32f1xx_hal_sd.h>
+  #include <stm32f1xx.h>
 #elif defined(STM32F4xx)
-  #include <stm32f4xx_hal_rcc.h>
-  #include <stm32f4xx_hal_dma.h>
-  #include <stm32f4xx_hal_gpio.h>
-  #include <stm32f4xx_hal_sd.h>
+  #include <stm32f4xx.h>
 #elif defined(STM32F7xx)
-  #include <stm32f7xx_hal_rcc.h>
-  #include <stm32f7xx_hal_dma.h>
-  #include <stm32f7xx_hal_gpio.h>
-  #include <stm32f7xx_hal_sd.h>
+  #include <stm32f7xx.h>
+#elif defined(STM32H7xx)
+  #include <stm32h7xx.h>
 #else
-  #error "SDIO only supported with STM32F103xE, STM32F103xG, STM32F4xx, or STM32F7xx."
-#endif
-
-SD_HandleTypeDef hsd;  // create SDIO structure
-// F4 supports one DMA for RX and another for TX, but Marlin will never
-// do read and write at same time, so we use the same DMA for both.
-DMA_HandleTypeDef hdma_sdio;
-
-/*
-  SDIO_INIT_CLK_DIV is 118
-  SDIO clock frequency is 48MHz / (TRANSFER_CLOCK_DIV + 2)
-  SDIO init clock frequency should not exceed 400kHz = 48MHz / (118 + 2)
-
-  Default TRANSFER_CLOCK_DIV is 2 (118 / 40)
-  Default SDIO clock frequency is 48MHz / (2 + 2) = 12 MHz
-  This might be too fast for stable SDIO operations
-
-  MKS Robin board seems to have stable SDIO with BusWide 1bit and ClockDiv 8 i.e. 4.8MHz SDIO clock frequency
-  Additional testing is required as there are clearly some 4bit initialization problems
-*/
-
-#ifndef USBD_OK
-  #define USBD_OK 0
+  #error "SDIO only supported with STM32F103xE, STM32F103xG, STM32F4xx, STM32F7xx, or STM32H7xx."
 #endif
 
 // Target Clock, configurable. Default is 18MHz, from STM32F1
@@ -78,223 +51,208 @@ DMA_HandleTypeDef hdma_sdio;
   #define SDIO_CLOCK 18000000 // 18 MHz
 #endif
 
-// SDIO retries, configurable. Default is 3, from STM32F1
-#ifndef SDIO_READ_RETRIES
-  #define SDIO_READ_RETRIES 3
-#endif
+#define SD_TIMEOUT              1000 // ms
 
 // SDIO Max Clock (naming from STM Manual, don't change)
 #define SDIOCLK 48000000
 
-static uint32_t clock_to_divider(uint32_t clk) {
-  // limit the SDIO master clock to 8/3 of PCLK2. See STM32 Manuals
-  // Also limited to no more than 48Mhz (SDIOCLK).
-  const uint32_t pclk2 = HAL_RCC_GetPCLK2Freq();
-  clk = min(clk, (uint32_t)(pclk2 * 8 / 3));
-  clk = min(clk, (uint32_t)SDIOCLK);
-  // Round up divider, so we don't run the card over the speed supported,
-  // and subtract by 2, because STM32 will add 2, as written in the manual:
-  // SDIO_CK frequency = SDIOCLK / [CLKDIV + 2]
-  return pclk2 / clk + (pclk2 % clk != 0) - 2;
-}
-
-void go_to_transfer_speed() {
-  /* Default SDIO peripheral configuration for SD card initialization */
-  hsd.Init.ClockEdge           = hsd.Init.ClockEdge;
-  hsd.Init.ClockBypass         = hsd.Init.ClockBypass;
-  hsd.Init.ClockPowerSave      = hsd.Init.ClockPowerSave;
-  hsd.Init.BusWide             = hsd.Init.BusWide;
-  hsd.Init.HardwareFlowControl = hsd.Init.HardwareFlowControl;
-  hsd.Init.ClockDiv            = clock_to_divider(SDIO_CLOCK);
-
-  /* Initialize SDIO peripheral interface with default configuration */
-  SDIO_Init(hsd.Instance, hsd.Init);
-}
-
-void SD_LowLevel_Init(void) {
-  uint32_t tempreg;
+#if defined(STM32F1xx)
+  DMA_HandleTypeDef hdma_sdio;
+  extern "C" void DMA2_Channel4_5_IRQHandler(void) {
+    HAL_DMA_IRQHandler(&hdma_sdio);
+  }
+#elif defined(STM32F4xx)
+  DMA_HandleTypeDef hdma_sdio_rx;
+  DMA_HandleTypeDef hdma_sdio_tx;
+  extern "C" void DMA2_Stream3_IRQHandler(void) {
+    HAL_DMA_IRQHandler(&hdma_sdio_rx);
+  }
 
-  __HAL_RCC_GPIOC_CLK_ENABLE(); //enable GPIO clocks
-  __HAL_RCC_GPIOD_CLK_ENABLE(); //enable GPIO clocks
+  extern "C" void DMA2_Stream6_IRQHandler(void) {
+    HAL_DMA_IRQHandler(&hdma_sdio_tx);
+  }
+#elif defined(STM32H7xx)
+  #define __HAL_RCC_SDIO_FORCE_RESET          __HAL_RCC_SDMMC1_FORCE_RESET
+  #define __HAL_RCC_SDIO_RELEASE_RESET        __HAL_RCC_SDMMC1_RELEASE_RESET
+  #define __HAL_RCC_SDIO_CLK_ENABLE           __HAL_RCC_SDMMC1_CLK_ENABLE
+  #define SDIO                                SDMMC1
+  #define SDIO_IRQn                           SDMMC1_IRQn
+  #define SDIO_IRQHandler                     SDMMC1_IRQHandler
+  #define SDIO_CLOCK_EDGE_RISING              SDMMC_CLOCK_EDGE_RISING
+  #define SDIO_CLOCK_POWER_SAVE_DISABLE       SDMMC_CLOCK_POWER_SAVE_DISABLE
+  #define SDIO_BUS_WIDE_1B                    SDMMC_BUS_WIDE_1B
+  #define SDIO_BUS_WIDE_4B                    SDMMC_BUS_WIDE_4B
+  #define SDIO_HARDWARE_FLOW_CONTROL_DISABLE  SDMMC_HARDWARE_FLOW_CONTROL_DISABLE
+#endif
 
-  GPIO_InitTypeDef  GPIO_InitStruct;
+uint8_t waitingRxCplt = 0;
+uint8_t waitingTxCplt = 0;
+SD_HandleTypeDef hsd;
 
-  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
-  GPIO_InitStruct.Pull = 1;  //GPIO_NOPULL;
-  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
+extern "C" void SDIO_IRQHandler(void) {
+  HAL_SD_IRQHandler(&hsd);
+}
 
-  #if DISABLED(STM32F1xx)
-    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
-  #endif
+void HAL_SD_TxCpltCallback(SD_HandleTypeDef *hsdio) {
+  waitingTxCplt = 0;
+}
 
-  GPIO_InitStruct.Pin = GPIO_PIN_8 | GPIO_PIN_12;  // D0 & SCK
-  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
+void HAL_SD_RxCpltCallback(SD_HandleTypeDef *hsdio) {
+  waitingRxCplt = 0;
+}
 
+void HAL_SD_MspInit(SD_HandleTypeDef *hsd) {
+  pinmap_pinout(PC_12, PinMap_SD);
+  pinmap_pinout(PD_2, PinMap_SD);
+  pinmap_pinout(PC_8, PinMap_SD);
   #if PINS_EXIST(SDIO_D1, SDIO_D2, SDIO_D3)  // define D1-D3 only if have a four bit wide SDIO bus
-    GPIO_InitStruct.Pin = GPIO_PIN_9 | GPIO_PIN_10 | GPIO_PIN_11;  // D1-D3
-    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
+    // D1-D3
+    pinmap_pinout(PC_9, PinMap_SD);
+    pinmap_pinout(PC_10, PinMap_SD);
+    pinmap_pinout(PC_11, PinMap_SD);
   #endif
 
-  // Configure PD.02 CMD line
-  GPIO_InitStruct.Pin = GPIO_PIN_2;
-  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
+  __HAL_RCC_SDIO_CLK_ENABLE();
+  HAL_NVIC_EnableIRQ(SDIO_IRQn);
 
-  // Setup DMA
+  // DMA Config
   #if defined(STM32F1xx)
-    hdma_sdio.Init.Mode = DMA_NORMAL;
-    hdma_sdio.Instance = DMA2_Channel4;
+    __HAL_RCC_DMA2_CLK_ENABLE();
     HAL_NVIC_EnableIRQ(DMA2_Channel4_5_IRQn);
+    hdma_sdio.Instance = DMA2_Channel4;
+    hdma_sdio.Init.Direction = DMA_PERIPH_TO_MEMORY;
+    hdma_sdio.Init.PeriphInc = DMA_PINC_DISABLE;
+    hdma_sdio.Init.MemInc = DMA_MINC_ENABLE;
+    hdma_sdio.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
+    hdma_sdio.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
+    hdma_sdio.Init.Mode = DMA_NORMAL;
+    hdma_sdio.Init.Priority = DMA_PRIORITY_LOW;
+    HAL_DMA_Init(&hdma_sdio);
+
+    __HAL_LINKDMA(hsd, hdmarx ,hdma_sdio);
+    __HAL_LINKDMA(hsd, hdmatx, hdma_sdio);
   #elif defined(STM32F4xx)
-    hdma_sdio.Init.Mode = DMA_PFCTRL;
-    hdma_sdio.Instance = DMA2_Stream3;
-    hdma_sdio.Init.Channel = DMA_CHANNEL_4;
-    hdma_sdio.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
-    hdma_sdio.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
-    hdma_sdio.Init.MemBurst = DMA_MBURST_INC4;
-    hdma_sdio.Init.PeriphBurst = DMA_PBURST_INC4;
+    __HAL_RCC_DMA2_CLK_ENABLE();
     HAL_NVIC_EnableIRQ(DMA2_Stream3_IRQn);
+    HAL_NVIC_EnableIRQ(DMA2_Stream6_IRQn);
+    hdma_sdio_rx.Instance = DMA2_Stream3;
+    hdma_sdio_rx.Init.Channel = DMA_CHANNEL_4;
+    hdma_sdio_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
+    hdma_sdio_rx.Init.PeriphInc = DMA_PINC_DISABLE;
+    hdma_sdio_rx.Init.MemInc = DMA_MINC_ENABLE;
+    hdma_sdio_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
+    hdma_sdio_rx.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
+    hdma_sdio_rx.Init.Mode = DMA_PFCTRL;
+    hdma_sdio_rx.Init.Priority = DMA_PRIORITY_LOW;
+    hdma_sdio_rx.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
+    hdma_sdio_rx.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
+    hdma_sdio_rx.Init.MemBurst = DMA_MBURST_INC4;
+    hdma_sdio_rx.Init.PeriphBurst = DMA_PBURST_INC4;
+    HAL_DMA_Init(&hdma_sdio_rx);
+
+    __HAL_LINKDMA(hsd,hdmarx,hdma_sdio_rx);
+
+    hdma_sdio_tx.Instance = DMA2_Stream6;
+    hdma_sdio_tx.Init.Channel = DMA_CHANNEL_4;
+    hdma_sdio_tx.Init.Direction = DMA_MEMORY_TO_PERIPH;
+    hdma_sdio_tx.Init.PeriphInc = DMA_PINC_DISABLE;
+    hdma_sdio_tx.Init.MemInc = DMA_MINC_ENABLE;
+    hdma_sdio_tx.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
+    hdma_sdio_tx.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
+    hdma_sdio_tx.Init.Mode = DMA_PFCTRL;
+    hdma_sdio_tx.Init.Priority = DMA_PRIORITY_LOW;
+    hdma_sdio_tx.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
+    hdma_sdio_tx.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
+    hdma_sdio_tx.Init.MemBurst = DMA_MBURST_INC4;
+    hdma_sdio_tx.Init.PeriphBurst = DMA_PBURST_INC4;
+    HAL_DMA_Init(&hdma_sdio_tx);
+
+    __HAL_LINKDMA(hsd,hdmatx,hdma_sdio_tx);
   #endif
-  HAL_NVIC_EnableIRQ(SDIO_IRQn);
-  hdma_sdio.Init.PeriphInc = DMA_PINC_DISABLE;
-  hdma_sdio.Init.MemInc = DMA_MINC_ENABLE;
-  hdma_sdio.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
-  hdma_sdio.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
-  hdma_sdio.Init.Priority = DMA_PRIORITY_LOW;
-  __HAL_LINKDMA(&hsd, hdmarx, hdma_sdio);
-  __HAL_LINKDMA(&hsd, hdmatx, hdma_sdio);
+}
 
-  #if defined(STM32F1xx)
-    __HAL_RCC_SDIO_CLK_ENABLE();
-    __HAL_RCC_DMA2_CLK_ENABLE();
-  #else
+void HAL_SD_MspDeInit(SD_HandleTypeDef *hsd) {
+  #if !defined(STM32F1xx)
     __HAL_RCC_SDIO_FORCE_RESET();
-    delay(2);
+    delay(10);
     __HAL_RCC_SDIO_RELEASE_RESET();
-    delay(2);
-    __HAL_RCC_SDIO_CLK_ENABLE();
-
-    __HAL_RCC_DMA2_FORCE_RESET();
-    delay(2);
-    __HAL_RCC_DMA2_RELEASE_RESET();
-    delay(2);
-    __HAL_RCC_DMA2_CLK_ENABLE();
+    delay(10);
   #endif
-
-  //Initialize the SDIO (with initial <400Khz Clock)
-  tempreg = 0;  //Reset value
-  tempreg |= SDIO_CLKCR_CLKEN;  // Clock enabled
-  tempreg |= SDIO_INIT_CLK_DIV; // Clock Divider. Clock = 48000 / (118 + 2) = 400Khz
-  // Keep the rest at 0 => HW_Flow Disabled, Rising Clock Edge, Disable CLK ByPass, Bus Width = 0, Power save Disable
-  SDIO->CLKCR = tempreg;
-
-  // Power up the SDIO
-  SDIO_PowerState_ON(SDIO);
-  hsd.Instance = SDIO;
 }
 
-void HAL_SD_MspInit(SD_HandleTypeDef *hsd) { // application specific init
-  UNUSED(hsd);   // Prevent unused argument(s) compilation warning
-  __HAL_RCC_SDIO_CLK_ENABLE();  // turn on SDIO clock
+static uint32_t clock_to_divider(uint32_t clk) {
+  #if defined(STM32H7xx)
+    // SDMMC_CK frequency = sdmmc_ker_ck / [2 * CLKDIV].
+    uint32_t sdmmc_clk     = HAL_RCCEx_GetPeriphCLKFreq(RCC_PERIPHCLK_SDMMC);
+    return sdmmc_clk / (2U * SDIO_CLOCK) + (sdmmc_clk % (2U * SDIO_CLOCK) != 0);
+  #else
+    // limit the SDIO master clock to 8/3 of PCLK2. See STM32 Manuals
+    // Also limited to no more than 48Mhz (SDIOCLK).
+    const uint32_t pclk2 = HAL_RCC_GetPCLK2Freq();
+    clk = min(clk, (uint32_t)(pclk2 * 8 / 3));
+    clk = min(clk, (uint32_t)SDIOCLK);
+    // Round up divider, so we don't run the card over the speed supported,
+    // and subtract by 2, because STM32 will add 2, as written in the manual:
+    // SDIO_CK frequency = SDIOCLK / [CLKDIV + 2]
+    return pclk2 / clk + (pclk2 % clk != 0) - 2;
+  #endif
 }
 
 bool SDIO_Init() {
-  uint8_t retryCnt = SDIO_READ_RETRIES;
+  HAL_StatusTypeDef sd_state = HAL_OK;
+  HAL_SD_DeInit(&hsd);
 
-  bool status;
+  /* HAL SD initialization */
   hsd.Instance = SDIO;
-  hsd.State = HAL_SD_STATE_RESET;
-
-  SD_LowLevel_Init();
-
-  uint8_t retry_Cnt = retryCnt;
-  for (;;) {
-    hal.watchdog_refresh();
-    status = (bool) HAL_SD_Init(&hsd);
-    if (!status) break;
-    if (!--retry_Cnt) return false;   // return failing status if retries are exhausted
-  }
-
-  go_to_transfer_speed();
-
-  #if PINS_EXIST(SDIO_D1, SDIO_D2, SDIO_D3) // go to 4 bit wide mode if pins are defined
-    retry_Cnt = retryCnt;
-    for (;;) {
-      hal.watchdog_refresh();
-      if (!HAL_SD_ConfigWideBusOperation(&hsd, SDIO_BUS_WIDE_4B)) break;  // some cards are only 1 bit wide so a pass here is not required
-      if (!--retry_Cnt) break;
-    }
-    if (!retry_Cnt) {  // wide bus failed, go back to one bit wide mode
-      hsd.State = (HAL_SD_StateTypeDef) 0;  // HAL_SD_STATE_RESET
-      SD_LowLevel_Init();
-      retry_Cnt = retryCnt;
-      for (;;) {
-        hal.watchdog_refresh();
-        status = (bool) HAL_SD_Init(&hsd);
-        if (!status) break;
-        if (!--retry_Cnt) return false;   // return failing status if retries are exhausted
-      }
-      go_to_transfer_speed();
+  hsd.Init.ClockEdge = SDIO_CLOCK_EDGE_RISING;
+  hsd.Init.ClockPowerSave = SDIO_CLOCK_POWER_SAVE_DISABLE;
+  hsd.Init.BusWide = SDIO_BUS_WIDE_1B;
+  hsd.Init.HardwareFlowControl = SDIO_HARDWARE_FLOW_CONTROL_DISABLE;
+  hsd.Init.ClockDiv = clock_to_divider(SDIO_CLOCK);
+  sd_state = HAL_SD_Init(&hsd);
+
+  #if PINS_EXIST(SDIO_D1, SDIO_D2, SDIO_D3)
+    if (sd_state == HAL_OK) {
+      sd_state = HAL_SD_ConfigWideBusOperation(&hsd, SDIO_BUS_WIDE_4B);
     }
   #endif
 
-  return true;
+  return (sd_state == HAL_OK) ? true : false;
 }
 
-static bool SDIO_ReadWriteBlock_DMA(uint32_t block, const uint8_t *src, uint8_t *dst) {
-  if (HAL_SD_GetCardState(&hsd) != HAL_SD_CARD_TRANSFER) return false;
-
-  hal.watchdog_refresh();
+bool SDIO_ReadBlock(uint32_t block, uint8_t *dst) {
+  uint32_t timeout = HAL_GetTick() + SD_TIMEOUT;
 
-  HAL_StatusTypeDef ret;
-  if (src) {
-    hdma_sdio.Init.Direction = DMA_MEMORY_TO_PERIPH;
-    HAL_DMA_Init(&hdma_sdio);
-    ret = HAL_SD_WriteBlocks_DMA(&hsd, (uint8_t *)src, block, 1);
-  }
-  else {
-    hdma_sdio.Init.Direction = DMA_PERIPH_TO_MEMORY;
-    HAL_DMA_Init(&hdma_sdio);
-    ret = HAL_SD_ReadBlocks_DMA(&hsd, (uint8_t *)dst, block, 1);
+  while (HAL_SD_GetCardState(&hsd) != HAL_SD_CARD_TRANSFER) {
+    if (HAL_GetTick() >= timeout) return false;
   }
 
-  if (ret != HAL_OK) {
-    HAL_DMA_Abort_IT(&hdma_sdio);
-    HAL_DMA_DeInit(&hdma_sdio);
+  waitingRxCplt = 1;
+  if (HAL_SD_ReadBlocks_DMA(&hsd, (uint8_t *)dst, block, 1) != HAL_OK)
     return false;
-  }
 
-  millis_t timeout = millis() + 500;
-  // Wait the transfer
-  while (hsd.State != HAL_SD_STATE_READY) {
-    if (ELAPSED(millis(), timeout)) {
-      HAL_DMA_Abort_IT(&hdma_sdio);
-      HAL_DMA_DeInit(&hdma_sdio);
-      return false;
-    }
-  }
+  timeout = HAL_GetTick() + SD_TIMEOUT;
+  while (waitingRxCplt)
+    if (HAL_GetTick() >= timeout) return false;
 
-  while (__HAL_DMA_GET_FLAG(&hdma_sdio, __HAL_DMA_GET_TC_FLAG_INDEX(&hdma_sdio)) != 0
-      || __HAL_DMA_GET_FLAG(&hdma_sdio, __HAL_DMA_GET_TE_FLAG_INDEX(&hdma_sdio)) != 0) { /* nada */ }
+  return true;
+}
 
-  HAL_DMA_Abort_IT(&hdma_sdio);
-  HAL_DMA_DeInit(&hdma_sdio);
+bool SDIO_WriteBlock(uint32_t block, const uint8_t *src) {
+  uint32_t timeout = HAL_GetTick() + SD_TIMEOUT;
 
-  timeout = millis() + 500;
-  while (HAL_SD_GetCardState(&hsd) != HAL_SD_CARD_TRANSFER) if (ELAPSED(millis(), timeout)) return false;
+  while (HAL_SD_GetCardState(&hsd) != HAL_SD_CARD_TRANSFER)
+    if (HAL_GetTick() >= timeout) return false;
 
-  return true;
-}
+  waitingTxCplt = 1;
+  if (HAL_SD_WriteBlocks_DMA(&hsd, (uint8_t *)src, block, 1) != HAL_OK)
+    return false;
 
-bool SDIO_ReadBlock(uint32_t block, uint8_t *dst) {
-  uint8_t retries = SDIO_READ_RETRIES;
-  while (retries--) if (SDIO_ReadWriteBlock_DMA(block, nullptr, dst)) return true;
-  return false;
-}
+  timeout = HAL_GetTick() + SD_TIMEOUT;
+  while (waitingTxCplt)
+    if (HAL_GetTick() >= timeout) return false;
 
-bool SDIO_WriteBlock(uint32_t block, const uint8_t *src) {
-  uint8_t retries = SDIO_READ_RETRIES;
-  while (retries--) if (SDIO_ReadWriteBlock_DMA(block, src, nullptr)) return true;
-  return false;
+  return true;
 }
 
 bool SDIO_IsReady() {
@@ -305,16 +263,5 @@ uint32_t SDIO_GetCardSize() {
   return (uint32_t)(hsd.SdCard.BlockNbr) * (hsd.SdCard.BlockSize);
 }
 
-#if defined(STM32F1xx)
-  #define DMA_IRQ_HANDLER DMA2_Channel4_5_IRQHandler
-#elif defined(STM32F4xx)
-  #define DMA_IRQ_HANDLER DMA2_Stream3_IRQHandler
-#else
-  #error "Unknown STM32 architecture."
-#endif
-
-extern "C" void SDIO_IRQHandler(void) { HAL_SD_IRQHandler(&hsd); }
-extern "C" void DMA_IRQ_HANDLER(void) { HAL_DMA_IRQHandler(&hdma_sdio); }
-
 #endif // SDIO_SUPPORT
 #endif // HAL_STM32

commit 52eefa90e1c18616f127cdf43798907880e05ee5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 19 11:36:13 2022 -0500

    ‚ôªÔ∏è Move watchdog to MarlinHAL

diff --git a/Marlin/src/HAL/STM32/sdio.cpp b/Marlin/src/HAL/STM32/sdio.cpp
index 0af5f9040e..b26ec768e8 100644
--- a/Marlin/src/HAL/STM32/sdio.cpp
+++ b/Marlin/src/HAL/STM32/sdio.cpp
@@ -208,7 +208,7 @@ bool SDIO_Init() {
 
   uint8_t retry_Cnt = retryCnt;
   for (;;) {
-    TERN_(USE_WATCHDOG, HAL_watchdog_refresh());
+    hal.watchdog_refresh();
     status = (bool) HAL_SD_Init(&hsd);
     if (!status) break;
     if (!--retry_Cnt) return false;   // return failing status if retries are exhausted
@@ -219,7 +219,7 @@ bool SDIO_Init() {
   #if PINS_EXIST(SDIO_D1, SDIO_D2, SDIO_D3) // go to 4 bit wide mode if pins are defined
     retry_Cnt = retryCnt;
     for (;;) {
-      TERN_(USE_WATCHDOG, HAL_watchdog_refresh());
+      hal.watchdog_refresh();
       if (!HAL_SD_ConfigWideBusOperation(&hsd, SDIO_BUS_WIDE_4B)) break;  // some cards are only 1 bit wide so a pass here is not required
       if (!--retry_Cnt) break;
     }
@@ -228,7 +228,7 @@ bool SDIO_Init() {
       SD_LowLevel_Init();
       retry_Cnt = retryCnt;
       for (;;) {
-        TERN_(USE_WATCHDOG, HAL_watchdog_refresh());
+        hal.watchdog_refresh();
         status = (bool) HAL_SD_Init(&hsd);
         if (!status) break;
         if (!--retry_Cnt) return false;   // return failing status if retries are exhausted
@@ -243,7 +243,7 @@ bool SDIO_Init() {
 static bool SDIO_ReadWriteBlock_DMA(uint32_t block, const uint8_t *src, uint8_t *dst) {
   if (HAL_SD_GetCardState(&hsd) != HAL_SD_CARD_TRANSFER) return false;
 
-  TERN_(USE_WATCHDOG, HAL_watchdog_refresh());
+  hal.watchdog_refresh();
 
   HAL_StatusTypeDef ret;
   if (src) {

commit 3e2a38b653b1d8479b7b38447d5fdff51ea9947f
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Wed Jan 12 08:24:56 2022 -0800

    üìù KHz => kHz (#23512)

diff --git a/Marlin/src/HAL/STM32/sdio.cpp b/Marlin/src/HAL/STM32/sdio.cpp
index 18b4434dfa..0af5f9040e 100644
--- a/Marlin/src/HAL/STM32/sdio.cpp
+++ b/Marlin/src/HAL/STM32/sdio.cpp
@@ -59,7 +59,7 @@ DMA_HandleTypeDef hdma_sdio;
 /*
   SDIO_INIT_CLK_DIV is 118
   SDIO clock frequency is 48MHz / (TRANSFER_CLOCK_DIV + 2)
-  SDIO init clock frequency should not exceed 400KHz = 48MHz / (118 + 2)
+  SDIO init clock frequency should not exceed 400kHz = 48MHz / (118 + 2)
 
   Default TRANSFER_CLOCK_DIV is 2 (118 / 40)
   Default SDIO clock frequency is 48MHz / (2 + 2) = 12 MHz

commit 56ac68172796d03c15235738fcb234c48167d807
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Dec 26 03:20:29 2021 -0600

    üé® Pins and SDIO cleanup

diff --git a/Marlin/src/HAL/STM32/sdio.cpp b/Marlin/src/HAL/STM32/sdio.cpp
new file mode 100644
index 0000000000..18b4434dfa
--- /dev/null
+++ b/Marlin/src/HAL/STM32/sdio.cpp
@@ -0,0 +1,320 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "../platforms.h"
+
+#ifdef HAL_STM32
+
+#include "../../inc/MarlinConfig.h"
+
+#if ENABLED(SDIO_SUPPORT)
+
+#include "sdio.h"
+
+#include <stdint.h>
+#include <stdbool.h>
+
+// use local drivers
+#if defined(STM32F103xE) || defined(STM32F103xG)
+  #include <stm32f1xx_hal_rcc_ex.h>
+  #include <stm32f1xx_hal_sd.h>
+#elif defined(STM32F4xx)
+  #include <stm32f4xx_hal_rcc.h>
+  #include <stm32f4xx_hal_dma.h>
+  #include <stm32f4xx_hal_gpio.h>
+  #include <stm32f4xx_hal_sd.h>
+#elif defined(STM32F7xx)
+  #include <stm32f7xx_hal_rcc.h>
+  #include <stm32f7xx_hal_dma.h>
+  #include <stm32f7xx_hal_gpio.h>
+  #include <stm32f7xx_hal_sd.h>
+#else
+  #error "SDIO only supported with STM32F103xE, STM32F103xG, STM32F4xx, or STM32F7xx."
+#endif
+
+SD_HandleTypeDef hsd;  // create SDIO structure
+// F4 supports one DMA for RX and another for TX, but Marlin will never
+// do read and write at same time, so we use the same DMA for both.
+DMA_HandleTypeDef hdma_sdio;
+
+/*
+  SDIO_INIT_CLK_DIV is 118
+  SDIO clock frequency is 48MHz / (TRANSFER_CLOCK_DIV + 2)
+  SDIO init clock frequency should not exceed 400KHz = 48MHz / (118 + 2)
+
+  Default TRANSFER_CLOCK_DIV is 2 (118 / 40)
+  Default SDIO clock frequency is 48MHz / (2 + 2) = 12 MHz
+  This might be too fast for stable SDIO operations
+
+  MKS Robin board seems to have stable SDIO with BusWide 1bit and ClockDiv 8 i.e. 4.8MHz SDIO clock frequency
+  Additional testing is required as there are clearly some 4bit initialization problems
+*/
+
+#ifndef USBD_OK
+  #define USBD_OK 0
+#endif
+
+// Target Clock, configurable. Default is 18MHz, from STM32F1
+#ifndef SDIO_CLOCK
+  #define SDIO_CLOCK 18000000 // 18 MHz
+#endif
+
+// SDIO retries, configurable. Default is 3, from STM32F1
+#ifndef SDIO_READ_RETRIES
+  #define SDIO_READ_RETRIES 3
+#endif
+
+// SDIO Max Clock (naming from STM Manual, don't change)
+#define SDIOCLK 48000000
+
+static uint32_t clock_to_divider(uint32_t clk) {
+  // limit the SDIO master clock to 8/3 of PCLK2. See STM32 Manuals
+  // Also limited to no more than 48Mhz (SDIOCLK).
+  const uint32_t pclk2 = HAL_RCC_GetPCLK2Freq();
+  clk = min(clk, (uint32_t)(pclk2 * 8 / 3));
+  clk = min(clk, (uint32_t)SDIOCLK);
+  // Round up divider, so we don't run the card over the speed supported,
+  // and subtract by 2, because STM32 will add 2, as written in the manual:
+  // SDIO_CK frequency = SDIOCLK / [CLKDIV + 2]
+  return pclk2 / clk + (pclk2 % clk != 0) - 2;
+}
+
+void go_to_transfer_speed() {
+  /* Default SDIO peripheral configuration for SD card initialization */
+  hsd.Init.ClockEdge           = hsd.Init.ClockEdge;
+  hsd.Init.ClockBypass         = hsd.Init.ClockBypass;
+  hsd.Init.ClockPowerSave      = hsd.Init.ClockPowerSave;
+  hsd.Init.BusWide             = hsd.Init.BusWide;
+  hsd.Init.HardwareFlowControl = hsd.Init.HardwareFlowControl;
+  hsd.Init.ClockDiv            = clock_to_divider(SDIO_CLOCK);
+
+  /* Initialize SDIO peripheral interface with default configuration */
+  SDIO_Init(hsd.Instance, hsd.Init);
+}
+
+void SD_LowLevel_Init(void) {
+  uint32_t tempreg;
+
+  __HAL_RCC_GPIOC_CLK_ENABLE(); //enable GPIO clocks
+  __HAL_RCC_GPIOD_CLK_ENABLE(); //enable GPIO clocks
+
+  GPIO_InitTypeDef  GPIO_InitStruct;
+
+  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
+  GPIO_InitStruct.Pull = 1;  //GPIO_NOPULL;
+  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
+
+  #if DISABLED(STM32F1xx)
+    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
+  #endif
+
+  GPIO_InitStruct.Pin = GPIO_PIN_8 | GPIO_PIN_12;  // D0 & SCK
+  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
+
+  #if PINS_EXIST(SDIO_D1, SDIO_D2, SDIO_D3)  // define D1-D3 only if have a four bit wide SDIO bus
+    GPIO_InitStruct.Pin = GPIO_PIN_9 | GPIO_PIN_10 | GPIO_PIN_11;  // D1-D3
+    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
+  #endif
+
+  // Configure PD.02 CMD line
+  GPIO_InitStruct.Pin = GPIO_PIN_2;
+  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
+
+  // Setup DMA
+  #if defined(STM32F1xx)
+    hdma_sdio.Init.Mode = DMA_NORMAL;
+    hdma_sdio.Instance = DMA2_Channel4;
+    HAL_NVIC_EnableIRQ(DMA2_Channel4_5_IRQn);
+  #elif defined(STM32F4xx)
+    hdma_sdio.Init.Mode = DMA_PFCTRL;
+    hdma_sdio.Instance = DMA2_Stream3;
+    hdma_sdio.Init.Channel = DMA_CHANNEL_4;
+    hdma_sdio.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
+    hdma_sdio.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
+    hdma_sdio.Init.MemBurst = DMA_MBURST_INC4;
+    hdma_sdio.Init.PeriphBurst = DMA_PBURST_INC4;
+    HAL_NVIC_EnableIRQ(DMA2_Stream3_IRQn);
+  #endif
+  HAL_NVIC_EnableIRQ(SDIO_IRQn);
+  hdma_sdio.Init.PeriphInc = DMA_PINC_DISABLE;
+  hdma_sdio.Init.MemInc = DMA_MINC_ENABLE;
+  hdma_sdio.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
+  hdma_sdio.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
+  hdma_sdio.Init.Priority = DMA_PRIORITY_LOW;
+  __HAL_LINKDMA(&hsd, hdmarx, hdma_sdio);
+  __HAL_LINKDMA(&hsd, hdmatx, hdma_sdio);
+
+  #if defined(STM32F1xx)
+    __HAL_RCC_SDIO_CLK_ENABLE();
+    __HAL_RCC_DMA2_CLK_ENABLE();
+  #else
+    __HAL_RCC_SDIO_FORCE_RESET();
+    delay(2);
+    __HAL_RCC_SDIO_RELEASE_RESET();
+    delay(2);
+    __HAL_RCC_SDIO_CLK_ENABLE();
+
+    __HAL_RCC_DMA2_FORCE_RESET();
+    delay(2);
+    __HAL_RCC_DMA2_RELEASE_RESET();
+    delay(2);
+    __HAL_RCC_DMA2_CLK_ENABLE();
+  #endif
+
+  //Initialize the SDIO (with initial <400Khz Clock)
+  tempreg = 0;  //Reset value
+  tempreg |= SDIO_CLKCR_CLKEN;  // Clock enabled
+  tempreg |= SDIO_INIT_CLK_DIV; // Clock Divider. Clock = 48000 / (118 + 2) = 400Khz
+  // Keep the rest at 0 => HW_Flow Disabled, Rising Clock Edge, Disable CLK ByPass, Bus Width = 0, Power save Disable
+  SDIO->CLKCR = tempreg;
+
+  // Power up the SDIO
+  SDIO_PowerState_ON(SDIO);
+  hsd.Instance = SDIO;
+}
+
+void HAL_SD_MspInit(SD_HandleTypeDef *hsd) { // application specific init
+  UNUSED(hsd);   // Prevent unused argument(s) compilation warning
+  __HAL_RCC_SDIO_CLK_ENABLE();  // turn on SDIO clock
+}
+
+bool SDIO_Init() {
+  uint8_t retryCnt = SDIO_READ_RETRIES;
+
+  bool status;
+  hsd.Instance = SDIO;
+  hsd.State = HAL_SD_STATE_RESET;
+
+  SD_LowLevel_Init();
+
+  uint8_t retry_Cnt = retryCnt;
+  for (;;) {
+    TERN_(USE_WATCHDOG, HAL_watchdog_refresh());
+    status = (bool) HAL_SD_Init(&hsd);
+    if (!status) break;
+    if (!--retry_Cnt) return false;   // return failing status if retries are exhausted
+  }
+
+  go_to_transfer_speed();
+
+  #if PINS_EXIST(SDIO_D1, SDIO_D2, SDIO_D3) // go to 4 bit wide mode if pins are defined
+    retry_Cnt = retryCnt;
+    for (;;) {
+      TERN_(USE_WATCHDOG, HAL_watchdog_refresh());
+      if (!HAL_SD_ConfigWideBusOperation(&hsd, SDIO_BUS_WIDE_4B)) break;  // some cards are only 1 bit wide so a pass here is not required
+      if (!--retry_Cnt) break;
+    }
+    if (!retry_Cnt) {  // wide bus failed, go back to one bit wide mode
+      hsd.State = (HAL_SD_StateTypeDef) 0;  // HAL_SD_STATE_RESET
+      SD_LowLevel_Init();
+      retry_Cnt = retryCnt;
+      for (;;) {
+        TERN_(USE_WATCHDOG, HAL_watchdog_refresh());
+        status = (bool) HAL_SD_Init(&hsd);
+        if (!status) break;
+        if (!--retry_Cnt) return false;   // return failing status if retries are exhausted
+      }
+      go_to_transfer_speed();
+    }
+  #endif
+
+  return true;
+}
+
+static bool SDIO_ReadWriteBlock_DMA(uint32_t block, const uint8_t *src, uint8_t *dst) {
+  if (HAL_SD_GetCardState(&hsd) != HAL_SD_CARD_TRANSFER) return false;
+
+  TERN_(USE_WATCHDOG, HAL_watchdog_refresh());
+
+  HAL_StatusTypeDef ret;
+  if (src) {
+    hdma_sdio.Init.Direction = DMA_MEMORY_TO_PERIPH;
+    HAL_DMA_Init(&hdma_sdio);
+    ret = HAL_SD_WriteBlocks_DMA(&hsd, (uint8_t *)src, block, 1);
+  }
+  else {
+    hdma_sdio.Init.Direction = DMA_PERIPH_TO_MEMORY;
+    HAL_DMA_Init(&hdma_sdio);
+    ret = HAL_SD_ReadBlocks_DMA(&hsd, (uint8_t *)dst, block, 1);
+  }
+
+  if (ret != HAL_OK) {
+    HAL_DMA_Abort_IT(&hdma_sdio);
+    HAL_DMA_DeInit(&hdma_sdio);
+    return false;
+  }
+
+  millis_t timeout = millis() + 500;
+  // Wait the transfer
+  while (hsd.State != HAL_SD_STATE_READY) {
+    if (ELAPSED(millis(), timeout)) {
+      HAL_DMA_Abort_IT(&hdma_sdio);
+      HAL_DMA_DeInit(&hdma_sdio);
+      return false;
+    }
+  }
+
+  while (__HAL_DMA_GET_FLAG(&hdma_sdio, __HAL_DMA_GET_TC_FLAG_INDEX(&hdma_sdio)) != 0
+      || __HAL_DMA_GET_FLAG(&hdma_sdio, __HAL_DMA_GET_TE_FLAG_INDEX(&hdma_sdio)) != 0) { /* nada */ }
+
+  HAL_DMA_Abort_IT(&hdma_sdio);
+  HAL_DMA_DeInit(&hdma_sdio);
+
+  timeout = millis() + 500;
+  while (HAL_SD_GetCardState(&hsd) != HAL_SD_CARD_TRANSFER) if (ELAPSED(millis(), timeout)) return false;
+
+  return true;
+}
+
+bool SDIO_ReadBlock(uint32_t block, uint8_t *dst) {
+  uint8_t retries = SDIO_READ_RETRIES;
+  while (retries--) if (SDIO_ReadWriteBlock_DMA(block, nullptr, dst)) return true;
+  return false;
+}
+
+bool SDIO_WriteBlock(uint32_t block, const uint8_t *src) {
+  uint8_t retries = SDIO_READ_RETRIES;
+  while (retries--) if (SDIO_ReadWriteBlock_DMA(block, src, nullptr)) return true;
+  return false;
+}
+
+bool SDIO_IsReady() {
+  return hsd.State == HAL_SD_STATE_READY;
+}
+
+uint32_t SDIO_GetCardSize() {
+  return (uint32_t)(hsd.SdCard.BlockNbr) * (hsd.SdCard.BlockSize);
+}
+
+#if defined(STM32F1xx)
+  #define DMA_IRQ_HANDLER DMA2_Channel4_5_IRQHandler
+#elif defined(STM32F4xx)
+  #define DMA_IRQ_HANDLER DMA2_Stream3_IRQHandler
+#else
+  #error "Unknown STM32 architecture."
+#endif
+
+extern "C" void SDIO_IRQHandler(void) { HAL_SD_IRQHandler(&hsd); }
+extern "C" void DMA_IRQ_HANDLER(void) { HAL_DMA_IRQHandler(&hdma_sdio); }
+
+#endif // SDIO_SUPPORT
+#endif // HAL_STM32
