commit 3dc437add4d142b71ea0684848fc1b73e4245a4c
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Thu May 16 08:42:19 2024 +1200

    üé® Apply TERN0/1 for some contexts (#27036)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 16d4a38e08..15cfeac911 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -36,21 +36,21 @@
 #if ENABLED(AUTO_REPORT_TEMPERATURES)
   #include "../libs/autoreport.h"
 #endif
 
 #if HAS_FANCHECK
   #include "../feature/fancheck.h"
 #endif
 
 //#define ERR_INCLUDE_TEMP
 
-#define HOTEND_INDEX TERN(HAS_MULTI_HOTEND, e, 0)
+#define HOTEND_INDEX TERN0(HAS_MULTI_HOTEND, e)
 #define E_NAME TERN_(HAS_MULTI_HOTEND, e)
 
 #if HAS_FAN
   #if NUM_REDUNDANT_FANS
     #define FAN_IS_REDUNDANT(Q) WITHIN(Q, REDUNDANT_PART_COOLING_FAN, REDUNDANT_PART_COOLING_FAN + NUM_REDUNDANT_FANS - 1)
   #else
     #define FAN_IS_REDUNDANT(Q) false
   #endif
   #define FAN_IS_M106ABLE(Q) (HAS_FAN##Q && !FAN_IS_REDUNDANT(Q))
 #else

commit bc0d7d7140abc61c89264f718f0797046dbff022
Author: Aron List <aronotmar@live.nl>
Date:   Sun Apr 21 03:18:49 2024 +0200

    üêõ Fix PID upon entering PID_FUNCTIONAL_RANGE (#26926)
    
    The PID algorithm did not cache the last seen temperature until it entered the PID_FUNCTIONAL_RANGE. This caused an incorrect output power to be calculated temporarily while the algorithm caught up.
    
    This has likely always been a problem for bed and chamber PID. For the hotend this error was introduced in refactoring in commit 54e7b933cdb6d0bf0d69fd661b585100d76e3c88.

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 088a17ec1b..16d4a38e08 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -197,45 +197,49 @@ typedef struct { float p, i, d, c, f; } raw_pidcf_t;
       void set(float p, float i, float d, float c=1, float f=0) { set_Kp(p); set_Ki(i); set_Kd(d); set_Kc(c); set_Kf(f); }
       void set(const raw_pid_t &raw) { set(raw.p, raw.i, raw.d); }
       void set(const raw_pidcf_t &raw) { set(raw.p, raw.i, raw.d, raw.c, raw.f); }
 
       float get_fan_scale_output(const uint8_t) { return 0; }
 
       float get_extrusion_scale_output(const bool, const int32_t, const float, const int16_t) { return 0; }
 
       float get_pid_output(const float target, const float current) {
         const float pid_error = target - current;
+        float output_pow;
         if (!target || pid_error < -(PID_FUNCTIONAL_RANGE)) {
           pid_reset = true;
-          return 0;
+          output_pow = 0;
         }
         else if (pid_error > PID_FUNCTIONAL_RANGE) {
           pid_reset = true;
-          return MAX_POW;
+          output_pow = MAX_POW;
         }
+        else {
+          if (pid_reset) {
+            pid_reset = false;
+            temp_iState = 0.0;
+            work_d = 0.0;
+          }
 
-        if (pid_reset) {
-          pid_reset = false;
-          temp_iState = 0.0;
-          work_d = 0.0;
-        }
+          const float max_power_over_i_gain = float(MAX_POW) / Ki - float(MIN_POW);
+          temp_iState = constrain(temp_iState + pid_error, 0, max_power_over_i_gain);
 
-        const float max_power_over_i_gain = float(MAX_POW) / Ki - float(MIN_POW);
-        temp_iState = constrain(temp_iState + pid_error, 0, max_power_over_i_gain);
+          work_p = Kp * pid_error;
+          work_i = Ki * temp_iState;
+          work_d = work_d + PID_K2 * (Kd * (temp_dState - current) - work_d);
 
-        work_p = Kp * pid_error;
-        work_i = Ki * temp_iState;
-        work_d = work_d + PID_K2 * (Kd * (temp_dState - current) - work_d);
+          output_pow = constrain(work_p + work_i + work_d + float(MIN_POW), 0, MAX_POW);
+        }
 
         temp_dState = current;
 
-        return constrain(work_p + work_i + work_d + float(MIN_POW), 0, MAX_POW);
+        return output_pow;
       }
 
   };
 
 #endif // HAS_PID_HEATING
 
 #if ENABLED(PIDTEMP)
 
   /// @brief Extrusion scaled PID class
   template<int MIN_POW, int MAX_POW, int LPQ_ARR_SZ>

commit cb291e8d00a6c1ee0a778625e0170b6b7430a004
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jan 9 22:41:00 2024 -0600

    ü©π Fix some temp constraints

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index c69a272adf..088a17ec1b 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -590,21 +590,21 @@ typedef struct { raw_adc_t raw_min, raw_max; celsius_t mintemp, maxtemp; } temp_
   #define HAS_FAN_LOGIC 1
 #endif
 
 class Temperature {
 
   public:
 
     #if HAS_HOTEND
       static hotend_info_t temp_hotend[HOTENDS];
       static constexpr celsius_t hotend_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP, HEATER_5_MAXTEMP, HEATER_6_MAXTEMP, HEATER_7_MAXTEMP);
-      static celsius_t hotend_max_target(const uint8_t e) { return hotend_maxtemp[e] - (HOTEND_OVERSHOOT); }
+      static constexpr celsius_t hotend_max_target(const uint8_t e) { return hotend_maxtemp[e] - (HOTEND_OVERSHOOT); }
     #endif
 
     #if HAS_HEATED_BED
       static bed_info_t temp_bed;
     #endif
     #if HAS_TEMP_PROBE
       static probe_info_t temp_probe;
     #endif
     #if HAS_TEMP_CHAMBER
       static chamber_info_t temp_chamber;

commit 25caae1e8c238422cb8ee00637d463ae837c5273
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Wed Jan 10 15:55:20 2024 +1300

    ü©π Fix PID / MPC tune background tasks (#26652)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index c4d718e148..c69a272adf 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -1190,20 +1190,22 @@ class Temperature {
       static bool auto_job_over_threshold();
       static void auto_job_check_timer(const bool can_start, const bool can_stop);
     #endif
 
     #if ENABLED(TEMP_TUNING_MAINTAIN_FAN)
       static bool adaptive_fan_slowing;
     #elif ENABLED(ADAPTIVE_FAN_SLOWING)
       static constexpr bool adaptive_fan_slowing = true;
     #endif
 
+    static bool tuning_idle(const millis_t &ms);
+
     /**
      * M303 PID auto-tuning for hotends or bed
      */
     #if HAS_PID_HEATING
 
       #if HAS_PID_DEBUG
         static bool pid_debug_flag;
       #endif
 
       static void PID_autotune(const celsius_t target, const heater_id_t heater_id, const int8_t ncycles, const bool set_result=false);

commit 12d7995a18d3ce59c871e11c4940bbaeb9c352fc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jan 9 18:45:17 2024 -0600

    üé® Minor temp / UI refactor

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 2acc1205b7..c4d718e148 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -515,20 +515,23 @@ struct HeaterWatch {
 #if WATCH_BED
   typedef struct HeaterWatch<WATCH_BED_TEMP_INCREASE, TEMP_BED_HYSTERESIS, WATCH_BED_TEMP_PERIOD> bed_watch_t;
 #endif
 #if WATCH_CHAMBER
   typedef struct HeaterWatch<WATCH_CHAMBER_TEMP_INCREASE, TEMP_CHAMBER_HYSTERESIS, WATCH_CHAMBER_TEMP_PERIOD> chamber_watch_t;
 #endif
 #if WATCH_COOLER
   typedef struct HeaterWatch<WATCH_COOLER_TEMP_INCREASE, TEMP_COOLER_HYSTERESIS, WATCH_COOLER_TEMP_PERIOD> cooler_watch_t;
 #endif
 
+// Just raw temperature sensor ranges
+typedef struct { raw_adc_t raw_min, raw_max; } temp_raw_range_t;
+
 // Temperature sensor read value ranges
 typedef struct { raw_adc_t raw_min, raw_max; celsius_t mintemp, maxtemp; } temp_range_t;
 
 #define THERMISTOR_ABS_ZERO_C           -273.15f  // bbbbrrrrr cold !
 #define THERMISTOR_RESISTANCE_NOMINAL_C 25.0f     // mmmmm comfortable
 
 #if HAS_USER_THERMISTORS
 
   enum CustomThermistorIndex : uint8_t {
     #if TEMP_SENSOR_0_IS_CUSTOM
@@ -720,53 +723,54 @@ class Temperature {
       static constexpr millis_t fan_update_interval_ms = TERN(HAS_PWMFANCHECK, 5000, TERN(HAS_FANCHECK, 1000, 2500));
     #endif
 
   private:
 
     #if ENABLED(WATCH_HOTENDS)
       static hotend_watch_t watch_hotend[HOTENDS];
     #endif
 
     #if HAS_HOTEND
+      // Sensor ranges, not user-configured
       static temp_range_t temp_range[HOTENDS];
     #endif
 
     #if HAS_HEATED_BED
       #if WATCH_BED
         static bed_watch_t watch_bed;
       #endif
       #if DISABLED(PIDTEMPBED)
         static millis_t next_bed_check_ms;
       #endif
-      static raw_adc_t mintemp_raw_BED, maxtemp_raw_BED;
+      static temp_raw_range_t temp_sensor_range_bed;
     #endif
 
     #if HAS_HEATED_CHAMBER
       #if WATCH_CHAMBER
         static chamber_watch_t watch_chamber;
       #endif
       #if DISABLED(PIDTEMPCHAMBER)
         static millis_t next_chamber_check_ms;
       #endif
-      static raw_adc_t mintemp_raw_CHAMBER, maxtemp_raw_CHAMBER;
+      static temp_raw_range_t temp_sensor_range_chamber;
     #endif
 
     #if HAS_COOLER
       #if WATCH_COOLER
         static cooler_watch_t watch_cooler;
       #endif
       static millis_t next_cooler_check_ms, cooler_fan_flush_ms;
-      static raw_adc_t mintemp_raw_COOLER, maxtemp_raw_COOLER;
+      static temp_raw_range_t temp_sensor_range_cooler;
     #endif
 
     #if ALL(HAS_TEMP_BOARD, THERMAL_PROTECTION_BOARD)
-      static raw_adc_t mintemp_raw_BOARD, maxtemp_raw_BOARD;
+      static temp_raw_range_t temp_sensor_range_board;
     #endif
 
     #if ALL(HAS_TEMP_SOC, THERMAL_PROTECTION_SOC)
       static raw_adc_t maxtemp_raw_SOC;
     #endif
 
     #if MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED > 1
       static uint8_t consecutive_low_temperature_error[HOTENDS];
     #endif
 
@@ -1187,21 +1191,21 @@ class Temperature {
       static void auto_job_check_timer(const bool can_start, const bool can_stop);
     #endif
 
     #if ENABLED(TEMP_TUNING_MAINTAIN_FAN)
       static bool adaptive_fan_slowing;
     #elif ENABLED(ADAPTIVE_FAN_SLOWING)
       static constexpr bool adaptive_fan_slowing = true;
     #endif
 
     /**
-     * Perform auto-tuning for hotend or bed in response to M303
+     * M303 PID auto-tuning for hotends or bed
      */
     #if HAS_PID_HEATING
 
       #if HAS_PID_DEBUG
         static bool pid_debug_flag;
       #endif
 
       static void PID_autotune(const celsius_t target, const heater_id_t heater_id, const int8_t ncycles, const bool set_result=false);
 
       // Update the temp manager when PID values change
@@ -1212,20 +1216,23 @@ class Temperature {
             temp_hotend[hotend].pid.set(p, i, d);
           #else
             HOTEND_LOOP() temp_hotend[e].pid.set(p, i, d);
           #endif
           updatePID();
         }
       #endif
 
     #endif // HAS_PID_HEATING
 
+    /**
+     * M306 MPC auto-tuning for hotends
+     */
     #if ENABLED(MPC_AUTOTUNE)
 
       // Utility class to perform MPCTEMP auto tuning measurements
       class MPC_autotuner {
         public:
           enum MeasurementState { CANCELLED, FAILED, SUCCESS };
           MPC_autotuner(const uint8_t extruderIdx);
           ~MPC_autotuner();
           MeasurementState measure_ambient_temp();
           MeasurementState measure_heatup();

commit 06710e54de8c83af77a4f57d458f6463fbfcad93
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Wed Dec 13 00:33:03 2023 -0500

    ‚ú® EDITABLE_DISPLAY_TIMEOUT (#26517)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index d174bfd11d..2acc1205b7 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -692,21 +692,21 @@ class Temperature {
         REPEAT(HOTENDS, _IDLE_INDEX_E)
         #undef _IDLE_INDEX_E
 
         OPTARG(HAS_HEATED_BED, IDLE_INDEX_BED)
 
         , NR_HEATER_IDLE
       };
 
       // Convert the given heater_id_t to idle array index
       static IdleIndex idle_index_for_id(const int8_t heater_id) {
-        TERN_(HAS_HEATED_BED, if (heater_id == H_BED) return IDLE_INDEX_BED);
+        OPTCODE(HAS_HEATED_BED, if (heater_id == H_BED) return IDLE_INDEX_BED)
         return (IdleIndex)_MAX(heater_id, 0);
       }
 
       static heater_idle_t heater_idle[NR_HEATER_IDLE];
 
     #endif // HEATER_IDLE_TIMER
 
     #if HAS_ADC_BUTTONS
       static uint32_t current_ADCKey_raw;
       static uint16_t ADCKey_count;
@@ -1045,21 +1045,21 @@ class Temperature {
       static celsius_float_t degBed()  { return temp_bed.celsius; }
       static celsius_t wholeDegBed()   { return static_cast<celsius_t>(degBed() + 0.5f); }
       static celsius_t degTargetBed()  { return temp_bed.target; }
       static bool isHeatingBed()       { return temp_bed.target > temp_bed.celsius; }
       static bool isCoolingBed()       { return temp_bed.target < temp_bed.celsius; }
       static bool degBedNear(const celsius_t temp) {
         return ABS(wholeDegBed() - temp) < (TEMP_BED_HYSTERESIS);
       }
 
       // Start watching the Bed to make sure it's really heating up
-      static void start_watching_bed() { TERN_(WATCH_BED, watch_bed.restart(degBed(), degTargetBed())); }
+      static void start_watching_bed() { OPTCODE(WATCH_BED, watch_bed.restart(degBed(), degTargetBed())) }
 
       static void setTargetBed(const celsius_t celsius) {
         #if PREHEAT_TIME_BED_MS > 0
           if (celsius == 0)
             reset_bed_preheat_time();
           else if (temp_bed.target == 0)
             start_bed_preheat_time();
         #endif
         TERN_(AUTO_POWER_CONTROL, if (celsius) powerManager.power_on());
         temp_bed.target = _MIN(celsius, BED_MAX_TARGET);
@@ -1101,21 +1101,21 @@ class Temperature {
         static void manage_heated_chamber(const millis_t &ms);
       #endif
     #endif
 
     #if HAS_HEATED_CHAMBER
       static void setTargetChamber(const celsius_t celsius) {
         temp_chamber.target = _MIN(celsius, CHAMBER_MAX_TARGET);
         start_watching_chamber();
       }
       // Start watching the Chamber to make sure it's really heating up
-      static void start_watching_chamber() { TERN_(WATCH_CHAMBER, watch_chamber.restart(degChamber(), degTargetChamber())); }
+      static void start_watching_chamber() { OPTCODE(WATCH_CHAMBER, watch_chamber.restart(degChamber(), degTargetChamber())) }
     #endif
 
     #if HAS_TEMP_COOLER
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         static raw_adc_t rawCoolerTemp()   { return temp_cooler.getraw(); }
       #endif
       static celsius_float_t degCooler()   { return temp_cooler.celsius; }
       static celsius_t wholeDegCooler()    { return static_cast<celsius_t>(temp_cooler.celsius + 0.5f); }
       #if HAS_COOLER
         static celsius_t degTargetCooler() { return temp_cooler.target; }
@@ -1151,21 +1151,21 @@ class Temperature {
       static celsius_t wholeDegRedundant()        { return static_cast<celsius_t>(temp_redundant.celsius + 0.5f); }
       static celsius_t wholeDegRedundantTarget()  { return static_cast<celsius_t>((*temp_redundant.target).celsius + 0.5f); }
     #endif
 
     #if HAS_COOLER
       static void setTargetCooler(const celsius_t celsius) {
         temp_cooler.target = constrain(celsius, COOLER_MIN_TARGET, COOLER_MAX_TARGET);
         start_watching_cooler();
       }
       // Start watching the Cooler to make sure it's really cooling down
-      static void start_watching_cooler() { TERN_(WATCH_COOLER, watch_cooler.restart(degCooler(), degTargetCooler())); }
+      static void start_watching_cooler() { OPTCODE(WATCH_COOLER, watch_cooler.restart(degCooler(), degTargetCooler())) }
     #endif
 
     /**
      * The software PWM power for a heater
      */
     static int16_t getHeaterPower(const heater_id_t heater_id);
 
     /**
      * Switch off all heaters, set all target temperatures to 0
      */
@@ -1384,23 +1384,23 @@ class Temperature {
           #undef _RUNAWAY_IND_E
         #endif
         OPTARG(THERMAL_PROTECTION_BED, RUNAWAY_IND_BED)
         OPTARG(THERMAL_PROTECTION_CHAMBER, RUNAWAY_IND_CHAMBER)
         OPTARG(THERMAL_PROTECTION_COOLER, RUNAWAY_IND_COOLER)
         , NR_HEATER_RUNAWAY
       };
 
       // Convert the given heater_id_t to runaway state array index
       static RunawayIndex runaway_index_for_id(const int8_t heater_id) {
-        TERN_(THERMAL_PROTECTION_CHAMBER, if (heater_id == H_CHAMBER) return RUNAWAY_IND_CHAMBER);
-        TERN_(THERMAL_PROTECTION_COOLER,  if (heater_id == H_COOLER)  return RUNAWAY_IND_COOLER);
-        TERN_(THERMAL_PROTECTION_BED,     if (heater_id == H_BED)     return RUNAWAY_IND_BED);
+        OPTCODE(THERMAL_PROTECTION_CHAMBER, if (heater_id == H_CHAMBER) return RUNAWAY_IND_CHAMBER)
+        OPTCODE(THERMAL_PROTECTION_COOLER,  if (heater_id == H_COOLER)  return RUNAWAY_IND_COOLER)
+        OPTCODE(THERMAL_PROTECTION_BED,     if (heater_id == H_BED)     return RUNAWAY_IND_BED)
         return (RunawayIndex)_MAX(heater_id, 0);
       }
 
       enum TRState : char { TRInactive, TRFirstHeating, TRStable, TRRunaway
         OPTARG(THERMAL_PROTECTION_VARIANCE_MONITOR, TRMalfunction)
       };
 
       typedef struct {
         millis_t timer = 0;
         TRState state = TRInactive;

commit 0a86a5f39c560f324e65b539b5be8da1ed91c60a
Author: David Buezas <dbuezas@users.noreply.github.com>
Date:   Sun Nov 26 02:55:51 2023 +0100

    ‚ú® MAX Thermocouples for Heated Bed (#26441)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index d5a27a8671..d174bfd11d 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -1328,29 +1328,30 @@ class Temperature {
     static void updateTemperaturesFromRawValues();
     static bool updateTemperaturesIfReady() {
       if (!raw_temps_ready) return false;
       updateTemperaturesFromRawValues();
       raw_temps_ready = false;
       return true;
     }
 
     // MAX Thermocouples
     #if HAS_MAX_TC
-      #define MAX_TC_COUNT TEMP_SENSOR_IS_MAX_TC(0) + TEMP_SENSOR_IS_MAX_TC(1) + TEMP_SENSOR_IS_MAX_TC(REDUNDANT)
+      #define MAX_TC_COUNT TEMP_SENSOR_IS_MAX_TC(0) + TEMP_SENSOR_IS_MAX_TC(1) + TEMP_SENSOR_IS_MAX_TC(2) + TEMP_SENSOR_IS_MAX_TC(REDUNDANT)
       #if MAX_TC_COUNT > 1
         #define HAS_MULTI_MAX_TC 1
-        #define READ_MAX_TC(N) read_max_tc(N)
-      #else
-        #define READ_MAX_TC(N) read_max_tc()
       #endif
+      #define READ_MAX_TC(N) read_max_tc(TERN_(HAS_MULTI_MAX_TC, N))
       static raw_adc_t read_max_tc(TERN_(HAS_MULTI_MAX_TC, const uint8_t hindex=0));
     #endif
+    #if TEMP_SENSOR_IS_MAX_TC(BED)
+      static raw_adc_t read_max_tc_bed();
+    #endif
 
     #if HAS_AUTO_FAN
       #if ENABLED(POWER_OFF_WAIT_FOR_COOLDOWN)
         static bool autofans_on;
       #endif
       static void update_autofans();
     #endif
 
     #if HAS_HOTEND
       static float get_pid_output_hotend(const uint8_t e);

commit 820d2b58b3cfe16affd421f4925ae924cb60826f
Author: Martin Turski <turningtides@outlook.de>
Date:   Fri Aug 4 04:40:38 2023 +0200

    üö∏ Option to report temperature on error (#25341)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index a8873bf2af..d5a27a8671 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -34,20 +34,22 @@
 #endif
 
 #if ENABLED(AUTO_REPORT_TEMPERATURES)
   #include "../libs/autoreport.h"
 #endif
 
 #if HAS_FANCHECK
   #include "../feature/fancheck.h"
 #endif
 
+//#define ERR_INCLUDE_TEMP
+
 #define HOTEND_INDEX TERN(HAS_MULTI_HOTEND, e, 0)
 #define E_NAME TERN_(HAS_MULTI_HOTEND, e)
 
 #if HAS_FAN
   #if NUM_REDUNDANT_FANS
     #define FAN_IS_REDUNDANT(Q) WITHIN(Q, REDUNDANT_PART_COOLING_FAN, REDUNDANT_PART_COOLING_FAN + NUM_REDUNDANT_FANS - 1)
   #else
     #define FAN_IS_REDUNDANT(Q) false
   #endif
   #define FAN_IS_M106ABLE(Q) (HAS_FAN##Q && !FAN_IS_REDUNDANT(Q))
@@ -1353,23 +1355,27 @@ class Temperature {
     #if HAS_HOTEND
       static float get_pid_output_hotend(const uint8_t e);
     #endif
     #if ENABLED(PIDTEMPBED)
       static float get_pid_output_bed();
     #endif
     #if ENABLED(PIDTEMPCHAMBER)
       static float get_pid_output_chamber();
     #endif
 
-    static void _temp_error(const heater_id_t e, FSTR_P const serial_msg, FSTR_P const lcd_msg);
-    static void mintemp_error(const heater_id_t e);
-    static void maxtemp_error(const heater_id_t e);
+    static void _temp_error(const heater_id_t e, FSTR_P const serial_msg, FSTR_P const lcd_msg OPTARG(ERR_INCLUDE_TEMP, const celsius_float_t deg));
+    static void mintemp_error(const heater_id_t e OPTARG(ERR_INCLUDE_TEMP, const celsius_float_t deg));
+    static void maxtemp_error(const heater_id_t e OPTARG(ERR_INCLUDE_TEMP, const celsius_float_t deg));
+
+    #define _TEMP_ERROR(e, m, l, d) _temp_error(heater_id_t(e), m, GET_TEXT_F(l) OPTARG(ERR_INCLUDE_TEMP, d))
+    #define MINTEMP_ERROR(e, d) mintemp_error(heater_id_t(e) OPTARG(ERR_INCLUDE_TEMP, d))
+    #define MAXTEMP_ERROR(e, d) maxtemp_error(heater_id_t(e) OPTARG(ERR_INCLUDE_TEMP, d))
 
     #define HAS_THERMAL_PROTECTION ANY(THERMAL_PROTECTION_HOTENDS, THERMAL_PROTECTION_CHAMBER, THERMAL_PROTECTION_BED, THERMAL_PROTECTION_COOLER)
 
     #if HAS_THERMAL_PROTECTION
 
       // Indices and size for the tr_state_machine array. One for each protected heater.
       enum RunawayIndex : int8_t {
         _RI = -1
         #if ENABLED(THERMAL_PROTECTION_HOTENDS)
           #define _RUNAWAY_IND_E(N) ,RUNAWAY_IND_E##N

commit 97e15812fa15cf3ee9f260089282eb5e69915c4e
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Thu Jun 29 13:21:14 2023 -0400

    üî® Makefile + 256K Creality Maple + Heater IDs (#26018)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 51fa6f1eff..a8873bf2af 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -48,32 +48,21 @@
   #if NUM_REDUNDANT_FANS
     #define FAN_IS_REDUNDANT(Q) WITHIN(Q, REDUNDANT_PART_COOLING_FAN, REDUNDANT_PART_COOLING_FAN + NUM_REDUNDANT_FANS - 1)
   #else
     #define FAN_IS_REDUNDANT(Q) false
   #endif
   #define FAN_IS_M106ABLE(Q) (HAS_FAN##Q && !FAN_IS_REDUNDANT(Q))
 #else
   #define FAN_IS_M106ABLE(Q) false
 #endif
 
-// Element identifiers. Positive values are hotends. Negative values are other heaters or coolers.
-typedef enum : int_fast8_t {
-  H_REDUNDANT = HID_REDUNDANT,
-  H_COOLER = HID_COOLER,
-  H_PROBE = HID_PROBE,
-  H_BOARD = HID_BOARD,
-  H_SOC = HID_SOC,
-  H_CHAMBER = HID_CHAMBER,
-  H_BED = HID_BED,
-  H_E0 = HID_E0, H_E1, H_E2, H_E3, H_E4, H_E5, H_E6, H_E7,
-  H_NONE = -128
-} heater_id_t;
+typedef int_fast8_t heater_id_t;
 
 /**
  * States for ADC reading in the ISR
  */
 enum ADCSensorState : char {
   StartSampling,
   #if HAS_TEMP_ADC_0
     PrepareTemp_0, MeasureTemp_0,
   #endif
   #if HAS_TEMP_ADC_BED

commit 46b5753f5653401bc2d1d3120041a897384db48d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jun 27 20:33:57 2023 -0500

    üé® Indent temp structs

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index b0cb3d778e..51fa6f1eff 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -170,209 +170,209 @@ typedef struct { float p, i, d, c, f; } raw_pidcf_t;
   #define scalePID_d(d)   ( float(d) / PID_dT )
   #define unscalePID_d(d) ( float(d) * PID_dT )
 
   /// @brief The default PID class, only has Kp, Ki, Kd, other classes extend this one
   /// @tparam MIN_POW output when current is above target by functional_range
   /// @tparam MAX_POW output when current is below target by functional_range
   /// @details This class has methods for Kc and Kf terms, but returns constant default values
   /// PID classes that implement these features are expected to override these methods
   /// Since the finally used PID class is typedef-d, there is no need to use virtual functions
   template<int MIN_POW, int MAX_POW>
-  struct PID_t{
-  protected:
-    bool pid_reset = true;
-    float temp_iState = 0.0f, temp_dState = 0.0f;
-    float work_p = 0, work_i = 0, work_d = 0;
-
-  public:
-    float Kp = 0, Ki = 0, Kd = 0;
-    float p() const { return Kp; }
-    float i() const { return unscalePID_i(Ki); }
-    float d() const { return unscalePID_d(Kd); }
-    float c() const { return 1; }
-    float f() const { return 0; }
-    float pTerm() const { return work_p; }
-    float iTerm() const { return work_i; }
-    float dTerm() const { return work_d; }
-    float cTerm() const { return 0; }
-    float fTerm() const { return 0; }
-    void set_Kp(float p) { Kp = p; }
-    void set_Ki(float i) { Ki = scalePID_i(i); }
-    void set_Kd(float d) { Kd = scalePID_d(d); }
-    void set_Kc(float) {}
-    void set_Kf(float) {}
-    int low() const { return MIN_POW; }
-    int high() const { return MAX_POW; }
-    void reset() { pid_reset = true; }
-    void set(float p, float i, float d, float c=1, float f=0) { set_Kp(p); set_Ki(i); set_Kd(d); set_Kc(c); set_Kf(f); }
-    void set(const raw_pid_t &raw) { set(raw.p, raw.i, raw.d); }
-    void set(const raw_pidcf_t &raw) { set(raw.p, raw.i, raw.d, raw.c, raw.f); }
-
-    float get_fan_scale_output(const uint8_t) { return 0; }
-
-    float get_extrusion_scale_output(const bool, const int32_t, const float, const int16_t) { return 0; }
-
-    float get_pid_output(const float target, const float current) {
-      const float pid_error = target - current;
-      if (!target || pid_error < -(PID_FUNCTIONAL_RANGE)) {
-        pid_reset = true;
-        return 0;
-      }
-      else if (pid_error > PID_FUNCTIONAL_RANGE) {
-        pid_reset = true;
-        return MAX_POW;
-      }
+  struct PID_t {
+    protected:
+      bool pid_reset = true;
+      float temp_iState = 0.0f, temp_dState = 0.0f;
+      float work_p = 0, work_i = 0, work_d = 0;
+
+    public:
+      float Kp = 0, Ki = 0, Kd = 0;
+      float p() const { return Kp; }
+      float i() const { return unscalePID_i(Ki); }
+      float d() const { return unscalePID_d(Kd); }
+      float c() const { return 1; }
+      float f() const { return 0; }
+      float pTerm() const { return work_p; }
+      float iTerm() const { return work_i; }
+      float dTerm() const { return work_d; }
+      float cTerm() const { return 0; }
+      float fTerm() const { return 0; }
+      void set_Kp(float p) { Kp = p; }
+      void set_Ki(float i) { Ki = scalePID_i(i); }
+      void set_Kd(float d) { Kd = scalePID_d(d); }
+      void set_Kc(float) {}
+      void set_Kf(float) {}
+      int low() const { return MIN_POW; }
+      int high() const { return MAX_POW; }
+      void reset() { pid_reset = true; }
+      void set(float p, float i, float d, float c=1, float f=0) { set_Kp(p); set_Ki(i); set_Kd(d); set_Kc(c); set_Kf(f); }
+      void set(const raw_pid_t &raw) { set(raw.p, raw.i, raw.d); }
+      void set(const raw_pidcf_t &raw) { set(raw.p, raw.i, raw.d, raw.c, raw.f); }
+
+      float get_fan_scale_output(const uint8_t) { return 0; }
+
+      float get_extrusion_scale_output(const bool, const int32_t, const float, const int16_t) { return 0; }
+
+      float get_pid_output(const float target, const float current) {
+        const float pid_error = target - current;
+        if (!target || pid_error < -(PID_FUNCTIONAL_RANGE)) {
+          pid_reset = true;
+          return 0;
+        }
+        else if (pid_error > PID_FUNCTIONAL_RANGE) {
+          pid_reset = true;
+          return MAX_POW;
+        }
 
-      if (pid_reset) {
-        pid_reset = false;
-        temp_iState = 0.0;
-        work_d = 0.0;
-      }
+        if (pid_reset) {
+          pid_reset = false;
+          temp_iState = 0.0;
+          work_d = 0.0;
+        }
 
-      const float max_power_over_i_gain = float(MAX_POW) / Ki - float(MIN_POW);
-      temp_iState = constrain(temp_iState + pid_error, 0, max_power_over_i_gain);
+        const float max_power_over_i_gain = float(MAX_POW) / Ki - float(MIN_POW);
+        temp_iState = constrain(temp_iState + pid_error, 0, max_power_over_i_gain);
 
-      work_p = Kp * pid_error;
-      work_i = Ki * temp_iState;
-      work_d = work_d + PID_K2 * (Kd * (temp_dState - current) - work_d);
+        work_p = Kp * pid_error;
+        work_i = Ki * temp_iState;
+        work_d = work_d + PID_K2 * (Kd * (temp_dState - current) - work_d);
 
-      temp_dState = current;
+        temp_dState = current;
 
-      return constrain(work_p + work_i + work_d + float(MIN_POW), 0, MAX_POW);
-    }
+        return constrain(work_p + work_i + work_d + float(MIN_POW), 0, MAX_POW);
+      }
 
   };
 
 #endif // HAS_PID_HEATING
 
 #if ENABLED(PIDTEMP)
 
   /// @brief Extrusion scaled PID class
   template<int MIN_POW, int MAX_POW, int LPQ_ARR_SZ>
   struct PIDC_t : public PID_t<MIN_POW, MAX_POW> {
-  private:
-    using base = PID_t<MIN_POW, MAX_POW>;
-    float work_c = 0;
-    float prev_e_pos = 0;
-    int32_t lpq[LPQ_ARR_SZ] = {};
-    int16_t lpq_ptr = 0;
-  public:
-    float Kc = 0;
-    float c() const { return Kc; }
-    void set_Kc(float c) { Kc = c; }
-    float cTerm() const { return work_c; }
-    void set(float p, float i, float d, float c=1, float f=0) {
-      base::set_Kp(p);
-      base::set_Ki(i);
-      base::set_Kd(d);
-      set_Kc(c);
-      base::set_Kf(f);
-    }
-    void set(const raw_pid_t &raw) { set(raw.p, raw.i, raw.d); }
-    void set(const raw_pidcf_t &raw) { set(raw.p, raw.i, raw.d, raw.c, raw.f); }
-    void reset() {
-      base::reset();
-      prev_e_pos = 0;
-      lpq_ptr = 0;
-      for (uint8_t i = 0; i < LPQ_ARR_SZ; ++i) lpq[i] = 0;
-    }
+    private:
+      using base = PID_t<MIN_POW, MAX_POW>;
+      float work_c = 0;
+      float prev_e_pos = 0;
+      int32_t lpq[LPQ_ARR_SZ] = {};
+      int16_t lpq_ptr = 0;
+    public:
+      float Kc = 0;
+      float c() const { return Kc; }
+      void set_Kc(float c) { Kc = c; }
+      float cTerm() const { return work_c; }
+      void set(float p, float i, float d, float c=1, float f=0) {
+        base::set_Kp(p);
+        base::set_Ki(i);
+        base::set_Kd(d);
+        set_Kc(c);
+        base::set_Kf(f);
+      }
+      void set(const raw_pid_t &raw) { set(raw.p, raw.i, raw.d); }
+      void set(const raw_pidcf_t &raw) { set(raw.p, raw.i, raw.d, raw.c, raw.f); }
+      void reset() {
+        base::reset();
+        prev_e_pos = 0;
+        lpq_ptr = 0;
+        for (uint8_t i = 0; i < LPQ_ARR_SZ; ++i) lpq[i] = 0;
+      }
 
-    float get_extrusion_scale_output(const bool is_active, const int32_t e_position, const float e_mm_per_step, const int16_t lpq_len) {
-      work_c = 0;
-      if (!is_active) return work_c;
+      float get_extrusion_scale_output(const bool is_active, const int32_t e_position, const float e_mm_per_step, const int16_t lpq_len) {
+        work_c = 0;
+        if (!is_active) return work_c;
 
-      if (e_position > prev_e_pos) {
-        lpq[lpq_ptr] = e_position - prev_e_pos;
-        prev_e_pos = e_position;
-      }
-      else
-        lpq[lpq_ptr] = 0;
+        if (e_position > prev_e_pos) {
+          lpq[lpq_ptr] = e_position - prev_e_pos;
+          prev_e_pos = e_position;
+        }
+        else
+          lpq[lpq_ptr] = 0;
 
-      ++lpq_ptr;
+        ++lpq_ptr;
 
-      if (lpq_ptr >= LPQ_ARR_SZ || lpq_ptr >= lpq_len)
-        lpq_ptr = 0;
+        if (lpq_ptr >= LPQ_ARR_SZ || lpq_ptr >= lpq_len)
+          lpq_ptr = 0;
 
-      work_c = (lpq[lpq_ptr] * e_mm_per_step) * Kc;
+        work_c = (lpq[lpq_ptr] * e_mm_per_step) * Kc;
 
-      return work_c;
-    }
+        return work_c;
+      }
   };
 
   /// @brief Fan scaled PID, this class implements the get_fan_scale_output() method
   /// @tparam MIN_POW @see PID_t
   /// @tparam MAX_POW @see PID_t
   /// @tparam SCALE_MIN_SPEED parameter from Configuration_adv.h
   /// @tparam SCALE_LIN_FACTOR parameter from Configuration_adv.h
   template<int MIN_POW, int MAX_POW, int SCALE_MIN_SPEED, int SCALE_LIN_FACTOR>
   struct PIDF_t : public PID_t<MIN_POW, MAX_POW> {
-  private:
-    using base = PID_t<MIN_POW, MAX_POW>;
-    float work_f = 0;
-  public:
-    float Kf = 0;
-    float f() const { return Kf; }
-    void set_Kf(float f) { Kf = f; }
-    float fTerm() const { return work_f; }
-    void set(float p, float i, float d, float c=1, float f=0) {
-      base::set_Kp(p);
-      base::set_Ki(i);
-      base::set_Kd(d);
-      base::set_Kc(c);
-      set_Kf(f);
-    }
-    void set(const raw_pid_t &raw) { set(raw.p, raw.i, raw.d); }
-    void set(const raw_pidcf_t &raw) { set(raw.p, raw.i, raw.d, raw.c, raw.f); }
+    private:
+      using base = PID_t<MIN_POW, MAX_POW>;
+      float work_f = 0;
+    public:
+      float Kf = 0;
+      float f() const { return Kf; }
+      void set_Kf(float f) { Kf = f; }
+      float fTerm() const { return work_f; }
+      void set(float p, float i, float d, float c=1, float f=0) {
+        base::set_Kp(p);
+        base::set_Ki(i);
+        base::set_Kd(d);
+        base::set_Kc(c);
+        set_Kf(f);
+      }
+      void set(const raw_pid_t &raw) { set(raw.p, raw.i, raw.d); }
+      void set(const raw_pidcf_t &raw) { set(raw.p, raw.i, raw.d, raw.c, raw.f); }
 
-    float get_fan_scale_output(const uint8_t fan_speed) {
-      work_f = 0;
-      if (fan_speed > SCALE_MIN_SPEED)
-        work_f = Kf + (SCALE_LIN_FACTOR) * fan_speed;
+      float get_fan_scale_output(const uint8_t fan_speed) {
+        work_f = 0;
+        if (fan_speed > SCALE_MIN_SPEED)
+          work_f = Kf + (SCALE_LIN_FACTOR) * fan_speed;
 
-      return work_f;
-    }
+        return work_f;
+      }
   };
 
   /// @brief Inherits PID and PIDC - can't use proper diamond inheritance w/o virtual
   template<int MIN_POW, int MAX_POW, int LPQ_ARR_SZ, int SCALE_MIN_SPEED, int SCALE_LIN_FACTOR>
   struct PIDCF_t : public PIDC_t<MIN_POW, MAX_POW, LPQ_ARR_SZ> {
-  private:
-    using base = PID_t<MIN_POW, MAX_POW>;
-    using cPID = PIDC_t<MIN_POW, MAX_POW, LPQ_ARR_SZ>;
-    float work_f = 0;
-  public:
-    float Kf = 0;
-    float c() const { return cPID::c(); }
-    float f() const { return Kf; }
-    void set_Kc(float c) { cPID::set_Kc(c); }
-    void set_Kf(float f) { Kf = f; }
-    float cTerm() const { return cPID::cTerm(); }
-    float fTerm() const { return work_f; }
-    void set(float p, float i, float d, float c=1, float f=0) {
-      base::set_Kp(p);
-      base::set_Ki(i);
-      base::set_Kd(d);
-      cPID::set_Kc(c);
-      set_Kf(f);
-    }
-    void set(const raw_pid_t &raw) { set(raw.p, raw.i, raw.d); }
-    void set(const raw_pidcf_t &raw) { set(raw.p, raw.i, raw.d, raw.c, raw.f); }
+    private:
+      using base = PID_t<MIN_POW, MAX_POW>;
+      using cPID = PIDC_t<MIN_POW, MAX_POW, LPQ_ARR_SZ>;
+      float work_f = 0;
+    public:
+      float Kf = 0;
+      float c() const { return cPID::c(); }
+      float f() const { return Kf; }
+      void set_Kc(float c) { cPID::set_Kc(c); }
+      void set_Kf(float f) { Kf = f; }
+      float cTerm() const { return cPID::cTerm(); }
+      float fTerm() const { return work_f; }
+      void set(float p, float i, float d, float c=1, float f=0) {
+        base::set_Kp(p);
+        base::set_Ki(i);
+        base::set_Kd(d);
+        cPID::set_Kc(c);
+        set_Kf(f);
+      }
+      void set(const raw_pid_t &raw) { set(raw.p, raw.i, raw.d); }
+      void set(const raw_pidcf_t &raw) { set(raw.p, raw.i, raw.d, raw.c, raw.f); }
 
-    void reset() { cPID::reset(); }
+      void reset() { cPID::reset(); }
 
-    float get_fan_scale_output(const uint8_t fan_speed) {
-      work_f = fan_speed > (SCALE_MIN_SPEED) ? Kf + (SCALE_LIN_FACTOR) * fan_speed : 0;
-      return work_f;
-    }
-    float get_extrusion_scale_output(const bool is_active, const int32_t e_position, const float e_mm_per_step, const int16_t lpq_len) {
-      return cPID::get_extrusion_scale_output(is_active, e_position, e_mm_per_step, lpq_len);
-    }
+      float get_fan_scale_output(const uint8_t fan_speed) {
+        work_f = fan_speed > (SCALE_MIN_SPEED) ? Kf + (SCALE_LIN_FACTOR) * fan_speed : 0;
+        return work_f;
+      }
+      float get_extrusion_scale_output(const bool is_active, const int32_t e_position, const float e_mm_per_step, const int16_t lpq_len) {
+        return cPID::get_extrusion_scale_output(is_active, e_position, e_mm_per_step, lpq_len);
+      }
   };
 
   typedef
     #if ALL(PID_EXTRUSION_SCALING, PID_FAN_SCALING)
       PIDCF_t<0, PID_MAX, LPQ_MAX_LEN, PID_FAN_SCALING_MIN_SPEED, PID_FAN_SCALING_LIN_FACTOR>
     #elif ENABLED(PID_EXTRUSION_SCALING)
       PIDC_t<0, PID_MAX, LPQ_MAX_LEN>
     #elif ENABLED(PID_FAN_SCALING)
       PIDF_t<0, PID_MAX, PID_FAN_SCALING_MIN_SPEED, PID_FAN_SCALING_LIN_FACTOR>
     #else
@@ -408,30 +408,30 @@ typedef struct { float p, i, d, c, f; } raw_pidcf_t;
   #define MPC_dT ((OVERSAMPLENR * float(ACTUAL_ADC_SAMPLES)) / (TEMP_TIMER_FREQUENCY))
 
 #endif
 
 #if ENABLED(G26_MESH_VALIDATION) && ANY(HAS_MARLINUI_MENU, EXTENSIBLE_UI)
   #define G26_CLICK_CAN_CANCEL 1
 #endif
 
 // A temperature sensor
 typedef struct TempInfo {
-private:
-  raw_adc_t acc;
-  raw_adc_t raw;
-public:
-  celsius_float_t celsius;
-  inline void reset() { acc = 0; }
-  inline void sample(const raw_adc_t s) { acc += s; }
-  inline void update() { raw = acc; }
-  void setraw(const raw_adc_t r) { raw = r; }
-  raw_adc_t getraw() const { return raw; }
+  private:
+    raw_adc_t acc;
+    raw_adc_t raw;
+  public:
+    celsius_float_t celsius;
+    inline void reset() { acc = 0; }
+    inline void sample(const raw_adc_t s) { acc += s; }
+    inline void update() { raw = acc; }
+    void setraw(const raw_adc_t r) { raw = r; }
+    raw_adc_t getraw() const { return raw; }
 } temp_info_t;
 
 #if HAS_TEMP_REDUNDANT
   // A redundant temperature sensor
   typedef struct RedundantTempInfo : public TempInfo {
     temp_info_t* target;
   } redundant_info_t;
 #endif
 
 // A PWM heater with temperature sensor

commit 86c811660ebf0b3fcbae2f34273d4c9d0c22abc4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:30:34 2023 -0500

    üßë‚Äçüíª Remove LOOP macros (#25917)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 9d1d68cf0b..b0cb3d778e 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -266,21 +266,21 @@ typedef struct { float p, i, d, c, f; } raw_pidcf_t;
       base::set_Kd(d);
       set_Kc(c);
       base::set_Kf(f);
     }
     void set(const raw_pid_t &raw) { set(raw.p, raw.i, raw.d); }
     void set(const raw_pidcf_t &raw) { set(raw.p, raw.i, raw.d, raw.c, raw.f); }
     void reset() {
       base::reset();
       prev_e_pos = 0;
       lpq_ptr = 0;
-      LOOP_L_N(i, LPQ_ARR_SZ) lpq[i] = 0;
+      for (uint8_t i = 0; i < LPQ_ARR_SZ; ++i) lpq[i] = 0;
     }
 
     float get_extrusion_scale_output(const bool is_active, const int32_t e_position, const float e_mm_per_step, const int16_t lpq_len) {
       work_c = 0;
       if (!is_active) return work_c;
 
       if (e_position > prev_e_pos) {
         lpq[lpq_ptr] = e_position - prev_e_pos;
         prev_e_pos = e_position;
       }
@@ -870,21 +870,21 @@ class Temperature {
     #if HAS_TEMP_SOC
       static celsius_float_t analog_to_celsius_soc(const raw_adc_t raw);
     #endif
     #if HAS_TEMP_REDUNDANT
       static celsius_float_t analog_to_celsius_redundant(const raw_adc_t raw);
     #endif
 
     #if HAS_FAN
 
       static uint8_t fan_speed[FAN_COUNT];
-      #define FANS_LOOP(I) LOOP_L_N(I, FAN_COUNT)
+      #define FANS_LOOP(I) for (uint8_t I = 0; I < FAN_COUNT; ++I)
 
       static void set_fan_speed(const uint8_t fan, const uint16_t speed);
 
       #if ENABLED(REPORT_FAN_CHANGE)
         static void report_fan_speed(const uint8_t fan);
       #endif
 
       #if ANY(PROBING_FANS_OFF, ADVANCED_PAUSE_FANS_PAUSE)
         static bool fans_paused;
         static uint8_t saved_fan_speed[FAN_COUNT];

commit 2691167afe02fbbe74b0fdca2c28a49fac635741
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:26:02 2023 -0500

    üßë‚Äçüíª Dump BOTH and EITHER macros (#25908)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index c4dae4c6e5..9d1d68cf0b 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -362,21 +362,21 @@ typedef struct { float p, i, d, c, f; } raw_pidcf_t;
     float get_fan_scale_output(const uint8_t fan_speed) {
       work_f = fan_speed > (SCALE_MIN_SPEED) ? Kf + (SCALE_LIN_FACTOR) * fan_speed : 0;
       return work_f;
     }
     float get_extrusion_scale_output(const bool is_active, const int32_t e_position, const float e_mm_per_step, const int16_t lpq_len) {
       return cPID::get_extrusion_scale_output(is_active, e_position, e_mm_per_step, lpq_len);
     }
   };
 
   typedef
-    #if BOTH(PID_EXTRUSION_SCALING, PID_FAN_SCALING)
+    #if ALL(PID_EXTRUSION_SCALING, PID_FAN_SCALING)
       PIDCF_t<0, PID_MAX, LPQ_MAX_LEN, PID_FAN_SCALING_MIN_SPEED, PID_FAN_SCALING_LIN_FACTOR>
     #elif ENABLED(PID_EXTRUSION_SCALING)
       PIDC_t<0, PID_MAX, LPQ_MAX_LEN>
     #elif ENABLED(PID_FAN_SCALING)
       PIDF_t<0, PID_MAX, PID_FAN_SCALING_MIN_SPEED, PID_FAN_SCALING_LIN_FACTOR>
     #else
       PID_t<0, PID_MAX>
     #endif
   hotend_pid_t;
 
@@ -402,21 +402,21 @@ typedef struct { float p, i, d, c, f; } raw_pidcf_t;
     #else
       void applyFanAdjustment(const_float_t) {}
     #endif
     float fanCoefficient() { return SUM_TERN(MPC_INCLUDE_FAN, ambient_xfer_coeff_fan0, fan255_adjustment); }
   } MPC_t;
 
   #define MPC_dT ((OVERSAMPLENR * float(ACTUAL_ADC_SAMPLES)) / (TEMP_TIMER_FREQUENCY))
 
 #endif
 
-#if ENABLED(G26_MESH_VALIDATION) && EITHER(HAS_MARLINUI_MENU, EXTENSIBLE_UI)
+#if ENABLED(G26_MESH_VALIDATION) && ANY(HAS_MARLINUI_MENU, EXTENSIBLE_UI)
   #define G26_CLICK_CAN_CANCEL 1
 #endif
 
 // A temperature sensor
 typedef struct TempInfo {
 private:
   raw_adc_t acc;
   raw_adc_t raw;
 public:
   celsius_float_t celsius;
@@ -478,21 +478,21 @@ struct PIDHeaterInfo : public HeaterInfo {
     typedef struct PIDHeaterInfo<PID_t<MIN_CHAMBER_POWER, MAX_CHAMBER_POWER>> chamber_info_t;
   #else
     typedef heater_info_t chamber_info_t;
   #endif
 #elif HAS_TEMP_CHAMBER
   typedef temp_info_t chamber_info_t;
 #endif
 #if HAS_TEMP_PROBE
   typedef temp_info_t probe_info_t;
 #endif
-#if EITHER(HAS_COOLER, HAS_TEMP_COOLER)
+#if ANY(HAS_COOLER, HAS_TEMP_COOLER)
   typedef heater_info_t cooler_info_t;
 #endif
 #if HAS_TEMP_BOARD
   typedef temp_info_t board_info_t;
 #endif
 #if HAS_TEMP_SOC
   typedef temp_info_t soc_info_t;
 #endif
 
 // Heater watch handling
@@ -621,40 +621,40 @@ class Temperature {
     #if HAS_TEMP_BOARD
       static board_info_t temp_board;
     #endif
     #if HAS_TEMP_SOC
       static soc_info_t temp_soc;
     #endif
     #if HAS_TEMP_REDUNDANT
       static redundant_info_t temp_redundant;
     #endif
 
-    #if EITHER(AUTO_POWER_E_FANS, HAS_FANCHECK)
+    #if ANY(AUTO_POWER_E_FANS, HAS_FANCHECK)
       static uint8_t autofan_speed[HOTENDS];
     #endif
     #if ENABLED(AUTO_POWER_CHAMBER_FAN)
       static uint8_t chamberfan_speed;
     #endif
     #if ENABLED(AUTO_POWER_COOLER_FAN)
       static uint8_t coolerfan_speed;
     #endif
 
     #if ENABLED(FAN_SOFT_PWM)
       static uint8_t soft_pwm_amount_fan[FAN_COUNT],
                      soft_pwm_count_fan[FAN_COUNT];
     #endif
 
-    #if BOTH(FAN_SOFT_PWM, USE_CONTROLLER_FAN)
+    #if ALL(FAN_SOFT_PWM, USE_CONTROLLER_FAN)
       static uint8_t soft_pwm_controller_speed;
     #endif
 
-    #if BOTH(HAS_MARLINUI_MENU, PREVENT_COLD_EXTRUSION) && E_MANUAL > 0
+    #if ALL(HAS_MARLINUI_MENU, PREVENT_COLD_EXTRUSION) && E_MANUAL > 0
       static bool allow_cold_extrude_override;
       static void set_menu_cold_override(const bool allow) { allow_cold_extrude_override = allow; }
     #else
       static constexpr bool allow_cold_extrude_override = false;
       static void set_menu_cold_override(const bool) {}
     #endif
 
     #if ENABLED(PREVENT_COLD_EXTRUSION)
       static bool allow_cold_extrude;
       static celsius_t extrude_min_temp;
@@ -664,21 +664,21 @@ class Temperature {
     #else
       static constexpr bool allow_cold_extrude = true;
       static constexpr celsius_t extrude_min_temp = 0;
       static bool tooColdToExtrude(const uint8_t) { return false; }
       static bool targetTooColdToExtrude(const uint8_t) { return false; }
     #endif
 
     static bool hotEnoughToExtrude(const uint8_t e) { return !tooColdToExtrude(e); }
     static bool targetHotEnoughToExtrude(const uint8_t e) { return !targetTooColdToExtrude(e); }
 
-    #if EITHER(SINGLENOZZLE_STANDBY_TEMP, SINGLENOZZLE_STANDBY_FAN)
+    #if ANY(SINGLENOZZLE_STANDBY_TEMP, SINGLENOZZLE_STANDBY_FAN)
       #if ENABLED(SINGLENOZZLE_STANDBY_TEMP)
         static celsius_t singlenozzle_temp[EXTRUDERS];
       #endif
       #if ENABLED(SINGLENOZZLE_STANDBY_FAN)
         static uint8_t singlenozzle_fan_speed[EXTRUDERS];
       #endif
       static void singlenozzle_change(const uint8_t old_tool, const uint8_t new_tool);
     #endif
 
     #if HEATER_IDLE_HANDLER
@@ -760,25 +760,25 @@ class Temperature {
     #endif
 
     #if HAS_COOLER
       #if WATCH_COOLER
         static cooler_watch_t watch_cooler;
       #endif
       static millis_t next_cooler_check_ms, cooler_fan_flush_ms;
       static raw_adc_t mintemp_raw_COOLER, maxtemp_raw_COOLER;
     #endif
 
-    #if BOTH(HAS_TEMP_BOARD, THERMAL_PROTECTION_BOARD)
+    #if ALL(HAS_TEMP_BOARD, THERMAL_PROTECTION_BOARD)
       static raw_adc_t mintemp_raw_BOARD, maxtemp_raw_BOARD;
     #endif
 
-    #if BOTH(HAS_TEMP_SOC, THERMAL_PROTECTION_SOC)
+    #if ALL(HAS_TEMP_SOC, THERMAL_PROTECTION_SOC)
       static raw_adc_t maxtemp_raw_SOC;
     #endif
 
     #if MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED > 1
       static uint8_t consecutive_low_temperature_error[HOTENDS];
     #endif
 
     #if HAS_FAN_LOGIC
       static millis_t fan_update_ms;
 
@@ -878,21 +878,21 @@ class Temperature {
 
       static uint8_t fan_speed[FAN_COUNT];
       #define FANS_LOOP(I) LOOP_L_N(I, FAN_COUNT)
 
       static void set_fan_speed(const uint8_t fan, const uint16_t speed);
 
       #if ENABLED(REPORT_FAN_CHANGE)
         static void report_fan_speed(const uint8_t fan);
       #endif
 
-      #if EITHER(PROBING_FANS_OFF, ADVANCED_PAUSE_FANS_PAUSE)
+      #if ANY(PROBING_FANS_OFF, ADVANCED_PAUSE_FANS_PAUSE)
         static bool fans_paused;
         static uint8_t saved_fan_speed[FAN_COUNT];
       #endif
 
       #if ENABLED(ADAPTIVE_FAN_SLOWING)
         static uint8_t fan_speed_scaler[FAN_COUNT];
       #endif
 
       static uint8_t scaledFanSpeed(const uint8_t fan, const uint8_t fs) {
         UNUSED(fan); // Potentially unused!
@@ -906,21 +906,21 @@ class Temperature {
       static constexpr inline uint8_t pwmToPercent(const uint8_t speed) { return ui8_to_percent(speed); }
       static uint8_t fanSpeedPercent(const uint8_t fan)          { return ui8_to_percent(fan_speed[fan]); }
       static uint8_t scaledFanSpeedPercent(const uint8_t fan)    { return ui8_to_percent(scaledFanSpeed(fan)); }
 
       #if ENABLED(EXTRA_FAN_SPEED)
         typedef struct { uint8_t saved, speed; } extra_fan_t;
         static extra_fan_t extra_fan_speed[FAN_COUNT];
         static void set_temp_fan_speed(const uint8_t fan, const uint16_t command_or_speed);
       #endif
 
-      #if EITHER(PROBING_FANS_OFF, ADVANCED_PAUSE_FANS_PAUSE)
+      #if ANY(PROBING_FANS_OFF, ADVANCED_PAUSE_FANS_PAUSE)
         void set_fans_paused(const bool p);
       #endif
 
     #endif // HAS_FAN
 
     static void zero_fan_speeds() {
       #if HAS_FAN
         FANS_LOOP(i) set_fan_speed(i, 0);
       #endif
     }

commit 5859ff0280b51b3130e1d13740bfae79eff4d23e
Author: Vert <45634861+Vertabreak@users.noreply.github.com>
Date:   Sat May 13 17:51:12 2023 -0400

    ‚ú® NUM_REDUNDANT_FANS (#25808)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 4bd185c425..c4dae4c6e5 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -37,20 +37,31 @@
   #include "../libs/autoreport.h"
 #endif
 
 #if HAS_FANCHECK
   #include "../feature/fancheck.h"
 #endif
 
 #define HOTEND_INDEX TERN(HAS_MULTI_HOTEND, e, 0)
 #define E_NAME TERN_(HAS_MULTI_HOTEND, e)
 
+#if HAS_FAN
+  #if NUM_REDUNDANT_FANS
+    #define FAN_IS_REDUNDANT(Q) WITHIN(Q, REDUNDANT_PART_COOLING_FAN, REDUNDANT_PART_COOLING_FAN + NUM_REDUNDANT_FANS - 1)
+  #else
+    #define FAN_IS_REDUNDANT(Q) false
+  #endif
+  #define FAN_IS_M106ABLE(Q) (HAS_FAN##Q && !FAN_IS_REDUNDANT(Q))
+#else
+  #define FAN_IS_M106ABLE(Q) false
+#endif
+
 // Element identifiers. Positive values are hotends. Negative values are other heaters or coolers.
 typedef enum : int_fast8_t {
   H_REDUNDANT = HID_REDUNDANT,
   H_COOLER = HID_COOLER,
   H_PROBE = HID_PROBE,
   H_BOARD = HID_BOARD,
   H_SOC = HID_SOC,
   H_CHAMBER = HID_CHAMBER,
   H_BED = HID_BED,
   H_E0 = HID_E0, H_E1, H_E2, H_E3, H_E4, H_E5, H_E6, H_E7,

commit 01f5bd333055e919677d95e05bec1f5f067374a4
Author: StevilKnevil <stevilknevil@hotmail.co.uk>
Date:   Fri May 12 01:09:02 2023 +0100

    üö∏ Improved MPCTEMP autotune (#25503)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 27aef11c7e..4bd185c425 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -143,21 +143,21 @@ enum ADCSensorState : char {
 
 //
 // PID
 //
 
 typedef struct { float p, i, d; } raw_pid_t;
 typedef struct { float p, i, d, c, f; } raw_pidcf_t;
 
 #if HAS_PID_HEATING
 
-  #define PID_K2 (1-float(PID_K1))
+  #define PID_K2 (1.0f - float(PID_K1))
   #define PID_dT ((OVERSAMPLENR * float(ACTUAL_ADC_SAMPLES)) / (TEMP_TIMER_FREQUENCY))
 
   // Apply the scale factors to the PID values
   #define scalePID_i(i)   ( float(i) * PID_dT )
   #define unscalePID_i(i) ( float(i) / PID_dT )
   #define scalePID_d(d)   ( float(d) / PID_dT )
   #define unscalePID_d(d) ( float(d) * PID_dT )
 
   /// @brief The default PID class, only has Kp, Ki, Kd, other classes extend this one
   /// @tparam MIN_POW output when current is above target by functional_range
@@ -224,21 +224,21 @@ typedef struct { float p, i, d, c, f; } raw_pidcf_t;
       work_i = Ki * temp_iState;
       work_d = work_d + PID_K2 * (Kd * (temp_dState - current) - work_d);
 
       temp_dState = current;
 
       return constrain(work_p + work_i + work_d + float(MIN_POW), 0, MAX_POW);
     }
 
   };
 
-#endif
+#endif // HAS_PID_HEATING
 
 #if ENABLED(PIDTEMP)
 
   /// @brief Extrusion scaled PID class
   template<int MIN_POW, int MAX_POW, int LPQ_ARR_SZ>
   struct PIDC_t : public PID_t<MIN_POW, MAX_POW> {
   private:
     using base = PID_t<MIN_POW, MAX_POW>;
     float work_c = 0;
     float prev_e_pos = 0;
@@ -1208,25 +1208,82 @@ class Temperature {
         static void setPID(const uint8_t hotend, const_float_t p, const_float_t i, const_float_t d) {
           #if ENABLED(PID_PARAMS_PER_HOTEND)
             temp_hotend[hotend].pid.set(p, i, d);
           #else
             HOTEND_LOOP() temp_hotend[e].pid.set(p, i, d);
           #endif
           updatePID();
         }
       #endif
 
-    #endif
+    #endif // HAS_PID_HEATING
 
     #if ENABLED(MPC_AUTOTUNE)
-      void MPC_autotune(const uint8_t e);
-    #endif
+
+      // Utility class to perform MPCTEMP auto tuning measurements
+      class MPC_autotuner {
+        public:
+          enum MeasurementState { CANCELLED, FAILED, SUCCESS };
+          MPC_autotuner(const uint8_t extruderIdx);
+          ~MPC_autotuner();
+          MeasurementState measure_ambient_temp();
+          MeasurementState measure_heatup();
+          MeasurementState measure_transfer();
+
+          celsius_float_t get_ambient_temp() { return ambient_temp; }
+          celsius_float_t get_last_measured_temp() { return current_temp; }
+
+          float get_elapsed_heating_time() { return elapsed_heating_time; }
+          float get_sample_1_time() { return t1_time; }
+          static float get_sample_1_temp() { return temp_samples[0]; }
+          static float get_sample_2_temp() { return temp_samples[(sample_count - 1) >> 1]; }
+          static float get_sample_3_temp() { return temp_samples[sample_count - 1]; }
+          static float get_sample_interval() { return sample_distance * (sample_count >> 1); }
+
+          static celsius_float_t get_temp_fastest() { return temp_fastest; }
+          float get_time_fastest() { return time_fastest; }
+          float get_rate_fastest() { return rate_fastest; }
+
+          float get_power_fan0() { return power_fan0; }
+          #if HAS_FAN
+            static float get_power_fan255() { return power_fan255; }
+          #endif
+
+        protected:
+          static void init_timers() { curr_time_ms = next_report_ms = millis(); }
+          MeasurementState housekeeping();
+
+          uint8_t e;
+
+          float elapsed_heating_time;
+          celsius_float_t ambient_temp, current_temp;
+          float t1_time;
+
+          static millis_t curr_time_ms, next_report_ms;
+          static celsius_float_t temp_samples[16];
+          static uint8_t sample_count;
+          static uint16_t sample_distance;
+
+          // Parameters from differential analysis
+          static celsius_float_t temp_fastest;
+          float time_fastest, rate_fastest;
+
+          float power_fan0;
+          #if HAS_FAN
+            static float power_fan255;
+          #endif
+      };
+
+      enum MPCTuningType { AUTO, FORCE_ASYMPTOTIC, FORCE_DIFFERENTIAL };
+      static void MPC_autotune(const uint8_t e, MPCTuningType tuning_type);
+
+    #endif // MPC_AUTOTUNE
 
     #if ENABLED(PROBING_HEATERS_OFF)
       static void pause_heaters(const bool p);
     #endif
 
     #if HEATER_IDLE_HANDLER
 
       static void reset_hotend_idle_timer(const uint8_t E_NAME) {
         heater_idle[HOTEND_INDEX].reset();
         start_watching_hotend(HOTEND_INDEX);

commit a6404aca45ff1e3f09ad7a0702ae95689fd81338
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Tue May 9 22:52:59 2023 +0200

    üîß Move SOFT_PWM_SCALE fallback to cpp (#25800)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 2fdd1f02c8..27aef11c7e 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -34,24 +34,20 @@
 #endif
 
 #if ENABLED(AUTO_REPORT_TEMPERATURES)
   #include "../libs/autoreport.h"
 #endif
 
 #if HAS_FANCHECK
   #include "../feature/fancheck.h"
 #endif
 
-#ifndef SOFT_PWM_SCALE
-  #define SOFT_PWM_SCALE 0
-#endif
-
 #define HOTEND_INDEX TERN(HAS_MULTI_HOTEND, e, 0)
 #define E_NAME TERN_(HAS_MULTI_HOTEND, e)
 
 // Element identifiers. Positive values are hotends. Negative values are other heaters or coolers.
 typedef enum : int_fast8_t {
   H_REDUNDANT = HID_REDUNDANT,
   H_COOLER = HID_COOLER,
   H_PROBE = HID_PROBE,
   H_BOARD = HID_BOARD,
   H_SOC = HID_SOC,

commit f5a905a64121e4ff43894d295ce6990e55aa1149
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Tue Apr 25 04:51:44 2023 +0200

    ‚ú® TEMP_SENSOR_SOC (#25642)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 4bf76e5d48..2fdd1f02c8 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -47,20 +47,21 @@
 
 #define HOTEND_INDEX TERN(HAS_MULTI_HOTEND, e, 0)
 #define E_NAME TERN_(HAS_MULTI_HOTEND, e)
 
 // Element identifiers. Positive values are hotends. Negative values are other heaters or coolers.
 typedef enum : int_fast8_t {
   H_REDUNDANT = HID_REDUNDANT,
   H_COOLER = HID_COOLER,
   H_PROBE = HID_PROBE,
   H_BOARD = HID_BOARD,
+  H_SOC = HID_SOC,
   H_CHAMBER = HID_CHAMBER,
   H_BED = HID_BED,
   H_E0 = HID_E0, H_E1, H_E2, H_E3, H_E4, H_E5, H_E6, H_E7,
   H_NONE = -128
 } heater_id_t;
 
 /**
  * States for ADC reading in the ISR
  */
 enum ADCSensorState : char {
@@ -76,20 +77,23 @@ enum ADCSensorState : char {
   #endif
   #if HAS_TEMP_ADC_COOLER
     PrepareTemp_COOLER, MeasureTemp_COOLER,
   #endif
   #if HAS_TEMP_ADC_PROBE
     PrepareTemp_PROBE, MeasureTemp_PROBE,
   #endif
   #if HAS_TEMP_ADC_BOARD
     PrepareTemp_BOARD, MeasureTemp_BOARD,
   #endif
+  #if HAS_TEMP_ADC_SOC
+    PrepareTemp_SOC, MeasureTemp_SOC,
+  #endif
   #if HAS_TEMP_ADC_REDUNDANT
     PrepareTemp_REDUNDANT, MeasureTemp_REDUNDANT,
   #endif
   #if HAS_TEMP_ADC_1
     PrepareTemp_1, MeasureTemp_1,
   #endif
   #if HAS_TEMP_ADC_2
     PrepareTemp_2, MeasureTemp_2,
   #endif
   #if HAS_TEMP_ADC_3
@@ -473,20 +477,23 @@ struct PIDHeaterInfo : public HeaterInfo {
 #endif
 #if HAS_TEMP_PROBE
   typedef temp_info_t probe_info_t;
 #endif
 #if EITHER(HAS_COOLER, HAS_TEMP_COOLER)
   typedef heater_info_t cooler_info_t;
 #endif
 #if HAS_TEMP_BOARD
   typedef temp_info_t board_info_t;
 #endif
+#if HAS_TEMP_SOC
+  typedef temp_info_t soc_info_t;
+#endif
 
 // Heater watch handling
 template <int INCREASE, int HYSTERESIS, millis_t PERIOD>
 struct HeaterWatch {
   celsius_t target;
   millis_t next_ms;
   inline bool elapsed(const millis_t &ms) { return next_ms && ELAPSED(ms, next_ms); }
   inline bool elapsed() { return elapsed(millis()); }
 
   inline bool check(const celsius_t curr) { return curr >= target; }
@@ -600,20 +607,23 @@ class Temperature {
     #endif
     #if HAS_TEMP_CHAMBER
       static chamber_info_t temp_chamber;
     #endif
     #if HAS_TEMP_COOLER
       static cooler_info_t temp_cooler;
     #endif
     #if HAS_TEMP_BOARD
       static board_info_t temp_board;
     #endif
+    #if HAS_TEMP_SOC
+      static soc_info_t temp_soc;
+    #endif
     #if HAS_TEMP_REDUNDANT
       static redundant_info_t temp_redundant;
     #endif
 
     #if EITHER(AUTO_POWER_E_FANS, HAS_FANCHECK)
       static uint8_t autofan_speed[HOTENDS];
     #endif
     #if ENABLED(AUTO_POWER_CHAMBER_FAN)
       static uint8_t chamberfan_speed;
     #endif
@@ -747,20 +757,24 @@ class Temperature {
         static cooler_watch_t watch_cooler;
       #endif
       static millis_t next_cooler_check_ms, cooler_fan_flush_ms;
       static raw_adc_t mintemp_raw_COOLER, maxtemp_raw_COOLER;
     #endif
 
     #if BOTH(HAS_TEMP_BOARD, THERMAL_PROTECTION_BOARD)
       static raw_adc_t mintemp_raw_BOARD, maxtemp_raw_BOARD;
     #endif
 
+    #if BOTH(HAS_TEMP_SOC, THERMAL_PROTECTION_SOC)
+      static raw_adc_t maxtemp_raw_SOC;
+    #endif
+
     #if MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED > 1
       static uint8_t consecutive_low_temperature_error[HOTENDS];
     #endif
 
     #if HAS_FAN_LOGIC
       static millis_t fan_update_ms;
 
       static void manage_extruder_fans(millis_t ms) {
         if (ELAPSED(ms, fan_update_ms)) { // only need to check fan state very infrequently
           const millis_t next_ms = ms + fan_update_interval_ms;
@@ -839,20 +853,23 @@ class Temperature {
     #endif
     #if HAS_TEMP_PROBE
       static celsius_float_t analog_to_celsius_probe(const raw_adc_t raw);
     #endif
     #if HAS_TEMP_COOLER
       static celsius_float_t analog_to_celsius_cooler(const raw_adc_t raw);
     #endif
     #if HAS_TEMP_BOARD
       static celsius_float_t analog_to_celsius_board(const raw_adc_t raw);
     #endif
+    #if HAS_TEMP_SOC
+      static celsius_float_t analog_to_celsius_soc(const raw_adc_t raw);
+    #endif
     #if HAS_TEMP_REDUNDANT
       static celsius_float_t analog_to_celsius_redundant(const raw_adc_t raw);
     #endif
 
     #if HAS_FAN
 
       static uint8_t fan_speed[FAN_COUNT];
       #define FANS_LOOP(I) LOOP_L_N(I, FAN_COUNT)
 
       static void set_fan_speed(const uint8_t fan, const uint16_t speed);
@@ -1112,20 +1129,28 @@ class Temperature {
     #endif
 
     #if HAS_TEMP_BOARD
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         static raw_adc_t rawBoardTemp()  { return temp_board.getraw(); }
       #endif
       static celsius_float_t degBoard()  { return temp_board.celsius; }
       static celsius_t wholeDegBoard()   { return static_cast<celsius_t>(temp_board.celsius + 0.5f); }
     #endif
 
+    #if HAS_TEMP_SOC
+      #if ENABLED(SHOW_TEMP_ADC_VALUES)
+        static raw_adc_t rawSocTemp()    { return temp_soc.getraw(); }
+      #endif
+      static celsius_float_t degSoc()    { return temp_soc.celsius; }
+      static celsius_t wholeDegSoc()     { return static_cast<celsius_t>(temp_soc.celsius + 0.5f); }
+    #endif
+
     #if HAS_TEMP_REDUNDANT
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         static raw_adc_t rawRedundantTemp()       { return temp_redundant.getraw(); }
       #endif
       static celsius_float_t degRedundant()       { return temp_redundant.celsius; }
       static celsius_float_t degRedundantTarget() { return (*temp_redundant.target).celsius; }
       static celsius_t wholeDegRedundant()        { return static_cast<celsius_t>(temp_redundant.celsius + 0.5f); }
       static celsius_t wholeDegRedundantTarget()  { return static_cast<celsius_t>((*temp_redundant.target).celsius + 0.5f); }
     #endif
 

commit e6ac9ff204b09c0a852f71b77417f99ce4f5473a
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 18 17:13:06 2023 -0500

    ‚ö°Ô∏è Misc. optimizations

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 0ab00ef768..4bf76e5d48 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -42,21 +42,21 @@
 #endif
 
 #ifndef SOFT_PWM_SCALE
   #define SOFT_PWM_SCALE 0
 #endif
 
 #define HOTEND_INDEX TERN(HAS_MULTI_HOTEND, e, 0)
 #define E_NAME TERN_(HAS_MULTI_HOTEND, e)
 
 // Element identifiers. Positive values are hotends. Negative values are other heaters or coolers.
-typedef enum : int8_t {
+typedef enum : int_fast8_t {
   H_REDUNDANT = HID_REDUNDANT,
   H_COOLER = HID_COOLER,
   H_PROBE = HID_PROBE,
   H_BOARD = HID_BOARD,
   H_CHAMBER = HID_CHAMBER,
   H_BED = HID_BED,
   H_E0 = HID_E0, H_E1, H_E2, H_E3, H_E4, H_E5, H_E6, H_E7,
   H_NONE = -128
 } heater_id_t;
 
@@ -1312,24 +1312,24 @@ class Temperature {
         return (RunawayIndex)_MAX(heater_id, 0);
       }
 
       enum TRState : char { TRInactive, TRFirstHeating, TRStable, TRRunaway
         OPTARG(THERMAL_PROTECTION_VARIANCE_MONITOR, TRMalfunction)
       };
 
       typedef struct {
         millis_t timer = 0;
         TRState state = TRInactive;
-        float running_temp;
+        celsius_float_t running_temp;
         #if ENABLED(THERMAL_PROTECTION_VARIANCE_MONITOR)
           millis_t variance_timer = 0;
           celsius_float_t last_temp = 0.0, variance = 0.0;
         #endif
-        void run(const_celsius_float_t current, const_celsius_float_t target, const heater_id_t heater_id, const uint16_t period_seconds, const celsius_t hysteresis_degc);
+        void run(const_celsius_float_t current, const_celsius_float_t target, const heater_id_t heater_id, const uint16_t period_seconds, const celsius_float_t hysteresis_degc);
       } tr_state_machine_t;
 
       static tr_state_machine_t tr_state_machine[NR_HEATER_RUNAWAY];
 
     #endif // HAS_THERMAL_PROTECTION
 };
 
 extern Temperature thermalManager;

commit fbb1c82bc2acbbe3339e2283a797126b3c3ea515
Author: Piotr Paczy≈Ñski <ppaczyn@gmail.com>
Date:   Sat Mar 18 11:01:10 2023 +0100

    üêõ Prevent MPC E-permm overrun in Load Filament (#25531)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index b8bf03bf31..0ab00ef768 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -370,21 +370,23 @@ typedef struct { float p, i, d, c, f; } raw_pidcf_t;
   hotend_pid_t;
 
   #if ENABLED(PID_PARAMS_PER_HOTEND)
     #define SET_HOTEND_PID(F,H,V) thermalManager.temp_hotend[H].pid.set_##F(V)
   #else
     #define SET_HOTEND_PID(F,_,V) do{ HOTEND_LOOP() thermalManager.temp_hotend[e].pid.set_##F(V); }while(0)
   #endif
 
 #elif ENABLED(MPCTEMP)
 
-  typedef struct {
+  typedef struct MPC {
+    static bool e_paused;               // Pause E filament permm tracking
+    static int32_t e_position;          // For E tracking
     float heater_power;                 // M306 P
     float block_heat_capacity;          // M306 C
     float sensor_responsiveness;        // M306 R
     float ambient_xfer_coeff_fan0;      // M306 A
     float filament_heat_capacity_permm; // M306 H
     #if ENABLED(MPC_INCLUDE_FAN)
       float fan255_adjustment;          // M306 F
       void applyFanAdjustment(const_float_t cf) { fan255_adjustment = cf - ambient_xfer_coeff_fan0; }
     #else
       void applyFanAdjustment(const_float_t) {}
@@ -709,24 +711,20 @@ class Temperature {
     #if HAS_FAN_LOGIC
       static constexpr millis_t fan_update_interval_ms = TERN(HAS_PWMFANCHECK, 5000, TERN(HAS_FANCHECK, 1000, 2500));
     #endif
 
   private:
 
     #if ENABLED(WATCH_HOTENDS)
       static hotend_watch_t watch_hotend[HOTENDS];
     #endif
 
-    #if ENABLED(MPCTEMP)
-      static int32_t mpc_e_position;
-    #endif
-
     #if HAS_HOTEND
       static temp_range_t temp_range[HOTENDS];
     #endif
 
     #if HAS_HEATED_BED
       #if WATCH_BED
         static bed_watch_t watch_bed;
       #endif
       #if DISABLED(PIDTEMPBED)
         static millis_t next_bed_check_ms;

commit f50603ff1d380f759addffd2e54ac008ebec5985
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 18 01:22:50 2023 -0500

    üßë‚Äçüíª More IntelliSense-friendly declares

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 4178973a9d..b8bf03bf31 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -718,37 +718,41 @@ class Temperature {
 
     #if ENABLED(MPCTEMP)
       static int32_t mpc_e_position;
     #endif
 
     #if HAS_HOTEND
       static temp_range_t temp_range[HOTENDS];
     #endif
 
     #if HAS_HEATED_BED
-      #if ENABLED(WATCH_BED)
+      #if WATCH_BED
         static bed_watch_t watch_bed;
       #endif
-      IF_DISABLED(PIDTEMPBED, static millis_t next_bed_check_ms);
+      #if DISABLED(PIDTEMPBED)
+        static millis_t next_bed_check_ms;
+      #endif
       static raw_adc_t mintemp_raw_BED, maxtemp_raw_BED;
     #endif
 
     #if HAS_HEATED_CHAMBER
-      #if ENABLED(WATCH_CHAMBER)
+      #if WATCH_CHAMBER
         static chamber_watch_t watch_chamber;
       #endif
-      TERN(PIDTEMPCHAMBER,,static millis_t next_chamber_check_ms);
+      #if DISABLED(PIDTEMPCHAMBER)
+        static millis_t next_chamber_check_ms;
+      #endif
       static raw_adc_t mintemp_raw_CHAMBER, maxtemp_raw_CHAMBER;
     #endif
 
     #if HAS_COOLER
-      #if ENABLED(WATCH_COOLER)
+      #if WATCH_COOLER
         static cooler_watch_t watch_cooler;
       #endif
       static millis_t next_cooler_check_ms, cooler_fan_flush_ms;
       static raw_adc_t mintemp_raw_COOLER, maxtemp_raw_COOLER;
     #endif
 
     #if BOTH(HAS_TEMP_BOARD, THERMAL_PROTECTION_BOARD)
       static raw_adc_t mintemp_raw_BOARD, maxtemp_raw_BOARD;
     #endif
 

commit b5836b243ac9321841daa9380d55b298375aaa2e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 17 20:12:36 2023 -0500

    üîß Optional MPC_AUTOTUNE to save 5.5 - 5.8KB

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index b7f388cbb6..4178973a9d 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -1187,21 +1187,21 @@ class Temperature {
             temp_hotend[hotend].pid.set(p, i, d);
           #else
             HOTEND_LOOP() temp_hotend[e].pid.set(p, i, d);
           #endif
           updatePID();
         }
       #endif
 
     #endif
 
-    #if ENABLED(MPCTEMP)
+    #if ENABLED(MPC_AUTOTUNE)
       void MPC_autotune(const uint8_t e);
     #endif
 
     #if ENABLED(PROBING_HEATERS_OFF)
       static void pause_heaters(const bool p);
     #endif
 
     #if HEATER_IDLE_HANDLER
 
       static void reset_hotend_idle_timer(const uint8_t E_NAME) {

commit e977232735abd759678e8665759dbc214df88202
Author: EvilGremlin <22657714+EvilGremlin@users.noreply.github.com>
Date:   Sat Mar 4 05:43:20 2023 +0300

    ‚ú® Switching extruder/nozzle without servo (e.g., Dondolo) (#24553)
    
    Co-authored-by: Anson Liu <ansonl@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index f86ec90d19..b7f388cbb6 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -741,21 +741,21 @@ class Temperature {
     #endif
 
     #if HAS_COOLER
       #if ENABLED(WATCH_COOLER)
         static cooler_watch_t watch_cooler;
       #endif
       static millis_t next_cooler_check_ms, cooler_fan_flush_ms;
       static raw_adc_t mintemp_raw_COOLER, maxtemp_raw_COOLER;
     #endif
 
-    #if HAS_TEMP_BOARD && ENABLED(THERMAL_PROTECTION_BOARD)
+    #if BOTH(HAS_TEMP_BOARD, THERMAL_PROTECTION_BOARD)
       static raw_adc_t mintemp_raw_BOARD, maxtemp_raw_BOARD;
     #endif
 
     #if MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED > 1
       static uint8_t consecutive_low_temperature_error[HOTENDS];
     #endif
 
     #if HAS_FAN_LOGIC
       static millis_t fan_update_ms;
 

commit df44424388ee5b2105270ad7086c37f84263dc5a
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Feb 21 15:08:25 2023 -0600

    üßë‚Äçüíª Fix preheat tests (nested macro limit ~256)
    
    Followup to #25407

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 136ed982dd..f86ec90d19 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -579,21 +579,21 @@ typedef struct { raw_adc_t raw_min, raw_max; celsius_t mintemp, maxtemp; } temp_
 #if HAS_AUTO_FAN || HAS_FANCHECK
   #define HAS_FAN_LOGIC 1
 #endif
 
 class Temperature {
 
   public:
 
     #if HAS_HOTEND
       static hotend_info_t temp_hotend[HOTENDS];
-      static const celsius_t hotend_maxtemp[HOTENDS];
+      static constexpr celsius_t hotend_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP, HEATER_5_MAXTEMP, HEATER_6_MAXTEMP, HEATER_7_MAXTEMP);
       static celsius_t hotend_max_target(const uint8_t e) { return hotend_maxtemp[e] - (HOTEND_OVERSHOOT); }
     #endif
 
     #if HAS_HEATED_BED
       static bed_info_t temp_bed;
     #endif
     #if HAS_TEMP_PROBE
       static probe_info_t temp_probe;
     #endif
     #if HAS_TEMP_CHAMBER

commit c421a2f5dd8e32e48afadee304301befaf40fd49
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Sun Feb 12 07:35:19 2023 +0100

    ‚ú® M306 E for MPC extruder index (#25326)
    
    Co-Authored-By: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index afbf656a7a..136ed982dd 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -1188,21 +1188,21 @@ class Temperature {
           #else
             HOTEND_LOOP() temp_hotend[e].pid.set(p, i, d);
           #endif
           updatePID();
         }
       #endif
 
     #endif
 
     #if ENABLED(MPCTEMP)
-      void MPC_autotune();
+      void MPC_autotune(const uint8_t e);
     #endif
 
     #if ENABLED(PROBING_HEATERS_OFF)
       static void pause_heaters(const bool p);
     #endif
 
     #if HEATER_IDLE_HANDLER
 
       static void reset_hotend_idle_timer(const uint8_t E_NAME) {
         heater_idle[HOTEND_INDEX].reset();

commit 3be967bcb4f2e66500756163ebd036b7d235af1f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Feb 1 02:19:47 2023 -0600

    ü©π PID / MPC heating followup
    
    Followup to #25314

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index c947a6789a..afbf656a7a 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -1155,37 +1155,37 @@ class Temperature {
     }
 
     #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
       /**
        * Methods to check if heaters are enabled, indicating an active job
        */
       static bool auto_job_over_threshold();
       static void auto_job_check_timer(const bool can_start, const bool can_stop);
     #endif
 
+    #if ENABLED(TEMP_TUNING_MAINTAIN_FAN)
+      static bool adaptive_fan_slowing;
+    #elif ENABLED(ADAPTIVE_FAN_SLOWING)
+      static constexpr bool adaptive_fan_slowing = true;
+    #endif
+
     /**
      * Perform auto-tuning for hotend or bed in response to M303
      */
     #if HAS_PID_HEATING
 
       #if HAS_PID_DEBUG
         static bool pid_debug_flag;
       #endif
 
       static void PID_autotune(const celsius_t target, const heater_id_t heater_id, const int8_t ncycles, const bool set_result=false);
 
-      #if ENABLED(TEMP_TUNING_MAINTAIN_FAN)
-        static bool adaptive_fan_slowing;
-      #elif ENABLED(ADAPTIVE_FAN_SLOWING)
-        static constexpr bool adaptive_fan_slowing = true;
-      #endif
-
       // Update the temp manager when PID values change
       #if ENABLED(PIDTEMP)
         static void updatePID() { HOTEND_LOOP() temp_hotend[e].pid.reset(); }
         static void setPID(const uint8_t hotend, const_float_t p, const_float_t i, const_float_t d) {
           #if ENABLED(PID_PARAMS_PER_HOTEND)
             temp_hotend[hotend].pid.set(p, i, d);
           #else
             HOTEND_LOOP() temp_hotend[e].pid.set(p, i, d);
           #endif
           updatePID();

commit d6f4f24658cd6d307d395077020be85ecb0d2210
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Wed Feb 1 07:25:13 2023 +0000

    ü©π Fix PID / MPC heating flags (#25314)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 9ac5db44ed..c947a6789a 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -1166,21 +1166,21 @@ class Temperature {
      * Perform auto-tuning for hotend or bed in response to M303
      */
     #if HAS_PID_HEATING
 
       #if HAS_PID_DEBUG
         static bool pid_debug_flag;
       #endif
 
       static void PID_autotune(const celsius_t target, const heater_id_t heater_id, const int8_t ncycles, const bool set_result=false);
 
-      #if ENABLED(NO_FAN_SLOWING_IN_PID_TUNING)
+      #if ENABLED(TEMP_TUNING_MAINTAIN_FAN)
         static bool adaptive_fan_slowing;
       #elif ENABLED(ADAPTIVE_FAN_SLOWING)
         static constexpr bool adaptive_fan_slowing = true;
       #endif
 
       // Update the temp manager when PID values change
       #if ENABLED(PIDTEMP)
         static void updatePID() { HOTEND_LOOP() temp_hotend[e].pid.reset(); }
         static void setPID(const uint8_t hotend, const_float_t p, const_float_t i, const_float_t d) {
           #if ENABLED(PID_PARAMS_PER_HOTEND)

commit b7c23631c5840e2338cae531b171459e9e9c5301
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Sun Jan 22 15:08:37 2023 +1300

    üêõ Fix misc. UI issues (#25252)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 0b5f8caf3f..9ac5db44ed 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -636,20 +636,22 @@ class Temperature {
       static void set_menu_cold_override(const bool) {}
     #endif
 
     #if ENABLED(PREVENT_COLD_EXTRUSION)
       static bool allow_cold_extrude;
       static celsius_t extrude_min_temp;
       static bool tooCold(const celsius_t temp) { return !allow_cold_extrude && !allow_cold_extrude_override && temp < extrude_min_temp - (TEMP_WINDOW); }
       static bool tooColdToExtrude(const uint8_t E_NAME)       { return tooCold(wholeDegHotend(HOTEND_INDEX)); }
       static bool targetTooColdToExtrude(const uint8_t E_NAME) { return tooCold(degTargetHotend(HOTEND_INDEX)); }
     #else
+      static constexpr bool allow_cold_extrude = true;
+      static constexpr celsius_t extrude_min_temp = 0;
       static bool tooColdToExtrude(const uint8_t) { return false; }
       static bool targetTooColdToExtrude(const uint8_t) { return false; }
     #endif
 
     static bool hotEnoughToExtrude(const uint8_t e) { return !tooColdToExtrude(e); }
     static bool targetHotEnoughToExtrude(const uint8_t e) { return !targetTooColdToExtrude(e); }
 
     #if EITHER(SINGLENOZZLE_STANDBY_TEMP, SINGLENOZZLE_STANDBY_FAN)
       #if ENABLED(SINGLENOZZLE_STANDBY_TEMP)
         static celsius_t singlenozzle_temp[EXTRUDERS];

commit 6fe387b6f0722033e6cca96fd5e8215ea7b162eb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jan 15 06:48:17 2023 -0600

    üßë‚Äçüíª Adjust PID / MPC / ProUI
    
    Changes to simplify #25232 WIP

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index d099c3d73b..0b5f8caf3f 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -375,24 +375,28 @@ typedef struct { float p, i, d, c, f; } raw_pidcf_t;
     #define SET_HOTEND_PID(F,_,V) do{ HOTEND_LOOP() thermalManager.temp_hotend[e].pid.set_##F(V); }while(0)
   #endif
 
 #elif ENABLED(MPCTEMP)
 
   typedef struct {
     float heater_power;                 // M306 P
     float block_heat_capacity;          // M306 C
     float sensor_responsiveness;        // M306 R
     float ambient_xfer_coeff_fan0;      // M306 A
+    float filament_heat_capacity_permm; // M306 H
     #if ENABLED(MPC_INCLUDE_FAN)
       float fan255_adjustment;          // M306 F
+      void applyFanAdjustment(const_float_t cf) { fan255_adjustment = cf - ambient_xfer_coeff_fan0; }
+    #else
+      void applyFanAdjustment(const_float_t) {}
     #endif
-    float filament_heat_capacity_permm; // M306 H
+    float fanCoefficient() { return SUM_TERN(MPC_INCLUDE_FAN, ambient_xfer_coeff_fan0, fan255_adjustment); }
   } MPC_t;
 
   #define MPC_dT ((OVERSAMPLENR * float(ACTUAL_ADC_SAMPLES)) / (TEMP_TIMER_FREQUENCY))
 
 #endif
 
 #if ENABLED(G26_MESH_VALIDATION) && EITHER(HAS_MARLINUI_MENU, EXTENSIBLE_UI)
   #define G26_CLICK_CAN_CANCEL 1
 #endif
 
@@ -426,24 +430,26 @@ typedef struct HeaterInfo : public TempInfo {
 } heater_info_t;
 
 // A heater with PID stabilization
 template<typename T>
 struct PIDHeaterInfo : public HeaterInfo {
   T pid;  // Initialized by settings.load()
 };
 
 #if ENABLED(MPCTEMP)
   struct MPCHeaterInfo : public HeaterInfo {
-    MPC_t constants;
+    MPC_t mpc;
     float modeled_ambient_temp,
           modeled_block_temp,
           modeled_sensor_temp;
+    float fanCoefficient() { return mpc.fanCoefficient(); }
+    void applyFanAdjustment(const_float_t cf) { mpc.applyFanAdjustment(cf); }
   };
 #endif
 
 #if ENABLED(PIDTEMP)
   typedef struct PIDHeaterInfo<hotend_pid_t> hotend_info_t;
 #elif ENABLED(MPCTEMP)
   typedef struct MPCHeaterInfo hotend_info_t;
 #else
   typedef heater_info_t hotend_info_t;
 #endif

commit 64167dfe79df4ef5f69b2632e3c0cc162fb22914
Author: Powerlated <zjia08@gmail.com>
Date:   Wed Jan 11 00:40:15 2023 -0500

    ‚ú® PREHEAT_TIME_BED_MS (#25146)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 091f218eb8..d099c3d73b 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -741,24 +741,20 @@ class Temperature {
     #endif
 
     #if HAS_TEMP_BOARD && ENABLED(THERMAL_PROTECTION_BOARD)
       static raw_adc_t mintemp_raw_BOARD, maxtemp_raw_BOARD;
     #endif
 
     #if MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED > 1
       static uint8_t consecutive_low_temperature_error[HOTENDS];
     #endif
 
-    #if MILLISECONDS_PREHEAT_TIME > 0
-      static millis_t preheat_end_time[HOTENDS];
-    #endif
-
     #if HAS_FAN_LOGIC
       static millis_t fan_update_ms;
 
       static void manage_extruder_fans(millis_t ms) {
         if (ELAPSED(ms, fan_update_ms)) { // only need to check fan state very infrequently
           const millis_t next_ms = ms + fan_update_interval_ms;
           #if HAS_PWMFANCHECK
             #define FAN_CHECK_DURATION 100
             if (fan_check.is_measuring()) {
               fan_check.compute_speed(ms + FAN_CHECK_DURATION - fan_update_ms);
@@ -900,34 +896,52 @@ class Temperature {
      */
     static void isr();
     static void readings_ready();
 
     /**
      * Call periodically to manage heaters and keep the watchdog fed
      */
     static void task();
 
     /**
-     * Preheating hotends
+     * Preheating hotends & bed
      */
-    #if MILLISECONDS_PREHEAT_TIME > 0
-      static bool is_preheating(const uint8_t E_NAME) {
-        return preheat_end_time[HOTEND_INDEX] && PENDING(millis(), preheat_end_time[HOTEND_INDEX]);
+    #if PREHEAT_TIME_HOTEND_MS > 0
+      static millis_t preheat_end_ms_hotend[HOTENDS];
+      static bool is_hotend_preheating(const uint8_t E_NAME) {
+        return preheat_end_ms_hotend[HOTEND_INDEX] && PENDING(millis(), preheat_end_ms_hotend[HOTEND_INDEX]);
       }
-      static void start_preheat_time(const uint8_t E_NAME) {
-        preheat_end_time[HOTEND_INDEX] = millis() + MILLISECONDS_PREHEAT_TIME;
+      static void start_hotend_preheat_time(const uint8_t E_NAME) {
+        preheat_end_ms_hotend[HOTEND_INDEX] = millis() + PREHEAT_TIME_HOTEND_MS;
       }
-      static void reset_preheat_time(const uint8_t E_NAME) {
-        preheat_end_time[HOTEND_INDEX] = 0;
+      static void reset_hotend_preheat_time(const uint8_t E_NAME) {
+        preheat_end_ms_hotend[HOTEND_INDEX] = 0;
       }
     #else
-      #define is_preheating(n) (false)
+      static bool is_hotend_preheating(const uint8_t) { return false; }
+    #endif
+
+    #if HAS_HEATED_BED
+      #if PREHEAT_TIME_BED_MS > 0
+        static millis_t preheat_end_ms_bed;
+        static bool is_bed_preheating() {
+          return preheat_end_ms_bed && PENDING(millis(), preheat_end_ms_bed);
+        }
+        static void start_bed_preheat_time() {
+          preheat_end_ms_bed = millis() + PREHEAT_TIME_BED_MS;
+        }
+        static void reset_bed_preheat_time() {
+          preheat_end_ms_bed = 0;
+        }
+      #else
+        static bool is_bed_preheating() { return false; }
+      #endif
     #endif
 
     //high level conversion routines, for use outside of temperature.cpp
     //inline so that there is no performance decrease.
     //deg=degreeCelsius
 
     static celsius_float_t degHotend(const uint8_t E_NAME) {
       return TERN0(HAS_HOTEND, temp_hotend[HOTEND_INDEX].celsius);
     }
 
@@ -942,25 +956,25 @@ class Temperature {
     #endif
 
     static celsius_t degTargetHotend(const uint8_t E_NAME) {
       return TERN0(HAS_HOTEND, temp_hotend[HOTEND_INDEX].target);
     }
 
     #if HAS_HOTEND
 
       static void setTargetHotend(const celsius_t celsius, const uint8_t E_NAME) {
         const uint8_t ee = HOTEND_INDEX;
-        #if MILLISECONDS_PREHEAT_TIME > 0
+        #if PREHEAT_TIME_HOTEND_MS > 0
           if (celsius == 0)
-            reset_preheat_time(ee);
+            reset_hotend_preheat_time(ee);
           else if (temp_hotend[ee].target == 0)
-            start_preheat_time(ee);
+            start_hotend_preheat_time(ee);
         #endif
         TERN_(AUTO_POWER_CONTROL, if (celsius) powerManager.power_on());
         temp_hotend[ee].target = _MIN(celsius, hotend_max_target(ee));
         start_watching_hotend(ee);
       }
 
       static bool isHeatingHotend(const uint8_t E_NAME) {
         return temp_hotend[HOTEND_INDEX].target > temp_hotend[HOTEND_INDEX].celsius;
       }
 
@@ -1009,20 +1023,26 @@ class Temperature {
       static bool isHeatingBed()       { return temp_bed.target > temp_bed.celsius; }
       static bool isCoolingBed()       { return temp_bed.target < temp_bed.celsius; }
       static bool degBedNear(const celsius_t temp) {
         return ABS(wholeDegBed() - temp) < (TEMP_BED_HYSTERESIS);
       }
 
       // Start watching the Bed to make sure it's really heating up
       static void start_watching_bed() { TERN_(WATCH_BED, watch_bed.restart(degBed(), degTargetBed())); }
 
       static void setTargetBed(const celsius_t celsius) {
+        #if PREHEAT_TIME_BED_MS > 0
+          if (celsius == 0)
+            reset_bed_preheat_time();
+          else if (temp_bed.target == 0)
+            start_bed_preheat_time();
+        #endif
         TERN_(AUTO_POWER_CONTROL, if (celsius) powerManager.power_on());
         temp_bed.target = _MIN(celsius, BED_MAX_TARGET);
         start_watching_bed();
       }
 
       static bool wait_for_bed(const bool no_wait_for_cooling=true
         OPTARG(G26_CLICK_CAN_CANCEL, const bool click_to_cancel=false)
       );
 
       static void wait_for_bed_heating();

commit 0e72c90f49c8262fac0e6eafa9dde7d20acfe5fc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jan 3 19:40:23 2023 -0600

    üßë‚Äçüíª Add Temperature::is_above_target

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 11b2530d38..091f218eb8 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -414,21 +414,22 @@ public:
   // A redundant temperature sensor
   typedef struct RedundantTempInfo : public TempInfo {
     temp_info_t* target;
   } redundant_info_t;
 #endif
 
 // A PWM heater with temperature sensor
 typedef struct HeaterInfo : public TempInfo {
   celsius_t target;
   uint8_t soft_pwm_amount;
-  bool is_below_target(const celsius_t offs=0) const { return (celsius < (target + offs)); }
+  bool is_below_target(const celsius_t offs=0) const { return (target - celsius > offs); } // celsius < target - offs
+  bool is_above_target(const celsius_t offs=0) const { return (celsius - target > offs); } // celsius > target + offs
 } heater_info_t;
 
 // A heater with PID stabilization
 template<typename T>
 struct PIDHeaterInfo : public HeaterInfo {
   T pid;  // Initialized by settings.load()
 };
 
 #if ENABLED(MPCTEMP)
   struct MPCHeaterInfo : public HeaterInfo {

commit 2dcf3b8550a7aae34923ad95ace3ee59de47bccd
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jan 3 18:57:33 2023 -0600

    üé® Rename *_temp_error to *temp_error

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index c40a418428..11b2530d38 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -1245,22 +1245,22 @@ class Temperature {
       static float get_pid_output_hotend(const uint8_t e);
     #endif
     #if ENABLED(PIDTEMPBED)
       static float get_pid_output_bed();
     #endif
     #if ENABLED(PIDTEMPCHAMBER)
       static float get_pid_output_chamber();
     #endif
 
     static void _temp_error(const heater_id_t e, FSTR_P const serial_msg, FSTR_P const lcd_msg);
-    static void min_temp_error(const heater_id_t e);
-    static void max_temp_error(const heater_id_t e);
+    static void mintemp_error(const heater_id_t e);
+    static void maxtemp_error(const heater_id_t e);
 
     #define HAS_THERMAL_PROTECTION ANY(THERMAL_PROTECTION_HOTENDS, THERMAL_PROTECTION_CHAMBER, THERMAL_PROTECTION_BED, THERMAL_PROTECTION_COOLER)
 
     #if HAS_THERMAL_PROTECTION
 
       // Indices and size for the tr_state_machine array. One for each protected heater.
       enum RunawayIndex : int8_t {
         _RI = -1
         #if ENABLED(THERMAL_PROTECTION_HOTENDS)
           #define _RUNAWAY_IND_E(N) ,RUNAWAY_IND_E##N

commit 5200b36ae44a814963bba0d68c4b76364dc98847
Author: MarkMan0 <38912829+MarkMan0@users.noreply.github.com>
Date:   Sun Dec 18 06:48:33 2022 +0100

    üêõ Fix, Refactor PID scaling (#25096)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index d0f7d2dda7..c40a418428 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -152,108 +152,230 @@ typedef struct { float p, i, d, c, f; } raw_pidcf_t;
 
   #define PID_K2 (1-float(PID_K1))
   #define PID_dT ((OVERSAMPLENR * float(ACTUAL_ADC_SAMPLES)) / (TEMP_TIMER_FREQUENCY))
 
   // Apply the scale factors to the PID values
   #define scalePID_i(i)   ( float(i) * PID_dT )
   #define unscalePID_i(i) ( float(i) / PID_dT )
   #define scalePID_d(d)   ( float(d) / PID_dT )
   #define unscalePID_d(d) ( float(d) * PID_dT )
 
-  typedef struct {
-    float Kp, Ki, Kd;
+  /// @brief The default PID class, only has Kp, Ki, Kd, other classes extend this one
+  /// @tparam MIN_POW output when current is above target by functional_range
+  /// @tparam MAX_POW output when current is below target by functional_range
+  /// @details This class has methods for Kc and Kf terms, but returns constant default values
+  /// PID classes that implement these features are expected to override these methods
+  /// Since the finally used PID class is typedef-d, there is no need to use virtual functions
+  template<int MIN_POW, int MAX_POW>
+  struct PID_t{
+  protected:
+    bool pid_reset = true;
+    float temp_iState = 0.0f, temp_dState = 0.0f;
+    float work_p = 0, work_i = 0, work_d = 0;
+
+  public:
+    float Kp = 0, Ki = 0, Kd = 0;
     float p() const { return Kp; }
     float i() const { return unscalePID_i(Ki); }
     float d() const { return unscalePID_d(Kd); }
     float c() const { return 1; }
     float f() const { return 0; }
+    float pTerm() const { return work_p; }
+    float iTerm() const { return work_i; }
+    float dTerm() const { return work_d; }
+    float cTerm() const { return 0; }
+    float fTerm() const { return 0; }
     void set_Kp(float p) { Kp = p; }
     void set_Ki(float i) { Ki = scalePID_i(i); }
     void set_Kd(float d) { Kd = scalePID_d(d); }
     void set_Kc(float) {}
     void set_Kf(float) {}
-    void set(float p, float i, float d, float c=1, float f=0) { set_Kp(p); set_Ki(i); set_Kd(d); UNUSED(c); UNUSED(f); }
+    int low() const { return MIN_POW; }
+    int high() const { return MAX_POW; }
+    void reset() { pid_reset = true; }
+    void set(float p, float i, float d, float c=1, float f=0) { set_Kp(p); set_Ki(i); set_Kd(d); set_Kc(c); set_Kf(f); }
     void set(const raw_pid_t &raw) { set(raw.p, raw.i, raw.d); }
-    void set(const raw_pidcf_t &raw) { set(raw.p, raw.i, raw.d); }
-  } PID_t;
+    void set(const raw_pidcf_t &raw) { set(raw.p, raw.i, raw.d, raw.c, raw.f); }
+
+    float get_fan_scale_output(const uint8_t) { return 0; }
+
+    float get_extrusion_scale_output(const bool, const int32_t, const float, const int16_t) { return 0; }
+
+    float get_pid_output(const float target, const float current) {
+      const float pid_error = target - current;
+      if (!target || pid_error < -(PID_FUNCTIONAL_RANGE)) {
+        pid_reset = true;
+        return 0;
+      }
+      else if (pid_error > PID_FUNCTIONAL_RANGE) {
+        pid_reset = true;
+        return MAX_POW;
+      }
+
+      if (pid_reset) {
+        pid_reset = false;
+        temp_iState = 0.0;
+        work_d = 0.0;
+      }
+
+      const float max_power_over_i_gain = float(MAX_POW) / Ki - float(MIN_POW);
+      temp_iState = constrain(temp_iState + pid_error, 0, max_power_over_i_gain);
+
+      work_p = Kp * pid_error;
+      work_i = Ki * temp_iState;
+      work_d = work_d + PID_K2 * (Kd * (temp_dState - current) - work_d);
+
+      temp_dState = current;
+
+      return constrain(work_p + work_i + work_d + float(MIN_POW), 0, MAX_POW);
+    }
+
+  };
 
 #endif
 
 #if ENABLED(PIDTEMP)
 
-  typedef struct {
-    float Kp, Ki, Kd, Kc;
-    float p() const { return Kp; }
-    float i() const { return unscalePID_i(Ki); }
-    float d() const { return unscalePID_d(Kd); }
+  /// @brief Extrusion scaled PID class
+  template<int MIN_POW, int MAX_POW, int LPQ_ARR_SZ>
+  struct PIDC_t : public PID_t<MIN_POW, MAX_POW> {
+  private:
+    using base = PID_t<MIN_POW, MAX_POW>;
+    float work_c = 0;
+    float prev_e_pos = 0;
+    int32_t lpq[LPQ_ARR_SZ] = {};
+    int16_t lpq_ptr = 0;
+  public:
+    float Kc = 0;
     float c() const { return Kc; }
-    float f() const { return 0; }
-    void set_Kp(float p) { Kp = p; }
-    void set_Ki(float i) { Ki = scalePID_i(i); }
-    void set_Kd(float d) { Kd = scalePID_d(d); }
     void set_Kc(float c) { Kc = c; }
-    void set_Kf(float) {}
-    void set(float p, float i, float d, float c=1, float f=0) { set_Kp(p); set_Ki(i); set_Kd(d); set_Kc(c); set_Kf(f); }
+    float cTerm() const { return work_c; }
+    void set(float p, float i, float d, float c=1, float f=0) {
+      base::set_Kp(p);
+      base::set_Ki(i);
+      base::set_Kd(d);
+      set_Kc(c);
+      base::set_Kf(f);
+    }
     void set(const raw_pid_t &raw) { set(raw.p, raw.i, raw.d); }
-    void set(const raw_pidcf_t &raw) { set(raw.p, raw.i, raw.d, raw.c); }
-  } PIDC_t;
+    void set(const raw_pidcf_t &raw) { set(raw.p, raw.i, raw.d, raw.c, raw.f); }
+    void reset() {
+      base::reset();
+      prev_e_pos = 0;
+      lpq_ptr = 0;
+      LOOP_L_N(i, LPQ_ARR_SZ) lpq[i] = 0;
+    }
 
-  typedef struct {
-    float Kp, Ki, Kd, Kf;
-    float p() const { return Kp; }
-    float i() const { return unscalePID_i(Ki); }
-    float d() const { return unscalePID_d(Kd); }
-    float c() const { return 1; }
+    float get_extrusion_scale_output(const bool is_active, const int32_t e_position, const float e_mm_per_step, const int16_t lpq_len) {
+      work_c = 0;
+      if (!is_active) return work_c;
+
+      if (e_position > prev_e_pos) {
+        lpq[lpq_ptr] = e_position - prev_e_pos;
+        prev_e_pos = e_position;
+      }
+      else
+        lpq[lpq_ptr] = 0;
+
+      ++lpq_ptr;
+
+      if (lpq_ptr >= LPQ_ARR_SZ || lpq_ptr >= lpq_len)
+        lpq_ptr = 0;
+
+      work_c = (lpq[lpq_ptr] * e_mm_per_step) * Kc;
+
+      return work_c;
+    }
+  };
+
+  /// @brief Fan scaled PID, this class implements the get_fan_scale_output() method
+  /// @tparam MIN_POW @see PID_t
+  /// @tparam MAX_POW @see PID_t
+  /// @tparam SCALE_MIN_SPEED parameter from Configuration_adv.h
+  /// @tparam SCALE_LIN_FACTOR parameter from Configuration_adv.h
+  template<int MIN_POW, int MAX_POW, int SCALE_MIN_SPEED, int SCALE_LIN_FACTOR>
+  struct PIDF_t : public PID_t<MIN_POW, MAX_POW> {
+  private:
+    using base = PID_t<MIN_POW, MAX_POW>;
+    float work_f = 0;
+  public:
+    float Kf = 0;
     float f() const { return Kf; }
-    void set_Kp(float p) { Kp = p; }
-    void set_Ki(float i) { Ki = scalePID_i(i); }
-    void set_Kd(float d) { Kd = scalePID_d(d); }
-    void set_Kc(float) {}
     void set_Kf(float f) { Kf = f; }
-    void set(float p, float i, float d, float c=1, float f=0) { set_Kp(p); set_Ki(i); set_Kd(d); set_Kf(f); }
+    float fTerm() const { return work_f; }
+    void set(float p, float i, float d, float c=1, float f=0) {
+      base::set_Kp(p);
+      base::set_Ki(i);
+      base::set_Kd(d);
+      base::set_Kc(c);
+      set_Kf(f);
+    }
     void set(const raw_pid_t &raw) { set(raw.p, raw.i, raw.d); }
-    void set(const raw_pidcf_t &raw) { set(raw.p, raw.i, raw.d, raw.f); }
-  } PIDF_t;
+    void set(const raw_pidcf_t &raw) { set(raw.p, raw.i, raw.d, raw.c, raw.f); }
 
-  typedef struct {
-    float Kp, Ki, Kd, Kc, Kf;
-    float p() const { return Kp; }
-    float i() const { return unscalePID_i(Ki); }
-    float d() const { return unscalePID_d(Kd); }
-    float c() const { return Kc; }
+    float get_fan_scale_output(const uint8_t fan_speed) {
+      work_f = 0;
+      if (fan_speed > SCALE_MIN_SPEED)
+        work_f = Kf + (SCALE_LIN_FACTOR) * fan_speed;
+
+      return work_f;
+    }
+  };
+
+  /// @brief Inherits PID and PIDC - can't use proper diamond inheritance w/o virtual
+  template<int MIN_POW, int MAX_POW, int LPQ_ARR_SZ, int SCALE_MIN_SPEED, int SCALE_LIN_FACTOR>
+  struct PIDCF_t : public PIDC_t<MIN_POW, MAX_POW, LPQ_ARR_SZ> {
+  private:
+    using base = PID_t<MIN_POW, MAX_POW>;
+    using cPID = PIDC_t<MIN_POW, MAX_POW, LPQ_ARR_SZ>;
+    float work_f = 0;
+  public:
+    float Kf = 0;
+    float c() const { return cPID::c(); }
     float f() const { return Kf; }
-    void set_Kp(float p) { Kp = p; }
-    void set_Ki(float i) { Ki = scalePID_i(i); }
-    void set_Kd(float d) { Kd = scalePID_d(d); }
-    void set_Kc(float c) { Kc = c; }
+    void set_Kc(float c) { cPID::set_Kc(c); }
     void set_Kf(float f) { Kf = f; }
-    void set(float p, float i, float d, float c=1, float f=0) { set_Kp(p); set_Ki(i); set_Kd(d); set_Kc(c); set_Kf(f); }
+    float cTerm() const { return cPID::cTerm(); }
+    float fTerm() const { return work_f; }
+    void set(float p, float i, float d, float c=1, float f=0) {
+      base::set_Kp(p);
+      base::set_Ki(i);
+      base::set_Kd(d);
+      cPID::set_Kc(c);
+      set_Kf(f);
+    }
     void set(const raw_pid_t &raw) { set(raw.p, raw.i, raw.d); }
     void set(const raw_pidcf_t &raw) { set(raw.p, raw.i, raw.d, raw.c, raw.f); }
-  } PIDCF_t;
+
+    void reset() { cPID::reset(); }
+
+    float get_fan_scale_output(const uint8_t fan_speed) {
+      work_f = fan_speed > (SCALE_MIN_SPEED) ? Kf + (SCALE_LIN_FACTOR) * fan_speed : 0;
+      return work_f;
+    }
+    float get_extrusion_scale_output(const bool is_active, const int32_t e_position, const float e_mm_per_step, const int16_t lpq_len) {
+      return cPID::get_extrusion_scale_output(is_active, e_position, e_mm_per_step, lpq_len);
+    }
+  };
 
   typedef
     #if BOTH(PID_EXTRUSION_SCALING, PID_FAN_SCALING)
-      PIDCF_t
+      PIDCF_t<0, PID_MAX, LPQ_MAX_LEN, PID_FAN_SCALING_MIN_SPEED, PID_FAN_SCALING_LIN_FACTOR>
     #elif ENABLED(PID_EXTRUSION_SCALING)
-      PIDC_t
+      PIDC_t<0, PID_MAX, LPQ_MAX_LEN>
     #elif ENABLED(PID_FAN_SCALING)
-      PIDF_t
+      PIDF_t<0, PID_MAX, PID_FAN_SCALING_MIN_SPEED, PID_FAN_SCALING_LIN_FACTOR>
     #else
-      PID_t
+      PID_t<0, PID_MAX>
     #endif
   hotend_pid_t;
 
-  #if ENABLED(PID_EXTRUSION_SCALING)
-    typedef IF<(LPQ_MAX_LEN > 255), uint16_t, uint8_t>::type lpq_ptr_t;
-  #endif
-
   #if ENABLED(PID_PARAMS_PER_HOTEND)
     #define SET_HOTEND_PID(F,H,V) thermalManager.temp_hotend[H].pid.set_##F(V)
   #else
     #define SET_HOTEND_PID(F,_,V) do{ HOTEND_LOOP() thermalManager.temp_hotend[e].pid.set_##F(V); }while(0)
   #endif
 
 #elif ENABLED(MPCTEMP)
 
   typedef struct {
     float heater_power;                 // M306 P
@@ -319,28 +441,28 @@ struct PIDHeaterInfo : public HeaterInfo {
 
 #if ENABLED(PIDTEMP)
   typedef struct PIDHeaterInfo<hotend_pid_t> hotend_info_t;
 #elif ENABLED(MPCTEMP)
   typedef struct MPCHeaterInfo hotend_info_t;
 #else
   typedef heater_info_t hotend_info_t;
 #endif
 #if HAS_HEATED_BED
   #if ENABLED(PIDTEMPBED)
-    typedef struct PIDHeaterInfo<PID_t> bed_info_t;
+    typedef struct PIDHeaterInfo<PID_t<MIN_BED_POWER, MAX_BED_POWER>> bed_info_t;
   #else
     typedef heater_info_t bed_info_t;
   #endif
 #endif
 #if HAS_HEATED_CHAMBER
   #if ENABLED(PIDTEMPCHAMBER)
-    typedef struct PIDHeaterInfo<PID_t> chamber_info_t;
+    typedef struct PIDHeaterInfo<PID_t<MIN_CHAMBER_POWER, MAX_CHAMBER_POWER>> chamber_info_t;
   #else
     typedef heater_info_t chamber_info_t;
   #endif
 #elif HAS_TEMP_CHAMBER
   typedef temp_info_t chamber_info_t;
 #endif
 #if HAS_TEMP_PROBE
   typedef temp_info_t probe_info_t;
 #endif
 #if EITHER(HAS_COOLER, HAS_TEMP_COOLER)
@@ -578,25 +700,20 @@ class Temperature {
     #if HAS_FAN_LOGIC
       static constexpr millis_t fan_update_interval_ms = TERN(HAS_PWMFANCHECK, 5000, TERN(HAS_FANCHECK, 1000, 2500));
     #endif
 
   private:
 
     #if ENABLED(WATCH_HOTENDS)
       static hotend_watch_t watch_hotend[HOTENDS];
     #endif
 
-    #if ENABLED(PID_EXTRUSION_SCALING)
-      static int32_t pes_e_position, lpq[LPQ_MAX_LEN];
-      static lpq_ptr_t lpq_ptr;
-    #endif
-
     #if ENABLED(MPCTEMP)
       static int32_t mpc_e_position;
     #endif
 
     #if HAS_HOTEND
       static temp_range_t temp_range[HOTENDS];
     #endif
 
     #if HAS_HEATED_BED
       #if ENABLED(WATCH_BED)
@@ -1028,21 +1145,21 @@ class Temperature {
       static void PID_autotune(const celsius_t target, const heater_id_t heater_id, const int8_t ncycles, const bool set_result=false);
 
       #if ENABLED(NO_FAN_SLOWING_IN_PID_TUNING)
         static bool adaptive_fan_slowing;
       #elif ENABLED(ADAPTIVE_FAN_SLOWING)
         static constexpr bool adaptive_fan_slowing = true;
       #endif
 
       // Update the temp manager when PID values change
       #if ENABLED(PIDTEMP)
-        static void updatePID() { TERN_(PID_EXTRUSION_SCALING, pes_e_position = 0); }
+        static void updatePID() { HOTEND_LOOP() temp_hotend[e].pid.reset(); }
         static void setPID(const uint8_t hotend, const_float_t p, const_float_t i, const_float_t d) {
           #if ENABLED(PID_PARAMS_PER_HOTEND)
             temp_hotend[hotend].pid.set(p, i, d);
           #else
             HOTEND_LOOP() temp_hotend[e].pid.set(p, i, d);
           #endif
           updatePID();
         }
       #endif
 

commit 094701cc71ccf1c6fcf3d768b9fcb227d0abf3b0
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Sun Sep 4 02:51:53 2022 +0200

    üêõ Fix / refactor shared PID (#24673)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index f6cf81b8a9..d0f7d2dda7 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -53,67 +53,20 @@ typedef enum : int8_t {
   H_REDUNDANT = HID_REDUNDANT,
   H_COOLER = HID_COOLER,
   H_PROBE = HID_PROBE,
   H_BOARD = HID_BOARD,
   H_CHAMBER = HID_CHAMBER,
   H_BED = HID_BED,
   H_E0 = HID_E0, H_E1, H_E2, H_E3, H_E4, H_E5, H_E6, H_E7,
   H_NONE = -128
 } heater_id_t;
 
-// PID storage
-typedef struct { float Kp, Ki, Kd;     } PID_t;
-typedef struct { float Kp, Ki, Kd, Kc; } PIDC_t;
-typedef struct { float Kp, Ki, Kd, Kf; } PIDF_t;
-typedef struct { float Kp, Ki, Kd, Kc, Kf; } PIDCF_t;
-
-typedef
-  #if BOTH(PID_EXTRUSION_SCALING, PID_FAN_SCALING)
-    PIDCF_t
-  #elif ENABLED(PID_EXTRUSION_SCALING)
-    PIDC_t
-  #elif ENABLED(PID_FAN_SCALING)
-    PIDF_t
-  #else
-    PID_t
-  #endif
-hotend_pid_t;
-
-#if ENABLED(PID_EXTRUSION_SCALING)
-  typedef IF<(LPQ_MAX_LEN > 255), uint16_t, uint8_t>::type lpq_ptr_t;
-#endif
-
-#define PID_PARAM(F,H) _PID_##F(TERN(PID_PARAMS_PER_HOTEND, H, 0 & H)) // Always use 'H' to suppress warning
-#define _PID_Kp(H) TERN(PIDTEMP, Temperature::temp_hotend[H].pid.Kp, NAN)
-#define _PID_Ki(H) TERN(PIDTEMP, Temperature::temp_hotend[H].pid.Ki, NAN)
-#define _PID_Kd(H) TERN(PIDTEMP, Temperature::temp_hotend[H].pid.Kd, NAN)
-#if ENABLED(PIDTEMP)
-  #define _PID_Kc(H) TERN(PID_EXTRUSION_SCALING, Temperature::temp_hotend[H].pid.Kc, 1)
-  #define _PID_Kf(H) TERN(PID_FAN_SCALING,       Temperature::temp_hotend[H].pid.Kf, 0)
-#else
-  #define _PID_Kc(H) 1
-  #define _PID_Kf(H) 0
-#endif
-
-#if ENABLED(MPCTEMP)
-  typedef struct {
-    float heater_power;                 // M306 P
-    float block_heat_capacity;          // M306 C
-    float sensor_responsiveness;        // M306 R
-    float ambient_xfer_coeff_fan0;      // M306 A
-    #if ENABLED(MPC_INCLUDE_FAN)
-      float fan255_adjustment;          // M306 F
-    #endif
-    float filament_heat_capacity_permm; // M306 H
-  } MPC_t;
-#endif
-
 /**
  * States for ADC reading in the ISR
  */
 enum ADCSensorState : char {
   StartSampling,
   #if HAS_TEMP_ADC_0
     PrepareTemp_0, MeasureTemp_0,
   #endif
   #if HAS_TEMP_ADC_BED
     PrepareTemp_BED, MeasureTemp_BED,
@@ -181,51 +134,165 @@ enum ADCSensorState : char {
   StartupDelay  // Startup, delay initial temp reading a tiny bit so the hardware can settle
 };
 
 // Minimum number of Temperature::ISR loops between sensor readings.
 // Multiplied by 16 (OVERSAMPLENR) to obtain the total time to
 // get all oversampled sensor readings
 #define MIN_ADC_ISR_LOOPS 10
 
 #define ACTUAL_ADC_SAMPLES _MAX(int(MIN_ADC_ISR_LOOPS), int(SensorsReady))
 
+//
+// PID
+//
+
+typedef struct { float p, i, d; } raw_pid_t;
+typedef struct { float p, i, d, c, f; } raw_pidcf_t;
+
 #if HAS_PID_HEATING
+
   #define PID_K2 (1-float(PID_K1))
   #define PID_dT ((OVERSAMPLENR * float(ACTUAL_ADC_SAMPLES)) / (TEMP_TIMER_FREQUENCY))
 
   // Apply the scale factors to the PID values
   #define scalePID_i(i)   ( float(i) * PID_dT )
   #define unscalePID_i(i) ( float(i) / PID_dT )
   #define scalePID_d(d)   ( float(d) / PID_dT )
   #define unscalePID_d(d) ( float(d) * PID_dT )
+
+  typedef struct {
+    float Kp, Ki, Kd;
+    float p() const { return Kp; }
+    float i() const { return unscalePID_i(Ki); }
+    float d() const { return unscalePID_d(Kd); }
+    float c() const { return 1; }
+    float f() const { return 0; }
+    void set_Kp(float p) { Kp = p; }
+    void set_Ki(float i) { Ki = scalePID_i(i); }
+    void set_Kd(float d) { Kd = scalePID_d(d); }
+    void set_Kc(float) {}
+    void set_Kf(float) {}
+    void set(float p, float i, float d, float c=1, float f=0) { set_Kp(p); set_Ki(i); set_Kd(d); UNUSED(c); UNUSED(f); }
+    void set(const raw_pid_t &raw) { set(raw.p, raw.i, raw.d); }
+    void set(const raw_pidcf_t &raw) { set(raw.p, raw.i, raw.d); }
+  } PID_t;
+
 #endif
 
-#if ENABLED(MPCTEMP)
+#if ENABLED(PIDTEMP)
+
+  typedef struct {
+    float Kp, Ki, Kd, Kc;
+    float p() const { return Kp; }
+    float i() const { return unscalePID_i(Ki); }
+    float d() const { return unscalePID_d(Kd); }
+    float c() const { return Kc; }
+    float f() const { return 0; }
+    void set_Kp(float p) { Kp = p; }
+    void set_Ki(float i) { Ki = scalePID_i(i); }
+    void set_Kd(float d) { Kd = scalePID_d(d); }
+    void set_Kc(float c) { Kc = c; }
+    void set_Kf(float) {}
+    void set(float p, float i, float d, float c=1, float f=0) { set_Kp(p); set_Ki(i); set_Kd(d); set_Kc(c); set_Kf(f); }
+    void set(const raw_pid_t &raw) { set(raw.p, raw.i, raw.d); }
+    void set(const raw_pidcf_t &raw) { set(raw.p, raw.i, raw.d, raw.c); }
+  } PIDC_t;
+
+  typedef struct {
+    float Kp, Ki, Kd, Kf;
+    float p() const { return Kp; }
+    float i() const { return unscalePID_i(Ki); }
+    float d() const { return unscalePID_d(Kd); }
+    float c() const { return 1; }
+    float f() const { return Kf; }
+    void set_Kp(float p) { Kp = p; }
+    void set_Ki(float i) { Ki = scalePID_i(i); }
+    void set_Kd(float d) { Kd = scalePID_d(d); }
+    void set_Kc(float) {}
+    void set_Kf(float f) { Kf = f; }
+    void set(float p, float i, float d, float c=1, float f=0) { set_Kp(p); set_Ki(i); set_Kd(d); set_Kf(f); }
+    void set(const raw_pid_t &raw) { set(raw.p, raw.i, raw.d); }
+    void set(const raw_pidcf_t &raw) { set(raw.p, raw.i, raw.d, raw.f); }
+  } PIDF_t;
+
+  typedef struct {
+    float Kp, Ki, Kd, Kc, Kf;
+    float p() const { return Kp; }
+    float i() const { return unscalePID_i(Ki); }
+    float d() const { return unscalePID_d(Kd); }
+    float c() const { return Kc; }
+    float f() const { return Kf; }
+    void set_Kp(float p) { Kp = p; }
+    void set_Ki(float i) { Ki = scalePID_i(i); }
+    void set_Kd(float d) { Kd = scalePID_d(d); }
+    void set_Kc(float c) { Kc = c; }
+    void set_Kf(float f) { Kf = f; }
+    void set(float p, float i, float d, float c=1, float f=0) { set_Kp(p); set_Ki(i); set_Kd(d); set_Kc(c); set_Kf(f); }
+    void set(const raw_pid_t &raw) { set(raw.p, raw.i, raw.d); }
+    void set(const raw_pidcf_t &raw) { set(raw.p, raw.i, raw.d, raw.c, raw.f); }
+  } PIDCF_t;
+
+  typedef
+    #if BOTH(PID_EXTRUSION_SCALING, PID_FAN_SCALING)
+      PIDCF_t
+    #elif ENABLED(PID_EXTRUSION_SCALING)
+      PIDC_t
+    #elif ENABLED(PID_FAN_SCALING)
+      PIDF_t
+    #else
+      PID_t
+    #endif
+  hotend_pid_t;
+
+  #if ENABLED(PID_EXTRUSION_SCALING)
+    typedef IF<(LPQ_MAX_LEN > 255), uint16_t, uint8_t>::type lpq_ptr_t;
+  #endif
+
+  #if ENABLED(PID_PARAMS_PER_HOTEND)
+    #define SET_HOTEND_PID(F,H,V) thermalManager.temp_hotend[H].pid.set_##F(V)
+  #else
+    #define SET_HOTEND_PID(F,_,V) do{ HOTEND_LOOP() thermalManager.temp_hotend[e].pid.set_##F(V); }while(0)
+  #endif
+
+#elif ENABLED(MPCTEMP)
+
+  typedef struct {
+    float heater_power;                 // M306 P
+    float block_heat_capacity;          // M306 C
+    float sensor_responsiveness;        // M306 R
+    float ambient_xfer_coeff_fan0;      // M306 A
+    #if ENABLED(MPC_INCLUDE_FAN)
+      float fan255_adjustment;          // M306 F
+    #endif
+    float filament_heat_capacity_permm; // M306 H
+  } MPC_t;
+
   #define MPC_dT ((OVERSAMPLENR * float(ACTUAL_ADC_SAMPLES)) / (TEMP_TIMER_FREQUENCY))
+
 #endif
 
 #if ENABLED(G26_MESH_VALIDATION) && EITHER(HAS_MARLINUI_MENU, EXTENSIBLE_UI)
   #define G26_CLICK_CAN_CANCEL 1
 #endif
 
 // A temperature sensor
 typedef struct TempInfo {
 private:
   raw_adc_t acc;
   raw_adc_t raw;
 public:
   celsius_float_t celsius;
   inline void reset() { acc = 0; }
   inline void sample(const raw_adc_t s) { acc += s; }
   inline void update() { raw = acc; }
   void setraw(const raw_adc_t r) { raw = r; }
-  raw_adc_t getraw() { return raw; }
+  raw_adc_t getraw() const { return raw; }
 } temp_info_t;
 
 #if HAS_TEMP_REDUNDANT
   // A redundant temperature sensor
   typedef struct RedundantTempInfo : public TempInfo {
     temp_info_t* target;
   } redundant_info_t;
 #endif
 
 // A PWM heater with temperature sensor
@@ -386,20 +453,21 @@ typedef struct { raw_adc_t raw_min, raw_max; celsius_t mintemp, maxtemp; } temp_
 
 class Temperature {
 
   public:
 
     #if HAS_HOTEND
       static hotend_info_t temp_hotend[HOTENDS];
       static const celsius_t hotend_maxtemp[HOTENDS];
       static celsius_t hotend_max_target(const uint8_t e) { return hotend_maxtemp[e] - (HOTEND_OVERSHOOT); }
     #endif
+
     #if HAS_HEATED_BED
       static bed_info_t temp_bed;
     #endif
     #if HAS_TEMP_PROBE
       static probe_info_t temp_probe;
     #endif
     #if HAS_TEMP_CHAMBER
       static chamber_info_t temp_chamber;
     #endif
     #if HAS_TEMP_COOLER
@@ -958,26 +1026,30 @@ class Temperature {
       #endif
 
       static void PID_autotune(const celsius_t target, const heater_id_t heater_id, const int8_t ncycles, const bool set_result=false);
 
       #if ENABLED(NO_FAN_SLOWING_IN_PID_TUNING)
         static bool adaptive_fan_slowing;
       #elif ENABLED(ADAPTIVE_FAN_SLOWING)
         static constexpr bool adaptive_fan_slowing = true;
       #endif
 
-      /**
-       * Update the temp manager when PID values change
-       */
+      // Update the temp manager when PID values change
       #if ENABLED(PIDTEMP)
-        static void updatePID() {
-          TERN_(PID_EXTRUSION_SCALING, pes_e_position = 0);
+        static void updatePID() { TERN_(PID_EXTRUSION_SCALING, pes_e_position = 0); }
+        static void setPID(const uint8_t hotend, const_float_t p, const_float_t i, const_float_t d) {
+          #if ENABLED(PID_PARAMS_PER_HOTEND)
+            temp_hotend[hotend].pid.set(p, i, d);
+          #else
+            HOTEND_LOOP() temp_hotend[e].pid.set(p, i, d);
+          #endif
+          updatePID();
         }
       #endif
 
     #endif
 
     #if ENABLED(MPCTEMP)
       void MPC_autotune();
     #endif
 
     #if ENABLED(PROBING_HEATERS_OFF)

commit 1bed10c38075a15bfec380c9c7763fea336e787e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Aug 4 02:38:15 2022 -0500

    üîß Config INI, dump options (#24528)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index feec318050..f6cf81b8a9 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -946,21 +946,21 @@ class Temperature {
        */
       static bool auto_job_over_threshold();
       static void auto_job_check_timer(const bool can_start, const bool can_stop);
     #endif
 
     /**
      * Perform auto-tuning for hotend or bed in response to M303
      */
     #if HAS_PID_HEATING
 
-      #if ANY(PID_DEBUG, PID_BED_DEBUG, PID_CHAMBER_DEBUG)
+      #if HAS_PID_DEBUG
         static bool pid_debug_flag;
       #endif
 
       static void PID_autotune(const celsius_t target, const heater_id_t heater_id, const int8_t ncycles, const bool set_result=false);
 
       #if ENABLED(NO_FAN_SLOWING_IN_PID_TUNING)
         static bool adaptive_fan_slowing;
       #elif ENABLED(ADAPTIVE_FAN_SLOWING)
         static constexpr bool adaptive_fan_slowing = true;
       #endif
@@ -1028,21 +1028,21 @@ class Temperature {
     static void updateTemperaturesFromRawValues();
     static bool updateTemperaturesIfReady() {
       if (!raw_temps_ready) return false;
       updateTemperaturesFromRawValues();
       raw_temps_ready = false;
       return true;
     }
 
     // MAX Thermocouples
     #if HAS_MAX_TC
-      #define MAX_TC_COUNT COUNT_ENABLED(TEMP_SENSOR_0_IS_MAX_TC, TEMP_SENSOR_1_IS_MAX_TC, TEMP_SENSOR_REDUNDANT_IS_MAX_TC)
+      #define MAX_TC_COUNT TEMP_SENSOR_IS_MAX_TC(0) + TEMP_SENSOR_IS_MAX_TC(1) + TEMP_SENSOR_IS_MAX_TC(REDUNDANT)
       #if MAX_TC_COUNT > 1
         #define HAS_MULTI_MAX_TC 1
         #define READ_MAX_TC(N) read_max_tc(N)
       #else
         #define READ_MAX_TC(N) read_max_tc()
       #endif
       static raw_adc_t read_max_tc(TERN_(HAS_MULTI_MAX_TC, const uint8_t hindex=0));
     #endif
 
     #if HAS_AUTO_FAN

commit 90b56452238f8ab673f564b657b979fd6a3a224b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jul 26 21:15:44 2022 -0500

    ü©π Fix lcd_preheat compile

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 80d15ce39e..feec318050 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -1009,21 +1009,21 @@ class Temperature {
         static AutoReporter<AutoReportTemp> auto_reporter;
       #endif
     #endif
 
     #if HAS_HOTEND && HAS_STATUS_MESSAGE
       static void set_heating_message(const uint8_t e, const bool isM104=false);
     #else
       static void set_heating_message(const uint8_t, const bool=false) {}
     #endif
 
-    #if HAS_MARLINUI_MENU && HAS_TEMPERATURE
+    #if HAS_MARLINUI_MENU && HAS_TEMPERATURE && HAS_PREHEAT
       static void lcd_preheat(const uint8_t e, const int8_t indh, const int8_t indb);
     #endif
 
   private:
 
     // Reading raw temperatures and converting to Celsius when ready
     static volatile bool raw_temps_ready;
     static void update_raw_temperatures();
     static void updateTemperaturesFromRawValues();
     static bool updateTemperaturesIfReady() {

commit 54e7b933cdb6d0bf0d69fd661b585100d76e3c88
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jul 3 10:32:47 2022 -0500

    ‚ôªÔ∏è Encapsulate PID in class (#24389)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index c11c9d76de..80d15ce39e 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -225,20 +225,21 @@ public:
   // A redundant temperature sensor
   typedef struct RedundantTempInfo : public TempInfo {
     temp_info_t* target;
   } redundant_info_t;
 #endif
 
 // A PWM heater with temperature sensor
 typedef struct HeaterInfo : public TempInfo {
   celsius_t target;
   uint8_t soft_pwm_amount;
+  bool is_below_target(const celsius_t offs=0) const { return (celsius < (target + offs)); }
 } heater_info_t;
 
 // A heater with PID stabilization
 template<typename T>
 struct PIDHeaterInfo : public HeaterInfo {
   T pid;  // Initialized by settings.load()
 };
 
 #if ENABLED(MPCTEMP)
   struct MPCHeaterInfo : public HeaterInfo {
@@ -708,23 +709,23 @@ class Temperature {
       #endif
     }
 
     /**
      * Called from the Temperature ISR
      */
     static void isr();
     static void readings_ready();
 
     /**
-     * Call periodically to manage heaters
+     * Call periodically to manage heaters and keep the watchdog fed
      */
-    static void manage_heater() __O2; // __O2 added to work around a compiler error
+    static void task();
 
     /**
      * Preheating hotends
      */
     #if MILLISECONDS_PREHEAT_TIME > 0
       static bool is_preheating(const uint8_t E_NAME) {
         return preheat_end_time[HOTEND_INDEX] && PENDING(millis(), preheat_end_time[HOTEND_INDEX]);
       }
       static void start_preheat_time(const uint8_t E_NAME) {
         preheat_end_time[HOTEND_INDEX] = millis() + MILLISECONDS_PREHEAT_TIME;
@@ -800,51 +801,54 @@ class Temperature {
       }
 
       // Start watching a Hotend to make sure it's really heating up
       static void start_watching_hotend(const uint8_t E_NAME) {
         UNUSED(HOTEND_INDEX);
         #if WATCH_HOTENDS
           watch_hotend[HOTEND_INDEX].restart(degHotend(HOTEND_INDEX), degTargetHotend(HOTEND_INDEX));
         #endif
       }
 
+      static void manage_hotends(const millis_t &ms);
+
     #endif // HAS_HOTEND
 
     #if HAS_HEATED_BED
 
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         static raw_adc_t rawBedTemp()  { return temp_bed.getraw(); }
       #endif
       static celsius_float_t degBed()  { return temp_bed.celsius; }
       static celsius_t wholeDegBed()   { return static_cast<celsius_t>(degBed() + 0.5f); }
       static celsius_t degTargetBed()  { return temp_bed.target; }
       static bool isHeatingBed()       { return temp_bed.target > temp_bed.celsius; }
       static bool isCoolingBed()       { return temp_bed.target < temp_bed.celsius; }
+      static bool degBedNear(const celsius_t temp) {
+        return ABS(wholeDegBed() - temp) < (TEMP_BED_HYSTERESIS);
+      }
 
       // Start watching the Bed to make sure it's really heating up
       static void start_watching_bed() { TERN_(WATCH_BED, watch_bed.restart(degBed(), degTargetBed())); }
 
       static void setTargetBed(const celsius_t celsius) {
         TERN_(AUTO_POWER_CONTROL, if (celsius) powerManager.power_on());
         temp_bed.target = _MIN(celsius, BED_MAX_TARGET);
         start_watching_bed();
       }
 
       static bool wait_for_bed(const bool no_wait_for_cooling=true
         OPTARG(G26_CLICK_CAN_CANCEL, const bool click_to_cancel=false)
       );
 
       static void wait_for_bed_heating();
 
-      static bool degBedNear(const celsius_t temp) {
-        return ABS(wholeDegBed() - temp) < (TEMP_BED_HYSTERESIS);
-      }
+      static void manage_heated_bed(const millis_t &ms);
 
     #endif // HAS_HEATED_BED
 
     #if HAS_TEMP_PROBE
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         static raw_adc_t rawProbeTemp()  { return temp_probe.getraw(); }
       #endif
       static celsius_float_t degProbe()  { return temp_probe.celsius; }
       static celsius_t wholeDegProbe()   { return static_cast<celsius_t>(degProbe() + 0.5f); }
       static bool isProbeBelowTemp(const celsius_t target_temp) { return wholeDegProbe() < target_temp; }
@@ -856,20 +860,21 @@ class Temperature {
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         static raw_adc_t rawChamberTemp()    { return temp_chamber.getraw(); }
       #endif
       static celsius_float_t degChamber()    { return temp_chamber.celsius; }
       static celsius_t wholeDegChamber()     { return static_cast<celsius_t>(degChamber() + 0.5f); }
       #if HAS_HEATED_CHAMBER
         static celsius_t degTargetChamber()  { return temp_chamber.target; }
         static bool isHeatingChamber()       { return temp_chamber.target > temp_chamber.celsius; }
         static bool isCoolingChamber()       { return temp_chamber.target < temp_chamber.celsius; }
         static bool wait_for_chamber(const bool no_wait_for_cooling=true);
+        static void manage_heated_chamber(const millis_t &ms);
       #endif
     #endif
 
     #if HAS_HEATED_CHAMBER
       static void setTargetChamber(const celsius_t celsius) {
         temp_chamber.target = _MIN(celsius, CHAMBER_MAX_TARGET);
         start_watching_chamber();
       }
       // Start watching the Chamber to make sure it's really heating up
       static void start_watching_chamber() { TERN_(WATCH_CHAMBER, watch_chamber.restart(degChamber(), degTargetChamber())); }
@@ -879,20 +884,21 @@ class Temperature {
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         static raw_adc_t rawCoolerTemp()   { return temp_cooler.getraw(); }
       #endif
       static celsius_float_t degCooler()   { return temp_cooler.celsius; }
       static celsius_t wholeDegCooler()    { return static_cast<celsius_t>(temp_cooler.celsius + 0.5f); }
       #if HAS_COOLER
         static celsius_t degTargetCooler() { return temp_cooler.target; }
         static bool isLaserHeating()       { return temp_cooler.target > temp_cooler.celsius; }
         static bool isLaserCooling()       { return temp_cooler.target < temp_cooler.celsius; }
         static bool wait_for_cooler(const bool no_wait_for_cooling=true);
+        static void manage_cooler(const millis_t &ms);
       #endif
     #endif
 
     #if HAS_TEMP_BOARD
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         static raw_adc_t rawBoardTemp()  { return temp_board.getraw(); }
       #endif
       static celsius_float_t degBoard()  { return temp_board.celsius; }
       static celsius_t wholeDegBoard()   { return static_cast<celsius_t>(temp_board.celsius + 0.5f); }
     #endif

commit ea7bebb56887491d9c6b2a2ba2c2aee98dabc3e5
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Tue May 31 18:01:59 2022 +0100

    üí• More M306 M => M306 H (#24258)
    
    Followup to #24253

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index da9d4a071b..c11c9d76de 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -96,21 +96,21 @@ hotend_pid_t;
 
 #if ENABLED(MPCTEMP)
   typedef struct {
     float heater_power;                 // M306 P
     float block_heat_capacity;          // M306 C
     float sensor_responsiveness;        // M306 R
     float ambient_xfer_coeff_fan0;      // M306 A
     #if ENABLED(MPC_INCLUDE_FAN)
       float fan255_adjustment;          // M306 F
     #endif
-    float filament_heat_capacity_permm; // M306 M
+    float filament_heat_capacity_permm; // M306 H
   } MPC_t;
 #endif
 
 /**
  * States for ADC reading in the ISR
  */
 enum ADCSensorState : char {
   StartSampling,
   #if HAS_TEMP_ADC_0
     PrepareTemp_0, MeasureTemp_0,

commit 6ecf52f196d08d399c24b1516fc0b33b227ed66c
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Sat May 28 23:40:08 2022 +0100

    üö© MPC update (#24253)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 2cc2382174..da9d4a071b 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -89,27 +89,28 @@ hotend_pid_t;
 #if ENABLED(PIDTEMP)
   #define _PID_Kc(H) TERN(PID_EXTRUSION_SCALING, Temperature::temp_hotend[H].pid.Kc, 1)
   #define _PID_Kf(H) TERN(PID_FAN_SCALING,       Temperature::temp_hotend[H].pid.Kf, 0)
 #else
   #define _PID_Kc(H) 1
   #define _PID_Kf(H) 0
 #endif
 
 #if ENABLED(MPCTEMP)
   typedef struct {
-    float heater_power;             // M306 P
-    float block_heat_capacity;      // M306 C
-    float sensor_responsiveness;    // M306 R
-    float ambient_xfer_coeff_fan0;  // M306 A
+    float heater_power;                 // M306 P
+    float block_heat_capacity;          // M306 C
+    float sensor_responsiveness;        // M306 R
+    float ambient_xfer_coeff_fan0;      // M306 A
     #if ENABLED(MPC_INCLUDE_FAN)
-      float fan255_adjustment;      // M306 F
+      float fan255_adjustment;          // M306 F
     #endif
+    float filament_heat_capacity_permm; // M306 M
   } MPC_t;
 #endif
 
 /**
  * States for ADC reading in the ISR
  */
 enum ADCSensorState : char {
   StartSampling,
   #if HAS_TEMP_ADC_0
     PrepareTemp_0, MeasureTemp_0,

commit 659b4172aa49d82e54a08b5ed674b3ba4ad51fb0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu May 5 18:55:43 2022 -0500

    üî® Prevent build attribute define conflicts

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index f54cd0334b..2cc2382174 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -709,21 +709,21 @@ class Temperature {
 
     /**
      * Called from the Temperature ISR
      */
     static void isr();
     static void readings_ready();
 
     /**
      * Call periodically to manage heaters
      */
-    static void manage_heater() _O2; // Added _O2 to work around a compiler error
+    static void manage_heater() __O2; // __O2 added to work around a compiler error
 
     /**
      * Preheating hotends
      */
     #if MILLISECONDS_PREHEAT_TIME > 0
       static bool is_preheating(const uint8_t E_NAME) {
         return preheat_end_time[HOTEND_INDEX] && PENDING(millis(), preheat_end_time[HOTEND_INDEX]);
       }
       static void start_preheat_time(const uint8_t E_NAME) {
         preheat_end_time[HOTEND_INDEX] = millis() + MILLISECONDS_PREHEAT_TIME;

commit 5005c7b64c1763eca767ad476f404301d6ef754a
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Tue Apr 19 15:03:42 2022 +1200

    üêõ Fix Manual Move cold extrude override (#24045)
    
    Followup to #19606
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 7cd2c13343..f54cd0334b 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -422,24 +422,32 @@ class Temperature {
 
     #if ENABLED(FAN_SOFT_PWM)
       static uint8_t soft_pwm_amount_fan[FAN_COUNT],
                      soft_pwm_count_fan[FAN_COUNT];
     #endif
 
     #if BOTH(FAN_SOFT_PWM, USE_CONTROLLER_FAN)
       static uint8_t soft_pwm_controller_speed;
     #endif
 
+    #if BOTH(HAS_MARLINUI_MENU, PREVENT_COLD_EXTRUSION) && E_MANUAL > 0
+      static bool allow_cold_extrude_override;
+      static void set_menu_cold_override(const bool allow) { allow_cold_extrude_override = allow; }
+    #else
+      static constexpr bool allow_cold_extrude_override = false;
+      static void set_menu_cold_override(const bool) {}
+    #endif
+
     #if ENABLED(PREVENT_COLD_EXTRUSION)
       static bool allow_cold_extrude;
       static celsius_t extrude_min_temp;
-      static bool tooCold(const celsius_t temp) { return allow_cold_extrude ? false : temp < extrude_min_temp - (TEMP_WINDOW); }
+      static bool tooCold(const celsius_t temp) { return !allow_cold_extrude && !allow_cold_extrude_override && temp < extrude_min_temp - (TEMP_WINDOW); }
       static bool tooColdToExtrude(const uint8_t E_NAME)       { return tooCold(wholeDegHotend(HOTEND_INDEX)); }
       static bool targetTooColdToExtrude(const uint8_t E_NAME) { return tooCold(degTargetHotend(HOTEND_INDEX)); }
     #else
       static bool tooColdToExtrude(const uint8_t) { return false; }
       static bool targetTooColdToExtrude(const uint8_t) { return false; }
     #endif
 
     static bool hotEnoughToExtrude(const uint8_t e) { return !tooColdToExtrude(e); }
     static bool targetHotEnoughToExtrude(const uint8_t e) { return !targetTooColdToExtrude(e); }
 

commit 80810f1b187661860a2ded43e2a0c4cc356edebe
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jan 1 17:49:54 2022 -0600

    üö® Fix some compiler warnings

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index aa80bd0a23..7cd2c13343 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -979,21 +979,21 @@ class Temperature {
       #if HAS_HEATED_BED
         static void reset_bed_idle_timer() {
           heater_idle[IDLE_INDEX_BED].reset();
           start_watching_bed();
         }
       #endif
 
     #endif // HEATER_IDLE_HANDLER
 
     #if HAS_TEMP_SENSOR
-      static void print_heater_states(const uint8_t target_extruder
+      static void print_heater_states(const int8_t target_extruder
         OPTARG(HAS_TEMP_REDUNDANT, const bool include_r=false)
       );
       #if ENABLED(AUTO_REPORT_TEMPERATURES)
         struct AutoReportTemp { static void report(); };
         static AutoReporter<AutoReportTemp> auto_reporter;
       #endif
     #endif
 
     #if HAS_HOTEND && HAS_STATUS_MESSAGE
       static void set_heating_message(const uint8_t e, const bool isM104=false);

commit 72b2e2b2c7230245dea9fcb46b9b8a92bcb11bcc
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Fri Apr 1 08:14:14 2022 +0100

    ‚öóÔ∏è Temperature Model Predictive Control (#23751)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index a4681ba02b..aa80bd0a23 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -87,20 +87,32 @@ hotend_pid_t;
 #define _PID_Ki(H) TERN(PIDTEMP, Temperature::temp_hotend[H].pid.Ki, NAN)
 #define _PID_Kd(H) TERN(PIDTEMP, Temperature::temp_hotend[H].pid.Kd, NAN)
 #if ENABLED(PIDTEMP)
   #define _PID_Kc(H) TERN(PID_EXTRUSION_SCALING, Temperature::temp_hotend[H].pid.Kc, 1)
   #define _PID_Kf(H) TERN(PID_FAN_SCALING,       Temperature::temp_hotend[H].pid.Kf, 0)
 #else
   #define _PID_Kc(H) 1
   #define _PID_Kf(H) 0
 #endif
 
+#if ENABLED(MPCTEMP)
+  typedef struct {
+    float heater_power;             // M306 P
+    float block_heat_capacity;      // M306 C
+    float sensor_responsiveness;    // M306 R
+    float ambient_xfer_coeff_fan0;  // M306 A
+    #if ENABLED(MPC_INCLUDE_FAN)
+      float fan255_adjustment;      // M306 F
+    #endif
+  } MPC_t;
+#endif
+
 /**
  * States for ADC reading in the ISR
  */
 enum ADCSensorState : char {
   StartSampling,
   #if HAS_TEMP_ADC_0
     PrepareTemp_0, MeasureTemp_0,
   #endif
   #if HAS_TEMP_ADC_BED
     PrepareTemp_BED, MeasureTemp_BED,
@@ -170,29 +182,33 @@ enum ADCSensorState : char {
 
 // Minimum number of Temperature::ISR loops between sensor readings.
 // Multiplied by 16 (OVERSAMPLENR) to obtain the total time to
 // get all oversampled sensor readings
 #define MIN_ADC_ISR_LOOPS 10
 
 #define ACTUAL_ADC_SAMPLES _MAX(int(MIN_ADC_ISR_LOOPS), int(SensorsReady))
 
 #if HAS_PID_HEATING
   #define PID_K2 (1-float(PID_K1))
-  #define PID_dT ((OVERSAMPLENR * float(ACTUAL_ADC_SAMPLES)) / TEMP_TIMER_FREQUENCY)
+  #define PID_dT ((OVERSAMPLENR * float(ACTUAL_ADC_SAMPLES)) / (TEMP_TIMER_FREQUENCY))
 
   // Apply the scale factors to the PID values
   #define scalePID_i(i)   ( float(i) * PID_dT )
   #define unscalePID_i(i) ( float(i) / PID_dT )
   #define scalePID_d(d)   ( float(d) / PID_dT )
   #define unscalePID_d(d) ( float(d) * PID_dT )
 #endif
 
+#if ENABLED(MPCTEMP)
+  #define MPC_dT ((OVERSAMPLENR * float(ACTUAL_ADC_SAMPLES)) / (TEMP_TIMER_FREQUENCY))
+#endif
+
 #if ENABLED(G26_MESH_VALIDATION) && EITHER(HAS_MARLINUI_MENU, EXTENSIBLE_UI)
   #define G26_CLICK_CAN_CANCEL 1
 #endif
 
 // A temperature sensor
 typedef struct TempInfo {
 private:
   raw_adc_t acc;
   raw_adc_t raw;
 public:
@@ -216,22 +232,33 @@ typedef struct HeaterInfo : public TempInfo {
   celsius_t target;
   uint8_t soft_pwm_amount;
 } heater_info_t;
 
 // A heater with PID stabilization
 template<typename T>
 struct PIDHeaterInfo : public HeaterInfo {
   T pid;  // Initialized by settings.load()
 };
 
+#if ENABLED(MPCTEMP)
+  struct MPCHeaterInfo : public HeaterInfo {
+    MPC_t constants;
+    float modeled_ambient_temp,
+          modeled_block_temp,
+          modeled_sensor_temp;
+  };
+#endif
+
 #if ENABLED(PIDTEMP)
   typedef struct PIDHeaterInfo<hotend_pid_t> hotend_info_t;
+#elif ENABLED(MPCTEMP)
+  typedef struct MPCHeaterInfo hotend_info_t;
 #else
   typedef heater_info_t hotend_info_t;
 #endif
 #if HAS_HEATED_BED
   #if ENABLED(PIDTEMPBED)
     typedef struct PIDHeaterInfo<PID_t> bed_info_t;
   #else
     typedef heater_info_t bed_info_t;
   #endif
 #endif
@@ -474,24 +501,28 @@ class Temperature {
       static constexpr millis_t fan_update_interval_ms = TERN(HAS_PWMFANCHECK, 5000, TERN(HAS_FANCHECK, 1000, 2500));
     #endif
 
   private:
 
     #if ENABLED(WATCH_HOTENDS)
       static hotend_watch_t watch_hotend[HOTENDS];
     #endif
 
     #if ENABLED(PID_EXTRUSION_SCALING)
-      static int32_t last_e_position, lpq[LPQ_MAX_LEN];
+      static int32_t pes_e_position, lpq[LPQ_MAX_LEN];
       static lpq_ptr_t lpq_ptr;
     #endif
 
+    #if ENABLED(MPCTEMP)
+      static int32_t mpc_e_position;
+    #endif
+
     #if HAS_HOTEND
       static temp_range_t temp_range[HOTENDS];
     #endif
 
     #if HAS_HEATED_BED
       #if ENABLED(WATCH_BED)
         static bed_watch_t watch_bed;
       #endif
       IF_DISABLED(PIDTEMPBED, static millis_t next_bed_check_ms);
       static raw_adc_t mintemp_raw_BED, maxtemp_raw_BED;
@@ -917,26 +948,30 @@ class Temperature {
         static bool adaptive_fan_slowing;
       #elif ENABLED(ADAPTIVE_FAN_SLOWING)
         static constexpr bool adaptive_fan_slowing = true;
       #endif
 
       /**
        * Update the temp manager when PID values change
        */
       #if ENABLED(PIDTEMP)
         static void updatePID() {
-          TERN_(PID_EXTRUSION_SCALING, last_e_position = 0);
+          TERN_(PID_EXTRUSION_SCALING, pes_e_position = 0);
         }
       #endif
 
     #endif
 
+    #if ENABLED(MPCTEMP)
+      void MPC_autotune();
+    #endif
+
     #if ENABLED(PROBING_HEATERS_OFF)
       static void pause_heaters(const bool p);
     #endif
 
     #if HEATER_IDLE_HANDLER
 
       static void reset_hotend_idle_timer(const uint8_t E_NAME) {
         heater_idle[HOTEND_INDEX].reset();
         start_watching_hotend(HOTEND_INDEX);
       }

commit fd742616ba6fd2db1607df197dea142cbf1a9d3f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 25 17:35:00 2022 -0500

    üö∏ Clear "heating/cooling" message on temp reached

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index cb84f7e395..a4681ba02b 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -954,23 +954,23 @@ class Temperature {
       static void print_heater_states(const uint8_t target_extruder
         OPTARG(HAS_TEMP_REDUNDANT, const bool include_r=false)
       );
       #if ENABLED(AUTO_REPORT_TEMPERATURES)
         struct AutoReportTemp { static void report(); };
         static AutoReporter<AutoReportTemp> auto_reporter;
       #endif
     #endif
 
     #if HAS_HOTEND && HAS_STATUS_MESSAGE
-      static void set_heating_message(const uint8_t e);
+      static void set_heating_message(const uint8_t e, const bool isM104=false);
     #else
-      static void set_heating_message(const uint8_t) {}
+      static void set_heating_message(const uint8_t, const bool=false) {}
     #endif
 
     #if HAS_MARLINUI_MENU && HAS_TEMPERATURE
       static void lcd_preheat(const uint8_t e, const int8_t indh, const int8_t indb);
     #endif
 
   private:
 
     // Reading raw temperatures and converting to Celsius when ready
     static volatile bool raw_temps_ready;

commit 631e35bfd6cec8d61eca31ac2945ff890ab8f2ed
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Fri Mar 18 03:15:26 2022 +0000

    ‚ö°Ô∏è Fix noisy ADC - 16x oversampling with 12-bit ADC (#23867)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index eb2f4337c0..cb84f7e395 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -185,26 +185,30 @@ enum ADCSensorState : char {
   #define scalePID_d(d)   ( float(d) / PID_dT )
   #define unscalePID_d(d) ( float(d) * PID_dT )
 #endif
 
 #if ENABLED(G26_MESH_VALIDATION) && EITHER(HAS_MARLINUI_MENU, EXTENSIBLE_UI)
   #define G26_CLICK_CAN_CANCEL 1
 #endif
 
 // A temperature sensor
 typedef struct TempInfo {
-  uint16_t acc;
-  int16_t raw;
+private:
+  raw_adc_t acc;
+  raw_adc_t raw;
+public:
   celsius_float_t celsius;
   inline void reset() { acc = 0; }
-  inline void sample(const uint16_t s) { acc += s; }
+  inline void sample(const raw_adc_t s) { acc += s; }
   inline void update() { raw = acc; }
+  void setraw(const raw_adc_t r) { raw = r; }
+  raw_adc_t getraw() { return raw; }
 } temp_info_t;
 
 #if HAS_TEMP_REDUNDANT
   // A redundant temperature sensor
   typedef struct RedundantTempInfo : public TempInfo {
     temp_info_t* target;
   } redundant_info_t;
 #endif
 
 // A PWM heater with temperature sensor
@@ -280,23 +284,21 @@ struct HeaterWatch {
   typedef struct HeaterWatch<WATCH_BED_TEMP_INCREASE, TEMP_BED_HYSTERESIS, WATCH_BED_TEMP_PERIOD> bed_watch_t;
 #endif
 #if WATCH_CHAMBER
   typedef struct HeaterWatch<WATCH_CHAMBER_TEMP_INCREASE, TEMP_CHAMBER_HYSTERESIS, WATCH_CHAMBER_TEMP_PERIOD> chamber_watch_t;
 #endif
 #if WATCH_COOLER
   typedef struct HeaterWatch<WATCH_COOLER_TEMP_INCREASE, TEMP_COOLER_HYSTERESIS, WATCH_COOLER_TEMP_PERIOD> cooler_watch_t;
 #endif
 
 // Temperature sensor read value ranges
-typedef struct { int16_t raw_min, raw_max; } raw_range_t;
-typedef struct { celsius_t mintemp, maxtemp; } celsius_range_t;
-typedef struct { int16_t raw_min, raw_max; celsius_t mintemp, maxtemp; } temp_range_t;
+typedef struct { raw_adc_t raw_min, raw_max; celsius_t mintemp, maxtemp; } temp_range_t;
 
 #define THERMISTOR_ABS_ZERO_C           -273.15f  // bbbbrrrrr cold !
 #define THERMISTOR_RESISTANCE_NOMINAL_C 25.0f     // mmmmm comfortable
 
 #if HAS_USER_THERMISTORS
 
   enum CustomThermistorIndex : uint8_t {
     #if TEMP_SENSOR_0_IS_CUSTOM
       CTI_HOTEND_0,
     #endif
@@ -485,41 +487,41 @@ class Temperature {
 
     #if HAS_HOTEND
       static temp_range_t temp_range[HOTENDS];
     #endif
 
     #if HAS_HEATED_BED
       #if ENABLED(WATCH_BED)
         static bed_watch_t watch_bed;
       #endif
       IF_DISABLED(PIDTEMPBED, static millis_t next_bed_check_ms);
-      static int16_t mintemp_raw_BED, maxtemp_raw_BED;
+      static raw_adc_t mintemp_raw_BED, maxtemp_raw_BED;
     #endif
 
     #if HAS_HEATED_CHAMBER
       #if ENABLED(WATCH_CHAMBER)
         static chamber_watch_t watch_chamber;
       #endif
       TERN(PIDTEMPCHAMBER,,static millis_t next_chamber_check_ms);
-      static int16_t mintemp_raw_CHAMBER, maxtemp_raw_CHAMBER;
+      static raw_adc_t mintemp_raw_CHAMBER, maxtemp_raw_CHAMBER;
     #endif
 
     #if HAS_COOLER
       #if ENABLED(WATCH_COOLER)
         static cooler_watch_t watch_cooler;
       #endif
       static millis_t next_cooler_check_ms, cooler_fan_flush_ms;
-      static int16_t mintemp_raw_COOLER, maxtemp_raw_COOLER;
+      static raw_adc_t mintemp_raw_COOLER, maxtemp_raw_COOLER;
     #endif
 
     #if HAS_TEMP_BOARD && ENABLED(THERMAL_PROTECTION_BOARD)
-      static int16_t mintemp_raw_BOARD, maxtemp_raw_BOARD;
+      static raw_adc_t mintemp_raw_BOARD, maxtemp_raw_BOARD;
     #endif
 
     #if MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED > 1
       static uint8_t consecutive_low_temperature_error[HOTENDS];
     #endif
 
     #if MILLISECONDS_PREHEAT_TIME > 0
       static millis_t preheat_end_time[HOTENDS];
     #endif
 
@@ -559,21 +561,21 @@ class Temperature {
     void init();
 
     /**
      * Static (class) methods
      */
 
     #if HAS_USER_THERMISTORS
       static user_thermistor_t user_thermistor[USER_THERMISTORS];
       static void M305_report(const uint8_t t_index, const bool forReplay=true);
       static void reset_user_thermistors();
-      static celsius_float_t user_thermistor_to_deg_c(const uint8_t t_index, const int16_t raw);
+      static celsius_float_t user_thermistor_to_deg_c(const uint8_t t_index, const raw_adc_t raw);
       static bool set_pull_up_res(int8_t t_index, float value) {
         //if (!WITHIN(t_index, 0, USER_THERMISTORS - 1)) return false;
         if (!WITHIN(value, 1, 1000000)) return false;
         user_thermistor[t_index].series_res = value;
         return true;
       }
       static bool set_res25(int8_t t_index, float value) {
         if (!WITHIN(value, 1, 10000000)) return false;
         user_thermistor[t_index].res_25 = value;
         user_thermistor[t_index].pre_calc = true;
@@ -587,39 +589,39 @@ class Temperature {
       }
       static bool set_sh_coeff(int8_t t_index, float value) {
         if (!WITHIN(value, -0.01f, 0.01f)) return false;
         user_thermistor[t_index].sh_c_coeff = value;
         user_thermistor[t_index].pre_calc = true;
         return true;
       }
     #endif
 
     #if HAS_HOTEND
-      static celsius_float_t analog_to_celsius_hotend(const int16_t raw, const uint8_t e);
+      static celsius_float_t analog_to_celsius_hotend(const raw_adc_t raw, const uint8_t e);
     #endif
     #if HAS_HEATED_BED
-      static celsius_float_t analog_to_celsius_bed(const int16_t raw);
+      static celsius_float_t analog_to_celsius_bed(const raw_adc_t raw);
     #endif
     #if HAS_TEMP_CHAMBER
-      static celsius_float_t analog_to_celsius_chamber(const int16_t raw);
+      static celsius_float_t analog_to_celsius_chamber(const raw_adc_t raw);
     #endif
     #if HAS_TEMP_PROBE
-      static celsius_float_t analog_to_celsius_probe(const int16_t raw);
+      static celsius_float_t analog_to_celsius_probe(const raw_adc_t raw);
     #endif
     #if HAS_TEMP_COOLER
-      static celsius_float_t analog_to_celsius_cooler(const int16_t raw);
+      static celsius_float_t analog_to_celsius_cooler(const raw_adc_t raw);
     #endif
     #if HAS_TEMP_BOARD
-      static celsius_float_t analog_to_celsius_board(const int16_t raw);
+      static celsius_float_t analog_to_celsius_board(const raw_adc_t raw);
     #endif
     #if HAS_TEMP_REDUNDANT
-      static celsius_float_t analog_to_celsius_redundant(const int16_t raw);
+      static celsius_float_t analog_to_celsius_redundant(const raw_adc_t raw);
     #endif
 
     #if HAS_FAN
 
       static uint8_t fan_speed[FAN_COUNT];
       #define FANS_LOOP(I) LOOP_L_N(I, FAN_COUNT)
 
       static void set_fan_speed(const uint8_t fan, const uint16_t speed);
 
       #if ENABLED(REPORT_FAN_CHANGE)
@@ -700,22 +702,22 @@ class Temperature {
 
     static celsius_float_t degHotend(const uint8_t E_NAME) {
       return TERN0(HAS_HOTEND, temp_hotend[HOTEND_INDEX].celsius);
     }
 
     static celsius_t wholeDegHotend(const uint8_t E_NAME) {
       return TERN0(HAS_HOTEND, static_cast<celsius_t>(temp_hotend[HOTEND_INDEX].celsius + 0.5f));
     }
 
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
-      static int16_t rawHotendTemp(const uint8_t E_NAME) {
-        return TERN0(HAS_HOTEND, temp_hotend[HOTEND_INDEX].raw);
+      static raw_adc_t rawHotendTemp(const uint8_t E_NAME) {
+        return TERN0(HAS_HOTEND, temp_hotend[HOTEND_INDEX].getraw());
       }
     #endif
 
     static celsius_t degTargetHotend(const uint8_t E_NAME) {
       return TERN0(HAS_HOTEND, temp_hotend[HOTEND_INDEX].target);
     }
 
     #if HAS_HOTEND
 
       static void setTargetHotend(const celsius_t celsius, const uint8_t E_NAME) {
@@ -763,21 +765,21 @@ class Temperature {
         #if WATCH_HOTENDS
           watch_hotend[HOTEND_INDEX].restart(degHotend(HOTEND_INDEX), degTargetHotend(HOTEND_INDEX));
         #endif
       }
 
     #endif // HAS_HOTEND
 
     #if HAS_HEATED_BED
 
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
-        static int16_t rawBedTemp()    { return temp_bed.raw; }
+        static raw_adc_t rawBedTemp()  { return temp_bed.getraw(); }
       #endif
       static celsius_float_t degBed()  { return temp_bed.celsius; }
       static celsius_t wholeDegBed()   { return static_cast<celsius_t>(degBed() + 0.5f); }
       static celsius_t degTargetBed()  { return temp_bed.target; }
       static bool isHeatingBed()       { return temp_bed.target > temp_bed.celsius; }
       static bool isCoolingBed()       { return temp_bed.target < temp_bed.celsius; }
 
       // Start watching the Bed to make sure it's really heating up
       static void start_watching_bed() { TERN_(WATCH_BED, watch_bed.restart(degBed(), degTargetBed())); }
 
@@ -794,32 +796,32 @@ class Temperature {
       static void wait_for_bed_heating();
 
       static bool degBedNear(const celsius_t temp) {
         return ABS(wholeDegBed() - temp) < (TEMP_BED_HYSTERESIS);
       }
 
     #endif // HAS_HEATED_BED
 
     #if HAS_TEMP_PROBE
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
-        static int16_t rawProbeTemp()    { return temp_probe.raw; }
+        static raw_adc_t rawProbeTemp()  { return temp_probe.getraw(); }
       #endif
       static celsius_float_t degProbe()  { return temp_probe.celsius; }
       static celsius_t wholeDegProbe()   { return static_cast<celsius_t>(degProbe() + 0.5f); }
       static bool isProbeBelowTemp(const celsius_t target_temp) { return wholeDegProbe() < target_temp; }
       static bool isProbeAboveTemp(const celsius_t target_temp) { return wholeDegProbe() > target_temp; }
       static bool wait_for_probe(const celsius_t target_temp, bool no_wait_for_cooling=true);
     #endif
 
     #if HAS_TEMP_CHAMBER
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
-        static int16_t rawChamberTemp()      { return temp_chamber.raw; }
+        static raw_adc_t rawChamberTemp()    { return temp_chamber.getraw(); }
       #endif
       static celsius_float_t degChamber()    { return temp_chamber.celsius; }
       static celsius_t wholeDegChamber()     { return static_cast<celsius_t>(degChamber() + 0.5f); }
       #if HAS_HEATED_CHAMBER
         static celsius_t degTargetChamber()  { return temp_chamber.target; }
         static bool isHeatingChamber()       { return temp_chamber.target > temp_chamber.celsius; }
         static bool isCoolingChamber()       { return temp_chamber.target < temp_chamber.celsius; }
         static bool wait_for_chamber(const bool no_wait_for_cooling=true);
       #endif
     #endif
@@ -828,44 +830,43 @@ class Temperature {
       static void setTargetChamber(const celsius_t celsius) {
         temp_chamber.target = _MIN(celsius, CHAMBER_MAX_TARGET);
         start_watching_chamber();
       }
       // Start watching the Chamber to make sure it's really heating up
       static void start_watching_chamber() { TERN_(WATCH_CHAMBER, watch_chamber.restart(degChamber(), degTargetChamber())); }
     #endif
 
     #if HAS_TEMP_COOLER
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
-        static int16_t rawCoolerTemp()     { return temp_cooler.raw; }
+        static raw_adc_t rawCoolerTemp()   { return temp_cooler.getraw(); }
       #endif
       static celsius_float_t degCooler()   { return temp_cooler.celsius; }
       static celsius_t wholeDegCooler()    { return static_cast<celsius_t>(temp_cooler.celsius + 0.5f); }
       #if HAS_COOLER
         static celsius_t degTargetCooler() { return temp_cooler.target; }
         static bool isLaserHeating()       { return temp_cooler.target > temp_cooler.celsius; }
         static bool isLaserCooling()       { return temp_cooler.target < temp_cooler.celsius; }
         static bool wait_for_cooler(const bool no_wait_for_cooling=true);
       #endif
     #endif
 
     #if HAS_TEMP_BOARD
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
-        static int16_t rawBoardTemp()    { return temp_board.raw; }
+        static raw_adc_t rawBoardTemp()  { return temp_board.getraw(); }
       #endif
       static celsius_float_t degBoard()  { return temp_board.celsius; }
       static celsius_t wholeDegBoard()   { return static_cast<celsius_t>(temp_board.celsius + 0.5f); }
     #endif
 
     #if HAS_TEMP_REDUNDANT
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
-        static int16_t rawRedundantTemp()         { return temp_redundant.raw; }
-        static int16_t rawRedundanTargetTemp()    { return (*temp_redundant.target).raw; }
+        static raw_adc_t rawRedundantTemp()       { return temp_redundant.getraw(); }
       #endif
       static celsius_float_t degRedundant()       { return temp_redundant.celsius; }
       static celsius_float_t degRedundantTarget() { return (*temp_redundant.target).celsius; }
       static celsius_t wholeDegRedundant()        { return static_cast<celsius_t>(temp_redundant.celsius + 0.5f); }
       static celsius_t wholeDegRedundantTarget()  { return static_cast<celsius_t>((*temp_redundant.target).celsius + 0.5f); }
     #endif
 
     #if HAS_COOLER
       static void setTargetCooler(const celsius_t celsius) {
         temp_cooler.target = constrain(celsius, COOLER_MIN_TARGET, COOLER_MAX_TARGET);
@@ -984,21 +985,21 @@ class Temperature {
 
     // MAX Thermocouples
     #if HAS_MAX_TC
       #define MAX_TC_COUNT COUNT_ENABLED(TEMP_SENSOR_0_IS_MAX_TC, TEMP_SENSOR_1_IS_MAX_TC, TEMP_SENSOR_REDUNDANT_IS_MAX_TC)
       #if MAX_TC_COUNT > 1
         #define HAS_MULTI_MAX_TC 1
         #define READ_MAX_TC(N) read_max_tc(N)
       #else
         #define READ_MAX_TC(N) read_max_tc()
       #endif
-      static int16_t read_max_tc(TERN_(HAS_MULTI_MAX_TC, const uint8_t hindex=0));
+      static raw_adc_t read_max_tc(TERN_(HAS_MULTI_MAX_TC, const uint8_t hindex=0));
     #endif
 
     #if HAS_AUTO_FAN
       #if ENABLED(POWER_OFF_WAIT_FOR_COOLDOWN)
         static bool autofans_on;
       #endif
       static void update_autofans();
     #endif
 
     #if HAS_HOTEND

commit ab46b7e2f298826a5512569d6e79bb59a7a6b8ea
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jan 25 15:33:03 2022 -0600

    üßë‚Äçüíª HAS_MARLINUI_MENU, HAS_MANUAL_MOVE_MENU

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index ade1d480b2..eb2f4337c0 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -179,21 +179,21 @@ enum ADCSensorState : char {
   #define PID_K2 (1-float(PID_K1))
   #define PID_dT ((OVERSAMPLENR * float(ACTUAL_ADC_SAMPLES)) / TEMP_TIMER_FREQUENCY)
 
   // Apply the scale factors to the PID values
   #define scalePID_i(i)   ( float(i) * PID_dT )
   #define unscalePID_i(i) ( float(i) / PID_dT )
   #define scalePID_d(d)   ( float(d) / PID_dT )
   #define unscalePID_d(d) ( float(d) * PID_dT )
 #endif
 
-#if ENABLED(G26_MESH_VALIDATION) && EITHER(HAS_LCD_MENU, EXTENSIBLE_UI)
+#if ENABLED(G26_MESH_VALIDATION) && EITHER(HAS_MARLINUI_MENU, EXTENSIBLE_UI)
   #define G26_CLICK_CAN_CANCEL 1
 #endif
 
 // A temperature sensor
 typedef struct TempInfo {
   uint16_t acc;
   int16_t raw;
   celsius_float_t celsius;
   inline void reset() { acc = 0; }
   inline void sample(const uint16_t s) { acc += s; }
@@ -958,21 +958,21 @@ class Temperature {
         static AutoReporter<AutoReportTemp> auto_reporter;
       #endif
     #endif
 
     #if HAS_HOTEND && HAS_STATUS_MESSAGE
       static void set_heating_message(const uint8_t e);
     #else
       static void set_heating_message(const uint8_t) {}
     #endif
 
-    #if HAS_LCD_MENU && HAS_TEMPERATURE
+    #if HAS_MARLINUI_MENU && HAS_TEMPERATURE
       static void lcd_preheat(const uint8_t e, const int8_t indh, const int8_t indb);
     #endif
 
   private:
 
     // Reading raw temperatures and converting to Celsius when ready
     static volatile bool raw_temps_ready;
     static void update_raw_temperatures();
     static void updateTemperaturesFromRawValues();
     static bool updateTemperaturesIfReady() {

commit 9285b6b9edcb42d38736a08785371204aea56501
Author: zerkix <97692157+zerkix@users.noreply.github.com>
Date:   Mon Jan 17 07:05:31 2022 +0100

    üêõ Finish and organize temp sensors (#23519)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 5affcf740d..ade1d480b2 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -224,38 +224,38 @@ struct PIDHeaterInfo : public HeaterInfo {
 #else
   typedef heater_info_t hotend_info_t;
 #endif
 #if HAS_HEATED_BED
   #if ENABLED(PIDTEMPBED)
     typedef struct PIDHeaterInfo<PID_t> bed_info_t;
   #else
     typedef heater_info_t bed_info_t;
   #endif
 #endif
-#if HAS_TEMP_PROBE
-  typedef temp_info_t probe_info_t;
-#endif
 #if HAS_HEATED_CHAMBER
   #if ENABLED(PIDTEMPCHAMBER)
     typedef struct PIDHeaterInfo<PID_t> chamber_info_t;
   #else
     typedef heater_info_t chamber_info_t;
   #endif
 #elif HAS_TEMP_CHAMBER
   typedef temp_info_t chamber_info_t;
 #endif
-#if HAS_TEMP_BOARD
-  typedef temp_info_t board_info_t;
+#if HAS_TEMP_PROBE
+  typedef temp_info_t probe_info_t;
 #endif
 #if EITHER(HAS_COOLER, HAS_TEMP_COOLER)
   typedef heater_info_t cooler_info_t;
 #endif
+#if HAS_TEMP_BOARD
+  typedef temp_info_t board_info_t;
+#endif
 
 // Heater watch handling
 template <int INCREASE, int HYSTERESIS, millis_t PERIOD>
 struct HeaterWatch {
   celsius_t target;
   millis_t next_ms;
   inline bool elapsed(const millis_t &ms) { return next_ms && ELAPSED(ms, next_ms); }
   inline bool elapsed() { return elapsed(millis()); }
 
   inline bool check(const celsius_t curr) { return curr >= target; }
@@ -311,26 +311,26 @@ typedef struct { int16_t raw_min, raw_max; celsius_t mintemp, maxtemp; } temp_ra
     #endif
     #if TEMP_SENSOR_4_IS_CUSTOM
       CTI_HOTEND_4,
     #endif
     #if TEMP_SENSOR_5_IS_CUSTOM
       CTI_HOTEND_5,
     #endif
     #if TEMP_SENSOR_BED_IS_CUSTOM
       CTI_BED,
     #endif
-    #if TEMP_SENSOR_PROBE_IS_CUSTOM
-      CTI_PROBE,
-    #endif
     #if TEMP_SENSOR_CHAMBER_IS_CUSTOM
       CTI_CHAMBER,
     #endif
+    #if TEMP_SENSOR_PROBE_IS_CUSTOM
+      CTI_PROBE,
+    #endif
     #if TEMP_SENSOR_COOLER_IS_CUSTOM
       CTI_COOLER,
     #endif
     #if TEMP_SENSOR_BOARD_IS_CUSTOM
       CTI_BOARD,
     #endif
     #if TEMP_SENSOR_REDUNDANT_IS_CUSTOM
       CTI_REDUNDANT,
     #endif
     USER_THERMISTORS
@@ -592,26 +592,26 @@ class Temperature {
         return true;
       }
     #endif
 
     #if HAS_HOTEND
       static celsius_float_t analog_to_celsius_hotend(const int16_t raw, const uint8_t e);
     #endif
     #if HAS_HEATED_BED
       static celsius_float_t analog_to_celsius_bed(const int16_t raw);
     #endif
-    #if HAS_TEMP_PROBE
-      static celsius_float_t analog_to_celsius_probe(const int16_t raw);
-    #endif
     #if HAS_TEMP_CHAMBER
       static celsius_float_t analog_to_celsius_chamber(const int16_t raw);
     #endif
+    #if HAS_TEMP_PROBE
+      static celsius_float_t analog_to_celsius_probe(const int16_t raw);
+    #endif
     #if HAS_TEMP_COOLER
       static celsius_float_t analog_to_celsius_cooler(const int16_t raw);
     #endif
     #if HAS_TEMP_BOARD
       static celsius_float_t analog_to_celsius_board(const int16_t raw);
     #endif
     #if HAS_TEMP_REDUNDANT
       static celsius_float_t analog_to_celsius_redundant(const int16_t raw);
     #endif
 

commit 3d79b55c15d26c4181b66d831fca457fb167bc7f
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Thu Jan 13 04:57:36 2022 +1300

    üöëÔ∏è Fix M105 regression (#23505)
    
    Fixes #23504

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 089694ab4a..5affcf740d 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -49,21 +49,22 @@
 #define E_NAME TERN_(HAS_MULTI_HOTEND, e)
 
 // Element identifiers. Positive values are hotends. Negative values are other heaters or coolers.
 typedef enum : int8_t {
   H_REDUNDANT = HID_REDUNDANT,
   H_COOLER = HID_COOLER,
   H_PROBE = HID_PROBE,
   H_BOARD = HID_BOARD,
   H_CHAMBER = HID_CHAMBER,
   H_BED = HID_BED,
-  H_E0 = HID_E0, H_E1, H_E2, H_E3, H_E4, H_E5, H_E6, H_E7
+  H_E0 = HID_E0, H_E1, H_E2, H_E3, H_E4, H_E5, H_E6, H_E7,
+  H_NONE = -128
 } heater_id_t;
 
 // PID storage
 typedef struct { float Kp, Ki, Kd;     } PID_t;
 typedef struct { float Kp, Ki, Kd, Kc; } PIDC_t;
 typedef struct { float Kp, Ki, Kd, Kf; } PIDF_t;
 typedef struct { float Kp, Ki, Kd, Kc, Kf; } PIDCF_t;
 
 typedef
   #if BOTH(PID_EXTRUSION_SCALING, PID_FAN_SCALING)

commit 9a194826e3e424e404e95443976f1bdfb1d2b245
Author: John Lagonikas <39417467+zeleps@users.noreply.github.com>
Date:   Mon Jan 3 18:11:39 2022 +0200

    ‚ú® M81 D / S - Power-off Delay (#23396)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index e3515f0db8..089694ab4a 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -986,21 +986,26 @@ class Temperature {
       #define MAX_TC_COUNT COUNT_ENABLED(TEMP_SENSOR_0_IS_MAX_TC, TEMP_SENSOR_1_IS_MAX_TC, TEMP_SENSOR_REDUNDANT_IS_MAX_TC)
       #if MAX_TC_COUNT > 1
         #define HAS_MULTI_MAX_TC 1
         #define READ_MAX_TC(N) read_max_tc(N)
       #else
         #define READ_MAX_TC(N) read_max_tc()
       #endif
       static int16_t read_max_tc(TERN_(HAS_MULTI_MAX_TC, const uint8_t hindex=0));
     #endif
 
-    static void update_autofans();
+    #if HAS_AUTO_FAN
+      #if ENABLED(POWER_OFF_WAIT_FOR_COOLDOWN)
+        static bool autofans_on;
+      #endif
+      static void update_autofans();
+    #endif
 
     #if HAS_HOTEND
       static float get_pid_output_hotend(const uint8_t e);
     #endif
     #if ENABLED(PIDTEMPBED)
       static float get_pid_output_bed();
     #endif
     #if ENABLED(PIDTEMPCHAMBER)
       static float get_pid_output_chamber();
     #endif

commit 63f71d85f2af5c9a352a4fca9b3c1acb1a5f4746
Author: John Lagonikas <39417467+zeleps@users.noreply.github.com>
Date:   Sun Jan 2 02:18:07 2022 +0200

    ‚ú® Temperature variance monitor (#23373)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 5661668204..e3515f0db8 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -1028,25 +1028,31 @@ class Temperature {
       };
 
       // Convert the given heater_id_t to runaway state array index
       static RunawayIndex runaway_index_for_id(const int8_t heater_id) {
         TERN_(THERMAL_PROTECTION_CHAMBER, if (heater_id == H_CHAMBER) return RUNAWAY_IND_CHAMBER);
         TERN_(THERMAL_PROTECTION_COOLER,  if (heater_id == H_COOLER)  return RUNAWAY_IND_COOLER);
         TERN_(THERMAL_PROTECTION_BED,     if (heater_id == H_BED)     return RUNAWAY_IND_BED);
         return (RunawayIndex)_MAX(heater_id, 0);
       }
 
-      enum TRState : char { TRInactive, TRFirstHeating, TRStable, TRRunaway };
+      enum TRState : char { TRInactive, TRFirstHeating, TRStable, TRRunaway
+        OPTARG(THERMAL_PROTECTION_VARIANCE_MONITOR, TRMalfunction)
+      };
 
       typedef struct {
         millis_t timer = 0;
         TRState state = TRInactive;
         float running_temp;
+        #if ENABLED(THERMAL_PROTECTION_VARIANCE_MONITOR)
+          millis_t variance_timer = 0;
+          celsius_float_t last_temp = 0.0, variance = 0.0;
+        #endif
         void run(const_celsius_float_t current, const_celsius_float_t target, const heater_id_t heater_id, const uint16_t period_seconds, const celsius_t hysteresis_degc);
       } tr_state_machine_t;
 
       static tr_state_machine_t tr_state_machine[NR_HEATER_RUNAWAY];
 
     #endif // HAS_THERMAL_PROTECTION
 };
 
 extern Temperature thermalManager;

commit b07887687ed96645b3e67ae2586c8198575a3e5d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Dec 31 07:42:07 2021 -0600

    üöëÔ∏è Fix thermal conditionals, structure

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 1ca0f3e88c..5661668204 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -1002,43 +1002,43 @@ class Temperature {
       static float get_pid_output_bed();
     #endif
     #if ENABLED(PIDTEMPCHAMBER)
       static float get_pid_output_chamber();
     #endif
 
     static void _temp_error(const heater_id_t e, FSTR_P const serial_msg, FSTR_P const lcd_msg);
     static void min_temp_error(const heater_id_t e);
     static void max_temp_error(const heater_id_t e);
 
-    #define HAS_THERMAL_PROTECTION ANY(THERMAL_PROTECTION_HOTENDS, THERMAL_PROTECTION_CHAMBER, HAS_THERMALLY_PROTECTED_BED, THERMAL_PROTECTION_COOLER)
+    #define HAS_THERMAL_PROTECTION ANY(THERMAL_PROTECTION_HOTENDS, THERMAL_PROTECTION_CHAMBER, THERMAL_PROTECTION_BED, THERMAL_PROTECTION_COOLER)
 
     #if HAS_THERMAL_PROTECTION
 
       // Indices and size for the tr_state_machine array. One for each protected heater.
       enum RunawayIndex : int8_t {
         _RI = -1
         #if ENABLED(THERMAL_PROTECTION_HOTENDS)
           #define _RUNAWAY_IND_E(N) ,RUNAWAY_IND_E##N
           REPEAT(HOTENDS, _RUNAWAY_IND_E)
           #undef _RUNAWAY_IND_E
         #endif
-        OPTARG(HAS_THERMALLY_PROTECTED_BED, RUNAWAY_IND_BED)
+        OPTARG(THERMAL_PROTECTION_BED, RUNAWAY_IND_BED)
         OPTARG(THERMAL_PROTECTION_CHAMBER, RUNAWAY_IND_CHAMBER)
         OPTARG(THERMAL_PROTECTION_COOLER, RUNAWAY_IND_COOLER)
         , NR_HEATER_RUNAWAY
       };
 
       // Convert the given heater_id_t to runaway state array index
       static RunawayIndex runaway_index_for_id(const int8_t heater_id) {
-        TERN_(HAS_THERMALLY_PROTECTED_CHAMBER, if (heater_id == H_CHAMBER) return RUNAWAY_IND_CHAMBER);
-        TERN_(HAS_THERMALLY_PROTECTED_CHAMBER, if (heater_id == H_COOLER)  return RUNAWAY_IND_COOLER);
-        TERN_(HAS_THERMALLY_PROTECTED_BED,     if (heater_id == H_BED)     return RUNAWAY_IND_BED);
+        TERN_(THERMAL_PROTECTION_CHAMBER, if (heater_id == H_CHAMBER) return RUNAWAY_IND_CHAMBER);
+        TERN_(THERMAL_PROTECTION_COOLER,  if (heater_id == H_COOLER)  return RUNAWAY_IND_COOLER);
+        TERN_(THERMAL_PROTECTION_BED,     if (heater_id == H_BED)     return RUNAWAY_IND_BED);
         return (RunawayIndex)_MAX(heater_id, 0);
       }
 
       enum TRState : char { TRInactive, TRFirstHeating, TRStable, TRRunaway };
 
       typedef struct {
         millis_t timer = 0;
         TRState state = TRInactive;
         float running_temp;
         void run(const_celsius_float_t current, const_celsius_float_t target, const heater_id_t heater_id, const uint16_t period_seconds, const celsius_t hysteresis_degc);

commit 6fb2d8a25f096d084348a6f6930f515d947474d4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Dec 28 02:57:24 2021 -0600

    üßë‚Äçüíª Remove extraneous 'inline' hints

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 0e4302938e..1ca0f3e88c 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -352,21 +352,21 @@ typedef struct { int16_t raw_min, raw_max; celsius_t mintemp, maxtemp; } temp_ra
   #define HAS_FAN_LOGIC 1
 #endif
 
 class Temperature {
 
   public:
 
     #if HAS_HOTEND
       static hotend_info_t temp_hotend[HOTENDS];
       static const celsius_t hotend_maxtemp[HOTENDS];
-      static inline celsius_t hotend_max_target(const uint8_t e) { return hotend_maxtemp[e] - (HOTEND_OVERSHOOT); }
+      static celsius_t hotend_max_target(const uint8_t e) { return hotend_maxtemp[e] - (HOTEND_OVERSHOOT); }
     #endif
     #if HAS_HEATED_BED
       static bed_info_t temp_bed;
     #endif
     #if HAS_TEMP_PROBE
       static probe_info_t temp_probe;
     #endif
     #if HAS_TEMP_CHAMBER
       static chamber_info_t temp_chamber;
     #endif
@@ -395,30 +395,30 @@ class Temperature {
                      soft_pwm_count_fan[FAN_COUNT];
     #endif
 
     #if BOTH(FAN_SOFT_PWM, USE_CONTROLLER_FAN)
       static uint8_t soft_pwm_controller_speed;
     #endif
 
     #if ENABLED(PREVENT_COLD_EXTRUSION)
       static bool allow_cold_extrude;
       static celsius_t extrude_min_temp;
-      static inline bool tooCold(const celsius_t temp) { return allow_cold_extrude ? false : temp < extrude_min_temp - (TEMP_WINDOW); }
-      static inline bool tooColdToExtrude(const uint8_t E_NAME)       { return tooCold(wholeDegHotend(HOTEND_INDEX)); }
-      static inline bool targetTooColdToExtrude(const uint8_t E_NAME) { return tooCold(degTargetHotend(HOTEND_INDEX)); }
+      static bool tooCold(const celsius_t temp) { return allow_cold_extrude ? false : temp < extrude_min_temp - (TEMP_WINDOW); }
+      static bool tooColdToExtrude(const uint8_t E_NAME)       { return tooCold(wholeDegHotend(HOTEND_INDEX)); }
+      static bool targetTooColdToExtrude(const uint8_t E_NAME) { return tooCold(degTargetHotend(HOTEND_INDEX)); }
     #else
-      static inline bool tooColdToExtrude(const uint8_t) { return false; }
-      static inline bool targetTooColdToExtrude(const uint8_t) { return false; }
+      static bool tooColdToExtrude(const uint8_t) { return false; }
+      static bool targetTooColdToExtrude(const uint8_t) { return false; }
     #endif
 
-    static inline bool hotEnoughToExtrude(const uint8_t e) { return !tooColdToExtrude(e); }
-    static inline bool targetHotEnoughToExtrude(const uint8_t e) { return !targetTooColdToExtrude(e); }
+    static bool hotEnoughToExtrude(const uint8_t e) { return !tooColdToExtrude(e); }
+    static bool targetHotEnoughToExtrude(const uint8_t e) { return !targetTooColdToExtrude(e); }
 
     #if EITHER(SINGLENOZZLE_STANDBY_TEMP, SINGLENOZZLE_STANDBY_FAN)
       #if ENABLED(SINGLENOZZLE_STANDBY_TEMP)
         static celsius_t singlenozzle_temp[EXTRUDERS];
       #endif
       #if ENABLED(SINGLENOZZLE_STANDBY_FAN)
         static uint8_t singlenozzle_fan_speed[EXTRUDERS];
       #endif
       static void singlenozzle_change(const uint8_t old_tool, const uint8_t new_tool);
     #endif
@@ -442,21 +442,21 @@ class Temperature {
         #define _IDLE_INDEX_E(N) ,IDLE_INDEX_E##N
         REPEAT(HOTENDS, _IDLE_INDEX_E)
         #undef _IDLE_INDEX_E
 
         OPTARG(HAS_HEATED_BED, IDLE_INDEX_BED)
 
         , NR_HEATER_IDLE
       };
 
       // Convert the given heater_id_t to idle array index
-      static inline IdleIndex idle_index_for_id(const int8_t heater_id) {
+      static IdleIndex idle_index_for_id(const int8_t heater_id) {
         TERN_(HAS_HEATED_BED, if (heater_id == H_BED) return IDLE_INDEX_BED);
         return (IdleIndex)_MAX(heater_id, 0);
       }
 
       static heater_idle_t heater_idle[NR_HEATER_IDLE];
 
     #endif // HEATER_IDLE_TIMER
 
     #if HAS_ADC_BUTTONS
       static uint32_t current_ADCKey_raw;
@@ -518,21 +518,21 @@ class Temperature {
       static uint8_t consecutive_low_temperature_error[HOTENDS];
     #endif
 
     #if MILLISECONDS_PREHEAT_TIME > 0
       static millis_t preheat_end_time[HOTENDS];
     #endif
 
     #if HAS_FAN_LOGIC
       static millis_t fan_update_ms;
 
-      static inline void manage_extruder_fans(millis_t ms) {
+      static void manage_extruder_fans(millis_t ms) {
         if (ELAPSED(ms, fan_update_ms)) { // only need to check fan state very infrequently
           const millis_t next_ms = ms + fan_update_interval_ms;
           #if HAS_PWMFANCHECK
             #define FAN_CHECK_DURATION 100
             if (fan_check.is_measuring()) {
               fan_check.compute_speed(ms + FAN_CHECK_DURATION - fan_update_ms);
               fan_update_ms = next_ms;
             }
             else
               fan_update_ms = ms + FAN_CHECK_DURATION;
@@ -559,39 +559,39 @@ class Temperature {
 
     /**
      * Static (class) methods
      */
 
     #if HAS_USER_THERMISTORS
       static user_thermistor_t user_thermistor[USER_THERMISTORS];
       static void M305_report(const uint8_t t_index, const bool forReplay=true);
       static void reset_user_thermistors();
       static celsius_float_t user_thermistor_to_deg_c(const uint8_t t_index, const int16_t raw);
-      static inline bool set_pull_up_res(int8_t t_index, float value) {
+      static bool set_pull_up_res(int8_t t_index, float value) {
         //if (!WITHIN(t_index, 0, USER_THERMISTORS - 1)) return false;
         if (!WITHIN(value, 1, 1000000)) return false;
         user_thermistor[t_index].series_res = value;
         return true;
       }
-      static inline bool set_res25(int8_t t_index, float value) {
+      static bool set_res25(int8_t t_index, float value) {
         if (!WITHIN(value, 1, 10000000)) return false;
         user_thermistor[t_index].res_25 = value;
         user_thermistor[t_index].pre_calc = true;
         return true;
       }
-      static inline bool set_beta(int8_t t_index, float value) {
+      static bool set_beta(int8_t t_index, float value) {
         if (!WITHIN(value, 1, 1000000)) return false;
         user_thermistor[t_index].beta = value;
         user_thermistor[t_index].pre_calc = true;
         return true;
       }
-      static inline bool set_sh_coeff(int8_t t_index, float value) {
+      static bool set_sh_coeff(int8_t t_index, float value) {
         if (!WITHIN(value, -0.01f, 0.01f)) return false;
         user_thermistor[t_index].sh_c_coeff = value;
         user_thermistor[t_index].pre_calc = true;
         return true;
       }
     #endif
 
     #if HAS_HOTEND
       static celsius_float_t analog_to_celsius_hotend(const int16_t raw, const uint8_t e);
     #endif
@@ -627,274 +627,274 @@ class Temperature {
 
       #if EITHER(PROBING_FANS_OFF, ADVANCED_PAUSE_FANS_PAUSE)
         static bool fans_paused;
         static uint8_t saved_fan_speed[FAN_COUNT];
       #endif
 
       #if ENABLED(ADAPTIVE_FAN_SLOWING)
         static uint8_t fan_speed_scaler[FAN_COUNT];
       #endif
 
-      static inline uint8_t scaledFanSpeed(const uint8_t fan, const uint8_t fs) {
+      static uint8_t scaledFanSpeed(const uint8_t fan, const uint8_t fs) {
         UNUSED(fan); // Potentially unused!
         return (fs * uint16_t(TERN(ADAPTIVE_FAN_SLOWING, fan_speed_scaler[fan], 128))) >> 7;
       }
 
-      static inline uint8_t scaledFanSpeed(const uint8_t fan) {
+      static uint8_t scaledFanSpeed(const uint8_t fan) {
         return scaledFanSpeed(fan, fan_speed[fan]);
       }
 
       static constexpr inline uint8_t pwmToPercent(const uint8_t speed) { return ui8_to_percent(speed); }
-      static inline uint8_t fanSpeedPercent(const uint8_t fan)          { return ui8_to_percent(fan_speed[fan]); }
-      static inline uint8_t scaledFanSpeedPercent(const uint8_t fan)    { return ui8_to_percent(scaledFanSpeed(fan)); }
+      static uint8_t fanSpeedPercent(const uint8_t fan)          { return ui8_to_percent(fan_speed[fan]); }
+      static uint8_t scaledFanSpeedPercent(const uint8_t fan)    { return ui8_to_percent(scaledFanSpeed(fan)); }
 
       #if ENABLED(EXTRA_FAN_SPEED)
         typedef struct { uint8_t saved, speed; } extra_fan_t;
         static extra_fan_t extra_fan_speed[FAN_COUNT];
         static void set_temp_fan_speed(const uint8_t fan, const uint16_t command_or_speed);
       #endif
 
       #if EITHER(PROBING_FANS_OFF, ADVANCED_PAUSE_FANS_PAUSE)
         void set_fans_paused(const bool p);
       #endif
 
     #endif // HAS_FAN
 
-    static inline void zero_fan_speeds() {
+    static void zero_fan_speeds() {
       #if HAS_FAN
         FANS_LOOP(i) set_fan_speed(i, 0);
       #endif
     }
 
     /**
      * Called from the Temperature ISR
      */
     static void isr();
     static void readings_ready();
 
     /**
      * Call periodically to manage heaters
      */
     static void manage_heater() _O2; // Added _O2 to work around a compiler error
 
     /**
      * Preheating hotends
      */
     #if MILLISECONDS_PREHEAT_TIME > 0
-      static inline bool is_preheating(const uint8_t E_NAME) {
+      static bool is_preheating(const uint8_t E_NAME) {
         return preheat_end_time[HOTEND_INDEX] && PENDING(millis(), preheat_end_time[HOTEND_INDEX]);
       }
-      static inline void start_preheat_time(const uint8_t E_NAME) {
+      static void start_preheat_time(const uint8_t E_NAME) {
         preheat_end_time[HOTEND_INDEX] = millis() + MILLISECONDS_PREHEAT_TIME;
       }
-      static inline void reset_preheat_time(const uint8_t E_NAME) {
+      static void reset_preheat_time(const uint8_t E_NAME) {
         preheat_end_time[HOTEND_INDEX] = 0;
       }
     #else
       #define is_preheating(n) (false)
     #endif
 
     //high level conversion routines, for use outside of temperature.cpp
     //inline so that there is no performance decrease.
     //deg=degreeCelsius
 
-    static inline celsius_float_t degHotend(const uint8_t E_NAME) {
+    static celsius_float_t degHotend(const uint8_t E_NAME) {
       return TERN0(HAS_HOTEND, temp_hotend[HOTEND_INDEX].celsius);
     }
 
-    static inline celsius_t wholeDegHotend(const uint8_t E_NAME) {
+    static celsius_t wholeDegHotend(const uint8_t E_NAME) {
       return TERN0(HAS_HOTEND, static_cast<celsius_t>(temp_hotend[HOTEND_INDEX].celsius + 0.5f));
     }
 
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
-      static inline int16_t rawHotendTemp(const uint8_t E_NAME) {
+      static int16_t rawHotendTemp(const uint8_t E_NAME) {
         return TERN0(HAS_HOTEND, temp_hotend[HOTEND_INDEX].raw);
       }
     #endif
 
-    static inline celsius_t degTargetHotend(const uint8_t E_NAME) {
+    static celsius_t degTargetHotend(const uint8_t E_NAME) {
       return TERN0(HAS_HOTEND, temp_hotend[HOTEND_INDEX].target);
     }
 
     #if HAS_HOTEND
 
       static void setTargetHotend(const celsius_t celsius, const uint8_t E_NAME) {
         const uint8_t ee = HOTEND_INDEX;
         #if MILLISECONDS_PREHEAT_TIME > 0
           if (celsius == 0)
             reset_preheat_time(ee);
           else if (temp_hotend[ee].target == 0)
             start_preheat_time(ee);
         #endif
         TERN_(AUTO_POWER_CONTROL, if (celsius) powerManager.power_on());
         temp_hotend[ee].target = _MIN(celsius, hotend_max_target(ee));
         start_watching_hotend(ee);
       }
 
-      static inline bool isHeatingHotend(const uint8_t E_NAME) {
+      static bool isHeatingHotend(const uint8_t E_NAME) {
         return temp_hotend[HOTEND_INDEX].target > temp_hotend[HOTEND_INDEX].celsius;
       }
 
-      static inline bool isCoolingHotend(const uint8_t E_NAME) {
+      static bool isCoolingHotend(const uint8_t E_NAME) {
         return temp_hotend[HOTEND_INDEX].target < temp_hotend[HOTEND_INDEX].celsius;
       }
 
       #if HAS_TEMP_HOTEND
         static bool wait_for_hotend(const uint8_t target_extruder, const bool no_wait_for_cooling=true
           OPTARG(G26_CLICK_CAN_CANCEL, const bool click_to_cancel=false)
         );
 
         #if ENABLED(WAIT_FOR_HOTEND)
           static void wait_for_hotend_heating(const uint8_t target_extruder);
         #endif
       #endif
 
-      static inline bool still_heating(const uint8_t e) {
+      static bool still_heating(const uint8_t e) {
         return degTargetHotend(e) > TEMP_HYSTERESIS && ABS(wholeDegHotend(e) - degTargetHotend(e)) > TEMP_HYSTERESIS;
       }
 
-      static inline bool degHotendNear(const uint8_t e, const celsius_t temp) {
+      static bool degHotendNear(const uint8_t e, const celsius_t temp) {
         return ABS(wholeDegHotend(e) - temp) < (TEMP_HYSTERESIS);
       }
 
       // Start watching a Hotend to make sure it's really heating up
-      static inline void start_watching_hotend(const uint8_t E_NAME) {
+      static void start_watching_hotend(const uint8_t E_NAME) {
         UNUSED(HOTEND_INDEX);
         #if WATCH_HOTENDS
           watch_hotend[HOTEND_INDEX].restart(degHotend(HOTEND_INDEX), degTargetHotend(HOTEND_INDEX));
         #endif
       }
 
     #endif // HAS_HOTEND
 
     #if HAS_HEATED_BED
 
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
-        static inline int16_t rawBedTemp()    { return temp_bed.raw; }
+        static int16_t rawBedTemp()    { return temp_bed.raw; }
       #endif
-      static inline celsius_float_t degBed()  { return temp_bed.celsius; }
-      static inline celsius_t wholeDegBed()   { return static_cast<celsius_t>(degBed() + 0.5f); }
-      static inline celsius_t degTargetBed()  { return temp_bed.target; }
-      static inline bool isHeatingBed()       { return temp_bed.target > temp_bed.celsius; }
-      static inline bool isCoolingBed()       { return temp_bed.target < temp_bed.celsius; }
+      static celsius_float_t degBed()  { return temp_bed.celsius; }
+      static celsius_t wholeDegBed()   { return static_cast<celsius_t>(degBed() + 0.5f); }
+      static celsius_t degTargetBed()  { return temp_bed.target; }
+      static bool isHeatingBed()       { return temp_bed.target > temp_bed.celsius; }
+      static bool isCoolingBed()       { return temp_bed.target < temp_bed.celsius; }
 
       // Start watching the Bed to make sure it's really heating up
-      static inline void start_watching_bed() { TERN_(WATCH_BED, watch_bed.restart(degBed(), degTargetBed())); }
+      static void start_watching_bed() { TERN_(WATCH_BED, watch_bed.restart(degBed(), degTargetBed())); }
 
       static void setTargetBed(const celsius_t celsius) {
         TERN_(AUTO_POWER_CONTROL, if (celsius) powerManager.power_on());
         temp_bed.target = _MIN(celsius, BED_MAX_TARGET);
         start_watching_bed();
       }
 
       static bool wait_for_bed(const bool no_wait_for_cooling=true
         OPTARG(G26_CLICK_CAN_CANCEL, const bool click_to_cancel=false)
       );
 
       static void wait_for_bed_heating();
 
-      static inline bool degBedNear(const celsius_t temp) {
+      static bool degBedNear(const celsius_t temp) {
         return ABS(wholeDegBed() - temp) < (TEMP_BED_HYSTERESIS);
       }
 
     #endif // HAS_HEATED_BED
 
     #if HAS_TEMP_PROBE
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
-        static inline int16_t rawProbeTemp()    { return temp_probe.raw; }
+        static int16_t rawProbeTemp()    { return temp_probe.raw; }
       #endif
-      static inline celsius_float_t degProbe()  { return temp_probe.celsius; }
-      static inline celsius_t wholeDegProbe()   { return static_cast<celsius_t>(degProbe() + 0.5f); }
-      static inline bool isProbeBelowTemp(const celsius_t target_temp) { return wholeDegProbe() < target_temp; }
-      static inline bool isProbeAboveTemp(const celsius_t target_temp) { return wholeDegProbe() > target_temp; }
+      static celsius_float_t degProbe()  { return temp_probe.celsius; }
+      static celsius_t wholeDegProbe()   { return static_cast<celsius_t>(degProbe() + 0.5f); }
+      static bool isProbeBelowTemp(const celsius_t target_temp) { return wholeDegProbe() < target_temp; }
+      static bool isProbeAboveTemp(const celsius_t target_temp) { return wholeDegProbe() > target_temp; }
       static bool wait_for_probe(const celsius_t target_temp, bool no_wait_for_cooling=true);
     #endif
 
     #if HAS_TEMP_CHAMBER
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
-        static inline int16_t rawChamberTemp()      { return temp_chamber.raw; }
+        static int16_t rawChamberTemp()      { return temp_chamber.raw; }
       #endif
-      static inline celsius_float_t degChamber()    { return temp_chamber.celsius; }
-      static inline celsius_t wholeDegChamber()     { return static_cast<celsius_t>(degChamber() + 0.5f); }
+      static celsius_float_t degChamber()    { return temp_chamber.celsius; }
+      static celsius_t wholeDegChamber()     { return static_cast<celsius_t>(degChamber() + 0.5f); }
       #if HAS_HEATED_CHAMBER
-        static inline celsius_t degTargetChamber()  { return temp_chamber.target; }
-        static inline bool isHeatingChamber()       { return temp_chamber.target > temp_chamber.celsius; }
-        static inline bool isCoolingChamber()       { return temp_chamber.target < temp_chamber.celsius; }
+        static celsius_t degTargetChamber()  { return temp_chamber.target; }
+        static bool isHeatingChamber()       { return temp_chamber.target > temp_chamber.celsius; }
+        static bool isCoolingChamber()       { return temp_chamber.target < temp_chamber.celsius; }
         static bool wait_for_chamber(const bool no_wait_for_cooling=true);
       #endif
     #endif
 
     #if HAS_HEATED_CHAMBER
       static void setTargetChamber(const celsius_t celsius) {
         temp_chamber.target = _MIN(celsius, CHAMBER_MAX_TARGET);
         start_watching_chamber();
       }
       // Start watching the Chamber to make sure it's really heating up
-      static inline void start_watching_chamber() { TERN_(WATCH_CHAMBER, watch_chamber.restart(degChamber(), degTargetChamber())); }
+      static void start_watching_chamber() { TERN_(WATCH_CHAMBER, watch_chamber.restart(degChamber(), degTargetChamber())); }
     #endif
 
     #if HAS_TEMP_COOLER
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
-        static inline int16_t rawCoolerTemp()     { return temp_cooler.raw; }
+        static int16_t rawCoolerTemp()     { return temp_cooler.raw; }
       #endif
-      static inline celsius_float_t degCooler()   { return temp_cooler.celsius; }
-      static inline celsius_t wholeDegCooler()    { return static_cast<celsius_t>(temp_cooler.celsius + 0.5f); }
+      static celsius_float_t degCooler()   { return temp_cooler.celsius; }
+      static celsius_t wholeDegCooler()    { return static_cast<celsius_t>(temp_cooler.celsius + 0.5f); }
       #if HAS_COOLER
-        static inline celsius_t degTargetCooler() { return temp_cooler.target; }
-        static inline bool isLaserHeating()       { return temp_cooler.target > temp_cooler.celsius; }
-        static inline bool isLaserCooling()       { return temp_cooler.target < temp_cooler.celsius; }
+        static celsius_t degTargetCooler() { return temp_cooler.target; }
+        static bool isLaserHeating()       { return temp_cooler.target > temp_cooler.celsius; }
+        static bool isLaserCooling()       { return temp_cooler.target < temp_cooler.celsius; }
         static bool wait_for_cooler(const bool no_wait_for_cooling=true);
       #endif
     #endif
 
     #if HAS_TEMP_BOARD
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
-        static inline int16_t rawBoardTemp()    { return temp_board.raw; }
+        static int16_t rawBoardTemp()    { return temp_board.raw; }
       #endif
-      static inline celsius_float_t degBoard()  { return temp_board.celsius; }
-      static inline celsius_t wholeDegBoard()   { return static_cast<celsius_t>(temp_board.celsius + 0.5f); }
+      static celsius_float_t degBoard()  { return temp_board.celsius; }
+      static celsius_t wholeDegBoard()   { return static_cast<celsius_t>(temp_board.celsius + 0.5f); }
     #endif
 
     #if HAS_TEMP_REDUNDANT
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
-        static inline int16_t rawRedundantTemp()         { return temp_redundant.raw; }
-        static inline int16_t rawRedundanTargetTemp()    { return (*temp_redundant.target).raw; }
+        static int16_t rawRedundantTemp()         { return temp_redundant.raw; }
+        static int16_t rawRedundanTargetTemp()    { return (*temp_redundant.target).raw; }
       #endif
-      static inline celsius_float_t degRedundant()       { return temp_redundant.celsius; }
-      static inline celsius_float_t degRedundantTarget() { return (*temp_redundant.target).celsius; }
-      static inline celsius_t wholeDegRedundant()        { return static_cast<celsius_t>(temp_redundant.celsius + 0.5f); }
-      static inline celsius_t wholeDegRedundantTarget()  { return static_cast<celsius_t>((*temp_redundant.target).celsius + 0.5f); }
+      static celsius_float_t degRedundant()       { return temp_redundant.celsius; }
+      static celsius_float_t degRedundantTarget() { return (*temp_redundant.target).celsius; }
+      static celsius_t wholeDegRedundant()        { return static_cast<celsius_t>(temp_redundant.celsius + 0.5f); }
+      static celsius_t wholeDegRedundantTarget()  { return static_cast<celsius_t>((*temp_redundant.target).celsius + 0.5f); }
     #endif
 
     #if HAS_COOLER
-      static inline void setTargetCooler(const celsius_t celsius) {
+      static void setTargetCooler(const celsius_t celsius) {
         temp_cooler.target = constrain(celsius, COOLER_MIN_TARGET, COOLER_MAX_TARGET);
         start_watching_cooler();
       }
       // Start watching the Cooler to make sure it's really cooling down
-      static inline void start_watching_cooler() { TERN_(WATCH_COOLER, watch_cooler.restart(degCooler(), degTargetCooler())); }
+      static void start_watching_cooler() { TERN_(WATCH_COOLER, watch_cooler.restart(degCooler(), degTargetCooler())); }
     #endif
 
     /**
      * The software PWM power for a heater
      */
     static int16_t getHeaterPower(const heater_id_t heater_id);
 
     /**
      * Switch off all heaters, set all target temperatures to 0
      */
     static void disable_all_heaters();
 
     /**
      * Cooldown, as from the LCD. Disables all heaters and fans.
      */
-    static inline void cooldown() {
+    static void cooldown() {
       zero_fan_speeds();
       disable_all_heaters();
     }
 
     #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
       /**
        * Methods to check if heaters are enabled, indicating an active job
        */
       static bool auto_job_over_threshold();
       static void auto_job_check_timer(const bool can_start, const bool can_stop);
@@ -914,74 +914,74 @@ class Temperature {
       #if ENABLED(NO_FAN_SLOWING_IN_PID_TUNING)
         static bool adaptive_fan_slowing;
       #elif ENABLED(ADAPTIVE_FAN_SLOWING)
         static constexpr bool adaptive_fan_slowing = true;
       #endif
 
       /**
        * Update the temp manager when PID values change
        */
       #if ENABLED(PIDTEMP)
-        static inline void updatePID() {
+        static void updatePID() {
           TERN_(PID_EXTRUSION_SCALING, last_e_position = 0);
         }
       #endif
 
     #endif
 
     #if ENABLED(PROBING_HEATERS_OFF)
       static void pause_heaters(const bool p);
     #endif
 
     #if HEATER_IDLE_HANDLER
 
-      static inline void reset_hotend_idle_timer(const uint8_t E_NAME) {
+      static void reset_hotend_idle_timer(const uint8_t E_NAME) {
         heater_idle[HOTEND_INDEX].reset();
         start_watching_hotend(HOTEND_INDEX);
       }
 
       #if HAS_HEATED_BED
-        static inline void reset_bed_idle_timer() {
+        static void reset_bed_idle_timer() {
           heater_idle[IDLE_INDEX_BED].reset();
           start_watching_bed();
         }
       #endif
 
     #endif // HEATER_IDLE_HANDLER
 
     #if HAS_TEMP_SENSOR
       static void print_heater_states(const uint8_t target_extruder
         OPTARG(HAS_TEMP_REDUNDANT, const bool include_r=false)
       );
       #if ENABLED(AUTO_REPORT_TEMPERATURES)
         struct AutoReportTemp { static void report(); };
         static AutoReporter<AutoReportTemp> auto_reporter;
       #endif
     #endif
 
     #if HAS_HOTEND && HAS_STATUS_MESSAGE
       static void set_heating_message(const uint8_t e);
     #else
-      static inline void set_heating_message(const uint8_t) {}
+      static void set_heating_message(const uint8_t) {}
     #endif
 
     #if HAS_LCD_MENU && HAS_TEMPERATURE
       static void lcd_preheat(const uint8_t e, const int8_t indh, const int8_t indb);
     #endif
 
   private:
 
     // Reading raw temperatures and converting to Celsius when ready
     static volatile bool raw_temps_ready;
     static void update_raw_temperatures();
     static void updateTemperaturesFromRawValues();
-    static inline bool updateTemperaturesIfReady() {
+    static bool updateTemperaturesIfReady() {
       if (!raw_temps_ready) return false;
       updateTemperaturesFromRawValues();
       raw_temps_ready = false;
       return true;
     }
 
     // MAX Thermocouples
     #if HAS_MAX_TC
       #define MAX_TC_COUNT COUNT_ENABLED(TEMP_SENSOR_0_IS_MAX_TC, TEMP_SENSOR_1_IS_MAX_TC, TEMP_SENSOR_REDUNDANT_IS_MAX_TC)
       #if MAX_TC_COUNT > 1
@@ -1021,21 +1021,21 @@ class Temperature {
           REPEAT(HOTENDS, _RUNAWAY_IND_E)
           #undef _RUNAWAY_IND_E
         #endif
         OPTARG(HAS_THERMALLY_PROTECTED_BED, RUNAWAY_IND_BED)
         OPTARG(THERMAL_PROTECTION_CHAMBER, RUNAWAY_IND_CHAMBER)
         OPTARG(THERMAL_PROTECTION_COOLER, RUNAWAY_IND_COOLER)
         , NR_HEATER_RUNAWAY
       };
 
       // Convert the given heater_id_t to runaway state array index
-      static inline RunawayIndex runaway_index_for_id(const int8_t heater_id) {
+      static RunawayIndex runaway_index_for_id(const int8_t heater_id) {
         TERN_(HAS_THERMALLY_PROTECTED_CHAMBER, if (heater_id == H_CHAMBER) return RUNAWAY_IND_CHAMBER);
         TERN_(HAS_THERMALLY_PROTECTED_CHAMBER, if (heater_id == H_COOLER)  return RUNAWAY_IND_COOLER);
         TERN_(HAS_THERMALLY_PROTECTED_BED,     if (heater_id == H_BED)     return RUNAWAY_IND_BED);
         return (RunawayIndex)_MAX(heater_id, 0);
       }
 
       enum TRState : char { TRInactive, TRFirstHeating, TRStable, TRRunaway };
 
       typedef struct {
         millis_t timer = 0;

commit 7110d11c9d8933c8c412c2fabd3b065a5ab97b6e
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Tue Nov 23 21:01:53 2021 +0100

    ‚ú® Fan tachometer support (#23086)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 050b3379e9..0e4302938e 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -30,20 +30,24 @@
 #include "../inc/MarlinConfig.h"
 
 #if ENABLED(AUTO_POWER_CONTROL)
   #include "../feature/power.h"
 #endif
 
 #if ENABLED(AUTO_REPORT_TEMPERATURES)
   #include "../libs/autoreport.h"
 #endif
 
+#if HAS_FANCHECK
+  #include "../feature/fancheck.h"
+#endif
+
 #ifndef SOFT_PWM_SCALE
   #define SOFT_PWM_SCALE 0
 #endif
 
 #define HOTEND_INDEX TERN(HAS_MULTI_HOTEND, e, 0)
 #define E_NAME TERN_(HAS_MULTI_HOTEND, e)
 
 // Element identifiers. Positive values are hotends. Negative values are other heaters or coolers.
 typedef enum : int8_t {
   H_REDUNDANT = HID_REDUNDANT,
@@ -337,20 +341,24 @@ typedef struct { int16_t raw_min, raw_max; celsius_t mintemp, maxtemp; } temp_ra
     float sh_c_coeff,  // Steinhart-Hart C coefficient .. defaults to '0.0'
           sh_alpha,
           series_res,
           res_25, res_25_recip,
           res_25_log,
           beta, beta_recip;
   } user_thermistor_t;
 
 #endif
 
+#if HAS_AUTO_FAN || HAS_FANCHECK
+  #define HAS_FAN_LOGIC 1
+#endif
+
 class Temperature {
 
   public:
 
     #if HAS_HOTEND
       static hotend_info_t temp_hotend[HOTENDS];
       static const celsius_t hotend_maxtemp[HOTENDS];
       static inline celsius_t hotend_max_target(const uint8_t e) { return hotend_maxtemp[e] - (HOTEND_OVERSHOOT); }
     #endif
     #if HAS_HEATED_BED
@@ -365,21 +373,21 @@ class Temperature {
     #if HAS_TEMP_COOLER
       static cooler_info_t temp_cooler;
     #endif
     #if HAS_TEMP_BOARD
       static board_info_t temp_board;
     #endif
     #if HAS_TEMP_REDUNDANT
       static redundant_info_t temp_redundant;
     #endif
 
-    #if ENABLED(AUTO_POWER_E_FANS)
+    #if EITHER(AUTO_POWER_E_FANS, HAS_FANCHECK)
       static uint8_t autofan_speed[HOTENDS];
     #endif
     #if ENABLED(AUTO_POWER_CHAMBER_FAN)
       static uint8_t chamberfan_speed;
     #endif
     #if ENABLED(AUTO_POWER_COOLER_FAN)
       static uint8_t coolerfan_speed;
     #endif
 
     #if ENABLED(FAN_SOFT_PWM)
@@ -452,20 +460,24 @@ class Temperature {
 
     #if HAS_ADC_BUTTONS
       static uint32_t current_ADCKey_raw;
       static uint16_t ADCKey_count;
     #endif
 
     #if ENABLED(PID_EXTRUSION_SCALING)
       static int16_t lpq_len;
     #endif
 
+    #if HAS_FAN_LOGIC
+      static constexpr millis_t fan_update_interval_ms = TERN(HAS_PWMFANCHECK, 5000, TERN(HAS_FANCHECK, 1000, 2500));
+    #endif
+
   private:
 
     #if ENABLED(WATCH_HOTENDS)
       static hotend_watch_t watch_hotend[HOTENDS];
     #endif
 
     #if ENABLED(PID_EXTRUSION_SCALING)
       static int32_t last_e_position, lpq[LPQ_MAX_LEN];
       static lpq_ptr_t lpq_ptr;
     #endif
@@ -503,22 +515,42 @@ class Temperature {
     #endif
 
     #if MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED > 1
       static uint8_t consecutive_low_temperature_error[HOTENDS];
     #endif
 
     #if MILLISECONDS_PREHEAT_TIME > 0
       static millis_t preheat_end_time[HOTENDS];
     #endif
 
-    #if HAS_AUTO_FAN
-      static millis_t next_auto_fan_check_ms;
+    #if HAS_FAN_LOGIC
+      static millis_t fan_update_ms;
+
+      static inline void manage_extruder_fans(millis_t ms) {
+        if (ELAPSED(ms, fan_update_ms)) { // only need to check fan state very infrequently
+          const millis_t next_ms = ms + fan_update_interval_ms;
+          #if HAS_PWMFANCHECK
+            #define FAN_CHECK_DURATION 100
+            if (fan_check.is_measuring()) {
+              fan_check.compute_speed(ms + FAN_CHECK_DURATION - fan_update_ms);
+              fan_update_ms = next_ms;
+            }
+            else
+              fan_update_ms = ms + FAN_CHECK_DURATION;
+            fan_check.toggle_measuring();
+          #else
+            TERN_(HAS_FANCHECK, fan_check.compute_speed(next_ms - fan_update_ms));
+            fan_update_ms = next_ms;
+          #endif
+          TERN_(HAS_AUTO_FAN, update_autofans()); // Needed as last when HAS_PWMFANCHECK to properly force fan speed
+        }
+      }
     #endif
 
     #if ENABLED(PROBING_HEATERS_OFF)
       static bool paused_for_probing;
     #endif
 
   public:
     /**
      * Instance Methods
      */
@@ -954,21 +986,21 @@ class Temperature {
       #define MAX_TC_COUNT COUNT_ENABLED(TEMP_SENSOR_0_IS_MAX_TC, TEMP_SENSOR_1_IS_MAX_TC, TEMP_SENSOR_REDUNDANT_IS_MAX_TC)
       #if MAX_TC_COUNT > 1
         #define HAS_MULTI_MAX_TC 1
         #define READ_MAX_TC(N) read_max_tc(N)
       #else
         #define READ_MAX_TC(N) read_max_tc()
       #endif
       static int16_t read_max_tc(TERN_(HAS_MULTI_MAX_TC, const uint8_t hindex=0));
     #endif
 
-    static void checkExtruderAutoFans();
+    static void update_autofans();
 
     #if HAS_HOTEND
       static float get_pid_output_hotend(const uint8_t e);
     #endif
     #if ENABLED(PIDTEMPBED)
       static float get_pid_output_bed();
     #endif
     #if ENABLED(PIDTEMPCHAMBER)
       static float get_pid_output_chamber();
     #endif

commit 8ee368b718ea7086522f9d64dc97e45a273d6832
Author: Mike La Spina <mike.laspina@shaw.ca>
Date:   Sun Nov 14 05:55:31 2021 -0600

    ‚ö°Ô∏è Controller Fan software PWM (etc.) (#23102)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 0e66f23110..050b3379e9 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -380,20 +380,24 @@ class Temperature {
     #endif
     #if ENABLED(AUTO_POWER_COOLER_FAN)
       static uint8_t coolerfan_speed;
     #endif
 
     #if ENABLED(FAN_SOFT_PWM)
       static uint8_t soft_pwm_amount_fan[FAN_COUNT],
                      soft_pwm_count_fan[FAN_COUNT];
     #endif
 
+    #if BOTH(FAN_SOFT_PWM, USE_CONTROLLER_FAN)
+      static uint8_t soft_pwm_controller_speed;
+    #endif
+
     #if ENABLED(PREVENT_COLD_EXTRUSION)
       static bool allow_cold_extrude;
       static celsius_t extrude_min_temp;
       static inline bool tooCold(const celsius_t temp) { return allow_cold_extrude ? false : temp < extrude_min_temp - (TEMP_WINDOW); }
       static inline bool tooColdToExtrude(const uint8_t E_NAME)       { return tooCold(wholeDegHotend(HOTEND_INDEX)); }
       static inline bool targetTooColdToExtrude(const uint8_t E_NAME) { return tooCold(degTargetHotend(HOTEND_INDEX)); }
     #else
       static inline bool tooColdToExtrude(const uint8_t) { return false; }
       static inline bool targetTooColdToExtrude(const uint8_t) { return false; }
     #endif

commit 70e31bff45165dd07375cd6140fc0a72468e0894
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Oct 27 21:36:06 2021 -0500

    üé® Standard 'cooldown' method

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 5579f71172..0e66f23110 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -841,20 +841,28 @@ class Temperature {
     /**
      * The software PWM power for a heater
      */
     static int16_t getHeaterPower(const heater_id_t heater_id);
 
     /**
      * Switch off all heaters, set all target temperatures to 0
      */
     static void disable_all_heaters();
 
+    /**
+     * Cooldown, as from the LCD. Disables all heaters and fans.
+     */
+    static inline void cooldown() {
+      zero_fan_speeds();
+      disable_all_heaters();
+    }
+
     #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
       /**
        * Methods to check if heaters are enabled, indicating an active job
        */
       static bool auto_job_over_threshold();
       static void auto_job_check_timer(const bool can_start, const bool can_stop);
     #endif
 
     /**
      * Perform auto-tuning for hotend or bed in response to M303

commit 65b950a489c35b1d5547da3a504af4dad8cde3d7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 28 20:15:52 2021 -0500

    üé® Apply F() to kill / sendinfoscreen

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 1675507f86..5579f71172 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -954,21 +954,21 @@ class Temperature {
     #if HAS_HOTEND
       static float get_pid_output_hotend(const uint8_t e);
     #endif
     #if ENABLED(PIDTEMPBED)
       static float get_pid_output_bed();
     #endif
     #if ENABLED(PIDTEMPCHAMBER)
       static float get_pid_output_chamber();
     #endif
 
-    static void _temp_error(const heater_id_t e, PGM_P const serial_msg, PGM_P const lcd_msg);
+    static void _temp_error(const heater_id_t e, FSTR_P const serial_msg, FSTR_P const lcd_msg);
     static void min_temp_error(const heater_id_t e);
     static void max_temp_error(const heater_id_t e);
 
     #define HAS_THERMAL_PROTECTION ANY(THERMAL_PROTECTION_HOTENDS, THERMAL_PROTECTION_CHAMBER, HAS_THERMALLY_PROTECTED_BED, THERMAL_PROTECTION_COOLER)
 
     #if HAS_THERMAL_PROTECTION
 
       // Indices and size for the tr_state_machine array. One for each protected heater.
       enum RunawayIndex : int8_t {
         _RI = -1

commit 79c72ed821564507b0ef46cbb26f9577585e2ccc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 7 18:06:10 2021 -0500

    üé® Standardize G-code reporting

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index c78dfa9372..1675507f86 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -520,21 +520,21 @@ class Temperature {
      */
 
     void init();
 
     /**
      * Static (class) methods
      */
 
     #if HAS_USER_THERMISTORS
       static user_thermistor_t user_thermistor[USER_THERMISTORS];
-      static void log_user_thermistor(const uint8_t t_index, const bool eprom=false);
+      static void M305_report(const uint8_t t_index, const bool forReplay=true);
       static void reset_user_thermistors();
       static celsius_float_t user_thermistor_to_deg_c(const uint8_t t_index, const int16_t raw);
       static inline bool set_pull_up_res(int8_t t_index, float value) {
         //if (!WITHIN(t_index, 0, USER_THERMISTORS - 1)) return false;
         if (!WITHIN(value, 1, 1000000)) return false;
         user_thermistor[t_index].series_res = value;
         return true;
       }
       static inline bool set_res25(int8_t t_index, float value) {
         if (!WITHIN(value, 1, 10000000)) return false;

commit 4479b0222bb66dd54f2c60f50a35a9d35f3230dc
Author: Katelyn Schiesser <katelyn.schiesser@gmail.com>
Date:   Mon Jul 12 20:57:01 2021 -0700

    üêõ Followup to TEMP_SENSOR_BOARD (#22343, #22344)
    
    Followup to #22279

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 61993c43a8..c78dfa9372 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -808,21 +808,21 @@ class Temperature {
         static inline bool isLaserCooling()       { return temp_cooler.target < temp_cooler.celsius; }
         static bool wait_for_cooler(const bool no_wait_for_cooling=true);
       #endif
     #endif
 
     #if HAS_TEMP_BOARD
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         static inline int16_t rawBoardTemp()    { return temp_board.raw; }
       #endif
       static inline celsius_float_t degBoard()  { return temp_board.celsius; }
-      static inline celsius_t wholeDegBoard()   { return static_cast<celsius_t>(degBoard() + 0.5f); }
+      static inline celsius_t wholeDegBoard()   { return static_cast<celsius_t>(temp_board.celsius + 0.5f); }
     #endif
 
     #if HAS_TEMP_REDUNDANT
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         static inline int16_t rawRedundantTemp()         { return temp_redundant.raw; }
         static inline int16_t rawRedundanTargetTemp()    { return (*temp_redundant.target).raw; }
       #endif
       static inline celsius_float_t degRedundant()       { return temp_redundant.celsius; }
       static inline celsius_float_t degRedundantTarget() { return (*temp_redundant.target).celsius; }
       static inline celsius_t wholeDegRedundant()        { return static_cast<celsius_t>(temp_redundant.celsius + 0.5f); }

commit 2f6c8e1176202a014c2a038846cb0403cd2cafe0
Author: Katelyn Schiesser <katelyn.schiesser@gmail.com>
Date:   Sun Jul 11 18:41:33 2021 -0700

    ‚ú® Add TEMP_SENSOR_BOARD (#22279)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index c8d085133c..61993c43a8 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -39,23 +39,27 @@
 
 #ifndef SOFT_PWM_SCALE
   #define SOFT_PWM_SCALE 0
 #endif
 
 #define HOTEND_INDEX TERN(HAS_MULTI_HOTEND, e, 0)
 #define E_NAME TERN_(HAS_MULTI_HOTEND, e)
 
 // Element identifiers. Positive values are hotends. Negative values are other heaters or coolers.
 typedef enum : int8_t {
-  H_NONE = -6,
-  H_COOLER, H_PROBE, H_REDUNDANT, H_CHAMBER, H_BED,
-  H_E0, H_E1, H_E2, H_E3, H_E4, H_E5, H_E6, H_E7
+  H_REDUNDANT = HID_REDUNDANT,
+  H_COOLER = HID_COOLER,
+  H_PROBE = HID_PROBE,
+  H_BOARD = HID_BOARD,
+  H_CHAMBER = HID_CHAMBER,
+  H_BED = HID_BED,
+  H_E0 = HID_E0, H_E1, H_E2, H_E3, H_E4, H_E5, H_E6, H_E7
 } heater_id_t;
 
 // PID storage
 typedef struct { float Kp, Ki, Kd;     } PID_t;
 typedef struct { float Kp, Ki, Kd, Kc; } PIDC_t;
 typedef struct { float Kp, Ki, Kd, Kf; } PIDF_t;
 typedef struct { float Kp, Ki, Kd, Kc, Kf; } PIDCF_t;
 
 typedef
   #if BOTH(PID_EXTRUSION_SCALING, PID_FAN_SCALING)
@@ -98,20 +102,23 @@ enum ADCSensorState : char {
   #endif
   #if HAS_TEMP_ADC_CHAMBER
     PrepareTemp_CHAMBER, MeasureTemp_CHAMBER,
   #endif
   #if HAS_TEMP_ADC_COOLER
     PrepareTemp_COOLER, MeasureTemp_COOLER,
   #endif
   #if HAS_TEMP_ADC_PROBE
     PrepareTemp_PROBE, MeasureTemp_PROBE,
   #endif
+  #if HAS_TEMP_ADC_BOARD
+    PrepareTemp_BOARD, MeasureTemp_BOARD,
+  #endif
   #if HAS_TEMP_ADC_REDUNDANT
     PrepareTemp_REDUNDANT, MeasureTemp_REDUNDANT,
   #endif
   #if HAS_TEMP_ADC_1
     PrepareTemp_1, MeasureTemp_1,
   #endif
   #if HAS_TEMP_ADC_2
     PrepareTemp_2, MeasureTemp_2,
   #endif
   #if HAS_TEMP_ADC_3
@@ -185,21 +192,21 @@ typedef struct TempInfo {
   celsius_float_t celsius;
   inline void reset() { acc = 0; }
   inline void sample(const uint16_t s) { acc += s; }
   inline void update() { raw = acc; }
 } temp_info_t;
 
 #if HAS_TEMP_REDUNDANT
   // A redundant temperature sensor
   typedef struct RedundantTempInfo : public TempInfo {
     temp_info_t* target;
-  } redundant_temp_info_t;
+  } redundant_info_t;
 #endif
 
 // A PWM heater with temperature sensor
 typedef struct HeaterInfo : public TempInfo {
   celsius_t target;
   uint8_t soft_pwm_amount;
 } heater_info_t;
 
 // A heater with PID stabilization
 template<typename T>
@@ -224,20 +231,23 @@ struct PIDHeaterInfo : public HeaterInfo {
 #endif
 #if HAS_HEATED_CHAMBER
   #if ENABLED(PIDTEMPCHAMBER)
     typedef struct PIDHeaterInfo<PID_t> chamber_info_t;
   #else
     typedef heater_info_t chamber_info_t;
   #endif
 #elif HAS_TEMP_CHAMBER
   typedef temp_info_t chamber_info_t;
 #endif
+#if HAS_TEMP_BOARD
+  typedef temp_info_t board_info_t;
+#endif
 #if EITHER(HAS_COOLER, HAS_TEMP_COOLER)
   typedef heater_info_t cooler_info_t;
 #endif
 
 // Heater watch handling
 template <int INCREASE, int HYSTERESIS, millis_t PERIOD>
 struct HeaterWatch {
   celsius_t target;
   millis_t next_ms;
   inline bool elapsed(const millis_t &ms) { return next_ms && ELAPSED(ms, next_ms); }
@@ -305,20 +315,23 @@ typedef struct { int16_t raw_min, raw_max; celsius_t mintemp, maxtemp; } temp_ra
     #endif
     #if TEMP_SENSOR_PROBE_IS_CUSTOM
       CTI_PROBE,
     #endif
     #if TEMP_SENSOR_CHAMBER_IS_CUSTOM
       CTI_CHAMBER,
     #endif
     #if TEMP_SENSOR_COOLER_IS_CUSTOM
       CTI_COOLER,
     #endif
+    #if TEMP_SENSOR_BOARD_IS_CUSTOM
+      CTI_BOARD,
+    #endif
     #if TEMP_SENSOR_REDUNDANT_IS_CUSTOM
       CTI_REDUNDANT,
     #endif
     USER_THERMISTORS
   };
 
   // User-defined thermistor
   typedef struct {
     bool pre_calc;     // true if pre-calculations update needed
     float sh_c_coeff,  // Steinhart-Hart C coefficient .. defaults to '0.0'
@@ -345,22 +358,25 @@ class Temperature {
     #endif
     #if HAS_TEMP_PROBE
       static probe_info_t temp_probe;
     #endif
     #if HAS_TEMP_CHAMBER
       static chamber_info_t temp_chamber;
     #endif
     #if HAS_TEMP_COOLER
       static cooler_info_t temp_cooler;
     #endif
+    #if HAS_TEMP_BOARD
+      static board_info_t temp_board;
+    #endif
     #if HAS_TEMP_REDUNDANT
-      static redundant_temp_info_t temp_redundant;
+      static redundant_info_t temp_redundant;
     #endif
 
     #if ENABLED(AUTO_POWER_E_FANS)
       static uint8_t autofan_speed[HOTENDS];
     #endif
     #if ENABLED(AUTO_POWER_CHAMBER_FAN)
       static uint8_t chamberfan_speed;
     #endif
     #if ENABLED(AUTO_POWER_COOLER_FAN)
       static uint8_t coolerfan_speed;
@@ -471,20 +487,24 @@ class Temperature {
     #endif
 
     #if HAS_COOLER
       #if ENABLED(WATCH_COOLER)
         static cooler_watch_t watch_cooler;
       #endif
       static millis_t next_cooler_check_ms, cooler_fan_flush_ms;
       static int16_t mintemp_raw_COOLER, maxtemp_raw_COOLER;
     #endif
 
+    #if HAS_TEMP_BOARD && ENABLED(THERMAL_PROTECTION_BOARD)
+      static int16_t mintemp_raw_BOARD, maxtemp_raw_BOARD;
+    #endif
+
     #if MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED > 1
       static uint8_t consecutive_low_temperature_error[HOTENDS];
     #endif
 
     #if MILLISECONDS_PREHEAT_TIME > 0
       static millis_t preheat_end_time[HOTENDS];
     #endif
 
     #if HAS_AUTO_FAN
       static millis_t next_auto_fan_check_ms;
@@ -544,20 +564,23 @@ class Temperature {
     #endif
     #if HAS_TEMP_PROBE
       static celsius_float_t analog_to_celsius_probe(const int16_t raw);
     #endif
     #if HAS_TEMP_CHAMBER
       static celsius_float_t analog_to_celsius_chamber(const int16_t raw);
     #endif
     #if HAS_TEMP_COOLER
       static celsius_float_t analog_to_celsius_cooler(const int16_t raw);
     #endif
+    #if HAS_TEMP_BOARD
+      static celsius_float_t analog_to_celsius_board(const int16_t raw);
+    #endif
     #if HAS_TEMP_REDUNDANT
       static celsius_float_t analog_to_celsius_redundant(const int16_t raw);
     #endif
 
     #if HAS_FAN
 
       static uint8_t fan_speed[FAN_COUNT];
       #define FANS_LOOP(I) LOOP_L_N(I, FAN_COUNT)
 
       static void set_fan_speed(const uint8_t fan, const uint16_t speed);
@@ -780,20 +803,28 @@ class Temperature {
       static inline celsius_float_t degCooler()   { return temp_cooler.celsius; }
       static inline celsius_t wholeDegCooler()    { return static_cast<celsius_t>(temp_cooler.celsius + 0.5f); }
       #if HAS_COOLER
         static inline celsius_t degTargetCooler() { return temp_cooler.target; }
         static inline bool isLaserHeating()       { return temp_cooler.target > temp_cooler.celsius; }
         static inline bool isLaserCooling()       { return temp_cooler.target < temp_cooler.celsius; }
         static bool wait_for_cooler(const bool no_wait_for_cooling=true);
       #endif
     #endif
 
+    #if HAS_TEMP_BOARD
+      #if ENABLED(SHOW_TEMP_ADC_VALUES)
+        static inline int16_t rawBoardTemp()    { return temp_board.raw; }
+      #endif
+      static inline celsius_float_t degBoard()  { return temp_board.celsius; }
+      static inline celsius_t wholeDegBoard()   { return static_cast<celsius_t>(degBoard() + 0.5f); }
+    #endif
+
     #if HAS_TEMP_REDUNDANT
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         static inline int16_t rawRedundantTemp()         { return temp_redundant.raw; }
         static inline int16_t rawRedundanTargetTemp()    { return (*temp_redundant.target).raw; }
       #endif
       static inline celsius_float_t degRedundant()       { return temp_redundant.celsius; }
       static inline celsius_float_t degRedundantTarget() { return (*temp_redundant.target).celsius; }
       static inline celsius_t wholeDegRedundant()        { return static_cast<celsius_t>(temp_redundant.celsius + 0.5f); }
       static inline celsius_t wholeDegRedundantTarget()  { return static_cast<celsius_t>((*temp_redundant.target).celsius + 0.5f); }
     #endif

commit 26bfc267977ddc444513c793c18f76847e23310e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jul 9 17:09:58 2021 -0500

    üé® Check flags without ENABLED

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 26c1dca8af..c8d085133c 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -333,30 +333,30 @@ typedef struct { int16_t raw_min, raw_max; celsius_t mintemp, maxtemp; } temp_ra
 
 class Temperature {
 
   public:
 
     #if HAS_HOTEND
       static hotend_info_t temp_hotend[HOTENDS];
       static const celsius_t hotend_maxtemp[HOTENDS];
       static inline celsius_t hotend_max_target(const uint8_t e) { return hotend_maxtemp[e] - (HOTEND_OVERSHOOT); }
     #endif
-    #if ENABLED(HAS_HEATED_BED)
+    #if HAS_HEATED_BED
       static bed_info_t temp_bed;
     #endif
-    #if ENABLED(HAS_TEMP_PROBE)
+    #if HAS_TEMP_PROBE
       static probe_info_t temp_probe;
     #endif
-    #if ENABLED(HAS_TEMP_CHAMBER)
+    #if HAS_TEMP_CHAMBER
       static chamber_info_t temp_chamber;
     #endif
-    #if ENABLED(HAS_TEMP_COOLER)
+    #if HAS_TEMP_COOLER
       static cooler_info_t temp_cooler;
     #endif
     #if HAS_TEMP_REDUNDANT
       static redundant_temp_info_t temp_redundant;
     #endif
 
     #if ENABLED(AUTO_POWER_E_FANS)
       static uint8_t autofan_speed[HOTENDS];
     #endif
     #if ENABLED(AUTO_POWER_CHAMBER_FAN)
@@ -443,21 +443,21 @@ class Temperature {
 
     #if ENABLED(WATCH_HOTENDS)
       static hotend_watch_t watch_hotend[HOTENDS];
     #endif
 
     #if ENABLED(PID_EXTRUSION_SCALING)
       static int32_t last_e_position, lpq[LPQ_MAX_LEN];
       static lpq_ptr_t lpq_ptr;
     #endif
 
-    #if ENABLED(HAS_HOTEND)
+    #if HAS_HOTEND
       static temp_range_t temp_range[HOTENDS];
     #endif
 
     #if HAS_HEATED_BED
       #if ENABLED(WATCH_BED)
         static bed_watch_t watch_bed;
       #endif
       IF_DISABLED(PIDTEMPBED, static millis_t next_bed_check_ms);
       static int16_t mintemp_raw_BED, maxtemp_raw_BED;
     #endif
@@ -479,21 +479,21 @@ class Temperature {
     #endif
 
     #if MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED > 1
       static uint8_t consecutive_low_temperature_error[HOTENDS];
     #endif
 
     #if MILLISECONDS_PREHEAT_TIME > 0
       static millis_t preheat_end_time[HOTENDS];
     #endif
 
-    #if ENABLED(HAS_AUTO_FAN)
+    #if HAS_AUTO_FAN
       static millis_t next_auto_fan_check_ms;
     #endif
 
     #if ENABLED(PROBING_HEATERS_OFF)
       static bool paused_for_probing;
     #endif
 
   public:
     /**
      * Instance Methods
@@ -913,21 +913,21 @@ class Temperature {
         #define HAS_MULTI_MAX_TC 1
         #define READ_MAX_TC(N) read_max_tc(N)
       #else
         #define READ_MAX_TC(N) read_max_tc()
       #endif
       static int16_t read_max_tc(TERN_(HAS_MULTI_MAX_TC, const uint8_t hindex=0));
     #endif
 
     static void checkExtruderAutoFans();
 
-    #if ENABLED(HAS_HOTEND)
+    #if HAS_HOTEND
       static float get_pid_output_hotend(const uint8_t e);
     #endif
     #if ENABLED(PIDTEMPBED)
       static float get_pid_output_bed();
     #endif
     #if ENABLED(PIDTEMPCHAMBER)
       static float get_pid_output_chamber();
     #endif
 
     static void _temp_error(const heater_id_t e, PGM_P const serial_msg, PGM_P const lcd_msg);

commit b2f0913083d83bd3fd9af1c603d1f4cc1afb64eb
Author: Katelyn Schiesser <katelyn.schiesser@gmail.com>
Date:   Tue Jul 6 17:36:41 2021 -0700

    üêõ Redundant Temp Sensor followup (#22196)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 3a8c506a5d..26c1dca8af 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -421,20 +421,29 @@ class Temperature {
       };
 
       // Convert the given heater_id_t to idle array index
       static inline IdleIndex idle_index_for_id(const int8_t heater_id) {
         TERN_(HAS_HEATED_BED, if (heater_id == H_BED) return IDLE_INDEX_BED);
         return (IdleIndex)_MAX(heater_id, 0);
       }
 
       static heater_idle_t heater_idle[NR_HEATER_IDLE];
 
+    #endif // HEATER_IDLE_TIMER
+
+    #if HAS_ADC_BUTTONS
+      static uint32_t current_ADCKey_raw;
+      static uint16_t ADCKey_count;
+    #endif
+
+    #if ENABLED(PID_EXTRUSION_SCALING)
+      static int16_t lpq_len;
     #endif
 
   private:
 
     #if ENABLED(WATCH_HOTENDS)
       static hotend_watch_t watch_hotend[HOTENDS];
     #endif
 
     #if ENABLED(PID_EXTRUSION_SCALING)
       static int32_t last_e_position, lpq[LPQ_MAX_LEN];
@@ -479,29 +488,20 @@ class Temperature {
 
     #if ENABLED(HAS_AUTO_FAN)
       static millis_t next_auto_fan_check_ms;
     #endif
 
     #if ENABLED(PROBING_HEATERS_OFF)
       static bool paused_for_probing;
     #endif
 
   public:
-    #if HAS_ADC_BUTTONS
-      static uint32_t current_ADCKey_raw;
-      static uint16_t ADCKey_count;
-    #endif
-
-    #if ENABLED(PID_EXTRUSION_SCALING)
-      static int16_t lpq_len;
-    #endif
-
     /**
      * Instance Methods
      */
 
     void init();
 
     /**
      * Static (class) methods
      */
 
@@ -908,21 +908,21 @@ class Temperature {
 
     // MAX Thermocouples
     #if HAS_MAX_TC
       #define MAX_TC_COUNT COUNT_ENABLED(TEMP_SENSOR_0_IS_MAX_TC, TEMP_SENSOR_1_IS_MAX_TC, TEMP_SENSOR_REDUNDANT_IS_MAX_TC)
       #if MAX_TC_COUNT > 1
         #define HAS_MULTI_MAX_TC 1
         #define READ_MAX_TC(N) read_max_tc(N)
       #else
         #define READ_MAX_TC(N) read_max_tc()
       #endif
-      static int read_max_tc(TERN_(HAS_MULTI_MAX_TC, const uint8_t hindex=0));
+      static int16_t read_max_tc(TERN_(HAS_MULTI_MAX_TC, const uint8_t hindex=0));
     #endif
 
     static void checkExtruderAutoFans();
 
     #if ENABLED(HAS_HOTEND)
       static float get_pid_output_hotend(const uint8_t e);
     #endif
     #if ENABLED(PIDTEMPBED)
       static float get_pid_output_bed();
     #endif

commit a3e8bb99e472042c7db0b2d0be8d515ee715cf28
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Jun 13 23:08:46 2021 -0400

    üé® ExtUI "user click" and other tweaks (#22122)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index e0dffc3f3a..3a8c506a5d 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -167,21 +167,21 @@ enum ADCSensorState : char {
   #define PID_K2 (1-float(PID_K1))
   #define PID_dT ((OVERSAMPLENR * float(ACTUAL_ADC_SAMPLES)) / TEMP_TIMER_FREQUENCY)
 
   // Apply the scale factors to the PID values
   #define scalePID_i(i)   ( float(i) * PID_dT )
   #define unscalePID_i(i) ( float(i) / PID_dT )
   #define scalePID_d(d)   ( float(d) / PID_dT )
   #define unscalePID_d(d) ( float(d) * PID_dT )
 #endif
 
-#if BOTH(HAS_LCD_MENU, G26_MESH_VALIDATION)
+#if ENABLED(G26_MESH_VALIDATION) && EITHER(HAS_LCD_MENU, EXTENSIBLE_UI)
   #define G26_CLICK_CAN_CANCEL 1
 #endif
 
 // A temperature sensor
 typedef struct TempInfo {
   uint16_t acc;
   int16_t raw;
   celsius_float_t celsius;
   inline void reset() { acc = 0; }
   inline void sample(const uint16_t s) { acc += s; }

commit 629551d9bc10fd10baf8684c6830baf83e6caa9b
Author: Katelyn Schiesser <katelyn.schiesser@gmail.com>
Date:   Fri Jun 11 13:51:29 2021 -0700

    ‚ú® More flexible redundant temp sensor (#22085)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 660fde8af6..e0dffc3f3a 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -98,20 +98,23 @@ enum ADCSensorState : char {
   #endif
   #if HAS_TEMP_ADC_CHAMBER
     PrepareTemp_CHAMBER, MeasureTemp_CHAMBER,
   #endif
   #if HAS_TEMP_ADC_COOLER
     PrepareTemp_COOLER, MeasureTemp_COOLER,
   #endif
   #if HAS_TEMP_ADC_PROBE
     PrepareTemp_PROBE, MeasureTemp_PROBE,
   #endif
+  #if HAS_TEMP_ADC_REDUNDANT
+    PrepareTemp_REDUNDANT, MeasureTemp_REDUNDANT,
+  #endif
   #if HAS_TEMP_ADC_1
     PrepareTemp_1, MeasureTemp_1,
   #endif
   #if HAS_TEMP_ADC_2
     PrepareTemp_2, MeasureTemp_2,
   #endif
   #if HAS_TEMP_ADC_3
     PrepareTemp_3, MeasureTemp_3,
   #endif
   #if HAS_TEMP_ADC_4
@@ -178,20 +181,27 @@ enum ADCSensorState : char {
 // A temperature sensor
 typedef struct TempInfo {
   uint16_t acc;
   int16_t raw;
   celsius_float_t celsius;
   inline void reset() { acc = 0; }
   inline void sample(const uint16_t s) { acc += s; }
   inline void update() { raw = acc; }
 } temp_info_t;
 
+#if HAS_TEMP_REDUNDANT
+  // A redundant temperature sensor
+  typedef struct RedundantTempInfo : public TempInfo {
+    temp_info_t* target;
+  } redundant_temp_info_t;
+#endif
+
 // A PWM heater with temperature sensor
 typedef struct HeaterInfo : public TempInfo {
   celsius_t target;
   uint8_t soft_pwm_amount;
 } heater_info_t;
 
 // A heater with PID stabilization
 template<typename T>
 struct PIDHeaterInfo : public HeaterInfo {
   T pid;  // Initialized by settings.load()
@@ -292,23 +302,26 @@ typedef struct { int16_t raw_min, raw_max; celsius_t mintemp, maxtemp; } temp_ra
     #endif
     #if TEMP_SENSOR_BED_IS_CUSTOM
       CTI_BED,
     #endif
     #if TEMP_SENSOR_PROBE_IS_CUSTOM
       CTI_PROBE,
     #endif
     #if TEMP_SENSOR_CHAMBER_IS_CUSTOM
       CTI_CHAMBER,
     #endif
-    #if COOLER_USER_THERMISTOR
+    #if TEMP_SENSOR_COOLER_IS_CUSTOM
       CTI_COOLER,
     #endif
+    #if TEMP_SENSOR_REDUNDANT_IS_CUSTOM
+      CTI_REDUNDANT,
+    #endif
     USER_THERMISTORS
   };
 
   // User-defined thermistor
   typedef struct {
     bool pre_calc;     // true if pre-calculations update needed
     float sh_c_coeff,  // Steinhart-Hart C coefficient .. defaults to '0.0'
           sh_alpha,
           series_res,
           res_25, res_25_recip,
@@ -316,39 +329,39 @@ typedef struct { int16_t raw_min, raw_max; celsius_t mintemp, maxtemp; } temp_ra
           beta, beta_recip;
   } user_thermistor_t;
 
 #endif
 
 class Temperature {
 
   public:
 
     #if HAS_HOTEND
-      #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
-        static temp_info_t temp_redundant;
-      #endif
       static hotend_info_t temp_hotend[HOTENDS];
       static const celsius_t hotend_maxtemp[HOTENDS];
       static inline celsius_t hotend_max_target(const uint8_t e) { return hotend_maxtemp[e] - (HOTEND_OVERSHOOT); }
     #endif
     #if ENABLED(HAS_HEATED_BED)
       static bed_info_t temp_bed;
     #endif
     #if ENABLED(HAS_TEMP_PROBE)
       static probe_info_t temp_probe;
     #endif
     #if ENABLED(HAS_TEMP_CHAMBER)
       static chamber_info_t temp_chamber;
     #endif
     #if ENABLED(HAS_TEMP_COOLER)
       static cooler_info_t temp_cooler;
     #endif
+    #if HAS_TEMP_REDUNDANT
+      static redundant_temp_info_t temp_redundant;
+    #endif
 
     #if ENABLED(AUTO_POWER_E_FANS)
       static uint8_t autofan_speed[HOTENDS];
     #endif
     #if ENABLED(AUTO_POWER_CHAMBER_FAN)
       static uint8_t chamberfan_speed;
     #endif
     #if ENABLED(AUTO_POWER_COOLER_FAN)
       static uint8_t coolerfan_speed;
     #endif
@@ -531,20 +544,23 @@ class Temperature {
     #endif
     #if HAS_TEMP_PROBE
       static celsius_float_t analog_to_celsius_probe(const int16_t raw);
     #endif
     #if HAS_TEMP_CHAMBER
       static celsius_float_t analog_to_celsius_chamber(const int16_t raw);
     #endif
     #if HAS_TEMP_COOLER
       static celsius_float_t analog_to_celsius_cooler(const int16_t raw);
     #endif
+    #if HAS_TEMP_REDUNDANT
+      static celsius_float_t analog_to_celsius_redundant(const int16_t raw);
+    #endif
 
     #if HAS_FAN
 
       static uint8_t fan_speed[FAN_COUNT];
       #define FANS_LOOP(I) LOOP_L_N(I, FAN_COUNT)
 
       static void set_fan_speed(const uint8_t fan, const uint16_t speed);
 
       #if ENABLED(REPORT_FAN_CHANGE)
         static void report_fan_speed(const uint8_t fan);
@@ -619,35 +635,28 @@ class Temperature {
     #endif
 
     //high level conversion routines, for use outside of temperature.cpp
     //inline so that there is no performance decrease.
     //deg=degreeCelsius
 
     static inline celsius_float_t degHotend(const uint8_t E_NAME) {
       return TERN0(HAS_HOTEND, temp_hotend[HOTEND_INDEX].celsius);
     }
 
-    #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
-      static inline celsius_float_t degHotendRedundant() { return temp_redundant.celsius; }
-    #endif
-
     static inline celsius_t wholeDegHotend(const uint8_t E_NAME) {
       return TERN0(HAS_HOTEND, static_cast<celsius_t>(temp_hotend[HOTEND_INDEX].celsius + 0.5f));
     }
 
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       static inline int16_t rawHotendTemp(const uint8_t E_NAME) {
         return TERN0(HAS_HOTEND, temp_hotend[HOTEND_INDEX].raw);
       }
-      #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
-        static inline int16_t rawHotendTempRedundant() { return temp_redundant.raw; }
-      #endif
     #endif
 
     static inline celsius_t degTargetHotend(const uint8_t E_NAME) {
       return TERN0(HAS_HOTEND, temp_hotend[HOTEND_INDEX].target);
     }
 
     #if HAS_HOTEND
 
       static void setTargetHotend(const celsius_t celsius, const uint8_t E_NAME) {
         const uint8_t ee = HOTEND_INDEX;
@@ -771,20 +780,31 @@ class Temperature {
       static inline celsius_float_t degCooler()   { return temp_cooler.celsius; }
       static inline celsius_t wholeDegCooler()    { return static_cast<celsius_t>(temp_cooler.celsius + 0.5f); }
       #if HAS_COOLER
         static inline celsius_t degTargetCooler() { return temp_cooler.target; }
         static inline bool isLaserHeating()       { return temp_cooler.target > temp_cooler.celsius; }
         static inline bool isLaserCooling()       { return temp_cooler.target < temp_cooler.celsius; }
         static bool wait_for_cooler(const bool no_wait_for_cooling=true);
       #endif
     #endif
 
+    #if HAS_TEMP_REDUNDANT
+      #if ENABLED(SHOW_TEMP_ADC_VALUES)
+        static inline int16_t rawRedundantTemp()         { return temp_redundant.raw; }
+        static inline int16_t rawRedundanTargetTemp()    { return (*temp_redundant.target).raw; }
+      #endif
+      static inline celsius_float_t degRedundant()       { return temp_redundant.celsius; }
+      static inline celsius_float_t degRedundantTarget() { return (*temp_redundant.target).celsius; }
+      static inline celsius_t wholeDegRedundant()        { return static_cast<celsius_t>(temp_redundant.celsius + 0.5f); }
+      static inline celsius_t wholeDegRedundantTarget()  { return static_cast<celsius_t>((*temp_redundant.target).celsius + 0.5f); }
+    #endif
+
     #if HAS_COOLER
       static inline void setTargetCooler(const celsius_t celsius) {
         temp_cooler.target = constrain(celsius, COOLER_MIN_TARGET, COOLER_MAX_TARGET);
         start_watching_cooler();
       }
       // Start watching the Cooler to make sure it's really cooling down
       static inline void start_watching_cooler() { TERN_(WATCH_COOLER, watch_cooler.restart(degCooler(), degTargetCooler())); }
     #endif
 
     /**
@@ -848,21 +868,21 @@ class Temperature {
         static inline void reset_bed_idle_timer() {
           heater_idle[IDLE_INDEX_BED].reset();
           start_watching_bed();
         }
       #endif
 
     #endif // HEATER_IDLE_HANDLER
 
     #if HAS_TEMP_SENSOR
       static void print_heater_states(const uint8_t target_extruder
-        OPTARG(TEMP_SENSOR_1_AS_REDUNDANT, const bool include_r=false)
+        OPTARG(HAS_TEMP_REDUNDANT, const bool include_r=false)
       );
       #if ENABLED(AUTO_REPORT_TEMPERATURES)
         struct AutoReportTemp { static void report(); };
         static AutoReporter<AutoReportTemp> auto_reporter;
       #endif
     #endif
 
     #if HAS_HOTEND && HAS_STATUS_MESSAGE
       static void set_heating_message(const uint8_t e);
     #else
@@ -881,21 +901,21 @@ class Temperature {
     static void updateTemperaturesFromRawValues();
     static inline bool updateTemperaturesIfReady() {
       if (!raw_temps_ready) return false;
       updateTemperaturesFromRawValues();
       raw_temps_ready = false;
       return true;
     }
 
     // MAX Thermocouples
     #if HAS_MAX_TC
-      #define MAX_TC_COUNT 1 + BOTH(TEMP_SENSOR_0_IS_MAX_TC, TEMP_SENSOR_1_IS_MAX_TC)
+      #define MAX_TC_COUNT COUNT_ENABLED(TEMP_SENSOR_0_IS_MAX_TC, TEMP_SENSOR_1_IS_MAX_TC, TEMP_SENSOR_REDUNDANT_IS_MAX_TC)
       #if MAX_TC_COUNT > 1
         #define HAS_MULTI_MAX_TC 1
         #define READ_MAX_TC(N) read_max_tc(N)
       #else
         #define READ_MAX_TC(N) read_max_tc()
       #endif
       static int read_max_tc(TERN_(HAS_MULTI_MAX_TC, const uint8_t hindex=0));
     #endif
 
     static void checkExtruderAutoFans();

commit 84fd0eff17d089e3f75f6585d4bba47f15c00ba7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 23 21:33:22 2021 -0500

    üé® Macros for optional arguments (#21969)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index a80e39cbd8..660fde8af6 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -39,21 +39,21 @@
 
 #ifndef SOFT_PWM_SCALE
   #define SOFT_PWM_SCALE 0
 #endif
 
 #define HOTEND_INDEX TERN(HAS_MULTI_HOTEND, e, 0)
 #define E_NAME TERN_(HAS_MULTI_HOTEND, e)
 
 // Element identifiers. Positive values are hotends. Negative values are other heaters or coolers.
 typedef enum : int8_t {
-  INDEX_NONE = -6,
+  H_NONE = -6,
   H_COOLER, H_PROBE, H_REDUNDANT, H_CHAMBER, H_BED,
   H_E0, H_E1, H_E2, H_E3, H_E4, H_E5, H_E6, H_E7
 } heater_id_t;
 
 // PID storage
 typedef struct { float Kp, Ki, Kd;     } PID_t;
 typedef struct { float Kp, Ki, Kd, Kc; } PIDC_t;
 typedef struct { float Kp, Ki, Kd, Kf; } PIDF_t;
 typedef struct { float Kp, Ki, Kd, Kc, Kf; } PIDCF_t;
 
@@ -388,35 +388,35 @@ class Temperature {
       typedef struct {
         millis_t timeout_ms;
         bool timed_out;
         inline void update(const millis_t &ms) { if (!timed_out && timeout_ms && ELAPSED(ms, timeout_ms)) timed_out = true; }
         inline void start(const millis_t &ms) { timeout_ms = millis() + ms; timed_out = false; }
         inline void reset() { timeout_ms = 0; timed_out = false; }
         inline void expire() { start(0); }
       } heater_idle_t;
 
       // Indices and size for the heater_idle array
-      #define _ENUM_FOR_E(N) IDLE_INDEX_E##N,
-      enum IdleIndex : uint8_t {
-        REPEAT(HOTENDS, _ENUM_FOR_E)
-        #if ENABLED(HAS_HEATED_BED)
-          IDLE_INDEX_BED,
-        #endif
-        NR_HEATER_IDLE
+      enum IdleIndex : int8_t {
+        _II = -1
+
+        #define _IDLE_INDEX_E(N) ,IDLE_INDEX_E##N
+        REPEAT(HOTENDS, _IDLE_INDEX_E)
+        #undef _IDLE_INDEX_E
+
+        OPTARG(HAS_HEATED_BED, IDLE_INDEX_BED)
+
+        , NR_HEATER_IDLE
       };
-      #undef _ENUM_FOR_E
 
       // Convert the given heater_id_t to idle array index
       static inline IdleIndex idle_index_for_id(const int8_t heater_id) {
-        #if HAS_HEATED_BED
-          if (heater_id == H_BED) return IDLE_INDEX_BED;
-        #endif
+        TERN_(HAS_HEATED_BED, if (heater_id == H_BED) return IDLE_INDEX_BED);
         return (IdleIndex)_MAX(heater_id, 0);
       }
 
       static heater_idle_t heater_idle[NR_HEATER_IDLE];
 
     #endif
 
   private:
 
     #if ENABLED(WATCH_HOTENDS)
@@ -665,23 +665,21 @@ class Temperature {
       static inline bool isHeatingHotend(const uint8_t E_NAME) {
         return temp_hotend[HOTEND_INDEX].target > temp_hotend[HOTEND_INDEX].celsius;
       }
 
       static inline bool isCoolingHotend(const uint8_t E_NAME) {
         return temp_hotend[HOTEND_INDEX].target < temp_hotend[HOTEND_INDEX].celsius;
       }
 
       #if HAS_TEMP_HOTEND
         static bool wait_for_hotend(const uint8_t target_extruder, const bool no_wait_for_cooling=true
-          #if G26_CLICK_CAN_CANCEL
-            , const bool click_to_cancel=false
-          #endif
+          OPTARG(G26_CLICK_CAN_CANCEL, const bool click_to_cancel=false)
         );
 
         #if ENABLED(WAIT_FOR_HOTEND)
           static void wait_for_hotend_heating(const uint8_t target_extruder);
         #endif
       #endif
 
       static inline bool still_heating(const uint8_t e) {
         return degTargetHotend(e) > TEMP_HYSTERESIS && ABS(wholeDegHotend(e) - degTargetHotend(e)) > TEMP_HYSTERESIS;
       }
@@ -714,23 +712,21 @@ class Temperature {
       // Start watching the Bed to make sure it's really heating up
       static inline void start_watching_bed() { TERN_(WATCH_BED, watch_bed.restart(degBed(), degTargetBed())); }
 
       static void setTargetBed(const celsius_t celsius) {
         TERN_(AUTO_POWER_CONTROL, if (celsius) powerManager.power_on());
         temp_bed.target = _MIN(celsius, BED_MAX_TARGET);
         start_watching_bed();
       }
 
       static bool wait_for_bed(const bool no_wait_for_cooling=true
-        #if G26_CLICK_CAN_CANCEL
-          , const bool click_to_cancel=false
-        #endif
+        OPTARG(G26_CLICK_CAN_CANCEL, const bool click_to_cancel=false)
       );
 
       static void wait_for_bed_heating();
 
       static inline bool degBedNear(const celsius_t temp) {
         return ABS(wholeDegBed() - temp) < (TEMP_BED_HYSTERESIS);
       }
 
     #endif // HAS_HEATED_BED
 
@@ -852,23 +848,21 @@ class Temperature {
         static inline void reset_bed_idle_timer() {
           heater_idle[IDLE_INDEX_BED].reset();
           start_watching_bed();
         }
       #endif
 
     #endif // HEATER_IDLE_HANDLER
 
     #if HAS_TEMP_SENSOR
       static void print_heater_states(const uint8_t target_extruder
-        #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
-          , const bool include_r=false
-        #endif
+        OPTARG(TEMP_SENSOR_1_AS_REDUNDANT, const bool include_r=false)
       );
       #if ENABLED(AUTO_REPORT_TEMPERATURES)
         struct AutoReportTemp { static void report(); };
         static AutoReporter<AutoReportTemp> auto_reporter;
       #endif
     #endif
 
     #if HAS_HOTEND && HAS_STATUS_MESSAGE
       static void set_heating_message(const uint8_t e);
     #else
@@ -918,49 +912,38 @@ class Temperature {
 
     static void _temp_error(const heater_id_t e, PGM_P const serial_msg, PGM_P const lcd_msg);
     static void min_temp_error(const heater_id_t e);
     static void max_temp_error(const heater_id_t e);
 
     #define HAS_THERMAL_PROTECTION ANY(THERMAL_PROTECTION_HOTENDS, THERMAL_PROTECTION_CHAMBER, HAS_THERMALLY_PROTECTED_BED, THERMAL_PROTECTION_COOLER)
 
     #if HAS_THERMAL_PROTECTION
 
       // Indices and size for the tr_state_machine array. One for each protected heater.
-      #define _ENUM_FOR_E(N) RUNAWAY_IND_E##N,
-      enum RunawayIndex : uint8_t {
+      enum RunawayIndex : int8_t {
+        _RI = -1
         #if ENABLED(THERMAL_PROTECTION_HOTENDS)
-          REPEAT(HOTENDS, _ENUM_FOR_E)
+          #define _RUNAWAY_IND_E(N) ,RUNAWAY_IND_E##N
+          REPEAT(HOTENDS, _RUNAWAY_IND_E)
+          #undef _RUNAWAY_IND_E
         #endif
-        #if ENABLED(HAS_THERMALLY_PROTECTED_BED)
-          RUNAWAY_IND_BED,
-        #endif
-        #if ENABLED(THERMAL_PROTECTION_CHAMBER)
-          RUNAWAY_IND_CHAMBER,
-        #endif
-        #if ENABLED(THERMAL_PROTECTION_COOLER)
-          RUNAWAY_IND_COOLER,
-        #endif
-        NR_HEATER_RUNAWAY
+        OPTARG(HAS_THERMALLY_PROTECTED_BED, RUNAWAY_IND_BED)
+        OPTARG(THERMAL_PROTECTION_CHAMBER, RUNAWAY_IND_CHAMBER)
+        OPTARG(THERMAL_PROTECTION_COOLER, RUNAWAY_IND_COOLER)
+        , NR_HEATER_RUNAWAY
       };
-      #undef _ENUM_FOR_E
 
       // Convert the given heater_id_t to runaway state array index
       static inline RunawayIndex runaway_index_for_id(const int8_t heater_id) {
-        #if HAS_THERMALLY_PROTECTED_CHAMBER
-          if (heater_id == H_CHAMBER) return RUNAWAY_IND_CHAMBER;
-        #endif
-        #if HAS_THERMALLY_PROTECTED_CHAMBER
-          if (heater_id == H_COOLER) return RUNAWAY_IND_COOLER;
-        #endif
-        #if HAS_THERMALLY_PROTECTED_BED
-          if (heater_id == H_BED) return RUNAWAY_IND_BED;
-        #endif
+        TERN_(HAS_THERMALLY_PROTECTED_CHAMBER, if (heater_id == H_CHAMBER) return RUNAWAY_IND_CHAMBER);
+        TERN_(HAS_THERMALLY_PROTECTED_CHAMBER, if (heater_id == H_COOLER)  return RUNAWAY_IND_COOLER);
+        TERN_(HAS_THERMALLY_PROTECTED_BED,     if (heater_id == H_BED)     return RUNAWAY_IND_BED);
         return (RunawayIndex)_MAX(heater_id, 0);
       }
 
       enum TRState : char { TRInactive, TRFirstHeating, TRStable, TRRunaway };
 
       typedef struct {
         millis_t timer = 0;
         TRState state = TRInactive;
         float running_temp;
         void run(const_celsius_float_t current, const_celsius_float_t target, const heater_id_t heater_id, const uint16_t period_seconds, const celsius_t hysteresis_degc);

commit ff0318c5bd95c6cb18ae9765f1ecb344dc2d6e4e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 22 21:08:57 2021 -0500

    üé® pause => pause_heaters

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 2fd2b639ec..a80e39cbd8 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -831,21 +831,21 @@ class Temperature {
        */
       #if ENABLED(PIDTEMP)
         static inline void updatePID() {
           TERN_(PID_EXTRUSION_SCALING, last_e_position = 0);
         }
       #endif
 
     #endif
 
     #if ENABLED(PROBING_HEATERS_OFF)
-      static void pause(const bool p);
+      static void pause_heaters(const bool p);
     #endif
 
     #if HEATER_IDLE_HANDLER
 
       static inline void reset_hotend_idle_timer(const uint8_t E_NAME) {
         heater_idle[HOTEND_INDEX].reset();
         start_watching_hotend(HOTEND_INDEX);
       }
 
       #if HAS_HEATED_BED

commit d8c4be375c24f0cda27ff8079b78985e5b8afa97
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 22 17:56:31 2021 -0500

    üé® Null heating message method

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 83fbc8fd46..2fd2b639ec 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -862,22 +862,24 @@ class Temperature {
         #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
           , const bool include_r=false
         #endif
       );
       #if ENABLED(AUTO_REPORT_TEMPERATURES)
         struct AutoReportTemp { static void report(); };
         static AutoReporter<AutoReportTemp> auto_reporter;
       #endif
     #endif
 
-    #if HAS_STATUS_MESSAGE
+    #if HAS_HOTEND && HAS_STATUS_MESSAGE
       static void set_heating_message(const uint8_t e);
+    #else
+      static inline void set_heating_message(const uint8_t) {}
     #endif
 
     #if HAS_LCD_MENU && HAS_TEMPERATURE
       static void lcd_preheat(const uint8_t e, const int8_t indh, const int8_t indb);
     #endif
 
   private:
 
     // Reading raw temperatures and converting to Celsius when ready
     static volatile bool raw_temps_ready;

commit 42a2b5c3ec1c4067113b87ad8c1977018bbb763e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat May 8 17:34:21 2021 -0500

    Move temp errors calling kill() out of ISR (#21832)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 96ff8b5895..83fbc8fd46 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -412,22 +412,20 @@ class Temperature {
         #endif
         return (IdleIndex)_MAX(heater_id, 0);
       }
 
       static heater_idle_t heater_idle[NR_HEATER_IDLE];
 
     #endif
 
   private:
 
-    static volatile bool raw_temps_ready;
-
     #if ENABLED(WATCH_HOTENDS)
       static hotend_watch_t watch_hotend[HOTENDS];
     #endif
 
     #if ENABLED(PID_EXTRUSION_SCALING)
       static int32_t last_e_position, lpq[LPQ_MAX_LEN];
       static lpq_ptr_t lpq_ptr;
     #endif
 
     #if ENABLED(HAS_HOTEND)
@@ -873,23 +871,33 @@ class Temperature {
 
     #if HAS_STATUS_MESSAGE
       static void set_heating_message(const uint8_t e);
     #endif
 
     #if HAS_LCD_MENU && HAS_TEMPERATURE
       static void lcd_preheat(const uint8_t e, const int8_t indh, const int8_t indb);
     #endif
 
   private:
+
+    // Reading raw temperatures and converting to Celsius when ready
+    static volatile bool raw_temps_ready;
     static void update_raw_temperatures();
     static void updateTemperaturesFromRawValues();
+    static inline bool updateTemperaturesIfReady() {
+      if (!raw_temps_ready) return false;
+      updateTemperaturesFromRawValues();
+      raw_temps_ready = false;
+      return true;
+    }
 
+    // MAX Thermocouples
     #if HAS_MAX_TC
       #define MAX_TC_COUNT 1 + BOTH(TEMP_SENSOR_0_IS_MAX_TC, TEMP_SENSOR_1_IS_MAX_TC)
       #if MAX_TC_COUNT > 1
         #define HAS_MULTI_MAX_TC 1
         #define READ_MAX_TC(N) read_max_tc(N)
       #else
         #define READ_MAX_TC(N) read_max_tc()
       #endif
       static int read_max_tc(TERN_(HAS_MULTI_MAX_TC, const uint8_t hindex=0));
     #endif

commit dc187690109b9f66673bb6675c098af0644d40e1
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Sun May 2 23:37:54 2021 -0300

    Prevent watchdog reset in setup() (#21776)
    
    Cause `manage_heaters` to only reset the watchdog and return until `setup()` is completed.
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 148e9eec54..96ff8b5895 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -412,24 +412,20 @@ class Temperature {
         #endif
         return (IdleIndex)_MAX(heater_id, 0);
       }
 
       static heater_idle_t heater_idle[NR_HEATER_IDLE];
 
     #endif
 
   private:
 
-    #if ENABLED(EARLY_WATCHDOG)
-      static bool inited;   // If temperature controller is running
-    #endif
-
     static volatile bool raw_temps_ready;
 
     #if ENABLED(WATCH_HOTENDS)
       static hotend_watch_t watch_hotend[HOTENDS];
     #endif
 
     #if ENABLED(PID_EXTRUSION_SCALING)
       static int32_t last_e_position, lpq[LPQ_MAX_LEN];
       static lpq_ptr_t lpq_ptr;
     #endif

commit becdac19ea4559c1e636d55d949a15c50cac7888
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 2 21:32:21 2021 -0500

    Temperature cleanup

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 702a3ea04d..148e9eec54 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -455,34 +455,34 @@ class Temperature {
     #endif
 
     #if HAS_COOLER
       #if ENABLED(WATCH_COOLER)
         static cooler_watch_t watch_cooler;
       #endif
       static millis_t next_cooler_check_ms, cooler_fan_flush_ms;
       static int16_t mintemp_raw_COOLER, maxtemp_raw_COOLER;
     #endif
 
-    #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
+    #if MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED > 1
       static uint8_t consecutive_low_temperature_error[HOTENDS];
     #endif
 
-    #ifdef MILLISECONDS_PREHEAT_TIME
+    #if MILLISECONDS_PREHEAT_TIME > 0
       static millis_t preheat_end_time[HOTENDS];
     #endif
 
     #if ENABLED(HAS_AUTO_FAN)
       static millis_t next_auto_fan_check_ms;
     #endif
 
     #if ENABLED(PROBING_HEATERS_OFF)
-      static bool paused;
+      static bool paused_for_probing;
     #endif
 
   public:
     #if HAS_ADC_BUTTONS
       static uint32_t current_ADCKey_raw;
       static uint16_t ADCKey_count;
     #endif
 
     #if ENABLED(PID_EXTRUSION_SCALING)
       static int16_t lpq_len;
@@ -603,21 +603,21 @@ class Temperature {
     static void readings_ready();
 
     /**
      * Call periodically to manage heaters
      */
     static void manage_heater() _O2; // Added _O2 to work around a compiler error
 
     /**
      * Preheating hotends
      */
-    #ifdef MILLISECONDS_PREHEAT_TIME
+    #if MILLISECONDS_PREHEAT_TIME > 0
       static inline bool is_preheating(const uint8_t E_NAME) {
         return preheat_end_time[HOTEND_INDEX] && PENDING(millis(), preheat_end_time[HOTEND_INDEX]);
       }
       static inline void start_preheat_time(const uint8_t E_NAME) {
         preheat_end_time[HOTEND_INDEX] = millis() + MILLISECONDS_PREHEAT_TIME;
       }
       static inline void reset_preheat_time(const uint8_t E_NAME) {
         preheat_end_time[HOTEND_INDEX] = 0;
       }
     #else
@@ -646,31 +646,25 @@ class Temperature {
       }
       #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
         static inline int16_t rawHotendTempRedundant() { return temp_redundant.raw; }
       #endif
     #endif
 
     static inline celsius_t degTargetHotend(const uint8_t E_NAME) {
       return TERN0(HAS_HOTEND, temp_hotend[HOTEND_INDEX].target);
     }
 
-    #if WATCH_HOTENDS
-      static void start_watching_hotend(const uint8_t e=0);
-    #else
-      static inline void start_watching_hotend(const uint8_t=0) {}
-    #endif
-
     #if HAS_HOTEND
 
       static void setTargetHotend(const celsius_t celsius, const uint8_t E_NAME) {
         const uint8_t ee = HOTEND_INDEX;
-        #ifdef MILLISECONDS_PREHEAT_TIME
+        #if MILLISECONDS_PREHEAT_TIME > 0
           if (celsius == 0)
             reset_preheat_time(ee);
           else if (temp_hotend[ee].target == 0)
             start_preheat_time(ee);
         #endif
         TERN_(AUTO_POWER_CONTROL, if (celsius) powerManager.power_on());
         temp_hotend[ee].target = _MIN(celsius, hotend_max_target(ee));
         start_watching_hotend(ee);
       }
 
@@ -695,38 +689,43 @@ class Temperature {
       #endif
 
       static inline bool still_heating(const uint8_t e) {
         return degTargetHotend(e) > TEMP_HYSTERESIS && ABS(wholeDegHotend(e) - degTargetHotend(e)) > TEMP_HYSTERESIS;
       }
 
       static inline bool degHotendNear(const uint8_t e, const celsius_t temp) {
         return ABS(wholeDegHotend(e) - temp) < (TEMP_HYSTERESIS);
       }
 
+      // Start watching a Hotend to make sure it's really heating up
+      static inline void start_watching_hotend(const uint8_t E_NAME) {
+        UNUSED(HOTEND_INDEX);
+        #if WATCH_HOTENDS
+          watch_hotend[HOTEND_INDEX].restart(degHotend(HOTEND_INDEX), degTargetHotend(HOTEND_INDEX));
+        #endif
+      }
+
     #endif // HAS_HOTEND
 
     #if HAS_HEATED_BED
 
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         static inline int16_t rawBedTemp()    { return temp_bed.raw; }
       #endif
       static inline celsius_float_t degBed()  { return temp_bed.celsius; }
       static inline celsius_t wholeDegBed()   { return static_cast<celsius_t>(degBed() + 0.5f); }
       static inline celsius_t degTargetBed()  { return temp_bed.target; }
       static inline bool isHeatingBed()       { return temp_bed.target > temp_bed.celsius; }
       static inline bool isCoolingBed()       { return temp_bed.target < temp_bed.celsius; }
 
-      #if WATCH_BED
-        static void start_watching_bed();
-      #else
-        static inline void start_watching_bed() {}
-      #endif
+      // Start watching the Bed to make sure it's really heating up
+      static inline void start_watching_bed() { TERN_(WATCH_BED, watch_bed.restart(degBed(), degTargetBed())); }
 
       static void setTargetBed(const celsius_t celsius) {
         TERN_(AUTO_POWER_CONTROL, if (celsius) powerManager.power_on());
         temp_bed.target = _MIN(celsius, BED_MAX_TARGET);
         start_watching_bed();
       }
 
       static bool wait_for_bed(const bool no_wait_for_cooling=true
         #if G26_CLICK_CAN_CANCEL
           , const bool click_to_cancel=false
@@ -745,78 +744,64 @@ class Temperature {
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         static inline int16_t rawProbeTemp()    { return temp_probe.raw; }
       #endif
       static inline celsius_float_t degProbe()  { return temp_probe.celsius; }
       static inline celsius_t wholeDegProbe()   { return static_cast<celsius_t>(degProbe() + 0.5f); }
       static inline bool isProbeBelowTemp(const celsius_t target_temp) { return wholeDegProbe() < target_temp; }
       static inline bool isProbeAboveTemp(const celsius_t target_temp) { return wholeDegProbe() > target_temp; }
       static bool wait_for_probe(const celsius_t target_temp, bool no_wait_for_cooling=true);
     #endif
 
-    #if WATCH_PROBE
-      static void start_watching_probe();
-    #else
-      static inline void start_watching_probe() {}
-    #endif
-
     #if HAS_TEMP_CHAMBER
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         static inline int16_t rawChamberTemp()      { return temp_chamber.raw; }
       #endif
       static inline celsius_float_t degChamber()    { return temp_chamber.celsius; }
       static inline celsius_t wholeDegChamber()     { return static_cast<celsius_t>(degChamber() + 0.5f); }
       #if HAS_HEATED_CHAMBER
         static inline celsius_t degTargetChamber()  { return temp_chamber.target; }
         static inline bool isHeatingChamber()       { return temp_chamber.target > temp_chamber.celsius; }
         static inline bool isCoolingChamber()       { return temp_chamber.target < temp_chamber.celsius; }
         static bool wait_for_chamber(const bool no_wait_for_cooling=true);
       #endif
     #endif
 
-    #if WATCH_CHAMBER
-      static void start_watching_chamber();
-    #else
-      static inline void start_watching_chamber() {}
-    #endif
-
     #if HAS_HEATED_CHAMBER
       static void setTargetChamber(const celsius_t celsius) {
         temp_chamber.target = _MIN(celsius, CHAMBER_MAX_TARGET);
         start_watching_chamber();
       }
+      // Start watching the Chamber to make sure it's really heating up
+      static inline void start_watching_chamber() { TERN_(WATCH_CHAMBER, watch_chamber.restart(degChamber(), degTargetChamber())); }
     #endif
 
     #if HAS_TEMP_COOLER
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         static inline int16_t rawCoolerTemp()     { return temp_cooler.raw; }
       #endif
       static inline celsius_float_t degCooler()   { return temp_cooler.celsius; }
       static inline celsius_t wholeDegCooler()    { return static_cast<celsius_t>(temp_cooler.celsius + 0.5f); }
       #if HAS_COOLER
         static inline celsius_t degTargetCooler() { return temp_cooler.target; }
         static inline bool isLaserHeating()       { return temp_cooler.target > temp_cooler.celsius; }
         static inline bool isLaserCooling()       { return temp_cooler.target < temp_cooler.celsius; }
         static bool wait_for_cooler(const bool no_wait_for_cooling=true);
       #endif
     #endif
 
-    #if WATCH_COOLER
-      static void start_watching_cooler();
-    #else
-      static inline void start_watching_cooler() {}
-    #endif
-
     #if HAS_COOLER
       static inline void setTargetCooler(const celsius_t celsius) {
         temp_cooler.target = constrain(celsius, COOLER_MIN_TARGET, COOLER_MAX_TARGET);
         start_watching_cooler();
       }
+      // Start watching the Cooler to make sure it's really cooling down
+      static inline void start_watching_cooler() { TERN_(WATCH_COOLER, watch_cooler.restart(degCooler(), degTargetCooler())); }
     #endif
 
     /**
      * The software PWM power for a heater
      */
     static int16_t getHeaterPower(const heater_id_t heater_id);
 
     /**
      * Switch off all heaters, set all target temperatures to 0
      */
@@ -853,21 +838,20 @@ class Temperature {
       #if ENABLED(PIDTEMP)
         static inline void updatePID() {
           TERN_(PID_EXTRUSION_SCALING, last_e_position = 0);
         }
       #endif
 
     #endif
 
     #if ENABLED(PROBING_HEATERS_OFF)
       static void pause(const bool p);
-      static inline bool is_paused() { return paused; }
     #endif
 
     #if HEATER_IDLE_HANDLER
 
       static inline void reset_hotend_idle_timer(const uint8_t E_NAME) {
         heater_idle[HOTEND_INDEX].reset();
         start_watching_hotend(HOTEND_INDEX);
       }
 
       #if HAS_HEATED_BED

commit ef9ca61039514efef6e2bf100c4b6b1db8f0316c
Author: ellensp <ellensp@hotmail.com>
Date:   Sat May 1 20:21:18 2021 +1200

    Fix Singlenozzle Standby issues (#21759)
    
    Fixes #21758
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index adc10c3ccd..702a3ea04d 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -365,23 +365,25 @@ class Temperature {
       static inline bool tooColdToExtrude(const uint8_t E_NAME)       { return tooCold(wholeDegHotend(HOTEND_INDEX)); }
       static inline bool targetTooColdToExtrude(const uint8_t E_NAME) { return tooCold(degTargetHotend(HOTEND_INDEX)); }
     #else
       static inline bool tooColdToExtrude(const uint8_t) { return false; }
       static inline bool targetTooColdToExtrude(const uint8_t) { return false; }
     #endif
 
     static inline bool hotEnoughToExtrude(const uint8_t e) { return !tooColdToExtrude(e); }
     static inline bool targetHotEnoughToExtrude(const uint8_t e) { return !targetTooColdToExtrude(e); }
 
-    #if ENABLED(SINGLENOZZLE_STANDBY_FAN)
-      static celsius_t singlenozzle_temp[EXTRUDERS];
-      #if HAS_FAN
+    #if EITHER(SINGLENOZZLE_STANDBY_TEMP, SINGLENOZZLE_STANDBY_FAN)
+      #if ENABLED(SINGLENOZZLE_STANDBY_TEMP)
+        static celsius_t singlenozzle_temp[EXTRUDERS];
+      #endif
+      #if ENABLED(SINGLENOZZLE_STANDBY_FAN)
         static uint8_t singlenozzle_fan_speed[EXTRUDERS];
       #endif
       static void singlenozzle_change(const uint8_t old_tool, const uint8_t new_tool);
     #endif
 
     #if HEATER_IDLE_HANDLER
 
       // Heater idle handling. Marlin creates one per hotend and one for the heated bed.
       typedef struct {
         millis_t timeout_ms;

commit cfdfd167794de13de75d99c161f61a0898549717
Author: David <davidtgbe@hotmail.com>
Date:   Fri Apr 30 08:51:26 2021 +0200

    Fix Thermal Runaway false-alarm in M303, add HeaterWatch::check (#21743)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 2bb773f805..adc10c3ccd 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -226,20 +226,22 @@ struct PIDHeaterInfo : public HeaterInfo {
 #endif
 
 // Heater watch handling
 template <int INCREASE, int HYSTERESIS, millis_t PERIOD>
 struct HeaterWatch {
   celsius_t target;
   millis_t next_ms;
   inline bool elapsed(const millis_t &ms) { return next_ms && ELAPSED(ms, next_ms); }
   inline bool elapsed() { return elapsed(millis()); }
 
+  inline bool check(const celsius_t curr) { return curr >= target; }
+
   inline void restart(const celsius_t curr, const celsius_t tgt) {
     if (tgt) {
       const celsius_t newtarget = curr + INCREASE;
       if (newtarget < tgt - HYSTERESIS - 1) {
         target = newtarget;
         next_ms = millis() + SEC_TO_MS(PERIOD);
         return;
       }
     }
     next_ms = 0;

commit 5f9aac2027c241056c83d497054be91c64b086e7
Author: ellensp <ellensp@hotmail.com>
Date:   Tue Apr 27 16:36:39 2021 +1200

    Use temp_info_t for temp_redundant (#21715)
    
    Fixes #21712
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index b7d52e8a08..2bb773f805 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -314,22 +314,24 @@ typedef struct { int16_t raw_min, raw_max; celsius_t mintemp, maxtemp; } temp_ra
           beta, beta_recip;
   } user_thermistor_t;
 
 #endif
 
 class Temperature {
 
   public:
 
     #if HAS_HOTEND
-      #define HOTEND_TEMPS (HOTENDS + ENABLED(TEMP_SENSOR_1_AS_REDUNDANT))
-      static hotend_info_t temp_hotend[HOTEND_TEMPS];
+      #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
+        static temp_info_t temp_redundant;
+      #endif
+      static hotend_info_t temp_hotend[HOTENDS];
       static const celsius_t hotend_maxtemp[HOTENDS];
       static inline celsius_t hotend_max_target(const uint8_t e) { return hotend_maxtemp[e] - (HOTEND_OVERSHOOT); }
     #endif
     #if ENABLED(HAS_HEATED_BED)
       static bed_info_t temp_bed;
     #endif
     #if ENABLED(HAS_TEMP_PROBE)
       static probe_info_t temp_probe;
     #endif
     #if ENABLED(HAS_TEMP_CHAMBER)
@@ -416,25 +418,20 @@ class Temperature {
     #if ENABLED(EARLY_WATCHDOG)
       static bool inited;   // If temperature controller is running
     #endif
 
     static volatile bool raw_temps_ready;
 
     #if ENABLED(WATCH_HOTENDS)
       static hotend_watch_t watch_hotend[HOTENDS];
     #endif
 
-    #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
-      static uint16_t redundant_temperature_raw;
-      static celsius_t redundant_temperature;
-    #endif
-
     #if ENABLED(PID_EXTRUSION_SCALING)
       static int32_t last_e_position, lpq[LPQ_MAX_LEN];
       static lpq_ptr_t lpq_ptr;
     #endif
 
     #if ENABLED(HAS_HOTEND)
       static temp_range_t temp_range[HOTENDS];
     #endif
 
     #if HAS_HEATED_BED
@@ -494,21 +491,21 @@ class Temperature {
     void init();
 
     /**
      * Static (class) methods
      */
 
     #if HAS_USER_THERMISTORS
       static user_thermistor_t user_thermistor[USER_THERMISTORS];
       static void log_user_thermistor(const uint8_t t_index, const bool eprom=false);
       static void reset_user_thermistors();
-      static celsius_float_t user_thermistor_to_deg_c(const uint8_t t_index, const int raw);
+      static celsius_float_t user_thermistor_to_deg_c(const uint8_t t_index, const int16_t raw);
       static inline bool set_pull_up_res(int8_t t_index, float value) {
         //if (!WITHIN(t_index, 0, USER_THERMISTORS - 1)) return false;
         if (!WITHIN(value, 1, 1000000)) return false;
         user_thermistor[t_index].series_res = value;
         return true;
       }
       static inline bool set_res25(int8_t t_index, float value) {
         if (!WITHIN(value, 1, 10000000)) return false;
         user_thermistor[t_index].res_25 = value;
         user_thermistor[t_index].pre_calc = true;
@@ -522,33 +519,33 @@ class Temperature {
       }
       static inline bool set_sh_coeff(int8_t t_index, float value) {
         if (!WITHIN(value, -0.01f, 0.01f)) return false;
         user_thermistor[t_index].sh_c_coeff = value;
         user_thermistor[t_index].pre_calc = true;
         return true;
       }
     #endif
 
     #if HAS_HOTEND
-      static celsius_float_t analog_to_celsius_hotend(const int raw, const uint8_t e);
+      static celsius_float_t analog_to_celsius_hotend(const int16_t raw, const uint8_t e);
     #endif
     #if HAS_HEATED_BED
-      static celsius_float_t analog_to_celsius_bed(const int raw);
+      static celsius_float_t analog_to_celsius_bed(const int16_t raw);
     #endif
     #if HAS_TEMP_PROBE
-      static celsius_float_t analog_to_celsius_probe(const int raw);
+      static celsius_float_t analog_to_celsius_probe(const int16_t raw);
     #endif
     #if HAS_TEMP_CHAMBER
-      static celsius_float_t analog_to_celsius_chamber(const int raw);
+      static celsius_float_t analog_to_celsius_chamber(const int16_t raw);
     #endif
     #if HAS_TEMP_COOLER
-      static celsius_float_t analog_to_celsius_cooler(const int raw);
+      static celsius_float_t analog_to_celsius_cooler(const int16_t raw);
     #endif
 
     #if HAS_FAN
 
       static uint8_t fan_speed[FAN_COUNT];
       #define FANS_LOOP(I) LOOP_L_N(I, FAN_COUNT)
 
       static void set_fan_speed(const uint8_t fan, const uint16_t speed);
 
       #if ENABLED(REPORT_FAN_CHANGE)
@@ -624,28 +621,35 @@ class Temperature {
     #endif
 
     //high level conversion routines, for use outside of temperature.cpp
     //inline so that there is no performance decrease.
     //deg=degreeCelsius
 
     static inline celsius_float_t degHotend(const uint8_t E_NAME) {
       return TERN0(HAS_HOTEND, temp_hotend[HOTEND_INDEX].celsius);
     }
 
+    #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
+      static inline celsius_float_t degHotendRedundant() { return temp_redundant.celsius; }
+    #endif
+
     static inline celsius_t wholeDegHotend(const uint8_t E_NAME) {
       return TERN0(HAS_HOTEND, static_cast<celsius_t>(temp_hotend[HOTEND_INDEX].celsius + 0.5f));
     }
 
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       static inline int16_t rawHotendTemp(const uint8_t E_NAME) {
         return TERN0(HAS_HOTEND, temp_hotend[HOTEND_INDEX].raw);
       }
+      #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
+        static inline int16_t rawHotendTempRedundant() { return temp_redundant.raw; }
+      #endif
     #endif
 
     static inline celsius_t degTargetHotend(const uint8_t E_NAME) {
       return TERN0(HAS_HOTEND, temp_hotend[HOTEND_INDEX].target);
     }
 
     #if WATCH_HOTENDS
       static void start_watching_hotend(const uint8_t e=0);
     #else
       static inline void start_watching_hotend(const uint8_t=0) {}

commit 46f272b66945e4f2fb6e191b83cebeaa57e496f5
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Fri Apr 23 22:29:15 2021 -0300

    Fix Celsius precision, current temp accessors (#21678)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index a7d41b36f9..b7d52e8a08 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -172,21 +172,21 @@ enum ADCSensorState : char {
 #endif
 
 #if BOTH(HAS_LCD_MENU, G26_MESH_VALIDATION)
   #define G26_CLICK_CAN_CANCEL 1
 #endif
 
 // A temperature sensor
 typedef struct TempInfo {
   uint16_t acc;
   int16_t raw;
-  celsius_t celsius;
+  celsius_float_t celsius;
   inline void reset() { acc = 0; }
   inline void sample(const uint16_t s) { acc += s; }
   inline void update() { raw = acc; }
 } temp_info_t;
 
 // A PWM heater with temperature sensor
 typedef struct HeaterInfo : public TempInfo {
   celsius_t target;
   uint8_t soft_pwm_amount;
 } heater_info_t;
@@ -494,21 +494,21 @@ class Temperature {
     void init();
 
     /**
      * Static (class) methods
      */
 
     #if HAS_USER_THERMISTORS
       static user_thermistor_t user_thermistor[USER_THERMISTORS];
       static void log_user_thermistor(const uint8_t t_index, const bool eprom=false);
       static void reset_user_thermistors();
-      static celsius_t user_thermistor_to_deg_c(const uint8_t t_index, const int raw);
+      static celsius_float_t user_thermistor_to_deg_c(const uint8_t t_index, const int raw);
       static inline bool set_pull_up_res(int8_t t_index, float value) {
         //if (!WITHIN(t_index, 0, USER_THERMISTORS - 1)) return false;
         if (!WITHIN(value, 1, 1000000)) return false;
         user_thermistor[t_index].series_res = value;
         return true;
       }
       static inline bool set_res25(int8_t t_index, float value) {
         if (!WITHIN(value, 1, 10000000)) return false;
         user_thermistor[t_index].res_25 = value;
         user_thermistor[t_index].pre_calc = true;
@@ -522,33 +522,33 @@ class Temperature {
       }
       static inline bool set_sh_coeff(int8_t t_index, float value) {
         if (!WITHIN(value, -0.01f, 0.01f)) return false;
         user_thermistor[t_index].sh_c_coeff = value;
         user_thermistor[t_index].pre_calc = true;
         return true;
       }
     #endif
 
     #if HAS_HOTEND
-      static celsius_t analog_to_celsius_hotend(const int raw, const uint8_t e);
+      static celsius_float_t analog_to_celsius_hotend(const int raw, const uint8_t e);
     #endif
     #if HAS_HEATED_BED
-      static celsius_t analog_to_celsius_bed(const int raw);
+      static celsius_float_t analog_to_celsius_bed(const int raw);
     #endif
     #if HAS_TEMP_PROBE
-      static celsius_t analog_to_celsius_probe(const int raw);
+      static celsius_float_t analog_to_celsius_probe(const int raw);
     #endif
     #if HAS_TEMP_CHAMBER
-      static celsius_t analog_to_celsius_chamber(const int raw);
+      static celsius_float_t analog_to_celsius_chamber(const int raw);
     #endif
     #if HAS_TEMP_COOLER
-      static celsius_t analog_to_celsius_cooler(const int raw);
+      static celsius_float_t analog_to_celsius_cooler(const int raw);
     #endif
 
     #if HAS_FAN
 
       static uint8_t fan_speed[FAN_COUNT];
       #define FANS_LOOP(I) LOOP_L_N(I, FAN_COUNT)
 
       static void set_fan_speed(const uint8_t fan, const uint16_t speed);
 
       #if ENABLED(REPORT_FAN_CHANGE)
@@ -620,21 +620,21 @@ class Temperature {
         preheat_end_time[HOTEND_INDEX] = 0;
       }
     #else
       #define is_preheating(n) (false)
     #endif
 
     //high level conversion routines, for use outside of temperature.cpp
     //inline so that there is no performance decrease.
     //deg=degreeCelsius
 
-    static inline celsius_t degHotend(const uint8_t E_NAME) {
+    static inline celsius_float_t degHotend(const uint8_t E_NAME) {
       return TERN0(HAS_HOTEND, temp_hotend[HOTEND_INDEX].celsius);
     }
 
     static inline celsius_t wholeDegHotend(const uint8_t E_NAME) {
       return TERN0(HAS_HOTEND, static_cast<celsius_t>(temp_hotend[HOTEND_INDEX].celsius + 0.5f));
     }
 
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       static inline int16_t rawHotendTemp(const uint8_t E_NAME) {
         return TERN0(HAS_HOTEND, temp_hotend[HOTEND_INDEX].raw);
@@ -694,21 +694,21 @@ class Temperature {
         return ABS(wholeDegHotend(e) - temp) < (TEMP_HYSTERESIS);
       }
 
     #endif // HAS_HOTEND
 
     #if HAS_HEATED_BED
 
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         static inline int16_t rawBedTemp()    { return temp_bed.raw; }
       #endif
-      static inline celsius_t degBed()        { return temp_bed.celsius; }
+      static inline celsius_float_t degBed()  { return temp_bed.celsius; }
       static inline celsius_t wholeDegBed()   { return static_cast<celsius_t>(degBed() + 0.5f); }
       static inline celsius_t degTargetBed()  { return temp_bed.target; }
       static inline bool isHeatingBed()       { return temp_bed.target > temp_bed.celsius; }
       static inline bool isCoolingBed()       { return temp_bed.target < temp_bed.celsius; }
 
       #if WATCH_BED
         static void start_watching_bed();
       #else
         static inline void start_watching_bed() {}
       #endif
@@ -730,38 +730,38 @@ class Temperature {
       static inline bool degBedNear(const celsius_t temp) {
         return ABS(wholeDegBed() - temp) < (TEMP_BED_HYSTERESIS);
       }
 
     #endif // HAS_HEATED_BED
 
     #if HAS_TEMP_PROBE
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         static inline int16_t rawProbeTemp()    { return temp_probe.raw; }
       #endif
-      static inline celsius_t degProbe()        { return temp_probe.celsius; }
+      static inline celsius_float_t degProbe()  { return temp_probe.celsius; }
       static inline celsius_t wholeDegProbe()   { return static_cast<celsius_t>(degProbe() + 0.5f); }
       static inline bool isProbeBelowTemp(const celsius_t target_temp) { return wholeDegProbe() < target_temp; }
       static inline bool isProbeAboveTemp(const celsius_t target_temp) { return wholeDegProbe() > target_temp; }
       static bool wait_for_probe(const celsius_t target_temp, bool no_wait_for_cooling=true);
     #endif
 
     #if WATCH_PROBE
       static void start_watching_probe();
     #else
       static inline void start_watching_probe() {}
     #endif
 
     #if HAS_TEMP_CHAMBER
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         static inline int16_t rawChamberTemp()      { return temp_chamber.raw; }
       #endif
-      static inline celsius_t degChamber()          { return temp_chamber.celsius; }
+      static inline celsius_float_t degChamber()    { return temp_chamber.celsius; }
       static inline celsius_t wholeDegChamber()     { return static_cast<celsius_t>(degChamber() + 0.5f); }
       #if HAS_HEATED_CHAMBER
         static inline celsius_t degTargetChamber()  { return temp_chamber.target; }
         static inline bool isHeatingChamber()       { return temp_chamber.target > temp_chamber.celsius; }
         static inline bool isCoolingChamber()       { return temp_chamber.target < temp_chamber.celsius; }
         static bool wait_for_chamber(const bool no_wait_for_cooling=true);
       #endif
     #endif
 
     #if WATCH_CHAMBER
@@ -774,21 +774,21 @@ class Temperature {
       static void setTargetChamber(const celsius_t celsius) {
         temp_chamber.target = _MIN(celsius, CHAMBER_MAX_TARGET);
         start_watching_chamber();
       }
     #endif
 
     #if HAS_TEMP_COOLER
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         static inline int16_t rawCoolerTemp()     { return temp_cooler.raw; }
       #endif
-      static inline celsius_t degCooler()         { return temp_cooler.celsius; }
+      static inline celsius_float_t degCooler()   { return temp_cooler.celsius; }
       static inline celsius_t wholeDegCooler()    { return static_cast<celsius_t>(temp_cooler.celsius + 0.5f); }
       #if HAS_COOLER
         static inline celsius_t degTargetCooler() { return temp_cooler.target; }
         static inline bool isLaserHeating()       { return temp_cooler.target > temp_cooler.celsius; }
         static inline bool isLaserCooling()       { return temp_cooler.target < temp_cooler.celsius; }
         static bool wait_for_cooler(const bool no_wait_for_cooling=true);
       #endif
     #endif
 
     #if WATCH_COOLER

commit c4620bb5285438e41fa4c39229aa2a39859877ca
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Apr 23 20:19:23 2021 -0500

    Add whole-degree accessors, simplify some temperature-related features (#21685)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 318cdaf075..a7d41b36f9 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -351,26 +351,22 @@ class Temperature {
 
     #if ENABLED(FAN_SOFT_PWM)
       static uint8_t soft_pwm_amount_fan[FAN_COUNT],
                      soft_pwm_count_fan[FAN_COUNT];
     #endif
 
     #if ENABLED(PREVENT_COLD_EXTRUSION)
       static bool allow_cold_extrude;
       static celsius_t extrude_min_temp;
       static inline bool tooCold(const celsius_t temp) { return allow_cold_extrude ? false : temp < extrude_min_temp - (TEMP_WINDOW); }
-      static inline bool tooColdToExtrude(const uint8_t E_NAME) {
-        return tooCold(degHotend(HOTEND_INDEX));
-      }
-      static inline bool targetTooColdToExtrude(const uint8_t E_NAME) {
-        return tooCold(degTargetHotend(HOTEND_INDEX));
-      }
+      static inline bool tooColdToExtrude(const uint8_t E_NAME)       { return tooCold(wholeDegHotend(HOTEND_INDEX)); }
+      static inline bool targetTooColdToExtrude(const uint8_t E_NAME) { return tooCold(degTargetHotend(HOTEND_INDEX)); }
     #else
       static inline bool tooColdToExtrude(const uint8_t) { return false; }
       static inline bool targetTooColdToExtrude(const uint8_t) { return false; }
     #endif
 
     static inline bool hotEnoughToExtrude(const uint8_t e) { return !tooColdToExtrude(e); }
     static inline bool targetHotEnoughToExtrude(const uint8_t e) { return !targetTooColdToExtrude(e); }
 
     #if ENABLED(SINGLENOZZLE_STANDBY_FAN)
       static celsius_t singlenozzle_temp[EXTRUDERS];
@@ -628,20 +624,24 @@ class Temperature {
     #endif
 
     //high level conversion routines, for use outside of temperature.cpp
     //inline so that there is no performance decrease.
     //deg=degreeCelsius
 
     static inline celsius_t degHotend(const uint8_t E_NAME) {
       return TERN0(HAS_HOTEND, temp_hotend[HOTEND_INDEX].celsius);
     }
 
+    static inline celsius_t wholeDegHotend(const uint8_t E_NAME) {
+      return TERN0(HAS_HOTEND, static_cast<celsius_t>(temp_hotend[HOTEND_INDEX].celsius + 0.5f));
+    }
+
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       static inline int16_t rawHotendTemp(const uint8_t E_NAME) {
         return TERN0(HAS_HOTEND, temp_hotend[HOTEND_INDEX].raw);
       }
     #endif
 
     static inline celsius_t degTargetHotend(const uint8_t E_NAME) {
       return TERN0(HAS_HOTEND, temp_hotend[HOTEND_INDEX].target);
     }
 
@@ -680,35 +680,36 @@ class Temperature {
             , const bool click_to_cancel=false
           #endif
         );
 
         #if ENABLED(WAIT_FOR_HOTEND)
           static void wait_for_hotend_heating(const uint8_t target_extruder);
         #endif
       #endif
 
       static inline bool still_heating(const uint8_t e) {
-        return degTargetHotend(e) > TEMP_HYSTERESIS && ABS(degHotend(e) - degTargetHotend(e)) > TEMP_HYSTERESIS;
+        return degTargetHotend(e) > TEMP_HYSTERESIS && ABS(wholeDegHotend(e) - degTargetHotend(e)) > TEMP_HYSTERESIS;
       }
 
-      static inline bool degHotendNear(const uint8_t e, const_float_t temp) {
-        return ABS(degHotend(e) - temp) < (TEMP_HYSTERESIS);
+      static inline bool degHotendNear(const uint8_t e, const celsius_t temp) {
+        return ABS(wholeDegHotend(e) - temp) < (TEMP_HYSTERESIS);
       }
 
     #endif // HAS_HOTEND
 
     #if HAS_HEATED_BED
 
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         static inline int16_t rawBedTemp()    { return temp_bed.raw; }
       #endif
       static inline celsius_t degBed()        { return temp_bed.celsius; }
+      static inline celsius_t wholeDegBed()   { return static_cast<celsius_t>(degBed() + 0.5f); }
       static inline celsius_t degTargetBed()  { return temp_bed.target; }
       static inline bool isHeatingBed()       { return temp_bed.target > temp_bed.celsius; }
       static inline bool isCoolingBed()       { return temp_bed.target < temp_bed.celsius; }
 
       #if WATCH_BED
         static void start_watching_bed();
       #else
         static inline void start_watching_bed() {}
       #endif
 
@@ -719,47 +720,49 @@ class Temperature {
       }
 
       static bool wait_for_bed(const bool no_wait_for_cooling=true
         #if G26_CLICK_CAN_CANCEL
           , const bool click_to_cancel=false
         #endif
       );
 
       static void wait_for_bed_heating();
 
-      static inline bool degBedNear(const_float_t temp) {
-        return ABS(degBed() - temp) < (TEMP_BED_HYSTERESIS);
+      static inline bool degBedNear(const celsius_t temp) {
+        return ABS(wholeDegBed() - temp) < (TEMP_BED_HYSTERESIS);
       }
 
     #endif // HAS_HEATED_BED
 
     #if HAS_TEMP_PROBE
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         static inline int16_t rawProbeTemp()    { return temp_probe.raw; }
       #endif
       static inline celsius_t degProbe()        { return temp_probe.celsius; }
-      static inline bool isProbeBelowTemp(const_float_t target_temp) { return temp_probe.celsius < target_temp; }
-      static inline bool isProbeAboveTemp(const_float_t target_temp) { return temp_probe.celsius > target_temp; }
-      static bool wait_for_probe(const_float_t target_temp, bool no_wait_for_cooling=true);
+      static inline celsius_t wholeDegProbe()   { return static_cast<celsius_t>(degProbe() + 0.5f); }
+      static inline bool isProbeBelowTemp(const celsius_t target_temp) { return wholeDegProbe() < target_temp; }
+      static inline bool isProbeAboveTemp(const celsius_t target_temp) { return wholeDegProbe() > target_temp; }
+      static bool wait_for_probe(const celsius_t target_temp, bool no_wait_for_cooling=true);
     #endif
 
     #if WATCH_PROBE
       static void start_watching_probe();
     #else
       static inline void start_watching_probe() {}
     #endif
 
     #if HAS_TEMP_CHAMBER
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         static inline int16_t rawChamberTemp()      { return temp_chamber.raw; }
       #endif
       static inline celsius_t degChamber()          { return temp_chamber.celsius; }
+      static inline celsius_t wholeDegChamber()     { return static_cast<celsius_t>(degChamber() + 0.5f); }
       #if HAS_HEATED_CHAMBER
         static inline celsius_t degTargetChamber()  { return temp_chamber.target; }
         static inline bool isHeatingChamber()       { return temp_chamber.target > temp_chamber.celsius; }
         static inline bool isCoolingChamber()       { return temp_chamber.target < temp_chamber.celsius; }
         static bool wait_for_chamber(const bool no_wait_for_cooling=true);
       #endif
     #endif
 
     #if WATCH_CHAMBER
       static void start_watching_chamber();
@@ -772,20 +775,21 @@ class Temperature {
         temp_chamber.target = _MIN(celsius, CHAMBER_MAX_TARGET);
         start_watching_chamber();
       }
     #endif
 
     #if HAS_TEMP_COOLER
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         static inline int16_t rawCoolerTemp()     { return temp_cooler.raw; }
       #endif
       static inline celsius_t degCooler()         { return temp_cooler.celsius; }
+      static inline celsius_t wholeDegCooler()    { return static_cast<celsius_t>(temp_cooler.celsius + 0.5f); }
       #if HAS_COOLER
         static inline celsius_t degTargetCooler() { return temp_cooler.target; }
         static inline bool isLaserHeating()       { return temp_cooler.target > temp_cooler.celsius; }
         static inline bool isLaserCooling()       { return temp_cooler.target < temp_cooler.celsius; }
         static bool wait_for_cooler(const bool no_wait_for_cooling=true);
       #endif
     #endif
 
     #if WATCH_COOLER
       static void start_watching_cooler();
@@ -820,21 +824,21 @@ class Temperature {
 
     /**
      * Perform auto-tuning for hotend or bed in response to M303
      */
     #if HAS_PID_HEATING
 
       #if ANY(PID_DEBUG, PID_BED_DEBUG, PID_CHAMBER_DEBUG)
         static bool pid_debug_flag;
       #endif
 
-      static void PID_autotune(const_float_t target, const heater_id_t heater_id, const int8_t ncycles, const bool set_result=false);
+      static void PID_autotune(const celsius_t target, const heater_id_t heater_id, const int8_t ncycles, const bool set_result=false);
 
       #if ENABLED(NO_FAN_SLOWING_IN_PID_TUNING)
         static bool adaptive_fan_slowing;
       #elif ENABLED(ADAPTIVE_FAN_SLOWING)
         static constexpr bool adaptive_fan_slowing = true;
       #endif
 
       /**
        * Update the temp manager when PID values change
        */

commit 54ad22a4553404e6c777bd0d4794e7edba23152f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Apr 23 19:36:43 2021 -0500

    Let compiler do Temperature inlining

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 0335733924..318cdaf075 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -317,21 +317,21 @@ typedef struct { int16_t raw_min, raw_max; celsius_t mintemp, maxtemp; } temp_ra
 #endif
 
 class Temperature {
 
   public:
 
     #if HAS_HOTEND
       #define HOTEND_TEMPS (HOTENDS + ENABLED(TEMP_SENSOR_1_AS_REDUNDANT))
       static hotend_info_t temp_hotend[HOTEND_TEMPS];
       static const celsius_t hotend_maxtemp[HOTENDS];
-      FORCE_INLINE static celsius_t hotend_max_target(const uint8_t e) { return hotend_maxtemp[e] - (HOTEND_OVERSHOOT); }
+      static inline celsius_t hotend_max_target(const uint8_t e) { return hotend_maxtemp[e] - (HOTEND_OVERSHOOT); }
     #endif
     #if ENABLED(HAS_HEATED_BED)
       static bed_info_t temp_bed;
     #endif
     #if ENABLED(HAS_TEMP_PROBE)
       static probe_info_t temp_probe;
     #endif
     #if ENABLED(HAS_TEMP_CHAMBER)
       static chamber_info_t temp_chamber;
     #endif
@@ -350,34 +350,34 @@ class Temperature {
     #endif
 
     #if ENABLED(FAN_SOFT_PWM)
       static uint8_t soft_pwm_amount_fan[FAN_COUNT],
                      soft_pwm_count_fan[FAN_COUNT];
     #endif
 
     #if ENABLED(PREVENT_COLD_EXTRUSION)
       static bool allow_cold_extrude;
       static celsius_t extrude_min_temp;
-      FORCE_INLINE static bool tooCold(const celsius_t temp) { return allow_cold_extrude ? false : temp < extrude_min_temp - (TEMP_WINDOW); }
-      FORCE_INLINE static bool tooColdToExtrude(const uint8_t E_NAME) {
+      static inline bool tooCold(const celsius_t temp) { return allow_cold_extrude ? false : temp < extrude_min_temp - (TEMP_WINDOW); }
+      static inline bool tooColdToExtrude(const uint8_t E_NAME) {
         return tooCold(degHotend(HOTEND_INDEX));
       }
-      FORCE_INLINE static bool targetTooColdToExtrude(const uint8_t E_NAME) {
+      static inline bool targetTooColdToExtrude(const uint8_t E_NAME) {
         return tooCold(degTargetHotend(HOTEND_INDEX));
       }
     #else
-      FORCE_INLINE static bool tooColdToExtrude(const uint8_t) { return false; }
-      FORCE_INLINE static bool targetTooColdToExtrude(const uint8_t) { return false; }
+      static inline bool tooColdToExtrude(const uint8_t) { return false; }
+      static inline bool targetTooColdToExtrude(const uint8_t) { return false; }
     #endif
 
-    FORCE_INLINE static bool hotEnoughToExtrude(const uint8_t e) { return !tooColdToExtrude(e); }
-    FORCE_INLINE static bool targetHotEnoughToExtrude(const uint8_t e) { return !targetTooColdToExtrude(e); }
+    static inline bool hotEnoughToExtrude(const uint8_t e) { return !tooColdToExtrude(e); }
+    static inline bool targetHotEnoughToExtrude(const uint8_t e) { return !targetTooColdToExtrude(e); }
 
     #if ENABLED(SINGLENOZZLE_STANDBY_FAN)
       static celsius_t singlenozzle_temp[EXTRUDERS];
       #if HAS_FAN
         static uint8_t singlenozzle_fan_speed[EXTRUDERS];
       #endif
       static void singlenozzle_change(const uint8_t old_tool, const uint8_t new_tool);
     #endif
 
     #if HEATER_IDLE_HANDLER
@@ -499,39 +499,39 @@ class Temperature {
 
     /**
      * Static (class) methods
      */
 
     #if HAS_USER_THERMISTORS
       static user_thermistor_t user_thermistor[USER_THERMISTORS];
       static void log_user_thermistor(const uint8_t t_index, const bool eprom=false);
       static void reset_user_thermistors();
       static celsius_t user_thermistor_to_deg_c(const uint8_t t_index, const int raw);
-      static bool set_pull_up_res(int8_t t_index, float value) {
+      static inline bool set_pull_up_res(int8_t t_index, float value) {
         //if (!WITHIN(t_index, 0, USER_THERMISTORS - 1)) return false;
         if (!WITHIN(value, 1, 1000000)) return false;
         user_thermistor[t_index].series_res = value;
         return true;
       }
-      static bool set_res25(int8_t t_index, float value) {
+      static inline bool set_res25(int8_t t_index, float value) {
         if (!WITHIN(value, 1, 10000000)) return false;
         user_thermistor[t_index].res_25 = value;
         user_thermistor[t_index].pre_calc = true;
         return true;
       }
-      static bool set_beta(int8_t t_index, float value) {
+      static inline bool set_beta(int8_t t_index, float value) {
         if (!WITHIN(value, 1, 1000000)) return false;
         user_thermistor[t_index].beta = value;
         user_thermistor[t_index].pre_calc = true;
         return true;
       }
-      static bool set_sh_coeff(int8_t t_index, float value) {
+      static inline bool set_sh_coeff(int8_t t_index, float value) {
         if (!WITHIN(value, -0.01f, 0.01f)) return false;
         user_thermistor[t_index].sh_c_coeff = value;
         user_thermistor[t_index].pre_calc = true;
         return true;
       }
     #endif
 
     #if HAS_HOTEND
       static celsius_t analog_to_celsius_hotend(const int raw, const uint8_t e);
     #endif
@@ -607,48 +607,48 @@ class Temperature {
 
     /**
      * Call periodically to manage heaters
      */
     static void manage_heater() _O2; // Added _O2 to work around a compiler error
 
     /**
      * Preheating hotends
      */
     #ifdef MILLISECONDS_PREHEAT_TIME
-      static bool is_preheating(const uint8_t E_NAME) {
+      static inline bool is_preheating(const uint8_t E_NAME) {
         return preheat_end_time[HOTEND_INDEX] && PENDING(millis(), preheat_end_time[HOTEND_INDEX]);
       }
-      static void start_preheat_time(const uint8_t E_NAME) {
+      static inline void start_preheat_time(const uint8_t E_NAME) {
         preheat_end_time[HOTEND_INDEX] = millis() + MILLISECONDS_PREHEAT_TIME;
       }
-      static void reset_preheat_time(const uint8_t E_NAME) {
+      static inline void reset_preheat_time(const uint8_t E_NAME) {
         preheat_end_time[HOTEND_INDEX] = 0;
       }
     #else
       #define is_preheating(n) (false)
     #endif
 
     //high level conversion routines, for use outside of temperature.cpp
     //inline so that there is no performance decrease.
     //deg=degreeCelsius
 
-    FORCE_INLINE static celsius_t degHotend(const uint8_t E_NAME) {
+    static inline celsius_t degHotend(const uint8_t E_NAME) {
       return TERN0(HAS_HOTEND, temp_hotend[HOTEND_INDEX].celsius);
     }
 
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
-      FORCE_INLINE static int16_t rawHotendTemp(const uint8_t E_NAME) {
+      static inline int16_t rawHotendTemp(const uint8_t E_NAME) {
         return TERN0(HAS_HOTEND, temp_hotend[HOTEND_INDEX].raw);
       }
     #endif
 
-    FORCE_INLINE static celsius_t degTargetHotend(const uint8_t E_NAME) {
+    static inline celsius_t degTargetHotend(const uint8_t E_NAME) {
       return TERN0(HAS_HOTEND, temp_hotend[HOTEND_INDEX].target);
     }
 
     #if WATCH_HOTENDS
       static void start_watching_hotend(const uint8_t e=0);
     #else
       static inline void start_watching_hotend(const uint8_t=0) {}
     #endif
 
     #if HAS_HOTEND
@@ -659,59 +659,59 @@ class Temperature {
           if (celsius == 0)
             reset_preheat_time(ee);
           else if (temp_hotend[ee].target == 0)
             start_preheat_time(ee);
         #endif
         TERN_(AUTO_POWER_CONTROL, if (celsius) powerManager.power_on());
         temp_hotend[ee].target = _MIN(celsius, hotend_max_target(ee));
         start_watching_hotend(ee);
       }
 
-      FORCE_INLINE static bool isHeatingHotend(const uint8_t E_NAME) {
+      static inline bool isHeatingHotend(const uint8_t E_NAME) {
         return temp_hotend[HOTEND_INDEX].target > temp_hotend[HOTEND_INDEX].celsius;
       }
 
-      FORCE_INLINE static bool isCoolingHotend(const uint8_t E_NAME) {
+      static inline bool isCoolingHotend(const uint8_t E_NAME) {
         return temp_hotend[HOTEND_INDEX].target < temp_hotend[HOTEND_INDEX].celsius;
       }
 
       #if HAS_TEMP_HOTEND
         static bool wait_for_hotend(const uint8_t target_extruder, const bool no_wait_for_cooling=true
           #if G26_CLICK_CAN_CANCEL
             , const bool click_to_cancel=false
           #endif
         );
 
         #if ENABLED(WAIT_FOR_HOTEND)
           static void wait_for_hotend_heating(const uint8_t target_extruder);
         #endif
       #endif
 
-      FORCE_INLINE static bool still_heating(const uint8_t e) {
+      static inline bool still_heating(const uint8_t e) {
         return degTargetHotend(e) > TEMP_HYSTERESIS && ABS(degHotend(e) - degTargetHotend(e)) > TEMP_HYSTERESIS;
       }
 
-      FORCE_INLINE static bool degHotendNear(const uint8_t e, const_float_t temp) {
+      static inline bool degHotendNear(const uint8_t e, const_float_t temp) {
         return ABS(degHotend(e) - temp) < (TEMP_HYSTERESIS);
       }
 
     #endif // HAS_HOTEND
 
     #if HAS_HEATED_BED
 
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
-        FORCE_INLINE static int16_t rawBedTemp()    { return temp_bed.raw; }
+        static inline int16_t rawBedTemp()    { return temp_bed.raw; }
       #endif
-      FORCE_INLINE static celsius_t degBed()        { return temp_bed.celsius; }
-      FORCE_INLINE static celsius_t degTargetBed()  { return temp_bed.target; }
-      FORCE_INLINE static bool isHeatingBed()       { return temp_bed.target > temp_bed.celsius; }
-      FORCE_INLINE static bool isCoolingBed()       { return temp_bed.target < temp_bed.celsius; }
+      static inline celsius_t degBed()        { return temp_bed.celsius; }
+      static inline celsius_t degTargetBed()  { return temp_bed.target; }
+      static inline bool isHeatingBed()       { return temp_bed.target > temp_bed.celsius; }
+      static inline bool isCoolingBed()       { return temp_bed.target < temp_bed.celsius; }
 
       #if WATCH_BED
         static void start_watching_bed();
       #else
         static inline void start_watching_bed() {}
       #endif
 
       static void setTargetBed(const celsius_t celsius) {
         TERN_(AUTO_POWER_CONTROL, if (celsius) powerManager.power_on());
         temp_bed.target = _MIN(celsius, BED_MAX_TARGET);
@@ -719,89 +719,89 @@ class Temperature {
       }
 
       static bool wait_for_bed(const bool no_wait_for_cooling=true
         #if G26_CLICK_CAN_CANCEL
           , const bool click_to_cancel=false
         #endif
       );
 
       static void wait_for_bed_heating();
 
-      FORCE_INLINE static bool degBedNear(const_float_t temp) {
+      static inline bool degBedNear(const_float_t temp) {
         return ABS(degBed() - temp) < (TEMP_BED_HYSTERESIS);
       }
 
     #endif // HAS_HEATED_BED
 
     #if HAS_TEMP_PROBE
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
-        FORCE_INLINE static int16_t rawProbeTemp()    { return temp_probe.raw; }
+        static inline int16_t rawProbeTemp()    { return temp_probe.raw; }
       #endif
-      FORCE_INLINE static celsius_t degProbe()        { return temp_probe.celsius; }
-      FORCE_INLINE static bool isProbeBelowTemp(const_float_t target_temp) { return temp_probe.celsius < target_temp; }
-      FORCE_INLINE static bool isProbeAboveTemp(const_float_t target_temp) { return temp_probe.celsius > target_temp; }
+      static inline celsius_t degProbe()        { return temp_probe.celsius; }
+      static inline bool isProbeBelowTemp(const_float_t target_temp) { return temp_probe.celsius < target_temp; }
+      static inline bool isProbeAboveTemp(const_float_t target_temp) { return temp_probe.celsius > target_temp; }
       static bool wait_for_probe(const_float_t target_temp, bool no_wait_for_cooling=true);
     #endif
 
     #if WATCH_PROBE
       static void start_watching_probe();
     #else
       static inline void start_watching_probe() {}
     #endif
 
     #if HAS_TEMP_CHAMBER
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
-        FORCE_INLINE static int16_t rawChamberTemp()      { return temp_chamber.raw; }
+        static inline int16_t rawChamberTemp()      { return temp_chamber.raw; }
       #endif
-      FORCE_INLINE static celsius_t degChamber()          { return temp_chamber.celsius; }
+      static inline celsius_t degChamber()          { return temp_chamber.celsius; }
       #if HAS_HEATED_CHAMBER
-        FORCE_INLINE static celsius_t degTargetChamber()  { return temp_chamber.target; }
-        FORCE_INLINE static bool isHeatingChamber()       { return temp_chamber.target > temp_chamber.celsius; }
-        FORCE_INLINE static bool isCoolingChamber()       { return temp_chamber.target < temp_chamber.celsius; }
+        static inline celsius_t degTargetChamber()  { return temp_chamber.target; }
+        static inline bool isHeatingChamber()       { return temp_chamber.target > temp_chamber.celsius; }
+        static inline bool isCoolingChamber()       { return temp_chamber.target < temp_chamber.celsius; }
         static bool wait_for_chamber(const bool no_wait_for_cooling=true);
       #endif
     #endif
 
     #if WATCH_CHAMBER
       static void start_watching_chamber();
     #else
       static inline void start_watching_chamber() {}
     #endif
 
     #if HAS_HEATED_CHAMBER
       static void setTargetChamber(const celsius_t celsius) {
         temp_chamber.target = _MIN(celsius, CHAMBER_MAX_TARGET);
         start_watching_chamber();
       }
     #endif
 
     #if HAS_TEMP_COOLER
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
-        FORCE_INLINE static int16_t rawCoolerTemp()     { return temp_cooler.raw; }
+        static inline int16_t rawCoolerTemp()     { return temp_cooler.raw; }
       #endif
-      FORCE_INLINE static celsius_t degCooler()         { return temp_cooler.celsius; }
+      static inline celsius_t degCooler()         { return temp_cooler.celsius; }
       #if HAS_COOLER
-        FORCE_INLINE static celsius_t degTargetCooler() { return temp_cooler.target; }
-        FORCE_INLINE static bool isLaserHeating()       { return temp_cooler.target > temp_cooler.celsius; }
-        FORCE_INLINE static bool isLaserCooling()       { return temp_cooler.target < temp_cooler.celsius; }
+        static inline celsius_t degTargetCooler() { return temp_cooler.target; }
+        static inline bool isLaserHeating()       { return temp_cooler.target > temp_cooler.celsius; }
+        static inline bool isLaserCooling()       { return temp_cooler.target < temp_cooler.celsius; }
         static bool wait_for_cooler(const bool no_wait_for_cooling=true);
       #endif
     #endif
 
     #if WATCH_COOLER
       static void start_watching_cooler();
     #else
       static inline void start_watching_cooler() {}
     #endif
 
     #if HAS_COOLER
-      static void setTargetCooler(const celsius_t celsius) {
+      static inline void setTargetCooler(const celsius_t celsius) {
         temp_cooler.target = constrain(celsius, COOLER_MIN_TARGET, COOLER_MAX_TARGET);
         start_watching_cooler();
       }
     #endif
 
     /**
      * The software PWM power for a heater
      */
     static int16_t getHeaterPower(const heater_id_t heater_id);
 
@@ -832,41 +832,41 @@ class Temperature {
       #if ENABLED(NO_FAN_SLOWING_IN_PID_TUNING)
         static bool adaptive_fan_slowing;
       #elif ENABLED(ADAPTIVE_FAN_SLOWING)
         static constexpr bool adaptive_fan_slowing = true;
       #endif
 
       /**
        * Update the temp manager when PID values change
        */
       #if ENABLED(PIDTEMP)
-        FORCE_INLINE static void updatePID() {
+        static inline void updatePID() {
           TERN_(PID_EXTRUSION_SCALING, last_e_position = 0);
         }
       #endif
 
     #endif
 
     #if ENABLED(PROBING_HEATERS_OFF)
       static void pause(const bool p);
-      FORCE_INLINE static bool is_paused() { return paused; }
+      static inline bool is_paused() { return paused; }
     #endif
 
     #if HEATER_IDLE_HANDLER
 
-      static void reset_hotend_idle_timer(const uint8_t E_NAME) {
+      static inline void reset_hotend_idle_timer(const uint8_t E_NAME) {
         heater_idle[HOTEND_INDEX].reset();
         start_watching_hotend(HOTEND_INDEX);
       }
 
       #if HAS_HEATED_BED
-        static void reset_bed_idle_timer() {
+        static inline void reset_bed_idle_timer() {
           heater_idle[IDLE_INDEX_BED].reset();
           start_watching_bed();
         }
       #endif
 
     #endif // HEATER_IDLE_HANDLER
 
     #if HAS_TEMP_SENSOR
       static void print_heater_states(const uint8_t target_extruder
         #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)

commit 72e3d2492f2085efe9c5fb0b33d67c24baf8a4bc
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Apr 23 19:14:49 2021 -0500

    Update temperature types

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index d2b3db8747..0335733924 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -954,19 +954,19 @@ class Temperature {
         #endif
         return (RunawayIndex)_MAX(heater_id, 0);
       }
 
       enum TRState : char { TRInactive, TRFirstHeating, TRStable, TRRunaway };
 
       typedef struct {
         millis_t timer = 0;
         TRState state = TRInactive;
         float running_temp;
-        void run(const_float_t current, const_float_t target, const heater_id_t heater_id, const uint16_t period_seconds, const celsius_t hysteresis_degc);
+        void run(const_celsius_float_t current, const_celsius_float_t target, const heater_id_t heater_id, const uint16_t period_seconds, const celsius_t hysteresis_degc);
       } tr_state_machine_t;
 
       static tr_state_machine_t tr_state_machine[NR_HEATER_RUNAWAY];
 
     #endif // HAS_THERMAL_PROTECTION
 };
 
 extern Temperature thermalManager;

commit 528b9bd8729656d7ebcd3dc7898ceddc2f377354
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Apr 16 02:43:59 2021 -0500

    Revert experimental NAN patch
    
    Hold changes from #21575 (24a095c) for more testing.

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index e1e7f56d17..d2b3db8747 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -67,23 +67,23 @@ typedef
   #else
     PID_t
   #endif
 hotend_pid_t;
 
 #if ENABLED(PID_EXTRUSION_SCALING)
   typedef IF<(LPQ_MAX_LEN > 255), uint16_t, uint8_t>::type lpq_ptr_t;
 #endif
 
 #define PID_PARAM(F,H) _PID_##F(TERN(PID_PARAMS_PER_HOTEND, H, 0 & H)) // Always use 'H' to suppress warning
-#define _PID_Kp(H) TERN(PIDTEMP, Temperature::temp_hotend[H].pid.Kp, MFNAN)
-#define _PID_Ki(H) TERN(PIDTEMP, Temperature::temp_hotend[H].pid.Ki, MFNAN)
-#define _PID_Kd(H) TERN(PIDTEMP, Temperature::temp_hotend[H].pid.Kd, MFNAN)
+#define _PID_Kp(H) TERN(PIDTEMP, Temperature::temp_hotend[H].pid.Kp, NAN)
+#define _PID_Ki(H) TERN(PIDTEMP, Temperature::temp_hotend[H].pid.Ki, NAN)
+#define _PID_Kd(H) TERN(PIDTEMP, Temperature::temp_hotend[H].pid.Kd, NAN)
 #if ENABLED(PIDTEMP)
   #define _PID_Kc(H) TERN(PID_EXTRUSION_SCALING, Temperature::temp_hotend[H].pid.Kc, 1)
   #define _PID_Kf(H) TERN(PID_FAN_SCALING,       Temperature::temp_hotend[H].pid.Kf, 0)
 #else
   #define _PID_Kc(H) 1
   #define _PID_Kf(H) 0
 #endif
 
 /**
  * States for ADC reading in the ISR

commit 58cc4b7043a9ff3b60df6c8f08591cb58213fbab
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Apr 15 20:06:08 2021 -0500

    Use celsius_t for temperature accessors

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index bcb451064e..e1e7f56d17 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -624,21 +624,21 @@ class Temperature {
         preheat_end_time[HOTEND_INDEX] = 0;
       }
     #else
       #define is_preheating(n) (false)
     #endif
 
     //high level conversion routines, for use outside of temperature.cpp
     //inline so that there is no performance decrease.
     //deg=degreeCelsius
 
-    FORCE_INLINE static float degHotend(const uint8_t E_NAME) {
+    FORCE_INLINE static celsius_t degHotend(const uint8_t E_NAME) {
       return TERN0(HAS_HOTEND, temp_hotend[HOTEND_INDEX].celsius);
     }
 
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       FORCE_INLINE static int16_t rawHotendTemp(const uint8_t E_NAME) {
         return TERN0(HAS_HOTEND, temp_hotend[HOTEND_INDEX].raw);
       }
     #endif
 
     FORCE_INLINE static celsius_t degTargetHotend(const uint8_t E_NAME) {
@@ -729,37 +729,37 @@ class Temperature {
       FORCE_INLINE static bool degBedNear(const_float_t temp) {
         return ABS(degBed() - temp) < (TEMP_BED_HYSTERESIS);
       }
 
     #endif // HAS_HEATED_BED
 
     #if HAS_TEMP_PROBE
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         FORCE_INLINE static int16_t rawProbeTemp()    { return temp_probe.raw; }
       #endif
-      FORCE_INLINE static float degProbe()            { return temp_probe.celsius; }
+      FORCE_INLINE static celsius_t degProbe()        { return temp_probe.celsius; }
       FORCE_INLINE static bool isProbeBelowTemp(const_float_t target_temp) { return temp_probe.celsius < target_temp; }
       FORCE_INLINE static bool isProbeAboveTemp(const_float_t target_temp) { return temp_probe.celsius > target_temp; }
       static bool wait_for_probe(const_float_t target_temp, bool no_wait_for_cooling=true);
     #endif
 
     #if WATCH_PROBE
       static void start_watching_probe();
     #else
       static inline void start_watching_probe() {}
     #endif
 
     #if HAS_TEMP_CHAMBER
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         FORCE_INLINE static int16_t rawChamberTemp()      { return temp_chamber.raw; }
       #endif
-      FORCE_INLINE static float degChamber()              { return temp_chamber.celsius; }
+      FORCE_INLINE static celsius_t degChamber()          { return temp_chamber.celsius; }
       #if HAS_HEATED_CHAMBER
         FORCE_INLINE static celsius_t degTargetChamber()  { return temp_chamber.target; }
         FORCE_INLINE static bool isHeatingChamber()       { return temp_chamber.target > temp_chamber.celsius; }
         FORCE_INLINE static bool isCoolingChamber()       { return temp_chamber.target < temp_chamber.celsius; }
         static bool wait_for_chamber(const bool no_wait_for_cooling=true);
       #endif
     #endif
 
     #if WATCH_CHAMBER
       static void start_watching_chamber();
@@ -771,21 +771,21 @@ class Temperature {
       static void setTargetChamber(const celsius_t celsius) {
         temp_chamber.target = _MIN(celsius, CHAMBER_MAX_TARGET);
         start_watching_chamber();
       }
     #endif
 
     #if HAS_TEMP_COOLER
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         FORCE_INLINE static int16_t rawCoolerTemp()     { return temp_cooler.raw; }
       #endif
-      FORCE_INLINE static float degCooler()             { return temp_cooler.celsius; }
+      FORCE_INLINE static celsius_t degCooler()         { return temp_cooler.celsius; }
       #if HAS_COOLER
         FORCE_INLINE static celsius_t degTargetCooler() { return temp_cooler.target; }
         FORCE_INLINE static bool isLaserHeating()       { return temp_cooler.target > temp_cooler.celsius; }
         FORCE_INLINE static bool isLaserCooling()       { return temp_cooler.target < temp_cooler.celsius; }
         static bool wait_for_cooler(const bool no_wait_for_cooling=true);
       #endif
     #endif
 
     #if WATCH_COOLER
       static void start_watching_cooler();

commit fd99ea09ecb41bc1dfc5e4109e0d6c7de1f87424
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Apr 13 04:00:39 2021 -0500

    Add fan percent accessors

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 9633c9733c..bcb451064e 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -546,46 +546,48 @@ class Temperature {
     #endif
     #if HAS_TEMP_COOLER
       static celsius_t analog_to_celsius_cooler(const int raw);
     #endif
 
     #if HAS_FAN
 
       static uint8_t fan_speed[FAN_COUNT];
       #define FANS_LOOP(I) LOOP_L_N(I, FAN_COUNT)
 
-      static void set_fan_speed(const uint8_t target, const uint16_t speed);
+      static void set_fan_speed(const uint8_t fan, const uint16_t speed);
 
       #if ENABLED(REPORT_FAN_CHANGE)
-        static void report_fan_speed(const uint8_t target);
+        static void report_fan_speed(const uint8_t fan);
       #endif
 
       #if EITHER(PROBING_FANS_OFF, ADVANCED_PAUSE_FANS_PAUSE)
         static bool fans_paused;
         static uint8_t saved_fan_speed[FAN_COUNT];
       #endif
 
-      static constexpr inline uint8_t fanPercent(const uint8_t speed) { return ui8_to_percent(speed); }
-
       #if ENABLED(ADAPTIVE_FAN_SLOWING)
         static uint8_t fan_speed_scaler[FAN_COUNT];
       #endif
 
-      static inline uint8_t scaledFanSpeed(const uint8_t target, const uint8_t fs) {
-        UNUSED(target); // Potentially unused!
-        return (fs * uint16_t(TERN(ADAPTIVE_FAN_SLOWING, fan_speed_scaler[target], 128))) >> 7;
+      static inline uint8_t scaledFanSpeed(const uint8_t fan, const uint8_t fs) {
+        UNUSED(fan); // Potentially unused!
+        return (fs * uint16_t(TERN(ADAPTIVE_FAN_SLOWING, fan_speed_scaler[fan], 128))) >> 7;
       }
 
-      static inline uint8_t scaledFanSpeed(const uint8_t target) {
-        return scaledFanSpeed(target, fan_speed[target]);
+      static inline uint8_t scaledFanSpeed(const uint8_t fan) {
+        return scaledFanSpeed(fan, fan_speed[fan]);
       }
 
+      static constexpr inline uint8_t pwmToPercent(const uint8_t speed) { return ui8_to_percent(speed); }
+      static inline uint8_t fanSpeedPercent(const uint8_t fan)          { return ui8_to_percent(fan_speed[fan]); }
+      static inline uint8_t scaledFanSpeedPercent(const uint8_t fan)    { return ui8_to_percent(scaledFanSpeed(fan)); }
+
       #if ENABLED(EXTRA_FAN_SPEED)
         typedef struct { uint8_t saved, speed; } extra_fan_t;
         static extra_fan_t extra_fan_speed[FAN_COUNT];
         static void set_temp_fan_speed(const uint8_t fan, const uint16_t command_or_speed);
       #endif
 
       #if EITHER(PROBING_FANS_OFF, ADVANCED_PAUSE_FANS_PAUSE)
         void set_fans_paused(const bool p);
       #endif
 

commit 24a095c5c14b60bcbffc2807d2c8cc8e9af46e90
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Apr 12 16:49:53 2021 -0500

    Reduce math library code size by 3.4KB (#21575)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 13dcca2932..9633c9733c 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -67,23 +67,23 @@ typedef
   #else
     PID_t
   #endif
 hotend_pid_t;
 
 #if ENABLED(PID_EXTRUSION_SCALING)
   typedef IF<(LPQ_MAX_LEN > 255), uint16_t, uint8_t>::type lpq_ptr_t;
 #endif
 
 #define PID_PARAM(F,H) _PID_##F(TERN(PID_PARAMS_PER_HOTEND, H, 0 & H)) // Always use 'H' to suppress warning
-#define _PID_Kp(H) TERN(PIDTEMP, Temperature::temp_hotend[H].pid.Kp, NAN)
-#define _PID_Ki(H) TERN(PIDTEMP, Temperature::temp_hotend[H].pid.Ki, NAN)
-#define _PID_Kd(H) TERN(PIDTEMP, Temperature::temp_hotend[H].pid.Kd, NAN)
+#define _PID_Kp(H) TERN(PIDTEMP, Temperature::temp_hotend[H].pid.Kp, MFNAN)
+#define _PID_Ki(H) TERN(PIDTEMP, Temperature::temp_hotend[H].pid.Ki, MFNAN)
+#define _PID_Kd(H) TERN(PIDTEMP, Temperature::temp_hotend[H].pid.Kd, MFNAN)
 #if ENABLED(PIDTEMP)
   #define _PID_Kc(H) TERN(PID_EXTRUSION_SCALING, Temperature::temp_hotend[H].pid.Kc, 1)
   #define _PID_Kf(H) TERN(PID_FAN_SCALING,       Temperature::temp_hotend[H].pid.Kf, 0)
 #else
   #define _PID_Kc(H) 1
   #define _PID_Kf(H) 0
 #endif
 
 /**
  * States for ADC reading in the ISR

commit 6ab7baa413b520fde11f588e288b391b39bf4cd8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Apr 8 15:43:16 2021 -0500

    tick() => isr() to spotlight interrupt-time

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 92e436c73f..13dcca2932 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -593,22 +593,22 @@ class Temperature {
 
     static inline void zero_fan_speeds() {
       #if HAS_FAN
         FANS_LOOP(i) set_fan_speed(i, 0);
       #endif
     }
 
     /**
      * Called from the Temperature ISR
      */
+    static void isr();
     static void readings_ready();
-    static void tick();
 
     /**
      * Call periodically to manage heaters
      */
     static void manage_heater() _O2; // Added _O2 to work around a compiler error
 
     /**
      * Preheating hotends
      */
     #ifdef MILLISECONDS_PREHEAT_TIME

commit 62f37669dc506a6e579389ca549ce5993548944d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Apr 1 17:59:57 2021 -0500

    Replace 'const float &' with 'const_float_t' (#21505)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index ec603b5217..92e436c73f 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -681,21 +681,21 @@ class Temperature {
 
         #if ENABLED(WAIT_FOR_HOTEND)
           static void wait_for_hotend_heating(const uint8_t target_extruder);
         #endif
       #endif
 
       FORCE_INLINE static bool still_heating(const uint8_t e) {
         return degTargetHotend(e) > TEMP_HYSTERESIS && ABS(degHotend(e) - degTargetHotend(e)) > TEMP_HYSTERESIS;
       }
 
-      FORCE_INLINE static bool degHotendNear(const uint8_t e, const float &temp) {
+      FORCE_INLINE static bool degHotendNear(const uint8_t e, const_float_t temp) {
         return ABS(degHotend(e) - temp) < (TEMP_HYSTERESIS);
       }
 
     #endif // HAS_HOTEND
 
     #if HAS_HEATED_BED
 
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         FORCE_INLINE static int16_t rawBedTemp()    { return temp_bed.raw; }
       #endif
@@ -717,34 +717,34 @@ class Temperature {
       }
 
       static bool wait_for_bed(const bool no_wait_for_cooling=true
         #if G26_CLICK_CAN_CANCEL
           , const bool click_to_cancel=false
         #endif
       );
 
       static void wait_for_bed_heating();
 
-      FORCE_INLINE static bool degBedNear(const float &temp) {
+      FORCE_INLINE static bool degBedNear(const_float_t temp) {
         return ABS(degBed() - temp) < (TEMP_BED_HYSTERESIS);
       }
 
     #endif // HAS_HEATED_BED
 
     #if HAS_TEMP_PROBE
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         FORCE_INLINE static int16_t rawProbeTemp()    { return temp_probe.raw; }
       #endif
       FORCE_INLINE static float degProbe()            { return temp_probe.celsius; }
-      FORCE_INLINE static bool isProbeBelowTemp(const float target_temp) { return temp_probe.celsius < target_temp; }
-      FORCE_INLINE static bool isProbeAboveTemp(const float target_temp) { return temp_probe.celsius > target_temp; }
-      static bool wait_for_probe(const float target_temp, bool no_wait_for_cooling=true);
+      FORCE_INLINE static bool isProbeBelowTemp(const_float_t target_temp) { return temp_probe.celsius < target_temp; }
+      FORCE_INLINE static bool isProbeAboveTemp(const_float_t target_temp) { return temp_probe.celsius > target_temp; }
+      static bool wait_for_probe(const_float_t target_temp, bool no_wait_for_cooling=true);
     #endif
 
     #if WATCH_PROBE
       static void start_watching_probe();
     #else
       static inline void start_watching_probe() {}
     #endif
 
     #if HAS_TEMP_CHAMBER
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
@@ -818,21 +818,21 @@ class Temperature {
 
     /**
      * Perform auto-tuning for hotend or bed in response to M303
      */
     #if HAS_PID_HEATING
 
       #if ANY(PID_DEBUG, PID_BED_DEBUG, PID_CHAMBER_DEBUG)
         static bool pid_debug_flag;
       #endif
 
-      static void PID_autotune(const float &target, const heater_id_t heater_id, const int8_t ncycles, const bool set_result=false);
+      static void PID_autotune(const_float_t target, const heater_id_t heater_id, const int8_t ncycles, const bool set_result=false);
 
       #if ENABLED(NO_FAN_SLOWING_IN_PID_TUNING)
         static bool adaptive_fan_slowing;
       #elif ENABLED(ADAPTIVE_FAN_SLOWING)
         static constexpr bool adaptive_fan_slowing = true;
       #endif
 
       /**
        * Update the temp manager when PID values change
        */
@@ -952,19 +952,19 @@ class Temperature {
         #endif
         return (RunawayIndex)_MAX(heater_id, 0);
       }
 
       enum TRState : char { TRInactive, TRFirstHeating, TRStable, TRRunaway };
 
       typedef struct {
         millis_t timer = 0;
         TRState state = TRInactive;
         float running_temp;
-        void run(const float &current, const float &target, const heater_id_t heater_id, const uint16_t period_seconds, const celsius_t hysteresis_degc);
+        void run(const_float_t current, const_float_t target, const heater_id_t heater_id, const uint16_t period_seconds, const celsius_t hysteresis_degc);
       } tr_state_machine_t;
 
       static tr_state_machine_t tr_state_machine[NR_HEATER_RUNAWAY];
 
     #endif // HAS_THERMAL_PROTECTION
 };
 
 extern Temperature thermalManager;

commit 930752d46e6aacb484ea89dacae6baf823d78d62
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Wed Mar 24 10:12:57 2021 -0500

    Ender 3 V2 Status Line (#21369)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 8092f1f7e2..ec603b5217 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -870,21 +870,21 @@ class Temperature {
         #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
           , const bool include_r=false
         #endif
       );
       #if ENABLED(AUTO_REPORT_TEMPERATURES)
         struct AutoReportTemp { static void report(); };
         static AutoReporter<AutoReportTemp> auto_reporter;
       #endif
     #endif
 
-    #if ENABLED(HAS_DISPLAY)
+    #if HAS_STATUS_MESSAGE
       static void set_heating_message(const uint8_t e);
     #endif
 
     #if HAS_LCD_MENU && HAS_TEMPERATURE
       static void lcd_preheat(const uint8_t e, const int8_t indh, const int8_t indb);
     #endif
 
   private:
     static void update_raw_temperatures();
     static void updateTemperaturesFromRawValues();

commit 2d2291d00eab6159de24eb7ff74001b1d6dd29e4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 24 05:40:28 2021 -0500

    More IntelliSense-friendly declarations

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index c9e3575257..8092f1f7e2 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -319,28 +319,42 @@ typedef struct { int16_t raw_min, raw_max; celsius_t mintemp, maxtemp; } temp_ra
 class Temperature {
 
   public:
 
     #if HAS_HOTEND
       #define HOTEND_TEMPS (HOTENDS + ENABLED(TEMP_SENSOR_1_AS_REDUNDANT))
       static hotend_info_t temp_hotend[HOTEND_TEMPS];
       static const celsius_t hotend_maxtemp[HOTENDS];
       FORCE_INLINE static celsius_t hotend_max_target(const uint8_t e) { return hotend_maxtemp[e] - (HOTEND_OVERSHOOT); }
     #endif
-    TERN_(HAS_HEATED_BED, static bed_info_t temp_bed);
-    TERN_(HAS_TEMP_PROBE, static probe_info_t temp_probe);
-    TERN_(HAS_TEMP_CHAMBER, static chamber_info_t temp_chamber);
-    TERN_(HAS_TEMP_COOLER, static cooler_info_t temp_cooler);
+    #if ENABLED(HAS_HEATED_BED)
+      static bed_info_t temp_bed;
+    #endif
+    #if ENABLED(HAS_TEMP_PROBE)
+      static probe_info_t temp_probe;
+    #endif
+    #if ENABLED(HAS_TEMP_CHAMBER)
+      static chamber_info_t temp_chamber;
+    #endif
+    #if ENABLED(HAS_TEMP_COOLER)
+      static cooler_info_t temp_cooler;
+    #endif
 
-    TERN_(AUTO_POWER_E_FANS, static uint8_t autofan_speed[HOTENDS]);
-    TERN_(AUTO_POWER_CHAMBER_FAN, static uint8_t chamberfan_speed);
-    TERN_(AUTO_POWER_COOLER_FAN, static uint8_t coolerfan_speed);
+    #if ENABLED(AUTO_POWER_E_FANS)
+      static uint8_t autofan_speed[HOTENDS];
+    #endif
+    #if ENABLED(AUTO_POWER_CHAMBER_FAN)
+      static uint8_t chamberfan_speed;
+    #endif
+    #if ENABLED(AUTO_POWER_COOLER_FAN)
+      static uint8_t coolerfan_speed;
+    #endif
 
     #if ENABLED(FAN_SOFT_PWM)
       static uint8_t soft_pwm_amount_fan[FAN_COUNT],
                      soft_pwm_count_fan[FAN_COUNT];
     #endif
 
     #if ENABLED(PREVENT_COLD_EXTRUSION)
       static bool allow_cold_extrude;
       static celsius_t extrude_min_temp;
       FORCE_INLINE static bool tooCold(const celsius_t temp) { return allow_cold_extrude ? false : temp < extrude_min_temp - (TEMP_WINDOW); }
@@ -396,75 +410,93 @@ class Temperature {
         #endif
         return (IdleIndex)_MAX(heater_id, 0);
       }
 
       static heater_idle_t heater_idle[NR_HEATER_IDLE];
 
     #endif
 
   private:
 
-    TERN_(EARLY_WATCHDOG, static bool inited);   // If temperature controller is running
+    #if ENABLED(EARLY_WATCHDOG)
+      static bool inited;   // If temperature controller is running
+    #endif
 
     static volatile bool raw_temps_ready;
 
-    TERN_(WATCH_HOTENDS, static hotend_watch_t watch_hotend[HOTENDS]);
+    #if ENABLED(WATCH_HOTENDS)
+      static hotend_watch_t watch_hotend[HOTENDS];
+    #endif
 
     #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
       static uint16_t redundant_temperature_raw;
       static celsius_t redundant_temperature;
     #endif
 
     #if ENABLED(PID_EXTRUSION_SCALING)
       static int32_t last_e_position, lpq[LPQ_MAX_LEN];
       static lpq_ptr_t lpq_ptr;
     #endif
 
-    TERN_(HAS_HOTEND, static temp_range_t temp_range[HOTENDS]);
+    #if ENABLED(HAS_HOTEND)
+      static temp_range_t temp_range[HOTENDS];
+    #endif
 
     #if HAS_HEATED_BED
-      TERN_(WATCH_BED, static bed_watch_t watch_bed);
+      #if ENABLED(WATCH_BED)
+        static bed_watch_t watch_bed;
+      #endif
       IF_DISABLED(PIDTEMPBED, static millis_t next_bed_check_ms);
       static int16_t mintemp_raw_BED, maxtemp_raw_BED;
     #endif
 
     #if HAS_HEATED_CHAMBER
-      TERN_(WATCH_CHAMBER, static chamber_watch_t watch_chamber);
+      #if ENABLED(WATCH_CHAMBER)
+        static chamber_watch_t watch_chamber;
+      #endif
       TERN(PIDTEMPCHAMBER,,static millis_t next_chamber_check_ms);
       static int16_t mintemp_raw_CHAMBER, maxtemp_raw_CHAMBER;
     #endif
 
     #if HAS_COOLER
-      TERN_(WATCH_COOLER, static cooler_watch_t watch_cooler);
+      #if ENABLED(WATCH_COOLER)
+        static cooler_watch_t watch_cooler;
+      #endif
       static millis_t next_cooler_check_ms, cooler_fan_flush_ms;
       static int16_t mintemp_raw_COOLER, maxtemp_raw_COOLER;
     #endif
 
     #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
       static uint8_t consecutive_low_temperature_error[HOTENDS];
     #endif
 
     #ifdef MILLISECONDS_PREHEAT_TIME
       static millis_t preheat_end_time[HOTENDS];
     #endif
 
-    TERN_(HAS_AUTO_FAN, static millis_t next_auto_fan_check_ms);
+    #if ENABLED(HAS_AUTO_FAN)
+      static millis_t next_auto_fan_check_ms;
+    #endif
 
-    TERN_(PROBING_HEATERS_OFF, static bool paused);
+    #if ENABLED(PROBING_HEATERS_OFF)
+      static bool paused;
+    #endif
 
   public:
     #if HAS_ADC_BUTTONS
       static uint32_t current_ADCKey_raw;
       static uint16_t ADCKey_count;
     #endif
 
-    TERN_(PID_EXTRUSION_SCALING, static int16_t lpq_len);
+    #if ENABLED(PID_EXTRUSION_SCALING)
+      static int16_t lpq_len;
+    #endif
 
     /**
      * Instance Methods
      */
 
     void init();
 
     /**
      * Static (class) methods
      */
@@ -527,21 +559,23 @@ class Temperature {
         static void report_fan_speed(const uint8_t target);
       #endif
 
       #if EITHER(PROBING_FANS_OFF, ADVANCED_PAUSE_FANS_PAUSE)
         static bool fans_paused;
         static uint8_t saved_fan_speed[FAN_COUNT];
       #endif
 
       static constexpr inline uint8_t fanPercent(const uint8_t speed) { return ui8_to_percent(speed); }
 
-      TERN_(ADAPTIVE_FAN_SLOWING, static uint8_t fan_speed_scaler[FAN_COUNT]);
+      #if ENABLED(ADAPTIVE_FAN_SLOWING)
+        static uint8_t fan_speed_scaler[FAN_COUNT];
+      #endif
 
       static inline uint8_t scaledFanSpeed(const uint8_t target, const uint8_t fs) {
         UNUSED(target); // Potentially unused!
         return (fs * uint16_t(TERN(ADAPTIVE_FAN_SLOWING, fan_speed_scaler[target], 128))) >> 7;
       }
 
       static inline uint8_t scaledFanSpeed(const uint8_t target) {
         return scaledFanSpeed(target, fan_speed[target]);
       }
 
@@ -836,21 +870,23 @@ class Temperature {
         #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
           , const bool include_r=false
         #endif
       );
       #if ENABLED(AUTO_REPORT_TEMPERATURES)
         struct AutoReportTemp { static void report(); };
         static AutoReporter<AutoReportTemp> auto_reporter;
       #endif
     #endif
 
-    TERN_(HAS_DISPLAY, static void set_heating_message(const uint8_t e));
+    #if ENABLED(HAS_DISPLAY)
+      static void set_heating_message(const uint8_t e);
+    #endif
 
     #if HAS_LCD_MENU && HAS_TEMPERATURE
       static void lcd_preheat(const uint8_t e, const int8_t indh, const int8_t indb);
     #endif
 
   private:
     static void update_raw_temperatures();
     static void updateTemperaturesFromRawValues();
 
     #if HAS_MAX_TC
@@ -859,23 +895,29 @@ class Temperature {
         #define HAS_MULTI_MAX_TC 1
         #define READ_MAX_TC(N) read_max_tc(N)
       #else
         #define READ_MAX_TC(N) read_max_tc()
       #endif
       static int read_max_tc(TERN_(HAS_MULTI_MAX_TC, const uint8_t hindex=0));
     #endif
 
     static void checkExtruderAutoFans();
 
-    TERN_(HAS_HOTEND,     static float get_pid_output_hotend(const uint8_t e));
-    TERN_(PIDTEMPBED,     static float get_pid_output_bed());
-    TERN_(PIDTEMPCHAMBER, static float get_pid_output_chamber());
+    #if ENABLED(HAS_HOTEND)
+      static float get_pid_output_hotend(const uint8_t e);
+    #endif
+    #if ENABLED(PIDTEMPBED)
+      static float get_pid_output_bed();
+    #endif
+    #if ENABLED(PIDTEMPCHAMBER)
+      static float get_pid_output_chamber();
+    #endif
 
     static void _temp_error(const heater_id_t e, PGM_P const serial_msg, PGM_P const lcd_msg);
     static void min_temp_error(const heater_id_t e);
     static void max_temp_error(const heater_id_t e);
 
     #define HAS_THERMAL_PROTECTION ANY(THERMAL_PROTECTION_HOTENDS, THERMAL_PROTECTION_CHAMBER, HAS_THERMALLY_PROTECTED_BED, THERMAL_PROTECTION_COOLER)
 
     #if HAS_THERMAL_PROTECTION
 
       // Indices and size for the tr_state_machine array. One for each protected heater.

commit e5ff55a1be7646b6159e6dedac50bfbe57e6dfa0
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 24 04:11:43 2021 -0500

    Add typedef celsius_t (#21374)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 38270fc9c4..c9e3575257 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -172,29 +172,29 @@ enum ADCSensorState : char {
 #endif
 
 #if BOTH(HAS_LCD_MENU, G26_MESH_VALIDATION)
   #define G26_CLICK_CAN_CANCEL 1
 #endif
 
 // A temperature sensor
 typedef struct TempInfo {
   uint16_t acc;
   int16_t raw;
-  float celsius;
+  celsius_t celsius;
   inline void reset() { acc = 0; }
   inline void sample(const uint16_t s) { acc += s; }
   inline void update() { raw = acc; }
 } temp_info_t;
 
 // A PWM heater with temperature sensor
 typedef struct HeaterInfo : public TempInfo {
-  int16_t target;
+  celsius_t target;
   uint8_t soft_pwm_amount;
 } heater_info_t;
 
 // A heater with PID stabilization
 template<typename T>
 struct PIDHeaterInfo : public HeaterInfo {
   T pid;  // Initialized by settings.load()
 };
 
 #if ENABLED(PIDTEMP)
@@ -221,28 +221,28 @@ struct PIDHeaterInfo : public HeaterInfo {
 #elif HAS_TEMP_CHAMBER
   typedef temp_info_t chamber_info_t;
 #endif
 #if EITHER(HAS_COOLER, HAS_TEMP_COOLER)
   typedef heater_info_t cooler_info_t;
 #endif
 
 // Heater watch handling
 template <int INCREASE, int HYSTERESIS, millis_t PERIOD>
 struct HeaterWatch {
-  uint16_t target;
+  celsius_t target;
   millis_t next_ms;
   inline bool elapsed(const millis_t &ms) { return next_ms && ELAPSED(ms, next_ms); }
   inline bool elapsed() { return elapsed(millis()); }
 
-  inline void restart(const int16_t curr, const int16_t tgt) {
+  inline void restart(const celsius_t curr, const celsius_t tgt) {
     if (tgt) {
-      const int16_t newtarget = curr + INCREASE;
+      const celsius_t newtarget = curr + INCREASE;
       if (newtarget < tgt - HYSTERESIS - 1) {
         target = newtarget;
         next_ms = millis() + SEC_TO_MS(PERIOD);
         return;
       }
     }
     next_ms = 0;
   }
 };
 
@@ -254,22 +254,22 @@ struct HeaterWatch {
 #endif
 #if WATCH_CHAMBER
   typedef struct HeaterWatch<WATCH_CHAMBER_TEMP_INCREASE, TEMP_CHAMBER_HYSTERESIS, WATCH_CHAMBER_TEMP_PERIOD> chamber_watch_t;
 #endif
 #if WATCH_COOLER
   typedef struct HeaterWatch<WATCH_COOLER_TEMP_INCREASE, TEMP_COOLER_HYSTERESIS, WATCH_COOLER_TEMP_PERIOD> cooler_watch_t;
 #endif
 
 // Temperature sensor read value ranges
 typedef struct { int16_t raw_min, raw_max; } raw_range_t;
-typedef struct { int16_t mintemp, maxtemp; } celsius_range_t;
-typedef struct { int16_t raw_min, raw_max, mintemp, maxtemp; } temp_range_t;
+typedef struct { celsius_t mintemp, maxtemp; } celsius_range_t;
+typedef struct { int16_t raw_min, raw_max; celsius_t mintemp, maxtemp; } temp_range_t;
 
 #define THERMISTOR_ABS_ZERO_C           -273.15f  // bbbbrrrrr cold !
 #define THERMISTOR_RESISTANCE_NOMINAL_C 25.0f     // mmmmm comfortable
 
 #if HAS_USER_THERMISTORS
 
   enum CustomThermistorIndex : uint8_t {
     #if TEMP_SENSOR_0_IS_CUSTOM
       CTI_HOTEND_0,
     #endif
@@ -316,57 +316,57 @@ typedef struct { int16_t raw_min, raw_max, mintemp, maxtemp; } temp_range_t;
 
 #endif
 
 class Temperature {
 
   public:
 
     #if HAS_HOTEND
       #define HOTEND_TEMPS (HOTENDS + ENABLED(TEMP_SENSOR_1_AS_REDUNDANT))
       static hotend_info_t temp_hotend[HOTEND_TEMPS];
-      static const uint16_t hotend_maxtemp[HOTENDS];
-      FORCE_INLINE static uint16_t hotend_max_target(const uint8_t e) { return hotend_maxtemp[e] - (HOTEND_OVERSHOOT); }
+      static const celsius_t hotend_maxtemp[HOTENDS];
+      FORCE_INLINE static celsius_t hotend_max_target(const uint8_t e) { return hotend_maxtemp[e] - (HOTEND_OVERSHOOT); }
     #endif
     TERN_(HAS_HEATED_BED, static bed_info_t temp_bed);
     TERN_(HAS_TEMP_PROBE, static probe_info_t temp_probe);
     TERN_(HAS_TEMP_CHAMBER, static chamber_info_t temp_chamber);
     TERN_(HAS_TEMP_COOLER, static cooler_info_t temp_cooler);
 
     TERN_(AUTO_POWER_E_FANS, static uint8_t autofan_speed[HOTENDS]);
     TERN_(AUTO_POWER_CHAMBER_FAN, static uint8_t chamberfan_speed);
     TERN_(AUTO_POWER_COOLER_FAN, static uint8_t coolerfan_speed);
 
     #if ENABLED(FAN_SOFT_PWM)
       static uint8_t soft_pwm_amount_fan[FAN_COUNT],
                      soft_pwm_count_fan[FAN_COUNT];
     #endif
 
     #if ENABLED(PREVENT_COLD_EXTRUSION)
       static bool allow_cold_extrude;
-      static int16_t extrude_min_temp;
-      FORCE_INLINE static bool tooCold(const int16_t temp) { return allow_cold_extrude ? false : temp < extrude_min_temp - (TEMP_WINDOW); }
+      static celsius_t extrude_min_temp;
+      FORCE_INLINE static bool tooCold(const celsius_t temp) { return allow_cold_extrude ? false : temp < extrude_min_temp - (TEMP_WINDOW); }
       FORCE_INLINE static bool tooColdToExtrude(const uint8_t E_NAME) {
         return tooCold(degHotend(HOTEND_INDEX));
       }
       FORCE_INLINE static bool targetTooColdToExtrude(const uint8_t E_NAME) {
         return tooCold(degTargetHotend(HOTEND_INDEX));
       }
     #else
       FORCE_INLINE static bool tooColdToExtrude(const uint8_t) { return false; }
       FORCE_INLINE static bool targetTooColdToExtrude(const uint8_t) { return false; }
     #endif
 
     FORCE_INLINE static bool hotEnoughToExtrude(const uint8_t e) { return !tooColdToExtrude(e); }
     FORCE_INLINE static bool targetHotEnoughToExtrude(const uint8_t e) { return !targetTooColdToExtrude(e); }
 
     #if ENABLED(SINGLENOZZLE_STANDBY_FAN)
-      static uint16_t singlenozzle_temp[EXTRUDERS];
+      static celsius_t singlenozzle_temp[EXTRUDERS];
       #if HAS_FAN
         static uint8_t singlenozzle_fan_speed[EXTRUDERS];
       #endif
       static void singlenozzle_change(const uint8_t old_tool, const uint8_t new_tool);
     #endif
 
     #if HEATER_IDLE_HANDLER
 
       // Heater idle handling. Marlin creates one per hotend and one for the heated bed.
       typedef struct {
@@ -404,61 +404,46 @@ class Temperature {
   private:
 
     TERN_(EARLY_WATCHDOG, static bool inited);   // If temperature controller is running
 
     static volatile bool raw_temps_ready;
 
     TERN_(WATCH_HOTENDS, static hotend_watch_t watch_hotend[HOTENDS]);
 
     #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
       static uint16_t redundant_temperature_raw;
-      static float redundant_temperature;
+      static celsius_t redundant_temperature;
     #endif
 
     #if ENABLED(PID_EXTRUSION_SCALING)
       static int32_t last_e_position, lpq[LPQ_MAX_LEN];
       static lpq_ptr_t lpq_ptr;
     #endif
 
     TERN_(HAS_HOTEND, static temp_range_t temp_range[HOTENDS]);
 
     #if HAS_HEATED_BED
       TERN_(WATCH_BED, static bed_watch_t watch_bed);
       IF_DISABLED(PIDTEMPBED, static millis_t next_bed_check_ms);
-      #ifdef BED_MINTEMP
-        static int16_t mintemp_raw_BED;
-      #endif
-      #ifdef BED_MAXTEMP
-        static int16_t maxtemp_raw_BED;
-      #endif
+      static int16_t mintemp_raw_BED, maxtemp_raw_BED;
     #endif
 
     #if HAS_HEATED_CHAMBER
       TERN_(WATCH_CHAMBER, static chamber_watch_t watch_chamber);
       TERN(PIDTEMPCHAMBER,,static millis_t next_chamber_check_ms);
-      #ifdef CHAMBER_MINTEMP
-        static int16_t mintemp_raw_CHAMBER;
-      #endif
-      #ifdef CHAMBER_MAXTEMP
-        static int16_t maxtemp_raw_CHAMBER;
-      #endif
+      static int16_t mintemp_raw_CHAMBER, maxtemp_raw_CHAMBER;
     #endif
 
     #if HAS_COOLER
       TERN_(WATCH_COOLER, static cooler_watch_t watch_cooler);
       static millis_t next_cooler_check_ms, cooler_fan_flush_ms;
-      #ifdef COOLER_MINTEMP
-        static int16_t mintemp_raw_COOLER;
-      #endif
-      #ifdef COOLER_MAXTEMP
-        static int16_t maxtemp_raw_COOLER;
-      #endif
+      static int16_t mintemp_raw_COOLER, maxtemp_raw_COOLER;
     #endif
 
     #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
       static uint8_t consecutive_low_temperature_error[HOTENDS];
     #endif
 
     #ifdef MILLISECONDS_PREHEAT_TIME
       static millis_t preheat_end_time[HOTENDS];
     #endif
 
@@ -481,21 +466,21 @@ class Temperature {
     void init();
 
     /**
      * Static (class) methods
      */
 
     #if HAS_USER_THERMISTORS
       static user_thermistor_t user_thermistor[USER_THERMISTORS];
       static void log_user_thermistor(const uint8_t t_index, const bool eprom=false);
       static void reset_user_thermistors();
-      static float user_thermistor_to_deg_c(const uint8_t t_index, const int raw);
+      static celsius_t user_thermistor_to_deg_c(const uint8_t t_index, const int raw);
       static bool set_pull_up_res(int8_t t_index, float value) {
         //if (!WITHIN(t_index, 0, USER_THERMISTORS - 1)) return false;
         if (!WITHIN(value, 1, 1000000)) return false;
         user_thermistor[t_index].series_res = value;
         return true;
       }
       static bool set_res25(int8_t t_index, float value) {
         if (!WITHIN(value, 1, 10000000)) return false;
         user_thermistor[t_index].res_25 = value;
         user_thermistor[t_index].pre_calc = true;
@@ -509,33 +494,33 @@ class Temperature {
       }
       static bool set_sh_coeff(int8_t t_index, float value) {
         if (!WITHIN(value, -0.01f, 0.01f)) return false;
         user_thermistor[t_index].sh_c_coeff = value;
         user_thermistor[t_index].pre_calc = true;
         return true;
       }
     #endif
 
     #if HAS_HOTEND
-      static float analog_to_celsius_hotend(const int raw, const uint8_t e);
+      static celsius_t analog_to_celsius_hotend(const int raw, const uint8_t e);
     #endif
     #if HAS_HEATED_BED
-      static float analog_to_celsius_bed(const int raw);
+      static celsius_t analog_to_celsius_bed(const int raw);
     #endif
     #if HAS_TEMP_PROBE
-      static float analog_to_celsius_probe(const int raw);
+      static celsius_t analog_to_celsius_probe(const int raw);
     #endif
     #if HAS_TEMP_CHAMBER
-      static float analog_to_celsius_chamber(const int raw);
+      static celsius_t analog_to_celsius_chamber(const int raw);
     #endif
     #if HAS_TEMP_COOLER
-      static float analog_to_celsius_cooler(const int raw);
+      static celsius_t analog_to_celsius_cooler(const int raw);
     #endif
 
     #if HAS_FAN
 
       static uint8_t fan_speed[FAN_COUNT];
       #define FANS_LOOP(I) LOOP_L_N(I, FAN_COUNT)
 
       static void set_fan_speed(const uint8_t target, const uint16_t speed);
 
       #if ENABLED(REPORT_FAN_CHANGE)
@@ -613,33 +598,33 @@ class Temperature {
     FORCE_INLINE static float degHotend(const uint8_t E_NAME) {
       return TERN0(HAS_HOTEND, temp_hotend[HOTEND_INDEX].celsius);
     }
 
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       FORCE_INLINE static int16_t rawHotendTemp(const uint8_t E_NAME) {
         return TERN0(HAS_HOTEND, temp_hotend[HOTEND_INDEX].raw);
       }
     #endif
 
-    FORCE_INLINE static int16_t degTargetHotend(const uint8_t E_NAME) {
+    FORCE_INLINE static celsius_t degTargetHotend(const uint8_t E_NAME) {
       return TERN0(HAS_HOTEND, temp_hotend[HOTEND_INDEX].target);
     }
 
     #if WATCH_HOTENDS
       static void start_watching_hotend(const uint8_t e=0);
     #else
       static inline void start_watching_hotend(const uint8_t=0) {}
     #endif
 
     #if HAS_HOTEND
 
-      static void setTargetHotend(const int16_t celsius, const uint8_t E_NAME) {
+      static void setTargetHotend(const celsius_t celsius, const uint8_t E_NAME) {
         const uint8_t ee = HOTEND_INDEX;
         #ifdef MILLISECONDS_PREHEAT_TIME
           if (celsius == 0)
             reset_preheat_time(ee);
           else if (temp_hotend[ee].target == 0)
             start_preheat_time(ee);
         #endif
         TERN_(AUTO_POWER_CONTROL, if (celsius) powerManager.power_on());
         temp_hotend[ee].target = _MIN(celsius, hotend_max_target(ee));
         start_watching_hotend(ee);
@@ -671,42 +656,36 @@ class Temperature {
 
       FORCE_INLINE static bool degHotendNear(const uint8_t e, const float &temp) {
         return ABS(degHotend(e) - temp) < (TEMP_HYSTERESIS);
       }
 
     #endif // HAS_HOTEND
 
     #if HAS_HEATED_BED
 
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
-        FORCE_INLINE static int16_t rawBedTemp()  { return temp_bed.raw; }
+        FORCE_INLINE static int16_t rawBedTemp()    { return temp_bed.raw; }
       #endif
-      FORCE_INLINE static float degBed()          { return temp_bed.celsius; }
-      FORCE_INLINE static int16_t degTargetBed()  { return temp_bed.target; }
-      FORCE_INLINE static bool isHeatingBed()     { return temp_bed.target > temp_bed.celsius; }
-      FORCE_INLINE static bool isCoolingBed()     { return temp_bed.target < temp_bed.celsius; }
+      FORCE_INLINE static celsius_t degBed()        { return temp_bed.celsius; }
+      FORCE_INLINE static celsius_t degTargetBed()  { return temp_bed.target; }
+      FORCE_INLINE static bool isHeatingBed()       { return temp_bed.target > temp_bed.celsius; }
+      FORCE_INLINE static bool isCoolingBed()       { return temp_bed.target < temp_bed.celsius; }
 
       #if WATCH_BED
         static void start_watching_bed();
       #else
         static inline void start_watching_bed() {}
       #endif
 
-      static void setTargetBed(const int16_t celsius) {
+      static void setTargetBed(const celsius_t celsius) {
         TERN_(AUTO_POWER_CONTROL, if (celsius) powerManager.power_on());
-        temp_bed.target =
-          #ifdef BED_MAX_TARGET
-            _MIN(celsius, BED_MAX_TARGET)
-          #else
-            celsius
-          #endif
-        ;
+        temp_bed.target = _MIN(celsius, BED_MAX_TARGET);
         start_watching_bed();
       }
 
       static bool wait_for_bed(const bool no_wait_for_cooling=true
         #if G26_CLICK_CAN_CANCEL
           , const bool click_to_cancel=false
         #endif
       );
 
       static void wait_for_bed_heating();
@@ -728,72 +707,65 @@ class Temperature {
     #endif
 
     #if WATCH_PROBE
       static void start_watching_probe();
     #else
       static inline void start_watching_probe() {}
     #endif
 
     #if HAS_TEMP_CHAMBER
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
-        FORCE_INLINE static int16_t rawChamberTemp()    { return temp_chamber.raw; }
+        FORCE_INLINE static int16_t rawChamberTemp()      { return temp_chamber.raw; }
       #endif
-      FORCE_INLINE static float degChamber()            { return temp_chamber.celsius; }
+      FORCE_INLINE static float degChamber()              { return temp_chamber.celsius; }
       #if HAS_HEATED_CHAMBER
-        FORCE_INLINE static int16_t degTargetChamber()  { return temp_chamber.target; }
-        FORCE_INLINE static bool isHeatingChamber()     { return temp_chamber.target > temp_chamber.celsius; }
-        FORCE_INLINE static bool isCoolingChamber()     { return temp_chamber.target < temp_chamber.celsius; }
-
+        FORCE_INLINE static celsius_t degTargetChamber()  { return temp_chamber.target; }
+        FORCE_INLINE static bool isHeatingChamber()       { return temp_chamber.target > temp_chamber.celsius; }
+        FORCE_INLINE static bool isCoolingChamber()       { return temp_chamber.target < temp_chamber.celsius; }
         static bool wait_for_chamber(const bool no_wait_for_cooling=true);
       #endif
     #endif
 
     #if WATCH_CHAMBER
       static void start_watching_chamber();
     #else
       static inline void start_watching_chamber() {}
     #endif
 
     #if HAS_HEATED_CHAMBER
-      static void setTargetChamber(const int16_t celsius) {
-        temp_chamber.target =
-          #ifdef CHAMBER_MAXTEMP
-            _MIN(celsius, CHAMBER_MAXTEMP - 10)
-          #else
-            celsius
-          #endif
-        ;
+      static void setTargetChamber(const celsius_t celsius) {
+        temp_chamber.target = _MIN(celsius, CHAMBER_MAX_TARGET);
         start_watching_chamber();
       }
     #endif
 
     #if HAS_TEMP_COOLER
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
-        FORCE_INLINE static int16_t rawCoolerTemp()    { return temp_cooler.raw; }
+        FORCE_INLINE static int16_t rawCoolerTemp()     { return temp_cooler.raw; }
       #endif
-      FORCE_INLINE static float degCooler()            { return temp_cooler.celsius; }
+      FORCE_INLINE static float degCooler()             { return temp_cooler.celsius; }
       #if HAS_COOLER
-        FORCE_INLINE static int16_t degTargetCooler()  { return temp_cooler.target; }
-        FORCE_INLINE static bool isLaserHeating()     { return temp_cooler.target > temp_cooler.celsius; }
-        FORCE_INLINE static bool isLaserCooling()     { return temp_cooler.target < temp_cooler.celsius; }
+        FORCE_INLINE static celsius_t degTargetCooler() { return temp_cooler.target; }
+        FORCE_INLINE static bool isLaserHeating()       { return temp_cooler.target > temp_cooler.celsius; }
+        FORCE_INLINE static bool isLaserCooling()       { return temp_cooler.target < temp_cooler.celsius; }
         static bool wait_for_cooler(const bool no_wait_for_cooling=true);
       #endif
     #endif
 
     #if WATCH_COOLER
       static void start_watching_cooler();
     #else
       static inline void start_watching_cooler() {}
     #endif
 
     #if HAS_COOLER
-      static void setTargetCooler(const int16_t celsius) {
+      static void setTargetCooler(const celsius_t celsius) {
         temp_cooler.target = constrain(celsius, COOLER_MIN_TARGET, COOLER_MAX_TARGET);
         start_watching_cooler();
       }
     #endif
 
     /**
      * The software PWM power for a heater
      */
     static int16_t getHeaterPower(const heater_id_t heater_id);
 
@@ -938,19 +910,19 @@ class Temperature {
         #endif
         return (RunawayIndex)_MAX(heater_id, 0);
       }
 
       enum TRState : char { TRInactive, TRFirstHeating, TRStable, TRRunaway };
 
       typedef struct {
         millis_t timer = 0;
         TRState state = TRInactive;
         float running_temp;
-        void run(const float &current, const float &target, const heater_id_t heater_id, const uint16_t period_seconds, const uint16_t hysteresis_degc);
+        void run(const float &current, const float &target, const heater_id_t heater_id, const uint16_t period_seconds, const celsius_t hysteresis_degc);
       } tr_state_machine_t;
 
       static tr_state_machine_t tr_state_machine[NR_HEATER_RUNAWAY];
 
     #endif // HAS_THERMAL_PROTECTION
 };
 
 extern Temperature thermalManager;

commit f7aaa2e1c758dae56fb0d3dbb743a1c5c04245d2
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Mar 19 16:39:05 2021 -0500

    Add typedef extra_fan_t

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index abd2eabac2..38270fc9c4 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -554,22 +554,23 @@ class Temperature {
       static inline uint8_t scaledFanSpeed(const uint8_t target, const uint8_t fs) {
         UNUSED(target); // Potentially unused!
         return (fs * uint16_t(TERN(ADAPTIVE_FAN_SLOWING, fan_speed_scaler[target], 128))) >> 7;
       }
 
       static inline uint8_t scaledFanSpeed(const uint8_t target) {
         return scaledFanSpeed(target, fan_speed[target]);
       }
 
       #if ENABLED(EXTRA_FAN_SPEED)
-        static uint8_t old_fan_speed[FAN_COUNT], new_fan_speed[FAN_COUNT];
-        static void set_temp_fan_speed(const uint8_t fan, const uint16_t tmp_temp);
+        typedef struct { uint8_t saved, speed; } extra_fan_t;
+        static extra_fan_t extra_fan_speed[FAN_COUNT];
+        static void set_temp_fan_speed(const uint8_t fan, const uint16_t command_or_speed);
       #endif
 
       #if EITHER(PROBING_FANS_OFF, ADVANCED_PAUSE_FANS_PAUSE)
         void set_fans_paused(const bool p);
       #endif
 
     #endif // HAS_FAN
 
     static inline void zero_fan_speeds() {
       #if HAS_FAN

commit cfa6c7d45ba72d1a0b26e6308191e008dcd0d9c9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Mar 19 16:34:10 2021 -0500

    Improve max temp / target

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index e69183f6f5..abd2eabac2 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -316,21 +316,22 @@ typedef struct { int16_t raw_min, raw_max, mintemp, maxtemp; } temp_range_t;
 
 #endif
 
 class Temperature {
 
   public:
 
     #if HAS_HOTEND
       #define HOTEND_TEMPS (HOTENDS + ENABLED(TEMP_SENSOR_1_AS_REDUNDANT))
       static hotend_info_t temp_hotend[HOTEND_TEMPS];
-      static const uint16_t heater_maxtemp[HOTENDS];
+      static const uint16_t hotend_maxtemp[HOTENDS];
+      FORCE_INLINE static uint16_t hotend_max_target(const uint8_t e) { return hotend_maxtemp[e] - (HOTEND_OVERSHOOT); }
     #endif
     TERN_(HAS_HEATED_BED, static bed_info_t temp_bed);
     TERN_(HAS_TEMP_PROBE, static probe_info_t temp_probe);
     TERN_(HAS_TEMP_CHAMBER, static chamber_info_t temp_chamber);
     TERN_(HAS_TEMP_COOLER, static cooler_info_t temp_cooler);
 
     TERN_(AUTO_POWER_E_FANS, static uint8_t autofan_speed[HOTENDS]);
     TERN_(AUTO_POWER_CHAMBER_FAN, static uint8_t chamberfan_speed);
     TERN_(AUTO_POWER_COOLER_FAN, static uint8_t coolerfan_speed);
 
@@ -632,21 +633,21 @@ class Temperature {
 
       static void setTargetHotend(const int16_t celsius, const uint8_t E_NAME) {
         const uint8_t ee = HOTEND_INDEX;
         #ifdef MILLISECONDS_PREHEAT_TIME
           if (celsius == 0)
             reset_preheat_time(ee);
           else if (temp_hotend[ee].target == 0)
             start_preheat_time(ee);
         #endif
         TERN_(AUTO_POWER_CONTROL, if (celsius) powerManager.power_on());
-        temp_hotend[ee].target = _MIN(celsius, temp_range[ee].maxtemp - HOTEND_OVERSHOOT);
+        temp_hotend[ee].target = _MIN(celsius, hotend_max_target(ee));
         start_watching_hotend(ee);
       }
 
       FORCE_INLINE static bool isHeatingHotend(const uint8_t E_NAME) {
         return temp_hotend[HOTEND_INDEX].target > temp_hotend[HOTEND_INDEX].celsius;
       }
 
       FORCE_INLINE static bool isCoolingHotend(const uint8_t E_NAME) {
         return temp_hotend[HOTEND_INDEX].target < temp_hotend[HOTEND_INDEX].celsius;
       }
@@ -778,27 +779,21 @@ class Temperature {
     #endif
 
     #if WATCH_COOLER
       static void start_watching_cooler();
     #else
       static inline void start_watching_cooler() {}
     #endif
 
     #if HAS_COOLER
       static void setTargetCooler(const int16_t celsius) {
-        temp_cooler.target =
-          #ifdef COOLER_MAXTEMP
-            _MIN(celsius, COOLER_MAXTEMP - 10)
-          #else
-            celsius
-          #endif
-        ;
+        temp_cooler.target = constrain(celsius, COOLER_MIN_TARGET, COOLER_MAX_TARGET);
         start_watching_cooler();
       }
     #endif
 
     /**
      * The software PWM power for a heater
      */
     static int16_t getHeaterPower(const heater_id_t heater_id);
 
     /**
@@ -871,21 +866,21 @@ class Temperature {
       );
       #if ENABLED(AUTO_REPORT_TEMPERATURES)
         struct AutoReportTemp { static void report(); };
         static AutoReporter<AutoReportTemp> auto_reporter;
       #endif
     #endif
 
     TERN_(HAS_DISPLAY, static void set_heating_message(const uint8_t e));
 
     #if HAS_LCD_MENU && HAS_TEMPERATURE
-      static void lcd_preheat(const int16_t e, const int8_t indh, const int8_t indb);
+      static void lcd_preheat(const uint8_t e, const int8_t indh, const int8_t indb);
     #endif
 
   private:
     static void update_raw_temperatures();
     static void updateTemperaturesFromRawValues();
 
     #if HAS_MAX_TC
       #define MAX_TC_COUNT 1 + BOTH(TEMP_SENSOR_0_IS_MAX_TC, TEMP_SENSOR_1_IS_MAX_TC)
       #if MAX_TC_COUNT > 1
         #define HAS_MULTI_MAX_TC 1

commit b95e548ddbcbc1c088eabc17992d0a06f82ac167
Author: Mike La Spina <mike.laspina@shaw.ca>
Date:   Sat Mar 6 14:13:28 2021 -0600

    Cooler (for Laser) - M143, M193 (#21255)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 5f5a076911..e69183f6f5 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -37,24 +37,24 @@
   #include "../libs/autoreport.h"
 #endif
 
 #ifndef SOFT_PWM_SCALE
   #define SOFT_PWM_SCALE 0
 #endif
 
 #define HOTEND_INDEX TERN(HAS_MULTI_HOTEND, e, 0)
 #define E_NAME TERN_(HAS_MULTI_HOTEND, e)
 
-// Heater identifiers. Positive values are hotends. Negative values are other heaters.
+// Element identifiers. Positive values are hotends. Negative values are other heaters or coolers.
 typedef enum : int8_t {
-  INDEX_NONE = -5,
-  H_PROBE, H_REDUNDANT, H_CHAMBER, H_BED,
+  INDEX_NONE = -6,
+  H_COOLER, H_PROBE, H_REDUNDANT, H_CHAMBER, H_BED,
   H_E0, H_E1, H_E2, H_E3, H_E4, H_E5, H_E6, H_E7
 } heater_id_t;
 
 // PID storage
 typedef struct { float Kp, Ki, Kd;     } PID_t;
 typedef struct { float Kp, Ki, Kd, Kc; } PIDC_t;
 typedef struct { float Kp, Ki, Kd, Kf; } PIDF_t;
 typedef struct { float Kp, Ki, Kd, Kc, Kf; } PIDCF_t;
 
 typedef
@@ -92,20 +92,23 @@ enum ADCSensorState : char {
   StartSampling,
   #if HAS_TEMP_ADC_0
     PrepareTemp_0, MeasureTemp_0,
   #endif
   #if HAS_TEMP_ADC_BED
     PrepareTemp_BED, MeasureTemp_BED,
   #endif
   #if HAS_TEMP_ADC_CHAMBER
     PrepareTemp_CHAMBER, MeasureTemp_CHAMBER,
   #endif
+  #if HAS_TEMP_ADC_COOLER
+    PrepareTemp_COOLER, MeasureTemp_COOLER,
+  #endif
   #if HAS_TEMP_ADC_PROBE
     PrepareTemp_PROBE, MeasureTemp_PROBE,
   #endif
   #if HAS_TEMP_ADC_1
     PrepareTemp_1, MeasureTemp_1,
   #endif
   #if HAS_TEMP_ADC_2
     PrepareTemp_2, MeasureTemp_2,
   #endif
   #if HAS_TEMP_ADC_3
@@ -211,20 +214,23 @@ struct PIDHeaterInfo : public HeaterInfo {
 #endif
 #if HAS_HEATED_CHAMBER
   #if ENABLED(PIDTEMPCHAMBER)
     typedef struct PIDHeaterInfo<PID_t> chamber_info_t;
   #else
     typedef heater_info_t chamber_info_t;
   #endif
 #elif HAS_TEMP_CHAMBER
   typedef temp_info_t chamber_info_t;
 #endif
+#if EITHER(HAS_COOLER, HAS_TEMP_COOLER)
+  typedef heater_info_t cooler_info_t;
+#endif
 
 // Heater watch handling
 template <int INCREASE, int HYSTERESIS, millis_t PERIOD>
 struct HeaterWatch {
   uint16_t target;
   millis_t next_ms;
   inline bool elapsed(const millis_t &ms) { return next_ms && ELAPSED(ms, next_ms); }
   inline bool elapsed() { return elapsed(millis()); }
 
   inline void restart(const int16_t curr, const int16_t tgt) {
@@ -242,20 +248,23 @@ struct HeaterWatch {
 
 #if WATCH_HOTENDS
   typedef struct HeaterWatch<WATCH_TEMP_INCREASE, TEMP_HYSTERESIS, WATCH_TEMP_PERIOD> hotend_watch_t;
 #endif
 #if WATCH_BED
   typedef struct HeaterWatch<WATCH_BED_TEMP_INCREASE, TEMP_BED_HYSTERESIS, WATCH_BED_TEMP_PERIOD> bed_watch_t;
 #endif
 #if WATCH_CHAMBER
   typedef struct HeaterWatch<WATCH_CHAMBER_TEMP_INCREASE, TEMP_CHAMBER_HYSTERESIS, WATCH_CHAMBER_TEMP_PERIOD> chamber_watch_t;
 #endif
+#if WATCH_COOLER
+  typedef struct HeaterWatch<WATCH_COOLER_TEMP_INCREASE, TEMP_COOLER_HYSTERESIS, WATCH_COOLER_TEMP_PERIOD> cooler_watch_t;
+#endif
 
 // Temperature sensor read value ranges
 typedef struct { int16_t raw_min, raw_max; } raw_range_t;
 typedef struct { int16_t mintemp, maxtemp; } celsius_range_t;
 typedef struct { int16_t raw_min, raw_max, mintemp, maxtemp; } temp_range_t;
 
 #define THERMISTOR_ABS_ZERO_C           -273.15f  // bbbbrrrrr cold !
 #define THERMISTOR_RESISTANCE_NOMINAL_C 25.0f     // mmmmm comfortable
 
 #if HAS_USER_THERMISTORS
@@ -281,20 +290,23 @@ typedef struct { int16_t raw_min, raw_max, mintemp, maxtemp; } temp_range_t;
     #endif
     #if TEMP_SENSOR_BED_IS_CUSTOM
       CTI_BED,
     #endif
     #if TEMP_SENSOR_PROBE_IS_CUSTOM
       CTI_PROBE,
     #endif
     #if TEMP_SENSOR_CHAMBER_IS_CUSTOM
       CTI_CHAMBER,
     #endif
+    #if COOLER_USER_THERMISTOR
+      CTI_COOLER,
+    #endif
     USER_THERMISTORS
   };
 
   // User-defined thermistor
   typedef struct {
     bool pre_calc;     // true if pre-calculations update needed
     float sh_c_coeff,  // Steinhart-Hart C coefficient .. defaults to '0.0'
           sh_alpha,
           series_res,
           res_25, res_25_recip,
@@ -309,23 +321,25 @@ class Temperature {
   public:
 
     #if HAS_HOTEND
       #define HOTEND_TEMPS (HOTENDS + ENABLED(TEMP_SENSOR_1_AS_REDUNDANT))
       static hotend_info_t temp_hotend[HOTEND_TEMPS];
       static const uint16_t heater_maxtemp[HOTENDS];
     #endif
     TERN_(HAS_HEATED_BED, static bed_info_t temp_bed);
     TERN_(HAS_TEMP_PROBE, static probe_info_t temp_probe);
     TERN_(HAS_TEMP_CHAMBER, static chamber_info_t temp_chamber);
+    TERN_(HAS_TEMP_COOLER, static cooler_info_t temp_cooler);
 
     TERN_(AUTO_POWER_E_FANS, static uint8_t autofan_speed[HOTENDS]);
     TERN_(AUTO_POWER_CHAMBER_FAN, static uint8_t chamberfan_speed);
+    TERN_(AUTO_POWER_COOLER_FAN, static uint8_t coolerfan_speed);
 
     #if ENABLED(FAN_SOFT_PWM)
       static uint8_t soft_pwm_amount_fan[FAN_COUNT],
                      soft_pwm_count_fan[FAN_COUNT];
     #endif
 
     #if ENABLED(PREVENT_COLD_EXTRUSION)
       static bool allow_cold_extrude;
       static int16_t extrude_min_temp;
       FORCE_INLINE static bool tooCold(const int16_t temp) { return allow_cold_extrude ? false : temp < extrude_min_temp - (TEMP_WINDOW); }
@@ -421,20 +435,31 @@ class Temperature {
       TERN_(WATCH_CHAMBER, static chamber_watch_t watch_chamber);
       TERN(PIDTEMPCHAMBER,,static millis_t next_chamber_check_ms);
       #ifdef CHAMBER_MINTEMP
         static int16_t mintemp_raw_CHAMBER;
       #endif
       #ifdef CHAMBER_MAXTEMP
         static int16_t maxtemp_raw_CHAMBER;
       #endif
     #endif
 
+    #if HAS_COOLER
+      TERN_(WATCH_COOLER, static cooler_watch_t watch_cooler);
+      static millis_t next_cooler_check_ms, cooler_fan_flush_ms;
+      #ifdef COOLER_MINTEMP
+        static int16_t mintemp_raw_COOLER;
+      #endif
+      #ifdef COOLER_MAXTEMP
+        static int16_t maxtemp_raw_COOLER;
+      #endif
+    #endif
+
     #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
       static uint8_t consecutive_low_temperature_error[HOTENDS];
     #endif
 
     #ifdef MILLISECONDS_PREHEAT_TIME
       static millis_t preheat_end_time[HOTENDS];
     #endif
 
     TERN_(HAS_AUTO_FAN, static millis_t next_auto_fan_check_ms);
 
@@ -485,30 +510,32 @@ class Temperature {
         if (!WITHIN(value, -0.01f, 0.01f)) return false;
         user_thermistor[t_index].sh_c_coeff = value;
         user_thermistor[t_index].pre_calc = true;
         return true;
       }
     #endif
 
     #if HAS_HOTEND
       static float analog_to_celsius_hotend(const int raw, const uint8_t e);
     #endif
-
     #if HAS_HEATED_BED
       static float analog_to_celsius_bed(const int raw);
     #endif
     #if HAS_TEMP_PROBE
       static float analog_to_celsius_probe(const int raw);
     #endif
     #if HAS_TEMP_CHAMBER
       static float analog_to_celsius_chamber(const int raw);
     #endif
+    #if HAS_TEMP_COOLER
+      static float analog_to_celsius_cooler(const int raw);
+    #endif
 
     #if HAS_FAN
 
       static uint8_t fan_speed[FAN_COUNT];
       #define FANS_LOOP(I) LOOP_L_N(I, FAN_COUNT)
 
       static void set_fan_speed(const uint8_t target, const uint16_t speed);
 
       #if ENABLED(REPORT_FAN_CHANGE)
         static void report_fan_speed(const uint8_t target);
@@ -730,20 +757,52 @@ class Temperature {
           #ifdef CHAMBER_MAXTEMP
             _MIN(celsius, CHAMBER_MAXTEMP - 10)
           #else
             celsius
           #endif
         ;
         start_watching_chamber();
       }
     #endif
 
+    #if HAS_TEMP_COOLER
+      #if ENABLED(SHOW_TEMP_ADC_VALUES)
+        FORCE_INLINE static int16_t rawCoolerTemp()    { return temp_cooler.raw; }
+      #endif
+      FORCE_INLINE static float degCooler()            { return temp_cooler.celsius; }
+      #if HAS_COOLER
+        FORCE_INLINE static int16_t degTargetCooler()  { return temp_cooler.target; }
+        FORCE_INLINE static bool isLaserHeating()     { return temp_cooler.target > temp_cooler.celsius; }
+        FORCE_INLINE static bool isLaserCooling()     { return temp_cooler.target < temp_cooler.celsius; }
+        static bool wait_for_cooler(const bool no_wait_for_cooling=true);
+      #endif
+    #endif
+
+    #if WATCH_COOLER
+      static void start_watching_cooler();
+    #else
+      static inline void start_watching_cooler() {}
+    #endif
+
+    #if HAS_COOLER
+      static void setTargetCooler(const int16_t celsius) {
+        temp_cooler.target =
+          #ifdef COOLER_MAXTEMP
+            _MIN(celsius, COOLER_MAXTEMP - 10)
+          #else
+            celsius
+          #endif
+        ;
+        start_watching_cooler();
+      }
+    #endif
+
     /**
      * The software PWM power for a heater
      */
     static int16_t getHeaterPower(const heater_id_t heater_id);
 
     /**
      * Switch off all heaters, set all target temperatures to 0
      */
     static void disable_all_heaters();
 
@@ -840,45 +899,51 @@ class Temperature {
     static void checkExtruderAutoFans();
 
     TERN_(HAS_HOTEND,     static float get_pid_output_hotend(const uint8_t e));
     TERN_(PIDTEMPBED,     static float get_pid_output_bed());
     TERN_(PIDTEMPCHAMBER, static float get_pid_output_chamber());
 
     static void _temp_error(const heater_id_t e, PGM_P const serial_msg, PGM_P const lcd_msg);
     static void min_temp_error(const heater_id_t e);
     static void max_temp_error(const heater_id_t e);
 
-    #define HAS_THERMAL_PROTECTION ANY(THERMAL_PROTECTION_HOTENDS, THERMAL_PROTECTION_CHAMBER, HAS_THERMALLY_PROTECTED_BED)
+    #define HAS_THERMAL_PROTECTION ANY(THERMAL_PROTECTION_HOTENDS, THERMAL_PROTECTION_CHAMBER, HAS_THERMALLY_PROTECTED_BED, THERMAL_PROTECTION_COOLER)
 
     #if HAS_THERMAL_PROTECTION
 
       // Indices and size for the tr_state_machine array. One for each protected heater.
       #define _ENUM_FOR_E(N) RUNAWAY_IND_E##N,
       enum RunawayIndex : uint8_t {
         #if ENABLED(THERMAL_PROTECTION_HOTENDS)
           REPEAT(HOTENDS, _ENUM_FOR_E)
         #endif
         #if ENABLED(HAS_THERMALLY_PROTECTED_BED)
           RUNAWAY_IND_BED,
         #endif
         #if ENABLED(THERMAL_PROTECTION_CHAMBER)
           RUNAWAY_IND_CHAMBER,
         #endif
+        #if ENABLED(THERMAL_PROTECTION_COOLER)
+          RUNAWAY_IND_COOLER,
+        #endif
         NR_HEATER_RUNAWAY
       };
       #undef _ENUM_FOR_E
 
       // Convert the given heater_id_t to runaway state array index
       static inline RunawayIndex runaway_index_for_id(const int8_t heater_id) {
         #if HAS_THERMALLY_PROTECTED_CHAMBER
           if (heater_id == H_CHAMBER) return RUNAWAY_IND_CHAMBER;
         #endif
+        #if HAS_THERMALLY_PROTECTED_CHAMBER
+          if (heater_id == H_COOLER) return RUNAWAY_IND_COOLER;
+        #endif
         #if HAS_THERMALLY_PROTECTED_BED
           if (heater_id == H_BED) return RUNAWAY_IND_BED;
         #endif
         return (RunawayIndex)_MAX(heater_id, 0);
       }
 
       enum TRState : char { TRInactive, TRFirstHeating, TRStable, TRRunaway };
 
       typedef struct {
         millis_t timer = 0;

commit 735c1b6183739152eeddade4c06c17e3b0de38bc
Author: Katelyn Schiesser <katelyn.schiesser@gmail.com>
Date:   Thu Feb 25 06:28:27 2021 -0800

    PROBING_HEATERS_OFF sub-option WAIT_FOR_HOTEND (#20835)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 1019c10fad..5f5a076911 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -623,20 +623,24 @@ class Temperature {
       FORCE_INLINE static bool isCoolingHotend(const uint8_t E_NAME) {
         return temp_hotend[HOTEND_INDEX].target < temp_hotend[HOTEND_INDEX].celsius;
       }
 
       #if HAS_TEMP_HOTEND
         static bool wait_for_hotend(const uint8_t target_extruder, const bool no_wait_for_cooling=true
           #if G26_CLICK_CAN_CANCEL
             , const bool click_to_cancel=false
           #endif
         );
+
+        #if ENABLED(WAIT_FOR_HOTEND)
+          static void wait_for_hotend_heating(const uint8_t target_extruder);
+        #endif
       #endif
 
       FORCE_INLINE static bool still_heating(const uint8_t e) {
         return degTargetHotend(e) > TEMP_HYSTERESIS && ABS(degHotend(e) - degTargetHotend(e)) > TEMP_HYSTERESIS;
       }
 
       FORCE_INLINE static bool degHotendNear(const uint8_t e, const float &temp) {
         return ABS(degHotend(e) - temp) < (TEMP_HYSTERESIS);
       }
 

commit a3a10b62f21cfbedfd001746faa46ac55d248b36
Author: Ken Sanislo <ksanislo@users.noreply.github.com>
Date:   Wed Feb 24 16:26:51 2021 -0800

    Chamber Heater PID (#21156)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 75da232874..1019c10fad 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -203,21 +203,25 @@ struct PIDHeaterInfo : public HeaterInfo {
   #if ENABLED(PIDTEMPBED)
     typedef struct PIDHeaterInfo<PID_t> bed_info_t;
   #else
     typedef heater_info_t bed_info_t;
   #endif
 #endif
 #if HAS_TEMP_PROBE
   typedef temp_info_t probe_info_t;
 #endif
 #if HAS_HEATED_CHAMBER
-  typedef heater_info_t chamber_info_t;
+  #if ENABLED(PIDTEMPCHAMBER)
+    typedef struct PIDHeaterInfo<PID_t> chamber_info_t;
+  #else
+    typedef heater_info_t chamber_info_t;
+  #endif
 #elif HAS_TEMP_CHAMBER
   typedef temp_info_t chamber_info_t;
 #endif
 
 // Heater watch handling
 template <int INCREASE, int HYSTERESIS, millis_t PERIOD>
 struct HeaterWatch {
   uint16_t target;
   millis_t next_ms;
   inline bool elapsed(const millis_t &ms) { return next_ms && ELAPSED(ms, next_ms); }
@@ -408,21 +412,21 @@ class Temperature {
       #ifdef BED_MINTEMP
         static int16_t mintemp_raw_BED;
       #endif
       #ifdef BED_MAXTEMP
         static int16_t maxtemp_raw_BED;
       #endif
     #endif
 
     #if HAS_HEATED_CHAMBER
       TERN_(WATCH_CHAMBER, static chamber_watch_t watch_chamber);
-      static millis_t next_chamber_check_ms;
+      TERN(PIDTEMPCHAMBER,,static millis_t next_chamber_check_ms);
       #ifdef CHAMBER_MINTEMP
         static int16_t mintemp_raw_CHAMBER;
       #endif
       #ifdef CHAMBER_MAXTEMP
         static int16_t maxtemp_raw_CHAMBER;
       #endif
     #endif
 
     #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
       static uint8_t consecutive_low_temperature_error[HOTENDS];
@@ -744,20 +748,25 @@ class Temperature {
        * Methods to check if heaters are enabled, indicating an active job
        */
       static bool auto_job_over_threshold();
       static void auto_job_check_timer(const bool can_start, const bool can_stop);
     #endif
 
     /**
      * Perform auto-tuning for hotend or bed in response to M303
      */
     #if HAS_PID_HEATING
+
+      #if ANY(PID_DEBUG, PID_BED_DEBUG, PID_CHAMBER_DEBUG)
+        static bool pid_debug_flag;
+      #endif
+
       static void PID_autotune(const float &target, const heater_id_t heater_id, const int8_t ncycles, const bool set_result=false);
 
       #if ENABLED(NO_FAN_SLOWING_IN_PID_TUNING)
         static bool adaptive_fan_slowing;
       #elif ENABLED(ADAPTIVE_FAN_SLOWING)
         static constexpr bool adaptive_fan_slowing = true;
       #endif
 
       /**
        * Update the temp manager when PID values change
@@ -819,25 +828,23 @@ class Temperature {
         #define HAS_MULTI_MAX_TC 1
         #define READ_MAX_TC(N) read_max_tc(N)
       #else
         #define READ_MAX_TC(N) read_max_tc()
       #endif
       static int read_max_tc(TERN_(HAS_MULTI_MAX_TC, const uint8_t hindex=0));
     #endif
 
     static void checkExtruderAutoFans();
 
-    static float get_pid_output_hotend(const uint8_t e);
-
-    TERN_(PIDTEMPBED, static float get_pid_output_bed());
-
-    TERN_(HAS_HEATED_CHAMBER, static float get_pid_output_chamber());
+    TERN_(HAS_HOTEND,     static float get_pid_output_hotend(const uint8_t e));
+    TERN_(PIDTEMPBED,     static float get_pid_output_bed());
+    TERN_(PIDTEMPCHAMBER, static float get_pid_output_chamber());
 
     static void _temp_error(const heater_id_t e, PGM_P const serial_msg, PGM_P const lcd_msg);
     static void min_temp_error(const heater_id_t e);
     static void max_temp_error(const heater_id_t e);
 
     #define HAS_THERMAL_PROTECTION ANY(THERMAL_PROTECTION_HOTENDS, THERMAL_PROTECTION_CHAMBER, HAS_THERMALLY_PROTECTED_BED)
 
     #if HAS_THERMAL_PROTECTION
 
       // Indices and size for the tr_state_machine array. One for each protected heater.

commit b35bfeb1c3f1271016227a1d79dcb552e67e3cb9
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Feb 7 16:58:06 2021 -0600

    Fix TEMP_0_TR_ENABLE, rename temp conditions (#21016)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 002e1cbf71..75da232874 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -250,45 +250,45 @@ struct HeaterWatch {
 typedef struct { int16_t raw_min, raw_max; } raw_range_t;
 typedef struct { int16_t mintemp, maxtemp; } celsius_range_t;
 typedef struct { int16_t raw_min, raw_max, mintemp, maxtemp; } temp_range_t;
 
 #define THERMISTOR_ABS_ZERO_C           -273.15f  // bbbbrrrrr cold !
 #define THERMISTOR_RESISTANCE_NOMINAL_C 25.0f     // mmmmm comfortable
 
 #if HAS_USER_THERMISTORS
 
   enum CustomThermistorIndex : uint8_t {
-    #if HEATER_0_USER_THERMISTOR
+    #if TEMP_SENSOR_0_IS_CUSTOM
       CTI_HOTEND_0,
     #endif
-    #if HEATER_1_USER_THERMISTOR
+    #if TEMP_SENSOR_1_IS_CUSTOM
       CTI_HOTEND_1,
     #endif
-    #if HEATER_2_USER_THERMISTOR
+    #if TEMP_SENSOR_2_IS_CUSTOM
       CTI_HOTEND_2,
     #endif
-    #if HEATER_3_USER_THERMISTOR
+    #if TEMP_SENSOR_3_IS_CUSTOM
       CTI_HOTEND_3,
     #endif
-    #if HEATER_4_USER_THERMISTOR
+    #if TEMP_SENSOR_4_IS_CUSTOM
       CTI_HOTEND_4,
     #endif
-    #if HEATER_5_USER_THERMISTOR
+    #if TEMP_SENSOR_5_IS_CUSTOM
       CTI_HOTEND_5,
     #endif
-    #if HEATER_BED_USER_THERMISTOR
+    #if TEMP_SENSOR_BED_IS_CUSTOM
       CTI_BED,
     #endif
-    #if HEATER_PROBE_USER_THERMISTOR
+    #if TEMP_SENSOR_PROBE_IS_CUSTOM
       CTI_PROBE,
     #endif
-    #if HEATER_CHAMBER_USER_THERMISTOR
+    #if TEMP_SENSOR_CHAMBER_IS_CUSTOM
       CTI_CHAMBER,
     #endif
     USER_THERMISTORS
   };
 
   // User-defined thermistor
   typedef struct {
     bool pre_calc;     // true if pre-calculations update needed
     float sh_c_coeff,  // Steinhart-Hart C coefficient .. defaults to '0.0'
           sh_alpha,
@@ -806,30 +806,29 @@ class Temperature {
     TERN_(HAS_DISPLAY, static void set_heating_message(const uint8_t e));
 
     #if HAS_LCD_MENU && HAS_TEMPERATURE
       static void lcd_preheat(const int16_t e, const int8_t indh, const int8_t indb);
     #endif
 
   private:
     static void update_raw_temperatures();
     static void updateTemperaturesFromRawValues();
 
-    #define HAS_MAX6675 EITHER(HEATER_0_USES_MAX6675, HEATER_1_USES_MAX6675)
-    #if HAS_MAX6675
-      #define COUNT_6675 1 + BOTH(HEATER_0_USES_MAX6675, HEATER_1_USES_MAX6675)
-      #if COUNT_6675 > 1
-        #define HAS_MULTI_6675 1
-        #define READ_MAX6675(N) read_max6675(N)
+    #if HAS_MAX_TC
+      #define MAX_TC_COUNT 1 + BOTH(TEMP_SENSOR_0_IS_MAX_TC, TEMP_SENSOR_1_IS_MAX_TC)
+      #if MAX_TC_COUNT > 1
+        #define HAS_MULTI_MAX_TC 1
+        #define READ_MAX_TC(N) read_max_tc(N)
       #else
-        #define READ_MAX6675(N) read_max6675()
+        #define READ_MAX_TC(N) read_max_tc()
       #endif
-      static int read_max6675(TERN_(HAS_MULTI_6675, const uint8_t hindex=0));
+      static int read_max_tc(TERN_(HAS_MULTI_MAX_TC, const uint8_t hindex=0));
     #endif
 
     static void checkExtruderAutoFans();
 
     static float get_pid_output_hotend(const uint8_t e);
 
     TERN_(PIDTEMPBED, static float get_pid_output_bed());
 
     TERN_(HAS_HEATED_CHAMBER, static float get_pid_output_chamber());
 

commit 07b4cc145bf6d84245b93f9f72fb0ac0f9d8d380
Author: X-Ryl669 <boite.pour.spam@gmail.com>
Date:   Mon Feb 1 01:11:50 2021 +0100

    Fix AutoReporter implementation (#20959)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 1401e0d354..002e1cbf71 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -791,22 +791,22 @@ class Temperature {
 
     #endif // HEATER_IDLE_HANDLER
 
     #if HAS_TEMP_SENSOR
       static void print_heater_states(const uint8_t target_extruder
         #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
           , const bool include_r=false
         #endif
       );
       #if ENABLED(AUTO_REPORT_TEMPERATURES)
-        class AutoReportTemp : public AutoReporter<SERIAL_ALL> { void auto_report(); };
-        static AutoReportTemp auto_reporter;
+        struct AutoReportTemp { static void report(); };
+        static AutoReporter<AutoReportTemp> auto_reporter;
       #endif
     #endif
 
     TERN_(HAS_DISPLAY, static void set_heating_message(const uint8_t e));
 
     #if HAS_LCD_MENU && HAS_TEMPERATURE
       static void lcd_preheat(const int16_t e, const int8_t indh, const int8_t indb);
     #endif
 
   private:

commit 9d0e64a725290233d6002017147c578ffd32c504
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jan 28 20:40:20 2021 -0600

    AutoReport class (Temperature, Cardreader) (#20913)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 86c202cadc..1401e0d354 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -26,20 +26,24 @@
  */
 
 #include "thermistor/thermistors.h"
 
 #include "../inc/MarlinConfig.h"
 
 #if ENABLED(AUTO_POWER_CONTROL)
   #include "../feature/power.h"
 #endif
 
+#if ENABLED(AUTO_REPORT_TEMPERATURES)
+  #include "../libs/autoreport.h"
+#endif
+
 #ifndef SOFT_PWM_SCALE
   #define SOFT_PWM_SCALE 0
 #endif
 
 #define HOTEND_INDEX TERN(HAS_MULTI_HOTEND, e, 0)
 #define E_NAME TERN_(HAS_MULTI_HOTEND, e)
 
 // Heater identifiers. Positive values are hotends. Negative values are other heaters.
 typedef enum : int8_t {
   INDEX_NONE = -5,
@@ -787,28 +791,22 @@ class Temperature {
 
     #endif // HEATER_IDLE_HANDLER
 
     #if HAS_TEMP_SENSOR
       static void print_heater_states(const uint8_t target_extruder
         #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
           , const bool include_r=false
         #endif
       );
       #if ENABLED(AUTO_REPORT_TEMPERATURES)
-        static uint8_t auto_report_temp_interval;
-        static millis_t next_temp_report_ms;
-        static void auto_report_temperatures();
-        static inline void set_auto_report_interval(uint8_t v) {
-          NOMORE(v, 60);
-          auto_report_temp_interval = v;
-          next_temp_report_ms = millis() + 1000UL * v;
-        }
+        class AutoReportTemp : public AutoReporter<SERIAL_ALL> { void auto_report(); };
+        static AutoReportTemp auto_reporter;
       #endif
     #endif
 
     TERN_(HAS_DISPLAY, static void set_heating_message(const uint8_t e));
 
     #if HAS_LCD_MENU && HAS_TEMPERATURE
       static void lcd_preheat(const int16_t e, const int8_t indh, const int8_t indb);
     #endif
 
   private:

commit 3f90ecfd77b608908d9a945a79518842f6d4471e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jan 19 20:58:50 2021 -0600

    Move singlenozzle temp/fan (#20829)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index f570fe2107..86c202cadc 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -328,20 +328,28 @@ class Temperature {
         return tooCold(degTargetHotend(HOTEND_INDEX));
       }
     #else
       FORCE_INLINE static bool tooColdToExtrude(const uint8_t) { return false; }
       FORCE_INLINE static bool targetTooColdToExtrude(const uint8_t) { return false; }
     #endif
 
     FORCE_INLINE static bool hotEnoughToExtrude(const uint8_t e) { return !tooColdToExtrude(e); }
     FORCE_INLINE static bool targetHotEnoughToExtrude(const uint8_t e) { return !targetTooColdToExtrude(e); }
 
+    #if ENABLED(SINGLENOZZLE_STANDBY_FAN)
+      static uint16_t singlenozzle_temp[EXTRUDERS];
+      #if HAS_FAN
+        static uint8_t singlenozzle_fan_speed[EXTRUDERS];
+      #endif
+      static void singlenozzle_change(const uint8_t old_tool, const uint8_t new_tool);
+    #endif
+
     #if HEATER_IDLE_HANDLER
 
       // Heater idle handling. Marlin creates one per hotend and one for the heated bed.
       typedef struct {
         millis_t timeout_ms;
         bool timed_out;
         inline void update(const millis_t &ms) { if (!timed_out && timeout_ms && ELAPSED(ms, timeout_ms)) timed_out = true; }
         inline void start(const millis_t &ms) { timeout_ms = millis() + ms; timed_out = false; }
         inline void reset() { timeout_ms = 0; timed_out = false; }
         inline void expire() { start(0); }

commit 6376b683c78ec410ace0765ba91314055b78d927
Author: Marcio Teixeira <mlt4356-github@yahoo.com>
Date:   Thu Jan 14 08:48:29 2021 -0700

    Silence unused parameter warnings

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index aa4f2e7634..f570fe2107 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -62,21 +62,21 @@ typedef
     PIDF_t
   #else
     PID_t
   #endif
 hotend_pid_t;
 
 #if ENABLED(PID_EXTRUSION_SCALING)
   typedef IF<(LPQ_MAX_LEN > 255), uint16_t, uint8_t>::type lpq_ptr_t;
 #endif
 
-#define PID_PARAM(F,H) _PID_##F(TERN(PID_PARAMS_PER_HOTEND, H, 0))
+#define PID_PARAM(F,H) _PID_##F(TERN(PID_PARAMS_PER_HOTEND, H, 0 & H)) // Always use 'H' to suppress warning
 #define _PID_Kp(H) TERN(PIDTEMP, Temperature::temp_hotend[H].pid.Kp, NAN)
 #define _PID_Ki(H) TERN(PIDTEMP, Temperature::temp_hotend[H].pid.Ki, NAN)
 #define _PID_Kd(H) TERN(PIDTEMP, Temperature::temp_hotend[H].pid.Kd, NAN)
 #if ENABLED(PIDTEMP)
   #define _PID_Kc(H) TERN(PID_EXTRUSION_SCALING, Temperature::temp_hotend[H].pid.Kc, 1)
   #define _PID_Kf(H) TERN(PID_FAN_SCALING,       Temperature::temp_hotend[H].pid.Kf, 0)
 #else
   #define _PID_Kc(H) 1
   #define _PID_Kf(H) 0
 #endif

commit 2d88bcb67e558f508f37b16b2789fd3e2b1755e9
Author: Marcio T <mlt4356-github@yahoo.com>
Date:   Sun Jan 3 20:39:15 2021 -0700

    Fix thermal error protection, reporting (#20655)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 33f38c3036..aa4f2e7634 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -689,40 +689,40 @@ class Temperature {
         FORCE_INLINE static int16_t rawChamberTemp()    { return temp_chamber.raw; }
       #endif
       FORCE_INLINE static float degChamber()            { return temp_chamber.celsius; }
       #if HAS_HEATED_CHAMBER
         FORCE_INLINE static int16_t degTargetChamber()  { return temp_chamber.target; }
         FORCE_INLINE static bool isHeatingChamber()     { return temp_chamber.target > temp_chamber.celsius; }
         FORCE_INLINE static bool isCoolingChamber()     { return temp_chamber.target < temp_chamber.celsius; }
 
         static bool wait_for_chamber(const bool no_wait_for_cooling=true);
       #endif
-    #endif // HAS_TEMP_CHAMBER
+    #endif
 
     #if WATCH_CHAMBER
       static void start_watching_chamber();
     #else
       static inline void start_watching_chamber() {}
     #endif
 
     #if HAS_HEATED_CHAMBER
       static void setTargetChamber(const int16_t celsius) {
         temp_chamber.target =
           #ifdef CHAMBER_MAXTEMP
             _MIN(celsius, CHAMBER_MAXTEMP - 10)
           #else
             celsius
           #endif
         ;
         start_watching_chamber();
       }
-    #endif // HAS_HEATED_CHAMBER
+    #endif
 
     /**
      * The software PWM power for a heater
      */
     static int16_t getHeaterPower(const heater_id_t heater_id);
 
     /**
      * Switch off all heaters, set all target temperatures to 0
      */
     static void disable_all_heaters();

commit 58eaad703a5e369ab3bf6a1d325b8775d89ede0d
Author: Jason Smith <jason.inet@gmail.com>
Date:   Sun Nov 22 16:47:52 2020 -0800

    Fix dummy thermistors for Bed, Chamber, Probe (#20247)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index edaa1c5384..33f38c3036 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -82,27 +82,27 @@ hotend_pid_t;
 #endif
 
 /**
  * States for ADC reading in the ISR
  */
 enum ADCSensorState : char {
   StartSampling,
   #if HAS_TEMP_ADC_0
     PrepareTemp_0, MeasureTemp_0,
   #endif
-  #if HAS_HEATED_BED
+  #if HAS_TEMP_ADC_BED
     PrepareTemp_BED, MeasureTemp_BED,
   #endif
-  #if HAS_TEMP_CHAMBER
+  #if HAS_TEMP_ADC_CHAMBER
     PrepareTemp_CHAMBER, MeasureTemp_CHAMBER,
   #endif
-  #if HAS_TEMP_PROBE
+  #if HAS_TEMP_ADC_PROBE
     PrepareTemp_PROBE, MeasureTemp_PROBE,
   #endif
   #if HAS_TEMP_ADC_1
     PrepareTemp_1, MeasureTemp_1,
   #endif
   #if HAS_TEMP_ADC_2
     PrepareTemp_2, MeasureTemp_2,
   #endif
   #if HAS_TEMP_ADC_3
     PrepareTemp_3, MeasureTemp_3,

commit 40d442fde294faedf839e3a80c82cd72c1824ba8
Author: JoAnn Manges <joannmanges@gmail.com>
Date:   Wed Nov 11 16:52:35 2020 -0500

    Fix MAX31865 on SPI (PT100/1000) support (#20074)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 4090b845d3..edaa1c5384 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -804,21 +804,21 @@ class Temperature {
     #endif
 
   private:
     static void update_raw_temperatures();
     static void updateTemperaturesFromRawValues();
 
     #define HAS_MAX6675 EITHER(HEATER_0_USES_MAX6675, HEATER_1_USES_MAX6675)
     #if HAS_MAX6675
       #define COUNT_6675 1 + BOTH(HEATER_0_USES_MAX6675, HEATER_1_USES_MAX6675)
       #if COUNT_6675 > 1
-        #define HAS_MULTI_6675
+        #define HAS_MULTI_6675 1
         #define READ_MAX6675(N) read_max6675(N)
       #else
         #define READ_MAX6675(N) read_max6675()
       #endif
       static int read_max6675(TERN_(HAS_MULTI_6675, const uint8_t hindex=0));
     #endif
 
     static void checkExtruderAutoFans();
 
     static float get_pid_output_hotend(const uint8_t e);

commit 59eca253e1518f17e1ffe962ffc6e7bfa0db49a3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Nov 9 01:17:37 2020 -0600

    Simplified temp sensor conditionals

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index c3c3ce2d8b..4090b845d3 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -246,45 +246,45 @@ struct HeaterWatch {
 typedef struct { int16_t raw_min, raw_max; } raw_range_t;
 typedef struct { int16_t mintemp, maxtemp; } celsius_range_t;
 typedef struct { int16_t raw_min, raw_max, mintemp, maxtemp; } temp_range_t;
 
 #define THERMISTOR_ABS_ZERO_C           -273.15f  // bbbbrrrrr cold !
 #define THERMISTOR_RESISTANCE_NOMINAL_C 25.0f     // mmmmm comfortable
 
 #if HAS_USER_THERMISTORS
 
   enum CustomThermistorIndex : uint8_t {
-    #if ENABLED(HEATER_0_USER_THERMISTOR)
+    #if HEATER_0_USER_THERMISTOR
       CTI_HOTEND_0,
     #endif
-    #if ENABLED(HEATER_1_USER_THERMISTOR)
+    #if HEATER_1_USER_THERMISTOR
       CTI_HOTEND_1,
     #endif
-    #if ENABLED(HEATER_2_USER_THERMISTOR)
+    #if HEATER_2_USER_THERMISTOR
       CTI_HOTEND_2,
     #endif
-    #if ENABLED(HEATER_3_USER_THERMISTOR)
+    #if HEATER_3_USER_THERMISTOR
       CTI_HOTEND_3,
     #endif
-    #if ENABLED(HEATER_4_USER_THERMISTOR)
+    #if HEATER_4_USER_THERMISTOR
       CTI_HOTEND_4,
     #endif
-    #if ENABLED(HEATER_5_USER_THERMISTOR)
+    #if HEATER_5_USER_THERMISTOR
       CTI_HOTEND_5,
     #endif
-    #if ENABLED(HEATER_BED_USER_THERMISTOR)
+    #if HEATER_BED_USER_THERMISTOR
       CTI_BED,
     #endif
-    #if ENABLED(HEATER_PROBE_USER_THERMISTOR)
+    #if HEATER_PROBE_USER_THERMISTOR
       CTI_PROBE,
     #endif
-    #if ENABLED(HEATER_CHAMBER_USER_THERMISTOR)
+    #if HEATER_CHAMBER_USER_THERMISTOR
       CTI_CHAMBER,
     #endif
     USER_THERMISTORS
   };
 
   // User-defined thermistor
   typedef struct {
     bool pre_calc;     // true if pre-calculations update needed
     float sh_c_coeff,  // Steinhart-Hart C coefficient .. defaults to '0.0'
           sh_alpha,
@@ -804,29 +804,26 @@ class Temperature {
     #endif
 
   private:
     static void update_raw_temperatures();
     static void updateTemperaturesFromRawValues();
 
     #define HAS_MAX6675 EITHER(HEATER_0_USES_MAX6675, HEATER_1_USES_MAX6675)
     #if HAS_MAX6675
       #define COUNT_6675 1 + BOTH(HEATER_0_USES_MAX6675, HEATER_1_USES_MAX6675)
       #if COUNT_6675 > 1
+        #define HAS_MULTI_6675
         #define READ_MAX6675(N) read_max6675(N)
       #else
         #define READ_MAX6675(N) read_max6675()
       #endif
-      static int read_max6675(
-        #if COUNT_6675 > 1
-          const uint8_t hindex=0
-        #endif
-      );
+      static int read_max6675(TERN_(HAS_MULTI_6675, const uint8_t hindex=0));
     #endif
 
     static void checkExtruderAutoFans();
 
     static float get_pid_output_hotend(const uint8_t e);
 
     TERN_(PIDTEMPBED, static float get_pid_output_bed());
 
     TERN_(HAS_HEATED_CHAMBER, static float get_pid_output_chamber());
 

commit 06bf3ccfb7a19c972e5f40816d49e3860711f976
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Nov 7 18:28:29 2020 -0600

    Add alternative TERN macros

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 4b27fff19d..c3c3ce2d8b 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -385,21 +385,21 @@ class Temperature {
 
     #if ENABLED(PID_EXTRUSION_SCALING)
       static int32_t last_e_position, lpq[LPQ_MAX_LEN];
       static lpq_ptr_t lpq_ptr;
     #endif
 
     TERN_(HAS_HOTEND, static temp_range_t temp_range[HOTENDS]);
 
     #if HAS_HEATED_BED
       TERN_(WATCH_BED, static bed_watch_t watch_bed);
-      TERN(PIDTEMPBED,,static millis_t next_bed_check_ms);
+      IF_DISABLED(PIDTEMPBED, static millis_t next_bed_check_ms);
       #ifdef BED_MINTEMP
         static int16_t mintemp_raw_BED;
       #endif
       #ifdef BED_MAXTEMP
         static int16_t maxtemp_raw_BED;
       #endif
     #endif
 
     #if HAS_HEATED_CHAMBER
       TERN_(WATCH_CHAMBER, static chamber_watch_t watch_chamber);

commit dcb0f5dc3b70f22fb3d9391525d260dbd2bef9d6
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Nov 7 17:55:31 2020 -0600

    Temperature 'autostart' => 'auto_job'

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 57b0fecbcc..4b27fff19d 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -724,22 +724,22 @@ class Temperature {
 
     /**
      * Switch off all heaters, set all target temperatures to 0
      */
     static void disable_all_heaters();
 
     #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
       /**
        * Methods to check if heaters are enabled, indicating an active job
        */
-      static bool over_autostart_threshold();
-      static void check_timer_autostart(const bool can_start, const bool can_stop);
+      static bool auto_job_over_threshold();
+      static void auto_job_check_timer(const bool can_start, const bool can_stop);
     #endif
 
     /**
      * Perform auto-tuning for hotend or bed in response to M303
      */
     #if HAS_PID_HEATING
       static void PID_autotune(const float &target, const heater_id_t heater_id, const int8_t ncycles, const bool set_result=false);
 
       #if ENABLED(NO_FAN_SLOWING_IN_PID_TUNING)
         static bool adaptive_fan_slowing;

commit 979876e958e73e642b51eb655461c92947fe1deb
Author: ellensp <ellensp@hotmail.com>
Date:   Mon Sep 14 16:58:39 2020 +1200

    Improve temperature runaway, idle timeout (#19339)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 37d1140f5e..57b0fecbcc 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -33,21 +33,21 @@
   #include "../feature/power.h"
 #endif
 
 #ifndef SOFT_PWM_SCALE
   #define SOFT_PWM_SCALE 0
 #endif
 
 #define HOTEND_INDEX TERN(HAS_MULTI_HOTEND, e, 0)
 #define E_NAME TERN_(HAS_MULTI_HOTEND, e)
 
-// Identifiers for other heaters
+// Heater identifiers. Positive values are hotends. Negative values are other heaters.
 typedef enum : int8_t {
   INDEX_NONE = -5,
   H_PROBE, H_REDUNDANT, H_CHAMBER, H_BED,
   H_E0, H_E1, H_E2, H_E3, H_E4, H_E5, H_E6, H_E7
 } heater_id_t;
 
 // PID storage
 typedef struct { float Kp, Ki, Kd;     } PID_t;
 typedef struct { float Kp, Ki, Kd, Kc; } PIDC_t;
 typedef struct { float Kp, Ki, Kd, Kf; } PIDF_t;
@@ -204,30 +204,20 @@ struct PIDHeaterInfo : public HeaterInfo {
 #endif
 #if HAS_TEMP_PROBE
   typedef temp_info_t probe_info_t;
 #endif
 #if HAS_HEATED_CHAMBER
   typedef heater_info_t chamber_info_t;
 #elif HAS_TEMP_CHAMBER
   typedef temp_info_t chamber_info_t;
 #endif
 
-// Heater idle handling
-typedef struct {
-  millis_t timeout_ms;
-  bool timed_out;
-  inline void update(const millis_t &ms) { if (!timed_out && timeout_ms && ELAPSED(ms, timeout_ms)) timed_out = true; }
-  inline void start(const millis_t &ms) { timeout_ms = millis() + ms; timed_out = false; }
-  inline void reset() { timeout_ms = 0; timed_out = false; }
-  inline void expire() { start(0); }
-} hotend_idle_t;
-
 // Heater watch handling
 template <int INCREASE, int HYSTERESIS, millis_t PERIOD>
 struct HeaterWatch {
   uint16_t target;
   millis_t next_ms;
   inline bool elapsed(const millis_t &ms) { return next_ms && ELAPSED(ms, next_ms); }
   inline bool elapsed() { return elapsed(millis()); }
 
   inline void restart(const int16_t curr, const int16_t tgt) {
     if (tgt) {
@@ -339,23 +329,52 @@ class Temperature {
       }
     #else
       FORCE_INLINE static bool tooColdToExtrude(const uint8_t) { return false; }
       FORCE_INLINE static bool targetTooColdToExtrude(const uint8_t) { return false; }
     #endif
 
     FORCE_INLINE static bool hotEnoughToExtrude(const uint8_t e) { return !tooColdToExtrude(e); }
     FORCE_INLINE static bool targetHotEnoughToExtrude(const uint8_t e) { return !targetTooColdToExtrude(e); }
 
     #if HEATER_IDLE_HANDLER
-      static hotend_idle_t hotend_idle[HOTENDS];
-      TERN_(HAS_HEATED_BED, static hotend_idle_t bed_idle);
-      TERN_(HAS_HEATED_CHAMBER, static hotend_idle_t chamber_idle);
+
+      // Heater idle handling. Marlin creates one per hotend and one for the heated bed.
+      typedef struct {
+        millis_t timeout_ms;
+        bool timed_out;
+        inline void update(const millis_t &ms) { if (!timed_out && timeout_ms && ELAPSED(ms, timeout_ms)) timed_out = true; }
+        inline void start(const millis_t &ms) { timeout_ms = millis() + ms; timed_out = false; }
+        inline void reset() { timeout_ms = 0; timed_out = false; }
+        inline void expire() { start(0); }
+      } heater_idle_t;
+
+      // Indices and size for the heater_idle array
+      #define _ENUM_FOR_E(N) IDLE_INDEX_E##N,
+      enum IdleIndex : uint8_t {
+        REPEAT(HOTENDS, _ENUM_FOR_E)
+        #if ENABLED(HAS_HEATED_BED)
+          IDLE_INDEX_BED,
+        #endif
+        NR_HEATER_IDLE
+      };
+      #undef _ENUM_FOR_E
+
+      // Convert the given heater_id_t to idle array index
+      static inline IdleIndex idle_index_for_id(const int8_t heater_id) {
+        #if HAS_HEATED_BED
+          if (heater_id == H_BED) return IDLE_INDEX_BED;
+        #endif
+        return (IdleIndex)_MAX(heater_id, 0);
+      }
+
+      static heater_idle_t heater_idle[NR_HEATER_IDLE];
+
     #endif
 
   private:
 
     TERN_(EARLY_WATCHDOG, static bool inited);   // If temperature controller is running
 
     static volatile bool raw_temps_ready;
 
     TERN_(WATCH_HOTENDS, static hotend_watch_t watch_hotend[HOTENDS]);
 
@@ -740,27 +759,27 @@ class Temperature {
     #endif
 
     #if ENABLED(PROBING_HEATERS_OFF)
       static void pause(const bool p);
       FORCE_INLINE static bool is_paused() { return paused; }
     #endif
 
     #if HEATER_IDLE_HANDLER
 
       static void reset_hotend_idle_timer(const uint8_t E_NAME) {
-        hotend_idle[HOTEND_INDEX].reset();
+        heater_idle[HOTEND_INDEX].reset();
         start_watching_hotend(HOTEND_INDEX);
       }
 
       #if HAS_HEATED_BED
         static void reset_bed_idle_timer() {
-          bed_idle.reset();
+          heater_idle[IDLE_INDEX_BED].reset();
           start_watching_bed();
         }
       #endif
 
     #endif // HEATER_IDLE_HANDLER
 
     #if HAS_TEMP_SENSOR
       static void print_heater_states(const uint8_t target_extruder
         #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
           , const bool include_r=false
@@ -808,31 +827,56 @@ class Temperature {
     static float get_pid_output_hotend(const uint8_t e);
 
     TERN_(PIDTEMPBED, static float get_pid_output_bed());
 
     TERN_(HAS_HEATED_CHAMBER, static float get_pid_output_chamber());
 
     static void _temp_error(const heater_id_t e, PGM_P const serial_msg, PGM_P const lcd_msg);
     static void min_temp_error(const heater_id_t e);
     static void max_temp_error(const heater_id_t e);
 
-    #define HAS_THERMAL_PROTECTION (EITHER(THERMAL_PROTECTION_HOTENDS, THERMAL_PROTECTION_CHAMBER) || HAS_THERMALLY_PROTECTED_BED)
+    #define HAS_THERMAL_PROTECTION ANY(THERMAL_PROTECTION_HOTENDS, THERMAL_PROTECTION_CHAMBER, HAS_THERMALLY_PROTECTED_BED)
 
     #if HAS_THERMAL_PROTECTION
 
+      // Indices and size for the tr_state_machine array. One for each protected heater.
+      #define _ENUM_FOR_E(N) RUNAWAY_IND_E##N,
+      enum RunawayIndex : uint8_t {
+        #if ENABLED(THERMAL_PROTECTION_HOTENDS)
+          REPEAT(HOTENDS, _ENUM_FOR_E)
+        #endif
+        #if ENABLED(HAS_THERMALLY_PROTECTED_BED)
+          RUNAWAY_IND_BED,
+        #endif
+        #if ENABLED(THERMAL_PROTECTION_CHAMBER)
+          RUNAWAY_IND_CHAMBER,
+        #endif
+        NR_HEATER_RUNAWAY
+      };
+      #undef _ENUM_FOR_E
+
+      // Convert the given heater_id_t to runaway state array index
+      static inline RunawayIndex runaway_index_for_id(const int8_t heater_id) {
+        #if HAS_THERMALLY_PROTECTED_CHAMBER
+          if (heater_id == H_CHAMBER) return RUNAWAY_IND_CHAMBER;
+        #endif
+        #if HAS_THERMALLY_PROTECTED_BED
+          if (heater_id == H_BED) return RUNAWAY_IND_BED;
+        #endif
+        return (RunawayIndex)_MAX(heater_id, 0);
+      }
+
       enum TRState : char { TRInactive, TRFirstHeating, TRStable, TRRunaway };
 
       typedef struct {
         millis_t timer = 0;
         TRState state = TRInactive;
+        float running_temp;
+        void run(const float &current, const float &target, const heater_id_t heater_id, const uint16_t period_seconds, const uint16_t hysteresis_degc);
       } tr_state_machine_t;
 
-      TERN_(THERMAL_PROTECTION_HOTENDS, static tr_state_machine_t tr_state_machine[HOTENDS]);
-      TERN_(HAS_THERMALLY_PROTECTED_BED, static tr_state_machine_t tr_state_machine_bed);
-      TERN_(THERMAL_PROTECTION_CHAMBER, static tr_state_machine_t tr_state_machine_chamber);
-
-      static void thermal_runaway_protection(tr_state_machine_t &state, const float &current, const float &target, const heater_id_t heater_id, const uint16_t period_seconds, const uint16_t hysteresis_degc);
+      static tr_state_machine_t tr_state_machine[NR_HEATER_RUNAWAY];
 
     #endif // HAS_THERMAL_PROTECTION
 };
 
 extern Temperature thermalManager;

commit 49ca16c3fb103e8e29f64107ba664aa82917b9f1
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 13 18:06:14 2020 -0500

    heater_ind_t => heater_id_t

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 2148f4cb68..37d1140f5e 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -38,21 +38,21 @@
 #endif
 
 #define HOTEND_INDEX TERN(HAS_MULTI_HOTEND, e, 0)
 #define E_NAME TERN_(HAS_MULTI_HOTEND, e)
 
 // Identifiers for other heaters
 typedef enum : int8_t {
   INDEX_NONE = -5,
   H_PROBE, H_REDUNDANT, H_CHAMBER, H_BED,
   H_E0, H_E1, H_E2, H_E3, H_E4, H_E5, H_E6, H_E7
-} heater_ind_t;
+} heater_id_t;
 
 // PID storage
 typedef struct { float Kp, Ki, Kd;     } PID_t;
 typedef struct { float Kp, Ki, Kd, Kc; } PIDC_t;
 typedef struct { float Kp, Ki, Kd, Kf; } PIDF_t;
 typedef struct { float Kp, Ki, Kd, Kc, Kf; } PIDCF_t;
 
 typedef
   #if BOTH(PID_EXTRUSION_SCALING, PID_FAN_SCALING)
     PIDCF_t
@@ -694,40 +694,40 @@ class Temperature {
             celsius
           #endif
         ;
         start_watching_chamber();
       }
     #endif // HAS_HEATED_CHAMBER
 
     /**
      * The software PWM power for a heater
      */
-    static int16_t getHeaterPower(const heater_ind_t heater);
+    static int16_t getHeaterPower(const heater_id_t heater_id);
 
     /**
      * Switch off all heaters, set all target temperatures to 0
      */
     static void disable_all_heaters();
 
     #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
       /**
        * Methods to check if heaters are enabled, indicating an active job
        */
       static bool over_autostart_threshold();
       static void check_timer_autostart(const bool can_start, const bool can_stop);
     #endif
 
     /**
      * Perform auto-tuning for hotend or bed in response to M303
      */
     #if HAS_PID_HEATING
-      static void PID_autotune(const float &target, const heater_ind_t hotend, const int8_t ncycles, const bool set_result=false);
+      static void PID_autotune(const float &target, const heater_id_t heater_id, const int8_t ncycles, const bool set_result=false);
 
       #if ENABLED(NO_FAN_SLOWING_IN_PID_TUNING)
         static bool adaptive_fan_slowing;
       #elif ENABLED(ADAPTIVE_FAN_SLOWING)
         static constexpr bool adaptive_fan_slowing = true;
       #endif
 
       /**
        * Update the temp manager when PID values change
        */
@@ -804,35 +804,35 @@ class Temperature {
     #endif
 
     static void checkExtruderAutoFans();
 
     static float get_pid_output_hotend(const uint8_t e);
 
     TERN_(PIDTEMPBED, static float get_pid_output_bed());
 
     TERN_(HAS_HEATED_CHAMBER, static float get_pid_output_chamber());
 
-    static void _temp_error(const heater_ind_t e, PGM_P const serial_msg, PGM_P const lcd_msg);
-    static void min_temp_error(const heater_ind_t e);
-    static void max_temp_error(const heater_ind_t e);
+    static void _temp_error(const heater_id_t e, PGM_P const serial_msg, PGM_P const lcd_msg);
+    static void min_temp_error(const heater_id_t e);
+    static void max_temp_error(const heater_id_t e);
 
     #define HAS_THERMAL_PROTECTION (EITHER(THERMAL_PROTECTION_HOTENDS, THERMAL_PROTECTION_CHAMBER) || HAS_THERMALLY_PROTECTED_BED)
 
     #if HAS_THERMAL_PROTECTION
 
       enum TRState : char { TRInactive, TRFirstHeating, TRStable, TRRunaway };
 
       typedef struct {
         millis_t timer = 0;
         TRState state = TRInactive;
       } tr_state_machine_t;
 
       TERN_(THERMAL_PROTECTION_HOTENDS, static tr_state_machine_t tr_state_machine[HOTENDS]);
       TERN_(HAS_THERMALLY_PROTECTED_BED, static tr_state_machine_t tr_state_machine_bed);
       TERN_(THERMAL_PROTECTION_CHAMBER, static tr_state_machine_t tr_state_machine_chamber);
 
-      static void thermal_runaway_protection(tr_state_machine_t &state, const float &current, const float &target, const heater_ind_t heater_id, const uint16_t period_seconds, const uint16_t hysteresis_degc);
+      static void thermal_runaway_protection(tr_state_machine_t &state, const float &current, const float &target, const heater_id_t heater_id, const uint16_t period_seconds, const uint16_t hysteresis_degc);
 
     #endif // HAS_THERMAL_PROTECTION
 };
 
 extern Temperature thermalManager;

commit 1917ed8741ed5c27c6a505c3936050e4f461d075
Author: Neskik <axel.gouverneur@gmail.com>
Date:   Sat Sep 12 05:51:19 2020 +0200

    M872 wait for probe temperature (#19344)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 4d3efceafd..2148f4cb68 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -647,20 +647,23 @@ class Temperature {
         return ABS(degBed() - temp) < (TEMP_BED_HYSTERESIS);
       }
 
     #endif // HAS_HEATED_BED
 
     #if HAS_TEMP_PROBE
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         FORCE_INLINE static int16_t rawProbeTemp()    { return temp_probe.raw; }
       #endif
       FORCE_INLINE static float degProbe()            { return temp_probe.celsius; }
+      FORCE_INLINE static bool isProbeBelowTemp(const float target_temp) { return temp_probe.celsius < target_temp; }
+      FORCE_INLINE static bool isProbeAboveTemp(const float target_temp) { return temp_probe.celsius > target_temp; }
+      static bool wait_for_probe(const float target_temp, bool no_wait_for_cooling=true);
     #endif
 
     #if WATCH_PROBE
       static void start_watching_probe();
     #else
       static inline void start_watching_probe() {}
     #endif
 
     #if HAS_TEMP_CHAMBER
       #if ENABLED(SHOW_TEMP_ADC_VALUES)

commit 828a582f4dfc719dbb519b89cccf621a5184d2a1
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Tue Sep 8 04:29:45 2020 +0200

    Make M600 heat up the nozzle. Reset runout on fail. (#19298)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 94eb42fd0f..4d3efceafd 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -323,21 +323,21 @@ class Temperature {
     TERN_(AUTO_POWER_CHAMBER_FAN, static uint8_t chamberfan_speed);
 
     #if ENABLED(FAN_SOFT_PWM)
       static uint8_t soft_pwm_amount_fan[FAN_COUNT],
                      soft_pwm_count_fan[FAN_COUNT];
     #endif
 
     #if ENABLED(PREVENT_COLD_EXTRUSION)
       static bool allow_cold_extrude;
       static int16_t extrude_min_temp;
-      FORCE_INLINE static bool tooCold(const int16_t temp) { return allow_cold_extrude ? false : temp < extrude_min_temp; }
+      FORCE_INLINE static bool tooCold(const int16_t temp) { return allow_cold_extrude ? false : temp < extrude_min_temp - (TEMP_WINDOW); }
       FORCE_INLINE static bool tooColdToExtrude(const uint8_t E_NAME) {
         return tooCold(degHotend(HOTEND_INDEX));
       }
       FORCE_INLINE static bool targetTooColdToExtrude(const uint8_t E_NAME) {
         return tooCold(degTargetHotend(HOTEND_INDEX));
       }
     #else
       FORCE_INLINE static bool tooColdToExtrude(const uint8_t) { return false; }
       FORCE_INLINE static bool targetTooColdToExtrude(const uint8_t) { return false; }
     #endif

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 37700c7b8b..94eb42fd0f 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -9,21 +9,21 @@
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 #pragma once
 
 /**
  * temperature.h - temperature controller
  */
 
 #include "thermistor/thermistors.h"
 

commit 76b67d55e2b55317c21c8d24d014887f2c2329eb
Author: Jason Smith <jason.inet@gmail.com>
Date:   Tue Jul 14 23:14:03 2020 -0700

    Fix some Power Loss Recovery behaviors (#18558)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index cfd9f957c1..37700c7b8b 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -569,21 +569,21 @@ class Temperature {
     #if HAS_HOTEND
 
       static void setTargetHotend(const int16_t celsius, const uint8_t E_NAME) {
         const uint8_t ee = HOTEND_INDEX;
         #ifdef MILLISECONDS_PREHEAT_TIME
           if (celsius == 0)
             reset_preheat_time(ee);
           else if (temp_hotend[ee].target == 0)
             start_preheat_time(ee);
         #endif
-        TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
+        TERN_(AUTO_POWER_CONTROL, if (celsius) powerManager.power_on());
         temp_hotend[ee].target = _MIN(celsius, temp_range[ee].maxtemp - HOTEND_OVERSHOOT);
         start_watching_hotend(ee);
       }
 
       FORCE_INLINE static bool isHeatingHotend(const uint8_t E_NAME) {
         return temp_hotend[HOTEND_INDEX].target > temp_hotend[HOTEND_INDEX].celsius;
       }
 
       FORCE_INLINE static bool isCoolingHotend(const uint8_t E_NAME) {
         return temp_hotend[HOTEND_INDEX].target < temp_hotend[HOTEND_INDEX].celsius;
@@ -617,21 +617,21 @@ class Temperature {
       FORCE_INLINE static bool isHeatingBed()     { return temp_bed.target > temp_bed.celsius; }
       FORCE_INLINE static bool isCoolingBed()     { return temp_bed.target < temp_bed.celsius; }
 
       #if WATCH_BED
         static void start_watching_bed();
       #else
         static inline void start_watching_bed() {}
       #endif
 
       static void setTargetBed(const int16_t celsius) {
-        TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
+        TERN_(AUTO_POWER_CONTROL, if (celsius) powerManager.power_on());
         temp_bed.target =
           #ifdef BED_MAX_TARGET
             _MIN(celsius, BED_MAX_TARGET)
           #else
             celsius
           #endif
         ;
         start_watching_bed();
       }
 

commit 2d33a9fd7c5485acbcf69c506470a67c870ef113
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jul 14 19:30:48 2020 -0500

    Add REPORT_FAN_CHANGE as an option

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 2f8ddbf7be..cfd9f957c1 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -467,40 +467,37 @@ class Temperature {
     #if HAS_TEMP_CHAMBER
       static float analog_to_celsius_chamber(const int raw);
     #endif
 
     #if HAS_FAN
 
       static uint8_t fan_speed[FAN_COUNT];
       #define FANS_LOOP(I) LOOP_L_N(I, FAN_COUNT)
 
       static void set_fan_speed(const uint8_t target, const uint16_t speed);
-      static void report_fan_speed(const uint8_t target);
+
+      #if ENABLED(REPORT_FAN_CHANGE)
+        static void report_fan_speed(const uint8_t target);
+      #endif
 
       #if EITHER(PROBING_FANS_OFF, ADVANCED_PAUSE_FANS_PAUSE)
         static bool fans_paused;
         static uint8_t saved_fan_speed[FAN_COUNT];
       #endif
 
       static constexpr inline uint8_t fanPercent(const uint8_t speed) { return ui8_to_percent(speed); }
 
       TERN_(ADAPTIVE_FAN_SLOWING, static uint8_t fan_speed_scaler[FAN_COUNT]);
 
       static inline uint8_t scaledFanSpeed(const uint8_t target, const uint8_t fs) {
         UNUSED(target); // Potentially unused!
-        return (fs * uint16_t(
-          #if ENABLED(ADAPTIVE_FAN_SLOWING)
-            fan_speed_scaler[target]
-          #else
-            128
-          #endif
-        )) >> 7;
+        return (fs * uint16_t(TERN(ADAPTIVE_FAN_SLOWING, fan_speed_scaler[target], 128))) >> 7;
       }
 
       static inline uint8_t scaledFanSpeed(const uint8_t target) {
         return scaledFanSpeed(target, fan_speed[target]);
       }
 
       #if ENABLED(EXTRA_FAN_SPEED)
         static uint8_t old_fan_speed[FAN_COUNT], new_fan_speed[FAN_COUNT];
         static void set_temp_fan_speed(const uint8_t fan, const uint16_t tmp_temp);
       #endif
@@ -622,21 +619,21 @@ class Temperature {
 
       #if WATCH_BED
         static void start_watching_bed();
       #else
         static inline void start_watching_bed() {}
       #endif
 
       static void setTargetBed(const int16_t celsius) {
         TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
         temp_bed.target =
-          #ifdef BED_MAXTEMP
+          #ifdef BED_MAX_TARGET
             _MIN(celsius, BED_MAX_TARGET)
           #else
             celsius
           #endif
         ;
         start_watching_bed();
       }
 
       static bool wait_for_bed(const bool no_wait_for_cooling=true
         #if G26_CLICK_CAN_CANCEL
@@ -783,25 +780,21 @@ class Temperature {
     #if HAS_LCD_MENU && HAS_TEMPERATURE
       static void lcd_preheat(const int16_t e, const int8_t indh, const int8_t indb);
     #endif
 
   private:
     static void update_raw_temperatures();
     static void updateTemperaturesFromRawValues();
 
     #define HAS_MAX6675 EITHER(HEATER_0_USES_MAX6675, HEATER_1_USES_MAX6675)
     #if HAS_MAX6675
-      #if BOTH(HEATER_0_USES_MAX6675, HEATER_1_USES_MAX6675)
-        #define COUNT_6675 2
-      #else
-        #define COUNT_6675 1
-      #endif
+      #define COUNT_6675 1 + BOTH(HEATER_0_USES_MAX6675, HEATER_1_USES_MAX6675)
       #if COUNT_6675 > 1
         #define READ_MAX6675(N) read_max6675(N)
       #else
         #define READ_MAX6675(N) read_max6675()
       #endif
       static int read_max6675(
         #if COUNT_6675 > 1
           const uint8_t hindex=0
         #endif
       );

commit c43bbcce152b4d3b4697e1e188d3bcada76a24a7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jul 1 16:27:28 2020 -0500

    Enforce sensor range for temperature target (#18465)
    
    * Mitigate stepper timeout
    
    * Add CHAMBER PWM code
    
    * Structured thermistor tables
    
    * Fix reversed sensor ranges
    
    * Prevent temps outside sensor range

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index d0d7858c7c..2f8ddbf7be 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -601,21 +601,21 @@ class Temperature {
       #endif
 
       FORCE_INLINE static bool still_heating(const uint8_t e) {
         return degTargetHotend(e) > TEMP_HYSTERESIS && ABS(degHotend(e) - degTargetHotend(e)) > TEMP_HYSTERESIS;
       }
 
       FORCE_INLINE static bool degHotendNear(const uint8_t e, const float &temp) {
         return ABS(degHotend(e) - temp) < (TEMP_HYSTERESIS);
       }
 
-    #endif // HOTENDS
+    #endif // HAS_HOTEND
 
     #if HAS_HEATED_BED
 
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         FORCE_INLINE static int16_t rawBedTemp()  { return temp_bed.raw; }
       #endif
       FORCE_INLINE static float degBed()          { return temp_bed.celsius; }
       FORCE_INLINE static int16_t degTargetBed()  { return temp_bed.target; }
       FORCE_INLINE static bool isHeatingBed()     { return temp_bed.target > temp_bed.celsius; }
       FORCE_INLINE static bool isCoolingBed()     { return temp_bed.target < temp_bed.celsius; }

commit 70fa4c9323543dfb65d10969838899575406cae6
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jul 1 16:18:20 2020 -0500

    Per-Hotend Default PIDs (#18483)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index a6d702646d..d0d7858c7c 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -30,27 +30,22 @@
 #include "../inc/MarlinConfig.h"
 
 #if ENABLED(AUTO_POWER_CONTROL)
   #include "../feature/power.h"
 #endif
 
 #ifndef SOFT_PWM_SCALE
   #define SOFT_PWM_SCALE 0
 #endif
 
-#if HOTENDS <= 1
-  #define HOTEND_INDEX  0
-  #define E_NAME
-#else
-  #define HOTEND_INDEX  e
-  #define E_NAME e
-#endif
+#define HOTEND_INDEX TERN(HAS_MULTI_HOTEND, e, 0)
+#define E_NAME TERN_(HAS_MULTI_HOTEND, e)
 
 // Identifiers for other heaters
 typedef enum : int8_t {
   INDEX_NONE = -5,
   H_PROBE, H_REDUNDANT, H_CHAMBER, H_BED,
   H_E0, H_E1, H_E2, H_E3, H_E4, H_E5, H_E6, H_E7
 } heater_ind_t;
 
 // PID storage
 typedef struct { float Kp, Ki, Kd;     } PID_t;
@@ -67,44 +62,32 @@ typedef
     PIDF_t
   #else
     PID_t
   #endif
 hotend_pid_t;
 
 #if ENABLED(PID_EXTRUSION_SCALING)
   typedef IF<(LPQ_MAX_LEN > 255), uint16_t, uint8_t>::type lpq_ptr_t;
 #endif
 
+#define PID_PARAM(F,H) _PID_##F(TERN(PID_PARAMS_PER_HOTEND, H, 0))
+#define _PID_Kp(H) TERN(PIDTEMP, Temperature::temp_hotend[H].pid.Kp, NAN)
+#define _PID_Ki(H) TERN(PIDTEMP, Temperature::temp_hotend[H].pid.Ki, NAN)
+#define _PID_Kd(H) TERN(PIDTEMP, Temperature::temp_hotend[H].pid.Kd, NAN)
 #if ENABLED(PIDTEMP)
-  #define _PID_Kp(H) Temperature::temp_hotend[H].pid.Kp
-  #define _PID_Ki(H) Temperature::temp_hotend[H].pid.Ki
-  #define _PID_Kd(H) Temperature::temp_hotend[H].pid.Kd
-  #if ENABLED(PID_EXTRUSION_SCALING)
-    #define _PID_Kc(H) Temperature::temp_hotend[H].pid.Kc
-  #else
-    #define _PID_Kc(H) 1
-  #endif
-
-  #if ENABLED(PID_FAN_SCALING)
-    #define _PID_Kf(H) Temperature::temp_hotend[H].pid.Kf
-  #else
-    #define _PID_Kf(H) 0
-  #endif
+  #define _PID_Kc(H) TERN(PID_EXTRUSION_SCALING, Temperature::temp_hotend[H].pid.Kc, 1)
+  #define _PID_Kf(H) TERN(PID_FAN_SCALING,       Temperature::temp_hotend[H].pid.Kf, 0)
 #else
-  #define _PID_Kp(H) NAN
-  #define _PID_Ki(H) NAN
-  #define _PID_Kd(H) NAN
   #define _PID_Kc(H) 1
+  #define _PID_Kf(H) 0
 #endif
 
-#define PID_PARAM(F,H) _PID_##F(H)
-
 /**
  * States for ADC reading in the ISR
  */
 enum ADCSensorState : char {
   StartSampling,
   #if HAS_TEMP_ADC_0
     PrepareTemp_0, MeasureTemp_0,
   #endif
   #if HAS_HEATED_BED
     PrepareTemp_BED, MeasureTemp_BED,

commit a907e15ae63b403358d831766d6773c76614702d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jun 26 18:53:39 2020 -0500

    Allow larger ADC debounce
    
    Reference #17205

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 0362e2e8e5..a6d702646d 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -418,21 +418,21 @@ class Temperature {
       static millis_t preheat_end_time[HOTENDS];
     #endif
 
     TERN_(HAS_AUTO_FAN, static millis_t next_auto_fan_check_ms);
 
     TERN_(PROBING_HEATERS_OFF, static bool paused);
 
   public:
     #if HAS_ADC_BUTTONS
       static uint32_t current_ADCKey_raw;
-      static uint8_t ADCKey_count;
+      static uint16_t ADCKey_count;
     #endif
 
     TERN_(PID_EXTRUSION_SCALING, static int16_t lpq_len);
 
     /**
      * Instance Methods
      */
 
     void init();
 

commit 43a994e0dfdba0e6fda7f2b5cf5db3d622e97435
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jun 24 20:14:58 2020 -0500

    Fix material preset editing

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index fca88608b5..0362e2e8e5 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -323,21 +323,21 @@ typedef struct { int16_t raw_min, raw_max, mintemp, maxtemp; } temp_range_t;
 
 #endif
 
 class Temperature {
 
   public:
 
     #if HAS_HOTEND
       #define HOTEND_TEMPS (HOTENDS + ENABLED(TEMP_SENSOR_1_AS_REDUNDANT))
       static hotend_info_t temp_hotend[HOTEND_TEMPS];
-      static const int16_t heater_maxtemp[HOTENDS];
+      static const uint16_t heater_maxtemp[HOTENDS];
     #endif
     TERN_(HAS_HEATED_BED, static bed_info_t temp_bed);
     TERN_(HAS_TEMP_PROBE, static probe_info_t temp_probe);
     TERN_(HAS_TEMP_CHAMBER, static chamber_info_t temp_chamber);
 
     TERN_(AUTO_POWER_E_FANS, static uint8_t autofan_speed[HOTENDS]);
     TERN_(AUTO_POWER_CHAMBER_FAN, static uint8_t chamberfan_speed);
 
     #if ENABLED(FAN_SOFT_PWM)
       static uint8_t soft_pwm_amount_fan[FAN_COUNT],

commit 4275466f4930ce554419f5f03f07119b8a9aec04
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jun 24 19:44:50 2020 -0500

    Fix issues with no hotend / bed / fan (#18395)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 0f95d0a726..fca88608b5 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -790,21 +790,21 @@ class Temperature {
         static inline void set_auto_report_interval(uint8_t v) {
           NOMORE(v, 60);
           auto_report_temp_interval = v;
           next_temp_report_ms = millis() + 1000UL * v;
         }
       #endif
     #endif
 
     TERN_(HAS_DISPLAY, static void set_heating_message(const uint8_t e));
 
-    #if HAS_LCD_MENU
+    #if HAS_LCD_MENU && HAS_TEMPERATURE
       static void lcd_preheat(const int16_t e, const int8_t indh, const int8_t indb);
     #endif
 
   private:
     static void update_raw_temperatures();
     static void updateTemperaturesFromRawValues();
 
     #define HAS_MAX6675 EITHER(HEATER_0_USES_MAX6675, HEATER_1_USES_MAX6675)
     #if HAS_MAX6675
       #if BOTH(HEATER_0_USES_MAX6675, HEATER_1_USES_MAX6675)

commit 424569b4c4bf112a3939724b30bad528a76a2b08
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jun 18 15:23:03 2020 -0500

    Power monitor and display (#17437)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 8f875f84f3..0f95d0a726 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -141,20 +141,28 @@ enum ADCSensorState : char {
   #endif
   #if HAS_JOY_ADC_Y
     PrepareJoy_Y, MeasureJoy_Y,
   #endif
   #if HAS_JOY_ADC_Z
     PrepareJoy_Z, MeasureJoy_Z,
   #endif
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     Prepare_FILWIDTH, Measure_FILWIDTH,
   #endif
+  #if ENABLED(POWER_MONITOR_CURRENT)
+    Prepare_POWER_MONITOR_CURRENT,
+    Measure_POWER_MONITOR_CURRENT,
+  #endif
+  #if ENABLED(POWER_MONITOR_VOLTAGE)
+    Prepare_POWER_MONITOR_VOLTAGE,
+    Measure_POWER_MONITOR_VOLTAGE,
+  #endif
   #if HAS_ADC_BUTTONS
     Prepare_ADC_KEY, Measure_ADC_KEY,
   #endif
   SensorsReady, // Temperatures ready. Delay the next round of readings to let ADC pins settle.
   StartupDelay  // Startup, delay initial temp reading a tiny bit so the hardware can settle
 };
 
 // Minimum number of Temperature::ISR loops between sensor readings.
 // Multiplied by 16 (OVERSAMPLENR) to obtain the total time to
 // get all oversampled sensor readings

commit f3bf343c89a1452af92fa7f57f3a4eb2761c77a8
Author: Gurmeet Athwal <gurmeet.athwal@gmail.com>
Date:   Tue May 26 04:16:35 2020 +0530

    Report fan speed on change (#18013)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index b2c5497b00..8f875f84f3 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -476,20 +476,21 @@ class Temperature {
     #if HAS_TEMP_CHAMBER
       static float analog_to_celsius_chamber(const int raw);
     #endif
 
     #if HAS_FAN
 
       static uint8_t fan_speed[FAN_COUNT];
       #define FANS_LOOP(I) LOOP_L_N(I, FAN_COUNT)
 
       static void set_fan_speed(const uint8_t target, const uint16_t speed);
+      static void report_fan_speed(const uint8_t target);
 
       #if EITHER(PROBING_FANS_OFF, ADVANCED_PAUSE_FANS_PAUSE)
         static bool fans_paused;
         static uint8_t saved_fan_speed[FAN_COUNT];
       #endif
 
       static constexpr inline uint8_t fanPercent(const uint8_t speed) { return ui8_to_percent(speed); }
 
       TERN_(ADAPTIVE_FAN_SLOWING, static uint8_t fan_speed_scaler[FAN_COUNT]);
 

commit 213d4b890ea4997db63b0946cde766581d7f96e5
Author: Italo Soares <italocjs@live.com>
Date:   Mon May 18 02:50:35 2020 -0300

    Hotend Idle Timeout (#16362)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 155644e7f8..b2c5497b00 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -605,20 +605,24 @@ class Temperature {
           #if G26_CLICK_CAN_CANCEL
             , const bool click_to_cancel=false
           #endif
         );
       #endif
 
       FORCE_INLINE static bool still_heating(const uint8_t e) {
         return degTargetHotend(e) > TEMP_HYSTERESIS && ABS(degHotend(e) - degTargetHotend(e)) > TEMP_HYSTERESIS;
       }
 
+      FORCE_INLINE static bool degHotendNear(const uint8_t e, const float &temp) {
+        return ABS(degHotend(e) - temp) < (TEMP_HYSTERESIS);
+      }
+
     #endif // HOTENDS
 
     #if HAS_HEATED_BED
 
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         FORCE_INLINE static int16_t rawBedTemp()  { return temp_bed.raw; }
       #endif
       FORCE_INLINE static float degBed()          { return temp_bed.celsius; }
       FORCE_INLINE static int16_t degTargetBed()  { return temp_bed.target; }
       FORCE_INLINE static bool isHeatingBed()     { return temp_bed.target > temp_bed.celsius; }
@@ -643,20 +647,24 @@ class Temperature {
       }
 
       static bool wait_for_bed(const bool no_wait_for_cooling=true
         #if G26_CLICK_CAN_CANCEL
           , const bool click_to_cancel=false
         #endif
       );
 
       static void wait_for_bed_heating();
 
+      FORCE_INLINE static bool degBedNear(const float &temp) {
+        return ABS(degBed() - temp) < (TEMP_BED_HYSTERESIS);
+      }
+
     #endif // HAS_HEATED_BED
 
     #if HAS_TEMP_PROBE
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         FORCE_INLINE static int16_t rawProbeTemp()    { return temp_probe.raw; }
       #endif
       FORCE_INLINE static float degProbe()            { return temp_probe.celsius; }
     #endif
 
     #if WATCH_PROBE

commit 37176ed2b9c3af5fbb2436d72a090b6d880f921e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 27 07:53:58 2020 -0500

    Apply maxtemp patch

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index f59d894254..155644e7f8 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -315,21 +315,21 @@ typedef struct { int16_t raw_min, raw_max, mintemp, maxtemp; } temp_range_t;
 
 #endif
 
 class Temperature {
 
   public:
 
     #if HAS_HOTEND
       #define HOTEND_TEMPS (HOTENDS + ENABLED(TEMP_SENSOR_1_AS_REDUNDANT))
       static hotend_info_t temp_hotend[HOTEND_TEMPS];
-      static constexpr int16_t heater_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP, HEATER_5_MAXTEMP, HEATER_6_MAXTEMP, HEATER_7_MAXTEMP);
+      static const int16_t heater_maxtemp[HOTENDS];
     #endif
     TERN_(HAS_HEATED_BED, static bed_info_t temp_bed);
     TERN_(HAS_TEMP_PROBE, static probe_info_t temp_probe);
     TERN_(HAS_TEMP_CHAMBER, static chamber_info_t temp_chamber);
 
     TERN_(AUTO_POWER_E_FANS, static uint8_t autofan_speed[HOTENDS]);
     TERN_(AUTO_POWER_CHAMBER_FAN, static uint8_t chamberfan_speed);
 
     #if ENABLED(FAN_SOFT_PWM)
       static uint8_t soft_pwm_amount_fan[FAN_COUNT],

commit 33217b0dd0e2117905813e3a45632fdc9c66d04f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 27 04:48:11 2020 -0500

    Add HOTEND_OVERSHOOT

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index b4cba62b10..f59d894254 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -581,21 +581,21 @@ class Temperature {
 
       static void setTargetHotend(const int16_t celsius, const uint8_t E_NAME) {
         const uint8_t ee = HOTEND_INDEX;
         #ifdef MILLISECONDS_PREHEAT_TIME
           if (celsius == 0)
             reset_preheat_time(ee);
           else if (temp_hotend[ee].target == 0)
             start_preheat_time(ee);
         #endif
         TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
-        temp_hotend[ee].target = _MIN(celsius, temp_range[ee].maxtemp - 15);
+        temp_hotend[ee].target = _MIN(celsius, temp_range[ee].maxtemp - HOTEND_OVERSHOOT);
         start_watching_hotend(ee);
       }
 
       FORCE_INLINE static bool isHeatingHotend(const uint8_t E_NAME) {
         return temp_hotend[HOTEND_INDEX].target > temp_hotend[HOTEND_INDEX].celsius;
       }
 
       FORCE_INLINE static bool isCoolingHotend(const uint8_t E_NAME) {
         return temp_hotend[HOTEND_INDEX].target < temp_hotend[HOTEND_INDEX].celsius;
       }

commit 8b3c7dda755ebce5bd57a7ce52891a137ea12b35
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 27 04:41:18 2020 -0500

    Add HAS_FAN and others

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index c08f4dc754..b4cba62b10 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -470,21 +470,21 @@ class Temperature {
     #if HAS_HEATED_BED
       static float analog_to_celsius_bed(const int raw);
     #endif
     #if HAS_TEMP_PROBE
       static float analog_to_celsius_probe(const int raw);
     #endif
     #if HAS_TEMP_CHAMBER
       static float analog_to_celsius_chamber(const int raw);
     #endif
 
-    #if FAN_COUNT > 0
+    #if HAS_FAN
 
       static uint8_t fan_speed[FAN_COUNT];
       #define FANS_LOOP(I) LOOP_L_N(I, FAN_COUNT)
 
       static void set_fan_speed(const uint8_t target, const uint16_t speed);
 
       #if EITHER(PROBING_FANS_OFF, ADVANCED_PAUSE_FANS_PAUSE)
         static bool fans_paused;
         static uint8_t saved_fan_speed[FAN_COUNT];
       #endif
@@ -510,24 +510,24 @@ class Temperature {
 
       #if ENABLED(EXTRA_FAN_SPEED)
         static uint8_t old_fan_speed[FAN_COUNT], new_fan_speed[FAN_COUNT];
         static void set_temp_fan_speed(const uint8_t fan, const uint16_t tmp_temp);
       #endif
 
       #if EITHER(PROBING_FANS_OFF, ADVANCED_PAUSE_FANS_PAUSE)
         void set_fans_paused(const bool p);
       #endif
 
-    #endif // FAN_COUNT > 0
+    #endif // HAS_FAN
 
     static inline void zero_fan_speeds() {
-      #if FAN_COUNT > 0
+      #if HAS_FAN
         FANS_LOOP(i) set_fan_speed(i, 0);
       #endif
     }
 
     /**
      * Called from the Temperature ISR
      */
     static void readings_ready();
     static void tick();
 
@@ -627,21 +627,21 @@ class Temperature {
       #if WATCH_BED
         static void start_watching_bed();
       #else
         static inline void start_watching_bed() {}
       #endif
 
       static void setTargetBed(const int16_t celsius) {
         TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
         temp_bed.target =
           #ifdef BED_MAXTEMP
-            _MIN(celsius, BED_MAXTEMP - 10)
+            _MIN(celsius, BED_MAX_TARGET)
           #else
             celsius
           #endif
         ;
         start_watching_bed();
       }
 
       static bool wait_for_bed(const bool no_wait_for_cooling=true
         #if G26_CLICK_CAN_CANCEL
           , const bool click_to_cancel=false

commit 3d45a4bd232c83450c269bb3f0fefa6fc67c788d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 27 04:35:20 2020 -0500

    Encapsulate Temperature items

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index f9f2fbc071..c08f4dc754 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -315,20 +315,21 @@ typedef struct { int16_t raw_min, raw_max, mintemp, maxtemp; } temp_range_t;
 
 #endif
 
 class Temperature {
 
   public:
 
     #if HAS_HOTEND
       #define HOTEND_TEMPS (HOTENDS + ENABLED(TEMP_SENSOR_1_AS_REDUNDANT))
       static hotend_info_t temp_hotend[HOTEND_TEMPS];
+      static constexpr int16_t heater_maxtemp[HOTENDS] = ARRAY_BY_HOTENDS(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP, HEATER_5_MAXTEMP, HEATER_6_MAXTEMP, HEATER_7_MAXTEMP);
     #endif
     TERN_(HAS_HEATED_BED, static bed_info_t temp_bed);
     TERN_(HAS_TEMP_PROBE, static probe_info_t temp_probe);
     TERN_(HAS_TEMP_CHAMBER, static chamber_info_t temp_chamber);
 
     TERN_(AUTO_POWER_E_FANS, static uint8_t autofan_speed[HOTENDS]);
     TERN_(AUTO_POWER_CHAMBER_FAN, static uint8_t chamberfan_speed);
 
     #if ENABLED(FAN_SOFT_PWM)
       static uint8_t soft_pwm_amount_fan[FAN_COUNT],
@@ -772,20 +773,24 @@ class Temperature {
         static inline void set_auto_report_interval(uint8_t v) {
           NOMORE(v, 60);
           auto_report_temp_interval = v;
           next_temp_report_ms = millis() + 1000UL * v;
         }
       #endif
     #endif
 
     TERN_(HAS_DISPLAY, static void set_heating_message(const uint8_t e));
 
+    #if HAS_LCD_MENU
+      static void lcd_preheat(const int16_t e, const int8_t indh, const int8_t indb);
+    #endif
+
   private:
     static void update_raw_temperatures();
     static void updateTemperaturesFromRawValues();
 
     #define HAS_MAX6675 EITHER(HEATER_0_USES_MAX6675, HEATER_1_USES_MAX6675)
     #if HAS_MAX6675
       #if BOTH(HEATER_0_USES_MAX6675, HEATER_1_USES_MAX6675)
         #define COUNT_6675 2
       #else
         #define COUNT_6675 1

commit 6d90d1e1f552dca5e21bc61b676b8e8ce731b280
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 22 16:35:03 2020 -0500

    Apply TERN to compact code (#17619)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 981615c1b4..f9f2fbc071 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -166,21 +166,23 @@ enum ADCSensorState : char {
   #define PID_K2 (1-float(PID_K1))
   #define PID_dT ((OVERSAMPLENR * float(ACTUAL_ADC_SAMPLES)) / TEMP_TIMER_FREQUENCY)
 
   // Apply the scale factors to the PID values
   #define scalePID_i(i)   ( float(i) * PID_dT )
   #define unscalePID_i(i) ( float(i) / PID_dT )
   #define scalePID_d(d)   ( float(d) / PID_dT )
   #define unscalePID_d(d) ( float(d) * PID_dT )
 #endif
 
-#define G26_CLICK_CAN_CANCEL (HAS_LCD_MENU && ENABLED(G26_MESH_VALIDATION))
+#if BOTH(HAS_LCD_MENU, G26_MESH_VALIDATION)
+  #define G26_CLICK_CAN_CANCEL 1
+#endif
 
 // A temperature sensor
 typedef struct TempInfo {
   uint16_t acc;
   int16_t raw;
   float celsius;
   inline void reset() { acc = 0; }
   inline void sample(const uint16_t s) { acc += s; }
   inline void update() { raw = acc; }
 } temp_info_t;
@@ -310,44 +312,30 @@ typedef struct { int16_t raw_min, raw_max, mintemp, maxtemp; } temp_range_t;
           res_25_log,
           beta, beta_recip;
   } user_thermistor_t;
 
 #endif
 
 class Temperature {
 
   public:
 
-      #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
-        #define HOTEND_TEMPS (HOTENDS + 1)
-      #else
-        #define HOTEND_TEMPS HOTENDS
-      #endif
     #if HAS_HOTEND
+      #define HOTEND_TEMPS (HOTENDS + ENABLED(TEMP_SENSOR_1_AS_REDUNDANT))
       static hotend_info_t temp_hotend[HOTEND_TEMPS];
     #endif
-    #if HAS_HEATED_BED
-      static bed_info_t temp_bed;
-    #endif
-    #if HAS_TEMP_PROBE
-      static probe_info_t temp_probe;
-    #endif
-    #if HAS_TEMP_CHAMBER
-      static chamber_info_t temp_chamber;
-    #endif
+    TERN_(HAS_HEATED_BED, static bed_info_t temp_bed);
+    TERN_(HAS_TEMP_PROBE, static probe_info_t temp_probe);
+    TERN_(HAS_TEMP_CHAMBER, static chamber_info_t temp_chamber);
 
-    #if ENABLED(AUTO_POWER_E_FANS)
-      static uint8_t autofan_speed[HOTENDS];
-    #endif
-    #if ENABLED(AUTO_POWER_CHAMBER_FAN)
-      static uint8_t chamberfan_speed;
-    #endif
+    TERN_(AUTO_POWER_E_FANS, static uint8_t autofan_speed[HOTENDS]);
+    TERN_(AUTO_POWER_CHAMBER_FAN, static uint8_t chamberfan_speed);
 
     #if ENABLED(FAN_SOFT_PWM)
       static uint8_t soft_pwm_amount_fan[FAN_COUNT],
                      soft_pwm_count_fan[FAN_COUNT];
     #endif
 
     #if ENABLED(PREVENT_COLD_EXTRUSION)
       static bool allow_cold_extrude;
       static int16_t extrude_min_temp;
       FORCE_INLINE static bool tooCold(const int16_t temp) { return allow_cold_extrude ? false : temp < extrude_min_temp; }
@@ -360,107 +348,85 @@ class Temperature {
     #else
       FORCE_INLINE static bool tooColdToExtrude(const uint8_t) { return false; }
       FORCE_INLINE static bool targetTooColdToExtrude(const uint8_t) { return false; }
     #endif
 
     FORCE_INLINE static bool hotEnoughToExtrude(const uint8_t e) { return !tooColdToExtrude(e); }
     FORCE_INLINE static bool targetHotEnoughToExtrude(const uint8_t e) { return !targetTooColdToExtrude(e); }
 
     #if HEATER_IDLE_HANDLER
       static hotend_idle_t hotend_idle[HOTENDS];
-      #if HAS_HEATED_BED
-        static hotend_idle_t bed_idle;
-      #endif
-      #if HAS_HEATED_CHAMBER
-        static hotend_idle_t chamber_idle;
-      #endif
+      TERN_(HAS_HEATED_BED, static hotend_idle_t bed_idle);
+      TERN_(HAS_HEATED_CHAMBER, static hotend_idle_t chamber_idle);
     #endif
 
   private:
 
-    #if EARLY_WATCHDOG
-      static bool inited;   // If temperature controller is running
-    #endif
+    TERN_(EARLY_WATCHDOG, static bool inited);   // If temperature controller is running
 
     static volatile bool raw_temps_ready;
 
-    #if WATCH_HOTENDS
-      static hotend_watch_t watch_hotend[HOTENDS];
-    #endif
+    TERN_(WATCH_HOTENDS, static hotend_watch_t watch_hotend[HOTENDS]);
 
     #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
       static uint16_t redundant_temperature_raw;
       static float redundant_temperature;
     #endif
 
     #if ENABLED(PID_EXTRUSION_SCALING)
       static int32_t last_e_position, lpq[LPQ_MAX_LEN];
       static lpq_ptr_t lpq_ptr;
     #endif
 
-    #if HOTENDS
-      static temp_range_t temp_range[HOTENDS];
-    #endif
+    TERN_(HAS_HOTEND, static temp_range_t temp_range[HOTENDS]);
 
     #if HAS_HEATED_BED
-      #if WATCH_BED
-        static bed_watch_t watch_bed;
-      #endif
-      #if DISABLED(PIDTEMPBED)
-        static millis_t next_bed_check_ms;
-      #endif
+      TERN_(WATCH_BED, static bed_watch_t watch_bed);
+      TERN(PIDTEMPBED,,static millis_t next_bed_check_ms);
       #ifdef BED_MINTEMP
         static int16_t mintemp_raw_BED;
       #endif
       #ifdef BED_MAXTEMP
         static int16_t maxtemp_raw_BED;
       #endif
     #endif
 
     #if HAS_HEATED_CHAMBER
-      #if WATCH_CHAMBER
-        static chamber_watch_t watch_chamber;
-      #endif
+      TERN_(WATCH_CHAMBER, static chamber_watch_t watch_chamber);
       static millis_t next_chamber_check_ms;
       #ifdef CHAMBER_MINTEMP
         static int16_t mintemp_raw_CHAMBER;
       #endif
       #ifdef CHAMBER_MAXTEMP
         static int16_t maxtemp_raw_CHAMBER;
       #endif
     #endif
 
     #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
       static uint8_t consecutive_low_temperature_error[HOTENDS];
     #endif
 
     #ifdef MILLISECONDS_PREHEAT_TIME
       static millis_t preheat_end_time[HOTENDS];
     #endif
 
-    #if HAS_AUTO_FAN
-      static millis_t next_auto_fan_check_ms;
-    #endif
+    TERN_(HAS_AUTO_FAN, static millis_t next_auto_fan_check_ms);
 
-    #if ENABLED(PROBING_HEATERS_OFF)
-      static bool paused;
-    #endif
+    TERN_(PROBING_HEATERS_OFF, static bool paused);
 
   public:
     #if HAS_ADC_BUTTONS
       static uint32_t current_ADCKey_raw;
       static uint8_t ADCKey_count;
     #endif
 
-    #if ENABLED(PID_EXTRUSION_SCALING)
-      static int16_t lpq_len;
-    #endif
+    TERN_(PID_EXTRUSION_SCALING, static int16_t lpq_len);
 
     /**
      * Instance Methods
      */
 
     void init();
 
     /**
      * Static (class) methods
      */
@@ -517,23 +483,21 @@ class Temperature {
 
       static void set_fan_speed(const uint8_t target, const uint16_t speed);
 
       #if EITHER(PROBING_FANS_OFF, ADVANCED_PAUSE_FANS_PAUSE)
         static bool fans_paused;
         static uint8_t saved_fan_speed[FAN_COUNT];
       #endif
 
       static constexpr inline uint8_t fanPercent(const uint8_t speed) { return ui8_to_percent(speed); }
 
-      #if ENABLED(ADAPTIVE_FAN_SLOWING)
-        static uint8_t fan_speed_scaler[FAN_COUNT];
-      #endif
+      TERN_(ADAPTIVE_FAN_SLOWING, static uint8_t fan_speed_scaler[FAN_COUNT]);
 
       static inline uint8_t scaledFanSpeed(const uint8_t target, const uint8_t fs) {
         UNUSED(target); // Potentially unused!
         return (fs * uint16_t(
           #if ENABLED(ADAPTIVE_FAN_SLOWING)
             fan_speed_scaler[target]
           #else
             128
           #endif
         )) >> 7;
@@ -586,64 +550,50 @@ class Temperature {
       }
     #else
       #define is_preheating(n) (false)
     #endif
 
     //high level conversion routines, for use outside of temperature.cpp
     //inline so that there is no performance decrease.
     //deg=degreeCelsius
 
     FORCE_INLINE static float degHotend(const uint8_t E_NAME) {
-      return (0
-        #if HOTENDS
-          + temp_hotend[HOTEND_INDEX].celsius
-        #endif
-      );
+      return TERN0(HAS_HOTEND, temp_hotend[HOTEND_INDEX].celsius);
     }
 
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       FORCE_INLINE static int16_t rawHotendTemp(const uint8_t E_NAME) {
-        return (0
-          #if HOTENDS
-            + temp_hotend[HOTEND_INDEX].raw
-          #endif
-        );
+        return TERN0(HAS_HOTEND, temp_hotend[HOTEND_INDEX].raw);
       }
     #endif
 
     FORCE_INLINE static int16_t degTargetHotend(const uint8_t E_NAME) {
-      return (0
-        #if HOTENDS
-          + temp_hotend[HOTEND_INDEX].target
-        #endif
-      );
+      return TERN0(HAS_HOTEND, temp_hotend[HOTEND_INDEX].target);
     }
 
     #if WATCH_HOTENDS
       static void start_watching_hotend(const uint8_t e=0);
     #else
       static inline void start_watching_hotend(const uint8_t=0) {}
     #endif
 
     #if HAS_HOTEND
 
       static void setTargetHotend(const int16_t celsius, const uint8_t E_NAME) {
         const uint8_t ee = HOTEND_INDEX;
         #ifdef MILLISECONDS_PREHEAT_TIME
           if (celsius == 0)
             reset_preheat_time(ee);
           else if (temp_hotend[ee].target == 0)
             start_preheat_time(ee);
         #endif
-        #if ENABLED(AUTO_POWER_CONTROL)
-          powerManager.power_on();
-        #endif
+        TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
         temp_hotend[ee].target = _MIN(celsius, temp_range[ee].maxtemp - 15);
         start_watching_hotend(ee);
       }
 
       FORCE_INLINE static bool isHeatingHotend(const uint8_t E_NAME) {
         return temp_hotend[HOTEND_INDEX].target > temp_hotend[HOTEND_INDEX].celsius;
       }
 
       FORCE_INLINE static bool isCoolingHotend(const uint8_t E_NAME) {
         return temp_hotend[HOTEND_INDEX].target < temp_hotend[HOTEND_INDEX].celsius;
@@ -673,23 +623,21 @@ class Temperature {
       FORCE_INLINE static bool isHeatingBed()     { return temp_bed.target > temp_bed.celsius; }
       FORCE_INLINE static bool isCoolingBed()     { return temp_bed.target < temp_bed.celsius; }
 
       #if WATCH_BED
         static void start_watching_bed();
       #else
         static inline void start_watching_bed() {}
       #endif
 
       static void setTargetBed(const int16_t celsius) {
-        #if ENABLED(AUTO_POWER_CONTROL)
-          powerManager.power_on();
-        #endif
+        TERN_(AUTO_POWER_CONTROL, powerManager.power_on());
         temp_bed.target =
           #ifdef BED_MAXTEMP
             _MIN(celsius, BED_MAXTEMP - 10)
           #else
             celsius
           #endif
         ;
         start_watching_bed();
       }
 
@@ -777,23 +725,21 @@ class Temperature {
         static bool adaptive_fan_slowing;
       #elif ENABLED(ADAPTIVE_FAN_SLOWING)
         static constexpr bool adaptive_fan_slowing = true;
       #endif
 
       /**
        * Update the temp manager when PID values change
        */
       #if ENABLED(PIDTEMP)
         FORCE_INLINE static void updatePID() {
-          #if ENABLED(PID_EXTRUSION_SCALING)
-            last_e_position = 0;
-          #endif
+          TERN_(PID_EXTRUSION_SCALING, last_e_position = 0);
         }
       #endif
 
     #endif
 
     #if ENABLED(PROBING_HEATERS_OFF)
       static void pause(const bool p);
       FORCE_INLINE static bool is_paused() { return paused; }
     #endif
 
@@ -824,23 +770,21 @@ class Temperature {
         static millis_t next_temp_report_ms;
         static void auto_report_temperatures();
         static inline void set_auto_report_interval(uint8_t v) {
           NOMORE(v, 60);
           auto_report_temp_interval = v;
           next_temp_report_ms = millis() + 1000UL * v;
         }
       #endif
     #endif
 
-    #if HAS_DISPLAY
-      static void set_heating_message(const uint8_t e);
-    #endif
+    TERN_(HAS_DISPLAY, static void set_heating_message(const uint8_t e));
 
   private:
     static void update_raw_temperatures();
     static void updateTemperaturesFromRawValues();
 
     #define HAS_MAX6675 EITHER(HEATER_0_USES_MAX6675, HEATER_1_USES_MAX6675)
     #if HAS_MAX6675
       #if BOTH(HEATER_0_USES_MAX6675, HEATER_1_USES_MAX6675)
         #define COUNT_6675 2
       #else
@@ -855,49 +799,39 @@ class Temperature {
         #if COUNT_6675 > 1
           const uint8_t hindex=0
         #endif
       );
     #endif
 
     static void checkExtruderAutoFans();
 
     static float get_pid_output_hotend(const uint8_t e);
 
-    #if ENABLED(PIDTEMPBED)
-      static float get_pid_output_bed();
-    #endif
+    TERN_(PIDTEMPBED, static float get_pid_output_bed());
 
-    #if HAS_HEATED_CHAMBER
-      static float get_pid_output_chamber();
-    #endif
+    TERN_(HAS_HEATED_CHAMBER, static float get_pid_output_chamber());
 
     static void _temp_error(const heater_ind_t e, PGM_P const serial_msg, PGM_P const lcd_msg);
     static void min_temp_error(const heater_ind_t e);
     static void max_temp_error(const heater_ind_t e);
 
     #define HAS_THERMAL_PROTECTION (EITHER(THERMAL_PROTECTION_HOTENDS, THERMAL_PROTECTION_CHAMBER) || HAS_THERMALLY_PROTECTED_BED)
 
     #if HAS_THERMAL_PROTECTION
 
       enum TRState : char { TRInactive, TRFirstHeating, TRStable, TRRunaway };
 
       typedef struct {
         millis_t timer = 0;
         TRState state = TRInactive;
       } tr_state_machine_t;
 
-      #if ENABLED(THERMAL_PROTECTION_HOTENDS)
-        static tr_state_machine_t tr_state_machine[HOTENDS];
-      #endif
-      #if HAS_THERMALLY_PROTECTED_BED
-        static tr_state_machine_t tr_state_machine_bed;
-      #endif
-      #if ENABLED(THERMAL_PROTECTION_CHAMBER)
-        static tr_state_machine_t tr_state_machine_chamber;
-      #endif
+      TERN_(THERMAL_PROTECTION_HOTENDS, static tr_state_machine_t tr_state_machine[HOTENDS]);
+      TERN_(HAS_THERMALLY_PROTECTED_BED, static tr_state_machine_t tr_state_machine_bed);
+      TERN_(THERMAL_PROTECTION_CHAMBER, static tr_state_machine_t tr_state_machine_chamber);
 
       static void thermal_runaway_protection(tr_state_machine_t &state, const float &current, const float &target, const heater_ind_t heater_id, const uint16_t period_seconds, const uint16_t hysteresis_degc);
 
     #endif // HAS_THERMAL_PROTECTION
 };
 
 extern Temperature thermalManager;

commit 15f6f53638a6778d22a17e1900fb3a9fdc92dade
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Apr 19 23:56:55 2020 -0500

    Add HAS_HOTEND, etc.

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index cba1642afd..981615c1b4 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -310,26 +310,26 @@ typedef struct { int16_t raw_min, raw_max, mintemp, maxtemp; } temp_range_t;
           res_25_log,
           beta, beta_recip;
   } user_thermistor_t;
 
 #endif
 
 class Temperature {
 
   public:
 
-    #if HOTENDS
       #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
         #define HOTEND_TEMPS (HOTENDS + 1)
       #else
         #define HOTEND_TEMPS HOTENDS
       #endif
+    #if HAS_HOTEND
       static hotend_info_t temp_hotend[HOTEND_TEMPS];
     #endif
     #if HAS_HEATED_BED
       static bed_info_t temp_bed;
     #endif
     #if HAS_TEMP_PROBE
       static probe_info_t temp_probe;
     #endif
     #if HAS_TEMP_CHAMBER
       static chamber_info_t temp_chamber;
@@ -489,21 +489,21 @@ class Temperature {
         return true;
       }
       static bool set_sh_coeff(int8_t t_index, float value) {
         if (!WITHIN(value, -0.01f, 0.01f)) return false;
         user_thermistor[t_index].sh_c_coeff = value;
         user_thermistor[t_index].pre_calc = true;
         return true;
       }
     #endif
 
-    #if HOTENDS
+    #if HAS_HOTEND
       static float analog_to_celsius_hotend(const int raw, const uint8_t e);
     #endif
 
     #if HAS_HEATED_BED
       static float analog_to_celsius_bed(const int raw);
     #endif
     #if HAS_TEMP_PROBE
       static float analog_to_celsius_probe(const int raw);
     #endif
     #if HAS_TEMP_CHAMBER
@@ -617,21 +617,21 @@ class Temperature {
         #endif
       );
     }
 
     #if WATCH_HOTENDS
       static void start_watching_hotend(const uint8_t e=0);
     #else
       static inline void start_watching_hotend(const uint8_t=0) {}
     #endif
 
-    #if HOTENDS
+    #if HAS_HOTEND
 
       static void setTargetHotend(const int16_t celsius, const uint8_t E_NAME) {
         const uint8_t ee = HOTEND_INDEX;
         #ifdef MILLISECONDS_PREHEAT_TIME
           if (celsius == 0)
             reset_preheat_time(ee);
           else if (temp_hotend[ee].target == 0)
             start_preheat_time(ee);
         #endif
         #if ENABLED(AUTO_POWER_CONTROL)

commit 0e06aaa2bc5c58e018fcdd466ae8836ac0c38e13
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Apr 3 19:49:45 2020 -0500

    Add millis helper macros

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 24e0054496..cba1642afd 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -234,21 +234,21 @@ struct HeaterWatch {
   uint16_t target;
   millis_t next_ms;
   inline bool elapsed(const millis_t &ms) { return next_ms && ELAPSED(ms, next_ms); }
   inline bool elapsed() { return elapsed(millis()); }
 
   inline void restart(const int16_t curr, const int16_t tgt) {
     if (tgt) {
       const int16_t newtarget = curr + INCREASE;
       if (newtarget < tgt - HYSTERESIS - 1) {
         target = newtarget;
-        next_ms = millis() + PERIOD * 1000UL;
+        next_ms = millis() + SEC_TO_MS(PERIOD);
         return;
       }
     }
     next_ms = 0;
   }
 };
 
 #if WATCH_HOTENDS
   typedef struct HeaterWatch<WATCH_TEMP_INCREASE, TEMP_HYSTERESIS, WATCH_TEMP_PERIOD> hotend_watch_t;
 #endif

commit 913de024a991b41038858cf65b88165fcfb43f2b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Mar 6 13:55:00 2020 -0600

    Change PID dummy value to NAN
    
    Fixes #17078

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 655de8d6f3..24e0054496 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -67,41 +67,39 @@ typedef
     PIDF_t
   #else
     PID_t
   #endif
 hotend_pid_t;
 
 #if ENABLED(PID_EXTRUSION_SCALING)
   typedef IF<(LPQ_MAX_LEN > 255), uint16_t, uint8_t>::type lpq_ptr_t;
 #endif
 
-#define DUMMY_PID_VALUE 3000.0f
-
 #if ENABLED(PIDTEMP)
   #define _PID_Kp(H) Temperature::temp_hotend[H].pid.Kp
   #define _PID_Ki(H) Temperature::temp_hotend[H].pid.Ki
   #define _PID_Kd(H) Temperature::temp_hotend[H].pid.Kd
   #if ENABLED(PID_EXTRUSION_SCALING)
     #define _PID_Kc(H) Temperature::temp_hotend[H].pid.Kc
   #else
     #define _PID_Kc(H) 1
   #endif
 
   #if ENABLED(PID_FAN_SCALING)
     #define _PID_Kf(H) Temperature::temp_hotend[H].pid.Kf
   #else
     #define _PID_Kf(H) 0
   #endif
 #else
-  #define _PID_Kp(H) DUMMY_PID_VALUE
-  #define _PID_Ki(H) DUMMY_PID_VALUE
-  #define _PID_Kd(H) DUMMY_PID_VALUE
+  #define _PID_Kp(H) NAN
+  #define _PID_Ki(H) NAN
+  #define _PID_Kd(H) NAN
   #define _PID_Kc(H) 1
 #endif
 
 #define PID_PARAM(F,H) _PID_##F(H)
 
 /**
  * States for ADC reading in the ISR
  */
 enum ADCSensorState : char {
   StartSampling,

commit 7709261ea9f73d60006b5ab1ae488086908d0e79
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 4 12:50:43 2020 -0600

    Move shared code to wait_for_bed_heating

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 66d6bd56e1..655de8d6f3 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -694,20 +694,22 @@ class Temperature {
         ;
         start_watching_bed();
       }
 
       static bool wait_for_bed(const bool no_wait_for_cooling=true
         #if G26_CLICK_CAN_CANCEL
           , const bool click_to_cancel=false
         #endif
       );
 
+      static void wait_for_bed_heating();
+
     #endif // HAS_HEATED_BED
 
     #if HAS_TEMP_PROBE
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         FORCE_INLINE static int16_t rawProbeTemp()    { return temp_probe.raw; }
       #endif
       FORCE_INLINE static float degProbe()            { return temp_probe.celsius; }
     #endif
 
     #if WATCH_PROBE

commit bfad23d3e2e590b257ebe4317d7b14cc2dd3435c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 3 08:00:57 2020 -0600

    (c) 2020

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index a360394f24..66d6bd56e1 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit 9caf5c05e7e408c7192e689e4ed5fe2735bb2995
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jan 30 03:24:43 2020 -0600

    Refactor heater watch, job timer auto-start (#16725)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index da73ed37a4..a360394f24 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -221,29 +221,52 @@ struct PIDHeaterInfo : public HeaterInfo {
 #endif
 
 // Heater idle handling
 typedef struct {
   millis_t timeout_ms;
   bool timed_out;
   inline void update(const millis_t &ms) { if (!timed_out && timeout_ms && ELAPSED(ms, timeout_ms)) timed_out = true; }
   inline void start(const millis_t &ms) { timeout_ms = millis() + ms; timed_out = false; }
   inline void reset() { timeout_ms = 0; timed_out = false; }
   inline void expire() { start(0); }
-} heater_idle_t;
+} hotend_idle_t;
 
 // Heater watch handling
-typedef struct {
+template <int INCREASE, int HYSTERESIS, millis_t PERIOD>
+struct HeaterWatch {
   uint16_t target;
   millis_t next_ms;
   inline bool elapsed(const millis_t &ms) { return next_ms && ELAPSED(ms, next_ms); }
   inline bool elapsed() { return elapsed(millis()); }
-} heater_watch_t;
+
+  inline void restart(const int16_t curr, const int16_t tgt) {
+    if (tgt) {
+      const int16_t newtarget = curr + INCREASE;
+      if (newtarget < tgt - HYSTERESIS - 1) {
+        target = newtarget;
+        next_ms = millis() + PERIOD * 1000UL;
+        return;
+      }
+    }
+    next_ms = 0;
+  }
+};
+
+#if WATCH_HOTENDS
+  typedef struct HeaterWatch<WATCH_TEMP_INCREASE, TEMP_HYSTERESIS, WATCH_TEMP_PERIOD> hotend_watch_t;
+#endif
+#if WATCH_BED
+  typedef struct HeaterWatch<WATCH_BED_TEMP_INCREASE, TEMP_BED_HYSTERESIS, WATCH_BED_TEMP_PERIOD> bed_watch_t;
+#endif
+#if WATCH_CHAMBER
+  typedef struct HeaterWatch<WATCH_CHAMBER_TEMP_INCREASE, TEMP_CHAMBER_HYSTERESIS, WATCH_CHAMBER_TEMP_PERIOD> chamber_watch_t;
+#endif
 
 // Temperature sensor read value ranges
 typedef struct { int16_t raw_min, raw_max; } raw_range_t;
 typedef struct { int16_t mintemp, maxtemp; } celsius_range_t;
 typedef struct { int16_t raw_min, raw_max, mintemp, maxtemp; } temp_range_t;
 
 #define THERMISTOR_ABS_ZERO_C           -273.15f  // bbbbrrrrr cold !
 #define THERMISTOR_RESISTANCE_NOMINAL_C 25.0f     // mmmmm comfortable
 
 #if HAS_USER_THERMISTORS
@@ -338,73 +361,73 @@ class Temperature {
       }
     #else
       FORCE_INLINE static bool tooColdToExtrude(const uint8_t) { return false; }
       FORCE_INLINE static bool targetTooColdToExtrude(const uint8_t) { return false; }
     #endif
 
     FORCE_INLINE static bool hotEnoughToExtrude(const uint8_t e) { return !tooColdToExtrude(e); }
     FORCE_INLINE static bool targetHotEnoughToExtrude(const uint8_t e) { return !targetTooColdToExtrude(e); }
 
     #if HEATER_IDLE_HANDLER
-      static heater_idle_t hotend_idle[HOTENDS];
+      static hotend_idle_t hotend_idle[HOTENDS];
       #if HAS_HEATED_BED
-        static heater_idle_t bed_idle;
+        static hotend_idle_t bed_idle;
       #endif
       #if HAS_HEATED_CHAMBER
-        static heater_idle_t chamber_idle;
+        static hotend_idle_t chamber_idle;
       #endif
     #endif
 
   private:
 
     #if EARLY_WATCHDOG
       static bool inited;   // If temperature controller is running
     #endif
 
     static volatile bool raw_temps_ready;
 
     #if WATCH_HOTENDS
-      static heater_watch_t watch_hotend[HOTENDS];
+      static hotend_watch_t watch_hotend[HOTENDS];
     #endif
 
     #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
       static uint16_t redundant_temperature_raw;
       static float redundant_temperature;
     #endif
 
     #if ENABLED(PID_EXTRUSION_SCALING)
       static int32_t last_e_position, lpq[LPQ_MAX_LEN];
       static lpq_ptr_t lpq_ptr;
     #endif
 
     #if HOTENDS
       static temp_range_t temp_range[HOTENDS];
     #endif
 
     #if HAS_HEATED_BED
       #if WATCH_BED
-        static heater_watch_t watch_bed;
+        static bed_watch_t watch_bed;
       #endif
       #if DISABLED(PIDTEMPBED)
         static millis_t next_bed_check_ms;
       #endif
       #ifdef BED_MINTEMP
         static int16_t mintemp_raw_BED;
       #endif
       #ifdef BED_MAXTEMP
         static int16_t maxtemp_raw_BED;
       #endif
     #endif
 
     #if HAS_HEATED_CHAMBER
       #if WATCH_CHAMBER
-        static heater_watch_t watch_chamber;
+        static chamber_watch_t watch_chamber;
       #endif
       static millis_t next_chamber_check_ms;
       #ifdef CHAMBER_MINTEMP
         static int16_t mintemp_raw_CHAMBER;
       #endif
       #ifdef CHAMBER_MAXTEMP
         static int16_t maxtemp_raw_CHAMBER;
       #endif
     #endif
 
@@ -729,20 +752,28 @@ class Temperature {
     /**
      * The software PWM power for a heater
      */
     static int16_t getHeaterPower(const heater_ind_t heater);
 
     /**
      * Switch off all heaters, set all target temperatures to 0
      */
     static void disable_all_heaters();
 
+    #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
+      /**
+       * Methods to check if heaters are enabled, indicating an active job
+       */
+      static bool over_autostart_threshold();
+      static void check_timer_autostart(const bool can_start, const bool can_stop);
+    #endif
+
     /**
      * Perform auto-tuning for hotend or bed in response to M303
      */
     #if HAS_PID_HEATING
       static void PID_autotune(const float &target, const heater_ind_t hotend, const int8_t ncycles, const bool set_result=false);
 
       #if ENABLED(NO_FAN_SLOWING_IN_PID_TUNING)
         static bool adaptive_fan_slowing;
       #elif ENABLED(ADAPTIVE_FAN_SLOWING)
         static constexpr bool adaptive_fan_slowing = true;
@@ -761,21 +792,21 @@ class Temperature {
 
     #endif
 
     #if ENABLED(PROBING_HEATERS_OFF)
       static void pause(const bool p);
       FORCE_INLINE static bool is_paused() { return paused; }
     #endif
 
     #if HEATER_IDLE_HANDLER
 
-      static void reset_heater_idle_timer(const uint8_t E_NAME) {
+      static void reset_hotend_idle_timer(const uint8_t E_NAME) {
         hotend_idle[HOTEND_INDEX].reset();
         start_watching_hotend(HOTEND_INDEX);
       }
 
       #if HAS_HEATED_BED
         static void reset_bed_idle_timer() {
           bed_idle.reset();
           start_watching_bed();
         }
       #endif

commit 56cd747c8be868b21619001aeebbecd3827a7e93
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Jan 26 17:39:45 2020 -0600

    Rename some temperature members

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 0bf67ed41b..da73ed37a4 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -353,21 +353,21 @@ class Temperature {
         static heater_idle_t chamber_idle;
       #endif
     #endif
 
   private:
 
     #if EARLY_WATCHDOG
       static bool inited;   // If temperature controller is running
     #endif
 
-    static volatile bool temp_meas_ready;
+    static volatile bool raw_temps_ready;
 
     #if WATCH_HOTENDS
       static heater_watch_t watch_hotend[HOTENDS];
     #endif
 
     #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
       static uint16_t redundant_temperature_raw;
       static float redundant_temperature;
     #endif
 
@@ -798,21 +798,21 @@ class Temperature {
           next_temp_report_ms = millis() + 1000UL * v;
         }
       #endif
     #endif
 
     #if HAS_DISPLAY
       static void set_heating_message(const uint8_t e);
     #endif
 
   private:
-    static void set_current_temp_raw();
+    static void update_raw_temperatures();
     static void updateTemperaturesFromRawValues();
 
     #define HAS_MAX6675 EITHER(HEATER_0_USES_MAX6675, HEATER_1_USES_MAX6675)
     #if HAS_MAX6675
       #if BOTH(HEATER_0_USES_MAX6675, HEATER_1_USES_MAX6675)
         #define COUNT_6675 2
       #else
         #define COUNT_6675 1
       #endif
       #if COUNT_6675 > 1

commit 1d1dc8e33934c0f837d0c590e8fe8d2a61a1c64b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Jan 26 03:20:11 2020 -0600

    More 8 extruder defines

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 5273104503..0bf67ed41b 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -42,21 +42,21 @@
   #define E_NAME
 #else
   #define HOTEND_INDEX  e
   #define E_NAME e
 #endif
 
 // Identifiers for other heaters
 typedef enum : int8_t {
   INDEX_NONE = -5,
   H_PROBE, H_REDUNDANT, H_CHAMBER, H_BED,
-  H_E0, H_E1, H_E2, H_E3, H_E4, H_E5
+  H_E0, H_E1, H_E2, H_E3, H_E4, H_E5, H_E6, H_E7
 } heater_ind_t;
 
 // PID storage
 typedef struct { float Kp, Ki, Kd;     } PID_t;
 typedef struct { float Kp, Ki, Kd, Kc; } PIDC_t;
 typedef struct { float Kp, Ki, Kd, Kf; } PIDF_t;
 typedef struct { float Kp, Ki, Kd, Kc, Kf; } PIDCF_t;
 
 typedef
   #if BOTH(PID_EXTRUSION_SCALING, PID_FAN_SCALING)

commit 248b7dfa591a34a8aa1c6960944e1a3a468ad1de
Author: yangwenxiong <46896566+yangwenxiong@users.noreply.github.com>
Date:   Sat Jan 25 16:13:39 2020 +0800

    BigTreeTech GTR V1.0 / Support 8 extruders, heaters, temp sensors, fans (#16595)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 9c1860798c..5273104503 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -125,20 +125,26 @@ enum ADCSensorState : char {
   #endif
   #if HAS_TEMP_ADC_3
     PrepareTemp_3, MeasureTemp_3,
   #endif
   #if HAS_TEMP_ADC_4
     PrepareTemp_4, MeasureTemp_4,
   #endif
   #if HAS_TEMP_ADC_5
     PrepareTemp_5, MeasureTemp_5,
   #endif
+  #if HAS_TEMP_ADC_6
+    PrepareTemp_6, MeasureTemp_6,
+  #endif
+  #if HAS_TEMP_ADC_7
+    PrepareTemp_7, MeasureTemp_7,
+  #endif
   #if HAS_JOY_ADC_X
     PrepareJoy_X, MeasureJoy_X,
   #endif
   #if HAS_JOY_ADC_Y
     PrepareJoy_Y, MeasureJoy_Y,
   #endif
   #if HAS_JOY_ADC_Z
     PrepareJoy_Z, MeasureJoy_Z,
   #endif
   #if ENABLED(FILAMENT_WIDTH_SENSOR)

commit ef8f82951357e45a6a13069e089bca5ea79b07c3
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Mon Jan 20 07:44:51 2020 +0100

    Fix CHAMBER_MAXTEMP security margin (#16600)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 1e814294a8..9c1860798c 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -704,21 +704,21 @@ class Temperature {
     #if WATCH_CHAMBER
       static void start_watching_chamber();
     #else
       static inline void start_watching_chamber() {}
     #endif
 
     #if HAS_HEATED_CHAMBER
       static void setTargetChamber(const int16_t celsius) {
         temp_chamber.target =
           #ifdef CHAMBER_MAXTEMP
-            _MIN(celsius, CHAMBER_MAXTEMP)
+            _MIN(celsius, CHAMBER_MAXTEMP - 10)
           #else
             celsius
           #endif
         ;
         start_watching_chamber();
       }
     #endif // HAS_HEATED_CHAMBER
 
     /**
      * The software PWM power for a heater

commit a338dce83f6f3b3348a8422ad8acd7b81cc1cefe
Author: tompe-proj <59094873+tompe-proj@users.noreply.github.com>
Date:   Sat Jan 18 00:16:45 2020 +0100

    PINDA v2 temperature sensor / compensation (#16293)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 4eff4e4f62..1e814294a8 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -40,22 +40,22 @@
 #if HOTENDS <= 1
   #define HOTEND_INDEX  0
   #define E_NAME
 #else
   #define HOTEND_INDEX  e
   #define E_NAME e
 #endif
 
 // Identifiers for other heaters
 typedef enum : int8_t {
-  INDEX_NONE = -4,
-  H_REDUNDANT, H_CHAMBER, H_BED,
+  INDEX_NONE = -5,
+  H_PROBE, H_REDUNDANT, H_CHAMBER, H_BED,
   H_E0, H_E1, H_E2, H_E3, H_E4, H_E5
 } heater_ind_t;
 
 // PID storage
 typedef struct { float Kp, Ki, Kd;     } PID_t;
 typedef struct { float Kp, Ki, Kd, Kc; } PIDC_t;
 typedef struct { float Kp, Ki, Kd, Kf; } PIDF_t;
 typedef struct { float Kp, Ki, Kd, Kc, Kf; } PIDCF_t;
 
 typedef
@@ -107,20 +107,23 @@ enum ADCSensorState : char {
   StartSampling,
   #if HAS_TEMP_ADC_0
     PrepareTemp_0, MeasureTemp_0,
   #endif
   #if HAS_HEATED_BED
     PrepareTemp_BED, MeasureTemp_BED,
   #endif
   #if HAS_TEMP_CHAMBER
     PrepareTemp_CHAMBER, MeasureTemp_CHAMBER,
   #endif
+  #if HAS_TEMP_PROBE
+    PrepareTemp_PROBE, MeasureTemp_PROBE,
+  #endif
   #if HAS_TEMP_ADC_1
     PrepareTemp_1, MeasureTemp_1,
   #endif
   #if HAS_TEMP_ADC_2
     PrepareTemp_2, MeasureTemp_2,
   #endif
   #if HAS_TEMP_ADC_3
     PrepareTemp_3, MeasureTemp_3,
   #endif
   #if HAS_TEMP_ADC_4
@@ -195,20 +198,23 @@ struct PIDHeaterInfo : public HeaterInfo {
 #else
   typedef heater_info_t hotend_info_t;
 #endif
 #if HAS_HEATED_BED
   #if ENABLED(PIDTEMPBED)
     typedef struct PIDHeaterInfo<PID_t> bed_info_t;
   #else
     typedef heater_info_t bed_info_t;
   #endif
 #endif
+#if HAS_TEMP_PROBE
+  typedef temp_info_t probe_info_t;
+#endif
 #if HAS_HEATED_CHAMBER
   typedef heater_info_t chamber_info_t;
 #elif HAS_TEMP_CHAMBER
   typedef temp_info_t chamber_info_t;
 #endif
 
 // Heater idle handling
 typedef struct {
   millis_t timeout_ms;
   bool timed_out;
@@ -251,20 +257,23 @@ typedef struct { int16_t raw_min, raw_max, mintemp, maxtemp; } temp_range_t;
     #endif
     #if ENABLED(HEATER_4_USER_THERMISTOR)
       CTI_HOTEND_4,
     #endif
     #if ENABLED(HEATER_5_USER_THERMISTOR)
       CTI_HOTEND_5,
     #endif
     #if ENABLED(HEATER_BED_USER_THERMISTOR)
       CTI_BED,
     #endif
+    #if ENABLED(HEATER_PROBE_USER_THERMISTOR)
+      CTI_PROBE,
+    #endif
     #if ENABLED(HEATER_CHAMBER_USER_THERMISTOR)
       CTI_CHAMBER,
     #endif
     USER_THERMISTORS
   };
 
   // User-defined thermistor
   typedef struct {
     bool pre_calc;     // true if pre-calculations update needed
     float sh_c_coeff,  // Steinhart-Hart C coefficient .. defaults to '0.0'
@@ -282,33 +291,33 @@ class Temperature {
   public:
 
     #if HOTENDS
       #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
         #define HOTEND_TEMPS (HOTENDS + 1)
       #else
         #define HOTEND_TEMPS HOTENDS
       #endif
       static hotend_info_t temp_hotend[HOTEND_TEMPS];
     #endif
-
     #if HAS_HEATED_BED
       static bed_info_t temp_bed;
     #endif
-
+    #if HAS_TEMP_PROBE
+      static probe_info_t temp_probe;
+    #endif
     #if HAS_TEMP_CHAMBER
       static chamber_info_t temp_chamber;
     #endif
 
     #if ENABLED(AUTO_POWER_E_FANS)
       static uint8_t autofan_speed[HOTENDS];
     #endif
-
     #if ENABLED(AUTO_POWER_CHAMBER_FAN)
       static uint8_t chamberfan_speed;
     #endif
 
     #if ENABLED(FAN_SOFT_PWM)
       static uint8_t soft_pwm_amount_fan[FAN_COUNT],
                      soft_pwm_count_fan[FAN_COUNT];
     #endif
 
     #if ENABLED(PREVENT_COLD_EXTRUSION)
@@ -460,20 +469,23 @@ class Temperature {
       }
     #endif
 
     #if HOTENDS
       static float analog_to_celsius_hotend(const int raw, const uint8_t e);
     #endif
 
     #if HAS_HEATED_BED
       static float analog_to_celsius_bed(const int raw);
     #endif
+    #if HAS_TEMP_PROBE
+      static float analog_to_celsius_probe(const int raw);
+    #endif
     #if HAS_TEMP_CHAMBER
       static float analog_to_celsius_chamber(const int raw);
     #endif
 
     #if FAN_COUNT > 0
 
       static uint8_t fan_speed[FAN_COUNT];
       #define FANS_LOOP(I) LOOP_L_N(I, FAN_COUNT)
 
       static void set_fan_speed(const uint8_t target, const uint16_t speed);
@@ -655,20 +667,33 @@ class Temperature {
       }
 
       static bool wait_for_bed(const bool no_wait_for_cooling=true
         #if G26_CLICK_CAN_CANCEL
           , const bool click_to_cancel=false
         #endif
       );
 
     #endif // HAS_HEATED_BED
 
+    #if HAS_TEMP_PROBE
+      #if ENABLED(SHOW_TEMP_ADC_VALUES)
+        FORCE_INLINE static int16_t rawProbeTemp()    { return temp_probe.raw; }
+      #endif
+      FORCE_INLINE static float degProbe()            { return temp_probe.celsius; }
+    #endif
+
+    #if WATCH_PROBE
+      static void start_watching_probe();
+    #else
+      static inline void start_watching_probe() {}
+    #endif
+
     #if HAS_TEMP_CHAMBER
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         FORCE_INLINE static int16_t rawChamberTemp()    { return temp_chamber.raw; }
       #endif
       FORCE_INLINE static float degChamber()            { return temp_chamber.celsius; }
       #if HAS_HEATED_CHAMBER
         FORCE_INLINE static int16_t degTargetChamber()  { return temp_chamber.target; }
         FORCE_INLINE static bool isHeatingChamber()     { return temp_chamber.target > temp_chamber.celsius; }
         FORCE_INLINE static bool isCoolingChamber()     { return temp_chamber.target < temp_chamber.celsius; }
 

commit ff6518c0a891b5de5ef8d1aacff8be6228fe1104
Author: haschtl <haschtl@protonmail.com>
Date:   Tue Nov 26 10:34:43 2019 +0100

    Add PID_FAN_SCALING option (#15585)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index e3d7c2498e..4eff4e4f62 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -48,42 +48,56 @@
 // Identifiers for other heaters
 typedef enum : int8_t {
   INDEX_NONE = -4,
   H_REDUNDANT, H_CHAMBER, H_BED,
   H_E0, H_E1, H_E2, H_E3, H_E4, H_E5
 } heater_ind_t;
 
 // PID storage
 typedef struct { float Kp, Ki, Kd;     } PID_t;
 typedef struct { float Kp, Ki, Kd, Kc; } PIDC_t;
-#if ENABLED(PID_EXTRUSION_SCALING)
-  typedef PIDC_t hotend_pid_t;
-  #if LPQ_MAX_LEN > 255
-    typedef uint16_t lpq_ptr_t;
+typedef struct { float Kp, Ki, Kd, Kf; } PIDF_t;
+typedef struct { float Kp, Ki, Kd, Kc, Kf; } PIDCF_t;
+
+typedef
+  #if BOTH(PID_EXTRUSION_SCALING, PID_FAN_SCALING)
+    PIDCF_t
+  #elif ENABLED(PID_EXTRUSION_SCALING)
+    PIDC_t
+  #elif ENABLED(PID_FAN_SCALING)
+    PIDF_t
   #else
-    typedef uint8_t lpq_ptr_t;
+    PID_t
   #endif
-#else
-  typedef PID_t hotend_pid_t;
+hotend_pid_t;
+
+#if ENABLED(PID_EXTRUSION_SCALING)
+  typedef IF<(LPQ_MAX_LEN > 255), uint16_t, uint8_t>::type lpq_ptr_t;
 #endif
 
 #define DUMMY_PID_VALUE 3000.0f
 
 #if ENABLED(PIDTEMP)
   #define _PID_Kp(H) Temperature::temp_hotend[H].pid.Kp
   #define _PID_Ki(H) Temperature::temp_hotend[H].pid.Ki
   #define _PID_Kd(H) Temperature::temp_hotend[H].pid.Kd
   #if ENABLED(PID_EXTRUSION_SCALING)
     #define _PID_Kc(H) Temperature::temp_hotend[H].pid.Kc
   #else
     #define _PID_Kc(H) 1
   #endif
+
+  #if ENABLED(PID_FAN_SCALING)
+    #define _PID_Kf(H) Temperature::temp_hotend[H].pid.Kf
+  #else
+    #define _PID_Kf(H) 0
+  #endif
 #else
   #define _PID_Kp(H) DUMMY_PID_VALUE
   #define _PID_Ki(H) DUMMY_PID_VALUE
   #define _PID_Kd(H) DUMMY_PID_VALUE
   #define _PID_Kc(H) 1
 #endif
 
 #define PID_PARAM(F,H) _PID_##F(H)
 
 /**

commit ac71cdc265374717c067102b2bc22af002c86ee3
Author: Lino Barreca <linobarreca@hotmail.com>
Date:   Wed Nov 13 02:23:02 2019 +0100

    New HardwareTimer for STM32 5.7.0 (#15655)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 6a746626d8..e3d7c2498e 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -210,22 +210,22 @@ typedef struct {
   millis_t next_ms;
   inline bool elapsed(const millis_t &ms) { return next_ms && ELAPSED(ms, next_ms); }
   inline bool elapsed() { return elapsed(millis()); }
 } heater_watch_t;
 
 // Temperature sensor read value ranges
 typedef struct { int16_t raw_min, raw_max; } raw_range_t;
 typedef struct { int16_t mintemp, maxtemp; } celsius_range_t;
 typedef struct { int16_t raw_min, raw_max, mintemp, maxtemp; } temp_range_t;
 
-#define THERMISTOR_ABS_ZERO_C           -273.15f       // bbbbrrrrr cold !
-#define THERMISTOR_RESISTANCE_NOMINAL_C 25.0f          // mmmmm comfortable
+#define THERMISTOR_ABS_ZERO_C           -273.15f  // bbbbrrrrr cold !
+#define THERMISTOR_RESISTANCE_NOMINAL_C 25.0f     // mmmmm comfortable
 
 #if HAS_USER_THERMISTORS
 
   enum CustomThermistorIndex : uint8_t {
     #if ENABLED(HEATER_0_USER_THERMISTOR)
       CTI_HOTEND_0,
     #endif
     #if ENABLED(HEATER_1_USER_THERMISTOR)
       CTI_HOTEND_1,
     #endif
@@ -260,22 +260,20 @@ typedef struct { int16_t raw_min, raw_max, mintemp, maxtemp; } temp_range_t;
           res_25_log,
           beta, beta_recip;
   } user_thermistor_t;
 
 #endif
 
 class Temperature {
 
   public:
 
-    static volatile bool in_temp_isr;
-
     #if HOTENDS
       #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
         #define HOTEND_TEMPS (HOTENDS + 1)
       #else
         #define HOTEND_TEMPS HOTENDS
       #endif
       static hotend_info_t temp_hotend[HOTEND_TEMPS];
     #endif
 
     #if HAS_HEATED_BED
@@ -506,21 +504,21 @@ class Temperature {
     static inline void zero_fan_speeds() {
       #if FAN_COUNT > 0
         FANS_LOOP(i) set_fan_speed(i, 0);
       #endif
     }
 
     /**
      * Called from the Temperature ISR
      */
     static void readings_ready();
-    static void isr();
+    static void tick();
 
     /**
      * Call periodically to manage heaters
      */
     static void manage_heater() _O2; // Added _O2 to work around a compiler error
 
     /**
      * Preheating hotends
      */
     #ifdef MILLISECONDS_PREHEAT_TIME

commit 5639b8ca20bd67a4f6c9a8d5cf5ce1db3ec74aa8
Author: Marcio Teixeira <57453521+marcio-cp@users.noreply.github.com>
Date:   Sun Nov 10 17:49:41 2019 -0700

    Touch UI fixes for Cocoa Press (#15847)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 588c451993..6a746626d8 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -471,20 +471,21 @@ class Temperature {
         static uint8_t saved_fan_speed[FAN_COUNT];
       #endif
 
       static constexpr inline uint8_t fanPercent(const uint8_t speed) { return ui8_to_percent(speed); }
 
       #if ENABLED(ADAPTIVE_FAN_SLOWING)
         static uint8_t fan_speed_scaler[FAN_COUNT];
       #endif
 
       static inline uint8_t scaledFanSpeed(const uint8_t target, const uint8_t fs) {
+        UNUSED(target); // Potentially unused!
         return (fs * uint16_t(
           #if ENABLED(ADAPTIVE_FAN_SLOWING)
             fan_speed_scaler[target]
           #else
             128
           #endif
         )) >> 7;
       }
 
       static inline uint8_t scaledFanSpeed(const uint8_t target) {

commit a84e3d1b8049653345d694c1171d6d3491ebf618
Author: LinFor <linfor@gmail.com>
Date:   Thu Nov 7 02:49:17 2019 +0300

    Use native ADC resolution where possible (#15719)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index c294325d9b..588c451993 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -210,21 +210,20 @@ typedef struct {
   millis_t next_ms;
   inline bool elapsed(const millis_t &ms) { return next_ms && ELAPSED(ms, next_ms); }
   inline bool elapsed() { return elapsed(millis()); }
 } heater_watch_t;
 
 // Temperature sensor read value ranges
 typedef struct { int16_t raw_min, raw_max; } raw_range_t;
 typedef struct { int16_t mintemp, maxtemp; } celsius_range_t;
 typedef struct { int16_t raw_min, raw_max, mintemp, maxtemp; } temp_range_t;
 
-#define THERMISTOR_ADC_RESOLUTION       1024           // 10-bit ADC .. shame to waste 12-bits of resolution on 32-bit
 #define THERMISTOR_ABS_ZERO_C           -273.15f       // bbbbrrrrr cold !
 #define THERMISTOR_RESISTANCE_NOMINAL_C 25.0f          // mmmmm comfortable
 
 #if HAS_USER_THERMISTORS
 
   enum CustomThermistorIndex : uint8_t {
     #if ENABLED(HEATER_0_USER_THERMISTOR)
       CTI_HOTEND_0,
     #endif
     #if ENABLED(HEATER_1_USER_THERMISTOR)

commit dc14d4a13c1eb80a76237ebcab6d8a512d960391
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Wed Oct 9 18:44:49 2019 -0600

    Improvements and fixes to Lulzbot UI (#15490)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 052ac156d6..c294325d9b 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -469,26 +469,30 @@ class Temperature {
 
       #if EITHER(PROBING_FANS_OFF, ADVANCED_PAUSE_FANS_PAUSE)
         static bool fans_paused;
         static uint8_t saved_fan_speed[FAN_COUNT];
       #endif
 
       static constexpr inline uint8_t fanPercent(const uint8_t speed) { return ui8_to_percent(speed); }
 
       #if ENABLED(ADAPTIVE_FAN_SLOWING)
         static uint8_t fan_speed_scaler[FAN_COUNT];
-      #else
-        static constexpr uint8_t fan_speed_scaler[FAN_COUNT] = ARRAY_N(FAN_COUNT, 128, 128, 128, 128, 128, 128);
       #endif
 
       static inline uint8_t scaledFanSpeed(const uint8_t target, const uint8_t fs) {
-        return (fs * uint16_t(fan_speed_scaler[target])) >> 7;
+        return (fs * uint16_t(
+          #if ENABLED(ADAPTIVE_FAN_SLOWING)
+            fan_speed_scaler[target]
+          #else
+            128
+          #endif
+        )) >> 7;
       }
 
       static inline uint8_t scaledFanSpeed(const uint8_t target) {
         return scaledFanSpeed(target, fan_speed[target]);
       }
 
       #if ENABLED(EXTRA_FAN_SPEED)
         static uint8_t old_fan_speed[FAN_COUNT], new_fan_speed[FAN_COUNT];
         static void set_temp_fan_speed(const uint8_t fan, const uint16_t tmp_temp);
       #endif

commit cc822c1a0513362e28f1b3aff76d4c4c06446f01
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Oct 7 19:44:33 2019 -0500

    Use lambdas in menus, where possible (#15452)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index e75eae4f85..052ac156d6 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -486,44 +486,20 @@ class Temperature {
 
       static inline uint8_t scaledFanSpeed(const uint8_t target) {
         return scaledFanSpeed(target, fan_speed[target]);
       }
 
       #if ENABLED(EXTRA_FAN_SPEED)
         static uint8_t old_fan_speed[FAN_COUNT], new_fan_speed[FAN_COUNT];
         static void set_temp_fan_speed(const uint8_t fan, const uint16_t tmp_temp);
       #endif
 
-      #if HAS_LCD_MENU
-
-        static uint8_t lcd_tmpfan_speed[
-          #if ENABLED(SINGLENOZZLE)
-            _MAX(EXTRUDERS, FAN_COUNT)
-          #else
-            FAN_COUNT
-          #endif
-        ];
-
-        static inline void lcd_setFanSpeed(const uint8_t target) { set_fan_speed(target, lcd_tmpfan_speed[target]); }
-
-        #if HAS_FAN0
-          FORCE_INLINE static void lcd_setFanSpeed0() { lcd_setFanSpeed(0); }
-        #endif
-        #if HAS_FAN1 || (ENABLED(SINGLENOZZLE) && EXTRUDERS > 1)
-          FORCE_INLINE static void lcd_setFanSpeed1() { lcd_setFanSpeed(1); }
-        #endif
-        #if HAS_FAN2 || (ENABLED(SINGLENOZZLE) && EXTRUDERS > 2)
-          FORCE_INLINE static void lcd_setFanSpeed2() { lcd_setFanSpeed(2); }
-        #endif
-
-      #endif // HAS_LCD_MENU
-
       #if EITHER(PROBING_FANS_OFF, ADVANCED_PAUSE_FANS_PAUSE)
         void set_fans_paused(const bool p);
       #endif
 
     #endif // FAN_COUNT > 0
 
     static inline void zero_fan_speeds() {
       #if FAN_COUNT > 0
         FANS_LOOP(i) set_fan_speed(i, 0);
       #endif
@@ -588,29 +564,20 @@ class Temperature {
     }
 
     #if WATCH_HOTENDS
       static void start_watching_hotend(const uint8_t e=0);
     #else
       static inline void start_watching_hotend(const uint8_t=0) {}
     #endif
 
     #if HOTENDS
 
-      #if HAS_LCD_MENU
-        static inline void start_watching_E0() { start_watching_hotend(0); }
-        static inline void start_watching_E1() { start_watching_hotend(1); }
-        static inline void start_watching_E2() { start_watching_hotend(2); }
-        static inline void start_watching_E3() { start_watching_hotend(3); }
-        static inline void start_watching_E4() { start_watching_hotend(4); }
-        static inline void start_watching_E5() { start_watching_hotend(5); }
-      #endif
-
       static void setTargetHotend(const int16_t celsius, const uint8_t E_NAME) {
         const uint8_t ee = HOTEND_INDEX;
         #ifdef MILLISECONDS_PREHEAT_TIME
           if (celsius == 0)
             reset_preheat_time(ee);
           else if (temp_hotend[ee].target == 0)
             start_preheat_time(ee);
         #endif
         #if ENABLED(AUTO_POWER_CONTROL)
           powerManager.power_on();

commit e3fd0519b323182a3d096eca8209c4eaf56b6802
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 30 21:44:07 2019 -0500

    Reduce need for UNUSED

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 63251cd40f..e75eae4f85 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -32,24 +32,24 @@
 #if ENABLED(AUTO_POWER_CONTROL)
   #include "../feature/power.h"
 #endif
 
 #ifndef SOFT_PWM_SCALE
   #define SOFT_PWM_SCALE 0
 #endif
 
 #if HOTENDS <= 1
   #define HOTEND_INDEX  0
-  #define E_UNUSED() UNUSED(e)
+  #define E_NAME
 #else
   #define HOTEND_INDEX  e
-  #define E_UNUSED()
+  #define E_NAME e
 #endif
 
 // Identifiers for other heaters
 typedef enum : int8_t {
   INDEX_NONE = -4,
   H_REDUNDANT, H_CHAMBER, H_BED,
   H_E0, H_E1, H_E2, H_E3, H_E4, H_E5
 } heater_ind_t;
 
 // PID storage
@@ -297,31 +297,29 @@ class Temperature {
 
     #if ENABLED(FAN_SOFT_PWM)
       static uint8_t soft_pwm_amount_fan[FAN_COUNT],
                      soft_pwm_count_fan[FAN_COUNT];
     #endif
 
     #if ENABLED(PREVENT_COLD_EXTRUSION)
       static bool allow_cold_extrude;
       static int16_t extrude_min_temp;
       FORCE_INLINE static bool tooCold(const int16_t temp) { return allow_cold_extrude ? false : temp < extrude_min_temp; }
-      FORCE_INLINE static bool tooColdToExtrude(const uint8_t e) {
-        E_UNUSED();
+      FORCE_INLINE static bool tooColdToExtrude(const uint8_t E_NAME) {
         return tooCold(degHotend(HOTEND_INDEX));
       }
-      FORCE_INLINE static bool targetTooColdToExtrude(const uint8_t e) {
-        E_UNUSED();
+      FORCE_INLINE static bool targetTooColdToExtrude(const uint8_t E_NAME) {
         return tooCold(degTargetHotend(HOTEND_INDEX));
       }
     #else
-      FORCE_INLINE static bool tooColdToExtrude(const uint8_t e) { UNUSED(e); return false; }
-      FORCE_INLINE static bool targetTooColdToExtrude(const uint8_t e) { UNUSED(e); return false; }
+      FORCE_INLINE static bool tooColdToExtrude(const uint8_t) { return false; }
+      FORCE_INLINE static bool targetTooColdToExtrude(const uint8_t) { return false; }
     #endif
 
     FORCE_INLINE static bool hotEnoughToExtrude(const uint8_t e) { return !tooColdToExtrude(e); }
     FORCE_INLINE static bool targetHotEnoughToExtrude(const uint8_t e) { return !targetTooColdToExtrude(e); }
 
     #if HEATER_IDLE_HANDLER
       static heater_idle_t hotend_idle[HOTENDS];
       #if HAS_HEATED_BED
         static heater_idle_t bed_idle;
       #endif
@@ -539,109 +537,100 @@ class Temperature {
 
     /**
      * Call periodically to manage heaters
      */
     static void manage_heater() _O2; // Added _O2 to work around a compiler error
 
     /**
      * Preheating hotends
      */
     #ifdef MILLISECONDS_PREHEAT_TIME
-      static bool is_preheating(const uint8_t e) {
-        E_UNUSED();
+      static bool is_preheating(const uint8_t E_NAME) {
         return preheat_end_time[HOTEND_INDEX] && PENDING(millis(), preheat_end_time[HOTEND_INDEX]);
       }
-      static void start_preheat_time(const uint8_t e) {
-        E_UNUSED();
+      static void start_preheat_time(const uint8_t E_NAME) {
         preheat_end_time[HOTEND_INDEX] = millis() + MILLISECONDS_PREHEAT_TIME;
       }
-      static void reset_preheat_time(const uint8_t e) {
-        E_UNUSED();
+      static void reset_preheat_time(const uint8_t E_NAME) {
         preheat_end_time[HOTEND_INDEX] = 0;
       }
     #else
       #define is_preheating(n) (false)
     #endif
 
     //high level conversion routines, for use outside of temperature.cpp
     //inline so that there is no performance decrease.
     //deg=degreeCelsius
 
-    FORCE_INLINE static float degHotend(const uint8_t e) {
-      E_UNUSED();
-      #if HOTENDS
-        return temp_hotend[HOTEND_INDEX].celsius;
-      #else
-        return 0;
-      #endif
+    FORCE_INLINE static float degHotend(const uint8_t E_NAME) {
+      return (0
+        #if HOTENDS
+          + temp_hotend[HOTEND_INDEX].celsius
+        #endif
+      );
     }
 
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
-      FORCE_INLINE static int16_t rawHotendTemp(const uint8_t e) {
-        E_UNUSED();
-        #if HOTENDS
-          return temp_hotend[HOTEND_INDEX].raw;
-        #else
-          return 0;
-        #endif
+      FORCE_INLINE static int16_t rawHotendTemp(const uint8_t E_NAME) {
+        return (0
+          #if HOTENDS
+            + temp_hotend[HOTEND_INDEX].raw
+          #endif
+        );
       }
     #endif
 
-    FORCE_INLINE static int16_t degTargetHotend(const uint8_t e) {
-      E_UNUSED();
-      #if HOTENDS
-        return temp_hotend[HOTEND_INDEX].target;
-      #else
-        return 0;
-      #endif
+    FORCE_INLINE static int16_t degTargetHotend(const uint8_t E_NAME) {
+      return (0
+        #if HOTENDS
+          + temp_hotend[HOTEND_INDEX].target
+        #endif
+      );
     }
 
     #if WATCH_HOTENDS
       static void start_watching_hotend(const uint8_t e=0);
     #else
-      static inline void start_watching_hotend(const uint8_t e=0) { UNUSED(e); }
+      static inline void start_watching_hotend(const uint8_t=0) {}
     #endif
 
     #if HOTENDS
 
       #if HAS_LCD_MENU
         static inline void start_watching_E0() { start_watching_hotend(0); }
         static inline void start_watching_E1() { start_watching_hotend(1); }
         static inline void start_watching_E2() { start_watching_hotend(2); }
         static inline void start_watching_E3() { start_watching_hotend(3); }
         static inline void start_watching_E4() { start_watching_hotend(4); }
         static inline void start_watching_E5() { start_watching_hotend(5); }
       #endif
 
-      static void setTargetHotend(const int16_t celsius, const uint8_t e) {
-        E_UNUSED();
+      static void setTargetHotend(const int16_t celsius, const uint8_t E_NAME) {
         const uint8_t ee = HOTEND_INDEX;
         #ifdef MILLISECONDS_PREHEAT_TIME
           if (celsius == 0)
             reset_preheat_time(ee);
           else if (temp_hotend[ee].target == 0)
             start_preheat_time(ee);
         #endif
         #if ENABLED(AUTO_POWER_CONTROL)
           powerManager.power_on();
         #endif
         temp_hotend[ee].target = _MIN(celsius, temp_range[ee].maxtemp - 15);
         start_watching_hotend(ee);
       }
 
-      FORCE_INLINE static bool isHeatingHotend(const uint8_t e) {
-        E_UNUSED();
+      FORCE_INLINE static bool isHeatingHotend(const uint8_t E_NAME) {
         return temp_hotend[HOTEND_INDEX].target > temp_hotend[HOTEND_INDEX].celsius;
       }
 
-      FORCE_INLINE static bool isCoolingHotend(const uint8_t e) {
-        E_UNUSED();
+      FORCE_INLINE static bool isCoolingHotend(const uint8_t E_NAME) {
         return temp_hotend[HOTEND_INDEX].target < temp_hotend[HOTEND_INDEX].celsius;
       }
 
       #if HAS_TEMP_HOTEND
         static bool wait_for_hotend(const uint8_t target_extruder, const bool no_wait_for_cooling=true
           #if G26_CLICK_CAN_CANCEL
             , const bool click_to_cancel=false
           #endif
         );
       #endif
@@ -758,22 +747,21 @@ class Temperature {
 
     #endif
 
     #if ENABLED(PROBING_HEATERS_OFF)
       static void pause(const bool p);
       FORCE_INLINE static bool is_paused() { return paused; }
     #endif
 
     #if HEATER_IDLE_HANDLER
 
-      static void reset_heater_idle_timer(const uint8_t e) {
-        E_UNUSED();
+      static void reset_heater_idle_timer(const uint8_t E_NAME) {
         hotend_idle[HOTEND_INDEX].reset();
         start_watching_hotend(HOTEND_INDEX);
       }
 
       #if HAS_HEATED_BED
         static void reset_bed_idle_timer() {
           bed_idle.reset();
           start_watching_bed();
         }
       #endif

commit f01f0d1956bb5cf0a9efb538b334ed6165a3e20f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 16 20:31:08 2019 -0500

    Drop C-style 'void' argument

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 7419c124d2..63251cd40f 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -782,21 +782,21 @@ class Temperature {
 
     #if HAS_TEMP_SENSOR
       static void print_heater_states(const uint8_t target_extruder
         #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
           , const bool include_r=false
         #endif
       );
       #if ENABLED(AUTO_REPORT_TEMPERATURES)
         static uint8_t auto_report_temp_interval;
         static millis_t next_temp_report_ms;
-        static void auto_report_temperatures(void);
+        static void auto_report_temperatures();
         static inline void set_auto_report_interval(uint8_t v) {
           NOMORE(v, 60);
           auto_report_temp_interval = v;
           next_temp_report_ms = millis() + 1000UL * v;
         }
       #endif
     #endif
 
     #if HAS_DISPLAY
       static void set_heating_message(const uint8_t e);

commit 75927e17dd2114c14a593c12394d941eff684685
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 10 18:48:58 2019 -0500

    Filament Width Sensor singleton (#15191)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 22b1cd6c98..7419c124d2 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -385,32 +385,24 @@ class Temperature {
     #endif
 
     #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
       static uint8_t consecutive_low_temperature_error[HOTENDS];
     #endif
 
     #ifdef MILLISECONDS_PREHEAT_TIME
       static millis_t preheat_end_time[HOTENDS];
     #endif
 
-    #if ENABLED(FILAMENT_WIDTH_SENSOR)
-      static int8_t meas_shift_index;  // Index of a delayed sample in buffer
-    #endif
-
     #if HAS_AUTO_FAN
       static millis_t next_auto_fan_check_ms;
     #endif
 
-    #if ENABLED(FILAMENT_WIDTH_SENSOR)
-      static uint16_t current_raw_filwidth; // Measured filament diameter - one extruder only
-    #endif
-
     #if ENABLED(PROBING_HEATERS_OFF)
       static bool paused;
     #endif
 
   public:
     #if HAS_ADC_BUTTONS
       static uint32_t current_ADCKey_raw;
       static uint8_t ADCKey_count;
     #endif
 
@@ -563,26 +555,20 @@ class Temperature {
         preheat_end_time[HOTEND_INDEX] = millis() + MILLISECONDS_PREHEAT_TIME;
       }
       static void reset_preheat_time(const uint8_t e) {
         E_UNUSED();
         preheat_end_time[HOTEND_INDEX] = 0;
       }
     #else
       #define is_preheating(n) (false)
     #endif
 
-    #if ENABLED(FILAMENT_WIDTH_SENSOR)
-      static float analog_to_mm_fil_width();         // Convert raw Filament Width to millimeters
-      static int8_t widthFil_to_size_ratio(); // Convert Filament Width (mm) to an extrusion ratio
-    #endif
-
-
     //high level conversion routines, for use outside of temperature.cpp
     //inline so that there is no performance decrease.
     //deg=degreeCelsius
 
     FORCE_INLINE static float degHotend(const uint8_t e) {
       E_UNUSED();
       #if HOTENDS
         return temp_hotend[HOTEND_INDEX].celsius;
       #else
         return 0;

commit 584c86bed1d81548da03681bd3b3c6bd54ae0fe3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 10 02:20:49 2019 -0500

    More "zero extruders" changes (#15213)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 774935e85a..22b1cd6c98 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -263,25 +263,28 @@ typedef struct { int16_t raw_min, raw_max, mintemp, maxtemp; } temp_range_t;
   } user_thermistor_t;
 
 #endif
 
 class Temperature {
 
   public:
 
     static volatile bool in_temp_isr;
 
-    static hotend_info_t temp_hotend[HOTENDS
+    #if HOTENDS
       #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
-        + 1
+        #define HOTEND_TEMPS (HOTENDS + 1)
+      #else
+        #define HOTEND_TEMPS HOTENDS
       #endif
-    ];
+      static hotend_info_t temp_hotend[HOTEND_TEMPS];
+    #endif
 
     #if HAS_HEATED_BED
       static bed_info_t temp_bed;
     #endif
 
     #if HAS_TEMP_CHAMBER
       static chamber_info_t temp_chamber;
     #endif
 
     #if ENABLED(AUTO_POWER_E_FANS)
@@ -342,21 +345,23 @@ class Temperature {
     #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
       static uint16_t redundant_temperature_raw;
       static float redundant_temperature;
     #endif
 
     #if ENABLED(PID_EXTRUSION_SCALING)
       static int32_t last_e_position, lpq[LPQ_MAX_LEN];
       static lpq_ptr_t lpq_ptr;
     #endif
 
-    static temp_range_t temp_range[HOTENDS];
+    #if HOTENDS
+      static temp_range_t temp_range[HOTENDS];
+    #endif
 
     #if HAS_HEATED_BED
       #if WATCH_BED
         static heater_watch_t watch_bed;
       #endif
       #if DISABLED(PIDTEMPBED)
         static millis_t next_bed_check_ms;
       #endif
       #ifdef BED_MINTEMP
         static int16_t mintemp_raw_BED;
@@ -410,22 +415,20 @@ class Temperature {
     #endif
 
     #if ENABLED(PID_EXTRUSION_SCALING)
       static int16_t lpq_len;
     #endif
 
     /**
      * Instance Methods
      */
 
-    Temperature();
-
     void init();
 
     /**
      * Static (class) methods
      */
 
     #if HAS_USER_THERMISTORS
       static user_thermistor_t user_thermistor[USER_THERMISTORS];
       static void log_user_thermistor(const uint8_t t_index, const bool eprom=false);
       static void reset_user_thermistors();
@@ -449,21 +452,23 @@ class Temperature {
         return true;
       }
       static bool set_sh_coeff(int8_t t_index, float value) {
         if (!WITHIN(value, -0.01f, 0.01f)) return false;
         user_thermistor[t_index].sh_c_coeff = value;
         user_thermistor[t_index].pre_calc = true;
         return true;
       }
     #endif
 
-    static float analog_to_celsius_hotend(const int raw, const uint8_t e);
+    #if HOTENDS
+      static float analog_to_celsius_hotend(const int raw, const uint8_t e);
+    #endif
 
     #if HAS_HEATED_BED
       static float analog_to_celsius_bed(const int raw);
     #endif
     #if HAS_TEMP_CHAMBER
       static float analog_to_celsius_chamber(const int raw);
     #endif
 
     #if FAN_COUNT > 0
 
@@ -570,87 +575,103 @@ class Temperature {
       static int8_t widthFil_to_size_ratio(); // Convert Filament Width (mm) to an extrusion ratio
     #endif
 
 
     //high level conversion routines, for use outside of temperature.cpp
     //inline so that there is no performance decrease.
     //deg=degreeCelsius
 
     FORCE_INLINE static float degHotend(const uint8_t e) {
       E_UNUSED();
-      return temp_hotend[HOTEND_INDEX].celsius;
+      #if HOTENDS
+        return temp_hotend[HOTEND_INDEX].celsius;
+      #else
+        return 0;
+      #endif
     }
 
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       FORCE_INLINE static int16_t rawHotendTemp(const uint8_t e) {
         E_UNUSED();
-        return temp_hotend[HOTEND_INDEX].raw;
+        #if HOTENDS
+          return temp_hotend[HOTEND_INDEX].raw;
+        #else
+          return 0;
+        #endif
       }
     #endif
 
     FORCE_INLINE static int16_t degTargetHotend(const uint8_t e) {
       E_UNUSED();
-      return temp_hotend[HOTEND_INDEX].target;
+      #if HOTENDS
+        return temp_hotend[HOTEND_INDEX].target;
+      #else
+        return 0;
+      #endif
     }
 
     #if WATCH_HOTENDS
       static void start_watching_hotend(const uint8_t e=0);
     #else
       static inline void start_watching_hotend(const uint8_t e=0) { UNUSED(e); }
     #endif
 
-    #if HAS_LCD_MENU
-      static inline void start_watching_E0() { start_watching_hotend(0); }
-      static inline void start_watching_E1() { start_watching_hotend(1); }
-      static inline void start_watching_E2() { start_watching_hotend(2); }
-      static inline void start_watching_E3() { start_watching_hotend(3); }
-      static inline void start_watching_E4() { start_watching_hotend(4); }
-      static inline void start_watching_E5() { start_watching_hotend(5); }
-    #endif
+    #if HOTENDS
 
-    static void setTargetHotend(const int16_t celsius, const uint8_t e) {
-      E_UNUSED();
-      const uint8_t ee = HOTEND_INDEX;
-      #ifdef MILLISECONDS_PREHEAT_TIME
-        if (celsius == 0)
-          reset_preheat_time(ee);
-        else if (temp_hotend[ee].target == 0)
-          start_preheat_time(ee);
-      #endif
-      #if ENABLED(AUTO_POWER_CONTROL)
-        powerManager.power_on();
-      #endif
-      temp_hotend[ee].target = _MIN(celsius, temp_range[ee].maxtemp - 15);
-      start_watching_hotend(ee);
-    }
+      #if HAS_LCD_MENU
+        static inline void start_watching_E0() { start_watching_hotend(0); }
+        static inline void start_watching_E1() { start_watching_hotend(1); }
+        static inline void start_watching_E2() { start_watching_hotend(2); }
+        static inline void start_watching_E3() { start_watching_hotend(3); }
+        static inline void start_watching_E4() { start_watching_hotend(4); }
+        static inline void start_watching_E5() { start_watching_hotend(5); }
+      #endif
 
-    FORCE_INLINE static bool isHeatingHotend(const uint8_t e) {
-      E_UNUSED();
-      return temp_hotend[HOTEND_INDEX].target > temp_hotend[HOTEND_INDEX].celsius;
-    }
+      static void setTargetHotend(const int16_t celsius, const uint8_t e) {
+        E_UNUSED();
+        const uint8_t ee = HOTEND_INDEX;
+        #ifdef MILLISECONDS_PREHEAT_TIME
+          if (celsius == 0)
+            reset_preheat_time(ee);
+          else if (temp_hotend[ee].target == 0)
+            start_preheat_time(ee);
+        #endif
+        #if ENABLED(AUTO_POWER_CONTROL)
+          powerManager.power_on();
+        #endif
+        temp_hotend[ee].target = _MIN(celsius, temp_range[ee].maxtemp - 15);
+        start_watching_hotend(ee);
+      }
 
-    FORCE_INLINE static bool isCoolingHotend(const uint8_t e) {
-      E_UNUSED();
-      return temp_hotend[HOTEND_INDEX].target < temp_hotend[HOTEND_INDEX].celsius;
-    }
+      FORCE_INLINE static bool isHeatingHotend(const uint8_t e) {
+        E_UNUSED();
+        return temp_hotend[HOTEND_INDEX].target > temp_hotend[HOTEND_INDEX].celsius;
+      }
 
-    #if HAS_TEMP_HOTEND
-      static bool wait_for_hotend(const uint8_t target_extruder, const bool no_wait_for_cooling=true
-        #if G26_CLICK_CAN_CANCEL
-          , const bool click_to_cancel=false
-        #endif
-      );
-    #endif
+      FORCE_INLINE static bool isCoolingHotend(const uint8_t e) {
+        E_UNUSED();
+        return temp_hotend[HOTEND_INDEX].target < temp_hotend[HOTEND_INDEX].celsius;
+      }
 
-    FORCE_INLINE static bool still_heating(const uint8_t e) {
-      return degTargetHotend(e) > TEMP_HYSTERESIS && ABS(degHotend(e) - degTargetHotend(e)) > TEMP_HYSTERESIS;
-    }
+      #if HAS_TEMP_HOTEND
+        static bool wait_for_hotend(const uint8_t target_extruder, const bool no_wait_for_cooling=true
+          #if G26_CLICK_CAN_CANCEL
+            , const bool click_to_cancel=false
+          #endif
+        );
+      #endif
+
+      FORCE_INLINE static bool still_heating(const uint8_t e) {
+        return degTargetHotend(e) > TEMP_HYSTERESIS && ABS(degHotend(e) - degTargetHotend(e)) > TEMP_HYSTERESIS;
+      }
+
+    #endif // HOTENDS
 
     #if HAS_HEATED_BED
 
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         FORCE_INLINE static int16_t rawBedTemp()  { return temp_bed.raw; }
       #endif
       FORCE_INLINE static float degBed()          { return temp_bed.celsius; }
       FORCE_INLINE static int16_t degTargetBed()  { return temp_bed.target; }
       FORCE_INLINE static bool isHeatingBed()     { return temp_bed.target > temp_bed.celsius; }
       FORCE_INLINE static bool isCoolingBed()     { return temp_bed.target < temp_bed.celsius; }

commit 565a0e11ed2d386ef343bf68274334c884dc6dbf
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 9 02:56:23 2019 -0500

    Prevent 'current' name conflict, if needed

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index df2fcf1062..774935e85a 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -151,21 +151,21 @@ enum ADCSensorState : char {
   #define scalePID_d(d)   ( float(d) / PID_dT )
   #define unscalePID_d(d) ( float(d) * PID_dT )
 #endif
 
 #define G26_CLICK_CAN_CANCEL (HAS_LCD_MENU && ENABLED(G26_MESH_VALIDATION))
 
 // A temperature sensor
 typedef struct TempInfo {
   uint16_t acc;
   int16_t raw;
-  float current;
+  float celsius;
   inline void reset() { acc = 0; }
   inline void sample(const uint16_t s) { acc += s; }
   inline void update() { raw = acc; }
 } temp_info_t;
 
 // A PWM heater with temperature sensor
 typedef struct HeaterInfo : public TempInfo {
   int16_t target;
   uint8_t soft_pwm_amount;
 } heater_info_t;
@@ -570,21 +570,21 @@ class Temperature {
       static int8_t widthFil_to_size_ratio(); // Convert Filament Width (mm) to an extrusion ratio
     #endif
 
 
     //high level conversion routines, for use outside of temperature.cpp
     //inline so that there is no performance decrease.
     //deg=degreeCelsius
 
     FORCE_INLINE static float degHotend(const uint8_t e) {
       E_UNUSED();
-      return temp_hotend[HOTEND_INDEX].current;
+      return temp_hotend[HOTEND_INDEX].celsius;
     }
 
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       FORCE_INLINE static int16_t rawHotendTemp(const uint8_t e) {
         E_UNUSED();
         return temp_hotend[HOTEND_INDEX].raw;
       }
     #endif
 
     FORCE_INLINE static int16_t degTargetHotend(const uint8_t e) {
@@ -618,49 +618,49 @@ class Temperature {
       #endif
       #if ENABLED(AUTO_POWER_CONTROL)
         powerManager.power_on();
       #endif
       temp_hotend[ee].target = _MIN(celsius, temp_range[ee].maxtemp - 15);
       start_watching_hotend(ee);
     }
 
     FORCE_INLINE static bool isHeatingHotend(const uint8_t e) {
       E_UNUSED();
-      return temp_hotend[HOTEND_INDEX].target > temp_hotend[HOTEND_INDEX].current;
+      return temp_hotend[HOTEND_INDEX].target > temp_hotend[HOTEND_INDEX].celsius;
     }
 
     FORCE_INLINE static bool isCoolingHotend(const uint8_t e) {
       E_UNUSED();
-      return temp_hotend[HOTEND_INDEX].target < temp_hotend[HOTEND_INDEX].current;
+      return temp_hotend[HOTEND_INDEX].target < temp_hotend[HOTEND_INDEX].celsius;
     }
 
     #if HAS_TEMP_HOTEND
       static bool wait_for_hotend(const uint8_t target_extruder, const bool no_wait_for_cooling=true
         #if G26_CLICK_CAN_CANCEL
           , const bool click_to_cancel=false
         #endif
       );
     #endif
 
     FORCE_INLINE static bool still_heating(const uint8_t e) {
       return degTargetHotend(e) > TEMP_HYSTERESIS && ABS(degHotend(e) - degTargetHotend(e)) > TEMP_HYSTERESIS;
     }
 
     #if HAS_HEATED_BED
 
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         FORCE_INLINE static int16_t rawBedTemp()  { return temp_bed.raw; }
       #endif
-      FORCE_INLINE static float degBed()          { return temp_bed.current; }
+      FORCE_INLINE static float degBed()          { return temp_bed.celsius; }
       FORCE_INLINE static int16_t degTargetBed()  { return temp_bed.target; }
-      FORCE_INLINE static bool isHeatingBed()     { return temp_bed.target > temp_bed.current; }
-      FORCE_INLINE static bool isCoolingBed()     { return temp_bed.target < temp_bed.current; }
+      FORCE_INLINE static bool isHeatingBed()     { return temp_bed.target > temp_bed.celsius; }
+      FORCE_INLINE static bool isCoolingBed()     { return temp_bed.target < temp_bed.celsius; }
 
       #if WATCH_BED
         static void start_watching_bed();
       #else
         static inline void start_watching_bed() {}
       #endif
 
       static void setTargetBed(const int16_t celsius) {
         #if ENABLED(AUTO_POWER_CONTROL)
           powerManager.power_on();
@@ -680,25 +680,25 @@ class Temperature {
           , const bool click_to_cancel=false
         #endif
       );
 
     #endif // HAS_HEATED_BED
 
     #if HAS_TEMP_CHAMBER
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         FORCE_INLINE static int16_t rawChamberTemp()    { return temp_chamber.raw; }
       #endif
-      FORCE_INLINE static float degChamber()            { return temp_chamber.current; }
+      FORCE_INLINE static float degChamber()            { return temp_chamber.celsius; }
       #if HAS_HEATED_CHAMBER
         FORCE_INLINE static int16_t degTargetChamber()  { return temp_chamber.target; }
-        FORCE_INLINE static bool isHeatingChamber()     { return temp_chamber.target > temp_chamber.current; }
-        FORCE_INLINE static bool isCoolingChamber()     { return temp_chamber.target < temp_chamber.current; }
+        FORCE_INLINE static bool isHeatingChamber()     { return temp_chamber.target > temp_chamber.celsius; }
+        FORCE_INLINE static bool isCoolingChamber()     { return temp_chamber.target < temp_chamber.celsius; }
 
         static bool wait_for_chamber(const bool no_wait_for_cooling=true);
       #endif
     #endif // HAS_TEMP_CHAMBER
 
     #if WATCH_CHAMBER
       static void start_watching_chamber();
     #else
       static inline void start_watching_chamber() {}
     #endif

commit 8bca3fcf2c4be3ea707860ebb9a1bfa1c03e2d7e
Author: Luu Lac <45380455+shitcreek@users.noreply.github.com>
Date:   Sun Sep 8 02:20:18 2019 -0500

    Display chamber with HAS_TEMP_CHAMBER (#15194)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 662d1866d4..df2fcf1062 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -616,57 +616,42 @@ class Temperature {
         else if (temp_hotend[ee].target == 0)
           start_preheat_time(ee);
       #endif
       #if ENABLED(AUTO_POWER_CONTROL)
         powerManager.power_on();
       #endif
       temp_hotend[ee].target = _MIN(celsius, temp_range[ee].maxtemp - 15);
       start_watching_hotend(ee);
     }
 
-    #if WATCH_CHAMBER
-      static void start_watching_chamber();
-    #else
-      static inline void start_watching_chamber() {}
-    #endif
-
-    #if HAS_HEATED_CHAMBER
-      static void setTargetChamber(const int16_t celsius) {
-        temp_chamber.target =
-          #ifdef CHAMBER_MAXTEMP
-            _MIN(celsius, CHAMBER_MAXTEMP)
-          #else
-            celsius
-          #endif
-        ;
-        start_watching_chamber();
-      }
-    #endif // HAS_HEATED_CHAMBER
-
     FORCE_INLINE static bool isHeatingHotend(const uint8_t e) {
       E_UNUSED();
       return temp_hotend[HOTEND_INDEX].target > temp_hotend[HOTEND_INDEX].current;
     }
 
     FORCE_INLINE static bool isCoolingHotend(const uint8_t e) {
       E_UNUSED();
       return temp_hotend[HOTEND_INDEX].target < temp_hotend[HOTEND_INDEX].current;
     }
 
     #if HAS_TEMP_HOTEND
       static bool wait_for_hotend(const uint8_t target_extruder, const bool no_wait_for_cooling=true
         #if G26_CLICK_CAN_CANCEL
           , const bool click_to_cancel=false
         #endif
       );
     #endif
 
+    FORCE_INLINE static bool still_heating(const uint8_t e) {
+      return degTargetHotend(e) > TEMP_HYSTERESIS && ABS(degHotend(e) - degTargetHotend(e)) > TEMP_HYSTERESIS;
+    }
+
     #if HAS_HEATED_BED
 
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         FORCE_INLINE static int16_t rawBedTemp()  { return temp_bed.raw; }
       #endif
       FORCE_INLINE static float degBed()          { return temp_bed.current; }
       FORCE_INLINE static int16_t degTargetBed()  { return temp_bed.target; }
       FORCE_INLINE static bool isHeatingBed()     { return temp_bed.target > temp_bed.current; }
       FORCE_INLINE static bool isCoolingBed()     { return temp_bed.target < temp_bed.current; }
 
@@ -705,23 +690,38 @@ class Temperature {
       FORCE_INLINE static float degChamber()            { return temp_chamber.current; }
       #if HAS_HEATED_CHAMBER
         FORCE_INLINE static int16_t degTargetChamber()  { return temp_chamber.target; }
         FORCE_INLINE static bool isHeatingChamber()     { return temp_chamber.target > temp_chamber.current; }
         FORCE_INLINE static bool isCoolingChamber()     { return temp_chamber.target < temp_chamber.current; }
 
         static bool wait_for_chamber(const bool no_wait_for_cooling=true);
       #endif
     #endif // HAS_TEMP_CHAMBER
 
-    FORCE_INLINE static bool still_heating(const uint8_t e) {
-      return degTargetHotend(e) > TEMP_HYSTERESIS && ABS(degHotend(e) - degTargetHotend(e)) > TEMP_HYSTERESIS;
-    }
+    #if WATCH_CHAMBER
+      static void start_watching_chamber();
+    #else
+      static inline void start_watching_chamber() {}
+    #endif
+
+    #if HAS_HEATED_CHAMBER
+      static void setTargetChamber(const int16_t celsius) {
+        temp_chamber.target =
+          #ifdef CHAMBER_MAXTEMP
+            _MIN(celsius, CHAMBER_MAXTEMP)
+          #else
+            celsius
+          #endif
+        ;
+        start_watching_chamber();
+      }
+    #endif // HAS_HEATED_CHAMBER
 
     /**
      * The software PWM power for a heater
      */
     static int16_t getHeaterPower(const heater_ind_t heater);
 
     /**
      * Switch off all heaters, set all target temperatures to 0
      */
     static void disable_all_heaters();

commit dbee0e9c5424770b9abf8815c0cb8b49de7db77f
Author: Jamie <vector76@users.noreply.github.com>
Date:   Sun Sep 8 00:55:34 2019 -0500

    Analog joystick jogging control (#14648)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index b4db416f14..662d1866d4 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -85,58 +85,57 @@ typedef struct { float Kp, Ki, Kd, Kc; } PIDC_t;
 #endif
 
 #define PID_PARAM(F,H) _PID_##F(H)
 
 /**
  * States for ADC reading in the ISR
  */
 enum ADCSensorState : char {
   StartSampling,
   #if HAS_TEMP_ADC_0
-    PrepareTemp_0,
-    MeasureTemp_0,
+    PrepareTemp_0, MeasureTemp_0,
   #endif
   #if HAS_HEATED_BED
-    PrepareTemp_BED,
-    MeasureTemp_BED,
+    PrepareTemp_BED, MeasureTemp_BED,
   #endif
   #if HAS_TEMP_CHAMBER
-    PrepareTemp_CHAMBER,
-    MeasureTemp_CHAMBER,
+    PrepareTemp_CHAMBER, MeasureTemp_CHAMBER,
   #endif
   #if HAS_TEMP_ADC_1
-    PrepareTemp_1,
-    MeasureTemp_1,
+    PrepareTemp_1, MeasureTemp_1,
   #endif
   #if HAS_TEMP_ADC_2
-    PrepareTemp_2,
-    MeasureTemp_2,
+    PrepareTemp_2, MeasureTemp_2,
   #endif
   #if HAS_TEMP_ADC_3
-    PrepareTemp_3,
-    MeasureTemp_3,
+    PrepareTemp_3, MeasureTemp_3,
   #endif
   #if HAS_TEMP_ADC_4
-    PrepareTemp_4,
-    MeasureTemp_4,
+    PrepareTemp_4, MeasureTemp_4,
   #endif
   #if HAS_TEMP_ADC_5
-    PrepareTemp_5,
-    MeasureTemp_5,
+    PrepareTemp_5, MeasureTemp_5,
+  #endif
+  #if HAS_JOY_ADC_X
+    PrepareJoy_X, MeasureJoy_X,
+  #endif
+  #if HAS_JOY_ADC_Y
+    PrepareJoy_Y, MeasureJoy_Y,
+  #endif
+  #if HAS_JOY_ADC_Z
+    PrepareJoy_Z, MeasureJoy_Z,
   #endif
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
-    Prepare_FILWIDTH,
-    Measure_FILWIDTH,
+    Prepare_FILWIDTH, Measure_FILWIDTH,
   #endif
   #if HAS_ADC_BUTTONS
-    Prepare_ADC_KEY,
-    Measure_ADC_KEY,
+    Prepare_ADC_KEY, Measure_ADC_KEY,
   #endif
   SensorsReady, // Temperatures ready. Delay the next round of readings to let ADC pins settle.
   StartupDelay  // Startup, delay initial temp reading a tiny bit so the hardware can settle
 };
 
 // Minimum number of Temperature::ISR loops between sensor readings.
 // Multiplied by 16 (OVERSAMPLENR) to obtain the total time to
 // get all oversampled sensor readings
 #define MIN_ADC_ISR_LOOPS 10
 

commit 4cdf7a1b933fff5f6bf7a86a9c6f53fc16782737
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Sep 5 19:44:55 2019 -0500

    Add ADC helpers to temp_info_t

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 171dee373f..b4db416f14 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -153,20 +153,23 @@ enum ADCSensorState : char {
   #define unscalePID_d(d) ( float(d) * PID_dT )
 #endif
 
 #define G26_CLICK_CAN_CANCEL (HAS_LCD_MENU && ENABLED(G26_MESH_VALIDATION))
 
 // A temperature sensor
 typedef struct TempInfo {
   uint16_t acc;
   int16_t raw;
   float current;
+  inline void reset() { acc = 0; }
+  inline void sample(const uint16_t s) { acc += s; }
+  inline void update() { raw = acc; }
 } temp_info_t;
 
 // A PWM heater with temperature sensor
 typedef struct HeaterInfo : public TempInfo {
   int16_t target;
   uint8_t soft_pwm_amount;
 } heater_info_t;
 
 // A heater with PID stabilization
 template<typename T>

commit 77f637763cf89a12515c3c29337466ed7d6557cf
Author: Tim Moore <tim@youngmoores.com>
Date:   Tue Aug 6 21:25:47 2019 -0700

    Overlord configs. Fix buzzer, redundant temp. (#14833)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index becec0770d..171dee373f 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -261,21 +261,25 @@ typedef struct { int16_t raw_min, raw_max, mintemp, maxtemp; } temp_range_t;
   } user_thermistor_t;
 
 #endif
 
 class Temperature {
 
   public:
 
     static volatile bool in_temp_isr;
 
-    static hotend_info_t temp_hotend[HOTENDS];
+    static hotend_info_t temp_hotend[HOTENDS
+      #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
+        + 1
+      #endif
+    ];
 
     #if HAS_HEATED_BED
       static bed_info_t temp_bed;
     #endif
 
     #if HAS_TEMP_CHAMBER
       static chamber_info_t temp_chamber;
     #endif
 
     #if ENABLED(AUTO_POWER_E_FANS)

commit 27c487bab744a22aeb580a0471591adba040bc68
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Wed Jul 17 02:12:39 2019 -0600

    Print progress enhancements (#14647)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 8c69e13169..becec0770d 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -778,21 +778,21 @@ class Temperature {
         static millis_t next_temp_report_ms;
         static void auto_report_temperatures(void);
         static inline void set_auto_report_interval(uint8_t v) {
           NOMORE(v, 60);
           auto_report_temp_interval = v;
           next_temp_report_ms = millis() + 1000UL * v;
         }
       #endif
     #endif
 
-    #if EITHER(ULTRA_LCD, EXTENSIBLE_UI)
+    #if HAS_DISPLAY
       static void set_heating_message(const uint8_t e);
     #endif
 
   private:
     static void set_current_temp_raw();
     static void updateTemperaturesFromRawValues();
 
     #define HAS_MAX6675 EITHER(HEATER_0_USES_MAX6675, HEATER_1_USES_MAX6675)
     #if HAS_MAX6675
       #if BOTH(HEATER_0_USES_MAX6675, HEATER_1_USES_MAX6675)

commit eaf1c0954eff9a8a6473a8853a47478a4a6cb73b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Jul 14 08:56:29 2019 -0500

    Update some precompiler tests

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index f19b1a4f17..8c69e13169 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -821,35 +821,37 @@ class Temperature {
     #endif
 
     #if HAS_HEATED_CHAMBER
       static float get_pid_output_chamber();
     #endif
 
     static void _temp_error(const heater_ind_t e, PGM_P const serial_msg, PGM_P const lcd_msg);
     static void min_temp_error(const heater_ind_t e);
     static void max_temp_error(const heater_ind_t e);
 
-    #if ENABLED(THERMAL_PROTECTION_HOTENDS) || HAS_THERMALLY_PROTECTED_BED || ENABLED(THERMAL_PROTECTION_CHAMBER)
+    #define HAS_THERMAL_PROTECTION (EITHER(THERMAL_PROTECTION_HOTENDS, THERMAL_PROTECTION_CHAMBER) || HAS_THERMALLY_PROTECTED_BED)
+
+    #if HAS_THERMAL_PROTECTION
 
       enum TRState : char { TRInactive, TRFirstHeating, TRStable, TRRunaway };
 
       typedef struct {
         millis_t timer = 0;
         TRState state = TRInactive;
       } tr_state_machine_t;
 
       #if ENABLED(THERMAL_PROTECTION_HOTENDS)
         static tr_state_machine_t tr_state_machine[HOTENDS];
       #endif
       #if HAS_THERMALLY_PROTECTED_BED
         static tr_state_machine_t tr_state_machine_bed;
       #endif
       #if ENABLED(THERMAL_PROTECTION_CHAMBER)
         static tr_state_machine_t tr_state_machine_chamber;
       #endif
 
       static void thermal_runaway_protection(tr_state_machine_t &state, const float &current, const float &target, const heater_ind_t heater_id, const uint16_t period_seconds, const uint16_t hysteresis_degc);
 
-    #endif // THERMAL_PROTECTION
+    #endif // HAS_THERMAL_PROTECTION
 };
 
 extern Temperature thermalManager;

commit 750a16ad385dca893d482cb51d8af2ac3f8a1da1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jul 5 18:01:21 2019 -0500

    Fix MIN/MAX function collision with macros

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 3ea172fe97..f19b1a4f17 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -133,21 +133,21 @@ enum ADCSensorState : char {
   #endif
   SensorsReady, // Temperatures ready. Delay the next round of readings to let ADC pins settle.
   StartupDelay  // Startup, delay initial temp reading a tiny bit so the hardware can settle
 };
 
 // Minimum number of Temperature::ISR loops between sensor readings.
 // Multiplied by 16 (OVERSAMPLENR) to obtain the total time to
 // get all oversampled sensor readings
 #define MIN_ADC_ISR_LOOPS 10
 
-#define ACTUAL_ADC_SAMPLES MAX(int(MIN_ADC_ISR_LOOPS), int(SensorsReady))
+#define ACTUAL_ADC_SAMPLES _MAX(int(MIN_ADC_ISR_LOOPS), int(SensorsReady))
 
 #if HAS_PID_HEATING
   #define PID_K2 (1-float(PID_K1))
   #define PID_dT ((OVERSAMPLENR * float(ACTUAL_ADC_SAMPLES)) / TEMP_TIMER_FREQUENCY)
 
   // Apply the scale factors to the PID values
   #define scalePID_i(i)   ( float(i) * PID_dT )
   #define unscalePID_i(i) ( float(i) / PID_dT )
   #define scalePID_d(d)   ( float(d) / PID_dT )
   #define unscalePID_d(d) ( float(d) * PID_dT )
@@ -489,21 +489,21 @@ class Temperature {
 
       #if ENABLED(EXTRA_FAN_SPEED)
         static uint8_t old_fan_speed[FAN_COUNT], new_fan_speed[FAN_COUNT];
         static void set_temp_fan_speed(const uint8_t fan, const uint16_t tmp_temp);
       #endif
 
       #if HAS_LCD_MENU
 
         static uint8_t lcd_tmpfan_speed[
           #if ENABLED(SINGLENOZZLE)
-            MAX(EXTRUDERS, FAN_COUNT)
+            _MAX(EXTRUDERS, FAN_COUNT)
           #else
             FAN_COUNT
           #endif
         ];
 
         static inline void lcd_setFanSpeed(const uint8_t target) { set_fan_speed(target, lcd_tmpfan_speed[target]); }
 
         #if HAS_FAN0
           FORCE_INLINE static void lcd_setFanSpeed0() { lcd_setFanSpeed(0); }
         #endif
@@ -606,35 +606,35 @@ class Temperature {
       const uint8_t ee = HOTEND_INDEX;
       #ifdef MILLISECONDS_PREHEAT_TIME
         if (celsius == 0)
           reset_preheat_time(ee);
         else if (temp_hotend[ee].target == 0)
           start_preheat_time(ee);
       #endif
       #if ENABLED(AUTO_POWER_CONTROL)
         powerManager.power_on();
       #endif
-      temp_hotend[ee].target = MIN(celsius, temp_range[ee].maxtemp - 15);
+      temp_hotend[ee].target = _MIN(celsius, temp_range[ee].maxtemp - 15);
       start_watching_hotend(ee);
     }
 
     #if WATCH_CHAMBER
       static void start_watching_chamber();
     #else
       static inline void start_watching_chamber() {}
     #endif
 
     #if HAS_HEATED_CHAMBER
       static void setTargetChamber(const int16_t celsius) {
         temp_chamber.target =
           #ifdef CHAMBER_MAXTEMP
-            MIN(celsius, CHAMBER_MAXTEMP)
+            _MIN(celsius, CHAMBER_MAXTEMP)
           #else
             celsius
           #endif
         ;
         start_watching_chamber();
       }
     #endif // HAS_HEATED_CHAMBER
 
     FORCE_INLINE static bool isHeatingHotend(const uint8_t e) {
       E_UNUSED();
@@ -669,21 +669,21 @@ class Temperature {
       #else
         static inline void start_watching_bed() {}
       #endif
 
       static void setTargetBed(const int16_t celsius) {
         #if ENABLED(AUTO_POWER_CONTROL)
           powerManager.power_on();
         #endif
         temp_bed.target =
           #ifdef BED_MAXTEMP
-            MIN(celsius, BED_MAXTEMP - 10)
+            _MIN(celsius, BED_MAXTEMP - 10)
           #else
             celsius
           #endif
         ;
         start_watching_bed();
       }
 
       static bool wait_for_bed(const bool no_wait_for_cooling=true
         #if G26_CLICK_CAN_CANCEL
           , const bool click_to_cancel=false

commit 720bc7c00b0eedf2e7601d5fc6e6ff61f9833562
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jul 2 08:39:55 2019 -0500

    Named indices for Temperature class (#14479)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index a4499ad0fa..3ea172fe97 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -38,20 +38,27 @@
 #endif
 
 #if HOTENDS <= 1
   #define HOTEND_INDEX  0
   #define E_UNUSED() UNUSED(e)
 #else
   #define HOTEND_INDEX  e
   #define E_UNUSED()
 #endif
 
+// Identifiers for other heaters
+typedef enum : int8_t {
+  INDEX_NONE = -4,
+  H_REDUNDANT, H_CHAMBER, H_BED,
+  H_E0, H_E1, H_E2, H_E3, H_E4, H_E5
+} heater_ind_t;
+
 // PID storage
 typedef struct { float Kp, Ki, Kd;     } PID_t;
 typedef struct { float Kp, Ki, Kd, Kc; } PIDC_t;
 #if ENABLED(PID_EXTRUSION_SCALING)
   typedef PIDC_t hotend_pid_t;
   #if LPQ_MAX_LEN > 255
     typedef uint16_t lpq_ptr_t;
   #else
     typedef uint8_t lpq_ptr_t;
   #endif
@@ -573,47 +580,48 @@ class Temperature {
         return temp_hotend[HOTEND_INDEX].raw;
       }
     #endif
 
     FORCE_INLINE static int16_t degTargetHotend(const uint8_t e) {
       E_UNUSED();
       return temp_hotend[HOTEND_INDEX].target;
     }
 
     #if WATCH_HOTENDS
-      static void start_watching_heater(const uint8_t e=0);
+      static void start_watching_hotend(const uint8_t e=0);
     #else
-      static inline void start_watching_heater(const uint8_t e=0) { UNUSED(e); }
+      static inline void start_watching_hotend(const uint8_t e=0) { UNUSED(e); }
     #endif
 
     #if HAS_LCD_MENU
-      static inline void start_watching_E0() { start_watching_heater(0); }
-      static inline void start_watching_E1() { start_watching_heater(1); }
-      static inline void start_watching_E2() { start_watching_heater(2); }
-      static inline void start_watching_E3() { start_watching_heater(3); }
-      static inline void start_watching_E4() { start_watching_heater(4); }
-      static inline void start_watching_E5() { start_watching_heater(5); }
+      static inline void start_watching_E0() { start_watching_hotend(0); }
+      static inline void start_watching_E1() { start_watching_hotend(1); }
+      static inline void start_watching_E2() { start_watching_hotend(2); }
+      static inline void start_watching_E3() { start_watching_hotend(3); }
+      static inline void start_watching_E4() { start_watching_hotend(4); }
+      static inline void start_watching_E5() { start_watching_hotend(5); }
     #endif
 
     static void setTargetHotend(const int16_t celsius, const uint8_t e) {
       E_UNUSED();
+      const uint8_t ee = HOTEND_INDEX;
       #ifdef MILLISECONDS_PREHEAT_TIME
         if (celsius == 0)
-          reset_preheat_time(HOTEND_INDEX);
-        else if (temp_hotend[HOTEND_INDEX].target == 0)
-          start_preheat_time(HOTEND_INDEX);
+          reset_preheat_time(ee);
+        else if (temp_hotend[ee].target == 0)
+          start_preheat_time(ee);
       #endif
       #if ENABLED(AUTO_POWER_CONTROL)
         powerManager.power_on();
       #endif
-      temp_hotend[HOTEND_INDEX].target = MIN(celsius, temp_range[HOTEND_INDEX].maxtemp - 15);
-      start_watching_heater(HOTEND_INDEX);
+      temp_hotend[ee].target = MIN(celsius, temp_range[ee].maxtemp - 15);
+      start_watching_hotend(ee);
     }
 
     #if WATCH_CHAMBER
       static void start_watching_chamber();
     #else
       static inline void start_watching_chamber() {}
     #endif
 
     #if HAS_HEATED_CHAMBER
       static void setTargetChamber(const int16_t celsius) {
@@ -698,32 +706,32 @@ class Temperature {
       #endif
     #endif // HAS_TEMP_CHAMBER
 
     FORCE_INLINE static bool still_heating(const uint8_t e) {
       return degTargetHotend(e) > TEMP_HYSTERESIS && ABS(degHotend(e) - degTargetHotend(e)) > TEMP_HYSTERESIS;
     }
 
     /**
      * The software PWM power for a heater
      */
-    static int16_t getHeaterPower(const int8_t heater);
+    static int16_t getHeaterPower(const heater_ind_t heater);
 
     /**
      * Switch off all heaters, set all target temperatures to 0
      */
     static void disable_all_heaters();
 
     /**
      * Perform auto-tuning for hotend or bed in response to M303
      */
     #if HAS_PID_HEATING
-      static void PID_autotune(const float &target, const int8_t hotend, const int8_t ncycles, const bool set_result=false);
+      static void PID_autotune(const float &target, const heater_ind_t hotend, const int8_t ncycles, const bool set_result=false);
 
       #if ENABLED(NO_FAN_SLOWING_IN_PID_TUNING)
         static bool adaptive_fan_slowing;
       #elif ENABLED(ADAPTIVE_FAN_SLOWING)
         static constexpr bool adaptive_fan_slowing = true;
       #endif
 
       /**
        * Update the temp manager when PID values change
        */
@@ -740,21 +748,21 @@ class Temperature {
     #if ENABLED(PROBING_HEATERS_OFF)
       static void pause(const bool p);
       FORCE_INLINE static bool is_paused() { return paused; }
     #endif
 
     #if HEATER_IDLE_HANDLER
 
       static void reset_heater_idle_timer(const uint8_t e) {
         E_UNUSED();
         hotend_idle[HOTEND_INDEX].reset();
-        start_watching_heater(HOTEND_INDEX);
+        start_watching_hotend(HOTEND_INDEX);
       }
 
       #if HAS_HEATED_BED
         static void reset_bed_idle_timer() {
           bed_idle.reset();
           start_watching_bed();
         }
       #endif
 
     #endif // HEATER_IDLE_HANDLER
@@ -799,49 +807,49 @@ class Temperature {
       #endif
       static int read_max6675(
         #if COUNT_6675 > 1
           const uint8_t hindex=0
         #endif
       );
     #endif
 
     static void checkExtruderAutoFans();
 
-    static float get_pid_output(const int8_t e);
+    static float get_pid_output_hotend(const uint8_t e);
 
     #if ENABLED(PIDTEMPBED)
       static float get_pid_output_bed();
     #endif
 
     #if HAS_HEATED_CHAMBER
       static float get_pid_output_chamber();
     #endif
 
-    static void _temp_error(const int8_t e, PGM_P const serial_msg, PGM_P const lcd_msg);
-    static void min_temp_error(const int8_t e);
-    static void max_temp_error(const int8_t e);
+    static void _temp_error(const heater_ind_t e, PGM_P const serial_msg, PGM_P const lcd_msg);
+    static void min_temp_error(const heater_ind_t e);
+    static void max_temp_error(const heater_ind_t e);
 
     #if ENABLED(THERMAL_PROTECTION_HOTENDS) || HAS_THERMALLY_PROTECTED_BED || ENABLED(THERMAL_PROTECTION_CHAMBER)
 
       enum TRState : char { TRInactive, TRFirstHeating, TRStable, TRRunaway };
 
       typedef struct {
         millis_t timer = 0;
         TRState state = TRInactive;
       } tr_state_machine_t;
 
       #if ENABLED(THERMAL_PROTECTION_HOTENDS)
         static tr_state_machine_t tr_state_machine[HOTENDS];
       #endif
       #if HAS_THERMALLY_PROTECTED_BED
         static tr_state_machine_t tr_state_machine_bed;
       #endif
       #if ENABLED(THERMAL_PROTECTION_CHAMBER)
         static tr_state_machine_t tr_state_machine_chamber;
       #endif
 
-      static void thermal_runaway_protection(tr_state_machine_t &state, const float &current, const float &target, const int8_t heater_id, const uint16_t period_seconds, const uint16_t hysteresis_degc);
+      static void thermal_runaway_protection(tr_state_machine_t &state, const float &current, const float &target, const heater_ind_t heater_id, const uint16_t period_seconds, const uint16_t hysteresis_degc);
 
     #endif // THERMAL_PROTECTION
 };
 
 extern Temperature thermalManager;

commit c9a8db33c34d69ea8d10893b76b30f2445c37977
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jun 28 21:24:31 2019 -0500

    Fix scaledFanSpeed

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 23da631c11..a4499ad0fa 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -465,25 +465,25 @@ class Temperature {
       #endif
 
       static constexpr inline uint8_t fanPercent(const uint8_t speed) { return ui8_to_percent(speed); }
 
       #if ENABLED(ADAPTIVE_FAN_SLOWING)
         static uint8_t fan_speed_scaler[FAN_COUNT];
       #else
         static constexpr uint8_t fan_speed_scaler[FAN_COUNT] = ARRAY_N(FAN_COUNT, 128, 128, 128, 128, 128, 128);
       #endif
 
-      static inline uint8_t scaledFanSpeed(const uint8_t target) {
+      static inline uint8_t scaledFanSpeed(const uint8_t target, const uint8_t fs) {
         return (fs * uint16_t(fan_speed_scaler[target])) >> 7;
       }
 
-      static inline uint8_t scaledFanSpeed(const uint8_t target, const uint8_t fs) {
+      static inline uint8_t scaledFanSpeed(const uint8_t target) {
         return scaledFanSpeed(target, fan_speed[target]);
       }
 
       #if ENABLED(EXTRA_FAN_SPEED)
         static uint8_t old_fan_speed[FAN_COUNT], new_fan_speed[FAN_COUNT];
         static void set_temp_fan_speed(const uint8_t fan, const uint16_t tmp_temp);
       #endif
 
       #if HAS_LCD_MENU
 

commit a8d68b7c8a5ed440b2d12aea077ad05cadbaadfd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jun 28 13:58:40 2019 -0500

    Common method for scaled fan speed

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 8a8300892f..23da631c11 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -465,22 +465,26 @@ class Temperature {
       #endif
 
       static constexpr inline uint8_t fanPercent(const uint8_t speed) { return ui8_to_percent(speed); }
 
       #if ENABLED(ADAPTIVE_FAN_SLOWING)
         static uint8_t fan_speed_scaler[FAN_COUNT];
       #else
         static constexpr uint8_t fan_speed_scaler[FAN_COUNT] = ARRAY_N(FAN_COUNT, 128, 128, 128, 128, 128, 128);
       #endif
 
-      static inline uint8_t lcd_fanSpeedActual(const uint8_t target) {
-        return (fan_speed[target] * uint16_t(fan_speed_scaler[target])) >> 7;
+      static inline uint8_t scaledFanSpeed(const uint8_t target) {
+        return (fs * uint16_t(fan_speed_scaler[target])) >> 7;
+      }
+
+      static inline uint8_t scaledFanSpeed(const uint8_t target, const uint8_t fs) {
+        return scaledFanSpeed(target, fan_speed[target]);
       }
 
       #if ENABLED(EXTRA_FAN_SPEED)
         static uint8_t old_fan_speed[FAN_COUNT], new_fan_speed[FAN_COUNT];
         static void set_temp_fan_speed(const uint8_t fan, const uint16_t tmp_temp);
       #endif
 
       #if HAS_LCD_MENU
 
         static uint8_t lcd_tmpfan_speed[

commit 93cd66ac1146603e8a9911fceb3c63f4351f4d8e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 23:57:50 2019 -0500

    Tweaky change from (C) to (c)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 1d1858ee9e..8a8300892f 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -1,16 +1,16 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

commit 81209f53102e53a0a00227eae5d2ea0ee3bdd255
Author: Tim Moore <tim@youngmoores.com>
Date:   Thu Jun 27 19:29:53 2019 -0700

    'M105 R' to report redundant temp sensor (#14324)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index ddcdd3909c..1d1858ee9e 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -749,21 +749,25 @@ class Temperature {
       #if HAS_HEATED_BED
         static void reset_bed_idle_timer() {
           bed_idle.reset();
           start_watching_bed();
         }
       #endif
 
     #endif // HEATER_IDLE_HANDLER
 
     #if HAS_TEMP_SENSOR
-      static void print_heater_states(const uint8_t target_extruder);
+      static void print_heater_states(const uint8_t target_extruder
+        #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
+          , const bool include_r=false
+        #endif
+      );
       #if ENABLED(AUTO_REPORT_TEMPERATURES)
         static uint8_t auto_report_temp_interval;
         static millis_t next_temp_report_ms;
         static void auto_report_temperatures(void);
         static inline void set_auto_report_interval(uint8_t v) {
           NOMORE(v, 60);
           auto_report_temp_interval = v;
           next_temp_report_ms = millis() + 1000UL * v;
         }
       #endif

commit bd494a6bd6dcdd3e467a3eb1d34e10def363742b
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Wed May 29 00:43:31 2019 +0200

    Update defines for patched temperature macros (#14161)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index fa5013bc56..ddcdd3909c 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -226,24 +226,24 @@ typedef struct { int16_t raw_min, raw_max, mintemp, maxtemp; } temp_range_t;
     #endif
     #if ENABLED(HEATER_3_USER_THERMISTOR)
       CTI_HOTEND_3,
     #endif
     #if ENABLED(HEATER_4_USER_THERMISTOR)
       CTI_HOTEND_4,
     #endif
     #if ENABLED(HEATER_5_USER_THERMISTOR)
       CTI_HOTEND_5,
     #endif
-    #if ENABLED(BED_USER_THERMISTOR)
+    #if ENABLED(HEATER_BED_USER_THERMISTOR)
       CTI_BED,
     #endif
-    #if ENABLED(CHAMBER_USER_THERMISTOR)
+    #if ENABLED(HEATER_CHAMBER_USER_THERMISTOR)
       CTI_CHAMBER,
     #endif
     USER_THERMISTORS
   };
 
   // User-defined thermistor
   typedef struct {
     bool pre_calc;     // true if pre-calculations update needed
     float sh_c_coeff,  // Steinhart-Hart C coefficient .. defaults to '0.0'
           sh_alpha,

commit a50436613834b183e5fccbf8f653af269d5d87dc
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Tue May 7 21:14:12 2019 +0200

    Fix probe fan compiling error (#13930)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 117286131d..fa5013bc56 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -452,22 +452,23 @@ class Temperature {
       static float analog_to_celsius_chamber(const int raw);
     #endif
 
     #if FAN_COUNT > 0
 
       static uint8_t fan_speed[FAN_COUNT];
       #define FANS_LOOP(I) LOOP_L_N(I, FAN_COUNT)
 
       static void set_fan_speed(const uint8_t target, const uint16_t speed);
 
-      #if ENABLED(PROBING_FANS_OFF)
+      #if EITHER(PROBING_FANS_OFF, ADVANCED_PAUSE_FANS_PAUSE)
         static bool fans_paused;
+        static uint8_t saved_fan_speed[FAN_COUNT];
       #endif
 
       static constexpr inline uint8_t fanPercent(const uint8_t speed) { return ui8_to_percent(speed); }
 
       #if ENABLED(ADAPTIVE_FAN_SLOWING)
         static uint8_t fan_speed_scaler[FAN_COUNT];
       #else
         static constexpr uint8_t fan_speed_scaler[FAN_COUNT] = ARRAY_N(FAN_COUNT, 128, 128, 128, 128, 128, 128);
       #endif
 

commit 23a8707ef1969be3db28251ccee2287e1ea7b9e4
Author: doggyfan <49303635+doggyfan@users.noreply.github.com>
Date:   Tue May 7 00:51:06 2019 +0100

    Configurable Thermistor (#13888)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 9a56a9ef23..117286131d 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -19,20 +19,21 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 #pragma once
 
 /**
  * temperature.h - temperature controller
  */
 
 #include "thermistor/thermistors.h"
+
 #include "../inc/MarlinConfig.h"
 
 #if ENABLED(AUTO_POWER_CONTROL)
   #include "../feature/power.h"
 #endif
 
 #ifndef SOFT_PWM_SCALE
   #define SOFT_PWM_SCALE 0
 #endif
 
@@ -200,20 +201,67 @@ typedef struct {
   millis_t next_ms;
   inline bool elapsed(const millis_t &ms) { return next_ms && ELAPSED(ms, next_ms); }
   inline bool elapsed() { return elapsed(millis()); }
 } heater_watch_t;
 
 // Temperature sensor read value ranges
 typedef struct { int16_t raw_min, raw_max; } raw_range_t;
 typedef struct { int16_t mintemp, maxtemp; } celsius_range_t;
 typedef struct { int16_t raw_min, raw_max, mintemp, maxtemp; } temp_range_t;
 
+#define THERMISTOR_ADC_RESOLUTION       1024           // 10-bit ADC .. shame to waste 12-bits of resolution on 32-bit
+#define THERMISTOR_ABS_ZERO_C           -273.15f       // bbbbrrrrr cold !
+#define THERMISTOR_RESISTANCE_NOMINAL_C 25.0f          // mmmmm comfortable
+
+#if HAS_USER_THERMISTORS
+
+  enum CustomThermistorIndex : uint8_t {
+    #if ENABLED(HEATER_0_USER_THERMISTOR)
+      CTI_HOTEND_0,
+    #endif
+    #if ENABLED(HEATER_1_USER_THERMISTOR)
+      CTI_HOTEND_1,
+    #endif
+    #if ENABLED(HEATER_2_USER_THERMISTOR)
+      CTI_HOTEND_2,
+    #endif
+    #if ENABLED(HEATER_3_USER_THERMISTOR)
+      CTI_HOTEND_3,
+    #endif
+    #if ENABLED(HEATER_4_USER_THERMISTOR)
+      CTI_HOTEND_4,
+    #endif
+    #if ENABLED(HEATER_5_USER_THERMISTOR)
+      CTI_HOTEND_5,
+    #endif
+    #if ENABLED(BED_USER_THERMISTOR)
+      CTI_BED,
+    #endif
+    #if ENABLED(CHAMBER_USER_THERMISTOR)
+      CTI_CHAMBER,
+    #endif
+    USER_THERMISTORS
+  };
+
+  // User-defined thermistor
+  typedef struct {
+    bool pre_calc;     // true if pre-calculations update needed
+    float sh_c_coeff,  // Steinhart-Hart C coefficient .. defaults to '0.0'
+          sh_alpha,
+          series_res,
+          res_25, res_25_recip,
+          res_25_log,
+          beta, beta_recip;
+  } user_thermistor_t;
+
+#endif
+
 class Temperature {
 
   public:
 
     static volatile bool in_temp_isr;
 
     static hotend_info_t temp_hotend[HOTENDS];
 
     #if HAS_HEATED_BED
       static bed_info_t temp_bed;
@@ -356,20 +404,52 @@ class Temperature {
      * Instance Methods
      */
 
     Temperature();
 
     void init();
 
     /**
      * Static (class) methods
      */
+
+    #if HAS_USER_THERMISTORS
+      static user_thermistor_t user_thermistor[USER_THERMISTORS];
+      static void log_user_thermistor(const uint8_t t_index, const bool eprom=false);
+      static void reset_user_thermistors();
+      static float user_thermistor_to_deg_c(const uint8_t t_index, const int raw);
+      static bool set_pull_up_res(int8_t t_index, float value) {
+        //if (!WITHIN(t_index, 0, USER_THERMISTORS - 1)) return false;
+        if (!WITHIN(value, 1, 1000000)) return false;
+        user_thermistor[t_index].series_res = value;
+        return true;
+      }
+      static bool set_res25(int8_t t_index, float value) {
+        if (!WITHIN(value, 1, 10000000)) return false;
+        user_thermistor[t_index].res_25 = value;
+        user_thermistor[t_index].pre_calc = true;
+        return true;
+      }
+      static bool set_beta(int8_t t_index, float value) {
+        if (!WITHIN(value, 1, 1000000)) return false;
+        user_thermistor[t_index].beta = value;
+        user_thermistor[t_index].pre_calc = true;
+        return true;
+      }
+      static bool set_sh_coeff(int8_t t_index, float value) {
+        if (!WITHIN(value, -0.01f, 0.01f)) return false;
+        user_thermistor[t_index].sh_c_coeff = value;
+        user_thermistor[t_index].pre_calc = true;
+        return true;
+      }
+    #endif
+
     static float analog_to_celsius_hotend(const int raw, const uint8_t e);
 
     #if HAS_HEATED_BED
       static float analog_to_celsius_bed(const int raw);
     #endif
     #if HAS_TEMP_CHAMBER
       static float analog_to_celsius_chamber(const int raw);
     #endif
 
     #if FAN_COUNT > 0

commit e2a77ed8813ebe33b75479bd43b9d1308da48b12
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Sun May 5 05:51:47 2019 +0200

    Bring chamber temp to completion (#13837)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index d8496c3730..9a56a9ef23 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -140,48 +140,20 @@ enum ADCSensorState : char {
 
   // Apply the scale factors to the PID values
   #define scalePID_i(i)   ( float(i) * PID_dT )
   #define unscalePID_i(i) ( float(i) / PID_dT )
   #define scalePID_d(d)   ( float(d) / PID_dT )
   #define unscalePID_d(d) ( float(d) * PID_dT )
 #endif
 
 #define G26_CLICK_CAN_CANCEL (HAS_LCD_MENU && ENABLED(G26_MESH_VALIDATION))
 
-enum TempIndex : uint8_t {
-  #if HOTENDS > 0
-    TEMP_E0,
-    #if HOTENDS > 1
-      TEMP_E1,
-      #if HOTENDS > 2
-        TEMP_E2,
-        #if HOTENDS > 3
-          TEMP_E3,
-          #if HOTENDS > 4
-            TEMP_E4,
-            #if HOTENDS > 5
-              TEMP_E5,
-            #endif
-          #endif
-        #endif
-      #endif
-    #endif
-  #endif
-  #if HAS_HEATED_BED
-    TEMP_BED,
-  #endif
-  #if HAS_HEATED_CHAMBER
-    TEMP_CHAMBER,
-  #endif
-  tempCOUNT
-};
-
 // A temperature sensor
 typedef struct TempInfo {
   uint16_t acc;
   int16_t raw;
   float current;
 } temp_info_t;
 
 // A PWM heater with temperature sensor
 typedef struct HeaterInfo : public TempInfo {
   int16_t target;
@@ -248,20 +220,24 @@ class Temperature {
     #endif
 
     #if HAS_TEMP_CHAMBER
       static chamber_info_t temp_chamber;
     #endif
 
     #if ENABLED(AUTO_POWER_E_FANS)
       static uint8_t autofan_speed[HOTENDS];
     #endif
 
+    #if ENABLED(AUTO_POWER_CHAMBER_FAN)
+      static uint8_t chamberfan_speed;
+    #endif
+
     #if ENABLED(FAN_SOFT_PWM)
       static uint8_t soft_pwm_amount_fan[FAN_COUNT],
                      soft_pwm_count_fan[FAN_COUNT];
     #endif
 
     #if ENABLED(PREVENT_COLD_EXTRUSION)
       static bool allow_cold_extrude;
       static int16_t extrude_min_temp;
       FORCE_INLINE static bool tooCold(const int16_t temp) { return allow_cold_extrude ? false : temp < extrude_min_temp; }
       FORCE_INLINE static bool tooColdToExtrude(const uint8_t e) {
@@ -547,34 +523,32 @@ class Temperature {
       temp_hotend[HOTEND_INDEX].target = MIN(celsius, temp_range[HOTEND_INDEX].maxtemp - 15);
       start_watching_heater(HOTEND_INDEX);
     }
 
     #if WATCH_CHAMBER
       static void start_watching_chamber();
     #else
       static inline void start_watching_chamber() {}
     #endif
 
-    #if HAS_TEMP_CHAMBER
+    #if HAS_HEATED_CHAMBER
       static void setTargetChamber(const int16_t celsius) {
-        #if HAS_HEATED_CHAMBER
-          temp_chamber.target =
-            #ifdef CHAMBER_MAXTEMP
-              MIN(celsius, CHAMBER_MAXTEMP)
-            #else
-              celsius
-            #endif
-          ;
-          start_watching_chamber();
-        #endif // HAS_HEATED_CHAMBER
+        temp_chamber.target =
+          #ifdef CHAMBER_MAXTEMP
+            MIN(celsius, CHAMBER_MAXTEMP)
+          #else
+            celsius
+          #endif
+        ;
+        start_watching_chamber();
       }
-    #endif // HAS_TEMP_CHAMBER
+    #endif // HAS_HEATED_CHAMBER
 
     FORCE_INLINE static bool isHeatingHotend(const uint8_t e) {
       E_UNUSED();
       return temp_hotend[HOTEND_INDEX].target > temp_hotend[HOTEND_INDEX].current;
     }
 
     FORCE_INLINE static bool isCoolingHotend(const uint8_t e) {
       E_UNUSED();
       return temp_hotend[HOTEND_INDEX].target < temp_hotend[HOTEND_INDEX].current;
     }
@@ -620,27 +594,29 @@ class Temperature {
       static bool wait_for_bed(const bool no_wait_for_cooling=true
         #if G26_CLICK_CAN_CANCEL
           , const bool click_to_cancel=false
         #endif
       );
 
     #endif // HAS_HEATED_BED
 
     #if HAS_TEMP_CHAMBER
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
-        FORCE_INLINE static int16_t rawChamberTemp() { return temp_chamber.raw; }
+        FORCE_INLINE static int16_t rawChamberTemp()    { return temp_chamber.raw; }
       #endif
-      FORCE_INLINE static float degChamber() { return temp_chamber.current; }
+      FORCE_INLINE static float degChamber()            { return temp_chamber.current; }
       #if HAS_HEATED_CHAMBER
+        FORCE_INLINE static int16_t degTargetChamber()  { return temp_chamber.target; }
         FORCE_INLINE static bool isHeatingChamber()     { return temp_chamber.target > temp_chamber.current; }
         FORCE_INLINE static bool isCoolingChamber()     { return temp_chamber.target < temp_chamber.current; }
-        FORCE_INLINE static int16_t degTargetChamber() {return temp_chamber.target; }
+
+        static bool wait_for_chamber(const bool no_wait_for_cooling=true);
       #endif
     #endif // HAS_TEMP_CHAMBER
 
     FORCE_INLINE static bool still_heating(const uint8_t e) {
       return degTargetHotend(e) > TEMP_HYSTERESIS && ABS(degHotend(e) - degTargetHotend(e)) > TEMP_HYSTERESIS;
     }
 
     /**
      * The software PWM power for a heater
      */
@@ -747,23 +723,20 @@ class Temperature {
       static float get_pid_output_bed();
     #endif
 
     #if HAS_HEATED_CHAMBER
       static float get_pid_output_chamber();
     #endif
 
     static void _temp_error(const int8_t e, PGM_P const serial_msg, PGM_P const lcd_msg);
     static void min_temp_error(const int8_t e);
     static void max_temp_error(const int8_t e);
-    #if HAS_TEMP_CHAMBER
-      static void chamber_temp_error(const bool max);
-    #endif
 
     #if ENABLED(THERMAL_PROTECTION_HOTENDS) || HAS_THERMALLY_PROTECTED_BED || ENABLED(THERMAL_PROTECTION_CHAMBER)
 
       enum TRState : char { TRInactive, TRFirstHeating, TRStable, TRRunaway };
 
       typedef struct {
         millis_t timer = 0;
         TRState state = TRInactive;
       } tr_state_machine_t;
 

commit 3fcab8dbf1f0746a6d3825a9ec099fedbd958943
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sat May 4 16:50:44 2019 -0400

    Option to disable fans during pause (#13820)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 3dadaf2b77..d8496c3730 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -441,21 +441,21 @@ class Temperature {
         #endif
         #if HAS_FAN1 || (ENABLED(SINGLENOZZLE) && EXTRUDERS > 1)
           FORCE_INLINE static void lcd_setFanSpeed1() { lcd_setFanSpeed(1); }
         #endif
         #if HAS_FAN2 || (ENABLED(SINGLENOZZLE) && EXTRUDERS > 2)
           FORCE_INLINE static void lcd_setFanSpeed2() { lcd_setFanSpeed(2); }
         #endif
 
       #endif // HAS_LCD_MENU
 
-      #if ENABLED(PROBING_FANS_OFF)
+      #if EITHER(PROBING_FANS_OFF, ADVANCED_PAUSE_FANS_PAUSE)
         void set_fans_paused(const bool p);
       #endif
 
     #endif // FAN_COUNT > 0
 
     static inline void zero_fan_speeds() {
       #if FAN_COUNT > 0
         FANS_LOOP(i) set_fan_speed(i, 0);
       #endif
     }

commit 2f32a6612d0155fd01d15497205bb63e68ae1e7a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat May 4 14:36:59 2019 -0500

    Clean up Temperature::set_fans_paused

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index b24f84fb58..3dadaf2b77 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -398,21 +398,20 @@ class Temperature {
 
     #if FAN_COUNT > 0
 
       static uint8_t fan_speed[FAN_COUNT];
       #define FANS_LOOP(I) LOOP_L_N(I, FAN_COUNT)
 
       static void set_fan_speed(const uint8_t target, const uint16_t speed);
 
       #if ENABLED(PROBING_FANS_OFF)
         static bool fans_paused;
-        static uint8_t paused_fan_speed[FAN_COUNT];
       #endif
 
       static constexpr inline uint8_t fanPercent(const uint8_t speed) { return ui8_to_percent(speed); }
 
       #if ENABLED(ADAPTIVE_FAN_SLOWING)
         static uint8_t fan_speed_scaler[FAN_COUNT];
       #else
         static constexpr uint8_t fan_speed_scaler[FAN_COUNT] = ARRAY_N(FAN_COUNT, 128, 128, 128, 128, 128, 128);
       #endif
 

commit 84273557f9231c445ee30ee89dbcc66bc9c10e59
Author: Stephan <stephan.veigl@gmail.com>
Date:   Fri Apr 12 22:38:10 2019 +0200

    Move and update heated chamber settings (#13671)
    
    Co-Authored-By: the-real-orca <stephan.veigl@gmail.com>

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index a8cfad34b3..b24f84fb58 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -199,30 +199,24 @@ struct PIDHeaterInfo : public HeaterInfo {
 #else
   typedef heater_info_t hotend_info_t;
 #endif
 #if HAS_HEATED_BED
   #if ENABLED(PIDTEMPBED)
     typedef struct PIDHeaterInfo<PID_t> bed_info_t;
   #else
     typedef heater_info_t bed_info_t;
   #endif
 #endif
-#if HAS_TEMP_CHAMBER
-  #if HAS_HEATED_CHAMBER
-    #if ENABLED(PIDTEMPCHAMBER)
-      typedef struct PIDHeaterInfo<PID_t> chamber_info_t;
-    #else
-      typedef heater_info_t chamber_info_t;
-    #endif
-  #else
-    typedef temp_info_t chamber_info_t;
-  #endif
+#if HAS_HEATED_CHAMBER
+  typedef heater_info_t chamber_info_t;
+#elif HAS_TEMP_CHAMBER
+  typedef temp_info_t chamber_info_t;
 #endif
 
 // Heater idle handling
 typedef struct {
   millis_t timeout_ms;
   bool timed_out;
   inline void update(const millis_t &ms) { if (!timed_out && timeout_ms && ELAPSED(ms, timeout_ms)) timed_out = true; }
   inline void start(const millis_t &ms) { timeout_ms = millis() + ms; timed_out = false; }
   inline void reset() { timeout_ms = 0; timed_out = false; }
   inline void expire() { start(0); }
@@ -332,23 +326,21 @@ class Temperature {
       #endif
       #ifdef BED_MAXTEMP
         static int16_t maxtemp_raw_BED;
       #endif
     #endif
 
     #if HAS_HEATED_CHAMBER
       #if WATCH_CHAMBER
         static heater_watch_t watch_chamber;
       #endif
-      #if DISABLED(PIDTEMPCHAMBER)
-        static millis_t next_chamber_check_ms;
-      #endif
+      static millis_t next_chamber_check_ms;
       #ifdef CHAMBER_MINTEMP
         static int16_t mintemp_raw_CHAMBER;
       #endif
       #ifdef CHAMBER_MAXTEMP
         static int16_t maxtemp_raw_CHAMBER;
       #endif
     #endif
 
     #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
       static uint8_t consecutive_low_temperature_error[HOTENDS];
@@ -646,21 +638,21 @@ class Temperature {
       #endif
     #endif // HAS_TEMP_CHAMBER
 
     FORCE_INLINE static bool still_heating(const uint8_t e) {
       return degTargetHotend(e) > TEMP_HYSTERESIS && ABS(degHotend(e) - degTargetHotend(e)) > TEMP_HYSTERESIS;
     }
 
     /**
      * The software PWM power for a heater
      */
-    static int getHeaterPower(const int heater);
+    static int16_t getHeaterPower(const int8_t heater);
 
     /**
      * Switch off all heaters, set all target temperatures to 0
      */
     static void disable_all_heaters();
 
     /**
      * Perform auto-tuning for hotend or bed in response to M303
      */
     #if HAS_PID_HEATING

commit 9cee81d47eea0c8700e265f10f103ca99499511f
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Sat Apr 6 18:04:34 2019 -0500

    Option to show babysteps total since G28 (#13580)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 6de0bba660..a8cfad34b3 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -259,24 +259,20 @@ class Temperature {
 
     #if ENABLED(AUTO_POWER_E_FANS)
       static uint8_t autofan_speed[HOTENDS];
     #endif
 
     #if ENABLED(FAN_SOFT_PWM)
       static uint8_t soft_pwm_amount_fan[FAN_COUNT],
                      soft_pwm_count_fan[FAN_COUNT];
     #endif
 
-    #if ENABLED(BABYSTEPPING)
-      static volatile int16_t babystepsTodo[3];
-    #endif
-
     #if ENABLED(PREVENT_COLD_EXTRUSION)
       static bool allow_cold_extrude;
       static int16_t extrude_min_temp;
       FORCE_INLINE static bool tooCold(const int16_t temp) { return allow_cold_extrude ? false : temp < extrude_min_temp; }
       FORCE_INLINE static bool tooColdToExtrude(const uint8_t e) {
         E_UNUSED();
         return tooCold(degHotend(HOTEND_INDEX));
       }
       FORCE_INLINE static bool targetTooColdToExtrude(const uint8_t e) {
         E_UNUSED();
@@ -682,24 +678,20 @@ class Temperature {
       #if ENABLED(PIDTEMP)
         FORCE_INLINE static void updatePID() {
           #if ENABLED(PID_EXTRUSION_SCALING)
             last_e_position = 0;
           #endif
         }
       #endif
 
     #endif
 
-    #if ENABLED(BABYSTEPPING)
-      static void babystep_axis(const AxisEnum axis, const int16_t distance);
-    #endif
-
     #if ENABLED(PROBING_HEATERS_OFF)
       static void pause(const bool p);
       FORCE_INLINE static bool is_paused() { return paused; }
     #endif
 
     #if HEATER_IDLE_HANDLER
 
       static void reset_heater_idle_timer(const uint8_t e) {
         E_UNUSED();
         hotend_idle[HOTEND_INDEX].reset();

commit 240ea1bbb330744a4cd67d39b7c3d50a689cc0a3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Apr 4 03:06:19 2019 -0500

    Split up games into separate files

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 2b53e5966d..6de0bba660 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -666,21 +666,21 @@ class Temperature {
 
     /**
      * Perform auto-tuning for hotend or bed in response to M303
      */
     #if HAS_PID_HEATING
       static void PID_autotune(const float &target, const int8_t hotend, const int8_t ncycles, const bool set_result=false);
 
       #if ENABLED(NO_FAN_SLOWING_IN_PID_TUNING)
         static bool adaptive_fan_slowing;
       #elif ENABLED(ADAPTIVE_FAN_SLOWING)
-        constexpr static bool adaptive_fan_slowing = true;
+        static constexpr bool adaptive_fan_slowing = true;
       #endif
 
       /**
        * Update the temp manager when PID values change
        */
       #if ENABLED(PIDTEMP)
         FORCE_INLINE static void updatePID() {
           #if ENABLED(PID_EXTRUSION_SCALING)
             last_e_position = 0;
           #endif

commit 2cfa9e900816dbb53ccafbd411fb7419e71e1e27
Author: Kajetan Rzepecki <kajetan.rzepecki+github@gmail.com>
Date:   Tue Apr 2 00:53:56 2019 +0200

    Fixed chamber-related compile error (#13552)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 01dafa1df0..2b53e5966d 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -565,21 +565,21 @@ class Temperature {
       static void start_watching_chamber();
     #else
       static inline void start_watching_chamber() {}
     #endif
 
     #if HAS_TEMP_CHAMBER
       static void setTargetChamber(const int16_t celsius) {
         #if HAS_HEATED_CHAMBER
           temp_chamber.target =
             #ifdef CHAMBER_MAXTEMP
-              min(celsius, CHAMBER_MAXTEMP)
+              MIN(celsius, CHAMBER_MAXTEMP)
             #else
               celsius
             #endif
           ;
           start_watching_chamber();
         #endif // HAS_HEATED_CHAMBER
       }
     #endif // HAS_TEMP_CHAMBER
 
     FORCE_INLINE static bool isHeatingHotend(const uint8_t e) {

commit 5679fae11efbc7e8b9de2f0e68dc9a879757ff88
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Fri Mar 29 13:07:43 2019 -0600

    UltraLCD enhancements (lower fan resolution, backlash menu) (#13519)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index ecb76765cc..01dafa1df0 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -413,21 +413,21 @@ class Temperature {
       static uint8_t fan_speed[FAN_COUNT];
       #define FANS_LOOP(I) LOOP_L_N(I, FAN_COUNT)
 
       static void set_fan_speed(const uint8_t target, const uint16_t speed);
 
       #if ENABLED(PROBING_FANS_OFF)
         static bool fans_paused;
         static uint8_t paused_fan_speed[FAN_COUNT];
       #endif
 
-      static constexpr inline uint8_t fanPercent(const uint8_t speed) { return (int(speed) * 100 + 127) / 255; }
+      static constexpr inline uint8_t fanPercent(const uint8_t speed) { return ui8_to_percent(speed); }
 
       #if ENABLED(ADAPTIVE_FAN_SLOWING)
         static uint8_t fan_speed_scaler[FAN_COUNT];
       #else
         static constexpr uint8_t fan_speed_scaler[FAN_COUNT] = ARRAY_N(FAN_COUNT, 128, 128, 128, 128, 128, 128);
       #endif
 
       static inline uint8_t lcd_fanSpeedActual(const uint8_t target) {
         return (fan_speed[target] * uint16_t(fan_speed_scaler[target])) >> 7;
       }

commit ffc2c2d7c5ced5e6e4cb33698d30a779f3bcfe66
Author: Chris Pepper <p3p@p3psoft.co.uk>
Date:   Tue Mar 26 06:03:23 2019 +0000

    Move FAST_PWM_FAN code to HALs (#13491)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 20a1718508..ecb76765cc 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -259,30 +259,20 @@ class Temperature {
 
     #if ENABLED(AUTO_POWER_E_FANS)
       static uint8_t autofan_speed[HOTENDS];
     #endif
 
     #if ENABLED(FAN_SOFT_PWM)
       static uint8_t soft_pwm_amount_fan[FAN_COUNT],
                      soft_pwm_count_fan[FAN_COUNT];
     #endif
 
-    /**
-     * set_pwm_duty (8-bit AVRs only)
-     *  Sets the PWM duty cycle of the provided pin to the provided value
-     *  Optionally allows inverting the duty cycle [default = false]
-     *  Optionally allows changing the maximum size of the provided value to enable finer PWM duty control [default = 255]
-     */
-    #if ENABLED(FAST_PWM_FAN)
-      static void set_pwm_duty(const pin_t pin, const uint16_t v, const uint16_t v_size=255, const bool invert=false);
-    #endif
-
     #if ENABLED(BABYSTEPPING)
       static volatile int16_t babystepsTodo[3];
     #endif
 
     #if ENABLED(PREVENT_COLD_EXTRUSION)
       static bool allow_cold_extrude;
       static int16_t extrude_min_temp;
       FORCE_INLINE static bool tooCold(const int16_t temp) { return allow_cold_extrude ? false : temp < extrude_min_temp; }
       FORCE_INLINE static bool tooColdToExtrude(const uint8_t e) {
         E_UNUSED();
@@ -737,52 +727,21 @@ class Temperature {
           next_temp_report_ms = millis() + 1000UL * v;
         }
       #endif
     #endif
 
     #if EITHER(ULTRA_LCD, EXTENSIBLE_UI)
       static void set_heating_message(const uint8_t e);
     #endif
 
   private:
-
-    /**
-     * (8-bit AVRs only)
-     *
-     * get_pwm_timer
-     *  Grabs timer information and registers of the provided pin
-     *  returns Timer struct containing this information
-     *  Used by set_pwm_frequency, set_pwm_duty
-     *
-     * set_pwm_frequency
-     *  Sets the frequency of the timer corresponding to the provided pin
-     *  as close as possible to the provided desired frequency. Internally
-     *  calculates the required waveform generation mode, prescaler and
-     *  resolution values required and sets the timer registers accordingly.
-     *  NOTE that the frequency is applied to all pins on the timer (Ex OC3A, OC3B and OC3B)
-     *  NOTE that there are limitations, particularly if using TIMER2. (see Configuration_adv.h -> FAST FAN PWM Settings)
-     */
-    #if ENABLED(FAST_PWM_FAN)
-      typedef struct Timer {
-          volatile uint8_t* TCCRnQ[3];  // max 3 TCCR registers per timer
-          volatile uint16_t* OCRnQ[3];  // max 3 OCR registers per timer
-          volatile uint16_t* ICRn;      // max 1 ICR register per timer
-          uint8_t n;                    // the timer number [0->5]
-          uint8_t q;                    // the timer output [0->2] (A->C)
-      } Timer;
-
-      static Timer get_pwm_timer(const pin_t pin);
-      static void set_pwm_frequency(const pin_t pin, int f_desired);
-    #endif
-
     static void set_current_temp_raw();
-
     static void updateTemperaturesFromRawValues();
 
     #define HAS_MAX6675 EITHER(HEATER_0_USES_MAX6675, HEATER_1_USES_MAX6675)
     #if HAS_MAX6675
       #if BOTH(HEATER_0_USES_MAX6675, HEATER_1_USES_MAX6675)
         #define COUNT_6675 2
       #else
         #define COUNT_6675 1
       #endif
       #if COUNT_6675 > 1

commit 49cf92dc36424cf828436f32e72263eca39a1cc3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 16 23:43:06 2019 -0500

    Extended condition macros (#13419)
    
    Allow `ENABLED`, `DISABLED`, `PIN_EXISTS`, and `BUTTON_EXISTS` to take multiple arguments. Also add:
    - Alias `ANY(...)` for `!DISABLED(...)`
    - Alias `ANY_PIN(...)` for `PIN_EXISTS(a) || PIN_EXISTS(b) ...`
    - Alias `EITHER(A,B)` for `ANY(...)`
    - Alias `ALL(...)` and `BOTH(A,B)` for `ENABLED(...)`
    - `NONE(...)` for `DISABLED(...)`

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 8bd5a59ed7..20a1718508 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -732,21 +732,21 @@ class Temperature {
         static millis_t next_temp_report_ms;
         static void auto_report_temperatures(void);
         static inline void set_auto_report_interval(uint8_t v) {
           NOMORE(v, 60);
           auto_report_temp_interval = v;
           next_temp_report_ms = millis() + 1000UL * v;
         }
       #endif
     #endif
 
-    #if ENABLED(ULTRA_LCD) || ENABLED(EXTENSIBLE_UI)
+    #if EITHER(ULTRA_LCD, EXTENSIBLE_UI)
       static void set_heating_message(const uint8_t e);
     #endif
 
   private:
 
     /**
      * (8-bit AVRs only)
      *
      * get_pwm_timer
      *  Grabs timer information and registers of the provided pin
@@ -771,23 +771,23 @@ class Temperature {
       } Timer;
 
       static Timer get_pwm_timer(const pin_t pin);
       static void set_pwm_frequency(const pin_t pin, int f_desired);
     #endif
 
     static void set_current_temp_raw();
 
     static void updateTemperaturesFromRawValues();
 
-    #define HAS_MAX6675 (ENABLED(HEATER_0_USES_MAX6675) || ENABLED(HEATER_1_USES_MAX6675))
+    #define HAS_MAX6675 EITHER(HEATER_0_USES_MAX6675, HEATER_1_USES_MAX6675)
     #if HAS_MAX6675
-      #if ENABLED(HEATER_0_USES_MAX6675) && ENABLED(HEATER_1_USES_MAX6675)
+      #if BOTH(HEATER_0_USES_MAX6675, HEATER_1_USES_MAX6675)
         #define COUNT_6675 2
       #else
         #define COUNT_6675 1
       #endif
       #if COUNT_6675 > 1
         #define READ_MAX6675(N) read_max6675(N)
       #else
         #define READ_MAX6675(N) read_max6675()
       #endif
       static int read_max6675(

commit e52bcc9408f7ff207140d6fe8c9155237c3ca21b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 11 16:32:34 2019 -0500

    Limit top bed temp to BED_MAXTEMP - 10
    
    The chances of a 10¬∞ overshoot is pretty minimal.

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 1bc0621e0c..8bd5a59ed7 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -625,21 +625,21 @@ class Temperature {
       #else
         static inline void start_watching_bed() {}
       #endif
 
       static void setTargetBed(const int16_t celsius) {
         #if ENABLED(AUTO_POWER_CONTROL)
           powerManager.power_on();
         #endif
         temp_bed.target =
           #ifdef BED_MAXTEMP
-            MIN(celsius, BED_MAXTEMP - 15)
+            MIN(celsius, BED_MAXTEMP - 10)
           #else
             celsius
           #endif
         ;
         start_watching_bed();
       }
 
       static bool wait_for_bed(const bool no_wait_for_cooling=true
         #if G26_CLICK_CAN_CANCEL
           , const bool click_to_cancel=false

commit 33a08fc6f76465c1e318a7a1046c65ceb661caed
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 10 08:27:41 2019 -0500

    Fix typos from temperature rework
    
    Followup to #12201

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 35a3c180ae..1bc0621e0c 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -645,24 +645,24 @@ class Temperature {
           , const bool click_to_cancel=false
         #endif
       );
 
     #endif // HAS_HEATED_BED
 
     #if HAS_TEMP_CHAMBER
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         FORCE_INLINE static int16_t rawChamberTemp() { return temp_chamber.raw; }
       #endif
-      FORCE_INLINE static float degChamber() { return temp_chambercurrent; }
+      FORCE_INLINE static float degChamber() { return temp_chamber.current; }
       #if HAS_HEATED_CHAMBER
-        FORCE_INLINE static bool isHeatingChamber()     { return temp_chamber.target > temp_chambercurrent; }
-        FORCE_INLINE static bool isCoolingChamber()     { return temp_chamber.target < temp_chambercurrent; }
+        FORCE_INLINE static bool isHeatingChamber()     { return temp_chamber.target > temp_chamber.current; }
+        FORCE_INLINE static bool isCoolingChamber()     { return temp_chamber.target < temp_chamber.current; }
         FORCE_INLINE static int16_t degTargetChamber() {return temp_chamber.target; }
       #endif
     #endif // HAS_TEMP_CHAMBER
 
     FORCE_INLINE static bool still_heating(const uint8_t e) {
       return degTargetHotend(e) > TEMP_HYSTERESIS && ABS(degHotend(e) - degTargetHotend(e)) > TEMP_HYSTERESIS;
     }
 
     /**
      * The software PWM power for a heater

commit dbead66988b138e67d0e8cc5901fa38672feb390
Author: Reece Kibble <reece.kibble@gmail.com>
Date:   Fri Mar 8 16:15:42 2019 +0800

    Allows user to set (almost) any PWM frequency (#12638)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index c900e434df..35a3c180ae 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -259,20 +259,30 @@ class Temperature {
 
     #if ENABLED(AUTO_POWER_E_FANS)
       static uint8_t autofan_speed[HOTENDS];
     #endif
 
     #if ENABLED(FAN_SOFT_PWM)
       static uint8_t soft_pwm_amount_fan[FAN_COUNT],
                      soft_pwm_count_fan[FAN_COUNT];
     #endif
 
+    /**
+     * set_pwm_duty (8-bit AVRs only)
+     *  Sets the PWM duty cycle of the provided pin to the provided value
+     *  Optionally allows inverting the duty cycle [default = false]
+     *  Optionally allows changing the maximum size of the provided value to enable finer PWM duty control [default = 255]
+     */
+    #if ENABLED(FAST_PWM_FAN)
+      static void set_pwm_duty(const pin_t pin, const uint16_t v, const uint16_t v_size=255, const bool invert=false);
+    #endif
+
     #if ENABLED(BABYSTEPPING)
       static volatile int16_t babystepsTodo[3];
     #endif
 
     #if ENABLED(PREVENT_COLD_EXTRUSION)
       static bool allow_cold_extrude;
       static int16_t extrude_min_temp;
       FORCE_INLINE static bool tooCold(const int16_t temp) { return allow_cold_extrude ? false : temp < extrude_min_temp; }
       FORCE_INLINE static bool tooColdToExtrude(const uint8_t e) {
         E_UNUSED();
@@ -728,22 +738,47 @@ class Temperature {
         }
       #endif
     #endif
 
     #if ENABLED(ULTRA_LCD) || ENABLED(EXTENSIBLE_UI)
       static void set_heating_message(const uint8_t e);
     #endif
 
   private:
 
+    /**
+     * (8-bit AVRs only)
+     *
+     * get_pwm_timer
+     *  Grabs timer information and registers of the provided pin
+     *  returns Timer struct containing this information
+     *  Used by set_pwm_frequency, set_pwm_duty
+     *
+     * set_pwm_frequency
+     *  Sets the frequency of the timer corresponding to the provided pin
+     *  as close as possible to the provided desired frequency. Internally
+     *  calculates the required waveform generation mode, prescaler and
+     *  resolution values required and sets the timer registers accordingly.
+     *  NOTE that the frequency is applied to all pins on the timer (Ex OC3A, OC3B and OC3B)
+     *  NOTE that there are limitations, particularly if using TIMER2. (see Configuration_adv.h -> FAST FAN PWM Settings)
+     */
     #if ENABLED(FAST_PWM_FAN)
-      static void setPwmFrequency(const pin_t pin, int val);
+      typedef struct Timer {
+          volatile uint8_t* TCCRnQ[3];  // max 3 TCCR registers per timer
+          volatile uint16_t* OCRnQ[3];  // max 3 OCR registers per timer
+          volatile uint16_t* ICRn;      // max 1 ICR register per timer
+          uint8_t n;                    // the timer number [0->5]
+          uint8_t q;                    // the timer output [0->2] (A->C)
+      } Timer;
+
+      static Timer get_pwm_timer(const pin_t pin);
+      static void set_pwm_frequency(const pin_t pin, int f_desired);
     #endif
 
     static void set_current_temp_raw();
 
     static void updateTemperaturesFromRawValues();
 
     #define HAS_MAX6675 (ENABLED(HEATER_0_USES_MAX6675) || ENABLED(HEATER_1_USES_MAX6675))
     #if HAS_MAX6675
       #if ENABLED(HEATER_0_USES_MAX6675) && ENABLED(HEATER_1_USES_MAX6675)
         #define COUNT_6675 2

commit 645ca7af7ac27af9d6690659dc71ff9867b34b6c
Author: 3dlabsio <shane@warnertci.com>
Date:   Thu Mar 7 00:09:39 2019 -0800

    M141 Heated Chamber, Temperature rework (#12201)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index fd0706e20e..c900e434df 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -29,43 +29,50 @@
 #include "../inc/MarlinConfig.h"
 
 #if ENABLED(AUTO_POWER_CONTROL)
   #include "../feature/power.h"
 #endif
 
 #ifndef SOFT_PWM_SCALE
   #define SOFT_PWM_SCALE 0
 #endif
 
-#if HOTENDS == 1
+#if HOTENDS <= 1
   #define HOTEND_INDEX  0
+  #define E_UNUSED() UNUSED(e)
 #else
   #define HOTEND_INDEX  e
+  #define E_UNUSED()
 #endif
 
 // PID storage
 typedef struct { float Kp, Ki, Kd;     } PID_t;
 typedef struct { float Kp, Ki, Kd, Kc; } PIDC_t;
 #if ENABLED(PID_EXTRUSION_SCALING)
   typedef PIDC_t hotend_pid_t;
+  #if LPQ_MAX_LEN > 255
+    typedef uint16_t lpq_ptr_t;
+  #else
+    typedef uint8_t lpq_ptr_t;
+  #endif
 #else
   typedef PID_t hotend_pid_t;
 #endif
 
 #define DUMMY_PID_VALUE 3000.0f
 
 #if ENABLED(PIDTEMP)
-  #define _PID_Kp(H) Temperature::pid[H].Kp
-  #define _PID_Ki(H) Temperature::pid[H].Ki
-  #define _PID_Kd(H) Temperature::pid[H].Kd
+  #define _PID_Kp(H) Temperature::temp_hotend[H].pid.Kp
+  #define _PID_Ki(H) Temperature::temp_hotend[H].pid.Ki
+  #define _PID_Kd(H) Temperature::temp_hotend[H].pid.Kd
   #if ENABLED(PID_EXTRUSION_SCALING)
-    #define _PID_Kc(H) Temperature::pid[H].Kc
+    #define _PID_Kc(H) Temperature::temp_hotend[H].pid.Kc
   #else
     #define _PID_Kc(H) 1
   #endif
 #else
   #define _PID_Kp(H) DUMMY_PID_VALUE
   #define _PID_Ki(H) DUMMY_PID_VALUE
   #define _PID_Kd(H) DUMMY_PID_VALUE
   #define _PID_Kc(H) 1
 #endif
 
@@ -73,43 +80,47 @@ typedef struct { float Kp, Ki, Kd, Kc; } PIDC_t;
 
 /**
  * States for ADC reading in the ISR
  */
 enum ADCSensorState : char {
   StartSampling,
   #if HAS_TEMP_ADC_0
     PrepareTemp_0,
     MeasureTemp_0,
   #endif
+  #if HAS_HEATED_BED
+    PrepareTemp_BED,
+    MeasureTemp_BED,
+  #endif
+  #if HAS_TEMP_CHAMBER
+    PrepareTemp_CHAMBER,
+    MeasureTemp_CHAMBER,
+  #endif
   #if HAS_TEMP_ADC_1
     PrepareTemp_1,
     MeasureTemp_1,
   #endif
   #if HAS_TEMP_ADC_2
     PrepareTemp_2,
     MeasureTemp_2,
   #endif
   #if HAS_TEMP_ADC_3
     PrepareTemp_3,
     MeasureTemp_3,
   #endif
   #if HAS_TEMP_ADC_4
     PrepareTemp_4,
     MeasureTemp_4,
   #endif
-  #if HAS_HEATED_BED
-    PrepareTemp_BED,
-    MeasureTemp_BED,
-  #endif
-  #if HAS_TEMP_CHAMBER
-    PrepareTemp_CHAMBER,
-    MeasureTemp_CHAMBER,
+  #if HAS_TEMP_ADC_5
+    PrepareTemp_5,
+    MeasureTemp_5,
   #endif
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     Prepare_FILWIDTH,
     Measure_FILWIDTH,
   #endif
   #if HAS_ADC_BUTTONS
     Prepare_ADC_KEY,
     Measure_ADC_KEY,
   #endif
   SensorsReady, // Temperatures ready. Delay the next round of readings to let ADC pins settle.
@@ -129,137 +140,225 @@ enum ADCSensorState : char {
 
   // Apply the scale factors to the PID values
   #define scalePID_i(i)   ( float(i) * PID_dT )
   #define unscalePID_i(i) ( float(i) / PID_dT )
   #define scalePID_d(d)   ( float(d) / PID_dT )
   #define unscalePID_d(d) ( float(d) * PID_dT )
 #endif
 
 #define G26_CLICK_CAN_CANCEL (HAS_LCD_MENU && ENABLED(G26_MESH_VALIDATION))
 
+enum TempIndex : uint8_t {
+  #if HOTENDS > 0
+    TEMP_E0,
+    #if HOTENDS > 1
+      TEMP_E1,
+      #if HOTENDS > 2
+        TEMP_E2,
+        #if HOTENDS > 3
+          TEMP_E3,
+          #if HOTENDS > 4
+            TEMP_E4,
+            #if HOTENDS > 5
+              TEMP_E5,
+            #endif
+          #endif
+        #endif
+      #endif
+    #endif
+  #endif
+  #if HAS_HEATED_BED
+    TEMP_BED,
+  #endif
+  #if HAS_HEATED_CHAMBER
+    TEMP_CHAMBER,
+  #endif
+  tempCOUNT
+};
+
+// A temperature sensor
+typedef struct TempInfo {
+  uint16_t acc;
+  int16_t raw;
+  float current;
+} temp_info_t;
+
+// A PWM heater with temperature sensor
+typedef struct HeaterInfo : public TempInfo {
+  int16_t target;
+  uint8_t soft_pwm_amount;
+} heater_info_t;
+
+// A heater with PID stabilization
+template<typename T>
+struct PIDHeaterInfo : public HeaterInfo {
+  T pid;  // Initialized by settings.load()
+};
+
+#if ENABLED(PIDTEMP)
+  typedef struct PIDHeaterInfo<hotend_pid_t> hotend_info_t;
+#else
+  typedef heater_info_t hotend_info_t;
+#endif
+#if HAS_HEATED_BED
+  #if ENABLED(PIDTEMPBED)
+    typedef struct PIDHeaterInfo<PID_t> bed_info_t;
+  #else
+    typedef heater_info_t bed_info_t;
+  #endif
+#endif
+#if HAS_TEMP_CHAMBER
+  #if HAS_HEATED_CHAMBER
+    #if ENABLED(PIDTEMPCHAMBER)
+      typedef struct PIDHeaterInfo<PID_t> chamber_info_t;
+    #else
+      typedef heater_info_t chamber_info_t;
+    #endif
+  #else
+    typedef temp_info_t chamber_info_t;
+  #endif
+#endif
+
+// Heater idle handling
+typedef struct {
+  millis_t timeout_ms;
+  bool timed_out;
+  inline void update(const millis_t &ms) { if (!timed_out && timeout_ms && ELAPSED(ms, timeout_ms)) timed_out = true; }
+  inline void start(const millis_t &ms) { timeout_ms = millis() + ms; timed_out = false; }
+  inline void reset() { timeout_ms = 0; timed_out = false; }
+  inline void expire() { start(0); }
+} heater_idle_t;
+
+// Heater watch handling
+typedef struct {
+  uint16_t target;
+  millis_t next_ms;
+  inline bool elapsed(const millis_t &ms) { return next_ms && ELAPSED(ms, next_ms); }
+  inline bool elapsed() { return elapsed(millis()); }
+} heater_watch_t;
+
+// Temperature sensor read value ranges
+typedef struct { int16_t raw_min, raw_max; } raw_range_t;
+typedef struct { int16_t mintemp, maxtemp; } celsius_range_t;
+typedef struct { int16_t raw_min, raw_max, mintemp, maxtemp; } temp_range_t;
+
 class Temperature {
 
   public:
 
     static volatile bool in_temp_isr;
 
-    static float current_temperature[HOTENDS];
-    static int16_t current_temperature_raw[HOTENDS],
-                   target_temperature[HOTENDS];
-    static uint8_t soft_pwm_amount[HOTENDS];
+    static hotend_info_t temp_hotend[HOTENDS];
+
+    #if HAS_HEATED_BED
+      static bed_info_t temp_bed;
+    #endif
+
+    #if HAS_TEMP_CHAMBER
+      static chamber_info_t temp_chamber;
+    #endif
 
     #if ENABLED(AUTO_POWER_E_FANS)
       static uint8_t autofan_speed[HOTENDS];
     #endif
 
     #if ENABLED(FAN_SOFT_PWM)
       static uint8_t soft_pwm_amount_fan[FAN_COUNT],
                      soft_pwm_count_fan[FAN_COUNT];
     #endif
 
-    #if ENABLED(PIDTEMP)
-      static hotend_pid_t pid[HOTENDS];
-    #endif
-
-    #if HAS_HEATED_BED
-      static float current_temperature_bed;
-      static int16_t current_temperature_bed_raw, target_temperature_bed;
-      static uint8_t soft_pwm_amount_bed;
-      #if ENABLED(PIDTEMPBED)
-        static PID_t bed_pid;
-      #endif
-    #endif
-
     #if ENABLED(BABYSTEPPING)
       static volatile int16_t babystepsTodo[3];
     #endif
 
     #if ENABLED(PREVENT_COLD_EXTRUSION)
       static bool allow_cold_extrude;
       static int16_t extrude_min_temp;
       FORCE_INLINE static bool tooCold(const int16_t temp) { return allow_cold_extrude ? false : temp < extrude_min_temp; }
       FORCE_INLINE static bool tooColdToExtrude(const uint8_t e) {
-        #if HOTENDS == 1
-          UNUSED(e);
-        #endif
+        E_UNUSED();
         return tooCold(degHotend(HOTEND_INDEX));
       }
       FORCE_INLINE static bool targetTooColdToExtrude(const uint8_t e) {
-        #if HOTENDS == 1
-          UNUSED(e);
-        #endif
+        E_UNUSED();
         return tooCold(degTargetHotend(HOTEND_INDEX));
       }
     #else
       FORCE_INLINE static bool tooColdToExtrude(const uint8_t e) { UNUSED(e); return false; }
       FORCE_INLINE static bool targetTooColdToExtrude(const uint8_t e) { UNUSED(e); return false; }
     #endif
 
     FORCE_INLINE static bool hotEnoughToExtrude(const uint8_t e) { return !tooColdToExtrude(e); }
     FORCE_INLINE static bool targetHotEnoughToExtrude(const uint8_t e) { return !targetTooColdToExtrude(e); }
 
+    #if HEATER_IDLE_HANDLER
+      static heater_idle_t hotend_idle[HOTENDS];
+      #if HAS_HEATED_BED
+        static heater_idle_t bed_idle;
+      #endif
+      #if HAS_HEATED_CHAMBER
+        static heater_idle_t chamber_idle;
+      #endif
+    #endif
+
   private:
 
     #if EARLY_WATCHDOG
       static bool inited;   // If temperature controller is running
     #endif
 
     static volatile bool temp_meas_ready;
-    static uint16_t raw_temp_value[MAX_EXTRUDERS];
 
     #if WATCH_HOTENDS
-      static uint16_t watch_target_temp[HOTENDS];
-      static millis_t watch_heater_next_ms[HOTENDS];
+      static heater_watch_t watch_hotend[HOTENDS];
     #endif
 
     #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
       static uint16_t redundant_temperature_raw;
       static float redundant_temperature;
     #endif
 
     #if ENABLED(PID_EXTRUSION_SCALING)
-      static long last_e_position;
-      static long lpq[LPQ_MAX_LEN];
-      static int lpq_ptr;
+      static int32_t last_e_position, lpq[LPQ_MAX_LEN];
+      static lpq_ptr_t lpq_ptr;
     #endif
 
-    // Init min and max temp with extreme values to prevent false errors during startup
-    static int16_t minttemp_raw[HOTENDS],
-                   maxttemp_raw[HOTENDS],
-                   minttemp[HOTENDS],
-                   maxttemp[HOTENDS];
+    static temp_range_t temp_range[HOTENDS];
 
     #if HAS_HEATED_BED
-      static uint16_t raw_temp_bed_value;
-      #if WATCH_THE_BED
-        static uint16_t watch_target_bed_temp;
-        static millis_t watch_bed_next_ms;
+      #if WATCH_BED
+        static heater_watch_t watch_bed;
       #endif
       #if DISABLED(PIDTEMPBED)
         static millis_t next_bed_check_ms;
       #endif
-      #if HEATER_IDLE_HANDLER
-        static millis_t bed_idle_timeout_ms;
-        static bool bed_idle_timeout_exceeded;
-      #endif
       #ifdef BED_MINTEMP
-        static int16_t bed_minttemp_raw;
+        static int16_t mintemp_raw_BED;
       #endif
       #ifdef BED_MAXTEMP
-        static int16_t bed_maxttemp_raw;
+        static int16_t maxtemp_raw_BED;
       #endif
     #endif
 
-    #if HAS_TEMP_CHAMBER
-      static uint16_t raw_temp_chamber_value;
-      static float current_temperature_chamber;
-      static int16_t current_temperature_chamber_raw;
+    #if HAS_HEATED_CHAMBER
+      #if WATCH_CHAMBER
+        static heater_watch_t watch_chamber;
+      #endif
+      #if DISABLED(PIDTEMPCHAMBER)
+        static millis_t next_chamber_check_ms;
+      #endif
+      #ifdef CHAMBER_MINTEMP
+        static int16_t mintemp_raw_CHAMBER;
+      #endif
+      #ifdef CHAMBER_MAXTEMP
+        static int16_t maxtemp_raw_CHAMBER;
+      #endif
     #endif
 
     #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
       static uint8_t consecutive_low_temperature_error[HOTENDS];
     #endif
 
     #ifdef MILLISECONDS_PREHEAT_TIME
       static millis_t preheat_end_time[HOTENDS];
     #endif
 
@@ -272,25 +371,20 @@ class Temperature {
     #endif
 
     #if ENABLED(FILAMENT_WIDTH_SENSOR)
       static uint16_t current_raw_filwidth; // Measured filament diameter - one extruder only
     #endif
 
     #if ENABLED(PROBING_HEATERS_OFF)
       static bool paused;
     #endif
 
-    #if HEATER_IDLE_HANDLER
-      static millis_t heater_idle_timeout_ms[HOTENDS];
-      static bool heater_idle_timeout_exceeded[HOTENDS];
-    #endif
-
   public:
     #if HAS_ADC_BUTTONS
       static uint32_t current_ADCKey_raw;
       static uint8_t ADCKey_count;
     #endif
 
     #if ENABLED(PID_EXTRUSION_SCALING)
       static int16_t lpq_len;
     #endif
 
@@ -304,21 +398,21 @@ class Temperature {
 
     /**
      * Static (class) methods
      */
     static float analog_to_celsius_hotend(const int raw, const uint8_t e);
 
     #if HAS_HEATED_BED
       static float analog_to_celsius_bed(const int raw);
     #endif
     #if HAS_TEMP_CHAMBER
-      static float analog_to_celsiusChamber(const int raw);
+      static float analog_to_celsius_chamber(const int raw);
     #endif
 
     #if FAN_COUNT > 0
 
       static uint8_t fan_speed[FAN_COUNT];
       #define FANS_LOOP(I) LOOP_L_N(I, FAN_COUNT)
 
       static void set_fan_speed(const uint8_t target, const uint16_t speed);
 
       #if ENABLED(PROBING_FANS_OFF)
@@ -388,163 +482,180 @@ class Temperature {
     /**
      * Call periodically to manage heaters
      */
     static void manage_heater() _O2; // Added _O2 to work around a compiler error
 
     /**
      * Preheating hotends
      */
     #ifdef MILLISECONDS_PREHEAT_TIME
       static bool is_preheating(const uint8_t e) {
-        #if HOTENDS == 1
-          UNUSED(e);
-        #endif
+        E_UNUSED();
         return preheat_end_time[HOTEND_INDEX] && PENDING(millis(), preheat_end_time[HOTEND_INDEX]);
       }
       static void start_preheat_time(const uint8_t e) {
-        #if HOTENDS == 1
-          UNUSED(e);
-        #endif
+        E_UNUSED();
         preheat_end_time[HOTEND_INDEX] = millis() + MILLISECONDS_PREHEAT_TIME;
       }
       static void reset_preheat_time(const uint8_t e) {
-        #if HOTENDS == 1
-          UNUSED(e);
-        #endif
+        E_UNUSED();
         preheat_end_time[HOTEND_INDEX] = 0;
       }
     #else
       #define is_preheating(n) (false)
     #endif
 
     #if ENABLED(FILAMENT_WIDTH_SENSOR)
       static float analog_to_mm_fil_width();         // Convert raw Filament Width to millimeters
       static int8_t widthFil_to_size_ratio(); // Convert Filament Width (mm) to an extrusion ratio
     #endif
 
 
     //high level conversion routines, for use outside of temperature.cpp
     //inline so that there is no performance decrease.
     //deg=degreeCelsius
 
     FORCE_INLINE static float degHotend(const uint8_t e) {
-      #if HOTENDS == 1
-        UNUSED(e);
-      #endif
-      return current_temperature[HOTEND_INDEX];
+      E_UNUSED();
+      return temp_hotend[HOTEND_INDEX].current;
     }
 
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       FORCE_INLINE static int16_t rawHotendTemp(const uint8_t e) {
-        #if HOTENDS == 1
-          UNUSED(e);
-        #endif
-        return current_temperature_raw[HOTEND_INDEX];
+        E_UNUSED();
+        return temp_hotend[HOTEND_INDEX].raw;
       }
     #endif
 
     FORCE_INLINE static int16_t degTargetHotend(const uint8_t e) {
-      #if HOTENDS == 1
-        UNUSED(e);
-      #endif
-      return target_temperature[HOTEND_INDEX];
+      E_UNUSED();
+      return temp_hotend[HOTEND_INDEX].target;
     }
 
     #if WATCH_HOTENDS
-      static void start_watching_heater(const uint8_t e = 0);
+      static void start_watching_heater(const uint8_t e=0);
+    #else
+      static inline void start_watching_heater(const uint8_t e=0) { UNUSED(e); }
+    #endif
+
+    #if HAS_LCD_MENU
+      static inline void start_watching_E0() { start_watching_heater(0); }
+      static inline void start_watching_E1() { start_watching_heater(1); }
+      static inline void start_watching_E2() { start_watching_heater(2); }
+      static inline void start_watching_E3() { start_watching_heater(3); }
+      static inline void start_watching_E4() { start_watching_heater(4); }
+      static inline void start_watching_E5() { start_watching_heater(5); }
     #endif
 
     static void setTargetHotend(const int16_t celsius, const uint8_t e) {
-      #if HOTENDS == 1
-        UNUSED(e);
-      #endif
+      E_UNUSED();
       #ifdef MILLISECONDS_PREHEAT_TIME
         if (celsius == 0)
           reset_preheat_time(HOTEND_INDEX);
-        else if (target_temperature[HOTEND_INDEX] == 0)
+        else if (temp_hotend[HOTEND_INDEX].target == 0)
           start_preheat_time(HOTEND_INDEX);
       #endif
       #if ENABLED(AUTO_POWER_CONTROL)
         powerManager.power_on();
       #endif
-      target_temperature[HOTEND_INDEX] = MIN(celsius, maxttemp[HOTEND_INDEX] - 15);
-      #if WATCH_HOTENDS
-        start_watching_heater(HOTEND_INDEX);
-      #endif
+      temp_hotend[HOTEND_INDEX].target = MIN(celsius, temp_range[HOTEND_INDEX].maxtemp - 15);
+      start_watching_heater(HOTEND_INDEX);
     }
 
+    #if WATCH_CHAMBER
+      static void start_watching_chamber();
+    #else
+      static inline void start_watching_chamber() {}
+    #endif
+
+    #if HAS_TEMP_CHAMBER
+      static void setTargetChamber(const int16_t celsius) {
+        #if HAS_HEATED_CHAMBER
+          temp_chamber.target =
+            #ifdef CHAMBER_MAXTEMP
+              min(celsius, CHAMBER_MAXTEMP)
+            #else
+              celsius
+            #endif
+          ;
+          start_watching_chamber();
+        #endif // HAS_HEATED_CHAMBER
+      }
+    #endif // HAS_TEMP_CHAMBER
+
     FORCE_INLINE static bool isHeatingHotend(const uint8_t e) {
-      #if HOTENDS == 1
-        UNUSED(e);
-      #endif
-      return target_temperature[HOTEND_INDEX] > current_temperature[HOTEND_INDEX];
+      E_UNUSED();
+      return temp_hotend[HOTEND_INDEX].target > temp_hotend[HOTEND_INDEX].current;
     }
 
     FORCE_INLINE static bool isCoolingHotend(const uint8_t e) {
-      #if HOTENDS == 1
-        UNUSED(e);
-      #endif
-      return target_temperature[HOTEND_INDEX] < current_temperature[HOTEND_INDEX];
+      E_UNUSED();
+      return temp_hotend[HOTEND_INDEX].target < temp_hotend[HOTEND_INDEX].current;
     }
 
     #if HAS_TEMP_HOTEND
       static bool wait_for_hotend(const uint8_t target_extruder, const bool no_wait_for_cooling=true
         #if G26_CLICK_CAN_CANCEL
           , const bool click_to_cancel=false
         #endif
       );
     #endif
 
     #if HAS_HEATED_BED
 
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
-        FORCE_INLINE static int16_t rawBedTemp()  { return current_temperature_bed_raw; }
+        FORCE_INLINE static int16_t rawBedTemp()  { return temp_bed.raw; }
+      #endif
+      FORCE_INLINE static float degBed()          { return temp_bed.current; }
+      FORCE_INLINE static int16_t degTargetBed()  { return temp_bed.target; }
+      FORCE_INLINE static bool isHeatingBed()     { return temp_bed.target > temp_bed.current; }
+      FORCE_INLINE static bool isCoolingBed()     { return temp_bed.target < temp_bed.current; }
+
+      #if WATCH_BED
+        static void start_watching_bed();
+      #else
+        static inline void start_watching_bed() {}
       #endif
-      FORCE_INLINE static float degBed()          { return current_temperature_bed; }
-      FORCE_INLINE static int16_t degTargetBed()  { return target_temperature_bed; }
-      FORCE_INLINE static bool isHeatingBed()     { return target_temperature_bed > current_temperature_bed; }
-      FORCE_INLINE static bool isCoolingBed()     { return target_temperature_bed < current_temperature_bed; }
 
       static void setTargetBed(const int16_t celsius) {
         #if ENABLED(AUTO_POWER_CONTROL)
           powerManager.power_on();
         #endif
-        target_temperature_bed =
+        temp_bed.target =
           #ifdef BED_MAXTEMP
             MIN(celsius, BED_MAXTEMP - 15)
           #else
             celsius
           #endif
         ;
-        #if WATCH_THE_BED
-          start_watching_bed();
-        #endif
+        start_watching_bed();
       }
 
-      #if WATCH_THE_BED
-        static void start_watching_bed();
-      #endif
-
       static bool wait_for_bed(const bool no_wait_for_cooling=true
         #if G26_CLICK_CAN_CANCEL
           , const bool click_to_cancel=false
         #endif
       );
 
     #endif // HAS_HEATED_BED
 
     #if HAS_TEMP_CHAMBER
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
-        FORCE_INLINE static int16_t rawChamberTemp() { return current_temperature_chamber_raw; }
+        FORCE_INLINE static int16_t rawChamberTemp() { return temp_chamber.raw; }
       #endif
-      FORCE_INLINE static float degChamber() { return current_temperature_chamber; }
-    #endif
+      FORCE_INLINE static float degChamber() { return temp_chambercurrent; }
+      #if HAS_HEATED_CHAMBER
+        FORCE_INLINE static bool isHeatingChamber()     { return temp_chamber.target > temp_chambercurrent; }
+        FORCE_INLINE static bool isCoolingChamber()     { return temp_chamber.target < temp_chambercurrent; }
+        FORCE_INLINE static int16_t degTargetChamber() {return temp_chamber.target; }
+      #endif
+    #endif // HAS_TEMP_CHAMBER
 
     FORCE_INLINE static bool still_heating(const uint8_t e) {
       return degTargetHotend(e) > TEMP_HYSTERESIS && ABS(degHotend(e) - degTargetHotend(e)) > TEMP_HYSTERESIS;
     }
 
     /**
      * The software PWM power for a heater
      */
     static int getHeaterPower(const int heater);
 
@@ -582,61 +693,31 @@ class Temperature {
       static void babystep_axis(const AxisEnum axis, const int16_t distance);
     #endif
 
     #if ENABLED(PROBING_HEATERS_OFF)
       static void pause(const bool p);
       FORCE_INLINE static bool is_paused() { return paused; }
     #endif
 
     #if HEATER_IDLE_HANDLER
 
-      static void start_heater_idle_timer(const uint8_t e, const millis_t timeout_ms) {
-        #if HOTENDS == 1
-          UNUSED(e);
-        #endif
-        heater_idle_timeout_ms[HOTEND_INDEX] = millis() + timeout_ms;
-        heater_idle_timeout_exceeded[HOTEND_INDEX] = false;
-      }
-
       static void reset_heater_idle_timer(const uint8_t e) {
-        #if HOTENDS == 1
-          UNUSED(e);
-        #endif
-        heater_idle_timeout_ms[HOTEND_INDEX] = 0;
-        heater_idle_timeout_exceeded[HOTEND_INDEX] = false;
-        #if WATCH_HOTENDS
-          start_watching_heater(HOTEND_INDEX);
-        #endif
-      }
-
-      FORCE_INLINE static bool is_heater_idle(const uint8_t e) {
-        #if HOTENDS == 1
-          UNUSED(e);
-        #endif
-        return heater_idle_timeout_exceeded[HOTEND_INDEX];
+        E_UNUSED();
+        hotend_idle[HOTEND_INDEX].reset();
+        start_watching_heater(HOTEND_INDEX);
       }
 
       #if HAS_HEATED_BED
-        static void start_bed_idle_timer(const millis_t timeout_ms) {
-          bed_idle_timeout_ms = millis() + timeout_ms;
-          bed_idle_timeout_exceeded = false;
-        }
-
         static void reset_bed_idle_timer() {
-          bed_idle_timeout_ms = 0;
-          bed_idle_timeout_exceeded = false;
-          #if WATCH_THE_BED
-            start_watching_bed();
-          #endif
+          bed_idle.reset();
+          start_watching_bed();
         }
-
-        FORCE_INLINE static bool is_bed_idle() { return bed_idle_timeout_exceeded; }
       #endif
 
     #endif // HEATER_IDLE_HANDLER
 
     #if HAS_TEMP_SENSOR
       static void print_heater_states(const uint8_t target_extruder);
       #if ENABLED(AUTO_REPORT_TEMPERATURES)
         static uint8_t auto_report_temp_interval;
         static millis_t next_temp_report_ms;
         static void auto_report_temperatures(void);
@@ -682,34 +763,46 @@ class Temperature {
     #endif
 
     static void checkExtruderAutoFans();
 
     static float get_pid_output(const int8_t e);
 
     #if ENABLED(PIDTEMPBED)
       static float get_pid_output_bed();
     #endif
 
+    #if HAS_HEATED_CHAMBER
+      static float get_pid_output_chamber();
+    #endif
+
     static void _temp_error(const int8_t e, PGM_P const serial_msg, PGM_P const lcd_msg);
     static void min_temp_error(const int8_t e);
     static void max_temp_error(const int8_t e);
+    #if HAS_TEMP_CHAMBER
+      static void chamber_temp_error(const bool max);
+    #endif
 
-    #if ENABLED(THERMAL_PROTECTION_HOTENDS) || HAS_THERMALLY_PROTECTED_BED
+    #if ENABLED(THERMAL_PROTECTION_HOTENDS) || HAS_THERMALLY_PROTECTED_BED || ENABLED(THERMAL_PROTECTION_CHAMBER)
 
       enum TRState : char { TRInactive, TRFirstHeating, TRStable, TRRunaway };
 
-      static void thermal_runaway_protection(TRState * const state, millis_t * const timer, const float &current, const float &target, const int8_t heater_id, const uint16_t period_seconds, const uint16_t hysteresis_degc);
+      typedef struct {
+        millis_t timer = 0;
+        TRState state = TRInactive;
+      } tr_state_machine_t;
 
       #if ENABLED(THERMAL_PROTECTION_HOTENDS)
-        static TRState thermal_runaway_state_machine[HOTENDS];
-        static millis_t thermal_runaway_timer[HOTENDS];
+        static tr_state_machine_t tr_state_machine[HOTENDS];
       #endif
-
       #if HAS_THERMALLY_PROTECTED_BED
-        static TRState thermal_runaway_bed_state_machine;
-        static millis_t thermal_runaway_bed_timer;
+        static tr_state_machine_t tr_state_machine_bed;
+      #endif
+      #if ENABLED(THERMAL_PROTECTION_CHAMBER)
+        static tr_state_machine_t tr_state_machine_chamber;
       #endif
 
+      static void thermal_runaway_protection(tr_state_machine_t &state, const float &current, const float &target, const int8_t heater_id, const uint16_t period_seconds, const uint16_t hysteresis_degc);
+
     #endif // THERMAL_PROTECTION
 };
 
 extern Temperature thermalManager;

commit fa236e9718cd2feb85a1986b8f56ad97cd2f4871
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Mar 1 19:29:48 2019 -0600

    General cleanup ahead of L64XX

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 0e1a132fb6..fd0706e20e 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -633,21 +633,21 @@ class Temperature {
       #endif
 
     #endif // HEATER_IDLE_HANDLER
 
     #if HAS_TEMP_SENSOR
       static void print_heater_states(const uint8_t target_extruder);
       #if ENABLED(AUTO_REPORT_TEMPERATURES)
         static uint8_t auto_report_temp_interval;
         static millis_t next_temp_report_ms;
         static void auto_report_temperatures(void);
-        FORCE_INLINE void set_auto_report_interval(uint8_t v) {
+        static inline void set_auto_report_interval(uint8_t v) {
           NOMORE(v, 60);
           auto_report_temp_interval = v;
           next_temp_report_ms = millis() + 1000UL * v;
         }
       #endif
     #endif
 
     #if ENABLED(ULTRA_LCD) || ENABLED(EXTENSIBLE_UI)
       static void set_heating_message(const uint8_t e);
     #endif

commit eb4bf93ea42c4c83335ca9cef21e78d0c752213f
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Wed Feb 27 05:38:56 2019 -0500

    Add more Babystep options (#13262)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index cd277a4149..0e1a132fb6 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -21,24 +21,20 @@
  */
 #pragma once
 
 /**
  * temperature.h - temperature controller
  */
 
 #include "thermistor/thermistors.h"
 #include "../inc/MarlinConfig.h"
 
-#if ENABLED(BABYSTEPPING)
-  extern uint8_t axis_known_position;
-#endif
-
 #if ENABLED(AUTO_POWER_CONTROL)
   #include "../feature/power.h"
 #endif
 
 #ifndef SOFT_PWM_SCALE
   #define SOFT_PWM_SCALE 0
 #endif
 
 #if HOTENDS == 1
   #define HOTEND_INDEX  0
@@ -213,26 +209,24 @@ class Temperature {
     #if WATCH_HOTENDS
       static uint16_t watch_target_temp[HOTENDS];
       static millis_t watch_heater_next_ms[HOTENDS];
     #endif
 
     #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
       static uint16_t redundant_temperature_raw;
       static float redundant_temperature;
     #endif
 
-    #if ENABLED(PIDTEMP)
-      #if ENABLED(PID_EXTRUSION_SCALING)
-        static long last_e_position;
-        static long lpq[LPQ_MAX_LEN];
-        static int lpq_ptr;
-      #endif
+    #if ENABLED(PID_EXTRUSION_SCALING)
+      static long last_e_position;
+      static long lpq[LPQ_MAX_LEN];
+      static int lpq_ptr;
     #endif
 
     // Init min and max temp with extreme values to prevent false errors during startup
     static int16_t minttemp_raw[HOTENDS],
                    maxttemp_raw[HOTENDS],
                    minttemp[HOTENDS],
                    maxttemp[HOTENDS];
 
     #if HAS_HEATED_BED
       static uint16_t raw_temp_bed_value;
@@ -578,53 +572,22 @@ class Temperature {
         FORCE_INLINE static void updatePID() {
           #if ENABLED(PID_EXTRUSION_SCALING)
             last_e_position = 0;
           #endif
         }
       #endif
 
     #endif
 
     #if ENABLED(BABYSTEPPING)
-
-      static void babystep_axis(const AxisEnum axis, const int16_t distance) {
-        if (TEST(axis_known_position, axis)) {
-          #if IS_CORE
-            #if ENABLED(BABYSTEP_XY)
-              switch (axis) {
-                case CORE_AXIS_1: // X on CoreXY and CoreXZ, Y on CoreYZ
-                  babystepsTodo[CORE_AXIS_1] += distance * 2;
-                  babystepsTodo[CORE_AXIS_2] += distance * 2;
-                  break;
-                case CORE_AXIS_2: // Y on CoreXY, Z on CoreXZ and CoreYZ
-                  babystepsTodo[CORE_AXIS_1] += CORESIGN(distance * 2);
-                  babystepsTodo[CORE_AXIS_2] -= CORESIGN(distance * 2);
-                  break;
-                case NORMAL_AXIS: // Z on CoreXY, Y on CoreXZ, X on CoreYZ
-                default:
-                  babystepsTodo[NORMAL_AXIS] += distance;
-                  break;
-              }
-            #elif CORE_IS_XZ || CORE_IS_YZ
-              // Only Z stepping needs to be handled here
-              babystepsTodo[CORE_AXIS_1] += CORESIGN(distance * 2);
-              babystepsTodo[CORE_AXIS_2] -= CORESIGN(distance * 2);
-            #else
-              babystepsTodo[Z_AXIS] += distance;
-            #endif
-          #else
-            babystepsTodo[axis] += distance;
-          #endif
-        }
-      }
-
-    #endif // BABYSTEPPING
+      static void babystep_axis(const AxisEnum axis, const int16_t distance);
+    #endif
 
     #if ENABLED(PROBING_HEATERS_OFF)
       static void pause(const bool p);
       FORCE_INLINE static bool is_paused() { return paused; }
     #endif
 
     #if HEATER_IDLE_HANDLER
 
       static void start_heater_idle_timer(const uint8_t e, const millis_t timeout_ms) {
         #if HOTENDS == 1

commit e15354e387cc825390fc4eaaf3ae4b784a8fd588
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Feb 23 22:53:01 2019 -0600

    Simplify serial port redirect (#13234)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index d376a70915..cd277a4149 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -665,25 +665,21 @@ class Temperature {
             start_watching_bed();
           #endif
         }
 
         FORCE_INLINE static bool is_bed_idle() { return bed_idle_timeout_exceeded; }
       #endif
 
     #endif // HEATER_IDLE_HANDLER
 
     #if HAS_TEMP_SENSOR
-      static void print_heater_states(const uint8_t target_extruder
-        #if NUM_SERIAL > 1
-          , const int8_t port = -1
-        #endif
-      );
+      static void print_heater_states(const uint8_t target_extruder);
       #if ENABLED(AUTO_REPORT_TEMPERATURES)
         static uint8_t auto_report_temp_interval;
         static millis_t next_temp_report_ms;
         static void auto_report_temperatures(void);
         FORCE_INLINE void set_auto_report_interval(uint8_t v) {
           NOMORE(v, 60);
           auto_report_temp_interval = v;
           next_temp_report_ms = millis() + 1000UL * v;
         }
       #endif

commit 02fec89a0dd671d08d8718ea3cab90177514c41d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Feb 22 21:00:36 2019 -0600

    Turn fans off in zero_fan_speeds
    
    Addressing #13231

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index acbc634d27..d376a70915 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -374,21 +374,21 @@ class Temperature {
       #endif // HAS_LCD_MENU
 
       #if ENABLED(PROBING_FANS_OFF)
         void set_fans_paused(const bool p);
       #endif
 
     #endif // FAN_COUNT > 0
 
     static inline void zero_fan_speeds() {
       #if FAN_COUNT > 0
-        FANS_LOOP(i) fan_speed[i] = 0;
+        FANS_LOOP(i) set_fan_speed(i, 0);
       #endif
     }
 
     /**
      * Called from the Temperature ISR
      */
     static void readings_ready();
     static void isr();
 
     /**

commit 0feeef26048883640b37ebe3994730f31ef6e922
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 15:06:53 2019 -0600

    Update copyright in headers

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index d68ce819e6..acbc634d27 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit 6fb4001b586467ed6965b944e2cf853c4afeac7b
Author: Nicolas G <ketchu13@hotmail.com>
Date:   Mon Feb 4 07:12:41 2019 +0100

    Add option to disable fan speed slowing in M303 (#13066)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 0d67163cad..d68ce819e6 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -558,20 +558,26 @@ class Temperature {
      * Switch off all heaters, set all target temperatures to 0
      */
     static void disable_all_heaters();
 
     /**
      * Perform auto-tuning for hotend or bed in response to M303
      */
     #if HAS_PID_HEATING
       static void PID_autotune(const float &target, const int8_t hotend, const int8_t ncycles, const bool set_result=false);
 
+      #if ENABLED(NO_FAN_SLOWING_IN_PID_TUNING)
+        static bool adaptive_fan_slowing;
+      #elif ENABLED(ADAPTIVE_FAN_SLOWING)
+        constexpr static bool adaptive_fan_slowing = true;
+      #endif
+
       /**
        * Update the temp manager when PID values change
        */
       #if ENABLED(PIDTEMP)
         FORCE_INLINE static void updatePID() {
           #if ENABLED(PID_EXTRUSION_SCALING)
             last_e_position = 0;
           #endif
         }
       #endif

commit acf266fe781d6d4bdad7beeb387b70c24cf2e213
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Sun Jan 20 01:47:29 2019 +0100

    Fix a compile warning, etc. (#12955)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 8468f059b2..0d67163cad 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -339,21 +339,21 @@ class Temperature {
       #else
         static constexpr uint8_t fan_speed_scaler[FAN_COUNT] = ARRAY_N(FAN_COUNT, 128, 128, 128, 128, 128, 128);
       #endif
 
       static inline uint8_t lcd_fanSpeedActual(const uint8_t target) {
         return (fan_speed[target] * uint16_t(fan_speed_scaler[target])) >> 7;
       }
 
       #if ENABLED(EXTRA_FAN_SPEED)
         static uint8_t old_fan_speed[FAN_COUNT], new_fan_speed[FAN_COUNT];
-        static void set_temp_fan_speed(const uint8_t fan, const int16_t tmp_temp);
+        static void set_temp_fan_speed(const uint8_t fan, const uint16_t tmp_temp);
       #endif
 
       #if HAS_LCD_MENU
 
         static uint8_t lcd_tmpfan_speed[
           #if ENABLED(SINGLENOZZLE)
             MAX(EXTRUDERS, FAN_COUNT)
           #else
             FAN_COUNT
           #endif

commit 082f6a27dece8d1883751d3f2af1c2b0f0b6802c
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sat Jan 12 01:41:48 2019 -0500

    ADAPTIVE_FAN_SLOWING extension to hotend thermal protection (#12853)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 31f8f2eb3e..8468f059b2 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -313,20 +313,85 @@ class Temperature {
      */
     static float analog_to_celsius_hotend(const int raw, const uint8_t e);
 
     #if HAS_HEATED_BED
       static float analog_to_celsius_bed(const int raw);
     #endif
     #if HAS_TEMP_CHAMBER
       static float analog_to_celsiusChamber(const int raw);
     #endif
 
+    #if FAN_COUNT > 0
+
+      static uint8_t fan_speed[FAN_COUNT];
+      #define FANS_LOOP(I) LOOP_L_N(I, FAN_COUNT)
+
+      static void set_fan_speed(const uint8_t target, const uint16_t speed);
+
+      #if ENABLED(PROBING_FANS_OFF)
+        static bool fans_paused;
+        static uint8_t paused_fan_speed[FAN_COUNT];
+      #endif
+
+      static constexpr inline uint8_t fanPercent(const uint8_t speed) { return (int(speed) * 100 + 127) / 255; }
+
+      #if ENABLED(ADAPTIVE_FAN_SLOWING)
+        static uint8_t fan_speed_scaler[FAN_COUNT];
+      #else
+        static constexpr uint8_t fan_speed_scaler[FAN_COUNT] = ARRAY_N(FAN_COUNT, 128, 128, 128, 128, 128, 128);
+      #endif
+
+      static inline uint8_t lcd_fanSpeedActual(const uint8_t target) {
+        return (fan_speed[target] * uint16_t(fan_speed_scaler[target])) >> 7;
+      }
+
+      #if ENABLED(EXTRA_FAN_SPEED)
+        static uint8_t old_fan_speed[FAN_COUNT], new_fan_speed[FAN_COUNT];
+        static void set_temp_fan_speed(const uint8_t fan, const int16_t tmp_temp);
+      #endif
+
+      #if HAS_LCD_MENU
+
+        static uint8_t lcd_tmpfan_speed[
+          #if ENABLED(SINGLENOZZLE)
+            MAX(EXTRUDERS, FAN_COUNT)
+          #else
+            FAN_COUNT
+          #endif
+        ];
+
+        static inline void lcd_setFanSpeed(const uint8_t target) { set_fan_speed(target, lcd_tmpfan_speed[target]); }
+
+        #if HAS_FAN0
+          FORCE_INLINE static void lcd_setFanSpeed0() { lcd_setFanSpeed(0); }
+        #endif
+        #if HAS_FAN1 || (ENABLED(SINGLENOZZLE) && EXTRUDERS > 1)
+          FORCE_INLINE static void lcd_setFanSpeed1() { lcd_setFanSpeed(1); }
+        #endif
+        #if HAS_FAN2 || (ENABLED(SINGLENOZZLE) && EXTRUDERS > 2)
+          FORCE_INLINE static void lcd_setFanSpeed2() { lcd_setFanSpeed(2); }
+        #endif
+
+      #endif // HAS_LCD_MENU
+
+      #if ENABLED(PROBING_FANS_OFF)
+        void set_fans_paused(const bool p);
+      #endif
+
+    #endif // FAN_COUNT > 0
+
+    static inline void zero_fan_speeds() {
+      #if FAN_COUNT > 0
+        FANS_LOOP(i) fan_speed[i] = 0;
+      #endif
+    }
+
     /**
      * Called from the Temperature ISR
      */
     static void readings_ready();
     static void isr();
 
     /**
      * Call periodically to manage heaters
      */
     static void manage_heater() _O2; // Added _O2 to work around a compiler error

commit 81e753064ac81292a4fc47ac5fa3f17686bdff7e
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Thu Jan 3 07:36:43 2019 -0700

    Fix ExtUI compile warnings and error (#12799)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 02a53a4e65..31f8f2eb3e 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -611,21 +611,21 @@ class Temperature {
         static millis_t next_temp_report_ms;
         static void auto_report_temperatures(void);
         FORCE_INLINE void set_auto_report_interval(uint8_t v) {
           NOMORE(v, 60);
           auto_report_temp_interval = v;
           next_temp_report_ms = millis() + 1000UL * v;
         }
       #endif
     #endif
 
-    #if ENABLED(ULTRA_LCD)
+    #if ENABLED(ULTRA_LCD) || ENABLED(EXTENSIBLE_UI)
       static void set_heating_message(const uint8_t e);
     #endif
 
   private:
 
     #if ENABLED(FAST_PWM_FAN)
       static void setPwmFrequency(const pin_t pin, int val);
     #endif
 
     static void set_current_temp_raw();

commit 594898aea757ef267ea2f841622f351d4f84b82a
Author: Roman Moravƒç√≠k <roman.moravcik@gmail.com>
Date:   Thu Dec 27 18:46:05 2018 +0100

    Limit hotend / bed temperature to maxtemp-15 (#12713)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 28ff8d26cd..02a53a4e65 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -400,21 +400,21 @@ class Temperature {
       #endif
       #ifdef MILLISECONDS_PREHEAT_TIME
         if (celsius == 0)
           reset_preheat_time(HOTEND_INDEX);
         else if (target_temperature[HOTEND_INDEX] == 0)
           start_preheat_time(HOTEND_INDEX);
       #endif
       #if ENABLED(AUTO_POWER_CONTROL)
         powerManager.power_on();
       #endif
-      target_temperature[HOTEND_INDEX] = MIN(celsius, maxttemp[HOTEND_INDEX]);
+      target_temperature[HOTEND_INDEX] = MIN(celsius, maxttemp[HOTEND_INDEX] - 15);
       #if WATCH_HOTENDS
         start_watching_heater(HOTEND_INDEX);
       #endif
     }
 
     FORCE_INLINE static bool isHeatingHotend(const uint8_t e) {
       #if HOTENDS == 1
         UNUSED(e);
       #endif
       return target_temperature[HOTEND_INDEX] > current_temperature[HOTEND_INDEX];
@@ -444,21 +444,21 @@ class Temperature {
       FORCE_INLINE static int16_t degTargetBed()  { return target_temperature_bed; }
       FORCE_INLINE static bool isHeatingBed()     { return target_temperature_bed > current_temperature_bed; }
       FORCE_INLINE static bool isCoolingBed()     { return target_temperature_bed < current_temperature_bed; }
 
       static void setTargetBed(const int16_t celsius) {
         #if ENABLED(AUTO_POWER_CONTROL)
           powerManager.power_on();
         #endif
         target_temperature_bed =
           #ifdef BED_MAXTEMP
-            MIN(celsius, BED_MAXTEMP)
+            MIN(celsius, BED_MAXTEMP - 15)
           #else
             celsius
           #endif
         ;
         #if WATCH_THE_BED
           start_watching_bed();
         #endif
       }
 
       #if WATCH_THE_BED

commit 98cf546771364f78b2ba0f8d6a7c50484731d9a6
Author: Roman Moravƒç√≠k <roman.moravcik@gmail.com>
Date:   Thu Dec 20 22:56:37 2018 +0100

    Limit set hotend temperature to maxtemp. (#12690)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index f9d21c3541..28ff8d26cd 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -400,21 +400,21 @@ class Temperature {
       #endif
       #ifdef MILLISECONDS_PREHEAT_TIME
         if (celsius == 0)
           reset_preheat_time(HOTEND_INDEX);
         else if (target_temperature[HOTEND_INDEX] == 0)
           start_preheat_time(HOTEND_INDEX);
       #endif
       #if ENABLED(AUTO_POWER_CONTROL)
         powerManager.power_on();
       #endif
-      target_temperature[HOTEND_INDEX] = celsius;
+      target_temperature[HOTEND_INDEX] = MIN(celsius, maxttemp[HOTEND_INDEX]);
       #if WATCH_HOTENDS
         start_watching_heater(HOTEND_INDEX);
       #endif
     }
 
     FORCE_INLINE static bool isHeatingHotend(const uint8_t e) {
       #if HOTENDS == 1
         UNUSED(e);
       #endif
       return target_temperature[HOTEND_INDEX] > current_temperature[HOTEND_INDEX];

commit 09d6db491a6263b1ec02cea74cd4f416cdb7e34f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Nov 25 18:05:18 2018 -0600

    Fix wait_for_bed compile error

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 28365913dc..f9d21c3541 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -458,21 +458,21 @@ class Temperature {
         ;
         #if WATCH_THE_BED
           start_watching_bed();
         #endif
       }
 
       #if WATCH_THE_BED
         static void start_watching_bed();
       #endif
 
-      static bool wait_for_bed(const bool no_wait_for_cooling
+      static bool wait_for_bed(const bool no_wait_for_cooling=true
         #if G26_CLICK_CAN_CANCEL
           , const bool click_to_cancel=false
         #endif
       );
 
     #endif // HAS_HEATED_BED
 
     #if HAS_TEMP_CHAMBER
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         FORCE_INLINE static int16_t rawChamberTemp() { return current_temperature_chamber_raw; }

commit 1f93d2bcf70f1cbe63ac9f21892543663723c8f3
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Mon Nov 19 03:39:49 2018 +0100

    Fix LCD compile error, etc. (#12472)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 0dc802768a..28365913dc 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -105,21 +105,21 @@ enum ADCSensorState : char {
     MeasureTemp_BED,
   #endif
   #if HAS_TEMP_CHAMBER
     PrepareTemp_CHAMBER,
     MeasureTemp_CHAMBER,
   #endif
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     Prepare_FILWIDTH,
     Measure_FILWIDTH,
   #endif
-  #if ENABLED(ADC_KEYPAD)
+  #if HAS_ADC_BUTTONS
     Prepare_ADC_KEY,
     Measure_ADC_KEY,
   #endif
   SensorsReady, // Temperatures ready. Delay the next round of readings to let ADC pins settle.
   StartupDelay  // Startup, delay initial temp reading a tiny bit so the hardware can settle
 };
 
 // Minimum number of Temperature::ISR loops between sensor readings.
 // Multiplied by 16 (OVERSAMPLENR) to obtain the total time to
 // get all oversampled sensor readings
@@ -284,21 +284,21 @@ class Temperature {
     #if ENABLED(PROBING_HEATERS_OFF)
       static bool paused;
     #endif
 
     #if HEATER_IDLE_HANDLER
       static millis_t heater_idle_timeout_ms[HOTENDS];
       static bool heater_idle_timeout_exceeded[HOTENDS];
     #endif
 
   public:
-    #if ENABLED(ADC_KEYPAD)
+    #if HAS_ADC_BUTTONS
       static uint32_t current_ADCKey_raw;
       static uint8_t ADCKey_count;
     #endif
 
     #if ENABLED(PID_EXTRUSION_SCALING)
       static int16_t lpq_len;
     #endif
 
     /**
      * Instance Methods

commit ca21ac6b9bac188560c4d316ecf1b257d3f0cec8
Author: Mateusz Krawczuk <mat.krawczuk@gmail.com>
Date:   Sat Nov 17 01:20:33 2018 +0100

    Support two MAX6675 thermocouples (#8686)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 963b219c53..0dc802768a 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -625,22 +625,37 @@ class Temperature {
   private:
 
     #if ENABLED(FAST_PWM_FAN)
       static void setPwmFrequency(const pin_t pin, int val);
     #endif
 
     static void set_current_temp_raw();
 
     static void updateTemperaturesFromRawValues();
 
-    #if ENABLED(HEATER_0_USES_MAX6675)
-      static int read_max6675();
+    #define HAS_MAX6675 (ENABLED(HEATER_0_USES_MAX6675) || ENABLED(HEATER_1_USES_MAX6675))
+    #if HAS_MAX6675
+      #if ENABLED(HEATER_0_USES_MAX6675) && ENABLED(HEATER_1_USES_MAX6675)
+        #define COUNT_6675 2
+      #else
+        #define COUNT_6675 1
+      #endif
+      #if COUNT_6675 > 1
+        #define READ_MAX6675(N) read_max6675(N)
+      #else
+        #define READ_MAX6675(N) read_max6675()
+      #endif
+      static int read_max6675(
+        #if COUNT_6675 > 1
+          const uint8_t hindex=0
+        #endif
+      );
     #endif
 
     static void checkExtruderAutoFans();
 
     static float get_pid_output(const int8_t e);
 
     #if ENABLED(PIDTEMPBED)
       static float get_pid_output_bed();
     #endif
 

commit d2bb53702a5b8bc03d6691230f252a21ca3ee375
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Nov 14 17:33:04 2018 -0600

    Optimize target_extruder, ignore T with mixing (#12432)
    
    * Optimize target_extruder, ignore T with mixing
    * Give G-code Tn parity with tool_change

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 9672707da9..963b219c53 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -594,23 +594,23 @@ class Temperature {
             start_watching_bed();
           #endif
         }
 
         FORCE_INLINE static bool is_bed_idle() { return bed_idle_timeout_exceeded; }
       #endif
 
     #endif // HEATER_IDLE_HANDLER
 
     #if HAS_TEMP_SENSOR
-      static void print_heaterstates(
+      static void print_heater_states(const uint8_t target_extruder
         #if NUM_SERIAL > 1
-          const int8_t port = -1
+          , const int8_t port = -1
         #endif
       );
       #if ENABLED(AUTO_REPORT_TEMPERATURES)
         static uint8_t auto_report_temp_interval;
         static millis_t next_temp_report_ms;
         static void auto_report_temperatures(void);
         FORCE_INLINE void set_auto_report_interval(uint8_t v) {
           NOMORE(v, 60);
           auto_report_temp_interval = v;
           next_temp_report_ms = millis() + 1000UL * v;

commit d82c350de741b6f20a3d4860c9cdc30dae20f746
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Nov 14 13:13:51 2018 -0600

    Miscellaneous LCD code renaming, reordering (#12430)
    
    * Move special characters to language.h
    * Apply some naming standards
    * Clean up menu item draw functions
    * Rename some Temperature methods
    * UI => ExtUI

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index c7031fd465..9672707da9 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -304,27 +304,27 @@ class Temperature {
      * Instance Methods
      */
 
     Temperature();
 
     void init();
 
     /**
      * Static (class) methods
      */
-    static float analog2temp(const int raw, const uint8_t e);
+    static float analog_to_celsius_hotend(const int raw, const uint8_t e);
 
     #if HAS_HEATED_BED
-      static float analog2tempBed(const int raw);
+      static float analog_to_celsius_bed(const int raw);
     #endif
     #if HAS_TEMP_CHAMBER
-      static float analog2tempChamber(const int raw);
+      static float analog_to_celsiusChamber(const int raw);
     #endif
 
     /**
      * Called from the Temperature ISR
      */
     static void readings_ready();
     static void isr();
 
     /**
      * Call periodically to manage heaters
@@ -351,21 +351,21 @@ class Temperature {
         #if HOTENDS == 1
           UNUSED(e);
         #endif
         preheat_end_time[HOTEND_INDEX] = 0;
       }
     #else
       #define is_preheating(n) (false)
     #endif
 
     #if ENABLED(FILAMENT_WIDTH_SENSOR)
-      static float analog2widthFil();         // Convert raw Filament Width to millimeters
+      static float analog_to_mm_fil_width();         // Convert raw Filament Width to millimeters
       static int8_t widthFil_to_size_ratio(); // Convert Filament Width (mm) to an extrusion ratio
     #endif
 
 
     //high level conversion routines, for use outside of temperature.cpp
     //inline so that there is no performance decrease.
     //deg=degreeCelsius
 
     FORCE_INLINE static float degHotend(const uint8_t e) {
       #if HOTENDS == 1

commit 6093df11dc91273764d0bf5607fa4314391793a2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Nov 10 18:07:38 2018 -0600

    Allow G26 to use the active extruder (#12387)
    
    * Make lcd_quick_feedback argument optional
    * Add click_to_cancel option to wait_for_hotend/bed
    * Have G26 use the active nozzle and wait_for_hotend/bed
    * Use wait_for_release in UBL G29
    * Add 'T' parameter to G26 for an initial tool-change

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 7c56105552..c7031fd465 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -131,20 +131,22 @@ enum ADCSensorState : char {
   #define PID_K2 (1-float(PID_K1))
   #define PID_dT ((OVERSAMPLENR * float(ACTUAL_ADC_SAMPLES)) / TEMP_TIMER_FREQUENCY)
 
   // Apply the scale factors to the PID values
   #define scalePID_i(i)   ( float(i) * PID_dT )
   #define unscalePID_i(i) ( float(i) / PID_dT )
   #define scalePID_d(d)   ( float(d) / PID_dT )
   #define unscalePID_d(d) ( float(d) * PID_dT )
 #endif
 
+#define G26_CLICK_CAN_CANCEL (HAS_LCD_MENU && ENABLED(G26_MESH_VALIDATION))
+
 class Temperature {
 
   public:
 
     static volatile bool in_temp_isr;
 
     static float current_temperature[HOTENDS];
     static int16_t current_temperature_raw[HOTENDS],
                    target_temperature[HOTENDS];
     static uint8_t soft_pwm_amount[HOTENDS];
@@ -419,21 +421,25 @@ class Temperature {
     }
 
     FORCE_INLINE static bool isCoolingHotend(const uint8_t e) {
       #if HOTENDS == 1
         UNUSED(e);
       #endif
       return target_temperature[HOTEND_INDEX] < current_temperature[HOTEND_INDEX];
     }
 
     #if HAS_TEMP_HOTEND
-      static bool wait_for_hotend(const uint8_t target_extruder, const bool no_wait_for_cooling=true);
+      static bool wait_for_hotend(const uint8_t target_extruder, const bool no_wait_for_cooling=true
+        #if G26_CLICK_CAN_CANCEL
+          , const bool click_to_cancel=false
+        #endif
+      );
     #endif
 
     #if HAS_HEATED_BED
 
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         FORCE_INLINE static int16_t rawBedTemp()  { return current_temperature_bed_raw; }
       #endif
       FORCE_INLINE static float degBed()          { return current_temperature_bed; }
       FORCE_INLINE static int16_t degTargetBed()  { return target_temperature_bed; }
       FORCE_INLINE static bool isHeatingBed()     { return target_temperature_bed > current_temperature_bed; }
@@ -452,21 +458,25 @@ class Temperature {
         ;
         #if WATCH_THE_BED
           start_watching_bed();
         #endif
       }
 
       #if WATCH_THE_BED
         static void start_watching_bed();
       #endif
 
-      static void wait_for_bed(const bool no_wait_for_cooling);
+      static bool wait_for_bed(const bool no_wait_for_cooling
+        #if G26_CLICK_CAN_CANCEL
+          , const bool click_to_cancel=false
+        #endif
+      );
 
     #endif // HAS_HEATED_BED
 
     #if HAS_TEMP_CHAMBER
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         FORCE_INLINE static int16_t rawChamberTemp() { return current_temperature_chamber_raw; }
       #endif
       FORCE_INLINE static float degChamber() { return current_temperature_chamber; }
     #endif
 

commit f5eab912ed6d336f2c37a688a0ec822ed3d42fcc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Nov 4 02:25:55 2018 -0600

    Apply #pragma once, misc cleanup (#12322)
    
    * Apply #pragma once in headers
    * Adjust some thermistors formatting
    * Misc cleanup and formatting

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 6baeacf24c..7c56105552 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -12,28 +12,26 @@
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
+#pragma once
 
 /**
  * temperature.h - temperature controller
  */
 
-#ifndef TEMPERATURE_H
-#define TEMPERATURE_H
-
 #include "thermistor/thermistors.h"
 #include "../inc/MarlinConfig.h"
 
 #if ENABLED(BABYSTEPPING)
   extern uint8_t axis_known_position;
 #endif
 
 #if ENABLED(AUTO_POWER_CONTROL)
   #include "../feature/power.h"
 #endif
@@ -653,12 +651,10 @@ class Temperature {
 
       #if HAS_THERMALLY_PROTECTED_BED
         static TRState thermal_runaway_bed_state_machine;
         static millis_t thermal_runaway_bed_timer;
       #endif
 
     #endif // THERMAL_PROTECTION
 };
 
 extern Temperature thermalManager;
-
-#endif // TEMPERATURE_H

commit d556dc18650e2185791834d7fe70b4acf45254bc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Oct 10 09:45:20 2018 -0500

    Fix and improve EEPROM storage (#12054)
    
    * Clean up Temperature PID
    * Improve EEPROM read/write/validate
    * Group `SINGLENOZZLE` saved settings
    * Group planner saved settings
    * Group filament change saved settings
    * Group skew saved settings
    * Group `FWRETRACT` saved settings

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 870345a342..6baeacf24c 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -41,20 +41,49 @@
 #ifndef SOFT_PWM_SCALE
   #define SOFT_PWM_SCALE 0
 #endif
 
 #if HOTENDS == 1
   #define HOTEND_INDEX  0
 #else
   #define HOTEND_INDEX  e
 #endif
 
+// PID storage
+typedef struct { float Kp, Ki, Kd;     } PID_t;
+typedef struct { float Kp, Ki, Kd, Kc; } PIDC_t;
+#if ENABLED(PID_EXTRUSION_SCALING)
+  typedef PIDC_t hotend_pid_t;
+#else
+  typedef PID_t hotend_pid_t;
+#endif
+
+#define DUMMY_PID_VALUE 3000.0f
+
+#if ENABLED(PIDTEMP)
+  #define _PID_Kp(H) Temperature::pid[H].Kp
+  #define _PID_Ki(H) Temperature::pid[H].Ki
+  #define _PID_Kd(H) Temperature::pid[H].Kd
+  #if ENABLED(PID_EXTRUSION_SCALING)
+    #define _PID_Kc(H) Temperature::pid[H].Kc
+  #else
+    #define _PID_Kc(H) 1
+  #endif
+#else
+  #define _PID_Kp(H) DUMMY_PID_VALUE
+  #define _PID_Ki(H) DUMMY_PID_VALUE
+  #define _PID_Kd(H) DUMMY_PID_VALUE
+  #define _PID_Kc(H) 1
+#endif
+
+#define PID_PARAM(F,H) _PID_##F(H)
+
 /**
  * States for ADC reading in the ISR
  */
 enum ADCSensorState : char {
   StartSampling,
   #if HAS_TEMP_ADC_0
     PrepareTemp_0,
     MeasureTemp_0,
   #endif
   #if HAS_TEMP_ADC_1
@@ -125,47 +154,29 @@ class Temperature {
     #if ENABLED(AUTO_POWER_E_FANS)
       static uint8_t autofan_speed[HOTENDS];
     #endif
 
     #if ENABLED(FAN_SOFT_PWM)
       static uint8_t soft_pwm_amount_fan[FAN_COUNT],
                      soft_pwm_count_fan[FAN_COUNT];
     #endif
 
     #if ENABLED(PIDTEMP)
-
-      #if ENABLED(PID_PARAMS_PER_HOTEND) && HOTENDS > 1
-
-        static float Kp[HOTENDS], Ki[HOTENDS], Kd[HOTENDS];
-        #if ENABLED(PID_EXTRUSION_SCALING)
-          static float Kc[HOTENDS];
-        #endif
-        #define PID_PARAM(param, h) Temperature::param[h]
-
-      #else
-
-        static float Kp, Ki, Kd;
-        #if ENABLED(PID_EXTRUSION_SCALING)
-          static float Kc;
-        #endif
-        #define PID_PARAM(param, h) Temperature::param
-
-      #endif // PID_PARAMS_PER_HOTEND
-
+      static hotend_pid_t pid[HOTENDS];
     #endif
 
     #if HAS_HEATED_BED
       static float current_temperature_bed;
       static int16_t current_temperature_bed_raw, target_temperature_bed;
       static uint8_t soft_pwm_amount_bed;
       #if ENABLED(PIDTEMPBED)
-        static float bedKp, bedKi, bedKd;
+        static PID_t bed_pid;
       #endif
     #endif
 
     #if ENABLED(BABYSTEPPING)
       static volatile int16_t babystepsTodo[3];
     #endif
 
     #if ENABLED(PREVENT_COLD_EXTRUSION)
       static bool allow_cold_extrude;
       static int16_t extrude_min_temp;
@@ -203,57 +214,40 @@ class Temperature {
       static uint16_t watch_target_temp[HOTENDS];
       static millis_t watch_heater_next_ms[HOTENDS];
     #endif
 
     #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
       static uint16_t redundant_temperature_raw;
       static float redundant_temperature;
     #endif
 
     #if ENABLED(PIDTEMP)
-      static float temp_iState[HOTENDS],
-                   temp_dState[HOTENDS],
-                   pTerm[HOTENDS],
-                   iTerm[HOTENDS],
-                   dTerm[HOTENDS];
-
       #if ENABLED(PID_EXTRUSION_SCALING)
-        static float cTerm[HOTENDS];
         static long last_e_position;
         static long lpq[LPQ_MAX_LEN];
         static int lpq_ptr;
       #endif
-
-      static float pid_error[HOTENDS];
-      static bool pid_reset[HOTENDS];
     #endif
 
     // Init min and max temp with extreme values to prevent false errors during startup
     static int16_t minttemp_raw[HOTENDS],
                    maxttemp_raw[HOTENDS],
                    minttemp[HOTENDS],
                    maxttemp[HOTENDS];
 
     #if HAS_HEATED_BED
       static uint16_t raw_temp_bed_value;
       #if WATCH_THE_BED
         static uint16_t watch_target_bed_temp;
         static millis_t watch_bed_next_ms;
       #endif
-      #if ENABLED(PIDTEMPBED)
-        static float temp_iState_bed,
-                     temp_dState_bed,
-                     pTerm_bed,
-                     iTerm_bed,
-                     dTerm_bed,
-                     pid_error_bed;
-      #else
+      #if DISABLED(PIDTEMPBED)
         static millis_t next_bed_check_ms;
       #endif
       #if HEATER_IDLE_HANDLER
         static millis_t bed_idle_timeout_ms;
         static bool bed_idle_timeout_exceeded;
       #endif
       #ifdef BED_MINTEMP
         static int16_t bed_minttemp_raw;
       #endif
       #ifdef BED_MAXTEMP

commit 74cd6cb4fc90e4c483e7a97a313c0257790f1375
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Oct 7 18:06:14 2018 -0400

    Single nozzle filament change (#11994)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 8f451be2b8..870345a342 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -609,20 +609,24 @@ class Temperature {
         static millis_t next_temp_report_ms;
         static void auto_report_temperatures(void);
         FORCE_INLINE void set_auto_report_interval(uint8_t v) {
           NOMORE(v, 60);
           auto_report_temp_interval = v;
           next_temp_report_ms = millis() + 1000UL * v;
         }
       #endif
     #endif
 
+    #if ENABLED(ULTRA_LCD)
+      static void set_heating_message(const uint8_t e);
+    #endif
+
   private:
 
     #if ENABLED(FAST_PWM_FAN)
       static void setPwmFrequency(const pin_t pin, int val);
     #endif
 
     static void set_current_temp_raw();
 
     static void updateTemperaturesFromRawValues();
 
@@ -652,16 +656,15 @@ class Temperature {
         static TRState thermal_runaway_state_machine[HOTENDS];
         static millis_t thermal_runaway_timer[HOTENDS];
       #endif
 
       #if HAS_THERMALLY_PROTECTED_BED
         static TRState thermal_runaway_bed_state_machine;
         static millis_t thermal_runaway_bed_timer;
       #endif
 
     #endif // THERMAL_PROTECTION
-
 };
 
 extern Temperature thermalManager;
 
 #endif // TEMPERATURE_H

commit d6b0fbd7715da67a2aaeeeafb0d4dc7c1563ef98
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Oct 7 15:34:41 2018 -0500

    Use uint8_t for all fan speeds (#12032)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 50b74fc662..8f451be2b8 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -116,21 +116,21 @@ class Temperature {
   public:
 
     static volatile bool in_temp_isr;
 
     static float current_temperature[HOTENDS];
     static int16_t current_temperature_raw[HOTENDS],
                    target_temperature[HOTENDS];
     static uint8_t soft_pwm_amount[HOTENDS];
 
     #if ENABLED(AUTO_POWER_E_FANS)
-      static int16_t autofan_speed[HOTENDS];
+      static uint8_t autofan_speed[HOTENDS];
     #endif
 
     #if ENABLED(FAN_SOFT_PWM)
       static uint8_t soft_pwm_amount_fan[FAN_COUNT],
                      soft_pwm_count_fan[FAN_COUNT];
     #endif
 
     #if ENABLED(PIDTEMP)
 
       #if ENABLED(PID_PARAMS_PER_HOTEND) && HOTENDS > 1

commit 65b8f3821b9527dcd72cb91651cd7499d17066aa
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Oct 6 19:29:22 2018 -0500

    Suppress temperature.h compile warning

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index ed37fcd140..50b74fc662 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -520,20 +520,21 @@ class Temperature {
               switch (axis) {
                 case CORE_AXIS_1: // X on CoreXY and CoreXZ, Y on CoreYZ
                   babystepsTodo[CORE_AXIS_1] += distance * 2;
                   babystepsTodo[CORE_AXIS_2] += distance * 2;
                   break;
                 case CORE_AXIS_2: // Y on CoreXY, Z on CoreXZ and CoreYZ
                   babystepsTodo[CORE_AXIS_1] += CORESIGN(distance * 2);
                   babystepsTodo[CORE_AXIS_2] -= CORESIGN(distance * 2);
                   break;
                 case NORMAL_AXIS: // Z on CoreXY, Y on CoreXZ, X on CoreYZ
+                default:
                   babystepsTodo[NORMAL_AXIS] += distance;
                   break;
               }
             #elif CORE_IS_XZ || CORE_IS_YZ
               // Only Z stepping needs to be handled here
               babystepsTodo[CORE_AXIS_1] += CORESIGN(distance * 2);
               babystepsTodo[CORE_AXIS_2] -= CORESIGN(distance * 2);
             #else
               babystepsTodo[Z_AXIS] += distance;
             #endif

commit 11ac75edcb34a2f90b50ca134ff40839f8c29199
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 30 23:44:33 2018 -0500

    Use PGM_P for PSTR pointers (#11977)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 53cdcdb5ea..ed37fcd140 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -630,21 +630,21 @@ class Temperature {
     #endif
 
     static void checkExtruderAutoFans();
 
     static float get_pid_output(const int8_t e);
 
     #if ENABLED(PIDTEMPBED)
       static float get_pid_output_bed();
     #endif
 
-    static void _temp_error(const int8_t e, const char * const serial_msg, const char * const lcd_msg);
+    static void _temp_error(const int8_t e, PGM_P const serial_msg, PGM_P const lcd_msg);
     static void min_temp_error(const int8_t e);
     static void max_temp_error(const int8_t e);
 
     #if ENABLED(THERMAL_PROTECTION_HOTENDS) || HAS_THERMALLY_PROTECTED_BED
 
       enum TRState : char { TRInactive, TRFirstHeating, TRStable, TRRunaway };
 
       static void thermal_runaway_protection(TRState * const state, millis_t * const timer, const float &current, const float &target, const int8_t heater_id, const uint16_t period_seconds, const uint16_t hysteresis_degc);
 
       #if ENABLED(THERMAL_PROTECTION_HOTENDS)

commit e4389f7d2308a8c3df2a961a511724513b519a4d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Sep 29 01:44:47 2018 -0500

    Standard methods to wait for heating (#11949)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index f91de03b57..53cdcdb5ea 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -426,21 +426,26 @@ class Temperature {
       return target_temperature[HOTEND_INDEX] > current_temperature[HOTEND_INDEX];
     }
 
     FORCE_INLINE static bool isCoolingHotend(const uint8_t e) {
       #if HOTENDS == 1
         UNUSED(e);
       #endif
       return target_temperature[HOTEND_INDEX] < current_temperature[HOTEND_INDEX];
     }
 
+    #if HAS_TEMP_HOTEND
+      static bool wait_for_hotend(const uint8_t target_extruder, const bool no_wait_for_cooling=true);
+    #endif
+
     #if HAS_HEATED_BED
+
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         FORCE_INLINE static int16_t rawBedTemp()  { return current_temperature_bed_raw; }
       #endif
       FORCE_INLINE static float degBed()          { return current_temperature_bed; }
       FORCE_INLINE static int16_t degTargetBed()  { return target_temperature_bed; }
       FORCE_INLINE static bool isHeatingBed()     { return target_temperature_bed > current_temperature_bed; }
       FORCE_INLINE static bool isCoolingBed()     { return target_temperature_bed < current_temperature_bed; }
 
       static void setTargetBed(const int16_t celsius) {
         #if ENABLED(AUTO_POWER_CONTROL)
@@ -454,30 +459,33 @@ class Temperature {
           #endif
         ;
         #if WATCH_THE_BED
           start_watching_bed();
         #endif
       }
 
       #if WATCH_THE_BED
         static void start_watching_bed();
       #endif
-    #endif
+
+      static void wait_for_bed(const bool no_wait_for_cooling);
+
+    #endif // HAS_HEATED_BED
 
     #if HAS_TEMP_CHAMBER
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         FORCE_INLINE static int16_t rawChamberTemp() { return current_temperature_chamber_raw; }
       #endif
       FORCE_INLINE static float degChamber() { return current_temperature_chamber; }
     #endif
 
-    FORCE_INLINE static bool wait_for_heating(const uint8_t e) {
+    FORCE_INLINE static bool still_heating(const uint8_t e) {
       return degTargetHotend(e) > TEMP_HYSTERESIS && ABS(degHotend(e) - degTargetHotend(e)) > TEMP_HYSTERESIS;
     }
 
     /**
      * The software PWM power for a heater
      */
     static int getHeaterPower(const int heater);
 
     /**
      * Switch off all heaters, set all target temperatures to 0

commit 1718eff54adefc7cc95851f28df0c7e02eae3a36
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Sep 13 01:35:55 2018 -0500

    Code changes supporting up to 6 extruders

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index e8b80f97b5..f91de03b57 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -156,21 +156,21 @@ class Temperature {
     #if HAS_HEATED_BED
       static float current_temperature_bed;
       static int16_t current_temperature_bed_raw, target_temperature_bed;
       static uint8_t soft_pwm_amount_bed;
       #if ENABLED(PIDTEMPBED)
         static float bedKp, bedKi, bedKd;
       #endif
     #endif
 
     #if ENABLED(BABYSTEPPING)
-      static volatile int babystepsTodo[3];
+      static volatile int16_t babystepsTodo[3];
     #endif
 
     #if ENABLED(PREVENT_COLD_EXTRUSION)
       static bool allow_cold_extrude;
       static int16_t extrude_min_temp;
       FORCE_INLINE static bool tooCold(const int16_t temp) { return allow_cold_extrude ? false : temp < extrude_min_temp; }
       FORCE_INLINE static bool tooColdToExtrude(const uint8_t e) {
         #if HOTENDS == 1
           UNUSED(e);
         #endif

commit 624986d42315cd685b29cad7cea3d1a9281c48df
Author: Andy Shaw <andy-git@gloomy-place.com>
Date:   Thu Jul 26 09:59:19 2018 +0100

    Ensure ADC conversion is complete before reading (#11336)
    
    The current Marlin implementation relies on a timer interrupt to start the ADC conversion and read it. However in some circumstances the interrupt can be delayed resulting in insufficient time being available for the ADC conversion. This results in a bad reading and false temperature fluctuations. These changes make sure that the conversion is complete (by checking the ADC hardware via the HAL) before reading a value.
    
    See: https://github.com/MarlinFirmware/Marlin/issues/11323

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 08c5e508a9..e8b80f97b5 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -45,20 +45,21 @@
 #if HOTENDS == 1
   #define HOTEND_INDEX  0
 #else
   #define HOTEND_INDEX  e
 #endif
 
 /**
  * States for ADC reading in the ISR
  */
 enum ADCSensorState : char {
+  StartSampling,
   #if HAS_TEMP_ADC_0
     PrepareTemp_0,
     MeasureTemp_0,
   #endif
   #if HAS_TEMP_ADC_1
     PrepareTemp_1,
     MeasureTemp_1,
   #endif
   #if HAS_TEMP_ADC_2
     PrepareTemp_2,
@@ -321,20 +322,21 @@ class Temperature {
     #if HAS_HEATED_BED
       static float analog2tempBed(const int raw);
     #endif
     #if HAS_TEMP_CHAMBER
       static float analog2tempChamber(const int raw);
     #endif
 
     /**
      * Called from the Temperature ISR
      */
+    static void readings_ready();
     static void isr();
 
     /**
      * Call periodically to manage heaters
      */
     static void manage_heater() _O2; // Added _O2 to work around a compiler error
 
     /**
      * Preheating hotends
      */

commit 1367df2875b4aff41e9c98824e3f7b56f4403e4d
Author: etagle <ejtagle@hotmail.com>
Date:   Sun Jul 1 17:20:28 2018 -0300

    Replace double with float, optimize calculation

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index bc9aa9a766..08c5e508a9 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -93,28 +93,28 @@ enum ADCSensorState : char {
 };
 
 // Minimum number of Temperature::ISR loops between sensor readings.
 // Multiplied by 16 (OVERSAMPLENR) to obtain the total time to
 // get all oversampled sensor readings
 #define MIN_ADC_ISR_LOOPS 10
 
 #define ACTUAL_ADC_SAMPLES MAX(int(MIN_ADC_ISR_LOOPS), int(SensorsReady))
 
 #if HAS_PID_HEATING
-  #define PID_K2 (1.0-PID_K1)
+  #define PID_K2 (1-float(PID_K1))
   #define PID_dT ((OVERSAMPLENR * float(ACTUAL_ADC_SAMPLES)) / TEMP_TIMER_FREQUENCY)
 
   // Apply the scale factors to the PID values
-  #define scalePID_i(i)   ( (i) * PID_dT )
-  #define unscalePID_i(i) ( (i) / PID_dT )
-  #define scalePID_d(d)   ( (d) / PID_dT )
-  #define unscalePID_d(d) ( (d) * PID_dT )
+  #define scalePID_i(i)   ( float(i) * PID_dT )
+  #define unscalePID_i(i) ( float(i) / PID_dT )
+  #define scalePID_d(d)   ( float(d) / PID_dT )
+  #define unscalePID_d(d) ( float(d) * PID_dT )
 #endif
 
 class Temperature {
 
   public:
 
     static volatile bool in_temp_isr;
 
     static float current_temperature[HOTENDS];
     static int16_t current_temperature_raw[HOTENDS],

commit f2c3b0d47646c5b56804f2474ae96c0884b783c8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jun 11 21:29:31 2018 -0500

    Use bit flags for homed/known

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 9be142cb82..bc9aa9a766 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -24,21 +24,21 @@
  * temperature.h - temperature controller
  */
 
 #ifndef TEMPERATURE_H
 #define TEMPERATURE_H
 
 #include "thermistor/thermistors.h"
 #include "../inc/MarlinConfig.h"
 
 #if ENABLED(BABYSTEPPING)
-  extern bool axis_known_position[XYZ];
+  extern uint8_t axis_known_position;
 #endif
 
 #if ENABLED(AUTO_POWER_CONTROL)
   #include "../feature/power.h"
 #endif
 
 #ifndef SOFT_PWM_SCALE
   #define SOFT_PWM_SCALE 0
 #endif
 
@@ -497,21 +497,21 @@ class Temperature {
             last_e_position = 0;
           #endif
         }
       #endif
 
     #endif
 
     #if ENABLED(BABYSTEPPING)
 
       static void babystep_axis(const AxisEnum axis, const int16_t distance) {
-        if (axis_known_position[axis]) {
+        if (TEST(axis_known_position, axis)) {
           #if IS_CORE
             #if ENABLED(BABYSTEP_XY)
               switch (axis) {
                 case CORE_AXIS_1: // X on CoreXY and CoreXZ, Y on CoreYZ
                   babystepsTodo[CORE_AXIS_1] += distance * 2;
                   babystepsTodo[CORE_AXIS_2] += distance * 2;
                   break;
                 case CORE_AXIS_2: // Y on CoreXY, Z on CoreXZ and CoreYZ
                   babystepsTodo[CORE_AXIS_1] += CORESIGN(distance * 2);
                   babystepsTodo[CORE_AXIS_2] -= CORESIGN(distance * 2);

commit 0ca9db705191d0b36dea513437ec518b0c0211a6
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 27 17:56:21 2018 -0500

    Correct HOTENDS for SWITCHING_EXTRUDER

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index f6637d03ea..9be142cb82 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -35,20 +35,26 @@
 #endif
 
 #if ENABLED(AUTO_POWER_CONTROL)
   #include "../feature/power.h"
 #endif
 
 #ifndef SOFT_PWM_SCALE
   #define SOFT_PWM_SCALE 0
 #endif
 
+#if HOTENDS == 1
+  #define HOTEND_INDEX  0
+#else
+  #define HOTEND_INDEX  e
+#endif
+
 /**
  * States for ADC reading in the ISR
  */
 enum ADCSensorState : char {
   #if HAS_TEMP_ADC_0
     PrepareTemp_0,
     MeasureTemp_0,
   #endif
   #if HAS_TEMP_ADC_1
     PrepareTemp_1,

commit 99ecdf59af907ebb8d2d847863614094bb576e3f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 13 01:10:34 2018 -0500

    Smarter MIN, MAX, ABS macros
    
    Use macros that explicitly avoid double-evaluation and can be used for any datatype, replacing `min`, `max`, `abs`, `fabs`, `labs`, and `FABS`.
    
    Co-Authored-By: ejtagle <ejtagle@hotmail.com>

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index b3e4e3cffd..f6637d03ea 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -84,21 +84,21 @@ enum ADCSensorState : char {
   #endif
   SensorsReady, // Temperatures ready. Delay the next round of readings to let ADC pins settle.
   StartupDelay  // Startup, delay initial temp reading a tiny bit so the hardware can settle
 };
 
 // Minimum number of Temperature::ISR loops between sensor readings.
 // Multiplied by 16 (OVERSAMPLENR) to obtain the total time to
 // get all oversampled sensor readings
 #define MIN_ADC_ISR_LOOPS 10
 
-#define ACTUAL_ADC_SAMPLES max(int(MIN_ADC_ISR_LOOPS), int(SensorsReady))
+#define ACTUAL_ADC_SAMPLES MAX(int(MIN_ADC_ISR_LOOPS), int(SensorsReady))
 
 #if HAS_PID_HEATING
   #define PID_K2 (1.0-PID_K1)
   #define PID_dT ((OVERSAMPLENR * float(ACTUAL_ADC_SAMPLES)) / TEMP_TIMER_FREQUENCY)
 
   // Apply the scale factors to the PID values
   #define scalePID_i(i)   ( (i) * PID_dT )
   #define unscalePID_i(i) ( (i) / PID_dT )
   #define scalePID_d(d)   ( (d) / PID_dT )
   #define unscalePID_d(d) ( (d) * PID_dT )
@@ -433,21 +433,21 @@ class Temperature {
       FORCE_INLINE static int16_t degTargetBed()  { return target_temperature_bed; }
       FORCE_INLINE static bool isHeatingBed()     { return target_temperature_bed > current_temperature_bed; }
       FORCE_INLINE static bool isCoolingBed()     { return target_temperature_bed < current_temperature_bed; }
 
       static void setTargetBed(const int16_t celsius) {
         #if ENABLED(AUTO_POWER_CONTROL)
           powerManager.power_on();
         #endif
         target_temperature_bed =
           #ifdef BED_MAXTEMP
-            min(celsius, BED_MAXTEMP)
+            MIN(celsius, BED_MAXTEMP)
           #else
             celsius
           #endif
         ;
         #if WATCH_THE_BED
           start_watching_bed();
         #endif
       }
 
       #if WATCH_THE_BED
@@ -456,21 +456,21 @@ class Temperature {
     #endif
 
     #if HAS_TEMP_CHAMBER
       #if ENABLED(SHOW_TEMP_ADC_VALUES)
         FORCE_INLINE static int16_t rawChamberTemp() { return current_temperature_chamber_raw; }
       #endif
       FORCE_INLINE static float degChamber() { return current_temperature_chamber; }
     #endif
 
     FORCE_INLINE static bool wait_for_heating(const uint8_t e) {
-      return degTargetHotend(e) > TEMP_HYSTERESIS && abs(degHotend(e) - degTargetHotend(e)) > TEMP_HYSTERESIS;
+      return degTargetHotend(e) > TEMP_HYSTERESIS && ABS(degHotend(e) - degTargetHotend(e)) > TEMP_HYSTERESIS;
     }
 
     /**
      * The software PWM power for a heater
      */
     static int getHeaterPower(const int heater);
 
     /**
      * Switch off all heaters, set all target temperatures to 0
      */

commit 8f8c6a9bc4f1c8b2d927e74339a48217d9b48ec7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 12 09:59:11 2018 -0500

    Move get_axis_position_mm to Planner (#10718)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index fd461df58b..b3e4e3cffd 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -31,24 +31,20 @@
 #include "../inc/MarlinConfig.h"
 
 #if ENABLED(BABYSTEPPING)
   extern bool axis_known_position[XYZ];
 #endif
 
 #if ENABLED(AUTO_POWER_CONTROL)
   #include "../feature/power.h"
 #endif
 
-#if ENABLED(PID_EXTRUSION_SCALING)
-  #include "stepper.h"
-#endif
-
 #ifndef SOFT_PWM_SCALE
   #define SOFT_PWM_SCALE 0
 #endif
 
 /**
  * States for ADC reading in the ISR
  */
 enum ADCSensorState : char {
   #if HAS_TEMP_ADC_0
     PrepareTemp_0,

commit 625035a9cefde67da3f9f5933a2ba9e636cef5bb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 12 02:13:40 2018 -0500

    Fix M301 access to lpq_len (#10714)
    
    Co-Authored-By: Zwaubel

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 3056c92b36..fd461df58b 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -292,20 +292,24 @@ class Temperature {
       static millis_t heater_idle_timeout_ms[HOTENDS];
       static bool heater_idle_timeout_exceeded[HOTENDS];
     #endif
 
   public:
     #if ENABLED(ADC_KEYPAD)
       static uint32_t current_ADCKey_raw;
       static uint8_t ADCKey_count;
     #endif
 
+    #if ENABLED(PID_EXTRUSION_SCALING)
+      static int16_t lpq_len;
+    #endif
+
     /**
      * Instance Methods
      */
 
     Temperature();
 
     void init();
 
     /**
      * Static (class) methods

commit 81b632c2558257c31b2f762e9bf8237c03638e07
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 1 19:33:41 2018 -0500

    Additional temp-oriented improvements

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index e9727c5125..3056c92b36 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -43,37 +43,37 @@
 #endif
 
 #ifndef SOFT_PWM_SCALE
   #define SOFT_PWM_SCALE 0
 #endif
 
 /**
  * States for ADC reading in the ISR
  */
 enum ADCSensorState : char {
-  #if HAS_TEMP_0
+  #if HAS_TEMP_ADC_0
     PrepareTemp_0,
     MeasureTemp_0,
   #endif
-  #if HAS_TEMP_1
+  #if HAS_TEMP_ADC_1
     PrepareTemp_1,
     MeasureTemp_1,
   #endif
-  #if HAS_TEMP_2
+  #if HAS_TEMP_ADC_2
     PrepareTemp_2,
     MeasureTemp_2,
   #endif
-  #if HAS_TEMP_3
+  #if HAS_TEMP_ADC_3
     PrepareTemp_3,
     MeasureTemp_3,
   #endif
-  #if HAS_TEMP_4
+  #if HAS_TEMP_ADC_4
     PrepareTemp_4,
     MeasureTemp_4,
   #endif
   #if HAS_HEATED_BED
     PrepareTemp_BED,
     MeasureTemp_BED,
   #endif
   #if HAS_TEMP_CHAMBER
     PrepareTemp_CHAMBER,
     MeasureTemp_CHAMBER,

commit 9789c1c719ac1bef616ee525a261c56350846bfe
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Apr 24 07:55:58 2018 -0500

    Fix current_temperature_chamber compile error
    
    Fix #10505

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 2abac6f116..e9727c5125 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -152,25 +152,20 @@ class Temperature {
 
     #if HAS_HEATED_BED
       static float current_temperature_bed;
       static int16_t current_temperature_bed_raw, target_temperature_bed;
       static uint8_t soft_pwm_amount_bed;
       #if ENABLED(PIDTEMPBED)
         static float bedKp, bedKi, bedKd;
       #endif
     #endif
 
-    #if HAS_TEMP_CHAMBER
-      static float current_temperature_chamber;
-      static int16_t current_temperature_chamber_raw;
-    #endif
-
     #if ENABLED(BABYSTEPPING)
       static volatile int babystepsTodo[3];
     #endif
 
     #if ENABLED(PREVENT_COLD_EXTRUSION)
       static bool allow_cold_extrude;
       static int16_t extrude_min_temp;
       FORCE_INLINE static bool tooCold(const int16_t temp) { return allow_cold_extrude ? false : temp < extrude_min_temp; }
       FORCE_INLINE static bool tooColdToExtrude(const uint8_t e) {
         #if HOTENDS == 1
@@ -258,23 +253,24 @@ class Temperature {
       #ifdef BED_MINTEMP
         static int16_t bed_minttemp_raw;
       #endif
       #ifdef BED_MAXTEMP
         static int16_t bed_maxttemp_raw;
       #endif
     #endif
 
     #if HAS_TEMP_CHAMBER
       static uint16_t raw_temp_chamber_value;
+      static float current_temperature_chamber;
+      static int16_t current_temperature_chamber_raw;
     #endif
 
-
     #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
       static uint8_t consecutive_low_temperature_error[HOTENDS];
     #endif
 
     #ifdef MILLISECONDS_PREHEAT_TIME
       static millis_t preheat_end_time[HOTENDS];
     #endif
 
     #if ENABLED(FILAMENT_WIDTH_SENSOR)
       static int8_t meas_shift_index;  // Index of a delayed sample in buffer

commit cb46cb8480c33ffc9f6361b96ed200986a3bd9ac
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Apr 23 17:13:01 2018 -0500

    Add HAS_HEATED_BED conditional (#10495)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 44e12507fc..2abac6f116 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -63,21 +63,21 @@ enum ADCSensorState : char {
     MeasureTemp_2,
   #endif
   #if HAS_TEMP_3
     PrepareTemp_3,
     MeasureTemp_3,
   #endif
   #if HAS_TEMP_4
     PrepareTemp_4,
     MeasureTemp_4,
   #endif
-  #if HAS_TEMP_BED
+  #if HAS_HEATED_BED
     PrepareTemp_BED,
     MeasureTemp_BED,
   #endif
   #if HAS_TEMP_CHAMBER
     PrepareTemp_CHAMBER,
     MeasureTemp_CHAMBER,
   #endif
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     Prepare_FILWIDTH,
     Measure_FILWIDTH,
@@ -101,49 +101,35 @@ enum ADCSensorState : char {
   #define PID_K2 (1.0-PID_K1)
   #define PID_dT ((OVERSAMPLENR * float(ACTUAL_ADC_SAMPLES)) / TEMP_TIMER_FREQUENCY)
 
   // Apply the scale factors to the PID values
   #define scalePID_i(i)   ( (i) * PID_dT )
   #define unscalePID_i(i) ( (i) / PID_dT )
   #define scalePID_d(d)   ( (d) / PID_dT )
   #define unscalePID_d(d) ( (d) * PID_dT )
 #endif
 
-#if !HAS_HEATER_BED
-  constexpr int16_t target_temperature_bed = 0;
-#endif
-
 class Temperature {
 
   public:
 
-    static float current_temperature[HOTENDS],
-                 current_temperature_chamber,
-                 current_temperature_bed;
+    static volatile bool in_temp_isr;
+
+    static float current_temperature[HOTENDS];
     static int16_t current_temperature_raw[HOTENDS],
-                   target_temperature[HOTENDS],
-                   current_temperature_chamber_raw,
-                   current_temperature_bed_raw;
+                   target_temperature[HOTENDS];
+    static uint8_t soft_pwm_amount[HOTENDS];
 
     #if ENABLED(AUTO_POWER_E_FANS)
       static int16_t autofan_speed[HOTENDS];
     #endif
 
-    #if HAS_HEATER_BED
-      static int16_t target_temperature_bed;
-    #endif
-
-    static volatile bool in_temp_isr;
-
-    static uint8_t soft_pwm_amount[HOTENDS],
-                   soft_pwm_amount_bed;
-
     #if ENABLED(FAN_SOFT_PWM)
       static uint8_t soft_pwm_amount_fan[FAN_COUNT],
                      soft_pwm_count_fan[FAN_COUNT];
     #endif
 
     #if ENABLED(PIDTEMP)
 
       #if ENABLED(PID_PARAMS_PER_HOTEND) && HOTENDS > 1
 
         static float Kp[HOTENDS], Ki[HOTENDS], Kd[HOTENDS];
@@ -157,36 +143,36 @@ class Temperature {
         static float Kp, Ki, Kd;
         #if ENABLED(PID_EXTRUSION_SCALING)
           static float Kc;
         #endif
         #define PID_PARAM(param, h) Temperature::param
 
       #endif // PID_PARAMS_PER_HOTEND
 
     #endif
 
-    #if ENABLED(PIDTEMPBED)
-      static float bedKp, bedKi, bedKd;
-    #endif
-
-    #if ENABLED(BABYSTEPPING)
-      static volatile int babystepsTodo[3];
+    #if HAS_HEATED_BED
+      static float current_temperature_bed;
+      static int16_t current_temperature_bed_raw, target_temperature_bed;
+      static uint8_t soft_pwm_amount_bed;
+      #if ENABLED(PIDTEMPBED)
+        static float bedKp, bedKi, bedKd;
+      #endif
     #endif
 
-    #if WATCH_HOTENDS
-      static uint16_t watch_target_temp[HOTENDS];
-      static millis_t watch_heater_next_ms[HOTENDS];
+    #if HAS_TEMP_CHAMBER
+      static float current_temperature_chamber;
+      static int16_t current_temperature_chamber_raw;
     #endif
 
-    #if WATCH_THE_BED
-      static uint16_t watch_target_bed_temp;
-      static millis_t watch_bed_next_ms;
+    #if ENABLED(BABYSTEPPING)
+      static volatile int babystepsTodo[3];
     #endif
 
     #if ENABLED(PREVENT_COLD_EXTRUSION)
       static bool allow_cold_extrude;
       static int16_t extrude_min_temp;
       FORCE_INLINE static bool tooCold(const int16_t temp) { return allow_cold_extrude ? false : temp < extrude_min_temp; }
       FORCE_INLINE static bool tooColdToExtrude(const uint8_t e) {
         #if HOTENDS == 1
           UNUSED(e);
         #endif
@@ -202,84 +188,99 @@ class Temperature {
       FORCE_INLINE static bool tooColdToExtrude(const uint8_t e) { UNUSED(e); return false; }
       FORCE_INLINE static bool targetTooColdToExtrude(const uint8_t e) { UNUSED(e); return false; }
     #endif
 
     FORCE_INLINE static bool hotEnoughToExtrude(const uint8_t e) { return !tooColdToExtrude(e); }
     FORCE_INLINE static bool targetHotEnoughToExtrude(const uint8_t e) { return !targetTooColdToExtrude(e); }
 
   private:
 
     #if EARLY_WATCHDOG
-      // If temperature controller is running
-      static bool inited;
+      static bool inited;   // If temperature controller is running
+    #endif
+
+    static volatile bool temp_meas_ready;
+    static uint16_t raw_temp_value[MAX_EXTRUDERS];
+
+    #if WATCH_HOTENDS
+      static uint16_t watch_target_temp[HOTENDS];
+      static millis_t watch_heater_next_ms[HOTENDS];
     #endif
 
     #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
       static uint16_t redundant_temperature_raw;
       static float redundant_temperature;
     #endif
 
-    static volatile bool temp_meas_ready;
-
     #if ENABLED(PIDTEMP)
       static float temp_iState[HOTENDS],
                    temp_dState[HOTENDS],
                    pTerm[HOTENDS],
                    iTerm[HOTENDS],
                    dTerm[HOTENDS];
 
       #if ENABLED(PID_EXTRUSION_SCALING)
         static float cTerm[HOTENDS];
         static long last_e_position;
         static long lpq[LPQ_MAX_LEN];
         static int lpq_ptr;
       #endif
 
       static float pid_error[HOTENDS];
       static bool pid_reset[HOTENDS];
     #endif
 
-    #if ENABLED(PIDTEMPBED)
-      static float temp_iState_bed,
-                   temp_dState_bed,
-                   pTerm_bed,
-                   iTerm_bed,
-                   dTerm_bed,
-                   pid_error_bed;
-    #else
-      static millis_t next_bed_check_ms;
-    #endif
-
-    static uint16_t raw_temp_value[MAX_EXTRUDERS],
-                    raw_temp_chamber_value,
-                    raw_temp_bed_value;
-
     // Init min and max temp with extreme values to prevent false errors during startup
     static int16_t minttemp_raw[HOTENDS],
                    maxttemp_raw[HOTENDS],
                    minttemp[HOTENDS],
                    maxttemp[HOTENDS];
 
-    #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
-      static uint8_t consecutive_low_temperature_error[HOTENDS];
+    #if HAS_HEATED_BED
+      static uint16_t raw_temp_bed_value;
+      #if WATCH_THE_BED
+        static uint16_t watch_target_bed_temp;
+        static millis_t watch_bed_next_ms;
+      #endif
+      #if ENABLED(PIDTEMPBED)
+        static float temp_iState_bed,
+                     temp_dState_bed,
+                     pTerm_bed,
+                     iTerm_bed,
+                     dTerm_bed,
+                     pid_error_bed;
+      #else
+        static millis_t next_bed_check_ms;
+      #endif
+      #if HEATER_IDLE_HANDLER
+        static millis_t bed_idle_timeout_ms;
+        static bool bed_idle_timeout_exceeded;
+      #endif
+      #ifdef BED_MINTEMP
+        static int16_t bed_minttemp_raw;
+      #endif
+      #ifdef BED_MAXTEMP
+        static int16_t bed_maxttemp_raw;
+      #endif
     #endif
 
-    #ifdef MILLISECONDS_PREHEAT_TIME
-      static millis_t preheat_end_time[HOTENDS];
+    #if HAS_TEMP_CHAMBER
+      static uint16_t raw_temp_chamber_value;
     #endif
 
-    #ifdef BED_MINTEMP
-      static int16_t bed_minttemp_raw;
+
+    #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
+      static uint8_t consecutive_low_temperature_error[HOTENDS];
     #endif
 
-    #ifdef BED_MAXTEMP
-      static int16_t bed_maxttemp_raw;
+    #ifdef MILLISECONDS_PREHEAT_TIME
+      static millis_t preheat_end_time[HOTENDS];
     #endif
 
     #if ENABLED(FILAMENT_WIDTH_SENSOR)
       static int8_t meas_shift_index;  // Index of a delayed sample in buffer
     #endif
 
     #if HAS_AUTO_FAN
       static millis_t next_auto_fan_check_ms;
     #endif
 
@@ -287,24 +288,20 @@ class Temperature {
       static uint16_t current_raw_filwidth; // Measured filament diameter - one extruder only
     #endif
 
     #if ENABLED(PROBING_HEATERS_OFF)
       static bool paused;
     #endif
 
     #if HEATER_IDLE_HANDLER
       static millis_t heater_idle_timeout_ms[HOTENDS];
       static bool heater_idle_timeout_exceeded[HOTENDS];
-      #if HAS_TEMP_BED
-        static millis_t bed_idle_timeout_ms;
-        static bool bed_idle_timeout_exceeded;
-      #endif
     #endif
 
   public:
     #if ENABLED(ADC_KEYPAD)
       static uint32_t current_ADCKey_raw;
       static uint8_t ADCKey_count;
     #endif
 
     /**
      * Instance Methods
@@ -312,21 +309,21 @@ class Temperature {
 
     Temperature();
 
     void init();
 
     /**
      * Static (class) methods
      */
     static float analog2temp(const int raw, const uint8_t e);
 
-    #if HAS_TEMP_BED
+    #if HAS_HEATED_BED
       static float analog2tempBed(const int raw);
     #endif
     #if HAS_TEMP_CHAMBER
       static float analog2tempChamber(const int raw);
     #endif
 
     /**
      * Called from the Temperature ISR
      */
     static void isr();
@@ -371,112 +368,119 @@ class Temperature {
     //high level conversion routines, for use outside of temperature.cpp
     //inline so that there is no performance decrease.
     //deg=degreeCelsius
 
     FORCE_INLINE static float degHotend(const uint8_t e) {
       #if HOTENDS == 1
         UNUSED(e);
       #endif
       return current_temperature[HOTEND_INDEX];
     }
-    FORCE_INLINE static float degBed() { return current_temperature_bed; }
-    FORCE_INLINE static float degChamber() { return current_temperature_chamber; }
 
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       FORCE_INLINE static int16_t rawHotendTemp(const uint8_t e) {
         #if HOTENDS == 1
           UNUSED(e);
         #endif
         return current_temperature_raw[HOTEND_INDEX];
       }
-      FORCE_INLINE static int16_t rawBedTemp() { return current_temperature_bed_raw; }
-      FORCE_INLINE static int16_t rawChamberTemp() { return current_temperature_chamber_raw; }
     #endif
 
     FORCE_INLINE static int16_t degTargetHotend(const uint8_t e) {
       #if HOTENDS == 1
         UNUSED(e);
       #endif
       return target_temperature[HOTEND_INDEX];
     }
 
-    FORCE_INLINE static int16_t degTargetBed() { return target_temperature_bed; }
-
     #if WATCH_HOTENDS
       static void start_watching_heater(const uint8_t e = 0);
     #endif
 
-    #if WATCH_THE_BED
-      static void start_watching_bed();
-    #endif
-
     static void setTargetHotend(const int16_t celsius, const uint8_t e) {
       #if HOTENDS == 1
         UNUSED(e);
       #endif
       #ifdef MILLISECONDS_PREHEAT_TIME
         if (celsius == 0)
           reset_preheat_time(HOTEND_INDEX);
         else if (target_temperature[HOTEND_INDEX] == 0)
           start_preheat_time(HOTEND_INDEX);
       #endif
       #if ENABLED(AUTO_POWER_CONTROL)
         powerManager.power_on();
       #endif
       target_temperature[HOTEND_INDEX] = celsius;
       #if WATCH_HOTENDS
         start_watching_heater(HOTEND_INDEX);
       #endif
     }
 
-    static void setTargetBed(const int16_t celsius) {
-      #if HAS_HEATER_BED
+    FORCE_INLINE static bool isHeatingHotend(const uint8_t e) {
+      #if HOTENDS == 1
+        UNUSED(e);
+      #endif
+      return target_temperature[HOTEND_INDEX] > current_temperature[HOTEND_INDEX];
+    }
+
+    FORCE_INLINE static bool isCoolingHotend(const uint8_t e) {
+      #if HOTENDS == 1
+        UNUSED(e);
+      #endif
+      return target_temperature[HOTEND_INDEX] < current_temperature[HOTEND_INDEX];
+    }
+
+    #if HAS_HEATED_BED
+      #if ENABLED(SHOW_TEMP_ADC_VALUES)
+        FORCE_INLINE static int16_t rawBedTemp()  { return current_temperature_bed_raw; }
+      #endif
+      FORCE_INLINE static float degBed()          { return current_temperature_bed; }
+      FORCE_INLINE static int16_t degTargetBed()  { return target_temperature_bed; }
+      FORCE_INLINE static bool isHeatingBed()     { return target_temperature_bed > current_temperature_bed; }
+      FORCE_INLINE static bool isCoolingBed()     { return target_temperature_bed < current_temperature_bed; }
+
+      static void setTargetBed(const int16_t celsius) {
         #if ENABLED(AUTO_POWER_CONTROL)
           powerManager.power_on();
         #endif
         target_temperature_bed =
           #ifdef BED_MAXTEMP
             min(celsius, BED_MAXTEMP)
           #else
             celsius
           #endif
         ;
         #if WATCH_THE_BED
           start_watching_bed();
         #endif
-      #endif
-    }
+      }
 
-    FORCE_INLINE static bool isHeatingHotend(const uint8_t e) {
-      #if HOTENDS == 1
-        UNUSED(e);
+      #if WATCH_THE_BED
+        static void start_watching_bed();
       #endif
-      return target_temperature[HOTEND_INDEX] > current_temperature[HOTEND_INDEX];
-    }
-    FORCE_INLINE static bool isHeatingBed() { return target_temperature_bed > current_temperature_bed; }
+    #endif
 
-    FORCE_INLINE static bool isCoolingHotend(const uint8_t e) {
-      #if HOTENDS == 1
-        UNUSED(e);
+    #if HAS_TEMP_CHAMBER
+      #if ENABLED(SHOW_TEMP_ADC_VALUES)
+        FORCE_INLINE static int16_t rawChamberTemp() { return current_temperature_chamber_raw; }
       #endif
-      return target_temperature[HOTEND_INDEX] < current_temperature[HOTEND_INDEX];
-    }
-    FORCE_INLINE static bool isCoolingBed() { return target_temperature_bed < current_temperature_bed; }
+      FORCE_INLINE static float degChamber() { return current_temperature_chamber; }
+    #endif
 
     FORCE_INLINE static bool wait_for_heating(const uint8_t e) {
       return degTargetHotend(e) > TEMP_HYSTERESIS && abs(degHotend(e) - degTargetHotend(e)) > TEMP_HYSTERESIS;
     }
 
     /**
      * The software PWM power for a heater
      */
-    static int getHeaterPower(int heater);
+    static int getHeaterPower(const int heater);
 
     /**
      * Switch off all heaters, set all target temperatures to 0
      */
     static void disable_all_heaters();
 
     /**
      * Perform auto-tuning for hotend or bed in response to M303
      */
     #if HAS_PID_HEATING
@@ -555,21 +559,21 @@ class Temperature {
         #endif
       }
 
       FORCE_INLINE static bool is_heater_idle(const uint8_t e) {
         #if HOTENDS == 1
           UNUSED(e);
         #endif
         return heater_idle_timeout_exceeded[HOTEND_INDEX];
       }
 
-      #if HAS_TEMP_BED
+      #if HAS_HEATED_BED
         static void start_bed_idle_timer(const millis_t timeout_ms) {
           bed_idle_timeout_ms = millis() + timeout_ms;
           bed_idle_timeout_exceeded = false;
         }
 
         static void reset_bed_idle_timer() {
           bed_idle_timeout_ms = 0;
           bed_idle_timeout_exceeded = false;
           #if WATCH_THE_BED
             start_watching_bed();
@@ -620,21 +624,21 @@ class Temperature {
     #if ENABLED(PIDTEMPBED)
       static float get_pid_output_bed();
     #endif
 
     static void _temp_error(const int8_t e, const char * const serial_msg, const char * const lcd_msg);
     static void min_temp_error(const int8_t e);
     static void max_temp_error(const int8_t e);
 
     #if ENABLED(THERMAL_PROTECTION_HOTENDS) || HAS_THERMALLY_PROTECTED_BED
 
-      typedef enum TRState : char { TRInactive, TRFirstHeating, TRStable, TRRunaway } TRstate;
+      enum TRState : char { TRInactive, TRFirstHeating, TRStable, TRRunaway };
 
       static void thermal_runaway_protection(TRState * const state, millis_t * const timer, const float &current, const float &target, const int8_t heater_id, const uint16_t period_seconds, const uint16_t hysteresis_degc);
 
       #if ENABLED(THERMAL_PROTECTION_HOTENDS)
         static TRState thermal_runaway_state_machine[HOTENDS];
         static millis_t thermal_runaway_timer[HOTENDS];
       #endif
 
       #if HAS_THERMALLY_PROTECTED_BED
         static TRState thermal_runaway_bed_state_machine;

commit 0e8242180d8cf59f609fe3e775d2c41b1ef8272c
Author: Lenbok <lenbok@gmail.com>
Date:   Sat Feb 24 19:38:58 2018 +1300

    Chamber temperature monitoring and auto fan control.
    
    This is an initial cut for feedback, updated for 2.0.x.
    
    Chamber temperature is currently reported along with hot end and bed
    temperatures to serial. The format is just like that used for hot end
    and bed temperatures, but using 'C' prefix. As there is no heater,
    target is always 0. Is this appropriate, is there a better way to report
    chamber temperatures?
    
    Chamber temperatures are not reported on the LCD in any way.
    
    When auto chamber fan is enabled, it currently just uses the same
    temperature threshold as the other auto controlled fans.
    
    As the chamber temperature is not connected to any heater, it doesn't
    undergo mintemp/maxtemp monitoring. This would need to change in the
    future if chamber heating became a feature.

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 45263b4a2f..44e12507fc 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -67,20 +67,24 @@ enum ADCSensorState : char {
     MeasureTemp_3,
   #endif
   #if HAS_TEMP_4
     PrepareTemp_4,
     MeasureTemp_4,
   #endif
   #if HAS_TEMP_BED
     PrepareTemp_BED,
     MeasureTemp_BED,
   #endif
+  #if HAS_TEMP_CHAMBER
+    PrepareTemp_CHAMBER,
+    MeasureTemp_CHAMBER,
+  #endif
   #if ENABLED(FILAMENT_WIDTH_SENSOR)
     Prepare_FILWIDTH,
     Measure_FILWIDTH,
   #endif
   #if ENABLED(ADC_KEYPAD)
     Prepare_ADC_KEY,
     Measure_ADC_KEY,
   #endif
   SensorsReady, // Temperatures ready. Delay the next round of readings to let ADC pins settle.
   StartupDelay  // Startup, delay initial temp reading a tiny bit so the hardware can settle
@@ -106,23 +110,25 @@ enum ADCSensorState : char {
 
 #if !HAS_HEATER_BED
   constexpr int16_t target_temperature_bed = 0;
 #endif
 
 class Temperature {
 
   public:
 
     static float current_temperature[HOTENDS],
+                 current_temperature_chamber,
                  current_temperature_bed;
     static int16_t current_temperature_raw[HOTENDS],
                    target_temperature[HOTENDS],
+                   current_temperature_chamber_raw,
                    current_temperature_bed_raw;
 
     #if ENABLED(AUTO_POWER_E_FANS)
       static int16_t autofan_speed[HOTENDS];
     #endif
 
     #if HAS_HEATER_BED
       static int16_t target_temperature_bed;
     #endif
 
@@ -237,20 +243,21 @@ class Temperature {
                    temp_dState_bed,
                    pTerm_bed,
                    iTerm_bed,
                    dTerm_bed,
                    pid_error_bed;
     #else
       static millis_t next_bed_check_ms;
     #endif
 
     static uint16_t raw_temp_value[MAX_EXTRUDERS],
+                    raw_temp_chamber_value,
                     raw_temp_bed_value;
 
     // Init min and max temp with extreme values to prevent false errors during startup
     static int16_t minttemp_raw[HOTENDS],
                    maxttemp_raw[HOTENDS],
                    minttemp[HOTENDS],
                    maxttemp[HOTENDS];
 
     #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
       static uint8_t consecutive_low_temperature_error[HOTENDS];
@@ -308,20 +315,23 @@ class Temperature {
     void init();
 
     /**
      * Static (class) methods
      */
     static float analog2temp(const int raw, const uint8_t e);
 
     #if HAS_TEMP_BED
       static float analog2tempBed(const int raw);
     #endif
+    #if HAS_TEMP_CHAMBER
+      static float analog2tempChamber(const int raw);
+    #endif
 
     /**
      * Called from the Temperature ISR
      */
     static void isr();
 
     /**
      * Call periodically to manage heaters
      */
     static void manage_heater() _O2; // Added _O2 to work around a compiler error
@@ -362,29 +372,31 @@ class Temperature {
     //inline so that there is no performance decrease.
     //deg=degreeCelsius
 
     FORCE_INLINE static float degHotend(const uint8_t e) {
       #if HOTENDS == 1
         UNUSED(e);
       #endif
       return current_temperature[HOTEND_INDEX];
     }
     FORCE_INLINE static float degBed() { return current_temperature_bed; }
+    FORCE_INLINE static float degChamber() { return current_temperature_chamber; }
 
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       FORCE_INLINE static int16_t rawHotendTemp(const uint8_t e) {
         #if HOTENDS == 1
           UNUSED(e);
         #endif
         return current_temperature_raw[HOTEND_INDEX];
       }
       FORCE_INLINE static int16_t rawBedTemp() { return current_temperature_bed_raw; }
+      FORCE_INLINE static int16_t rawChamberTemp() { return current_temperature_chamber_raw; }
     #endif
 
     FORCE_INLINE static int16_t degTargetHotend(const uint8_t e) {
       #if HOTENDS == 1
         UNUSED(e);
       #endif
       return target_temperature[HOTEND_INDEX];
     }
 
     FORCE_INLINE static int16_t degTargetBed() { return target_temperature_bed; }

commit 97e8a6ebd972ce0ad5b4e27aa139b9bb074ff44e
Author: Eduardo Jos√© Tagle <ejtagle@hotmail.com>
Date:   Wed Mar 21 21:04:45 2018 -0300

    Various fixes for DUE... (#10152)
    
    - Watchdog reset during SD Card initialization.
    - Move `DebugMonitor` to `DebugMonitor_Due.cpp`.
    - Since the watchdog is enabled on boot do extra resets during init.
    - Have `thermalManager` do watchdog reset before its ISR starts to prevent reset.
    - Ensure that timers are stopped before reprogramming them to address tone issues.
    - Improve SAM3XE reset when reflashed through the native port.

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index b92140c26a..45263b4a2f 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -195,20 +195,25 @@ class Temperature {
     #else
       FORCE_INLINE static bool tooColdToExtrude(const uint8_t e) { UNUSED(e); return false; }
       FORCE_INLINE static bool targetTooColdToExtrude(const uint8_t e) { UNUSED(e); return false; }
     #endif
 
     FORCE_INLINE static bool hotEnoughToExtrude(const uint8_t e) { return !tooColdToExtrude(e); }
     FORCE_INLINE static bool targetHotEnoughToExtrude(const uint8_t e) { return !targetTooColdToExtrude(e); }
 
   private:
 
+    #if EARLY_WATCHDOG
+      // If temperature controller is running
+      static bool inited;
+    #endif
+
     #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
       static uint16_t redundant_temperature_raw;
       static float redundant_temperature;
     #endif
 
     static volatile bool temp_meas_ready;
 
     #if ENABLED(PIDTEMP)
       static float temp_iState[HOTENDS],
                    temp_dState[HOTENDS],

commit ffbf63e6afb7728849d434ccfda89e3fd8b37094
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 7 01:53:50 2018 -0600

    Add HAS_TEMP_SENSOR conditional

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 9709ddff81..b92140c26a 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -557,21 +557,21 @@ class Temperature {
           #if WATCH_THE_BED
             start_watching_bed();
           #endif
         }
 
         FORCE_INLINE static bool is_bed_idle() { return bed_idle_timeout_exceeded; }
       #endif
 
     #endif // HEATER_IDLE_HANDLER
 
-    #if HAS_TEMP_HOTEND || HAS_TEMP_BED
+    #if HAS_TEMP_SENSOR
       static void print_heaterstates(
         #if NUM_SERIAL > 1
           const int8_t port = -1
         #endif
       );
       #if ENABLED(AUTO_REPORT_TEMPERATURES)
         static uint8_t auto_report_temp_interval;
         static millis_t next_temp_report_ms;
         static void auto_report_temperatures(void);
         FORCE_INLINE void set_auto_report_interval(uint8_t v) {

commit 20571771848e2d8d3bb4f216c25c3d610c7e47cb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Mar 6 22:35:22 2018 -0600

    Make enums into implicit char

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 4210803011..9709ddff81 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -42,21 +42,21 @@
   #include "stepper.h"
 #endif
 
 #ifndef SOFT_PWM_SCALE
   #define SOFT_PWM_SCALE 0
 #endif
 
 /**
  * States for ADC reading in the ISR
  */
-enum ADCSensorState {
+enum ADCSensorState : char {
   #if HAS_TEMP_0
     PrepareTemp_0,
     MeasureTemp_0,
   #endif
   #if HAS_TEMP_1
     PrepareTemp_1,
     MeasureTemp_1,
   #endif
   #if HAS_TEMP_2
     PrepareTemp_2,
@@ -603,21 +603,21 @@ class Temperature {
     #if ENABLED(PIDTEMPBED)
       static float get_pid_output_bed();
     #endif
 
     static void _temp_error(const int8_t e, const char * const serial_msg, const char * const lcd_msg);
     static void min_temp_error(const int8_t e);
     static void max_temp_error(const int8_t e);
 
     #if ENABLED(THERMAL_PROTECTION_HOTENDS) || HAS_THERMALLY_PROTECTED_BED
 
-      typedef enum TRState { TRInactive, TRFirstHeating, TRStable, TRRunaway } TRstate;
+      typedef enum TRState : char { TRInactive, TRFirstHeating, TRStable, TRRunaway } TRstate;
 
       static void thermal_runaway_protection(TRState * const state, millis_t * const timer, const float &current, const float &target, const int8_t heater_id, const uint16_t period_seconds, const uint16_t hysteresis_degc);
 
       #if ENABLED(THERMAL_PROTECTION_HOTENDS)
         static TRState thermal_runaway_state_machine[HOTENDS];
         static millis_t thermal_runaway_timer[HOTENDS];
       #endif
 
       #if HAS_THERMALLY_PROTECTED_BED
         static TRState thermal_runaway_bed_state_machine;

commit 7280fa1e31c4c027a9711aab6eda599af2b803ac
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Feb 10 15:41:18 2018 -0600

    Patch Power class

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 49019ebfe0..4210803011 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -28,21 +28,21 @@
 #define TEMPERATURE_H
 
 #include "thermistor/thermistors.h"
 #include "../inc/MarlinConfig.h"
 
 #if ENABLED(BABYSTEPPING)
   extern bool axis_known_position[XYZ];
 #endif
 
 #if ENABLED(AUTO_POWER_CONTROL)
-  #include "power.h"
+  #include "../feature/power.h"
 #endif
 
 #if ENABLED(PID_EXTRUSION_SCALING)
   #include "stepper.h"
 #endif
 
 #ifndef SOFT_PWM_SCALE
   #define SOFT_PWM_SCALE 0
 #endif
 

commit b5e92f4f908461ca2c78a86eefe069b85af0a2dc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Feb 6 00:22:30 2018 -0600

    [2.0.x] Enable / disable PSU automatically (#9503)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 167c6d2dfb..49019ebfe0 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -21,25 +21,30 @@
  */
 
 /**
  * temperature.h - temperature controller
  */
 
 #ifndef TEMPERATURE_H
 #define TEMPERATURE_H
 
 #include "thermistor/thermistors.h"
+#include "../inc/MarlinConfig.h"
 
 #if ENABLED(BABYSTEPPING)
   extern bool axis_known_position[XYZ];
 #endif
 
+#if ENABLED(AUTO_POWER_CONTROL)
+  #include "power.h"
+#endif
+
 #if ENABLED(PID_EXTRUSION_SCALING)
   #include "stepper.h"
 #endif
 
 #ifndef SOFT_PWM_SCALE
   #define SOFT_PWM_SCALE 0
 #endif
 
 /**
  * States for ADC reading in the ISR
@@ -106,20 +111,24 @@ enum ADCSensorState {
 class Temperature {
 
   public:
 
     static float current_temperature[HOTENDS],
                  current_temperature_bed;
     static int16_t current_temperature_raw[HOTENDS],
                    target_temperature[HOTENDS],
                    current_temperature_bed_raw;
 
+    #if ENABLED(AUTO_POWER_E_FANS)
+      static int16_t autofan_speed[HOTENDS];
+    #endif
+
     #if HAS_HEATER_BED
       static int16_t target_temperature_bed;
     #endif
 
     static volatile bool in_temp_isr;
 
     static uint8_t soft_pwm_amount[HOTENDS],
                    soft_pwm_amount_bed;
 
     #if ENABLED(FAN_SOFT_PWM)
@@ -386,28 +395,34 @@ class Temperature {
     static void setTargetHotend(const int16_t celsius, const uint8_t e) {
       #if HOTENDS == 1
         UNUSED(e);
       #endif
       #ifdef MILLISECONDS_PREHEAT_TIME
         if (celsius == 0)
           reset_preheat_time(HOTEND_INDEX);
         else if (target_temperature[HOTEND_INDEX] == 0)
           start_preheat_time(HOTEND_INDEX);
       #endif
+      #if ENABLED(AUTO_POWER_CONTROL)
+        powerManager.power_on();
+      #endif
       target_temperature[HOTEND_INDEX] = celsius;
       #if WATCH_HOTENDS
         start_watching_heater(HOTEND_INDEX);
       #endif
     }
 
     static void setTargetBed(const int16_t celsius) {
       #if HAS_HEATER_BED
+        #if ENABLED(AUTO_POWER_CONTROL)
+          powerManager.power_on();
+        #endif
         target_temperature_bed =
           #ifdef BED_MAXTEMP
             min(celsius, BED_MAXTEMP)
           #else
             celsius
           #endif
         ;
         #if WATCH_THE_BED
           start_watching_bed();
         #endif

commit 61bf8478a2a10f083462f4292a44671b944bce0e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jan 22 04:29:29 2018 -0600

    Add hotEnough methods

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index dc2b701047..167c6d2dfb 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -181,20 +181,23 @@ class Temperature {
         #if HOTENDS == 1
           UNUSED(e);
         #endif
         return tooCold(degTargetHotend(HOTEND_INDEX));
       }
     #else
       FORCE_INLINE static bool tooColdToExtrude(const uint8_t e) { UNUSED(e); return false; }
       FORCE_INLINE static bool targetTooColdToExtrude(const uint8_t e) { UNUSED(e); return false; }
     #endif
 
+    FORCE_INLINE static bool hotEnoughToExtrude(const uint8_t e) { return !tooColdToExtrude(e); }
+    FORCE_INLINE static bool targetHotEnoughToExtrude(const uint8_t e) { return !targetTooColdToExtrude(e); }
+
   private:
 
     #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
       static uint16_t redundant_temperature_raw;
       static float redundant_temperature;
     #endif
 
     static volatile bool temp_meas_ready;
 
     #if ENABLED(PIDTEMP)

commit d5bf9e74c4342ca53821b1b775c32bb0a0b3012a
Merge: 4d2f277d43 14dcad6bbc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jan 15 05:14:25 2018 -0600

    Merge pull request #8996 from p3p/pr_bf2_more_adc_filter
    
    [2.0.x] PID control fix and more LPC1768 ADC filtering

diff --combined Marlin/src/module/temperature.h
index 147a2df24f,68b00586c9..dc2b701047
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@@ -83,21 -83,21 +83,21 @@@ enum ADCSensorState 
  
  // Minimum number of Temperature::ISR loops between sensor readings.
  // Multiplied by 16 (OVERSAMPLENR) to obtain the total time to
  // get all oversampled sensor readings
  #define MIN_ADC_ISR_LOOPS 10
  
  #define ACTUAL_ADC_SAMPLES max(int(MIN_ADC_ISR_LOOPS), int(SensorsReady))
  
  #if HAS_PID_HEATING
    #define PID_K2 (1.0-PID_K1)
-   #define PID_dT ((OVERSAMPLENR * float(ACTUAL_ADC_SAMPLES)) / (F_CPU / 64.0 / 256.0))
+   #define PID_dT ((OVERSAMPLENR * float(ACTUAL_ADC_SAMPLES)) / TEMP_TIMER_FREQUENCY)
  
    // Apply the scale factors to the PID values
    #define scalePID_i(i)   ( (i) * PID_dT )
    #define unscalePID_i(i) ( (i) / PID_dT )
    #define scalePID_d(d)   ( (d) / PID_dT )
    #define unscalePID_d(d) ( (d) * PID_dT )
  #endif
  
  #if !HAS_HEATER_BED
    constexpr int16_t target_temperature_bed = 0;
@@@ -163,36 -163,28 +163,36 @@@ class Temperature 
      #endif
  
      #if WATCH_THE_BED
        static uint16_t watch_target_bed_temp;
        static millis_t watch_bed_next_ms;
      #endif
  
      #if ENABLED(PREVENT_COLD_EXTRUSION)
        static bool allow_cold_extrude;
        static int16_t extrude_min_temp;
 -      static bool tooColdToExtrude(uint8_t e) {
 +      FORCE_INLINE static bool tooCold(const int16_t temp) { return allow_cold_extrude ? false : temp < extrude_min_temp; }
 +      FORCE_INLINE static bool tooColdToExtrude(const uint8_t e) {
          #if HOTENDS == 1
            UNUSED(e);
          #endif
 -        return allow_cold_extrude ? false : degHotend(HOTEND_INDEX) < extrude_min_temp;
 +        return tooCold(degHotend(HOTEND_INDEX));
 +      }
 +      FORCE_INLINE static bool targetTooColdToExtrude(const uint8_t e) {
 +        #if HOTENDS == 1
 +          UNUSED(e);
 +        #endif
 +        return tooCold(degTargetHotend(HOTEND_INDEX));
        }
      #else
 -      static bool tooColdToExtrude(uint8_t e) { UNUSED(e); return false; }
 +      FORCE_INLINE static bool tooColdToExtrude(const uint8_t e) { UNUSED(e); return false; }
 +      FORCE_INLINE static bool targetTooColdToExtrude(const uint8_t e) { UNUSED(e); return false; }
      #endif
  
    private:
  
      #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
        static uint16_t redundant_temperature_raw;
        static float redundant_temperature;
      #endif
  
      static volatile bool temp_meas_ready;
@@@ -286,98 -278,94 +286,98 @@@
       * Instance Methods
       */
  
      Temperature();
  
      void init();
  
      /**
       * Static (class) methods
       */
 -    static float analog2temp(int raw, uint8_t e);
 -    static float analog2tempBed(int raw);
 +    static float analog2temp(const int raw, const uint8_t e);
 +
 +    #if HAS_TEMP_BED
 +      static float analog2tempBed(const int raw);
 +    #endif
  
      /**
       * Called from the Temperature ISR
       */
      static void isr();
  
      /**
       * Call periodically to manage heaters
       */
      static void manage_heater() _O2; // Added _O2 to work around a compiler error
  
      /**
       * Preheating hotends
       */
      #ifdef MILLISECONDS_PREHEAT_TIME
 -      static bool is_preheating(uint8_t e) {
 +      static bool is_preheating(const uint8_t e) {
          #if HOTENDS == 1
            UNUSED(e);
          #endif
          return preheat_end_time[HOTEND_INDEX] && PENDING(millis(), preheat_end_time[HOTEND_INDEX]);
        }
 -      static void start_preheat_time(uint8_t e) {
 +      static void start_preheat_time(const uint8_t e) {
          #if HOTENDS == 1
            UNUSED(e);
          #endif
          preheat_end_time[HOTEND_INDEX] = millis() + MILLISECONDS_PREHEAT_TIME;
        }
 -      static void reset_preheat_time(uint8_t e) {
 +      static void reset_preheat_time(const uint8_t e) {
          #if HOTENDS == 1
            UNUSED(e);
          #endif
          preheat_end_time[HOTEND_INDEX] = 0;
        }
      #else
        #define is_preheating(n) (false)
      #endif
  
      #if ENABLED(FILAMENT_WIDTH_SENSOR)
        static float analog2widthFil();         // Convert raw Filament Width to millimeters
        static int8_t widthFil_to_size_ratio(); // Convert Filament Width (mm) to an extrusion ratio
      #endif
  
 +
      //high level conversion routines, for use outside of temperature.cpp
      //inline so that there is no performance decrease.
      //deg=degreeCelsius
  
 -    static float degHotend(uint8_t e) {
 +    FORCE_INLINE static float degHotend(const uint8_t e) {
        #if HOTENDS == 1
          UNUSED(e);
        #endif
        return current_temperature[HOTEND_INDEX];
      }
 -    static float degBed() { return current_temperature_bed; }
 +    FORCE_INLINE static float degBed() { return current_temperature_bed; }
  
      #if ENABLED(SHOW_TEMP_ADC_VALUES)
 -      static int16_t rawHotendTemp(uint8_t e) {
 +      FORCE_INLINE static int16_t rawHotendTemp(const uint8_t e) {
          #if HOTENDS == 1
            UNUSED(e);
          #endif
          return current_temperature_raw[HOTEND_INDEX];
        }
 -      static int16_t rawBedTemp() { return current_temperature_bed_raw; }
 +      FORCE_INLINE static int16_t rawBedTemp() { return current_temperature_bed_raw; }
      #endif
  
 -    static int16_t degTargetHotend(uint8_t e) {
 +    FORCE_INLINE static int16_t degTargetHotend(const uint8_t e) {
        #if HOTENDS == 1
          UNUSED(e);
        #endif
        return target_temperature[HOTEND_INDEX];
      }
  
 -    static int16_t degTargetBed() { return target_temperature_bed; }
 +    FORCE_INLINE static int16_t degTargetBed() { return target_temperature_bed; }
  
      #if WATCH_HOTENDS
        static void start_watching_heater(const uint8_t e = 0);
      #endif
  
      #if WATCH_THE_BED
        static void start_watching_bed();
      #endif
  
      static void setTargetHotend(const int16_t celsius, const uint8_t e) {
@@@ -404,55 -392,51 +404,55 @@@
            #else
              celsius
            #endif
          ;
          #if WATCH_THE_BED
            start_watching_bed();
          #endif
        #endif
      }
  
 -    static bool isHeatingHotend(uint8_t e) {
 +    FORCE_INLINE static bool isHeatingHotend(const uint8_t e) {
        #if HOTENDS == 1
          UNUSED(e);
        #endif
        return target_temperature[HOTEND_INDEX] > current_temperature[HOTEND_INDEX];
      }
 -    static bool isHeatingBed() { return target_temperature_bed > current_temperature_bed; }
 +    FORCE_INLINE static bool isHeatingBed() { return target_temperature_bed > current_temperature_bed; }
  
 -    static bool isCoolingHotend(uint8_t e) {
 +    FORCE_INLINE static bool isCoolingHotend(const uint8_t e) {
        #if HOTENDS == 1
          UNUSED(e);
        #endif
        return target_temperature[HOTEND_INDEX] < current_temperature[HOTEND_INDEX];
      }
 -    static bool isCoolingBed() { return target_temperature_bed < current_temperature_bed; }
 +    FORCE_INLINE static bool isCoolingBed() { return target_temperature_bed < current_temperature_bed; }
 +
 +    FORCE_INLINE static bool wait_for_heating(const uint8_t e) {
 +      return degTargetHotend(e) > TEMP_HYSTERESIS && abs(degHotend(e) - degTargetHotend(e)) > TEMP_HYSTERESIS;
 +    }
  
      /**
       * The software PWM power for a heater
       */
      static int getHeaterPower(int heater);
  
      /**
       * Switch off all heaters, set all target temperatures to 0
       */
      static void disable_all_heaters();
  
      /**
       * Perform auto-tuning for hotend or bed in response to M303
       */
      #if HAS_PID_HEATING
 -      static void PID_autotune(const float temp, const int8_t hotend, const int8_t ncycles, const bool set_result=false);
 +      static void PID_autotune(const float &target, const int8_t hotend, const int8_t ncycles, const bool set_result=false);
  
        /**
         * Update the temp manager when PID values change
         */
        #if ENABLED(PIDTEMP)
          FORCE_INLINE static void updatePID() {
            #if ENABLED(PID_EXTRUSION_SCALING)
              last_e_position = 0;
            #endif
          }
@@@ -489,76 -473,72 +489,76 @@@
            #else
              babystepsTodo[axis] += distance;
            #endif
          }
        }
  
      #endif // BABYSTEPPING
  
      #if ENABLED(PROBING_HEATERS_OFF)
        static void pause(const bool p);
 -      static bool is_paused() { return paused; }
 +      FORCE_INLINE static bool is_paused() { return paused; }
      #endif
  
      #if HEATER_IDLE_HANDLER
 -      static void start_heater_idle_timer(uint8_t e, millis_t timeout_ms) {
 +
 +      static void start_heater_idle_timer(const uint8_t e, const millis_t timeout_ms) {
          #if HOTENDS == 1
            UNUSED(e);
          #endif
          heater_idle_timeout_ms[HOTEND_INDEX] = millis() + timeout_ms;
          heater_idle_timeout_exceeded[HOTEND_INDEX] = false;
        }
  
 -      static void reset_heater_idle_timer(uint8_t e) {
 +      static void reset_heater_idle_timer(const uint8_t e) {
          #if HOTENDS == 1
            UNUSED(e);
          #endif
          heater_idle_timeout_ms[HOTEND_INDEX] = 0;
          heater_idle_timeout_exceeded[HOTEND_INDEX] = false;
          #if WATCH_HOTENDS
            start_watching_heater(HOTEND_INDEX);
          #endif
        }
  
 -      static bool is_heater_idle(uint8_t e) {
 +      FORCE_INLINE static bool is_heater_idle(const uint8_t e) {
          #if HOTENDS == 1
            UNUSED(e);
          #endif
          return heater_idle_timeout_exceeded[HOTEND_INDEX];
        }
  
        #if HAS_TEMP_BED
 -        static void start_bed_idle_timer(millis_t timeout_ms) {
 +        static void start_bed_idle_timer(const millis_t timeout_ms) {
            bed_idle_timeout_ms = millis() + timeout_ms;
            bed_idle_timeout_exceeded = false;
          }
  
          static void reset_bed_idle_timer() {
            bed_idle_timeout_ms = 0;
            bed_idle_timeout_exceeded = false;
            #if WATCH_THE_BED
              start_watching_bed();
            #endif
          }
  
 -        static bool is_bed_idle() {
 -          return bed_idle_timeout_exceeded;
 -        }
 +        FORCE_INLINE static bool is_bed_idle() { return bed_idle_timeout_exceeded; }
        #endif
 -    #endif
 +
 +    #endif // HEATER_IDLE_HANDLER
  
      #if HAS_TEMP_HOTEND || HAS_TEMP_BED
 -      static void print_heaterstates();
 +      static void print_heaterstates(
 +        #if NUM_SERIAL > 1
 +          const int8_t port = -1
 +        #endif
 +      );
        #if ENABLED(AUTO_REPORT_TEMPERATURES)
          static uint8_t auto_report_temp_interval;
          static millis_t next_temp_report_ms;
          static void auto_report_temperatures(void);
          FORCE_INLINE void set_auto_report_interval(uint8_t v) {
            NOMORE(v, 60);
            auto_report_temp_interval = v;
            next_temp_report_ms = millis() + 1000UL * v;
          }
        #endif
@@@ -587,21 -567,21 +587,21 @@@
      #endif
  
      static void _temp_error(const int8_t e, const char * const serial_msg, const char * const lcd_msg);
      static void min_temp_error(const int8_t e);
      static void max_temp_error(const int8_t e);
  
      #if ENABLED(THERMAL_PROTECTION_HOTENDS) || HAS_THERMALLY_PROTECTED_BED
  
        typedef enum TRState { TRInactive, TRFirstHeating, TRStable, TRRunaway } TRstate;
  
 -      static void thermal_runaway_protection(TRState * const state, millis_t * const timer, const float current, const float target, const int8_t heater_id, const uint16_t period_seconds, const uint16_t hysteresis_degc);
 +      static void thermal_runaway_protection(TRState * const state, millis_t * const timer, const float &current, const float &target, const int8_t heater_id, const uint16_t period_seconds, const uint16_t hysteresis_degc);
  
        #if ENABLED(THERMAL_PROTECTION_HOTENDS)
          static TRState thermal_runaway_state_machine[HOTENDS];
          static millis_t thermal_runaway_timer[HOTENDS];
        #endif
  
        #if HAS_THERMALLY_PROTECTED_BED
          static TRState thermal_runaway_bed_state_machine;
          static millis_t thermal_runaway_bed_timer;
        #endif

commit f7efac57b7ac607405529a71b4e36a6545525c89
Author: Thomas Moore <tcm0116@gmail.com>
Date:   Sun Nov 5 08:49:38 2017 -0600

    Multi-host support

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 107fa67249..147a2df24f 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -540,21 +540,25 @@ class Temperature {
             start_watching_bed();
           #endif
         }
 
         FORCE_INLINE static bool is_bed_idle() { return bed_idle_timeout_exceeded; }
       #endif
 
     #endif // HEATER_IDLE_HANDLER
 
     #if HAS_TEMP_HOTEND || HAS_TEMP_BED
-      static void print_heaterstates();
+      static void print_heaterstates(
+        #if NUM_SERIAL > 1
+          const int8_t port = -1
+        #endif
+      );
       #if ENABLED(AUTO_REPORT_TEMPERATURES)
         static uint8_t auto_report_temp_interval;
         static millis_t next_temp_report_ms;
         static void auto_report_temperatures(void);
         FORCE_INLINE void set_auto_report_interval(uint8_t v) {
           NOMORE(v, 60);
           auto_report_temp_interval = v;
           next_temp_report_ms = millis() + 1000UL * v;
         }
       #endif

commit 14dcad6bbc5288b1205a201139218e37e9ff6d7a
Author: Christopher Pepper <p3p@p3psoft.co.uk>
Date:   Sun Jan 7 22:15:20 2018 +0000

    LPC1768: Increase ADC median filter from 3 values to 23
    
    Clarify the HAL_adc_get_result method to make sure correct values enter the filters
    
    HAL: Fix the PID control loop for non-AVR platforms

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 52d49dcfa6..68b00586c9 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -83,21 +83,21 @@ enum ADCSensorState {
 
 // Minimum number of Temperature::ISR loops between sensor readings.
 // Multiplied by 16 (OVERSAMPLENR) to obtain the total time to
 // get all oversampled sensor readings
 #define MIN_ADC_ISR_LOOPS 10
 
 #define ACTUAL_ADC_SAMPLES max(int(MIN_ADC_ISR_LOOPS), int(SensorsReady))
 
 #if HAS_PID_HEATING
   #define PID_K2 (1.0-PID_K1)
-  #define PID_dT ((OVERSAMPLENR * float(ACTUAL_ADC_SAMPLES)) / (F_CPU / 64.0 / 256.0))
+  #define PID_dT ((OVERSAMPLENR * float(ACTUAL_ADC_SAMPLES)) / TEMP_TIMER_FREQUENCY)
 
   // Apply the scale factors to the PID values
   #define scalePID_i(i)   ( (i) * PID_dT )
   #define unscalePID_i(i) ( (i) / PID_dT )
   #define scalePID_d(d)   ( (d) / PID_dT )
   #define unscalePID_d(d) ( (d) * PID_dT )
 #endif
 
 #if !HAS_HEATER_BED
   constexpr int16_t target_temperature_bed = 0;

commit 4af3d436b271f25bd7ffae78d860bc016525dd5a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jan 3 21:30:45 2018 -0600

    M303 pid autotune cleanup, commentary

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index adbab87ae5..107fa67249 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -438,21 +438,21 @@ class Temperature {
 
     /**
      * Switch off all heaters, set all target temperatures to 0
      */
     static void disable_all_heaters();
 
     /**
      * Perform auto-tuning for hotend or bed in response to M303
      */
     #if HAS_PID_HEATING
-      static void PID_autotune(const float temp, const int8_t hotend, const int8_t ncycles, const bool set_result=false);
+      static void PID_autotune(const float &target, const int8_t hotend, const int8_t ncycles, const bool set_result=false);
 
       /**
        * Update the temp manager when PID values change
        */
       #if ENABLED(PIDTEMP)
         FORCE_INLINE static void updatePID() {
           #if ENABLED(PID_EXTRUSION_SCALING)
             last_e_position = 0;
           #endif
         }

commit 5e01ee8adf8348a09711bcf136da730bb05dc3a7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jan 1 18:24:54 2018 -0600

    Temperature updates for parity with 1.1.x

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 52d49dcfa6..adbab87ae5 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -163,28 +163,36 @@ class Temperature {
     #endif
 
     #if WATCH_THE_BED
       static uint16_t watch_target_bed_temp;
       static millis_t watch_bed_next_ms;
     #endif
 
     #if ENABLED(PREVENT_COLD_EXTRUSION)
       static bool allow_cold_extrude;
       static int16_t extrude_min_temp;
-      static bool tooColdToExtrude(uint8_t e) {
+      FORCE_INLINE static bool tooCold(const int16_t temp) { return allow_cold_extrude ? false : temp < extrude_min_temp; }
+      FORCE_INLINE static bool tooColdToExtrude(const uint8_t e) {
         #if HOTENDS == 1
           UNUSED(e);
         #endif
-        return allow_cold_extrude ? false : degHotend(HOTEND_INDEX) < extrude_min_temp;
+        return tooCold(degHotend(HOTEND_INDEX));
+      }
+      FORCE_INLINE static bool targetTooColdToExtrude(const uint8_t e) {
+        #if HOTENDS == 1
+          UNUSED(e);
+        #endif
+        return tooCold(degTargetHotend(HOTEND_INDEX));
       }
     #else
-      static bool tooColdToExtrude(uint8_t e) { UNUSED(e); return false; }
+      FORCE_INLINE static bool tooColdToExtrude(const uint8_t e) { UNUSED(e); return false; }
+      FORCE_INLINE static bool targetTooColdToExtrude(const uint8_t e) { UNUSED(e); return false; }
     #endif
 
   private:
 
     #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
       static uint16_t redundant_temperature_raw;
       static float redundant_temperature;
     #endif
 
     static volatile bool temp_meas_ready;
@@ -278,94 +286,98 @@ class Temperature {
      * Instance Methods
      */
 
     Temperature();
 
     void init();
 
     /**
      * Static (class) methods
      */
-    static float analog2temp(int raw, uint8_t e);
-    static float analog2tempBed(int raw);
+    static float analog2temp(const int raw, const uint8_t e);
+
+    #if HAS_TEMP_BED
+      static float analog2tempBed(const int raw);
+    #endif
 
     /**
      * Called from the Temperature ISR
      */
     static void isr();
 
     /**
      * Call periodically to manage heaters
      */
     static void manage_heater() _O2; // Added _O2 to work around a compiler error
 
     /**
      * Preheating hotends
      */
     #ifdef MILLISECONDS_PREHEAT_TIME
-      static bool is_preheating(uint8_t e) {
+      static bool is_preheating(const uint8_t e) {
         #if HOTENDS == 1
           UNUSED(e);
         #endif
         return preheat_end_time[HOTEND_INDEX] && PENDING(millis(), preheat_end_time[HOTEND_INDEX]);
       }
-      static void start_preheat_time(uint8_t e) {
+      static void start_preheat_time(const uint8_t e) {
         #if HOTENDS == 1
           UNUSED(e);
         #endif
         preheat_end_time[HOTEND_INDEX] = millis() + MILLISECONDS_PREHEAT_TIME;
       }
-      static void reset_preheat_time(uint8_t e) {
+      static void reset_preheat_time(const uint8_t e) {
         #if HOTENDS == 1
           UNUSED(e);
         #endif
         preheat_end_time[HOTEND_INDEX] = 0;
       }
     #else
       #define is_preheating(n) (false)
     #endif
 
     #if ENABLED(FILAMENT_WIDTH_SENSOR)
       static float analog2widthFil();         // Convert raw Filament Width to millimeters
       static int8_t widthFil_to_size_ratio(); // Convert Filament Width (mm) to an extrusion ratio
     #endif
 
+
     //high level conversion routines, for use outside of temperature.cpp
     //inline so that there is no performance decrease.
     //deg=degreeCelsius
 
-    static float degHotend(uint8_t e) {
+    FORCE_INLINE static float degHotend(const uint8_t e) {
       #if HOTENDS == 1
         UNUSED(e);
       #endif
       return current_temperature[HOTEND_INDEX];
     }
-    static float degBed() { return current_temperature_bed; }
+    FORCE_INLINE static float degBed() { return current_temperature_bed; }
 
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
-      static int16_t rawHotendTemp(uint8_t e) {
+      FORCE_INLINE static int16_t rawHotendTemp(const uint8_t e) {
         #if HOTENDS == 1
           UNUSED(e);
         #endif
         return current_temperature_raw[HOTEND_INDEX];
       }
-      static int16_t rawBedTemp() { return current_temperature_bed_raw; }
+      FORCE_INLINE static int16_t rawBedTemp() { return current_temperature_bed_raw; }
     #endif
 
-    static int16_t degTargetHotend(uint8_t e) {
+    FORCE_INLINE static int16_t degTargetHotend(const uint8_t e) {
       #if HOTENDS == 1
         UNUSED(e);
       #endif
       return target_temperature[HOTEND_INDEX];
     }
 
-    static int16_t degTargetBed() { return target_temperature_bed; }
+    FORCE_INLINE static int16_t degTargetBed() { return target_temperature_bed; }
 
     #if WATCH_HOTENDS
       static void start_watching_heater(const uint8_t e = 0);
     #endif
 
     #if WATCH_THE_BED
       static void start_watching_bed();
     #endif
 
     static void setTargetHotend(const int16_t celsius, const uint8_t e) {
@@ -392,35 +404,39 @@ class Temperature {
           #else
             celsius
           #endif
         ;
         #if WATCH_THE_BED
           start_watching_bed();
         #endif
       #endif
     }
 
-    static bool isHeatingHotend(uint8_t e) {
+    FORCE_INLINE static bool isHeatingHotend(const uint8_t e) {
       #if HOTENDS == 1
         UNUSED(e);
       #endif
       return target_temperature[HOTEND_INDEX] > current_temperature[HOTEND_INDEX];
     }
-    static bool isHeatingBed() { return target_temperature_bed > current_temperature_bed; }
+    FORCE_INLINE static bool isHeatingBed() { return target_temperature_bed > current_temperature_bed; }
 
-    static bool isCoolingHotend(uint8_t e) {
+    FORCE_INLINE static bool isCoolingHotend(const uint8_t e) {
       #if HOTENDS == 1
         UNUSED(e);
       #endif
       return target_temperature[HOTEND_INDEX] < current_temperature[HOTEND_INDEX];
     }
-    static bool isCoolingBed() { return target_temperature_bed < current_temperature_bed; }
+    FORCE_INLINE static bool isCoolingBed() { return target_temperature_bed < current_temperature_bed; }
+
+    FORCE_INLINE static bool wait_for_heating(const uint8_t e) {
+      return degTargetHotend(e) > TEMP_HYSTERESIS && abs(degHotend(e) - degTargetHotend(e)) > TEMP_HYSTERESIS;
+    }
 
     /**
      * The software PWM power for a heater
      */
     static int getHeaterPower(int heater);
 
     /**
      * Switch off all heaters, set all target temperatures to 0
      */
     static void disable_all_heaters();
@@ -473,69 +489,69 @@ class Temperature {
           #else
             babystepsTodo[axis] += distance;
           #endif
         }
       }
 
     #endif // BABYSTEPPING
 
     #if ENABLED(PROBING_HEATERS_OFF)
       static void pause(const bool p);
-      static bool is_paused() { return paused; }
+      FORCE_INLINE static bool is_paused() { return paused; }
     #endif
 
     #if HEATER_IDLE_HANDLER
-      static void start_heater_idle_timer(uint8_t e, millis_t timeout_ms) {
+
+      static void start_heater_idle_timer(const uint8_t e, const millis_t timeout_ms) {
         #if HOTENDS == 1
           UNUSED(e);
         #endif
         heater_idle_timeout_ms[HOTEND_INDEX] = millis() + timeout_ms;
         heater_idle_timeout_exceeded[HOTEND_INDEX] = false;
       }
 
-      static void reset_heater_idle_timer(uint8_t e) {
+      static void reset_heater_idle_timer(const uint8_t e) {
         #if HOTENDS == 1
           UNUSED(e);
         #endif
         heater_idle_timeout_ms[HOTEND_INDEX] = 0;
         heater_idle_timeout_exceeded[HOTEND_INDEX] = false;
         #if WATCH_HOTENDS
           start_watching_heater(HOTEND_INDEX);
         #endif
       }
 
-      static bool is_heater_idle(uint8_t e) {
+      FORCE_INLINE static bool is_heater_idle(const uint8_t e) {
         #if HOTENDS == 1
           UNUSED(e);
         #endif
         return heater_idle_timeout_exceeded[HOTEND_INDEX];
       }
 
       #if HAS_TEMP_BED
-        static void start_bed_idle_timer(millis_t timeout_ms) {
+        static void start_bed_idle_timer(const millis_t timeout_ms) {
           bed_idle_timeout_ms = millis() + timeout_ms;
           bed_idle_timeout_exceeded = false;
         }
 
         static void reset_bed_idle_timer() {
           bed_idle_timeout_ms = 0;
           bed_idle_timeout_exceeded = false;
           #if WATCH_THE_BED
             start_watching_bed();
           #endif
         }
 
-        static bool is_bed_idle() {
-          return bed_idle_timeout_exceeded;
-        }
+        FORCE_INLINE static bool is_bed_idle() { return bed_idle_timeout_exceeded; }
       #endif
-    #endif
+
+    #endif // HEATER_IDLE_HANDLER
 
     #if HAS_TEMP_HOTEND || HAS_TEMP_BED
       static void print_heaterstates();
       #if ENABLED(AUTO_REPORT_TEMPERATURES)
         static uint8_t auto_report_temp_interval;
         static millis_t next_temp_report_ms;
         static void auto_report_temperatures(void);
         FORCE_INLINE void set_auto_report_interval(uint8_t v) {
           NOMORE(v, 60);
           auto_report_temp_interval = v;
@@ -567,21 +583,21 @@ class Temperature {
     #endif
 
     static void _temp_error(const int8_t e, const char * const serial_msg, const char * const lcd_msg);
     static void min_temp_error(const int8_t e);
     static void max_temp_error(const int8_t e);
 
     #if ENABLED(THERMAL_PROTECTION_HOTENDS) || HAS_THERMALLY_PROTECTED_BED
 
       typedef enum TRState { TRInactive, TRFirstHeating, TRStable, TRRunaway } TRstate;
 
-      static void thermal_runaway_protection(TRState * const state, millis_t * const timer, const float current, const float target, const int8_t heater_id, const uint16_t period_seconds, const uint16_t hysteresis_degc);
+      static void thermal_runaway_protection(TRState * const state, millis_t * const timer, const float &current, const float &target, const int8_t heater_id, const uint16_t period_seconds, const uint16_t hysteresis_degc);
 
       #if ENABLED(THERMAL_PROTECTION_HOTENDS)
         static TRState thermal_runaway_state_machine[HOTENDS];
         static millis_t thermal_runaway_timer[HOTENDS];
       #endif
 
       #if HAS_THERMALLY_PROTECTED_BED
         static TRState thermal_runaway_bed_state_machine;
         static millis_t thermal_runaway_bed_timer;
       #endif

commit cf2193c07ffc07597ece619da2db8cc587f68479
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Dec 13 02:32:34 2017 -0600

    Comment, fix filament width sensor

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index b15c49f165..52d49dcfa6 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -318,25 +318,24 @@ class Temperature {
         #if HOTENDS == 1
           UNUSED(e);
         #endif
         preheat_end_time[HOTEND_INDEX] = 0;
       }
     #else
       #define is_preheating(n) (false)
     #endif
 
     #if ENABLED(FILAMENT_WIDTH_SENSOR)
-      static float analog2widthFil(); // Convert raw Filament Width to millimeters
-      static int widthFil_to_size_ratio(); // Convert raw Filament Width to an extrusion ratio
+      static float analog2widthFil();         // Convert raw Filament Width to millimeters
+      static int8_t widthFil_to_size_ratio(); // Convert Filament Width (mm) to an extrusion ratio
     #endif
 
-
     //high level conversion routines, for use outside of temperature.cpp
     //inline so that there is no performance decrease.
     //deg=degreeCelsius
 
     static float degHotend(uint8_t e) {
       #if HOTENDS == 1
         UNUSED(e);
       #endif
       return current_temperature[HOTEND_INDEX];
     }

commit c1184552acfd69ec118ddae57d8e135357234959
Author: Richard Wackerbarth <rkw@dataplex.net>
Date:   Fri Dec 1 09:08:30 2017 -0600

    Change K1 to required option PID_K1

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index b31d181308..b15c49f165 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -81,20 +81,31 @@ enum ADCSensorState {
   StartupDelay  // Startup, delay initial temp reading a tiny bit so the hardware can settle
 };
 
 // Minimum number of Temperature::ISR loops between sensor readings.
 // Multiplied by 16 (OVERSAMPLENR) to obtain the total time to
 // get all oversampled sensor readings
 #define MIN_ADC_ISR_LOOPS 10
 
 #define ACTUAL_ADC_SAMPLES max(int(MIN_ADC_ISR_LOOPS), int(SensorsReady))
 
+#if HAS_PID_HEATING
+  #define PID_K2 (1.0-PID_K1)
+  #define PID_dT ((OVERSAMPLENR * float(ACTUAL_ADC_SAMPLES)) / (F_CPU / 64.0 / 256.0))
+
+  // Apply the scale factors to the PID values
+  #define scalePID_i(i)   ( (i) * PID_dT )
+  #define unscalePID_i(i) ( (i) / PID_dT )
+  #define scalePID_d(d)   ( (d) / PID_dT )
+  #define unscalePID_d(d) ( (d) * PID_dT )
+#endif
+
 #if !HAS_HEATER_BED
   constexpr int16_t target_temperature_bed = 0;
 #endif
 
 class Temperature {
 
   public:
 
     static float current_temperature[HOTENDS],
                  current_temperature_bed;
@@ -109,50 +120,40 @@ class Temperature {
     static volatile bool in_temp_isr;
 
     static uint8_t soft_pwm_amount[HOTENDS],
                    soft_pwm_amount_bed;
 
     #if ENABLED(FAN_SOFT_PWM)
       static uint8_t soft_pwm_amount_fan[FAN_COUNT],
                      soft_pwm_count_fan[FAN_COUNT];
     #endif
 
-    #if ENABLED(PIDTEMP) || ENABLED(PIDTEMPBED)
-      #define PID_dT ((OVERSAMPLENR * float(ACTUAL_ADC_SAMPLES)) / TEMP_TIMER_FREQUENCY)
-    #endif
-
     #if ENABLED(PIDTEMP)
 
       #if ENABLED(PID_PARAMS_PER_HOTEND) && HOTENDS > 1
 
         static float Kp[HOTENDS], Ki[HOTENDS], Kd[HOTENDS];
         #if ENABLED(PID_EXTRUSION_SCALING)
           static float Kc[HOTENDS];
         #endif
         #define PID_PARAM(param, h) Temperature::param[h]
 
       #else
 
         static float Kp, Ki, Kd;
         #if ENABLED(PID_EXTRUSION_SCALING)
           static float Kc;
         #endif
         #define PID_PARAM(param, h) Temperature::param
 
       #endif // PID_PARAMS_PER_HOTEND
 
-      // Apply the scale factors to the PID values
-      #define scalePID_i(i)   ( (i) * PID_dT )
-      #define unscalePID_i(i) ( (i) / PID_dT )
-      #define scalePID_d(d)   ( (d) / PID_dT )
-      #define unscalePID_d(d) ( (d) * PID_dT )
-
     #endif
 
     #if ENABLED(PIDTEMPBED)
       static float bedKp, bedKi, bedKd;
     #endif
 
     #if ENABLED(BABYSTEPPING)
       static volatile int babystepsTodo[3];
     #endif
 
@@ -424,24 +425,24 @@ class Temperature {
      * Switch off all heaters, set all target temperatures to 0
      */
     static void disable_all_heaters();
 
     /**
      * Perform auto-tuning for hotend or bed in response to M303
      */
     #if HAS_PID_HEATING
       static void PID_autotune(const float temp, const int8_t hotend, const int8_t ncycles, const bool set_result=false);
 
+      /**
+       * Update the temp manager when PID values change
+       */
       #if ENABLED(PIDTEMP)
-        /**
-         * Update the temp manager when PID values change
-         */
         FORCE_INLINE static void updatePID() {
           #if ENABLED(PID_EXTRUSION_SCALING)
             last_e_position = 0;
           #endif
         }
       #endif
 
     #endif
 
     #if ENABLED(BABYSTEPPING)

commit 45c2388a5894c502d66cebce52c19311d71803a3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Dec 1 19:42:44 2017 -0600

    Apply const to thermal_runaway_protection args

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 478e49d07c..b31d181308 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -567,21 +567,21 @@ class Temperature {
     #endif
 
     static void _temp_error(const int8_t e, const char * const serial_msg, const char * const lcd_msg);
     static void min_temp_error(const int8_t e);
     static void max_temp_error(const int8_t e);
 
     #if ENABLED(THERMAL_PROTECTION_HOTENDS) || HAS_THERMALLY_PROTECTED_BED
 
       typedef enum TRState { TRInactive, TRFirstHeating, TRStable, TRRunaway } TRstate;
 
-      static void thermal_runaway_protection(TRState* state, millis_t* timer, float temperature, float target_temperature, int heater_id, int period_seconds, int hysteresis_degc);
+      static void thermal_runaway_protection(TRState * const state, millis_t * const timer, const float current, const float target, const int8_t heater_id, const uint16_t period_seconds, const uint16_t hysteresis_degc);
 
       #if ENABLED(THERMAL_PROTECTION_HOTENDS)
         static TRState thermal_runaway_state_machine[HOTENDS];
         static millis_t thermal_runaway_timer[HOTENDS];
       #endif
 
       #if HAS_THERMALLY_PROTECTED_BED
         static TRState thermal_runaway_bed_state_machine;
         static millis_t thermal_runaway_bed_timer;
       #endif

commit 33912fa7e8cfeb10e75615f40bcdf77ad87207f6
Author: Unknown <davejohnson3000@gmail.com>
Date:   Mon Nov 20 01:49:21 2017 -0800

    Update Temperature::setPwmFrequency prototype to match source
    
    Introduced with #8446

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 3b419f2a59..478e49d07c 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -540,21 +540,21 @@ class Temperature {
           NOMORE(v, 60);
           auto_report_temp_interval = v;
           next_temp_report_ms = millis() + 1000UL * v;
         }
       #endif
     #endif
 
   private:
 
     #if ENABLED(FAST_PWM_FAN)
-      static void setPwmFrequency(const uint8_t pin, int val);
+      static void setPwmFrequency(const pin_t pin, int val);
     #endif
 
     static void set_current_temp_raw();
 
     static void updateTemperaturesFromRawValues();
 
     #if ENABLED(HEATER_0_USES_MAX6675)
       static int read_max6675();
     #endif
 

commit c14000775b1a5e9e8c24e139424bd9f0b4845465
Author: Bob-the-Kuhn <bob.kuhn@att.net>
Date:   Wed Nov 15 19:01:52 2017 -0600

    PWM fixes, slow down fan update
    
    include LPC1768 syntax for M42
    
    couple more pin_t changes
    
    consistency
    
    change M42 to R, P format
    
    Revert "change M42 to R, P format"
    
    This reverts commit 01f12f579ec9ccc1bb9126e68d2c86449e9b7edf.

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 4fad317597..3b419f2a59 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -354,28 +354,28 @@ class Temperature {
     static int16_t degTargetHotend(uint8_t e) {
       #if HOTENDS == 1
         UNUSED(e);
       #endif
       return target_temperature[HOTEND_INDEX];
     }
 
     static int16_t degTargetBed() { return target_temperature_bed; }
 
     #if WATCH_HOTENDS
-      static void start_watching_heater(uint8_t e = 0);
+      static void start_watching_heater(const uint8_t e = 0);
     #endif
 
     #if WATCH_THE_BED
       static void start_watching_bed();
     #endif
 
-    static void setTargetHotend(const int16_t celsius, uint8_t e) {
+    static void setTargetHotend(const int16_t celsius, const uint8_t e) {
       #if HOTENDS == 1
         UNUSED(e);
       #endif
       #ifdef MILLISECONDS_PREHEAT_TIME
         if (celsius == 0)
           reset_preheat_time(HOTEND_INDEX);
         else if (target_temperature[HOTEND_INDEX] == 0)
           start_preheat_time(HOTEND_INDEX);
       #endif
       target_temperature[HOTEND_INDEX] = celsius;

commit 1ed86adf9cbcd9199263ef0466a939bb38c96484
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Nov 10 00:48:00 2017 -0600

    Cleanup around updatePID

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 51a9038d28..4fad317597 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -423,26 +423,33 @@ class Temperature {
     /**
      * Switch off all heaters, set all target temperatures to 0
      */
     static void disable_all_heaters();
 
     /**
      * Perform auto-tuning for hotend or bed in response to M303
      */
     #if HAS_PID_HEATING
       static void PID_autotune(const float temp, const int8_t hotend, const int8_t ncycles, const bool set_result=false);
-    #endif
 
-    /**
-     * Update the temp manager when PID values change
-     */
-    static void updatePID();
+      #if ENABLED(PIDTEMP)
+        /**
+         * Update the temp manager when PID values change
+         */
+        FORCE_INLINE static void updatePID() {
+          #if ENABLED(PID_EXTRUSION_SCALING)
+            last_e_position = 0;
+          #endif
+        }
+      #endif
+
+    #endif
 
     #if ENABLED(BABYSTEPPING)
 
       static void babystep_axis(const AxisEnum axis, const int16_t distance) {
         if (axis_known_position[axis]) {
           #if IS_CORE
             #if ENABLED(BABYSTEP_XY)
               switch (axis) {
                 case CORE_AXIS_1: // X on CoreXY and CoreXZ, Y on CoreYZ
                   babystepsTodo[CORE_AXIS_1] += distance * 2;

commit 2f9e42feb91d9dee59026f312001300d766c17d7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Nov 3 03:24:19 2017 -0500

    M303 thermal runaway protection

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index ad9ff1818f..51a9038d28 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -422,21 +422,21 @@ class Temperature {
 
     /**
      * Switch off all heaters, set all target temperatures to 0
      */
     static void disable_all_heaters();
 
     /**
      * Perform auto-tuning for hotend or bed in response to M303
      */
     #if HAS_PID_HEATING
-      static void PID_autotune(float temp, int hotend, int ncycles, bool set_result=false);
+      static void PID_autotune(const float temp, const int8_t hotend, const int8_t ncycles, const bool set_result=false);
     #endif
 
     /**
      * Update the temp manager when PID values change
      */
     static void updatePID();
 
     #if ENABLED(BABYSTEPPING)
 
       static void babystep_axis(const AxisEnum axis, const int16_t distance) {

commit 325233b45428189333b663c61713c428915606b2
Author: Thomas Moore <tcm0116@users.noreply.github.com>
Date:   Sat Oct 28 19:45:07 2017 -0500

    Fix automatic stepper assignment for X/Y/Z dual stepper drivers (#8130)

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index d8c8505c9a..ad9ff1818f 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -22,22 +22,20 @@
 
 /**
  * temperature.h - temperature controller
  */
 
 #ifndef TEMPERATURE_H
 #define TEMPERATURE_H
 
 #include "thermistor/thermistors.h"
 
-#include "../inc/MarlinConfig.h"
-
 #if ENABLED(BABYSTEPPING)
   extern bool axis_known_position[XYZ];
 #endif
 
 #if ENABLED(PID_EXTRUSION_SCALING)
   #include "stepper.h"
 #endif
 
 #ifndef SOFT_PWM_SCALE
   #define SOFT_PWM_SCALE 0

commit 6cb26c98c8714e199c2d8859d0a383dd59171692
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Mon Oct 16 16:29:37 2017 -0500

    Fix Baby Stepping on 32-Bit platforms (#8001)
    
    Also, Max7219 debug code was used for this effort.   It has been
    improved and hardened.

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index e18bd10e22..d8c8505c9a 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -434,21 +434,21 @@ class Temperature {
       static void PID_autotune(float temp, int hotend, int ncycles, bool set_result=false);
     #endif
 
     /**
      * Update the temp manager when PID values change
      */
     static void updatePID();
 
     #if ENABLED(BABYSTEPPING)
 
-      static void babystep_axis(const AxisEnum axis, const int distance) {
+      static void babystep_axis(const AxisEnum axis, const int16_t distance) {
         if (axis_known_position[axis]) {
           #if IS_CORE
             #if ENABLED(BABYSTEP_XY)
               switch (axis) {
                 case CORE_AXIS_1: // X on CoreXY and CoreXZ, Y on CoreYZ
                   babystepsTodo[CORE_AXIS_1] += distance * 2;
                   babystepsTodo[CORE_AXIS_2] += distance * 2;
                   break;
                 case CORE_AXIS_2: // Y on CoreXY, Z on CoreXZ and CoreYZ
                   babystepsTodo[CORE_AXIS_1] += CORESIGN(distance * 2);

commit df0432c7c8abee61e1bc8956cbf8adb8e35c846a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 16 13:05:01 2017 -0500

    Move M155 to cpp, auto-report to Temperature

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 9959d18248..e18bd10e22 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -520,20 +520,30 @@ class Temperature {
         }
 
         static bool is_bed_idle() {
           return bed_idle_timeout_exceeded;
         }
       #endif
     #endif
 
     #if HAS_TEMP_HOTEND || HAS_TEMP_BED
       static void print_heaterstates();
+      #if ENABLED(AUTO_REPORT_TEMPERATURES)
+        static uint8_t auto_report_temp_interval;
+        static millis_t next_temp_report_ms;
+        static void auto_report_temperatures(void);
+        FORCE_INLINE void set_auto_report_interval(uint8_t v) {
+          NOMORE(v, 60);
+          auto_report_temp_interval = v;
+          next_temp_report_ms = millis() + 1000UL * v;
+        }
+      #endif
     #endif
 
   private:
 
     #if ENABLED(FAST_PWM_FAN)
       static void setPwmFrequency(const uint8_t pin, int val);
     #endif
 
     static void set_current_temp_raw();
 

commit 71aefc2e2250744b96f351e0b3b57f68c54fe1ab
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 16 04:44:37 2017 -0500

    Move heater output to Temperature class

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 2aa7e67feb..9959d18248 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -518,20 +518,24 @@ class Temperature {
             start_watching_bed();
           #endif
         }
 
         static bool is_bed_idle() {
           return bed_idle_timeout_exceeded;
         }
       #endif
     #endif
 
+    #if HAS_TEMP_HOTEND || HAS_TEMP_BED
+      static void print_heaterstates();
+    #endif
+
   private:
 
     #if ENABLED(FAST_PWM_FAN)
       static void setPwmFrequency(const uint8_t pin, int val);
     #endif
 
     static void set_current_temp_raw();
 
     static void updateTemperaturesFromRawValues();
 

commit 3d8a0ab4b215a3869a0388e5c0ef35a6372ed7d5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 6 06:28:32 2017 -0500

    Module updates

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
index 89a917992f..2aa7e67feb 100644
--- a/Marlin/src/module/temperature.h
+++ b/Marlin/src/module/temperature.h
@@ -20,42 +20,36 @@
  *
  */
 
 /**
  * temperature.h - temperature controller
  */
 
 #ifndef TEMPERATURE_H
 #define TEMPERATURE_H
 
-#include "thermistortables.h"
+#include "thermistor/thermistors.h"
 
-#include "MarlinConfig.h"
+#include "../inc/MarlinConfig.h"
+
+#if ENABLED(BABYSTEPPING)
+  extern bool axis_known_position[XYZ];
+#endif
 
 #if ENABLED(PID_EXTRUSION_SCALING)
   #include "stepper.h"
 #endif
 
 #ifndef SOFT_PWM_SCALE
   #define SOFT_PWM_SCALE 0
 #endif
 
-#define HOTEND_LOOP() for (int8_t e = 0; e < HOTENDS; e++)
-
-#if HOTENDS == 1
-  #define HOTEND_INDEX  0
-  #define EXTRUDER_IDX  0
-#else
-  #define HOTEND_INDEX  e
-  #define EXTRUDER_IDX  active_extruder
-#endif
-
 /**
  * States for ADC reading in the ISR
  */
 enum ADCSensorState {
   #if HAS_TEMP_0
     PrepareTemp_0,
     MeasureTemp_0,
   #endif
   #if HAS_TEMP_1
     PrepareTemp_1,
@@ -526,20 +520,24 @@ class Temperature {
         }
 
         static bool is_bed_idle() {
           return bed_idle_timeout_exceeded;
         }
       #endif
     #endif
 
   private:
 
+    #if ENABLED(FAST_PWM_FAN)
+      static void setPwmFrequency(const uint8_t pin, int val);
+    #endif
+
     static void set_current_temp_raw();
 
     static void updateTemperaturesFromRawValues();
 
     #if ENABLED(HEATER_0_USES_MAX6675)
       static int read_max6675();
     #endif
 
     static void checkExtruderAutoFans();
 

commit 0c9231fd04798c30830513a0cad8b204a6b9633f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 6 06:28:30 2017 -0500

    Move 'module' files

diff --git a/Marlin/src/module/temperature.h b/Marlin/src/module/temperature.h
new file mode 100644
index 0000000000..89a917992f
--- /dev/null
+++ b/Marlin/src/module/temperature.h
@@ -0,0 +1,578 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * temperature.h - temperature controller
+ */
+
+#ifndef TEMPERATURE_H
+#define TEMPERATURE_H
+
+#include "thermistortables.h"
+
+#include "MarlinConfig.h"
+
+#if ENABLED(PID_EXTRUSION_SCALING)
+  #include "stepper.h"
+#endif
+
+#ifndef SOFT_PWM_SCALE
+  #define SOFT_PWM_SCALE 0
+#endif
+
+#define HOTEND_LOOP() for (int8_t e = 0; e < HOTENDS; e++)
+
+#if HOTENDS == 1
+  #define HOTEND_INDEX  0
+  #define EXTRUDER_IDX  0
+#else
+  #define HOTEND_INDEX  e
+  #define EXTRUDER_IDX  active_extruder
+#endif
+
+/**
+ * States for ADC reading in the ISR
+ */
+enum ADCSensorState {
+  #if HAS_TEMP_0
+    PrepareTemp_0,
+    MeasureTemp_0,
+  #endif
+  #if HAS_TEMP_1
+    PrepareTemp_1,
+    MeasureTemp_1,
+  #endif
+  #if HAS_TEMP_2
+    PrepareTemp_2,
+    MeasureTemp_2,
+  #endif
+  #if HAS_TEMP_3
+    PrepareTemp_3,
+    MeasureTemp_3,
+  #endif
+  #if HAS_TEMP_4
+    PrepareTemp_4,
+    MeasureTemp_4,
+  #endif
+  #if HAS_TEMP_BED
+    PrepareTemp_BED,
+    MeasureTemp_BED,
+  #endif
+  #if ENABLED(FILAMENT_WIDTH_SENSOR)
+    Prepare_FILWIDTH,
+    Measure_FILWIDTH,
+  #endif
+  #if ENABLED(ADC_KEYPAD)
+    Prepare_ADC_KEY,
+    Measure_ADC_KEY,
+  #endif
+  SensorsReady, // Temperatures ready. Delay the next round of readings to let ADC pins settle.
+  StartupDelay  // Startup, delay initial temp reading a tiny bit so the hardware can settle
+};
+
+// Minimum number of Temperature::ISR loops between sensor readings.
+// Multiplied by 16 (OVERSAMPLENR) to obtain the total time to
+// get all oversampled sensor readings
+#define MIN_ADC_ISR_LOOPS 10
+
+#define ACTUAL_ADC_SAMPLES max(int(MIN_ADC_ISR_LOOPS), int(SensorsReady))
+
+#if !HAS_HEATER_BED
+  constexpr int16_t target_temperature_bed = 0;
+#endif
+
+class Temperature {
+
+  public:
+
+    static float current_temperature[HOTENDS],
+                 current_temperature_bed;
+    static int16_t current_temperature_raw[HOTENDS],
+                   target_temperature[HOTENDS],
+                   current_temperature_bed_raw;
+
+    #if HAS_HEATER_BED
+      static int16_t target_temperature_bed;
+    #endif
+
+    static volatile bool in_temp_isr;
+
+    static uint8_t soft_pwm_amount[HOTENDS],
+                   soft_pwm_amount_bed;
+
+    #if ENABLED(FAN_SOFT_PWM)
+      static uint8_t soft_pwm_amount_fan[FAN_COUNT],
+                     soft_pwm_count_fan[FAN_COUNT];
+    #endif
+
+    #if ENABLED(PIDTEMP) || ENABLED(PIDTEMPBED)
+      #define PID_dT ((OVERSAMPLENR * float(ACTUAL_ADC_SAMPLES)) / TEMP_TIMER_FREQUENCY)
+    #endif
+
+    #if ENABLED(PIDTEMP)
+
+      #if ENABLED(PID_PARAMS_PER_HOTEND) && HOTENDS > 1
+
+        static float Kp[HOTENDS], Ki[HOTENDS], Kd[HOTENDS];
+        #if ENABLED(PID_EXTRUSION_SCALING)
+          static float Kc[HOTENDS];
+        #endif
+        #define PID_PARAM(param, h) Temperature::param[h]
+
+      #else
+
+        static float Kp, Ki, Kd;
+        #if ENABLED(PID_EXTRUSION_SCALING)
+          static float Kc;
+        #endif
+        #define PID_PARAM(param, h) Temperature::param
+
+      #endif // PID_PARAMS_PER_HOTEND
+
+      // Apply the scale factors to the PID values
+      #define scalePID_i(i)   ( (i) * PID_dT )
+      #define unscalePID_i(i) ( (i) / PID_dT )
+      #define scalePID_d(d)   ( (d) / PID_dT )
+      #define unscalePID_d(d) ( (d) * PID_dT )
+
+    #endif
+
+    #if ENABLED(PIDTEMPBED)
+      static float bedKp, bedKi, bedKd;
+    #endif
+
+    #if ENABLED(BABYSTEPPING)
+      static volatile int babystepsTodo[3];
+    #endif
+
+    #if WATCH_HOTENDS
+      static uint16_t watch_target_temp[HOTENDS];
+      static millis_t watch_heater_next_ms[HOTENDS];
+    #endif
+
+    #if WATCH_THE_BED
+      static uint16_t watch_target_bed_temp;
+      static millis_t watch_bed_next_ms;
+    #endif
+
+    #if ENABLED(PREVENT_COLD_EXTRUSION)
+      static bool allow_cold_extrude;
+      static int16_t extrude_min_temp;
+      static bool tooColdToExtrude(uint8_t e) {
+        #if HOTENDS == 1
+          UNUSED(e);
+        #endif
+        return allow_cold_extrude ? false : degHotend(HOTEND_INDEX) < extrude_min_temp;
+      }
+    #else
+      static bool tooColdToExtrude(uint8_t e) { UNUSED(e); return false; }
+    #endif
+
+  private:
+
+    #if ENABLED(TEMP_SENSOR_1_AS_REDUNDANT)
+      static uint16_t redundant_temperature_raw;
+      static float redundant_temperature;
+    #endif
+
+    static volatile bool temp_meas_ready;
+
+    #if ENABLED(PIDTEMP)
+      static float temp_iState[HOTENDS],
+                   temp_dState[HOTENDS],
+                   pTerm[HOTENDS],
+                   iTerm[HOTENDS],
+                   dTerm[HOTENDS];
+
+      #if ENABLED(PID_EXTRUSION_SCALING)
+        static float cTerm[HOTENDS];
+        static long last_e_position;
+        static long lpq[LPQ_MAX_LEN];
+        static int lpq_ptr;
+      #endif
+
+      static float pid_error[HOTENDS];
+      static bool pid_reset[HOTENDS];
+    #endif
+
+    #if ENABLED(PIDTEMPBED)
+      static float temp_iState_bed,
+                   temp_dState_bed,
+                   pTerm_bed,
+                   iTerm_bed,
+                   dTerm_bed,
+                   pid_error_bed;
+    #else
+      static millis_t next_bed_check_ms;
+    #endif
+
+    static uint16_t raw_temp_value[MAX_EXTRUDERS],
+                    raw_temp_bed_value;
+
+    // Init min and max temp with extreme values to prevent false errors during startup
+    static int16_t minttemp_raw[HOTENDS],
+                   maxttemp_raw[HOTENDS],
+                   minttemp[HOTENDS],
+                   maxttemp[HOTENDS];
+
+    #ifdef MAX_CONSECUTIVE_LOW_TEMPERATURE_ERROR_ALLOWED
+      static uint8_t consecutive_low_temperature_error[HOTENDS];
+    #endif
+
+    #ifdef MILLISECONDS_PREHEAT_TIME
+      static millis_t preheat_end_time[HOTENDS];
+    #endif
+
+    #ifdef BED_MINTEMP
+      static int16_t bed_minttemp_raw;
+    #endif
+
+    #ifdef BED_MAXTEMP
+      static int16_t bed_maxttemp_raw;
+    #endif
+
+    #if ENABLED(FILAMENT_WIDTH_SENSOR)
+      static int8_t meas_shift_index;  // Index of a delayed sample in buffer
+    #endif
+
+    #if HAS_AUTO_FAN
+      static millis_t next_auto_fan_check_ms;
+    #endif
+
+    #if ENABLED(FILAMENT_WIDTH_SENSOR)
+      static uint16_t current_raw_filwidth; // Measured filament diameter - one extruder only
+    #endif
+
+    #if ENABLED(PROBING_HEATERS_OFF)
+      static bool paused;
+    #endif
+
+    #if HEATER_IDLE_HANDLER
+      static millis_t heater_idle_timeout_ms[HOTENDS];
+      static bool heater_idle_timeout_exceeded[HOTENDS];
+      #if HAS_TEMP_BED
+        static millis_t bed_idle_timeout_ms;
+        static bool bed_idle_timeout_exceeded;
+      #endif
+    #endif
+
+  public:
+    #if ENABLED(ADC_KEYPAD)
+      static uint32_t current_ADCKey_raw;
+      static uint8_t ADCKey_count;
+    #endif
+
+    /**
+     * Instance Methods
+     */
+
+    Temperature();
+
+    void init();
+
+    /**
+     * Static (class) methods
+     */
+    static float analog2temp(int raw, uint8_t e);
+    static float analog2tempBed(int raw);
+
+    /**
+     * Called from the Temperature ISR
+     */
+    static void isr();
+
+    /**
+     * Call periodically to manage heaters
+     */
+    static void manage_heater() _O2; // Added _O2 to work around a compiler error
+
+    /**
+     * Preheating hotends
+     */
+    #ifdef MILLISECONDS_PREHEAT_TIME
+      static bool is_preheating(uint8_t e) {
+        #if HOTENDS == 1
+          UNUSED(e);
+        #endif
+        return preheat_end_time[HOTEND_INDEX] && PENDING(millis(), preheat_end_time[HOTEND_INDEX]);
+      }
+      static void start_preheat_time(uint8_t e) {
+        #if HOTENDS == 1
+          UNUSED(e);
+        #endif
+        preheat_end_time[HOTEND_INDEX] = millis() + MILLISECONDS_PREHEAT_TIME;
+      }
+      static void reset_preheat_time(uint8_t e) {
+        #if HOTENDS == 1
+          UNUSED(e);
+        #endif
+        preheat_end_time[HOTEND_INDEX] = 0;
+      }
+    #else
+      #define is_preheating(n) (false)
+    #endif
+
+    #if ENABLED(FILAMENT_WIDTH_SENSOR)
+      static float analog2widthFil(); // Convert raw Filament Width to millimeters
+      static int widthFil_to_size_ratio(); // Convert raw Filament Width to an extrusion ratio
+    #endif
+
+
+    //high level conversion routines, for use outside of temperature.cpp
+    //inline so that there is no performance decrease.
+    //deg=degreeCelsius
+
+    static float degHotend(uint8_t e) {
+      #if HOTENDS == 1
+        UNUSED(e);
+      #endif
+      return current_temperature[HOTEND_INDEX];
+    }
+    static float degBed() { return current_temperature_bed; }
+
+    #if ENABLED(SHOW_TEMP_ADC_VALUES)
+      static int16_t rawHotendTemp(uint8_t e) {
+        #if HOTENDS == 1
+          UNUSED(e);
+        #endif
+        return current_temperature_raw[HOTEND_INDEX];
+      }
+      static int16_t rawBedTemp() { return current_temperature_bed_raw; }
+    #endif
+
+    static int16_t degTargetHotend(uint8_t e) {
+      #if HOTENDS == 1
+        UNUSED(e);
+      #endif
+      return target_temperature[HOTEND_INDEX];
+    }
+
+    static int16_t degTargetBed() { return target_temperature_bed; }
+
+    #if WATCH_HOTENDS
+      static void start_watching_heater(uint8_t e = 0);
+    #endif
+
+    #if WATCH_THE_BED
+      static void start_watching_bed();
+    #endif
+
+    static void setTargetHotend(const int16_t celsius, uint8_t e) {
+      #if HOTENDS == 1
+        UNUSED(e);
+      #endif
+      #ifdef MILLISECONDS_PREHEAT_TIME
+        if (celsius == 0)
+          reset_preheat_time(HOTEND_INDEX);
+        else if (target_temperature[HOTEND_INDEX] == 0)
+          start_preheat_time(HOTEND_INDEX);
+      #endif
+      target_temperature[HOTEND_INDEX] = celsius;
+      #if WATCH_HOTENDS
+        start_watching_heater(HOTEND_INDEX);
+      #endif
+    }
+
+    static void setTargetBed(const int16_t celsius) {
+      #if HAS_HEATER_BED
+        target_temperature_bed =
+          #ifdef BED_MAXTEMP
+            min(celsius, BED_MAXTEMP)
+          #else
+            celsius
+          #endif
+        ;
+        #if WATCH_THE_BED
+          start_watching_bed();
+        #endif
+      #endif
+    }
+
+    static bool isHeatingHotend(uint8_t e) {
+      #if HOTENDS == 1
+        UNUSED(e);
+      #endif
+      return target_temperature[HOTEND_INDEX] > current_temperature[HOTEND_INDEX];
+    }
+    static bool isHeatingBed() { return target_temperature_bed > current_temperature_bed; }
+
+    static bool isCoolingHotend(uint8_t e) {
+      #if HOTENDS == 1
+        UNUSED(e);
+      #endif
+      return target_temperature[HOTEND_INDEX] < current_temperature[HOTEND_INDEX];
+    }
+    static bool isCoolingBed() { return target_temperature_bed < current_temperature_bed; }
+
+    /**
+     * The software PWM power for a heater
+     */
+    static int getHeaterPower(int heater);
+
+    /**
+     * Switch off all heaters, set all target temperatures to 0
+     */
+    static void disable_all_heaters();
+
+    /**
+     * Perform auto-tuning for hotend or bed in response to M303
+     */
+    #if HAS_PID_HEATING
+      static void PID_autotune(float temp, int hotend, int ncycles, bool set_result=false);
+    #endif
+
+    /**
+     * Update the temp manager when PID values change
+     */
+    static void updatePID();
+
+    #if ENABLED(BABYSTEPPING)
+
+      static void babystep_axis(const AxisEnum axis, const int distance) {
+        if (axis_known_position[axis]) {
+          #if IS_CORE
+            #if ENABLED(BABYSTEP_XY)
+              switch (axis) {
+                case CORE_AXIS_1: // X on CoreXY and CoreXZ, Y on CoreYZ
+                  babystepsTodo[CORE_AXIS_1] += distance * 2;
+                  babystepsTodo[CORE_AXIS_2] += distance * 2;
+                  break;
+                case CORE_AXIS_2: // Y on CoreXY, Z on CoreXZ and CoreYZ
+                  babystepsTodo[CORE_AXIS_1] += CORESIGN(distance * 2);
+                  babystepsTodo[CORE_AXIS_2] -= CORESIGN(distance * 2);
+                  break;
+                case NORMAL_AXIS: // Z on CoreXY, Y on CoreXZ, X on CoreYZ
+                  babystepsTodo[NORMAL_AXIS] += distance;
+                  break;
+              }
+            #elif CORE_IS_XZ || CORE_IS_YZ
+              // Only Z stepping needs to be handled here
+              babystepsTodo[CORE_AXIS_1] += CORESIGN(distance * 2);
+              babystepsTodo[CORE_AXIS_2] -= CORESIGN(distance * 2);
+            #else
+              babystepsTodo[Z_AXIS] += distance;
+            #endif
+          #else
+            babystepsTodo[axis] += distance;
+          #endif
+        }
+      }
+
+    #endif // BABYSTEPPING
+
+    #if ENABLED(PROBING_HEATERS_OFF)
+      static void pause(const bool p);
+      static bool is_paused() { return paused; }
+    #endif
+
+    #if HEATER_IDLE_HANDLER
+      static void start_heater_idle_timer(uint8_t e, millis_t timeout_ms) {
+        #if HOTENDS == 1
+          UNUSED(e);
+        #endif
+        heater_idle_timeout_ms[HOTEND_INDEX] = millis() + timeout_ms;
+        heater_idle_timeout_exceeded[HOTEND_INDEX] = false;
+      }
+
+      static void reset_heater_idle_timer(uint8_t e) {
+        #if HOTENDS == 1
+          UNUSED(e);
+        #endif
+        heater_idle_timeout_ms[HOTEND_INDEX] = 0;
+        heater_idle_timeout_exceeded[HOTEND_INDEX] = false;
+        #if WATCH_HOTENDS
+          start_watching_heater(HOTEND_INDEX);
+        #endif
+      }
+
+      static bool is_heater_idle(uint8_t e) {
+        #if HOTENDS == 1
+          UNUSED(e);
+        #endif
+        return heater_idle_timeout_exceeded[HOTEND_INDEX];
+      }
+
+      #if HAS_TEMP_BED
+        static void start_bed_idle_timer(millis_t timeout_ms) {
+          bed_idle_timeout_ms = millis() + timeout_ms;
+          bed_idle_timeout_exceeded = false;
+        }
+
+        static void reset_bed_idle_timer() {
+          bed_idle_timeout_ms = 0;
+          bed_idle_timeout_exceeded = false;
+          #if WATCH_THE_BED
+            start_watching_bed();
+          #endif
+        }
+
+        static bool is_bed_idle() {
+          return bed_idle_timeout_exceeded;
+        }
+      #endif
+    #endif
+
+  private:
+
+    static void set_current_temp_raw();
+
+    static void updateTemperaturesFromRawValues();
+
+    #if ENABLED(HEATER_0_USES_MAX6675)
+      static int read_max6675();
+    #endif
+
+    static void checkExtruderAutoFans();
+
+    static float get_pid_output(const int8_t e);
+
+    #if ENABLED(PIDTEMPBED)
+      static float get_pid_output_bed();
+    #endif
+
+    static void _temp_error(const int8_t e, const char * const serial_msg, const char * const lcd_msg);
+    static void min_temp_error(const int8_t e);
+    static void max_temp_error(const int8_t e);
+
+    #if ENABLED(THERMAL_PROTECTION_HOTENDS) || HAS_THERMALLY_PROTECTED_BED
+
+      typedef enum TRState { TRInactive, TRFirstHeating, TRStable, TRRunaway } TRstate;
+
+      static void thermal_runaway_protection(TRState* state, millis_t* timer, float temperature, float target_temperature, int heater_id, int period_seconds, int hysteresis_degc);
+
+      #if ENABLED(THERMAL_PROTECTION_HOTENDS)
+        static TRState thermal_runaway_state_machine[HOTENDS];
+        static millis_t thermal_runaway_timer[HOTENDS];
+      #endif
+
+      #if HAS_THERMALLY_PROTECTED_BED
+        static TRState thermal_runaway_bed_state_machine;
+        static millis_t thermal_runaway_bed_timer;
+      #endif
+
+    #endif // THERMAL_PROTECTION
+
+};
+
+extern Temperature thermalManager;
+
+#endif // TEMPERATURE_H
