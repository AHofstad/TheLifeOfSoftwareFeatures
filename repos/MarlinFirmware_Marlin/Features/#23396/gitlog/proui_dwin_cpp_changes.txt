commit 1f9fc665ec21f95666801aa4fccc4f4f71932018
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jun 26 18:27:05 2024 -0500

    üö∏ MarlinUI:: clear_for_drawing

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 56c7fec517..2b691326c0 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -1906,20 +1906,22 @@ void dwinCopySettingsFrom(const char * const buff) {
 }
 
 // Initialize or re-initialize the LCD
 void MarlinUI::init_lcd() {
   delay(750);   // Wait to wakeup screen
   const bool hs = dwinHandshake(); UNUSED(hs);
   dwinFrameSetDir(1);
   dwinJPGCacheTo1(Language_English);
 }
 
+void MarlinUI::clear_lcd() {}
+
 void dwinInitScreen() {
   dwinSetColorDefaults();
   hmiInit();   // Draws boot screen
   DWINUI::init();
   DWINUI::setColors(hmiData.colorText, hmiData.colorBackground, hmiData.colorStatusBg);
   DWINUI::onTitleDraw = drawTitle;
   initMenu();
   checkkey = 255;
   hash_changed = true;
   dwinDrawStatusLine();

commit f9153712483bf6ad3322de3ab4adf5c55bbe47a9
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed May 22 17:36:44 2024 -0500

    üßë‚Äçüíª More language cleanup

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 7c2727486b..56c7fec517 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -3309,21 +3309,21 @@ void drawMoveMenu() {
     updateMenu(probeSettingsMenu);
   }
 
 #endif // HAS_BED_PROBE
 
 void drawFilSetMenu() {
   checkkey = ID_Menu;
   if (SET_MENU(filSetMenu, MSG_FILAMENT_SET, 9)) {
     BACK_ITEM(drawAdvancedSettingsMenu);
     #if HAS_FILAMENT_SENSOR
-      EDIT_ITEM(ICON_Runout, MSG_RUNOUT_ENABLE, onDrawChkbMenu, setRunoutEnable, &runout.enabled);
+      EDIT_ITEM(ICON_Runout, MSG_RUNOUT_SENSOR, onDrawChkbMenu, setRunoutEnable, &runout.enabled);
     #endif
     #if HAS_FILAMENT_RUNOUT_DISTANCE
       EDIT_ITEM(ICON_Runout, MSG_RUNOUT_DISTANCE_MM, onDrawPFloatMenu, setRunoutDistance, &runout.runout_distance());
     #endif
     #if ENABLED(PREVENT_COLD_EXTRUSION)
       EDIT_ITEM(ICON_ExtrudeMinT, MSG_EXTRUDER_MIN_TEMP, onDrawPIntMenu, setExtMinT, &hmiData.extMinT);
     #endif
     #if ENABLED(CONFIGURE_FILAMENT_CHANGE)
       EDIT_ITEM(ICON_FilLoad, MSG_FILAMENT_LOAD, onDrawPFloatMenu, setFilLoad, &fc_settings[0].load_length);
       EDIT_ITEM(ICON_FilUnload, MSG_FILAMENT_UNLOAD, onDrawPFloatMenu, setFilUnload, &fc_settings[0].unload_length);
@@ -3400,21 +3400,21 @@ void drawTuneMenu() {
     #if ALL(HAS_ZOFFSET_ITEM, HAS_BED_PROBE, BABYSTEP_ZPROBE_OFFSET, BABYSTEPPING)
       EDIT_ITEM(ICON_Zoffset, MSG_ZPROBE_ZOFFSET, onDrawZOffset, setZOffset, &BABY_Z_VAR);
     #elif ALL(HAS_ZOFFSET_ITEM, MESH_BED_LEVELING, BABYSTEPPING)
       EDIT_ITEM(ICON_Zoffset, MSG_HOME_OFFSET_Z, onDrawPFloat2Menu, setZOffset, &BABY_Z_VAR);
     #endif
     EDIT_ITEM(ICON_Flow, MSG_FLOW, onDrawPIntMenu, setFlow, &planner.flow_percentage[0]);
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
       MENU_ITEM(ICON_FilMan, MSG_FILAMENTCHANGE, onDrawMenuItem, changeFilament);
     #endif
     #if HAS_FILAMENT_SENSOR
-      EDIT_ITEM(ICON_Runout, MSG_RUNOUT_ENABLE, onDrawChkbMenu, setRunoutEnable, &runout.enabled);
+      EDIT_ITEM(ICON_Runout, MSG_RUNOUT_SENSOR, onDrawChkbMenu, setRunoutEnable, &runout.enabled);
     #endif
     #if ENABLED(PROUI_ITEM_PLR)
       EDIT_ITEM(ICON_Pwrlossr, MSG_OUTAGE_RECOVERY, onDrawChkbMenu, setPwrLossr, &recovery.enabled);
     #endif
     #if ENABLED(FWRETRACT)
       MENU_ITEM(ICON_FWRetract, MSG_FWRETRACT, onDrawSubMenu, drawFWRetractMenu);
     #endif
     #if ENABLED(PROUI_ITEM_JD)
       EDIT_ITEM(ICON_JDmm, MSG_JUNCTION_DEVIATION, onDrawPFloat3Menu, setJDmm, &planner.junction_deviation_mm);
     #endif

commit ea848aa891808c27d0fc0039a93bb454cf81daf6
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Wed May 22 15:07:04 2024 -0400

    ü©π Z input shaper followup (#27118)
    
    Followup to #27073

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 18c97adb3a..7c2727486b 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -3480,21 +3480,21 @@ void drawTuneMenu() {
 
   #if ENABLED(INPUT_SHAPING_Z)
     void onDrawShapingZFreq(MenuItem* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, stepper.get_shaping_frequency(Z_AXIS)); }
     void onDrawShapingZZeta(MenuItem* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, stepper.get_shaping_damping_ratio(Z_AXIS)); }
     void setShapingZFreq() { hmiValue.axis = Z_AXIS; setFloatOnClick(0, 200, 2, stepper.get_shaping_frequency(Z_AXIS), applyShapingFreq); }
     void setShapingZZeta() { hmiValue.axis = Z_AXIS; setFloatOnClick(0, 1, 2, stepper.get_shaping_damping_ratio(Z_AXIS), applyShapingZeta); }
   #endif
 
   void drawInputShaping_menu() {
     checkkey = ID_Menu;
-    if (SET_MENU(inputShapingMenu, MSG_INPUT_SHAPING, 5)) {
+    if (SET_MENU(inputShapingMenu, MSG_INPUT_SHAPING, 1 PLUS_TERN0(INPUT_SHAPING_X, 2) PLUS_TERN0(INPUT_SHAPING_Y, 2) PLUS_TERN0(INPUT_SHAPING_Z, 2))) {
       BACK_ITEM(drawMotionMenu);
       #if ENABLED(INPUT_SHAPING_X)
         MENU_ITEM(ICON_ShapingX, MSG_SHAPING_A_FREQ, onDrawShapingXFreq, setShapingXFreq);
         MENU_ITEM(ICON_ShapingX, MSG_SHAPING_A_ZETA, onDrawShapingXZeta, setShapingXZeta);
       #endif
       #if ENABLED(INPUT_SHAPING_Y)
         MENU_ITEM(ICON_ShapingY, MSG_SHAPING_B_FREQ, onDrawShapingYFreq, setShapingYFreq);
         MENU_ITEM(ICON_ShapingY, MSG_SHAPING_B_ZETA, onDrawShapingYZeta, setShapingYZeta);
       #endif
       #if ENABLED(INPUT_SHAPING_Z)

commit 6b6865d068c2ebbcb6b56c965807571257d50828
Author: Jonathan Brazier <66009857+JonBr306@users.noreply.github.com>
Date:   Mon May 20 06:03:03 2024 +0100

    ‚ú® INPUT_SHAPING_Z (#27073)

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index debe3b5de0..18c97adb3a 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -3471,32 +3471,43 @@ void drawTuneMenu() {
     void setShapingXZeta() { hmiValue.axis = X_AXIS; setFloatOnClick(0, 1, 2, stepper.get_shaping_damping_ratio(X_AXIS), applyShapingZeta); }
   #endif
 
   #if ENABLED(INPUT_SHAPING_Y)
     void onDrawShapingYFreq(MenuItem* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, stepper.get_shaping_frequency(Y_AXIS)); }
     void onDrawShapingYZeta(MenuItem* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, stepper.get_shaping_damping_ratio(Y_AXIS)); }
     void setShapingYFreq() { hmiValue.axis = Y_AXIS; setFloatOnClick(0, 200, 2, stepper.get_shaping_frequency(Y_AXIS), applyShapingFreq); }
     void setShapingYZeta() { hmiValue.axis = Y_AXIS; setFloatOnClick(0, 1, 2, stepper.get_shaping_damping_ratio(Y_AXIS), applyShapingZeta); }
   #endif
 
+  #if ENABLED(INPUT_SHAPING_Z)
+    void onDrawShapingZFreq(MenuItem* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, stepper.get_shaping_frequency(Z_AXIS)); }
+    void onDrawShapingZZeta(MenuItem* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, stepper.get_shaping_damping_ratio(Z_AXIS)); }
+    void setShapingZFreq() { hmiValue.axis = Z_AXIS; setFloatOnClick(0, 200, 2, stepper.get_shaping_frequency(Z_AXIS), applyShapingFreq); }
+    void setShapingZZeta() { hmiValue.axis = Z_AXIS; setFloatOnClick(0, 1, 2, stepper.get_shaping_damping_ratio(Z_AXIS), applyShapingZeta); }
+  #endif
+
   void drawInputShaping_menu() {
     checkkey = ID_Menu;
     if (SET_MENU(inputShapingMenu, MSG_INPUT_SHAPING, 5)) {
       BACK_ITEM(drawMotionMenu);
       #if ENABLED(INPUT_SHAPING_X)
         MENU_ITEM(ICON_ShapingX, MSG_SHAPING_A_FREQ, onDrawShapingXFreq, setShapingXFreq);
         MENU_ITEM(ICON_ShapingX, MSG_SHAPING_A_ZETA, onDrawShapingXZeta, setShapingXZeta);
       #endif
       #if ENABLED(INPUT_SHAPING_Y)
         MENU_ITEM(ICON_ShapingY, MSG_SHAPING_B_FREQ, onDrawShapingYFreq, setShapingYFreq);
         MENU_ITEM(ICON_ShapingY, MSG_SHAPING_B_ZETA, onDrawShapingYZeta, setShapingYZeta);
       #endif
+      #if ENABLED(INPUT_SHAPING_Z)
+        MENU_ITEM(ICON_ShapingZ, MSG_SHAPING_C_FREQ, onDrawShapingZFreq, setShapingZFreq);
+        MENU_ITEM(ICON_ShapingZ, MSG_SHAPING_C_ZETA, onDrawShapingZZeta, setShapingZZeta);
+      #endif
     }
     updateMenu(inputShapingMenu);
   }
 #endif
 
 #if HAS_TRINAMIC_CONFIG
   #if AXIS_IS_TMC(X)
     void setXTMCCurrent() { setPIntOnClick(MIN_TMC_CURRENT, MAX_TMC_CURRENT, []{ stepperX.refresh_stepper_current(); }); }
   #endif
   #if AXIS_IS_TMC(Y)

commit 46e426ce9648682b1c59b75b4eabb9e647c18b05
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Sun May 12 13:28:38 2024 -0500

    üìù Use "based on" for partial ProUI (#26998)

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 923f02696d..debe3b5de0 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -15,21 +15,22 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 /**
  * DWIN Enhanced implementation for PRO UI
- * Author: Miguel A. Risco-Castillo (MRISCOC)
+ * Based on the original work of: Miguel Risco-Castillo (MRISCOC)
+ * https://github.com/mriscoc/Ender3V2S1
  * Version: 3.25.3
  * Date: 2023/05/18
  */
 
 #include "../../../inc/MarlinConfig.h"
 
 #if ENABLED(DWIN_LCD_PROUI)
 
 #include "dwin.h"
 #include "menus.h"

commit a3960dfa53394f9d105cbd23dc260ed81ff884f4
Author: David Buezas <dbuezas@users.noreply.github.com>
Date:   Thu May 9 23:20:57 2024 +0200

    üö∏ New encoder logic & debounce (#26723)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 8aa4b90d1e..923f02696d 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -1903,21 +1903,20 @@ void dwinCopySettingsFrom(const char * const buff) {
     leds.update();
   #endif
 }
 
 // Initialize or re-initialize the LCD
 void MarlinUI::init_lcd() {
   delay(750);   // Wait to wakeup screen
   const bool hs = dwinHandshake(); UNUSED(hs);
   dwinFrameSetDir(1);
   dwinJPGCacheTo1(Language_English);
-  encoderConfiguration();
 }
 
 void dwinInitScreen() {
   dwinSetColorDefaults();
   hmiInit();   // Draws boot screen
   DWINUI::init();
   DWINUI::setColors(hmiData.colorText, hmiData.colorBackground, hmiData.colorStatusBg);
   DWINUI::onTitleDraw = drawTitle;
   initMenu();
   checkkey = 255;

commit a1ecea60fdbf4f930f1aff236900b642883dfc6a
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Wed Apr 24 12:35:11 2024 +1200

    ‚úèÔ∏è MPCTEMP_START => MPC_STARTED (#27002)

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index fd4e095885..8aa4b90d1e 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -1305,21 +1305,21 @@ void eachMomentUpdate() {
         TERN_(PIDTEMP, if (hmiValue.tempControl == PIDTEMP_START) plot.update(thermalManager.wholeDegHotend(0)));
         TERN_(PIDTEMPBED, if (hmiValue.tempControl == PIDTEMPBED_START) plot.update(thermalManager.wholeDegBed()));
         TERN_(PIDTEMPCHAMBER, if (hmiValue.tempControl == PIDTEMPCHAMBER_START) plot.update(thermalManager.wholeDegChamber()));
       }
       TERN_(MPCTEMP, if (checkkey == ID_MPCProcess) plot.update(thermalManager.wholeDegHotend(0)));
       #if ENABLED(PROUI_ITEM_PLOT)
         if (checkkey == ID_PlotProcess) {
           TERN_(PIDTEMP, if (hmiValue.tempControl == PIDTEMP_START) { plot.update(thermalManager.wholeDegHotend(0)); })
           TERN_(PIDTEMPBED, if (hmiValue.tempControl == PIDTEMPBED_START) { plot.update(thermalManager.wholeDegBed()); })
           TERN_(PIDTEMPCHAMBER, if (hmiValue.tempControl == PIDTEMPCHAMBER_START) { plot.update(thermalManager.wholeDegChamber()); })
-          TERN_(MPCTEMP, if (hmiValue.tempControl == MPCTEMP_START) { plot.update(thermalManager.wholeDegHotend(0)); })
+          TERN_(MPCTEMP, if (hmiValue.tempControl == MPC_STARTED) { plot.update(thermalManager.wholeDegHotend(0)); })
           if (hmiFlag.abort_flag || hmiFlag.pause_flag || print_job_timer.isPaused()) {
             hmiReturnScreen();
           }
         }
       #endif
     #endif
   }
 
   #if HAS_STATUS_MESSAGE_TIMEOUT
     bool did_expire = ui.status_reset_callback && (*ui.status_reset_callback)();
@@ -1560,21 +1560,21 @@ void dwinLevelingDone() {
 
   celsius_t _maxtemp, _target;
   void dwinDrawPIDMPCPopup() {
     constexpr frame_rect_t gfrm = { 30, 150, DWIN_WIDTH - 60, 160 };
     DWINUI::clearMainArea();
     drawPopupBkgd();
 
     switch (hmiValue.tempControl) {
       default: return;
       #if ENABLED(MPC_AUTOTUNE)
-        case MPCTEMP_START:
+        case MPC_STARTED:
           DWINUI::drawCenteredString(hmiData.colorPopupTxt, 70, GET_TEXT_F(MSG_MPC_AUTOTUNE));
           DWINUI::drawString(hmiData.colorPopupTxt, gfrm.x, gfrm.y - DWINUI::fontHeight() - 4, F("MPC target:     Celsius"));
           DWINUI::drawCenteredString(hmiData.colorPopupTxt, 92, GET_TEXT_F(MSG_PID_FOR_NOZZLE));
           _maxtemp = thermalManager.hotend_maxtemp[0];
           _target = 200;
           break;
       #endif
       #if ENABLED(PIDTEMP)
         case PIDTEMP_START:
           DWINUI::drawCenteredString(hmiData.colorPopupTxt, 70, GET_TEXT_F(MSG_PID_AUTOTUNE));
@@ -1613,21 +1613,21 @@ void dwinLevelingDone() {
 
     void dwinDrawPlot(tempcontrol_t result) {
       hmiValue.tempControl = result;
       constexpr frame_rect_t gfrm = { 30, 135, DWIN_WIDTH - 60, 160 };
       DWINUI::clearMainArea();
       drawPopupBkgd();
       hmiSaveProcessID(ID_PlotProcess);
 
       switch (result) {
         #if ENABLED(MPCTEMP)
-          case MPCTEMP_START:
+          case MPC_STARTED:
         #elif ENABLED(PIDTEMP)
           case PIDTEMP_START:
         #endif
             title.showCaption(GET_TEXT_F(MSG_HOTEND_TEMP_GRAPH));
             DWINUI::drawCenteredString(3, hmiData.colorPopupTxt, 75, GET_TEXT_F(MSG_TEMP_NOZZLE));
             _maxtemp = thermalManager.hotend_max_target(0);
             _target = thermalManager.degTargetHotend(0);
             break;
         #if ENABLED(PIDTEMPBED)
           case PIDTEMPBED_START:
@@ -1649,21 +1649,21 @@ void dwinLevelingDone() {
       }
 
       dwinDrawString(false, 2, hmiData.colorPopupTxt, hmiData.colorPopupBg, gfrm.x, gfrm.y - DWINUI::fontHeight() - 4, F("Target:     Celsius"));
       plot.draw(gfrm, _maxtemp, _target);
       DWINUI::drawInt(false, 2, hmiData.colorStatusTxt, hmiData.colorPopupBg, 3, gfrm.x + 80, gfrm.y - DWINUI::fontHeight() - 4, _target);
       DWINUI::drawButton(BTN_Continue, 86, 305);
     }
 
     void drawHPlot() {
       TERN_(PIDTEMP, dwinDrawPlot(PIDTEMP_START));
-      TERN_(MPCTEMP, dwinDrawPlot(MPCTEMP_START));
+      TERN_(MPCTEMP, dwinDrawPlot(MPC_STARTED));
     }
     void drawBPlot() {
       TERN_(PIDTEMPBED, dwinDrawPlot(PIDTEMPBED_START));
     }
     void drawCPlot() {
       TERN_(PIDTEMPCHAMBER, dwinDrawPlot(PIDTEMPCHAMBER_START));
     }
 
   #endif // PROUI_ITEM_PLOT
 
@@ -1735,21 +1735,21 @@ void dwinLevelingDone() {
     }
   }
 
 #endif // HAS_PID_HEATING
 
 #if ENABLED(MPC_AUTOTUNE)
 
   void dwinMPCTuning(tempcontrol_t result) {
     hmiValue.tempControl = result;
     switch (result) {
-      case MPCTEMP_START:
+      case MPC_STARTED:
         hmiSaveProcessID(ID_MPCProcess);
         #if PROUI_TUNING_GRAPH
           dwinDrawPIDMPCPopup();
         #else
           dwinDrawPopup(ICON_TempTooHigh, GET_TEXT_F(MSG_MPC_AUTOTUNE), F("for Nozzle is running."));
         #endif
         break;
       case MPC_TEMP_ERROR:
         checkkey = last_checkkey;
         dwinPopupConfirm(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE_FAILED), F(STR_MPC_TEMPERATURE_ERROR));

commit 58d4494365df50927442ab78b5147969be697575
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Sun Apr 21 09:48:31 2024 +1200

    add ui_api.h include (#26977)

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index a0e2f8898b..fd4e095885 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -30,20 +30,21 @@
 #include "../../../inc/MarlinConfig.h"
 
 #if ENABLED(DWIN_LCD_PROUI)
 
 #include "dwin.h"
 #include "menus.h"
 #include "dwin_popup.h"
 
 #include "../../utf8.h"
 #include "../../marlinui.h"
+#include "../../extui/ui_api.h"
 #include "../../../MarlinCore.h"
 #include "../../../core/serial.h"
 #include "../../../core/macros.h"
 #include "../../../module/temperature.h"
 #include "../../../module/printcounter.h"
 #include "../../../module/motion.h"
 #include "../../../module/planner.h"
 #include "../../../module/stepper.h"
 #include "../../../gcode/gcode.h"
 #include "../../../gcode/queue.h"

commit 07ebb8171f68919e984f5d4f6772f3c9c35a4601
Author: Javlon Sodikov <5047093+javlonsodikov@users.noreply.github.com>
Date:   Wed Apr 17 10:25:22 2024 +0500

    ü©πFix ProUI error when !CASELIGHT_USES_BRIGHTNESS (#26976)
    
    * Fix the compile error with the case light menu
    
    Fix the compile error with the case light menu
    
    * Add failing test
    
    ---------
    
    Co-authored-by: Jason Smith <jason.inet@gmail.com>

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 4c5f91e032..a0e2f8898b 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -3138,21 +3138,21 @@ void drawControlMenu() {
   checkkey = ID_Menu;
   if (SET_MENU_R(controlMenu, selrect({103, 1, 28, 14}), MSG_CONTROL, 11)) {
     BACK_ITEM(gotoMainMenu);
     MENU_ITEM(ICON_Temperature, MSG_TEMPERATURE, onDrawTempSubMenu, drawTemperatureMenu);
     MENU_ITEM(ICON_Motion, MSG_MOTION, onDrawMotionSubMenu, drawMotionMenu);
     #if ENABLED(CASE_LIGHT_MENU)
       #if CASELIGHT_USES_BRIGHTNESS
         enableLiveCaseLightBrightness = true;  // Allow live update of brightness in control menu
         MENU_ITEM(ICON_CaseLight, MSG_CASE_LIGHT, onDrawSubMenu, drawCaseLightMenu);
       #else
-        MENU_ITEM(ICON_CaseLight, MSG_CASE_LIGHT, onDrawChkbMenu, setCaseLight, &caselight.on);
+        EDIT_ITEM(ICON_CaseLight, MSG_CASE_LIGHT, onDrawChkbMenu, setCaseLight, &caselight.on);
       #endif
     #endif
     #if ENABLED(LED_CONTROL_MENU)
       enableLiveLedColor = true;  // Allow live update of color in control menu
       MENU_ITEM(ICON_LedControl, MSG_LED_CONTROL, onDrawSubMenu, drawLedControlMenu);
     #endif
     #if ENABLED(EEPROM_SETTINGS)
       MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawWriteEeprom, writeEEPROM);
       MENU_ITEM(ICON_ReadEEPROM, MSG_LOAD_EEPROM, onDrawReadEeprom, readEEPROM);
       MENU_ITEM(ICON_ResetEEPROM, MSG_RESTORE_DEFAULTS, onDrawResetEeprom, resetEEPROM);

commit c31d9e717b207d1fa59ac942475ebcf15c1a3841
Author: Andrew Bortz <andrew@abortz.net>
Date:   Sun Apr 7 09:37:37 2024 -0700

    ü©πFix ProUI Z probe offset text (#26832)

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index bb345e5191..4c5f91e032 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -4007,21 +4007,21 @@ void drawMaxAccelMenu() {
 //=============================================================================
 
 #if HAS_BED_PROBE
 
   void drawZOffsetWizMenu() {
     checkkey = ID_Menu;
     if (SET_MENU(zOffsetWizMenu, MSG_PROBE_WIZARD, 4)) {
       BACK_ITEM(drawPrepareMenu);
       MENU_ITEM(ICON_Homing, MSG_AUTO_HOME, onDrawMenuItem, autoHome);
       MENU_ITEM(ICON_AxisD, MSG_MOVE_NOZZLE_TO_BED, onDrawMenuItem, setMoveZto0);
-      EDIT_ITEM(ICON_Zoffset, MSG_XATC_UPDATE_Z_OFFSET, onDrawPFloat2Menu, setZOffset, &BABY_Z_VAR);
+      EDIT_ITEM(ICON_Zoffset, MSG_ZPROBE_ZOFFSET, onDrawPFloat2Menu, setZOffset, &BABY_Z_VAR);
     }
     updateMenu(zOffsetWizMenu);
     if (!axis_is_trusted(Z_AXIS)) LCD_MESSAGE_F("WARNING: Z position unknown, move Z to home");
   }
 
 #endif
 
 #if ENABLED(INDIVIDUAL_AXIS_HOMING_SUBMENU)
 
   void drawHomingMenu() {

commit 87e94f456348e944ba4487aed436c762dd718966
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Mon Apr 1 16:05:11 2024 -0400

    üö∏ Update ProUI Plot graph - part 2 (#26563)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index b65adbb780..bb345e5191 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -151,20 +151,22 @@
 #if HAS_TRINAMIC_CONFIG
   #define MIN_TMC_CURRENT 100
   #define MAX_TMC_CURRENT 3000
 #endif
 
 // Editable temperature limits
 #define MIN_ETEMP   0
 #define MAX_ETEMP   thermalManager.hotend_max_target(0)
 #define MIN_BEDTEMP 0
 #define MAX_BEDTEMP BED_MAX_TARGET
+#define MIN_CHAMBERTEMP 0
+#define MAX_CHAMBERTEMP CHAMBER_MAX_TARGET
 
 #define DWIN_VAR_UPDATE_INTERVAL          500
 #define DWIN_UPDATE_INTERVAL             1000
 
 #if HAS_MESH && HAS_BED_PROBE
   #define BABY_Z_VAR probe.offset.z
 #else
   float z_offset = 0;
   #define BABY_Z_VAR z_offset
 #endif
@@ -236,25 +238,30 @@ Menu *filamentMenu = nullptr;
 Menu *temperatureMenu = nullptr;
 Menu *maxSpeedMenu = nullptr;
 Menu *maxAccelMenu = nullptr;
 #if ENABLED(CLASSIC_JERK)
   Menu *maxJerkMenu = nullptr;
 #endif
 Menu *stepsMenu = nullptr;
 #if ANY(MPC_EDIT_MENU, MPC_AUTOTUNE_MENU)
   Menu *hotendMPCMenu = nullptr;
 #endif
-#if ENABLED(PIDTEMP) && ANY(PID_EDIT_MENU, PID_AUTOTUNE_MENU)
-  Menu *hotendPIDMenu = nullptr;
-#endif
-#if ENABLED(PIDTEMPBED) && ANY(PID_EDIT_MENU, PID_AUTOTUNE_MENU)
-  Menu *bedPIDMenu = nullptr;
+#if ANY(PID_EDIT_MENU, PID_AUTOTUNE_MENU)
+  #if ENABLED(PIDTEMP)
+    Menu *hotendPIDMenu = nullptr;
+  #endif
+  #if ENABLED(PIDTEMPBED)
+    Menu *bedPIDMenu = nullptr;
+  #endif
+  #if ENABLED(PIDTEMPCHAMBER)
+    Menu *chamberPIDMenu = nullptr;
+  #endif
 #endif
 #if CASELIGHT_USES_BRIGHTNESS
   Menu *caseLightMenu = nullptr;
 #endif
 #if ENABLED(LED_CONTROL_MENU)
   Menu *ledControlMenu = nullptr;
 #endif
 #if HAS_BED_PROBE
   Menu *zOffsetWizMenu = nullptr;
 #endif
@@ -411,63 +418,64 @@ void popupPauseOrStop() {
     DWINUI::clearMainArea();
     drawPopupBkgd();
          if (select_print.now == PRINT_PAUSE_RESUME) dwinFrameAreaCopy(1, 237, 338, 269, 356, 98, 150);
     else if (select_print.now == PRINT_STOP) dwinFrameAreaCopy(1, 221, 320, 253, 336, 98, 150);
     dwinFrameAreaCopy(1, 220, 304, 264, 319, 130, 150);
     DWINUI::drawIconWB(ICON_Confirm_C, 26, 280);
     DWINUI::drawIconWB(ICON_Cancel_C, 146, 280);
     drawSelectHighlight(true);
     dwinUpdateLCD();
   }
-  else
-    dwinPopupConfirmCancel(ICON_BLTouch, select_print.now == PRINT_PAUSE_RESUME ? GET_TEXT_F(MSG_PAUSE_PRINT) : GET_TEXT_F(MSG_STOP_PRINT));
-}
-
-#if HAS_HOTEND
-
-  void popupETempTooLow() {
-    if (hmiIsChinese()) {
-      hmiSaveProcessID(ID_WaitResponse);
-      DWINUI::clearMainArea();
-      drawPopupBkgd();
-      DWINUI::drawIcon(ICON_TempTooLow, 102, 105);
-      dwinFrameAreaCopy(1, 103, 371, 136, 386,  69, 240);
-      dwinFrameAreaCopy(1, 170, 371, 270, 386, 102, 240);
-      DWINUI::drawIconWB(ICON_Confirm_C, 86, 280);
-      dwinUpdateLCD();
+  else {
+    switch (select_print.now) {
+      case PRINT_PAUSE_RESUME: dwinPopupConfirmCancel(ICON_Pause_1, GET_TEXT_F(MSG_PAUSE_PRINT)); break;
+      case PRINT_STOP: dwinPopupConfirmCancel(ICON_Stop_1, GET_TEXT_F(MSG_STOP_PRINT)); break;
+      default: break;
     }
-    else
-      dwinPopupConfirm(ICON_TempTooLow, GET_TEXT_F(MSG_HOTEND_TOO_COLD), GET_TEXT_F(MSG_PLEASE_PREHEAT));
   }
+}
 
-#endif
-
-#if HAS_HOTEND || HAS_HEATED_BED
-  void dwinPopupTemperature(const bool toohigh) {
+#if HAS_HOTEND || HAS_HEATED_BED || HAS_HEATED_CHAMBER
+  void dwinPopupTemperature(const int_fast8_t heater_id, const uint8_t state) {
     hmiSaveProcessID(ID_WaitResponse);
     if (hmiIsChinese()) {
       DWINUI::clearMainArea();
       drawPopupBkgd();
-      if (toohigh) {
+      if (state == 1) {
         DWINUI::drawIcon(ICON_TempTooHigh, 102, 165);
         dwinFrameAreaCopy(1, 103, 371, 237, 386, 52, 285);
         dwinFrameAreaCopy(1, 151, 389, 185, 402, 187, 285);
         dwinFrameAreaCopy(1, 189, 389, 271, 402, 95, 310);
       }
-      else {
+      else if (state == 0) {
         DWINUI::drawIcon(ICON_TempTooLow, 102, 165);
         dwinFrameAreaCopy(1, 103, 371, 270, 386, 52, 285);
         dwinFrameAreaCopy(1, 189, 389, 271, 402, 95, 310);
       }
+      else {
+        // Chinese "Temp Error"
+      }
+    }
+    else {
+      FSTR_P heaterstr = nullptr;
+           if (TERN0(HAS_HEATED_BED,     heater_id == H_BED))     heaterstr = F("Bed");
+      else if (TERN0(HAS_HEATED_CHAMBER, heater_id == H_CHAMBER)) heaterstr = F("Chamber");
+      else if (TERN0(HAS_HOTEND,         heater_id >= 0))         heaterstr = F("Nozzle");
+      FSTR_P errorstr;
+      uint8_t icon;
+      switch (state) {
+        case 0:  errorstr = GET_TEXT_F(MSG_TEMP_TOO_LOW);       icon = ICON_TempTooLow;  break;
+        case 1:  errorstr = GET_TEXT_F(MSG_TEMP_TOO_HIGH);      icon = ICON_TempTooHigh; break;
+        default: errorstr = GET_TEXT_F(MSG_ERR_HEATING_FAILED); icon = ICON_Temperature; break; // May be thermal runaway, temp malfunction, etc.
+      }
+      dwinShowPopup(icon, heaterstr, errorstr, BTN_Continue);
     }
-    else
-      dwinShowPopup(toohigh ? ICON_TempTooHigh : ICON_TempTooLow, F("Nozzle or Bed temperature"), toohigh ? F("is too high") : F("is too low"), BTN_Continue);
   }
 #endif
 
 //
 // Draw status line
 //
 void dwinDrawStatusLine(const char *text) {
   dwinDrawRectangle(1, hmiData.colorStatusBg, 0, STATUS_Y, DWIN_WIDTH, STATUS_Y + 20);
   if (text) DWINUI::drawCenteredString(hmiData.colorStatusTxt, STATUS_Y + 2, text);
 }
@@ -574,41 +582,42 @@ void drawPrintProgressElapsed() {
     MString<12> buf;
     buf.setf(F("%02i:%02i "), _remain_time / 3600, (_remain_time % 3600) / 60);
     DWINUI::drawString(hmiData.colorText, hmiData.colorBackground, 181, 192, buf);
   }
 #endif
 
 void ICON_ResumeOrPause() {
   if (checkkey == ID_PrintProcess) (print_job_timer.isPaused() || hmiFlag.pause_flag) ? ICON_Resume() : ICON_Pause();
 }
 
-// Update filename on print
-void dwinPrintHeader(const char *text = nullptr) {
+// Print a string (up to 30 characters) in the header,
+// e.g., The filename or string sent with M75.
+void dwinPrintHeader(const char * const cstr/*=nullptr*/) {
   static char headertxt[31] = "";  // Print header text
-  if (text) {
-    const int8_t size = _MIN(30U, strlen_P(text));
-    for (uint8_t i = 0; i < size; ++i) headertxt[i] = text[i];
+  if (cstr) {
+    const int8_t size = _MIN(30U, strlen(cstr));
+    for (uint8_t i = 0; i < size; ++i) headertxt[i] = cstr[i];
     headertxt[size] = '\0';
   }
   if (checkkey == ID_PrintProcess || checkkey == ID_PrintDone) {
-    dwinDrawRectangle(1, hmiData.colorBackground, 0, 60, DWIN_WIDTH, 60+16);
+    dwinDrawRectangle(1, hmiData.colorBackground, 0, 60, DWIN_WIDTH, 60 + 16);
     DWINUI::drawCenteredString(60, headertxt);
   }
 }
 
 void drawPrintProcess() {
   if (hmiIsChinese())
     title.frameCopy(30, 1, 42, 14);                     // "Printing"
   else
     title.showCaption(GET_TEXT_F(MSG_PRINTING));
   DWINUI::clearMainArea();
-  dwinPrintHeader(nullptr);
+  dwinPrintHeader();
   drawPrintLabels();
   DWINUI::drawIcon(ICON_PrintTime, 15, 173);
   DWINUI::drawIcon(ICON_RemainTime, 150, 171);
   drawPrintProgressBar();
   drawPrintProgressElapsed();
   TERN_(SHOW_REMAINING_TIME, drawPrintProgressRemain());
   ICON_Tune();
   ICON_ResumeOrPause();
   ICON_Stop();
 }
@@ -622,21 +631,21 @@ void gotoPrintProcess() {
     TERN_(DASH_REDRAW, dwinRedrawDash());
   }
   dwinUpdateLCD();
 }
 
 void drawPrintDone() {
   TERN_(SET_PROGRESS_PERCENT, ui.set_progress_done());
   TERN_(SET_REMAINING_TIME, ui.reset_remaining_time());
   title.showCaption(GET_TEXT_F(MSG_PRINT_DONE));
   DWINUI::clearMainArea();
-  dwinPrintHeader(nullptr);
+  dwinPrintHeader();
   #if HAS_GCODE_PREVIEW
     const bool haspreview = preview.valid();
     if (haspreview) {
       preview.show();
       DWINUI::drawButton(BTN_Continue, 86, 295);
     }
   #else
     constexpr bool haspreview = false;
   #endif
 
@@ -1024,21 +1033,21 @@ void drawPrintFileMenu() {
 //
 void hmiSDCardUpdate() {
   if (hmiFlag.home_flag) return;
   if (DWIN_lcd_sd_status != card.isMounted()) {
     DWIN_lcd_sd_status = card.isMounted();
     resetMenu(fileMenu);
     if (isMenu(fileMenu)) {
       currentMenu = nullptr;
       drawPrintFileMenu();
     }
-    if (!DWIN_lcd_sd_status && sdPrinting()) ui.abort_print();  // Media removed while printing
+    if (!DWIN_lcd_sd_status && sdPrinting()) ExtUI::stopPrint();  // Media removed while printing
   }
 }
 
 /**
  * Dash board and indicators
  */
 
 void dwinDrawDashboard() {
   dwinDrawRectangle(1, hmiData.colorBackground, 0, STATUS_Y + 21, DWIN_WIDTH, DWIN_HEIGHT - 1);
   dwinDrawRectangle(1, hmiData.colorSplitLine, 0, 449, DWIN_WIDTH, 451);
@@ -1053,21 +1062,21 @@ void dwinDrawDashboard() {
     DWINUI::drawInt(DWIN_FONT_STAT, hmiData.colorIndicator, hmiData.colorBackground, 3, 28, 384, thermalManager.wholeDegHotend(0));
     DWINUI::drawString(DWIN_FONT_STAT, hmiData.colorIndicator, hmiData.colorBackground, 25 + 3 * STAT_CHR_W + 5, 384, F("/"));
     DWINUI::drawInt(DWIN_FONT_STAT, hmiData.colorIndicator, hmiData.colorBackground, 3, 25 + 4 * STAT_CHR_W + 6, 384, thermalManager.degTargetHotend(0));
 
     DWINUI::drawIcon(ICON_StepE, 113, 416);
     DWINUI::drawInt(DWIN_FONT_STAT, hmiData.colorIndicator, hmiData.colorBackground, 3, 116 + 2 * STAT_CHR_W, 417, planner.flow_percentage[0]);
     DWINUI::drawString(DWIN_FONT_STAT, hmiData.colorIndicator, hmiData.colorBackground, 116 + 5 * STAT_CHR_W + 2, 417, F("%"));
   #endif
 
   #if HAS_HEATED_BED
-    DWINUI::drawIcon(ICON_BedTemp, 10, 416);
+    DWINUI::drawIcon(ICON_SetBedTemp, 10, 416);
     DWINUI::drawInt(DWIN_FONT_STAT, hmiData.colorIndicator, hmiData.colorBackground, 3, 28, 417, thermalManager.wholeDegBed());
     DWINUI::drawString(DWIN_FONT_STAT, hmiData.colorIndicator, hmiData.colorBackground, 25 + 3 * STAT_CHR_W + 5, 417, F("/"));
     DWINUI::drawInt(DWIN_FONT_STAT, hmiData.colorIndicator, hmiData.colorBackground, 3, 25 + 4 * STAT_CHR_W + 6, 417, thermalManager.degTargetBed());
   #endif
 
   DWINUI::drawIcon(ICON_Speed, 113, 383);
   DWINUI::drawInt(DWIN_FONT_STAT, hmiData.colorIndicator, hmiData.colorBackground, 3, 116 + 2 * STAT_CHR_W, 384, feedrate_percentage);
   IF_DISABLED(SHOW_SPEED_IND, DWINUI::drawString(DWIN_FONT_STAT, hmiData.colorIndicator, hmiData.colorBackground, 116 + 5 * STAT_CHR_W + 2, 384, F("%")));
 
   #if HAS_FAN
@@ -1148,22 +1157,22 @@ void hmiMainMenu() {
       case PAGE_CONTROL: drawControlMenu(); break;
       case PAGE_ADVANCE: drawAdvancedSettingsMenu(); break;
     }
   }
   dwinUpdateLCD();
 }
 
 // Pause or Stop popup
 void onClickPauseOrStop() {
   switch (select_print.now) {
-    case PRINT_PAUSE_RESUME: if (hmiFlag.select_flag) ui.pause_print(); break; // Confirm pause
-    case PRINT_STOP: if (hmiFlag.select_flag) ui.abort_print(); break; // Stop confirmed then abort print
+    case PRINT_PAUSE_RESUME: if (hmiFlag.select_flag) ExtUI::pausePrint(); break; // Confirm pause
+    case PRINT_STOP: if (hmiFlag.select_flag) ExtUI::stopPrint(); break; // Stop confirmed then abort print
     default: break;
   }
   return gotoPrintProcess();
 }
 
 // Printing
 void hmiPrinting() {
   EncoderState encoder_diffState = get_encoder_state();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
   // Avoid flicker by updating only the previous menu
@@ -1183,21 +1192,21 @@ void hmiPrinting() {
         case PRINT_PAUSE_RESUME: ICON_ResumeOrPause(); ICON_Stop(); break;
         case PRINT_STOP: ICON_Stop(); break;
       }
     }
   }
   else if (encoder_diffState == ENCODER_DIFF_ENTER) {
     switch (select_print.now) {
       case PRINT_SETUP: drawTuneMenu(); break;
       case PRINT_PAUSE_RESUME:
         if (printingIsPaused()) {  // If printer is already in pause
-          ui.resume_print();
+          ExtUI::resumePrint();
           break;
         }
         else
           return gotoPopup(popupPauseOrStop, onClickPauseOrStop);
       case PRINT_STOP:
         return gotoPopup(popupPauseOrStop, onClickPauseOrStop);
       default: break;
     }
   }
   dwinUpdateLCD();
@@ -1206,20 +1215,34 @@ void hmiPrinting() {
 #include "../../../libs/buzzer.h"
 
 void drawMainArea() {
   switch (checkkey) {
     case ID_MainMenu:         drawMainMenu(); break;
     case ID_PrintProcess:     drawPrintProcess(); break;
     case ID_PrintDone:        drawPrintDone(); break;
     #if HAS_ESDIAG
       case ID_ESDiagProcess:  drawEndStopDiag(); break;
     #endif
+    #if ENABLED(PROUI_ITEM_PLOT)
+      case ID_PlotProcess:
+        switch (hmiValue.tempControl) {
+          #if ENABLED(PIDTEMP)
+            case PIDTEMP_START: drawHPlot(); break;
+          #endif
+          #if ENABLED(PIDTEMPBED)
+            case PIDTEMPBED_START: drawBPlot(); break;
+          #endif
+          #if ENABLED(PIDTEMPCHAMBER)
+            case PIDTEMPCHAMBER_START: drawCPlot(); break;
+          #endif
+        } break;
+    #endif
     case ID_Popup:            popupDraw(); break;
     #if HAS_LOCKSCREEN
       case ID_Locked:         lockScreen.draw(); break;
     #endif
     case ID_Menu:
     case ID_SetInt:
     case ID_SetPInt:
     case ID_SetIntNoDraw:
     case ID_SetFloat:
     case ID_SetPFloat:        ReDrawMenu(true); break;
@@ -1273,26 +1296,28 @@ void eachMomentUpdate() {
     next_var_update_ms = ms + DWIN_VAR_UPDATE_INTERVAL;
     blink = !blink;
     updateVariable();
     #if HAS_ESDIAG
       if (checkkey == ID_ESDiagProcess) esDiag.update();
     #endif
     #if PROUI_TUNING_GRAPH
       if (checkkey == ID_PIDProcess) {
         TERN_(PIDTEMP, if (hmiValue.tempControl == PIDTEMP_START) plot.update(thermalManager.wholeDegHotend(0)));
         TERN_(PIDTEMPBED, if (hmiValue.tempControl == PIDTEMPBED_START) plot.update(thermalManager.wholeDegBed()));
+        TERN_(PIDTEMPCHAMBER, if (hmiValue.tempControl == PIDTEMPCHAMBER_START) plot.update(thermalManager.wholeDegChamber()));
       }
       TERN_(MPCTEMP, if (checkkey == ID_MPCProcess) plot.update(thermalManager.wholeDegHotend(0)));
       #if ENABLED(PROUI_ITEM_PLOT)
         if (checkkey == ID_PlotProcess) {
           TERN_(PIDTEMP, if (hmiValue.tempControl == PIDTEMP_START) { plot.update(thermalManager.wholeDegHotend(0)); })
           TERN_(PIDTEMPBED, if (hmiValue.tempControl == PIDTEMPBED_START) { plot.update(thermalManager.wholeDegBed()); })
+          TERN_(PIDTEMPCHAMBER, if (hmiValue.tempControl == PIDTEMPCHAMBER_START) { plot.update(thermalManager.wholeDegChamber()); })
           TERN_(MPCTEMP, if (hmiValue.tempControl == MPCTEMP_START) { plot.update(thermalManager.wholeDegHotend(0)); })
           if (hmiFlag.abort_flag || hmiFlag.pause_flag || print_job_timer.isPaused()) {
             hmiReturnScreen();
           }
         }
       #endif
     #endif
   }
 
   #if HAS_STATUS_MESSAGE_TIMEOUT
@@ -1350,31 +1375,32 @@ void eachMomentUpdate() {
       #endif
 
       // Elapsed print time
       static uint16_t _printtime = 0;
       const uint16_t min = (print_job_timer.duration() % 3600) / 60;
       if (_printtime != min) { // 1 minute update
         _printtime = min;
         drawPrintProgressElapsed();
       }
     }
-    #if ENABLED(POWER_LOSS_RECOVERY)
-      else if (DWIN_lcd_sd_status && recovery.dwin_flag) { // Resume print before power off
+    #if HAS_PLR_UI_FLAG
+      else if (DWIN_lcd_sd_status && recovery.ui_flag_resume) { // Resume interrupted print
         return gotoPowerLossRecovery();
       }
     #endif
 
     dwinUpdateLCD();
   }
 }
 
 #if ENABLED(POWER_LOSS_RECOVERY)
+
   void popupPowerLossRecovery() {
     DWINUI::clearMainArea();
     drawPopupBkgd();
     if (hmiIsChinese()) {
       dwinFrameAreaCopy(1, 160, 338, 235, 354, 98, 115);
       dwinFrameAreaCopy(1, 103, 321, 271, 335, 52, 167);
       DWINUI::drawIconWB(ICON_Cancel_C,    26, 280);
       DWINUI::drawIconWB(ICON_Continue_C, 146, 280);
     }
     else {
@@ -1400,21 +1426,21 @@ void eachMomentUpdate() {
       return gotoMainMenu();
     }
     else {
       hmiSaveProcessID(ID_NothingToDo);
       select_print.set(PRINT_SETUP);
       queue.inject(F("M1000"));
     }
   }
 
   void gotoPowerLossRecovery() {
-    recovery.dwin_flag = false;
+    recovery.ui_flag_resume = false;
     LCD_MESSAGE(MSG_CONTINUE_PRINT_JOB);
     gotoPopup(popupPowerLossRecovery, onClickPowerLossRecovery);
   }
 
 #endif // POWER_LOSS_RECOVERY
 
 void dwinHandleScreen() {
   switch (checkkey) {
     case ID_MainMenu:     hmiMainMenu(); break;
     case ID_Menu:         hmiMenu(); break;
@@ -1428,35 +1454,38 @@ void dwinHandleScreen() {
     #if HAS_LOCKSCREEN
       case ID_Locked: hmiLockScreen(); break;
     #endif
     TERN_(HAS_ESDIAG, case ID_ESDiagProcess:)
     TERN_(PROUI_ITEM_PLOT, case ID_PlotProcess:)
     case ID_PrintDone:
     case ID_WaitResponse: hmiWaitForUser(); break;
 
     TERN_(HAS_BED_PROBE, case ID_Leveling:)
     case ID_Homing:
-    case ID_PIDProcess:
+    TERN_(HAS_PID_HEATING, case ID_PIDProcess:)
+    TERN_(MPCTEMP, case ID_MPCProcess:)
     case ID_NothingToDo:
     default: break;
   }
 }
 
 bool idIsPopUp() {    // If ID is popup...
   switch (checkkey) {
     TERN_(HAS_BED_PROBE, case ID_Leveling:)
     TERN_(HAS_ESDIAG, case ID_ESDiagProcess:)
     case ID_NothingToDo:
     case ID_WaitResponse:
     case ID_Popup:
     case ID_Homing:
-    case ID_PIDProcess:
+    TERN_(HAS_PID_HEATING, case ID_PIDProcess:)
+    TERN_(MPCTEMP, case ID_MPCProcess:)
+    TERN_(PROUI_ITEM_PLOT, case ID_PlotProcess:)
       return true;
     default: break;
   }
   return false;
 }
 
 void hmiSaveProcessID(const uint8_t id) {
   if (checkkey == id) return;
   if (!idIsPopUp()) last_checkkey = checkkey; // If previous is not a popup
   checkkey = id;
@@ -1475,53 +1504,42 @@ void hmiSaveProcessID(const uint8_t id) {
 void hmiReturnScreen() {
   checkkey = last_checkkey;
   wait_for_user = false;
   drawMainArea();
 }
 
 void dwinHomingStart() {
   hmiFlag.home_flag = true;
   hmiSaveProcessID(ID_Homing);
   title.showCaption(GET_TEXT_F(MSG_HOMING));
-  dwinShowPopup(ICON_BLTouch, GET_TEXT_F(MSG_HOMING), GET_TEXT_F(MSG_PLEASE_WAIT));
+  #if ANY(TJC_DISPLAY, DACAI_DISPLAY)
+    dwinShowPopup(ICON_BLTouch, GET_TEXT_F(MSG_HOMING), GET_TEXT_F(MSG_PLEASE_WAIT));
+  #else
+    dwinShowPopup(ICON_Printer_0, GET_TEXT_F(MSG_HOMING), GET_TEXT_F(MSG_PLEASE_WAIT));
+  #endif
 }
 
 void dwinHomingDone() {
   hmiFlag.home_flag = false;
   if (last_checkkey == ID_PrintDone)
     gotoPrintDone();
   else
     hmiReturnScreen();
 }
 
 void dwinLevelingStart() {
   #if HAS_BED_PROBE
     hmiSaveProcessID(ID_Leveling);
     title.showCaption(GET_TEXT_F(MSG_BED_LEVELING));
     dwinShowPopup(ICON_AutoLeveling, GET_TEXT_F(MSG_BED_LEVELING), GET_TEXT_F(MSG_PLEASE_WAIT));
     #if ALL(AUTO_BED_LEVELING_UBL, PREHEAT_BEFORE_LEVELING)
-      #if HAS_BED_PROBE
-        if (!DEBUGGING(DRYRUN)) probe.preheat_for_probing(LEVELING_NOZZLE_TEMP, hmiData.bedLevT);
-      #else
-        #if HAS_HOTEND
-          if (!DEBUGGING(DRYRUN) && thermalManager.degTargetHotend(0) < LEVELING_NOZZLE_TEMP) {
-            thermalManager.setTargetHotend(LEVELING_NOZZLE_TEMP, 0);
-            thermalManager.wait_for_hotend(0);
-          }
-        #endif
-        #if HAS_HEATED_BED
-          if (!DEBUGGING(DRYRUN) && thermalManager.degTargetBed() < hmiData.bedLevT) {
-            thermalManager.setTargetBed(hmiData.bedLevT);
-            thermalManager.wait_for_bed_heating();
-          }
-        #endif
-      #endif
+      if (!DEBUGGING(DRYRUN)) probe.preheat_for_probing(LEVELING_NOZZLE_TEMP, hmiData.bedLevT);
     #endif
   #elif ENABLED(MESH_BED_LEVELING)
     drawManualMeshMenu();
   #endif
 }
 
 void dwinLevelingDone() {
   TERN_(HAS_MESH, gotoMeshViewer(true));
 }
 
@@ -1544,163 +1562,186 @@ void dwinLevelingDone() {
     constexpr frame_rect_t gfrm = { 30, 150, DWIN_WIDTH - 60, 160 };
     DWINUI::clearMainArea();
     drawPopupBkgd();
 
     switch (hmiValue.tempControl) {
       default: return;
       #if ENABLED(MPC_AUTOTUNE)
         case MPCTEMP_START:
           DWINUI::drawCenteredString(hmiData.colorPopupTxt, 70, GET_TEXT_F(MSG_MPC_AUTOTUNE));
           DWINUI::drawString(hmiData.colorPopupTxt, gfrm.x, gfrm.y - DWINUI::fontHeight() - 4, F("MPC target:     Celsius"));
-          DWINUI::drawCenteredString(hmiData.colorPopupTxt, 92, F("for NOZZLE is running."));
+          DWINUI::drawCenteredString(hmiData.colorPopupTxt, 92, GET_TEXT_F(MSG_PID_FOR_NOZZLE));
           _maxtemp = thermalManager.hotend_maxtemp[0];
           _target = 200;
           break;
       #endif
       #if ENABLED(PIDTEMP)
         case PIDTEMP_START:
           DWINUI::drawCenteredString(hmiData.colorPopupTxt, 70, GET_TEXT_F(MSG_PID_AUTOTUNE));
           DWINUI::drawString(hmiData.colorPopupTxt, gfrm.x, gfrm.y - DWINUI::fontHeight() - 4, F("PID target:     Celsius"));
-          DWINUI::drawCenteredString(hmiData.colorPopupTxt, 92, F("for NOZZLE is running."));
+          DWINUI::drawCenteredString(hmiData.colorPopupTxt, 92, GET_TEXT_F(MSG_PID_FOR_NOZZLE));
           _maxtemp = thermalManager.hotend_maxtemp[0];
-          _target = hmiData.hotendPidT;
+          _target = hmiData.hotendPIDT;
           break;
       #endif
       #if ENABLED(PIDTEMPBED)
         case PIDTEMPBED_START:
           DWINUI::drawCenteredString(hmiData.colorPopupTxt, 70, GET_TEXT_F(MSG_PID_AUTOTUNE));
           DWINUI::drawString(hmiData.colorPopupTxt, gfrm.x, gfrm.y - DWINUI::fontHeight() - 4, F("PID target:     Celsius"));
-          DWINUI::drawCenteredString(hmiData.colorPopupTxt, 92, F("for BED is running."));
+          DWINUI::drawCenteredString(hmiData.colorPopupTxt, 92, GET_TEXT_F(MSG_PID_FOR_BED));
           _maxtemp = BED_MAXTEMP;
-          _target = hmiData.bedPidT;
+          _target = hmiData.bedPIDT;
+          break;
+      #endif
+      #if ENABLED(PIDTEMPCHAMBER)
+        case PIDTEMPCHAMBER_START:
+          DWINUI::drawCenteredString(hmiData.colorPopupTxt, 70, GET_TEXT_F(MSG_PID_AUTOTUNE));
+          DWINUI::drawString(hmiData.colorPopupTxt, gfrm.x, gfrm.y - DWINUI::fontHeight() - 4, F("PID target:     Celsius"));
+          DWINUI::drawCenteredString(hmiData.colorPopupTxt, 92, GET_TEXT_F(MSG_PID_FOR_CHAMBER));
+          _maxtemp = CHAMBER_MAXTEMP;
+          _target = hmiData.chamberPIDT;
           break;
       #endif
     }
 
     plot.draw(gfrm, _maxtemp, _target);
     DWINUI::drawInt(false, 2, hmiData.colorStatusTxt, hmiData.colorPopupTxt, 3, gfrm.x + 92, gfrm.y - DWINUI::fontHeight() - 6, _target);
   }
 
   // Plot Temperature Graph (PID Tuning Graph)
   #if ENABLED(PROUI_ITEM_PLOT)
 
     void dwinDrawPlot(tempcontrol_t result) {
       hmiValue.tempControl = result;
-      constexpr frame_rect_t gfrm = {30, 135, DWIN_WIDTH - 60, 160};
+      constexpr frame_rect_t gfrm = { 30, 135, DWIN_WIDTH - 60, 160 };
       DWINUI::clearMainArea();
       drawPopupBkgd();
       hmiSaveProcessID(ID_PlotProcess);
 
       switch (result) {
         #if ENABLED(MPCTEMP)
           case MPCTEMP_START:
         #elif ENABLED(PIDTEMP)
           case PIDTEMP_START:
         #endif
             title.showCaption(GET_TEXT_F(MSG_HOTEND_TEMP_GRAPH));
-            DWINUI::drawCenteredString(3, hmiData.colorPopupTxt, 75, F("Nozzle Temperature"));
+            DWINUI::drawCenteredString(3, hmiData.colorPopupTxt, 75, GET_TEXT_F(MSG_TEMP_NOZZLE));
             _maxtemp = thermalManager.hotend_max_target(0);
             _target = thermalManager.degTargetHotend(0);
             break;
         #if ENABLED(PIDTEMPBED)
           case PIDTEMPBED_START:
             title.showCaption(GET_TEXT_F(MSG_BED_TEMP_GRAPH));
-            DWINUI::drawCenteredString(3, hmiData.colorPopupTxt, 75, F("Bed Temperature"));
+            DWINUI::drawCenteredString(3, hmiData.colorPopupTxt, 75, GET_TEXT_F(MSG_TEMP_BED));
             _maxtemp = BED_MAX_TARGET;
             _target = thermalManager.degTargetBed();
             break;
         #endif
+        #if ENABLED(PIDTEMPCHAMBER)
+          case PIDTEMPCHAMBER_START:
+            title.showCaption(GET_TEXT_F(MSG_CHAMBER_TEMP_GRAPH));
+            DWINUI::drawCenteredString(3, hmiData.colorPopupTxt, 75, GET_TEXT_F(MSG_TEMP_CHAMBER));
+            _maxtemp = CHAMBER_MAX_TARGET;
+            _target = thermalManager.degTargetChamber();
+            break;
+        #endif
         default: break;
       }
 
       dwinDrawString(false, 2, hmiData.colorPopupTxt, hmiData.colorPopupBg, gfrm.x, gfrm.y - DWINUI::fontHeight() - 4, F("Target:     Celsius"));
       plot.draw(gfrm, _maxtemp, _target);
       DWINUI::drawInt(false, 2, hmiData.colorStatusTxt, hmiData.colorPopupBg, 3, gfrm.x + 80, gfrm.y - DWINUI::fontHeight() - 4, _target);
       DWINUI::drawButton(BTN_Continue, 86, 305);
-      dwinUpdateLCD();
     }
 
     void drawHPlot() {
       TERN_(PIDTEMP, dwinDrawPlot(PIDTEMP_START));
       TERN_(MPCTEMP, dwinDrawPlot(MPCTEMP_START));
     }
     void drawBPlot() {
       TERN_(PIDTEMPBED, dwinDrawPlot(PIDTEMPBED_START));
     }
+    void drawCPlot() {
+      TERN_(PIDTEMPCHAMBER, dwinDrawPlot(PIDTEMPCHAMBER_START));
+    }
 
   #endif // PROUI_ITEM_PLOT
 
 #endif // PROUI_TUNING_GRAPH
 
-#if PROUI_PID_TUNE
+#if HAS_PID_HEATING
 
-  void dwinStartM303(const bool seenC, const int c, const bool seenS, const heater_id_t hid, const celsius_t temp) {
-    if (seenC) hmiData.pidCycles = c;
-    if (seenS) {
-      switch (hid) {
-        #if ENABLED(PIDTEMP)
-          case 0 ... HOTENDS - 1: hmiData.hotendPidT = temp; break;
-        #endif
-        #if ENABLED(PIDTEMPBED)
-          case H_BED: hmiData.bedPidT = temp; break;
-        #endif
-        default: break;
-      }
+  void dwinStartM303(const int count, const heater_id_t hid, const celsius_t temp) {
+    hmiData.pidCycles = count;
+    switch (hid) {
+      #if ENABLED(PIDTEMP)
+        case 0 ... HOTENDS - 1: hmiData.hotendPIDT = temp; break;
+      #endif
+      #if ENABLED(PIDTEMPBED)
+        case H_BED: hmiData.bedPIDT = temp; break;
+      #endif
+      #if ENABLED(PIDTEMPCHAMBER)
+        case H_CHAMBER: hmiData.chamberPIDT = temp; break;
+      #endif
+      default: break;
     }
   }
 
-  void dwinPidTuning(tempcontrol_t result) {
+  void dwinPIDTuning(tempcontrol_t result) {
     hmiValue.tempControl = result;
     switch (result) {
       #if ENABLED(PIDTEMP)
         case PIDTEMP_START:
           hmiSaveProcessID(ID_PIDProcess);
           #if PROUI_TUNING_GRAPH
             dwinDrawPIDMPCPopup();
           #else
-            dwinDrawPopup(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE), F("for Nozzle is running."));
+            dwinDrawPopup(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE), GET_TEXT_F(MSG_PID_FOR_NOZZLE));
           #endif
           break;
-        case PID_TEMP_TOO_HIGH:
-          checkkey = last_checkkey;
-          dwinPopupConfirm(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE_FAILED), GET_TEXT_F(MSG_TEMP_TOO_HIGH));
-          break;
       #endif
       #if ENABLED(PIDTEMPBED)
         case PIDTEMPBED_START:
           hmiSaveProcessID(ID_PIDProcess);
-          #if PROUI_TUNING_GRAPH
-            dwinDrawPIDMPCPopup();
-          #else
-            dwinDrawPopup(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE), F("for BED is running."));
-          #endif
+          dwinDrawPopup(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE), GET_TEXT_F(MSG_PID_FOR_BED));
+          break;
+      #endif
+      #if ENABLED(PIDTEMPCHAMBER)
+        case PIDTEMPCHAMBER_START:
+          hmiSaveProcessID(ID_PIDProcess);
+          dwinDrawPopup(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE), GET_TEXT_F(MSG_PID_FOR_CHAMBER));
           break;
       #endif
       case PID_BAD_HEATER_ID:
         checkkey = last_checkkey;
         dwinPopupConfirm(ICON_TempTooLow, GET_TEXT_F(MSG_PID_AUTOTUNE_FAILED), GET_TEXT_F(MSG_PID_BAD_HEATER_ID));
         break;
       case PID_TUNING_TIMEOUT:
         checkkey = last_checkkey;
         dwinPopupConfirm(ICON_TempTooHigh, GET_TEXT_F(MSG_ERROR), GET_TEXT_F(MSG_PID_TIMEOUT));
         break;
+      case PID_TEMP_TOO_HIGH:
+        checkkey = last_checkkey;
+        dwinPopupConfirm(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE_FAILED), GET_TEXT_F(MSG_TEMP_TOO_HIGH));
+        break;
       case AUTOTUNE_DONE:
         checkkey = last_checkkey;
         dwinPopupConfirm(ICON_TempTooLow, GET_TEXT_F(MSG_PID_AUTOTUNE), GET_TEXT_F(MSG_BUTTON_DONE));
         break;
       default:
         checkkey = last_checkkey;
+        dwinPopupConfirm(ICON_Info_0, GET_TEXT_F(MSG_ERROR), GET_TEXT_F(MSG_STOPPING));
         break;
     }
   }
 
-#endif // PROUI_PID_TUNE
+#endif // HAS_PID_HEATING
 
 #if ENABLED(MPC_AUTOTUNE)
 
   void dwinMPCTuning(tempcontrol_t result) {
     hmiValue.tempControl = result;
     switch (result) {
       case MPCTEMP_START:
         hmiSaveProcessID(ID_MPCProcess);
         #if PROUI_TUNING_GRAPH
           dwinDrawPIDMPCPopup();
@@ -1801,26 +1842,28 @@ void dwinSetColorDefaults() {
   hmiData.colorPopupBg    = defColorPopupBg;
   hmiData.colorPopupTxt   = defColorPopupTxt;
   hmiData.colorAlertBg    = defColorAlertBg;
   hmiData.colorAlertTxt   = defColorAlertTxt;
   hmiData.colorPercentTxt = defColorPercentTxt;
   hmiData.colorBarfill    = defColorBarfill;
   hmiData.colorIndicator  = defColorIndicator;
   hmiData.colorCoordinate = defColorCoordinate;
 }
 
+static_assert(ExtUI::eeprom_data_size >= sizeof(hmi_data_t), "Insufficient space in EEPROM for UI parameters");
+
 void dwinSetDataDefaults() {
   dwinSetColorDefaults();
   DWINUI::setColors(hmiData.colorText, hmiData.colorBackground, hmiData.colorStatusBg);
-  TERN_(PIDTEMP, hmiData.hotendPidT = DEF_HOTENDPIDT);
-  TERN_(PIDTEMPBED, hmiData.bedPidT = DEF_BEDPIDT);
-  TERN_(PROUI_PID_TUNE, hmiData.pidCycles = DEF_PIDCYCLES);
+  TERN_(PIDTEMP, hmiData.hotendPIDT = DEF_HOTENDPIDT);
+  TERN_(PIDTEMPBED, hmiData.bedPIDT = DEF_BEDPIDT);
+  TERN_(HAS_PID_HEATING, hmiData.pidCycles = DEF_PIDCYCLES);
   #if ENABLED(PREVENT_COLD_EXTRUSION)
     hmiData.extMinT = EXTRUDE_MINTEMP;
     applyExtMinT();
   #endif
   TERN_(PREHEAT_BEFORE_LEVELING, hmiData.bedLevT = LEVELING_BED_TEMP);
   TERN_(BAUD_RATE_GCODE, setBaud250K());
   #if ALL(LCD_BED_TRAMMING, HAS_BED_PROBE)
     hmiData.fullManualTramming = DISABLED(BED_TRAMMING_USE_PROBE);
   #endif
   #if ENABLED(PROUI_MEDIASORT)
@@ -1828,26 +1871,25 @@ void dwinSetDataDefaults() {
     card.setSortOn(TERN(SDSORT_REVERSE, AS_REV, AS_FWD));
   #endif
   hmiData.mediaAutoMount = ENABLED(HAS_SD_EXTENDER);
   #if ALL(INDIVIDUAL_AXIS_HOMING_SUBMENU, MESH_BED_LEVELING)
     hmiData.zAfterHoming = DEF_Z_AFTER_HOMING;
   #endif
   #if ALL(LED_CONTROL_MENU, HAS_COLOR_LEDS)
     TERN_(LED_COLOR_PRESETS, leds.set_default());
     applyLEDColor();
   #endif
-  TERN_(ADAPTIVE_STEP_SMOOTHING, hmiData.adaptiveStepSmoothing = true);
   TERN_(HAS_GCODE_PREVIEW, hmiData.enablePreview = true);
 }
 
 void dwinCopySettingsTo(char * const buff) {
-  memcpy(buff, &hmiData, eeprom_data_size);
+  memcpy(buff, &hmiData, sizeof(hmi_data_t));
 }
 
 void dwinCopySettingsFrom(const char * const buff) {
   memcpy(&hmiData, buff, sizeof(hmi_data_t));
   if (hmiData.colorText == hmiData.colorBackground) dwinSetColorDefaults();
   DWINUI::setColors(hmiData.colorText, hmiData.colorBackground, hmiData.colorStatusBg);
   TERN_(PREVENT_COLD_EXTRUSION, applyExtMinT());
   feedrate_percentage = 100;
   TERN_(BAUD_RATE_GCODE, hmiSetBaudRate());
   #if ALL(LED_CONTROL_MENU, HAS_COLOR_LEDS)
@@ -1888,21 +1930,25 @@ void MarlinUI::update() {
   hmiSDCardUpdate();  // SD card update
   eachMomentUpdate(); // Status update
   dwinHandleScreen(); // Rotary encoder update
 }
 
 #if HAS_LCD_BRIGHTNESS
   void MarlinUI::_set_brightness() { dwinLCDBrightness(backlight ? brightness : 0); }
 #endif
 
 void MarlinUI::kill_screen(FSTR_P const lcd_error, FSTR_P const) {
-  dwinDrawPopup(ICON_BLTouch, GET_TEXT_F(MSG_PRINTER_KILLED), lcd_error);
+  #if ANY(TJC_DISPLAY, DACAI_DISPLAY)
+    dwinDrawPopup(ICON_BLTouch, GET_TEXT_F(MSG_PRINTER_KILLED), lcd_error);
+  #else
+    dwinDrawPopup(ICON_Printer_0, GET_TEXT_F(MSG_PRINTER_KILLED), lcd_error);
+  #endif
   DWINUI::drawCenteredString(hmiData.colorPopupTxt, 270, GET_TEXT_F(MSG_TURN_OFF));
   dwinUpdateLCD();
 }
 
 void dwinRebootScreen() {
   dwinFrameClear(COLOR_BG_BLACK);
   dwinJPGShowAndCache(0);
   DWINUI::drawCenteredString(COLOR_WHITE, 220, GET_TEXT_F(MSG_PLEASE_WAIT_REBOOT));
   dwinUpdateLCD();
   safe_delay(500);
@@ -1913,46 +1959,28 @@ void dwinRedrawDash() {
   dwinDrawStatusMessage();
   dwinDrawDashboard();
 }
 
 void dwinRedrawScreen() {
   drawMainArea();
   dwinRedrawDash();
 }
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
+
   void dwinPopupPause(FSTR_P const fmsg, uint8_t button/*=0*/) {
     hmiSaveProcessID(button ? ID_WaitResponse : ID_NothingToDo);
-    dwinShowPopup(ICON_BLTouch, GET_TEXT_F(MSG_ADVANCED_PAUSE), fmsg, button);
-  }
-
-  void MarlinUI::pause_show_message(const PauseMessage message, const PauseMode mode/*=PAUSE_MODE_SAME*/, const uint8_t extruder/*=active_extruder*/) {
-    if (mode != PAUSE_MODE_SAME) pause_mode = mode;
-    switch (message) {
-      case PAUSE_MESSAGE_PARKING:  dwinPopupPause(GET_TEXT_F(MSG_PAUSE_PRINT_PARKING));    break;                // M125
-      case PAUSE_MESSAGE_CHANGING: dwinPopupPause(GET_TEXT_F(MSG_FILAMENT_CHANGE_INIT));   break;                // pause_print (M125, M600)
-      case PAUSE_MESSAGE_WAITING:  dwinPopupPause(GET_TEXT_F(MSG_ADVANCED_PAUSE_WAITING), BTN_Continue); break;
-      case PAUSE_MESSAGE_INSERT:   dwinPopupPause(GET_TEXT_F(MSG_FILAMENT_CHANGE_INSERT), BTN_Continue); break;
-      case PAUSE_MESSAGE_LOAD:     dwinPopupPause(GET_TEXT_F(MSG_FILAMENT_CHANGE_LOAD));   break;
-      case PAUSE_MESSAGE_UNLOAD:   dwinPopupPause(GET_TEXT_F(MSG_FILAMENT_CHANGE_UNLOAD)); break;                // Unload of pause and Unload of M702
-      case PAUSE_MESSAGE_PURGE:    dwinPopupPause(GET_TEXT_F(TERN(ADVANCED_PAUSE_CONTINUOUS_PURGE, MSG_FILAMENT_CHANGE_CONT_PURGE, MSG_FILAMENT_CHANGE_PURGE))); break;
-      case PAUSE_MESSAGE_OPTION:   gotoFilamentPurge(); break;
-      case PAUSE_MESSAGE_RESUME:   dwinPopupPause(GET_TEXT_F(MSG_FILAMENT_CHANGE_RESUME)); break;
-      case PAUSE_MESSAGE_HEAT:     dwinPopupPause(GET_TEXT_F(MSG_FILAMENT_CHANGE_HEAT), BTN_Continue);   break;
-      case PAUSE_MESSAGE_HEATING:  dwinPopupPause(GET_TEXT_F(MSG_FILAMENT_CHANGE_HEATING)); break;
-      case PAUSE_MESSAGE_STATUS:   hmiReturnScreen(); break;                                                      // Exit from Pause, Load and Unload
-      default: break;
-    }
+    dwinShowPopup(ICON_Pause_1, GET_TEXT_F(MSG_ADVANCED_PAUSE), fmsg, button);
   }
 
   void drawPopupFilamentPurge() {
-    dwinDrawPopup(ICON_BLTouch, GET_TEXT_F(MSG_ADVANCED_PAUSE), GET_TEXT_F(MSG_FILAMENT_CHANGE_PURGE_CONTINUE));
+    dwinDrawPopup(ICON_AutoLeveling, GET_TEXT_F(MSG_ADVANCED_PAUSE), GET_TEXT_F(MSG_FILAMENT_CHANGE_PURGE_CONTINUE));
     DWINUI::drawButton(BTN_Purge, 26, 280);
     DWINUI::drawButton(BTN_Continue, 146, 280);
     drawSelectHighlight(true);
   }
 
   void onClickFilamentPurge() {
     if (hmiFlag.select_flag)
       pause_menu_response = PAUSE_RESPONSE_EXTRUDE_MORE;  // "Purge More" button
     else {
       hmiSaveProcessID(ID_NothingToDo);
@@ -1963,21 +1991,21 @@ void dwinRedrawScreen() {
   void gotoFilamentPurge() {
     pause_menu_response = PAUSE_RESPONSE_WAIT_FOR;
     gotoPopup(drawPopupFilamentPurge, onClickFilamentPurge);
   }
 
 #endif // ADVANCED_PAUSE_FEATURE
 
 #if HAS_MESH
   void dwinMeshViewer() {
     if (!leveling_is_valid())
-      dwinPopupContinue(ICON_BLTouch, GET_TEXT_F(MSG_MESH_VIEWER), GET_TEXT_F(MSG_NO_VALID_MESH));
+      dwinPopupContinue(ICON_Leveling_1, GET_TEXT_F(MSG_MESH_VIEWER), GET_TEXT_F(MSG_NO_VALID_MESH));
     else {
       hmiSaveProcessID(ID_WaitResponse);
       meshViewer.draw();
     }
   }
 #endif
 
 #if HAS_LOCKSCREEN
 
   void dwinLockScreen() {
@@ -3081,31 +3109,31 @@ void drawPrepareMenu() {
   updateMenu(prepareMenu);
 }
 
 #if ENABLED(LCD_BED_TRAMMING)
 
   void drawTrammingMenu() {
     checkkey = ID_Menu;
     if (SET_MENU(trammingMenu, MSG_BED_TRAMMING, 8)) {
       BACK_ITEM(drawPrepareMenu);
       #if HAS_BED_PROBE && HAS_MESH
-        MENU_ITEM(ICON_ProbeSet, MSG_TRAMMING_WIZARD, onDrawMenuItem, trammingwizard);
-        EDIT_ITEM(ICON_ProbeSet, MSG_BED_TRAMMING_MANUAL, onDrawChkbMenu, setManualTramming, &hmiData.fullManualTramming);
+        MENU_ITEM(ICON_Tram, MSG_TRAMMING_WIZARD, onDrawMenuItem, trammingwizard);
+        EDIT_ITEM(ICON_Version, MSG_BED_TRAMMING_MANUAL, onDrawChkbMenu, setManualTramming, &hmiData.fullManualTramming);
       #elif !HAS_BED_PROBE && HAS_ZOFFSET_ITEM
         MENU_ITEM_F(ICON_MoveZ0, "Home Z and disable", onDrawMenuItem, homeZAndDisable);
       #endif
-      MENU_ITEM(ICON_Axis, MSG_TRAM_FL, onDrawMenuItem, []{ (void)tram(0); });
-      MENU_ITEM(ICON_Axis, MSG_TRAM_FR, onDrawMenuItem, []{ (void)tram(1); });
-      MENU_ITEM(ICON_Axis, MSG_TRAM_BR, onDrawMenuItem, []{ (void)tram(2); });
-      MENU_ITEM(ICON_Axis, MSG_TRAM_BL, onDrawMenuItem, []{ (void)tram(3); });
+      MENU_ITEM(ICON_AxisBL, MSG_TRAM_FL, onDrawMenuItem, []{ (void)tram(0); });
+      MENU_ITEM(ICON_AxisBR, MSG_TRAM_FR, onDrawMenuItem, []{ (void)tram(1); });
+      MENU_ITEM(ICON_AxisTR, MSG_TRAM_BR, onDrawMenuItem, []{ (void)tram(2); });
+      MENU_ITEM(ICON_AxisTL, MSG_TRAM_BL, onDrawMenuItem, []{ (void)tram(3); });
       #if ENABLED(BED_TRAMMING_INCLUDE_CENTER)
-        MENU_ITEM(ICON_Axis, MSG_TRAM_C, onDrawMenuItem, []{ (void)tram(4); });
+        MENU_ITEM(ICON_AxisC, MSG_TRAM_C, onDrawMenuItem, []{ (void)tram(4); });
       #endif
     }
     updateMenu(trammingMenu);
   }
 
 #endif // LCD_BED_TRAMMING
 
 void drawControlMenu() {
   checkkey = ID_Menu;
   if (SET_MENU_R(controlMenu, selrect({103, 1, 28, 14}), MSG_CONTROL, 11)) {
@@ -3137,27 +3165,27 @@ void drawControlMenu() {
 }
 
 void drawAdvancedSettingsMenu() {
   checkkey = ID_Menu;
   if (SET_MENU(advancedSettingsMenu, MSG_ADVANCED_SETTINGS, 24)) {
     BACK_ITEM(gotoMainMenu);
     #if ENABLED(EEPROM_SETTINGS)
       MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawMenuItem, writeEEPROM);
     #endif
     #if HAS_MESH
-      MENU_ITEM(ICON_ProbeSet, MSG_MESH_LEVELING, onDrawSubMenu, drawMeshSetMenu);
+      MENU_ITEM(ICON_Mesh, MSG_MESH_LEVELING, onDrawSubMenu, drawMeshSetMenu);
     #endif
     #if HAS_BED_PROBE
-      MENU_ITEM(ICON_ProbeSet, MSG_ZPROBE_SETTINGS, onDrawSubMenu, drawProbeSetMenu);
+      MENU_ITEM(ICON_Probe, MSG_ZPROBE_SETTINGS, onDrawSubMenu, drawProbeSetMenu);
     #endif
     #if HAS_HOME_OFFSET
-      MENU_ITEM(ICON_ProbeSet, MSG_SET_HOME_OFFSETS, onDrawSubMenu, drawHomeOffsetMenu);
+      MENU_ITEM(ICON_HomeOffset, MSG_SET_HOME_OFFSETS, onDrawSubMenu, drawHomeOffsetMenu);
     #endif
     MENU_ITEM(ICON_FilSet, MSG_FILAMENT_SET, onDrawSubMenu, drawFilSetMenu);
     #if ENABLED(PIDTEMP) && ANY(PID_AUTOTUNE_MENU, PID_EDIT_MENU)
       MENU_ITEM_F(ICON_PIDNozzle, STR_HOTEND_PID " Settings", onDrawSubMenu, drawHotendPIDMenu);
     #endif
     #if ANY(MPC_EDIT_MENU, MPC_AUTOTUNE_MENU)
       MENU_ITEM_F(ICON_MPCNozzle, "MPC Settings", onDrawSubMenu, drawHotendMPCMenu);
     #endif
     #if ENABLED(PIDTEMPBED) && ANY(PID_AUTOTUNE_MENU, PID_EDIT_MENU)
       MENU_ITEM_F(ICON_PIDBed, STR_BED_PID " Settings", onDrawSubMenu, drawBedPIDMenu);
@@ -3169,41 +3197,41 @@ void drawAdvancedSettingsMenu() {
       MENU_ITEM_F(ICON_esDiag, "End-stops diag.", onDrawSubMenu, drawEndStopDiag);
     #endif
     #if ENABLED(PRINTCOUNTER)
       MENU_ITEM(ICON_PrintStats, MSG_INFO_STATS_MENU, onDrawSubMenu, gotoPrintStats);
       MENU_ITEM(ICON_PrintStatsReset, MSG_INFO_PRINT_COUNT_RESET, onDrawSubMenu, printStatsReset);
     #endif
     #if HAS_LOCKSCREEN
       MENU_ITEM(ICON_Lock, MSG_LOCKSCREEN, onDrawMenuItem, dwinLockScreen);
     #endif
     #if ENABLED(EDITABLE_DISPLAY_TIMEOUT)
-      EDIT_ITEM(ICON_Brightness, MSG_SCREEN_TIMEOUT, onDrawPIntMenu, setTimer, &ui.backlight_timeout_minutes);
+      EDIT_ITEM(ICON_RemainTime, MSG_SCREEN_TIMEOUT, onDrawPIntMenu, setTimer, &ui.backlight_timeout_minutes);
     #endif
     #if ENABLED(SOUND_MENU_ITEM)
       EDIT_ITEM(ICON_Sound, MSG_SOUND_ENABLE, onDrawChkbMenu, setEnableSound, &ui.sound_on);
     #endif
     #if ENABLED(POWER_LOSS_RECOVERY)
       EDIT_ITEM(ICON_Pwrlossr, MSG_OUTAGE_RECOVERY, onDrawChkbMenu, setPwrLossr, &recovery.enabled);
     #endif
     #if HAS_GCODE_PREVIEW
       EDIT_ITEM(ICON_File, MSG_HAS_PREVIEW, onDrawChkbMenu, setPreview, &hmiData.enablePreview);
     #endif
     #if ENABLED(PROUI_MEDIASORT)
       EDIT_ITEM(ICON_File, MSG_MEDIA_SORT, onDrawChkbMenu, setMediaSort, &hmiData.mediaSort);
     #endif
     EDIT_ITEM(ICON_File, MSG_MEDIA_UPDATE, onDrawChkbMenu, setMediaAutoMount, &hmiData.mediaAutoMount);
     #if ENABLED(BAUD_RATE_GCODE)
       EDIT_ITEM_F(ICON_SetBaudRate, "115K baud", onDrawChkbMenu, setBaudRate, &hmiData.baud115K);
     #endif
     #if HAS_LCD_BRIGHTNESS
       EDIT_ITEM(ICON_Brightness, MSG_BRIGHTNESS, onDrawPInt8Menu, setBrightness, &ui.brightness);
-      MENU_ITEM(ICON_Brightness, MSG_BRIGHTNESS_OFF, onDrawMenuItem, turnOffBacklight);
+      MENU_ITEM(ICON_Box, MSG_BRIGHTNESS_OFF, onDrawMenuItem, turnOffBacklight);
     #endif
     #if HAS_CUSTOM_COLORS
       MENU_ITEM(ICON_Scolor, MSG_COLORS_SELECT, onDrawSubMenu, drawSelectColorsMenu);
     #endif
   }
   ui.reset_status(true);
   updateMenu(advancedSettingsMenu);
 }
 
 void drawMoveMenu() {
@@ -3261,21 +3289,21 @@ void drawMoveMenu() {
       #endif
       #if HAS_Y_AXIS
         EDIT_ITEM(ICON_ProbeOffsetY, MSG_ZPROBE_YOFFSET, onDrawPFloatMenu, setProbeOffsetY, &probe.offset.y);
       #endif
       #if HAS_Z_AXIS
         EDIT_ITEM(ICON_ProbeOffsetZ, MSG_ZPROBE_ZOFFSET, onDrawPFloat2Menu, setProbeOffsetZ, &probe.offset.z);
       #endif
       #if ENABLED(BLTOUCH)
         MENU_ITEM(ICON_ProbeStow, MSG_MANUAL_STOW, onDrawMenuItem, probeStow);
         MENU_ITEM(ICON_ProbeDeploy, MSG_MANUAL_DEPLOY, onDrawMenuItem, probeDeploy);
-        MENU_ITEM(ICON_BltouchReset, MSG_BLTOUCH_RESET, onDrawMenuItem, bltouch._reset);
+        MENU_ITEM(ICON_BLTouchReset, MSG_BLTOUCH_RESET, onDrawMenuItem, bltouch._reset);
         #if HAS_BLTOUCH_HS_MODE
           EDIT_ITEM(ICON_HSMode, MSG_ENABLE_HS_MODE, onDrawChkbMenu, setHSMode, &bltouch.high_speed_mode);
         #endif
       #endif
       #if ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)
         MENU_ITEM(ICON_ProbeTest, MSG_M48_TEST, onDrawMenuItem, probeTest);
       #endif
     }
     updateMenu(probeSettingsMenu);
   }
@@ -3390,24 +3418,24 @@ void drawTuneMenu() {
       EDIT_ITEM(ICON_JDmm, MSG_JUNCTION_DEVIATION, onDrawPFloat3Menu, setJDmm, &planner.junction_deviation_mm);
     #endif
     #if ENABLED(PROUI_ITEM_ADVK)
       EDIT_ITEM(ICON_MaxAccelerated, MSG_ADVANCE_K, onDrawPFloat3Menu, setLA_K, &planner.extruder_advance_K[0]);
     #endif
     #if HAS_LOCKSCREEN
       MENU_ITEM(ICON_Lock, MSG_LOCKSCREEN, onDrawMenuItem, dwinLockScreen);
     #endif
     #if HAS_LCD_BRIGHTNESS
       EDIT_ITEM(ICON_Brightness, MSG_BRIGHTNESS, onDrawPInt8Menu, setBrightness, &ui.brightness);
-      MENU_ITEM(ICON_Brightness, MSG_BRIGHTNESS_OFF, onDrawMenuItem, turnOffBacklight);
+      MENU_ITEM(ICON_Box, MSG_BRIGHTNESS_OFF, onDrawMenuItem, turnOffBacklight);
     #endif
     #if ENABLED(EDITABLE_DISPLAY_TIMEOUT)
-      EDIT_ITEM(ICON_Brightness, MSG_SCREEN_TIMEOUT, onDrawPIntMenu, setTimer, &ui.backlight_timeout_minutes);
+      EDIT_ITEM(ICON_RemainTime, MSG_SCREEN_TIMEOUT, onDrawPIntMenu, setTimer, &ui.backlight_timeout_minutes);
     #endif
     #if ALL(PROUI_TUNING_GRAPH, PROUI_ITEM_PLOT)
       MENU_ITEM(ICON_PIDNozzle, MSG_HOTEND_TEMP_GRAPH, onDrawMenuItem, drawHPlot);
       MENU_ITEM(ICON_PIDBed, MSG_BED_TEMP_GRAPH, onDrawMenuItem, drawBPlot);
     #endif
     #if ENABLED(CASE_LIGHT_MENU)
       EDIT_ITEM(ICON_CaseLight, MSG_CASE_LIGHT, onDrawChkbMenu, setCaseLight, &caselight.on);
       #if CASELIGHT_USES_BRIGHTNESS
         // Avoid heavy interference with print job disabling live update of brightness in tune menu
         enableLiveCaseLightBrightness = false;
@@ -3418,23 +3446,23 @@ void drawTuneMenu() {
         enableLiveLedColor = false;
         MENU_ITEM(ICON_LedControl, MSG_LED_CONTROL, onDrawSubMenu, drawLedControlMenu);
       #endif
     #elif ENABLED(LED_CONTROL_MENU) && DISABLED(CASE_LIGHT_USE_NEOPIXEL)
       EDIT_ITEM(ICON_LedControl, MSG_LEDS, onDrawChkbMenu, setLedStatus, &leds.lights_on);
     #endif
   }
   updateMenu(tuneMenu);
 }
 
-#if ENABLED(ADAPTIVE_STEP_SMOOTHING)
+#if ENABLED(ADAPTIVE_STEP_SMOOTHING_TOGGLE)
   void setAdaptiveStepSmoothing() {
-    toggleCheckboxLine(hmiData.adaptiveStepSmoothing);
+    toggleCheckboxLine(stepper.adaptive_step_smoothing_enabled);
   }
 #endif
 
 #if ENABLED(SHAPING_MENU)
   void applyShapingFreq() { stepper.set_shaping_frequency(hmiValue.axis, menuData.value / 100); }
   void applyShapingZeta() { stepper.set_shaping_damping_ratio(hmiValue.axis, menuData.value / 100); }
 
   #if ENABLED(INPUT_SHAPING_X)
     void onDrawShapingXFreq(MenuItem* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, stepper.get_shaping_frequency(X_AXIS)); }
     void onDrawShapingXZeta(MenuItem* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, stepper.get_shaping_damping_ratio(X_AXIS)); }
@@ -3511,22 +3539,22 @@ void drawMotionMenu() {
       MENU_ITEM(ICON_MaxJerk, MSG_JERK, onDrawJerk, drawMaxJerkMenu);
     #elif HAS_JUNCTION_DEVIATION
       EDIT_ITEM(ICON_JDmm, MSG_JUNCTION_DEVIATION, onDrawPFloat3Menu, setJDmm, &planner.junction_deviation_mm);
     #endif
     #if ENABLED(LIN_ADVANCE)
       EDIT_ITEM(ICON_MaxAccelerated, MSG_ADVANCE_K, onDrawPFloat3Menu, setLA_K, &planner.extruder_advance_K[0]);
     #endif
     #if ENABLED(SHAPING_MENU)
       MENU_ITEM(ICON_InputShaping, MSG_INPUT_SHAPING, onDrawSubMenu, drawInputShaping_menu);
     #endif
-    #if ENABLED(ADAPTIVE_STEP_SMOOTHING)
-      EDIT_ITEM(ICON_UBLActive, MSG_STEP_SMOOTHING, onDrawChkbMenu, setAdaptiveStepSmoothing, &hmiData.adaptiveStepSmoothing);
+    #if ENABLED(ADAPTIVE_STEP_SMOOTHING_TOGGLE)
+      EDIT_ITEM(ICON_UBLActive, MSG_STEP_SMOOTHING, onDrawChkbMenu, setAdaptiveStepSmoothing, &stepper.adaptive_step_smoothing_enabled);
     #endif
     #if ENABLED(EDITABLE_STEPS_PER_UNIT)
       MENU_ITEM(ICON_Step, MSG_STEPS_PER_MM, onDrawSteps, drawStepsMenu);
     #endif
     EDIT_ITEM(ICON_Flow, MSG_FLOW, onDrawPIntMenu, setFlow, &planner.flow_percentage[0]);
     EDIT_ITEM(ICON_Speed, MSG_SPEED, onDrawPIntMenu, setSpeed, &feedrate_percentage);
   }
   updateMenu(motionMenu);
 }
 
@@ -3582,24 +3610,24 @@ void drawFilamentManMenu() {
 
 #endif // MESH_BED_LEVELING
 
 #if HAS_PREHEAT
 
   void drawPreheatMenu(const bool notCurrent) {
     checkkey = ID_Menu;
     if (notCurrent) {
       BACK_ITEM(drawTemperatureMenu);
       #if HAS_HOTEND
-        EDIT_ITEM(ICON_SetEndTemp, MSG_UBL_SET_TEMP_HOTEND, onDrawSetPreheatHotend, setPreheatEndTemp, &ui.material_preset[hmiValue.select].hotend_temp);
+        EDIT_ITEM(ICON_HotendTemp, MSG_UBL_SET_TEMP_HOTEND, onDrawSetPreheatHotend, setPreheatEndTemp, &ui.material_preset[hmiValue.select].hotend_temp);
       #endif
       #if HAS_HEATED_BED
-        EDIT_ITEM(ICON_SetBedTemp, MSG_UBL_SET_TEMP_BED, onDrawSetPreheatBed, setPreheatBedTemp, &ui.material_preset[hmiValue.select].bed_temp);
+        EDIT_ITEM(ICON_BedTemp, MSG_UBL_SET_TEMP_BED, onDrawSetPreheatBed, setPreheatBedTemp, &ui.material_preset[hmiValue.select].bed_temp);
       #endif
       #if HAS_FAN
         EDIT_ITEM(ICON_FanSpeed, MSG_FAN_SPEED, onDrawSetPreheatFan, setPreheatFanSpeed, &ui.material_preset[hmiValue.select].fan_speed);
       #endif
       #if ENABLED(EEPROM_SETTINGS)
         MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawWriteEeprom, writeEEPROM);
       #endif
     }
     updateMenu(preheatMenu);
   }
@@ -3611,24 +3639,24 @@ void drawFilamentManMenu() {
     }
   REPEAT_1(PREHEAT_COUNT, _preheatMenu)
 
 #endif // HAS_PREHEAT
 
 void drawTemperatureMenu() {
   checkkey = ID_Menu;
   if (SET_MENU_R(temperatureMenu, selrect({236, 2, 28, 12}), MSG_TEMPERATURE, 4 + PREHEAT_COUNT)) {
     BACK_ITEM(drawControlMenu);
     #if HAS_HOTEND
-      hotendTargetItem = EDIT_ITEM(ICON_SetEndTemp, MSG_UBL_SET_TEMP_HOTEND, onDrawHotendTemp, setHotendTemp, &thermalManager.temp_hotend[0].target);
+      hotendTargetItem = EDIT_ITEM(ICON_HotendTemp, MSG_UBL_SET_TEMP_HOTEND, onDrawHotendTemp, setHotendTemp, &thermalManager.temp_hotend[0].target);
     #endif
     #if HAS_HEATED_BED
-      bedTargetItem = EDIT_ITEM(ICON_SetBedTemp, MSG_UBL_SET_TEMP_BED, onDrawBedTemp, setBedTemp, &thermalManager.temp_bed.target);
+      bedTargetItem = EDIT_ITEM(ICON_BedTemp, MSG_UBL_SET_TEMP_BED, onDrawBedTemp, setBedTemp, &thermalManager.temp_bed.target);
     #endif
     #if HAS_FAN
       fanSpeedItem = EDIT_ITEM(ICON_FanSpeed, MSG_FAN_SPEED, onDrawFanSpeed, setFanSpeed, &thermalManager.fan_speed[0]);
     #endif
     #if HAS_PREHEAT
       #define _ITEM_SETPREHEAT(N) MENU_ITEM(ICON_SetPreheat##N, MSG_PREHEAT_## N ##_SETTINGS, onDrawSubMenu, drawPreheat## N ##Menu);
       REPEAT_1(PREHEAT_COUNT, _ITEM_SETPREHEAT)
     #endif
   }
   updateMenu(temperatureMenu);
@@ -3837,126 +3865,162 @@ void drawMaxAccelMenu() {
         #if ENABLED(MPC_INCLUDE_FAN)
           EDIT_ITEM(ICON_MPCFan, MSG_MPC_AMBIENT_XFER_COEFF_FAN, onDrawFanAdj, setFanAdj, &mpc.fan255_adjustment);
         #endif
       #endif
     }
     updateMenu(hotendMPCMenu);
   }
 
 #endif // MPC_EDIT_MENU || MPC_AUTOTUNE_MENU
 
-#if PROUI_PID_TUNE
-  void setPID(celsius_t t, heater_id_t h) {
-    gcode.process_subcommands_now(
-      MString<60>(F("G28OXY\nG0Z5F300\nG0X"), X_CENTER, F("Y"), Y_CENTER, F("F5000\nM84\nM400"))
-    );
-    thermalManager.PID_autotune(t, h, hmiData.pidCycles, true);
-  }
-  void setPidCycles() { setPIntOnClick(3, 50); }
-#endif
+#if HAS_PID_HEATING
 
-#if ALL(HAS_PID_HEATING, PID_EDIT_MENU)
+  #if ENABLED(PID_AUTOTUNE_MENU)
+    void setPID(celsius_t t, heater_id_t h) {
+      gcode.process_subcommands_now(
+        MString<60>(F("G28OXY\nG0Z5F300\nG0X"), X_CENTER, F("Y"), Y_CENTER, F("F5000\nM84\nM400"))
+      );
+      thermalManager.PID_autotune(t, h, hmiData.pidCycles, true);
+    }
+    void setPIDCycles() { setPIntOnClick(3, 50); }
+  #endif
 
-  void setKp() { setPFloatOnClick(0, 1000, 2); }
-  void applyPIDi() {
-    *menuData.floatPtr = scalePID_i(menuData.value / POW(10, 2));
-    TERN_(PIDTEMP, thermalManager.updatePID());
-  }
-  void applyPIDd() {
-    *menuData.floatPtr = scalePID_d(menuData.value / POW(10, 2));
-    TERN_(PIDTEMP, thermalManager.updatePID());
-  }
-  void setKi() {
-    menuData.floatPtr = (float*)static_cast<MenuItemPtr*>(currentMenu->selectedItem())->value;
-    const float value = unscalePID_i(*menuData.floatPtr);
-    setFloatOnClick(0, 1000, 2, value, applyPIDi);
-  }
-  void setKd() {
-    menuData.floatPtr = (float*)static_cast<MenuItemPtr*>(currentMenu->selectedItem())->value;
-    const float value = unscalePID_d(*menuData.floatPtr);
-    setFloatOnClick(0, 1000, 2, value, applyPIDd);
-  }
-  void onDrawPIDi(MenuItem* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, unscalePID_i(*(float*)static_cast<MenuItemPtr*>(menuitem)->value)); }
-  void onDrawPIDd(MenuItem* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, unscalePID_d(*(float*)static_cast<MenuItemPtr*>(menuitem)->value)); }
+  #if ENABLED(PID_EDIT_MENU)
+    void setKp() { setPFloatOnClick(0, 1000, 2); }
+    void applyPIDi() {
+      *menuData.floatPtr = scalePID_i(menuData.value / POW(10, 2));
+      TERN_(PIDTEMP, thermalManager.updatePID());
+    }
+    void applyPIDd() {
+      *menuData.floatPtr = scalePID_d(menuData.value / POW(10, 2));
+      TERN_(PIDTEMP, thermalManager.updatePID());
+    }
+    void setKi() {
+      menuData.floatPtr = (float*)static_cast<MenuItemPtr*>(currentMenu->selectedItem())->value;
+      const float value = unscalePID_i(*menuData.floatPtr);
+      setFloatOnClick(0, 1000, 2, value, applyPIDi);
+    }
+    void setKd() {
+      menuData.floatPtr = (float*)static_cast<MenuItemPtr*>(currentMenu->selectedItem())->value;
+      const float value = unscalePID_d(*menuData.floatPtr);
+      setFloatOnClick(0, 1000, 2, value, applyPIDd);
+    }
+    void onDrawPIDi(MenuItem* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, unscalePID_i(*(float*)static_cast<MenuItemPtr*>(menuitem)->value)); }
+    void onDrawPIDd(MenuItem* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, unscalePID_d(*(float*)static_cast<MenuItemPtr*>(menuitem)->value)); }
+  #endif // PID_EDIT_MENU
 
-#endif // HAS_PID_HEATING && PID_EDIT_MENU
+#endif // HAS_PID_HEATING
 
-#if ENABLED(PIDTEMP) && ANY(PID_AUTOTUNE_MENU, PID_EDIT_MENU)
+#if ANY(PID_AUTOTUNE_MENU, PID_EDIT_MENU)
 
-  #if ENABLED(PID_AUTOTUNE_MENU)
-    void hotendPID() { setPID(hmiData.hotendPidT, H_E0); }
-    void setHotendPidT() { setPIntOnClick(MIN_ETEMP, MAX_ETEMP); }
-  #endif
+  #if ENABLED(PIDTEMP)
 
-  void drawHotendPIDMenu() {
-    checkkey = ID_Menu;
-    if (SET_MENU_F(hotendPIDMenu, STR_HOTEND_PID " Settings", 8)) {
-      BACK_ITEM(drawAdvancedSettingsMenu);
-      #if ENABLED(PID_AUTOTUNE_MENU)
-        MENU_ITEM_F(ICON_PIDNozzle, STR_HOTEND_PID, onDrawMenuItem, hotendPID);
-        EDIT_ITEM(ICON_Temperature, MSG_TEMPERATURE, onDrawPIntMenu, setHotendPidT, &hmiData.hotendPidT);
-        EDIT_ITEM(ICON_PIDCycles, MSG_PID_CYCLE, onDrawPIntMenu, setPidCycles, &hmiData.pidCycles);
-      #endif
-      #if ENABLED(PID_EDIT_MENU)
-        EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KP, onDrawPFloat2Menu, setKp, &thermalManager.temp_hotend[0].pid.Kp);
-        EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KI, onDrawPIDi, setKi, &thermalManager.temp_hotend[0].pid.Ki);
-        EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KD, onDrawPIDd, setKd, &thermalManager.temp_hotend[0].pid.Kd);
-      #endif
-      #if ENABLED(EEPROM_SETTINGS)
-        MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawMenuItem, writeEEPROM);
-      #endif
+    #if ENABLED(PID_AUTOTUNE_MENU)
+      void hotendPID() { setPID(hmiData.hotendPIDT, H_E0); }
+      void setHotendPIDT() { setPIntOnClick(MIN_ETEMP, MAX_ETEMP); }
+    #endif
+
+    void drawHotendPIDMenu() {
+      checkkey = ID_Menu;
+      if (SET_MENU_F(hotendPIDMenu, STR_HOTEND_PID " Settings", 8)) {
+        BACK_ITEM(drawAdvancedSettingsMenu);
+        #if ENABLED(PID_AUTOTUNE_MENU)
+          MENU_ITEM_F(ICON_PIDNozzle, STR_HOTEND_PID, onDrawMenuItem, hotendPID);
+          EDIT_ITEM(ICON_Temperature, MSG_TEMPERATURE, onDrawPIntMenu, setHotendPIDT, &hmiData.hotendPIDT);
+          EDIT_ITEM(ICON_PIDCycles, MSG_PID_CYCLE, onDrawPIntMenu, setPIDCycles, &hmiData.pidCycles);
+        #endif
+        #if ENABLED(PID_EDIT_MENU)
+          EDIT_ITEM_F(ICON_PIDValue, "Set Kp: ", onDrawPFloat2Menu, setKp, &thermalManager.temp_hotend[0].pid.Kp);
+          EDIT_ITEM_F(ICON_PIDValue, "Set Ki: ", onDrawPIDi, setKi, &thermalManager.temp_hotend[0].pid.Ki);
+          EDIT_ITEM_F(ICON_PIDValue, "Set Kd: ", onDrawPIDd, setKd, &thermalManager.temp_hotend[0].pid.Kd);
+        #endif
+        #if ENABLED(EEPROM_SETTINGS)
+          MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawMenuItem, writeEEPROM);
+        #endif
+      }
+      updateMenu(hotendPIDMenu);
     }
-    updateMenu(hotendPIDMenu);
-  }
 
-#endif // PIDTEMP && (PID_AUTOTUNE_MENU || PID_EDIT_MENU)
+  #endif // PIDTEMP
 
-#if ENABLED(PIDTEMPBED) && ANY(PID_AUTOTUNE_MENU, PID_EDIT_MENU)
+  #if ENABLED(PIDTEMPBED)
 
-  #if ENABLED(PID_AUTOTUNE_MENU)
-    void bedPID() { setPID(hmiData.bedPidT, H_BED); }
-    void setBedPidT() { setPIntOnClick(MIN_BEDTEMP, MAX_BEDTEMP); }
-  #endif
+    #if ENABLED(PID_AUTOTUNE_MENU)
+      void bedPID() { setPID(hmiData.bedPIDT, H_BED); }
+      void setBedPIDT() { setPIntOnClick(MIN_BEDTEMP, MAX_BEDTEMP); }
+    #endif
 
-  void drawBedPIDMenu() {
-    checkkey = ID_Menu;
-    if (SET_MENU_F(bedPIDMenu, STR_BED_PID " Settings", 8)) {
-      BACK_ITEM(drawAdvancedSettingsMenu);
-      #if ENABLED(PID_AUTOTUNE_MENU)
-        MENU_ITEM_F(ICON_PIDBed, STR_BED_PID, onDrawMenuItem,bedPID);
-        EDIT_ITEM(ICON_Temperature, MSG_TEMPERATURE, onDrawPIntMenu, setBedPidT, &hmiData.bedPidT);
-        EDIT_ITEM(ICON_PIDCycles, MSG_PID_CYCLE, onDrawPIntMenu, setPidCycles, &hmiData.pidCycles);
-      #endif
-      #if ENABLED(PID_EDIT_MENU)
-        EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KP, onDrawPFloat2Menu, setKp, &thermalManager.temp_bed.pid.Kp);
-        EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KI, onDrawPIDi, setKi, &thermalManager.temp_bed.pid.Ki);
-        EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KD, onDrawPIDd, setKd, &thermalManager.temp_bed.pid.Kd);
-      #endif
-      #if ENABLED(EEPROM_SETTINGS)
-        MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawMenuItem, writeEEPROM);
-      #endif
+    void drawBedPIDMenu() {
+      checkkey = ID_Menu;
+      if (SET_MENU_F(bedPIDMenu, STR_BED_PID " Settings", 8)) {
+        BACK_ITEM(drawAdvancedSettingsMenu);
+        #if ENABLED(PID_AUTOTUNE_MENU)
+          MENU_ITEM_F(ICON_PIDBed, STR_BED_PID, onDrawMenuItem,bedPID);
+          EDIT_ITEM(ICON_Temperature, MSG_TEMPERATURE, onDrawPIntMenu, setBedPIDT, &hmiData.bedPIDT);
+          EDIT_ITEM(ICON_PIDCycles, MSG_PID_CYCLE, onDrawPIntMenu, setPIDCycles, &hmiData.pidCycles);
+        #endif
+        #if ENABLED(PID_EDIT_MENU)
+          EDIT_ITEM_F(ICON_PIDValue, "Set Kp: ", onDrawPFloat2Menu, setKp, &thermalManager.temp_bed.pid.Kp);
+          EDIT_ITEM_F(ICON_PIDValue, "Set Ki: ", onDrawPIDi, setKi, &thermalManager.temp_bed.pid.Ki);
+          EDIT_ITEM_F(ICON_PIDValue, "Set Kd: ", onDrawPIDd, setKd, &thermalManager.temp_bed.pid.Kd);
+        #endif
+        #if ENABLED(EEPROM_SETTINGS)
+          MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawMenuItem, writeEEPROM);
+        #endif
+      }
+      updateMenu(bedPIDMenu);
     }
-    updateMenu(bedPIDMenu);
-  }
 
-#endif // PIDTEMPBED && (PID_AUTOTUNE_MENU || PID_EDIT_MENU)
+  #endif // PIDTEMPBED
+
+  #if ENABLED(PIDTEMPCHAMBER)
+
+    #if ENABLED(PID_AUTOTUNE_MENU)
+      void chamberPID() { setPID(hmiData.chamberPIDT, H_CHAMBER); }
+      void setChamberPIDT() { setPIntOnClick(MIN_CHAMBERTEMP, MAX_CHAMBERTEMP); }
+    #endif
+
+    void drawChamberPIDMenu() {
+      checkkey = ID_Menu;
+      if (SET_MENU_F(chamberPIDMenu, STR_CHAMBER_PID " Settings", 8)) {
+        BACK_ITEM(drawAdvancedSettingsMenu);
+        #if ENABLED(PID_AUTOTUNE_MENU)
+          MENU_ITEM_F(ICON_PIDChamber, STR_CHAMBER_PID, onDrawMenuItem,chamberPID);
+          EDIT_ITEM(ICON_Temperature, MSG_TEMPERATURE, onDrawPIntMenu, setChamberPIDT, &hmiData.chamberPIDT);
+          EDIT_ITEM(ICON_PIDCycles, MSG_PID_CYCLE, onDrawPIntMenu, setPIDCycles, &hmiData.pidCycles);
+        #endif
+        #if ENABLED(PID_EDIT_MENU)
+          EDIT_ITEM_F(ICON_PIDValue, "Set Kp: ", onDrawPFloat2Menu, setKp, &thermalManager.temp_chamber.pid.Kp);
+          EDIT_ITEM_F(ICON_PIDValue, "Set Ki: ", onDrawPIDi, setKi, &thermalManager.temp_chamber.pid.Ki);
+          EDIT_ITEM_F(ICON_PIDValue, "Set Kd: ", onDrawPIDd, setKd, &thermalManager.temp_chamber.pid.Kd);
+        #endif
+        #if ENABLED(EEPROM_SETTINGS)
+          MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawMenuItem, writeEEPROM);
+        #endif
+      }
+      updateMenu(chamberPIDMenu);
+    }
+
+  #endif // PIDTEMPCHAMBER
+
+#endif // PID_AUTOTUNE_MENU || PID_EDIT_MENU
 
 //=============================================================================
 
 #if HAS_BED_PROBE
 
   void drawZOffsetWizMenu() {
     checkkey = ID_Menu;
     if (SET_MENU(zOffsetWizMenu, MSG_PROBE_WIZARD, 4)) {
       BACK_ITEM(drawPrepareMenu);
       MENU_ITEM(ICON_Homing, MSG_AUTO_HOME, onDrawMenuItem, autoHome);
-      MENU_ITEM(ICON_MoveZ0, MSG_MOVE_NOZZLE_TO_BED, onDrawMenuItem, setMoveZto0);
+      MENU_ITEM(ICON_AxisD, MSG_MOVE_NOZZLE_TO_BED, onDrawMenuItem, setMoveZto0);
       EDIT_ITEM(ICON_Zoffset, MSG_XATC_UPDATE_Z_OFFSET, onDrawPFloat2Menu, setZOffset, &BABY_Z_VAR);
     }
     updateMenu(zOffsetWizMenu);
     if (!axis_is_trusted(Z_AXIS)) LCD_MESSAGE_F("WARNING: Z position unknown, move Z to home");
   }
 
 #endif
 
 #if ENABLED(INDIVIDUAL_AXIS_HOMING_SUBMENU)
 

commit 466282f322ae4f42a8f3db5e3c9765c38445fdc8
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Mar 31 18:20:37 2024 -0500

    ü©π Misc. changes from ProUI / ExtUI updates (#26928)

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 888d1f7492..b65adbb780 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -1883,22 +1883,20 @@ void dwinInitScreen() {
   dwinDrawDashboard();
   gotoMainMenu();
 }
 
 void MarlinUI::update() {
   hmiSDCardUpdate();  // SD card update
   eachMomentUpdate(); // Status update
   dwinHandleScreen(); // Rotary encoder update
 }
 
-void MarlinUI::refresh() { /* Nothing to see here */ }
-
 #if HAS_LCD_BRIGHTNESS
   void MarlinUI::_set_brightness() { dwinLCDBrightness(backlight ? brightness : 0); }
 #endif
 
 void MarlinUI::kill_screen(FSTR_P const lcd_error, FSTR_P const) {
   dwinDrawPopup(ICON_BLTouch, GET_TEXT_F(MSG_PRINTER_KILLED), lcd_error);
   DWINUI::drawCenteredString(hmiData.colorPopupTxt, 270, GET_TEXT_F(MSG_TURN_OFF));
   dwinUpdateLCD();
 }
 
@@ -1921,22 +1919,21 @@ void dwinRedrawScreen() {
   dwinRedrawDash();
 }
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   void dwinPopupPause(FSTR_P const fmsg, uint8_t button/*=0*/) {
     hmiSaveProcessID(button ? ID_WaitResponse : ID_NothingToDo);
     dwinShowPopup(ICON_BLTouch, GET_TEXT_F(MSG_ADVANCED_PAUSE), fmsg, button);
   }
 
   void MarlinUI::pause_show_message(const PauseMessage message, const PauseMode mode/*=PAUSE_MODE_SAME*/, const uint8_t extruder/*=active_extruder*/) {
-    //if (mode == PAUSE_MODE_SAME) return;
-    pause_mode = mode;
+    if (mode != PAUSE_MODE_SAME) pause_mode = mode;
     switch (message) {
       case PAUSE_MESSAGE_PARKING:  dwinPopupPause(GET_TEXT_F(MSG_PAUSE_PRINT_PARKING));    break;                // M125
       case PAUSE_MESSAGE_CHANGING: dwinPopupPause(GET_TEXT_F(MSG_FILAMENT_CHANGE_INIT));   break;                // pause_print (M125, M600)
       case PAUSE_MESSAGE_WAITING:  dwinPopupPause(GET_TEXT_F(MSG_ADVANCED_PAUSE_WAITING), BTN_Continue); break;
       case PAUSE_MESSAGE_INSERT:   dwinPopupPause(GET_TEXT_F(MSG_FILAMENT_CHANGE_INSERT), BTN_Continue); break;
       case PAUSE_MESSAGE_LOAD:     dwinPopupPause(GET_TEXT_F(MSG_FILAMENT_CHANGE_LOAD));   break;
       case PAUSE_MESSAGE_UNLOAD:   dwinPopupPause(GET_TEXT_F(MSG_FILAMENT_CHANGE_UNLOAD)); break;                // Unload of pause and Unload of M702
       case PAUSE_MESSAGE_PURGE:    dwinPopupPause(GET_TEXT_F(TERN(ADVANCED_PAUSE_CONTINUOUS_PURGE, MSG_FILAMENT_CHANGE_CONT_PURGE, MSG_FILAMENT_CHANGE_PURGE))); break;
       case PAUSE_MESSAGE_OPTION:   gotoFilamentPurge(); break;
       case PAUSE_MESSAGE_RESUME:   dwinPopupPause(GET_TEXT_F(MSG_FILAMENT_CHANGE_RESUME)); break;

commit dd3b5a10a09e2a83918af1cf6f8782fd0c473f98
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jan 21 22:00:37 2024 -0600

    Misc. aesthetic adjustments
    
    Co-Authored-By: Andrew <18502096+classicrocker883@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 721859f1be..888d1f7492 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -506,36 +506,36 @@ void dwinDrawStatusMessage() {
         dwinDrawStatusLine(ui.status_message);
         hash_changed = false;
       }
     }
     else {
       // String is larger than the available line space
 
       // Get a pointer to the next valid UTF8 character
       // and the string remaining length
       uint8_t rlen;
-      const char *stat = MarlinUI::status_and_len(rlen);
+      const char *stat = ui.status_and_len(rlen);
       dwinDrawRectangle(1, hmiData.colorStatusBg, 0, STATUS_Y, DWIN_WIDTH, STATUS_Y + 20);
       DWINUI::moveTo(0, STATUS_Y + 2);
       DWINUI::drawString(hmiData.colorStatusTxt, stat, LCD_WIDTH);
 
       // If the string doesn't completely fill the line...
       if (rlen < LCD_WIDTH) {
-        DWINUI::drawChar(hmiData.colorStatusTxt, '.');  // Always at 1+ spaces left, draw a dot
+        DWINUI::drawChar(hmiData.colorStatusTxt, '.');     // Always at 1+ spaces left, draw a dot
         uint8_t chars = LCD_WIDTH - rlen;                  // Amount of space left in characters
         if (--chars) {                                     // Draw a second dot if there's space
           DWINUI::drawChar(hmiData.colorStatusTxt, '.');
           if (--chars)
             DWINUI::drawString(hmiData.colorStatusTxt, ui.status_message, chars); // Print a second copy of the message
         }
       }
-      MarlinUI::advance_status_scroll();
+      ui.advance_status_scroll();
     }
 
   #else
 
     if (hash_changed) {
       ui.status_message.trunc(LCD_WIDTH);
       dwinDrawStatusLine(ui.status_message);
       hash_changed = false;
     }
 
@@ -741,21 +741,21 @@ void _drawZOffsetIcon() {
 }
 
 void _drawFeedrate() {
   #if ENABLED(SHOW_SPEED_IND)
     int16_t _value;
     if (blink) {
       _value = feedrate_percentage;
       DWINUI::drawString(DWIN_FONT_STAT, hmiData.colorIndicator, hmiData.colorBackground, 116 + 4 * STAT_CHR_W + 2, 384, F(" %"));
     }
     else {
-      _value = CEIL(feedrate_mm_s * feedrate_percentage / 100);
+      _value = CEIL(MMS_SCALED(feedrate_mm_s));
       dwinDrawBox(1, hmiData.colorBackground, 116 + 5 * STAT_CHR_W + 2, 384, 20, 20);
     }
     DWINUI::drawInt(DWIN_FONT_STAT, hmiData.colorIndicator, hmiData.colorBackground, 3, 116 + 2 * STAT_CHR_W, 384, _value);
   #else
     static int16_t _feedrate = 100;
     if (_feedrate != feedrate_percentage) {
       _feedrate = feedrate_percentage;
       DWINUI::drawInt(DWIN_FONT_STAT, hmiData.colorIndicator, hmiData.colorBackground, 3, 116 + 2 * STAT_CHR_W, 384, _feedrate);
     }
   #endif
@@ -873,38 +873,38 @@ bool DWIN_lcd_sd_status = false;
   }
 #endif
 
 void setMediaAutoMount() { toggleCheckboxLine(hmiData.mediaAutoMount); }
 
 inline uint16_t nr_sd_menu_items() {
   return _MIN(card.get_num_items() + !card.flag.workDirIsRoot, MENU_MAX_ITEMS);
 }
 
 void makeNameWithoutExt(char *dst, char *src, size_t maxlen=MENU_CHAR_LIMIT) {
-  size_t pos = strlen(src);  // Index of ending nul
+  size_t pos = strlen(src); // Index of ending nul
 
   // For files, remove the extension
   // which may be .gcode, .gco, or .g
   if (!card.flag.filenameIsDir)
     while (pos && src[pos] != '.') pos--; // Find last '.' (stop at 0)
 
-  if (!pos) pos = strlen(src);  // pos = 0 ('.' not found) restore pos
+  if (!pos) pos = strlen(src); // pos = 0 ('.' not found) restore pos
 
-  size_t len = pos;   // nul or '.'
-  if (len > maxlen) { // Keep the name short
-    pos        = len = maxlen; // Move nul down
-    dst[--pos] = '.'; // Insert dots
+  size_t len = pos;     // nul or '.'
+  if (len > maxlen) {   // Keep the name short
+    pos = len = maxlen; // Move nul down
+    dst[--pos] = '.';   // Insert dots
     dst[--pos] = '.';
     dst[--pos] = '.';
   }
 
-  dst[len] = '\0';    // End it
+  dst[len] = '\0';      // End it
 
   // Copy down to 0
   while (pos--) dst[pos] = src[pos];
 }
 
 void sdCardUp() {
   card.cdup();
   DWIN_lcd_sd_status = false; // On next DWIN_Update
 }
 
@@ -965,21 +965,21 @@ void onClickSDItem() {
       if (selected >= 1 + hasUpDir) {
         const int8_t filenum = selected - 1 - hasUpDir; // Skip "Back" and ".."
         card.selectFileByIndexSorted(filenum);
         makeNameWithoutExt(shift_name, card.longest_filename(), LONG_FILENAME_LENGTH);
         shift_len = strlen(shift_name);
         shift_amt = 0;
       }
     }
     else if ((selected >= 1 + hasUpDir) && (shift_len > MENU_CHAR_LIMIT)) {
       uint8_t shift_new = _MIN(shift_amt + 1, shift_len - MENU_CHAR_LIMIT); // Try to shift by...
-      drawSDItemShifted(shift_new);             // Draw the item
+      drawSDItemShifted(shift_new);               // Draw the item
       if (shift_new == shift_amt)                 // Scroll reached the end
         shift_new = -1;                           // Reset
       shift_amt = shift_new;                      // Set new scroll
     }
   }
 
 #else // !SCROLL_LONG_FILENAMES
 
   char shift_name[FILENAME_LENGTH + 1] = "";
 
@@ -1228,30 +1228,22 @@ void drawMainArea() {
 }
 
 void hmiWaitForUser() {
   EncoderState encoder_diffState = get_encoder_state();
   if (encoder_diffState != ENCODER_DIFF_NO && !ui.backlight) {
     if (checkkey == ID_WaitResponse) hmiReturnScreen();
     return ui.refresh_brightness();
   }
   if (!wait_for_user) {
     switch (checkkey) {
-      case ID_PrintDone:
-        select_page.reset();
-        gotoMainMenu();
-        break;
-      #if HAS_BED_PROBE
-        case ID_Leveling:
-      #endif
-      default:
-        hmiReturnScreen();
-        break;
+      case ID_PrintDone: select_page.reset(); gotoMainMenu(); break;
+      default: hmiReturnScreen(); break;
     }
   }
 }
 
 void hmiInit() {
   #if ENABLED(SHOW_BOOTSCREEN)
     #ifndef BOOTSCREEN_TIMEOUT
       #define BOOTSCREEN_TIMEOUT 1100
     #endif
     DWINUI::drawBox(1, COLOR_BLACK, { 5, 220, DWIN_WIDTH - 5, DWINUI::fontHeight() });
@@ -1323,21 +1315,21 @@ void eachMomentUpdate() {
     if ((isPrinting() != hmiFlag.printing_flag) && !hmiFlag.home_flag) {
       hmiFlag.printing_flag = isPrinting();
       if (hmiFlag.printing_flag)
         dwinPrintStarted();
       else if (hmiFlag.abort_flag)
         dwinPrintAborted();
       else
         dwinPrintFinished();
     }
 
-    if ((printingIsPaused() != hmiFlag.pause_flag) && !hmiFlag.home_flag) {
+    if ((hmiFlag.pause_flag != printingIsPaused()) && !hmiFlag.home_flag) {
       hmiFlag.pause_flag = printingIsPaused();
       if (hmiFlag.pause_flag)
         dwinPrintPause();
       else if (hmiFlag.abort_flag)
         dwinPrintAborted();
       else
         dwinPrintResume();
     }
 
     if (checkkey == ID_PrintProcess) { // Print process
@@ -1427,23 +1419,22 @@ void dwinHandleScreen() {
     case ID_MainMenu:     hmiMainMenu(); break;
     case ID_Menu:         hmiMenu(); break;
     case ID_SetInt:       hmiSetDraw(); break;
     case ID_SetFloat:     hmiSetDraw(); break;
     case ID_SetPInt:      hmiSetPInt(); break;
     case ID_SetPFloat:    hmiSetPFloat(); break;
     case ID_SetIntNoDraw: hmiSetNoDraw(); break;
     case ID_PrintProcess: hmiPrinting(); break;
     case ID_Popup:        hmiPopup(); break;
     #if HAS_LOCKSCREEN
-      case ID_Locked:     hmiLockScreen(); break;
+      case ID_Locked: hmiLockScreen(); break;
     #endif
-
     TERN_(HAS_ESDIAG, case ID_ESDiagProcess:)
     TERN_(PROUI_ITEM_PLOT, case ID_PlotProcess:)
     case ID_PrintDone:
     case ID_WaitResponse: hmiWaitForUser(); break;
 
     TERN_(HAS_BED_PROBE, case ID_Leveling:)
     case ID_Homing:
     case ID_PIDProcess:
     case ID_NothingToDo:
     default: break;
@@ -1622,39 +1613,43 @@ void dwinLevelingDone() {
       }
 
       dwinDrawString(false, 2, hmiData.colorPopupTxt, hmiData.colorPopupBg, gfrm.x, gfrm.y - DWINUI::fontHeight() - 4, F("Target:     Celsius"));
       plot.draw(gfrm, _maxtemp, _target);
       DWINUI::drawInt(false, 2, hmiData.colorStatusTxt, hmiData.colorPopupBg, 3, gfrm.x + 80, gfrm.y - DWINUI::fontHeight() - 4, _target);
       DWINUI::drawButton(BTN_Continue, 86, 305);
       dwinUpdateLCD();
     }
 
     void drawHPlot() {
-      TERN_(PIDTEMP, dwinDrawPlot(PIDTEMP_START);)
-      TERN_(MPCTEMP, dwinDrawPlot(MPCTEMP_START);)
+      TERN_(PIDTEMP, dwinDrawPlot(PIDTEMP_START));
+      TERN_(MPCTEMP, dwinDrawPlot(MPCTEMP_START));
     }
     void drawBPlot() {
-      TERN_(PIDTEMPBED, dwinDrawPlot(PIDTEMPBED_START);)
+      TERN_(PIDTEMPBED, dwinDrawPlot(PIDTEMPBED_START));
     }
 
   #endif // PROUI_ITEM_PLOT
 
 #endif // PROUI_TUNING_GRAPH
 
 #if PROUI_PID_TUNE
 
   void dwinStartM303(const bool seenC, const int c, const bool seenS, const heater_id_t hid, const celsius_t temp) {
     if (seenC) hmiData.pidCycles = c;
     if (seenS) {
       switch (hid) {
-        OPTCODE(PIDTEMP,    case 0 ... HOTENDS - 1: hmiData.hotendPidT = temp; break)
-        OPTCODE(PIDTEMPBED, case H_BED:             hmiData.bedPidT = temp;    break)
+        #if ENABLED(PIDTEMP)
+          case 0 ... HOTENDS - 1: hmiData.hotendPidT = temp; break;
+        #endif
+        #if ENABLED(PIDTEMPBED)
+          case H_BED: hmiData.bedPidT = temp; break;
+        #endif
         default: break;
       }
     }
   }
 
   void dwinPidTuning(tempcontrol_t result) {
     hmiValue.tempControl = result;
     switch (result) {
       #if ENABLED(PIDTEMP)
         case PIDTEMP_START:
@@ -1771,21 +1766,21 @@ void dwinPrintFinished() {
 }
 
 // Print was aborted
 void dwinPrintAborted() {
   #ifndef EVENT_GCODE_SD_ABORT
     if (all_axes_homed()) {
       queue.inject(
         #if ENABLED(NOZZLE_PARK_FEATURE)
           F("G27")
         #else
-          TS(F("G0Z"), float(_MIN(current_position.z + (Z_POST_CLEARANCE), Z_MAX_POS)), F("\nG0F2000Y"), Y_MAX_POS);
+          TS(F("G0Z"), float(_MIN(current_position.z + (Z_POST_CLEARANCE), Z_MAX_POS)), F("\nG0F2000Y"), Y_MAX_POS)
         #endif
       );
     }
   #endif
   TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PRINT_ABORTED)));
   dwinPrintFinished();
 }
 
 #if HAS_FILAMENT_SENSOR
   // Filament Runout process
@@ -1883,23 +1878,23 @@ void dwinInitScreen() {
   DWINUI::onTitleDraw = drawTitle;
   initMenu();
   checkkey = 255;
   hash_changed = true;
   dwinDrawStatusLine();
   dwinDrawDashboard();
   gotoMainMenu();
 }
 
 void MarlinUI::update() {
-  hmiSDCardUpdate();   // SD card update
-  eachMomentUpdate();   // Status update
-  dwinHandleScreen();  // Rotary encoder update
+  hmiSDCardUpdate();  // SD card update
+  eachMomentUpdate(); // Status update
+  dwinHandleScreen(); // Rotary encoder update
 }
 
 void MarlinUI::refresh() { /* Nothing to see here */ }
 
 #if HAS_LCD_BRIGHTNESS
   void MarlinUI::_set_brightness() { dwinLCDBrightness(backlight ? brightness : 0); }
 #endif
 
 void MarlinUI::kill_screen(FSTR_P const lcd_error, FSTR_P const) {
   dwinDrawPopup(ICON_BLTouch, GET_TEXT_F(MSG_PRINTER_KILLED), lcd_error);
@@ -2385,21 +2380,22 @@ void setFlow() { setPIntOnClick(FLOW_EDIT_MIN, FLOW_EDIT_MAX, []{ planner.refres
         y = Y_BED_SIZE - bed_tramming_inset_lfbr[3];
         break;
       case 3:
         LCD_MESSAGE(MSG_TRAM_BL);
         x = bed_tramming_inset_lfbr[0];
         y = Y_BED_SIZE - bed_tramming_inset_lfbr[3];
         break;
       #if ENABLED(BED_TRAMMING_INCLUDE_CENTER)
         case 4:
           LCD_MESSAGE(MSG_TRAM_C);
-          x = X_CENTER; y = Y_CENTER;
+          x = X_CENTER;
+          y = Y_CENTER;
           break;
       #endif
     }
   }
 
   #if HAS_BED_PROBE
 
     float tram(const uint8_t point) {
       static bool inLev = false;
       if (inLev) return NAN;
@@ -2476,30 +2472,30 @@ void setFlow() { setPIntOnClick(FLOW_EDIT_MIN, FLOW_EDIT_MAX, []{ planner.refres
       DWINUI::drawCenteredString(160, F("and relative heights"));
       safe_delay(1000);
       float avg = 0.0f;
       for (uint8_t x = 0; x < 2; ++x) for (uint8_t y = 0; y < 2; ++y) avg += zval[x][y];
       avg /= 4.0f;
       for (uint8_t x = 0; x < 2; ++x) for (uint8_t y = 0; y < 2; ++y) zval[x][y] -= avg;
       meshViewer.drawMesh(zval, 2, 2);
       ui.reset_status();
 
       #ifndef BED_TRAMMING_PROBE_TOLERANCE
-        #define BED_TRAMMING_PROBE_TOLERANCE 0.05
+        #define BED_TRAMMING_PROBE_TOLERANCE 0.05f
       #endif
 
       if (ABS(meshViewer.max - meshViewer.min) < BED_TRAMMING_PROBE_TOLERANCE) {
         DWINUI::drawCenteredString(140, F("Corners leveled"));
         DWINUI::drawCenteredString(160, F("Tolerance achieved!"));
       }
       else {
         uint8_t p = 0;
-        float max = 0;
+        float max = 0.0f;
         FSTR_P plabel;
         bool s = true;
         for (uint8_t x = 0; x < 2; ++x) for (uint8_t y = 0; y < 2; ++y) {
           const float d = ABS(zval[x][y]);
           if (max < d) {
             s = (zval[x][y] >= 0);
             max = d;
             p = x + 2 * y;
           }
         }
@@ -2759,23 +2755,23 @@ void onDrawSelColorItem(MenuItem* menuitem, int8_t line) {
   const uint16_t color = *(uint16_t*)static_cast<MenuItemPtr*>(menuitem)->value;
   dwinDrawRectangle(0, hmiData.colorHighlight, ICOX + 1, MBASE(line) - 1 + 1, ICOX + 18, MBASE(line) - 1 + 18);
   dwinDrawRectangle(1, color, ICOX + 2, MBASE(line) - 1 + 2, ICOX + 17, MBASE(line) - 1 + 17);
   onDrawMenuItem(menuitem, line);
 }
 
 void onDrawGetColorItem(MenuItem* menuitem, int8_t line) {
   const uint8_t i = menuitem->icon;
   uint16_t color;
   switch (i) {
-    case 0: color = RGB(31, 0, 0); break; // Red
-    case 1: color = RGB(0, 63, 0); break; // Green
-    case 2: color = RGB(0, 0, 31); break; // Blue
+    case 0:  color = RGB(31, 0, 0); break; // Red
+    case 1:  color = RGB(0, 63, 0); break; // Green
+    case 2:  color = RGB(0, 0, 31); break; // Blue
     default: color = 0; break;
   }
   dwinDrawRectangle(0, hmiData.colorHighlight, ICOX + 1, MBASE(line) - 1 + 1, ICOX + 18, MBASE(line) - 1 + 18);
   dwinDrawRectangle(1, color, ICOX + 2, MBASE(line) - 1 + 2, ICOX + 17, MBASE(line) - 1 + 17);
   DWINUI::drawString(LBLX, MBASE(line) - 1, menuitem->caption);
   drawMenuIntValue(hmiData.colorBackground, line, 4, hmiValue.color[i]);
   dwinDrawHLine(hmiData.colorSplitLine, 16, MYPOS(line + 1), 240);
 }
 
 void onDrawSpeedItem(MenuItem* menuitem, int8_t line) {
@@ -3793,23 +3789,23 @@ void drawMaxAccelMenu() {
       EDIT_ITEM_F(0, "Coordinate value", onDrawSelColorItem, selColor, &hmiData.colorCoordinate);
     }
     updateMenu(selectColorMenu);
   }
 
   void drawGetColorMenu() {
     checkkey = ID_Menu;
     if (SET_MENU(getColorMenu, MSG_COLORS_GET, 5)) {
       BACK_ITEM(dwinApplyColor);
       MENU_ITEM(ICON_Cancel, MSG_BUTTON_CANCEL, onDrawMenuItem, drawSelectColorsMenu);
-      MENU_ITEM(0, MSG_COLORS_RED, onDrawGetColorItem, setRGBColor);
+      MENU_ITEM(0, MSG_COLORS_RED,   onDrawGetColorItem, setRGBColor);
       MENU_ITEM(1, MSG_COLORS_GREEN, onDrawGetColorItem, setRGBColor);
-      MENU_ITEM(2, MSG_COLORS_BLUE, onDrawGetColorItem, setRGBColor);
+      MENU_ITEM(2, MSG_COLORS_BLUE,  onDrawGetColorItem, setRGBColor);
     }
     updateMenu(getColorMenu);
     dwinDrawRectangle(1, *menuData.intPtr, 20, 315, DWIN_WIDTH - 20, 335);
   }
 
 #endif // HAS_CUSTOM_COLORS
 
 //=============================================================================
 // Nozzle and Bed PID/MPC
 //=============================================================================

commit 854f3315af645775e7b0aa39bd05db66187bcc38
Author: plampix <plampix@users.noreply.github.com>
Date:   Wed Jan 10 07:33:54 2024 +0100

    ‚ú® EDITABLE_STEPS_PER_UNIT (#26618)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index b42a9a263b..721859f1be 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -3521,21 +3521,23 @@ void drawMotionMenu() {
     #endif
     #if ENABLED(LIN_ADVANCE)
       EDIT_ITEM(ICON_MaxAccelerated, MSG_ADVANCE_K, onDrawPFloat3Menu, setLA_K, &planner.extruder_advance_K[0]);
     #endif
     #if ENABLED(SHAPING_MENU)
       MENU_ITEM(ICON_InputShaping, MSG_INPUT_SHAPING, onDrawSubMenu, drawInputShaping_menu);
     #endif
     #if ENABLED(ADAPTIVE_STEP_SMOOTHING)
       EDIT_ITEM(ICON_UBLActive, MSG_STEP_SMOOTHING, onDrawChkbMenu, setAdaptiveStepSmoothing, &hmiData.adaptiveStepSmoothing);
     #endif
-    MENU_ITEM(ICON_Step, MSG_STEPS_PER_MM, onDrawSteps, drawStepsMenu);
+    #if ENABLED(EDITABLE_STEPS_PER_UNIT)
+      MENU_ITEM(ICON_Step, MSG_STEPS_PER_MM, onDrawSteps, drawStepsMenu);
+    #endif
     EDIT_ITEM(ICON_Flow, MSG_FLOW, onDrawPIntMenu, setFlow, &planner.flow_percentage[0]);
     EDIT_ITEM(ICON_Speed, MSG_SPEED, onDrawPIntMenu, setSpeed, &feedrate_percentage);
   }
   updateMenu(motionMenu);
 }
 
 #if ALL(ADVANCED_PAUSE_FEATURE, HAS_PREHEAT)
 
     void drawPreheatHotendMenu() {
       checkkey = ID_Menu;
@@ -3696,39 +3698,43 @@ void drawMaxAccelMenu() {
       #endif
       #if HAS_HOTEND
         EDIT_ITEM(ICON_MaxSpeedJerkE, MSG_VE_JERK, onDrawMaxJerkE, setMaxJerkE, &planner.max_jerk.e);
       #endif
     }
     updateMenu(maxJerkMenu);
   }
 
 #endif // CLASSIC_JERK
 
-void drawStepsMenu() {
-  checkkey = ID_Menu;
-  if (SET_MENU_R(stepsMenu, selrect({1, 16, 28, 13}), MSG_STEPS_PER_MM, 5)) {
-    BACK_ITEM(drawMotionMenu);
-    #if HAS_X_AXIS
-      EDIT_ITEM(ICON_StepX, MSG_A_STEPS, onDrawStepsX, setStepsX, &planner.settings.axis_steps_per_mm[X_AXIS]);
-    #endif
-    #if HAS_Y_AXIS
-      EDIT_ITEM(ICON_StepY, MSG_B_STEPS, onDrawStepsY, setStepsY, &planner.settings.axis_steps_per_mm[Y_AXIS]);
-    #endif
-    #if HAS_Z_AXIS
-      EDIT_ITEM(ICON_StepZ, MSG_C_STEPS, onDrawStepsZ, setStepsZ, &planner.settings.axis_steps_per_mm[Z_AXIS]);
-    #endif
-    #if HAS_HOTEND
-      EDIT_ITEM(ICON_StepE, MSG_E_STEPS, onDrawStepsE, setStepsE, &planner.settings.axis_steps_per_mm[E_AXIS]);
-    #endif
+#if ENABLED(EDITABLE_STEPS_PER_UNIT)
+
+  void drawStepsMenu() {
+    checkkey = ID_Menu;
+    if (SET_MENU_R(stepsMenu, selrect({1, 16, 28, 13}), MSG_STEPS_PER_MM, 5)) {
+      BACK_ITEM(drawMotionMenu);
+      #if HAS_X_AXIS
+        EDIT_ITEM(ICON_StepX, MSG_A_STEPS, onDrawStepsX, setStepsX, &planner.settings.axis_steps_per_mm[X_AXIS]);
+      #endif
+      #if HAS_Y_AXIS
+        EDIT_ITEM(ICON_StepY, MSG_B_STEPS, onDrawStepsY, setStepsY, &planner.settings.axis_steps_per_mm[Y_AXIS]);
+      #endif
+      #if HAS_Z_AXIS
+        EDIT_ITEM(ICON_StepZ, MSG_C_STEPS, onDrawStepsZ, setStepsZ, &planner.settings.axis_steps_per_mm[Z_AXIS]);
+      #endif
+      #if HAS_HOTEND
+        EDIT_ITEM(ICON_StepE, MSG_E_STEPS, onDrawStepsE, setStepsE, &planner.settings.axis_steps_per_mm[E_AXIS]);
+      #endif
+    }
+    updateMenu(stepsMenu);
   }
-  updateMenu(stepsMenu);
-}
+
+#endif
 
 //=============================================================================
 // UI editable custom colors
 //=============================================================================
 
 #if HAS_CUSTOM_COLORS
 
   void restoreDefaultColors() {
     dwinSetColorDefaults();
     DWINUI::setColors(hmiData.colorText, hmiData.colorBackground, hmiData.colorStatusBg);

commit cb291e8d00a6c1ee0a778625e0170b6b7430a004
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jan 9 22:41:00 2024 -0600

    ü©π Fix some temp constraints

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 7520b46b60..b42a9a263b 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -147,22 +147,22 @@
 // Juntion deviation limits
 #define MIN_JD_MM             0.001
 #define MAX_JD_MM             TERN(LIN_ADVANCE, 0.3f, 0.5f)
 
 #if HAS_TRINAMIC_CONFIG
   #define MIN_TMC_CURRENT 100
   #define MAX_TMC_CURRENT 3000
 #endif
 
 // Editable temperature limits
-#define MIN_ETEMP  0
-#define MAX_ETEMP  (thermalManager.hotend_maxtemp[0] - (HOTEND_OVERSHOOT))
+#define MIN_ETEMP   0
+#define MAX_ETEMP   thermalManager.hotend_max_target(0)
 #define MIN_BEDTEMP 0
 #define MAX_BEDTEMP BED_MAX_TARGET
 
 #define DWIN_VAR_UPDATE_INTERVAL          500
 #define DWIN_UPDATE_INTERVAL             1000
 
 #if HAS_MESH && HAS_BED_PROBE
   #define BABY_Z_VAR probe.offset.z
 #else
   float z_offset = 0;

commit 6e67ad51b70ce4f02be967bb14e5557a021e48eb
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Thu Jan 4 18:07:53 2024 -0500

    üé® Followup to optional M111/M115 (#26626)
    
    Followup to #26603

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 5262dba385..7520b46b60 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -2299,21 +2299,21 @@ void setMoveZ() { hmiValue.axis = Z_AXIS; setPFloatOnClick(Z_MIN_POS, Z_MAX_POS,
   void setRunoutEnable() {
     runout.reset();
     toggleCheckboxLine(runout.enabled);
   }
   #if HAS_FILAMENT_RUNOUT_DISTANCE
     void applyRunoutDistance() { runout.set_runout_distance(menuData.value / MINUNITMULT); }
     void setRunoutDistance() { setFloatOnClick(0, 999, UNITFDIGITS, runout.runout_distance(), applyRunoutDistance); }
   #endif
 #endif
 
-#if ENABLED(ADVANCED_PAUSE_FEATURE)
+#if ENABLED(CONFIGURE_FILAMENT_CHANGE)
   void setFilLoad()   { setPFloatOnClick(0, EXTRUDE_MAXLENGTH, UNITFDIGITS); }
   void setFilUnload() { setPFloatOnClick(0, EXTRUDE_MAXLENGTH, UNITFDIGITS); }
 #endif
 
 #if ENABLED(PREVENT_COLD_EXTRUSION)
   void applyExtMinT() { thermalManager.extrude_min_temp = hmiData.extMinT; thermalManager.allow_cold_extrude = (hmiData.extMinT == 0); }
   void setExtMinT() { setPIntOnClick(MIN_ETEMP, MAX_ETEMP, applyExtMinT); }
 #endif
 
 void setSpeed() { setPIntOnClick(SPEED_EDIT_MIN, SPEED_EDIT_MAX); }

commit 6d407767e7692d66bc93a0012d71268770e4835c
Author: plampix <plampix@users.noreply.github.com>
Date:   Wed Jan 3 16:43:18 2024 +0100

    üîß CONFIGURE_FILAMENT_CHANGE - Optional M603 (#26613)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 894102e8a3..5262dba385 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -3295,21 +3295,21 @@ void drawFilSetMenu() {
     BACK_ITEM(drawAdvancedSettingsMenu);
     #if HAS_FILAMENT_SENSOR
       EDIT_ITEM(ICON_Runout, MSG_RUNOUT_ENABLE, onDrawChkbMenu, setRunoutEnable, &runout.enabled);
     #endif
     #if HAS_FILAMENT_RUNOUT_DISTANCE
       EDIT_ITEM(ICON_Runout, MSG_RUNOUT_DISTANCE_MM, onDrawPFloatMenu, setRunoutDistance, &runout.runout_distance());
     #endif
     #if ENABLED(PREVENT_COLD_EXTRUSION)
       EDIT_ITEM(ICON_ExtrudeMinT, MSG_EXTRUDER_MIN_TEMP, onDrawPIntMenu, setExtMinT, &hmiData.extMinT);
     #endif
-    #if ENABLED(ADVANCED_PAUSE_FEATURE)
+    #if ENABLED(CONFIGURE_FILAMENT_CHANGE)
       EDIT_ITEM(ICON_FilLoad, MSG_FILAMENT_LOAD, onDrawPFloatMenu, setFilLoad, &fc_settings[0].load_length);
       EDIT_ITEM(ICON_FilUnload, MSG_FILAMENT_UNLOAD, onDrawPFloatMenu, setFilUnload, &fc_settings[0].unload_length);
     #endif
     #if ENABLED(FWRETRACT)
       MENU_ITEM(ICON_FWRetract, MSG_FWRETRACT, onDrawSubMenu, drawFWRetractMenu);
     #endif
   }
   updateMenu(filSetMenu);
 }
 

commit 0f0955492994f4a7f4649c22e0f3aa5cc71541d7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Dec 24 14:53:09 2023 -0600

    üßë‚Äçüíª DWIN icon updates, etc.

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index fcebdb8c57..894102e8a3 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -329,84 +329,84 @@ void ICON_Button(const bool selected, const int iconid, const frame_rect_t &ico,
                    y = (ico.y + ico.h - 20) - DWINUI::fontHeight() / 2;
     DWINUI::drawString(x, y, caption);
   }
 }
 
 //
 // Main Menu: "Print"
 //
 void ICON_Print() {
   constexpr frame_rect_t ico = { 17, 110, 110, 100 };
-  constexpr text_info_t txt = { 1, { 405, TERN(USE_STOCK_DWIN_SET, 446, 447) }, 27, 15 };
+  constexpr text_info_t txt = { 1, { 405, 447 }, 27, 15 };
   ICON_Button(select_page.now == PAGE_PRINT, ICON_Print_0, ico, txt, GET_TEXT_F(MSG_BUTTON_PRINT));
 }
 
 //
 // Main Menu: "Prepare"
 //
 void ICON_Prepare() {
   constexpr frame_rect_t ico = { 145, 110, 110, 100 };
-  constexpr text_info_t txt = { 31, { 405, TERN(USE_STOCK_DWIN_SET, 446, 447) }, 27, 15 };
+  constexpr text_info_t txt = { 31, { 405, 447 }, 27, 15 };
   ICON_Button(select_page.now == PAGE_PREPARE, ICON_Prepare_0, ico, txt, GET_TEXT_F(MSG_PREPARE));
 }
 
 //
 // Main Menu: "Control"
 //
 void ICON_Control() {
   constexpr frame_rect_t ico = { 17, 226, 110, 100 };
-  constexpr text_info_t txt = { 61, { 405, TERN(USE_STOCK_DWIN_SET, 446, 447) }, 27, 15 };
+  constexpr text_info_t txt = { 61, { 405, 447 }, 27, 15 };
   ICON_Button(select_page.now == PAGE_CONTROL, ICON_Control_0, ico, txt, GET_TEXT_F(MSG_CONTROL));
 }
 
 //
 // Main Menu: "Advanced Settings"
 //
 void ICON_AdvSettings() {
   constexpr frame_rect_t ico = { 145, 226, 110, 100 };
-  constexpr text_info_t txt = { 91, { 405, TERN(USE_STOCK_DWIN_SET, 446, 447) }, 27, 15 };
+  constexpr text_info_t txt = { 91, { 405, 447 }, 27, 15 };
   ICON_Button(select_page.now == PAGE_ADVANCE, ICON_Info_0, ico, txt, GET_TEXT_F(MSG_BUTTON_ADVANCED));
 }
 
 //
 // Printing: "Tune"
 //
 void ICON_Tune() {
   constexpr frame_rect_t ico = { 8, 232, 80, 100 };
-  constexpr text_info_t txt = { 121, { 405, TERN(USE_STOCK_DWIN_SET, 446, 447) }, 27, 15 };
+  constexpr text_info_t txt = { 121, { 405, 447 }, 27, 15 };
   ICON_Button(select_print.now == PRINT_SETUP, ICON_Setup_0, ico, txt, GET_TEXT_F(MSG_TUNE));
 }
 
 //
 // Printing: "Pause"
 //
 void ICON_Pause() {
   constexpr frame_rect_t ico = { 96, 232, 80, 100 };
-  constexpr text_info_t txt = { 181, { 405, TERN(USE_STOCK_DWIN_SET, 446, 447) }, 27, 15 };
+  constexpr text_info_t txt = { 181, { 405, 447 }, 27, 15 };
   ICON_Button(select_print.now == PRINT_PAUSE_RESUME, ICON_Pause_0, ico, txt, GET_TEXT_F(MSG_BUTTON_PAUSE));
 }
 
 //
 // Printing: "Resume"
 //
 void ICON_Resume() {
   constexpr frame_rect_t ico = { 96, 232, 80, 100 };
-  constexpr text_info_t txt = { 1, { 405, TERN(USE_STOCK_DWIN_SET, 446, 447) }, 27, 15 };
+  constexpr text_info_t txt = { 1, { 405, 447 }, 27, 15 };
   ICON_Button(select_print.now == PRINT_PAUSE_RESUME, ICON_Continue_0, ico, txt, GET_TEXT_F(MSG_BUTTON_RESUME));
 }
 
 //
 // Printing: "Stop"
 //
 void ICON_Stop() {
   constexpr frame_rect_t ico = { 184, 232, 80, 100 };
-  constexpr text_info_t txt = { 151, { 405, TERN(USE_STOCK_DWIN_SET, 446, 447) }, 27, 12 };
+  constexpr text_info_t txt = { 151, { 405, 447 }, 27, 12 };
   ICON_Button(select_print.now == PRINT_STOP, ICON_Stop_0, ico, txt, GET_TEXT_F(MSG_BUTTON_STOP));
 }
 
 //
 // PopUps
 //
 void popupPauseOrStop() {
   if (hmiIsChinese()) {
     DWINUI::clearMainArea();
     drawPopupBkgd();
@@ -475,22 +475,21 @@ void dwinDrawStatusLine(FSTR_P fstr) { dwinDrawStatusLine(FTOP(fstr)); }
 
 // Clear & reset status line
 void dwinResetStatusLine() {
   ui.status_message.clear();
   dwinCheckStatusMessage();
 }
 
 // Djb2 hash algorithm
 uint32_t getHash(char * str) {
   uint32_t hash = 5381;
-  char c;
-  while ((c = *str++)) hash = ((hash << 5) + hash) + c; /* hash * 33 + c */
+  for (char c; (c = *str++);) hash = ((hash << 5) + hash) + c; /* hash * 33 + c */
   return hash;
 }
 
 // Check for a change in the status message
 void dwinCheckStatusMessage() {
   static MString<>::hash_t old_hash = 0x0000;
   const MString<>::hash_t hash = ui.status_message.hash();
   hash_changed = hash != old_hash;
   old_hash = hash;
 }
@@ -1936,27 +1935,21 @@ void dwinRedrawScreen() {
   void MarlinUI::pause_show_message(const PauseMessage message, const PauseMode mode/*=PAUSE_MODE_SAME*/, const uint8_t extruder/*=active_extruder*/) {
     //if (mode == PAUSE_MODE_SAME) return;
     pause_mode = mode;
     switch (message) {
       case PAUSE_MESSAGE_PARKING:  dwinPopupPause(GET_TEXT_F(MSG_PAUSE_PRINT_PARKING));    break;                // M125
       case PAUSE_MESSAGE_CHANGING: dwinPopupPause(GET_TEXT_F(MSG_FILAMENT_CHANGE_INIT));   break;                // pause_print (M125, M600)
       case PAUSE_MESSAGE_WAITING:  dwinPopupPause(GET_TEXT_F(MSG_ADVANCED_PAUSE_WAITING), BTN_Continue); break;
       case PAUSE_MESSAGE_INSERT:   dwinPopupPause(GET_TEXT_F(MSG_FILAMENT_CHANGE_INSERT), BTN_Continue); break;
       case PAUSE_MESSAGE_LOAD:     dwinPopupPause(GET_TEXT_F(MSG_FILAMENT_CHANGE_LOAD));   break;
       case PAUSE_MESSAGE_UNLOAD:   dwinPopupPause(GET_TEXT_F(MSG_FILAMENT_CHANGE_UNLOAD)); break;                // Unload of pause and Unload of M702
-      case PAUSE_MESSAGE_PURGE:
-        #if ENABLED(ADVANCED_PAUSE_CONTINUOUS_PURGE)
-          dwinPopupPause(GET_TEXT_F(MSG_FILAMENT_CHANGE_CONT_PURGE));
-        #else
-          dwinPopupPause(GET_TEXT_F(MSG_FILAMENT_CHANGE_PURGE));
-        #endif
-        break;
+      case PAUSE_MESSAGE_PURGE:    dwinPopupPause(GET_TEXT_F(TERN(ADVANCED_PAUSE_CONTINUOUS_PURGE, MSG_FILAMENT_CHANGE_CONT_PURGE, MSG_FILAMENT_CHANGE_PURGE))); break;
       case PAUSE_MESSAGE_OPTION:   gotoFilamentPurge(); break;
       case PAUSE_MESSAGE_RESUME:   dwinPopupPause(GET_TEXT_F(MSG_FILAMENT_CHANGE_RESUME)); break;
       case PAUSE_MESSAGE_HEAT:     dwinPopupPause(GET_TEXT_F(MSG_FILAMENT_CHANGE_HEAT), BTN_Continue);   break;
       case PAUSE_MESSAGE_HEATING:  dwinPopupPause(GET_TEXT_F(MSG_FILAMENT_CHANGE_HEATING)); break;
       case PAUSE_MESSAGE_STATUS:   hmiReturnScreen(); break;                                                      // Exit from Pause, Load and Unload
       default: break;
     }
   }
 
   void drawPopupFilamentPurge() {
@@ -3134,21 +3127,21 @@ void drawControlMenu() {
         MENU_ITEM(ICON_CaseLight, MSG_CASE_LIGHT, onDrawChkbMenu, setCaseLight, &caselight.on);
       #endif
     #endif
     #if ENABLED(LED_CONTROL_MENU)
       enableLiveLedColor = true;  // Allow live update of color in control menu
       MENU_ITEM(ICON_LedControl, MSG_LED_CONTROL, onDrawSubMenu, drawLedControlMenu);
     #endif
     #if ENABLED(EEPROM_SETTINGS)
       MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawWriteEeprom, writeEEPROM);
       MENU_ITEM(ICON_ReadEEPROM, MSG_LOAD_EEPROM, onDrawReadEeprom, readEEPROM);
-      MENU_ITEM(ICON_ResumeEEPROM, MSG_RESTORE_DEFAULTS, onDrawResetEeprom, resetEEPROM);
+      MENU_ITEM(ICON_ResetEEPROM, MSG_RESTORE_DEFAULTS, onDrawResetEeprom, resetEEPROM);
     #endif
     MENU_ITEM(ICON_Reboot, MSG_RESET_PRINTER, onDrawMenuItem, rebootPrinter);
     MENU_ITEM(ICON_Info, MSG_INFO_SCREEN, onDrawInfoSubMenu, gotoInfoMenu);
   }
   ui.reset_status(true);
   updateMenu(controlMenu);
 }
 
 void drawAdvancedSettingsMenu() {
   checkkey = ID_Menu;
@@ -3950,22 +3943,22 @@ void drawStepsMenu() {
 
 //=============================================================================
 
 #if HAS_BED_PROBE
 
   void drawZOffsetWizMenu() {
     checkkey = ID_Menu;
     if (SET_MENU(zOffsetWizMenu, MSG_PROBE_WIZARD, 4)) {
       BACK_ITEM(drawPrepareMenu);
       MENU_ITEM(ICON_Homing, MSG_AUTO_HOME, onDrawMenuItem, autoHome);
-      MENU_ITEM_F(ICON_MoveZ0, "Move Z to Home", onDrawMenuItem, setMoveZto0);
-      EDIT_ITEM(ICON_Zoffset, MSG_ZPROBE_ZOFFSET, onDrawPFloat2Menu, setZOffset, &BABY_Z_VAR);
+      MENU_ITEM(ICON_MoveZ0, MSG_MOVE_NOZZLE_TO_BED, onDrawMenuItem, setMoveZto0);
+      EDIT_ITEM(ICON_Zoffset, MSG_XATC_UPDATE_Z_OFFSET, onDrawPFloat2Menu, setZOffset, &BABY_Z_VAR);
     }
     updateMenu(zOffsetWizMenu);
     if (!axis_is_trusted(Z_AXIS)) LCD_MESSAGE_F("WARNING: Z position unknown, move Z to home");
   }
 
 #endif
 
 #if ENABLED(INDIVIDUAL_AXIS_HOMING_SUBMENU)
 
   void drawHomingMenu() {

commit 56ac5d03ed0901b721d816a41126854a96b1d67f
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Fri Dec 22 13:57:06 2023 -0500

    üö∏ Update ProUI Plot graph (#26539)

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 8d54e0c582..fcebdb8c57 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -728,21 +728,21 @@ void _drawIconBlink(bool &flag, const bool sensor, const uint8_t icon1, const ui
       flag = sensor;
       dwinDrawBox(1, hmiData.colorBackground, x, y, 20, 20);
       DWINUI::drawIcon(flag ? icon2 : icon1, x, y);
     }
   #endif
 }
 
 void _drawZOffsetIcon() {
   #if HAS_LEVELING
     static bool _leveling_active = false;
-    _drawIconBlink(_leveling_active, planner.leveling_active, ICON_Zoffset, ICON_SetZOffset, 186, 416);
+    _drawIconBlink(_leveling_active, planner.leveling_active, ICON_Zoffset, ICON_SetZOffset, 187, 416);
   #else
     DWINUI::drawIcon(ICON_Zoffset, 187, 416);
   #endif
 }
 
 void _drawFeedrate() {
   #if ENABLED(SHOW_SPEED_IND)
     int16_t _value;
     if (blink) {
       _value = feedrate_percentage;
@@ -756,45 +756,67 @@ void _drawFeedrate() {
   #else
     static int16_t _feedrate = 100;
     if (_feedrate != feedrate_percentage) {
       _feedrate = feedrate_percentage;
       DWINUI::drawInt(DWIN_FONT_STAT, hmiData.colorIndicator, hmiData.colorBackground, 3, 116 + 2 * STAT_CHR_W, 384, _feedrate);
     }
   #endif
 }
 
 void _drawXYZPosition(const bool force) {
-  _update_axis_value(X_AXIS,  27, 459, force);
-  _update_axis_value(Y_AXIS, 112, 459, force);
-  _update_axis_value(Z_AXIS, 197, 459, force);
+  _update_axis_value(X_AXIS,  27, 457, force);
+  _update_axis_value(Y_AXIS, 112, 457, force);
+  _update_axis_value(Z_AXIS, 197, 457, force);
 }
 
 void updateVariable() {
   _drawXYZPosition(false);
   #if HAS_HOTEND
     static celsius_t _hotendtemp = 0, _hotendtarget = 0;
     const celsius_t hc = thermalManager.wholeDegHotend(0),
                     ht = thermalManager.degTargetHotend(0);
     const bool _new_hotend_temp = _hotendtemp != hc,
                _new_hotend_target = _hotendtarget != ht;
     if (_new_hotend_temp) _hotendtemp = hc;
     if (_new_hotend_target) _hotendtarget = ht;
-  #endif
+
+    // if hotend is near target or heating, ICON indicates hot
+    if (thermalManager.degHotendNear(0, ht) || thermalManager.isHeatingHotend(0)) {
+      dwinDrawBox(1, hmiData.colorBackground, 10, 383, 20, 20);
+      DWINUI::drawIcon(ICON_SetEndTemp, 10, 383);
+    }
+    else {
+      dwinDrawBox(1, hmiData.colorBackground, 10, 383, 20, 20);
+      DWINUI::drawIcon(ICON_HotendTemp, 10, 383);
+    }
+  #endif // HAS_HOTEND
+
   #if HAS_HEATED_BED
     static celsius_t _bedtemp = 0, _bedtarget = 0;
     const celsius_t bc = thermalManager.wholeDegBed(),
                     bt = thermalManager.degTargetBed();
     const bool _new_bed_temp = _bedtemp != bc,
                _new_bed_target = _bedtarget != bt;
     if (_new_bed_temp) _bedtemp = bc;
     if (_new_bed_target) _bedtarget = bt;
-  #endif
+
+    // if bed is near target, heating, or if degrees > 44, ICON indicates hot
+    if (thermalManager.degBedNear(bt) || thermalManager.isHeatingBed() || (bc > 44)) {
+      dwinDrawBox(1, hmiData.colorBackground, 10, 416, 20, 20);
+      DWINUI::drawIcon(ICON_BedTemp, 10, 416);
+    }
+    else {
+      dwinDrawBox(1, hmiData.colorBackground, 10, 416, 20, 20);
+      DWINUI::drawIcon(ICON_SetBedTemp, 10, 416);
+    }
+  #endif // HAS_HEATED_BED
+
   #if HAS_FAN
     static uint8_t _fanspeed = 0;
     const bool _new_fanspeed = _fanspeed != thermalManager.fan_speed[0];
     if (_new_fanspeed) _fanspeed = thermalManager.fan_speed[0];
   #endif
 
   if (isMenu(tuneMenu) || isMenu(temperatureMenu)) {
     // Tune page temperature update
     TERN_(HAS_HOTEND, if (_new_hotend_target) hotendTargetItem->redraw());
     TERN_(HAS_HEATED_BED, if (_new_bed_target) bedTargetItem->redraw());
@@ -1015,32 +1037,32 @@ void hmiSDCardUpdate() {
 }
 
 /**
  * Dash board and indicators
  */
 
 void dwinDrawDashboard() {
   dwinDrawRectangle(1, hmiData.colorBackground, 0, STATUS_Y + 21, DWIN_WIDTH, DWIN_HEIGHT - 1);
   dwinDrawRectangle(1, hmiData.colorSplitLine, 0, 449, DWIN_WIDTH, 451);
 
-  DWINUI::drawIcon(ICON_MaxSpeedX,  10, 456);
-  DWINUI::drawIcon(ICON_MaxSpeedY,  95, 456);
-  DWINUI::drawIcon(ICON_MaxSpeedZ, 180, 456);
+  DWINUI::drawIcon(ICON_MaxSpeedX,  10, 454);
+  DWINUI::drawIcon(ICON_MaxSpeedY,  95, 454);
+  DWINUI::drawIcon(ICON_MaxSpeedZ, 180, 454);
   _drawXYZPosition(true);
 
   #if HAS_HOTEND
     DWINUI::drawIcon(ICON_HotendTemp, 10, 383);
     DWINUI::drawInt(DWIN_FONT_STAT, hmiData.colorIndicator, hmiData.colorBackground, 3, 28, 384, thermalManager.wholeDegHotend(0));
     DWINUI::drawString(DWIN_FONT_STAT, hmiData.colorIndicator, hmiData.colorBackground, 25 + 3 * STAT_CHR_W + 5, 384, F("/"));
     DWINUI::drawInt(DWIN_FONT_STAT, hmiData.colorIndicator, hmiData.colorBackground, 3, 25 + 4 * STAT_CHR_W + 6, 384, thermalManager.degTargetHotend(0));
 
-    DWINUI::drawIcon(ICON_StepE, 112, 417);
+    DWINUI::drawIcon(ICON_StepE, 113, 416);
     DWINUI::drawInt(DWIN_FONT_STAT, hmiData.colorIndicator, hmiData.colorBackground, 3, 116 + 2 * STAT_CHR_W, 417, planner.flow_percentage[0]);
     DWINUI::drawString(DWIN_FONT_STAT, hmiData.colorIndicator, hmiData.colorBackground, 116 + 5 * STAT_CHR_W + 2, 417, F("%"));
   #endif
 
   #if HAS_HEATED_BED
     DWINUI::drawIcon(ICON_BedTemp, 10, 416);
     DWINUI::drawInt(DWIN_FONT_STAT, hmiData.colorIndicator, hmiData.colorBackground, 3, 28, 417, thermalManager.wholeDegBed());
     DWINUI::drawString(DWIN_FONT_STAT, hmiData.colorIndicator, hmiData.colorBackground, 25 + 3 * STAT_CHR_W + 5, 417, F("/"));
     DWINUI::drawInt(DWIN_FONT_STAT, hmiData.colorIndicator, hmiData.colorBackground, 3, 25 + 4 * STAT_CHR_W + 6, 417, thermalManager.degTargetBed());
   #endif
@@ -1262,20 +1284,30 @@ void eachMomentUpdate() {
     updateVariable();
     #if HAS_ESDIAG
       if (checkkey == ID_ESDiagProcess) esDiag.update();
     #endif
     #if PROUI_TUNING_GRAPH
       if (checkkey == ID_PIDProcess) {
         TERN_(PIDTEMP, if (hmiValue.tempControl == PIDTEMP_START) plot.update(thermalManager.wholeDegHotend(0)));
         TERN_(PIDTEMPBED, if (hmiValue.tempControl == PIDTEMPBED_START) plot.update(thermalManager.wholeDegBed()));
       }
       TERN_(MPCTEMP, if (checkkey == ID_MPCProcess) plot.update(thermalManager.wholeDegHotend(0)));
+      #if ENABLED(PROUI_ITEM_PLOT)
+        if (checkkey == ID_PlotProcess) {
+          TERN_(PIDTEMP, if (hmiValue.tempControl == PIDTEMP_START) { plot.update(thermalManager.wholeDegHotend(0)); })
+          TERN_(PIDTEMPBED, if (hmiValue.tempControl == PIDTEMPBED_START) { plot.update(thermalManager.wholeDegBed()); })
+          TERN_(MPCTEMP, if (hmiValue.tempControl == MPCTEMP_START) { plot.update(thermalManager.wholeDegHotend(0)); })
+          if (hmiFlag.abort_flag || hmiFlag.pause_flag || print_job_timer.isPaused()) {
+            hmiReturnScreen();
+          }
+        }
+      #endif
     #endif
   }
 
   #if HAS_STATUS_MESSAGE_TIMEOUT
     bool did_expire = ui.status_reset_callback && (*ui.status_reset_callback)();
     did_expire |= ui.status_message_expire_ms && ELAPSED(ms, ui.status_message_expire_ms);
     if (did_expire) ui.reset_status();
   #endif
 
   if (ELAPSED(ms, next_status_update_ms)) {
@@ -1395,59 +1427,63 @@ void dwinHandleScreen() {
   switch (checkkey) {
     case ID_MainMenu:     hmiMainMenu(); break;
     case ID_Menu:         hmiMenu(); break;
     case ID_SetInt:       hmiSetDraw(); break;
     case ID_SetFloat:     hmiSetDraw(); break;
     case ID_SetPInt:      hmiSetPInt(); break;
     case ID_SetPFloat:    hmiSetPFloat(); break;
     case ID_SetIntNoDraw: hmiSetNoDraw(); break;
     case ID_PrintProcess: hmiPrinting(); break;
     case ID_Popup:        hmiPopup(); break;
-    case ID_Leveling:     break;
     #if HAS_LOCKSCREEN
       case ID_Locked:     hmiLockScreen(); break;
     #endif
-    case ID_PrintDone:
+
     TERN_(HAS_ESDIAG, case ID_ESDiagProcess:)
+    TERN_(PROUI_ITEM_PLOT, case ID_PlotProcess:)
+    case ID_PrintDone:
     case ID_WaitResponse: hmiWaitForUser(); break;
+
+    TERN_(HAS_BED_PROBE, case ID_Leveling:)
     case ID_Homing:
     case ID_PIDProcess:
-    case ID_NothingToDo:  break;
+    case ID_NothingToDo:
     default: break;
   }
 }
 
 bool idIsPopUp() {    // If ID is popup...
   switch (checkkey) {
+    TERN_(HAS_BED_PROBE, case ID_Leveling:)
+    TERN_(HAS_ESDIAG, case ID_ESDiagProcess:)
     case ID_NothingToDo:
     case ID_WaitResponse:
     case ID_Popup:
     case ID_Homing:
-    case ID_Leveling:
     case ID_PIDProcess:
-    TERN_(HAS_ESDIAG, case ID_ESDiagProcess:)
       return true;
     default: break;
   }
   return false;
 }
 
 void hmiSaveProcessID(const uint8_t id) {
   if (checkkey == id) return;
   if (!idIsPopUp()) last_checkkey = checkkey; // If previous is not a popup
   checkkey = id;
   switch (id) {
     case ID_Popup:
     case ID_WaitResponse:
     case ID_PrintDone:
-    case ID_Leveling:
+    TERN_(HAS_BED_PROBE, case ID_Leveling:)
     TERN_(HAS_ESDIAG, case ID_ESDiagProcess:)
+    TERN_(PROUI_ITEM_PLOT, case ID_PlotProcess:)
       wait_for_user = true;
     default: break;
   }
 }
 
 void hmiReturnScreen() {
   checkkey = last_checkkey;
   wait_for_user = false;
   drawMainArea();
 }
@@ -1508,82 +1544,108 @@ void dwinLevelingDone() {
 #endif
 
 // PID/MPC process
 
 #if PROUI_TUNING_GRAPH
 
   #include "plot.h"
 
   celsius_t _maxtemp, _target;
   void dwinDrawPIDMPCPopup() {
-    constexpr frame_rect_t gfrm = { 40, 180, DWIN_WIDTH - 80, 120 };
+    constexpr frame_rect_t gfrm = { 30, 150, DWIN_WIDTH - 60, 160 };
     DWINUI::clearMainArea();
     drawPopupBkgd();
 
     switch (hmiValue.tempControl) {
       default: return;
       #if ENABLED(MPC_AUTOTUNE)
         case MPCTEMP_START:
-          DWINUI::drawCenteredString(hmiData.colorPopupTxt, 100, GET_TEXT_F(MSG_MPC_AUTOTUNE));
-          DWINUI::drawString(hmiData.colorPopupTxt, gfrm.x, gfrm.y - DWINUI::fontHeight() - 4, F("MPC target:    Celsius"));
-          break;
-      #endif
-      #if ANY(PIDTEMP, PIDTEMPBED)
-        TERN_(PIDTEMP,    case PIDTEMP_START:)
-        TERN_(PIDTEMPBED, case PIDTEMPBED_START:)
-          DWINUI::drawCenteredString(hmiData.colorPopupTxt, 100, GET_TEXT_F(MSG_PID_AUTOTUNE));
-          DWINUI::drawString(hmiData.colorPopupTxt, gfrm.x, gfrm.y - DWINUI::fontHeight() - 4, F("PID target:    Celsius"));
-          break;
-      #endif
-    }
-
-    switch (hmiValue.tempControl) {
-      default: break;
-      #if ANY(PIDTEMP, MPC_AUTOTUNE)
-        TERN_(PIDTEMP,      case PIDTEMP_START:)
-        TERN_(MPC_AUTOTUNE, case MPCTEMP_START:)
-          DWINUI::drawCenteredString(hmiData.colorPopupTxt, 120, F("for Nozzle is running."));
-          break;
-      #endif
-      #if ENABLED(PIDTEMPBED)
-        case PIDTEMPBED_START:
-          DWINUI::drawCenteredString(hmiData.colorPopupTxt, 120, F("for BED is running."));
-          break;
-      #endif
-    }
-
-    switch (hmiValue.tempControl) {
-      default: break;
-      #if ENABLED(MPC_AUTOTUNE)
-        case MPCTEMP_START:
+          DWINUI::drawCenteredString(hmiData.colorPopupTxt, 70, GET_TEXT_F(MSG_MPC_AUTOTUNE));
+          DWINUI::drawString(hmiData.colorPopupTxt, gfrm.x, gfrm.y - DWINUI::fontHeight() - 4, F("MPC target:     Celsius"));
+          DWINUI::drawCenteredString(hmiData.colorPopupTxt, 92, F("for NOZZLE is running."));
           _maxtemp = thermalManager.hotend_maxtemp[0];
           _target = 200;
           break;
       #endif
       #if ENABLED(PIDTEMP)
         case PIDTEMP_START:
+          DWINUI::drawCenteredString(hmiData.colorPopupTxt, 70, GET_TEXT_F(MSG_PID_AUTOTUNE));
+          DWINUI::drawString(hmiData.colorPopupTxt, gfrm.x, gfrm.y - DWINUI::fontHeight() - 4, F("PID target:     Celsius"));
+          DWINUI::drawCenteredString(hmiData.colorPopupTxt, 92, F("for NOZZLE is running."));
           _maxtemp = thermalManager.hotend_maxtemp[0];
           _target = hmiData.hotendPidT;
           break;
       #endif
       #if ENABLED(PIDTEMPBED)
         case PIDTEMPBED_START:
+          DWINUI::drawCenteredString(hmiData.colorPopupTxt, 70, GET_TEXT_F(MSG_PID_AUTOTUNE));
+          DWINUI::drawString(hmiData.colorPopupTxt, gfrm.x, gfrm.y - DWINUI::fontHeight() - 4, F("PID target:     Celsius"));
+          DWINUI::drawCenteredString(hmiData.colorPopupTxt, 92, F("for BED is running."));
           _maxtemp = BED_MAXTEMP;
           _target = hmiData.bedPidT;
           break;
       #endif
     }
 
     plot.draw(gfrm, _maxtemp, _target);
-    DWINUI::drawInt(hmiData.colorPopupTxt, 3, gfrm.x + 90, gfrm.y - DWINUI::fontHeight() - 4, _target);
+    DWINUI::drawInt(false, 2, hmiData.colorStatusTxt, hmiData.colorPopupTxt, 3, gfrm.x + 92, gfrm.y - DWINUI::fontHeight() - 6, _target);
   }
 
+  // Plot Temperature Graph (PID Tuning Graph)
+  #if ENABLED(PROUI_ITEM_PLOT)
+
+    void dwinDrawPlot(tempcontrol_t result) {
+      hmiValue.tempControl = result;
+      constexpr frame_rect_t gfrm = {30, 135, DWIN_WIDTH - 60, 160};
+      DWINUI::clearMainArea();
+      drawPopupBkgd();
+      hmiSaveProcessID(ID_PlotProcess);
+
+      switch (result) {
+        #if ENABLED(MPCTEMP)
+          case MPCTEMP_START:
+        #elif ENABLED(PIDTEMP)
+          case PIDTEMP_START:
+        #endif
+            title.showCaption(GET_TEXT_F(MSG_HOTEND_TEMP_GRAPH));
+            DWINUI::drawCenteredString(3, hmiData.colorPopupTxt, 75, F("Nozzle Temperature"));
+            _maxtemp = thermalManager.hotend_max_target(0);
+            _target = thermalManager.degTargetHotend(0);
+            break;
+        #if ENABLED(PIDTEMPBED)
+          case PIDTEMPBED_START:
+            title.showCaption(GET_TEXT_F(MSG_BED_TEMP_GRAPH));
+            DWINUI::drawCenteredString(3, hmiData.colorPopupTxt, 75, F("Bed Temperature"));
+            _maxtemp = BED_MAX_TARGET;
+            _target = thermalManager.degTargetBed();
+            break;
+        #endif
+        default: break;
+      }
+
+      dwinDrawString(false, 2, hmiData.colorPopupTxt, hmiData.colorPopupBg, gfrm.x, gfrm.y - DWINUI::fontHeight() - 4, F("Target:     Celsius"));
+      plot.draw(gfrm, _maxtemp, _target);
+      DWINUI::drawInt(false, 2, hmiData.colorStatusTxt, hmiData.colorPopupBg, 3, gfrm.x + 80, gfrm.y - DWINUI::fontHeight() - 4, _target);
+      DWINUI::drawButton(BTN_Continue, 86, 305);
+      dwinUpdateLCD();
+    }
+
+    void drawHPlot() {
+      TERN_(PIDTEMP, dwinDrawPlot(PIDTEMP_START);)
+      TERN_(MPCTEMP, dwinDrawPlot(MPCTEMP_START);)
+    }
+    void drawBPlot() {
+      TERN_(PIDTEMPBED, dwinDrawPlot(PIDTEMPBED_START);)
+    }
+
+  #endif // PROUI_ITEM_PLOT
+
 #endif // PROUI_TUNING_GRAPH
 
 #if PROUI_PID_TUNE
 
   void dwinStartM303(const bool seenC, const int c, const bool seenS, const heater_id_t hid, const celsius_t temp) {
     if (seenC) hmiData.pidCycles = c;
     if (seenS) {
       switch (hid) {
         OPTCODE(PIDTEMP,    case 0 ... HOTENDS - 1: hmiData.hotendPidT = temp; break)
         OPTCODE(PIDTEMPBED, case H_BED:             hmiData.bedPidT = temp;    break)
@@ -2986,21 +3048,21 @@ void onDrawAcc(MenuItem* menuitem, int8_t line) {
 #endif
 
 // Menu Creation and Drawing functions ======================================================
 
 frame_rect_t selrect(frame_rect_t) {
   return hmiIsChinese() ? frame_rect_t({ 133, 1, 28, 13 }) : frame_rect_t({ 0 });
 }
 
 void drawPrepareMenu() {
   checkkey = ID_Menu;
-  if (SET_MENU_R(prepareMenu, selrect({133, 1, 28, 13}), MSG_PREPARE, 10 + PREHEAT_COUNT)) {
+  if (SET_MENU_R(prepareMenu, selrect({133, 1, 28, 13}), MSG_PREPARE, 12 + PREHEAT_COUNT)) {
     BACK_ITEM(gotoMainMenu);
     MENU_ITEM(ICON_FilMan, MSG_FILAMENT_MAN, onDrawSubMenu, drawFilamentManMenu);
     MENU_ITEM(ICON_Axis, MSG_MOVE_AXIS, onDrawMoveSubMenu, drawMoveMenu);
     #if ENABLED(LCD_BED_TRAMMING)
       MENU_ITEM(ICON_Tram, MSG_BED_TRAMMING, onDrawSubMenu, drawTrammingMenu);
     #endif
     MENU_ITEM(ICON_CloseMotor, MSG_DISABLE_STEPPERS, onDrawDisableMotors, disableMotors);
     #if ENABLED(INDIVIDUAL_AXIS_HOMING_SUBMENU)
       MENU_ITEM(ICON_Homing, MSG_HOMING, onDrawSubMenu, drawHomingMenu);
     #else
@@ -3016,20 +3078,24 @@ void drawPrepareMenu() {
         MENU_ITEM(ICON_SetZOffset, MSG_PROBE_WIZARD, onDrawSubMenu, drawZOffsetWizMenu);
       #elif ENABLED(BABYSTEPPING)
         EDIT_ITEM(ICON_Zoffset, MSG_HOME_OFFSET_Z, onDrawPFloat2Menu, setZOffset, &BABY_Z_VAR);
       #endif
     #endif
     #if HAS_PREHEAT
       #define _ITEM_PREHEAT(N) MENU_ITEM(ICON_Preheat##N, MSG_PREHEAT_##N, onDrawMenuItem, DoPreheat##N);
       REPEAT_1(PREHEAT_COUNT, _ITEM_PREHEAT)
     #endif
     MENU_ITEM(ICON_Cool, MSG_COOLDOWN, onDrawCooldown, doCoolDown);
+    #if ALL(PROUI_TUNING_GRAPH, PROUI_ITEM_PLOT)
+      MENU_ITEM(ICON_PIDNozzle, MSG_HOTEND_TEMP_GRAPH, onDrawMenuItem, drawHPlot);
+      MENU_ITEM(ICON_PIDBed, MSG_BED_TEMP_GRAPH, onDrawMenuItem, drawBPlot);
+    #endif
     MENU_ITEM(ICON_Language, MSG_UI_LANGUAGE, onDrawLanguage, setLanguage);
   }
   ui.reset_status(true);
   updateMenu(prepareMenu);
 }
 
 #if ENABLED(LCD_BED_TRAMMING)
 
   void drawTrammingMenu() {
     checkkey = ID_Menu;
@@ -3297,21 +3363,21 @@ void drawFilSetMenu() {
         #endif
       #endif
     }
     updateMenu(ledControlMenu);
   }
 
 #endif // LED_CONTROL_MENU
 
 void drawTuneMenu() {
   checkkey = ID_Menu;
-  if (SET_MENU_R(tuneMenu, selrect({73, 2, 28, 12}), MSG_TUNE, 18)) {
+  if (SET_MENU_R(tuneMenu, selrect({73, 2, 28, 12}), MSG_TUNE, 20)) {
     BACK_ITEM(gotoPrintProcess);
     EDIT_ITEM(ICON_Speed, MSG_SPEED, onDrawSpeedItem, setSpeed, &feedrate_percentage);
     #if HAS_HOTEND
       hotendTargetItem = EDIT_ITEM(ICON_HotendTemp, MSG_UBL_SET_TEMP_HOTEND, onDrawHotendTemp, setHotendTemp, &thermalManager.temp_hotend[0].target);
     #endif
     #if HAS_HEATED_BED
       bedTargetItem = EDIT_ITEM(ICON_BedTemp, MSG_UBL_SET_TEMP_BED, onDrawBedTemp, setBedTemp, &thermalManager.temp_bed.target);
     #endif
     #if HAS_FAN
       fanSpeedItem = EDIT_ITEM(ICON_FanSpeed, MSG_FAN_SPEED, onDrawFanSpeed, setFanSpeed, &thermalManager.fan_speed[0]);
@@ -3343,20 +3409,24 @@ void drawTuneMenu() {
     #if HAS_LOCKSCREEN
       MENU_ITEM(ICON_Lock, MSG_LOCKSCREEN, onDrawMenuItem, dwinLockScreen);
     #endif
     #if HAS_LCD_BRIGHTNESS
       EDIT_ITEM(ICON_Brightness, MSG_BRIGHTNESS, onDrawPInt8Menu, setBrightness, &ui.brightness);
       MENU_ITEM(ICON_Brightness, MSG_BRIGHTNESS_OFF, onDrawMenuItem, turnOffBacklight);
     #endif
     #if ENABLED(EDITABLE_DISPLAY_TIMEOUT)
       EDIT_ITEM(ICON_Brightness, MSG_SCREEN_TIMEOUT, onDrawPIntMenu, setTimer, &ui.backlight_timeout_minutes);
     #endif
+    #if ALL(PROUI_TUNING_GRAPH, PROUI_ITEM_PLOT)
+      MENU_ITEM(ICON_PIDNozzle, MSG_HOTEND_TEMP_GRAPH, onDrawMenuItem, drawHPlot);
+      MENU_ITEM(ICON_PIDBed, MSG_BED_TEMP_GRAPH, onDrawMenuItem, drawBPlot);
+    #endif
     #if ENABLED(CASE_LIGHT_MENU)
       EDIT_ITEM(ICON_CaseLight, MSG_CASE_LIGHT, onDrawChkbMenu, setCaseLight, &caselight.on);
       #if CASELIGHT_USES_BRIGHTNESS
         // Avoid heavy interference with print job disabling live update of brightness in tune menu
         enableLiveCaseLightBrightness = false;
         EDIT_ITEM(ICON_Brightness, MSG_CASE_LIGHT_BRIGHTNESS, onDrawPInt8Menu, setCaseLightBrightness, &caselight.brightness);
       #endif
       #if ENABLED(LED_CONTROL_MENU)
         // Avoid heavy interference with print job disabling live update of color in tune menu
         enableLiveLedColor = false;

commit 75da3555ee0910f3d572f4b8176afecdc941524b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Dec 14 10:03:11 2023 -0600

    üîß Update CLASSIC_JERK conditionals

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 7c68c60f81..8d54e0c582 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -229,21 +229,21 @@ Menu *filamentMenu = nullptr;
 #if ENABLED(MESH_BED_LEVELING)
   Menu *manualMeshMenu = nullptr;
 #endif
 #if HAS_PREHEAT
   Menu *preheatMenu = nullptr;
   Menu *preheatHotendMenu = nullptr;
 #endif
 Menu *temperatureMenu = nullptr;
 Menu *maxSpeedMenu = nullptr;
 Menu *maxAccelMenu = nullptr;
-#if HAS_CLASSIC_JERK
+#if ENABLED(CLASSIC_JERK)
   Menu *maxJerkMenu = nullptr;
 #endif
 Menu *stepsMenu = nullptr;
 #if ANY(MPC_EDIT_MENU, MPC_AUTOTUNE_MENU)
   Menu *hotendMPCMenu = nullptr;
 #endif
 #if ENABLED(PIDTEMP) && ANY(PID_EDIT_MENU, PID_AUTOTUNE_MENU)
   Menu *hotendPIDMenu = nullptr;
 #endif
 #if ENABLED(PIDTEMPBED) && ANY(PID_EDIT_MENU, PID_AUTOTUNE_MENU)
@@ -2538,21 +2538,21 @@ void applyMaxAccel() { planner.set_max_acceleration(hmiValue.axis, menuData.valu
 #if HAS_Y_AXIS
   void setMaxAccelY() { hmiValue.axis = Y_AXIS, setIntOnClick(min_acceleration_edit_values.y, max_acceleration_edit_values.y, planner.settings.max_acceleration_mm_per_s2[Y_AXIS], applyMaxAccel); }
 #endif
 #if HAS_Z_AXIS
   void setMaxAccelZ() { hmiValue.axis = Z_AXIS, setIntOnClick(min_acceleration_edit_values.z, max_acceleration_edit_values.z, planner.settings.max_acceleration_mm_per_s2[Z_AXIS], applyMaxAccel); }
 #endif
 #if HAS_HOTEND
   void setMaxAccelE() { hmiValue.axis = E_AXIS; setIntOnClick(min_acceleration_edit_values.e, max_acceleration_edit_values.e, planner.settings.max_acceleration_mm_per_s2[E_AXIS], applyMaxAccel); }
 #endif
 
-#if HAS_CLASSIC_JERK
+#if ENABLED(CLASSIC_JERK)
   void applyMaxJerk() { planner.set_max_jerk(hmiValue.axis, menuData.value / MINUNITMULT); }
   #if HAS_X_AXIS
     void setMaxJerkX() { hmiValue.axis = X_AXIS, setFloatOnClick(min_jerk_edit_values.x, max_jerk_edit_values.x, UNITFDIGITS, planner.max_jerk.x, applyMaxJerk); }
   #endif
   #if HAS_Y_AXIS
     void setMaxJerkY() { hmiValue.axis = Y_AXIS, setFloatOnClick(min_jerk_edit_values.y, max_jerk_edit_values.y, UNITFDIGITS, planner.max_jerk.y, applyMaxJerk); }
   #endif
   #if HAS_Z_AXIS
     void setMaxJerkZ() { hmiValue.axis = Z_AXIS, setFloatOnClick(min_jerk_edit_values.z, max_jerk_edit_values.z, UNITFDIGITS, planner.max_jerk.z, applyMaxJerk); }
   #endif
@@ -2873,21 +2873,21 @@ void onDrawAcc(MenuItem* menuitem, int8_t line) {
   void onDrawMaxAccelE(MenuItem* menuitem, int8_t line) {
     if (hmiIsChinese()) {
       menuitem->setFrame(1, 173, 133, 200, 147);
       dwinFrameAreaCopy(1, 28, 149,  69, 161, LBLX + 27, MBASE(line));
       dwinFrameAreaCopy(1, 18, 150,  25, 160, LBLX + 71, MBASE(line));    // E
     }
     onDrawPInt32Menu(menuitem, line);
   }
 #endif
 
-#if HAS_CLASSIC_JERK
+#if ENABLED(CLASSIC_JERK)
 
   void onDrawJerk(MenuItem* menuitem, int8_t line) {
     if (hmiIsChinese()) {
       menuitem->setFrame(1, 173, 133, 200, 147);
       dwinFrameAreaCopy(1, 1, 180, 28, 192, LBLX + 27, MBASE(line) + 1);  // ...
       dwinFrameAreaCopy(1, 202, 133, 228, 147, LBLX + 54, MBASE(line));   // ...Jerk
     }
     onDrawSubMenu(menuitem, line);
   }
 
@@ -2934,21 +2934,21 @@ void onDrawAcc(MenuItem* menuitem, int8_t line) {
         menuitem->setFrame(1, 173, 133, 200, 147);
         dwinFrameAreaCopy(1,   1, 180,  28, 192, LBLX + 27, MBASE(line));
         dwinFrameAreaCopy(1, 202, 133, 228, 147, LBLX + 53, MBASE(line));
         dwinFrameAreaCopy(1,  18, 150,  25, 160, LBLX + 83, MBASE(line));
       }
       onDrawPFloatMenu(menuitem, line);
     }
 
   #endif
 
-#endif // HAS_CLASSIC_JERK
+#endif // CLASSIC_JERK
 
 #if HAS_X_AXIS
   void onDrawStepsX(MenuItem* menuitem, int8_t line) {
     if (hmiIsChinese()) {
       menuitem->setFrame(1, 153, 148, 194, 161);
       dwinFrameAreaCopy(1, 229, 133, 236, 147, LBLX + 44, MBASE(line));      // X
     }
     onDrawPFloatMenu(menuitem, line);
   }
 #endif
@@ -3444,21 +3444,21 @@ void drawTuneMenu() {
     updateMenu(trinamicConfigMenu);
   }
 #endif
 
 void drawMotionMenu() {
   checkkey = ID_Menu;
   if (SET_MENU_R(motionMenu, selrect({1, 16, 28, 13}), MSG_MOTION, 10)) {
     BACK_ITEM(drawControlMenu);
     MENU_ITEM(ICON_MaxSpeed, MSG_SPEED, onDrawSpeed, drawMaxSpeedMenu);
     MENU_ITEM(ICON_MaxAccelerated, MSG_ACCELERATION, onDrawAcc, drawMaxAccelMenu);
-    #if HAS_CLASSIC_JERK
+    #if ENABLED(CLASSIC_JERK)
       MENU_ITEM(ICON_MaxJerk, MSG_JERK, onDrawJerk, drawMaxJerkMenu);
     #elif HAS_JUNCTION_DEVIATION
       EDIT_ITEM(ICON_JDmm, MSG_JUNCTION_DEVIATION, onDrawPFloat3Menu, setJDmm, &planner.junction_deviation_mm);
     #endif
     #if ENABLED(LIN_ADVANCE)
       EDIT_ITEM(ICON_MaxAccelerated, MSG_ADVANCE_K, onDrawPFloat3Menu, setLA_K, &planner.extruder_advance_K[0]);
     #endif
     #if ENABLED(SHAPING_MENU)
       MENU_ITEM(ICON_InputShaping, MSG_INPUT_SHAPING, onDrawSubMenu, drawInputShaping_menu);
     #endif
@@ -3609,21 +3609,21 @@ void drawMaxAccelMenu() {
     #if HAS_Z_AXIS
       EDIT_ITEM(ICON_MaxAccZ, MSG_AMAX_C, onDrawMaxAccelZ, setMaxAccelZ, &planner.settings.max_acceleration_mm_per_s2[Z_AXIS]);
     #endif
     #if HAS_HOTEND
       EDIT_ITEM(ICON_MaxAccE, MSG_AMAX_E, onDrawMaxAccelE, setMaxAccelE, &planner.settings.max_acceleration_mm_per_s2[E_AXIS]);
     #endif
   }
   updateMenu(maxAccelMenu);
 }
 
-#if HAS_CLASSIC_JERK
+#if ENABLED(CLASSIC_JERK)
 
   void drawMaxJerkMenu() {
     checkkey = ID_Menu;
     if (SET_MENU_R(maxJerkMenu, selrect({1, 16, 28, 13}), MSG_JERK, 5)) {
       BACK_ITEM(drawMotionMenu);
       #if HAS_X_AXIS
         EDIT_ITEM(ICON_MaxSpeedJerkX, MSG_VA_JERK, onDrawMaxJerkX, setMaxJerkX, &planner.max_jerk.x);
       #endif
       #if HAS_Y_AXIS
         EDIT_ITEM(ICON_MaxSpeedJerkY, MSG_VB_JERK, onDrawMaxJerkY, setMaxJerkY, &planner.max_jerk.y);
@@ -3631,21 +3631,21 @@ void drawMaxAccelMenu() {
       #if HAS_Z_AXIS
         EDIT_ITEM(ICON_MaxSpeedJerkZ, MSG_VC_JERK, onDrawMaxJerkZ, setMaxJerkZ, &planner.max_jerk.z);
       #endif
       #if HAS_HOTEND
         EDIT_ITEM(ICON_MaxSpeedJerkE, MSG_VE_JERK, onDrawMaxJerkE, setMaxJerkE, &planner.max_jerk.e);
       #endif
     }
     updateMenu(maxJerkMenu);
   }
 
-#endif // HAS_CLASSIC_JERK
+#endif // CLASSIC_JERK
 
 void drawStepsMenu() {
   checkkey = ID_Menu;
   if (SET_MENU_R(stepsMenu, selrect({1, 16, 28, 13}), MSG_STEPS_PER_MM, 5)) {
     BACK_ITEM(drawMotionMenu);
     #if HAS_X_AXIS
       EDIT_ITEM(ICON_StepX, MSG_A_STEPS, onDrawStepsX, setStepsX, &planner.settings.axis_steps_per_mm[X_AXIS]);
     #endif
     #if HAS_Y_AXIS
       EDIT_ITEM(ICON_StepY, MSG_B_STEPS, onDrawStepsY, setStepsY, &planner.settings.axis_steps_per_mm[Y_AXIS]);

commit 06710e54de8c83af77a4f57d458f6463fbfcad93
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Wed Dec 13 00:33:03 2023 -0500

    ‚ú® EDITABLE_DISPLAY_TIMEOUT (#26517)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 8d4aa9106b..7c68c60f81 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -1242,21 +1242,21 @@ void hmiInit() {
       safe_delay((BOOTSCREEN_TIMEOUT) / 22);
     }
   #endif
   hmiSetLanguage();
 }
 
 void eachMomentUpdate() {
   static millis_t next_var_update_ms = 0, next_rts_update_ms = 0, next_status_update_ms = 0;
   const millis_t ms = millis();
 
-  #if LCD_BACKLIGHT_TIMEOUT_MINS
+  #if HAS_BACKLIGHT_TIMEOUT
     if (ui.backlight_off_ms && ELAPSED(ms, ui.backlight_off_ms)) {
       turnOffBacklight(); // Backlight off
       ui.backlight_off_ms = 0;
     }
   #endif
 
   if (ELAPSED(ms, next_var_update_ms)) {
     next_var_update_ms = ms + DWIN_VAR_UPDATE_INTERVAL;
     blink = !blink;
     updateVariable();
@@ -2228,21 +2228,21 @@ void setMoveZ() { hmiValue.axis = Z_AXIS; setPFloatOnClick(Z_MIN_POS, Z_MAX_POS,
 
   void probeStow() { probe.stow(); }
   void probeDeploy() { probe.deploy(); }
 
   #if HAS_BLTOUCH_HS_MODE
     void setHSMode() { toggleCheckboxLine(bltouch.high_speed_mode); }
   #endif
 
 #endif
 
-#if LCD_BACKLIGHT_TIMEOUT_MINS
+#if ENABLED(EDITABLE_DISPLAY_TIMEOUT)
   void applyTimer() { ui.backlight_timeout_minutes = menuData.value; }
   void setTimer() { setIntOnClick(ui.backlight_timeout_min, ui.backlight_timeout_max, ui.backlight_timeout_minutes, applyTimer); }
 #endif
 
 #if HAS_FILAMENT_SENSOR
   void setRunoutEnable() {
     runout.reset();
     toggleCheckboxLine(runout.enabled);
   }
   #if HAS_FILAMENT_RUNOUT_DISTANCE
@@ -3116,21 +3116,21 @@ void drawAdvancedSettingsMenu() {
     #if HAS_ESDIAG
       MENU_ITEM_F(ICON_esDiag, "End-stops diag.", onDrawSubMenu, drawEndStopDiag);
     #endif
     #if ENABLED(PRINTCOUNTER)
       MENU_ITEM(ICON_PrintStats, MSG_INFO_STATS_MENU, onDrawSubMenu, gotoPrintStats);
       MENU_ITEM(ICON_PrintStatsReset, MSG_INFO_PRINT_COUNT_RESET, onDrawSubMenu, printStatsReset);
     #endif
     #if HAS_LOCKSCREEN
       MENU_ITEM(ICON_Lock, MSG_LOCKSCREEN, onDrawMenuItem, dwinLockScreen);
     #endif
-    #if LCD_BACKLIGHT_TIMEOUT_MINS
+    #if ENABLED(EDITABLE_DISPLAY_TIMEOUT)
       EDIT_ITEM(ICON_Brightness, MSG_SCREEN_TIMEOUT, onDrawPIntMenu, setTimer, &ui.backlight_timeout_minutes);
     #endif
     #if ENABLED(SOUND_MENU_ITEM)
       EDIT_ITEM(ICON_Sound, MSG_SOUND_ENABLE, onDrawChkbMenu, setEnableSound, &ui.sound_on);
     #endif
     #if ENABLED(POWER_LOSS_RECOVERY)
       EDIT_ITEM(ICON_Pwrlossr, MSG_OUTAGE_RECOVERY, onDrawChkbMenu, setPwrLossr, &recovery.enabled);
     #endif
     #if HAS_GCODE_PREVIEW
       EDIT_ITEM(ICON_File, MSG_HAS_PREVIEW, onDrawChkbMenu, setPreview, &hmiData.enablePreview);
@@ -3340,21 +3340,21 @@ void drawTuneMenu() {
     #if ENABLED(PROUI_ITEM_ADVK)
       EDIT_ITEM(ICON_MaxAccelerated, MSG_ADVANCE_K, onDrawPFloat3Menu, setLA_K, &planner.extruder_advance_K[0]);
     #endif
     #if HAS_LOCKSCREEN
       MENU_ITEM(ICON_Lock, MSG_LOCKSCREEN, onDrawMenuItem, dwinLockScreen);
     #endif
     #if HAS_LCD_BRIGHTNESS
       EDIT_ITEM(ICON_Brightness, MSG_BRIGHTNESS, onDrawPInt8Menu, setBrightness, &ui.brightness);
       MENU_ITEM(ICON_Brightness, MSG_BRIGHTNESS_OFF, onDrawMenuItem, turnOffBacklight);
     #endif
-    #if LCD_BACKLIGHT_TIMEOUT_MINS
+    #if ENABLED(EDITABLE_DISPLAY_TIMEOUT)
       EDIT_ITEM(ICON_Brightness, MSG_SCREEN_TIMEOUT, onDrawPIntMenu, setTimer, &ui.backlight_timeout_minutes);
     #endif
     #if ENABLED(CASE_LIGHT_MENU)
       EDIT_ITEM(ICON_CaseLight, MSG_CASE_LIGHT, onDrawChkbMenu, setCaseLight, &caselight.on);
       #if CASELIGHT_USES_BRIGHTNESS
         // Avoid heavy interference with print job disabling live update of brightness in tune menu
         enableLiveCaseLightBrightness = false;
         EDIT_ITEM(ICON_Brightness, MSG_CASE_LIGHT_BRIGHTNESS, onDrawPInt8Menu, setCaseLightBrightness, &caselight.brightness);
       #endif
       #if ENABLED(LED_CONTROL_MENU)

commit dabcd6590350a3096309647cc51bd289fbc4554a
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Wed Nov 29 11:23:18 2023 +1300

    üö∏ Fix ProUI hostui.notify('finished') (#26478)

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 366ecffbd9..8d4aa9106b 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -1715,21 +1715,21 @@ void dwinPrintAborted() {
     if (all_axes_homed()) {
       queue.inject(
         #if ENABLED(NOZZLE_PARK_FEATURE)
           F("G27")
         #else
           TS(F("G0Z"), float(_MIN(current_position.z + (Z_POST_CLEARANCE), Z_MAX_POS)), F("\nG0F2000Y"), Y_MAX_POS);
         #endif
       );
     }
   #endif
-  hostui.notify("Print Aborted");
+  TERN_(HOST_PROMPT_SUPPORT, hostui.notify(GET_TEXT_F(MSG_PRINT_ABORTED)));
   dwinPrintFinished();
 }
 
 #if HAS_FILAMENT_SENSOR
   // Filament Runout process
   void dwinFilamentRunout(const uint8_t extruder) { LCD_MESSAGE(MSG_RUNOUT_SENSOR); }
 #endif
 
 void dwinSetColorDefaults() {
   hmiData.colorBackground = defColorBackground;

commit bd872a7a98528da6e1fab95382488ce703fe24c1
Author: Vovodroid <vovodroid@users.noreply.github.com>
Date:   Fri Nov 24 21:03:06 2023 +0200

    üîß Configurable FR/Flow edit ranges (#26446)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 341521ee84..366ecffbd9 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -128,30 +128,28 @@
 #if HAS_LOCKSCREEN
   #include "lockscreen.h"
 #endif
 
 #ifndef MACHINE_SIZE
   #define MACHINE_SIZE STRINGIFY(X_BED_SIZE) "x" STRINGIFY(Y_BED_SIZE) "x" STRINGIFY(Z_MAX_POS)
 #endif
 
 #define PAUSE_HEAT
 
-// Print speed limit
-#define MIN_PRINT_SPEED  10
-#define MAX_PRINT_SPEED 999
-
-// Print flow limit
-#define MIN_PRINT_FLOW   10
-#define MAX_PRINT_FLOW   299
-
 // Load and Unload limits
-#define MAX_LOAD_UNLOAD  500
+#ifndef EXTRUDE_MAXLENGTH
+  #ifdef FILAMENT_CHANGE_UNLOAD_LENGTH
+    #define EXTRUDE_MAXLENGTH (FILAMENT_CHANGE_UNLOAD_LENGTH + 10)
+  #else
+    #define EXTRUDE_MAXLENGTH 500
+  #endif
+#endif
 
 // Juntion deviation limits
 #define MIN_JD_MM             0.001
 #define MAX_JD_MM             TERN(LIN_ADVANCE, 0.3f, 0.5f)
 
 #if HAS_TRINAMIC_CONFIG
   #define MIN_TMC_CURRENT 100
   #define MAX_TMC_CURRENT 3000
 #endif
 
@@ -2247,30 +2245,30 @@ void setMoveZ() { hmiValue.axis = Z_AXIS; setPFloatOnClick(Z_MIN_POS, Z_MAX_POS,
     runout.reset();
     toggleCheckboxLine(runout.enabled);
   }
   #if HAS_FILAMENT_RUNOUT_DISTANCE
     void applyRunoutDistance() { runout.set_runout_distance(menuData.value / MINUNITMULT); }
     void setRunoutDistance() { setFloatOnClick(0, 999, UNITFDIGITS, runout.runout_distance(), applyRunoutDistance); }
   #endif
 #endif
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
-  void setFilLoad()   { setPFloatOnClick(0, MAX_LOAD_UNLOAD, UNITFDIGITS); }
-  void setFilUnload() { setPFloatOnClick(0, MAX_LOAD_UNLOAD, UNITFDIGITS); }
+  void setFilLoad()   { setPFloatOnClick(0, EXTRUDE_MAXLENGTH, UNITFDIGITS); }
+  void setFilUnload() { setPFloatOnClick(0, EXTRUDE_MAXLENGTH, UNITFDIGITS); }
 #endif
 
 #if ENABLED(PREVENT_COLD_EXTRUSION)
   void applyExtMinT() { thermalManager.extrude_min_temp = hmiData.extMinT; thermalManager.allow_cold_extrude = (hmiData.extMinT == 0); }
   void setExtMinT() { setPIntOnClick(MIN_ETEMP, MAX_ETEMP, applyExtMinT); }
 #endif
 
-void setSpeed() { setPIntOnClick(MIN_PRINT_SPEED, MAX_PRINT_SPEED); }
+void setSpeed() { setPIntOnClick(SPEED_EDIT_MIN, SPEED_EDIT_MAX); }
 
 #if HAS_HOTEND
   void applyHotendTemp() { thermalManager.setTargetHotend(menuData.value, 0); }
   void setHotendTemp() { setIntOnClick(MIN_ETEMP, MAX_ETEMP, thermalManager.degTargetHotend(0), applyHotendTemp); }
 #endif
 
 #if HAS_HEATED_BED
   void applyBedTemp() { thermalManager.setTargetBed(menuData.value); }
   void setBedTemp() { setIntOnClick(MIN_BEDTEMP, MAX_BEDTEMP, thermalManager.degTargetBed(), applyBedTemp); }
 #endif
@@ -2301,21 +2299,21 @@ void setSpeed() { setPIntOnClick(MIN_PRINT_SPEED, MAX_PRINT_SPEED); }
     }
 
     void loadFilament() {
       LCD_MESSAGE(MSG_FILAMENTLOAD);
       queue.inject(F("M701 Z20"));
     }
   #endif
 
 #endif // ADVANCED_PAUSE_FEATURE
 
-void setFlow() { setPIntOnClick(MIN_PRINT_FLOW, MAX_PRINT_FLOW, []{ planner.refresh_e_factor(0); }); }
+void setFlow() { setPIntOnClick(FLOW_EDIT_MIN, FLOW_EDIT_MAX, []{ planner.refresh_e_factor(0); }); }
 
 // Bed Tramming
 
 #if ENABLED(LCD_BED_TRAMMING)
 
   void tramXY(const uint8_t point, float &x, float &y) {
     switch (point) {
       case 0:
         LCD_MESSAGE(MSG_TRAM_FL);
         x = bed_tramming_inset_lfbr[0];

commit f3473495d0ecc61e4d768e88759e9a7f9a263770
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Wed Nov 22 03:19:29 2023 -0500

    üö∏ Fixes for ProUI popup, abort (#26308)

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index a6cc1613ef..341521ee84 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -1706,20 +1706,32 @@ void dwinPrintFinished() {
   hmiFlag.abort_flag = false;
   hmiFlag.pause_flag = false;
   wait_for_heatup = false;
   planner.finish_and_disable();
   thermalManager.cooldown();
   gotoPrintDone();
 }
 
 // Print was aborted
 void dwinPrintAborted() {
+  #ifndef EVENT_GCODE_SD_ABORT
+    if (all_axes_homed()) {
+      queue.inject(
+        #if ENABLED(NOZZLE_PARK_FEATURE)
+          F("G27")
+        #else
+          TS(F("G0Z"), float(_MIN(current_position.z + (Z_POST_CLEARANCE), Z_MAX_POS)), F("\nG0F2000Y"), Y_MAX_POS);
+        #endif
+      );
+    }
+  #endif
+  hostui.notify("Print Aborted");
   dwinPrintFinished();
 }
 
 #if HAS_FILAMENT_SENSOR
   // Filament Runout process
   void dwinFilamentRunout(const uint8_t extruder) { LCD_MESSAGE(MSG_RUNOUT_SENSOR); }
 #endif
 
 void dwinSetColorDefaults() {
   hmiData.colorBackground = defColorBackground;
@@ -2219,21 +2231,22 @@ void setMoveZ() { hmiValue.axis = Z_AXIS; setPFloatOnClick(Z_MIN_POS, Z_MAX_POS,
   void probeStow() { probe.stow(); }
   void probeDeploy() { probe.deploy(); }
 
   #if HAS_BLTOUCH_HS_MODE
     void setHSMode() { toggleCheckboxLine(bltouch.high_speed_mode); }
   #endif
 
 #endif
 
 #if LCD_BACKLIGHT_TIMEOUT_MINS
-  void setTimer() { setPIntOnClick(ui.backlight_timeout_min, ui.backlight_timeout_max); }
+  void applyTimer() { ui.backlight_timeout_minutes = menuData.value; }
+  void setTimer() { setIntOnClick(ui.backlight_timeout_min, ui.backlight_timeout_max, ui.backlight_timeout_minutes, applyTimer); }
 #endif
 
 #if HAS_FILAMENT_SENSOR
   void setRunoutEnable() {
     runout.reset();
     toggleCheckboxLine(runout.enabled);
   }
   #if HAS_FILAMENT_RUNOUT_DISTANCE
     void applyRunoutDistance() { runout.set_runout_distance(menuData.value / MINUNITMULT); }
     void setRunoutDistance() { setFloatOnClick(0, 999, UNITFDIGITS, runout.runout_distance(), applyRunoutDistance); }

commit cc8f7c83dabdff51a0980d8fa066833aeaa3d97d
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Tue Nov 21 04:57:31 2023 -0500

    üö∏ Fix, clean up ProUI (#26434)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 843009c274..a6cc1613ef 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -24,20 +24,24 @@
  * DWIN Enhanced implementation for PRO UI
  * Author: Miguel A. Risco-Castillo (MRISCOC)
  * Version: 3.25.3
  * Date: 2023/05/18
  */
 
 #include "../../../inc/MarlinConfig.h"
 
 #if ENABLED(DWIN_LCD_PROUI)
 
+#include "dwin.h"
+#include "menus.h"
+#include "dwin_popup.h"
+
 #include "../../utf8.h"
 #include "../../marlinui.h"
 #include "../../../MarlinCore.h"
 #include "../../../core/serial.h"
 #include "../../../core/macros.h"
 #include "../../../module/temperature.h"
 #include "../../../module/printcounter.h"
 #include "../../../module/motion.h"
 #include "../../../module/planner.h"
 #include "../../../module/stepper.h"
@@ -98,24 +102,20 @@
 #endif
 
 #if ENABLED(LED_CONTROL_MENU)
   #include "../../../feature/leds/leds.h"
 #endif
 
 #if HAS_TRINAMIC_CONFIG
   #include "../../../feature/tmc_util.h"
 #endif
 
-#include "dwin.h"
-#include "menus.h"
-#include "dwin_popup.h"
-
 #if HAS_GCODE_PREVIEW
   #include "gcode_preview.h"
 #endif
 
 #if HAS_ESDIAG
   #include "endstop_diag.h"
 #endif
 
 #if PROUI_TUNING_GRAPH
   #include "plot.h"
@@ -261,21 +261,21 @@ Menu *stepsMenu = nullptr;
   Menu *zOffsetWizMenu = nullptr;
 #endif
 #if ENABLED(INDIVIDUAL_AXIS_HOMING_SUBMENU)
   Menu *homingMenu = nullptr;
 #endif
 #if ENABLED(FWRETRACT)
   Menu *fwRetractMenu = nullptr;
 #endif
 #if HAS_MESH
   Menu *meshMenu = nullptr;
-  #if ENABLED(MESH_EDIT_MENU)
+  #if ENABLED(PROUI_MESH_EDIT)
     Menu *editMeshMenu = nullptr;
   #endif
 #endif
 #if ENABLED(SHAPING_MENU)
   Menu *inputShapingMenu = nullptr;
 #endif
 #if HAS_TRINAMIC_CONFIG
   Menu *trinamicConfigMenu = nullptr;
 #endif
 
@@ -840,21 +840,21 @@ void updateVariable() {
 
   _drawZOffsetIcon();
 }
 
 /**
  * Memory card and file management
  */
 
 bool DWIN_lcd_sd_status = false;
 
-#if ENABLED(MEDIASORT_MENU_ITEM)
+#if ENABLED(PROUI_MEDIASORT)
   void setMediaSort() {
     toggleCheckboxLine(hmiData.mediaSort);
     card.setSortOn(hmiData.mediaSort ? TERN(SDSORT_REVERSE, AS_REV, AS_FWD) : AS_OFF);
   }
 #endif
 
 void setMediaAutoMount() { toggleCheckboxLine(hmiData.mediaAutoMount); }
 
 inline uint16_t nr_sd_menu_items() {
   return _MIN(card.get_num_items() + !card.flag.workDirIsRoot, MENU_MAX_ITEMS);
@@ -978,23 +978,22 @@ void onDrawFileName(MenuItem* menuitem, int8_t line) {
     icon = card.flag.filenameIsDir ? ICON_Folder : card.fileIsBinary() ? ICON_Binary : ICON_File;
     drawMenuLine(line, icon, shift_name);
   }
 }
 
 void drawPrintFileMenu() {
   checkkey = ID_Menu;
   if (card.isMounted()) {
     if (SET_MENU(fileMenu, MSG_MEDIA_MENU, nr_sd_menu_items() + 1)) {
       BACK_ITEM(gotoMainMenu);
-      for (uint8_t i = 0; i < nr_sd_menu_items(); ++i) {
+      for (uint8_t i = 0; i < nr_sd_menu_items(); ++i)
         menuItemAdd(onDrawFileName, onClickSDItem);
-      }
     }
     updateMenu(fileMenu);
     TERN_(DASH_REDRAW, dwinRedrawDash());
   }
   else {
     if (SET_MENU(fileMenu, MSG_MEDIA_MENU, 1)) BACK_ITEM(gotoMainMenu);
     updateMenu(fileMenu);
     dwinDrawRectangle(1, hmiData.colorAlertBg, 10, MBASE(3) - 10, DWIN_WIDTH - 10, MBASE(4));
     DWINUI::drawCenteredString(font12x24, hmiData.colorAlertTxt, MBASE(3), GET_TEXT_F(MSG_MEDIA_NOT_INSERTED));
   }
@@ -1015,21 +1014,20 @@ void hmiSDCardUpdate() {
     }
     if (!DWIN_lcd_sd_status && sdPrinting()) ui.abort_print();  // Media removed while printing
   }
 }
 
 /**
  * Dash board and indicators
  */
 
 void dwinDrawDashboard() {
-
   dwinDrawRectangle(1, hmiData.colorBackground, 0, STATUS_Y + 21, DWIN_WIDTH, DWIN_HEIGHT - 1);
   dwinDrawRectangle(1, hmiData.colorSplitLine, 0, 449, DWIN_WIDTH, 451);
 
   DWINUI::drawIcon(ICON_MaxSpeedX,  10, 456);
   DWINUI::drawIcon(ICON_MaxSpeedY,  95, 456);
   DWINUI::drawIcon(ICON_MaxSpeedZ, 180, 456);
   _drawXYZPosition(true);
 
   #if HAS_HOTEND
     DWINUI::drawIcon(ICON_HotendTemp, 10, 383);
@@ -1060,21 +1058,21 @@ void dwinDrawDashboard() {
 
   #if HAS_ZOFFSET_ITEM
     DWINUI::drawIcon(planner.leveling_active ? ICON_SetZOffset : ICON_Zoffset, 187, 416);
     DWINUI::drawSignedFloat(DWIN_FONT_STAT, hmiData.colorIndicator,  hmiData.colorBackground, 2, 2, 204, 417, BABY_Z_VAR);
   #endif
 }
 
 void drawInfoMenu() {
   DWINUI::clearMainArea();
   if (hmiIsChinese())
-    title.frameCopy(30, 17, 28, 13);                        // "Info"
+    title.frameCopy(30, 17, 28, 13);                      // "Info"
   else
     title.showCaption(GET_TEXT_F(MSG_INFO_SCREEN));
   drawMenuLine(0, ICON_Back, GET_TEXT_F(MSG_BACK), false, true);
 
   if (hmiIsChinese()) {
     dwinFrameAreaCopy(1, 197, 149, 252, 161, 108, 102);   // "Size"
     dwinFrameAreaCopy(1,   1, 164,  56, 176, 108, 175);   // "Firmware Version"
     dwinFrameAreaCopy(1,  58, 164, 113, 176, 105, 248);   // "Contact Details"
     DWINUI::drawCenteredString(268, F(CORP_WEBSITE));
   }
@@ -1117,21 +1115,21 @@ void hmiMainMenu() {
         case PAGE_ADVANCE: ICON_AdvSettings(); break;
       }
     }
   }
   else if (encoder_diffState == ENCODER_DIFF_ENTER) {
     switch (select_page.now) {
       case PAGE_PRINT:
         if (hmiData.mediaAutoMount) {
           card.mount();
           safe_delay(800);
-        };
+        }
         drawPrintFileMenu();
         break;
       case PAGE_PREPARE: drawPrepareMenu(); break;
       case PAGE_CONTROL: drawControlMenu(); break;
       case PAGE_ADVANCE: drawAdvancedSettingsMenu(); break;
     }
   }
   dwinUpdateLCD();
 }
 
@@ -1752,21 +1750,21 @@ void dwinSetDataDefaults() {
   TERN_(PROUI_PID_TUNE, hmiData.pidCycles = DEF_PIDCYCLES);
   #if ENABLED(PREVENT_COLD_EXTRUSION)
     hmiData.extMinT = EXTRUDE_MINTEMP;
     applyExtMinT();
   #endif
   TERN_(PREHEAT_BEFORE_LEVELING, hmiData.bedLevT = LEVELING_BED_TEMP);
   TERN_(BAUD_RATE_GCODE, setBaud250K());
   #if ALL(LCD_BED_TRAMMING, HAS_BED_PROBE)
     hmiData.fullManualTramming = DISABLED(BED_TRAMMING_USE_PROBE);
   #endif
-  #if ENABLED(MEDIASORT_MENU_ITEM)
+  #if ENABLED(PROUI_MEDIASORT)
     hmiData.mediaSort = true;
     card.setSortOn(TERN(SDSORT_REVERSE, AS_REV, AS_FWD));
   #endif
   hmiData.mediaAutoMount = ENABLED(HAS_SD_EXTENDER);
   #if ALL(INDIVIDUAL_AXIS_HOMING_SUBMENU, MESH_BED_LEVELING)
     hmiData.zAfterHoming = DEF_Z_AFTER_HOMING;
   #endif
   #if ALL(LED_CONTROL_MENU, HAS_COLOR_LEDS)
     TERN_(LED_COLOR_PRESETS, leds.set_default());
     applyLEDColor();
@@ -2703,21 +2701,21 @@ void onDrawGetColorItem(MenuItem* menuitem, int8_t line) {
   uint16_t color;
   switch (i) {
     case 0: color = RGB(31, 0, 0); break; // Red
     case 1: color = RGB(0, 63, 0); break; // Green
     case 2: color = RGB(0, 0, 31); break; // Blue
     default: color = 0; break;
   }
   dwinDrawRectangle(0, hmiData.colorHighlight, ICOX + 1, MBASE(line) - 1 + 1, ICOX + 18, MBASE(line) - 1 + 18);
   dwinDrawRectangle(1, color, ICOX + 2, MBASE(line) - 1 + 2, ICOX + 17, MBASE(line) - 1 + 17);
   DWINUI::drawString(LBLX, MBASE(line) - 1, menuitem->caption);
-  drawMenuIntValue(hmiData.colorBackground, line, 4, hmiValue.Color[i]);
+  drawMenuIntValue(hmiData.colorBackground, line, 4, hmiValue.color[i]);
   dwinDrawHLine(hmiData.colorSplitLine, 16, MYPOS(line + 1), 240);
 }
 
 void onDrawSpeedItem(MenuItem* menuitem, int8_t line) {
   if (hmiIsChinese()) menuitem->setFrame(1, 116, 164, 171, 176);
   onDrawPIntMenu(menuitem, line);
 }
 
 #if HAS_HOTEND
   void onDrawHotendTemp(MenuItem* menuitem, int8_t line) {
@@ -2969,24 +2967,20 @@ void onDrawAcc(MenuItem* menuitem, int8_t line) {
   void onDrawStepsE(MenuItem* menuitem, int8_t line) {
     if (hmiIsChinese()) {
       menuitem->setFrame(1, 153, 148, 194, 161);
       dwinFrameAreaCopy(1,  18, 150,  25, 160, LBLX + 44, MBASE(line));    // E
     }
     onDrawPFloatMenu(menuitem, line);
   }
 
 #endif
 
-#if HAS_ONESTEP_LEVELING
-  void onDrawManualTramming(MenuItem* menuitem, int8_t line) { onDrawChkbMenu(menuitem, line, hmiData.fullManualTramming); }
-#endif
-
 // Menu Creation and Drawing functions ======================================================
 
 frame_rect_t selrect(frame_rect_t) {
   return hmiIsChinese() ? frame_rect_t({ 133, 1, 28, 13 }) : frame_rect_t({ 0 });
 }
 
 void drawPrepareMenu() {
   checkkey = ID_Menu;
   if (SET_MENU_R(prepareMenu, selrect({133, 1, 28, 13}), MSG_PREPARE, 10 + PREHEAT_COUNT)) {
     BACK_ITEM(gotoMainMenu);
@@ -3123,21 +3117,21 @@ void drawAdvancedSettingsMenu() {
     #endif
     #if ENABLED(SOUND_MENU_ITEM)
       EDIT_ITEM(ICON_Sound, MSG_SOUND_ENABLE, onDrawChkbMenu, setEnableSound, &ui.sound_on);
     #endif
     #if ENABLED(POWER_LOSS_RECOVERY)
       EDIT_ITEM(ICON_Pwrlossr, MSG_OUTAGE_RECOVERY, onDrawChkbMenu, setPwrLossr, &recovery.enabled);
     #endif
     #if HAS_GCODE_PREVIEW
       EDIT_ITEM(ICON_File, MSG_HAS_PREVIEW, onDrawChkbMenu, setPreview, &hmiData.enablePreview);
     #endif
-    #if ENABLED(MEDIASORT_MENU_ITEM)
+    #if ENABLED(PROUI_MEDIASORT)
       EDIT_ITEM(ICON_File, MSG_MEDIA_SORT, onDrawChkbMenu, setMediaSort, &hmiData.mediaSort);
     #endif
     EDIT_ITEM(ICON_File, MSG_MEDIA_UPDATE, onDrawChkbMenu, setMediaAutoMount, &hmiData.mediaAutoMount);
     #if ENABLED(BAUD_RATE_GCODE)
       EDIT_ITEM_F(ICON_SetBaudRate, "115K baud", onDrawChkbMenu, setBaudRate, &hmiData.baud115K);
     #endif
     #if HAS_LCD_BRIGHTNESS
       EDIT_ITEM(ICON_Brightness, MSG_BRIGHTNESS, onDrawPInt8Menu, setBrightness, &ui.brightness);
       MENU_ITEM(ICON_Brightness, MSG_BRIGHTNESS_OFF, onDrawMenuItem, turnOffBacklight);
     #endif
@@ -3316,30 +3310,30 @@ void drawTuneMenu() {
     #elif ALL(HAS_ZOFFSET_ITEM, MESH_BED_LEVELING, BABYSTEPPING)
       EDIT_ITEM(ICON_Zoffset, MSG_HOME_OFFSET_Z, onDrawPFloat2Menu, setZOffset, &BABY_Z_VAR);
     #endif
     EDIT_ITEM(ICON_Flow, MSG_FLOW, onDrawPIntMenu, setFlow, &planner.flow_percentage[0]);
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
       MENU_ITEM(ICON_FilMan, MSG_FILAMENTCHANGE, onDrawMenuItem, changeFilament);
     #endif
     #if HAS_FILAMENT_SENSOR
       EDIT_ITEM(ICON_Runout, MSG_RUNOUT_ENABLE, onDrawChkbMenu, setRunoutEnable, &runout.enabled);
     #endif
-    #if ENABLED(PLR_TUNE_ITEM)
+    #if ENABLED(PROUI_ITEM_PLR)
       EDIT_ITEM(ICON_Pwrlossr, MSG_OUTAGE_RECOVERY, onDrawChkbMenu, setPwrLossr, &recovery.enabled);
     #endif
     #if ENABLED(FWRETRACT)
       MENU_ITEM(ICON_FWRetract, MSG_FWRETRACT, onDrawSubMenu, drawFWRetractMenu);
     #endif
-    #if ENABLED(JD_TUNE_ITEM)
+    #if ENABLED(PROUI_ITEM_JD)
       EDIT_ITEM(ICON_JDmm, MSG_JUNCTION_DEVIATION, onDrawPFloat3Menu, setJDmm, &planner.junction_deviation_mm);
     #endif
-    #if ENABLED(ADVK_TUNE_ITEM)
+    #if ENABLED(PROUI_ITEM_ADVK)
       EDIT_ITEM(ICON_MaxAccelerated, MSG_ADVANCE_K, onDrawPFloat3Menu, setLA_K, &planner.extruder_advance_K[0]);
     #endif
     #if HAS_LOCKSCREEN
       MENU_ITEM(ICON_Lock, MSG_LOCKSCREEN, onDrawMenuItem, dwinLockScreen);
     #endif
     #if HAS_LCD_BRIGHTNESS
       EDIT_ITEM(ICON_Brightness, MSG_BRIGHTNESS, onDrawPInt8Menu, setBrightness, &ui.brightness);
       MENU_ITEM(ICON_Brightness, MSG_BRIGHTNESS_OFF, onDrawMenuItem, turnOffBacklight);
     #endif
     #if LCD_BACKLIGHT_TIMEOUT_MINS
@@ -3662,38 +3656,38 @@ void drawStepsMenu() {
 #if HAS_CUSTOM_COLORS
 
   void restoreDefaultColors() {
     dwinSetColorDefaults();
     DWINUI::setColors(hmiData.colorText, hmiData.colorBackground, hmiData.colorStatusBg);
     dwinRedrawScreen();
   }
 
   void selColor() {
     menuData.intPtr = (int16_t*)static_cast<MenuItemPtr*>(currentMenu->selectedItem())->value;
-    hmiValue.Color[0] = GetRColor(*menuData.intPtr);  // Red
-    hmiValue.Color[1] = GetGColor(*menuData.intPtr);  // Green
-    hmiValue.Color[2] = GetBColor(*menuData.intPtr);  // Blue
+    hmiValue.color.r = GetRColor(*menuData.intPtr); // Red
+    hmiValue.color.g = GetGColor(*menuData.intPtr); // Green
+    hmiValue.color.b = GetBColor(*menuData.intPtr); // Blue
     drawGetColorMenu();
   }
 
   void liveRGBColor() {
-    hmiValue.Color[currentMenu->line() - 2] = menuData.value;
-    uint16_t color = RGB(hmiValue.Color[0], hmiValue.Color[1], hmiValue.Color[2]);
+    hmiValue.color[currentMenu->line() - 2] = menuData.value;
+    const uint16_t color = RGB(hmiValue.color.r, hmiValue.color.g, hmiValue.color.b);
     dwinDrawRectangle(1, color, 20, 315, DWIN_WIDTH - 20, 335);
   }
   void setRGBColor() {
     const uint8_t color = static_cast<MenuItem*>(currentMenu->selectedItem())->icon;
-    setIntOnClick(0, (color == 1) ? 63 : 31, hmiValue.Color[color], nullptr, liveRGBColor);
+    setIntOnClick(0, (color == 1) ? 63 : 31, hmiValue.color[color], nullptr, liveRGBColor);
   }
 
   void dwinApplyColor() {
-    *menuData.intPtr = RGB(hmiValue.Color[0], hmiValue.Color[1], hmiValue.Color[2]);
+    *menuData.intPtr = RGB(hmiValue.color.r, hmiValue.color.g, hmiValue.color.b);
     DWINUI::setColors(hmiData.colorText, hmiData.colorBackground, hmiData.colorStatusBg);
     drawSelectColorsMenu();
     hash_changed = true;
     LCD_MESSAGE(MSG_COLORS_APPLIED);
     dwinDrawDashboard();
   }
 
   void drawSelectColorsMenu() {
     checkkey = ID_Menu;
     if (SET_MENU(selectColorMenu, MSG_COLORS_SELECT, 20)) {
@@ -3945,30 +3939,27 @@ void drawStepsMenu() {
   void setMeshActive() {
     set_bed_leveling_enabled(!planner.leveling_active);
     drawCheckboxLine(currentMenu->line(), planner.leveling_active);
     dwinUpdateLCD();
   }
 
   #if ENABLED(PREHEAT_BEFORE_LEVELING)
     void setBedLevT() { setPIntOnClick(MIN_BEDTEMP, MAX_BEDTEMP); }
   #endif
 
-  #if ENABLED(MESH_EDIT_MENU)
-    #define Z_OFFSET_MIN -3
-    #define Z_OFFSET_MAX  3
-
-    void LiveEditMesh() { ((MenuItemPtr*)editZValueItem)->value = &bedlevel.z_values[hmiValue.select ? bedLevelTools.mesh_x : menuData.value][hmiValue.select ? menuData.value : bedLevelTools.mesh_y]; editZValueItem->redraw(); }
+  #if ENABLED(PROUI_MESH_EDIT)
+    void liveEditMesh() { ((MenuItemPtr*)editZValueItem)->value = &bedlevel.z_values[hmiValue.select ? bedLevelTools.mesh_x : menuData.value][hmiValue.select ? menuData.value : bedLevelTools.mesh_y]; editZValueItem->redraw(); }
     void applyEditMeshX() { bedLevelTools.mesh_x = menuData.value; }
     void applyEditMeshY() { bedLevelTools.mesh_y = menuData.value; }
-    void ResetMesh() { bedLevelTools.meshReset(); LCD_MESSAGE(MSG_MESH_RESET); }
-    void setEditMeshX() { hmiValue.select = 0; setIntOnClick(0, GRID_MAX_POINTS_X - 1, bedLevelTools.mesh_x, applyEditMeshX, LiveEditMesh); }
-    void setEditMeshY() { hmiValue.select = 1; setIntOnClick(0, GRID_MAX_POINTS_Y - 1, bedLevelTools.mesh_y, applyEditMeshY, LiveEditMesh); }
+    void resetMesh() { bedLevelTools.meshReset(); LCD_MESSAGE(MSG_MESH_RESET); }
+    void setEditMeshX() { hmiValue.select = 0; setIntOnClick(0, GRID_MAX_POINTS_X - 1, bedLevelTools.mesh_x, applyEditMeshX, liveEditMesh); }
+    void setEditMeshY() { hmiValue.select = 1; setIntOnClick(0, GRID_MAX_POINTS_Y - 1, bedLevelTools.mesh_y, applyEditMeshY, liveEditMesh); }
     void setEditZValue() { setPFloatOnClick(Z_OFFSET_MIN, Z_OFFSET_MAX, 3); }
   #endif
 
 #endif // HAS_MESH
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
 
   void applyUBLSlot() { bedlevel.storage_slot = menuData.value; }
   void setUBLSlot() { setIntOnClick(0, settings.calc_num_meshes() - 1, bedlevel.storage_slot, applyUBLSlot); }
   void onDrawUBLSlot(MenuItem* menuitem, int8_t line) {
@@ -4022,30 +4013,30 @@ void drawStepsMenu() {
         MENU_ITEM(ICON_Level, MSG_AUTO_MESH, onDrawMenuItem, autoLevel);
       #endif
       #if ENABLED(AUTO_BED_LEVELING_UBL)
         EDIT_ITEM(ICON_UBLSlot, MSG_UBL_STORAGE_SLOT, onDrawUBLSlot, setUBLSlot, &bedlevel.storage_slot);
         MENU_ITEM(ICON_UBLMeshSave, MSG_UBL_SAVE_MESH, onDrawMenuItem, ublMeshSave);
         MENU_ITEM(ICON_UBLMeshLoad, MSG_UBL_LOAD_MESH, onDrawMenuItem, ublMeshLoad);
         EDIT_ITEM(ICON_UBLTiltGrid, MSG_UBL_TILTING_GRID, onDrawPInt8Menu, setUBLTiltGrid, &bedLevelTools.tilt_grid);
         MENU_ITEM(ICON_UBLTiltGrid, MSG_UBL_TILT_MESH, onDrawMenuItem, ublMeshTilt);
         MENU_ITEM(ICON_UBLSmartFill, MSG_UBL_SMART_FILLIN, onDrawMenuItem, ublSmartFillMesh);
       #endif
-      #if ENABLED(MESH_EDIT_MENU)
-        MENU_ITEM(ICON_MeshReset, MSG_MESH_RESET, onDrawMenuItem, ResetMesh);
+      #if ENABLED(PROUI_MESH_EDIT)
+        MENU_ITEM(ICON_MeshReset, MSG_MESH_RESET, onDrawMenuItem, resetMesh);
         MENU_ITEM(ICON_MeshEdit, MSG_EDIT_MESH, onDrawSubMenu, drawEditMeshMenu);
       #endif
       MENU_ITEM(ICON_MeshViewer, MSG_MESH_VIEW, onDrawSubMenu, dwinMeshViewer);
     }
     updateMenu(meshMenu);
   }
 
-  #if ENABLED(MESH_EDIT_MENU)
+  #if ENABLED(PROUI_MESH_EDIT)
     void drawEditMeshMenu() {
       if (!leveling_is_valid()) { LCD_MESSAGE(MSG_UBL_MESH_INVALID); return; }
       set_bed_leveling_enabled(false);
       checkkey = ID_Menu;
       if (SET_MENU(editMeshMenu, MSG_EDIT_MESH, 4)) {
         bedLevelTools.mesh_x = bedLevelTools.mesh_y = 0;
         BACK_ITEM(drawMeshSetMenu);
         EDIT_ITEM(ICON_MeshEditX, MSG_MESH_X, onDrawPInt8Menu, setEditMeshX, &bedLevelTools.mesh_x);
         EDIT_ITEM(ICON_MeshEditY, MSG_MESH_Y, onDrawPInt8Menu, setEditMeshY, &bedLevelTools.mesh_y);
         editZValueItem = EDIT_ITEM(ICON_MeshEditZ, MSG_MESH_EDIT_Z, onDrawPFloat2Menu, setEditZValue, &bedlevel.z_values[bedLevelTools.mesh_x][bedLevelTools.mesh_y]);

commit cb044d989c397fcbf6f106502df69a7e5c41d34b
Author: Vladimir Sitnikov <sitnikov.vladimir@gmail.com>
Date:   Sun Nov 5 09:46:57 2023 +0300

    ‚ú® Probe XY Offset value limits (#26267)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 0f038a30b2..843009c274 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -2050,21 +2050,21 @@ void autoHome() { queue.inject_P(G28_STR); }
   void liveZOffset() {
     #if ANY(BABYSTEP_ZPROBE_OFFSET, JUST_BABYSTEP)
       const_float_t step_zoffset = round((menuData.value / 100.0f) * planner.settings.axis_steps_per_mm[Z_AXIS]) - babystep.accum;
       if (BABYSTEP_ALLOWED()) babystep.add_steps(Z_AXIS, step_zoffset);
     #endif
   }
   void setZOffset() {
     #if ANY(BABYSTEP_ZPROBE_OFFSET, JUST_BABYSTEP)
       babystep.accum = round(planner.settings.axis_steps_per_mm[Z_AXIS] * BABY_Z_VAR);
     #endif
-    setPFloatOnClick(Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX, 2, applyZOffset, liveZOffset);
+    setPFloatOnClick(PROBE_OFFSET_ZMIN, PROBE_OFFSET_ZMAX, 2, applyZOffset, liveZOffset);
   }
 
   void setMoveZto0() {
     #if ENABLED(Z_SAFE_HOMING)
       gcode.process_subcommands_now(MString<54>(F("G28XYO\nG28Z\nG0F5000X"), Z_SAFE_HOMING_X_POINT, F("Y"), Z_SAFE_HOMING_Y_POINT, F("\nG0Z0F300\nM400")));
     #else
       TERN_(HAS_LEVELING, set_bed_leveling_enabled(false));
       gcode.process_subcommands_now(F("G28Z\nG0Z0F300\nM400"));
     #endif
     ui.reset_status();

commit 8fa6a4da2eebc1dbe120dcac87b159e389e17dc3
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Fri Aug 25 19:33:49 2023 -0400

    üö∏ Fixes for ProUI, JyersUI, backlight, etc. (#26086)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index af69e8d3ed..0f038a30b2 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -154,22 +154,22 @@
   #define MIN_TMC_CURRENT 100
   #define MAX_TMC_CURRENT 3000
 #endif
 
 // Editable temperature limits
 #define MIN_ETEMP  0
 #define MAX_ETEMP  (thermalManager.hotend_maxtemp[0] - (HOTEND_OVERSHOOT))
 #define MIN_BEDTEMP 0
 #define MAX_BEDTEMP BED_MAX_TARGET
 
-#define DWIN_VAR_UPDATE_INTERVAL         1024
-#define DWIN_UPDATE_INTERVAL             1024
+#define DWIN_VAR_UPDATE_INTERVAL          500
+#define DWIN_UPDATE_INTERVAL             1000
 
 #if HAS_MESH && HAS_BED_PROBE
   #define BABY_Z_VAR probe.offset.z
 #else
   float z_offset = 0;
   #define BABY_Z_VAR z_offset
 #endif
 
 // Structs
 hmi_value_t hmiValue;
@@ -1246,20 +1246,27 @@ void hmiInit() {
       safe_delay((BOOTSCREEN_TIMEOUT) / 22);
     }
   #endif
   hmiSetLanguage();
 }
 
 void eachMomentUpdate() {
   static millis_t next_var_update_ms = 0, next_rts_update_ms = 0, next_status_update_ms = 0;
   const millis_t ms = millis();
 
+  #if LCD_BACKLIGHT_TIMEOUT_MINS
+    if (ui.backlight_off_ms && ELAPSED(ms, ui.backlight_off_ms)) {
+      turnOffBacklight(); // Backlight off
+      ui.backlight_off_ms = 0;
+    }
+  #endif
+
   if (ELAPSED(ms, next_var_update_ms)) {
     next_var_update_ms = ms + DWIN_VAR_UPDATE_INTERVAL;
     blink = !blink;
     updateVariable();
     #if HAS_ESDIAG
       if (checkkey == ID_ESDiagProcess) esDiag.update();
     #endif
     #if PROUI_TUNING_GRAPH
       if (checkkey == ID_PIDProcess) {
         TERN_(PIDTEMP, if (hmiValue.tempControl == PIDTEMP_START) plot.update(thermalManager.wholeDegHotend(0)));
@@ -1269,21 +1276,21 @@ void eachMomentUpdate() {
     #endif
   }
 
   #if HAS_STATUS_MESSAGE_TIMEOUT
     bool did_expire = ui.status_reset_callback && (*ui.status_reset_callback)();
     did_expire |= ui.status_message_expire_ms && ELAPSED(ms, ui.status_message_expire_ms);
     if (did_expire) ui.reset_status();
   #endif
 
   if (ELAPSED(ms, next_status_update_ms)) {
-    next_status_update_ms = ms + 500;
+    next_status_update_ms = ms + DWIN_VAR_UPDATE_INTERVAL;
     dwinDrawStatusMessage();
     #if ENABLED(SCROLL_LONG_FILENAMES)
       if (isMenu(fileMenu)) fileMenuIdle();
     #endif
   }
 
   if (!PENDING(ms, next_rts_update_ms)) {
     next_rts_update_ms = ms + DWIN_UPDATE_INTERVAL;
 
     if ((isPrinting() != hmiFlag.printing_flag) && !hmiFlag.home_flag) {
@@ -2213,20 +2220,24 @@ void setMoveZ() { hmiValue.axis = Z_AXIS; setPFloatOnClick(Z_MIN_POS, Z_MAX_POS,
 
   void probeStow() { probe.stow(); }
   void probeDeploy() { probe.deploy(); }
 
   #if HAS_BLTOUCH_HS_MODE
     void setHSMode() { toggleCheckboxLine(bltouch.high_speed_mode); }
   #endif
 
 #endif
 
+#if LCD_BACKLIGHT_TIMEOUT_MINS
+  void setTimer() { setPIntOnClick(ui.backlight_timeout_min, ui.backlight_timeout_max); }
+#endif
+
 #if HAS_FILAMENT_SENSOR
   void setRunoutEnable() {
     runout.reset();
     toggleCheckboxLine(runout.enabled);
   }
   #if HAS_FILAMENT_RUNOUT_DISTANCE
     void applyRunoutDistance() { runout.set_runout_distance(menuData.value / MINUNITMULT); }
     void setRunoutDistance() { setFloatOnClick(0, 999, UNITFDIGITS, runout.runout_distance(), applyRunoutDistance); }
   #endif
 #endif
@@ -2251,34 +2262,34 @@ void setSpeed() { setPIntOnClick(MIN_PRINT_SPEED, MAX_PRINT_SPEED); }
 #if HAS_HEATED_BED
   void applyBedTemp() { thermalManager.setTargetBed(menuData.value); }
   void setBedTemp() { setIntOnClick(MIN_BEDTEMP, MAX_BEDTEMP, thermalManager.degTargetBed(), applyBedTemp); }
 #endif
 
 #if HAS_FAN
   void applyFanSpeed() { thermalManager.set_fan_speed(0, menuData.value); }
   void setFanSpeed() { setIntOnClick(0, 255, thermalManager.fan_speed[0], applyFanSpeed); }
 #endif
 
+#if ENABLED(NOZZLE_PARK_FEATURE)
+  void parkHead() {
+    LCD_MESSAGE(MSG_FILAMENT_PARK_ENABLED);
+    queue.inject(F("G28O\nG27"));
+  }
+#endif
+
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
 
   void changeFilament() {
     hmiSaveProcessID(ID_NothingToDo);
     queue.inject(F("M600 B2"));
   }
 
-  #if ENABLED(NOZZLE_PARK_FEATURE)
-    void parkHead() {
-      LCD_MESSAGE(MSG_FILAMENT_PARK_ENABLED);
-      queue.inject(F("G28O\nG27"));
-    }
-  #endif
-
   #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
     void unloadFilament() {
       LCD_MESSAGE(MSG_FILAMENTUNLOAD);
       queue.inject(F("M702 Z20"));
     }
 
     void loadFilament() {
       LCD_MESSAGE(MSG_FILAMENTLOAD);
       queue.inject(F("M701 Z20"));
     }
@@ -2972,23 +2983,21 @@ void onDrawAcc(MenuItem* menuitem, int8_t line) {
 // Menu Creation and Drawing functions ======================================================
 
 frame_rect_t selrect(frame_rect_t) {
   return hmiIsChinese() ? frame_rect_t({ 133, 1, 28, 13 }) : frame_rect_t({ 0 });
 }
 
 void drawPrepareMenu() {
   checkkey = ID_Menu;
   if (SET_MENU_R(prepareMenu, selrect({133, 1, 28, 13}), MSG_PREPARE, 10 + PREHEAT_COUNT)) {
     BACK_ITEM(gotoMainMenu);
-    #if ENABLED(ADVANCED_PAUSE_FEATURE)
-      MENU_ITEM(ICON_FilMan, MSG_FILAMENT_MAN, onDrawSubMenu, drawFilamentManMenu);
-    #endif
+    MENU_ITEM(ICON_FilMan, MSG_FILAMENT_MAN, onDrawSubMenu, drawFilamentManMenu);
     MENU_ITEM(ICON_Axis, MSG_MOVE_AXIS, onDrawMoveSubMenu, drawMoveMenu);
     #if ENABLED(LCD_BED_TRAMMING)
       MENU_ITEM(ICON_Tram, MSG_BED_TRAMMING, onDrawSubMenu, drawTrammingMenu);
     #endif
     MENU_ITEM(ICON_CloseMotor, MSG_DISABLE_STEPPERS, onDrawDisableMotors, disableMotors);
     #if ENABLED(INDIVIDUAL_AXIS_HOMING_SUBMENU)
       MENU_ITEM(ICON_Homing, MSG_HOMING, onDrawSubMenu, drawHomingMenu);
     #else
       MENU_ITEM(ICON_Homing, MSG_AUTO_HOME, onDrawAutoHome, autoHome);
     #endif
@@ -3065,21 +3074,21 @@ void drawControlMenu() {
     #endif
     MENU_ITEM(ICON_Reboot, MSG_RESET_PRINTER, onDrawMenuItem, rebootPrinter);
     MENU_ITEM(ICON_Info, MSG_INFO_SCREEN, onDrawInfoSubMenu, gotoInfoMenu);
   }
   ui.reset_status(true);
   updateMenu(controlMenu);
 }
 
 void drawAdvancedSettingsMenu() {
   checkkey = ID_Menu;
-  if (SET_MENU(advancedSettingsMenu, MSG_ADVANCED_SETTINGS, 23)) {
+  if (SET_MENU(advancedSettingsMenu, MSG_ADVANCED_SETTINGS, 24)) {
     BACK_ITEM(gotoMainMenu);
     #if ENABLED(EEPROM_SETTINGS)
       MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawMenuItem, writeEEPROM);
     #endif
     #if HAS_MESH
       MENU_ITEM(ICON_ProbeSet, MSG_MESH_LEVELING, onDrawSubMenu, drawMeshSetMenu);
     #endif
     #if HAS_BED_PROBE
       MENU_ITEM(ICON_ProbeSet, MSG_ZPROBE_SETTINGS, onDrawSubMenu, drawProbeSetMenu);
     #endif
@@ -3102,20 +3111,23 @@ void drawAdvancedSettingsMenu() {
     #if HAS_ESDIAG
       MENU_ITEM_F(ICON_esDiag, "End-stops diag.", onDrawSubMenu, drawEndStopDiag);
     #endif
     #if ENABLED(PRINTCOUNTER)
       MENU_ITEM(ICON_PrintStats, MSG_INFO_STATS_MENU, onDrawSubMenu, gotoPrintStats);
       MENU_ITEM(ICON_PrintStatsReset, MSG_INFO_PRINT_COUNT_RESET, onDrawSubMenu, printStatsReset);
     #endif
     #if HAS_LOCKSCREEN
       MENU_ITEM(ICON_Lock, MSG_LOCKSCREEN, onDrawMenuItem, dwinLockScreen);
     #endif
+    #if LCD_BACKLIGHT_TIMEOUT_MINS
+      EDIT_ITEM(ICON_Brightness, MSG_SCREEN_TIMEOUT, onDrawPIntMenu, setTimer, &ui.backlight_timeout_minutes);
+    #endif
     #if ENABLED(SOUND_MENU_ITEM)
       EDIT_ITEM(ICON_Sound, MSG_SOUND_ENABLE, onDrawChkbMenu, setEnableSound, &ui.sound_on);
     #endif
     #if ENABLED(POWER_LOSS_RECOVERY)
       EDIT_ITEM(ICON_Pwrlossr, MSG_OUTAGE_RECOVERY, onDrawChkbMenu, setPwrLossr, &recovery.enabled);
     #endif
     #if HAS_GCODE_PREVIEW
       EDIT_ITEM(ICON_File, MSG_HAS_PREVIEW, onDrawChkbMenu, setPreview, &hmiData.enablePreview);
     #endif
     #if ENABLED(MEDIASORT_MENU_ITEM)
@@ -3323,20 +3335,23 @@ void drawTuneMenu() {
     #if ENABLED(ADVK_TUNE_ITEM)
       EDIT_ITEM(ICON_MaxAccelerated, MSG_ADVANCE_K, onDrawPFloat3Menu, setLA_K, &planner.extruder_advance_K[0]);
     #endif
     #if HAS_LOCKSCREEN
       MENU_ITEM(ICON_Lock, MSG_LOCKSCREEN, onDrawMenuItem, dwinLockScreen);
     #endif
     #if HAS_LCD_BRIGHTNESS
       EDIT_ITEM(ICON_Brightness, MSG_BRIGHTNESS, onDrawPInt8Menu, setBrightness, &ui.brightness);
       MENU_ITEM(ICON_Brightness, MSG_BRIGHTNESS_OFF, onDrawMenuItem, turnOffBacklight);
     #endif
+    #if LCD_BACKLIGHT_TIMEOUT_MINS
+      EDIT_ITEM(ICON_Brightness, MSG_SCREEN_TIMEOUT, onDrawPIntMenu, setTimer, &ui.backlight_timeout_minutes);
+    #endif
     #if ENABLED(CASE_LIGHT_MENU)
       EDIT_ITEM(ICON_CaseLight, MSG_CASE_LIGHT, onDrawChkbMenu, setCaseLight, &caselight.on);
       #if CASELIGHT_USES_BRIGHTNESS
         // Avoid heavy interference with print job disabling live update of brightness in tune menu
         enableLiveCaseLightBrightness = false;
         EDIT_ITEM(ICON_Brightness, MSG_CASE_LIGHT_BRIGHTNESS, onDrawPInt8Menu, setCaseLightBrightness, &caselight.brightness);
       #endif
       #if ENABLED(LED_CONTROL_MENU)
         // Avoid heavy interference with print job disabling live update of color in tune menu
         enableLiveLedColor = false;
@@ -3445,56 +3460,54 @@ void drawMotionMenu() {
     #if ENABLED(ADAPTIVE_STEP_SMOOTHING)
       EDIT_ITEM(ICON_UBLActive, MSG_STEP_SMOOTHING, onDrawChkbMenu, setAdaptiveStepSmoothing, &hmiData.adaptiveStepSmoothing);
     #endif
     MENU_ITEM(ICON_Step, MSG_STEPS_PER_MM, onDrawSteps, drawStepsMenu);
     EDIT_ITEM(ICON_Flow, MSG_FLOW, onDrawPIntMenu, setFlow, &planner.flow_percentage[0]);
     EDIT_ITEM(ICON_Speed, MSG_SPEED, onDrawPIntMenu, setSpeed, &feedrate_percentage);
   }
   updateMenu(motionMenu);
 }
 
-#if ENABLED(ADVANCED_PAUSE_FEATURE)
-
-  #if HAS_PREHEAT
+#if ALL(ADVANCED_PAUSE_FEATURE, HAS_PREHEAT)
 
     void drawPreheatHotendMenu() {
       checkkey = ID_Menu;
       if (SET_MENU(preheatHotendMenu, MSG_PREHEAT_HOTEND, 1 + PREHEAT_COUNT)) {
         BACK_ITEM(drawFilamentManMenu);
         #define _ITEM_PREHEAT_HE(N) MENU_ITEM(ICON_Preheat##N, MSG_PREHEAT_##N, onDrawMenuItem, DoPreheatHotend##N);
         REPEAT_1(PREHEAT_COUNT, _ITEM_PREHEAT_HE)
       }
       updateMenu(preheatHotendMenu);
     }
 
-  #endif
+#endif
 
-  void drawFilamentManMenu() {
-    checkkey = ID_Menu;
-    if (SET_MENU(filamentMenu, MSG_FILAMENT_MAN, 6)) {
-      BACK_ITEM(drawPrepareMenu);
-      #if ENABLED(NOZZLE_PARK_FEATURE)
-        MENU_ITEM(ICON_Park, MSG_FILAMENT_PARK_ENABLED, onDrawMenuItem, parkHead);
-      #endif
+void drawFilamentManMenu() {
+  checkkey = ID_Menu;
+  if (SET_MENU(filamentMenu, MSG_FILAMENT_MAN, 6)) {
+    BACK_ITEM(drawPrepareMenu);
+    #if ENABLED(NOZZLE_PARK_FEATURE)
+      MENU_ITEM(ICON_Park, MSG_FILAMENT_PARK_ENABLED, onDrawMenuItem, parkHead);
+    #endif
+    #if ENABLED(ADVANCED_PAUSE_FEATURE)
       #if HAS_PREHEAT
         MENU_ITEM(ICON_SetEndTemp, MSG_PREHEAT_HOTEND, onDrawSubMenu, drawPreheatHotendMenu);
       #endif
       MENU_ITEM(ICON_FilMan, MSG_FILAMENTCHANGE, onDrawMenuItem, changeFilament);
-      #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
-        MENU_ITEM(ICON_FilUnload, MSG_FILAMENTUNLOAD, onDrawMenuItem, unloadFilament);
-        MENU_ITEM(ICON_FilLoad, MSG_FILAMENTLOAD, onDrawMenuItem, loadFilament);
-      #endif
-    }
-    updateMenu(filamentMenu);
+    #endif
+    #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
+      MENU_ITEM(ICON_FilUnload, MSG_FILAMENTUNLOAD, onDrawMenuItem, unloadFilament);
+      MENU_ITEM(ICON_FilLoad, MSG_FILAMENTLOAD, onDrawMenuItem, loadFilament);
+    #endif
   }
-
-#endif
+  updateMenu(filamentMenu);
+}
 
 #if ENABLED(MESH_BED_LEVELING)
 
   void drawManualMeshMenu() {
     checkkey = ID_Menu;
     if (SET_MENU(manualMeshMenu, MSG_UBL_MANUAL_MESH, 6)) {
       BACK_ITEM(drawPrepareMenu);
       MENU_ITEM(ICON_ManualMesh, MSG_LEVEL_BED, onDrawMenuItem, manualMeshStart);
       mMeshMoveZItem = EDIT_ITEM(ICON_Zoffset, MSG_MOVE_Z, onDrawMMeshMoveZ, setMMeshMoveZ, &current_position.z);
       MENU_ITEM(ICON_Axis, MSG_UBL_CONTINUE_MESH, onDrawMenuItem, manualMeshContinue);

commit 4613f85bb754991b1ea4fa5218ae94e758be0e8a
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Aug 24 15:09:03 2023 -0500

    üßë‚Äçüíª Encapsulate ProUI G-code preview

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 83c7eebe38..af69e8d3ed 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -281,21 +281,21 @@ Menu *stepsMenu = nullptr;
 
 // Updatable menuitems pointers
 MenuItem *hotendTargetItem = nullptr;
 MenuItem *bedTargetItem = nullptr;
 MenuItem *fanSpeedItem = nullptr;
 MenuItem *mMeshMoveZItem = nullptr;
 MenuItem *editZValueItem = nullptr;
 
 bool isPrinting() { return printingIsActive() || printingIsPaused(); }
 bool sdPrinting() { return isPrinting() && IS_SD_FILE_OPEN(); }
-bool Host_Printing() { return isPrinting() && !IS_SD_FILE_OPEN(); }
+bool hostPrinting() { return isPrinting() && !IS_SD_FILE_OPEN(); }
 
 #define DWIN_LANGUAGE_EEPROM_ADDRESS 0x01   // Between 0x01 and 0x63 (EEPROM_OFFSET-1)
                                             // BL24CXX::check() uses 0x00
 
 inline bool hmiIsChinese() { return hmiFlag.language == DWIN_CHINESE; }
 
 void hmiSetLanguageCache() {
   dwinJPGCacheTo1(hmiIsChinese() ? Language_Chinese : Language_English);
 }
 
@@ -627,23 +627,23 @@ void gotoPrintProcess() {
   dwinUpdateLCD();
 }
 
 void drawPrintDone() {
   TERN_(SET_PROGRESS_PERCENT, ui.set_progress_done());
   TERN_(SET_REMAINING_TIME, ui.reset_remaining_time());
   title.showCaption(GET_TEXT_F(MSG_PRINT_DONE));
   DWINUI::clearMainArea();
   dwinPrintHeader(nullptr);
   #if HAS_GCODE_PREVIEW
-    const bool haspreview = Preview_Valid();
+    const bool haspreview = preview.valid();
     if (haspreview) {
-      Preview_Show();
+      preview.show();
       DWINUI::drawButton(BTN_Continue, 86, 295);
     }
   #else
     constexpr bool haspreview = false;
   #endif
 
   if (!haspreview) {
     drawPrintProgressBar();
     drawPrintLabels();
     DWINUI::drawIcon(ICON_PrintTime, 15, 173);
@@ -1668,21 +1668,21 @@ void dwinLevelingDone() {
         checkkey = last_checkkey;
         ui.reset_alert_level();
         break;
     }
   }
 
 #endif // MPC_AUTOTUNE
 
 // Started a Print Job
 void dwinPrintStarted() {
-  TERN_(HAS_GCODE_PREVIEW, if (Host_Printing()) Preview_Invalidate());
+  TERN_(HAS_GCODE_PREVIEW, if (hostPrinting()) preview.invalidate());
   TERN_(SET_PROGRESS_PERCENT, ui.progress_reset());
   TERN_(SET_REMAINING_TIME, ui.reset_remaining_time());
   hmiFlag.pause_flag = false;
   hmiFlag.abort_flag = false;
   select_print.reset();
   gotoPrintProcess();
 }
 
 // Pause a print job
 void dwinPrintPause() {
@@ -1953,21 +1953,21 @@ void dwinRedrawScreen() {
       return card.openAndPrintFile(card.filename);
     }
     else
       hmiReturnScreen();
   }
 
 #endif // HAS_GCODE_PREVIEW
 
 void gotoConfirmToPrint() {
   #if HAS_GCODE_PREVIEW
-    if (hmiData.enablePreview) return gotoPopup(Preview_DrawFromSD, onClickConfirmToPrint);
+    if (hmiData.enablePreview) return gotoPopup(preview.drawFromSD, onClickConfirmToPrint);
   #endif
   card.openAndPrintFile(card.filename); // Direct print SD file
 }
 
 #if HAS_ESDIAG
   void drawEndStopDiag() {
     hmiSaveProcessID(ID_ESDiagProcess);
     esDiag.draw();
   }
 #endif

commit 88cdf487b433bf2187f2dad31587882ebf02cc59
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Aug 22 17:36:53 2023 -0500

    üö∏ Avoid LCD messages starting with "Error:" (#26164)

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 7c69d0f900..83c7eebe38 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -1818,21 +1818,21 @@ void MarlinUI::update() {
   eachMomentUpdate();   // Status update
   dwinHandleScreen();  // Rotary encoder update
 }
 
 void MarlinUI::refresh() { /* Nothing to see here */ }
 
 #if HAS_LCD_BRIGHTNESS
   void MarlinUI::_set_brightness() { dwinLCDBrightness(backlight ? brightness : 0); }
 #endif
 
-void MarlinUI::kill_screen(FSTR_P const lcd_error, FSTR_P const lcd_component) {
+void MarlinUI::kill_screen(FSTR_P const lcd_error, FSTR_P const) {
   dwinDrawPopup(ICON_BLTouch, GET_TEXT_F(MSG_PRINTER_KILLED), lcd_error);
   DWINUI::drawCenteredString(hmiData.colorPopupTxt, 270, GET_TEXT_F(MSG_TURN_OFF));
   dwinUpdateLCD();
 }
 
 void dwinRebootScreen() {
   dwinFrameClear(COLOR_BG_BLACK);
   dwinJPGShowAndCache(0);
   DWINUI::drawCenteredString(COLOR_WHITE, 220, GET_TEXT_F(MSG_PLEASE_WAIT_REBOOT));
   dwinUpdateLCD();

commit f7d5188b2f0a59b752fbabf6b96ff1ed4aed8112
Author: GHGiampy <83699429+GHGiampy@users.noreply.github.com>
Date:   Sat Aug 19 22:53:45 2023 +0200

    üêõ Fixes for ProUI, build rename (#26177)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 824b730019..7c69d0f900 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -207,36 +207,36 @@ bool hash_changed = true; // Flag to know if message status was changed
 bool blink = false;
 uint8_t checkkey = 255, last_checkkey = ID_MainMenu;
 
 // New menu system pointers
 Menu *fileMenu = nullptr;
 Menu *prepareMenu = nullptr;
 #if ENABLED(LCD_BED_TRAMMING)
   Menu *trammingMenu = nullptr;
 #endif
 Menu *moveMenu = nullptr;
-Menu *ControlMenu = nullptr;
-Menu *AdvancedSettings = nullptr;
+Menu *controlMenu = nullptr;
+Menu *advancedSettingsMenu = nullptr;
 #if HAS_HOME_OFFSET
   Menu *homeOffsetMenu = nullptr;
 #endif
 #if HAS_BED_PROBE
-  Menu *ProbeSetMenu = nullptr;
+  Menu *probeSettingsMenu = nullptr;
 #endif
 Menu *filSetMenu = nullptr;
 Menu *selectColorMenu = nullptr;
 Menu *getColorMenu = nullptr;
 Menu *tuneMenu = nullptr;
 Menu *motionMenu = nullptr;
 Menu *filamentMenu = nullptr;
 #if ENABLED(MESH_BED_LEVELING)
-  Menu *manualMesh = nullptr;
+  Menu *manualMeshMenu = nullptr;
 #endif
 #if HAS_PREHEAT
   Menu *preheatMenu = nullptr;
   Menu *preheatHotendMenu = nullptr;
 #endif
 Menu *temperatureMenu = nullptr;
 Menu *maxSpeedMenu = nullptr;
 Menu *maxAccelMenu = nullptr;
 #if HAS_CLASSIC_JERK
   Menu *maxJerkMenu = nullptr;
@@ -244,21 +244,21 @@ Menu *maxAccelMenu = nullptr;
 Menu *stepsMenu = nullptr;
 #if ANY(MPC_EDIT_MENU, MPC_AUTOTUNE_MENU)
   Menu *hotendMPCMenu = nullptr;
 #endif
 #if ENABLED(PIDTEMP) && ANY(PID_EDIT_MENU, PID_AUTOTUNE_MENU)
   Menu *hotendPIDMenu = nullptr;
 #endif
 #if ENABLED(PIDTEMPBED) && ANY(PID_EDIT_MENU, PID_AUTOTUNE_MENU)
   Menu *bedPIDMenu = nullptr;
 #endif
-#if ENABLED(CASELIGHT_USES_BRIGHTNESS)
+#if CASELIGHT_USES_BRIGHTNESS
   Menu *caseLightMenu = nullptr;
 #endif
 #if ENABLED(LED_CONTROL_MENU)
   Menu *ledControlMenu = nullptr;
 #endif
 #if HAS_BED_PROBE
   Menu *zOffsetWizMenu = nullptr;
 #endif
 #if ENABLED(INDIVIDUAL_AXIS_HOMING_SUBMENU)
   Menu *homingMenu = nullptr;
@@ -2145,38 +2145,41 @@ void setMoveZ() { hmiValue.axis = Z_AXIS; setPFloatOnClick(Z_MIN_POS, Z_MAX_POS,
   void liveBrightness() { dwinLCDBrightness(menuData.value); }
   void setBrightness() { setIntOnClick(LCD_BRIGHTNESS_MIN, LCD_BRIGHTNESS_MAX, ui.brightness, applyBrightness, liveBrightness); }
   void turnOffBacklight() { hmiSaveProcessID(ID_WaitResponse); ui.set_brightness(0); dwinRedrawScreen(); }
 #endif
 
 #if ENABLED(CASE_LIGHT_MENU)
   void setCaseLight() {
     toggleCheckboxLine(caselight.on);
     caselight.update_enabled();
   }
-  #if ENABLED(CASELIGHT_USES_BRIGHTNESS)
+  #if CASELIGHT_USES_BRIGHTNESS
+    bool enableLiveCaseLightBrightness = true;
     void liveCaseLightBrightness() { caselight.brightness = menuData.value; caselight.update_brightness(); }
-    void setCaseLightBrightness() { setIntOnClick(0, 255, caselight.brightness, nullptr, liveCaseLightBrightness); }
+    void setCaseLightBrightness() { setIntOnClick(0, 255, caselight.brightness, liveCaseLightBrightness, enableLiveCaseLightBrightness ? liveCaseLightBrightness : nullptr); }
   #endif
 #endif
 
 #if ENABLED(LED_CONTROL_MENU)
   #if !ALL(CASE_LIGHT_MENU, CASE_LIGHT_USE_NEOPIXEL)
     void setLedStatus() {
       leds.toggle();
       showCheckboxLine(leds.lights_on);
     }
   #endif
   #if HAS_COLOR_LEDS
+    bool enableLiveLedColor = true;
     void applyLEDColor() {
       hmiData.ledColor = LEDColor( {leds.color.r, leds.color.g, leds.color.b OPTARG(HAS_WHITE_LED, hmiData.ledColor.w) } );
+      if (!enableLiveLedColor) leds.update();
     }
-    void liveLEDColor(uint8_t *color) { *color = menuData.value; leds.update(); }
+    void liveLEDColor(uint8_t *color) { *color = menuData.value; if (enableLiveLedColor) leds.update(); }
     void liveLEDColorR() { liveLEDColor(&leds.color.r); }
     void liveLEDColorG() { liveLEDColor(&leds.color.g); }
     void liveLEDColorB() { liveLEDColor(&leds.color.b); }
     void setLEDColorR() { setIntOnClick(0, 255, leds.color.r, applyLEDColor, liveLEDColorR); }
     void setLEDColorG() { setIntOnClick(0, 255, leds.color.g, applyLEDColor, liveLEDColorG); }
     void setLEDColorB() { setIntOnClick(0, 255, leds.color.b, applyLEDColor, liveLEDColorB); }
     #if HAS_WHITE_LED
       void liveLEDColorW() { liveLEDColor(&leds.color.w); }
       void setLEDColorW() { setIntOnClick(0, 255, leds.color.w, applyLEDColor, liveLEDColorW); }
     #endif
@@ -3032,49 +3035,51 @@ void drawPrepareMenu() {
         MENU_ITEM(ICON_Axis, MSG_TRAM_C, onDrawMenuItem, []{ (void)tram(4); });
       #endif
     }
     updateMenu(trammingMenu);
   }
 
 #endif // LCD_BED_TRAMMING
 
 void drawControlMenu() {
   checkkey = ID_Menu;
-  if (SET_MENU_R(ControlMenu, selrect({103, 1, 28, 14}), MSG_CONTROL, 11)) {
+  if (SET_MENU_R(controlMenu, selrect({103, 1, 28, 14}), MSG_CONTROL, 11)) {
     BACK_ITEM(gotoMainMenu);
     MENU_ITEM(ICON_Temperature, MSG_TEMPERATURE, onDrawTempSubMenu, drawTemperatureMenu);
     MENU_ITEM(ICON_Motion, MSG_MOTION, onDrawMotionSubMenu, drawMotionMenu);
-    #if ENABLED(EEPROM_SETTINGS)
-      MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawWriteEeprom, writeEEPROM);
-      MENU_ITEM(ICON_ReadEEPROM, MSG_LOAD_EEPROM, onDrawReadEeprom, readEEPROM);
-      MENU_ITEM(ICON_ResumeEEPROM, MSG_RESTORE_DEFAULTS, onDrawResetEeprom, resetEEPROM);
-    #endif
-    MENU_ITEM(ICON_Reboot, MSG_RESET_PRINTER, onDrawMenuItem, rebootPrinter);
     #if ENABLED(CASE_LIGHT_MENU)
-      #if ENABLED(CASELIGHT_USES_BRIGHTNESS)
+      #if CASELIGHT_USES_BRIGHTNESS
+        enableLiveCaseLightBrightness = true;  // Allow live update of brightness in control menu
         MENU_ITEM(ICON_CaseLight, MSG_CASE_LIGHT, onDrawSubMenu, drawCaseLightMenu);
       #else
         MENU_ITEM(ICON_CaseLight, MSG_CASE_LIGHT, onDrawChkbMenu, setCaseLight, &caselight.on);
       #endif
     #endif
     #if ENABLED(LED_CONTROL_MENU)
+      enableLiveLedColor = true;  // Allow live update of color in control menu
       MENU_ITEM(ICON_LedControl, MSG_LED_CONTROL, onDrawSubMenu, drawLedControlMenu);
     #endif
+    #if ENABLED(EEPROM_SETTINGS)
+      MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawWriteEeprom, writeEEPROM);
+      MENU_ITEM(ICON_ReadEEPROM, MSG_LOAD_EEPROM, onDrawReadEeprom, readEEPROM);
+      MENU_ITEM(ICON_ResumeEEPROM, MSG_RESTORE_DEFAULTS, onDrawResetEeprom, resetEEPROM);
+    #endif
+    MENU_ITEM(ICON_Reboot, MSG_RESET_PRINTER, onDrawMenuItem, rebootPrinter);
     MENU_ITEM(ICON_Info, MSG_INFO_SCREEN, onDrawInfoSubMenu, gotoInfoMenu);
   }
   ui.reset_status(true);
-  updateMenu(ControlMenu);
+  updateMenu(controlMenu);
 }
 
 void drawAdvancedSettingsMenu() {
   checkkey = ID_Menu;
-  if (SET_MENU(AdvancedSettings, MSG_ADVANCED_SETTINGS, 23)) {
+  if (SET_MENU(advancedSettingsMenu, MSG_ADVANCED_SETTINGS, 23)) {
     BACK_ITEM(gotoMainMenu);
     #if ENABLED(EEPROM_SETTINGS)
       MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawMenuItem, writeEEPROM);
     #endif
     #if HAS_MESH
       MENU_ITEM(ICON_ProbeSet, MSG_MESH_LEVELING, onDrawSubMenu, drawMeshSetMenu);
     #endif
     #if HAS_BED_PROBE
       MENU_ITEM(ICON_ProbeSet, MSG_ZPROBE_SETTINGS, onDrawSubMenu, drawProbeSetMenu);
     #endif
@@ -3122,21 +3127,21 @@ void drawAdvancedSettingsMenu() {
     #endif
     #if HAS_LCD_BRIGHTNESS
       EDIT_ITEM(ICON_Brightness, MSG_BRIGHTNESS, onDrawPInt8Menu, setBrightness, &ui.brightness);
       MENU_ITEM(ICON_Brightness, MSG_BRIGHTNESS_OFF, onDrawMenuItem, turnOffBacklight);
     #endif
     #if HAS_CUSTOM_COLORS
       MENU_ITEM(ICON_Scolor, MSG_COLORS_SELECT, onDrawSubMenu, drawSelectColorsMenu);
     #endif
   }
   ui.reset_status(true);
-  updateMenu(AdvancedSettings);
+  updateMenu(advancedSettingsMenu);
 }
 
 void drawMoveMenu() {
   checkkey = ID_Menu;
   if (SET_MENU_R(moveMenu, selrect({192, 1, 42, 14}), MSG_MOVE_AXIS, 6)) {
     BACK_ITEM(drawPrepareMenu);
     EDIT_ITEM(ICON_Axis, MSG_LIVE_MOVE, onDrawChkbMenu, setLiveMove, &enableLiveMove);
     #if HAS_X_AXIS
       EDIT_ITEM(ICON_MoveX, MSG_MOVE_X, onDrawMoveX, setMoveX, &current_position.x);
     #endif
@@ -3173,21 +3178,21 @@ void drawMoveMenu() {
     }
     updateMenu(homeOffsetMenu);
   }
 
 #endif // HAS_HOME_OFFSET
 
 #if HAS_BED_PROBE
 
   void drawProbeSetMenu() {
     checkkey = ID_Menu;
-    if (SET_MENU(ProbeSetMenu, MSG_ZPROBE_SETTINGS, 9)) {
+    if (SET_MENU(probeSettingsMenu, MSG_ZPROBE_SETTINGS, 9)) {
       BACK_ITEM(drawAdvancedSettingsMenu);
       #if HAS_X_AXIS
         EDIT_ITEM(ICON_ProbeOffsetX, MSG_ZPROBE_XOFFSET, onDrawPFloatMenu, setProbeOffsetX, &probe.offset.x);
       #endif
       #if HAS_Y_AXIS
         EDIT_ITEM(ICON_ProbeOffsetY, MSG_ZPROBE_YOFFSET, onDrawPFloatMenu, setProbeOffsetY, &probe.offset.y);
       #endif
       #if HAS_Z_AXIS
         EDIT_ITEM(ICON_ProbeOffsetZ, MSG_ZPROBE_ZOFFSET, onDrawPFloat2Menu, setProbeOffsetZ, &probe.offset.z);
       #endif
@@ -3196,21 +3201,21 @@ void drawMoveMenu() {
         MENU_ITEM(ICON_ProbeDeploy, MSG_MANUAL_DEPLOY, onDrawMenuItem, probeDeploy);
         MENU_ITEM(ICON_BltouchReset, MSG_BLTOUCH_RESET, onDrawMenuItem, bltouch._reset);
         #if HAS_BLTOUCH_HS_MODE
           EDIT_ITEM(ICON_HSMode, MSG_ENABLE_HS_MODE, onDrawChkbMenu, setHSMode, &bltouch.high_speed_mode);
         #endif
       #endif
       #if ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)
         MENU_ITEM(ICON_ProbeTest, MSG_M48_TEST, onDrawMenuItem, probeTest);
       #endif
     }
-    updateMenu(ProbeSetMenu);
+    updateMenu(probeSettingsMenu);
   }
 
 #endif // HAS_BED_PROBE
 
 void drawFilSetMenu() {
   checkkey = ID_Menu;
   if (SET_MENU(filSetMenu, MSG_FILAMENT_SET, 9)) {
     BACK_ITEM(drawAdvancedSettingsMenu);
     #if HAS_FILAMENT_SENSOR
       EDIT_ITEM(ICON_Runout, MSG_RUNOUT_ENABLE, onDrawChkbMenu, setRunoutEnable, &runout.enabled);
@@ -3244,21 +3249,21 @@ void drawFilSetMenu() {
     updateMenu(caseLightMenu);
   }
 
 #endif
 
 #if ENABLED(LED_CONTROL_MENU)
 
   void drawLedControlMenu() {
     checkkey = ID_Menu;
     if (SET_MENU(ledControlMenu, MSG_LED_CONTROL, 10)) {
-      BACK_ITEM(drawControlMenu);
+      BACK_ITEM((currentMenu == tuneMenu) ? drawTuneMenu : drawControlMenu);
       #if !ALL(CASE_LIGHT_MENU, CASE_LIGHT_USE_NEOPIXEL)
         EDIT_ITEM(ICON_LedControl, MSG_LEDS, onDrawChkbMenu, setLedStatus, &leds.lights_on);
       #endif
       #if HAS_COLOR_LEDS
         #if ENABLED(LED_COLOR_PRESETS)
           MENU_ITEM(ICON_LedControl, MSG_SET_LEDS_WHITE, onDrawMenuItem,  leds.set_white);
           MENU_ITEM(ICON_LedControl, MSG_SET_LEDS_RED, onDrawMenuItem,    leds.set_red);
           MENU_ITEM(ICON_LedControl, MSG_SET_LEDS_ORANGE, onDrawMenuItem, leds.set_orange);
           MENU_ITEM(ICON_LedControl, MSG_SET_LEDS_YELLOW, onDrawMenuItem, leds.set_yellow);
           MENU_ITEM(ICON_LedControl, MSG_SET_LEDS_GREEN, onDrawMenuItem,  leds.set_green);
@@ -3275,21 +3280,21 @@ void drawFilSetMenu() {
         #endif
       #endif
     }
     updateMenu(ledControlMenu);
   }
 
 #endif // LED_CONTROL_MENU
 
 void drawTuneMenu() {
   checkkey = ID_Menu;
-  if (SET_MENU_R(tuneMenu, selrect({73, 2, 28, 12}), MSG_TUNE, 17)) {
+  if (SET_MENU_R(tuneMenu, selrect({73, 2, 28, 12}), MSG_TUNE, 18)) {
     BACK_ITEM(gotoPrintProcess);
     EDIT_ITEM(ICON_Speed, MSG_SPEED, onDrawSpeedItem, setSpeed, &feedrate_percentage);
     #if HAS_HOTEND
       hotendTargetItem = EDIT_ITEM(ICON_HotendTemp, MSG_UBL_SET_TEMP_HOTEND, onDrawHotendTemp, setHotendTemp, &thermalManager.temp_hotend[0].target);
     #endif
     #if HAS_HEATED_BED
       bedTargetItem = EDIT_ITEM(ICON_BedTemp, MSG_UBL_SET_TEMP_BED, onDrawBedTemp, setBedTemp, &thermalManager.temp_bed.target);
     #endif
     #if HAS_FAN
       fanSpeedItem = EDIT_ITEM(ICON_FanSpeed, MSG_FAN_SPEED, onDrawFanSpeed, setFanSpeed, &thermalManager.fan_speed[0]);
@@ -3320,20 +3325,30 @@ void drawTuneMenu() {
     #endif
     #if HAS_LOCKSCREEN
       MENU_ITEM(ICON_Lock, MSG_LOCKSCREEN, onDrawMenuItem, dwinLockScreen);
     #endif
     #if HAS_LCD_BRIGHTNESS
       EDIT_ITEM(ICON_Brightness, MSG_BRIGHTNESS, onDrawPInt8Menu, setBrightness, &ui.brightness);
       MENU_ITEM(ICON_Brightness, MSG_BRIGHTNESS_OFF, onDrawMenuItem, turnOffBacklight);
     #endif
     #if ENABLED(CASE_LIGHT_MENU)
       EDIT_ITEM(ICON_CaseLight, MSG_CASE_LIGHT, onDrawChkbMenu, setCaseLight, &caselight.on);
+      #if CASELIGHT_USES_BRIGHTNESS
+        // Avoid heavy interference with print job disabling live update of brightness in tune menu
+        enableLiveCaseLightBrightness = false;
+        EDIT_ITEM(ICON_Brightness, MSG_CASE_LIGHT_BRIGHTNESS, onDrawPInt8Menu, setCaseLightBrightness, &caselight.brightness);
+      #endif
+      #if ENABLED(LED_CONTROL_MENU)
+        // Avoid heavy interference with print job disabling live update of color in tune menu
+        enableLiveLedColor = false;
+        MENU_ITEM(ICON_LedControl, MSG_LED_CONTROL, onDrawSubMenu, drawLedControlMenu);
+      #endif
     #elif ENABLED(LED_CONTROL_MENU) && DISABLED(CASE_LIGHT_USE_NEOPIXEL)
       EDIT_ITEM(ICON_LedControl, MSG_LEDS, onDrawChkbMenu, setLedStatus, &leds.lights_on);
     #endif
   }
   updateMenu(tuneMenu);
 }
 
 #if ENABLED(ADAPTIVE_STEP_SMOOTHING)
   void setAdaptiveStepSmoothing() {
     toggleCheckboxLine(hmiData.adaptiveStepSmoothing);
@@ -3471,29 +3486,29 @@ void drawMotionMenu() {
     }
     updateMenu(filamentMenu);
   }
 
 #endif
 
 #if ENABLED(MESH_BED_LEVELING)
 
   void drawManualMeshMenu() {
     checkkey = ID_Menu;
-    if (SET_MENU(manualMesh, MSG_UBL_MANUAL_MESH, 6)) {
+    if (SET_MENU(manualMeshMenu, MSG_UBL_MANUAL_MESH, 6)) {
       BACK_ITEM(drawPrepareMenu);
       MENU_ITEM(ICON_ManualMesh, MSG_LEVEL_BED, onDrawMenuItem, manualMeshStart);
       mMeshMoveZItem = EDIT_ITEM(ICON_Zoffset, MSG_MOVE_Z, onDrawMMeshMoveZ, setMMeshMoveZ, &current_position.z);
       MENU_ITEM(ICON_Axis, MSG_UBL_CONTINUE_MESH, onDrawMenuItem, manualMeshContinue);
       MENU_ITEM(ICON_MeshViewer, MSG_MESH_VIEW, onDrawSubMenu, dwinMeshViewer);
       MENU_ITEM(ICON_MeshSave, MSG_UBL_SAVE_MESH, onDrawMenuItem, manualMeshSave);
     }
-    updateMenu(manualMesh);
+    updateMenu(manualMeshMenu);
   }
 
 #endif // MESH_BED_LEVELING
 
 #if HAS_PREHEAT
 
   void drawPreheatMenu(const bool notCurrent) {
     checkkey = ID_Menu;
     if (notCurrent) {
       BACK_ITEM(drawTemperatureMenu);

commit 49ead19d008dd54403b37818b21e79b8ccfa4b89
Author: Vovodroid <vovodroid@users.noreply.github.com>
Date:   Fri Aug 18 02:13:10 2023 +0300

    üîß Reversible file alpha sorting (#26130)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 2c52b0cabc..824b730019 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -843,21 +843,21 @@ void updateVariable() {
 
 /**
  * Memory card and file management
  */
 
 bool DWIN_lcd_sd_status = false;
 
 #if ENABLED(MEDIASORT_MENU_ITEM)
   void setMediaSort() {
     toggleCheckboxLine(hmiData.mediaSort);
-    card.setSortOn(hmiData.mediaSort);
+    card.setSortOn(hmiData.mediaSort ? TERN(SDSORT_REVERSE, AS_REV, AS_FWD) : AS_OFF);
   }
 #endif
 
 void setMediaAutoMount() { toggleCheckboxLine(hmiData.mediaAutoMount); }
 
 inline uint16_t nr_sd_menu_items() {
   return _MIN(card.get_num_items() + !card.flag.workDirIsRoot, MENU_MAX_ITEMS);
 }
 
 void makeNameWithoutExt(char *dst, char *src, size_t maxlen=MENU_CHAR_LIMIT) {
@@ -1747,21 +1747,21 @@ void dwinSetDataDefaults() {
     hmiData.extMinT = EXTRUDE_MINTEMP;
     applyExtMinT();
   #endif
   TERN_(PREHEAT_BEFORE_LEVELING, hmiData.bedLevT = LEVELING_BED_TEMP);
   TERN_(BAUD_RATE_GCODE, setBaud250K());
   #if ALL(LCD_BED_TRAMMING, HAS_BED_PROBE)
     hmiData.fullManualTramming = DISABLED(BED_TRAMMING_USE_PROBE);
   #endif
   #if ENABLED(MEDIASORT_MENU_ITEM)
     hmiData.mediaSort = true;
-    card.setSortOn(true);
+    card.setSortOn(TERN(SDSORT_REVERSE, AS_REV, AS_FWD));
   #endif
   hmiData.mediaAutoMount = ENABLED(HAS_SD_EXTENDER);
   #if ALL(INDIVIDUAL_AXIS_HOMING_SUBMENU, MESH_BED_LEVELING)
     hmiData.zAfterHoming = DEF_Z_AFTER_HOMING;
   #endif
   #if ALL(LED_CONTROL_MENU, HAS_COLOR_LEDS)
     TERN_(LED_COLOR_PRESETS, leds.set_default());
     applyLEDColor();
   #endif
   TERN_(ADAPTIVE_STEP_SMOOTHING, hmiData.adaptiveStepSmoothing = true);

commit 2a82ca87b03ab3b819f69b571ca44dd0a0e1afdf
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jul 27 23:03:36 2023 -0500

    ü©π Fix ProUI compile without Advanced Pause

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 7aa9b1760d..2c52b0cabc 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -3430,33 +3430,35 @@ void drawMotionMenu() {
     #if ENABLED(ADAPTIVE_STEP_SMOOTHING)
       EDIT_ITEM(ICON_UBLActive, MSG_STEP_SMOOTHING, onDrawChkbMenu, setAdaptiveStepSmoothing, &hmiData.adaptiveStepSmoothing);
     #endif
     MENU_ITEM(ICON_Step, MSG_STEPS_PER_MM, onDrawSteps, drawStepsMenu);
     EDIT_ITEM(ICON_Flow, MSG_FLOW, onDrawPIntMenu, setFlow, &planner.flow_percentage[0]);
     EDIT_ITEM(ICON_Speed, MSG_SPEED, onDrawPIntMenu, setSpeed, &feedrate_percentage);
   }
   updateMenu(motionMenu);
 }
 
-#if HAS_PREHEAT
-  void drawPreheatHotendMenu() {
-    checkkey = ID_Menu;
-    if (SET_MENU(preheatHotendMenu, MSG_PREHEAT_HOTEND, 1 + PREHEAT_COUNT)) {
-      BACK_ITEM(drawFilamentManMenu);
-      #define _ITEM_PREHEAT_HE(N) MENU_ITEM(ICON_Preheat##N, MSG_PREHEAT_##N, onDrawMenuItem, DoPreheatHotend##N);
-      REPEAT_1(PREHEAT_COUNT, _ITEM_PREHEAT_HE)
+#if ENABLED(ADVANCED_PAUSE_FEATURE)
+
+  #if HAS_PREHEAT
+
+    void drawPreheatHotendMenu() {
+      checkkey = ID_Menu;
+      if (SET_MENU(preheatHotendMenu, MSG_PREHEAT_HOTEND, 1 + PREHEAT_COUNT)) {
+        BACK_ITEM(drawFilamentManMenu);
+        #define _ITEM_PREHEAT_HE(N) MENU_ITEM(ICON_Preheat##N, MSG_PREHEAT_##N, onDrawMenuItem, DoPreheatHotend##N);
+        REPEAT_1(PREHEAT_COUNT, _ITEM_PREHEAT_HE)
+      }
+      updateMenu(preheatHotendMenu);
     }
-    updateMenu(preheatHotendMenu);
-  }
-#endif
 
-#if ENABLED(ADVANCED_PAUSE_FEATURE)
+  #endif
 
   void drawFilamentManMenu() {
     checkkey = ID_Menu;
     if (SET_MENU(filamentMenu, MSG_FILAMENT_MAN, 6)) {
       BACK_ITEM(drawPrepareMenu);
       #if ENABLED(NOZZLE_PARK_FEATURE)
         MENU_ITEM(ICON_Park, MSG_FILAMENT_PARK_ENABLED, onDrawMenuItem, parkHead);
       #endif
       #if HAS_PREHEAT
         MENU_ITEM(ICON_SetEndTemp, MSG_PREHEAT_HOTEND, onDrawSubMenu, drawPreheatHotendMenu);

commit fc2272c4b473a45f2033d4dd82aef4b259b99759
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Sat Jul 15 21:10:42 2023 -0400

    ü©π Fix, clean up ProUI, JyersUI (#26078)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 5ea8c71be0..7aa9b1760d 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -122,23 +122,20 @@
 #endif
 
 #if HAS_MESH
   #include "meshviewer.h"
 #endif
 
 #if HAS_LOCKSCREEN
   #include "lockscreen.h"
 #endif
 
-#define DEBUG_OUT ENABLED(DEBUG_DWIN)
-#include "../../../core/debug_out.h"
-
 #ifndef MACHINE_SIZE
   #define MACHINE_SIZE STRINGIFY(X_BED_SIZE) "x" STRINGIFY(Y_BED_SIZE) "x" STRINGIFY(Z_MAX_POS)
 #endif
 
 #define PAUSE_HEAT
 
 // Print speed limit
 #define MIN_PRINT_SPEED  10
 #define MAX_PRINT_SPEED 999
 
@@ -2196,24 +2193,28 @@ void setMoveZ() { hmiValue.axis = Z_AXIS; setPFloatOnClick(Z_MIN_POS, Z_MAX_POS,
   void applyHomeOffset() { set_home_offset(hmiValue.axis, menuData.value / MINUNITMULT); }
   void setHomeOffsetX() { hmiValue.axis = X_AXIS; setPFloatOnClick(-50, 50, UNITFDIGITS, applyHomeOffset); }
   void setHomeOffsetY() { hmiValue.axis = Y_AXIS; setPFloatOnClick(-50, 50, UNITFDIGITS, applyHomeOffset); }
   void setHomeOffsetZ() { hmiValue.axis = Z_AXIS; setPFloatOnClick( -2,  2, UNITFDIGITS, applyHomeOffset); }
 #endif
 
 #if HAS_BED_PROBE
   void setProbeOffsetX() { setPFloatOnClick(-60, 60, UNITFDIGITS); }
   void setProbeOffsetY() { setPFloatOnClick(-60, 60, UNITFDIGITS); }
   void setProbeOffsetZ() { setPFloatOnClick(-10, 10, 2); }
-  void probeTest() {
-    LCD_MESSAGE(MSG_M48_TEST);
-    queue.inject(F("G28O\nM48 P10"));
-  }
+
+  #if ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)
+    void probeTest() {
+      LCD_MESSAGE(MSG_M48_TEST);
+      queue.inject(F("G28O\nM48 P10"));
+    }
+  #endif
+
   void probeStow() { probe.stow(); }
   void probeDeploy() { probe.deploy(); }
 
   #if HAS_BLTOUCH_HS_MODE
     void setHSMode() { toggleCheckboxLine(bltouch.high_speed_mode); }
   #endif
 
 #endif
 
 #if HAS_FILAMENT_SENSOR
@@ -3031,21 +3032,21 @@ void drawPrepareMenu() {
         MENU_ITEM(ICON_Axis, MSG_TRAM_C, onDrawMenuItem, []{ (void)tram(4); });
       #endif
     }
     updateMenu(trammingMenu);
   }
 
 #endif // LCD_BED_TRAMMING
 
 void drawControlMenu() {
   checkkey = ID_Menu;
-  if (SET_MENU_R(ControlMenu, selrect({103, 1, 28, 14}), MSG_CONTROL, 10)) {
+  if (SET_MENU_R(ControlMenu, selrect({103, 1, 28, 14}), MSG_CONTROL, 11)) {
     BACK_ITEM(gotoMainMenu);
     MENU_ITEM(ICON_Temperature, MSG_TEMPERATURE, onDrawTempSubMenu, drawTemperatureMenu);
     MENU_ITEM(ICON_Motion, MSG_MOTION, onDrawMotionSubMenu, drawMotionMenu);
     #if ENABLED(EEPROM_SETTINGS)
       MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawWriteEeprom, writeEEPROM);
       MENU_ITEM(ICON_ReadEEPROM, MSG_LOAD_EEPROM, onDrawReadEeprom, readEEPROM);
       MENU_ITEM(ICON_ResumeEEPROM, MSG_RESTORE_DEFAULTS, onDrawResetEeprom, resetEEPROM);
     #endif
     MENU_ITEM(ICON_Reboot, MSG_RESET_PRINTER, onDrawMenuItem, rebootPrinter);
     #if ENABLED(CASE_LIGHT_MENU)
@@ -3059,31 +3060,34 @@ void drawControlMenu() {
       MENU_ITEM(ICON_LedControl, MSG_LED_CONTROL, onDrawSubMenu, drawLedControlMenu);
     #endif
     MENU_ITEM(ICON_Info, MSG_INFO_SCREEN, onDrawInfoSubMenu, gotoInfoMenu);
   }
   ui.reset_status(true);
   updateMenu(ControlMenu);
 }
 
 void drawAdvancedSettingsMenu() {
   checkkey = ID_Menu;
-  if (SET_MENU(AdvancedSettings, MSG_ADVANCED_SETTINGS, 22)) {
+  if (SET_MENU(AdvancedSettings, MSG_ADVANCED_SETTINGS, 23)) {
     BACK_ITEM(gotoMainMenu);
     #if ENABLED(EEPROM_SETTINGS)
       MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawMenuItem, writeEEPROM);
     #endif
     #if HAS_MESH
       MENU_ITEM(ICON_ProbeSet, MSG_MESH_LEVELING, onDrawSubMenu, drawMeshSetMenu);
     #endif
     #if HAS_BED_PROBE
       MENU_ITEM(ICON_ProbeSet, MSG_ZPROBE_SETTINGS, onDrawSubMenu, drawProbeSetMenu);
     #endif
+    #if HAS_HOME_OFFSET
+      MENU_ITEM(ICON_ProbeSet, MSG_SET_HOME_OFFSETS, onDrawSubMenu, drawHomeOffsetMenu);
+    #endif
     MENU_ITEM(ICON_FilSet, MSG_FILAMENT_SET, onDrawSubMenu, drawFilSetMenu);
     #if ENABLED(PIDTEMP) && ANY(PID_AUTOTUNE_MENU, PID_EDIT_MENU)
       MENU_ITEM_F(ICON_PIDNozzle, STR_HOTEND_PID " Settings", onDrawSubMenu, drawHotendPIDMenu);
     #endif
     #if ANY(MPC_EDIT_MENU, MPC_AUTOTUNE_MENU)
       MENU_ITEM_F(ICON_MPCNozzle, "MPC Settings", onDrawSubMenu, drawHotendMPCMenu);
     #endif
     #if ENABLED(PIDTEMPBED) && ANY(PID_AUTOTUNE_MENU, PID_EDIT_MENU)
       MENU_ITEM_F(ICON_PIDBed, STR_BED_PID " Settings", onDrawSubMenu, drawBedPIDMenu);
     #endif
@@ -3149,21 +3153,21 @@ void drawMoveMenu() {
   }
   updateMenu(moveMenu);
   if (!all_axes_trusted()) LCD_MESSAGE_F("WARNING: Current position unknown. Home axes.");
 }
 
 #if HAS_HOME_OFFSET
 
   void drawHomeOffsetMenu() {
     checkkey = ID_Menu;
     if (SET_MENU(homeOffsetMenu, MSG_SET_HOME_OFFSETS, 4)) {
-      BACK_ITEM(drawPhySetMenu);
+      BACK_ITEM(drawAdvancedSettingsMenu);
       #if HAS_X_AXIS
         EDIT_ITEM(ICON_HomeOffsetX, MSG_HOME_OFFSET_X, onDrawPFloatMenu, setHomeOffsetX, &home_offset.x);
       #endif
       #if HAS_Y_AXIS
         EDIT_ITEM(ICON_HomeOffsetY, MSG_HOME_OFFSET_Y, onDrawPFloatMenu, setHomeOffsetY, &home_offset.y);
       #endif
       #if HAS_Z_AXIS
         EDIT_ITEM(ICON_HomeOffsetZ, MSG_HOME_OFFSET_Z, onDrawPFloatMenu, setHomeOffsetZ, &home_offset.z);
       #endif
     }
@@ -3188,21 +3192,23 @@ void drawMoveMenu() {
         EDIT_ITEM(ICON_ProbeOffsetZ, MSG_ZPROBE_ZOFFSET, onDrawPFloat2Menu, setProbeOffsetZ, &probe.offset.z);
       #endif
       #if ENABLED(BLTOUCH)
         MENU_ITEM(ICON_ProbeStow, MSG_MANUAL_STOW, onDrawMenuItem, probeStow);
         MENU_ITEM(ICON_ProbeDeploy, MSG_MANUAL_DEPLOY, onDrawMenuItem, probeDeploy);
         MENU_ITEM(ICON_BltouchReset, MSG_BLTOUCH_RESET, onDrawMenuItem, bltouch._reset);
         #if HAS_BLTOUCH_HS_MODE
           EDIT_ITEM(ICON_HSMode, MSG_ENABLE_HS_MODE, onDrawChkbMenu, setHSMode, &bltouch.high_speed_mode);
         #endif
       #endif
-      MENU_ITEM(ICON_ProbeTest, MSG_M48_TEST, onDrawMenuItem, probeTest);
+      #if ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)
+        MENU_ITEM(ICON_ProbeTest, MSG_M48_TEST, onDrawMenuItem, probeTest);
+      #endif
     }
     updateMenu(ProbeSetMenu);
   }
 
 #endif // HAS_BED_PROBE
 
 void drawFilSetMenu() {
   checkkey = ID_Menu;
   if (SET_MENU(filSetMenu, MSG_FILAMENT_SET, 9)) {
     BACK_ITEM(drawAdvancedSettingsMenu);
@@ -3787,23 +3793,23 @@ void drawStepsMenu() {
   void drawHotendPIDMenu() {
     checkkey = ID_Menu;
     if (SET_MENU_F(hotendPIDMenu, STR_HOTEND_PID " Settings", 8)) {
       BACK_ITEM(drawAdvancedSettingsMenu);
       #if ENABLED(PID_AUTOTUNE_MENU)
         MENU_ITEM_F(ICON_PIDNozzle, STR_HOTEND_PID, onDrawMenuItem, hotendPID);
         EDIT_ITEM(ICON_Temperature, MSG_TEMPERATURE, onDrawPIntMenu, setHotendPidT, &hmiData.hotendPidT);
         EDIT_ITEM(ICON_PIDCycles, MSG_PID_CYCLE, onDrawPIntMenu, setPidCycles, &hmiData.pidCycles);
       #endif
       #if ENABLED(PID_EDIT_MENU)
-        EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KP, onDrawPFloat2Menu, SetKp, &thermalManager.temp_hotend[0].pid.Kp);
-        EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KI, onDrawPIDi, SetKi, &thermalManager.temp_hotend[0].pid.Ki);
-        EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KD, onDrawPIDd, SetKd, &thermalManager.temp_hotend[0].pid.Kd);
+        EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KP, onDrawPFloat2Menu, setKp, &thermalManager.temp_hotend[0].pid.Kp);
+        EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KI, onDrawPIDi, setKi, &thermalManager.temp_hotend[0].pid.Ki);
+        EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KD, onDrawPIDd, setKd, &thermalManager.temp_hotend[0].pid.Kd);
       #endif
       #if ENABLED(EEPROM_SETTINGS)
         MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawMenuItem, writeEEPROM);
       #endif
     }
     updateMenu(hotendPIDMenu);
   }
 
 #endif // PIDTEMP && (PID_AUTOTUNE_MENU || PID_EDIT_MENU)
 
@@ -3817,23 +3823,23 @@ void drawStepsMenu() {
   void drawBedPIDMenu() {
     checkkey = ID_Menu;
     if (SET_MENU_F(bedPIDMenu, STR_BED_PID " Settings", 8)) {
       BACK_ITEM(drawAdvancedSettingsMenu);
       #if ENABLED(PID_AUTOTUNE_MENU)
         MENU_ITEM_F(ICON_PIDBed, STR_BED_PID, onDrawMenuItem,bedPID);
         EDIT_ITEM(ICON_Temperature, MSG_TEMPERATURE, onDrawPIntMenu, setBedPidT, &hmiData.bedPidT);
         EDIT_ITEM(ICON_PIDCycles, MSG_PID_CYCLE, onDrawPIntMenu, setPidCycles, &hmiData.pidCycles);
       #endif
       #if ENABLED(PID_EDIT_MENU)
-        EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KP, onDrawPFloat2Menu, SetKp, &thermalManager.temp_bed.pid.Kp);
-        EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KI, onDrawPIDi, SetKi, &thermalManager.temp_bed.pid.Ki);
-        EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KD, onDrawPIDd, SetKd, &thermalManager.temp_bed.pid.Kd);
+        EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KP, onDrawPFloat2Menu, setKp, &thermalManager.temp_bed.pid.Kp);
+        EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KI, onDrawPIDi, setKi, &thermalManager.temp_bed.pid.Ki);
+        EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KD, onDrawPIDd, setKd, &thermalManager.temp_bed.pid.Kd);
       #endif
       #if ENABLED(EEPROM_SETTINGS)
         MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawMenuItem, writeEEPROM);
       #endif
     }
     updateMenu(bedPIDMenu);
   }
 
 #endif // PIDTEMPBED && (PID_AUTOTUNE_MENU || PID_EDIT_MENU)
 

commit 16f19b2c1fa6b64abd4de2558c13c9fdc162d600
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jul 4 19:19:44 2023 -0500

    ü©π Fix ProUI tramming

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 34a37da45f..5ea8c71be0 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -2350,62 +2350,54 @@ void setFlow() { setPIntOnClick(MIN_PRINT_FLOW, MAX_PRINT_FLOW, []{ planner.refr
 
         LIMIT(xpos, MESH_MIN_X, MESH_MAX_X);
         LIMIT(ypos, MESH_MIN_Y, MESH_MAX_Y);
         probe.stow();
         gcode.process_subcommands_now(F("M420S0\nG28O"));
         inLev = true;
         zval = probe.probe_at_point(xpos, ypos, PROBE_PT_STOW);
         if (isnan(zval))
           LCD_MESSAGE(MSG_ZPROBE_OUT);
         else
-          ui.set_status(TS(F("X:"), p_float_t(xpos, 1), F(" Y:"), p_float_t(ypos, 1), F(" Z:")));
+          ui.set_status(TS(F("X:"), p_float_t(xpos, 1), F(" Y:"), p_float_t(ypos, 1), F(" Z:"), p_float_t(zval, 2)));
         inLev = false;
       }
       return zval;
     }
 
   #else
 
     void tram(const uint8_t point) {
       float xpos = 0, ypos = 0;
       tramXY(point, xpos, ypos);
       queue.inject(MString<100>(
         F("M420S0\nG28O\nG90\nG0F300Z5\nG0F5000X"), p_float_t(xpos, 1), 'Y', p_float_t(ypos, 1), F("\nG0F300Z0")
       ));
     }
 
   #endif
 
-  inline void tramFL() { tram(0); }
-  inline void tramFR() { tram(1); }
-  inline void tramBR() { tram(2); }
-  inline void tramBL() { tram(3); }
-  #if ENABLED(BED_TRAMMING_INCLUDE_CENTER)
-    inline void tramC() { tram(4); }
-  #endif
-
   #if HAS_BED_PROBE && HAS_MESH
 
     void trammingwizard() {
       if (hmiData.fullManualTramming) {
         LCD_MESSAGE_F("Disable manual tramming");
         return;
       }
       bed_mesh_t zval = {0};
-      zval[0][0] = tramFL();
+      zval[0][0] = tram(0);
       checkkey = ID_NothingToDo;
       meshViewer.drawMesh(zval, 2, 2);
-      zval[1][0] = tramFR();
+      zval[1][0] = tram(1);
       meshViewer.drawMesh(zval, 2, 2);
-      zval[1][1] = tramBR();
+      zval[1][1] = tram(2);
       meshViewer.drawMesh(zval, 2, 2);
-      zval[0][1] = tramBL();
+      zval[0][1] = tram(3);
       meshViewer.drawMesh(zval, 2, 2);
 
       DWINUI::drawCenteredString(140, F("Calculating average"));
       DWINUI::drawCenteredString(160, F("and relative heights"));
       safe_delay(1000);
       float avg = 0.0f;
       for (uint8_t x = 0; x < 2; ++x) for (uint8_t y = 0; y < 2; ++y) avg += zval[x][y];
       avg /= 4.0f;
       for (uint8_t x = 0; x < 2; ++x) for (uint8_t y = 0; y < 2; ++y) zval[x][y] -= avg;
       meshViewer.drawMesh(zval, 2, 2);
@@ -3024,26 +3016,26 @@ void drawPrepareMenu() {
   void drawTrammingMenu() {
     checkkey = ID_Menu;
     if (SET_MENU(trammingMenu, MSG_BED_TRAMMING, 8)) {
       BACK_ITEM(drawPrepareMenu);
       #if HAS_BED_PROBE && HAS_MESH
         MENU_ITEM(ICON_ProbeSet, MSG_TRAMMING_WIZARD, onDrawMenuItem, trammingwizard);
         EDIT_ITEM(ICON_ProbeSet, MSG_BED_TRAMMING_MANUAL, onDrawChkbMenu, setManualTramming, &hmiData.fullManualTramming);
       #elif !HAS_BED_PROBE && HAS_ZOFFSET_ITEM
         MENU_ITEM_F(ICON_MoveZ0, "Home Z and disable", onDrawMenuItem, homeZAndDisable);
       #endif
-      MENU_ITEM(ICON_Axis, MSG_TRAM_FL, onDrawMenuItem, tramFL);
-      MENU_ITEM(ICON_Axis, MSG_TRAM_FR, onDrawMenuItem, tramFR);
-      MENU_ITEM(ICON_Axis, MSG_TRAM_BR, onDrawMenuItem, tramBR);
-      MENU_ITEM(ICON_Axis, MSG_TRAM_BL, onDrawMenuItem, tramBL);
+      MENU_ITEM(ICON_Axis, MSG_TRAM_FL, onDrawMenuItem, []{ (void)tram(0); });
+      MENU_ITEM(ICON_Axis, MSG_TRAM_FR, onDrawMenuItem, []{ (void)tram(1); });
+      MENU_ITEM(ICON_Axis, MSG_TRAM_BR, onDrawMenuItem, []{ (void)tram(2); });
+      MENU_ITEM(ICON_Axis, MSG_TRAM_BL, onDrawMenuItem, []{ (void)tram(3); });
       #if ENABLED(BED_TRAMMING_INCLUDE_CENTER)
-        MENU_ITEM(ICON_Axis, MSG_TRAM_C, onDrawMenuItem, tramC);
+        MENU_ITEM(ICON_Axis, MSG_TRAM_C, onDrawMenuItem, []{ (void)tram(4); });
       #endif
     }
     updateMenu(trammingMenu);
   }
 
 #endif // LCD_BED_TRAMMING
 
 void drawControlMenu() {
   checkkey = ID_Menu;
   if (SET_MENU_R(ControlMenu, selrect({103, 1, 28, 14}), MSG_CONTROL, 10)) {

commit c483fe76c7c750d1ee08a6d5fdfe363f1beb4e03
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jul 1 20:01:45 2023 -0500

    ü©π Fix ProUI _remain_time
    
    Followup to #25982

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 2e4047e05f..34a37da45f 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -568,20 +568,21 @@ void drawPrintProgressBar() {
 }
 
 void drawPrintProgressElapsed() {
   MString<12> buf;
   duration_t elapsed = print_job_timer.duration(); // Print timer
   buf.setf(F("%02i:%02i "), uint16_t(elapsed.value / 3600), (uint16_t(elapsed.value) % 3600) / 60);
   DWINUI::drawString(hmiData.colorText, hmiData.colorBackground, 47, 192, buf);
 }
 
 #if ENABLED(SHOW_REMAINING_TIME)
+  uint32_t _remain_time = 0;
   void drawPrintProgressRemain() {
     MString<12> buf;
     buf.setf(F("%02i:%02i "), _remain_time / 3600, (_remain_time % 3600) / 60);
     DWINUI::drawString(hmiData.colorText, hmiData.colorBackground, 181, 192, buf);
   }
 #endif
 
 void ICON_ResumeOrPause() {
   if (checkkey == ID_PrintProcess) (print_job_timer.isPaused() || hmiFlag.pause_flag) ? ICON_Resume() : ICON_Pause();
 }
@@ -1312,21 +1313,20 @@ void eachMomentUpdate() {
 
       // Progress percent
       static uint8_t _percent_done = 255;
       if (_percent_done != ui.get_progress_percent()) {
         _percent_done = ui.get_progress_percent();
         drawPrintProgressBar();
       }
 
       // Remaining time
       #if ENABLED(SHOW_REMAINING_TIME)
-        static uint32_t _remain_time = 0;
         if (_remain_time != ui.get_remaining_time()) {
           _remain_time = ui.get_remaining_time();
           drawPrintProgressRemain();
         }
       #endif
 
       // Elapsed print time
       static uint16_t _printtime = 0;
       const uint16_t min = (print_job_timer.duration() % 3600) / 60;
       if (_printtime != min) { // 1 minute update

commit f14f1be168ebf252dd458c935271aed1a57cfa0b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 30 19:16:00 2023 -0500

    üé® Standardize naming (ProUI) (#25982)

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 51a53741ef..2e4047e05f 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -110,21 +110,21 @@
 #include "dwin_popup.h"
 
 #if HAS_GCODE_PREVIEW
   #include "gcode_preview.h"
 #endif
 
 #if HAS_ESDIAG
   #include "endstop_diag.h"
 #endif
 
-#if SHOW_TUNING_GRAPH
+#if PROUI_TUNING_GRAPH
   #include "plot.h"
 #endif
 
 #if HAS_MESH
   #include "meshviewer.h"
 #endif
 
 #if HAS_LOCKSCREEN
   #include "lockscreen.h"
 #endif
@@ -168,23 +168,23 @@
 #define DWIN_UPDATE_INTERVAL             1024
 
 #if HAS_MESH && HAS_BED_PROBE
   #define BABY_Z_VAR probe.offset.z
 #else
   float z_offset = 0;
   #define BABY_Z_VAR z_offset
 #endif
 
 // Structs
-HMI_value_t HMI_value;
-HMI_flag_t hmiFlag{0};
-HMI_data_t HMI_data;
+hmi_value_t hmiValue;
+hmi_flag_t hmiFlag{0};
+hmi_data_t hmiData;
 
 enum SelectItem : uint8_t {
   PAGE_PRINT = 0,
   PAGE_PREPARE,
   PAGE_CONTROL,
   PAGE_ADVANCE,
   PAGE_COUNT,
 
   PRINT_SETUP = 0,
   PRINT_PAUSE_RESUME,
@@ -201,145 +201,145 @@ typedef struct {
   bool inc(uint8_t v) { if (now < (v - 1)) now++; else now = (v - 1); return changed(); }
 } select_t;
 select_t select_page{0}, select_print{0};
 
 #if ENABLED(LCD_BED_TRAMMING)
   constexpr float bed_tramming_inset_lfbr[] = BED_TRAMMING_INSET_LFRB;
 #endif
 
 bool hash_changed = true; // Flag to know if message status was changed
 bool blink = false;
-uint8_t checkkey = 255, last_checkkey = MainMenu;
+uint8_t checkkey = 255, last_checkkey = ID_MainMenu;
 
 // New menu system pointers
-MenuClass *FileMenu = nullptr;
-MenuClass *PrepareMenu = nullptr;
+Menu *fileMenu = nullptr;
+Menu *prepareMenu = nullptr;
 #if ENABLED(LCD_BED_TRAMMING)
-  MenuClass *TrammingMenu = nullptr;
+  Menu *trammingMenu = nullptr;
 #endif
-MenuClass *MoveMenu = nullptr;
-MenuClass *ControlMenu = nullptr;
-MenuClass *AdvancedSettings = nullptr;
+Menu *moveMenu = nullptr;
+Menu *ControlMenu = nullptr;
+Menu *AdvancedSettings = nullptr;
 #if HAS_HOME_OFFSET
-  MenuClass *HomeOffMenu = nullptr;
+  Menu *homeOffsetMenu = nullptr;
 #endif
 #if HAS_BED_PROBE
-  MenuClass *ProbeSetMenu = nullptr;
-#endif
-MenuClass *FilSetMenu = nullptr;
-MenuClass *SelectColorMenu = nullptr;
-MenuClass *GetColorMenu = nullptr;
-MenuClass *TuneMenu = nullptr;
-MenuClass *MotionMenu = nullptr;
-MenuClass *FilamentMenu = nullptr;
+  Menu *ProbeSetMenu = nullptr;
+#endif
+Menu *filSetMenu = nullptr;
+Menu *selectColorMenu = nullptr;
+Menu *getColorMenu = nullptr;
+Menu *tuneMenu = nullptr;
+Menu *motionMenu = nullptr;
+Menu *filamentMenu = nullptr;
 #if ENABLED(MESH_BED_LEVELING)
-  MenuClass *ManualMesh = nullptr;
+  Menu *manualMesh = nullptr;
 #endif
 #if HAS_PREHEAT
-  MenuClass *PreheatMenu = nullptr;
-  MenuClass *PreheatHotendMenu = nullptr;
+  Menu *preheatMenu = nullptr;
+  Menu *preheatHotendMenu = nullptr;
 #endif
-MenuClass *TemperatureMenu = nullptr;
-MenuClass *MaxSpeedMenu = nullptr;
-MenuClass *MaxAccelMenu = nullptr;
+Menu *temperatureMenu = nullptr;
+Menu *maxSpeedMenu = nullptr;
+Menu *maxAccelMenu = nullptr;
 #if HAS_CLASSIC_JERK
-  MenuClass *MaxJerkMenu = nullptr;
+  Menu *maxJerkMenu = nullptr;
 #endif
-MenuClass *StepsMenu = nullptr;
+Menu *stepsMenu = nullptr;
 #if ANY(MPC_EDIT_MENU, MPC_AUTOTUNE_MENU)
-  MenuClass *HotendMPCMenu = nullptr;
+  Menu *hotendMPCMenu = nullptr;
 #endif
 #if ENABLED(PIDTEMP) && ANY(PID_EDIT_MENU, PID_AUTOTUNE_MENU)
-  MenuClass *HotendPIDMenu = nullptr;
+  Menu *hotendPIDMenu = nullptr;
 #endif
 #if ENABLED(PIDTEMPBED) && ANY(PID_EDIT_MENU, PID_AUTOTUNE_MENU)
-  MenuClass *BedPIDMenu = nullptr;
+  Menu *bedPIDMenu = nullptr;
 #endif
 #if ENABLED(CASELIGHT_USES_BRIGHTNESS)
-  MenuClass *CaseLightMenu = nullptr;
+  Menu *caseLightMenu = nullptr;
 #endif
 #if ENABLED(LED_CONTROL_MENU)
-  MenuClass *LedControlMenu = nullptr;
+  Menu *ledControlMenu = nullptr;
 #endif
 #if HAS_BED_PROBE
-  MenuClass *ZOffsetWizMenu = nullptr;
+  Menu *zOffsetWizMenu = nullptr;
 #endif
 #if ENABLED(INDIVIDUAL_AXIS_HOMING_SUBMENU)
-  MenuClass *HomingMenu = nullptr;
+  Menu *homingMenu = nullptr;
 #endif
 #if ENABLED(FWRETRACT)
-  MenuClass *FWRetractMenu = nullptr;
+  Menu *fwRetractMenu = nullptr;
 #endif
 #if HAS_MESH
-  MenuClass *MeshMenu = nullptr;
+  Menu *meshMenu = nullptr;
   #if ENABLED(MESH_EDIT_MENU)
-    MenuClass *EditMeshMenu = nullptr;
+    Menu *editMeshMenu = nullptr;
   #endif
 #endif
 #if ENABLED(SHAPING_MENU)
-  MenuClass *InputShapingMenu = nullptr;
+  Menu *inputShapingMenu = nullptr;
 #endif
 #if HAS_TRINAMIC_CONFIG
-  MenuClass *TrinamicConfigMenu = nullptr;
+  Menu *trinamicConfigMenu = nullptr;
 #endif
 
 // Updatable menuitems pointers
-MenuItemClass *HotendTargetItem = nullptr;
-MenuItemClass *BedTargetItem = nullptr;
-MenuItemClass *FanSpeedItem = nullptr;
-MenuItemClass *MMeshMoveZItem = nullptr;
-MenuItemClass *EditZValueItem = nullptr;
+MenuItem *hotendTargetItem = nullptr;
+MenuItem *bedTargetItem = nullptr;
+MenuItem *fanSpeedItem = nullptr;
+MenuItem *mMeshMoveZItem = nullptr;
+MenuItem *editZValueItem = nullptr;
 
-bool Printing() { return printingIsActive() || printingIsPaused(); }
-bool SD_Printing() { return Printing() && IS_SD_FILE_OPEN(); }
-bool Host_Printing() { return Printing() && !IS_SD_FILE_OPEN(); }
+bool isPrinting() { return printingIsActive() || printingIsPaused(); }
+bool sdPrinting() { return isPrinting() && IS_SD_FILE_OPEN(); }
+bool Host_Printing() { return isPrinting() && !IS_SD_FILE_OPEN(); }
 
 #define DWIN_LANGUAGE_EEPROM_ADDRESS 0x01   // Between 0x01 and 0x63 (EEPROM_OFFSET-1)
                                             // BL24CXX::check() uses 0x00
 
-inline bool HMI_IsChinese() { return hmiFlag.language == DWIN_CHINESE; }
+inline bool hmiIsChinese() { return hmiFlag.language == DWIN_CHINESE; }
 
-void HMI_SetLanguageCache() {
-  dwinJPGCacheTo1(HMI_IsChinese() ? Language_Chinese : Language_English);
+void hmiSetLanguageCache() {
+  dwinJPGCacheTo1(hmiIsChinese() ? Language_Chinese : Language_English);
 }
 
-void HMI_SetLanguage() {
+void hmiSetLanguage() {
   #if ALL(EEPROM_SETTINGS, IIC_BL24CXX_EEPROM)
     BL24CXX::read(DWIN_LANGUAGE_EEPROM_ADDRESS, (uint8_t*)&hmiFlag.language, sizeof(hmiFlag.language));
   #endif
-  HMI_SetLanguageCache();
+  hmiSetLanguageCache();
 }
 
-void HMI_ToggleLanguage() {
-  hmiFlag.language = HMI_IsChinese() ? DWIN_ENGLISH : DWIN_CHINESE;
-  HMI_SetLanguageCache();
+void hmiToggleLanguage() {
+  hmiFlag.language = hmiIsChinese() ? DWIN_ENGLISH : DWIN_CHINESE;
+  hmiSetLanguageCache();
   #if ALL(EEPROM_SETTINGS, IIC_BL24CXX_EEPROM)
     BL24CXX::write(DWIN_LANGUAGE_EEPROM_ADDRESS, (uint8_t*)&hmiFlag.language, sizeof(hmiFlag.language));
   #endif
 }
 
 //-----------------------------------------------------------------------------
 // Main Buttons
 //-----------------------------------------------------------------------------
 
 typedef struct { uint16_t x, y[2], w, h; } text_info_t;
 
 void ICON_Button(const bool selected, const int iconid, const frame_rect_t &ico, const text_info_t (&txt), FSTR_P caption) {
-  DWINUI::Draw_IconWB(iconid + selected, ico.x, ico.y);
-  if (selected) DWINUI::Draw_Box(0, HMI_data.Highlight_Color, ico);
-  if (HMI_IsChinese()) {
-    DWIN_Frame_AreaCopy(1, txt.x, txt.y[selected], txt.x + txt.w - 1, txt.y[selected] + txt.h - 1, ico.x + (ico.w - txt.w) / 2, (ico.y + ico.h - 25) - txt.h/2);
+  DWINUI::drawIconWB(iconid + selected, ico.x, ico.y);
+  if (selected) DWINUI::drawBox(0, hmiData.colorHighlight, ico);
+  if (hmiIsChinese()) {
+    dwinFrameAreaCopy(1, txt.x, txt.y[selected], txt.x + txt.w - 1, txt.y[selected] + txt.h - 1, ico.x + (ico.w - txt.w) / 2, (ico.y + ico.h - 25) - txt.h/2);
   }
   else {
     const uint16_t x = ico.x + (ico.w - strlen_P(FTOP(caption)) * DWINUI::fontWidth()) / 2,
                    y = (ico.y + ico.h - 20) - DWINUI::fontHeight() / 2;
-    DWINUI::Draw_String(x, y, caption);
+    DWINUI::drawString(x, y, caption);
   }
 }
 
 //
 // Main Menu: "Print"
 //
 void ICON_Print() {
   constexpr frame_rect_t ico = { 17, 110, 110, 100 };
   constexpr text_info_t txt = { 1, { 405, TERN(USE_STOCK_DWIN_SET, 446, 447) }, 27, 15 };
   ICON_Button(select_page.now == PAGE_PRINT, ICON_Print_0, ico, txt, GET_TEXT_F(MSG_BUTTON_PRINT));
@@ -402,293 +402,293 @@ void ICON_Resume() {
 //
 // Printing: "Stop"
 //
 void ICON_Stop() {
   constexpr frame_rect_t ico = { 184, 232, 80, 100 };
   constexpr text_info_t txt = { 151, { 405, TERN(USE_STOCK_DWIN_SET, 446, 447) }, 27, 12 };
   ICON_Button(select_print.now == PRINT_STOP, ICON_Stop_0, ico, txt, GET_TEXT_F(MSG_BUTTON_STOP));
 }
 
 //
-//PopUps
+// PopUps
 //
-void Popup_window_PauseOrStop() {
-  if (HMI_IsChinese()) {
-    DWINUI::ClearMainArea();
-    Draw_Popup_Bkgd();
-         if (select_print.now == PRINT_PAUSE_RESUME) DWIN_Frame_AreaCopy(1, 237, 338, 269, 356, 98, 150);
-    else if (select_print.now == PRINT_STOP) DWIN_Frame_AreaCopy(1, 221, 320, 253, 336, 98, 150);
-    DWIN_Frame_AreaCopy(1, 220, 304, 264, 319, 130, 150);
-    DWINUI::Draw_IconWB(ICON_Confirm_C, 26, 280);
-    DWINUI::Draw_IconWB(ICON_Cancel_C, 146, 280);
-    Draw_Select_Highlight(true);
+void popupPauseOrStop() {
+  if (hmiIsChinese()) {
+    DWINUI::clearMainArea();
+    drawPopupBkgd();
+         if (select_print.now == PRINT_PAUSE_RESUME) dwinFrameAreaCopy(1, 237, 338, 269, 356, 98, 150);
+    else if (select_print.now == PRINT_STOP) dwinFrameAreaCopy(1, 221, 320, 253, 336, 98, 150);
+    dwinFrameAreaCopy(1, 220, 304, 264, 319, 130, 150);
+    DWINUI::drawIconWB(ICON_Confirm_C, 26, 280);
+    DWINUI::drawIconWB(ICON_Cancel_C, 146, 280);
+    drawSelectHighlight(true);
     dwinUpdateLCD();
   }
   else
-    DWIN_Popup_ConfirmCancel(ICON_BLTouch, select_print.now == PRINT_PAUSE_RESUME ? GET_TEXT_F(MSG_PAUSE_PRINT) : GET_TEXT_F(MSG_STOP_PRINT));
+    dwinPopupConfirmCancel(ICON_BLTouch, select_print.now == PRINT_PAUSE_RESUME ? GET_TEXT_F(MSG_PAUSE_PRINT) : GET_TEXT_F(MSG_STOP_PRINT));
 }
 
 #if HAS_HOTEND
 
-  void Popup_Window_ETempTooLow() {
-    if (HMI_IsChinese()) {
-      HMI_SaveProcessID(WaitResponse);
-      DWINUI::ClearMainArea();
-      Draw_Popup_Bkgd();
-      DWINUI::Draw_Icon(ICON_TempTooLow, 102, 105);
-      DWIN_Frame_AreaCopy(1, 103, 371, 136, 386,  69, 240);
-      DWIN_Frame_AreaCopy(1, 170, 371, 270, 386, 102, 240);
-      DWINUI::Draw_IconWB(ICON_Confirm_C, 86, 280);
+  void popupETempTooLow() {
+    if (hmiIsChinese()) {
+      hmiSaveProcessID(ID_WaitResponse);
+      DWINUI::clearMainArea();
+      drawPopupBkgd();
+      DWINUI::drawIcon(ICON_TempTooLow, 102, 105);
+      dwinFrameAreaCopy(1, 103, 371, 136, 386,  69, 240);
+      dwinFrameAreaCopy(1, 170, 371, 270, 386, 102, 240);
+      DWINUI::drawIconWB(ICON_Confirm_C, 86, 280);
       dwinUpdateLCD();
     }
     else
-      DWIN_Popup_Confirm(ICON_TempTooLow, GET_TEXT_F(MSG_HOTEND_TOO_COLD), GET_TEXT_F(MSG_PLEASE_PREHEAT));
+      dwinPopupConfirm(ICON_TempTooLow, GET_TEXT_F(MSG_HOTEND_TOO_COLD), GET_TEXT_F(MSG_PLEASE_PREHEAT));
   }
 
 #endif
 
 #if HAS_HOTEND || HAS_HEATED_BED
   void dwinPopupTemperature(const bool toohigh) {
-    HMI_SaveProcessID(WaitResponse);
-    if (HMI_IsChinese()) {
-      DWINUI::ClearMainArea();
-      Draw_Popup_Bkgd();
+    hmiSaveProcessID(ID_WaitResponse);
+    if (hmiIsChinese()) {
+      DWINUI::clearMainArea();
+      drawPopupBkgd();
       if (toohigh) {
-        DWINUI::Draw_Icon(ICON_TempTooHigh, 102, 165);
-        DWIN_Frame_AreaCopy(1, 103, 371, 237, 386, 52, 285);
-        DWIN_Frame_AreaCopy(1, 151, 389, 185, 402, 187, 285);
-        DWIN_Frame_AreaCopy(1, 189, 389, 271, 402, 95, 310);
+        DWINUI::drawIcon(ICON_TempTooHigh, 102, 165);
+        dwinFrameAreaCopy(1, 103, 371, 237, 386, 52, 285);
+        dwinFrameAreaCopy(1, 151, 389, 185, 402, 187, 285);
+        dwinFrameAreaCopy(1, 189, 389, 271, 402, 95, 310);
       }
       else {
-        DWINUI::Draw_Icon(ICON_TempTooLow, 102, 165);
-        DWIN_Frame_AreaCopy(1, 103, 371, 270, 386, 52, 285);
-        DWIN_Frame_AreaCopy(1, 189, 389, 271, 402, 95, 310);
+        DWINUI::drawIcon(ICON_TempTooLow, 102, 165);
+        dwinFrameAreaCopy(1, 103, 371, 270, 386, 52, 285);
+        dwinFrameAreaCopy(1, 189, 389, 271, 402, 95, 310);
       }
     }
     else
-      DWIN_Show_Popup(toohigh ? ICON_TempTooHigh : ICON_TempTooLow, F("Nozzle or Bed temperature"), toohigh ? F("is too high") : F("is too low"), BTN_Continue);
+      dwinShowPopup(toohigh ? ICON_TempTooHigh : ICON_TempTooLow, F("Nozzle or Bed temperature"), toohigh ? F("is too high") : F("is too low"), BTN_Continue);
   }
 #endif
 
 //
 // Draw status line
 //
-void DWIN_DrawStatusLine(const char *text) {
-  dwinDrawRectangle(1, HMI_data.StatusBg_Color, 0, STATUS_Y, DWIN_WIDTH, STATUS_Y + 20);
-  if (text) DWINUI::Draw_CenteredString(HMI_data.StatusTxt_Color, STATUS_Y + 2, text);
+void dwinDrawStatusLine(const char *text) {
+  dwinDrawRectangle(1, hmiData.colorStatusBg, 0, STATUS_Y, DWIN_WIDTH, STATUS_Y + 20);
+  if (text) DWINUI::drawCenteredString(hmiData.colorStatusTxt, STATUS_Y + 2, text);
 }
-void DWIN_DrawStatusLine(FSTR_P fstr) { DWIN_DrawStatusLine(FTOP(fstr)); }
+void dwinDrawStatusLine(FSTR_P fstr) { dwinDrawStatusLine(FTOP(fstr)); }
 
 // Clear & reset status line
-void DWIN_ResetStatusLine() {
+void dwinResetStatusLine() {
   ui.status_message.clear();
-  DWIN_CheckStatusMessage();
+  dwinCheckStatusMessage();
 }
 
 // Djb2 hash algorithm
-uint32_t GetHash(char * str) {
+uint32_t getHash(char * str) {
   uint32_t hash = 5381;
   char c;
   while ((c = *str++)) hash = ((hash << 5) + hash) + c; /* hash * 33 + c */
   return hash;
 }
 
 // Check for a change in the status message
-void DWIN_CheckStatusMessage() {
+void dwinCheckStatusMessage() {
   static MString<>::hash_t old_hash = 0x0000;
   const MString<>::hash_t hash = ui.status_message.hash();
   hash_changed = hash != old_hash;
   old_hash = hash;
 }
 
-void DWIN_DrawStatusMessage() {
+void dwinDrawStatusMessage() {
   #if ENABLED(STATUS_MESSAGE_SCROLLING)
 
     // Get the UTF8 character count of the string
     uint8_t slen = ui.status_message.glyphs();
 
     // If the string fits the status line do not scroll it
     if (slen <= LCD_WIDTH) {
       if (hash_changed) {
-        DWIN_DrawStatusLine(ui.status_message);
+        dwinDrawStatusLine(ui.status_message);
         hash_changed = false;
       }
     }
     else {
       // String is larger than the available line space
 
       // Get a pointer to the next valid UTF8 character
       // and the string remaining length
       uint8_t rlen;
       const char *stat = MarlinUI::status_and_len(rlen);
-      dwinDrawRectangle(1, HMI_data.StatusBg_Color, 0, STATUS_Y, DWIN_WIDTH, STATUS_Y + 20);
-      DWINUI::MoveTo(0, STATUS_Y + 2);
-      DWINUI::Draw_String(HMI_data.StatusTxt_Color, stat, LCD_WIDTH);
+      dwinDrawRectangle(1, hmiData.colorStatusBg, 0, STATUS_Y, DWIN_WIDTH, STATUS_Y + 20);
+      DWINUI::moveTo(0, STATUS_Y + 2);
+      DWINUI::drawString(hmiData.colorStatusTxt, stat, LCD_WIDTH);
 
       // If the string doesn't completely fill the line...
       if (rlen < LCD_WIDTH) {
-        DWINUI::Draw_Char(HMI_data.StatusTxt_Color, '.');  // Always at 1+ spaces left, draw a dot
+        DWINUI::drawChar(hmiData.colorStatusTxt, '.');  // Always at 1+ spaces left, draw a dot
         uint8_t chars = LCD_WIDTH - rlen;                  // Amount of space left in characters
         if (--chars) {                                     // Draw a second dot if there's space
-          DWINUI::Draw_Char(HMI_data.StatusTxt_Color, '.');
+          DWINUI::drawChar(hmiData.colorStatusTxt, '.');
           if (--chars)
-            DWINUI::Draw_String(HMI_data.StatusTxt_Color, ui.status_message, chars); // Print a second copy of the message
+            DWINUI::drawString(hmiData.colorStatusTxt, ui.status_message, chars); // Print a second copy of the message
         }
       }
       MarlinUI::advance_status_scroll();
     }
 
   #else
 
     if (hash_changed) {
       ui.status_message.trunc(LCD_WIDTH);
-      DWIN_DrawStatusLine(ui.status_message);
+      dwinDrawStatusLine(ui.status_message);
       hash_changed = false;
     }
 
   #endif
 }
 
-void Draw_Print_Labels() {
-  if (HMI_IsChinese()) {
-    DWIN_Frame_AreaCopy(1,  0, 72,  63, 86,  41, 173);  // Printing Time
-    DWIN_Frame_AreaCopy(1, 65, 72, 128, 86, 176, 173);  // Remain
+void drawPrintLabels() {
+  if (hmiIsChinese()) {
+    dwinFrameAreaCopy(1,  0, 72,  63, 86,  41, 173);  // Printing Time
+    dwinFrameAreaCopy(1, 65, 72, 128, 86, 176, 173);  // Remain
   }
   else {
-    DWINUI::Draw_String( 46, 173, GET_TEXT_F(MSG_INFO_PRINT_TIME));
-    DWINUI::Draw_String(181, 173, GET_TEXT_F(MSG_REMAINING_TIME));
+    DWINUI::drawString( 46, 173, GET_TEXT_F(MSG_INFO_PRINT_TIME));
+    DWINUI::drawString(181, 173, GET_TEXT_F(MSG_REMAINING_TIME));
   }
 }
 
-void Draw_Print_ProgressBar() {
+void drawPrintProgressBar() {
   const uint8_t _percent_done = ui.get_progress_percent();
-  DWINUI::Draw_IconWB(ICON_Bar, 15, 93);
-  dwinDrawRectangle(1, HMI_data.Barfill_Color, 16 + _percent_done * 240 / 100, 93, 256, 113);
-  DWINUI::Draw_Int(HMI_data.PercentTxt_Color, HMI_data.Background_Color, 3, 117, 133, _percent_done);
-  DWINUI::Draw_String(HMI_data.PercentTxt_Color, 142, 133, F("%"));
+  DWINUI::drawIconWB(ICON_Bar, 15, 93);
+  dwinDrawRectangle(1, hmiData.colorBarfill, 16 + _percent_done * 240 / 100, 93, 256, 113);
+  DWINUI::drawInt(hmiData.colorPercentTxt, hmiData.colorBackground, 3, 117, 133, _percent_done);
+  DWINUI::drawString(hmiData.colorPercentTxt, 142, 133, F("%"));
 }
 
-void Draw_Print_ProgressElapsed() {
+void drawPrintProgressElapsed() {
   MString<12> buf;
   duration_t elapsed = print_job_timer.duration(); // Print timer
   buf.setf(F("%02i:%02i "), uint16_t(elapsed.value / 3600), (uint16_t(elapsed.value) % 3600) / 60);
-  DWINUI::Draw_String(HMI_data.Text_Color, HMI_data.Background_Color, 47, 192, buf);
+  DWINUI::drawString(hmiData.colorText, hmiData.colorBackground, 47, 192, buf);
 }
 
 #if ENABLED(SHOW_REMAINING_TIME)
-  void Draw_Print_ProgressRemain() {
+  void drawPrintProgressRemain() {
     MString<12> buf;
     buf.setf(F("%02i:%02i "), _remain_time / 3600, (_remain_time % 3600) / 60);
-    DWINUI::Draw_String(HMI_data.Text_Color, HMI_data.Background_Color, 181, 192, buf);
+    DWINUI::drawString(hmiData.colorText, hmiData.colorBackground, 181, 192, buf);
   }
 #endif
 
 void ICON_ResumeOrPause() {
-  if (checkkey == PrintProcess) (print_job_timer.isPaused() || hmiFlag.pause_flag) ? ICON_Resume() : ICON_Pause();
+  if (checkkey == ID_PrintProcess) (print_job_timer.isPaused() || hmiFlag.pause_flag) ? ICON_Resume() : ICON_Pause();
 }
 
 // Update filename on print
-void DWIN_Print_Header(const char *text = nullptr) {
+void dwinPrintHeader(const char *text = nullptr) {
   static char headertxt[31] = "";  // Print header text
   if (text) {
     const int8_t size = _MIN(30U, strlen_P(text));
     for (uint8_t i = 0; i < size; ++i) headertxt[i] = text[i];
     headertxt[size] = '\0';
   }
-  if (checkkey == PrintProcess || checkkey == PrintDone) {
-    dwinDrawRectangle(1, HMI_data.Background_Color, 0, 60, DWIN_WIDTH, 60+16);
-    DWINUI::Draw_CenteredString(60, headertxt);
+  if (checkkey == ID_PrintProcess || checkkey == ID_PrintDone) {
+    dwinDrawRectangle(1, hmiData.colorBackground, 0, 60, DWIN_WIDTH, 60+16);
+    DWINUI::drawCenteredString(60, headertxt);
   }
 }
 
-void Draw_PrintProcess() {
-  if (HMI_IsChinese())
-    Title.FrameCopy(30, 1, 42, 14);                     // "Printing"
+void drawPrintProcess() {
+  if (hmiIsChinese())
+    title.frameCopy(30, 1, 42, 14);                     // "Printing"
   else
-    Title.ShowCaption(GET_TEXT_F(MSG_PRINTING));
-  DWINUI::ClearMainArea();
-  DWIN_Print_Header(nullptr);
-  Draw_Print_Labels();
-  DWINUI::Draw_Icon(ICON_PrintTime, 15, 173);
-  DWINUI::Draw_Icon(ICON_RemainTime, 150, 171);
-  Draw_Print_ProgressBar();
-  Draw_Print_ProgressElapsed();
-  TERN_(SHOW_REMAINING_TIME, Draw_Print_ProgressRemain());
+    title.showCaption(GET_TEXT_F(MSG_PRINTING));
+  DWINUI::clearMainArea();
+  dwinPrintHeader(nullptr);
+  drawPrintLabels();
+  DWINUI::drawIcon(ICON_PrintTime, 15, 173);
+  DWINUI::drawIcon(ICON_RemainTime, 150, 171);
+  drawPrintProgressBar();
+  drawPrintProgressElapsed();
+  TERN_(SHOW_REMAINING_TIME, drawPrintProgressRemain());
   ICON_Tune();
   ICON_ResumeOrPause();
   ICON_Stop();
 }
 
-void Goto_PrintProcess() {
-  if (checkkey == PrintProcess)
+void gotoPrintProcess() {
+  if (checkkey == ID_PrintProcess)
     ICON_ResumeOrPause();
   else {
-    checkkey = PrintProcess;
-    Draw_PrintProcess();
-    TERN_(DASH_REDRAW, DWIN_RedrawDash());
+    checkkey = ID_PrintProcess;
+    drawPrintProcess();
+    TERN_(DASH_REDRAW, dwinRedrawDash());
   }
   dwinUpdateLCD();
 }
 
-void Draw_PrintDone() {
+void drawPrintDone() {
   TERN_(SET_PROGRESS_PERCENT, ui.set_progress_done());
   TERN_(SET_REMAINING_TIME, ui.reset_remaining_time());
-  Title.ShowCaption(GET_TEXT_F(MSG_PRINT_DONE));
-  DWINUI::ClearMainArea();
-  DWIN_Print_Header(nullptr);
+  title.showCaption(GET_TEXT_F(MSG_PRINT_DONE));
+  DWINUI::clearMainArea();
+  dwinPrintHeader(nullptr);
   #if HAS_GCODE_PREVIEW
     const bool haspreview = Preview_Valid();
     if (haspreview) {
       Preview_Show();
-      DWINUI::Draw_Button(BTN_Continue, 86, 295);
+      DWINUI::drawButton(BTN_Continue, 86, 295);
     }
   #else
     constexpr bool haspreview = false;
   #endif
 
   if (!haspreview) {
-    Draw_Print_ProgressBar();
-    Draw_Print_Labels();
-    DWINUI::Draw_Icon(ICON_PrintTime, 15, 173);
-    DWINUI::Draw_Icon(ICON_RemainTime, 150, 171);
-    Draw_Print_ProgressElapsed();
-    TERN_(SHOW_REMAINING_TIME, Draw_Print_ProgressRemain());
-    DWINUI::Draw_Button(BTN_Continue, 86, 273);
+    drawPrintProgressBar();
+    drawPrintLabels();
+    DWINUI::drawIcon(ICON_PrintTime, 15, 173);
+    DWINUI::drawIcon(ICON_RemainTime, 150, 171);
+    drawPrintProgressElapsed();
+    TERN_(SHOW_REMAINING_TIME, drawPrintProgressRemain());
+    DWINUI::drawButton(BTN_Continue, 86, 273);
   }
 }
 
-void Goto_PrintDone() {
+void gotoPrintDone() {
   wait_for_user = true;
-  if (checkkey != PrintDone) {
-    checkkey = PrintDone;
-    Draw_PrintDone();
+  if (checkkey != ID_PrintDone) {
+    checkkey = ID_PrintDone;
+    drawPrintDone();
     dwinUpdateLCD();
   }
 }
 
-void Draw_Main_Menu() {
-  DWINUI::ClearMainArea();
-  if (HMI_IsChinese())
-    Title.FrameCopy(2, 2, 26, 13);   // "Home" etc
+void drawMainMenu() {
+  DWINUI::clearMainArea();
+  if (hmiIsChinese())
+    title.frameCopy(2, 2, 26, 13);   // "Home" etc
   else
-    Title.ShowCaption(MACHINE_NAME);
-  DWINUI::Draw_Icon(ICON_LOGO, 71, 52);  // CREALITY logo
+    title.showCaption(MACHINE_NAME);
+  DWINUI::drawIcon(ICON_LOGO, 71, 52);  // CREALITY logo
   ICON_Print();
   ICON_Prepare();
   ICON_Control();
   ICON_AdvSettings();
 }
 
-void Goto_Main_Menu() {
-  if (checkkey == MainMenu) return;
-  checkkey = MainMenu;
-  Draw_Main_Menu();
+void gotoMainMenu() {
+  if (checkkey == ID_MainMenu) return;
+  checkkey = ID_MainMenu;
+  drawMainMenu();
   dwinUpdateLCD();
 }
 
 // Draw X, Y, Z and blink if in an un-homed or un-trusted state
 void _update_axis_value(const AxisEnum axis, const uint16_t x, const uint16_t y, const bool force) {
   const bool draw_qmark = axis_should_home(axis),
              draw_empty = NONE(HOME_AFTER_DEACTIVATE, DISABLE_REDUCED_ACCURACY_WARNING) && !draw_qmark && !axis_is_trusted(axis);
 
   // Check for a position change
   static xyz_pos_t oldpos = { -1, -1, -1 };
@@ -699,88 +699,88 @@ void _update_axis_value(const AxisEnum axis, const uint16_t x, const uint16_t y,
     #else
       current_position[axis]
     #endif
   );
 
   const bool changed = oldpos[axis] != p;
   if (changed) oldpos[axis] = p;
 
   if (force || changed || draw_qmark || draw_empty) {
     if (blink && draw_qmark)
-      DWINUI::Draw_String(HMI_data.Coordinate_Color, HMI_data.Background_Color, x, y, F("  - ? -"));
+      DWINUI::drawString(hmiData.colorCoordinate, hmiData.colorBackground, x, y, F("  - ? -"));
     else if (blink && draw_empty)
-      DWINUI::Draw_String(HMI_data.Coordinate_Color, HMI_data.Background_Color, x, y, F("       "));
+      DWINUI::drawString(hmiData.colorCoordinate, hmiData.colorBackground, x, y, F("       "));
     else
-      DWINUI::Draw_Signed_Float(HMI_data.Coordinate_Color, HMI_data.Background_Color, 3, 2, x, y, p);
+      DWINUI::drawSignedFloat(hmiData.colorCoordinate, hmiData.colorBackground, 3, 2, x, y, p);
   }
 }
 
-void _draw_iconblink(bool &flag, const bool sensor, const uint8_t icon1, const uint8_t icon2, const uint16_t x, const uint16_t y) {
+void _drawIconBlink(bool &flag, const bool sensor, const uint8_t icon1, const uint8_t icon2, const uint16_t x, const uint16_t y) {
   #if DISABLED(NO_BLINK_IND)
     if (flag != sensor) {
       flag = sensor;
       if (!flag) {
-        dwinDrawBox(1, HMI_data.Background_Color, x, y, 20, 20);
-        DWINUI::Draw_Icon(icon1, x, y);
+        dwinDrawBox(1, hmiData.colorBackground, x, y, 20, 20);
+        DWINUI::drawIcon(icon1, x, y);
       }
     }
     if (flag) {
-      dwinDrawBox(1, blink ? HMI_data.SplitLine_Color : HMI_data.Background_Color, x, y, 20, 20);
-      DWINUI::Draw_Icon(icon2, x, y);
+      dwinDrawBox(1, blink ? hmiData.colorSplitLine : hmiData.colorBackground, x, y, 20, 20);
+      DWINUI::drawIcon(icon2, x, y);
     }
   #else
     if (flag != sensor) {
       flag = sensor;
-      dwinDrawBox(1, HMI_data.Background_Color, x, y, 20, 20);
-      DWINUI::Draw_Icon(flag ? icon2 : icon1, x, y);
+      dwinDrawBox(1, hmiData.colorBackground, x, y, 20, 20);
+      DWINUI::drawIcon(flag ? icon2 : icon1, x, y);
     }
   #endif
 }
 
-void _draw_ZOffsetIcon() {
+void _drawZOffsetIcon() {
   #if HAS_LEVELING
     static bool _leveling_active = false;
-    _draw_iconblink(_leveling_active, planner.leveling_active, ICON_Zoffset, ICON_SetZOffset, 186, 416);
+    _drawIconBlink(_leveling_active, planner.leveling_active, ICON_Zoffset, ICON_SetZOffset, 186, 416);
   #else
-    DWINUI::Draw_Icon(ICON_Zoffset, 187, 416);
+    DWINUI::drawIcon(ICON_Zoffset, 187, 416);
   #endif
 }
 
-void _draw_feedrate() {
+void _drawFeedrate() {
   #if ENABLED(SHOW_SPEED_IND)
     int16_t _value;
     if (blink) {
       _value = feedrate_percentage;
-      DWINUI::Draw_String(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 116 + 4 * STAT_CHR_W + 2, 384, F(" %"));
+      DWINUI::drawString(DWIN_FONT_STAT, hmiData.colorIndicator, hmiData.colorBackground, 116 + 4 * STAT_CHR_W + 2, 384, F(" %"));
     }
     else {
       _value = CEIL(feedrate_mm_s * feedrate_percentage / 100);
-      dwinDrawBox(1, HMI_data.Background_Color, 116 + 5 * STAT_CHR_W + 2, 384, 20, 20);
+      dwinDrawBox(1, hmiData.colorBackground, 116 + 5 * STAT_CHR_W + 2, 384, 20, 20);
     }
-    DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 116 + 2 * STAT_CHR_W, 384, _value);
+    DWINUI::drawInt(DWIN_FONT_STAT, hmiData.colorIndicator, hmiData.colorBackground, 3, 116 + 2 * STAT_CHR_W, 384, _value);
   #else
     static int16_t _feedrate = 100;
     if (_feedrate != feedrate_percentage) {
       _feedrate = feedrate_percentage;
-      DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 116 + 2 * STAT_CHR_W, 384, _feedrate);
+      DWINUI::drawInt(DWIN_FONT_STAT, hmiData.colorIndicator, hmiData.colorBackground, 3, 116 + 2 * STAT_CHR_W, 384, _feedrate);
     }
   #endif
 }
 
-void _draw_xyz_position(const bool force) {
+void _drawXYZPosition(const bool force) {
   _update_axis_value(X_AXIS,  27, 459, force);
   _update_axis_value(Y_AXIS, 112, 459, force);
   _update_axis_value(Z_AXIS, 197, 459, force);
 }
 
-void update_variable() {
-  _draw_xyz_position(false);
+void updateVariable() {
+  _drawXYZPosition(false);
   #if HAS_HOTEND
     static celsius_t _hotendtemp = 0, _hotendtarget = 0;
     const celsius_t hc = thermalManager.wholeDegHotend(0),
                     ht = thermalManager.degTargetHotend(0);
     const bool _new_hotend_temp = _hotendtemp != hc,
                _new_hotend_target = _hotendtarget != ht;
     if (_new_hotend_temp) _hotendtemp = hc;
     if (_new_hotend_target) _hotendtarget = ht;
   #endif
   #if HAS_HEATED_BED
@@ -791,85 +791,85 @@ void update_variable() {
                _new_bed_target = _bedtarget != bt;
     if (_new_bed_temp) _bedtemp = bc;
     if (_new_bed_target) _bedtarget = bt;
   #endif
   #if HAS_FAN
     static uint8_t _fanspeed = 0;
     const bool _new_fanspeed = _fanspeed != thermalManager.fan_speed[0];
     if (_new_fanspeed) _fanspeed = thermalManager.fan_speed[0];
   #endif
 
-  if (IsMenu(TuneMenu) || IsMenu(TemperatureMenu)) {
+  if (isMenu(tuneMenu) || isMenu(temperatureMenu)) {
     // Tune page temperature update
-    TERN_(HAS_HOTEND, if (_new_hotend_target) HotendTargetItem->redraw());
-    TERN_(HAS_HEATED_BED, if (_new_bed_target) BedTargetItem->redraw());
-    TERN_(HAS_FAN, if (_new_fanspeed) FanSpeedItem->redraw());
+    TERN_(HAS_HOTEND, if (_new_hotend_target) hotendTargetItem->redraw());
+    TERN_(HAS_HEATED_BED, if (_new_bed_target) bedTargetItem->redraw());
+    TERN_(HAS_FAN, if (_new_fanspeed) fanSpeedItem->redraw());
   }
 
   // Bottom temperature update
 
   #if HAS_HOTEND
     if (_new_hotend_temp)
-      DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 28, 384, _hotendtemp);
+      DWINUI::drawInt(DWIN_FONT_STAT, hmiData.colorIndicator, hmiData.colorBackground, 3, 28, 384, _hotendtemp);
     if (_new_hotend_target)
-      DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 25 + 4 * STAT_CHR_W + 6, 384, _hotendtarget);
+      DWINUI::drawInt(DWIN_FONT_STAT, hmiData.colorIndicator, hmiData.colorBackground, 3, 25 + 4 * STAT_CHR_W + 6, 384, _hotendtarget);
 
     static int16_t _flow = planner.flow_percentage[0];
     if (_flow != planner.flow_percentage[0]) {
       _flow = planner.flow_percentage[0];
-      DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 116 + 2 * STAT_CHR_W, 417, _flow);
+      DWINUI::drawInt(DWIN_FONT_STAT, hmiData.colorIndicator, hmiData.colorBackground, 3, 116 + 2 * STAT_CHR_W, 417, _flow);
     }
   #endif
 
   #if HAS_HEATED_BED
     if (_new_bed_temp)
-      DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 28, 417, _bedtemp);
+      DWINUI::drawInt(DWIN_FONT_STAT, hmiData.colorIndicator, hmiData.colorBackground, 3, 28, 417, _bedtemp);
     if (_new_bed_target)
-      DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 25 + 4 * STAT_CHR_W + 6, 417, _bedtarget);
+      DWINUI::drawInt(DWIN_FONT_STAT, hmiData.colorIndicator, hmiData.colorBackground, 3, 25 + 4 * STAT_CHR_W + 6, 417, _bedtarget);
   #endif
 
-  _draw_feedrate();
+  _drawFeedrate();
 
   #if HAS_FAN
     if (_new_fanspeed)
-      DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 195 + 2 * STAT_CHR_W, 384, _fanspeed);
+      DWINUI::drawInt(DWIN_FONT_STAT, hmiData.colorIndicator, hmiData.colorBackground, 3, 195 + 2 * STAT_CHR_W, 384, _fanspeed);
   #endif
 
   static float _offset = 0;
   if (BABY_Z_VAR != _offset) {
     _offset = BABY_Z_VAR;
-    DWINUI::Draw_Signed_Float(DWIN_FONT_STAT, HMI_data.Indicator_Color,  HMI_data.Background_Color, 2, 2, 204, 417, _offset);
+    DWINUI::drawSignedFloat(DWIN_FONT_STAT, hmiData.colorIndicator,  hmiData.colorBackground, 2, 2, 204, 417, _offset);
   }
 
-  _draw_ZOffsetIcon();
+  _drawZOffsetIcon();
 }
 
 /**
  * Memory card and file management
  */
 
 bool DWIN_lcd_sd_status = false;
 
 #if ENABLED(MEDIASORT_MENU_ITEM)
-  void SetMediaSort() {
-    Toggle_Chkb_Line(HMI_data.MediaSort);
-    card.setSortOn(HMI_data.MediaSort);
+  void setMediaSort() {
+    toggleCheckboxLine(hmiData.mediaSort);
+    card.setSortOn(hmiData.mediaSort);
   }
 #endif
 
-void SetMediaAutoMount() { Toggle_Chkb_Line(HMI_data.MediaAutoMount); }
+void setMediaAutoMount() { toggleCheckboxLine(hmiData.mediaAutoMount); }
 
 inline uint16_t nr_sd_menu_items() {
   return _MIN(card.get_num_items() + !card.flag.workDirIsRoot, MENU_MAX_ITEMS);
 }
 
-void make_name_without_ext(char *dst, char *src, size_t maxlen=MENU_CHAR_LIMIT) {
+void makeNameWithoutExt(char *dst, char *src, size_t maxlen=MENU_CHAR_LIMIT) {
   size_t pos = strlen(src);  // Index of ending nul
 
   // For files, remove the extension
   // which may be .gcode, .gco, or .g
   if (!card.flag.filenameIsDir)
     while (pos && src[pos] != '.') pos--; // Find last '.' (stop at 0)
 
   if (!pos) pos = strlen(src);  // pos = 0 ('.' not found) restore pos
 
   size_t len = pos;   // nul or '.'
@@ -879,227 +879,231 @@ void make_name_without_ext(char *dst, char *src, size_t maxlen=MENU_CHAR_LIMIT)
     dst[--pos] = '.';
     dst[--pos] = '.';
   }
 
   dst[len] = '\0';    // End it
 
   // Copy down to 0
   while (pos--) dst[pos] = src[pos];
 }
 
-void SDCard_Up() {
+void sdCardUp() {
   card.cdup();
   DWIN_lcd_sd_status = false; // On next DWIN_Update
 }
 
-void SDCard_Folder(char * const dirname) {
+void sdCardFolder(char * const dirname) {
   card.cd(dirname);
   DWIN_lcd_sd_status = false; // On next DWIN_Update
 }
 
 void onClickSDItem() {
   const uint16_t hasUpDir = !card.flag.workDirIsRoot;
-  if (hasUpDir && CurrentMenu->selected == 1) return SDCard_Up();
+  if (hasUpDir && currentMenu->selected == 1) return sdCardUp();
   else {
-    const uint16_t filenum = CurrentMenu->selected - 1 - hasUpDir;
+    const uint16_t filenum = currentMenu->selected - 1 - hasUpDir;
     card.selectFileByIndexSorted(filenum);
 
     // Enter that folder!
-    if (card.flag.filenameIsDir) return SDCard_Folder(card.filename);
+    if (card.flag.filenameIsDir) return sdCardFolder(card.filename);
 
     if (card.fileIsBinary())
-      return DWIN_Popup_Confirm(ICON_Error, F("Please check filenames"), F("Only G-code can be printed"));
+      return dwinPopupConfirm(ICON_Error, F("Please check filenames"), F("Only G-code can be printed"));
     else {
-      DWIN_Print_Header(card.longest_filename()); // Save filename
-      return Goto_ConfirmToPrint();
+      dwinPrintHeader(card.longest_filename()); // Save filename
+      return gotoConfirmToPrint();
     }
   }
 }
 
 #if ENABLED(SCROLL_LONG_FILENAMES)
+
   char shift_name[LONG_FILENAME_LENGTH + 1] = "";
 
-  void Draw_SDItem_Shifted(uint8_t &shift) {
+  void drawSDItemShifted(uint8_t &shift) {
     // Shorten to the available space
     const size_t lastchar = shift + MENU_CHAR_LIMIT;
     const char c = shift_name[lastchar];
     shift_name[lastchar] = '\0';
 
-    const uint8_t row = FileMenu->line();
-    Erase_Menu_Text(row);
-    Draw_Menu_Line(row, 0, &shift_name[shift]);
+    const uint8_t row = fileMenu->line();
+    eraseMenuText(row);
+    drawMenuLine(row, 0, &shift_name[shift]);
 
     shift_name[lastchar] = c;
   }
 
-  void FileMenuIdle(bool reset=false) {
+  void fileMenuIdle(bool reset=false) {
     static bool hasUpDir = false;
     static uint8_t last_itemselected = 0;
     static int8_t shift_amt = 0, shift_len = 0;
     if (reset) {
       last_itemselected = 0;
       hasUpDir = !card.flag.workDirIsRoot; // Is a SubDir
       return;
     }
-    const uint8_t selected = FileMenu->selected;
+    const uint8_t selected = fileMenu->selected;
     if (last_itemselected != selected) {
-      if (last_itemselected >= 1 + hasUpDir) FileMenu->Items()[last_itemselected]->redraw(true);
+      if (last_itemselected >= 1 + hasUpDir) fileMenu->items()[last_itemselected]->redraw(true);
       last_itemselected = selected;
       if (selected >= 1 + hasUpDir) {
         const int8_t filenum = selected - 1 - hasUpDir; // Skip "Back" and ".."
         card.selectFileByIndexSorted(filenum);
-        make_name_without_ext(shift_name, card.longest_filename(), LONG_FILENAME_LENGTH);
+        makeNameWithoutExt(shift_name, card.longest_filename(), LONG_FILENAME_LENGTH);
         shift_len = strlen(shift_name);
         shift_amt = 0;
       }
     }
     else if ((selected >= 1 + hasUpDir) && (shift_len > MENU_CHAR_LIMIT)) {
       uint8_t shift_new = _MIN(shift_amt + 1, shift_len - MENU_CHAR_LIMIT); // Try to shift by...
-      Draw_SDItem_Shifted(shift_new);             // Draw the item
+      drawSDItemShifted(shift_new);             // Draw the item
       if (shift_new == shift_amt)                 // Scroll reached the end
         shift_new = -1;                           // Reset
       shift_amt = shift_new;                      // Set new scroll
     }
   }
-#else
+
+#else // !SCROLL_LONG_FILENAMES
+
   char shift_name[FILENAME_LENGTH + 1] = "";
+
 #endif
 
-void onDrawFileName(MenuItemClass* menuitem, int8_t line) {
+void onDrawFileName(MenuItem* menuitem, int8_t line) {
   const bool is_subdir = !card.flag.workDirIsRoot;
   if (is_subdir && menuitem->pos == 1) {
-    Draw_Menu_Line(line, ICON_Folder, "..");
+    drawMenuLine(line, ICON_Folder, "..");
   }
   else {
     uint8_t icon;
     card.selectFileByIndexSorted(menuitem->pos - is_subdir - 1);
-    make_name_without_ext(shift_name, card.longest_filename());
+    makeNameWithoutExt(shift_name, card.longest_filename());
     icon = card.flag.filenameIsDir ? ICON_Folder : card.fileIsBinary() ? ICON_Binary : ICON_File;
-    Draw_Menu_Line(line, icon, shift_name);
+    drawMenuLine(line, icon, shift_name);
   }
 }
 
-void Draw_Print_File_Menu() {
-  checkkey = Menu;
+void drawPrintFileMenu() {
+  checkkey = ID_Menu;
   if (card.isMounted()) {
-    if (SET_MENU(FileMenu, MSG_MEDIA_MENU, nr_sd_menu_items() + 1)) {
-      BACK_ITEM(Goto_Main_Menu);
+    if (SET_MENU(fileMenu, MSG_MEDIA_MENU, nr_sd_menu_items() + 1)) {
+      BACK_ITEM(gotoMainMenu);
       for (uint8_t i = 0; i < nr_sd_menu_items(); ++i) {
-        MenuItemAdd(onDrawFileName, onClickSDItem);
+        menuItemAdd(onDrawFileName, onClickSDItem);
       }
     }
-    UpdateMenu(FileMenu);
-    TERN_(DASH_REDRAW, DWIN_RedrawDash());
+    updateMenu(fileMenu);
+    TERN_(DASH_REDRAW, dwinRedrawDash());
   }
   else {
-    if (SET_MENU(FileMenu, MSG_MEDIA_MENU, 1)) BACK_ITEM(Goto_Main_Menu);
-    UpdateMenu(FileMenu);
-    dwinDrawRectangle(1, HMI_data.AlertBg_Color, 10, MBASE(3) - 10, DWIN_WIDTH - 10, MBASE(4));
-    DWINUI::Draw_CenteredString(font12x24, HMI_data.AlertTxt_Color, MBASE(3), GET_TEXT_F(MSG_MEDIA_NOT_INSERTED));
+    if (SET_MENU(fileMenu, MSG_MEDIA_MENU, 1)) BACK_ITEM(gotoMainMenu);
+    updateMenu(fileMenu);
+    dwinDrawRectangle(1, hmiData.colorAlertBg, 10, MBASE(3) - 10, DWIN_WIDTH - 10, MBASE(4));
+    DWINUI::drawCenteredString(font12x24, hmiData.colorAlertTxt, MBASE(3), GET_TEXT_F(MSG_MEDIA_NOT_INSERTED));
   }
-  TERN_(SCROLL_LONG_FILENAMES, FileMenuIdle(true));
+  TERN_(SCROLL_LONG_FILENAMES, fileMenuIdle(true));
 }
 
 //
 // Watch for media mount / unmount
 //
-void HMI_SDCardUpdate() {
+void hmiSDCardUpdate() {
   if (hmiFlag.home_flag) return;
   if (DWIN_lcd_sd_status != card.isMounted()) {
     DWIN_lcd_sd_status = card.isMounted();
-    ResetMenu(FileMenu);
-    if (IsMenu(FileMenu)) {
-      CurrentMenu = nullptr;
-      Draw_Print_File_Menu();
+    resetMenu(fileMenu);
+    if (isMenu(fileMenu)) {
+      currentMenu = nullptr;
+      drawPrintFileMenu();
     }
-    if (!DWIN_lcd_sd_status && SD_Printing()) ui.abort_print();  // Media removed while printing
+    if (!DWIN_lcd_sd_status && sdPrinting()) ui.abort_print();  // Media removed while printing
   }
 }
 
 /**
  * Dash board and indicators
  */
 
-void DWIN_Draw_Dashboard() {
+void dwinDrawDashboard() {
 
-  dwinDrawRectangle(1, HMI_data.Background_Color, 0, STATUS_Y + 21, DWIN_WIDTH, DWIN_HEIGHT - 1);
-  dwinDrawRectangle(1, HMI_data.SplitLine_Color, 0, 449, DWIN_WIDTH, 451);
+  dwinDrawRectangle(1, hmiData.colorBackground, 0, STATUS_Y + 21, DWIN_WIDTH, DWIN_HEIGHT - 1);
+  dwinDrawRectangle(1, hmiData.colorSplitLine, 0, 449, DWIN_WIDTH, 451);
 
-  DWINUI::Draw_Icon(ICON_MaxSpeedX,  10, 456);
-  DWINUI::Draw_Icon(ICON_MaxSpeedY,  95, 456);
-  DWINUI::Draw_Icon(ICON_MaxSpeedZ, 180, 456);
-  _draw_xyz_position(true);
+  DWINUI::drawIcon(ICON_MaxSpeedX,  10, 456);
+  DWINUI::drawIcon(ICON_MaxSpeedY,  95, 456);
+  DWINUI::drawIcon(ICON_MaxSpeedZ, 180, 456);
+  _drawXYZPosition(true);
 
   #if HAS_HOTEND
-    DWINUI::Draw_Icon(ICON_HotendTemp, 10, 383);
-    DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 28, 384, thermalManager.wholeDegHotend(0));
-    DWINUI::Draw_String(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 25 + 3 * STAT_CHR_W + 5, 384, F("/"));
-    DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 25 + 4 * STAT_CHR_W + 6, 384, thermalManager.degTargetHotend(0));
+    DWINUI::drawIcon(ICON_HotendTemp, 10, 383);
+    DWINUI::drawInt(DWIN_FONT_STAT, hmiData.colorIndicator, hmiData.colorBackground, 3, 28, 384, thermalManager.wholeDegHotend(0));
+    DWINUI::drawString(DWIN_FONT_STAT, hmiData.colorIndicator, hmiData.colorBackground, 25 + 3 * STAT_CHR_W + 5, 384, F("/"));
+    DWINUI::drawInt(DWIN_FONT_STAT, hmiData.colorIndicator, hmiData.colorBackground, 3, 25 + 4 * STAT_CHR_W + 6, 384, thermalManager.degTargetHotend(0));
 
-    DWINUI::Draw_Icon(ICON_StepE, 112, 417);
-    DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 116 + 2 * STAT_CHR_W, 417, planner.flow_percentage[0]);
-    DWINUI::Draw_String(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 116 + 5 * STAT_CHR_W + 2, 417, F("%"));
+    DWINUI::drawIcon(ICON_StepE, 112, 417);
+    DWINUI::drawInt(DWIN_FONT_STAT, hmiData.colorIndicator, hmiData.colorBackground, 3, 116 + 2 * STAT_CHR_W, 417, planner.flow_percentage[0]);
+    DWINUI::drawString(DWIN_FONT_STAT, hmiData.colorIndicator, hmiData.colorBackground, 116 + 5 * STAT_CHR_W + 2, 417, F("%"));
   #endif
 
   #if HAS_HEATED_BED
-    DWINUI::Draw_Icon(ICON_BedTemp, 10, 416);
-    DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 28, 417, thermalManager.wholeDegBed());
-    DWINUI::Draw_String(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 25 + 3 * STAT_CHR_W + 5, 417, F("/"));
-    DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 25 + 4 * STAT_CHR_W + 6, 417, thermalManager.degTargetBed());
+    DWINUI::drawIcon(ICON_BedTemp, 10, 416);
+    DWINUI::drawInt(DWIN_FONT_STAT, hmiData.colorIndicator, hmiData.colorBackground, 3, 28, 417, thermalManager.wholeDegBed());
+    DWINUI::drawString(DWIN_FONT_STAT, hmiData.colorIndicator, hmiData.colorBackground, 25 + 3 * STAT_CHR_W + 5, 417, F("/"));
+    DWINUI::drawInt(DWIN_FONT_STAT, hmiData.colorIndicator, hmiData.colorBackground, 3, 25 + 4 * STAT_CHR_W + 6, 417, thermalManager.degTargetBed());
   #endif
 
-  DWINUI::Draw_Icon(ICON_Speed, 113, 383);
-  DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 116 + 2 * STAT_CHR_W, 384, feedrate_percentage);
-  IF_DISABLED(SHOW_SPEED_IND, DWINUI::Draw_String(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 116 + 5 * STAT_CHR_W + 2, 384, F("%")));
+  DWINUI::drawIcon(ICON_Speed, 113, 383);
+  DWINUI::drawInt(DWIN_FONT_STAT, hmiData.colorIndicator, hmiData.colorBackground, 3, 116 + 2 * STAT_CHR_W, 384, feedrate_percentage);
+  IF_DISABLED(SHOW_SPEED_IND, DWINUI::drawString(DWIN_FONT_STAT, hmiData.colorIndicator, hmiData.colorBackground, 116 + 5 * STAT_CHR_W + 2, 384, F("%")));
 
   #if HAS_FAN
-    DWINUI::Draw_Icon(ICON_FanSpeed, 187, 383);
-    DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 195 + 2 * STAT_CHR_W, 384, thermalManager.fan_speed[0]);
+    DWINUI::drawIcon(ICON_FanSpeed, 187, 383);
+    DWINUI::drawInt(DWIN_FONT_STAT, hmiData.colorIndicator, hmiData.colorBackground, 3, 195 + 2 * STAT_CHR_W, 384, thermalManager.fan_speed[0]);
   #endif
 
   #if HAS_ZOFFSET_ITEM
-    DWINUI::Draw_Icon(planner.leveling_active ? ICON_SetZOffset : ICON_Zoffset, 187, 416);
-    DWINUI::Draw_Signed_Float(DWIN_FONT_STAT, HMI_data.Indicator_Color,  HMI_data.Background_Color, 2, 2, 204, 417, BABY_Z_VAR);
+    DWINUI::drawIcon(planner.leveling_active ? ICON_SetZOffset : ICON_Zoffset, 187, 416);
+    DWINUI::drawSignedFloat(DWIN_FONT_STAT, hmiData.colorIndicator,  hmiData.colorBackground, 2, 2, 204, 417, BABY_Z_VAR);
   #endif
 }
 
-void Draw_Info_Menu() {
-  DWINUI::ClearMainArea();
-  if (HMI_IsChinese())
-    Title.FrameCopy(30, 17, 28, 13);                        // "Info"
+void drawInfoMenu() {
+  DWINUI::clearMainArea();
+  if (hmiIsChinese())
+    title.frameCopy(30, 17, 28, 13);                        // "Info"
   else
-    Title.ShowCaption(GET_TEXT_F(MSG_INFO_SCREEN));
-  Draw_Menu_Line(0, ICON_Back, GET_TEXT_F(MSG_BACK), false, true);
+    title.showCaption(GET_TEXT_F(MSG_INFO_SCREEN));
+  drawMenuLine(0, ICON_Back, GET_TEXT_F(MSG_BACK), false, true);
 
-  if (HMI_IsChinese()) {
-    DWIN_Frame_AreaCopy(1, 197, 149, 252, 161, 108, 102);   // "Size"
-    DWIN_Frame_AreaCopy(1,   1, 164,  56, 176, 108, 175);   // "Firmware Version"
-    DWIN_Frame_AreaCopy(1,  58, 164, 113, 176, 105, 248);   // "Contact Details"
-    DWINUI::Draw_CenteredString(268, F(CORP_WEBSITE));
+  if (hmiIsChinese()) {
+    dwinFrameAreaCopy(1, 197, 149, 252, 161, 108, 102);   // "Size"
+    dwinFrameAreaCopy(1,   1, 164,  56, 176, 108, 175);   // "Firmware Version"
+    dwinFrameAreaCopy(1,  58, 164, 113, 176, 105, 248);   // "Contact Details"
+    DWINUI::drawCenteredString(268, F(CORP_WEBSITE));
   }
   else {
-    DWINUI::Draw_CenteredString(102, F("Size"));
-    DWINUI::Draw_CenteredString(175, F("Firmware version"));
-    DWINUI::Draw_CenteredString(248, F("Build Datetime"));
-    DWINUI::Draw_CenteredString(268, F(STRING_DISTRIBUTION_DATE));
+    DWINUI::drawCenteredString(102, F("Size"));
+    DWINUI::drawCenteredString(175, F("Firmware version"));
+    DWINUI::drawCenteredString(248, F("Build Datetime"));
+    DWINUI::drawCenteredString(268, F(STRING_DISTRIBUTION_DATE));
   }
-  DWINUI::Draw_CenteredString(122, F(MACHINE_SIZE));
-  DWINUI::Draw_CenteredString(195, F(SHORT_BUILD_VERSION));
+  DWINUI::drawCenteredString(122, F(MACHINE_SIZE));
+  DWINUI::drawCenteredString(195, F(SHORT_BUILD_VERSION));
 
   for (uint8_t i = 0; i < 3; ++i) {
-    DWINUI::Draw_Icon(ICON_PrintSize + i, ICOX, 99 + i * 73);
-    dwinDrawHLine(HMI_data.SplitLine_Color, 16, MBASE(2) + i * 73, 240);
+    DWINUI::drawIcon(ICON_PrintSize + i, ICOX, 99 + i * 73);
+    dwinDrawHLine(hmiData.colorSplitLine, 16, MBASE(2) + i * 73, 240);
   }
 }
 
 // Main Process
-void HMI_MainMenu() {
+void hmiMainMenu() {
   EncoderState encoder_diffState = get_encoder_state();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
 
   if (encoder_diffState == ENCODER_DIFF_CW) {
     if (select_page.inc(PAGE_COUNT)) {
       switch (select_page.now) {
         case PAGE_PRINT: ICON_Print(); break;
         case PAGE_PREPARE: ICON_Print(); ICON_Prepare(); break;
         case PAGE_CONTROL: ICON_Prepare(); ICON_Control(); break;
         case PAGE_ADVANCE: ICON_Control(); ICON_AdvSettings(); break;
@@ -1112,46 +1116,46 @@ void HMI_MainMenu() {
         case PAGE_PRINT: ICON_Print(); ICON_Prepare(); break;
         case PAGE_PREPARE: ICON_Prepare(); ICON_Control(); break;
         case PAGE_CONTROL: ICON_Control(); ICON_AdvSettings(); break;
         case PAGE_ADVANCE: ICON_AdvSettings(); break;
       }
     }
   }
   else if (encoder_diffState == ENCODER_DIFF_ENTER) {
     switch (select_page.now) {
       case PAGE_PRINT:
-        if (HMI_data.MediaAutoMount) {
+        if (hmiData.mediaAutoMount) {
           card.mount();
           safe_delay(800);
         };
-        Draw_Print_File_Menu();
+        drawPrintFileMenu();
         break;
-      case PAGE_PREPARE: Draw_Prepare_Menu(); break;
-      case PAGE_CONTROL: Draw_Control_Menu(); break;
-      case PAGE_ADVANCE: Draw_AdvancedSettings_Menu(); break;
+      case PAGE_PREPARE: drawPrepareMenu(); break;
+      case PAGE_CONTROL: drawControlMenu(); break;
+      case PAGE_ADVANCE: drawAdvancedSettingsMenu(); break;
     }
   }
   dwinUpdateLCD();
 }
 
 // Pause or Stop popup
-void onClick_PauseOrStop() {
+void onClickPauseOrStop() {
   switch (select_print.now) {
     case PRINT_PAUSE_RESUME: if (hmiFlag.select_flag) ui.pause_print(); break; // Confirm pause
     case PRINT_STOP: if (hmiFlag.select_flag) ui.abort_print(); break; // Stop confirmed then abort print
     default: break;
   }
-  return Goto_PrintProcess();
+  return gotoPrintProcess();
 }
 
 // Printing
-void HMI_Printing() {
+void hmiPrinting() {
   EncoderState encoder_diffState = get_encoder_state();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
   // Avoid flicker by updating only the previous menu
   if (encoder_diffState == ENCODER_DIFF_CW) {
     if (select_print.inc(PRINT_COUNT)) {
       switch (select_print.now) {
         case PRINT_SETUP: ICON_Tune(); break;
         case PRINT_PAUSE_RESUME: ICON_Tune(); ICON_ResumeOrPause(); break;
         case PRINT_STOP: ICON_ResumeOrPause(); ICON_Stop(); break;
       }
@@ -1161,1137 +1165,1137 @@ void HMI_Printing() {
     if (select_print.dec()) {
       switch (select_print.now) {
         case PRINT_SETUP: ICON_Tune(); ICON_ResumeOrPause(); break;
         case PRINT_PAUSE_RESUME: ICON_ResumeOrPause(); ICON_Stop(); break;
         case PRINT_STOP: ICON_Stop(); break;
       }
     }
   }
   else if (encoder_diffState == ENCODER_DIFF_ENTER) {
     switch (select_print.now) {
-      case PRINT_SETUP: Draw_Tune_Menu(); break;
+      case PRINT_SETUP: drawTuneMenu(); break;
       case PRINT_PAUSE_RESUME:
         if (printingIsPaused()) {  // If printer is already in pause
           ui.resume_print();
           break;
         }
         else
-          return Goto_Popup(Popup_window_PauseOrStop, onClick_PauseOrStop);
+          return gotoPopup(popupPauseOrStop, onClickPauseOrStop);
       case PRINT_STOP:
-        return Goto_Popup(Popup_window_PauseOrStop, onClick_PauseOrStop);
+        return gotoPopup(popupPauseOrStop, onClickPauseOrStop);
       default: break;
     }
   }
   dwinUpdateLCD();
 }
 
 #include "../../../libs/buzzer.h"
 
-void Draw_Main_Area() {
+void drawMainArea() {
   switch (checkkey) {
-    case MainMenu:               Draw_Main_Menu(); break;
-    case PrintProcess:           Draw_PrintProcess(); break;
-    case PrintDone:              Draw_PrintDone(); break;
+    case ID_MainMenu:         drawMainMenu(); break;
+    case ID_PrintProcess:     drawPrintProcess(); break;
+    case ID_PrintDone:        drawPrintDone(); break;
     #if HAS_ESDIAG
-      case ESDiagProcess:        Draw_EndStopDiag(); break;
+      case ID_ESDiagProcess:  drawEndStopDiag(); break;
     #endif
-    case Popup:                  popupDraw(); break;
+    case ID_Popup:            popupDraw(); break;
     #if HAS_LOCKSCREEN
-      case Locked:               lockScreen.draw(); break;
-    #endif
-    case Menu:
-    case SetInt:
-    case SetPInt:
-    case SetIntNoDraw:
-    case SetFloat:
-    case SetPFloat:              ReDrawMenu(true); break;
+      case ID_Locked:         lockScreen.draw(); break;
+    #endif
+    case ID_Menu:
+    case ID_SetInt:
+    case ID_SetPInt:
+    case ID_SetIntNoDraw:
+    case ID_SetFloat:
+    case ID_SetPFloat:        ReDrawMenu(true); break;
     default: break;
   }
 }
 
-void HMI_WaitForUser() {
+void hmiWaitForUser() {
   EncoderState encoder_diffState = get_encoder_state();
   if (encoder_diffState != ENCODER_DIFF_NO && !ui.backlight) {
-    if (checkkey == WaitResponse) HMI_ReturnScreen();
+    if (checkkey == ID_WaitResponse) hmiReturnScreen();
     return ui.refresh_brightness();
   }
   if (!wait_for_user) {
     switch (checkkey) {
-      case PrintDone:
+      case ID_PrintDone:
         select_page.reset();
-        Goto_Main_Menu();
+        gotoMainMenu();
         break;
       #if HAS_BED_PROBE
-        case Leveling:
+        case ID_Leveling:
       #endif
       default:
-        HMI_ReturnScreen();
+        hmiReturnScreen();
         break;
     }
   }
 }
 
-void HMI_Init() {
+void hmiInit() {
   #if ENABLED(SHOW_BOOTSCREEN)
     #ifndef BOOTSCREEN_TIMEOUT
       #define BOOTSCREEN_TIMEOUT 1100
     #endif
-    DWINUI::Draw_Box(1, Color_Black, { 5, 220, DWIN_WIDTH - 5, DWINUI::fontHeight() });
-    DWINUI::Draw_CenteredString(Color_White, 220, F("ProUI starting up "));
+    DWINUI::drawBox(1, COLOR_BLACK, { 5, 220, DWIN_WIDTH - 5, DWINUI::fontHeight() });
+    DWINUI::drawCenteredString(COLOR_WHITE, 220, F("ProUI starting up "));
     for (uint16_t t = 15; t < 257; t += 11) {
-      DWINUI::Draw_Icon(ICON_Bar, 15, 260);
-      dwinDrawRectangle(1, HMI_data.Background_Color, t, 260, 257, 280);
+      DWINUI::drawIcon(ICON_Bar, 15, 260);
+      dwinDrawRectangle(1, hmiData.colorBackground, t, 260, 257, 280);
       dwinUpdateLCD();
       safe_delay((BOOTSCREEN_TIMEOUT) / 22);
     }
   #endif
-  HMI_SetLanguage();
+  hmiSetLanguage();
 }
 
-void EachMomentUpdate() {
+void eachMomentUpdate() {
   static millis_t next_var_update_ms = 0, next_rts_update_ms = 0, next_status_update_ms = 0;
   const millis_t ms = millis();
 
   if (ELAPSED(ms, next_var_update_ms)) {
     next_var_update_ms = ms + DWIN_VAR_UPDATE_INTERVAL;
     blink = !blink;
-    update_variable();
+    updateVariable();
     #if HAS_ESDIAG
-      if (checkkey == ESDiagProcess) ESDiag.Update();
+      if (checkkey == ID_ESDiagProcess) esDiag.update();
     #endif
-    #if SHOW_TUNING_GRAPH
-      if (checkkey == PidProcess) {
-        TERN_(PIDTEMP, if (HMI_value.tempcontrol == PIDTEMP_START) plot.Update(thermalManager.wholeDegHotend(0)));
-        TERN_(PIDTEMPBED, if (HMI_value.tempcontrol == PIDTEMPBED_START) plot.Update(thermalManager.wholeDegBed()));
+    #if PROUI_TUNING_GRAPH
+      if (checkkey == ID_PIDProcess) {
+        TERN_(PIDTEMP, if (hmiValue.tempControl == PIDTEMP_START) plot.update(thermalManager.wholeDegHotend(0)));
+        TERN_(PIDTEMPBED, if (hmiValue.tempControl == PIDTEMPBED_START) plot.update(thermalManager.wholeDegBed()));
       }
-      TERN_(MPCTEMP, if (checkkey == MPCProcess) plot.Update(thermalManager.wholeDegHotend(0)));
+      TERN_(MPCTEMP, if (checkkey == ID_MPCProcess) plot.update(thermalManager.wholeDegHotend(0)));
     #endif
   }
 
   #if HAS_STATUS_MESSAGE_TIMEOUT
     bool did_expire = ui.status_reset_callback && (*ui.status_reset_callback)();
     did_expire |= ui.status_message_expire_ms && ELAPSED(ms, ui.status_message_expire_ms);
     if (did_expire) ui.reset_status();
   #endif
 
   if (ELAPSED(ms, next_status_update_ms)) {
     next_status_update_ms = ms + 500;
-    DWIN_DrawStatusMessage();
+    dwinDrawStatusMessage();
     #if ENABLED(SCROLL_LONG_FILENAMES)
-      if (IsMenu(FileMenu)) FileMenuIdle();
+      if (isMenu(fileMenu)) fileMenuIdle();
     #endif
   }
 
   if (!PENDING(ms, next_rts_update_ms)) {
     next_rts_update_ms = ms + DWIN_UPDATE_INTERVAL;
 
-    if ((Printing() != hmiFlag.printing_flag) && !hmiFlag.home_flag) {
-      hmiFlag.printing_flag = Printing();
+    if ((isPrinting() != hmiFlag.printing_flag) && !hmiFlag.home_flag) {
+      hmiFlag.printing_flag = isPrinting();
       if (hmiFlag.printing_flag)
-        DWIN_Print_Started();
+        dwinPrintStarted();
       else if (hmiFlag.abort_flag)
-        DWIN_Print_Aborted();
+        dwinPrintAborted();
       else
-        DWIN_Print_Finished();
+        dwinPrintFinished();
     }
 
     if ((printingIsPaused() != hmiFlag.pause_flag) && !hmiFlag.home_flag) {
       hmiFlag.pause_flag = printingIsPaused();
       if (hmiFlag.pause_flag)
-        DWIN_Print_Pause();
+        dwinPrintPause();
       else if (hmiFlag.abort_flag)
-        DWIN_Print_Aborted();
+        dwinPrintAborted();
       else
-        DWIN_Print_Resume();
+        dwinPrintResume();
     }
 
-    if (checkkey == PrintProcess) { // Print process
+    if (checkkey == ID_PrintProcess) { // Print process
 
       // Progress percent
       static uint8_t _percent_done = 255;
       if (_percent_done != ui.get_progress_percent()) {
         _percent_done = ui.get_progress_percent();
-        Draw_Print_ProgressBar();
+        drawPrintProgressBar();
       }
 
       // Remaining time
       #if ENABLED(SHOW_REMAINING_TIME)
         static uint32_t _remain_time = 0;
         if (_remain_time != ui.get_remaining_time()) {
           _remain_time = ui.get_remaining_time();
-          Draw_Print_ProgressRemain();
+          drawPrintProgressRemain();
         }
       #endif
 
       // Elapsed print time
       static uint16_t _printtime = 0;
       const uint16_t min = (print_job_timer.duration() % 3600) / 60;
       if (_printtime != min) { // 1 minute update
         _printtime = min;
-        Draw_Print_ProgressElapsed();
+        drawPrintProgressElapsed();
       }
     }
     #if ENABLED(POWER_LOSS_RECOVERY)
       else if (DWIN_lcd_sd_status && recovery.dwin_flag) { // Resume print before power off
-        return Goto_PowerLossRecovery();
+        return gotoPowerLossRecovery();
       }
     #endif
 
     dwinUpdateLCD();
   }
 }
 
 #if ENABLED(POWER_LOSS_RECOVERY)
-  void Popup_PowerLossRecovery() {
-    DWINUI::ClearMainArea();
-    Draw_Popup_Bkgd();
-    if (HMI_IsChinese()) {
-      DWIN_Frame_AreaCopy(1, 160, 338, 235, 354, 98, 115);
-      DWIN_Frame_AreaCopy(1, 103, 321, 271, 335, 52, 167);
-      DWINUI::Draw_IconWB(ICON_Cancel_C,    26, 280);
-      DWINUI::Draw_IconWB(ICON_Continue_C, 146, 280);
+  void popupPowerLossRecovery() {
+    DWINUI::clearMainArea();
+    drawPopupBkgd();
+    if (hmiIsChinese()) {
+      dwinFrameAreaCopy(1, 160, 338, 235, 354, 98, 115);
+      dwinFrameAreaCopy(1, 103, 321, 271, 335, 52, 167);
+      DWINUI::drawIconWB(ICON_Cancel_C,    26, 280);
+      DWINUI::drawIconWB(ICON_Continue_C, 146, 280);
     }
     else {
-      DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 70, GET_TEXT_F(MSG_OUTAGE_RECOVERY));
-      DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 147, F("It looks like the last"));
-      DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 167, F("file was interrupted."));
-      DWINUI::Draw_Button(BTN_Cancel,    26, 280);
-      DWINUI::Draw_Button(BTN_Continue, 146, 280);
+      DWINUI::drawCenteredString(hmiData.colorPopupTxt, 70, GET_TEXT_F(MSG_OUTAGE_RECOVERY));
+      DWINUI::drawCenteredString(hmiData.colorPopupTxt, 147, F("It looks like the last"));
+      DWINUI::drawCenteredString(hmiData.colorPopupTxt, 167, F("file was interrupted."));
+      DWINUI::drawButton(BTN_Cancel,    26, 280);
+      DWINUI::drawButton(BTN_Continue, 146, 280);
     }
     MediaFile *dir = nullptr;
     const char * const filename = card.diveToFile(true, dir, recovery.info.sd_filename);
     card.selectFileByName(filename);
-    DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 207, card.longest_filename());
-    DWIN_Print_Header(card.longest_filename()); // Save filename
-    Draw_Select_Highlight(hmiFlag.select_flag);
+    DWINUI::drawCenteredString(hmiData.colorPopupTxt, 207, card.longest_filename());
+    dwinPrintHeader(card.longest_filename()); // Save filename
+    drawSelectHighlight(hmiFlag.select_flag);
     dwinUpdateLCD();
   }
 
-  void onClick_PowerLossRecovery() {
+  void onClickPowerLossRecovery() {
     if (hmiFlag.select_flag) {
       queue.inject(F("M1000C"));
       select_page.reset();
-      return Goto_Main_Menu();
+      return gotoMainMenu();
     }
     else {
-      HMI_SaveProcessID(NothingToDo);
+      hmiSaveProcessID(ID_NothingToDo);
       select_print.set(PRINT_SETUP);
       queue.inject(F("M1000"));
     }
   }
 
-  void Goto_PowerLossRecovery() {
+  void gotoPowerLossRecovery() {
     recovery.dwin_flag = false;
     LCD_MESSAGE(MSG_CONTINUE_PRINT_JOB);
-    Goto_Popup(Popup_PowerLossRecovery, onClick_PowerLossRecovery);
+    gotoPopup(popupPowerLossRecovery, onClickPowerLossRecovery);
   }
 
 #endif // POWER_LOSS_RECOVERY
 
-void DWIN_HandleScreen() {
+void dwinHandleScreen() {
   switch (checkkey) {
-    case MainMenu:        HMI_MainMenu(); break;
-    case Menu:            HMI_Menu(); break;
-    case SetInt:          HMI_SetDraw(); break;
-    case SetFloat:        HMI_SetDraw(); break;
-    case SetPInt:         HMI_SetPInt(); break;
-    case SetPFloat:       HMI_SetPFloat(); break;
-    case SetIntNoDraw:    HMI_SetNoDraw(); break;
-    case PrintProcess:    HMI_Printing(); break;
-    case Popup:           HMI_Popup(); break;
-    case Leveling:        break;
+    case ID_MainMenu:     hmiMainMenu(); break;
+    case ID_Menu:         hmiMenu(); break;
+    case ID_SetInt:       hmiSetDraw(); break;
+    case ID_SetFloat:     hmiSetDraw(); break;
+    case ID_SetPInt:      hmiSetPInt(); break;
+    case ID_SetPFloat:    hmiSetPFloat(); break;
+    case ID_SetIntNoDraw: hmiSetNoDraw(); break;
+    case ID_PrintProcess: hmiPrinting(); break;
+    case ID_Popup:        hmiPopup(); break;
+    case ID_Leveling:     break;
     #if HAS_LOCKSCREEN
-      case Locked:        HMI_LockScreen(); break;
-    #endif
-    case PrintDone:
-    TERN_(HAS_ESDIAG, case ESDiagProcess:)
-    case WaitResponse:    HMI_WaitForUser(); break;
-    case Homing:
-    case PidProcess:
-    case NothingToDo:     break;
+      case ID_Locked:     hmiLockScreen(); break;
+    #endif
+    case ID_PrintDone:
+    TERN_(HAS_ESDIAG, case ID_ESDiagProcess:)
+    case ID_WaitResponse: hmiWaitForUser(); break;
+    case ID_Homing:
+    case ID_PIDProcess:
+    case ID_NothingToDo:  break;
     default: break;
   }
 }
 
-bool IDisPopUp() {    // If ID is popup...
+bool idIsPopUp() {    // If ID is popup...
   switch (checkkey) {
-    case NothingToDo:
-    case WaitResponse:
-    case Popup:
-    case Homing:
-    case Leveling:
-    case PidProcess:
-    TERN_(HAS_ESDIAG, case ESDiagProcess:)
+    case ID_NothingToDo:
+    case ID_WaitResponse:
+    case ID_Popup:
+    case ID_Homing:
+    case ID_Leveling:
+    case ID_PIDProcess:
+    TERN_(HAS_ESDIAG, case ID_ESDiagProcess:)
       return true;
     default: break;
   }
   return false;
 }
 
-void HMI_SaveProcessID(const uint8_t id) {
+void hmiSaveProcessID(const uint8_t id) {
   if (checkkey == id) return;
-  if (!IDisPopUp()) last_checkkey = checkkey; // If previous is not a popup
+  if (!idIsPopUp()) last_checkkey = checkkey; // If previous is not a popup
   checkkey = id;
   switch (id) {
-    case Popup:
-    case WaitResponse:
-    case PrintDone:
-    case Leveling:
-    TERN_(HAS_ESDIAG, case ESDiagProcess:)
+    case ID_Popup:
+    case ID_WaitResponse:
+    case ID_PrintDone:
+    case ID_Leveling:
+    TERN_(HAS_ESDIAG, case ID_ESDiagProcess:)
       wait_for_user = true;
     default: break;
   }
 }
 
-void HMI_ReturnScreen() {
+void hmiReturnScreen() {
   checkkey = last_checkkey;
   wait_for_user = false;
-  Draw_Main_Area();
+  drawMainArea();
 }
 
 void dwinHomingStart() {
   hmiFlag.home_flag = true;
-  HMI_SaveProcessID(Homing);
-  Title.ShowCaption(GET_TEXT_F(MSG_HOMING));
-  DWIN_Show_Popup(ICON_BLTouch, GET_TEXT_F(MSG_HOMING), GET_TEXT_F(MSG_PLEASE_WAIT));
+  hmiSaveProcessID(ID_Homing);
+  title.showCaption(GET_TEXT_F(MSG_HOMING));
+  dwinShowPopup(ICON_BLTouch, GET_TEXT_F(MSG_HOMING), GET_TEXT_F(MSG_PLEASE_WAIT));
 }
 
 void dwinHomingDone() {
   hmiFlag.home_flag = false;
-  if (last_checkkey == PrintDone)
-    Goto_PrintDone();
+  if (last_checkkey == ID_PrintDone)
+    gotoPrintDone();
   else
-    HMI_ReturnScreen();
+    hmiReturnScreen();
 }
 
-void DWIN_LevelingStart() {
+void dwinLevelingStart() {
   #if HAS_BED_PROBE
-    HMI_SaveProcessID(Leveling);
-    Title.ShowCaption(GET_TEXT_F(MSG_BED_LEVELING));
-    DWIN_Show_Popup(ICON_AutoLeveling, GET_TEXT_F(MSG_BED_LEVELING), GET_TEXT_F(MSG_PLEASE_WAIT));
+    hmiSaveProcessID(ID_Leveling);
+    title.showCaption(GET_TEXT_F(MSG_BED_LEVELING));
+    dwinShowPopup(ICON_AutoLeveling, GET_TEXT_F(MSG_BED_LEVELING), GET_TEXT_F(MSG_PLEASE_WAIT));
     #if ALL(AUTO_BED_LEVELING_UBL, PREHEAT_BEFORE_LEVELING)
       #if HAS_BED_PROBE
-        if (!DEBUGGING(DRYRUN)) probe.preheat_for_probing(LEVELING_NOZZLE_TEMP, HMI_data.BedLevT);
+        if (!DEBUGGING(DRYRUN)) probe.preheat_for_probing(LEVELING_NOZZLE_TEMP, hmiData.bedLevT);
       #else
         #if HAS_HOTEND
           if (!DEBUGGING(DRYRUN) && thermalManager.degTargetHotend(0) < LEVELING_NOZZLE_TEMP) {
             thermalManager.setTargetHotend(LEVELING_NOZZLE_TEMP, 0);
             thermalManager.wait_for_hotend(0);
           }
         #endif
         #if HAS_HEATED_BED
-          if (!DEBUGGING(DRYRUN) && thermalManager.degTargetBed() < HMI_data.BedLevT) {
-            thermalManager.setTargetBed(HMI_data.BedLevT);
+          if (!DEBUGGING(DRYRUN) && thermalManager.degTargetBed() < hmiData.bedLevT) {
+            thermalManager.setTargetBed(hmiData.bedLevT);
             thermalManager.wait_for_bed_heating();
           }
         #endif
       #endif
     #endif
   #elif ENABLED(MESH_BED_LEVELING)
-    Draw_ManualMesh_Menu();
+    drawManualMeshMenu();
   #endif
 }
 
-void DWIN_LevelingDone() {
-  TERN_(HAS_MESH, Goto_MeshViewer(true));
+void dwinLevelingDone() {
+  TERN_(HAS_MESH, gotoMeshViewer(true));
 }
 
 #if HAS_MESH
-  void DWIN_MeshUpdate(const int8_t cpos, const int8_t tpos, const_float_t zval) {
+  void dwinMeshUpdate(const int8_t cpos, const int8_t tpos, const_float_t zval) {
     ui.set_status(
       &MString<32>(GET_TEXT_F(MSG_PROBING_POINT), ' ', cpos, '/', tpos, F(" Z="), p_float_t(zval, 2))
     );
   }
 #endif
 
 // PID/MPC process
 
-#if SHOW_TUNING_GRAPH
+#if PROUI_TUNING_GRAPH
 
   #include "plot.h"
 
   celsius_t _maxtemp, _target;
-  void DWIN_Draw_PID_MPC_Popup() {
+  void dwinDrawPIDMPCPopup() {
     constexpr frame_rect_t gfrm = { 40, 180, DWIN_WIDTH - 80, 120 };
-    DWINUI::ClearMainArea();
-    Draw_Popup_Bkgd();
+    DWINUI::clearMainArea();
+    drawPopupBkgd();
 
-    switch (HMI_value.tempcontrol) {
+    switch (hmiValue.tempControl) {
       default: return;
       #if ENABLED(MPC_AUTOTUNE)
         case MPCTEMP_START:
-          DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 100, GET_TEXT_F(MSG_MPC_AUTOTUNE));
-          DWINUI::Draw_String(HMI_data.PopupTxt_Color, gfrm.x, gfrm.y - DWINUI::fontHeight() - 4, F("MPC target:    Celsius"));
+          DWINUI::drawCenteredString(hmiData.colorPopupTxt, 100, GET_TEXT_F(MSG_MPC_AUTOTUNE));
+          DWINUI::drawString(hmiData.colorPopupTxt, gfrm.x, gfrm.y - DWINUI::fontHeight() - 4, F("MPC target:    Celsius"));
           break;
       #endif
       #if ANY(PIDTEMP, PIDTEMPBED)
         TERN_(PIDTEMP,    case PIDTEMP_START:)
         TERN_(PIDTEMPBED, case PIDTEMPBED_START:)
-          DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 100, GET_TEXT_F(MSG_PID_AUTOTUNE));
-          DWINUI::Draw_String(HMI_data.PopupTxt_Color, gfrm.x, gfrm.y - DWINUI::fontHeight() - 4, F("PID target:    Celsius"));
+          DWINUI::drawCenteredString(hmiData.colorPopupTxt, 100, GET_TEXT_F(MSG_PID_AUTOTUNE));
+          DWINUI::drawString(hmiData.colorPopupTxt, gfrm.x, gfrm.y - DWINUI::fontHeight() - 4, F("PID target:    Celsius"));
           break;
       #endif
     }
 
-    switch (HMI_value.tempcontrol) {
+    switch (hmiValue.tempControl) {
       default: break;
       #if ANY(PIDTEMP, MPC_AUTOTUNE)
         TERN_(PIDTEMP,      case PIDTEMP_START:)
         TERN_(MPC_AUTOTUNE, case MPCTEMP_START:)
-          DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 120, F("for Nozzle is running."));
+          DWINUI::drawCenteredString(hmiData.colorPopupTxt, 120, F("for Nozzle is running."));
           break;
       #endif
       #if ENABLED(PIDTEMPBED)
         case PIDTEMPBED_START:
-          DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 120, F("for BED is running."));
+          DWINUI::drawCenteredString(hmiData.colorPopupTxt, 120, F("for BED is running."));
           break;
       #endif
     }
 
-    switch (HMI_value.tempcontrol) {
+    switch (hmiValue.tempControl) {
       default: break;
       #if ENABLED(MPC_AUTOTUNE)
         case MPCTEMP_START:
           _maxtemp = thermalManager.hotend_maxtemp[0];
           _target = 200;
           break;
       #endif
       #if ENABLED(PIDTEMP)
         case PIDTEMP_START:
           _maxtemp = thermalManager.hotend_maxtemp[0];
-          _target = HMI_data.HotendPidT;
+          _target = hmiData.hotendPidT;
           break;
       #endif
       #if ENABLED(PIDTEMPBED)
         case PIDTEMPBED_START:
           _maxtemp = BED_MAXTEMP;
-          _target = HMI_data.BedPidT;
+          _target = hmiData.bedPidT;
           break;
       #endif
     }
 
-    plot.Draw(gfrm, _maxtemp, _target);
-    DWINUI::Draw_Int(HMI_data.PopupTxt_Color, 3, gfrm.x + 90, gfrm.y - DWINUI::fontHeight() - 4, _target);
+    plot.draw(gfrm, _maxtemp, _target);
+    DWINUI::drawInt(hmiData.colorPopupTxt, 3, gfrm.x + 90, gfrm.y - DWINUI::fontHeight() - 4, _target);
   }
 
-#endif // SHOW_TUNING_GRAPH
+#endif // PROUI_TUNING_GRAPH
 
-#if DWIN_PID_TUNE
+#if PROUI_PID_TUNE
 
-  void DWIN_StartM303(const bool seenC, const int c, const bool seenS, const heater_id_t hid, const celsius_t temp) {
-    if (seenC) HMI_data.PidCycles = c;
+  void dwinStartM303(const bool seenC, const int c, const bool seenS, const heater_id_t hid, const celsius_t temp) {
+    if (seenC) hmiData.pidCycles = c;
     if (seenS) {
       switch (hid) {
-        OPTCODE(PIDTEMP,    case 0 ... HOTENDS - 1: HMI_data.HotendPidT = temp; break)
-        OPTCODE(PIDTEMPBED, case H_BED:             HMI_data.BedPidT = temp;    break)
+        OPTCODE(PIDTEMP,    case 0 ... HOTENDS - 1: hmiData.hotendPidT = temp; break)
+        OPTCODE(PIDTEMPBED, case H_BED:             hmiData.bedPidT = temp;    break)
         default: break;
       }
     }
   }
 
-  void DWIN_PidTuning(tempcontrol_t result) {
-    HMI_value.tempcontrol = result;
+  void dwinPidTuning(tempcontrol_t result) {
+    hmiValue.tempControl = result;
     switch (result) {
       #if ENABLED(PIDTEMP)
         case PIDTEMP_START:
-          HMI_SaveProcessID(PidProcess);
-          #if SHOW_TUNING_GRAPH
-            DWIN_Draw_PID_MPC_Popup();
+          hmiSaveProcessID(ID_PIDProcess);
+          #if PROUI_TUNING_GRAPH
+            dwinDrawPIDMPCPopup();
           #else
-            DWIN_Draw_Popup(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE), F("for Nozzle is running."));
+            dwinDrawPopup(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE), F("for Nozzle is running."));
           #endif
           break;
         case PID_TEMP_TOO_HIGH:
           checkkey = last_checkkey;
-          DWIN_Popup_Confirm(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE_FAILED), GET_TEXT_F(MSG_TEMP_TOO_HIGH));
+          dwinPopupConfirm(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE_FAILED), GET_TEXT_F(MSG_TEMP_TOO_HIGH));
           break;
       #endif
       #if ENABLED(PIDTEMPBED)
         case PIDTEMPBED_START:
-          HMI_SaveProcessID(PidProcess);
-          #if SHOW_TUNING_GRAPH
-            DWIN_Draw_PID_MPC_Popup();
+          hmiSaveProcessID(ID_PIDProcess);
+          #if PROUI_TUNING_GRAPH
+            dwinDrawPIDMPCPopup();
           #else
-            DWIN_Draw_Popup(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE), F("for BED is running."));
+            dwinDrawPopup(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE), F("for BED is running."));
           #endif
           break;
       #endif
       case PID_BAD_HEATER_ID:
         checkkey = last_checkkey;
-        DWIN_Popup_Confirm(ICON_TempTooLow, GET_TEXT_F(MSG_PID_AUTOTUNE_FAILED), GET_TEXT_F(MSG_PID_BAD_HEATER_ID));
+        dwinPopupConfirm(ICON_TempTooLow, GET_TEXT_F(MSG_PID_AUTOTUNE_FAILED), GET_TEXT_F(MSG_PID_BAD_HEATER_ID));
         break;
       case PID_TUNING_TIMEOUT:
         checkkey = last_checkkey;
-        DWIN_Popup_Confirm(ICON_TempTooHigh, GET_TEXT_F(MSG_ERROR), GET_TEXT_F(MSG_PID_TIMEOUT));
+        dwinPopupConfirm(ICON_TempTooHigh, GET_TEXT_F(MSG_ERROR), GET_TEXT_F(MSG_PID_TIMEOUT));
         break;
       case AUTOTUNE_DONE:
         checkkey = last_checkkey;
-        DWIN_Popup_Confirm(ICON_TempTooLow, GET_TEXT_F(MSG_PID_AUTOTUNE), GET_TEXT_F(MSG_BUTTON_DONE));
+        dwinPopupConfirm(ICON_TempTooLow, GET_TEXT_F(MSG_PID_AUTOTUNE), GET_TEXT_F(MSG_BUTTON_DONE));
         break;
       default:
         checkkey = last_checkkey;
         break;
     }
   }
 
-#endif // DWIN_PID_TUNE
+#endif // PROUI_PID_TUNE
 
 #if ENABLED(MPC_AUTOTUNE)
 
-  void DWIN_MPCTuning(tempcontrol_t result) {
-    HMI_value.tempcontrol = result;
+  void dwinMPCTuning(tempcontrol_t result) {
+    hmiValue.tempControl = result;
     switch (result) {
       case MPCTEMP_START:
-        HMI_SaveProcessID(MPCProcess);
-        #if SHOW_TUNING_GRAPH
-          DWIN_Draw_PID_MPC_Popup();
+        hmiSaveProcessID(ID_MPCProcess);
+        #if PROUI_TUNING_GRAPH
+          dwinDrawPIDMPCPopup();
         #else
-          DWIN_Draw_Popup(ICON_TempTooHigh, GET_TEXT_F(MSG_MPC_AUTOTUNE), F("for Nozzle is running."));
+          dwinDrawPopup(ICON_TempTooHigh, GET_TEXT_F(MSG_MPC_AUTOTUNE), F("for Nozzle is running."));
         #endif
         break;
       case MPC_TEMP_ERROR:
         checkkey = last_checkkey;
-        DWIN_Popup_Confirm(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE_FAILED), F(STR_MPC_TEMPERATURE_ERROR));
+        dwinPopupConfirm(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE_FAILED), F(STR_MPC_TEMPERATURE_ERROR));
         ui.reset_alert_level();
         break;
       case MPC_INTERRUPTED:
         checkkey = last_checkkey;
-        DWIN_Popup_Confirm(ICON_TempTooHigh, GET_TEXT_F(MSG_ERROR), F(STR_MPC_AUTOTUNE_INTERRUPTED));
+        dwinPopupConfirm(ICON_TempTooHigh, GET_TEXT_F(MSG_ERROR), F(STR_MPC_AUTOTUNE_INTERRUPTED));
         ui.reset_alert_level();
         break;
       case AUTOTUNE_DONE:
         checkkey = last_checkkey;
-        DWIN_Popup_Confirm(ICON_TempTooLow, GET_TEXT_F(MSG_MPC_AUTOTUNE), GET_TEXT_F(MSG_BUTTON_DONE));
+        dwinPopupConfirm(ICON_TempTooLow, GET_TEXT_F(MSG_MPC_AUTOTUNE), GET_TEXT_F(MSG_BUTTON_DONE));
         ui.reset_alert_level();
         break;
       default:
         checkkey = last_checkkey;
         ui.reset_alert_level();
         break;
     }
   }
 
 #endif // MPC_AUTOTUNE
 
 // Started a Print Job
-void DWIN_Print_Started() {
+void dwinPrintStarted() {
   TERN_(HAS_GCODE_PREVIEW, if (Host_Printing()) Preview_Invalidate());
   TERN_(SET_PROGRESS_PERCENT, ui.progress_reset());
   TERN_(SET_REMAINING_TIME, ui.reset_remaining_time());
   hmiFlag.pause_flag = false;
   hmiFlag.abort_flag = false;
   select_print.reset();
-  Goto_PrintProcess();
+  gotoPrintProcess();
 }
 
 // Pause a print job
-void DWIN_Print_Pause() {
+void dwinPrintPause() {
   ICON_ResumeOrPause();
 }
 
 // Resume print job
-void DWIN_Print_Resume() {
+void dwinPrintResume() {
   ICON_ResumeOrPause();
   LCD_MESSAGE(MSG_RESUME_PRINT);
 }
 
 // Ended print job
-void DWIN_Print_Finished() {
+void dwinPrintFinished() {
   TERN_(POWER_LOSS_RECOVERY, if (card.isPrinting()) recovery.cancel());
   hmiFlag.abort_flag = false;
   hmiFlag.pause_flag = false;
   wait_for_heatup = false;
   planner.finish_and_disable();
   thermalManager.cooldown();
-  Goto_PrintDone();
+  gotoPrintDone();
 }
 
 // Print was aborted
-void DWIN_Print_Aborted() {
-  DWIN_Print_Finished();
+void dwinPrintAborted() {
+  dwinPrintFinished();
 }
 
 #if HAS_FILAMENT_SENSOR
   // Filament Runout process
-  void DWIN_FilamentRunout(const uint8_t extruder) { LCD_MESSAGE(MSG_RUNOUT_SENSOR); }
-#endif
-
-void DWIN_SetColorDefaults() {
-  HMI_data.Background_Color = Def_Background_Color;
-  HMI_data.Cursor_Color     = Def_Cursor_Color;
-  HMI_data.TitleBg_Color    = Def_TitleBg_Color;
-  HMI_data.TitleTxt_Color   = Def_TitleTxt_Color;
-  HMI_data.Text_Color       = Def_Text_Color;
-  HMI_data.Selected_Color   = Def_Selected_Color;
-  HMI_data.SplitLine_Color  = Def_SplitLine_Color;
-  HMI_data.Highlight_Color  = Def_Highlight_Color;
-  HMI_data.StatusBg_Color   = Def_StatusBg_Color;
-  HMI_data.StatusTxt_Color  = Def_StatusTxt_Color;
-  HMI_data.PopupBg_Color    = Def_PopupBg_Color;
-  HMI_data.PopupTxt_Color   = Def_PopupTxt_Color;
-  HMI_data.AlertBg_Color    = Def_AlertBg_Color;
-  HMI_data.AlertTxt_Color   = Def_AlertTxt_Color;
-  HMI_data.PercentTxt_Color = Def_PercentTxt_Color;
-  HMI_data.Barfill_Color    = Def_Barfill_Color;
-  HMI_data.Indicator_Color  = Def_Indicator_Color;
-  HMI_data.Coordinate_Color = Def_Coordinate_Color;
-}
-
-void DWIN_SetDataDefaults() {
-  DWIN_SetColorDefaults();
-  DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color, HMI_data.StatusBg_Color);
-  TERN_(PIDTEMP, HMI_data.HotendPidT = DEF_HOTENDPIDT);
-  TERN_(PIDTEMPBED, HMI_data.BedPidT = DEF_BEDPIDT);
-  TERN_(DWIN_PID_TUNE, HMI_data.PidCycles = DEF_PIDCYCLES);
+  void dwinFilamentRunout(const uint8_t extruder) { LCD_MESSAGE(MSG_RUNOUT_SENSOR); }
+#endif
+
+void dwinSetColorDefaults() {
+  hmiData.colorBackground = defColorBackground;
+  hmiData.colorCursor     = defColorCursor;
+  hmiData.colorTitleBg    = defColorTitleBg;
+  hmiData.colorTitleTxt   = defColorTitleTxt;
+  hmiData.colorText       = defColorText;
+  hmiData.colorSelected   = defColorSelected;
+  hmiData.colorSplitLine  = defColorSplitLine;
+  hmiData.colorHighlight  = defColorHighlight;
+  hmiData.colorStatusBg   = defColorStatusBg;
+  hmiData.colorStatusTxt  = defColorStatusTxt;
+  hmiData.colorPopupBg    = defColorPopupBg;
+  hmiData.colorPopupTxt   = defColorPopupTxt;
+  hmiData.colorAlertBg    = defColorAlertBg;
+  hmiData.colorAlertTxt   = defColorAlertTxt;
+  hmiData.colorPercentTxt = defColorPercentTxt;
+  hmiData.colorBarfill    = defColorBarfill;
+  hmiData.colorIndicator  = defColorIndicator;
+  hmiData.colorCoordinate = defColorCoordinate;
+}
+
+void dwinSetDataDefaults() {
+  dwinSetColorDefaults();
+  DWINUI::setColors(hmiData.colorText, hmiData.colorBackground, hmiData.colorStatusBg);
+  TERN_(PIDTEMP, hmiData.hotendPidT = DEF_HOTENDPIDT);
+  TERN_(PIDTEMPBED, hmiData.bedPidT = DEF_BEDPIDT);
+  TERN_(PROUI_PID_TUNE, hmiData.pidCycles = DEF_PIDCYCLES);
   #if ENABLED(PREVENT_COLD_EXTRUSION)
-    HMI_data.ExtMinT = EXTRUDE_MINTEMP;
-    ApplyExtMinT();
+    hmiData.extMinT = EXTRUDE_MINTEMP;
+    applyExtMinT();
   #endif
-  TERN_(PREHEAT_BEFORE_LEVELING, HMI_data.BedLevT = LEVELING_BED_TEMP);
-  TERN_(BAUD_RATE_GCODE, SetBaud250K());
+  TERN_(PREHEAT_BEFORE_LEVELING, hmiData.bedLevT = LEVELING_BED_TEMP);
+  TERN_(BAUD_RATE_GCODE, setBaud250K());
   #if ALL(LCD_BED_TRAMMING, HAS_BED_PROBE)
-    HMI_data.FullManualTramming = DISABLED(BED_TRAMMING_USE_PROBE);
+    hmiData.fullManualTramming = DISABLED(BED_TRAMMING_USE_PROBE);
   #endif
   #if ENABLED(MEDIASORT_MENU_ITEM)
-    HMI_data.MediaSort = true;
+    hmiData.mediaSort = true;
     card.setSortOn(true);
   #endif
-  HMI_data.MediaAutoMount = ENABLED(HAS_SD_EXTENDER);
+  hmiData.mediaAutoMount = ENABLED(HAS_SD_EXTENDER);
   #if ALL(INDIVIDUAL_AXIS_HOMING_SUBMENU, MESH_BED_LEVELING)
-    HMI_data.z_after_homing = DEF_Z_AFTER_HOMING;
+    hmiData.zAfterHoming = DEF_Z_AFTER_HOMING;
   #endif
   #if ALL(LED_CONTROL_MENU, HAS_COLOR_LEDS)
     TERN_(LED_COLOR_PRESETS, leds.set_default());
-    ApplyLEDColor();
+    applyLEDColor();
   #endif
-  TERN_(ADAPTIVE_STEP_SMOOTHING, HMI_data.AdaptiveStepSmoothing = true);
-  TERN_(HAS_GCODE_PREVIEW, HMI_data.EnablePreview = true);
+  TERN_(ADAPTIVE_STEP_SMOOTHING, hmiData.adaptiveStepSmoothing = true);
+  TERN_(HAS_GCODE_PREVIEW, hmiData.enablePreview = true);
 }
 
-void DWIN_CopySettingsTo(char * const buff) {
-  memcpy(buff, &HMI_data, eeprom_data_size);
+void dwinCopySettingsTo(char * const buff) {
+  memcpy(buff, &hmiData, eeprom_data_size);
 }
 
-void DWIN_CopySettingsFrom(const char * const buff) {
-  memcpy(&HMI_data, buff, sizeof(HMI_data_t));
-  if (HMI_data.Text_Color == HMI_data.Background_Color) DWIN_SetColorDefaults();
-  DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color, HMI_data.StatusBg_Color);
-  TERN_(PREVENT_COLD_EXTRUSION, ApplyExtMinT());
+void dwinCopySettingsFrom(const char * const buff) {
+  memcpy(&hmiData, buff, sizeof(hmi_data_t));
+  if (hmiData.colorText == hmiData.colorBackground) dwinSetColorDefaults();
+  DWINUI::setColors(hmiData.colorText, hmiData.colorBackground, hmiData.colorStatusBg);
+  TERN_(PREVENT_COLD_EXTRUSION, applyExtMinT());
   feedrate_percentage = 100;
-  TERN_(BAUD_RATE_GCODE, HMI_SetBaudRate());
+  TERN_(BAUD_RATE_GCODE, hmiSetBaudRate());
   #if ALL(LED_CONTROL_MENU, HAS_COLOR_LEDS)
     leds.set_color(
-      HMI_data.Led_Color.r,
-      HMI_data.Led_Color.g,
-      HMI_data.Led_Color.b
-      OPTARG(HAS_WHITE_LED, HMI_data.Led_Color.w)
+      hmiData.ledColor.r,
+      hmiData.ledColor.g,
+      hmiData.ledColor.b
+      OPTARG(HAS_WHITE_LED, hmiData.ledColor.w)
     );
     leds.update();
   #endif
 }
 
 // Initialize or re-initialize the LCD
 void MarlinUI::init_lcd() {
   delay(750);   // Wait to wakeup screen
   const bool hs = dwinHandshake(); UNUSED(hs);
   dwinFrameSetDir(1);
   dwinJPGCacheTo1(Language_English);
   encoderConfiguration();
 }
 
 void dwinInitScreen() {
-  DWIN_SetColorDefaults();
-  HMI_Init();   // Draws boot screen
+  dwinSetColorDefaults();
+  hmiInit();   // Draws boot screen
   DWINUI::init();
-  DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color, HMI_data.StatusBg_Color);
-  DWINUI::onTitleDraw = Draw_Title;
-  InitMenu();
+  DWINUI::setColors(hmiData.colorText, hmiData.colorBackground, hmiData.colorStatusBg);
+  DWINUI::onTitleDraw = drawTitle;
+  initMenu();
   checkkey = 255;
   hash_changed = true;
-  DWIN_DrawStatusLine();
-  DWIN_Draw_Dashboard();
-  Goto_Main_Menu();
+  dwinDrawStatusLine();
+  dwinDrawDashboard();
+  gotoMainMenu();
 }
 
 void MarlinUI::update() {
-  HMI_SDCardUpdate();   // SD card update
-  EachMomentUpdate();   // Status update
-  DWIN_HandleScreen();  // Rotary encoder update
+  hmiSDCardUpdate();   // SD card update
+  eachMomentUpdate();   // Status update
+  dwinHandleScreen();  // Rotary encoder update
 }
 
 void MarlinUI::refresh() { /* Nothing to see here */ }
 
 #if HAS_LCD_BRIGHTNESS
   void MarlinUI::_set_brightness() { dwinLCDBrightness(backlight ? brightness : 0); }
 #endif
 
 void MarlinUI::kill_screen(FSTR_P const lcd_error, FSTR_P const lcd_component) {
-  DWIN_Draw_Popup(ICON_BLTouch, GET_TEXT_F(MSG_PRINTER_KILLED), lcd_error);
-  DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 270, GET_TEXT_F(MSG_TURN_OFF));
+  dwinDrawPopup(ICON_BLTouch, GET_TEXT_F(MSG_PRINTER_KILLED), lcd_error);
+  DWINUI::drawCenteredString(hmiData.colorPopupTxt, 270, GET_TEXT_F(MSG_TURN_OFF));
   dwinUpdateLCD();
 }
 
-void DWIN_RebootScreen() {
-  dwinFrameClear(Color_Bg_Black);
+void dwinRebootScreen() {
+  dwinFrameClear(COLOR_BG_BLACK);
   dwinJPGShowAndCache(0);
-  DWINUI::Draw_CenteredString(Color_White, 220, GET_TEXT_F(MSG_PLEASE_WAIT_REBOOT));
+  DWINUI::drawCenteredString(COLOR_WHITE, 220, GET_TEXT_F(MSG_PLEASE_WAIT_REBOOT));
   dwinUpdateLCD();
   safe_delay(500);
 }
 
-void DWIN_RedrawDash() {
+void dwinRedrawDash() {
   hash_changed = true;
-  DWIN_DrawStatusMessage();
-  DWIN_Draw_Dashboard();
+  dwinDrawStatusMessage();
+  dwinDrawDashboard();
 }
 
-void DWIN_RedrawScreen() {
-  Draw_Main_Area();
-  DWIN_RedrawDash();
+void dwinRedrawScreen() {
+  drawMainArea();
+  dwinRedrawDash();
 }
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
-  void DWIN_Popup_Pause(FSTR_P const fmsg, uint8_t button/*=0*/) {
-    HMI_SaveProcessID(button ? WaitResponse : NothingToDo);
-    DWIN_Show_Popup(ICON_BLTouch, GET_TEXT_F(MSG_ADVANCED_PAUSE), fmsg, button);
+  void dwinPopupPause(FSTR_P const fmsg, uint8_t button/*=0*/) {
+    hmiSaveProcessID(button ? ID_WaitResponse : ID_NothingToDo);
+    dwinShowPopup(ICON_BLTouch, GET_TEXT_F(MSG_ADVANCED_PAUSE), fmsg, button);
   }
 
   void MarlinUI::pause_show_message(const PauseMessage message, const PauseMode mode/*=PAUSE_MODE_SAME*/, const uint8_t extruder/*=active_extruder*/) {
     //if (mode == PAUSE_MODE_SAME) return;
     pause_mode = mode;
     switch (message) {
-      case PAUSE_MESSAGE_PARKING:  DWIN_Popup_Pause(GET_TEXT_F(MSG_PAUSE_PRINT_PARKING));    break;                // M125
-      case PAUSE_MESSAGE_CHANGING: DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_INIT));   break;                // pause_print (M125, M600)
-      case PAUSE_MESSAGE_WAITING:  DWIN_Popup_Pause(GET_TEXT_F(MSG_ADVANCED_PAUSE_WAITING), BTN_Continue); break;
-      case PAUSE_MESSAGE_INSERT:   DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_INSERT), BTN_Continue); break;
-      case PAUSE_MESSAGE_LOAD:     DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_LOAD));   break;
-      case PAUSE_MESSAGE_UNLOAD:   DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_UNLOAD)); break;                // Unload of pause and Unload of M702
+      case PAUSE_MESSAGE_PARKING:  dwinPopupPause(GET_TEXT_F(MSG_PAUSE_PRINT_PARKING));    break;                // M125
+      case PAUSE_MESSAGE_CHANGING: dwinPopupPause(GET_TEXT_F(MSG_FILAMENT_CHANGE_INIT));   break;                // pause_print (M125, M600)
+      case PAUSE_MESSAGE_WAITING:  dwinPopupPause(GET_TEXT_F(MSG_ADVANCED_PAUSE_WAITING), BTN_Continue); break;
+      case PAUSE_MESSAGE_INSERT:   dwinPopupPause(GET_TEXT_F(MSG_FILAMENT_CHANGE_INSERT), BTN_Continue); break;
+      case PAUSE_MESSAGE_LOAD:     dwinPopupPause(GET_TEXT_F(MSG_FILAMENT_CHANGE_LOAD));   break;
+      case PAUSE_MESSAGE_UNLOAD:   dwinPopupPause(GET_TEXT_F(MSG_FILAMENT_CHANGE_UNLOAD)); break;                // Unload of pause and Unload of M702
       case PAUSE_MESSAGE_PURGE:
         #if ENABLED(ADVANCED_PAUSE_CONTINUOUS_PURGE)
-          DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_CONT_PURGE));
+          dwinPopupPause(GET_TEXT_F(MSG_FILAMENT_CHANGE_CONT_PURGE));
         #else
-          DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_PURGE));
+          dwinPopupPause(GET_TEXT_F(MSG_FILAMENT_CHANGE_PURGE));
         #endif
         break;
-      case PAUSE_MESSAGE_OPTION:   Goto_FilamentPurge(); break;
-      case PAUSE_MESSAGE_RESUME:   DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_RESUME)); break;
-      case PAUSE_MESSAGE_HEAT:     DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_HEAT), BTN_Continue);   break;
-      case PAUSE_MESSAGE_HEATING:  DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_HEATING)); break;
-      case PAUSE_MESSAGE_STATUS:   HMI_ReturnScreen(); break;                                                      // Exit from Pause, Load and Unload
+      case PAUSE_MESSAGE_OPTION:   gotoFilamentPurge(); break;
+      case PAUSE_MESSAGE_RESUME:   dwinPopupPause(GET_TEXT_F(MSG_FILAMENT_CHANGE_RESUME)); break;
+      case PAUSE_MESSAGE_HEAT:     dwinPopupPause(GET_TEXT_F(MSG_FILAMENT_CHANGE_HEAT), BTN_Continue);   break;
+      case PAUSE_MESSAGE_HEATING:  dwinPopupPause(GET_TEXT_F(MSG_FILAMENT_CHANGE_HEATING)); break;
+      case PAUSE_MESSAGE_STATUS:   hmiReturnScreen(); break;                                                      // Exit from Pause, Load and Unload
       default: break;
     }
   }
 
-  void Draw_Popup_FilamentPurge() {
-    DWIN_Draw_Popup(ICON_BLTouch, GET_TEXT_F(MSG_ADVANCED_PAUSE), GET_TEXT_F(MSG_FILAMENT_CHANGE_PURGE_CONTINUE));
-    DWINUI::Draw_Button(BTN_Purge, 26, 280);
-    DWINUI::Draw_Button(BTN_Continue, 146, 280);
-    Draw_Select_Highlight(true);
+  void drawPopupFilamentPurge() {
+    dwinDrawPopup(ICON_BLTouch, GET_TEXT_F(MSG_ADVANCED_PAUSE), GET_TEXT_F(MSG_FILAMENT_CHANGE_PURGE_CONTINUE));
+    DWINUI::drawButton(BTN_Purge, 26, 280);
+    DWINUI::drawButton(BTN_Continue, 146, 280);
+    drawSelectHighlight(true);
   }
 
-  void onClick_FilamentPurge() {
+  void onClickFilamentPurge() {
     if (hmiFlag.select_flag)
       pause_menu_response = PAUSE_RESPONSE_EXTRUDE_MORE;  // "Purge More" button
     else {
-      HMI_SaveProcessID(NothingToDo);
+      hmiSaveProcessID(ID_NothingToDo);
       pause_menu_response = PAUSE_RESPONSE_RESUME_PRINT;  // "Continue" button
     }
   }
 
-  void Goto_FilamentPurge() {
+  void gotoFilamentPurge() {
     pause_menu_response = PAUSE_RESPONSE_WAIT_FOR;
-    Goto_Popup(Draw_Popup_FilamentPurge, onClick_FilamentPurge);
+    gotoPopup(drawPopupFilamentPurge, onClickFilamentPurge);
   }
 
 #endif // ADVANCED_PAUSE_FEATURE
 
 #if HAS_MESH
-  void DWIN_MeshViewer() {
+  void dwinMeshViewer() {
     if (!leveling_is_valid())
-      DWIN_Popup_Continue(ICON_BLTouch, GET_TEXT_F(MSG_MESH_VIEWER), GET_TEXT_F(MSG_NO_VALID_MESH));
+      dwinPopupContinue(ICON_BLTouch, GET_TEXT_F(MSG_MESH_VIEWER), GET_TEXT_F(MSG_NO_VALID_MESH));
     else {
-      HMI_SaveProcessID(WaitResponse);
-      MeshViewer.Draw();
+      hmiSaveProcessID(ID_WaitResponse);
+      meshViewer.draw();
     }
   }
 #endif
 
 #if HAS_LOCKSCREEN
 
-  void DWIN_LockScreen() {
-    if (checkkey != Locked) {
+  void dwinLockScreen() {
+    if (checkkey != ID_Locked) {
       lockScreen.rprocess = checkkey;
-      checkkey = Locked;
+      checkkey = ID_Locked;
       lockScreen.init();
     }
   }
 
-  void DWIN_UnLockScreen() {
-    if (checkkey == Locked) {
+  void dwinUnLockScreen() {
+    if (checkkey == ID_Locked) {
       checkkey = lockScreen.rprocess;
-      Draw_Main_Area();
+      drawMainArea();
     }
   }
 
-  void HMI_LockScreen() {
+  void hmiLockScreen() {
     EncoderState encoder_diffState = get_encoder_state();
     if (encoder_diffState == ENCODER_DIFF_NO) return;
     lockScreen.onEncoder(encoder_diffState);
-    if (lockScreen.isUnlocked()) DWIN_UnLockScreen();
+    if (lockScreen.isUnlocked()) dwinUnLockScreen();
   }
 
 #endif // HAS_LOCKSCREEN
 
 #if HAS_GCODE_PREVIEW
 
-  void SetPreview() { Toggle_Chkb_Line(HMI_data.EnablePreview); }
+  void setPreview() { toggleCheckboxLine(hmiData.enablePreview); }
 
-  void onClick_ConfirmToPrint() {
-    DWIN_ResetStatusLine();
+  void onClickConfirmToPrint() {
+    dwinResetStatusLine();
     if (hmiFlag.select_flag) {     // Confirm
-      Goto_Main_Menu();
+      gotoMainMenu();
       return card.openAndPrintFile(card.filename);
     }
     else
-      HMI_ReturnScreen();
+      hmiReturnScreen();
   }
 
 #endif // HAS_GCODE_PREVIEW
 
-void Goto_ConfirmToPrint() {
+void gotoConfirmToPrint() {
   #if HAS_GCODE_PREVIEW
-    if (HMI_data.EnablePreview) return Goto_Popup(Preview_DrawFromSD, onClick_ConfirmToPrint);
+    if (hmiData.enablePreview) return gotoPopup(Preview_DrawFromSD, onClickConfirmToPrint);
   #endif
   card.openAndPrintFile(card.filename); // Direct print SD file
 }
 
 #if HAS_ESDIAG
-  void Draw_EndStopDiag() {
-    HMI_SaveProcessID(ESDiagProcess);
-    ESDiag.Draw();
+  void drawEndStopDiag() {
+    hmiSaveProcessID(ID_ESDiagProcess);
+    esDiag.draw();
   }
 #endif
 
 //=============================================================================
 // MENU SUBSYSTEM
 //=============================================================================
 
 // Tool functions
 
 #if ENABLED(EEPROM_SETTINGS)
 
-  void WriteEeprom() {
-    DWIN_DrawStatusLine(GET_TEXT_F(MSG_STORE_EEPROM));
+  void writeEEPROM() {
+    dwinDrawStatusLine(GET_TEXT_F(MSG_STORE_EEPROM));
     dwinUpdateLCD();
     DONE_BUZZ(settings.save());
   }
 
-  void ReadEeprom() {
+  void readEEPROM() {
     const bool success = settings.load();
-    DWIN_RedrawScreen();
+    dwinRedrawScreen();
     DONE_BUZZ(success);
   }
 
-  void ResetEeprom() {
+  void resetEEPROM() {
     settings.reset();
-    DWIN_RedrawScreen();
+    dwinRedrawScreen();
     DONE_BUZZ(true);
   }
 
   #if HAS_MESH
-    void SaveMesh() { TERN(AUTO_BED_LEVELING_UBL, UBLMeshSave(), WriteEeprom()); }
+    void saveMesh() { TERN(AUTO_BED_LEVELING_UBL, ublMeshSave(), writeEEPROM()); }
   #endif
 
 #endif // EEPROM_SETTINGS
 
 // Reset Printer
-void RebootPrinter() {
+void rebootPrinter() {
   wait_for_heatup = wait_for_user = false;    // Stop waiting for heating/user
   thermalManager.disable_all_heaters();
   planner.finish_and_disable();
-  DWIN_RebootScreen();
+  dwinRebootScreen();
   hal.reboot();
 }
 
-void Goto_Info_Menu() {
-  Draw_Info_Menu();
+void gotoInfoMenu() {
+  drawInfoMenu();
   dwinUpdateLCD();
-  HMI_SaveProcessID(WaitResponse);
+  hmiSaveProcessID(ID_WaitResponse);
 }
 
-void DisableMotors() { queue.inject(F("M84")); }
+void disableMotors() { queue.inject(F("M84")); }
 
-void AutoLev() {   // Always reacquire the Z "home" position
+void autoLevel() {   // Always reacquire the Z "home" position
   queue.inject(F(TERN(AUTO_BED_LEVELING_UBL, "G29P1", "G29")));
 }
 
-void AutoHome() { queue.inject_P(G28_STR); }
+void autoHome() { queue.inject_P(G28_STR); }
 
 #if ENABLED(INDIVIDUAL_AXIS_HOMING_SUBMENU)
-  void HomeX() { queue.inject(F("G28X")); }
-  void HomeY() { queue.inject(F("G28Y")); }
-  void HomeZ() { queue.inject(F("G28Z")); }
+  void homeX() { queue.inject(F("G28X")); }
+  void homeY() { queue.inject(F("G28Y")); }
+  void homeZ() { queue.inject(F("G28Z")); }
   #if ALL(INDIVIDUAL_AXIS_HOMING_SUBMENU, MESH_BED_LEVELING)
-    void ApplyZAfterHoming() { HMI_data.z_after_homing = MenuData.Value; };
-    void SetZAfterHoming() { SetIntOnClick(0, 20, HMI_data.z_after_homing, ApplyZAfterHoming); }
+    void applyZAfterHoming() { hmiData.zAfterHoming = menuData.value; };
+    void setZAfterHoming() { setIntOnClick(0, 20, hmiData.zAfterHoming, applyZAfterHoming); }
   #endif
 #endif
 
 #if HAS_ZOFFSET_ITEM
 
-  void ApplyZOffset() { TERN_(EEPROM_SETTINGS, settings.save()); }
-  void LiveZOffset() {
+  void applyZOffset() { TERN_(EEPROM_SETTINGS, settings.save()); }
+  void liveZOffset() {
     #if ANY(BABYSTEP_ZPROBE_OFFSET, JUST_BABYSTEP)
-      const_float_t step_zoffset = round((MenuData.Value / 100.0f) * planner.settings.axis_steps_per_mm[Z_AXIS]) - babystep.accum;
+      const_float_t step_zoffset = round((menuData.value / 100.0f) * planner.settings.axis_steps_per_mm[Z_AXIS]) - babystep.accum;
       if (BABYSTEP_ALLOWED()) babystep.add_steps(Z_AXIS, step_zoffset);
     #endif
   }
-  void SetZOffset() {
+  void setZOffset() {
     #if ANY(BABYSTEP_ZPROBE_OFFSET, JUST_BABYSTEP)
       babystep.accum = round(planner.settings.axis_steps_per_mm[Z_AXIS] * BABY_Z_VAR);
     #endif
-    SetPFloatOnClick(Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX, 2, ApplyZOffset, LiveZOffset);
+    setPFloatOnClick(Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX, 2, applyZOffset, liveZOffset);
   }
 
-  void SetMoveZto0() {
+  void setMoveZto0() {
     #if ENABLED(Z_SAFE_HOMING)
       gcode.process_subcommands_now(MString<54>(F("G28XYO\nG28Z\nG0F5000X"), Z_SAFE_HOMING_X_POINT, F("Y"), Z_SAFE_HOMING_Y_POINT, F("\nG0Z0F300\nM400")));
     #else
       TERN_(HAS_LEVELING, set_bed_leveling_enabled(false));
       gcode.process_subcommands_now(F("G28Z\nG0Z0F300\nM400"));
     #endif
     ui.reset_status();
     DONE_BUZZ(true);
   }
 
   #if !HAS_BED_PROBE
-    void HomeZandDisable() {
-      SetMoveZto0();
-      DisableMotors();
+    void homeZAndDisable() {
+      setMoveZto0();
+      disableMotors();
     }
   #endif
 
 #endif // HAS_ZOFFSET_ITEM
 
 #if HAS_PREHEAT
-  #define _DoPreheat(N) void DoPreheat##N() { ui.preheat_all(N-1); }\
+  #define _doPreheat(N) void DoPreheat##N() { ui.preheat_all(N-1); }\
                         void DoPreheatHotend##N() { ui.preheat_hotend(N-1); }
-  REPEAT_1(PREHEAT_COUNT, _DoPreheat)
+  REPEAT_1(PREHEAT_COUNT, _doPreheat)
 #endif
 
-void DoCoolDown() { thermalManager.cooldown(); }
+void doCoolDown() { thermalManager.cooldown(); }
 
-void SetLanguage() {
-  HMI_ToggleLanguage();
-  CurrentMenu = nullptr;  // Invalidate menu to full redraw
-  Draw_Prepare_Menu();
+void setLanguage() {
+  hmiToggleLanguage();
+  currentMenu = nullptr;  // Invalidate menu to full redraw
+  drawPrepareMenu();
 }
 
-bool EnableLiveMove = false;
-void SetLiveMove() { Toggle_Chkb_Line(EnableLiveMove); }
-void AxisMove(AxisEnum axis) {
+bool enableLiveMove = false;
+void setLiveMove() { toggleCheckboxLine(enableLiveMove); }
+void axisMove(AxisEnum axis) {
   #if HAS_HOTEND
     if (axis == E_AXIS && thermalManager.tooColdToExtrude(0)) {
       gcode.process_subcommands_now(F("G92E0"));  // Reset extruder position
-      return DWIN_Popup_Confirm(ICON_TempTooLow, GET_TEXT_F(MSG_HOTEND_TOO_COLD), GET_TEXT_F(MSG_PLEASE_PREHEAT));
+      return dwinPopupConfirm(ICON_TempTooLow, GET_TEXT_F(MSG_HOTEND_TOO_COLD), GET_TEXT_F(MSG_PLEASE_PREHEAT));
     }
   #endif
   planner.synchronize();
   if (!planner.is_full()) planner.buffer_line(current_position, manual_feedrate_mm_s[axis]);
 }
-void LiveMove() {
-  if (!EnableLiveMove) return;
-  *MenuData.P_Float = MenuData.Value / MINUNITMULT;
-  AxisMove(HMI_value.axis);
+void liveMove() {
+  if (!enableLiveMove) return;
+  *menuData.floatPtr = menuData.value / MINUNITMULT;
+  axisMove(hmiValue.axis);
 }
-void ApplyMove() {
-  if (EnableLiveMove) return;
-  AxisMove(HMI_value.axis);
+void applyMove() {
+  if (enableLiveMove) return;
+  axisMove(hmiValue.axis);
 }
 
-void SetMoveX() { HMI_value.axis = X_AXIS; SetPFloatOnClick(X_MIN_POS, X_MAX_POS, UNITFDIGITS, ApplyMove, LiveMove); }
-void SetMoveY() { HMI_value.axis = Y_AXIS; SetPFloatOnClick(Y_MIN_POS, Y_MAX_POS, UNITFDIGITS, ApplyMove, LiveMove); }
-void SetMoveZ() { HMI_value.axis = Z_AXIS; SetPFloatOnClick(Z_MIN_POS, Z_MAX_POS, UNITFDIGITS, ApplyMove, LiveMove); }
+void setMoveX() { hmiValue.axis = X_AXIS; setPFloatOnClick(X_MIN_POS, X_MAX_POS, UNITFDIGITS, applyMove, liveMove); }
+void setMoveY() { hmiValue.axis = Y_AXIS; setPFloatOnClick(Y_MIN_POS, Y_MAX_POS, UNITFDIGITS, applyMove, liveMove); }
+void setMoveZ() { hmiValue.axis = Z_AXIS; setPFloatOnClick(Z_MIN_POS, Z_MAX_POS, UNITFDIGITS, applyMove, liveMove); }
 
 #if HAS_HOTEND
-  void SetMoveE() {
+  void setMoveE() {
     const float e_min = current_position.e - (EXTRUDE_MAXLENGTH),
                 e_max = current_position.e + (EXTRUDE_MAXLENGTH);
-    HMI_value.axis = E_AXIS; SetPFloatOnClick(e_min, e_max, UNITFDIGITS, ApplyMove, LiveMove);
+    hmiValue.axis = E_AXIS; setPFloatOnClick(e_min, e_max, UNITFDIGITS, applyMove, liveMove);
   }
 #endif
 
 #if ENABLED(POWER_LOSS_RECOVERY)
-  void SetPwrLossr() {
-    Toggle_Chkb_Line(recovery.enabled);
+  void setPwrLossr() {
+    toggleCheckboxLine(recovery.enabled);
     recovery.changed();
   }
 #endif
 
 #if ENABLED(BAUD_RATE_GCODE)
-  void HMI_SetBaudRate() { HMI_data.Baud115K ? SetBaud115K() : SetBaud250K(); }
-  void SetBaudRate() {
-    HMI_data.Baud115K ^= true;
-    HMI_SetBaudRate();
-    Draw_Chkb_Line(CurrentMenu->line(), HMI_data.Baud115K);
+  void hmiSetBaudRate() { hmiData.baud115K ? setBaud115K() : setBaud250K(); }
+  void setBaudRate() {
+    hmiData.baud115K ^= true;
+    hmiSetBaudRate();
+    drawCheckboxLine(currentMenu->line(), hmiData.baud115K);
     dwinUpdateLCD();
   }
-  void SetBaud115K() { queue.inject(F("M575 P0 B115200")); HMI_data.Baud115K = true; }
-  void SetBaud250K() { queue.inject(F("M575 P0 B250000")); HMI_data.Baud115K = false; }
+  void setBaud115K() { queue.inject(F("M575 P0 B115200")); hmiData.baud115K = true; }
+  void setBaud250K() { queue.inject(F("M575 P0 B250000")); hmiData.baud115K = false; }
 #endif
 
 #if HAS_LCD_BRIGHTNESS
-  void ApplyBrightness() { ui.set_brightness(MenuData.Value); }
-  void LiveBrightness() { dwinLCDBrightness(MenuData.Value); }
-  void SetBrightness() { SetIntOnClick(LCD_BRIGHTNESS_MIN, LCD_BRIGHTNESS_MAX, ui.brightness, ApplyBrightness, LiveBrightness); }
-  void TurnOffBacklight() { HMI_SaveProcessID(WaitResponse); ui.set_brightness(0); DWIN_RedrawScreen(); }
+  void applyBrightness() { ui.set_brightness(menuData.value); }
+  void liveBrightness() { dwinLCDBrightness(menuData.value); }
+  void setBrightness() { setIntOnClick(LCD_BRIGHTNESS_MIN, LCD_BRIGHTNESS_MAX, ui.brightness, applyBrightness, liveBrightness); }
+  void turnOffBacklight() { hmiSaveProcessID(ID_WaitResponse); ui.set_brightness(0); dwinRedrawScreen(); }
 #endif
 
 #if ENABLED(CASE_LIGHT_MENU)
-  void SetCaseLight() {
-    Toggle_Chkb_Line(caselight.on);
+  void setCaseLight() {
+    toggleCheckboxLine(caselight.on);
     caselight.update_enabled();
   }
   #if ENABLED(CASELIGHT_USES_BRIGHTNESS)
-    void LiveCaseLightBrightness() { caselight.brightness = MenuData.Value; caselight.update_brightness(); }
-    void SetCaseLightBrightness() { SetIntOnClick(0, 255, caselight.brightness, nullptr, LiveCaseLightBrightness); }
+    void liveCaseLightBrightness() { caselight.brightness = menuData.value; caselight.update_brightness(); }
+    void setCaseLightBrightness() { setIntOnClick(0, 255, caselight.brightness, nullptr, liveCaseLightBrightness); }
   #endif
 #endif
 
 #if ENABLED(LED_CONTROL_MENU)
   #if !ALL(CASE_LIGHT_MENU, CASE_LIGHT_USE_NEOPIXEL)
-    void SetLedStatus() {
+    void setLedStatus() {
       leds.toggle();
-      Show_Chkb_Line(leds.lights_on);
+      showCheckboxLine(leds.lights_on);
     }
   #endif
   #if HAS_COLOR_LEDS
-    void ApplyLEDColor() {
-      HMI_data.Led_Color = LEDColor( {leds.color.r, leds.color.g, leds.color.b OPTARG(HAS_WHITE_LED, HMI_data.Led_Color.w) } );
-    }
-    void LiveLEDColor(uint8_t *color) { *color = MenuData.Value; leds.update(); }
-    void LiveLEDColorR() { LiveLEDColor(&leds.color.r); }
-    void LiveLEDColorG() { LiveLEDColor(&leds.color.g); }
-    void LiveLEDColorB() { LiveLEDColor(&leds.color.b); }
-    void SetLEDColorR() { SetIntOnClick(0, 255, leds.color.r, ApplyLEDColor, LiveLEDColorR); }
-    void SetLEDColorG() { SetIntOnClick(0, 255, leds.color.g, ApplyLEDColor, LiveLEDColorG); }
-    void SetLEDColorB() { SetIntOnClick(0, 255, leds.color.b, ApplyLEDColor, LiveLEDColorB); }
+    void applyLEDColor() {
+      hmiData.ledColor = LEDColor( {leds.color.r, leds.color.g, leds.color.b OPTARG(HAS_WHITE_LED, hmiData.ledColor.w) } );
+    }
+    void liveLEDColor(uint8_t *color) { *color = menuData.value; leds.update(); }
+    void liveLEDColorR() { liveLEDColor(&leds.color.r); }
+    void liveLEDColorG() { liveLEDColor(&leds.color.g); }
+    void liveLEDColorB() { liveLEDColor(&leds.color.b); }
+    void setLEDColorR() { setIntOnClick(0, 255, leds.color.r, applyLEDColor, liveLEDColorR); }
+    void setLEDColorG() { setIntOnClick(0, 255, leds.color.g, applyLEDColor, liveLEDColorG); }
+    void setLEDColorB() { setIntOnClick(0, 255, leds.color.b, applyLEDColor, liveLEDColorB); }
     #if HAS_WHITE_LED
-      void LiveLEDColorW() { LiveLEDColor(&leds.color.w); }
-      void SetLEDColorW() { SetIntOnClick(0, 255, leds.color.w, ApplyLEDColor, LiveLEDColorW); }
+      void liveLEDColorW() { liveLEDColor(&leds.color.w); }
+      void setLEDColorW() { setIntOnClick(0, 255, leds.color.w, applyLEDColor, liveLEDColorW); }
     #endif
   #endif
 #endif
 
 #if ENABLED(SOUND_MENU_ITEM)
-  void SetEnableSound() {
-    Toggle_Chkb_Line(ui.sound_on);
+  void setEnableSound() {
+    toggleCheckboxLine(ui.sound_on);
   }
 #endif
 
 #if HAS_HOME_OFFSET
-  void ApplyHomeOffset() { set_home_offset(HMI_value.axis, MenuData.Value / MINUNITMULT); }
-  void SetHomeOffsetX() { HMI_value.axis = X_AXIS; SetPFloatOnClick(-50, 50, UNITFDIGITS, ApplyHomeOffset); }
-  void SetHomeOffsetY() { HMI_value.axis = Y_AXIS; SetPFloatOnClick(-50, 50, UNITFDIGITS, ApplyHomeOffset); }
-  void SetHomeOffsetZ() { HMI_value.axis = Z_AXIS; SetPFloatOnClick( -2,  2, UNITFDIGITS, ApplyHomeOffset); }
+  void applyHomeOffset() { set_home_offset(hmiValue.axis, menuData.value / MINUNITMULT); }
+  void setHomeOffsetX() { hmiValue.axis = X_AXIS; setPFloatOnClick(-50, 50, UNITFDIGITS, applyHomeOffset); }
+  void setHomeOffsetY() { hmiValue.axis = Y_AXIS; setPFloatOnClick(-50, 50, UNITFDIGITS, applyHomeOffset); }
+  void setHomeOffsetZ() { hmiValue.axis = Z_AXIS; setPFloatOnClick( -2,  2, UNITFDIGITS, applyHomeOffset); }
 #endif
 
 #if HAS_BED_PROBE
-  void SetProbeOffsetX() { SetPFloatOnClick(-60, 60, UNITFDIGITS); }
-  void SetProbeOffsetY() { SetPFloatOnClick(-60, 60, UNITFDIGITS); }
-  void SetProbeOffsetZ() { SetPFloatOnClick(-10, 10, 2); }
-  void ProbeTest() {
+  void setProbeOffsetX() { setPFloatOnClick(-60, 60, UNITFDIGITS); }
+  void setProbeOffsetY() { setPFloatOnClick(-60, 60, UNITFDIGITS); }
+  void setProbeOffsetZ() { setPFloatOnClick(-10, 10, 2); }
+  void probeTest() {
     LCD_MESSAGE(MSG_M48_TEST);
     queue.inject(F("G28O\nM48 P10"));
   }
-  void ProbeStow() { probe.stow(); }
-  void ProbeDeploy() { probe.deploy(); }
+  void probeStow() { probe.stow(); }
+  void probeDeploy() { probe.deploy(); }
 
   #if HAS_BLTOUCH_HS_MODE
-    void SetHSMode() { Toggle_Chkb_Line(bltouch.high_speed_mode); }
+    void setHSMode() { toggleCheckboxLine(bltouch.high_speed_mode); }
   #endif
 
 #endif
 
 #if HAS_FILAMENT_SENSOR
-  void SetRunoutEnable() {
+  void setRunoutEnable() {
     runout.reset();
-    Toggle_Chkb_Line(runout.enabled);
+    toggleCheckboxLine(runout.enabled);
   }
   #if HAS_FILAMENT_RUNOUT_DISTANCE
-    void ApplyRunoutDistance() { runout.set_runout_distance(MenuData.Value / MINUNITMULT); }
-    void SetRunoutDistance() { SetFloatOnClick(0, 999, UNITFDIGITS, runout.runout_distance(), ApplyRunoutDistance); }
+    void applyRunoutDistance() { runout.set_runout_distance(menuData.value / MINUNITMULT); }
+    void setRunoutDistance() { setFloatOnClick(0, 999, UNITFDIGITS, runout.runout_distance(), applyRunoutDistance); }
   #endif
 #endif
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
-  void SetFilLoad()   { SetPFloatOnClick(0, MAX_LOAD_UNLOAD, UNITFDIGITS); }
-  void SetFilUnload() { SetPFloatOnClick(0, MAX_LOAD_UNLOAD, UNITFDIGITS); }
+  void setFilLoad()   { setPFloatOnClick(0, MAX_LOAD_UNLOAD, UNITFDIGITS); }
+  void setFilUnload() { setPFloatOnClick(0, MAX_LOAD_UNLOAD, UNITFDIGITS); }
 #endif
 
 #if ENABLED(PREVENT_COLD_EXTRUSION)
-  void ApplyExtMinT() { thermalManager.extrude_min_temp = HMI_data.ExtMinT; thermalManager.allow_cold_extrude = (HMI_data.ExtMinT == 0); }
-  void SetExtMinT() { SetPIntOnClick(MIN_ETEMP, MAX_ETEMP, ApplyExtMinT); }
+  void applyExtMinT() { thermalManager.extrude_min_temp = hmiData.extMinT; thermalManager.allow_cold_extrude = (hmiData.extMinT == 0); }
+  void setExtMinT() { setPIntOnClick(MIN_ETEMP, MAX_ETEMP, applyExtMinT); }
 #endif
 
-void SetSpeed() { SetPIntOnClick(MIN_PRINT_SPEED, MAX_PRINT_SPEED); }
+void setSpeed() { setPIntOnClick(MIN_PRINT_SPEED, MAX_PRINT_SPEED); }
 
 #if HAS_HOTEND
-  void ApplyHotendTemp() { thermalManager.setTargetHotend(MenuData.Value, 0); }
-  void SetHotendTemp() { SetIntOnClick(MIN_ETEMP, MAX_ETEMP, thermalManager.degTargetHotend(0), ApplyHotendTemp); }
+  void applyHotendTemp() { thermalManager.setTargetHotend(menuData.value, 0); }
+  void setHotendTemp() { setIntOnClick(MIN_ETEMP, MAX_ETEMP, thermalManager.degTargetHotend(0), applyHotendTemp); }
 #endif
 
 #if HAS_HEATED_BED
-  void ApplyBedTemp() { thermalManager.setTargetBed(MenuData.Value); }
-  void SetBedTemp() { SetIntOnClick(MIN_BEDTEMP, MAX_BEDTEMP, thermalManager.degTargetBed(), ApplyBedTemp); }
+  void applyBedTemp() { thermalManager.setTargetBed(menuData.value); }
+  void setBedTemp() { setIntOnClick(MIN_BEDTEMP, MAX_BEDTEMP, thermalManager.degTargetBed(), applyBedTemp); }
 #endif
 
 #if HAS_FAN
-  void ApplyFanSpeed() { thermalManager.set_fan_speed(0, MenuData.Value); }
-  void SetFanSpeed() { SetIntOnClick(0, 255, thermalManager.fan_speed[0], ApplyFanSpeed); }
+  void applyFanSpeed() { thermalManager.set_fan_speed(0, menuData.value); }
+  void setFanSpeed() { setIntOnClick(0, 255, thermalManager.fan_speed[0], applyFanSpeed); }
 #endif
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
 
-  void ChangeFilament() {
-    HMI_SaveProcessID(NothingToDo);
+  void changeFilament() {
+    hmiSaveProcessID(ID_NothingToDo);
     queue.inject(F("M600 B2"));
   }
 
   #if ENABLED(NOZZLE_PARK_FEATURE)
-    void ParkHead() {
+    void parkHead() {
       LCD_MESSAGE(MSG_FILAMENT_PARK_ENABLED);
       queue.inject(F("G28O\nG27"));
     }
   #endif
 
   #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
-    void UnloadFilament() {
+    void unloadFilament() {
       LCD_MESSAGE(MSG_FILAMENTUNLOAD);
       queue.inject(F("M702 Z20"));
     }
 
-    void LoadFilament() {
+    void loadFilament() {
       LCD_MESSAGE(MSG_FILAMENTLOAD);
       queue.inject(F("M701 Z20"));
     }
   #endif
 
 #endif // ADVANCED_PAUSE_FEATURE
 
-void SetFlow() { SetPIntOnClick(MIN_PRINT_FLOW, MAX_PRINT_FLOW, []{ planner.refresh_e_factor(0); }); }
+void setFlow() { setPIntOnClick(MIN_PRINT_FLOW, MAX_PRINT_FLOW, []{ planner.refresh_e_factor(0); }); }
 
 // Bed Tramming
 
 #if ENABLED(LCD_BED_TRAMMING)
 
-  void TramXY(const uint8_t point, float &x, float &y) {
+  void tramXY(const uint8_t point, float &x, float &y) {
     switch (point) {
       case 0:
         LCD_MESSAGE(MSG_TRAM_FL);
         x = bed_tramming_inset_lfbr[0];
         y = bed_tramming_inset_lfbr[1];
         break;
       case 1:
         LCD_MESSAGE(MSG_TRAM_FR);
         x = X_BED_SIZE - bed_tramming_inset_lfbr[2];
         y = bed_tramming_inset_lfbr[1];
@@ -2310,28 +2314,28 @@ void SetFlow() { SetPIntOnClick(MIN_PRINT_FLOW, MAX_PRINT_FLOW, []{ planner.refr
         case 4:
           LCD_MESSAGE(MSG_TRAM_C);
           x = X_CENTER; y = Y_CENTER;
           break;
       #endif
     }
   }
 
   #if HAS_BED_PROBE
 
-    float Tram(const uint8_t point) {
+    float tram(const uint8_t point) {
       static bool inLev = false;
       if (inLev) return NAN;
 
       float xpos = 0, ypos = 0, zval = 0;
-      TramXY(point, xpos, ypos);
+      tramXY(point, xpos, ypos);
 
-      if (HMI_data.FullManualTramming) {
+      if (hmiData.fullManualTramming) {
         queue.inject(MString<100>(
           F("M420S0\nG28O\nG90\nG0F300Z5\nG0F5000X"), p_float_t(xpos, 1), 'Y', p_float_t(ypos, 1), F("\nG0F300Z0")
         ));
       }
       else {
         // AUTO_BED_LEVELING_BILINEAR does not define MESH_INSET
         #ifndef MESH_MIN_X
           #define MESH_MIN_X (_MAX(X_MIN_BED + PROBING_MARGIN, X_MIN_POS))
         #endif
         #ifndef MESH_MIN_Y
@@ -2354,73 +2358,73 @@ void SetFlow() { SetPIntOnClick(MIN_PRINT_FLOW, MAX_PRINT_FLOW, []{ planner.refr
           LCD_MESSAGE(MSG_ZPROBE_OUT);
         else
           ui.set_status(TS(F("X:"), p_float_t(xpos, 1), F(" Y:"), p_float_t(ypos, 1), F(" Z:")));
         inLev = false;
       }
       return zval;
     }
 
   #else
 
-    void Tram(const uint8_t point) {
+    void tram(const uint8_t point) {
       float xpos = 0, ypos = 0;
-      TramXY(point, xpos, ypos);
+      tramXY(point, xpos, ypos);
       queue.inject(MString<100>(
         F("M420S0\nG28O\nG90\nG0F300Z5\nG0F5000X"), p_float_t(xpos, 1), 'Y', p_float_t(ypos, 1), F("\nG0F300Z0")
       ));
     }
 
   #endif
 
-  inline void TramFL() { Tram(0); }
-  inline void TramFR() { Tram(1); }
-  inline void TramBR() { Tram(2); }
-  inline void TramBL() { Tram(3); }
+  inline void tramFL() { tram(0); }
+  inline void tramFR() { tram(1); }
+  inline void tramBR() { tram(2); }
+  inline void tramBL() { tram(3); }
   #if ENABLED(BED_TRAMMING_INCLUDE_CENTER)
-    inline void TramC() { Tram(4); }
+    inline void tramC() { tram(4); }
   #endif
 
   #if HAS_BED_PROBE && HAS_MESH
 
-    void Trammingwizard() {
-      if (HMI_data.FullManualTramming) {
+    void trammingwizard() {
+      if (hmiData.fullManualTramming) {
         LCD_MESSAGE_F("Disable manual tramming");
         return;
       }
       bed_mesh_t zval = {0};
-      zval[0][0] = TramFL();
-      checkkey = NothingToDo;
-      MeshViewer.DrawMesh(zval, 2, 2);
-      zval[1][0] = TramFR();
-      MeshViewer.DrawMesh(zval, 2, 2);
-      zval[1][1] = TramBR();
-      MeshViewer.DrawMesh(zval, 2, 2);
-      zval[0][1] = TramBL();
-      MeshViewer.DrawMesh(zval, 2, 2);
-
-      DWINUI::Draw_CenteredString(140, F("Calculating average"));
-      DWINUI::Draw_CenteredString(160, F("and relative heights"));
+      zval[0][0] = tramFL();
+      checkkey = ID_NothingToDo;
+      meshViewer.drawMesh(zval, 2, 2);
+      zval[1][0] = tramFR();
+      meshViewer.drawMesh(zval, 2, 2);
+      zval[1][1] = tramBR();
+      meshViewer.drawMesh(zval, 2, 2);
+      zval[0][1] = tramBL();
+      meshViewer.drawMesh(zval, 2, 2);
+
+      DWINUI::drawCenteredString(140, F("Calculating average"));
+      DWINUI::drawCenteredString(160, F("and relative heights"));
       safe_delay(1000);
       float avg = 0.0f;
       for (uint8_t x = 0; x < 2; ++x) for (uint8_t y = 0; y < 2; ++y) avg += zval[x][y];
       avg /= 4.0f;
       for (uint8_t x = 0; x < 2; ++x) for (uint8_t y = 0; y < 2; ++y) zval[x][y] -= avg;
-      MeshViewer.DrawMesh(zval, 2, 2);
+      meshViewer.drawMesh(zval, 2, 2);
       ui.reset_status();
 
       #ifndef BED_TRAMMING_PROBE_TOLERANCE
         #define BED_TRAMMING_PROBE_TOLERANCE 0.05
       #endif
 
-      if (ABS(MeshViewer.max - MeshViewer.min) < BED_TRAMMING_PROBE_TOLERANCE) {
-        DWINUI::Draw_CenteredString(140, F("Corners leveled"));
-        DWINUI::Draw_CenteredString(160, F("Tolerance achieved!"));
+      if (ABS(meshViewer.max - meshViewer.min) < BED_TRAMMING_PROBE_TOLERANCE) {
+        DWINUI::drawCenteredString(140, F("Corners leveled"));
+        DWINUI::drawCenteredString(160, F("Tolerance achieved!"));
       }
       else {
         uint8_t p = 0;
         float max = 0;
         FSTR_P plabel;
         bool s = true;
         for (uint8_t x = 0; x < 2; ++x) for (uint8_t y = 0; y < 2; ++y) {
           const float d = ABS(zval[x][y]);
           if (max < d) {
             s = (zval[x][y] >= 0);
@@ -2428,1600 +2432,1600 @@ void SetFlow() { SetPIntOnClick(MIN_PRINT_FLOW, MAX_PRINT_FLOW, []{ planner.refr
             p = x + 2 * y;
           }
         }
         switch (p) {
           case 0b00 : plabel = GET_TEXT_F(MSG_TRAM_FL); break;
           case 0b01 : plabel = GET_TEXT_F(MSG_TRAM_FR); break;
           case 0b10 : plabel = GET_TEXT_F(MSG_TRAM_BL); break;
           case 0b11 : plabel = GET_TEXT_F(MSG_TRAM_BR); break;
           default   : plabel = F(""); break;
         }
-        DWINUI::Draw_CenteredString(120, F("Corners not leveled"));
-        DWINUI::Draw_CenteredString(140, F("Knob adjustment required"));
-        DWINUI::Draw_CenteredString(Color_Green, 160, s ? F("Lower") : F("Raise"));
-        DWINUI::Draw_CenteredString(Color_Green, 180, plabel);
+        DWINUI::drawCenteredString(120, F("Corners not leveled"));
+        DWINUI::drawCenteredString(140, F("Knob adjustment required"));
+        DWINUI::drawCenteredString(COLOR_GREEN, 160, s ? F("Lower") : F("Raise"));
+        DWINUI::drawCenteredString(COLOR_GREEN, 180, plabel);
       }
-      DWINUI::Draw_Button(BTN_Continue, 86, 305);
-      checkkey = Menu;
-      HMI_SaveProcessID(WaitResponse);
+      DWINUI::drawButton(BTN_Continue, 86, 305);
+      checkkey = ID_Menu;
+      hmiSaveProcessID(ID_WaitResponse);
     }
 
-    void SetManualTramming() {
-      Toggle_Chkb_Line(HMI_data.FullManualTramming);
+    void setManualTramming() {
+      toggleCheckboxLine(hmiData.fullManualTramming);
     }
 
   #endif // HAS_BED_PROBE && HAS_MESH
 
 #endif // LCD_BED_TRAMMING
 
 #if ENABLED(MESH_BED_LEVELING)
 
-  void ManualMeshStart() {
+  void manualMeshStart() {
     LCD_MESSAGE(MSG_UBL_BUILD_MESH_MENU);
     gcode.process_subcommands_now(F("G28XYO\nG28Z\nM211S0\nG29S1"));
     #ifdef MANUAL_PROBE_START_Z
-      const uint8_t line = CurrentMenu->line(MMeshMoveZItem->pos);
-      DWINUI::Draw_Signed_Float(HMI_data.Text_Color, HMI_data.Background_Color, 3, 2, VALX - 2 * DWINUI::fontWidth(DWIN_FONT_MENU), MBASE(line), MANUAL_PROBE_START_Z);
+      const uint8_t line = currentMenu->line(mMeshMoveZItem->pos);
+      DWINUI::drawSignedFloat(hmiData.colorText, hmiData.colorBackground, 3, 2, VALX - 2 * DWINUI::fontWidth(DWIN_FONT_MENU), MBASE(line), MANUAL_PROBE_START_Z);
     #endif
   }
 
-  void LiveMeshMoveZ() {
-    *MenuData.P_Float = MenuData.Value / POW(10, 2);
+  void liveMeshMoveZ() {
+    *menuData.floatPtr = menuData.value / POW(10, 2);
     if (!planner.is_full()) {
       planner.synchronize();
       planner.buffer_line(current_position, manual_feedrate_mm_s[Z_AXIS]);
     }
   }
-  void SetMMeshMoveZ() { SetPFloatOnClick(-1, 1, 2, planner.synchronize, LiveMeshMoveZ); }
+  void setMMeshMoveZ() { setPFloatOnClick(-1, 1, 2, planner.synchronize, liveMeshMoveZ); }
 
-  void ManualMeshContinue() {
+  void manualMeshContinue() {
     gcode.process_subcommands_now(F("G29S2"));
-    MMeshMoveZItem->redraw();
+    mMeshMoveZItem->redraw();
   }
 
-  void ManualMeshSave() {
+  void manualMeshSave() {
     LCD_MESSAGE(MSG_UBL_STORAGE_MESH_MENU);
     queue.inject(F("M211S1\nM500"));
   }
 
 #endif // MESH_BED_LEVELING
 
 #if HAS_PREHEAT
   #if HAS_HOTEND
-    void SetPreheatEndTemp() { SetPIntOnClick(MIN_ETEMP, MAX_ETEMP); }
+    void setPreheatEndTemp() { setPIntOnClick(MIN_ETEMP, MAX_ETEMP); }
   #endif
   #if HAS_HEATED_BED
-    void SetPreheatBedTemp() { SetPIntOnClick(MIN_BEDTEMP, MAX_BEDTEMP); }
+    void setPreheatBedTemp() { setPIntOnClick(MIN_BEDTEMP, MAX_BEDTEMP); }
   #endif
   #if HAS_FAN
-    void SetPreheatFanSpeed() { SetPIntOnClick(0, 255); }
+    void setPreheatFanSpeed() { setPIntOnClick(0, 255); }
   #endif
 #endif
 
-void ApplyMaxSpeed() { planner.set_max_feedrate(HMI_value.axis, MenuData.Value / MINUNITMULT); }
+void applyMaxSpeed() { planner.set_max_feedrate(hmiValue.axis, menuData.value / MINUNITMULT); }
 #if HAS_X_AXIS
-  void SetMaxSpeedX() { HMI_value.axis = X_AXIS, SetFloatOnClick(min_feedrate_edit_values.x, max_feedrate_edit_values.x, UNITFDIGITS, planner.settings.max_feedrate_mm_s[X_AXIS], ApplyMaxSpeed); }
+  void setMaxSpeedX() { hmiValue.axis = X_AXIS, setFloatOnClick(min_feedrate_edit_values.x, max_feedrate_edit_values.x, UNITFDIGITS, planner.settings.max_feedrate_mm_s[X_AXIS], applyMaxSpeed); }
 #endif
 #if HAS_Y_AXIS
-  void SetMaxSpeedY() { HMI_value.axis = Y_AXIS, SetFloatOnClick(min_feedrate_edit_values.y, max_feedrate_edit_values.y, UNITFDIGITS, planner.settings.max_feedrate_mm_s[Y_AXIS], ApplyMaxSpeed); }
+  void setMaxSpeedY() { hmiValue.axis = Y_AXIS, setFloatOnClick(min_feedrate_edit_values.y, max_feedrate_edit_values.y, UNITFDIGITS, planner.settings.max_feedrate_mm_s[Y_AXIS], applyMaxSpeed); }
 #endif
 #if HAS_Z_AXIS
-  void SetMaxSpeedZ() { HMI_value.axis = Z_AXIS, SetFloatOnClick(min_feedrate_edit_values.z, max_feedrate_edit_values.z, UNITFDIGITS, planner.settings.max_feedrate_mm_s[Z_AXIS], ApplyMaxSpeed); }
+  void setMaxSpeedZ() { hmiValue.axis = Z_AXIS, setFloatOnClick(min_feedrate_edit_values.z, max_feedrate_edit_values.z, UNITFDIGITS, planner.settings.max_feedrate_mm_s[Z_AXIS], applyMaxSpeed); }
 #endif
 #if HAS_HOTEND
-  void SetMaxSpeedE() { HMI_value.axis = E_AXIS; SetFloatOnClick(min_feedrate_edit_values.e, max_feedrate_edit_values.e, UNITFDIGITS, planner.settings.max_feedrate_mm_s[E_AXIS], ApplyMaxSpeed); }
+  void setMaxSpeedE() { hmiValue.axis = E_AXIS; setFloatOnClick(min_feedrate_edit_values.e, max_feedrate_edit_values.e, UNITFDIGITS, planner.settings.max_feedrate_mm_s[E_AXIS], applyMaxSpeed); }
 #endif
 
-void ApplyMaxAccel() { planner.set_max_acceleration(HMI_value.axis, MenuData.Value); }
+void applyMaxAccel() { planner.set_max_acceleration(hmiValue.axis, menuData.value); }
 #if HAS_X_AXIS
-  void SetMaxAccelX() { HMI_value.axis = X_AXIS, SetIntOnClick(min_acceleration_edit_values.x, max_acceleration_edit_values.x, planner.settings.max_acceleration_mm_per_s2[X_AXIS], ApplyMaxAccel); }
+  void setMaxAccelX() { hmiValue.axis = X_AXIS, setIntOnClick(min_acceleration_edit_values.x, max_acceleration_edit_values.x, planner.settings.max_acceleration_mm_per_s2[X_AXIS], applyMaxAccel); }
 #endif
 #if HAS_Y_AXIS
-  void SetMaxAccelY() { HMI_value.axis = Y_AXIS, SetIntOnClick(min_acceleration_edit_values.y, max_acceleration_edit_values.y, planner.settings.max_acceleration_mm_per_s2[Y_AXIS], ApplyMaxAccel); }
+  void setMaxAccelY() { hmiValue.axis = Y_AXIS, setIntOnClick(min_acceleration_edit_values.y, max_acceleration_edit_values.y, planner.settings.max_acceleration_mm_per_s2[Y_AXIS], applyMaxAccel); }
 #endif
 #if HAS_Z_AXIS
-  void SetMaxAccelZ() { HMI_value.axis = Z_AXIS, SetIntOnClick(min_acceleration_edit_values.z, max_acceleration_edit_values.z, planner.settings.max_acceleration_mm_per_s2[Z_AXIS], ApplyMaxAccel); }
+  void setMaxAccelZ() { hmiValue.axis = Z_AXIS, setIntOnClick(min_acceleration_edit_values.z, max_acceleration_edit_values.z, planner.settings.max_acceleration_mm_per_s2[Z_AXIS], applyMaxAccel); }
 #endif
 #if HAS_HOTEND
-  void SetMaxAccelE() { HMI_value.axis = E_AXIS; SetIntOnClick(min_acceleration_edit_values.e, max_acceleration_edit_values.e, planner.settings.max_acceleration_mm_per_s2[E_AXIS], ApplyMaxAccel); }
+  void setMaxAccelE() { hmiValue.axis = E_AXIS; setIntOnClick(min_acceleration_edit_values.e, max_acceleration_edit_values.e, planner.settings.max_acceleration_mm_per_s2[E_AXIS], applyMaxAccel); }
 #endif
 
 #if HAS_CLASSIC_JERK
-  void ApplyMaxJerk() { planner.set_max_jerk(HMI_value.axis, MenuData.Value / MINUNITMULT); }
+  void applyMaxJerk() { planner.set_max_jerk(hmiValue.axis, menuData.value / MINUNITMULT); }
   #if HAS_X_AXIS
-    void SetMaxJerkX() { HMI_value.axis = X_AXIS, SetFloatOnClick(min_jerk_edit_values.x, max_jerk_edit_values.x, UNITFDIGITS, planner.max_jerk.x, ApplyMaxJerk); }
+    void setMaxJerkX() { hmiValue.axis = X_AXIS, setFloatOnClick(min_jerk_edit_values.x, max_jerk_edit_values.x, UNITFDIGITS, planner.max_jerk.x, applyMaxJerk); }
   #endif
   #if HAS_Y_AXIS
-    void SetMaxJerkY() { HMI_value.axis = Y_AXIS, SetFloatOnClick(min_jerk_edit_values.y, max_jerk_edit_values.y, UNITFDIGITS, planner.max_jerk.y, ApplyMaxJerk); }
+    void setMaxJerkY() { hmiValue.axis = Y_AXIS, setFloatOnClick(min_jerk_edit_values.y, max_jerk_edit_values.y, UNITFDIGITS, planner.max_jerk.y, applyMaxJerk); }
   #endif
   #if HAS_Z_AXIS
-    void SetMaxJerkZ() { HMI_value.axis = Z_AXIS, SetFloatOnClick(min_jerk_edit_values.z, max_jerk_edit_values.z, UNITFDIGITS, planner.max_jerk.z, ApplyMaxJerk); }
+    void setMaxJerkZ() { hmiValue.axis = Z_AXIS, setFloatOnClick(min_jerk_edit_values.z, max_jerk_edit_values.z, UNITFDIGITS, planner.max_jerk.z, applyMaxJerk); }
   #endif
   #if HAS_HOTEND
-    void SetMaxJerkE() { HMI_value.axis = E_AXIS; SetFloatOnClick(min_jerk_edit_values.e, max_jerk_edit_values.e, UNITFDIGITS, planner.max_jerk.e, ApplyMaxJerk); }
+    void setMaxJerkE() { hmiValue.axis = E_AXIS; setFloatOnClick(min_jerk_edit_values.e, max_jerk_edit_values.e, UNITFDIGITS, planner.max_jerk.e, applyMaxJerk); }
   #endif
 #elif HAS_JUNCTION_DEVIATION
-  void ApplyJDmm() { TERN_(LIN_ADVANCE, planner.recalculate_max_e_jerk()); }
-  void SetJDmm() { SetPFloatOnClick(MIN_JD_MM, MAX_JD_MM, 3, ApplyJDmm); }
+  void applyJDmm() { TERN_(LIN_ADVANCE, planner.recalculate_max_e_jerk()); }
+  void setJDmm() { setPFloatOnClick(MIN_JD_MM, MAX_JD_MM, 3, applyJDmm); }
 #endif
 
 #if ENABLED(LIN_ADVANCE)
-  void SetLA_K() { SetPFloatOnClick(0, 10, 3); }
+  void setLA_K() { setPFloatOnClick(0, 10, 3); }
 #endif
 
 #if HAS_X_AXIS
-  void SetStepsX() { HMI_value.axis = X_AXIS, SetPFloatOnClick( min_steps_edit_values.x, max_steps_edit_values.x, UNITFDIGITS); }
+  void setStepsX() { hmiValue.axis = X_AXIS, setPFloatOnClick( min_steps_edit_values.x, max_steps_edit_values.x, UNITFDIGITS); }
 #endif
 #if HAS_Y_AXIS
-  void SetStepsY() { HMI_value.axis = Y_AXIS, SetPFloatOnClick( min_steps_edit_values.y, max_steps_edit_values.y, UNITFDIGITS); }
+  void setStepsY() { hmiValue.axis = Y_AXIS, setPFloatOnClick( min_steps_edit_values.y, max_steps_edit_values.y, UNITFDIGITS); }
 #endif
 #if HAS_Z_AXIS
-  void SetStepsZ() { HMI_value.axis = Z_AXIS, SetPFloatOnClick( min_steps_edit_values.z, max_steps_edit_values.z, UNITFDIGITS); }
+  void setStepsZ() { hmiValue.axis = Z_AXIS, setPFloatOnClick( min_steps_edit_values.z, max_steps_edit_values.z, UNITFDIGITS); }
 #endif
 #if HAS_HOTEND
-  void SetStepsE() { HMI_value.axis = E_AXIS; SetPFloatOnClick( min_steps_edit_values.e, max_steps_edit_values.e, UNITFDIGITS); }
+  void setStepsE() { hmiValue.axis = E_AXIS; setPFloatOnClick( min_steps_edit_values.e, max_steps_edit_values.e, UNITFDIGITS); }
 #endif
 #if ENABLED(FWRETRACT)
-  void Return_FWRetract_Menu() { (PreviousMenu == FilSetMenu) ? Draw_FilSet_Menu() : Draw_Tune_Menu(); }
-  void SetRetractLength() { SetPFloatOnClick( 0, 10, UNITFDIGITS); }
-  void SetRetractSpeed()  { SetPFloatOnClick( 1, 90, UNITFDIGITS); }
-  void SetZRaise()        { SetPFloatOnClick( 0, 2, 2); }
-  void SetRecoverSpeed()  { SetPFloatOnClick( 1, 90, UNITFDIGITS); }
-  void SetAddRecover()    { SetPFloatOnClick(-5, 5, UNITFDIGITS); }
+  void returnFWRetractMenu() { (previousMenu == filSetMenu) ? drawFilSetMenu() : drawTuneMenu(); }
+  void setRetractLength() { setPFloatOnClick( 0, 10, UNITFDIGITS); }
+  void setRetractSpeed()  { setPFloatOnClick( 1, 90, UNITFDIGITS); }
+  void setZRaise()        { setPFloatOnClick( 0, 2, 2); }
+  void setRecoverSpeed()  { setPFloatOnClick( 1, 90, UNITFDIGITS); }
+  void setAddRecover()    { setPFloatOnClick(-5, 5, UNITFDIGITS); }
 #endif
 
 // Special Menuitem Drawing functions =================================================
 
-void onDrawBack(MenuItemClass* menuitem, int8_t line) {
-  if (HMI_IsChinese()) menuitem->SetFrame(1, 129, 72, 156, 84);
+void onDrawBack(MenuItem* menuitem, int8_t line) {
+  if (hmiIsChinese()) menuitem->setFrame(1, 129, 72, 156, 84);
   onDrawMenuItem(menuitem, line);
 }
 
-void onDrawTempSubMenu(MenuItemClass* menuitem, int8_t line) {
-  if (HMI_IsChinese()) menuitem->SetFrame(1,  57, 104,  84, 116);
+void onDrawTempSubMenu(MenuItem* menuitem, int8_t line) {
+  if (hmiIsChinese()) menuitem->setFrame(1,  57, 104,  84, 116);
   onDrawSubMenu(menuitem, line);
 }
 
-void onDrawMotionSubMenu(MenuItemClass* menuitem, int8_t line) {
-  if (HMI_IsChinese()) menuitem->SetFrame(1,  87, 104, 114, 116);
+void onDrawMotionSubMenu(MenuItem* menuitem, int8_t line) {
+  if (hmiIsChinese()) menuitem->setFrame(1,  87, 104, 114, 116);
   onDrawSubMenu(menuitem, line);
 }
 
 #if ENABLED(EEPROM_SETTINGS)
-  void onDrawWriteEeprom(MenuItemClass* menuitem, int8_t line) {
-    if (HMI_IsChinese()) menuitem->SetFrame(1, 117, 104, 172, 116);
+  void onDrawWriteEeprom(MenuItem* menuitem, int8_t line) {
+    if (hmiIsChinese()) menuitem->setFrame(1, 117, 104, 172, 116);
     onDrawMenuItem(menuitem, line);
   }
 
-  void onDrawReadEeprom(MenuItemClass* menuitem, int8_t line) {
-    if (HMI_IsChinese()) menuitem->SetFrame(1, 174, 103, 229, 116);
+  void onDrawReadEeprom(MenuItem* menuitem, int8_t line) {
+    if (hmiIsChinese()) menuitem->setFrame(1, 174, 103, 229, 116);
     onDrawMenuItem(menuitem, line);
   }
 
-  void onDrawResetEeprom(MenuItemClass* menuitem, int8_t line) {
-    if (HMI_IsChinese()) menuitem->SetFrame(1,   1, 118,  56, 131);
+  void onDrawResetEeprom(MenuItem* menuitem, int8_t line) {
+    if (hmiIsChinese()) menuitem->setFrame(1,   1, 118,  56, 131);
     onDrawMenuItem(menuitem, line);
   }
 #endif
 
-void onDrawInfoSubMenu(MenuItemClass* menuitem, int8_t line) {
-  if (HMI_IsChinese()) menuitem->SetFrame(1, 231, 104, 258, 116);
+void onDrawInfoSubMenu(MenuItem* menuitem, int8_t line) {
+  if (hmiIsChinese()) menuitem->setFrame(1, 231, 104, 258, 116);
   onDrawSubMenu(menuitem, line);
 }
 
-void onDrawMoveX(MenuItemClass* menuitem, int8_t line) {
-  if (HMI_IsChinese()) menuitem->SetFrame(1, 58, 118, 106, 132);
+void onDrawMoveX(MenuItem* menuitem, int8_t line) {
+  if (hmiIsChinese()) menuitem->setFrame(1, 58, 118, 106, 132);
   onDrawPFloatMenu(menuitem, line);
 }
 
-void onDrawMoveY(MenuItemClass* menuitem, int8_t line) {
-  if (HMI_IsChinese()) menuitem->SetFrame(1, 109, 118, 157, 132);
+void onDrawMoveY(MenuItem* menuitem, int8_t line) {
+  if (hmiIsChinese()) menuitem->setFrame(1, 109, 118, 157, 132);
   onDrawPFloatMenu(menuitem, line);
 }
 
-void onDrawMoveZ(MenuItemClass* menuitem, int8_t line) {
-  if (HMI_IsChinese()) menuitem->SetFrame(1, 160, 118, 209, 132);
+void onDrawMoveZ(MenuItem* menuitem, int8_t line) {
+  if (hmiIsChinese()) menuitem->setFrame(1, 160, 118, 209, 132);
   onDrawPFloatMenu(menuitem, line);
 }
 
 #if HAS_HOTEND
-  void onDrawMoveE(MenuItemClass* menuitem, int8_t line) {
-    if (HMI_IsChinese()) menuitem->SetFrame(1, 212, 118, 253, 131);
+  void onDrawMoveE(MenuItem* menuitem, int8_t line) {
+    if (hmiIsChinese()) menuitem->setFrame(1, 212, 118, 253, 131);
     onDrawPFloatMenu(menuitem, line);
   }
 #endif
 
-void onDrawMoveSubMenu(MenuItemClass* menuitem, int8_t line) {
-  if (HMI_IsChinese()) menuitem->SetFrame(1, 159, 70, 200, 84);
+void onDrawMoveSubMenu(MenuItem* menuitem, int8_t line) {
+  if (hmiIsChinese()) menuitem->setFrame(1, 159, 70, 200, 84);
   onDrawSubMenu(menuitem, line);
 }
 
-void onDrawDisableMotors(MenuItemClass* menuitem, int8_t line) {
-  if (HMI_IsChinese()) menuitem->SetFrame(1, 204, 70, 259, 82);
+void onDrawDisableMotors(MenuItem* menuitem, int8_t line) {
+  if (hmiIsChinese()) menuitem->setFrame(1, 204, 70, 259, 82);
   onDrawMenuItem(menuitem, line);
 }
 
-void onDrawAutoHome(MenuItemClass* menuitem, int8_t line) {
-  if (HMI_IsChinese()) menuitem->SetFrame(1, 0, 89, 41, 101);
+void onDrawAutoHome(MenuItem* menuitem, int8_t line) {
+  if (hmiIsChinese()) menuitem->setFrame(1, 0, 89, 41, 101);
   onDrawMenuItem(menuitem, line);
 }
 
 #if HAS_ZOFFSET_ITEM
   #if ANY(BABYSTEP_ZPROBE_OFFSET, JUST_BABYSTEP)
-    void onDrawZOffset(MenuItemClass* menuitem, int8_t line) {
-      if (HMI_IsChinese()) menuitem->SetFrame(1, 174, 164, 223, 177);
+    void onDrawZOffset(MenuItem* menuitem, int8_t line) {
+      if (hmiIsChinese()) menuitem->setFrame(1, 174, 164, 223, 177);
       onDrawPFloat2Menu(menuitem, line);
     }
   #endif
 #endif
 
 #if HAS_HOTEND
-  void onDrawPreheat1(MenuItemClass* menuitem, int8_t line) {
-    if (HMI_IsChinese()) menuitem->SetFrame(1, 100, 89, 151, 101);
+  void onDrawPreheat1(MenuItem* menuitem, int8_t line) {
+    if (hmiIsChinese()) menuitem->setFrame(1, 100, 89, 151, 101);
     onDrawMenuItem(menuitem, line);
   }
   #if PREHEAT_COUNT > 1
-    void onDrawPreheat2(MenuItemClass* menuitem, int8_t line) {
-      if (HMI_IsChinese()) menuitem->SetFrame(1, 180, 89, 233, 100);
+    void onDrawPreheat2(MenuItem* menuitem, int8_t line) {
+      if (hmiIsChinese()) menuitem->setFrame(1, 180, 89, 233, 100);
       onDrawMenuItem(menuitem, line);
     }
   #endif
 #endif
 
 #if HAS_PREHEAT
-  void onDrawCooldown(MenuItemClass* menuitem, int8_t line) {
-    if (HMI_IsChinese()) menuitem->SetFrame(1, 1, 104,  56, 117);
+  void onDrawCooldown(MenuItem* menuitem, int8_t line) {
+    if (hmiIsChinese()) menuitem->setFrame(1, 1, 104,  56, 117);
     onDrawMenuItem(menuitem, line);
   }
 #endif
 
-void onDrawLanguage(MenuItemClass* menuitem, int8_t line) {
-  if (HMI_IsChinese()) menuitem->SetFrame(1, 239, 134, 266, 146);
+void onDrawLanguage(MenuItem* menuitem, int8_t line) {
+  if (hmiIsChinese()) menuitem->setFrame(1, 239, 134, 266, 146);
   onDrawMenuItem(menuitem, line);
-  DWINUI::Draw_String(VALX, MBASE(line), HMI_IsChinese() ? F("CN") : F("EN"));
+  DWINUI::drawString(VALX, MBASE(line), hmiIsChinese() ? F("CN") : F("EN"));
 }
 
-void onDrawSelColorItem(MenuItemClass* menuitem, int8_t line) {
-  const uint16_t color = *(uint16_t*)static_cast<MenuItemPtrClass*>(menuitem)->value;
-  dwinDrawRectangle(0, HMI_data.Highlight_Color, ICOX + 1, MBASE(line) - 1 + 1, ICOX + 18, MBASE(line) - 1 + 18);
+void onDrawSelColorItem(MenuItem* menuitem, int8_t line) {
+  const uint16_t color = *(uint16_t*)static_cast<MenuItemPtr*>(menuitem)->value;
+  dwinDrawRectangle(0, hmiData.colorHighlight, ICOX + 1, MBASE(line) - 1 + 1, ICOX + 18, MBASE(line) - 1 + 18);
   dwinDrawRectangle(1, color, ICOX + 2, MBASE(line) - 1 + 2, ICOX + 17, MBASE(line) - 1 + 17);
   onDrawMenuItem(menuitem, line);
 }
 
-void onDrawGetColorItem(MenuItemClass* menuitem, int8_t line) {
+void onDrawGetColorItem(MenuItem* menuitem, int8_t line) {
   const uint8_t i = menuitem->icon;
   uint16_t color;
   switch (i) {
     case 0: color = RGB(31, 0, 0); break; // Red
     case 1: color = RGB(0, 63, 0); break; // Green
     case 2: color = RGB(0, 0, 31); break; // Blue
     default: color = 0; break;
   }
-  dwinDrawRectangle(0, HMI_data.Highlight_Color, ICOX + 1, MBASE(line) - 1 + 1, ICOX + 18, MBASE(line) - 1 + 18);
+  dwinDrawRectangle(0, hmiData.colorHighlight, ICOX + 1, MBASE(line) - 1 + 1, ICOX + 18, MBASE(line) - 1 + 18);
   dwinDrawRectangle(1, color, ICOX + 2, MBASE(line) - 1 + 2, ICOX + 17, MBASE(line) - 1 + 17);
-  DWINUI::Draw_String(LBLX, MBASE(line) - 1, menuitem->caption);
-  Draw_Menu_IntValue(HMI_data.Background_Color, line, 4, HMI_value.Color[i]);
-  dwinDrawHLine(HMI_data.SplitLine_Color, 16, MYPOS(line + 1), 240);
+  DWINUI::drawString(LBLX, MBASE(line) - 1, menuitem->caption);
+  drawMenuIntValue(hmiData.colorBackground, line, 4, hmiValue.Color[i]);
+  dwinDrawHLine(hmiData.colorSplitLine, 16, MYPOS(line + 1), 240);
 }
 
-void onDrawSpeedItem(MenuItemClass* menuitem, int8_t line) {
-  if (HMI_IsChinese()) menuitem->SetFrame(1, 116, 164, 171, 176);
+void onDrawSpeedItem(MenuItem* menuitem, int8_t line) {
+  if (hmiIsChinese()) menuitem->setFrame(1, 116, 164, 171, 176);
   onDrawPIntMenu(menuitem, line);
 }
 
 #if HAS_HOTEND
-  void onDrawHotendTemp(MenuItemClass* menuitem, int8_t line) {
-    if (HMI_IsChinese()) menuitem->SetFrame(1, 1, 134, 56, 146);
+  void onDrawHotendTemp(MenuItem* menuitem, int8_t line) {
+    if (hmiIsChinese()) menuitem->setFrame(1, 1, 134, 56, 146);
     onDrawPIntMenu(menuitem, line);
   }
 #endif
 
 #if HAS_HEATED_BED
-  void onDrawBedTemp(MenuItemClass* menuitem, int8_t line) {
-    if (HMI_IsChinese()) menuitem->SetFrame(1, 58, 134, 113, 146);
+  void onDrawBedTemp(MenuItem* menuitem, int8_t line) {
+    if (hmiIsChinese()) menuitem->setFrame(1, 58, 134, 113, 146);
     onDrawPIntMenu(menuitem, line);
   }
 #endif
 
 #if HAS_FAN
-  void onDrawFanSpeed(MenuItemClass* menuitem, int8_t line) {
-    if (HMI_IsChinese()) menuitem->SetFrame(1, 115, 134, 170, 146);
+  void onDrawFanSpeed(MenuItem* menuitem, int8_t line) {
+    if (hmiIsChinese()) menuitem->setFrame(1, 115, 134, 170, 146);
     onDrawPInt8Menu(menuitem, line);
   }
 #endif
 
-void onDrawSteps(MenuItemClass* menuitem, int8_t line) {
-  if (HMI_IsChinese()) menuitem->SetFrame(1, 153, 148, 194, 161);
+void onDrawSteps(MenuItem* menuitem, int8_t line) {
+  if (hmiIsChinese()) menuitem->setFrame(1, 153, 148, 194, 161);
   onDrawSubMenu(menuitem, line);
 }
 
 #if ENABLED(MESH_BED_LEVELING)
-  void onDrawMMeshMoveZ(MenuItemClass* menuitem, int8_t line) {
-    if (HMI_IsChinese()) menuitem->SetFrame(1, 160, 118, 209, 132);
+  void onDrawMMeshMoveZ(MenuItem* menuitem, int8_t line) {
+    if (hmiIsChinese()) menuitem->setFrame(1, 160, 118, 209, 132);
     onDrawPFloat2Menu(menuitem, line);
   }
 #endif
 
 #if HAS_PREHEAT
   #if HAS_HOTEND
-    void onDrawSetPreheatHotend(MenuItemClass* menuitem, int8_t line) {
-      if (HMI_IsChinese()) menuitem->SetFrame(1, 1, 134, 56, 146);
+    void onDrawSetPreheatHotend(MenuItem* menuitem, int8_t line) {
+      if (hmiIsChinese()) menuitem->setFrame(1, 1, 134, 56, 146);
       onDrawPIntMenu(menuitem, line);
     }
   #endif
   #if HAS_HEATED_BED
-    void onDrawSetPreheatBed(MenuItemClass* menuitem, int8_t line) {
-      if (HMI_IsChinese()) menuitem->SetFrame(1, 58, 134, 113, 146);
+    void onDrawSetPreheatBed(MenuItem* menuitem, int8_t line) {
+      if (hmiIsChinese()) menuitem->setFrame(1, 58, 134, 113, 146);
       onDrawPIntMenu(menuitem, line);
     }
   #endif
   #if HAS_FAN
-    void onDrawSetPreheatFan(MenuItemClass* menuitem, int8_t line) {
-      if (HMI_IsChinese()) menuitem->SetFrame(1, 115, 134, 170, 146);
+    void onDrawSetPreheatFan(MenuItem* menuitem, int8_t line) {
+      if (hmiIsChinese()) menuitem->setFrame(1, 115, 134, 170, 146);
       onDrawPIntMenu(menuitem, line);
     }
   #endif
 #endif // HAS_PREHEAT
 
-void onDrawSpeed(MenuItemClass* menuitem, int8_t line) {
-  if (HMI_IsChinese())
-    menuitem->SetFrame(1, 173, 133, 228, 147);
+void onDrawSpeed(MenuItem* menuitem, int8_t line) {
+  if (hmiIsChinese())
+    menuitem->setFrame(1, 173, 133, 228, 147);
   onDrawSubMenu(menuitem, line);
 }
 
 #if HAS_X_AXIS
-  void onDrawMaxSpeedX(MenuItemClass* menuitem, int8_t line) {
-    if (HMI_IsChinese()) {
-      menuitem->SetFrame(1, 173, 133, 228, 147);
-      DWIN_Frame_AreaCopy(1, 229, 133, 236, 147, LBLX + 58, MBASE(line));   // X
+  void onDrawMaxSpeedX(MenuItem* menuitem, int8_t line) {
+    if (hmiIsChinese()) {
+      menuitem->setFrame(1, 173, 133, 228, 147);
+      dwinFrameAreaCopy(1, 229, 133, 236, 147, LBLX + 58, MBASE(line));   // X
     }
     onDrawPFloatMenu(menuitem, line);
   }
 #endif
 
 #if HAS_Y_AXIS
-  void onDrawMaxSpeedY(MenuItemClass* menuitem, int8_t line) {
-    if (HMI_IsChinese()) {
-      menuitem->SetFrame(1, 173, 133, 228, 147);
-      DWIN_Frame_AreaCopy(1, 1, 150, 7, 160, LBLX + 58, MBASE(line));       // Y
+  void onDrawMaxSpeedY(MenuItem* menuitem, int8_t line) {
+    if (hmiIsChinese()) {
+      menuitem->setFrame(1, 173, 133, 228, 147);
+      dwinFrameAreaCopy(1, 1, 150, 7, 160, LBLX + 58, MBASE(line));       // Y
     }
     onDrawPFloatMenu(menuitem, line);
   }
 #endif
 
 #if HAS_Z_AXIS
-  void onDrawMaxSpeedZ(MenuItemClass* menuitem, int8_t line) {
-    if (HMI_IsChinese()) {
-      menuitem->SetFrame(1, 173, 133, 228, 147);
-      DWIN_Frame_AreaCopy(1, 9, 150, 16, 160, LBLX + 58, MBASE(line) + 3);  // Z
+  void onDrawMaxSpeedZ(MenuItem* menuitem, int8_t line) {
+    if (hmiIsChinese()) {
+      menuitem->setFrame(1, 173, 133, 228, 147);
+      dwinFrameAreaCopy(1, 9, 150, 16, 160, LBLX + 58, MBASE(line) + 3);  // Z
     }
     onDrawPFloatMenu(menuitem, line);
   }
 #endif
 
 #if HAS_HOTEND
-  void onDrawMaxSpeedE(MenuItemClass* menuitem, int8_t line) {
-    if (HMI_IsChinese()) {
-      menuitem->SetFrame(1, 173, 133, 228, 147);
-      DWIN_Frame_AreaCopy(1, 18, 150, 25, 160, LBLX + 58, MBASE(line));     // E
+  void onDrawMaxSpeedE(MenuItem* menuitem, int8_t line) {
+    if (hmiIsChinese()) {
+      menuitem->setFrame(1, 173, 133, 228, 147);
+      dwinFrameAreaCopy(1, 18, 150, 25, 160, LBLX + 58, MBASE(line));     // E
     }
     onDrawPFloatMenu(menuitem, line);
   }
 #endif
 
-void onDrawAcc(MenuItemClass* menuitem, int8_t line) {
-  if (HMI_IsChinese()) {
-    menuitem->SetFrame(1, 173, 133, 200, 147);
-    DWIN_Frame_AreaCopy(1, 28, 149, 69, 161, LBLX + 27, MBASE(line) + 1);   // ...Acceleration
+void onDrawAcc(MenuItem* menuitem, int8_t line) {
+  if (hmiIsChinese()) {
+    menuitem->setFrame(1, 173, 133, 200, 147);
+    dwinFrameAreaCopy(1, 28, 149, 69, 161, LBLX + 27, MBASE(line) + 1);   // ...Acceleration
   }
   onDrawSubMenu(menuitem, line);
 }
 
 #if HAS_X_AXIS
-  void onDrawMaxAccelX(MenuItemClass* menuitem, int8_t line) {
-    if (HMI_IsChinese()) {
-      menuitem->SetFrame(1, 173, 133, 200, 147);
-      DWIN_Frame_AreaCopy(1, 28,  149,  69, 161, LBLX + 27, MBASE(line));
-      DWIN_Frame_AreaCopy(1, 229, 133, 236, 147, LBLX + 71, MBASE(line));   // X
+  void onDrawMaxAccelX(MenuItem* menuitem, int8_t line) {
+    if (hmiIsChinese()) {
+      menuitem->setFrame(1, 173, 133, 200, 147);
+      dwinFrameAreaCopy(1, 28,  149,  69, 161, LBLX + 27, MBASE(line));
+      dwinFrameAreaCopy(1, 229, 133, 236, 147, LBLX + 71, MBASE(line));   // X
     }
     onDrawPInt32Menu(menuitem, line);
   }
 #endif
 
 #if HAS_Y_AXIS
-  void onDrawMaxAccelY(MenuItemClass* menuitem, int8_t line) {
-    if (HMI_IsChinese()) {
-      menuitem->SetFrame(1, 173, 133, 200, 147);
-      DWIN_Frame_AreaCopy(1, 28, 149,  69, 161, LBLX + 27, MBASE(line));
-      DWIN_Frame_AreaCopy(1,  1, 150,   7, 160, LBLX + 71, MBASE(line));    // Y
+  void onDrawMaxAccelY(MenuItem* menuitem, int8_t line) {
+    if (hmiIsChinese()) {
+      menuitem->setFrame(1, 173, 133, 200, 147);
+      dwinFrameAreaCopy(1, 28, 149,  69, 161, LBLX + 27, MBASE(line));
+      dwinFrameAreaCopy(1,  1, 150,   7, 160, LBLX + 71, MBASE(line));    // Y
     }
     onDrawPInt32Menu(menuitem, line);
   }
 #endif
 
 #if HAS_Z_AXIS
-  void onDrawMaxAccelZ(MenuItemClass* menuitem, int8_t line) {
-    if (HMI_IsChinese()) {
-      menuitem->SetFrame(1, 173, 133, 200, 147);
-      DWIN_Frame_AreaCopy(1, 28, 149,  69, 161, LBLX + 27, MBASE(line));
-      DWIN_Frame_AreaCopy(1,  9, 150,  16, 160, LBLX + 71, MBASE(line));    // Z
+  void onDrawMaxAccelZ(MenuItem* menuitem, int8_t line) {
+    if (hmiIsChinese()) {
+      menuitem->setFrame(1, 173, 133, 200, 147);
+      dwinFrameAreaCopy(1, 28, 149,  69, 161, LBLX + 27, MBASE(line));
+      dwinFrameAreaCopy(1,  9, 150,  16, 160, LBLX + 71, MBASE(line));    // Z
     }
     onDrawPInt32Menu(menuitem, line);
   }
 #endif
 
 #if HAS_HOTEND
-  void onDrawMaxAccelE(MenuItemClass* menuitem, int8_t line) {
-    if (HMI_IsChinese()) {
-      menuitem->SetFrame(1, 173, 133, 200, 147);
-      DWIN_Frame_AreaCopy(1, 28, 149,  69, 161, LBLX + 27, MBASE(line));
-      DWIN_Frame_AreaCopy(1, 18, 150,  25, 160, LBLX + 71, MBASE(line));    // E
+  void onDrawMaxAccelE(MenuItem* menuitem, int8_t line) {
+    if (hmiIsChinese()) {
+      menuitem->setFrame(1, 173, 133, 200, 147);
+      dwinFrameAreaCopy(1, 28, 149,  69, 161, LBLX + 27, MBASE(line));
+      dwinFrameAreaCopy(1, 18, 150,  25, 160, LBLX + 71, MBASE(line));    // E
     }
     onDrawPInt32Menu(menuitem, line);
   }
 #endif
 
 #if HAS_CLASSIC_JERK
 
-  void onDrawJerk(MenuItemClass* menuitem, int8_t line) {
-    if (HMI_IsChinese()) {
-      menuitem->SetFrame(1, 173, 133, 200, 147);
-      DWIN_Frame_AreaCopy(1, 1, 180, 28, 192, LBLX + 27, MBASE(line) + 1);  // ...
-      DWIN_Frame_AreaCopy(1, 202, 133, 228, 147, LBLX + 54, MBASE(line));   // ...Jerk
+  void onDrawJerk(MenuItem* menuitem, int8_t line) {
+    if (hmiIsChinese()) {
+      menuitem->setFrame(1, 173, 133, 200, 147);
+      dwinFrameAreaCopy(1, 1, 180, 28, 192, LBLX + 27, MBASE(line) + 1);  // ...
+      dwinFrameAreaCopy(1, 202, 133, 228, 147, LBLX + 54, MBASE(line));   // ...Jerk
     }
     onDrawSubMenu(menuitem, line);
   }
 
   #if HAS_X_AXIS
-    void onDrawMaxJerkX(MenuItemClass* menuitem, int8_t line) {
-      if (HMI_IsChinese()) {
-        menuitem->SetFrame(1, 173, 133, 200, 147);
-        DWIN_Frame_AreaCopy(1,   1, 180,  28, 192, LBLX + 27, MBASE(line));
-        DWIN_Frame_AreaCopy(1, 202, 133, 228, 147, LBLX + 53, MBASE(line));
-        DWIN_Frame_AreaCopy(1, 229, 133, 236, 147, LBLX + 83, MBASE(line));
+    void onDrawMaxJerkX(MenuItem* menuitem, int8_t line) {
+      if (hmiIsChinese()) {
+        menuitem->setFrame(1, 173, 133, 200, 147);
+        dwinFrameAreaCopy(1,   1, 180,  28, 192, LBLX + 27, MBASE(line));
+        dwinFrameAreaCopy(1, 202, 133, 228, 147, LBLX + 53, MBASE(line));
+        dwinFrameAreaCopy(1, 229, 133, 236, 147, LBLX + 83, MBASE(line));
       }
       onDrawPFloatMenu(menuitem, line);
     }
   #endif
 
   #if HAS_Y_AXIS
-    void onDrawMaxJerkY(MenuItemClass* menuitem, int8_t line) {
-      if (HMI_IsChinese()) {
-        menuitem->SetFrame(1, 173, 133, 200, 147);
-        DWIN_Frame_AreaCopy(1,   1, 180,  28, 192, LBLX + 27, MBASE(line));
-        DWIN_Frame_AreaCopy(1, 202, 133, 228, 147, LBLX + 53, MBASE(line));
-        DWIN_Frame_AreaCopy(1,   1, 150,   7, 160, LBLX + 83, MBASE(line));
+    void onDrawMaxJerkY(MenuItem* menuitem, int8_t line) {
+      if (hmiIsChinese()) {
+        menuitem->setFrame(1, 173, 133, 200, 147);
+        dwinFrameAreaCopy(1,   1, 180,  28, 192, LBLX + 27, MBASE(line));
+        dwinFrameAreaCopy(1, 202, 133, 228, 147, LBLX + 53, MBASE(line));
+        dwinFrameAreaCopy(1,   1, 150,   7, 160, LBLX + 83, MBASE(line));
       }
       onDrawPFloatMenu(menuitem, line);
     }
   #endif
 
   #if HAS_Z_AXIS
-    void onDrawMaxJerkZ(MenuItemClass* menuitem, int8_t line) {
-      if (HMI_IsChinese()) {
-        menuitem->SetFrame(1, 173, 133, 200, 147);
-        DWIN_Frame_AreaCopy(1,   1, 180,  28, 192, LBLX + 27, MBASE(line));
-        DWIN_Frame_AreaCopy(1, 202, 133, 228, 147, LBLX + 53, MBASE(line));
-        DWIN_Frame_AreaCopy(1,   9, 150,  16, 160, LBLX + 83, MBASE(line));
+    void onDrawMaxJerkZ(MenuItem* menuitem, int8_t line) {
+      if (hmiIsChinese()) {
+        menuitem->setFrame(1, 173, 133, 200, 147);
+        dwinFrameAreaCopy(1,   1, 180,  28, 192, LBLX + 27, MBASE(line));
+        dwinFrameAreaCopy(1, 202, 133, 228, 147, LBLX + 53, MBASE(line));
+        dwinFrameAreaCopy(1,   9, 150,  16, 160, LBLX + 83, MBASE(line));
       }
       onDrawPFloatMenu(menuitem, line);
     }
   #endif
 
   #if HAS_HOTEND
 
-    void onDrawMaxJerkE(MenuItemClass* menuitem, int8_t line) {
-      if (HMI_IsChinese()) {
-        menuitem->SetFrame(1, 173, 133, 200, 147);
-        DWIN_Frame_AreaCopy(1,   1, 180,  28, 192, LBLX + 27, MBASE(line));
-        DWIN_Frame_AreaCopy(1, 202, 133, 228, 147, LBLX + 53, MBASE(line));
-        DWIN_Frame_AreaCopy(1,  18, 150,  25, 160, LBLX + 83, MBASE(line));
+    void onDrawMaxJerkE(MenuItem* menuitem, int8_t line) {
+      if (hmiIsChinese()) {
+        menuitem->setFrame(1, 173, 133, 200, 147);
+        dwinFrameAreaCopy(1,   1, 180,  28, 192, LBLX + 27, MBASE(line));
+        dwinFrameAreaCopy(1, 202, 133, 228, 147, LBLX + 53, MBASE(line));
+        dwinFrameAreaCopy(1,  18, 150,  25, 160, LBLX + 83, MBASE(line));
       }
       onDrawPFloatMenu(menuitem, line);
     }
 
   #endif
 
 #endif // HAS_CLASSIC_JERK
 
 #if HAS_X_AXIS
-  void onDrawStepsX(MenuItemClass* menuitem, int8_t line) {
-    if (HMI_IsChinese()) {
-      menuitem->SetFrame(1, 153, 148, 194, 161);
-      DWIN_Frame_AreaCopy(1, 229, 133, 236, 147, LBLX + 44, MBASE(line));      // X
+  void onDrawStepsX(MenuItem* menuitem, int8_t line) {
+    if (hmiIsChinese()) {
+      menuitem->setFrame(1, 153, 148, 194, 161);
+      dwinFrameAreaCopy(1, 229, 133, 236, 147, LBLX + 44, MBASE(line));      // X
     }
     onDrawPFloatMenu(menuitem, line);
   }
 #endif
 
 #if HAS_Y_AXIS
-  void onDrawStepsY(MenuItemClass* menuitem, int8_t line) {
-    if (HMI_IsChinese()) {
-      menuitem->SetFrame(1, 153, 148, 194, 161);
-      DWIN_Frame_AreaCopy(1,   1, 150,   7, 160, LBLX + 44, MBASE(line));      // Y
+  void onDrawStepsY(MenuItem* menuitem, int8_t line) {
+    if (hmiIsChinese()) {
+      menuitem->setFrame(1, 153, 148, 194, 161);
+      dwinFrameAreaCopy(1,   1, 150,   7, 160, LBLX + 44, MBASE(line));      // Y
     }
     onDrawPFloatMenu(menuitem, line);
   }
 #endif
 
 #if HAS_Z_AXIS
-  void onDrawStepsZ(MenuItemClass* menuitem, int8_t line) {
-    if (HMI_IsChinese()) {
-      menuitem->SetFrame(1, 153, 148, 194, 161);
-      DWIN_Frame_AreaCopy(1,   9, 150,  16, 160, LBLX + 44, MBASE(line));      // Z
+  void onDrawStepsZ(MenuItem* menuitem, int8_t line) {
+    if (hmiIsChinese()) {
+      menuitem->setFrame(1, 153, 148, 194, 161);
+      dwinFrameAreaCopy(1,   9, 150,  16, 160, LBLX + 44, MBASE(line));      // Z
     }
     onDrawPFloatMenu(menuitem, line);
   }
 #endif
 
 #if HAS_HOTEND
 
-  void onDrawStepsE(MenuItemClass* menuitem, int8_t line) {
-    if (HMI_IsChinese()) {
-      menuitem->SetFrame(1, 153, 148, 194, 161);
-      DWIN_Frame_AreaCopy(1,  18, 150,  25, 160, LBLX + 44, MBASE(line));    // E
+  void onDrawStepsE(MenuItem* menuitem, int8_t line) {
+    if (hmiIsChinese()) {
+      menuitem->setFrame(1, 153, 148, 194, 161);
+      dwinFrameAreaCopy(1,  18, 150,  25, 160, LBLX + 44, MBASE(line));    // E
     }
     onDrawPFloatMenu(menuitem, line);
   }
 
 #endif
 
 #if HAS_ONESTEP_LEVELING
-  void onDrawManualTramming(MenuItemClass* menuitem, int8_t line) { onDrawChkbMenu(menuitem, line, HMI_data.FullManualTramming); }
+  void onDrawManualTramming(MenuItem* menuitem, int8_t line) { onDrawChkbMenu(menuitem, line, hmiData.fullManualTramming); }
 #endif
 
 // Menu Creation and Drawing functions ======================================================
 
 frame_rect_t selrect(frame_rect_t) {
-  return HMI_IsChinese() ? frame_rect_t({ 133, 1, 28, 13 }) : frame_rect_t({ 0 });
+  return hmiIsChinese() ? frame_rect_t({ 133, 1, 28, 13 }) : frame_rect_t({ 0 });
 }
 
-void Draw_Prepare_Menu() {
-  checkkey = Menu;
-  if (SET_MENU_R(PrepareMenu, selrect({133, 1, 28, 13}), MSG_PREPARE, 10 + PREHEAT_COUNT)) {
-    BACK_ITEM(Goto_Main_Menu);
+void drawPrepareMenu() {
+  checkkey = ID_Menu;
+  if (SET_MENU_R(prepareMenu, selrect({133, 1, 28, 13}), MSG_PREPARE, 10 + PREHEAT_COUNT)) {
+    BACK_ITEM(gotoMainMenu);
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
-      MENU_ITEM(ICON_FilMan, MSG_FILAMENT_MAN, onDrawSubMenu, Draw_FilamentMan_Menu);
+      MENU_ITEM(ICON_FilMan, MSG_FILAMENT_MAN, onDrawSubMenu, drawFilamentManMenu);
     #endif
-    MENU_ITEM(ICON_Axis, MSG_MOVE_AXIS, onDrawMoveSubMenu, Draw_Move_Menu);
+    MENU_ITEM(ICON_Axis, MSG_MOVE_AXIS, onDrawMoveSubMenu, drawMoveMenu);
     #if ENABLED(LCD_BED_TRAMMING)
-      MENU_ITEM(ICON_Tram, MSG_BED_TRAMMING, onDrawSubMenu, Draw_Tramming_Menu);
+      MENU_ITEM(ICON_Tram, MSG_BED_TRAMMING, onDrawSubMenu, drawTrammingMenu);
     #endif
-    MENU_ITEM(ICON_CloseMotor, MSG_DISABLE_STEPPERS, onDrawDisableMotors, DisableMotors);
+    MENU_ITEM(ICON_CloseMotor, MSG_DISABLE_STEPPERS, onDrawDisableMotors, disableMotors);
     #if ENABLED(INDIVIDUAL_AXIS_HOMING_SUBMENU)
-      MENU_ITEM(ICON_Homing, MSG_HOMING, onDrawSubMenu, Draw_Homing_Menu);
+      MENU_ITEM(ICON_Homing, MSG_HOMING, onDrawSubMenu, drawHomingMenu);
     #else
-      MENU_ITEM(ICON_Homing, MSG_AUTO_HOME, onDrawAutoHome, AutoHome);
+      MENU_ITEM(ICON_Homing, MSG_AUTO_HOME, onDrawAutoHome, autoHome);
     #endif
     #if ENABLED(MESH_BED_LEVELING)
-      MENU_ITEM(ICON_ManualMesh, MSG_MANUAL_MESH, onDrawSubMenu, Draw_ManualMesh_Menu);
+      MENU_ITEM(ICON_ManualMesh, MSG_MANUAL_MESH, onDrawSubMenu, drawManualMeshMenu);
     #elif HAS_BED_PROBE
-      MENU_ITEM(ICON_Level, MSG_AUTO_MESH, onDrawMenuItem, AutoLev);
+      MENU_ITEM(ICON_Level, MSG_AUTO_MESH, onDrawMenuItem, autoLevel);
     #endif
     #if HAS_ZOFFSET_ITEM
       #if HAS_BED_PROBE
-        MENU_ITEM(ICON_SetZOffset, MSG_PROBE_WIZARD, onDrawSubMenu, Draw_ZOffsetWiz_Menu);
+        MENU_ITEM(ICON_SetZOffset, MSG_PROBE_WIZARD, onDrawSubMenu, drawZOffsetWizMenu);
       #elif ENABLED(BABYSTEPPING)
-        EDIT_ITEM(ICON_Zoffset, MSG_HOME_OFFSET_Z, onDrawPFloat2Menu, SetZOffset, &BABY_Z_VAR);
+        EDIT_ITEM(ICON_Zoffset, MSG_HOME_OFFSET_Z, onDrawPFloat2Menu, setZOffset, &BABY_Z_VAR);
       #endif
     #endif
     #if HAS_PREHEAT
       #define _ITEM_PREHEAT(N) MENU_ITEM(ICON_Preheat##N, MSG_PREHEAT_##N, onDrawMenuItem, DoPreheat##N);
       REPEAT_1(PREHEAT_COUNT, _ITEM_PREHEAT)
     #endif
-    MENU_ITEM(ICON_Cool, MSG_COOLDOWN, onDrawCooldown, DoCoolDown);
-    MENU_ITEM(ICON_Language, MSG_UI_LANGUAGE, onDrawLanguage, SetLanguage);
+    MENU_ITEM(ICON_Cool, MSG_COOLDOWN, onDrawCooldown, doCoolDown);
+    MENU_ITEM(ICON_Language, MSG_UI_LANGUAGE, onDrawLanguage, setLanguage);
   }
   ui.reset_status(true);
-  UpdateMenu(PrepareMenu);
+  updateMenu(prepareMenu);
 }
 
 #if ENABLED(LCD_BED_TRAMMING)
 
-  void Draw_Tramming_Menu() {
-    checkkey = Menu;
-    if (SET_MENU(TrammingMenu, MSG_BED_TRAMMING, 8)) {
-      BACK_ITEM(Draw_Prepare_Menu);
+  void drawTrammingMenu() {
+    checkkey = ID_Menu;
+    if (SET_MENU(trammingMenu, MSG_BED_TRAMMING, 8)) {
+      BACK_ITEM(drawPrepareMenu);
       #if HAS_BED_PROBE && HAS_MESH
-        MENU_ITEM(ICON_ProbeSet, MSG_TRAMMING_WIZARD, onDrawMenuItem, Trammingwizard);
-        EDIT_ITEM(ICON_ProbeSet, MSG_BED_TRAMMING_MANUAL, onDrawChkbMenu, SetManualTramming, &HMI_data.FullManualTramming);
+        MENU_ITEM(ICON_ProbeSet, MSG_TRAMMING_WIZARD, onDrawMenuItem, trammingwizard);
+        EDIT_ITEM(ICON_ProbeSet, MSG_BED_TRAMMING_MANUAL, onDrawChkbMenu, setManualTramming, &hmiData.fullManualTramming);
       #elif !HAS_BED_PROBE && HAS_ZOFFSET_ITEM
-        MENU_ITEM_F(ICON_MoveZ0, "Home Z and disable", onDrawMenuItem, HomeZandDisable);
+        MENU_ITEM_F(ICON_MoveZ0, "Home Z and disable", onDrawMenuItem, homeZAndDisable);
       #endif
-      MENU_ITEM(ICON_Axis, MSG_TRAM_FL, onDrawMenuItem, TramFL);
-      MENU_ITEM(ICON_Axis, MSG_TRAM_FR, onDrawMenuItem, TramFR);
-      MENU_ITEM(ICON_Axis, MSG_TRAM_BR, onDrawMenuItem, TramBR);
-      MENU_ITEM(ICON_Axis, MSG_TRAM_BL, onDrawMenuItem, TramBL);
+      MENU_ITEM(ICON_Axis, MSG_TRAM_FL, onDrawMenuItem, tramFL);
+      MENU_ITEM(ICON_Axis, MSG_TRAM_FR, onDrawMenuItem, tramFR);
+      MENU_ITEM(ICON_Axis, MSG_TRAM_BR, onDrawMenuItem, tramBR);
+      MENU_ITEM(ICON_Axis, MSG_TRAM_BL, onDrawMenuItem, tramBL);
       #if ENABLED(BED_TRAMMING_INCLUDE_CENTER)
-        MENU_ITEM(ICON_Axis, MSG_TRAM_C, onDrawMenuItem, TramC);
+        MENU_ITEM(ICON_Axis, MSG_TRAM_C, onDrawMenuItem, tramC);
       #endif
     }
-    UpdateMenu(TrammingMenu);
+    updateMenu(trammingMenu);
   }
 
 #endif // LCD_BED_TRAMMING
 
-void Draw_Control_Menu() {
-  checkkey = Menu;
+void drawControlMenu() {
+  checkkey = ID_Menu;
   if (SET_MENU_R(ControlMenu, selrect({103, 1, 28, 14}), MSG_CONTROL, 10)) {
-    BACK_ITEM(Goto_Main_Menu);
-    MENU_ITEM(ICON_Temperature, MSG_TEMPERATURE, onDrawTempSubMenu, Draw_Temperature_Menu);
-    MENU_ITEM(ICON_Motion, MSG_MOTION, onDrawMotionSubMenu, Draw_Motion_Menu);
+    BACK_ITEM(gotoMainMenu);
+    MENU_ITEM(ICON_Temperature, MSG_TEMPERATURE, onDrawTempSubMenu, drawTemperatureMenu);
+    MENU_ITEM(ICON_Motion, MSG_MOTION, onDrawMotionSubMenu, drawMotionMenu);
     #if ENABLED(EEPROM_SETTINGS)
-      MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawWriteEeprom, WriteEeprom);
-      MENU_ITEM(ICON_ReadEEPROM, MSG_LOAD_EEPROM, onDrawReadEeprom, ReadEeprom);
-      MENU_ITEM(ICON_ResumeEEPROM, MSG_RESTORE_DEFAULTS, onDrawResetEeprom, ResetEeprom);
+      MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawWriteEeprom, writeEEPROM);
+      MENU_ITEM(ICON_ReadEEPROM, MSG_LOAD_EEPROM, onDrawReadEeprom, readEEPROM);
+      MENU_ITEM(ICON_ResumeEEPROM, MSG_RESTORE_DEFAULTS, onDrawResetEeprom, resetEEPROM);
     #endif
-    MENU_ITEM(ICON_Reboot, MSG_RESET_PRINTER, onDrawMenuItem, RebootPrinter);
+    MENU_ITEM(ICON_Reboot, MSG_RESET_PRINTER, onDrawMenuItem, rebootPrinter);
     #if ENABLED(CASE_LIGHT_MENU)
       #if ENABLED(CASELIGHT_USES_BRIGHTNESS)
-        MENU_ITEM(ICON_CaseLight, MSG_CASE_LIGHT, onDrawSubMenu, Draw_CaseLight_Menu);
+        MENU_ITEM(ICON_CaseLight, MSG_CASE_LIGHT, onDrawSubMenu, drawCaseLightMenu);
       #else
-        MENU_ITEM(ICON_CaseLight, MSG_CASE_LIGHT, onDrawChkbMenu, SetCaseLight, &caselight.on);
+        MENU_ITEM(ICON_CaseLight, MSG_CASE_LIGHT, onDrawChkbMenu, setCaseLight, &caselight.on);
       #endif
     #endif
     #if ENABLED(LED_CONTROL_MENU)
-      MENU_ITEM(ICON_LedControl, MSG_LED_CONTROL, onDrawSubMenu, Draw_LedControl_Menu);
+      MENU_ITEM(ICON_LedControl, MSG_LED_CONTROL, onDrawSubMenu, drawLedControlMenu);
     #endif
-    MENU_ITEM(ICON_Info, MSG_INFO_SCREEN, onDrawInfoSubMenu, Goto_Info_Menu);
+    MENU_ITEM(ICON_Info, MSG_INFO_SCREEN, onDrawInfoSubMenu, gotoInfoMenu);
   }
   ui.reset_status(true);
-  UpdateMenu(ControlMenu);
+  updateMenu(ControlMenu);
 }
 
-void Draw_AdvancedSettings_Menu() {
-  checkkey = Menu;
+void drawAdvancedSettingsMenu() {
+  checkkey = ID_Menu;
   if (SET_MENU(AdvancedSettings, MSG_ADVANCED_SETTINGS, 22)) {
-    BACK_ITEM(Goto_Main_Menu);
+    BACK_ITEM(gotoMainMenu);
     #if ENABLED(EEPROM_SETTINGS)
-      MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawMenuItem, WriteEeprom);
+      MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawMenuItem, writeEEPROM);
     #endif
     #if HAS_MESH
-      MENU_ITEM(ICON_ProbeSet, MSG_MESH_LEVELING, onDrawSubMenu, Draw_MeshSet_Menu);
+      MENU_ITEM(ICON_ProbeSet, MSG_MESH_LEVELING, onDrawSubMenu, drawMeshSetMenu);
     #endif
     #if HAS_BED_PROBE
-      MENU_ITEM(ICON_ProbeSet, MSG_ZPROBE_SETTINGS, onDrawSubMenu, Draw_ProbeSet_Menu);
+      MENU_ITEM(ICON_ProbeSet, MSG_ZPROBE_SETTINGS, onDrawSubMenu, drawProbeSetMenu);
     #endif
-    MENU_ITEM(ICON_FilSet, MSG_FILAMENT_SET, onDrawSubMenu, Draw_FilSet_Menu);
+    MENU_ITEM(ICON_FilSet, MSG_FILAMENT_SET, onDrawSubMenu, drawFilSetMenu);
     #if ENABLED(PIDTEMP) && ANY(PID_AUTOTUNE_MENU, PID_EDIT_MENU)
-      MENU_ITEM_F(ICON_PIDNozzle, STR_HOTEND_PID " Settings", onDrawSubMenu, Draw_HotendPID_Menu);
+      MENU_ITEM_F(ICON_PIDNozzle, STR_HOTEND_PID " Settings", onDrawSubMenu, drawHotendPIDMenu);
     #endif
     #if ANY(MPC_EDIT_MENU, MPC_AUTOTUNE_MENU)
-      MENU_ITEM_F(ICON_MPCNozzle, "MPC Settings", onDrawSubMenu, Draw_HotendMPC_Menu);
+      MENU_ITEM_F(ICON_MPCNozzle, "MPC Settings", onDrawSubMenu, drawHotendMPCMenu);
     #endif
     #if ENABLED(PIDTEMPBED) && ANY(PID_AUTOTUNE_MENU, PID_EDIT_MENU)
-      MENU_ITEM_F(ICON_PIDBed, STR_BED_PID " Settings", onDrawSubMenu, Draw_BedPID_Menu);
+      MENU_ITEM_F(ICON_PIDBed, STR_BED_PID " Settings", onDrawSubMenu, drawBedPIDMenu);
     #endif
     #if HAS_TRINAMIC_CONFIG
-      MENU_ITEM(ICON_TMCSet, MSG_TMC_DRIVERS, onDrawSubMenu, Draw_TrinamicConfig_menu);
+      MENU_ITEM(ICON_TMCSet, MSG_TMC_DRIVERS, onDrawSubMenu, drawTrinamicConfigMenu);
     #endif
     #if HAS_ESDIAG
-      MENU_ITEM_F(ICON_ESDiag, "End-stops diag.", onDrawSubMenu, Draw_EndStopDiag);
+      MENU_ITEM_F(ICON_esDiag, "End-stops diag.", onDrawSubMenu, drawEndStopDiag);
     #endif
     #if ENABLED(PRINTCOUNTER)
-      MENU_ITEM(ICON_PrintStats, MSG_INFO_STATS_MENU, onDrawSubMenu, Goto_PrintStats);
-      MENU_ITEM(ICON_PrintStatsReset, MSG_INFO_PRINT_COUNT_RESET, onDrawSubMenu, PrintStatsReset);
+      MENU_ITEM(ICON_PrintStats, MSG_INFO_STATS_MENU, onDrawSubMenu, gotoPrintStats);
+      MENU_ITEM(ICON_PrintStatsReset, MSG_INFO_PRINT_COUNT_RESET, onDrawSubMenu, printStatsReset);
     #endif
     #if HAS_LOCKSCREEN
-      MENU_ITEM(ICON_Lock, MSG_LOCKSCREEN, onDrawMenuItem, DWIN_LockScreen);
+      MENU_ITEM(ICON_Lock, MSG_LOCKSCREEN, onDrawMenuItem, dwinLockScreen);
     #endif
     #if ENABLED(SOUND_MENU_ITEM)
-      EDIT_ITEM(ICON_Sound, MSG_SOUND_ENABLE, onDrawChkbMenu, SetEnableSound, &ui.sound_on);
+      EDIT_ITEM(ICON_Sound, MSG_SOUND_ENABLE, onDrawChkbMenu, setEnableSound, &ui.sound_on);
     #endif
     #if ENABLED(POWER_LOSS_RECOVERY)
-      EDIT_ITEM(ICON_Pwrlossr, MSG_OUTAGE_RECOVERY, onDrawChkbMenu, SetPwrLossr, &recovery.enabled);
+      EDIT_ITEM(ICON_Pwrlossr, MSG_OUTAGE_RECOVERY, onDrawChkbMenu, setPwrLossr, &recovery.enabled);
     #endif
     #if HAS_GCODE_PREVIEW
-      EDIT_ITEM(ICON_File, MSG_HAS_PREVIEW, onDrawChkbMenu, SetPreview, &HMI_data.EnablePreview);
+      EDIT_ITEM(ICON_File, MSG_HAS_PREVIEW, onDrawChkbMenu, setPreview, &hmiData.enablePreview);
     #endif
     #if ENABLED(MEDIASORT_MENU_ITEM)
-      EDIT_ITEM(ICON_File, MSG_MEDIA_SORT, onDrawChkbMenu, SetMediaSort, &HMI_data.MediaSort);
+      EDIT_ITEM(ICON_File, MSG_MEDIA_SORT, onDrawChkbMenu, setMediaSort, &hmiData.mediaSort);
     #endif
-    EDIT_ITEM(ICON_File, MSG_MEDIA_UPDATE, onDrawChkbMenu, SetMediaAutoMount, &HMI_data.MediaAutoMount);
+    EDIT_ITEM(ICON_File, MSG_MEDIA_UPDATE, onDrawChkbMenu, setMediaAutoMount, &hmiData.mediaAutoMount);
     #if ENABLED(BAUD_RATE_GCODE)
-      EDIT_ITEM_F(ICON_SetBaudRate, "115K baud", onDrawChkbMenu, SetBaudRate, &HMI_data.Baud115K);
+      EDIT_ITEM_F(ICON_SetBaudRate, "115K baud", onDrawChkbMenu, setBaudRate, &hmiData.baud115K);
     #endif
     #if HAS_LCD_BRIGHTNESS
-      EDIT_ITEM(ICON_Brightness, MSG_BRIGHTNESS, onDrawPInt8Menu, SetBrightness, &ui.brightness);
-      MENU_ITEM(ICON_Brightness, MSG_BRIGHTNESS_OFF, onDrawMenuItem, TurnOffBacklight);
+      EDIT_ITEM(ICON_Brightness, MSG_BRIGHTNESS, onDrawPInt8Menu, setBrightness, &ui.brightness);
+      MENU_ITEM(ICON_Brightness, MSG_BRIGHTNESS_OFF, onDrawMenuItem, turnOffBacklight);
     #endif
     #if HAS_CUSTOM_COLORS
-      MENU_ITEM(ICON_Scolor, MSG_COLORS_SELECT, onDrawSubMenu, Draw_SelectColors_Menu);
+      MENU_ITEM(ICON_Scolor, MSG_COLORS_SELECT, onDrawSubMenu, drawSelectColorsMenu);
     #endif
   }
   ui.reset_status(true);
-  UpdateMenu(AdvancedSettings);
+  updateMenu(AdvancedSettings);
 }
 
-void Draw_Move_Menu() {
-  checkkey = Menu;
-  if (SET_MENU_R(MoveMenu, selrect({192, 1, 42, 14}), MSG_MOVE_AXIS, 6)) {
-    BACK_ITEM(Draw_Prepare_Menu);
-    EDIT_ITEM(ICON_Axis, MSG_LIVE_MOVE, onDrawChkbMenu, SetLiveMove, &EnableLiveMove);
+void drawMoveMenu() {
+  checkkey = ID_Menu;
+  if (SET_MENU_R(moveMenu, selrect({192, 1, 42, 14}), MSG_MOVE_AXIS, 6)) {
+    BACK_ITEM(drawPrepareMenu);
+    EDIT_ITEM(ICON_Axis, MSG_LIVE_MOVE, onDrawChkbMenu, setLiveMove, &enableLiveMove);
     #if HAS_X_AXIS
-      EDIT_ITEM(ICON_MoveX, MSG_MOVE_X, onDrawMoveX, SetMoveX, &current_position.x);
+      EDIT_ITEM(ICON_MoveX, MSG_MOVE_X, onDrawMoveX, setMoveX, &current_position.x);
     #endif
     #if HAS_Y_AXIS
-      EDIT_ITEM(ICON_MoveY, MSG_MOVE_Y, onDrawMoveY, SetMoveY, &current_position.y);
+      EDIT_ITEM(ICON_MoveY, MSG_MOVE_Y, onDrawMoveY, setMoveY, &current_position.y);
     #endif
     #if HAS_Z_AXIS
-      EDIT_ITEM(ICON_MoveZ, MSG_MOVE_Z, onDrawMoveZ, SetMoveZ, &current_position.z);
+      EDIT_ITEM(ICON_MoveZ, MSG_MOVE_Z, onDrawMoveZ, setMoveZ, &current_position.z);
     #endif
     #if HAS_HOTEND
       gcode.process_subcommands_now(F("G92E0"));  // Reset extruder position
-      EDIT_ITEM(ICON_Extruder, MSG_MOVE_E, onDrawMoveE, SetMoveE, &current_position.e);
+      EDIT_ITEM(ICON_Extruder, MSG_MOVE_E, onDrawMoveE, setMoveE, &current_position.e);
     #endif
   }
-  UpdateMenu(MoveMenu);
+  updateMenu(moveMenu);
   if (!all_axes_trusted()) LCD_MESSAGE_F("WARNING: Current position unknown. Home axes.");
 }
 
 #if HAS_HOME_OFFSET
 
-  void Draw_HomeOffset_Menu() {
-    checkkey = Menu;
-    if (SET_MENU(HomeOffMenu, MSG_SET_HOME_OFFSETS, 4)) {
-      BACK_ITEM(Draw_PhySet_Menu);
+  void drawHomeOffsetMenu() {
+    checkkey = ID_Menu;
+    if (SET_MENU(homeOffsetMenu, MSG_SET_HOME_OFFSETS, 4)) {
+      BACK_ITEM(drawPhySetMenu);
       #if HAS_X_AXIS
-        EDIT_ITEM(ICON_HomeOffsetX, MSG_HOME_OFFSET_X, onDrawPFloatMenu, SetHomeOffsetX, &home_offset.x);
+        EDIT_ITEM(ICON_HomeOffsetX, MSG_HOME_OFFSET_X, onDrawPFloatMenu, setHomeOffsetX, &home_offset.x);
       #endif
       #if HAS_Y_AXIS
-        EDIT_ITEM(ICON_HomeOffsetY, MSG_HOME_OFFSET_Y, onDrawPFloatMenu, SetHomeOffsetY, &home_offset.y);
+        EDIT_ITEM(ICON_HomeOffsetY, MSG_HOME_OFFSET_Y, onDrawPFloatMenu, setHomeOffsetY, &home_offset.y);
       #endif
       #if HAS_Z_AXIS
-        EDIT_ITEM(ICON_HomeOffsetZ, MSG_HOME_OFFSET_Z, onDrawPFloatMenu, SetHomeOffsetZ, &home_offset.z);
+        EDIT_ITEM(ICON_HomeOffsetZ, MSG_HOME_OFFSET_Z, onDrawPFloatMenu, setHomeOffsetZ, &home_offset.z);
       #endif
     }
-    UpdateMenu(HomeOffMenu);
+    updateMenu(homeOffsetMenu);
   }
 
 #endif // HAS_HOME_OFFSET
 
 #if HAS_BED_PROBE
 
-  void Draw_ProbeSet_Menu() {
-    checkkey = Menu;
+  void drawProbeSetMenu() {
+    checkkey = ID_Menu;
     if (SET_MENU(ProbeSetMenu, MSG_ZPROBE_SETTINGS, 9)) {
-      BACK_ITEM(Draw_AdvancedSettings_Menu);
+      BACK_ITEM(drawAdvancedSettingsMenu);
       #if HAS_X_AXIS
-        EDIT_ITEM(ICON_ProbeOffsetX, MSG_ZPROBE_XOFFSET, onDrawPFloatMenu, SetProbeOffsetX, &probe.offset.x);
+        EDIT_ITEM(ICON_ProbeOffsetX, MSG_ZPROBE_XOFFSET, onDrawPFloatMenu, setProbeOffsetX, &probe.offset.x);
       #endif
       #if HAS_Y_AXIS
-        EDIT_ITEM(ICON_ProbeOffsetY, MSG_ZPROBE_YOFFSET, onDrawPFloatMenu, SetProbeOffsetY, &probe.offset.y);
+        EDIT_ITEM(ICON_ProbeOffsetY, MSG_ZPROBE_YOFFSET, onDrawPFloatMenu, setProbeOffsetY, &probe.offset.y);
       #endif
       #if HAS_Z_AXIS
-        EDIT_ITEM(ICON_ProbeOffsetZ, MSG_ZPROBE_ZOFFSET, onDrawPFloat2Menu, SetProbeOffsetZ, &probe.offset.z);
+        EDIT_ITEM(ICON_ProbeOffsetZ, MSG_ZPROBE_ZOFFSET, onDrawPFloat2Menu, setProbeOffsetZ, &probe.offset.z);
       #endif
       #if ENABLED(BLTOUCH)
-        MENU_ITEM(ICON_ProbeStow, MSG_MANUAL_STOW, onDrawMenuItem, ProbeStow);
-        MENU_ITEM(ICON_ProbeDeploy, MSG_MANUAL_DEPLOY, onDrawMenuItem, ProbeDeploy);
+        MENU_ITEM(ICON_ProbeStow, MSG_MANUAL_STOW, onDrawMenuItem, probeStow);
+        MENU_ITEM(ICON_ProbeDeploy, MSG_MANUAL_DEPLOY, onDrawMenuItem, probeDeploy);
         MENU_ITEM(ICON_BltouchReset, MSG_BLTOUCH_RESET, onDrawMenuItem, bltouch._reset);
         #if HAS_BLTOUCH_HS_MODE
-          EDIT_ITEM(ICON_HSMode, MSG_ENABLE_HS_MODE, onDrawChkbMenu, SetHSMode, &bltouch.high_speed_mode);
+          EDIT_ITEM(ICON_HSMode, MSG_ENABLE_HS_MODE, onDrawChkbMenu, setHSMode, &bltouch.high_speed_mode);
         #endif
       #endif
-      MENU_ITEM(ICON_ProbeTest, MSG_M48_TEST, onDrawMenuItem, ProbeTest);
+      MENU_ITEM(ICON_ProbeTest, MSG_M48_TEST, onDrawMenuItem, probeTest);
     }
-    UpdateMenu(ProbeSetMenu);
+    updateMenu(ProbeSetMenu);
   }
 
 #endif // HAS_BED_PROBE
 
-void Draw_FilSet_Menu() {
-  checkkey = Menu;
-  if (SET_MENU(FilSetMenu, MSG_FILAMENT_SET, 9)) {
-    BACK_ITEM(Draw_AdvancedSettings_Menu);
+void drawFilSetMenu() {
+  checkkey = ID_Menu;
+  if (SET_MENU(filSetMenu, MSG_FILAMENT_SET, 9)) {
+    BACK_ITEM(drawAdvancedSettingsMenu);
     #if HAS_FILAMENT_SENSOR
-      EDIT_ITEM(ICON_Runout, MSG_RUNOUT_ENABLE, onDrawChkbMenu, SetRunoutEnable, &runout.enabled);
+      EDIT_ITEM(ICON_Runout, MSG_RUNOUT_ENABLE, onDrawChkbMenu, setRunoutEnable, &runout.enabled);
     #endif
     #if HAS_FILAMENT_RUNOUT_DISTANCE
-      EDIT_ITEM(ICON_Runout, MSG_RUNOUT_DISTANCE_MM, onDrawPFloatMenu, SetRunoutDistance, &runout.runout_distance());
+      EDIT_ITEM(ICON_Runout, MSG_RUNOUT_DISTANCE_MM, onDrawPFloatMenu, setRunoutDistance, &runout.runout_distance());
     #endif
     #if ENABLED(PREVENT_COLD_EXTRUSION)
-      EDIT_ITEM(ICON_ExtrudeMinT, MSG_EXTRUDER_MIN_TEMP, onDrawPIntMenu, SetExtMinT, &HMI_data.ExtMinT);
+      EDIT_ITEM(ICON_ExtrudeMinT, MSG_EXTRUDER_MIN_TEMP, onDrawPIntMenu, setExtMinT, &hmiData.extMinT);
     #endif
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
-      EDIT_ITEM(ICON_FilLoad, MSG_FILAMENT_LOAD, onDrawPFloatMenu, SetFilLoad, &fc_settings[0].load_length);
-      EDIT_ITEM(ICON_FilUnload, MSG_FILAMENT_UNLOAD, onDrawPFloatMenu, SetFilUnload, &fc_settings[0].unload_length);
+      EDIT_ITEM(ICON_FilLoad, MSG_FILAMENT_LOAD, onDrawPFloatMenu, setFilLoad, &fc_settings[0].load_length);
+      EDIT_ITEM(ICON_FilUnload, MSG_FILAMENT_UNLOAD, onDrawPFloatMenu, setFilUnload, &fc_settings[0].unload_length);
     #endif
     #if ENABLED(FWRETRACT)
-      MENU_ITEM(ICON_FWRetract, MSG_FWRETRACT, onDrawSubMenu, Draw_FWRetract_Menu);
+      MENU_ITEM(ICON_FWRetract, MSG_FWRETRACT, onDrawSubMenu, drawFWRetractMenu);
     #endif
   }
-  UpdateMenu(FilSetMenu);
+  updateMenu(filSetMenu);
 }
 
 #if ALL(CASE_LIGHT_MENU, CASELIGHT_USES_BRIGHTNESS)
 
-  void Draw_CaseLight_Menu() {
-    checkkey = Menu;
-    if (SET_MENU(CaseLightMenu, MSG_CASE_LIGHT, 3)) {
-      BACK_ITEM(Draw_Control_Menu);
-      EDIT_ITEM(ICON_CaseLight, MSG_CASE_LIGHT, onDrawChkbMenu, SetCaseLight, &caselight.on);
-      EDIT_ITEM(ICON_Brightness, MSG_CASE_LIGHT_BRIGHTNESS, onDrawPInt8Menu, SetCaseLightBrightness, &caselight.brightness);
+  void drawCaseLightMenu() {
+    checkkey = ID_Menu;
+    if (SET_MENU(caseLightMenu, MSG_CASE_LIGHT, 3)) {
+      BACK_ITEM(drawControlMenu);
+      EDIT_ITEM(ICON_CaseLight, MSG_CASE_LIGHT, onDrawChkbMenu, setCaseLight, &caselight.on);
+      EDIT_ITEM(ICON_Brightness, MSG_CASE_LIGHT_BRIGHTNESS, onDrawPInt8Menu, setCaseLightBrightness, &caselight.brightness);
     }
-    UpdateMenu(CaseLightMenu);
+    updateMenu(caseLightMenu);
   }
 
 #endif
 
 #if ENABLED(LED_CONTROL_MENU)
 
-  void Draw_LedControl_Menu() {
-    checkkey = Menu;
-    if (SET_MENU(LedControlMenu, MSG_LED_CONTROL, 10)) {
-      BACK_ITEM(Draw_Control_Menu);
+  void drawLedControlMenu() {
+    checkkey = ID_Menu;
+    if (SET_MENU(ledControlMenu, MSG_LED_CONTROL, 10)) {
+      BACK_ITEM(drawControlMenu);
       #if !ALL(CASE_LIGHT_MENU, CASE_LIGHT_USE_NEOPIXEL)
-        EDIT_ITEM(ICON_LedControl, MSG_LEDS, onDrawChkbMenu, SetLedStatus, &leds.lights_on);
+        EDIT_ITEM(ICON_LedControl, MSG_LEDS, onDrawChkbMenu, setLedStatus, &leds.lights_on);
       #endif
       #if HAS_COLOR_LEDS
         #if ENABLED(LED_COLOR_PRESETS)
           MENU_ITEM(ICON_LedControl, MSG_SET_LEDS_WHITE, onDrawMenuItem,  leds.set_white);
           MENU_ITEM(ICON_LedControl, MSG_SET_LEDS_RED, onDrawMenuItem,    leds.set_red);
           MENU_ITEM(ICON_LedControl, MSG_SET_LEDS_ORANGE, onDrawMenuItem, leds.set_orange);
           MENU_ITEM(ICON_LedControl, MSG_SET_LEDS_YELLOW, onDrawMenuItem, leds.set_yellow);
           MENU_ITEM(ICON_LedControl, MSG_SET_LEDS_GREEN, onDrawMenuItem,  leds.set_green);
           MENU_ITEM(ICON_LedControl, MSG_SET_LEDS_BLUE, onDrawMenuItem,   leds.set_blue);
           MENU_ITEM(ICON_LedControl, MSG_SET_LEDS_INDIGO, onDrawMenuItem, leds.set_indigo);
           MENU_ITEM(ICON_LedControl, MSG_SET_LEDS_VIOLET, onDrawMenuItem, leds.set_violet);
         #else
-          EDIT_ITEM(ICON_LedControl, MSG_COLORS_RED, onDrawPInt8Menu, SetLEDColorR, &leds.color.r);
-          EDIT_ITEM(ICON_LedControl, MSG_COLORS_GREEN, onDrawPInt8Menu, SetLEDColorG, &leds.color.g);
-          EDIT_ITEM(ICON_LedControl, MSG_COLORS_BLUE, onDrawPInt8Menu, SetLEDColorB, &leds.color.b);
+          EDIT_ITEM(ICON_LedControl, MSG_COLORS_RED, onDrawPInt8Menu, setLEDColorR, &leds.color.r);
+          EDIT_ITEM(ICON_LedControl, MSG_COLORS_GREEN, onDrawPInt8Menu, setLEDColorG, &leds.color.g);
+          EDIT_ITEM(ICON_LedControl, MSG_COLORS_BLUE, onDrawPInt8Menu, setLEDColorB, &leds.color.b);
           #if ENABLED(HAS_WHITE_LED)
-            EDIT_ITEM(ICON_LedControl, MSG_COLORS_WHITE, onDrawPInt8Menu, SetLEDColorW, &leds.color.w);
+            EDIT_ITEM(ICON_LedControl, MSG_COLORS_WHITE, onDrawPInt8Menu, setLEDColorW, &leds.color.w);
           #endif
         #endif
       #endif
     }
-    UpdateMenu(LedControlMenu);
+    updateMenu(ledControlMenu);
   }
 
 #endif // LED_CONTROL_MENU
 
-void Draw_Tune_Menu() {
-  checkkey = Menu;
-  if (SET_MENU_R(TuneMenu, selrect({73, 2, 28, 12}), MSG_TUNE, 17)) {
-    BACK_ITEM(Goto_PrintProcess);
-    EDIT_ITEM(ICON_Speed, MSG_SPEED, onDrawSpeedItem, SetSpeed, &feedrate_percentage);
+void drawTuneMenu() {
+  checkkey = ID_Menu;
+  if (SET_MENU_R(tuneMenu, selrect({73, 2, 28, 12}), MSG_TUNE, 17)) {
+    BACK_ITEM(gotoPrintProcess);
+    EDIT_ITEM(ICON_Speed, MSG_SPEED, onDrawSpeedItem, setSpeed, &feedrate_percentage);
     #if HAS_HOTEND
-      HotendTargetItem = EDIT_ITEM(ICON_HotendTemp, MSG_UBL_SET_TEMP_HOTEND, onDrawHotendTemp, SetHotendTemp, &thermalManager.temp_hotend[0].target);
+      hotendTargetItem = EDIT_ITEM(ICON_HotendTemp, MSG_UBL_SET_TEMP_HOTEND, onDrawHotendTemp, setHotendTemp, &thermalManager.temp_hotend[0].target);
     #endif
     #if HAS_HEATED_BED
-      BedTargetItem = EDIT_ITEM(ICON_BedTemp, MSG_UBL_SET_TEMP_BED, onDrawBedTemp, SetBedTemp, &thermalManager.temp_bed.target);
+      bedTargetItem = EDIT_ITEM(ICON_BedTemp, MSG_UBL_SET_TEMP_BED, onDrawBedTemp, setBedTemp, &thermalManager.temp_bed.target);
     #endif
     #if HAS_FAN
-      FanSpeedItem = EDIT_ITEM(ICON_FanSpeed, MSG_FAN_SPEED, onDrawFanSpeed, SetFanSpeed, &thermalManager.fan_speed[0]);
+      fanSpeedItem = EDIT_ITEM(ICON_FanSpeed, MSG_FAN_SPEED, onDrawFanSpeed, setFanSpeed, &thermalManager.fan_speed[0]);
     #endif
     #if ALL(HAS_ZOFFSET_ITEM, HAS_BED_PROBE, BABYSTEP_ZPROBE_OFFSET, BABYSTEPPING)
-      EDIT_ITEM(ICON_Zoffset, MSG_ZPROBE_ZOFFSET, onDrawZOffset, SetZOffset, &BABY_Z_VAR);
+      EDIT_ITEM(ICON_Zoffset, MSG_ZPROBE_ZOFFSET, onDrawZOffset, setZOffset, &BABY_Z_VAR);
     #elif ALL(HAS_ZOFFSET_ITEM, MESH_BED_LEVELING, BABYSTEPPING)
-      EDIT_ITEM(ICON_Zoffset, MSG_HOME_OFFSET_Z, onDrawPFloat2Menu, SetZOffset, &BABY_Z_VAR);
+      EDIT_ITEM(ICON_Zoffset, MSG_HOME_OFFSET_Z, onDrawPFloat2Menu, setZOffset, &BABY_Z_VAR);
     #endif
-    EDIT_ITEM(ICON_Flow, MSG_FLOW, onDrawPIntMenu, SetFlow, &planner.flow_percentage[0]);
+    EDIT_ITEM(ICON_Flow, MSG_FLOW, onDrawPIntMenu, setFlow, &planner.flow_percentage[0]);
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
-      MENU_ITEM(ICON_FilMan, MSG_FILAMENTCHANGE, onDrawMenuItem, ChangeFilament);
+      MENU_ITEM(ICON_FilMan, MSG_FILAMENTCHANGE, onDrawMenuItem, changeFilament);
     #endif
     #if HAS_FILAMENT_SENSOR
-      EDIT_ITEM(ICON_Runout, MSG_RUNOUT_ENABLE, onDrawChkbMenu, SetRunoutEnable, &runout.enabled);
+      EDIT_ITEM(ICON_Runout, MSG_RUNOUT_ENABLE, onDrawChkbMenu, setRunoutEnable, &runout.enabled);
     #endif
     #if ENABLED(PLR_TUNE_ITEM)
-      EDIT_ITEM(ICON_Pwrlossr, MSG_OUTAGE_RECOVERY, onDrawChkbMenu, SetPwrLossr, &recovery.enabled);
+      EDIT_ITEM(ICON_Pwrlossr, MSG_OUTAGE_RECOVERY, onDrawChkbMenu, setPwrLossr, &recovery.enabled);
     #endif
     #if ENABLED(FWRETRACT)
-      MENU_ITEM(ICON_FWRetract, MSG_FWRETRACT, onDrawSubMenu, Draw_FWRetract_Menu);
+      MENU_ITEM(ICON_FWRetract, MSG_FWRETRACT, onDrawSubMenu, drawFWRetractMenu);
     #endif
     #if ENABLED(JD_TUNE_ITEM)
-      EDIT_ITEM(ICON_JDmm, MSG_JUNCTION_DEVIATION, onDrawPFloat3Menu, SetJDmm, &planner.junction_deviation_mm);
+      EDIT_ITEM(ICON_JDmm, MSG_JUNCTION_DEVIATION, onDrawPFloat3Menu, setJDmm, &planner.junction_deviation_mm);
     #endif
     #if ENABLED(ADVK_TUNE_ITEM)
-      EDIT_ITEM(ICON_MaxAccelerated, MSG_ADVANCE_K, onDrawPFloat3Menu, SetLA_K, &planner.extruder_advance_K[0]);
+      EDIT_ITEM(ICON_MaxAccelerated, MSG_ADVANCE_K, onDrawPFloat3Menu, setLA_K, &planner.extruder_advance_K[0]);
     #endif
     #if HAS_LOCKSCREEN
-      MENU_ITEM(ICON_Lock, MSG_LOCKSCREEN, onDrawMenuItem, DWIN_LockScreen);
+      MENU_ITEM(ICON_Lock, MSG_LOCKSCREEN, onDrawMenuItem, dwinLockScreen);
     #endif
     #if HAS_LCD_BRIGHTNESS
-      EDIT_ITEM(ICON_Brightness, MSG_BRIGHTNESS, onDrawPInt8Menu, SetBrightness, &ui.brightness);
-      MENU_ITEM(ICON_Brightness, MSG_BRIGHTNESS_OFF, onDrawMenuItem, TurnOffBacklight);
+      EDIT_ITEM(ICON_Brightness, MSG_BRIGHTNESS, onDrawPInt8Menu, setBrightness, &ui.brightness);
+      MENU_ITEM(ICON_Brightness, MSG_BRIGHTNESS_OFF, onDrawMenuItem, turnOffBacklight);
     #endif
     #if ENABLED(CASE_LIGHT_MENU)
-      EDIT_ITEM(ICON_CaseLight, MSG_CASE_LIGHT, onDrawChkbMenu, SetCaseLight, &caselight.on);
+      EDIT_ITEM(ICON_CaseLight, MSG_CASE_LIGHT, onDrawChkbMenu, setCaseLight, &caselight.on);
     #elif ENABLED(LED_CONTROL_MENU) && DISABLED(CASE_LIGHT_USE_NEOPIXEL)
-      EDIT_ITEM(ICON_LedControl, MSG_LEDS, onDrawChkbMenu, SetLedStatus, &leds.lights_on);
+      EDIT_ITEM(ICON_LedControl, MSG_LEDS, onDrawChkbMenu, setLedStatus, &leds.lights_on);
     #endif
   }
-  UpdateMenu(TuneMenu);
+  updateMenu(tuneMenu);
 }
 
 #if ENABLED(ADAPTIVE_STEP_SMOOTHING)
-  void SetAdaptiveStepSmoothing() {
-    Toggle_Chkb_Line(HMI_data.AdaptiveStepSmoothing);
+  void setAdaptiveStepSmoothing() {
+    toggleCheckboxLine(hmiData.adaptiveStepSmoothing);
   }
 #endif
 
 #if ENABLED(SHAPING_MENU)
-  void ApplyShapingFreq() { stepper.set_shaping_frequency(HMI_value.axis, MenuData.Value / 100); }
-  void ApplyShapingZeta() { stepper.set_shaping_damping_ratio(HMI_value.axis, MenuData.Value / 100); }
+  void applyShapingFreq() { stepper.set_shaping_frequency(hmiValue.axis, menuData.value / 100); }
+  void applyShapingZeta() { stepper.set_shaping_damping_ratio(hmiValue.axis, menuData.value / 100); }
 
   #if ENABLED(INPUT_SHAPING_X)
-    void onDrawShapingXFreq(MenuItemClass* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, stepper.get_shaping_frequency(X_AXIS)); }
-    void onDrawShapingXZeta(MenuItemClass* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, stepper.get_shaping_damping_ratio(X_AXIS)); }
-    void SetShapingXFreq() { HMI_value.axis = X_AXIS; SetFloatOnClick(0, 200, 2, stepper.get_shaping_frequency(X_AXIS), ApplyShapingFreq); }
-    void SetShapingXZeta() { HMI_value.axis = X_AXIS; SetFloatOnClick(0, 1, 2, stepper.get_shaping_damping_ratio(X_AXIS), ApplyShapingZeta); }
+    void onDrawShapingXFreq(MenuItem* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, stepper.get_shaping_frequency(X_AXIS)); }
+    void onDrawShapingXZeta(MenuItem* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, stepper.get_shaping_damping_ratio(X_AXIS)); }
+    void setShapingXFreq() { hmiValue.axis = X_AXIS; setFloatOnClick(0, 200, 2, stepper.get_shaping_frequency(X_AXIS), applyShapingFreq); }
+    void setShapingXZeta() { hmiValue.axis = X_AXIS; setFloatOnClick(0, 1, 2, stepper.get_shaping_damping_ratio(X_AXIS), applyShapingZeta); }
   #endif
 
   #if ENABLED(INPUT_SHAPING_Y)
-    void onDrawShapingYFreq(MenuItemClass* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, stepper.get_shaping_frequency(Y_AXIS)); }
-    void onDrawShapingYZeta(MenuItemClass* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, stepper.get_shaping_damping_ratio(Y_AXIS)); }
-    void SetShapingYFreq() { HMI_value.axis = Y_AXIS; SetFloatOnClick(0, 200, 2, stepper.get_shaping_frequency(Y_AXIS), ApplyShapingFreq); }
-    void SetShapingYZeta() { HMI_value.axis = Y_AXIS; SetFloatOnClick(0, 1, 2, stepper.get_shaping_damping_ratio(Y_AXIS), ApplyShapingZeta); }
+    void onDrawShapingYFreq(MenuItem* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, stepper.get_shaping_frequency(Y_AXIS)); }
+    void onDrawShapingYZeta(MenuItem* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, stepper.get_shaping_damping_ratio(Y_AXIS)); }
+    void setShapingYFreq() { hmiValue.axis = Y_AXIS; setFloatOnClick(0, 200, 2, stepper.get_shaping_frequency(Y_AXIS), applyShapingFreq); }
+    void setShapingYZeta() { hmiValue.axis = Y_AXIS; setFloatOnClick(0, 1, 2, stepper.get_shaping_damping_ratio(Y_AXIS), applyShapingZeta); }
   #endif
 
-  void Draw_InputShaping_menu() {
-    checkkey = Menu;
-    if (SET_MENU(InputShapingMenu, MSG_INPUT_SHAPING, 5)) {
-      BACK_ITEM(Draw_Motion_Menu);
+  void drawInputShaping_menu() {
+    checkkey = ID_Menu;
+    if (SET_MENU(inputShapingMenu, MSG_INPUT_SHAPING, 5)) {
+      BACK_ITEM(drawMotionMenu);
       #if ENABLED(INPUT_SHAPING_X)
-        MENU_ITEM(ICON_ShapingX, MSG_SHAPING_A_FREQ, onDrawShapingXFreq, SetShapingXFreq);
-        MENU_ITEM(ICON_ShapingX, MSG_SHAPING_A_ZETA, onDrawShapingXZeta, SetShapingXZeta);
+        MENU_ITEM(ICON_ShapingX, MSG_SHAPING_A_FREQ, onDrawShapingXFreq, setShapingXFreq);
+        MENU_ITEM(ICON_ShapingX, MSG_SHAPING_A_ZETA, onDrawShapingXZeta, setShapingXZeta);
       #endif
       #if ENABLED(INPUT_SHAPING_Y)
-        MENU_ITEM(ICON_ShapingY, MSG_SHAPING_B_FREQ, onDrawShapingYFreq, SetShapingYFreq);
-        MENU_ITEM(ICON_ShapingY, MSG_SHAPING_B_ZETA, onDrawShapingYZeta, SetShapingYZeta);
+        MENU_ITEM(ICON_ShapingY, MSG_SHAPING_B_FREQ, onDrawShapingYFreq, setShapingYFreq);
+        MENU_ITEM(ICON_ShapingY, MSG_SHAPING_B_ZETA, onDrawShapingYZeta, setShapingYZeta);
       #endif
     }
-    UpdateMenu(InputShapingMenu);
+    updateMenu(inputShapingMenu);
   }
 #endif
 
 #if HAS_TRINAMIC_CONFIG
   #if AXIS_IS_TMC(X)
-    void SetXTMCCurrent() { SetPIntOnClick(MIN_TMC_CURRENT, MAX_TMC_CURRENT, []{ stepperX.refresh_stepper_current(); }); }
+    void setXTMCCurrent() { setPIntOnClick(MIN_TMC_CURRENT, MAX_TMC_CURRENT, []{ stepperX.refresh_stepper_current(); }); }
   #endif
   #if AXIS_IS_TMC(Y)
-    void SetYTMCCurrent() { SetPIntOnClick(MIN_TMC_CURRENT, MAX_TMC_CURRENT, []{ stepperY.refresh_stepper_current(); }); }
+    void setYTMCCurrent() { setPIntOnClick(MIN_TMC_CURRENT, MAX_TMC_CURRENT, []{ stepperY.refresh_stepper_current(); }); }
   #endif
   #if AXIS_IS_TMC(Z)
-    void SetZTMCCurrent() { SetPIntOnClick(MIN_TMC_CURRENT, MAX_TMC_CURRENT, []{ stepperZ.refresh_stepper_current(); }); }
+    void setZTMCCurrent() { setPIntOnClick(MIN_TMC_CURRENT, MAX_TMC_CURRENT, []{ stepperZ.refresh_stepper_current(); }); }
   #endif
   #if AXIS_IS_TMC(E0)
-    void SetETMCCurrent() { SetPIntOnClick(MIN_TMC_CURRENT, MAX_TMC_CURRENT, []{ stepperE0.refresh_stepper_current(); }); }
+    void setETMCCurrent() { setPIntOnClick(MIN_TMC_CURRENT, MAX_TMC_CURRENT, []{ stepperE0.refresh_stepper_current(); }); }
   #endif
 
-  void Draw_TrinamicConfig_menu() {
-    checkkey = Menu;
-    if (SET_MENU(TrinamicConfigMenu, MSG_TMC_DRIVERS, 5)) {
-      BACK_ITEM(Draw_AdvancedSettings_Menu);
+  void drawTrinamicConfigMenu() {
+    checkkey = ID_Menu;
+    if (SET_MENU(trinamicConfigMenu, MSG_TMC_DRIVERS, 5)) {
+      BACK_ITEM(drawAdvancedSettingsMenu);
       #if AXIS_IS_TMC(X)
-        EDIT_ITEM(ICON_TMCXSet, MSG_TMC_ACURRENT, onDrawPIntMenu, SetXTMCCurrent, &stepperX.val_mA);
+        EDIT_ITEM(ICON_TMCXSet, MSG_TMC_ACURRENT, onDrawPIntMenu, setXTMCCurrent, &stepperX.val_mA);
       #endif
       #if AXIS_IS_TMC(Y)
-        EDIT_ITEM(ICON_TMCYSet, MSG_TMC_BCURRENT, onDrawPIntMenu, SetYTMCCurrent, &stepperY.val_mA);
+        EDIT_ITEM(ICON_TMCYSet, MSG_TMC_BCURRENT, onDrawPIntMenu, setYTMCCurrent, &stepperY.val_mA);
       #endif
       #if AXIS_IS_TMC(Z)
-        EDIT_ITEM(ICON_TMCZSet, MSG_TMC_CCURRENT, onDrawPIntMenu, SetZTMCCurrent, &stepperZ.val_mA);
+        EDIT_ITEM(ICON_TMCZSet, MSG_TMC_CCURRENT, onDrawPIntMenu, setZTMCCurrent, &stepperZ.val_mA);
       #endif
       #if AXIS_IS_TMC(E0)
-        EDIT_ITEM(ICON_TMCESet, MSG_TMC_ECURRENT, onDrawPIntMenu, SetETMCCurrent, &stepperE0.val_mA);
+        EDIT_ITEM(ICON_TMCESet, MSG_TMC_ECURRENT, onDrawPIntMenu, setETMCCurrent, &stepperE0.val_mA);
       #endif
     }
-    UpdateMenu(TrinamicConfigMenu);
+    updateMenu(trinamicConfigMenu);
   }
 #endif
 
-void Draw_Motion_Menu() {
-  checkkey = Menu;
-  if (SET_MENU_R(MotionMenu, selrect({1, 16, 28, 13}), MSG_MOTION, 10)) {
-    BACK_ITEM(Draw_Control_Menu);
-    MENU_ITEM(ICON_MaxSpeed, MSG_SPEED, onDrawSpeed, Draw_MaxSpeed_Menu);
-    MENU_ITEM(ICON_MaxAccelerated, MSG_ACCELERATION, onDrawAcc, Draw_MaxAccel_Menu);
+void drawMotionMenu() {
+  checkkey = ID_Menu;
+  if (SET_MENU_R(motionMenu, selrect({1, 16, 28, 13}), MSG_MOTION, 10)) {
+    BACK_ITEM(drawControlMenu);
+    MENU_ITEM(ICON_MaxSpeed, MSG_SPEED, onDrawSpeed, drawMaxSpeedMenu);
+    MENU_ITEM(ICON_MaxAccelerated, MSG_ACCELERATION, onDrawAcc, drawMaxAccelMenu);
     #if HAS_CLASSIC_JERK
-      MENU_ITEM(ICON_MaxJerk, MSG_JERK, onDrawJerk, Draw_MaxJerk_Menu);
+      MENU_ITEM(ICON_MaxJerk, MSG_JERK, onDrawJerk, drawMaxJerkMenu);
     #elif HAS_JUNCTION_DEVIATION
-      EDIT_ITEM(ICON_JDmm, MSG_JUNCTION_DEVIATION, onDrawPFloat3Menu, SetJDmm, &planner.junction_deviation_mm);
+      EDIT_ITEM(ICON_JDmm, MSG_JUNCTION_DEVIATION, onDrawPFloat3Menu, setJDmm, &planner.junction_deviation_mm);
     #endif
     #if ENABLED(LIN_ADVANCE)
-      EDIT_ITEM(ICON_MaxAccelerated, MSG_ADVANCE_K, onDrawPFloat3Menu, SetLA_K, &planner.extruder_advance_K[0]);
+      EDIT_ITEM(ICON_MaxAccelerated, MSG_ADVANCE_K, onDrawPFloat3Menu, setLA_K, &planner.extruder_advance_K[0]);
     #endif
     #if ENABLED(SHAPING_MENU)
-      MENU_ITEM(ICON_InputShaping, MSG_INPUT_SHAPING, onDrawSubMenu, Draw_InputShaping_menu);
+      MENU_ITEM(ICON_InputShaping, MSG_INPUT_SHAPING, onDrawSubMenu, drawInputShaping_menu);
     #endif
     #if ENABLED(ADAPTIVE_STEP_SMOOTHING)
-      EDIT_ITEM(ICON_UBLActive, MSG_STEP_SMOOTHING, onDrawChkbMenu, SetAdaptiveStepSmoothing, &HMI_data.AdaptiveStepSmoothing);
+      EDIT_ITEM(ICON_UBLActive, MSG_STEP_SMOOTHING, onDrawChkbMenu, setAdaptiveStepSmoothing, &hmiData.adaptiveStepSmoothing);
     #endif
-    MENU_ITEM(ICON_Step, MSG_STEPS_PER_MM, onDrawSteps, Draw_Steps_Menu);
-    EDIT_ITEM(ICON_Flow, MSG_FLOW, onDrawPIntMenu, SetFlow, &planner.flow_percentage[0]);
-    EDIT_ITEM(ICON_Speed, MSG_SPEED, onDrawPIntMenu, SetSpeed, &feedrate_percentage);
+    MENU_ITEM(ICON_Step, MSG_STEPS_PER_MM, onDrawSteps, drawStepsMenu);
+    EDIT_ITEM(ICON_Flow, MSG_FLOW, onDrawPIntMenu, setFlow, &planner.flow_percentage[0]);
+    EDIT_ITEM(ICON_Speed, MSG_SPEED, onDrawPIntMenu, setSpeed, &feedrate_percentage);
   }
-  UpdateMenu(MotionMenu);
+  updateMenu(motionMenu);
 }
 
 #if HAS_PREHEAT
-  void Draw_PreheatHotend_Menu() {
-    checkkey = Menu;
-    if (SET_MENU(PreheatHotendMenu, MSG_PREHEAT_HOTEND, 1 + PREHEAT_COUNT)) {
-      BACK_ITEM(Draw_FilamentMan_Menu);
+  void drawPreheatHotendMenu() {
+    checkkey = ID_Menu;
+    if (SET_MENU(preheatHotendMenu, MSG_PREHEAT_HOTEND, 1 + PREHEAT_COUNT)) {
+      BACK_ITEM(drawFilamentManMenu);
       #define _ITEM_PREHEAT_HE(N) MENU_ITEM(ICON_Preheat##N, MSG_PREHEAT_##N, onDrawMenuItem, DoPreheatHotend##N);
       REPEAT_1(PREHEAT_COUNT, _ITEM_PREHEAT_HE)
     }
-    UpdateMenu(PreheatHotendMenu);
+    updateMenu(preheatHotendMenu);
   }
 #endif
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
 
-  void Draw_FilamentMan_Menu() {
-    checkkey = Menu;
-    if (SET_MENU(FilamentMenu, MSG_FILAMENT_MAN, 6)) {
-      BACK_ITEM(Draw_Prepare_Menu);
+  void drawFilamentManMenu() {
+    checkkey = ID_Menu;
+    if (SET_MENU(filamentMenu, MSG_FILAMENT_MAN, 6)) {
+      BACK_ITEM(drawPrepareMenu);
       #if ENABLED(NOZZLE_PARK_FEATURE)
-        MENU_ITEM(ICON_Park, MSG_FILAMENT_PARK_ENABLED, onDrawMenuItem, ParkHead);
+        MENU_ITEM(ICON_Park, MSG_FILAMENT_PARK_ENABLED, onDrawMenuItem, parkHead);
       #endif
       #if HAS_PREHEAT
-        MENU_ITEM(ICON_SetEndTemp, MSG_PREHEAT_HOTEND, onDrawSubMenu, Draw_PreheatHotend_Menu);
+        MENU_ITEM(ICON_SetEndTemp, MSG_PREHEAT_HOTEND, onDrawSubMenu, drawPreheatHotendMenu);
       #endif
-      MENU_ITEM(ICON_FilMan, MSG_FILAMENTCHANGE, onDrawMenuItem, ChangeFilament);
+      MENU_ITEM(ICON_FilMan, MSG_FILAMENTCHANGE, onDrawMenuItem, changeFilament);
       #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
-        MENU_ITEM(ICON_FilUnload, MSG_FILAMENTUNLOAD, onDrawMenuItem, UnloadFilament);
-        MENU_ITEM(ICON_FilLoad, MSG_FILAMENTLOAD, onDrawMenuItem, LoadFilament);
+        MENU_ITEM(ICON_FilUnload, MSG_FILAMENTUNLOAD, onDrawMenuItem, unloadFilament);
+        MENU_ITEM(ICON_FilLoad, MSG_FILAMENTLOAD, onDrawMenuItem, loadFilament);
       #endif
     }
-    UpdateMenu(FilamentMenu);
+    updateMenu(filamentMenu);
   }
 
 #endif
 
 #if ENABLED(MESH_BED_LEVELING)
 
-  void Draw_ManualMesh_Menu() {
-    checkkey = Menu;
-    if (SET_MENU(ManualMesh, MSG_UBL_MANUAL_MESH, 6)) {
-      BACK_ITEM(Draw_Prepare_Menu);
-      MENU_ITEM(ICON_ManualMesh, MSG_LEVEL_BED, onDrawMenuItem, ManualMeshStart);
-      MMeshMoveZItem = EDIT_ITEM(ICON_Zoffset, MSG_MOVE_Z, onDrawMMeshMoveZ, SetMMeshMoveZ, &current_position.z);
-      MENU_ITEM(ICON_Axis, MSG_UBL_CONTINUE_MESH, onDrawMenuItem, ManualMeshContinue);
-      MENU_ITEM(ICON_MeshViewer, MSG_MESH_VIEW, onDrawSubMenu, DWIN_MeshViewer);
-      MENU_ITEM(ICON_MeshSave, MSG_UBL_SAVE_MESH, onDrawMenuItem, ManualMeshSave);
+  void drawManualMeshMenu() {
+    checkkey = ID_Menu;
+    if (SET_MENU(manualMesh, MSG_UBL_MANUAL_MESH, 6)) {
+      BACK_ITEM(drawPrepareMenu);
+      MENU_ITEM(ICON_ManualMesh, MSG_LEVEL_BED, onDrawMenuItem, manualMeshStart);
+      mMeshMoveZItem = EDIT_ITEM(ICON_Zoffset, MSG_MOVE_Z, onDrawMMeshMoveZ, setMMeshMoveZ, &current_position.z);
+      MENU_ITEM(ICON_Axis, MSG_UBL_CONTINUE_MESH, onDrawMenuItem, manualMeshContinue);
+      MENU_ITEM(ICON_MeshViewer, MSG_MESH_VIEW, onDrawSubMenu, dwinMeshViewer);
+      MENU_ITEM(ICON_MeshSave, MSG_UBL_SAVE_MESH, onDrawMenuItem, manualMeshSave);
     }
-    UpdateMenu(ManualMesh);
+    updateMenu(manualMesh);
   }
 
 #endif // MESH_BED_LEVELING
 
 #if HAS_PREHEAT
 
-  void Draw_Preheat_Menu(bool NotCurrent) {
-    checkkey = Menu;
-    if (NotCurrent) {
-      BACK_ITEM(Draw_Temperature_Menu);
+  void drawPreheatMenu(const bool notCurrent) {
+    checkkey = ID_Menu;
+    if (notCurrent) {
+      BACK_ITEM(drawTemperatureMenu);
       #if HAS_HOTEND
-        EDIT_ITEM(ICON_SetEndTemp, MSG_UBL_SET_TEMP_HOTEND, onDrawSetPreheatHotend, SetPreheatEndTemp, &ui.material_preset[HMI_value.Select].hotend_temp);
+        EDIT_ITEM(ICON_SetEndTemp, MSG_UBL_SET_TEMP_HOTEND, onDrawSetPreheatHotend, setPreheatEndTemp, &ui.material_preset[hmiValue.select].hotend_temp);
       #endif
       #if HAS_HEATED_BED
-        EDIT_ITEM(ICON_SetBedTemp, MSG_UBL_SET_TEMP_BED, onDrawSetPreheatBed, SetPreheatBedTemp, &ui.material_preset[HMI_value.Select].bed_temp);
+        EDIT_ITEM(ICON_SetBedTemp, MSG_UBL_SET_TEMP_BED, onDrawSetPreheatBed, setPreheatBedTemp, &ui.material_preset[hmiValue.select].bed_temp);
       #endif
       #if HAS_FAN
-        EDIT_ITEM(ICON_FanSpeed, MSG_FAN_SPEED, onDrawSetPreheatFan, SetPreheatFanSpeed, &ui.material_preset[HMI_value.Select].fan_speed);
+        EDIT_ITEM(ICON_FanSpeed, MSG_FAN_SPEED, onDrawSetPreheatFan, setPreheatFanSpeed, &ui.material_preset[hmiValue.select].fan_speed);
       #endif
       #if ENABLED(EEPROM_SETTINGS)
-        MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawWriteEeprom, WriteEeprom);
+        MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawWriteEeprom, writeEEPROM);
       #endif
     }
-    UpdateMenu(PreheatMenu);
+    updateMenu(preheatMenu);
   }
 
-  #define _Preheat_Menu(N) \
-    void Draw_Preheat## N ##_Menu() { \
-      HMI_value.Select = (N) - 1; \
-      Draw_Preheat_Menu(SET_MENU(PreheatMenu, MSG_PREHEAT_## N ##_SETTINGS, 5)); \
+  #define _preheatMenu(N) \
+    void drawPreheat## N ##Menu() { \
+      hmiValue.select = (N) - 1; \
+      drawPreheatMenu(SET_MENU(preheatMenu, MSG_PREHEAT_## N ##_SETTINGS, 5)); \
     }
-  REPEAT_1(PREHEAT_COUNT, _Preheat_Menu)
+  REPEAT_1(PREHEAT_COUNT, _preheatMenu)
 
 #endif // HAS_PREHEAT
 
-void Draw_Temperature_Menu() {
-  checkkey = Menu;
-  if (SET_MENU_R(TemperatureMenu, selrect({236, 2, 28, 12}), MSG_TEMPERATURE, 4 + PREHEAT_COUNT)) {
-    BACK_ITEM(Draw_Control_Menu);
+void drawTemperatureMenu() {
+  checkkey = ID_Menu;
+  if (SET_MENU_R(temperatureMenu, selrect({236, 2, 28, 12}), MSG_TEMPERATURE, 4 + PREHEAT_COUNT)) {
+    BACK_ITEM(drawControlMenu);
     #if HAS_HOTEND
-      HotendTargetItem = EDIT_ITEM(ICON_SetEndTemp, MSG_UBL_SET_TEMP_HOTEND, onDrawHotendTemp, SetHotendTemp, &thermalManager.temp_hotend[0].target);
+      hotendTargetItem = EDIT_ITEM(ICON_SetEndTemp, MSG_UBL_SET_TEMP_HOTEND, onDrawHotendTemp, setHotendTemp, &thermalManager.temp_hotend[0].target);
     #endif
     #if HAS_HEATED_BED
-      BedTargetItem = EDIT_ITEM(ICON_SetBedTemp, MSG_UBL_SET_TEMP_BED, onDrawBedTemp, SetBedTemp, &thermalManager.temp_bed.target);
+      bedTargetItem = EDIT_ITEM(ICON_SetBedTemp, MSG_UBL_SET_TEMP_BED, onDrawBedTemp, setBedTemp, &thermalManager.temp_bed.target);
     #endif
     #if HAS_FAN
-      FanSpeedItem = EDIT_ITEM(ICON_FanSpeed, MSG_FAN_SPEED, onDrawFanSpeed, SetFanSpeed, &thermalManager.fan_speed[0]);
+      fanSpeedItem = EDIT_ITEM(ICON_FanSpeed, MSG_FAN_SPEED, onDrawFanSpeed, setFanSpeed, &thermalManager.fan_speed[0]);
     #endif
     #if HAS_PREHEAT
-      #define _ITEM_SETPREHEAT(N) MENU_ITEM(ICON_SetPreheat##N, MSG_PREHEAT_## N ##_SETTINGS, onDrawSubMenu, Draw_Preheat## N ##_Menu);
+      #define _ITEM_SETPREHEAT(N) MENU_ITEM(ICON_SetPreheat##N, MSG_PREHEAT_## N ##_SETTINGS, onDrawSubMenu, drawPreheat## N ##Menu);
       REPEAT_1(PREHEAT_COUNT, _ITEM_SETPREHEAT)
     #endif
   }
-  UpdateMenu(TemperatureMenu);
+  updateMenu(temperatureMenu);
 }
 
-void Draw_MaxSpeed_Menu() {
-  checkkey = Menu;
-  if (SET_MENU_R(MaxSpeedMenu, selrect({1, 16, 28, 13}), MSG_MAX_SPEED, 5)) {
-    BACK_ITEM(Draw_Motion_Menu);
+void drawMaxSpeedMenu() {
+  checkkey = ID_Menu;
+  if (SET_MENU_R(maxSpeedMenu, selrect({1, 16, 28, 13}), MSG_MAX_SPEED, 5)) {
+    BACK_ITEM(drawMotionMenu);
     #if HAS_X_AXIS
-      EDIT_ITEM(ICON_MaxSpeedX, MSG_VMAX_A, onDrawMaxSpeedX, SetMaxSpeedX, &planner.settings.max_feedrate_mm_s[X_AXIS]);
+      EDIT_ITEM(ICON_MaxSpeedX, MSG_VMAX_A, onDrawMaxSpeedX, setMaxSpeedX, &planner.settings.max_feedrate_mm_s[X_AXIS]);
     #endif
     #if HAS_Y_AXIS
-      EDIT_ITEM(ICON_MaxSpeedY, MSG_VMAX_B, onDrawMaxSpeedY, SetMaxSpeedY, &planner.settings.max_feedrate_mm_s[Y_AXIS]);
+      EDIT_ITEM(ICON_MaxSpeedY, MSG_VMAX_B, onDrawMaxSpeedY, setMaxSpeedY, &planner.settings.max_feedrate_mm_s[Y_AXIS]);
     #endif
     #if HAS_Z_AXIS
-      EDIT_ITEM(ICON_MaxSpeedZ, MSG_VMAX_C, onDrawMaxSpeedZ, SetMaxSpeedZ, &planner.settings.max_feedrate_mm_s[Z_AXIS]);
+      EDIT_ITEM(ICON_MaxSpeedZ, MSG_VMAX_C, onDrawMaxSpeedZ, setMaxSpeedZ, &planner.settings.max_feedrate_mm_s[Z_AXIS]);
     #endif
     #if HAS_HOTEND
-      EDIT_ITEM(ICON_MaxSpeedE, MSG_VMAX_E, onDrawMaxSpeedE, SetMaxSpeedE, &planner.settings.max_feedrate_mm_s[E_AXIS]);
+      EDIT_ITEM(ICON_MaxSpeedE, MSG_VMAX_E, onDrawMaxSpeedE, setMaxSpeedE, &planner.settings.max_feedrate_mm_s[E_AXIS]);
     #endif
   }
-  UpdateMenu(MaxSpeedMenu);
+  updateMenu(maxSpeedMenu);
 }
 
-void Draw_MaxAccel_Menu() {
-  checkkey = Menu;
-  if (SET_MENU_R(MaxAccelMenu, selrect({1, 16, 28, 13}), MSG_AMAX_EN, 5)) {
-    BACK_ITEM(Draw_Motion_Menu);
+void drawMaxAccelMenu() {
+  checkkey = ID_Menu;
+  if (SET_MENU_R(maxAccelMenu, selrect({1, 16, 28, 13}), MSG_AMAX_EN, 5)) {
+    BACK_ITEM(drawMotionMenu);
     #if HAS_X_AXIS
-      EDIT_ITEM(ICON_MaxAccX, MSG_AMAX_A, onDrawMaxAccelX, SetMaxAccelX, &planner.settings.max_acceleration_mm_per_s2[X_AXIS]);
+      EDIT_ITEM(ICON_MaxAccX, MSG_AMAX_A, onDrawMaxAccelX, setMaxAccelX, &planner.settings.max_acceleration_mm_per_s2[X_AXIS]);
     #endif
     #if HAS_Y_AXIS
-      EDIT_ITEM(ICON_MaxAccY, MSG_AMAX_B, onDrawMaxAccelY, SetMaxAccelY, &planner.settings.max_acceleration_mm_per_s2[Y_AXIS]);
+      EDIT_ITEM(ICON_MaxAccY, MSG_AMAX_B, onDrawMaxAccelY, setMaxAccelY, &planner.settings.max_acceleration_mm_per_s2[Y_AXIS]);
     #endif
     #if HAS_Z_AXIS
-      EDIT_ITEM(ICON_MaxAccZ, MSG_AMAX_C, onDrawMaxAccelZ, SetMaxAccelZ, &planner.settings.max_acceleration_mm_per_s2[Z_AXIS]);
+      EDIT_ITEM(ICON_MaxAccZ, MSG_AMAX_C, onDrawMaxAccelZ, setMaxAccelZ, &planner.settings.max_acceleration_mm_per_s2[Z_AXIS]);
     #endif
     #if HAS_HOTEND
-      EDIT_ITEM(ICON_MaxAccE, MSG_AMAX_E, onDrawMaxAccelE, SetMaxAccelE, &planner.settings.max_acceleration_mm_per_s2[E_AXIS]);
+      EDIT_ITEM(ICON_MaxAccE, MSG_AMAX_E, onDrawMaxAccelE, setMaxAccelE, &planner.settings.max_acceleration_mm_per_s2[E_AXIS]);
     #endif
   }
-  UpdateMenu(MaxAccelMenu);
+  updateMenu(maxAccelMenu);
 }
 
 #if HAS_CLASSIC_JERK
 
-  void Draw_MaxJerk_Menu() {
-    checkkey = Menu;
-    if (SET_MENU_R(MaxJerkMenu, selrect({1, 16, 28, 13}), MSG_JERK, 5)) {
-      BACK_ITEM(Draw_Motion_Menu);
+  void drawMaxJerkMenu() {
+    checkkey = ID_Menu;
+    if (SET_MENU_R(maxJerkMenu, selrect({1, 16, 28, 13}), MSG_JERK, 5)) {
+      BACK_ITEM(drawMotionMenu);
       #if HAS_X_AXIS
-        EDIT_ITEM(ICON_MaxSpeedJerkX, MSG_VA_JERK, onDrawMaxJerkX, SetMaxJerkX, &planner.max_jerk.x);
+        EDIT_ITEM(ICON_MaxSpeedJerkX, MSG_VA_JERK, onDrawMaxJerkX, setMaxJerkX, &planner.max_jerk.x);
       #endif
       #if HAS_Y_AXIS
-        EDIT_ITEM(ICON_MaxSpeedJerkY, MSG_VB_JERK, onDrawMaxJerkY, SetMaxJerkY, &planner.max_jerk.y);
+        EDIT_ITEM(ICON_MaxSpeedJerkY, MSG_VB_JERK, onDrawMaxJerkY, setMaxJerkY, &planner.max_jerk.y);
       #endif
       #if HAS_Z_AXIS
-        EDIT_ITEM(ICON_MaxSpeedJerkZ, MSG_VC_JERK, onDrawMaxJerkZ, SetMaxJerkZ, &planner.max_jerk.z);
+        EDIT_ITEM(ICON_MaxSpeedJerkZ, MSG_VC_JERK, onDrawMaxJerkZ, setMaxJerkZ, &planner.max_jerk.z);
       #endif
       #if HAS_HOTEND
-        EDIT_ITEM(ICON_MaxSpeedJerkE, MSG_VE_JERK, onDrawMaxJerkE, SetMaxJerkE, &planner.max_jerk.e);
+        EDIT_ITEM(ICON_MaxSpeedJerkE, MSG_VE_JERK, onDrawMaxJerkE, setMaxJerkE, &planner.max_jerk.e);
       #endif
     }
-    UpdateMenu(MaxJerkMenu);
+    updateMenu(maxJerkMenu);
   }
 
 #endif // HAS_CLASSIC_JERK
 
-void Draw_Steps_Menu() {
-  checkkey = Menu;
-  if (SET_MENU_R(StepsMenu, selrect({1, 16, 28, 13}), MSG_STEPS_PER_MM, 5)) {
-    BACK_ITEM(Draw_Motion_Menu);
+void drawStepsMenu() {
+  checkkey = ID_Menu;
+  if (SET_MENU_R(stepsMenu, selrect({1, 16, 28, 13}), MSG_STEPS_PER_MM, 5)) {
+    BACK_ITEM(drawMotionMenu);
     #if HAS_X_AXIS
-      EDIT_ITEM(ICON_StepX, MSG_A_STEPS, onDrawStepsX, SetStepsX, &planner.settings.axis_steps_per_mm[X_AXIS]);
+      EDIT_ITEM(ICON_StepX, MSG_A_STEPS, onDrawStepsX, setStepsX, &planner.settings.axis_steps_per_mm[X_AXIS]);
     #endif
     #if HAS_Y_AXIS
-      EDIT_ITEM(ICON_StepY, MSG_B_STEPS, onDrawStepsY, SetStepsY, &planner.settings.axis_steps_per_mm[Y_AXIS]);
+      EDIT_ITEM(ICON_StepY, MSG_B_STEPS, onDrawStepsY, setStepsY, &planner.settings.axis_steps_per_mm[Y_AXIS]);
     #endif
     #if HAS_Z_AXIS
-      EDIT_ITEM(ICON_StepZ, MSG_C_STEPS, onDrawStepsZ, SetStepsZ, &planner.settings.axis_steps_per_mm[Z_AXIS]);
+      EDIT_ITEM(ICON_StepZ, MSG_C_STEPS, onDrawStepsZ, setStepsZ, &planner.settings.axis_steps_per_mm[Z_AXIS]);
     #endif
     #if HAS_HOTEND
-      EDIT_ITEM(ICON_StepE, MSG_E_STEPS, onDrawStepsE, SetStepsE, &planner.settings.axis_steps_per_mm[E_AXIS]);
+      EDIT_ITEM(ICON_StepE, MSG_E_STEPS, onDrawStepsE, setStepsE, &planner.settings.axis_steps_per_mm[E_AXIS]);
     #endif
   }
-  UpdateMenu(StepsMenu);
+  updateMenu(stepsMenu);
 }
 
 //=============================================================================
 // UI editable custom colors
 //=============================================================================
 
 #if HAS_CUSTOM_COLORS
 
-  void RestoreDefaultColors() {
-    DWIN_SetColorDefaults();
-    DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color, HMI_data.StatusBg_Color);
-    DWIN_RedrawScreen();
+  void restoreDefaultColors() {
+    dwinSetColorDefaults();
+    DWINUI::setColors(hmiData.colorText, hmiData.colorBackground, hmiData.colorStatusBg);
+    dwinRedrawScreen();
   }
 
-  void SelColor() {
-    MenuData.P_Int = (int16_t*)static_cast<MenuItemPtrClass*>(CurrentMenu->SelectedItem())->value;
-    HMI_value.Color[0] = GetRColor(*MenuData.P_Int);  // Red
-    HMI_value.Color[1] = GetGColor(*MenuData.P_Int);  // Green
-    HMI_value.Color[2] = GetBColor(*MenuData.P_Int);  // Blue
-    Draw_GetColor_Menu();
+  void selColor() {
+    menuData.intPtr = (int16_t*)static_cast<MenuItemPtr*>(currentMenu->selectedItem())->value;
+    hmiValue.Color[0] = GetRColor(*menuData.intPtr);  // Red
+    hmiValue.Color[1] = GetGColor(*menuData.intPtr);  // Green
+    hmiValue.Color[2] = GetBColor(*menuData.intPtr);  // Blue
+    drawGetColorMenu();
   }
 
-  void LiveRGBColor() {
-    HMI_value.Color[CurrentMenu->line() - 2] = MenuData.Value;
-    uint16_t color = RGB(HMI_value.Color[0], HMI_value.Color[1], HMI_value.Color[2]);
+  void liveRGBColor() {
+    hmiValue.Color[currentMenu->line() - 2] = menuData.value;
+    uint16_t color = RGB(hmiValue.Color[0], hmiValue.Color[1], hmiValue.Color[2]);
     dwinDrawRectangle(1, color, 20, 315, DWIN_WIDTH - 20, 335);
   }
-  void SetRGBColor() {
-    const uint8_t color = static_cast<MenuItemClass*>(CurrentMenu->SelectedItem())->icon;
-    SetIntOnClick(0, (color == 1) ? 63 : 31, HMI_value.Color[color], nullptr, LiveRGBColor);
+  void setRGBColor() {
+    const uint8_t color = static_cast<MenuItem*>(currentMenu->selectedItem())->icon;
+    setIntOnClick(0, (color == 1) ? 63 : 31, hmiValue.Color[color], nullptr, liveRGBColor);
   }
 
-  void DWIN_ApplyColor() {
-    *MenuData.P_Int = RGB(HMI_value.Color[0], HMI_value.Color[1], HMI_value.Color[2]);
-    DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color, HMI_data.StatusBg_Color);
-    Draw_SelectColors_Menu();
+  void dwinApplyColor() {
+    *menuData.intPtr = RGB(hmiValue.Color[0], hmiValue.Color[1], hmiValue.Color[2]);
+    DWINUI::setColors(hmiData.colorText, hmiData.colorBackground, hmiData.colorStatusBg);
+    drawSelectColorsMenu();
     hash_changed = true;
     LCD_MESSAGE(MSG_COLORS_APPLIED);
-    DWIN_Draw_Dashboard();
-  }
-
-  void Draw_SelectColors_Menu() {
-    checkkey = Menu;
-    if (SET_MENU(SelectColorMenu, MSG_COLORS_SELECT, 20)) {
-      BACK_ITEM(Draw_AdvancedSettings_Menu);
-      MENU_ITEM(ICON_StockConfiguration, MSG_RESTORE_DEFAULTS, onDrawMenuItem, RestoreDefaultColors);
-      EDIT_ITEM_F(0, "Screen Background", onDrawSelColorItem, SelColor, &HMI_data.Background_Color);
-      EDIT_ITEM_F(0, "Cursor", onDrawSelColorItem, SelColor, &HMI_data.Cursor_Color);
-      EDIT_ITEM_F(0, "Title Background", onDrawSelColorItem, SelColor, &HMI_data.TitleBg_Color);
-      EDIT_ITEM_F(0, "Title Text", onDrawSelColorItem, SelColor, &HMI_data.TitleTxt_Color);
-      EDIT_ITEM_F(0, "Text", onDrawSelColorItem, SelColor, &HMI_data.Text_Color);
-      EDIT_ITEM_F(0, "Selected", onDrawSelColorItem, SelColor, &HMI_data.Selected_Color);
-      EDIT_ITEM_F(0, "Split Line", onDrawSelColorItem, SelColor, &HMI_data.SplitLine_Color);
-      EDIT_ITEM_F(0, "Highlight", onDrawSelColorItem, SelColor, &HMI_data.Highlight_Color);
-      EDIT_ITEM_F(0, "Status Background", onDrawSelColorItem, SelColor, &HMI_data.StatusBg_Color);
-      EDIT_ITEM_F(0, "Status Text", onDrawSelColorItem, SelColor, &HMI_data.StatusTxt_Color);
-      EDIT_ITEM_F(0, "Popup Background", onDrawSelColorItem, SelColor, &HMI_data.PopupBg_Color);
-      EDIT_ITEM_F(0, "Popup Text", onDrawSelColorItem, SelColor, &HMI_data.PopupTxt_Color);
-      EDIT_ITEM_F(0, "Alert Background", onDrawSelColorItem, SelColor, &HMI_data.AlertBg_Color);
-      EDIT_ITEM_F(0, "Alert Text", onDrawSelColorItem, SelColor, &HMI_data.AlertTxt_Color);
-      EDIT_ITEM_F(0, "Percent Text", onDrawSelColorItem, SelColor, &HMI_data.PercentTxt_Color);
-      EDIT_ITEM_F(0, "Bar Fill", onDrawSelColorItem, SelColor, &HMI_data.Barfill_Color);
-      EDIT_ITEM_F(0, "Indicator value", onDrawSelColorItem, SelColor, &HMI_data.Indicator_Color);
-      EDIT_ITEM_F(0, "Coordinate value", onDrawSelColorItem, SelColor, &HMI_data.Coordinate_Color);
-    }
-    UpdateMenu(SelectColorMenu);
-  }
-
-  void Draw_GetColor_Menu() {
-    checkkey = Menu;
-    if (SET_MENU(GetColorMenu, MSG_COLORS_GET, 5)) {
-      BACK_ITEM(DWIN_ApplyColor);
-      MENU_ITEM(ICON_Cancel, MSG_BUTTON_CANCEL, onDrawMenuItem, Draw_SelectColors_Menu);
-      MENU_ITEM(0, MSG_COLORS_RED, onDrawGetColorItem, SetRGBColor);
-      MENU_ITEM(1, MSG_COLORS_GREEN, onDrawGetColorItem, SetRGBColor);
-      MENU_ITEM(2, MSG_COLORS_BLUE, onDrawGetColorItem, SetRGBColor);
-    }
-    UpdateMenu(GetColorMenu);
-    dwinDrawRectangle(1, *MenuData.P_Int, 20, 315, DWIN_WIDTH - 20, 335);
+    dwinDrawDashboard();
+  }
+
+  void drawSelectColorsMenu() {
+    checkkey = ID_Menu;
+    if (SET_MENU(selectColorMenu, MSG_COLORS_SELECT, 20)) {
+      BACK_ITEM(drawAdvancedSettingsMenu);
+      MENU_ITEM(ICON_StockConfiguration, MSG_RESTORE_DEFAULTS, onDrawMenuItem, restoreDefaultColors);
+      EDIT_ITEM_F(0, "Screen Background", onDrawSelColorItem, selColor, &hmiData.colorBackground);
+      EDIT_ITEM_F(0, "Cursor", onDrawSelColorItem, selColor, &hmiData.colorCursor);
+      EDIT_ITEM_F(0, "Title Background", onDrawSelColorItem, selColor, &hmiData.colorTitleBg);
+      EDIT_ITEM_F(0, "Title Text", onDrawSelColorItem, selColor, &hmiData.colorTitleTxt);
+      EDIT_ITEM_F(0, "Text", onDrawSelColorItem, selColor, &hmiData.colorText);
+      EDIT_ITEM_F(0, "Selected", onDrawSelColorItem, selColor, &hmiData.colorSelected);
+      EDIT_ITEM_F(0, "Split Line", onDrawSelColorItem, selColor, &hmiData.colorSplitLine);
+      EDIT_ITEM_F(0, "Highlight", onDrawSelColorItem, selColor, &hmiData.colorHighlight);
+      EDIT_ITEM_F(0, "Status Background", onDrawSelColorItem, selColor, &hmiData.colorStatusBg);
+      EDIT_ITEM_F(0, "Status Text", onDrawSelColorItem, selColor, &hmiData.colorStatusTxt);
+      EDIT_ITEM_F(0, "Popup Background", onDrawSelColorItem, selColor, &hmiData.colorPopupBg);
+      EDIT_ITEM_F(0, "Popup Text", onDrawSelColorItem, selColor, &hmiData.colorPopupTxt);
+      EDIT_ITEM_F(0, "Alert Background", onDrawSelColorItem, selColor, &hmiData.colorAlertBg);
+      EDIT_ITEM_F(0, "Alert Text", onDrawSelColorItem, selColor, &hmiData.colorAlertTxt);
+      EDIT_ITEM_F(0, "Percent Text", onDrawSelColorItem, selColor, &hmiData.colorPercentTxt);
+      EDIT_ITEM_F(0, "Bar Fill", onDrawSelColorItem, selColor, &hmiData.colorBarfill);
+      EDIT_ITEM_F(0, "Indicator value", onDrawSelColorItem, selColor, &hmiData.colorIndicator);
+      EDIT_ITEM_F(0, "Coordinate value", onDrawSelColorItem, selColor, &hmiData.colorCoordinate);
+    }
+    updateMenu(selectColorMenu);
+  }
+
+  void drawGetColorMenu() {
+    checkkey = ID_Menu;
+    if (SET_MENU(getColorMenu, MSG_COLORS_GET, 5)) {
+      BACK_ITEM(dwinApplyColor);
+      MENU_ITEM(ICON_Cancel, MSG_BUTTON_CANCEL, onDrawMenuItem, drawSelectColorsMenu);
+      MENU_ITEM(0, MSG_COLORS_RED, onDrawGetColorItem, setRGBColor);
+      MENU_ITEM(1, MSG_COLORS_GREEN, onDrawGetColorItem, setRGBColor);
+      MENU_ITEM(2, MSG_COLORS_BLUE, onDrawGetColorItem, setRGBColor);
+    }
+    updateMenu(getColorMenu);
+    dwinDrawRectangle(1, *menuData.intPtr, 20, 315, DWIN_WIDTH - 20, 335);
   }
 
 #endif // HAS_CUSTOM_COLORS
 
 //=============================================================================
 // Nozzle and Bed PID/MPC
 //=============================================================================
 
 #if ANY(MPC_EDIT_MENU, MPC_AUTOTUNE_MENU)
 
   #if ENABLED(MPC_EDIT_MENU)
-    void SetHeaterPower() { SetPFloatOnClick(1, 200, 1); }
-    void SetBlkHeatCapacity() { SetPFloatOnClick(0, 40, 2); }
-    void SetSensorResponse() { SetPFloatOnClick(0, 1, 4); }
-    void SetAmbientXfer() { SetPFloatOnClick(0, 1, 4); }
+    void setHeaterPower() { setPFloatOnClick(1, 200, 1); }
+    void setBlkHeatCapacity() { setPFloatOnClick(0, 40, 2); }
+    void setSensorResponse() { setPFloatOnClick(0, 1, 4); }
+    void setAmbientXfer() { setPFloatOnClick(0, 1, 4); }
     #if ENABLED(MPC_INCLUDE_FAN)
-      void onDrawFanAdj(MenuItemClass* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 4, thermalManager.temp_hotend[0].fanCoefficient()); }
-      void ApplyFanAdj() { thermalManager.temp_hotend[0].applyFanAdjustment(MenuData.Value / POW(10, 4)); }
-      void SetFanAdj() { SetFloatOnClick(0, 1, 4, thermalManager.temp_hotend[0].fanCoefficient(), ApplyFanAdj); }
+      void onDrawFanAdj(MenuItem* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 4, thermalManager.temp_hotend[0].fanCoefficient()); }
+      void applyFanAdj() { thermalManager.temp_hotend[0].applyFanAdjustment(menuData.value / POW(10, 4)); }
+      void setFanAdj() { setFloatOnClick(0, 1, 4, thermalManager.temp_hotend[0].fanCoefficient(), applyFanAdj); }
     #endif
   #endif
 
-  void Draw_HotendMPC_Menu() {
-    checkkey = Menu;
-    if (SET_MENU_F(HotendMPCMenu, "MPC Settings", 7)) {
+  void drawHotendMPCMenu() {
+    checkkey = ID_Menu;
+    if (SET_MENU_F(hotendMPCMenu, "MPC Settings", 7)) {
       MPC_t &mpc = thermalManager.temp_hotend[0].mpc;
-      BACK_ITEM(Draw_AdvancedSettings_Menu);
+      BACK_ITEM(drawAdvancedSettingsMenu);
       #if ENABLED(MPC_AUTOTUNE_MENU)
         MENU_ITEM(ICON_MPCNozzle, MSG_MPC_AUTOTUNE, onDrawMenuItem, []{ thermalManager.MPC_autotune(active_extruder, Temperature::MPCTuningType::AUTO); });
       #endif
       #if ENABLED(MPC_EDIT_MENU)
-        EDIT_ITEM(ICON_MPCHeater, MSG_MPC_POWER, onDrawPFloatMenu, SetHeaterPower, &mpc.heater_power);
-        EDIT_ITEM(ICON_MPCHeatCap, MSG_MPC_BLOCK_HEAT_CAPACITY, onDrawPFloat2Menu, SetBlkHeatCapacity, &mpc.block_heat_capacity);
-        EDIT_ITEM(ICON_MPCValue, MSG_SENSOR_RESPONSIVENESS, onDrawPFloat4Menu, SetSensorResponse, &mpc.sensor_responsiveness);
-        EDIT_ITEM(ICON_MPCValue, MSG_MPC_AMBIENT_XFER_COEFF, onDrawPFloat4Menu, SetAmbientXfer, &mpc.ambient_xfer_coeff_fan0);
+        EDIT_ITEM(ICON_MPCHeater, MSG_MPC_POWER, onDrawPFloatMenu, setHeaterPower, &mpc.heater_power);
+        EDIT_ITEM(ICON_MPCHeatCap, MSG_MPC_BLOCK_HEAT_CAPACITY, onDrawPFloat2Menu, setBlkHeatCapacity, &mpc.block_heat_capacity);
+        EDIT_ITEM(ICON_MPCValue, MSG_SENSOR_RESPONSIVENESS, onDrawPFloat4Menu, setSensorResponse, &mpc.sensor_responsiveness);
+        EDIT_ITEM(ICON_MPCValue, MSG_MPC_AMBIENT_XFER_COEFF, onDrawPFloat4Menu, setAmbientXfer, &mpc.ambient_xfer_coeff_fan0);
         #if ENABLED(MPC_INCLUDE_FAN)
-          EDIT_ITEM(ICON_MPCFan, MSG_MPC_AMBIENT_XFER_COEFF_FAN, onDrawFanAdj, SetFanAdj, &mpc.fan255_adjustment);
+          EDIT_ITEM(ICON_MPCFan, MSG_MPC_AMBIENT_XFER_COEFF_FAN, onDrawFanAdj, setFanAdj, &mpc.fan255_adjustment);
         #endif
       #endif
     }
-    UpdateMenu(HotendMPCMenu);
+    updateMenu(hotendMPCMenu);
   }
 
 #endif // MPC_EDIT_MENU || MPC_AUTOTUNE_MENU
 
-#if DWIN_PID_TUNE
-  void SetPID(celsius_t t, heater_id_t h) {
+#if PROUI_PID_TUNE
+  void setPID(celsius_t t, heater_id_t h) {
     gcode.process_subcommands_now(
       MString<60>(F("G28OXY\nG0Z5F300\nG0X"), X_CENTER, F("Y"), Y_CENTER, F("F5000\nM84\nM400"))
     );
-    thermalManager.PID_autotune(t, h, HMI_data.PidCycles, true);
+    thermalManager.PID_autotune(t, h, hmiData.pidCycles, true);
   }
-  void SetPidCycles() { SetPIntOnClick(3, 50); }
+  void setPidCycles() { setPIntOnClick(3, 50); }
 #endif
 
 #if ALL(HAS_PID_HEATING, PID_EDIT_MENU)
 
-  void SetKp() { SetPFloatOnClick(0, 1000, 2); }
-  void ApplyPIDi() {
-    *MenuData.P_Float = scalePID_i(MenuData.Value / POW(10, 2));
+  void setKp() { setPFloatOnClick(0, 1000, 2); }
+  void applyPIDi() {
+    *menuData.floatPtr = scalePID_i(menuData.value / POW(10, 2));
     TERN_(PIDTEMP, thermalManager.updatePID());
   }
-  void ApplyPIDd() {
-    *MenuData.P_Float = scalePID_d(MenuData.Value / POW(10, 2));
+  void applyPIDd() {
+    *menuData.floatPtr = scalePID_d(menuData.value / POW(10, 2));
     TERN_(PIDTEMP, thermalManager.updatePID());
   }
-  void SetKi() {
-    MenuData.P_Float = (float*)static_cast<MenuItemPtrClass*>(CurrentMenu->SelectedItem())->value;
-    const float value = unscalePID_i(*MenuData.P_Float);
-    SetFloatOnClick(0, 1000, 2, value, ApplyPIDi);
+  void setKi() {
+    menuData.floatPtr = (float*)static_cast<MenuItemPtr*>(currentMenu->selectedItem())->value;
+    const float value = unscalePID_i(*menuData.floatPtr);
+    setFloatOnClick(0, 1000, 2, value, applyPIDi);
   }
-  void SetKd() {
-    MenuData.P_Float = (float*)static_cast<MenuItemPtrClass*>(CurrentMenu->SelectedItem())->value;
-    const float value = unscalePID_d(*MenuData.P_Float);
-    SetFloatOnClick(0, 1000, 2, value, ApplyPIDd);
+  void setKd() {
+    menuData.floatPtr = (float*)static_cast<MenuItemPtr*>(currentMenu->selectedItem())->value;
+    const float value = unscalePID_d(*menuData.floatPtr);
+    setFloatOnClick(0, 1000, 2, value, applyPIDd);
   }
-  void onDrawPIDi(MenuItemClass* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, unscalePID_i(*(float*)static_cast<MenuItemPtrClass*>(menuitem)->value)); }
-  void onDrawPIDd(MenuItemClass* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, unscalePID_d(*(float*)static_cast<MenuItemPtrClass*>(menuitem)->value)); }
+  void onDrawPIDi(MenuItem* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, unscalePID_i(*(float*)static_cast<MenuItemPtr*>(menuitem)->value)); }
+  void onDrawPIDd(MenuItem* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, unscalePID_d(*(float*)static_cast<MenuItemPtr*>(menuitem)->value)); }
 
 #endif // HAS_PID_HEATING && PID_EDIT_MENU
 
 #if ENABLED(PIDTEMP) && ANY(PID_AUTOTUNE_MENU, PID_EDIT_MENU)
 
   #if ENABLED(PID_AUTOTUNE_MENU)
-    void HotendPID() { SetPID(HMI_data.HotendPidT, H_E0); }
-    void SetHotendPidT() { SetPIntOnClick(MIN_ETEMP, MAX_ETEMP); }
+    void hotendPID() { setPID(hmiData.hotendPidT, H_E0); }
+    void setHotendPidT() { setPIntOnClick(MIN_ETEMP, MAX_ETEMP); }
   #endif
 
-  void Draw_HotendPID_Menu() {
-    checkkey = Menu;
-    if (SET_MENU_F(HotendPIDMenu, STR_HOTEND_PID " Settings", 8)) {
-      BACK_ITEM(Draw_AdvancedSettings_Menu);
+  void drawHotendPIDMenu() {
+    checkkey = ID_Menu;
+    if (SET_MENU_F(hotendPIDMenu, STR_HOTEND_PID " Settings", 8)) {
+      BACK_ITEM(drawAdvancedSettingsMenu);
       #if ENABLED(PID_AUTOTUNE_MENU)
-        MENU_ITEM_F(ICON_PIDNozzle, STR_HOTEND_PID, onDrawMenuItem, HotendPID);
-        EDIT_ITEM(ICON_Temperature, MSG_TEMPERATURE, onDrawPIntMenu, SetHotendPidT, &HMI_data.HotendPidT);
-        EDIT_ITEM(ICON_PIDCycles, MSG_PID_CYCLE, onDrawPIntMenu, SetPidCycles, &HMI_data.PidCycles);
+        MENU_ITEM_F(ICON_PIDNozzle, STR_HOTEND_PID, onDrawMenuItem, hotendPID);
+        EDIT_ITEM(ICON_Temperature, MSG_TEMPERATURE, onDrawPIntMenu, setHotendPidT, &hmiData.hotendPidT);
+        EDIT_ITEM(ICON_PIDCycles, MSG_PID_CYCLE, onDrawPIntMenu, setPidCycles, &hmiData.pidCycles);
       #endif
       #if ENABLED(PID_EDIT_MENU)
         EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KP, onDrawPFloat2Menu, SetKp, &thermalManager.temp_hotend[0].pid.Kp);
         EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KI, onDrawPIDi, SetKi, &thermalManager.temp_hotend[0].pid.Ki);
         EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KD, onDrawPIDd, SetKd, &thermalManager.temp_hotend[0].pid.Kd);
       #endif
       #if ENABLED(EEPROM_SETTINGS)
-        MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawMenuItem, WriteEeprom);
+        MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawMenuItem, writeEEPROM);
       #endif
     }
-    UpdateMenu(HotendPIDMenu);
+    updateMenu(hotendPIDMenu);
   }
 
 #endif // PIDTEMP && (PID_AUTOTUNE_MENU || PID_EDIT_MENU)
 
 #if ENABLED(PIDTEMPBED) && ANY(PID_AUTOTUNE_MENU, PID_EDIT_MENU)
 
   #if ENABLED(PID_AUTOTUNE_MENU)
-    void BedPID() { SetPID(HMI_data.BedPidT, H_BED); }
-    void SetBedPidT() { SetPIntOnClick(MIN_BEDTEMP, MAX_BEDTEMP); }
+    void bedPID() { setPID(hmiData.bedPidT, H_BED); }
+    void setBedPidT() { setPIntOnClick(MIN_BEDTEMP, MAX_BEDTEMP); }
   #endif
 
-  void Draw_BedPID_Menu() {
-    checkkey = Menu;
-    if (SET_MENU_F(BedPIDMenu, STR_BED_PID " Settings", 8)) {
-      BACK_ITEM(Draw_AdvancedSettings_Menu);
+  void drawBedPIDMenu() {
+    checkkey = ID_Menu;
+    if (SET_MENU_F(bedPIDMenu, STR_BED_PID " Settings", 8)) {
+      BACK_ITEM(drawAdvancedSettingsMenu);
       #if ENABLED(PID_AUTOTUNE_MENU)
-        MENU_ITEM_F(ICON_PIDBed, STR_BED_PID, onDrawMenuItem,BedPID);
-        EDIT_ITEM(ICON_Temperature, MSG_TEMPERATURE, onDrawPIntMenu, SetBedPidT, &HMI_data.BedPidT);
-        EDIT_ITEM(ICON_PIDCycles, MSG_PID_CYCLE, onDrawPIntMenu, SetPidCycles, &HMI_data.PidCycles);
+        MENU_ITEM_F(ICON_PIDBed, STR_BED_PID, onDrawMenuItem,bedPID);
+        EDIT_ITEM(ICON_Temperature, MSG_TEMPERATURE, onDrawPIntMenu, setBedPidT, &hmiData.bedPidT);
+        EDIT_ITEM(ICON_PIDCycles, MSG_PID_CYCLE, onDrawPIntMenu, setPidCycles, &hmiData.pidCycles);
       #endif
       #if ENABLED(PID_EDIT_MENU)
         EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KP, onDrawPFloat2Menu, SetKp, &thermalManager.temp_bed.pid.Kp);
         EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KI, onDrawPIDi, SetKi, &thermalManager.temp_bed.pid.Ki);
         EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KD, onDrawPIDd, SetKd, &thermalManager.temp_bed.pid.Kd);
       #endif
       #if ENABLED(EEPROM_SETTINGS)
-        MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawMenuItem, WriteEeprom);
+        MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawMenuItem, writeEEPROM);
       #endif
     }
-    UpdateMenu(BedPIDMenu);
+    updateMenu(bedPIDMenu);
   }
 
 #endif // PIDTEMPBED && (PID_AUTOTUNE_MENU || PID_EDIT_MENU)
 
 //=============================================================================
 
 #if HAS_BED_PROBE
 
-  void Draw_ZOffsetWiz_Menu() {
-    checkkey = Menu;
-    if (SET_MENU(ZOffsetWizMenu, MSG_PROBE_WIZARD, 4)) {
-      BACK_ITEM(Draw_Prepare_Menu);
-      MENU_ITEM(ICON_Homing, MSG_AUTO_HOME, onDrawMenuItem, AutoHome);
-      MENU_ITEM_F(ICON_MoveZ0, "Move Z to Home", onDrawMenuItem, SetMoveZto0);
-      EDIT_ITEM(ICON_Zoffset, MSG_ZPROBE_ZOFFSET, onDrawPFloat2Menu, SetZOffset, &BABY_Z_VAR);
+  void drawZOffsetWizMenu() {
+    checkkey = ID_Menu;
+    if (SET_MENU(zOffsetWizMenu, MSG_PROBE_WIZARD, 4)) {
+      BACK_ITEM(drawPrepareMenu);
+      MENU_ITEM(ICON_Homing, MSG_AUTO_HOME, onDrawMenuItem, autoHome);
+      MENU_ITEM_F(ICON_MoveZ0, "Move Z to Home", onDrawMenuItem, setMoveZto0);
+      EDIT_ITEM(ICON_Zoffset, MSG_ZPROBE_ZOFFSET, onDrawPFloat2Menu, setZOffset, &BABY_Z_VAR);
     }
-    UpdateMenu(ZOffsetWizMenu);
+    updateMenu(zOffsetWizMenu);
     if (!axis_is_trusted(Z_AXIS)) LCD_MESSAGE_F("WARNING: Z position unknown, move Z to home");
   }
 
 #endif
 
 #if ENABLED(INDIVIDUAL_AXIS_HOMING_SUBMENU)
 
-  void Draw_Homing_Menu() {
-    checkkey = Menu;
-    if (SET_MENU(HomingMenu, MSG_HOMING, 6)) {
-      BACK_ITEM(Draw_Prepare_Menu);
-      MENU_ITEM(ICON_Homing, MSG_AUTO_HOME, onDrawMenuItem, AutoHome);
+  void drawHomingMenu() {
+    checkkey = ID_Menu;
+    if (SET_MENU(homingMenu, MSG_HOMING, 6)) {
+      BACK_ITEM(drawPrepareMenu);
+      MENU_ITEM(ICON_Homing, MSG_AUTO_HOME, onDrawMenuItem, autoHome);
       #if HAS_X_AXIS
-        MENU_ITEM(ICON_HomeX, MSG_AUTO_HOME_X, onDrawMenuItem, HomeX);
+        MENU_ITEM(ICON_HomeX, MSG_AUTO_HOME_X, onDrawMenuItem, homeX);
       #endif
       #if HAS_Y_AXIS
-        MENU_ITEM(ICON_HomeY, MSG_AUTO_HOME_Y, onDrawMenuItem, HomeY);
+        MENU_ITEM(ICON_HomeY, MSG_AUTO_HOME_Y, onDrawMenuItem, homeY);
       #endif
       #if HAS_Z_AXIS
-        MENU_ITEM(ICON_HomeZ, MSG_AUTO_HOME_Z, onDrawMenuItem, HomeZ);
+        MENU_ITEM(ICON_HomeZ, MSG_AUTO_HOME_Z, onDrawMenuItem, homeZ);
       #endif
       #if ENABLED(MESH_BED_LEVELING)
-        EDIT_ITEM(ICON_ZAfterHome, MSG_Z_AFTER_HOME, onDrawPInt8Menu, SetZAfterHoming, &HMI_data.z_after_homing);
+        EDIT_ITEM(ICON_ZAfterHome, MSG_Z_AFTER_HOME, onDrawPInt8Menu, setZAfterHoming, &hmiData.zAfterHoming);
       #endif
     }
-    UpdateMenu(HomingMenu);
+    updateMenu(homingMenu);
   }
 
 #endif // INDIVIDUAL_AXIS_HOMING_SUBMENU
 
 #if ENABLED(FWRETRACT)
 
-  void Draw_FWRetract_Menu() {
-    checkkey = Menu;
-    if (SET_MENU(FWRetractMenu, MSG_FWRETRACT, 6)) {
-      BACK_ITEM(Return_FWRetract_Menu);
-      EDIT_ITEM(ICON_FWRetLength, MSG_CONTROL_RETRACT, onDrawPFloatMenu, SetRetractLength, &fwretract.settings.retract_length);
-      EDIT_ITEM(ICON_FWRetSpeed, MSG_SINGLENOZZLE_RETRACT_SPEED, onDrawPFloatMenu, SetRetractSpeed, &fwretract.settings.retract_feedrate_mm_s);
-      EDIT_ITEM(ICON_FWRetZRaise, MSG_CONTROL_RETRACT_ZHOP, onDrawPFloat2Menu, SetZRaise, &fwretract.settings.retract_zraise);
-      EDIT_ITEM(ICON_FWRecSpeed, MSG_SINGLENOZZLE_UNRETRACT_SPEED, onDrawPFloatMenu, SetRecoverSpeed, &fwretract.settings.retract_recover_feedrate_mm_s);
-      EDIT_ITEM(ICON_FWRecExtra, MSG_CONTROL_RETRACT_RECOVER, onDrawPFloatMenu, SetAddRecover, &fwretract.settings.retract_recover_extra);
+  void drawFWRetractMenu() {
+    checkkey = ID_Menu;
+    if (SET_MENU(fwRetractMenu, MSG_FWRETRACT, 6)) {
+      BACK_ITEM(returnFWRetractMenu);
+      EDIT_ITEM(ICON_FWRetLength, MSG_CONTROL_RETRACT, onDrawPFloatMenu, setRetractLength, &fwretract.settings.retract_length);
+      EDIT_ITEM(ICON_FWRetSpeed, MSG_SINGLENOZZLE_RETRACT_SPEED, onDrawPFloatMenu, setRetractSpeed, &fwretract.settings.retract_feedrate_mm_s);
+      EDIT_ITEM(ICON_FWRetZRaise, MSG_CONTROL_RETRACT_ZHOP, onDrawPFloat2Menu, setZRaise, &fwretract.settings.retract_zraise);
+      EDIT_ITEM(ICON_FWRecSpeed, MSG_SINGLENOZZLE_UNRETRACT_SPEED, onDrawPFloatMenu, setRecoverSpeed, &fwretract.settings.retract_recover_feedrate_mm_s);
+      EDIT_ITEM(ICON_FWRecExtra, MSG_CONTROL_RETRACT_RECOVER, onDrawPFloatMenu, setAddRecover, &fwretract.settings.retract_recover_extra);
     }
-    UpdateMenu(FWRetractMenu);
+    updateMenu(fwRetractMenu);
   }
 
 #endif
 
 //=============================================================================
 // Mesh Bed Leveling
 //=============================================================================
 
 #if HAS_MESH
 
-  void ApplyMeshFadeHeight() { set_z_fade_height(planner.z_fade_height); }
-  void SetMeshFadeHeight() { SetPFloatOnClick(0, 100, 1, ApplyMeshFadeHeight); }
+  void applyMeshFadeHeight() { set_z_fade_height(planner.z_fade_height); }
+  void setMeshFadeHeight() { setPFloatOnClick(0, 100, 1, applyMeshFadeHeight); }
 
-  void SetMeshActive() {
+  void setMeshActive() {
     set_bed_leveling_enabled(!planner.leveling_active);
-    Draw_Chkb_Line(CurrentMenu->line(), planner.leveling_active);
+    drawCheckboxLine(currentMenu->line(), planner.leveling_active);
     dwinUpdateLCD();
   }
 
   #if ENABLED(PREHEAT_BEFORE_LEVELING)
-    void SetBedLevT() { SetPIntOnClick(MIN_BEDTEMP, MAX_BEDTEMP); }
+    void setBedLevT() { setPIntOnClick(MIN_BEDTEMP, MAX_BEDTEMP); }
   #endif
 
   #if ENABLED(MESH_EDIT_MENU)
     #define Z_OFFSET_MIN -3
     #define Z_OFFSET_MAX  3
 
-    void LiveEditMesh() { ((MenuItemPtrClass*)EditZValueItem)->value = &bedlevel.z_values[HMI_value.Select ? bedLevelTools.mesh_x : MenuData.Value][HMI_value.Select ? MenuData.Value : bedLevelTools.mesh_y]; EditZValueItem->redraw(); }
-    void ApplyEditMeshX() { bedLevelTools.mesh_x = MenuData.Value; }
-    void ApplyEditMeshY() { bedLevelTools.mesh_y = MenuData.Value; }
-    void ResetMesh() { bedLevelTools.mesh_reset(); LCD_MESSAGE(MSG_MESH_RESET); }
-    void SetEditMeshX() { HMI_value.Select = 0; SetIntOnClick(0, GRID_MAX_POINTS_X - 1, bedLevelTools.mesh_x, ApplyEditMeshX, LiveEditMesh); }
-    void SetEditMeshY() { HMI_value.Select = 1; SetIntOnClick(0, GRID_MAX_POINTS_Y - 1, bedLevelTools.mesh_y, ApplyEditMeshY, LiveEditMesh); }
-    void SetEditZValue() { SetPFloatOnClick(Z_OFFSET_MIN, Z_OFFSET_MAX, 3); }
+    void LiveEditMesh() { ((MenuItemPtr*)editZValueItem)->value = &bedlevel.z_values[hmiValue.select ? bedLevelTools.mesh_x : menuData.value][hmiValue.select ? menuData.value : bedLevelTools.mesh_y]; editZValueItem->redraw(); }
+    void applyEditMeshX() { bedLevelTools.mesh_x = menuData.value; }
+    void applyEditMeshY() { bedLevelTools.mesh_y = menuData.value; }
+    void ResetMesh() { bedLevelTools.meshReset(); LCD_MESSAGE(MSG_MESH_RESET); }
+    void setEditMeshX() { hmiValue.select = 0; setIntOnClick(0, GRID_MAX_POINTS_X - 1, bedLevelTools.mesh_x, applyEditMeshX, LiveEditMesh); }
+    void setEditMeshY() { hmiValue.select = 1; setIntOnClick(0, GRID_MAX_POINTS_Y - 1, bedLevelTools.mesh_y, applyEditMeshY, LiveEditMesh); }
+    void setEditZValue() { setPFloatOnClick(Z_OFFSET_MIN, Z_OFFSET_MAX, 3); }
   #endif
 
 #endif // HAS_MESH
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
 
-  void ApplyUBLSlot() { bedlevel.storage_slot = MenuData.Value; }
-  void SetUBLSlot() { SetIntOnClick(0, settings.calc_num_meshes() - 1, bedlevel.storage_slot, ApplyUBLSlot); }
-  void onDrawUBLSlot(MenuItemClass* menuitem, int8_t line) {
+  void applyUBLSlot() { bedlevel.storage_slot = menuData.value; }
+  void setUBLSlot() { setIntOnClick(0, settings.calc_num_meshes() - 1, bedlevel.storage_slot, applyUBLSlot); }
+  void onDrawUBLSlot(MenuItem* menuitem, int8_t line) {
     NOLESS(bedlevel.storage_slot, 0);
     onDrawIntMenu(menuitem, line, bedlevel.storage_slot);
   }
 
-  void ApplyUBLTiltGrid() { bedLevelTools.tilt_grid = MenuData.Value; }
-  void SetUBLTiltGrid() { SetIntOnClick(1, 3, bedLevelTools.tilt_grid, ApplyUBLTiltGrid); }
+  void applyUBLTiltGrid() { bedLevelTools.tilt_grid = menuData.value; }
+  void setUBLTiltGrid() { setIntOnClick(1, 3, bedLevelTools.tilt_grid, applyUBLTiltGrid); }
 
-  void UBLMeshTilt() {
+  void ublMeshTilt() {
     NOLESS(bedlevel.storage_slot, 0);
     if (bedLevelTools.tilt_grid > 1)
       gcode.process_subcommands_now(TS(F("G29J"), bedLevelTools.tilt_grid));
     else
       gcode.process_subcommands_now(F("G29J"));
     LCD_MESSAGE(MSG_UBL_MESH_TILTED);
   }
 
-  void UBLSmartFillMesh() {
+  void ublSmartFillMesh() {
     for (uint8_t x = 0; x < GRID_MAX_POINTS_Y; ++x) bedlevel.smart_fill_mesh();
     LCD_MESSAGE(MSG_UBL_MESH_FILLED);
   }
 
-  void UBLMeshSave() {
+  void ublMeshSave() {
     NOLESS(bedlevel.storage_slot, 0);
     settings.store_mesh(bedlevel.storage_slot);
     ui.status_printf(0, GET_TEXT_F(MSG_MESH_SAVED), bedlevel.storage_slot);
     DONE_BUZZ(true);
   }
 
-  void UBLMeshLoad() {
+  void ublMeshLoad() {
     NOLESS(bedlevel.storage_slot, 0);
     settings.load_mesh(bedlevel.storage_slot);
   }
 
 #endif // AUTO_BED_LEVELING_UBL
 
 #if HAS_MESH
 
-  void Draw_MeshSet_Menu() {
-    checkkey = Menu;
-    if (SET_MENU(MeshMenu, MSG_MESH_LEVELING, 14)) {
-      BACK_ITEM(Draw_AdvancedSettings_Menu);
+  void drawMeshSetMenu() {
+    checkkey = ID_Menu;
+    if (SET_MENU(meshMenu, MSG_MESH_LEVELING, 14)) {
+      BACK_ITEM(drawAdvancedSettingsMenu);
       #if ENABLED(PREHEAT_BEFORE_LEVELING)
-        EDIT_ITEM(ICON_Temperature, MSG_UBL_SET_TEMP_BED, onDrawPIntMenu, SetBedLevT, &HMI_data.BedLevT);
+        EDIT_ITEM(ICON_Temperature, MSG_UBL_SET_TEMP_BED, onDrawPIntMenu, setBedLevT, &hmiData.bedLevT);
       #endif
-      EDIT_ITEM(ICON_SetZOffset, MSG_Z_FADE_HEIGHT, onDrawPFloatMenu, SetMeshFadeHeight, &planner.z_fade_height);
-      EDIT_ITEM(ICON_UBLActive, MSG_ACTIVATE_MESH, onDrawChkbMenu, SetMeshActive, &planner.leveling_active);
+      EDIT_ITEM(ICON_SetZOffset, MSG_Z_FADE_HEIGHT, onDrawPFloatMenu, setMeshFadeHeight, &planner.z_fade_height);
+      EDIT_ITEM(ICON_UBLActive, MSG_ACTIVATE_MESH, onDrawChkbMenu, setMeshActive, &planner.leveling_active);
       #if HAS_BED_PROBE
-        MENU_ITEM(ICON_Level, MSG_AUTO_MESH, onDrawMenuItem, AutoLev);
+        MENU_ITEM(ICON_Level, MSG_AUTO_MESH, onDrawMenuItem, autoLevel);
       #endif
       #if ENABLED(AUTO_BED_LEVELING_UBL)
-        EDIT_ITEM(ICON_UBLSlot, MSG_UBL_STORAGE_SLOT, onDrawUBLSlot, SetUBLSlot, &bedlevel.storage_slot);
-        MENU_ITEM(ICON_UBLMeshSave, MSG_UBL_SAVE_MESH, onDrawMenuItem, UBLMeshSave);
-        MENU_ITEM(ICON_UBLMeshLoad, MSG_UBL_LOAD_MESH, onDrawMenuItem, UBLMeshLoad);
-        EDIT_ITEM(ICON_UBLTiltGrid, MSG_UBL_TILTING_GRID, onDrawPInt8Menu, SetUBLTiltGrid, &bedLevelTools.tilt_grid);
-        MENU_ITEM(ICON_UBLTiltGrid, MSG_UBL_TILT_MESH, onDrawMenuItem, UBLMeshTilt);
-        MENU_ITEM(ICON_UBLSmartFill, MSG_UBL_SMART_FILLIN, onDrawMenuItem, UBLSmartFillMesh);
+        EDIT_ITEM(ICON_UBLSlot, MSG_UBL_STORAGE_SLOT, onDrawUBLSlot, setUBLSlot, &bedlevel.storage_slot);
+        MENU_ITEM(ICON_UBLMeshSave, MSG_UBL_SAVE_MESH, onDrawMenuItem, ublMeshSave);
+        MENU_ITEM(ICON_UBLMeshLoad, MSG_UBL_LOAD_MESH, onDrawMenuItem, ublMeshLoad);
+        EDIT_ITEM(ICON_UBLTiltGrid, MSG_UBL_TILTING_GRID, onDrawPInt8Menu, setUBLTiltGrid, &bedLevelTools.tilt_grid);
+        MENU_ITEM(ICON_UBLTiltGrid, MSG_UBL_TILT_MESH, onDrawMenuItem, ublMeshTilt);
+        MENU_ITEM(ICON_UBLSmartFill, MSG_UBL_SMART_FILLIN, onDrawMenuItem, ublSmartFillMesh);
       #endif
       #if ENABLED(MESH_EDIT_MENU)
         MENU_ITEM(ICON_MeshReset, MSG_MESH_RESET, onDrawMenuItem, ResetMesh);
-        MENU_ITEM(ICON_MeshEdit, MSG_EDIT_MESH, onDrawSubMenu, Draw_EditMesh_Menu);
+        MENU_ITEM(ICON_MeshEdit, MSG_EDIT_MESH, onDrawSubMenu, drawEditMeshMenu);
       #endif
-      MENU_ITEM(ICON_MeshViewer, MSG_MESH_VIEW, onDrawSubMenu, DWIN_MeshViewer);
+      MENU_ITEM(ICON_MeshViewer, MSG_MESH_VIEW, onDrawSubMenu, dwinMeshViewer);
     }
-    UpdateMenu(MeshMenu);
+    updateMenu(meshMenu);
   }
 
   #if ENABLED(MESH_EDIT_MENU)
-    void Draw_EditMesh_Menu() {
+    void drawEditMeshMenu() {
       if (!leveling_is_valid()) { LCD_MESSAGE(MSG_UBL_MESH_INVALID); return; }
       set_bed_leveling_enabled(false);
-      checkkey = Menu;
-      if (SET_MENU(EditMeshMenu, MSG_EDIT_MESH, 4)) {
+      checkkey = ID_Menu;
+      if (SET_MENU(editMeshMenu, MSG_EDIT_MESH, 4)) {
         bedLevelTools.mesh_x = bedLevelTools.mesh_y = 0;
-        BACK_ITEM(Draw_MeshSet_Menu);
-        EDIT_ITEM(ICON_MeshEditX, MSG_MESH_X, onDrawPInt8Menu, SetEditMeshX, &bedLevelTools.mesh_x);
-        EDIT_ITEM(ICON_MeshEditY, MSG_MESH_Y, onDrawPInt8Menu, SetEditMeshY, &bedLevelTools.mesh_y);
-        EditZValueItem = EDIT_ITEM(ICON_MeshEditZ, MSG_MESH_EDIT_Z, onDrawPFloat2Menu, SetEditZValue, &bedlevel.z_values[bedLevelTools.mesh_x][bedLevelTools.mesh_y]);
+        BACK_ITEM(drawMeshSetMenu);
+        EDIT_ITEM(ICON_MeshEditX, MSG_MESH_X, onDrawPInt8Menu, setEditMeshX, &bedLevelTools.mesh_x);
+        EDIT_ITEM(ICON_MeshEditY, MSG_MESH_Y, onDrawPInt8Menu, setEditMeshY, &bedLevelTools.mesh_y);
+        editZValueItem = EDIT_ITEM(ICON_MeshEditZ, MSG_MESH_EDIT_Z, onDrawPFloat2Menu, setEditZValue, &bedlevel.z_values[bedLevelTools.mesh_x][bedLevelTools.mesh_y]);
       }
-      UpdateMenu(EditMeshMenu);
+      updateMenu(editMeshMenu);
     }
   #endif
 
 #endif // HAS_MESH
 
 #endif // DWIN_LCD_PROUI

commit 574dd34c49fde76e1e736b8a7e1ea579d724ff22
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jun 27 13:19:36 2023 -0500

    ‚ôªÔ∏è String helper class (#24390)

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 624ea23385..51a53741ef 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -473,44 +473,45 @@ void Popup_window_PauseOrStop() {
 // Draw status line
 //
 void DWIN_DrawStatusLine(const char *text) {
   dwinDrawRectangle(1, HMI_data.StatusBg_Color, 0, STATUS_Y, DWIN_WIDTH, STATUS_Y + 20);
   if (text) DWINUI::Draw_CenteredString(HMI_data.StatusTxt_Color, STATUS_Y + 2, text);
 }
 void DWIN_DrawStatusLine(FSTR_P fstr) { DWIN_DrawStatusLine(FTOP(fstr)); }
 
 // Clear & reset status line
 void DWIN_ResetStatusLine() {
-  ui.status_message[0] = 0;
+  ui.status_message.clear();
   DWIN_CheckStatusMessage();
 }
 
 // Djb2 hash algorithm
 uint32_t GetHash(char * str) {
   uint32_t hash = 5381;
   char c;
   while ((c = *str++)) hash = ((hash << 5) + hash) + c; /* hash * 33 + c */
   return hash;
 }
 
+// Check for a change in the status message
 void DWIN_CheckStatusMessage() {
-  static uint32_t old_hash = 0;
-  uint32_t hash = GetHash(&ui.status_message[0]);
+  static MString<>::hash_t old_hash = 0x0000;
+  const MString<>::hash_t hash = ui.status_message.hash();
   hash_changed = hash != old_hash;
   old_hash = hash;
-};
+}
 
 void DWIN_DrawStatusMessage() {
   #if ENABLED(STATUS_MESSAGE_SCROLLING)
 
     // Get the UTF8 character count of the string
-    uint8_t slen = utf8_strlen(ui.status_message);
+    uint8_t slen = ui.status_message.glyphs();
 
     // If the string fits the status line do not scroll it
     if (slen <= LCD_WIDTH) {
       if (hash_changed) {
         DWIN_DrawStatusLine(ui.status_message);
         hash_changed = false;
       }
     }
     else {
       // String is larger than the available line space
@@ -532,21 +533,21 @@ void DWIN_DrawStatusMessage() {
           if (--chars)
             DWINUI::Draw_String(HMI_data.StatusTxt_Color, ui.status_message, chars); // Print a second copy of the message
         }
       }
       MarlinUI::advance_status_scroll();
     }
 
   #else
 
     if (hash_changed) {
-      ui.status_message[LCD_WIDTH] = 0;
+      ui.status_message.trunc(LCD_WIDTH);
       DWIN_DrawStatusLine(ui.status_message);
       hash_changed = false;
     }
 
   #endif
 }
 
 void Draw_Print_Labels() {
   if (HMI_IsChinese()) {
     DWIN_Frame_AreaCopy(1,  0, 72,  63, 86,  41, 173);  // Printing Time
@@ -560,31 +561,30 @@ void Draw_Print_Labels() {
 
 void Draw_Print_ProgressBar() {
   const uint8_t _percent_done = ui.get_progress_percent();
   DWINUI::Draw_IconWB(ICON_Bar, 15, 93);
   dwinDrawRectangle(1, HMI_data.Barfill_Color, 16 + _percent_done * 240 / 100, 93, 256, 113);
   DWINUI::Draw_Int(HMI_data.PercentTxt_Color, HMI_data.Background_Color, 3, 117, 133, _percent_done);
   DWINUI::Draw_String(HMI_data.PercentTxt_Color, 142, 133, F("%"));
 }
 
 void Draw_Print_ProgressElapsed() {
-  char buf[10];
+  MString<12> buf;
   duration_t elapsed = print_job_timer.duration(); // Print timer
-  sprintf_P(buf, PSTR("%02i:%02i "), (uint16_t)(elapsed.value / 3600), ((uint16_t)elapsed.value % 3600) / 60);
+  buf.setf(F("%02i:%02i "), uint16_t(elapsed.value / 3600), (uint16_t(elapsed.value) % 3600) / 60);
   DWINUI::Draw_String(HMI_data.Text_Color, HMI_data.Background_Color, 47, 192, buf);
 }
 
 #if ENABLED(SHOW_REMAINING_TIME)
   void Draw_Print_ProgressRemain() {
-    const uint32_t _remain_time = ui.get_remaining_time();
-    char buf[10];
-    sprintf_P(buf, PSTR("%02i:%02i "), (uint16_t)(_remain_time / 3600), ((uint16_t)_remain_time % 3600) / 60);
+    MString<12> buf;
+    buf.setf(F("%02i:%02i "), _remain_time / 3600, (_remain_time % 3600) / 60);
     DWINUI::Draw_String(HMI_data.Text_Color, HMI_data.Background_Color, 181, 192, buf);
   }
 #endif
 
 void ICON_ResumeOrPause() {
   if (checkkey == PrintProcess) (print_job_timer.isPaused() || hmiFlag.pause_flag) ? ICON_Resume() : ICON_Pause();
 }
 
 // Update filename on print
 void DWIN_Print_Header(const char *text = nullptr) {
@@ -1490,22 +1490,23 @@ void DWIN_LevelingStart() {
     Draw_ManualMesh_Menu();
   #endif
 }
 
 void DWIN_LevelingDone() {
   TERN_(HAS_MESH, Goto_MeshViewer(true));
 }
 
 #if HAS_MESH
   void DWIN_MeshUpdate(const int8_t cpos, const int8_t tpos, const_float_t zval) {
-    char str_1[6] = "";
-    ui.status_printf(0, F(S_FMT " %i/%i Z=%s"), GET_TEXT_F(MSG_PROBING_POINT), cpos, tpos, dtostrf(zval, 1, 2, str_1));
+    ui.set_status(
+      &MString<32>(GET_TEXT_F(MSG_PROBING_POINT), ' ', cpos, '/', tpos, F(" Z="), p_float_t(zval, 2))
+    );
   }
 #endif
 
 // PID/MPC process
 
 #if SHOW_TUNING_GRAPH
 
   #include "plot.h"
 
   celsius_t _maxtemp, _target;
@@ -2044,44 +2045,39 @@ void AutoHome() { queue.inject_P(G28_STR); }
       if (BABYSTEP_ALLOWED()) babystep.add_steps(Z_AXIS, step_zoffset);
     #endif
   }
   void SetZOffset() {
     #if ANY(BABYSTEP_ZPROBE_OFFSET, JUST_BABYSTEP)
       babystep.accum = round(planner.settings.axis_steps_per_mm[Z_AXIS] * BABY_Z_VAR);
     #endif
     SetPFloatOnClick(Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX, 2, ApplyZOffset, LiveZOffset);
   }
 
-#endif // HAS_ZOFFSET_ITEM
+  void SetMoveZto0() {
+    #if ENABLED(Z_SAFE_HOMING)
+      gcode.process_subcommands_now(MString<54>(F("G28XYO\nG28Z\nG0F5000X"), Z_SAFE_HOMING_X_POINT, F("Y"), Z_SAFE_HOMING_Y_POINT, F("\nG0Z0F300\nM400")));
+    #else
+      TERN_(HAS_LEVELING, set_bed_leveling_enabled(false));
+      gcode.process_subcommands_now(F("G28Z\nG0Z0F300\nM400"));
+    #endif
+    ui.reset_status();
+    DONE_BUZZ(true);
+  }
 
-void SetMoveZto0() {
-  #if ENABLED(Z_SAFE_HOMING)
-    char cmd[54], str_1[5], str_2[5];
-    sprintf_P(cmd, PSTR("G28XYO\nG28Z\nG0X%sY%sF5000\nG0Z0F300\nM400"),
-      dtostrf(Z_SAFE_HOMING_X_POINT, 1, 1, str_1),
-      dtostrf(Z_SAFE_HOMING_Y_POINT, 1, 1, str_2)
-    );
-    gcode.process_subcommands_now(cmd);
-  #else
-    TERN_(HAS_LEVELING, set_bed_leveling_enabled(false));
-    gcode.process_subcommands_now(F("G28Z\nG0Z0F300\nM400"));
+  #if !HAS_BED_PROBE
+    void HomeZandDisable() {
+      SetMoveZto0();
+      DisableMotors();
+    }
   #endif
-  ui.reset_status();
-  DONE_BUZZ(true);
-}
 
-#if DISABLED(HAS_BED_PROBE)
-  void HomeZandDisable() {
-    SetMoveZto0();
-    DisableMotors();
-  }
-#endif
+#endif // HAS_ZOFFSET_ITEM
 
 #if HAS_PREHEAT
   #define _DoPreheat(N) void DoPreheat##N() { ui.preheat_all(N-1); }\
                         void DoPreheatHotend##N() { ui.preheat_hotend(N-1); }
   REPEAT_1(PREHEAT_COUNT, _DoPreheat)
 #endif
 
 void DoCoolDown() { thermalManager.cooldown(); }
 
 void SetLanguage() {
@@ -2315,34 +2311,30 @@ void SetFlow() { SetPIntOnClick(MIN_PRINT_FLOW, MAX_PRINT_FLOW, []{ planner.refr
           LCD_MESSAGE(MSG_TRAM_C);
           x = X_CENTER; y = Y_CENTER;
           break;
       #endif
     }
   }
 
   #if HAS_BED_PROBE
 
     float Tram(const uint8_t point) {
-      char cmd[100] = "";
       static bool inLev = false;
-      float xpos = 0, ypos = 0, zval = 0;
-      char str_1[6] = "", str_2[6] = "", str_3[6] = "";
       if (inLev) return NAN;
 
+      float xpos = 0, ypos = 0, zval = 0;
       TramXY(point, xpos, ypos);
 
       if (HMI_data.FullManualTramming) {
-        sprintf_P(cmd, PSTR("M420S0\nG28O\nG90\nG0Z5F300\nG0X%sY%sF5000\nG0Z0F300"),
-          dtostrf(xpos, 1, 1, str_1),
-          dtostrf(ypos, 1, 1, str_2)
-        );
-        queue.inject(cmd);
+        queue.inject(MString<100>(
+          F("M420S0\nG28O\nG90\nG0F300Z5\nG0F5000X"), p_float_t(xpos, 1), 'Y', p_float_t(ypos, 1), F("\nG0F300Z0")
+        ));
       }
       else {
         // AUTO_BED_LEVELING_BILINEAR does not define MESH_INSET
         #ifndef MESH_MIN_X
           #define MESH_MIN_X (_MAX(X_MIN_BED + PROBING_MARGIN, X_MIN_POS))
         #endif
         #ifndef MESH_MIN_Y
           #define MESH_MIN_Y (_MAX(Y_MIN_BED + PROBING_MARGIN, Y_MIN_POS))
         #endif
         #ifndef MESH_MAX_X
@@ -2353,42 +2345,35 @@ void SetFlow() { SetPIntOnClick(MIN_PRINT_FLOW, MAX_PRINT_FLOW, []{ planner.refr
         #endif
 
         LIMIT(xpos, MESH_MIN_X, MESH_MAX_X);
         LIMIT(ypos, MESH_MIN_Y, MESH_MAX_Y);
         probe.stow();
         gcode.process_subcommands_now(F("M420S0\nG28O"));
         inLev = true;
         zval = probe.probe_at_point(xpos, ypos, PROBE_PT_STOW);
         if (isnan(zval))
           LCD_MESSAGE(MSG_ZPROBE_OUT);
-        else {
-          sprintf_P(cmd, PSTR("X:%s, Y:%s, Z:%s"),
-            dtostrf(xpos, 1, 1, str_1),
-            dtostrf(ypos, 1, 1, str_2),
-            dtostrf(zval, 1, 2, str_3)
-          );
-          ui.set_status(cmd);
-        }
+        else
+          ui.set_status(TS(F("X:"), p_float_t(xpos, 1), F(" Y:"), p_float_t(ypos, 1), F(" Z:")));
         inLev = false;
       }
       return zval;
     }
 
   #else
 
     void Tram(const uint8_t point) {
       float xpos = 0, ypos = 0;
       TramXY(point, xpos, ypos);
-
-      char cmd[100] = "", str_1[6] = "", str_2[6] = "";
-      sprintf_P(cmd, PSTR("M420S0\nG28O\nG90\nG0Z5F300\nG0X%sY%sF5000\nG0Z0F300"), dtostrf(xpos, 1, 1, str_1), dtostrf(ypos, 1, 1, str_2));
-      queue.inject(cmd);
+      queue.inject(MString<100>(
+        F("M420S0\nG28O\nG90\nG0F300Z5\nG0F5000X"), p_float_t(xpos, 1), 'Y', p_float_t(ypos, 1), F("\nG0F300Z0")
+      ));
     }
 
   #endif
 
   inline void TramFL() { Tram(0); }
   inline void TramFR() { Tram(1); }
   inline void TramBR() { Tram(2); }
   inline void TramBL() { Tram(3); }
   #if ENABLED(BED_TRAMMING_INCLUDE_CENTER)
     inline void TramC() { Tram(4); }
@@ -3755,27 +3740,23 @@ void Draw_Steps_Menu() {
         #endif
       #endif
     }
     UpdateMenu(HotendMPCMenu);
   }
 
 #endif // MPC_EDIT_MENU || MPC_AUTOTUNE_MENU
 
 #if DWIN_PID_TUNE
   void SetPID(celsius_t t, heater_id_t h) {
-    char cmd[53] = "";
-    char str_1[5] = "", str_2[5] = "";
-    sprintf_P(cmd, PSTR("G28OXY\nG0Z5F300\nG0X%sY%sF5000\nM84\nM400"),
-      dtostrf(X_CENTER, 1, 1, str_1),
-      dtostrf(Y_CENTER, 1, 1, str_2)
+    gcode.process_subcommands_now(
+      MString<60>(F("G28OXY\nG0Z5F300\nG0X"), X_CENTER, F("Y"), Y_CENTER, F("F5000\nM84\nM400"))
     );
-    gcode.process_subcommands_now(cmd);
     thermalManager.PID_autotune(t, h, HMI_data.PidCycles, true);
   }
   void SetPidCycles() { SetPIntOnClick(3, 50); }
 #endif
 
 #if ALL(HAS_PID_HEATING, PID_EDIT_MENU)
 
   void SetKp() { SetPFloatOnClick(0, 1000, 2); }
   void ApplyPIDi() {
     *MenuData.P_Float = scalePID_i(MenuData.Value / POW(10, 2));
@@ -3961,25 +3942,22 @@ void Draw_Steps_Menu() {
   void onDrawUBLSlot(MenuItemClass* menuitem, int8_t line) {
     NOLESS(bedlevel.storage_slot, 0);
     onDrawIntMenu(menuitem, line, bedlevel.storage_slot);
   }
 
   void ApplyUBLTiltGrid() { bedLevelTools.tilt_grid = MenuData.Value; }
   void SetUBLTiltGrid() { SetIntOnClick(1, 3, bedLevelTools.tilt_grid, ApplyUBLTiltGrid); }
 
   void UBLMeshTilt() {
     NOLESS(bedlevel.storage_slot, 0);
-    char buf[9];
-    if (bedLevelTools.tilt_grid > 1) {
-      sprintf_P(buf, PSTR("G29J%i"), bedLevelTools.tilt_grid);
-      gcode.process_subcommands_now(buf);
-    }
+    if (bedLevelTools.tilt_grid > 1)
+      gcode.process_subcommands_now(TS(F("G29J"), bedLevelTools.tilt_grid));
     else
       gcode.process_subcommands_now(F("G29J"));
     LCD_MESSAGE(MSG_UBL_MESH_TILTED);
   }
 
   void UBLSmartFillMesh() {
     for (uint8_t x = 0; x < GRID_MAX_POINTS_Y; ++x) bedlevel.smart_fill_mesh();
     LCD_MESSAGE(MSG_UBL_MESH_FILLED);
   }
 

commit 858916d628526b5d56c34c5c9663e3535bfc7788
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Fri Jun 23 04:57:22 2023 -0500

    üö∏ Update DWIN ProUI (#26003)

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 83105f2109..624ea23385 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -16,46 +16,49 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 /**
  * DWIN Enhanced implementation for PRO UI
  * Author: Miguel A. Risco-Castillo (MRISCOC)
- * Version: 3.21.2
- * Date: 2022/12/02
+ * Version: 3.25.3
+ * Date: 2023/05/18
  */
 
 #include "../../../inc/MarlinConfig.h"
 
 #if ENABLED(DWIN_LCD_PROUI)
 
 #include "../../utf8.h"
 #include "../../marlinui.h"
-
-#include "../../../sd/cardreader.h"
-
 #include "../../../MarlinCore.h"
 #include "../../../core/serial.h"
 #include "../../../core/macros.h"
-
 #include "../../../module/temperature.h"
 #include "../../../module/printcounter.h"
 #include "../../../module/motion.h"
-#include "../../../module/stepper.h"
 #include "../../../module/planner.h"
-
+#include "../../../module/stepper.h"
 #include "../../../gcode/gcode.h"
 #include "../../../gcode/queue.h"
 
+#if HAS_MEDIA
+  #include "../../../sd/cardreader.h"
+#endif
+
+#if NEED_HEX_PRINT
+  #include "../../../libs/hex_print.h"
+#endif
+
 #if HAS_FILAMENT_SENSOR
   #include "../../../feature/runout.h"
 #endif
 
 #if ENABLED(EEPROM_SETTINGS)
   #include "../../../module/settings.h"
 #endif
 
 #if ENABLED(HOST_ACTION_COMMANDS)
   #include "../../../feature/host_actions.h"
@@ -91,22 +94,25 @@
 #endif
 
 #if ENABLED(CASE_LIGHT_MENU)
   #include "../../../feature/caselight.h"
 #endif
 
 #if ENABLED(LED_CONTROL_MENU)
   #include "../../../feature/leds/leds.h"
 #endif
 
+#if HAS_TRINAMIC_CONFIG
+  #include "../../../feature/tmc_util.h"
+#endif
+
 #include "dwin.h"
-#include "dwinui.h"
 #include "menus.h"
 #include "dwin_popup.h"
 
 #if HAS_GCODE_PREVIEW
   #include "gcode_preview.h"
 #endif
 
 #if HAS_ESDIAG
   #include "endstop_diag.h"
 #endif
@@ -136,29 +142,37 @@
 #define MIN_PRINT_SPEED  10
 #define MAX_PRINT_SPEED 999
 
 // Print flow limit
 #define MIN_PRINT_FLOW   10
 #define MAX_PRINT_FLOW   299
 
 // Load and Unload limits
 #define MAX_LOAD_UNLOAD  500
 
+// Juntion deviation limits
+#define MIN_JD_MM             0.001
+#define MAX_JD_MM             TERN(LIN_ADVANCE, 0.3f, 0.5f)
+
+#if HAS_TRINAMIC_CONFIG
+  #define MIN_TMC_CURRENT 100
+  #define MAX_TMC_CURRENT 3000
+#endif
+
 // Editable temperature limits
 #define MIN_ETEMP  0
 #define MAX_ETEMP  (thermalManager.hotend_maxtemp[0] - (HOTEND_OVERSHOOT))
 #define MIN_BEDTEMP 0
 #define MAX_BEDTEMP BED_MAX_TARGET
 
 #define DWIN_VAR_UPDATE_INTERVAL         1024
 #define DWIN_UPDATE_INTERVAL             1024
-#define DWIN_REMAIN_TIME_UPDATE_INTERVAL SEC_TO_MS(20)
 
 #if HAS_MESH && HAS_BED_PROBE
   #define BABY_Z_VAR probe.offset.z
 #else
   float z_offset = 0;
   #define BABY_Z_VAR z_offset
 #endif
 
 // Structs
 HMI_value_t HMI_value;
@@ -181,72 +195,70 @@ enum SelectItem : uint8_t {
 typedef struct {
   uint8_t now, last;
   void set(uint8_t v) { now = last = v; }
   void reset() { set(0); }
   bool changed() { bool c = (now != last); if (c) last = now; return c; }
   bool dec() { if (now) now--; return changed(); }
   bool inc(uint8_t v) { if (now < (v - 1)) now++; else now = (v - 1); return changed(); }
 } select_t;
 select_t select_page{0}, select_print{0};
 
-#if HAS_HOTEND
-  float last_E = 0;
-  #define E_MIN_POS (last_E - (EXTRUDE_MAXLENGTH))
-  #define E_MAX_POS (last_E + (EXTRUDE_MAXLENGTH))
+#if ENABLED(LCD_BED_TRAMMING)
+  constexpr float bed_tramming_inset_lfbr[] = BED_TRAMMING_INSET_LFRB;
 #endif
 
 bool hash_changed = true; // Flag to know if message status was changed
-uint8_t _percent_done = 0;
-uint32_t _remain_time = 0;
 bool blink = false;
-millis_t dwin_heat_time = 0;
 uint8_t checkkey = 255, last_checkkey = MainMenu;
 
 // New menu system pointers
 MenuClass *FileMenu = nullptr;
 MenuClass *PrepareMenu = nullptr;
-MenuClass *TrammingMenu = nullptr;
+#if ENABLED(LCD_BED_TRAMMING)
+  MenuClass *TrammingMenu = nullptr;
+#endif
 MenuClass *MoveMenu = nullptr;
 MenuClass *ControlMenu = nullptr;
 MenuClass *AdvancedSettings = nullptr;
 #if HAS_HOME_OFFSET
   MenuClass *HomeOffMenu = nullptr;
 #endif
 #if HAS_BED_PROBE
   MenuClass *ProbeSetMenu = nullptr;
 #endif
 MenuClass *FilSetMenu = nullptr;
 MenuClass *SelectColorMenu = nullptr;
 MenuClass *GetColorMenu = nullptr;
 MenuClass *TuneMenu = nullptr;
 MenuClass *MotionMenu = nullptr;
 MenuClass *FilamentMenu = nullptr;
 #if ENABLED(MESH_BED_LEVELING)
   MenuClass *ManualMesh = nullptr;
 #endif
-#if HAS_HOTEND
+#if HAS_PREHEAT
   MenuClass *PreheatMenu = nullptr;
+  MenuClass *PreheatHotendMenu = nullptr;
 #endif
 MenuClass *TemperatureMenu = nullptr;
 MenuClass *MaxSpeedMenu = nullptr;
 MenuClass *MaxAccelMenu = nullptr;
 #if HAS_CLASSIC_JERK
   MenuClass *MaxJerkMenu = nullptr;
 #endif
 MenuClass *StepsMenu = nullptr;
 #if ANY(MPC_EDIT_MENU, MPC_AUTOTUNE_MENU)
   MenuClass *HotendMPCMenu = nullptr;
 #endif
-#if ENABLED(PIDTEMP)
+#if ENABLED(PIDTEMP) && ANY(PID_EDIT_MENU, PID_AUTOTUNE_MENU)
   MenuClass *HotendPIDMenu = nullptr;
 #endif
-#if ENABLED(PIDTEMPBED)
+#if ENABLED(PIDTEMPBED) && ANY(PID_EDIT_MENU, PID_AUTOTUNE_MENU)
   MenuClass *BedPIDMenu = nullptr;
 #endif
 #if ENABLED(CASELIGHT_USES_BRIGHTNESS)
   MenuClass *CaseLightMenu = nullptr;
 #endif
 #if ENABLED(LED_CONTROL_MENU)
   MenuClass *LedControlMenu = nullptr;
 #endif
 #if HAS_BED_PROBE
   MenuClass *ZOffsetWizMenu = nullptr;
@@ -256,20 +268,26 @@ MenuClass *StepsMenu = nullptr;
 #endif
 #if ENABLED(FWRETRACT)
   MenuClass *FWRetractMenu = nullptr;
 #endif
 #if HAS_MESH
   MenuClass *MeshMenu = nullptr;
   #if ENABLED(MESH_EDIT_MENU)
     MenuClass *EditMeshMenu = nullptr;
   #endif
 #endif
+#if ENABLED(SHAPING_MENU)
+  MenuClass *InputShapingMenu = nullptr;
+#endif
+#if HAS_TRINAMIC_CONFIG
+  MenuClass *TrinamicConfigMenu = nullptr;
+#endif
 
 // Updatable menuitems pointers
 MenuItemClass *HotendTargetItem = nullptr;
 MenuItemClass *BedTargetItem = nullptr;
 MenuItemClass *FanSpeedItem = nullptr;
 MenuItemClass *MMeshMoveZItem = nullptr;
 MenuItemClass *EditZValueItem = nullptr;
 
 bool Printing() { return printingIsActive() || printingIsPaused(); }
 bool SD_Printing() { return Printing() && IS_SD_FILE_OPEN(); }
@@ -534,41 +552,45 @@ void Draw_Print_Labels() {
     DWIN_Frame_AreaCopy(1,  0, 72,  63, 86,  41, 173);  // Printing Time
     DWIN_Frame_AreaCopy(1, 65, 72, 128, 86, 176, 173);  // Remain
   }
   else {
     DWINUI::Draw_String( 46, 173, GET_TEXT_F(MSG_INFO_PRINT_TIME));
     DWINUI::Draw_String(181, 173, GET_TEXT_F(MSG_REMAINING_TIME));
   }
 }
 
 void Draw_Print_ProgressBar() {
+  const uint8_t _percent_done = ui.get_progress_percent();
   DWINUI::Draw_IconWB(ICON_Bar, 15, 93);
   dwinDrawRectangle(1, HMI_data.Barfill_Color, 16 + _percent_done * 240 / 100, 93, 256, 113);
   DWINUI::Draw_Int(HMI_data.PercentTxt_Color, HMI_data.Background_Color, 3, 117, 133, _percent_done);
   DWINUI::Draw_String(HMI_data.PercentTxt_Color, 142, 133, F("%"));
 }
 
 void Draw_Print_ProgressElapsed() {
   char buf[10];
-  duration_t elapsed = print_job_timer.duration(); // print timer
+  duration_t elapsed = print_job_timer.duration(); // Print timer
   sprintf_P(buf, PSTR("%02i:%02i "), (uint16_t)(elapsed.value / 3600), ((uint16_t)elapsed.value % 3600) / 60);
   DWINUI::Draw_String(HMI_data.Text_Color, HMI_data.Background_Color, 47, 192, buf);
 }
 
-void Draw_Print_ProgressRemain() {
-  char buf[10];
-  sprintf_P(buf, PSTR("%02i:%02i "), (uint16_t)(_remain_time / 3600), ((uint16_t)_remain_time % 3600) / 60);
-  DWINUI::Draw_String(HMI_data.Text_Color, HMI_data.Background_Color, 181, 192, buf);
-}
+#if ENABLED(SHOW_REMAINING_TIME)
+  void Draw_Print_ProgressRemain() {
+    const uint32_t _remain_time = ui.get_remaining_time();
+    char buf[10];
+    sprintf_P(buf, PSTR("%02i:%02i "), (uint16_t)(_remain_time / 3600), ((uint16_t)_remain_time % 3600) / 60);
+    DWINUI::Draw_String(HMI_data.Text_Color, HMI_data.Background_Color, 181, 192, buf);
+  }
+#endif
 
 void ICON_ResumeOrPause() {
-  if (checkkey == PrintProcess) printingIsPaused() ? ICON_Resume() : ICON_Pause();
+  if (checkkey == PrintProcess) (print_job_timer.isPaused() || hmiFlag.pause_flag) ? ICON_Resume() : ICON_Pause();
 }
 
 // Update filename on print
 void DWIN_Print_Header(const char *text = nullptr) {
   static char headertxt[31] = "";  // Print header text
   if (text) {
     const int8_t size = _MIN(30U, strlen_P(text));
     for (uint8_t i = 0; i < size; ++i) headertxt[i] = text[i];
     headertxt[size] = '\0';
   }
@@ -577,69 +599,66 @@ void DWIN_Print_Header(const char *text = nullptr) {
     DWINUI::Draw_CenteredString(60, headertxt);
   }
 }
 
 void Draw_PrintProcess() {
   if (HMI_IsChinese())
     Title.FrameCopy(30, 1, 42, 14);                     // "Printing"
   else
     Title.ShowCaption(GET_TEXT_F(MSG_PRINTING));
   DWINUI::ClearMainArea();
-  DWIN_Print_Header(SD_Printing() ? card.longest_filename() : nullptr);
+  DWIN_Print_Header(nullptr);
   Draw_Print_Labels();
   DWINUI::Draw_Icon(ICON_PrintTime, 15, 173);
   DWINUI::Draw_Icon(ICON_RemainTime, 150, 171);
   Draw_Print_ProgressBar();
   Draw_Print_ProgressElapsed();
-  Draw_Print_ProgressRemain();
+  TERN_(SHOW_REMAINING_TIME, Draw_Print_ProgressRemain());
   ICON_Tune();
   ICON_ResumeOrPause();
   ICON_Stop();
 }
 
 void Goto_PrintProcess() {
   if (checkkey == PrintProcess)
     ICON_ResumeOrPause();
   else {
     checkkey = PrintProcess;
     Draw_PrintProcess();
     TERN_(DASH_REDRAW, DWIN_RedrawDash());
   }
   dwinUpdateLCD();
 }
 
 void Draw_PrintDone() {
-  // show percent bar and value
-  _percent_done = 100;
-  _remain_time = 0;
-
+  TERN_(SET_PROGRESS_PERCENT, ui.set_progress_done());
+  TERN_(SET_REMAINING_TIME, ui.reset_remaining_time());
   Title.ShowCaption(GET_TEXT_F(MSG_PRINT_DONE));
   DWINUI::ClearMainArea();
   DWIN_Print_Header(nullptr);
-
   #if HAS_GCODE_PREVIEW
-    const bool isvalid = Preview_Valid();
-    if (isvalid) {
-      dwinIconShow(0, 0, 1, 21, 100, 0x00);
-      DWINUI::Draw_Button(BTN_Continue, 86, 300);
+    const bool haspreview = Preview_Valid();
+    if (haspreview) {
+      Preview_Show();
+      DWINUI::Draw_Button(BTN_Continue, 86, 295);
     }
   #else
-    constexpr bool isvalid = false;
+    constexpr bool haspreview = false;
   #endif
 
-  if (!isvalid) {
+  if (!haspreview) {
     Draw_Print_ProgressBar();
     Draw_Print_Labels();
     DWINUI::Draw_Icon(ICON_PrintTime, 15, 173);
     DWINUI::Draw_Icon(ICON_RemainTime, 150, 171);
     Draw_Print_ProgressElapsed();
-    Draw_Print_ProgressRemain();
+    TERN_(SHOW_REMAINING_TIME, Draw_Print_ProgressRemain());
     DWINUI::Draw_Button(BTN_Continue, 86, 273);
   }
 }
 
 void Goto_PrintDone() {
   wait_for_user = true;
   if (checkkey != PrintDone) {
     checkkey = PrintDone;
     Draw_PrintDone();
     dwinUpdateLCD();
@@ -667,70 +686,101 @@ void Goto_Main_Menu() {
 }
 
 // Draw X, Y, Z and blink if in an un-homed or un-trusted state
 void _update_axis_value(const AxisEnum axis, const uint16_t x, const uint16_t y, const bool force) {
   const bool draw_qmark = axis_should_home(axis),
              draw_empty = NONE(HOME_AFTER_DEACTIVATE, DISABLE_REDUCED_ACCURACY_WARNING) && !draw_qmark && !axis_is_trusted(axis);
 
   // Check for a position change
   static xyz_pos_t oldpos = { -1, -1, -1 };
 
-  const float p = TERN(SHOW_REAL_POS, stepper.position(axis) / planner.settings.axis_steps_per_mm[axis], current_position[axis]);
+  const float p = (
+    #if ALL(IS_FULL_CARTESIAN, SHOW_REAL_POS)
+      planner.get_axis_position_mm(axis)
+    #else
+      current_position[axis]
+    #endif
+  );
 
   const bool changed = oldpos[axis] != p;
   if (changed) oldpos[axis] = p;
 
   if (force || changed || draw_qmark || draw_empty) {
     if (blink && draw_qmark)
       DWINUI::Draw_String(HMI_data.Coordinate_Color, HMI_data.Background_Color, x, y, F("  - ? -"));
     else if (blink && draw_empty)
       DWINUI::Draw_String(HMI_data.Coordinate_Color, HMI_data.Background_Color, x, y, F("       "));
     else
       DWINUI::Draw_Signed_Float(HMI_data.Coordinate_Color, HMI_data.Background_Color, 3, 2, x, y, p);
   }
 }
 
+void _draw_iconblink(bool &flag, const bool sensor, const uint8_t icon1, const uint8_t icon2, const uint16_t x, const uint16_t y) {
+  #if DISABLED(NO_BLINK_IND)
+    if (flag != sensor) {
+      flag = sensor;
+      if (!flag) {
+        dwinDrawBox(1, HMI_data.Background_Color, x, y, 20, 20);
+        DWINUI::Draw_Icon(icon1, x, y);
+      }
+    }
+    if (flag) {
+      dwinDrawBox(1, blink ? HMI_data.SplitLine_Color : HMI_data.Background_Color, x, y, 20, 20);
+      DWINUI::Draw_Icon(icon2, x, y);
+    }
+  #else
+    if (flag != sensor) {
+      flag = sensor;
+      dwinDrawBox(1, HMI_data.Background_Color, x, y, 20, 20);
+      DWINUI::Draw_Icon(flag ? icon2 : icon1, x, y);
+    }
+  #endif
+}
+
 void _draw_ZOffsetIcon() {
   #if HAS_LEVELING
-    #if NO_BLINK_LEV_IND
-      static bool _leveling_active = false;
-      if (_leveling_active != planner.leveling_active) {
-        _leveling_active = planner.leveling_active;
-        dwinDrawRectangle(1, HMI_data.Background_Color, 186, 415, 205, 436);
-        DWINUI::Draw_Icon(_leveling_active ? ICON_SetZOffset : ICON_Zoffset, 187, 416);
-      }
-    #else
-      if (planner.leveling_active) {
-        dwinDrawRectangle(1, blink ? HMI_data.SplitLine_Color : HMI_data.Background_Color, 186, 415, 205, 436);
-        DWINUI::Draw_Icon(ICON_SetZOffset, 186, 416);
-      }
-      static bool _leveling_active = false;
-      if (_leveling_active != planner.leveling_active) {
-        _leveling_active = planner.leveling_active;
-        if (!_leveling_active) {
-          dwinDrawRectangle(1, HMI_data.Background_Color, 186, 415, 205, 436);
-          DWINUI::Draw_Icon(ICON_Zoffset, 187, 416);
-        }
-      }
-    #endif
+    static bool _leveling_active = false;
+    _draw_iconblink(_leveling_active, planner.leveling_active, ICON_Zoffset, ICON_SetZOffset, 186, 416);
   #else
     DWINUI::Draw_Icon(ICON_Zoffset, 187, 416);
   #endif
 }
 
+void _draw_feedrate() {
+  #if ENABLED(SHOW_SPEED_IND)
+    int16_t _value;
+    if (blink) {
+      _value = feedrate_percentage;
+      DWINUI::Draw_String(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 116 + 4 * STAT_CHR_W + 2, 384, F(" %"));
+    }
+    else {
+      _value = CEIL(feedrate_mm_s * feedrate_percentage / 100);
+      dwinDrawBox(1, HMI_data.Background_Color, 116 + 5 * STAT_CHR_W + 2, 384, 20, 20);
+    }
+    DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 116 + 2 * STAT_CHR_W, 384, _value);
+  #else
+    static int16_t _feedrate = 100;
+    if (_feedrate != feedrate_percentage) {
+      _feedrate = feedrate_percentage;
+      DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 116 + 2 * STAT_CHR_W, 384, _feedrate);
+    }
+  #endif
+}
+
 void _draw_xyz_position(const bool force) {
   _update_axis_value(X_AXIS,  27, 459, force);
   _update_axis_value(Y_AXIS, 112, 459, force);
   _update_axis_value(Z_AXIS, 197, 459, force);
 }
 
 void update_variable() {
+  _draw_xyz_position(false);
   #if HAS_HOTEND
     static celsius_t _hotendtemp = 0, _hotendtarget = 0;
     const celsius_t hc = thermalManager.wholeDegHotend(0),
                     ht = thermalManager.degTargetHotend(0);
     const bool _new_hotend_temp = _hotendtemp != hc,
                _new_hotend_target = _hotendtarget != ht;
     if (_new_hotend_temp) _hotendtemp = hc;
     if (_new_hotend_target) _hotendtarget = ht;
   #endif
   #if HAS_HEATED_BED
@@ -770,86 +820,79 @@ void update_variable() {
     }
   #endif
 
   #if HAS_HEATED_BED
     if (_new_bed_temp)
       DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 28, 417, _bedtemp);
     if (_new_bed_target)
       DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 25 + 4 * STAT_CHR_W + 6, 417, _bedtarget);
   #endif
 
-  static int16_t _feedrate = 100;
-  if (_feedrate != feedrate_percentage) {
-    _feedrate = feedrate_percentage;
-    DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 116 + 2 * STAT_CHR_W, 384, _feedrate);
-  }
+  _draw_feedrate();
 
   #if HAS_FAN
-    if (_new_fanspeed) {
-      _fanspeed = thermalManager.fan_speed[0];
+    if (_new_fanspeed)
       DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 195 + 2 * STAT_CHR_W, 384, _fanspeed);
-    }
   #endif
 
   static float _offset = 0;
   if (BABY_Z_VAR != _offset) {
     _offset = BABY_Z_VAR;
     DWINUI::Draw_Signed_Float(DWIN_FONT_STAT, HMI_data.Indicator_Color,  HMI_data.Background_Color, 2, 2, 204, 417, _offset);
   }
 
   _draw_ZOffsetIcon();
-  _draw_xyz_position(false);
 }
 
 /**
  * Memory card and file management
  */
 
 bool DWIN_lcd_sd_status = false;
 
-void SetMediaAutoMount() {
-  Toggle_Chkb_Line(HMI_data.MediaAutoMount);
-}
+#if ENABLED(MEDIASORT_MENU_ITEM)
+  void SetMediaSort() {
+    Toggle_Chkb_Line(HMI_data.MediaSort);
+    card.setSortOn(HMI_data.MediaSort);
+  }
+#endif
+
+void SetMediaAutoMount() { Toggle_Chkb_Line(HMI_data.MediaAutoMount); }
 
 inline uint16_t nr_sd_menu_items() {
   return _MIN(card.get_num_items() + !card.flag.workDirIsRoot, MENU_MAX_ITEMS);
 }
 
 void make_name_without_ext(char *dst, char *src, size_t maxlen=MENU_CHAR_LIMIT) {
-  size_t pos = strlen(src);  // index of ending nul
+  size_t pos = strlen(src);  // Index of ending nul
 
   // For files, remove the extension
   // which may be .gcode, .gco, or .g
   if (!card.flag.filenameIsDir)
-    while (pos && src[pos] != '.') pos--; // find last '.' (stop at 0)
+    while (pos && src[pos] != '.') pos--; // Find last '.' (stop at 0)
 
   if (!pos) pos = strlen(src);  // pos = 0 ('.' not found) restore pos
 
   size_t len = pos;   // nul or '.'
   if (len > maxlen) { // Keep the name short
-    pos        = len = maxlen; // move nul down
-    dst[--pos] = '.'; // insert dots
+    pos        = len = maxlen; // Move nul down
+    dst[--pos] = '.'; // Insert dots
     dst[--pos] = '.';
     dst[--pos] = '.';
   }
 
-  dst[len] = '\0';    // end it
+  dst[len] = '\0';    // End it
 
   // Copy down to 0
   while (pos--) dst[pos] = src[pos];
 }
 
-void Redraw_SD_List() {
-  InvalidateMenu();
-  Draw_Print_File_Menu();
-}
-
 void SDCard_Up() {
   card.cdup();
   DWIN_lcd_sd_status = false; // On next DWIN_Update
 }
 
 void SDCard_Folder(char * const dirname) {
   card.cd(dirname);
   DWIN_lcd_sd_status = false; // On next DWIN_Update
 }
 
@@ -858,22 +901,24 @@ void onClickSDItem() {
   if (hasUpDir && CurrentMenu->selected == 1) return SDCard_Up();
   else {
     const uint16_t filenum = CurrentMenu->selected - 1 - hasUpDir;
     card.selectFileByIndexSorted(filenum);
 
     // Enter that folder!
     if (card.flag.filenameIsDir) return SDCard_Folder(card.filename);
 
     if (card.fileIsBinary())
       return DWIN_Popup_Confirm(ICON_Error, F("Please check filenames"), F("Only G-code can be printed"));
-    else
+    else {
+      DWIN_Print_Header(card.longest_filename()); // Save filename
       return Goto_ConfirmToPrint();
+    }
   }
 }
 
 #if ENABLED(SCROLL_LONG_FILENAMES)
   char shift_name[LONG_FILENAME_LENGTH + 1] = "";
 
   void Draw_SDItem_Shifted(uint8_t &shift) {
     // Shorten to the available space
     const size_t lastchar = shift + MENU_CHAR_LIMIT;
     const char c = shift_name[lastchar];
@@ -885,21 +930,21 @@ void onClickSDItem() {
 
     shift_name[lastchar] = c;
   }
 
   void FileMenuIdle(bool reset=false) {
     static bool hasUpDir = false;
     static uint8_t last_itemselected = 0;
     static int8_t shift_amt = 0, shift_len = 0;
     if (reset) {
       last_itemselected = 0;
-      hasUpDir = !card.flag.workDirIsRoot; // is a SubDir
+      hasUpDir = !card.flag.workDirIsRoot; // Is a SubDir
       return;
     }
     const uint8_t selected = FileMenu->selected;
     if (last_itemselected != selected) {
       if (last_itemselected >= 1 + hasUpDir) FileMenu->Items()[last_itemselected]->redraw(true);
       last_itemselected = selected;
       if (selected >= 1 + hasUpDir) {
         const int8_t filenum = selected - 1 - hasUpDir; // Skip "Back" and ".."
         card.selectFileByIndexSorted(filenum);
         make_name_without_ext(shift_name, card.longest_filename(), LONG_FILENAME_LENGTH);
@@ -954,33 +999,42 @@ void Draw_Print_File_Menu() {
   TERN_(SCROLL_LONG_FILENAMES, FileMenuIdle(true));
 }
 
 //
 // Watch for media mount / unmount
 //
 void HMI_SDCardUpdate() {
   if (hmiFlag.home_flag) return;
   if (DWIN_lcd_sd_status != card.isMounted()) {
     DWIN_lcd_sd_status = card.isMounted();
-    if (IsMenu(FileMenu)) Redraw_SD_List();
+    ResetMenu(FileMenu);
+    if (IsMenu(FileMenu)) {
+      CurrentMenu = nullptr;
+      Draw_Print_File_Menu();
+    }
     if (!DWIN_lcd_sd_status && SD_Printing()) ui.abort_print();  // Media removed while printing
-    dwinUpdateLCD();
   }
 }
 
 /**
  * Dash board and indicators
  */
 
 void DWIN_Draw_Dashboard() {
 
   dwinDrawRectangle(1, HMI_data.Background_Color, 0, STATUS_Y + 21, DWIN_WIDTH, DWIN_HEIGHT - 1);
+  dwinDrawRectangle(1, HMI_data.SplitLine_Color, 0, 449, DWIN_WIDTH, 451);
+
+  DWINUI::Draw_Icon(ICON_MaxSpeedX,  10, 456);
+  DWINUI::Draw_Icon(ICON_MaxSpeedY,  95, 456);
+  DWINUI::Draw_Icon(ICON_MaxSpeedZ, 180, 456);
+  _draw_xyz_position(true);
 
   #if HAS_HOTEND
     DWINUI::Draw_Icon(ICON_HotendTemp, 10, 383);
     DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 28, 384, thermalManager.wholeDegHotend(0));
     DWINUI::Draw_String(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 25 + 3 * STAT_CHR_W + 5, 384, F("/"));
     DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 25 + 4 * STAT_CHR_W + 6, 384, thermalManager.degTargetHotend(0));
 
     DWINUI::Draw_Icon(ICON_StepE, 112, 417);
     DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 116 + 2 * STAT_CHR_W, 417, planner.flow_percentage[0]);
     DWINUI::Draw_String(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 116 + 5 * STAT_CHR_W + 2, 417, F("%"));
@@ -988,40 +1042,31 @@ void DWIN_Draw_Dashboard() {
 
   #if HAS_HEATED_BED
     DWINUI::Draw_Icon(ICON_BedTemp, 10, 416);
     DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 28, 417, thermalManager.wholeDegBed());
     DWINUI::Draw_String(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 25 + 3 * STAT_CHR_W + 5, 417, F("/"));
     DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 25 + 4 * STAT_CHR_W + 6, 417, thermalManager.degTargetBed());
   #endif
 
   DWINUI::Draw_Icon(ICON_Speed, 113, 383);
   DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 116 + 2 * STAT_CHR_W, 384, feedrate_percentage);
-  DWINUI::Draw_String(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 116 + 5 * STAT_CHR_W + 2, 384, F("%"));
+  IF_DISABLED(SHOW_SPEED_IND, DWINUI::Draw_String(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 116 + 5 * STAT_CHR_W + 2, 384, F("%")));
 
   #if HAS_FAN
     DWINUI::Draw_Icon(ICON_FanSpeed, 187, 383);
     DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 195 + 2 * STAT_CHR_W, 384, thermalManager.fan_speed[0]);
   #endif
 
   #if HAS_ZOFFSET_ITEM
     DWINUI::Draw_Icon(planner.leveling_active ? ICON_SetZOffset : ICON_Zoffset, 187, 416);
+    DWINUI::Draw_Signed_Float(DWIN_FONT_STAT, HMI_data.Indicator_Color,  HMI_data.Background_Color, 2, 2, 204, 417, BABY_Z_VAR);
   #endif
-
-  DWINUI::Draw_Signed_Float(DWIN_FONT_STAT, HMI_data.Indicator_Color,  HMI_data.Background_Color, 2, 2, 204, 417, BABY_Z_VAR);
-
-  dwinDrawRectangle(1, HMI_data.SplitLine_Color, 0, 449, DWIN_WIDTH, 451);
-
-  DWINUI::Draw_Icon(ICON_MaxSpeedX,  10, 456);
-  DWINUI::Draw_Icon(ICON_MaxSpeedY,  95, 456);
-  DWINUI::Draw_Icon(ICON_MaxSpeedZ, 180, 456);
-  _draw_xyz_position(true);
-
 }
 
 void Draw_Info_Menu() {
   DWINUI::ClearMainArea();
   if (HMI_IsChinese())
     Title.FrameCopy(30, 17, 28, 13);                        // "Info"
   else
     Title.ShowCaption(GET_TEXT_F(MSG_INFO_SCREEN));
   Draw_Menu_Line(0, ICON_Back, GET_TEXT_F(MSG_BACK), false, true);
 
@@ -1084,22 +1129,22 @@ void HMI_MainMenu() {
       case PAGE_CONTROL: Draw_Control_Menu(); break;
       case PAGE_ADVANCE: Draw_AdvancedSettings_Menu(); break;
     }
   }
   dwinUpdateLCD();
 }
 
 // Pause or Stop popup
 void onClick_PauseOrStop() {
   switch (select_print.now) {
-    case PRINT_PAUSE_RESUME: if (hmiFlag.select_flag) ui.pause_print(); break; // confirm pause
-    case PRINT_STOP: if (hmiFlag.select_flag) ui.abort_print(); break; // stop confirmed then abort print
+    case PRINT_PAUSE_RESUME: if (hmiFlag.select_flag) ui.pause_print(); break; // Confirm pause
+    case PRINT_STOP: if (hmiFlag.select_flag) ui.abort_print(); break; // Stop confirmed then abort print
     default: break;
   }
   return Goto_PrintProcess();
 }
 
 // Printing
 void HMI_Printing() {
   EncoderState encoder_diffState = get_encoder_state();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
   // Avoid flicker by updating only the previous menu
@@ -1118,21 +1163,21 @@ void HMI_Printing() {
         case PRINT_SETUP: ICON_Tune(); ICON_ResumeOrPause(); break;
         case PRINT_PAUSE_RESUME: ICON_ResumeOrPause(); ICON_Stop(); break;
         case PRINT_STOP: ICON_Stop(); break;
       }
     }
   }
   else if (encoder_diffState == ENCODER_DIFF_ENTER) {
     switch (select_print.now) {
       case PRINT_SETUP: Draw_Tune_Menu(); break;
       case PRINT_PAUSE_RESUME:
-        if (printingIsPaused()) {  // if printer is already in pause
+        if (printingIsPaused()) {  // If printer is already in pause
           ui.resume_print();
           break;
         }
         else
           return Goto_Popup(Popup_window_PauseOrStop, onClick_PauseOrStop);
       case PRINT_STOP:
         return Goto_Popup(Popup_window_PauseOrStop, onClick_PauseOrStop);
       default: break;
     }
   }
@@ -1156,26 +1201,20 @@ void Draw_Main_Area() {
     case Menu:
     case SetInt:
     case SetPInt:
     case SetIntNoDraw:
     case SetFloat:
     case SetPFloat:              ReDrawMenu(true); break;
     default: break;
   }
 }
 
-void HMI_ReturnScreen() {
-  checkkey = last_checkkey;
-  wait_for_user = false;
-  Draw_Main_Area();
-}
-
 void HMI_WaitForUser() {
   EncoderState encoder_diffState = get_encoder_state();
   if (encoder_diffState != ENCODER_DIFF_NO && !ui.backlight) {
     if (checkkey == WaitResponse) HMI_ReturnScreen();
     return ui.refresh_brightness();
   }
   if (!wait_for_user) {
     switch (checkkey) {
       case PrintDone:
         select_page.reset();
@@ -1190,21 +1229,21 @@ void HMI_WaitForUser() {
     }
   }
 }
 
 void HMI_Init() {
   #if ENABLED(SHOW_BOOTSCREEN)
     #ifndef BOOTSCREEN_TIMEOUT
       #define BOOTSCREEN_TIMEOUT 1100
     #endif
     DWINUI::Draw_Box(1, Color_Black, { 5, 220, DWIN_WIDTH - 5, DWINUI::fontHeight() });
-    DWINUI::Draw_CenteredString(Color_White, 220, F("Professional Firmware "));
+    DWINUI::Draw_CenteredString(Color_White, 220, F("ProUI starting up "));
     for (uint16_t t = 15; t < 257; t += 11) {
       DWINUI::Draw_Icon(ICON_Bar, 15, 260);
       dwinDrawRectangle(1, HMI_data.Background_Color, t, 260, 257, 280);
       dwinUpdateLCD();
       safe_delay((BOOTSCREEN_TIMEOUT) / 22);
     }
   #endif
   HMI_SetLanguage();
 }
 
@@ -1213,21 +1252,25 @@ void EachMomentUpdate() {
   const millis_t ms = millis();
 
   if (ELAPSED(ms, next_var_update_ms)) {
     next_var_update_ms = ms + DWIN_VAR_UPDATE_INTERVAL;
     blink = !blink;
     update_variable();
     #if HAS_ESDIAG
       if (checkkey == ESDiagProcess) ESDiag.Update();
     #endif
     #if SHOW_TUNING_GRAPH
-      if (checkkey == PidProcess) plot.Update((HMI_value.pidresult == PIDTEMP_START) ? thermalManager.wholeDegHotend(0) : thermalManager.wholeDegBed());
+      if (checkkey == PidProcess) {
+        TERN_(PIDTEMP, if (HMI_value.tempcontrol == PIDTEMP_START) plot.Update(thermalManager.wholeDegHotend(0)));
+        TERN_(PIDTEMPBED, if (HMI_value.tempcontrol == PIDTEMPBED_START) plot.Update(thermalManager.wholeDegBed()));
+      }
+      TERN_(MPCTEMP, if (checkkey == MPCProcess) plot.Update(thermalManager.wholeDegHotend(0)));
     #endif
   }
 
   #if HAS_STATUS_MESSAGE_TIMEOUT
     bool did_expire = ui.status_reset_callback && (*ui.status_reset_callback)();
     did_expire |= ui.status_message_expire_ms && ELAPSED(ms, ui.status_message_expire_ms);
     if (did_expire) ui.reset_status();
   #endif
 
   if (ELAPSED(ms, next_status_update_ms)) {
@@ -1254,54 +1297,51 @@ void EachMomentUpdate() {
     if ((printingIsPaused() != hmiFlag.pause_flag) && !hmiFlag.home_flag) {
       hmiFlag.pause_flag = printingIsPaused();
       if (hmiFlag.pause_flag)
         DWIN_Print_Pause();
       else if (hmiFlag.abort_flag)
         DWIN_Print_Aborted();
       else
         DWIN_Print_Resume();
     }
 
-    if (checkkey == PrintProcess) { // print process
+    if (checkkey == PrintProcess) { // Print process
 
-      duration_t elapsed = print_job_timer.duration(); // print timer
-
-      if (card.isPrinting() && !hmiFlag.percent_flag) {
-        uint8_t percentDone = card.percentDone();
-        if (_percent_done != percentDone) { // print percent
-          _percent_done = percentDone;
-          Draw_Print_ProgressBar();
-        }
+      // Progress percent
+      static uint8_t _percent_done = 255;
+      if (_percent_done != ui.get_progress_percent()) {
+        _percent_done = ui.get_progress_percent();
+        Draw_Print_ProgressBar();
+      }
 
-        // Estimate remaining time every 20 seconds
-        static millis_t next_remain_time_update = 0;
-        if (_percent_done > 1 && ELAPSED(ms, next_remain_time_update) && !hmiFlag.heat_flag && !hmiFlag.remain_flag) {
-          _remain_time = (elapsed.value - dwin_heat_time) / (_percent_done * 0.01f) - (elapsed.value - dwin_heat_time);
-          next_remain_time_update += DWIN_REMAIN_TIME_UPDATE_INTERVAL;
+      // Remaining time
+      #if ENABLED(SHOW_REMAINING_TIME)
+        static uint32_t _remain_time = 0;
+        if (_remain_time != ui.get_remaining_time()) {
+          _remain_time = ui.get_remaining_time();
           Draw_Print_ProgressRemain();
         }
-      }
+      #endif
 
-      // Print time so far
-      static uint16_t last_Printtime = 0;
-      const uint16_t min = (elapsed.value % 3600) / 60;
-      if (last_Printtime != min) { // 1 minute update
-        last_Printtime = min;
+      // Elapsed print time
+      static uint16_t _printtime = 0;
+      const uint16_t min = (print_job_timer.duration() % 3600) / 60;
+      if (_printtime != min) { // 1 minute update
+        _printtime = min;
         Draw_Print_ProgressElapsed();
       }
-
     }
     #if ENABLED(POWER_LOSS_RECOVERY)
-      else if (DWIN_lcd_sd_status && recovery.dwin_flag) { // resume print before power off
+      else if (DWIN_lcd_sd_status && recovery.dwin_flag) { // Resume print before power off
         return Goto_PowerLossRecovery();
       }
-    #endif // POWER_LOSS_RECOVERY
+    #endif
 
     dwinUpdateLCD();
   }
 }
 
 #if ENABLED(POWER_LOSS_RECOVERY)
   void Popup_PowerLossRecovery() {
     DWINUI::ClearMainArea();
     Draw_Popup_Bkgd();
     if (HMI_IsChinese()) {
@@ -1314,45 +1354,46 @@ void EachMomentUpdate() {
       DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 70, GET_TEXT_F(MSG_OUTAGE_RECOVERY));
       DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 147, F("It looks like the last"));
       DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 167, F("file was interrupted."));
       DWINUI::Draw_Button(BTN_Cancel,    26, 280);
       DWINUI::Draw_Button(BTN_Continue, 146, 280);
     }
     MediaFile *dir = nullptr;
     const char * const filename = card.diveToFile(true, dir, recovery.info.sd_filename);
     card.selectFileByName(filename);
     DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 207, card.longest_filename());
+    DWIN_Print_Header(card.longest_filename()); // Save filename
     Draw_Select_Highlight(hmiFlag.select_flag);
     dwinUpdateLCD();
   }
 
   void onClick_PowerLossRecovery() {
     if (hmiFlag.select_flag) {
       queue.inject(F("M1000C"));
       select_page.reset();
       return Goto_Main_Menu();
     }
     else {
+      HMI_SaveProcessID(NothingToDo);
       select_print.set(PRINT_SETUP);
       queue.inject(F("M1000"));
     }
   }
 
   void Goto_PowerLossRecovery() {
     recovery.dwin_flag = false;
     LCD_MESSAGE(MSG_CONTINUE_PRINT_JOB);
     Goto_Popup(Popup_PowerLossRecovery, onClick_PowerLossRecovery);
   }
 
 #endif // POWER_LOSS_RECOVERY
 
-
 void DWIN_HandleScreen() {
   switch (checkkey) {
     case MainMenu:        HMI_MainMenu(); break;
     case Menu:            HMI_Menu(); break;
     case SetInt:          HMI_SetDraw(); break;
     case SetFloat:        HMI_SetDraw(); break;
     case SetPInt:         HMI_SetPInt(); break;
     case SetPFloat:       HMI_SetPFloat(); break;
     case SetIntNoDraw:    HMI_SetNoDraw(); break;
     case PrintProcess:    HMI_Printing(); break;
@@ -1365,133 +1406,154 @@ void DWIN_HandleScreen() {
     TERN_(HAS_ESDIAG, case ESDiagProcess:)
     case WaitResponse:    HMI_WaitForUser(); break;
     case Homing:
     case PidProcess:
     case NothingToDo:     break;
     default: break;
   }
 }
 
 bool IDisPopUp() {    // If ID is popup...
-  return  (checkkey == NothingToDo)
-       || (checkkey == WaitResponse)
-       || (checkkey == Homing)
-       || (checkkey == Leveling)
-       || (checkkey == PidProcess)
-       || TERN0(HAS_ESDIAG, (checkkey == ESDiagProcess))
-       || (checkkey == Popup);
+  switch (checkkey) {
+    case NothingToDo:
+    case WaitResponse:
+    case Popup:
+    case Homing:
+    case Leveling:
+    case PidProcess:
+    TERN_(HAS_ESDIAG, case ESDiagProcess:)
+      return true;
+    default: break;
+  }
+  return false;
 }
 
 void HMI_SaveProcessID(const uint8_t id) {
-  if (checkkey != id) {
-    if (!IDisPopUp()) last_checkkey = checkkey; // if previous is not a popup
-    if ((id == Popup)
-         || TERN0(HAS_ESDIAG, (id == ESDiagProcess))
-         || (id == PrintDone)
-         || (id == Leveling)
-         || (id == WaitResponse)) wait_for_user = true;
-    checkkey = id;
+  if (checkkey == id) return;
+  if (!IDisPopUp()) last_checkkey = checkkey; // If previous is not a popup
+  checkkey = id;
+  switch (id) {
+    case Popup:
+    case WaitResponse:
+    case PrintDone:
+    case Leveling:
+    TERN_(HAS_ESDIAG, case ESDiagProcess:)
+      wait_for_user = true;
+    default: break;
   }
 }
 
+void HMI_ReturnScreen() {
+  checkkey = last_checkkey;
+  wait_for_user = false;
+  Draw_Main_Area();
+}
+
 void dwinHomingStart() {
   hmiFlag.home_flag = true;
   HMI_SaveProcessID(Homing);
   Title.ShowCaption(GET_TEXT_F(MSG_HOMING));
   DWIN_Show_Popup(ICON_BLTouch, GET_TEXT_F(MSG_HOMING), GET_TEXT_F(MSG_PLEASE_WAIT));
 }
 
 void dwinHomingDone() {
   hmiFlag.home_flag = false;
-  HMI_ReturnScreen();
+  if (last_checkkey == PrintDone)
+    Goto_PrintDone();
+  else
+    HMI_ReturnScreen();
 }
 
 void DWIN_LevelingStart() {
   #if HAS_BED_PROBE
     HMI_SaveProcessID(Leveling);
     Title.ShowCaption(GET_TEXT_F(MSG_BED_LEVELING));
     DWIN_Show_Popup(ICON_AutoLeveling, GET_TEXT_F(MSG_BED_LEVELING), GET_TEXT_F(MSG_PLEASE_WAIT));
     #if ALL(AUTO_BED_LEVELING_UBL, PREHEAT_BEFORE_LEVELING)
-      #if HAS_HOTEND
-        if (thermalManager.degTargetHotend(0) < LEVELING_NOZZLE_TEMP)
-          thermalManager.setTargetHotend(LEVELING_NOZZLE_TEMP, 0);
-      #endif
-      #if HAS_HEATED_BED
-        if (thermalManager.degTargetBed() < HMI_data.BedLevT)
-          thermalManager.setTargetBed(HMI_data.BedLevT);
+      #if HAS_BED_PROBE
+        if (!DEBUGGING(DRYRUN)) probe.preheat_for_probing(LEVELING_NOZZLE_TEMP, HMI_data.BedLevT);
+      #else
+        #if HAS_HOTEND
+          if (!DEBUGGING(DRYRUN) && thermalManager.degTargetHotend(0) < LEVELING_NOZZLE_TEMP) {
+            thermalManager.setTargetHotend(LEVELING_NOZZLE_TEMP, 0);
+            thermalManager.wait_for_hotend(0);
+          }
+        #endif
+        #if HAS_HEATED_BED
+          if (!DEBUGGING(DRYRUN) && thermalManager.degTargetBed() < HMI_data.BedLevT) {
+            thermalManager.setTargetBed(HMI_data.BedLevT);
+            thermalManager.wait_for_bed_heating();
+          }
+        #endif
       #endif
-      TERN_(HAS_HOTEND, thermalManager.wait_for_hotend(0));
-      TERN_(HAS_HEATED_BED, thermalManager.wait_for_bed_heating());
     #endif
   #elif ENABLED(MESH_BED_LEVELING)
     Draw_ManualMesh_Menu();
   #endif
 }
 
 void DWIN_LevelingDone() {
-  TERN_(HAS_MESH, Goto_MeshViewer());
+  TERN_(HAS_MESH, Goto_MeshViewer(true));
 }
 
 #if HAS_MESH
   void DWIN_MeshUpdate(const int8_t cpos, const int8_t tpos, const_float_t zval) {
-    char msg[33] = "";
     char str_1[6] = "";
-    sprintf_P(msg, PSTR(S_FMT " %i/%i Z=%s"), GET_TEXT(MSG_PROBING_POINT), cpos, tpos, dtostrf(zval, 1, 2, str_1));
-    ui.set_status(msg);
+    ui.status_printf(0, F(S_FMT " %i/%i Z=%s"), GET_TEXT_F(MSG_PROBING_POINT), cpos, tpos, dtostrf(zval, 1, 2, str_1));
   }
 #endif
 
 // PID/MPC process
 
 #if SHOW_TUNING_GRAPH
 
   #include "plot.h"
 
   celsius_t _maxtemp, _target;
   void DWIN_Draw_PID_MPC_Popup() {
     constexpr frame_rect_t gfrm = { 40, 180, DWIN_WIDTH - 80, 120 };
     DWINUI::ClearMainArea();
     Draw_Popup_Bkgd();
 
-    switch (HMI_value.pidresult) {
+    switch (HMI_value.tempcontrol) {
       default: return;
       #if ENABLED(MPC_AUTOTUNE)
         case MPCTEMP_START:
           DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 100, GET_TEXT_F(MSG_MPC_AUTOTUNE));
           DWINUI::Draw_String(HMI_data.PopupTxt_Color, gfrm.x, gfrm.y - DWINUI::fontHeight() - 4, F("MPC target:    Celsius"));
           break;
       #endif
       #if ANY(PIDTEMP, PIDTEMPBED)
         TERN_(PIDTEMP,    case PIDTEMP_START:)
         TERN_(PIDTEMPBED, case PIDTEMPBED_START:)
           DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 100, GET_TEXT_F(MSG_PID_AUTOTUNE));
           DWINUI::Draw_String(HMI_data.PopupTxt_Color, gfrm.x, gfrm.y - DWINUI::fontHeight() - 4, F("PID target:    Celsius"));
           break;
       #endif
     }
 
-    switch (HMI_value.pidresult) {
+    switch (HMI_value.tempcontrol) {
       default: break;
       #if ANY(PIDTEMP, MPC_AUTOTUNE)
         TERN_(PIDTEMP,      case PIDTEMP_START:)
         TERN_(MPC_AUTOTUNE, case MPCTEMP_START:)
           DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 120, F("for Nozzle is running."));
           break;
       #endif
       #if ENABLED(PIDTEMPBED)
         case PIDTEMPBED_START:
           DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 120, F("for BED is running."));
           break;
       #endif
     }
 
-    switch (HMI_value.pidresult) {
+    switch (HMI_value.tempcontrol) {
       default: break;
       #if ENABLED(MPC_AUTOTUNE)
         case MPCTEMP_START:
           _maxtemp = thermalManager.hotend_maxtemp[0];
           _target = 200;
           break;
       #endif
       #if ENABLED(PIDTEMP)
         case PIDTEMP_START:
           _maxtemp = thermalManager.hotend_maxtemp[0];
@@ -1519,21 +1581,21 @@ void DWIN_LevelingDone() {
     if (seenS) {
       switch (hid) {
         OPTCODE(PIDTEMP,    case 0 ... HOTENDS - 1: HMI_data.HotendPidT = temp; break)
         OPTCODE(PIDTEMPBED, case H_BED:             HMI_data.BedPidT = temp;    break)
         default: break;
       }
     }
   }
 
   void DWIN_PidTuning(tempcontrol_t result) {
-    HMI_value.pidresult = result;
+    HMI_value.tempcontrol = result;
     switch (result) {
       #if ENABLED(PIDTEMP)
         case PIDTEMP_START:
           HMI_SaveProcessID(PidProcess);
           #if SHOW_TUNING_GRAPH
             DWIN_Draw_PID_MPC_Popup();
           #else
             DWIN_Draw_Popup(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE), F("for Nozzle is running."));
           #endif
           break;
@@ -1553,125 +1615,107 @@ void DWIN_LevelingDone() {
           break;
       #endif
       case PID_BAD_HEATER_ID:
         checkkey = last_checkkey;
         DWIN_Popup_Confirm(ICON_TempTooLow, GET_TEXT_F(MSG_PID_AUTOTUNE_FAILED), GET_TEXT_F(MSG_PID_BAD_HEATER_ID));
         break;
       case PID_TUNING_TIMEOUT:
         checkkey = last_checkkey;
         DWIN_Popup_Confirm(ICON_TempTooHigh, GET_TEXT_F(MSG_ERROR), GET_TEXT_F(MSG_PID_TIMEOUT));
         break;
-      case PID_DONE:
+      case AUTOTUNE_DONE:
         checkkey = last_checkkey;
         DWIN_Popup_Confirm(ICON_TempTooLow, GET_TEXT_F(MSG_PID_AUTOTUNE), GET_TEXT_F(MSG_BUTTON_DONE));
         break;
       default:
         checkkey = last_checkkey;
         break;
     }
   }
 
 #endif // DWIN_PID_TUNE
 
 #if ENABLED(MPC_AUTOTUNE)
 
   void DWIN_MPCTuning(tempcontrol_t result) {
-    HMI_value.pidresult = result;
+    HMI_value.tempcontrol = result;
     switch (result) {
       case MPCTEMP_START:
         HMI_SaveProcessID(MPCProcess);
         #if SHOW_TUNING_GRAPH
           DWIN_Draw_PID_MPC_Popup();
         #else
           DWIN_Draw_Popup(ICON_TempTooHigh, GET_TEXT_F(MSG_MPC_AUTOTUNE), F("for Nozzle is running."));
         #endif
         break;
       case MPC_TEMP_ERROR:
         checkkey = last_checkkey;
         DWIN_Popup_Confirm(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE_FAILED), F(STR_MPC_TEMPERATURE_ERROR));
         ui.reset_alert_level();
         break;
       case MPC_INTERRUPTED:
         checkkey = last_checkkey;
         DWIN_Popup_Confirm(ICON_TempTooHigh, GET_TEXT_F(MSG_ERROR), F(STR_MPC_AUTOTUNE_INTERRUPTED));
         ui.reset_alert_level();
         break;
-      case MPC_DONE:
+      case AUTOTUNE_DONE:
         checkkey = last_checkkey;
         DWIN_Popup_Confirm(ICON_TempTooLow, GET_TEXT_F(MSG_MPC_AUTOTUNE), GET_TEXT_F(MSG_BUTTON_DONE));
         ui.reset_alert_level();
         break;
       default:
         checkkey = last_checkkey;
         ui.reset_alert_level();
         break;
     }
   }
 
 #endif // MPC_AUTOTUNE
 
 // Started a Print Job
 void DWIN_Print_Started() {
   TERN_(HAS_GCODE_PREVIEW, if (Host_Printing()) Preview_Invalidate());
-  _percent_done = 0;
-  _remain_time = 0;
-  hmiFlag.percent_flag = false;
-  hmiFlag.remain_flag = false;
+  TERN_(SET_PROGRESS_PERCENT, ui.progress_reset());
+  TERN_(SET_REMAINING_TIME, ui.reset_remaining_time());
   hmiFlag.pause_flag = false;
   hmiFlag.abort_flag = false;
   select_print.reset();
   Goto_PrintProcess();
 }
 
 // Pause a print job
 void DWIN_Print_Pause() {
   ICON_ResumeOrPause();
 }
 
 // Resume print job
 void DWIN_Print_Resume() {
   ICON_ResumeOrPause();
   LCD_MESSAGE(MSG_RESUME_PRINT);
 }
 
 // Ended print job
 void DWIN_Print_Finished() {
   TERN_(POWER_LOSS_RECOVERY, if (card.isPrinting()) recovery.cancel());
+  hmiFlag.abort_flag = false;
   hmiFlag.pause_flag = false;
   wait_for_heatup = false;
   planner.finish_and_disable();
   thermalManager.cooldown();
   Goto_PrintDone();
 }
 
 // Print was aborted
 void DWIN_Print_Aborted() {
   DWIN_Print_Finished();
 }
 
-// Progress and remaining time update
-void DWIN_M73() {
-  if (parser.seenval('P')) {
-    _percent_done = parser.value_byte();
-    hmiFlag.percent_flag = true;
-  }
-  if (parser.seenval('R')) {
-    _remain_time = parser.value_ulong() * 60;
-    hmiFlag.remain_flag = true;
-  }
-  if (checkkey == PrintProcess) {
-    Draw_Print_ProgressBar();
-    Draw_Print_ProgressRemain();
-    Draw_Print_ProgressElapsed();
-  }
-}
-
 #if HAS_FILAMENT_SENSOR
   // Filament Runout process
   void DWIN_FilamentRunout(const uint8_t extruder) { LCD_MESSAGE(MSG_RUNOUT_SENSOR); }
 #endif
 
 void DWIN_SetColorDefaults() {
   HMI_data.Background_Color = Def_Background_Color;
   HMI_data.Cursor_Color     = Def_Cursor_Color;
   HMI_data.TitleBg_Color    = Def_TitleBg_Color;
   HMI_data.TitleTxt_Color   = Def_TitleTxt_Color;
@@ -1696,29 +1740,37 @@ void DWIN_SetDataDefaults() {
   DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color, HMI_data.StatusBg_Color);
   TERN_(PIDTEMP, HMI_data.HotendPidT = DEF_HOTENDPIDT);
   TERN_(PIDTEMPBED, HMI_data.BedPidT = DEF_BEDPIDT);
   TERN_(DWIN_PID_TUNE, HMI_data.PidCycles = DEF_PIDCYCLES);
   #if ENABLED(PREVENT_COLD_EXTRUSION)
     HMI_data.ExtMinT = EXTRUDE_MINTEMP;
     ApplyExtMinT();
   #endif
   TERN_(PREHEAT_BEFORE_LEVELING, HMI_data.BedLevT = LEVELING_BED_TEMP);
   TERN_(BAUD_RATE_GCODE, SetBaud250K());
-  HMI_data.FullManualTramming = false;
+  #if ALL(LCD_BED_TRAMMING, HAS_BED_PROBE)
+    HMI_data.FullManualTramming = DISABLED(BED_TRAMMING_USE_PROBE);
+  #endif
+  #if ENABLED(MEDIASORT_MENU_ITEM)
+    HMI_data.MediaSort = true;
+    card.setSortOn(true);
+  #endif
   HMI_data.MediaAutoMount = ENABLED(HAS_SD_EXTENDER);
   #if ALL(INDIVIDUAL_AXIS_HOMING_SUBMENU, MESH_BED_LEVELING)
     HMI_data.z_after_homing = DEF_Z_AFTER_HOMING;
   #endif
   #if ALL(LED_CONTROL_MENU, HAS_COLOR_LEDS)
     TERN_(LED_COLOR_PRESETS, leds.set_default());
     ApplyLEDColor();
   #endif
+  TERN_(ADAPTIVE_STEP_SMOOTHING, HMI_data.AdaptiveStepSmoothing = true);
+  TERN_(HAS_GCODE_PREVIEW, HMI_data.EnablePreview = true);
 }
 
 void DWIN_CopySettingsTo(char * const buff) {
   memcpy(buff, &HMI_data, eeprom_data_size);
 }
 
 void DWIN_CopySettingsFrom(const char * const buff) {
   memcpy(&HMI_data, buff, sizeof(HMI_data_t));
   if (HMI_data.Text_Color == HMI_data.Background_Color) DWIN_SetColorDefaults();
   DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color, HMI_data.StatusBg_Color);
@@ -1731,45 +1783,44 @@ void DWIN_CopySettingsFrom(const char * const buff) {
       HMI_data.Led_Color.g,
       HMI_data.Led_Color.b
       OPTARG(HAS_WHITE_LED, HMI_data.Led_Color.w)
     );
     leds.update();
   #endif
 }
 
 // Initialize or re-initialize the LCD
 void MarlinUI::init_lcd() {
-  delay(750);   // wait to wakeup screen
+  delay(750);   // Wait to wakeup screen
   const bool hs = dwinHandshake(); UNUSED(hs);
   dwinFrameSetDir(1);
   dwinJPGCacheTo1(Language_English);
   encoderConfiguration();
 }
 
 void dwinInitScreen() {
   DWIN_SetColorDefaults();
-  HMI_Init();   // draws boot screen
+  HMI_Init();   // Draws boot screen
   DWINUI::init();
   DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color, HMI_data.StatusBg_Color);
   DWINUI::onTitleDraw = Draw_Title;
   InitMenu();
   checkkey = 255;
   hash_changed = true;
-  last_E = 0;
   DWIN_DrawStatusLine();
   DWIN_Draw_Dashboard();
   Goto_Main_Menu();
 }
 
 void MarlinUI::update() {
-  EachMomentUpdate();   // Status update
   HMI_SDCardUpdate();   // SD card update
+  EachMomentUpdate();   // Status update
   DWIN_HandleScreen();  // Rotary encoder update
 }
 
 void MarlinUI::refresh() { /* Nothing to see here */ }
 
 #if HAS_LCD_BRIGHTNESS
   void MarlinUI::_set_brightness() { dwinLCDBrightness(backlight ? brightness : 0); }
 #endif
 
 void MarlinUI::kill_screen(FSTR_P const lcd_error, FSTR_P const lcd_component) {
@@ -1791,21 +1842,21 @@ void DWIN_RedrawDash() {
   DWIN_DrawStatusMessage();
   DWIN_Draw_Dashboard();
 }
 
 void DWIN_RedrawScreen() {
   Draw_Main_Area();
   DWIN_RedrawDash();
 }
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
-  void DWIN_Popup_Pause(FSTR_P const fmsg, uint8_t button /*= 0*/) {
+  void DWIN_Popup_Pause(FSTR_P const fmsg, uint8_t button/*=0*/) {
     HMI_SaveProcessID(button ? WaitResponse : NothingToDo);
     DWIN_Show_Popup(ICON_BLTouch, GET_TEXT_F(MSG_ADVANCED_PAUSE), fmsg, button);
   }
 
   void MarlinUI::pause_show_message(const PauseMessage message, const PauseMode mode/*=PAUSE_MODE_SAME*/, const uint8_t extruder/*=active_extruder*/) {
     //if (mode == PAUSE_MODE_SAME) return;
     pause_mode = mode;
     switch (message) {
       case PAUSE_MESSAGE_PARKING:  DWIN_Popup_Pause(GET_TEXT_F(MSG_PAUSE_PRINT_PARKING));    break;                // M125
       case PAUSE_MESSAGE_CHANGING: DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_INIT));   break;                // pause_print (M125, M600)
@@ -1846,31 +1897,29 @@ void DWIN_RedrawScreen() {
   }
 
   void Goto_FilamentPurge() {
     pause_menu_response = PAUSE_RESPONSE_WAIT_FOR;
     Goto_Popup(Draw_Popup_FilamentPurge, onClick_FilamentPurge);
   }
 
 #endif // ADVANCED_PAUSE_FEATURE
 
 #if HAS_MESH
-
   void DWIN_MeshViewer() {
     if (!leveling_is_valid())
       DWIN_Popup_Continue(ICON_BLTouch, GET_TEXT_F(MSG_MESH_VIEWER), GET_TEXT_F(MSG_NO_VALID_MESH));
     else {
       HMI_SaveProcessID(WaitResponse);
       MeshViewer.Draw();
     }
   }
-
-#endif // HAS_MESH
+#endif
 
 #if HAS_LOCKSCREEN
 
   void DWIN_LockScreen() {
     if (checkkey != Locked) {
       lockScreen.rprocess = checkkey;
       checkkey = Locked;
       lockScreen.init();
     }
   }
@@ -1886,53 +1935,50 @@ void DWIN_RedrawScreen() {
     EncoderState encoder_diffState = get_encoder_state();
     if (encoder_diffState == ENCODER_DIFF_NO) return;
     lockScreen.onEncoder(encoder_diffState);
     if (lockScreen.isUnlocked()) DWIN_UnLockScreen();
   }
 
 #endif // HAS_LOCKSCREEN
 
 #if HAS_GCODE_PREVIEW
 
+  void SetPreview() { Toggle_Chkb_Line(HMI_data.EnablePreview); }
+
   void onClick_ConfirmToPrint() {
-    Preview_Reset();
     DWIN_ResetStatusLine();
     if (hmiFlag.select_flag) {     // Confirm
-      hmiFlag.heat_flag = true;
       Goto_Main_Menu();
       return card.openAndPrintFile(card.filename);
     }
     else
       HMI_ReturnScreen();
   }
 
-#endif
+#endif // HAS_GCODE_PREVIEW
 
 void Goto_ConfirmToPrint() {
   #if HAS_GCODE_PREVIEW
-    Goto_Popup(Preview_DrawFromSD, onClick_ConfirmToPrint);
-  #else
-    // Print SD file
-    hmiFlag.heat_flag = true;
-    card.openAndPrintFile(card.filename);
+    if (HMI_data.EnablePreview) return Goto_Popup(Preview_DrawFromSD, onClick_ConfirmToPrint);
   #endif
+  card.openAndPrintFile(card.filename); // Direct print SD file
 }
 
 #if HAS_ESDIAG
   void Draw_EndStopDiag() {
     HMI_SaveProcessID(ESDiagProcess);
     ESDiag.Draw();
   }
 #endif
 
 //=============================================================================
-// NEW MENU SUBSYSTEM
+// MENU SUBSYSTEM
 //=============================================================================
 
 // Tool functions
 
 #if ENABLED(EEPROM_SETTINGS)
 
   void WriteEeprom() {
     DWIN_DrawStatusLine(GET_TEXT_F(MSG_STORE_EEPROM));
     dwinUpdateLCD();
     DONE_BUZZ(settings.save());
@@ -1947,161 +1993,142 @@ void Goto_ConfirmToPrint() {
   void ResetEeprom() {
     settings.reset();
     DWIN_RedrawScreen();
     DONE_BUZZ(true);
   }
 
   #if HAS_MESH
     void SaveMesh() { TERN(AUTO_BED_LEVELING_UBL, UBLMeshSave(), WriteEeprom()); }
   #endif
 
-#endif
+#endif // EEPROM_SETTINGS
 
 // Reset Printer
 void RebootPrinter() {
   wait_for_heatup = wait_for_user = false;    // Stop waiting for heating/user
   thermalManager.disable_all_heaters();
   planner.finish_and_disable();
   DWIN_RebootScreen();
   hal.reboot();
 }
 
 void Goto_Info_Menu() {
   Draw_Info_Menu();
   dwinUpdateLCD();
   HMI_SaveProcessID(WaitResponse);
 }
 
 void DisableMotors() { queue.inject(F("M84")); }
 
 void AutoLev() {   // Always reacquire the Z "home" position
-  queue.inject(F(TERN(AUTO_BED_LEVELING_UBL, "G28Z\nG29P1", "G28XYO\nG28Z\nG29")));
+  queue.inject(F(TERN(AUTO_BED_LEVELING_UBL, "G29P1", "G29")));
 }
 
 void AutoHome() { queue.inject_P(G28_STR); }
 
 #if ENABLED(INDIVIDUAL_AXIS_HOMING_SUBMENU)
   void HomeX() { queue.inject(F("G28X")); }
   void HomeY() { queue.inject(F("G28Y")); }
   void HomeZ() { queue.inject(F("G28Z")); }
   #if ALL(INDIVIDUAL_AXIS_HOMING_SUBMENU, MESH_BED_LEVELING)
     void ApplyZAfterHoming() { HMI_data.z_after_homing = MenuData.Value; };
     void SetZAfterHoming() { SetIntOnClick(0, 20, HMI_data.z_after_homing, ApplyZAfterHoming); }
   #endif
 #endif
 
-#if HAS_HOME_OFFSET
-  // Apply workspace offset, making the current position 0,0,0
-  void SetHome() {
-    queue.inject(F("G92X0Y0Z0"));
-    DONE_BUZZ(true);
-  }
-#endif
-
 #if HAS_ZOFFSET_ITEM
 
   void ApplyZOffset() { TERN_(EEPROM_SETTINGS, settings.save()); }
   void LiveZOffset() {
     #if ANY(BABYSTEP_ZPROBE_OFFSET, JUST_BABYSTEP)
       const_float_t step_zoffset = round((MenuData.Value / 100.0f) * planner.settings.axis_steps_per_mm[Z_AXIS]) - babystep.accum;
       if (BABYSTEP_ALLOWED()) babystep.add_steps(Z_AXIS, step_zoffset);
     #endif
   }
   void SetZOffset() {
     #if ANY(BABYSTEP_ZPROBE_OFFSET, JUST_BABYSTEP)
       babystep.accum = round(planner.settings.axis_steps_per_mm[Z_AXIS] * BABY_Z_VAR);
     #endif
     SetPFloatOnClick(Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX, 2, ApplyZOffset, LiveZOffset);
   }
 
-  void SetMoveZto0() {
-    #if ENABLED(Z_SAFE_HOMING)
-      char cmd[54], str_1[5], str_2[5];
-      sprintf_P(cmd, PSTR("G28XYO\nG28Z\nG0X%sY%sF5000\nG0Z0F300\nM400"),
-        dtostrf(Z_SAFE_HOMING_X_POINT, 1, 1, str_1),
-        dtostrf(Z_SAFE_HOMING_Y_POINT, 1, 1, str_2)
-      );
-      gcode.process_subcommands_now(cmd);
-    #else
-      TERN_(HAS_LEVELING, set_bed_leveling_enabled(false));
-      gcode.process_subcommands_now(F("G28Z\nG0Z0F300\nM400"));
-    #endif
-    ui.reset_status();
-    DONE_BUZZ(true);
-  }
+#endif // HAS_ZOFFSET_ITEM
 
-  #if !HAS_BED_PROBE
-    void HomeZandDisable() {
-      SetMoveZto0();
-      DisableMotors();
-    }
+void SetMoveZto0() {
+  #if ENABLED(Z_SAFE_HOMING)
+    char cmd[54], str_1[5], str_2[5];
+    sprintf_P(cmd, PSTR("G28XYO\nG28Z\nG0X%sY%sF5000\nG0Z0F300\nM400"),
+      dtostrf(Z_SAFE_HOMING_X_POINT, 1, 1, str_1),
+      dtostrf(Z_SAFE_HOMING_Y_POINT, 1, 1, str_2)
+    );
+    gcode.process_subcommands_now(cmd);
+  #else
+    TERN_(HAS_LEVELING, set_bed_leveling_enabled(false));
+    gcode.process_subcommands_now(F("G28Z\nG0Z0F300\nM400"));
   #endif
+  ui.reset_status();
+  DONE_BUZZ(true);
+}
 
-#endif // HAS_ZOFFSET_ITEM
+#if DISABLED(HAS_BED_PROBE)
+  void HomeZandDisable() {
+    SetMoveZto0();
+    DisableMotors();
+  }
+#endif
 
 #if HAS_PREHEAT
   #define _DoPreheat(N) void DoPreheat##N() { ui.preheat_all(N-1); }\
                         void DoPreheatHotend##N() { ui.preheat_hotend(N-1); }
   REPEAT_1(PREHEAT_COUNT, _DoPreheat)
 #endif
 
 void DoCoolDown() { thermalManager.cooldown(); }
 
 void SetLanguage() {
   HMI_ToggleLanguage();
   CurrentMenu = nullptr;  // Invalidate menu to full redraw
   Draw_Prepare_Menu();
 }
 
 bool EnableLiveMove = false;
 void SetLiveMove() { Toggle_Chkb_Line(EnableLiveMove); }
-void LiveMove() {
+void AxisMove(AxisEnum axis) {
+  #if HAS_HOTEND
+    if (axis == E_AXIS && thermalManager.tooColdToExtrude(0)) {
+      gcode.process_subcommands_now(F("G92E0"));  // Reset extruder position
+      return DWIN_Popup_Confirm(ICON_TempTooLow, GET_TEXT_F(MSG_HOTEND_TOO_COLD), GET_TEXT_F(MSG_PLEASE_PREHEAT));
+    }
+  #endif
   planner.synchronize();
+  if (!planner.is_full()) planner.buffer_line(current_position, manual_feedrate_mm_s[axis]);
+}
+void LiveMove() {
   if (!EnableLiveMove) return;
   *MenuData.P_Float = MenuData.Value / MINUNITMULT;
-  if (!planner.is_full()) planner.buffer_line(current_position, manual_feedrate_mm_s[HMI_value.axis]);
+  AxisMove(HMI_value.axis);
 }
 void ApplyMove() {
-  planner.synchronize();
   if (EnableLiveMove) return;
-  if (HMI_value.axis == E_AXIS) last_E = MenuData.Value / MINUNITMULT;
-  if (!planner.is_full()) planner.buffer_line(current_position, manual_feedrate_mm_s[HMI_value.axis]);
+  AxisMove(HMI_value.axis);
 }
 
 void SetMoveX() { HMI_value.axis = X_AXIS; SetPFloatOnClick(X_MIN_POS, X_MAX_POS, UNITFDIGITS, ApplyMove, LiveMove); }
 void SetMoveY() { HMI_value.axis = Y_AXIS; SetPFloatOnClick(Y_MIN_POS, Y_MAX_POS, UNITFDIGITS, ApplyMove, LiveMove); }
 void SetMoveZ() { HMI_value.axis = Z_AXIS; SetPFloatOnClick(Z_MIN_POS, Z_MAX_POS, UNITFDIGITS, ApplyMove, LiveMove); }
 
 #if HAS_HOTEND
   void SetMoveE() {
-    if (thermalManager.tooColdToExtrude(0)) return DWIN_Popup_Confirm(ICON_TempTooLow, GET_TEXT_F(MSG_HOTEND_TOO_COLD), GET_TEXT_F(MSG_PLEASE_PREHEAT));
-    HMI_value.axis = E_AXIS; SetPFloatOnClick(E_MIN_POS, E_MAX_POS, UNITFDIGITS, ApplyMove, LiveMove);
-  }
-#endif
-
-#if DWIN_PID_TUNE
-  void SetPID(celsius_t t, heater_id_t h) {
-    char cmd[53] = "";
-    char str_1[5] = "", str_2[5] = "";
-    sprintf_P(cmd, PSTR("G28OXY\nG0Z5F300\nG0X%sY%sF5000\nM84\nM400"),
-      dtostrf(X_CENTER, 1, 1, str_1),
-      dtostrf(Y_CENTER, 1, 1, str_2)
-    );
-    gcode.process_subcommands_now(cmd);
-    thermalManager.PID_autotune(t, h, HMI_data.PidCycles, true);
+    const float e_min = current_position.e - (EXTRUDE_MAXLENGTH),
+                e_max = current_position.e + (EXTRUDE_MAXLENGTH);
+    HMI_value.axis = E_AXIS; SetPFloatOnClick(e_min, e_max, UNITFDIGITS, ApplyMove, LiveMove);
   }
-  #if ENABLED(PIDTEMP)
-    void HotendPID() { SetPID(HMI_data.HotendPidT, H_E0); }
-  #endif
-  #if ENABLED(PIDTEMPBED)
-    void BedPID() { SetPID(HMI_data.BedPidT, H_BED); }
-  #endif
 #endif
 
 #if ENABLED(POWER_LOSS_RECOVERY)
   void SetPwrLossr() {
     Toggle_Chkb_Line(recovery.enabled);
     recovery.changed();
   }
 #endif
 
 #if ENABLED(BAUD_RATE_GCODE)
@@ -2203,53 +2230,20 @@ void SetMoveZ() { HMI_value.axis = Z_AXIS; SetPFloatOnClick(Z_MIN_POS, Z_MAX_POS
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   void SetFilLoad()   { SetPFloatOnClick(0, MAX_LOAD_UNLOAD, UNITFDIGITS); }
   void SetFilUnload() { SetPFloatOnClick(0, MAX_LOAD_UNLOAD, UNITFDIGITS); }
 #endif
 
 #if ENABLED(PREVENT_COLD_EXTRUSION)
   void ApplyExtMinT() { thermalManager.extrude_min_temp = HMI_data.ExtMinT; thermalManager.allow_cold_extrude = (HMI_data.ExtMinT == 0); }
   void SetExtMinT() { SetPIntOnClick(MIN_ETEMP, MAX_ETEMP, ApplyExtMinT); }
 #endif
 
-void RestoreDefaultColors() {
-  DWIN_SetColorDefaults();
-  DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color, HMI_data.StatusBg_Color);
-  DWIN_RedrawScreen();
-}
-
-void SelColor() {
-  MenuData.P_Int = (int16_t*)static_cast<MenuItemPtrClass*>(CurrentMenu->SelectedItem())->value;
-  HMI_value.Color[0] = GetRColor(*MenuData.P_Int);  // Red
-  HMI_value.Color[1] = GetGColor(*MenuData.P_Int);  // Green
-  HMI_value.Color[2] = GetBColor(*MenuData.P_Int);  // Blue
-  Draw_GetColor_Menu();
-}
-
-void LiveRGBColor() {
-    HMI_value.Color[CurrentMenu->line() - 2] = MenuData.Value;
-    uint16_t color = RGB(HMI_value.Color[0], HMI_value.Color[1], HMI_value.Color[2]);
-    dwinDrawRectangle(1, color, 20, 315, DWIN_WIDTH - 20, 335);
-}
-void SetRGBColor() {
-  const uint8_t color = static_cast<MenuItemClass*>(CurrentMenu->SelectedItem())->icon;
-  SetIntOnClick(0, (color == 1) ? 63 : 31, HMI_value.Color[color], nullptr, LiveRGBColor);
-}
-
-void DWIN_ApplyColor() {
-  *MenuData.P_Int = RGB(HMI_value.Color[0], HMI_value.Color[1], HMI_value.Color[2]);
-  DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color, HMI_data.StatusBg_Color);
-  Draw_SelectColors_Menu();
-  hash_changed = true;
-  LCD_MESSAGE(MSG_COLORS_APPLIED);
-  DWIN_Draw_Dashboard();
-}
-
 void SetSpeed() { SetPIntOnClick(MIN_PRINT_SPEED, MAX_PRINT_SPEED); }
 
 #if HAS_HOTEND
   void ApplyHotendTemp() { thermalManager.setTargetHotend(MenuData.Value, 0); }
   void SetHotendTemp() { SetIntOnClick(MIN_ETEMP, MAX_ETEMP, thermalManager.degTargetHotend(0), ApplyHotendTemp); }
 #endif
 
 #if HAS_HEATED_BED
   void ApplyBedTemp() { thermalManager.setTargetBed(MenuData.Value); }
   void SetBedTemp() { SetIntOnClick(MIN_BEDTEMP, MAX_BEDTEMP, thermalManager.degTargetBed(), ApplyBedTemp); }
@@ -2285,186 +2279,201 @@ void SetSpeed() { SetPIntOnClick(MIN_PRINT_SPEED, MAX_PRINT_SPEED); }
       queue.inject(F("M701 Z20"));
     }
   #endif
 
 #endif // ADVANCED_PAUSE_FEATURE
 
 void SetFlow() { SetPIntOnClick(MIN_PRINT_FLOW, MAX_PRINT_FLOW, []{ planner.refresh_e_factor(0); }); }
 
 // Bed Tramming
 
-void TramXY(const uint8_t point, const float &margin, float &x, float &y) {
-  switch (point) {
-    case 0:
-      LCD_MESSAGE(MSG_LEVBED_FL);
-      x = y = margin;
-      break;
-    case 1:
-      LCD_MESSAGE(MSG_LEVBED_FR);
-      x = X_BED_SIZE - margin; y = margin;
-      break;
-    case 2:
-      LCD_MESSAGE(MSG_LEVBED_BR);
-      x = X_BED_SIZE - margin; y = Y_BED_SIZE - margin;
-      break;
-    case 3:
-      LCD_MESSAGE(MSG_LEVBED_BL);
-      x = margin; y = Y_BED_SIZE - margin;
-      break;
-    case 4:
-      LCD_MESSAGE(MSG_LEVBED_C);
-      x = X_CENTER; y = Y_CENTER;
-      break;
+#if ENABLED(LCD_BED_TRAMMING)
+
+  void TramXY(const uint8_t point, float &x, float &y) {
+    switch (point) {
+      case 0:
+        LCD_MESSAGE(MSG_TRAM_FL);
+        x = bed_tramming_inset_lfbr[0];
+        y = bed_tramming_inset_lfbr[1];
+        break;
+      case 1:
+        LCD_MESSAGE(MSG_TRAM_FR);
+        x = X_BED_SIZE - bed_tramming_inset_lfbr[2];
+        y = bed_tramming_inset_lfbr[1];
+        break;
+      case 2:
+        LCD_MESSAGE(MSG_TRAM_BR);
+        x = X_BED_SIZE - bed_tramming_inset_lfbr[2];
+        y = Y_BED_SIZE - bed_tramming_inset_lfbr[3];
+        break;
+      case 3:
+        LCD_MESSAGE(MSG_TRAM_BL);
+        x = bed_tramming_inset_lfbr[0];
+        y = Y_BED_SIZE - bed_tramming_inset_lfbr[3];
+        break;
+      #if ENABLED(BED_TRAMMING_INCLUDE_CENTER)
+        case 4:
+          LCD_MESSAGE(MSG_TRAM_C);
+          x = X_CENTER; y = Y_CENTER;
+          break;
+      #endif
+    }
   }
-}
 
-#if HAS_BED_PROBE
+  #if HAS_BED_PROBE
 
-  float Tram(const uint8_t point) {
-    char cmd[100] = "";
-    static bool inLev = false;
-    float xpos = 0, ypos = 0, zval = 0, margin = 0;
-    char str_1[6] = "", str_2[6] = "", str_3[6] = "";
-    if (inLev) return NAN;
-    margin = HMI_data.FullManualTramming ? 30 : PROBING_MARGIN;
-
-    TramXY(point, margin, xpos, ypos);
-
-    if (HMI_data.FullManualTramming) {
-      sprintf_P(cmd, PSTR("M420S0\nG28O\nG90\nG0Z5F300\nG0X%sY%sF5000\nG0Z0F300"),
-        dtostrf(xpos, 1, 1, str_1),
-        dtostrf(ypos, 1, 1, str_2)
-      );
-      queue.inject(cmd);
-    }
-    else {
-      // AUTO_BED_LEVELING_BILINEAR does not define MESH_INSET
-      #ifndef MESH_MIN_X
-        #define MESH_MIN_X (_MAX(X_MIN_BED + PROBING_MARGIN, X_MIN_POS))
-      #endif
-      #ifndef MESH_MIN_Y
-        #define MESH_MIN_Y (_MAX(Y_MIN_BED + PROBING_MARGIN, Y_MIN_POS))
-      #endif
-      #ifndef MESH_MAX_X
-        #define MESH_MAX_X (_MIN(X_MAX_BED - (PROBING_MARGIN), X_MAX_POS))
-      #endif
-      #ifndef MESH_MAX_Y
-        #define MESH_MAX_Y (_MIN(Y_MAX_BED - (PROBING_MARGIN), Y_MAX_POS))
-      #endif
+    float Tram(const uint8_t point) {
+      char cmd[100] = "";
+      static bool inLev = false;
+      float xpos = 0, ypos = 0, zval = 0;
+      char str_1[6] = "", str_2[6] = "", str_3[6] = "";
+      if (inLev) return NAN;
 
-      LIMIT(xpos, MESH_MIN_X, MESH_MAX_X);
-      LIMIT(ypos, MESH_MIN_Y, MESH_MAX_Y);
-      probe.stow();
-      gcode.process_subcommands_now(F("M420S0\nG28O"));
-      inLev = true;
-      zval = probe.probe_at_point(xpos, ypos, PROBE_PT_STOW);
-      if (isnan(zval))
-        LCD_MESSAGE(MSG_ZPROBE_OUT);
-      else {
-        sprintf_P(cmd, PSTR("X:%s, Y:%s, Z:%s"),
+      TramXY(point, xpos, ypos);
+
+      if (HMI_data.FullManualTramming) {
+        sprintf_P(cmd, PSTR("M420S0\nG28O\nG90\nG0Z5F300\nG0X%sY%sF5000\nG0Z0F300"),
           dtostrf(xpos, 1, 1, str_1),
-          dtostrf(ypos, 1, 1, str_2),
-          dtostrf(zval, 1, 2, str_3)
+          dtostrf(ypos, 1, 1, str_2)
         );
-        ui.set_status(cmd);
+        queue.inject(cmd);
+      }
+      else {
+        // AUTO_BED_LEVELING_BILINEAR does not define MESH_INSET
+        #ifndef MESH_MIN_X
+          #define MESH_MIN_X (_MAX(X_MIN_BED + PROBING_MARGIN, X_MIN_POS))
+        #endif
+        #ifndef MESH_MIN_Y
+          #define MESH_MIN_Y (_MAX(Y_MIN_BED + PROBING_MARGIN, Y_MIN_POS))
+        #endif
+        #ifndef MESH_MAX_X
+          #define MESH_MAX_X (_MIN(X_MAX_BED - (PROBING_MARGIN), X_MAX_POS))
+        #endif
+        #ifndef MESH_MAX_Y
+          #define MESH_MAX_Y (_MIN(Y_MAX_BED - (PROBING_MARGIN), Y_MAX_POS))
+        #endif
+
+        LIMIT(xpos, MESH_MIN_X, MESH_MAX_X);
+        LIMIT(ypos, MESH_MIN_Y, MESH_MAX_Y);
+        probe.stow();
+        gcode.process_subcommands_now(F("M420S0\nG28O"));
+        inLev = true;
+        zval = probe.probe_at_point(xpos, ypos, PROBE_PT_STOW);
+        if (isnan(zval))
+          LCD_MESSAGE(MSG_ZPROBE_OUT);
+        else {
+          sprintf_P(cmd, PSTR("X:%s, Y:%s, Z:%s"),
+            dtostrf(xpos, 1, 1, str_1),
+            dtostrf(ypos, 1, 1, str_2),
+            dtostrf(zval, 1, 2, str_3)
+          );
+          ui.set_status(cmd);
+        }
+        inLev = false;
       }
-      inLev = false;
+      return zval;
     }
-    return zval;
-  }
 
-#else
+  #else
 
-  void Tram(const uint8_t point) {
-    float xpos = 0, ypos = 0, margin = 30;
-    TramXY(point, margin, xpos, ypos);
+    void Tram(const uint8_t point) {
+      float xpos = 0, ypos = 0;
+      TramXY(point, xpos, ypos);
 
-    char cmd[100] = "", str_1[6] = "", str_2[6] = "";
-    sprintf_P(cmd, PSTR("M420S0\nG28O\nG90\nG0Z5F300\nG0X%sY%sF5000\nG0Z0F300"), dtostrf(xpos, 1, 1, str_1), dtostrf(ypos, 1, 1, str_2));
-    queue.inject(cmd);
-  }
+      char cmd[100] = "", str_1[6] = "", str_2[6] = "";
+      sprintf_P(cmd, PSTR("M420S0\nG28O\nG90\nG0Z5F300\nG0X%sY%sF5000\nG0Z0F300"), dtostrf(xpos, 1, 1, str_1), dtostrf(ypos, 1, 1, str_2));
+      queue.inject(cmd);
+    }
 
-#endif
+  #endif
 
-void TramFL() { Tram(0); }
-void TramFR() { Tram(1); }
-void TramBR() { Tram(2); }
-void TramBL() { Tram(3); }
-void TramC () { Tram(4); }
+  inline void TramFL() { Tram(0); }
+  inline void TramFR() { Tram(1); }
+  inline void TramBR() { Tram(2); }
+  inline void TramBL() { Tram(3); }
+  #if ENABLED(BED_TRAMMING_INCLUDE_CENTER)
+    inline void TramC() { Tram(4); }
+  #endif
 
-#if HAS_BED_PROBE && HAS_MESH
+  #if HAS_BED_PROBE && HAS_MESH
 
-  void Trammingwizard() {
-    if (HMI_data.FullManualTramming) {
-      LCD_MESSAGE_F("Disable manual tramming");
-      return;
-    }
-    bed_mesh_t zval = {0};
-    zval[0][0] = Tram(0);
-    checkkey = NothingToDo;
-    MeshViewer.DrawMesh(zval, 2, 2);
-    zval[1][0] = Tram(1);
-    MeshViewer.DrawMesh(zval, 2, 2);
-    zval[1][1] = Tram(2);
-    MeshViewer.DrawMesh(zval, 2, 2);
-    zval[0][1] = Tram(3);
-    MeshViewer.DrawMesh(zval, 2, 2);
-
-    DWINUI::Draw_CenteredString(140, F("Calculating average"));
-    DWINUI::Draw_CenteredString(160, F("and relative heights"));
-    safe_delay(1000);
-    float avg = 0.0f;
-    for (uint8_t x = 0; x < 2; ++x) for (uint8_t y = 0; y < 2; ++y) avg += zval[x][y];
-    avg /= 4.0f;
-    for (uint8_t x = 0; x < 2; ++x) for (uint8_t y = 0; y < 2; ++y) zval[x][y] -= avg;
-    MeshViewer.DrawMesh(zval, 2, 2);
-    ui.reset_status();
-
-    if (ABS(MeshViewer.max - MeshViewer.min) < 0.05f) {
-      DWINUI::Draw_CenteredString(140, F("Corners leveled"));
-      DWINUI::Draw_CenteredString(160, F("Tolerance achieved!"));
-    }
-    else {
-      uint8_t p = 0;
-      float max = 0;
-      FSTR_P plabel;
-      bool s = true;
-      for (uint8_t x = 0; x < 2; ++x) for (uint8_t y = 0; y < 2; ++y) {
-        const float d = ABS(zval[x][y]);
-        if (max < d) {
-          s = (zval[x][y] >= 0);
-          max = d;
-          p = x + 2 * y;
-        }
+    void Trammingwizard() {
+      if (HMI_data.FullManualTramming) {
+        LCD_MESSAGE_F("Disable manual tramming");
+        return;
       }
-      switch (p) {
-        case 0b00 : plabel = GET_TEXT_F(MSG_LEVBED_FL); break;
-        case 0b01 : plabel = GET_TEXT_F(MSG_LEVBED_FR); break;
-        case 0b10 : plabel = GET_TEXT_F(MSG_LEVBED_BL); break;
-        case 0b11 : plabel = GET_TEXT_F(MSG_LEVBED_BR); break;
-        default   : plabel = F(""); break;
+      bed_mesh_t zval = {0};
+      zval[0][0] = TramFL();
+      checkkey = NothingToDo;
+      MeshViewer.DrawMesh(zval, 2, 2);
+      zval[1][0] = TramFR();
+      MeshViewer.DrawMesh(zval, 2, 2);
+      zval[1][1] = TramBR();
+      MeshViewer.DrawMesh(zval, 2, 2);
+      zval[0][1] = TramBL();
+      MeshViewer.DrawMesh(zval, 2, 2);
+
+      DWINUI::Draw_CenteredString(140, F("Calculating average"));
+      DWINUI::Draw_CenteredString(160, F("and relative heights"));
+      safe_delay(1000);
+      float avg = 0.0f;
+      for (uint8_t x = 0; x < 2; ++x) for (uint8_t y = 0; y < 2; ++y) avg += zval[x][y];
+      avg /= 4.0f;
+      for (uint8_t x = 0; x < 2; ++x) for (uint8_t y = 0; y < 2; ++y) zval[x][y] -= avg;
+      MeshViewer.DrawMesh(zval, 2, 2);
+      ui.reset_status();
+
+      #ifndef BED_TRAMMING_PROBE_TOLERANCE
+        #define BED_TRAMMING_PROBE_TOLERANCE 0.05
+      #endif
+
+      if (ABS(MeshViewer.max - MeshViewer.min) < BED_TRAMMING_PROBE_TOLERANCE) {
+        DWINUI::Draw_CenteredString(140, F("Corners leveled"));
+        DWINUI::Draw_CenteredString(160, F("Tolerance achieved!"));
       }
-      DWINUI::Draw_CenteredString(120, F("Corners not leveled"));
-      DWINUI::Draw_CenteredString(140, F("Knob adjustment required"));
-      DWINUI::Draw_CenteredString(Color_Green, 160, s ? F("Lower") : F("Raise"));
-      DWINUI::Draw_CenteredString(Color_Green, 180, plabel);
+      else {
+        uint8_t p = 0;
+        float max = 0;
+        FSTR_P plabel;
+        bool s = true;
+        for (uint8_t x = 0; x < 2; ++x) for (uint8_t y = 0; y < 2; ++y) {
+          const float d = ABS(zval[x][y]);
+          if (max < d) {
+            s = (zval[x][y] >= 0);
+            max = d;
+            p = x + 2 * y;
+          }
+        }
+        switch (p) {
+          case 0b00 : plabel = GET_TEXT_F(MSG_TRAM_FL); break;
+          case 0b01 : plabel = GET_TEXT_F(MSG_TRAM_FR); break;
+          case 0b10 : plabel = GET_TEXT_F(MSG_TRAM_BL); break;
+          case 0b11 : plabel = GET_TEXT_F(MSG_TRAM_BR); break;
+          default   : plabel = F(""); break;
+        }
+        DWINUI::Draw_CenteredString(120, F("Corners not leveled"));
+        DWINUI::Draw_CenteredString(140, F("Knob adjustment required"));
+        DWINUI::Draw_CenteredString(Color_Green, 160, s ? F("Lower") : F("Raise"));
+        DWINUI::Draw_CenteredString(Color_Green, 180, plabel);
+      }
+      DWINUI::Draw_Button(BTN_Continue, 86, 305);
+      checkkey = Menu;
+      HMI_SaveProcessID(WaitResponse);
     }
-    DWINUI::Draw_Button(BTN_Continue, 86, 305);
-    checkkey = Menu;
-    HMI_SaveProcessID(WaitResponse);
-  }
 
-  void SetManualTramming() {
-    Toggle_Chkb_Line(HMI_data.FullManualTramming);
-  }
+    void SetManualTramming() {
+      Toggle_Chkb_Line(HMI_data.FullManualTramming);
+    }
 
-#endif // HAS_BED_PROBE && HAS_MESH
+  #endif // HAS_BED_PROBE && HAS_MESH
+
+#endif // LCD_BED_TRAMMING
 
 #if ENABLED(MESH_BED_LEVELING)
 
   void ManualMeshStart() {
     LCD_MESSAGE(MSG_UBL_BUILD_MESH_MENU);
     gcode.process_subcommands_now(F("G28XYO\nG28Z\nM211S0\nG29S1"));
     #ifdef MANUAL_PROBE_START_Z
       const uint8_t line = CurrentMenu->line(MMeshMoveZItem->pos);
       DWINUI::Draw_Signed_Float(HMI_data.Text_Color, HMI_data.Background_Color, 3, 2, VALX - 2 * DWINUI::fontWidth(DWIN_FONT_MENU), MBASE(line), MANUAL_PROBE_START_Z);
     #endif
@@ -2538,64 +2547,41 @@ void ApplyMaxAccel() { planner.set_max_acceleration(HMI_value.axis, MenuData.Val
   #endif
   #if HAS_Y_AXIS
     void SetMaxJerkY() { HMI_value.axis = Y_AXIS, SetFloatOnClick(min_jerk_edit_values.y, max_jerk_edit_values.y, UNITFDIGITS, planner.max_jerk.y, ApplyMaxJerk); }
   #endif
   #if HAS_Z_AXIS
     void SetMaxJerkZ() { HMI_value.axis = Z_AXIS, SetFloatOnClick(min_jerk_edit_values.z, max_jerk_edit_values.z, UNITFDIGITS, planner.max_jerk.z, ApplyMaxJerk); }
   #endif
   #if HAS_HOTEND
     void SetMaxJerkE() { HMI_value.axis = E_AXIS; SetFloatOnClick(min_jerk_edit_values.e, max_jerk_edit_values.e, UNITFDIGITS, planner.max_jerk.e, ApplyMaxJerk); }
   #endif
+#elif HAS_JUNCTION_DEVIATION
+  void ApplyJDmm() { TERN_(LIN_ADVANCE, planner.recalculate_max_e_jerk()); }
+  void SetJDmm() { SetPFloatOnClick(MIN_JD_MM, MAX_JD_MM, 3, ApplyJDmm); }
+#endif
+
+#if ENABLED(LIN_ADVANCE)
+  void SetLA_K() { SetPFloatOnClick(0, 10, 3); }
 #endif
 
 #if HAS_X_AXIS
   void SetStepsX() { HMI_value.axis = X_AXIS, SetPFloatOnClick( min_steps_edit_values.x, max_steps_edit_values.x, UNITFDIGITS); }
 #endif
 #if HAS_Y_AXIS
   void SetStepsY() { HMI_value.axis = Y_AXIS, SetPFloatOnClick( min_steps_edit_values.y, max_steps_edit_values.y, UNITFDIGITS); }
 #endif
 #if HAS_Z_AXIS
   void SetStepsZ() { HMI_value.axis = Z_AXIS, SetPFloatOnClick( min_steps_edit_values.z, max_steps_edit_values.z, UNITFDIGITS); }
 #endif
 #if HAS_HOTEND
   void SetStepsE() { HMI_value.axis = E_AXIS; SetPFloatOnClick( min_steps_edit_values.e, max_steps_edit_values.e, UNITFDIGITS); }
-  #if ENABLED(PIDTEMP)
-    void SetHotendPidT() { SetPIntOnClick(MIN_ETEMP, MAX_ETEMP); }
-  #endif
-#endif
-#if ENABLED(PIDTEMPBED)
-  void SetBedPidT() { SetPIntOnClick(MIN_BEDTEMP, MAX_BEDTEMP); }
-#endif
-
-#if DWIN_PID_TUNE
-  void SetPidCycles() { SetPIntOnClick(3, 50); }
-  void SetKp() { SetPFloatOnClick(0, 1000, 2); }
-  void ApplyPIDi() {
-    *MenuData.P_Float = scalePID_i(MenuData.Value / POW(10, 2));
-    TERN_(PIDTEMP, thermalManager.updatePID());
-  }
-  void ApplyPIDd() {
-    *MenuData.P_Float = scalePID_d(MenuData.Value / POW(10, 2));
-    TERN_(PIDTEMP, thermalManager.updatePID());
-  }
-  void SetKi() {
-    MenuData.P_Float = (float*)static_cast<MenuItemPtrClass*>(CurrentMenu->SelectedItem())->value;
-    const float value = unscalePID_i(*MenuData.P_Float);
-    SetFloatOnClick(0, 1000, 2, value, ApplyPIDi);
-  }
-  void SetKd() {
-    MenuData.P_Float = (float*)static_cast<MenuItemPtrClass*>(CurrentMenu->SelectedItem())->value;
-    const float value = unscalePID_d(*MenuData.P_Float);
-    SetFloatOnClick(0, 1000, 2, value, ApplyPIDd);
-  }
 #endif
-
 #if ENABLED(FWRETRACT)
   void Return_FWRetract_Menu() { (PreviousMenu == FilSetMenu) ? Draw_FilSet_Menu() : Draw_Tune_Menu(); }
   void SetRetractLength() { SetPFloatOnClick( 0, 10, UNITFDIGITS); }
   void SetRetractSpeed()  { SetPFloatOnClick( 1, 90, UNITFDIGITS); }
   void SetZRaise()        { SetPFloatOnClick( 0, 2, 2); }
   void SetRecoverSpeed()  { SetPFloatOnClick( 1, 90, UNITFDIGITS); }
   void SetAddRecover()    { SetPFloatOnClick(-5, 5, UNITFDIGITS); }
 #endif
 
 // Special Menuitem Drawing functions =================================================
@@ -2673,25 +2659,20 @@ void onDrawAutoHome(MenuItemClass* menuitem, int8_t line) {
   if (HMI_IsChinese()) menuitem->SetFrame(1, 0, 89, 41, 101);
   onDrawMenuItem(menuitem, line);
 }
 
 #if HAS_ZOFFSET_ITEM
   #if ANY(BABYSTEP_ZPROBE_OFFSET, JUST_BABYSTEP)
     void onDrawZOffset(MenuItemClass* menuitem, int8_t line) {
       if (HMI_IsChinese()) menuitem->SetFrame(1, 174, 164, 223, 177);
       onDrawPFloat2Menu(menuitem, line);
     }
-  #else
-    void onDrawHomeOffset(MenuItemClass* menuitem, int8_t line) {
-      if (HMI_IsChinese()) menuitem->SetFrame(1, 43, 89, 98, 101);
-      onDrawMenuItem(menuitem, line);
-    }
   #endif
 #endif
 
 #if HAS_HOTEND
   void onDrawPreheat1(MenuItemClass* menuitem, int8_t line) {
     if (HMI_IsChinese()) menuitem->SetFrame(1, 100, 89, 151, 101);
     onDrawMenuItem(menuitem, line);
   }
   #if PREHEAT_COUNT > 1
     void onDrawPreheat2(MenuItemClass* menuitem, int8_t line) {
@@ -2730,25 +2711,20 @@ void onDrawGetColorItem(MenuItemClass* menuitem, int8_t line) {
     case 2: color = RGB(0, 0, 31); break; // Blue
     default: color = 0; break;
   }
   dwinDrawRectangle(0, HMI_data.Highlight_Color, ICOX + 1, MBASE(line) - 1 + 1, ICOX + 18, MBASE(line) - 1 + 18);
   dwinDrawRectangle(1, color, ICOX + 2, MBASE(line) - 1 + 2, ICOX + 17, MBASE(line) - 1 + 17);
   DWINUI::Draw_String(LBLX, MBASE(line) - 1, menuitem->caption);
   Draw_Menu_IntValue(HMI_data.Background_Color, line, 4, HMI_value.Color[i]);
   dwinDrawHLine(HMI_data.SplitLine_Color, 16, MYPOS(line + 1), 240);
 }
 
-#if DWIN_PID_TUNE
-  void onDrawPIDi(MenuItemClass* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, unscalePID_i(*(float*)static_cast<MenuItemPtrClass*>(menuitem)->value)); }
-  void onDrawPIDd(MenuItemClass* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, unscalePID_d(*(float*)static_cast<MenuItemPtrClass*>(menuitem)->value)); }
-#endif
-
 void onDrawSpeedItem(MenuItemClass* menuitem, int8_t line) {
   if (HMI_IsChinese()) menuitem->SetFrame(1, 116, 164, 171, 176);
   onDrawPIntMenu(menuitem, line);
 }
 
 #if HAS_HOTEND
   void onDrawHotendTemp(MenuItemClass* menuitem, int8_t line) {
     if (HMI_IsChinese()) menuitem->SetFrame(1, 1, 134, 56, 146);
     onDrawPIntMenu(menuitem, line);
   }
@@ -3015,70 +2991,76 @@ frame_rect_t selrect(frame_rect_t) {
 }
 
 void Draw_Prepare_Menu() {
   checkkey = Menu;
   if (SET_MENU_R(PrepareMenu, selrect({133, 1, 28, 13}), MSG_PREPARE, 10 + PREHEAT_COUNT)) {
     BACK_ITEM(Goto_Main_Menu);
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
       MENU_ITEM(ICON_FilMan, MSG_FILAMENT_MAN, onDrawSubMenu, Draw_FilamentMan_Menu);
     #endif
     MENU_ITEM(ICON_Axis, MSG_MOVE_AXIS, onDrawMoveSubMenu, Draw_Move_Menu);
-    MENU_ITEM(ICON_Tram, MSG_BED_TRAMMING, onDrawSubMenu, Draw_Tramming_Menu);
+    #if ENABLED(LCD_BED_TRAMMING)
+      MENU_ITEM(ICON_Tram, MSG_BED_TRAMMING, onDrawSubMenu, Draw_Tramming_Menu);
+    #endif
     MENU_ITEM(ICON_CloseMotor, MSG_DISABLE_STEPPERS, onDrawDisableMotors, DisableMotors);
     #if ENABLED(INDIVIDUAL_AXIS_HOMING_SUBMENU)
       MENU_ITEM(ICON_Homing, MSG_HOMING, onDrawSubMenu, Draw_Homing_Menu);
     #else
       MENU_ITEM(ICON_Homing, MSG_AUTO_HOME, onDrawAutoHome, AutoHome);
     #endif
     #if ENABLED(MESH_BED_LEVELING)
       MENU_ITEM(ICON_ManualMesh, MSG_MANUAL_MESH, onDrawSubMenu, Draw_ManualMesh_Menu);
     #elif HAS_BED_PROBE
       MENU_ITEM(ICON_Level, MSG_AUTO_MESH, onDrawMenuItem, AutoLev);
     #endif
     #if HAS_ZOFFSET_ITEM
       #if HAS_BED_PROBE
         MENU_ITEM(ICON_SetZOffset, MSG_PROBE_WIZARD, onDrawSubMenu, Draw_ZOffsetWiz_Menu);
       #elif ENABLED(BABYSTEPPING)
         EDIT_ITEM(ICON_Zoffset, MSG_HOME_OFFSET_Z, onDrawPFloat2Menu, SetZOffset, &BABY_Z_VAR);
-      #elif HAS_HOME_OFFSET
-        MENU_ITEM(ICON_SetHome, MSG_SET_HOME_OFFSETS, onDrawHomeOffset, SetHome);
       #endif
     #endif
     #if HAS_PREHEAT
       #define _ITEM_PREHEAT(N) MENU_ITEM(ICON_Preheat##N, MSG_PREHEAT_##N, onDrawMenuItem, DoPreheat##N);
       REPEAT_1(PREHEAT_COUNT, _ITEM_PREHEAT)
     #endif
     MENU_ITEM(ICON_Cool, MSG_COOLDOWN, onDrawCooldown, DoCoolDown);
     MENU_ITEM(ICON_Language, MSG_UI_LANGUAGE, onDrawLanguage, SetLanguage);
   }
   ui.reset_status(true);
   UpdateMenu(PrepareMenu);
 }
 
-void Draw_Tramming_Menu() {
-  checkkey = Menu;
-  if (SET_MENU(TrammingMenu, MSG_BED_TRAMMING, 8)) {
-    BACK_ITEM(Draw_Prepare_Menu);
-    #if HAS_BED_PROBE && HAS_MESH
-      MENU_ITEM(ICON_ProbeSet, MSG_TRAMMING_WIZARD, onDrawMenuItem, Trammingwizard);
-      EDIT_ITEM(ICON_ProbeSet, MSG_BED_TRAMMING_MANUAL, onDrawChkbMenu, SetManualTramming, &HMI_data.FullManualTramming);
-    #elif !HAS_BED_PROBE && HAS_ZOFFSET_ITEM
-      MENU_ITEM_F(ICON_MoveZ0, "Home Z and disable", onDrawMenuItem, HomeZandDisable);
-    #endif
-    MENU_ITEM(ICON_Axis, MSG_LEVBED_FL, onDrawMenuItem, TramFL);
-    MENU_ITEM(ICON_Axis, MSG_LEVBED_FR, onDrawMenuItem, TramFR);
-    MENU_ITEM(ICON_Axis, MSG_LEVBED_BR, onDrawMenuItem, TramBR);
-    MENU_ITEM(ICON_Axis, MSG_LEVBED_BL, onDrawMenuItem, TramBL);
-    MENU_ITEM(ICON_Axis, MSG_LEVBED_C, onDrawMenuItem, TramC );
+#if ENABLED(LCD_BED_TRAMMING)
+
+  void Draw_Tramming_Menu() {
+    checkkey = Menu;
+    if (SET_MENU(TrammingMenu, MSG_BED_TRAMMING, 8)) {
+      BACK_ITEM(Draw_Prepare_Menu);
+      #if HAS_BED_PROBE && HAS_MESH
+        MENU_ITEM(ICON_ProbeSet, MSG_TRAMMING_WIZARD, onDrawMenuItem, Trammingwizard);
+        EDIT_ITEM(ICON_ProbeSet, MSG_BED_TRAMMING_MANUAL, onDrawChkbMenu, SetManualTramming, &HMI_data.FullManualTramming);
+      #elif !HAS_BED_PROBE && HAS_ZOFFSET_ITEM
+        MENU_ITEM_F(ICON_MoveZ0, "Home Z and disable", onDrawMenuItem, HomeZandDisable);
+      #endif
+      MENU_ITEM(ICON_Axis, MSG_TRAM_FL, onDrawMenuItem, TramFL);
+      MENU_ITEM(ICON_Axis, MSG_TRAM_FR, onDrawMenuItem, TramFR);
+      MENU_ITEM(ICON_Axis, MSG_TRAM_BR, onDrawMenuItem, TramBR);
+      MENU_ITEM(ICON_Axis, MSG_TRAM_BL, onDrawMenuItem, TramBL);
+      #if ENABLED(BED_TRAMMING_INCLUDE_CENTER)
+        MENU_ITEM(ICON_Axis, MSG_TRAM_C, onDrawMenuItem, TramC);
+      #endif
+    }
+    UpdateMenu(TrammingMenu);
   }
-  UpdateMenu(TrammingMenu);
-}
+
+#endif // LCD_BED_TRAMMING
 
 void Draw_Control_Menu() {
   checkkey = Menu;
   if (SET_MENU_R(ControlMenu, selrect({103, 1, 28, 14}), MSG_CONTROL, 10)) {
     BACK_ITEM(Goto_Main_Menu);
     MENU_ITEM(ICON_Temperature, MSG_TEMPERATURE, onDrawTempSubMenu, Draw_Temperature_Menu);
     MENU_ITEM(ICON_Motion, MSG_MOTION, onDrawMotionSubMenu, Draw_Motion_Menu);
     #if ENABLED(EEPROM_SETTINGS)
       MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawWriteEeprom, WriteEeprom);
       MENU_ITEM(ICON_ReadEEPROM, MSG_LOAD_EEPROM, onDrawReadEeprom, ReadEeprom);
@@ -3096,87 +3078,98 @@ void Draw_Control_Menu() {
       MENU_ITEM(ICON_LedControl, MSG_LED_CONTROL, onDrawSubMenu, Draw_LedControl_Menu);
     #endif
     MENU_ITEM(ICON_Info, MSG_INFO_SCREEN, onDrawInfoSubMenu, Goto_Info_Menu);
   }
   ui.reset_status(true);
   UpdateMenu(ControlMenu);
 }
 
 void Draw_AdvancedSettings_Menu() {
   checkkey = Menu;
-  if (SET_MENU(AdvancedSettings, MSG_ADVANCED_SETTINGS, 19)) {
+  if (SET_MENU(AdvancedSettings, MSG_ADVANCED_SETTINGS, 22)) {
     BACK_ITEM(Goto_Main_Menu);
     #if ENABLED(EEPROM_SETTINGS)
       MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawMenuItem, WriteEeprom);
     #endif
     #if HAS_MESH
       MENU_ITEM(ICON_ProbeSet, MSG_MESH_LEVELING, onDrawSubMenu, Draw_MeshSet_Menu);
     #endif
     #if HAS_BED_PROBE
       MENU_ITEM(ICON_ProbeSet, MSG_ZPROBE_SETTINGS, onDrawSubMenu, Draw_ProbeSet_Menu);
     #endif
     MENU_ITEM(ICON_FilSet, MSG_FILAMENT_SET, onDrawSubMenu, Draw_FilSet_Menu);
-    #if ENABLED(PIDTEMP)
+    #if ENABLED(PIDTEMP) && ANY(PID_AUTOTUNE_MENU, PID_EDIT_MENU)
       MENU_ITEM_F(ICON_PIDNozzle, STR_HOTEND_PID " Settings", onDrawSubMenu, Draw_HotendPID_Menu);
     #endif
     #if ANY(MPC_EDIT_MENU, MPC_AUTOTUNE_MENU)
       MENU_ITEM_F(ICON_MPCNozzle, "MPC Settings", onDrawSubMenu, Draw_HotendMPC_Menu);
     #endif
-    #if ENABLED(PIDTEMPBED)
+    #if ENABLED(PIDTEMPBED) && ANY(PID_AUTOTUNE_MENU, PID_EDIT_MENU)
       MENU_ITEM_F(ICON_PIDBed, STR_BED_PID " Settings", onDrawSubMenu, Draw_BedPID_Menu);
     #endif
+    #if HAS_TRINAMIC_CONFIG
+      MENU_ITEM(ICON_TMCSet, MSG_TMC_DRIVERS, onDrawSubMenu, Draw_TrinamicConfig_menu);
+    #endif
     #if HAS_ESDIAG
       MENU_ITEM_F(ICON_ESDiag, "End-stops diag.", onDrawSubMenu, Draw_EndStopDiag);
     #endif
     #if ENABLED(PRINTCOUNTER)
       MENU_ITEM(ICON_PrintStats, MSG_INFO_STATS_MENU, onDrawSubMenu, Goto_PrintStats);
       MENU_ITEM(ICON_PrintStatsReset, MSG_INFO_PRINT_COUNT_RESET, onDrawSubMenu, PrintStatsReset);
     #endif
     #if HAS_LOCKSCREEN
       MENU_ITEM(ICON_Lock, MSG_LOCKSCREEN, onDrawMenuItem, DWIN_LockScreen);
     #endif
     #if ENABLED(SOUND_MENU_ITEM)
       EDIT_ITEM(ICON_Sound, MSG_SOUND_ENABLE, onDrawChkbMenu, SetEnableSound, &ui.sound_on);
     #endif
     #if ENABLED(POWER_LOSS_RECOVERY)
       EDIT_ITEM(ICON_Pwrlossr, MSG_OUTAGE_RECOVERY, onDrawChkbMenu, SetPwrLossr, &recovery.enabled);
     #endif
+    #if HAS_GCODE_PREVIEW
+      EDIT_ITEM(ICON_File, MSG_HAS_PREVIEW, onDrawChkbMenu, SetPreview, &HMI_data.EnablePreview);
+    #endif
+    #if ENABLED(MEDIASORT_MENU_ITEM)
+      EDIT_ITEM(ICON_File, MSG_MEDIA_SORT, onDrawChkbMenu, SetMediaSort, &HMI_data.MediaSort);
+    #endif
     EDIT_ITEM(ICON_File, MSG_MEDIA_UPDATE, onDrawChkbMenu, SetMediaAutoMount, &HMI_data.MediaAutoMount);
     #if ENABLED(BAUD_RATE_GCODE)
       EDIT_ITEM_F(ICON_SetBaudRate, "115K baud", onDrawChkbMenu, SetBaudRate, &HMI_data.Baud115K);
     #endif
     #if HAS_LCD_BRIGHTNESS
       EDIT_ITEM(ICON_Brightness, MSG_BRIGHTNESS, onDrawPInt8Menu, SetBrightness, &ui.brightness);
       MENU_ITEM(ICON_Brightness, MSG_BRIGHTNESS_OFF, onDrawMenuItem, TurnOffBacklight);
     #endif
-    MENU_ITEM(ICON_Scolor, MSG_COLORS_SELECT, onDrawSubMenu, Draw_SelectColors_Menu);
+    #if HAS_CUSTOM_COLORS
+      MENU_ITEM(ICON_Scolor, MSG_COLORS_SELECT, onDrawSubMenu, Draw_SelectColors_Menu);
+    #endif
   }
   ui.reset_status(true);
   UpdateMenu(AdvancedSettings);
 }
 
 void Draw_Move_Menu() {
   checkkey = Menu;
   if (SET_MENU_R(MoveMenu, selrect({192, 1, 42, 14}), MSG_MOVE_AXIS, 6)) {
     BACK_ITEM(Draw_Prepare_Menu);
     EDIT_ITEM(ICON_Axis, MSG_LIVE_MOVE, onDrawChkbMenu, SetLiveMove, &EnableLiveMove);
     #if HAS_X_AXIS
       EDIT_ITEM(ICON_MoveX, MSG_MOVE_X, onDrawMoveX, SetMoveX, &current_position.x);
     #endif
     #if HAS_Y_AXIS
       EDIT_ITEM(ICON_MoveY, MSG_MOVE_Y, onDrawMoveY, SetMoveY, &current_position.y);
     #endif
     #if HAS_Z_AXIS
       EDIT_ITEM(ICON_MoveZ, MSG_MOVE_Z, onDrawMoveZ, SetMoveZ, &current_position.z);
     #endif
     #if HAS_HOTEND
-      gcode.process_subcommands_now(F("G92E0"));  // reset extruder position
+      gcode.process_subcommands_now(F("G92E0"));  // Reset extruder position
       EDIT_ITEM(ICON_Extruder, MSG_MOVE_E, onDrawMoveE, SetMoveE, &current_position.e);
     #endif
   }
   UpdateMenu(MoveMenu);
   if (!all_axes_trusted()) LCD_MESSAGE_F("WARNING: Current position unknown. Home axes.");
 }
 
 #if HAS_HOME_OFFSET
 
   void Draw_HomeOffset_Menu() {
@@ -3189,21 +3182,21 @@ void Draw_Move_Menu() {
       #if HAS_Y_AXIS
         EDIT_ITEM(ICON_HomeOffsetY, MSG_HOME_OFFSET_Y, onDrawPFloatMenu, SetHomeOffsetY, &home_offset.y);
       #endif
       #if HAS_Z_AXIS
         EDIT_ITEM(ICON_HomeOffsetZ, MSG_HOME_OFFSET_Z, onDrawPFloatMenu, SetHomeOffsetZ, &home_offset.z);
       #endif
     }
     UpdateMenu(HomeOffMenu);
   }
 
-#endif
+#endif // HAS_HOME_OFFSET
 
 #if HAS_BED_PROBE
 
   void Draw_ProbeSet_Menu() {
     checkkey = Menu;
     if (SET_MENU(ProbeSetMenu, MSG_ZPROBE_SETTINGS, 9)) {
       BACK_ITEM(Draw_AdvancedSettings_Menu);
       #if HAS_X_AXIS
         EDIT_ITEM(ICON_ProbeOffsetX, MSG_ZPROBE_XOFFSET, onDrawPFloatMenu, SetProbeOffsetX, &probe.offset.x);
       #endif
@@ -3219,21 +3212,21 @@ void Draw_Move_Menu() {
         MENU_ITEM(ICON_BltouchReset, MSG_BLTOUCH_RESET, onDrawMenuItem, bltouch._reset);
         #if HAS_BLTOUCH_HS_MODE
           EDIT_ITEM(ICON_HSMode, MSG_ENABLE_HS_MODE, onDrawChkbMenu, SetHSMode, &bltouch.high_speed_mode);
         #endif
       #endif
       MENU_ITEM(ICON_ProbeTest, MSG_M48_TEST, onDrawMenuItem, ProbeTest);
     }
     UpdateMenu(ProbeSetMenu);
   }
 
-#endif
+#endif // HAS_BED_PROBE
 
 void Draw_FilSet_Menu() {
   checkkey = Menu;
   if (SET_MENU(FilSetMenu, MSG_FILAMENT_SET, 9)) {
     BACK_ITEM(Draw_AdvancedSettings_Menu);
     #if HAS_FILAMENT_SENSOR
       EDIT_ITEM(ICON_Runout, MSG_RUNOUT_ENABLE, onDrawChkbMenu, SetRunoutEnable, &runout.enabled);
     #endif
     #if HAS_FILAMENT_RUNOUT_DISTANCE
       EDIT_ITEM(ICON_Runout, MSG_RUNOUT_DISTANCE_MM, onDrawPFloatMenu, SetRunoutDistance, &runout.runout_distance());
@@ -3245,60 +3238,20 @@ void Draw_FilSet_Menu() {
       EDIT_ITEM(ICON_FilLoad, MSG_FILAMENT_LOAD, onDrawPFloatMenu, SetFilLoad, &fc_settings[0].load_length);
       EDIT_ITEM(ICON_FilUnload, MSG_FILAMENT_UNLOAD, onDrawPFloatMenu, SetFilUnload, &fc_settings[0].unload_length);
     #endif
     #if ENABLED(FWRETRACT)
       MENU_ITEM(ICON_FWRetract, MSG_FWRETRACT, onDrawSubMenu, Draw_FWRetract_Menu);
     #endif
   }
   UpdateMenu(FilSetMenu);
 }
 
-void Draw_SelectColors_Menu() {
-  checkkey = Menu;
-  if (SET_MENU(SelectColorMenu, MSG_COLORS_SELECT, 20)) {
-    BACK_ITEM(Draw_AdvancedSettings_Menu);
-    MENU_ITEM(ICON_StockConfiguration, MSG_RESTORE_DEFAULTS, onDrawMenuItem, RestoreDefaultColors);
-    EDIT_ITEM_F(0, "Screen Background", onDrawSelColorItem, SelColor, &HMI_data.Background_Color);
-    EDIT_ITEM_F(0, "Cursor", onDrawSelColorItem, SelColor, &HMI_data.Cursor_Color);
-    EDIT_ITEM_F(0, "Title Background", onDrawSelColorItem, SelColor, &HMI_data.TitleBg_Color);
-    EDIT_ITEM_F(0, "Title Text", onDrawSelColorItem, SelColor, &HMI_data.TitleTxt_Color);
-    EDIT_ITEM_F(0, "Text", onDrawSelColorItem, SelColor, &HMI_data.Text_Color);
-    EDIT_ITEM_F(0, "Selected", onDrawSelColorItem, SelColor, &HMI_data.Selected_Color);
-    EDIT_ITEM_F(0, "Split Line", onDrawSelColorItem, SelColor, &HMI_data.SplitLine_Color);
-    EDIT_ITEM_F(0, "Highlight", onDrawSelColorItem, SelColor, &HMI_data.Highlight_Color);
-    EDIT_ITEM_F(0, "Status Background", onDrawSelColorItem, SelColor, &HMI_data.StatusBg_Color);
-    EDIT_ITEM_F(0, "Status Text", onDrawSelColorItem, SelColor, &HMI_data.StatusTxt_Color);
-    EDIT_ITEM_F(0, "Popup Background", onDrawSelColorItem, SelColor, &HMI_data.PopupBg_Color);
-    EDIT_ITEM_F(0, "Popup Text", onDrawSelColorItem, SelColor, &HMI_data.PopupTxt_Color);
-    EDIT_ITEM_F(0, "Alert Background", onDrawSelColorItem, SelColor, &HMI_data.AlertBg_Color);
-    EDIT_ITEM_F(0, "Alert Text", onDrawSelColorItem, SelColor, &HMI_data.AlertTxt_Color);
-    EDIT_ITEM_F(0, "Percent Text", onDrawSelColorItem, SelColor, &HMI_data.PercentTxt_Color);
-    EDIT_ITEM_F(0, "Bar Fill", onDrawSelColorItem, SelColor, &HMI_data.Barfill_Color);
-    EDIT_ITEM_F(0, "Indicator value", onDrawSelColorItem, SelColor, &HMI_data.Indicator_Color);
-    EDIT_ITEM_F(0, "Coordinate value", onDrawSelColorItem, SelColor, &HMI_data.Coordinate_Color);
-  }
-  UpdateMenu(SelectColorMenu);
-}
-
-void Draw_GetColor_Menu() {
-  checkkey = Menu;
-  if (SET_MENU(GetColorMenu, MSG_COLORS_GET, 5)) {
-    BACK_ITEM(DWIN_ApplyColor);
-    MENU_ITEM(ICON_Cancel, MSG_BUTTON_CANCEL, onDrawMenuItem, Draw_SelectColors_Menu);
-    MENU_ITEM(0, MSG_COLORS_RED, onDrawGetColorItem, SetRGBColor);
-    MENU_ITEM(1, MSG_COLORS_GREEN, onDrawGetColorItem, SetRGBColor);
-    MENU_ITEM(2, MSG_COLORS_BLUE, onDrawGetColorItem, SetRGBColor);
-  }
-  UpdateMenu(GetColorMenu);
-  dwinDrawRectangle(1, *MenuData.P_Int, 20, 315, DWIN_WIDTH - 20, 335);
-}
-
 #if ALL(CASE_LIGHT_MENU, CASELIGHT_USES_BRIGHTNESS)
 
   void Draw_CaseLight_Menu() {
     checkkey = Menu;
     if (SET_MENU(CaseLightMenu, MSG_CASE_LIGHT, 3)) {
       BACK_ITEM(Draw_Control_Menu);
       EDIT_ITEM(ICON_CaseLight, MSG_CASE_LIGHT, onDrawChkbMenu, SetCaseLight, &caselight.on);
       EDIT_ITEM(ICON_Brightness, MSG_CASE_LIGHT_BRIGHTNESS, onDrawPInt8Menu, SetCaseLightBrightness, &caselight.brightness);
     }
     UpdateMenu(CaseLightMenu);
@@ -3335,87 +3288,199 @@ void Draw_GetColor_Menu() {
         #endif
       #endif
     }
     UpdateMenu(LedControlMenu);
   }
 
 #endif // LED_CONTROL_MENU
 
 void Draw_Tune_Menu() {
   checkkey = Menu;
-  if (SET_MENU_R(TuneMenu, selrect({73, 2, 28, 12}), MSG_TUNE, 14)) {
+  if (SET_MENU_R(TuneMenu, selrect({73, 2, 28, 12}), MSG_TUNE, 17)) {
     BACK_ITEM(Goto_PrintProcess);
     EDIT_ITEM(ICON_Speed, MSG_SPEED, onDrawSpeedItem, SetSpeed, &feedrate_percentage);
     #if HAS_HOTEND
       HotendTargetItem = EDIT_ITEM(ICON_HotendTemp, MSG_UBL_SET_TEMP_HOTEND, onDrawHotendTemp, SetHotendTemp, &thermalManager.temp_hotend[0].target);
     #endif
     #if HAS_HEATED_BED
       BedTargetItem = EDIT_ITEM(ICON_BedTemp, MSG_UBL_SET_TEMP_BED, onDrawBedTemp, SetBedTemp, &thermalManager.temp_bed.target);
     #endif
     #if HAS_FAN
       FanSpeedItem = EDIT_ITEM(ICON_FanSpeed, MSG_FAN_SPEED, onDrawFanSpeed, SetFanSpeed, &thermalManager.fan_speed[0]);
     #endif
-    #if ALL(HAS_ZOFFSET_ITEM, HAS_BED_PROBE, BABYSTEPPING)
+    #if ALL(HAS_ZOFFSET_ITEM, HAS_BED_PROBE, BABYSTEP_ZPROBE_OFFSET, BABYSTEPPING)
       EDIT_ITEM(ICON_Zoffset, MSG_ZPROBE_ZOFFSET, onDrawZOffset, SetZOffset, &BABY_Z_VAR);
     #elif ALL(HAS_ZOFFSET_ITEM, MESH_BED_LEVELING, BABYSTEPPING)
       EDIT_ITEM(ICON_Zoffset, MSG_HOME_OFFSET_Z, onDrawPFloat2Menu, SetZOffset, &BABY_Z_VAR);
     #endif
     EDIT_ITEM(ICON_Flow, MSG_FLOW, onDrawPIntMenu, SetFlow, &planner.flow_percentage[0]);
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
       MENU_ITEM(ICON_FilMan, MSG_FILAMENTCHANGE, onDrawMenuItem, ChangeFilament);
     #endif
     #if HAS_FILAMENT_SENSOR
       EDIT_ITEM(ICON_Runout, MSG_RUNOUT_ENABLE, onDrawChkbMenu, SetRunoutEnable, &runout.enabled);
     #endif
+    #if ENABLED(PLR_TUNE_ITEM)
+      EDIT_ITEM(ICON_Pwrlossr, MSG_OUTAGE_RECOVERY, onDrawChkbMenu, SetPwrLossr, &recovery.enabled);
+    #endif
     #if ENABLED(FWRETRACT)
       MENU_ITEM(ICON_FWRetract, MSG_FWRETRACT, onDrawSubMenu, Draw_FWRetract_Menu);
     #endif
+    #if ENABLED(JD_TUNE_ITEM)
+      EDIT_ITEM(ICON_JDmm, MSG_JUNCTION_DEVIATION, onDrawPFloat3Menu, SetJDmm, &planner.junction_deviation_mm);
+    #endif
+    #if ENABLED(ADVK_TUNE_ITEM)
+      EDIT_ITEM(ICON_MaxAccelerated, MSG_ADVANCE_K, onDrawPFloat3Menu, SetLA_K, &planner.extruder_advance_K[0]);
+    #endif
     #if HAS_LOCKSCREEN
       MENU_ITEM(ICON_Lock, MSG_LOCKSCREEN, onDrawMenuItem, DWIN_LockScreen);
     #endif
     #if HAS_LCD_BRIGHTNESS
       EDIT_ITEM(ICON_Brightness, MSG_BRIGHTNESS, onDrawPInt8Menu, SetBrightness, &ui.brightness);
       MENU_ITEM(ICON_Brightness, MSG_BRIGHTNESS_OFF, onDrawMenuItem, TurnOffBacklight);
     #endif
     #if ENABLED(CASE_LIGHT_MENU)
       EDIT_ITEM(ICON_CaseLight, MSG_CASE_LIGHT, onDrawChkbMenu, SetCaseLight, &caselight.on);
     #elif ENABLED(LED_CONTROL_MENU) && DISABLED(CASE_LIGHT_USE_NEOPIXEL)
       EDIT_ITEM(ICON_LedControl, MSG_LEDS, onDrawChkbMenu, SetLedStatus, &leds.lights_on);
     #endif
   }
   UpdateMenu(TuneMenu);
 }
 
+#if ENABLED(ADAPTIVE_STEP_SMOOTHING)
+  void SetAdaptiveStepSmoothing() {
+    Toggle_Chkb_Line(HMI_data.AdaptiveStepSmoothing);
+  }
+#endif
+
+#if ENABLED(SHAPING_MENU)
+  void ApplyShapingFreq() { stepper.set_shaping_frequency(HMI_value.axis, MenuData.Value / 100); }
+  void ApplyShapingZeta() { stepper.set_shaping_damping_ratio(HMI_value.axis, MenuData.Value / 100); }
+
+  #if ENABLED(INPUT_SHAPING_X)
+    void onDrawShapingXFreq(MenuItemClass* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, stepper.get_shaping_frequency(X_AXIS)); }
+    void onDrawShapingXZeta(MenuItemClass* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, stepper.get_shaping_damping_ratio(X_AXIS)); }
+    void SetShapingXFreq() { HMI_value.axis = X_AXIS; SetFloatOnClick(0, 200, 2, stepper.get_shaping_frequency(X_AXIS), ApplyShapingFreq); }
+    void SetShapingXZeta() { HMI_value.axis = X_AXIS; SetFloatOnClick(0, 1, 2, stepper.get_shaping_damping_ratio(X_AXIS), ApplyShapingZeta); }
+  #endif
+
+  #if ENABLED(INPUT_SHAPING_Y)
+    void onDrawShapingYFreq(MenuItemClass* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, stepper.get_shaping_frequency(Y_AXIS)); }
+    void onDrawShapingYZeta(MenuItemClass* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, stepper.get_shaping_damping_ratio(Y_AXIS)); }
+    void SetShapingYFreq() { HMI_value.axis = Y_AXIS; SetFloatOnClick(0, 200, 2, stepper.get_shaping_frequency(Y_AXIS), ApplyShapingFreq); }
+    void SetShapingYZeta() { HMI_value.axis = Y_AXIS; SetFloatOnClick(0, 1, 2, stepper.get_shaping_damping_ratio(Y_AXIS), ApplyShapingZeta); }
+  #endif
+
+  void Draw_InputShaping_menu() {
+    checkkey = Menu;
+    if (SET_MENU(InputShapingMenu, MSG_INPUT_SHAPING, 5)) {
+      BACK_ITEM(Draw_Motion_Menu);
+      #if ENABLED(INPUT_SHAPING_X)
+        MENU_ITEM(ICON_ShapingX, MSG_SHAPING_A_FREQ, onDrawShapingXFreq, SetShapingXFreq);
+        MENU_ITEM(ICON_ShapingX, MSG_SHAPING_A_ZETA, onDrawShapingXZeta, SetShapingXZeta);
+      #endif
+      #if ENABLED(INPUT_SHAPING_Y)
+        MENU_ITEM(ICON_ShapingY, MSG_SHAPING_B_FREQ, onDrawShapingYFreq, SetShapingYFreq);
+        MENU_ITEM(ICON_ShapingY, MSG_SHAPING_B_ZETA, onDrawShapingYZeta, SetShapingYZeta);
+      #endif
+    }
+    UpdateMenu(InputShapingMenu);
+  }
+#endif
+
+#if HAS_TRINAMIC_CONFIG
+  #if AXIS_IS_TMC(X)
+    void SetXTMCCurrent() { SetPIntOnClick(MIN_TMC_CURRENT, MAX_TMC_CURRENT, []{ stepperX.refresh_stepper_current(); }); }
+  #endif
+  #if AXIS_IS_TMC(Y)
+    void SetYTMCCurrent() { SetPIntOnClick(MIN_TMC_CURRENT, MAX_TMC_CURRENT, []{ stepperY.refresh_stepper_current(); }); }
+  #endif
+  #if AXIS_IS_TMC(Z)
+    void SetZTMCCurrent() { SetPIntOnClick(MIN_TMC_CURRENT, MAX_TMC_CURRENT, []{ stepperZ.refresh_stepper_current(); }); }
+  #endif
+  #if AXIS_IS_TMC(E0)
+    void SetETMCCurrent() { SetPIntOnClick(MIN_TMC_CURRENT, MAX_TMC_CURRENT, []{ stepperE0.refresh_stepper_current(); }); }
+  #endif
+
+  void Draw_TrinamicConfig_menu() {
+    checkkey = Menu;
+    if (SET_MENU(TrinamicConfigMenu, MSG_TMC_DRIVERS, 5)) {
+      BACK_ITEM(Draw_AdvancedSettings_Menu);
+      #if AXIS_IS_TMC(X)
+        EDIT_ITEM(ICON_TMCXSet, MSG_TMC_ACURRENT, onDrawPIntMenu, SetXTMCCurrent, &stepperX.val_mA);
+      #endif
+      #if AXIS_IS_TMC(Y)
+        EDIT_ITEM(ICON_TMCYSet, MSG_TMC_BCURRENT, onDrawPIntMenu, SetYTMCCurrent, &stepperY.val_mA);
+      #endif
+      #if AXIS_IS_TMC(Z)
+        EDIT_ITEM(ICON_TMCZSet, MSG_TMC_CCURRENT, onDrawPIntMenu, SetZTMCCurrent, &stepperZ.val_mA);
+      #endif
+      #if AXIS_IS_TMC(E0)
+        EDIT_ITEM(ICON_TMCESet, MSG_TMC_ECURRENT, onDrawPIntMenu, SetETMCCurrent, &stepperE0.val_mA);
+      #endif
+    }
+    UpdateMenu(TrinamicConfigMenu);
+  }
+#endif
+
 void Draw_Motion_Menu() {
   checkkey = Menu;
-  if (SET_MENU_R(MotionMenu, selrect({1, 16, 28, 13}), MSG_MOTION, 6)) {
+  if (SET_MENU_R(MotionMenu, selrect({1, 16, 28, 13}), MSG_MOTION, 10)) {
     BACK_ITEM(Draw_Control_Menu);
     MENU_ITEM(ICON_MaxSpeed, MSG_SPEED, onDrawSpeed, Draw_MaxSpeed_Menu);
     MENU_ITEM(ICON_MaxAccelerated, MSG_ACCELERATION, onDrawAcc, Draw_MaxAccel_Menu);
     #if HAS_CLASSIC_JERK
       MENU_ITEM(ICON_MaxJerk, MSG_JERK, onDrawJerk, Draw_MaxJerk_Menu);
+    #elif HAS_JUNCTION_DEVIATION
+      EDIT_ITEM(ICON_JDmm, MSG_JUNCTION_DEVIATION, onDrawPFloat3Menu, SetJDmm, &planner.junction_deviation_mm);
+    #endif
+    #if ENABLED(LIN_ADVANCE)
+      EDIT_ITEM(ICON_MaxAccelerated, MSG_ADVANCE_K, onDrawPFloat3Menu, SetLA_K, &planner.extruder_advance_K[0]);
+    #endif
+    #if ENABLED(SHAPING_MENU)
+      MENU_ITEM(ICON_InputShaping, MSG_INPUT_SHAPING, onDrawSubMenu, Draw_InputShaping_menu);
+    #endif
+    #if ENABLED(ADAPTIVE_STEP_SMOOTHING)
+      EDIT_ITEM(ICON_UBLActive, MSG_STEP_SMOOTHING, onDrawChkbMenu, SetAdaptiveStepSmoothing, &HMI_data.AdaptiveStepSmoothing);
     #endif
     MENU_ITEM(ICON_Step, MSG_STEPS_PER_MM, onDrawSteps, Draw_Steps_Menu);
     EDIT_ITEM(ICON_Flow, MSG_FLOW, onDrawPIntMenu, SetFlow, &planner.flow_percentage[0]);
+    EDIT_ITEM(ICON_Speed, MSG_SPEED, onDrawPIntMenu, SetSpeed, &feedrate_percentage);
   }
   UpdateMenu(MotionMenu);
 }
 
+#if HAS_PREHEAT
+  void Draw_PreheatHotend_Menu() {
+    checkkey = Menu;
+    if (SET_MENU(PreheatHotendMenu, MSG_PREHEAT_HOTEND, 1 + PREHEAT_COUNT)) {
+      BACK_ITEM(Draw_FilamentMan_Menu);
+      #define _ITEM_PREHEAT_HE(N) MENU_ITEM(ICON_Preheat##N, MSG_PREHEAT_##N, onDrawMenuItem, DoPreheatHotend##N);
+      REPEAT_1(PREHEAT_COUNT, _ITEM_PREHEAT_HE)
+    }
+    UpdateMenu(PreheatHotendMenu);
+  }
+#endif
+
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
 
   void Draw_FilamentMan_Menu() {
     checkkey = Menu;
-    if (SET_MENU(FilamentMenu, MSG_FILAMENT_MAN, 5)) {
+    if (SET_MENU(FilamentMenu, MSG_FILAMENT_MAN, 6)) {
       BACK_ITEM(Draw_Prepare_Menu);
       #if ENABLED(NOZZLE_PARK_FEATURE)
         MENU_ITEM(ICON_Park, MSG_FILAMENT_PARK_ENABLED, onDrawMenuItem, ParkHead);
       #endif
+      #if HAS_PREHEAT
+        MENU_ITEM(ICON_SetEndTemp, MSG_PREHEAT_HOTEND, onDrawSubMenu, Draw_PreheatHotend_Menu);
+      #endif
       MENU_ITEM(ICON_FilMan, MSG_FILAMENTCHANGE, onDrawMenuItem, ChangeFilament);
       #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
         MENU_ITEM(ICON_FilUnload, MSG_FILAMENTUNLOAD, onDrawMenuItem, UnloadFilament);
         MENU_ITEM(ICON_FilLoad, MSG_FILAMENTLOAD, onDrawMenuItem, LoadFilament);
       #endif
     }
     UpdateMenu(FilamentMenu);
   }
 
 #endif
@@ -3566,101 +3631,243 @@ void Draw_Steps_Menu() {
     #if HAS_Z_AXIS
       EDIT_ITEM(ICON_StepZ, MSG_C_STEPS, onDrawStepsZ, SetStepsZ, &planner.settings.axis_steps_per_mm[Z_AXIS]);
     #endif
     #if HAS_HOTEND
       EDIT_ITEM(ICON_StepE, MSG_E_STEPS, onDrawStepsE, SetStepsE, &planner.settings.axis_steps_per_mm[E_AXIS]);
     #endif
   }
   UpdateMenu(StepsMenu);
 }
 
-#if ENABLED(PIDTEMP)
+//=============================================================================
+// UI editable custom colors
+//=============================================================================
 
-  void Draw_HotendPID_Menu() {
+#if HAS_CUSTOM_COLORS
+
+  void RestoreDefaultColors() {
+    DWIN_SetColorDefaults();
+    DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color, HMI_data.StatusBg_Color);
+    DWIN_RedrawScreen();
+  }
+
+  void SelColor() {
+    MenuData.P_Int = (int16_t*)static_cast<MenuItemPtrClass*>(CurrentMenu->SelectedItem())->value;
+    HMI_value.Color[0] = GetRColor(*MenuData.P_Int);  // Red
+    HMI_value.Color[1] = GetGColor(*MenuData.P_Int);  // Green
+    HMI_value.Color[2] = GetBColor(*MenuData.P_Int);  // Blue
+    Draw_GetColor_Menu();
+  }
+
+  void LiveRGBColor() {
+    HMI_value.Color[CurrentMenu->line() - 2] = MenuData.Value;
+    uint16_t color = RGB(HMI_value.Color[0], HMI_value.Color[1], HMI_value.Color[2]);
+    dwinDrawRectangle(1, color, 20, 315, DWIN_WIDTH - 20, 335);
+  }
+  void SetRGBColor() {
+    const uint8_t color = static_cast<MenuItemClass*>(CurrentMenu->SelectedItem())->icon;
+    SetIntOnClick(0, (color == 1) ? 63 : 31, HMI_value.Color[color], nullptr, LiveRGBColor);
+  }
+
+  void DWIN_ApplyColor() {
+    *MenuData.P_Int = RGB(HMI_value.Color[0], HMI_value.Color[1], HMI_value.Color[2]);
+    DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color, HMI_data.StatusBg_Color);
+    Draw_SelectColors_Menu();
+    hash_changed = true;
+    LCD_MESSAGE(MSG_COLORS_APPLIED);
+    DWIN_Draw_Dashboard();
+  }
+
+  void Draw_SelectColors_Menu() {
     checkkey = Menu;
-    if (SET_MENU_F(HotendPIDMenu, STR_HOTEND_PID " Settings", 8)) {
+    if (SET_MENU(SelectColorMenu, MSG_COLORS_SELECT, 20)) {
       BACK_ITEM(Draw_AdvancedSettings_Menu);
-      MENU_ITEM_F(ICON_PIDNozzle, STR_HOTEND_PID, onDrawMenuItem, HotendPID);
-      EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KP, onDrawPFloat2Menu, SetKp, &thermalManager.temp_hotend[0].pid.Kp);
-      EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KI, onDrawPIDi, SetKi, &thermalManager.temp_hotend[0].pid.Ki);
-      EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KD, onDrawPIDd, SetKd, &thermalManager.temp_hotend[0].pid.Kd);
-      EDIT_ITEM(ICON_Temperature, MSG_TEMPERATURE, onDrawPIntMenu, SetHotendPidT, &HMI_data.HotendPidT);
-      EDIT_ITEM(ICON_PIDCycles, MSG_PID_CYCLE, onDrawPIntMenu, SetPidCycles, &HMI_data.PidCycles);
-      #if ENABLED(EEPROM_SETTINGS)
-        MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawMenuItem, WriteEeprom);
-      #endif
+      MENU_ITEM(ICON_StockConfiguration, MSG_RESTORE_DEFAULTS, onDrawMenuItem, RestoreDefaultColors);
+      EDIT_ITEM_F(0, "Screen Background", onDrawSelColorItem, SelColor, &HMI_data.Background_Color);
+      EDIT_ITEM_F(0, "Cursor", onDrawSelColorItem, SelColor, &HMI_data.Cursor_Color);
+      EDIT_ITEM_F(0, "Title Background", onDrawSelColorItem, SelColor, &HMI_data.TitleBg_Color);
+      EDIT_ITEM_F(0, "Title Text", onDrawSelColorItem, SelColor, &HMI_data.TitleTxt_Color);
+      EDIT_ITEM_F(0, "Text", onDrawSelColorItem, SelColor, &HMI_data.Text_Color);
+      EDIT_ITEM_F(0, "Selected", onDrawSelColorItem, SelColor, &HMI_data.Selected_Color);
+      EDIT_ITEM_F(0, "Split Line", onDrawSelColorItem, SelColor, &HMI_data.SplitLine_Color);
+      EDIT_ITEM_F(0, "Highlight", onDrawSelColorItem, SelColor, &HMI_data.Highlight_Color);
+      EDIT_ITEM_F(0, "Status Background", onDrawSelColorItem, SelColor, &HMI_data.StatusBg_Color);
+      EDIT_ITEM_F(0, "Status Text", onDrawSelColorItem, SelColor, &HMI_data.StatusTxt_Color);
+      EDIT_ITEM_F(0, "Popup Background", onDrawSelColorItem, SelColor, &HMI_data.PopupBg_Color);
+      EDIT_ITEM_F(0, "Popup Text", onDrawSelColorItem, SelColor, &HMI_data.PopupTxt_Color);
+      EDIT_ITEM_F(0, "Alert Background", onDrawSelColorItem, SelColor, &HMI_data.AlertBg_Color);
+      EDIT_ITEM_F(0, "Alert Text", onDrawSelColorItem, SelColor, &HMI_data.AlertTxt_Color);
+      EDIT_ITEM_F(0, "Percent Text", onDrawSelColorItem, SelColor, &HMI_data.PercentTxt_Color);
+      EDIT_ITEM_F(0, "Bar Fill", onDrawSelColorItem, SelColor, &HMI_data.Barfill_Color);
+      EDIT_ITEM_F(0, "Indicator value", onDrawSelColorItem, SelColor, &HMI_data.Indicator_Color);
+      EDIT_ITEM_F(0, "Coordinate value", onDrawSelColorItem, SelColor, &HMI_data.Coordinate_Color);
+    }
+    UpdateMenu(SelectColorMenu);
+  }
+
+  void Draw_GetColor_Menu() {
+    checkkey = Menu;
+    if (SET_MENU(GetColorMenu, MSG_COLORS_GET, 5)) {
+      BACK_ITEM(DWIN_ApplyColor);
+      MENU_ITEM(ICON_Cancel, MSG_BUTTON_CANCEL, onDrawMenuItem, Draw_SelectColors_Menu);
+      MENU_ITEM(0, MSG_COLORS_RED, onDrawGetColorItem, SetRGBColor);
+      MENU_ITEM(1, MSG_COLORS_GREEN, onDrawGetColorItem, SetRGBColor);
+      MENU_ITEM(2, MSG_COLORS_BLUE, onDrawGetColorItem, SetRGBColor);
     }
-    UpdateMenu(HotendPIDMenu);
+    UpdateMenu(GetColorMenu);
+    dwinDrawRectangle(1, *MenuData.P_Int, 20, 315, DWIN_WIDTH - 20, 335);
   }
 
-#endif
+#endif // HAS_CUSTOM_COLORS
+
+//=============================================================================
+// Nozzle and Bed PID/MPC
+//=============================================================================
 
 #if ANY(MPC_EDIT_MENU, MPC_AUTOTUNE_MENU)
 
-  #if ENABLED(MPC_AUTOTUNE_MENU)
-    void HotendMPC() { thermalManager.MPC_autotune(active_extruder); }
-  #endif
   #if ENABLED(MPC_EDIT_MENU)
     void SetHeaterPower() { SetPFloatOnClick(1, 200, 1); }
     void SetBlkHeatCapacity() { SetPFloatOnClick(0, 40, 2); }
     void SetSensorResponse() { SetPFloatOnClick(0, 1, 4); }
     void SetAmbientXfer() { SetPFloatOnClick(0, 1, 4); }
     #if ENABLED(MPC_INCLUDE_FAN)
       void onDrawFanAdj(MenuItemClass* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 4, thermalManager.temp_hotend[0].fanCoefficient()); }
       void ApplyFanAdj() { thermalManager.temp_hotend[0].applyFanAdjustment(MenuData.Value / POW(10, 4)); }
       void SetFanAdj() { SetFloatOnClick(0, 1, 4, thermalManager.temp_hotend[0].fanCoefficient(), ApplyFanAdj); }
     #endif
   #endif
 
   void Draw_HotendMPC_Menu() {
     checkkey = Menu;
     if (SET_MENU_F(HotendMPCMenu, "MPC Settings", 7)) {
       MPC_t &mpc = thermalManager.temp_hotend[0].mpc;
       BACK_ITEM(Draw_AdvancedSettings_Menu);
       #if ENABLED(MPC_AUTOTUNE_MENU)
-        MENU_ITEM(ICON_MPCNozzle, MSG_MPC_AUTOTUNE, onDrawMenuItem, HotendMPC);
+        MENU_ITEM(ICON_MPCNozzle, MSG_MPC_AUTOTUNE, onDrawMenuItem, []{ thermalManager.MPC_autotune(active_extruder, Temperature::MPCTuningType::AUTO); });
       #endif
       #if ENABLED(MPC_EDIT_MENU)
         EDIT_ITEM(ICON_MPCHeater, MSG_MPC_POWER, onDrawPFloatMenu, SetHeaterPower, &mpc.heater_power);
         EDIT_ITEM(ICON_MPCHeatCap, MSG_MPC_BLOCK_HEAT_CAPACITY, onDrawPFloat2Menu, SetBlkHeatCapacity, &mpc.block_heat_capacity);
         EDIT_ITEM(ICON_MPCValue, MSG_SENSOR_RESPONSIVENESS, onDrawPFloat4Menu, SetSensorResponse, &mpc.sensor_responsiveness);
         EDIT_ITEM(ICON_MPCValue, MSG_MPC_AMBIENT_XFER_COEFF, onDrawPFloat4Menu, SetAmbientXfer, &mpc.ambient_xfer_coeff_fan0);
         #if ENABLED(MPC_INCLUDE_FAN)
           EDIT_ITEM(ICON_MPCFan, MSG_MPC_AMBIENT_XFER_COEFF_FAN, onDrawFanAdj, SetFanAdj, &mpc.fan255_adjustment);
         #endif
       #endif
     }
     UpdateMenu(HotendMPCMenu);
   }
 
 #endif // MPC_EDIT_MENU || MPC_AUTOTUNE_MENU
 
-#if ENABLED(PIDTEMPBED)
+#if DWIN_PID_TUNE
+  void SetPID(celsius_t t, heater_id_t h) {
+    char cmd[53] = "";
+    char str_1[5] = "", str_2[5] = "";
+    sprintf_P(cmd, PSTR("G28OXY\nG0Z5F300\nG0X%sY%sF5000\nM84\nM400"),
+      dtostrf(X_CENTER, 1, 1, str_1),
+      dtostrf(Y_CENTER, 1, 1, str_2)
+    );
+    gcode.process_subcommands_now(cmd);
+    thermalManager.PID_autotune(t, h, HMI_data.PidCycles, true);
+  }
+  void SetPidCycles() { SetPIntOnClick(3, 50); }
+#endif
+
+#if ALL(HAS_PID_HEATING, PID_EDIT_MENU)
+
+  void SetKp() { SetPFloatOnClick(0, 1000, 2); }
+  void ApplyPIDi() {
+    *MenuData.P_Float = scalePID_i(MenuData.Value / POW(10, 2));
+    TERN_(PIDTEMP, thermalManager.updatePID());
+  }
+  void ApplyPIDd() {
+    *MenuData.P_Float = scalePID_d(MenuData.Value / POW(10, 2));
+    TERN_(PIDTEMP, thermalManager.updatePID());
+  }
+  void SetKi() {
+    MenuData.P_Float = (float*)static_cast<MenuItemPtrClass*>(CurrentMenu->SelectedItem())->value;
+    const float value = unscalePID_i(*MenuData.P_Float);
+    SetFloatOnClick(0, 1000, 2, value, ApplyPIDi);
+  }
+  void SetKd() {
+    MenuData.P_Float = (float*)static_cast<MenuItemPtrClass*>(CurrentMenu->SelectedItem())->value;
+    const float value = unscalePID_d(*MenuData.P_Float);
+    SetFloatOnClick(0, 1000, 2, value, ApplyPIDd);
+  }
+  void onDrawPIDi(MenuItemClass* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, unscalePID_i(*(float*)static_cast<MenuItemPtrClass*>(menuitem)->value)); }
+  void onDrawPIDd(MenuItemClass* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, unscalePID_d(*(float*)static_cast<MenuItemPtrClass*>(menuitem)->value)); }
+
+#endif // HAS_PID_HEATING && PID_EDIT_MENU
+
+#if ENABLED(PIDTEMP) && ANY(PID_AUTOTUNE_MENU, PID_EDIT_MENU)
+
+  #if ENABLED(PID_AUTOTUNE_MENU)
+    void HotendPID() { SetPID(HMI_data.HotendPidT, H_E0); }
+    void SetHotendPidT() { SetPIntOnClick(MIN_ETEMP, MAX_ETEMP); }
+  #endif
+
+  void Draw_HotendPID_Menu() {
+    checkkey = Menu;
+    if (SET_MENU_F(HotendPIDMenu, STR_HOTEND_PID " Settings", 8)) {
+      BACK_ITEM(Draw_AdvancedSettings_Menu);
+      #if ENABLED(PID_AUTOTUNE_MENU)
+        MENU_ITEM_F(ICON_PIDNozzle, STR_HOTEND_PID, onDrawMenuItem, HotendPID);
+        EDIT_ITEM(ICON_Temperature, MSG_TEMPERATURE, onDrawPIntMenu, SetHotendPidT, &HMI_data.HotendPidT);
+        EDIT_ITEM(ICON_PIDCycles, MSG_PID_CYCLE, onDrawPIntMenu, SetPidCycles, &HMI_data.PidCycles);
+      #endif
+      #if ENABLED(PID_EDIT_MENU)
+        EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KP, onDrawPFloat2Menu, SetKp, &thermalManager.temp_hotend[0].pid.Kp);
+        EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KI, onDrawPIDi, SetKi, &thermalManager.temp_hotend[0].pid.Ki);
+        EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KD, onDrawPIDd, SetKd, &thermalManager.temp_hotend[0].pid.Kd);
+      #endif
+      #if ENABLED(EEPROM_SETTINGS)
+        MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawMenuItem, WriteEeprom);
+      #endif
+    }
+    UpdateMenu(HotendPIDMenu);
+  }
+
+#endif // PIDTEMP && (PID_AUTOTUNE_MENU || PID_EDIT_MENU)
+
+#if ENABLED(PIDTEMPBED) && ANY(PID_AUTOTUNE_MENU, PID_EDIT_MENU)
+
+  #if ENABLED(PID_AUTOTUNE_MENU)
+    void BedPID() { SetPID(HMI_data.BedPidT, H_BED); }
+    void SetBedPidT() { SetPIntOnClick(MIN_BEDTEMP, MAX_BEDTEMP); }
+  #endif
 
   void Draw_BedPID_Menu() {
     checkkey = Menu;
     if (SET_MENU_F(BedPIDMenu, STR_BED_PID " Settings", 8)) {
       BACK_ITEM(Draw_AdvancedSettings_Menu);
-      MENU_ITEM_F(ICON_PIDBed, STR_BED_PID, onDrawMenuItem,BedPID);
-      EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KP, onDrawPFloat2Menu, SetKp, &thermalManager.temp_bed.pid.Kp);
-      EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KI, onDrawPIDi, SetKi, &thermalManager.temp_bed.pid.Ki);
-      EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KD, onDrawPIDd, SetKd, &thermalManager.temp_bed.pid.Kd);
-      EDIT_ITEM(ICON_Temperature, MSG_TEMPERATURE, onDrawPIntMenu, SetBedPidT, &HMI_data.BedPidT);
-      EDIT_ITEM(ICON_PIDCycles, MSG_PID_CYCLE, onDrawPIntMenu, SetPidCycles, &HMI_data.PidCycles);
+      #if ENABLED(PID_AUTOTUNE_MENU)
+        MENU_ITEM_F(ICON_PIDBed, STR_BED_PID, onDrawMenuItem,BedPID);
+        EDIT_ITEM(ICON_Temperature, MSG_TEMPERATURE, onDrawPIntMenu, SetBedPidT, &HMI_data.BedPidT);
+        EDIT_ITEM(ICON_PIDCycles, MSG_PID_CYCLE, onDrawPIntMenu, SetPidCycles, &HMI_data.PidCycles);
+      #endif
+      #if ENABLED(PID_EDIT_MENU)
+        EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KP, onDrawPFloat2Menu, SetKp, &thermalManager.temp_bed.pid.Kp);
+        EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KI, onDrawPIDi, SetKi, &thermalManager.temp_bed.pid.Ki);
+        EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KD, onDrawPIDd, SetKd, &thermalManager.temp_bed.pid.Kd);
+      #endif
       #if ENABLED(EEPROM_SETTINGS)
         MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawMenuItem, WriteEeprom);
       #endif
     }
     UpdateMenu(BedPIDMenu);
   }
 
-#endif // PIDTEMPBED
+#endif // PIDTEMPBED && (PID_AUTOTUNE_MENU || PID_EDIT_MENU)
+
+//=============================================================================
 
 #if HAS_BED_PROBE
 
   void Draw_ZOffsetWiz_Menu() {
     checkkey = Menu;
     if (SET_MENU(ZOffsetWizMenu, MSG_PROBE_WIZARD, 4)) {
       BACK_ITEM(Draw_Prepare_Menu);
       MENU_ITEM(ICON_Homing, MSG_AUTO_HOME, onDrawMenuItem, AutoHome);
       MENU_ITEM_F(ICON_MoveZ0, "Move Z to Home", onDrawMenuItem, SetMoveZto0);
       EDIT_ITEM(ICON_Zoffset, MSG_ZPROBE_ZOFFSET, onDrawPFloat2Menu, SetZOffset, &BABY_Z_VAR);
@@ -3687,21 +3894,21 @@ void Draw_Steps_Menu() {
       #if HAS_Z_AXIS
         MENU_ITEM(ICON_HomeZ, MSG_AUTO_HOME_Z, onDrawMenuItem, HomeZ);
       #endif
       #if ENABLED(MESH_BED_LEVELING)
         EDIT_ITEM(ICON_ZAfterHome, MSG_Z_AFTER_HOME, onDrawPInt8Menu, SetZAfterHoming, &HMI_data.z_after_homing);
       #endif
     }
     UpdateMenu(HomingMenu);
   }
 
-#endif
+#endif // INDIVIDUAL_AXIS_HOMING_SUBMENU
 
 #if ENABLED(FWRETRACT)
 
   void Draw_FWRetract_Menu() {
     checkkey = Menu;
     if (SET_MENU(FWRetractMenu, MSG_FWRETRACT, 6)) {
       BACK_ITEM(Return_FWRetract_Menu);
       EDIT_ITEM(ICON_FWRetLength, MSG_CONTROL_RETRACT, onDrawPFloatMenu, SetRetractLength, &fwretract.settings.retract_length);
       EDIT_ITEM(ICON_FWRetSpeed, MSG_SINGLENOZZLE_RETRACT_SPEED, onDrawPFloatMenu, SetRetractSpeed, &fwretract.settings.retract_feedrate_mm_s);
       EDIT_ITEM(ICON_FWRetZRaise, MSG_CONTROL_RETRACT_ZHOP, onDrawPFloat2Menu, SetZRaise, &fwretract.settings.retract_zraise);
@@ -3731,49 +3938,50 @@ void Draw_Steps_Menu() {
   #if ENABLED(PREHEAT_BEFORE_LEVELING)
     void SetBedLevT() { SetPIntOnClick(MIN_BEDTEMP, MAX_BEDTEMP); }
   #endif
 
   #if ENABLED(MESH_EDIT_MENU)
     #define Z_OFFSET_MIN -3
     #define Z_OFFSET_MAX  3
 
     void LiveEditMesh() { ((MenuItemPtrClass*)EditZValueItem)->value = &bedlevel.z_values[HMI_value.Select ? bedLevelTools.mesh_x : MenuData.Value][HMI_value.Select ? MenuData.Value : bedLevelTools.mesh_y]; EditZValueItem->redraw(); }
     void ApplyEditMeshX() { bedLevelTools.mesh_x = MenuData.Value; }
-    void SetEditMeshX() { HMI_value.Select = 0; SetIntOnClick(0, GRID_MAX_POINTS_X - 1, bedLevelTools.mesh_x, ApplyEditMeshX, LiveEditMesh); }
     void ApplyEditMeshY() { bedLevelTools.mesh_y = MenuData.Value; }
+    void ResetMesh() { bedLevelTools.mesh_reset(); LCD_MESSAGE(MSG_MESH_RESET); }
+    void SetEditMeshX() { HMI_value.Select = 0; SetIntOnClick(0, GRID_MAX_POINTS_X - 1, bedLevelTools.mesh_x, ApplyEditMeshX, LiveEditMesh); }
     void SetEditMeshY() { HMI_value.Select = 1; SetIntOnClick(0, GRID_MAX_POINTS_Y - 1, bedLevelTools.mesh_y, ApplyEditMeshY, LiveEditMesh); }
     void SetEditZValue() { SetPFloatOnClick(Z_OFFSET_MIN, Z_OFFSET_MAX, 3); }
   #endif
 
 #endif // HAS_MESH
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
 
   void ApplyUBLSlot() { bedlevel.storage_slot = MenuData.Value; }
   void SetUBLSlot() { SetIntOnClick(0, settings.calc_num_meshes() - 1, bedlevel.storage_slot, ApplyUBLSlot); }
   void onDrawUBLSlot(MenuItemClass* menuitem, int8_t line) {
     NOLESS(bedlevel.storage_slot, 0);
     onDrawIntMenu(menuitem, line, bedlevel.storage_slot);
   }
 
   void ApplyUBLTiltGrid() { bedLevelTools.tilt_grid = MenuData.Value; }
   void SetUBLTiltGrid() { SetIntOnClick(1, 3, bedLevelTools.tilt_grid, ApplyUBLTiltGrid); }
 
   void UBLMeshTilt() {
     NOLESS(bedlevel.storage_slot, 0);
-    char buf[15];
+    char buf[9];
     if (bedLevelTools.tilt_grid > 1) {
-      sprintf_P(buf, PSTR("G28O\nG29 J%i"), bedLevelTools.tilt_grid);
+      sprintf_P(buf, PSTR("G29J%i"), bedLevelTools.tilt_grid);
       gcode.process_subcommands_now(buf);
     }
     else
-      gcode.process_subcommands_now(F("G28O\nG29J"));
+      gcode.process_subcommands_now(F("G29J"));
     LCD_MESSAGE(MSG_UBL_MESH_TILTED);
   }
 
   void UBLSmartFillMesh() {
     for (uint8_t x = 0; x < GRID_MAX_POINTS_Y; ++x) bedlevel.smart_fill_mesh();
     LCD_MESSAGE(MSG_UBL_MESH_FILLED);
   }
 
   void UBLMeshSave() {
     NOLESS(bedlevel.storage_slot, 0);
@@ -3786,39 +3994,40 @@ void Draw_Steps_Menu() {
     NOLESS(bedlevel.storage_slot, 0);
     settings.load_mesh(bedlevel.storage_slot);
   }
 
 #endif // AUTO_BED_LEVELING_UBL
 
 #if HAS_MESH
 
   void Draw_MeshSet_Menu() {
     checkkey = Menu;
-    if (SET_MENU(MeshMenu, MSG_MESH_LEVELING, 13)) {
+    if (SET_MENU(MeshMenu, MSG_MESH_LEVELING, 14)) {
       BACK_ITEM(Draw_AdvancedSettings_Menu);
       #if ENABLED(PREHEAT_BEFORE_LEVELING)
         EDIT_ITEM(ICON_Temperature, MSG_UBL_SET_TEMP_BED, onDrawPIntMenu, SetBedLevT, &HMI_data.BedLevT);
       #endif
       EDIT_ITEM(ICON_SetZOffset, MSG_Z_FADE_HEIGHT, onDrawPFloatMenu, SetMeshFadeHeight, &planner.z_fade_height);
       EDIT_ITEM(ICON_UBLActive, MSG_ACTIVATE_MESH, onDrawChkbMenu, SetMeshActive, &planner.leveling_active);
       #if HAS_BED_PROBE
         MENU_ITEM(ICON_Level, MSG_AUTO_MESH, onDrawMenuItem, AutoLev);
       #endif
       #if ENABLED(AUTO_BED_LEVELING_UBL)
         EDIT_ITEM(ICON_UBLSlot, MSG_UBL_STORAGE_SLOT, onDrawUBLSlot, SetUBLSlot, &bedlevel.storage_slot);
         MENU_ITEM(ICON_UBLMeshSave, MSG_UBL_SAVE_MESH, onDrawMenuItem, UBLMeshSave);
         MENU_ITEM(ICON_UBLMeshLoad, MSG_UBL_LOAD_MESH, onDrawMenuItem, UBLMeshLoad);
         EDIT_ITEM(ICON_UBLTiltGrid, MSG_UBL_TILTING_GRID, onDrawPInt8Menu, SetUBLTiltGrid, &bedLevelTools.tilt_grid);
         MENU_ITEM(ICON_UBLTiltGrid, MSG_UBL_TILT_MESH, onDrawMenuItem, UBLMeshTilt);
         MENU_ITEM(ICON_UBLSmartFill, MSG_UBL_SMART_FILLIN, onDrawMenuItem, UBLSmartFillMesh);
       #endif
       #if ENABLED(MESH_EDIT_MENU)
+        MENU_ITEM(ICON_MeshReset, MSG_MESH_RESET, onDrawMenuItem, ResetMesh);
         MENU_ITEM(ICON_MeshEdit, MSG_EDIT_MESH, onDrawSubMenu, Draw_EditMesh_Menu);
       #endif
       MENU_ITEM(ICON_MeshViewer, MSG_MESH_VIEW, onDrawSubMenu, DWIN_MeshViewer);
     }
     UpdateMenu(MeshMenu);
   }
 
   #if ENABLED(MESH_EDIT_MENU)
     void Draw_EditMesh_Menu() {
       if (!leveling_is_valid()) { LCD_MESSAGE(MSG_UBL_MESH_INVALID); return; }

commit 238951a966204ce9bc109e06fdb4027125b28feb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 16 18:08:59 2023 -0500

    üé® More more lowercase (partial ProUI)
    
    Followup to #25939

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 293e6c2d5c..83105f2109 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -155,21 +155,21 @@
 
 #if HAS_MESH && HAS_BED_PROBE
   #define BABY_Z_VAR probe.offset.z
 #else
   float z_offset = 0;
   #define BABY_Z_VAR z_offset
 #endif
 
 // Structs
 HMI_value_t HMI_value;
-HMI_flag_t HMI_flag{0};
+HMI_flag_t hmiFlag{0};
 HMI_data_t HMI_data;
 
 enum SelectItem : uint8_t {
   PAGE_PRINT = 0,
   PAGE_PREPARE,
   PAGE_CONTROL,
   PAGE_ADVANCE,
   PAGE_COUNT,
 
   PRINT_SETUP = 0,
@@ -271,38 +271,38 @@ MenuItemClass *FanSpeedItem = nullptr;
 MenuItemClass *MMeshMoveZItem = nullptr;
 MenuItemClass *EditZValueItem = nullptr;
 
 bool Printing() { return printingIsActive() || printingIsPaused(); }
 bool SD_Printing() { return Printing() && IS_SD_FILE_OPEN(); }
 bool Host_Printing() { return Printing() && !IS_SD_FILE_OPEN(); }
 
 #define DWIN_LANGUAGE_EEPROM_ADDRESS 0x01   // Between 0x01 and 0x63 (EEPROM_OFFSET-1)
                                             // BL24CXX::check() uses 0x00
 
-inline bool HMI_IsChinese() { return HMI_flag.language == DWIN_CHINESE; }
+inline bool HMI_IsChinese() { return hmiFlag.language == DWIN_CHINESE; }
 
 void HMI_SetLanguageCache() {
-  DWIN_JPG_CacheTo1(HMI_IsChinese() ? Language_Chinese : Language_English);
+  dwinJPGCacheTo1(HMI_IsChinese() ? Language_Chinese : Language_English);
 }
 
 void HMI_SetLanguage() {
   #if ALL(EEPROM_SETTINGS, IIC_BL24CXX_EEPROM)
-    BL24CXX::read(DWIN_LANGUAGE_EEPROM_ADDRESS, (uint8_t*)&HMI_flag.language, sizeof(HMI_flag.language));
+    BL24CXX::read(DWIN_LANGUAGE_EEPROM_ADDRESS, (uint8_t*)&hmiFlag.language, sizeof(hmiFlag.language));
   #endif
   HMI_SetLanguageCache();
 }
 
 void HMI_ToggleLanguage() {
-  HMI_flag.language = HMI_IsChinese() ? DWIN_ENGLISH : DWIN_CHINESE;
+  hmiFlag.language = HMI_IsChinese() ? DWIN_ENGLISH : DWIN_CHINESE;
   HMI_SetLanguageCache();
   #if ALL(EEPROM_SETTINGS, IIC_BL24CXX_EEPROM)
-    BL24CXX::write(DWIN_LANGUAGE_EEPROM_ADDRESS, (uint8_t*)&HMI_flag.language, sizeof(HMI_flag.language));
+    BL24CXX::write(DWIN_LANGUAGE_EEPROM_ADDRESS, (uint8_t*)&hmiFlag.language, sizeof(hmiFlag.language));
   #endif
 }
 
 //-----------------------------------------------------------------------------
 // Main Buttons
 //-----------------------------------------------------------------------------
 
 typedef struct { uint16_t x, y[2], w, h; } text_info_t;
 
 void ICON_Button(const bool selected, const int iconid, const frame_rect_t &ico, const text_info_t (&txt), FSTR_P caption) {
@@ -396,47 +396,47 @@ void ICON_Stop() {
 void Popup_window_PauseOrStop() {
   if (HMI_IsChinese()) {
     DWINUI::ClearMainArea();
     Draw_Popup_Bkgd();
          if (select_print.now == PRINT_PAUSE_RESUME) DWIN_Frame_AreaCopy(1, 237, 338, 269, 356, 98, 150);
     else if (select_print.now == PRINT_STOP) DWIN_Frame_AreaCopy(1, 221, 320, 253, 336, 98, 150);
     DWIN_Frame_AreaCopy(1, 220, 304, 264, 319, 130, 150);
     DWINUI::Draw_IconWB(ICON_Confirm_C, 26, 280);
     DWINUI::Draw_IconWB(ICON_Cancel_C, 146, 280);
     Draw_Select_Highlight(true);
-    DWIN_UpdateLCD();
+    dwinUpdateLCD();
   }
   else
     DWIN_Popup_ConfirmCancel(ICON_BLTouch, select_print.now == PRINT_PAUSE_RESUME ? GET_TEXT_F(MSG_PAUSE_PRINT) : GET_TEXT_F(MSG_STOP_PRINT));
 }
 
 #if HAS_HOTEND
 
   void Popup_Window_ETempTooLow() {
     if (HMI_IsChinese()) {
       HMI_SaveProcessID(WaitResponse);
       DWINUI::ClearMainArea();
       Draw_Popup_Bkgd();
       DWINUI::Draw_Icon(ICON_TempTooLow, 102, 105);
       DWIN_Frame_AreaCopy(1, 103, 371, 136, 386,  69, 240);
       DWIN_Frame_AreaCopy(1, 170, 371, 270, 386, 102, 240);
       DWINUI::Draw_IconWB(ICON_Confirm_C, 86, 280);
-      DWIN_UpdateLCD();
+      dwinUpdateLCD();
     }
     else
       DWIN_Popup_Confirm(ICON_TempTooLow, GET_TEXT_F(MSG_HOTEND_TOO_COLD), GET_TEXT_F(MSG_PLEASE_PREHEAT));
   }
 
 #endif
 
 #if HAS_HOTEND || HAS_HEATED_BED
-  void DWIN_Popup_Temperature(const bool toohigh) {
+  void dwinPopupTemperature(const bool toohigh) {
     HMI_SaveProcessID(WaitResponse);
     if (HMI_IsChinese()) {
       DWINUI::ClearMainArea();
       Draw_Popup_Bkgd();
       if (toohigh) {
         DWINUI::Draw_Icon(ICON_TempTooHigh, 102, 165);
         DWIN_Frame_AreaCopy(1, 103, 371, 237, 386, 52, 285);
         DWIN_Frame_AreaCopy(1, 151, 389, 185, 402, 187, 285);
         DWIN_Frame_AreaCopy(1, 189, 389, 271, 402, 95, 310);
       }
@@ -448,21 +448,21 @@ void Popup_window_PauseOrStop() {
     }
     else
       DWIN_Show_Popup(toohigh ? ICON_TempTooHigh : ICON_TempTooLow, F("Nozzle or Bed temperature"), toohigh ? F("is too high") : F("is too low"), BTN_Continue);
   }
 #endif
 
 //
 // Draw status line
 //
 void DWIN_DrawStatusLine(const char *text) {
-  DWIN_Draw_Rectangle(1, HMI_data.StatusBg_Color, 0, STATUS_Y, DWIN_WIDTH, STATUS_Y + 20);
+  dwinDrawRectangle(1, HMI_data.StatusBg_Color, 0, STATUS_Y, DWIN_WIDTH, STATUS_Y + 20);
   if (text) DWINUI::Draw_CenteredString(HMI_data.StatusTxt_Color, STATUS_Y + 2, text);
 }
 void DWIN_DrawStatusLine(FSTR_P fstr) { DWIN_DrawStatusLine(FTOP(fstr)); }
 
 // Clear & reset status line
 void DWIN_ResetStatusLine() {
   ui.status_message[0] = 0;
   DWIN_CheckStatusMessage();
 }
 
@@ -494,21 +494,21 @@ void DWIN_DrawStatusMessage() {
         hash_changed = false;
       }
     }
     else {
       // String is larger than the available line space
 
       // Get a pointer to the next valid UTF8 character
       // and the string remaining length
       uint8_t rlen;
       const char *stat = MarlinUI::status_and_len(rlen);
-      DWIN_Draw_Rectangle(1, HMI_data.StatusBg_Color, 0, STATUS_Y, DWIN_WIDTH, STATUS_Y + 20);
+      dwinDrawRectangle(1, HMI_data.StatusBg_Color, 0, STATUS_Y, DWIN_WIDTH, STATUS_Y + 20);
       DWINUI::MoveTo(0, STATUS_Y + 2);
       DWINUI::Draw_String(HMI_data.StatusTxt_Color, stat, LCD_WIDTH);
 
       // If the string doesn't completely fill the line...
       if (rlen < LCD_WIDTH) {
         DWINUI::Draw_Char(HMI_data.StatusTxt_Color, '.');  // Always at 1+ spaces left, draw a dot
         uint8_t chars = LCD_WIDTH - rlen;                  // Amount of space left in characters
         if (--chars) {                                     // Draw a second dot if there's space
           DWINUI::Draw_Char(HMI_data.StatusTxt_Color, '.');
           if (--chars)
@@ -535,21 +535,21 @@ void Draw_Print_Labels() {
     DWIN_Frame_AreaCopy(1, 65, 72, 128, 86, 176, 173);  // Remain
   }
   else {
     DWINUI::Draw_String( 46, 173, GET_TEXT_F(MSG_INFO_PRINT_TIME));
     DWINUI::Draw_String(181, 173, GET_TEXT_F(MSG_REMAINING_TIME));
   }
 }
 
 void Draw_Print_ProgressBar() {
   DWINUI::Draw_IconWB(ICON_Bar, 15, 93);
-  DWIN_Draw_Rectangle(1, HMI_data.Barfill_Color, 16 + _percent_done * 240 / 100, 93, 256, 113);
+  dwinDrawRectangle(1, HMI_data.Barfill_Color, 16 + _percent_done * 240 / 100, 93, 256, 113);
   DWINUI::Draw_Int(HMI_data.PercentTxt_Color, HMI_data.Background_Color, 3, 117, 133, _percent_done);
   DWINUI::Draw_String(HMI_data.PercentTxt_Color, 142, 133, F("%"));
 }
 
 void Draw_Print_ProgressElapsed() {
   char buf[10];
   duration_t elapsed = print_job_timer.duration(); // print timer
   sprintf_P(buf, PSTR("%02i:%02i "), (uint16_t)(elapsed.value / 3600), ((uint16_t)elapsed.value % 3600) / 60);
   DWINUI::Draw_String(HMI_data.Text_Color, HMI_data.Background_Color, 47, 192, buf);
 }
@@ -566,21 +566,21 @@ void ICON_ResumeOrPause() {
 
 // Update filename on print
 void DWIN_Print_Header(const char *text = nullptr) {
   static char headertxt[31] = "";  // Print header text
   if (text) {
     const int8_t size = _MIN(30U, strlen_P(text));
     for (uint8_t i = 0; i < size; ++i) headertxt[i] = text[i];
     headertxt[size] = '\0';
   }
   if (checkkey == PrintProcess || checkkey == PrintDone) {
-    DWIN_Draw_Rectangle(1, HMI_data.Background_Color, 0, 60, DWIN_WIDTH, 60+16);
+    dwinDrawRectangle(1, HMI_data.Background_Color, 0, 60, DWIN_WIDTH, 60+16);
     DWINUI::Draw_CenteredString(60, headertxt);
   }
 }
 
 void Draw_PrintProcess() {
   if (HMI_IsChinese())
     Title.FrameCopy(30, 1, 42, 14);                     // "Printing"
   else
     Title.ShowCaption(GET_TEXT_F(MSG_PRINTING));
   DWINUI::ClearMainArea();
@@ -597,36 +597,36 @@ void Draw_PrintProcess() {
 }
 
 void Goto_PrintProcess() {
   if (checkkey == PrintProcess)
     ICON_ResumeOrPause();
   else {
     checkkey = PrintProcess;
     Draw_PrintProcess();
     TERN_(DASH_REDRAW, DWIN_RedrawDash());
   }
-  DWIN_UpdateLCD();
+  dwinUpdateLCD();
 }
 
 void Draw_PrintDone() {
   // show percent bar and value
   _percent_done = 100;
   _remain_time = 0;
 
   Title.ShowCaption(GET_TEXT_F(MSG_PRINT_DONE));
   DWINUI::ClearMainArea();
   DWIN_Print_Header(nullptr);
 
   #if HAS_GCODE_PREVIEW
     const bool isvalid = Preview_Valid();
     if (isvalid) {
-      DWIN_ICON_Show(0, 0, 1, 21, 100, 0x00);
+      dwinIconShow(0, 0, 1, 21, 100, 0x00);
       DWINUI::Draw_Button(BTN_Continue, 86, 300);
     }
   #else
     constexpr bool isvalid = false;
   #endif
 
   if (!isvalid) {
     Draw_Print_ProgressBar();
     Draw_Print_Labels();
     DWINUI::Draw_Icon(ICON_PrintTime, 15, 173);
@@ -635,42 +635,42 @@ void Draw_PrintDone() {
     Draw_Print_ProgressRemain();
     DWINUI::Draw_Button(BTN_Continue, 86, 273);
   }
 }
 
 void Goto_PrintDone() {
   wait_for_user = true;
   if (checkkey != PrintDone) {
     checkkey = PrintDone;
     Draw_PrintDone();
-    DWIN_UpdateLCD();
+    dwinUpdateLCD();
   }
 }
 
 void Draw_Main_Menu() {
   DWINUI::ClearMainArea();
   if (HMI_IsChinese())
     Title.FrameCopy(2, 2, 26, 13);   // "Home" etc
   else
     Title.ShowCaption(MACHINE_NAME);
   DWINUI::Draw_Icon(ICON_LOGO, 71, 52);  // CREALITY logo
   ICON_Print();
   ICON_Prepare();
   ICON_Control();
   ICON_AdvSettings();
 }
 
 void Goto_Main_Menu() {
   if (checkkey == MainMenu) return;
   checkkey = MainMenu;
   Draw_Main_Menu();
-  DWIN_UpdateLCD();
+  dwinUpdateLCD();
 }
 
 // Draw X, Y, Z and blink if in an un-homed or un-trusted state
 void _update_axis_value(const AxisEnum axis, const uint16_t x, const uint16_t y, const bool force) {
   const bool draw_qmark = axis_should_home(axis),
              draw_empty = NONE(HOME_AFTER_DEACTIVATE, DISABLE_REDUCED_ACCURACY_WARNING) && !draw_qmark && !axis_is_trusted(axis);
 
   // Check for a position change
   static xyz_pos_t oldpos = { -1, -1, -1 };
 
@@ -688,33 +688,33 @@ void _update_axis_value(const AxisEnum axis, const uint16_t x, const uint16_t y,
       DWINUI::Draw_Signed_Float(HMI_data.Coordinate_Color, HMI_data.Background_Color, 3, 2, x, y, p);
   }
 }
 
 void _draw_ZOffsetIcon() {
   #if HAS_LEVELING
     #if NO_BLINK_LEV_IND
       static bool _leveling_active = false;
       if (_leveling_active != planner.leveling_active) {
         _leveling_active = planner.leveling_active;
-        DWIN_Draw_Rectangle(1, HMI_data.Background_Color, 186, 415, 205, 436);
+        dwinDrawRectangle(1, HMI_data.Background_Color, 186, 415, 205, 436);
         DWINUI::Draw_Icon(_leveling_active ? ICON_SetZOffset : ICON_Zoffset, 187, 416);
       }
     #else
       if (planner.leveling_active) {
-        DWIN_Draw_Rectangle(1, blink ? HMI_data.SplitLine_Color : HMI_data.Background_Color, 186, 415, 205, 436);
+        dwinDrawRectangle(1, blink ? HMI_data.SplitLine_Color : HMI_data.Background_Color, 186, 415, 205, 436);
         DWINUI::Draw_Icon(ICON_SetZOffset, 186, 416);
       }
       static bool _leveling_active = false;
       if (_leveling_active != planner.leveling_active) {
         _leveling_active = planner.leveling_active;
         if (!_leveling_active) {
-          DWIN_Draw_Rectangle(1, HMI_data.Background_Color, 186, 415, 205, 436);
+          dwinDrawRectangle(1, HMI_data.Background_Color, 186, 415, 205, 436);
           DWINUI::Draw_Icon(ICON_Zoffset, 187, 416);
         }
       }
     #endif
   #else
     DWINUI::Draw_Icon(ICON_Zoffset, 187, 416);
   #endif
 }
 
 void _draw_xyz_position(const bool force) {
@@ -941,46 +941,46 @@ void Draw_Print_File_Menu() {
       for (uint8_t i = 0; i < nr_sd_menu_items(); ++i) {
         MenuItemAdd(onDrawFileName, onClickSDItem);
       }
     }
     UpdateMenu(FileMenu);
     TERN_(DASH_REDRAW, DWIN_RedrawDash());
   }
   else {
     if (SET_MENU(FileMenu, MSG_MEDIA_MENU, 1)) BACK_ITEM(Goto_Main_Menu);
     UpdateMenu(FileMenu);
-    DWIN_Draw_Rectangle(1, HMI_data.AlertBg_Color, 10, MBASE(3) - 10, DWIN_WIDTH - 10, MBASE(4));
+    dwinDrawRectangle(1, HMI_data.AlertBg_Color, 10, MBASE(3) - 10, DWIN_WIDTH - 10, MBASE(4));
     DWINUI::Draw_CenteredString(font12x24, HMI_data.AlertTxt_Color, MBASE(3), GET_TEXT_F(MSG_MEDIA_NOT_INSERTED));
   }
   TERN_(SCROLL_LONG_FILENAMES, FileMenuIdle(true));
 }
 
 //
 // Watch for media mount / unmount
 //
 void HMI_SDCardUpdate() {
-  if (HMI_flag.home_flag) return;
+  if (hmiFlag.home_flag) return;
   if (DWIN_lcd_sd_status != card.isMounted()) {
     DWIN_lcd_sd_status = card.isMounted();
     if (IsMenu(FileMenu)) Redraw_SD_List();
     if (!DWIN_lcd_sd_status && SD_Printing()) ui.abort_print();  // Media removed while printing
-    DWIN_UpdateLCD();
+    dwinUpdateLCD();
   }
 }
 
 /**
  * Dash board and indicators
  */
 
 void DWIN_Draw_Dashboard() {
 
-  DWIN_Draw_Rectangle(1, HMI_data.Background_Color, 0, STATUS_Y + 21, DWIN_WIDTH, DWIN_HEIGHT - 1);
+  dwinDrawRectangle(1, HMI_data.Background_Color, 0, STATUS_Y + 21, DWIN_WIDTH, DWIN_HEIGHT - 1);
 
   #if HAS_HOTEND
     DWINUI::Draw_Icon(ICON_HotendTemp, 10, 383);
     DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 28, 384, thermalManager.wholeDegHotend(0));
     DWINUI::Draw_String(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 25 + 3 * STAT_CHR_W + 5, 384, F("/"));
     DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 25 + 4 * STAT_CHR_W + 6, 384, thermalManager.degTargetHotend(0));
 
     DWINUI::Draw_Icon(ICON_StepE, 112, 417);
     DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 116 + 2 * STAT_CHR_W, 417, planner.flow_percentage[0]);
     DWINUI::Draw_String(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 116 + 5 * STAT_CHR_W + 2, 417, F("%"));
@@ -1001,21 +1001,21 @@ void DWIN_Draw_Dashboard() {
     DWINUI::Draw_Icon(ICON_FanSpeed, 187, 383);
     DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 195 + 2 * STAT_CHR_W, 384, thermalManager.fan_speed[0]);
   #endif
 
   #if HAS_ZOFFSET_ITEM
     DWINUI::Draw_Icon(planner.leveling_active ? ICON_SetZOffset : ICON_Zoffset, 187, 416);
   #endif
 
   DWINUI::Draw_Signed_Float(DWIN_FONT_STAT, HMI_data.Indicator_Color,  HMI_data.Background_Color, 2, 2, 204, 417, BABY_Z_VAR);
 
-  DWIN_Draw_Rectangle(1, HMI_data.SplitLine_Color, 0, 449, DWIN_WIDTH, 451);
+  dwinDrawRectangle(1, HMI_data.SplitLine_Color, 0, 449, DWIN_WIDTH, 451);
 
   DWINUI::Draw_Icon(ICON_MaxSpeedX,  10, 456);
   DWINUI::Draw_Icon(ICON_MaxSpeedY,  95, 456);
   DWINUI::Draw_Icon(ICON_MaxSpeedZ, 180, 456);
   _draw_xyz_position(true);
 
 }
 
 void Draw_Info_Menu() {
   DWINUI::ClearMainArea();
@@ -1035,21 +1035,21 @@ void Draw_Info_Menu() {
     DWINUI::Draw_CenteredString(102, F("Size"));
     DWINUI::Draw_CenteredString(175, F("Firmware version"));
     DWINUI::Draw_CenteredString(248, F("Build Datetime"));
     DWINUI::Draw_CenteredString(268, F(STRING_DISTRIBUTION_DATE));
   }
   DWINUI::Draw_CenteredString(122, F(MACHINE_SIZE));
   DWINUI::Draw_CenteredString(195, F(SHORT_BUILD_VERSION));
 
   for (uint8_t i = 0; i < 3; ++i) {
     DWINUI::Draw_Icon(ICON_PrintSize + i, ICOX, 99 + i * 73);
-    DWIN_Draw_HLine(HMI_data.SplitLine_Color, 16, MBASE(2) + i * 73, 240);
+    dwinDrawHLine(HMI_data.SplitLine_Color, 16, MBASE(2) + i * 73, 240);
   }
 }
 
 // Main Process
 void HMI_MainMenu() {
   EncoderState encoder_diffState = get_encoder_state();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
 
   if (encoder_diffState == ENCODER_DIFF_CW) {
     if (select_page.inc(PAGE_COUNT)) {
@@ -1078,28 +1078,28 @@ void HMI_MainMenu() {
           card.mount();
           safe_delay(800);
         };
         Draw_Print_File_Menu();
         break;
       case PAGE_PREPARE: Draw_Prepare_Menu(); break;
       case PAGE_CONTROL: Draw_Control_Menu(); break;
       case PAGE_ADVANCE: Draw_AdvancedSettings_Menu(); break;
     }
   }
-  DWIN_UpdateLCD();
+  dwinUpdateLCD();
 }
 
 // Pause or Stop popup
 void onClick_PauseOrStop() {
   switch (select_print.now) {
-    case PRINT_PAUSE_RESUME: if (HMI_flag.select_flag) ui.pause_print(); break; // confirm pause
-    case PRINT_STOP: if (HMI_flag.select_flag) ui.abort_print(); break; // stop confirmed then abort print
+    case PRINT_PAUSE_RESUME: if (hmiFlag.select_flag) ui.pause_print(); break; // confirm pause
+    case PRINT_STOP: if (hmiFlag.select_flag) ui.abort_print(); break; // stop confirmed then abort print
     default: break;
   }
   return Goto_PrintProcess();
 }
 
 // Printing
 void HMI_Printing() {
   EncoderState encoder_diffState = get_encoder_state();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
   // Avoid flicker by updating only the previous menu
@@ -1129,21 +1129,21 @@ void HMI_Printing() {
           ui.resume_print();
           break;
         }
         else
           return Goto_Popup(Popup_window_PauseOrStop, onClick_PauseOrStop);
       case PRINT_STOP:
         return Goto_Popup(Popup_window_PauseOrStop, onClick_PauseOrStop);
       default: break;
     }
   }
-  DWIN_UpdateLCD();
+  dwinUpdateLCD();
 }
 
 #include "../../../libs/buzzer.h"
 
 void Draw_Main_Area() {
   switch (checkkey) {
     case MainMenu:               Draw_Main_Menu(); break;
     case PrintProcess:           Draw_PrintProcess(); break;
     case PrintDone:              Draw_PrintDone(); break;
     #if HAS_ESDIAG
@@ -1193,22 +1193,22 @@ void HMI_WaitForUser() {
 
 void HMI_Init() {
   #if ENABLED(SHOW_BOOTSCREEN)
     #ifndef BOOTSCREEN_TIMEOUT
       #define BOOTSCREEN_TIMEOUT 1100
     #endif
     DWINUI::Draw_Box(1, Color_Black, { 5, 220, DWIN_WIDTH - 5, DWINUI::fontHeight() });
     DWINUI::Draw_CenteredString(Color_White, 220, F("Professional Firmware "));
     for (uint16_t t = 15; t < 257; t += 11) {
       DWINUI::Draw_Icon(ICON_Bar, 15, 260);
-      DWIN_Draw_Rectangle(1, HMI_data.Background_Color, t, 260, 257, 280);
-      DWIN_UpdateLCD();
+      dwinDrawRectangle(1, HMI_data.Background_Color, t, 260, 257, 280);
+      dwinUpdateLCD();
       safe_delay((BOOTSCREEN_TIMEOUT) / 22);
     }
   #endif
   HMI_SetLanguage();
 }
 
 void EachMomentUpdate() {
   static millis_t next_var_update_ms = 0, next_rts_update_ms = 0, next_status_update_ms = 0;
   const millis_t ms = millis();
 
@@ -1234,54 +1234,54 @@ void EachMomentUpdate() {
     next_status_update_ms = ms + 500;
     DWIN_DrawStatusMessage();
     #if ENABLED(SCROLL_LONG_FILENAMES)
       if (IsMenu(FileMenu)) FileMenuIdle();
     #endif
   }
 
   if (!PENDING(ms, next_rts_update_ms)) {
     next_rts_update_ms = ms + DWIN_UPDATE_INTERVAL;
 
-    if ((Printing() != HMI_flag.printing_flag) && !HMI_flag.home_flag) {
-      HMI_flag.printing_flag = Printing();
-      if (HMI_flag.printing_flag)
+    if ((Printing() != hmiFlag.printing_flag) && !hmiFlag.home_flag) {
+      hmiFlag.printing_flag = Printing();
+      if (hmiFlag.printing_flag)
         DWIN_Print_Started();
-      else if (HMI_flag.abort_flag)
+      else if (hmiFlag.abort_flag)
         DWIN_Print_Aborted();
       else
         DWIN_Print_Finished();
     }
 
-    if ((printingIsPaused() != HMI_flag.pause_flag) && !HMI_flag.home_flag) {
-      HMI_flag.pause_flag = printingIsPaused();
-      if (HMI_flag.pause_flag)
+    if ((printingIsPaused() != hmiFlag.pause_flag) && !hmiFlag.home_flag) {
+      hmiFlag.pause_flag = printingIsPaused();
+      if (hmiFlag.pause_flag)
         DWIN_Print_Pause();
-      else if (HMI_flag.abort_flag)
+      else if (hmiFlag.abort_flag)
         DWIN_Print_Aborted();
       else
         DWIN_Print_Resume();
     }
 
     if (checkkey == PrintProcess) { // print process
 
       duration_t elapsed = print_job_timer.duration(); // print timer
 
-      if (card.isPrinting() && !HMI_flag.percent_flag) {
+      if (card.isPrinting() && !hmiFlag.percent_flag) {
         uint8_t percentDone = card.percentDone();
         if (_percent_done != percentDone) { // print percent
           _percent_done = percentDone;
           Draw_Print_ProgressBar();
         }
 
         // Estimate remaining time every 20 seconds
         static millis_t next_remain_time_update = 0;
-        if (_percent_done > 1 && ELAPSED(ms, next_remain_time_update) && !HMI_flag.heat_flag && !HMI_flag.remain_flag) {
+        if (_percent_done > 1 && ELAPSED(ms, next_remain_time_update) && !hmiFlag.heat_flag && !hmiFlag.remain_flag) {
           _remain_time = (elapsed.value - dwin_heat_time) / (_percent_done * 0.01f) - (elapsed.value - dwin_heat_time);
           next_remain_time_update += DWIN_REMAIN_TIME_UPDATE_INTERVAL;
           Draw_Print_ProgressRemain();
         }
       }
 
       // Print time so far
       static uint16_t last_Printtime = 0;
       const uint16_t min = (elapsed.value % 3600) / 60;
       if (last_Printtime != min) { // 1 minute update
@@ -1289,21 +1289,21 @@ void EachMomentUpdate() {
         Draw_Print_ProgressElapsed();
       }
 
     }
     #if ENABLED(POWER_LOSS_RECOVERY)
       else if (DWIN_lcd_sd_status && recovery.dwin_flag) { // resume print before power off
         return Goto_PowerLossRecovery();
       }
     #endif // POWER_LOSS_RECOVERY
 
-    DWIN_UpdateLCD();
+    dwinUpdateLCD();
   }
 }
 
 #if ENABLED(POWER_LOSS_RECOVERY)
   void Popup_PowerLossRecovery() {
     DWINUI::ClearMainArea();
     Draw_Popup_Bkgd();
     if (HMI_IsChinese()) {
       DWIN_Frame_AreaCopy(1, 160, 338, 235, 354, 98, 115);
       DWIN_Frame_AreaCopy(1, 103, 321, 271, 335, 52, 167);
@@ -1314,26 +1314,26 @@ void EachMomentUpdate() {
       DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 70, GET_TEXT_F(MSG_OUTAGE_RECOVERY));
       DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 147, F("It looks like the last"));
       DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 167, F("file was interrupted."));
       DWINUI::Draw_Button(BTN_Cancel,    26, 280);
       DWINUI::Draw_Button(BTN_Continue, 146, 280);
     }
     MediaFile *dir = nullptr;
     const char * const filename = card.diveToFile(true, dir, recovery.info.sd_filename);
     card.selectFileByName(filename);
     DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 207, card.longest_filename());
-    Draw_Select_Highlight(HMI_flag.select_flag);
-    DWIN_UpdateLCD();
+    Draw_Select_Highlight(hmiFlag.select_flag);
+    dwinUpdateLCD();
   }
 
   void onClick_PowerLossRecovery() {
-    if (HMI_flag.select_flag) {
+    if (hmiFlag.select_flag) {
       queue.inject(F("M1000C"));
       select_page.reset();
       return Goto_Main_Menu();
     }
     else {
       select_print.set(PRINT_SETUP);
       queue.inject(F("M1000"));
     }
   }
 
@@ -1386,29 +1386,29 @@ void HMI_SaveProcessID(const uint8_t id) {
     if (!IDisPopUp()) last_checkkey = checkkey; // if previous is not a popup
     if ((id == Popup)
          || TERN0(HAS_ESDIAG, (id == ESDiagProcess))
          || (id == PrintDone)
          || (id == Leveling)
          || (id == WaitResponse)) wait_for_user = true;
     checkkey = id;
   }
 }
 
-void DWIN_HomingStart() {
-  HMI_flag.home_flag = true;
+void dwinHomingStart() {
+  hmiFlag.home_flag = true;
   HMI_SaveProcessID(Homing);
   Title.ShowCaption(GET_TEXT_F(MSG_HOMING));
   DWIN_Show_Popup(ICON_BLTouch, GET_TEXT_F(MSG_HOMING), GET_TEXT_F(MSG_PLEASE_WAIT));
 }
 
-void DWIN_HomingDone() {
-  HMI_flag.home_flag = false;
+void dwinHomingDone() {
+  hmiFlag.home_flag = false;
   HMI_ReturnScreen();
 }
 
 void DWIN_LevelingStart() {
   #if HAS_BED_PROBE
     HMI_SaveProcessID(Leveling);
     Title.ShowCaption(GET_TEXT_F(MSG_BED_LEVELING));
     DWIN_Show_Popup(ICON_AutoLeveling, GET_TEXT_F(MSG_BED_LEVELING), GET_TEXT_F(MSG_PLEASE_WAIT));
     #if ALL(AUTO_BED_LEVELING_UBL, PREHEAT_BEFORE_LEVELING)
       #if HAS_HOTEND
@@ -1607,63 +1607,63 @@ void DWIN_LevelingDone() {
     }
   }
 
 #endif // MPC_AUTOTUNE
 
 // Started a Print Job
 void DWIN_Print_Started() {
   TERN_(HAS_GCODE_PREVIEW, if (Host_Printing()) Preview_Invalidate());
   _percent_done = 0;
   _remain_time = 0;
-  HMI_flag.percent_flag = false;
-  HMI_flag.remain_flag = false;
-  HMI_flag.pause_flag = false;
-  HMI_flag.abort_flag = false;
+  hmiFlag.percent_flag = false;
+  hmiFlag.remain_flag = false;
+  hmiFlag.pause_flag = false;
+  hmiFlag.abort_flag = false;
   select_print.reset();
   Goto_PrintProcess();
 }
 
 // Pause a print job
 void DWIN_Print_Pause() {
   ICON_ResumeOrPause();
 }
 
 // Resume print job
 void DWIN_Print_Resume() {
   ICON_ResumeOrPause();
   LCD_MESSAGE(MSG_RESUME_PRINT);
 }
 
 // Ended print job
 void DWIN_Print_Finished() {
   TERN_(POWER_LOSS_RECOVERY, if (card.isPrinting()) recovery.cancel());
-  HMI_flag.pause_flag = false;
+  hmiFlag.pause_flag = false;
   wait_for_heatup = false;
   planner.finish_and_disable();
   thermalManager.cooldown();
   Goto_PrintDone();
 }
 
 // Print was aborted
 void DWIN_Print_Aborted() {
   DWIN_Print_Finished();
 }
 
 // Progress and remaining time update
 void DWIN_M73() {
   if (parser.seenval('P')) {
     _percent_done = parser.value_byte();
-    HMI_flag.percent_flag = true;
+    hmiFlag.percent_flag = true;
   }
   if (parser.seenval('R')) {
     _remain_time = parser.value_ulong() * 60;
-    HMI_flag.remain_flag = true;
+    hmiFlag.remain_flag = true;
   }
   if (checkkey == PrintProcess) {
     Draw_Print_ProgressBar();
     Draw_Print_ProgressRemain();
     Draw_Print_ProgressElapsed();
   }
 }
 
 #if HAS_FILAMENT_SENSOR
   // Filament Runout process
@@ -1732,27 +1732,27 @@ void DWIN_CopySettingsFrom(const char * const buff) {
       HMI_data.Led_Color.b
       OPTARG(HAS_WHITE_LED, HMI_data.Led_Color.w)
     );
     leds.update();
   #endif
 }
 
 // Initialize or re-initialize the LCD
 void MarlinUI::init_lcd() {
   delay(750);   // wait to wakeup screen
-  const bool hs = DWIN_Handshake(); UNUSED(hs);
-  DWIN_Frame_SetDir(1);
-  DWIN_JPG_CacheTo1(Language_English);
-  Encoder_Configuration();
+  const bool hs = dwinHandshake(); UNUSED(hs);
+  dwinFrameSetDir(1);
+  dwinJPGCacheTo1(Language_English);
+  encoderConfiguration();
 }
 
-void DWIN_InitScreen() {
+void dwinInitScreen() {
   DWIN_SetColorDefaults();
   HMI_Init();   // draws boot screen
   DWINUI::init();
   DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color, HMI_data.StatusBg_Color);
   DWINUI::onTitleDraw = Draw_Title;
   InitMenu();
   checkkey = 255;
   hash_changed = true;
   last_E = 0;
   DWIN_DrawStatusLine();
@@ -1762,34 +1762,34 @@ void DWIN_InitScreen() {
 
 void MarlinUI::update() {
   EachMomentUpdate();   // Status update
   HMI_SDCardUpdate();   // SD card update
   DWIN_HandleScreen();  // Rotary encoder update
 }
 
 void MarlinUI::refresh() { /* Nothing to see here */ }
 
 #if HAS_LCD_BRIGHTNESS
-  void MarlinUI::_set_brightness() { DWIN_LCD_Brightness(backlight ? brightness : 0); }
+  void MarlinUI::_set_brightness() { dwinLCDBrightness(backlight ? brightness : 0); }
 #endif
 
 void MarlinUI::kill_screen(FSTR_P const lcd_error, FSTR_P const lcd_component) {
   DWIN_Draw_Popup(ICON_BLTouch, GET_TEXT_F(MSG_PRINTER_KILLED), lcd_error);
   DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 270, GET_TEXT_F(MSG_TURN_OFF));
-  DWIN_UpdateLCD();
+  dwinUpdateLCD();
 }
 
 void DWIN_RebootScreen() {
-  DWIN_Frame_Clear(Color_Bg_Black);
-  DWIN_JPG_ShowAndCache(0);
+  dwinFrameClear(Color_Bg_Black);
+  dwinJPGShowAndCache(0);
   DWINUI::Draw_CenteredString(Color_White, 220, GET_TEXT_F(MSG_PLEASE_WAIT_REBOOT));
-  DWIN_UpdateLCD();
+  dwinUpdateLCD();
   safe_delay(500);
 }
 
 void DWIN_RedrawDash() {
   hash_changed = true;
   DWIN_DrawStatusMessage();
   DWIN_Draw_Dashboard();
 }
 
 void DWIN_RedrawScreen() {
@@ -1830,21 +1830,21 @@ void DWIN_RedrawScreen() {
   }
 
   void Draw_Popup_FilamentPurge() {
     DWIN_Draw_Popup(ICON_BLTouch, GET_TEXT_F(MSG_ADVANCED_PAUSE), GET_TEXT_F(MSG_FILAMENT_CHANGE_PURGE_CONTINUE));
     DWINUI::Draw_Button(BTN_Purge, 26, 280);
     DWINUI::Draw_Button(BTN_Continue, 146, 280);
     Draw_Select_Highlight(true);
   }
 
   void onClick_FilamentPurge() {
-    if (HMI_flag.select_flag)
+    if (hmiFlag.select_flag)
       pause_menu_response = PAUSE_RESPONSE_EXTRUDE_MORE;  // "Purge More" button
     else {
       HMI_SaveProcessID(NothingToDo);
       pause_menu_response = PAUSE_RESPONSE_RESUME_PRINT;  // "Continue" button
     }
   }
 
   void Goto_FilamentPurge() {
     pause_menu_response = PAUSE_RESPONSE_WAIT_FOR;
     Goto_Popup(Draw_Popup_FilamentPurge, onClick_FilamentPurge);
@@ -1889,37 +1889,37 @@ void DWIN_RedrawScreen() {
     if (lockScreen.isUnlocked()) DWIN_UnLockScreen();
   }
 
 #endif // HAS_LOCKSCREEN
 
 #if HAS_GCODE_PREVIEW
 
   void onClick_ConfirmToPrint() {
     Preview_Reset();
     DWIN_ResetStatusLine();
-    if (HMI_flag.select_flag) {     // Confirm
-      HMI_flag.heat_flag = true;
+    if (hmiFlag.select_flag) {     // Confirm
+      hmiFlag.heat_flag = true;
       Goto_Main_Menu();
       return card.openAndPrintFile(card.filename);
     }
     else
       HMI_ReturnScreen();
   }
 
 #endif
 
 void Goto_ConfirmToPrint() {
   #if HAS_GCODE_PREVIEW
     Goto_Popup(Preview_DrawFromSD, onClick_ConfirmToPrint);
   #else
     // Print SD file
-    HMI_flag.heat_flag = true;
+    hmiFlag.heat_flag = true;
     card.openAndPrintFile(card.filename);
   #endif
 }
 
 #if HAS_ESDIAG
   void Draw_EndStopDiag() {
     HMI_SaveProcessID(ESDiagProcess);
     ESDiag.Draw();
   }
 #endif
@@ -1927,21 +1927,21 @@ void Goto_ConfirmToPrint() {
 //=============================================================================
 // NEW MENU SUBSYSTEM
 //=============================================================================
 
 // Tool functions
 
 #if ENABLED(EEPROM_SETTINGS)
 
   void WriteEeprom() {
     DWIN_DrawStatusLine(GET_TEXT_F(MSG_STORE_EEPROM));
-    DWIN_UpdateLCD();
+    dwinUpdateLCD();
     DONE_BUZZ(settings.save());
   }
 
   void ReadEeprom() {
     const bool success = settings.load();
     DWIN_RedrawScreen();
     DONE_BUZZ(success);
   }
 
   void ResetEeprom() {
@@ -1960,21 +1960,21 @@ void Goto_ConfirmToPrint() {
 void RebootPrinter() {
   wait_for_heatup = wait_for_user = false;    // Stop waiting for heating/user
   thermalManager.disable_all_heaters();
   planner.finish_and_disable();
   DWIN_RebootScreen();
   hal.reboot();
 }
 
 void Goto_Info_Menu() {
   Draw_Info_Menu();
-  DWIN_UpdateLCD();
+  dwinUpdateLCD();
   HMI_SaveProcessID(WaitResponse);
 }
 
 void DisableMotors() { queue.inject(F("M84")); }
 
 void AutoLev() {   // Always reacquire the Z "home" position
   queue.inject(F(TERN(AUTO_BED_LEVELING_UBL, "G28Z\nG29P1", "G28XYO\nG28Z\nG29")));
 }
 
 void AutoHome() { queue.inject_P(G28_STR); }
@@ -2103,29 +2103,29 @@ void SetMoveZ() { HMI_value.axis = Z_AXIS; SetPFloatOnClick(Z_MIN_POS, Z_MAX_POS
     recovery.changed();
   }
 #endif
 
 #if ENABLED(BAUD_RATE_GCODE)
   void HMI_SetBaudRate() { HMI_data.Baud115K ? SetBaud115K() : SetBaud250K(); }
   void SetBaudRate() {
     HMI_data.Baud115K ^= true;
     HMI_SetBaudRate();
     Draw_Chkb_Line(CurrentMenu->line(), HMI_data.Baud115K);
-    DWIN_UpdateLCD();
+    dwinUpdateLCD();
   }
   void SetBaud115K() { queue.inject(F("M575 P0 B115200")); HMI_data.Baud115K = true; }
   void SetBaud250K() { queue.inject(F("M575 P0 B250000")); HMI_data.Baud115K = false; }
 #endif
 
 #if HAS_LCD_BRIGHTNESS
   void ApplyBrightness() { ui.set_brightness(MenuData.Value); }
-  void LiveBrightness() { DWIN_LCD_Brightness(MenuData.Value); }
+  void LiveBrightness() { dwinLCDBrightness(MenuData.Value); }
   void SetBrightness() { SetIntOnClick(LCD_BRIGHTNESS_MIN, LCD_BRIGHTNESS_MAX, ui.brightness, ApplyBrightness, LiveBrightness); }
   void TurnOffBacklight() { HMI_SaveProcessID(WaitResponse); ui.set_brightness(0); DWIN_RedrawScreen(); }
 #endif
 
 #if ENABLED(CASE_LIGHT_MENU)
   void SetCaseLight() {
     Toggle_Chkb_Line(caselight.on);
     caselight.update_enabled();
   }
   #if ENABLED(CASELIGHT_USES_BRIGHTNESS)
@@ -2220,21 +2220,21 @@ void SelColor() {
   MenuData.P_Int = (int16_t*)static_cast<MenuItemPtrClass*>(CurrentMenu->SelectedItem())->value;
   HMI_value.Color[0] = GetRColor(*MenuData.P_Int);  // Red
   HMI_value.Color[1] = GetGColor(*MenuData.P_Int);  // Green
   HMI_value.Color[2] = GetBColor(*MenuData.P_Int);  // Blue
   Draw_GetColor_Menu();
 }
 
 void LiveRGBColor() {
     HMI_value.Color[CurrentMenu->line() - 2] = MenuData.Value;
     uint16_t color = RGB(HMI_value.Color[0], HMI_value.Color[1], HMI_value.Color[2]);
-    DWIN_Draw_Rectangle(1, color, 20, 315, DWIN_WIDTH - 20, 335);
+    dwinDrawRectangle(1, color, 20, 315, DWIN_WIDTH - 20, 335);
 }
 void SetRGBColor() {
   const uint8_t color = static_cast<MenuItemClass*>(CurrentMenu->SelectedItem())->icon;
   SetIntOnClick(0, (color == 1) ? 63 : 31, HMI_value.Color[color], nullptr, LiveRGBColor);
 }
 
 void DWIN_ApplyColor() {
   *MenuData.P_Int = RGB(HMI_value.Color[0], HMI_value.Color[1], HMI_value.Color[2]);
   DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color, HMI_data.StatusBg_Color);
   Draw_SelectColors_Menu();
@@ -2709,39 +2709,39 @@ void onDrawAutoHome(MenuItemClass* menuitem, int8_t line) {
 #endif
 
 void onDrawLanguage(MenuItemClass* menuitem, int8_t line) {
   if (HMI_IsChinese()) menuitem->SetFrame(1, 239, 134, 266, 146);
   onDrawMenuItem(menuitem, line);
   DWINUI::Draw_String(VALX, MBASE(line), HMI_IsChinese() ? F("CN") : F("EN"));
 }
 
 void onDrawSelColorItem(MenuItemClass* menuitem, int8_t line) {
   const uint16_t color = *(uint16_t*)static_cast<MenuItemPtrClass*>(menuitem)->value;
-  DWIN_Draw_Rectangle(0, HMI_data.Highlight_Color, ICOX + 1, MBASE(line) - 1 + 1, ICOX + 18, MBASE(line) - 1 + 18);
-  DWIN_Draw_Rectangle(1, color, ICOX + 2, MBASE(line) - 1 + 2, ICOX + 17, MBASE(line) - 1 + 17);
+  dwinDrawRectangle(0, HMI_data.Highlight_Color, ICOX + 1, MBASE(line) - 1 + 1, ICOX + 18, MBASE(line) - 1 + 18);
+  dwinDrawRectangle(1, color, ICOX + 2, MBASE(line) - 1 + 2, ICOX + 17, MBASE(line) - 1 + 17);
   onDrawMenuItem(menuitem, line);
 }
 
 void onDrawGetColorItem(MenuItemClass* menuitem, int8_t line) {
   const uint8_t i = menuitem->icon;
   uint16_t color;
   switch (i) {
     case 0: color = RGB(31, 0, 0); break; // Red
     case 1: color = RGB(0, 63, 0); break; // Green
     case 2: color = RGB(0, 0, 31); break; // Blue
     default: color = 0; break;
   }
-  DWIN_Draw_Rectangle(0, HMI_data.Highlight_Color, ICOX + 1, MBASE(line) - 1 + 1, ICOX + 18, MBASE(line) - 1 + 18);
-  DWIN_Draw_Rectangle(1, color, ICOX + 2, MBASE(line) - 1 + 2, ICOX + 17, MBASE(line) - 1 + 17);
+  dwinDrawRectangle(0, HMI_data.Highlight_Color, ICOX + 1, MBASE(line) - 1 + 1, ICOX + 18, MBASE(line) - 1 + 18);
+  dwinDrawRectangle(1, color, ICOX + 2, MBASE(line) - 1 + 2, ICOX + 17, MBASE(line) - 1 + 17);
   DWINUI::Draw_String(LBLX, MBASE(line) - 1, menuitem->caption);
   Draw_Menu_IntValue(HMI_data.Background_Color, line, 4, HMI_value.Color[i]);
-  DWIN_Draw_HLine(HMI_data.SplitLine_Color, 16, MYPOS(line + 1), 240);
+  dwinDrawHLine(HMI_data.SplitLine_Color, 16, MYPOS(line + 1), 240);
 }
 
 #if DWIN_PID_TUNE
   void onDrawPIDi(MenuItemClass* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, unscalePID_i(*(float*)static_cast<MenuItemPtrClass*>(menuitem)->value)); }
   void onDrawPIDd(MenuItemClass* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, unscalePID_d(*(float*)static_cast<MenuItemPtrClass*>(menuitem)->value)); }
 #endif
 
 void onDrawSpeedItem(MenuItemClass* menuitem, int8_t line) {
   if (HMI_IsChinese()) menuitem->SetFrame(1, 116, 164, 171, 176);
   onDrawPIntMenu(menuitem, line);
@@ -3282,21 +3282,21 @@ void Draw_SelectColors_Menu() {
 void Draw_GetColor_Menu() {
   checkkey = Menu;
   if (SET_MENU(GetColorMenu, MSG_COLORS_GET, 5)) {
     BACK_ITEM(DWIN_ApplyColor);
     MENU_ITEM(ICON_Cancel, MSG_BUTTON_CANCEL, onDrawMenuItem, Draw_SelectColors_Menu);
     MENU_ITEM(0, MSG_COLORS_RED, onDrawGetColorItem, SetRGBColor);
     MENU_ITEM(1, MSG_COLORS_GREEN, onDrawGetColorItem, SetRGBColor);
     MENU_ITEM(2, MSG_COLORS_BLUE, onDrawGetColorItem, SetRGBColor);
   }
   UpdateMenu(GetColorMenu);
-  DWIN_Draw_Rectangle(1, *MenuData.P_Int, 20, 315, DWIN_WIDTH - 20, 335);
+  dwinDrawRectangle(1, *MenuData.P_Int, 20, 315, DWIN_WIDTH - 20, 335);
 }
 
 #if ALL(CASE_LIGHT_MENU, CASELIGHT_USES_BRIGHTNESS)
 
   void Draw_CaseLight_Menu() {
     checkkey = Menu;
     if (SET_MENU(CaseLightMenu, MSG_CASE_LIGHT, 3)) {
       BACK_ITEM(Draw_Control_Menu);
       EDIT_ITEM(ICON_CaseLight, MSG_CASE_LIGHT, onDrawChkbMenu, SetCaseLight, &caselight.on);
       EDIT_ITEM(ICON_Brightness, MSG_CASE_LIGHT_BRIGHTNESS, onDrawPInt8Menu, SetCaseLightBrightness, &caselight.brightness);
@@ -3718,21 +3718,21 @@ void Draw_Steps_Menu() {
 //=============================================================================
 
 #if HAS_MESH
 
   void ApplyMeshFadeHeight() { set_z_fade_height(planner.z_fade_height); }
   void SetMeshFadeHeight() { SetPFloatOnClick(0, 100, 1, ApplyMeshFadeHeight); }
 
   void SetMeshActive() {
     set_bed_leveling_enabled(!planner.leveling_active);
     Draw_Chkb_Line(CurrentMenu->line(), planner.leveling_active);
-    DWIN_UpdateLCD();
+    dwinUpdateLCD();
   }
 
   #if ENABLED(PREHEAT_BEFORE_LEVELING)
     void SetBedLevT() { SetPIntOnClick(MIN_BEDTEMP, MAX_BEDTEMP); }
   #endif
 
   #if ENABLED(MESH_EDIT_MENU)
     #define Z_OFFSET_MIN -3
     #define Z_OFFSET_MAX  3
 

commit 86c811660ebf0b3fcbae2f34273d4c9d0c22abc4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:30:34 2023 -0500

    üßë‚Äçüíª Remove LOOP macros (#25917)

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 807f1915f6..293e6c2d5c 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -562,21 +562,21 @@ void Draw_Print_ProgressRemain() {
 
 void ICON_ResumeOrPause() {
   if (checkkey == PrintProcess) printingIsPaused() ? ICON_Resume() : ICON_Pause();
 }
 
 // Update filename on print
 void DWIN_Print_Header(const char *text = nullptr) {
   static char headertxt[31] = "";  // Print header text
   if (text) {
     const int8_t size = _MIN(30U, strlen_P(text));
-    LOOP_L_N(i, size) headertxt[i] = text[i];
+    for (uint8_t i = 0; i < size; ++i) headertxt[i] = text[i];
     headertxt[size] = '\0';
   }
   if (checkkey == PrintProcess || checkkey == PrintDone) {
     DWIN_Draw_Rectangle(1, HMI_data.Background_Color, 0, 60, DWIN_WIDTH, 60+16);
     DWINUI::Draw_CenteredString(60, headertxt);
   }
 }
 
 void Draw_PrintProcess() {
   if (HMI_IsChinese())
@@ -931,21 +931,21 @@ void onDrawFileName(MenuItemClass* menuitem, int8_t line) {
     icon = card.flag.filenameIsDir ? ICON_Folder : card.fileIsBinary() ? ICON_Binary : ICON_File;
     Draw_Menu_Line(line, icon, shift_name);
   }
 }
 
 void Draw_Print_File_Menu() {
   checkkey = Menu;
   if (card.isMounted()) {
     if (SET_MENU(FileMenu, MSG_MEDIA_MENU, nr_sd_menu_items() + 1)) {
       BACK_ITEM(Goto_Main_Menu);
-      LOOP_L_N(i, nr_sd_menu_items()) {
+      for (uint8_t i = 0; i < nr_sd_menu_items(); ++i) {
         MenuItemAdd(onDrawFileName, onClickSDItem);
       }
     }
     UpdateMenu(FileMenu);
     TERN_(DASH_REDRAW, DWIN_RedrawDash());
   }
   else {
     if (SET_MENU(FileMenu, MSG_MEDIA_MENU, 1)) BACK_ITEM(Goto_Main_Menu);
     UpdateMenu(FileMenu);
     DWIN_Draw_Rectangle(1, HMI_data.AlertBg_Color, 10, MBASE(3) - 10, DWIN_WIDTH - 10, MBASE(4));
@@ -1033,21 +1033,21 @@ void Draw_Info_Menu() {
   }
   else {
     DWINUI::Draw_CenteredString(102, F("Size"));
     DWINUI::Draw_CenteredString(175, F("Firmware version"));
     DWINUI::Draw_CenteredString(248, F("Build Datetime"));
     DWINUI::Draw_CenteredString(268, F(STRING_DISTRIBUTION_DATE));
   }
   DWINUI::Draw_CenteredString(122, F(MACHINE_SIZE));
   DWINUI::Draw_CenteredString(195, F(SHORT_BUILD_VERSION));
 
-  LOOP_L_N(i, 3) {
+  for (uint8_t i = 0; i < 3; ++i) {
     DWINUI::Draw_Icon(ICON_PrintSize + i, ICOX, 99 + i * 73);
     DWIN_Draw_HLine(HMI_data.SplitLine_Color, 16, MBASE(2) + i * 73, 240);
   }
 }
 
 // Main Process
 void HMI_MainMenu() {
   EncoderState encoder_diffState = get_encoder_state();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
 
@@ -2406,36 +2406,36 @@ void TramC () { Tram(4); }
     MeshViewer.DrawMesh(zval, 2, 2);
     zval[1][1] = Tram(2);
     MeshViewer.DrawMesh(zval, 2, 2);
     zval[0][1] = Tram(3);
     MeshViewer.DrawMesh(zval, 2, 2);
 
     DWINUI::Draw_CenteredString(140, F("Calculating average"));
     DWINUI::Draw_CenteredString(160, F("and relative heights"));
     safe_delay(1000);
     float avg = 0.0f;
-    LOOP_L_N(x, 2) LOOP_L_N(y, 2) avg += zval[x][y];
+    for (uint8_t x = 0; x < 2; ++x) for (uint8_t y = 0; y < 2; ++y) avg += zval[x][y];
     avg /= 4.0f;
-    LOOP_L_N(x, 2) LOOP_L_N(y, 2) zval[x][y] -= avg;
+    for (uint8_t x = 0; x < 2; ++x) for (uint8_t y = 0; y < 2; ++y) zval[x][y] -= avg;
     MeshViewer.DrawMesh(zval, 2, 2);
     ui.reset_status();
 
     if (ABS(MeshViewer.max - MeshViewer.min) < 0.05f) {
       DWINUI::Draw_CenteredString(140, F("Corners leveled"));
       DWINUI::Draw_CenteredString(160, F("Tolerance achieved!"));
     }
     else {
       uint8_t p = 0;
       float max = 0;
       FSTR_P plabel;
       bool s = true;
-      LOOP_L_N(x, 2) LOOP_L_N(y, 2) {
+      for (uint8_t x = 0; x < 2; ++x) for (uint8_t y = 0; y < 2; ++y) {
         const float d = ABS(zval[x][y]);
         if (max < d) {
           s = (zval[x][y] >= 0);
           max = d;
           p = x + 2 * y;
         }
       }
       switch (p) {
         case 0b00 : plabel = GET_TEXT_F(MSG_LEVBED_FL); break;
         case 0b01 : plabel = GET_TEXT_F(MSG_LEVBED_FR); break;
@@ -3764,21 +3764,21 @@ void Draw_Steps_Menu() {
     if (bedLevelTools.tilt_grid > 1) {
       sprintf_P(buf, PSTR("G28O\nG29 J%i"), bedLevelTools.tilt_grid);
       gcode.process_subcommands_now(buf);
     }
     else
       gcode.process_subcommands_now(F("G28O\nG29J"));
     LCD_MESSAGE(MSG_UBL_MESH_TILTED);
   }
 
   void UBLSmartFillMesh() {
-    LOOP_L_N(x, GRID_MAX_POINTS_Y) bedlevel.smart_fill_mesh();
+    for (uint8_t x = 0; x < GRID_MAX_POINTS_Y; ++x) bedlevel.smart_fill_mesh();
     LCD_MESSAGE(MSG_UBL_MESH_FILLED);
   }
 
   void UBLMeshSave() {
     NOLESS(bedlevel.storage_slot, 0);
     settings.store_mesh(bedlevel.storage_slot);
     ui.status_printf(0, GET_TEXT_F(MSG_MESH_SAVED), bedlevel.storage_slot);
     DONE_BUZZ(true);
   }
 

commit 2691167afe02fbbe74b0fdca2c28a49fac635741
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:26:02 2023 -0500

    üßë‚Äçüíª Dump BOTH and EITHER macros (#25908)

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 6730c026c5..807f1915f6 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -226,21 +226,21 @@ MenuClass *FilamentMenu = nullptr;
 #if HAS_HOTEND
   MenuClass *PreheatMenu = nullptr;
 #endif
 MenuClass *TemperatureMenu = nullptr;
 MenuClass *MaxSpeedMenu = nullptr;
 MenuClass *MaxAccelMenu = nullptr;
 #if HAS_CLASSIC_JERK
   MenuClass *MaxJerkMenu = nullptr;
 #endif
 MenuClass *StepsMenu = nullptr;
-#if EITHER(MPC_EDIT_MENU, MPC_AUTOTUNE_MENU)
+#if ANY(MPC_EDIT_MENU, MPC_AUTOTUNE_MENU)
   MenuClass *HotendMPCMenu = nullptr;
 #endif
 #if ENABLED(PIDTEMP)
   MenuClass *HotendPIDMenu = nullptr;
 #endif
 #if ENABLED(PIDTEMPBED)
   MenuClass *BedPIDMenu = nullptr;
 #endif
 #if ENABLED(CASELIGHT_USES_BRIGHTNESS)
   MenuClass *CaseLightMenu = nullptr;
@@ -278,30 +278,30 @@ bool Host_Printing() { return Printing() && !IS_SD_FILE_OPEN(); }
 #define DWIN_LANGUAGE_EEPROM_ADDRESS 0x01   // Between 0x01 and 0x63 (EEPROM_OFFSET-1)
                                             // BL24CXX::check() uses 0x00
 
 inline bool HMI_IsChinese() { return HMI_flag.language == DWIN_CHINESE; }
 
 void HMI_SetLanguageCache() {
   DWIN_JPG_CacheTo1(HMI_IsChinese() ? Language_Chinese : Language_English);
 }
 
 void HMI_SetLanguage() {
-  #if BOTH(EEPROM_SETTINGS, IIC_BL24CXX_EEPROM)
+  #if ALL(EEPROM_SETTINGS, IIC_BL24CXX_EEPROM)
     BL24CXX::read(DWIN_LANGUAGE_EEPROM_ADDRESS, (uint8_t*)&HMI_flag.language, sizeof(HMI_flag.language));
   #endif
   HMI_SetLanguageCache();
 }
 
 void HMI_ToggleLanguage() {
   HMI_flag.language = HMI_IsChinese() ? DWIN_ENGLISH : DWIN_CHINESE;
   HMI_SetLanguageCache();
-  #if BOTH(EEPROM_SETTINGS, IIC_BL24CXX_EEPROM)
+  #if ALL(EEPROM_SETTINGS, IIC_BL24CXX_EEPROM)
     BL24CXX::write(DWIN_LANGUAGE_EEPROM_ADDRESS, (uint8_t*)&HMI_flag.language, sizeof(HMI_flag.language));
   #endif
 }
 
 //-----------------------------------------------------------------------------
 // Main Buttons
 //-----------------------------------------------------------------------------
 
 typedef struct { uint16_t x, y[2], w, h; } text_info_t;
 
@@ -1403,21 +1403,21 @@ void DWIN_HomingStart() {
 void DWIN_HomingDone() {
   HMI_flag.home_flag = false;
   HMI_ReturnScreen();
 }
 
 void DWIN_LevelingStart() {
   #if HAS_BED_PROBE
     HMI_SaveProcessID(Leveling);
     Title.ShowCaption(GET_TEXT_F(MSG_BED_LEVELING));
     DWIN_Show_Popup(ICON_AutoLeveling, GET_TEXT_F(MSG_BED_LEVELING), GET_TEXT_F(MSG_PLEASE_WAIT));
-    #if BOTH(AUTO_BED_LEVELING_UBL, PREHEAT_BEFORE_LEVELING)
+    #if ALL(AUTO_BED_LEVELING_UBL, PREHEAT_BEFORE_LEVELING)
       #if HAS_HOTEND
         if (thermalManager.degTargetHotend(0) < LEVELING_NOZZLE_TEMP)
           thermalManager.setTargetHotend(LEVELING_NOZZLE_TEMP, 0);
       #endif
       #if HAS_HEATED_BED
         if (thermalManager.degTargetBed() < HMI_data.BedLevT)
           thermalManager.setTargetBed(HMI_data.BedLevT);
       #endif
       TERN_(HAS_HOTEND, thermalManager.wait_for_hotend(0));
       TERN_(HAS_HEATED_BED, thermalManager.wait_for_bed_heating());
@@ -1453,32 +1453,32 @@ void DWIN_LevelingDone() {
     Draw_Popup_Bkgd();
 
     switch (HMI_value.pidresult) {
       default: return;
       #if ENABLED(MPC_AUTOTUNE)
         case MPCTEMP_START:
           DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 100, GET_TEXT_F(MSG_MPC_AUTOTUNE));
           DWINUI::Draw_String(HMI_data.PopupTxt_Color, gfrm.x, gfrm.y - DWINUI::fontHeight() - 4, F("MPC target:    Celsius"));
           break;
       #endif
-      #if EITHER(PIDTEMP, PIDTEMPBED)
+      #if ANY(PIDTEMP, PIDTEMPBED)
         TERN_(PIDTEMP,    case PIDTEMP_START:)
         TERN_(PIDTEMPBED, case PIDTEMPBED_START:)
           DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 100, GET_TEXT_F(MSG_PID_AUTOTUNE));
           DWINUI::Draw_String(HMI_data.PopupTxt_Color, gfrm.x, gfrm.y - DWINUI::fontHeight() - 4, F("PID target:    Celsius"));
           break;
       #endif
     }
 
     switch (HMI_value.pidresult) {
       default: break;
-      #if EITHER(PIDTEMP, MPC_AUTOTUNE)
+      #if ANY(PIDTEMP, MPC_AUTOTUNE)
         TERN_(PIDTEMP,      case PIDTEMP_START:)
         TERN_(MPC_AUTOTUNE, case MPCTEMP_START:)
           DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 120, F("for Nozzle is running."));
           break;
       #endif
       #if ENABLED(PIDTEMPBED)
         case PIDTEMPBED_START:
           DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 120, F("for BED is running."));
           break;
       #endif
@@ -1698,41 +1698,41 @@ void DWIN_SetDataDefaults() {
   TERN_(PIDTEMPBED, HMI_data.BedPidT = DEF_BEDPIDT);
   TERN_(DWIN_PID_TUNE, HMI_data.PidCycles = DEF_PIDCYCLES);
   #if ENABLED(PREVENT_COLD_EXTRUSION)
     HMI_data.ExtMinT = EXTRUDE_MINTEMP;
     ApplyExtMinT();
   #endif
   TERN_(PREHEAT_BEFORE_LEVELING, HMI_data.BedLevT = LEVELING_BED_TEMP);
   TERN_(BAUD_RATE_GCODE, SetBaud250K());
   HMI_data.FullManualTramming = false;
   HMI_data.MediaAutoMount = ENABLED(HAS_SD_EXTENDER);
-  #if BOTH(INDIVIDUAL_AXIS_HOMING_SUBMENU, MESH_BED_LEVELING)
+  #if ALL(INDIVIDUAL_AXIS_HOMING_SUBMENU, MESH_BED_LEVELING)
     HMI_data.z_after_homing = DEF_Z_AFTER_HOMING;
   #endif
-  #if BOTH(LED_CONTROL_MENU, HAS_COLOR_LEDS)
+  #if ALL(LED_CONTROL_MENU, HAS_COLOR_LEDS)
     TERN_(LED_COLOR_PRESETS, leds.set_default());
     ApplyLEDColor();
   #endif
 }
 
 void DWIN_CopySettingsTo(char * const buff) {
   memcpy(buff, &HMI_data, eeprom_data_size);
 }
 
 void DWIN_CopySettingsFrom(const char * const buff) {
   memcpy(&HMI_data, buff, sizeof(HMI_data_t));
   if (HMI_data.Text_Color == HMI_data.Background_Color) DWIN_SetColorDefaults();
   DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color, HMI_data.StatusBg_Color);
   TERN_(PREVENT_COLD_EXTRUSION, ApplyExtMinT());
   feedrate_percentage = 100;
   TERN_(BAUD_RATE_GCODE, HMI_SetBaudRate());
-  #if BOTH(LED_CONTROL_MENU, HAS_COLOR_LEDS)
+  #if ALL(LED_CONTROL_MENU, HAS_COLOR_LEDS)
     leds.set_color(
       HMI_data.Led_Color.r,
       HMI_data.Led_Color.g,
       HMI_data.Led_Color.b
       OPTARG(HAS_WHITE_LED, HMI_data.Led_Color.w)
     );
     leds.update();
   #endif
 }
 
@@ -1976,45 +1976,45 @@ void DisableMotors() { queue.inject(F("M84")); }
 void AutoLev() {   // Always reacquire the Z "home" position
   queue.inject(F(TERN(AUTO_BED_LEVELING_UBL, "G28Z\nG29P1", "G28XYO\nG28Z\nG29")));
 }
 
 void AutoHome() { queue.inject_P(G28_STR); }
 
 #if ENABLED(INDIVIDUAL_AXIS_HOMING_SUBMENU)
   void HomeX() { queue.inject(F("G28X")); }
   void HomeY() { queue.inject(F("G28Y")); }
   void HomeZ() { queue.inject(F("G28Z")); }
-  #if BOTH(INDIVIDUAL_AXIS_HOMING_SUBMENU, MESH_BED_LEVELING)
+  #if ALL(INDIVIDUAL_AXIS_HOMING_SUBMENU, MESH_BED_LEVELING)
     void ApplyZAfterHoming() { HMI_data.z_after_homing = MenuData.Value; };
     void SetZAfterHoming() { SetIntOnClick(0, 20, HMI_data.z_after_homing, ApplyZAfterHoming); }
   #endif
 #endif
 
 #if HAS_HOME_OFFSET
   // Apply workspace offset, making the current position 0,0,0
   void SetHome() {
     queue.inject(F("G92X0Y0Z0"));
     DONE_BUZZ(true);
   }
 #endif
 
 #if HAS_ZOFFSET_ITEM
 
   void ApplyZOffset() { TERN_(EEPROM_SETTINGS, settings.save()); }
   void LiveZOffset() {
-    #if EITHER(BABYSTEP_ZPROBE_OFFSET, JUST_BABYSTEP)
+    #if ANY(BABYSTEP_ZPROBE_OFFSET, JUST_BABYSTEP)
       const_float_t step_zoffset = round((MenuData.Value / 100.0f) * planner.settings.axis_steps_per_mm[Z_AXIS]) - babystep.accum;
       if (BABYSTEP_ALLOWED()) babystep.add_steps(Z_AXIS, step_zoffset);
     #endif
   }
   void SetZOffset() {
-    #if EITHER(BABYSTEP_ZPROBE_OFFSET, JUST_BABYSTEP)
+    #if ANY(BABYSTEP_ZPROBE_OFFSET, JUST_BABYSTEP)
       babystep.accum = round(planner.settings.axis_steps_per_mm[Z_AXIS] * BABY_Z_VAR);
     #endif
     SetPFloatOnClick(Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX, 2, ApplyZOffset, LiveZOffset);
   }
 
   void SetMoveZto0() {
     #if ENABLED(Z_SAFE_HOMING)
       char cmd[54], str_1[5], str_2[5];
       sprintf_P(cmd, PSTR("G28XYO\nG28Z\nG0X%sY%sF5000\nG0Z0F300\nM400"),
         dtostrf(Z_SAFE_HOMING_X_POINT, 1, 1, str_1),
@@ -2128,21 +2128,21 @@ void SetMoveZ() { HMI_value.axis = Z_AXIS; SetPFloatOnClick(Z_MIN_POS, Z_MAX_POS
     Toggle_Chkb_Line(caselight.on);
     caselight.update_enabled();
   }
   #if ENABLED(CASELIGHT_USES_BRIGHTNESS)
     void LiveCaseLightBrightness() { caselight.brightness = MenuData.Value; caselight.update_brightness(); }
     void SetCaseLightBrightness() { SetIntOnClick(0, 255, caselight.brightness, nullptr, LiveCaseLightBrightness); }
   #endif
 #endif
 
 #if ENABLED(LED_CONTROL_MENU)
-  #if !BOTH(CASE_LIGHT_MENU, CASE_LIGHT_USE_NEOPIXEL)
+  #if !ALL(CASE_LIGHT_MENU, CASE_LIGHT_USE_NEOPIXEL)
     void SetLedStatus() {
       leds.toggle();
       Show_Chkb_Line(leds.lights_on);
     }
   #endif
   #if HAS_COLOR_LEDS
     void ApplyLEDColor() {
       HMI_data.Led_Color = LEDColor( {leds.color.r, leds.color.g, leds.color.b OPTARG(HAS_WHITE_LED, HMI_data.Led_Color.w) } );
     }
     void LiveLEDColor(uint8_t *color) { *color = MenuData.Value; leds.update(); }
@@ -2668,21 +2668,21 @@ void onDrawDisableMotors(MenuItemClass* menuitem, int8_t line) {
   if (HMI_IsChinese()) menuitem->SetFrame(1, 204, 70, 259, 82);
   onDrawMenuItem(menuitem, line);
 }
 
 void onDrawAutoHome(MenuItemClass* menuitem, int8_t line) {
   if (HMI_IsChinese()) menuitem->SetFrame(1, 0, 89, 41, 101);
   onDrawMenuItem(menuitem, line);
 }
 
 #if HAS_ZOFFSET_ITEM
-  #if EITHER(BABYSTEP_ZPROBE_OFFSET, JUST_BABYSTEP)
+  #if ANY(BABYSTEP_ZPROBE_OFFSET, JUST_BABYSTEP)
     void onDrawZOffset(MenuItemClass* menuitem, int8_t line) {
       if (HMI_IsChinese()) menuitem->SetFrame(1, 174, 164, 223, 177);
       onDrawPFloat2Menu(menuitem, line);
     }
   #else
     void onDrawHomeOffset(MenuItemClass* menuitem, int8_t line) {
       if (HMI_IsChinese()) menuitem->SetFrame(1, 43, 89, 98, 101);
       onDrawMenuItem(menuitem, line);
     }
   #endif
@@ -3111,21 +3111,21 @@ void Draw_AdvancedSettings_Menu() {
     #if HAS_MESH
       MENU_ITEM(ICON_ProbeSet, MSG_MESH_LEVELING, onDrawSubMenu, Draw_MeshSet_Menu);
     #endif
     #if HAS_BED_PROBE
       MENU_ITEM(ICON_ProbeSet, MSG_ZPROBE_SETTINGS, onDrawSubMenu, Draw_ProbeSet_Menu);
     #endif
     MENU_ITEM(ICON_FilSet, MSG_FILAMENT_SET, onDrawSubMenu, Draw_FilSet_Menu);
     #if ENABLED(PIDTEMP)
       MENU_ITEM_F(ICON_PIDNozzle, STR_HOTEND_PID " Settings", onDrawSubMenu, Draw_HotendPID_Menu);
     #endif
-    #if EITHER(MPC_EDIT_MENU, MPC_AUTOTUNE_MENU)
+    #if ANY(MPC_EDIT_MENU, MPC_AUTOTUNE_MENU)
       MENU_ITEM_F(ICON_MPCNozzle, "MPC Settings", onDrawSubMenu, Draw_HotendMPC_Menu);
     #endif
     #if ENABLED(PIDTEMPBED)
       MENU_ITEM_F(ICON_PIDBed, STR_BED_PID " Settings", onDrawSubMenu, Draw_BedPID_Menu);
     #endif
     #if HAS_ESDIAG
       MENU_ITEM_F(ICON_ESDiag, "End-stops diag.", onDrawSubMenu, Draw_EndStopDiag);
     #endif
     #if ENABLED(PRINTCOUNTER)
       MENU_ITEM(ICON_PrintStats, MSG_INFO_STATS_MENU, onDrawSubMenu, Goto_PrintStats);
@@ -3285,41 +3285,41 @@ void Draw_GetColor_Menu() {
     BACK_ITEM(DWIN_ApplyColor);
     MENU_ITEM(ICON_Cancel, MSG_BUTTON_CANCEL, onDrawMenuItem, Draw_SelectColors_Menu);
     MENU_ITEM(0, MSG_COLORS_RED, onDrawGetColorItem, SetRGBColor);
     MENU_ITEM(1, MSG_COLORS_GREEN, onDrawGetColorItem, SetRGBColor);
     MENU_ITEM(2, MSG_COLORS_BLUE, onDrawGetColorItem, SetRGBColor);
   }
   UpdateMenu(GetColorMenu);
   DWIN_Draw_Rectangle(1, *MenuData.P_Int, 20, 315, DWIN_WIDTH - 20, 335);
 }
 
-#if BOTH(CASE_LIGHT_MENU, CASELIGHT_USES_BRIGHTNESS)
+#if ALL(CASE_LIGHT_MENU, CASELIGHT_USES_BRIGHTNESS)
 
   void Draw_CaseLight_Menu() {
     checkkey = Menu;
     if (SET_MENU(CaseLightMenu, MSG_CASE_LIGHT, 3)) {
       BACK_ITEM(Draw_Control_Menu);
       EDIT_ITEM(ICON_CaseLight, MSG_CASE_LIGHT, onDrawChkbMenu, SetCaseLight, &caselight.on);
       EDIT_ITEM(ICON_Brightness, MSG_CASE_LIGHT_BRIGHTNESS, onDrawPInt8Menu, SetCaseLightBrightness, &caselight.brightness);
     }
     UpdateMenu(CaseLightMenu);
   }
 
 #endif
 
 #if ENABLED(LED_CONTROL_MENU)
 
   void Draw_LedControl_Menu() {
     checkkey = Menu;
     if (SET_MENU(LedControlMenu, MSG_LED_CONTROL, 10)) {
       BACK_ITEM(Draw_Control_Menu);
-      #if !BOTH(CASE_LIGHT_MENU, CASE_LIGHT_USE_NEOPIXEL)
+      #if !ALL(CASE_LIGHT_MENU, CASE_LIGHT_USE_NEOPIXEL)
         EDIT_ITEM(ICON_LedControl, MSG_LEDS, onDrawChkbMenu, SetLedStatus, &leds.lights_on);
       #endif
       #if HAS_COLOR_LEDS
         #if ENABLED(LED_COLOR_PRESETS)
           MENU_ITEM(ICON_LedControl, MSG_SET_LEDS_WHITE, onDrawMenuItem,  leds.set_white);
           MENU_ITEM(ICON_LedControl, MSG_SET_LEDS_RED, onDrawMenuItem,    leds.set_red);
           MENU_ITEM(ICON_LedControl, MSG_SET_LEDS_ORANGE, onDrawMenuItem, leds.set_orange);
           MENU_ITEM(ICON_LedControl, MSG_SET_LEDS_YELLOW, onDrawMenuItem, leds.set_yellow);
           MENU_ITEM(ICON_LedControl, MSG_SET_LEDS_GREEN, onDrawMenuItem,  leds.set_green);
           MENU_ITEM(ICON_LedControl, MSG_SET_LEDS_BLUE, onDrawMenuItem,   leds.set_blue);
@@ -3587,21 +3587,21 @@ void Draw_Steps_Menu() {
       EDIT_ITEM(ICON_PIDCycles, MSG_PID_CYCLE, onDrawPIntMenu, SetPidCycles, &HMI_data.PidCycles);
       #if ENABLED(EEPROM_SETTINGS)
         MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawMenuItem, WriteEeprom);
       #endif
     }
     UpdateMenu(HotendPIDMenu);
   }
 
 #endif
 
-#if EITHER(MPC_EDIT_MENU, MPC_AUTOTUNE_MENU)
+#if ANY(MPC_EDIT_MENU, MPC_AUTOTUNE_MENU)
 
   #if ENABLED(MPC_AUTOTUNE_MENU)
     void HotendMPC() { thermalManager.MPC_autotune(active_extruder); }
   #endif
   #if ENABLED(MPC_EDIT_MENU)
     void SetHeaterPower() { SetPFloatOnClick(1, 200, 1); }
     void SetBlkHeatCapacity() { SetPFloatOnClick(0, 40, 2); }
     void SetSensorResponse() { SetPFloatOnClick(0, 1, 4); }
     void SetAmbientXfer() { SetPFloatOnClick(0, 1, 4); }
     #if ENABLED(MPC_INCLUDE_FAN)

commit b2f372b20f375852e3e009d490260307e399792c
Author: Krzysztof B≈Ça≈ºewicz <blazewicz.krzysztof@gmail.com>
Date:   Thu May 18 07:38:21 2023 +0200

    üö∏ Unify edit limits for some E3V2 LCDs (#25045)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 8bd0a67b9b..6730c026c5 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -136,27 +136,20 @@
 #define MIN_PRINT_SPEED  10
 #define MAX_PRINT_SPEED 999
 
 // Print flow limit
 #define MIN_PRINT_FLOW   10
 #define MAX_PRINT_FLOW   299
 
 // Load and Unload limits
 #define MAX_LOAD_UNLOAD  500
 
-// Feedspeed limit (max feedspeed = MAX_FEEDRATE_EDIT_VALUES)
-#define MIN_MAXFEEDSPEED      1
-#define MIN_MAXACCELERATION   1
-#define MIN_MAXJERK           0.1
-#define MIN_STEP              1
-#define MAX_STEP              999.9
-
 // Editable temperature limits
 #define MIN_ETEMP  0
 #define MAX_ETEMP  (thermalManager.hotend_maxtemp[0] - (HOTEND_OVERSHOOT))
 #define MIN_BEDTEMP 0
 #define MAX_BEDTEMP BED_MAX_TARGET
 
 #define DWIN_VAR_UPDATE_INTERVAL         1024
 #define DWIN_UPDATE_INTERVAL             1024
 #define DWIN_REMAIN_TIME_UPDATE_INTERVAL SEC_TO_MS(20)
 
@@ -188,46 +181,20 @@ enum SelectItem : uint8_t {
 typedef struct {
   uint8_t now, last;
   void set(uint8_t v) { now = last = v; }
   void reset() { set(0); }
   bool changed() { bool c = (now != last); if (c) last = now; return c; }
   bool dec() { if (now) now--; return changed(); }
   bool inc(uint8_t v) { if (now < (v - 1)) now++; else now = (v - 1); return changed(); }
 } select_t;
 select_t select_page{0}, select_print{0};
 
-constexpr float max_feedrate_edit_values[] =
-  #ifdef MAX_FEEDRATE_EDIT_VALUES
-    MAX_FEEDRATE_EDIT_VALUES
-  #else
-    { 1000, 1000, 10, 50 }
-  #endif
-;
-
-constexpr float max_acceleration_edit_values[] =
-  #ifdef MAX_ACCEL_EDIT_VALUES
-    MAX_ACCEL_EDIT_VALUES
-  #else
-    { 1000, 1000, 200, 2000 }
-  #endif
-;
-
-#if HAS_CLASSIC_JERK
-  constexpr float max_jerk_edit_values[] =
-    #ifdef MAX_JERK_EDIT_VALUES
-      MAX_JERK_EDIT_VALUES
-    #else
-      { DEFAULT_XJERK * 2, DEFAULT_YJERK * 2, DEFAULT_ZJERK * 2, DEFAULT_EJERK * 2 }
-    #endif
-  ;
-#endif
-
 #if HAS_HOTEND
   float last_E = 0;
   #define E_MIN_POS (last_E - (EXTRUDE_MAXLENGTH))
   #define E_MAX_POS (last_E + (EXTRUDE_MAXLENGTH))
 #endif
 
 bool hash_changed = true; // Flag to know if message status was changed
 uint8_t _percent_done = 0;
 uint32_t _remain_time = 0;
 bool blink = false;
@@ -1294,22 +1261,22 @@ void EachMomentUpdate() {
         DWIN_Print_Resume();
     }
 
     if (checkkey == PrintProcess) { // print process
 
       duration_t elapsed = print_job_timer.duration(); // print timer
 
       if (card.isPrinting() && !HMI_flag.percent_flag) {
         uint8_t percentDone = card.percentDone();
         if (_percent_done != percentDone) { // print percent
-            _percent_done = percentDone;
-            Draw_Print_ProgressBar();
+          _percent_done = percentDone;
+          Draw_Print_ProgressBar();
         }
 
         // Estimate remaining time every 20 seconds
         static millis_t next_remain_time_update = 0;
         if (_percent_done > 1 && ELAPSED(ms, next_remain_time_update) && !HMI_flag.heat_flag && !HMI_flag.remain_flag) {
           _remain_time = (elapsed.value - dwin_heat_time) / (_percent_done * 0.01f) - (elapsed.value - dwin_heat_time);
           next_remain_time_update += DWIN_REMAIN_TIME_UPDATE_INTERVAL;
           Draw_Print_ProgressRemain();
         }
       }
@@ -2530,50 +2497,74 @@ void TramC () { Tram(4); }
   #endif
   #if HAS_HEATED_BED
     void SetPreheatBedTemp() { SetPIntOnClick(MIN_BEDTEMP, MAX_BEDTEMP); }
   #endif
   #if HAS_FAN
     void SetPreheatFanSpeed() { SetPIntOnClick(0, 255); }
   #endif
 #endif
 
 void ApplyMaxSpeed() { planner.set_max_feedrate(HMI_value.axis, MenuData.Value / MINUNITMULT); }
-void SetMaxSpeedX() { HMI_value.axis = X_AXIS, SetFloatOnClick(MIN_MAXFEEDSPEED, max_feedrate_edit_values[X_AXIS], UNITFDIGITS, planner.settings.max_feedrate_mm_s[X_AXIS], ApplyMaxSpeed); }
-void SetMaxSpeedY() { HMI_value.axis = Y_AXIS, SetFloatOnClick(MIN_MAXFEEDSPEED, max_feedrate_edit_values[Y_AXIS], UNITFDIGITS, planner.settings.max_feedrate_mm_s[Y_AXIS], ApplyMaxSpeed); }
-void SetMaxSpeedZ() { HMI_value.axis = Z_AXIS, SetFloatOnClick(MIN_MAXFEEDSPEED, max_feedrate_edit_values[Z_AXIS], UNITFDIGITS, planner.settings.max_feedrate_mm_s[Z_AXIS], ApplyMaxSpeed); }
+#if HAS_X_AXIS
+  void SetMaxSpeedX() { HMI_value.axis = X_AXIS, SetFloatOnClick(min_feedrate_edit_values.x, max_feedrate_edit_values.x, UNITFDIGITS, planner.settings.max_feedrate_mm_s[X_AXIS], ApplyMaxSpeed); }
+#endif
+#if HAS_Y_AXIS
+  void SetMaxSpeedY() { HMI_value.axis = Y_AXIS, SetFloatOnClick(min_feedrate_edit_values.y, max_feedrate_edit_values.y, UNITFDIGITS, planner.settings.max_feedrate_mm_s[Y_AXIS], ApplyMaxSpeed); }
+#endif
+#if HAS_Z_AXIS
+  void SetMaxSpeedZ() { HMI_value.axis = Z_AXIS, SetFloatOnClick(min_feedrate_edit_values.z, max_feedrate_edit_values.z, UNITFDIGITS, planner.settings.max_feedrate_mm_s[Z_AXIS], ApplyMaxSpeed); }
+#endif
 #if HAS_HOTEND
-  void SetMaxSpeedE() { HMI_value.axis = E_AXIS; SetFloatOnClick(MIN_MAXFEEDSPEED, max_feedrate_edit_values[E_AXIS], UNITFDIGITS, planner.settings.max_feedrate_mm_s[E_AXIS], ApplyMaxSpeed); }
+  void SetMaxSpeedE() { HMI_value.axis = E_AXIS; SetFloatOnClick(min_feedrate_edit_values.e, max_feedrate_edit_values.e, UNITFDIGITS, planner.settings.max_feedrate_mm_s[E_AXIS], ApplyMaxSpeed); }
 #endif
 
 void ApplyMaxAccel() { planner.set_max_acceleration(HMI_value.axis, MenuData.Value); }
-void SetMaxAccelX() { HMI_value.axis = X_AXIS, SetIntOnClick(MIN_MAXACCELERATION, max_acceleration_edit_values[X_AXIS], planner.settings.max_acceleration_mm_per_s2[X_AXIS], ApplyMaxAccel); }
-void SetMaxAccelY() { HMI_value.axis = Y_AXIS, SetIntOnClick(MIN_MAXACCELERATION, max_acceleration_edit_values[Y_AXIS], planner.settings.max_acceleration_mm_per_s2[Y_AXIS], ApplyMaxAccel); }
-void SetMaxAccelZ() { HMI_value.axis = Z_AXIS, SetIntOnClick(MIN_MAXACCELERATION, max_acceleration_edit_values[Z_AXIS], planner.settings.max_acceleration_mm_per_s2[Z_AXIS], ApplyMaxAccel); }
+#if HAS_X_AXIS
+  void SetMaxAccelX() { HMI_value.axis = X_AXIS, SetIntOnClick(min_acceleration_edit_values.x, max_acceleration_edit_values.x, planner.settings.max_acceleration_mm_per_s2[X_AXIS], ApplyMaxAccel); }
+#endif
+#if HAS_Y_AXIS
+  void SetMaxAccelY() { HMI_value.axis = Y_AXIS, SetIntOnClick(min_acceleration_edit_values.y, max_acceleration_edit_values.y, planner.settings.max_acceleration_mm_per_s2[Y_AXIS], ApplyMaxAccel); }
+#endif
+#if HAS_Z_AXIS
+  void SetMaxAccelZ() { HMI_value.axis = Z_AXIS, SetIntOnClick(min_acceleration_edit_values.z, max_acceleration_edit_values.z, planner.settings.max_acceleration_mm_per_s2[Z_AXIS], ApplyMaxAccel); }
+#endif
 #if HAS_HOTEND
-  void SetMaxAccelE() { HMI_value.axis = E_AXIS; SetIntOnClick(MIN_MAXACCELERATION, max_acceleration_edit_values[E_AXIS], planner.settings.max_acceleration_mm_per_s2[E_AXIS], ApplyMaxAccel); }
+  void SetMaxAccelE() { HMI_value.axis = E_AXIS; SetIntOnClick(min_acceleration_edit_values.e, max_acceleration_edit_values.e, planner.settings.max_acceleration_mm_per_s2[E_AXIS], ApplyMaxAccel); }
 #endif
 
 #if HAS_CLASSIC_JERK
   void ApplyMaxJerk() { planner.set_max_jerk(HMI_value.axis, MenuData.Value / MINUNITMULT); }
-  void SetMaxJerkX() { HMI_value.axis = X_AXIS, SetFloatOnClick(MIN_MAXJERK, max_jerk_edit_values[X_AXIS], UNITFDIGITS, planner.max_jerk.x, ApplyMaxJerk); }
-  void SetMaxJerkY() { HMI_value.axis = Y_AXIS, SetFloatOnClick(MIN_MAXJERK, max_jerk_edit_values[Y_AXIS], UNITFDIGITS, planner.max_jerk.y, ApplyMaxJerk); }
-  void SetMaxJerkZ() { HMI_value.axis = Z_AXIS, SetFloatOnClick(MIN_MAXJERK, max_jerk_edit_values[Z_AXIS], UNITFDIGITS, planner.max_jerk.z, ApplyMaxJerk); }
+  #if HAS_X_AXIS
+    void SetMaxJerkX() { HMI_value.axis = X_AXIS, SetFloatOnClick(min_jerk_edit_values.x, max_jerk_edit_values.x, UNITFDIGITS, planner.max_jerk.x, ApplyMaxJerk); }
+  #endif
+  #if HAS_Y_AXIS
+    void SetMaxJerkY() { HMI_value.axis = Y_AXIS, SetFloatOnClick(min_jerk_edit_values.y, max_jerk_edit_values.y, UNITFDIGITS, planner.max_jerk.y, ApplyMaxJerk); }
+  #endif
+  #if HAS_Z_AXIS
+    void SetMaxJerkZ() { HMI_value.axis = Z_AXIS, SetFloatOnClick(min_jerk_edit_values.z, max_jerk_edit_values.z, UNITFDIGITS, planner.max_jerk.z, ApplyMaxJerk); }
+  #endif
   #if HAS_HOTEND
-    void SetMaxJerkE() { HMI_value.axis = E_AXIS; SetFloatOnClick(MIN_MAXJERK, max_jerk_edit_values[E_AXIS], UNITFDIGITS, planner.max_jerk.e, ApplyMaxJerk); }
+    void SetMaxJerkE() { HMI_value.axis = E_AXIS; SetFloatOnClick(min_jerk_edit_values.e, max_jerk_edit_values.e, UNITFDIGITS, planner.max_jerk.e, ApplyMaxJerk); }
   #endif
 #endif
 
-void SetStepsX() { HMI_value.axis = X_AXIS, SetPFloatOnClick( MIN_STEP, MAX_STEP, UNITFDIGITS); }
-void SetStepsY() { HMI_value.axis = Y_AXIS, SetPFloatOnClick( MIN_STEP, MAX_STEP, UNITFDIGITS); }
-void SetStepsZ() { HMI_value.axis = Z_AXIS, SetPFloatOnClick( MIN_STEP, MAX_STEP, UNITFDIGITS); }
+#if HAS_X_AXIS
+  void SetStepsX() { HMI_value.axis = X_AXIS, SetPFloatOnClick( min_steps_edit_values.x, max_steps_edit_values.x, UNITFDIGITS); }
+#endif
+#if HAS_Y_AXIS
+  void SetStepsY() { HMI_value.axis = Y_AXIS, SetPFloatOnClick( min_steps_edit_values.y, max_steps_edit_values.y, UNITFDIGITS); }
+#endif
+#if HAS_Z_AXIS
+  void SetStepsZ() { HMI_value.axis = Z_AXIS, SetPFloatOnClick( min_steps_edit_values.z, max_steps_edit_values.z, UNITFDIGITS); }
+#endif
 #if HAS_HOTEND
-  void SetStepsE() { HMI_value.axis = E_AXIS; SetPFloatOnClick( MIN_STEP, MAX_STEP, UNITFDIGITS); }
+  void SetStepsE() { HMI_value.axis = E_AXIS; SetPFloatOnClick( min_steps_edit_values.e, max_steps_edit_values.e, UNITFDIGITS); }
   #if ENABLED(PIDTEMP)
     void SetHotendPidT() { SetPIntOnClick(MIN_ETEMP, MAX_ETEMP); }
   #endif
 #endif
 #if ENABLED(PIDTEMPBED)
   void SetBedPidT() { SetPIntOnClick(MIN_BEDTEMP, MAX_BEDTEMP); }
 #endif
 
 #if DWIN_PID_TUNE
   void SetPidCycles() { SetPIntOnClick(3, 50); }
@@ -2809,88 +2800,100 @@ void onDrawSteps(MenuItemClass* menuitem, int8_t line) {
     }
   #endif
 #endif // HAS_PREHEAT
 
 void onDrawSpeed(MenuItemClass* menuitem, int8_t line) {
   if (HMI_IsChinese())
     menuitem->SetFrame(1, 173, 133, 228, 147);
   onDrawSubMenu(menuitem, line);
 }
 
-void onDrawMaxSpeedX(MenuItemClass* menuitem, int8_t line) {
-  if (HMI_IsChinese()) {
-    menuitem->SetFrame(1, 173, 133, 228, 147);
-    DWIN_Frame_AreaCopy(1, 229, 133, 236, 147, LBLX + 58, MBASE(line));     // X
+#if HAS_X_AXIS
+  void onDrawMaxSpeedX(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) {
+      menuitem->SetFrame(1, 173, 133, 228, 147);
+      DWIN_Frame_AreaCopy(1, 229, 133, 236, 147, LBLX + 58, MBASE(line));   // X
+    }
+    onDrawPFloatMenu(menuitem, line);
   }
-  onDrawPFloatMenu(menuitem, line);
-}
+#endif
 
-void onDrawMaxSpeedY(MenuItemClass* menuitem, int8_t line) {
-  if (HMI_IsChinese()) {
-    menuitem->SetFrame(1, 173, 133, 228, 147);
-    DWIN_Frame_AreaCopy(1, 1, 150, 7, 160, LBLX + 58, MBASE(line));         // Y
+#if HAS_Y_AXIS
+  void onDrawMaxSpeedY(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) {
+      menuitem->SetFrame(1, 173, 133, 228, 147);
+      DWIN_Frame_AreaCopy(1, 1, 150, 7, 160, LBLX + 58, MBASE(line));       // Y
+    }
+    onDrawPFloatMenu(menuitem, line);
   }
-  onDrawPFloatMenu(menuitem, line);
-}
+#endif
 
-void onDrawMaxSpeedZ(MenuItemClass* menuitem, int8_t line) {
-  if (HMI_IsChinese()) {
-    menuitem->SetFrame(1, 173, 133, 228, 147);
-    DWIN_Frame_AreaCopy(1, 9, 150, 16, 160, LBLX + 58, MBASE(line) + 3);    // Z
+#if HAS_Z_AXIS
+  void onDrawMaxSpeedZ(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) {
+      menuitem->SetFrame(1, 173, 133, 228, 147);
+      DWIN_Frame_AreaCopy(1, 9, 150, 16, 160, LBLX + 58, MBASE(line) + 3);  // Z
+    }
+    onDrawPFloatMenu(menuitem, line);
   }
-  onDrawPFloatMenu(menuitem, line);
-}
+#endif
 
 #if HAS_HOTEND
   void onDrawMaxSpeedE(MenuItemClass* menuitem, int8_t line) {
     if (HMI_IsChinese()) {
       menuitem->SetFrame(1, 173, 133, 228, 147);
       DWIN_Frame_AreaCopy(1, 18, 150, 25, 160, LBLX + 58, MBASE(line));     // E
     }
     onDrawPFloatMenu(menuitem, line);
   }
 #endif
 
 void onDrawAcc(MenuItemClass* menuitem, int8_t line) {
   if (HMI_IsChinese()) {
     menuitem->SetFrame(1, 173, 133, 200, 147);
     DWIN_Frame_AreaCopy(1, 28, 149, 69, 161, LBLX + 27, MBASE(line) + 1);   // ...Acceleration
   }
   onDrawSubMenu(menuitem, line);
 }
 
-void onDrawMaxAccelX(MenuItemClass* menuitem, int8_t line) {
-  if (HMI_IsChinese()) {
-    menuitem->SetFrame(1, 173, 133, 200, 147);
-    DWIN_Frame_AreaCopy(1, 28,  149,  69, 161, LBLX + 27, MBASE(line));
-    DWIN_Frame_AreaCopy(1, 229, 133, 236, 147, LBLX + 71, MBASE(line));     // X
+#if HAS_X_AXIS
+  void onDrawMaxAccelX(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) {
+      menuitem->SetFrame(1, 173, 133, 200, 147);
+      DWIN_Frame_AreaCopy(1, 28,  149,  69, 161, LBLX + 27, MBASE(line));
+      DWIN_Frame_AreaCopy(1, 229, 133, 236, 147, LBLX + 71, MBASE(line));   // X
+    }
+    onDrawPInt32Menu(menuitem, line);
   }
-  onDrawPInt32Menu(menuitem, line);
-}
+#endif
 
-void onDrawMaxAccelY(MenuItemClass* menuitem, int8_t line) {
-  if (HMI_IsChinese()) {
-    menuitem->SetFrame(1, 173, 133, 200, 147);
-    DWIN_Frame_AreaCopy(1, 28, 149,  69, 161, LBLX + 27, MBASE(line));
-    DWIN_Frame_AreaCopy(1,  1, 150,   7, 160, LBLX + 71, MBASE(line));      // Y
+#if HAS_Y_AXIS
+  void onDrawMaxAccelY(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) {
+      menuitem->SetFrame(1, 173, 133, 200, 147);
+      DWIN_Frame_AreaCopy(1, 28, 149,  69, 161, LBLX + 27, MBASE(line));
+      DWIN_Frame_AreaCopy(1,  1, 150,   7, 160, LBLX + 71, MBASE(line));    // Y
+    }
+    onDrawPInt32Menu(menuitem, line);
   }
-  onDrawPInt32Menu(menuitem, line);
-}
+#endif
 
-void onDrawMaxAccelZ(MenuItemClass* menuitem, int8_t line) {
-  if (HMI_IsChinese()) {
-    menuitem->SetFrame(1, 173, 133, 200, 147);
-    DWIN_Frame_AreaCopy(1, 28, 149,  69, 161, LBLX + 27, MBASE(line));
-    DWIN_Frame_AreaCopy(1,  9, 150,  16, 160, LBLX + 71, MBASE(line));      // Z
+#if HAS_Z_AXIS
+  void onDrawMaxAccelZ(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) {
+      menuitem->SetFrame(1, 173, 133, 200, 147);
+      DWIN_Frame_AreaCopy(1, 28, 149,  69, 161, LBLX + 27, MBASE(line));
+      DWIN_Frame_AreaCopy(1,  9, 150,  16, 160, LBLX + 71, MBASE(line));    // Z
+    }
+    onDrawPInt32Menu(menuitem, line);
   }
-  onDrawPInt32Menu(menuitem, line);
-}
+#endif
 
 #if HAS_HOTEND
   void onDrawMaxAccelE(MenuItemClass* menuitem, int8_t line) {
     if (HMI_IsChinese()) {
       menuitem->SetFrame(1, 173, 133, 200, 147);
       DWIN_Frame_AreaCopy(1, 28, 149,  69, 161, LBLX + 27, MBASE(line));
       DWIN_Frame_AreaCopy(1, 18, 150,  25, 160, LBLX + 71, MBASE(line));    // E
     }
     onDrawPInt32Menu(menuitem, line);
   }
@@ -2900,113 +2903,122 @@ void onDrawMaxAccelZ(MenuItemClass* menuitem, int8_t line) {
 
   void onDrawJerk(MenuItemClass* menuitem, int8_t line) {
     if (HMI_IsChinese()) {
       menuitem->SetFrame(1, 173, 133, 200, 147);
       DWIN_Frame_AreaCopy(1, 1, 180, 28, 192, LBLX + 27, MBASE(line) + 1);  // ...
       DWIN_Frame_AreaCopy(1, 202, 133, 228, 147, LBLX + 54, MBASE(line));   // ...Jerk
     }
     onDrawSubMenu(menuitem, line);
   }
 
-  void onDrawMaxJerkX(MenuItemClass* menuitem, int8_t line) {
-    if (HMI_IsChinese()) {
-      menuitem->SetFrame(1, 173, 133, 200, 147);
-      DWIN_Frame_AreaCopy(1,   1, 180,  28, 192, LBLX + 27, MBASE(line));
-      DWIN_Frame_AreaCopy(1, 202, 133, 228, 147, LBLX + 53, MBASE(line));
-      DWIN_Frame_AreaCopy(1, 229, 133, 236, 147, LBLX + 83, MBASE(line));
+  #if HAS_X_AXIS
+    void onDrawMaxJerkX(MenuItemClass* menuitem, int8_t line) {
+      if (HMI_IsChinese()) {
+        menuitem->SetFrame(1, 173, 133, 200, 147);
+        DWIN_Frame_AreaCopy(1,   1, 180,  28, 192, LBLX + 27, MBASE(line));
+        DWIN_Frame_AreaCopy(1, 202, 133, 228, 147, LBLX + 53, MBASE(line));
+        DWIN_Frame_AreaCopy(1, 229, 133, 236, 147, LBLX + 83, MBASE(line));
+      }
+      onDrawPFloatMenu(menuitem, line);
     }
-    onDrawPFloatMenu(menuitem, line);
-  }
+  #endif
 
-  void onDrawMaxJerkY(MenuItemClass* menuitem, int8_t line) {
-    if (HMI_IsChinese()) {
-      menuitem->SetFrame(1, 173, 133, 200, 147);
-      DWIN_Frame_AreaCopy(1,   1, 180,  28, 192, LBLX + 27, MBASE(line));
-      DWIN_Frame_AreaCopy(1, 202, 133, 228, 147, LBLX + 53, MBASE(line));
-      DWIN_Frame_AreaCopy(1,   1, 150,   7, 160, LBLX + 83, MBASE(line));
+  #if HAS_Y_AXIS
+    void onDrawMaxJerkY(MenuItemClass* menuitem, int8_t line) {
+      if (HMI_IsChinese()) {
+        menuitem->SetFrame(1, 173, 133, 200, 147);
+        DWIN_Frame_AreaCopy(1,   1, 180,  28, 192, LBLX + 27, MBASE(line));
+        DWIN_Frame_AreaCopy(1, 202, 133, 228, 147, LBLX + 53, MBASE(line));
+        DWIN_Frame_AreaCopy(1,   1, 150,   7, 160, LBLX + 83, MBASE(line));
+      }
+      onDrawPFloatMenu(menuitem, line);
     }
-    onDrawPFloatMenu(menuitem, line);
-  }
+  #endif
 
-  void onDrawMaxJerkZ(MenuItemClass* menuitem, int8_t line) {
-    if (HMI_IsChinese()) {
-      menuitem->SetFrame(1, 173, 133, 200, 147);
-      DWIN_Frame_AreaCopy(1,   1, 180,  28, 192, LBLX + 27, MBASE(line));
-      DWIN_Frame_AreaCopy(1, 202, 133, 228, 147, LBLX + 53, MBASE(line));
-      DWIN_Frame_AreaCopy(1,   9, 150,  16, 160, LBLX + 83, MBASE(line));
+  #if HAS_Z_AXIS
+    void onDrawMaxJerkZ(MenuItemClass* menuitem, int8_t line) {
+      if (HMI_IsChinese()) {
+        menuitem->SetFrame(1, 173, 133, 200, 147);
+        DWIN_Frame_AreaCopy(1,   1, 180,  28, 192, LBLX + 27, MBASE(line));
+        DWIN_Frame_AreaCopy(1, 202, 133, 228, 147, LBLX + 53, MBASE(line));
+        DWIN_Frame_AreaCopy(1,   9, 150,  16, 160, LBLX + 83, MBASE(line));
+      }
+      onDrawPFloatMenu(menuitem, line);
     }
-    onDrawPFloatMenu(menuitem, line);
-  }
+  #endif
 
   #if HAS_HOTEND
 
     void onDrawMaxJerkE(MenuItemClass* menuitem, int8_t line) {
       if (HMI_IsChinese()) {
         menuitem->SetFrame(1, 173, 133, 200, 147);
         DWIN_Frame_AreaCopy(1,   1, 180,  28, 192, LBLX + 27, MBASE(line));
         DWIN_Frame_AreaCopy(1, 202, 133, 228, 147, LBLX + 53, MBASE(line));
         DWIN_Frame_AreaCopy(1,  18, 150,  25, 160, LBLX + 83, MBASE(line));
       }
       onDrawPFloatMenu(menuitem, line);
     }
 
   #endif
 
 #endif // HAS_CLASSIC_JERK
 
-void onDrawStepsX(MenuItemClass* menuitem, int8_t line) {
-  if (HMI_IsChinese()) {
-    menuitem->SetFrame(1, 153, 148, 194, 161);
-    DWIN_Frame_AreaCopy(1, 229, 133, 236, 147, LBLX + 44, MBASE(line));      // X
+#if HAS_X_AXIS
+  void onDrawStepsX(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) {
+      menuitem->SetFrame(1, 153, 148, 194, 161);
+      DWIN_Frame_AreaCopy(1, 229, 133, 236, 147, LBLX + 44, MBASE(line));      // X
+    }
+    onDrawPFloatMenu(menuitem, line);
   }
-  onDrawPFloatMenu(menuitem, line);
-}
+#endif
 
-void onDrawStepsY(MenuItemClass* menuitem, int8_t line) {
-  if (HMI_IsChinese()) {
-    menuitem->SetFrame(1, 153, 148, 194, 161);
-    DWIN_Frame_AreaCopy(1,   1, 150,   7, 160, LBLX + 44, MBASE(line));      // Y
+#if HAS_Y_AXIS
+  void onDrawStepsY(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) {
+      menuitem->SetFrame(1, 153, 148, 194, 161);
+      DWIN_Frame_AreaCopy(1,   1, 150,   7, 160, LBLX + 44, MBASE(line));      // Y
+    }
+    onDrawPFloatMenu(menuitem, line);
   }
-  onDrawPFloatMenu(menuitem, line);
-}
+#endif
 
-void onDrawStepsZ(MenuItemClass* menuitem, int8_t line) {
-  if (HMI_IsChinese()) {
-    menuitem->SetFrame(1, 153, 148, 194, 161);
-    DWIN_Frame_AreaCopy(1,   9, 150,  16, 160, LBLX + 44, MBASE(line));      // Z
+#if HAS_Z_AXIS
+  void onDrawStepsZ(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) {
+      menuitem->SetFrame(1, 153, 148, 194, 161);
+      DWIN_Frame_AreaCopy(1,   9, 150,  16, 160, LBLX + 44, MBASE(line));      // Z
+    }
+    onDrawPFloatMenu(menuitem, line);
   }
-  onDrawPFloatMenu(menuitem, line);
-}
+#endif
 
 #if HAS_HOTEND
 
   void onDrawStepsE(MenuItemClass* menuitem, int8_t line) {
     if (HMI_IsChinese()) {
       menuitem->SetFrame(1, 153, 148, 194, 161);
       DWIN_Frame_AreaCopy(1,  18, 150,  25, 160, LBLX + 44, MBASE(line));    // E
     }
     onDrawPFloatMenu(menuitem, line);
   }
 
 #endif
 
 #if HAS_ONESTEP_LEVELING
   void onDrawManualTramming(MenuItemClass* menuitem, int8_t line) { onDrawChkbMenu(menuitem, line, HMI_data.FullManualTramming); }
 #endif
 
 // Menu Creation and Drawing functions ======================================================
 
 frame_rect_t selrect(frame_rect_t) {
-  if (HMI_IsChinese())
-    return {133, 1, 28, 13};
-  else
-    return{0};
+  return HMI_IsChinese() ? frame_rect_t({ 133, 1, 28, 13 }) : frame_rect_t({ 0 });
 }
 
 void Draw_Prepare_Menu() {
   checkkey = Menu;
   if (SET_MENU_R(PrepareMenu, selrect({133, 1, 28, 13}), MSG_PREPARE, 10 + PREHEAT_COUNT)) {
     BACK_ITEM(Goto_Main_Menu);
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
       MENU_ITEM(ICON_FilMan, MSG_FILAMENT_MAN, onDrawSubMenu, Draw_FilamentMan_Menu);
     #endif
     MENU_ITEM(ICON_Axis, MSG_MOVE_AXIS, onDrawMoveSubMenu, Draw_Move_Menu);
@@ -3140,56 +3152,74 @@ void Draw_AdvancedSettings_Menu() {
   }
   ui.reset_status(true);
   UpdateMenu(AdvancedSettings);
 }
 
 void Draw_Move_Menu() {
   checkkey = Menu;
   if (SET_MENU_R(MoveMenu, selrect({192, 1, 42, 14}), MSG_MOVE_AXIS, 6)) {
     BACK_ITEM(Draw_Prepare_Menu);
     EDIT_ITEM(ICON_Axis, MSG_LIVE_MOVE, onDrawChkbMenu, SetLiveMove, &EnableLiveMove);
-    EDIT_ITEM(ICON_MoveX, MSG_MOVE_X, onDrawMoveX, SetMoveX, &current_position.x);
-    EDIT_ITEM(ICON_MoveY, MSG_MOVE_Y, onDrawMoveY, SetMoveY, &current_position.y);
-    EDIT_ITEM(ICON_MoveZ, MSG_MOVE_Z, onDrawMoveZ, SetMoveZ, &current_position.z);
+    #if HAS_X_AXIS
+      EDIT_ITEM(ICON_MoveX, MSG_MOVE_X, onDrawMoveX, SetMoveX, &current_position.x);
+    #endif
+    #if HAS_Y_AXIS
+      EDIT_ITEM(ICON_MoveY, MSG_MOVE_Y, onDrawMoveY, SetMoveY, &current_position.y);
+    #endif
+    #if HAS_Z_AXIS
+      EDIT_ITEM(ICON_MoveZ, MSG_MOVE_Z, onDrawMoveZ, SetMoveZ, &current_position.z);
+    #endif
     #if HAS_HOTEND
       gcode.process_subcommands_now(F("G92E0"));  // reset extruder position
       EDIT_ITEM(ICON_Extruder, MSG_MOVE_E, onDrawMoveE, SetMoveE, &current_position.e);
     #endif
   }
   UpdateMenu(MoveMenu);
   if (!all_axes_trusted()) LCD_MESSAGE_F("WARNING: Current position unknown. Home axes.");
 }
 
 #if HAS_HOME_OFFSET
 
   void Draw_HomeOffset_Menu() {
     checkkey = Menu;
     if (SET_MENU(HomeOffMenu, MSG_SET_HOME_OFFSETS, 4)) {
       BACK_ITEM(Draw_PhySet_Menu);
-      EDIT_ITEM(ICON_HomeOffsetX, MSG_HOME_OFFSET_X, onDrawPFloatMenu, SetHomeOffsetX, &home_offset.x);
-      EDIT_ITEM(ICON_HomeOffsetY, MSG_HOME_OFFSET_Y, onDrawPFloatMenu, SetHomeOffsetY, &home_offset.y);
-      EDIT_ITEM(ICON_HomeOffsetZ, MSG_HOME_OFFSET_Z, onDrawPFloatMenu, SetHomeOffsetZ, &home_offset.z);
+      #if HAS_X_AXIS
+        EDIT_ITEM(ICON_HomeOffsetX, MSG_HOME_OFFSET_X, onDrawPFloatMenu, SetHomeOffsetX, &home_offset.x);
+      #endif
+      #if HAS_Y_AXIS
+        EDIT_ITEM(ICON_HomeOffsetY, MSG_HOME_OFFSET_Y, onDrawPFloatMenu, SetHomeOffsetY, &home_offset.y);
+      #endif
+      #if HAS_Z_AXIS
+        EDIT_ITEM(ICON_HomeOffsetZ, MSG_HOME_OFFSET_Z, onDrawPFloatMenu, SetHomeOffsetZ, &home_offset.z);
+      #endif
     }
     UpdateMenu(HomeOffMenu);
   }
 
 #endif
 
 #if HAS_BED_PROBE
 
   void Draw_ProbeSet_Menu() {
     checkkey = Menu;
     if (SET_MENU(ProbeSetMenu, MSG_ZPROBE_SETTINGS, 9)) {
       BACK_ITEM(Draw_AdvancedSettings_Menu);
-      EDIT_ITEM(ICON_ProbeOffsetX, MSG_ZPROBE_XOFFSET, onDrawPFloatMenu, SetProbeOffsetX, &probe.offset.x);
-      EDIT_ITEM(ICON_ProbeOffsetY, MSG_ZPROBE_YOFFSET, onDrawPFloatMenu, SetProbeOffsetY, &probe.offset.y);
-      EDIT_ITEM(ICON_ProbeOffsetZ, MSG_ZPROBE_ZOFFSET, onDrawPFloat2Menu, SetProbeOffsetZ, &probe.offset.z);
+      #if HAS_X_AXIS
+        EDIT_ITEM(ICON_ProbeOffsetX, MSG_ZPROBE_XOFFSET, onDrawPFloatMenu, SetProbeOffsetX, &probe.offset.x);
+      #endif
+      #if HAS_Y_AXIS
+        EDIT_ITEM(ICON_ProbeOffsetY, MSG_ZPROBE_YOFFSET, onDrawPFloatMenu, SetProbeOffsetY, &probe.offset.y);
+      #endif
+      #if HAS_Z_AXIS
+        EDIT_ITEM(ICON_ProbeOffsetZ, MSG_ZPROBE_ZOFFSET, onDrawPFloat2Menu, SetProbeOffsetZ, &probe.offset.z);
+      #endif
       #if ENABLED(BLTOUCH)
         MENU_ITEM(ICON_ProbeStow, MSG_MANUAL_STOW, onDrawMenuItem, ProbeStow);
         MENU_ITEM(ICON_ProbeDeploy, MSG_MANUAL_DEPLOY, onDrawMenuItem, ProbeDeploy);
         MENU_ITEM(ICON_BltouchReset, MSG_BLTOUCH_RESET, onDrawMenuItem, bltouch._reset);
         #if HAS_BLTOUCH_HS_MODE
           EDIT_ITEM(ICON_HSMode, MSG_ENABLE_HS_MODE, onDrawChkbMenu, SetHSMode, &bltouch.high_speed_mode);
         #endif
       #endif
       MENU_ITEM(ICON_ProbeTest, MSG_M48_TEST, onDrawMenuItem, ProbeTest);
     }
@@ -3424,21 +3454,21 @@ void Draw_Motion_Menu() {
       #endif
       #if ENABLED(EEPROM_SETTINGS)
         MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawWriteEeprom, WriteEeprom);
       #endif
     }
     UpdateMenu(PreheatMenu);
   }
 
   #define _Preheat_Menu(N) \
     void Draw_Preheat## N ##_Menu() { \
-      HMI_value.Select = N-1; \
+      HMI_value.Select = (N) - 1; \
       Draw_Preheat_Menu(SET_MENU(PreheatMenu, MSG_PREHEAT_## N ##_SETTINGS, 5)); \
     }
   REPEAT_1(PREHEAT_COUNT, _Preheat_Menu)
 
 #endif // HAS_PREHEAT
 
 void Draw_Temperature_Menu() {
   checkkey = Menu;
   if (SET_MENU_R(TemperatureMenu, selrect({236, 2, 28, 12}), MSG_TEMPERATURE, 4 + PREHEAT_COUNT)) {
     BACK_ITEM(Draw_Control_Menu);
@@ -3456,69 +3486,93 @@ void Draw_Temperature_Menu() {
       REPEAT_1(PREHEAT_COUNT, _ITEM_SETPREHEAT)
     #endif
   }
   UpdateMenu(TemperatureMenu);
 }
 
 void Draw_MaxSpeed_Menu() {
   checkkey = Menu;
   if (SET_MENU_R(MaxSpeedMenu, selrect({1, 16, 28, 13}), MSG_MAX_SPEED, 5)) {
     BACK_ITEM(Draw_Motion_Menu);
-    EDIT_ITEM(ICON_MaxSpeedX, MSG_VMAX_A, onDrawMaxSpeedX, SetMaxSpeedX, &planner.settings.max_feedrate_mm_s[X_AXIS]);
-    EDIT_ITEM(ICON_MaxSpeedY, MSG_VMAX_B, onDrawMaxSpeedY, SetMaxSpeedY, &planner.settings.max_feedrate_mm_s[Y_AXIS]);
-    EDIT_ITEM(ICON_MaxSpeedZ, MSG_VMAX_C, onDrawMaxSpeedZ, SetMaxSpeedZ, &planner.settings.max_feedrate_mm_s[Z_AXIS]);
+    #if HAS_X_AXIS
+      EDIT_ITEM(ICON_MaxSpeedX, MSG_VMAX_A, onDrawMaxSpeedX, SetMaxSpeedX, &planner.settings.max_feedrate_mm_s[X_AXIS]);
+    #endif
+    #if HAS_Y_AXIS
+      EDIT_ITEM(ICON_MaxSpeedY, MSG_VMAX_B, onDrawMaxSpeedY, SetMaxSpeedY, &planner.settings.max_feedrate_mm_s[Y_AXIS]);
+    #endif
+    #if HAS_Z_AXIS
+      EDIT_ITEM(ICON_MaxSpeedZ, MSG_VMAX_C, onDrawMaxSpeedZ, SetMaxSpeedZ, &planner.settings.max_feedrate_mm_s[Z_AXIS]);
+    #endif
     #if HAS_HOTEND
       EDIT_ITEM(ICON_MaxSpeedE, MSG_VMAX_E, onDrawMaxSpeedE, SetMaxSpeedE, &planner.settings.max_feedrate_mm_s[E_AXIS]);
     #endif
   }
   UpdateMenu(MaxSpeedMenu);
 }
 
 void Draw_MaxAccel_Menu() {
   checkkey = Menu;
   if (SET_MENU_R(MaxAccelMenu, selrect({1, 16, 28, 13}), MSG_AMAX_EN, 5)) {
     BACK_ITEM(Draw_Motion_Menu);
-    EDIT_ITEM(ICON_MaxAccX, MSG_AMAX_A, onDrawMaxAccelX, SetMaxAccelX, &planner.settings.max_acceleration_mm_per_s2[X_AXIS]);
-    EDIT_ITEM(ICON_MaxAccY, MSG_AMAX_B, onDrawMaxAccelY, SetMaxAccelY, &planner.settings.max_acceleration_mm_per_s2[Y_AXIS]);
-    EDIT_ITEM(ICON_MaxAccZ, MSG_AMAX_C, onDrawMaxAccelZ, SetMaxAccelZ, &planner.settings.max_acceleration_mm_per_s2[Z_AXIS]);
+    #if HAS_X_AXIS
+      EDIT_ITEM(ICON_MaxAccX, MSG_AMAX_A, onDrawMaxAccelX, SetMaxAccelX, &planner.settings.max_acceleration_mm_per_s2[X_AXIS]);
+    #endif
+    #if HAS_Y_AXIS
+      EDIT_ITEM(ICON_MaxAccY, MSG_AMAX_B, onDrawMaxAccelY, SetMaxAccelY, &planner.settings.max_acceleration_mm_per_s2[Y_AXIS]);
+    #endif
+    #if HAS_Z_AXIS
+      EDIT_ITEM(ICON_MaxAccZ, MSG_AMAX_C, onDrawMaxAccelZ, SetMaxAccelZ, &planner.settings.max_acceleration_mm_per_s2[Z_AXIS]);
+    #endif
     #if HAS_HOTEND
       EDIT_ITEM(ICON_MaxAccE, MSG_AMAX_E, onDrawMaxAccelE, SetMaxAccelE, &planner.settings.max_acceleration_mm_per_s2[E_AXIS]);
     #endif
   }
   UpdateMenu(MaxAccelMenu);
 }
 
 #if HAS_CLASSIC_JERK
 
   void Draw_MaxJerk_Menu() {
     checkkey = Menu;
     if (SET_MENU_R(MaxJerkMenu, selrect({1, 16, 28, 13}), MSG_JERK, 5)) {
       BACK_ITEM(Draw_Motion_Menu);
-      EDIT_ITEM(ICON_MaxSpeedJerkX, MSG_VA_JERK, onDrawMaxJerkX, SetMaxJerkX, &planner.max_jerk.x);
-      EDIT_ITEM(ICON_MaxSpeedJerkY, MSG_VB_JERK, onDrawMaxJerkY, SetMaxJerkY, &planner.max_jerk.y);
-      EDIT_ITEM(ICON_MaxSpeedJerkZ, MSG_VC_JERK, onDrawMaxJerkZ, SetMaxJerkZ, &planner.max_jerk.z);
+      #if HAS_X_AXIS
+        EDIT_ITEM(ICON_MaxSpeedJerkX, MSG_VA_JERK, onDrawMaxJerkX, SetMaxJerkX, &planner.max_jerk.x);
+      #endif
+      #if HAS_Y_AXIS
+        EDIT_ITEM(ICON_MaxSpeedJerkY, MSG_VB_JERK, onDrawMaxJerkY, SetMaxJerkY, &planner.max_jerk.y);
+      #endif
+      #if HAS_Z_AXIS
+        EDIT_ITEM(ICON_MaxSpeedJerkZ, MSG_VC_JERK, onDrawMaxJerkZ, SetMaxJerkZ, &planner.max_jerk.z);
+      #endif
       #if HAS_HOTEND
         EDIT_ITEM(ICON_MaxSpeedJerkE, MSG_VE_JERK, onDrawMaxJerkE, SetMaxJerkE, &planner.max_jerk.e);
       #endif
     }
     UpdateMenu(MaxJerkMenu);
   }
 
 #endif // HAS_CLASSIC_JERK
 
 void Draw_Steps_Menu() {
   checkkey = Menu;
   if (SET_MENU_R(StepsMenu, selrect({1, 16, 28, 13}), MSG_STEPS_PER_MM, 5)) {
     BACK_ITEM(Draw_Motion_Menu);
-    EDIT_ITEM(ICON_StepX, MSG_A_STEPS, onDrawStepsX, SetStepsX, &planner.settings.axis_steps_per_mm[X_AXIS]);
-    EDIT_ITEM(ICON_StepY, MSG_B_STEPS, onDrawStepsY, SetStepsY, &planner.settings.axis_steps_per_mm[Y_AXIS]);
-    EDIT_ITEM(ICON_StepZ, MSG_C_STEPS, onDrawStepsZ, SetStepsZ, &planner.settings.axis_steps_per_mm[Z_AXIS]);
+    #if HAS_X_AXIS
+      EDIT_ITEM(ICON_StepX, MSG_A_STEPS, onDrawStepsX, SetStepsX, &planner.settings.axis_steps_per_mm[X_AXIS]);
+    #endif
+    #if HAS_Y_AXIS
+      EDIT_ITEM(ICON_StepY, MSG_B_STEPS, onDrawStepsY, SetStepsY, &planner.settings.axis_steps_per_mm[Y_AXIS]);
+    #endif
+    #if HAS_Z_AXIS
+      EDIT_ITEM(ICON_StepZ, MSG_C_STEPS, onDrawStepsZ, SetStepsZ, &planner.settings.axis_steps_per_mm[Z_AXIS]);
+    #endif
     #if HAS_HOTEND
       EDIT_ITEM(ICON_StepE, MSG_E_STEPS, onDrawStepsE, SetStepsE, &planner.settings.axis_steps_per_mm[E_AXIS]);
     #endif
   }
   UpdateMenu(StepsMenu);
 }
 
 #if ENABLED(PIDTEMP)
 
   void Draw_HotendPID_Menu() {
@@ -3617,23 +3671,29 @@ void Draw_Steps_Menu() {
 
 #endif
 
 #if ENABLED(INDIVIDUAL_AXIS_HOMING_SUBMENU)
 
   void Draw_Homing_Menu() {
     checkkey = Menu;
     if (SET_MENU(HomingMenu, MSG_HOMING, 6)) {
       BACK_ITEM(Draw_Prepare_Menu);
       MENU_ITEM(ICON_Homing, MSG_AUTO_HOME, onDrawMenuItem, AutoHome);
-      MENU_ITEM(ICON_HomeX, MSG_AUTO_HOME_X, onDrawMenuItem, HomeX);
-      MENU_ITEM(ICON_HomeY, MSG_AUTO_HOME_Y, onDrawMenuItem, HomeY);
-      MENU_ITEM(ICON_HomeZ, MSG_AUTO_HOME_Z, onDrawMenuItem, HomeZ);
+      #if HAS_X_AXIS
+        MENU_ITEM(ICON_HomeX, MSG_AUTO_HOME_X, onDrawMenuItem, HomeX);
+      #endif
+      #if HAS_Y_AXIS
+        MENU_ITEM(ICON_HomeY, MSG_AUTO_HOME_Y, onDrawMenuItem, HomeY);
+      #endif
+      #if HAS_Z_AXIS
+        MENU_ITEM(ICON_HomeZ, MSG_AUTO_HOME_Z, onDrawMenuItem, HomeZ);
+      #endif
       #if ENABLED(MESH_BED_LEVELING)
         EDIT_ITEM(ICON_ZAfterHome, MSG_Z_AFTER_HOME, onDrawPInt8Menu, SetZAfterHoming, &HMI_data.z_after_homing);
       #endif
     }
     UpdateMenu(HomingMenu);
   }
 
 #endif
 
 #if ENABLED(FWRETRACT)

commit e66cd41654a3ca299acd2111daefe50c255f67ac
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Mon May 15 09:29:35 2023 +1200

    üêõ Safe Delay for ProUI startup animation (#25827)

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index f3a23ae1e4..8bd0a67b9b 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -1228,21 +1228,21 @@ void HMI_Init() {
   #if ENABLED(SHOW_BOOTSCREEN)
     #ifndef BOOTSCREEN_TIMEOUT
       #define BOOTSCREEN_TIMEOUT 1100
     #endif
     DWINUI::Draw_Box(1, Color_Black, { 5, 220, DWIN_WIDTH - 5, DWINUI::fontHeight() });
     DWINUI::Draw_CenteredString(Color_White, 220, F("Professional Firmware "));
     for (uint16_t t = 15; t < 257; t += 11) {
       DWINUI::Draw_Icon(ICON_Bar, 15, 260);
       DWIN_Draw_Rectangle(1, HMI_data.Background_Color, t, 260, 257, 280);
       DWIN_UpdateLCD();
-      delay((BOOTSCREEN_TIMEOUT) / 22);
+      safe_delay((BOOTSCREEN_TIMEOUT) / 22);
     }
   #endif
   HMI_SetLanguage();
 }
 
 void EachMomentUpdate() {
   static millis_t next_var_update_ms = 0, next_rts_update_ms = 0, next_status_update_ms = 0;
   const millis_t ms = millis();
 
   if (ELAPSED(ms, next_var_update_ms)) {

commit 4528fde7f9255eb90fc9b9a44e35a04efb764742
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 6 14:56:22 2023 -0500

    üîß Apply bootscreen settings to ProUI

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index a372ae5b4d..f3a23ae1e4 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -1218,28 +1218,33 @@ void HMI_WaitForUser() {
         case Leveling:
       #endif
       default:
         HMI_ReturnScreen();
         break;
     }
   }
 }
 
 void HMI_Init() {
-  DWINUI::Draw_Box(1, Color_Black, { 5, 220, DWIN_WIDTH - 5, DWINUI::fontHeight() });
-  DWINUI::Draw_CenteredString(Color_White, 220, F("Professional Firmware "));
-  for (uint16_t t = 15; t <= 257; t += 10) {
-    DWINUI::Draw_Icon(ICON_Bar, 15, 260);
-    DWIN_Draw_Rectangle(1, HMI_data.Background_Color, t, 260, 257, 280);
-    DWIN_UpdateLCD();
-    delay(50);
-  }
+  #if ENABLED(SHOW_BOOTSCREEN)
+    #ifndef BOOTSCREEN_TIMEOUT
+      #define BOOTSCREEN_TIMEOUT 1100
+    #endif
+    DWINUI::Draw_Box(1, Color_Black, { 5, 220, DWIN_WIDTH - 5, DWINUI::fontHeight() });
+    DWINUI::Draw_CenteredString(Color_White, 220, F("Professional Firmware "));
+    for (uint16_t t = 15; t < 257; t += 11) {
+      DWINUI::Draw_Icon(ICON_Bar, 15, 260);
+      DWIN_Draw_Rectangle(1, HMI_data.Background_Color, t, 260, 257, 280);
+      DWIN_UpdateLCD();
+      delay((BOOTSCREEN_TIMEOUT) / 22);
+    }
+  #endif
   HMI_SetLanguage();
 }
 
 void EachMomentUpdate() {
   static millis_t next_var_update_ms = 0, next_rts_update_ms = 0, next_status_update_ms = 0;
   const millis_t ms = millis();
 
   if (ELAPSED(ms, next_var_update_ms)) {
     next_var_update_ms = ms + DWIN_VAR_UPDATE_INTERVAL;
     blink = !blink;

commit 9a7d9e6995f4f66c4b48147ec7876d49d4b3ae77
Author: Martin Turski <turningtides@outlook.de>
Date:   Thu Apr 27 14:05:24 2023 +0200

    üßë‚Äçüíª Optimize PlatformIO source filtering (#25332)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index af157921d5..a372ae5b4d 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -24,21 +24,21 @@
  * DWIN Enhanced implementation for PRO UI
  * Author: Miguel A. Risco-Castillo (MRISCOC)
  * Version: 3.21.2
  * Date: 2022/12/02
  */
 
 #include "../../../inc/MarlinConfig.h"
 
 #if ENABLED(DWIN_LCD_PROUI)
 
-#include "../../fontutils.h"
+#include "../../utf8.h"
 #include "../../marlinui.h"
 
 #include "../../../sd/cardreader.h"
 
 #include "../../../MarlinCore.h"
 #include "../../../core/serial.h"
 #include "../../../core/macros.h"
 
 #include "../../../module/temperature.h"
 #include "../../../module/printcounter.h"

commit f5c7b190f6169f0a213ef4b088e9c4b5ef33b2b8
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Apr 11 23:22:36 2023 -0500

    üêõ Fix BLTOUCH_HS_MODE config

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index adc6fca72a..af157921d5 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -2204,24 +2204,22 @@ void SetMoveZ() { HMI_value.axis = Z_AXIS; SetPFloatOnClick(Z_MIN_POS, Z_MAX_POS
   void SetProbeOffsetX() { SetPFloatOnClick(-60, 60, UNITFDIGITS); }
   void SetProbeOffsetY() { SetPFloatOnClick(-60, 60, UNITFDIGITS); }
   void SetProbeOffsetZ() { SetPFloatOnClick(-10, 10, 2); }
   void ProbeTest() {
     LCD_MESSAGE(MSG_M48_TEST);
     queue.inject(F("G28O\nM48 P10"));
   }
   void ProbeStow() { probe.stow(); }
   void ProbeDeploy() { probe.deploy(); }
 
-  #if ENABLED(BLTOUCH_HS_MODE)
-    void SetHSMode() {
-      Toggle_Chkb_Line(bltouch.high_speed_mode);
-    }
+  #if HAS_BLTOUCH_HS_MODE
+    void SetHSMode() { Toggle_Chkb_Line(bltouch.high_speed_mode); }
   #endif
 
 #endif
 
 #if HAS_FILAMENT_SENSOR
   void SetRunoutEnable() {
     runout.reset();
     Toggle_Chkb_Line(runout.enabled);
   }
   #if HAS_FILAMENT_RUNOUT_DISTANCE
@@ -3177,21 +3175,21 @@ void Draw_Move_Menu() {
     checkkey = Menu;
     if (SET_MENU(ProbeSetMenu, MSG_ZPROBE_SETTINGS, 9)) {
       BACK_ITEM(Draw_AdvancedSettings_Menu);
       EDIT_ITEM(ICON_ProbeOffsetX, MSG_ZPROBE_XOFFSET, onDrawPFloatMenu, SetProbeOffsetX, &probe.offset.x);
       EDIT_ITEM(ICON_ProbeOffsetY, MSG_ZPROBE_YOFFSET, onDrawPFloatMenu, SetProbeOffsetY, &probe.offset.y);
       EDIT_ITEM(ICON_ProbeOffsetZ, MSG_ZPROBE_ZOFFSET, onDrawPFloat2Menu, SetProbeOffsetZ, &probe.offset.z);
       #if ENABLED(BLTOUCH)
         MENU_ITEM(ICON_ProbeStow, MSG_MANUAL_STOW, onDrawMenuItem, ProbeStow);
         MENU_ITEM(ICON_ProbeDeploy, MSG_MANUAL_DEPLOY, onDrawMenuItem, ProbeDeploy);
         MENU_ITEM(ICON_BltouchReset, MSG_BLTOUCH_RESET, onDrawMenuItem, bltouch._reset);
-        #if ENABLED(BLTOUCH_HS_MODE)
+        #if HAS_BLTOUCH_HS_MODE
           EDIT_ITEM(ICON_HSMode, MSG_ENABLE_HS_MODE, onDrawChkbMenu, SetHSMode, &bltouch.high_speed_mode);
         #endif
       #endif
       MENU_ITEM(ICON_ProbeTest, MSG_M48_TEST, onDrawMenuItem, ProbeTest);
     }
     UpdateMenu(ProbeSetMenu);
   }
 
 #endif
 

commit 06e5273d24776219253a9229621c034ab263cba7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 31 18:18:25 2023 -0500

    üßë‚Äçüíª CardReader adjustments (#25611)

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index b0d1fb3ff6..adc6fca72a 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -837,21 +837,21 @@ void update_variable() {
  * Memory card and file management
  */
 
 bool DWIN_lcd_sd_status = false;
 
 void SetMediaAutoMount() {
   Toggle_Chkb_Line(HMI_data.MediaAutoMount);
 }
 
 inline uint16_t nr_sd_menu_items() {
-  return _MIN(card.get_num_Files() + !card.flag.workDirIsRoot, MENU_MAX_ITEMS);
+  return _MIN(card.get_num_items() + !card.flag.workDirIsRoot, MENU_MAX_ITEMS);
 }
 
 void make_name_without_ext(char *dst, char *src, size_t maxlen=MENU_CHAR_LIMIT) {
   size_t pos = strlen(src);  // index of ending nul
 
   // For files, remove the extension
   // which may be .gcode, .gco, or .g
   if (!card.flag.filenameIsDir)
     while (pos && src[pos] != '.') pos--; // find last '.' (stop at 0)
 
@@ -884,21 +884,21 @@ void SDCard_Up() {
 void SDCard_Folder(char * const dirname) {
   card.cd(dirname);
   DWIN_lcd_sd_status = false; // On next DWIN_Update
 }
 
 void onClickSDItem() {
   const uint16_t hasUpDir = !card.flag.workDirIsRoot;
   if (hasUpDir && CurrentMenu->selected == 1) return SDCard_Up();
   else {
     const uint16_t filenum = CurrentMenu->selected - 1 - hasUpDir;
-    card.getfilename_sorted(SD_ORDER(filenum, card.get_num_Files()));
+    card.selectFileByIndexSorted(filenum);
 
     // Enter that folder!
     if (card.flag.filenameIsDir) return SDCard_Folder(card.filename);
 
     if (card.fileIsBinary())
       return DWIN_Popup_Confirm(ICON_Error, F("Please check filenames"), F("Only G-code can be printed"));
     else
       return Goto_ConfirmToPrint();
   }
 }
@@ -927,21 +927,21 @@ void onClickSDItem() {
       last_itemselected = 0;
       hasUpDir = !card.flag.workDirIsRoot; // is a SubDir
       return;
     }
     const uint8_t selected = FileMenu->selected;
     if (last_itemselected != selected) {
       if (last_itemselected >= 1 + hasUpDir) FileMenu->Items()[last_itemselected]->redraw(true);
       last_itemselected = selected;
       if (selected >= 1 + hasUpDir) {
         const int8_t filenum = selected - 1 - hasUpDir; // Skip "Back" and ".."
-        card.getfilename_sorted(SD_ORDER(filenum, card.get_num_Files()));
+        card.selectFileByIndexSorted(filenum);
         make_name_without_ext(shift_name, card.longest_filename(), LONG_FILENAME_LENGTH);
         shift_len = strlen(shift_name);
         shift_amt = 0;
       }
     }
     else if ((selected >= 1 + hasUpDir) && (shift_len > MENU_CHAR_LIMIT)) {
       uint8_t shift_new = _MIN(shift_amt + 1, shift_len - MENU_CHAR_LIMIT); // Try to shift by...
       Draw_SDItem_Shifted(shift_new);             // Draw the item
       if (shift_new == shift_amt)                 // Scroll reached the end
         shift_new = -1;                           // Reset
@@ -952,21 +952,21 @@ void onClickSDItem() {
   char shift_name[FILENAME_LENGTH + 1] = "";
 #endif
 
 void onDrawFileName(MenuItemClass* menuitem, int8_t line) {
   const bool is_subdir = !card.flag.workDirIsRoot;
   if (is_subdir && menuitem->pos == 1) {
     Draw_Menu_Line(line, ICON_Folder, "..");
   }
   else {
     uint8_t icon;
-    card.getfilename_sorted(SD_ORDER(menuitem->pos - is_subdir - 1, card.get_num_Files()));
+    card.selectFileByIndexSorted(menuitem->pos - is_subdir - 1);
     make_name_without_ext(shift_name, card.longest_filename());
     icon = card.flag.filenameIsDir ? ICON_Folder : card.fileIsBinary() ? ICON_Binary : ICON_File;
     Draw_Menu_Line(line, icon, shift_name);
   }
 }
 
 void Draw_Print_File_Menu() {
   checkkey = Menu;
   if (card.isMounted()) {
     if (SET_MENU(FileMenu, MSG_MEDIA_MENU, nr_sd_menu_items() + 1)) {

commit b5836b243ac9321841daa9380d55b298375aaa2e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 17 20:12:36 2023 -0500

    üîß Optional MPC_AUTOTUNE to save 5.5 - 5.8KB

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 6be56b0ded..b0d1fb3ff6 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -259,21 +259,21 @@ MenuClass *FilamentMenu = nullptr;
 #if HAS_HOTEND
   MenuClass *PreheatMenu = nullptr;
 #endif
 MenuClass *TemperatureMenu = nullptr;
 MenuClass *MaxSpeedMenu = nullptr;
 MenuClass *MaxAccelMenu = nullptr;
 #if HAS_CLASSIC_JERK
   MenuClass *MaxJerkMenu = nullptr;
 #endif
 MenuClass *StepsMenu = nullptr;
-#if ENABLED(MPCTEMP)
+#if EITHER(MPC_EDIT_MENU, MPC_AUTOTUNE_MENU)
   MenuClass *HotendMPCMenu = nullptr;
 #endif
 #if ENABLED(PIDTEMP)
   MenuClass *HotendPIDMenu = nullptr;
 #endif
 #if ENABLED(PIDTEMPBED)
   MenuClass *BedPIDMenu = nullptr;
 #endif
 #if ENABLED(CASELIGHT_USES_BRIGHTNESS)
   MenuClass *CaseLightMenu = nullptr;
@@ -1473,60 +1473,73 @@ void DWIN_LevelingDone() {
 #if SHOW_TUNING_GRAPH
 
   #include "plot.h"
 
   celsius_t _maxtemp, _target;
   void DWIN_Draw_PID_MPC_Popup() {
     constexpr frame_rect_t gfrm = { 40, 180, DWIN_WIDTH - 80, 120 };
     DWINUI::ClearMainArea();
     Draw_Popup_Bkgd();
 
-    #if ENABLED(MPCTEMP)
-
-      switch (HMI_value.pidresult) {
+    switch (HMI_value.pidresult) {
+      default: return;
+      #if ENABLED(MPC_AUTOTUNE)
         case MPCTEMP_START:
-          _maxtemp = thermalManager.hotend_maxtemp[0];
-          _target = 200;
           DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 100, GET_TEXT_F(MSG_MPC_AUTOTUNE));
           DWINUI::Draw_String(HMI_data.PopupTxt_Color, gfrm.x, gfrm.y - DWINUI::fontHeight() - 4, F("MPC target:    Celsius"));
-          DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 120, F("for Nozzle is running."));
           break;
-        case PIDTEMPBED_START:
-          _maxtemp = BED_MAXTEMP;
-          _target = HMI_data.BedPidT;
+      #endif
+      #if EITHER(PIDTEMP, PIDTEMPBED)
+        TERN_(PIDTEMP,    case PIDTEMP_START:)
+        TERN_(PIDTEMPBED, case PIDTEMPBED_START:)
           DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 100, GET_TEXT_F(MSG_PID_AUTOTUNE));
           DWINUI::Draw_String(HMI_data.PopupTxt_Color, gfrm.x, gfrm.y - DWINUI::fontHeight() - 4, F("PID target:    Celsius"));
-          DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 120, F("for BED is running."));
           break;
-        default: return;
-      }
-
-    #else // PID
+      #endif
+    }
 
-      DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 100, GET_TEXT_F(MSG_PID_AUTOTUNE));
-      DWINUI::Draw_String(HMI_data.PopupTxt_Color, gfrm.x, gfrm.y - DWINUI::fontHeight() - 4, F("PID target:    Celsius"));
+    switch (HMI_value.pidresult) {
+      default: break;
+      #if EITHER(PIDTEMP, MPC_AUTOTUNE)
+        TERN_(PIDTEMP,      case PIDTEMP_START:)
+        TERN_(MPC_AUTOTUNE, case MPCTEMP_START:)
+          DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 120, F("for Nozzle is running."));
+          break;
+      #endif
+      #if ENABLED(PIDTEMPBED)
+        case PIDTEMPBED_START:
+          DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 120, F("for BED is running."));
+          break;
+      #endif
+    }
 
-      switch (HMI_value.pidresult) {
+    switch (HMI_value.pidresult) {
+      default: break;
+      #if ENABLED(MPC_AUTOTUNE)
+        case MPCTEMP_START:
+          _maxtemp = thermalManager.hotend_maxtemp[0];
+          _target = 200;
+          break;
+      #endif
+      #if ENABLED(PIDTEMP)
         case PIDTEMP_START:
           _maxtemp = thermalManager.hotend_maxtemp[0];
           _target = HMI_data.HotendPidT;
-          DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 120, F("for Nozzle is running."));
           break;
+      #endif
+      #if ENABLED(PIDTEMPBED)
         case PIDTEMPBED_START:
           _maxtemp = BED_MAXTEMP;
           _target = HMI_data.BedPidT;
-          DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 120, F("for BED is running."));
           break;
-        default: return;
-      }
-
-    #endif // PID
+      #endif
+    }
 
     plot.Draw(gfrm, _maxtemp, _target);
     DWINUI::Draw_Int(HMI_data.PopupTxt_Color, 3, gfrm.x + 90, gfrm.y - DWINUI::fontHeight() - 4, _target);
   }
 
 #endif // SHOW_TUNING_GRAPH
 
 #if DWIN_PID_TUNE
 
   void DWIN_StartM303(const bool seenC, const int c, const bool seenS, const heater_id_t hid, const celsius_t temp) {
@@ -1580,56 +1593,56 @@ void DWIN_LevelingDone() {
         DWIN_Popup_Confirm(ICON_TempTooLow, GET_TEXT_F(MSG_PID_AUTOTUNE), GET_TEXT_F(MSG_BUTTON_DONE));
         break;
       default:
         checkkey = last_checkkey;
         break;
     }
   }
 
 #endif // DWIN_PID_TUNE
 
-#if ENABLED(MPCTEMP)
+#if ENABLED(MPC_AUTOTUNE)
 
   void DWIN_MPCTuning(tempcontrol_t result) {
     HMI_value.pidresult = result;
     switch (result) {
       case MPCTEMP_START:
         HMI_SaveProcessID(MPCProcess);
         #if SHOW_TUNING_GRAPH
           DWIN_Draw_PID_MPC_Popup();
         #else
           DWIN_Draw_Popup(ICON_TempTooHigh, GET_TEXT_F(MSG_MPC_AUTOTUNE), F("for Nozzle is running."));
         #endif
         break;
       case MPC_TEMP_ERROR:
         checkkey = last_checkkey;
         DWIN_Popup_Confirm(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE_FAILED), F(STR_MPC_TEMPERATURE_ERROR));
         ui.reset_alert_level();
         break;
       case MPC_INTERRUPTED:
         checkkey = last_checkkey;
-        DWIN_Popup_Confirm(ICON_TempTooHigh, GET_TEXT_F(MSG_ERROR), F(STR_MPC_AUTOTUNE STR_MPC_AUTOTUNE_INTERRUPTED));
+        DWIN_Popup_Confirm(ICON_TempTooHigh, GET_TEXT_F(MSG_ERROR), F(STR_MPC_AUTOTUNE_INTERRUPTED));
         ui.reset_alert_level();
         break;
       case MPC_DONE:
         checkkey = last_checkkey;
         DWIN_Popup_Confirm(ICON_TempTooLow, GET_TEXT_F(MSG_MPC_AUTOTUNE), GET_TEXT_F(MSG_BUTTON_DONE));
         ui.reset_alert_level();
         break;
       default:
         checkkey = last_checkkey;
         ui.reset_alert_level();
         break;
     }
   }
 
-#endif // MPCTEMP
+#endif // MPC_AUTOTUNE
 
 // Started a Print Job
 void DWIN_Print_Started() {
   TERN_(HAS_GCODE_PREVIEW, if (Host_Printing()) Preview_Invalidate());
   _percent_done = 0;
   _remain_time = 0;
   HMI_flag.percent_flag = false;
   HMI_flag.remain_flag = false;
   HMI_flag.pause_flag = false;
   HMI_flag.abort_flag = false;
@@ -3083,22 +3096,22 @@ void Draw_AdvancedSettings_Menu() {
     #if HAS_MESH
       MENU_ITEM(ICON_ProbeSet, MSG_MESH_LEVELING, onDrawSubMenu, Draw_MeshSet_Menu);
     #endif
     #if HAS_BED_PROBE
       MENU_ITEM(ICON_ProbeSet, MSG_ZPROBE_SETTINGS, onDrawSubMenu, Draw_ProbeSet_Menu);
     #endif
     MENU_ITEM(ICON_FilSet, MSG_FILAMENT_SET, onDrawSubMenu, Draw_FilSet_Menu);
     #if ENABLED(PIDTEMP)
       MENU_ITEM_F(ICON_PIDNozzle, STR_HOTEND_PID " Settings", onDrawSubMenu, Draw_HotendPID_Menu);
     #endif
-    #if ENABLED(MPCTEMP)
-      MENU_ITEM_F(ICON_MPCNozzle, STR_MPC_AUTOTUNE " Settings", onDrawSubMenu, Draw_HotendMPC_Menu);
+    #if EITHER(MPC_EDIT_MENU, MPC_AUTOTUNE_MENU)
+      MENU_ITEM_F(ICON_MPCNozzle, "MPC Settings", onDrawSubMenu, Draw_HotendMPC_Menu);
     #endif
     #if ENABLED(PIDTEMPBED)
       MENU_ITEM_F(ICON_PIDBed, STR_BED_PID " Settings", onDrawSubMenu, Draw_BedPID_Menu);
     #endif
     #if HAS_ESDIAG
       MENU_ITEM_F(ICON_ESDiag, "End-stops diag.", onDrawSubMenu, Draw_EndStopDiag);
     #endif
     #if ENABLED(PRINTCOUNTER)
       MENU_ITEM(ICON_PrintStats, MSG_INFO_STATS_MENU, onDrawSubMenu, Goto_PrintStats);
       MENU_ITEM(ICON_PrintStatsReset, MSG_INFO_PRINT_COUNT_RESET, onDrawSubMenu, PrintStatsReset);
@@ -3517,51 +3530,59 @@ void Draw_Steps_Menu() {
       EDIT_ITEM(ICON_PIDCycles, MSG_PID_CYCLE, onDrawPIntMenu, SetPidCycles, &HMI_data.PidCycles);
       #if ENABLED(EEPROM_SETTINGS)
         MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawMenuItem, WriteEeprom);
       #endif
     }
     UpdateMenu(HotendPIDMenu);
   }
 
 #endif
 
-#if ENABLED(MPCTEMP)
+#if EITHER(MPC_EDIT_MENU, MPC_AUTOTUNE_MENU)
 
-  void HotendMPC() { thermalManager.MPC_autotune(active_extruder); }
-  void SetHeaterPower() { SetPFloatOnClick(1, 200, 1); }
-  void SetBlkHeatCapacity() { SetPFloatOnClick(0, 40, 2); }
-  void SetSensorRespons() { SetPFloatOnClick(0, 1, 4); }
-  void SetAmbientXfer() { SetPFloatOnClick(0, 1, 4); }
-  #if ENABLED(MPC_INCLUDE_FAN)
-    void onDrawFanAdj(MenuItemClass* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 4, thermalManager.temp_hotend[0].fanCoefficient()); }
-    void ApplyFanAdj() { thermalManager.temp_hotend[0].applyFanAdjustment(MenuData.Value / POW(10, 4)); }
-    void SetFanAdj() { SetFloatOnClick(0, 1, 4, thermalManager.temp_hotend[0].fanCoefficient(), ApplyFanAdj); }
+  #if ENABLED(MPC_AUTOTUNE_MENU)
+    void HotendMPC() { thermalManager.MPC_autotune(active_extruder); }
+  #endif
+  #if ENABLED(MPC_EDIT_MENU)
+    void SetHeaterPower() { SetPFloatOnClick(1, 200, 1); }
+    void SetBlkHeatCapacity() { SetPFloatOnClick(0, 40, 2); }
+    void SetSensorResponse() { SetPFloatOnClick(0, 1, 4); }
+    void SetAmbientXfer() { SetPFloatOnClick(0, 1, 4); }
+    #if ENABLED(MPC_INCLUDE_FAN)
+      void onDrawFanAdj(MenuItemClass* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 4, thermalManager.temp_hotend[0].fanCoefficient()); }
+      void ApplyFanAdj() { thermalManager.temp_hotend[0].applyFanAdjustment(MenuData.Value / POW(10, 4)); }
+      void SetFanAdj() { SetFloatOnClick(0, 1, 4, thermalManager.temp_hotend[0].fanCoefficient(), ApplyFanAdj); }
+    #endif
   #endif
 
   void Draw_HotendMPC_Menu() {
     checkkey = Menu;
-    if (SET_MENU_F(HotendMPCMenu, STR_MPC_AUTOTUNE " Settings", 7)) {
+    if (SET_MENU_F(HotendMPCMenu, "MPC Settings", 7)) {
       MPC_t &mpc = thermalManager.temp_hotend[0].mpc;
       BACK_ITEM(Draw_AdvancedSettings_Menu);
-      MENU_ITEM(ICON_MPCNozzle, MSG_MPC_AUTOTUNE, onDrawMenuItem, HotendMPC);
-      EDIT_ITEM(ICON_MPCHeater, MSG_MPC_POWER, onDrawPFloatMenu, SetHeaterPower, &mpc.heater_power);
-      EDIT_ITEM(ICON_MPCHeatCap, MSG_MPC_BLOCK_HEAT_CAPACITY, onDrawPFloat2Menu, SetBlkHeatCapacity, &mpc.block_heat_capacity);
-      EDIT_ITEM(ICON_MPCValue, MSG_SENSOR_RESPONSIVENESS, onDrawPFloat4Menu, SetSensorRespons, &mpc.sensor_responsiveness);
-      EDIT_ITEM(ICON_MPCValue, MSG_MPC_AMBIENT_XFER_COEFF, onDrawPFloat4Menu, SetAmbientXfer, &mpc.ambient_xfer_coeff_fan0);
-      #if ENABLED(MPC_INCLUDE_FAN)
-        EDIT_ITEM(ICON_MPCFan, MSG_MPC_AMBIENT_XFER_COEFF_FAN, onDrawFanAdj, SetFanAdj, &mpc.fan255_adjustment);
+      #if ENABLED(MPC_AUTOTUNE_MENU)
+        MENU_ITEM(ICON_MPCNozzle, MSG_MPC_AUTOTUNE, onDrawMenuItem, HotendMPC);
+      #endif
+      #if ENABLED(MPC_EDIT_MENU)
+        EDIT_ITEM(ICON_MPCHeater, MSG_MPC_POWER, onDrawPFloatMenu, SetHeaterPower, &mpc.heater_power);
+        EDIT_ITEM(ICON_MPCHeatCap, MSG_MPC_BLOCK_HEAT_CAPACITY, onDrawPFloat2Menu, SetBlkHeatCapacity, &mpc.block_heat_capacity);
+        EDIT_ITEM(ICON_MPCValue, MSG_SENSOR_RESPONSIVENESS, onDrawPFloat4Menu, SetSensorResponse, &mpc.sensor_responsiveness);
+        EDIT_ITEM(ICON_MPCValue, MSG_MPC_AMBIENT_XFER_COEFF, onDrawPFloat4Menu, SetAmbientXfer, &mpc.ambient_xfer_coeff_fan0);
+        #if ENABLED(MPC_INCLUDE_FAN)
+          EDIT_ITEM(ICON_MPCFan, MSG_MPC_AMBIENT_XFER_COEFF_FAN, onDrawFanAdj, SetFanAdj, &mpc.fan255_adjustment);
+        #endif
       #endif
     }
     UpdateMenu(HotendMPCMenu);
   }
 
-#endif // MPCTEMP
+#endif // MPC_EDIT_MENU || MPC_AUTOTUNE_MENU
 
 #if ENABLED(PIDTEMPBED)
 
   void Draw_BedPID_Menu() {
     checkkey = Menu;
     if (SET_MENU_F(BedPIDMenu, STR_BED_PID " Settings", 8)) {
       BACK_ITEM(Draw_AdvancedSettings_Menu);
       MENU_ITEM_F(ICON_PIDBed, STR_BED_PID, onDrawMenuItem,BedPID);
       EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KP, onDrawPFloat2Menu, SetKp, &thermalManager.temp_bed.pid.Kp);
       EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KI, onDrawPIDi, SetKi, &thermalManager.temp_bed.pid.Ki);

commit 96bc084f3d791bc93265f217181986863e8e5fc7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Feb 18 02:15:16 2023 -0600

    üé® Misc. LCD cleanup (#25400)

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index ae10f0e84e..6be56b0ded 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -1264,32 +1264,30 @@ void EachMomentUpdate() {
     #if ENABLED(SCROLL_LONG_FILENAMES)
       if (IsMenu(FileMenu)) FileMenuIdle();
     #endif
   }
 
   if (!PENDING(ms, next_rts_update_ms)) {
     next_rts_update_ms = ms + DWIN_UPDATE_INTERVAL;
 
     if ((Printing() != HMI_flag.printing_flag) && !HMI_flag.home_flag) {
       HMI_flag.printing_flag = Printing();
-      DEBUG_ECHOLNPGM("printing_flag: ", HMI_flag.printing_flag);
       if (HMI_flag.printing_flag)
         DWIN_Print_Started();
       else if (HMI_flag.abort_flag)
         DWIN_Print_Aborted();
       else
         DWIN_Print_Finished();
     }
 
     if ((printingIsPaused() != HMI_flag.pause_flag) && !HMI_flag.home_flag) {
       HMI_flag.pause_flag = printingIsPaused();
-      DEBUG_ECHOLNPGM("pause_flag: ", HMI_flag.pause_flag);
       if (HMI_flag.pause_flag)
         DWIN_Print_Pause();
       else if (HMI_flag.abort_flag)
         DWIN_Print_Aborted();
       else
         DWIN_Print_Resume();
     }
 
     if (checkkey == PrintProcess) { // print process
 
@@ -1621,59 +1619,54 @@ void DWIN_LevelingDone() {
         checkkey = last_checkkey;
         ui.reset_alert_level();
         break;
     }
   }
 
 #endif // MPCTEMP
 
 // Started a Print Job
 void DWIN_Print_Started() {
-  DEBUG_ECHOLNPGM("DWIN_Print_Started: ", SD_Printing());
   TERN_(HAS_GCODE_PREVIEW, if (Host_Printing()) Preview_Invalidate());
   _percent_done = 0;
   _remain_time = 0;
   HMI_flag.percent_flag = false;
   HMI_flag.remain_flag = false;
   HMI_flag.pause_flag = false;
   HMI_flag.abort_flag = false;
   select_print.reset();
   Goto_PrintProcess();
 }
 
 // Pause a print job
 void DWIN_Print_Pause() {
-  DEBUG_ECHOLNPGM("DWIN_Print_Pause");
   ICON_ResumeOrPause();
 }
 
 // Resume print job
 void DWIN_Print_Resume() {
-  DEBUG_ECHOLNPGM("DWIN_Print_Resume");
   ICON_ResumeOrPause();
   LCD_MESSAGE(MSG_RESUME_PRINT);
 }
 
 // Ended print job
 void DWIN_Print_Finished() {
-  DEBUG_ECHOLNPGM("DWIN_Print_Finished");
   TERN_(POWER_LOSS_RECOVERY, if (card.isPrinting()) recovery.cancel());
   HMI_flag.pause_flag = false;
   wait_for_heatup = false;
   planner.finish_and_disable();
   thermalManager.cooldown();
   Goto_PrintDone();
 }
 
 // Print was aborted
 void DWIN_Print_Aborted() {
-  DEBUG_ECHOLNPGM("DWIN_Print_Aborted");
   DWIN_Print_Finished();
 }
 
 // Progress and remaining time update
 void DWIN_M73() {
   if (parser.seenval('P')) {
     _percent_done = parser.value_byte();
     HMI_flag.percent_flag = true;
   }
   if (parser.seenval('R')) {
@@ -1707,21 +1700,20 @@ void DWIN_SetColorDefaults() {
   HMI_data.PopupTxt_Color   = Def_PopupTxt_Color;
   HMI_data.AlertBg_Color    = Def_AlertBg_Color;
   HMI_data.AlertTxt_Color   = Def_AlertTxt_Color;
   HMI_data.PercentTxt_Color = Def_PercentTxt_Color;
   HMI_data.Barfill_Color    = Def_Barfill_Color;
   HMI_data.Indicator_Color  = Def_Indicator_Color;
   HMI_data.Coordinate_Color = Def_Coordinate_Color;
 }
 
 void DWIN_SetDataDefaults() {
-  DEBUG_ECHOLNPGM("DWIN_SetDataDefaults");
   DWIN_SetColorDefaults();
   DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color, HMI_data.StatusBg_Color);
   TERN_(PIDTEMP, HMI_data.HotendPidT = DEF_HOTENDPIDT);
   TERN_(PIDTEMPBED, HMI_data.BedPidT = DEF_BEDPIDT);
   TERN_(DWIN_PID_TUNE, HMI_data.PidCycles = DEF_PIDCYCLES);
   #if ENABLED(PREVENT_COLD_EXTRUSION)
     HMI_data.ExtMinT = EXTRUDE_MINTEMP;
     ApplyExtMinT();
   #endif
   TERN_(PREHEAT_BEFORE_LEVELING, HMI_data.BedLevT = LEVELING_BED_TEMP);
@@ -1731,58 +1723,51 @@ void DWIN_SetDataDefaults() {
   #if BOTH(INDIVIDUAL_AXIS_HOMING_SUBMENU, MESH_BED_LEVELING)
     HMI_data.z_after_homing = DEF_Z_AFTER_HOMING;
   #endif
   #if BOTH(LED_CONTROL_MENU, HAS_COLOR_LEDS)
     TERN_(LED_COLOR_PRESETS, leds.set_default());
     ApplyLEDColor();
   #endif
 }
 
 void DWIN_CopySettingsTo(char * const buff) {
-  DEBUG_ECHOLNPGM("DWIN_CopySettingsTo");
-  DEBUG_ECHOLNPGM("HMI_data: ", sizeof(HMI_data_t));
   memcpy(buff, &HMI_data, eeprom_data_size);
 }
 
 void DWIN_CopySettingsFrom(const char * const buff) {
-  DEBUG_ECHOLNPGM("DWIN_CopySettingsFrom");
   memcpy(&HMI_data, buff, sizeof(HMI_data_t));
   if (HMI_data.Text_Color == HMI_data.Background_Color) DWIN_SetColorDefaults();
   DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color, HMI_data.StatusBg_Color);
   TERN_(PREVENT_COLD_EXTRUSION, ApplyExtMinT());
   feedrate_percentage = 100;
   TERN_(BAUD_RATE_GCODE, HMI_SetBaudRate());
   #if BOTH(LED_CONTROL_MENU, HAS_COLOR_LEDS)
     leds.set_color(
       HMI_data.Led_Color.r,
       HMI_data.Led_Color.g,
       HMI_data.Led_Color.b
       OPTARG(HAS_WHITE_LED, HMI_data.Led_Color.w)
     );
     leds.update();
   #endif
 }
 
 // Initialize or re-initialize the LCD
 void MarlinUI::init_lcd() {
-  DEBUG_ECHOLNPGM("MarlinUI::init_lcd");
   delay(750);   // wait to wakeup screen
   const bool hs = DWIN_Handshake(); UNUSED(hs);
-  DEBUG_ECHOPGM("DWIN_Handshake ");
-  DEBUG_ECHOLNF(hs ? F("ok.") : F("error."));
   DWIN_Frame_SetDir(1);
   DWIN_JPG_CacheTo1(Language_English);
   Encoder_Configuration();
 }
 
 void DWIN_InitScreen() {
-  DEBUG_ECHOLNPGM("DWIN_InitScreen");
   DWIN_SetColorDefaults();
   HMI_Init();   // draws boot screen
   DWINUI::init();
   DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color, HMI_data.StatusBg_Color);
   DWINUI::onTitleDraw = Draw_Title;
   InitMenu();
   checkkey = 255;
   hash_changed = true;
   last_E = 0;
   DWIN_DrawStatusLine();
@@ -2027,21 +2012,20 @@ void AutoHome() { queue.inject_P(G28_STR); }
   }
 #endif
 
 #if HAS_ZOFFSET_ITEM
 
   void ApplyZOffset() { TERN_(EEPROM_SETTINGS, settings.save()); }
   void LiveZOffset() {
     #if EITHER(BABYSTEP_ZPROBE_OFFSET, JUST_BABYSTEP)
       const_float_t step_zoffset = round((MenuData.Value / 100.0f) * planner.settings.axis_steps_per_mm[Z_AXIS]) - babystep.accum;
       if (BABYSTEP_ALLOWED()) babystep.add_steps(Z_AXIS, step_zoffset);
-      //DEBUG_ECHOLNF(F("BB Steps: "), step_zoffset);
     #endif
   }
   void SetZOffset() {
     #if EITHER(BABYSTEP_ZPROBE_OFFSET, JUST_BABYSTEP)
       babystep.accum = round(planner.settings.axis_steps_per_mm[Z_AXIS] * BABY_Z_VAR);
     #endif
     SetPFloatOnClick(Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX, 2, ApplyZOffset, LiveZOffset);
   }
 
   void SetMoveZto0() {

commit c421a2f5dd8e32e48afadee304301befaf40fd49
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Sun Feb 12 07:35:19 2023 +0100

    ‚ú® M306 E for MPC extruder index (#25326)
    
    Co-Authored-By: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index c45aae6044..ae10f0e84e 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -3535,21 +3535,21 @@ void Draw_Steps_Menu() {
         MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawMenuItem, WriteEeprom);
       #endif
     }
     UpdateMenu(HotendPIDMenu);
   }
 
 #endif
 
 #if ENABLED(MPCTEMP)
 
-  void HotendMPC() { thermalManager.MPC_autotune(); }
+  void HotendMPC() { thermalManager.MPC_autotune(active_extruder); }
   void SetHeaterPower() { SetPFloatOnClick(1, 200, 1); }
   void SetBlkHeatCapacity() { SetPFloatOnClick(0, 40, 2); }
   void SetSensorRespons() { SetPFloatOnClick(0, 1, 4); }
   void SetAmbientXfer() { SetPFloatOnClick(0, 1, 4); }
   #if ENABLED(MPC_INCLUDE_FAN)
     void onDrawFanAdj(MenuItemClass* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 4, thermalManager.temp_hotend[0].fanCoefficient()); }
     void ApplyFanAdj() { thermalManager.temp_hotend[0].applyFanAdjustment(MenuData.Value / POW(10, 4)); }
     void SetFanAdj() { SetFloatOnClick(0, 1, 4, thermalManager.temp_hotend[0].fanCoefficient(), ApplyFanAdj); }
   #endif
 

commit 218ca0530432d6b1194ccac5fc32a72bbc9a7c96
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Sat Feb 4 05:10:26 2023 -0300

    üßë‚Äçüíª General 'MediaFile' type alias (#24424)

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index e8430d591c..c45aae6044 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -1340,21 +1340,21 @@ void EachMomentUpdate() {
       DWINUI::Draw_IconWB(ICON_Cancel_C,    26, 280);
       DWINUI::Draw_IconWB(ICON_Continue_C, 146, 280);
     }
     else {
       DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 70, GET_TEXT_F(MSG_OUTAGE_RECOVERY));
       DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 147, F("It looks like the last"));
       DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 167, F("file was interrupted."));
       DWINUI::Draw_Button(BTN_Cancel,    26, 280);
       DWINUI::Draw_Button(BTN_Continue, 146, 280);
     }
-    SdFile *dir = nullptr;
+    MediaFile *dir = nullptr;
     const char * const filename = card.diveToFile(true, dir, recovery.info.sd_filename);
     card.selectFileByName(filename);
     DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 207, card.longest_filename());
     Draw_Select_Highlight(HMI_flag.select_flag);
     DWIN_UpdateLCD();
   }
 
   void onClick_PowerLossRecovery() {
     if (HMI_flag.select_flag) {
       queue.inject(F("M1000C"));

commit b3f65b674f23db5c32e4d7e96ad2dff97c77c717
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Tue Jan 17 18:41:36 2023 -0500

    üö∏ ProUI MPC menu (#25232)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 4be0819441..e8430d591c 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -24,51 +24,20 @@
  * DWIN Enhanced implementation for PRO UI
  * Author: Miguel A. Risco-Castillo (MRISCOC)
  * Version: 3.21.2
  * Date: 2022/12/02
  */
 
 #include "../../../inc/MarlinConfig.h"
 
 #if ENABLED(DWIN_LCD_PROUI)
 
-#if DISABLED(LIMITED_MAX_FR_EDITING)
-  #warning "LIMITED_MAX_FR_EDITING is recommended with ProUI."
-#endif
-#if DISABLED(LIMITED_MAX_ACCEL_EDITING)
-  #warning "LIMITED_MAX_ACCEL_EDITING is recommended with ProUI."
-#endif
-#if ENABLED(CLASSIC_JERK) && DISABLED(LIMITED_JERK_EDITING)
-  #warning "LIMITED_JERK_EDITING is recommended with ProUI."
-#endif
-#if DISABLED(INDIVIDUAL_AXIS_HOMING_SUBMENU)
-  #warning "INDIVIDUAL_AXIS_HOMING_SUBMENU is recommended with ProUI."
-#endif
-#if DISABLED(SET_PROGRESS_MANUALLY)
-  #warning "SET_PROGRESS_MANUALLY is recommended with ProUI."
-#endif
-#if DISABLED(STATUS_MESSAGE_SCROLLING)
-  #warning "STATUS_MESSAGE_SCROLLING is recommended with ProUI."
-#endif
-#if DISABLED(BAUD_RATE_GCODE)
-  #warning "BAUD_RATE_GCODE is recommended with ProUI."
-#endif
-#if DISABLED(SOUND_MENU_ITEM)
-  #warning "SOUND_MENU_ITEM is recommended with ProUI."
-#endif
-#if DISABLED(PRINTCOUNTER)
-  #warning "PRINTCOUNTER is recommended with ProUI."
-#endif
-#if HAS_MESH && DISABLED(MESH_EDIT_MENU)
-  #warning "MESH_EDIT_MENU is recommended with ProUI."
-#endif
-
 #include "../../fontutils.h"
 #include "../../marlinui.h"
 
 #include "../../../sd/cardreader.h"
 
 #include "../../../MarlinCore.h"
 #include "../../../core/serial.h"
 #include "../../../core/macros.h"
 
 #include "../../../module/temperature.h"
@@ -135,21 +104,21 @@
 #include "dwin_popup.h"
 
 #if HAS_GCODE_PREVIEW
   #include "gcode_preview.h"
 #endif
 
 #if HAS_ESDIAG
   #include "endstop_diag.h"
 #endif
 
-#if HAS_PIDPLOT
+#if SHOW_TUNING_GRAPH
   #include "plot.h"
 #endif
 
 #if HAS_MESH
   #include "meshviewer.h"
 #endif
 
 #if HAS_LOCKSCREEN
   #include "lockscreen.h"
 #endif
@@ -290,20 +259,23 @@ MenuClass *FilamentMenu = nullptr;
 #if HAS_HOTEND
   MenuClass *PreheatMenu = nullptr;
 #endif
 MenuClass *TemperatureMenu = nullptr;
 MenuClass *MaxSpeedMenu = nullptr;
 MenuClass *MaxAccelMenu = nullptr;
 #if HAS_CLASSIC_JERK
   MenuClass *MaxJerkMenu = nullptr;
 #endif
 MenuClass *StepsMenu = nullptr;
+#if ENABLED(MPCTEMP)
+  MenuClass *HotendMPCMenu = nullptr;
+#endif
 #if ENABLED(PIDTEMP)
   MenuClass *HotendPIDMenu = nullptr;
 #endif
 #if ENABLED(PIDTEMPBED)
   MenuClass *BedPIDMenu = nullptr;
 #endif
 #if ENABLED(CASELIGHT_USES_BRIGHTNESS)
   MenuClass *CaseLightMenu = nullptr;
 #endif
 #if ENABLED(LED_CONTROL_MENU)
@@ -1268,22 +1240,22 @@ void EachMomentUpdate() {
   static millis_t next_var_update_ms = 0, next_rts_update_ms = 0, next_status_update_ms = 0;
   const millis_t ms = millis();
 
   if (ELAPSED(ms, next_var_update_ms)) {
     next_var_update_ms = ms + DWIN_VAR_UPDATE_INTERVAL;
     blink = !blink;
     update_variable();
     #if HAS_ESDIAG
       if (checkkey == ESDiagProcess) ESDiag.Update();
     #endif
-    #if HAS_PIDPLOT
-      if (checkkey == PidProcess) Plot.Update((HMI_value.pidresult == PIDTEMP_START) ? thermalManager.wholeDegHotend(0) : thermalManager.wholeDegBed());
+    #if SHOW_TUNING_GRAPH
+      if (checkkey == PidProcess) plot.Update((HMI_value.pidresult == PIDTEMP_START) ? thermalManager.wholeDegHotend(0) : thermalManager.wholeDegBed());
     #endif
   }
 
   #if HAS_STATUS_MESSAGE_TIMEOUT
     bool did_expire = ui.status_reset_callback && (*ui.status_reset_callback)();
     did_expire |= ui.status_message_expire_ms && ELAPSED(ms, ui.status_message_expire_ms);
     if (did_expire) ui.reset_status();
   #endif
 
   if (ELAPSED(ms, next_status_update_ms)) {
@@ -1491,111 +1463,176 @@ void DWIN_LevelingDone() {
 
 #if HAS_MESH
   void DWIN_MeshUpdate(const int8_t cpos, const int8_t tpos, const_float_t zval) {
     char msg[33] = "";
     char str_1[6] = "";
     sprintf_P(msg, PSTR(S_FMT " %i/%i Z=%s"), GET_TEXT(MSG_PROBING_POINT), cpos, tpos, dtostrf(zval, 1, 2, str_1));
     ui.set_status(msg);
   }
 #endif
 
-// PID process
+// PID/MPC process
 
-#if BOTH(HAS_PIDPLOT, DWIN_PID_TUNE)
+#if SHOW_TUNING_GRAPH
+
+  #include "plot.h"
 
-  void DWIN_Draw_PIDPopup() {
-    frame_rect_t gfrm = { 40, 180, DWIN_WIDTH - 80, 120 };
+  celsius_t _maxtemp, _target;
+  void DWIN_Draw_PID_MPC_Popup() {
+    constexpr frame_rect_t gfrm = { 40, 180, DWIN_WIDTH - 80, 120 };
     DWINUI::ClearMainArea();
     Draw_Popup_Bkgd();
-    DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 100, GET_TEXT_F(MSG_PID_AUTOTUNE));
-    DWINUI::Draw_String(HMI_data.PopupTxt_Color, gfrm.x, gfrm.y - DWINUI::fontHeight() - 4, F("PID target:    Celsius"));
-    switch (HMI_value.pidresult) {
-      #if ENABLED(PIDTEMP)
+
+    #if ENABLED(MPCTEMP)
+
+      switch (HMI_value.pidresult) {
+        case MPCTEMP_START:
+          _maxtemp = thermalManager.hotend_maxtemp[0];
+          _target = 200;
+          DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 100, GET_TEXT_F(MSG_MPC_AUTOTUNE));
+          DWINUI::Draw_String(HMI_data.PopupTxt_Color, gfrm.x, gfrm.y - DWINUI::fontHeight() - 4, F("MPC target:    Celsius"));
+          DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 120, F("for Nozzle is running."));
+          break;
+        case PIDTEMPBED_START:
+          _maxtemp = BED_MAXTEMP;
+          _target = HMI_data.BedPidT;
+          DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 100, GET_TEXT_F(MSG_PID_AUTOTUNE));
+          DWINUI::Draw_String(HMI_data.PopupTxt_Color, gfrm.x, gfrm.y - DWINUI::fontHeight() - 4, F("PID target:    Celsius"));
+          DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 120, F("for BED is running."));
+          break;
+        default: return;
+      }
+
+    #else // PID
+
+      DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 100, GET_TEXT_F(MSG_PID_AUTOTUNE));
+      DWINUI::Draw_String(HMI_data.PopupTxt_Color, gfrm.x, gfrm.y - DWINUI::fontHeight() - 4, F("PID target:    Celsius"));
+
+      switch (HMI_value.pidresult) {
         case PIDTEMP_START:
+          _maxtemp = thermalManager.hotend_maxtemp[0];
+          _target = HMI_data.HotendPidT;
           DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 120, F("for Nozzle is running."));
-          Plot.Draw(gfrm, thermalManager.hotend_maxtemp[0], HMI_data.HotendPidT);
-          DWINUI::Draw_Int(HMI_data.PopupTxt_Color, 3, gfrm.x + 90, gfrm.y - DWINUI::fontHeight() - 4, HMI_data.HotendPidT);
           break;
-      #endif
-      #if ENABLED(PIDTEMPBED)
         case PIDTEMPBED_START:
+          _maxtemp = BED_MAXTEMP;
+          _target = HMI_data.BedPidT;
           DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 120, F("for BED is running."));
-          Plot.Draw(gfrm, BED_MAXTEMP, HMI_data.BedPidT);
-          DWINUI::Draw_Int(HMI_data.PopupTxt_Color, 3, gfrm.x + 90, gfrm.y - DWINUI::fontHeight() - 4, HMI_data.BedPidT);
           break;
-      #endif
-      default: break;
-    }
+        default: return;
+      }
+
+    #endif // PID
+
+    plot.Draw(gfrm, _maxtemp, _target);
+    DWINUI::Draw_Int(HMI_data.PopupTxt_Color, 3, gfrm.x + 90, gfrm.y - DWINUI::fontHeight() - 4, _target);
   }
 
-#endif
+#endif // SHOW_TUNING_GRAPH
 
 #if DWIN_PID_TUNE
 
   void DWIN_StartM303(const bool seenC, const int c, const bool seenS, const heater_id_t hid, const celsius_t temp) {
     if (seenC) HMI_data.PidCycles = c;
     if (seenS) {
       switch (hid) {
         OPTCODE(PIDTEMP,    case 0 ... HOTENDS - 1: HMI_data.HotendPidT = temp; break)
         OPTCODE(PIDTEMPBED, case H_BED:             HMI_data.BedPidT = temp;    break)
         default: break;
       }
     }
   }
 
-  void DWIN_PidTuning(pidresult_t result) {
+  void DWIN_PidTuning(tempcontrol_t result) {
     HMI_value.pidresult = result;
     switch (result) {
       #if ENABLED(PIDTEMP)
         case PIDTEMP_START:
           HMI_SaveProcessID(PidProcess);
-          #if HAS_PIDPLOT
-            DWIN_Draw_PIDPopup();
+          #if SHOW_TUNING_GRAPH
+            DWIN_Draw_PID_MPC_Popup();
           #else
             DWIN_Draw_Popup(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE), F("for Nozzle is running."));
           #endif
           break;
-        case PID_BAD_HEATER_ID:
+        case PID_TEMP_TOO_HIGH:
           checkkey = last_checkkey;
-          DWIN_Popup_Confirm(ICON_TempTooLow, GET_TEXT_F(MSG_PID_AUTOTUNE_FAILED), GET_TEXT_F(MSG_BAD_HEATER_ID));
+          DWIN_Popup_Confirm(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE_FAILED), GET_TEXT_F(MSG_TEMP_TOO_HIGH));
           break;
       #endif
       #if ENABLED(PIDTEMPBED)
         case PIDTEMPBED_START:
           HMI_SaveProcessID(PidProcess);
-          #if HAS_PIDPLOT
-            DWIN_Draw_PIDPopup();
+          #if SHOW_TUNING_GRAPH
+            DWIN_Draw_PID_MPC_Popup();
           #else
             DWIN_Draw_Popup(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE), F("for BED is running."));
           #endif
           break;
       #endif
-      case PID_TUNING_TIMEOUT:
+      case PID_BAD_HEATER_ID:
         checkkey = last_checkkey;
-        DWIN_Popup_Confirm(ICON_TempTooHigh, GET_TEXT_F(MSG_ERROR), GET_TEXT_F(MSG_PID_TIMEOUT));
+        DWIN_Popup_Confirm(ICON_TempTooLow, GET_TEXT_F(MSG_PID_AUTOTUNE_FAILED), GET_TEXT_F(MSG_PID_BAD_HEATER_ID));
         break;
-      case PID_TEMP_TOO_HIGH:
+      case PID_TUNING_TIMEOUT:
         checkkey = last_checkkey;
-        DWIN_Popup_Confirm(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE_FAILED), GET_TEXT_F(MSG_TEMP_TOO_HIGH));
+        DWIN_Popup_Confirm(ICON_TempTooHigh, GET_TEXT_F(MSG_ERROR), GET_TEXT_F(MSG_PID_TIMEOUT));
         break;
       case PID_DONE:
         checkkey = last_checkkey;
         DWIN_Popup_Confirm(ICON_TempTooLow, GET_TEXT_F(MSG_PID_AUTOTUNE), GET_TEXT_F(MSG_BUTTON_DONE));
         break;
       default:
         checkkey = last_checkkey;
         break;
     }
   }
 
 #endif // DWIN_PID_TUNE
 
+#if ENABLED(MPCTEMP)
+
+  void DWIN_MPCTuning(tempcontrol_t result) {
+    HMI_value.pidresult = result;
+    switch (result) {
+      case MPCTEMP_START:
+        HMI_SaveProcessID(MPCProcess);
+        #if SHOW_TUNING_GRAPH
+          DWIN_Draw_PID_MPC_Popup();
+        #else
+          DWIN_Draw_Popup(ICON_TempTooHigh, GET_TEXT_F(MSG_MPC_AUTOTUNE), F("for Nozzle is running."));
+        #endif
+        break;
+      case MPC_TEMP_ERROR:
+        checkkey = last_checkkey;
+        DWIN_Popup_Confirm(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE_FAILED), F(STR_MPC_TEMPERATURE_ERROR));
+        ui.reset_alert_level();
+        break;
+      case MPC_INTERRUPTED:
+        checkkey = last_checkkey;
+        DWIN_Popup_Confirm(ICON_TempTooHigh, GET_TEXT_F(MSG_ERROR), F(STR_MPC_AUTOTUNE STR_MPC_AUTOTUNE_INTERRUPTED));
+        ui.reset_alert_level();
+        break;
+      case MPC_DONE:
+        checkkey = last_checkkey;
+        DWIN_Popup_Confirm(ICON_TempTooLow, GET_TEXT_F(MSG_MPC_AUTOTUNE), GET_TEXT_F(MSG_BUTTON_DONE));
+        ui.reset_alert_level();
+        break;
+      default:
+        checkkey = last_checkkey;
+        ui.reset_alert_level();
+        break;
+    }
+  }
+
+#endif // MPCTEMP
+
 // Started a Print Job
 void DWIN_Print_Started() {
   DEBUG_ECHOLNPGM("DWIN_Print_Started: ", SD_Printing());
   TERN_(HAS_GCODE_PREVIEW, if (Host_Printing()) Preview_Invalidate());
   _percent_done = 0;
   _remain_time = 0;
   HMI_flag.percent_flag = false;
   HMI_flag.remain_flag = false;
   HMI_flag.pause_flag = false;
   HMI_flag.abort_flag = false;
@@ -3047,35 +3084,38 @@ void Draw_Control_Menu() {
       MENU_ITEM(ICON_LedControl, MSG_LED_CONTROL, onDrawSubMenu, Draw_LedControl_Menu);
     #endif
     MENU_ITEM(ICON_Info, MSG_INFO_SCREEN, onDrawInfoSubMenu, Goto_Info_Menu);
   }
   ui.reset_status(true);
   UpdateMenu(ControlMenu);
 }
 
 void Draw_AdvancedSettings_Menu() {
   checkkey = Menu;
-  if (SET_MENU(AdvancedSettings, MSG_ADVANCED_SETTINGS, 18)) {
+  if (SET_MENU(AdvancedSettings, MSG_ADVANCED_SETTINGS, 19)) {
     BACK_ITEM(Goto_Main_Menu);
     #if ENABLED(EEPROM_SETTINGS)
       MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawMenuItem, WriteEeprom);
     #endif
     #if HAS_MESH
       MENU_ITEM(ICON_ProbeSet, MSG_MESH_LEVELING, onDrawSubMenu, Draw_MeshSet_Menu);
     #endif
     #if HAS_BED_PROBE
       MENU_ITEM(ICON_ProbeSet, MSG_ZPROBE_SETTINGS, onDrawSubMenu, Draw_ProbeSet_Menu);
     #endif
     MENU_ITEM(ICON_FilSet, MSG_FILAMENT_SET, onDrawSubMenu, Draw_FilSet_Menu);
     #if ENABLED(PIDTEMP)
       MENU_ITEM_F(ICON_PIDNozzle, STR_HOTEND_PID " Settings", onDrawSubMenu, Draw_HotendPID_Menu);
     #endif
+    #if ENABLED(MPCTEMP)
+      MENU_ITEM_F(ICON_MPCNozzle, STR_MPC_AUTOTUNE " Settings", onDrawSubMenu, Draw_HotendMPC_Menu);
+    #endif
     #if ENABLED(PIDTEMPBED)
       MENU_ITEM_F(ICON_PIDBed, STR_BED_PID " Settings", onDrawSubMenu, Draw_BedPID_Menu);
     #endif
     #if HAS_ESDIAG
       MENU_ITEM_F(ICON_ESDiag, "End-stops diag.", onDrawSubMenu, Draw_EndStopDiag);
     #endif
     #if ENABLED(PRINTCOUNTER)
       MENU_ITEM(ICON_PrintStats, MSG_INFO_STATS_MENU, onDrawSubMenu, Goto_PrintStats);
       MENU_ITEM(ICON_PrintStatsReset, MSG_INFO_PRINT_COUNT_RESET, onDrawSubMenu, PrintStatsReset);
     #endif
@@ -3493,20 +3533,52 @@ void Draw_Steps_Menu() {
       EDIT_ITEM(ICON_PIDCycles, MSG_PID_CYCLE, onDrawPIntMenu, SetPidCycles, &HMI_data.PidCycles);
       #if ENABLED(EEPROM_SETTINGS)
         MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawMenuItem, WriteEeprom);
       #endif
     }
     UpdateMenu(HotendPIDMenu);
   }
 
 #endif
 
+#if ENABLED(MPCTEMP)
+
+  void HotendMPC() { thermalManager.MPC_autotune(); }
+  void SetHeaterPower() { SetPFloatOnClick(1, 200, 1); }
+  void SetBlkHeatCapacity() { SetPFloatOnClick(0, 40, 2); }
+  void SetSensorRespons() { SetPFloatOnClick(0, 1, 4); }
+  void SetAmbientXfer() { SetPFloatOnClick(0, 1, 4); }
+  #if ENABLED(MPC_INCLUDE_FAN)
+    void onDrawFanAdj(MenuItemClass* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 4, thermalManager.temp_hotend[0].fanCoefficient()); }
+    void ApplyFanAdj() { thermalManager.temp_hotend[0].applyFanAdjustment(MenuData.Value / POW(10, 4)); }
+    void SetFanAdj() { SetFloatOnClick(0, 1, 4, thermalManager.temp_hotend[0].fanCoefficient(), ApplyFanAdj); }
+  #endif
+
+  void Draw_HotendMPC_Menu() {
+    checkkey = Menu;
+    if (SET_MENU_F(HotendMPCMenu, STR_MPC_AUTOTUNE " Settings", 7)) {
+      MPC_t &mpc = thermalManager.temp_hotend[0].mpc;
+      BACK_ITEM(Draw_AdvancedSettings_Menu);
+      MENU_ITEM(ICON_MPCNozzle, MSG_MPC_AUTOTUNE, onDrawMenuItem, HotendMPC);
+      EDIT_ITEM(ICON_MPCHeater, MSG_MPC_POWER, onDrawPFloatMenu, SetHeaterPower, &mpc.heater_power);
+      EDIT_ITEM(ICON_MPCHeatCap, MSG_MPC_BLOCK_HEAT_CAPACITY, onDrawPFloat2Menu, SetBlkHeatCapacity, &mpc.block_heat_capacity);
+      EDIT_ITEM(ICON_MPCValue, MSG_SENSOR_RESPONSIVENESS, onDrawPFloat4Menu, SetSensorRespons, &mpc.sensor_responsiveness);
+      EDIT_ITEM(ICON_MPCValue, MSG_MPC_AMBIENT_XFER_COEFF, onDrawPFloat4Menu, SetAmbientXfer, &mpc.ambient_xfer_coeff_fan0);
+      #if ENABLED(MPC_INCLUDE_FAN)
+        EDIT_ITEM(ICON_MPCFan, MSG_MPC_AMBIENT_XFER_COEFF_FAN, onDrawFanAdj, SetFanAdj, &mpc.fan255_adjustment);
+      #endif
+    }
+    UpdateMenu(HotendMPCMenu);
+  }
+
+#endif // MPCTEMP
+
 #if ENABLED(PIDTEMPBED)
 
   void Draw_BedPID_Menu() {
     checkkey = Menu;
     if (SET_MENU_F(BedPIDMenu, STR_BED_PID " Settings", 8)) {
       BACK_ITEM(Draw_AdvancedSettings_Menu);
       MENU_ITEM_F(ICON_PIDBed, STR_BED_PID, onDrawMenuItem,BedPID);
       EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KP, onDrawPFloat2Menu, SetKp, &thermalManager.temp_bed.pid.Kp);
       EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KI, onDrawPIDi, SetKi, &thermalManager.temp_bed.pid.Ki);
       EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KD, onDrawPIDd, SetKd, &thermalManager.temp_bed.pid.Kd);

commit 6fe387b6f0722033e6cca96fd5e8215ea7b162eb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jan 15 06:48:17 2023 -0600

    üßë‚Äçüíª Adjust PID / MPC / ProUI
    
    Changes to simplify #25232 WIP

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 621b3d0dd3..4be0819441 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -1493,23 +1493,24 @@ void DWIN_LevelingDone() {
   void DWIN_MeshUpdate(const int8_t cpos, const int8_t tpos, const_float_t zval) {
     char msg[33] = "";
     char str_1[6] = "";
     sprintf_P(msg, PSTR(S_FMT " %i/%i Z=%s"), GET_TEXT(MSG_PROBING_POINT), cpos, tpos, dtostrf(zval, 1, 2, str_1));
     ui.set_status(msg);
   }
 #endif
 
 // PID process
 
-#if HAS_PIDPLOT
+#if BOTH(HAS_PIDPLOT, DWIN_PID_TUNE)
+
   void DWIN_Draw_PIDPopup() {
-    frame_rect_t gfrm = {40, 180, DWIN_WIDTH - 80, 120};
+    frame_rect_t gfrm = { 40, 180, DWIN_WIDTH - 80, 120 };
     DWINUI::ClearMainArea();
     Draw_Popup_Bkgd();
     DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 100, GET_TEXT_F(MSG_PID_AUTOTUNE));
     DWINUI::Draw_String(HMI_data.PopupTxt_Color, gfrm.x, gfrm.y - DWINUI::fontHeight() - 4, F("PID target:    Celsius"));
     switch (HMI_value.pidresult) {
       #if ENABLED(PIDTEMP)
         case PIDTEMP_START:
           DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 120, F("for Nozzle is running."));
           Plot.Draw(gfrm, thermalManager.hotend_maxtemp[0], HMI_data.HotendPidT);
           DWINUI::Draw_Int(HMI_data.PopupTxt_Color, 3, gfrm.x + 90, gfrm.y - DWINUI::fontHeight() - 4, HMI_data.HotendPidT);
@@ -1518,39 +1519,51 @@ void DWIN_LevelingDone() {
       #if ENABLED(PIDTEMPBED)
         case PIDTEMPBED_START:
           DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 120, F("for BED is running."));
           Plot.Draw(gfrm, BED_MAXTEMP, HMI_data.BedPidT);
           DWINUI::Draw_Int(HMI_data.PopupTxt_Color, 3, gfrm.x + 90, gfrm.y - DWINUI::fontHeight() - 4, HMI_data.BedPidT);
           break;
       #endif
       default: break;
     }
   }
+
 #endif
 
-#if EITHER(PIDTEMP, PIDTEMPBED)
+#if DWIN_PID_TUNE
+
+  void DWIN_StartM303(const bool seenC, const int c, const bool seenS, const heater_id_t hid, const celsius_t temp) {
+    if (seenC) HMI_data.PidCycles = c;
+    if (seenS) {
+      switch (hid) {
+        OPTCODE(PIDTEMP,    case 0 ... HOTENDS - 1: HMI_data.HotendPidT = temp; break)
+        OPTCODE(PIDTEMPBED, case H_BED:             HMI_data.BedPidT = temp;    break)
+        default: break;
+      }
+    }
+  }
 
   void DWIN_PidTuning(pidresult_t result) {
     HMI_value.pidresult = result;
     switch (result) {
       #if ENABLED(PIDTEMP)
         case PIDTEMP_START:
           HMI_SaveProcessID(PidProcess);
           #if HAS_PIDPLOT
             DWIN_Draw_PIDPopup();
           #else
             DWIN_Draw_Popup(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE), F("for Nozzle is running."));
           #endif
           break;
-        case PID_BAD_EXTRUDER_NUM:
+        case PID_BAD_HEATER_ID:
           checkkey = last_checkkey;
-          DWIN_Popup_Confirm(ICON_TempTooLow, GET_TEXT_F(MSG_PID_AUTOTUNE_FAILED), GET_TEXT_F(MSG_BAD_EXTRUDER_NUM));
+          DWIN_Popup_Confirm(ICON_TempTooLow, GET_TEXT_F(MSG_PID_AUTOTUNE_FAILED), GET_TEXT_F(MSG_BAD_HEATER_ID));
           break;
       #endif
       #if ENABLED(PIDTEMPBED)
         case PIDTEMPBED_START:
           HMI_SaveProcessID(PidProcess);
           #if HAS_PIDPLOT
             DWIN_Draw_PIDPopup();
           #else
             DWIN_Draw_Popup(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE), F("for BED is running."));
           #endif
@@ -1561,25 +1574,27 @@ void DWIN_LevelingDone() {
         DWIN_Popup_Confirm(ICON_TempTooHigh, GET_TEXT_F(MSG_ERROR), GET_TEXT_F(MSG_PID_TIMEOUT));
         break;
       case PID_TEMP_TOO_HIGH:
         checkkey = last_checkkey;
         DWIN_Popup_Confirm(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE_FAILED), GET_TEXT_F(MSG_TEMP_TOO_HIGH));
         break;
       case PID_DONE:
         checkkey = last_checkkey;
         DWIN_Popup_Confirm(ICON_TempTooLow, GET_TEXT_F(MSG_PID_AUTOTUNE), GET_TEXT_F(MSG_BUTTON_DONE));
         break;
-      default: checkkey = last_checkkey; break;
+      default:
+        checkkey = last_checkkey;
+        break;
     }
   }
 
-#endif // PIDTEMP || PIDTEMPBED
+#endif // DWIN_PID_TUNE
 
 // Started a Print Job
 void DWIN_Print_Started() {
   DEBUG_ECHOLNPGM("DWIN_Print_Started: ", SD_Printing());
   TERN_(HAS_GCODE_PREVIEW, if (Host_Printing()) Preview_Invalidate());
   _percent_done = 0;
   _remain_time = 0;
   HMI_flag.percent_flag = false;
   HMI_flag.remain_flag = false;
   HMI_flag.pause_flag = false;
@@ -1660,21 +1675,21 @@ void DWIN_SetColorDefaults() {
   HMI_data.Indicator_Color  = Def_Indicator_Color;
   HMI_data.Coordinate_Color = Def_Coordinate_Color;
 }
 
 void DWIN_SetDataDefaults() {
   DEBUG_ECHOLNPGM("DWIN_SetDataDefaults");
   DWIN_SetColorDefaults();
   DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color, HMI_data.StatusBg_Color);
   TERN_(PIDTEMP, HMI_data.HotendPidT = DEF_HOTENDPIDT);
   TERN_(PIDTEMPBED, HMI_data.BedPidT = DEF_BEDPIDT);
-  TERN_(HAS_PID_HEATING, HMI_data.PidCycles = DEF_PIDCYCLES);
+  TERN_(DWIN_PID_TUNE, HMI_data.PidCycles = DEF_PIDCYCLES);
   #if ENABLED(PREVENT_COLD_EXTRUSION)
     HMI_data.ExtMinT = EXTRUDE_MINTEMP;
     ApplyExtMinT();
   #endif
   TERN_(PREHEAT_BEFORE_LEVELING, HMI_data.BedLevT = LEVELING_BED_TEMP);
   TERN_(BAUD_RATE_GCODE, SetBaud250K());
   HMI_data.FullManualTramming = false;
   HMI_data.MediaAutoMount = ENABLED(HAS_SD_EXTENDER);
   #if BOTH(INDIVIDUAL_AXIS_HOMING_SUBMENU, MESH_BED_LEVELING)
     HMI_data.z_after_homing = DEF_Z_AFTER_HOMING;
@@ -2050,21 +2065,21 @@ void SetMoveX() { HMI_value.axis = X_AXIS; SetPFloatOnClick(X_MIN_POS, X_MAX_POS
 void SetMoveY() { HMI_value.axis = Y_AXIS; SetPFloatOnClick(Y_MIN_POS, Y_MAX_POS, UNITFDIGITS, ApplyMove, LiveMove); }
 void SetMoveZ() { HMI_value.axis = Z_AXIS; SetPFloatOnClick(Z_MIN_POS, Z_MAX_POS, UNITFDIGITS, ApplyMove, LiveMove); }
 
 #if HAS_HOTEND
   void SetMoveE() {
     if (thermalManager.tooColdToExtrude(0)) return DWIN_Popup_Confirm(ICON_TempTooLow, GET_TEXT_F(MSG_HOTEND_TOO_COLD), GET_TEXT_F(MSG_PLEASE_PREHEAT));
     HMI_value.axis = E_AXIS; SetPFloatOnClick(E_MIN_POS, E_MAX_POS, UNITFDIGITS, ApplyMove, LiveMove);
   }
 #endif
 
-#if EITHER(PIDTEMP, PIDTEMPBED)
+#if DWIN_PID_TUNE
   void SetPID(celsius_t t, heater_id_t h) {
     char cmd[53] = "";
     char str_1[5] = "", str_2[5] = "";
     sprintf_P(cmd, PSTR("G28OXY\nG0Z5F300\nG0X%sY%sF5000\nM84\nM400"),
       dtostrf(X_CENTER, 1, 1, str_1),
       dtostrf(Y_CENTER, 1, 1, str_2)
     );
     gcode.process_subcommands_now(cmd);
     thermalManager.PID_autotune(t, h, HMI_data.PidCycles, true);
   }
@@ -2516,21 +2531,21 @@ void SetStepsZ() { HMI_value.axis = Z_AXIS, SetPFloatOnClick( MIN_STEP, MAX_STEP
 #if HAS_HOTEND
   void SetStepsE() { HMI_value.axis = E_AXIS; SetPFloatOnClick( MIN_STEP, MAX_STEP, UNITFDIGITS); }
   #if ENABLED(PIDTEMP)
     void SetHotendPidT() { SetPIntOnClick(MIN_ETEMP, MAX_ETEMP); }
   #endif
 #endif
 #if ENABLED(PIDTEMPBED)
   void SetBedPidT() { SetPIntOnClick(MIN_BEDTEMP, MAX_BEDTEMP); }
 #endif
 
-#if EITHER(PIDTEMP, PIDTEMPBED)
+#if DWIN_PID_TUNE
   void SetPidCycles() { SetPIntOnClick(3, 50); }
   void SetKp() { SetPFloatOnClick(0, 1000, 2); }
   void ApplyPIDi() {
     *MenuData.P_Float = scalePID_i(MenuData.Value / POW(10, 2));
     TERN_(PIDTEMP, thermalManager.updatePID());
   }
   void ApplyPIDd() {
     *MenuData.P_Float = scalePID_d(MenuData.Value / POW(10, 2));
     TERN_(PIDTEMP, thermalManager.updatePID());
   }
@@ -2687,21 +2702,21 @@ void onDrawGetColorItem(MenuItemClass* menuitem, int8_t line) {
     case 2: color = RGB(0, 0, 31); break; // Blue
     default: color = 0; break;
   }
   DWIN_Draw_Rectangle(0, HMI_data.Highlight_Color, ICOX + 1, MBASE(line) - 1 + 1, ICOX + 18, MBASE(line) - 1 + 18);
   DWIN_Draw_Rectangle(1, color, ICOX + 2, MBASE(line) - 1 + 2, ICOX + 17, MBASE(line) - 1 + 17);
   DWINUI::Draw_String(LBLX, MBASE(line) - 1, menuitem->caption);
   Draw_Menu_IntValue(HMI_data.Background_Color, line, 4, HMI_value.Color[i]);
   DWIN_Draw_HLine(HMI_data.SplitLine_Color, 16, MYPOS(line + 1), 240);
 }
 
-#if EITHER(PIDTEMP, PIDTEMPBED)
+#if DWIN_PID_TUNE
   void onDrawPIDi(MenuItemClass* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, unscalePID_i(*(float*)static_cast<MenuItemPtrClass*>(menuitem)->value)); }
   void onDrawPIDd(MenuItemClass* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, unscalePID_d(*(float*)static_cast<MenuItemPtrClass*>(menuitem)->value)); }
 #endif
 
 void onDrawSpeedItem(MenuItemClass* menuitem, int8_t line) {
   if (HMI_IsChinese()) menuitem->SetFrame(1, 116, 164, 171, 176);
   onDrawPIntMenu(menuitem, line);
 }
 
 #if HAS_HOTEND

commit d94defc545ad477c82a8bc77e949aa91cdd3e0f2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jan 15 06:48:17 2023 -0600

    üé® Language / menu cleanup

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index ffb216f05f..621b3d0dd3 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -543,24 +543,24 @@ void DWIN_CheckStatusMessage() {
 };
 
 void DWIN_DrawStatusMessage() {
   #if ENABLED(STATUS_MESSAGE_SCROLLING)
 
     // Get the UTF8 character count of the string
     uint8_t slen = utf8_strlen(ui.status_message);
 
     // If the string fits the status line do not scroll it
     if (slen <= LCD_WIDTH) {
-       if (hash_changed) {
-         DWIN_DrawStatusLine(ui.status_message);
-         hash_changed = false;
-       }
+      if (hash_changed) {
+        DWIN_DrawStatusLine(ui.status_message);
+        hash_changed = false;
+      }
     }
     else {
       // String is larger than the available line space
 
       // Get a pointer to the next valid UTF8 character
       // and the string remaining length
       uint8_t rlen;
       const char *stat = MarlinUI::status_and_len(rlen);
       DWIN_Draw_Rectangle(1, HMI_data.StatusBg_Color, 0, STATUS_Y, DWIN_WIDTH, STATUS_Y + 20);
       DWINUI::MoveTo(0, STATUS_Y + 2);
@@ -669,28 +669,32 @@ void Goto_PrintProcess() {
 }
 
 void Draw_PrintDone() {
   // show percent bar and value
   _percent_done = 100;
   _remain_time = 0;
 
   Title.ShowCaption(GET_TEXT_F(MSG_PRINT_DONE));
   DWINUI::ClearMainArea();
   DWIN_Print_Header(nullptr);
+
   #if HAS_GCODE_PREVIEW
-    if (Preview_Valid()) {
+    const bool isvalid = Preview_Valid();
+    if (isvalid) {
       DWIN_ICON_Show(0, 0, 1, 21, 100, 0x00);
       DWINUI::Draw_Button(BTN_Continue, 86, 300);
     }
-    else
+  #else
+    constexpr bool isvalid = false;
   #endif
-  {
+
+  if (!isvalid) {
     Draw_Print_ProgressBar();
     Draw_Print_Labels();
     DWINUI::Draw_Icon(ICON_PrintTime, 15, 173);
     DWINUI::Draw_Icon(ICON_RemainTime, 150, 171);
     Draw_Print_ProgressElapsed();
     Draw_Print_ProgressRemain();
     DWINUI::Draw_Button(BTN_Continue, 86, 273);
   }
 }
 
@@ -724,25 +728,21 @@ void Goto_Main_Menu() {
 }
 
 // Draw X, Y, Z and blink if in an un-homed or un-trusted state
 void _update_axis_value(const AxisEnum axis, const uint16_t x, const uint16_t y, const bool force) {
   const bool draw_qmark = axis_should_home(axis),
              draw_empty = NONE(HOME_AFTER_DEACTIVATE, DISABLE_REDUCED_ACCURACY_WARNING) && !draw_qmark && !axis_is_trusted(axis);
 
   // Check for a position change
   static xyz_pos_t oldpos = { -1, -1, -1 };
 
-  #if ENABLED(SHOW_REAL_POS)
-    const float p = stepper.position(axis) / planner.settings.axis_steps_per_mm[axis];
-  #else
-    const float p = current_position[axis];
-  #endif
+  const float p = TERN(SHOW_REAL_POS, stepper.position(axis) / planner.settings.axis_steps_per_mm[axis], current_position[axis]);
 
   const bool changed = oldpos[axis] != p;
   if (changed) oldpos[axis] = p;
 
   if (force || changed || draw_qmark || draw_empty) {
     if (blink && draw_qmark)
       DWINUI::Draw_String(HMI_data.Coordinate_Color, HMI_data.Background_Color, x, y, F("  - ? -"));
     else if (blink && draw_empty)
       DWINUI::Draw_String(HMI_data.Coordinate_Color, HMI_data.Background_Color, x, y, F("       "));
     else
@@ -804,29 +804,23 @@ void update_variable() {
     if (_new_bed_target) _bedtarget = bt;
   #endif
   #if HAS_FAN
     static uint8_t _fanspeed = 0;
     const bool _new_fanspeed = _fanspeed != thermalManager.fan_speed[0];
     if (_new_fanspeed) _fanspeed = thermalManager.fan_speed[0];
   #endif
 
   if (IsMenu(TuneMenu) || IsMenu(TemperatureMenu)) {
     // Tune page temperature update
-    #if HAS_HOTEND
-      if (_new_hotend_target) HotendTargetItem->redraw();
-    #endif
-    #if HAS_HEATED_BED
-      if (_new_bed_target) BedTargetItem->redraw();
-    #endif
-    #if HAS_FAN
-      if (_new_fanspeed) FanSpeedItem->redraw();
-    #endif
+    TERN_(HAS_HOTEND, if (_new_hotend_target) HotendTargetItem->redraw());
+    TERN_(HAS_HEATED_BED, if (_new_bed_target) BedTargetItem->redraw());
+    TERN_(HAS_FAN, if (_new_fanspeed) FanSpeedItem->redraw());
   }
 
   // Bottom temperature update
 
   #if HAS_HOTEND
     if (_new_hotend_temp)
       DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 28, 384, _hotendtemp);
     if (_new_hotend_target)
       DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 25 + 4 * STAT_CHR_W + 6, 384, _hotendtarget);
 
@@ -949,22 +943,21 @@ void onClickSDItem() {
     const uint8_t row = FileMenu->line();
     Erase_Menu_Text(row);
     Draw_Menu_Line(row, 0, &shift_name[shift]);
 
     shift_name[lastchar] = c;
   }
 
   void FileMenuIdle(bool reset=false) {
     static bool hasUpDir = false;
     static uint8_t last_itemselected = 0;
-    static int8_t shift_amt = 0;
-    static int8_t shift_len = 0;
+    static int8_t shift_amt = 0, shift_len = 0;
     if (reset) {
       last_itemselected = 0;
       hasUpDir = !card.flag.workDirIsRoot; // is a SubDir
       return;
     }
     const uint8_t selected = FileMenu->selected;
     if (last_itemselected != selected) {
       if (last_itemselected >= 1 + hasUpDir) FileMenu->Items()[last_itemselected]->redraw(true);
       last_itemselected = selected;
       if (selected >= 1 + hasUpDir) {
@@ -1708,21 +1701,20 @@ void DWIN_CopySettingsFrom(const char * const buff) {
   TERN_(BAUD_RATE_GCODE, HMI_SetBaudRate());
   #if BOTH(LED_CONTROL_MENU, HAS_COLOR_LEDS)
     leds.set_color(
       HMI_data.Led_Color.r,
       HMI_data.Led_Color.g,
       HMI_data.Led_Color.b
       OPTARG(HAS_WHITE_LED, HMI_data.Led_Color.w)
     );
     leds.update();
   #endif
-
 }
 
 // Initialize or re-initialize the LCD
 void MarlinUI::init_lcd() {
   DEBUG_ECHOLNPGM("MarlinUI::init_lcd");
   delay(750);   // wait to wakeup screen
   const bool hs = DWIN_Handshake(); UNUSED(hs);
   DEBUG_ECHOPGM("DWIN_Handshake ");
   DEBUG_ECHOLNF(hs ? F("ok.") : F("error."));
   DWIN_Frame_SetDir(1);
@@ -1832,30 +1824,31 @@ void DWIN_RedrawScreen() {
   }
 
   void Goto_FilamentPurge() {
     pause_menu_response = PAUSE_RESPONSE_WAIT_FOR;
     Goto_Popup(Draw_Popup_FilamentPurge, onClick_FilamentPurge);
   }
 
 #endif // ADVANCED_PAUSE_FEATURE
 
 #if HAS_MESH
+
   void DWIN_MeshViewer() {
     if (!leveling_is_valid())
       DWIN_Popup_Continue(ICON_BLTouch, GET_TEXT_F(MSG_MESH_VIEWER), GET_TEXT_F(MSG_NO_VALID_MESH));
     else {
       HMI_SaveProcessID(WaitResponse);
       MeshViewer.Draw();
     }
   }
-#endif // HAS_MESH
 
+#endif // HAS_MESH
 
 #if HAS_LOCKSCREEN
 
   void DWIN_LockScreen() {
     if (checkkey != Locked) {
       lockScreen.rprocess = checkkey;
       checkkey = Locked;
       lockScreen.init();
     }
   }
@@ -1867,82 +1860,85 @@ void DWIN_RedrawScreen() {
     }
   }
 
   void HMI_LockScreen() {
     EncoderState encoder_diffState = get_encoder_state();
     if (encoder_diffState == ENCODER_DIFF_NO) return;
     lockScreen.onEncoder(encoder_diffState);
     if (lockScreen.isUnlocked()) DWIN_UnLockScreen();
   }
 
-#endif //  HAS_LOCKSCREEN
+#endif // HAS_LOCKSCREEN
 
 #if HAS_GCODE_PREVIEW
 
   void onClick_ConfirmToPrint() {
     Preview_Reset();
     DWIN_ResetStatusLine();
     if (HMI_flag.select_flag) {     // Confirm
       HMI_flag.heat_flag = true;
       Goto_Main_Menu();
       return card.openAndPrintFile(card.filename);
     }
-    else HMI_ReturnScreen();
+    else
+      HMI_ReturnScreen();
   }
 
-  void Goto_ConfirmToPrint() {
-    Goto_Popup(Preview_DrawFromSD, onClick_ConfirmToPrint);
-  }
+#endif
 
-#else
-  void Goto_ConfirmToPrint() {
+void Goto_ConfirmToPrint() {
+  #if HAS_GCODE_PREVIEW
+    Goto_Popup(Preview_DrawFromSD, onClick_ConfirmToPrint);
+  #else
     // Print SD file
     HMI_flag.heat_flag = true;
     card.openAndPrintFile(card.filename);
-  }
-#endif
+  #endif
+}
 
 #if HAS_ESDIAG
   void Draw_EndStopDiag() {
     HMI_SaveProcessID(ESDiagProcess);
     ESDiag.Draw();
   }
 #endif
 
 //=============================================================================
 // NEW MENU SUBSYSTEM
 //=============================================================================
 
 // Tool functions
 
 #if ENABLED(EEPROM_SETTINGS)
+
   void WriteEeprom() {
     DWIN_DrawStatusLine(GET_TEXT_F(MSG_STORE_EEPROM));
     DWIN_UpdateLCD();
     DONE_BUZZ(settings.save());
   }
 
   void ReadEeprom() {
     const bool success = settings.load();
     DWIN_RedrawScreen();
     DONE_BUZZ(success);
   }
 
   void ResetEeprom() {
     settings.reset();
     DWIN_RedrawScreen();
     DONE_BUZZ(true);
   }
 
   #if HAS_MESH
-    void SaveMesh() { TERN(AUTO_BED_LEVELING_UBL, UBLSaveMesh(), WriteEeprom()); }
+    void SaveMesh() { TERN(AUTO_BED_LEVELING_UBL, UBLMeshSave(), WriteEeprom()); }
   #endif
+
 #endif
 
 // Reset Printer
 void RebootPrinter() {
   wait_for_heatup = wait_for_user = false;    // Stop waiting for heating/user
   thermalManager.disable_all_heaters();
   planner.finish_and_disable();
   DWIN_RebootScreen();
   hal.reboot();
 }
@@ -2397,23 +2393,23 @@ void TramC () { Tram(4); }
     DWINUI::Draw_CenteredString(140, F("Calculating average"));
     DWINUI::Draw_CenteredString(160, F("and relative heights"));
     safe_delay(1000);
     float avg = 0.0f;
     LOOP_L_N(x, 2) LOOP_L_N(y, 2) avg += zval[x][y];
     avg /= 4.0f;
     LOOP_L_N(x, 2) LOOP_L_N(y, 2) zval[x][y] -= avg;
     MeshViewer.DrawMesh(zval, 2, 2);
     ui.reset_status();
 
-    if (ABS(MeshViewer.max - MeshViewer.min) < 0.05) {
-      DWINUI::Draw_CenteredString(140,F("Corners leveled"));
-      DWINUI::Draw_CenteredString(160,F("Tolerance achieved!"));
+    if (ABS(MeshViewer.max - MeshViewer.min) < 0.05f) {
+      DWINUI::Draw_CenteredString(140, F("Corners leveled"));
+      DWINUI::Draw_CenteredString(160, F("Tolerance achieved!"));
     }
     else {
       uint8_t p = 0;
       float max = 0;
       FSTR_P plabel;
       bool s = true;
       LOOP_L_N(x, 2) LOOP_L_N(y, 2) {
         const float d = ABS(zval[x][y]);
         if (max < d) {
           s = (zval[x][y] >= 0);
@@ -2691,21 +2687,20 @@ void onDrawGetColorItem(MenuItemClass* menuitem, int8_t line) {
     case 2: color = RGB(0, 0, 31); break; // Blue
     default: color = 0; break;
   }
   DWIN_Draw_Rectangle(0, HMI_data.Highlight_Color, ICOX + 1, MBASE(line) - 1 + 1, ICOX + 18, MBASE(line) - 1 + 18);
   DWIN_Draw_Rectangle(1, color, ICOX + 2, MBASE(line) - 1 + 2, ICOX + 17, MBASE(line) - 1 + 17);
   DWINUI::Draw_String(LBLX, MBASE(line) - 1, menuitem->caption);
   Draw_Menu_IntValue(HMI_data.Background_Color, line, 4, HMI_value.Color[i]);
   DWIN_Draw_HLine(HMI_data.SplitLine_Color, 16, MYPOS(line + 1), 240);
 }
 
-
 #if EITHER(PIDTEMP, PIDTEMPBED)
   void onDrawPIDi(MenuItemClass* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, unscalePID_i(*(float*)static_cast<MenuItemPtrClass*>(menuitem)->value)); }
   void onDrawPIDd(MenuItemClass* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, unscalePID_d(*(float*)static_cast<MenuItemPtrClass*>(menuitem)->value)); }
 #endif
 
 void onDrawSpeedItem(MenuItemClass* menuitem, int8_t line) {
   if (HMI_IsChinese()) menuitem->SetFrame(1, 116, 164, 171, 176);
   onDrawPIntMenu(menuitem, line);
 }
 
@@ -2884,29 +2879,31 @@ void onDrawMaxAccelZ(MenuItemClass* menuitem, int8_t line) {
     if (HMI_IsChinese()) {
       menuitem->SetFrame(1, 173, 133, 200, 147);
       DWIN_Frame_AreaCopy(1,   1, 180,  28, 192, LBLX + 27, MBASE(line));
       DWIN_Frame_AreaCopy(1, 202, 133, 228, 147, LBLX + 53, MBASE(line));
       DWIN_Frame_AreaCopy(1,   9, 150,  16, 160, LBLX + 83, MBASE(line));
     }
     onDrawPFloatMenu(menuitem, line);
   }
 
   #if HAS_HOTEND
+
     void onDrawMaxJerkE(MenuItemClass* menuitem, int8_t line) {
       if (HMI_IsChinese()) {
         menuitem->SetFrame(1, 173, 133, 200, 147);
         DWIN_Frame_AreaCopy(1,   1, 180,  28, 192, LBLX + 27, MBASE(line));
         DWIN_Frame_AreaCopy(1, 202, 133, 228, 147, LBLX + 53, MBASE(line));
         DWIN_Frame_AreaCopy(1,  18, 150,  25, 160, LBLX + 83, MBASE(line));
       }
       onDrawPFloatMenu(menuitem, line);
     }
+
   #endif
 
 #endif // HAS_CLASSIC_JERK
 
 void onDrawStepsX(MenuItemClass* menuitem, int8_t line) {
   if (HMI_IsChinese()) {
     menuitem->SetFrame(1, 153, 148, 194, 161);
     DWIN_Frame_AreaCopy(1, 229, 133, 236, 147, LBLX + 44, MBASE(line));      // X
   }
   onDrawPFloatMenu(menuitem, line);
@@ -2922,27 +2919,29 @@ void onDrawStepsY(MenuItemClass* menuitem, int8_t line) {
 
 void onDrawStepsZ(MenuItemClass* menuitem, int8_t line) {
   if (HMI_IsChinese()) {
     menuitem->SetFrame(1, 153, 148, 194, 161);
     DWIN_Frame_AreaCopy(1,   9, 150,  16, 160, LBLX + 44, MBASE(line));      // Z
   }
   onDrawPFloatMenu(menuitem, line);
 }
 
 #if HAS_HOTEND
+
   void onDrawStepsE(MenuItemClass* menuitem, int8_t line) {
     if (HMI_IsChinese()) {
       menuitem->SetFrame(1, 153, 148, 194, 161);
       DWIN_Frame_AreaCopy(1,  18, 150,  25, 160, LBLX + 44, MBASE(line));    // E
     }
     onDrawPFloatMenu(menuitem, line);
   }
+
 #endif
 
 #if HAS_ONESTEP_LEVELING
   void onDrawManualTramming(MenuItemClass* menuitem, int8_t line) { onDrawChkbMenu(menuitem, line, HMI_data.FullManualTramming); }
 #endif
 
 // Menu Creation and Drawing functions ======================================================
 
 frame_rect_t selrect(frame_rect_t) {
   if (HMI_IsChinese())
@@ -3099,52 +3098,56 @@ void Draw_Move_Menu() {
     #if HAS_HOTEND
       gcode.process_subcommands_now(F("G92E0"));  // reset extruder position
       EDIT_ITEM(ICON_Extruder, MSG_MOVE_E, onDrawMoveE, SetMoveE, &current_position.e);
     #endif
   }
   UpdateMenu(MoveMenu);
   if (!all_axes_trusted()) LCD_MESSAGE_F("WARNING: Current position unknown. Home axes.");
 }
 
 #if HAS_HOME_OFFSET
+
   void Draw_HomeOffset_Menu() {
     checkkey = Menu;
     if (SET_MENU(HomeOffMenu, MSG_SET_HOME_OFFSETS, 4)) {
       BACK_ITEM(Draw_PhySet_Menu);
       EDIT_ITEM(ICON_HomeOffsetX, MSG_HOME_OFFSET_X, onDrawPFloatMenu, SetHomeOffsetX, &home_offset.x);
       EDIT_ITEM(ICON_HomeOffsetY, MSG_HOME_OFFSET_Y, onDrawPFloatMenu, SetHomeOffsetY, &home_offset.y);
       EDIT_ITEM(ICON_HomeOffsetZ, MSG_HOME_OFFSET_Z, onDrawPFloatMenu, SetHomeOffsetZ, &home_offset.z);
     }
     UpdateMenu(HomeOffMenu);
   }
+
 #endif
 
 #if HAS_BED_PROBE
+
   void Draw_ProbeSet_Menu() {
     checkkey = Menu;
     if (SET_MENU(ProbeSetMenu, MSG_ZPROBE_SETTINGS, 9)) {
       BACK_ITEM(Draw_AdvancedSettings_Menu);
       EDIT_ITEM(ICON_ProbeOffsetX, MSG_ZPROBE_XOFFSET, onDrawPFloatMenu, SetProbeOffsetX, &probe.offset.x);
       EDIT_ITEM(ICON_ProbeOffsetY, MSG_ZPROBE_YOFFSET, onDrawPFloatMenu, SetProbeOffsetY, &probe.offset.y);
       EDIT_ITEM(ICON_ProbeOffsetZ, MSG_ZPROBE_ZOFFSET, onDrawPFloat2Menu, SetProbeOffsetZ, &probe.offset.z);
       #if ENABLED(BLTOUCH)
         MENU_ITEM(ICON_ProbeStow, MSG_MANUAL_STOW, onDrawMenuItem, ProbeStow);
         MENU_ITEM(ICON_ProbeDeploy, MSG_MANUAL_DEPLOY, onDrawMenuItem, ProbeDeploy);
         MENU_ITEM(ICON_BltouchReset, MSG_BLTOUCH_RESET, onDrawMenuItem, bltouch._reset);
         #if ENABLED(BLTOUCH_HS_MODE)
           EDIT_ITEM(ICON_HSMode, MSG_ENABLE_HS_MODE, onDrawChkbMenu, SetHSMode, &bltouch.high_speed_mode);
         #endif
       #endif
       MENU_ITEM(ICON_ProbeTest, MSG_M48_TEST, onDrawMenuItem, ProbeTest);
     }
     UpdateMenu(ProbeSetMenu);
   }
+
 #endif
 
 void Draw_FilSet_Menu() {
   checkkey = Menu;
   if (SET_MENU(FilSetMenu, MSG_FILAMENT_SET, 9)) {
     BACK_ITEM(Draw_AdvancedSettings_Menu);
     #if HAS_FILAMENT_SENSOR
       EDIT_ITEM(ICON_Runout, MSG_RUNOUT_ENABLE, onDrawChkbMenu, SetRunoutEnable, &runout.enabled);
     #endif
     #if HAS_FILAMENT_RUNOUT_DISTANCE
@@ -3198,32 +3201,35 @@ void Draw_GetColor_Menu() {
     MENU_ITEM(ICON_Cancel, MSG_BUTTON_CANCEL, onDrawMenuItem, Draw_SelectColors_Menu);
     MENU_ITEM(0, MSG_COLORS_RED, onDrawGetColorItem, SetRGBColor);
     MENU_ITEM(1, MSG_COLORS_GREEN, onDrawGetColorItem, SetRGBColor);
     MENU_ITEM(2, MSG_COLORS_BLUE, onDrawGetColorItem, SetRGBColor);
   }
   UpdateMenu(GetColorMenu);
   DWIN_Draw_Rectangle(1, *MenuData.P_Int, 20, 315, DWIN_WIDTH - 20, 335);
 }
 
 #if BOTH(CASE_LIGHT_MENU, CASELIGHT_USES_BRIGHTNESS)
+
   void Draw_CaseLight_Menu() {
     checkkey = Menu;
     if (SET_MENU(CaseLightMenu, MSG_CASE_LIGHT, 3)) {
       BACK_ITEM(Draw_Control_Menu);
       EDIT_ITEM(ICON_CaseLight, MSG_CASE_LIGHT, onDrawChkbMenu, SetCaseLight, &caselight.on);
       EDIT_ITEM(ICON_Brightness, MSG_CASE_LIGHT_BRIGHTNESS, onDrawPInt8Menu, SetCaseLightBrightness, &caselight.brightness);
     }
     UpdateMenu(CaseLightMenu);
   }
+
 #endif
 
 #if ENABLED(LED_CONTROL_MENU)
+
   void Draw_LedControl_Menu() {
     checkkey = Menu;
     if (SET_MENU(LedControlMenu, MSG_LED_CONTROL, 10)) {
       BACK_ITEM(Draw_Control_Menu);
       #if !BOTH(CASE_LIGHT_MENU, CASE_LIGHT_USE_NEOPIXEL)
         EDIT_ITEM(ICON_LedControl, MSG_LEDS, onDrawChkbMenu, SetLedStatus, &leds.lights_on);
       #endif
       #if HAS_COLOR_LEDS
         #if ENABLED(LED_COLOR_PRESETS)
           MENU_ITEM(ICON_LedControl, MSG_SET_LEDS_WHITE, onDrawMenuItem,  leds.set_white);
@@ -3239,21 +3245,22 @@ void Draw_GetColor_Menu() {
           EDIT_ITEM(ICON_LedControl, MSG_COLORS_GREEN, onDrawPInt8Menu, SetLEDColorG, &leds.color.g);
           EDIT_ITEM(ICON_LedControl, MSG_COLORS_BLUE, onDrawPInt8Menu, SetLEDColorB, &leds.color.b);
           #if ENABLED(HAS_WHITE_LED)
             EDIT_ITEM(ICON_LedControl, MSG_COLORS_WHITE, onDrawPInt8Menu, SetLEDColorW, &leds.color.w);
           #endif
         #endif
       #endif
     }
     UpdateMenu(LedControlMenu);
   }
-#endif
+
+#endif // LED_CONTROL_MENU
 
 void Draw_Tune_Menu() {
   checkkey = Menu;
   if (SET_MENU_R(TuneMenu, selrect({73, 2, 28, 12}), MSG_TUNE, 14)) {
     BACK_ITEM(Goto_PrintProcess);
     EDIT_ITEM(ICON_Speed, MSG_SPEED, onDrawSpeedItem, SetSpeed, &feedrate_percentage);
     #if HAS_HOTEND
       HotendTargetItem = EDIT_ITEM(ICON_HotendTemp, MSG_UBL_SET_TEMP_HOTEND, onDrawHotendTemp, SetHotendTemp, &thermalManager.temp_hotend[0].target);
     #endif
     #if HAS_HEATED_BED
@@ -3302,51 +3309,55 @@ void Draw_Motion_Menu() {
     #if HAS_CLASSIC_JERK
       MENU_ITEM(ICON_MaxJerk, MSG_JERK, onDrawJerk, Draw_MaxJerk_Menu);
     #endif
     MENU_ITEM(ICON_Step, MSG_STEPS_PER_MM, onDrawSteps, Draw_Steps_Menu);
     EDIT_ITEM(ICON_Flow, MSG_FLOW, onDrawPIntMenu, SetFlow, &planner.flow_percentage[0]);
   }
   UpdateMenu(MotionMenu);
 }
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
+
   void Draw_FilamentMan_Menu() {
     checkkey = Menu;
     if (SET_MENU(FilamentMenu, MSG_FILAMENT_MAN, 5)) {
       BACK_ITEM(Draw_Prepare_Menu);
       #if ENABLED(NOZZLE_PARK_FEATURE)
         MENU_ITEM(ICON_Park, MSG_FILAMENT_PARK_ENABLED, onDrawMenuItem, ParkHead);
       #endif
       MENU_ITEM(ICON_FilMan, MSG_FILAMENTCHANGE, onDrawMenuItem, ChangeFilament);
       #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
         MENU_ITEM(ICON_FilUnload, MSG_FILAMENTUNLOAD, onDrawMenuItem, UnloadFilament);
         MENU_ITEM(ICON_FilLoad, MSG_FILAMENTLOAD, onDrawMenuItem, LoadFilament);
       #endif
     }
     UpdateMenu(FilamentMenu);
   }
+
 #endif
 
 #if ENABLED(MESH_BED_LEVELING)
+
   void Draw_ManualMesh_Menu() {
     checkkey = Menu;
     if (SET_MENU(ManualMesh, MSG_UBL_MANUAL_MESH, 6)) {
       BACK_ITEM(Draw_Prepare_Menu);
       MENU_ITEM(ICON_ManualMesh, MSG_LEVEL_BED, onDrawMenuItem, ManualMeshStart);
       MMeshMoveZItem = EDIT_ITEM(ICON_Zoffset, MSG_MOVE_Z, onDrawMMeshMoveZ, SetMMeshMoveZ, &current_position.z);
       MENU_ITEM(ICON_Axis, MSG_UBL_CONTINUE_MESH, onDrawMenuItem, ManualMeshContinue);
       MENU_ITEM(ICON_MeshViewer, MSG_MESH_VIEW, onDrawSubMenu, DWIN_MeshViewer);
       MENU_ITEM(ICON_MeshSave, MSG_UBL_SAVE_MESH, onDrawMenuItem, ManualMeshSave);
     }
     UpdateMenu(ManualMesh);
   }
-#endif
+
+#endif // MESH_BED_LEVELING
 
 #if HAS_PREHEAT
 
   void Draw_Preheat_Menu(bool NotCurrent) {
     checkkey = Menu;
     if (NotCurrent) {
       BACK_ITEM(Draw_Temperature_Menu);
       #if HAS_HOTEND
         EDIT_ITEM(ICON_SetEndTemp, MSG_UBL_SET_TEMP_HOTEND, onDrawSetPreheatHotend, SetPreheatEndTemp, &ui.material_preset[HMI_value.Select].hotend_temp);
       #endif
@@ -3415,131 +3426,143 @@ void Draw_MaxAccel_Menu() {
     EDIT_ITEM(ICON_MaxAccY, MSG_AMAX_B, onDrawMaxAccelY, SetMaxAccelY, &planner.settings.max_acceleration_mm_per_s2[Y_AXIS]);
     EDIT_ITEM(ICON_MaxAccZ, MSG_AMAX_C, onDrawMaxAccelZ, SetMaxAccelZ, &planner.settings.max_acceleration_mm_per_s2[Z_AXIS]);
     #if HAS_HOTEND
       EDIT_ITEM(ICON_MaxAccE, MSG_AMAX_E, onDrawMaxAccelE, SetMaxAccelE, &planner.settings.max_acceleration_mm_per_s2[E_AXIS]);
     #endif
   }
   UpdateMenu(MaxAccelMenu);
 }
 
 #if HAS_CLASSIC_JERK
+
   void Draw_MaxJerk_Menu() {
     checkkey = Menu;
     if (SET_MENU_R(MaxJerkMenu, selrect({1, 16, 28, 13}), MSG_JERK, 5)) {
       BACK_ITEM(Draw_Motion_Menu);
       EDIT_ITEM(ICON_MaxSpeedJerkX, MSG_VA_JERK, onDrawMaxJerkX, SetMaxJerkX, &planner.max_jerk.x);
       EDIT_ITEM(ICON_MaxSpeedJerkY, MSG_VB_JERK, onDrawMaxJerkY, SetMaxJerkY, &planner.max_jerk.y);
       EDIT_ITEM(ICON_MaxSpeedJerkZ, MSG_VC_JERK, onDrawMaxJerkZ, SetMaxJerkZ, &planner.max_jerk.z);
       #if HAS_HOTEND
         EDIT_ITEM(ICON_MaxSpeedJerkE, MSG_VE_JERK, onDrawMaxJerkE, SetMaxJerkE, &planner.max_jerk.e);
       #endif
     }
     UpdateMenu(MaxJerkMenu);
   }
-#endif
+
+#endif // HAS_CLASSIC_JERK
 
 void Draw_Steps_Menu() {
   checkkey = Menu;
   if (SET_MENU_R(StepsMenu, selrect({1, 16, 28, 13}), MSG_STEPS_PER_MM, 5)) {
     BACK_ITEM(Draw_Motion_Menu);
     EDIT_ITEM(ICON_StepX, MSG_A_STEPS, onDrawStepsX, SetStepsX, &planner.settings.axis_steps_per_mm[X_AXIS]);
     EDIT_ITEM(ICON_StepY, MSG_B_STEPS, onDrawStepsY, SetStepsY, &planner.settings.axis_steps_per_mm[Y_AXIS]);
     EDIT_ITEM(ICON_StepZ, MSG_C_STEPS, onDrawStepsZ, SetStepsZ, &planner.settings.axis_steps_per_mm[Z_AXIS]);
     #if HAS_HOTEND
       EDIT_ITEM(ICON_StepE, MSG_E_STEPS, onDrawStepsE, SetStepsE, &planner.settings.axis_steps_per_mm[E_AXIS]);
     #endif
   }
   UpdateMenu(StepsMenu);
 }
 
 #if ENABLED(PIDTEMP)
+
   void Draw_HotendPID_Menu() {
     checkkey = Menu;
     if (SET_MENU_F(HotendPIDMenu, STR_HOTEND_PID " Settings", 8)) {
       BACK_ITEM(Draw_AdvancedSettings_Menu);
       MENU_ITEM_F(ICON_PIDNozzle, STR_HOTEND_PID, onDrawMenuItem, HotendPID);
       EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KP, onDrawPFloat2Menu, SetKp, &thermalManager.temp_hotend[0].pid.Kp);
       EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KI, onDrawPIDi, SetKi, &thermalManager.temp_hotend[0].pid.Ki);
       EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KD, onDrawPIDd, SetKd, &thermalManager.temp_hotend[0].pid.Kd);
       EDIT_ITEM(ICON_Temperature, MSG_TEMPERATURE, onDrawPIntMenu, SetHotendPidT, &HMI_data.HotendPidT);
       EDIT_ITEM(ICON_PIDCycles, MSG_PID_CYCLE, onDrawPIntMenu, SetPidCycles, &HMI_data.PidCycles);
       #if ENABLED(EEPROM_SETTINGS)
         MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawMenuItem, WriteEeprom);
       #endif
     }
     UpdateMenu(HotendPIDMenu);
   }
+
 #endif
 
 #if ENABLED(PIDTEMPBED)
+
   void Draw_BedPID_Menu() {
     checkkey = Menu;
     if (SET_MENU_F(BedPIDMenu, STR_BED_PID " Settings", 8)) {
       BACK_ITEM(Draw_AdvancedSettings_Menu);
       MENU_ITEM_F(ICON_PIDBed, STR_BED_PID, onDrawMenuItem,BedPID);
       EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KP, onDrawPFloat2Menu, SetKp, &thermalManager.temp_bed.pid.Kp);
       EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KI, onDrawPIDi, SetKi, &thermalManager.temp_bed.pid.Ki);
       EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KD, onDrawPIDd, SetKd, &thermalManager.temp_bed.pid.Kd);
       EDIT_ITEM(ICON_Temperature, MSG_TEMPERATURE, onDrawPIntMenu, SetBedPidT, &HMI_data.BedPidT);
       EDIT_ITEM(ICON_PIDCycles, MSG_PID_CYCLE, onDrawPIntMenu, SetPidCycles, &HMI_data.PidCycles);
       #if ENABLED(EEPROM_SETTINGS)
         MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawMenuItem, WriteEeprom);
       #endif
     }
     UpdateMenu(BedPIDMenu);
   }
-#endif
+
+#endif // PIDTEMPBED
 
 #if HAS_BED_PROBE
+
   void Draw_ZOffsetWiz_Menu() {
     checkkey = Menu;
     if (SET_MENU(ZOffsetWizMenu, MSG_PROBE_WIZARD, 4)) {
       BACK_ITEM(Draw_Prepare_Menu);
       MENU_ITEM(ICON_Homing, MSG_AUTO_HOME, onDrawMenuItem, AutoHome);
       MENU_ITEM_F(ICON_MoveZ0, "Move Z to Home", onDrawMenuItem, SetMoveZto0);
       EDIT_ITEM(ICON_Zoffset, MSG_ZPROBE_ZOFFSET, onDrawPFloat2Menu, SetZOffset, &BABY_Z_VAR);
     }
     UpdateMenu(ZOffsetWizMenu);
     if (!axis_is_trusted(Z_AXIS)) LCD_MESSAGE_F("WARNING: Z position unknown, move Z to home");
   }
+
 #endif
 
 #if ENABLED(INDIVIDUAL_AXIS_HOMING_SUBMENU)
+
   void Draw_Homing_Menu() {
     checkkey = Menu;
     if (SET_MENU(HomingMenu, MSG_HOMING, 6)) {
       BACK_ITEM(Draw_Prepare_Menu);
       MENU_ITEM(ICON_Homing, MSG_AUTO_HOME, onDrawMenuItem, AutoHome);
       MENU_ITEM(ICON_HomeX, MSG_AUTO_HOME_X, onDrawMenuItem, HomeX);
       MENU_ITEM(ICON_HomeY, MSG_AUTO_HOME_Y, onDrawMenuItem, HomeY);
       MENU_ITEM(ICON_HomeZ, MSG_AUTO_HOME_Z, onDrawMenuItem, HomeZ);
       #if ENABLED(MESH_BED_LEVELING)
         EDIT_ITEM(ICON_ZAfterHome, MSG_Z_AFTER_HOME, onDrawPInt8Menu, SetZAfterHoming, &HMI_data.z_after_homing);
       #endif
     }
     UpdateMenu(HomingMenu);
   }
+
 #endif
 
 #if ENABLED(FWRETRACT)
+
   void Draw_FWRetract_Menu() {
     checkkey = Menu;
     if (SET_MENU(FWRetractMenu, MSG_FWRETRACT, 6)) {
       BACK_ITEM(Return_FWRetract_Menu);
       EDIT_ITEM(ICON_FWRetLength, MSG_CONTROL_RETRACT, onDrawPFloatMenu, SetRetractLength, &fwretract.settings.retract_length);
       EDIT_ITEM(ICON_FWRetSpeed, MSG_SINGLENOZZLE_RETRACT_SPEED, onDrawPFloatMenu, SetRetractSpeed, &fwretract.settings.retract_feedrate_mm_s);
       EDIT_ITEM(ICON_FWRetZRaise, MSG_CONTROL_RETRACT_ZHOP, onDrawPFloat2Menu, SetZRaise, &fwretract.settings.retract_zraise);
       EDIT_ITEM(ICON_FWRecSpeed, MSG_SINGLENOZZLE_UNRETRACT_SPEED, onDrawPFloatMenu, SetRecoverSpeed, &fwretract.settings.retract_recover_feedrate_mm_s);
       EDIT_ITEM(ICON_FWRecExtra, MSG_CONTROL_RETRACT_RECOVER, onDrawPFloatMenu, SetAddRecover, &fwretract.settings.retract_recover_extra);
     }
     UpdateMenu(FWRetractMenu);
   }
+
 #endif
 
 //=============================================================================
 // Mesh Bed Leveling
 //=============================================================================
 
 #if HAS_MESH
 
   void ApplyMeshFadeHeight() { set_z_fade_height(planner.z_fade_height); }
   void SetMeshFadeHeight() { SetPFloatOnClick(0, 100, 1, ApplyMeshFadeHeight); }
@@ -3558,60 +3581,61 @@ void Draw_Steps_Menu() {
     #define Z_OFFSET_MIN -3
     #define Z_OFFSET_MAX  3
 
     void LiveEditMesh() { ((MenuItemPtrClass*)EditZValueItem)->value = &bedlevel.z_values[HMI_value.Select ? bedLevelTools.mesh_x : MenuData.Value][HMI_value.Select ? MenuData.Value : bedLevelTools.mesh_y]; EditZValueItem->redraw(); }
     void ApplyEditMeshX() { bedLevelTools.mesh_x = MenuData.Value; }
     void SetEditMeshX() { HMI_value.Select = 0; SetIntOnClick(0, GRID_MAX_POINTS_X - 1, bedLevelTools.mesh_x, ApplyEditMeshX, LiveEditMesh); }
     void ApplyEditMeshY() { bedLevelTools.mesh_y = MenuData.Value; }
     void SetEditMeshY() { HMI_value.Select = 1; SetIntOnClick(0, GRID_MAX_POINTS_Y - 1, bedLevelTools.mesh_y, ApplyEditMeshY, LiveEditMesh); }
     void SetEditZValue() { SetPFloatOnClick(Z_OFFSET_MIN, Z_OFFSET_MAX, 3); }
   #endif
-#endif
+
+#endif // HAS_MESH
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
 
   void ApplyUBLSlot() { bedlevel.storage_slot = MenuData.Value; }
   void SetUBLSlot() { SetIntOnClick(0, settings.calc_num_meshes() - 1, bedlevel.storage_slot, ApplyUBLSlot); }
   void onDrawUBLSlot(MenuItemClass* menuitem, int8_t line) {
-    if (bedlevel.storage_slot < 0) bedlevel.storage_slot = 0;
+    NOLESS(bedlevel.storage_slot, 0);
     onDrawIntMenu(menuitem, line, bedlevel.storage_slot);
   }
 
   void ApplyUBLTiltGrid() { bedLevelTools.tilt_grid = MenuData.Value; }
   void SetUBLTiltGrid() { SetIntOnClick(1, 3, bedLevelTools.tilt_grid, ApplyUBLTiltGrid); }
 
-  void UBLTiltMesh() {
-    if (bedlevel.storage_slot < 0) bedlevel.storage_slot = 0;
+  void UBLMeshTilt() {
+    NOLESS(bedlevel.storage_slot, 0);
     char buf[15];
     if (bedLevelTools.tilt_grid > 1) {
       sprintf_P(buf, PSTR("G28O\nG29 J%i"), bedLevelTools.tilt_grid);
       gcode.process_subcommands_now(buf);
     }
     else
       gcode.process_subcommands_now(F("G28O\nG29J"));
     LCD_MESSAGE(MSG_UBL_MESH_TILTED);
   }
 
   void UBLSmartFillMesh() {
     LOOP_L_N(x, GRID_MAX_POINTS_Y) bedlevel.smart_fill_mesh();
     LCD_MESSAGE(MSG_UBL_MESH_FILLED);
   }
 
-  void UBLSaveMesh() {
-    if (bedlevel.storage_slot < 0) bedlevel.storage_slot = 0;
+  void UBLMeshSave() {
+    NOLESS(bedlevel.storage_slot, 0);
     settings.store_mesh(bedlevel.storage_slot);
     ui.status_printf(0, GET_TEXT_F(MSG_MESH_SAVED), bedlevel.storage_slot);
     DONE_BUZZ(true);
   }
 
-  void UBLLoadMesh() {
-    if (bedlevel.storage_slot < 0) bedlevel.storage_slot = 0;
+  void UBLMeshLoad() {
+    NOLESS(bedlevel.storage_slot, 0);
     settings.load_mesh(bedlevel.storage_slot);
   }
 
 #endif // AUTO_BED_LEVELING_UBL
 
 #if HAS_MESH
 
   void Draw_MeshSet_Menu() {
     checkkey = Menu;
     if (SET_MENU(MeshMenu, MSG_MESH_LEVELING, 13)) {
@@ -3619,24 +3643,24 @@ void Draw_Steps_Menu() {
       #if ENABLED(PREHEAT_BEFORE_LEVELING)
         EDIT_ITEM(ICON_Temperature, MSG_UBL_SET_TEMP_BED, onDrawPIntMenu, SetBedLevT, &HMI_data.BedLevT);
       #endif
       EDIT_ITEM(ICON_SetZOffset, MSG_Z_FADE_HEIGHT, onDrawPFloatMenu, SetMeshFadeHeight, &planner.z_fade_height);
       EDIT_ITEM(ICON_UBLActive, MSG_ACTIVATE_MESH, onDrawChkbMenu, SetMeshActive, &planner.leveling_active);
       #if HAS_BED_PROBE
         MENU_ITEM(ICON_Level, MSG_AUTO_MESH, onDrawMenuItem, AutoLev);
       #endif
       #if ENABLED(AUTO_BED_LEVELING_UBL)
         EDIT_ITEM(ICON_UBLSlot, MSG_UBL_STORAGE_SLOT, onDrawUBLSlot, SetUBLSlot, &bedlevel.storage_slot);
-        MENU_ITEM(ICON_UBLSaveMesh, MSG_UBL_SAVE_MESH, onDrawMenuItem, UBLSaveMesh);
-        MENU_ITEM(ICON_UBLLoadMesh, MSG_UBL_LOAD_MESH, onDrawMenuItem, UBLLoadMesh);
+        MENU_ITEM(ICON_UBLMeshSave, MSG_UBL_SAVE_MESH, onDrawMenuItem, UBLMeshSave);
+        MENU_ITEM(ICON_UBLMeshLoad, MSG_UBL_LOAD_MESH, onDrawMenuItem, UBLMeshLoad);
         EDIT_ITEM(ICON_UBLTiltGrid, MSG_UBL_TILTING_GRID, onDrawPInt8Menu, SetUBLTiltGrid, &bedLevelTools.tilt_grid);
-        MENU_ITEM(ICON_UBLTiltGrid, MSG_UBL_TILT_MESH, onDrawMenuItem, UBLTiltMesh);
+        MENU_ITEM(ICON_UBLTiltGrid, MSG_UBL_TILT_MESH, onDrawMenuItem, UBLMeshTilt);
         MENU_ITEM(ICON_UBLSmartFill, MSG_UBL_SMART_FILLIN, onDrawMenuItem, UBLSmartFillMesh);
       #endif
       #if ENABLED(MESH_EDIT_MENU)
         MENU_ITEM(ICON_MeshEdit, MSG_EDIT_MESH, onDrawSubMenu, Draw_EditMesh_Menu);
       #endif
       MENU_ITEM(ICON_MeshViewer, MSG_MESH_VIEW, onDrawSubMenu, DWIN_MeshViewer);
     }
     UpdateMenu(MeshMenu);
   }
 

commit 5fd5cb02f6b26f32fd9b49fb37e53a93531da98c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jan 14 07:44:57 2023 -0600

    ‚úèÔ∏è  ProUI followup

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 098db27b1b..ffb216f05f 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -867,21 +867,21 @@ void update_variable() {
   _draw_xyz_position(false);
 }
 
 /**
  * Memory card and file management
  */
 
 bool DWIN_lcd_sd_status = false;
 
 void SetMediaAutoMount() {
-  Toogle_Chkb_Line(HMI_data.MediaAutoMount);
+  Toggle_Chkb_Line(HMI_data.MediaAutoMount);
 }
 
 inline uint16_t nr_sd_menu_items() {
   return _MIN(card.get_num_Files() + !card.flag.workDirIsRoot, MENU_MAX_ITEMS);
 }
 
 void make_name_without_ext(char *dst, char *src, size_t maxlen=MENU_CHAR_LIMIT) {
   size_t pos = strlen(src);  // index of ending nul
 
   // For files, remove the extension
@@ -2029,21 +2029,21 @@ void AutoHome() { queue.inject_P(G28_STR); }
 
 void DoCoolDown() { thermalManager.cooldown(); }
 
 void SetLanguage() {
   HMI_ToggleLanguage();
   CurrentMenu = nullptr;  // Invalidate menu to full redraw
   Draw_Prepare_Menu();
 }
 
 bool EnableLiveMove = false;
-void SetLiveMove() { Toogle_Chkb_Line(EnableLiveMove); }
+void SetLiveMove() { Toggle_Chkb_Line(EnableLiveMove); }
 void LiveMove() {
   planner.synchronize();
   if (!EnableLiveMove) return;
   *MenuData.P_Float = MenuData.Value / MINUNITMULT;
   if (!planner.is_full()) planner.buffer_line(current_position, manual_feedrate_mm_s[HMI_value.axis]);
 }
 void ApplyMove() {
   planner.synchronize();
   if (EnableLiveMove) return;
   if (HMI_value.axis == E_AXIS) last_E = MenuData.Value / MINUNITMULT;
@@ -2075,21 +2075,21 @@ void SetMoveZ() { HMI_value.axis = Z_AXIS; SetPFloatOnClick(Z_MIN_POS, Z_MAX_POS
   #if ENABLED(PIDTEMP)
     void HotendPID() { SetPID(HMI_data.HotendPidT, H_E0); }
   #endif
   #if ENABLED(PIDTEMPBED)
     void BedPID() { SetPID(HMI_data.BedPidT, H_BED); }
   #endif
 #endif
 
 #if ENABLED(POWER_LOSS_RECOVERY)
   void SetPwrLossr() {
-    Toogle_Chkb_Line(recovery.enabled);
+    Toggle_Chkb_Line(recovery.enabled);
     recovery.changed();
   }
 #endif
 
 #if ENABLED(BAUD_RATE_GCODE)
   void HMI_SetBaudRate() { HMI_data.Baud115K ? SetBaud115K() : SetBaud250K(); }
   void SetBaudRate() {
     HMI_data.Baud115K ^= true;
     HMI_SetBaudRate();
     Draw_Chkb_Line(CurrentMenu->line(), HMI_data.Baud115K);
@@ -2101,21 +2101,21 @@ void SetMoveZ() { HMI_value.axis = Z_AXIS; SetPFloatOnClick(Z_MIN_POS, Z_MAX_POS
 
 #if HAS_LCD_BRIGHTNESS
   void ApplyBrightness() { ui.set_brightness(MenuData.Value); }
   void LiveBrightness() { DWIN_LCD_Brightness(MenuData.Value); }
   void SetBrightness() { SetIntOnClick(LCD_BRIGHTNESS_MIN, LCD_BRIGHTNESS_MAX, ui.brightness, ApplyBrightness, LiveBrightness); }
   void TurnOffBacklight() { HMI_SaveProcessID(WaitResponse); ui.set_brightness(0); DWIN_RedrawScreen(); }
 #endif
 
 #if ENABLED(CASE_LIGHT_MENU)
   void SetCaseLight() {
-    Toogle_Chkb_Line(caselight.on);
+    Toggle_Chkb_Line(caselight.on);
     caselight.update_enabled();
   }
   #if ENABLED(CASELIGHT_USES_BRIGHTNESS)
     void LiveCaseLightBrightness() { caselight.brightness = MenuData.Value; caselight.update_brightness(); }
     void SetCaseLightBrightness() { SetIntOnClick(0, 255, caselight.brightness, nullptr, LiveCaseLightBrightness); }
   #endif
 #endif
 
 #if ENABLED(LED_CONTROL_MENU)
   #if !BOTH(CASE_LIGHT_MENU, CASE_LIGHT_USE_NEOPIXEL)
@@ -2137,21 +2137,21 @@ void SetMoveZ() { HMI_value.axis = Z_AXIS; SetPFloatOnClick(Z_MIN_POS, Z_MAX_POS
     void SetLEDColorB() { SetIntOnClick(0, 255, leds.color.b, ApplyLEDColor, LiveLEDColorB); }
     #if HAS_WHITE_LED
       void LiveLEDColorW() { LiveLEDColor(&leds.color.w); }
       void SetLEDColorW() { SetIntOnClick(0, 255, leds.color.w, ApplyLEDColor, LiveLEDColorW); }
     #endif
   #endif
 #endif
 
 #if ENABLED(SOUND_MENU_ITEM)
   void SetEnableSound() {
-    Toogle_Chkb_Line(ui.sound_on);
+    Toggle_Chkb_Line(ui.sound_on);
   }
 #endif
 
 #if HAS_HOME_OFFSET
   void ApplyHomeOffset() { set_home_offset(HMI_value.axis, MenuData.Value / MINUNITMULT); }
   void SetHomeOffsetX() { HMI_value.axis = X_AXIS; SetPFloatOnClick(-50, 50, UNITFDIGITS, ApplyHomeOffset); }
   void SetHomeOffsetY() { HMI_value.axis = Y_AXIS; SetPFloatOnClick(-50, 50, UNITFDIGITS, ApplyHomeOffset); }
   void SetHomeOffsetZ() { HMI_value.axis = Z_AXIS; SetPFloatOnClick( -2,  2, UNITFDIGITS, ApplyHomeOffset); }
 #endif
 
@@ -2161,30 +2161,30 @@ void SetMoveZ() { HMI_value.axis = Z_AXIS; SetPFloatOnClick(Z_MIN_POS, Z_MAX_POS
   void SetProbeOffsetZ() { SetPFloatOnClick(-10, 10, 2); }
   void ProbeTest() {
     LCD_MESSAGE(MSG_M48_TEST);
     queue.inject(F("G28O\nM48 P10"));
   }
   void ProbeStow() { probe.stow(); }
   void ProbeDeploy() { probe.deploy(); }
 
   #if ENABLED(BLTOUCH_HS_MODE)
     void SetHSMode() {
-      Toogle_Chkb_Line(bltouch.high_speed_mode);
+      Toggle_Chkb_Line(bltouch.high_speed_mode);
     }
   #endif
 
 #endif
 
 #if HAS_FILAMENT_SENSOR
   void SetRunoutEnable() {
     runout.reset();
-    Toogle_Chkb_Line(runout.enabled);
+    Toggle_Chkb_Line(runout.enabled);
   }
   #if HAS_FILAMENT_RUNOUT_DISTANCE
     void ApplyRunoutDistance() { runout.set_runout_distance(MenuData.Value / MINUNITMULT); }
     void SetRunoutDistance() { SetFloatOnClick(0, 999, UNITFDIGITS, runout.runout_distance(), ApplyRunoutDistance); }
   #endif
 #endif
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   void SetFilLoad()   { SetPFloatOnClick(0, MAX_LOAD_UNLOAD, UNITFDIGITS); }
   void SetFilUnload() { SetPFloatOnClick(0, MAX_LOAD_UNLOAD, UNITFDIGITS); }
@@ -2432,21 +2432,21 @@ void TramC () { Tram(4); }
       DWINUI::Draw_CenteredString(140, F("Knob adjustment required"));
       DWINUI::Draw_CenteredString(Color_Green, 160, s ? F("Lower") : F("Raise"));
       DWINUI::Draw_CenteredString(Color_Green, 180, plabel);
     }
     DWINUI::Draw_Button(BTN_Continue, 86, 305);
     checkkey = Menu;
     HMI_SaveProcessID(WaitResponse);
   }
 
   void SetManualTramming() {
-    Toogle_Chkb_Line(HMI_data.FullManualTramming);
+    Toggle_Chkb_Line(HMI_data.FullManualTramming);
   }
 
 #endif // HAS_BED_PROBE && HAS_MESH
 
 #if ENABLED(MESH_BED_LEVELING)
 
   void ManualMeshStart() {
     LCD_MESSAGE(MSG_UBL_BUILD_MESH_MENU);
     gcode.process_subcommands_now(F("G28XYO\nG28Z\nM211S0\nG29S1"));
     #ifdef MANUAL_PROBE_START_Z

commit 01e58de31a804731d21c491952afd2347fda3753
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jan 10 22:38:08 2023 -0600

    ü©π ProUI - Remove ManualZOffset

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index deefbf2573..098db27b1b 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -102,28 +102,22 @@
 #endif
 
 #if HAS_BED_PROBE
   #include "../../../module/probe.h"
 #endif
 
 #if ENABLED(BLTOUCH)
   #include "../../../feature/bltouch.h"
 #endif
 
-#if EITHER(BABYSTEPPING, HAS_BED_PROBE)
-  #define HAS_ZOFFSET_ITEM 1
-  #if ENABLED(BABYSTEPPING)
-    #include "../../../feature/babystep.h"
-    #if !HAS_BED_PROBE
-      #define JUST_BABYSTEP 1
-    #endif
-  #endif
+#if ENABLED(BABYSTEPPING)
+  #include "../../../feature/babystep.h"
 #endif
 
 #if ENABLED(POWER_LOSS_RECOVERY)
   #include "../../../feature/powerloss.h"
 #endif
 
 #if ENABLED(PRINTCOUNTER)
   #include "printstats.h"
 #endif
 
@@ -190,22 +184,22 @@
 // Editable temperature limits
 #define MIN_ETEMP  0
 #define MAX_ETEMP  (thermalManager.hotend_maxtemp[0] - (HOTEND_OVERSHOOT))
 #define MIN_BEDTEMP 0
 #define MAX_BEDTEMP BED_MAX_TARGET
 
 #define DWIN_VAR_UPDATE_INTERVAL         1024
 #define DWIN_UPDATE_INTERVAL             1024
 #define DWIN_REMAIN_TIME_UPDATE_INTERVAL SEC_TO_MS(20)
 
-#if HAS_MESH
-  #define BABY_Z_VAR TERN(HAS_BED_PROBE, probe.offset.z, HMI_data.ManualZOffset)
+#if HAS_MESH && HAS_BED_PROBE
+  #define BABY_Z_VAR probe.offset.z
 #else
   float z_offset = 0;
   #define BABY_Z_VAR z_offset
 #endif
 
 // Structs
 HMI_value_t HMI_value;
 HMI_flag_t HMI_flag{0};
 HMI_data_t HMI_data;
 
@@ -1466,24 +1460,20 @@ void HMI_SaveProcessID(const uint8_t id) {
 
 void DWIN_HomingStart() {
   HMI_flag.home_flag = true;
   HMI_SaveProcessID(Homing);
   Title.ShowCaption(GET_TEXT_F(MSG_HOMING));
   DWIN_Show_Popup(ICON_BLTouch, GET_TEXT_F(MSG_HOMING), GET_TEXT_F(MSG_PLEASE_WAIT));
 }
 
 void DWIN_HomingDone() {
   HMI_flag.home_flag = false;
-  #if DISABLED(HAS_BED_PROBE) && EITHER(BABYSTEP_ZPROBE_OFFSET, JUST_BABYSTEP)
-    planner.synchronize();
-    babystep.add_mm(Z_AXIS, HMI_data.ManualZOffset);
-  #endif
   HMI_ReturnScreen();
 }
 
 void DWIN_LevelingStart() {
   #if HAS_BED_PROBE
     HMI_SaveProcessID(Leveling);
     Title.ShowCaption(GET_TEXT_F(MSG_BED_LEVELING));
     DWIN_Show_Popup(ICON_AutoLeveling, GET_TEXT_F(MSG_BED_LEVELING), GET_TEXT_F(MSG_PLEASE_WAIT));
     #if BOTH(AUTO_BED_LEVELING_UBL, PREHEAT_BEFORE_LEVELING)
       #if HAS_HOTEND
@@ -1689,21 +1679,20 @@ void DWIN_SetDataDefaults() {
     HMI_data.ExtMinT = EXTRUDE_MINTEMP;
     ApplyExtMinT();
   #endif
   TERN_(PREHEAT_BEFORE_LEVELING, HMI_data.BedLevT = LEVELING_BED_TEMP);
   TERN_(BAUD_RATE_GCODE, SetBaud250K());
   HMI_data.FullManualTramming = false;
   HMI_data.MediaAutoMount = ENABLED(HAS_SD_EXTENDER);
   #if BOTH(INDIVIDUAL_AXIS_HOMING_SUBMENU, MESH_BED_LEVELING)
     HMI_data.z_after_homing = DEF_Z_AFTER_HOMING;
   #endif
-  IF_DISABLED(HAS_BED_PROBE, HMI_data.ManualZOffset = 0);
   #if BOTH(LED_CONTROL_MENU, HAS_COLOR_LEDS)
     TERN_(LED_COLOR_PRESETS, leds.set_default());
     ApplyLEDColor();
   #endif
 }
 
 void DWIN_CopySettingsTo(char * const buff) {
   DEBUG_ECHOLNPGM("DWIN_CopySettingsTo");
   DEBUG_ECHOLNPGM("HMI_data: ", sizeof(HMI_data_t));
   memcpy(buff, &HMI_data, eeprom_data_size);

commit 202114c018dc22513e74c5b76e92ecda53214310
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jan 8 20:00:13 2023 -0600

    üêõ Fix ProUI with disabled PID, mesh, etc.

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index a5570026d0..deefbf2573 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -190,21 +190,26 @@
 // Editable temperature limits
 #define MIN_ETEMP  0
 #define MAX_ETEMP  (thermalManager.hotend_maxtemp[0] - (HOTEND_OVERSHOOT))
 #define MIN_BEDTEMP 0
 #define MAX_BEDTEMP BED_MAX_TARGET
 
 #define DWIN_VAR_UPDATE_INTERVAL         1024
 #define DWIN_UPDATE_INTERVAL             1024
 #define DWIN_REMAIN_TIME_UPDATE_INTERVAL SEC_TO_MS(20)
 
-#define BABY_Z_VAR TERN(HAS_BED_PROBE, probe.offset.z, HMI_data.ManualZOffset)
+#if HAS_MESH
+  #define BABY_Z_VAR TERN(HAS_BED_PROBE, probe.offset.z, HMI_data.ManualZOffset)
+#else
+  float z_offset = 0;
+  #define BABY_Z_VAR z_offset
+#endif
 
 // Structs
 HMI_value_t HMI_value;
 HMI_flag_t HMI_flag{0};
 HMI_data_t HMI_data;
 
 enum SelectItem : uint8_t {
   PAGE_PRINT = 0,
   PAGE_PREPARE,
   PAGE_CONTROL,
@@ -1513,76 +1518,85 @@ void DWIN_LevelingDone() {
 // PID process
 
 #if HAS_PIDPLOT
   void DWIN_Draw_PIDPopup() {
     frame_rect_t gfrm = {40, 180, DWIN_WIDTH - 80, 120};
     DWINUI::ClearMainArea();
     Draw_Popup_Bkgd();
     DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 100, GET_TEXT_F(MSG_PID_AUTOTUNE));
     DWINUI::Draw_String(HMI_data.PopupTxt_Color, gfrm.x, gfrm.y - DWINUI::fontHeight() - 4, F("PID target:    Celsius"));
     switch (HMI_value.pidresult) {
-      case PIDTEMP_START:
-        DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 120, F("for Nozzle is running."));
-        Plot.Draw(gfrm, thermalManager.hotend_maxtemp[0], HMI_data.HotendPidT);
-        DWINUI::Draw_Int(HMI_data.PopupTxt_Color, 3, gfrm.x + 90, gfrm.y - DWINUI::fontHeight() - 4, HMI_data.HotendPidT);
-        break;
-      case PIDTEMPBED_START:
-        DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 120, F("for BED is running."));
-        Plot.Draw(gfrm, BED_MAXTEMP, HMI_data.BedPidT);
-        DWINUI::Draw_Int(HMI_data.PopupTxt_Color, 3, gfrm.x + 90, gfrm.y - DWINUI::fontHeight() - 4, HMI_data.BedPidT);
-        break;
-      default:
-        break;
+      #if ENABLED(PIDTEMP)
+        case PIDTEMP_START:
+          DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 120, F("for Nozzle is running."));
+          Plot.Draw(gfrm, thermalManager.hotend_maxtemp[0], HMI_data.HotendPidT);
+          DWINUI::Draw_Int(HMI_data.PopupTxt_Color, 3, gfrm.x + 90, gfrm.y - DWINUI::fontHeight() - 4, HMI_data.HotendPidT);
+          break;
+      #endif
+      #if ENABLED(PIDTEMPBED)
+        case PIDTEMPBED_START:
+          DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 120, F("for BED is running."));
+          Plot.Draw(gfrm, BED_MAXTEMP, HMI_data.BedPidT);
+          DWINUI::Draw_Int(HMI_data.PopupTxt_Color, 3, gfrm.x + 90, gfrm.y - DWINUI::fontHeight() - 4, HMI_data.BedPidT);
+          break;
+      #endif
+      default: break;
     }
   }
 #endif
 
-void DWIN_PidTuning(pidresult_t result) {
-  HMI_value.pidresult = result;
-  switch (result) {
-    case PIDTEMPBED_START:
-      HMI_SaveProcessID(PidProcess);
-      #if HAS_PIDPLOT
-        DWIN_Draw_PIDPopup();
-      #else
-        DWIN_Draw_Popup(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE), F("for BED is running."));
+#if EITHER(PIDTEMP, PIDTEMPBED)
+
+  void DWIN_PidTuning(pidresult_t result) {
+    HMI_value.pidresult = result;
+    switch (result) {
+      #if ENABLED(PIDTEMP)
+        case PIDTEMP_START:
+          HMI_SaveProcessID(PidProcess);
+          #if HAS_PIDPLOT
+            DWIN_Draw_PIDPopup();
+          #else
+            DWIN_Draw_Popup(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE), F("for Nozzle is running."));
+          #endif
+          break;
+        case PID_BAD_EXTRUDER_NUM:
+          checkkey = last_checkkey;
+          DWIN_Popup_Confirm(ICON_TempTooLow, GET_TEXT_F(MSG_PID_AUTOTUNE_FAILED), GET_TEXT_F(MSG_BAD_EXTRUDER_NUM));
+          break;
       #endif
-      break;
-    case PIDTEMP_START:
-      HMI_SaveProcessID(PidProcess);
-      #if HAS_PIDPLOT
-        DWIN_Draw_PIDPopup();
-      #else
-        DWIN_Draw_Popup(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE), F("for Nozzle is running."));
+      #if ENABLED(PIDTEMPBED)
+        case PIDTEMPBED_START:
+          HMI_SaveProcessID(PidProcess);
+          #if HAS_PIDPLOT
+            DWIN_Draw_PIDPopup();
+          #else
+            DWIN_Draw_Popup(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE), F("for BED is running."));
+          #endif
+          break;
       #endif
-      break;
-    case PID_BAD_EXTRUDER_NUM:
-      checkkey = last_checkkey;
-      DWIN_Popup_Confirm(ICON_TempTooLow, GET_TEXT_F(MSG_PID_AUTOTUNE_FAILED), GET_TEXT_F(MSG_BAD_EXTRUDER_NUM));
-      break;
-    case PID_TUNING_TIMEOUT:
-      checkkey = last_checkkey;
-      DWIN_Popup_Confirm(ICON_TempTooHigh, GET_TEXT_F(MSG_ERROR), GET_TEXT_F(MSG_PID_TIMEOUT));
-      break;
-    case PID_TEMP_TOO_HIGH:
-      checkkey = last_checkkey;
-      DWIN_Popup_Confirm(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE_FAILED), GET_TEXT_F(MSG_TEMP_TOO_HIGH));
-      break;
-    case PID_DONE:
-      checkkey = last_checkkey;
-      DWIN_Popup_Confirm(ICON_TempTooLow, GET_TEXT_F(MSG_PID_AUTOTUNE), GET_TEXT_F(MSG_BUTTON_DONE));
-      break;
-    default:
-      checkkey = last_checkkey;
-      break;
+      case PID_TUNING_TIMEOUT:
+        checkkey = last_checkkey;
+        DWIN_Popup_Confirm(ICON_TempTooHigh, GET_TEXT_F(MSG_ERROR), GET_TEXT_F(MSG_PID_TIMEOUT));
+        break;
+      case PID_TEMP_TOO_HIGH:
+        checkkey = last_checkkey;
+        DWIN_Popup_Confirm(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE_FAILED), GET_TEXT_F(MSG_TEMP_TOO_HIGH));
+        break;
+      case PID_DONE:
+        checkkey = last_checkkey;
+        DWIN_Popup_Confirm(ICON_TempTooLow, GET_TEXT_F(MSG_PID_AUTOTUNE), GET_TEXT_F(MSG_BUTTON_DONE));
+        break;
+      default: checkkey = last_checkkey; break;
+    }
   }
-}
+
+#endif // PIDTEMP || PIDTEMPBED
 
 // Started a Print Job
 void DWIN_Print_Started() {
   DEBUG_ECHOLNPGM("DWIN_Print_Started: ", SD_Printing());
   TERN_(HAS_GCODE_PREVIEW, if (Host_Printing()) Preview_Invalidate());
   _percent_done = 0;
   _remain_time = 0;
   HMI_flag.percent_flag = false;
   HMI_flag.remain_flag = false;
   HMI_flag.pause_flag = false;
@@ -1668,32 +1682,28 @@ void DWIN_SetDataDefaults() {
   DEBUG_ECHOLNPGM("DWIN_SetDataDefaults");
   DWIN_SetColorDefaults();
   DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color, HMI_data.StatusBg_Color);
   TERN_(PIDTEMP, HMI_data.HotendPidT = DEF_HOTENDPIDT);
   TERN_(PIDTEMPBED, HMI_data.BedPidT = DEF_BEDPIDT);
   TERN_(HAS_PID_HEATING, HMI_data.PidCycles = DEF_PIDCYCLES);
   #if ENABLED(PREVENT_COLD_EXTRUSION)
     HMI_data.ExtMinT = EXTRUDE_MINTEMP;
     ApplyExtMinT();
   #endif
-  #if BOTH(HAS_HEATED_BED, PREHEAT_BEFORE_LEVELING)
-    HMI_data.BedLevT = LEVELING_BED_TEMP;
-  #endif
+  TERN_(PREHEAT_BEFORE_LEVELING, HMI_data.BedLevT = LEVELING_BED_TEMP);
   TERN_(BAUD_RATE_GCODE, SetBaud250K());
   HMI_data.FullManualTramming = false;
   HMI_data.MediaAutoMount = ENABLED(HAS_SD_EXTENDER);
   #if BOTH(INDIVIDUAL_AXIS_HOMING_SUBMENU, MESH_BED_LEVELING)
     HMI_data.z_after_homing = DEF_Z_AFTER_HOMING;
   #endif
-  #if DISABLED(HAS_BED_PROBE)
-    HMI_data.ManualZOffset = 0;
-  #endif
+  IF_DISABLED(HAS_BED_PROBE, HMI_data.ManualZOffset = 0);
   #if BOTH(LED_CONTROL_MENU, HAS_COLOR_LEDS)
     TERN_(LED_COLOR_PRESETS, leds.set_default());
     ApplyLEDColor();
   #endif
 }
 
 void DWIN_CopySettingsTo(char * const buff) {
   DEBUG_ECHOLNPGM("DWIN_CopySettingsTo");
   DEBUG_ECHOLNPGM("HMI_data: ", sizeof(HMI_data_t));
   memcpy(buff, &HMI_data, eeprom_data_size);
@@ -2055,35 +2065,37 @@ void SetMoveX() { HMI_value.axis = X_AXIS; SetPFloatOnClick(X_MIN_POS, X_MAX_POS
 void SetMoveY() { HMI_value.axis = Y_AXIS; SetPFloatOnClick(Y_MIN_POS, Y_MAX_POS, UNITFDIGITS, ApplyMove, LiveMove); }
 void SetMoveZ() { HMI_value.axis = Z_AXIS; SetPFloatOnClick(Z_MIN_POS, Z_MAX_POS, UNITFDIGITS, ApplyMove, LiveMove); }
 
 #if HAS_HOTEND
   void SetMoveE() {
     if (thermalManager.tooColdToExtrude(0)) return DWIN_Popup_Confirm(ICON_TempTooLow, GET_TEXT_F(MSG_HOTEND_TOO_COLD), GET_TEXT_F(MSG_PLEASE_PREHEAT));
     HMI_value.axis = E_AXIS; SetPFloatOnClick(E_MIN_POS, E_MAX_POS, UNITFDIGITS, ApplyMove, LiveMove);
   }
 #endif
 
-void SetPID(celsius_t t, heater_id_t h) {
-  char cmd[53] = "";
-  char str_1[5] = "", str_2[5] = "";
-  sprintf_P(cmd, PSTR("G28OXY\nG0Z5F300\nG0X%sY%sF5000\nM84\nM400"),
-    dtostrf(X_CENTER, 1, 1, str_1),
-    dtostrf(Y_CENTER, 1, 1, str_2)
-  );
-  gcode.process_subcommands_now(cmd);
-  thermalManager.PID_autotune(t, h, HMI_data.PidCycles, true);
-}
-#if ENABLED(PIDTEMP)
-  void HotendPID() { SetPID(HMI_data.HotendPidT, H_E0); }
-#endif
-#if ENABLED(PIDTEMPBED)
-  void BedPID() { SetPID(HMI_data.BedPidT, H_BED); }
+#if EITHER(PIDTEMP, PIDTEMPBED)
+  void SetPID(celsius_t t, heater_id_t h) {
+    char cmd[53] = "";
+    char str_1[5] = "", str_2[5] = "";
+    sprintf_P(cmd, PSTR("G28OXY\nG0Z5F300\nG0X%sY%sF5000\nM84\nM400"),
+      dtostrf(X_CENTER, 1, 1, str_1),
+      dtostrf(Y_CENTER, 1, 1, str_2)
+    );
+    gcode.process_subcommands_now(cmd);
+    thermalManager.PID_autotune(t, h, HMI_data.PidCycles, true);
+  }
+  #if ENABLED(PIDTEMP)
+    void HotendPID() { SetPID(HMI_data.HotendPidT, H_E0); }
+  #endif
+  #if ENABLED(PIDTEMPBED)
+    void BedPID() { SetPID(HMI_data.BedPidT, H_BED); }
+  #endif
 #endif
 
 #if ENABLED(POWER_LOSS_RECOVERY)
   void SetPwrLossr() {
     Toogle_Chkb_Line(recovery.enabled);
     recovery.changed();
   }
 #endif
 
 #if ENABLED(BAUD_RATE_GCODE)
@@ -2368,28 +2380,28 @@ void TramXY(const uint8_t point, const float &margin, float &x, float &y) {
   }
 
 #endif
 
 void TramFL() { Tram(0); }
 void TramFR() { Tram(1); }
 void TramBR() { Tram(2); }
 void TramBL() { Tram(3); }
 void TramC () { Tram(4); }
 
-#if HAS_BED_PROBE
+#if HAS_BED_PROBE && HAS_MESH
 
   void Trammingwizard() {
-    bed_mesh_t zval = {0};
     if (HMI_data.FullManualTramming) {
       LCD_MESSAGE_F("Disable manual tramming");
       return;
     }
+    bed_mesh_t zval = {0};
     zval[0][0] = Tram(0);
     checkkey = NothingToDo;
     MeshViewer.DrawMesh(zval, 2, 2);
     zval[1][0] = Tram(1);
     MeshViewer.DrawMesh(zval, 2, 2);
     zval[1][1] = Tram(2);
     MeshViewer.DrawMesh(zval, 2, 2);
     zval[0][1] = Tram(3);
     MeshViewer.DrawMesh(zval, 2, 2);
 
@@ -2434,21 +2446,21 @@ void TramC () { Tram(4); }
     }
     DWINUI::Draw_Button(BTN_Continue, 86, 305);
     checkkey = Menu;
     HMI_SaveProcessID(WaitResponse);
   }
 
   void SetManualTramming() {
     Toogle_Chkb_Line(HMI_data.FullManualTramming);
   }
 
-#endif // HAS_BED_PROBE
+#endif // HAS_BED_PROBE && HAS_MESH
 
 #if ENABLED(MESH_BED_LEVELING)
 
   void ManualMeshStart() {
     LCD_MESSAGE(MSG_UBL_BUILD_MESH_MENU);
     gcode.process_subcommands_now(F("G28XYO\nG28Z\nM211S0\nG29S1"));
     #ifdef MANUAL_PROBE_START_Z
       const uint8_t line = CurrentMenu->line(MMeshMoveZItem->pos);
       DWINUI::Draw_Signed_Float(HMI_data.Text_Color, HMI_data.Background_Color, 3, 2, VALX - 2 * DWINUI::fontWidth(DWIN_FONT_MENU), MBASE(line), MANUAL_PROBE_START_Z);
     #endif
@@ -2524,25 +2536,25 @@ void SetStepsZ() { HMI_value.axis = Z_AXIS, SetPFloatOnClick( MIN_STEP, MAX_STEP
 #endif
 #if ENABLED(PIDTEMPBED)
   void SetBedPidT() { SetPIntOnClick(MIN_BEDTEMP, MAX_BEDTEMP); }
 #endif
 
 #if EITHER(PIDTEMP, PIDTEMPBED)
   void SetPidCycles() { SetPIntOnClick(3, 50); }
   void SetKp() { SetPFloatOnClick(0, 1000, 2); }
   void ApplyPIDi() {
     *MenuData.P_Float = scalePID_i(MenuData.Value / POW(10, 2));
-    thermalManager.updatePID();
+    TERN_(PIDTEMP, thermalManager.updatePID());
   }
   void ApplyPIDd() {
     *MenuData.P_Float = scalePID_d(MenuData.Value / POW(10, 2));
-    thermalManager.updatePID();
+    TERN_(PIDTEMP, thermalManager.updatePID());
   }
   void SetKi() {
     MenuData.P_Float = (float*)static_cast<MenuItemPtrClass*>(CurrentMenu->SelectedItem())->value;
     const float value = unscalePID_i(*MenuData.P_Float);
     SetFloatOnClick(0, 1000, 2, value, ApplyPIDi);
   }
   void SetKd() {
     MenuData.P_Float = (float*)static_cast<MenuItemPtrClass*>(CurrentMenu->SelectedItem())->value;
     const float value = unscalePID_d(*MenuData.P_Float);
     SetFloatOnClick(0, 1000, 2, value, ApplyPIDd);
@@ -2691,22 +2703,24 @@ void onDrawGetColorItem(MenuItemClass* menuitem, int8_t line) {
     default: color = 0; break;
   }
   DWIN_Draw_Rectangle(0, HMI_data.Highlight_Color, ICOX + 1, MBASE(line) - 1 + 1, ICOX + 18, MBASE(line) - 1 + 18);
   DWIN_Draw_Rectangle(1, color, ICOX + 2, MBASE(line) - 1 + 2, ICOX + 17, MBASE(line) - 1 + 17);
   DWINUI::Draw_String(LBLX, MBASE(line) - 1, menuitem->caption);
   Draw_Menu_IntValue(HMI_data.Background_Color, line, 4, HMI_value.Color[i]);
   DWIN_Draw_HLine(HMI_data.SplitLine_Color, 16, MYPOS(line + 1), 240);
 }
 
 
-void onDrawPIDi(MenuItemClass* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, unscalePID_i(*(float*)static_cast<MenuItemPtrClass*>(menuitem)->value)); }
-void onDrawPIDd(MenuItemClass* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, unscalePID_d(*(float*)static_cast<MenuItemPtrClass*>(menuitem)->value)); }
+#if EITHER(PIDTEMP, PIDTEMPBED)
+  void onDrawPIDi(MenuItemClass* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, unscalePID_i(*(float*)static_cast<MenuItemPtrClass*>(menuitem)->value)); }
+  void onDrawPIDd(MenuItemClass* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, unscalePID_d(*(float*)static_cast<MenuItemPtrClass*>(menuitem)->value)); }
+#endif
 
 void onDrawSpeedItem(MenuItemClass* menuitem, int8_t line) {
   if (HMI_IsChinese()) menuitem->SetFrame(1, 116, 164, 171, 176);
   onDrawPIntMenu(menuitem, line);
 }
 
 #if HAS_HOTEND
   void onDrawHotendTemp(MenuItemClass* menuitem, int8_t line) {
     if (HMI_IsChinese()) menuitem->SetFrame(1, 1, 134, 56, 146);
     onDrawPIntMenu(menuitem, line);
@@ -2985,24 +2999,24 @@ void Draw_Prepare_Menu() {
     MENU_ITEM(ICON_Language, MSG_UI_LANGUAGE, onDrawLanguage, SetLanguage);
   }
   ui.reset_status(true);
   UpdateMenu(PrepareMenu);
 }
 
 void Draw_Tramming_Menu() {
   checkkey = Menu;
   if (SET_MENU(TrammingMenu, MSG_BED_TRAMMING, 8)) {
     BACK_ITEM(Draw_Prepare_Menu);
-    #if HAS_BED_PROBE
+    #if HAS_BED_PROBE && HAS_MESH
       MENU_ITEM(ICON_ProbeSet, MSG_TRAMMING_WIZARD, onDrawMenuItem, Trammingwizard);
       EDIT_ITEM(ICON_ProbeSet, MSG_BED_TRAMMING_MANUAL, onDrawChkbMenu, SetManualTramming, &HMI_data.FullManualTramming);
-    #else
+    #elif !HAS_BED_PROBE && HAS_ZOFFSET_ITEM
       MENU_ITEM_F(ICON_MoveZ0, "Home Z and disable", onDrawMenuItem, HomeZandDisable);
     #endif
     MENU_ITEM(ICON_Axis, MSG_LEVBED_FL, onDrawMenuItem, TramFL);
     MENU_ITEM(ICON_Axis, MSG_LEVBED_FR, onDrawMenuItem, TramFR);
     MENU_ITEM(ICON_Axis, MSG_LEVBED_BR, onDrawMenuItem, TramBR);
     MENU_ITEM(ICON_Axis, MSG_LEVBED_BL, onDrawMenuItem, TramBL);
     MENU_ITEM(ICON_Axis, MSG_LEVBED_C, onDrawMenuItem, TramC );
   }
   UpdateMenu(TrammingMenu);
 }
@@ -3540,21 +3554,21 @@ void Draw_Steps_Menu() {
 
   void ApplyMeshFadeHeight() { set_z_fade_height(planner.z_fade_height); }
   void SetMeshFadeHeight() { SetPFloatOnClick(0, 100, 1, ApplyMeshFadeHeight); }
 
   void SetMeshActive() {
     set_bed_leveling_enabled(!planner.leveling_active);
     Draw_Chkb_Line(CurrentMenu->line(), planner.leveling_active);
     DWIN_UpdateLCD();
   }
 
-  #if BOTH(HAS_HEATED_BED, PREHEAT_BEFORE_LEVELING)
+  #if ENABLED(PREHEAT_BEFORE_LEVELING)
     void SetBedLevT() { SetPIntOnClick(MIN_BEDTEMP, MAX_BEDTEMP); }
   #endif
 
   #if ENABLED(MESH_EDIT_MENU)
     #define Z_OFFSET_MIN -3
     #define Z_OFFSET_MAX  3
 
     void LiveEditMesh() { ((MenuItemPtrClass*)EditZValueItem)->value = &bedlevel.z_values[HMI_value.Select ? bedLevelTools.mesh_x : MenuData.Value][HMI_value.Select ? MenuData.Value : bedLevelTools.mesh_y]; EditZValueItem->redraw(); }
     void ApplyEditMeshX() { bedLevelTools.mesh_x = MenuData.Value; }
     void SetEditMeshX() { HMI_value.Select = 0; SetIntOnClick(0, GRID_MAX_POINTS_X - 1, bedLevelTools.mesh_x, ApplyEditMeshX, LiveEditMesh); }
@@ -3606,21 +3620,21 @@ void Draw_Steps_Menu() {
   }
 
 #endif // AUTO_BED_LEVELING_UBL
 
 #if HAS_MESH
 
   void Draw_MeshSet_Menu() {
     checkkey = Menu;
     if (SET_MENU(MeshMenu, MSG_MESH_LEVELING, 13)) {
       BACK_ITEM(Draw_AdvancedSettings_Menu);
-      #if BOTH(HAS_HEATED_BED, PREHEAT_BEFORE_LEVELING)
+      #if ENABLED(PREHEAT_BEFORE_LEVELING)
         EDIT_ITEM(ICON_Temperature, MSG_UBL_SET_TEMP_BED, onDrawPIntMenu, SetBedLevT, &HMI_data.BedLevT);
       #endif
       EDIT_ITEM(ICON_SetZOffset, MSG_Z_FADE_HEIGHT, onDrawPFloatMenu, SetMeshFadeHeight, &planner.z_fade_height);
       EDIT_ITEM(ICON_UBLActive, MSG_ACTIVATE_MESH, onDrawChkbMenu, SetMeshActive, &planner.leveling_active);
       #if HAS_BED_PROBE
         MENU_ITEM(ICON_Level, MSG_AUTO_MESH, onDrawMenuItem, AutoLev);
       #endif
       #if ENABLED(AUTO_BED_LEVELING_UBL)
         EDIT_ITEM(ICON_UBLSlot, MSG_UBL_STORAGE_SLOT, onDrawUBLSlot, SetUBLSlot, &bedlevel.storage_slot);
         MENU_ITEM(ICON_UBLSaveMesh, MSG_UBL_SAVE_MESH, onDrawMenuItem, UBLSaveMesh);

commit c66b3cf8a429c427c014f33171407c634da735f1
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Sun Jan 8 04:22:21 2023 -0500

    üö∏ ProUI updates (#25176)

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index fcceb2d52d..a5570026d0 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -16,22 +16,22 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 /**
  * DWIN Enhanced implementation for PRO UI
  * Author: Miguel A. Risco-Castillo (MRISCOC)
- * Version: 3.17.2
- * Date: 2022/04/08
+ * Version: 3.21.2
+ * Date: 2022/12/02
  */
 
 #include "../../../inc/MarlinConfig.h"
 
 #if ENABLED(DWIN_LCD_PROUI)
 
 #if DISABLED(LIMITED_MAX_FR_EDITING)
   #warning "LIMITED_MAX_FR_EDITING is recommended with ProUI."
 #endif
 #if DISABLED(LIMITED_MAX_ACCEL_EDITING)
@@ -55,36 +55,33 @@
 #if DISABLED(SOUND_MENU_ITEM)
   #warning "SOUND_MENU_ITEM is recommended with ProUI."
 #endif
 #if DISABLED(PRINTCOUNTER)
   #warning "PRINTCOUNTER is recommended with ProUI."
 #endif
 #if HAS_MESH && DISABLED(MESH_EDIT_MENU)
   #warning "MESH_EDIT_MENU is recommended with ProUI."
 #endif
 
-#include "dwin.h"
-#include "menus.h"
-#include "dwin_popup.h"
-
 #include "../../fontutils.h"
 #include "../../marlinui.h"
 
 #include "../../../sd/cardreader.h"
 
 #include "../../../MarlinCore.h"
 #include "../../../core/serial.h"
 #include "../../../core/macros.h"
 
 #include "../../../module/temperature.h"
 #include "../../../module/printcounter.h"
 #include "../../../module/motion.h"
+#include "../../../module/stepper.h"
 #include "../../../module/planner.h"
 
 #include "../../../gcode/gcode.h"
 #include "../../../gcode/queue.h"
 
 #if HAS_FILAMENT_SENSOR
   #include "../../../feature/runout.h"
 #endif
 
 #if ENABLED(EEPROM_SETTINGS)
@@ -119,106 +116,101 @@
     #if !HAS_BED_PROBE
       #define JUST_BABYSTEP 1
     #endif
   #endif
 #endif
 
 #if ENABLED(POWER_LOSS_RECOVERY)
   #include "../../../feature/powerloss.h"
 #endif
 
-#if HAS_ESDIAG
-  #include "endstop_diag.h"
+#if ENABLED(PRINTCOUNTER)
+  #include "printstats.h"
 #endif
 
-#if HAS_PIDPLOT
-  #include "plot.h"
+#if ENABLED(CASE_LIGHT_MENU)
+  #include "../../../feature/caselight.h"
 #endif
 
-#if HAS_GCODE_PREVIEW
-  #include "gcode_preview.h"
+#if ENABLED(LED_CONTROL_MENU)
+  #include "../../../feature/leds/leds.h"
 #endif
 
-#if HAS_MESH
-  #include "meshviewer.h"
+#include "dwin.h"
+#include "dwinui.h"
+#include "menus.h"
+#include "dwin_popup.h"
+
+#if HAS_GCODE_PREVIEW
+  #include "gcode_preview.h"
 #endif
 
-#if ENABLED(PRINTCOUNTER)
-  #include "printstats.h"
+#if HAS_ESDIAG
+  #include "endstop_diag.h"
 #endif
 
-#if ENABLED(CASE_LIGHT_MENU)
-  #include "../../../feature/caselight.h"
+#if HAS_PIDPLOT
+  #include "plot.h"
 #endif
 
-#if ENABLED(LED_CONTROL_MENU)
-  #include "../../../feature/leds/leds.h"
+#if HAS_MESH
+  #include "meshviewer.h"
 #endif
 
 #if HAS_LOCKSCREEN
   #include "lockscreen.h"
 #endif
 
+#define DEBUG_OUT ENABLED(DEBUG_DWIN)
+#include "../../../core/debug_out.h"
+
 #ifndef MACHINE_SIZE
   #define MACHINE_SIZE STRINGIFY(X_BED_SIZE) "x" STRINGIFY(Y_BED_SIZE) "x" STRINGIFY(Z_MAX_POS)
 #endif
 
 #define PAUSE_HEAT
 
-#define MENU_CHAR_LIMIT  24
-
 // Print speed limit
 #define MIN_PRINT_SPEED  10
 #define MAX_PRINT_SPEED 999
 
 // Print flow limit
 #define MIN_PRINT_FLOW   10
 #define MAX_PRINT_FLOW   299
 
 // Load and Unload limits
 #define MAX_LOAD_UNLOAD  500
 
 // Feedspeed limit (max feedspeed = MAX_FEEDRATE_EDIT_VALUES)
 #define MIN_MAXFEEDSPEED      1
 #define MIN_MAXACCELERATION   1
 #define MIN_MAXJERK           0.1
 #define MIN_STEP              1
 #define MAX_STEP              999.9
 
 // Editable temperature limits
 #define MIN_ETEMP  0
-#define MAX_ETEMP  (HEATER_0_MAXTEMP - (HOTEND_OVERSHOOT))
+#define MAX_ETEMP  (thermalManager.hotend_maxtemp[0] - (HOTEND_OVERSHOOT))
 #define MIN_BEDTEMP 0
 #define MAX_BEDTEMP BED_MAX_TARGET
 
-#define FEEDRATE_E      (60)
-
 #define DWIN_VAR_UPDATE_INTERVAL         1024
-#define DWIN_SCROLL_UPDATE_INTERVAL      SEC_TO_MS(2)
+#define DWIN_UPDATE_INTERVAL             1024
 #define DWIN_REMAIN_TIME_UPDATE_INTERVAL SEC_TO_MS(20)
 
-#if HAS_MESH
-  #define BABY_Z_VAR TERN(HAS_BED_PROBE, probe.offset.z, HMI_data.ManualZOffset)
-#else
-  float z_offset = 0;
-  #define BABY_Z_VAR z_offset
-#endif
+#define BABY_Z_VAR TERN(HAS_BED_PROBE, probe.offset.z, HMI_data.ManualZOffset)
 
 // Structs
 HMI_value_t HMI_value;
 HMI_flag_t HMI_flag{0};
 HMI_data_t HMI_data;
 
-millis_t dwin_heat_time = 0;
-
-uint8_t checkkey = 255, last_checkkey = MainMenu;
-
 enum SelectItem : uint8_t {
   PAGE_PRINT = 0,
   PAGE_PREPARE,
   PAGE_CONTROL,
   PAGE_ADVANCE,
   PAGE_COUNT,
 
   PRINT_SETUP = 0,
   PRINT_PAUSE_RESUME,
   PRINT_STOP,
@@ -226,25 +218,21 @@ enum SelectItem : uint8_t {
 };
 
 typedef struct {
   uint8_t now, last;
   void set(uint8_t v) { now = last = v; }
   void reset() { set(0); }
   bool changed() { bool c = (now != last); if (c) last = now; return c; }
   bool dec() { if (now) now--; return changed(); }
   bool inc(uint8_t v) { if (now < (v - 1)) now++; else now = (v - 1); return changed(); }
 } select_t;
-
-select_t select_page{0}, select_file{0}, select_print{0};
-uint8_t index_file     = MROWS;
-
-bool hash_changed = true; // Flag to know if message status was changed
+select_t select_page{0}, select_print{0};
 
 constexpr float max_feedrate_edit_values[] =
   #ifdef MAX_FEEDRATE_EDIT_VALUES
     MAX_FEEDRATE_EDIT_VALUES
   #else
     { 1000, 1000, 10, 50 }
   #endif
 ;
 
 constexpr float max_acceleration_edit_values[] =
@@ -258,31 +246,35 @@ constexpr float max_acceleration_edit_values[] =
 #if HAS_CLASSIC_JERK
   constexpr float max_jerk_edit_values[] =
     #ifdef MAX_JERK_EDIT_VALUES
       MAX_JERK_EDIT_VALUES
     #else
       { DEFAULT_XJERK * 2, DEFAULT_YJERK * 2, DEFAULT_ZJERK * 2, DEFAULT_EJERK * 2 }
     #endif
   ;
 #endif
 
-static uint8_t _percent_done = 0;
-static uint32_t _remain_time = 0;
-
-// Additional Aux Host Support
-static bool sdprint = false;
-
 #if HAS_HOTEND
   float last_E = 0;
+  #define E_MIN_POS (last_E - (EXTRUDE_MAXLENGTH))
+  #define E_MAX_POS (last_E + (EXTRUDE_MAXLENGTH))
 #endif
 
+bool hash_changed = true; // Flag to know if message status was changed
+uint8_t _percent_done = 0;
+uint32_t _remain_time = 0;
+bool blink = false;
+millis_t dwin_heat_time = 0;
+uint8_t checkkey = 255, last_checkkey = MainMenu;
+
 // New menu system pointers
+MenuClass *FileMenu = nullptr;
 MenuClass *PrepareMenu = nullptr;
 MenuClass *TrammingMenu = nullptr;
 MenuClass *MoveMenu = nullptr;
 MenuClass *ControlMenu = nullptr;
 MenuClass *AdvancedSettings = nullptr;
 #if HAS_HOME_OFFSET
   MenuClass *HomeOffMenu = nullptr;
 #endif
 #if HAS_BED_PROBE
   MenuClass *ProbeSetMenu = nullptr;
@@ -299,22 +291,26 @@ MenuClass *FilamentMenu = nullptr;
 #if HAS_HOTEND
   MenuClass *PreheatMenu = nullptr;
 #endif
 MenuClass *TemperatureMenu = nullptr;
 MenuClass *MaxSpeedMenu = nullptr;
 MenuClass *MaxAccelMenu = nullptr;
 #if HAS_CLASSIC_JERK
   MenuClass *MaxJerkMenu = nullptr;
 #endif
 MenuClass *StepsMenu = nullptr;
-MenuClass *HotendPIDMenu = nullptr;
-MenuClass *BedPIDMenu = nullptr;
+#if ENABLED(PIDTEMP)
+  MenuClass *HotendPIDMenu = nullptr;
+#endif
+#if ENABLED(PIDTEMPBED)
+  MenuClass *BedPIDMenu = nullptr;
+#endif
 #if ENABLED(CASELIGHT_USES_BRIGHTNESS)
   MenuClass *CaseLightMenu = nullptr;
 #endif
 #if ENABLED(LED_CONTROL_MENU)
   MenuClass *LedControlMenu = nullptr;
 #endif
 #if HAS_BED_PROBE
   MenuClass *ZOffsetWizMenu = nullptr;
 #endif
 #if ENABLED(INDIVIDUAL_AXIS_HOMING_SUBMENU)
@@ -330,20 +326,24 @@ MenuClass *BedPIDMenu = nullptr;
   #endif
 #endif
 
 // Updatable menuitems pointers
 MenuItemClass *HotendTargetItem = nullptr;
 MenuItemClass *BedTargetItem = nullptr;
 MenuItemClass *FanSpeedItem = nullptr;
 MenuItemClass *MMeshMoveZItem = nullptr;
 MenuItemClass *EditZValueItem = nullptr;
 
+bool Printing() { return printingIsActive() || printingIsPaused(); }
+bool SD_Printing() { return Printing() && IS_SD_FILE_OPEN(); }
+bool Host_Printing() { return Printing() && !IS_SD_FILE_OPEN(); }
+
 #define DWIN_LANGUAGE_EEPROM_ADDRESS 0x01   // Between 0x01 and 0x63 (EEPROM_OFFSET-1)
                                             // BL24CXX::check() uses 0x00
 
 inline bool HMI_IsChinese() { return HMI_flag.language == DWIN_CHINESE; }
 
 void HMI_SetLanguageCache() {
   DWIN_JPG_CacheTo1(HMI_IsChinese() ? Language_Chinese : Language_English);
 }
 
 void HMI_SetLanguage() {
@@ -361,21 +361,21 @@ void HMI_ToggleLanguage() {
   #endif
 }
 
 //-----------------------------------------------------------------------------
 // Main Buttons
 //-----------------------------------------------------------------------------
 
 typedef struct { uint16_t x, y[2], w, h; } text_info_t;
 
 void ICON_Button(const bool selected, const int iconid, const frame_rect_t &ico, const text_info_t (&txt), FSTR_P caption) {
-  DWIN_ICON_Show(true, false, false, ICON, iconid + selected, ico.x, ico.y);
+  DWINUI::Draw_IconWB(iconid + selected, ico.x, ico.y);
   if (selected) DWINUI::Draw_Box(0, HMI_data.Highlight_Color, ico);
   if (HMI_IsChinese()) {
     DWIN_Frame_AreaCopy(1, txt.x, txt.y[selected], txt.x + txt.w - 1, txt.y[selected] + txt.h - 1, ico.x + (ico.w - txt.w) / 2, (ico.y + ico.h - 25) - txt.h/2);
   }
   else {
     const uint16_t x = ico.x + (ico.w - strlen_P(FTOP(caption)) * DWINUI::fontWidth()) / 2,
                    y = (ico.y + ico.h - 20) - DWINUI::fontHeight() / 2;
     DWINUI::Draw_String(x, y, caption);
   }
 }
@@ -445,61 +445,23 @@ void ICON_Resume() {
 
 //
 // Printing: "Stop"
 //
 void ICON_Stop() {
   constexpr frame_rect_t ico = { 184, 232, 80, 100 };
   constexpr text_info_t txt = { 151, { 405, TERN(USE_STOCK_DWIN_SET, 446, 447) }, 27, 12 };
   ICON_Button(select_print.now == PRINT_STOP, ICON_Stop_0, ico, txt, GET_TEXT_F(MSG_BUTTON_STOP));
 }
 
-//-----------------------------------------------------------------------------
-// Drawing routines
-//-----------------------------------------------------------------------------
-
-void Move_Highlight(const int8_t from, const int8_t newline) {
-  Erase_Menu_Cursor(newline - from);
-  Draw_Menu_Cursor(newline);
-}
-
-void Add_Menu_Line() {
-  Move_Highlight(1, MROWS);
-  DWIN_Draw_HLine(HMI_data.SplitLine_Color, 16, MYPOS(MROWS + 1), 240);
-}
-
-void Scroll_Menu(const uint8_t dir) {
-  DWIN_Frame_AreaMove(1, dir, MLINE, HMI_data.Background_Color, 0, 31, DWIN_WIDTH, 349);
-  switch (dir) {
-    case DWIN_SCROLL_DOWN: Move_Highlight(-1, 0); break;
-    case DWIN_SCROLL_UP:   Add_Menu_Line(); break;
-  }
-}
-
-inline uint16_t nr_sd_menu_items() {
-  return card.get_num_Files() + !card.flag.workDirIsRoot;
-}
-
-void Erase_Menu_Text(const uint8_t line) {
-  DWIN_Draw_Rectangle(1, HMI_data.Background_Color, LBLX, MBASE(line) - 14, 271, MBASE(line) + 28);
-}
-
-// Draw "Back" line at the top
-void Draw_Back_First(const bool is_sel=true) {
-  Draw_Menu_Line(0, ICON_Back);
-  if (HMI_IsChinese())
-    DWIN_Frame_AreaCopy(1, 129, 72, 156, 84, LBLX, MBASE(0));
-  else
-    DWINUI::Draw_String(LBLX, MBASE(0), GET_TEXT_F(MSG_BACK));
-  if (is_sel) Draw_Menu_Cursor(0);
-}
-
+//
 //PopUps
+//
 void Popup_window_PauseOrStop() {
   if (HMI_IsChinese()) {
     DWINUI::ClearMainArea();
     Draw_Popup_Bkgd();
          if (select_print.now == PRINT_PAUSE_RESUME) DWIN_Frame_AreaCopy(1, 237, 338, 269, 356, 98, 150);
     else if (select_print.now == PRINT_STOP) DWIN_Frame_AreaCopy(1, 221, 320, 253, 336, 98, 150);
     DWIN_Frame_AreaCopy(1, 220, 304, 264, 319, 130, 150);
     DWINUI::Draw_IconWB(ICON_Confirm_C, 26, 280);
     DWINUI::Draw_IconWB(ICON_Cancel_C, 146, 280);
     Draw_Select_Highlight(true);
@@ -539,108 +501,116 @@ void Popup_window_PauseOrStop() {
         DWIN_Frame_AreaCopy(1, 103, 371, 237, 386, 52, 285);
         DWIN_Frame_AreaCopy(1, 151, 389, 185, 402, 187, 285);
         DWIN_Frame_AreaCopy(1, 189, 389, 271, 402, 95, 310);
       }
       else {
         DWINUI::Draw_Icon(ICON_TempTooLow, 102, 165);
         DWIN_Frame_AreaCopy(1, 103, 371, 270, 386, 52, 285);
         DWIN_Frame_AreaCopy(1, 189, 389, 271, 402, 95, 310);
       }
     }
-    else DWIN_Show_Popup(toohigh ? ICON_TempTooHigh : ICON_TempTooLow, F("Nozzle or Bed temperature"), toohigh ? F("is too high") : F("is too low"), BTN_Continue);
+    else
+      DWIN_Show_Popup(toohigh ? ICON_TempTooHigh : ICON_TempTooLow, F("Nozzle or Bed temperature"), toohigh ? F("is too high") : F("is too low"), BTN_Continue);
   }
 #endif
 
+//
 // Draw status line
-void DWIN_DrawStatusLine() {
+//
+void DWIN_DrawStatusLine(const char *text) {
   DWIN_Draw_Rectangle(1, HMI_data.StatusBg_Color, 0, STATUS_Y, DWIN_WIDTH, STATUS_Y + 20);
-  DWINUI::Draw_CenteredString(HMI_data.StatusTxt_Color, STATUS_Y + 2, ui.status_message);
+  if (text) DWINUI::Draw_CenteredString(HMI_data.StatusTxt_Color, STATUS_Y + 2, text);
 }
+void DWIN_DrawStatusLine(FSTR_P fstr) { DWIN_DrawStatusLine(FTOP(fstr)); }
 
 // Clear & reset status line
 void DWIN_ResetStatusLine() {
   ui.status_message[0] = 0;
   DWIN_CheckStatusMessage();
 }
 
 // Djb2 hash algorithm
-void DWIN_CheckStatusMessage() {
-  static uint32_t old_hash = 0;
-  char * str = &ui.status_message[0];
+uint32_t GetHash(char * str) {
   uint32_t hash = 5381;
   char c;
   while ((c = *str++)) hash = ((hash << 5) + hash) + c; /* hash * 33 + c */
+  return hash;
+}
+
+void DWIN_CheckStatusMessage() {
+  static uint32_t old_hash = 0;
+  uint32_t hash = GetHash(&ui.status_message[0]);
   hash_changed = hash != old_hash;
   old_hash = hash;
 };
 
 void DWIN_DrawStatusMessage() {
   #if ENABLED(STATUS_MESSAGE_SCROLLING)
 
     // Get the UTF8 character count of the string
     uint8_t slen = utf8_strlen(ui.status_message);
 
     // If the string fits the status line do not scroll it
     if (slen <= LCD_WIDTH) {
        if (hash_changed) {
-         DWIN_DrawStatusLine();
+         DWIN_DrawStatusLine(ui.status_message);
          hash_changed = false;
        }
     }
     else {
       // String is larger than the available line space
 
       // Get a pointer to the next valid UTF8 character
       // and the string remaining length
       uint8_t rlen;
       const char *stat = MarlinUI::status_and_len(rlen);
       DWIN_Draw_Rectangle(1, HMI_data.StatusBg_Color, 0, STATUS_Y, DWIN_WIDTH, STATUS_Y + 20);
       DWINUI::MoveTo(0, STATUS_Y + 2);
       DWINUI::Draw_String(HMI_data.StatusTxt_Color, stat, LCD_WIDTH);
 
       // If the string doesn't completely fill the line...
       if (rlen < LCD_WIDTH) {
         DWINUI::Draw_Char(HMI_data.StatusTxt_Color, '.');  // Always at 1+ spaces left, draw a dot
         uint8_t chars = LCD_WIDTH - rlen;                  // Amount of space left in characters
-        if (--chars) {                            // Draw a second dot if there's space
+        if (--chars) {                                     // Draw a second dot if there's space
           DWINUI::Draw_Char(HMI_data.StatusTxt_Color, '.');
           if (--chars)
             DWINUI::Draw_String(HMI_data.StatusTxt_Color, ui.status_message, chars); // Print a second copy of the message
         }
       }
       MarlinUI::advance_status_scroll();
     }
 
   #else
 
     if (hash_changed) {
       ui.status_message[LCD_WIDTH] = 0;
-      DWIN_DrawStatusLine();
+      DWIN_DrawStatusLine(ui.status_message);
       hash_changed = false;
     }
 
   #endif
 }
 
 void Draw_Print_Labels() {
   if (HMI_IsChinese()) {
     DWIN_Frame_AreaCopy(1,  0, 72,  63, 86,  41, 173);  // Printing Time
     DWIN_Frame_AreaCopy(1, 65, 72, 128, 86, 176, 173);  // Remain
   }
   else {
     DWINUI::Draw_String( 46, 173, GET_TEXT_F(MSG_INFO_PRINT_TIME));
     DWINUI::Draw_String(181, 173, GET_TEXT_F(MSG_REMAINING_TIME));
   }
 }
 
 void Draw_Print_ProgressBar() {
-  DWIN_ICON_Show(true, false, false, ICON, ICON_Bar, 15, 93);
+  DWINUI::Draw_IconWB(ICON_Bar, 15, 93);
   DWIN_Draw_Rectangle(1, HMI_data.Barfill_Color, 16 + _percent_done * 240 / 100, 93, 256, 113);
   DWINUI::Draw_Int(HMI_data.PercentTxt_Color, HMI_data.Background_Color, 3, 117, 133, _percent_done);
   DWINUI::Draw_String(HMI_data.PercentTxt_Color, 142, 133, F("%"));
 }
 
 void Draw_Print_ProgressElapsed() {
   char buf[10];
   duration_t elapsed = print_job_timer.duration(); // print timer
   sprintf_P(buf, PSTR("%02i:%02i "), (uint16_t)(elapsed.value / 3600), ((uint16_t)elapsed.value % 3600) / 60);
   DWINUI::Draw_String(HMI_data.Text_Color, HMI_data.Background_Color, 47, 192, buf);
@@ -650,40 +620,40 @@ void Draw_Print_ProgressRemain() {
   char buf[10];
   sprintf_P(buf, PSTR("%02i:%02i "), (uint16_t)(_remain_time / 3600), ((uint16_t)_remain_time % 3600) / 60);
   DWINUI::Draw_String(HMI_data.Text_Color, HMI_data.Background_Color, 181, 192, buf);
 }
 
 void ICON_ResumeOrPause() {
   if (checkkey == PrintProcess) printingIsPaused() ? ICON_Resume() : ICON_Pause();
 }
 
 // Update filename on print
-void DWIN_Print_Header(const char *text=nullptr) {
+void DWIN_Print_Header(const char *text = nullptr) {
   static char headertxt[31] = "";  // Print header text
   if (text) {
     const int8_t size = _MIN(30U, strlen_P(text));
     LOOP_L_N(i, size) headertxt[i] = text[i];
     headertxt[size] = '\0';
   }
   if (checkkey == PrintProcess || checkkey == PrintDone) {
     DWIN_Draw_Rectangle(1, HMI_data.Background_Color, 0, 60, DWIN_WIDTH, 60+16);
     DWINUI::Draw_CenteredString(60, headertxt);
   }
 }
 
 void Draw_PrintProcess() {
   if (HMI_IsChinese())
     Title.FrameCopy(30, 1, 42, 14);                     // "Printing"
   else
     Title.ShowCaption(GET_TEXT_F(MSG_PRINTING));
   DWINUI::ClearMainArea();
-  DWIN_Print_Header(sdprint ? card.longest_filename() : nullptr);
+  DWIN_Print_Header(SD_Printing() ? card.longest_filename() : nullptr);
   Draw_Print_Labels();
   DWINUI::Draw_Icon(ICON_PrintTime, 15, 173);
   DWINUI::Draw_Icon(ICON_RemainTime, 150, 171);
   Draw_Print_ProgressBar();
   Draw_Print_ProgressElapsed();
   Draw_Print_ProgressRemain();
   ICON_Tune();
   ICON_ResumeOrPause();
   ICON_Stop();
 }
@@ -700,25 +670,28 @@ void Goto_PrintProcess() {
 }
 
 void Draw_PrintDone() {
   // show percent bar and value
   _percent_done = 100;
   _remain_time = 0;
 
   Title.ShowCaption(GET_TEXT_F(MSG_PRINT_DONE));
   DWINUI::ClearMainArea();
   DWIN_Print_Header(nullptr);
-  if (sdprint && TERN0(HAS_GCODE_PREVIEW, Preview_Valid())) {
-    DWIN_ICON_Show(0, 0, 1, 21, 100, 0x00);
-    DWINUI::Draw_Button(BTN_Continue, 86, 300);
-  }
-  else {
+  #if HAS_GCODE_PREVIEW
+    if (Preview_Valid()) {
+      DWIN_ICON_Show(0, 0, 1, 21, 100, 0x00);
+      DWINUI::Draw_Button(BTN_Continue, 86, 300);
+    }
+    else
+  #endif
+  {
     Draw_Print_ProgressBar();
     Draw_Print_Labels();
     DWINUI::Draw_Icon(ICON_PrintTime, 15, 173);
     DWINUI::Draw_Icon(ICON_RemainTime, 150, 171);
     Draw_Print_ProgressElapsed();
     Draw_Print_ProgressRemain();
     DWINUI::Draw_Button(BTN_Continue, 86, 273);
   }
 }
 
@@ -731,67 +704,92 @@ void Goto_PrintDone() {
   }
 }
 
 void Draw_Main_Menu() {
   DWINUI::ClearMainArea();
   if (HMI_IsChinese())
     Title.FrameCopy(2, 2, 26, 13);   // "Home" etc
   else
     Title.ShowCaption(MACHINE_NAME);
   DWINUI::Draw_Icon(ICON_LOGO, 71, 52);  // CREALITY logo
-  DWIN_ResetStatusLine();
   ICON_Print();
   ICON_Prepare();
   ICON_Control();
   ICON_AdvSettings();
 }
 
 void Goto_Main_Menu() {
   if (checkkey == MainMenu) return;
   checkkey = MainMenu;
   Draw_Main_Menu();
   DWIN_UpdateLCD();
 }
 
 // Draw X, Y, Z and blink if in an un-homed or un-trusted state
-void _update_axis_value(const AxisEnum axis, const uint16_t x, const uint16_t y, const bool blink, const bool force) {
+void _update_axis_value(const AxisEnum axis, const uint16_t x, const uint16_t y, const bool force) {
   const bool draw_qmark = axis_should_home(axis),
              draw_empty = NONE(HOME_AFTER_DEACTIVATE, DISABLE_REDUCED_ACCURACY_WARNING) && !draw_qmark && !axis_is_trusted(axis);
 
   // Check for a position change
   static xyz_pos_t oldpos = { -1, -1, -1 };
-  const float p = current_position[axis];
+
+  #if ENABLED(SHOW_REAL_POS)
+    const float p = stepper.position(axis) / planner.settings.axis_steps_per_mm[axis];
+  #else
+    const float p = current_position[axis];
+  #endif
+
   const bool changed = oldpos[axis] != p;
   if (changed) oldpos[axis] = p;
 
   if (force || changed || draw_qmark || draw_empty) {
     if (blink && draw_qmark)
       DWINUI::Draw_String(HMI_data.Coordinate_Color, HMI_data.Background_Color, x, y, F("  - ? -"));
     else if (blink && draw_empty)
       DWINUI::Draw_String(HMI_data.Coordinate_Color, HMI_data.Background_Color, x, y, F("       "));
     else
       DWINUI::Draw_Signed_Float(HMI_data.Coordinate_Color, HMI_data.Background_Color, 3, 2, x, y, p);
   }
 }
 
+void _draw_ZOffsetIcon() {
+  #if HAS_LEVELING
+    #if NO_BLINK_LEV_IND
+      static bool _leveling_active = false;
+      if (_leveling_active != planner.leveling_active) {
+        _leveling_active = planner.leveling_active;
+        DWIN_Draw_Rectangle(1, HMI_data.Background_Color, 186, 415, 205, 436);
+        DWINUI::Draw_Icon(_leveling_active ? ICON_SetZOffset : ICON_Zoffset, 187, 416);
+      }
+    #else
+      if (planner.leveling_active) {
+        DWIN_Draw_Rectangle(1, blink ? HMI_data.SplitLine_Color : HMI_data.Background_Color, 186, 415, 205, 436);
+        DWINUI::Draw_Icon(ICON_SetZOffset, 186, 416);
+      }
+      static bool _leveling_active = false;
+      if (_leveling_active != planner.leveling_active) {
+        _leveling_active = planner.leveling_active;
+        if (!_leveling_active) {
+          DWIN_Draw_Rectangle(1, HMI_data.Background_Color, 186, 415, 205, 436);
+          DWINUI::Draw_Icon(ICON_Zoffset, 187, 416);
+        }
+      }
+    #endif
+  #else
+    DWINUI::Draw_Icon(ICON_Zoffset, 187, 416);
+  #endif
+}
+
 void _draw_xyz_position(const bool force) {
-  //SERIAL_ECHOPGM("Draw XYZ:");
-  static bool _blink = false;
-  const bool blink = !!(millis() & 0x400UL);
-  if (force || blink != _blink) {
-    _blink = blink;
-    //SERIAL_ECHOPGM(" (blink)");
-    _update_axis_value(X_AXIS,  27, 459, blink, true);
-    _update_axis_value(Y_AXIS, 112, 459, blink, true);
-    _update_axis_value(Z_AXIS, 197, 459, blink, true);
-  }
-  //SERIAL_EOL();
+  _update_axis_value(X_AXIS,  27, 459, force);
+  _update_axis_value(Y_AXIS, 112, 459, force);
+  _update_axis_value(Z_AXIS, 197, 459, force);
 }
 
 void update_variable() {
   #if HAS_HOTEND
     static celsius_t _hotendtemp = 0, _hotendtarget = 0;
     const celsius_t hc = thermalManager.wholeDegHotend(0),
                     ht = thermalManager.degTargetHotend(0);
     const bool _new_hotend_temp = _hotendtemp != hc,
                _new_hotend_target = _hotendtarget != ht;
     if (_new_hotend_temp) _hotendtemp = hc;
@@ -805,21 +803,21 @@ void update_variable() {
                _new_bed_target = _bedtarget != bt;
     if (_new_bed_temp) _bedtemp = bc;
     if (_new_bed_target) _bedtarget = bt;
   #endif
   #if HAS_FAN
     static uint8_t _fanspeed = 0;
     const bool _new_fanspeed = _fanspeed != thermalManager.fan_speed[0];
     if (_new_fanspeed) _fanspeed = thermalManager.fan_speed[0];
   #endif
 
-  if (checkkey == Menu && (CurrentMenu == TuneMenu || CurrentMenu == TemperatureMenu)) {
+  if (IsMenu(TuneMenu) || IsMenu(TemperatureMenu)) {
     // Tune page temperature update
     #if HAS_HOTEND
       if (_new_hotend_target) HotendTargetItem->redraw();
     #endif
     #if HAS_HEATED_BED
       if (_new_bed_target) BedTargetItem->redraw();
     #endif
     #if HAS_FAN
       if (_new_fanspeed) FanSpeedItem->redraw();
     #endif
@@ -859,48 +857,37 @@ void update_variable() {
       DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 195 + 2 * STAT_CHR_W, 384, _fanspeed);
     }
   #endif
 
   static float _offset = 0;
   if (BABY_Z_VAR != _offset) {
     _offset = BABY_Z_VAR;
     DWINUI::Draw_Signed_Float(DWIN_FONT_STAT, HMI_data.Indicator_Color,  HMI_data.Background_Color, 2, 2, 204, 417, _offset);
   }
 
-  #if HAS_MESH
-    static bool _leveling_active = false;
-    if (_leveling_active != planner.leveling_active) {
-      _leveling_active = planner.leveling_active;
-      DWIN_Draw_Box(1, HMI_data.Background_Color, 186, 416, 20, 20);
-      if (_leveling_active)
-        DWINUI::Draw_Icon(ICON_SetZOffset, 186, 416);
-      else
-        DWINUI::Draw_Icon(ICON_Zoffset, 187, 416);
-    }
-  #else
-    DWINUI::Draw_Icon(ICON_Zoffset, 187, 416);
-  #endif
-
+  _draw_ZOffsetIcon();
   _draw_xyz_position(false);
 }
 
 /**
- * Read and cache the working directory.
- *
- * TODO: New code can follow the pattern of menu_media.cpp
- * and rely on Marlin caching for performance. No need to
- * cache files here.
+ * Memory card and file management
  */
 
-#ifndef strcasecmp_P
-  #define strcasecmp_P(a, b) strcasecmp((a), (b))
-#endif
+bool DWIN_lcd_sd_status = false;
+
+void SetMediaAutoMount() {
+  Toogle_Chkb_Line(HMI_data.MediaAutoMount);
+}
+
+inline uint16_t nr_sd_menu_items() {
+  return _MIN(card.get_num_Files() + !card.flag.workDirIsRoot, MENU_MAX_ITEMS);
+}
 
 void make_name_without_ext(char *dst, char *src, size_t maxlen=MENU_CHAR_LIMIT) {
   size_t pos = strlen(src);  // index of ending nul
 
   // For files, remove the extension
   // which may be .gcode, .gco, or .g
   if (!card.flag.filenameIsDir)
     while (pos && src[pos] != '.') pos--; // find last '.' (stop at 0)
 
   if (!pos) pos = strlen(src);  // pos = 0 ('.' not found) restore pos
@@ -912,163 +899,154 @@ void make_name_without_ext(char *dst, char *src, size_t maxlen=MENU_CHAR_LIMIT)
     dst[--pos] = '.';
     dst[--pos] = '.';
   }
 
   dst[len] = '\0';    // end it
 
   // Copy down to 0
   while (pos--) dst[pos] = src[pos];
 }
 
-void HMI_SDCardInit() { card.cdroot(); }
-
-#if ENABLED(SCROLL_LONG_FILENAMES)
-
-  char shift_name[LONG_FILENAME_LENGTH + 1];
-  int8_t shift_amt; // = 0
-  millis_t shift_ms; // = 0
-
-  // Init the shift name based on the highlighted item
-  void Init_Shift_Name() {
-    const bool is_subdir = !card.flag.workDirIsRoot;
-    const int8_t filenum = select_file.now - 1 - is_subdir; // Skip "Back" and ".."
-    const uint16_t fileCnt = card.get_num_Files();
-    if (WITHIN(filenum, 0, fileCnt - 1)) {
-      card.getfilename_sorted(SD_ORDER(filenum, fileCnt));
-      char * const name = card.longest_filename();
-      make_name_without_ext(shift_name, name, 100);
-    }
-  }
-
-  void Init_SDItem_Shift() {
-    shift_amt = 0;
-    shift_ms = select_file.now > 0 && strlen(shift_name) > MENU_CHAR_LIMIT ? millis() + 750UL : 0;
-  }
+void Redraw_SD_List() {
+  InvalidateMenu();
+  Draw_Print_File_Menu();
+}
 
-#endif
+void SDCard_Up() {
+  card.cdup();
+  DWIN_lcd_sd_status = false; // On next DWIN_Update
+}
 
-/**
- * Display an SD item, adding a CDUP for subfolders.
- */
-void Draw_SDItem(const uint16_t item, int16_t row=-1) {
-  if (row < 0) row = item + 1 + MROWS - index_file;
-  const bool is_subdir = !card.flag.workDirIsRoot;
-  if (is_subdir && item == 0)
-    return Draw_Menu_Line(row, ICON_Folder, "..");
+void SDCard_Folder(char * const dirname) {
+  card.cd(dirname);
+  DWIN_lcd_sd_status = false; // On next DWIN_Update
+}
 
-  card.getfilename_sorted(SD_ORDER(item - is_subdir, card.get_num_Files()));
-  char * const name = card.longest_filename();
+void onClickSDItem() {
+  const uint16_t hasUpDir = !card.flag.workDirIsRoot;
+  if (hasUpDir && CurrentMenu->selected == 1) return SDCard_Up();
+  else {
+    const uint16_t filenum = CurrentMenu->selected - 1 - hasUpDir;
+    card.getfilename_sorted(SD_ORDER(filenum, card.get_num_Files()));
 
-  #if ENABLED(SCROLL_LONG_FILENAMES)
-    // Init the current selected name
-    // This is used during scroll drawing
-    if (item == select_file.now - 1) {
-      make_name_without_ext(shift_name, name, 100);
-      Init_SDItem_Shift();
-    }
-  #endif
+    // Enter that folder!
+    if (card.flag.filenameIsDir) return SDCard_Folder(card.filename);
 
-  // Draw the file/folder with name aligned left
-  char str[strlen(name) + 1];
-  make_name_without_ext(str, name);
-  const uint8_t icon = card.flag.filenameIsDir ? ICON_Folder : card.fileIsBinary() ? ICON_Binary : ICON_File;
-  Draw_Menu_Line(row, icon, str);
+    if (card.fileIsBinary())
+      return DWIN_Popup_Confirm(ICON_Error, F("Please check filenames"), F("Only G-code can be printed"));
+    else
+      return Goto_ConfirmToPrint();
+  }
 }
 
 #if ENABLED(SCROLL_LONG_FILENAMES)
+  char shift_name[LONG_FILENAME_LENGTH + 1] = "";
 
   void Draw_SDItem_Shifted(uint8_t &shift) {
-    // Limit to the number of chars past the cutoff
-    const size_t len = strlen(shift_name);
-    NOMORE(shift, _MAX(len - MENU_CHAR_LIMIT, 0U));
-
     // Shorten to the available space
-    const size_t lastchar = _MIN((signed)len, shift + MENU_CHAR_LIMIT);
-
+    const size_t lastchar = shift + MENU_CHAR_LIMIT;
     const char c = shift_name[lastchar];
     shift_name[lastchar] = '\0';
 
-    const uint8_t row = select_file.now + MROWS - index_file; // skip "Back" and scroll
+    const uint8_t row = FileMenu->line();
     Erase_Menu_Text(row);
     Draw_Menu_Line(row, 0, &shift_name[shift]);
 
     shift_name[lastchar] = c;
   }
 
+  void FileMenuIdle(bool reset=false) {
+    static bool hasUpDir = false;
+    static uint8_t last_itemselected = 0;
+    static int8_t shift_amt = 0;
+    static int8_t shift_len = 0;
+    if (reset) {
+      last_itemselected = 0;
+      hasUpDir = !card.flag.workDirIsRoot; // is a SubDir
+      return;
+    }
+    const uint8_t selected = FileMenu->selected;
+    if (last_itemselected != selected) {
+      if (last_itemselected >= 1 + hasUpDir) FileMenu->Items()[last_itemselected]->redraw(true);
+      last_itemselected = selected;
+      if (selected >= 1 + hasUpDir) {
+        const int8_t filenum = selected - 1 - hasUpDir; // Skip "Back" and ".."
+        card.getfilename_sorted(SD_ORDER(filenum, card.get_num_Files()));
+        make_name_without_ext(shift_name, card.longest_filename(), LONG_FILENAME_LENGTH);
+        shift_len = strlen(shift_name);
+        shift_amt = 0;
+      }
+    }
+    else if ((selected >= 1 + hasUpDir) && (shift_len > MENU_CHAR_LIMIT)) {
+      uint8_t shift_new = _MIN(shift_amt + 1, shift_len - MENU_CHAR_LIMIT); // Try to shift by...
+      Draw_SDItem_Shifted(shift_new);             // Draw the item
+      if (shift_new == shift_amt)                 // Scroll reached the end
+        shift_new = -1;                           // Reset
+      shift_amt = shift_new;                      // Set new scroll
+    }
+  }
+#else
+  char shift_name[FILENAME_LENGTH + 1] = "";
 #endif
 
-// Redraw the first set of SD Files
-void Redraw_SD_List() {
-  select_file.reset();
-  index_file = MROWS;
-
-  DWINUI::ClearMainArea(); // Leave title bar unchanged
-
-  Draw_Back_First();
+void onDrawFileName(MenuItemClass* menuitem, int8_t line) {
+  const bool is_subdir = !card.flag.workDirIsRoot;
+  if (is_subdir && menuitem->pos == 1) {
+    Draw_Menu_Line(line, ICON_Folder, "..");
+  }
+  else {
+    uint8_t icon;
+    card.getfilename_sorted(SD_ORDER(menuitem->pos - is_subdir - 1, card.get_num_Files()));
+    make_name_without_ext(shift_name, card.longest_filename());
+    icon = card.flag.filenameIsDir ? ICON_Folder : card.fileIsBinary() ? ICON_Binary : ICON_File;
+    Draw_Menu_Line(line, icon, shift_name);
+  }
+}
 
+void Draw_Print_File_Menu() {
+  checkkey = Menu;
   if (card.isMounted()) {
-    // As many files as will fit
-    LOOP_L_N(i, _MIN(nr_sd_menu_items(), MROWS))
-      Draw_SDItem(i, i + 1);
-
-    TERN_(SCROLL_LONG_FILENAMES, Init_SDItem_Shift());
+    if (SET_MENU(FileMenu, MSG_MEDIA_MENU, nr_sd_menu_items() + 1)) {
+      BACK_ITEM(Goto_Main_Menu);
+      LOOP_L_N(i, nr_sd_menu_items()) {
+        MenuItemAdd(onDrawFileName, onClickSDItem);
+      }
+    }
+    UpdateMenu(FileMenu);
+    TERN_(DASH_REDRAW, DWIN_RedrawDash());
   }
   else {
+    if (SET_MENU(FileMenu, MSG_MEDIA_MENU, 1)) BACK_ITEM(Goto_Main_Menu);
+    UpdateMenu(FileMenu);
     DWIN_Draw_Rectangle(1, HMI_data.AlertBg_Color, 10, MBASE(3) - 10, DWIN_WIDTH - 10, MBASE(4));
     DWINUI::Draw_CenteredString(font12x24, HMI_data.AlertTxt_Color, MBASE(3), GET_TEXT_F(MSG_MEDIA_NOT_INSERTED));
   }
-}
-
-bool DWIN_lcd_sd_status = false;
-
-void SDCard_Up() {
-  card.cdup();
-  Redraw_SD_List();
-  DWIN_lcd_sd_status = false; // On next DWIN_Update
-}
-
-void SDCard_Folder(char * const dirname) {
-  card.cd(dirname);
-  Redraw_SD_List();
-  DWIN_lcd_sd_status = false; // On next DWIN_Update
+  TERN_(SCROLL_LONG_FILENAMES, FileMenuIdle(true));
 }
 
 //
 // Watch for media mount / unmount
 //
 void HMI_SDCardUpdate() {
   if (HMI_flag.home_flag) return;
   if (DWIN_lcd_sd_status != card.isMounted()) {
     DWIN_lcd_sd_status = card.isMounted();
-    //SERIAL_ECHOLNPGM("HMI_SDCardUpdate: ", DWIN_lcd_sd_status);
-    if (DWIN_lcd_sd_status) {  // Media inserted
-      if (checkkey == SelectFile)
-        Redraw_SD_List();
-    }
-    else {    // Media removed
-      // clean file icon
-      if (checkkey == SelectFile) {
-        Redraw_SD_List();
-      }
-      else if (sdprint && card.isPrinting() && printingIsActive()) {
-        wait_for_heatup = wait_for_user = false;
-        HMI_flag.abort_flag = true; // Abort print
-      }
-    }
+    if (IsMenu(FileMenu)) Redraw_SD_List();
+    if (!DWIN_lcd_sd_status && SD_Printing()) ui.abort_print();  // Media removed while printing
     DWIN_UpdateLCD();
   }
 }
 
-//
-// The Dashboard is always on-screen, except during
-// full-screen modal dialogs.
-//
+/**
+ * Dash board and indicators
+ */
+
 void DWIN_Draw_Dashboard() {
 
   DWIN_Draw_Rectangle(1, HMI_data.Background_Color, 0, STATUS_Y + 21, DWIN_WIDTH, DWIN_HEIGHT - 1);
 
   #if HAS_HOTEND
     DWINUI::Draw_Icon(ICON_HotendTemp, 10, 383);
     DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 28, 384, thermalManager.wholeDegHotend(0));
     DWINUI::Draw_String(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 25 + 3 * STAT_CHR_W + 5, 384, F("/"));
     DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 25 + 4 * STAT_CHR_W + 6, 384, thermalManager.degTargetHotend(0));
 
@@ -1103,25 +1081,25 @@ void DWIN_Draw_Dashboard() {
 
   DWINUI::Draw_Icon(ICON_MaxSpeedX,  10, 456);
   DWINUI::Draw_Icon(ICON_MaxSpeedY,  95, 456);
   DWINUI::Draw_Icon(ICON_MaxSpeedZ, 180, 456);
   _draw_xyz_position(true);
 
 }
 
 void Draw_Info_Menu() {
   DWINUI::ClearMainArea();
-  Draw_Back_First();
   if (HMI_IsChinese())
     Title.FrameCopy(30, 17, 28, 13);                        // "Info"
   else
     Title.ShowCaption(GET_TEXT_F(MSG_INFO_SCREEN));
+  Draw_Menu_Line(0, ICON_Back, GET_TEXT_F(MSG_BACK), false, true);
 
   if (HMI_IsChinese()) {
     DWIN_Frame_AreaCopy(1, 197, 149, 252, 161, 108, 102);   // "Size"
     DWIN_Frame_AreaCopy(1,   1, 164,  56, 176, 108, 175);   // "Firmware Version"
     DWIN_Frame_AreaCopy(1,  58, 164, 113, 176, 105, 248);   // "Contact Details"
     DWINUI::Draw_CenteredString(268, F(CORP_WEBSITE));
   }
   else {
     DWINUI::Draw_CenteredString(102, F("Size"));
     DWINUI::Draw_CenteredString(175, F("Firmware version"));
@@ -1130,29 +1108,20 @@ void Draw_Info_Menu() {
   }
   DWINUI::Draw_CenteredString(122, F(MACHINE_SIZE));
   DWINUI::Draw_CenteredString(195, F(SHORT_BUILD_VERSION));
 
   LOOP_L_N(i, 3) {
     DWINUI::Draw_Icon(ICON_PrintSize + i, ICOX, 99 + i * 73);
     DWIN_Draw_HLine(HMI_data.SplitLine_Color, 16, MBASE(2) + i * 73, 240);
   }
 }
 
-void Draw_Print_File_Menu() {
-  if (HMI_IsChinese())
-    Title.FrameCopy(0, 31, 56, 14);    // "Print file"
-  else
-    Title.ShowCaption(GET_TEXT_F(MSG_MEDIA_MENU));
-  Redraw_SD_List();
-  TERN_(DASH_REDRAW, DWIN_RedrawDash());
-}
-
 // Main Process
 void HMI_MainMenu() {
   EncoderState encoder_diffState = get_encoder_state();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
 
   if (encoder_diffState == ENCODER_DIFF_CW) {
     if (select_page.inc(PAGE_COUNT)) {
       switch (select_page.now) {
         case PAGE_PRINT: ICON_Print(); break;
         case PAGE_PREPARE: ICON_Print(); ICON_Prepare(); break;
@@ -1167,152 +1136,39 @@ void HMI_MainMenu() {
         case PAGE_PRINT: ICON_Print(); ICON_Prepare(); break;
         case PAGE_PREPARE: ICON_Prepare(); ICON_Control(); break;
         case PAGE_CONTROL: ICON_Control(); ICON_AdvSettings(); break;
         case PAGE_ADVANCE: ICON_AdvSettings(); break;
       }
     }
   }
   else if (encoder_diffState == ENCODER_DIFF_ENTER) {
     switch (select_page.now) {
       case PAGE_PRINT:
-        checkkey = SelectFile;
-        card.mount();
-        safe_delay(300);
+        if (HMI_data.MediaAutoMount) {
+          card.mount();
+          safe_delay(800);
+        };
         Draw_Print_File_Menu();
         break;
       case PAGE_PREPARE: Draw_Prepare_Menu(); break;
       case PAGE_CONTROL: Draw_Control_Menu(); break;
       case PAGE_ADVANCE: Draw_AdvancedSettings_Menu(); break;
     }
   }
   DWIN_UpdateLCD();
 }
 
-// Select (and Print) File
-void HMI_SelectFile() {
-  EncoderState encoder_diffState = get_encoder_state();
-
-  const uint16_t hasUpDir = !card.flag.workDirIsRoot;
-
-  if (encoder_diffState == ENCODER_DIFF_NO) {
-    #if ENABLED(SCROLL_LONG_FILENAMES)
-      if (shift_ms && select_file.now >= 1 + hasUpDir) {
-        // Scroll selected filename every second
-        const millis_t ms = millis();
-        if (ELAPSED(ms, shift_ms)) {
-          const bool was_reset = shift_amt < 0;
-          shift_ms = ms + 375UL + was_reset * 250UL;  // ms per character
-          uint8_t shift_new = shift_amt + 1;          // Try to shift by...
-          Draw_SDItem_Shifted(shift_new);             // Draw the item
-          if (!was_reset && shift_new == 0)           // Was it limited to 0?
-            shift_ms = 0;                             // No scrolling needed
-          else if (shift_new == shift_amt)            // Scroll reached the end
-            shift_new = -1;                           // Reset
-          shift_amt = shift_new;                      // Set new scroll
-        }
-      }
-    #endif
-    return;
-  }
-
-  // First pause is long. Easy.
-  // On reset, long pause must be after 0.
-
-  const uint16_t fullCnt = nr_sd_menu_items();
-
-  if (encoder_diffState == ENCODER_DIFF_CW && fullCnt) {
-    if (select_file.inc(1 + fullCnt)) {
-      const uint8_t itemnum = select_file.now - 1;              // -1 for "Back"
-      if (TERN0(SCROLL_LONG_FILENAMES, shift_ms)) {             // If line was shifted
-        Erase_Menu_Text(itemnum + MROWS - index_file);          // Erase and
-        Draw_SDItem(itemnum - 1);                               // redraw
-      }
-      if (select_file.now > MROWS && select_file.now > index_file) { // Cursor past the bottom
-        index_file = select_file.now;                           // New bottom line
-        Scroll_Menu(DWIN_SCROLL_UP);
-        Draw_SDItem(itemnum, MROWS);                            // Draw and init the shift name
-      }
-      else {
-        Move_Highlight(1, select_file.now + MROWS - index_file); // Just move highlight
-        TERN_(SCROLL_LONG_FILENAMES, Init_Shift_Name());         // ...and init the shift name
-      }
-      TERN_(SCROLL_LONG_FILENAMES, Init_SDItem_Shift());
-    }
-  }
-  else if (encoder_diffState == ENCODER_DIFF_CCW && fullCnt) {
-    if (select_file.dec()) {
-      const uint8_t itemnum = select_file.now - 1;              // -1 for "Back"
-      if (TERN0(SCROLL_LONG_FILENAMES, shift_ms)) {             // If line was shifted
-        Erase_Menu_Text(select_file.now + 1 + MROWS - index_file); // Erase and
-        Draw_SDItem(itemnum + 1);                               // redraw
-      }
-      if (select_file.now < index_file - MROWS) {               // Cursor past the top
-        index_file--;                                           // New bottom line
-        Scroll_Menu(DWIN_SCROLL_DOWN);
-        if (index_file == MROWS) {
-          Draw_Back_First();
-          TERN_(SCROLL_LONG_FILENAMES, shift_ms = 0);
-        }
-        else {
-          Draw_SDItem(itemnum, 0);                              // Draw the item (and init shift name)
-        }
-      }
-      else {
-        Move_Highlight(-1, select_file.now + MROWS - index_file); // Just move highlight
-        TERN_(SCROLL_LONG_FILENAMES, Init_Shift_Name());        // ...and init the shift name
-      }
-      TERN_(SCROLL_LONG_FILENAMES, Init_SDItem_Shift());        // Reset left. Init timer.
-    }
-  }
-  else if (encoder_diffState == ENCODER_DIFF_ENTER) {
-    if (select_file.now == 0) { // Back
-      select_page.set(PAGE_PRINT);
-      return Goto_Main_Menu();
-    }
-    else if (hasUpDir && select_file.now == 1) { // CD-Up
-      SDCard_Up();
-      goto HMI_SelectFileExit;
-    }
-    else {
-      const uint16_t filenum = select_file.now - 1 - hasUpDir;
-      card.getfilename_sorted(SD_ORDER(filenum, card.get_num_Files()));
-
-      // Enter that folder!
-      if (card.flag.filenameIsDir) {
-        SDCard_Folder(card.filename);
-        goto HMI_SelectFileExit;
-      }
-
-      // Reset highlight for next entry
-      select_print.reset();
-      select_file.reset();
-
-      // Start choice and print SD file
-      HMI_flag.heat_flag = true;
-      HMI_flag.print_finish = false;
-
-      if (card.fileIsBinary())
-        return DWIN_Popup_Confirm(ICON_Error, F("Please check filenames"), F("Only G-code can be printed"));
-      else
-        return Goto_ConfirmToPrint();
-    }
-  }
-
-  HMI_SelectFileExit:
-  DWIN_UpdateLCD();
-}
-
 // Pause or Stop popup
 void onClick_PauseOrStop() {
   switch (select_print.now) {
-    case PRINT_PAUSE_RESUME: if (HMI_flag.select_flag) HMI_flag.pause_flag = true; break; // confirm pause
-    case PRINT_STOP: if (HMI_flag.select_flag) HMI_flag.abort_flag = true; break; // stop confirmed then abort print
+    case PRINT_PAUSE_RESUME: if (HMI_flag.select_flag) ui.pause_print(); break; // confirm pause
+    case PRINT_STOP: if (HMI_flag.select_flag) ui.abort_print(); break; // stop confirmed then abort print
     default: break;
   }
   return Goto_PrintProcess();
 }
 
 // Printing
 void HMI_Printing() {
   EncoderState encoder_diffState = get_encoder_state();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
   // Avoid flicker by updating only the previous menu
@@ -1350,21 +1206,20 @@ void HMI_Printing() {
     }
   }
   DWIN_UpdateLCD();
 }
 
 #include "../../../libs/buzzer.h"
 
 void Draw_Main_Area() {
   switch (checkkey) {
     case MainMenu:               Draw_Main_Menu(); break;
-    case SelectFile:             Draw_Print_File_Menu(); break;
     case PrintProcess:           Draw_PrintProcess(); break;
     case PrintDone:              Draw_PrintDone(); break;
     #if HAS_ESDIAG
       case ESDiagProcess:        Draw_EndStopDiag(); break;
     #endif
     case Popup:                  popupDraw(); break;
     #if HAS_LOCKSCREEN
       case Locked:               lockScreen.draw(); break;
     #endif
     case Menu:
@@ -1377,136 +1232,145 @@ void Draw_Main_Area() {
   }
 }
 
 void HMI_ReturnScreen() {
   checkkey = last_checkkey;
   wait_for_user = false;
   Draw_Main_Area();
 }
 
 void HMI_WaitForUser() {
-  get_encoder_state();
+  EncoderState encoder_diffState = get_encoder_state();
+  if (encoder_diffState != ENCODER_DIFF_NO && !ui.backlight) {
+    if (checkkey == WaitResponse) HMI_ReturnScreen();
+    return ui.refresh_brightness();
+  }
   if (!wait_for_user) {
     switch (checkkey) {
       case PrintDone:
         select_page.reset();
         Goto_Main_Menu();
         break;
-      TERN_(HAS_ONESTEP_LEVELING, case Leveling:)
-      default: HMI_ReturnScreen(); break;
+      #if HAS_BED_PROBE
+        case Leveling:
+      #endif
+      default:
+        HMI_ReturnScreen();
+        break;
     }
   }
 }
 
 void HMI_Init() {
-  DWINUI::Draw_Box(1, Color_Black, {5, 220, DWIN_WIDTH-5, DWINUI::fontHeight()});
+  DWINUI::Draw_Box(1, Color_Black, { 5, 220, DWIN_WIDTH - 5, DWINUI::fontHeight() });
   DWINUI::Draw_CenteredString(Color_White, 220, F("Professional Firmware "));
-  for (uint16_t t = 0; t <= 100; t += 2) {
+  for (uint16_t t = 15; t <= 257; t += 10) {
     DWINUI::Draw_Icon(ICON_Bar, 15, 260);
-    DWIN_Draw_Rectangle(1, HMI_data.Background_Color, 15 + t * 242 / 100, 260, 257, 280);
+    DWIN_Draw_Rectangle(1, HMI_data.Background_Color, t, 260, 257, 280);
     DWIN_UpdateLCD();
-    delay(20);
+    delay(50);
   }
   HMI_SetLanguage();
 }
 
 void EachMomentUpdate() {
   static millis_t next_var_update_ms = 0, next_rts_update_ms = 0, next_status_update_ms = 0;
   const millis_t ms = millis();
 
   if (ELAPSED(ms, next_var_update_ms)) {
     next_var_update_ms = ms + DWIN_VAR_UPDATE_INTERVAL;
+    blink = !blink;
     update_variable();
     #if HAS_ESDIAG
       if (checkkey == ESDiagProcess) ESDiag.Update();
     #endif
     #if HAS_PIDPLOT
-      if (checkkey == PidProcess) Plot.Update((HMI_value.pidresult == PID_EXTR_START) ? thermalManager.wholeDegHotend(0) : thermalManager.wholeDegBed());
+      if (checkkey == PidProcess) Plot.Update((HMI_value.pidresult == PIDTEMP_START) ? thermalManager.wholeDegHotend(0) : thermalManager.wholeDegBed());
     #endif
   }
 
   #if HAS_STATUS_MESSAGE_TIMEOUT
     bool did_expire = ui.status_reset_callback && (*ui.status_reset_callback)();
     did_expire |= ui.status_message_expire_ms && ELAPSED(ms, ui.status_message_expire_ms);
     if (did_expire) ui.reset_status();
   #endif
 
   if (ELAPSED(ms, next_status_update_ms)) {
     next_status_update_ms = ms + 500;
     DWIN_DrawStatusMessage();
+    #if ENABLED(SCROLL_LONG_FILENAMES)
+      if (IsMenu(FileMenu)) FileMenuIdle();
+    #endif
   }
 
-  if (PENDING(ms, next_rts_update_ms)) return;
-  next_rts_update_ms = ms + DWIN_SCROLL_UPDATE_INTERVAL;
-
-  if (checkkey == PrintProcess) { // print process
+  if (!PENDING(ms, next_rts_update_ms)) {
+    next_rts_update_ms = ms + DWIN_UPDATE_INTERVAL;
 
-    // Print pause
-    if (HMI_flag.pause_flag && !HMI_flag.home_flag) {
-      HMI_flag.pause_flag = false;
-      if (!HMI_flag.pause_action) {
-        HMI_flag.pause_action = true;
-        return ui.pause_print();
-      }
+    if ((Printing() != HMI_flag.printing_flag) && !HMI_flag.home_flag) {
+      HMI_flag.printing_flag = Printing();
+      DEBUG_ECHOLNPGM("printing_flag: ", HMI_flag.printing_flag);
+      if (HMI_flag.printing_flag)
+        DWIN_Print_Started();
+      else if (HMI_flag.abort_flag)
+        DWIN_Print_Aborted();
+      else
+        DWIN_Print_Finished();
     }
 
-    // if print done
-    if (HMI_flag.print_finish && !HMI_flag.home_flag) {
-      HMI_flag.print_finish = false;
-      return DWIN_Print_Finished();
+    if ((printingIsPaused() != HMI_flag.pause_flag) && !HMI_flag.home_flag) {
+      HMI_flag.pause_flag = printingIsPaused();
+      DEBUG_ECHOLNPGM("pause_flag: ", HMI_flag.pause_flag);
+      if (HMI_flag.pause_flag)
+        DWIN_Print_Pause();
+      else if (HMI_flag.abort_flag)
+        DWIN_Print_Aborted();
+      else
+        DWIN_Print_Resume();
     }
 
-    // if print was aborted
-    if (HMI_flag.abort_flag && !HMI_flag.home_flag) { // Print Stop
-      HMI_flag.abort_flag = false;
-      if (!HMI_flag.abort_action) {
-        HMI_flag.abort_action = true;
-        ui.abort_print();
-        return Goto_PrintDone();
-      }
-    }
+    if (checkkey == PrintProcess) { // print process
 
-    duration_t elapsed = print_job_timer.duration(); // print timer
+      duration_t elapsed = print_job_timer.duration(); // print timer
 
-    if (sdprint && card.isPrinting() && !HMI_flag.percent_flag) {
-      uint8_t percentDone = card.percentDone();
-      if (_percent_done != percentDone) { // print percent
-          _percent_done = percentDone;
-          Draw_Print_ProgressBar();
+      if (card.isPrinting() && !HMI_flag.percent_flag) {
+        uint8_t percentDone = card.percentDone();
+        if (_percent_done != percentDone) { // print percent
+            _percent_done = percentDone;
+            Draw_Print_ProgressBar();
         }
 
-      // Estimate remaining time every 20 seconds
-      static millis_t next_remain_time_update = 0;
-      if (_percent_done > 1 && ELAPSED(ms, next_remain_time_update) && !HMI_flag.heat_flag && !HMI_flag.remain_flag) {
-        _remain_time = (elapsed.value - dwin_heat_time) / (_percent_done * 0.01f) - (elapsed.value - dwin_heat_time);
-        next_remain_time_update += DWIN_REMAIN_TIME_UPDATE_INTERVAL;
-        Draw_Print_ProgressRemain();
+        // Estimate remaining time every 20 seconds
+        static millis_t next_remain_time_update = 0;
+        if (_percent_done > 1 && ELAPSED(ms, next_remain_time_update) && !HMI_flag.heat_flag && !HMI_flag.remain_flag) {
+          _remain_time = (elapsed.value - dwin_heat_time) / (_percent_done * 0.01f) - (elapsed.value - dwin_heat_time);
+          next_remain_time_update += DWIN_REMAIN_TIME_UPDATE_INTERVAL;
+          Draw_Print_ProgressRemain();
+        }
       }
-    }
-
-    // Print time so far
-    static uint16_t last_Printtime = 0;
-    const uint16_t min = (elapsed.value % 3600) / 60;
-    if (last_Printtime != min) { // 1 minute update
-      last_Printtime = min;
-      Draw_Print_ProgressElapsed();
-    }
 
-  }
+      // Print time so far
+      static uint16_t last_Printtime = 0;
+      const uint16_t min = (elapsed.value % 3600) / 60;
+      if (last_Printtime != min) { // 1 minute update
+        last_Printtime = min;
+        Draw_Print_ProgressElapsed();
+      }
 
-  #if ENABLED(POWER_LOSS_RECOVERY)
-    else if (DWIN_lcd_sd_status && recovery.dwin_flag) { // resume print before power off
-      return Goto_PowerLossRecovery();
     }
-  #endif // POWER_LOSS_RECOVERY
+    #if ENABLED(POWER_LOSS_RECOVERY)
+      else if (DWIN_lcd_sd_status && recovery.dwin_flag) { // resume print before power off
+        return Goto_PowerLossRecovery();
+      }
+    #endif // POWER_LOSS_RECOVERY
 
-  DWIN_UpdateLCD();
+    DWIN_UpdateLCD();
+  }
 }
 
 #if ENABLED(POWER_LOSS_RECOVERY)
   void Popup_PowerLossRecovery() {
     DWINUI::ClearMainArea();
     Draw_Popup_Bkgd();
     if (HMI_IsChinese()) {
       DWIN_Frame_AreaCopy(1, 160, 338, 235, 354, 98, 115);
       DWIN_Frame_AreaCopy(1, 103, 321, 271, 335, 52, 167);
       DWINUI::Draw_IconWB(ICON_Cancel_C,    26, 280);
@@ -1529,44 +1393,41 @@ void EachMomentUpdate() {
 
   void onClick_PowerLossRecovery() {
     if (HMI_flag.select_flag) {
       queue.inject(F("M1000C"));
       select_page.reset();
       return Goto_Main_Menu();
     }
     else {
       select_print.set(PRINT_SETUP);
       queue.inject(F("M1000"));
-      sdprint = true;
-      return Goto_PrintProcess();
     }
   }
 
   void Goto_PowerLossRecovery() {
     recovery.dwin_flag = false;
     LCD_MESSAGE(MSG_CONTINUE_PRINT_JOB);
     Goto_Popup(Popup_PowerLossRecovery, onClick_PowerLossRecovery);
   }
 
 #endif // POWER_LOSS_RECOVERY
 
 
 void DWIN_HandleScreen() {
   switch (checkkey) {
     case MainMenu:        HMI_MainMenu(); break;
     case Menu:            HMI_Menu(); break;
-    case SetInt:          HMI_SetInt(); break;
+    case SetInt:          HMI_SetDraw(); break;
+    case SetFloat:        HMI_SetDraw(); break;
     case SetPInt:         HMI_SetPInt(); break;
-    case SetIntNoDraw:    HMI_SetIntNoDraw(); break;
-    case SetFloat:        HMI_SetFloat(); break;
     case SetPFloat:       HMI_SetPFloat(); break;
-    case SelectFile:      HMI_SelectFile(); break;
+    case SetIntNoDraw:    HMI_SetNoDraw(); break;
     case PrintProcess:    HMI_Printing(); break;
     case Popup:           HMI_Popup(); break;
     case Leveling:        break;
     #if HAS_LOCKSCREEN
       case Locked:        HMI_LockScreen(); break;
     #endif
     case PrintDone:
     TERN_(HAS_ESDIAG, case ESDiagProcess:)
     case WaitResponse:    HMI_WaitForUser(); break;
     case Homing:
@@ -1600,29 +1461,29 @@ void HMI_SaveProcessID(const uint8_t id) {
 
 void DWIN_HomingStart() {
   HMI_flag.home_flag = true;
   HMI_SaveProcessID(Homing);
   Title.ShowCaption(GET_TEXT_F(MSG_HOMING));
   DWIN_Show_Popup(ICON_BLTouch, GET_TEXT_F(MSG_HOMING), GET_TEXT_F(MSG_PLEASE_WAIT));
 }
 
 void DWIN_HomingDone() {
   HMI_flag.home_flag = false;
-  #if ENABLED(MESH_BED_LEVELING) && EITHER(BABYSTEP_ZPROBE_OFFSET, JUST_BABYSTEP)
+  #if DISABLED(HAS_BED_PROBE) && EITHER(BABYSTEP_ZPROBE_OFFSET, JUST_BABYSTEP)
     planner.synchronize();
     babystep.add_mm(Z_AXIS, HMI_data.ManualZOffset);
   #endif
-  if (HMI_flag.abort_action) DWIN_Print_Aborted(); else HMI_ReturnScreen();
+  HMI_ReturnScreen();
 }
 
 void DWIN_LevelingStart() {
-  #if HAS_ONESTEP_LEVELING
+  #if HAS_BED_PROBE
     HMI_SaveProcessID(Leveling);
     Title.ShowCaption(GET_TEXT_F(MSG_BED_LEVELING));
     DWIN_Show_Popup(ICON_AutoLeveling, GET_TEXT_F(MSG_BED_LEVELING), GET_TEXT_F(MSG_PLEASE_WAIT));
     #if BOTH(AUTO_BED_LEVELING_UBL, PREHEAT_BEFORE_LEVELING)
       #if HAS_HOTEND
         if (thermalManager.degTargetHotend(0) < LEVELING_NOZZLE_TEMP)
           thermalManager.setTargetHotend(LEVELING_NOZZLE_TEMP, 0);
       #endif
       #if HAS_HEATED_BED
         if (thermalManager.degTargetBed() < HMI_data.BedLevT)
@@ -1634,66 +1495,66 @@ void DWIN_LevelingStart() {
   #elif ENABLED(MESH_BED_LEVELING)
     Draw_ManualMesh_Menu();
   #endif
 }
 
 void DWIN_LevelingDone() {
   TERN_(HAS_MESH, Goto_MeshViewer());
 }
 
 #if HAS_MESH
-  void DWIN_MeshUpdate(const int8_t xpos, const int8_t ypos, const_float_t zval) {
+  void DWIN_MeshUpdate(const int8_t cpos, const int8_t tpos, const_float_t zval) {
     char msg[33] = "";
     char str_1[6] = "";
-    sprintf_P(msg, PSTR(S_FMT " %i/%i Z=%s"), GET_TEXT(MSG_PROBING_POINT), xpos, ypos, dtostrf(zval, 1, 2, str_1));
+    sprintf_P(msg, PSTR(S_FMT " %i/%i Z=%s"), GET_TEXT(MSG_PROBING_POINT), cpos, tpos, dtostrf(zval, 1, 2, str_1));
     ui.set_status(msg);
   }
 #endif
 
 // PID process
 
 #if HAS_PIDPLOT
   void DWIN_Draw_PIDPopup() {
     frame_rect_t gfrm = {40, 180, DWIN_WIDTH - 80, 120};
     DWINUI::ClearMainArea();
     Draw_Popup_Bkgd();
     DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 100, GET_TEXT_F(MSG_PID_AUTOTUNE));
     DWINUI::Draw_String(HMI_data.PopupTxt_Color, gfrm.x, gfrm.y - DWINUI::fontHeight() - 4, F("PID target:    Celsius"));
     switch (HMI_value.pidresult) {
-      case PID_EXTR_START:
+      case PIDTEMP_START:
         DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 120, F("for Nozzle is running."));
         Plot.Draw(gfrm, thermalManager.hotend_maxtemp[0], HMI_data.HotendPidT);
         DWINUI::Draw_Int(HMI_data.PopupTxt_Color, 3, gfrm.x + 90, gfrm.y - DWINUI::fontHeight() - 4, HMI_data.HotendPidT);
         break;
-      case PID_BED_START:
+      case PIDTEMPBED_START:
         DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 120, F("for BED is running."));
         Plot.Draw(gfrm, BED_MAXTEMP, HMI_data.BedPidT);
         DWINUI::Draw_Int(HMI_data.PopupTxt_Color, 3, gfrm.x + 90, gfrm.y - DWINUI::fontHeight() - 4, HMI_data.BedPidT);
         break;
       default:
         break;
     }
   }
 #endif
 
 void DWIN_PidTuning(pidresult_t result) {
   HMI_value.pidresult = result;
   switch (result) {
-    case PID_BED_START:
+    case PIDTEMPBED_START:
       HMI_SaveProcessID(PidProcess);
       #if HAS_PIDPLOT
         DWIN_Draw_PIDPopup();
       #else
         DWIN_Draw_Popup(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE), F("for BED is running."));
       #endif
       break;
-    case PID_EXTR_START:
+    case PIDTEMP_START:
       HMI_SaveProcessID(PidProcess);
       #if HAS_PIDPLOT
         DWIN_Draw_PIDPopup();
       #else
         DWIN_Draw_Popup(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE), F("for Nozzle is running."));
       #endif
       break;
     case PID_BAD_EXTRUDER_NUM:
       checkkey = last_checkkey;
       DWIN_Popup_Confirm(ICON_TempTooLow, GET_TEXT_F(MSG_PID_AUTOTUNE_FAILED), GET_TEXT_F(MSG_BAD_EXTRUDER_NUM));
@@ -1710,68 +1571,61 @@ void DWIN_PidTuning(pidresult_t result) {
       checkkey = last_checkkey;
       DWIN_Popup_Confirm(ICON_TempTooLow, GET_TEXT_F(MSG_PID_AUTOTUNE), GET_TEXT_F(MSG_BUTTON_DONE));
       break;
     default:
       checkkey = last_checkkey;
       break;
   }
 }
 
 // Started a Print Job
-void DWIN_Print_Started(const bool sd) {
-  sdprint = IS_SD_PRINTING() || sd;
+void DWIN_Print_Started() {
+  DEBUG_ECHOLNPGM("DWIN_Print_Started: ", SD_Printing());
+  TERN_(HAS_GCODE_PREVIEW, if (Host_Printing()) Preview_Invalidate());
   _percent_done = 0;
   _remain_time = 0;
   HMI_flag.percent_flag = false;
   HMI_flag.remain_flag = false;
   HMI_flag.pause_flag = false;
-  HMI_flag.pause_action = false;
   HMI_flag.abort_flag = false;
-  HMI_flag.abort_action = false;
-  HMI_flag.print_finish = false;
+  select_print.reset();
   Goto_PrintProcess();
 }
 
 // Pause a print job
 void DWIN_Print_Pause() {
+  DEBUG_ECHOLNPGM("DWIN_Print_Pause");
   ICON_ResumeOrPause();
 }
 
 // Resume print job
 void DWIN_Print_Resume() {
-  HMI_flag.pause_action = false;
+  DEBUG_ECHOLNPGM("DWIN_Print_Resume");
   ICON_ResumeOrPause();
-  if (printJobOngoing()) {
-    LCD_MESSAGE(MSG_RESUME_PRINT);
-    Goto_PrintProcess();
-  }
+  LCD_MESSAGE(MSG_RESUME_PRINT);
 }
 
 // Ended print job
 void DWIN_Print_Finished() {
-  if (HMI_flag.abort_flag || checkkey == PrintDone) return;
+  DEBUG_ECHOLNPGM("DWIN_Print_Finished");
   TERN_(POWER_LOSS_RECOVERY, if (card.isPrinting()) recovery.cancel());
   HMI_flag.pause_flag = false;
   wait_for_heatup = false;
   planner.finish_and_disable();
   thermalManager.cooldown();
   Goto_PrintDone();
 }
 
 // Print was aborted
 void DWIN_Print_Aborted() {
-  TERN_(DEBUG_DWIN, SERIAL_ECHOLNPGM("DWIN_Print_Aborted"));
-  HMI_flag.abort_action = false;
-  wait_for_heatup = false;
-  planner.finish_and_disable();
-  thermalManager.cooldown();
-  Goto_PrintDone();
+  DEBUG_ECHOLNPGM("DWIN_Print_Aborted");
+  DWIN_Print_Finished();
 }
 
 // Progress and remaining time update
 void DWIN_M73() {
   if (parser.seenval('P')) {
     _percent_done = parser.value_byte();
     HMI_flag.percent_flag = true;
   }
   if (parser.seenval('R')) {
     _remain_time = parser.value_ulong() * 60;
@@ -1784,100 +1638,115 @@ void DWIN_M73() {
   }
 }
 
 #if HAS_FILAMENT_SENSOR
   // Filament Runout process
   void DWIN_FilamentRunout(const uint8_t extruder) { LCD_MESSAGE(MSG_RUNOUT_SENSOR); }
 #endif
 
 void DWIN_SetColorDefaults() {
   HMI_data.Background_Color = Def_Background_Color;
-  HMI_data.Cursor_color     = Def_Cursor_color;
-  HMI_data.TitleBg_color    = Def_TitleBg_color;
-  HMI_data.TitleTxt_color   = Def_TitleTxt_color;
+  HMI_data.Cursor_Color     = Def_Cursor_Color;
+  HMI_data.TitleBg_Color    = Def_TitleBg_Color;
+  HMI_data.TitleTxt_Color   = Def_TitleTxt_Color;
   HMI_data.Text_Color       = Def_Text_Color;
   HMI_data.Selected_Color   = Def_Selected_Color;
   HMI_data.SplitLine_Color  = Def_SplitLine_Color;
   HMI_data.Highlight_Color  = Def_Highlight_Color;
   HMI_data.StatusBg_Color   = Def_StatusBg_Color;
   HMI_data.StatusTxt_Color  = Def_StatusTxt_Color;
-  HMI_data.PopupBg_color    = Def_PopupBg_color;
+  HMI_data.PopupBg_Color    = Def_PopupBg_Color;
   HMI_data.PopupTxt_Color   = Def_PopupTxt_Color;
   HMI_data.AlertBg_Color    = Def_AlertBg_Color;
   HMI_data.AlertTxt_Color   = Def_AlertTxt_Color;
   HMI_data.PercentTxt_Color = Def_PercentTxt_Color;
   HMI_data.Barfill_Color    = Def_Barfill_Color;
   HMI_data.Indicator_Color  = Def_Indicator_Color;
   HMI_data.Coordinate_Color = Def_Coordinate_Color;
 }
 
 void DWIN_SetDataDefaults() {
+  DEBUG_ECHOLNPGM("DWIN_SetDataDefaults");
   DWIN_SetColorDefaults();
   DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color, HMI_data.StatusBg_Color);
-  TERN_(HAS_HOTEND,     HMI_data.HotendPidT = PREHEAT_1_TEMP_HOTEND);
-  TERN_(HAS_HEATED_BED, HMI_data.BedPidT    = PREHEAT_1_TEMP_BED);
-  TERN_(HAS_HOTEND,     HMI_data.PidCycles  = 5);
+  TERN_(PIDTEMP, HMI_data.HotendPidT = DEF_HOTENDPIDT);
+  TERN_(PIDTEMPBED, HMI_data.BedPidT = DEF_BEDPIDT);
+  TERN_(HAS_PID_HEATING, HMI_data.PidCycles = DEF_PIDCYCLES);
   #if ENABLED(PREVENT_COLD_EXTRUSION)
     HMI_data.ExtMinT = EXTRUDE_MINTEMP;
     ApplyExtMinT();
   #endif
   #if BOTH(HAS_HEATED_BED, PREHEAT_BEFORE_LEVELING)
     HMI_data.BedLevT = LEVELING_BED_TEMP;
   #endif
   TERN_(BAUD_RATE_GCODE, SetBaud250K());
+  HMI_data.FullManualTramming = false;
+  HMI_data.MediaAutoMount = ENABLED(HAS_SD_EXTENDER);
+  #if BOTH(INDIVIDUAL_AXIS_HOMING_SUBMENU, MESH_BED_LEVELING)
+    HMI_data.z_after_homing = DEF_Z_AFTER_HOMING;
+  #endif
+  #if DISABLED(HAS_BED_PROBE)
+    HMI_data.ManualZOffset = 0;
+  #endif
   #if BOTH(LED_CONTROL_MENU, HAS_COLOR_LEDS)
     TERN_(LED_COLOR_PRESETS, leds.set_default());
     ApplyLEDColor();
   #endif
 }
 
 void DWIN_CopySettingsTo(char * const buff) {
+  DEBUG_ECHOLNPGM("DWIN_CopySettingsTo");
+  DEBUG_ECHOLNPGM("HMI_data: ", sizeof(HMI_data_t));
   memcpy(buff, &HMI_data, eeprom_data_size);
 }
 
 void DWIN_CopySettingsFrom(const char * const buff) {
+  DEBUG_ECHOLNPGM("DWIN_CopySettingsFrom");
   memcpy(&HMI_data, buff, sizeof(HMI_data_t));
   if (HMI_data.Text_Color == HMI_data.Background_Color) DWIN_SetColorDefaults();
   DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color, HMI_data.StatusBg_Color);
   TERN_(PREVENT_COLD_EXTRUSION, ApplyExtMinT());
   feedrate_percentage = 100;
   TERN_(BAUD_RATE_GCODE, HMI_SetBaudRate());
   #if BOTH(LED_CONTROL_MENU, HAS_COLOR_LEDS)
     leds.set_color(
       HMI_data.Led_Color.r,
       HMI_data.Led_Color.g,
       HMI_data.Led_Color.b
       OPTARG(HAS_WHITE_LED, HMI_data.Led_Color.w)
     );
     leds.update();
   #endif
 
 }
 
 // Initialize or re-initialize the LCD
 void MarlinUI::init_lcd() {
-  TERN_(DEBUG_DWIN, SERIAL_ECHOLNPGM("DWIN_Startup"));
-  DWINUI::init();
+  DEBUG_ECHOLNPGM("MarlinUI::init_lcd");
+  delay(750);   // wait to wakeup screen
+  const bool hs = DWIN_Handshake(); UNUSED(hs);
+  DEBUG_ECHOPGM("DWIN_Handshake ");
+  DEBUG_ECHOLNF(hs ? F("ok.") : F("error."));
+  DWIN_Frame_SetDir(1);
   DWIN_JPG_CacheTo1(Language_English);
   Encoder_Configuration();
 }
 
 void DWIN_InitScreen() {
+  DEBUG_ECHOLNPGM("DWIN_InitScreen");
+  DWIN_SetColorDefaults();
   HMI_Init();   // draws boot screen
-  onCursorDraw = Draw_Menu_Cursor;
-  onCursorErase = Erase_Menu_Cursor;
+  DWINUI::init();
+  DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color, HMI_data.StatusBg_Color);
   DWINUI::onTitleDraw = Draw_Title;
-  onMenuDraw = Draw_Menu;
+  InitMenu();
   checkkey = 255;
-  CurrentMenu = nullptr;
-  PreviousMenu = nullptr;
-  index_file = MROWS;
   hash_changed = true;
   last_E = 0;
   DWIN_DrawStatusLine();
   DWIN_Draw_Dashboard();
   Goto_Main_Menu();
 }
 
 void MarlinUI::update() {
   EachMomentUpdate();   // Status update
   HMI_SDCardUpdate();   // SD card update
@@ -1918,57 +1787,57 @@ void DWIN_RedrawScreen() {
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   void DWIN_Popup_Pause(FSTR_P const fmsg, uint8_t button /*= 0*/) {
     HMI_SaveProcessID(button ? WaitResponse : NothingToDo);
     DWIN_Show_Popup(ICON_BLTouch, GET_TEXT_F(MSG_ADVANCED_PAUSE), fmsg, button);
   }
 
   void MarlinUI::pause_show_message(const PauseMessage message, const PauseMode mode/*=PAUSE_MODE_SAME*/, const uint8_t extruder/*=active_extruder*/) {
     //if (mode == PAUSE_MODE_SAME) return;
     pause_mode = mode;
     switch (message) {
-      case PAUSE_MESSAGE_PARKING:  DWIN_Popup_Pause(GET_TEXT_F(MSG_PAUSE_PRINT_PARKING));    break;                                     // M125
-      case PAUSE_MESSAGE_CHANGING: DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_INIT));   break;                                     // pause_print (M125, M600)
+      case PAUSE_MESSAGE_PARKING:  DWIN_Popup_Pause(GET_TEXT_F(MSG_PAUSE_PRINT_PARKING));    break;                // M125
+      case PAUSE_MESSAGE_CHANGING: DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_INIT));   break;                // pause_print (M125, M600)
       case PAUSE_MESSAGE_WAITING:  DWIN_Popup_Pause(GET_TEXT_F(MSG_ADVANCED_PAUSE_WAITING), BTN_Continue); break;
       case PAUSE_MESSAGE_INSERT:   DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_INSERT), BTN_Continue); break;
       case PAUSE_MESSAGE_LOAD:     DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_LOAD));   break;
-      case PAUSE_MESSAGE_UNLOAD:   DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_UNLOAD)); break;                                     // Unload of pause and Unload of M702
+      case PAUSE_MESSAGE_UNLOAD:   DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_UNLOAD)); break;                // Unload of pause and Unload of M702
       case PAUSE_MESSAGE_PURGE:
         #if ENABLED(ADVANCED_PAUSE_CONTINUOUS_PURGE)
           DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_CONT_PURGE));
         #else
           DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_PURGE));
         #endif
         break;
       case PAUSE_MESSAGE_OPTION:   Goto_FilamentPurge(); break;
       case PAUSE_MESSAGE_RESUME:   DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_RESUME)); break;
       case PAUSE_MESSAGE_HEAT:     DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_HEAT), BTN_Continue);   break;
       case PAUSE_MESSAGE_HEATING:  DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_HEATING)); break;
-      case PAUSE_MESSAGE_STATUS:   HMI_ReturnScreen(); break;                                                                         // Exit from Pause, Load and Unload
+      case PAUSE_MESSAGE_STATUS:   HMI_ReturnScreen(); break;                                                      // Exit from Pause, Load and Unload
       default: break;
     }
   }
 
   void Draw_Popup_FilamentPurge() {
     DWIN_Draw_Popup(ICON_BLTouch, GET_TEXT_F(MSG_ADVANCED_PAUSE), GET_TEXT_F(MSG_FILAMENT_CHANGE_PURGE_CONTINUE));
     DWINUI::Draw_Button(BTN_Purge, 26, 280);
     DWINUI::Draw_Button(BTN_Continue, 146, 280);
     Draw_Select_Highlight(true);
   }
 
   void onClick_FilamentPurge() {
-      if (HMI_flag.select_flag)
-        pause_menu_response = PAUSE_RESPONSE_EXTRUDE_MORE;  // "Purge More" button
-      else {
-        HMI_SaveProcessID(NothingToDo);
-        pause_menu_response = PAUSE_RESPONSE_RESUME_PRINT;  // "Continue" button
-      }
+    if (HMI_flag.select_flag)
+      pause_menu_response = PAUSE_RESPONSE_EXTRUDE_MORE;  // "Purge More" button
+    else {
+      HMI_SaveProcessID(NothingToDo);
+      pause_menu_response = PAUSE_RESPONSE_RESUME_PRINT;  // "Continue" button
     }
+  }
 
   void Goto_FilamentPurge() {
     pause_menu_response = PAUSE_RESPONSE_WAIT_FOR;
     Goto_Popup(Draw_Popup_FilamentPurge, onClick_FilamentPurge);
   }
 
 #endif // ADVANCED_PAUSE_FEATURE
 
 #if HAS_MESH
   void DWIN_MeshViewer() {
@@ -2004,59 +1873,58 @@ void DWIN_RedrawScreen() {
     if (encoder_diffState == ENCODER_DIFF_NO) return;
     lockScreen.onEncoder(encoder_diffState);
     if (lockScreen.isUnlocked()) DWIN_UnLockScreen();
   }
 
 #endif //  HAS_LOCKSCREEN
 
 #if HAS_GCODE_PREVIEW
 
   void onClick_ConfirmToPrint() {
+    Preview_Reset();
+    DWIN_ResetStatusLine();
     if (HMI_flag.select_flag) {     // Confirm
-      card.openAndPrintFile(card.filename);
-      return DWIN_Print_Started(true);
-    }
-    else {                          // Cancel
-      DWIN_ResetStatusLine();
-      checkkey = SelectFile;
-      return Draw_Print_File_Menu();
+      HMI_flag.heat_flag = true;
+      Goto_Main_Menu();
+      return card.openAndPrintFile(card.filename);
     }
+    else HMI_ReturnScreen();
   }
 
   void Goto_ConfirmToPrint() {
     Goto_Popup(Preview_DrawFromSD, onClick_ConfirmToPrint);
   }
 
 #else
   void Goto_ConfirmToPrint() {
+    // Print SD file
+    HMI_flag.heat_flag = true;
     card.openAndPrintFile(card.filename);
-    DWIN_Print_Started(true);
   }
 #endif
 
 #if HAS_ESDIAG
   void Draw_EndStopDiag() {
     HMI_SaveProcessID(ESDiagProcess);
     ESDiag.Draw();
   }
 #endif
 
 //=============================================================================
 // NEW MENU SUBSYSTEM
 //=============================================================================
 
 // Tool functions
 
 #if ENABLED(EEPROM_SETTINGS)
   void WriteEeprom() {
-    ui.set_status(GET_TEXT_F(MSG_STORE_EEPROM));
-    DWIN_DrawStatusLine();
+    DWIN_DrawStatusLine(GET_TEXT_F(MSG_STORE_EEPROM));
     DWIN_UpdateLCD();
     DONE_BUZZ(settings.save());
   }
 
   void ReadEeprom() {
     const bool success = settings.load();
     DWIN_RedrawScreen();
     DONE_BUZZ(success);
   }
 
@@ -2079,156 +1947,149 @@ void RebootPrinter() {
   DWIN_RebootScreen();
   hal.reboot();
 }
 
 void Goto_Info_Menu() {
   Draw_Info_Menu();
   DWIN_UpdateLCD();
   HMI_SaveProcessID(WaitResponse);
 }
 
-void Goto_Move_Menu() {
-  #if HAS_HOTEND
-    gcode.process_subcommands_now(F("G92E0"));  // reset extruder position
-  #endif
-  Draw_Move_Menu();
-}
-
 void DisableMotors() { queue.inject(F("M84")); }
 
 void AutoLev() {   // Always reacquire the Z "home" position
   queue.inject(F(TERN(AUTO_BED_LEVELING_UBL, "G28Z\nG29P1", "G28XYO\nG28Z\nG29")));
 }
 
 void AutoHome() { queue.inject_P(G28_STR); }
-void HomeX() { queue.inject(F("G28X")); }
-void HomeY() { queue.inject(F("G28Y")); }
-void HomeZ() { queue.inject(F("G28Z")); }
+
+#if ENABLED(INDIVIDUAL_AXIS_HOMING_SUBMENU)
+  void HomeX() { queue.inject(F("G28X")); }
+  void HomeY() { queue.inject(F("G28Y")); }
+  void HomeZ() { queue.inject(F("G28Z")); }
+  #if BOTH(INDIVIDUAL_AXIS_HOMING_SUBMENU, MESH_BED_LEVELING)
+    void ApplyZAfterHoming() { HMI_data.z_after_homing = MenuData.Value; };
+    void SetZAfterHoming() { SetIntOnClick(0, 20, HMI_data.z_after_homing, ApplyZAfterHoming); }
+  #endif
+#endif
 
 #if HAS_HOME_OFFSET
   // Apply workspace offset, making the current position 0,0,0
   void SetHome() {
-  queue.inject(F("G92X0Y0Z0"));
-  DONE_BUZZ(true);
+    queue.inject(F("G92X0Y0Z0"));
+    DONE_BUZZ(true);
   }
 #endif
 
 #if HAS_ZOFFSET_ITEM
 
   void ApplyZOffset() { TERN_(EEPROM_SETTINGS, settings.save()); }
   void LiveZOffset() {
     #if EITHER(BABYSTEP_ZPROBE_OFFSET, JUST_BABYSTEP)
       const_float_t step_zoffset = round((MenuData.Value / 100.0f) * planner.settings.axis_steps_per_mm[Z_AXIS]) - babystep.accum;
       if (BABYSTEP_ALLOWED()) babystep.add_steps(Z_AXIS, step_zoffset);
+      //DEBUG_ECHOLNF(F("BB Steps: "), step_zoffset);
     #endif
   }
-
-  #if EITHER(BABYSTEP_ZPROBE_OFFSET, JUST_BABYSTEP)
-    void SetZOffset() {
+  void SetZOffset() {
+    #if EITHER(BABYSTEP_ZPROBE_OFFSET, JUST_BABYSTEP)
       babystep.accum = round(planner.settings.axis_steps_per_mm[Z_AXIS] * BABY_Z_VAR);
-      SetPFloatOnClick(Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX, 2, ApplyZOffset, LiveZOffset);
-    }
-  #endif
+    #endif
+    SetPFloatOnClick(Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX, 2, ApplyZOffset, LiveZOffset);
+  }
 
   void SetMoveZto0() {
     #if ENABLED(Z_SAFE_HOMING)
       char cmd[54], str_1[5], str_2[5];
       sprintf_P(cmd, PSTR("G28XYO\nG28Z\nG0X%sY%sF5000\nG0Z0F300\nM400"),
         dtostrf(Z_SAFE_HOMING_X_POINT, 1, 1, str_1),
         dtostrf(Z_SAFE_HOMING_Y_POINT, 1, 1, str_2)
       );
       gcode.process_subcommands_now(cmd);
     #else
       TERN_(HAS_LEVELING, set_bed_leveling_enabled(false));
-      gcode.process_subcommands_now(F("G28O\nG0Z0F300\nM400"));
+      gcode.process_subcommands_now(F("G28Z\nG0Z0F300\nM400"));
     #endif
     ui.reset_status();
     DONE_BUZZ(true);
   }
 
   #if !HAS_BED_PROBE
     void HomeZandDisable() {
       SetMoveZto0();
       DisableMotors();
     }
   #endif
 
 #endif // HAS_ZOFFSET_ITEM
 
 #if HAS_PREHEAT
-  void DoPreheat0() { ui.preheat_all(0); }
-  #if PREHEAT_COUNT >= 2
-    void DoPreheat1() { ui.preheat_all(1); }
-    #if PREHEAT_COUNT >= 3
-      void DoPreheat2() { ui.preheat_all(2); }
-    #endif
-  #endif
+  #define _DoPreheat(N) void DoPreheat##N() { ui.preheat_all(N-1); }\
+                        void DoPreheatHotend##N() { ui.preheat_hotend(N-1); }
+  REPEAT_1(PREHEAT_COUNT, _DoPreheat)
 #endif
 
 void DoCoolDown() { thermalManager.cooldown(); }
 
 void SetLanguage() {
   HMI_ToggleLanguage();
   CurrentMenu = nullptr;  // Invalidate menu to full redraw
   Draw_Prepare_Menu();
 }
 
+bool EnableLiveMove = false;
+void SetLiveMove() { Toogle_Chkb_Line(EnableLiveMove); }
 void LiveMove() {
+  planner.synchronize();
+  if (!EnableLiveMove) return;
   *MenuData.P_Float = MenuData.Value / MINUNITMULT;
-  if (!planner.is_full()) {
-    planner.synchronize();
-    planner.buffer_line(current_position, homing_feedrate(HMI_value.axis));
-  }
+  if (!planner.is_full()) planner.buffer_line(current_position, manual_feedrate_mm_s[HMI_value.axis]);
 }
-void ApplyMoveE() {
-  last_E = MenuData.Value / MINUNITMULT;
-  if (!planner.is_full()) {
-    planner.synchronize();
-    planner.buffer_line(current_position, MMM_TO_MMS(FEEDRATE_E));
-  }
+void ApplyMove() {
+  planner.synchronize();
+  if (EnableLiveMove) return;
+  if (HMI_value.axis == E_AXIS) last_E = MenuData.Value / MINUNITMULT;
+  if (!planner.is_full()) planner.buffer_line(current_position, manual_feedrate_mm_s[HMI_value.axis]);
 }
-void SetMoveX() { HMI_value.axis = X_AXIS; SetPFloatOnClick(X_MIN_POS, X_MAX_POS, UNITFDIGITS, planner.synchronize, LiveMove); }
-void SetMoveY() { HMI_value.axis = Y_AXIS; SetPFloatOnClick(Y_MIN_POS, Y_MAX_POS, UNITFDIGITS, planner.synchronize, LiveMove); }
-void SetMoveZ() { HMI_value.axis = Z_AXIS; SetPFloatOnClick(Z_MIN_POS, Z_MAX_POS, UNITFDIGITS, planner.synchronize, LiveMove); }
+
+void SetMoveX() { HMI_value.axis = X_AXIS; SetPFloatOnClick(X_MIN_POS, X_MAX_POS, UNITFDIGITS, ApplyMove, LiveMove); }
+void SetMoveY() { HMI_value.axis = Y_AXIS; SetPFloatOnClick(Y_MIN_POS, Y_MAX_POS, UNITFDIGITS, ApplyMove, LiveMove); }
+void SetMoveZ() { HMI_value.axis = Z_AXIS; SetPFloatOnClick(Z_MIN_POS, Z_MAX_POS, UNITFDIGITS, ApplyMove, LiveMove); }
 
 #if HAS_HOTEND
   void SetMoveE() {
-    #if ENABLED(PREVENT_COLD_EXTRUSION)
-      if (thermalManager.tooColdToExtrude(0))
-        return DWIN_Popup_Confirm(ICON_TempTooLow, GET_TEXT_F(MSG_HOTEND_TOO_COLD), GET_TEXT_F(MSG_PLEASE_PREHEAT));
-    #endif
-    SetPFloatOnClick(last_E - (EXTRUDE_MAXLENGTH), last_E + (EXTRUDE_MAXLENGTH), UNITFDIGITS, ApplyMoveE);
+    if (thermalManager.tooColdToExtrude(0)) return DWIN_Popup_Confirm(ICON_TempTooLow, GET_TEXT_F(MSG_HOTEND_TOO_COLD), GET_TEXT_F(MSG_PLEASE_PREHEAT));
+    HMI_value.axis = E_AXIS; SetPFloatOnClick(E_MIN_POS, E_MAX_POS, UNITFDIGITS, ApplyMove, LiveMove);
   }
 #endif
 
 void SetPID(celsius_t t, heater_id_t h) {
   char cmd[53] = "";
   char str_1[5] = "", str_2[5] = "";
   sprintf_P(cmd, PSTR("G28OXY\nG0Z5F300\nG0X%sY%sF5000\nM84\nM400"),
     dtostrf(X_CENTER, 1, 1, str_1),
     dtostrf(Y_CENTER, 1, 1, str_2)
   );
   gcode.process_subcommands_now(cmd);
   thermalManager.PID_autotune(t, h, HMI_data.PidCycles, true);
 }
-#if HAS_HOTEND
+#if ENABLED(PIDTEMP)
   void HotendPID() { SetPID(HMI_data.HotendPidT, H_E0); }
 #endif
-#if HAS_HEATED_BED
+#if ENABLED(PIDTEMPBED)
   void BedPID() { SetPID(HMI_data.BedPidT, H_BED); }
 #endif
 
 #if ENABLED(POWER_LOSS_RECOVERY)
   void SetPwrLossr() {
-    recovery.enable(!recovery.enabled);
-    Draw_Chkb_Line(CurrentMenu->line(), recovery.enabled);
-    DWIN_UpdateLCD();
+    Toogle_Chkb_Line(recovery.enabled);
+    recovery.changed();
   }
 #endif
 
 #if ENABLED(BAUD_RATE_GCODE)
   void HMI_SetBaudRate() { HMI_data.Baud115K ? SetBaud115K() : SetBaud250K(); }
   void SetBaudRate() {
     HMI_data.Baud115K ^= true;
     HMI_SetBaudRate();
     Draw_Chkb_Line(CurrentMenu->line(), HMI_data.Baud115K);
     DWIN_UpdateLCD();
@@ -2239,37 +2100,34 @@ void SetPID(celsius_t t, heater_id_t h) {
 
 #if HAS_LCD_BRIGHTNESS
   void ApplyBrightness() { ui.set_brightness(MenuData.Value); }
   void LiveBrightness() { DWIN_LCD_Brightness(MenuData.Value); }
   void SetBrightness() { SetIntOnClick(LCD_BRIGHTNESS_MIN, LCD_BRIGHTNESS_MAX, ui.brightness, ApplyBrightness, LiveBrightness); }
   void TurnOffBacklight() { HMI_SaveProcessID(WaitResponse); ui.set_brightness(0); DWIN_RedrawScreen(); }
 #endif
 
 #if ENABLED(CASE_LIGHT_MENU)
   void SetCaseLight() {
-    caselight.on = !caselight.on;
+    Toogle_Chkb_Line(caselight.on);
     caselight.update_enabled();
-    Draw_Chkb_Line(CurrentMenu->line(), caselight.on);
-    DWIN_UpdateLCD();
   }
   #if ENABLED(CASELIGHT_USES_BRIGHTNESS)
     void LiveCaseLightBrightness() { caselight.brightness = MenuData.Value; caselight.update_brightness(); }
     void SetCaseLightBrightness() { SetIntOnClick(0, 255, caselight.brightness, nullptr, LiveCaseLightBrightness); }
   #endif
 #endif
 
 #if ENABLED(LED_CONTROL_MENU)
   #if !BOTH(CASE_LIGHT_MENU, CASE_LIGHT_USE_NEOPIXEL)
     void SetLedStatus() {
       leds.toggle();
-      Draw_Chkb_Line(CurrentMenu->line(), leds.lights_on);
-      DWIN_UpdateLCD();
+      Show_Chkb_Line(leds.lights_on);
     }
   #endif
   #if HAS_COLOR_LEDS
     void ApplyLEDColor() {
       HMI_data.Led_Color = LEDColor( {leds.color.r, leds.color.g, leds.color.b OPTARG(HAS_WHITE_LED, HMI_data.Led_Color.w) } );
     }
     void LiveLEDColor(uint8_t *color) { *color = MenuData.Value; leds.update(); }
     void LiveLEDColorR() { LiveLEDColor(&leds.color.r); }
     void LiveLEDColorG() { LiveLEDColor(&leds.color.g); }
     void LiveLEDColorB() { LiveLEDColor(&leds.color.b); }
@@ -2278,23 +2136,21 @@ void SetPID(celsius_t t, heater_id_t h) {
     void SetLEDColorB() { SetIntOnClick(0, 255, leds.color.b, ApplyLEDColor, LiveLEDColorB); }
     #if HAS_WHITE_LED
       void LiveLEDColorW() { LiveLEDColor(&leds.color.w); }
       void SetLEDColorW() { SetIntOnClick(0, 255, leds.color.w, ApplyLEDColor, LiveLEDColorW); }
     #endif
   #endif
 #endif
 
 #if ENABLED(SOUND_MENU_ITEM)
   void SetEnableSound() {
-    ui.sound_on = !ui.sound_on;
-    Draw_Chkb_Line(CurrentMenu->line(), ui.sound_on);
-    DWIN_UpdateLCD();
+    Toogle_Chkb_Line(ui.sound_on);
   }
 #endif
 
 #if HAS_HOME_OFFSET
   void ApplyHomeOffset() { set_home_offset(HMI_value.axis, MenuData.Value / MINUNITMULT); }
   void SetHomeOffsetX() { HMI_value.axis = X_AXIS; SetPFloatOnClick(-50, 50, UNITFDIGITS, ApplyHomeOffset); }
   void SetHomeOffsetY() { HMI_value.axis = Y_AXIS; SetPFloatOnClick(-50, 50, UNITFDIGITS, ApplyHomeOffset); }
   void SetHomeOffsetZ() { HMI_value.axis = Z_AXIS; SetPFloatOnClick( -2,  2, UNITFDIGITS, ApplyHomeOffset); }
 #endif
 
@@ -2302,74 +2158,70 @@ void SetPID(celsius_t t, heater_id_t h) {
   void SetProbeOffsetX() { SetPFloatOnClick(-60, 60, UNITFDIGITS); }
   void SetProbeOffsetY() { SetPFloatOnClick(-60, 60, UNITFDIGITS); }
   void SetProbeOffsetZ() { SetPFloatOnClick(-10, 10, 2); }
   void ProbeTest() {
     LCD_MESSAGE(MSG_M48_TEST);
     queue.inject(F("G28O\nM48 P10"));
   }
   void ProbeStow() { probe.stow(); }
   void ProbeDeploy() { probe.deploy(); }
 
-  #ifdef BLTOUCH_HS_MODE
+  #if ENABLED(BLTOUCH_HS_MODE)
     void SetHSMode() {
-      bltouch.high_speed_mode = !bltouch.high_speed_mode;
-      Draw_Chkb_Line(CurrentMenu->line(), bltouch.high_speed_mode);
-      DWIN_UpdateLCD();
+      Toogle_Chkb_Line(bltouch.high_speed_mode);
     }
   #endif
 
 #endif
 
 #if HAS_FILAMENT_SENSOR
   void SetRunoutEnable() {
     runout.reset();
-    runout.enabled = !runout.enabled;
-    Draw_Chkb_Line(CurrentMenu->line(), runout.enabled);
-    DWIN_UpdateLCD();
+    Toogle_Chkb_Line(runout.enabled);
   }
   #if HAS_FILAMENT_RUNOUT_DISTANCE
     void ApplyRunoutDistance() { runout.set_runout_distance(MenuData.Value / MINUNITMULT); }
     void SetRunoutDistance() { SetFloatOnClick(0, 999, UNITFDIGITS, runout.runout_distance(), ApplyRunoutDistance); }
   #endif
 #endif
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   void SetFilLoad()   { SetPFloatOnClick(0, MAX_LOAD_UNLOAD, UNITFDIGITS); }
   void SetFilUnload() { SetPFloatOnClick(0, MAX_LOAD_UNLOAD, UNITFDIGITS); }
 #endif
 
 #if ENABLED(PREVENT_COLD_EXTRUSION)
   void ApplyExtMinT() { thermalManager.extrude_min_temp = HMI_data.ExtMinT; thermalManager.allow_cold_extrude = (HMI_data.ExtMinT == 0); }
   void SetExtMinT() { SetPIntOnClick(MIN_ETEMP, MAX_ETEMP, ApplyExtMinT); }
 #endif
 
-void RestoreDefaultsColors() {
+void RestoreDefaultColors() {
   DWIN_SetColorDefaults();
   DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color, HMI_data.StatusBg_Color);
   DWIN_RedrawScreen();
 }
 
 void SelColor() {
   MenuData.P_Int = (int16_t*)static_cast<MenuItemPtrClass*>(CurrentMenu->SelectedItem())->value;
   HMI_value.Color[0] = GetRColor(*MenuData.P_Int);  // Red
   HMI_value.Color[1] = GetGColor(*MenuData.P_Int);  // Green
   HMI_value.Color[2] = GetBColor(*MenuData.P_Int);  // Blue
   Draw_GetColor_Menu();
 }
 
 void LiveRGBColor() {
     HMI_value.Color[CurrentMenu->line() - 2] = MenuData.Value;
     uint16_t color = RGB(HMI_value.Color[0], HMI_value.Color[1], HMI_value.Color[2]);
     DWIN_Draw_Rectangle(1, color, 20, 315, DWIN_WIDTH - 20, 335);
 }
 void SetRGBColor() {
-  const uint8_t color = CurrentMenu->SelectedItem()->icon;
+  const uint8_t color = static_cast<MenuItemClass*>(CurrentMenu->SelectedItem())->icon;
   SetIntOnClick(0, (color == 1) ? 63 : 31, HMI_value.Color[color], nullptr, LiveRGBColor);
 }
 
 void DWIN_ApplyColor() {
   *MenuData.P_Int = RGB(HMI_value.Color[0], HMI_value.Color[1], HMI_value.Color[2]);
   DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color, HMI_data.StatusBg_Color);
   Draw_SelectColors_Menu();
   hash_changed = true;
   LCD_MESSAGE(MSG_COLORS_APPLIED);
   DWIN_Draw_Dashboard();
@@ -2392,41 +2244,42 @@ void SetSpeed() { SetPIntOnClick(MIN_PRINT_SPEED, MAX_PRINT_SPEED); }
   void SetFanSpeed() { SetIntOnClick(0, 255, thermalManager.fan_speed[0], ApplyFanSpeed); }
 #endif
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
 
   void ChangeFilament() {
     HMI_SaveProcessID(NothingToDo);
     queue.inject(F("M600 B2"));
   }
 
-  void ParkHead() {
-    LCD_MESSAGE(MSG_FILAMENT_PARK_ENABLED);
-    queue.inject(F("G28O\nG27"));
-  }
+  #if ENABLED(NOZZLE_PARK_FEATURE)
+    void ParkHead() {
+      LCD_MESSAGE(MSG_FILAMENT_PARK_ENABLED);
+      queue.inject(F("G28O\nG27"));
+    }
+  #endif
 
   #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
     void UnloadFilament() {
       LCD_MESSAGE(MSG_FILAMENTUNLOAD);
       queue.inject(F("M702 Z20"));
     }
 
     void LoadFilament() {
       LCD_MESSAGE(MSG_FILAMENTLOAD);
       queue.inject(F("M701 Z20"));
     }
   #endif
 
 #endif // ADVANCED_PAUSE_FEATURE
 
-void ApplyFlow() { planner.refresh_e_factor(0); }
-void SetFlow() { SetPIntOnClick(MIN_PRINT_FLOW, MAX_PRINT_FLOW, ApplyFlow); }
+void SetFlow() { SetPIntOnClick(MIN_PRINT_FLOW, MAX_PRINT_FLOW, []{ planner.refresh_e_factor(0); }); }
 
 // Bed Tramming
 
 void TramXY(const uint8_t point, const float &margin, float &x, float &y) {
   switch (point) {
     case 0:
       LCD_MESSAGE(MSG_LEVBED_FL);
       x = y = margin;
       break;
     case 1:
@@ -2578,43 +2431,41 @@ void TramC () { Tram(4); }
       DWINUI::Draw_CenteredString(140, F("Knob adjustment required"));
       DWINUI::Draw_CenteredString(Color_Green, 160, s ? F("Lower") : F("Raise"));
       DWINUI::Draw_CenteredString(Color_Green, 180, plabel);
     }
     DWINUI::Draw_Button(BTN_Continue, 86, 305);
     checkkey = Menu;
     HMI_SaveProcessID(WaitResponse);
   }
 
   void SetManualTramming() {
-    HMI_data.FullManualTramming = !HMI_data.FullManualTramming;
-    Draw_Chkb_Line(CurrentMenu->line(), HMI_data.FullManualTramming);
-    DWIN_UpdateLCD();
+    Toogle_Chkb_Line(HMI_data.FullManualTramming);
   }
 
 #endif // HAS_BED_PROBE
 
 #if ENABLED(MESH_BED_LEVELING)
 
   void ManualMeshStart() {
     LCD_MESSAGE(MSG_UBL_BUILD_MESH_MENU);
     gcode.process_subcommands_now(F("G28XYO\nG28Z\nM211S0\nG29S1"));
     #ifdef MANUAL_PROBE_START_Z
       const uint8_t line = CurrentMenu->line(MMeshMoveZItem->pos);
       DWINUI::Draw_Signed_Float(HMI_data.Text_Color, HMI_data.Background_Color, 3, 2, VALX - 2 * DWINUI::fontWidth(DWIN_FONT_MENU), MBASE(line), MANUAL_PROBE_START_Z);
     #endif
   }
 
   void LiveMeshMoveZ() {
     *MenuData.P_Float = MenuData.Value / POW(10, 2);
     if (!planner.is_full()) {
       planner.synchronize();
-      planner.buffer_line(current_position, homing_feedrate(Z_AXIS));
+      planner.buffer_line(current_position, manual_feedrate_mm_s[Z_AXIS]);
     }
   }
   void SetMMeshMoveZ() { SetPFloatOnClick(-1, 1, 2, planner.synchronize, LiveMeshMoveZ); }
 
   void ManualMeshContinue() {
     gcode.process_subcommands_now(F("G29S2"));
     MMeshMoveZItem->redraw();
   }
 
   void ManualMeshSave() {
@@ -2900,30 +2751,20 @@ void onDrawSteps(MenuItemClass* menuitem, int8_t line) {
       if (HMI_IsChinese()) menuitem->SetFrame(1, 58, 134, 113, 146);
       onDrawPIntMenu(menuitem, line);
     }
   #endif
   #if HAS_FAN
     void onDrawSetPreheatFan(MenuItemClass* menuitem, int8_t line) {
       if (HMI_IsChinese()) menuitem->SetFrame(1, 115, 134, 170, 146);
       onDrawPIntMenu(menuitem, line);
     }
   #endif
-  void onDrawPLAPreheatSubMenu(MenuItemClass* menuitem, int8_t line) {
-    if (HMI_IsChinese()) menuitem->SetFrame(1, 100, 89, 178, 101);
-    onDrawSubMenu(menuitem,line);
-  }
-  #if PREHEAT_COUNT >= 2
-    void onDrawABSPreheatSubMenu(MenuItemClass* menuitem, int8_t line) {
-      if (HMI_IsChinese()) menuitem->SetFrame(1, 180, 89, 260, 100);
-      onDrawSubMenu(menuitem,line);
-    }
-  #endif
 #endif // HAS_PREHEAT
 
 void onDrawSpeed(MenuItemClass* menuitem, int8_t line) {
   if (HMI_IsChinese())
     menuitem->SetFrame(1, 173, 133, 228, 147);
   onDrawSubMenu(menuitem, line);
 }
 
 void onDrawMaxSpeedX(MenuItemClass* menuitem, int8_t line) {
   if (HMI_IsChinese()) {
@@ -3093,666 +2934,606 @@ void onDrawStepsZ(MenuItemClass* menuitem, int8_t line) {
     onDrawPFloatMenu(menuitem, line);
   }
 #endif
 
 #if HAS_ONESTEP_LEVELING
   void onDrawManualTramming(MenuItemClass* menuitem, int8_t line) { onDrawChkbMenu(menuitem, line, HMI_data.FullManualTramming); }
 #endif
 
 // Menu Creation and Drawing functions ======================================================
 
-void SetMenuTitle(frame_rect_t cn, const __FlashStringHelper* fstr) {
-  if (HMI_IsChinese() && (cn.w != 0))
-    CurrentMenu->MenuTitle.SetFrame(cn.x, cn.y, cn.w, cn.h);
+frame_rect_t selrect(frame_rect_t) {
+  if (HMI_IsChinese())
+    return {133, 1, 28, 13};
   else
-    CurrentMenu->MenuTitle.SetCaption(fstr);
+    return{0};
 }
 
 void Draw_Prepare_Menu() {
   checkkey = Menu;
-  if (!PrepareMenu) PrepareMenu = new MenuClass();
-  if (CurrentMenu != PrepareMenu) {
-    CurrentMenu = PrepareMenu;
-    SetMenuTitle({133, 1, 28, 13}, GET_TEXT_F(MSG_PREPARE));
-    MenuItemsPrepare(13);
+  if (SET_MENU_R(PrepareMenu, selrect({133, 1, 28, 13}), MSG_PREPARE, 10 + PREHEAT_COUNT)) {
     BACK_ITEM(Goto_Main_Menu);
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
-      MENU_ITEM_F(ICON_FilMan, MSG_FILAMENT_MAN, onDrawSubMenu, Draw_FilamentMan_Menu);
+      MENU_ITEM(ICON_FilMan, MSG_FILAMENT_MAN, onDrawSubMenu, Draw_FilamentMan_Menu);
     #endif
-    MENU_ITEM_F(ICON_Axis, MSG_MOVE_AXIS, onDrawMoveSubMenu, Goto_Move_Menu);
-    MENU_ITEM_F(ICON_Tram, MSG_BED_TRAMMING, onDrawSubMenu, Draw_Tramming_Menu);
-    MENU_ITEM_F(ICON_CloseMotor, MSG_DISABLE_STEPPERS, onDrawDisableMotors, DisableMotors);
+    MENU_ITEM(ICON_Axis, MSG_MOVE_AXIS, onDrawMoveSubMenu, Draw_Move_Menu);
+    MENU_ITEM(ICON_Tram, MSG_BED_TRAMMING, onDrawSubMenu, Draw_Tramming_Menu);
+    MENU_ITEM(ICON_CloseMotor, MSG_DISABLE_STEPPERS, onDrawDisableMotors, DisableMotors);
     #if ENABLED(INDIVIDUAL_AXIS_HOMING_SUBMENU)
-      MENU_ITEM_F(ICON_Homing, MSG_HOMING, onDrawSubMenu, Draw_Homing_Menu);
+      MENU_ITEM(ICON_Homing, MSG_HOMING, onDrawSubMenu, Draw_Homing_Menu);
     #else
-      MENU_ITEM_F(ICON_Homing, MSG_AUTO_HOME, onDrawAutoHome, AutoHome);
+      MENU_ITEM(ICON_Homing, MSG_AUTO_HOME, onDrawAutoHome, AutoHome);
     #endif
     #if ENABLED(MESH_BED_LEVELING)
-      MENU_ITEM_F(ICON_ManualMesh, MSG_MANUAL_MESH, onDrawSubMenu, Draw_ManualMesh_Menu);
-    #endif
-    #if HAS_ONESTEP_LEVELING
-      MENU_ITEM_F(ICON_Level, MSG_AUTO_MESH, onDrawMenuItem, AutoLev);
+      MENU_ITEM(ICON_ManualMesh, MSG_MANUAL_MESH, onDrawSubMenu, Draw_ManualMesh_Menu);
+    #elif HAS_BED_PROBE
+      MENU_ITEM(ICON_Level, MSG_AUTO_MESH, onDrawMenuItem, AutoLev);
     #endif
     #if HAS_ZOFFSET_ITEM
-      #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
-        MENU_ITEM_F(ICON_SetZOffset, MSG_PROBE_WIZARD, onDrawSubMenu, Draw_ZOffsetWiz_Menu);
-      #elif JUST_BABYSTEP
-        EDIT_ITEM_F(ICON_Zoffset, MSG_ZPROBE_ZOFFSET, onDrawPFloat2Menu, SetZOffset, &BABY_Z_VAR);
-      #else
-        MENU_ITEM_F(ICON_SetHome, MSG_SET_HOME_OFFSETS, onDrawHomeOffset, SetHome);
+      #if HAS_BED_PROBE
+        MENU_ITEM(ICON_SetZOffset, MSG_PROBE_WIZARD, onDrawSubMenu, Draw_ZOffsetWiz_Menu);
+      #elif ENABLED(BABYSTEPPING)
+        EDIT_ITEM(ICON_Zoffset, MSG_HOME_OFFSET_Z, onDrawPFloat2Menu, SetZOffset, &BABY_Z_VAR);
+      #elif HAS_HOME_OFFSET
+        MENU_ITEM(ICON_SetHome, MSG_SET_HOME_OFFSETS, onDrawHomeOffset, SetHome);
       #endif
     #endif
     #if HAS_PREHEAT
-      MENU_ITEM_F(ICON_PLAPreheat, MSG_PREHEAT_1, onDrawPreheat1, DoPreheat0);
-      #if PREHEAT_COUNT > 1
-        MENU_ITEM(ICON_ABSPreheat, F("Preheat " PREHEAT_2_LABEL), onDrawPreheat2, DoPreheat1);
-        #if PREHEAT_COUNT > 2
-          MENU_ITEM(ICON_CustomPreheat, F("Preheat " PREHEAT_3_LABEL), onDrawMenuItem, DoPreheat2);
-        #endif
-      #endif
+      #define _ITEM_PREHEAT(N) MENU_ITEM(ICON_Preheat##N, MSG_PREHEAT_##N, onDrawMenuItem, DoPreheat##N);
+      REPEAT_1(PREHEAT_COUNT, _ITEM_PREHEAT)
     #endif
-    MENU_ITEM_F(ICON_Cool, MSG_COOLDOWN, onDrawCooldown, DoCoolDown);
-    MENU_ITEM_F(ICON_Language, MSG_UI_LANGUAGE, onDrawLanguage, SetLanguage);
+    MENU_ITEM(ICON_Cool, MSG_COOLDOWN, onDrawCooldown, DoCoolDown);
+    MENU_ITEM(ICON_Language, MSG_UI_LANGUAGE, onDrawLanguage, SetLanguage);
   }
   ui.reset_status(true);
-  CurrentMenu->draw();
+  UpdateMenu(PrepareMenu);
 }
 
 void Draw_Tramming_Menu() {
   checkkey = Menu;
-  if (SetMenu(TrammingMenu, GET_TEXT_F(MSG_BED_TRAMMING), 8)) {
+  if (SET_MENU(TrammingMenu, MSG_BED_TRAMMING, 8)) {
     BACK_ITEM(Draw_Prepare_Menu);
     #if HAS_BED_PROBE
-      MENU_ITEM_F(ICON_ProbeSet, MSG_TRAMMING_WIZARD, onDrawMenuItem, Trammingwizard);
-      EDIT_ITEM_F(ICON_ProbeSet, MSG_BED_TRAMMING_MANUAL, onDrawChkbMenu, SetManualTramming, &HMI_data.FullManualTramming);
+      MENU_ITEM(ICON_ProbeSet, MSG_TRAMMING_WIZARD, onDrawMenuItem, Trammingwizard);
+      EDIT_ITEM(ICON_ProbeSet, MSG_BED_TRAMMING_MANUAL, onDrawChkbMenu, SetManualTramming, &HMI_data.FullManualTramming);
     #else
-      MENU_ITEM(ICON_MoveZ0, F("Home Z and disable"), onDrawMenuItem, HomeZandDisable);
+      MENU_ITEM_F(ICON_MoveZ0, "Home Z and disable", onDrawMenuItem, HomeZandDisable);
     #endif
-    MENU_ITEM_F(ICON_Axis, MSG_LEVBED_FL, onDrawMenuItem, TramFL);
-    MENU_ITEM_F(ICON_Axis, MSG_LEVBED_FR, onDrawMenuItem, TramFR);
-    MENU_ITEM_F(ICON_Axis, MSG_LEVBED_BR, onDrawMenuItem, TramBR);
-    MENU_ITEM_F(ICON_Axis, MSG_LEVBED_BL, onDrawMenuItem, TramBL);
-    MENU_ITEM(ICON_Axis, GET_TEXT_F(MSG_LEVBED_C ), onDrawMenuItem, TramC );
+    MENU_ITEM(ICON_Axis, MSG_LEVBED_FL, onDrawMenuItem, TramFL);
+    MENU_ITEM(ICON_Axis, MSG_LEVBED_FR, onDrawMenuItem, TramFR);
+    MENU_ITEM(ICON_Axis, MSG_LEVBED_BR, onDrawMenuItem, TramBR);
+    MENU_ITEM(ICON_Axis, MSG_LEVBED_BL, onDrawMenuItem, TramBL);
+    MENU_ITEM(ICON_Axis, MSG_LEVBED_C, onDrawMenuItem, TramC );
   }
   UpdateMenu(TrammingMenu);
 }
 
 void Draw_Control_Menu() {
   checkkey = Menu;
-  if (!ControlMenu) ControlMenu = new MenuClass();
-  if (CurrentMenu != ControlMenu) {
-    CurrentMenu = ControlMenu;
-    SetMenuTitle({103, 1, 28, 14}, GET_TEXT_F(MSG_CONTROL));
-    MenuItemsPrepare(10);
+  if (SET_MENU_R(ControlMenu, selrect({103, 1, 28, 14}), MSG_CONTROL, 10)) {
     BACK_ITEM(Goto_Main_Menu);
-    MENU_ITEM_F(ICON_Temperature, MSG_TEMPERATURE, onDrawTempSubMenu, Draw_Temperature_Menu);
-    MENU_ITEM_F(ICON_Motion, MSG_MOTION, onDrawMotionSubMenu, Draw_Motion_Menu);
+    MENU_ITEM(ICON_Temperature, MSG_TEMPERATURE, onDrawTempSubMenu, Draw_Temperature_Menu);
+    MENU_ITEM(ICON_Motion, MSG_MOTION, onDrawMotionSubMenu, Draw_Motion_Menu);
     #if ENABLED(EEPROM_SETTINGS)
-      MENU_ITEM_F(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawWriteEeprom, WriteEeprom);
-      MENU_ITEM_F(ICON_ReadEEPROM, MSG_LOAD_EEPROM, onDrawReadEeprom, ReadEeprom);
-      MENU_ITEM_F(ICON_ResumeEEPROM, MSG_RESTORE_DEFAULTS, onDrawResetEeprom, ResetEeprom);
+      MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawWriteEeprom, WriteEeprom);
+      MENU_ITEM(ICON_ReadEEPROM, MSG_LOAD_EEPROM, onDrawReadEeprom, ReadEeprom);
+      MENU_ITEM(ICON_ResumeEEPROM, MSG_RESTORE_DEFAULTS, onDrawResetEeprom, ResetEeprom);
     #endif
-    MENU_ITEM_F(ICON_Reboot, MSG_RESET_PRINTER, onDrawMenuItem, RebootPrinter);
+    MENU_ITEM(ICON_Reboot, MSG_RESET_PRINTER, onDrawMenuItem, RebootPrinter);
     #if ENABLED(CASE_LIGHT_MENU)
       #if ENABLED(CASELIGHT_USES_BRIGHTNESS)
-        MENU_ITEM_F(ICON_CaseLight, MSG_CASE_LIGHT, onDrawSubMenu, Draw_CaseLight_Menu);
+        MENU_ITEM(ICON_CaseLight, MSG_CASE_LIGHT, onDrawSubMenu, Draw_CaseLight_Menu);
       #else
-        MENU_ITEM_F(ICON_CaseLight, MSG_CASE_LIGHT, onDrawChkbMenu, SetCaseLight, &caselight.on);
+        MENU_ITEM(ICON_CaseLight, MSG_CASE_LIGHT, onDrawChkbMenu, SetCaseLight, &caselight.on);
       #endif
     #endif
     #if ENABLED(LED_CONTROL_MENU)
-      MENU_ITEM_F(ICON_LedControl, MSG_LED_CONTROL, onDrawSubMenu, Draw_LedControl_Menu);
+      MENU_ITEM(ICON_LedControl, MSG_LED_CONTROL, onDrawSubMenu, Draw_LedControl_Menu);
     #endif
-    MENU_ITEM_F(ICON_Info, MSG_INFO_SCREEN, onDrawInfoSubMenu, Goto_Info_Menu);
+    MENU_ITEM(ICON_Info, MSG_INFO_SCREEN, onDrawInfoSubMenu, Goto_Info_Menu);
   }
   ui.reset_status(true);
-  CurrentMenu->draw();
+  UpdateMenu(ControlMenu);
 }
 
 void Draw_AdvancedSettings_Menu() {
   checkkey = Menu;
-  if (SetMenu(AdvancedSettings, GET_TEXT_F(MSG_ADVANCED_SETTINGS), 20)) {
+  if (SET_MENU(AdvancedSettings, MSG_ADVANCED_SETTINGS, 18)) {
     BACK_ITEM(Goto_Main_Menu);
     #if ENABLED(EEPROM_SETTINGS)
-      MENU_ITEM_F(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawMenuItem, WriteEeprom);
-    #endif
-    #if HAS_BED_PROBE
-      MENU_ITEM_F(ICON_ProbeSet, MSG_ZPROBE_SETTINGS, onDrawSubMenu, Draw_ProbeSet_Menu);
+      MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawMenuItem, WriteEeprom);
     #endif
     #if HAS_MESH
-      MENU_ITEM_F(ICON_ProbeSet, MSG_MESH_LEVELING, onDrawSubMenu, Draw_MeshSet_Menu);
+      MENU_ITEM(ICON_ProbeSet, MSG_MESH_LEVELING, onDrawSubMenu, Draw_MeshSet_Menu);
     #endif
-    #if HAS_HOME_OFFSET
-      MENU_ITEM_F(ICON_HomeOffset, MSG_SET_HOME_OFFSETS, onDrawSubMenu, Draw_HomeOffset_Menu);
+    #if HAS_BED_PROBE
+      MENU_ITEM(ICON_ProbeSet, MSG_ZPROBE_SETTINGS, onDrawSubMenu, Draw_ProbeSet_Menu);
     #endif
+    MENU_ITEM(ICON_FilSet, MSG_FILAMENT_SET, onDrawSubMenu, Draw_FilSet_Menu);
     #if ENABLED(PIDTEMP)
-      MENU_ITEM(ICON_PIDNozzle, F(STR_HOTEND_PID " Settings"), onDrawSubMenu, Draw_HotendPID_Menu);
+      MENU_ITEM_F(ICON_PIDNozzle, STR_HOTEND_PID " Settings", onDrawSubMenu, Draw_HotendPID_Menu);
     #endif
     #if ENABLED(PIDTEMPBED)
-      MENU_ITEM(ICON_PIDbed, F(STR_BED_PID " Settings"), onDrawSubMenu, Draw_BedPID_Menu);
+      MENU_ITEM_F(ICON_PIDBed, STR_BED_PID " Settings", onDrawSubMenu, Draw_BedPID_Menu);
     #endif
-      MENU_ITEM_F(ICON_FilSet, MSG_FILAMENT_SET, onDrawSubMenu, Draw_FilSet_Menu);
-    #if ENABLED(POWER_LOSS_RECOVERY)
-      EDIT_ITEM_F(ICON_Pwrlossr, MSG_OUTAGE_RECOVERY, onDrawChkbMenu, SetPwrLossr, &recovery.enabled);
+    #if HAS_ESDIAG
+      MENU_ITEM_F(ICON_ESDiag, "End-stops diag.", onDrawSubMenu, Draw_EndStopDiag);
     #endif
-    #if ENABLED(BAUD_RATE_GCODE)
-      EDIT_ITEM(ICON_SetBaudRate, F("115K baud"), onDrawChkbMenu, SetBaudRate, &HMI_data.Baud115K);
+    #if ENABLED(PRINTCOUNTER)
+      MENU_ITEM(ICON_PrintStats, MSG_INFO_STATS_MENU, onDrawSubMenu, Goto_PrintStats);
+      MENU_ITEM(ICON_PrintStatsReset, MSG_INFO_PRINT_COUNT_RESET, onDrawSubMenu, PrintStatsReset);
     #endif
-    #if HAS_LCD_BRIGHTNESS
-      EDIT_ITEM_F(ICON_Brightness, MSG_BRIGHTNESS, onDrawPInt8Menu, SetBrightness, &ui.brightness);
-      MENU_ITEM_F(ICON_Brightness, MSG_BRIGHTNESS_OFF, onDrawMenuItem, TurnOffBacklight);
+    #if HAS_LOCKSCREEN
+      MENU_ITEM(ICON_Lock, MSG_LOCKSCREEN, onDrawMenuItem, DWIN_LockScreen);
     #endif
-    MENU_ITEM_F(ICON_Scolor, MSG_COLORS_SELECT, onDrawSubMenu, Draw_SelectColors_Menu);
     #if ENABLED(SOUND_MENU_ITEM)
-      EDIT_ITEM_F(ICON_Sound, MSG_SOUND_ENABLE, onDrawChkbMenu, SetEnableSound, &ui.sound_on);
+      EDIT_ITEM(ICON_Sound, MSG_SOUND_ENABLE, onDrawChkbMenu, SetEnableSound, &ui.sound_on);
     #endif
-    #if HAS_ESDIAG
-      MENU_ITEM(ICON_ESDiag, F("End-stops diag."), onDrawSubMenu, Draw_EndStopDiag);
+    #if ENABLED(POWER_LOSS_RECOVERY)
+      EDIT_ITEM(ICON_Pwrlossr, MSG_OUTAGE_RECOVERY, onDrawChkbMenu, SetPwrLossr, &recovery.enabled);
     #endif
-    #if ENABLED(PRINTCOUNTER)
-      MENU_ITEM_F(ICON_PrintStats, MSG_INFO_STATS_MENU, onDrawSubMenu, Goto_PrintStats);
-      MENU_ITEM_F(ICON_PrintStatsReset, MSG_INFO_PRINT_COUNT_RESET, onDrawSubMenu, PrintStats.Reset);
+    EDIT_ITEM(ICON_File, MSG_MEDIA_UPDATE, onDrawChkbMenu, SetMediaAutoMount, &HMI_data.MediaAutoMount);
+    #if ENABLED(BAUD_RATE_GCODE)
+      EDIT_ITEM_F(ICON_SetBaudRate, "115K baud", onDrawChkbMenu, SetBaudRate, &HMI_data.Baud115K);
     #endif
-    #if HAS_LOCKSCREEN
-      MENU_ITEM_F(ICON_Lock, MSG_LOCKSCREEN, onDrawMenuItem, DWIN_LockScreen);
+    #if HAS_LCD_BRIGHTNESS
+      EDIT_ITEM(ICON_Brightness, MSG_BRIGHTNESS, onDrawPInt8Menu, SetBrightness, &ui.brightness);
+      MENU_ITEM(ICON_Brightness, MSG_BRIGHTNESS_OFF, onDrawMenuItem, TurnOffBacklight);
     #endif
+    MENU_ITEM(ICON_Scolor, MSG_COLORS_SELECT, onDrawSubMenu, Draw_SelectColors_Menu);
   }
   ui.reset_status(true);
   UpdateMenu(AdvancedSettings);
 }
 
 void Draw_Move_Menu() {
   checkkey = Menu;
-  if (!MoveMenu) MoveMenu = new MenuClass();
-  if (CurrentMenu != MoveMenu) {
-    CurrentMenu = MoveMenu;
-    SetMenuTitle({192, 1, 42, 14}, GET_TEXT_F(MSG_MOVE_AXIS));
-    MenuItemsPrepare(5);
+  if (SET_MENU_R(MoveMenu, selrect({192, 1, 42, 14}), MSG_MOVE_AXIS, 6)) {
     BACK_ITEM(Draw_Prepare_Menu);
-    EDIT_ITEM_F(ICON_MoveX, MSG_MOVE_X, onDrawMoveX, SetMoveX, &current_position.x);
-    EDIT_ITEM_F(ICON_MoveY, MSG_MOVE_Y, onDrawMoveY, SetMoveY, &current_position.y);
-    EDIT_ITEM_F(ICON_MoveZ, MSG_MOVE_Z, onDrawMoveZ, SetMoveZ, &current_position.z);
+    EDIT_ITEM(ICON_Axis, MSG_LIVE_MOVE, onDrawChkbMenu, SetLiveMove, &EnableLiveMove);
+    EDIT_ITEM(ICON_MoveX, MSG_MOVE_X, onDrawMoveX, SetMoveX, &current_position.x);
+    EDIT_ITEM(ICON_MoveY, MSG_MOVE_Y, onDrawMoveY, SetMoveY, &current_position.y);
+    EDIT_ITEM(ICON_MoveZ, MSG_MOVE_Z, onDrawMoveZ, SetMoveZ, &current_position.z);
     #if HAS_HOTEND
-      EDIT_ITEM_F(ICON_Extruder, MSG_MOVE_E, onDrawMoveE, SetMoveE, &current_position.e);
+      gcode.process_subcommands_now(F("G92E0"));  // reset extruder position
+      EDIT_ITEM(ICON_Extruder, MSG_MOVE_E, onDrawMoveE, SetMoveE, &current_position.e);
     #endif
   }
-  CurrentMenu->draw();
+  UpdateMenu(MoveMenu);
   if (!all_axes_trusted()) LCD_MESSAGE_F("WARNING: Current position unknown. Home axes.");
 }
 
 #if HAS_HOME_OFFSET
   void Draw_HomeOffset_Menu() {
     checkkey = Menu;
-    if (SetMenu(HomeOffMenu, GET_TEXT_F(MSG_SET_HOME_OFFSETS), 4)) {
-      BACK_ITEM(Draw_AdvancedSettings_Menu);
-      EDIT_ITEM_F(ICON_HomeOffsetX, MSG_HOME_OFFSET_X, onDrawPFloatMenu, SetHomeOffsetX, &home_offset.x);
-      EDIT_ITEM_F(ICON_HomeOffsetY, MSG_HOME_OFFSET_Y, onDrawPFloatMenu, SetHomeOffsetY, &home_offset.y);
-      EDIT_ITEM_F(ICON_HomeOffsetZ, MSG_HOME_OFFSET_Z, onDrawPFloatMenu, SetHomeOffsetZ, &home_offset.z);
+    if (SET_MENU(HomeOffMenu, MSG_SET_HOME_OFFSETS, 4)) {
+      BACK_ITEM(Draw_PhySet_Menu);
+      EDIT_ITEM(ICON_HomeOffsetX, MSG_HOME_OFFSET_X, onDrawPFloatMenu, SetHomeOffsetX, &home_offset.x);
+      EDIT_ITEM(ICON_HomeOffsetY, MSG_HOME_OFFSET_Y, onDrawPFloatMenu, SetHomeOffsetY, &home_offset.y);
+      EDIT_ITEM(ICON_HomeOffsetZ, MSG_HOME_OFFSET_Z, onDrawPFloatMenu, SetHomeOffsetZ, &home_offset.z);
     }
     UpdateMenu(HomeOffMenu);
   }
 #endif
 
 #if HAS_BED_PROBE
   void Draw_ProbeSet_Menu() {
     checkkey = Menu;
-    if (SetMenu(ProbeSetMenu, GET_TEXT_F(MSG_ZPROBE_SETTINGS), 8)) {
+    if (SET_MENU(ProbeSetMenu, MSG_ZPROBE_SETTINGS, 9)) {
       BACK_ITEM(Draw_AdvancedSettings_Menu);
-      EDIT_ITEM_F(ICON_ProbeOffsetX, MSG_ZPROBE_XOFFSET, onDrawPFloatMenu, SetProbeOffsetX, &probe.offset.x);
-      EDIT_ITEM_F(ICON_ProbeOffsetY, MSG_ZPROBE_YOFFSET, onDrawPFloatMenu, SetProbeOffsetY, &probe.offset.y);
-      EDIT_ITEM_F(ICON_ProbeOffsetZ, MSG_ZPROBE_ZOFFSET, onDrawPFloat2Menu, SetProbeOffsetZ, &probe.offset.z);
+      EDIT_ITEM(ICON_ProbeOffsetX, MSG_ZPROBE_XOFFSET, onDrawPFloatMenu, SetProbeOffsetX, &probe.offset.x);
+      EDIT_ITEM(ICON_ProbeOffsetY, MSG_ZPROBE_YOFFSET, onDrawPFloatMenu, SetProbeOffsetY, &probe.offset.y);
+      EDIT_ITEM(ICON_ProbeOffsetZ, MSG_ZPROBE_ZOFFSET, onDrawPFloat2Menu, SetProbeOffsetZ, &probe.offset.z);
       #if ENABLED(BLTOUCH)
-        MENU_ITEM_F(ICON_ProbeStow, MSG_MANUAL_STOW, onDrawMenuItem, ProbeStow);
-        MENU_ITEM_F(ICON_ProbeDeploy, MSG_MANUAL_DEPLOY, onDrawMenuItem, ProbeDeploy);
-        MENU_ITEM_F(ICON_BltouchReset, MSG_BLTOUCH_RESET, onDrawMenuItem, bltouch._reset);
-        #ifdef BLTOUCH_HS_MODE
-          EDIT_ITEM_F(ICON_HSMode, MSG_ENABLE_HS_MODE, onDrawChkbMenu, SetHSMode, &bltouch.high_speed_mode);
+        MENU_ITEM(ICON_ProbeStow, MSG_MANUAL_STOW, onDrawMenuItem, ProbeStow);
+        MENU_ITEM(ICON_ProbeDeploy, MSG_MANUAL_DEPLOY, onDrawMenuItem, ProbeDeploy);
+        MENU_ITEM(ICON_BltouchReset, MSG_BLTOUCH_RESET, onDrawMenuItem, bltouch._reset);
+        #if ENABLED(BLTOUCH_HS_MODE)
+          EDIT_ITEM(ICON_HSMode, MSG_ENABLE_HS_MODE, onDrawChkbMenu, SetHSMode, &bltouch.high_speed_mode);
         #endif
       #endif
-      MENU_ITEM_F(ICON_ProbeTest, MSG_M48_TEST, onDrawMenuItem, ProbeTest);
+      MENU_ITEM(ICON_ProbeTest, MSG_M48_TEST, onDrawMenuItem, ProbeTest);
     }
     UpdateMenu(ProbeSetMenu);
   }
-
 #endif
 
 void Draw_FilSet_Menu() {
   checkkey = Menu;
-  if (SetMenu(FilSetMenu, GET_TEXT_F(MSG_FILAMENT_SET), 9)) {
+  if (SET_MENU(FilSetMenu, MSG_FILAMENT_SET, 9)) {
     BACK_ITEM(Draw_AdvancedSettings_Menu);
     #if HAS_FILAMENT_SENSOR
-      EDIT_ITEM_F(ICON_Runout, MSG_RUNOUT_ENABLE, onDrawChkbMenu, SetRunoutEnable, &runout.enabled);
+      EDIT_ITEM(ICON_Runout, MSG_RUNOUT_ENABLE, onDrawChkbMenu, SetRunoutEnable, &runout.enabled);
     #endif
     #if HAS_FILAMENT_RUNOUT_DISTANCE
-      EDIT_ITEM_F(ICON_Runout, MSG_RUNOUT_DISTANCE_MM, onDrawPFloatMenu, SetRunoutDistance, &runout.runout_distance());
+      EDIT_ITEM(ICON_Runout, MSG_RUNOUT_DISTANCE_MM, onDrawPFloatMenu, SetRunoutDistance, &runout.runout_distance());
     #endif
     #if ENABLED(PREVENT_COLD_EXTRUSION)
-      EDIT_ITEM_F(ICON_ExtrudeMinT, MSG_EXTRUDER_MIN_TEMP, onDrawPIntMenu, SetExtMinT, &HMI_data.ExtMinT);
+      EDIT_ITEM(ICON_ExtrudeMinT, MSG_EXTRUDER_MIN_TEMP, onDrawPIntMenu, SetExtMinT, &HMI_data.ExtMinT);
     #endif
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
-      EDIT_ITEM_F(ICON_FilLoad, MSG_FILAMENT_LOAD, onDrawPFloatMenu, SetFilLoad, &fc_settings[0].load_length);
-      EDIT_ITEM_F(ICON_FilUnload, MSG_FILAMENT_UNLOAD, onDrawPFloatMenu, SetFilUnload, &fc_settings[0].unload_length);
+      EDIT_ITEM(ICON_FilLoad, MSG_FILAMENT_LOAD, onDrawPFloatMenu, SetFilLoad, &fc_settings[0].load_length);
+      EDIT_ITEM(ICON_FilUnload, MSG_FILAMENT_UNLOAD, onDrawPFloatMenu, SetFilUnload, &fc_settings[0].unload_length);
     #endif
     #if ENABLED(FWRETRACT)
-      MENU_ITEM_F(ICON_FWRetract, MSG_FWRETRACT, onDrawSubMenu, Draw_FWRetract_Menu);
+      MENU_ITEM(ICON_FWRetract, MSG_FWRETRACT, onDrawSubMenu, Draw_FWRetract_Menu);
     #endif
   }
   UpdateMenu(FilSetMenu);
 }
 
 void Draw_SelectColors_Menu() {
   checkkey = Menu;
-  if (SetMenu(SelectColorMenu, GET_TEXT_F(MSG_COLORS_SELECT), 20)) {
+  if (SET_MENU(SelectColorMenu, MSG_COLORS_SELECT, 20)) {
     BACK_ITEM(Draw_AdvancedSettings_Menu);
-    MENU_ITEM_F(ICON_StockConfiguration, MSG_RESTORE_DEFAULTS, onDrawMenuItem, RestoreDefaultsColors);
-    EDIT_ITEM(0, F("Screen Background"), onDrawSelColorItem, SelColor, &HMI_data.Background_Color);
-    EDIT_ITEM(0, F("Cursor"), onDrawSelColorItem, SelColor, &HMI_data.Cursor_color);
-    EDIT_ITEM(0, F("Title Background"), onDrawSelColorItem, SelColor, &HMI_data.TitleBg_color);
-    EDIT_ITEM(0, F("Title Text"), onDrawSelColorItem, SelColor, &HMI_data.TitleTxt_color);
-    EDIT_ITEM(0, F("Text"), onDrawSelColorItem, SelColor, &HMI_data.Text_Color);
-    EDIT_ITEM(0, F("Selected"), onDrawSelColorItem, SelColor, &HMI_data.Selected_Color);
-    EDIT_ITEM(0, F("Split Line"), onDrawSelColorItem, SelColor, &HMI_data.SplitLine_Color);
-    EDIT_ITEM(0, F("Highlight"), onDrawSelColorItem, SelColor, &HMI_data.Highlight_Color);
-    EDIT_ITEM(0, F("Status Background"), onDrawSelColorItem, SelColor, &HMI_data.StatusBg_Color);
-    EDIT_ITEM(0, F("Status Text"), onDrawSelColorItem, SelColor, &HMI_data.StatusTxt_Color);
-    EDIT_ITEM(0, F("Popup Background"), onDrawSelColorItem, SelColor, &HMI_data.PopupBg_color);
-    EDIT_ITEM(0, F("Popup Text"), onDrawSelColorItem, SelColor, &HMI_data.PopupTxt_Color);
-    EDIT_ITEM(0, F("Alert Background"), onDrawSelColorItem, SelColor, &HMI_data.AlertBg_Color);
-    EDIT_ITEM(0, F("Alert Text"), onDrawSelColorItem, SelColor, &HMI_data.AlertTxt_Color);
-    EDIT_ITEM(0, F("Percent Text"), onDrawSelColorItem, SelColor, &HMI_data.PercentTxt_Color);
-    EDIT_ITEM(0, F("Bar Fill"), onDrawSelColorItem, SelColor, &HMI_data.Barfill_Color);
-    EDIT_ITEM(0, F("Indicator value"), onDrawSelColorItem, SelColor, &HMI_data.Indicator_Color);
-    EDIT_ITEM(0, F("Coordinate value"), onDrawSelColorItem, SelColor, &HMI_data.Coordinate_Color);
+    MENU_ITEM(ICON_StockConfiguration, MSG_RESTORE_DEFAULTS, onDrawMenuItem, RestoreDefaultColors);
+    EDIT_ITEM_F(0, "Screen Background", onDrawSelColorItem, SelColor, &HMI_data.Background_Color);
+    EDIT_ITEM_F(0, "Cursor", onDrawSelColorItem, SelColor, &HMI_data.Cursor_Color);
+    EDIT_ITEM_F(0, "Title Background", onDrawSelColorItem, SelColor, &HMI_data.TitleBg_Color);
+    EDIT_ITEM_F(0, "Title Text", onDrawSelColorItem, SelColor, &HMI_data.TitleTxt_Color);
+    EDIT_ITEM_F(0, "Text", onDrawSelColorItem, SelColor, &HMI_data.Text_Color);
+    EDIT_ITEM_F(0, "Selected", onDrawSelColorItem, SelColor, &HMI_data.Selected_Color);
+    EDIT_ITEM_F(0, "Split Line", onDrawSelColorItem, SelColor, &HMI_data.SplitLine_Color);
+    EDIT_ITEM_F(0, "Highlight", onDrawSelColorItem, SelColor, &HMI_data.Highlight_Color);
+    EDIT_ITEM_F(0, "Status Background", onDrawSelColorItem, SelColor, &HMI_data.StatusBg_Color);
+    EDIT_ITEM_F(0, "Status Text", onDrawSelColorItem, SelColor, &HMI_data.StatusTxt_Color);
+    EDIT_ITEM_F(0, "Popup Background", onDrawSelColorItem, SelColor, &HMI_data.PopupBg_Color);
+    EDIT_ITEM_F(0, "Popup Text", onDrawSelColorItem, SelColor, &HMI_data.PopupTxt_Color);
+    EDIT_ITEM_F(0, "Alert Background", onDrawSelColorItem, SelColor, &HMI_data.AlertBg_Color);
+    EDIT_ITEM_F(0, "Alert Text", onDrawSelColorItem, SelColor, &HMI_data.AlertTxt_Color);
+    EDIT_ITEM_F(0, "Percent Text", onDrawSelColorItem, SelColor, &HMI_data.PercentTxt_Color);
+    EDIT_ITEM_F(0, "Bar Fill", onDrawSelColorItem, SelColor, &HMI_data.Barfill_Color);
+    EDIT_ITEM_F(0, "Indicator value", onDrawSelColorItem, SelColor, &HMI_data.Indicator_Color);
+    EDIT_ITEM_F(0, "Coordinate value", onDrawSelColorItem, SelColor, &HMI_data.Coordinate_Color);
   }
   UpdateMenu(SelectColorMenu);
 }
 
 void Draw_GetColor_Menu() {
   checkkey = Menu;
-  if (SetMenu(GetColorMenu, GET_TEXT_F(MSG_COLORS_GET), 5)) {
+  if (SET_MENU(GetColorMenu, MSG_COLORS_GET, 5)) {
     BACK_ITEM(DWIN_ApplyColor);
-    MENU_ITEM_F(ICON_Cancel, MSG_BUTTON_CANCEL, onDrawMenuItem, Draw_SelectColors_Menu);
-    MENU_ITEM_F(0, MSG_COLORS_RED, onDrawGetColorItem, SetRGBColor);
-    MENU_ITEM_F(1, MSG_COLORS_GREEN, onDrawGetColorItem, SetRGBColor);
-    MENU_ITEM_F(2, MSG_COLORS_BLUE, onDrawGetColorItem, SetRGBColor);
+    MENU_ITEM(ICON_Cancel, MSG_BUTTON_CANCEL, onDrawMenuItem, Draw_SelectColors_Menu);
+    MENU_ITEM(0, MSG_COLORS_RED, onDrawGetColorItem, SetRGBColor);
+    MENU_ITEM(1, MSG_COLORS_GREEN, onDrawGetColorItem, SetRGBColor);
+    MENU_ITEM(2, MSG_COLORS_BLUE, onDrawGetColorItem, SetRGBColor);
   }
   UpdateMenu(GetColorMenu);
   DWIN_Draw_Rectangle(1, *MenuData.P_Int, 20, 315, DWIN_WIDTH - 20, 335);
 }
 
 #if BOTH(CASE_LIGHT_MENU, CASELIGHT_USES_BRIGHTNESS)
-    void Draw_CaseLight_Menu() {
-      checkkey = Menu;
-      if (SetMenu(CaseLightMenu, GET_TEXT_F(MSG_CASE_LIGHT), 3)) {
-        BACK_ITEM(Draw_Control_Menu);
-        EDIT_ITEM_F(ICON_CaseLight, MSG_CASE_LIGHT, onDrawChkbMenu, SetCaseLight, &caselight.on);
-        EDIT_ITEM_F(ICON_Brightness, MSG_CASE_LIGHT_BRIGHTNESS, onDrawPInt8Menu, SetCaseLightBrightness, &caselight.brightness);
-      }
-      UpdateMenu(CaseLightMenu);
+  void Draw_CaseLight_Menu() {
+    checkkey = Menu;
+    if (SET_MENU(CaseLightMenu, MSG_CASE_LIGHT, 3)) {
+      BACK_ITEM(Draw_Control_Menu);
+      EDIT_ITEM(ICON_CaseLight, MSG_CASE_LIGHT, onDrawChkbMenu, SetCaseLight, &caselight.on);
+      EDIT_ITEM(ICON_Brightness, MSG_CASE_LIGHT_BRIGHTNESS, onDrawPInt8Menu, SetCaseLightBrightness, &caselight.brightness);
     }
+    UpdateMenu(CaseLightMenu);
+  }
 #endif
 
 #if ENABLED(LED_CONTROL_MENU)
   void Draw_LedControl_Menu() {
     checkkey = Menu;
-    if (SetMenu(LedControlMenu, GET_TEXT_F(MSG_LED_CONTROL), 6)) {
+    if (SET_MENU(LedControlMenu, MSG_LED_CONTROL, 10)) {
       BACK_ITEM(Draw_Control_Menu);
       #if !BOTH(CASE_LIGHT_MENU, CASE_LIGHT_USE_NEOPIXEL)
-        EDIT_ITEM_F(ICON_LedControl, MSG_LEDS, onDrawChkbMenu, SetLedStatus, &leds.lights_on);
+        EDIT_ITEM(ICON_LedControl, MSG_LEDS, onDrawChkbMenu, SetLedStatus, &leds.lights_on);
       #endif
       #if HAS_COLOR_LEDS
         #if ENABLED(LED_COLOR_PRESETS)
-          MENU_ITEM_F(ICON_LedControl, MSG_SET_LEDS_WHITE, onDrawMenuItem,  leds.set_white);
-          MENU_ITEM_F(ICON_LedControl, MSG_SET_LEDS_RED, onDrawMenuItem,    leds.set_red);
-          MENU_ITEM_F(ICON_LedControl, MSG_SET_LEDS_ORANGE, onDrawMenuItem, leds.set_orange);
-          MENU_ITEM_F(ICON_LedControl, MSG_SET_LEDS_YELLOW, onDrawMenuItem, leds.set_yellow);
-          MENU_ITEM_F(ICON_LedControl, MSG_SET_LEDS_GREEN, onDrawMenuItem,  leds.set_green);
-          MENU_ITEM_F(ICON_LedControl, MSG_SET_LEDS_BLUE, onDrawMenuItem,   leds.set_blue);
-          MENU_ITEM_F(ICON_LedControl, MSG_SET_LEDS_INDIGO, onDrawMenuItem, leds.set_indigo);
-          MENU_ITEM_F(ICON_LedControl, MSG_SET_LEDS_VIOLET, onDrawMenuItem, leds.set_violet);
+          MENU_ITEM(ICON_LedControl, MSG_SET_LEDS_WHITE, onDrawMenuItem,  leds.set_white);
+          MENU_ITEM(ICON_LedControl, MSG_SET_LEDS_RED, onDrawMenuItem,    leds.set_red);
+          MENU_ITEM(ICON_LedControl, MSG_SET_LEDS_ORANGE, onDrawMenuItem, leds.set_orange);
+          MENU_ITEM(ICON_LedControl, MSG_SET_LEDS_YELLOW, onDrawMenuItem, leds.set_yellow);
+          MENU_ITEM(ICON_LedControl, MSG_SET_LEDS_GREEN, onDrawMenuItem,  leds.set_green);
+          MENU_ITEM(ICON_LedControl, MSG_SET_LEDS_BLUE, onDrawMenuItem,   leds.set_blue);
+          MENU_ITEM(ICON_LedControl, MSG_SET_LEDS_INDIGO, onDrawMenuItem, leds.set_indigo);
+          MENU_ITEM(ICON_LedControl, MSG_SET_LEDS_VIOLET, onDrawMenuItem, leds.set_violet);
         #else
-          EDIT_ITEM_F(ICON_LedControl, MSG_COLORS_RED, onDrawPInt8Menu, SetLEDColorR, &leds.color.r);
-          EDIT_ITEM_F(ICON_LedControl, MSG_COLORS_GREEN, onDrawPInt8Menu, SetLEDColorG, &leds.color.g);
-          EDIT_ITEM_F(ICON_LedControl, MSG_COLORS_BLUE, onDrawPInt8Menu, SetLEDColorB, &leds.color.b);
+          EDIT_ITEM(ICON_LedControl, MSG_COLORS_RED, onDrawPInt8Menu, SetLEDColorR, &leds.color.r);
+          EDIT_ITEM(ICON_LedControl, MSG_COLORS_GREEN, onDrawPInt8Menu, SetLEDColorG, &leds.color.g);
+          EDIT_ITEM(ICON_LedControl, MSG_COLORS_BLUE, onDrawPInt8Menu, SetLEDColorB, &leds.color.b);
           #if ENABLED(HAS_WHITE_LED)
-            EDIT_ITEM_F(ICON_LedControl, MSG_COLORS_WHITE, onDrawPInt8Menu, SetLEDColorW, &leds.color.w);
+            EDIT_ITEM(ICON_LedControl, MSG_COLORS_WHITE, onDrawPInt8Menu, SetLEDColorW, &leds.color.w);
           #endif
         #endif
       #endif
     }
     UpdateMenu(LedControlMenu);
   }
 #endif
 
 void Draw_Tune_Menu() {
   checkkey = Menu;
-  if (!TuneMenu) TuneMenu = new MenuClass();
-  if (CurrentMenu != TuneMenu) {
-    CurrentMenu = TuneMenu;
-    SetMenuTitle({73, 2, 28, 12}, GET_TEXT_F(MSG_TUNE)); // TODO: Chinese, English "Tune" JPG
-    MenuItemsPrepare(16);
+  if (SET_MENU_R(TuneMenu, selrect({73, 2, 28, 12}), MSG_TUNE, 14)) {
     BACK_ITEM(Goto_PrintProcess);
-    EDIT_ITEM_F(ICON_Speed, MSG_SPEED, onDrawSpeedItem, SetSpeed, &feedrate_percentage);
+    EDIT_ITEM(ICON_Speed, MSG_SPEED, onDrawSpeedItem, SetSpeed, &feedrate_percentage);
     #if HAS_HOTEND
-      HotendTargetItem = EDIT_ITEM_F(ICON_HotendTemp, MSG_UBL_SET_TEMP_HOTEND, onDrawHotendTemp, SetHotendTemp, &thermalManager.temp_hotend[0].target);
+      HotendTargetItem = EDIT_ITEM(ICON_HotendTemp, MSG_UBL_SET_TEMP_HOTEND, onDrawHotendTemp, SetHotendTemp, &thermalManager.temp_hotend[0].target);
     #endif
     #if HAS_HEATED_BED
-      BedTargetItem = EDIT_ITEM_F(ICON_BedTemp, MSG_UBL_SET_TEMP_BED, onDrawBedTemp, SetBedTemp, &thermalManager.temp_bed.target);
+      BedTargetItem = EDIT_ITEM(ICON_BedTemp, MSG_UBL_SET_TEMP_BED, onDrawBedTemp, SetBedTemp, &thermalManager.temp_bed.target);
     #endif
     #if HAS_FAN
-      FanSpeedItem = EDIT_ITEM_F(ICON_FanSpeed, MSG_FAN_SPEED, onDrawFanSpeed, SetFanSpeed, &thermalManager.fan_speed[0]);
+      FanSpeedItem = EDIT_ITEM(ICON_FanSpeed, MSG_FAN_SPEED, onDrawFanSpeed, SetFanSpeed, &thermalManager.fan_speed[0]);
     #endif
-    #if HAS_ZOFFSET_ITEM && EITHER(BABYSTEP_ZPROBE_OFFSET, JUST_BABYSTEP)
-      EDIT_ITEM_F(ICON_Zoffset, MSG_ZPROBE_ZOFFSET, onDrawZOffset, SetZOffset, &BABY_Z_VAR);
+    #if ALL(HAS_ZOFFSET_ITEM, HAS_BED_PROBE, BABYSTEPPING)
+      EDIT_ITEM(ICON_Zoffset, MSG_ZPROBE_ZOFFSET, onDrawZOffset, SetZOffset, &BABY_Z_VAR);
+    #elif ALL(HAS_ZOFFSET_ITEM, MESH_BED_LEVELING, BABYSTEPPING)
+      EDIT_ITEM(ICON_Zoffset, MSG_HOME_OFFSET_Z, onDrawPFloat2Menu, SetZOffset, &BABY_Z_VAR);
     #endif
-    EDIT_ITEM_F(ICON_Flow, MSG_FLOW, onDrawPIntMenu, SetFlow, &planner.flow_percentage[0]);
+    EDIT_ITEM(ICON_Flow, MSG_FLOW, onDrawPIntMenu, SetFlow, &planner.flow_percentage[0]);
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
-      MENU_ITEM_F(ICON_FilMan, MSG_FILAMENTCHANGE, onDrawMenuItem, ChangeFilament);
+      MENU_ITEM(ICON_FilMan, MSG_FILAMENTCHANGE, onDrawMenuItem, ChangeFilament);
+    #endif
+    #if HAS_FILAMENT_SENSOR
+      EDIT_ITEM(ICON_Runout, MSG_RUNOUT_ENABLE, onDrawChkbMenu, SetRunoutEnable, &runout.enabled);
     #endif
     #if ENABLED(FWRETRACT)
-      MENU_ITEM_F(ICON_FWRetract, MSG_FWRETRACT, onDrawSubMenu, Draw_FWRetract_Menu);
+      MENU_ITEM(ICON_FWRetract, MSG_FWRETRACT, onDrawSubMenu, Draw_FWRetract_Menu);
     #endif
     #if HAS_LOCKSCREEN
-      MENU_ITEM_F(ICON_Lock, MSG_LOCKSCREEN, onDrawMenuItem, DWIN_LockScreen);
+      MENU_ITEM(ICON_Lock, MSG_LOCKSCREEN, onDrawMenuItem, DWIN_LockScreen);
     #endif
     #if HAS_LCD_BRIGHTNESS
-      EDIT_ITEM_F(ICON_Brightness, MSG_BRIGHTNESS, onDrawPInt8Menu, SetBrightness, &ui.brightness);
-      MENU_ITEM_F(ICON_Brightness, MSG_BRIGHTNESS_OFF, onDrawMenuItem, TurnOffBacklight);
+      EDIT_ITEM(ICON_Brightness, MSG_BRIGHTNESS, onDrawPInt8Menu, SetBrightness, &ui.brightness);
+      MENU_ITEM(ICON_Brightness, MSG_BRIGHTNESS_OFF, onDrawMenuItem, TurnOffBacklight);
     #endif
     #if ENABLED(CASE_LIGHT_MENU)
-      EDIT_ITEM_F(ICON_CaseLight, MSG_CASE_LIGHT, onDrawChkbMenu, SetCaseLight, &caselight.on);
+      EDIT_ITEM(ICON_CaseLight, MSG_CASE_LIGHT, onDrawChkbMenu, SetCaseLight, &caselight.on);
     #elif ENABLED(LED_CONTROL_MENU) && DISABLED(CASE_LIGHT_USE_NEOPIXEL)
-      EDIT_ITEM_F(ICON_LedControl, MSG_LEDS, onDrawChkbMenu, SetLedStatus, &leds.lights_on);
+      EDIT_ITEM(ICON_LedControl, MSG_LEDS, onDrawChkbMenu, SetLedStatus, &leds.lights_on);
     #endif
   }
-  CurrentMenu->draw();
+  UpdateMenu(TuneMenu);
 }
 
 void Draw_Motion_Menu() {
   checkkey = Menu;
-  if (!MotionMenu) MotionMenu = new MenuClass();
-  if (CurrentMenu != MotionMenu) {
-    CurrentMenu = MotionMenu;
-    SetMenuTitle({1, 16, 28, 13}, GET_TEXT_F(MSG_MOTION)); // TODO: Chinese, English "Motion" JPG
-    MenuItemsPrepare(6);
+  if (SET_MENU_R(MotionMenu, selrect({1, 16, 28, 13}), MSG_MOTION, 6)) {
     BACK_ITEM(Draw_Control_Menu);
-    MENU_ITEM_F(ICON_MaxSpeed, MSG_SPEED, onDrawSpeed, Draw_MaxSpeed_Menu);
-    MENU_ITEM_F(ICON_MaxAccelerated, MSG_ACCELERATION, onDrawAcc, Draw_MaxAccel_Menu);
+    MENU_ITEM(ICON_MaxSpeed, MSG_SPEED, onDrawSpeed, Draw_MaxSpeed_Menu);
+    MENU_ITEM(ICON_MaxAccelerated, MSG_ACCELERATION, onDrawAcc, Draw_MaxAccel_Menu);
     #if HAS_CLASSIC_JERK
-      MENU_ITEM_F(ICON_MaxJerk, MSG_JERK, onDrawJerk, Draw_MaxJerk_Menu);
+      MENU_ITEM(ICON_MaxJerk, MSG_JERK, onDrawJerk, Draw_MaxJerk_Menu);
     #endif
-    MENU_ITEM_F(ICON_Step, MSG_STEPS_PER_MM, onDrawSteps, Draw_Steps_Menu);
-    EDIT_ITEM_F(ICON_Flow, MSG_FLOW, onDrawPIntMenu, SetFlow, &planner.flow_percentage[0]);
+    MENU_ITEM(ICON_Step, MSG_STEPS_PER_MM, onDrawSteps, Draw_Steps_Menu);
+    EDIT_ITEM(ICON_Flow, MSG_FLOW, onDrawPIntMenu, SetFlow, &planner.flow_percentage[0]);
   }
-  CurrentMenu->draw();
+  UpdateMenu(MotionMenu);
 }
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   void Draw_FilamentMan_Menu() {
     checkkey = Menu;
-    if (SetMenu(FilamentMenu, GET_TEXT_F(MSG_FILAMENT_MAN), 5)) {
+    if (SET_MENU(FilamentMenu, MSG_FILAMENT_MAN, 5)) {
       BACK_ITEM(Draw_Prepare_Menu);
-      MENU_ITEM_F(ICON_Park, MSG_FILAMENT_PARK_ENABLED, onDrawMenuItem, ParkHead);
-      MENU_ITEM_F(ICON_FilMan, MSG_FILAMENTCHANGE, onDrawMenuItem, ChangeFilament);
+      #if ENABLED(NOZZLE_PARK_FEATURE)
+        MENU_ITEM(ICON_Park, MSG_FILAMENT_PARK_ENABLED, onDrawMenuItem, ParkHead);
+      #endif
+      MENU_ITEM(ICON_FilMan, MSG_FILAMENTCHANGE, onDrawMenuItem, ChangeFilament);
       #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
-        MENU_ITEM_F(ICON_FilUnload, MSG_FILAMENTUNLOAD, onDrawMenuItem, UnloadFilament);
-        MENU_ITEM_F(ICON_FilLoad, MSG_FILAMENTLOAD, onDrawMenuItem, LoadFilament);
+        MENU_ITEM(ICON_FilUnload, MSG_FILAMENTUNLOAD, onDrawMenuItem, UnloadFilament);
+        MENU_ITEM(ICON_FilLoad, MSG_FILAMENTLOAD, onDrawMenuItem, LoadFilament);
       #endif
     }
     UpdateMenu(FilamentMenu);
   }
 #endif
 
 #if ENABLED(MESH_BED_LEVELING)
   void Draw_ManualMesh_Menu() {
     checkkey = Menu;
-    if (SetMenu(ManualMesh, GET_TEXT_F(MSG_UBL_MANUAL_MESH), 6)) {
+    if (SET_MENU(ManualMesh, MSG_UBL_MANUAL_MESH, 6)) {
       BACK_ITEM(Draw_Prepare_Menu);
-      MENU_ITEM_F(ICON_ManualMesh, MSG_LEVEL_BED, onDrawMenuItem, ManualMeshStart);
-      MMeshMoveZItem = EDIT_ITEM_F(ICON_Zoffset, MSG_MOVE_Z, onDrawMMeshMoveZ, SetMMeshMoveZ, &current_position.z);
-      MENU_ITEM_F(ICON_Axis, MSG_UBL_CONTINUE_MESH, onDrawMenuItem, ManualMeshContinue);
-      MENU_ITEM_F(ICON_MeshViewer, MSG_MESH_VIEW, onDrawSubMenu, DWIN_MeshViewer);
-      MENU_ITEM_F(ICON_MeshSave, MSG_UBL_SAVE_MESH, onDrawMenuItem, ManualMeshSave);
+      MENU_ITEM(ICON_ManualMesh, MSG_LEVEL_BED, onDrawMenuItem, ManualMeshStart);
+      MMeshMoveZItem = EDIT_ITEM(ICON_Zoffset, MSG_MOVE_Z, onDrawMMeshMoveZ, SetMMeshMoveZ, &current_position.z);
+      MENU_ITEM(ICON_Axis, MSG_UBL_CONTINUE_MESH, onDrawMenuItem, ManualMeshContinue);
+      MENU_ITEM(ICON_MeshViewer, MSG_MESH_VIEW, onDrawSubMenu, DWIN_MeshViewer);
+      MENU_ITEM(ICON_MeshSave, MSG_UBL_SAVE_MESH, onDrawMenuItem, ManualMeshSave);
     }
     UpdateMenu(ManualMesh);
   }
 #endif
 
 #if HAS_PREHEAT
 
-  void Draw_Preheat_Menu(frame_rect_t cn, const __FlashStringHelper* fstr) {
+  void Draw_Preheat_Menu(bool NotCurrent) {
     checkkey = Menu;
-    if (CurrentMenu != PreheatMenu) {
-      CurrentMenu = PreheatMenu;
-      SetMenuTitle(cn, fstr);
-      MenuItemsPrepare(5);
+    if (NotCurrent) {
       BACK_ITEM(Draw_Temperature_Menu);
       #if HAS_HOTEND
-        EDIT_ITEM_F(ICON_SetEndTemp, MSG_UBL_SET_TEMP_HOTEND, onDrawSetPreheatHotend, SetPreheatEndTemp, &ui.material_preset[HMI_value.Select].hotend_temp);
+        EDIT_ITEM(ICON_SetEndTemp, MSG_UBL_SET_TEMP_HOTEND, onDrawSetPreheatHotend, SetPreheatEndTemp, &ui.material_preset[HMI_value.Select].hotend_temp);
       #endif
       #if HAS_HEATED_BED
-        EDIT_ITEM_F(ICON_SetBedTemp, MSG_UBL_SET_TEMP_BED, onDrawSetPreheatBed, SetPreheatBedTemp, &ui.material_preset[HMI_value.Select].bed_temp);
+        EDIT_ITEM(ICON_SetBedTemp, MSG_UBL_SET_TEMP_BED, onDrawSetPreheatBed, SetPreheatBedTemp, &ui.material_preset[HMI_value.Select].bed_temp);
       #endif
       #if HAS_FAN
-        EDIT_ITEM_F(ICON_FanSpeed, MSG_FAN_SPEED, onDrawSetPreheatFan, SetPreheatFanSpeed, &ui.material_preset[HMI_value.Select].fan_speed);
+        EDIT_ITEM(ICON_FanSpeed, MSG_FAN_SPEED, onDrawSetPreheatFan, SetPreheatFanSpeed, &ui.material_preset[HMI_value.Select].fan_speed);
       #endif
       #if ENABLED(EEPROM_SETTINGS)
-        MENU_ITEM_F(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawWriteEeprom, WriteEeprom);
+        MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawWriteEeprom, WriteEeprom);
       #endif
     }
-    CurrentMenu->draw();
-  }
-
-  void Draw_Preheat1_Menu() {
-    HMI_value.Select = 0;
-    if (!PreheatMenu) PreheatMenu = new MenuClass();
-    Draw_Preheat_Menu({59, 16, 81, 14}, F(PREHEAT_1_LABEL " Preheat Settings")); // TODO: English "PLA Settings" JPG
+    UpdateMenu(PreheatMenu);
   }
 
-  #if PREHEAT_COUNT >= 2
-    void Draw_Preheat2_Menu() {
-      HMI_value.Select = 1;
-      if (!PreheatMenu) PreheatMenu = new MenuClass();
-      Draw_Preheat_Menu({142, 16, 82, 14}, F(PREHEAT_2_LABEL " Preheat Settings"));  // TODO: English "ABS Settings" JPG
+  #define _Preheat_Menu(N) \
+    void Draw_Preheat## N ##_Menu() { \
+      HMI_value.Select = N-1; \
+      Draw_Preheat_Menu(SET_MENU(PreheatMenu, MSG_PREHEAT_## N ##_SETTINGS, 5)); \
     }
-  #endif
-
-  #if PREHEAT_COUNT >= 3
-    void Draw_Preheat3_Menu() {
-      HMI_value.Select = 2;
-      if (!PreheatMenu) PreheatMenu = new MenuClass();
-      Draw_Preheat_Menu({225, 16, 82, 14}, F(PREHEAT_3_LABEL " Preheat Settings"));  // TODO: English "... Settings" JPG
-    }
-  #endif
+  REPEAT_1(PREHEAT_COUNT, _Preheat_Menu)
 
 #endif // HAS_PREHEAT
 
 void Draw_Temperature_Menu() {
   checkkey = Menu;
-  if (!TemperatureMenu) TemperatureMenu = new MenuClass();
-  if (CurrentMenu != TemperatureMenu) {
-    CurrentMenu = TemperatureMenu;
-    SetMenuTitle({236, 2, 28, 12}, GET_TEXT_F(MSG_TEMPERATURE));
-    MenuItemsPrepare(7);
+  if (SET_MENU_R(TemperatureMenu, selrect({236, 2, 28, 12}), MSG_TEMPERATURE, 4 + PREHEAT_COUNT)) {
     BACK_ITEM(Draw_Control_Menu);
     #if HAS_HOTEND
-      HotendTargetItem = EDIT_ITEM_F(ICON_SetEndTemp, MSG_UBL_SET_TEMP_HOTEND, onDrawHotendTemp, SetHotendTemp, &thermalManager.temp_hotend[0].target);
+      HotendTargetItem = EDIT_ITEM(ICON_SetEndTemp, MSG_UBL_SET_TEMP_HOTEND, onDrawHotendTemp, SetHotendTemp, &thermalManager.temp_hotend[0].target);
     #endif
     #if HAS_HEATED_BED
-      BedTargetItem = EDIT_ITEM_F(ICON_SetBedTemp, MSG_UBL_SET_TEMP_BED, onDrawBedTemp, SetBedTemp, &thermalManager.temp_bed.target);
+      BedTargetItem = EDIT_ITEM(ICON_SetBedTemp, MSG_UBL_SET_TEMP_BED, onDrawBedTemp, SetBedTemp, &thermalManager.temp_bed.target);
     #endif
     #if HAS_FAN
-      FanSpeedItem = EDIT_ITEM_F(ICON_FanSpeed, MSG_FAN_SPEED, onDrawFanSpeed, SetFanSpeed, &thermalManager.fan_speed[0]);
+      FanSpeedItem = EDIT_ITEM(ICON_FanSpeed, MSG_FAN_SPEED, onDrawFanSpeed, SetFanSpeed, &thermalManager.fan_speed[0]);
     #endif
     #if HAS_PREHEAT
-      MENU_ITEM_F(ICON_SetPLAPreheat, MSG_PREHEAT_1_SETTINGS, onDrawPLAPreheatSubMenu, Draw_Preheat1_Menu);
-      #if PREHEAT_COUNT >= 2
-        MENU_ITEM_F(ICON_SetABSPreheat, MSG_PREHEAT_2_SETTINGS, onDrawABSPreheatSubMenu, Draw_Preheat2_Menu);
-        #if PREHEAT_COUNT >= 3
-          MENU_ITEM_F(ICON_SetCustomPreheat, MSG_PREHEAT_3_SETTINGS, onDrawSubMenu, Draw_Preheat3_Menu);
-        #endif
-      #endif
+      #define _ITEM_SETPREHEAT(N) MENU_ITEM(ICON_SetPreheat##N, MSG_PREHEAT_## N ##_SETTINGS, onDrawSubMenu, Draw_Preheat## N ##_Menu);
+      REPEAT_1(PREHEAT_COUNT, _ITEM_SETPREHEAT)
     #endif
   }
-  CurrentMenu->draw();
+  UpdateMenu(TemperatureMenu);
 }
 
 void Draw_MaxSpeed_Menu() {
   checkkey = Menu;
-  if (!MaxSpeedMenu) MaxSpeedMenu = new MenuClass();
-  if (CurrentMenu != MaxSpeedMenu) {
-    CurrentMenu = MaxSpeedMenu;
-    SetMenuTitle({1, 16, 28, 13}, GET_TEXT_F(MSG_MAX_SPEED));
-    MenuItemsPrepare(5);
+  if (SET_MENU_R(MaxSpeedMenu, selrect({1, 16, 28, 13}), MSG_MAX_SPEED, 5)) {
     BACK_ITEM(Draw_Motion_Menu);
-    EDIT_ITEM_F(ICON_MaxSpeedX, MSG_VMAX_A, onDrawMaxSpeedX, SetMaxSpeedX, &planner.settings.max_feedrate_mm_s[X_AXIS]);
-    EDIT_ITEM_F(ICON_MaxSpeedY, MSG_VMAX_B, onDrawMaxSpeedY, SetMaxSpeedY, &planner.settings.max_feedrate_mm_s[Y_AXIS]);
-    EDIT_ITEM_F(ICON_MaxSpeedZ, MSG_VMAX_C, onDrawMaxSpeedZ, SetMaxSpeedZ, &planner.settings.max_feedrate_mm_s[Z_AXIS]);
+    EDIT_ITEM(ICON_MaxSpeedX, MSG_VMAX_A, onDrawMaxSpeedX, SetMaxSpeedX, &planner.settings.max_feedrate_mm_s[X_AXIS]);
+    EDIT_ITEM(ICON_MaxSpeedY, MSG_VMAX_B, onDrawMaxSpeedY, SetMaxSpeedY, &planner.settings.max_feedrate_mm_s[Y_AXIS]);
+    EDIT_ITEM(ICON_MaxSpeedZ, MSG_VMAX_C, onDrawMaxSpeedZ, SetMaxSpeedZ, &planner.settings.max_feedrate_mm_s[Z_AXIS]);
     #if HAS_HOTEND
-      EDIT_ITEM_F(ICON_MaxSpeedE, MSG_VMAX_E, onDrawMaxSpeedE, SetMaxSpeedE, &planner.settings.max_feedrate_mm_s[E_AXIS]);
+      EDIT_ITEM(ICON_MaxSpeedE, MSG_VMAX_E, onDrawMaxSpeedE, SetMaxSpeedE, &planner.settings.max_feedrate_mm_s[E_AXIS]);
     #endif
   }
-  CurrentMenu->draw();
+  UpdateMenu(MaxSpeedMenu);
 }
 
 void Draw_MaxAccel_Menu() {
   checkkey = Menu;
-  if (!MaxAccelMenu) MaxAccelMenu = new MenuClass();
-  if (CurrentMenu != MaxAccelMenu) {
-    CurrentMenu = MaxAccelMenu;
-    SetMenuTitle({1, 16, 28, 13}, GET_TEXT_F(MSG_ACCELERATION));
-    MenuItemsPrepare(5);
+  if (SET_MENU_R(MaxAccelMenu, selrect({1, 16, 28, 13}), MSG_AMAX_EN, 5)) {
     BACK_ITEM(Draw_Motion_Menu);
-    EDIT_ITEM_F(ICON_MaxAccX, MSG_AMAX_A, onDrawMaxAccelX, SetMaxAccelX, &planner.settings.max_acceleration_mm_per_s2[X_AXIS]);
-    EDIT_ITEM_F(ICON_MaxAccY, MSG_AMAX_B, onDrawMaxAccelY, SetMaxAccelY, &planner.settings.max_acceleration_mm_per_s2[Y_AXIS]);
-    EDIT_ITEM_F(ICON_MaxAccZ, MSG_AMAX_C, onDrawMaxAccelZ, SetMaxAccelZ, &planner.settings.max_acceleration_mm_per_s2[Z_AXIS]);
+    EDIT_ITEM(ICON_MaxAccX, MSG_AMAX_A, onDrawMaxAccelX, SetMaxAccelX, &planner.settings.max_acceleration_mm_per_s2[X_AXIS]);
+    EDIT_ITEM(ICON_MaxAccY, MSG_AMAX_B, onDrawMaxAccelY, SetMaxAccelY, &planner.settings.max_acceleration_mm_per_s2[Y_AXIS]);
+    EDIT_ITEM(ICON_MaxAccZ, MSG_AMAX_C, onDrawMaxAccelZ, SetMaxAccelZ, &planner.settings.max_acceleration_mm_per_s2[Z_AXIS]);
     #if HAS_HOTEND
-      EDIT_ITEM_F(ICON_MaxAccE, MSG_AMAX_E, onDrawMaxAccelE, SetMaxAccelE, &planner.settings.max_acceleration_mm_per_s2[E_AXIS]);
+      EDIT_ITEM(ICON_MaxAccE, MSG_AMAX_E, onDrawMaxAccelE, SetMaxAccelE, &planner.settings.max_acceleration_mm_per_s2[E_AXIS]);
     #endif
   }
-  CurrentMenu->draw();
+  UpdateMenu(MaxAccelMenu);
 }
 
 #if HAS_CLASSIC_JERK
   void Draw_MaxJerk_Menu() {
     checkkey = Menu;
-    if (!MaxJerkMenu) MaxJerkMenu = new MenuClass();
-    if (CurrentMenu != MaxJerkMenu) {
-      CurrentMenu = MaxJerkMenu;
-      SetMenuTitle({1, 16, 28, 13}, GET_TEXT_F(MSG_JERK));
-      MenuItemsPrepare(5);
+    if (SET_MENU_R(MaxJerkMenu, selrect({1, 16, 28, 13}), MSG_JERK, 5)) {
       BACK_ITEM(Draw_Motion_Menu);
-      EDIT_ITEM_F(ICON_MaxSpeedJerkX, MSG_VA_JERK, onDrawMaxJerkX, SetMaxJerkX, &planner.max_jerk.x);
-      EDIT_ITEM_F(ICON_MaxSpeedJerkY, MSG_VB_JERK, onDrawMaxJerkY, SetMaxJerkY, &planner.max_jerk.y);
-      EDIT_ITEM_F(ICON_MaxSpeedJerkZ, MSG_VC_JERK, onDrawMaxJerkZ, SetMaxJerkZ, &planner.max_jerk.z);
+      EDIT_ITEM(ICON_MaxSpeedJerkX, MSG_VA_JERK, onDrawMaxJerkX, SetMaxJerkX, &planner.max_jerk.x);
+      EDIT_ITEM(ICON_MaxSpeedJerkY, MSG_VB_JERK, onDrawMaxJerkY, SetMaxJerkY, &planner.max_jerk.y);
+      EDIT_ITEM(ICON_MaxSpeedJerkZ, MSG_VC_JERK, onDrawMaxJerkZ, SetMaxJerkZ, &planner.max_jerk.z);
       #if HAS_HOTEND
-        EDIT_ITEM_F(ICON_MaxSpeedJerkE, MSG_VE_JERK, onDrawMaxJerkE, SetMaxJerkE, &planner.max_jerk.e);
+        EDIT_ITEM(ICON_MaxSpeedJerkE, MSG_VE_JERK, onDrawMaxJerkE, SetMaxJerkE, &planner.max_jerk.e);
       #endif
     }
-    CurrentMenu->draw();
+    UpdateMenu(MaxJerkMenu);
   }
 #endif
 
 void Draw_Steps_Menu() {
   checkkey = Menu;
-  if (!StepsMenu) StepsMenu = new MenuClass();
-  if (CurrentMenu != StepsMenu) {
-    CurrentMenu = StepsMenu;
-    SetMenuTitle({1, 16, 28, 13}, GET_TEXT_F(MSG_STEPS_PER_MM));
-    MenuItemsPrepare(5);
+  if (SET_MENU_R(StepsMenu, selrect({1, 16, 28, 13}), MSG_STEPS_PER_MM, 5)) {
     BACK_ITEM(Draw_Motion_Menu);
-    EDIT_ITEM_F(ICON_StepX, MSG_A_STEPS, onDrawStepsX, SetStepsX, &planner.settings.axis_steps_per_mm[X_AXIS]);
-    EDIT_ITEM_F(ICON_StepY, MSG_B_STEPS, onDrawStepsY, SetStepsY, &planner.settings.axis_steps_per_mm[Y_AXIS]);
-    EDIT_ITEM_F(ICON_StepZ, MSG_C_STEPS, onDrawStepsZ, SetStepsZ, &planner.settings.axis_steps_per_mm[Z_AXIS]);
+    EDIT_ITEM(ICON_StepX, MSG_A_STEPS, onDrawStepsX, SetStepsX, &planner.settings.axis_steps_per_mm[X_AXIS]);
+    EDIT_ITEM(ICON_StepY, MSG_B_STEPS, onDrawStepsY, SetStepsY, &planner.settings.axis_steps_per_mm[Y_AXIS]);
+    EDIT_ITEM(ICON_StepZ, MSG_C_STEPS, onDrawStepsZ, SetStepsZ, &planner.settings.axis_steps_per_mm[Z_AXIS]);
     #if HAS_HOTEND
-      EDIT_ITEM_F(ICON_StepE, MSG_E_STEPS, onDrawStepsE, SetStepsE, &planner.settings.axis_steps_per_mm[E_AXIS]);
+      EDIT_ITEM(ICON_StepE, MSG_E_STEPS, onDrawStepsE, SetStepsE, &planner.settings.axis_steps_per_mm[E_AXIS]);
     #endif
   }
-  CurrentMenu->draw();
+  UpdateMenu(StepsMenu);
 }
 
 #if ENABLED(PIDTEMP)
   void Draw_HotendPID_Menu() {
     checkkey = Menu;
-    if (SetMenu(HotendPIDMenu, F(STR_HOTEND_PID " Settings"), 8)) {
+    if (SET_MENU_F(HotendPIDMenu, STR_HOTEND_PID " Settings", 8)) {
       BACK_ITEM(Draw_AdvancedSettings_Menu);
-      MENU_ITEM(ICON_PIDNozzle, F(STR_HOTEND_PID), onDrawMenuItem, HotendPID);
-      EDIT_ITEM(ICON_PIDValue, F("Set" STR_KP), onDrawPFloat2Menu, SetKp, &thermalManager.temp_hotend[0].pid.Kp);
-      EDIT_ITEM(ICON_PIDValue, F("Set" STR_KI), onDrawPIDi, SetKi, &thermalManager.temp_hotend[0].pid.Ki);
-      EDIT_ITEM(ICON_PIDValue, F("Set" STR_KD), onDrawPIDd, SetKd, &thermalManager.temp_hotend[0].pid.Kd);
-      EDIT_ITEM_F(ICON_Temperature, MSG_TEMPERATURE, onDrawPIntMenu, SetHotendPidT, &HMI_data.HotendPidT);
-      EDIT_ITEM_F(ICON_PIDcycles, MSG_PID_CYCLE, onDrawPIntMenu, SetPidCycles, &HMI_data.PidCycles);
+      MENU_ITEM_F(ICON_PIDNozzle, STR_HOTEND_PID, onDrawMenuItem, HotendPID);
+      EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KP, onDrawPFloat2Menu, SetKp, &thermalManager.temp_hotend[0].pid.Kp);
+      EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KI, onDrawPIDi, SetKi, &thermalManager.temp_hotend[0].pid.Ki);
+      EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KD, onDrawPIDd, SetKd, &thermalManager.temp_hotend[0].pid.Kd);
+      EDIT_ITEM(ICON_Temperature, MSG_TEMPERATURE, onDrawPIntMenu, SetHotendPidT, &HMI_data.HotendPidT);
+      EDIT_ITEM(ICON_PIDCycles, MSG_PID_CYCLE, onDrawPIntMenu, SetPidCycles, &HMI_data.PidCycles);
       #if ENABLED(EEPROM_SETTINGS)
-        MENU_ITEM_F(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawMenuItem, WriteEeprom);
+        MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawMenuItem, WriteEeprom);
       #endif
     }
     UpdateMenu(HotendPIDMenu);
   }
 #endif
 
 #if ENABLED(PIDTEMPBED)
   void Draw_BedPID_Menu() {
     checkkey = Menu;
-    if (SetMenu(BedPIDMenu, F(STR_BED_PID " Settings"), 8)) {
+    if (SET_MENU_F(BedPIDMenu, STR_BED_PID " Settings", 8)) {
       BACK_ITEM(Draw_AdvancedSettings_Menu);
-      MENU_ITEM(ICON_PIDNozzle, F(STR_BED_PID), onDrawMenuItem,BedPID);
-      EDIT_ITEM(ICON_PIDValue, F("Set" STR_KP), onDrawPFloat2Menu, SetKp, &thermalManager.temp_bed.pid.Kp);
-      EDIT_ITEM(ICON_PIDValue, F("Set" STR_KI), onDrawPIDi, SetKi, &thermalManager.temp_bed.pid.Ki);
-      EDIT_ITEM(ICON_PIDValue, F("Set" STR_KD), onDrawPIDd, SetKd, &thermalManager.temp_bed.pid.Kd);
-      EDIT_ITEM_F(ICON_Temperature, MSG_TEMPERATURE, onDrawPIntMenu, SetBedPidT, &HMI_data.BedPidT);
-      EDIT_ITEM_F(ICON_PIDcycles, MSG_PID_CYCLE, onDrawPIntMenu, SetPidCycles, &HMI_data.PidCycles);
+      MENU_ITEM_F(ICON_PIDBed, STR_BED_PID, onDrawMenuItem,BedPID);
+      EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KP, onDrawPFloat2Menu, SetKp, &thermalManager.temp_bed.pid.Kp);
+      EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KI, onDrawPIDi, SetKi, &thermalManager.temp_bed.pid.Ki);
+      EDIT_ITEM_F(ICON_PIDValue, "Set" STR_KD, onDrawPIDd, SetKd, &thermalManager.temp_bed.pid.Kd);
+      EDIT_ITEM(ICON_Temperature, MSG_TEMPERATURE, onDrawPIntMenu, SetBedPidT, &HMI_data.BedPidT);
+      EDIT_ITEM(ICON_PIDCycles, MSG_PID_CYCLE, onDrawPIntMenu, SetPidCycles, &HMI_data.PidCycles);
       #if ENABLED(EEPROM_SETTINGS)
-        MENU_ITEM_F(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawMenuItem, WriteEeprom);
+        MENU_ITEM(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawMenuItem, WriteEeprom);
       #endif
     }
     UpdateMenu(BedPIDMenu);
   }
 #endif
 
-#if ENABLED(BABYSTEP_ZPROBE_OFFSET)
+#if HAS_BED_PROBE
   void Draw_ZOffsetWiz_Menu() {
     checkkey = Menu;
-    if (SetMenu(ZOffsetWizMenu, GET_TEXT_F(MSG_PROBE_WIZARD), 4)) {
+    if (SET_MENU(ZOffsetWizMenu, MSG_PROBE_WIZARD, 4)) {
       BACK_ITEM(Draw_Prepare_Menu);
-      MENU_ITEM_F(ICON_Homing, MSG_AUTO_HOME, onDrawMenuItem, AutoHome);
-      MENU_ITEM(ICON_MoveZ0, F("Move Z to Home"), onDrawMenuItem, SetMoveZto0);
-      EDIT_ITEM_F(ICON_Zoffset, MSG_ZPROBE_ZOFFSET, onDrawPFloat2Menu, SetZOffset, &BABY_Z_VAR);
+      MENU_ITEM(ICON_Homing, MSG_AUTO_HOME, onDrawMenuItem, AutoHome);
+      MENU_ITEM_F(ICON_MoveZ0, "Move Z to Home", onDrawMenuItem, SetMoveZto0);
+      EDIT_ITEM(ICON_Zoffset, MSG_ZPROBE_ZOFFSET, onDrawPFloat2Menu, SetZOffset, &BABY_Z_VAR);
     }
     UpdateMenu(ZOffsetWizMenu);
     if (!axis_is_trusted(Z_AXIS)) LCD_MESSAGE_F("WARNING: Z position unknown, move Z to home");
   }
 #endif
 
 #if ENABLED(INDIVIDUAL_AXIS_HOMING_SUBMENU)
   void Draw_Homing_Menu() {
     checkkey = Menu;
-    if (SetMenu(HomingMenu, GET_TEXT_F(MSG_HOMING), 5)) {
+    if (SET_MENU(HomingMenu, MSG_HOMING, 6)) {
       BACK_ITEM(Draw_Prepare_Menu);
-      MENU_ITEM_F(ICON_Homing, MSG_AUTO_HOME, onDrawMenuItem, AutoHome);
-      MENU_ITEM_F(ICON_HomeX, MSG_AUTO_HOME_X, onDrawMenuItem, HomeX);
-      MENU_ITEM_F(ICON_HomeY, MSG_AUTO_HOME_Y, onDrawMenuItem, HomeY);
-      MENU_ITEM_F(ICON_HomeZ, MSG_AUTO_HOME_Z, onDrawMenuItem, HomeZ);
+      MENU_ITEM(ICON_Homing, MSG_AUTO_HOME, onDrawMenuItem, AutoHome);
+      MENU_ITEM(ICON_HomeX, MSG_AUTO_HOME_X, onDrawMenuItem, HomeX);
+      MENU_ITEM(ICON_HomeY, MSG_AUTO_HOME_Y, onDrawMenuItem, HomeY);
+      MENU_ITEM(ICON_HomeZ, MSG_AUTO_HOME_Z, onDrawMenuItem, HomeZ);
+      #if ENABLED(MESH_BED_LEVELING)
+        EDIT_ITEM(ICON_ZAfterHome, MSG_Z_AFTER_HOME, onDrawPInt8Menu, SetZAfterHoming, &HMI_data.z_after_homing);
+      #endif
     }
     UpdateMenu(HomingMenu);
   }
 #endif
 
 #if ENABLED(FWRETRACT)
   void Draw_FWRetract_Menu() {
     checkkey = Menu;
-    if (SetMenu(FWRetractMenu, GET_TEXT_F(MSG_FWRETRACT), 6)) {
+    if (SET_MENU(FWRetractMenu, MSG_FWRETRACT, 6)) {
       BACK_ITEM(Return_FWRetract_Menu);
-      EDIT_ITEM_F(ICON_FWRetLength, MSG_CONTROL_RETRACT, onDrawPFloatMenu, SetRetractLength, &fwretract.settings.retract_length);
-      EDIT_ITEM_F(ICON_FWRetSpeed, MSG_SINGLENOZZLE_RETRACT_SPEED, onDrawPFloatMenu, SetRetractSpeed, &fwretract.settings.retract_feedrate_mm_s);
-      EDIT_ITEM_F(ICON_FWRetZRaise, MSG_CONTROL_RETRACT_ZHOP, onDrawPFloat2Menu, SetZRaise, &fwretract.settings.retract_zraise);
-      EDIT_ITEM_F(ICON_FWRecSpeed, MSG_SINGLENOZZLE_UNRETRACT_SPEED, onDrawPFloatMenu, SetRecoverSpeed, &fwretract.settings.retract_recover_feedrate_mm_s);
-      EDIT_ITEM_F(ICON_FWRecExtra, MSG_CONTROL_RETRACT_RECOVER, onDrawPFloatMenu, SetAddRecover, &fwretract.settings.retract_recover_extra);
+      EDIT_ITEM(ICON_FWRetLength, MSG_CONTROL_RETRACT, onDrawPFloatMenu, SetRetractLength, &fwretract.settings.retract_length);
+      EDIT_ITEM(ICON_FWRetSpeed, MSG_SINGLENOZZLE_RETRACT_SPEED, onDrawPFloatMenu, SetRetractSpeed, &fwretract.settings.retract_feedrate_mm_s);
+      EDIT_ITEM(ICON_FWRetZRaise, MSG_CONTROL_RETRACT_ZHOP, onDrawPFloat2Menu, SetZRaise, &fwretract.settings.retract_zraise);
+      EDIT_ITEM(ICON_FWRecSpeed, MSG_SINGLENOZZLE_UNRETRACT_SPEED, onDrawPFloatMenu, SetRecoverSpeed, &fwretract.settings.retract_recover_feedrate_mm_s);
+      EDIT_ITEM(ICON_FWRecExtra, MSG_CONTROL_RETRACT_RECOVER, onDrawPFloatMenu, SetAddRecover, &fwretract.settings.retract_recover_extra);
     }
     UpdateMenu(FWRetractMenu);
   }
 #endif
 
 //=============================================================================
 // Mesh Bed Leveling
 //=============================================================================
 
 #if HAS_MESH
@@ -3767,46 +3548,46 @@ void Draw_Steps_Menu() {
   }
 
   #if BOTH(HAS_HEATED_BED, PREHEAT_BEFORE_LEVELING)
     void SetBedLevT() { SetPIntOnClick(MIN_BEDTEMP, MAX_BEDTEMP); }
   #endif
 
   #if ENABLED(MESH_EDIT_MENU)
     #define Z_OFFSET_MIN -3
     #define Z_OFFSET_MAX  3
 
-    void LiveEditMesh() { ((MenuItemPtrClass*)EditZValueItem)->value = &bedlevel.z_values[HMI_value.Select ? BedLevelTools.mesh_x : MenuData.Value][HMI_value.Select ? MenuData.Value : BedLevelTools.mesh_y]; EditZValueItem->redraw(); }
-    void ApplyEditMeshX() { BedLevelTools.mesh_x = MenuData.Value; }
-    void SetEditMeshX() { HMI_value.Select = 0; SetIntOnClick(0, GRID_MAX_POINTS_X - 1, BedLevelTools.mesh_x, ApplyEditMeshX, LiveEditMesh); }
-    void ApplyEditMeshY() { BedLevelTools.mesh_y = MenuData.Value; }
-    void SetEditMeshY() { HMI_value.Select = 1; SetIntOnClick(0, GRID_MAX_POINTS_Y - 1, BedLevelTools.mesh_y, ApplyEditMeshY, LiveEditMesh); }
+    void LiveEditMesh() { ((MenuItemPtrClass*)EditZValueItem)->value = &bedlevel.z_values[HMI_value.Select ? bedLevelTools.mesh_x : MenuData.Value][HMI_value.Select ? MenuData.Value : bedLevelTools.mesh_y]; EditZValueItem->redraw(); }
+    void ApplyEditMeshX() { bedLevelTools.mesh_x = MenuData.Value; }
+    void SetEditMeshX() { HMI_value.Select = 0; SetIntOnClick(0, GRID_MAX_POINTS_X - 1, bedLevelTools.mesh_x, ApplyEditMeshX, LiveEditMesh); }
+    void ApplyEditMeshY() { bedLevelTools.mesh_y = MenuData.Value; }
+    void SetEditMeshY() { HMI_value.Select = 1; SetIntOnClick(0, GRID_MAX_POINTS_Y - 1, bedLevelTools.mesh_y, ApplyEditMeshY, LiveEditMesh); }
     void SetEditZValue() { SetPFloatOnClick(Z_OFFSET_MIN, Z_OFFSET_MAX, 3); }
   #endif
 #endif
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
 
   void ApplyUBLSlot() { bedlevel.storage_slot = MenuData.Value; }
   void SetUBLSlot() { SetIntOnClick(0, settings.calc_num_meshes() - 1, bedlevel.storage_slot, ApplyUBLSlot); }
   void onDrawUBLSlot(MenuItemClass* menuitem, int8_t line) {
     if (bedlevel.storage_slot < 0) bedlevel.storage_slot = 0;
     onDrawIntMenu(menuitem, line, bedlevel.storage_slot);
   }
 
-  void ApplyUBLTiltGrid() { BedLevelTools.tilt_grid = MenuData.Value; }
-  void SetUBLTiltGrid() { SetIntOnClick(1, 3, BedLevelTools.tilt_grid, ApplyUBLTiltGrid); }
+  void ApplyUBLTiltGrid() { bedLevelTools.tilt_grid = MenuData.Value; }
+  void SetUBLTiltGrid() { SetIntOnClick(1, 3, bedLevelTools.tilt_grid, ApplyUBLTiltGrid); }
 
   void UBLTiltMesh() {
     if (bedlevel.storage_slot < 0) bedlevel.storage_slot = 0;
     char buf[15];
-    if (BedLevelTools.tilt_grid > 1) {
-      sprintf_P(buf, PSTR("G28O\nG29 J%i"), BedLevelTools.tilt_grid);
+    if (bedLevelTools.tilt_grid > 1) {
+      sprintf_P(buf, PSTR("G28O\nG29 J%i"), bedLevelTools.tilt_grid);
       gcode.process_subcommands_now(buf);
     }
     else
       gcode.process_subcommands_now(F("G28O\nG29J"));
     LCD_MESSAGE(MSG_UBL_MESH_TILTED);
   }
 
   void UBLSmartFillMesh() {
     LOOP_L_N(x, GRID_MAX_POINTS_Y) bedlevel.smart_fill_mesh();
     LCD_MESSAGE(MSG_UBL_MESH_FILLED);
@@ -3823,55 +3604,55 @@ void Draw_Steps_Menu() {
     if (bedlevel.storage_slot < 0) bedlevel.storage_slot = 0;
     settings.load_mesh(bedlevel.storage_slot);
   }
 
 #endif // AUTO_BED_LEVELING_UBL
 
 #if HAS_MESH
 
   void Draw_MeshSet_Menu() {
     checkkey = Menu;
-    if (SetMenu(MeshMenu, GET_TEXT_F(MSG_MESH_LEVELING), 15)) {
+    if (SET_MENU(MeshMenu, MSG_MESH_LEVELING, 13)) {
       BACK_ITEM(Draw_AdvancedSettings_Menu);
       #if BOTH(HAS_HEATED_BED, PREHEAT_BEFORE_LEVELING)
-        EDIT_ITEM_F(ICON_Temperature, MSG_UBL_SET_TEMP_BED, onDrawPIntMenu, SetBedLevT, &HMI_data.BedLevT);
+        EDIT_ITEM(ICON_Temperature, MSG_UBL_SET_TEMP_BED, onDrawPIntMenu, SetBedLevT, &HMI_data.BedLevT);
       #endif
-      EDIT_ITEM_F(ICON_SetZOffset, MSG_Z_FADE_HEIGHT, onDrawPFloatMenu, SetMeshFadeHeight, &planner.z_fade_height);
-      EDIT_ITEM_F(ICON_UBLActive, MSG_ACTIVATE_MESH, onDrawChkbMenu, SetMeshActive, &planner.leveling_active);
+      EDIT_ITEM(ICON_SetZOffset, MSG_Z_FADE_HEIGHT, onDrawPFloatMenu, SetMeshFadeHeight, &planner.z_fade_height);
+      EDIT_ITEM(ICON_UBLActive, MSG_ACTIVATE_MESH, onDrawChkbMenu, SetMeshActive, &planner.leveling_active);
       #if HAS_BED_PROBE
-        MENU_ITEM_F(ICON_Level, MSG_AUTO_MESH, onDrawMenuItem, AutoLev);
+        MENU_ITEM(ICON_Level, MSG_AUTO_MESH, onDrawMenuItem, AutoLev);
       #endif
       #if ENABLED(AUTO_BED_LEVELING_UBL)
-        EDIT_ITEM_F(ICON_UBLActive, MSG_UBL_STORAGE_SLOT, onDrawUBLSlot, SetUBLSlot, &bedlevel.storage_slot);
-        MENU_ITEM_F(ICON_UBLActive, MSG_UBL_SAVE_MESH, onDrawMenuItem, UBLSaveMesh);
-        MENU_ITEM_F(ICON_UBLActive, MSG_UBL_LOAD_MESH, onDrawMenuItem, UBLLoadMesh);
-        EDIT_ITEM_F(ICON_UBLActive, MSG_UBL_TILTING_GRID, onDrawPInt8Menu, SetUBLTiltGrid, &BedLevelTools.tilt_grid);
-        MENU_ITEM_F(ICON_UBLActive, MSG_UBL_TILT_MESH, onDrawMenuItem, UBLTiltMesh);
-        MENU_ITEM_F(ICON_UBLActive, MSG_UBL_SMART_FILLIN, onDrawMenuItem, UBLSmartFillMesh);
+        EDIT_ITEM(ICON_UBLSlot, MSG_UBL_STORAGE_SLOT, onDrawUBLSlot, SetUBLSlot, &bedlevel.storage_slot);
+        MENU_ITEM(ICON_UBLSaveMesh, MSG_UBL_SAVE_MESH, onDrawMenuItem, UBLSaveMesh);
+        MENU_ITEM(ICON_UBLLoadMesh, MSG_UBL_LOAD_MESH, onDrawMenuItem, UBLLoadMesh);
+        EDIT_ITEM(ICON_UBLTiltGrid, MSG_UBL_TILTING_GRID, onDrawPInt8Menu, SetUBLTiltGrid, &bedLevelTools.tilt_grid);
+        MENU_ITEM(ICON_UBLTiltGrid, MSG_UBL_TILT_MESH, onDrawMenuItem, UBLTiltMesh);
+        MENU_ITEM(ICON_UBLSmartFill, MSG_UBL_SMART_FILLIN, onDrawMenuItem, UBLSmartFillMesh);
       #endif
       #if ENABLED(MESH_EDIT_MENU)
-        MENU_ITEM_F(ICON_UBLActive, MSG_EDIT_MESH, onDrawSubMenu, Draw_EditMesh_Menu);
+        MENU_ITEM(ICON_MeshEdit, MSG_EDIT_MESH, onDrawSubMenu, Draw_EditMesh_Menu);
       #endif
-      MENU_ITEM_F(ICON_MeshViewer, MSG_MESH_VIEW, onDrawSubMenu, DWIN_MeshViewer);
+      MENU_ITEM(ICON_MeshViewer, MSG_MESH_VIEW, onDrawSubMenu, DWIN_MeshViewer);
     }
     UpdateMenu(MeshMenu);
   }
 
   #if ENABLED(MESH_EDIT_MENU)
     void Draw_EditMesh_Menu() {
       if (!leveling_is_valid()) { LCD_MESSAGE(MSG_UBL_MESH_INVALID); return; }
       set_bed_leveling_enabled(false);
       checkkey = Menu;
-      if (SetMenu(EditMeshMenu, GET_TEXT_F(MSG_EDIT_MESH), 4)) {
-        BedLevelTools.mesh_x = BedLevelTools.mesh_y = 0;
+      if (SET_MENU(EditMeshMenu, MSG_EDIT_MESH, 4)) {
+        bedLevelTools.mesh_x = bedLevelTools.mesh_y = 0;
         BACK_ITEM(Draw_MeshSet_Menu);
-        EDIT_ITEM_F(ICON_UBLActive, MSG_MESH_X, onDrawPInt8Menu, SetEditMeshX,&BedLevelTools.mesh_x);
-        EDIT_ITEM_F(ICON_UBLActive, MSG_MESH_Y, onDrawPInt8Menu, SetEditMeshY,&BedLevelTools.mesh_y);
-        EditZValueItem = EDIT_ITEM_F(ICON_UBLActive, MSG_MESH_EDIT_Z, onDrawPFloat3Menu, SetEditZValue, &bedlevel.z_values[BedLevelTools.mesh_x][BedLevelTools.mesh_y]);
+        EDIT_ITEM(ICON_MeshEditX, MSG_MESH_X, onDrawPInt8Menu, SetEditMeshX, &bedLevelTools.mesh_x);
+        EDIT_ITEM(ICON_MeshEditY, MSG_MESH_Y, onDrawPInt8Menu, SetEditMeshY, &bedLevelTools.mesh_y);
+        EditZValueItem = EDIT_ITEM(ICON_MeshEditZ, MSG_MESH_EDIT_Z, onDrawPFloat2Menu, SetEditZValue, &bedlevel.z_values[bedLevelTools.mesh_x][bedLevelTools.mesh_y]);
       }
       UpdateMenu(EditMeshMenu);
     }
   #endif
 
 #endif // HAS_MESH
 
 #endif // DWIN_LCD_PROUI

commit d123ea7346c4a72b08e82e7c876a97296d5c8090
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Nov 11 16:09:26 2022 -0600

    üé® Prefer axis element over index

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 06768ed18f..fcceb2d52d 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -2647,25 +2647,25 @@ void SetMaxSpeedZ() { HMI_value.axis = Z_AXIS, SetFloatOnClick(MIN_MAXFEEDSPEED,
 void ApplyMaxAccel() { planner.set_max_acceleration(HMI_value.axis, MenuData.Value); }
 void SetMaxAccelX() { HMI_value.axis = X_AXIS, SetIntOnClick(MIN_MAXACCELERATION, max_acceleration_edit_values[X_AXIS], planner.settings.max_acceleration_mm_per_s2[X_AXIS], ApplyMaxAccel); }
 void SetMaxAccelY() { HMI_value.axis = Y_AXIS, SetIntOnClick(MIN_MAXACCELERATION, max_acceleration_edit_values[Y_AXIS], planner.settings.max_acceleration_mm_per_s2[Y_AXIS], ApplyMaxAccel); }
 void SetMaxAccelZ() { HMI_value.axis = Z_AXIS, SetIntOnClick(MIN_MAXACCELERATION, max_acceleration_edit_values[Z_AXIS], planner.settings.max_acceleration_mm_per_s2[Z_AXIS], ApplyMaxAccel); }
 #if HAS_HOTEND
   void SetMaxAccelE() { HMI_value.axis = E_AXIS; SetIntOnClick(MIN_MAXACCELERATION, max_acceleration_edit_values[E_AXIS], planner.settings.max_acceleration_mm_per_s2[E_AXIS], ApplyMaxAccel); }
 #endif
 
 #if HAS_CLASSIC_JERK
   void ApplyMaxJerk() { planner.set_max_jerk(HMI_value.axis, MenuData.Value / MINUNITMULT); }
-  void SetMaxJerkX() { HMI_value.axis = X_AXIS, SetFloatOnClick(MIN_MAXJERK, max_jerk_edit_values[X_AXIS], UNITFDIGITS, planner.max_jerk[X_AXIS], ApplyMaxJerk); }
-  void SetMaxJerkY() { HMI_value.axis = Y_AXIS, SetFloatOnClick(MIN_MAXJERK, max_jerk_edit_values[Y_AXIS], UNITFDIGITS, planner.max_jerk[Y_AXIS], ApplyMaxJerk); }
-  void SetMaxJerkZ() { HMI_value.axis = Z_AXIS, SetFloatOnClick(MIN_MAXJERK, max_jerk_edit_values[Z_AXIS], UNITFDIGITS, planner.max_jerk[Z_AXIS], ApplyMaxJerk); }
+  void SetMaxJerkX() { HMI_value.axis = X_AXIS, SetFloatOnClick(MIN_MAXJERK, max_jerk_edit_values[X_AXIS], UNITFDIGITS, planner.max_jerk.x, ApplyMaxJerk); }
+  void SetMaxJerkY() { HMI_value.axis = Y_AXIS, SetFloatOnClick(MIN_MAXJERK, max_jerk_edit_values[Y_AXIS], UNITFDIGITS, planner.max_jerk.y, ApplyMaxJerk); }
+  void SetMaxJerkZ() { HMI_value.axis = Z_AXIS, SetFloatOnClick(MIN_MAXJERK, max_jerk_edit_values[Z_AXIS], UNITFDIGITS, planner.max_jerk.z, ApplyMaxJerk); }
   #if HAS_HOTEND
-    void SetMaxJerkE() { HMI_value.axis = E_AXIS; SetFloatOnClick(MIN_MAXJERK, max_jerk_edit_values[E_AXIS], UNITFDIGITS, planner.max_jerk[E_AXIS], ApplyMaxJerk); }
+    void SetMaxJerkE() { HMI_value.axis = E_AXIS; SetFloatOnClick(MIN_MAXJERK, max_jerk_edit_values[E_AXIS], UNITFDIGITS, planner.max_jerk.e, ApplyMaxJerk); }
   #endif
 #endif
 
 void SetStepsX() { HMI_value.axis = X_AXIS, SetPFloatOnClick( MIN_STEP, MAX_STEP, UNITFDIGITS); }
 void SetStepsY() { HMI_value.axis = Y_AXIS, SetPFloatOnClick( MIN_STEP, MAX_STEP, UNITFDIGITS); }
 void SetStepsZ() { HMI_value.axis = Z_AXIS, SetPFloatOnClick( MIN_STEP, MAX_STEP, UNITFDIGITS); }
 #if HAS_HOTEND
   void SetStepsE() { HMI_value.axis = E_AXIS; SetPFloatOnClick( MIN_STEP, MAX_STEP, UNITFDIGITS); }
   #if ENABLED(PIDTEMP)
     void SetHotendPidT() { SetPIntOnClick(MIN_ETEMP, MAX_ETEMP); }
@@ -3634,25 +3634,25 @@ void Draw_MaxAccel_Menu() {
 
 #if HAS_CLASSIC_JERK
   void Draw_MaxJerk_Menu() {
     checkkey = Menu;
     if (!MaxJerkMenu) MaxJerkMenu = new MenuClass();
     if (CurrentMenu != MaxJerkMenu) {
       CurrentMenu = MaxJerkMenu;
       SetMenuTitle({1, 16, 28, 13}, GET_TEXT_F(MSG_JERK));
       MenuItemsPrepare(5);
       BACK_ITEM(Draw_Motion_Menu);
-      EDIT_ITEM_F(ICON_MaxSpeedJerkX, MSG_VA_JERK, onDrawMaxJerkX, SetMaxJerkX, &planner.max_jerk[X_AXIS]);
-      EDIT_ITEM_F(ICON_MaxSpeedJerkY, MSG_VB_JERK, onDrawMaxJerkY, SetMaxJerkY, &planner.max_jerk[Y_AXIS]);
-      EDIT_ITEM_F(ICON_MaxSpeedJerkZ, MSG_VC_JERK, onDrawMaxJerkZ, SetMaxJerkZ, &planner.max_jerk[Z_AXIS]);
+      EDIT_ITEM_F(ICON_MaxSpeedJerkX, MSG_VA_JERK, onDrawMaxJerkX, SetMaxJerkX, &planner.max_jerk.x);
+      EDIT_ITEM_F(ICON_MaxSpeedJerkY, MSG_VB_JERK, onDrawMaxJerkY, SetMaxJerkY, &planner.max_jerk.y);
+      EDIT_ITEM_F(ICON_MaxSpeedJerkZ, MSG_VC_JERK, onDrawMaxJerkZ, SetMaxJerkZ, &planner.max_jerk.z);
       #if HAS_HOTEND
-        EDIT_ITEM_F(ICON_MaxSpeedJerkE, MSG_VE_JERK, onDrawMaxJerkE, SetMaxJerkE, &planner.max_jerk[E_AXIS]);
+        EDIT_ITEM_F(ICON_MaxSpeedJerkE, MSG_VE_JERK, onDrawMaxJerkE, SetMaxJerkE, &planner.max_jerk.e);
       #endif
     }
     CurrentMenu->draw();
   }
 #endif
 
 void Draw_Steps_Menu() {
   checkkey = Menu;
   if (!StepsMenu) StepsMenu = new MenuClass();
   if (CurrentMenu != StepsMenu) {

commit f595e40ceb0c79d7f0d6438636658dfcfa2a75b8
Author: EvilGremlin <22657714+EvilGremlin@users.noreply.github.com>
Date:   Sun Oct 9 18:30:47 2022 +0300

    ‚ôªÔ∏è Set Progress without LCD (#24767)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 09c3ca9ab8..06768ed18f 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -36,22 +36,22 @@
 #endif
 #if DISABLED(LIMITED_MAX_ACCEL_EDITING)
   #warning "LIMITED_MAX_ACCEL_EDITING is recommended with ProUI."
 #endif
 #if ENABLED(CLASSIC_JERK) && DISABLED(LIMITED_JERK_EDITING)
   #warning "LIMITED_JERK_EDITING is recommended with ProUI."
 #endif
 #if DISABLED(INDIVIDUAL_AXIS_HOMING_SUBMENU)
   #warning "INDIVIDUAL_AXIS_HOMING_SUBMENU is recommended with ProUI."
 #endif
-#if DISABLED(LCD_SET_PROGRESS_MANUALLY)
-  #warning "LCD_SET_PROGRESS_MANUALLY is recommended with ProUI."
+#if DISABLED(SET_PROGRESS_MANUALLY)
+  #warning "SET_PROGRESS_MANUALLY is recommended with ProUI."
 #endif
 #if DISABLED(STATUS_MESSAGE_SCROLLING)
   #warning "STATUS_MESSAGE_SCROLLING is recommended with ProUI."
 #endif
 #if DISABLED(BAUD_RATE_GCODE)
   #warning "BAUD_RATE_GCODE is recommended with ProUI."
 #endif
 #if DISABLED(SOUND_MENU_ITEM)
   #warning "SOUND_MENU_ITEM is recommended with ProUI."
 #endif

commit 094701cc71ccf1c6fcf3d768b9fcb227d0abf3b0
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Sun Sep 4 02:51:53 2022 +0200

    üêõ Fix / refactor shared PID (#24673)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index f51da4cf5a..09c3ca9ab8 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -2660,27 +2660,29 @@ void SetMaxAccelZ() { HMI_value.axis = Z_AXIS, SetIntOnClick(MIN_MAXACCELERATION
   #if HAS_HOTEND
     void SetMaxJerkE() { HMI_value.axis = E_AXIS; SetFloatOnClick(MIN_MAXJERK, max_jerk_edit_values[E_AXIS], UNITFDIGITS, planner.max_jerk[E_AXIS], ApplyMaxJerk); }
   #endif
 #endif
 
 void SetStepsX() { HMI_value.axis = X_AXIS, SetPFloatOnClick( MIN_STEP, MAX_STEP, UNITFDIGITS); }
 void SetStepsY() { HMI_value.axis = Y_AXIS, SetPFloatOnClick( MIN_STEP, MAX_STEP, UNITFDIGITS); }
 void SetStepsZ() { HMI_value.axis = Z_AXIS, SetPFloatOnClick( MIN_STEP, MAX_STEP, UNITFDIGITS); }
 #if HAS_HOTEND
   void SetStepsE() { HMI_value.axis = E_AXIS; SetPFloatOnClick( MIN_STEP, MAX_STEP, UNITFDIGITS); }
-  void SetHotendPidT() { SetPIntOnClick(MIN_ETEMP, MAX_ETEMP); }
+  #if ENABLED(PIDTEMP)
+    void SetHotendPidT() { SetPIntOnClick(MIN_ETEMP, MAX_ETEMP); }
+  #endif
 #endif
-#if HAS_HEATED_BED
+#if ENABLED(PIDTEMPBED)
   void SetBedPidT() { SetPIntOnClick(MIN_BEDTEMP, MAX_BEDTEMP); }
 #endif
 
-#if HAS_HOTEND || HAS_HEATED_BED
+#if EITHER(PIDTEMP, PIDTEMPBED)
   void SetPidCycles() { SetPIntOnClick(3, 50); }
   void SetKp() { SetPFloatOnClick(0, 1000, 2); }
   void ApplyPIDi() {
     *MenuData.P_Float = scalePID_i(MenuData.Value / POW(10, 2));
     thermalManager.updatePID();
   }
   void ApplyPIDd() {
     *MenuData.P_Float = scalePID_d(MenuData.Value / POW(10, 2));
     thermalManager.updatePID();
   }
@@ -3215,24 +3217,24 @@ void Draw_AdvancedSettings_Menu() {
     #endif
     #if HAS_BED_PROBE
       MENU_ITEM_F(ICON_ProbeSet, MSG_ZPROBE_SETTINGS, onDrawSubMenu, Draw_ProbeSet_Menu);
     #endif
     #if HAS_MESH
       MENU_ITEM_F(ICON_ProbeSet, MSG_MESH_LEVELING, onDrawSubMenu, Draw_MeshSet_Menu);
     #endif
     #if HAS_HOME_OFFSET
       MENU_ITEM_F(ICON_HomeOffset, MSG_SET_HOME_OFFSETS, onDrawSubMenu, Draw_HomeOffset_Menu);
     #endif
-    #if HAS_HOTEND
+    #if ENABLED(PIDTEMP)
       MENU_ITEM(ICON_PIDNozzle, F(STR_HOTEND_PID " Settings"), onDrawSubMenu, Draw_HotendPID_Menu);
     #endif
-    #if HAS_HEATED_BED
+    #if ENABLED(PIDTEMPBED)
       MENU_ITEM(ICON_PIDbed, F(STR_BED_PID " Settings"), onDrawSubMenu, Draw_BedPID_Menu);
     #endif
       MENU_ITEM_F(ICON_FilSet, MSG_FILAMENT_SET, onDrawSubMenu, Draw_FilSet_Menu);
     #if ENABLED(POWER_LOSS_RECOVERY)
       EDIT_ITEM_F(ICON_Pwrlossr, MSG_OUTAGE_RECOVERY, onDrawChkbMenu, SetPwrLossr, &recovery.enabled);
     #endif
     #if ENABLED(BAUD_RATE_GCODE)
       EDIT_ITEM(ICON_SetBaudRate, F("115K baud"), onDrawChkbMenu, SetBaudRate, &HMI_data.Baud115K);
     #endif
     #if HAS_LCD_BRIGHTNESS
@@ -3661,43 +3663,43 @@ void Draw_Steps_Menu() {
     EDIT_ITEM_F(ICON_StepX, MSG_A_STEPS, onDrawStepsX, SetStepsX, &planner.settings.axis_steps_per_mm[X_AXIS]);
     EDIT_ITEM_F(ICON_StepY, MSG_B_STEPS, onDrawStepsY, SetStepsY, &planner.settings.axis_steps_per_mm[Y_AXIS]);
     EDIT_ITEM_F(ICON_StepZ, MSG_C_STEPS, onDrawStepsZ, SetStepsZ, &planner.settings.axis_steps_per_mm[Z_AXIS]);
     #if HAS_HOTEND
       EDIT_ITEM_F(ICON_StepE, MSG_E_STEPS, onDrawStepsE, SetStepsE, &planner.settings.axis_steps_per_mm[E_AXIS]);
     #endif
   }
   CurrentMenu->draw();
 }
 
-#if HAS_HOTEND
+#if ENABLED(PIDTEMP)
   void Draw_HotendPID_Menu() {
     checkkey = Menu;
-    if (SetMenu(HotendPIDMenu, F(STR_HOTEND_PID " Settings"),8)) {
+    if (SetMenu(HotendPIDMenu, F(STR_HOTEND_PID " Settings"), 8)) {
       BACK_ITEM(Draw_AdvancedSettings_Menu);
       MENU_ITEM(ICON_PIDNozzle, F(STR_HOTEND_PID), onDrawMenuItem, HotendPID);
       EDIT_ITEM(ICON_PIDValue, F("Set" STR_KP), onDrawPFloat2Menu, SetKp, &thermalManager.temp_hotend[0].pid.Kp);
       EDIT_ITEM(ICON_PIDValue, F("Set" STR_KI), onDrawPIDi, SetKi, &thermalManager.temp_hotend[0].pid.Ki);
       EDIT_ITEM(ICON_PIDValue, F("Set" STR_KD), onDrawPIDd, SetKd, &thermalManager.temp_hotend[0].pid.Kd);
       EDIT_ITEM_F(ICON_Temperature, MSG_TEMPERATURE, onDrawPIntMenu, SetHotendPidT, &HMI_data.HotendPidT);
       EDIT_ITEM_F(ICON_PIDcycles, MSG_PID_CYCLE, onDrawPIntMenu, SetPidCycles, &HMI_data.PidCycles);
       #if ENABLED(EEPROM_SETTINGS)
         MENU_ITEM_F(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawMenuItem, WriteEeprom);
       #endif
     }
     UpdateMenu(HotendPIDMenu);
   }
 #endif
 
-#if HAS_HEATED_BED
+#if ENABLED(PIDTEMPBED)
   void Draw_BedPID_Menu() {
     checkkey = Menu;
-    if (SetMenu(BedPIDMenu, F(STR_BED_PID " Settings"),8)) {
+    if (SetMenu(BedPIDMenu, F(STR_BED_PID " Settings"), 8)) {
       BACK_ITEM(Draw_AdvancedSettings_Menu);
       MENU_ITEM(ICON_PIDNozzle, F(STR_BED_PID), onDrawMenuItem,BedPID);
       EDIT_ITEM(ICON_PIDValue, F("Set" STR_KP), onDrawPFloat2Menu, SetKp, &thermalManager.temp_bed.pid.Kp);
       EDIT_ITEM(ICON_PIDValue, F("Set" STR_KI), onDrawPIDi, SetKi, &thermalManager.temp_bed.pid.Ki);
       EDIT_ITEM(ICON_PIDValue, F("Set" STR_KD), onDrawPIDd, SetKd, &thermalManager.temp_bed.pid.Kd);
       EDIT_ITEM_F(ICON_Temperature, MSG_TEMPERATURE, onDrawPIntMenu, SetBedPidT, &HMI_data.BedPidT);
       EDIT_ITEM_F(ICON_PIDcycles, MSG_PID_CYCLE, onDrawPIntMenu, SetPidCycles, &HMI_data.PidCycles);
       #if ENABLED(EEPROM_SETTINGS)
         MENU_ITEM_F(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawMenuItem, WriteEeprom);
       #endif

commit 6d83f7a579e3d21a881e0c2a7d893598270a72f1
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Sun Jul 17 21:33:23 2022 -0700

    ü©π Fix ProUI + Leveling compile (#24508)

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 111af5acd7..f51da4cf5a 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -92,21 +92,21 @@
 #endif
 
 #if ENABLED(HOST_ACTION_COMMANDS)
   #include "../../../feature/host_actions.h"
 #endif
 
 #if DISABLED(PROBE_MANUALLY) && ANY(AUTO_BED_LEVELING_BILINEAR, AUTO_BED_LEVELING_LINEAR, AUTO_BED_LEVELING_3POINT)
   #define HAS_ONESTEP_LEVELING 1
 #endif
 
-#if HAS_MESH || HAS_ONESTEP_LEVELING
+#if HAS_MESH || (HAS_LEVELING && HAS_ZOFFSET_ITEM)
   #include "../../../feature/bedlevel/bedlevel.h"
   #include "bedlevel_tools.h"
 #endif
 
 #if HAS_BED_PROBE
   #include "../../../module/probe.h"
 #endif
 
 #if ENABLED(BLTOUCH)
   #include "../../../feature/bltouch.h"
@@ -2131,21 +2131,21 @@ void HomeZ() { queue.inject(F("G28Z")); }
 
   void SetMoveZto0() {
     #if ENABLED(Z_SAFE_HOMING)
       char cmd[54], str_1[5], str_2[5];
       sprintf_P(cmd, PSTR("G28XYO\nG28Z\nG0X%sY%sF5000\nG0Z0F300\nM400"),
         dtostrf(Z_SAFE_HOMING_X_POINT, 1, 1, str_1),
         dtostrf(Z_SAFE_HOMING_Y_POINT, 1, 1, str_2)
       );
       gcode.process_subcommands_now(cmd);
     #else
-      set_bed_leveling_enabled(false);
+      TERN_(HAS_LEVELING, set_bed_leveling_enabled(false));
       gcode.process_subcommands_now(F("G28O\nG0Z0F300\nM400"));
     #endif
     ui.reset_status();
     DONE_BUZZ(true);
   }
 
   #if !HAS_BED_PROBE
     void HomeZandDisable() {
       SetMoveZto0();
       DisableMotors();
@@ -3818,20 +3818,21 @@ void Draw_Steps_Menu() {
   }
 
   void UBLLoadMesh() {
     if (bedlevel.storage_slot < 0) bedlevel.storage_slot = 0;
     settings.load_mesh(bedlevel.storage_slot);
   }
 
 #endif // AUTO_BED_LEVELING_UBL
 
 #if HAS_MESH
+
   void Draw_MeshSet_Menu() {
     checkkey = Menu;
     if (SetMenu(MeshMenu, GET_TEXT_F(MSG_MESH_LEVELING), 15)) {
       BACK_ITEM(Draw_AdvancedSettings_Menu);
       #if BOTH(HAS_HEATED_BED, PREHEAT_BEFORE_LEVELING)
         EDIT_ITEM_F(ICON_Temperature, MSG_UBL_SET_TEMP_BED, onDrawPIntMenu, SetBedLevT, &HMI_data.BedLevT);
       #endif
       EDIT_ITEM_F(ICON_SetZOffset, MSG_Z_FADE_HEIGHT, onDrawPFloatMenu, SetMeshFadeHeight, &planner.z_fade_height);
       EDIT_ITEM_F(ICON_UBLActive, MSG_ACTIVATE_MESH, onDrawChkbMenu, SetMeshActive, &planner.leveling_active);
       #if HAS_BED_PROBE

commit 9be1de54ae11b20cc3f47008080bc4afb80369c5
Author: GHGiampy <83699429+GHGiampy@users.noreply.github.com>
Date:   Sat Jul 16 03:14:15 2022 +0200

    ü©π Add'l ProUI fixes (#24500)

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 762a4fb627..111af5acd7 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -1818,21 +1818,21 @@ void DWIN_SetDataDefaults() {
   TERN_(HAS_HOTEND,     HMI_data.PidCycles  = 5);
   #if ENABLED(PREVENT_COLD_EXTRUSION)
     HMI_data.ExtMinT = EXTRUDE_MINTEMP;
     ApplyExtMinT();
   #endif
   #if BOTH(HAS_HEATED_BED, PREHEAT_BEFORE_LEVELING)
     HMI_data.BedLevT = LEVELING_BED_TEMP;
   #endif
   TERN_(BAUD_RATE_GCODE, SetBaud250K());
   #if BOTH(LED_CONTROL_MENU, HAS_COLOR_LEDS)
-    leds.set_default();
+    TERN_(LED_COLOR_PRESETS, leds.set_default());
     ApplyLEDColor();
   #endif
 }
 
 void DWIN_CopySettingsTo(char * const buff) {
   memcpy(buff, &HMI_data, eeprom_data_size);
 }
 
 void DWIN_CopySettingsFrom(const char * const buff) {
   memcpy(&HMI_data, buff, sizeof(HMI_data_t));
@@ -2219,24 +2219,23 @@ void SetPID(celsius_t t, heater_id_t h) {
 
 #if ENABLED(POWER_LOSS_RECOVERY)
   void SetPwrLossr() {
     recovery.enable(!recovery.enabled);
     Draw_Chkb_Line(CurrentMenu->line(), recovery.enabled);
     DWIN_UpdateLCD();
   }
 #endif
 
 #if ENABLED(BAUD_RATE_GCODE)
-  void HMI_SetBaudRate() {
-    if (HMI_data.Baud115K) SetBaud115K(); else SetBaud250K();
-  }
+  void HMI_SetBaudRate() { HMI_data.Baud115K ? SetBaud115K() : SetBaud250K(); }
   void SetBaudRate() {
+    HMI_data.Baud115K ^= true;
     HMI_SetBaudRate();
     Draw_Chkb_Line(CurrentMenu->line(), HMI_data.Baud115K);
     DWIN_UpdateLCD();
   }
   void SetBaud115K() { queue.inject(F("M575 P0 B115200")); HMI_data.Baud115K = true; }
   void SetBaud250K() { queue.inject(F("M575 P0 B250000")); HMI_data.Baud115K = false; }
 #endif
 
 #if HAS_LCD_BRIGHTNESS
   void ApplyBrightness() { ui.set_brightness(MenuData.Value); }
@@ -2261,23 +2260,21 @@ void SetPID(celsius_t t, heater_id_t h) {
 #if ENABLED(LED_CONTROL_MENU)
   #if !BOTH(CASE_LIGHT_MENU, CASE_LIGHT_USE_NEOPIXEL)
     void SetLedStatus() {
       leds.toggle();
       Draw_Chkb_Line(CurrentMenu->line(), leds.lights_on);
       DWIN_UpdateLCD();
     }
   #endif
   #if HAS_COLOR_LEDS
     void ApplyLEDColor() {
-      HMI_data.Led_Color = LEDColor(
-        TERN(HAS_WHITE_LED, { 0, 0, 0, leds.color.w }, { leds.color.r, leds.color.g, leds.color.b })
-      );
+      HMI_data.Led_Color = LEDColor( {leds.color.r, leds.color.g, leds.color.b OPTARG(HAS_WHITE_LED, HMI_data.Led_Color.w) } );
     }
     void LiveLEDColor(uint8_t *color) { *color = MenuData.Value; leds.update(); }
     void LiveLEDColorR() { LiveLEDColor(&leds.color.r); }
     void LiveLEDColorG() { LiveLEDColor(&leds.color.g); }
     void LiveLEDColorB() { LiveLEDColor(&leds.color.b); }
     void SetLEDColorR() { SetIntOnClick(0, 255, leds.color.r, ApplyLEDColor, LiveLEDColorR); }
     void SetLEDColorG() { SetIntOnClick(0, 255, leds.color.g, ApplyLEDColor, LiveLEDColorG); }
     void SetLEDColorB() { SetIntOnClick(0, 255, leds.color.b, ApplyLEDColor, LiveLEDColorB); }
     #if HAS_WHITE_LED
       void LiveLEDColorW() { LiveLEDColor(&leds.color.w); }
@@ -3408,21 +3405,21 @@ void Draw_GetColor_Menu() {
           MENU_ITEM_F(ICON_LedControl, MSG_SET_LEDS_YELLOW, onDrawMenuItem, leds.set_yellow);
           MENU_ITEM_F(ICON_LedControl, MSG_SET_LEDS_GREEN, onDrawMenuItem,  leds.set_green);
           MENU_ITEM_F(ICON_LedControl, MSG_SET_LEDS_BLUE, onDrawMenuItem,   leds.set_blue);
           MENU_ITEM_F(ICON_LedControl, MSG_SET_LEDS_INDIGO, onDrawMenuItem, leds.set_indigo);
           MENU_ITEM_F(ICON_LedControl, MSG_SET_LEDS_VIOLET, onDrawMenuItem, leds.set_violet);
         #else
           EDIT_ITEM_F(ICON_LedControl, MSG_COLORS_RED, onDrawPInt8Menu, SetLEDColorR, &leds.color.r);
           EDIT_ITEM_F(ICON_LedControl, MSG_COLORS_GREEN, onDrawPInt8Menu, SetLEDColorG, &leds.color.g);
           EDIT_ITEM_F(ICON_LedControl, MSG_COLORS_BLUE, onDrawPInt8Menu, SetLEDColorB, &leds.color.b);
           #if ENABLED(HAS_WHITE_LED)
-            EDIT_ITEM_F(ICON_LedControl, MSG_COLORS_WHITE, onDrawPInt8Menu, SetLedColorW, &leds.color.w);
+            EDIT_ITEM_F(ICON_LedControl, MSG_COLORS_WHITE, onDrawPInt8Menu, SetLEDColorW, &leds.color.w);
           #endif
         #endif
       #endif
     }
     UpdateMenu(LedControlMenu);
   }
 #endif
 
 void Draw_Tune_Menu() {
   checkkey = Menu;

commit 30ec700a1d22d586d00688a7b94fd84e2a32c929
Author: GHGiampy <83699429+GHGiampy@users.noreply.github.com>
Date:   Thu Jul 14 07:03:27 2022 +0200

    ü©π Fix ProUI LED compile (#24473)

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 27e1003ab6..762a4fb627 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -1836,24 +1836,24 @@ void DWIN_CopySettingsTo(char * const buff) {
 
 void DWIN_CopySettingsFrom(const char * const buff) {
   memcpy(&HMI_data, buff, sizeof(HMI_data_t));
   if (HMI_data.Text_Color == HMI_data.Background_Color) DWIN_SetColorDefaults();
   DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color, HMI_data.StatusBg_Color);
   TERN_(PREVENT_COLD_EXTRUSION, ApplyExtMinT());
   feedrate_percentage = 100;
   TERN_(BAUD_RATE_GCODE, HMI_SetBaudRate());
   #if BOTH(LED_CONTROL_MENU, HAS_COLOR_LEDS)
     leds.set_color(
-      (HMI_data.LED_Color >> 16) & 0xFF,
-      (HMI_data.LED_Color >>  8) & 0xFF,
-      (HMI_data.LED_Color >>  0) & 0xFF
-      OPTARG(HAS_WHITE_LED, (HMI_data.LED_Color >> 24) & 0xFF)
+      HMI_data.Led_Color.r,
+      HMI_data.Led_Color.g,
+      HMI_data.Led_Color.b
+      OPTARG(HAS_WHITE_LED, HMI_data.Led_Color.w)
     );
     leds.update();
   #endif
 
 }
 
 // Initialize or re-initialize the LCD
 void MarlinUI::init_lcd() {
   TERN_(DEBUG_DWIN, SERIAL_ECHOLNPGM("DWIN_Startup"));
   DWINUI::init();
@@ -2260,21 +2260,25 @@ void SetPID(celsius_t t, heater_id_t h) {
 
 #if ENABLED(LED_CONTROL_MENU)
   #if !BOTH(CASE_LIGHT_MENU, CASE_LIGHT_USE_NEOPIXEL)
     void SetLedStatus() {
       leds.toggle();
       Draw_Chkb_Line(CurrentMenu->line(), leds.lights_on);
       DWIN_UpdateLCD();
     }
   #endif
   #if HAS_COLOR_LEDS
-    void ApplyLEDColor() { HMI_data.LED_Color = TERN0(HAS_WHITE_LED, (leds.color.w << 24)) | (leds.color.r << 16) | (leds.color.g << 8) | leds.color.b; }
+    void ApplyLEDColor() {
+      HMI_data.Led_Color = LEDColor(
+        TERN(HAS_WHITE_LED, { 0, 0, 0, leds.color.w }, { leds.color.r, leds.color.g, leds.color.b })
+      );
+    }
     void LiveLEDColor(uint8_t *color) { *color = MenuData.Value; leds.update(); }
     void LiveLEDColorR() { LiveLEDColor(&leds.color.r); }
     void LiveLEDColorG() { LiveLEDColor(&leds.color.g); }
     void LiveLEDColorB() { LiveLEDColor(&leds.color.b); }
     void SetLEDColorR() { SetIntOnClick(0, 255, leds.color.r, ApplyLEDColor, LiveLEDColorR); }
     void SetLEDColorG() { SetIntOnClick(0, 255, leds.color.g, ApplyLEDColor, LiveLEDColorG); }
     void SetLEDColorB() { SetIntOnClick(0, 255, leds.color.b, ApplyLEDColor, LiveLEDColorB); }
     #if HAS_WHITE_LED
       void LiveLEDColorW() { LiveLEDColor(&leds.color.w); }
       void SetLEDColorW() { SetIntOnClick(0, 255, leds.color.w, ApplyLEDColor, LiveLEDColorW); }

commit 8fb54d4621c5f571d613fca2943393d4a95cb8e4
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Thu Jul 14 00:00:33 2022 -0500

    üö∏ Fix and update ProUI (#24477)

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 07b134471b..27e1003ab6 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -94,31 +94,32 @@
 #if ENABLED(HOST_ACTION_COMMANDS)
   #include "../../../feature/host_actions.h"
 #endif
 
 #if DISABLED(PROBE_MANUALLY) && ANY(AUTO_BED_LEVELING_BILINEAR, AUTO_BED_LEVELING_LINEAR, AUTO_BED_LEVELING_3POINT)
   #define HAS_ONESTEP_LEVELING 1
 #endif
 
 #if HAS_MESH || HAS_ONESTEP_LEVELING
   #include "../../../feature/bedlevel/bedlevel.h"
+  #include "bedlevel_tools.h"
 #endif
 
 #if HAS_BED_PROBE
   #include "../../../module/probe.h"
 #endif
 
-#ifdef BLTOUCH_HS_MODE
+#if ENABLED(BLTOUCH)
   #include "../../../feature/bltouch.h"
 #endif
 
-#if ANY(BABYSTEPPING, HAS_BED_PROBE, HAS_WORKSPACE_OFFSET)
+#if EITHER(BABYSTEPPING, HAS_BED_PROBE)
   #define HAS_ZOFFSET_ITEM 1
   #if ENABLED(BABYSTEPPING)
     #include "../../../feature/babystep.h"
     #if !HAS_BED_PROBE
       #define JUST_BABYSTEP 1
     #endif
   #endif
 #endif
 
 #if ENABLED(POWER_LOSS_RECOVERY)
@@ -134,46 +135,40 @@
 #endif
 
 #if HAS_GCODE_PREVIEW
   #include "gcode_preview.h"
 #endif
 
 #if HAS_MESH
   #include "meshviewer.h"
 #endif
 
-#if ENABLED(AUTO_BED_LEVELING_UBL)
-  #include "ubl_tools.h"
-#endif
-
 #if ENABLED(PRINTCOUNTER)
   #include "printstats.h"
 #endif
 
 #if ENABLED(CASE_LIGHT_MENU)
   #include "../../../feature/caselight.h"
 #endif
 
 #if ENABLED(LED_CONTROL_MENU)
   #include "../../../feature/leds/leds.h"
 #endif
 
-#include <WString.h>
-#include <stdio.h>
-#include <string.h>
+#if HAS_LOCKSCREEN
+  #include "lockscreen.h"
+#endif
 
 #ifndef MACHINE_SIZE
   #define MACHINE_SIZE STRINGIFY(X_BED_SIZE) "x" STRINGIFY(Y_BED_SIZE) "x" STRINGIFY(Z_MAX_POS)
 #endif
 
-#include "lockscreen.h"
-
 #define PAUSE_HEAT
 
 #define MENU_CHAR_LIMIT  24
 
 // Print speed limit
 #define MIN_PRINT_SPEED  10
 #define MAX_PRINT_SPEED 999
 
 // Print flow limit
 #define MIN_PRINT_FLOW   10
@@ -244,27 +239,29 @@ uint8_t index_file     = MROWS;
 
 bool hash_changed = true; // Flag to know if message status was changed
 
 constexpr float max_feedrate_edit_values[] =
   #ifdef MAX_FEEDRATE_EDIT_VALUES
     MAX_FEEDRATE_EDIT_VALUES
   #else
     { 1000, 1000, 10, 50 }
   #endif
 ;
+
 constexpr float max_acceleration_edit_values[] =
   #ifdef MAX_ACCEL_EDIT_VALUES
     MAX_ACCEL_EDIT_VALUES
   #else
     { 1000, 1000, 200, 2000 }
   #endif
 ;
+
 #if HAS_CLASSIC_JERK
   constexpr float max_jerk_edit_values[] =
     #ifdef MAX_JERK_EDIT_VALUES
       MAX_JERK_EDIT_VALUES
     #else
       { DEFAULT_XJERK * 2, DEFAULT_YJERK * 2, DEFAULT_ZJERK * 2, DEFAULT_EJERK * 2 }
     #endif
   ;
 #endif
 
@@ -298,21 +295,23 @@ MenuClass *MotionMenu = nullptr;
 MenuClass *FilamentMenu = nullptr;
 #if ENABLED(MESH_BED_LEVELING)
   MenuClass *ManualMesh = nullptr;
 #endif
 #if HAS_HOTEND
   MenuClass *PreheatMenu = nullptr;
 #endif
 MenuClass *TemperatureMenu = nullptr;
 MenuClass *MaxSpeedMenu = nullptr;
 MenuClass *MaxAccelMenu = nullptr;
-MenuClass *MaxJerkMenu = nullptr;
+#if HAS_CLASSIC_JERK
+  MenuClass *MaxJerkMenu = nullptr;
+#endif
 MenuClass *StepsMenu = nullptr;
 MenuClass *HotendPIDMenu = nullptr;
 MenuClass *BedPIDMenu = nullptr;
 #if ENABLED(CASELIGHT_USES_BRIGHTNESS)
   MenuClass *CaseLightMenu = nullptr;
 #endif
 #if ENABLED(LED_CONTROL_MENU)
   MenuClass *LedControlMenu = nullptr;
 #endif
 #if HAS_BED_PROBE
@@ -545,28 +544,23 @@ void Popup_window_PauseOrStop() {
         DWINUI::Draw_Icon(ICON_TempTooLow, 102, 165);
         DWIN_Frame_AreaCopy(1, 103, 371, 270, 386, 52, 285);
         DWIN_Frame_AreaCopy(1, 189, 389, 271, 402, 95, 310);
       }
     }
     else DWIN_Show_Popup(toohigh ? ICON_TempTooHigh : ICON_TempTooLow, F("Nozzle or Bed temperature"), toohigh ? F("is too high") : F("is too low"), BTN_Continue);
   }
 #endif
 
 // Draw status line
-void DWIN_DrawStatusLine(const char *text) {
-  DWIN_Draw_Rectangle(1, HMI_data.StatusBg_Color, 0, STATUS_Y, DWIN_WIDTH, STATUS_Y + 20);
-  if (text) DWINUI::Draw_CenteredString(HMI_data.StatusTxt_Color, STATUS_Y + 2, text);
-}
-
-void DWIN_DrawStatusLine(FSTR_P fstr) {
+void DWIN_DrawStatusLine() {
   DWIN_Draw_Rectangle(1, HMI_data.StatusBg_Color, 0, STATUS_Y, DWIN_WIDTH, STATUS_Y + 20);
-  if (fstr) DWINUI::Draw_CenteredString(HMI_data.StatusTxt_Color, STATUS_Y + 2, fstr);
+  DWINUI::Draw_CenteredString(HMI_data.StatusTxt_Color, STATUS_Y + 2, ui.status_message);
 }
 
 // Clear & reset status line
 void DWIN_ResetStatusLine() {
   ui.status_message[0] = 0;
   DWIN_CheckStatusMessage();
 }
 
 // Djb2 hash algorithm
 void DWIN_CheckStatusMessage() {
@@ -581,21 +575,21 @@ void DWIN_CheckStatusMessage() {
 
 void DWIN_DrawStatusMessage() {
   #if ENABLED(STATUS_MESSAGE_SCROLLING)
 
     // Get the UTF8 character count of the string
     uint8_t slen = utf8_strlen(ui.status_message);
 
     // If the string fits the status line do not scroll it
     if (slen <= LCD_WIDTH) {
        if (hash_changed) {
-         DWIN_DrawStatusLine(ui.status_message);
+         DWIN_DrawStatusLine();
          hash_changed = false;
        }
     }
     else {
       // String is larger than the available line space
 
       // Get a pointer to the next valid UTF8 character
       // and the string remaining length
       uint8_t rlen;
       const char *stat = MarlinUI::status_and_len(rlen);
@@ -613,21 +607,21 @@ void DWIN_DrawStatusMessage() {
             DWINUI::Draw_String(HMI_data.StatusTxt_Color, ui.status_message, chars); // Print a second copy of the message
         }
       }
       MarlinUI::advance_status_scroll();
     }
 
   #else
 
     if (hash_changed) {
       ui.status_message[LCD_WIDTH] = 0;
-      DWIN_DrawStatusLine(ui.status_message);
+      DWIN_DrawStatusLine();
       hash_changed = false;
     }
 
   #endif
 }
 
 void Draw_Print_Labels() {
   if (HMI_IsChinese()) {
     DWIN_Frame_AreaCopy(1,  0, 72,  63, 86,  41, 173);  // Printing Time
     DWIN_Frame_AreaCopy(1, 65, 72, 128, 86, 176, 173);  // Remain
@@ -656,21 +650,21 @@ void Draw_Print_ProgressRemain() {
   char buf[10];
   sprintf_P(buf, PSTR("%02i:%02i "), (uint16_t)(_remain_time / 3600), ((uint16_t)_remain_time % 3600) / 60);
   DWINUI::Draw_String(HMI_data.Text_Color, HMI_data.Background_Color, 181, 192, buf);
 }
 
 void ICON_ResumeOrPause() {
   if (checkkey == PrintProcess) printingIsPaused() ? ICON_Resume() : ICON_Pause();
 }
 
 // Update filename on print
-void DWIN_Print_Header(const char *text = nullptr) {
+void DWIN_Print_Header(const char *text=nullptr) {
   static char headertxt[31] = "";  // Print header text
   if (text) {
     const int8_t size = _MIN(30U, strlen_P(text));
     LOOP_L_N(i, size) headertxt[i] = text[i];
     headertxt[size] = '\0';
   }
   if (checkkey == PrintProcess || checkkey == PrintDone) {
     DWIN_Draw_Rectangle(1, HMI_data.Background_Color, 0, 60, DWIN_WIDTH, 60+16);
     DWINUI::Draw_CenteredString(60, headertxt);
   }
@@ -1092,21 +1086,21 @@ void DWIN_Draw_Dashboard() {
 
   DWINUI::Draw_Icon(ICON_Speed, 113, 383);
   DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 116 + 2 * STAT_CHR_W, 384, feedrate_percentage);
   DWINUI::Draw_String(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 116 + 5 * STAT_CHR_W + 2, 384, F("%"));
 
   #if HAS_FAN
     DWINUI::Draw_Icon(ICON_FanSpeed, 187, 383);
     DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 195 + 2 * STAT_CHR_W, 384, thermalManager.fan_speed[0]);
   #endif
 
-  #if BOTH(BABYSTEPPING, HAS_BED_PROBE)
+  #if HAS_ZOFFSET_ITEM
     DWINUI::Draw_Icon(planner.leveling_active ? ICON_SetZOffset : ICON_Zoffset, 187, 416);
   #endif
 
   DWINUI::Draw_Signed_Float(DWIN_FONT_STAT, HMI_data.Indicator_Color,  HMI_data.Background_Color, 2, 2, 204, 417, BABY_Z_VAR);
 
   DWIN_Draw_Rectangle(1, HMI_data.SplitLine_Color, 0, 449, DWIN_WIDTH, 451);
 
   DWINUI::Draw_Icon(ICON_MaxSpeedX,  10, 456);
   DWINUI::Draw_Icon(ICON_MaxSpeedY,  95, 456);
   DWINUI::Draw_Icon(ICON_MaxSpeedZ, 180, 456);
@@ -1363,27 +1357,29 @@ void HMI_Printing() {
 void Draw_Main_Area() {
   switch (checkkey) {
     case MainMenu:               Draw_Main_Menu(); break;
     case SelectFile:             Draw_Print_File_Menu(); break;
     case PrintProcess:           Draw_PrintProcess(); break;
     case PrintDone:              Draw_PrintDone(); break;
     #if HAS_ESDIAG
       case ESDiagProcess:        Draw_EndStopDiag(); break;
     #endif
     case Popup:                  popupDraw(); break;
-    case Locked:                 lockScreen.draw(); break;
+    #if HAS_LOCKSCREEN
+      case Locked:               lockScreen.draw(); break;
+    #endif
     case Menu:
     case SetInt:
     case SetPInt:
     case SetIntNoDraw:
     case SetFloat:
-    case SetPFloat:              ReDrawMenu(); break;
+    case SetPFloat:              ReDrawMenu(true); break;
     default: break;
   }
 }
 
 void HMI_ReturnScreen() {
   checkkey = last_checkkey;
   wait_for_user = false;
   Draw_Main_Area();
 }
 
@@ -1560,21 +1556,23 @@ void DWIN_HandleScreen() {
     case Menu:            HMI_Menu(); break;
     case SetInt:          HMI_SetInt(); break;
     case SetPInt:         HMI_SetPInt(); break;
     case SetIntNoDraw:    HMI_SetIntNoDraw(); break;
     case SetFloat:        HMI_SetFloat(); break;
     case SetPFloat:       HMI_SetPFloat(); break;
     case SelectFile:      HMI_SelectFile(); break;
     case PrintProcess:    HMI_Printing(); break;
     case Popup:           HMI_Popup(); break;
     case Leveling:        break;
-    case Locked:          HMI_LockScreen(); break;
+    #if HAS_LOCKSCREEN
+      case Locked:        HMI_LockScreen(); break;
+    #endif
     case PrintDone:
     TERN_(HAS_ESDIAG, case ESDiagProcess:)
     case WaitResponse:    HMI_WaitForUser(); break;
     case Homing:
     case PidProcess:
     case NothingToDo:     break;
     default: break;
   }
 }
 
@@ -1762,21 +1760,21 @@ void DWIN_Print_Finished() {
 // Print was aborted
 void DWIN_Print_Aborted() {
   TERN_(DEBUG_DWIN, SERIAL_ECHOLNPGM("DWIN_Print_Aborted"));
   HMI_flag.abort_action = false;
   wait_for_heatup = false;
   planner.finish_and_disable();
   thermalManager.cooldown();
   Goto_PrintDone();
 }
 
-// Progress Bar update
+// Progress and remaining time update
 void DWIN_M73() {
   if (parser.seenval('P')) {
     _percent_done = parser.value_byte();
     HMI_flag.percent_flag = true;
   }
   if (parser.seenval('R')) {
     _remain_time = parser.value_ulong() * 60;
     HMI_flag.remain_flag = true;
   }
   if (checkkey == PrintProcess) {
@@ -1836,25 +1834,20 @@ void DWIN_CopySettingsTo(char * const buff) {
   memcpy(buff, &HMI_data, eeprom_data_size);
 }
 
 void DWIN_CopySettingsFrom(const char * const buff) {
   memcpy(&HMI_data, buff, sizeof(HMI_data_t));
   if (HMI_data.Text_Color == HMI_data.Background_Color) DWIN_SetColorDefaults();
   DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color, HMI_data.StatusBg_Color);
   TERN_(PREVENT_COLD_EXTRUSION, ApplyExtMinT());
   feedrate_percentage = 100;
   TERN_(BAUD_RATE_GCODE, HMI_SetBaudRate());
-  #if BOTH(CASE_LIGHT_MENU, CASELIGHT_USES_BRIGHTNESS)
-    // Apply Case light brightness
-    caselight.brightness = HMI_data.CaseLight_Brightness;
-    caselight.update_brightness();
-  #endif
   #if BOTH(LED_CONTROL_MENU, HAS_COLOR_LEDS)
     leds.set_color(
       (HMI_data.LED_Color >> 16) & 0xFF,
       (HMI_data.LED_Color >>  8) & 0xFF,
       (HMI_data.LED_Color >>  0) & 0xFF
       OPTARG(HAS_WHITE_LED, (HMI_data.LED_Color >> 24) & 0xFF)
     );
     leds.update();
   #endif
 
@@ -1873,21 +1866,21 @@ void DWIN_InitScreen() {
   onCursorDraw = Draw_Menu_Cursor;
   onCursorErase = Erase_Menu_Cursor;
   DWINUI::onTitleDraw = Draw_Title;
   onMenuDraw = Draw_Menu;
   checkkey = 255;
   CurrentMenu = nullptr;
   PreviousMenu = nullptr;
   index_file = MROWS;
   hash_changed = true;
   last_E = 0;
-  DWIN_DrawStatusLine(FSTR_P(nullptr));
+  DWIN_DrawStatusLine();
   DWIN_Draw_Dashboard();
   Goto_Main_Menu();
 }
 
 void MarlinUI::update() {
   EachMomentUpdate();   // Status update
   HMI_SDCardUpdate();   // SD card update
   DWIN_HandleScreen();  // Rotary encoder update
 }
 
@@ -1928,21 +1921,21 @@ void DWIN_RedrawScreen() {
     DWIN_Show_Popup(ICON_BLTouch, GET_TEXT_F(MSG_ADVANCED_PAUSE), fmsg, button);
   }
 
   void MarlinUI::pause_show_message(const PauseMessage message, const PauseMode mode/*=PAUSE_MODE_SAME*/, const uint8_t extruder/*=active_extruder*/) {
     //if (mode == PAUSE_MODE_SAME) return;
     pause_mode = mode;
     switch (message) {
       case PAUSE_MESSAGE_PARKING:  DWIN_Popup_Pause(GET_TEXT_F(MSG_PAUSE_PRINT_PARKING));    break;                                     // M125
       case PAUSE_MESSAGE_CHANGING: DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_INIT));   break;                                     // pause_print (M125, M600)
       case PAUSE_MESSAGE_WAITING:  DWIN_Popup_Pause(GET_TEXT_F(MSG_ADVANCED_PAUSE_WAITING), BTN_Continue); break;
-      case PAUSE_MESSAGE_INSERT:   DWIN_Popup_Continue(ICON_BLTouch, GET_TEXT_F(MSG_ADVANCED_PAUSE), GET_TEXT_F(MSG_FILAMENT_CHANGE_INSERT)); break;
+      case PAUSE_MESSAGE_INSERT:   DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_INSERT), BTN_Continue); break;
       case PAUSE_MESSAGE_LOAD:     DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_LOAD));   break;
       case PAUSE_MESSAGE_UNLOAD:   DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_UNLOAD)); break;                                     // Unload of pause and Unload of M702
       case PAUSE_MESSAGE_PURGE:
         #if ENABLED(ADVANCED_PAUSE_CONTINUOUS_PURGE)
           DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_CONT_PURGE));
         #else
           DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_PURGE));
         #endif
         break;
       case PAUSE_MESSAGE_OPTION:   Goto_FilamentPurge(); break;
@@ -1981,42 +1974,46 @@ void DWIN_RedrawScreen() {
   void DWIN_MeshViewer() {
     if (!leveling_is_valid())
       DWIN_Popup_Continue(ICON_BLTouch, GET_TEXT_F(MSG_MESH_VIEWER), GET_TEXT_F(MSG_NO_VALID_MESH));
     else {
       HMI_SaveProcessID(WaitResponse);
       MeshViewer.Draw();
     }
   }
 #endif // HAS_MESH
 
-void DWIN_LockScreen() {
-  if (checkkey != Locked) {
-    lockScreen.rprocess = checkkey;
-    checkkey = Locked;
-    lockScreen.init();
+
+#if HAS_LOCKSCREEN
+
+  void DWIN_LockScreen() {
+    if (checkkey != Locked) {
+      lockScreen.rprocess = checkkey;
+      checkkey = Locked;
+      lockScreen.init();
+    }
   }
-}
 
-void DWIN_UnLockScreen() {
-  if (checkkey == Locked) {
-    checkkey = lockScreen.rprocess;
-    Draw_Main_Area();
+  void DWIN_UnLockScreen() {
+    if (checkkey == Locked) {
+      checkkey = lockScreen.rprocess;
+      Draw_Main_Area();
+    }
   }
-}
 
-void HMI_LockScreen() {
-  EncoderState encoder_diffState = get_encoder_state();
-  if (encoder_diffState == ENCODER_DIFF_NO) return;
-  lockScreen.onEncoder(encoder_diffState);
-  if (lockScreen.isUnlocked()) DWIN_UnLockScreen();
-}
+  void HMI_LockScreen() {
+    EncoderState encoder_diffState = get_encoder_state();
+    if (encoder_diffState == ENCODER_DIFF_NO) return;
+    lockScreen.onEncoder(encoder_diffState);
+    if (lockScreen.isUnlocked()) DWIN_UnLockScreen();
+  }
 
+#endif //  HAS_LOCKSCREEN
 
 #if HAS_GCODE_PREVIEW
 
   void onClick_ConfirmToPrint() {
     if (HMI_flag.select_flag) {     // Confirm
       card.openAndPrintFile(card.filename);
       return DWIN_Print_Started(true);
     }
     else {                          // Cancel
       DWIN_ResetStatusLine();
@@ -2044,21 +2041,22 @@ void HMI_LockScreen() {
 #endif
 
 //=============================================================================
 // NEW MENU SUBSYSTEM
 //=============================================================================
 
 // Tool functions
 
 #if ENABLED(EEPROM_SETTINGS)
   void WriteEeprom() {
-    DWIN_DrawStatusLine(GET_TEXT_F(MSG_STORE_EEPROM));
+    ui.set_status(GET_TEXT_F(MSG_STORE_EEPROM));
+    DWIN_DrawStatusLine();
     DWIN_UpdateLCD();
     DONE_BUZZ(settings.save());
   }
 
   void ReadEeprom() {
     const bool success = settings.load();
     DWIN_RedrawScreen();
     DONE_BUZZ(success);
   }
 
@@ -2099,25 +2097,27 @@ void DisableMotors() { queue.inject(F("M84")); }
 
 void AutoLev() {   // Always reacquire the Z "home" position
   queue.inject(F(TERN(AUTO_BED_LEVELING_UBL, "G28Z\nG29P1", "G28XYO\nG28Z\nG29")));
 }
 
 void AutoHome() { queue.inject_P(G28_STR); }
 void HomeX() { queue.inject(F("G28X")); }
 void HomeY() { queue.inject(F("G28Y")); }
 void HomeZ() { queue.inject(F("G28Z")); }
 
-void SetHome() {
+#if HAS_HOME_OFFSET
   // Apply workspace offset, making the current position 0,0,0
+  void SetHome() {
   queue.inject(F("G92X0Y0Z0"));
   DONE_BUZZ(true);
-}
+  }
+#endif
 
 #if HAS_ZOFFSET_ITEM
 
   void ApplyZOffset() { TERN_(EEPROM_SETTINGS, settings.save()); }
   void LiveZOffset() {
     #if EITHER(BABYSTEP_ZPROBE_OFFSET, JUST_BABYSTEP)
       const_float_t step_zoffset = round((MenuData.Value / 100.0f) * planner.settings.axis_steps_per_mm[Z_AXIS]) - babystep.accum;
       if (BABYSTEP_ALLOWED()) babystep.add_steps(Z_AXIS, step_zoffset);
     #endif
   }
@@ -2125,36 +2125,39 @@ void SetHome() {
   #if EITHER(BABYSTEP_ZPROBE_OFFSET, JUST_BABYSTEP)
     void SetZOffset() {
       babystep.accum = round(planner.settings.axis_steps_per_mm[Z_AXIS] * BABY_Z_VAR);
       SetPFloatOnClick(Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX, 2, ApplyZOffset, LiveZOffset);
     }
   #endif
 
   void SetMoveZto0() {
     #if ENABLED(Z_SAFE_HOMING)
       char cmd[54], str_1[5], str_2[5];
-      sprintf_P(cmd, PSTR("G28XYO\nG28Z\nG0X%sY%sF5000\nM420S0\nG0Z0F300\nM400"),
+      sprintf_P(cmd, PSTR("G28XYO\nG28Z\nG0X%sY%sF5000\nG0Z0F300\nM400"),
         dtostrf(Z_SAFE_HOMING_X_POINT, 1, 1, str_1),
         dtostrf(Z_SAFE_HOMING_Y_POINT, 1, 1, str_2)
       );
       gcode.process_subcommands_now(cmd);
     #else
-      gcode.process_subcommands_now(F("G28O\nM420S0\nG0Z0F300\nM400"));
+      set_bed_leveling_enabled(false);
+      gcode.process_subcommands_now(F("G28O\nG0Z0F300\nM400"));
     #endif
     ui.reset_status();
     DONE_BUZZ(true);
   }
 
-  void HomeZandDisable() {
-    SetMoveZto0();
-    DisableMotors();
-  }
+  #if !HAS_BED_PROBE
+    void HomeZandDisable() {
+      SetMoveZto0();
+      DisableMotors();
+    }
+  #endif
 
 #endif // HAS_ZOFFSET_ITEM
 
 #if HAS_PREHEAT
   void DoPreheat0() { ui.preheat_all(0); }
   #if PREHEAT_COUNT >= 2
     void DoPreheat1() { ui.preheat_all(1); }
     #if PREHEAT_COUNT >= 3
       void DoPreheat2() { ui.preheat_all(2); }
     #endif
@@ -2833,23 +2836,20 @@ void onDrawGetColorItem(MenuItemClass* menuitem, int8_t line) {
     case 2: color = RGB(0, 0, 31); break; // Blue
     default: color = 0; break;
   }
   DWIN_Draw_Rectangle(0, HMI_data.Highlight_Color, ICOX + 1, MBASE(line) - 1 + 1, ICOX + 18, MBASE(line) - 1 + 18);
   DWIN_Draw_Rectangle(1, color, ICOX + 2, MBASE(line) - 1 + 2, ICOX + 17, MBASE(line) - 1 + 17);
   DWINUI::Draw_String(LBLX, MBASE(line) - 1, menuitem->caption);
   Draw_Menu_IntValue(HMI_data.Background_Color, line, 4, HMI_value.Color[i]);
   DWIN_Draw_HLine(HMI_data.SplitLine_Color, 16, MYPOS(line + 1), 240);
 }
 
-#if HAS_FILAMENT_SENSOR
-  void onDrawRunoutEnable(MenuItemClass* menuitem, int8_t line) { onDrawChkbMenu(menuitem, line, runout.enabled); }
-#endif
 
 void onDrawPIDi(MenuItemClass* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, unscalePID_i(*(float*)static_cast<MenuItemPtrClass*>(menuitem)->value)); }
 void onDrawPIDd(MenuItemClass* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, unscalePID_d(*(float*)static_cast<MenuItemPtrClass*>(menuitem)->value)); }
 
 void onDrawSpeedItem(MenuItemClass* menuitem, int8_t line) {
   if (HMI_IsChinese()) menuitem->SetFrame(1, 116, 164, 171, 176);
   onDrawPIntMenu(menuitem, line);
 }
 
 #if HAS_HOTEND
@@ -3242,21 +3242,23 @@ void Draw_AdvancedSettings_Menu() {
     #if ENABLED(SOUND_MENU_ITEM)
       EDIT_ITEM_F(ICON_Sound, MSG_SOUND_ENABLE, onDrawChkbMenu, SetEnableSound, &ui.sound_on);
     #endif
     #if HAS_ESDIAG
       MENU_ITEM(ICON_ESDiag, F("End-stops diag."), onDrawSubMenu, Draw_EndStopDiag);
     #endif
     #if ENABLED(PRINTCOUNTER)
       MENU_ITEM_F(ICON_PrintStats, MSG_INFO_STATS_MENU, onDrawSubMenu, Goto_PrintStats);
       MENU_ITEM_F(ICON_PrintStatsReset, MSG_INFO_PRINT_COUNT_RESET, onDrawSubMenu, PrintStats.Reset);
     #endif
-    MENU_ITEM_F(ICON_Lock, MSG_LOCKSCREEN, onDrawMenuItem, DWIN_LockScreen);
+    #if HAS_LOCKSCREEN
+      MENU_ITEM_F(ICON_Lock, MSG_LOCKSCREEN, onDrawMenuItem, DWIN_LockScreen);
+    #endif
   }
   ui.reset_status(true);
   UpdateMenu(AdvancedSettings);
 }
 
 void Draw_Move_Menu() {
   checkkey = Menu;
   if (!MoveMenu) MoveMenu = new MenuClass();
   if (CurrentMenu != MoveMenu) {
     CurrentMenu = MoveMenu;
@@ -3288,26 +3290,29 @@ void Draw_Move_Menu() {
 #endif
 
 #if HAS_BED_PROBE
   void Draw_ProbeSet_Menu() {
     checkkey = Menu;
     if (SetMenu(ProbeSetMenu, GET_TEXT_F(MSG_ZPROBE_SETTINGS), 8)) {
       BACK_ITEM(Draw_AdvancedSettings_Menu);
       EDIT_ITEM_F(ICON_ProbeOffsetX, MSG_ZPROBE_XOFFSET, onDrawPFloatMenu, SetProbeOffsetX, &probe.offset.x);
       EDIT_ITEM_F(ICON_ProbeOffsetY, MSG_ZPROBE_YOFFSET, onDrawPFloatMenu, SetProbeOffsetY, &probe.offset.y);
       EDIT_ITEM_F(ICON_ProbeOffsetZ, MSG_ZPROBE_ZOFFSET, onDrawPFloat2Menu, SetProbeOffsetZ, &probe.offset.z);
-      #ifdef BLTOUCH_HS_MODE
-        EDIT_ITEM_F(ICON_HSMode, MSG_ENABLE_HS_MODE, onDrawChkbMenu, SetHSMode, &bltouch.high_speed_mode);
+      #if ENABLED(BLTOUCH)
+        MENU_ITEM_F(ICON_ProbeStow, MSG_MANUAL_STOW, onDrawMenuItem, ProbeStow);
+        MENU_ITEM_F(ICON_ProbeDeploy, MSG_MANUAL_DEPLOY, onDrawMenuItem, ProbeDeploy);
+        MENU_ITEM_F(ICON_BltouchReset, MSG_BLTOUCH_RESET, onDrawMenuItem, bltouch._reset);
+        #ifdef BLTOUCH_HS_MODE
+          EDIT_ITEM_F(ICON_HSMode, MSG_ENABLE_HS_MODE, onDrawChkbMenu, SetHSMode, &bltouch.high_speed_mode);
+        #endif
       #endif
       MENU_ITEM_F(ICON_ProbeTest, MSG_M48_TEST, onDrawMenuItem, ProbeTest);
-      MENU_ITEM_F(ICON_ProbeStow, MSG_MANUAL_STOW, onDrawMenuItem, ProbeStow);
-      MENU_ITEM_F(ICON_ProbeDeploy, MSG_MANUAL_DEPLOY, onDrawMenuItem, ProbeDeploy);
     }
     UpdateMenu(ProbeSetMenu);
   }
 
 #endif
 
 void Draw_FilSet_Menu() {
   checkkey = Menu;
   if (SetMenu(FilSetMenu, GET_TEXT_F(MSG_FILAMENT_SET), 9)) {
     BACK_ITEM(Draw_AdvancedSettings_Menu);
@@ -3377,38 +3382,49 @@ void Draw_GetColor_Menu() {
       if (SetMenu(CaseLightMenu, GET_TEXT_F(MSG_CASE_LIGHT), 3)) {
         BACK_ITEM(Draw_Control_Menu);
         EDIT_ITEM_F(ICON_CaseLight, MSG_CASE_LIGHT, onDrawChkbMenu, SetCaseLight, &caselight.on);
         EDIT_ITEM_F(ICON_Brightness, MSG_CASE_LIGHT_BRIGHTNESS, onDrawPInt8Menu, SetCaseLightBrightness, &caselight.brightness);
       }
       UpdateMenu(CaseLightMenu);
     }
 #endif
 
 #if ENABLED(LED_CONTROL_MENU)
-    void Draw_LedControl_Menu() {
-      checkkey = Menu;
-      if (SetMenu(LedControlMenu, GET_TEXT_F(MSG_LED_CONTROL), 6)) {
-        BACK_ITEM(Draw_Control_Menu);
-        #if !BOTH(CASE_LIGHT_MENU, CASE_LIGHT_USE_NEOPIXEL)
-          EDIT_ITEM_F(ICON_LedControl, MSG_LEDS, onDrawChkbMenu, SetLedStatus, &leds.lights_on);
-        #endif
-        #if HAS_COLOR_LEDS
+  void Draw_LedControl_Menu() {
+    checkkey = Menu;
+    if (SetMenu(LedControlMenu, GET_TEXT_F(MSG_LED_CONTROL), 6)) {
+      BACK_ITEM(Draw_Control_Menu);
+      #if !BOTH(CASE_LIGHT_MENU, CASE_LIGHT_USE_NEOPIXEL)
+        EDIT_ITEM_F(ICON_LedControl, MSG_LEDS, onDrawChkbMenu, SetLedStatus, &leds.lights_on);
+      #endif
+      #if HAS_COLOR_LEDS
+        #if ENABLED(LED_COLOR_PRESETS)
+          MENU_ITEM_F(ICON_LedControl, MSG_SET_LEDS_WHITE, onDrawMenuItem,  leds.set_white);
+          MENU_ITEM_F(ICON_LedControl, MSG_SET_LEDS_RED, onDrawMenuItem,    leds.set_red);
+          MENU_ITEM_F(ICON_LedControl, MSG_SET_LEDS_ORANGE, onDrawMenuItem, leds.set_orange);
+          MENU_ITEM_F(ICON_LedControl, MSG_SET_LEDS_YELLOW, onDrawMenuItem, leds.set_yellow);
+          MENU_ITEM_F(ICON_LedControl, MSG_SET_LEDS_GREEN, onDrawMenuItem,  leds.set_green);
+          MENU_ITEM_F(ICON_LedControl, MSG_SET_LEDS_BLUE, onDrawMenuItem,   leds.set_blue);
+          MENU_ITEM_F(ICON_LedControl, MSG_SET_LEDS_INDIGO, onDrawMenuItem, leds.set_indigo);
+          MENU_ITEM_F(ICON_LedControl, MSG_SET_LEDS_VIOLET, onDrawMenuItem, leds.set_violet);
+        #else
           EDIT_ITEM_F(ICON_LedControl, MSG_COLORS_RED, onDrawPInt8Menu, SetLEDColorR, &leds.color.r);
           EDIT_ITEM_F(ICON_LedControl, MSG_COLORS_GREEN, onDrawPInt8Menu, SetLEDColorG, &leds.color.g);
           EDIT_ITEM_F(ICON_LedControl, MSG_COLORS_BLUE, onDrawPInt8Menu, SetLEDColorB, &leds.color.b);
           #if ENABLED(HAS_WHITE_LED)
             EDIT_ITEM_F(ICON_LedControl, MSG_COLORS_WHITE, onDrawPInt8Menu, SetLedColorW, &leds.color.w);
           #endif
         #endif
-      }
-      UpdateMenu(LedControlMenu);
+      #endif
     }
+    UpdateMenu(LedControlMenu);
+  }
 #endif
 
 void Draw_Tune_Menu() {
   checkkey = Menu;
   if (!TuneMenu) TuneMenu = new MenuClass();
   if (CurrentMenu != TuneMenu) {
     CurrentMenu = TuneMenu;
     SetMenuTitle({73, 2, 28, 12}, GET_TEXT_F(MSG_TUNE)); // TODO: Chinese, English "Tune" JPG
     MenuItemsPrepare(16);
     BACK_ITEM(Goto_PrintProcess);
@@ -3425,21 +3441,23 @@ void Draw_Tune_Menu() {
     #if HAS_ZOFFSET_ITEM && EITHER(BABYSTEP_ZPROBE_OFFSET, JUST_BABYSTEP)
       EDIT_ITEM_F(ICON_Zoffset, MSG_ZPROBE_ZOFFSET, onDrawZOffset, SetZOffset, &BABY_Z_VAR);
     #endif
     EDIT_ITEM_F(ICON_Flow, MSG_FLOW, onDrawPIntMenu, SetFlow, &planner.flow_percentage[0]);
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
       MENU_ITEM_F(ICON_FilMan, MSG_FILAMENTCHANGE, onDrawMenuItem, ChangeFilament);
     #endif
     #if ENABLED(FWRETRACT)
       MENU_ITEM_F(ICON_FWRetract, MSG_FWRETRACT, onDrawSubMenu, Draw_FWRetract_Menu);
     #endif
-    MENU_ITEM_F(ICON_Lock, MSG_LOCKSCREEN, onDrawMenuItem, DWIN_LockScreen);
+    #if HAS_LOCKSCREEN
+      MENU_ITEM_F(ICON_Lock, MSG_LOCKSCREEN, onDrawMenuItem, DWIN_LockScreen);
+    #endif
     #if HAS_LCD_BRIGHTNESS
       EDIT_ITEM_F(ICON_Brightness, MSG_BRIGHTNESS, onDrawPInt8Menu, SetBrightness, &ui.brightness);
       MENU_ITEM_F(ICON_Brightness, MSG_BRIGHTNESS_OFF, onDrawMenuItem, TurnOffBacklight);
     #endif
     #if ENABLED(CASE_LIGHT_MENU)
       EDIT_ITEM_F(ICON_CaseLight, MSG_CASE_LIGHT, onDrawChkbMenu, SetCaseLight, &caselight.on);
     #elif ENABLED(LED_CONTROL_MENU) && DISABLED(CASE_LIGHT_USE_NEOPIXEL)
       EDIT_ITEM_F(ICON_LedControl, MSG_LEDS, onDrawChkbMenu, SetLedStatus, &leds.lights_on);
     #endif
   }
@@ -3743,86 +3761,71 @@ void Draw_Steps_Menu() {
     set_bed_leveling_enabled(!planner.leveling_active);
     Draw_Chkb_Line(CurrentMenu->line(), planner.leveling_active);
     DWIN_UpdateLCD();
   }
 
   #if BOTH(HAS_HEATED_BED, PREHEAT_BEFORE_LEVELING)
     void SetBedLevT() { SetPIntOnClick(MIN_BEDTEMP, MAX_BEDTEMP); }
   #endif
 
   #if ENABLED(MESH_EDIT_MENU)
-    uint8_t mesh_x = 0, mesh_y = 0;
     #define Z_OFFSET_MIN -3
     #define Z_OFFSET_MAX  3
 
-    void LiveEditMesh() { ((MenuItemPtrClass*)EditZValueItem)->value = &bedlevel.z_values[HMI_value.Select ? mesh_x : MenuData.Value][HMI_value.Select ? MenuData.Value : mesh_y]; EditZValueItem->redraw(); }
-    void ApplyEditMeshX() { mesh_x = MenuData.Value; }
-    void SetEditMeshX() { HMI_value.Select = 0; SetIntOnClick(0, GRID_MAX_POINTS_X - 1, mesh_x, ApplyEditMeshX, LiveEditMesh); }
-    void ApplyEditMeshY() { mesh_y = MenuData.Value; }
-    void SetEditMeshY() { HMI_value.Select = 1; SetIntOnClick(0, GRID_MAX_POINTS_Y - 1, mesh_y, ApplyEditMeshY, LiveEditMesh); }
+    void LiveEditMesh() { ((MenuItemPtrClass*)EditZValueItem)->value = &bedlevel.z_values[HMI_value.Select ? BedLevelTools.mesh_x : MenuData.Value][HMI_value.Select ? MenuData.Value : BedLevelTools.mesh_y]; EditZValueItem->redraw(); }
+    void ApplyEditMeshX() { BedLevelTools.mesh_x = MenuData.Value; }
+    void SetEditMeshX() { HMI_value.Select = 0; SetIntOnClick(0, GRID_MAX_POINTS_X - 1, BedLevelTools.mesh_x, ApplyEditMeshX, LiveEditMesh); }
+    void ApplyEditMeshY() { BedLevelTools.mesh_y = MenuData.Value; }
+    void SetEditMeshY() { HMI_value.Select = 1; SetIntOnClick(0, GRID_MAX_POINTS_Y - 1, BedLevelTools.mesh_y, ApplyEditMeshY, LiveEditMesh); }
     void SetEditZValue() { SetPFloatOnClick(Z_OFFSET_MIN, Z_OFFSET_MAX, 3); }
   #endif
 #endif
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
 
   void ApplyUBLSlot() { bedlevel.storage_slot = MenuData.Value; }
   void SetUBLSlot() { SetIntOnClick(0, settings.calc_num_meshes() - 1, bedlevel.storage_slot, ApplyUBLSlot); }
   void onDrawUBLSlot(MenuItemClass* menuitem, int8_t line) {
     if (bedlevel.storage_slot < 0) bedlevel.storage_slot = 0;
     onDrawIntMenu(menuitem, line, bedlevel.storage_slot);
   }
 
-  void ApplyUBLTiltGrid() { ubl_tools.tilt_grid = MenuData.Value; }
-  void SetUBLTiltGrid() { SetIntOnClick(1, 3, ubl_tools.tilt_grid, ApplyUBLTiltGrid); }
+  void ApplyUBLTiltGrid() { BedLevelTools.tilt_grid = MenuData.Value; }
+  void SetUBLTiltGrid() { SetIntOnClick(1, 3, BedLevelTools.tilt_grid, ApplyUBLTiltGrid); }
 
   void UBLTiltMesh() {
     if (bedlevel.storage_slot < 0) bedlevel.storage_slot = 0;
     char buf[15];
-    if (ubl_tools.tilt_grid > 1) {
-      sprintf_P(buf, PSTR("G28O\nG29 J%i"), ubl_tools.tilt_grid);
+    if (BedLevelTools.tilt_grid > 1) {
+      sprintf_P(buf, PSTR("G28O\nG29 J%i"), BedLevelTools.tilt_grid);
       gcode.process_subcommands_now(buf);
     }
     else
       gcode.process_subcommands_now(F("G28O\nG29J"));
     LCD_MESSAGE(MSG_UBL_MESH_TILTED);
   }
 
   void UBLSmartFillMesh() {
-    bedlevel.smart_fill_mesh();
+    LOOP_L_N(x, GRID_MAX_POINTS_Y) bedlevel.smart_fill_mesh();
     LCD_MESSAGE(MSG_UBL_MESH_FILLED);
   }
 
-  bool UBLValidMesh() {
-    const bool valid = ubl_tools.validate();
-    if (!valid) bedlevel.invalidate();
-    return valid;
-  }
-
   void UBLSaveMesh() {
     if (bedlevel.storage_slot < 0) bedlevel.storage_slot = 0;
     settings.store_mesh(bedlevel.storage_slot);
     ui.status_printf(0, GET_TEXT_F(MSG_MESH_SAVED), bedlevel.storage_slot);
     DONE_BUZZ(true);
   }
 
   void UBLLoadMesh() {
     if (bedlevel.storage_slot < 0) bedlevel.storage_slot = 0;
     settings.load_mesh(bedlevel.storage_slot);
-    if (UBLValidMesh()) {
-      ui.status_printf(0, GET_TEXT_F(MSG_MESH_LOADED), bedlevel.storage_slot);
-      DONE_BUZZ(true);
-    }
-    else {
-      LCD_MESSAGE_F("Invalid Mesh Loaded");
-      DONE_BUZZ(false);
-    }
   }
 
 #endif // AUTO_BED_LEVELING_UBL
 
 #if HAS_MESH
   void Draw_MeshSet_Menu() {
     checkkey = Menu;
     if (SetMenu(MeshMenu, GET_TEXT_F(MSG_MESH_LEVELING), 15)) {
       BACK_ITEM(Draw_AdvancedSettings_Menu);
       #if BOTH(HAS_HEATED_BED, PREHEAT_BEFORE_LEVELING)
@@ -3830,39 +3833,41 @@ void Draw_Steps_Menu() {
       #endif
       EDIT_ITEM_F(ICON_SetZOffset, MSG_Z_FADE_HEIGHT, onDrawPFloatMenu, SetMeshFadeHeight, &planner.z_fade_height);
       EDIT_ITEM_F(ICON_UBLActive, MSG_ACTIVATE_MESH, onDrawChkbMenu, SetMeshActive, &planner.leveling_active);
       #if HAS_BED_PROBE
         MENU_ITEM_F(ICON_Level, MSG_AUTO_MESH, onDrawMenuItem, AutoLev);
       #endif
       #if ENABLED(AUTO_BED_LEVELING_UBL)
         EDIT_ITEM_F(ICON_UBLActive, MSG_UBL_STORAGE_SLOT, onDrawUBLSlot, SetUBLSlot, &bedlevel.storage_slot);
         MENU_ITEM_F(ICON_UBLActive, MSG_UBL_SAVE_MESH, onDrawMenuItem, UBLSaveMesh);
         MENU_ITEM_F(ICON_UBLActive, MSG_UBL_LOAD_MESH, onDrawMenuItem, UBLLoadMesh);
-        EDIT_ITEM_F(ICON_UBLActive, MSG_UBL_TILTING_GRID, onDrawPInt8Menu, SetUBLTiltGrid, &ubl_tools.tilt_grid);
+        EDIT_ITEM_F(ICON_UBLActive, MSG_UBL_TILTING_GRID, onDrawPInt8Menu, SetUBLTiltGrid, &BedLevelTools.tilt_grid);
         MENU_ITEM_F(ICON_UBLActive, MSG_UBL_TILT_MESH, onDrawMenuItem, UBLTiltMesh);
         MENU_ITEM_F(ICON_UBLActive, MSG_UBL_SMART_FILLIN, onDrawMenuItem, UBLSmartFillMesh);
       #endif
       #if ENABLED(MESH_EDIT_MENU)
         MENU_ITEM_F(ICON_UBLActive, MSG_EDIT_MESH, onDrawSubMenu, Draw_EditMesh_Menu);
       #endif
       MENU_ITEM_F(ICON_MeshViewer, MSG_MESH_VIEW, onDrawSubMenu, DWIN_MeshViewer);
     }
     UpdateMenu(MeshMenu);
   }
 
   #if ENABLED(MESH_EDIT_MENU)
     void Draw_EditMesh_Menu() {
+      if (!leveling_is_valid()) { LCD_MESSAGE(MSG_UBL_MESH_INVALID); return; }
+      set_bed_leveling_enabled(false);
       checkkey = Menu;
       if (SetMenu(EditMeshMenu, GET_TEXT_F(MSG_EDIT_MESH), 4)) {
-        mesh_x = mesh_y = 0;
+        BedLevelTools.mesh_x = BedLevelTools.mesh_y = 0;
         BACK_ITEM(Draw_MeshSet_Menu);
-        EDIT_ITEM_F(ICON_UBLActive, MSG_MESH_X, onDrawPInt8Menu, SetEditMeshX, &mesh_x);
-        EDIT_ITEM_F(ICON_UBLActive, MSG_MESH_Y, onDrawPInt8Menu, SetEditMeshY, &mesh_y);
-        EditZValueItem = EDIT_ITEM_F(ICON_UBLActive, MSG_MESH_EDIT_Z, onDrawPFloat3Menu, SetEditZValue, &bedlevel.z_values[mesh_x][mesh_y]);
+        EDIT_ITEM_F(ICON_UBLActive, MSG_MESH_X, onDrawPInt8Menu, SetEditMeshX,&BedLevelTools.mesh_x);
+        EDIT_ITEM_F(ICON_UBLActive, MSG_MESH_Y, onDrawPInt8Menu, SetEditMeshY,&BedLevelTools.mesh_y);
+        EditZValueItem = EDIT_ITEM_F(ICON_UBLActive, MSG_MESH_EDIT_Z, onDrawPFloat3Menu, SetEditZValue, &bedlevel.z_values[BedLevelTools.mesh_x][BedLevelTools.mesh_y]);
       }
       UpdateMenu(EditMeshMenu);
     }
   #endif
 
 #endif // HAS_MESH
 
 #endif // DWIN_LCD_PROUI

commit c9a9b25d41e7eb805c166e8a27cfa938b36bd2ba
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Mon Jun 6 00:01:06 2022 -0500

    üö∏ ProUI G-code preview, PID plot (#24282)

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 8594a899f9..07b134471b 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -122,20 +122,28 @@
 #endif
 
 #if ENABLED(POWER_LOSS_RECOVERY)
   #include "../../../feature/powerloss.h"
 #endif
 
 #if HAS_ESDIAG
   #include "endstop_diag.h"
 #endif
 
+#if HAS_PIDPLOT
+  #include "plot.h"
+#endif
+
+#if HAS_GCODE_PREVIEW
+  #include "gcode_preview.h"
+#endif
+
 #if HAS_MESH
   #include "meshviewer.h"
 #endif
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
   #include "ubl_tools.h"
 #endif
 
 #if ENABLED(PRINTCOUNTER)
   #include "printstats.h"
@@ -698,27 +706,33 @@ void Goto_PrintProcess() {
 }
 
 void Draw_PrintDone() {
   // show percent bar and value
   _percent_done = 100;
   _remain_time = 0;
 
   Title.ShowCaption(GET_TEXT_F(MSG_PRINT_DONE));
   DWINUI::ClearMainArea();
   DWIN_Print_Header(nullptr);
-  Draw_Print_ProgressBar();
-  Draw_Print_Labels();
-  DWINUI::Draw_Icon(ICON_PrintTime, 15, 173);
-  DWINUI::Draw_Icon(ICON_RemainTime, 150, 171);
-  Draw_Print_ProgressElapsed();
-  Draw_Print_ProgressRemain();
-  DWINUI::Draw_Button(BTN_Continue, 86, 273);
+  if (sdprint && TERN0(HAS_GCODE_PREVIEW, Preview_Valid())) {
+    DWIN_ICON_Show(0, 0, 1, 21, 100, 0x00);
+    DWINUI::Draw_Button(BTN_Continue, 86, 300);
+  }
+  else {
+    Draw_Print_ProgressBar();
+    Draw_Print_Labels();
+    DWINUI::Draw_Icon(ICON_PrintTime, 15, 173);
+    DWINUI::Draw_Icon(ICON_RemainTime, 150, 171);
+    Draw_Print_ProgressElapsed();
+    Draw_Print_ProgressRemain();
+    DWINUI::Draw_Button(BTN_Continue, 86, 273);
+  }
 }
 
 void Goto_PrintDone() {
   wait_for_user = true;
   if (checkkey != PrintDone) {
     checkkey = PrintDone;
     Draw_PrintDone();
     DWIN_UpdateLCD();
   }
 }
@@ -1402,20 +1416,23 @@ void HMI_Init() {
 void EachMomentUpdate() {
   static millis_t next_var_update_ms = 0, next_rts_update_ms = 0, next_status_update_ms = 0;
   const millis_t ms = millis();
 
   if (ELAPSED(ms, next_var_update_ms)) {
     next_var_update_ms = ms + DWIN_VAR_UPDATE_INTERVAL;
     update_variable();
     #if HAS_ESDIAG
       if (checkkey == ESDiagProcess) ESDiag.Update();
     #endif
+    #if HAS_PIDPLOT
+      if (checkkey == PidProcess) Plot.Update((HMI_value.pidresult == PID_EXTR_START) ? thermalManager.wholeDegHotend(0) : thermalManager.wholeDegBed());
+    #endif
   }
 
   #if HAS_STATUS_MESSAGE_TIMEOUT
     bool did_expire = ui.status_reset_callback && (*ui.status_reset_callback)();
     did_expire |= ui.status_message_expire_ms && ELAPSED(ms, ui.status_message_expire_ms);
     if (did_expire) ui.reset_status();
   #endif
 
   if (ELAPSED(ms, next_status_update_ms)) {
     next_status_update_ms = ms + 500;
@@ -1628,29 +1645,63 @@ void DWIN_LevelingDone() {
 #if HAS_MESH
   void DWIN_MeshUpdate(const int8_t xpos, const int8_t ypos, const_float_t zval) {
     char msg[33] = "";
     char str_1[6] = "";
     sprintf_P(msg, PSTR(S_FMT " %i/%i Z=%s"), GET_TEXT(MSG_PROBING_POINT), xpos, ypos, dtostrf(zval, 1, 2, str_1));
     ui.set_status(msg);
   }
 #endif
 
 // PID process
+
+#if HAS_PIDPLOT
+  void DWIN_Draw_PIDPopup() {
+    frame_rect_t gfrm = {40, 180, DWIN_WIDTH - 80, 120};
+    DWINUI::ClearMainArea();
+    Draw_Popup_Bkgd();
+    DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 100, GET_TEXT_F(MSG_PID_AUTOTUNE));
+    DWINUI::Draw_String(HMI_data.PopupTxt_Color, gfrm.x, gfrm.y - DWINUI::fontHeight() - 4, F("PID target:    Celsius"));
+    switch (HMI_value.pidresult) {
+      case PID_EXTR_START:
+        DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 120, F("for Nozzle is running."));
+        Plot.Draw(gfrm, thermalManager.hotend_maxtemp[0], HMI_data.HotendPidT);
+        DWINUI::Draw_Int(HMI_data.PopupTxt_Color, 3, gfrm.x + 90, gfrm.y - DWINUI::fontHeight() - 4, HMI_data.HotendPidT);
+        break;
+      case PID_BED_START:
+        DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 120, F("for BED is running."));
+        Plot.Draw(gfrm, BED_MAXTEMP, HMI_data.BedPidT);
+        DWINUI::Draw_Int(HMI_data.PopupTxt_Color, 3, gfrm.x + 90, gfrm.y - DWINUI::fontHeight() - 4, HMI_data.BedPidT);
+        break;
+      default:
+        break;
+    }
+  }
+#endif
+
 void DWIN_PidTuning(pidresult_t result) {
+  HMI_value.pidresult = result;
   switch (result) {
     case PID_BED_START:
-      HMI_SaveProcessID(NothingToDo);
-      DWIN_Draw_Popup(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE), F("for BED is running."));
+      HMI_SaveProcessID(PidProcess);
+      #if HAS_PIDPLOT
+        DWIN_Draw_PIDPopup();
+      #else
+        DWIN_Draw_Popup(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE), F("for BED is running."));
+      #endif
       break;
     case PID_EXTR_START:
-      HMI_SaveProcessID(NothingToDo);
-      DWIN_Draw_Popup(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE), F("for Nozzle is running."));
+      HMI_SaveProcessID(PidProcess);
+      #if HAS_PIDPLOT
+        DWIN_Draw_PIDPopup();
+      #else
+        DWIN_Draw_Popup(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE), F("for Nozzle is running."));
+      #endif
       break;
     case PID_BAD_EXTRUDER_NUM:
       checkkey = last_checkkey;
       DWIN_Popup_Confirm(ICON_TempTooLow, GET_TEXT_F(MSG_PID_AUTOTUNE_FAILED), GET_TEXT_F(MSG_BAD_EXTRUDER_NUM));
       break;
     case PID_TUNING_TIMEOUT:
       checkkey = last_checkkey;
       DWIN_Popup_Confirm(ICON_TempTooHigh, GET_TEXT_F(MSG_ERROR), GET_TEXT_F(MSG_PID_TIMEOUT));
       break;
     case PID_TEMP_TOO_HIGH:
@@ -1953,24 +2004,44 @@ void DWIN_UnLockScreen() {
 }
 
 void HMI_LockScreen() {
   EncoderState encoder_diffState = get_encoder_state();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
   lockScreen.onEncoder(encoder_diffState);
   if (lockScreen.isUnlocked()) DWIN_UnLockScreen();
 }
 
 
-void Goto_ConfirmToPrint() {
-  card.openAndPrintFile(card.filename);
-  DWIN_Print_Started(true);
-}
+#if HAS_GCODE_PREVIEW
+
+  void onClick_ConfirmToPrint() {
+    if (HMI_flag.select_flag) {     // Confirm
+      card.openAndPrintFile(card.filename);
+      return DWIN_Print_Started(true);
+    }
+    else {                          // Cancel
+      DWIN_ResetStatusLine();
+      checkkey = SelectFile;
+      return Draw_Print_File_Menu();
+    }
+  }
+
+  void Goto_ConfirmToPrint() {
+    Goto_Popup(Preview_DrawFromSD, onClick_ConfirmToPrint);
+  }
+
+#else
+  void Goto_ConfirmToPrint() {
+    card.openAndPrintFile(card.filename);
+    DWIN_Print_Started(true);
+  }
+#endif
 
 #if HAS_ESDIAG
   void Draw_EndStopDiag() {
     HMI_SaveProcessID(ESDiagProcess);
     ESDiag.Draw();
   }
 #endif
 
 //=============================================================================
 // NEW MENU SUBSYSTEM

commit 8aca38351cd6d33a1202bf9a13890dc8e5eadd49
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 3 22:56:38 2022 -0500

    üßë‚Äçüíª Extend LCD string substitution (#24278)

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index b4a1bad746..8594a899f9 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -3502,28 +3502,28 @@ void Draw_Temperature_Menu() {
     #endif
   }
   CurrentMenu->draw();
 }
 
 void Draw_MaxSpeed_Menu() {
   checkkey = Menu;
   if (!MaxSpeedMenu) MaxSpeedMenu = new MenuClass();
   if (CurrentMenu != MaxSpeedMenu) {
     CurrentMenu = MaxSpeedMenu;
-    SetMenuTitle({1, 16, 28, 13}, GET_TEXT_F(MSG_MAXSPEED));
+    SetMenuTitle({1, 16, 28, 13}, GET_TEXT_F(MSG_MAX_SPEED));
     MenuItemsPrepare(5);
     BACK_ITEM(Draw_Motion_Menu);
-    EDIT_ITEM_F(ICON_MaxSpeedX, MSG_MAXSPEED_X, onDrawMaxSpeedX, SetMaxSpeedX, &planner.settings.max_feedrate_mm_s[X_AXIS]);
-    EDIT_ITEM_F(ICON_MaxSpeedY, MSG_MAXSPEED_Y, onDrawMaxSpeedY, SetMaxSpeedY, &planner.settings.max_feedrate_mm_s[Y_AXIS]);
-    EDIT_ITEM_F(ICON_MaxSpeedZ, MSG_MAXSPEED_Z, onDrawMaxSpeedZ, SetMaxSpeedZ, &planner.settings.max_feedrate_mm_s[Z_AXIS]);
+    EDIT_ITEM_F(ICON_MaxSpeedX, MSG_VMAX_A, onDrawMaxSpeedX, SetMaxSpeedX, &planner.settings.max_feedrate_mm_s[X_AXIS]);
+    EDIT_ITEM_F(ICON_MaxSpeedY, MSG_VMAX_B, onDrawMaxSpeedY, SetMaxSpeedY, &planner.settings.max_feedrate_mm_s[Y_AXIS]);
+    EDIT_ITEM_F(ICON_MaxSpeedZ, MSG_VMAX_C, onDrawMaxSpeedZ, SetMaxSpeedZ, &planner.settings.max_feedrate_mm_s[Z_AXIS]);
     #if HAS_HOTEND
-      EDIT_ITEM_F(ICON_MaxSpeedE, MSG_MAXSPEED_E, onDrawMaxSpeedE, SetMaxSpeedE, &planner.settings.max_feedrate_mm_s[E_AXIS]);
+      EDIT_ITEM_F(ICON_MaxSpeedE, MSG_VMAX_E, onDrawMaxSpeedE, SetMaxSpeedE, &planner.settings.max_feedrate_mm_s[E_AXIS]);
     #endif
   }
   CurrentMenu->draw();
 }
 
 void Draw_MaxAccel_Menu() {
   checkkey = Menu;
   if (!MaxAccelMenu) MaxAccelMenu = new MenuClass();
   if (CurrentMenu != MaxAccelMenu) {
     CurrentMenu = MaxAccelMenu;

commit eec9c800c9e82eb36b566ea6aca7cf7c1483a4bf
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Sat May 28 17:34:36 2022 -0500

    üö∏ Fix, improve, update ProUI (#24251)

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 122136c1a0..b4a1bad746 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -24,20 +24,51 @@
  * DWIN Enhanced implementation for PRO UI
  * Author: Miguel A. Risco-Castillo (MRISCOC)
  * Version: 3.17.2
  * Date: 2022/04/08
  */
 
 #include "../../../inc/MarlinConfig.h"
 
 #if ENABLED(DWIN_LCD_PROUI)
 
+#if DISABLED(LIMITED_MAX_FR_EDITING)
+  #warning "LIMITED_MAX_FR_EDITING is recommended with ProUI."
+#endif
+#if DISABLED(LIMITED_MAX_ACCEL_EDITING)
+  #warning "LIMITED_MAX_ACCEL_EDITING is recommended with ProUI."
+#endif
+#if ENABLED(CLASSIC_JERK) && DISABLED(LIMITED_JERK_EDITING)
+  #warning "LIMITED_JERK_EDITING is recommended with ProUI."
+#endif
+#if DISABLED(INDIVIDUAL_AXIS_HOMING_SUBMENU)
+  #warning "INDIVIDUAL_AXIS_HOMING_SUBMENU is recommended with ProUI."
+#endif
+#if DISABLED(LCD_SET_PROGRESS_MANUALLY)
+  #warning "LCD_SET_PROGRESS_MANUALLY is recommended with ProUI."
+#endif
+#if DISABLED(STATUS_MESSAGE_SCROLLING)
+  #warning "STATUS_MESSAGE_SCROLLING is recommended with ProUI."
+#endif
+#if DISABLED(BAUD_RATE_GCODE)
+  #warning "BAUD_RATE_GCODE is recommended with ProUI."
+#endif
+#if DISABLED(SOUND_MENU_ITEM)
+  #warning "SOUND_MENU_ITEM is recommended with ProUI."
+#endif
+#if DISABLED(PRINTCOUNTER)
+  #warning "PRINTCOUNTER is recommended with ProUI."
+#endif
+#if HAS_MESH && DISABLED(MESH_EDIT_MENU)
+  #warning "MESH_EDIT_MENU is recommended with ProUI."
+#endif
+
 #include "dwin.h"
 #include "menus.h"
 #include "dwin_popup.h"
 
 #include "../../fontutils.h"
 #include "../../marlinui.h"
 
 #include "../../../sd/cardreader.h"
 
 #include "../../../MarlinCore.h"
@@ -155,21 +186,26 @@
 #define MAX_ETEMP  (HEATER_0_MAXTEMP - (HOTEND_OVERSHOOT))
 #define MIN_BEDTEMP 0
 #define MAX_BEDTEMP BED_MAX_TARGET
 
 #define FEEDRATE_E      (60)
 
 #define DWIN_VAR_UPDATE_INTERVAL         1024
 #define DWIN_SCROLL_UPDATE_INTERVAL      SEC_TO_MS(2)
 #define DWIN_REMAIN_TIME_UPDATE_INTERVAL SEC_TO_MS(20)
 
-#define BABY_Z_VAR TERN(HAS_BED_PROBE, probe.offset.z, HMI_data.ManualZOffset)
+#if HAS_MESH
+  #define BABY_Z_VAR TERN(HAS_BED_PROBE, probe.offset.z, HMI_data.ManualZOffset)
+#else
+  float z_offset = 0;
+  #define BABY_Z_VAR z_offset
+#endif
 
 // Structs
 HMI_value_t HMI_value;
 HMI_flag_t HMI_flag{0};
 HMI_data_t HMI_data;
 
 millis_t dwin_heat_time = 0;
 
 uint8_t checkkey = 255, last_checkkey = MainMenu;
 
@@ -193,25 +229,42 @@ typedef struct {
   bool changed() { bool c = (now != last); if (c) last = now; return c; }
   bool dec() { if (now) now--; return changed(); }
   bool inc(uint8_t v) { if (now < (v - 1)) now++; else now = (v - 1); return changed(); }
 } select_t;
 
 select_t select_page{0}, select_file{0}, select_print{0};
 uint8_t index_file     = MROWS;
 
 bool hash_changed = true; // Flag to know if message status was changed
 
-constexpr float max_feedrate_edit_values[] = MAX_FEEDRATE_EDIT_VALUES;
-constexpr float max_acceleration_edit_values[] = MAX_ACCEL_EDIT_VALUES;
-
+constexpr float max_feedrate_edit_values[] =
+  #ifdef MAX_FEEDRATE_EDIT_VALUES
+    MAX_FEEDRATE_EDIT_VALUES
+  #else
+    { 1000, 1000, 10, 50 }
+  #endif
+;
+constexpr float max_acceleration_edit_values[] =
+  #ifdef MAX_ACCEL_EDIT_VALUES
+    MAX_ACCEL_EDIT_VALUES
+  #else
+    { 1000, 1000, 200, 2000 }
+  #endif
+;
 #if HAS_CLASSIC_JERK
-  constexpr float max_jerk_edit_values[] = MAX_JERK_EDIT_VALUES;
+  constexpr float max_jerk_edit_values[] =
+    #ifdef MAX_JERK_EDIT_VALUES
+      MAX_JERK_EDIT_VALUES
+    #else
+      { DEFAULT_XJERK * 2, DEFAULT_YJERK * 2, DEFAULT_ZJERK * 2, DEFAULT_EJERK * 2 }
+    #endif
+  ;
 #endif
 
 static uint8_t _percent_done = 0;
 static uint32_t _remain_time = 0;
 
 // Additional Aux Host Support
 static bool sdprint = false;
 
 #if HAS_HOTEND
   float last_E = 0;
@@ -808,20 +861,22 @@ void update_variable() {
   #if HAS_MESH
     static bool _leveling_active = false;
     if (_leveling_active != planner.leveling_active) {
       _leveling_active = planner.leveling_active;
       DWIN_Draw_Box(1, HMI_data.Background_Color, 186, 416, 20, 20);
       if (_leveling_active)
         DWINUI::Draw_Icon(ICON_SetZOffset, 186, 416);
       else
         DWINUI::Draw_Icon(ICON_Zoffset, 187, 416);
     }
+  #else
+    DWINUI::Draw_Icon(ICON_Zoffset, 187, 416);
   #endif
 
   _draw_xyz_position(false);
 }
 
 /**
  * Read and cache the working directory.
  *
  * TODO: New code can follow the pattern of menu_media.cpp
  * and rely on Marlin caching for performance. No need to
@@ -2285,96 +2340,113 @@ void SetSpeed() { SetPIntOnClick(MIN_PRINT_SPEED, MAX_PRINT_SPEED); }
       queue.inject(F("M701 Z20"));
     }
   #endif
 
 #endif // ADVANCED_PAUSE_FEATURE
 
 void ApplyFlow() { planner.refresh_e_factor(0); }
 void SetFlow() { SetPIntOnClick(MIN_PRINT_FLOW, MAX_PRINT_FLOW, ApplyFlow); }
 
 // Bed Tramming
-TERN(HAS_BED_PROBE, float, void) Tram(uint8_t point) {
-  char cmd[100] = "";
-  #if HAS_BED_PROBE
-    static bool inLev = false;
-    float xpos = 0, ypos = 0, zval = 0, margin = 0;
-    char str_1[6] = "", str_2[6] = "", str_3[6] = "";
-    if (inLev) return NAN;
-    margin = HMI_data.FullManualTramming ? 30 : PROBING_MARGIN;
-  #else
-    int16_t xpos = 0, ypos = 0;
-    int16_t margin = 30;
-  #endif
 
+void TramXY(const uint8_t point, const float &margin, float &x, float &y) {
   switch (point) {
     case 0:
       LCD_MESSAGE(MSG_LEVBED_FL);
-      xpos = ypos = margin;
+      x = y = margin;
       break;
     case 1:
       LCD_MESSAGE(MSG_LEVBED_FR);
-      xpos = X_BED_SIZE - margin; ypos = margin;
+      x = X_BED_SIZE - margin; y = margin;
       break;
     case 2:
       LCD_MESSAGE(MSG_LEVBED_BR);
-      xpos = X_BED_SIZE - margin; ypos = Y_BED_SIZE - margin;
+      x = X_BED_SIZE - margin; y = Y_BED_SIZE - margin;
       break;
     case 3:
       LCD_MESSAGE(MSG_LEVBED_BL);
-      xpos = margin; ypos = Y_BED_SIZE - margin;
+      x = margin; y = Y_BED_SIZE - margin;
       break;
     case 4:
       LCD_MESSAGE(MSG_LEVBED_C);
-      xpos = X_BED_SIZE / 2; ypos = Y_BED_SIZE / 2;
+      x = X_CENTER; y = Y_CENTER;
       break;
   }
+}
 
-  planner.synchronize();
+#if HAS_BED_PROBE
 
-  #if HAS_BED_PROBE
+  float Tram(const uint8_t point) {
+    char cmd[100] = "";
+    static bool inLev = false;
+    float xpos = 0, ypos = 0, zval = 0, margin = 0;
+    char str_1[6] = "", str_2[6] = "", str_3[6] = "";
+    if (inLev) return NAN;
+    margin = HMI_data.FullManualTramming ? 30 : PROBING_MARGIN;
+
+    TramXY(point, margin, xpos, ypos);
 
     if (HMI_data.FullManualTramming) {
-      planner.synchronize();
       sprintf_P(cmd, PSTR("M420S0\nG28O\nG90\nG0Z5F300\nG0X%sY%sF5000\nG0Z0F300"),
         dtostrf(xpos, 1, 1, str_1),
         dtostrf(ypos, 1, 1, str_2)
       );
       queue.inject(cmd);
     }
     else {
+      // AUTO_BED_LEVELING_BILINEAR does not define MESH_INSET
+      #ifndef MESH_MIN_X
+        #define MESH_MIN_X (_MAX(X_MIN_BED + PROBING_MARGIN, X_MIN_POS))
+      #endif
+      #ifndef MESH_MIN_Y
+        #define MESH_MIN_Y (_MAX(Y_MIN_BED + PROBING_MARGIN, Y_MIN_POS))
+      #endif
+      #ifndef MESH_MAX_X
+        #define MESH_MAX_X (_MIN(X_MAX_BED - (PROBING_MARGIN), X_MAX_POS))
+      #endif
+      #ifndef MESH_MAX_Y
+        #define MESH_MAX_Y (_MIN(Y_MAX_BED - (PROBING_MARGIN), Y_MAX_POS))
+      #endif
+
       LIMIT(xpos, MESH_MIN_X, MESH_MAX_X);
       LIMIT(ypos, MESH_MIN_Y, MESH_MAX_Y);
       probe.stow();
       gcode.process_subcommands_now(F("M420S0\nG28O"));
       inLev = true;
       zval = probe.probe_at_point(xpos, ypos, PROBE_PT_STOW);
       if (isnan(zval))
         LCD_MESSAGE(MSG_ZPROBE_OUT);
       else {
         sprintf_P(cmd, PSTR("X:%s, Y:%s, Z:%s"),
           dtostrf(xpos, 1, 1, str_1),
           dtostrf(ypos, 1, 1, str_2),
           dtostrf(zval, 1, 2, str_3)
         );
         ui.set_status(cmd);
       }
       inLev = false;
     }
     return zval;
+  }
 
-  #else // !HAS_BED_PROBE
+#else
 
-    sprintf_P(cmd, PSTR("M420S0\nG28O\nG90\nG0Z5F300\nG0X%iY%iF5000\nG0Z0F300"), xpos, ypos);
+  void Tram(const uint8_t point) {
+    float xpos = 0, ypos = 0, margin = 30;
+    TramXY(point, margin, xpos, ypos);
+
+    char cmd[100] = "", str_1[6] = "", str_2[6] = "";
+    sprintf_P(cmd, PSTR("M420S0\nG28O\nG90\nG0Z5F300\nG0X%sY%sF5000\nG0Z0F300"), dtostrf(xpos, 1, 1, str_1), dtostrf(ypos, 1, 1, str_2));
     queue.inject(cmd);
+  }
 
-  #endif
-}
+#endif
 
 void TramFL() { Tram(0); }
 void TramFR() { Tram(1); }
 void TramBR() { Tram(2); }
 void TramBL() { Tram(3); }
 void TramC () { Tram(4); }
 
 #if HAS_BED_PROBE
 
   void Trammingwizard() {
@@ -3599,32 +3671,32 @@ void Draw_Steps_Menu() {
   void SetMeshActive() {
     set_bed_leveling_enabled(!planner.leveling_active);
     Draw_Chkb_Line(CurrentMenu->line(), planner.leveling_active);
     DWIN_UpdateLCD();
   }
 
   #if BOTH(HAS_HEATED_BED, PREHEAT_BEFORE_LEVELING)
     void SetBedLevT() { SetPIntOnClick(MIN_BEDTEMP, MAX_BEDTEMP); }
   #endif
 
-  uint8_t mesh_x = 0;
-  uint8_t mesh_y = 0;
-  #define Z_OFFSET_MIN -3
-  #define Z_OFFSET_MAX  3
-
-  void LiveEditMesh() { ((MenuItemPtrClass*)EditZValueItem)->value = &bedlevel.z_values[HMI_value.Select ? mesh_x : MenuData.Value][HMI_value.Select ? MenuData.Value : mesh_y]; EditZValueItem->redraw(); }
-  void ApplyEditMeshX() { mesh_x = MenuData.Value; }
-  void SetEditMeshX() { HMI_value.Select = 0; SetIntOnClick(0, GRID_MAX_POINTS_X - 1, mesh_x, ApplyEditMeshX, LiveEditMesh); }
-  void ApplyEditMeshY() { mesh_y = MenuData.Value; }
-  void SetEditMeshY() { HMI_value.Select = 1; SetIntOnClick(0, GRID_MAX_POINTS_Y - 1, mesh_y, ApplyEditMeshY, LiveEditMesh); }
-  void SetEditZValue() { SetPFloatOnClick(Z_OFFSET_MIN, Z_OFFSET_MAX, 3); }
-
+  #if ENABLED(MESH_EDIT_MENU)
+    uint8_t mesh_x = 0, mesh_y = 0;
+    #define Z_OFFSET_MIN -3
+    #define Z_OFFSET_MAX  3
+
+    void LiveEditMesh() { ((MenuItemPtrClass*)EditZValueItem)->value = &bedlevel.z_values[HMI_value.Select ? mesh_x : MenuData.Value][HMI_value.Select ? MenuData.Value : mesh_y]; EditZValueItem->redraw(); }
+    void ApplyEditMeshX() { mesh_x = MenuData.Value; }
+    void SetEditMeshX() { HMI_value.Select = 0; SetIntOnClick(0, GRID_MAX_POINTS_X - 1, mesh_x, ApplyEditMeshX, LiveEditMesh); }
+    void ApplyEditMeshY() { mesh_y = MenuData.Value; }
+    void SetEditMeshY() { HMI_value.Select = 1; SetIntOnClick(0, GRID_MAX_POINTS_Y - 1, mesh_y, ApplyEditMeshY, LiveEditMesh); }
+    void SetEditZValue() { SetPFloatOnClick(Z_OFFSET_MIN, Z_OFFSET_MAX, 3); }
+  #endif
 #endif
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
 
   void ApplyUBLSlot() { bedlevel.storage_slot = MenuData.Value; }
   void SetUBLSlot() { SetIntOnClick(0, settings.calc_num_meshes() - 1, bedlevel.storage_slot, ApplyUBLSlot); }
   void onDrawUBLSlot(MenuItemClass* menuitem, int8_t line) {
     if (bedlevel.storage_slot < 0) bedlevel.storage_slot = 0;
     onDrawIntMenu(menuitem, line, bedlevel.storage_slot);
   }

commit b523ddf1b2820488c6cc46887ee85e8a781ce726
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 19 06:05:52 2022 -0500

    ‚ôªÔ∏è Common Bed Leveling object name, accessors (#24214)

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index cae29e5b28..122136c1a0 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -3604,76 +3604,76 @@ void Draw_Steps_Menu() {
 
   #if BOTH(HAS_HEATED_BED, PREHEAT_BEFORE_LEVELING)
     void SetBedLevT() { SetPIntOnClick(MIN_BEDTEMP, MAX_BEDTEMP); }
   #endif
 
   uint8_t mesh_x = 0;
   uint8_t mesh_y = 0;
   #define Z_OFFSET_MIN -3
   #define Z_OFFSET_MAX  3
 
-  void LiveEditMesh() { ((MenuItemPtrClass*)EditZValueItem)->value = &Z_VALUES_ARR[HMI_value.Select ? mesh_x : MenuData.Value][HMI_value.Select ? MenuData.Value : mesh_y]; EditZValueItem->redraw(); }
+  void LiveEditMesh() { ((MenuItemPtrClass*)EditZValueItem)->value = &bedlevel.z_values[HMI_value.Select ? mesh_x : MenuData.Value][HMI_value.Select ? MenuData.Value : mesh_y]; EditZValueItem->redraw(); }
   void ApplyEditMeshX() { mesh_x = MenuData.Value; }
   void SetEditMeshX() { HMI_value.Select = 0; SetIntOnClick(0, GRID_MAX_POINTS_X - 1, mesh_x, ApplyEditMeshX, LiveEditMesh); }
   void ApplyEditMeshY() { mesh_y = MenuData.Value; }
   void SetEditMeshY() { HMI_value.Select = 1; SetIntOnClick(0, GRID_MAX_POINTS_Y - 1, mesh_y, ApplyEditMeshY, LiveEditMesh); }
   void SetEditZValue() { SetPFloatOnClick(Z_OFFSET_MIN, Z_OFFSET_MAX, 3); }
 
 #endif
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
 
-  void ApplyUBLSlot() { ubl.storage_slot = MenuData.Value; }
-  void SetUBLSlot() { SetIntOnClick(0, settings.calc_num_meshes() - 1, ubl.storage_slot, ApplyUBLSlot); }
+  void ApplyUBLSlot() { bedlevel.storage_slot = MenuData.Value; }
+  void SetUBLSlot() { SetIntOnClick(0, settings.calc_num_meshes() - 1, bedlevel.storage_slot, ApplyUBLSlot); }
   void onDrawUBLSlot(MenuItemClass* menuitem, int8_t line) {
-    if (ubl.storage_slot < 0) ubl.storage_slot = 0;
-    onDrawIntMenu(menuitem, line, ubl.storage_slot);
+    if (bedlevel.storage_slot < 0) bedlevel.storage_slot = 0;
+    onDrawIntMenu(menuitem, line, bedlevel.storage_slot);
   }
 
   void ApplyUBLTiltGrid() { ubl_tools.tilt_grid = MenuData.Value; }
   void SetUBLTiltGrid() { SetIntOnClick(1, 3, ubl_tools.tilt_grid, ApplyUBLTiltGrid); }
 
   void UBLTiltMesh() {
-    if (ubl.storage_slot < 0) ubl.storage_slot = 0;
+    if (bedlevel.storage_slot < 0) bedlevel.storage_slot = 0;
     char buf[15];
     if (ubl_tools.tilt_grid > 1) {
       sprintf_P(buf, PSTR("G28O\nG29 J%i"), ubl_tools.tilt_grid);
       gcode.process_subcommands_now(buf);
     }
     else
       gcode.process_subcommands_now(F("G28O\nG29J"));
     LCD_MESSAGE(MSG_UBL_MESH_TILTED);
   }
 
   void UBLSmartFillMesh() {
-    ubl.smart_fill_mesh();
+    bedlevel.smart_fill_mesh();
     LCD_MESSAGE(MSG_UBL_MESH_FILLED);
   }
 
   bool UBLValidMesh() {
     const bool valid = ubl_tools.validate();
-    if (!valid) ubl.invalidate();
+    if (!valid) bedlevel.invalidate();
     return valid;
   }
 
   void UBLSaveMesh() {
-    if (ubl.storage_slot < 0) ubl.storage_slot = 0;
-    settings.store_mesh(ubl.storage_slot);
-    ui.status_printf(0, GET_TEXT_F(MSG_MESH_SAVED), ubl.storage_slot);
+    if (bedlevel.storage_slot < 0) bedlevel.storage_slot = 0;
+    settings.store_mesh(bedlevel.storage_slot);
+    ui.status_printf(0, GET_TEXT_F(MSG_MESH_SAVED), bedlevel.storage_slot);
     DONE_BUZZ(true);
   }
 
   void UBLLoadMesh() {
-    if (ubl.storage_slot < 0) ubl.storage_slot = 0;
-    settings.load_mesh(ubl.storage_slot);
+    if (bedlevel.storage_slot < 0) bedlevel.storage_slot = 0;
+    settings.load_mesh(bedlevel.storage_slot);
     if (UBLValidMesh()) {
-      ui.status_printf(0, GET_TEXT_F(MSG_MESH_LOADED), ubl.storage_slot);
+      ui.status_printf(0, GET_TEXT_F(MSG_MESH_LOADED), bedlevel.storage_slot);
       DONE_BUZZ(true);
     }
     else {
       LCD_MESSAGE_F("Invalid Mesh Loaded");
       DONE_BUZZ(false);
     }
   }
 
 #endif // AUTO_BED_LEVELING_UBL
 
@@ -3684,21 +3684,21 @@ void Draw_Steps_Menu() {
       BACK_ITEM(Draw_AdvancedSettings_Menu);
       #if BOTH(HAS_HEATED_BED, PREHEAT_BEFORE_LEVELING)
         EDIT_ITEM_F(ICON_Temperature, MSG_UBL_SET_TEMP_BED, onDrawPIntMenu, SetBedLevT, &HMI_data.BedLevT);
       #endif
       EDIT_ITEM_F(ICON_SetZOffset, MSG_Z_FADE_HEIGHT, onDrawPFloatMenu, SetMeshFadeHeight, &planner.z_fade_height);
       EDIT_ITEM_F(ICON_UBLActive, MSG_ACTIVATE_MESH, onDrawChkbMenu, SetMeshActive, &planner.leveling_active);
       #if HAS_BED_PROBE
         MENU_ITEM_F(ICON_Level, MSG_AUTO_MESH, onDrawMenuItem, AutoLev);
       #endif
       #if ENABLED(AUTO_BED_LEVELING_UBL)
-        EDIT_ITEM_F(ICON_UBLActive, MSG_UBL_STORAGE_SLOT, onDrawUBLSlot, SetUBLSlot, &ubl.storage_slot);
+        EDIT_ITEM_F(ICON_UBLActive, MSG_UBL_STORAGE_SLOT, onDrawUBLSlot, SetUBLSlot, &bedlevel.storage_slot);
         MENU_ITEM_F(ICON_UBLActive, MSG_UBL_SAVE_MESH, onDrawMenuItem, UBLSaveMesh);
         MENU_ITEM_F(ICON_UBLActive, MSG_UBL_LOAD_MESH, onDrawMenuItem, UBLLoadMesh);
         EDIT_ITEM_F(ICON_UBLActive, MSG_UBL_TILTING_GRID, onDrawPInt8Menu, SetUBLTiltGrid, &ubl_tools.tilt_grid);
         MENU_ITEM_F(ICON_UBLActive, MSG_UBL_TILT_MESH, onDrawMenuItem, UBLTiltMesh);
         MENU_ITEM_F(ICON_UBLActive, MSG_UBL_SMART_FILLIN, onDrawMenuItem, UBLSmartFillMesh);
       #endif
       #if ENABLED(MESH_EDIT_MENU)
         MENU_ITEM_F(ICON_UBLActive, MSG_EDIT_MESH, onDrawSubMenu, Draw_EditMesh_Menu);
       #endif
       MENU_ITEM_F(ICON_MeshViewer, MSG_MESH_VIEW, onDrawSubMenu, DWIN_MeshViewer);
@@ -3707,19 +3707,19 @@ void Draw_Steps_Menu() {
   }
 
   #if ENABLED(MESH_EDIT_MENU)
     void Draw_EditMesh_Menu() {
       checkkey = Menu;
       if (SetMenu(EditMeshMenu, GET_TEXT_F(MSG_EDIT_MESH), 4)) {
         mesh_x = mesh_y = 0;
         BACK_ITEM(Draw_MeshSet_Menu);
         EDIT_ITEM_F(ICON_UBLActive, MSG_MESH_X, onDrawPInt8Menu, SetEditMeshX, &mesh_x);
         EDIT_ITEM_F(ICON_UBLActive, MSG_MESH_Y, onDrawPInt8Menu, SetEditMeshY, &mesh_y);
-        EditZValueItem = EDIT_ITEM_F(ICON_UBLActive, MSG_MESH_EDIT_Z, onDrawPFloat3Menu, SetEditZValue, &Z_VALUES_ARR[mesh_x][mesh_y]);
+        EditZValueItem = EDIT_ITEM_F(ICON_UBLActive, MSG_MESH_EDIT_Z, onDrawPFloat3Menu, SetEditZValue, &bedlevel.z_values[mesh_x][mesh_y]);
       }
       UpdateMenu(EditMeshMenu);
     }
   #endif
 
 #endif // HAS_MESH
 
 #endif // DWIN_LCD_PROUI

commit a65e4edb1c794dcd22980f3cce9bf2993da1514b
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Tue May 17 15:44:30 2022 -0500

    üö∏ ProUI APRIL2022 updates (#24084)

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 68099f2076..cae29e5b28 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -16,22 +16,22 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 /**
  * DWIN Enhanced implementation for PRO UI
  * Author: Miguel A. Risco-Castillo (MRISCOC)
- * Version: 3.15.2
- * Date: 2022/03/01
+ * Version: 3.17.2
+ * Date: 2022/04/08
  */
 
 #include "../../../inc/MarlinConfig.h"
 
 #if ENABLED(DWIN_LCD_PROUI)
 
 #include "dwin.h"
 #include "menus.h"
 #include "dwin_popup.h"
 
@@ -57,62 +57,62 @@
 #endif
 
 #if ENABLED(EEPROM_SETTINGS)
   #include "../../../module/settings.h"
 #endif
 
 #if ENABLED(HOST_ACTION_COMMANDS)
   #include "../../../feature/host_actions.h"
 #endif
 
-#if ANY(AUTO_BED_LEVELING_BILINEAR, AUTO_BED_LEVELING_LINEAR, AUTO_BED_LEVELING_3POINT) && DISABLED(PROBE_MANUALLY)
+#if DISABLED(PROBE_MANUALLY) && ANY(AUTO_BED_LEVELING_BILINEAR, AUTO_BED_LEVELING_LINEAR, AUTO_BED_LEVELING_3POINT)
   #define HAS_ONESTEP_LEVELING 1
 #endif
 
 #if HAS_MESH || HAS_ONESTEP_LEVELING
   #include "../../../feature/bedlevel/bedlevel.h"
 #endif
 
 #if HAS_BED_PROBE
   #include "../../../module/probe.h"
 #endif
 
 #ifdef BLTOUCH_HS_MODE
   #include "../../../feature/bltouch.h"
 #endif
 
 #if ANY(BABYSTEPPING, HAS_BED_PROBE, HAS_WORKSPACE_OFFSET)
   #define HAS_ZOFFSET_ITEM 1
-  #if !HAS_BED_PROBE && ENABLED(BABYSTEPPING)
-    #define JUST_BABYSTEP 1
-  #endif
-  #if EITHER(BABYSTEP_ZPROBE_OFFSET, JUST_BABYSTEP)
+  #if ENABLED(BABYSTEPPING)
     #include "../../../feature/babystep.h"
+    #if !HAS_BED_PROBE
+      #define JUST_BABYSTEP 1
+    #endif
   #endif
 #endif
 
 #if ENABLED(POWER_LOSS_RECOVERY)
   #include "../../../feature/powerloss.h"
 #endif
 
-#if HAS_GCODE_PREVIEW
-  #include "gcode_preview.h"
-#endif
-
 #if HAS_ESDIAG
   #include "endstop_diag.h"
 #endif
 
 #if HAS_MESH
   #include "meshviewer.h"
 #endif
 
+#if ENABLED(AUTO_BED_LEVELING_UBL)
+  #include "ubl_tools.h"
+#endif
+
 #if ENABLED(PRINTCOUNTER)
   #include "printstats.h"
 #endif
 
 #if ENABLED(CASE_LIGHT_MENU)
   #include "../../../feature/caselight.h"
 #endif
 
 #if ENABLED(LED_CONTROL_MENU)
   #include "../../../feature/leds/leds.h"
@@ -136,43 +136,40 @@
 #define MIN_PRINT_SPEED  10
 #define MAX_PRINT_SPEED 999
 
 // Print flow limit
 #define MIN_PRINT_FLOW   10
 #define MAX_PRINT_FLOW   299
 
 // Load and Unload limits
 #define MAX_LOAD_UNLOAD  500
 
-// Feedspeed limit (max feedspeed = DEFAULT_MAX_FEEDRATE * 2)
+// Feedspeed limit (max feedspeed = MAX_FEEDRATE_EDIT_VALUES)
 #define MIN_MAXFEEDSPEED      1
 #define MIN_MAXACCELERATION   1
 #define MIN_MAXJERK           0.1
 #define MIN_STEP              1
 #define MAX_STEP              999.9
 
-// Extruder's temperature limits
-#define MIN_ETEMP  HEATER_0_MINTEMP
-#define MAX_ETEMP  (HEATER_0_MAXTEMP - HOTEND_OVERSHOOT)
+// Editable temperature limits
+#define MIN_ETEMP  0
+#define MAX_ETEMP  (HEATER_0_MAXTEMP - (HOTEND_OVERSHOOT))
+#define MIN_BEDTEMP 0
+#define MAX_BEDTEMP BED_MAX_TARGET
 
 #define FEEDRATE_E      (60)
 
-// Minimum unit (0.1) : multiple (10)
-#define UNITFDIGITS 1
-#define MINUNITMULT POW(10, UNITFDIGITS)
-
-#define ENCODER_WAIT_MS                  20
 #define DWIN_VAR_UPDATE_INTERVAL         1024
 #define DWIN_SCROLL_UPDATE_INTERVAL      SEC_TO_MS(2)
 #define DWIN_REMAIN_TIME_UPDATE_INTERVAL SEC_TO_MS(20)
 
-#define BABY_Z_VAR TERN(HAS_BED_PROBE, probe.offset.z, dwin_zoffset)
+#define BABY_Z_VAR TERN(HAS_BED_PROBE, probe.offset.z, HMI_data.ManualZOffset)
 
 // Structs
 HMI_value_t HMI_value;
 HMI_flag_t HMI_flag{0};
 HMI_data_t HMI_data;
 
 millis_t dwin_heat_time = 0;
 
 uint8_t checkkey = 255, last_checkkey = MainMenu;
 
@@ -196,37 +193,33 @@ typedef struct {
   bool changed() { bool c = (now != last); if (c) last = now; return c; }
   bool dec() { if (now) now--; return changed(); }
   bool inc(uint8_t v) { if (now < (v - 1)) now++; else now = (v - 1); return changed(); }
 } select_t;
 
 select_t select_page{0}, select_file{0}, select_print{0};
 uint8_t index_file     = MROWS;
 
 bool hash_changed = true; // Flag to know if message status was changed
 
-constexpr float max_feedrate_edit_values[]        = DEFAULT_MAX_FEEDRATE;
-constexpr float max_acceleration_edit_values[]    = DEFAULT_MAX_ACCELERATION;
+constexpr float max_feedrate_edit_values[] = MAX_FEEDRATE_EDIT_VALUES;
+constexpr float max_acceleration_edit_values[] = MAX_ACCEL_EDIT_VALUES;
 
 #if HAS_CLASSIC_JERK
-  constexpr float max_jerk_edit_values[]          = { DEFAULT_XJERK, DEFAULT_YJERK, DEFAULT_ZJERK, DEFAULT_EJERK };
+  constexpr float max_jerk_edit_values[] = MAX_JERK_EDIT_VALUES;
 #endif
 
 static uint8_t _percent_done = 0;
 static uint32_t _remain_time = 0;
 
 // Additional Aux Host Support
 static bool sdprint = false;
 
-#if HAS_ZOFFSET_ITEM
-  float dwin_zoffset = 0, last_zoffset = 0;
-#endif
-
 #if HAS_HOTEND
   float last_E = 0;
 #endif
 
 // New menu system pointers
 MenuClass *PrepareMenu = nullptr;
 MenuClass *TrammingMenu = nullptr;
 MenuClass *MoveMenu = nullptr;
 MenuClass *ControlMenu = nullptr;
 MenuClass *AdvancedSettings = nullptr;
@@ -260,26 +253,36 @@ MenuClass *BedPIDMenu = nullptr;
 #endif
 #if ENABLED(LED_CONTROL_MENU)
   MenuClass *LedControlMenu = nullptr;
 #endif
 #if HAS_BED_PROBE
   MenuClass *ZOffsetWizMenu = nullptr;
 #endif
 #if ENABLED(INDIVIDUAL_AXIS_HOMING_SUBMENU)
   MenuClass *HomingMenu = nullptr;
 #endif
+#if ENABLED(FWRETRACT)
+  MenuClass *FWRetractMenu = nullptr;
+#endif
+#if HAS_MESH
+  MenuClass *MeshMenu = nullptr;
+  #if ENABLED(MESH_EDIT_MENU)
+    MenuClass *EditMeshMenu = nullptr;
+  #endif
+#endif
 
 // Updatable menuitems pointers
 MenuItemClass *HotendTargetItem = nullptr;
 MenuItemClass *BedTargetItem = nullptr;
 MenuItemClass *FanSpeedItem = nullptr;
 MenuItemClass *MMeshMoveZItem = nullptr;
+MenuItemClass *EditZValueItem = nullptr;
 
 #define DWIN_LANGUAGE_EEPROM_ADDRESS 0x01   // Between 0x01 and 0x63 (EEPROM_OFFSET-1)
                                             // BL24CXX::check() uses 0x00
 
 inline bool HMI_IsChinese() { return HMI_flag.language == DWIN_CHINESE; }
 
 void HMI_SetLanguageCache() {
   DWIN_JPG_CacheTo1(HMI_IsChinese() ? Language_Chinese : Language_English);
 }
 
@@ -486,20 +489,25 @@ void Popup_window_PauseOrStop() {
     else DWIN_Show_Popup(toohigh ? ICON_TempTooHigh : ICON_TempTooLow, F("Nozzle or Bed temperature"), toohigh ? F("is too high") : F("is too low"), BTN_Continue);
   }
 #endif
 
 // Draw status line
 void DWIN_DrawStatusLine(const char *text) {
   DWIN_Draw_Rectangle(1, HMI_data.StatusBg_Color, 0, STATUS_Y, DWIN_WIDTH, STATUS_Y + 20);
   if (text) DWINUI::Draw_CenteredString(HMI_data.StatusTxt_Color, STATUS_Y + 2, text);
 }
 
+void DWIN_DrawStatusLine(FSTR_P fstr) {
+  DWIN_Draw_Rectangle(1, HMI_data.StatusBg_Color, 0, STATUS_Y, DWIN_WIDTH, STATUS_Y + 20);
+  if (fstr) DWINUI::Draw_CenteredString(HMI_data.StatusTxt_Color, STATUS_Y + 2, fstr);
+}
+
 // Clear & reset status line
 void DWIN_ResetStatusLine() {
   ui.status_message[0] = 0;
   DWIN_CheckStatusMessage();
 }
 
 // Djb2 hash algorithm
 void DWIN_CheckStatusMessage() {
   static uint32_t old_hash = 0;
   char * str = &ui.status_message[0];
@@ -624,40 +632,40 @@ void Draw_PrintProcess() {
   ICON_ResumeOrPause();
   ICON_Stop();
 }
 
 void Goto_PrintProcess() {
   if (checkkey == PrintProcess)
     ICON_ResumeOrPause();
   else {
     checkkey = PrintProcess;
     Draw_PrintProcess();
+    TERN_(DASH_REDRAW, DWIN_RedrawDash());
   }
   DWIN_UpdateLCD();
 }
 
 void Draw_PrintDone() {
   // show percent bar and value
   _percent_done = 100;
   _remain_time = 0;
 
   Title.ShowCaption(GET_TEXT_F(MSG_PRINT_DONE));
   DWINUI::ClearMainArea();
   DWIN_Print_Header(nullptr);
   Draw_Print_ProgressBar();
   Draw_Print_Labels();
   DWINUI::Draw_Icon(ICON_PrintTime, 15, 173);
   DWINUI::Draw_Icon(ICON_RemainTime, 150, 171);
   Draw_Print_ProgressElapsed();
   Draw_Print_ProgressRemain();
-  // show print done confirm
-  DWINUI::Draw_Button(BTN_Confirm, 86, 273);
+  DWINUI::Draw_Button(BTN_Continue, 86, 273);
 }
 
 void Goto_PrintDone() {
   wait_for_user = true;
   if (checkkey != PrintDone) {
     checkkey = PrintDone;
     Draw_PrintDone();
     DWIN_UpdateLCD();
   }
 }
@@ -739,30 +747,27 @@ void update_variable() {
   #endif
   #if HAS_FAN
     static uint8_t _fanspeed = 0;
     const bool _new_fanspeed = _fanspeed != thermalManager.fan_speed[0];
     if (_new_fanspeed) _fanspeed = thermalManager.fan_speed[0];
   #endif
 
   if (checkkey == Menu && (CurrentMenu == TuneMenu || CurrentMenu == TemperatureMenu)) {
     // Tune page temperature update
     #if HAS_HOTEND
-      if (_new_hotend_target)
-        HotendTargetItem->draw(CurrentMenu->line(HotendTargetItem->pos));
+      if (_new_hotend_target) HotendTargetItem->redraw();
     #endif
     #if HAS_HEATED_BED
-      if (_new_bed_target)
-        BedTargetItem->draw(CurrentMenu->line(BedTargetItem->pos));
+      if (_new_bed_target) BedTargetItem->redraw();
     #endif
     #if HAS_FAN
-      if (_new_fanspeed)
-        FanSpeedItem->draw(CurrentMenu->line(FanSpeedItem->pos));
+      if (_new_fanspeed) FanSpeedItem->redraw();
     #endif
   }
 
   // Bottom temperature update
 
   #if HAS_HOTEND
     if (_new_hotend_temp)
       DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 28, 384, _hotendtemp);
     if (_new_hotend_target)
       DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 25 + 4 * STAT_CHR_W + 6, 384, _hotendtarget);
@@ -1006,33 +1011,33 @@ void DWIN_Draw_Dashboard() {
 
     DWINUI::Draw_Icon(ICON_StepE, 112, 417);
     DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 116 + 2 * STAT_CHR_W, 417, planner.flow_percentage[0]);
     DWINUI::Draw_String(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 116 + 5 * STAT_CHR_W + 2, 417, F("%"));
   #endif
 
   #if HAS_HEATED_BED
     DWINUI::Draw_Icon(ICON_BedTemp, 10, 416);
     DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 28, 417, thermalManager.wholeDegBed());
     DWINUI::Draw_String(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 25 + 3 * STAT_CHR_W + 5, 417, F("/"));
-    DWINUI::Draw_Int(true, true, 0, DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 25 + 4 * STAT_CHR_W + 6, 417, thermalManager.degTargetBed());
+    DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 25 + 4 * STAT_CHR_W + 6, 417, thermalManager.degTargetBed());
   #endif
 
   DWINUI::Draw_Icon(ICON_Speed, 113, 383);
   DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 116 + 2 * STAT_CHR_W, 384, feedrate_percentage);
   DWINUI::Draw_String(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 116 + 5 * STAT_CHR_W + 2, 384, F("%"));
 
   #if HAS_FAN
     DWINUI::Draw_Icon(ICON_FanSpeed, 187, 383);
     DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 195 + 2 * STAT_CHR_W, 384, thermalManager.fan_speed[0]);
   #endif
 
-  #if HAS_ZOFFSET_ITEM
+  #if BOTH(BABYSTEPPING, HAS_BED_PROBE)
     DWINUI::Draw_Icon(planner.leveling_active ? ICON_SetZOffset : ICON_Zoffset, 187, 416);
   #endif
 
   DWINUI::Draw_Signed_Float(DWIN_FONT_STAT, HMI_data.Indicator_Color,  HMI_data.Background_Color, 2, 2, 204, 417, BABY_Z_VAR);
 
   DWIN_Draw_Rectangle(1, HMI_data.SplitLine_Color, 0, 449, DWIN_WIDTH, 451);
 
   DWINUI::Draw_Icon(ICON_MaxSpeedX,  10, 456);
   DWINUI::Draw_Icon(ICON_MaxSpeedY,  95, 456);
   DWINUI::Draw_Icon(ICON_MaxSpeedZ, 180, 456);
@@ -1068,20 +1073,21 @@ void Draw_Info_Menu() {
     DWIN_Draw_HLine(HMI_data.SplitLine_Color, 16, MBASE(2) + i * 73, 240);
   }
 }
 
 void Draw_Print_File_Menu() {
   if (HMI_IsChinese())
     Title.FrameCopy(0, 31, 56, 14);    // "Print file"
   else
     Title.ShowCaption(GET_TEXT_F(MSG_MEDIA_MENU));
   Redraw_SD_List();
+  TERN_(DASH_REDRAW, DWIN_RedrawDash());
 }
 
 // Main Process
 void HMI_MainMenu() {
   EncoderState encoder_diffState = get_encoder_state();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
 
   if (encoder_diffState == ENCODER_DIFF_CW) {
     if (select_page.inc(PAGE_COUNT)) {
       switch (select_page.now) {
@@ -1278,66 +1284,57 @@ void HMI_Printing() {
       case PRINT_STOP:
         return Goto_Popup(Popup_window_PauseOrStop, onClick_PauseOrStop);
       default: break;
     }
   }
   DWIN_UpdateLCD();
 }
 
 #include "../../../libs/buzzer.h"
 
-void HMI_AudioFeedback(const bool success/*=true*/) { DONE_BUZZ(success); }
-
 void Draw_Main_Area() {
   switch (checkkey) {
     case MainMenu:               Draw_Main_Menu(); break;
     case SelectFile:             Draw_Print_File_Menu(); break;
     case PrintProcess:           Draw_PrintProcess(); break;
     case PrintDone:              Draw_PrintDone(); break;
     #if HAS_ESDIAG
       case ESDiagProcess:        Draw_EndStopDiag(); break;
     #endif
     case Popup:                  popupDraw(); break;
     case Locked:                 lockScreen.draw(); break;
     case Menu:
     case SetInt:
     case SetPInt:
     case SetIntNoDraw:
     case SetFloat:
-    case SetPFloat:              CurrentMenu->draw(); break;
+    case SetPFloat:              ReDrawMenu(); break;
     default: break;
   }
 }
 
 void HMI_ReturnScreen() {
   checkkey = last_checkkey;
   wait_for_user = false;
   Draw_Main_Area();
 }
 
 void HMI_WaitForUser() {
   get_encoder_state();
   if (!wait_for_user) {
     switch (checkkey) {
       case PrintDone:
         select_page.reset();
         Goto_Main_Menu();
         break;
-      #if HAS_ONESTEP_LEVELING
-      case Leveling:
-        //TERN_(ProUI, ProEx.StopLeveling());
-        HMI_ReturnScreen();
-        break;
-      #endif
-      default:
-        HMI_ReturnScreen();
-        break;
+      TERN_(HAS_ONESTEP_LEVELING, case Leveling:)
+      default: HMI_ReturnScreen(); break;
     }
   }
 }
 
 void HMI_Init() {
   DWINUI::Draw_Box(1, Color_Black, {5, 220, DWIN_WIDTH-5, DWINUI::fontHeight()});
   DWINUI::Draw_CenteredString(Color_White, 220, F("Professional Firmware "));
   for (uint16_t t = 0; t <= 100; t += 2) {
     DWINUI::Draw_Icon(ICON_Bar, 15, 260);
     DWIN_Draw_Rectangle(1, HMI_data.Background_Color, 15 + t * 242 / 100, 260, 257, 280);
@@ -1347,31 +1344,31 @@ void HMI_Init() {
   HMI_SetLanguage();
 }
 
 void EachMomentUpdate() {
   static millis_t next_var_update_ms = 0, next_rts_update_ms = 0, next_status_update_ms = 0;
   const millis_t ms = millis();
 
   if (ELAPSED(ms, next_var_update_ms)) {
     next_var_update_ms = ms + DWIN_VAR_UPDATE_INTERVAL;
     update_variable();
-    switch (checkkey) {
-      #if HAS_ESDIAG
-        case ESDiagProcess:
-          ESDiag.Update();
-          break;
-      #endif
-      default:
-        break;
-    }
+    #if HAS_ESDIAG
+      if (checkkey == ESDiagProcess) ESDiag.Update();
+    #endif
   }
 
+  #if HAS_STATUS_MESSAGE_TIMEOUT
+    bool did_expire = ui.status_reset_callback && (*ui.status_reset_callback)();
+    did_expire |= ui.status_message_expire_ms && ELAPSED(ms, ui.status_message_expire_ms);
+    if (did_expire) ui.reset_status();
+  #endif
+
   if (ELAPSED(ms, next_status_update_ms)) {
     next_status_update_ms = ms + 500;
     DWIN_DrawStatusMessage();
   }
 
   if (PENDING(ms, next_rts_update_ms)) return;
   next_rts_update_ms = ms + DWIN_SCROLL_UPDATE_INTERVAL;
 
   if (checkkey == PrintProcess) { // print process
 
@@ -1395,21 +1392,21 @@ void EachMomentUpdate() {
       HMI_flag.abort_flag = false;
       if (!HMI_flag.abort_action) {
         HMI_flag.abort_action = true;
         ui.abort_print();
         return Goto_PrintDone();
       }
     }
 
     duration_t elapsed = print_job_timer.duration(); // print timer
 
-    if (sdprint && card.isPrinting()) {
+    if (sdprint && card.isPrinting() && !HMI_flag.percent_flag) {
       uint8_t percentDone = card.percentDone();
       if (_percent_done != percentDone) { // print percent
           _percent_done = percentDone;
           Draw_Print_ProgressBar();
         }
 
       // Estimate remaining time every 20 seconds
       static millis_t next_remain_time_update = 0;
       if (_percent_done > 1 && ELAPSED(ms, next_remain_time_update) && !HMI_flag.heat_flag && !HMI_flag.remain_flag) {
         _remain_time = (elapsed.value - dwin_heat_time) / (_percent_done * 0.01f) - (elapsed.value - dwin_heat_time);
@@ -1490,22 +1487,21 @@ void DWIN_HandleScreen() {
     case MainMenu:        HMI_MainMenu(); break;
     case Menu:            HMI_Menu(); break;
     case SetInt:          HMI_SetInt(); break;
     case SetPInt:         HMI_SetPInt(); break;
     case SetIntNoDraw:    HMI_SetIntNoDraw(); break;
     case SetFloat:        HMI_SetFloat(); break;
     case SetPFloat:       HMI_SetPFloat(); break;
     case SelectFile:      HMI_SelectFile(); break;
     case PrintProcess:    HMI_Printing(); break;
     case Popup:           HMI_Popup(); break;
-    case Leveling:        //TERN_(ProUI, HMI_WaitForUser());
-                          break;
+    case Leveling:        break;
     case Locked:          HMI_LockScreen(); break;
     case PrintDone:
     TERN_(HAS_ESDIAG, case ESDiagProcess:)
     case WaitResponse:    HMI_WaitForUser(); break;
     case Homing:
     case PidProcess:
     case NothingToDo:     break;
     default: break;
   }
 }
@@ -1534,36 +1530,51 @@ void HMI_SaveProcessID(const uint8_t id) {
 
 void DWIN_HomingStart() {
   HMI_flag.home_flag = true;
   HMI_SaveProcessID(Homing);
   Title.ShowCaption(GET_TEXT_F(MSG_HOMING));
   DWIN_Show_Popup(ICON_BLTouch, GET_TEXT_F(MSG_HOMING), GET_TEXT_F(MSG_PLEASE_WAIT));
 }
 
 void DWIN_HomingDone() {
   HMI_flag.home_flag = false;
-  dwin_zoffset = TERN0(HAS_BED_PROBE, probe.offset.z);
+  #if ENABLED(MESH_BED_LEVELING) && EITHER(BABYSTEP_ZPROBE_OFFSET, JUST_BABYSTEP)
+    planner.synchronize();
+    babystep.add_mm(Z_AXIS, HMI_data.ManualZOffset);
+  #endif
   if (HMI_flag.abort_action) DWIN_Print_Aborted(); else HMI_ReturnScreen();
 }
 
 void DWIN_LevelingStart() {
   #if HAS_ONESTEP_LEVELING
     HMI_SaveProcessID(Leveling);
     Title.ShowCaption(GET_TEXT_F(MSG_BED_LEVELING));
     DWIN_Show_Popup(ICON_AutoLeveling, GET_TEXT_F(MSG_BED_LEVELING), GET_TEXT_F(MSG_PLEASE_WAIT));
+    #if BOTH(AUTO_BED_LEVELING_UBL, PREHEAT_BEFORE_LEVELING)
+      #if HAS_HOTEND
+        if (thermalManager.degTargetHotend(0) < LEVELING_NOZZLE_TEMP)
+          thermalManager.setTargetHotend(LEVELING_NOZZLE_TEMP, 0);
+      #endif
+      #if HAS_HEATED_BED
+        if (thermalManager.degTargetBed() < HMI_data.BedLevT)
+          thermalManager.setTargetBed(HMI_data.BedLevT);
+      #endif
+      TERN_(HAS_HOTEND, thermalManager.wait_for_hotend(0));
+      TERN_(HAS_HEATED_BED, thermalManager.wait_for_bed_heating());
+    #endif
   #elif ENABLED(MESH_BED_LEVELING)
     Draw_ManualMesh_Menu();
   #endif
 }
 
 void DWIN_LevelingDone() {
-  TERN_(HAS_ONESTEP_LEVELING, if (planner.leveling_active) Goto_MeshViewer());
+  TERN_(HAS_MESH, Goto_MeshViewer());
 }
 
 #if HAS_MESH
   void DWIN_MeshUpdate(const int8_t xpos, const int8_t ypos, const_float_t zval) {
     char msg[33] = "";
     char str_1[6] = "";
     sprintf_P(msg, PSTR(S_FMT " %i/%i Z=%s"), GET_TEXT(MSG_PROBING_POINT), xpos, ypos, dtostrf(zval, 1, 2, str_1));
     ui.set_status(msg);
   }
 #endif
@@ -1599,20 +1610,21 @@ void DWIN_PidTuning(pidresult_t result) {
       checkkey = last_checkkey;
       break;
   }
 }
 
 // Started a Print Job
 void DWIN_Print_Started(const bool sd) {
   sdprint = IS_SD_PRINTING() || sd;
   _percent_done = 0;
   _remain_time = 0;
+  HMI_flag.percent_flag = false;
   HMI_flag.remain_flag = false;
   HMI_flag.pause_flag = false;
   HMI_flag.pause_action = false;
   HMI_flag.abort_flag = false;
   HMI_flag.abort_action = false;
   HMI_flag.print_finish = false;
   Goto_PrintProcess();
 }
 
 // Pause a print job
@@ -1646,23 +1658,26 @@ void DWIN_Print_Aborted() {
   TERN_(DEBUG_DWIN, SERIAL_ECHOLNPGM("DWIN_Print_Aborted"));
   HMI_flag.abort_action = false;
   wait_for_heatup = false;
   planner.finish_and_disable();
   thermalManager.cooldown();
   Goto_PrintDone();
 }
 
 // Progress Bar update
 void DWIN_M73() {
-  if (parser.seenval('P')) _percent_done = parser.byteval('P');
+  if (parser.seenval('P')) {
+    _percent_done = parser.value_byte();
+    HMI_flag.percent_flag = true;
+  }
   if (parser.seenval('R')) {
-    _remain_time = parser.ulongval('R') * 60;
+    _remain_time = parser.value_ulong() * 60;
     HMI_flag.remain_flag = true;
   }
   if (checkkey == PrintProcess) {
     Draw_Print_ProgressBar();
     Draw_Print_ProgressRemain();
     Draw_Print_ProgressElapsed();
   }
 }
 
 #if HAS_FILAMENT_SENSOR
@@ -1698,99 +1713,116 @@ void DWIN_SetDataDefaults() {
   TERN_(HAS_HEATED_BED, HMI_data.BedPidT    = PREHEAT_1_TEMP_BED);
   TERN_(HAS_HOTEND,     HMI_data.PidCycles  = 5);
   #if ENABLED(PREVENT_COLD_EXTRUSION)
     HMI_data.ExtMinT = EXTRUDE_MINTEMP;
     ApplyExtMinT();
   #endif
   #if BOTH(HAS_HEATED_BED, PREHEAT_BEFORE_LEVELING)
     HMI_data.BedLevT = LEVELING_BED_TEMP;
   #endif
   TERN_(BAUD_RATE_GCODE, SetBaud250K());
+  #if BOTH(LED_CONTROL_MENU, HAS_COLOR_LEDS)
+    leds.set_default();
+    ApplyLEDColor();
+  #endif
 }
 
 void DWIN_CopySettingsTo(char * const buff) {
-  memcpy(buff, &HMI_data, _MIN(sizeof(HMI_data), eeprom_data_size));
+  memcpy(buff, &HMI_data, eeprom_data_size);
 }
 
 void DWIN_CopySettingsFrom(const char * const buff) {
-  // (void *)-> Avoid Warning when save data different from uintX_t in HMI_data_t struct
-  memcpy((void *)&HMI_data, buff, _MIN(sizeof(HMI_data), eeprom_data_size));
-  dwin_zoffset = TERN0(HAS_BED_PROBE, probe.offset.z);
+  memcpy(&HMI_data, buff, sizeof(HMI_data_t));
   if (HMI_data.Text_Color == HMI_data.Background_Color) DWIN_SetColorDefaults();
   DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color, HMI_data.StatusBg_Color);
   TERN_(PREVENT_COLD_EXTRUSION, ApplyExtMinT());
   feedrate_percentage = 100;
   TERN_(BAUD_RATE_GCODE, HMI_SetBaudRate());
   #if BOTH(CASE_LIGHT_MENU, CASELIGHT_USES_BRIGHTNESS)
     // Apply Case light brightness
     caselight.brightness = HMI_data.CaseLight_Brightness;
     caselight.update_brightness();
   #endif
   #if BOTH(LED_CONTROL_MENU, HAS_COLOR_LEDS)
-    // Apply Led Color
-    leds.set_color(HMI_data.Led_Color);
+    leds.set_color(
+      (HMI_data.LED_Color >> 16) & 0xFF,
+      (HMI_data.LED_Color >>  8) & 0xFF,
+      (HMI_data.LED_Color >>  0) & 0xFF
+      OPTARG(HAS_WHITE_LED, (HMI_data.LED_Color >> 24) & 0xFF)
+    );
+    leds.update();
   #endif
 
 }
 
 // Initialize or re-initialize the LCD
 void MarlinUI::init_lcd() {
   TERN_(DEBUG_DWIN, SERIAL_ECHOLNPGM("DWIN_Startup"));
   DWINUI::init();
   DWIN_JPG_CacheTo1(Language_English);
   Encoder_Configuration();
 }
 
 void DWIN_InitScreen() {
   HMI_Init();   // draws boot screen
-  DWINUI::onCursorDraw = Draw_Menu_Cursor;
-  DWINUI::onCursorErase = Erase_Menu_Cursor;
+  onCursorDraw = Draw_Menu_Cursor;
+  onCursorErase = Erase_Menu_Cursor;
   DWINUI::onTitleDraw = Draw_Title;
-  DWINUI::onMenuDraw = Draw_Menu;
-  DWIN_DrawStatusLine(nullptr);
+  onMenuDraw = Draw_Menu;
+  checkkey = 255;
+  CurrentMenu = nullptr;
+  PreviousMenu = nullptr;
+  index_file = MROWS;
+  hash_changed = true;
+  last_E = 0;
+  DWIN_DrawStatusLine(FSTR_P(nullptr));
   DWIN_Draw_Dashboard();
   Goto_Main_Menu();
 }
 
 void MarlinUI::update() {
   EachMomentUpdate();   // Status update
   HMI_SDCardUpdate();   // SD card update
   DWIN_HandleScreen();  // Rotary encoder update
 }
 
 void MarlinUI::refresh() { /* Nothing to see here */ }
 
 #if HAS_LCD_BRIGHTNESS
   void MarlinUI::_set_brightness() { DWIN_LCD_Brightness(backlight ? brightness : 0); }
 #endif
 
 void MarlinUI::kill_screen(FSTR_P const lcd_error, FSTR_P const lcd_component) {
-  DWIN_Draw_Popup(ICON_BLTouch, F("Printer killed:"), lcd_error);
-  DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 270, F("Turn off the printer"));
+  DWIN_Draw_Popup(ICON_BLTouch, GET_TEXT_F(MSG_PRINTER_KILLED), lcd_error);
+  DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 270, GET_TEXT_F(MSG_TURN_OFF));
   DWIN_UpdateLCD();
 }
 
 void DWIN_RebootScreen() {
   DWIN_Frame_Clear(Color_Bg_Black);
   DWIN_JPG_ShowAndCache(0);
   DWINUI::Draw_CenteredString(Color_White, 220, GET_TEXT_F(MSG_PLEASE_WAIT_REBOOT));
   DWIN_UpdateLCD();
   safe_delay(500);
 }
 
-void DWIN_RedrawScreen() {
-  Draw_Main_Area();
+void DWIN_RedrawDash() {
   hash_changed = true;
   DWIN_DrawStatusMessage();
   DWIN_Draw_Dashboard();
 }
 
+void DWIN_RedrawScreen() {
+  Draw_Main_Area();
+  DWIN_RedrawDash();
+}
+
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   void DWIN_Popup_Pause(FSTR_P const fmsg, uint8_t button /*= 0*/) {
     HMI_SaveProcessID(button ? WaitResponse : NothingToDo);
     DWIN_Show_Popup(ICON_BLTouch, GET_TEXT_F(MSG_ADVANCED_PAUSE), fmsg, button);
   }
 
   void MarlinUI::pause_show_message(const PauseMessage message, const PauseMode mode/*=PAUSE_MODE_SAME*/, const uint8_t extruder/*=active_extruder*/) {
     //if (mode == PAUSE_MODE_SAME) return;
     pause_mode = mode;
     switch (message) {
@@ -1803,29 +1835,29 @@ void DWIN_RedrawScreen() {
       case PAUSE_MESSAGE_PURGE:
         #if ENABLED(ADVANCED_PAUSE_CONTINUOUS_PURGE)
           DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_CONT_PURGE));
         #else
           DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_PURGE));
         #endif
         break;
       case PAUSE_MESSAGE_OPTION:   Goto_FilamentPurge(); break;
       case PAUSE_MESSAGE_RESUME:   DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_RESUME)); break;
       case PAUSE_MESSAGE_HEAT:     DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_HEAT), BTN_Continue);   break;
-      case PAUSE_MESSAGE_HEATING:  LCD_MESSAGE(MSG_FILAMENT_CHANGE_HEATING); break;
+      case PAUSE_MESSAGE_HEATING:  DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_HEATING)); break;
       case PAUSE_MESSAGE_STATUS:   HMI_ReturnScreen(); break;                                                                         // Exit from Pause, Load and Unload
       default: break;
     }
   }
 
   void Draw_Popup_FilamentPurge() {
-    DWIN_Draw_Popup(ICON_BLTouch, GET_TEXT_F(MSG_ADVANCED_PAUSE), F("Purge or Continue?"));
-    DWINUI::Draw_Button(BTN_Confirm, 26, 280);
+    DWIN_Draw_Popup(ICON_BLTouch, GET_TEXT_F(MSG_ADVANCED_PAUSE), GET_TEXT_F(MSG_FILAMENT_CHANGE_PURGE_CONTINUE));
+    DWINUI::Draw_Button(BTN_Purge, 26, 280);
     DWINUI::Draw_Button(BTN_Continue, 146, 280);
     Draw_Select_Highlight(true);
   }
 
   void onClick_FilamentPurge() {
       if (HMI_flag.select_flag)
         pause_menu_response = PAUSE_RESPONSE_EXTRUDE_MORE;  // "Purge More" button
       else {
         HMI_SaveProcessID(NothingToDo);
         pause_menu_response = PAUSE_RESPONSE_RESUME_PRINT;  // "Continue" button
@@ -1886,113 +1918,128 @@ void Goto_ConfirmToPrint() {
 #endif
 
 //=============================================================================
 // NEW MENU SUBSYSTEM
 //=============================================================================
 
 // Tool functions
 
 #if ENABLED(EEPROM_SETTINGS)
   void WriteEeprom() {
-    const bool success = settings.save();
-    HMI_AudioFeedback(success);
+    DWIN_DrawStatusLine(GET_TEXT_F(MSG_STORE_EEPROM));
+    DWIN_UpdateLCD();
+    DONE_BUZZ(settings.save());
   }
 
   void ReadEeprom() {
     const bool success = settings.load();
     DWIN_RedrawScreen();
-    HMI_AudioFeedback(success);
+    DONE_BUZZ(success);
   }
 
   void ResetEeprom() {
     settings.reset();
     DWIN_RedrawScreen();
-    HMI_AudioFeedback();
+    DONE_BUZZ(true);
   }
+
+  #if HAS_MESH
+    void SaveMesh() { TERN(AUTO_BED_LEVELING_UBL, UBLSaveMesh(), WriteEeprom()); }
+  #endif
 #endif
 
 // Reset Printer
 void RebootPrinter() {
   wait_for_heatup = wait_for_user = false;    // Stop waiting for heating/user
   thermalManager.disable_all_heaters();
   planner.finish_and_disable();
   DWIN_RebootScreen();
   hal.reboot();
 }
 
-void Goto_Info_Menu(){
+void Goto_Info_Menu() {
   Draw_Info_Menu();
+  DWIN_UpdateLCD();
   HMI_SaveProcessID(WaitResponse);
 }
 
 void Goto_Move_Menu() {
   #if HAS_HOTEND
     gcode.process_subcommands_now(F("G92E0"));  // reset extruder position
-    planner.synchronize();
   #endif
   Draw_Move_Menu();
 }
 
 void DisableMotors() { queue.inject(F("M84")); }
 
-void AutoLev() { queue.inject(F("G28XYO\nG28Z\nG29")); }  // Force to get the current Z home position
+void AutoLev() {   // Always reacquire the Z "home" position
+  queue.inject(F(TERN(AUTO_BED_LEVELING_UBL, "G28Z\nG29P1", "G28XYO\nG28Z\nG29")));
+}
 
 void AutoHome() { queue.inject_P(G28_STR); }
 void HomeX() { queue.inject(F("G28X")); }
 void HomeY() { queue.inject(F("G28Y")); }
 void HomeZ() { queue.inject(F("G28Z")); }
 
 void SetHome() {
   // Apply workspace offset, making the current position 0,0,0
   queue.inject(F("G92X0Y0Z0"));
-  HMI_AudioFeedback();
+  DONE_BUZZ(true);
 }
 
 #if HAS_ZOFFSET_ITEM
 
   void ApplyZOffset() { TERN_(EEPROM_SETTINGS, settings.save()); }
   void LiveZOffset() {
-    last_zoffset = dwin_zoffset;
-    dwin_zoffset = MenuData.Value / 100.0f;
     #if EITHER(BABYSTEP_ZPROBE_OFFSET, JUST_BABYSTEP)
-      if (BABYSTEP_ALLOWED()) babystep.add_mm(Z_AXIS, dwin_zoffset - last_zoffset);
+      const_float_t step_zoffset = round((MenuData.Value / 100.0f) * planner.settings.axis_steps_per_mm[Z_AXIS]) - babystep.accum;
+      if (BABYSTEP_ALLOWED()) babystep.add_steps(Z_AXIS, step_zoffset);
     #endif
   }
-  #if EITHER(HAS_BED_PROBE, BABYSTEPPING)
+
+  #if EITHER(BABYSTEP_ZPROBE_OFFSET, JUST_BABYSTEP)
     void SetZOffset() {
+      babystep.accum = round(planner.settings.axis_steps_per_mm[Z_AXIS] * BABY_Z_VAR);
       SetPFloatOnClick(Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX, 2, ApplyZOffset, LiveZOffset);
     }
   #endif
 
   void SetMoveZto0() {
-    char cmd[48] = "";
-    char str_1[5] = "", str_2[5] = "";
-    sprintf_P(cmd, PSTR("G28XYO\nG28Z\nG0X%sY%sF5000\nM420S0\nG0Z0F300"),
-      #if ENABLED(MESH_BED_LEVELING)
-        dtostrf(0, 1, 1, str_1),
-        dtostrf(0, 1, 1, str_2)
-      #else
-        dtostrf(X_CENTER, 1, 1, str_1),
-        dtostrf(Y_CENTER, 1, 1, str_2)
-      #endif
-    );
-    gcode.process_subcommands_now(cmd);
-    planner.synchronize();
-    LCD_MESSAGE_F("Now adjust Z Offset");
-    HMI_AudioFeedback(true);
+    #if ENABLED(Z_SAFE_HOMING)
+      char cmd[54], str_1[5], str_2[5];
+      sprintf_P(cmd, PSTR("G28XYO\nG28Z\nG0X%sY%sF5000\nM420S0\nG0Z0F300\nM400"),
+        dtostrf(Z_SAFE_HOMING_X_POINT, 1, 1, str_1),
+        dtostrf(Z_SAFE_HOMING_Y_POINT, 1, 1, str_2)
+      );
+      gcode.process_subcommands_now(cmd);
+    #else
+      gcode.process_subcommands_now(F("G28O\nM420S0\nG0Z0F300\nM400"));
+    #endif
+    ui.reset_status();
+    DONE_BUZZ(true);
   }
-#endif
+
+  void HomeZandDisable() {
+    SetMoveZto0();
+    DisableMotors();
+  }
+
+#endif // HAS_ZOFFSET_ITEM
 
 #if HAS_PREHEAT
   void DoPreheat0() { ui.preheat_all(0); }
-  void DoPreheat1() { ui.preheat_all(1); }
-  void DoPreheat2() { ui.preheat_all(2); }
+  #if PREHEAT_COUNT >= 2
+    void DoPreheat1() { ui.preheat_all(1); }
+    #if PREHEAT_COUNT >= 3
+      void DoPreheat2() { ui.preheat_all(2); }
+    #endif
+  #endif
 #endif
 
 void DoCoolDown() { thermalManager.cooldown(); }
 
 void SetLanguage() {
   HMI_ToggleLanguage();
   CurrentMenu = nullptr;  // Invalidate menu to full redraw
   Draw_Prepare_Menu();
 }
 
@@ -2003,43 +2050,42 @@ void LiveMove() {
     planner.buffer_line(current_position, homing_feedrate(HMI_value.axis));
   }
 }
 void ApplyMoveE() {
   last_E = MenuData.Value / MINUNITMULT;
   if (!planner.is_full()) {
     planner.synchronize();
     planner.buffer_line(current_position, MMM_TO_MMS(FEEDRATE_E));
   }
 }
-void SetMoveX() { HMI_value.axis = X_AXIS; SetPFloatOnClick(X_MIN_POS, X_MAX_POS, UNITFDIGITS, planner.synchronize, LiveMove);}
-void SetMoveY() { HMI_value.axis = Y_AXIS; SetPFloatOnClick(Y_MIN_POS, Y_MAX_POS, UNITFDIGITS, planner.synchronize, LiveMove);}
-void SetMoveZ() { HMI_value.axis = Z_AXIS; SetPFloatOnClick(Z_MIN_POS, Z_MAX_POS, UNITFDIGITS, planner.synchronize, LiveMove);}
+void SetMoveX() { HMI_value.axis = X_AXIS; SetPFloatOnClick(X_MIN_POS, X_MAX_POS, UNITFDIGITS, planner.synchronize, LiveMove); }
+void SetMoveY() { HMI_value.axis = Y_AXIS; SetPFloatOnClick(Y_MIN_POS, Y_MAX_POS, UNITFDIGITS, planner.synchronize, LiveMove); }
+void SetMoveZ() { HMI_value.axis = Z_AXIS; SetPFloatOnClick(Z_MIN_POS, Z_MAX_POS, UNITFDIGITS, planner.synchronize, LiveMove); }
 
 #if HAS_HOTEND
   void SetMoveE() {
     #if ENABLED(PREVENT_COLD_EXTRUSION)
       if (thermalManager.tooColdToExtrude(0))
         return DWIN_Popup_Confirm(ICON_TempTooLow, GET_TEXT_F(MSG_HOTEND_TOO_COLD), GET_TEXT_F(MSG_PLEASE_PREHEAT));
     #endif
     SetPFloatOnClick(last_E - (EXTRUDE_MAXLENGTH), last_E + (EXTRUDE_MAXLENGTH), UNITFDIGITS, ApplyMoveE);
   }
 #endif
 
 void SetPID(celsius_t t, heater_id_t h) {
-  char cmd[48] = "";
+  char cmd[53] = "";
   char str_1[5] = "", str_2[5] = "";
-  sprintf_P(cmd, PSTR("G28OXY\nG0Z5F300\nG0X%sY%sF5000\nM84"),
+  sprintf_P(cmd, PSTR("G28OXY\nG0Z5F300\nG0X%sY%sF5000\nM84\nM400"),
     dtostrf(X_CENTER, 1, 1, str_1),
     dtostrf(Y_CENTER, 1, 1, str_2)
   );
   gcode.process_subcommands_now(cmd);
-  planner.synchronize();
   thermalManager.PID_autotune(t, h, HMI_data.PidCycles, true);
 }
 #if HAS_HOTEND
   void HotendPID() { SetPID(HMI_data.HotendPidT, H_E0); }
 #endif
 #if HAS_HEATED_BED
   void BedPID() { SetPID(HMI_data.BedPidT, H_BED); }
 #endif
 
 #if ENABLED(POWER_LOSS_RECOVERY)
@@ -2071,43 +2117,45 @@ void SetPID(celsius_t t, heater_id_t h) {
 #endif
 
 #if ENABLED(CASE_LIGHT_MENU)
   void SetCaseLight() {
     caselight.on = !caselight.on;
     caselight.update_enabled();
     Draw_Chkb_Line(CurrentMenu->line(), caselight.on);
     DWIN_UpdateLCD();
   }
   #if ENABLED(CASELIGHT_USES_BRIGHTNESS)
-    void LiveCaseLightBrightness() { HMI_data.CaseLight_Brightness = caselight.brightness = MenuData.Value; caselight.update_brightness(); }
+    void LiveCaseLightBrightness() { caselight.brightness = MenuData.Value; caselight.update_brightness(); }
     void SetCaseLightBrightness() { SetIntOnClick(0, 255, caselight.brightness, nullptr, LiveCaseLightBrightness); }
   #endif
 #endif
 
 #if ENABLED(LED_CONTROL_MENU)
   #if !BOTH(CASE_LIGHT_MENU, CASE_LIGHT_USE_NEOPIXEL)
     void SetLedStatus() {
       leds.toggle();
       Draw_Chkb_Line(CurrentMenu->line(), leds.lights_on);
       DWIN_UpdateLCD();
     }
   #endif
   #if HAS_COLOR_LEDS
-    void LiveLedColorR() { leds.color.r = MenuData.Value; HMI_data.Led_Color = leds.color; leds.update(); }
-    void SetLedColorR() { SetIntOnClick(0, 255, leds.color.r, nullptr, LiveLedColorR); }
-    void LiveLedColorG() { leds.color.g = MenuData.Value; HMI_data.Led_Color = leds.color; leds.update(); }
-    void SetLedColorG() { SetIntOnClick(0, 255, leds.color.g, nullptr, LiveLedColorG); }
-    void LiveLedColorB() { leds.color.b = MenuData.Value; HMI_data.Led_Color = leds.color; leds.update(); }
-    void SetLedColorB() { SetIntOnClick(0, 255, leds.color.b, nullptr, LiveLedColorB); }
+    void ApplyLEDColor() { HMI_data.LED_Color = TERN0(HAS_WHITE_LED, (leds.color.w << 24)) | (leds.color.r << 16) | (leds.color.g << 8) | leds.color.b; }
+    void LiveLEDColor(uint8_t *color) { *color = MenuData.Value; leds.update(); }
+    void LiveLEDColorR() { LiveLEDColor(&leds.color.r); }
+    void LiveLEDColorG() { LiveLEDColor(&leds.color.g); }
+    void LiveLEDColorB() { LiveLEDColor(&leds.color.b); }
+    void SetLEDColorR() { SetIntOnClick(0, 255, leds.color.r, ApplyLEDColor, LiveLEDColorR); }
+    void SetLEDColorG() { SetIntOnClick(0, 255, leds.color.g, ApplyLEDColor, LiveLEDColorG); }
+    void SetLEDColorB() { SetIntOnClick(0, 255, leds.color.b, ApplyLEDColor, LiveLEDColorB); }
     #if HAS_WHITE_LED
-      void LiveLedColorW() { leds.color.w = MenuData.Value; HMI_data.Led_Color = leds.color; leds.update(); }
-      void SetLedColorW() { SetIntOnClick(0, 255, leds.color.w, nullptr, LiveLedColorW); }
+      void LiveLEDColorW() { LiveLEDColor(&leds.color.w); }
+      void SetLEDColorW() { SetIntOnClick(0, 255, leds.color.w, ApplyLEDColor, LiveLEDColorW); }
     #endif
   #endif
 #endif
 
 #if ENABLED(SOUND_MENU_ITEM)
   void SetEnableSound() {
     ui.sound_on = !ui.sound_on;
     Draw_Chkb_Line(CurrentMenu->line(), ui.sound_on);
     DWIN_UpdateLCD();
   }
@@ -2132,24 +2180,20 @@ void SetPID(celsius_t t, heater_id_t h) {
   void ProbeDeploy() { probe.deploy(); }
 
   #ifdef BLTOUCH_HS_MODE
     void SetHSMode() {
       bltouch.high_speed_mode = !bltouch.high_speed_mode;
       Draw_Chkb_Line(CurrentMenu->line(), bltouch.high_speed_mode);
       DWIN_UpdateLCD();
     }
   #endif
 
-  #if BOTH(HAS_HEATED_BED, PREHEAT_BEFORE_LEVELING)
-    void SetBedLevT() { SetPIntOnClick(BED_MINTEMP, BED_MAX_TARGET); }
-  #endif
-
 #endif
 
 #if HAS_FILAMENT_SENSOR
   void SetRunoutEnable() {
     runout.reset();
     runout.enabled = !runout.enabled;
     Draw_Chkb_Line(CurrentMenu->line(), runout.enabled);
     DWIN_UpdateLCD();
   }
   #if HAS_FILAMENT_RUNOUT_DISTANCE
@@ -2190,74 +2234,74 @@ void LiveRGBColor() {
 void SetRGBColor() {
   const uint8_t color = CurrentMenu->SelectedItem()->icon;
   SetIntOnClick(0, (color == 1) ? 63 : 31, HMI_value.Color[color], nullptr, LiveRGBColor);
 }
 
 void DWIN_ApplyColor() {
   *MenuData.P_Int = RGB(HMI_value.Color[0], HMI_value.Color[1], HMI_value.Color[2]);
   DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color, HMI_data.StatusBg_Color);
   Draw_SelectColors_Menu();
   hash_changed = true;
-  LCD_MESSAGE_F(GET_TEXT_F(MSG_COLORS_APPLIED));
+  LCD_MESSAGE(MSG_COLORS_APPLIED);
   DWIN_Draw_Dashboard();
 }
 
 void SetSpeed() { SetPIntOnClick(MIN_PRINT_SPEED, MAX_PRINT_SPEED); }
 
 #if HAS_HOTEND
   void ApplyHotendTemp() { thermalManager.setTargetHotend(MenuData.Value, 0); }
   void SetHotendTemp() { SetIntOnClick(MIN_ETEMP, MAX_ETEMP, thermalManager.degTargetHotend(0), ApplyHotendTemp); }
 #endif
 
 #if HAS_HEATED_BED
   void ApplyBedTemp() { thermalManager.setTargetBed(MenuData.Value); }
-  void SetBedTemp() { SetIntOnClick(BED_MINTEMP, BED_MAX_TARGET, thermalManager.degTargetBed(), ApplyBedTemp); }
+  void SetBedTemp() { SetIntOnClick(MIN_BEDTEMP, MAX_BEDTEMP, thermalManager.degTargetBed(), ApplyBedTemp); }
 #endif
 
 #if HAS_FAN
   void ApplyFanSpeed() { thermalManager.set_fan_speed(0, MenuData.Value); }
   void SetFanSpeed() { SetIntOnClick(0, 255, thermalManager.fan_speed[0], ApplyFanSpeed); }
 #endif
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
 
   void ChangeFilament() {
     HMI_SaveProcessID(NothingToDo);
     queue.inject(F("M600 B2"));
   }
 
-  void ParkHead(){
+  void ParkHead() {
     LCD_MESSAGE(MSG_FILAMENT_PARK_ENABLED);
     queue.inject(F("G28O\nG27"));
   }
 
   #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
-    void UnloadFilament(){
+    void UnloadFilament() {
       LCD_MESSAGE(MSG_FILAMENTUNLOAD);
       queue.inject(F("M702 Z20"));
     }
 
-    void LoadFilament(){
+    void LoadFilament() {
       LCD_MESSAGE(MSG_FILAMENTLOAD);
       queue.inject(F("M701 Z20"));
     }
   #endif
 
 #endif // ADVANCED_PAUSE_FEATURE
 
 void ApplyFlow() { planner.refresh_e_factor(0); }
 void SetFlow() { SetPIntOnClick(MIN_PRINT_FLOW, MAX_PRINT_FLOW, ApplyFlow); }
 
 // Bed Tramming
-TERN(HAS_ONESTEP_LEVELING, float, void) Tram(uint8_t point) {
+TERN(HAS_BED_PROBE, float, void) Tram(uint8_t point) {
   char cmd[100] = "";
-  #if HAS_ONESTEP_LEVELING
+  #if HAS_BED_PROBE
     static bool inLev = false;
     float xpos = 0, ypos = 0, zval = 0, margin = 0;
     char str_1[6] = "", str_2[6] = "", str_3[6] = "";
     if (inLev) return NAN;
     margin = HMI_data.FullManualTramming ? 30 : PROBING_MARGIN;
   #else
     int16_t xpos = 0, ypos = 0;
     int16_t margin = 30;
   #endif
 
@@ -2279,167 +2323,173 @@ TERN(HAS_ONESTEP_LEVELING, float, void) Tram(uint8_t point) {
       xpos = margin; ypos = Y_BED_SIZE - margin;
       break;
     case 4:
       LCD_MESSAGE(MSG_LEVBED_C);
       xpos = X_BED_SIZE / 2; ypos = Y_BED_SIZE / 2;
       break;
   }
 
   planner.synchronize();
 
-  #if HAS_ONESTEP_LEVELING
+  #if HAS_BED_PROBE
 
     if (HMI_data.FullManualTramming) {
       planner.synchronize();
       sprintf_P(cmd, PSTR("M420S0\nG28O\nG90\nG0Z5F300\nG0X%sY%sF5000\nG0Z0F300"),
         dtostrf(xpos, 1, 1, str_1),
         dtostrf(ypos, 1, 1, str_2)
       );
       queue.inject(cmd);
     }
     else {
-      LIMIT(xpos, X_MIN_POS, (X_MAX_POS + probe.offset.x));
-      LIMIT(ypos, Y_MIN_POS, (Y_MAX_POS + probe.offset.y));
+      LIMIT(xpos, MESH_MIN_X, MESH_MAX_X);
+      LIMIT(ypos, MESH_MIN_Y, MESH_MAX_Y);
       probe.stow();
       gcode.process_subcommands_now(F("M420S0\nG28O"));
-      planner.synchronize();
       inLev = true;
       zval = probe.probe_at_point(xpos, ypos, PROBE_PT_STOW);
       if (isnan(zval))
-        LCD_MESSAGE_F("Position Not Reachable, check offsets");
+        LCD_MESSAGE(MSG_ZPROBE_OUT);
       else {
         sprintf_P(cmd, PSTR("X:%s, Y:%s, Z:%s"),
           dtostrf(xpos, 1, 1, str_1),
           dtostrf(ypos, 1, 1, str_2),
           dtostrf(zval, 1, 2, str_3)
         );
         ui.set_status(cmd);
       }
       inLev = false;
     }
     return zval;
 
-  #else
+  #else // !HAS_BED_PROBE
 
     sprintf_P(cmd, PSTR("M420S0\nG28O\nG90\nG0Z5F300\nG0X%iY%iF5000\nG0Z0F300"), xpos, ypos);
     queue.inject(cmd);
 
   #endif
 }
 
 void TramFL() { Tram(0); }
 void TramFR() { Tram(1); }
 void TramBR() { Tram(2); }
 void TramBL() { Tram(3); }
 void TramC () { Tram(4); }
 
-#if HAS_ONESTEP_LEVELING
+#if HAS_BED_PROBE
 
   void Trammingwizard() {
     bed_mesh_t zval = {0};
     if (HMI_data.FullManualTramming) {
       LCD_MESSAGE_F("Disable manual tramming");
       return;
     }
     zval[0][0] = Tram(0);
     checkkey = NothingToDo;
     MeshViewer.DrawMesh(zval, 2, 2);
     zval[1][0] = Tram(1);
     MeshViewer.DrawMesh(zval, 2, 2);
     zval[1][1] = Tram(2);
     MeshViewer.DrawMesh(zval, 2, 2);
     zval[0][1] = Tram(3);
     MeshViewer.DrawMesh(zval, 2, 2);
-    char str_1[6] = "", str_2[6] = "";
-    ui.status_printf(0, F("Limits minZ: %s, maxZ: %s"),
-      dtostrf(MeshViewer.min, 1, 2, str_1),
-      dtostrf(MeshViewer.max, 1, 2, str_2)
-    );
+
+    DWINUI::Draw_CenteredString(140, F("Calculating average"));
+    DWINUI::Draw_CenteredString(160, F("and relative heights"));
+    safe_delay(1000);
+    float avg = 0.0f;
+    LOOP_L_N(x, 2) LOOP_L_N(y, 2) avg += zval[x][y];
+    avg /= 4.0f;
+    LOOP_L_N(x, 2) LOOP_L_N(y, 2) zval[x][y] -= avg;
+    MeshViewer.DrawMesh(zval, 2, 2);
+    ui.reset_status();
+
     if (ABS(MeshViewer.max - MeshViewer.min) < 0.05) {
       DWINUI::Draw_CenteredString(140,F("Corners leveled"));
       DWINUI::Draw_CenteredString(160,F("Tolerance achieved!"));
     }
     else {
       uint8_t p = 0;
-      float d, max = 0;
+      float max = 0;
       FSTR_P plabel;
-      LOOP_L_N(x,2) LOOP_L_N(y,2) {
-        d = ABS(zval[x][y] - MeshViewer.avg);
+      bool s = true;
+      LOOP_L_N(x, 2) LOOP_L_N(y, 2) {
+        const float d = ABS(zval[x][y]);
         if (max < d) {
+          s = (zval[x][y] >= 0);
           max = d;
           p = x + 2 * y;
         }
       }
       switch (p) {
         case 0b00 : plabel = GET_TEXT_F(MSG_LEVBED_FL); break;
         case 0b01 : plabel = GET_TEXT_F(MSG_LEVBED_FR); break;
         case 0b10 : plabel = GET_TEXT_F(MSG_LEVBED_BL); break;
         case 0b11 : plabel = GET_TEXT_F(MSG_LEVBED_BR); break;
         default   : plabel = F(""); break;
       }
-      DWINUI::Draw_CenteredString(130, F("Corners not leveled"));
-      DWINUI::Draw_CenteredString(150, F("Knob adjustment required"));
-      DWINUI::Draw_CenteredString(Color_Green, 170, plabel);
+      DWINUI::Draw_CenteredString(120, F("Corners not leveled"));
+      DWINUI::Draw_CenteredString(140, F("Knob adjustment required"));
+      DWINUI::Draw_CenteredString(Color_Green, 160, s ? F("Lower") : F("Raise"));
+      DWINUI::Draw_CenteredString(Color_Green, 180, plabel);
     }
     DWINUI::Draw_Button(BTN_Continue, 86, 305);
     checkkey = Menu;
     HMI_SaveProcessID(WaitResponse);
   }
 
   void SetManualTramming() {
     HMI_data.FullManualTramming = !HMI_data.FullManualTramming;
     Draw_Chkb_Line(CurrentMenu->line(), HMI_data.FullManualTramming);
     DWIN_UpdateLCD();
   }
 
-#endif // HAS_ONESTEP_LEVELING
+#endif // HAS_BED_PROBE
 
 #if ENABLED(MESH_BED_LEVELING)
 
-  void ManualMeshStart(){
+  void ManualMeshStart() {
     LCD_MESSAGE(MSG_UBL_BUILD_MESH_MENU);
     gcode.process_subcommands_now(F("G28XYO\nG28Z\nM211S0\nG29S1"));
-    planner.synchronize();
     #ifdef MANUAL_PROBE_START_Z
       const uint8_t line = CurrentMenu->line(MMeshMoveZItem->pos);
       DWINUI::Draw_Signed_Float(HMI_data.Text_Color, HMI_data.Background_Color, 3, 2, VALX - 2 * DWINUI::fontWidth(DWIN_FONT_MENU), MBASE(line), MANUAL_PROBE_START_Z);
     #endif
   }
 
   void LiveMeshMoveZ() {
     *MenuData.P_Float = MenuData.Value / POW(10, 2);
     if (!planner.is_full()) {
       planner.synchronize();
       planner.buffer_line(current_position, homing_feedrate(Z_AXIS));
     }
   }
-  void SetMMeshMoveZ() { SetPFloatOnClick(-1, 1, 2, planner.synchronize, LiveMeshMoveZ);}
+  void SetMMeshMoveZ() { SetPFloatOnClick(-1, 1, 2, planner.synchronize, LiveMeshMoveZ); }
 
-  void ManualMeshContinue(){
+  void ManualMeshContinue() {
     gcode.process_subcommands_now(F("G29S2"));
-    planner.synchronize();
-    MMeshMoveZItem->draw(CurrentMenu->line(MMeshMoveZItem->pos));
+    MMeshMoveZItem->redraw();
   }
 
-  void ManualMeshSave(){
+  void ManualMeshSave() {
     LCD_MESSAGE(MSG_UBL_STORAGE_MESH_MENU);
     queue.inject(F("M211S1\nM500"));
   }
 
 #endif // MESH_BED_LEVELING
 
 #if HAS_PREHEAT
   #if HAS_HOTEND
     void SetPreheatEndTemp() { SetPIntOnClick(MIN_ETEMP, MAX_ETEMP); }
   #endif
   #if HAS_HEATED_BED
-    void SetPreheatBedTemp() { SetPIntOnClick(BED_MINTEMP, BED_MAX_TARGET); }
+    void SetPreheatBedTemp() { SetPIntOnClick(MIN_BEDTEMP, MAX_BEDTEMP); }
   #endif
   #if HAS_FAN
     void SetPreheatFanSpeed() { SetPIntOnClick(0, 255); }
   #endif
 #endif
 
 void ApplyMaxSpeed() { planner.set_max_feedrate(HMI_value.axis, MenuData.Value / MINUNITMULT); }
 void SetMaxSpeedX() { HMI_value.axis = X_AXIS, SetFloatOnClick(MIN_MAXFEEDSPEED, max_feedrate_edit_values[X_AXIS], UNITFDIGITS, planner.settings.max_feedrate_mm_s[X_AXIS], ApplyMaxSpeed); }
 void SetMaxSpeedY() { HMI_value.axis = Y_AXIS, SetFloatOnClick(MIN_MAXFEEDSPEED, max_feedrate_edit_values[Y_AXIS], UNITFDIGITS, planner.settings.max_feedrate_mm_s[Y_AXIS], ApplyMaxSpeed); }
 void SetMaxSpeedZ() { HMI_value.axis = Z_AXIS, SetFloatOnClick(MIN_MAXFEEDSPEED, max_feedrate_edit_values[Z_AXIS], UNITFDIGITS, planner.settings.max_feedrate_mm_s[Z_AXIS], ApplyMaxSpeed); }
@@ -2466,21 +2516,21 @@ void SetMaxAccelZ() { HMI_value.axis = Z_AXIS, SetIntOnClick(MIN_MAXACCELERATION
 #endif
 
 void SetStepsX() { HMI_value.axis = X_AXIS, SetPFloatOnClick( MIN_STEP, MAX_STEP, UNITFDIGITS); }
 void SetStepsY() { HMI_value.axis = Y_AXIS, SetPFloatOnClick( MIN_STEP, MAX_STEP, UNITFDIGITS); }
 void SetStepsZ() { HMI_value.axis = Z_AXIS, SetPFloatOnClick( MIN_STEP, MAX_STEP, UNITFDIGITS); }
 #if HAS_HOTEND
   void SetStepsE() { HMI_value.axis = E_AXIS; SetPFloatOnClick( MIN_STEP, MAX_STEP, UNITFDIGITS); }
   void SetHotendPidT() { SetPIntOnClick(MIN_ETEMP, MAX_ETEMP); }
 #endif
 #if HAS_HEATED_BED
-  void SetBedPidT() { SetPIntOnClick(BED_MINTEMP, BED_MAX_TARGET); }
+  void SetBedPidT() { SetPIntOnClick(MIN_BEDTEMP, MAX_BEDTEMP); }
 #endif
 
 #if HAS_HOTEND || HAS_HEATED_BED
   void SetPidCycles() { SetPIntOnClick(3, 50); }
   void SetKp() { SetPFloatOnClick(0, 1000, 2); }
   void ApplyPIDi() {
     *MenuData.P_Float = scalePID_i(MenuData.Value / POW(10, 2));
     thermalManager.updatePID();
   }
   void ApplyPIDd() {
@@ -2493,24 +2543,26 @@ void SetStepsZ() { HMI_value.axis = Z_AXIS, SetPFloatOnClick( MIN_STEP, MAX_STEP
     SetFloatOnClick(0, 1000, 2, value, ApplyPIDi);
   }
   void SetKd() {
     MenuData.P_Float = (float*)static_cast<MenuItemPtrClass*>(CurrentMenu->SelectedItem())->value;
     const float value = unscalePID_d(*MenuData.P_Float);
     SetFloatOnClick(0, 1000, 2, value, ApplyPIDd);
   }
 #endif
 
 #if ENABLED(FWRETRACT)
-  void SetRetractLength() { SetPFloatOnClick( 0, 10, UNITFDIGITS); };
-  void SetRetractSpeed() { SetPFloatOnClick( 1, 90, UNITFDIGITS); };
-  void SetZRaise() { SetPFloatOnClick( 0, 2, 2); };
-  void SetRecoverSpeed() { SetPFloatOnClick( 1, 90, UNITFDIGITS); };
+  void Return_FWRetract_Menu() { (PreviousMenu == FilSetMenu) ? Draw_FilSet_Menu() : Draw_Tune_Menu(); }
+  void SetRetractLength() { SetPFloatOnClick( 0, 10, UNITFDIGITS); }
+  void SetRetractSpeed()  { SetPFloatOnClick( 1, 90, UNITFDIGITS); }
+  void SetZRaise()        { SetPFloatOnClick( 0, 2, 2); }
+  void SetRecoverSpeed()  { SetPFloatOnClick( 1, 90, UNITFDIGITS); }
+  void SetAddRecover()    { SetPFloatOnClick(-5, 5, UNITFDIGITS); }
 #endif
 
 // Special Menuitem Drawing functions =================================================
 
 void onDrawBack(MenuItemClass* menuitem, int8_t line) {
   if (HMI_IsChinese()) menuitem->SetFrame(1, 129, 72, 156, 84);
   onDrawMenuItem(menuitem, line);
 }
 
 void onDrawTempSubMenu(MenuItemClass* menuitem, int8_t line) {
@@ -2576,83 +2628,59 @@ void onDrawDisableMotors(MenuItemClass* menuitem, int8_t line) {
   if (HMI_IsChinese()) menuitem->SetFrame(1, 204, 70, 259, 82);
   onDrawMenuItem(menuitem, line);
 }
 
 void onDrawAutoHome(MenuItemClass* menuitem, int8_t line) {
   if (HMI_IsChinese()) menuitem->SetFrame(1, 0, 89, 41, 101);
   onDrawMenuItem(menuitem, line);
 }
 
 #if HAS_ZOFFSET_ITEM
-  #if EITHER(HAS_BED_PROBE, BABYSTEPPING)
+  #if EITHER(BABYSTEP_ZPROBE_OFFSET, JUST_BABYSTEP)
     void onDrawZOffset(MenuItemClass* menuitem, int8_t line) {
       if (HMI_IsChinese()) menuitem->SetFrame(1, 174, 164, 223, 177);
       onDrawPFloat2Menu(menuitem, line);
     }
   #else
     void onDrawHomeOffset(MenuItemClass* menuitem, int8_t line) {
       if (HMI_IsChinese()) menuitem->SetFrame(1, 43, 89, 98, 101);
       onDrawMenuItem(menuitem, line);
     }
   #endif
 #endif
 
 #if HAS_HOTEND
   void onDrawPreheat1(MenuItemClass* menuitem, int8_t line) {
     if (HMI_IsChinese()) menuitem->SetFrame(1, 100, 89, 151, 101);
     onDrawMenuItem(menuitem, line);
   }
-  void onDrawPreheat2(MenuItemClass* menuitem, int8_t line) {
-    if (HMI_IsChinese()) menuitem->SetFrame(1, 180, 89, 233, 100);
-    onDrawMenuItem(menuitem, line);
-  }
+  #if PREHEAT_COUNT > 1
+    void onDrawPreheat2(MenuItemClass* menuitem, int8_t line) {
+      if (HMI_IsChinese()) menuitem->SetFrame(1, 180, 89, 233, 100);
+      onDrawMenuItem(menuitem, line);
+    }
+  #endif
 #endif
 
 #if HAS_PREHEAT
   void onDrawCooldown(MenuItemClass* menuitem, int8_t line) {
     if (HMI_IsChinese()) menuitem->SetFrame(1, 1, 104,  56, 117);
     onDrawMenuItem(menuitem, line);
   }
 #endif
 
 void onDrawLanguage(MenuItemClass* menuitem, int8_t line) {
   if (HMI_IsChinese()) menuitem->SetFrame(1, 239, 134, 266, 146);
   onDrawMenuItem(menuitem, line);
   DWINUI::Draw_String(VALX, MBASE(line), HMI_IsChinese() ? F("CN") : F("EN"));
 }
 
-#if ENABLED(POWER_LOSS_RECOVERY)
-  void onDrawPwrLossR(MenuItemClass* menuitem, int8_t line) { onDrawChkbMenu(menuitem, line, recovery.enabled); }
-#endif
-
-#if ENABLED(BAUD_RATE_GCODE)
-  void onDrawBaudrate(MenuItemClass* menuitem, int8_t line) { onDrawChkbMenu(menuitem, line, HMI_data.Baud115K); }
-#endif
-
-#if ENABLED(CASE_LIGHT_MENU)
-  void onDrawCaseLight(MenuItemClass* menuitem, int8_t line) { onDrawChkbMenu(menuitem, line, caselight.on); }
-#endif
-
-#if ENABLED(LED_CONTROL_MENU)
-  #if !BOTH(CASE_LIGHT_MENU, CASE_LIGHT_USE_NEOPIXEL)
-    void onDrawLedStatus(MenuItemClass* menuitem, int8_t line) { onDrawChkbMenu(menuitem, line, leds.lights_on); }
-  #endif
-#endif
-
-#if ENABLED(SOUND_MENU_ITEM)
-  void onDrawEnableSound(MenuItemClass* menuitem, int8_t line) { onDrawChkbMenu(menuitem, line, ui.sound_on); }
-#endif
-
-#ifdef BLTOUCH_HS_MODE
-  void onDrawHSMode(MenuItemClass* menuitem, int8_t line) { onDrawChkbMenu(menuitem, line, bltouch.high_speed_mode); }
-#endif
-
 void onDrawSelColorItem(MenuItemClass* menuitem, int8_t line) {
   const uint16_t color = *(uint16_t*)static_cast<MenuItemPtrClass*>(menuitem)->value;
   DWIN_Draw_Rectangle(0, HMI_data.Highlight_Color, ICOX + 1, MBASE(line) - 1 + 1, ICOX + 18, MBASE(line) - 1 + 18);
   DWIN_Draw_Rectangle(1, color, ICOX + 2, MBASE(line) - 1 + 2, ICOX + 17, MBASE(line) - 1 + 17);
   onDrawMenuItem(menuitem, line);
 }
 
 void onDrawGetColorItem(MenuItemClass* menuitem, int8_t line) {
   const uint8_t i = menuitem->icon;
   uint16_t color;
@@ -2730,24 +2758,26 @@ void onDrawSteps(MenuItemClass* menuitem, int8_t line) {
   #if HAS_FAN
     void onDrawSetPreheatFan(MenuItemClass* menuitem, int8_t line) {
       if (HMI_IsChinese()) menuitem->SetFrame(1, 115, 134, 170, 146);
       onDrawPIntMenu(menuitem, line);
     }
   #endif
   void onDrawPLAPreheatSubMenu(MenuItemClass* menuitem, int8_t line) {
     if (HMI_IsChinese()) menuitem->SetFrame(1, 100, 89, 178, 101);
     onDrawSubMenu(menuitem,line);
   }
-  void onDrawABSPreheatSubMenu(MenuItemClass* menuitem, int8_t line) {
-    if (HMI_IsChinese()) menuitem->SetFrame(1, 180, 89, 260, 100);
-    onDrawSubMenu(menuitem,line);
-  }
+  #if PREHEAT_COUNT >= 2
+    void onDrawABSPreheatSubMenu(MenuItemClass* menuitem, int8_t line) {
+      if (HMI_IsChinese()) menuitem->SetFrame(1, 180, 89, 260, 100);
+      onDrawSubMenu(menuitem,line);
+    }
+  #endif
 #endif // HAS_PREHEAT
 
 void onDrawSpeed(MenuItemClass* menuitem, int8_t line) {
   if (HMI_IsChinese())
     menuitem->SetFrame(1, 173, 133, 228, 147);
   onDrawSubMenu(menuitem, line);
 }
 
 void onDrawMaxSpeedX(MenuItemClass* menuitem, int8_t line) {
   if (HMI_IsChinese()) {
@@ -2930,683 +2960,766 @@ void SetMenuTitle(frame_rect_t cn, const __FlashStringHelper* fstr) {
   else
     CurrentMenu->MenuTitle.SetCaption(fstr);
 }
 
 void Draw_Prepare_Menu() {
   checkkey = Menu;
   if (!PrepareMenu) PrepareMenu = new MenuClass();
   if (CurrentMenu != PrepareMenu) {
     CurrentMenu = PrepareMenu;
     SetMenuTitle({133, 1, 28, 13}, GET_TEXT_F(MSG_PREPARE));
-    DWINUI::MenuItemsPrepare(13);
-    MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Goto_Main_Menu);
+    MenuItemsPrepare(13);
+    BACK_ITEM(Goto_Main_Menu);
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
-      MENU_ITEM(ICON_FilMan, GET_TEXT_F(MSG_FILAMENT_MAN), onDrawSubMenu, Draw_FilamentMan_Menu);
+      MENU_ITEM_F(ICON_FilMan, MSG_FILAMENT_MAN, onDrawSubMenu, Draw_FilamentMan_Menu);
     #endif
-    MENU_ITEM(ICON_Axis, GET_TEXT_F(MSG_MOVE_AXIS), onDrawMoveSubMenu, Goto_Move_Menu);
-    MENU_ITEM(ICON_Tram, GET_TEXT_F(MSG_BED_TRAMMING), onDrawSubMenu, Draw_Tramming_Menu);
-    MENU_ITEM(ICON_CloseMotor, GET_TEXT_F(MSG_DISABLE_STEPPERS), onDrawDisableMotors, DisableMotors);
+    MENU_ITEM_F(ICON_Axis, MSG_MOVE_AXIS, onDrawMoveSubMenu, Goto_Move_Menu);
+    MENU_ITEM_F(ICON_Tram, MSG_BED_TRAMMING, onDrawSubMenu, Draw_Tramming_Menu);
+    MENU_ITEM_F(ICON_CloseMotor, MSG_DISABLE_STEPPERS, onDrawDisableMotors, DisableMotors);
     #if ENABLED(INDIVIDUAL_AXIS_HOMING_SUBMENU)
-      MENU_ITEM(ICON_Homing, GET_TEXT_F(MSG_HOMING), onDrawSubMenu, Draw_Homing_Menu);
+      MENU_ITEM_F(ICON_Homing, MSG_HOMING, onDrawSubMenu, Draw_Homing_Menu);
     #else
-      MENU_ITEM(ICON_Homing, GET_TEXT_F(MSG_AUTO_HOME), onDrawAutoHome, AutoHome);
+      MENU_ITEM_F(ICON_Homing, MSG_AUTO_HOME, onDrawAutoHome, AutoHome);
     #endif
     #if ENABLED(MESH_BED_LEVELING)
-      MENU_ITEM(ICON_ManualMesh, GET_TEXT_F(MSG_MANUAL_MESH), onDrawSubMenu, Draw_ManualMesh_Menu);
+      MENU_ITEM_F(ICON_ManualMesh, MSG_MANUAL_MESH, onDrawSubMenu, Draw_ManualMesh_Menu);
     #endif
     #if HAS_ONESTEP_LEVELING
-      MENU_ITEM(ICON_Level, GET_TEXT_F(MSG_AUTO_MESH), onDrawMenuItem, AutoLev);
+      MENU_ITEM_F(ICON_Level, MSG_AUTO_MESH, onDrawMenuItem, AutoLev);
     #endif
     #if HAS_ZOFFSET_ITEM
-      #if HAS_BED_PROBE
-        MENU_ITEM(ICON_SetZOffset, GET_TEXT_F(MSG_PROBE_WIZARD), onDrawSubMenu, Draw_ZOffsetWiz_Menu);
-      #elif ENABLED(BABYSTEPPING)
-        EDIT_ITEM(ICON_Zoffset, GET_TEXT_F(MSG_ZPROBE_ZOFFSET), onDrawPFloat2Menu, SetZOffset, &BABY_Z_VAR);
+      #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
+        MENU_ITEM_F(ICON_SetZOffset, MSG_PROBE_WIZARD, onDrawSubMenu, Draw_ZOffsetWiz_Menu);
+      #elif JUST_BABYSTEP
+        EDIT_ITEM_F(ICON_Zoffset, MSG_ZPROBE_ZOFFSET, onDrawPFloat2Menu, SetZOffset, &BABY_Z_VAR);
       #else
-        MENU_ITEM(ICON_SetHome, GET_TEXT_F(MSG_SET_HOME_OFFSETS), onDrawHomeOffset, SetHome);
+        MENU_ITEM_F(ICON_SetHome, MSG_SET_HOME_OFFSETS, onDrawHomeOffset, SetHome);
       #endif
     #endif
     #if HAS_PREHEAT
-      MENU_ITEM(ICON_PLAPreheat, GET_TEXT_F(MSG_PREHEAT_1), onDrawPreheat1, DoPreheat0);
+      MENU_ITEM_F(ICON_PLAPreheat, MSG_PREHEAT_1, onDrawPreheat1, DoPreheat0);
       #if PREHEAT_COUNT > 1
-        MENU_ITEM(ICON_ABSPreheat, PSTR("Preheat " PREHEAT_2_LABEL), onDrawPreheat2, DoPreheat1);
-      #endif
-      #if PREHEAT_COUNT > 2
-        MENU_ITEM(ICON_CustomPreheat, GET_TEXT_F(MSG_PREHEAT_CUSTOM), onDrawMenuItem, DoPreheat2);
+        MENU_ITEM(ICON_ABSPreheat, F("Preheat " PREHEAT_2_LABEL), onDrawPreheat2, DoPreheat1);
+        #if PREHEAT_COUNT > 2
+          MENU_ITEM(ICON_CustomPreheat, F("Preheat " PREHEAT_3_LABEL), onDrawMenuItem, DoPreheat2);
+        #endif
       #endif
     #endif
-    MENU_ITEM(ICON_Cool, GET_TEXT_F(MSG_COOLDOWN), onDrawCooldown, DoCoolDown);
-    MENU_ITEM(ICON_Language, PSTR(GET_TEXT_F(MSG_UI_LANGUAGE)), onDrawLanguage, SetLanguage);
+    MENU_ITEM_F(ICON_Cool, MSG_COOLDOWN, onDrawCooldown, DoCoolDown);
+    MENU_ITEM_F(ICON_Language, MSG_UI_LANGUAGE, onDrawLanguage, SetLanguage);
   }
   ui.reset_status(true);
   CurrentMenu->draw();
 }
 
 void Draw_Tramming_Menu() {
-  DWINUI::ClearMainArea();
   checkkey = Menu;
-  if (!TrammingMenu) TrammingMenu = new MenuClass();
-  if (CurrentMenu != TrammingMenu) {
-    CurrentMenu = TrammingMenu;
-    SetMenuTitle({0}, GET_TEXT_F(MSG_BED_TRAMMING)); // TODO: Chinese, English "Bed Tramming" JPG
-    DWINUI::MenuItemsPrepare(8);
-    MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_Prepare_Menu);
-    MENU_ITEM(ICON_Axis, GET_TEXT_F(MSG_LEVBED_FL), onDrawMenuItem, TramFL);
-    MENU_ITEM(ICON_Axis, GET_TEXT_F(MSG_LEVBED_FR), onDrawMenuItem, TramFR);
-    MENU_ITEM(ICON_Axis, GET_TEXT_F(MSG_LEVBED_BR), onDrawMenuItem, TramBR);
-    MENU_ITEM(ICON_Axis, GET_TEXT_F(MSG_LEVBED_BL), onDrawMenuItem, TramBL);
-    MENU_ITEM(ICON_Axis, GET_TEXT_F(MSG_LEVBED_C ), onDrawMenuItem, TramC );
-    #if HAS_ONESTEP_LEVELING
-      MENU_ITEM(ICON_ProbeSet, F("Bed tramming wizard"), onDrawMenuItem, Trammingwizard);
-      MENU_ITEM(ICON_ProbeSet, GET_TEXT_F(MSG_BED_TRAMMING_MANUAL), onDrawManualTramming, SetManualTramming);
+  if (SetMenu(TrammingMenu, GET_TEXT_F(MSG_BED_TRAMMING), 8)) {
+    BACK_ITEM(Draw_Prepare_Menu);
+    #if HAS_BED_PROBE
+      MENU_ITEM_F(ICON_ProbeSet, MSG_TRAMMING_WIZARD, onDrawMenuItem, Trammingwizard);
+      EDIT_ITEM_F(ICON_ProbeSet, MSG_BED_TRAMMING_MANUAL, onDrawChkbMenu, SetManualTramming, &HMI_data.FullManualTramming);
+    #else
+      MENU_ITEM(ICON_MoveZ0, F("Home Z and disable"), onDrawMenuItem, HomeZandDisable);
     #endif
+    MENU_ITEM_F(ICON_Axis, MSG_LEVBED_FL, onDrawMenuItem, TramFL);
+    MENU_ITEM_F(ICON_Axis, MSG_LEVBED_FR, onDrawMenuItem, TramFR);
+    MENU_ITEM_F(ICON_Axis, MSG_LEVBED_BR, onDrawMenuItem, TramBR);
+    MENU_ITEM_F(ICON_Axis, MSG_LEVBED_BL, onDrawMenuItem, TramBL);
+    MENU_ITEM(ICON_Axis, GET_TEXT_F(MSG_LEVBED_C ), onDrawMenuItem, TramC );
   }
-  CurrentMenu->draw();
+  UpdateMenu(TrammingMenu);
 }
 
 void Draw_Control_Menu() {
   checkkey = Menu;
   if (!ControlMenu) ControlMenu = new MenuClass();
   if (CurrentMenu != ControlMenu) {
     CurrentMenu = ControlMenu;
     SetMenuTitle({103, 1, 28, 14}, GET_TEXT_F(MSG_CONTROL));
-    DWINUI::MenuItemsPrepare(10);
-    MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Goto_Main_Menu);
+    MenuItemsPrepare(10);
+    BACK_ITEM(Goto_Main_Menu);
+    MENU_ITEM_F(ICON_Temperature, MSG_TEMPERATURE, onDrawTempSubMenu, Draw_Temperature_Menu);
+    MENU_ITEM_F(ICON_Motion, MSG_MOTION, onDrawMotionSubMenu, Draw_Motion_Menu);
+    #if ENABLED(EEPROM_SETTINGS)
+      MENU_ITEM_F(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawWriteEeprom, WriteEeprom);
+      MENU_ITEM_F(ICON_ReadEEPROM, MSG_LOAD_EEPROM, onDrawReadEeprom, ReadEeprom);
+      MENU_ITEM_F(ICON_ResumeEEPROM, MSG_RESTORE_DEFAULTS, onDrawResetEeprom, ResetEeprom);
+    #endif
+    MENU_ITEM_F(ICON_Reboot, MSG_RESET_PRINTER, onDrawMenuItem, RebootPrinter);
     #if ENABLED(CASE_LIGHT_MENU)
       #if ENABLED(CASELIGHT_USES_BRIGHTNESS)
-        MENU_ITEM(ICON_CaseLight, GET_TEXT_F(MSG_CASE_LIGHT), onDrawSubMenu, Draw_CaseLight_Menu);
+        MENU_ITEM_F(ICON_CaseLight, MSG_CASE_LIGHT, onDrawSubMenu, Draw_CaseLight_Menu);
       #else
-        MENU_ITEM(ICON_CaseLight, GET_TEXT_F(MSG_CASE_LIGHT), onDrawCaseLight, SetCaseLight);
+        MENU_ITEM_F(ICON_CaseLight, MSG_CASE_LIGHT, onDrawChkbMenu, SetCaseLight, &caselight.on);
       #endif
     #endif
     #if ENABLED(LED_CONTROL_MENU)
-      MENU_ITEM(ICON_LedControl, GET_TEXT_F(MSG_LED_CONTROL), onDrawSubMenu, Draw_LedControl_Menu);
+      MENU_ITEM_F(ICON_LedControl, MSG_LED_CONTROL, onDrawSubMenu, Draw_LedControl_Menu);
     #endif
-    MENU_ITEM(ICON_Temperature, GET_TEXT_F(MSG_TEMPERATURE), onDrawTempSubMenu, Draw_Temperature_Menu);
-    MENU_ITEM(ICON_Motion, GET_TEXT_F(MSG_MOTION), onDrawMotionSubMenu, Draw_Motion_Menu);
-    #if ENABLED(EEPROM_SETTINGS)
-      MENU_ITEM(ICON_WriteEEPROM, GET_TEXT_F(MSG_STORE_EEPROM), onDrawWriteEeprom, WriteEeprom);
-      MENU_ITEM(ICON_ReadEEPROM, GET_TEXT_F(MSG_LOAD_EEPROM), onDrawReadEeprom, ReadEeprom);
-      MENU_ITEM(ICON_ResumeEEPROM, GET_TEXT_F(MSG_RESTORE_DEFAULTS), onDrawResetEeprom, ResetEeprom);
-    #endif
-    MENU_ITEM(ICON_Reboot, GET_TEXT_F(MSG_RESET_PRINTER), onDrawMenuItem, RebootPrinter);
-    MENU_ITEM(ICON_Info, GET_TEXT_F(MSG_INFO_SCREEN), onDrawInfoSubMenu, Goto_Info_Menu);
+    MENU_ITEM_F(ICON_Info, MSG_INFO_SCREEN, onDrawInfoSubMenu, Goto_Info_Menu);
   }
   ui.reset_status(true);
   CurrentMenu->draw();
 }
 
 void Draw_AdvancedSettings_Menu() {
   checkkey = Menu;
-  if (!AdvancedSettings) AdvancedSettings = new MenuClass();
-  if (CurrentMenu != AdvancedSettings) {
-    CurrentMenu = AdvancedSettings;
-    SetMenuTitle({0}, GET_TEXT_F(MSG_ADVANCED_SETTINGS)); // TODO: Chinese, English "Advanced Settings" JPG
-    DWINUI::MenuItemsPrepare(17);
-    MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Goto_Main_Menu);
+  if (SetMenu(AdvancedSettings, GET_TEXT_F(MSG_ADVANCED_SETTINGS), 20)) {
+    BACK_ITEM(Goto_Main_Menu);
     #if ENABLED(EEPROM_SETTINGS)
-      MENU_ITEM(ICON_WriteEEPROM, GET_TEXT_F(MSG_STORE_EEPROM), onDrawMenuItem, WriteEeprom);
-    #endif
-    #if HAS_HOME_OFFSET
-      MENU_ITEM(ICON_HomeOffset, GET_TEXT_F(MSG_SET_HOME_OFFSETS), onDrawSubMenu, Draw_HomeOffset_Menu);
+      MENU_ITEM_F(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawMenuItem, WriteEeprom);
     #endif
     #if HAS_BED_PROBE
-      MENU_ITEM(ICON_ProbeSet, GET_TEXT_F(MSG_ZPROBE_SETTINGS), onDrawSubMenu, Draw_ProbeSet_Menu);
+      MENU_ITEM_F(ICON_ProbeSet, MSG_ZPROBE_SETTINGS, onDrawSubMenu, Draw_ProbeSet_Menu);
+    #endif
+    #if HAS_MESH
+      MENU_ITEM_F(ICON_ProbeSet, MSG_MESH_LEVELING, onDrawSubMenu, Draw_MeshSet_Menu);
+    #endif
+    #if HAS_HOME_OFFSET
+      MENU_ITEM_F(ICON_HomeOffset, MSG_SET_HOME_OFFSETS, onDrawSubMenu, Draw_HomeOffset_Menu);
     #endif
     #if HAS_HOTEND
-      MENU_ITEM(ICON_PIDNozzle, F("Hotend PID Settings"), onDrawSubMenu, Draw_HotendPID_Menu);
+      MENU_ITEM(ICON_PIDNozzle, F(STR_HOTEND_PID " Settings"), onDrawSubMenu, Draw_HotendPID_Menu);
     #endif
     #if HAS_HEATED_BED
-      MENU_ITEM(ICON_PIDbed, F("Bed PID Settings"), onDrawSubMenu, Draw_BedPID_Menu);
-    #endif
-    #if HAS_FILAMENT_SENSOR
-      MENU_ITEM(ICON_FilSet, GET_TEXT_F(MSG_FILAMENT_SET), onDrawSubMenu, Draw_FilSet_Menu);
+      MENU_ITEM(ICON_PIDbed, F(STR_BED_PID " Settings"), onDrawSubMenu, Draw_BedPID_Menu);
     #endif
+      MENU_ITEM_F(ICON_FilSet, MSG_FILAMENT_SET, onDrawSubMenu, Draw_FilSet_Menu);
     #if ENABLED(POWER_LOSS_RECOVERY)
-      MENU_ITEM(ICON_Pwrlossr, GET_TEXT_F(MSG_OUTAGE_RECOVERY), onDrawPwrLossR, SetPwrLossr);
+      EDIT_ITEM_F(ICON_Pwrlossr, MSG_OUTAGE_RECOVERY, onDrawChkbMenu, SetPwrLossr, &recovery.enabled);
     #endif
     #if ENABLED(BAUD_RATE_GCODE)
-      MENU_ITEM(ICON_SetBaudRate, F("115K baud"), onDrawBaudrate, SetBaudRate);
+      EDIT_ITEM(ICON_SetBaudRate, F("115K baud"), onDrawChkbMenu, SetBaudRate, &HMI_data.Baud115K);
     #endif
     #if HAS_LCD_BRIGHTNESS
-      EDIT_ITEM(ICON_Brightness, GET_TEXT_F(MSG_BRIGHTNESS), onDrawPInt8Menu, SetBrightness, &ui.brightness);
+      EDIT_ITEM_F(ICON_Brightness, MSG_BRIGHTNESS, onDrawPInt8Menu, SetBrightness, &ui.brightness);
+      MENU_ITEM_F(ICON_Brightness, MSG_BRIGHTNESS_OFF, onDrawMenuItem, TurnOffBacklight);
     #endif
-    MENU_ITEM(ICON_Scolor, GET_TEXT_F(MSG_COLORS_SELECT), onDrawSubMenu, Draw_SelectColors_Menu);
+    MENU_ITEM_F(ICON_Scolor, MSG_COLORS_SELECT, onDrawSubMenu, Draw_SelectColors_Menu);
     #if ENABLED(SOUND_MENU_ITEM)
-      MENU_ITEM(ICON_Sound, GET_TEXT_F(MSG_SOUND_ENABLE), onDrawEnableSound, SetEnableSound);
-    #endif
-    #if HAS_MESH
-      MENU_ITEM(ICON_MeshViewer, GET_TEXT_F(MSG_MESH_VIEW), onDrawSubMenu, DWIN_MeshViewer);
+      EDIT_ITEM_F(ICON_Sound, MSG_SOUND_ENABLE, onDrawChkbMenu, SetEnableSound, &ui.sound_on);
     #endif
     #if HAS_ESDIAG
       MENU_ITEM(ICON_ESDiag, F("End-stops diag."), onDrawSubMenu, Draw_EndStopDiag);
     #endif
     #if ENABLED(PRINTCOUNTER)
-      MENU_ITEM(ICON_PrintStats, GET_TEXT_F(MSG_INFO_STATS_MENU), onDrawSubMenu, Goto_PrintStats);
-      MENU_ITEM(ICON_PrintStatsReset, GET_TEXT_F(MSG_INFO_PRINT_COUNT_RESET), onDrawSubMenu, PrintStats.Reset);
+      MENU_ITEM_F(ICON_PrintStats, MSG_INFO_STATS_MENU, onDrawSubMenu, Goto_PrintStats);
+      MENU_ITEM_F(ICON_PrintStatsReset, MSG_INFO_PRINT_COUNT_RESET, onDrawSubMenu, PrintStats.Reset);
     #endif
-    MENU_ITEM(ICON_Lock, GET_TEXT_F(MSG_LOCKSCREEN), onDrawMenuItem, DWIN_LockScreen);
+    MENU_ITEM_F(ICON_Lock, MSG_LOCKSCREEN, onDrawMenuItem, DWIN_LockScreen);
   }
   ui.reset_status(true);
-  CurrentMenu->draw();
+  UpdateMenu(AdvancedSettings);
 }
 
 void Draw_Move_Menu() {
   checkkey = Menu;
   if (!MoveMenu) MoveMenu = new MenuClass();
   if (CurrentMenu != MoveMenu) {
     CurrentMenu = MoveMenu;
     SetMenuTitle({192, 1, 42, 14}, GET_TEXT_F(MSG_MOVE_AXIS));
-    DWINUI::MenuItemsPrepare(5);
-    MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_Prepare_Menu);
-    EDIT_ITEM(ICON_MoveX, GET_TEXT_F(MSG_MOVE_X), onDrawMoveX, SetMoveX, &current_position.x);
-    EDIT_ITEM(ICON_MoveY, GET_TEXT_F(MSG_MOVE_Y), onDrawMoveY, SetMoveY, &current_position.y);
-    EDIT_ITEM(ICON_MoveZ, GET_TEXT_F(MSG_MOVE_Z), onDrawMoveZ, SetMoveZ, &current_position.z);
+    MenuItemsPrepare(5);
+    BACK_ITEM(Draw_Prepare_Menu);
+    EDIT_ITEM_F(ICON_MoveX, MSG_MOVE_X, onDrawMoveX, SetMoveX, &current_position.x);
+    EDIT_ITEM_F(ICON_MoveY, MSG_MOVE_Y, onDrawMoveY, SetMoveY, &current_position.y);
+    EDIT_ITEM_F(ICON_MoveZ, MSG_MOVE_Z, onDrawMoveZ, SetMoveZ, &current_position.z);
     #if HAS_HOTEND
-      EDIT_ITEM(ICON_Extruder, GET_TEXT_F(MSG_MOVE_E), onDrawMoveE, SetMoveE, &current_position.e);
+      EDIT_ITEM_F(ICON_Extruder, MSG_MOVE_E, onDrawMoveE, SetMoveE, &current_position.e);
     #endif
   }
   CurrentMenu->draw();
-  if (!all_axes_trusted()) LCD_MESSAGE_F("WARNING: current position is unknown, home axes");
+  if (!all_axes_trusted()) LCD_MESSAGE_F("WARNING: Current position unknown. Home axes.");
 }
 
 #if HAS_HOME_OFFSET
   void Draw_HomeOffset_Menu() {
     checkkey = Menu;
-    if (!HomeOffMenu) HomeOffMenu = new MenuClass();
-    if (CurrentMenu != HomeOffMenu) {
-      CurrentMenu = HomeOffMenu;
-      SetMenuTitle({0}, GET_TEXT_F(MSG_SET_HOME_OFFSETS)); // TODO: Chinese, English "Set Home Offsets" JPG
-      DWINUI::MenuItemsPrepare(4);
-      MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_AdvancedSettings_Menu);
-      EDIT_ITEM(ICON_HomeOffsetX, GET_TEXT_F(MSG_HOME_OFFSET_X), onDrawPFloatMenu, SetHomeOffsetX, &home_offset[X_AXIS]);
-      EDIT_ITEM(ICON_HomeOffsetY, GET_TEXT_F(MSG_HOME_OFFSET_Y), onDrawPFloatMenu, SetHomeOffsetY, &home_offset[Y_AXIS]);
-      EDIT_ITEM(ICON_HomeOffsetZ, GET_TEXT_F(MSG_HOME_OFFSET_Z), onDrawPFloatMenu, SetHomeOffsetZ, &home_offset[Z_AXIS]);
+    if (SetMenu(HomeOffMenu, GET_TEXT_F(MSG_SET_HOME_OFFSETS), 4)) {
+      BACK_ITEM(Draw_AdvancedSettings_Menu);
+      EDIT_ITEM_F(ICON_HomeOffsetX, MSG_HOME_OFFSET_X, onDrawPFloatMenu, SetHomeOffsetX, &home_offset.x);
+      EDIT_ITEM_F(ICON_HomeOffsetY, MSG_HOME_OFFSET_Y, onDrawPFloatMenu, SetHomeOffsetY, &home_offset.y);
+      EDIT_ITEM_F(ICON_HomeOffsetZ, MSG_HOME_OFFSET_Z, onDrawPFloatMenu, SetHomeOffsetZ, &home_offset.z);
     }
-    CurrentMenu->draw();
+    UpdateMenu(HomeOffMenu);
   }
 #endif
 
 #if HAS_BED_PROBE
   void Draw_ProbeSet_Menu() {
     checkkey = Menu;
-    if (!ProbeSetMenu) ProbeSetMenu = new MenuClass();
-    if (CurrentMenu != ProbeSetMenu) {
-      CurrentMenu = ProbeSetMenu;
-      SetMenuTitle({0}, GET_TEXT_F(MSG_ZPROBE_SETTINGS)); // TODO: Chinese, English "Probe Settings" JPG
-      DWINUI::MenuItemsPrepare(9);
-      MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_AdvancedSettings_Menu);
-      EDIT_ITEM(ICON_ProbeOffsetX, GET_TEXT_F(MSG_ZPROBE_XOFFSET), onDrawPFloatMenu, SetProbeOffsetX, &probe.offset.x);
-      EDIT_ITEM(ICON_ProbeOffsetY, GET_TEXT_F(MSG_ZPROBE_YOFFSET), onDrawPFloatMenu, SetProbeOffsetY, &probe.offset.y);
-      EDIT_ITEM(ICON_ProbeOffsetZ, GET_TEXT_F(MSG_ZPROBE_ZOFFSET), onDrawPFloat2Menu, SetProbeOffsetZ, &probe.offset.z);
-      #if BOTH(HAS_HEATED_BED, PREHEAT_BEFORE_LEVELING)
-        EDIT_ITEM(ICON_Temperature, GET_TEXT_F(MSG_UBL_SET_TEMP_BED), onDrawPIntMenu, SetBedLevT, &HMI_data.BedLevT);
-      #endif
+    if (SetMenu(ProbeSetMenu, GET_TEXT_F(MSG_ZPROBE_SETTINGS), 8)) {
+      BACK_ITEM(Draw_AdvancedSettings_Menu);
+      EDIT_ITEM_F(ICON_ProbeOffsetX, MSG_ZPROBE_XOFFSET, onDrawPFloatMenu, SetProbeOffsetX, &probe.offset.x);
+      EDIT_ITEM_F(ICON_ProbeOffsetY, MSG_ZPROBE_YOFFSET, onDrawPFloatMenu, SetProbeOffsetY, &probe.offset.y);
+      EDIT_ITEM_F(ICON_ProbeOffsetZ, MSG_ZPROBE_ZOFFSET, onDrawPFloat2Menu, SetProbeOffsetZ, &probe.offset.z);
       #ifdef BLTOUCH_HS_MODE
-        MENU_ITEM(ICON_HSMode, F("Enable HS mode"), onDrawHSMode, SetHSMode);
+        EDIT_ITEM_F(ICON_HSMode, MSG_ENABLE_HS_MODE, onDrawChkbMenu, SetHSMode, &bltouch.high_speed_mode);
       #endif
-      MENU_ITEM(ICON_ProbeTest, GET_TEXT_F(MSG_M48_TEST), onDrawMenuItem, ProbeTest);
-      MENU_ITEM(ICON_ProbeStow, GET_TEXT_F(MSG_MANUAL_STOW), onDrawMenuItem, ProbeStow);
-      MENU_ITEM(ICON_ProbeDeploy, GET_TEXT_F(MSG_MANUAL_DEPLOY), onDrawMenuItem, ProbeDeploy);
+      MENU_ITEM_F(ICON_ProbeTest, MSG_M48_TEST, onDrawMenuItem, ProbeTest);
+      MENU_ITEM_F(ICON_ProbeStow, MSG_MANUAL_STOW, onDrawMenuItem, ProbeStow);
+      MENU_ITEM_F(ICON_ProbeDeploy, MSG_MANUAL_DEPLOY, onDrawMenuItem, ProbeDeploy);
     }
-    CurrentMenu->draw();
+    UpdateMenu(ProbeSetMenu);
   }
+
 #endif
 
-#if HAS_FILAMENT_SENSOR
-  void Draw_FilSet_Menu() {
-    checkkey = Menu;
-    if (!FilSetMenu) FilSetMenu = new MenuClass();
-    if (CurrentMenu != FilSetMenu) {
-      CurrentMenu = FilSetMenu;
-      CurrentMenu->MenuTitle.SetCaption(GET_TEXT_F(MSG_FILAMENT_SET));
-      DWINUI::MenuItemsPrepare(10);
-      MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawMenuItem, Draw_AdvancedSettings_Menu);
-      #if HAS_FILAMENT_SENSOR
-        MENU_ITEM(ICON_Runout, GET_TEXT_F(MSG_RUNOUT_ENABLE), onDrawRunoutEnable, SetRunoutEnable);
-      #endif
-      #if HAS_FILAMENT_RUNOUT_DISTANCE
-        EDIT_ITEM(ICON_Runout, F("Runout Distance"), onDrawPFloatMenu, SetRunoutDistance, &runout.runout_distance());
-      #endif
-      #if ENABLED(PREVENT_COLD_EXTRUSION)
-        EDIT_ITEM(ICON_ExtrudeMinT, F("Extrude Min Temp."), onDrawPIntMenu, SetExtMinT, &HMI_data.ExtMinT);
-      #endif
-      #if ENABLED(ADVANCED_PAUSE_FEATURE)
-        EDIT_ITEM(ICON_FilLoad, GET_TEXT_F(MSG_FILAMENT_LOAD), onDrawPFloatMenu, SetFilLoad, &fc_settings[0].load_length);
-        EDIT_ITEM(ICON_FilUnload, GET_TEXT_F(MSG_FILAMENT_UNLOAD), onDrawPFloatMenu, SetFilUnload, &fc_settings[0].unload_length);
-      #endif
-      #if ENABLED(FWRETRACT)
-        EDIT_ITEM(ICON_FWRetLength, GET_TEXT_F(MSG_CONTROL_RETRACT), onDrawPFloatMenu, SetRetractLength, &fwretract.settings.retract_length);
-        EDIT_ITEM(ICON_FWRetSpeed, GET_TEXT_F(MSG_SINGLENOZZLE_RETRACT_SPEED), onDrawPFloatMenu, SetRetractSpeed, &fwretract.settings.retract_feedrate_mm_s);
-        EDIT_ITEM(ICON_FWRetZRaise, GET_TEXT_F(MSG_CONTROL_RETRACT_ZHOP), onDrawPFloat2Menu, SetZRaise, &fwretract.settings.retract_zraise);
-        EDIT_ITEM(ICON_FWRecSpeed, GET_TEXT_F(MSG_SINGLENOZZLE_UNRETRACT_SPEED), onDrawPFloatMenu, SetRecoverSpeed, &fwretract.settings.retract_recover_feedrate_mm_s);
-      #endif
-    }
-    CurrentMenu->draw();
+void Draw_FilSet_Menu() {
+  checkkey = Menu;
+  if (SetMenu(FilSetMenu, GET_TEXT_F(MSG_FILAMENT_SET), 9)) {
+    BACK_ITEM(Draw_AdvancedSettings_Menu);
+    #if HAS_FILAMENT_SENSOR
+      EDIT_ITEM_F(ICON_Runout, MSG_RUNOUT_ENABLE, onDrawChkbMenu, SetRunoutEnable, &runout.enabled);
+    #endif
+    #if HAS_FILAMENT_RUNOUT_DISTANCE
+      EDIT_ITEM_F(ICON_Runout, MSG_RUNOUT_DISTANCE_MM, onDrawPFloatMenu, SetRunoutDistance, &runout.runout_distance());
+    #endif
+    #if ENABLED(PREVENT_COLD_EXTRUSION)
+      EDIT_ITEM_F(ICON_ExtrudeMinT, MSG_EXTRUDER_MIN_TEMP, onDrawPIntMenu, SetExtMinT, &HMI_data.ExtMinT);
+    #endif
+    #if ENABLED(ADVANCED_PAUSE_FEATURE)
+      EDIT_ITEM_F(ICON_FilLoad, MSG_FILAMENT_LOAD, onDrawPFloatMenu, SetFilLoad, &fc_settings[0].load_length);
+      EDIT_ITEM_F(ICON_FilUnload, MSG_FILAMENT_UNLOAD, onDrawPFloatMenu, SetFilUnload, &fc_settings[0].unload_length);
+    #endif
+    #if ENABLED(FWRETRACT)
+      MENU_ITEM_F(ICON_FWRetract, MSG_FWRETRACT, onDrawSubMenu, Draw_FWRetract_Menu);
+    #endif
   }
-#endif // HAS_FILAMENT_SENSOR
+  UpdateMenu(FilSetMenu);
+}
 
 void Draw_SelectColors_Menu() {
   checkkey = Menu;
-  if (!SelectColorMenu) SelectColorMenu = new MenuClass();
-  if (CurrentMenu != SelectColorMenu) {
-    CurrentMenu = SelectColorMenu;
-    SetMenuTitle({0}, GET_TEXT_F(MSG_COLORS_SELECT)); // TODO: Chinese, English "Select Color" JPG
-    DWINUI::MenuItemsPrepare(20);
-    MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_AdvancedSettings_Menu);
-    MENU_ITEM(ICON_StockConfiguration, GET_TEXT_F(MSG_RESTORE_DEFAULTS), onDrawMenuItem, RestoreDefaultsColors);
-    EDIT_ITEM(0, "Screen Background", onDrawSelColorItem, SelColor, &HMI_data.Background_Color);
-    EDIT_ITEM(0, "Cursor", onDrawSelColorItem, SelColor, &HMI_data.Cursor_color);
-    EDIT_ITEM(0, "Title Background", onDrawSelColorItem, SelColor, &HMI_data.TitleBg_color);
-    EDIT_ITEM(0, "Title Text", onDrawSelColorItem, SelColor, &HMI_data.TitleTxt_color);
-    EDIT_ITEM(0, "Text", onDrawSelColorItem, SelColor, &HMI_data.Text_Color);
-    EDIT_ITEM(0, "Selected", onDrawSelColorItem, SelColor, &HMI_data.Selected_Color);
-    EDIT_ITEM(0, "Split Line", onDrawSelColorItem, SelColor, &HMI_data.SplitLine_Color);
-    EDIT_ITEM(0, "Highlight", onDrawSelColorItem, SelColor, &HMI_data.Highlight_Color);
-    EDIT_ITEM(0, "Status Background", onDrawSelColorItem, SelColor, &HMI_data.StatusBg_Color);
-    EDIT_ITEM(0, "Status Text", onDrawSelColorItem, SelColor, &HMI_data.StatusTxt_Color);
-    EDIT_ITEM(0, "Popup Background", onDrawSelColorItem, SelColor, &HMI_data.PopupBg_color);
-    EDIT_ITEM(0, "Popup Text", onDrawSelColorItem, SelColor, &HMI_data.PopupTxt_Color);
-    EDIT_ITEM(0, "Alert Background", onDrawSelColorItem, SelColor, &HMI_data.AlertBg_Color);
-    EDIT_ITEM(0, "Alert Text", onDrawSelColorItem, SelColor, &HMI_data.AlertTxt_Color);
-    EDIT_ITEM(0, "Percent Text", onDrawSelColorItem, SelColor, &HMI_data.PercentTxt_Color);
-    EDIT_ITEM(0, "Bar Fill", onDrawSelColorItem, SelColor, &HMI_data.Barfill_Color);
-    EDIT_ITEM(0, "Indicator value", onDrawSelColorItem, SelColor, &HMI_data.Indicator_Color);
-    EDIT_ITEM(0, "Coordinate value", onDrawSelColorItem, SelColor, &HMI_data.Coordinate_Color);
-  }
-  CurrentMenu->draw();
+  if (SetMenu(SelectColorMenu, GET_TEXT_F(MSG_COLORS_SELECT), 20)) {
+    BACK_ITEM(Draw_AdvancedSettings_Menu);
+    MENU_ITEM_F(ICON_StockConfiguration, MSG_RESTORE_DEFAULTS, onDrawMenuItem, RestoreDefaultsColors);
+    EDIT_ITEM(0, F("Screen Background"), onDrawSelColorItem, SelColor, &HMI_data.Background_Color);
+    EDIT_ITEM(0, F("Cursor"), onDrawSelColorItem, SelColor, &HMI_data.Cursor_color);
+    EDIT_ITEM(0, F("Title Background"), onDrawSelColorItem, SelColor, &HMI_data.TitleBg_color);
+    EDIT_ITEM(0, F("Title Text"), onDrawSelColorItem, SelColor, &HMI_data.TitleTxt_color);
+    EDIT_ITEM(0, F("Text"), onDrawSelColorItem, SelColor, &HMI_data.Text_Color);
+    EDIT_ITEM(0, F("Selected"), onDrawSelColorItem, SelColor, &HMI_data.Selected_Color);
+    EDIT_ITEM(0, F("Split Line"), onDrawSelColorItem, SelColor, &HMI_data.SplitLine_Color);
+    EDIT_ITEM(0, F("Highlight"), onDrawSelColorItem, SelColor, &HMI_data.Highlight_Color);
+    EDIT_ITEM(0, F("Status Background"), onDrawSelColorItem, SelColor, &HMI_data.StatusBg_Color);
+    EDIT_ITEM(0, F("Status Text"), onDrawSelColorItem, SelColor, &HMI_data.StatusTxt_Color);
+    EDIT_ITEM(0, F("Popup Background"), onDrawSelColorItem, SelColor, &HMI_data.PopupBg_color);
+    EDIT_ITEM(0, F("Popup Text"), onDrawSelColorItem, SelColor, &HMI_data.PopupTxt_Color);
+    EDIT_ITEM(0, F("Alert Background"), onDrawSelColorItem, SelColor, &HMI_data.AlertBg_Color);
+    EDIT_ITEM(0, F("Alert Text"), onDrawSelColorItem, SelColor, &HMI_data.AlertTxt_Color);
+    EDIT_ITEM(0, F("Percent Text"), onDrawSelColorItem, SelColor, &HMI_data.PercentTxt_Color);
+    EDIT_ITEM(0, F("Bar Fill"), onDrawSelColorItem, SelColor, &HMI_data.Barfill_Color);
+    EDIT_ITEM(0, F("Indicator value"), onDrawSelColorItem, SelColor, &HMI_data.Indicator_Color);
+    EDIT_ITEM(0, F("Coordinate value"), onDrawSelColorItem, SelColor, &HMI_data.Coordinate_Color);
+  }
+  UpdateMenu(SelectColorMenu);
 }
 
 void Draw_GetColor_Menu() {
   checkkey = Menu;
-  if (!GetColorMenu) GetColorMenu = new MenuClass();
-  if (CurrentMenu != GetColorMenu) {
-    CurrentMenu = GetColorMenu;
-    SetMenuTitle({0}, GET_TEXT_F(MSG_COLORS_GET)); // TODO: Chinese, English "Get Color" JPG
-    DWINUI::MenuItemsPrepare(5);
-    MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, DWIN_ApplyColor);
-    MENU_ITEM(ICON_Cancel, GET_TEXT_F(MSG_BUTTON_CANCEL), onDrawMenuItem, Draw_SelectColors_Menu);
-    MENU_ITEM(0, GET_TEXT_F(MSG_COLORS_RED), onDrawGetColorItem, SetRGBColor);
-    MENU_ITEM(1, GET_TEXT_F(MSG_COLORS_GREEN), onDrawGetColorItem, SetRGBColor);
-    MENU_ITEM(2, GET_TEXT_F(MSG_COLORS_BLUE), onDrawGetColorItem, SetRGBColor);
-  }
-  CurrentMenu->draw();
+  if (SetMenu(GetColorMenu, GET_TEXT_F(MSG_COLORS_GET), 5)) {
+    BACK_ITEM(DWIN_ApplyColor);
+    MENU_ITEM_F(ICON_Cancel, MSG_BUTTON_CANCEL, onDrawMenuItem, Draw_SelectColors_Menu);
+    MENU_ITEM_F(0, MSG_COLORS_RED, onDrawGetColorItem, SetRGBColor);
+    MENU_ITEM_F(1, MSG_COLORS_GREEN, onDrawGetColorItem, SetRGBColor);
+    MENU_ITEM_F(2, MSG_COLORS_BLUE, onDrawGetColorItem, SetRGBColor);
+  }
+  UpdateMenu(GetColorMenu);
   DWIN_Draw_Rectangle(1, *MenuData.P_Int, 20, 315, DWIN_WIDTH - 20, 335);
 }
 
 #if BOTH(CASE_LIGHT_MENU, CASELIGHT_USES_BRIGHTNESS)
     void Draw_CaseLight_Menu() {
       checkkey = Menu;
-      if (!CaseLightMenu) CaseLightMenu = new MenuClass();
-      if (CurrentMenu != CaseLightMenu) {
-        CurrentMenu = CaseLightMenu;
-        SetMenuTitle({0}, GET_TEXT_F(MSG_CASE_LIGHT)); // TODO: Chinese, English "Case Light" JPG
-        DWINUI::MenuItemsPrepare(3);
-        MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_Control_Menu);
-        MENU_ITEM(ICON_CaseLight, GET_TEXT_F(MSG_CASE_LIGHT), onDrawCaseLight, SetCaseLight);
-        EDIT_ITEM(ICON_Brightness, GET_TEXT_F(MSG_CASE_LIGHT_BRIGHTNESS), onDrawPInt8Menu, SetCaseLightBrightness, &caselight.brightness);
+      if (SetMenu(CaseLightMenu, GET_TEXT_F(MSG_CASE_LIGHT), 3)) {
+        BACK_ITEM(Draw_Control_Menu);
+        EDIT_ITEM_F(ICON_CaseLight, MSG_CASE_LIGHT, onDrawChkbMenu, SetCaseLight, &caselight.on);
+        EDIT_ITEM_F(ICON_Brightness, MSG_CASE_LIGHT_BRIGHTNESS, onDrawPInt8Menu, SetCaseLightBrightness, &caselight.brightness);
       }
-      CurrentMenu->draw();
+      UpdateMenu(CaseLightMenu);
     }
 #endif
 
 #if ENABLED(LED_CONTROL_MENU)
     void Draw_LedControl_Menu() {
       checkkey = Menu;
-      if (!LedControlMenu) LedControlMenu = new MenuClass();
-      if (CurrentMenu != LedControlMenu) {
-        CurrentMenu = LedControlMenu;
-        SetMenuTitle({0}, GET_TEXT_F(MSG_LED_CONTROL)); // TODO: Chinese, English "LED Control" JPG
-        DWINUI::MenuItemsPrepare(6);
-        MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_Control_Menu);
+      if (SetMenu(LedControlMenu, GET_TEXT_F(MSG_LED_CONTROL), 6)) {
+        BACK_ITEM(Draw_Control_Menu);
         #if !BOTH(CASE_LIGHT_MENU, CASE_LIGHT_USE_NEOPIXEL)
-          MENU_ITEM(ICON_LedControl, GET_TEXT_F(MSG_LEDS), onDrawLedStatus, SetLedStatus);
+          EDIT_ITEM_F(ICON_LedControl, MSG_LEDS, onDrawChkbMenu, SetLedStatus, &leds.lights_on);
         #endif
         #if HAS_COLOR_LEDS
-          EDIT_ITEM(ICON_LedControl, GET_TEXT_F(MSG_COLORS_RED), onDrawPInt8Menu, SetLedColorR, &leds.color.r);
-          EDIT_ITEM(ICON_LedControl, GET_TEXT_F(MSG_COLORS_GREEN), onDrawPInt8Menu, SetLedColorG, &leds.color.g);
-          EDIT_ITEM(ICON_LedControl, GET_TEXT_F(MSG_COLORS_BLUE), onDrawPInt8Menu, SetLedColorB, &leds.color.b);
+          EDIT_ITEM_F(ICON_LedControl, MSG_COLORS_RED, onDrawPInt8Menu, SetLEDColorR, &leds.color.r);
+          EDIT_ITEM_F(ICON_LedControl, MSG_COLORS_GREEN, onDrawPInt8Menu, SetLEDColorG, &leds.color.g);
+          EDIT_ITEM_F(ICON_LedControl, MSG_COLORS_BLUE, onDrawPInt8Menu, SetLEDColorB, &leds.color.b);
           #if ENABLED(HAS_WHITE_LED)
-            EDIT_ITEM(ICON_LedControl, GET_TEXT_F(MSG_COLORS_WHITE), onDrawPInt8Menu, SetLedColorW, &leds.color.w);
+            EDIT_ITEM_F(ICON_LedControl, MSG_COLORS_WHITE, onDrawPInt8Menu, SetLedColorW, &leds.color.w);
           #endif
         #endif
       }
-      CurrentMenu->draw();
+      UpdateMenu(LedControlMenu);
     }
 #endif
 
 void Draw_Tune_Menu() {
   checkkey = Menu;
   if (!TuneMenu) TuneMenu = new MenuClass();
   if (CurrentMenu != TuneMenu) {
     CurrentMenu = TuneMenu;
     SetMenuTitle({73, 2, 28, 12}, GET_TEXT_F(MSG_TUNE)); // TODO: Chinese, English "Tune" JPG
-    DWINUI::MenuItemsPrepare(16);
-    MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Goto_PrintProcess);
-    #if ENABLED(CASE_LIGHT_MENU)
-      MENU_ITEM(ICON_CaseLight, GET_TEXT_F(MSG_CASE_LIGHT), onDrawCaseLight, SetCaseLight);
-    #elif ENABLED(LED_CONTROL_MENU) && DISABLED(CASE_LIGHT_USE_NEOPIXEL)
-      MENU_ITEM(ICON_LedControl, GET_TEXT_F(MSG_LEDS), onDrawLedStatus, SetLedStatus);
-    #endif
-    EDIT_ITEM(ICON_Speed, GET_TEXT_F(MSG_SPEED), onDrawSpeedItem, SetSpeed, &feedrate_percentage);
+    MenuItemsPrepare(16);
+    BACK_ITEM(Goto_PrintProcess);
+    EDIT_ITEM_F(ICON_Speed, MSG_SPEED, onDrawSpeedItem, SetSpeed, &feedrate_percentage);
     #if HAS_HOTEND
-      HotendTargetItem = EDIT_ITEM(ICON_HotendTemp, GET_TEXT_F(MSG_UBL_SET_TEMP_HOTEND), onDrawHotendTemp, SetHotendTemp, &thermalManager.temp_hotend[0].target);
+      HotendTargetItem = EDIT_ITEM_F(ICON_HotendTemp, MSG_UBL_SET_TEMP_HOTEND, onDrawHotendTemp, SetHotendTemp, &thermalManager.temp_hotend[0].target);
     #endif
     #if HAS_HEATED_BED
-      BedTargetItem = EDIT_ITEM(ICON_BedTemp, GET_TEXT_F(MSG_UBL_SET_TEMP_BED), onDrawBedTemp, SetBedTemp, &thermalManager.temp_bed.target);
+      BedTargetItem = EDIT_ITEM_F(ICON_BedTemp, MSG_UBL_SET_TEMP_BED, onDrawBedTemp, SetBedTemp, &thermalManager.temp_bed.target);
     #endif
     #if HAS_FAN
-      FanSpeedItem = EDIT_ITEM(ICON_FanSpeed, GET_TEXT_F(MSG_FAN_SPEED), onDrawFanSpeed, SetFanSpeed, &thermalManager.fan_speed[0]);
+      FanSpeedItem = EDIT_ITEM_F(ICON_FanSpeed, MSG_FAN_SPEED, onDrawFanSpeed, SetFanSpeed, &thermalManager.fan_speed[0]);
     #endif
-    #if HAS_ZOFFSET_ITEM && EITHER(HAS_BED_PROBE, BABYSTEPPING)
-      EDIT_ITEM(ICON_Zoffset, GET_TEXT_F(MSG_ZPROBE_ZOFFSET), onDrawZOffset, SetZOffset, &BABY_Z_VAR);
-    #endif
-    #if ENABLED(FWRETRACT)
-      EDIT_ITEM(ICON_FWRetLength, GET_TEXT_F(MSG_CONTROL_RETRACT), onDrawPFloatMenu, SetRetractLength, &fwretract.settings.retract_length);
-      EDIT_ITEM(ICON_FWRetSpeed, GET_TEXT_F(MSG_SINGLENOZZLE_RETRACT_SPEED), onDrawPFloatMenu, SetRetractSpeed, &fwretract.settings.retract_feedrate_mm_s);
-      EDIT_ITEM(ICON_FWRetZRaise, GET_TEXT_F(MSG_CONTROL_RETRACT_ZHOP), onDrawPFloat2Menu, SetZRaise, &fwretract.settings.retract_zraise);
-      EDIT_ITEM(ICON_FWRecSpeed, GET_TEXT_F(MSG_SINGLENOZZLE_UNRETRACT_SPEED), onDrawPFloatMenu, SetRecoverSpeed, &fwretract.settings.retract_recover_feedrate_mm_s);
+    #if HAS_ZOFFSET_ITEM && EITHER(BABYSTEP_ZPROBE_OFFSET, JUST_BABYSTEP)
+      EDIT_ITEM_F(ICON_Zoffset, MSG_ZPROBE_ZOFFSET, onDrawZOffset, SetZOffset, &BABY_Z_VAR);
     #endif
-    EDIT_ITEM(ICON_Flow, GET_TEXT_F(MSG_FLOW), onDrawPIntMenu, SetFlow, &planner.flow_percentage[0]);
+    EDIT_ITEM_F(ICON_Flow, MSG_FLOW, onDrawPIntMenu, SetFlow, &planner.flow_percentage[0]);
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
-      MENU_ITEM(ICON_FilMan, GET_TEXT_F(MSG_FILAMENTCHANGE), onDrawMenuItem, ChangeFilament);
+      MENU_ITEM_F(ICON_FilMan, MSG_FILAMENTCHANGE, onDrawMenuItem, ChangeFilament);
     #endif
-    MENU_ITEM(ICON_Lock, GET_TEXT_F(MSG_LOCKSCREEN), onDrawMenuItem, DWIN_LockScreen);
+    #if ENABLED(FWRETRACT)
+      MENU_ITEM_F(ICON_FWRetract, MSG_FWRETRACT, onDrawSubMenu, Draw_FWRetract_Menu);
+    #endif
+    MENU_ITEM_F(ICON_Lock, MSG_LOCKSCREEN, onDrawMenuItem, DWIN_LockScreen);
     #if HAS_LCD_BRIGHTNESS
-      EDIT_ITEM(ICON_Brightness, GET_TEXT_F(MSG_BRIGHTNESS), onDrawPInt8Menu, SetBrightness, &ui.brightness);
-      MENU_ITEM(ICON_Brightness, GET_TEXT_F(MSG_BRIGHTNESS_OFF), onDrawMenuItem, TurnOffBacklight);
+      EDIT_ITEM_F(ICON_Brightness, MSG_BRIGHTNESS, onDrawPInt8Menu, SetBrightness, &ui.brightness);
+      MENU_ITEM_F(ICON_Brightness, MSG_BRIGHTNESS_OFF, onDrawMenuItem, TurnOffBacklight);
+    #endif
+    #if ENABLED(CASE_LIGHT_MENU)
+      EDIT_ITEM_F(ICON_CaseLight, MSG_CASE_LIGHT, onDrawChkbMenu, SetCaseLight, &caselight.on);
+    #elif ENABLED(LED_CONTROL_MENU) && DISABLED(CASE_LIGHT_USE_NEOPIXEL)
+      EDIT_ITEM_F(ICON_LedControl, MSG_LEDS, onDrawChkbMenu, SetLedStatus, &leds.lights_on);
     #endif
   }
   CurrentMenu->draw();
 }
 
 void Draw_Motion_Menu() {
   checkkey = Menu;
   if (!MotionMenu) MotionMenu = new MenuClass();
   if (CurrentMenu != MotionMenu) {
     CurrentMenu = MotionMenu;
     SetMenuTitle({1, 16, 28, 13}, GET_TEXT_F(MSG_MOTION)); // TODO: Chinese, English "Motion" JPG
-    DWINUI::MenuItemsPrepare(6);
-    MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_Control_Menu);
-    MENU_ITEM(ICON_MaxSpeed, GET_TEXT_F(MSG_SPEED), onDrawSpeed, Draw_MaxSpeed_Menu);
-    MENU_ITEM(ICON_MaxAccelerated, GET_TEXT_F(MSG_ACCELERATION), onDrawAcc, Draw_MaxAccel_Menu);
+    MenuItemsPrepare(6);
+    BACK_ITEM(Draw_Control_Menu);
+    MENU_ITEM_F(ICON_MaxSpeed, MSG_SPEED, onDrawSpeed, Draw_MaxSpeed_Menu);
+    MENU_ITEM_F(ICON_MaxAccelerated, MSG_ACCELERATION, onDrawAcc, Draw_MaxAccel_Menu);
     #if HAS_CLASSIC_JERK
-      MENU_ITEM(ICON_MaxJerk, GET_TEXT_F(MSG_JERK), onDrawJerk, Draw_MaxJerk_Menu);
+      MENU_ITEM_F(ICON_MaxJerk, MSG_JERK, onDrawJerk, Draw_MaxJerk_Menu);
     #endif
-    MENU_ITEM(ICON_Step, GET_TEXT_F(MSG_STEPS_PER_MM), onDrawSteps, Draw_Steps_Menu);
-    EDIT_ITEM(ICON_Flow, GET_TEXT_F(MSG_FLOW), onDrawPIntMenu, SetFlow, &planner.flow_percentage[0]);
+    MENU_ITEM_F(ICON_Step, MSG_STEPS_PER_MM, onDrawSteps, Draw_Steps_Menu);
+    EDIT_ITEM_F(ICON_Flow, MSG_FLOW, onDrawPIntMenu, SetFlow, &planner.flow_percentage[0]);
   }
   CurrentMenu->draw();
 }
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   void Draw_FilamentMan_Menu() {
     checkkey = Menu;
-    if (!FilamentMenu) FilamentMenu = new MenuClass();
-    if (CurrentMenu != FilamentMenu) {
-      CurrentMenu = FilamentMenu;
-      SetMenuTitle({0}, GET_TEXT_F(MSG_FILAMENT_MAN)); // TODO: Chinese, English "Filament Management" JPG
-      DWINUI::MenuItemsPrepare(5);
-      MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_Prepare_Menu);
-      MENU_ITEM(ICON_Park, GET_TEXT_F(MSG_FILAMENT_PARK_ENABLED), onDrawMenuItem, ParkHead);
-      MENU_ITEM(ICON_FilMan, GET_TEXT_F(MSG_FILAMENTCHANGE), onDrawMenuItem, ChangeFilament);
+    if (SetMenu(FilamentMenu, GET_TEXT_F(MSG_FILAMENT_MAN), 5)) {
+      BACK_ITEM(Draw_Prepare_Menu);
+      MENU_ITEM_F(ICON_Park, MSG_FILAMENT_PARK_ENABLED, onDrawMenuItem, ParkHead);
+      MENU_ITEM_F(ICON_FilMan, MSG_FILAMENTCHANGE, onDrawMenuItem, ChangeFilament);
       #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
-        MENU_ITEM(ICON_FilUnload, GET_TEXT_F(MSG_FILAMENTUNLOAD), onDrawMenuItem, UnloadFilament);
-        MENU_ITEM(ICON_FilLoad, GET_TEXT_F(MSG_FILAMENTLOAD), onDrawMenuItem, LoadFilament);
+        MENU_ITEM_F(ICON_FilUnload, MSG_FILAMENTUNLOAD, onDrawMenuItem, UnloadFilament);
+        MENU_ITEM_F(ICON_FilLoad, MSG_FILAMENTLOAD, onDrawMenuItem, LoadFilament);
       #endif
     }
-    CurrentMenu->draw();
+    UpdateMenu(FilamentMenu);
   }
 #endif
 
 #if ENABLED(MESH_BED_LEVELING)
   void Draw_ManualMesh_Menu() {
     checkkey = Menu;
-    if (!ManualMesh) ManualMesh = new MenuClass();
-    if (CurrentMenu != ManualMesh) {
-      CurrentMenu = ManualMesh;
-      SetMenuTitle({0}, GET_TEXT_F(MSG_MANUAL_MESH)); // TODO: Chinese, English "Manual Mesh Leveling" JPG
-      DWINUI::MenuItemsPrepare(6);
-      MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_Prepare_Menu);
-      MENU_ITEM(ICON_ManualMesh, GET_TEXT_F(MSG_LEVEL_BED), onDrawMenuItem, ManualMeshStart);
-      MMeshMoveZItem = EDIT_ITEM(ICON_Zoffset, GET_TEXT_F(MSG_MOVE_Z), onDrawMMeshMoveZ, SetMMeshMoveZ, &current_position.z);
-      MENU_ITEM(ICON_Axis, GET_TEXT_F(MSG_UBL_CONTINUE_MESH), onDrawMenuItem, ManualMeshContinue);
-      MENU_ITEM(ICON_MeshViewer, GET_TEXT_F(MSG_MESH_VIEW), onDrawSubMenu, DWIN_MeshViewer);
-      MENU_ITEM(ICON_MeshSave, GET_TEXT_F(MSG_UBL_SAVE_MESH), onDrawMenuItem, ManualMeshSave);
+    if (SetMenu(ManualMesh, GET_TEXT_F(MSG_UBL_MANUAL_MESH), 6)) {
+      BACK_ITEM(Draw_Prepare_Menu);
+      MENU_ITEM_F(ICON_ManualMesh, MSG_LEVEL_BED, onDrawMenuItem, ManualMeshStart);
+      MMeshMoveZItem = EDIT_ITEM_F(ICON_Zoffset, MSG_MOVE_Z, onDrawMMeshMoveZ, SetMMeshMoveZ, &current_position.z);
+      MENU_ITEM_F(ICON_Axis, MSG_UBL_CONTINUE_MESH, onDrawMenuItem, ManualMeshContinue);
+      MENU_ITEM_F(ICON_MeshViewer, MSG_MESH_VIEW, onDrawSubMenu, DWIN_MeshViewer);
+      MENU_ITEM_F(ICON_MeshSave, MSG_UBL_SAVE_MESH, onDrawMenuItem, ManualMeshSave);
     }
-    CurrentMenu->draw();
+    UpdateMenu(ManualMesh);
   }
 #endif
 
 #if HAS_PREHEAT
 
   void Draw_Preheat_Menu(frame_rect_t cn, const __FlashStringHelper* fstr) {
     checkkey = Menu;
     if (CurrentMenu != PreheatMenu) {
       CurrentMenu = PreheatMenu;
       SetMenuTitle(cn, fstr);
-      DWINUI::MenuItemsPrepare(5);
-      MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_Temperature_Menu);
+      MenuItemsPrepare(5);
+      BACK_ITEM(Draw_Temperature_Menu);
       #if HAS_HOTEND
-        EDIT_ITEM(ICON_SetEndTemp, GET_TEXT_F(MSG_UBL_SET_TEMP_HOTEND), onDrawSetPreheatHotend, SetPreheatEndTemp, &ui.material_preset[HMI_value.Preheat].hotend_temp);
+        EDIT_ITEM_F(ICON_SetEndTemp, MSG_UBL_SET_TEMP_HOTEND, onDrawSetPreheatHotend, SetPreheatEndTemp, &ui.material_preset[HMI_value.Select].hotend_temp);
       #endif
       #if HAS_HEATED_BED
-        EDIT_ITEM(ICON_SetBedTemp, GET_TEXT_F(MSG_UBL_SET_TEMP_BED), onDrawSetPreheatBed, SetPreheatBedTemp, &ui.material_preset[HMI_value.Preheat].bed_temp);
+        EDIT_ITEM_F(ICON_SetBedTemp, MSG_UBL_SET_TEMP_BED, onDrawSetPreheatBed, SetPreheatBedTemp, &ui.material_preset[HMI_value.Select].bed_temp);
       #endif
       #if HAS_FAN
-        EDIT_ITEM(ICON_FanSpeed, GET_TEXT_F(MSG_FAN_SPEED), onDrawSetPreheatFan, SetPreheatFanSpeed, &ui.material_preset[HMI_value.Preheat].fan_speed);
+        EDIT_ITEM_F(ICON_FanSpeed, MSG_FAN_SPEED, onDrawSetPreheatFan, SetPreheatFanSpeed, &ui.material_preset[HMI_value.Select].fan_speed);
       #endif
       #if ENABLED(EEPROM_SETTINGS)
-        MENU_ITEM(ICON_WriteEEPROM, GET_TEXT_F(MSG_STORE_EEPROM), onDrawWriteEeprom, WriteEeprom);
+        MENU_ITEM_F(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawWriteEeprom, WriteEeprom);
       #endif
     }
     CurrentMenu->draw();
   }
 
   void Draw_Preheat1_Menu() {
-    HMI_value.Preheat = 0;
+    HMI_value.Select = 0;
     if (!PreheatMenu) PreheatMenu = new MenuClass();
     Draw_Preheat_Menu({59, 16, 81, 14}, F(PREHEAT_1_LABEL " Preheat Settings")); // TODO: English "PLA Settings" JPG
   }
 
-  void Draw_Preheat2_Menu() {
-    HMI_value.Preheat = 1;
-    if (!PreheatMenu) PreheatMenu = new MenuClass();
-    Draw_Preheat_Menu({142, 16, 82, 14}, F(PREHEAT_2_LABEL " Preheat Settings"));  // TODO: English "ABS Settings" JPG
-  }
+  #if PREHEAT_COUNT >= 2
+    void Draw_Preheat2_Menu() {
+      HMI_value.Select = 1;
+      if (!PreheatMenu) PreheatMenu = new MenuClass();
+      Draw_Preheat_Menu({142, 16, 82, 14}, F(PREHEAT_2_LABEL " Preheat Settings"));  // TODO: English "ABS Settings" JPG
+    }
+  #endif
 
-  #ifdef PREHEAT_3_LABEL
+  #if PREHEAT_COUNT >= 3
     void Draw_Preheat3_Menu() {
-      HMI_value.Preheat = 2;
+      HMI_value.Select = 2;
       if (!PreheatMenu) PreheatMenu = new MenuClass();
-      #define PREHEAT_3_TITLE PREHEAT_3_LABEL " Preheat Set."
-      Draw_Preheat_Menu({0}, F(PREHEAT_3_TITLE));  // TODO: Chinese, English "Custom Preheat Settings" JPG
+      Draw_Preheat_Menu({225, 16, 82, 14}, F(PREHEAT_3_LABEL " Preheat Settings"));  // TODO: English "... Settings" JPG
     }
   #endif
 
 #endif // HAS_PREHEAT
 
 void Draw_Temperature_Menu() {
   checkkey = Menu;
   if (!TemperatureMenu) TemperatureMenu = new MenuClass();
   if (CurrentMenu != TemperatureMenu) {
     CurrentMenu = TemperatureMenu;
     SetMenuTitle({236, 2, 28, 12}, GET_TEXT_F(MSG_TEMPERATURE));
-    DWINUI::MenuItemsPrepare(7);
-    MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_Control_Menu);
+    MenuItemsPrepare(7);
+    BACK_ITEM(Draw_Control_Menu);
     #if HAS_HOTEND
-      HotendTargetItem = EDIT_ITEM(ICON_SetEndTemp, GET_TEXT_F(MSG_UBL_SET_TEMP_HOTEND), onDrawHotendTemp, SetHotendTemp, &thermalManager.temp_hotend[0].target);
+      HotendTargetItem = EDIT_ITEM_F(ICON_SetEndTemp, MSG_UBL_SET_TEMP_HOTEND, onDrawHotendTemp, SetHotendTemp, &thermalManager.temp_hotend[0].target);
     #endif
     #if HAS_HEATED_BED
-      BedTargetItem = EDIT_ITEM(ICON_SetBedTemp, GET_TEXT_F(MSG_UBL_SET_TEMP_BED), onDrawBedTemp, SetBedTemp, &thermalManager.temp_bed.target);
+      BedTargetItem = EDIT_ITEM_F(ICON_SetBedTemp, MSG_UBL_SET_TEMP_BED, onDrawBedTemp, SetBedTemp, &thermalManager.temp_bed.target);
     #endif
     #if HAS_FAN
-      FanSpeedItem = EDIT_ITEM(ICON_FanSpeed, GET_TEXT_F(MSG_FAN_SPEED), onDrawFanSpeed, SetFanSpeed, &thermalManager.fan_speed[0]);
+      FanSpeedItem = EDIT_ITEM_F(ICON_FanSpeed, MSG_FAN_SPEED, onDrawFanSpeed, SetFanSpeed, &thermalManager.fan_speed[0]);
     #endif
-    #if HAS_HOTEND
-      MENU_ITEM(ICON_SetPLAPreheat, F(PREHEAT_1_LABEL " Preheat Settings"), onDrawPLAPreheatSubMenu, Draw_Preheat1_Menu);
-      MENU_ITEM(ICON_SetABSPreheat, F(PREHEAT_2_LABEL " Preheat Settings"), onDrawABSPreheatSubMenu, Draw_Preheat2_Menu);
-      #ifdef PREHEAT_3_LABEL
-        MENU_ITEM(ICON_SetCustomPreheat, PREHEAT_3_TITLE, onDrawSubMenu, Draw_Preheat3_Menu);
+    #if HAS_PREHEAT
+      MENU_ITEM_F(ICON_SetPLAPreheat, MSG_PREHEAT_1_SETTINGS, onDrawPLAPreheatSubMenu, Draw_Preheat1_Menu);
+      #if PREHEAT_COUNT >= 2
+        MENU_ITEM_F(ICON_SetABSPreheat, MSG_PREHEAT_2_SETTINGS, onDrawABSPreheatSubMenu, Draw_Preheat2_Menu);
+        #if PREHEAT_COUNT >= 3
+          MENU_ITEM_F(ICON_SetCustomPreheat, MSG_PREHEAT_3_SETTINGS, onDrawSubMenu, Draw_Preheat3_Menu);
+        #endif
       #endif
     #endif
   }
   CurrentMenu->draw();
 }
 
 void Draw_MaxSpeed_Menu() {
   checkkey = Menu;
   if (!MaxSpeedMenu) MaxSpeedMenu = new MenuClass();
   if (CurrentMenu != MaxSpeedMenu) {
     CurrentMenu = MaxSpeedMenu;
     SetMenuTitle({1, 16, 28, 13}, GET_TEXT_F(MSG_MAXSPEED));
-    DWINUI::MenuItemsPrepare(5);
-    MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_Motion_Menu);
-    EDIT_ITEM(ICON_MaxSpeedX, GET_TEXT_F(MSG_MAXSPEED_X), onDrawMaxSpeedX, SetMaxSpeedX, &planner.settings.max_feedrate_mm_s[X_AXIS]);
-    EDIT_ITEM(ICON_MaxSpeedY, GET_TEXT_F(MSG_MAXSPEED_Y), onDrawMaxSpeedY, SetMaxSpeedY, &planner.settings.max_feedrate_mm_s[Y_AXIS]);
-    EDIT_ITEM(ICON_MaxSpeedZ, GET_TEXT_F(MSG_MAXSPEED_Z), onDrawMaxSpeedZ, SetMaxSpeedZ, &planner.settings.max_feedrate_mm_s[Z_AXIS]);
+    MenuItemsPrepare(5);
+    BACK_ITEM(Draw_Motion_Menu);
+    EDIT_ITEM_F(ICON_MaxSpeedX, MSG_MAXSPEED_X, onDrawMaxSpeedX, SetMaxSpeedX, &planner.settings.max_feedrate_mm_s[X_AXIS]);
+    EDIT_ITEM_F(ICON_MaxSpeedY, MSG_MAXSPEED_Y, onDrawMaxSpeedY, SetMaxSpeedY, &planner.settings.max_feedrate_mm_s[Y_AXIS]);
+    EDIT_ITEM_F(ICON_MaxSpeedZ, MSG_MAXSPEED_Z, onDrawMaxSpeedZ, SetMaxSpeedZ, &planner.settings.max_feedrate_mm_s[Z_AXIS]);
     #if HAS_HOTEND
-      EDIT_ITEM(ICON_MaxSpeedE, GET_TEXT_F(MSG_MAXSPEED_E), onDrawMaxSpeedE, SetMaxSpeedE, &planner.settings.max_feedrate_mm_s[E_AXIS]);
+      EDIT_ITEM_F(ICON_MaxSpeedE, MSG_MAXSPEED_E, onDrawMaxSpeedE, SetMaxSpeedE, &planner.settings.max_feedrate_mm_s[E_AXIS]);
     #endif
   }
   CurrentMenu->draw();
 }
 
 void Draw_MaxAccel_Menu() {
   checkkey = Menu;
   if (!MaxAccelMenu) MaxAccelMenu = new MenuClass();
   if (CurrentMenu != MaxAccelMenu) {
     CurrentMenu = MaxAccelMenu;
     SetMenuTitle({1, 16, 28, 13}, GET_TEXT_F(MSG_ACCELERATION));
-    DWINUI::MenuItemsPrepare(5);
-    MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_Motion_Menu);
-    EDIT_ITEM(ICON_MaxAccX, GET_TEXT_F(MSG_AMAX_A), onDrawMaxAccelX, SetMaxAccelX, &planner.settings.max_acceleration_mm_per_s2[X_AXIS]);
-    EDIT_ITEM(ICON_MaxAccY, GET_TEXT_F(MSG_AMAX_B), onDrawMaxAccelY, SetMaxAccelY, &planner.settings.max_acceleration_mm_per_s2[Y_AXIS]);
-    EDIT_ITEM(ICON_MaxAccZ, GET_TEXT_F(MSG_AMAX_C), onDrawMaxAccelZ, SetMaxAccelZ, &planner.settings.max_acceleration_mm_per_s2[Z_AXIS]);
+    MenuItemsPrepare(5);
+    BACK_ITEM(Draw_Motion_Menu);
+    EDIT_ITEM_F(ICON_MaxAccX, MSG_AMAX_A, onDrawMaxAccelX, SetMaxAccelX, &planner.settings.max_acceleration_mm_per_s2[X_AXIS]);
+    EDIT_ITEM_F(ICON_MaxAccY, MSG_AMAX_B, onDrawMaxAccelY, SetMaxAccelY, &planner.settings.max_acceleration_mm_per_s2[Y_AXIS]);
+    EDIT_ITEM_F(ICON_MaxAccZ, MSG_AMAX_C, onDrawMaxAccelZ, SetMaxAccelZ, &planner.settings.max_acceleration_mm_per_s2[Z_AXIS]);
     #if HAS_HOTEND
-      EDIT_ITEM(ICON_MaxAccE, GET_TEXT_F(MSG_AMAX_E), onDrawMaxAccelE, SetMaxAccelE, &planner.settings.max_acceleration_mm_per_s2[E_AXIS]);
+      EDIT_ITEM_F(ICON_MaxAccE, MSG_AMAX_E, onDrawMaxAccelE, SetMaxAccelE, &planner.settings.max_acceleration_mm_per_s2[E_AXIS]);
     #endif
   }
   CurrentMenu->draw();
 }
 
 #if HAS_CLASSIC_JERK
   void Draw_MaxJerk_Menu() {
     checkkey = Menu;
     if (!MaxJerkMenu) MaxJerkMenu = new MenuClass();
     if (CurrentMenu != MaxJerkMenu) {
       CurrentMenu = MaxJerkMenu;
       SetMenuTitle({1, 16, 28, 13}, GET_TEXT_F(MSG_JERK));
-      DWINUI::MenuItemsPrepare(5);
-      MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_Motion_Menu);
-      EDIT_ITEM(ICON_MaxSpeedJerkX, GET_TEXT_F(MSG_VA_JERK), onDrawMaxJerkX, SetMaxJerkX, &planner.max_jerk[X_AXIS]);
-      EDIT_ITEM(ICON_MaxSpeedJerkY, GET_TEXT_F(MSG_VB_JERK), onDrawMaxJerkY, SetMaxJerkY, &planner.max_jerk[Y_AXIS]);
-      EDIT_ITEM(ICON_MaxSpeedJerkZ, GET_TEXT_F(MSG_VC_JERK), onDrawMaxJerkZ, SetMaxJerkZ, &planner.max_jerk[Z_AXIS]);
+      MenuItemsPrepare(5);
+      BACK_ITEM(Draw_Motion_Menu);
+      EDIT_ITEM_F(ICON_MaxSpeedJerkX, MSG_VA_JERK, onDrawMaxJerkX, SetMaxJerkX, &planner.max_jerk[X_AXIS]);
+      EDIT_ITEM_F(ICON_MaxSpeedJerkY, MSG_VB_JERK, onDrawMaxJerkY, SetMaxJerkY, &planner.max_jerk[Y_AXIS]);
+      EDIT_ITEM_F(ICON_MaxSpeedJerkZ, MSG_VC_JERK, onDrawMaxJerkZ, SetMaxJerkZ, &planner.max_jerk[Z_AXIS]);
       #if HAS_HOTEND
-        EDIT_ITEM(ICON_MaxSpeedJerkE, GET_TEXT_F(MSG_VE_JERK), onDrawMaxJerkE, SetMaxJerkE, &planner.max_jerk[E_AXIS]);
+        EDIT_ITEM_F(ICON_MaxSpeedJerkE, MSG_VE_JERK, onDrawMaxJerkE, SetMaxJerkE, &planner.max_jerk[E_AXIS]);
       #endif
     }
     CurrentMenu->draw();
   }
 #endif
 
 void Draw_Steps_Menu() {
   checkkey = Menu;
   if (!StepsMenu) StepsMenu = new MenuClass();
   if (CurrentMenu != StepsMenu) {
     CurrentMenu = StepsMenu;
     SetMenuTitle({1, 16, 28, 13}, GET_TEXT_F(MSG_STEPS_PER_MM));
-    DWINUI::MenuItemsPrepare(5);
-    MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_Motion_Menu);
-    EDIT_ITEM(ICON_StepX, GET_TEXT_F(MSG_A_STEPS), onDrawStepsX, SetStepsX, &planner.settings.axis_steps_per_mm[X_AXIS]);
-    EDIT_ITEM(ICON_StepY, GET_TEXT_F(MSG_B_STEPS), onDrawStepsY, SetStepsY, &planner.settings.axis_steps_per_mm[Y_AXIS]);
-    EDIT_ITEM(ICON_StepZ, GET_TEXT_F(MSG_C_STEPS), onDrawStepsZ, SetStepsZ, &planner.settings.axis_steps_per_mm[Z_AXIS]);
+    MenuItemsPrepare(5);
+    BACK_ITEM(Draw_Motion_Menu);
+    EDIT_ITEM_F(ICON_StepX, MSG_A_STEPS, onDrawStepsX, SetStepsX, &planner.settings.axis_steps_per_mm[X_AXIS]);
+    EDIT_ITEM_F(ICON_StepY, MSG_B_STEPS, onDrawStepsY, SetStepsY, &planner.settings.axis_steps_per_mm[Y_AXIS]);
+    EDIT_ITEM_F(ICON_StepZ, MSG_C_STEPS, onDrawStepsZ, SetStepsZ, &planner.settings.axis_steps_per_mm[Z_AXIS]);
     #if HAS_HOTEND
-      EDIT_ITEM(ICON_StepE, GET_TEXT_F(MSG_E_STEPS), onDrawStepsE, SetStepsE, &planner.settings.axis_steps_per_mm[E_AXIS]);
+      EDIT_ITEM_F(ICON_StepE, MSG_E_STEPS, onDrawStepsE, SetStepsE, &planner.settings.axis_steps_per_mm[E_AXIS]);
     #endif
   }
   CurrentMenu->draw();
 }
 
 #if HAS_HOTEND
   void Draw_HotendPID_Menu() {
     checkkey = Menu;
-    if (!HotendPIDMenu) HotendPIDMenu = new MenuClass();
-    if (CurrentMenu != HotendPIDMenu) {
-      CurrentMenu = HotendPIDMenu;
-      CurrentMenu->MenuTitle.SetCaption(F("Hotend PID Settings"));
-      DWINUI::MenuItemsPrepare(8);
-      MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawMenuItem, Draw_AdvancedSettings_Menu);
-      MENU_ITEM(ICON_PIDNozzle, F("Hotend PID"), onDrawMenuItem, HotendPID);
+    if (SetMenu(HotendPIDMenu, F(STR_HOTEND_PID " Settings"),8)) {
+      BACK_ITEM(Draw_AdvancedSettings_Menu);
+      MENU_ITEM(ICON_PIDNozzle, F(STR_HOTEND_PID), onDrawMenuItem, HotendPID);
       EDIT_ITEM(ICON_PIDValue, F("Set" STR_KP), onDrawPFloat2Menu, SetKp, &thermalManager.temp_hotend[0].pid.Kp);
       EDIT_ITEM(ICON_PIDValue, F("Set" STR_KI), onDrawPIDi, SetKi, &thermalManager.temp_hotend[0].pid.Ki);
       EDIT_ITEM(ICON_PIDValue, F("Set" STR_KD), onDrawPIDd, SetKd, &thermalManager.temp_hotend[0].pid.Kd);
-      EDIT_ITEM(ICON_Temperature, GET_TEXT_F(MSG_TEMPERATURE), onDrawPIntMenu, SetHotendPidT, &HMI_data.HotendPidT);
-      EDIT_ITEM(ICON_PIDcycles, GET_TEXT_F(MSG_PID_CYCLE), onDrawPIntMenu, SetPidCycles, &HMI_data.PidCycles);
+      EDIT_ITEM_F(ICON_Temperature, MSG_TEMPERATURE, onDrawPIntMenu, SetHotendPidT, &HMI_data.HotendPidT);
+      EDIT_ITEM_F(ICON_PIDcycles, MSG_PID_CYCLE, onDrawPIntMenu, SetPidCycles, &HMI_data.PidCycles);
       #if ENABLED(EEPROM_SETTINGS)
-        MENU_ITEM(ICON_WriteEEPROM, GET_TEXT_F(MSG_STORE_EEPROM), onDrawMenuItem, WriteEeprom);
+        MENU_ITEM_F(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawMenuItem, WriteEeprom);
       #endif
     }
-    CurrentMenu->draw();
+    UpdateMenu(HotendPIDMenu);
   }
 #endif
 
 #if HAS_HEATED_BED
   void Draw_BedPID_Menu() {
     checkkey = Menu;
-    if (!BedPIDMenu) BedPIDMenu = new MenuClass();
-    if (CurrentMenu != BedPIDMenu) {
-      CurrentMenu = BedPIDMenu;
-      CurrentMenu->MenuTitle.SetCaption(F("Bed PID Settings"));
-      DWINUI::MenuItemsPrepare(8);
-      MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawMenuItem, Draw_AdvancedSettings_Menu);
-      MENU_ITEM(ICON_PIDNozzle, F("Bed PID"), onDrawMenuItem,BedPID);
+    if (SetMenu(BedPIDMenu, F(STR_BED_PID " Settings"),8)) {
+      BACK_ITEM(Draw_AdvancedSettings_Menu);
+      MENU_ITEM(ICON_PIDNozzle, F(STR_BED_PID), onDrawMenuItem,BedPID);
       EDIT_ITEM(ICON_PIDValue, F("Set" STR_KP), onDrawPFloat2Menu, SetKp, &thermalManager.temp_bed.pid.Kp);
       EDIT_ITEM(ICON_PIDValue, F("Set" STR_KI), onDrawPIDi, SetKi, &thermalManager.temp_bed.pid.Ki);
       EDIT_ITEM(ICON_PIDValue, F("Set" STR_KD), onDrawPIDd, SetKd, &thermalManager.temp_bed.pid.Kd);
-      EDIT_ITEM(ICON_Temperature, GET_TEXT_F(MSG_TEMPERATURE), onDrawPIntMenu, SetBedPidT, &HMI_data.BedPidT);
-      EDIT_ITEM(ICON_PIDcycles, GET_TEXT_F(MSG_PID_CYCLE), onDrawPIntMenu, SetPidCycles, &HMI_data.PidCycles);
+      EDIT_ITEM_F(ICON_Temperature, MSG_TEMPERATURE, onDrawPIntMenu, SetBedPidT, &HMI_data.BedPidT);
+      EDIT_ITEM_F(ICON_PIDcycles, MSG_PID_CYCLE, onDrawPIntMenu, SetPidCycles, &HMI_data.PidCycles);
       #if ENABLED(EEPROM_SETTINGS)
-        MENU_ITEM(ICON_WriteEEPROM, GET_TEXT_F(MSG_STORE_EEPROM), onDrawMenuItem, WriteEeprom);
+        MENU_ITEM_F(ICON_WriteEEPROM, MSG_STORE_EEPROM, onDrawMenuItem, WriteEeprom);
       #endif
     }
-    CurrentMenu->draw();
+    UpdateMenu(BedPIDMenu);
   }
 #endif
 
-#if HAS_BED_PROBE
+#if ENABLED(BABYSTEP_ZPROBE_OFFSET)
   void Draw_ZOffsetWiz_Menu() {
     checkkey = Menu;
-    if (!ZOffsetWizMenu) ZOffsetWizMenu = new MenuClass();
-    if (CurrentMenu != ZOffsetWizMenu) {
-      CurrentMenu = ZOffsetWizMenu;
-      CurrentMenu->MenuTitle.SetCaption(GET_TEXT_F(MSG_PROBE_WIZARD));
-      DWINUI::MenuItemsPrepare(4);
-      MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawMenuItem, Draw_Prepare_Menu);
-      MENU_ITEM(ICON_Homing, GET_TEXT_F(MSG_AUTO_HOME), onDrawMenuItem, AutoHome);
+    if (SetMenu(ZOffsetWizMenu, GET_TEXT_F(MSG_PROBE_WIZARD), 4)) {
+      BACK_ITEM(Draw_Prepare_Menu);
+      MENU_ITEM_F(ICON_Homing, MSG_AUTO_HOME, onDrawMenuItem, AutoHome);
       MENU_ITEM(ICON_MoveZ0, F("Move Z to Home"), onDrawMenuItem, SetMoveZto0);
-      EDIT_ITEM(ICON_Zoffset, GET_TEXT_F(MSG_ZPROBE_ZOFFSET), onDrawPFloat2Menu, SetZOffset, &BABY_Z_VAR);
+      EDIT_ITEM_F(ICON_Zoffset, MSG_ZPROBE_ZOFFSET, onDrawPFloat2Menu, SetZOffset, &BABY_Z_VAR);
     }
-    CurrentMenu->draw();
+    UpdateMenu(ZOffsetWizMenu);
     if (!axis_is_trusted(Z_AXIS)) LCD_MESSAGE_F("WARNING: Z position unknown, move Z to home");
   }
 #endif
 
 #if ENABLED(INDIVIDUAL_AXIS_HOMING_SUBMENU)
   void Draw_Homing_Menu() {
     checkkey = Menu;
-    if (!HomingMenu) HomingMenu = new MenuClass();
-    if (CurrentMenu != HomingMenu) {
-      CurrentMenu = HomingMenu;
-      CurrentMenu->MenuTitle.SetCaption(GET_TEXT_F(MSG_HOMING));
-      DWINUI::MenuItemsPrepare(5);
-      MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawMenuItem, Draw_Prepare_Menu);
-      MENU_ITEM(ICON_Homing, GET_TEXT_F(MSG_AUTO_HOME), onDrawMenuItem, AutoHome);
-      MENU_ITEM(ICON_HomeX, GET_TEXT_F(MSG_AUTO_HOME_X), onDrawMenuItem, HomeX);
-      MENU_ITEM(ICON_HomeY, GET_TEXT_F(MSG_AUTO_HOME_Y), onDrawMenuItem, HomeY);
-      MENU_ITEM(ICON_HomeZ, GET_TEXT_F(MSG_AUTO_HOME_Z), onDrawMenuItem, HomeZ);
+    if (SetMenu(HomingMenu, GET_TEXT_F(MSG_HOMING), 5)) {
+      BACK_ITEM(Draw_Prepare_Menu);
+      MENU_ITEM_F(ICON_Homing, MSG_AUTO_HOME, onDrawMenuItem, AutoHome);
+      MENU_ITEM_F(ICON_HomeX, MSG_AUTO_HOME_X, onDrawMenuItem, HomeX);
+      MENU_ITEM_F(ICON_HomeY, MSG_AUTO_HOME_Y, onDrawMenuItem, HomeY);
+      MENU_ITEM_F(ICON_HomeZ, MSG_AUTO_HOME_Z, onDrawMenuItem, HomeZ);
     }
-    CurrentMenu->draw();
+    UpdateMenu(HomingMenu);
+  }
+#endif
+
+#if ENABLED(FWRETRACT)
+  void Draw_FWRetract_Menu() {
+    checkkey = Menu;
+    if (SetMenu(FWRetractMenu, GET_TEXT_F(MSG_FWRETRACT), 6)) {
+      BACK_ITEM(Return_FWRetract_Menu);
+      EDIT_ITEM_F(ICON_FWRetLength, MSG_CONTROL_RETRACT, onDrawPFloatMenu, SetRetractLength, &fwretract.settings.retract_length);
+      EDIT_ITEM_F(ICON_FWRetSpeed, MSG_SINGLENOZZLE_RETRACT_SPEED, onDrawPFloatMenu, SetRetractSpeed, &fwretract.settings.retract_feedrate_mm_s);
+      EDIT_ITEM_F(ICON_FWRetZRaise, MSG_CONTROL_RETRACT_ZHOP, onDrawPFloat2Menu, SetZRaise, &fwretract.settings.retract_zraise);
+      EDIT_ITEM_F(ICON_FWRecSpeed, MSG_SINGLENOZZLE_UNRETRACT_SPEED, onDrawPFloatMenu, SetRecoverSpeed, &fwretract.settings.retract_recover_feedrate_mm_s);
+      EDIT_ITEM_F(ICON_FWRecExtra, MSG_CONTROL_RETRACT_RECOVER, onDrawPFloatMenu, SetAddRecover, &fwretract.settings.retract_recover_extra);
+    }
+    UpdateMenu(FWRetractMenu);
+  }
+#endif
+
+//=============================================================================
+// Mesh Bed Leveling
+//=============================================================================
+
+#if HAS_MESH
+
+  void ApplyMeshFadeHeight() { set_z_fade_height(planner.z_fade_height); }
+  void SetMeshFadeHeight() { SetPFloatOnClick(0, 100, 1, ApplyMeshFadeHeight); }
+
+  void SetMeshActive() {
+    set_bed_leveling_enabled(!planner.leveling_active);
+    Draw_Chkb_Line(CurrentMenu->line(), planner.leveling_active);
+    DWIN_UpdateLCD();
   }
+
+  #if BOTH(HAS_HEATED_BED, PREHEAT_BEFORE_LEVELING)
+    void SetBedLevT() { SetPIntOnClick(MIN_BEDTEMP, MAX_BEDTEMP); }
+  #endif
+
+  uint8_t mesh_x = 0;
+  uint8_t mesh_y = 0;
+  #define Z_OFFSET_MIN -3
+  #define Z_OFFSET_MAX  3
+
+  void LiveEditMesh() { ((MenuItemPtrClass*)EditZValueItem)->value = &Z_VALUES_ARR[HMI_value.Select ? mesh_x : MenuData.Value][HMI_value.Select ? MenuData.Value : mesh_y]; EditZValueItem->redraw(); }
+  void ApplyEditMeshX() { mesh_x = MenuData.Value; }
+  void SetEditMeshX() { HMI_value.Select = 0; SetIntOnClick(0, GRID_MAX_POINTS_X - 1, mesh_x, ApplyEditMeshX, LiveEditMesh); }
+  void ApplyEditMeshY() { mesh_y = MenuData.Value; }
+  void SetEditMeshY() { HMI_value.Select = 1; SetIntOnClick(0, GRID_MAX_POINTS_Y - 1, mesh_y, ApplyEditMeshY, LiveEditMesh); }
+  void SetEditZValue() { SetPFloatOnClick(Z_OFFSET_MIN, Z_OFFSET_MAX, 3); }
+
 #endif
 
+#if ENABLED(AUTO_BED_LEVELING_UBL)
+
+  void ApplyUBLSlot() { ubl.storage_slot = MenuData.Value; }
+  void SetUBLSlot() { SetIntOnClick(0, settings.calc_num_meshes() - 1, ubl.storage_slot, ApplyUBLSlot); }
+  void onDrawUBLSlot(MenuItemClass* menuitem, int8_t line) {
+    if (ubl.storage_slot < 0) ubl.storage_slot = 0;
+    onDrawIntMenu(menuitem, line, ubl.storage_slot);
+  }
+
+  void ApplyUBLTiltGrid() { ubl_tools.tilt_grid = MenuData.Value; }
+  void SetUBLTiltGrid() { SetIntOnClick(1, 3, ubl_tools.tilt_grid, ApplyUBLTiltGrid); }
+
+  void UBLTiltMesh() {
+    if (ubl.storage_slot < 0) ubl.storage_slot = 0;
+    char buf[15];
+    if (ubl_tools.tilt_grid > 1) {
+      sprintf_P(buf, PSTR("G28O\nG29 J%i"), ubl_tools.tilt_grid);
+      gcode.process_subcommands_now(buf);
+    }
+    else
+      gcode.process_subcommands_now(F("G28O\nG29J"));
+    LCD_MESSAGE(MSG_UBL_MESH_TILTED);
+  }
+
+  void UBLSmartFillMesh() {
+    ubl.smart_fill_mesh();
+    LCD_MESSAGE(MSG_UBL_MESH_FILLED);
+  }
+
+  bool UBLValidMesh() {
+    const bool valid = ubl_tools.validate();
+    if (!valid) ubl.invalidate();
+    return valid;
+  }
+
+  void UBLSaveMesh() {
+    if (ubl.storage_slot < 0) ubl.storage_slot = 0;
+    settings.store_mesh(ubl.storage_slot);
+    ui.status_printf(0, GET_TEXT_F(MSG_MESH_SAVED), ubl.storage_slot);
+    DONE_BUZZ(true);
+  }
+
+  void UBLLoadMesh() {
+    if (ubl.storage_slot < 0) ubl.storage_slot = 0;
+    settings.load_mesh(ubl.storage_slot);
+    if (UBLValidMesh()) {
+      ui.status_printf(0, GET_TEXT_F(MSG_MESH_LOADED), ubl.storage_slot);
+      DONE_BUZZ(true);
+    }
+    else {
+      LCD_MESSAGE_F("Invalid Mesh Loaded");
+      DONE_BUZZ(false);
+    }
+  }
+
+#endif // AUTO_BED_LEVELING_UBL
+
+#if HAS_MESH
+  void Draw_MeshSet_Menu() {
+    checkkey = Menu;
+    if (SetMenu(MeshMenu, GET_TEXT_F(MSG_MESH_LEVELING), 15)) {
+      BACK_ITEM(Draw_AdvancedSettings_Menu);
+      #if BOTH(HAS_HEATED_BED, PREHEAT_BEFORE_LEVELING)
+        EDIT_ITEM_F(ICON_Temperature, MSG_UBL_SET_TEMP_BED, onDrawPIntMenu, SetBedLevT, &HMI_data.BedLevT);
+      #endif
+      EDIT_ITEM_F(ICON_SetZOffset, MSG_Z_FADE_HEIGHT, onDrawPFloatMenu, SetMeshFadeHeight, &planner.z_fade_height);
+      EDIT_ITEM_F(ICON_UBLActive, MSG_ACTIVATE_MESH, onDrawChkbMenu, SetMeshActive, &planner.leveling_active);
+      #if HAS_BED_PROBE
+        MENU_ITEM_F(ICON_Level, MSG_AUTO_MESH, onDrawMenuItem, AutoLev);
+      #endif
+      #if ENABLED(AUTO_BED_LEVELING_UBL)
+        EDIT_ITEM_F(ICON_UBLActive, MSG_UBL_STORAGE_SLOT, onDrawUBLSlot, SetUBLSlot, &ubl.storage_slot);
+        MENU_ITEM_F(ICON_UBLActive, MSG_UBL_SAVE_MESH, onDrawMenuItem, UBLSaveMesh);
+        MENU_ITEM_F(ICON_UBLActive, MSG_UBL_LOAD_MESH, onDrawMenuItem, UBLLoadMesh);
+        EDIT_ITEM_F(ICON_UBLActive, MSG_UBL_TILTING_GRID, onDrawPInt8Menu, SetUBLTiltGrid, &ubl_tools.tilt_grid);
+        MENU_ITEM_F(ICON_UBLActive, MSG_UBL_TILT_MESH, onDrawMenuItem, UBLTiltMesh);
+        MENU_ITEM_F(ICON_UBLActive, MSG_UBL_SMART_FILLIN, onDrawMenuItem, UBLSmartFillMesh);
+      #endif
+      #if ENABLED(MESH_EDIT_MENU)
+        MENU_ITEM_F(ICON_UBLActive, MSG_EDIT_MESH, onDrawSubMenu, Draw_EditMesh_Menu);
+      #endif
+      MENU_ITEM_F(ICON_MeshViewer, MSG_MESH_VIEW, onDrawSubMenu, DWIN_MeshViewer);
+    }
+    UpdateMenu(MeshMenu);
+  }
+
+  #if ENABLED(MESH_EDIT_MENU)
+    void Draw_EditMesh_Menu() {
+      checkkey = Menu;
+      if (SetMenu(EditMeshMenu, GET_TEXT_F(MSG_EDIT_MESH), 4)) {
+        mesh_x = mesh_y = 0;
+        BACK_ITEM(Draw_MeshSet_Menu);
+        EDIT_ITEM_F(ICON_UBLActive, MSG_MESH_X, onDrawPInt8Menu, SetEditMeshX, &mesh_x);
+        EDIT_ITEM_F(ICON_UBLActive, MSG_MESH_Y, onDrawPInt8Menu, SetEditMeshY, &mesh_y);
+        EditZValueItem = EDIT_ITEM_F(ICON_UBLActive, MSG_MESH_EDIT_Z, onDrawPFloat3Menu, SetEditZValue, &Z_VALUES_ARR[mesh_x][mesh_y]);
+      }
+      UpdateMenu(EditMeshMenu);
+    }
+  #endif
+
+#endif // HAS_MESH
+
 #endif // DWIN_LCD_PROUI

commit 310ff2367690a9b3c40cec756f193add76900fe3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 17 15:05:25 2022 -0500

    üé® Misc. E3V2 DWIN cleanup

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 7d87725b81..68099f2076 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -1936,21 +1936,21 @@ void DisableMotors() { queue.inject(F("M84")); }
 
 void AutoLev() { queue.inject(F("G28XYO\nG28Z\nG29")); }  // Force to get the current Z home position
 
 void AutoHome() { queue.inject_P(G28_STR); }
 void HomeX() { queue.inject(F("G28X")); }
 void HomeY() { queue.inject(F("G28Y")); }
 void HomeZ() { queue.inject(F("G28Z")); }
 
 void SetHome() {
   // Apply workspace offset, making the current position 0,0,0
-  queue.inject(F("G92 X0 Y0 Z0"));
+  queue.inject(F("G92X0Y0Z0"));
   HMI_AudioFeedback();
 }
 
 #if HAS_ZOFFSET_ITEM
 
   void ApplyZOffset() { TERN_(EEPROM_SETTINGS, settings.save()); }
   void LiveZOffset() {
     last_zoffset = dwin_zoffset;
     dwin_zoffset = MenuData.Value / 100.0f;
     #if EITHER(BABYSTEP_ZPROBE_OFFSET, JUST_BABYSTEP)

commit b934a4c612a09cfd577e3811df01e8a2fdbb81dd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu May 12 23:40:56 2022 -0500

    ü©π Fix printer_busy, M73
    
    Followup to "Misc. LCD cleanup"

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 68d4010ef6..7d87725b81 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -1645,22 +1645,22 @@ void DWIN_Print_Finished() {
 void DWIN_Print_Aborted() {
   TERN_(DEBUG_DWIN, SERIAL_ECHOLNPGM("DWIN_Print_Aborted"));
   HMI_flag.abort_action = false;
   wait_for_heatup = false;
   planner.finish_and_disable();
   thermalManager.cooldown();
   Goto_PrintDone();
 }
 
 // Progress Bar update
-  if (parser.seenval('P')) _percent_done = parser.byteval('P');
 void DWIN_M73() {
+  if (parser.seenval('P')) _percent_done = parser.byteval('P');
   if (parser.seenval('R')) {
     _remain_time = parser.ulongval('R') * 60;
     HMI_flag.remain_flag = true;
   }
   if (checkkey == PrintProcess) {
     Draw_Print_ProgressBar();
     Draw_Print_ProgressRemain();
     Draw_Print_ProgressElapsed();
   }
 }

commit 1e749e4f48f528179213e736c99371843a90b4fb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu May 12 20:13:59 2022 -0500

    üßë‚Äçüíª Misc. LCD cleanup

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 1933c82d36..68d4010ef6 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -425,58 +425,58 @@ void Draw_Back_First(const bool is_sel=true) {
   if (HMI_IsChinese())
     DWIN_Frame_AreaCopy(1, 129, 72, 156, 84, LBLX, MBASE(0));
   else
     DWINUI::Draw_String(LBLX, MBASE(0), GET_TEXT_F(MSG_BACK));
   if (is_sel) Draw_Menu_Cursor(0);
 }
 
 //PopUps
 void Popup_window_PauseOrStop() {
   if (HMI_IsChinese()) {
-    DWINUI::ClearMenuArea();
+    DWINUI::ClearMainArea();
     Draw_Popup_Bkgd();
          if (select_print.now == PRINT_PAUSE_RESUME) DWIN_Frame_AreaCopy(1, 237, 338, 269, 356, 98, 150);
     else if (select_print.now == PRINT_STOP) DWIN_Frame_AreaCopy(1, 221, 320, 253, 336, 98, 150);
     DWIN_Frame_AreaCopy(1, 220, 304, 264, 319, 130, 150);
     DWINUI::Draw_IconWB(ICON_Confirm_C, 26, 280);
     DWINUI::Draw_IconWB(ICON_Cancel_C, 146, 280);
     Draw_Select_Highlight(true);
     DWIN_UpdateLCD();
   }
   else
     DWIN_Popup_ConfirmCancel(ICON_BLTouch, select_print.now == PRINT_PAUSE_RESUME ? GET_TEXT_F(MSG_PAUSE_PRINT) : GET_TEXT_F(MSG_STOP_PRINT));
 }
 
 #if HAS_HOTEND
 
   void Popup_Window_ETempTooLow() {
     if (HMI_IsChinese()) {
       HMI_SaveProcessID(WaitResponse);
-      DWINUI::ClearMenuArea();
+      DWINUI::ClearMainArea();
       Draw_Popup_Bkgd();
       DWINUI::Draw_Icon(ICON_TempTooLow, 102, 105);
       DWIN_Frame_AreaCopy(1, 103, 371, 136, 386,  69, 240);
       DWIN_Frame_AreaCopy(1, 170, 371, 270, 386, 102, 240);
       DWINUI::Draw_IconWB(ICON_Confirm_C, 86, 280);
       DWIN_UpdateLCD();
     }
     else
       DWIN_Popup_Confirm(ICON_TempTooLow, GET_TEXT_F(MSG_HOTEND_TOO_COLD), GET_TEXT_F(MSG_PLEASE_PREHEAT));
   }
 
 #endif
 
 #if HAS_HOTEND || HAS_HEATED_BED
   void DWIN_Popup_Temperature(const bool toohigh) {
     HMI_SaveProcessID(WaitResponse);
     if (HMI_IsChinese()) {
-      DWINUI::ClearMenuArea();
+      DWINUI::ClearMainArea();
       Draw_Popup_Bkgd();
       if (toohigh) {
         DWINUI::Draw_Icon(ICON_TempTooHigh, 102, 165);
         DWIN_Frame_AreaCopy(1, 103, 371, 237, 386, 52, 285);
         DWIN_Frame_AreaCopy(1, 151, 389, 185, 402, 187, 285);
         DWIN_Frame_AreaCopy(1, 189, 389, 271, 402, 95, 310);
       }
       else {
         DWINUI::Draw_Icon(ICON_TempTooLow, 102, 165);
         DWIN_Frame_AreaCopy(1, 103, 371, 270, 386, 52, 285);
@@ -572,27 +572,27 @@ void Draw_Print_Labels() {
 void Draw_Print_ProgressBar() {
   DWIN_ICON_Show(true, false, false, ICON, ICON_Bar, 15, 93);
   DWIN_Draw_Rectangle(1, HMI_data.Barfill_Color, 16 + _percent_done * 240 / 100, 93, 256, 113);
   DWINUI::Draw_Int(HMI_data.PercentTxt_Color, HMI_data.Background_Color, 3, 117, 133, _percent_done);
   DWINUI::Draw_String(HMI_data.PercentTxt_Color, 142, 133, F("%"));
 }
 
 void Draw_Print_ProgressElapsed() {
   char buf[10];
   duration_t elapsed = print_job_timer.duration(); // print timer
-  sprintf_P(buf, PSTR("%02i:%02i"), (uint16_t)(elapsed.value / 3600), ((uint16_t)elapsed.value % 3600) / 60);
+  sprintf_P(buf, PSTR("%02i:%02i "), (uint16_t)(elapsed.value / 3600), ((uint16_t)elapsed.value % 3600) / 60);
   DWINUI::Draw_String(HMI_data.Text_Color, HMI_data.Background_Color, 47, 192, buf);
 }
 
 void Draw_Print_ProgressRemain() {
   char buf[10];
-  sprintf_P(buf, PSTR("%02i:%02i"), (uint16_t)(_remain_time / 3600), ((uint16_t)_remain_time % 3600) / 60);
+  sprintf_P(buf, PSTR("%02i:%02i "), (uint16_t)(_remain_time / 3600), ((uint16_t)_remain_time % 3600) / 60);
   DWINUI::Draw_String(HMI_data.Text_Color, HMI_data.Background_Color, 181, 192, buf);
 }
 
 void ICON_ResumeOrPause() {
   if (checkkey == PrintProcess) printingIsPaused() ? ICON_Resume() : ICON_Pause();
 }
 
 // Update filename on print
 void DWIN_Print_Header(const char *text = nullptr) {
   static char headertxt[31] = "";  // Print header text
@@ -605,21 +605,21 @@ void DWIN_Print_Header(const char *text = nullptr) {
     DWIN_Draw_Rectangle(1, HMI_data.Background_Color, 0, 60, DWIN_WIDTH, 60+16);
     DWINUI::Draw_CenteredString(60, headertxt);
   }
 }
 
 void Draw_PrintProcess() {
   if (HMI_IsChinese())
     Title.FrameCopy(30, 1, 42, 14);                     // "Printing"
   else
     Title.ShowCaption(GET_TEXT_F(MSG_PRINTING));
-  DWINUI::ClearMenuArea();
+  DWINUI::ClearMainArea();
   DWIN_Print_Header(sdprint ? card.longest_filename() : nullptr);
   Draw_Print_Labels();
   DWINUI::Draw_Icon(ICON_PrintTime, 15, 173);
   DWINUI::Draw_Icon(ICON_RemainTime, 150, 171);
   Draw_Print_ProgressBar();
   Draw_Print_ProgressElapsed();
   Draw_Print_ProgressRemain();
   ICON_Tune();
   ICON_ResumeOrPause();
   ICON_Stop();
@@ -634,21 +634,21 @@ void Goto_PrintProcess() {
   }
   DWIN_UpdateLCD();
 }
 
 void Draw_PrintDone() {
   // show percent bar and value
   _percent_done = 100;
   _remain_time = 0;
 
   Title.ShowCaption(GET_TEXT_F(MSG_PRINT_DONE));
-  DWINUI::ClearMenuArea();
+  DWINUI::ClearMainArea();
   DWIN_Print_Header(nullptr);
   Draw_Print_ProgressBar();
   Draw_Print_Labels();
   DWINUI::Draw_Icon(ICON_PrintTime, 15, 173);
   DWINUI::Draw_Icon(ICON_RemainTime, 150, 171);
   Draw_Print_ProgressElapsed();
   Draw_Print_ProgressRemain();
   // show print done confirm
   DWINUI::Draw_Button(BTN_Confirm, 86, 273);
 }
@@ -656,21 +656,21 @@ void Draw_PrintDone() {
 void Goto_PrintDone() {
   wait_for_user = true;
   if (checkkey != PrintDone) {
     checkkey = PrintDone;
     Draw_PrintDone();
     DWIN_UpdateLCD();
   }
 }
 
 void Draw_Main_Menu() {
-  DWINUI::ClearMenuArea();
+  DWINUI::ClearMainArea();
   if (HMI_IsChinese())
     Title.FrameCopy(2, 2, 26, 13);   // "Home" etc
   else
     Title.ShowCaption(MACHINE_NAME);
   DWINUI::Draw_Icon(ICON_LOGO, 71, 52);  // CREALITY logo
   DWIN_ResetStatusLine();
   ICON_Print();
   ICON_Prepare();
   ICON_Control();
   ICON_AdvSettings();
@@ -926,21 +926,21 @@ void Draw_SDItem(const uint16_t item, int16_t row=-1) {
     shift_name[lastchar] = c;
   }
 
 #endif
 
 // Redraw the first set of SD Files
 void Redraw_SD_List() {
   select_file.reset();
   index_file = MROWS;
 
-  DWINUI::ClearMenuArea(); // Leave title bar unchanged
+  DWINUI::ClearMainArea(); // Leave title bar unchanged
 
   Draw_Back_First();
 
   if (card.isMounted()) {
     // As many files as will fit
     LOOP_L_N(i, _MIN(nr_sd_menu_items(), MROWS))
       Draw_SDItem(i, i + 1);
 
     TERN_(SCROLL_LONG_FILENAMES, Init_SDItem_Shift());
   }
@@ -1034,21 +1034,21 @@ void DWIN_Draw_Dashboard() {
   DWIN_Draw_Rectangle(1, HMI_data.SplitLine_Color, 0, 449, DWIN_WIDTH, 451);
 
   DWINUI::Draw_Icon(ICON_MaxSpeedX,  10, 456);
   DWINUI::Draw_Icon(ICON_MaxSpeedY,  95, 456);
   DWINUI::Draw_Icon(ICON_MaxSpeedZ, 180, 456);
   _draw_xyz_position(true);
 
 }
 
 void Draw_Info_Menu() {
-  DWINUI::ClearMenuArea();
+  DWINUI::ClearMainArea();
   Draw_Back_First();
   if (HMI_IsChinese())
     Title.FrameCopy(30, 17, 28, 13);                        // "Info"
   else
     Title.ShowCaption(GET_TEXT_F(MSG_INFO_SCREEN));
 
   if (HMI_IsChinese()) {
     DWIN_Frame_AreaCopy(1, 197, 149, 252, 161, 108, 102);   // "Size"
     DWIN_Frame_AreaCopy(1,   1, 164,  56, 176, 108, 175);   // "Firmware Version"
     DWIN_Frame_AreaCopy(1,  58, 164, 113, 176, 105, 248);   // "Contact Details"
@@ -1100,21 +1100,21 @@ void HMI_MainMenu() {
         case PAGE_CONTROL: ICON_Control(); ICON_AdvSettings(); break;
         case PAGE_ADVANCE: ICON_AdvSettings(); break;
       }
     }
   }
   else if (encoder_diffState == ENCODER_DIFF_ENTER) {
     switch (select_page.now) {
       case PAGE_PRINT:
         checkkey = SelectFile;
         card.mount();
-        delay(300);
+        safe_delay(300);
         Draw_Print_File_Menu();
         break;
       case PAGE_PREPARE: Draw_Prepare_Menu(); break;
       case PAGE_CONTROL: Draw_Control_Menu(); break;
       case PAGE_ADVANCE: Draw_AdvancedSettings_Menu(); break;
     }
   }
   DWIN_UpdateLCD();
 }
 
@@ -1342,22 +1342,22 @@ void HMI_Init() {
     DWINUI::Draw_Icon(ICON_Bar, 15, 260);
     DWIN_Draw_Rectangle(1, HMI_data.Background_Color, 15 + t * 242 / 100, 260, 257, 280);
     DWIN_UpdateLCD();
     delay(20);
   }
   HMI_SetLanguage();
 }
 
 void EachMomentUpdate() {
   static millis_t next_var_update_ms = 0, next_rts_update_ms = 0, next_status_update_ms = 0;
-
   const millis_t ms = millis();
+
   if (ELAPSED(ms, next_var_update_ms)) {
     next_var_update_ms = ms + DWIN_VAR_UPDATE_INTERVAL;
     update_variable();
     switch (checkkey) {
       #if HAS_ESDIAG
         case ESDiagProcess:
           ESDiag.Update();
           break;
       #endif
       default:
@@ -1432,21 +1432,21 @@ void EachMomentUpdate() {
     else if (DWIN_lcd_sd_status && recovery.dwin_flag) { // resume print before power off
       return Goto_PowerLossRecovery();
     }
   #endif // POWER_LOSS_RECOVERY
 
   DWIN_UpdateLCD();
 }
 
 #if ENABLED(POWER_LOSS_RECOVERY)
   void Popup_PowerLossRecovery() {
-    DWINUI::ClearMenuArea();
+    DWINUI::ClearMainArea();
     Draw_Popup_Bkgd();
     if (HMI_IsChinese()) {
       DWIN_Frame_AreaCopy(1, 160, 338, 235, 354, 98, 115);
       DWIN_Frame_AreaCopy(1, 103, 321, 271, 335, 52, 167);
       DWINUI::Draw_IconWB(ICON_Cancel_C,    26, 280);
       DWINUI::Draw_IconWB(ICON_Continue_C, 146, 280);
     }
     else {
       DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 70, GET_TEXT_F(MSG_OUTAGE_RECOVERY));
       DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 147, F("It looks like the last"));
@@ -1471,21 +1471,21 @@ void EachMomentUpdate() {
     else {
       select_print.set(PRINT_SETUP);
       queue.inject(F("M1000"));
       sdprint = true;
       return Goto_PrintProcess();
     }
   }
 
   void Goto_PowerLossRecovery() {
     recovery.dwin_flag = false;
-    LCD_MESSAGE_F(GET_TEXT_F(MSG_CONTINUE_PRINT_JOB));
+    LCD_MESSAGE(MSG_CONTINUE_PRINT_JOB);
     Goto_Popup(Popup_PowerLossRecovery, onClick_PowerLossRecovery);
   }
 
 #endif // POWER_LOSS_RECOVERY
 
 
 void DWIN_HandleScreen() {
   switch (checkkey) {
     case MainMenu:        HMI_MainMenu(); break;
     case Menu:            HMI_Menu(); break;
@@ -1574,29 +1574,29 @@ void DWIN_PidTuning(pidresult_t result) {
     case PID_BED_START:
       HMI_SaveProcessID(NothingToDo);
       DWIN_Draw_Popup(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE), F("for BED is running."));
       break;
     case PID_EXTR_START:
       HMI_SaveProcessID(NothingToDo);
       DWIN_Draw_Popup(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE), F("for Nozzle is running."));
       break;
     case PID_BAD_EXTRUDER_NUM:
       checkkey = last_checkkey;
-      DWIN_Popup_Confirm(ICON_TempTooLow, F("PID Autotune failed!"), F("Bad extruder"));
+      DWIN_Popup_Confirm(ICON_TempTooLow, GET_TEXT_F(MSG_PID_AUTOTUNE_FAILED), GET_TEXT_F(MSG_BAD_EXTRUDER_NUM));
       break;
     case PID_TUNING_TIMEOUT:
       checkkey = last_checkkey;
-      DWIN_Popup_Confirm(ICON_TempTooHigh, F("Error"), GET_TEXT_F(MSG_PID_TIMEOUT));
+      DWIN_Popup_Confirm(ICON_TempTooHigh, GET_TEXT_F(MSG_ERROR), GET_TEXT_F(MSG_PID_TIMEOUT));
       break;
     case PID_TEMP_TOO_HIGH:
       checkkey = last_checkkey;
-      DWIN_Popup_Confirm(ICON_TempTooHigh, F("PID Autotune failed!"), F("Temperature too high"));
+      DWIN_Popup_Confirm(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE_FAILED), GET_TEXT_F(MSG_TEMP_TOO_HIGH));
       break;
     case PID_DONE:
       checkkey = last_checkkey;
       DWIN_Popup_Confirm(ICON_TempTooLow, GET_TEXT_F(MSG_PID_AUTOTUNE), GET_TEXT_F(MSG_BUTTON_DONE));
       break;
     default:
       checkkey = last_checkkey;
       break;
   }
 }
@@ -1630,37 +1630,37 @@ void DWIN_Print_Resume() {
   }
 }
 
 // Ended print job
 void DWIN_Print_Finished() {
   if (HMI_flag.abort_flag || checkkey == PrintDone) return;
   TERN_(POWER_LOSS_RECOVERY, if (card.isPrinting()) recovery.cancel());
   HMI_flag.pause_flag = false;
   wait_for_heatup = false;
   planner.finish_and_disable();
-    thermalManager.cooldown();
+  thermalManager.cooldown();
   Goto_PrintDone();
 }
 
 // Print was aborted
 void DWIN_Print_Aborted() {
   TERN_(DEBUG_DWIN, SERIAL_ECHOLNPGM("DWIN_Print_Aborted"));
   HMI_flag.abort_action = false;
   wait_for_heatup = false;
   planner.finish_and_disable();
   thermalManager.cooldown();
   Goto_PrintDone();
 }
 
 // Progress Bar update
-void DWIN_Progress_Update() {
   if (parser.seenval('P')) _percent_done = parser.byteval('P');
+void DWIN_M73() {
   if (parser.seenval('R')) {
     _remain_time = parser.ulongval('R') * 60;
     HMI_flag.remain_flag = true;
   }
   if (checkkey == PrintProcess) {
     Draw_Print_ProgressBar();
     Draw_Print_ProgressRemain();
     Draw_Print_ProgressElapsed();
   }
 }
@@ -1700,42 +1700,43 @@ void DWIN_SetDataDefaults() {
   #if ENABLED(PREVENT_COLD_EXTRUSION)
     HMI_data.ExtMinT = EXTRUDE_MINTEMP;
     ApplyExtMinT();
   #endif
   #if BOTH(HAS_HEATED_BED, PREHEAT_BEFORE_LEVELING)
     HMI_data.BedLevT = LEVELING_BED_TEMP;
   #endif
   TERN_(BAUD_RATE_GCODE, SetBaud250K());
 }
 
-void DWIN_StoreSettings(char *buff) {
+void DWIN_CopySettingsTo(char * const buff) {
   memcpy(buff, &HMI_data, _MIN(sizeof(HMI_data), eeprom_data_size));
 }
 
-void DWIN_LoadSettings(const char *buff) {
+void DWIN_CopySettingsFrom(const char * const buff) {
   // (void *)-> Avoid Warning when save data different from uintX_t in HMI_data_t struct
   memcpy((void *)&HMI_data, buff, _MIN(sizeof(HMI_data), eeprom_data_size));
   dwin_zoffset = TERN0(HAS_BED_PROBE, probe.offset.z);
   if (HMI_data.Text_Color == HMI_data.Background_Color) DWIN_SetColorDefaults();
   DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color, HMI_data.StatusBg_Color);
   TERN_(PREVENT_COLD_EXTRUSION, ApplyExtMinT());
   feedrate_percentage = 100;
   TERN_(BAUD_RATE_GCODE, HMI_SetBaudRate());
   #if BOTH(CASE_LIGHT_MENU, CASELIGHT_USES_BRIGHTNESS)
     // Apply Case light brightness
     caselight.brightness = HMI_data.CaseLight_Brightness;
     caselight.update_brightness();
   #endif
   #if BOTH(LED_CONTROL_MENU, HAS_COLOR_LEDS)
     // Apply Led Color
     leds.set_color(HMI_data.Led_Color);
   #endif
+
 }
 
 // Initialize or re-initialize the LCD
 void MarlinUI::init_lcd() {
   TERN_(DEBUG_DWIN, SERIAL_ECHOLNPGM("DWIN_Startup"));
   DWINUI::init();
   DWIN_JPG_CacheTo1(Language_English);
   Encoder_Configuration();
 }
 
@@ -1766,24 +1767,24 @@ void MarlinUI::kill_screen(FSTR_P const lcd_error, FSTR_P const lcd_component) {
   DWIN_Draw_Popup(ICON_BLTouch, F("Printer killed:"), lcd_error);
   DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 270, F("Turn off the printer"));
   DWIN_UpdateLCD();
 }
 
 void DWIN_RebootScreen() {
   DWIN_Frame_Clear(Color_Bg_Black);
   DWIN_JPG_ShowAndCache(0);
   DWINUI::Draw_CenteredString(Color_White, 220, GET_TEXT_F(MSG_PLEASE_WAIT_REBOOT));
   DWIN_UpdateLCD();
-  delay(500);
+  safe_delay(500);
 }
 
-void DWIN_Redraw_screen() {
+void DWIN_RedrawScreen() {
   Draw_Main_Area();
   hash_changed = true;
   DWIN_DrawStatusMessage();
   DWIN_Draw_Dashboard();
 }
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   void DWIN_Popup_Pause(FSTR_P const fmsg, uint8_t button /*= 0*/) {
     HMI_SaveProcessID(button ? WaitResponse : NothingToDo);
     DWIN_Show_Popup(ICON_BLTouch, GET_TEXT_F(MSG_ADVANCED_PAUSE), fmsg, button);
@@ -1891,27 +1892,27 @@ void Goto_ConfirmToPrint() {
 // Tool functions
 
 #if ENABLED(EEPROM_SETTINGS)
   void WriteEeprom() {
     const bool success = settings.save();
     HMI_AudioFeedback(success);
   }
 
   void ReadEeprom() {
     const bool success = settings.load();
-    DWIN_Redraw_screen();
+    DWIN_RedrawScreen();
     HMI_AudioFeedback(success);
   }
 
   void ResetEeprom() {
     settings.reset();
-    DWIN_Redraw_screen();
+    DWIN_RedrawScreen();
     HMI_AudioFeedback();
   }
 #endif
 
 // Reset Printer
 void RebootPrinter() {
   wait_for_heatup = wait_for_user = false;    // Stop waiting for heating/user
   thermalManager.disable_all_heaters();
   planner.finish_and_disable();
   DWIN_RebootScreen();
@@ -1940,21 +1941,21 @@ void HomeX() { queue.inject(F("G28X")); }
 void HomeY() { queue.inject(F("G28Y")); }
 void HomeZ() { queue.inject(F("G28Z")); }
 
 void SetHome() {
   // Apply workspace offset, making the current position 0,0,0
   queue.inject(F("G92 X0 Y0 Z0"));
   HMI_AudioFeedback();
 }
 
 #if HAS_ZOFFSET_ITEM
-  bool printer_busy() { return planner.movesplanned() || printingIsActive(); }
+
   void ApplyZOffset() { TERN_(EEPROM_SETTINGS, settings.save()); }
   void LiveZOffset() {
     last_zoffset = dwin_zoffset;
     dwin_zoffset = MenuData.Value / 100.0f;
     #if EITHER(BABYSTEP_ZPROBE_OFFSET, JUST_BABYSTEP)
       if (BABYSTEP_ALLOWED()) babystep.add_mm(Z_AXIS, dwin_zoffset - last_zoffset);
     #endif
   }
   #if EITHER(HAS_BED_PROBE, BABYSTEPPING)
     void SetZOffset() {
@@ -2059,21 +2060,21 @@ void SetPID(celsius_t t, heater_id_t h) {
     DWIN_UpdateLCD();
   }
   void SetBaud115K() { queue.inject(F("M575 P0 B115200")); HMI_data.Baud115K = true; }
   void SetBaud250K() { queue.inject(F("M575 P0 B250000")); HMI_data.Baud115K = false; }
 #endif
 
 #if HAS_LCD_BRIGHTNESS
   void ApplyBrightness() { ui.set_brightness(MenuData.Value); }
   void LiveBrightness() { DWIN_LCD_Brightness(MenuData.Value); }
   void SetBrightness() { SetIntOnClick(LCD_BRIGHTNESS_MIN, LCD_BRIGHTNESS_MAX, ui.brightness, ApplyBrightness, LiveBrightness); }
-  void TurnOffBacklight() { HMI_SaveProcessID(WaitResponse); ui.set_brightness(0); DWIN_Redraw_screen(); }
+  void TurnOffBacklight() { HMI_SaveProcessID(WaitResponse); ui.set_brightness(0); DWIN_RedrawScreen(); }
 #endif
 
 #if ENABLED(CASE_LIGHT_MENU)
   void SetCaseLight() {
     caselight.on = !caselight.on;
     caselight.update_enabled();
     Draw_Chkb_Line(CurrentMenu->line(), caselight.on);
     DWIN_UpdateLCD();
   }
   #if ENABLED(CASELIGHT_USES_BRIGHTNESS)
@@ -2163,21 +2164,21 @@ void SetPID(celsius_t t, heater_id_t h) {
 #endif
 
 #if ENABLED(PREVENT_COLD_EXTRUSION)
   void ApplyExtMinT() { thermalManager.extrude_min_temp = HMI_data.ExtMinT; thermalManager.allow_cold_extrude = (HMI_data.ExtMinT == 0); }
   void SetExtMinT() { SetPIntOnClick(MIN_ETEMP, MAX_ETEMP, ApplyExtMinT); }
 #endif
 
 void RestoreDefaultsColors() {
   DWIN_SetColorDefaults();
   DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color, HMI_data.StatusBg_Color);
-  DWIN_Redraw_screen();
+  DWIN_RedrawScreen();
 }
 
 void SelColor() {
   MenuData.P_Int = (int16_t*)static_cast<MenuItemPtrClass*>(CurrentMenu->SelectedItem())->value;
   HMI_value.Color[0] = GetRColor(*MenuData.P_Int);  // Red
   HMI_value.Color[1] = GetGColor(*MenuData.P_Int);  // Green
   HMI_value.Color[2] = GetBColor(*MenuData.P_Int);  // Blue
   Draw_GetColor_Menu();
 }
 
@@ -2974,21 +2975,21 @@ void Draw_Prepare_Menu() {
       #endif
     #endif
     MENU_ITEM(ICON_Cool, GET_TEXT_F(MSG_COOLDOWN), onDrawCooldown, DoCoolDown);
     MENU_ITEM(ICON_Language, PSTR(GET_TEXT_F(MSG_UI_LANGUAGE)), onDrawLanguage, SetLanguage);
   }
   ui.reset_status(true);
   CurrentMenu->draw();
 }
 
 void Draw_Tramming_Menu() {
-  DWINUI::ClearMenuArea();
+  DWINUI::ClearMainArea();
   checkkey = Menu;
   if (!TrammingMenu) TrammingMenu = new MenuClass();
   if (CurrentMenu != TrammingMenu) {
     CurrentMenu = TrammingMenu;
     SetMenuTitle({0}, GET_TEXT_F(MSG_BED_TRAMMING)); // TODO: Chinese, English "Bed Tramming" JPG
     DWINUI::MenuItemsPrepare(8);
     MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_Prepare_Menu);
     MENU_ITEM(ICON_Axis, GET_TEXT_F(MSG_LEVBED_FL), onDrawMenuItem, TramFL);
     MENU_ITEM(ICON_Axis, GET_TEXT_F(MSG_LEVBED_FR), onDrawMenuItem, TramFR);
     MENU_ITEM(ICON_Axis, GET_TEXT_F(MSG_LEVBED_BR), onDrawMenuItem, TramBR);

commit 04fe50936e23a8aca7a400591e700c1220f68b3f
Author: Pauli Jokela <pauli.jokela@didstopia.com>
Date:   Thu May 12 05:23:16 2022 +0300

    ‚ú® SOUND_ON_DEFAULT option (#24102)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index fe424e062a..1933c82d36 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -2099,22 +2099,22 @@ void SetPID(celsius_t t, heater_id_t h) {
     void SetLedColorB() { SetIntOnClick(0, 255, leds.color.b, nullptr, LiveLedColorB); }
     #if HAS_WHITE_LED
       void LiveLedColorW() { leds.color.w = MenuData.Value; HMI_data.Led_Color = leds.color; leds.update(); }
       void SetLedColorW() { SetIntOnClick(0, 255, leds.color.w, nullptr, LiveLedColorW); }
     #endif
   #endif
 #endif
 
 #if ENABLED(SOUND_MENU_ITEM)
   void SetEnableSound() {
-    ui.buzzer_enabled = !ui.buzzer_enabled;
-    Draw_Chkb_Line(CurrentMenu->line(), ui.buzzer_enabled);
+    ui.sound_on = !ui.sound_on;
+    Draw_Chkb_Line(CurrentMenu->line(), ui.sound_on);
     DWIN_UpdateLCD();
   }
 #endif
 
 #if HAS_HOME_OFFSET
   void ApplyHomeOffset() { set_home_offset(HMI_value.axis, MenuData.Value / MINUNITMULT); }
   void SetHomeOffsetX() { HMI_value.axis = X_AXIS; SetPFloatOnClick(-50, 50, UNITFDIGITS, ApplyHomeOffset); }
   void SetHomeOffsetY() { HMI_value.axis = Y_AXIS; SetPFloatOnClick(-50, 50, UNITFDIGITS, ApplyHomeOffset); }
   void SetHomeOffsetZ() { HMI_value.axis = Z_AXIS; SetPFloatOnClick( -2,  2, UNITFDIGITS, ApplyHomeOffset); }
 #endif
@@ -2631,21 +2631,21 @@ void onDrawLanguage(MenuItemClass* menuitem, int8_t line) {
   void onDrawCaseLight(MenuItemClass* menuitem, int8_t line) { onDrawChkbMenu(menuitem, line, caselight.on); }
 #endif
 
 #if ENABLED(LED_CONTROL_MENU)
   #if !BOTH(CASE_LIGHT_MENU, CASE_LIGHT_USE_NEOPIXEL)
     void onDrawLedStatus(MenuItemClass* menuitem, int8_t line) { onDrawChkbMenu(menuitem, line, leds.lights_on); }
   #endif
 #endif
 
 #if ENABLED(SOUND_MENU_ITEM)
-  void onDrawEnableSound(MenuItemClass* menuitem, int8_t line) { onDrawChkbMenu(menuitem, line, ui.buzzer_enabled); }
+  void onDrawEnableSound(MenuItemClass* menuitem, int8_t line) { onDrawChkbMenu(menuitem, line, ui.sound_on); }
 #endif
 
 #ifdef BLTOUCH_HS_MODE
   void onDrawHSMode(MenuItemClass* menuitem, int8_t line) { onDrawChkbMenu(menuitem, line, bltouch.high_speed_mode); }
 #endif
 
 void onDrawSelColorItem(MenuItemClass* menuitem, int8_t line) {
   const uint16_t color = *(uint16_t*)static_cast<MenuItemPtrClass*>(menuitem)->value;
   DWIN_Draw_Rectangle(0, HMI_data.Highlight_Color, ICOX + 1, MBASE(line) - 1 + 1, ICOX + 18, MBASE(line) - 1 + 18);
   DWIN_Draw_Rectangle(1, color, ICOX + 2, MBASE(line) - 1 + 2, ICOX + 17, MBASE(line) - 1 + 17);

commit df40181357b08761766067ef5012b2b3d0e34d3e
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Wed May 4 17:25:02 2022 -0700

    üí• Num Axes and Multi-Stepper based on Driver Types (#24120)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 9db6355e98..fe424e062a 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -2083,21 +2083,21 @@ void SetPID(celsius_t t, heater_id_t h) {
 #endif
 
 #if ENABLED(LED_CONTROL_MENU)
   #if !BOTH(CASE_LIGHT_MENU, CASE_LIGHT_USE_NEOPIXEL)
     void SetLedStatus() {
       leds.toggle();
       Draw_Chkb_Line(CurrentMenu->line(), leds.lights_on);
       DWIN_UpdateLCD();
     }
   #endif
-  #if ENABLED(HAS_COLOR_LEDS)
+  #if HAS_COLOR_LEDS
     void LiveLedColorR() { leds.color.r = MenuData.Value; HMI_data.Led_Color = leds.color; leds.update(); }
     void SetLedColorR() { SetIntOnClick(0, 255, leds.color.r, nullptr, LiveLedColorR); }
     void LiveLedColorG() { leds.color.g = MenuData.Value; HMI_data.Led_Color = leds.color; leds.update(); }
     void SetLedColorG() { SetIntOnClick(0, 255, leds.color.g, nullptr, LiveLedColorG); }
     void LiveLedColorB() { leds.color.b = MenuData.Value; HMI_data.Led_Color = leds.color; leds.update(); }
     void SetLedColorB() { SetIntOnClick(0, 255, leds.color.b, nullptr, LiveLedColorB); }
     #if HAS_WHITE_LED
       void LiveLedColorW() { leds.color.w = MenuData.Value; HMI_data.Led_Color = leds.color; leds.update(); }
       void SetLedColorW() { SetIntOnClick(0, 255, leds.color.w, nullptr, LiveLedColorW); }
     #endif
@@ -3253,21 +3253,21 @@ void Draw_GetColor_Menu() {
       checkkey = Menu;
       if (!LedControlMenu) LedControlMenu = new MenuClass();
       if (CurrentMenu != LedControlMenu) {
         CurrentMenu = LedControlMenu;
         SetMenuTitle({0}, GET_TEXT_F(MSG_LED_CONTROL)); // TODO: Chinese, English "LED Control" JPG
         DWINUI::MenuItemsPrepare(6);
         MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_Control_Menu);
         #if !BOTH(CASE_LIGHT_MENU, CASE_LIGHT_USE_NEOPIXEL)
           MENU_ITEM(ICON_LedControl, GET_TEXT_F(MSG_LEDS), onDrawLedStatus, SetLedStatus);
         #endif
-        #if (HAS_COLOR_LEDS)
+        #if HAS_COLOR_LEDS
           EDIT_ITEM(ICON_LedControl, GET_TEXT_F(MSG_COLORS_RED), onDrawPInt8Menu, SetLedColorR, &leds.color.r);
           EDIT_ITEM(ICON_LedControl, GET_TEXT_F(MSG_COLORS_GREEN), onDrawPInt8Menu, SetLedColorG, &leds.color.g);
           EDIT_ITEM(ICON_LedControl, GET_TEXT_F(MSG_COLORS_BLUE), onDrawPInt8Menu, SetLedColorB, &leds.color.b);
           #if ENABLED(HAS_WHITE_LED)
             EDIT_ITEM(ICON_LedControl, GET_TEXT_F(MSG_COLORS_WHITE), onDrawPInt8Menu, SetLedColorW, &leds.color.w);
           #endif
         #endif
       }
       CurrentMenu->draw();
     }

commit 4a73fa18d8d6b7b8909fad8a84dfe90cf8fefab1
Author: Mateusz Kleina <mateuszkleina@gmail.com>
Date:   Fri Apr 22 12:12:39 2022 +0200

    üêõ Fix ProUI / JyersUI leveling preheat (#24064)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 7b5f6955af..9db6355e98 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -1695,21 +1695,21 @@ void DWIN_SetDataDefaults() {
   DWIN_SetColorDefaults();
   DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color, HMI_data.StatusBg_Color);
   TERN_(HAS_HOTEND,     HMI_data.HotendPidT = PREHEAT_1_TEMP_HOTEND);
   TERN_(HAS_HEATED_BED, HMI_data.BedPidT    = PREHEAT_1_TEMP_BED);
   TERN_(HAS_HOTEND,     HMI_data.PidCycles  = 5);
   #if ENABLED(PREVENT_COLD_EXTRUSION)
     HMI_data.ExtMinT = EXTRUDE_MINTEMP;
     ApplyExtMinT();
   #endif
   #if BOTH(HAS_HEATED_BED, PREHEAT_BEFORE_LEVELING)
-    HMI_data.BedLevT = PREHEAT_1_TEMP_BED;
+    HMI_data.BedLevT = LEVELING_BED_TEMP;
   #endif
   TERN_(BAUD_RATE_GCODE, SetBaud250K());
 }
 
 void DWIN_StoreSettings(char *buff) {
   memcpy(buff, &HMI_data, _MIN(sizeof(HMI_data), eeprom_data_size));
 }
 
 void DWIN_LoadSettings(const char *buff) {
   // (void *)-> Avoid Warning when save data different from uintX_t in HMI_data_t struct

commit 8dfdf51678a4a3975df8250bedf3489fd4835796
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 25 17:09:55 2022 -0500

    üé® Format, use status macros

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 66e90740fd..7b5f6955af 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -2297,21 +2297,21 @@ TERN(HAS_ONESTEP_LEVELING, float, void) Tram(uint8_t point) {
     }
     else {
       LIMIT(xpos, X_MIN_POS, (X_MAX_POS + probe.offset.x));
       LIMIT(ypos, Y_MIN_POS, (Y_MAX_POS + probe.offset.y));
       probe.stow();
       gcode.process_subcommands_now(F("M420S0\nG28O"));
       planner.synchronize();
       inLev = true;
       zval = probe.probe_at_point(xpos, ypos, PROBE_PT_STOW);
       if (isnan(zval))
-        ui.set_status(F("Position Not Reachable, check offsets"));
+        LCD_MESSAGE_F("Position Not Reachable, check offsets");
       else {
         sprintf_P(cmd, PSTR("X:%s, Y:%s, Z:%s"),
           dtostrf(xpos, 1, 1, str_1),
           dtostrf(ypos, 1, 1, str_2),
           dtostrf(zval, 1, 2, str_3)
         );
         ui.set_status(cmd);
       }
       inLev = false;
     }
@@ -2329,21 +2329,21 @@ void TramFL() { Tram(0); }
 void TramFR() { Tram(1); }
 void TramBR() { Tram(2); }
 void TramBL() { Tram(3); }
 void TramC () { Tram(4); }
 
 #if HAS_ONESTEP_LEVELING
 
   void Trammingwizard() {
     bed_mesh_t zval = {0};
     if (HMI_data.FullManualTramming) {
-      ui.set_status(F("Disable manual tramming"));
+      LCD_MESSAGE_F("Disable manual tramming");
       return;
     }
     zval[0][0] = Tram(0);
     checkkey = NothingToDo;
     MeshViewer.DrawMesh(zval, 2, 2);
     zval[1][0] = Tram(1);
     MeshViewer.DrawMesh(zval, 2, 2);
     zval[1][1] = Tram(2);
     MeshViewer.DrawMesh(zval, 2, 2);
     zval[0][1] = Tram(3);

commit 89a9c3a391101e4d2d8dbfbf0cdb261ad2d9592b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 12 16:34:58 2022 -0600

    üßë‚Äçüíª  Add standard BUZZ types

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 95cb0b28b9..66e90740fd 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -1278,31 +1278,21 @@ void HMI_Printing() {
       case PRINT_STOP:
         return Goto_Popup(Popup_window_PauseOrStop, onClick_PauseOrStop);
       default: break;
     }
   }
   DWIN_UpdateLCD();
 }
 
 #include "../../../libs/buzzer.h"
 
-void HMI_AudioFeedback(const bool success/*=true*/) {
-  #if HAS_BUZZER
-    if (success) {
-      BUZZ(100, 659);
-      BUZZ(10, 0);
-      BUZZ(100, 698);
-    }
-    else
-      BUZZ(40, 440);
-  #endif
-}
+void HMI_AudioFeedback(const bool success/*=true*/) { DONE_BUZZ(success); }
 
 void Draw_Main_Area() {
   switch (checkkey) {
     case MainMenu:               Draw_Main_Menu(); break;
     case SelectFile:             Draw_Print_File_Menu(); break;
     case PrintProcess:           Draw_PrintProcess(); break;
     case PrintDone:              Draw_PrintDone(); break;
     #if HAS_ESDIAG
       case ESDiagProcess:        Draw_EndStopDiag(); break;
     #endif

commit 623c6b720b0d9b14934fb8ccb895d421ab043cc9
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 12 15:58:28 2022 -0600

    üßë‚Äçüíª Add ExtUI::onLevelingDone, match DWIN to ExtUI

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 0a392cd563..95cb0b28b9 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -1535,44 +1535,44 @@ void HMI_SaveProcessID(const uint8_t id) {
     if (!IDisPopUp()) last_checkkey = checkkey; // if previous is not a popup
     if ((id == Popup)
          || TERN0(HAS_ESDIAG, (id == ESDiagProcess))
          || (id == PrintDone)
          || (id == Leveling)
          || (id == WaitResponse)) wait_for_user = true;
     checkkey = id;
   }
 }
 
-void DWIN_StartHoming() {
+void DWIN_HomingStart() {
   HMI_flag.home_flag = true;
   HMI_SaveProcessID(Homing);
   Title.ShowCaption(GET_TEXT_F(MSG_HOMING));
   DWIN_Show_Popup(ICON_BLTouch, GET_TEXT_F(MSG_HOMING), GET_TEXT_F(MSG_PLEASE_WAIT));
 }
 
-void DWIN_CompletedHoming() {
+void DWIN_HomingDone() {
   HMI_flag.home_flag = false;
   dwin_zoffset = TERN0(HAS_BED_PROBE, probe.offset.z);
   if (HMI_flag.abort_action) DWIN_Print_Aborted(); else HMI_ReturnScreen();
 }
 
-void DWIN_MeshLevelingStart() {
+void DWIN_LevelingStart() {
   #if HAS_ONESTEP_LEVELING
     HMI_SaveProcessID(Leveling);
     Title.ShowCaption(GET_TEXT_F(MSG_BED_LEVELING));
     DWIN_Show_Popup(ICON_AutoLeveling, GET_TEXT_F(MSG_BED_LEVELING), GET_TEXT_F(MSG_PLEASE_WAIT));
   #elif ENABLED(MESH_BED_LEVELING)
     Draw_ManualMesh_Menu();
   #endif
 }
 
-void DWIN_CompletedLeveling() {
+void DWIN_LevelingDone() {
   TERN_(HAS_ONESTEP_LEVELING, if (planner.leveling_active) Goto_MeshViewer());
 }
 
 #if HAS_MESH
   void DWIN_MeshUpdate(const int8_t xpos, const int8_t ypos, const_float_t zval) {
     char msg[33] = "";
     char str_1[6] = "";
     sprintf_P(msg, PSTR(S_FMT " %i/%i Z=%s"), GET_TEXT(MSG_PROBING_POINT), xpos, ypos, dtostrf(zval, 1, 2, str_1));
     ui.set_status(msg);
   }

commit 79b38e0e14074b52e0aeb98b08a686a99a9b1aad
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Fri Mar 11 15:06:49 2022 -0500

    üö∏ Update Ender3 V2/S1 Pro UI (#23878)

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 9e08854aed..0a392cd563 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -14,33 +14,32 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 /**
- * Enhanced DWIN implementation
+ * DWIN Enhanced implementation for PRO UI
  * Author: Miguel A. Risco-Castillo (MRISCOC)
- * Version: 3.11.2
- * date: 2022/01/19
- *
- * Based on the original code provided by Creality under GPL
+ * Version: 3.15.2
+ * Date: 2022/03/01
  */
 
-#include "../../../inc/MarlinConfigPre.h"
+#include "../../../inc/MarlinConfig.h"
 
 #if ENABLED(DWIN_LCD_PROUI)
 
 #include "dwin.h"
+#include "menus.h"
 #include "dwin_popup.h"
 
 #include "../../fontutils.h"
 #include "../../marlinui.h"
 
 #include "../../../sd/cardreader.h"
 
 #include "../../../MarlinCore.h"
 #include "../../../core/serial.h"
 #include "../../../core/macros.h"
@@ -58,34 +57,44 @@
 #endif
 
 #if ENABLED(EEPROM_SETTINGS)
   #include "../../../module/settings.h"
 #endif
 
 #if ENABLED(HOST_ACTION_COMMANDS)
   #include "../../../feature/host_actions.h"
 #endif
 
+#if ANY(AUTO_BED_LEVELING_BILINEAR, AUTO_BED_LEVELING_LINEAR, AUTO_BED_LEVELING_3POINT) && DISABLED(PROBE_MANUALLY)
+  #define HAS_ONESTEP_LEVELING 1
+#endif
+
 #if HAS_MESH || HAS_ONESTEP_LEVELING
   #include "../../../feature/bedlevel/bedlevel.h"
 #endif
 
 #if HAS_BED_PROBE
   #include "../../../module/probe.h"
 #endif
 
 #ifdef BLTOUCH_HS_MODE
   #include "../../../feature/bltouch.h"
 #endif
 
-#if EITHER(BABYSTEP_ZPROBE_OFFSET, JUST_BABYSTEP)
-  #include "../../../feature/babystep.h"
+#if ANY(BABYSTEPPING, HAS_BED_PROBE, HAS_WORKSPACE_OFFSET)
+  #define HAS_ZOFFSET_ITEM 1
+  #if !HAS_BED_PROBE && ENABLED(BABYSTEPPING)
+    #define JUST_BABYSTEP 1
+  #endif
+  #if EITHER(BABYSTEP_ZPROBE_OFFSET, JUST_BABYSTEP)
+    #include "../../../feature/babystep.h"
+  #endif
 #endif
 
 #if ENABLED(POWER_LOSS_RECOVERY)
   #include "../../../feature/powerloss.h"
 #endif
 
 #if HAS_GCODE_PREVIEW
   #include "gcode_preview.h"
 #endif
 
@@ -164,69 +173,56 @@ HMI_flag_t HMI_flag{0};
 HMI_data_t HMI_data;
 
 millis_t dwin_heat_time = 0;
 
 uint8_t checkkey = 255, last_checkkey = MainMenu;
 
 enum SelectItem : uint8_t {
   PAGE_PRINT = 0,
   PAGE_PREPARE,
   PAGE_CONTROL,
-  PAGE_INFO_LEV_ADV,
+  PAGE_ADVANCE,
   PAGE_COUNT,
 
   PRINT_SETUP = 0,
   PRINT_PAUSE_RESUME,
   PRINT_STOP,
   PRINT_COUNT
 };
 
 typedef struct {
   uint8_t now, last;
   void set(uint8_t v) { now = last = v; }
   void reset() { set(0); }
   bool changed() { bool c = (now != last); if (c) last = now; return c; }
   bool dec() { if (now) now--; return changed(); }
   bool inc(uint8_t v) { if (now < (v - 1)) now++; else now = (v - 1); return changed(); }
 } select_t;
 
 select_t select_page{0}, select_file{0}, select_print{0};
 uint8_t index_file     = MROWS;
 
-bool dwin_abort_flag = false; // Flag to reset feedrate, return to Home
 bool hash_changed = true; // Flag to know if message status was changed
 
-constexpr float default_max_feedrate[]        = DEFAULT_MAX_FEEDRATE;
-constexpr float default_max_acceleration[]    = DEFAULT_MAX_ACCELERATION;
+constexpr float max_feedrate_edit_values[]        = DEFAULT_MAX_FEEDRATE;
+constexpr float max_acceleration_edit_values[]    = DEFAULT_MAX_ACCELERATION;
 
 #if HAS_CLASSIC_JERK
-  constexpr float default_max_jerk[]          = { DEFAULT_XJERK, DEFAULT_YJERK, DEFAULT_ZJERK, DEFAULT_EJERK };
+  constexpr float max_jerk_edit_values[]          = { DEFAULT_XJERK, DEFAULT_YJERK, DEFAULT_ZJERK, DEFAULT_EJERK };
 #endif
 
 static uint8_t _percent_done = 0;
 static uint32_t _remain_time = 0;
 
 // Additional Aux Host Support
 static bool sdprint = false;
 
-#if ENABLED(PAUSE_HEAT)
-  #if HAS_HOTEND
-    celsius_t resume_hotend_temp = 0;
-  #endif
-  #if HAS_HEATED_BED
-    celsius_t resume_bed_temp = 0;
-  #endif
-  #if HAS_FAN
-    uint16_t resume_fan = 0;
-  #endif
-#endif
-
 #if HAS_ZOFFSET_ITEM
   float dwin_zoffset = 0, last_zoffset = 0;
 #endif
 
 #if HAS_HOTEND
   float last_E = 0;
 #endif
 
 // New menu system pointers
 MenuClass *PrepareMenu = nullptr;
@@ -341,45 +337,27 @@ void ICON_Prepare() {
 
 //
 // Main Menu: "Control"
 //
 void ICON_Control() {
   constexpr frame_rect_t ico = { 17, 226, 110, 100 };
   constexpr text_info_t txt = { 61, { 405, TERN(USE_STOCK_DWIN_SET, 446, 447) }, 27, 15 };
   ICON_Button(select_page.now == PAGE_CONTROL, ICON_Control_0, ico, txt, GET_TEXT_F(MSG_CONTROL));
 }
 
-//
-// Main Menu: "Info"
-//
-void ICON_StartInfo() {
-  constexpr frame_rect_t ico = { 145, 226, 110, 100 };
-  constexpr text_info_t txt = { 91, { 405, TERN(USE_STOCK_DWIN_SET, 446, 447) }, 27, 15 };
-  ICON_Button(select_page.now == PAGE_INFO_LEV_ADV, ICON_Info_0, ico, txt, GET_TEXT_F(MSG_BUTTON_INFO));
-}
-
-//
-// Main Menu: "Level"
-//
-void ICON_Leveling() {
-  constexpr frame_rect_t ico = { 145, 226, 110, 100 };
-  constexpr text_info_t txt = { 211, { 405, TERN(USE_STOCK_DWIN_SET, 446, 447) }, 27, 15 };
-  ICON_Button(select_page.now == PAGE_INFO_LEV_ADV, ICON_Leveling_0, ico, txt, GET_TEXT_F(MSG_BUTTON_LEVEL));
-}
-
 //
 // Main Menu: "Advanced Settings"
 //
 void ICON_AdvSettings() {
   constexpr frame_rect_t ico = { 145, 226, 110, 100 };
   constexpr text_info_t txt = { 91, { 405, TERN(USE_STOCK_DWIN_SET, 446, 447) }, 27, 15 };
-  ICON_Button(select_page.now == PAGE_INFO_LEV_ADV, ICON_Info_0, ico, txt, GET_TEXT_F(MSG_BUTTON_ADVANCED));
+  ICON_Button(select_page.now == PAGE_ADVANCE, ICON_Info_0, ico, txt, GET_TEXT_F(MSG_BUTTON_ADVANCED));
 }
 
 //
 // Printing: "Tune"
 //
 void ICON_Tune() {
   constexpr frame_rect_t ico = { 8, 232, 80, 100 };
   constexpr text_info_t txt = { 121, { 405, TERN(USE_STOCK_DWIN_SET, 446, 447) }, 27, 15 };
   ICON_Button(select_print.now == PRINT_SETUP, ICON_Setup_0, ico, txt, GET_TEXT_F(MSG_TUNE));
 }
@@ -408,97 +386,56 @@ void ICON_Resume() {
 void ICON_Stop() {
   constexpr frame_rect_t ico = { 184, 232, 80, 100 };
   constexpr text_info_t txt = { 151, { 405, TERN(USE_STOCK_DWIN_SET, 446, 447) }, 27, 12 };
   ICON_Button(select_print.now == PRINT_STOP, ICON_Stop_0, ico, txt, GET_TEXT_F(MSG_BUTTON_STOP));
 }
 
 //-----------------------------------------------------------------------------
 // Drawing routines
 //-----------------------------------------------------------------------------
 
-void Draw_Menu_Cursor(const int8_t line) {
-  DWIN_Draw_Rectangle(1, HMI_data.Cursor_color, 0, MBASE(line) - 18, 14, MBASE(line + 1) - 20);
-}
-
-void Erase_Menu_Cursor(const int8_t line) {
-  DWIN_Draw_Rectangle(1, HMI_data.Background_Color, 0, MBASE(line) - 18, 14, MBASE(line + 1) - 20);
-}
-
 void Move_Highlight(const int8_t from, const int8_t newline) {
   Erase_Menu_Cursor(newline - from);
   Draw_Menu_Cursor(newline);
 }
 
 void Add_Menu_Line() {
   Move_Highlight(1, MROWS);
-  DWIN_Draw_Line(HMI_data.SplitLine_Color, 16, MBASE(MROWS + 1) - 20, 256, MBASE(MROWS + 1) - 19);
+  DWIN_Draw_HLine(HMI_data.SplitLine_Color, 16, MYPOS(MROWS + 1), 240);
 }
 
 void Scroll_Menu(const uint8_t dir) {
   DWIN_Frame_AreaMove(1, dir, MLINE, HMI_data.Background_Color, 0, 31, DWIN_WIDTH, 349);
   switch (dir) {
     case DWIN_SCROLL_DOWN: Move_Highlight(-1, 0); break;
     case DWIN_SCROLL_UP:   Add_Menu_Line(); break;
   }
 }
 
 inline uint16_t nr_sd_menu_items() {
   return card.get_num_Files() + !card.flag.workDirIsRoot;
 }
 
 void Erase_Menu_Text(const uint8_t line) {
   DWIN_Draw_Rectangle(1, HMI_data.Background_Color, LBLX, MBASE(line) - 14, 271, MBASE(line) + 28);
 }
 
-void Draw_Menu_Line(const uint8_t line, const uint8_t icon=0, const char * const label=nullptr, bool more=false) {
-  if (icon)  DWINUI::Draw_Icon(icon, ICOX, MBASE(line) - 3);
-  if (label) DWINUI::Draw_String(LBLX, MBASE(line) - 1, (char*)label);
-  if (more)  DWINUI::Draw_Icon(ICON_More, VALX + 16, MBASE(line) - 3);
-  DWIN_Draw_HLine(HMI_data.SplitLine_Color, 16, MYPOS(line + 1), 240);
-}
-
-void Draw_Chkb_Line(const uint8_t line, const bool checked) {
-  DWINUI::Draw_Checkbox(HMI_data.Text_Color, HMI_data.Background_Color, VALX + 16, MBASE(line) - 1, checked);
-}
-
-void Draw_Menu_IntValue(uint16_t bcolor, const uint8_t line, uint8_t iNum, const uint16_t value=0) {
-  DWINUI::Draw_Int(HMI_data.Text_Color, bcolor, iNum , VALX, MBASE(line) - 1, value);
-}
-
 // Draw "Back" line at the top
 void Draw_Back_First(const bool is_sel=true) {
   Draw_Menu_Line(0, ICON_Back);
   if (HMI_IsChinese())
     DWIN_Frame_AreaCopy(1, 129, 72, 156, 84, LBLX, MBASE(0));
   else
     DWINUI::Draw_String(LBLX, MBASE(0), GET_TEXT_F(MSG_BACK));
   if (is_sel) Draw_Menu_Cursor(0);
 }
 
-inline EncoderState get_encoder_state() {
-  static millis_t Encoder_ms = 0;
-  const millis_t ms = millis();
-  if (PENDING(ms, Encoder_ms)) return ENCODER_DIFF_NO;
-  const EncoderState state = Encoder_ReceiveAnalyze();
-  if (state != ENCODER_DIFF_NO) Encoder_ms = ms + ENCODER_WAIT_MS;
-  return state;
-}
-
-template<typename T>
-inline bool Apply_Encoder(const EncoderState &encoder_diffState, T &valref) {
-  if (encoder_diffState == ENCODER_DIFF_CW)
-    valref += EncoderRate.encoderMoveValue;
-  else if (encoder_diffState == ENCODER_DIFF_CCW)
-    valref -= EncoderRate.encoderMoveValue;
-  return encoder_diffState == ENCODER_DIFF_ENTER;
-}
-
 //PopUps
 void Popup_window_PauseOrStop() {
   if (HMI_IsChinese()) {
     DWINUI::ClearMenuArea();
     Draw_Popup_Bkgd();
          if (select_print.now == PRINT_PAUSE_RESUME) DWIN_Frame_AreaCopy(1, 237, 338, 269, 356, 98, 150);
     else if (select_print.now == PRINT_STOP) DWIN_Frame_AreaCopy(1, 221, 320, 253, 336, 98, 150);
     DWIN_Frame_AreaCopy(1, 220, 304, 264, 319, 130, 150);
     DWINUI::Draw_IconWB(ICON_Confirm_C, 26, 280);
     DWINUI::Draw_IconWB(ICON_Cancel_C, 146, 280);
@@ -523,259 +460,267 @@ void Popup_window_PauseOrStop() {
       DWIN_UpdateLCD();
     }
     else
       DWIN_Popup_Confirm(ICON_TempTooLow, GET_TEXT_F(MSG_HOTEND_TOO_COLD), GET_TEXT_F(MSG_PLEASE_PREHEAT));
   }
 
 #endif
 
 #if HAS_HOTEND || HAS_HEATED_BED
   void DWIN_Popup_Temperature(const bool toohigh) {
-    DWINUI::ClearMenuArea();
-    Draw_Popup_Bkgd();
+    HMI_SaveProcessID(WaitResponse);
     if (HMI_IsChinese()) {
+      DWINUI::ClearMenuArea();
+      Draw_Popup_Bkgd();
       if (toohigh) {
         DWINUI::Draw_Icon(ICON_TempTooHigh, 102, 165);
         DWIN_Frame_AreaCopy(1, 103, 371, 237, 386, 52, 285);
         DWIN_Frame_AreaCopy(1, 151, 389, 185, 402, 187, 285);
         DWIN_Frame_AreaCopy(1, 189, 389, 271, 402, 95, 310);
       }
       else {
         DWINUI::Draw_Icon(ICON_TempTooLow, 102, 165);
         DWIN_Frame_AreaCopy(1, 103, 371, 270, 386, 52, 285);
         DWIN_Frame_AreaCopy(1, 189, 389, 271, 402, 95, 310);
       }
     }
-    else {
-      DWIN_Draw_Popup(toohigh ? ICON_TempTooHigh : ICON_TempTooLow, F("Nozzle or Bed temperature"), toohigh ? F("is too high") : F("is too low"));
-    }
+    else DWIN_Show_Popup(toohigh ? ICON_TempTooHigh : ICON_TempTooLow, F("Nozzle or Bed temperature"), toohigh ? F("is too high") : F("is too low"), BTN_Continue);
   }
 #endif
 
 // Draw status line
-void DWIN_DrawStatusLine(const uint16_t color, const uint16_t bgcolor, const char *text, const bool center = true) {
-  DWIN_Draw_Rectangle(1, bgcolor, 0, STATUS_Y, DWIN_WIDTH, STATUS_Y + 20);
-  if (text) {
-    if (center) DWINUI::Draw_CenteredString(color, STATUS_Y + 2, text);
-    else        DWINUI::Draw_String(color, 0, STATUS_Y + 2, text);
-  }
-  DWIN_UpdateLCD();
-}
-void DWIN_DrawStatusLine(const char *text, const bool center = true) {
-  DWIN_DrawStatusLine(HMI_data.StatusTxt_Color, HMI_data.StatusBg_Color, text, center);
+void DWIN_DrawStatusLine(const char *text) {
+  DWIN_Draw_Rectangle(1, HMI_data.StatusBg_Color, 0, STATUS_Y, DWIN_WIDTH, STATUS_Y + 20);
+  if (text) DWINUI::Draw_CenteredString(HMI_data.StatusTxt_Color, STATUS_Y + 2, text);
 }
 
 // Clear & reset status line
 void DWIN_ResetStatusLine() {
   ui.status_message[0] = 0;
   DWIN_CheckStatusMessage();
 }
 
 // Djb2 hash algorithm
 void DWIN_CheckStatusMessage() {
   static uint32_t old_hash = 0;
   char * str = &ui.status_message[0];
   uint32_t hash = 5381;
   char c;
   while ((c = *str++)) hash = ((hash << 5) + hash) + c; /* hash * 33 + c */
   hash_changed = hash != old_hash;
   old_hash = hash;
 };
 
 void DWIN_DrawStatusMessage() {
-  const uint8_t max_status_chars = DWIN_WIDTH / DWINUI::fontWidth();
-
   #if ENABLED(STATUS_MESSAGE_SCROLLING)
 
     // Get the UTF8 character count of the string
     uint8_t slen = utf8_strlen(ui.status_message);
 
     // If the string fits the status line do not scroll it
-    if (slen <= max_status_chars) {
+    if (slen <= LCD_WIDTH) {
        if (hash_changed) {
-         DWIN_DrawStatusLine(HMI_data.StatusTxt_Color, HMI_data.StatusBg_Color, ui.status_message);
+         DWIN_DrawStatusLine(ui.status_message);
          hash_changed = false;
        }
     }
     else {
       // String is larger than the available line space
 
       // Get a pointer to the next valid UTF8 character
       // and the string remaining length
       uint8_t rlen;
       const char *stat = MarlinUI::status_and_len(rlen);
       DWIN_Draw_Rectangle(1, HMI_data.StatusBg_Color, 0, STATUS_Y, DWIN_WIDTH, STATUS_Y + 20);
       DWINUI::MoveTo(0, STATUS_Y + 2);
-      DWINUI::Draw_String(stat, max_status_chars);
+      DWINUI::Draw_String(HMI_data.StatusTxt_Color, stat, LCD_WIDTH);
 
       // If the string doesn't completely fill the line...
-      if (rlen < max_status_chars) {
-        DWINUI::Draw_Char('.');                   // Always at 1+ spaces left, draw a dot
-        uint8_t chars = max_status_chars - rlen;  // Amount of space left in characters
+      if (rlen < LCD_WIDTH) {
+        DWINUI::Draw_Char(HMI_data.StatusTxt_Color, '.');  // Always at 1+ spaces left, draw a dot
+        uint8_t chars = LCD_WIDTH - rlen;                  // Amount of space left in characters
         if (--chars) {                            // Draw a second dot if there's space
-          DWINUI::Draw_Char('.');
+          DWINUI::Draw_Char(HMI_data.StatusTxt_Color, '.');
           if (--chars)
-            DWINUI::Draw_String(ui.status_message, chars); // Print a second copy of the message
+            DWINUI::Draw_String(HMI_data.StatusTxt_Color, ui.status_message, chars); // Print a second copy of the message
         }
       }
       MarlinUI::advance_status_scroll();
     }
 
   #else
 
     if (hash_changed) {
-      ui.status_message[max_status_chars] = 0;
-      DWIN_DrawStatusLine(HMI_data.StatusTxt_Color, HMI_data.StatusBg_Color, ui.status_message);
+      ui.status_message[LCD_WIDTH] = 0;
+      DWIN_DrawStatusLine(ui.status_message);
       hash_changed = false;
     }
 
   #endif
 }
 
 void Draw_Print_Labels() {
   if (HMI_IsChinese()) {
     DWIN_Frame_AreaCopy(1,  0, 72,  63, 86,  41, 173);  // Printing Time
     DWIN_Frame_AreaCopy(1, 65, 72, 128, 86, 176, 173);  // Remain
   }
   else {
     DWINUI::Draw_String( 46, 173, GET_TEXT_F(MSG_INFO_PRINT_TIME));
     DWINUI::Draw_String(181, 173, GET_TEXT_F(MSG_REMAINING_TIME));
   }
 }
 
 void Draw_Print_ProgressBar() {
-  DWINUI::Draw_IconWB(ICON_Bar, 15, 93);
+  DWIN_ICON_Show(true, false, false, ICON, ICON_Bar, 15, 93);
   DWIN_Draw_Rectangle(1, HMI_data.Barfill_Color, 16 + _percent_done * 240 / 100, 93, 256, 113);
   DWINUI::Draw_Int(HMI_data.PercentTxt_Color, HMI_data.Background_Color, 3, 117, 133, _percent_done);
   DWINUI::Draw_String(HMI_data.PercentTxt_Color, 142, 133, F("%"));
 }
 
 void Draw_Print_ProgressElapsed() {
   char buf[10];
   duration_t elapsed = print_job_timer.duration(); // print timer
   sprintf_P(buf, PSTR("%02i:%02i"), (uint16_t)(elapsed.value / 3600), ((uint16_t)elapsed.value % 3600) / 60);
   DWINUI::Draw_String(HMI_data.Text_Color, HMI_data.Background_Color, 47, 192, buf);
 }
 
 void Draw_Print_ProgressRemain() {
   char buf[10];
   sprintf_P(buf, PSTR("%02i:%02i"), (uint16_t)(_remain_time / 3600), ((uint16_t)_remain_time % 3600) / 60);
   DWINUI::Draw_String(HMI_data.Text_Color, HMI_data.Background_Color, 181, 192, buf);
 }
 
 void ICON_ResumeOrPause() {
-  if (printingIsPaused() || HMI_flag.pause_flag || HMI_flag.pause_action)
-    ICON_Resume();
-  else
-    ICON_Pause();
+  if (checkkey == PrintProcess) printingIsPaused() ? ICON_Resume() : ICON_Pause();
+}
+
+// Update filename on print
+void DWIN_Print_Header(const char *text = nullptr) {
+  static char headertxt[31] = "";  // Print header text
+  if (text) {
+    const int8_t size = _MIN(30U, strlen_P(text));
+    LOOP_L_N(i, size) headertxt[i] = text[i];
+    headertxt[size] = '\0';
+  }
+  if (checkkey == PrintProcess || checkkey == PrintDone) {
+    DWIN_Draw_Rectangle(1, HMI_data.Background_Color, 0, 60, DWIN_WIDTH, 60+16);
+    DWINUI::Draw_CenteredString(60, headertxt);
+  }
 }
 
 void Draw_PrintProcess() {
   if (HMI_IsChinese())
     Title.FrameCopy(30, 1, 42, 14);                     // "Printing"
   else
     Title.ShowCaption(GET_TEXT_F(MSG_PRINTING));
   DWINUI::ClearMenuArea();
   DWIN_Print_Header(sdprint ? card.longest_filename() : nullptr);
   Draw_Print_Labels();
   DWINUI::Draw_Icon(ICON_PrintTime, 15, 173);
   DWINUI::Draw_Icon(ICON_RemainTime, 150, 171);
   Draw_Print_ProgressBar();
   Draw_Print_ProgressElapsed();
   Draw_Print_ProgressRemain();
   ICON_Tune();
   ICON_ResumeOrPause();
   ICON_Stop();
-  DWIN_UpdateLCD();
 }
 
 void Goto_PrintProcess() {
-  if (checkkey == PrintProcess) {
+  if (checkkey == PrintProcess)
     ICON_ResumeOrPause();
-    DWIN_UpdateLCD();
-    return;
+  else {
+    checkkey = PrintProcess;
+    Draw_PrintProcess();
   }
-  checkkey = PrintProcess;
-  Draw_PrintProcess();
+  DWIN_UpdateLCD();
 }
 
 void Draw_PrintDone() {
   // show percent bar and value
   _percent_done = 100;
   _remain_time = 0;
 
   Title.ShowCaption(GET_TEXT_F(MSG_PRINT_DONE));
   DWINUI::ClearMenuArea();
   DWIN_Print_Header(nullptr);
   Draw_Print_ProgressBar();
   Draw_Print_Labels();
   DWINUI::Draw_Icon(ICON_PrintTime, 15, 173);
   DWINUI::Draw_Icon(ICON_RemainTime, 150, 171);
   Draw_Print_ProgressElapsed();
   Draw_Print_ProgressRemain();
   // show print done confirm
-  DWINUI::Draw_IconWB(HMI_IsChinese() ? ICON_Confirm_C : ICON_Confirm_E, 86, 273);
-  DWIN_UpdateLCD();
+  DWINUI::Draw_Button(BTN_Confirm, 86, 273);
+}
+
+void Goto_PrintDone() {
+  wait_for_user = true;
+  if (checkkey != PrintDone) {
+    checkkey = PrintDone;
+    Draw_PrintDone();
+    DWIN_UpdateLCD();
+  }
 }
 
 void Draw_Main_Menu() {
   DWINUI::ClearMenuArea();
   if (HMI_IsChinese())
     Title.FrameCopy(2, 2, 26, 13);   // "Home" etc
   else
     Title.ShowCaption(MACHINE_NAME);
   DWINUI::Draw_Icon(ICON_LOGO, 71, 52);  // CREALITY logo
+  DWIN_ResetStatusLine();
   ICON_Print();
   ICON_Prepare();
   ICON_Control();
   ICON_AdvSettings();
-  DWIN_UpdateLCD();
 }
 
 void Goto_Main_Menu() {
   if (checkkey == MainMenu) return;
   checkkey = MainMenu;
-  ui.reset_status(true);
   Draw_Main_Menu();
+  DWIN_UpdateLCD();
 }
 
 // Draw X, Y, Z and blink if in an un-homed or un-trusted state
 void _update_axis_value(const AxisEnum axis, const uint16_t x, const uint16_t y, const bool blink, const bool force) {
   const bool draw_qmark = axis_should_home(axis),
              draw_empty = NONE(HOME_AFTER_DEACTIVATE, DISABLE_REDUCED_ACCURACY_WARNING) && !draw_qmark && !axis_is_trusted(axis);
 
   // Check for a position change
   static xyz_pos_t oldpos = { -1, -1, -1 };
   const float p = current_position[axis];
   const bool changed = oldpos[axis] != p;
   if (changed) oldpos[axis] = p;
 
   if (force || changed || draw_qmark || draw_empty) {
     if (blink && draw_qmark)
-      DWINUI::Draw_String(HMI_data.Coordinate_Color, HMI_data.Background_Color, x, y, F(" - ? -"));
+      DWINUI::Draw_String(HMI_data.Coordinate_Color, HMI_data.Background_Color, x, y, F("  - ? -"));
     else if (blink && draw_empty)
-      DWINUI::Draw_String(HMI_data.Coordinate_Color, HMI_data.Background_Color, x, y, F("     "));
+      DWINUI::Draw_String(HMI_data.Coordinate_Color, HMI_data.Background_Color, x, y, F("       "));
     else
       DWINUI::Draw_Signed_Float(HMI_data.Coordinate_Color, HMI_data.Background_Color, 3, 2, x, y, p);
   }
 }
 
 void _draw_xyz_position(const bool force) {
   //SERIAL_ECHOPGM("Draw XYZ:");
   static bool _blink = false;
   const bool blink = !!(millis() & 0x400UL);
   if (force || blink != _blink) {
     _blink = blink;
     //SERIAL_ECHOPGM(" (blink)");
-    _update_axis_value(X_AXIS,  35, 459, blink, true);
-    _update_axis_value(Y_AXIS, 120, 459, blink, true);
-    _update_axis_value(Z_AXIS, 205, 459, blink, true);
+    _update_axis_value(X_AXIS,  27, 459, blink, true);
+    _update_axis_value(Y_AXIS, 112, 459, blink, true);
+    _update_axis_value(Z_AXIS, 197, 459, blink, true);
   }
   //SERIAL_EOL();
 }
 
 void update_variable() {
   #if HAS_HOTEND
     static celsius_t _hotendtemp = 0, _hotendtarget = 0;
     const celsius_t hc = thermalManager.wholeDegHotend(0),
                     ht = thermalManager.degTargetHotend(0);
     const bool _new_hotend_temp = _hotendtemp != hc,
@@ -845,21 +790,21 @@ void update_variable() {
   #if HAS_FAN
     if (_new_fanspeed) {
       _fanspeed = thermalManager.fan_speed[0];
       DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 195 + 2 * STAT_CHR_W, 384, _fanspeed);
     }
   #endif
 
   static float _offset = 0;
   if (BABY_Z_VAR != _offset) {
     _offset = BABY_Z_VAR;
-    DWINUI::Draw_Signed_Float(DWIN_FONT_STAT, HMI_data.Indicator_Color,  HMI_data.Background_Color, 2, 2, 210, 417, _offset);
+    DWINUI::Draw_Signed_Float(DWIN_FONT_STAT, HMI_data.Indicator_Color,  HMI_data.Background_Color, 2, 2, 204, 417, _offset);
   }
 
   #if HAS_MESH
     static bool _leveling_active = false;
     if (_leveling_active != planner.leveling_active) {
       _leveling_active = planner.leveling_active;
       DWIN_Draw_Box(1, HMI_data.Background_Color, 186, 416, 20, 20);
       if (_leveling_active)
         DWINUI::Draw_Icon(ICON_SetZOffset, 186, 416);
       else
@@ -901,29 +846,20 @@ void make_name_without_ext(char *dst, char *src, size_t maxlen=MENU_CHAR_LIMIT)
   }
 
   dst[len] = '\0';    // end it
 
   // Copy down to 0
   while (pos--) dst[pos] = src[pos];
 }
 
 void HMI_SDCardInit() { card.cdroot(); }
 
-// Initialize or re-initialize the LCD
-void MarlinUI::init_lcd() { DWIN_Startup(); }
-
-void MarlinUI::refresh() { /* Nothing to see here */ }
-
-#if HAS_LCD_BRIGHTNESS
-  void MarlinUI::_set_brightness() { DWIN_LCD_Brightness(backlight ? brightness : 0); }
-#endif
-
 #if ENABLED(SCROLL_LONG_FILENAMES)
 
   char shift_name[LONG_FILENAME_LENGTH + 1];
   int8_t shift_amt; // = 0
   millis_t shift_ms; // = 0
 
   // Init the shift name based on the highlighted item
   void Init_Shift_Name() {
     const bool is_subdir = !card.flag.workDirIsRoot;
     const int8_t filenum = select_file.now - 1 - is_subdir; // Skip "Back" and ".."
@@ -959,21 +895,22 @@ void Draw_SDItem(const uint16_t item, int16_t row=-1) {
     // This is used during scroll drawing
     if (item == select_file.now - 1) {
       make_name_without_ext(shift_name, name, 100);
       Init_SDItem_Shift();
     }
   #endif
 
   // Draw the file/folder with name aligned left
   char str[strlen(name) + 1];
   make_name_without_ext(str, name);
-  Draw_Menu_Line(row, card.flag.filenameIsDir ? ICON_Folder : ICON_File, str);
+  const uint8_t icon = card.flag.filenameIsDir ? ICON_Folder : card.fileIsBinary() ? ICON_Binary : ICON_File;
+  Draw_Menu_Line(row, icon, str);
 }
 
 #if ENABLED(SCROLL_LONG_FILENAMES)
 
   void Draw_SDItem_Shifted(uint8_t &shift) {
     // Limit to the number of chars past the cutoff
     const size_t len = strlen(shift_name);
     NOMORE(shift, _MAX(len - MENU_CHAR_LIMIT, 0U));
 
     // Shorten to the available space
@@ -1038,36 +975,33 @@ void HMI_SDCardUpdate() {
     if (DWIN_lcd_sd_status) {  // Media inserted
       if (checkkey == SelectFile)
         Redraw_SD_List();
     }
     else {    // Media removed
       // clean file icon
       if (checkkey == SelectFile) {
         Redraw_SD_List();
       }
       else if (sdprint && card.isPrinting() && printingIsActive()) {
-        // TODO: Move card removed abort handling
-        //       to CardReader::manage_media.
-        card.abortFilePrintSoon();
         wait_for_heatup = wait_for_user = false;
-        dwin_abort_flag = true; // Reset feedrate, return to Home
+        HMI_flag.abort_flag = true; // Abort print
       }
     }
     DWIN_UpdateLCD();
   }
 }
 
 //
-// The status area is always on-screen, except during
-// full-screen modal dialogs. (TODO: Keep alive during dialogs)
+// The Dashboard is always on-screen, except during
+// full-screen modal dialogs.
 //
-void Draw_Status_Area(const bool with_update) {
+void DWIN_Draw_Dashboard() {
 
   DWIN_Draw_Rectangle(1, HMI_data.Background_Color, 0, STATUS_Y + 21, DWIN_WIDTH, DWIN_HEIGHT - 1);
 
   #if HAS_HOTEND
     DWINUI::Draw_Icon(ICON_HotendTemp, 10, 383);
     DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 28, 384, thermalManager.wholeDegHotend(0));
     DWINUI::Draw_String(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 25 + 3 * STAT_CHR_W + 5, 384, F("/"));
     DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 25 + 4 * STAT_CHR_W + 6, 384, thermalManager.degTargetHotend(0));
 
     DWINUI::Draw_Icon(ICON_StepE, 112, 417);
@@ -1088,39 +1022,29 @@ void Draw_Status_Area(const bool with_update) {
 
   #if HAS_FAN
     DWINUI::Draw_Icon(ICON_FanSpeed, 187, 383);
     DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 195 + 2 * STAT_CHR_W, 384, thermalManager.fan_speed[0]);
   #endif
 
   #if HAS_ZOFFSET_ITEM
     DWINUI::Draw_Icon(planner.leveling_active ? ICON_SetZOffset : ICON_Zoffset, 187, 416);
   #endif
 
-  DWINUI::Draw_Signed_Float(DWIN_FONT_STAT, HMI_data.Indicator_Color,  HMI_data.Background_Color, 2, 2, 210, 417, BABY_Z_VAR);
+  DWINUI::Draw_Signed_Float(DWIN_FONT_STAT, HMI_data.Indicator_Color,  HMI_data.Background_Color, 2, 2, 204, 417, BABY_Z_VAR);
 
   DWIN_Draw_Rectangle(1, HMI_data.SplitLine_Color, 0, 449, DWIN_WIDTH, 451);
 
   DWINUI::Draw_Icon(ICON_MaxSpeedX,  10, 456);
   DWINUI::Draw_Icon(ICON_MaxSpeedY,  95, 456);
   DWINUI::Draw_Icon(ICON_MaxSpeedZ, 180, 456);
   _draw_xyz_position(true);
 
-  if (with_update) {
-    DWIN_UpdateLCD();
-    delay(5);
-  }
-}
-
-void HMI_StartFrame(const bool with_update) {
-  Goto_Main_Menu();
-  DWIN_DrawStatusLine(nullptr);
-  Draw_Status_Area(with_update);
 }
 
 void Draw_Info_Menu() {
   DWINUI::ClearMenuArea();
   Draw_Back_First();
   if (HMI_IsChinese())
     Title.FrameCopy(30, 17, 28, 13);                        // "Info"
   else
     Title.ShowCaption(GET_TEXT_F(MSG_INFO_SCREEN));
 
@@ -1136,22 +1060,20 @@ void Draw_Info_Menu() {
     DWINUI::Draw_CenteredString(248, F("Build Datetime"));
     DWINUI::Draw_CenteredString(268, F(STRING_DISTRIBUTION_DATE));
   }
   DWINUI::Draw_CenteredString(122, F(MACHINE_SIZE));
   DWINUI::Draw_CenteredString(195, F(SHORT_BUILD_VERSION));
 
   LOOP_L_N(i, 3) {
     DWINUI::Draw_Icon(ICON_PrintSize + i, ICOX, 99 + i * 73);
     DWIN_Draw_HLine(HMI_data.SplitLine_Color, 16, MBASE(2) + i * 73, 240);
   }
-
-  DWIN_UpdateLCD();
 }
 
 void Draw_Print_File_Menu() {
   if (HMI_IsChinese())
     Title.FrameCopy(0, 31, 56, 14);    // "Print file"
   else
     Title.ShowCaption(GET_TEXT_F(MSG_MEDIA_MENU));
   Redraw_SD_List();
 }
 
@@ -1159,47 +1081,45 @@ void Draw_Print_File_Menu() {
 void HMI_MainMenu() {
   EncoderState encoder_diffState = get_encoder_state();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
 
   if (encoder_diffState == ENCODER_DIFF_CW) {
     if (select_page.inc(PAGE_COUNT)) {
       switch (select_page.now) {
         case PAGE_PRINT: ICON_Print(); break;
         case PAGE_PREPARE: ICON_Print(); ICON_Prepare(); break;
         case PAGE_CONTROL: ICON_Prepare(); ICON_Control(); break;
-        case PAGE_INFO_LEV_ADV: ICON_Control(); ICON_AdvSettings(); break;
+        case PAGE_ADVANCE: ICON_Control(); ICON_AdvSettings(); break;
       }
     }
   }
   else if (encoder_diffState == ENCODER_DIFF_CCW) {
     if (select_page.dec()) {
       switch (select_page.now) {
         case PAGE_PRINT: ICON_Print(); ICON_Prepare(); break;
         case PAGE_PREPARE: ICON_Prepare(); ICON_Control(); break;
         case PAGE_CONTROL: ICON_Control(); ICON_AdvSettings(); break;
-        case PAGE_INFO_LEV_ADV: ICON_AdvSettings(); break;
+        case PAGE_ADVANCE: ICON_AdvSettings(); break;
       }
     }
   }
   else if (encoder_diffState == ENCODER_DIFF_ENTER) {
     switch (select_page.now) {
       case PAGE_PRINT:
         checkkey = SelectFile;
         card.mount();
+        delay(300);
         Draw_Print_File_Menu();
         break;
-
       case PAGE_PREPARE: Draw_Prepare_Menu(); break;
-
       case PAGE_CONTROL: Draw_Control_Menu(); break;
-
-      case PAGE_INFO_LEV_ADV: Draw_AdvancedSettings_Menu(); break;
+      case PAGE_ADVANCE: Draw_AdvancedSettings_Menu(); break;
     }
   }
   DWIN_UpdateLCD();
 }
 
 // Select (and Print) File
 void HMI_SelectFile() {
   EncoderState encoder_diffState = get_encoder_state();
 
   const uint16_t hasUpDir = !card.flag.workDirIsRoot;
@@ -1270,21 +1190,21 @@ void HMI_SelectFile() {
       else {
         Move_Highlight(-1, select_file.now + MROWS - index_file); // Just move highlight
         TERN_(SCROLL_LONG_FILENAMES, Init_Shift_Name());        // ...and init the shift name
       }
       TERN_(SCROLL_LONG_FILENAMES, Init_SDItem_Shift());        // Reset left. Init timer.
     }
   }
   else if (encoder_diffState == ENCODER_DIFF_ENTER) {
     if (select_file.now == 0) { // Back
       select_page.set(PAGE_PRINT);
-      Goto_Main_Menu();
+      return Goto_Main_Menu();
     }
     else if (hasUpDir && select_file.now == 1) { // CD-Up
       SDCard_Up();
       goto HMI_SelectFileExit;
     }
     else {
       const uint16_t filenum = select_file.now - 1 - hasUpDir;
       card.getfilename_sorted(SD_ORDER(filenum, card.get_num_Files()));
 
       // Enter that folder!
@@ -1294,37 +1214,41 @@ void HMI_SelectFile() {
       }
 
       // Reset highlight for next entry
       select_print.reset();
       select_file.reset();
 
       // Start choice and print SD file
       HMI_flag.heat_flag = true;
       HMI_flag.print_finish = false;
 
-      card.openAndPrintFile(card.filename);
-
-      #if HAS_FAN
-        // All fans on for Ender 3 v2 ?
-        // The slicer should manage this for us.
-        //for (uint8_t i = 0; i < FAN_COUNT; i++)
-        //  thermalManager.fan_speed[i] = 255;
-      #endif
-
-      DWIN_Print_Started(true);
+      if (card.fileIsBinary())
+        return DWIN_Popup_Confirm(ICON_Error, F("Please check filenames"), F("Only G-code can be printed"));
+      else
+        return Goto_ConfirmToPrint();
     }
   }
 
   HMI_SelectFileExit:
   DWIN_UpdateLCD();
 }
 
+// Pause or Stop popup
+void onClick_PauseOrStop() {
+  switch (select_print.now) {
+    case PRINT_PAUSE_RESUME: if (HMI_flag.select_flag) HMI_flag.pause_flag = true; break; // confirm pause
+    case PRINT_STOP: if (HMI_flag.select_flag) HMI_flag.abort_flag = true; break; // stop confirmed then abort print
+    default: break;
+  }
+  return Goto_PrintProcess();
+}
+
 // Printing
 void HMI_Printing() {
   EncoderState encoder_diffState = get_encoder_state();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
   // Avoid flicker by updating only the previous menu
   if (encoder_diffState == ENCODER_DIFF_CW) {
     if (select_print.inc(PRINT_COUNT)) {
       switch (select_print.now) {
         case PRINT_SETUP: ICON_Tune(); break;
         case PRINT_PAUSE_RESUME: ICON_Tune(); ICON_ResumeOrPause(); break;
@@ -1338,187 +1262,108 @@ void HMI_Printing() {
         case PRINT_SETUP: ICON_Tune(); ICON_ResumeOrPause(); break;
         case PRINT_PAUSE_RESUME: ICON_ResumeOrPause(); ICON_Stop(); break;
         case PRINT_STOP: ICON_Stop(); break;
       }
     }
   }
   else if (encoder_diffState == ENCODER_DIFF_ENTER) {
     switch (select_print.now) {
       case PRINT_SETUP: Draw_Tune_Menu(); break;
       case PRINT_PAUSE_RESUME:
-        if (HMI_flag.pause_flag) {
-          ICON_Pause();
-          #if DISABLED(ADVANCED_PAUSE_FEATURE)
-            char cmd[40];
-            cmd[0] = '\0';
-            #if BOTH(HAS_HEATED_BED, PAUSE_HEAT)
-              if (resume_bed_temp) sprintf_P(cmd, PSTR("M190 S%i\n"), resume_bed_temp);
-            #endif
-            #if BOTH(HAS_HOTEND, PAUSE_HEAT)
-              if (resume_hotend_temp) sprintf_P(&cmd[strlen(cmd)], PSTR("M109 S%i\n"), resume_hotend_temp);
-            #endif
-            #if HAS_FAN
-              if (resume_fan) thermalManager.fan_speed[0] = resume_fan;
-            #endif
-            strcat_P(cmd, M24_STR);
-            queue.inject(cmd);
-          #endif
-        }
-        else {
-          HMI_flag.select_flag = true;
-          checkkey = PauseOrStop;
-          Popup_window_PauseOrStop();
+        if (printingIsPaused()) {  // if printer is already in pause
+          ui.resume_print();
+          break;
         }
-        break;
-
+        else
+          return Goto_Popup(Popup_window_PauseOrStop, onClick_PauseOrStop);
       case PRINT_STOP:
-        HMI_flag.select_flag = true;
-        checkkey = PauseOrStop;
-        Popup_window_PauseOrStop();
-        break;
-
+        return Goto_Popup(Popup_window_PauseOrStop, onClick_PauseOrStop);
       default: break;
     }
   }
   DWIN_UpdateLCD();
 }
 
-// Print done
-void HMI_PrintDone() {
-  EncoderState encoder_diffState = get_encoder_state();
-  if (encoder_diffState == ENCODER_DIFF_NO) return;
-  if (encoder_diffState == ENCODER_DIFF_ENTER) {
-    dwin_abort_flag = true; // Reset feedrate, return to Home
-    Goto_Main_Menu(); // Return to Main menu after print done
-  }
-}
-
-// Pause or Stop popup
-void HMI_PauseOrStop() {
-  EncoderState encoder_diffState = get_encoder_state();
-  if (encoder_diffState == ENCODER_DIFF_NO) return;
-
-  if (encoder_diffState == ENCODER_DIFF_CW)
-    Draw_Select_Highlight(false);
-  else if (encoder_diffState == ENCODER_DIFF_CCW)
-    Draw_Select_Highlight(true);
-  else if (encoder_diffState == ENCODER_DIFF_ENTER) {
-    if (select_print.now == PRINT_PAUSE_RESUME) {
-      if (HMI_flag.select_flag) {
-        HMI_flag.pause_action = true;
-        ICON_Resume();
-        queue.inject(F("M25"));
-      }
-      else {
-        // cancel pause
-      }
-      Goto_PrintProcess();
-    }
-    else if (select_print.now == PRINT_STOP) {
-      if (HMI_flag.select_flag) {
-        checkkey = MainMenu;
-        if (HMI_flag.home_flag) planner.synchronize(); // Wait for planner moves to finish!
-        wait_for_heatup = wait_for_user = false;       // Stop waiting for heating/user
-        card.abortFilePrintSoon();                     // Let the main loop handle SD abort
-        dwin_abort_flag = true;                        // Reset feedrate, return to Home
-        #ifdef ACTION_ON_CANCEL
-          hostui.cancel();
-        #endif
-        DWIN_Draw_Popup(ICON_BLTouch, GET_TEXT_F(MSG_STOPPING), GET_TEXT_F(MSG_PLEASE_WAIT));
-      }
-      else
-        Goto_PrintProcess(); // cancel stop
-    }
-  }
-  DWIN_UpdateLCD();
-}
-
 #include "../../../libs/buzzer.h"
 
 void HMI_AudioFeedback(const bool success/*=true*/) {
   #if HAS_BUZZER
     if (success) {
       BUZZ(100, 659);
       BUZZ(10, 0);
       BUZZ(100, 698);
     }
     else
       BUZZ(40, 440);
   #endif
 }
 
 void Draw_Main_Area() {
   switch (checkkey) {
     case MainMenu:               Draw_Main_Menu(); break;
     case SelectFile:             Draw_Print_File_Menu(); break;
     case PrintProcess:           Draw_PrintProcess(); break;
     case PrintDone:              Draw_PrintDone(); break;
-    case Info:                   Draw_Info_Menu(); break;
     #if HAS_ESDIAG
       case ESDiagProcess:        Draw_EndStopDiag(); break;
     #endif
-    #if ENABLED(PRINTCOUNTER)
-      case PrintStatsProcess:    Draw_PrintStats(); break;
-    #endif
-    case PauseOrStop:            Popup_window_PauseOrStop(); break;
-    #if ENABLED(POWER_LOSS_RECOVERY)
-      case PwrlossRec:           Popup_PowerLossRecovery(); break;
-    #endif
-    #if ENABLED(ADVANCED_PAUSE_FEATURE)
-      case FilamentPurge:        Draw_Popup_FilamentPurge(); break;
-    #endif
+    case Popup:                  popupDraw(); break;
     case Locked:                 lockScreen.draw(); break;
-    #if HAS_GCODE_PREVIEW
-      case ConfirmToPrint:       Draw_PreviewFromSD(); break;
-    #endif
     case Menu:
     case SetInt:
     case SetPInt:
     case SetIntNoDraw:
     case SetFloat:
     case SetPFloat:              CurrentMenu->draw(); break;
     default: break;
   }
 }
 
 void HMI_ReturnScreen() {
   checkkey = last_checkkey;
   wait_for_user = false;
   Draw_Main_Area();
-  return;
 }
 
-void HMI_Popup() {
-  EncoderState encoder_diffState = get_encoder_state();
-  if (encoder_diffState == ENCODER_DIFF_NO) return;
-  if (encoder_diffState == ENCODER_DIFF_ENTER) {
-    HMI_ReturnScreen();
+void HMI_WaitForUser() {
+  get_encoder_state();
+  if (!wait_for_user) {
+    switch (checkkey) {
+      case PrintDone:
+        select_page.reset();
+        Goto_Main_Menu();
+        break;
+      #if HAS_ONESTEP_LEVELING
+      case Leveling:
+        //TERN_(ProUI, ProEx.StopLeveling());
+        HMI_ReturnScreen();
+        break;
+      #endif
+      default:
+        HMI_ReturnScreen();
+        break;
+    }
   }
 }
 
 void HMI_Init() {
-  HMI_SDCardInit();
+  DWINUI::Draw_Box(1, Color_Black, {5, 220, DWIN_WIDTH-5, DWINUI::fontHeight()});
+  DWINUI::Draw_CenteredString(Color_White, 220, F("Professional Firmware "));
   for (uint16_t t = 0; t <= 100; t += 2) {
     DWINUI::Draw_Icon(ICON_Bar, 15, 260);
     DWIN_Draw_Rectangle(1, HMI_data.Background_Color, 15 + t * 242 / 100, 260, 257, 280);
     DWIN_UpdateLCD();
     delay(20);
   }
   HMI_SetLanguage();
 }
 
-void DWIN_Update() {
-  EachMomentUpdate();   // Status update
-  HMI_SDCardUpdate();   // SD card update
-  DWIN_HandleScreen();  // Rotary encoder update
-}
-
 void EachMomentUpdate() {
   static millis_t next_var_update_ms = 0, next_rts_update_ms = 0, next_status_update_ms = 0;
 
   const millis_t ms = millis();
   if (ELAPSED(ms, next_var_update_ms)) {
     next_var_update_ms = ms + DWIN_VAR_UPDATE_INTERVAL;
     update_variable();
     switch (checkkey) {
       #if HAS_ESDIAG
         case ESDiagProcess:
@@ -1531,87 +1376,74 @@ void EachMomentUpdate() {
   }
 
   if (ELAPSED(ms, next_status_update_ms)) {
     next_status_update_ms = ms + 500;
     DWIN_DrawStatusMessage();
   }
 
   if (PENDING(ms, next_rts_update_ms)) return;
   next_rts_update_ms = ms + DWIN_SCROLL_UPDATE_INTERVAL;
 
-  if (checkkey == PrintProcess) {
+  if (checkkey == PrintProcess) { // print process
+
+    // Print pause
+    if (HMI_flag.pause_flag && !HMI_flag.home_flag) {
+      HMI_flag.pause_flag = false;
+      if (!HMI_flag.pause_action) {
+        HMI_flag.pause_action = true;
+        return ui.pause_print();
+      }
+    }
+
     // if print done
-    if (HMI_flag.print_finish) {
+    if (HMI_flag.print_finish && !HMI_flag.home_flag) {
       HMI_flag.print_finish = false;
-      TERN_(POWER_LOSS_RECOVERY, recovery.cancel());
-      planner.finish_and_disable();
-      checkkey = PrintDone;
-      Draw_PrintDone();
-    }
-    else if (HMI_flag.pause_flag != printingIsPaused()) {
-      // print status update
-      HMI_flag.pause_flag = printingIsPaused();
-      ICON_ResumeOrPause();
+      return DWIN_Print_Finished();
     }
-  }
 
-  // pause after homing
-  if (HMI_flag.pause_action && printingIsPaused() && !planner.has_blocks_queued()) {
-    HMI_flag.pause_action = false;
-    #if ENABLED(PAUSE_HEAT)
-      TERN_(HAS_HOTEND, resume_hotend_temp = sdprint ? thermalManager.degTargetHotend(0) : thermalManager.wholeDegHotend(0));
-      TERN_(HAS_HEATED_BED, resume_bed_temp = sdprint ? thermalManager.degTargetBed() : thermalManager.wholeDegBed());
-      TERN_(HAS_FAN, resume_fan = thermalManager.fan_speed[0]);
-    #endif
-    IF_DISABLED(ADVANCED_PAUSE_FEATURE, thermalManager.disable_all_heaters());
-    IF_DISABLED(PARK_HEAD_ON_PAUSE, queue.inject(F("G1 F1200 X0 Y0")));
-  }
-
-  if (checkkey == PrintProcess) { // print process
+    // if print was aborted
+    if (HMI_flag.abort_flag && !HMI_flag.home_flag) { // Print Stop
+      HMI_flag.abort_flag = false;
+      if (!HMI_flag.abort_action) {
+        HMI_flag.abort_action = true;
+        ui.abort_print();
+        return Goto_PrintDone();
+      }
+    }
 
     duration_t elapsed = print_job_timer.duration(); // print timer
 
     if (sdprint && card.isPrinting()) {
       uint8_t percentDone = card.percentDone();
-      static uint8_t last_percentValue = 101;
-      if (last_percentValue != percentDone) { // print percent
-        last_percentValue = percentDone;
-        if (percentDone) {
+      if (_percent_done != percentDone) { // print percent
           _percent_done = percentDone;
           Draw_Print_ProgressBar();
         }
-      }
 
       // Estimate remaining time every 20 seconds
       static millis_t next_remain_time_update = 0;
-      if (_percent_done > 1 && ELAPSED(ms, next_remain_time_update) && !HMI_flag.heat_flag) {
+      if (_percent_done > 1 && ELAPSED(ms, next_remain_time_update) && !HMI_flag.heat_flag && !HMI_flag.remain_flag) {
         _remain_time = (elapsed.value - dwin_heat_time) / (_percent_done * 0.01f) - (elapsed.value - dwin_heat_time);
         next_remain_time_update += DWIN_REMAIN_TIME_UPDATE_INTERVAL;
         Draw_Print_ProgressRemain();
       }
     }
 
     // Print time so far
     static uint16_t last_Printtime = 0;
     const uint16_t min = (elapsed.value % 3600) / 60;
     if (last_Printtime != min) { // 1 minute update
       last_Printtime = min;
       Draw_Print_ProgressElapsed();
     }
 
   }
-  else if (dwin_abort_flag && !HMI_flag.home_flag) { // Print Stop
-    dwin_abort_flag = false;
-    dwin_zoffset = BABY_Z_VAR;
-    select_page.set(PAGE_PRINT);
-    Goto_Main_Menu();
-  }
 
   #if ENABLED(POWER_LOSS_RECOVERY)
     else if (DWIN_lcd_sd_status && recovery.dwin_flag) { // resume print before power off
       return Goto_PowerLossRecovery();
     }
   #endif // POWER_LOSS_RECOVERY
 
   DWIN_UpdateLCD();
 }
 
@@ -1622,154 +1454,133 @@ void EachMomentUpdate() {
     if (HMI_IsChinese()) {
       DWIN_Frame_AreaCopy(1, 160, 338, 235, 354, 98, 115);
       DWIN_Frame_AreaCopy(1, 103, 321, 271, 335, 52, 167);
       DWINUI::Draw_IconWB(ICON_Cancel_C,    26, 280);
       DWINUI::Draw_IconWB(ICON_Continue_C, 146, 280);
     }
     else {
       DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 70, GET_TEXT_F(MSG_OUTAGE_RECOVERY));
       DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 147, F("It looks like the last"));
       DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 167, F("file was interrupted."));
-      DWINUI::Draw_IconWB(ICON_Cancel_E,    26, 280);
-      DWINUI::Draw_IconWB(ICON_Continue_E, 146, 280);
+      DWINUI::Draw_Button(BTN_Cancel,    26, 280);
+      DWINUI::Draw_Button(BTN_Continue, 146, 280);
     }
     SdFile *dir = nullptr;
     const char * const filename = card.diveToFile(true, dir, recovery.info.sd_filename);
     card.selectFileByName(filename);
     DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 207, card.longest_filename());
     Draw_Select_Highlight(HMI_flag.select_flag);
     DWIN_UpdateLCD();
   }
 
+  void onClick_PowerLossRecovery() {
+    if (HMI_flag.select_flag) {
+      queue.inject(F("M1000C"));
+      select_page.reset();
+      return Goto_Main_Menu();
+    }
+    else {
+      select_print.set(PRINT_SETUP);
+      queue.inject(F("M1000"));
+      sdprint = true;
+      return Goto_PrintProcess();
+    }
+  }
+
   void Goto_PowerLossRecovery() {
     recovery.dwin_flag = false;
     LCD_MESSAGE_F(GET_TEXT_F(MSG_CONTINUE_PRINT_JOB));
-    HMI_flag.select_flag = false;
-    Popup_PowerLossRecovery();
-    last_checkkey = MainMenu;
-    checkkey = PwrlossRec;
-  }
-
-  void HMI_PowerlossRecovery() {
-    EncoderState encoder_diffState = get_encoder_state();
-    if (encoder_diffState == ENCODER_DIFF_NO) return;
-    if (encoder_diffState == ENCODER_DIFF_ENTER) {
-      if (HMI_flag.select_flag) {
-        queue.inject(F("M1000C"));
-        select_page.reset();
-        Goto_Main_Menu();
-      }
-      else {
-        select_print.set(PRINT_SETUP);
-        queue.inject(F("M1000"));
-        sdprint = true;
-        Goto_PrintProcess();
-      }
-    }
-    else
-      Draw_Select_Highlight(encoder_diffState != ENCODER_DIFF_CW);
-    DWIN_UpdateLCD();
+    Goto_Popup(Popup_PowerLossRecovery, onClick_PowerLossRecovery);
   }
+
 #endif // POWER_LOSS_RECOVERY
 
 
 void DWIN_HandleScreen() {
   switch (checkkey) {
     case MainMenu:        HMI_MainMenu(); break;
     case Menu:            HMI_Menu(); break;
     case SetInt:          HMI_SetInt(); break;
     case SetPInt:         HMI_SetPInt(); break;
     case SetIntNoDraw:    HMI_SetIntNoDraw(); break;
     case SetFloat:        HMI_SetFloat(); break;
     case SetPFloat:       HMI_SetPFloat(); break;
     case SelectFile:      HMI_SelectFile(); break;
-    case Homing:          break;
-    case Leveling:        break;
     case PrintProcess:    HMI_Printing(); break;
-    case PrintDone:       HMI_PrintDone(); break;
-    case PauseOrStop:     HMI_PauseOrStop(); break;
-    case Info:            HMI_Popup(); break;
-    case WaitResponse:    HMI_Popup(); break;
-    #if ENABLED(ADVANCED_PAUSE_FEATURE)
-      case FilamentPurge: HMI_FilamentPurge(); break;
-    #endif
-    case NothingToDo:     break;
+    case Popup:           HMI_Popup(); break;
+    case Leveling:        //TERN_(ProUI, HMI_WaitForUser());
+                          break;
     case Locked:          HMI_LockScreen(); break;
-    #if ENABLED(POWER_LOSS_RECOVERY)
-      case PwrlossRec:    HMI_PowerlossRecovery(); break;
-    #endif
-    #if HAS_GCODE_PREVIEW
-      case ConfirmToPrint: HMI_ConfirmToPrint(); break;
-    #endif
-    #if HAS_ESDIAG
-      case ESDiagProcess: HMI_Popup(); break;
-    #endif
-    #if ENABLED(PRINTCOUNTER)
-      case PrintStatsProcess: HMI_Popup(); break;
-    #endif
+    case PrintDone:
+    TERN_(HAS_ESDIAG, case ESDiagProcess:)
+    case WaitResponse:    HMI_WaitForUser(); break;
+    case Homing:
+    case PidProcess:
+    case NothingToDo:     break;
     default: break;
   }
 }
 
 bool IDisPopUp() {    // If ID is popup...
-  return  (checkkey == NothingToDo) ||
-          (checkkey == WaitResponse) ||
-          (checkkey == Info) ||
-          (checkkey == Homing) ||
-          (checkkey == Leveling) ||
-          TERN_(HAS_ESDIAG, (checkkey == ESDiagProcess) ||)
-          TERN_(PRINTCOUNTER, (checkkey == PrintStatsProcess) ||)
-          (checkkey == PauseOrStop) ||
-          (checkkey == FilamentPurge);
+  return  (checkkey == NothingToDo)
+       || (checkkey == WaitResponse)
+       || (checkkey == Homing)
+       || (checkkey == Leveling)
+       || (checkkey == PidProcess)
+       || TERN0(HAS_ESDIAG, (checkkey == ESDiagProcess))
+       || (checkkey == Popup);
 }
 
 void HMI_SaveProcessID(const uint8_t id) {
   if (checkkey != id) {
     if (!IDisPopUp()) last_checkkey = checkkey; // if previous is not a popup
+    if ((id == Popup)
+         || TERN0(HAS_ESDIAG, (id == ESDiagProcess))
+         || (id == PrintDone)
+         || (id == Leveling)
+         || (id == WaitResponse)) wait_for_user = true;
     checkkey = id;
   }
 }
 
 void DWIN_StartHoming() {
   HMI_flag.home_flag = true;
   HMI_SaveProcessID(Homing);
-  Title.ShowCaption(GET_TEXT_F(MSG_LEVEL_BED_HOMING));
-  DWIN_Draw_Popup(ICON_BLTouch, GET_TEXT_F(MSG_LEVEL_BED_HOMING), GET_TEXT_F(MSG_PLEASE_WAIT));
+  Title.ShowCaption(GET_TEXT_F(MSG_HOMING));
+  DWIN_Show_Popup(ICON_BLTouch, GET_TEXT_F(MSG_HOMING), GET_TEXT_F(MSG_PLEASE_WAIT));
 }
 
 void DWIN_CompletedHoming() {
   HMI_flag.home_flag = false;
   dwin_zoffset = TERN0(HAS_BED_PROBE, probe.offset.z);
-  if (dwin_abort_flag) {
-    planner.finish_and_disable();
-  }
-  HMI_ReturnScreen();
+  if (HMI_flag.abort_action) DWIN_Print_Aborted(); else HMI_ReturnScreen();
 }
 
 void DWIN_MeshLevelingStart() {
   #if HAS_ONESTEP_LEVELING
     HMI_SaveProcessID(Leveling);
     Title.ShowCaption(GET_TEXT_F(MSG_BED_LEVELING));
-    DWIN_Show_Popup(ICON_AutoLeveling, GET_TEXT_F(MSG_BED_LEVELING), GET_TEXT_F(MSG_PLEASE_WAIT), ICON_Cancel_E);
+    DWIN_Show_Popup(ICON_AutoLeveling, GET_TEXT_F(MSG_BED_LEVELING), GET_TEXT_F(MSG_PLEASE_WAIT));
   #elif ENABLED(MESH_BED_LEVELING)
     Draw_ManualMesh_Menu();
   #endif
 }
 
-void DWIN_CompletedLeveling() { TERN_(HAS_MESH, DWIN_MeshViewer()); }
+void DWIN_CompletedLeveling() {
+  TERN_(HAS_ONESTEP_LEVELING, if (planner.leveling_active) Goto_MeshViewer());
+}
 
 #if HAS_MESH
-  void DWIN_MeshUpdate(const int8_t xpos, const int8_t ypos, const float zval) {
+  void DWIN_MeshUpdate(const int8_t xpos, const int8_t ypos, const_float_t zval) {
     char msg[33] = "";
     char str_1[6] = "";
-    sprintf_P(msg, PSTR(S_FMT " %i/%i Z=%s"), GET_TEXT(MSG_PROBING_POINT), xpos, ypos,
-      dtostrf(zval, 1, 2, str_1));
+    sprintf_P(msg, PSTR(S_FMT " %i/%i Z=%s"), GET_TEXT(MSG_PROBING_POINT), xpos, ypos, dtostrf(zval, 1, 2, str_1));
     ui.set_status(msg);
   }
 #endif
 
 // PID process
 void DWIN_PidTuning(pidresult_t result) {
   switch (result) {
     case PID_BED_START:
       HMI_SaveProcessID(NothingToDo);
       DWIN_Draw_Popup(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE), F("for BED is running."));
@@ -1793,81 +1604,77 @@ void DWIN_PidTuning(pidresult_t result) {
     case PID_DONE:
       checkkey = last_checkkey;
       DWIN_Popup_Confirm(ICON_TempTooLow, GET_TEXT_F(MSG_PID_AUTOTUNE), GET_TEXT_F(MSG_BUTTON_DONE));
       break;
     default:
       checkkey = last_checkkey;
       break;
   }
 }
 
-// Update filename on print
-void DWIN_Print_Header(const char *text = nullptr) {
-  static char headertxt[31] = "";  // Print header text
-
-  if (text) {
-    const int8_t size = _MIN((unsigned) 30, strlen_P(text));
-    LOOP_L_N(i, size) headertxt[i] = text[i];
-    headertxt[size] = '\0';
-  }
-  if (checkkey == PrintProcess || checkkey == PrintDone) {
-    DWIN_Draw_Rectangle(1, HMI_data.Background_Color, 0, 60, DWIN_WIDTH, 60+16);
-    DWINUI::Draw_CenteredString(60, headertxt);
-  }
-}
-
-void Draw_Title(TitleClass* title) {
-  DWIN_Draw_Rectangle(1, HMI_data.TitleBg_color, 0, 0, DWIN_WIDTH - 1, TITLE_HEIGHT - 1);
-  if (title->frameid)
-    DWIN_Frame_AreaCopy(title->frameid, title->frame.left, title->frame.top, title->frame.right, title->frame.bottom, 14, (TITLE_HEIGHT - (title->frame.bottom - title->frame.top)) / 2 - 1);
-  else
-    DWIN_Draw_String(false, DWIN_FONT_HEAD, HMI_data.TitleTxt_color, HMI_data.TitleBg_color, 14, (TITLE_HEIGHT - DWINUI::fontHeight(DWIN_FONT_HEAD)) / 2 - 1, title->caption);
-}
-
-void Draw_Menu(MenuClass* menu) {
-  DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color);
-  DWIN_Draw_Rectangle(1, DWINUI::backcolor, 0, TITLE_HEIGHT, DWIN_WIDTH - 1, STATUS_Y - 1);
-  DWIN_ResetStatusLine();
-}
-
-// Startup routines
-void DWIN_Startup() {
-  DWINUI::init();
-  DWINUI::onCursorDraw = Draw_Menu_Cursor;
-  DWINUI::onCursorErase = Erase_Menu_Cursor;
-  DWINUI::onTitleDraw = Draw_Title;
-  DWINUI::onMenuDraw = Draw_Menu;
-  DWIN_JPG_ShowAndCache(3);
-  HMI_SetLanguage();
-}
-
 // Started a Print Job
 void DWIN_Print_Started(const bool sd) {
-  sdprint = card.isPrinting() || sd;
+  sdprint = IS_SD_PRINTING() || sd;
   _percent_done = 0;
   _remain_time = 0;
+  HMI_flag.remain_flag = false;
+  HMI_flag.pause_flag = false;
+  HMI_flag.pause_action = false;
+  HMI_flag.abort_flag = false;
+  HMI_flag.abort_action = false;
   HMI_flag.print_finish = false;
   Goto_PrintProcess();
 }
 
+// Pause a print job
+void DWIN_Print_Pause() {
+  ICON_ResumeOrPause();
+}
+
+// Resume print job
+void DWIN_Print_Resume() {
+  HMI_flag.pause_action = false;
+  ICON_ResumeOrPause();
+  if (printJobOngoing()) {
+    LCD_MESSAGE(MSG_RESUME_PRINT);
+    Goto_PrintProcess();
+  }
+}
+
 // Ended print job
 void DWIN_Print_Finished() {
-  if (checkkey == PrintProcess || printingIsActive()) {
+  if (HMI_flag.abort_flag || checkkey == PrintDone) return;
+  TERN_(POWER_LOSS_RECOVERY, if (card.isPrinting()) recovery.cancel());
+  HMI_flag.pause_flag = false;
+  wait_for_heatup = false;
+  planner.finish_and_disable();
     thermalManager.cooldown();
-    HMI_flag.print_finish = true;
-  }
+  Goto_PrintDone();
+}
+
+// Print was aborted
+void DWIN_Print_Aborted() {
+  TERN_(DEBUG_DWIN, SERIAL_ECHOLNPGM("DWIN_Print_Aborted"));
+  HMI_flag.abort_action = false;
+  wait_for_heatup = false;
+  planner.finish_and_disable();
+  thermalManager.cooldown();
+  Goto_PrintDone();
 }
 
 // Progress Bar update
 void DWIN_Progress_Update() {
   if (parser.seenval('P')) _percent_done = parser.byteval('P');
-  if (parser.seenval('R')) _remain_time = parser.ulongval('R') * 60;
+  if (parser.seenval('R')) {
+    _remain_time = parser.ulongval('R') * 60;
+    HMI_flag.remain_flag = true;
+  }
   if (checkkey == PrintProcess) {
     Draw_Print_ProgressBar();
     Draw_Print_ProgressRemain();
     Draw_Print_ProgressElapsed();
   }
 }
 
 #if HAS_FILAMENT_SENSOR
   // Filament Runout process
   void DWIN_FilamentRunout(const uint8_t extruder) { LCD_MESSAGE(MSG_RUNOUT_SENSOR); }
@@ -1889,129 +1696,161 @@ void DWIN_SetColorDefaults() {
   HMI_data.AlertBg_Color    = Def_AlertBg_Color;
   HMI_data.AlertTxt_Color   = Def_AlertTxt_Color;
   HMI_data.PercentTxt_Color = Def_PercentTxt_Color;
   HMI_data.Barfill_Color    = Def_Barfill_Color;
   HMI_data.Indicator_Color  = Def_Indicator_Color;
   HMI_data.Coordinate_Color = Def_Coordinate_Color;
 }
 
 void DWIN_SetDataDefaults() {
   DWIN_SetColorDefaults();
-  DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color);
-  TERN_(HAS_HOTEND,             HMI_data.HotendPidT = PREHEAT_1_TEMP_HOTEND);
-  TERN_(HAS_HEATED_BED,         HMI_data.BedPidT    = PREHEAT_1_TEMP_BED);
-  TERN_(HAS_HOTEND,             HMI_data.PidCycles  = 5);
-  TERN_(PREVENT_COLD_EXTRUSION, HMI_data.ExtMinT    = EXTRUDE_MINTEMP);
+  DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color, HMI_data.StatusBg_Color);
+  TERN_(HAS_HOTEND,     HMI_data.HotendPidT = PREHEAT_1_TEMP_HOTEND);
+  TERN_(HAS_HEATED_BED, HMI_data.BedPidT    = PREHEAT_1_TEMP_BED);
+  TERN_(HAS_HOTEND,     HMI_data.PidCycles  = 5);
+  #if ENABLED(PREVENT_COLD_EXTRUSION)
+    HMI_data.ExtMinT = EXTRUDE_MINTEMP;
+    ApplyExtMinT();
+  #endif
+  #if BOTH(HAS_HEATED_BED, PREHEAT_BEFORE_LEVELING)
+    HMI_data.BedLevT = PREHEAT_1_TEMP_BED;
+  #endif
+  TERN_(BAUD_RATE_GCODE, SetBaud250K());
 }
 
 void DWIN_StoreSettings(char *buff) {
   memcpy(buff, &HMI_data, _MIN(sizeof(HMI_data), eeprom_data_size));
 }
 
 void DWIN_LoadSettings(const char *buff) {
   // (void *)-> Avoid Warning when save data different from uintX_t in HMI_data_t struct
   memcpy((void *)&HMI_data, buff, _MIN(sizeof(HMI_data), eeprom_data_size));
   dwin_zoffset = TERN0(HAS_BED_PROBE, probe.offset.z);
   if (HMI_data.Text_Color == HMI_data.Background_Color) DWIN_SetColorDefaults();
-  DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color);
+  DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color, HMI_data.StatusBg_Color);
   TERN_(PREVENT_COLD_EXTRUSION, ApplyExtMinT());
   feedrate_percentage = 100;
+  TERN_(BAUD_RATE_GCODE, HMI_SetBaudRate());
   #if BOTH(CASE_LIGHT_MENU, CASELIGHT_USES_BRIGHTNESS)
     // Apply Case light brightness
     caselight.brightness = HMI_data.CaseLight_Brightness;
     caselight.update_brightness();
   #endif
   #if BOTH(LED_CONTROL_MENU, HAS_COLOR_LEDS)
     // Apply Led Color
     leds.set_color(HMI_data.Led_Color);
   #endif
 }
 
+// Initialize or re-initialize the LCD
+void MarlinUI::init_lcd() {
+  TERN_(DEBUG_DWIN, SERIAL_ECHOLNPGM("DWIN_Startup"));
+  DWINUI::init();
+  DWIN_JPG_CacheTo1(Language_English);
+  Encoder_Configuration();
+}
+
+void DWIN_InitScreen() {
+  HMI_Init();   // draws boot screen
+  DWINUI::onCursorDraw = Draw_Menu_Cursor;
+  DWINUI::onCursorErase = Erase_Menu_Cursor;
+  DWINUI::onTitleDraw = Draw_Title;
+  DWINUI::onMenuDraw = Draw_Menu;
+  DWIN_DrawStatusLine(nullptr);
+  DWIN_Draw_Dashboard();
+  Goto_Main_Menu();
+}
+
+void MarlinUI::update() {
+  EachMomentUpdate();   // Status update
+  HMI_SDCardUpdate();   // SD card update
+  DWIN_HandleScreen();  // Rotary encoder update
+}
+
+void MarlinUI::refresh() { /* Nothing to see here */ }
+
+#if HAS_LCD_BRIGHTNESS
+  void MarlinUI::_set_brightness() { DWIN_LCD_Brightness(backlight ? brightness : 0); }
+#endif
+
 void MarlinUI::kill_screen(FSTR_P const lcd_error, FSTR_P const lcd_component) {
   DWIN_Draw_Popup(ICON_BLTouch, F("Printer killed:"), lcd_error);
   DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 270, F("Turn off the printer"));
   DWIN_UpdateLCD();
 }
 
 void DWIN_RebootScreen() {
   DWIN_Frame_Clear(Color_Bg_Black);
   DWIN_JPG_ShowAndCache(0);
   DWINUI::Draw_CenteredString(Color_White, 220, GET_TEXT_F(MSG_PLEASE_WAIT_REBOOT));
   DWIN_UpdateLCD();
   delay(500);
-  DWIN_JPG_ShowAndCache(3);
 }
 
 void DWIN_Redraw_screen() {
   Draw_Main_Area();
-  Draw_Status_Area(false);
+  hash_changed = true;
+  DWIN_DrawStatusMessage();
+  DWIN_Draw_Dashboard();
 }
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
-
-  void DWIN_Popup_Pause(FSTR_P const fmsg, uint8_t button = 0) {
+  void DWIN_Popup_Pause(FSTR_P const fmsg, uint8_t button /*= 0*/) {
     HMI_SaveProcessID(button ? WaitResponse : NothingToDo);
-    DWIN_Draw_Popup(ICON_BLTouch, GET_TEXT_F(MSG_ADVANCED_PAUSE), fmsg, button);
-    ui.reset_status(true);
+    DWIN_Show_Popup(ICON_BLTouch, GET_TEXT_F(MSG_ADVANCED_PAUSE), fmsg, button);
   }
 
   void MarlinUI::pause_show_message(const PauseMessage message, const PauseMode mode/*=PAUSE_MODE_SAME*/, const uint8_t extruder/*=active_extruder*/) {
+    //if (mode == PAUSE_MODE_SAME) return;
+    pause_mode = mode;
     switch (message) {
-      case PAUSE_MESSAGE_PARKING:  DWIN_Popup_Pause(GET_TEXT_F(MSG_PAUSE_PRINT_PARKING));    break;
-      case PAUSE_MESSAGE_CHANGING: DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_INIT));   break;
-      case PAUSE_MESSAGE_UNLOAD:   DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_UNLOAD)); break;
-      case PAUSE_MESSAGE_WAITING:  DWIN_Popup_Pause(GET_TEXT_F(MSG_ADVANCED_PAUSE_WAITING), ICON_Continue_E); break;
+      case PAUSE_MESSAGE_PARKING:  DWIN_Popup_Pause(GET_TEXT_F(MSG_PAUSE_PRINT_PARKING));    break;                                     // M125
+      case PAUSE_MESSAGE_CHANGING: DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_INIT));   break;                                     // pause_print (M125, M600)
+      case PAUSE_MESSAGE_WAITING:  DWIN_Popup_Pause(GET_TEXT_F(MSG_ADVANCED_PAUSE_WAITING), BTN_Continue); break;
       case PAUSE_MESSAGE_INSERT:   DWIN_Popup_Continue(ICON_BLTouch, GET_TEXT_F(MSG_ADVANCED_PAUSE), GET_TEXT_F(MSG_FILAMENT_CHANGE_INSERT)); break;
       case PAUSE_MESSAGE_LOAD:     DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_LOAD));   break;
-      case PAUSE_MESSAGE_PURGE:    DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_PURGE));  break;
-      case PAUSE_MESSAGE_OPTION:   DWIN_Popup_FilamentPurge(); break;
+      case PAUSE_MESSAGE_UNLOAD:   DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_UNLOAD)); break;                                     // Unload of pause and Unload of M702
+      case PAUSE_MESSAGE_PURGE:
+        #if ENABLED(ADVANCED_PAUSE_CONTINUOUS_PURGE)
+          DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_CONT_PURGE));
+        #else
+          DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_PURGE));
+        #endif
+        break;
+      case PAUSE_MESSAGE_OPTION:   Goto_FilamentPurge(); break;
       case PAUSE_MESSAGE_RESUME:   DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_RESUME)); break;
-      case PAUSE_MESSAGE_HEAT:     DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_HEAT), ICON_Continue_E);   break;
+      case PAUSE_MESSAGE_HEAT:     DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_HEAT), BTN_Continue);   break;
       case PAUSE_MESSAGE_HEATING:  LCD_MESSAGE(MSG_FILAMENT_CHANGE_HEATING); break;
-      case PAUSE_MESSAGE_STATUS:   HMI_ReturnScreen(); break;
+      case PAUSE_MESSAGE_STATUS:   HMI_ReturnScreen(); break;                                                                         // Exit from Pause, Load and Unload
       default: break;
     }
   }
 
   void Draw_Popup_FilamentPurge() {
     DWIN_Draw_Popup(ICON_BLTouch, GET_TEXT_F(MSG_ADVANCED_PAUSE), F("Purge or Continue?"));
-    DWINUI::Draw_IconWB(ICON_Confirm_E, 26, 280);
-    DWINUI::Draw_IconWB(ICON_Continue_E, 146, 280);
+    DWINUI::Draw_Button(BTN_Confirm, 26, 280);
+    DWINUI::Draw_Button(BTN_Continue, 146, 280);
     Draw_Select_Highlight(true);
-    DWIN_UpdateLCD();
-  }
-
-  // Handle responses such as:
-  //  - Purge More, Continue
-  //  - General "Continue" response
-  void DWIN_Popup_FilamentPurge() {
-    HMI_SaveProcessID(FilamentPurge);
-    pause_menu_response = PAUSE_RESPONSE_WAIT_FOR;
-    Draw_Popup_FilamentPurge();
   }
 
-  void HMI_FilamentPurge() {
-    EncoderState encoder_diffState = get_encoder_state();
-    if (encoder_diffState == ENCODER_DIFF_NO) return;
-    if (encoder_diffState == ENCODER_DIFF_CW)
-      Draw_Select_Highlight(false);
-    else if (encoder_diffState == ENCODER_DIFF_CCW)
-      Draw_Select_Highlight(true);
-    else if (encoder_diffState == ENCODER_DIFF_ENTER) {
+  void onClick_FilamentPurge() {
       if (HMI_flag.select_flag)
         pause_menu_response = PAUSE_RESPONSE_EXTRUDE_MORE;  // "Purge More" button
       else {
         HMI_SaveProcessID(NothingToDo);
         pause_menu_response = PAUSE_RESPONSE_RESUME_PRINT;  // "Continue" button
       }
     }
-    DWIN_UpdateLCD();
+
+  void Goto_FilamentPurge() {
+    pause_menu_response = PAUSE_RESPONSE_WAIT_FOR;
+    Goto_Popup(Draw_Popup_FilamentPurge, onClick_FilamentPurge);
   }
 
 #endif // ADVANCED_PAUSE_FEATURE
 
 #if HAS_MESH
   void DWIN_MeshViewer() {
     if (!leveling_is_valid())
       DWIN_Popup_Continue(ICON_BLTouch, GET_TEXT_F(MSG_MESH_VIEWER), GET_TEXT_F(MSG_NO_VALID_MESH));
     else {
       HMI_SaveProcessID(WaitResponse);
@@ -2035,159 +1874,38 @@ void DWIN_UnLockScreen() {
   }
 }
 
 void HMI_LockScreen() {
   EncoderState encoder_diffState = get_encoder_state();
   if (encoder_diffState == ENCODER_DIFF_NO) return;
   lockScreen.onEncoder(encoder_diffState);
   if (lockScreen.isUnlocked()) DWIN_UnLockScreen();
 }
 
-#if HAS_GCODE_PREVIEW
-
-  void HMI_ConfirmToPrint() {
-    EncoderState encoder_diffState = get_encoder_state();
-    if (encoder_diffState == ENCODER_DIFF_NO) return;
-    if (encoder_diffState == ENCODER_DIFF_CW)
-      Draw_Select_Highlight(false);
-    else if (encoder_diffState == ENCODER_DIFF_CCW)
-      Draw_Select_Highlight(true);
-    else if (encoder_diffState == ENCODER_DIFF_ENTER) {
-      if (HMI_flag.select_flag) {     // Confirm
-        card.openAndPrintFile(card.filename);
-        DWIN_Print_Started(true);
-      }
-      else {                          // Cancel
-        DWIN_ResetStatusLine();
-        checkkey = SelectFile;
-        Draw_Print_File_Menu();
-      }
-    }
-    DWIN_UpdateLCD();
-  }
-
-#endif
 
 void Goto_ConfirmToPrint() {
-  #if HAS_GCODE_PREVIEW
-    HMI_SaveProcessID(ConfirmToPrint);
-    Draw_PreviewFromSD();
-  #else
-    card.openAndPrintFile(card.filename);
-    DWIN_Print_Started(true);
-  #endif
+  card.openAndPrintFile(card.filename);
+  DWIN_Print_Started(true);
 }
 
 #if HAS_ESDIAG
   void Draw_EndStopDiag() {
     HMI_SaveProcessID(ESDiagProcess);
     ESDiag.Draw();
   }
 #endif
 
-#if ENABLED(PRINTCOUNTER)
-  void Draw_PrintStats() {
-    HMI_SaveProcessID(PrintStatsProcess);
-    PrintStats.Draw();
-  }
-#endif
-
 //=============================================================================
 // NEW MENU SUBSYSTEM
 //=============================================================================
 
-// On click functions
-
-// Generic onclick event without draw anything
-//  process: process id HMI destiny
-//  lo: low limit
-//  hi: high limit
-//  dp: decimal places, 0 for integers
-//  val: value / scaled value
-//  LiveUpdate: live update function when the encoder changes
-//  Apply: update function when the encoder is pressed
-void SetOnClick(uint8_t process, const int32_t lo, const int32_t hi, uint8_t dp, const int32_t val, void (*Apply)() = nullptr, void (*LiveUpdate)() = nullptr) {
-  checkkey = process;
-  HMI_value.MinValue = lo;
-  HMI_value.MaxValue = hi;
-  HMI_value.dp = dp;
-  HMI_value.Apply = Apply;
-  HMI_value.LiveUpdate = LiveUpdate;
-  HMI_value.Value = val;
-  EncoderRate.enabled = true;
-}
-
-// Generic onclick event for integer values
-//  process: process id HMI destiny
-//  lo: scaled low limit
-//  hi: scaled high limit
-//  val: value
-//  LiveUpdate: live update function when the encoder changes
-//  Apply: update function when the encoder is pressed
-void SetValueOnClick(uint8_t process, const int32_t lo, const int32_t hi, const int32_t val, void (*Apply)() = nullptr, void (*LiveUpdate)() = nullptr) {
-  SetOnClick(process, lo, hi, 0, val, Apply, LiveUpdate);
-  Draw_Menu_IntValue(HMI_data.Selected_Color, CurrentMenu->line(), 4, HMI_value.Value);
-}
-
-// Generic onclick event for float values
-//  process: process id HMI destiny
-//  lo: scaled low limit
-//  hi: scaled high limit
-//  val: value
-//  LiveUpdate: live update function when the encoder changes
-//  Apply: update function when the encoder is pressed
-void SetValueOnClick(uint8_t process, const float lo, const float hi, uint8_t dp, const float val, void (*Apply)() = nullptr, void (*LiveUpdate)() = nullptr) {
-  const int32_t value =  round(val * POW(10, dp));
-  SetOnClick(process, lo * POW(10, dp), hi * POW(10, dp), dp, value, Apply, LiveUpdate);
-  DWINUI::Draw_Signed_Float(HMI_data.Text_Color, HMI_data.Selected_Color, 3, dp, VALX - dp * DWINUI::fontWidth(DWIN_FONT_MENU), MBASE(CurrentMenu->line()), val);
-}
-
-// Generic onclick event for integer values
-//  lo: scaled low limit
-//  hi: scaled high limit
-//  val: value
-//  LiveUpdate: live update function when the encoder changes
-//  Apply: update function when the encoder is pressed
-inline void SetIntOnClick(const int32_t lo, const int32_t hi, const int32_t val, void (*Apply)() = nullptr, void (*LiveUpdate)() = nullptr) {
-  SetValueOnClick(SetInt, lo, hi, val, Apply, LiveUpdate);
-}
-
-// Generic onclick event for set pointer to 16 bit uinteger values
-//  lo: low limit
-//  hi: high limit
-//  LiveUpdate: live update function when the encoder changes
-//  Apply: update function when the encoder is pressed
-void SetPIntOnClick(const int32_t lo, const int32_t hi, void (*Apply)() = nullptr, void (*LiveUpdate)() = nullptr) {
-  HMI_value.P_Int = (int16_t*)static_cast<MenuItemPtrClass*>(CurrentMenu->SelectedItem())->value;
-  const int32_t value = *HMI_value.P_Int;
-  SetValueOnClick(SetPInt, lo, hi, value, Apply, LiveUpdate);
-}
-
-// Generic onclick event for float values
-//  process: process id HMI destiny
-//  lo: low limit
-//  hi: high limit
-//  dp: decimal places
-//  val: value
-inline void SetFloatOnClick(const float lo, const float hi, uint8_t dp, const float val, void (*Apply)() = nullptr, void (*LiveUpdate)() = nullptr) {
-  SetValueOnClick(SetFloat, lo, hi, dp, val, Apply, LiveUpdate);
-}
-
-// Generic onclick event for set pointer to float values
-//  lo: low limit
-//  hi: high limit
-//  LiveUpdate: live update function when the encoder changes
-//  Apply: update function when the encoder is pressed
-void SetPFloatOnClick(const float lo, const float hi, uint8_t dp, void (*Apply)() = nullptr, void (*LiveUpdate)() = nullptr) {
-  HMI_value.P_Float = (float*)static_cast<MenuItemPtrClass*>(CurrentMenu->SelectedItem())->value;
-  SetValueOnClick(SetPFloat, lo, hi, dp, *HMI_value.P_Float, Apply, LiveUpdate);
-}
+// Tool functions
 
 #if ENABLED(EEPROM_SETTINGS)
   void WriteEeprom() {
     const bool success = settings.save();
     HMI_AudioFeedback(success);
   }
 
   void ReadEeprom() {
     const bool success = settings.load();
     DWIN_Redraw_screen();
@@ -2196,138 +1914,132 @@ void SetPFloatOnClick(const float lo, const float hi, uint8_t dp, void (*Apply)(
 
   void ResetEeprom() {
     settings.reset();
     DWIN_Redraw_screen();
     HMI_AudioFeedback();
   }
 #endif
 
 // Reset Printer
 void RebootPrinter() {
-  dwin_abort_flag = true;
   wait_for_heatup = wait_for_user = false;    // Stop waiting for heating/user
   thermalManager.disable_all_heaters();
   planner.finish_and_disable();
   DWIN_RebootScreen();
   hal.reboot();
 }
 
 void Goto_Info_Menu(){
-  HMI_SaveProcessID(Info);
   Draw_Info_Menu();
+  HMI_SaveProcessID(WaitResponse);
 }
 
 void Goto_Move_Menu() {
   #if HAS_HOTEND
     gcode.process_subcommands_now(F("G92E0"));  // reset extruder position
     planner.synchronize();
   #endif
   Draw_Move_Menu();
 }
 
 void DisableMotors() { queue.inject(F("M84")); }
 
-void AutoLev() { queue.inject(F("G28Z\nG29")); }  // Force to get the current Z home position
+void AutoLev() { queue.inject(F("G28XYO\nG28Z\nG29")); }  // Force to get the current Z home position
 
 void AutoHome() { queue.inject_P(G28_STR); }
-
 void HomeX() { queue.inject(F("G28X")); }
-
 void HomeY() { queue.inject(F("G28Y")); }
-
 void HomeZ() { queue.inject(F("G28Z")); }
 
 void SetHome() {
   // Apply workspace offset, making the current position 0,0,0
   queue.inject(F("G92 X0 Y0 Z0"));
   HMI_AudioFeedback();
 }
 
 #if HAS_ZOFFSET_ITEM
   bool printer_busy() { return planner.movesplanned() || printingIsActive(); }
   void ApplyZOffset() { TERN_(EEPROM_SETTINGS, settings.save()); }
   void LiveZOffset() {
     last_zoffset = dwin_zoffset;
-    dwin_zoffset = HMI_value.Value / 100.0f;
+    dwin_zoffset = MenuData.Value / 100.0f;
     #if EITHER(BABYSTEP_ZPROBE_OFFSET, JUST_BABYSTEP)
       if (BABYSTEP_ALLOWED()) babystep.add_mm(Z_AXIS, dwin_zoffset - last_zoffset);
     #endif
   }
   #if EITHER(HAS_BED_PROBE, BABYSTEPPING)
     void SetZOffset() {
       SetPFloatOnClick(Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX, 2, ApplyZOffset, LiveZOffset);
     }
   #endif
+
+  void SetMoveZto0() {
+    char cmd[48] = "";
+    char str_1[5] = "", str_2[5] = "";
+    sprintf_P(cmd, PSTR("G28XYO\nG28Z\nG0X%sY%sF5000\nM420S0\nG0Z0F300"),
+      #if ENABLED(MESH_BED_LEVELING)
+        dtostrf(0, 1, 1, str_1),
+        dtostrf(0, 1, 1, str_2)
+      #else
+        dtostrf(X_CENTER, 1, 1, str_1),
+        dtostrf(Y_CENTER, 1, 1, str_2)
+      #endif
+    );
+    gcode.process_subcommands_now(cmd);
+    planner.synchronize();
+    LCD_MESSAGE_F("Now adjust Z Offset");
+    HMI_AudioFeedback(true);
+  }
 #endif
 
 #if HAS_PREHEAT
   void DoPreheat0() { ui.preheat_all(0); }
   void DoPreheat1() { ui.preheat_all(1); }
   void DoPreheat2() { ui.preheat_all(2); }
 #endif
 
 void DoCoolDown() { thermalManager.cooldown(); }
 
 void SetLanguage() {
   HMI_ToggleLanguage();
   CurrentMenu = nullptr;  // Invalidate menu to full redraw
   Draw_Prepare_Menu();
 }
 
 void LiveMove() {
-  *HMI_value.P_Float = HMI_value.Value / MINUNITMULT;
+  *MenuData.P_Float = MenuData.Value / MINUNITMULT;
   if (!planner.is_full()) {
     planner.synchronize();
     planner.buffer_line(current_position, homing_feedrate(HMI_value.axis));
   }
 }
 void ApplyMoveE() {
-  last_E = HMI_value.Value / MINUNITMULT;
+  last_E = MenuData.Value / MINUNITMULT;
   if (!planner.is_full()) {
     planner.synchronize();
     planner.buffer_line(current_position, MMM_TO_MMS(FEEDRATE_E));
   }
 }
 void SetMoveX() { HMI_value.axis = X_AXIS; SetPFloatOnClick(X_MIN_POS, X_MAX_POS, UNITFDIGITS, planner.synchronize, LiveMove);}
 void SetMoveY() { HMI_value.axis = Y_AXIS; SetPFloatOnClick(Y_MIN_POS, Y_MAX_POS, UNITFDIGITS, planner.synchronize, LiveMove);}
 void SetMoveZ() { HMI_value.axis = Z_AXIS; SetPFloatOnClick(Z_MIN_POS, Z_MAX_POS, UNITFDIGITS, planner.synchronize, LiveMove);}
 
 #if HAS_HOTEND
   void SetMoveE() {
     #if ENABLED(PREVENT_COLD_EXTRUSION)
-      if (thermalManager.tooColdToExtrude(0)) {
-        Popup_Window_ETempTooLow();
-        return;
-      }
+      if (thermalManager.tooColdToExtrude(0))
+        return DWIN_Popup_Confirm(ICON_TempTooLow, GET_TEXT_F(MSG_HOTEND_TOO_COLD), GET_TEXT_F(MSG_PLEASE_PREHEAT));
     #endif
     SetPFloatOnClick(last_E - (EXTRUDE_MAXLENGTH), last_E + (EXTRUDE_MAXLENGTH), UNITFDIGITS, ApplyMoveE);
   }
 #endif
 
-void SetMoveZto0() {
-  char cmd[48] = "";
-  char str_1[5] = "", str_2[5] = "";
-  sprintf_P(cmd, PSTR("G28Z\nG0X%sY%sF5000\nM420S0\nG0Z0F300"),
-    #if ENABLED(MESH_BED_LEVELING)
-      dtostrf(0, 1, 1, str_1),
-      dtostrf(0, 1, 1, str_2)
-    #else
-      dtostrf(X_CENTER, 1, 1, str_1),
-      dtostrf(Y_CENTER, 1, 1, str_2)
-    #endif
-  );
-  gcode.process_subcommands_now(cmd);
-  planner.synchronize();
-  LCD_MESSAGE_F("Now adjust Z Offset");
-  HMI_AudioFeedback(true);
-}
-
 void SetPID(celsius_t t, heater_id_t h) {
   char cmd[48] = "";
   char str_1[5] = "", str_2[5] = "";
   sprintf_P(cmd, PSTR("G28OXY\nG0Z5F300\nG0X%sY%sF5000\nM84"),
     dtostrf(X_CENTER, 1, 1, str_1),
     dtostrf(Y_CENTER, 1, 1, str_2)
   );
   gcode.process_subcommands_now(cmd);
   planner.synchronize();
   thermalManager.PID_autotune(t, h, HMI_data.PidCycles, true);
@@ -2340,71 +2052,85 @@ void SetPID(celsius_t t, heater_id_t h) {
 #endif
 
 #if ENABLED(POWER_LOSS_RECOVERY)
   void SetPwrLossr() {
     recovery.enable(!recovery.enabled);
     Draw_Chkb_Line(CurrentMenu->line(), recovery.enabled);
     DWIN_UpdateLCD();
   }
 #endif
 
+#if ENABLED(BAUD_RATE_GCODE)
+  void HMI_SetBaudRate() {
+    if (HMI_data.Baud115K) SetBaud115K(); else SetBaud250K();
+  }
+  void SetBaudRate() {
+    HMI_SetBaudRate();
+    Draw_Chkb_Line(CurrentMenu->line(), HMI_data.Baud115K);
+    DWIN_UpdateLCD();
+  }
+  void SetBaud115K() { queue.inject(F("M575 P0 B115200")); HMI_data.Baud115K = true; }
+  void SetBaud250K() { queue.inject(F("M575 P0 B250000")); HMI_data.Baud115K = false; }
+#endif
+
 #if HAS_LCD_BRIGHTNESS
-  void ApplyBrightness() { ui.set_brightness(HMI_value.Value); }
-  void LiveBrightness() { DWIN_LCD_Brightness(HMI_value.Value); }
+  void ApplyBrightness() { ui.set_brightness(MenuData.Value); }
+  void LiveBrightness() { DWIN_LCD_Brightness(MenuData.Value); }
   void SetBrightness() { SetIntOnClick(LCD_BRIGHTNESS_MIN, LCD_BRIGHTNESS_MAX, ui.brightness, ApplyBrightness, LiveBrightness); }
+  void TurnOffBacklight() { HMI_SaveProcessID(WaitResponse); ui.set_brightness(0); DWIN_Redraw_screen(); }
 #endif
 
 #if ENABLED(CASE_LIGHT_MENU)
   void SetCaseLight() {
     caselight.on = !caselight.on;
     caselight.update_enabled();
     Draw_Chkb_Line(CurrentMenu->line(), caselight.on);
     DWIN_UpdateLCD();
   }
   #if ENABLED(CASELIGHT_USES_BRIGHTNESS)
-    void LiveCaseLightBrightness() { HMI_data.CaseLight_Brightness = caselight.brightness = HMI_value.Value; caselight.update_brightness(); }
+    void LiveCaseLightBrightness() { HMI_data.CaseLight_Brightness = caselight.brightness = MenuData.Value; caselight.update_brightness(); }
     void SetCaseLightBrightness() { SetIntOnClick(0, 255, caselight.brightness, nullptr, LiveCaseLightBrightness); }
   #endif
 #endif
 
 #if ENABLED(LED_CONTROL_MENU)
   #if !BOTH(CASE_LIGHT_MENU, CASE_LIGHT_USE_NEOPIXEL)
     void SetLedStatus() {
       leds.toggle();
       Draw_Chkb_Line(CurrentMenu->line(), leds.lights_on);
       DWIN_UpdateLCD();
     }
   #endif
   #if ENABLED(HAS_COLOR_LEDS)
-    void LiveLedColorR() { leds.color.r = HMI_value.Value; HMI_data.Led_Color = leds.color; leds.update(); }
+    void LiveLedColorR() { leds.color.r = MenuData.Value; HMI_data.Led_Color = leds.color; leds.update(); }
     void SetLedColorR() { SetIntOnClick(0, 255, leds.color.r, nullptr, LiveLedColorR); }
-    void LiveLedColorG() { leds.color.g = HMI_value.Value; HMI_data.Led_Color = leds.color; leds.update(); }
+    void LiveLedColorG() { leds.color.g = MenuData.Value; HMI_data.Led_Color = leds.color; leds.update(); }
     void SetLedColorG() { SetIntOnClick(0, 255, leds.color.g, nullptr, LiveLedColorG); }
-    void LiveLedColorB() { leds.color.b = HMI_value.Value; HMI_data.Led_Color = leds.color; leds.update(); }
+    void LiveLedColorB() { leds.color.b = MenuData.Value; HMI_data.Led_Color = leds.color; leds.update(); }
     void SetLedColorB() { SetIntOnClick(0, 255, leds.color.b, nullptr, LiveLedColorB); }
     #if HAS_WHITE_LED
-      void LiveLedColorW() { leds.color.w = HMI_value.Value; HMI_data.Led_Color = leds.color; leds.update(); }
+      void LiveLedColorW() { leds.color.w = MenuData.Value; HMI_data.Led_Color = leds.color; leds.update(); }
       void SetLedColorW() { SetIntOnClick(0, 255, leds.color.w, nullptr, LiveLedColorW); }
     #endif
   #endif
 #endif
 
 #if ENABLED(SOUND_MENU_ITEM)
   void SetEnableSound() {
     ui.buzzer_enabled = !ui.buzzer_enabled;
     Draw_Chkb_Line(CurrentMenu->line(), ui.buzzer_enabled);
     DWIN_UpdateLCD();
   }
 #endif
 
 #if HAS_HOME_OFFSET
-  void ApplyHomeOffset() { set_home_offset(HMI_value.axis, HMI_value.Value / MINUNITMULT); }
+  void ApplyHomeOffset() { set_home_offset(HMI_value.axis, MenuData.Value / MINUNITMULT); }
   void SetHomeOffsetX() { HMI_value.axis = X_AXIS; SetPFloatOnClick(-50, 50, UNITFDIGITS, ApplyHomeOffset); }
   void SetHomeOffsetY() { HMI_value.axis = Y_AXIS; SetPFloatOnClick(-50, 50, UNITFDIGITS, ApplyHomeOffset); }
   void SetHomeOffsetZ() { HMI_value.axis = Z_AXIS; SetPFloatOnClick( -2,  2, UNITFDIGITS, ApplyHomeOffset); }
 #endif
 
 #if HAS_BED_PROBE
   void SetProbeOffsetX() { SetPFloatOnClick(-60, 60, UNITFDIGITS); }
   void SetProbeOffsetY() { SetPFloatOnClick(-60, 60, UNITFDIGITS); }
   void SetProbeOffsetZ() { SetPFloatOnClick(-10, 10, 2); }
   void ProbeTest() {
@@ -2414,97 +2140,97 @@ void SetPID(celsius_t t, heater_id_t h) {
   void ProbeStow() { probe.stow(); }
   void ProbeDeploy() { probe.deploy(); }
 
   #ifdef BLTOUCH_HS_MODE
     void SetHSMode() {
       bltouch.high_speed_mode = !bltouch.high_speed_mode;
       Draw_Chkb_Line(CurrentMenu->line(), bltouch.high_speed_mode);
       DWIN_UpdateLCD();
     }
   #endif
-#endif
 
-#if ENABLED(NOZZLE_PARK_FEATURE)
-  void SetParkPosX()   { SetPIntOnClick(0, X_MAX_POS); }
-  void SetParkPosY()   { SetPIntOnClick(0, Y_MAX_POS); }
-  void SetParkZRaise() { SetPIntOnClick(0, 50); }
+  #if BOTH(HAS_HEATED_BED, PREHEAT_BEFORE_LEVELING)
+    void SetBedLevT() { SetPIntOnClick(BED_MINTEMP, BED_MAX_TARGET); }
+  #endif
+
 #endif
 
 #if HAS_FILAMENT_SENSOR
   void SetRunoutEnable() {
     runout.reset();
     runout.enabled = !runout.enabled;
     Draw_Chkb_Line(CurrentMenu->line(), runout.enabled);
     DWIN_UpdateLCD();
   }
   #if HAS_FILAMENT_RUNOUT_DISTANCE
-    void ApplyRunoutDistance() { runout.set_runout_distance(HMI_value.Value / MINUNITMULT); }
+    void ApplyRunoutDistance() { runout.set_runout_distance(MenuData.Value / MINUNITMULT); }
     void SetRunoutDistance() { SetFloatOnClick(0, 999, UNITFDIGITS, runout.runout_distance(), ApplyRunoutDistance); }
   #endif
 #endif
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   void SetFilLoad()   { SetPFloatOnClick(0, MAX_LOAD_UNLOAD, UNITFDIGITS); }
   void SetFilUnload() { SetPFloatOnClick(0, MAX_LOAD_UNLOAD, UNITFDIGITS); }
 #endif
 
 #if ENABLED(PREVENT_COLD_EXTRUSION)
   void ApplyExtMinT() { thermalManager.extrude_min_temp = HMI_data.ExtMinT; thermalManager.allow_cold_extrude = (HMI_data.ExtMinT == 0); }
   void SetExtMinT() { SetPIntOnClick(MIN_ETEMP, MAX_ETEMP, ApplyExtMinT); }
 #endif
 
 void RestoreDefaultsColors() {
   DWIN_SetColorDefaults();
-  DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color);
+  DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color, HMI_data.StatusBg_Color);
   DWIN_Redraw_screen();
 }
 
 void SelColor() {
-  HMI_value.P_Int = (int16_t*)static_cast<MenuItemPtrClass*>(CurrentMenu->SelectedItem())->value;
-  HMI_value.Color[0] = GetRColor(*HMI_value.P_Int);  // Red
-  HMI_value.Color[1] = GetGColor(*HMI_value.P_Int);  // Green
-  HMI_value.Color[2] = GetBColor(*HMI_value.P_Int);  // Blue
+  MenuData.P_Int = (int16_t*)static_cast<MenuItemPtrClass*>(CurrentMenu->SelectedItem())->value;
+  HMI_value.Color[0] = GetRColor(*MenuData.P_Int);  // Red
+  HMI_value.Color[1] = GetGColor(*MenuData.P_Int);  // Green
+  HMI_value.Color[2] = GetBColor(*MenuData.P_Int);  // Blue
   Draw_GetColor_Menu();
 }
 
 void LiveRGBColor() {
-    HMI_value.Color[CurrentMenu->line() - 2] = HMI_value.Value;
+    HMI_value.Color[CurrentMenu->line() - 2] = MenuData.Value;
     uint16_t color = RGB(HMI_value.Color[0], HMI_value.Color[1], HMI_value.Color[2]);
     DWIN_Draw_Rectangle(1, color, 20, 315, DWIN_WIDTH - 20, 335);
 }
 void SetRGBColor() {
   const uint8_t color = CurrentMenu->SelectedItem()->icon;
   SetIntOnClick(0, (color == 1) ? 63 : 31, HMI_value.Color[color], nullptr, LiveRGBColor);
 }
 
 void DWIN_ApplyColor() {
-  *HMI_value.P_Int = RGB(HMI_value.Color[0], HMI_value.Color[1], HMI_value.Color[2]);
-  DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color);
-  Draw_Status_Area(false);
+  *MenuData.P_Int = RGB(HMI_value.Color[0], HMI_value.Color[1], HMI_value.Color[2]);
+  DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color, HMI_data.StatusBg_Color);
   Draw_SelectColors_Menu();
+  hash_changed = true;
   LCD_MESSAGE_F(GET_TEXT_F(MSG_COLORS_APPLIED));
+  DWIN_Draw_Dashboard();
 }
 
 void SetSpeed() { SetPIntOnClick(MIN_PRINT_SPEED, MAX_PRINT_SPEED); }
 
 #if HAS_HOTEND
-  void ApplyHotendTemp() { thermalManager.setTargetHotend(HMI_value.Value, 0); }
+  void ApplyHotendTemp() { thermalManager.setTargetHotend(MenuData.Value, 0); }
   void SetHotendTemp() { SetIntOnClick(MIN_ETEMP, MAX_ETEMP, thermalManager.degTargetHotend(0), ApplyHotendTemp); }
 #endif
 
 #if HAS_HEATED_BED
-  void ApplyBedTemp() { thermalManager.setTargetBed(HMI_value.Value); }
+  void ApplyBedTemp() { thermalManager.setTargetBed(MenuData.Value); }
   void SetBedTemp() { SetIntOnClick(BED_MINTEMP, BED_MAX_TARGET, thermalManager.degTargetBed(), ApplyBedTemp); }
 #endif
 
 #if HAS_FAN
-  void ApplyFanSpeed() { thermalManager.set_fan_speed(0, HMI_value.Value); }
+  void ApplyFanSpeed() { thermalManager.set_fan_speed(0, MenuData.Value); }
   void SetFanSpeed() { SetIntOnClick(0, 255, thermalManager.fan_speed[0], ApplyFanSpeed); }
 #endif
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
 
   void ChangeFilament() {
     HMI_SaveProcessID(NothingToDo);
     queue.inject(F("M600 B2"));
   }
 
@@ -2524,31 +2250,29 @@ void SetSpeed() { SetPIntOnClick(MIN_PRINT_SPEED, MAX_PRINT_SPEED); }
       queue.inject(F("M701 Z20"));
     }
   #endif
 
 #endif // ADVANCED_PAUSE_FEATURE
 
 void ApplyFlow() { planner.refresh_e_factor(0); }
 void SetFlow() { SetPIntOnClick(MIN_PRINT_FLOW, MAX_PRINT_FLOW, ApplyFlow); }
 
 // Bed Tramming
-void Tram(uint8_t point) {
+TERN(HAS_ONESTEP_LEVELING, float, void) Tram(uint8_t point) {
   char cmd[100] = "";
   #if HAS_ONESTEP_LEVELING
     static bool inLev = false;
-    if (inLev) return;
+    float xpos = 0, ypos = 0, zval = 0, margin = 0;
     char str_1[6] = "", str_2[6] = "", str_3[6] = "";
-    #define fmt "X:%s, Y:%s, Z:%s"
-    float xpos = 0, ypos = 0, zval = 0;
-    float margin = PROBING_MARGIN;
+    if (inLev) return NAN;
+    margin = HMI_data.FullManualTramming ? 30 : PROBING_MARGIN;
   #else
-    #define fmt "M420S0\nG28O\nG90\nG0Z5F300\nG0X%iY%iF5000\nG0Z0F300"
     int16_t xpos = 0, ypos = 0;
     int16_t margin = 30;
   #endif
 
   switch (point) {
     case 0:
       LCD_MESSAGE(MSG_LEVBED_FL);
       xpos = ypos = margin;
       break;
     case 1:
@@ -2562,61 +2286,143 @@ void Tram(uint8_t point) {
     case 3:
       LCD_MESSAGE(MSG_LEVBED_BL);
       xpos = margin; ypos = Y_BED_SIZE - margin;
       break;
     case 4:
       LCD_MESSAGE(MSG_LEVBED_C);
       xpos = X_BED_SIZE / 2; ypos = Y_BED_SIZE / 2;
       break;
   }
 
+  planner.synchronize();
+
   #if HAS_ONESTEP_LEVELING
-    planner.synchronize();
-    probe.stow();
-    gcode.process_subcommands_now(F("M420S0\nG28O"));
-    planner.synchronize();
-    inLev = true;
-    zval = probe.probe_at_point(xpos, ypos, PROBE_PT_STOW);
-    sprintf_P(cmd, PSTR(fmt),
-      dtostrf(xpos, 1, 1, str_1),
-      dtostrf(ypos, 1, 1, str_2),
-      dtostrf(zval, 1, 2, str_3)
-    );
-    ui.set_status(cmd);
-    inLev = false;
+
+    if (HMI_data.FullManualTramming) {
+      planner.synchronize();
+      sprintf_P(cmd, PSTR("M420S0\nG28O\nG90\nG0Z5F300\nG0X%sY%sF5000\nG0Z0F300"),
+        dtostrf(xpos, 1, 1, str_1),
+        dtostrf(ypos, 1, 1, str_2)
+      );
+      queue.inject(cmd);
+    }
+    else {
+      LIMIT(xpos, X_MIN_POS, (X_MAX_POS + probe.offset.x));
+      LIMIT(ypos, Y_MIN_POS, (Y_MAX_POS + probe.offset.y));
+      probe.stow();
+      gcode.process_subcommands_now(F("M420S0\nG28O"));
+      planner.synchronize();
+      inLev = true;
+      zval = probe.probe_at_point(xpos, ypos, PROBE_PT_STOW);
+      if (isnan(zval))
+        ui.set_status(F("Position Not Reachable, check offsets"));
+      else {
+        sprintf_P(cmd, PSTR("X:%s, Y:%s, Z:%s"),
+          dtostrf(xpos, 1, 1, str_1),
+          dtostrf(ypos, 1, 1, str_2),
+          dtostrf(zval, 1, 2, str_3)
+        );
+        ui.set_status(cmd);
+      }
+      inLev = false;
+    }
+    return zval;
+
   #else
-    planner.synchronize();
-    sprintf_P(cmd, PSTR(fmt), xpos, ypos);
+
+    sprintf_P(cmd, PSTR("M420S0\nG28O\nG90\nG0Z5F300\nG0X%iY%iF5000\nG0Z0F300"), xpos, ypos);
     queue.inject(cmd);
+
   #endif
 }
 
 void TramFL() { Tram(0); }
 void TramFR() { Tram(1); }
 void TramBR() { Tram(2); }
 void TramBL() { Tram(3); }
 void TramC () { Tram(4); }
 
+#if HAS_ONESTEP_LEVELING
+
+  void Trammingwizard() {
+    bed_mesh_t zval = {0};
+    if (HMI_data.FullManualTramming) {
+      ui.set_status(F("Disable manual tramming"));
+      return;
+    }
+    zval[0][0] = Tram(0);
+    checkkey = NothingToDo;
+    MeshViewer.DrawMesh(zval, 2, 2);
+    zval[1][0] = Tram(1);
+    MeshViewer.DrawMesh(zval, 2, 2);
+    zval[1][1] = Tram(2);
+    MeshViewer.DrawMesh(zval, 2, 2);
+    zval[0][1] = Tram(3);
+    MeshViewer.DrawMesh(zval, 2, 2);
+    char str_1[6] = "", str_2[6] = "";
+    ui.status_printf(0, F("Limits minZ: %s, maxZ: %s"),
+      dtostrf(MeshViewer.min, 1, 2, str_1),
+      dtostrf(MeshViewer.max, 1, 2, str_2)
+    );
+    if (ABS(MeshViewer.max - MeshViewer.min) < 0.05) {
+      DWINUI::Draw_CenteredString(140,F("Corners leveled"));
+      DWINUI::Draw_CenteredString(160,F("Tolerance achieved!"));
+    }
+    else {
+      uint8_t p = 0;
+      float d, max = 0;
+      FSTR_P plabel;
+      LOOP_L_N(x,2) LOOP_L_N(y,2) {
+        d = ABS(zval[x][y] - MeshViewer.avg);
+        if (max < d) {
+          max = d;
+          p = x + 2 * y;
+        }
+      }
+      switch (p) {
+        case 0b00 : plabel = GET_TEXT_F(MSG_LEVBED_FL); break;
+        case 0b01 : plabel = GET_TEXT_F(MSG_LEVBED_FR); break;
+        case 0b10 : plabel = GET_TEXT_F(MSG_LEVBED_BL); break;
+        case 0b11 : plabel = GET_TEXT_F(MSG_LEVBED_BR); break;
+        default   : plabel = F(""); break;
+      }
+      DWINUI::Draw_CenteredString(130, F("Corners not leveled"));
+      DWINUI::Draw_CenteredString(150, F("Knob adjustment required"));
+      DWINUI::Draw_CenteredString(Color_Green, 170, plabel);
+    }
+    DWINUI::Draw_Button(BTN_Continue, 86, 305);
+    checkkey = Menu;
+    HMI_SaveProcessID(WaitResponse);
+  }
+
+  void SetManualTramming() {
+    HMI_data.FullManualTramming = !HMI_data.FullManualTramming;
+    Draw_Chkb_Line(CurrentMenu->line(), HMI_data.FullManualTramming);
+    DWIN_UpdateLCD();
+  }
+
+#endif // HAS_ONESTEP_LEVELING
+
 #if ENABLED(MESH_BED_LEVELING)
 
   void ManualMeshStart(){
     LCD_MESSAGE(MSG_UBL_BUILD_MESH_MENU);
-    gcode.process_subcommands_now(F("G28Z\nM211S0\nG29S1"));
+    gcode.process_subcommands_now(F("G28XYO\nG28Z\nM211S0\nG29S1"));
     planner.synchronize();
     #ifdef MANUAL_PROBE_START_Z
       const uint8_t line = CurrentMenu->line(MMeshMoveZItem->pos);
       DWINUI::Draw_Signed_Float(HMI_data.Text_Color, HMI_data.Background_Color, 3, 2, VALX - 2 * DWINUI::fontWidth(DWIN_FONT_MENU), MBASE(line), MANUAL_PROBE_START_Z);
     #endif
   }
 
   void LiveMeshMoveZ() {
-    *HMI_value.P_Float = HMI_value.Value / POW(10, 2);
+    *MenuData.P_Float = MenuData.Value / POW(10, 2);
     if (!planner.is_full()) {
       planner.synchronize();
       planner.buffer_line(current_position, homing_feedrate(Z_AXIS));
     }
   }
   void SetMMeshMoveZ() { SetPFloatOnClick(-1, 1, 2, planner.synchronize, LiveMeshMoveZ);}
 
   void ManualMeshContinue(){
     gcode.process_subcommands_now(F("G29S2"));
     planner.synchronize();
@@ -2635,143 +2441,88 @@ void TramC () { Tram(4); }
     void SetPreheatEndTemp() { SetPIntOnClick(MIN_ETEMP, MAX_ETEMP); }
   #endif
   #if HAS_HEATED_BED
     void SetPreheatBedTemp() { SetPIntOnClick(BED_MINTEMP, BED_MAX_TARGET); }
   #endif
   #if HAS_FAN
     void SetPreheatFanSpeed() { SetPIntOnClick(0, 255); }
   #endif
 #endif
 
-void ApplyMaxSpeed() { planner.set_max_feedrate(HMI_value.axis, HMI_value.Value / MINUNITMULT); }
-void SetMaxSpeedX() { HMI_value.axis = X_AXIS, SetFloatOnClick(MIN_MAXFEEDSPEED, default_max_feedrate[X_AXIS] * 2, UNITFDIGITS, planner.settings.max_feedrate_mm_s[X_AXIS], ApplyMaxSpeed); }
-void SetMaxSpeedY() { HMI_value.axis = Y_AXIS, SetFloatOnClick(MIN_MAXFEEDSPEED, default_max_feedrate[Y_AXIS] * 2, UNITFDIGITS, planner.settings.max_feedrate_mm_s[Y_AXIS], ApplyMaxSpeed); }
-void SetMaxSpeedZ() { HMI_value.axis = Z_AXIS, SetFloatOnClick(MIN_MAXFEEDSPEED, default_max_feedrate[Z_AXIS] * 2, UNITFDIGITS, planner.settings.max_feedrate_mm_s[Z_AXIS], ApplyMaxSpeed); }
+void ApplyMaxSpeed() { planner.set_max_feedrate(HMI_value.axis, MenuData.Value / MINUNITMULT); }
+void SetMaxSpeedX() { HMI_value.axis = X_AXIS, SetFloatOnClick(MIN_MAXFEEDSPEED, max_feedrate_edit_values[X_AXIS], UNITFDIGITS, planner.settings.max_feedrate_mm_s[X_AXIS], ApplyMaxSpeed); }
+void SetMaxSpeedY() { HMI_value.axis = Y_AXIS, SetFloatOnClick(MIN_MAXFEEDSPEED, max_feedrate_edit_values[Y_AXIS], UNITFDIGITS, planner.settings.max_feedrate_mm_s[Y_AXIS], ApplyMaxSpeed); }
+void SetMaxSpeedZ() { HMI_value.axis = Z_AXIS, SetFloatOnClick(MIN_MAXFEEDSPEED, max_feedrate_edit_values[Z_AXIS], UNITFDIGITS, planner.settings.max_feedrate_mm_s[Z_AXIS], ApplyMaxSpeed); }
 #if HAS_HOTEND
-  void SetMaxSpeedE() { HMI_value.axis = E_AXIS; SetFloatOnClick(MIN_MAXFEEDSPEED, default_max_feedrate[E_AXIS] * 2, UNITFDIGITS, planner.settings.max_feedrate_mm_s[E_AXIS], ApplyMaxSpeed); }
+  void SetMaxSpeedE() { HMI_value.axis = E_AXIS; SetFloatOnClick(MIN_MAXFEEDSPEED, max_feedrate_edit_values[E_AXIS], UNITFDIGITS, planner.settings.max_feedrate_mm_s[E_AXIS], ApplyMaxSpeed); }
 #endif
 
-void ApplyMaxAccel() { planner.set_max_acceleration(HMI_value.axis, HMI_value.Value); }
-void SetMaxAccelX() { HMI_value.axis = X_AXIS, SetIntOnClick(MIN_MAXACCELERATION, default_max_acceleration[X_AXIS] * 2, planner.settings.max_acceleration_mm_per_s2[X_AXIS], ApplyMaxAccel); }
-void SetMaxAccelY() { HMI_value.axis = Y_AXIS, SetIntOnClick(MIN_MAXACCELERATION, default_max_acceleration[Y_AXIS] * 2, planner.settings.max_acceleration_mm_per_s2[Y_AXIS], ApplyMaxAccel); }
-void SetMaxAccelZ() { HMI_value.axis = Z_AXIS, SetIntOnClick(MIN_MAXACCELERATION, default_max_acceleration[Z_AXIS] * 2, planner.settings.max_acceleration_mm_per_s2[Z_AXIS], ApplyMaxAccel); }
+void ApplyMaxAccel() { planner.set_max_acceleration(HMI_value.axis, MenuData.Value); }
+void SetMaxAccelX() { HMI_value.axis = X_AXIS, SetIntOnClick(MIN_MAXACCELERATION, max_acceleration_edit_values[X_AXIS], planner.settings.max_acceleration_mm_per_s2[X_AXIS], ApplyMaxAccel); }
+void SetMaxAccelY() { HMI_value.axis = Y_AXIS, SetIntOnClick(MIN_MAXACCELERATION, max_acceleration_edit_values[Y_AXIS], planner.settings.max_acceleration_mm_per_s2[Y_AXIS], ApplyMaxAccel); }
+void SetMaxAccelZ() { HMI_value.axis = Z_AXIS, SetIntOnClick(MIN_MAXACCELERATION, max_acceleration_edit_values[Z_AXIS], planner.settings.max_acceleration_mm_per_s2[Z_AXIS], ApplyMaxAccel); }
 #if HAS_HOTEND
-  void SetMaxAccelE() { HMI_value.axis = E_AXIS; SetIntOnClick(MIN_MAXACCELERATION, default_max_acceleration[E_AXIS] * 2, planner.settings.max_acceleration_mm_per_s2[E_AXIS], ApplyMaxAccel); }
+  void SetMaxAccelE() { HMI_value.axis = E_AXIS; SetIntOnClick(MIN_MAXACCELERATION, max_acceleration_edit_values[E_AXIS], planner.settings.max_acceleration_mm_per_s2[E_AXIS], ApplyMaxAccel); }
 #endif
 
 #if HAS_CLASSIC_JERK
-  void ApplyMaxJerk() { planner.set_max_jerk(HMI_value.axis, HMI_value.Value / MINUNITMULT); }
-  void SetMaxJerkX() { HMI_value.axis = X_AXIS, SetFloatOnClick(MIN_MAXJERK, default_max_jerk[X_AXIS] * 2, UNITFDIGITS, planner.max_jerk[X_AXIS], ApplyMaxJerk); }
-  void SetMaxJerkY() { HMI_value.axis = Y_AXIS, SetFloatOnClick(MIN_MAXJERK, default_max_jerk[Y_AXIS] * 2, UNITFDIGITS, planner.max_jerk[Y_AXIS], ApplyMaxJerk); }
-  void SetMaxJerkZ() { HMI_value.axis = Z_AXIS, SetFloatOnClick(MIN_MAXJERK, default_max_jerk[Z_AXIS] * 2, UNITFDIGITS, planner.max_jerk[Z_AXIS], ApplyMaxJerk); }
+  void ApplyMaxJerk() { planner.set_max_jerk(HMI_value.axis, MenuData.Value / MINUNITMULT); }
+  void SetMaxJerkX() { HMI_value.axis = X_AXIS, SetFloatOnClick(MIN_MAXJERK, max_jerk_edit_values[X_AXIS], UNITFDIGITS, planner.max_jerk[X_AXIS], ApplyMaxJerk); }
+  void SetMaxJerkY() { HMI_value.axis = Y_AXIS, SetFloatOnClick(MIN_MAXJERK, max_jerk_edit_values[Y_AXIS], UNITFDIGITS, planner.max_jerk[Y_AXIS], ApplyMaxJerk); }
+  void SetMaxJerkZ() { HMI_value.axis = Z_AXIS, SetFloatOnClick(MIN_MAXJERK, max_jerk_edit_values[Z_AXIS], UNITFDIGITS, planner.max_jerk[Z_AXIS], ApplyMaxJerk); }
   #if HAS_HOTEND
-    void SetMaxJerkE() { HMI_value.axis = E_AXIS; SetFloatOnClick(MIN_MAXJERK, default_max_jerk[E_AXIS] * 2, UNITFDIGITS, planner.max_jerk[E_AXIS], ApplyMaxJerk); }
+    void SetMaxJerkE() { HMI_value.axis = E_AXIS; SetFloatOnClick(MIN_MAXJERK, max_jerk_edit_values[E_AXIS], UNITFDIGITS, planner.max_jerk[E_AXIS], ApplyMaxJerk); }
   #endif
 #endif
 
 void SetStepsX() { HMI_value.axis = X_AXIS, SetPFloatOnClick( MIN_STEP, MAX_STEP, UNITFDIGITS); }
 void SetStepsY() { HMI_value.axis = Y_AXIS, SetPFloatOnClick( MIN_STEP, MAX_STEP, UNITFDIGITS); }
 void SetStepsZ() { HMI_value.axis = Z_AXIS, SetPFloatOnClick( MIN_STEP, MAX_STEP, UNITFDIGITS); }
 #if HAS_HOTEND
   void SetStepsE() { HMI_value.axis = E_AXIS; SetPFloatOnClick( MIN_STEP, MAX_STEP, UNITFDIGITS); }
   void SetHotendPidT() { SetPIntOnClick(MIN_ETEMP, MAX_ETEMP); }
 #endif
 #if HAS_HEATED_BED
   void SetBedPidT() { SetPIntOnClick(BED_MINTEMP, BED_MAX_TARGET); }
 #endif
 
 #if HAS_HOTEND || HAS_HEATED_BED
   void SetPidCycles() { SetPIntOnClick(3, 50); }
   void SetKp() { SetPFloatOnClick(0, 1000, 2); }
   void ApplyPIDi() {
-    *HMI_value.P_Float = scalePID_i(HMI_value.Value / POW(10, 2));
+    *MenuData.P_Float = scalePID_i(MenuData.Value / POW(10, 2));
     thermalManager.updatePID();
   }
   void ApplyPIDd() {
-    *HMI_value.P_Float = scalePID_d(HMI_value.Value / POW(10, 2));
+    *MenuData.P_Float = scalePID_d(MenuData.Value / POW(10, 2));
     thermalManager.updatePID();
   }
   void SetKi() {
-    HMI_value.P_Float = (float*)static_cast<MenuItemPtrClass*>(CurrentMenu->SelectedItem())->value;
-    const float value = unscalePID_i(*HMI_value.P_Float);
+    MenuData.P_Float = (float*)static_cast<MenuItemPtrClass*>(CurrentMenu->SelectedItem())->value;
+    const float value = unscalePID_i(*MenuData.P_Float);
     SetFloatOnClick(0, 1000, 2, value, ApplyPIDi);
   }
   void SetKd() {
-    HMI_value.P_Float = (float*)static_cast<MenuItemPtrClass*>(CurrentMenu->SelectedItem())->value;
-    const float value = unscalePID_d(*HMI_value.P_Float);
+    MenuData.P_Float = (float*)static_cast<MenuItemPtrClass*>(CurrentMenu->SelectedItem())->value;
+    const float value = unscalePID_d(*MenuData.P_Float);
     SetFloatOnClick(0, 1000, 2, value, ApplyPIDd);
   }
 #endif
 
 #if ENABLED(FWRETRACT)
   void SetRetractLength() { SetPFloatOnClick( 0, 10, UNITFDIGITS); };
   void SetRetractSpeed() { SetPFloatOnClick( 1, 90, UNITFDIGITS); };
   void SetZRaise() { SetPFloatOnClick( 0, 2, 2); };
   void SetRecoverSpeed() { SetPFloatOnClick( 1, 90, UNITFDIGITS); };
 #endif
 
-// Menuitem Drawing functions =================================================
-
-void onDrawMenuItem(MenuItemClass* menuitem, int8_t line) {
-  if (menuitem->icon) DWINUI::Draw_Icon(menuitem->icon, ICOX, MBASE(line) - 3);
-  if (menuitem->frameid)
-    DWIN_Frame_AreaCopy(menuitem->frameid, menuitem->frame.left, menuitem->frame.top, menuitem->frame.right, menuitem->frame.bottom, LBLX, MBASE(line));
-  else if (menuitem->caption)
-    DWINUI::Draw_String(LBLX, MBASE(line) - 1, menuitem->caption);
-  DWIN_Draw_HLine(HMI_data.SplitLine_Color, 16, MYPOS(line + 1), 240);
-}
-
-void onDrawSubMenu(MenuItemClass* menuitem, int8_t line) {
-  onDrawMenuItem(menuitem, line);
-  DWINUI::Draw_Icon(ICON_More, VALX + 16, MBASE(line) - 3);
-}
-
-void onDrawIntMenu(MenuItemClass* menuitem, int8_t line, uint16_t value) {
-  onDrawMenuItem(menuitem, line);
-  Draw_Menu_IntValue(HMI_data.Background_Color, line, 4, value);
-}
-
-void onDrawPIntMenu(MenuItemClass* menuitem, int8_t line) {
-  const uint16_t value = *(uint16_t*)static_cast<MenuItemPtrClass*>(menuitem)->value;
-  onDrawIntMenu(menuitem, line, value);
-}
-
-void onDrawPInt8Menu(MenuItemClass* menuitem, int8_t line) {
-  const uint8_t value = *(uint8_t*)static_cast<MenuItemPtrClass*>(menuitem)->value;
-  onDrawIntMenu(menuitem, line, value);
-}
-
-void onDrawPInt32Menu(MenuItemClass* menuitem, int8_t line) {
-  const uint32_t value = *(uint32_t*)static_cast<MenuItemPtrClass*>(menuitem)->value;
-  onDrawIntMenu(menuitem, line, value);
-}
-
-void onDrawFloatMenu(MenuItemClass* menuitem, int8_t line, uint8_t dp, const float value) {
-  onDrawMenuItem(menuitem, line);
-  DWINUI::Draw_Signed_Float(HMI_data.Text_Color, HMI_data.Background_Color, 3, dp, VALX - dp * DWINUI::fontWidth(DWIN_FONT_MENU), MBASE(line), value);
-}
-
-void onDrawPFloatMenu(MenuItemClass* menuitem, int8_t line) {
-  const float value = *(float*)static_cast<MenuItemPtrClass*>(menuitem)->value;
-  const int8_t dp = UNITFDIGITS;
-  onDrawFloatMenu(menuitem, line, dp, value);
-}
-
-void onDrawPFloat2Menu(MenuItemClass* menuitem, int8_t line) {
-  const float value = *(float*)static_cast<MenuItemPtrClass*>(menuitem)->value;
-  onDrawFloatMenu(menuitem, line, 2, value);
-}
-
-void onDrawChkbMenu(MenuItemClass* menuitem, int8_t line, bool checked) {
-  onDrawMenuItem(menuitem, line);
-  Draw_Chkb_Line(line, checked);
-}
+// Special Menuitem Drawing functions =================================================
 
 void onDrawBack(MenuItemClass* menuitem, int8_t line) {
   if (HMI_IsChinese()) menuitem->SetFrame(1, 129, 72, 156, 84);
   onDrawMenuItem(menuitem, line);
 }
 
 void onDrawTempSubMenu(MenuItemClass* menuitem, int8_t line) {
   if (HMI_IsChinese()) menuitem->SetFrame(1,  57, 104,  84, 116);
   onDrawSubMenu(menuitem, line);
 }
@@ -2875,20 +2626,24 @@ void onDrawAutoHome(MenuItemClass* menuitem, int8_t line) {
 void onDrawLanguage(MenuItemClass* menuitem, int8_t line) {
   if (HMI_IsChinese()) menuitem->SetFrame(1, 239, 134, 266, 146);
   onDrawMenuItem(menuitem, line);
   DWINUI::Draw_String(VALX, MBASE(line), HMI_IsChinese() ? F("CN") : F("EN"));
 }
 
 #if ENABLED(POWER_LOSS_RECOVERY)
   void onDrawPwrLossR(MenuItemClass* menuitem, int8_t line) { onDrawChkbMenu(menuitem, line, recovery.enabled); }
 #endif
 
+#if ENABLED(BAUD_RATE_GCODE)
+  void onDrawBaudrate(MenuItemClass* menuitem, int8_t line) { onDrawChkbMenu(menuitem, line, HMI_data.Baud115K); }
+#endif
+
 #if ENABLED(CASE_LIGHT_MENU)
   void onDrawCaseLight(MenuItemClass* menuitem, int8_t line) { onDrawChkbMenu(menuitem, line, caselight.on); }
 #endif
 
 #if ENABLED(LED_CONTROL_MENU)
   #if !BOTH(CASE_LIGHT_MENU, CASE_LIGHT_USE_NEOPIXEL)
     void onDrawLedStatus(MenuItemClass* menuitem, int8_t line) { onDrawChkbMenu(menuitem, line, leds.lights_on); }
   #endif
 #endif
 
@@ -3165,151 +2920,23 @@ void onDrawStepsZ(MenuItemClass* menuitem, int8_t line) {
 #if HAS_HOTEND
   void onDrawStepsE(MenuItemClass* menuitem, int8_t line) {
     if (HMI_IsChinese()) {
       menuitem->SetFrame(1, 153, 148, 194, 161);
       DWIN_Frame_AreaCopy(1,  18, 150,  25, 160, LBLX + 44, MBASE(line));    // E
     }
     onDrawPFloatMenu(menuitem, line);
   }
 #endif
 
-// HMI Control functions ======================================================
-
-// Generic menu control using the encoder
-void HMI_Menu() {
-  EncoderState encoder_diffState = get_encoder_state();
-  if (encoder_diffState == ENCODER_DIFF_NO) return;
-  if (CurrentMenu) {
-    if (encoder_diffState == ENCODER_DIFF_ENTER)
-      CurrentMenu->onClick();
-    else
-      CurrentMenu->onScroll(encoder_diffState == ENCODER_DIFF_CW);
-  }
-}
-
-// Get an integer value using the encoder without draw anything
-//  lo: low limit
-//  hi: high limit
-// Return value:
-//  0 : no change
-//  1 : live change
-//  2 : apply change
-int8_t HMI_GetIntNoDraw(const int32_t lo, const int32_t hi) {
-  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
-  if (encoder_diffState != ENCODER_DIFF_NO) {
-    if (Apply_Encoder(encoder_diffState, HMI_value.Value)) {
-      EncoderRate.enabled = false;
-      checkkey = Menu;
-      return 2;
-    }
-    LIMIT(HMI_value.Value, lo, hi);
-    return 1;
-  }
-  return 0;
-}
-
-// Get an integer value using the encoder
-//  lo: low limit
-//  hi: high limit
-// Return value:
-//  0 : no change
-//  1 : live change
-//  2 : apply change
-int8_t HMI_GetInt(const int32_t lo, const int32_t hi) {
-  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
-  if (encoder_diffState != ENCODER_DIFF_NO) {
-    if (Apply_Encoder(encoder_diffState, HMI_value.Value)) {
-      EncoderRate.enabled = false;
-      DWINUI::Draw_Int(HMI_data.Text_Color, HMI_data.Background_Color, 4 , VALX, MBASE(CurrentMenu->line()) - 1, HMI_value.Value);
-      checkkey = Menu;
-      return 2;
-    }
-    LIMIT(HMI_value.Value, lo, hi);
-    DWINUI::Draw_Int(HMI_data.Text_Color, HMI_data.Selected_Color, 4 , VALX, MBASE(CurrentMenu->line()) - 1, HMI_value.Value);
-    return 1;
-  }
-  return 0;
-}
-
-// Set an integer using the encoder
-void HMI_SetInt() {
-  int8_t val = HMI_GetInt(HMI_value.MinValue, HMI_value.MaxValue);
-  switch (val) {
-    case 0: return; break;
-    case 1: if (HMI_value.LiveUpdate) HMI_value.LiveUpdate(); break;
-    case 2: if (HMI_value.Apply) HMI_value.Apply(); break;
-  }
-}
-
-// Set an integer without drawing
-void HMI_SetIntNoDraw() {
-  int8_t val = HMI_GetIntNoDraw(HMI_value.MinValue, HMI_value.MaxValue);
-  switch (val) {
-    case 0: return; break;
-    case 1: if (HMI_value.LiveUpdate) HMI_value.LiveUpdate(); break;
-    case 2: if (HMI_value.Apply) HMI_value.Apply(); break;
-  }
-}
-
-// Set an integer pointer variable using the encoder
-void HMI_SetPInt() {
-  int8_t val = HMI_GetInt(HMI_value.MinValue, HMI_value.MaxValue);
-  switch (val) {
-    case 0: return;
-    case 1: if (HMI_value.LiveUpdate) HMI_value.LiveUpdate(); break;
-    case 2: *HMI_value.P_Int = HMI_value.Value; if (HMI_value.Apply) HMI_value.Apply(); break;
-  }
-}
-
-// Get a scaled float value using the encoder
-//  dp: decimal places
-//  lo: scaled low limit
-//  hi: scaled high limit
-// Return value:
-//  0 : no change
-//  1 : live change
-//  2 : apply change
-int8_t HMI_GetFloat(uint8_t dp, int32_t lo, int32_t hi) {
-  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
-  if (encoder_diffState != ENCODER_DIFF_NO) {
-    if (Apply_Encoder(encoder_diffState, HMI_value.Value)) {
-      EncoderRate.enabled = false;
-      DWINUI::Draw_Signed_Float(HMI_data.Text_Color, HMI_data.Background_Color, 3, dp, VALX - dp * DWINUI::fontWidth(DWIN_FONT_MENU), MBASE(CurrentMenu->line()), HMI_value.Value / POW(10, dp));
-      checkkey = Menu;
-      return 2;
-    }
-    LIMIT(HMI_value.Value, lo, hi);
-    DWINUI::Draw_Signed_Float(HMI_data.Text_Color, HMI_data.Selected_Color, 3, dp, VALX - dp * DWINUI::fontWidth(DWIN_FONT_MENU), MBASE(CurrentMenu->line()), HMI_value.Value / POW(10, dp));
-    return 1;
-  }
-  return 0;
-}
-
-// Set a scaled float using the encoder
-void HMI_SetFloat() {
-  const int8_t val = HMI_GetFloat(HMI_value.dp, HMI_value.MinValue, HMI_value.MaxValue);
-  switch (val) {
-    case 0: return;
-    case 1: if (HMI_value.LiveUpdate) HMI_value.LiveUpdate(); break;
-    case 2: if (HMI_value.Apply) HMI_value.Apply(); break;
-  }
-}
-
-// Set a scaled float pointer variable using the encoder
-void HMI_SetPFloat() {
-  const int8_t val = HMI_GetFloat(HMI_value.dp, HMI_value.MinValue, HMI_value.MaxValue);
-  switch (val) {
-    case 0: return;
-    case 1: if (HMI_value.LiveUpdate) HMI_value.LiveUpdate(); break;
-    case 2: *HMI_value.P_Float = HMI_value.Value / POW(10, HMI_value.dp); if (HMI_value.Apply) HMI_value.Apply(); break;
-  }
-}
+#if HAS_ONESTEP_LEVELING
+  void onDrawManualTramming(MenuItemClass* menuitem, int8_t line) { onDrawChkbMenu(menuitem, line, HMI_data.FullManualTramming); }
+#endif
 
 // Menu Creation and Drawing functions ======================================================
 
 void SetMenuTitle(frame_rect_t cn, const __FlashStringHelper* fstr) {
   if (HMI_IsChinese() && (cn.w != 0))
     CurrentMenu->MenuTitle.SetFrame(cn.x, cn.y, cn.w, cn.h);
   else
     CurrentMenu->MenuTitle.SetCaption(fstr);
 }
 
@@ -3352,48 +2979,53 @@ void Draw_Prepare_Menu() {
       #if PREHEAT_COUNT > 1
         MENU_ITEM(ICON_ABSPreheat, PSTR("Preheat " PREHEAT_2_LABEL), onDrawPreheat2, DoPreheat1);
       #endif
       #if PREHEAT_COUNT > 2
         MENU_ITEM(ICON_CustomPreheat, GET_TEXT_F(MSG_PREHEAT_CUSTOM), onDrawMenuItem, DoPreheat2);
       #endif
     #endif
     MENU_ITEM(ICON_Cool, GET_TEXT_F(MSG_COOLDOWN), onDrawCooldown, DoCoolDown);
     MENU_ITEM(ICON_Language, PSTR(GET_TEXT_F(MSG_UI_LANGUAGE)), onDrawLanguage, SetLanguage);
   }
+  ui.reset_status(true);
   CurrentMenu->draw();
 }
 
 void Draw_Tramming_Menu() {
   DWINUI::ClearMenuArea();
   checkkey = Menu;
   if (!TrammingMenu) TrammingMenu = new MenuClass();
   if (CurrentMenu != TrammingMenu) {
     CurrentMenu = TrammingMenu;
     SetMenuTitle({0}, GET_TEXT_F(MSG_BED_TRAMMING)); // TODO: Chinese, English "Bed Tramming" JPG
-    DWINUI::MenuItemsPrepare(6);
+    DWINUI::MenuItemsPrepare(8);
     MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_Prepare_Menu);
     MENU_ITEM(ICON_Axis, GET_TEXT_F(MSG_LEVBED_FL), onDrawMenuItem, TramFL);
     MENU_ITEM(ICON_Axis, GET_TEXT_F(MSG_LEVBED_FR), onDrawMenuItem, TramFR);
     MENU_ITEM(ICON_Axis, GET_TEXT_F(MSG_LEVBED_BR), onDrawMenuItem, TramBR);
     MENU_ITEM(ICON_Axis, GET_TEXT_F(MSG_LEVBED_BL), onDrawMenuItem, TramBL);
     MENU_ITEM(ICON_Axis, GET_TEXT_F(MSG_LEVBED_C ), onDrawMenuItem, TramC );
+    #if HAS_ONESTEP_LEVELING
+      MENU_ITEM(ICON_ProbeSet, F("Bed tramming wizard"), onDrawMenuItem, Trammingwizard);
+      MENU_ITEM(ICON_ProbeSet, GET_TEXT_F(MSG_BED_TRAMMING_MANUAL), onDrawManualTramming, SetManualTramming);
+    #endif
   }
   CurrentMenu->draw();
 }
 
 void Draw_Control_Menu() {
   checkkey = Menu;
   if (!ControlMenu) ControlMenu = new MenuClass();
   if (CurrentMenu != ControlMenu) {
     CurrentMenu = ControlMenu;
     SetMenuTitle({103, 1, 28, 14}, GET_TEXT_F(MSG_CONTROL));
-    DWINUI::MenuItemsPrepare(8);
+    DWINUI::MenuItemsPrepare(10);
     MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Goto_Main_Menu);
     #if ENABLED(CASE_LIGHT_MENU)
       #if ENABLED(CASELIGHT_USES_BRIGHTNESS)
         MENU_ITEM(ICON_CaseLight, GET_TEXT_F(MSG_CASE_LIGHT), onDrawSubMenu, Draw_CaseLight_Menu);
       #else
         MENU_ITEM(ICON_CaseLight, GET_TEXT_F(MSG_CASE_LIGHT), onDrawCaseLight, SetCaseLight);
       #endif
     #endif
     #if ENABLED(LED_CONTROL_MENU)
       MENU_ITEM(ICON_LedControl, GET_TEXT_F(MSG_LED_CONTROL), onDrawSubMenu, Draw_LedControl_Menu);
@@ -3401,68 +3033,76 @@ void Draw_Control_Menu() {
     MENU_ITEM(ICON_Temperature, GET_TEXT_F(MSG_TEMPERATURE), onDrawTempSubMenu, Draw_Temperature_Menu);
     MENU_ITEM(ICON_Motion, GET_TEXT_F(MSG_MOTION), onDrawMotionSubMenu, Draw_Motion_Menu);
     #if ENABLED(EEPROM_SETTINGS)
       MENU_ITEM(ICON_WriteEEPROM, GET_TEXT_F(MSG_STORE_EEPROM), onDrawWriteEeprom, WriteEeprom);
       MENU_ITEM(ICON_ReadEEPROM, GET_TEXT_F(MSG_LOAD_EEPROM), onDrawReadEeprom, ReadEeprom);
       MENU_ITEM(ICON_ResumeEEPROM, GET_TEXT_F(MSG_RESTORE_DEFAULTS), onDrawResetEeprom, ResetEeprom);
     #endif
     MENU_ITEM(ICON_Reboot, GET_TEXT_F(MSG_RESET_PRINTER), onDrawMenuItem, RebootPrinter);
     MENU_ITEM(ICON_Info, GET_TEXT_F(MSG_INFO_SCREEN), onDrawInfoSubMenu, Goto_Info_Menu);
   }
+  ui.reset_status(true);
   CurrentMenu->draw();
 }
 
 void Draw_AdvancedSettings_Menu() {
   checkkey = Menu;
   if (!AdvancedSettings) AdvancedSettings = new MenuClass();
   if (CurrentMenu != AdvancedSettings) {
     CurrentMenu = AdvancedSettings;
     SetMenuTitle({0}, GET_TEXT_F(MSG_ADVANCED_SETTINGS)); // TODO: Chinese, English "Advanced Settings" JPG
-    DWINUI::MenuItemsPrepare(15);
+    DWINUI::MenuItemsPrepare(17);
     MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Goto_Main_Menu);
+    #if ENABLED(EEPROM_SETTINGS)
+      MENU_ITEM(ICON_WriteEEPROM, GET_TEXT_F(MSG_STORE_EEPROM), onDrawMenuItem, WriteEeprom);
+    #endif
     #if HAS_HOME_OFFSET
       MENU_ITEM(ICON_HomeOffset, GET_TEXT_F(MSG_SET_HOME_OFFSETS), onDrawSubMenu, Draw_HomeOffset_Menu);
     #endif
     #if HAS_BED_PROBE
       MENU_ITEM(ICON_ProbeSet, GET_TEXT_F(MSG_ZPROBE_SETTINGS), onDrawSubMenu, Draw_ProbeSet_Menu);
     #endif
     #if HAS_HOTEND
       MENU_ITEM(ICON_PIDNozzle, F("Hotend PID Settings"), onDrawSubMenu, Draw_HotendPID_Menu);
     #endif
     #if HAS_HEATED_BED
       MENU_ITEM(ICON_PIDbed, F("Bed PID Settings"), onDrawSubMenu, Draw_BedPID_Menu);
     #endif
     #if HAS_FILAMENT_SENSOR
       MENU_ITEM(ICON_FilSet, GET_TEXT_F(MSG_FILAMENT_SET), onDrawSubMenu, Draw_FilSet_Menu);
     #endif
     #if ENABLED(POWER_LOSS_RECOVERY)
       MENU_ITEM(ICON_Pwrlossr, GET_TEXT_F(MSG_OUTAGE_RECOVERY), onDrawPwrLossR, SetPwrLossr);
     #endif
+    #if ENABLED(BAUD_RATE_GCODE)
+      MENU_ITEM(ICON_SetBaudRate, F("115K baud"), onDrawBaudrate, SetBaudRate);
+    #endif
     #if HAS_LCD_BRIGHTNESS
       EDIT_ITEM(ICON_Brightness, GET_TEXT_F(MSG_BRIGHTNESS), onDrawPInt8Menu, SetBrightness, &ui.brightness);
     #endif
     MENU_ITEM(ICON_Scolor, GET_TEXT_F(MSG_COLORS_SELECT), onDrawSubMenu, Draw_SelectColors_Menu);
     #if ENABLED(SOUND_MENU_ITEM)
       MENU_ITEM(ICON_Sound, GET_TEXT_F(MSG_SOUND_ENABLE), onDrawEnableSound, SetEnableSound);
     #endif
     #if HAS_MESH
       MENU_ITEM(ICON_MeshViewer, GET_TEXT_F(MSG_MESH_VIEW), onDrawSubMenu, DWIN_MeshViewer);
     #endif
     #if HAS_ESDIAG
       MENU_ITEM(ICON_ESDiag, F("End-stops diag."), onDrawSubMenu, Draw_EndStopDiag);
     #endif
     #if ENABLED(PRINTCOUNTER)
-      MENU_ITEM(ICON_PrintStats, GET_TEXT_F(MSG_INFO_STATS_MENU), onDrawSubMenu, Draw_PrintStats);
+      MENU_ITEM(ICON_PrintStats, GET_TEXT_F(MSG_INFO_STATS_MENU), onDrawSubMenu, Goto_PrintStats);
       MENU_ITEM(ICON_PrintStatsReset, GET_TEXT_F(MSG_INFO_PRINT_COUNT_RESET), onDrawSubMenu, PrintStats.Reset);
     #endif
     MENU_ITEM(ICON_Lock, GET_TEXT_F(MSG_LOCKSCREEN), onDrawMenuItem, DWIN_LockScreen);
   }
+  ui.reset_status(true);
   CurrentMenu->draw();
 }
 
 void Draw_Move_Menu() {
   checkkey = Menu;
   if (!MoveMenu) MoveMenu = new MenuClass();
   if (CurrentMenu != MoveMenu) {
     CurrentMenu = MoveMenu;
     SetMenuTitle({192, 1, 42, 14}, GET_TEXT_F(MSG_MOVE_AXIS));
     DWINUI::MenuItemsPrepare(5);
@@ -3495,25 +3135,28 @@ void Draw_Move_Menu() {
   }
 #endif
 
 #if HAS_BED_PROBE
   void Draw_ProbeSet_Menu() {
     checkkey = Menu;
     if (!ProbeSetMenu) ProbeSetMenu = new MenuClass();
     if (CurrentMenu != ProbeSetMenu) {
       CurrentMenu = ProbeSetMenu;
       SetMenuTitle({0}, GET_TEXT_F(MSG_ZPROBE_SETTINGS)); // TODO: Chinese, English "Probe Settings" JPG
-      DWINUI::MenuItemsPrepare(8);
+      DWINUI::MenuItemsPrepare(9);
       MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_AdvancedSettings_Menu);
       EDIT_ITEM(ICON_ProbeOffsetX, GET_TEXT_F(MSG_ZPROBE_XOFFSET), onDrawPFloatMenu, SetProbeOffsetX, &probe.offset.x);
       EDIT_ITEM(ICON_ProbeOffsetY, GET_TEXT_F(MSG_ZPROBE_YOFFSET), onDrawPFloatMenu, SetProbeOffsetY, &probe.offset.y);
       EDIT_ITEM(ICON_ProbeOffsetZ, GET_TEXT_F(MSG_ZPROBE_ZOFFSET), onDrawPFloat2Menu, SetProbeOffsetZ, &probe.offset.z);
+      #if BOTH(HAS_HEATED_BED, PREHEAT_BEFORE_LEVELING)
+        EDIT_ITEM(ICON_Temperature, GET_TEXT_F(MSG_UBL_SET_TEMP_BED), onDrawPIntMenu, SetBedLevT, &HMI_data.BedLevT);
+      #endif
       #ifdef BLTOUCH_HS_MODE
         MENU_ITEM(ICON_HSMode, F("Enable HS mode"), onDrawHSMode, SetHSMode);
       #endif
       MENU_ITEM(ICON_ProbeTest, GET_TEXT_F(MSG_M48_TEST), onDrawMenuItem, ProbeTest);
       MENU_ITEM(ICON_ProbeStow, GET_TEXT_F(MSG_MANUAL_STOW), onDrawMenuItem, ProbeStow);
       MENU_ITEM(ICON_ProbeDeploy, GET_TEXT_F(MSG_MANUAL_DEPLOY), onDrawMenuItem, ProbeDeploy);
     }
     CurrentMenu->draw();
   }
 #endif
@@ -3589,21 +3232,21 @@ void Draw_GetColor_Menu() {
     CurrentMenu = GetColorMenu;
     SetMenuTitle({0}, GET_TEXT_F(MSG_COLORS_GET)); // TODO: Chinese, English "Get Color" JPG
     DWINUI::MenuItemsPrepare(5);
     MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, DWIN_ApplyColor);
     MENU_ITEM(ICON_Cancel, GET_TEXT_F(MSG_BUTTON_CANCEL), onDrawMenuItem, Draw_SelectColors_Menu);
     MENU_ITEM(0, GET_TEXT_F(MSG_COLORS_RED), onDrawGetColorItem, SetRGBColor);
     MENU_ITEM(1, GET_TEXT_F(MSG_COLORS_GREEN), onDrawGetColorItem, SetRGBColor);
     MENU_ITEM(2, GET_TEXT_F(MSG_COLORS_BLUE), onDrawGetColorItem, SetRGBColor);
   }
   CurrentMenu->draw();
-  DWIN_Draw_Rectangle(1, *HMI_value.P_Int, 20, 315, DWIN_WIDTH - 20, 335);
+  DWIN_Draw_Rectangle(1, *MenuData.P_Int, 20, 315, DWIN_WIDTH - 20, 335);
 }
 
 #if BOTH(CASE_LIGHT_MENU, CASELIGHT_USES_BRIGHTNESS)
     void Draw_CaseLight_Menu() {
       checkkey = Menu;
       if (!CaseLightMenu) CaseLightMenu = new MenuClass();
       if (CurrentMenu != CaseLightMenu) {
         CurrentMenu = CaseLightMenu;
         SetMenuTitle({0}, GET_TEXT_F(MSG_CASE_LIGHT)); // TODO: Chinese, English "Case Light" JPG
         DWINUI::MenuItemsPrepare(3);
@@ -3639,21 +3282,21 @@ void Draw_GetColor_Menu() {
       CurrentMenu->draw();
     }
 #endif
 
 void Draw_Tune_Menu() {
   checkkey = Menu;
   if (!TuneMenu) TuneMenu = new MenuClass();
   if (CurrentMenu != TuneMenu) {
     CurrentMenu = TuneMenu;
     SetMenuTitle({73, 2, 28, 12}, GET_TEXT_F(MSG_TUNE)); // TODO: Chinese, English "Tune" JPG
-    DWINUI::MenuItemsPrepare(14);
+    DWINUI::MenuItemsPrepare(16);
     MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Goto_PrintProcess);
     #if ENABLED(CASE_LIGHT_MENU)
       MENU_ITEM(ICON_CaseLight, GET_TEXT_F(MSG_CASE_LIGHT), onDrawCaseLight, SetCaseLight);
     #elif ENABLED(LED_CONTROL_MENU) && DISABLED(CASE_LIGHT_USE_NEOPIXEL)
       MENU_ITEM(ICON_LedControl, GET_TEXT_F(MSG_LEDS), onDrawLedStatus, SetLedStatus);
     #endif
     EDIT_ITEM(ICON_Speed, GET_TEXT_F(MSG_SPEED), onDrawSpeedItem, SetSpeed, &feedrate_percentage);
     #if HAS_HOTEND
       HotendTargetItem = EDIT_ITEM(ICON_HotendTemp, GET_TEXT_F(MSG_UBL_SET_TEMP_HOTEND), onDrawHotendTemp, SetHotendTemp, &thermalManager.temp_hotend[0].target);
     #endif
@@ -3672,20 +3315,21 @@ void Draw_Tune_Menu() {
       EDIT_ITEM(ICON_FWRetZRaise, GET_TEXT_F(MSG_CONTROL_RETRACT_ZHOP), onDrawPFloat2Menu, SetZRaise, &fwretract.settings.retract_zraise);
       EDIT_ITEM(ICON_FWRecSpeed, GET_TEXT_F(MSG_SINGLENOZZLE_UNRETRACT_SPEED), onDrawPFloatMenu, SetRecoverSpeed, &fwretract.settings.retract_recover_feedrate_mm_s);
     #endif
     EDIT_ITEM(ICON_Flow, GET_TEXT_F(MSG_FLOW), onDrawPIntMenu, SetFlow, &planner.flow_percentage[0]);
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
       MENU_ITEM(ICON_FilMan, GET_TEXT_F(MSG_FILAMENTCHANGE), onDrawMenuItem, ChangeFilament);
     #endif
     MENU_ITEM(ICON_Lock, GET_TEXT_F(MSG_LOCKSCREEN), onDrawMenuItem, DWIN_LockScreen);
     #if HAS_LCD_BRIGHTNESS
       EDIT_ITEM(ICON_Brightness, GET_TEXT_F(MSG_BRIGHTNESS), onDrawPInt8Menu, SetBrightness, &ui.brightness);
+      MENU_ITEM(ICON_Brightness, GET_TEXT_F(MSG_BRIGHTNESS_OFF), onDrawMenuItem, TurnOffBacklight);
     #endif
   }
   CurrentMenu->draw();
 }
 
 void Draw_Motion_Menu() {
   checkkey = Menu;
   if (!MotionMenu) MotionMenu = new MenuClass();
   if (CurrentMenu != MotionMenu) {
     CurrentMenu = MotionMenu;

commit 48b5362cf02ff12c9e9fc4d5825ceebe457ea34b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Mar 10 22:07:47 2022 -0600

    üîß DWIN_CREALITY_LCD_ENHANCED => DWIN_LCD_PROUI
    
    Followup to #23624

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 5af7fc294d..9e08854aed 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -24,21 +24,21 @@
  * Enhanced DWIN implementation
  * Author: Miguel A. Risco-Castillo (MRISCOC)
  * Version: 3.11.2
  * date: 2022/01/19
  *
  * Based on the original code provided by Creality under GPL
  */
 
 #include "../../../inc/MarlinConfigPre.h"
 
-#if ENABLED(DWIN_CREALITY_LCD_ENHANCED)
+#if ENABLED(DWIN_LCD_PROUI)
 
 #include "dwin.h"
 #include "dwin_popup.h"
 
 #include "../../fontutils.h"
 #include "../../marlinui.h"
 
 #include "../../../sd/cardreader.h"
 
 #include "../../../MarlinCore.h"
@@ -3967,11 +3967,11 @@ void Draw_Steps_Menu() {
       MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawMenuItem, Draw_Prepare_Menu);
       MENU_ITEM(ICON_Homing, GET_TEXT_F(MSG_AUTO_HOME), onDrawMenuItem, AutoHome);
       MENU_ITEM(ICON_HomeX, GET_TEXT_F(MSG_AUTO_HOME_X), onDrawMenuItem, HomeX);
       MENU_ITEM(ICON_HomeY, GET_TEXT_F(MSG_AUTO_HOME_Y), onDrawMenuItem, HomeY);
       MENU_ITEM(ICON_HomeZ, GET_TEXT_F(MSG_AUTO_HOME_Z), onDrawMenuItem, HomeZ);
     }
     CurrentMenu->draw();
   }
 #endif
 
-#endif // DWIN_CREALITY_LCD_ENHANCED
+#endif // DWIN_LCD_PROUI

commit 9ef01d43bb2f4384482ae8205ca6c80ebe388a52
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue Mar 1 17:25:30 2022 -0500

    ‚ö°Ô∏è E3V2 blank bg for S1 compatibility (#23822)

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index d65fa9ec79..5af7fc294d 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -1829,20 +1829,21 @@ void Draw_Menu(MenuClass* menu) {
   DWIN_ResetStatusLine();
 }
 
 // Startup routines
 void DWIN_Startup() {
   DWINUI::init();
   DWINUI::onCursorDraw = Draw_Menu_Cursor;
   DWINUI::onCursorErase = Erase_Menu_Cursor;
   DWINUI::onTitleDraw = Draw_Title;
   DWINUI::onMenuDraw = Draw_Menu;
+  DWIN_JPG_ShowAndCache(3);
   HMI_SetLanguage();
 }
 
 // Started a Print Job
 void DWIN_Print_Started(const bool sd) {
   sdprint = card.isPrinting() || sd;
   _percent_done = 0;
   _remain_time = 0;
   HMI_flag.print_finish = false;
   Goto_PrintProcess();
@@ -1930,20 +1931,21 @@ void MarlinUI::kill_screen(FSTR_P const lcd_error, FSTR_P const lcd_component) {
   DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 270, F("Turn off the printer"));
   DWIN_UpdateLCD();
 }
 
 void DWIN_RebootScreen() {
   DWIN_Frame_Clear(Color_Bg_Black);
   DWIN_JPG_ShowAndCache(0);
   DWINUI::Draw_CenteredString(Color_White, 220, GET_TEXT_F(MSG_PLEASE_WAIT_REBOOT));
   DWIN_UpdateLCD();
   delay(500);
+  DWIN_JPG_ShowAndCache(3);
 }
 
 void DWIN_Redraw_screen() {
   Draw_Main_Area();
   Draw_Status_Area(false);
 }
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
 
   void DWIN_Popup_Pause(FSTR_P const fmsg, uint8_t button = 0) {

commit 44eff9a23348dcc117fd1ea9b4b1ef0b54061808
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Feb 17 18:50:31 2022 -0600

    ‚ôªÔ∏è Refactor HAL as singleton (#23357)

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
index 4d7f38171d..d65fa9ec79 100644
--- a/Marlin/src/lcd/e3v2/proui/dwin.cpp
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -2199,21 +2199,21 @@ void SetPFloatOnClick(const float lo, const float hi, uint8_t dp, void (*Apply)(
   }
 #endif
 
 // Reset Printer
 void RebootPrinter() {
   dwin_abort_flag = true;
   wait_for_heatup = wait_for_user = false;    // Stop waiting for heating/user
   thermalManager.disable_all_heaters();
   planner.finish_and_disable();
   DWIN_RebootScreen();
-  HAL_reboot();
+  hal.reboot();
 }
 
 void Goto_Info_Menu(){
   HMI_SaveProcessID(Info);
   Draw_Info_Menu();
 }
 
 void Goto_Move_Menu() {
   #if HAS_HOTEND
     gcode.process_subcommands_now(F("G92E0"));  // reset extruder position

commit 0564cb188f1a74dc9ecfb55b793f4225424a9ca4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Feb 5 10:30:17 2022 -0600

    üö∏ Enhanced UI => Professional UI - with updates (#23624)

diff --git a/Marlin/src/lcd/e3v2/proui/dwin.cpp b/Marlin/src/lcd/e3v2/proui/dwin.cpp
new file mode 100644
index 0000000000..4d7f38171d
--- /dev/null
+++ b/Marlin/src/lcd/e3v2/proui/dwin.cpp
@@ -0,0 +1,3975 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * Enhanced DWIN implementation
+ * Author: Miguel A. Risco-Castillo (MRISCOC)
+ * Version: 3.11.2
+ * date: 2022/01/19
+ *
+ * Based on the original code provided by Creality under GPL
+ */
+
+#include "../../../inc/MarlinConfigPre.h"
+
+#if ENABLED(DWIN_CREALITY_LCD_ENHANCED)
+
+#include "dwin.h"
+#include "dwin_popup.h"
+
+#include "../../fontutils.h"
+#include "../../marlinui.h"
+
+#include "../../../sd/cardreader.h"
+
+#include "../../../MarlinCore.h"
+#include "../../../core/serial.h"
+#include "../../../core/macros.h"
+
+#include "../../../module/temperature.h"
+#include "../../../module/printcounter.h"
+#include "../../../module/motion.h"
+#include "../../../module/planner.h"
+
+#include "../../../gcode/gcode.h"
+#include "../../../gcode/queue.h"
+
+#if HAS_FILAMENT_SENSOR
+  #include "../../../feature/runout.h"
+#endif
+
+#if ENABLED(EEPROM_SETTINGS)
+  #include "../../../module/settings.h"
+#endif
+
+#if ENABLED(HOST_ACTION_COMMANDS)
+  #include "../../../feature/host_actions.h"
+#endif
+
+#if HAS_MESH || HAS_ONESTEP_LEVELING
+  #include "../../../feature/bedlevel/bedlevel.h"
+#endif
+
+#if HAS_BED_PROBE
+  #include "../../../module/probe.h"
+#endif
+
+#ifdef BLTOUCH_HS_MODE
+  #include "../../../feature/bltouch.h"
+#endif
+
+#if EITHER(BABYSTEP_ZPROBE_OFFSET, JUST_BABYSTEP)
+  #include "../../../feature/babystep.h"
+#endif
+
+#if ENABLED(POWER_LOSS_RECOVERY)
+  #include "../../../feature/powerloss.h"
+#endif
+
+#if HAS_GCODE_PREVIEW
+  #include "gcode_preview.h"
+#endif
+
+#if HAS_ESDIAG
+  #include "endstop_diag.h"
+#endif
+
+#if HAS_MESH
+  #include "meshviewer.h"
+#endif
+
+#if ENABLED(PRINTCOUNTER)
+  #include "printstats.h"
+#endif
+
+#if ENABLED(CASE_LIGHT_MENU)
+  #include "../../../feature/caselight.h"
+#endif
+
+#if ENABLED(LED_CONTROL_MENU)
+  #include "../../../feature/leds/leds.h"
+#endif
+
+#include <WString.h>
+#include <stdio.h>
+#include <string.h>
+
+#ifndef MACHINE_SIZE
+  #define MACHINE_SIZE STRINGIFY(X_BED_SIZE) "x" STRINGIFY(Y_BED_SIZE) "x" STRINGIFY(Z_MAX_POS)
+#endif
+
+#include "lockscreen.h"
+
+#define PAUSE_HEAT
+
+#define MENU_CHAR_LIMIT  24
+
+// Print speed limit
+#define MIN_PRINT_SPEED  10
+#define MAX_PRINT_SPEED 999
+
+// Print flow limit
+#define MIN_PRINT_FLOW   10
+#define MAX_PRINT_FLOW   299
+
+// Load and Unload limits
+#define MAX_LOAD_UNLOAD  500
+
+// Feedspeed limit (max feedspeed = DEFAULT_MAX_FEEDRATE * 2)
+#define MIN_MAXFEEDSPEED      1
+#define MIN_MAXACCELERATION   1
+#define MIN_MAXJERK           0.1
+#define MIN_STEP              1
+#define MAX_STEP              999.9
+
+// Extruder's temperature limits
+#define MIN_ETEMP  HEATER_0_MINTEMP
+#define MAX_ETEMP  (HEATER_0_MAXTEMP - HOTEND_OVERSHOOT)
+
+#define FEEDRATE_E      (60)
+
+// Minimum unit (0.1) : multiple (10)
+#define UNITFDIGITS 1
+#define MINUNITMULT POW(10, UNITFDIGITS)
+
+#define ENCODER_WAIT_MS                  20
+#define DWIN_VAR_UPDATE_INTERVAL         1024
+#define DWIN_SCROLL_UPDATE_INTERVAL      SEC_TO_MS(2)
+#define DWIN_REMAIN_TIME_UPDATE_INTERVAL SEC_TO_MS(20)
+
+#define BABY_Z_VAR TERN(HAS_BED_PROBE, probe.offset.z, dwin_zoffset)
+
+// Structs
+HMI_value_t HMI_value;
+HMI_flag_t HMI_flag{0};
+HMI_data_t HMI_data;
+
+millis_t dwin_heat_time = 0;
+
+uint8_t checkkey = 255, last_checkkey = MainMenu;
+
+enum SelectItem : uint8_t {
+  PAGE_PRINT = 0,
+  PAGE_PREPARE,
+  PAGE_CONTROL,
+  PAGE_INFO_LEV_ADV,
+  PAGE_COUNT,
+
+  PRINT_SETUP = 0,
+  PRINT_PAUSE_RESUME,
+  PRINT_STOP,
+  PRINT_COUNT
+};
+
+typedef struct {
+  uint8_t now, last;
+  void set(uint8_t v) { now = last = v; }
+  void reset() { set(0); }
+  bool changed() { bool c = (now != last); if (c) last = now; return c; }
+  bool dec() { if (now) now--; return changed(); }
+  bool inc(uint8_t v) { if (now < (v - 1)) now++; else now = (v - 1); return changed(); }
+} select_t;
+
+select_t select_page{0}, select_file{0}, select_print{0};
+uint8_t index_file     = MROWS;
+
+bool dwin_abort_flag = false; // Flag to reset feedrate, return to Home
+bool hash_changed = true; // Flag to know if message status was changed
+
+constexpr float default_max_feedrate[]        = DEFAULT_MAX_FEEDRATE;
+constexpr float default_max_acceleration[]    = DEFAULT_MAX_ACCELERATION;
+
+#if HAS_CLASSIC_JERK
+  constexpr float default_max_jerk[]          = { DEFAULT_XJERK, DEFAULT_YJERK, DEFAULT_ZJERK, DEFAULT_EJERK };
+#endif
+
+static uint8_t _percent_done = 0;
+static uint32_t _remain_time = 0;
+
+// Additional Aux Host Support
+static bool sdprint = false;
+
+#if ENABLED(PAUSE_HEAT)
+  #if HAS_HOTEND
+    celsius_t resume_hotend_temp = 0;
+  #endif
+  #if HAS_HEATED_BED
+    celsius_t resume_bed_temp = 0;
+  #endif
+  #if HAS_FAN
+    uint16_t resume_fan = 0;
+  #endif
+#endif
+
+#if HAS_ZOFFSET_ITEM
+  float dwin_zoffset = 0, last_zoffset = 0;
+#endif
+
+#if HAS_HOTEND
+  float last_E = 0;
+#endif
+
+// New menu system pointers
+MenuClass *PrepareMenu = nullptr;
+MenuClass *TrammingMenu = nullptr;
+MenuClass *MoveMenu = nullptr;
+MenuClass *ControlMenu = nullptr;
+MenuClass *AdvancedSettings = nullptr;
+#if HAS_HOME_OFFSET
+  MenuClass *HomeOffMenu = nullptr;
+#endif
+#if HAS_BED_PROBE
+  MenuClass *ProbeSetMenu = nullptr;
+#endif
+MenuClass *FilSetMenu = nullptr;
+MenuClass *SelectColorMenu = nullptr;
+MenuClass *GetColorMenu = nullptr;
+MenuClass *TuneMenu = nullptr;
+MenuClass *MotionMenu = nullptr;
+MenuClass *FilamentMenu = nullptr;
+#if ENABLED(MESH_BED_LEVELING)
+  MenuClass *ManualMesh = nullptr;
+#endif
+#if HAS_HOTEND
+  MenuClass *PreheatMenu = nullptr;
+#endif
+MenuClass *TemperatureMenu = nullptr;
+MenuClass *MaxSpeedMenu = nullptr;
+MenuClass *MaxAccelMenu = nullptr;
+MenuClass *MaxJerkMenu = nullptr;
+MenuClass *StepsMenu = nullptr;
+MenuClass *HotendPIDMenu = nullptr;
+MenuClass *BedPIDMenu = nullptr;
+#if ENABLED(CASELIGHT_USES_BRIGHTNESS)
+  MenuClass *CaseLightMenu = nullptr;
+#endif
+#if ENABLED(LED_CONTROL_MENU)
+  MenuClass *LedControlMenu = nullptr;
+#endif
+#if HAS_BED_PROBE
+  MenuClass *ZOffsetWizMenu = nullptr;
+#endif
+#if ENABLED(INDIVIDUAL_AXIS_HOMING_SUBMENU)
+  MenuClass *HomingMenu = nullptr;
+#endif
+
+// Updatable menuitems pointers
+MenuItemClass *HotendTargetItem = nullptr;
+MenuItemClass *BedTargetItem = nullptr;
+MenuItemClass *FanSpeedItem = nullptr;
+MenuItemClass *MMeshMoveZItem = nullptr;
+
+#define DWIN_LANGUAGE_EEPROM_ADDRESS 0x01   // Between 0x01 and 0x63 (EEPROM_OFFSET-1)
+                                            // BL24CXX::check() uses 0x00
+
+inline bool HMI_IsChinese() { return HMI_flag.language == DWIN_CHINESE; }
+
+void HMI_SetLanguageCache() {
+  DWIN_JPG_CacheTo1(HMI_IsChinese() ? Language_Chinese : Language_English);
+}
+
+void HMI_SetLanguage() {
+  #if BOTH(EEPROM_SETTINGS, IIC_BL24CXX_EEPROM)
+    BL24CXX::read(DWIN_LANGUAGE_EEPROM_ADDRESS, (uint8_t*)&HMI_flag.language, sizeof(HMI_flag.language));
+  #endif
+  HMI_SetLanguageCache();
+}
+
+void HMI_ToggleLanguage() {
+  HMI_flag.language = HMI_IsChinese() ? DWIN_ENGLISH : DWIN_CHINESE;
+  HMI_SetLanguageCache();
+  #if BOTH(EEPROM_SETTINGS, IIC_BL24CXX_EEPROM)
+    BL24CXX::write(DWIN_LANGUAGE_EEPROM_ADDRESS, (uint8_t*)&HMI_flag.language, sizeof(HMI_flag.language));
+  #endif
+}
+
+//-----------------------------------------------------------------------------
+// Main Buttons
+//-----------------------------------------------------------------------------
+
+typedef struct { uint16_t x, y[2], w, h; } text_info_t;
+
+void ICON_Button(const bool selected, const int iconid, const frame_rect_t &ico, const text_info_t (&txt), FSTR_P caption) {
+  DWIN_ICON_Show(true, false, false, ICON, iconid + selected, ico.x, ico.y);
+  if (selected) DWINUI::Draw_Box(0, HMI_data.Highlight_Color, ico);
+  if (HMI_IsChinese()) {
+    DWIN_Frame_AreaCopy(1, txt.x, txt.y[selected], txt.x + txt.w - 1, txt.y[selected] + txt.h - 1, ico.x + (ico.w - txt.w) / 2, (ico.y + ico.h - 25) - txt.h/2);
+  }
+  else {
+    const uint16_t x = ico.x + (ico.w - strlen_P(FTOP(caption)) * DWINUI::fontWidth()) / 2,
+                   y = (ico.y + ico.h - 20) - DWINUI::fontHeight() / 2;
+    DWINUI::Draw_String(x, y, caption);
+  }
+}
+
+//
+// Main Menu: "Print"
+//
+void ICON_Print() {
+  constexpr frame_rect_t ico = { 17, 110, 110, 100 };
+  constexpr text_info_t txt = { 1, { 405, TERN(USE_STOCK_DWIN_SET, 446, 447) }, 27, 15 };
+  ICON_Button(select_page.now == PAGE_PRINT, ICON_Print_0, ico, txt, GET_TEXT_F(MSG_BUTTON_PRINT));
+}
+
+//
+// Main Menu: "Prepare"
+//
+void ICON_Prepare() {
+  constexpr frame_rect_t ico = { 145, 110, 110, 100 };
+  constexpr text_info_t txt = { 31, { 405, TERN(USE_STOCK_DWIN_SET, 446, 447) }, 27, 15 };
+  ICON_Button(select_page.now == PAGE_PREPARE, ICON_Prepare_0, ico, txt, GET_TEXT_F(MSG_PREPARE));
+}
+
+//
+// Main Menu: "Control"
+//
+void ICON_Control() {
+  constexpr frame_rect_t ico = { 17, 226, 110, 100 };
+  constexpr text_info_t txt = { 61, { 405, TERN(USE_STOCK_DWIN_SET, 446, 447) }, 27, 15 };
+  ICON_Button(select_page.now == PAGE_CONTROL, ICON_Control_0, ico, txt, GET_TEXT_F(MSG_CONTROL));
+}
+
+//
+// Main Menu: "Info"
+//
+void ICON_StartInfo() {
+  constexpr frame_rect_t ico = { 145, 226, 110, 100 };
+  constexpr text_info_t txt = { 91, { 405, TERN(USE_STOCK_DWIN_SET, 446, 447) }, 27, 15 };
+  ICON_Button(select_page.now == PAGE_INFO_LEV_ADV, ICON_Info_0, ico, txt, GET_TEXT_F(MSG_BUTTON_INFO));
+}
+
+//
+// Main Menu: "Level"
+//
+void ICON_Leveling() {
+  constexpr frame_rect_t ico = { 145, 226, 110, 100 };
+  constexpr text_info_t txt = { 211, { 405, TERN(USE_STOCK_DWIN_SET, 446, 447) }, 27, 15 };
+  ICON_Button(select_page.now == PAGE_INFO_LEV_ADV, ICON_Leveling_0, ico, txt, GET_TEXT_F(MSG_BUTTON_LEVEL));
+}
+
+//
+// Main Menu: "Advanced Settings"
+//
+void ICON_AdvSettings() {
+  constexpr frame_rect_t ico = { 145, 226, 110, 100 };
+  constexpr text_info_t txt = { 91, { 405, TERN(USE_STOCK_DWIN_SET, 446, 447) }, 27, 15 };
+  ICON_Button(select_page.now == PAGE_INFO_LEV_ADV, ICON_Info_0, ico, txt, GET_TEXT_F(MSG_BUTTON_ADVANCED));
+}
+
+//
+// Printing: "Tune"
+//
+void ICON_Tune() {
+  constexpr frame_rect_t ico = { 8, 232, 80, 100 };
+  constexpr text_info_t txt = { 121, { 405, TERN(USE_STOCK_DWIN_SET, 446, 447) }, 27, 15 };
+  ICON_Button(select_print.now == PRINT_SETUP, ICON_Setup_0, ico, txt, GET_TEXT_F(MSG_TUNE));
+}
+
+//
+// Printing: "Pause"
+//
+void ICON_Pause() {
+  constexpr frame_rect_t ico = { 96, 232, 80, 100 };
+  constexpr text_info_t txt = { 181, { 405, TERN(USE_STOCK_DWIN_SET, 446, 447) }, 27, 15 };
+  ICON_Button(select_print.now == PRINT_PAUSE_RESUME, ICON_Pause_0, ico, txt, GET_TEXT_F(MSG_BUTTON_PAUSE));
+}
+
+//
+// Printing: "Resume"
+//
+void ICON_Resume() {
+  constexpr frame_rect_t ico = { 96, 232, 80, 100 };
+  constexpr text_info_t txt = { 1, { 405, TERN(USE_STOCK_DWIN_SET, 446, 447) }, 27, 15 };
+  ICON_Button(select_print.now == PRINT_PAUSE_RESUME, ICON_Continue_0, ico, txt, GET_TEXT_F(MSG_BUTTON_RESUME));
+}
+
+//
+// Printing: "Stop"
+//
+void ICON_Stop() {
+  constexpr frame_rect_t ico = { 184, 232, 80, 100 };
+  constexpr text_info_t txt = { 151, { 405, TERN(USE_STOCK_DWIN_SET, 446, 447) }, 27, 12 };
+  ICON_Button(select_print.now == PRINT_STOP, ICON_Stop_0, ico, txt, GET_TEXT_F(MSG_BUTTON_STOP));
+}
+
+//-----------------------------------------------------------------------------
+// Drawing routines
+//-----------------------------------------------------------------------------
+
+void Draw_Menu_Cursor(const int8_t line) {
+  DWIN_Draw_Rectangle(1, HMI_data.Cursor_color, 0, MBASE(line) - 18, 14, MBASE(line + 1) - 20);
+}
+
+void Erase_Menu_Cursor(const int8_t line) {
+  DWIN_Draw_Rectangle(1, HMI_data.Background_Color, 0, MBASE(line) - 18, 14, MBASE(line + 1) - 20);
+}
+
+void Move_Highlight(const int8_t from, const int8_t newline) {
+  Erase_Menu_Cursor(newline - from);
+  Draw_Menu_Cursor(newline);
+}
+
+void Add_Menu_Line() {
+  Move_Highlight(1, MROWS);
+  DWIN_Draw_Line(HMI_data.SplitLine_Color, 16, MBASE(MROWS + 1) - 20, 256, MBASE(MROWS + 1) - 19);
+}
+
+void Scroll_Menu(const uint8_t dir) {
+  DWIN_Frame_AreaMove(1, dir, MLINE, HMI_data.Background_Color, 0, 31, DWIN_WIDTH, 349);
+  switch (dir) {
+    case DWIN_SCROLL_DOWN: Move_Highlight(-1, 0); break;
+    case DWIN_SCROLL_UP:   Add_Menu_Line(); break;
+  }
+}
+
+inline uint16_t nr_sd_menu_items() {
+  return card.get_num_Files() + !card.flag.workDirIsRoot;
+}
+
+void Erase_Menu_Text(const uint8_t line) {
+  DWIN_Draw_Rectangle(1, HMI_data.Background_Color, LBLX, MBASE(line) - 14, 271, MBASE(line) + 28);
+}
+
+void Draw_Menu_Line(const uint8_t line, const uint8_t icon=0, const char * const label=nullptr, bool more=false) {
+  if (icon)  DWINUI::Draw_Icon(icon, ICOX, MBASE(line) - 3);
+  if (label) DWINUI::Draw_String(LBLX, MBASE(line) - 1, (char*)label);
+  if (more)  DWINUI::Draw_Icon(ICON_More, VALX + 16, MBASE(line) - 3);
+  DWIN_Draw_HLine(HMI_data.SplitLine_Color, 16, MYPOS(line + 1), 240);
+}
+
+void Draw_Chkb_Line(const uint8_t line, const bool checked) {
+  DWINUI::Draw_Checkbox(HMI_data.Text_Color, HMI_data.Background_Color, VALX + 16, MBASE(line) - 1, checked);
+}
+
+void Draw_Menu_IntValue(uint16_t bcolor, const uint8_t line, uint8_t iNum, const uint16_t value=0) {
+  DWINUI::Draw_Int(HMI_data.Text_Color, bcolor, iNum , VALX, MBASE(line) - 1, value);
+}
+
+// Draw "Back" line at the top
+void Draw_Back_First(const bool is_sel=true) {
+  Draw_Menu_Line(0, ICON_Back);
+  if (HMI_IsChinese())
+    DWIN_Frame_AreaCopy(1, 129, 72, 156, 84, LBLX, MBASE(0));
+  else
+    DWINUI::Draw_String(LBLX, MBASE(0), GET_TEXT_F(MSG_BACK));
+  if (is_sel) Draw_Menu_Cursor(0);
+}
+
+inline EncoderState get_encoder_state() {
+  static millis_t Encoder_ms = 0;
+  const millis_t ms = millis();
+  if (PENDING(ms, Encoder_ms)) return ENCODER_DIFF_NO;
+  const EncoderState state = Encoder_ReceiveAnalyze();
+  if (state != ENCODER_DIFF_NO) Encoder_ms = ms + ENCODER_WAIT_MS;
+  return state;
+}
+
+template<typename T>
+inline bool Apply_Encoder(const EncoderState &encoder_diffState, T &valref) {
+  if (encoder_diffState == ENCODER_DIFF_CW)
+    valref += EncoderRate.encoderMoveValue;
+  else if (encoder_diffState == ENCODER_DIFF_CCW)
+    valref -= EncoderRate.encoderMoveValue;
+  return encoder_diffState == ENCODER_DIFF_ENTER;
+}
+
+//PopUps
+void Popup_window_PauseOrStop() {
+  if (HMI_IsChinese()) {
+    DWINUI::ClearMenuArea();
+    Draw_Popup_Bkgd();
+         if (select_print.now == PRINT_PAUSE_RESUME) DWIN_Frame_AreaCopy(1, 237, 338, 269, 356, 98, 150);
+    else if (select_print.now == PRINT_STOP) DWIN_Frame_AreaCopy(1, 221, 320, 253, 336, 98, 150);
+    DWIN_Frame_AreaCopy(1, 220, 304, 264, 319, 130, 150);
+    DWINUI::Draw_IconWB(ICON_Confirm_C, 26, 280);
+    DWINUI::Draw_IconWB(ICON_Cancel_C, 146, 280);
+    Draw_Select_Highlight(true);
+    DWIN_UpdateLCD();
+  }
+  else
+    DWIN_Popup_ConfirmCancel(ICON_BLTouch, select_print.now == PRINT_PAUSE_RESUME ? GET_TEXT_F(MSG_PAUSE_PRINT) : GET_TEXT_F(MSG_STOP_PRINT));
+}
+
+#if HAS_HOTEND
+
+  void Popup_Window_ETempTooLow() {
+    if (HMI_IsChinese()) {
+      HMI_SaveProcessID(WaitResponse);
+      DWINUI::ClearMenuArea();
+      Draw_Popup_Bkgd();
+      DWINUI::Draw_Icon(ICON_TempTooLow, 102, 105);
+      DWIN_Frame_AreaCopy(1, 103, 371, 136, 386,  69, 240);
+      DWIN_Frame_AreaCopy(1, 170, 371, 270, 386, 102, 240);
+      DWINUI::Draw_IconWB(ICON_Confirm_C, 86, 280);
+      DWIN_UpdateLCD();
+    }
+    else
+      DWIN_Popup_Confirm(ICON_TempTooLow, GET_TEXT_F(MSG_HOTEND_TOO_COLD), GET_TEXT_F(MSG_PLEASE_PREHEAT));
+  }
+
+#endif
+
+#if HAS_HOTEND || HAS_HEATED_BED
+  void DWIN_Popup_Temperature(const bool toohigh) {
+    DWINUI::ClearMenuArea();
+    Draw_Popup_Bkgd();
+    if (HMI_IsChinese()) {
+      if (toohigh) {
+        DWINUI::Draw_Icon(ICON_TempTooHigh, 102, 165);
+        DWIN_Frame_AreaCopy(1, 103, 371, 237, 386, 52, 285);
+        DWIN_Frame_AreaCopy(1, 151, 389, 185, 402, 187, 285);
+        DWIN_Frame_AreaCopy(1, 189, 389, 271, 402, 95, 310);
+      }
+      else {
+        DWINUI::Draw_Icon(ICON_TempTooLow, 102, 165);
+        DWIN_Frame_AreaCopy(1, 103, 371, 270, 386, 52, 285);
+        DWIN_Frame_AreaCopy(1, 189, 389, 271, 402, 95, 310);
+      }
+    }
+    else {
+      DWIN_Draw_Popup(toohigh ? ICON_TempTooHigh : ICON_TempTooLow, F("Nozzle or Bed temperature"), toohigh ? F("is too high") : F("is too low"));
+    }
+  }
+#endif
+
+// Draw status line
+void DWIN_DrawStatusLine(const uint16_t color, const uint16_t bgcolor, const char *text, const bool center = true) {
+  DWIN_Draw_Rectangle(1, bgcolor, 0, STATUS_Y, DWIN_WIDTH, STATUS_Y + 20);
+  if (text) {
+    if (center) DWINUI::Draw_CenteredString(color, STATUS_Y + 2, text);
+    else        DWINUI::Draw_String(color, 0, STATUS_Y + 2, text);
+  }
+  DWIN_UpdateLCD();
+}
+void DWIN_DrawStatusLine(const char *text, const bool center = true) {
+  DWIN_DrawStatusLine(HMI_data.StatusTxt_Color, HMI_data.StatusBg_Color, text, center);
+}
+
+// Clear & reset status line
+void DWIN_ResetStatusLine() {
+  ui.status_message[0] = 0;
+  DWIN_CheckStatusMessage();
+}
+
+// Djb2 hash algorithm
+void DWIN_CheckStatusMessage() {
+  static uint32_t old_hash = 0;
+  char * str = &ui.status_message[0];
+  uint32_t hash = 5381;
+  char c;
+  while ((c = *str++)) hash = ((hash << 5) + hash) + c; /* hash * 33 + c */
+  hash_changed = hash != old_hash;
+  old_hash = hash;
+};
+
+void DWIN_DrawStatusMessage() {
+  const uint8_t max_status_chars = DWIN_WIDTH / DWINUI::fontWidth();
+
+  #if ENABLED(STATUS_MESSAGE_SCROLLING)
+
+    // Get the UTF8 character count of the string
+    uint8_t slen = utf8_strlen(ui.status_message);
+
+    // If the string fits the status line do not scroll it
+    if (slen <= max_status_chars) {
+       if (hash_changed) {
+         DWIN_DrawStatusLine(HMI_data.StatusTxt_Color, HMI_data.StatusBg_Color, ui.status_message);
+         hash_changed = false;
+       }
+    }
+    else {
+      // String is larger than the available line space
+
+      // Get a pointer to the next valid UTF8 character
+      // and the string remaining length
+      uint8_t rlen;
+      const char *stat = MarlinUI::status_and_len(rlen);
+      DWIN_Draw_Rectangle(1, HMI_data.StatusBg_Color, 0, STATUS_Y, DWIN_WIDTH, STATUS_Y + 20);
+      DWINUI::MoveTo(0, STATUS_Y + 2);
+      DWINUI::Draw_String(stat, max_status_chars);
+
+      // If the string doesn't completely fill the line...
+      if (rlen < max_status_chars) {
+        DWINUI::Draw_Char('.');                   // Always at 1+ spaces left, draw a dot
+        uint8_t chars = max_status_chars - rlen;  // Amount of space left in characters
+        if (--chars) {                            // Draw a second dot if there's space
+          DWINUI::Draw_Char('.');
+          if (--chars)
+            DWINUI::Draw_String(ui.status_message, chars); // Print a second copy of the message
+        }
+      }
+      MarlinUI::advance_status_scroll();
+    }
+
+  #else
+
+    if (hash_changed) {
+      ui.status_message[max_status_chars] = 0;
+      DWIN_DrawStatusLine(HMI_data.StatusTxt_Color, HMI_data.StatusBg_Color, ui.status_message);
+      hash_changed = false;
+    }
+
+  #endif
+}
+
+void Draw_Print_Labels() {
+  if (HMI_IsChinese()) {
+    DWIN_Frame_AreaCopy(1,  0, 72,  63, 86,  41, 173);  // Printing Time
+    DWIN_Frame_AreaCopy(1, 65, 72, 128, 86, 176, 173);  // Remain
+  }
+  else {
+    DWINUI::Draw_String( 46, 173, GET_TEXT_F(MSG_INFO_PRINT_TIME));
+    DWINUI::Draw_String(181, 173, GET_TEXT_F(MSG_REMAINING_TIME));
+  }
+}
+
+void Draw_Print_ProgressBar() {
+  DWINUI::Draw_IconWB(ICON_Bar, 15, 93);
+  DWIN_Draw_Rectangle(1, HMI_data.Barfill_Color, 16 + _percent_done * 240 / 100, 93, 256, 113);
+  DWINUI::Draw_Int(HMI_data.PercentTxt_Color, HMI_data.Background_Color, 3, 117, 133, _percent_done);
+  DWINUI::Draw_String(HMI_data.PercentTxt_Color, 142, 133, F("%"));
+}
+
+void Draw_Print_ProgressElapsed() {
+  char buf[10];
+  duration_t elapsed = print_job_timer.duration(); // print timer
+  sprintf_P(buf, PSTR("%02i:%02i"), (uint16_t)(elapsed.value / 3600), ((uint16_t)elapsed.value % 3600) / 60);
+  DWINUI::Draw_String(HMI_data.Text_Color, HMI_data.Background_Color, 47, 192, buf);
+}
+
+void Draw_Print_ProgressRemain() {
+  char buf[10];
+  sprintf_P(buf, PSTR("%02i:%02i"), (uint16_t)(_remain_time / 3600), ((uint16_t)_remain_time % 3600) / 60);
+  DWINUI::Draw_String(HMI_data.Text_Color, HMI_data.Background_Color, 181, 192, buf);
+}
+
+void ICON_ResumeOrPause() {
+  if (printingIsPaused() || HMI_flag.pause_flag || HMI_flag.pause_action)
+    ICON_Resume();
+  else
+    ICON_Pause();
+}
+
+void Draw_PrintProcess() {
+  if (HMI_IsChinese())
+    Title.FrameCopy(30, 1, 42, 14);                     // "Printing"
+  else
+    Title.ShowCaption(GET_TEXT_F(MSG_PRINTING));
+  DWINUI::ClearMenuArea();
+  DWIN_Print_Header(sdprint ? card.longest_filename() : nullptr);
+  Draw_Print_Labels();
+  DWINUI::Draw_Icon(ICON_PrintTime, 15, 173);
+  DWINUI::Draw_Icon(ICON_RemainTime, 150, 171);
+  Draw_Print_ProgressBar();
+  Draw_Print_ProgressElapsed();
+  Draw_Print_ProgressRemain();
+  ICON_Tune();
+  ICON_ResumeOrPause();
+  ICON_Stop();
+  DWIN_UpdateLCD();
+}
+
+void Goto_PrintProcess() {
+  if (checkkey == PrintProcess) {
+    ICON_ResumeOrPause();
+    DWIN_UpdateLCD();
+    return;
+  }
+  checkkey = PrintProcess;
+  Draw_PrintProcess();
+}
+
+void Draw_PrintDone() {
+  // show percent bar and value
+  _percent_done = 100;
+  _remain_time = 0;
+
+  Title.ShowCaption(GET_TEXT_F(MSG_PRINT_DONE));
+  DWINUI::ClearMenuArea();
+  DWIN_Print_Header(nullptr);
+  Draw_Print_ProgressBar();
+  Draw_Print_Labels();
+  DWINUI::Draw_Icon(ICON_PrintTime, 15, 173);
+  DWINUI::Draw_Icon(ICON_RemainTime, 150, 171);
+  Draw_Print_ProgressElapsed();
+  Draw_Print_ProgressRemain();
+  // show print done confirm
+  DWINUI::Draw_IconWB(HMI_IsChinese() ? ICON_Confirm_C : ICON_Confirm_E, 86, 273);
+  DWIN_UpdateLCD();
+}
+
+void Draw_Main_Menu() {
+  DWINUI::ClearMenuArea();
+  if (HMI_IsChinese())
+    Title.FrameCopy(2, 2, 26, 13);   // "Home" etc
+  else
+    Title.ShowCaption(MACHINE_NAME);
+  DWINUI::Draw_Icon(ICON_LOGO, 71, 52);  // CREALITY logo
+  ICON_Print();
+  ICON_Prepare();
+  ICON_Control();
+  ICON_AdvSettings();
+  DWIN_UpdateLCD();
+}
+
+void Goto_Main_Menu() {
+  if (checkkey == MainMenu) return;
+  checkkey = MainMenu;
+  ui.reset_status(true);
+  Draw_Main_Menu();
+}
+
+// Draw X, Y, Z and blink if in an un-homed or un-trusted state
+void _update_axis_value(const AxisEnum axis, const uint16_t x, const uint16_t y, const bool blink, const bool force) {
+  const bool draw_qmark = axis_should_home(axis),
+             draw_empty = NONE(HOME_AFTER_DEACTIVATE, DISABLE_REDUCED_ACCURACY_WARNING) && !draw_qmark && !axis_is_trusted(axis);
+
+  // Check for a position change
+  static xyz_pos_t oldpos = { -1, -1, -1 };
+  const float p = current_position[axis];
+  const bool changed = oldpos[axis] != p;
+  if (changed) oldpos[axis] = p;
+
+  if (force || changed || draw_qmark || draw_empty) {
+    if (blink && draw_qmark)
+      DWINUI::Draw_String(HMI_data.Coordinate_Color, HMI_data.Background_Color, x, y, F(" - ? -"));
+    else if (blink && draw_empty)
+      DWINUI::Draw_String(HMI_data.Coordinate_Color, HMI_data.Background_Color, x, y, F("     "));
+    else
+      DWINUI::Draw_Signed_Float(HMI_data.Coordinate_Color, HMI_data.Background_Color, 3, 2, x, y, p);
+  }
+}
+
+void _draw_xyz_position(const bool force) {
+  //SERIAL_ECHOPGM("Draw XYZ:");
+  static bool _blink = false;
+  const bool blink = !!(millis() & 0x400UL);
+  if (force || blink != _blink) {
+    _blink = blink;
+    //SERIAL_ECHOPGM(" (blink)");
+    _update_axis_value(X_AXIS,  35, 459, blink, true);
+    _update_axis_value(Y_AXIS, 120, 459, blink, true);
+    _update_axis_value(Z_AXIS, 205, 459, blink, true);
+  }
+  //SERIAL_EOL();
+}
+
+void update_variable() {
+  #if HAS_HOTEND
+    static celsius_t _hotendtemp = 0, _hotendtarget = 0;
+    const celsius_t hc = thermalManager.wholeDegHotend(0),
+                    ht = thermalManager.degTargetHotend(0);
+    const bool _new_hotend_temp = _hotendtemp != hc,
+               _new_hotend_target = _hotendtarget != ht;
+    if (_new_hotend_temp) _hotendtemp = hc;
+    if (_new_hotend_target) _hotendtarget = ht;
+  #endif
+  #if HAS_HEATED_BED
+    static celsius_t _bedtemp = 0, _bedtarget = 0;
+    const celsius_t bc = thermalManager.wholeDegBed(),
+                    bt = thermalManager.degTargetBed();
+    const bool _new_bed_temp = _bedtemp != bc,
+               _new_bed_target = _bedtarget != bt;
+    if (_new_bed_temp) _bedtemp = bc;
+    if (_new_bed_target) _bedtarget = bt;
+  #endif
+  #if HAS_FAN
+    static uint8_t _fanspeed = 0;
+    const bool _new_fanspeed = _fanspeed != thermalManager.fan_speed[0];
+    if (_new_fanspeed) _fanspeed = thermalManager.fan_speed[0];
+  #endif
+
+  if (checkkey == Menu && (CurrentMenu == TuneMenu || CurrentMenu == TemperatureMenu)) {
+    // Tune page temperature update
+    #if HAS_HOTEND
+      if (_new_hotend_target)
+        HotendTargetItem->draw(CurrentMenu->line(HotendTargetItem->pos));
+    #endif
+    #if HAS_HEATED_BED
+      if (_new_bed_target)
+        BedTargetItem->draw(CurrentMenu->line(BedTargetItem->pos));
+    #endif
+    #if HAS_FAN
+      if (_new_fanspeed)
+        FanSpeedItem->draw(CurrentMenu->line(FanSpeedItem->pos));
+    #endif
+  }
+
+  // Bottom temperature update
+
+  #if HAS_HOTEND
+    if (_new_hotend_temp)
+      DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 28, 384, _hotendtemp);
+    if (_new_hotend_target)
+      DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 25 + 4 * STAT_CHR_W + 6, 384, _hotendtarget);
+
+    static int16_t _flow = planner.flow_percentage[0];
+    if (_flow != planner.flow_percentage[0]) {
+      _flow = planner.flow_percentage[0];
+      DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 116 + 2 * STAT_CHR_W, 417, _flow);
+    }
+  #endif
+
+  #if HAS_HEATED_BED
+    if (_new_bed_temp)
+      DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 28, 417, _bedtemp);
+    if (_new_bed_target)
+      DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 25 + 4 * STAT_CHR_W + 6, 417, _bedtarget);
+  #endif
+
+  static int16_t _feedrate = 100;
+  if (_feedrate != feedrate_percentage) {
+    _feedrate = feedrate_percentage;
+    DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 116 + 2 * STAT_CHR_W, 384, _feedrate);
+  }
+
+  #if HAS_FAN
+    if (_new_fanspeed) {
+      _fanspeed = thermalManager.fan_speed[0];
+      DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 195 + 2 * STAT_CHR_W, 384, _fanspeed);
+    }
+  #endif
+
+  static float _offset = 0;
+  if (BABY_Z_VAR != _offset) {
+    _offset = BABY_Z_VAR;
+    DWINUI::Draw_Signed_Float(DWIN_FONT_STAT, HMI_data.Indicator_Color,  HMI_data.Background_Color, 2, 2, 210, 417, _offset);
+  }
+
+  #if HAS_MESH
+    static bool _leveling_active = false;
+    if (_leveling_active != planner.leveling_active) {
+      _leveling_active = planner.leveling_active;
+      DWIN_Draw_Box(1, HMI_data.Background_Color, 186, 416, 20, 20);
+      if (_leveling_active)
+        DWINUI::Draw_Icon(ICON_SetZOffset, 186, 416);
+      else
+        DWINUI::Draw_Icon(ICON_Zoffset, 187, 416);
+    }
+  #endif
+
+  _draw_xyz_position(false);
+}
+
+/**
+ * Read and cache the working directory.
+ *
+ * TODO: New code can follow the pattern of menu_media.cpp
+ * and rely on Marlin caching for performance. No need to
+ * cache files here.
+ */
+
+#ifndef strcasecmp_P
+  #define strcasecmp_P(a, b) strcasecmp((a), (b))
+#endif
+
+void make_name_without_ext(char *dst, char *src, size_t maxlen=MENU_CHAR_LIMIT) {
+  size_t pos = strlen(src);  // index of ending nul
+
+  // For files, remove the extension
+  // which may be .gcode, .gco, or .g
+  if (!card.flag.filenameIsDir)
+    while (pos && src[pos] != '.') pos--; // find last '.' (stop at 0)
+
+  if (!pos) pos = strlen(src);  // pos = 0 ('.' not found) restore pos
+
+  size_t len = pos;   // nul or '.'
+  if (len > maxlen) { // Keep the name short
+    pos        = len = maxlen; // move nul down
+    dst[--pos] = '.'; // insert dots
+    dst[--pos] = '.';
+    dst[--pos] = '.';
+  }
+
+  dst[len] = '\0';    // end it
+
+  // Copy down to 0
+  while (pos--) dst[pos] = src[pos];
+}
+
+void HMI_SDCardInit() { card.cdroot(); }
+
+// Initialize or re-initialize the LCD
+void MarlinUI::init_lcd() { DWIN_Startup(); }
+
+void MarlinUI::refresh() { /* Nothing to see here */ }
+
+#if HAS_LCD_BRIGHTNESS
+  void MarlinUI::_set_brightness() { DWIN_LCD_Brightness(backlight ? brightness : 0); }
+#endif
+
+#if ENABLED(SCROLL_LONG_FILENAMES)
+
+  char shift_name[LONG_FILENAME_LENGTH + 1];
+  int8_t shift_amt; // = 0
+  millis_t shift_ms; // = 0
+
+  // Init the shift name based on the highlighted item
+  void Init_Shift_Name() {
+    const bool is_subdir = !card.flag.workDirIsRoot;
+    const int8_t filenum = select_file.now - 1 - is_subdir; // Skip "Back" and ".."
+    const uint16_t fileCnt = card.get_num_Files();
+    if (WITHIN(filenum, 0, fileCnt - 1)) {
+      card.getfilename_sorted(SD_ORDER(filenum, fileCnt));
+      char * const name = card.longest_filename();
+      make_name_without_ext(shift_name, name, 100);
+    }
+  }
+
+  void Init_SDItem_Shift() {
+    shift_amt = 0;
+    shift_ms = select_file.now > 0 && strlen(shift_name) > MENU_CHAR_LIMIT ? millis() + 750UL : 0;
+  }
+
+#endif
+
+/**
+ * Display an SD item, adding a CDUP for subfolders.
+ */
+void Draw_SDItem(const uint16_t item, int16_t row=-1) {
+  if (row < 0) row = item + 1 + MROWS - index_file;
+  const bool is_subdir = !card.flag.workDirIsRoot;
+  if (is_subdir && item == 0)
+    return Draw_Menu_Line(row, ICON_Folder, "..");
+
+  card.getfilename_sorted(SD_ORDER(item - is_subdir, card.get_num_Files()));
+  char * const name = card.longest_filename();
+
+  #if ENABLED(SCROLL_LONG_FILENAMES)
+    // Init the current selected name
+    // This is used during scroll drawing
+    if (item == select_file.now - 1) {
+      make_name_without_ext(shift_name, name, 100);
+      Init_SDItem_Shift();
+    }
+  #endif
+
+  // Draw the file/folder with name aligned left
+  char str[strlen(name) + 1];
+  make_name_without_ext(str, name);
+  Draw_Menu_Line(row, card.flag.filenameIsDir ? ICON_Folder : ICON_File, str);
+}
+
+#if ENABLED(SCROLL_LONG_FILENAMES)
+
+  void Draw_SDItem_Shifted(uint8_t &shift) {
+    // Limit to the number of chars past the cutoff
+    const size_t len = strlen(shift_name);
+    NOMORE(shift, _MAX(len - MENU_CHAR_LIMIT, 0U));
+
+    // Shorten to the available space
+    const size_t lastchar = _MIN((signed)len, shift + MENU_CHAR_LIMIT);
+
+    const char c = shift_name[lastchar];
+    shift_name[lastchar] = '\0';
+
+    const uint8_t row = select_file.now + MROWS - index_file; // skip "Back" and scroll
+    Erase_Menu_Text(row);
+    Draw_Menu_Line(row, 0, &shift_name[shift]);
+
+    shift_name[lastchar] = c;
+  }
+
+#endif
+
+// Redraw the first set of SD Files
+void Redraw_SD_List() {
+  select_file.reset();
+  index_file = MROWS;
+
+  DWINUI::ClearMenuArea(); // Leave title bar unchanged
+
+  Draw_Back_First();
+
+  if (card.isMounted()) {
+    // As many files as will fit
+    LOOP_L_N(i, _MIN(nr_sd_menu_items(), MROWS))
+      Draw_SDItem(i, i + 1);
+
+    TERN_(SCROLL_LONG_FILENAMES, Init_SDItem_Shift());
+  }
+  else {
+    DWIN_Draw_Rectangle(1, HMI_data.AlertBg_Color, 10, MBASE(3) - 10, DWIN_WIDTH - 10, MBASE(4));
+    DWINUI::Draw_CenteredString(font12x24, HMI_data.AlertTxt_Color, MBASE(3), GET_TEXT_F(MSG_MEDIA_NOT_INSERTED));
+  }
+}
+
+bool DWIN_lcd_sd_status = false;
+
+void SDCard_Up() {
+  card.cdup();
+  Redraw_SD_List();
+  DWIN_lcd_sd_status = false; // On next DWIN_Update
+}
+
+void SDCard_Folder(char * const dirname) {
+  card.cd(dirname);
+  Redraw_SD_List();
+  DWIN_lcd_sd_status = false; // On next DWIN_Update
+}
+
+//
+// Watch for media mount / unmount
+//
+void HMI_SDCardUpdate() {
+  if (HMI_flag.home_flag) return;
+  if (DWIN_lcd_sd_status != card.isMounted()) {
+    DWIN_lcd_sd_status = card.isMounted();
+    //SERIAL_ECHOLNPGM("HMI_SDCardUpdate: ", DWIN_lcd_sd_status);
+    if (DWIN_lcd_sd_status) {  // Media inserted
+      if (checkkey == SelectFile)
+        Redraw_SD_List();
+    }
+    else {    // Media removed
+      // clean file icon
+      if (checkkey == SelectFile) {
+        Redraw_SD_List();
+      }
+      else if (sdprint && card.isPrinting() && printingIsActive()) {
+        // TODO: Move card removed abort handling
+        //       to CardReader::manage_media.
+        card.abortFilePrintSoon();
+        wait_for_heatup = wait_for_user = false;
+        dwin_abort_flag = true; // Reset feedrate, return to Home
+      }
+    }
+    DWIN_UpdateLCD();
+  }
+}
+
+//
+// The status area is always on-screen, except during
+// full-screen modal dialogs. (TODO: Keep alive during dialogs)
+//
+void Draw_Status_Area(const bool with_update) {
+
+  DWIN_Draw_Rectangle(1, HMI_data.Background_Color, 0, STATUS_Y + 21, DWIN_WIDTH, DWIN_HEIGHT - 1);
+
+  #if HAS_HOTEND
+    DWINUI::Draw_Icon(ICON_HotendTemp, 10, 383);
+    DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 28, 384, thermalManager.wholeDegHotend(0));
+    DWINUI::Draw_String(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 25 + 3 * STAT_CHR_W + 5, 384, F("/"));
+    DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 25 + 4 * STAT_CHR_W + 6, 384, thermalManager.degTargetHotend(0));
+
+    DWINUI::Draw_Icon(ICON_StepE, 112, 417);
+    DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 116 + 2 * STAT_CHR_W, 417, planner.flow_percentage[0]);
+    DWINUI::Draw_String(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 116 + 5 * STAT_CHR_W + 2, 417, F("%"));
+  #endif
+
+  #if HAS_HEATED_BED
+    DWINUI::Draw_Icon(ICON_BedTemp, 10, 416);
+    DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 28, 417, thermalManager.wholeDegBed());
+    DWINUI::Draw_String(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 25 + 3 * STAT_CHR_W + 5, 417, F("/"));
+    DWINUI::Draw_Int(true, true, 0, DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 25 + 4 * STAT_CHR_W + 6, 417, thermalManager.degTargetBed());
+  #endif
+
+  DWINUI::Draw_Icon(ICON_Speed, 113, 383);
+  DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 116 + 2 * STAT_CHR_W, 384, feedrate_percentage);
+  DWINUI::Draw_String(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 116 + 5 * STAT_CHR_W + 2, 384, F("%"));
+
+  #if HAS_FAN
+    DWINUI::Draw_Icon(ICON_FanSpeed, 187, 383);
+    DWINUI::Draw_Int(DWIN_FONT_STAT, HMI_data.Indicator_Color, HMI_data.Background_Color, 3, 195 + 2 * STAT_CHR_W, 384, thermalManager.fan_speed[0]);
+  #endif
+
+  #if HAS_ZOFFSET_ITEM
+    DWINUI::Draw_Icon(planner.leveling_active ? ICON_SetZOffset : ICON_Zoffset, 187, 416);
+  #endif
+
+  DWINUI::Draw_Signed_Float(DWIN_FONT_STAT, HMI_data.Indicator_Color,  HMI_data.Background_Color, 2, 2, 210, 417, BABY_Z_VAR);
+
+  DWIN_Draw_Rectangle(1, HMI_data.SplitLine_Color, 0, 449, DWIN_WIDTH, 451);
+
+  DWINUI::Draw_Icon(ICON_MaxSpeedX,  10, 456);
+  DWINUI::Draw_Icon(ICON_MaxSpeedY,  95, 456);
+  DWINUI::Draw_Icon(ICON_MaxSpeedZ, 180, 456);
+  _draw_xyz_position(true);
+
+  if (with_update) {
+    DWIN_UpdateLCD();
+    delay(5);
+  }
+}
+
+void HMI_StartFrame(const bool with_update) {
+  Goto_Main_Menu();
+  DWIN_DrawStatusLine(nullptr);
+  Draw_Status_Area(with_update);
+}
+
+void Draw_Info_Menu() {
+  DWINUI::ClearMenuArea();
+  Draw_Back_First();
+  if (HMI_IsChinese())
+    Title.FrameCopy(30, 17, 28, 13);                        // "Info"
+  else
+    Title.ShowCaption(GET_TEXT_F(MSG_INFO_SCREEN));
+
+  if (HMI_IsChinese()) {
+    DWIN_Frame_AreaCopy(1, 197, 149, 252, 161, 108, 102);   // "Size"
+    DWIN_Frame_AreaCopy(1,   1, 164,  56, 176, 108, 175);   // "Firmware Version"
+    DWIN_Frame_AreaCopy(1,  58, 164, 113, 176, 105, 248);   // "Contact Details"
+    DWINUI::Draw_CenteredString(268, F(CORP_WEBSITE));
+  }
+  else {
+    DWINUI::Draw_CenteredString(102, F("Size"));
+    DWINUI::Draw_CenteredString(175, F("Firmware version"));
+    DWINUI::Draw_CenteredString(248, F("Build Datetime"));
+    DWINUI::Draw_CenteredString(268, F(STRING_DISTRIBUTION_DATE));
+  }
+  DWINUI::Draw_CenteredString(122, F(MACHINE_SIZE));
+  DWINUI::Draw_CenteredString(195, F(SHORT_BUILD_VERSION));
+
+  LOOP_L_N(i, 3) {
+    DWINUI::Draw_Icon(ICON_PrintSize + i, ICOX, 99 + i * 73);
+    DWIN_Draw_HLine(HMI_data.SplitLine_Color, 16, MBASE(2) + i * 73, 240);
+  }
+
+  DWIN_UpdateLCD();
+}
+
+void Draw_Print_File_Menu() {
+  if (HMI_IsChinese())
+    Title.FrameCopy(0, 31, 56, 14);    // "Print file"
+  else
+    Title.ShowCaption(GET_TEXT_F(MSG_MEDIA_MENU));
+  Redraw_SD_List();
+}
+
+// Main Process
+void HMI_MainMenu() {
+  EncoderState encoder_diffState = get_encoder_state();
+  if (encoder_diffState == ENCODER_DIFF_NO) return;
+
+  if (encoder_diffState == ENCODER_DIFF_CW) {
+    if (select_page.inc(PAGE_COUNT)) {
+      switch (select_page.now) {
+        case PAGE_PRINT: ICON_Print(); break;
+        case PAGE_PREPARE: ICON_Print(); ICON_Prepare(); break;
+        case PAGE_CONTROL: ICON_Prepare(); ICON_Control(); break;
+        case PAGE_INFO_LEV_ADV: ICON_Control(); ICON_AdvSettings(); break;
+      }
+    }
+  }
+  else if (encoder_diffState == ENCODER_DIFF_CCW) {
+    if (select_page.dec()) {
+      switch (select_page.now) {
+        case PAGE_PRINT: ICON_Print(); ICON_Prepare(); break;
+        case PAGE_PREPARE: ICON_Prepare(); ICON_Control(); break;
+        case PAGE_CONTROL: ICON_Control(); ICON_AdvSettings(); break;
+        case PAGE_INFO_LEV_ADV: ICON_AdvSettings(); break;
+      }
+    }
+  }
+  else if (encoder_diffState == ENCODER_DIFF_ENTER) {
+    switch (select_page.now) {
+      case PAGE_PRINT:
+        checkkey = SelectFile;
+        card.mount();
+        Draw_Print_File_Menu();
+        break;
+
+      case PAGE_PREPARE: Draw_Prepare_Menu(); break;
+
+      case PAGE_CONTROL: Draw_Control_Menu(); break;
+
+      case PAGE_INFO_LEV_ADV: Draw_AdvancedSettings_Menu(); break;
+    }
+  }
+  DWIN_UpdateLCD();
+}
+
+// Select (and Print) File
+void HMI_SelectFile() {
+  EncoderState encoder_diffState = get_encoder_state();
+
+  const uint16_t hasUpDir = !card.flag.workDirIsRoot;
+
+  if (encoder_diffState == ENCODER_DIFF_NO) {
+    #if ENABLED(SCROLL_LONG_FILENAMES)
+      if (shift_ms && select_file.now >= 1 + hasUpDir) {
+        // Scroll selected filename every second
+        const millis_t ms = millis();
+        if (ELAPSED(ms, shift_ms)) {
+          const bool was_reset = shift_amt < 0;
+          shift_ms = ms + 375UL + was_reset * 250UL;  // ms per character
+          uint8_t shift_new = shift_amt + 1;          // Try to shift by...
+          Draw_SDItem_Shifted(shift_new);             // Draw the item
+          if (!was_reset && shift_new == 0)           // Was it limited to 0?
+            shift_ms = 0;                             // No scrolling needed
+          else if (shift_new == shift_amt)            // Scroll reached the end
+            shift_new = -1;                           // Reset
+          shift_amt = shift_new;                      // Set new scroll
+        }
+      }
+    #endif
+    return;
+  }
+
+  // First pause is long. Easy.
+  // On reset, long pause must be after 0.
+
+  const uint16_t fullCnt = nr_sd_menu_items();
+
+  if (encoder_diffState == ENCODER_DIFF_CW && fullCnt) {
+    if (select_file.inc(1 + fullCnt)) {
+      const uint8_t itemnum = select_file.now - 1;              // -1 for "Back"
+      if (TERN0(SCROLL_LONG_FILENAMES, shift_ms)) {             // If line was shifted
+        Erase_Menu_Text(itemnum + MROWS - index_file);          // Erase and
+        Draw_SDItem(itemnum - 1);                               // redraw
+      }
+      if (select_file.now > MROWS && select_file.now > index_file) { // Cursor past the bottom
+        index_file = select_file.now;                           // New bottom line
+        Scroll_Menu(DWIN_SCROLL_UP);
+        Draw_SDItem(itemnum, MROWS);                            // Draw and init the shift name
+      }
+      else {
+        Move_Highlight(1, select_file.now + MROWS - index_file); // Just move highlight
+        TERN_(SCROLL_LONG_FILENAMES, Init_Shift_Name());         // ...and init the shift name
+      }
+      TERN_(SCROLL_LONG_FILENAMES, Init_SDItem_Shift());
+    }
+  }
+  else if (encoder_diffState == ENCODER_DIFF_CCW && fullCnt) {
+    if (select_file.dec()) {
+      const uint8_t itemnum = select_file.now - 1;              // -1 for "Back"
+      if (TERN0(SCROLL_LONG_FILENAMES, shift_ms)) {             // If line was shifted
+        Erase_Menu_Text(select_file.now + 1 + MROWS - index_file); // Erase and
+        Draw_SDItem(itemnum + 1);                               // redraw
+      }
+      if (select_file.now < index_file - MROWS) {               // Cursor past the top
+        index_file--;                                           // New bottom line
+        Scroll_Menu(DWIN_SCROLL_DOWN);
+        if (index_file == MROWS) {
+          Draw_Back_First();
+          TERN_(SCROLL_LONG_FILENAMES, shift_ms = 0);
+        }
+        else {
+          Draw_SDItem(itemnum, 0);                              // Draw the item (and init shift name)
+        }
+      }
+      else {
+        Move_Highlight(-1, select_file.now + MROWS - index_file); // Just move highlight
+        TERN_(SCROLL_LONG_FILENAMES, Init_Shift_Name());        // ...and init the shift name
+      }
+      TERN_(SCROLL_LONG_FILENAMES, Init_SDItem_Shift());        // Reset left. Init timer.
+    }
+  }
+  else if (encoder_diffState == ENCODER_DIFF_ENTER) {
+    if (select_file.now == 0) { // Back
+      select_page.set(PAGE_PRINT);
+      Goto_Main_Menu();
+    }
+    else if (hasUpDir && select_file.now == 1) { // CD-Up
+      SDCard_Up();
+      goto HMI_SelectFileExit;
+    }
+    else {
+      const uint16_t filenum = select_file.now - 1 - hasUpDir;
+      card.getfilename_sorted(SD_ORDER(filenum, card.get_num_Files()));
+
+      // Enter that folder!
+      if (card.flag.filenameIsDir) {
+        SDCard_Folder(card.filename);
+        goto HMI_SelectFileExit;
+      }
+
+      // Reset highlight for next entry
+      select_print.reset();
+      select_file.reset();
+
+      // Start choice and print SD file
+      HMI_flag.heat_flag = true;
+      HMI_flag.print_finish = false;
+
+      card.openAndPrintFile(card.filename);
+
+      #if HAS_FAN
+        // All fans on for Ender 3 v2 ?
+        // The slicer should manage this for us.
+        //for (uint8_t i = 0; i < FAN_COUNT; i++)
+        //  thermalManager.fan_speed[i] = 255;
+      #endif
+
+      DWIN_Print_Started(true);
+    }
+  }
+
+  HMI_SelectFileExit:
+  DWIN_UpdateLCD();
+}
+
+// Printing
+void HMI_Printing() {
+  EncoderState encoder_diffState = get_encoder_state();
+  if (encoder_diffState == ENCODER_DIFF_NO) return;
+  // Avoid flicker by updating only the previous menu
+  if (encoder_diffState == ENCODER_DIFF_CW) {
+    if (select_print.inc(PRINT_COUNT)) {
+      switch (select_print.now) {
+        case PRINT_SETUP: ICON_Tune(); break;
+        case PRINT_PAUSE_RESUME: ICON_Tune(); ICON_ResumeOrPause(); break;
+        case PRINT_STOP: ICON_ResumeOrPause(); ICON_Stop(); break;
+      }
+    }
+  }
+  else if (encoder_diffState == ENCODER_DIFF_CCW) {
+    if (select_print.dec()) {
+      switch (select_print.now) {
+        case PRINT_SETUP: ICON_Tune(); ICON_ResumeOrPause(); break;
+        case PRINT_PAUSE_RESUME: ICON_ResumeOrPause(); ICON_Stop(); break;
+        case PRINT_STOP: ICON_Stop(); break;
+      }
+    }
+  }
+  else if (encoder_diffState == ENCODER_DIFF_ENTER) {
+    switch (select_print.now) {
+      case PRINT_SETUP: Draw_Tune_Menu(); break;
+      case PRINT_PAUSE_RESUME:
+        if (HMI_flag.pause_flag) {
+          ICON_Pause();
+          #if DISABLED(ADVANCED_PAUSE_FEATURE)
+            char cmd[40];
+            cmd[0] = '\0';
+            #if BOTH(HAS_HEATED_BED, PAUSE_HEAT)
+              if (resume_bed_temp) sprintf_P(cmd, PSTR("M190 S%i\n"), resume_bed_temp);
+            #endif
+            #if BOTH(HAS_HOTEND, PAUSE_HEAT)
+              if (resume_hotend_temp) sprintf_P(&cmd[strlen(cmd)], PSTR("M109 S%i\n"), resume_hotend_temp);
+            #endif
+            #if HAS_FAN
+              if (resume_fan) thermalManager.fan_speed[0] = resume_fan;
+            #endif
+            strcat_P(cmd, M24_STR);
+            queue.inject(cmd);
+          #endif
+        }
+        else {
+          HMI_flag.select_flag = true;
+          checkkey = PauseOrStop;
+          Popup_window_PauseOrStop();
+        }
+        break;
+
+      case PRINT_STOP:
+        HMI_flag.select_flag = true;
+        checkkey = PauseOrStop;
+        Popup_window_PauseOrStop();
+        break;
+
+      default: break;
+    }
+  }
+  DWIN_UpdateLCD();
+}
+
+// Print done
+void HMI_PrintDone() {
+  EncoderState encoder_diffState = get_encoder_state();
+  if (encoder_diffState == ENCODER_DIFF_NO) return;
+  if (encoder_diffState == ENCODER_DIFF_ENTER) {
+    dwin_abort_flag = true; // Reset feedrate, return to Home
+    Goto_Main_Menu(); // Return to Main menu after print done
+  }
+}
+
+// Pause or Stop popup
+void HMI_PauseOrStop() {
+  EncoderState encoder_diffState = get_encoder_state();
+  if (encoder_diffState == ENCODER_DIFF_NO) return;
+
+  if (encoder_diffState == ENCODER_DIFF_CW)
+    Draw_Select_Highlight(false);
+  else if (encoder_diffState == ENCODER_DIFF_CCW)
+    Draw_Select_Highlight(true);
+  else if (encoder_diffState == ENCODER_DIFF_ENTER) {
+    if (select_print.now == PRINT_PAUSE_RESUME) {
+      if (HMI_flag.select_flag) {
+        HMI_flag.pause_action = true;
+        ICON_Resume();
+        queue.inject(F("M25"));
+      }
+      else {
+        // cancel pause
+      }
+      Goto_PrintProcess();
+    }
+    else if (select_print.now == PRINT_STOP) {
+      if (HMI_flag.select_flag) {
+        checkkey = MainMenu;
+        if (HMI_flag.home_flag) planner.synchronize(); // Wait for planner moves to finish!
+        wait_for_heatup = wait_for_user = false;       // Stop waiting for heating/user
+        card.abortFilePrintSoon();                     // Let the main loop handle SD abort
+        dwin_abort_flag = true;                        // Reset feedrate, return to Home
+        #ifdef ACTION_ON_CANCEL
+          hostui.cancel();
+        #endif
+        DWIN_Draw_Popup(ICON_BLTouch, GET_TEXT_F(MSG_STOPPING), GET_TEXT_F(MSG_PLEASE_WAIT));
+      }
+      else
+        Goto_PrintProcess(); // cancel stop
+    }
+  }
+  DWIN_UpdateLCD();
+}
+
+#include "../../../libs/buzzer.h"
+
+void HMI_AudioFeedback(const bool success/*=true*/) {
+  #if HAS_BUZZER
+    if (success) {
+      BUZZ(100, 659);
+      BUZZ(10, 0);
+      BUZZ(100, 698);
+    }
+    else
+      BUZZ(40, 440);
+  #endif
+}
+
+void Draw_Main_Area() {
+  switch (checkkey) {
+    case MainMenu:               Draw_Main_Menu(); break;
+    case SelectFile:             Draw_Print_File_Menu(); break;
+    case PrintProcess:           Draw_PrintProcess(); break;
+    case PrintDone:              Draw_PrintDone(); break;
+    case Info:                   Draw_Info_Menu(); break;
+    #if HAS_ESDIAG
+      case ESDiagProcess:        Draw_EndStopDiag(); break;
+    #endif
+    #if ENABLED(PRINTCOUNTER)
+      case PrintStatsProcess:    Draw_PrintStats(); break;
+    #endif
+    case PauseOrStop:            Popup_window_PauseOrStop(); break;
+    #if ENABLED(POWER_LOSS_RECOVERY)
+      case PwrlossRec:           Popup_PowerLossRecovery(); break;
+    #endif
+    #if ENABLED(ADVANCED_PAUSE_FEATURE)
+      case FilamentPurge:        Draw_Popup_FilamentPurge(); break;
+    #endif
+    case Locked:                 lockScreen.draw(); break;
+    #if HAS_GCODE_PREVIEW
+      case ConfirmToPrint:       Draw_PreviewFromSD(); break;
+    #endif
+    case Menu:
+    case SetInt:
+    case SetPInt:
+    case SetIntNoDraw:
+    case SetFloat:
+    case SetPFloat:              CurrentMenu->draw(); break;
+    default: break;
+  }
+}
+
+void HMI_ReturnScreen() {
+  checkkey = last_checkkey;
+  wait_for_user = false;
+  Draw_Main_Area();
+  return;
+}
+
+void HMI_Popup() {
+  EncoderState encoder_diffState = get_encoder_state();
+  if (encoder_diffState == ENCODER_DIFF_NO) return;
+  if (encoder_diffState == ENCODER_DIFF_ENTER) {
+    HMI_ReturnScreen();
+  }
+}
+
+void HMI_Init() {
+  HMI_SDCardInit();
+  for (uint16_t t = 0; t <= 100; t += 2) {
+    DWINUI::Draw_Icon(ICON_Bar, 15, 260);
+    DWIN_Draw_Rectangle(1, HMI_data.Background_Color, 15 + t * 242 / 100, 260, 257, 280);
+    DWIN_UpdateLCD();
+    delay(20);
+  }
+  HMI_SetLanguage();
+}
+
+void DWIN_Update() {
+  EachMomentUpdate();   // Status update
+  HMI_SDCardUpdate();   // SD card update
+  DWIN_HandleScreen();  // Rotary encoder update
+}
+
+void EachMomentUpdate() {
+  static millis_t next_var_update_ms = 0, next_rts_update_ms = 0, next_status_update_ms = 0;
+
+  const millis_t ms = millis();
+  if (ELAPSED(ms, next_var_update_ms)) {
+    next_var_update_ms = ms + DWIN_VAR_UPDATE_INTERVAL;
+    update_variable();
+    switch (checkkey) {
+      #if HAS_ESDIAG
+        case ESDiagProcess:
+          ESDiag.Update();
+          break;
+      #endif
+      default:
+        break;
+    }
+  }
+
+  if (ELAPSED(ms, next_status_update_ms)) {
+    next_status_update_ms = ms + 500;
+    DWIN_DrawStatusMessage();
+  }
+
+  if (PENDING(ms, next_rts_update_ms)) return;
+  next_rts_update_ms = ms + DWIN_SCROLL_UPDATE_INTERVAL;
+
+  if (checkkey == PrintProcess) {
+    // if print done
+    if (HMI_flag.print_finish) {
+      HMI_flag.print_finish = false;
+      TERN_(POWER_LOSS_RECOVERY, recovery.cancel());
+      planner.finish_and_disable();
+      checkkey = PrintDone;
+      Draw_PrintDone();
+    }
+    else if (HMI_flag.pause_flag != printingIsPaused()) {
+      // print status update
+      HMI_flag.pause_flag = printingIsPaused();
+      ICON_ResumeOrPause();
+    }
+  }
+
+  // pause after homing
+  if (HMI_flag.pause_action && printingIsPaused() && !planner.has_blocks_queued()) {
+    HMI_flag.pause_action = false;
+    #if ENABLED(PAUSE_HEAT)
+      TERN_(HAS_HOTEND, resume_hotend_temp = sdprint ? thermalManager.degTargetHotend(0) : thermalManager.wholeDegHotend(0));
+      TERN_(HAS_HEATED_BED, resume_bed_temp = sdprint ? thermalManager.degTargetBed() : thermalManager.wholeDegBed());
+      TERN_(HAS_FAN, resume_fan = thermalManager.fan_speed[0]);
+    #endif
+    IF_DISABLED(ADVANCED_PAUSE_FEATURE, thermalManager.disable_all_heaters());
+    IF_DISABLED(PARK_HEAD_ON_PAUSE, queue.inject(F("G1 F1200 X0 Y0")));
+  }
+
+  if (checkkey == PrintProcess) { // print process
+
+    duration_t elapsed = print_job_timer.duration(); // print timer
+
+    if (sdprint && card.isPrinting()) {
+      uint8_t percentDone = card.percentDone();
+      static uint8_t last_percentValue = 101;
+      if (last_percentValue != percentDone) { // print percent
+        last_percentValue = percentDone;
+        if (percentDone) {
+          _percent_done = percentDone;
+          Draw_Print_ProgressBar();
+        }
+      }
+
+      // Estimate remaining time every 20 seconds
+      static millis_t next_remain_time_update = 0;
+      if (_percent_done > 1 && ELAPSED(ms, next_remain_time_update) && !HMI_flag.heat_flag) {
+        _remain_time = (elapsed.value - dwin_heat_time) / (_percent_done * 0.01f) - (elapsed.value - dwin_heat_time);
+        next_remain_time_update += DWIN_REMAIN_TIME_UPDATE_INTERVAL;
+        Draw_Print_ProgressRemain();
+      }
+    }
+
+    // Print time so far
+    static uint16_t last_Printtime = 0;
+    const uint16_t min = (elapsed.value % 3600) / 60;
+    if (last_Printtime != min) { // 1 minute update
+      last_Printtime = min;
+      Draw_Print_ProgressElapsed();
+    }
+
+  }
+  else if (dwin_abort_flag && !HMI_flag.home_flag) { // Print Stop
+    dwin_abort_flag = false;
+    dwin_zoffset = BABY_Z_VAR;
+    select_page.set(PAGE_PRINT);
+    Goto_Main_Menu();
+  }
+
+  #if ENABLED(POWER_LOSS_RECOVERY)
+    else if (DWIN_lcd_sd_status && recovery.dwin_flag) { // resume print before power off
+      return Goto_PowerLossRecovery();
+    }
+  #endif // POWER_LOSS_RECOVERY
+
+  DWIN_UpdateLCD();
+}
+
+#if ENABLED(POWER_LOSS_RECOVERY)
+  void Popup_PowerLossRecovery() {
+    DWINUI::ClearMenuArea();
+    Draw_Popup_Bkgd();
+    if (HMI_IsChinese()) {
+      DWIN_Frame_AreaCopy(1, 160, 338, 235, 354, 98, 115);
+      DWIN_Frame_AreaCopy(1, 103, 321, 271, 335, 52, 167);
+      DWINUI::Draw_IconWB(ICON_Cancel_C,    26, 280);
+      DWINUI::Draw_IconWB(ICON_Continue_C, 146, 280);
+    }
+    else {
+      DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 70, GET_TEXT_F(MSG_OUTAGE_RECOVERY));
+      DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 147, F("It looks like the last"));
+      DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 167, F("file was interrupted."));
+      DWINUI::Draw_IconWB(ICON_Cancel_E,    26, 280);
+      DWINUI::Draw_IconWB(ICON_Continue_E, 146, 280);
+    }
+    SdFile *dir = nullptr;
+    const char * const filename = card.diveToFile(true, dir, recovery.info.sd_filename);
+    card.selectFileByName(filename);
+    DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 207, card.longest_filename());
+    Draw_Select_Highlight(HMI_flag.select_flag);
+    DWIN_UpdateLCD();
+  }
+
+  void Goto_PowerLossRecovery() {
+    recovery.dwin_flag = false;
+    LCD_MESSAGE_F(GET_TEXT_F(MSG_CONTINUE_PRINT_JOB));
+    HMI_flag.select_flag = false;
+    Popup_PowerLossRecovery();
+    last_checkkey = MainMenu;
+    checkkey = PwrlossRec;
+  }
+
+  void HMI_PowerlossRecovery() {
+    EncoderState encoder_diffState = get_encoder_state();
+    if (encoder_diffState == ENCODER_DIFF_NO) return;
+    if (encoder_diffState == ENCODER_DIFF_ENTER) {
+      if (HMI_flag.select_flag) {
+        queue.inject(F("M1000C"));
+        select_page.reset();
+        Goto_Main_Menu();
+      }
+      else {
+        select_print.set(PRINT_SETUP);
+        queue.inject(F("M1000"));
+        sdprint = true;
+        Goto_PrintProcess();
+      }
+    }
+    else
+      Draw_Select_Highlight(encoder_diffState != ENCODER_DIFF_CW);
+    DWIN_UpdateLCD();
+  }
+#endif // POWER_LOSS_RECOVERY
+
+
+void DWIN_HandleScreen() {
+  switch (checkkey) {
+    case MainMenu:        HMI_MainMenu(); break;
+    case Menu:            HMI_Menu(); break;
+    case SetInt:          HMI_SetInt(); break;
+    case SetPInt:         HMI_SetPInt(); break;
+    case SetIntNoDraw:    HMI_SetIntNoDraw(); break;
+    case SetFloat:        HMI_SetFloat(); break;
+    case SetPFloat:       HMI_SetPFloat(); break;
+    case SelectFile:      HMI_SelectFile(); break;
+    case Homing:          break;
+    case Leveling:        break;
+    case PrintProcess:    HMI_Printing(); break;
+    case PrintDone:       HMI_PrintDone(); break;
+    case PauseOrStop:     HMI_PauseOrStop(); break;
+    case Info:            HMI_Popup(); break;
+    case WaitResponse:    HMI_Popup(); break;
+    #if ENABLED(ADVANCED_PAUSE_FEATURE)
+      case FilamentPurge: HMI_FilamentPurge(); break;
+    #endif
+    case NothingToDo:     break;
+    case Locked:          HMI_LockScreen(); break;
+    #if ENABLED(POWER_LOSS_RECOVERY)
+      case PwrlossRec:    HMI_PowerlossRecovery(); break;
+    #endif
+    #if HAS_GCODE_PREVIEW
+      case ConfirmToPrint: HMI_ConfirmToPrint(); break;
+    #endif
+    #if HAS_ESDIAG
+      case ESDiagProcess: HMI_Popup(); break;
+    #endif
+    #if ENABLED(PRINTCOUNTER)
+      case PrintStatsProcess: HMI_Popup(); break;
+    #endif
+    default: break;
+  }
+}
+
+bool IDisPopUp() {    // If ID is popup...
+  return  (checkkey == NothingToDo) ||
+          (checkkey == WaitResponse) ||
+          (checkkey == Info) ||
+          (checkkey == Homing) ||
+          (checkkey == Leveling) ||
+          TERN_(HAS_ESDIAG, (checkkey == ESDiagProcess) ||)
+          TERN_(PRINTCOUNTER, (checkkey == PrintStatsProcess) ||)
+          (checkkey == PauseOrStop) ||
+          (checkkey == FilamentPurge);
+}
+
+void HMI_SaveProcessID(const uint8_t id) {
+  if (checkkey != id) {
+    if (!IDisPopUp()) last_checkkey = checkkey; // if previous is not a popup
+    checkkey = id;
+  }
+}
+
+void DWIN_StartHoming() {
+  HMI_flag.home_flag = true;
+  HMI_SaveProcessID(Homing);
+  Title.ShowCaption(GET_TEXT_F(MSG_LEVEL_BED_HOMING));
+  DWIN_Draw_Popup(ICON_BLTouch, GET_TEXT_F(MSG_LEVEL_BED_HOMING), GET_TEXT_F(MSG_PLEASE_WAIT));
+}
+
+void DWIN_CompletedHoming() {
+  HMI_flag.home_flag = false;
+  dwin_zoffset = TERN0(HAS_BED_PROBE, probe.offset.z);
+  if (dwin_abort_flag) {
+    planner.finish_and_disable();
+  }
+  HMI_ReturnScreen();
+}
+
+void DWIN_MeshLevelingStart() {
+  #if HAS_ONESTEP_LEVELING
+    HMI_SaveProcessID(Leveling);
+    Title.ShowCaption(GET_TEXT_F(MSG_BED_LEVELING));
+    DWIN_Show_Popup(ICON_AutoLeveling, GET_TEXT_F(MSG_BED_LEVELING), GET_TEXT_F(MSG_PLEASE_WAIT), ICON_Cancel_E);
+  #elif ENABLED(MESH_BED_LEVELING)
+    Draw_ManualMesh_Menu();
+  #endif
+}
+
+void DWIN_CompletedLeveling() { TERN_(HAS_MESH, DWIN_MeshViewer()); }
+
+#if HAS_MESH
+  void DWIN_MeshUpdate(const int8_t xpos, const int8_t ypos, const float zval) {
+    char msg[33] = "";
+    char str_1[6] = "";
+    sprintf_P(msg, PSTR(S_FMT " %i/%i Z=%s"), GET_TEXT(MSG_PROBING_POINT), xpos, ypos,
+      dtostrf(zval, 1, 2, str_1));
+    ui.set_status(msg);
+  }
+#endif
+
+// PID process
+void DWIN_PidTuning(pidresult_t result) {
+  switch (result) {
+    case PID_BED_START:
+      HMI_SaveProcessID(NothingToDo);
+      DWIN_Draw_Popup(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE), F("for BED is running."));
+      break;
+    case PID_EXTR_START:
+      HMI_SaveProcessID(NothingToDo);
+      DWIN_Draw_Popup(ICON_TempTooHigh, GET_TEXT_F(MSG_PID_AUTOTUNE), F("for Nozzle is running."));
+      break;
+    case PID_BAD_EXTRUDER_NUM:
+      checkkey = last_checkkey;
+      DWIN_Popup_Confirm(ICON_TempTooLow, F("PID Autotune failed!"), F("Bad extruder"));
+      break;
+    case PID_TUNING_TIMEOUT:
+      checkkey = last_checkkey;
+      DWIN_Popup_Confirm(ICON_TempTooHigh, F("Error"), GET_TEXT_F(MSG_PID_TIMEOUT));
+      break;
+    case PID_TEMP_TOO_HIGH:
+      checkkey = last_checkkey;
+      DWIN_Popup_Confirm(ICON_TempTooHigh, F("PID Autotune failed!"), F("Temperature too high"));
+      break;
+    case PID_DONE:
+      checkkey = last_checkkey;
+      DWIN_Popup_Confirm(ICON_TempTooLow, GET_TEXT_F(MSG_PID_AUTOTUNE), GET_TEXT_F(MSG_BUTTON_DONE));
+      break;
+    default:
+      checkkey = last_checkkey;
+      break;
+  }
+}
+
+// Update filename on print
+void DWIN_Print_Header(const char *text = nullptr) {
+  static char headertxt[31] = "";  // Print header text
+
+  if (text) {
+    const int8_t size = _MIN((unsigned) 30, strlen_P(text));
+    LOOP_L_N(i, size) headertxt[i] = text[i];
+    headertxt[size] = '\0';
+  }
+  if (checkkey == PrintProcess || checkkey == PrintDone) {
+    DWIN_Draw_Rectangle(1, HMI_data.Background_Color, 0, 60, DWIN_WIDTH, 60+16);
+    DWINUI::Draw_CenteredString(60, headertxt);
+  }
+}
+
+void Draw_Title(TitleClass* title) {
+  DWIN_Draw_Rectangle(1, HMI_data.TitleBg_color, 0, 0, DWIN_WIDTH - 1, TITLE_HEIGHT - 1);
+  if (title->frameid)
+    DWIN_Frame_AreaCopy(title->frameid, title->frame.left, title->frame.top, title->frame.right, title->frame.bottom, 14, (TITLE_HEIGHT - (title->frame.bottom - title->frame.top)) / 2 - 1);
+  else
+    DWIN_Draw_String(false, DWIN_FONT_HEAD, HMI_data.TitleTxt_color, HMI_data.TitleBg_color, 14, (TITLE_HEIGHT - DWINUI::fontHeight(DWIN_FONT_HEAD)) / 2 - 1, title->caption);
+}
+
+void Draw_Menu(MenuClass* menu) {
+  DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color);
+  DWIN_Draw_Rectangle(1, DWINUI::backcolor, 0, TITLE_HEIGHT, DWIN_WIDTH - 1, STATUS_Y - 1);
+  DWIN_ResetStatusLine();
+}
+
+// Startup routines
+void DWIN_Startup() {
+  DWINUI::init();
+  DWINUI::onCursorDraw = Draw_Menu_Cursor;
+  DWINUI::onCursorErase = Erase_Menu_Cursor;
+  DWINUI::onTitleDraw = Draw_Title;
+  DWINUI::onMenuDraw = Draw_Menu;
+  HMI_SetLanguage();
+}
+
+// Started a Print Job
+void DWIN_Print_Started(const bool sd) {
+  sdprint = card.isPrinting() || sd;
+  _percent_done = 0;
+  _remain_time = 0;
+  HMI_flag.print_finish = false;
+  Goto_PrintProcess();
+}
+
+// Ended print job
+void DWIN_Print_Finished() {
+  if (checkkey == PrintProcess || printingIsActive()) {
+    thermalManager.cooldown();
+    HMI_flag.print_finish = true;
+  }
+}
+
+// Progress Bar update
+void DWIN_Progress_Update() {
+  if (parser.seenval('P')) _percent_done = parser.byteval('P');
+  if (parser.seenval('R')) _remain_time = parser.ulongval('R') * 60;
+  if (checkkey == PrintProcess) {
+    Draw_Print_ProgressBar();
+    Draw_Print_ProgressRemain();
+    Draw_Print_ProgressElapsed();
+  }
+}
+
+#if HAS_FILAMENT_SENSOR
+  // Filament Runout process
+  void DWIN_FilamentRunout(const uint8_t extruder) { LCD_MESSAGE(MSG_RUNOUT_SENSOR); }
+#endif
+
+void DWIN_SetColorDefaults() {
+  HMI_data.Background_Color = Def_Background_Color;
+  HMI_data.Cursor_color     = Def_Cursor_color;
+  HMI_data.TitleBg_color    = Def_TitleBg_color;
+  HMI_data.TitleTxt_color   = Def_TitleTxt_color;
+  HMI_data.Text_Color       = Def_Text_Color;
+  HMI_data.Selected_Color   = Def_Selected_Color;
+  HMI_data.SplitLine_Color  = Def_SplitLine_Color;
+  HMI_data.Highlight_Color  = Def_Highlight_Color;
+  HMI_data.StatusBg_Color   = Def_StatusBg_Color;
+  HMI_data.StatusTxt_Color  = Def_StatusTxt_Color;
+  HMI_data.PopupBg_color    = Def_PopupBg_color;
+  HMI_data.PopupTxt_Color   = Def_PopupTxt_Color;
+  HMI_data.AlertBg_Color    = Def_AlertBg_Color;
+  HMI_data.AlertTxt_Color   = Def_AlertTxt_Color;
+  HMI_data.PercentTxt_Color = Def_PercentTxt_Color;
+  HMI_data.Barfill_Color    = Def_Barfill_Color;
+  HMI_data.Indicator_Color  = Def_Indicator_Color;
+  HMI_data.Coordinate_Color = Def_Coordinate_Color;
+}
+
+void DWIN_SetDataDefaults() {
+  DWIN_SetColorDefaults();
+  DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color);
+  TERN_(HAS_HOTEND,             HMI_data.HotendPidT = PREHEAT_1_TEMP_HOTEND);
+  TERN_(HAS_HEATED_BED,         HMI_data.BedPidT    = PREHEAT_1_TEMP_BED);
+  TERN_(HAS_HOTEND,             HMI_data.PidCycles  = 5);
+  TERN_(PREVENT_COLD_EXTRUSION, HMI_data.ExtMinT    = EXTRUDE_MINTEMP);
+}
+
+void DWIN_StoreSettings(char *buff) {
+  memcpy(buff, &HMI_data, _MIN(sizeof(HMI_data), eeprom_data_size));
+}
+
+void DWIN_LoadSettings(const char *buff) {
+  // (void *)-> Avoid Warning when save data different from uintX_t in HMI_data_t struct
+  memcpy((void *)&HMI_data, buff, _MIN(sizeof(HMI_data), eeprom_data_size));
+  dwin_zoffset = TERN0(HAS_BED_PROBE, probe.offset.z);
+  if (HMI_data.Text_Color == HMI_data.Background_Color) DWIN_SetColorDefaults();
+  DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color);
+  TERN_(PREVENT_COLD_EXTRUSION, ApplyExtMinT());
+  feedrate_percentage = 100;
+  #if BOTH(CASE_LIGHT_MENU, CASELIGHT_USES_BRIGHTNESS)
+    // Apply Case light brightness
+    caselight.brightness = HMI_data.CaseLight_Brightness;
+    caselight.update_brightness();
+  #endif
+  #if BOTH(LED_CONTROL_MENU, HAS_COLOR_LEDS)
+    // Apply Led Color
+    leds.set_color(HMI_data.Led_Color);
+  #endif
+}
+
+void MarlinUI::kill_screen(FSTR_P const lcd_error, FSTR_P const lcd_component) {
+  DWIN_Draw_Popup(ICON_BLTouch, F("Printer killed:"), lcd_error);
+  DWINUI::Draw_CenteredString(HMI_data.PopupTxt_Color, 270, F("Turn off the printer"));
+  DWIN_UpdateLCD();
+}
+
+void DWIN_RebootScreen() {
+  DWIN_Frame_Clear(Color_Bg_Black);
+  DWIN_JPG_ShowAndCache(0);
+  DWINUI::Draw_CenteredString(Color_White, 220, GET_TEXT_F(MSG_PLEASE_WAIT_REBOOT));
+  DWIN_UpdateLCD();
+  delay(500);
+}
+
+void DWIN_Redraw_screen() {
+  Draw_Main_Area();
+  Draw_Status_Area(false);
+}
+
+#if ENABLED(ADVANCED_PAUSE_FEATURE)
+
+  void DWIN_Popup_Pause(FSTR_P const fmsg, uint8_t button = 0) {
+    HMI_SaveProcessID(button ? WaitResponse : NothingToDo);
+    DWIN_Draw_Popup(ICON_BLTouch, GET_TEXT_F(MSG_ADVANCED_PAUSE), fmsg, button);
+    ui.reset_status(true);
+  }
+
+  void MarlinUI::pause_show_message(const PauseMessage message, const PauseMode mode/*=PAUSE_MODE_SAME*/, const uint8_t extruder/*=active_extruder*/) {
+    switch (message) {
+      case PAUSE_MESSAGE_PARKING:  DWIN_Popup_Pause(GET_TEXT_F(MSG_PAUSE_PRINT_PARKING));    break;
+      case PAUSE_MESSAGE_CHANGING: DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_INIT));   break;
+      case PAUSE_MESSAGE_UNLOAD:   DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_UNLOAD)); break;
+      case PAUSE_MESSAGE_WAITING:  DWIN_Popup_Pause(GET_TEXT_F(MSG_ADVANCED_PAUSE_WAITING), ICON_Continue_E); break;
+      case PAUSE_MESSAGE_INSERT:   DWIN_Popup_Continue(ICON_BLTouch, GET_TEXT_F(MSG_ADVANCED_PAUSE), GET_TEXT_F(MSG_FILAMENT_CHANGE_INSERT)); break;
+      case PAUSE_MESSAGE_LOAD:     DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_LOAD));   break;
+      case PAUSE_MESSAGE_PURGE:    DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_PURGE));  break;
+      case PAUSE_MESSAGE_OPTION:   DWIN_Popup_FilamentPurge(); break;
+      case PAUSE_MESSAGE_RESUME:   DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_RESUME)); break;
+      case PAUSE_MESSAGE_HEAT:     DWIN_Popup_Pause(GET_TEXT_F(MSG_FILAMENT_CHANGE_HEAT), ICON_Continue_E);   break;
+      case PAUSE_MESSAGE_HEATING:  LCD_MESSAGE(MSG_FILAMENT_CHANGE_HEATING); break;
+      case PAUSE_MESSAGE_STATUS:   HMI_ReturnScreen(); break;
+      default: break;
+    }
+  }
+
+  void Draw_Popup_FilamentPurge() {
+    DWIN_Draw_Popup(ICON_BLTouch, GET_TEXT_F(MSG_ADVANCED_PAUSE), F("Purge or Continue?"));
+    DWINUI::Draw_IconWB(ICON_Confirm_E, 26, 280);
+    DWINUI::Draw_IconWB(ICON_Continue_E, 146, 280);
+    Draw_Select_Highlight(true);
+    DWIN_UpdateLCD();
+  }
+
+  // Handle responses such as:
+  //  - Purge More, Continue
+  //  - General "Continue" response
+  void DWIN_Popup_FilamentPurge() {
+    HMI_SaveProcessID(FilamentPurge);
+    pause_menu_response = PAUSE_RESPONSE_WAIT_FOR;
+    Draw_Popup_FilamentPurge();
+  }
+
+  void HMI_FilamentPurge() {
+    EncoderState encoder_diffState = get_encoder_state();
+    if (encoder_diffState == ENCODER_DIFF_NO) return;
+    if (encoder_diffState == ENCODER_DIFF_CW)
+      Draw_Select_Highlight(false);
+    else if (encoder_diffState == ENCODER_DIFF_CCW)
+      Draw_Select_Highlight(true);
+    else if (encoder_diffState == ENCODER_DIFF_ENTER) {
+      if (HMI_flag.select_flag)
+        pause_menu_response = PAUSE_RESPONSE_EXTRUDE_MORE;  // "Purge More" button
+      else {
+        HMI_SaveProcessID(NothingToDo);
+        pause_menu_response = PAUSE_RESPONSE_RESUME_PRINT;  // "Continue" button
+      }
+    }
+    DWIN_UpdateLCD();
+  }
+
+#endif // ADVANCED_PAUSE_FEATURE
+
+#if HAS_MESH
+  void DWIN_MeshViewer() {
+    if (!leveling_is_valid())
+      DWIN_Popup_Continue(ICON_BLTouch, GET_TEXT_F(MSG_MESH_VIEWER), GET_TEXT_F(MSG_NO_VALID_MESH));
+    else {
+      HMI_SaveProcessID(WaitResponse);
+      MeshViewer.Draw();
+    }
+  }
+#endif // HAS_MESH
+
+void DWIN_LockScreen() {
+  if (checkkey != Locked) {
+    lockScreen.rprocess = checkkey;
+    checkkey = Locked;
+    lockScreen.init();
+  }
+}
+
+void DWIN_UnLockScreen() {
+  if (checkkey == Locked) {
+    checkkey = lockScreen.rprocess;
+    Draw_Main_Area();
+  }
+}
+
+void HMI_LockScreen() {
+  EncoderState encoder_diffState = get_encoder_state();
+  if (encoder_diffState == ENCODER_DIFF_NO) return;
+  lockScreen.onEncoder(encoder_diffState);
+  if (lockScreen.isUnlocked()) DWIN_UnLockScreen();
+}
+
+#if HAS_GCODE_PREVIEW
+
+  void HMI_ConfirmToPrint() {
+    EncoderState encoder_diffState = get_encoder_state();
+    if (encoder_diffState == ENCODER_DIFF_NO) return;
+    if (encoder_diffState == ENCODER_DIFF_CW)
+      Draw_Select_Highlight(false);
+    else if (encoder_diffState == ENCODER_DIFF_CCW)
+      Draw_Select_Highlight(true);
+    else if (encoder_diffState == ENCODER_DIFF_ENTER) {
+      if (HMI_flag.select_flag) {     // Confirm
+        card.openAndPrintFile(card.filename);
+        DWIN_Print_Started(true);
+      }
+      else {                          // Cancel
+        DWIN_ResetStatusLine();
+        checkkey = SelectFile;
+        Draw_Print_File_Menu();
+      }
+    }
+    DWIN_UpdateLCD();
+  }
+
+#endif
+
+void Goto_ConfirmToPrint() {
+  #if HAS_GCODE_PREVIEW
+    HMI_SaveProcessID(ConfirmToPrint);
+    Draw_PreviewFromSD();
+  #else
+    card.openAndPrintFile(card.filename);
+    DWIN_Print_Started(true);
+  #endif
+}
+
+#if HAS_ESDIAG
+  void Draw_EndStopDiag() {
+    HMI_SaveProcessID(ESDiagProcess);
+    ESDiag.Draw();
+  }
+#endif
+
+#if ENABLED(PRINTCOUNTER)
+  void Draw_PrintStats() {
+    HMI_SaveProcessID(PrintStatsProcess);
+    PrintStats.Draw();
+  }
+#endif
+
+//=============================================================================
+// NEW MENU SUBSYSTEM
+//=============================================================================
+
+// On click functions
+
+// Generic onclick event without draw anything
+//  process: process id HMI destiny
+//  lo: low limit
+//  hi: high limit
+//  dp: decimal places, 0 for integers
+//  val: value / scaled value
+//  LiveUpdate: live update function when the encoder changes
+//  Apply: update function when the encoder is pressed
+void SetOnClick(uint8_t process, const int32_t lo, const int32_t hi, uint8_t dp, const int32_t val, void (*Apply)() = nullptr, void (*LiveUpdate)() = nullptr) {
+  checkkey = process;
+  HMI_value.MinValue = lo;
+  HMI_value.MaxValue = hi;
+  HMI_value.dp = dp;
+  HMI_value.Apply = Apply;
+  HMI_value.LiveUpdate = LiveUpdate;
+  HMI_value.Value = val;
+  EncoderRate.enabled = true;
+}
+
+// Generic onclick event for integer values
+//  process: process id HMI destiny
+//  lo: scaled low limit
+//  hi: scaled high limit
+//  val: value
+//  LiveUpdate: live update function when the encoder changes
+//  Apply: update function when the encoder is pressed
+void SetValueOnClick(uint8_t process, const int32_t lo, const int32_t hi, const int32_t val, void (*Apply)() = nullptr, void (*LiveUpdate)() = nullptr) {
+  SetOnClick(process, lo, hi, 0, val, Apply, LiveUpdate);
+  Draw_Menu_IntValue(HMI_data.Selected_Color, CurrentMenu->line(), 4, HMI_value.Value);
+}
+
+// Generic onclick event for float values
+//  process: process id HMI destiny
+//  lo: scaled low limit
+//  hi: scaled high limit
+//  val: value
+//  LiveUpdate: live update function when the encoder changes
+//  Apply: update function when the encoder is pressed
+void SetValueOnClick(uint8_t process, const float lo, const float hi, uint8_t dp, const float val, void (*Apply)() = nullptr, void (*LiveUpdate)() = nullptr) {
+  const int32_t value =  round(val * POW(10, dp));
+  SetOnClick(process, lo * POW(10, dp), hi * POW(10, dp), dp, value, Apply, LiveUpdate);
+  DWINUI::Draw_Signed_Float(HMI_data.Text_Color, HMI_data.Selected_Color, 3, dp, VALX - dp * DWINUI::fontWidth(DWIN_FONT_MENU), MBASE(CurrentMenu->line()), val);
+}
+
+// Generic onclick event for integer values
+//  lo: scaled low limit
+//  hi: scaled high limit
+//  val: value
+//  LiveUpdate: live update function when the encoder changes
+//  Apply: update function when the encoder is pressed
+inline void SetIntOnClick(const int32_t lo, const int32_t hi, const int32_t val, void (*Apply)() = nullptr, void (*LiveUpdate)() = nullptr) {
+  SetValueOnClick(SetInt, lo, hi, val, Apply, LiveUpdate);
+}
+
+// Generic onclick event for set pointer to 16 bit uinteger values
+//  lo: low limit
+//  hi: high limit
+//  LiveUpdate: live update function when the encoder changes
+//  Apply: update function when the encoder is pressed
+void SetPIntOnClick(const int32_t lo, const int32_t hi, void (*Apply)() = nullptr, void (*LiveUpdate)() = nullptr) {
+  HMI_value.P_Int = (int16_t*)static_cast<MenuItemPtrClass*>(CurrentMenu->SelectedItem())->value;
+  const int32_t value = *HMI_value.P_Int;
+  SetValueOnClick(SetPInt, lo, hi, value, Apply, LiveUpdate);
+}
+
+// Generic onclick event for float values
+//  process: process id HMI destiny
+//  lo: low limit
+//  hi: high limit
+//  dp: decimal places
+//  val: value
+inline void SetFloatOnClick(const float lo, const float hi, uint8_t dp, const float val, void (*Apply)() = nullptr, void (*LiveUpdate)() = nullptr) {
+  SetValueOnClick(SetFloat, lo, hi, dp, val, Apply, LiveUpdate);
+}
+
+// Generic onclick event for set pointer to float values
+//  lo: low limit
+//  hi: high limit
+//  LiveUpdate: live update function when the encoder changes
+//  Apply: update function when the encoder is pressed
+void SetPFloatOnClick(const float lo, const float hi, uint8_t dp, void (*Apply)() = nullptr, void (*LiveUpdate)() = nullptr) {
+  HMI_value.P_Float = (float*)static_cast<MenuItemPtrClass*>(CurrentMenu->SelectedItem())->value;
+  SetValueOnClick(SetPFloat, lo, hi, dp, *HMI_value.P_Float, Apply, LiveUpdate);
+}
+
+#if ENABLED(EEPROM_SETTINGS)
+  void WriteEeprom() {
+    const bool success = settings.save();
+    HMI_AudioFeedback(success);
+  }
+
+  void ReadEeprom() {
+    const bool success = settings.load();
+    DWIN_Redraw_screen();
+    HMI_AudioFeedback(success);
+  }
+
+  void ResetEeprom() {
+    settings.reset();
+    DWIN_Redraw_screen();
+    HMI_AudioFeedback();
+  }
+#endif
+
+// Reset Printer
+void RebootPrinter() {
+  dwin_abort_flag = true;
+  wait_for_heatup = wait_for_user = false;    // Stop waiting for heating/user
+  thermalManager.disable_all_heaters();
+  planner.finish_and_disable();
+  DWIN_RebootScreen();
+  HAL_reboot();
+}
+
+void Goto_Info_Menu(){
+  HMI_SaveProcessID(Info);
+  Draw_Info_Menu();
+}
+
+void Goto_Move_Menu() {
+  #if HAS_HOTEND
+    gcode.process_subcommands_now(F("G92E0"));  // reset extruder position
+    planner.synchronize();
+  #endif
+  Draw_Move_Menu();
+}
+
+void DisableMotors() { queue.inject(F("M84")); }
+
+void AutoLev() { queue.inject(F("G28Z\nG29")); }  // Force to get the current Z home position
+
+void AutoHome() { queue.inject_P(G28_STR); }
+
+void HomeX() { queue.inject(F("G28X")); }
+
+void HomeY() { queue.inject(F("G28Y")); }
+
+void HomeZ() { queue.inject(F("G28Z")); }
+
+void SetHome() {
+  // Apply workspace offset, making the current position 0,0,0
+  queue.inject(F("G92 X0 Y0 Z0"));
+  HMI_AudioFeedback();
+}
+
+#if HAS_ZOFFSET_ITEM
+  bool printer_busy() { return planner.movesplanned() || printingIsActive(); }
+  void ApplyZOffset() { TERN_(EEPROM_SETTINGS, settings.save()); }
+  void LiveZOffset() {
+    last_zoffset = dwin_zoffset;
+    dwin_zoffset = HMI_value.Value / 100.0f;
+    #if EITHER(BABYSTEP_ZPROBE_OFFSET, JUST_BABYSTEP)
+      if (BABYSTEP_ALLOWED()) babystep.add_mm(Z_AXIS, dwin_zoffset - last_zoffset);
+    #endif
+  }
+  #if EITHER(HAS_BED_PROBE, BABYSTEPPING)
+    void SetZOffset() {
+      SetPFloatOnClick(Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX, 2, ApplyZOffset, LiveZOffset);
+    }
+  #endif
+#endif
+
+#if HAS_PREHEAT
+  void DoPreheat0() { ui.preheat_all(0); }
+  void DoPreheat1() { ui.preheat_all(1); }
+  void DoPreheat2() { ui.preheat_all(2); }
+#endif
+
+void DoCoolDown() { thermalManager.cooldown(); }
+
+void SetLanguage() {
+  HMI_ToggleLanguage();
+  CurrentMenu = nullptr;  // Invalidate menu to full redraw
+  Draw_Prepare_Menu();
+}
+
+void LiveMove() {
+  *HMI_value.P_Float = HMI_value.Value / MINUNITMULT;
+  if (!planner.is_full()) {
+    planner.synchronize();
+    planner.buffer_line(current_position, homing_feedrate(HMI_value.axis));
+  }
+}
+void ApplyMoveE() {
+  last_E = HMI_value.Value / MINUNITMULT;
+  if (!planner.is_full()) {
+    planner.synchronize();
+    planner.buffer_line(current_position, MMM_TO_MMS(FEEDRATE_E));
+  }
+}
+void SetMoveX() { HMI_value.axis = X_AXIS; SetPFloatOnClick(X_MIN_POS, X_MAX_POS, UNITFDIGITS, planner.synchronize, LiveMove);}
+void SetMoveY() { HMI_value.axis = Y_AXIS; SetPFloatOnClick(Y_MIN_POS, Y_MAX_POS, UNITFDIGITS, planner.synchronize, LiveMove);}
+void SetMoveZ() { HMI_value.axis = Z_AXIS; SetPFloatOnClick(Z_MIN_POS, Z_MAX_POS, UNITFDIGITS, planner.synchronize, LiveMove);}
+
+#if HAS_HOTEND
+  void SetMoveE() {
+    #if ENABLED(PREVENT_COLD_EXTRUSION)
+      if (thermalManager.tooColdToExtrude(0)) {
+        Popup_Window_ETempTooLow();
+        return;
+      }
+    #endif
+    SetPFloatOnClick(last_E - (EXTRUDE_MAXLENGTH), last_E + (EXTRUDE_MAXLENGTH), UNITFDIGITS, ApplyMoveE);
+  }
+#endif
+
+void SetMoveZto0() {
+  char cmd[48] = "";
+  char str_1[5] = "", str_2[5] = "";
+  sprintf_P(cmd, PSTR("G28Z\nG0X%sY%sF5000\nM420S0\nG0Z0F300"),
+    #if ENABLED(MESH_BED_LEVELING)
+      dtostrf(0, 1, 1, str_1),
+      dtostrf(0, 1, 1, str_2)
+    #else
+      dtostrf(X_CENTER, 1, 1, str_1),
+      dtostrf(Y_CENTER, 1, 1, str_2)
+    #endif
+  );
+  gcode.process_subcommands_now(cmd);
+  planner.synchronize();
+  LCD_MESSAGE_F("Now adjust Z Offset");
+  HMI_AudioFeedback(true);
+}
+
+void SetPID(celsius_t t, heater_id_t h) {
+  char cmd[48] = "";
+  char str_1[5] = "", str_2[5] = "";
+  sprintf_P(cmd, PSTR("G28OXY\nG0Z5F300\nG0X%sY%sF5000\nM84"),
+    dtostrf(X_CENTER, 1, 1, str_1),
+    dtostrf(Y_CENTER, 1, 1, str_2)
+  );
+  gcode.process_subcommands_now(cmd);
+  planner.synchronize();
+  thermalManager.PID_autotune(t, h, HMI_data.PidCycles, true);
+}
+#if HAS_HOTEND
+  void HotendPID() { SetPID(HMI_data.HotendPidT, H_E0); }
+#endif
+#if HAS_HEATED_BED
+  void BedPID() { SetPID(HMI_data.BedPidT, H_BED); }
+#endif
+
+#if ENABLED(POWER_LOSS_RECOVERY)
+  void SetPwrLossr() {
+    recovery.enable(!recovery.enabled);
+    Draw_Chkb_Line(CurrentMenu->line(), recovery.enabled);
+    DWIN_UpdateLCD();
+  }
+#endif
+
+#if HAS_LCD_BRIGHTNESS
+  void ApplyBrightness() { ui.set_brightness(HMI_value.Value); }
+  void LiveBrightness() { DWIN_LCD_Brightness(HMI_value.Value); }
+  void SetBrightness() { SetIntOnClick(LCD_BRIGHTNESS_MIN, LCD_BRIGHTNESS_MAX, ui.brightness, ApplyBrightness, LiveBrightness); }
+#endif
+
+#if ENABLED(CASE_LIGHT_MENU)
+  void SetCaseLight() {
+    caselight.on = !caselight.on;
+    caselight.update_enabled();
+    Draw_Chkb_Line(CurrentMenu->line(), caselight.on);
+    DWIN_UpdateLCD();
+  }
+  #if ENABLED(CASELIGHT_USES_BRIGHTNESS)
+    void LiveCaseLightBrightness() { HMI_data.CaseLight_Brightness = caselight.brightness = HMI_value.Value; caselight.update_brightness(); }
+    void SetCaseLightBrightness() { SetIntOnClick(0, 255, caselight.brightness, nullptr, LiveCaseLightBrightness); }
+  #endif
+#endif
+
+#if ENABLED(LED_CONTROL_MENU)
+  #if !BOTH(CASE_LIGHT_MENU, CASE_LIGHT_USE_NEOPIXEL)
+    void SetLedStatus() {
+      leds.toggle();
+      Draw_Chkb_Line(CurrentMenu->line(), leds.lights_on);
+      DWIN_UpdateLCD();
+    }
+  #endif
+  #if ENABLED(HAS_COLOR_LEDS)
+    void LiveLedColorR() { leds.color.r = HMI_value.Value; HMI_data.Led_Color = leds.color; leds.update(); }
+    void SetLedColorR() { SetIntOnClick(0, 255, leds.color.r, nullptr, LiveLedColorR); }
+    void LiveLedColorG() { leds.color.g = HMI_value.Value; HMI_data.Led_Color = leds.color; leds.update(); }
+    void SetLedColorG() { SetIntOnClick(0, 255, leds.color.g, nullptr, LiveLedColorG); }
+    void LiveLedColorB() { leds.color.b = HMI_value.Value; HMI_data.Led_Color = leds.color; leds.update(); }
+    void SetLedColorB() { SetIntOnClick(0, 255, leds.color.b, nullptr, LiveLedColorB); }
+    #if HAS_WHITE_LED
+      void LiveLedColorW() { leds.color.w = HMI_value.Value; HMI_data.Led_Color = leds.color; leds.update(); }
+      void SetLedColorW() { SetIntOnClick(0, 255, leds.color.w, nullptr, LiveLedColorW); }
+    #endif
+  #endif
+#endif
+
+#if ENABLED(SOUND_MENU_ITEM)
+  void SetEnableSound() {
+    ui.buzzer_enabled = !ui.buzzer_enabled;
+    Draw_Chkb_Line(CurrentMenu->line(), ui.buzzer_enabled);
+    DWIN_UpdateLCD();
+  }
+#endif
+
+#if HAS_HOME_OFFSET
+  void ApplyHomeOffset() { set_home_offset(HMI_value.axis, HMI_value.Value / MINUNITMULT); }
+  void SetHomeOffsetX() { HMI_value.axis = X_AXIS; SetPFloatOnClick(-50, 50, UNITFDIGITS, ApplyHomeOffset); }
+  void SetHomeOffsetY() { HMI_value.axis = Y_AXIS; SetPFloatOnClick(-50, 50, UNITFDIGITS, ApplyHomeOffset); }
+  void SetHomeOffsetZ() { HMI_value.axis = Z_AXIS; SetPFloatOnClick( -2,  2, UNITFDIGITS, ApplyHomeOffset); }
+#endif
+
+#if HAS_BED_PROBE
+  void SetProbeOffsetX() { SetPFloatOnClick(-60, 60, UNITFDIGITS); }
+  void SetProbeOffsetY() { SetPFloatOnClick(-60, 60, UNITFDIGITS); }
+  void SetProbeOffsetZ() { SetPFloatOnClick(-10, 10, 2); }
+  void ProbeTest() {
+    LCD_MESSAGE(MSG_M48_TEST);
+    queue.inject(F("G28O\nM48 P10"));
+  }
+  void ProbeStow() { probe.stow(); }
+  void ProbeDeploy() { probe.deploy(); }
+
+  #ifdef BLTOUCH_HS_MODE
+    void SetHSMode() {
+      bltouch.high_speed_mode = !bltouch.high_speed_mode;
+      Draw_Chkb_Line(CurrentMenu->line(), bltouch.high_speed_mode);
+      DWIN_UpdateLCD();
+    }
+  #endif
+#endif
+
+#if ENABLED(NOZZLE_PARK_FEATURE)
+  void SetParkPosX()   { SetPIntOnClick(0, X_MAX_POS); }
+  void SetParkPosY()   { SetPIntOnClick(0, Y_MAX_POS); }
+  void SetParkZRaise() { SetPIntOnClick(0, 50); }
+#endif
+
+#if HAS_FILAMENT_SENSOR
+  void SetRunoutEnable() {
+    runout.reset();
+    runout.enabled = !runout.enabled;
+    Draw_Chkb_Line(CurrentMenu->line(), runout.enabled);
+    DWIN_UpdateLCD();
+  }
+  #if HAS_FILAMENT_RUNOUT_DISTANCE
+    void ApplyRunoutDistance() { runout.set_runout_distance(HMI_value.Value / MINUNITMULT); }
+    void SetRunoutDistance() { SetFloatOnClick(0, 999, UNITFDIGITS, runout.runout_distance(), ApplyRunoutDistance); }
+  #endif
+#endif
+
+#if ENABLED(ADVANCED_PAUSE_FEATURE)
+  void SetFilLoad()   { SetPFloatOnClick(0, MAX_LOAD_UNLOAD, UNITFDIGITS); }
+  void SetFilUnload() { SetPFloatOnClick(0, MAX_LOAD_UNLOAD, UNITFDIGITS); }
+#endif
+
+#if ENABLED(PREVENT_COLD_EXTRUSION)
+  void ApplyExtMinT() { thermalManager.extrude_min_temp = HMI_data.ExtMinT; thermalManager.allow_cold_extrude = (HMI_data.ExtMinT == 0); }
+  void SetExtMinT() { SetPIntOnClick(MIN_ETEMP, MAX_ETEMP, ApplyExtMinT); }
+#endif
+
+void RestoreDefaultsColors() {
+  DWIN_SetColorDefaults();
+  DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color);
+  DWIN_Redraw_screen();
+}
+
+void SelColor() {
+  HMI_value.P_Int = (int16_t*)static_cast<MenuItemPtrClass*>(CurrentMenu->SelectedItem())->value;
+  HMI_value.Color[0] = GetRColor(*HMI_value.P_Int);  // Red
+  HMI_value.Color[1] = GetGColor(*HMI_value.P_Int);  // Green
+  HMI_value.Color[2] = GetBColor(*HMI_value.P_Int);  // Blue
+  Draw_GetColor_Menu();
+}
+
+void LiveRGBColor() {
+    HMI_value.Color[CurrentMenu->line() - 2] = HMI_value.Value;
+    uint16_t color = RGB(HMI_value.Color[0], HMI_value.Color[1], HMI_value.Color[2]);
+    DWIN_Draw_Rectangle(1, color, 20, 315, DWIN_WIDTH - 20, 335);
+}
+void SetRGBColor() {
+  const uint8_t color = CurrentMenu->SelectedItem()->icon;
+  SetIntOnClick(0, (color == 1) ? 63 : 31, HMI_value.Color[color], nullptr, LiveRGBColor);
+}
+
+void DWIN_ApplyColor() {
+  *HMI_value.P_Int = RGB(HMI_value.Color[0], HMI_value.Color[1], HMI_value.Color[2]);
+  DWINUI::SetColors(HMI_data.Text_Color, HMI_data.Background_Color);
+  Draw_Status_Area(false);
+  Draw_SelectColors_Menu();
+  LCD_MESSAGE_F(GET_TEXT_F(MSG_COLORS_APPLIED));
+}
+
+void SetSpeed() { SetPIntOnClick(MIN_PRINT_SPEED, MAX_PRINT_SPEED); }
+
+#if HAS_HOTEND
+  void ApplyHotendTemp() { thermalManager.setTargetHotend(HMI_value.Value, 0); }
+  void SetHotendTemp() { SetIntOnClick(MIN_ETEMP, MAX_ETEMP, thermalManager.degTargetHotend(0), ApplyHotendTemp); }
+#endif
+
+#if HAS_HEATED_BED
+  void ApplyBedTemp() { thermalManager.setTargetBed(HMI_value.Value); }
+  void SetBedTemp() { SetIntOnClick(BED_MINTEMP, BED_MAX_TARGET, thermalManager.degTargetBed(), ApplyBedTemp); }
+#endif
+
+#if HAS_FAN
+  void ApplyFanSpeed() { thermalManager.set_fan_speed(0, HMI_value.Value); }
+  void SetFanSpeed() { SetIntOnClick(0, 255, thermalManager.fan_speed[0], ApplyFanSpeed); }
+#endif
+
+#if ENABLED(ADVANCED_PAUSE_FEATURE)
+
+  void ChangeFilament() {
+    HMI_SaveProcessID(NothingToDo);
+    queue.inject(F("M600 B2"));
+  }
+
+  void ParkHead(){
+    LCD_MESSAGE(MSG_FILAMENT_PARK_ENABLED);
+    queue.inject(F("G28O\nG27"));
+  }
+
+  #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
+    void UnloadFilament(){
+      LCD_MESSAGE(MSG_FILAMENTUNLOAD);
+      queue.inject(F("M702 Z20"));
+    }
+
+    void LoadFilament(){
+      LCD_MESSAGE(MSG_FILAMENTLOAD);
+      queue.inject(F("M701 Z20"));
+    }
+  #endif
+
+#endif // ADVANCED_PAUSE_FEATURE
+
+void ApplyFlow() { planner.refresh_e_factor(0); }
+void SetFlow() { SetPIntOnClick(MIN_PRINT_FLOW, MAX_PRINT_FLOW, ApplyFlow); }
+
+// Bed Tramming
+void Tram(uint8_t point) {
+  char cmd[100] = "";
+  #if HAS_ONESTEP_LEVELING
+    static bool inLev = false;
+    if (inLev) return;
+    char str_1[6] = "", str_2[6] = "", str_3[6] = "";
+    #define fmt "X:%s, Y:%s, Z:%s"
+    float xpos = 0, ypos = 0, zval = 0;
+    float margin = PROBING_MARGIN;
+  #else
+    #define fmt "M420S0\nG28O\nG90\nG0Z5F300\nG0X%iY%iF5000\nG0Z0F300"
+    int16_t xpos = 0, ypos = 0;
+    int16_t margin = 30;
+  #endif
+
+  switch (point) {
+    case 0:
+      LCD_MESSAGE(MSG_LEVBED_FL);
+      xpos = ypos = margin;
+      break;
+    case 1:
+      LCD_MESSAGE(MSG_LEVBED_FR);
+      xpos = X_BED_SIZE - margin; ypos = margin;
+      break;
+    case 2:
+      LCD_MESSAGE(MSG_LEVBED_BR);
+      xpos = X_BED_SIZE - margin; ypos = Y_BED_SIZE - margin;
+      break;
+    case 3:
+      LCD_MESSAGE(MSG_LEVBED_BL);
+      xpos = margin; ypos = Y_BED_SIZE - margin;
+      break;
+    case 4:
+      LCD_MESSAGE(MSG_LEVBED_C);
+      xpos = X_BED_SIZE / 2; ypos = Y_BED_SIZE / 2;
+      break;
+  }
+
+  #if HAS_ONESTEP_LEVELING
+    planner.synchronize();
+    probe.stow();
+    gcode.process_subcommands_now(F("M420S0\nG28O"));
+    planner.synchronize();
+    inLev = true;
+    zval = probe.probe_at_point(xpos, ypos, PROBE_PT_STOW);
+    sprintf_P(cmd, PSTR(fmt),
+      dtostrf(xpos, 1, 1, str_1),
+      dtostrf(ypos, 1, 1, str_2),
+      dtostrf(zval, 1, 2, str_3)
+    );
+    ui.set_status(cmd);
+    inLev = false;
+  #else
+    planner.synchronize();
+    sprintf_P(cmd, PSTR(fmt), xpos, ypos);
+    queue.inject(cmd);
+  #endif
+}
+
+void TramFL() { Tram(0); }
+void TramFR() { Tram(1); }
+void TramBR() { Tram(2); }
+void TramBL() { Tram(3); }
+void TramC () { Tram(4); }
+
+#if ENABLED(MESH_BED_LEVELING)
+
+  void ManualMeshStart(){
+    LCD_MESSAGE(MSG_UBL_BUILD_MESH_MENU);
+    gcode.process_subcommands_now(F("G28Z\nM211S0\nG29S1"));
+    planner.synchronize();
+    #ifdef MANUAL_PROBE_START_Z
+      const uint8_t line = CurrentMenu->line(MMeshMoveZItem->pos);
+      DWINUI::Draw_Signed_Float(HMI_data.Text_Color, HMI_data.Background_Color, 3, 2, VALX - 2 * DWINUI::fontWidth(DWIN_FONT_MENU), MBASE(line), MANUAL_PROBE_START_Z);
+    #endif
+  }
+
+  void LiveMeshMoveZ() {
+    *HMI_value.P_Float = HMI_value.Value / POW(10, 2);
+    if (!planner.is_full()) {
+      planner.synchronize();
+      planner.buffer_line(current_position, homing_feedrate(Z_AXIS));
+    }
+  }
+  void SetMMeshMoveZ() { SetPFloatOnClick(-1, 1, 2, planner.synchronize, LiveMeshMoveZ);}
+
+  void ManualMeshContinue(){
+    gcode.process_subcommands_now(F("G29S2"));
+    planner.synchronize();
+    MMeshMoveZItem->draw(CurrentMenu->line(MMeshMoveZItem->pos));
+  }
+
+  void ManualMeshSave(){
+    LCD_MESSAGE(MSG_UBL_STORAGE_MESH_MENU);
+    queue.inject(F("M211S1\nM500"));
+  }
+
+#endif // MESH_BED_LEVELING
+
+#if HAS_PREHEAT
+  #if HAS_HOTEND
+    void SetPreheatEndTemp() { SetPIntOnClick(MIN_ETEMP, MAX_ETEMP); }
+  #endif
+  #if HAS_HEATED_BED
+    void SetPreheatBedTemp() { SetPIntOnClick(BED_MINTEMP, BED_MAX_TARGET); }
+  #endif
+  #if HAS_FAN
+    void SetPreheatFanSpeed() { SetPIntOnClick(0, 255); }
+  #endif
+#endif
+
+void ApplyMaxSpeed() { planner.set_max_feedrate(HMI_value.axis, HMI_value.Value / MINUNITMULT); }
+void SetMaxSpeedX() { HMI_value.axis = X_AXIS, SetFloatOnClick(MIN_MAXFEEDSPEED, default_max_feedrate[X_AXIS] * 2, UNITFDIGITS, planner.settings.max_feedrate_mm_s[X_AXIS], ApplyMaxSpeed); }
+void SetMaxSpeedY() { HMI_value.axis = Y_AXIS, SetFloatOnClick(MIN_MAXFEEDSPEED, default_max_feedrate[Y_AXIS] * 2, UNITFDIGITS, planner.settings.max_feedrate_mm_s[Y_AXIS], ApplyMaxSpeed); }
+void SetMaxSpeedZ() { HMI_value.axis = Z_AXIS, SetFloatOnClick(MIN_MAXFEEDSPEED, default_max_feedrate[Z_AXIS] * 2, UNITFDIGITS, planner.settings.max_feedrate_mm_s[Z_AXIS], ApplyMaxSpeed); }
+#if HAS_HOTEND
+  void SetMaxSpeedE() { HMI_value.axis = E_AXIS; SetFloatOnClick(MIN_MAXFEEDSPEED, default_max_feedrate[E_AXIS] * 2, UNITFDIGITS, planner.settings.max_feedrate_mm_s[E_AXIS], ApplyMaxSpeed); }
+#endif
+
+void ApplyMaxAccel() { planner.set_max_acceleration(HMI_value.axis, HMI_value.Value); }
+void SetMaxAccelX() { HMI_value.axis = X_AXIS, SetIntOnClick(MIN_MAXACCELERATION, default_max_acceleration[X_AXIS] * 2, planner.settings.max_acceleration_mm_per_s2[X_AXIS], ApplyMaxAccel); }
+void SetMaxAccelY() { HMI_value.axis = Y_AXIS, SetIntOnClick(MIN_MAXACCELERATION, default_max_acceleration[Y_AXIS] * 2, planner.settings.max_acceleration_mm_per_s2[Y_AXIS], ApplyMaxAccel); }
+void SetMaxAccelZ() { HMI_value.axis = Z_AXIS, SetIntOnClick(MIN_MAXACCELERATION, default_max_acceleration[Z_AXIS] * 2, planner.settings.max_acceleration_mm_per_s2[Z_AXIS], ApplyMaxAccel); }
+#if HAS_HOTEND
+  void SetMaxAccelE() { HMI_value.axis = E_AXIS; SetIntOnClick(MIN_MAXACCELERATION, default_max_acceleration[E_AXIS] * 2, planner.settings.max_acceleration_mm_per_s2[E_AXIS], ApplyMaxAccel); }
+#endif
+
+#if HAS_CLASSIC_JERK
+  void ApplyMaxJerk() { planner.set_max_jerk(HMI_value.axis, HMI_value.Value / MINUNITMULT); }
+  void SetMaxJerkX() { HMI_value.axis = X_AXIS, SetFloatOnClick(MIN_MAXJERK, default_max_jerk[X_AXIS] * 2, UNITFDIGITS, planner.max_jerk[X_AXIS], ApplyMaxJerk); }
+  void SetMaxJerkY() { HMI_value.axis = Y_AXIS, SetFloatOnClick(MIN_MAXJERK, default_max_jerk[Y_AXIS] * 2, UNITFDIGITS, planner.max_jerk[Y_AXIS], ApplyMaxJerk); }
+  void SetMaxJerkZ() { HMI_value.axis = Z_AXIS, SetFloatOnClick(MIN_MAXJERK, default_max_jerk[Z_AXIS] * 2, UNITFDIGITS, planner.max_jerk[Z_AXIS], ApplyMaxJerk); }
+  #if HAS_HOTEND
+    void SetMaxJerkE() { HMI_value.axis = E_AXIS; SetFloatOnClick(MIN_MAXJERK, default_max_jerk[E_AXIS] * 2, UNITFDIGITS, planner.max_jerk[E_AXIS], ApplyMaxJerk); }
+  #endif
+#endif
+
+void SetStepsX() { HMI_value.axis = X_AXIS, SetPFloatOnClick( MIN_STEP, MAX_STEP, UNITFDIGITS); }
+void SetStepsY() { HMI_value.axis = Y_AXIS, SetPFloatOnClick( MIN_STEP, MAX_STEP, UNITFDIGITS); }
+void SetStepsZ() { HMI_value.axis = Z_AXIS, SetPFloatOnClick( MIN_STEP, MAX_STEP, UNITFDIGITS); }
+#if HAS_HOTEND
+  void SetStepsE() { HMI_value.axis = E_AXIS; SetPFloatOnClick( MIN_STEP, MAX_STEP, UNITFDIGITS); }
+  void SetHotendPidT() { SetPIntOnClick(MIN_ETEMP, MAX_ETEMP); }
+#endif
+#if HAS_HEATED_BED
+  void SetBedPidT() { SetPIntOnClick(BED_MINTEMP, BED_MAX_TARGET); }
+#endif
+
+#if HAS_HOTEND || HAS_HEATED_BED
+  void SetPidCycles() { SetPIntOnClick(3, 50); }
+  void SetKp() { SetPFloatOnClick(0, 1000, 2); }
+  void ApplyPIDi() {
+    *HMI_value.P_Float = scalePID_i(HMI_value.Value / POW(10, 2));
+    thermalManager.updatePID();
+  }
+  void ApplyPIDd() {
+    *HMI_value.P_Float = scalePID_d(HMI_value.Value / POW(10, 2));
+    thermalManager.updatePID();
+  }
+  void SetKi() {
+    HMI_value.P_Float = (float*)static_cast<MenuItemPtrClass*>(CurrentMenu->SelectedItem())->value;
+    const float value = unscalePID_i(*HMI_value.P_Float);
+    SetFloatOnClick(0, 1000, 2, value, ApplyPIDi);
+  }
+  void SetKd() {
+    HMI_value.P_Float = (float*)static_cast<MenuItemPtrClass*>(CurrentMenu->SelectedItem())->value;
+    const float value = unscalePID_d(*HMI_value.P_Float);
+    SetFloatOnClick(0, 1000, 2, value, ApplyPIDd);
+  }
+#endif
+
+#if ENABLED(FWRETRACT)
+  void SetRetractLength() { SetPFloatOnClick( 0, 10, UNITFDIGITS); };
+  void SetRetractSpeed() { SetPFloatOnClick( 1, 90, UNITFDIGITS); };
+  void SetZRaise() { SetPFloatOnClick( 0, 2, 2); };
+  void SetRecoverSpeed() { SetPFloatOnClick( 1, 90, UNITFDIGITS); };
+#endif
+
+// Menuitem Drawing functions =================================================
+
+void onDrawMenuItem(MenuItemClass* menuitem, int8_t line) {
+  if (menuitem->icon) DWINUI::Draw_Icon(menuitem->icon, ICOX, MBASE(line) - 3);
+  if (menuitem->frameid)
+    DWIN_Frame_AreaCopy(menuitem->frameid, menuitem->frame.left, menuitem->frame.top, menuitem->frame.right, menuitem->frame.bottom, LBLX, MBASE(line));
+  else if (menuitem->caption)
+    DWINUI::Draw_String(LBLX, MBASE(line) - 1, menuitem->caption);
+  DWIN_Draw_HLine(HMI_data.SplitLine_Color, 16, MYPOS(line + 1), 240);
+}
+
+void onDrawSubMenu(MenuItemClass* menuitem, int8_t line) {
+  onDrawMenuItem(menuitem, line);
+  DWINUI::Draw_Icon(ICON_More, VALX + 16, MBASE(line) - 3);
+}
+
+void onDrawIntMenu(MenuItemClass* menuitem, int8_t line, uint16_t value) {
+  onDrawMenuItem(menuitem, line);
+  Draw_Menu_IntValue(HMI_data.Background_Color, line, 4, value);
+}
+
+void onDrawPIntMenu(MenuItemClass* menuitem, int8_t line) {
+  const uint16_t value = *(uint16_t*)static_cast<MenuItemPtrClass*>(menuitem)->value;
+  onDrawIntMenu(menuitem, line, value);
+}
+
+void onDrawPInt8Menu(MenuItemClass* menuitem, int8_t line) {
+  const uint8_t value = *(uint8_t*)static_cast<MenuItemPtrClass*>(menuitem)->value;
+  onDrawIntMenu(menuitem, line, value);
+}
+
+void onDrawPInt32Menu(MenuItemClass* menuitem, int8_t line) {
+  const uint32_t value = *(uint32_t*)static_cast<MenuItemPtrClass*>(menuitem)->value;
+  onDrawIntMenu(menuitem, line, value);
+}
+
+void onDrawFloatMenu(MenuItemClass* menuitem, int8_t line, uint8_t dp, const float value) {
+  onDrawMenuItem(menuitem, line);
+  DWINUI::Draw_Signed_Float(HMI_data.Text_Color, HMI_data.Background_Color, 3, dp, VALX - dp * DWINUI::fontWidth(DWIN_FONT_MENU), MBASE(line), value);
+}
+
+void onDrawPFloatMenu(MenuItemClass* menuitem, int8_t line) {
+  const float value = *(float*)static_cast<MenuItemPtrClass*>(menuitem)->value;
+  const int8_t dp = UNITFDIGITS;
+  onDrawFloatMenu(menuitem, line, dp, value);
+}
+
+void onDrawPFloat2Menu(MenuItemClass* menuitem, int8_t line) {
+  const float value = *(float*)static_cast<MenuItemPtrClass*>(menuitem)->value;
+  onDrawFloatMenu(menuitem, line, 2, value);
+}
+
+void onDrawChkbMenu(MenuItemClass* menuitem, int8_t line, bool checked) {
+  onDrawMenuItem(menuitem, line);
+  Draw_Chkb_Line(line, checked);
+}
+
+void onDrawBack(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) menuitem->SetFrame(1, 129, 72, 156, 84);
+  onDrawMenuItem(menuitem, line);
+}
+
+void onDrawTempSubMenu(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) menuitem->SetFrame(1,  57, 104,  84, 116);
+  onDrawSubMenu(menuitem, line);
+}
+
+void onDrawMotionSubMenu(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) menuitem->SetFrame(1,  87, 104, 114, 116);
+  onDrawSubMenu(menuitem, line);
+}
+
+#if ENABLED(EEPROM_SETTINGS)
+  void onDrawWriteEeprom(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) menuitem->SetFrame(1, 117, 104, 172, 116);
+    onDrawMenuItem(menuitem, line);
+  }
+
+  void onDrawReadEeprom(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) menuitem->SetFrame(1, 174, 103, 229, 116);
+    onDrawMenuItem(menuitem, line);
+  }
+
+  void onDrawResetEeprom(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) menuitem->SetFrame(1,   1, 118,  56, 131);
+    onDrawMenuItem(menuitem, line);
+  }
+#endif
+
+void onDrawInfoSubMenu(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) menuitem->SetFrame(1, 231, 104, 258, 116);
+  onDrawSubMenu(menuitem, line);
+}
+
+void onDrawMoveX(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) menuitem->SetFrame(1, 58, 118, 106, 132);
+  onDrawPFloatMenu(menuitem, line);
+}
+
+void onDrawMoveY(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) menuitem->SetFrame(1, 109, 118, 157, 132);
+  onDrawPFloatMenu(menuitem, line);
+}
+
+void onDrawMoveZ(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) menuitem->SetFrame(1, 160, 118, 209, 132);
+  onDrawPFloatMenu(menuitem, line);
+}
+
+#if HAS_HOTEND
+  void onDrawMoveE(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) menuitem->SetFrame(1, 212, 118, 253, 131);
+    onDrawPFloatMenu(menuitem, line);
+  }
+#endif
+
+void onDrawMoveSubMenu(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) menuitem->SetFrame(1, 159, 70, 200, 84);
+  onDrawSubMenu(menuitem, line);
+}
+
+void onDrawDisableMotors(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) menuitem->SetFrame(1, 204, 70, 259, 82);
+  onDrawMenuItem(menuitem, line);
+}
+
+void onDrawAutoHome(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) menuitem->SetFrame(1, 0, 89, 41, 101);
+  onDrawMenuItem(menuitem, line);
+}
+
+#if HAS_ZOFFSET_ITEM
+  #if EITHER(HAS_BED_PROBE, BABYSTEPPING)
+    void onDrawZOffset(MenuItemClass* menuitem, int8_t line) {
+      if (HMI_IsChinese()) menuitem->SetFrame(1, 174, 164, 223, 177);
+      onDrawPFloat2Menu(menuitem, line);
+    }
+  #else
+    void onDrawHomeOffset(MenuItemClass* menuitem, int8_t line) {
+      if (HMI_IsChinese()) menuitem->SetFrame(1, 43, 89, 98, 101);
+      onDrawMenuItem(menuitem, line);
+    }
+  #endif
+#endif
+
+#if HAS_HOTEND
+  void onDrawPreheat1(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) menuitem->SetFrame(1, 100, 89, 151, 101);
+    onDrawMenuItem(menuitem, line);
+  }
+  void onDrawPreheat2(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) menuitem->SetFrame(1, 180, 89, 233, 100);
+    onDrawMenuItem(menuitem, line);
+  }
+#endif
+
+#if HAS_PREHEAT
+  void onDrawCooldown(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) menuitem->SetFrame(1, 1, 104,  56, 117);
+    onDrawMenuItem(menuitem, line);
+  }
+#endif
+
+void onDrawLanguage(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) menuitem->SetFrame(1, 239, 134, 266, 146);
+  onDrawMenuItem(menuitem, line);
+  DWINUI::Draw_String(VALX, MBASE(line), HMI_IsChinese() ? F("CN") : F("EN"));
+}
+
+#if ENABLED(POWER_LOSS_RECOVERY)
+  void onDrawPwrLossR(MenuItemClass* menuitem, int8_t line) { onDrawChkbMenu(menuitem, line, recovery.enabled); }
+#endif
+
+#if ENABLED(CASE_LIGHT_MENU)
+  void onDrawCaseLight(MenuItemClass* menuitem, int8_t line) { onDrawChkbMenu(menuitem, line, caselight.on); }
+#endif
+
+#if ENABLED(LED_CONTROL_MENU)
+  #if !BOTH(CASE_LIGHT_MENU, CASE_LIGHT_USE_NEOPIXEL)
+    void onDrawLedStatus(MenuItemClass* menuitem, int8_t line) { onDrawChkbMenu(menuitem, line, leds.lights_on); }
+  #endif
+#endif
+
+#if ENABLED(SOUND_MENU_ITEM)
+  void onDrawEnableSound(MenuItemClass* menuitem, int8_t line) { onDrawChkbMenu(menuitem, line, ui.buzzer_enabled); }
+#endif
+
+#ifdef BLTOUCH_HS_MODE
+  void onDrawHSMode(MenuItemClass* menuitem, int8_t line) { onDrawChkbMenu(menuitem, line, bltouch.high_speed_mode); }
+#endif
+
+void onDrawSelColorItem(MenuItemClass* menuitem, int8_t line) {
+  const uint16_t color = *(uint16_t*)static_cast<MenuItemPtrClass*>(menuitem)->value;
+  DWIN_Draw_Rectangle(0, HMI_data.Highlight_Color, ICOX + 1, MBASE(line) - 1 + 1, ICOX + 18, MBASE(line) - 1 + 18);
+  DWIN_Draw_Rectangle(1, color, ICOX + 2, MBASE(line) - 1 + 2, ICOX + 17, MBASE(line) - 1 + 17);
+  onDrawMenuItem(menuitem, line);
+}
+
+void onDrawGetColorItem(MenuItemClass* menuitem, int8_t line) {
+  const uint8_t i = menuitem->icon;
+  uint16_t color;
+  switch (i) {
+    case 0: color = RGB(31, 0, 0); break; // Red
+    case 1: color = RGB(0, 63, 0); break; // Green
+    case 2: color = RGB(0, 0, 31); break; // Blue
+    default: color = 0; break;
+  }
+  DWIN_Draw_Rectangle(0, HMI_data.Highlight_Color, ICOX + 1, MBASE(line) - 1 + 1, ICOX + 18, MBASE(line) - 1 + 18);
+  DWIN_Draw_Rectangle(1, color, ICOX + 2, MBASE(line) - 1 + 2, ICOX + 17, MBASE(line) - 1 + 17);
+  DWINUI::Draw_String(LBLX, MBASE(line) - 1, menuitem->caption);
+  Draw_Menu_IntValue(HMI_data.Background_Color, line, 4, HMI_value.Color[i]);
+  DWIN_Draw_HLine(HMI_data.SplitLine_Color, 16, MYPOS(line + 1), 240);
+}
+
+#if HAS_FILAMENT_SENSOR
+  void onDrawRunoutEnable(MenuItemClass* menuitem, int8_t line) { onDrawChkbMenu(menuitem, line, runout.enabled); }
+#endif
+
+void onDrawPIDi(MenuItemClass* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, unscalePID_i(*(float*)static_cast<MenuItemPtrClass*>(menuitem)->value)); }
+void onDrawPIDd(MenuItemClass* menuitem, int8_t line) { onDrawFloatMenu(menuitem, line, 2, unscalePID_d(*(float*)static_cast<MenuItemPtrClass*>(menuitem)->value)); }
+
+void onDrawSpeedItem(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) menuitem->SetFrame(1, 116, 164, 171, 176);
+  onDrawPIntMenu(menuitem, line);
+}
+
+#if HAS_HOTEND
+  void onDrawHotendTemp(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) menuitem->SetFrame(1, 1, 134, 56, 146);
+    onDrawPIntMenu(menuitem, line);
+  }
+#endif
+
+#if HAS_HEATED_BED
+  void onDrawBedTemp(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) menuitem->SetFrame(1, 58, 134, 113, 146);
+    onDrawPIntMenu(menuitem, line);
+  }
+#endif
+
+#if HAS_FAN
+  void onDrawFanSpeed(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) menuitem->SetFrame(1, 115, 134, 170, 146);
+    onDrawPInt8Menu(menuitem, line);
+  }
+#endif
+
+void onDrawSteps(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) menuitem->SetFrame(1, 153, 148, 194, 161);
+  onDrawSubMenu(menuitem, line);
+}
+
+#if ENABLED(MESH_BED_LEVELING)
+  void onDrawMMeshMoveZ(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) menuitem->SetFrame(1, 160, 118, 209, 132);
+    onDrawPFloat2Menu(menuitem, line);
+  }
+#endif
+
+#if HAS_PREHEAT
+  #if HAS_HOTEND
+    void onDrawSetPreheatHotend(MenuItemClass* menuitem, int8_t line) {
+      if (HMI_IsChinese()) menuitem->SetFrame(1, 1, 134, 56, 146);
+      onDrawPIntMenu(menuitem, line);
+    }
+  #endif
+  #if HAS_HEATED_BED
+    void onDrawSetPreheatBed(MenuItemClass* menuitem, int8_t line) {
+      if (HMI_IsChinese()) menuitem->SetFrame(1, 58, 134, 113, 146);
+      onDrawPIntMenu(menuitem, line);
+    }
+  #endif
+  #if HAS_FAN
+    void onDrawSetPreheatFan(MenuItemClass* menuitem, int8_t line) {
+      if (HMI_IsChinese()) menuitem->SetFrame(1, 115, 134, 170, 146);
+      onDrawPIntMenu(menuitem, line);
+    }
+  #endif
+  void onDrawPLAPreheatSubMenu(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) menuitem->SetFrame(1, 100, 89, 178, 101);
+    onDrawSubMenu(menuitem,line);
+  }
+  void onDrawABSPreheatSubMenu(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) menuitem->SetFrame(1, 180, 89, 260, 100);
+    onDrawSubMenu(menuitem,line);
+  }
+#endif // HAS_PREHEAT
+
+void onDrawSpeed(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese())
+    menuitem->SetFrame(1, 173, 133, 228, 147);
+  onDrawSubMenu(menuitem, line);
+}
+
+void onDrawMaxSpeedX(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) {
+    menuitem->SetFrame(1, 173, 133, 228, 147);
+    DWIN_Frame_AreaCopy(1, 229, 133, 236, 147, LBLX + 58, MBASE(line));     // X
+  }
+  onDrawPFloatMenu(menuitem, line);
+}
+
+void onDrawMaxSpeedY(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) {
+    menuitem->SetFrame(1, 173, 133, 228, 147);
+    DWIN_Frame_AreaCopy(1, 1, 150, 7, 160, LBLX + 58, MBASE(line));         // Y
+  }
+  onDrawPFloatMenu(menuitem, line);
+}
+
+void onDrawMaxSpeedZ(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) {
+    menuitem->SetFrame(1, 173, 133, 228, 147);
+    DWIN_Frame_AreaCopy(1, 9, 150, 16, 160, LBLX + 58, MBASE(line) + 3);    // Z
+  }
+  onDrawPFloatMenu(menuitem, line);
+}
+
+#if HAS_HOTEND
+  void onDrawMaxSpeedE(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) {
+      menuitem->SetFrame(1, 173, 133, 228, 147);
+      DWIN_Frame_AreaCopy(1, 18, 150, 25, 160, LBLX + 58, MBASE(line));     // E
+    }
+    onDrawPFloatMenu(menuitem, line);
+  }
+#endif
+
+void onDrawAcc(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) {
+    menuitem->SetFrame(1, 173, 133, 200, 147);
+    DWIN_Frame_AreaCopy(1, 28, 149, 69, 161, LBLX + 27, MBASE(line) + 1);   // ...Acceleration
+  }
+  onDrawSubMenu(menuitem, line);
+}
+
+void onDrawMaxAccelX(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) {
+    menuitem->SetFrame(1, 173, 133, 200, 147);
+    DWIN_Frame_AreaCopy(1, 28,  149,  69, 161, LBLX + 27, MBASE(line));
+    DWIN_Frame_AreaCopy(1, 229, 133, 236, 147, LBLX + 71, MBASE(line));     // X
+  }
+  onDrawPInt32Menu(menuitem, line);
+}
+
+void onDrawMaxAccelY(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) {
+    menuitem->SetFrame(1, 173, 133, 200, 147);
+    DWIN_Frame_AreaCopy(1, 28, 149,  69, 161, LBLX + 27, MBASE(line));
+    DWIN_Frame_AreaCopy(1,  1, 150,   7, 160, LBLX + 71, MBASE(line));      // Y
+  }
+  onDrawPInt32Menu(menuitem, line);
+}
+
+void onDrawMaxAccelZ(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) {
+    menuitem->SetFrame(1, 173, 133, 200, 147);
+    DWIN_Frame_AreaCopy(1, 28, 149,  69, 161, LBLX + 27, MBASE(line));
+    DWIN_Frame_AreaCopy(1,  9, 150,  16, 160, LBLX + 71, MBASE(line));      // Z
+  }
+  onDrawPInt32Menu(menuitem, line);
+}
+
+#if HAS_HOTEND
+  void onDrawMaxAccelE(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) {
+      menuitem->SetFrame(1, 173, 133, 200, 147);
+      DWIN_Frame_AreaCopy(1, 28, 149,  69, 161, LBLX + 27, MBASE(line));
+      DWIN_Frame_AreaCopy(1, 18, 150,  25, 160, LBLX + 71, MBASE(line));    // E
+    }
+    onDrawPInt32Menu(menuitem, line);
+  }
+#endif
+
+#if HAS_CLASSIC_JERK
+
+  void onDrawJerk(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) {
+      menuitem->SetFrame(1, 173, 133, 200, 147);
+      DWIN_Frame_AreaCopy(1, 1, 180, 28, 192, LBLX + 27, MBASE(line) + 1);  // ...
+      DWIN_Frame_AreaCopy(1, 202, 133, 228, 147, LBLX + 54, MBASE(line));   // ...Jerk
+    }
+    onDrawSubMenu(menuitem, line);
+  }
+
+  void onDrawMaxJerkX(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) {
+      menuitem->SetFrame(1, 173, 133, 200, 147);
+      DWIN_Frame_AreaCopy(1,   1, 180,  28, 192, LBLX + 27, MBASE(line));
+      DWIN_Frame_AreaCopy(1, 202, 133, 228, 147, LBLX + 53, MBASE(line));
+      DWIN_Frame_AreaCopy(1, 229, 133, 236, 147, LBLX + 83, MBASE(line));
+    }
+    onDrawPFloatMenu(menuitem, line);
+  }
+
+  void onDrawMaxJerkY(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) {
+      menuitem->SetFrame(1, 173, 133, 200, 147);
+      DWIN_Frame_AreaCopy(1,   1, 180,  28, 192, LBLX + 27, MBASE(line));
+      DWIN_Frame_AreaCopy(1, 202, 133, 228, 147, LBLX + 53, MBASE(line));
+      DWIN_Frame_AreaCopy(1,   1, 150,   7, 160, LBLX + 83, MBASE(line));
+    }
+    onDrawPFloatMenu(menuitem, line);
+  }
+
+  void onDrawMaxJerkZ(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) {
+      menuitem->SetFrame(1, 173, 133, 200, 147);
+      DWIN_Frame_AreaCopy(1,   1, 180,  28, 192, LBLX + 27, MBASE(line));
+      DWIN_Frame_AreaCopy(1, 202, 133, 228, 147, LBLX + 53, MBASE(line));
+      DWIN_Frame_AreaCopy(1,   9, 150,  16, 160, LBLX + 83, MBASE(line));
+    }
+    onDrawPFloatMenu(menuitem, line);
+  }
+
+  #if HAS_HOTEND
+    void onDrawMaxJerkE(MenuItemClass* menuitem, int8_t line) {
+      if (HMI_IsChinese()) {
+        menuitem->SetFrame(1, 173, 133, 200, 147);
+        DWIN_Frame_AreaCopy(1,   1, 180,  28, 192, LBLX + 27, MBASE(line));
+        DWIN_Frame_AreaCopy(1, 202, 133, 228, 147, LBLX + 53, MBASE(line));
+        DWIN_Frame_AreaCopy(1,  18, 150,  25, 160, LBLX + 83, MBASE(line));
+      }
+      onDrawPFloatMenu(menuitem, line);
+    }
+  #endif
+
+#endif // HAS_CLASSIC_JERK
+
+void onDrawStepsX(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) {
+    menuitem->SetFrame(1, 153, 148, 194, 161);
+    DWIN_Frame_AreaCopy(1, 229, 133, 236, 147, LBLX + 44, MBASE(line));      // X
+  }
+  onDrawPFloatMenu(menuitem, line);
+}
+
+void onDrawStepsY(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) {
+    menuitem->SetFrame(1, 153, 148, 194, 161);
+    DWIN_Frame_AreaCopy(1,   1, 150,   7, 160, LBLX + 44, MBASE(line));      // Y
+  }
+  onDrawPFloatMenu(menuitem, line);
+}
+
+void onDrawStepsZ(MenuItemClass* menuitem, int8_t line) {
+  if (HMI_IsChinese()) {
+    menuitem->SetFrame(1, 153, 148, 194, 161);
+    DWIN_Frame_AreaCopy(1,   9, 150,  16, 160, LBLX + 44, MBASE(line));      // Z
+  }
+  onDrawPFloatMenu(menuitem, line);
+}
+
+#if HAS_HOTEND
+  void onDrawStepsE(MenuItemClass* menuitem, int8_t line) {
+    if (HMI_IsChinese()) {
+      menuitem->SetFrame(1, 153, 148, 194, 161);
+      DWIN_Frame_AreaCopy(1,  18, 150,  25, 160, LBLX + 44, MBASE(line));    // E
+    }
+    onDrawPFloatMenu(menuitem, line);
+  }
+#endif
+
+// HMI Control functions ======================================================
+
+// Generic menu control using the encoder
+void HMI_Menu() {
+  EncoderState encoder_diffState = get_encoder_state();
+  if (encoder_diffState == ENCODER_DIFF_NO) return;
+  if (CurrentMenu) {
+    if (encoder_diffState == ENCODER_DIFF_ENTER)
+      CurrentMenu->onClick();
+    else
+      CurrentMenu->onScroll(encoder_diffState == ENCODER_DIFF_CW);
+  }
+}
+
+// Get an integer value using the encoder without draw anything
+//  lo: low limit
+//  hi: high limit
+// Return value:
+//  0 : no change
+//  1 : live change
+//  2 : apply change
+int8_t HMI_GetIntNoDraw(const int32_t lo, const int32_t hi) {
+  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
+  if (encoder_diffState != ENCODER_DIFF_NO) {
+    if (Apply_Encoder(encoder_diffState, HMI_value.Value)) {
+      EncoderRate.enabled = false;
+      checkkey = Menu;
+      return 2;
+    }
+    LIMIT(HMI_value.Value, lo, hi);
+    return 1;
+  }
+  return 0;
+}
+
+// Get an integer value using the encoder
+//  lo: low limit
+//  hi: high limit
+// Return value:
+//  0 : no change
+//  1 : live change
+//  2 : apply change
+int8_t HMI_GetInt(const int32_t lo, const int32_t hi) {
+  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
+  if (encoder_diffState != ENCODER_DIFF_NO) {
+    if (Apply_Encoder(encoder_diffState, HMI_value.Value)) {
+      EncoderRate.enabled = false;
+      DWINUI::Draw_Int(HMI_data.Text_Color, HMI_data.Background_Color, 4 , VALX, MBASE(CurrentMenu->line()) - 1, HMI_value.Value);
+      checkkey = Menu;
+      return 2;
+    }
+    LIMIT(HMI_value.Value, lo, hi);
+    DWINUI::Draw_Int(HMI_data.Text_Color, HMI_data.Selected_Color, 4 , VALX, MBASE(CurrentMenu->line()) - 1, HMI_value.Value);
+    return 1;
+  }
+  return 0;
+}
+
+// Set an integer using the encoder
+void HMI_SetInt() {
+  int8_t val = HMI_GetInt(HMI_value.MinValue, HMI_value.MaxValue);
+  switch (val) {
+    case 0: return; break;
+    case 1: if (HMI_value.LiveUpdate) HMI_value.LiveUpdate(); break;
+    case 2: if (HMI_value.Apply) HMI_value.Apply(); break;
+  }
+}
+
+// Set an integer without drawing
+void HMI_SetIntNoDraw() {
+  int8_t val = HMI_GetIntNoDraw(HMI_value.MinValue, HMI_value.MaxValue);
+  switch (val) {
+    case 0: return; break;
+    case 1: if (HMI_value.LiveUpdate) HMI_value.LiveUpdate(); break;
+    case 2: if (HMI_value.Apply) HMI_value.Apply(); break;
+  }
+}
+
+// Set an integer pointer variable using the encoder
+void HMI_SetPInt() {
+  int8_t val = HMI_GetInt(HMI_value.MinValue, HMI_value.MaxValue);
+  switch (val) {
+    case 0: return;
+    case 1: if (HMI_value.LiveUpdate) HMI_value.LiveUpdate(); break;
+    case 2: *HMI_value.P_Int = HMI_value.Value; if (HMI_value.Apply) HMI_value.Apply(); break;
+  }
+}
+
+// Get a scaled float value using the encoder
+//  dp: decimal places
+//  lo: scaled low limit
+//  hi: scaled high limit
+// Return value:
+//  0 : no change
+//  1 : live change
+//  2 : apply change
+int8_t HMI_GetFloat(uint8_t dp, int32_t lo, int32_t hi) {
+  EncoderState encoder_diffState = Encoder_ReceiveAnalyze();
+  if (encoder_diffState != ENCODER_DIFF_NO) {
+    if (Apply_Encoder(encoder_diffState, HMI_value.Value)) {
+      EncoderRate.enabled = false;
+      DWINUI::Draw_Signed_Float(HMI_data.Text_Color, HMI_data.Background_Color, 3, dp, VALX - dp * DWINUI::fontWidth(DWIN_FONT_MENU), MBASE(CurrentMenu->line()), HMI_value.Value / POW(10, dp));
+      checkkey = Menu;
+      return 2;
+    }
+    LIMIT(HMI_value.Value, lo, hi);
+    DWINUI::Draw_Signed_Float(HMI_data.Text_Color, HMI_data.Selected_Color, 3, dp, VALX - dp * DWINUI::fontWidth(DWIN_FONT_MENU), MBASE(CurrentMenu->line()), HMI_value.Value / POW(10, dp));
+    return 1;
+  }
+  return 0;
+}
+
+// Set a scaled float using the encoder
+void HMI_SetFloat() {
+  const int8_t val = HMI_GetFloat(HMI_value.dp, HMI_value.MinValue, HMI_value.MaxValue);
+  switch (val) {
+    case 0: return;
+    case 1: if (HMI_value.LiveUpdate) HMI_value.LiveUpdate(); break;
+    case 2: if (HMI_value.Apply) HMI_value.Apply(); break;
+  }
+}
+
+// Set a scaled float pointer variable using the encoder
+void HMI_SetPFloat() {
+  const int8_t val = HMI_GetFloat(HMI_value.dp, HMI_value.MinValue, HMI_value.MaxValue);
+  switch (val) {
+    case 0: return;
+    case 1: if (HMI_value.LiveUpdate) HMI_value.LiveUpdate(); break;
+    case 2: *HMI_value.P_Float = HMI_value.Value / POW(10, HMI_value.dp); if (HMI_value.Apply) HMI_value.Apply(); break;
+  }
+}
+
+// Menu Creation and Drawing functions ======================================================
+
+void SetMenuTitle(frame_rect_t cn, const __FlashStringHelper* fstr) {
+  if (HMI_IsChinese() && (cn.w != 0))
+    CurrentMenu->MenuTitle.SetFrame(cn.x, cn.y, cn.w, cn.h);
+  else
+    CurrentMenu->MenuTitle.SetCaption(fstr);
+}
+
+void Draw_Prepare_Menu() {
+  checkkey = Menu;
+  if (!PrepareMenu) PrepareMenu = new MenuClass();
+  if (CurrentMenu != PrepareMenu) {
+    CurrentMenu = PrepareMenu;
+    SetMenuTitle({133, 1, 28, 13}, GET_TEXT_F(MSG_PREPARE));
+    DWINUI::MenuItemsPrepare(13);
+    MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Goto_Main_Menu);
+    #if ENABLED(ADVANCED_PAUSE_FEATURE)
+      MENU_ITEM(ICON_FilMan, GET_TEXT_F(MSG_FILAMENT_MAN), onDrawSubMenu, Draw_FilamentMan_Menu);
+    #endif
+    MENU_ITEM(ICON_Axis, GET_TEXT_F(MSG_MOVE_AXIS), onDrawMoveSubMenu, Goto_Move_Menu);
+    MENU_ITEM(ICON_Tram, GET_TEXT_F(MSG_BED_TRAMMING), onDrawSubMenu, Draw_Tramming_Menu);
+    MENU_ITEM(ICON_CloseMotor, GET_TEXT_F(MSG_DISABLE_STEPPERS), onDrawDisableMotors, DisableMotors);
+    #if ENABLED(INDIVIDUAL_AXIS_HOMING_SUBMENU)
+      MENU_ITEM(ICON_Homing, GET_TEXT_F(MSG_HOMING), onDrawSubMenu, Draw_Homing_Menu);
+    #else
+      MENU_ITEM(ICON_Homing, GET_TEXT_F(MSG_AUTO_HOME), onDrawAutoHome, AutoHome);
+    #endif
+    #if ENABLED(MESH_BED_LEVELING)
+      MENU_ITEM(ICON_ManualMesh, GET_TEXT_F(MSG_MANUAL_MESH), onDrawSubMenu, Draw_ManualMesh_Menu);
+    #endif
+    #if HAS_ONESTEP_LEVELING
+      MENU_ITEM(ICON_Level, GET_TEXT_F(MSG_AUTO_MESH), onDrawMenuItem, AutoLev);
+    #endif
+    #if HAS_ZOFFSET_ITEM
+      #if HAS_BED_PROBE
+        MENU_ITEM(ICON_SetZOffset, GET_TEXT_F(MSG_PROBE_WIZARD), onDrawSubMenu, Draw_ZOffsetWiz_Menu);
+      #elif ENABLED(BABYSTEPPING)
+        EDIT_ITEM(ICON_Zoffset, GET_TEXT_F(MSG_ZPROBE_ZOFFSET), onDrawPFloat2Menu, SetZOffset, &BABY_Z_VAR);
+      #else
+        MENU_ITEM(ICON_SetHome, GET_TEXT_F(MSG_SET_HOME_OFFSETS), onDrawHomeOffset, SetHome);
+      #endif
+    #endif
+    #if HAS_PREHEAT
+      MENU_ITEM(ICON_PLAPreheat, GET_TEXT_F(MSG_PREHEAT_1), onDrawPreheat1, DoPreheat0);
+      #if PREHEAT_COUNT > 1
+        MENU_ITEM(ICON_ABSPreheat, PSTR("Preheat " PREHEAT_2_LABEL), onDrawPreheat2, DoPreheat1);
+      #endif
+      #if PREHEAT_COUNT > 2
+        MENU_ITEM(ICON_CustomPreheat, GET_TEXT_F(MSG_PREHEAT_CUSTOM), onDrawMenuItem, DoPreheat2);
+      #endif
+    #endif
+    MENU_ITEM(ICON_Cool, GET_TEXT_F(MSG_COOLDOWN), onDrawCooldown, DoCoolDown);
+    MENU_ITEM(ICON_Language, PSTR(GET_TEXT_F(MSG_UI_LANGUAGE)), onDrawLanguage, SetLanguage);
+  }
+  CurrentMenu->draw();
+}
+
+void Draw_Tramming_Menu() {
+  DWINUI::ClearMenuArea();
+  checkkey = Menu;
+  if (!TrammingMenu) TrammingMenu = new MenuClass();
+  if (CurrentMenu != TrammingMenu) {
+    CurrentMenu = TrammingMenu;
+    SetMenuTitle({0}, GET_TEXT_F(MSG_BED_TRAMMING)); // TODO: Chinese, English "Bed Tramming" JPG
+    DWINUI::MenuItemsPrepare(6);
+    MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_Prepare_Menu);
+    MENU_ITEM(ICON_Axis, GET_TEXT_F(MSG_LEVBED_FL), onDrawMenuItem, TramFL);
+    MENU_ITEM(ICON_Axis, GET_TEXT_F(MSG_LEVBED_FR), onDrawMenuItem, TramFR);
+    MENU_ITEM(ICON_Axis, GET_TEXT_F(MSG_LEVBED_BR), onDrawMenuItem, TramBR);
+    MENU_ITEM(ICON_Axis, GET_TEXT_F(MSG_LEVBED_BL), onDrawMenuItem, TramBL);
+    MENU_ITEM(ICON_Axis, GET_TEXT_F(MSG_LEVBED_C ), onDrawMenuItem, TramC );
+  }
+  CurrentMenu->draw();
+}
+
+void Draw_Control_Menu() {
+  checkkey = Menu;
+  if (!ControlMenu) ControlMenu = new MenuClass();
+  if (CurrentMenu != ControlMenu) {
+    CurrentMenu = ControlMenu;
+    SetMenuTitle({103, 1, 28, 14}, GET_TEXT_F(MSG_CONTROL));
+    DWINUI::MenuItemsPrepare(8);
+    MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Goto_Main_Menu);
+    #if ENABLED(CASE_LIGHT_MENU)
+      #if ENABLED(CASELIGHT_USES_BRIGHTNESS)
+        MENU_ITEM(ICON_CaseLight, GET_TEXT_F(MSG_CASE_LIGHT), onDrawSubMenu, Draw_CaseLight_Menu);
+      #else
+        MENU_ITEM(ICON_CaseLight, GET_TEXT_F(MSG_CASE_LIGHT), onDrawCaseLight, SetCaseLight);
+      #endif
+    #endif
+    #if ENABLED(LED_CONTROL_MENU)
+      MENU_ITEM(ICON_LedControl, GET_TEXT_F(MSG_LED_CONTROL), onDrawSubMenu, Draw_LedControl_Menu);
+    #endif
+    MENU_ITEM(ICON_Temperature, GET_TEXT_F(MSG_TEMPERATURE), onDrawTempSubMenu, Draw_Temperature_Menu);
+    MENU_ITEM(ICON_Motion, GET_TEXT_F(MSG_MOTION), onDrawMotionSubMenu, Draw_Motion_Menu);
+    #if ENABLED(EEPROM_SETTINGS)
+      MENU_ITEM(ICON_WriteEEPROM, GET_TEXT_F(MSG_STORE_EEPROM), onDrawWriteEeprom, WriteEeprom);
+      MENU_ITEM(ICON_ReadEEPROM, GET_TEXT_F(MSG_LOAD_EEPROM), onDrawReadEeprom, ReadEeprom);
+      MENU_ITEM(ICON_ResumeEEPROM, GET_TEXT_F(MSG_RESTORE_DEFAULTS), onDrawResetEeprom, ResetEeprom);
+    #endif
+    MENU_ITEM(ICON_Reboot, GET_TEXT_F(MSG_RESET_PRINTER), onDrawMenuItem, RebootPrinter);
+    MENU_ITEM(ICON_Info, GET_TEXT_F(MSG_INFO_SCREEN), onDrawInfoSubMenu, Goto_Info_Menu);
+  }
+  CurrentMenu->draw();
+}
+
+void Draw_AdvancedSettings_Menu() {
+  checkkey = Menu;
+  if (!AdvancedSettings) AdvancedSettings = new MenuClass();
+  if (CurrentMenu != AdvancedSettings) {
+    CurrentMenu = AdvancedSettings;
+    SetMenuTitle({0}, GET_TEXT_F(MSG_ADVANCED_SETTINGS)); // TODO: Chinese, English "Advanced Settings" JPG
+    DWINUI::MenuItemsPrepare(15);
+    MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Goto_Main_Menu);
+    #if HAS_HOME_OFFSET
+      MENU_ITEM(ICON_HomeOffset, GET_TEXT_F(MSG_SET_HOME_OFFSETS), onDrawSubMenu, Draw_HomeOffset_Menu);
+    #endif
+    #if HAS_BED_PROBE
+      MENU_ITEM(ICON_ProbeSet, GET_TEXT_F(MSG_ZPROBE_SETTINGS), onDrawSubMenu, Draw_ProbeSet_Menu);
+    #endif
+    #if HAS_HOTEND
+      MENU_ITEM(ICON_PIDNozzle, F("Hotend PID Settings"), onDrawSubMenu, Draw_HotendPID_Menu);
+    #endif
+    #if HAS_HEATED_BED
+      MENU_ITEM(ICON_PIDbed, F("Bed PID Settings"), onDrawSubMenu, Draw_BedPID_Menu);
+    #endif
+    #if HAS_FILAMENT_SENSOR
+      MENU_ITEM(ICON_FilSet, GET_TEXT_F(MSG_FILAMENT_SET), onDrawSubMenu, Draw_FilSet_Menu);
+    #endif
+    #if ENABLED(POWER_LOSS_RECOVERY)
+      MENU_ITEM(ICON_Pwrlossr, GET_TEXT_F(MSG_OUTAGE_RECOVERY), onDrawPwrLossR, SetPwrLossr);
+    #endif
+    #if HAS_LCD_BRIGHTNESS
+      EDIT_ITEM(ICON_Brightness, GET_TEXT_F(MSG_BRIGHTNESS), onDrawPInt8Menu, SetBrightness, &ui.brightness);
+    #endif
+    MENU_ITEM(ICON_Scolor, GET_TEXT_F(MSG_COLORS_SELECT), onDrawSubMenu, Draw_SelectColors_Menu);
+    #if ENABLED(SOUND_MENU_ITEM)
+      MENU_ITEM(ICON_Sound, GET_TEXT_F(MSG_SOUND_ENABLE), onDrawEnableSound, SetEnableSound);
+    #endif
+    #if HAS_MESH
+      MENU_ITEM(ICON_MeshViewer, GET_TEXT_F(MSG_MESH_VIEW), onDrawSubMenu, DWIN_MeshViewer);
+    #endif
+    #if HAS_ESDIAG
+      MENU_ITEM(ICON_ESDiag, F("End-stops diag."), onDrawSubMenu, Draw_EndStopDiag);
+    #endif
+    #if ENABLED(PRINTCOUNTER)
+      MENU_ITEM(ICON_PrintStats, GET_TEXT_F(MSG_INFO_STATS_MENU), onDrawSubMenu, Draw_PrintStats);
+      MENU_ITEM(ICON_PrintStatsReset, GET_TEXT_F(MSG_INFO_PRINT_COUNT_RESET), onDrawSubMenu, PrintStats.Reset);
+    #endif
+    MENU_ITEM(ICON_Lock, GET_TEXT_F(MSG_LOCKSCREEN), onDrawMenuItem, DWIN_LockScreen);
+  }
+  CurrentMenu->draw();
+}
+
+void Draw_Move_Menu() {
+  checkkey = Menu;
+  if (!MoveMenu) MoveMenu = new MenuClass();
+  if (CurrentMenu != MoveMenu) {
+    CurrentMenu = MoveMenu;
+    SetMenuTitle({192, 1, 42, 14}, GET_TEXT_F(MSG_MOVE_AXIS));
+    DWINUI::MenuItemsPrepare(5);
+    MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_Prepare_Menu);
+    EDIT_ITEM(ICON_MoveX, GET_TEXT_F(MSG_MOVE_X), onDrawMoveX, SetMoveX, &current_position.x);
+    EDIT_ITEM(ICON_MoveY, GET_TEXT_F(MSG_MOVE_Y), onDrawMoveY, SetMoveY, &current_position.y);
+    EDIT_ITEM(ICON_MoveZ, GET_TEXT_F(MSG_MOVE_Z), onDrawMoveZ, SetMoveZ, &current_position.z);
+    #if HAS_HOTEND
+      EDIT_ITEM(ICON_Extruder, GET_TEXT_F(MSG_MOVE_E), onDrawMoveE, SetMoveE, &current_position.e);
+    #endif
+  }
+  CurrentMenu->draw();
+  if (!all_axes_trusted()) LCD_MESSAGE_F("WARNING: current position is unknown, home axes");
+}
+
+#if HAS_HOME_OFFSET
+  void Draw_HomeOffset_Menu() {
+    checkkey = Menu;
+    if (!HomeOffMenu) HomeOffMenu = new MenuClass();
+    if (CurrentMenu != HomeOffMenu) {
+      CurrentMenu = HomeOffMenu;
+      SetMenuTitle({0}, GET_TEXT_F(MSG_SET_HOME_OFFSETS)); // TODO: Chinese, English "Set Home Offsets" JPG
+      DWINUI::MenuItemsPrepare(4);
+      MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_AdvancedSettings_Menu);
+      EDIT_ITEM(ICON_HomeOffsetX, GET_TEXT_F(MSG_HOME_OFFSET_X), onDrawPFloatMenu, SetHomeOffsetX, &home_offset[X_AXIS]);
+      EDIT_ITEM(ICON_HomeOffsetY, GET_TEXT_F(MSG_HOME_OFFSET_Y), onDrawPFloatMenu, SetHomeOffsetY, &home_offset[Y_AXIS]);
+      EDIT_ITEM(ICON_HomeOffsetZ, GET_TEXT_F(MSG_HOME_OFFSET_Z), onDrawPFloatMenu, SetHomeOffsetZ, &home_offset[Z_AXIS]);
+    }
+    CurrentMenu->draw();
+  }
+#endif
+
+#if HAS_BED_PROBE
+  void Draw_ProbeSet_Menu() {
+    checkkey = Menu;
+    if (!ProbeSetMenu) ProbeSetMenu = new MenuClass();
+    if (CurrentMenu != ProbeSetMenu) {
+      CurrentMenu = ProbeSetMenu;
+      SetMenuTitle({0}, GET_TEXT_F(MSG_ZPROBE_SETTINGS)); // TODO: Chinese, English "Probe Settings" JPG
+      DWINUI::MenuItemsPrepare(8);
+      MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_AdvancedSettings_Menu);
+      EDIT_ITEM(ICON_ProbeOffsetX, GET_TEXT_F(MSG_ZPROBE_XOFFSET), onDrawPFloatMenu, SetProbeOffsetX, &probe.offset.x);
+      EDIT_ITEM(ICON_ProbeOffsetY, GET_TEXT_F(MSG_ZPROBE_YOFFSET), onDrawPFloatMenu, SetProbeOffsetY, &probe.offset.y);
+      EDIT_ITEM(ICON_ProbeOffsetZ, GET_TEXT_F(MSG_ZPROBE_ZOFFSET), onDrawPFloat2Menu, SetProbeOffsetZ, &probe.offset.z);
+      #ifdef BLTOUCH_HS_MODE
+        MENU_ITEM(ICON_HSMode, F("Enable HS mode"), onDrawHSMode, SetHSMode);
+      #endif
+      MENU_ITEM(ICON_ProbeTest, GET_TEXT_F(MSG_M48_TEST), onDrawMenuItem, ProbeTest);
+      MENU_ITEM(ICON_ProbeStow, GET_TEXT_F(MSG_MANUAL_STOW), onDrawMenuItem, ProbeStow);
+      MENU_ITEM(ICON_ProbeDeploy, GET_TEXT_F(MSG_MANUAL_DEPLOY), onDrawMenuItem, ProbeDeploy);
+    }
+    CurrentMenu->draw();
+  }
+#endif
+
+#if HAS_FILAMENT_SENSOR
+  void Draw_FilSet_Menu() {
+    checkkey = Menu;
+    if (!FilSetMenu) FilSetMenu = new MenuClass();
+    if (CurrentMenu != FilSetMenu) {
+      CurrentMenu = FilSetMenu;
+      CurrentMenu->MenuTitle.SetCaption(GET_TEXT_F(MSG_FILAMENT_SET));
+      DWINUI::MenuItemsPrepare(10);
+      MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawMenuItem, Draw_AdvancedSettings_Menu);
+      #if HAS_FILAMENT_SENSOR
+        MENU_ITEM(ICON_Runout, GET_TEXT_F(MSG_RUNOUT_ENABLE), onDrawRunoutEnable, SetRunoutEnable);
+      #endif
+      #if HAS_FILAMENT_RUNOUT_DISTANCE
+        EDIT_ITEM(ICON_Runout, F("Runout Distance"), onDrawPFloatMenu, SetRunoutDistance, &runout.runout_distance());
+      #endif
+      #if ENABLED(PREVENT_COLD_EXTRUSION)
+        EDIT_ITEM(ICON_ExtrudeMinT, F("Extrude Min Temp."), onDrawPIntMenu, SetExtMinT, &HMI_data.ExtMinT);
+      #endif
+      #if ENABLED(ADVANCED_PAUSE_FEATURE)
+        EDIT_ITEM(ICON_FilLoad, GET_TEXT_F(MSG_FILAMENT_LOAD), onDrawPFloatMenu, SetFilLoad, &fc_settings[0].load_length);
+        EDIT_ITEM(ICON_FilUnload, GET_TEXT_F(MSG_FILAMENT_UNLOAD), onDrawPFloatMenu, SetFilUnload, &fc_settings[0].unload_length);
+      #endif
+      #if ENABLED(FWRETRACT)
+        EDIT_ITEM(ICON_FWRetLength, GET_TEXT_F(MSG_CONTROL_RETRACT), onDrawPFloatMenu, SetRetractLength, &fwretract.settings.retract_length);
+        EDIT_ITEM(ICON_FWRetSpeed, GET_TEXT_F(MSG_SINGLENOZZLE_RETRACT_SPEED), onDrawPFloatMenu, SetRetractSpeed, &fwretract.settings.retract_feedrate_mm_s);
+        EDIT_ITEM(ICON_FWRetZRaise, GET_TEXT_F(MSG_CONTROL_RETRACT_ZHOP), onDrawPFloat2Menu, SetZRaise, &fwretract.settings.retract_zraise);
+        EDIT_ITEM(ICON_FWRecSpeed, GET_TEXT_F(MSG_SINGLENOZZLE_UNRETRACT_SPEED), onDrawPFloatMenu, SetRecoverSpeed, &fwretract.settings.retract_recover_feedrate_mm_s);
+      #endif
+    }
+    CurrentMenu->draw();
+  }
+#endif // HAS_FILAMENT_SENSOR
+
+void Draw_SelectColors_Menu() {
+  checkkey = Menu;
+  if (!SelectColorMenu) SelectColorMenu = new MenuClass();
+  if (CurrentMenu != SelectColorMenu) {
+    CurrentMenu = SelectColorMenu;
+    SetMenuTitle({0}, GET_TEXT_F(MSG_COLORS_SELECT)); // TODO: Chinese, English "Select Color" JPG
+    DWINUI::MenuItemsPrepare(20);
+    MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_AdvancedSettings_Menu);
+    MENU_ITEM(ICON_StockConfiguration, GET_TEXT_F(MSG_RESTORE_DEFAULTS), onDrawMenuItem, RestoreDefaultsColors);
+    EDIT_ITEM(0, "Screen Background", onDrawSelColorItem, SelColor, &HMI_data.Background_Color);
+    EDIT_ITEM(0, "Cursor", onDrawSelColorItem, SelColor, &HMI_data.Cursor_color);
+    EDIT_ITEM(0, "Title Background", onDrawSelColorItem, SelColor, &HMI_data.TitleBg_color);
+    EDIT_ITEM(0, "Title Text", onDrawSelColorItem, SelColor, &HMI_data.TitleTxt_color);
+    EDIT_ITEM(0, "Text", onDrawSelColorItem, SelColor, &HMI_data.Text_Color);
+    EDIT_ITEM(0, "Selected", onDrawSelColorItem, SelColor, &HMI_data.Selected_Color);
+    EDIT_ITEM(0, "Split Line", onDrawSelColorItem, SelColor, &HMI_data.SplitLine_Color);
+    EDIT_ITEM(0, "Highlight", onDrawSelColorItem, SelColor, &HMI_data.Highlight_Color);
+    EDIT_ITEM(0, "Status Background", onDrawSelColorItem, SelColor, &HMI_data.StatusBg_Color);
+    EDIT_ITEM(0, "Status Text", onDrawSelColorItem, SelColor, &HMI_data.StatusTxt_Color);
+    EDIT_ITEM(0, "Popup Background", onDrawSelColorItem, SelColor, &HMI_data.PopupBg_color);
+    EDIT_ITEM(0, "Popup Text", onDrawSelColorItem, SelColor, &HMI_data.PopupTxt_Color);
+    EDIT_ITEM(0, "Alert Background", onDrawSelColorItem, SelColor, &HMI_data.AlertBg_Color);
+    EDIT_ITEM(0, "Alert Text", onDrawSelColorItem, SelColor, &HMI_data.AlertTxt_Color);
+    EDIT_ITEM(0, "Percent Text", onDrawSelColorItem, SelColor, &HMI_data.PercentTxt_Color);
+    EDIT_ITEM(0, "Bar Fill", onDrawSelColorItem, SelColor, &HMI_data.Barfill_Color);
+    EDIT_ITEM(0, "Indicator value", onDrawSelColorItem, SelColor, &HMI_data.Indicator_Color);
+    EDIT_ITEM(0, "Coordinate value", onDrawSelColorItem, SelColor, &HMI_data.Coordinate_Color);
+  }
+  CurrentMenu->draw();
+}
+
+void Draw_GetColor_Menu() {
+  checkkey = Menu;
+  if (!GetColorMenu) GetColorMenu = new MenuClass();
+  if (CurrentMenu != GetColorMenu) {
+    CurrentMenu = GetColorMenu;
+    SetMenuTitle({0}, GET_TEXT_F(MSG_COLORS_GET)); // TODO: Chinese, English "Get Color" JPG
+    DWINUI::MenuItemsPrepare(5);
+    MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, DWIN_ApplyColor);
+    MENU_ITEM(ICON_Cancel, GET_TEXT_F(MSG_BUTTON_CANCEL), onDrawMenuItem, Draw_SelectColors_Menu);
+    MENU_ITEM(0, GET_TEXT_F(MSG_COLORS_RED), onDrawGetColorItem, SetRGBColor);
+    MENU_ITEM(1, GET_TEXT_F(MSG_COLORS_GREEN), onDrawGetColorItem, SetRGBColor);
+    MENU_ITEM(2, GET_TEXT_F(MSG_COLORS_BLUE), onDrawGetColorItem, SetRGBColor);
+  }
+  CurrentMenu->draw();
+  DWIN_Draw_Rectangle(1, *HMI_value.P_Int, 20, 315, DWIN_WIDTH - 20, 335);
+}
+
+#if BOTH(CASE_LIGHT_MENU, CASELIGHT_USES_BRIGHTNESS)
+    void Draw_CaseLight_Menu() {
+      checkkey = Menu;
+      if (!CaseLightMenu) CaseLightMenu = new MenuClass();
+      if (CurrentMenu != CaseLightMenu) {
+        CurrentMenu = CaseLightMenu;
+        SetMenuTitle({0}, GET_TEXT_F(MSG_CASE_LIGHT)); // TODO: Chinese, English "Case Light" JPG
+        DWINUI::MenuItemsPrepare(3);
+        MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_Control_Menu);
+        MENU_ITEM(ICON_CaseLight, GET_TEXT_F(MSG_CASE_LIGHT), onDrawCaseLight, SetCaseLight);
+        EDIT_ITEM(ICON_Brightness, GET_TEXT_F(MSG_CASE_LIGHT_BRIGHTNESS), onDrawPInt8Menu, SetCaseLightBrightness, &caselight.brightness);
+      }
+      CurrentMenu->draw();
+    }
+#endif
+
+#if ENABLED(LED_CONTROL_MENU)
+    void Draw_LedControl_Menu() {
+      checkkey = Menu;
+      if (!LedControlMenu) LedControlMenu = new MenuClass();
+      if (CurrentMenu != LedControlMenu) {
+        CurrentMenu = LedControlMenu;
+        SetMenuTitle({0}, GET_TEXT_F(MSG_LED_CONTROL)); // TODO: Chinese, English "LED Control" JPG
+        DWINUI::MenuItemsPrepare(6);
+        MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_Control_Menu);
+        #if !BOTH(CASE_LIGHT_MENU, CASE_LIGHT_USE_NEOPIXEL)
+          MENU_ITEM(ICON_LedControl, GET_TEXT_F(MSG_LEDS), onDrawLedStatus, SetLedStatus);
+        #endif
+        #if (HAS_COLOR_LEDS)
+          EDIT_ITEM(ICON_LedControl, GET_TEXT_F(MSG_COLORS_RED), onDrawPInt8Menu, SetLedColorR, &leds.color.r);
+          EDIT_ITEM(ICON_LedControl, GET_TEXT_F(MSG_COLORS_GREEN), onDrawPInt8Menu, SetLedColorG, &leds.color.g);
+          EDIT_ITEM(ICON_LedControl, GET_TEXT_F(MSG_COLORS_BLUE), onDrawPInt8Menu, SetLedColorB, &leds.color.b);
+          #if ENABLED(HAS_WHITE_LED)
+            EDIT_ITEM(ICON_LedControl, GET_TEXT_F(MSG_COLORS_WHITE), onDrawPInt8Menu, SetLedColorW, &leds.color.w);
+          #endif
+        #endif
+      }
+      CurrentMenu->draw();
+    }
+#endif
+
+void Draw_Tune_Menu() {
+  checkkey = Menu;
+  if (!TuneMenu) TuneMenu = new MenuClass();
+  if (CurrentMenu != TuneMenu) {
+    CurrentMenu = TuneMenu;
+    SetMenuTitle({73, 2, 28, 12}, GET_TEXT_F(MSG_TUNE)); // TODO: Chinese, English "Tune" JPG
+    DWINUI::MenuItemsPrepare(14);
+    MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Goto_PrintProcess);
+    #if ENABLED(CASE_LIGHT_MENU)
+      MENU_ITEM(ICON_CaseLight, GET_TEXT_F(MSG_CASE_LIGHT), onDrawCaseLight, SetCaseLight);
+    #elif ENABLED(LED_CONTROL_MENU) && DISABLED(CASE_LIGHT_USE_NEOPIXEL)
+      MENU_ITEM(ICON_LedControl, GET_TEXT_F(MSG_LEDS), onDrawLedStatus, SetLedStatus);
+    #endif
+    EDIT_ITEM(ICON_Speed, GET_TEXT_F(MSG_SPEED), onDrawSpeedItem, SetSpeed, &feedrate_percentage);
+    #if HAS_HOTEND
+      HotendTargetItem = EDIT_ITEM(ICON_HotendTemp, GET_TEXT_F(MSG_UBL_SET_TEMP_HOTEND), onDrawHotendTemp, SetHotendTemp, &thermalManager.temp_hotend[0].target);
+    #endif
+    #if HAS_HEATED_BED
+      BedTargetItem = EDIT_ITEM(ICON_BedTemp, GET_TEXT_F(MSG_UBL_SET_TEMP_BED), onDrawBedTemp, SetBedTemp, &thermalManager.temp_bed.target);
+    #endif
+    #if HAS_FAN
+      FanSpeedItem = EDIT_ITEM(ICON_FanSpeed, GET_TEXT_F(MSG_FAN_SPEED), onDrawFanSpeed, SetFanSpeed, &thermalManager.fan_speed[0]);
+    #endif
+    #if HAS_ZOFFSET_ITEM && EITHER(HAS_BED_PROBE, BABYSTEPPING)
+      EDIT_ITEM(ICON_Zoffset, GET_TEXT_F(MSG_ZPROBE_ZOFFSET), onDrawZOffset, SetZOffset, &BABY_Z_VAR);
+    #endif
+    #if ENABLED(FWRETRACT)
+      EDIT_ITEM(ICON_FWRetLength, GET_TEXT_F(MSG_CONTROL_RETRACT), onDrawPFloatMenu, SetRetractLength, &fwretract.settings.retract_length);
+      EDIT_ITEM(ICON_FWRetSpeed, GET_TEXT_F(MSG_SINGLENOZZLE_RETRACT_SPEED), onDrawPFloatMenu, SetRetractSpeed, &fwretract.settings.retract_feedrate_mm_s);
+      EDIT_ITEM(ICON_FWRetZRaise, GET_TEXT_F(MSG_CONTROL_RETRACT_ZHOP), onDrawPFloat2Menu, SetZRaise, &fwretract.settings.retract_zraise);
+      EDIT_ITEM(ICON_FWRecSpeed, GET_TEXT_F(MSG_SINGLENOZZLE_UNRETRACT_SPEED), onDrawPFloatMenu, SetRecoverSpeed, &fwretract.settings.retract_recover_feedrate_mm_s);
+    #endif
+    EDIT_ITEM(ICON_Flow, GET_TEXT_F(MSG_FLOW), onDrawPIntMenu, SetFlow, &planner.flow_percentage[0]);
+    #if ENABLED(ADVANCED_PAUSE_FEATURE)
+      MENU_ITEM(ICON_FilMan, GET_TEXT_F(MSG_FILAMENTCHANGE), onDrawMenuItem, ChangeFilament);
+    #endif
+    MENU_ITEM(ICON_Lock, GET_TEXT_F(MSG_LOCKSCREEN), onDrawMenuItem, DWIN_LockScreen);
+    #if HAS_LCD_BRIGHTNESS
+      EDIT_ITEM(ICON_Brightness, GET_TEXT_F(MSG_BRIGHTNESS), onDrawPInt8Menu, SetBrightness, &ui.brightness);
+    #endif
+  }
+  CurrentMenu->draw();
+}
+
+void Draw_Motion_Menu() {
+  checkkey = Menu;
+  if (!MotionMenu) MotionMenu = new MenuClass();
+  if (CurrentMenu != MotionMenu) {
+    CurrentMenu = MotionMenu;
+    SetMenuTitle({1, 16, 28, 13}, GET_TEXT_F(MSG_MOTION)); // TODO: Chinese, English "Motion" JPG
+    DWINUI::MenuItemsPrepare(6);
+    MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_Control_Menu);
+    MENU_ITEM(ICON_MaxSpeed, GET_TEXT_F(MSG_SPEED), onDrawSpeed, Draw_MaxSpeed_Menu);
+    MENU_ITEM(ICON_MaxAccelerated, GET_TEXT_F(MSG_ACCELERATION), onDrawAcc, Draw_MaxAccel_Menu);
+    #if HAS_CLASSIC_JERK
+      MENU_ITEM(ICON_MaxJerk, GET_TEXT_F(MSG_JERK), onDrawJerk, Draw_MaxJerk_Menu);
+    #endif
+    MENU_ITEM(ICON_Step, GET_TEXT_F(MSG_STEPS_PER_MM), onDrawSteps, Draw_Steps_Menu);
+    EDIT_ITEM(ICON_Flow, GET_TEXT_F(MSG_FLOW), onDrawPIntMenu, SetFlow, &planner.flow_percentage[0]);
+  }
+  CurrentMenu->draw();
+}
+
+#if ENABLED(ADVANCED_PAUSE_FEATURE)
+  void Draw_FilamentMan_Menu() {
+    checkkey = Menu;
+    if (!FilamentMenu) FilamentMenu = new MenuClass();
+    if (CurrentMenu != FilamentMenu) {
+      CurrentMenu = FilamentMenu;
+      SetMenuTitle({0}, GET_TEXT_F(MSG_FILAMENT_MAN)); // TODO: Chinese, English "Filament Management" JPG
+      DWINUI::MenuItemsPrepare(5);
+      MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_Prepare_Menu);
+      MENU_ITEM(ICON_Park, GET_TEXT_F(MSG_FILAMENT_PARK_ENABLED), onDrawMenuItem, ParkHead);
+      MENU_ITEM(ICON_FilMan, GET_TEXT_F(MSG_FILAMENTCHANGE), onDrawMenuItem, ChangeFilament);
+      #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
+        MENU_ITEM(ICON_FilUnload, GET_TEXT_F(MSG_FILAMENTUNLOAD), onDrawMenuItem, UnloadFilament);
+        MENU_ITEM(ICON_FilLoad, GET_TEXT_F(MSG_FILAMENTLOAD), onDrawMenuItem, LoadFilament);
+      #endif
+    }
+    CurrentMenu->draw();
+  }
+#endif
+
+#if ENABLED(MESH_BED_LEVELING)
+  void Draw_ManualMesh_Menu() {
+    checkkey = Menu;
+    if (!ManualMesh) ManualMesh = new MenuClass();
+    if (CurrentMenu != ManualMesh) {
+      CurrentMenu = ManualMesh;
+      SetMenuTitle({0}, GET_TEXT_F(MSG_MANUAL_MESH)); // TODO: Chinese, English "Manual Mesh Leveling" JPG
+      DWINUI::MenuItemsPrepare(6);
+      MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_Prepare_Menu);
+      MENU_ITEM(ICON_ManualMesh, GET_TEXT_F(MSG_LEVEL_BED), onDrawMenuItem, ManualMeshStart);
+      MMeshMoveZItem = EDIT_ITEM(ICON_Zoffset, GET_TEXT_F(MSG_MOVE_Z), onDrawMMeshMoveZ, SetMMeshMoveZ, &current_position.z);
+      MENU_ITEM(ICON_Axis, GET_TEXT_F(MSG_UBL_CONTINUE_MESH), onDrawMenuItem, ManualMeshContinue);
+      MENU_ITEM(ICON_MeshViewer, GET_TEXT_F(MSG_MESH_VIEW), onDrawSubMenu, DWIN_MeshViewer);
+      MENU_ITEM(ICON_MeshSave, GET_TEXT_F(MSG_UBL_SAVE_MESH), onDrawMenuItem, ManualMeshSave);
+    }
+    CurrentMenu->draw();
+  }
+#endif
+
+#if HAS_PREHEAT
+
+  void Draw_Preheat_Menu(frame_rect_t cn, const __FlashStringHelper* fstr) {
+    checkkey = Menu;
+    if (CurrentMenu != PreheatMenu) {
+      CurrentMenu = PreheatMenu;
+      SetMenuTitle(cn, fstr);
+      DWINUI::MenuItemsPrepare(5);
+      MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_Temperature_Menu);
+      #if HAS_HOTEND
+        EDIT_ITEM(ICON_SetEndTemp, GET_TEXT_F(MSG_UBL_SET_TEMP_HOTEND), onDrawSetPreheatHotend, SetPreheatEndTemp, &ui.material_preset[HMI_value.Preheat].hotend_temp);
+      #endif
+      #if HAS_HEATED_BED
+        EDIT_ITEM(ICON_SetBedTemp, GET_TEXT_F(MSG_UBL_SET_TEMP_BED), onDrawSetPreheatBed, SetPreheatBedTemp, &ui.material_preset[HMI_value.Preheat].bed_temp);
+      #endif
+      #if HAS_FAN
+        EDIT_ITEM(ICON_FanSpeed, GET_TEXT_F(MSG_FAN_SPEED), onDrawSetPreheatFan, SetPreheatFanSpeed, &ui.material_preset[HMI_value.Preheat].fan_speed);
+      #endif
+      #if ENABLED(EEPROM_SETTINGS)
+        MENU_ITEM(ICON_WriteEEPROM, GET_TEXT_F(MSG_STORE_EEPROM), onDrawWriteEeprom, WriteEeprom);
+      #endif
+    }
+    CurrentMenu->draw();
+  }
+
+  void Draw_Preheat1_Menu() {
+    HMI_value.Preheat = 0;
+    if (!PreheatMenu) PreheatMenu = new MenuClass();
+    Draw_Preheat_Menu({59, 16, 81, 14}, F(PREHEAT_1_LABEL " Preheat Settings")); // TODO: English "PLA Settings" JPG
+  }
+
+  void Draw_Preheat2_Menu() {
+    HMI_value.Preheat = 1;
+    if (!PreheatMenu) PreheatMenu = new MenuClass();
+    Draw_Preheat_Menu({142, 16, 82, 14}, F(PREHEAT_2_LABEL " Preheat Settings"));  // TODO: English "ABS Settings" JPG
+  }
+
+  #ifdef PREHEAT_3_LABEL
+    void Draw_Preheat3_Menu() {
+      HMI_value.Preheat = 2;
+      if (!PreheatMenu) PreheatMenu = new MenuClass();
+      #define PREHEAT_3_TITLE PREHEAT_3_LABEL " Preheat Set."
+      Draw_Preheat_Menu({0}, F(PREHEAT_3_TITLE));  // TODO: Chinese, English "Custom Preheat Settings" JPG
+    }
+  #endif
+
+#endif // HAS_PREHEAT
+
+void Draw_Temperature_Menu() {
+  checkkey = Menu;
+  if (!TemperatureMenu) TemperatureMenu = new MenuClass();
+  if (CurrentMenu != TemperatureMenu) {
+    CurrentMenu = TemperatureMenu;
+    SetMenuTitle({236, 2, 28, 12}, GET_TEXT_F(MSG_TEMPERATURE));
+    DWINUI::MenuItemsPrepare(7);
+    MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_Control_Menu);
+    #if HAS_HOTEND
+      HotendTargetItem = EDIT_ITEM(ICON_SetEndTemp, GET_TEXT_F(MSG_UBL_SET_TEMP_HOTEND), onDrawHotendTemp, SetHotendTemp, &thermalManager.temp_hotend[0].target);
+    #endif
+    #if HAS_HEATED_BED
+      BedTargetItem = EDIT_ITEM(ICON_SetBedTemp, GET_TEXT_F(MSG_UBL_SET_TEMP_BED), onDrawBedTemp, SetBedTemp, &thermalManager.temp_bed.target);
+    #endif
+    #if HAS_FAN
+      FanSpeedItem = EDIT_ITEM(ICON_FanSpeed, GET_TEXT_F(MSG_FAN_SPEED), onDrawFanSpeed, SetFanSpeed, &thermalManager.fan_speed[0]);
+    #endif
+    #if HAS_HOTEND
+      MENU_ITEM(ICON_SetPLAPreheat, F(PREHEAT_1_LABEL " Preheat Settings"), onDrawPLAPreheatSubMenu, Draw_Preheat1_Menu);
+      MENU_ITEM(ICON_SetABSPreheat, F(PREHEAT_2_LABEL " Preheat Settings"), onDrawABSPreheatSubMenu, Draw_Preheat2_Menu);
+      #ifdef PREHEAT_3_LABEL
+        MENU_ITEM(ICON_SetCustomPreheat, PREHEAT_3_TITLE, onDrawSubMenu, Draw_Preheat3_Menu);
+      #endif
+    #endif
+  }
+  CurrentMenu->draw();
+}
+
+void Draw_MaxSpeed_Menu() {
+  checkkey = Menu;
+  if (!MaxSpeedMenu) MaxSpeedMenu = new MenuClass();
+  if (CurrentMenu != MaxSpeedMenu) {
+    CurrentMenu = MaxSpeedMenu;
+    SetMenuTitle({1, 16, 28, 13}, GET_TEXT_F(MSG_MAXSPEED));
+    DWINUI::MenuItemsPrepare(5);
+    MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_Motion_Menu);
+    EDIT_ITEM(ICON_MaxSpeedX, GET_TEXT_F(MSG_MAXSPEED_X), onDrawMaxSpeedX, SetMaxSpeedX, &planner.settings.max_feedrate_mm_s[X_AXIS]);
+    EDIT_ITEM(ICON_MaxSpeedY, GET_TEXT_F(MSG_MAXSPEED_Y), onDrawMaxSpeedY, SetMaxSpeedY, &planner.settings.max_feedrate_mm_s[Y_AXIS]);
+    EDIT_ITEM(ICON_MaxSpeedZ, GET_TEXT_F(MSG_MAXSPEED_Z), onDrawMaxSpeedZ, SetMaxSpeedZ, &planner.settings.max_feedrate_mm_s[Z_AXIS]);
+    #if HAS_HOTEND
+      EDIT_ITEM(ICON_MaxSpeedE, GET_TEXT_F(MSG_MAXSPEED_E), onDrawMaxSpeedE, SetMaxSpeedE, &planner.settings.max_feedrate_mm_s[E_AXIS]);
+    #endif
+  }
+  CurrentMenu->draw();
+}
+
+void Draw_MaxAccel_Menu() {
+  checkkey = Menu;
+  if (!MaxAccelMenu) MaxAccelMenu = new MenuClass();
+  if (CurrentMenu != MaxAccelMenu) {
+    CurrentMenu = MaxAccelMenu;
+    SetMenuTitle({1, 16, 28, 13}, GET_TEXT_F(MSG_ACCELERATION));
+    DWINUI::MenuItemsPrepare(5);
+    MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_Motion_Menu);
+    EDIT_ITEM(ICON_MaxAccX, GET_TEXT_F(MSG_AMAX_A), onDrawMaxAccelX, SetMaxAccelX, &planner.settings.max_acceleration_mm_per_s2[X_AXIS]);
+    EDIT_ITEM(ICON_MaxAccY, GET_TEXT_F(MSG_AMAX_B), onDrawMaxAccelY, SetMaxAccelY, &planner.settings.max_acceleration_mm_per_s2[Y_AXIS]);
+    EDIT_ITEM(ICON_MaxAccZ, GET_TEXT_F(MSG_AMAX_C), onDrawMaxAccelZ, SetMaxAccelZ, &planner.settings.max_acceleration_mm_per_s2[Z_AXIS]);
+    #if HAS_HOTEND
+      EDIT_ITEM(ICON_MaxAccE, GET_TEXT_F(MSG_AMAX_E), onDrawMaxAccelE, SetMaxAccelE, &planner.settings.max_acceleration_mm_per_s2[E_AXIS]);
+    #endif
+  }
+  CurrentMenu->draw();
+}
+
+#if HAS_CLASSIC_JERK
+  void Draw_MaxJerk_Menu() {
+    checkkey = Menu;
+    if (!MaxJerkMenu) MaxJerkMenu = new MenuClass();
+    if (CurrentMenu != MaxJerkMenu) {
+      CurrentMenu = MaxJerkMenu;
+      SetMenuTitle({1, 16, 28, 13}, GET_TEXT_F(MSG_JERK));
+      DWINUI::MenuItemsPrepare(5);
+      MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_Motion_Menu);
+      EDIT_ITEM(ICON_MaxSpeedJerkX, GET_TEXT_F(MSG_VA_JERK), onDrawMaxJerkX, SetMaxJerkX, &planner.max_jerk[X_AXIS]);
+      EDIT_ITEM(ICON_MaxSpeedJerkY, GET_TEXT_F(MSG_VB_JERK), onDrawMaxJerkY, SetMaxJerkY, &planner.max_jerk[Y_AXIS]);
+      EDIT_ITEM(ICON_MaxSpeedJerkZ, GET_TEXT_F(MSG_VC_JERK), onDrawMaxJerkZ, SetMaxJerkZ, &planner.max_jerk[Z_AXIS]);
+      #if HAS_HOTEND
+        EDIT_ITEM(ICON_MaxSpeedJerkE, GET_TEXT_F(MSG_VE_JERK), onDrawMaxJerkE, SetMaxJerkE, &planner.max_jerk[E_AXIS]);
+      #endif
+    }
+    CurrentMenu->draw();
+  }
+#endif
+
+void Draw_Steps_Menu() {
+  checkkey = Menu;
+  if (!StepsMenu) StepsMenu = new MenuClass();
+  if (CurrentMenu != StepsMenu) {
+    CurrentMenu = StepsMenu;
+    SetMenuTitle({1, 16, 28, 13}, GET_TEXT_F(MSG_STEPS_PER_MM));
+    DWINUI::MenuItemsPrepare(5);
+    MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawBack, Draw_Motion_Menu);
+    EDIT_ITEM(ICON_StepX, GET_TEXT_F(MSG_A_STEPS), onDrawStepsX, SetStepsX, &planner.settings.axis_steps_per_mm[X_AXIS]);
+    EDIT_ITEM(ICON_StepY, GET_TEXT_F(MSG_B_STEPS), onDrawStepsY, SetStepsY, &planner.settings.axis_steps_per_mm[Y_AXIS]);
+    EDIT_ITEM(ICON_StepZ, GET_TEXT_F(MSG_C_STEPS), onDrawStepsZ, SetStepsZ, &planner.settings.axis_steps_per_mm[Z_AXIS]);
+    #if HAS_HOTEND
+      EDIT_ITEM(ICON_StepE, GET_TEXT_F(MSG_E_STEPS), onDrawStepsE, SetStepsE, &planner.settings.axis_steps_per_mm[E_AXIS]);
+    #endif
+  }
+  CurrentMenu->draw();
+}
+
+#if HAS_HOTEND
+  void Draw_HotendPID_Menu() {
+    checkkey = Menu;
+    if (!HotendPIDMenu) HotendPIDMenu = new MenuClass();
+    if (CurrentMenu != HotendPIDMenu) {
+      CurrentMenu = HotendPIDMenu;
+      CurrentMenu->MenuTitle.SetCaption(F("Hotend PID Settings"));
+      DWINUI::MenuItemsPrepare(8);
+      MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawMenuItem, Draw_AdvancedSettings_Menu);
+      MENU_ITEM(ICON_PIDNozzle, F("Hotend PID"), onDrawMenuItem, HotendPID);
+      EDIT_ITEM(ICON_PIDValue, F("Set" STR_KP), onDrawPFloat2Menu, SetKp, &thermalManager.temp_hotend[0].pid.Kp);
+      EDIT_ITEM(ICON_PIDValue, F("Set" STR_KI), onDrawPIDi, SetKi, &thermalManager.temp_hotend[0].pid.Ki);
+      EDIT_ITEM(ICON_PIDValue, F("Set" STR_KD), onDrawPIDd, SetKd, &thermalManager.temp_hotend[0].pid.Kd);
+      EDIT_ITEM(ICON_Temperature, GET_TEXT_F(MSG_TEMPERATURE), onDrawPIntMenu, SetHotendPidT, &HMI_data.HotendPidT);
+      EDIT_ITEM(ICON_PIDcycles, GET_TEXT_F(MSG_PID_CYCLE), onDrawPIntMenu, SetPidCycles, &HMI_data.PidCycles);
+      #if ENABLED(EEPROM_SETTINGS)
+        MENU_ITEM(ICON_WriteEEPROM, GET_TEXT_F(MSG_STORE_EEPROM), onDrawMenuItem, WriteEeprom);
+      #endif
+    }
+    CurrentMenu->draw();
+  }
+#endif
+
+#if HAS_HEATED_BED
+  void Draw_BedPID_Menu() {
+    checkkey = Menu;
+    if (!BedPIDMenu) BedPIDMenu = new MenuClass();
+    if (CurrentMenu != BedPIDMenu) {
+      CurrentMenu = BedPIDMenu;
+      CurrentMenu->MenuTitle.SetCaption(F("Bed PID Settings"));
+      DWINUI::MenuItemsPrepare(8);
+      MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawMenuItem, Draw_AdvancedSettings_Menu);
+      MENU_ITEM(ICON_PIDNozzle, F("Bed PID"), onDrawMenuItem,BedPID);
+      EDIT_ITEM(ICON_PIDValue, F("Set" STR_KP), onDrawPFloat2Menu, SetKp, &thermalManager.temp_bed.pid.Kp);
+      EDIT_ITEM(ICON_PIDValue, F("Set" STR_KI), onDrawPIDi, SetKi, &thermalManager.temp_bed.pid.Ki);
+      EDIT_ITEM(ICON_PIDValue, F("Set" STR_KD), onDrawPIDd, SetKd, &thermalManager.temp_bed.pid.Kd);
+      EDIT_ITEM(ICON_Temperature, GET_TEXT_F(MSG_TEMPERATURE), onDrawPIntMenu, SetBedPidT, &HMI_data.BedPidT);
+      EDIT_ITEM(ICON_PIDcycles, GET_TEXT_F(MSG_PID_CYCLE), onDrawPIntMenu, SetPidCycles, &HMI_data.PidCycles);
+      #if ENABLED(EEPROM_SETTINGS)
+        MENU_ITEM(ICON_WriteEEPROM, GET_TEXT_F(MSG_STORE_EEPROM), onDrawMenuItem, WriteEeprom);
+      #endif
+    }
+    CurrentMenu->draw();
+  }
+#endif
+
+#if HAS_BED_PROBE
+  void Draw_ZOffsetWiz_Menu() {
+    checkkey = Menu;
+    if (!ZOffsetWizMenu) ZOffsetWizMenu = new MenuClass();
+    if (CurrentMenu != ZOffsetWizMenu) {
+      CurrentMenu = ZOffsetWizMenu;
+      CurrentMenu->MenuTitle.SetCaption(GET_TEXT_F(MSG_PROBE_WIZARD));
+      DWINUI::MenuItemsPrepare(4);
+      MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawMenuItem, Draw_Prepare_Menu);
+      MENU_ITEM(ICON_Homing, GET_TEXT_F(MSG_AUTO_HOME), onDrawMenuItem, AutoHome);
+      MENU_ITEM(ICON_MoveZ0, F("Move Z to Home"), onDrawMenuItem, SetMoveZto0);
+      EDIT_ITEM(ICON_Zoffset, GET_TEXT_F(MSG_ZPROBE_ZOFFSET), onDrawPFloat2Menu, SetZOffset, &BABY_Z_VAR);
+    }
+    CurrentMenu->draw();
+    if (!axis_is_trusted(Z_AXIS)) LCD_MESSAGE_F("WARNING: Z position unknown, move Z to home");
+  }
+#endif
+
+#if ENABLED(INDIVIDUAL_AXIS_HOMING_SUBMENU)
+  void Draw_Homing_Menu() {
+    checkkey = Menu;
+    if (!HomingMenu) HomingMenu = new MenuClass();
+    if (CurrentMenu != HomingMenu) {
+      CurrentMenu = HomingMenu;
+      CurrentMenu->MenuTitle.SetCaption(GET_TEXT_F(MSG_HOMING));
+      DWINUI::MenuItemsPrepare(5);
+      MENU_ITEM(ICON_Back, GET_TEXT_F(MSG_BUTTON_BACK), onDrawMenuItem, Draw_Prepare_Menu);
+      MENU_ITEM(ICON_Homing, GET_TEXT_F(MSG_AUTO_HOME), onDrawMenuItem, AutoHome);
+      MENU_ITEM(ICON_HomeX, GET_TEXT_F(MSG_AUTO_HOME_X), onDrawMenuItem, HomeX);
+      MENU_ITEM(ICON_HomeY, GET_TEXT_F(MSG_AUTO_HOME_Y), onDrawMenuItem, HomeY);
+      MENU_ITEM(ICON_HomeZ, GET_TEXT_F(MSG_AUTO_HOME_Z), onDrawMenuItem, HomeZ);
+    }
+    CurrentMenu->draw();
+  }
+#endif
+
+#endif // DWIN_CREALITY_LCD_ENHANCED
