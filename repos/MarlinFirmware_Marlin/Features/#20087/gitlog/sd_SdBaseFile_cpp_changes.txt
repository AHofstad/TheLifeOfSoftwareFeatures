commit 6c018eb7703d9c859a065631553bf2af3ad1aaca
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Mon May 20 01:01:05 2024 -0400

    üìù Update some G-code and other comments  (#27034)

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index f878118d2f..3963043ca6 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -253,7 +253,7 @@ bool SdBaseFile::exists(const char *name) {
  *
  * \return For success fgets() returns the length of the string in \a str.
  * If no data is read, fgets() returns zero for EOF or -1 if an error occurred.
- **/
+ */
 int16_t SdBaseFile::fgets(char *str, int16_t num, char *delim) {
   char ch;
   int16_t n = 0;

commit 5639237e2b174715413f9ffc6f6421db9150d9d6
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jan 29 20:38:03 2024 -0600

    üé® Misc. cleanup 29-01

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index 94c1b02e0e..f878118d2f 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -1295,7 +1295,6 @@ static void print2u(const uint8_t v) {
  * \param[in] fatDate The date field from a directory entry.
  */
 
-
 /**
  * %Print a directory date field.
  *
@@ -1312,7 +1311,6 @@ void SdBaseFile::printFatDate(const uint16_t fatDate) {
   print2u(FAT_DAY(fatDate));
 }
 
-
 /**
  * %Print a directory time field.
  *

commit 49ead19d008dd54403b37818b21e79b8ccfa4b89
Author: Vovodroid <vovodroid@users.noreply.github.com>
Date:   Fri Aug 18 02:13:10 2023 +0300

    üîß Reversible file alpha sorting (#26130)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index 7180b675d7..94c1b02e0e 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -1422,11 +1422,13 @@ int16_t SdBaseFile::read(void * const buf, uint16_t nbyte) {
  *
  * \param[out] dir The dir_t struct that will receive the data.
  *
- * \return For success readDir() returns the number of bytes read.
- * A value of zero will be returned if end of file is reached.
- * If an error occurs, readDir() returns -1.  Possible errors include
- * readDir() called before a directory has been opened, this is not
- * a directory file or an I/O error occurred.
+ * \return For success return a non-zero value (number of bytes read).
+ *         A value of zero will be returned if end of dir is reached.
+ *         If an error occurs, readDir() returns -1. Possible errors:
+ *           - readDir() called on unopened dir
+ *           - not a directory file
+ *           - bad dir entry
+ *           - I/O error
  */
 int8_t SdBaseFile::readDir(dir_t * const dir, char * const longFilename) {
   int16_t n;
@@ -1488,7 +1490,7 @@ int8_t SdBaseFile::readDir(dir_t * const dir, char * const longFilename) {
                   longFilename[idx] = utf16_ch & 0xFF;
                   longFilename[idx + 1] = (utf16_ch >> 8) & 0xFF;
                 #else
-                  // Replace all multibyte characters to '_'
+                  // Replace multibyte character with '_'
                   longFilename[n + i] = (utf16_ch > 0xFF) ? '_' : (utf16_ch & 0xFF);
                 #endif
               }

commit a5e4b4bd7d18f84c29a13430c636ecae289c352a
Author: narno2202 <130909513+narno2202@users.noreply.github.com>
Date:   Mon Aug 7 10:30:24 2023 +0200

    üö∏ FT_MOTION menu updates (#26083)

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index 46312bca82..7180b675d7 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -708,7 +708,7 @@ bool SdBaseFile::open(SdBaseFile * const dirFile, const uint8_t dname[11]
               }
               // Get LFN sequence number
               lfnSequenceNumber = pvFat->sequenceNumber & 0x1F;
-              if WITHIN(lfnSequenceNumber, 1, reqEntriesNum) {
+              if (WITHIN(lfnSequenceNumber, 1, reqEntriesNum)) {
                 // Check checksum for all other entries with the starting checksum fetched before
                 if (lfnChecksum == pvFat->checksum) {
                   // Set chunk of LFN from VFAT entry into lfnName

commit 86c811660ebf0b3fcbae2f34273d4c9d0c22abc4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:30:34 2023 -0500

    üßë‚Äçüíª Remove LOOP macros (#25917)

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index 98cbe9ba9d..46312bca82 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -209,7 +209,7 @@ bool SdBaseFile::dirEntry(dir_t *dir) {
  */
 void SdBaseFile::dirName(const dir_t &dir, char *name) {
   uint8_t j = 0;
-  LOOP_L_N(i, 11) {
+  for (uint8_t i = 0; i < 11; ++i) {
     if (dir.name[i] == ' ')continue;
     if (i == 8) name[j++] = '.';
     name[j++] = dir.name[i];
@@ -350,10 +350,10 @@ int8_t SdBaseFile::lsPrintNext(const uint8_t flags, const uint8_t indent) {
         && DIR_IS_FILE_OR_SUBDIR(&dir)) break;
   }
   // indent for dir level
-  LOOP_L_N(i, indent) SERIAL_CHAR(' ');
+  for (uint8_t i = 0; i < indent; ++i) SERIAL_CHAR(' ');
 
   // print name
-  LOOP_L_N(i, 11) {
+  for (uint8_t i = 0; i < 11; ++i) {
     if (dir.name[i] == ' ')continue;
     if (i == 8) {
       SERIAL_CHAR('.');
@@ -504,7 +504,7 @@ bool SdBaseFile::mkdir(SdBaseFile * const parent, const uint8_t dname[11]
   dir_t d;
   memcpy(&d, p, sizeof(d));
   d.name[0] = '.';
-  LOOP_S_L_N(i, 1, 11) d.name[i] = ' ';
+  for (uint8_t i = 1; i < 11; ++i) d.name[i] = ' ';
 
   // cache block for '.'  and '..'
   uint32_t block = vol_->clusterStartBlock(firstCluster_);
@@ -771,7 +771,7 @@ bool SdBaseFile::open(SdBaseFile * const dirFile, const uint8_t dname[11]
       if (!dirFile->seekSet(32 * index)) return false;
 
       // Dir entries write loop: [LFN] + SFN(1)
-      LOOP_L_N(dirWriteIdx, reqEntriesNum) {
+      for (uint8_t dirWriteIdx = 0; dirWriteIdx < reqEntriesNum; ++dirWriteIdx) {
         index = (dirFile->curPosition_ / 32) & 0xF;
         p = dirFile->readDirCache();
         // LFN or SFN Entry?
@@ -1137,7 +1137,7 @@ bool SdBaseFile::openNext(SdBaseFile *dirFile, const uint8_t oflag) {
    */
   void SdBaseFile::getLFNName(vfat_t *pFatDir, char *lname, const uint8_t sequenceNumber) {
     const uint8_t startOffset = (sequenceNumber - 1) * FILENAME_LENGTH;
-    LOOP_L_N(i, FILENAME_LENGTH) {
+    for (uint8_t i = 0; i < FILENAME_LENGTH; ++i) {
       const uint16_t utf16_ch = (i >= 11) ? pFatDir->name3[i - 11] : (i >= 5) ? pFatDir->name2[i - 5] : pFatDir->name1[i];
       #if ENABLED(UTF_FILENAME_SUPPORT)
         // We can't reconvert to UTF-8 here as UTF-8 is variable-size encoding, but joining LFN blocks
@@ -1158,7 +1158,7 @@ bool SdBaseFile::openNext(SdBaseFile *dirFile, const uint8_t oflag) {
   void SdBaseFile::setLFNName(vfat_t *pFatDir, char *lname, const uint8_t sequenceNumber) {
     const uint8_t startOffset = (sequenceNumber - 1) * FILENAME_LENGTH,
                   nameLength = strlen(lname);
-    LOOP_L_N(i, FILENAME_LENGTH) {
+    for (uint8_t i = 0; i < FILENAME_LENGTH; ++i) {
       uint16_t ch = 0;
       if ((startOffset + i) < nameLength)
         ch = lname[startOffset + i];
@@ -1479,7 +1479,7 @@ int8_t SdBaseFile::readDir(dir_t * const dir, char * const longFilename) {
 
               n = (seq - 1) * (FILENAME_LENGTH);
 
-              LOOP_L_N(i, FILENAME_LENGTH) {
+              for (uint8_t i = 0; i < FILENAME_LENGTH; ++i) {
                 const uint16_t utf16_ch = (i >= 11) ? VFAT->name3[i - 11] : (i >= 5) ? VFAT->name2[i - 5] : VFAT->name1[i];
                 #if ENABLED(UTF_FILENAME_SUPPORT)
                   // We can't reconvert to UTF-8 here as UTF-8 is variable-size encoding, but joining LFN blocks
@@ -1627,7 +1627,7 @@ bool SdBaseFile::remove() {
     // Check if the entry has a LFN
     bool lastEntry = false;
     // loop back to search for any LFN entries related to this file
-    LOOP_S_LE_N(sequenceNumber, 1, VFAT_ENTRIES_LIMIT) {
+    for (uint8_t sequenceNumber = 1; sequenceNumber <= VFAT_ENTRIES_LIMIT; ++sequenceNumber) {
       dirIndex_ = (dirIndex_ - 1) & 0xF;
       if (dirBlock_ == 0) break;
       if (dirIndex_ == 0xF) dirBlock_--;

commit 1a4e208c6901cf3727940e98f12748aa14a52f5d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed May 24 21:22:54 2023 -0500

    ü©π Fix card.ls call (in easythreed_ui)
    
    Fix regression in #24679

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index cf403d4b3a..98cbe9ba9d 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -322,12 +322,12 @@ void SdBaseFile::getpos(filepos_t * const pos) {
  * \param[in] indent Amount of space before file name. Used for recursive
  * list to indicate subdirectory level.
  */
-void SdBaseFile::ls(uint8_t flags, uint8_t indent) {
+void SdBaseFile::ls(const uint8_t flags/*=0*/, const uint8_t indent/*=0*/) {
   rewind();
   int8_t status;
   while ((status = lsPrintNext(flags, indent))) {
     if (status > 1 && (flags & LS_R)) {
-      uint16_t index = curPosition() / 32 - 1;
+      const uint16_t index = curPosition() / 32 - 1;
       SdBaseFile s;
       if (s.open(this, index, O_READ)) s.ls(flags, indent + 2);
       seekSet(32 * (index + 1));

commit 5664c02d077e028f84a24efd96c2eebe97ce8763
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 22 22:43:09 2023 -0500

    üßë‚Äçüíª Generalize SDSUPPORT as HAS_MEDIA
    
    In preparation for single- and multi-volume refactoring.

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index 5ee0db2b9e..cf403d4b3a 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -35,7 +35,7 @@
 
 #include "../inc/MarlinConfig.h"
 
-#if ENABLED(SDSUPPORT)
+#if HAS_MEDIA
 
 #include "SdBaseFile.h"
 
@@ -2269,4 +2269,4 @@ int16_t SdBaseFile::write(const void *buf, const uint16_t nbyte) {
   return -1;
 }
 
-#endif // SDSUPPORT
+#endif // HAS_MEDIA

commit 158c4de4f6d5a91379226f00e6e9e0e7c153d22f
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Tue Apr 18 10:40:13 2023 +0200

    ü©π Bail on 'mc.zip' write error (#25695)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index 4f4a8e9fa9..5ee0db2b9e 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -2169,7 +2169,7 @@ bool SdBaseFile::truncate(uint32_t length) {
  * include write() is called before a file has been opened, write is called
  * for a read-only file, device is full, a corrupt file system or an I/O error.
  */
-int16_t SdBaseFile::write(const void *buf, uint16_t nbyte) {
+int16_t SdBaseFile::write(const void *buf, const uint16_t nbyte) {
   #if ENABLED(SDCARD_READONLY)
     writeError = true; return -1;
   #endif

commit 27b828891db155f8b372e4efb9891bdc91bf6d33
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Apr 7 01:33:03 2023 -0500

    üé® Apply const (#25643)

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index 818f0dcb37..4f4a8e9fa9 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -91,7 +91,7 @@ bool SdBaseFile::addDirCluster() {
 // cache a file's directory entry
 // cache the current "dirBlock_" and return the entry at index "dirIndex_"
 // return pointer to cached entry or null for failure
-dir_t* SdBaseFile::cacheDirEntry(uint8_t action) {
+dir_t* SdBaseFile::cacheDirEntry(const uint8_t action) {
   if (!vol_->cacheRawBlock(dirBlock_, action)) return nullptr;
   return vol_->cache()->dir + dirIndex_;
 }
@@ -119,7 +119,7 @@ bool SdBaseFile::close() {
  * Reasons for failure include file is not contiguous, file has zero length
  * or an I/O error occurred.
  */
-bool SdBaseFile::contiguousRange(uint32_t *bgnBlock, uint32_t *endBlock) {
+bool SdBaseFile::contiguousRange(uint32_t * const bgnBlock, uint32_t * const endBlock) {
   // error if no blocks
   if (firstCluster_ == 0) return false;
 
@@ -156,7 +156,7 @@ bool SdBaseFile::contiguousRange(uint32_t *bgnBlock, uint32_t *endBlock) {
  * a file is already open, the file already exists, the root
  * directory is full or an I/O error.
  */
-bool SdBaseFile::createContiguous(SdBaseFile *dirFile, const char *path, uint32_t size) {
+bool SdBaseFile::createContiguous(SdBaseFile * const dirFile, const char * const path, const uint32_t size) {
   if (ENABLED(SDCARD_READONLY)) return false;
 
   uint32_t count;
@@ -301,7 +301,7 @@ bool SdBaseFile::getDosName(char * const name) {
   return true;
 }
 
-void SdBaseFile::getpos(filepos_t *pos) {
+void SdBaseFile::getpos(filepos_t * const pos) {
   pos->position = curPosition_;
   pos->cluster = curCluster_;
 }
@@ -337,7 +337,7 @@ void SdBaseFile::ls(uint8_t flags, uint8_t indent) {
 
 // saves 32 bytes on stack for ls recursion
 // return 0 - EOF, 1 - normal file, or 2 - directory
-int8_t SdBaseFile::lsPrintNext(uint8_t flags, uint8_t indent) {
+int8_t SdBaseFile::lsPrintNext(const uint8_t flags, const uint8_t indent) {
   dir_t dir;
   uint8_t w = 0;
 
@@ -400,7 +400,7 @@ uint8_t lfn_checksum(const uint8_t *name) {
 }
 
 // Format directory name field from a 8.3 name string
-bool SdBaseFile::make83Name(const char *str, uint8_t *name, const char **ptr) {
+bool SdBaseFile::make83Name(const char *str, uint8_t * const name, const char **ptr) {
   uint8_t n = 7,                      // Max index until a dot is found
           i = 11;
   while (i) name[--i] = ' ';          // Set whole FILENAME.EXT to spaces
@@ -437,13 +437,11 @@ bool SdBaseFile::make83Name(const char *str, uint8_t *name, const char **ptr) {
  * Reasons for failure include this file is already open, \a parent is not a
  * directory, \a path is invalid or already exists in \a parent.
  */
-bool SdBaseFile::mkdir(SdBaseFile *parent, const char *path, bool pFlag) {
+bool SdBaseFile::mkdir(SdBaseFile *parent, const char *path, const bool pFlag/*=true*/) {
   if (ENABLED(SDCARD_READONLY)) return false;
 
-  uint8_t dname[11];
-  SdBaseFile dir1, dir2;
-  SdBaseFile *sub = &dir1;
-  SdBaseFile *start = parent;
+  SdBaseFile dir1, dir2, *sub = &dir1;
+  SdBaseFile * const start = parent;
 
   #if ENABLED(LONG_FILENAME_WRITE_SUPPORT)
     uint8_t dlname[LONG_FILENAME_LENGTH];
@@ -459,6 +457,7 @@ bool SdBaseFile::mkdir(SdBaseFile *parent, const char *path, bool pFlag) {
     }
   }
 
+  uint8_t dname[11];
   for (;;) {
     if (!TERN(LONG_FILENAME_WRITE_SUPPORT, parsePath(path, dname, dlname, &path), make83Name(path, dname, &path))) return false;
     while (*path == '/') path++;
@@ -474,7 +473,7 @@ bool SdBaseFile::mkdir(SdBaseFile *parent, const char *path, bool pFlag) {
   return mkdir(parent, dname OPTARG(LONG_FILENAME_WRITE_SUPPORT, dlname));
 }
 
-bool SdBaseFile::mkdir(SdBaseFile *parent, const uint8_t dname[11]
+bool SdBaseFile::mkdir(SdBaseFile * const parent, const uint8_t dname[11]
   OPTARG(LONG_FILENAME_WRITE_SUPPORT, const uint8_t dlname[LONG_FILENAME_LENGTH])
 ) {
   if (ENABLED(SDCARD_READONLY)) return false;
@@ -541,7 +540,7 @@ bool SdBaseFile::mkdir(SdBaseFile *parent, const uint8_t dname[11]
  *
  * \return true for success, false for failure.
  */
-bool SdBaseFile::open(const char *path, uint8_t oflag) {
+bool SdBaseFile::open(const char * const path, const uint8_t oflag) {
   return open(cwd_, path, oflag);
 }
 
@@ -595,7 +594,7 @@ bool SdBaseFile::open(const char *path, uint8_t oflag) {
  * a directory, \a path is invalid, the file does not exist
  * or can't be opened in the access mode specified by oflag.
  */
-bool SdBaseFile::open(SdBaseFile *dirFile, const char *path, uint8_t oflag) {
+bool SdBaseFile::open(SdBaseFile * const dirFile, const char *path, const uint8_t oflag) {
   uint8_t dname[11];
   SdBaseFile dir1, dir2;
   SdBaseFile *parent = dirFile, *sub = &dir1;
@@ -627,9 +626,9 @@ bool SdBaseFile::open(SdBaseFile *dirFile, const char *path, uint8_t oflag) {
 }
 
 // open with filename in dname and long filename in dlname
-bool SdBaseFile::open(SdBaseFile *dirFile, const uint8_t dname[11]
+bool SdBaseFile::open(SdBaseFile * const dirFile, const uint8_t dname[11]
     OPTARG(LONG_FILENAME_WRITE_SUPPORT, const uint8_t dlname[LONG_FILENAME_LENGTH])
-  , uint8_t oflag
+  , const uint8_t oflag
 ) {
   bool emptyFound = false, fileFound = false;
   uint8_t index = 0;
@@ -876,7 +875,7 @@ bool SdBaseFile::open(SdBaseFile *dirFile, const uint8_t dname[11]
  * See open() by path for definition of flags.
  * \return true for success or false for failure.
  */
-bool SdBaseFile::open(SdBaseFile *dirFile, uint16_t index, uint8_t oflag) {
+bool SdBaseFile::open(SdBaseFile *dirFile, uint16_t index, const uint8_t oflag) {
   vol_ = dirFile->vol_;
 
   // error if already open
@@ -902,7 +901,7 @@ bool SdBaseFile::open(SdBaseFile *dirFile, uint16_t index, uint8_t oflag) {
 }
 
 // open a cached directory entry. Assumes vol_ is initialized
-bool SdBaseFile::openCachedEntry(uint8_t dirIndex, uint8_t oflag) {
+bool SdBaseFile::openCachedEntry(const uint8_t dirIndex, const uint8_t oflag) {
   dir_t *p;
 
   #if ENABLED(SDCARD_READONLY)
@@ -962,7 +961,7 @@ bool SdBaseFile::openCachedEntry(uint8_t dirIndex, uint8_t oflag) {
  * See open() by path for definition of flags.
  * \return true for success or false for failure.
  */
-bool SdBaseFile::openNext(SdBaseFile *dirFile, uint8_t oflag) {
+bool SdBaseFile::openNext(SdBaseFile *dirFile, const uint8_t oflag) {
   if (!dirFile) return false;
 
   // error if already open
@@ -1017,7 +1016,7 @@ bool SdBaseFile::openNext(SdBaseFile *dirFile, uint8_t oflag) {
    * \return true if the dirname is a long file name (LFN)
    * \return false if the dirname is a short file name 8.3 (SFN)
    */
-  bool SdBaseFile::isDirNameLFN(const char *dirname) {
+  bool SdBaseFile::isDirNameLFN(const char * const dirname) {
     uint8_t length = strlen(dirname), idx = length;
     bool dotFound = false;
     if (idx > 12) return true;            // LFN due to filename length > 12 ("filename.ext")
@@ -1048,7 +1047,7 @@ bool SdBaseFile::openNext(SdBaseFile *dirFile, uint8_t oflag) {
    * The SFN is without dot ("FILENAMEEXT")
    * The LFN is complete ("Filename.ext")
    */
-  bool SdBaseFile::parsePath(const char *path, uint8_t *name, uint8_t *lname, const char **ptrNextPath) {
+  bool SdBaseFile::parsePath(const char *path, uint8_t * const name, uint8_t * const lname, const char **ptrNextPath) {
     // Init randomizer for SFN generation
     randomSeed(millis());
     // Parse the LFN
@@ -1136,7 +1135,7 @@ bool SdBaseFile::openNext(SdBaseFile *dirFile, uint8_t oflag) {
   /**
    * Get the LFN filename block from a dir. Get the block in lname at startOffset
    */
-  void SdBaseFile::getLFNName(vfat_t *pFatDir, char *lname, uint8_t sequenceNumber) {
+  void SdBaseFile::getLFNName(vfat_t *pFatDir, char *lname, const uint8_t sequenceNumber) {
     const uint8_t startOffset = (sequenceNumber - 1) * FILENAME_LENGTH;
     LOOP_L_N(i, FILENAME_LENGTH) {
       const uint16_t utf16_ch = (i >= 11) ? pFatDir->name3[i - 11] : (i >= 5) ? pFatDir->name2[i - 5] : pFatDir->name1[i];
@@ -1156,7 +1155,7 @@ bool SdBaseFile::openNext(SdBaseFile *dirFile, uint8_t oflag) {
   /**
    * Set the LFN filename block lname to a dir. Put the block based on sequence number
    */
-  void SdBaseFile::setLFNName(vfat_t *pFatDir, char *lname, uint8_t sequenceNumber) {
+  void SdBaseFile::setLFNName(vfat_t *pFatDir, char *lname, const uint8_t sequenceNumber) {
     const uint8_t startOffset = (sequenceNumber - 1) * FILENAME_LENGTH,
                   nameLength = strlen(lname);
     LOOP_L_N(i, FILENAME_LENGTH) {
@@ -1305,7 +1304,7 @@ static void print2u(const uint8_t v) {
  * \param[in] pr Print stream for output.
  * \param[in] fatDate The date field from a directory entry.
  */
-void SdBaseFile::printFatDate(uint16_t fatDate) {
+void SdBaseFile::printFatDate(const uint16_t fatDate) {
   SERIAL_ECHO(FAT_YEAR(fatDate));
   SERIAL_CHAR('-');
   print2u(FAT_MONTH(fatDate));
@@ -1322,7 +1321,7 @@ void SdBaseFile::printFatDate(uint16_t fatDate) {
  * \param[in] pr Print stream for output.
  * \param[in] fatTime The time field from a directory entry.
  */
-void SdBaseFile::printFatTime(uint16_t fatTime) {
+void SdBaseFile::printFatTime(const uint16_t fatTime) {
   print2u(FAT_HOUR(fatTime));
   SERIAL_CHAR(':');
   print2u(FAT_MINUTE(fatTime));
@@ -1367,7 +1366,7 @@ int16_t SdBaseFile::read() {
  * read() called before a file has been opened, corrupt file system
  * or an I/O error occurred.
  */
-int16_t SdBaseFile::read(void *buf, uint16_t nbyte) {
+int16_t SdBaseFile::read(void * const buf, uint16_t nbyte) {
   uint8_t *dst = reinterpret_cast<uint8_t*>(buf);
   uint16_t offset, toRead;
   uint32_t block;  // raw device block number
@@ -1429,7 +1428,7 @@ int16_t SdBaseFile::read(void *buf, uint16_t nbyte) {
  * readDir() called before a directory has been opened, this is not
  * a directory file or an I/O error occurred.
  */
-int8_t SdBaseFile::readDir(dir_t *dir, char * const longFilename) {
+int8_t SdBaseFile::readDir(dir_t * const dir, char * const longFilename) {
   int16_t n;
   // if not a directory file or miss-positioned return an error
   if (!isDir() || (0x1F & curPosition_)) return -1;
@@ -1676,7 +1675,7 @@ bool SdBaseFile::remove() {
  * \a dirFile is not a directory, \a path is not found
  * or an I/O error occurred.
  */
-bool SdBaseFile::remove(SdBaseFile *dirFile, const char *path) {
+bool SdBaseFile::remove(SdBaseFile * const dirFile, const char * const path) {
   if (ENABLED(SDCARD_READONLY)) return false;
 
   SdBaseFile file;
@@ -1715,7 +1714,7 @@ bool SdBaseFile::hide(const bool hidden) {
  * Reasons for failure include \a dirFile is not open or is not a directory
  * file, newPath is invalid or already exists, or an I/O error occurs.
  */
-bool SdBaseFile::rename(SdBaseFile *dirFile, const char *newPath) {
+bool SdBaseFile::rename(SdBaseFile * const dirFile, const char * const newPath) {
   if (ENABLED(SDCARD_READONLY)) return false;
 
   uint32_t dirCluster = 0;
@@ -1900,7 +1899,7 @@ bool SdBaseFile::rmRfStar() {
  * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive
  * OR of open flags. see SdBaseFile::open(SdBaseFile*, const char*, uint8_t).
  */
-SdBaseFile::SdBaseFile(const char *path, uint8_t oflag) {
+SdBaseFile::SdBaseFile(const char * const path, const uint8_t oflag) {
   type_ = FAT_FILE_TYPE_CLOSED;
   writeError = false;
   open(path, oflag);
@@ -1943,7 +1942,7 @@ bool SdBaseFile::seekSet(const uint32_t pos) {
   return true;
 }
 
-void SdBaseFile::setpos(filepos_t *pos) {
+void SdBaseFile::setpos(filepos_t * const pos) {
   curPosition_ = pos->position;
   curCluster_ = pos->cluster;
 }
@@ -1998,7 +1997,7 @@ bool SdBaseFile::sync() {
  *
  * \return true for success, false for failure.
  */
-bool SdBaseFile::timestamp(SdBaseFile *file) {
+bool SdBaseFile::timestamp(SdBaseFile * const file) {
   dir_t dir;
 
   // get timestamps
@@ -2055,8 +2054,8 @@ bool SdBaseFile::timestamp(SdBaseFile *file) {
  *
  * \return true for success, false for failure.
  */
-bool SdBaseFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
-                           uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
+bool SdBaseFile::timestamp(const uint8_t flags, const uint16_t year, const uint8_t month,
+                           const uint8_t day, const uint8_t hour, const uint8_t minute, const uint8_t second) {
   if (ENABLED(SDCARD_READONLY)) return false;
 
   uint16_t dirDate, dirTime;

commit 06d9a2ff8f4364c13dc12e36b91399de54136097
Author: Eduard Sukharev <sukharev.eh@gmail.com>
Date:   Sat Apr 1 05:45:53 2023 +0300

    üêõ Fix Long FIlename lookup (#25598)

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index 72cdcb9268..818f0dcb37 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -1003,7 +1003,8 @@ bool SdBaseFile::openNext(SdBaseFile *dirFile, uint8_t oflag) {
   bool SdBaseFile::isDirLFN(const dir_t* dir) {
     if (DIR_IS_LONG_NAME(dir)) {
       vfat_t *VFAT = (vfat_t*)dir;
-      // Sanity-check the VFAT entry. The first cluster is always set to zero. And the sequence number should be higher than 0
+      // Sanity-check the VFAT entry. The first cluster is always set to zero.
+      // The sequence number should be higher than 0 and lower than maximum allowed by VFAT spec
       if ((VFAT->firstClusterLow == 0) && WITHIN((VFAT->sequenceNumber & 0x1F), 1, MAX_VFAT_ENTRIES)) return true;
     }
     return false;
@@ -1463,7 +1464,7 @@ int8_t SdBaseFile::readDir(dir_t *dir, char * const longFilename) {
         // Sanity-check the VFAT entry. The first cluster is always set to zero. And the sequence number should be higher than 0
         if (VFAT->firstClusterLow == 0) {
           const uint8_t seq = VFAT->sequenceNumber & 0x1F;
-          if (WITHIN(seq, 1, MAX_VFAT_ENTRIES)) {
+          if (WITHIN(seq, 1, VFAT_ENTRIES_LIMIT)) {
             if (seq == 1) {
               checksum = VFAT->checksum;
               checksum_error = 0;
@@ -1627,7 +1628,7 @@ bool SdBaseFile::remove() {
     // Check if the entry has a LFN
     bool lastEntry = false;
     // loop back to search for any LFN entries related to this file
-    LOOP_S_LE_N(sequenceNumber, 1, MAX_VFAT_ENTRIES) {
+    LOOP_S_LE_N(sequenceNumber, 1, VFAT_ENTRIES_LIMIT) {
       dirIndex_ = (dirIndex_ - 1) & 0xF;
       if (dirBlock_ == 0) break;
       if (dirIndex_ == 0xF) dirBlock_--;

commit a3ab435acf27034e14cc1f94ab5e3de3936052cf
Author: Eduard Sukharev <sukharev.eh@gmail.com>
Date:   Mon Mar 27 21:55:56 2023 +0300

    üêõ Fix M23 long filename support (#25540)

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index b8b49b7ba0..72cdcb9268 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -703,7 +703,10 @@ bool SdBaseFile::open(SdBaseFile *dirFile, const uint8_t dname[11]
               // Get VFat dir entry
               pvFat = (vfat_t *) p;
               // Get checksum from the last entry of the sequence
-              if (pvFat->sequenceNumber & 0x40) lfnChecksum = pvFat->checksum;
+              if (pvFat->sequenceNumber & 0x40) {
+                lfnChecksum = pvFat->checksum;
+                ZERO(lfnName);
+              }
               // Get LFN sequence number
               lfnSequenceNumber = pvFat->sequenceNumber & 0x1F;
               if WITHIN(lfnSequenceNumber, 1, reqEntriesNum) {
@@ -711,6 +714,7 @@ bool SdBaseFile::open(SdBaseFile *dirFile, const uint8_t dname[11]
                 if (lfnChecksum == pvFat->checksum) {
                   // Set chunk of LFN from VFAT entry into lfnName
                   getLFNName(pvFat, (char *)lfnName, lfnSequenceNumber);
+                  TERN_(UTF_FILENAME_SUPPORT, convertUtf16ToUtf8((char *)lfnName));
                   // LFN found?
                   if (!strncasecmp((char*)dlname, (char*)lfnName, lfnNameLength)) lfnFileFound = true;
                 }
@@ -1132,13 +1136,13 @@ bool SdBaseFile::openNext(SdBaseFile *dirFile, uint8_t oflag) {
    * Get the LFN filename block from a dir. Get the block in lname at startOffset
    */
   void SdBaseFile::getLFNName(vfat_t *pFatDir, char *lname, uint8_t sequenceNumber) {
-    uint8_t startOffset = (sequenceNumber - 1) * FILENAME_LENGTH;
+    const uint8_t startOffset = (sequenceNumber - 1) * FILENAME_LENGTH;
     LOOP_L_N(i, FILENAME_LENGTH) {
       const uint16_t utf16_ch = (i >= 11) ? pFatDir->name3[i - 11] : (i >= 5) ? pFatDir->name2[i - 5] : pFatDir->name1[i];
       #if ENABLED(UTF_FILENAME_SUPPORT)
         // We can't reconvert to UTF-8 here as UTF-8 is variable-size encoding, but joining LFN blocks
         // needs static bytes addressing. So here just store full UTF-16LE words to re-convert later.
-        uint16_t idx = (startOffset + i) * 2; // This is fixed as FAT LFN always contain UTF-16LE encoding
+        const uint16_t idx = (startOffset + i) * 2; // This is fixed as FAT LFN always contain UTF-16LE encoding
         lname[idx] = utf16_ch & 0xFF;
         lname[idx + 1] = (utf16_ch >> 8) & 0xFF;
       #else
@@ -1152,8 +1156,8 @@ bool SdBaseFile::openNext(SdBaseFile *dirFile, uint8_t oflag) {
    * Set the LFN filename block lname to a dir. Put the block based on sequence number
    */
   void SdBaseFile::setLFNName(vfat_t *pFatDir, char *lname, uint8_t sequenceNumber) {
-    uint8_t startOffset = (sequenceNumber - 1) * FILENAME_LENGTH;
-    uint8_t nameLength = strlen(lname);
+    const uint8_t startOffset = (sequenceNumber - 1) * FILENAME_LENGTH,
+                  nameLength = strlen(lname);
     LOOP_L_N(i, FILENAME_LENGTH) {
       uint16_t ch = 0;
       if ((startOffset + i) < nameLength)
@@ -1424,7 +1428,7 @@ int16_t SdBaseFile::read(void *buf, uint16_t nbyte) {
  * readDir() called before a directory has been opened, this is not
  * a directory file or an I/O error occurred.
  */
-int8_t SdBaseFile::readDir(dir_t *dir, char *longFilename) {
+int8_t SdBaseFile::readDir(dir_t *dir, char * const longFilename) {
   int16_t n;
   // if not a directory file or miss-positioned return an error
   if (!isDir() || (0x1F & curPosition_)) return -1;
@@ -1506,44 +1510,55 @@ int8_t SdBaseFile::readDir(dir_t *dir, char *longFilename) {
     // Post-process normal file or subdirectory longname, if any
     if (DIR_IS_FILE_OR_SUBDIR(dir)) {
       #if ENABLED(UTF_FILENAME_SUPPORT)
-        #if LONG_FILENAME_CHARSIZE > 2
-          // Add warning for developers for unsupported 3-byte cases.
-          // (Converting 2-byte codepoints to 3-byte in-place would break the rest of filename.)
-          #error "Currently filename re-encoding is done in-place. It may break the remaining chars to use 3-byte codepoints."
-        #endif
-
         // Is there a long filename to decode?
         if (longFilename) {
-          // Reset n to the start of the long name
-          n = 0;
-          for (uint16_t idx = 0; idx < (LONG_FILENAME_LENGTH); idx += 2) {  // idx is fixed since FAT LFN always contains UTF-16LE encoding
-            const uint16_t utf16_ch = longFilename[idx] | (longFilename[idx + 1] << 8);
-            if (0xD800 == (utf16_ch & 0xF800))                              // Surrogate pair - encode as '_'
-              longFilename[n++] = '_';
-            else if (0 == (utf16_ch & 0xFF80))                              // Encode as 1-byte UTF-8 char
-              longFilename[n++] = utf16_ch & 0x007F;
-            else if (0 == (utf16_ch & 0xF800)) {                            // Encode as 2-byte UTF-8 char
-              longFilename[n++] = 0xC0 | ((utf16_ch >> 6) & 0x1F);
-              longFilename[n++] = 0x80 | ( utf16_ch       & 0x3F);
-            }
-            else {
-              #if LONG_FILENAME_CHARSIZE > 2                                // Encode as 3-byte UTF-8 char
-                longFilename[n++] = 0xE0 | ((utf16_ch >> 12) & 0x0F);
-                longFilename[n++] = 0xC0 | ((utf16_ch >>  6) & 0x3F);
-                longFilename[n++] = 0xC0 | ( utf16_ch        & 0x3F);
-              #else                                                         // Encode as '_'
-                longFilename[n++] = '_';
-              #endif
-            }
-            if (0 == utf16_ch) break; // End of filename
-          } // idx
-        } // longFilename
+          n = convertUtf16ToUtf8(longFilename);
+        }
       #endif
       return n;
     } // DIR_IS_FILE_OR_SUBDIR
   }
 }
 
+#if ENABLED(UTF_FILENAME_SUPPORT)
+
+  uint8_t SdBaseFile::convertUtf16ToUtf8(char * const longFilename) {
+    #if LONG_FILENAME_CHARSIZE > 2
+      // Add warning for developers for unsupported 3-byte cases.
+      // (Converting 2-byte codepoints to 3-byte in-place would break the rest of filename.)
+      #error "Currently filename re-encoding is done in-place. It may break the remaining chars to use 3-byte codepoints."
+    #endif
+
+    int16_t n;
+    // Reset n to the start of the long name
+    n = 0;
+    for (uint16_t idx = 0; idx < (LONG_FILENAME_LENGTH); idx += 2) {  // idx is fixed since FAT LFN always contains UTF-16LE encoding
+      const uint16_t utf16_ch = longFilename[idx] | (longFilename[idx + 1] << 8);
+      if (0xD800 == (utf16_ch & 0xF800))                              // Surrogate pair - encode as '_'
+        longFilename[n++] = '_';
+      else if (0 == (utf16_ch & 0xFF80))                              // Encode as 1-byte UTF-8 char
+        longFilename[n++] = utf16_ch & 0x007F;
+      else if (0 == (utf16_ch & 0xF800)) {                            // Encode as 2-byte UTF-8 char
+        longFilename[n++] = 0xC0 | ((utf16_ch >> 6) & 0x1F);
+        longFilename[n++] = 0x80 | ( utf16_ch       & 0x3F);
+      }
+      else {
+        #if LONG_FILENAME_CHARSIZE > 2                                // Encode as 3-byte UTF-8 char
+          longFilename[n++] = 0xE0 | ((utf16_ch >> 12) & 0x0F);
+          longFilename[n++] = 0xC0 | ((utf16_ch >>  6) & 0x3F);
+          longFilename[n++] = 0xC0 | ( utf16_ch        & 0x3F);
+        #else                                                         // Encode as '_'
+          longFilename[n++] = '_';
+        #endif
+      }
+      if (0 == utf16_ch) break; // End of filename
+    } // idx
+
+    return n;
+  }
+
+#endif // UTF_FILENAME_SUPPORT
+
 // Read next directory entry into the cache
 // Assumes file is correctly positioned
 dir_t* SdBaseFile::readDirCache() {

commit f90c49910defc4124f7ef0a75dc8a292b9ee85c7
Author: Eduard Sukharev <sukharev.eh@gmail.com>
Date:   Wed Mar 15 00:49:49 2023 +0300

    üêõ Fix long filename read/report (#25509)

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index e3f95623ac..b8b49b7ba0 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -1013,8 +1013,7 @@ bool SdBaseFile::openNext(SdBaseFile *dirFile, uint8_t oflag) {
    * \return false if the dirname is a short file name 8.3 (SFN)
    */
   bool SdBaseFile::isDirNameLFN(const char *dirname) {
-    uint8_t length = strlen(dirname);
-    uint8_t idx = length;
+    uint8_t length = strlen(dirname), idx = length;
     bool dotFound = false;
     if (idx > 12) return true;            // LFN due to filename length > 12 ("filename.ext")
     // Check dot(s) position
@@ -1508,8 +1507,8 @@ int8_t SdBaseFile::readDir(dir_t *dir, char *longFilename) {
     if (DIR_IS_FILE_OR_SUBDIR(dir)) {
       #if ENABLED(UTF_FILENAME_SUPPORT)
         #if LONG_FILENAME_CHARSIZE > 2
-          // Add warning for developers for currently not supported 3-byte cases (Conversion series of 2-byte
-          // codepoints to 3-byte in-place will break the rest of filename)
+          // Add warning for developers for unsupported 3-byte cases.
+          // (Converting 2-byte codepoints to 3-byte in-place would break the rest of filename.)
           #error "Currently filename re-encoding is done in-place. It may break the remaining chars to use 3-byte codepoints."
         #endif
 
@@ -1517,22 +1516,22 @@ int8_t SdBaseFile::readDir(dir_t *dir, char *longFilename) {
         if (longFilename) {
           // Reset n to the start of the long name
           n = 0;
-          for (uint16_t idx = 0; idx < (LONG_FILENAME_LENGTH) / 2; idx += 2) {    // idx is fixed since FAT LFN always contains UTF-16LE encoding
+          for (uint16_t idx = 0; idx < (LONG_FILENAME_LENGTH); idx += 2) {  // idx is fixed since FAT LFN always contains UTF-16LE encoding
             const uint16_t utf16_ch = longFilename[idx] | (longFilename[idx + 1] << 8);
-            if (0xD800 == (utf16_ch & 0xF800))                                    // Surrogate pair - encode as '_'
+            if (0xD800 == (utf16_ch & 0xF800))                              // Surrogate pair - encode as '_'
               longFilename[n++] = '_';
-            else if (0 == (utf16_ch & 0xFF80))                                    // Encode as 1-byte UTF-8 char
+            else if (0 == (utf16_ch & 0xFF80))                              // Encode as 1-byte UTF-8 char
               longFilename[n++] = utf16_ch & 0x007F;
-            else if (0 == (utf16_ch & 0xF800)) {                                  // Encode as 2-byte UTF-8 char
+            else if (0 == (utf16_ch & 0xF800)) {                            // Encode as 2-byte UTF-8 char
               longFilename[n++] = 0xC0 | ((utf16_ch >> 6) & 0x1F);
               longFilename[n++] = 0x80 | ( utf16_ch       & 0x3F);
             }
             else {
-              #if LONG_FILENAME_CHARSIZE > 2                                      // Encode as 3-byte UTF-8 char
+              #if LONG_FILENAME_CHARSIZE > 2                                // Encode as 3-byte UTF-8 char
                 longFilename[n++] = 0xE0 | ((utf16_ch >> 12) & 0x0F);
                 longFilename[n++] = 0xC0 | ((utf16_ch >>  6) & 0x3F);
                 longFilename[n++] = 0xC0 | ( utf16_ch        & 0x3F);
-              #else                                                               // Encode as '_'
+              #else                                                         // Encode as '_'
                 longFilename[n++] = '_';
               #endif
             }

commit 08d9cbb9306a032d706a6ded0bf576fd0c58ca8d
Author: vyacheslav-shubin <shubin-vv@krista.ru>
Date:   Sat Feb 4 10:36:07 2023 +0300

    üßë‚Äçüíª Add SD Card 'hide' method for dev usage (#22425)

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index 1c1e0c7d14..e3f95623ac 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -1668,6 +1668,28 @@ bool SdBaseFile::remove(SdBaseFile *dirFile, const char *path) {
   return file.open(dirFile, path, O_WRITE) ? file.remove() : false;
 }
 
+bool SdBaseFile::hide(const bool hidden) {
+  if (ENABLED(SDCARD_READONLY)) return false;
+  // must be an open file or subdirectory
+  if (!(isFile() || isSubDir())) return false;
+  // sync() and cache directory entry
+  sync();
+  dir_t *d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
+  if (!d) return false;
+  uint8_t a = d->attributes;
+  if (hidden)
+    a |= DIR_ATT_HIDDEN;
+  else
+    a &= ~DIR_ATT_HIDDEN;
+
+  if (a != d->attributes) {
+    d->attributes = a;
+    return vol_->cacheFlush();
+  }
+
+  return true;
+}
+
 /**
  * Rename a file or subdirectory.
  *

commit fee85b318eca9f410f1b49de22ee9e6f778a23ff
Author: GHGiampy <83699429+GHGiampy@users.noreply.github.com>
Date:   Fri Feb 18 01:45:42 2022 +0100

    ‚úèÔ∏è Fix getLFNName parameter (#23752)

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index 64d0ad68bd..1c1e0c7d14 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -1140,8 +1140,8 @@ bool SdBaseFile::openNext(SdBaseFile *dirFile, uint8_t oflag) {
         // We can't reconvert to UTF-8 here as UTF-8 is variable-size encoding, but joining LFN blocks
         // needs static bytes addressing. So here just store full UTF-16LE words to re-convert later.
         uint16_t idx = (startOffset + i) * 2; // This is fixed as FAT LFN always contain UTF-16LE encoding
-        longFilename[idx] = utf16_ch & 0xFF;
-        longFilename[idx + 1] = (utf16_ch >> 8) & 0xFF;
+        lname[idx] = utf16_ch & 0xFF;
+        lname[idx + 1] = (utf16_ch >> 8) & 0xFF;
       #else
         // Replace all multibyte characters to '_'
         lname[startOffset + i] = (utf16_ch > 0xFF) ? '_' : (utf16_ch & 0xFF);

commit 1e246d65ad160d0a33d598046374f3910d8e4084
Author: GHGiampy <83699429+GHGiampy@users.noreply.github.com>
Date:   Tue Jan 18 07:56:11 2022 +0100

    ‚ú® Long filename open/create/write (#23526)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index b357495a3e..64d0ad68bd 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -89,6 +89,7 @@ bool SdBaseFile::addDirCluster() {
 }
 
 // cache a file's directory entry
+// cache the current "dirBlock_" and return the entry at index "dirIndex_"
 // return pointer to cached entry or null for failure
 dir_t* SdBaseFile::cacheDirEntry(uint8_t action) {
   if (!vol_->cacheRawBlock(dirBlock_, action)) return nullptr;
@@ -384,6 +385,20 @@ int8_t SdBaseFile::lsPrintNext(uint8_t flags, uint8_t indent) {
   return DIR_IS_FILE(&dir) ? 1 : 2;
 }
 
+/**
+ * Calculate a checksum for an 8.3 filename
+ *
+ * \param name The 8.3 file name to calculate
+ *
+ * \return The checksum byte
+ */
+uint8_t lfn_checksum(const uint8_t *name) {
+  uint8_t sum = 0;
+  for (uint8_t i = 11; i; i--)
+    sum = ((sum & 1) << 7) + (sum >> 1) + *name++;
+  return sum;
+}
+
 // Format directory name field from a 8.3 name string
 bool SdBaseFile::make83Name(const char *str, uint8_t *name, const char **ptr) {
   uint8_t n = 7,                      // Max index until a dot is found
@@ -430,6 +445,10 @@ bool SdBaseFile::mkdir(SdBaseFile *parent, const char *path, bool pFlag) {
   SdBaseFile *sub = &dir1;
   SdBaseFile *start = parent;
 
+  #if ENABLED(LONG_FILENAME_WRITE_SUPPORT)
+    uint8_t dlname[LONG_FILENAME_LENGTH];
+  #endif
+
   if (!parent || isOpen()) return false;
 
   if (*path == '/') {
@@ -439,28 +458,31 @@ bool SdBaseFile::mkdir(SdBaseFile *parent, const char *path, bool pFlag) {
       parent = &dir2;
     }
   }
-  while (1) {
-    if (!make83Name(path, dname, &path)) return false;
+
+  for (;;) {
+    if (!TERN(LONG_FILENAME_WRITE_SUPPORT, parsePath(path, dname, dlname, &path), make83Name(path, dname, &path))) return false;
     while (*path == '/') path++;
     if (!*path) break;
-    if (!sub->open(parent, dname, O_READ)) {
-      if (!pFlag || !sub->mkdir(parent, dname))
+    if (!sub->open(parent, dname OPTARG(LONG_FILENAME_WRITE_SUPPORT, dlname), O_READ)) {
+      if (!pFlag || !sub->mkdir(parent, dname OPTARG(LONG_FILENAME_WRITE_SUPPORT, dlname)))
         return false;
     }
     if (parent != start) parent->close();
     parent = sub;
     sub = parent != &dir1 ? &dir1 : &dir2;
   }
-  return mkdir(parent, dname);
+  return mkdir(parent, dname OPTARG(LONG_FILENAME_WRITE_SUPPORT, dlname));
 }
 
-bool SdBaseFile::mkdir(SdBaseFile *parent, const uint8_t dname[11]) {
+bool SdBaseFile::mkdir(SdBaseFile *parent, const uint8_t dname[11]
+  OPTARG(LONG_FILENAME_WRITE_SUPPORT, const uint8_t dlname[LONG_FILENAME_LENGTH])
+) {
   if (ENABLED(SDCARD_READONLY)) return false;
 
   if (!parent->isDir()) return false;
 
   // create a normal file
-  if (!open(parent, dname, O_CREAT | O_EXCL | O_RDWR)) return false;
+  if (!open(parent, dname OPTARG(LONG_FILENAME_WRITE_SUPPORT, dlname), O_CREAT | O_EXCL | O_RDWR)) return false;
 
   // convert file to directory
   flags_ = O_READ;
@@ -578,6 +600,10 @@ bool SdBaseFile::open(SdBaseFile *dirFile, const char *path, uint8_t oflag) {
   SdBaseFile dir1, dir2;
   SdBaseFile *parent = dirFile, *sub = &dir1;
 
+  #if ENABLED(LONG_FILENAME_WRITE_SUPPORT)
+    uint8_t dlname[LONG_FILENAME_LENGTH];
+  #endif
+
   if (!dirFile || isOpen()) return false;
 
   if (*path == '/') {                                         // Path starts with '/'
@@ -589,90 +615,244 @@ bool SdBaseFile::open(SdBaseFile *dirFile, const char *path, uint8_t oflag) {
   }
 
   for (;;) {
-    if (!make83Name(path, dname, &path)) return false;
+    if (!TERN(LONG_FILENAME_WRITE_SUPPORT, parsePath(path, dname, dlname, &path), make83Name(path, dname, &path))) return false;
     while (*path == '/') path++;
     if (!*path) break;
-    if (!sub->open(parent, dname, O_READ)) return false;
+    if (TERN0(LONG_FILENAME_WRITE_SUPPORT, !sub->open(parent, dname, dlname, O_READ))) return false;
     if (parent != dirFile) parent->close();
     parent = sub;
     sub = parent != &dir1 ? &dir1 : &dir2;
   }
-  return open(parent, dname, oflag);
+  return open(parent, dname OPTARG(LONG_FILENAME_WRITE_SUPPORT, dlname), oflag);
 }
 
-// open with filename in dname
-bool SdBaseFile::open(SdBaseFile *dirFile, const uint8_t dname[11], uint8_t oflag) {
+// open with filename in dname and long filename in dlname
+bool SdBaseFile::open(SdBaseFile *dirFile, const uint8_t dname[11]
+    OPTARG(LONG_FILENAME_WRITE_SUPPORT, const uint8_t dlname[LONG_FILENAME_LENGTH])
+  , uint8_t oflag
+) {
   bool emptyFound = false, fileFound = false;
-  uint8_t index;
+  uint8_t index = 0;
   dir_t *p;
 
-  vol_ = dirFile->vol_;
+  #if ENABLED(LONG_FILENAME_WRITE_SUPPORT)
+    // LFN - Long File Name support
+    const bool useLFN = dlname[0] != 0;
+    bool lfnFileFound = false;
+    vfat_t *pvFat;
+    uint8_t emptyCount = 0,
+            emptyIndex = 0,
+            reqEntriesNum = useLFN ? getLFNEntriesNum((char*)dlname) + 1 : 1,
+            lfnNameLength = useLFN ? strlen((char*)dlname) : 0,
+            lfnName[LONG_FILENAME_LENGTH],
+            lfnSequenceNumber = 0,
+            lfnChecksum = 0;
+  #endif
 
+  // Rewind this dir
+  vol_ = dirFile->vol_;
   dirFile->rewind();
-  // search for file
 
+  // search for file
   while (dirFile->curPosition_ < dirFile->fileSize_) {
-    index = 0xF & (dirFile->curPosition_ >> 5);
-    p = dirFile->readDirCache();
-    if (!p) return false;
+    // Get absolute index position
+    index = (dirFile->curPosition_ >> 5) IF_DISABLED(LONG_FILENAME_WRITE_SUPPORT, & 0x0F);
 
+    // Get next entry
+    if (!(p = dirFile->readDirCache())) return false;
+
+    // Check empty status: Is entry empty?
     if (p->name[0] == DIR_NAME_FREE || p->name[0] == DIR_NAME_DELETED) {
-      // remember first empty slot
+      // Count the contiguous available entries in which (eventually) fit the new dir entry, if it's a write operation
       if (!emptyFound) {
-        dirBlock_ = dirFile->vol_->cacheBlockNumber();
-        dirIndex_ = index;
-        emptyFound = true;
+        #if ENABLED(LONG_FILENAME_WRITE_SUPPORT)
+          if (emptyCount == 0) emptyIndex = index;
+          // Incr empty entries counter
+          // If found the required empty entries, mark it
+          if (++emptyCount == reqEntriesNum) {
+            dirBlock_ = dirFile->vol_->cacheBlockNumber();
+            dirIndex_ = index & 0xF;
+            emptyFound = true;
+          }
+        #else
+          dirBlock_ = dirFile->vol_->cacheBlockNumber();
+          dirIndex_ = index;
+          emptyFound = true;
+        #endif
       }
-      // done if no entries follow
+      // Done if no entries follow
       if (p->name[0] == DIR_NAME_FREE) break;
     }
-    else if (!memcmp(dname, p->name, 11)) {
-      fileFound = true;
-      break;
+    else {  // Entry not empty
+      #if ENABLED(LONG_FILENAME_WRITE_SUPPORT)
+        // Reset empty counter
+        if (!emptyFound) emptyCount = 0;
+        // Search for SFN or LFN?
+        if (!useLFN) {
+          // Check using SFN: file found?
+          if (!memcmp(dname, p->name, 11)) {
+            fileFound = true;
+            break;
+          }
+        }
+        else {
+          // Check using LFN: LFN not found? continue search for LFN
+          if (!lfnFileFound) {
+            // Is this dir a LFN?
+            if (isDirLFN(p)) {
+              // Get VFat dir entry
+              pvFat = (vfat_t *) p;
+              // Get checksum from the last entry of the sequence
+              if (pvFat->sequenceNumber & 0x40) lfnChecksum = pvFat->checksum;
+              // Get LFN sequence number
+              lfnSequenceNumber = pvFat->sequenceNumber & 0x1F;
+              if WITHIN(lfnSequenceNumber, 1, reqEntriesNum) {
+                // Check checksum for all other entries with the starting checksum fetched before
+                if (lfnChecksum == pvFat->checksum) {
+                  // Set chunk of LFN from VFAT entry into lfnName
+                  getLFNName(pvFat, (char *)lfnName, lfnSequenceNumber);
+                  // LFN found?
+                  if (!strncasecmp((char*)dlname, (char*)lfnName, lfnNameLength)) lfnFileFound = true;
+                }
+              }
+            }
+          }
+          else {    // Complete LFN found, check for related SFN
+            // Check if only the SFN checksum match because the filename may be different due to different truncation methods
+            if (!isDirLFN(p) && (lfnChecksum == lfn_checksum(p->name))) {
+              fileFound = true;
+              break;
+            }
+            else lfnFileFound = false;    // SFN not valid for the LFN found, reset LFN FileFound
+          }
+        }
+      #else
+
+        if (!memcmp(dname, p->name, 11)) {
+          fileFound = true;
+          break;
+        }
+
+      #endif // LONG_FILENAME_WRITE_SUPPORT
     }
   }
+
   if (fileFound) {
     // don't open existing file if O_EXCL
     if (oflag & O_EXCL) return false;
+    TERN_(LONG_FILENAME_WRITE_SUPPORT, index &= 0xF);
   }
   else {
     // don't create unless O_CREAT and O_WRITE
     if ((oflag & (O_CREAT | O_WRITE)) != (O_CREAT | O_WRITE)) return false;
-    if (emptyFound) {
-      index = dirIndex_;
-      p = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
-      if (!p) return false;
-    }
-    else {
-      if (dirFile->type_ == FAT_FILE_TYPE_ROOT_FIXED) return false;
 
-      // add and zero cluster for dirFile - first cluster is in cache for write
-      if (!dirFile->addDirCluster()) return false;
+    #if ENABLED(LONG_FILENAME_WRITE_SUPPORT)
 
-      // use first entry in cluster
-      p = dirFile->vol_->cache()->dir;
-      index = 0;
-    }
-    // initialize as empty file
-    memset(p, 0, sizeof(*p));
-    memcpy(p->name, dname, 11);
+      // Use bookmark index if found empty entries
+      if (emptyFound) index = emptyIndex;
 
-    // set timestamps
-    if (dateTime_) {
-      // call user date/time function
-      dateTime_(&p->creationDate, &p->creationTime);
-    }
-    else {
-      // use default date/time
-      p->creationDate = FAT_DEFAULT_DATE;
-      p->creationTime = FAT_DEFAULT_TIME;
-    }
-    p->lastAccessDate = p->creationDate;
-    p->lastWriteDate = p->creationDate;
-    p->lastWriteTime = p->creationTime;
+      // Make room for needed entries
+      while (emptyCount < reqEntriesNum) {
+        p = dirFile->readDirCache();
+        if (!p) break;
+        emptyCount++;
+      }
+      while (emptyCount < reqEntriesNum) {
+        if (dirFile->type_ == FAT_FILE_TYPE_ROOT_FIXED) return false;
+        // add and zero cluster for dirFile - first cluster is in cache for write
+        if (!dirFile->addDirCluster()) return false;
+        emptyCount += dirFile->vol_->blocksPerCluster() * 16;
+      }
+
+      // Move to 1st entry to write
+      if (!dirFile->seekSet(32 * index)) return false;
+
+      // Dir entries write loop: [LFN] + SFN(1)
+      LOOP_L_N(dirWriteIdx, reqEntriesNum) {
+        index = (dirFile->curPosition_ / 32) & 0xF;
+        p = dirFile->readDirCache();
+        // LFN or SFN Entry?
+        if (dirWriteIdx < reqEntriesNum - 1) {
+          // Write LFN Entries
+          pvFat = (vfat_t *) p;
+          // initialize as empty file
+          memset(pvFat, 0, sizeof(*pvFat));
+          lfnSequenceNumber = (reqEntriesNum - dirWriteIdx - 1) & 0x1F;
+          pvFat->attributes = DIR_ATT_LONG_NAME;
+          pvFat->checksum = lfn_checksum(dname);
+          // Set sequence number and mark as last LFN entry if it's the 1st loop
+          pvFat->sequenceNumber = lfnSequenceNumber | (dirWriteIdx == 0 ? 0x40 : 0);
+          // Set LFN name block
+          setLFNName(pvFat, (char*)dlname, lfnSequenceNumber);
+        }
+        else {
+          // Write SFN Entry
+          // initialize as empty file
+          memset(p, 0, sizeof(*p));
+          memcpy(p->name, dname, 11);
+
+          // set timestamps
+          if (dateTime_) {
+            // call user date/time function
+            dateTime_(&p->creationDate, &p->creationTime);
+          }
+          else {
+            // use default date/time
+            p->creationDate = FAT_DEFAULT_DATE;
+            p->creationTime = FAT_DEFAULT_TIME;
+          }
+          p->lastAccessDate = p->creationDate;
+          p->lastWriteDate = p->creationDate;
+          p->lastWriteTime = p->creationTime;
+        }
+
+        // write entry to SD
+        dirFile->vol_->cacheSetDirty();
+        if (!dirFile->vol_->cacheFlush()) return false;
+      }
+
+    #else // !LONG_FILENAME_WRITE_SUPPORT
+
+      if (emptyFound) {
+        index = dirIndex_;
+        p = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
+        if (!p) return false;
+      }
+      else {
+        if (dirFile->type_ == FAT_FILE_TYPE_ROOT_FIXED) return false;
+
+        // add and zero cluster for dirFile - first cluster is in cache for write
+        if (!dirFile->addDirCluster()) return false;
+
+        // use first entry in cluster
+        p = dirFile->vol_->cache()->dir;
+        index = 0;
+      }
+
+      // initialize as empty file
+      memset(p, 0, sizeof(*p));
+      memcpy(p->name, dname, 11);
+
+      // set timestamps
+      if (dateTime_) {
+        // call user date/time function
+        dateTime_(&p->creationDate, &p->creationTime);
+      }
+      else {
+        // use default date/time
+        p->creationDate = FAT_DEFAULT_DATE;
+        p->creationTime = FAT_DEFAULT_TIME;
+      }
+
+      p->lastAccessDate = p->creationDate;
+      p->lastWriteDate = p->creationDate;
+      p->lastWriteTime = p->creationTime;
+
+      // write entry to SD
+      if (!dirFile->vol_->cacheFlush()) return false;
+
+    #endif // !LONG_FILENAME_WRITE_SUPPORT
 
-    // write entry to SD
-    if (!dirFile->vol_->cacheFlush()) return false;
   }
   // open entry in cache
   return openCachedEntry(index, oflag);
@@ -808,6 +988,191 @@ bool SdBaseFile::openNext(SdBaseFile *dirFile, uint8_t oflag) {
   return false;
 }
 
+#if ENABLED(LONG_FILENAME_WRITE_SUPPORT)
+
+  /**
+   * Check if dir is a long file name entry (LFN)
+   *
+   * \param[in] dir Parent of this directory will be opened.  Must not be root.
+   * \return true if the dir is a long file name entry (LFN)
+   */
+  bool SdBaseFile::isDirLFN(const dir_t* dir) {
+    if (DIR_IS_LONG_NAME(dir)) {
+      vfat_t *VFAT = (vfat_t*)dir;
+      // Sanity-check the VFAT entry. The first cluster is always set to zero. And the sequence number should be higher than 0
+      if ((VFAT->firstClusterLow == 0) && WITHIN((VFAT->sequenceNumber & 0x1F), 1, MAX_VFAT_ENTRIES)) return true;
+    }
+    return false;
+  }
+
+  /**
+   * Check if dirname string is a long file name (LFN)
+   *
+   * \param[in] dirname The string to check
+   * \return true if the dirname is a long file name (LFN)
+   * \return false if the dirname is a short file name 8.3 (SFN)
+   */
+  bool SdBaseFile::isDirNameLFN(const char *dirname) {
+    uint8_t length = strlen(dirname);
+    uint8_t idx = length;
+    bool dotFound = false;
+    if (idx > 12) return true;            // LFN due to filename length > 12 ("filename.ext")
+    // Check dot(s) position
+    while (idx) {
+      if (dirname[--idx] == '.') {
+        if (!dotFound) {
+          // Last dot (extension) is allowed only
+          // in position [1..8] from start or [0..3] from end for SFN else it's a LFN
+          // A filename starting with "." is a LFN                (eg. ".file" ->in SFN-> "file~1     ")
+          // A filename ending with "." is a SFN (if length <= 9) (eg. "file." ->in SFN-> "file       ")
+          if (idx > 8 || idx == 0 || (length - idx - 1) > 3) return true;   // LFN due to dot extension position
+          dotFound = true;
+        }
+        else {
+          // Found another dot, is a LFN
+          return true;
+        }
+      }
+    }
+    // If no dots found, the filename must be of max 8 characters
+    if ((!dotFound) && length > 8) return true;         // LFN due to max filename (without extension) length
+    return false;
+  }
+
+  /**
+   * Parse path and return 8.3 format and LFN filenames (if the parsed path is a LFN)
+   * The SFN is without dot ("FILENAMEEXT")
+   * The LFN is complete ("Filename.ext")
+   */
+  bool SdBaseFile::parsePath(const char *path, uint8_t *name, uint8_t *lname, const char **ptrNextPath) {
+    // Init randomizer for SFN generation
+    randomSeed(millis());
+    // Parse the LFN
+    uint8_t ilfn = 0;
+    bool lastDotFound = false;
+    const char *pLastDot = 0;
+    const char *lfnpath = path;
+    uint8_t c;
+
+    while (*lfnpath && *lfnpath != '/') {
+      if (ilfn == LONG_FILENAME_LENGTH - 1) return false;                 // Name too long
+      c = *lfnpath++;                                                     // Get char and advance
+      // Fail for illegal characters
+      PGM_P p = PSTR("|<>^+=?/[];:,*\"\\");
+      while (uint8_t b = pgm_read_byte(p++)) if (b == c) return false;    // Check reserved characters
+      if (c < 0x20 || c == 0x7F) return false;                            // Check non-printable characters
+      if (c == '.' && (lfnpath - 1) > path) {                             // Skip dot '.' check in 1st position
+        // Save last dot pointer (skip if starts with '.')
+        pLastDot = lfnpath - 1;
+        lastDotFound = true;
+      }
+      lname[ilfn++] = c;  // Set LFN character
+    }
+    // Terminate LFN
+    lname[ilfn] = 0;
+
+    // Parse/generate 8.3 SFN. Will take
+    // until 8 characters for the filename part
+    // until 3 characters for the extension part (if exists)
+    // Add 4 more characters if name part < 3
+    // Add '~cnt' characters if it's a LFN
+    const bool isLFN = isDirNameLFN((char*)lname);
+
+    uint8_t n = isLFN ? 5 : 7,  // Max index for each component of the file:
+                                // starting with 7 or 5 (if LFN)
+                                // switch to 10 for extension if the last dot is found
+            i = 11;
+    while (i) name[--i] = ' ';            // Set whole FILENAMEEXT to spaces
+    while (*path && *path != '/') {
+      c = *path++;                                                        // Get char and advance
+      // Skip spaces and dots (if it's not the last dot)
+      if (c == ' ') continue;
+      if (c == '.' && (!lastDotFound || (lastDotFound && path < pLastDot))) continue;
+      // Fail for illegal characters
+      PGM_P p = PSTR("|<>^+=?/[];:,*\"\\");
+      while (uint8_t b = pgm_read_byte(p++)) if (b == c) return false;    // Check reserved characters
+      if (c < 0x21 || c == 0x7F) return false;                            // Check non-printable characters
+      // Is last dot?
+      if (c == '.') {
+        // Switch to extension part
+        n = 10;
+        i = 8;
+      }
+      // If in valid range add the character
+      else if (i <= n)                                          // Check size for 8.3 format
+        name[i++] = c + (WITHIN(c, 'a', 'z') ? 'A' - 'a' : 0);  // Uppercase required for 8.3 name
+    }
+    // If it's a LFN then the SFN always need:
+    // - A minimal of 3 characters (otherwise 4 chars are added)
+    // - The '~cnt' at the end
+    if (isLFN) {
+      // Get the 1st free character
+      uint8_t iFree = 0;
+      while (1) if (name[iFree++] == ' ' || iFree == 11) break;
+      iFree--;
+      // Check minimal length
+      if (iFree < 3) {
+        // Append 4 extra characters
+        name[iFree++] = random(0,24) + 'A'; name[iFree++] = random(0,24) + 'A';
+        name[iFree++] = random(0,24) + 'A'; name[iFree++] = random(0,24) + 'A';
+      }
+      // Append '~cnt' characters
+      if (iFree > 5) iFree = 5; // Force the append in the last 3 characters of name part
+      name[iFree++] = '~';
+      name[iFree++] = random(1,9) + '0';
+      name[iFree++] = random(1,9) + '0';
+    }
+
+    // Check if LFN is needed
+    if (!isLFN) lname[0] = 0;   // Zero LFN
+    *ptrNextPath = path;        // Set passed pointer to the end
+    return name[0] != ' ';      // Return true if any name was set
+  }
+
+  /**
+   * Get the LFN filename block from a dir. Get the block in lname at startOffset
+   */
+  void SdBaseFile::getLFNName(vfat_t *pFatDir, char *lname, uint8_t sequenceNumber) {
+    uint8_t startOffset = (sequenceNumber - 1) * FILENAME_LENGTH;
+    LOOP_L_N(i, FILENAME_LENGTH) {
+      const uint16_t utf16_ch = (i >= 11) ? pFatDir->name3[i - 11] : (i >= 5) ? pFatDir->name2[i - 5] : pFatDir->name1[i];
+      #if ENABLED(UTF_FILENAME_SUPPORT)
+        // We can't reconvert to UTF-8 here as UTF-8 is variable-size encoding, but joining LFN blocks
+        // needs static bytes addressing. So here just store full UTF-16LE words to re-convert later.
+        uint16_t idx = (startOffset + i) * 2; // This is fixed as FAT LFN always contain UTF-16LE encoding
+        longFilename[idx] = utf16_ch & 0xFF;
+        longFilename[idx + 1] = (utf16_ch >> 8) & 0xFF;
+      #else
+        // Replace all multibyte characters to '_'
+        lname[startOffset + i] = (utf16_ch > 0xFF) ? '_' : (utf16_ch & 0xFF);
+      #endif
+    }
+  }
+
+  /**
+   * Set the LFN filename block lname to a dir. Put the block based on sequence number
+   */
+  void SdBaseFile::setLFNName(vfat_t *pFatDir, char *lname, uint8_t sequenceNumber) {
+    uint8_t startOffset = (sequenceNumber - 1) * FILENAME_LENGTH;
+    uint8_t nameLength = strlen(lname);
+    LOOP_L_N(i, FILENAME_LENGTH) {
+      uint16_t ch = 0;
+      if ((startOffset + i) < nameLength)
+        ch = lname[startOffset + i];
+      else if ((startOffset + i) > nameLength)
+        ch = 0xFFFF;
+      // Set char
+      if (i < 5)
+        pFatDir->name1[i] = ch;
+      else if (i < 11)
+        pFatDir->name2[i - 5] = ch;
+      else
+        pFatDir->name3[i - 11] = ch;
+    }
+  }
+
+#endif // LONG_FILENAME_WRITE_SUPPORT
+
 #if 0
 /**
  * Open a directory's parent directory.
@@ -1049,20 +1414,6 @@ int16_t SdBaseFile::read(void *buf, uint16_t nbyte) {
   return nbyte;
 }
 
-/**
- * Calculate a checksum for an 8.3 filename
- *
- * \param name The 8.3 file name to calculate
- *
- * \return The checksum byte
- */
-uint8_t lfn_checksum(const uint8_t *name) {
-  uint8_t sum = 0;
-  for (uint8_t i = 11; i; i--)
-    sum = ((sum & 1) << 7) + (sum >> 1) + *name++;
-  return sum;
-}
-
 /**
  * Read the next entry in a directory.
  *
@@ -1110,30 +1461,40 @@ int8_t SdBaseFile::readDir(dir_t *dir, char *longFilename) {
         if (VFAT->firstClusterLow == 0) {
           const uint8_t seq = VFAT->sequenceNumber & 0x1F;
           if (WITHIN(seq, 1, MAX_VFAT_ENTRIES)) {
-            n = (seq - 1) * (FILENAME_LENGTH);
-            if (n == 0) {
+            if (seq == 1) {
               checksum = VFAT->checksum;
               checksum_error = 0;
             }
             else if (checksum != VFAT->checksum) // orphan detected
               checksum_error = 1;
 
-            LOOP_L_N(i, FILENAME_LENGTH) {
-              const uint16_t utf16_ch = (i >= 11) ? VFAT->name3[i - 11] : (i >= 5) ? VFAT->name2[i - 5] : VFAT->name1[i];
-              #if ENABLED(UTF_FILENAME_SUPPORT)
-                // We can't reconvert to UTF-8 here as UTF-8 is variable-size encoding, but joining LFN blocks
-                // needs static bytes addressing. So here just store full UTF-16LE words to re-convert later.
-                uint16_t idx = (n + i) * 2; // This is fixed as FAT LFN always contain UTF-16LE encoding
-                longFilename[idx] = utf16_ch & 0xFF;
-                longFilename[idx + 1] = (utf16_ch >> 8) & 0xFF;
-              #else
-                // Replace all multibyte characters to '_'
-                longFilename[n + i] = (utf16_ch > 0xFF) ? '_' : (utf16_ch & 0xFF);
-              #endif
-            }
+            #if ENABLED(LONG_FILENAME_WRITE_SUPPORT)
+
+              getLFNName(VFAT, longFilename, seq);  // Get chunk of LFN from VFAT entry
+
+            #else // !LONG_FILENAME_WRITE_SUPPORT
+
+              n = (seq - 1) * (FILENAME_LENGTH);
+
+              LOOP_L_N(i, FILENAME_LENGTH) {
+                const uint16_t utf16_ch = (i >= 11) ? VFAT->name3[i - 11] : (i >= 5) ? VFAT->name2[i - 5] : VFAT->name1[i];
+                #if ENABLED(UTF_FILENAME_SUPPORT)
+                  // We can't reconvert to UTF-8 here as UTF-8 is variable-size encoding, but joining LFN blocks
+                  // needs static bytes addressing. So here just store full UTF-16LE words to re-convert later.
+                  uint16_t idx = (n + i) * 2; // This is fixed as FAT LFN always contain UTF-16LE encoding
+                  longFilename[idx] = utf16_ch & 0xFF;
+                  longFilename[idx + 1] = (utf16_ch >> 8) & 0xFF;
+                #else
+                  // Replace all multibyte characters to '_'
+                  longFilename[n + i] = (utf16_ch > 0xFF) ? '_' : (utf16_ch & 0xFF);
+                #endif
+              }
+
+            #endif // !LONG_FILENAME_WRITE_SUPPORT
+
             // If this VFAT entry is the last one, add a NUL terminator at the end of the string
             if (VFAT->sequenceNumber & 0x40)
-                longFilename[(n + FILENAME_LENGTH) * LONG_FILENAME_CHARSIZE] = '\0';
+              longFilename[LONG_FILENAME_CHARSIZE * TERN(LONG_FILENAME_WRITE_SUPPORT, seq * FILENAME_LENGTH, (n + FILENAME_LENGTH))] = '\0';
           }
         }
       }
@@ -1227,6 +1588,11 @@ bool SdBaseFile::remove() {
   dir_t *d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
   if (!d) return false;
 
+  #if ENABLED(LONG_FILENAME_WRITE_SUPPORT)
+    // get SFN checksum before name rewrite (needed for LFN deletion)
+    const uint8_t sfn_checksum = lfn_checksum(d->name);
+  #endif
+
   // mark entry deleted
   d->name[0] = DIR_NAME_DELETED;
 
@@ -1234,8 +1600,48 @@ bool SdBaseFile::remove() {
   type_ = FAT_FILE_TYPE_CLOSED;
 
   // write entry to SD
-  return vol_->cacheFlush();
-  return true;
+  #if DISABLED(LONG_FILENAME_WRITE_SUPPORT)
+
+    return vol_->cacheFlush();
+
+  #else // LONG_FILENAME_WRITE_SUPPORT
+
+    flags_ = 0;
+
+    if (!vol_->cacheFlush()) return false;
+
+    // Check if the entry has a LFN
+    bool lastEntry = false;
+    // loop back to search for any LFN entries related to this file
+    LOOP_S_LE_N(sequenceNumber, 1, MAX_VFAT_ENTRIES) {
+      dirIndex_ = (dirIndex_ - 1) & 0xF;
+      if (dirBlock_ == 0) break;
+      if (dirIndex_ == 0xF) dirBlock_--;
+      dir_t *dir = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
+      if (!dir) return false;
+
+      // check for valid LFN: not deleted, not top dirs (".", ".."), must be a LFN
+      if (dir->name[0] == DIR_NAME_DELETED || dir->name[0] == '.' || !isDirLFN(dir)) break;
+      // check coherent LFN: checksum and sequenceNumber must match
+      vfat_t* dirlfn = (vfat_t*) dir;
+      if (dirlfn->checksum != sfn_checksum || (dirlfn->sequenceNumber & 0x1F) != sequenceNumber) break;    // orphan entry
+      // is last entry of LFN ?
+      lastEntry = (dirlfn->sequenceNumber & 0x40);
+      // mark as deleted
+      dirlfn->sequenceNumber = DIR_NAME_DELETED;
+      // Flush to SD
+      if (!vol_->cacheFlush()) return false;
+      // exit on last entry of LFN deleted
+      if (lastEntry) break;
+    }
+
+    // Restore current index
+    //if (!seekSet(32UL * dirIndex_)) return false;
+    //dirIndex_ += prevDirIndex;
+
+    return true;
+
+  #endif // LONG_FILENAME_WRITE_SUPPORT
 }
 
 /**

commit 8da8bf7e879835a14c045fdfe947c81008027a17
Author: vyacheslav-shubin <shubin-vv@krista.ru>
Date:   Mon Apr 5 02:52:16 2021 +0300

    Fix FAT delete of items with long name (#21528)

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index ac73a5a806..b357495a3e 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -1049,6 +1049,20 @@ int16_t SdBaseFile::read(void *buf, uint16_t nbyte) {
   return nbyte;
 }
 
+/**
+ * Calculate a checksum for an 8.3 filename
+ *
+ * \param name The 8.3 file name to calculate
+ *
+ * \return The checksum byte
+ */
+uint8_t lfn_checksum(const uint8_t *name) {
+  uint8_t sum = 0;
+  for (uint8_t i = 11; i; i--)
+    sum = ((sum & 1) << 7) + (sum >> 1) + *name++;
+  return sum;
+}
+
 /**
  * Read the next entry in a directory.
  *
@@ -1065,51 +1079,68 @@ int8_t SdBaseFile::readDir(dir_t *dir, char *longFilename) {
   // if not a directory file or miss-positioned return an error
   if (!isDir() || (0x1F & curPosition_)) return -1;
 
+  #define INVALIDATE_LONGNAME() (longFilename[0] = longFilename[1] = '\0')
+
   // If we have a longFilename buffer, mark it as invalid.
   // If a long filename is found it will be filled automatically.
-  if (longFilename) { longFilename[0] = '\0'; longFilename[1] = '\0'; }
+  if (longFilename) INVALIDATE_LONGNAME();
+
+  uint8_t checksum_error = 0xFF, checksum = 0;
 
   while (1) {
 
     n = read(dir, sizeof(dir_t));
     if (n != sizeof(dir_t)) return n ? -1 : 0;
 
-    // last entry if DIR_NAME_FREE
+    // Last entry if DIR_NAME_FREE
     if (dir->name[0] == DIR_NAME_FREE) return 0;
 
-    // skip deleted entry and entry for .  and ..
+    // Skip deleted entry and entry for . and ..
     if (dir->name[0] == DIR_NAME_DELETED || dir->name[0] == '.') {
-      if (longFilename) { longFilename[0] = '\0'; longFilename[1] = '\0'; } // Invalidate erased file long name, if any
+      if (longFilename) INVALIDATE_LONGNAME();   // Invalidate erased file long name, if any
       continue;
     }
 
-    // Fill the long filename if we have a long filename entry.
-    // Long filename entries are stored before the short filename.
-    if (longFilename && DIR_IS_LONG_NAME(dir)) {
-      vfat_t *VFAT = (vfat_t*)dir;
-      // Sanity-check the VFAT entry. The first cluster is always set to zero. And the sequence number should be higher than 0
-      if (VFAT->firstClusterLow == 0) {
-        const uint8_t seq = VFAT->sequenceNumber & 0x1F;
-        if (WITHIN(seq, 1, MAX_VFAT_ENTRIES)) {
-          // TODO: Store the filename checksum to verify if a long-filename-unaware system modified the file table.
-          n = (seq - 1) * (FILENAME_LENGTH);
-          LOOP_L_N(i, FILENAME_LENGTH) {
-            uint16_t utf16_ch = (i < 5) ? VFAT->name1[i] : (i < 11) ? VFAT->name2[i - 5] : VFAT->name3[i - 11];
-            #if ENABLED(UTF_FILENAME_SUPPORT)
-              // We can't reconvert to UTF-8 here as UTF-8 is variable-size encoding, but joining LFN blocks
-              // needs static bytes addressing. So here just store full UTF-16LE words to re-convert later.
-              uint16_t idx = (n + i) * 2; // This is fixed as FAT LFN always contain UTF-16LE encoding
-              longFilename[idx]     =  utf16_ch       & 0xFF;
-              longFilename[idx + 1] = (utf16_ch >> 8) & 0xFF;
-            #else
-              // Replace all multibyte characters to '_'
-              longFilename[n + i] = (utf16_ch > 0xFF) ? '_' : (utf16_ch & 0xFF);
-            #endif
+    if (longFilename) {
+      // Fill the long filename if we have a long filename entry.
+      // Long filename entries are stored before the short filename.
+      if (DIR_IS_LONG_NAME(dir)) {
+        vfat_t *VFAT = (vfat_t*)dir;
+        // Sanity-check the VFAT entry. The first cluster is always set to zero. And the sequence number should be higher than 0
+        if (VFAT->firstClusterLow == 0) {
+          const uint8_t seq = VFAT->sequenceNumber & 0x1F;
+          if (WITHIN(seq, 1, MAX_VFAT_ENTRIES)) {
+            n = (seq - 1) * (FILENAME_LENGTH);
+            if (n == 0) {
+              checksum = VFAT->checksum;
+              checksum_error = 0;
+            }
+            else if (checksum != VFAT->checksum) // orphan detected
+              checksum_error = 1;
+
+            LOOP_L_N(i, FILENAME_LENGTH) {
+              const uint16_t utf16_ch = (i >= 11) ? VFAT->name3[i - 11] : (i >= 5) ? VFAT->name2[i - 5] : VFAT->name1[i];
+              #if ENABLED(UTF_FILENAME_SUPPORT)
+                // We can't reconvert to UTF-8 here as UTF-8 is variable-size encoding, but joining LFN blocks
+                // needs static bytes addressing. So here just store full UTF-16LE words to re-convert later.
+                uint16_t idx = (n + i) * 2; // This is fixed as FAT LFN always contain UTF-16LE encoding
+                longFilename[idx] = utf16_ch & 0xFF;
+                longFilename[idx + 1] = (utf16_ch >> 8) & 0xFF;
+              #else
+                // Replace all multibyte characters to '_'
+                longFilename[n + i] = (utf16_ch > 0xFF) ? '_' : (utf16_ch & 0xFF);
+              #endif
+            }
+            // If this VFAT entry is the last one, add a NUL terminator at the end of the string
+            if (VFAT->sequenceNumber & 0x40)
+                longFilename[(n + FILENAME_LENGTH) * LONG_FILENAME_CHARSIZE] = '\0';
           }
-          // If this VFAT entry is the last one, add a NUL terminator at the end of the string
-          if (VFAT->sequenceNumber & 0x40) longFilename[(n + FILENAME_LENGTH) * LONG_FILENAME_CHARSIZE] = '\0';
         }
       }
+      else {
+        if (!checksum_error && lfn_checksum(dir->name) != checksum) checksum_error = 1; // orphan detected
+        if (checksum_error) INVALIDATE_LONGNAME();
+      }
     }
 
     // Post-process normal file or subdirectory longname, if any

commit 8b6718c6320c32abe0fa1de56a033aca54ff0b76
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Apr 4 18:07:16 2021 -0500

    misc. pointer formatting

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index 120668baa8..ac73a5a806 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -40,7 +40,7 @@
 #include "SdBaseFile.h"
 
 #include "../MarlinCore.h"
-SdBaseFile* SdBaseFile::cwd_ = 0;   // Pointer to Current Working Directory
+SdBaseFile *SdBaseFile::cwd_ = 0;   // Pointer to Current Working Directory
 
 // callback function for date/time
 void (*SdBaseFile::dateTime_)(uint16_t *date, uint16_t *time) = 0;
@@ -155,7 +155,7 @@ bool SdBaseFile::contiguousRange(uint32_t *bgnBlock, uint32_t *endBlock) {
  * a file is already open, the file already exists, the root
  * directory is full or an I/O error.
  */
-bool SdBaseFile::createContiguous(SdBaseFile* dirFile, const char *path, uint32_t size) {
+bool SdBaseFile::createContiguous(SdBaseFile *dirFile, const char *path, uint32_t size) {
   if (ENABLED(SDCARD_READONLY)) return false;
 
   uint32_t count;
@@ -187,12 +187,11 @@ bool SdBaseFile::createContiguous(SdBaseFile* dirFile, const char *path, uint32_
  * \return true for success, false for failure.
  */
 bool SdBaseFile::dirEntry(dir_t *dir) {
-  dir_t *p;
   // make sure fields on SD are correct
   if (!sync()) return false;
 
   // read entry
-  p = cacheDirEntry(SdVolume::CACHE_FOR_READ);
+  dir_t *p = cacheDirEntry(SdVolume::CACHE_FOR_READ);
   if (!p) return false;
 
   // copy to caller's struct
@@ -207,7 +206,7 @@ bool SdBaseFile::dirEntry(dir_t *dir) {
  * \param[in] dir The directory structure containing the name.
  * \param[out] name A 13 byte char array for the formatted name.
  */
-void SdBaseFile::dirName(const dir_t& dir, char *name) {
+void SdBaseFile::dirName(const dir_t &dir, char *name) {
   uint8_t j = 0;
   LOOP_L_N(i, 11) {
     if (dir.name[i] == ' ')continue;
@@ -386,7 +385,7 @@ int8_t SdBaseFile::lsPrintNext(uint8_t flags, uint8_t indent) {
 }
 
 // Format directory name field from a 8.3 name string
-bool SdBaseFile::make83Name(const char *str, uint8_t *name, const char** ptr) {
+bool SdBaseFile::make83Name(const char *str, uint8_t *name, const char **ptr) {
   uint8_t n = 7,                      // Max index until a dot is found
           i = 11;
   while (i) name[--i] = ' ';          // Set whole FILENAME.EXT to spaces
@@ -423,13 +422,13 @@ bool SdBaseFile::make83Name(const char *str, uint8_t *name, const char** ptr) {
  * Reasons for failure include this file is already open, \a parent is not a
  * directory, \a path is invalid or already exists in \a parent.
  */
-bool SdBaseFile::mkdir(SdBaseFile* parent, const char *path, bool pFlag) {
+bool SdBaseFile::mkdir(SdBaseFile *parent, const char *path, bool pFlag) {
   if (ENABLED(SDCARD_READONLY)) return false;
 
   uint8_t dname[11];
   SdBaseFile dir1, dir2;
-  SdBaseFile* sub = &dir1;
-  SdBaseFile* start = parent;
+  SdBaseFile *sub = &dir1;
+  SdBaseFile *start = parent;
 
   if (!parent || isOpen()) return false;
 
@@ -455,13 +454,9 @@ bool SdBaseFile::mkdir(SdBaseFile* parent, const char *path, bool pFlag) {
   return mkdir(parent, dname);
 }
 
-bool SdBaseFile::mkdir(SdBaseFile* parent, const uint8_t dname[11]) {
+bool SdBaseFile::mkdir(SdBaseFile *parent, const uint8_t dname[11]) {
   if (ENABLED(SDCARD_READONLY)) return false;
 
-  uint32_t block;
-  dir_t d;
-  dir_t *p;
-
   if (!parent->isDir()) return false;
 
   // create a normal file
@@ -478,19 +473,20 @@ bool SdBaseFile::mkdir(SdBaseFile* parent, const uint8_t dname[11]) {
   if (!sync()) return false;
 
   // cache entry - should already be in cache due to sync() call
-  p = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
+  dir_t *p = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
   if (!p) return false;
 
   // change directory entry  attribute
   p->attributes = DIR_ATT_DIRECTORY;
 
   // make entry for '.'
+  dir_t d;
   memcpy(&d, p, sizeof(d));
   d.name[0] = '.';
   LOOP_S_L_N(i, 1, 11) d.name[i] = ' ';
 
   // cache block for '.'  and '..'
-  block = vol_->clusterStartBlock(firstCluster_);
+  uint32_t block = vol_->clusterStartBlock(firstCluster_);
   if (!vol_->cacheRawBlock(block, SdVolume::CACHE_FOR_WRITE)) return false;
 
   // copy '.' to block
@@ -577,7 +573,7 @@ bool SdBaseFile::open(const char *path, uint8_t oflag) {
  * a directory, \a path is invalid, the file does not exist
  * or can't be opened in the access mode specified by oflag.
  */
-bool SdBaseFile::open(SdBaseFile* dirFile, const char *path, uint8_t oflag) {
+bool SdBaseFile::open(SdBaseFile *dirFile, const char *path, uint8_t oflag) {
   uint8_t dname[11];
   SdBaseFile dir1, dir2;
   SdBaseFile *parent = dirFile, *sub = &dir1;
@@ -605,7 +601,7 @@ bool SdBaseFile::open(SdBaseFile* dirFile, const char *path, uint8_t oflag) {
 }
 
 // open with filename in dname
-bool SdBaseFile::open(SdBaseFile* dirFile, const uint8_t dname[11], uint8_t oflag) {
+bool SdBaseFile::open(SdBaseFile *dirFile, const uint8_t dname[11], uint8_t oflag) {
   bool emptyFound = false, fileFound = false;
   uint8_t index;
   dir_t *p;
@@ -696,9 +692,7 @@ bool SdBaseFile::open(SdBaseFile* dirFile, const uint8_t dname[11], uint8_t ofla
  * See open() by path for definition of flags.
  * \return true for success or false for failure.
  */
-bool SdBaseFile::open(SdBaseFile* dirFile, uint16_t index, uint8_t oflag) {
-  dir_t *p;
-
+bool SdBaseFile::open(SdBaseFile *dirFile, uint16_t index, uint8_t oflag) {
   vol_ = dirFile->vol_;
 
   // error if already open
@@ -711,7 +705,7 @@ bool SdBaseFile::open(SdBaseFile* dirFile, uint16_t index, uint8_t oflag) {
   if (!dirFile->seekSet(32 * index)) return false;
 
   // read entry into cache
-  p = dirFile->readDirCache();
+  dir_t *p = dirFile->readDirCache();
   if (!p) return false;
 
   // error if empty slot or '.' or '..'
@@ -784,10 +778,7 @@ bool SdBaseFile::openCachedEntry(uint8_t dirIndex, uint8_t oflag) {
  * See open() by path for definition of flags.
  * \return true for success or false for failure.
  */
-bool SdBaseFile::openNext(SdBaseFile* dirFile, uint8_t oflag) {
-  dir_t *p;
-  uint8_t index;
-
+bool SdBaseFile::openNext(SdBaseFile *dirFile, uint8_t oflag) {
   if (!dirFile) return false;
 
   // error if already open
@@ -796,10 +787,10 @@ bool SdBaseFile::openNext(SdBaseFile* dirFile, uint8_t oflag) {
   vol_ = dirFile->vol_;
 
   while (1) {
-    index = 0xF & (dirFile->curPosition_ >> 5);
+    uint8_t index = 0xF & (dirFile->curPosition_ >> 5);
 
     // read entry into cache
-    p = dirFile->readDirCache();
+    dir_t *p = dirFile->readDirCache();
     if (!p) return false;
 
     // done if last entry
@@ -825,9 +816,8 @@ bool SdBaseFile::openNext(SdBaseFile* dirFile, uint8_t oflag) {
  *
  * \return true for success, false for failure.
  */
-bool SdBaseFile::openParent(SdBaseFile* dir) {
+bool SdBaseFile::openParent(SdBaseFile *dir) {
   dir_t entry;
-  dir_t *p;
   SdBaseFile file;
   uint32_t c;
   uint32_t cluster;
@@ -850,7 +840,7 @@ bool SdBaseFile::openParent(SdBaseFile* dir) {
   // first block of parent dir
   if (!vol_->cacheRawBlock(lbn, SdVolume::CACHE_FOR_READ)) return false;
 
-  p = &vol_->cacheBuffer_.dir[1];
+  dir_t *p = &vol_->cacheBuffer_.dir[1];
   // verify name for '../..'
   if (p->name[0] != '.' || p->name[1] != '.') return false;
   // '..' is pointer to first cluster of parent. open '../..' to find parent
@@ -881,7 +871,7 @@ bool SdBaseFile::openParent(SdBaseFile* dir) {
  * Reasons for failure include the file is already open, the FAT volume has
  * not been initialized or it a FAT12 volume.
  */
-bool SdBaseFile::openRoot(SdVolume* vol) {
+bool SdBaseFile::openRoot(SdVolume *vol) {
   // error if file is already open
   if (isOpen()) return false;
 
@@ -1008,7 +998,7 @@ int16_t SdBaseFile::read() {
  * read() called before a file has been opened, corrupt file system
  * or an I/O error occurred.
  */
-int16_t SdBaseFile::read(void* buf, uint16_t nbyte) {
+int16_t SdBaseFile::read(void *buf, uint16_t nbyte) {
   uint8_t *dst = reinterpret_cast<uint8_t*>(buf);
   uint16_t offset, toRead;
   uint32_t block;  // raw device block number
@@ -1136,7 +1126,7 @@ int8_t SdBaseFile::readDir(dir_t *dir, char *longFilename) {
           // Reset n to the start of the long name
           n = 0;
           for (uint16_t idx = 0; idx < (LONG_FILENAME_LENGTH) / 2; idx += 2) {    // idx is fixed since FAT LFN always contains UTF-16LE encoding
-            uint16_t utf16_ch = longFilename[idx] | (longFilename[idx + 1] << 8);
+            const uint16_t utf16_ch = longFilename[idx] | (longFilename[idx + 1] << 8);
             if (0xD800 == (utf16_ch & 0xF800))                                    // Surrogate pair - encode as '_'
               longFilename[n++] = '_';
             else if (0 == (utf16_ch & 0xFF80))                                    // Encode as 1-byte UTF-8 char
@@ -1199,12 +1189,11 @@ dir_t* SdBaseFile::readDirCache() {
 bool SdBaseFile::remove() {
   if (ENABLED(SDCARD_READONLY)) return false;
 
-  dir_t *d;
   // free any clusters - will fail if read-only or directory
   if (!truncate(0)) return false;
 
   // cache directory entry
-  d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
+  dir_t *d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
   if (!d) return false;
 
   // mark entry deleted
@@ -1235,7 +1224,7 @@ bool SdBaseFile::remove() {
  * \a dirFile is not a directory, \a path is not found
  * or an I/O error occurred.
  */
-bool SdBaseFile::remove(SdBaseFile* dirFile, const char *path) {
+bool SdBaseFile::remove(SdBaseFile *dirFile, const char *path) {
   if (ENABLED(SDCARD_READONLY)) return false;
 
   SdBaseFile file;
@@ -1252,13 +1241,10 @@ bool SdBaseFile::remove(SdBaseFile* dirFile, const char *path) {
  * Reasons for failure include \a dirFile is not open or is not a directory
  * file, newPath is invalid or already exists, or an I/O error occurs.
  */
-bool SdBaseFile::rename(SdBaseFile* dirFile, const char *newPath) {
+bool SdBaseFile::rename(SdBaseFile *dirFile, const char *newPath) {
   if (ENABLED(SDCARD_READONLY)) return false;
 
-  dir_t entry;
   uint32_t dirCluster = 0;
-  SdBaseFile file;
-  dir_t *d;
 
   // must be an open file or subdirectory
   if (!(isFile() || isSubDir())) return false;
@@ -1268,16 +1254,18 @@ bool SdBaseFile::rename(SdBaseFile* dirFile, const char *newPath) {
 
   // sync() and cache directory entry
   sync();
-  d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
+  dir_t *d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
   if (!d) return false;
 
   // save directory entry
+  dir_t entry;
   memcpy(&entry, d, sizeof(entry));
 
   // mark entry deleted
   d->name[0] = DIR_NAME_DELETED;
 
   // make directory entry for new path
+  SdBaseFile file;
   if (isFile()) {
     if (!file.open(dirFile, newPath, O_CREAT | O_EXCL | O_WRITE)) {
       goto restore;
@@ -1536,8 +1524,7 @@ bool SdBaseFile::sync() {
  *
  * \return true for success, false for failure.
  */
-bool SdBaseFile::timestamp(SdBaseFile* file) {
-  dir_t *d;
+bool SdBaseFile::timestamp(SdBaseFile *file) {
   dir_t dir;
 
   // get timestamps
@@ -1546,7 +1533,7 @@ bool SdBaseFile::timestamp(SdBaseFile* file) {
   // update directory fields
   if (!sync()) return false;
 
-  d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
+  dir_t *d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
   if (!d) return false;
 
   // copy timestamps
@@ -1599,7 +1586,6 @@ bool SdBaseFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
   if (ENABLED(SDCARD_READONLY)) return false;
 
   uint16_t dirDate, dirTime;
-  dir_t *d;
 
   if (!isOpen()
       || year < 1980
@@ -1616,7 +1602,7 @@ bool SdBaseFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
   // update directory entry
   if (!sync()) return false;
 
-  d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
+  dir_t *d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
   if (!d) return false;
 
   dirDate = FAT_DATE(year, month, day);
@@ -1710,7 +1696,7 @@ bool SdBaseFile::truncate(uint32_t length) {
  * include write() is called before a file has been opened, write is called
  * for a read-only file, device is full, a corrupt file system or an I/O error.
  */
-int16_t SdBaseFile::write(const void* buf, uint16_t nbyte) {
+int16_t SdBaseFile::write(const void *buf, uint16_t nbyte) {
   #if ENABLED(SDCARD_READONLY)
     writeError = true; return -1;
   #endif

commit 3b73b115ca9366f0155986b717d4c85c31ed2f80
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 29 20:36:37 2021 -0500

    Apply pointer formatting

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index 3cd88318ff..120668baa8 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -43,7 +43,7 @@
 SdBaseFile* SdBaseFile::cwd_ = 0;   // Pointer to Current Working Directory
 
 // callback function for date/time
-void (*SdBaseFile::dateTime_)(uint16_t* date, uint16_t* time) = 0;
+void (*SdBaseFile::dateTime_)(uint16_t *date, uint16_t *time) = 0;
 
 // add a cluster to a file
 bool SdBaseFile::addCluster() {
@@ -118,7 +118,7 @@ bool SdBaseFile::close() {
  * Reasons for failure include file is not contiguous, file has zero length
  * or an I/O error occurred.
  */
-bool SdBaseFile::contiguousRange(uint32_t* bgnBlock, uint32_t* endBlock) {
+bool SdBaseFile::contiguousRange(uint32_t *bgnBlock, uint32_t *endBlock) {
   // error if no blocks
   if (firstCluster_ == 0) return false;
 
@@ -155,7 +155,7 @@ bool SdBaseFile::contiguousRange(uint32_t* bgnBlock, uint32_t* endBlock) {
  * a file is already open, the file already exists, the root
  * directory is full or an I/O error.
  */
-bool SdBaseFile::createContiguous(SdBaseFile* dirFile, const char* path, uint32_t size) {
+bool SdBaseFile::createContiguous(SdBaseFile* dirFile, const char *path, uint32_t size) {
   if (ENABLED(SDCARD_READONLY)) return false;
 
   uint32_t count;
@@ -186,8 +186,8 @@ bool SdBaseFile::createContiguous(SdBaseFile* dirFile, const char* path, uint32_
  *
  * \return true for success, false for failure.
  */
-bool SdBaseFile::dirEntry(dir_t* dir) {
-  dir_t* p;
+bool SdBaseFile::dirEntry(dir_t *dir) {
+  dir_t *p;
   // make sure fields on SD are correct
   if (!sync()) return false;
 
@@ -207,7 +207,7 @@ bool SdBaseFile::dirEntry(dir_t* dir) {
  * \param[in] dir The directory structure containing the name.
  * \param[out] name A 13 byte char array for the formatted name.
  */
-void SdBaseFile::dirName(const dir_t& dir, char* name) {
+void SdBaseFile::dirName(const dir_t& dir, char *name) {
   uint8_t j = 0;
   LOOP_L_N(i, 11) {
     if (dir.name[i] == ' ')continue;
@@ -229,7 +229,7 @@ void SdBaseFile::dirName(const dir_t& dir, char* name) {
  *
  * \return true if the file exists else false.
  */
-bool SdBaseFile::exists(const char* name) {
+bool SdBaseFile::exists(const char *name) {
   SdBaseFile file;
   return file.open(this, name, O_READ);
 }
@@ -254,7 +254,7 @@ bool SdBaseFile::exists(const char* name) {
  * \return For success fgets() returns the length of the string in \a str.
  * If no data is read, fgets() returns zero for EOF or -1 if an error occurred.
  **/
-int16_t SdBaseFile::fgets(char* str, int16_t num, char* delim) {
+int16_t SdBaseFile::fgets(char *str, int16_t num, char *delim) {
   char ch;
   int16_t n = 0;
   int16_t r = -1;
@@ -293,7 +293,7 @@ bool SdBaseFile::getDosName(char * const name) {
     return true;
   }
   // cache entry
-  dir_t* p = cacheDirEntry(SdVolume::CACHE_FOR_READ);
+  dir_t *p = cacheDirEntry(SdVolume::CACHE_FOR_READ);
   if (!p) return false;
 
   // format name
@@ -301,7 +301,7 @@ bool SdBaseFile::getDosName(char * const name) {
   return true;
 }
 
-void SdBaseFile::getpos(filepos_t* pos) {
+void SdBaseFile::getpos(filepos_t *pos) {
   pos->position = curPosition_;
   pos->cluster = curCluster_;
 }
@@ -386,7 +386,7 @@ int8_t SdBaseFile::lsPrintNext(uint8_t flags, uint8_t indent) {
 }
 
 // Format directory name field from a 8.3 name string
-bool SdBaseFile::make83Name(const char* str, uint8_t* name, const char** ptr) {
+bool SdBaseFile::make83Name(const char *str, uint8_t *name, const char** ptr) {
   uint8_t n = 7,                      // Max index until a dot is found
           i = 11;
   while (i) name[--i] = ' ';          // Set whole FILENAME.EXT to spaces
@@ -423,7 +423,7 @@ bool SdBaseFile::make83Name(const char* str, uint8_t* name, const char** ptr) {
  * Reasons for failure include this file is already open, \a parent is not a
  * directory, \a path is invalid or already exists in \a parent.
  */
-bool SdBaseFile::mkdir(SdBaseFile* parent, const char* path, bool pFlag) {
+bool SdBaseFile::mkdir(SdBaseFile* parent, const char *path, bool pFlag) {
   if (ENABLED(SDCARD_READONLY)) return false;
 
   uint8_t dname[11];
@@ -460,7 +460,7 @@ bool SdBaseFile::mkdir(SdBaseFile* parent, const uint8_t dname[11]) {
 
   uint32_t block;
   dir_t d;
-  dir_t* p;
+  dir_t *p;
 
   if (!parent->isDir()) return false;
 
@@ -523,7 +523,7 @@ bool SdBaseFile::mkdir(SdBaseFile* parent, const uint8_t dname[11]) {
  *
  * \return true for success, false for failure.
  */
-bool SdBaseFile::open(const char* path, uint8_t oflag) {
+bool SdBaseFile::open(const char *path, uint8_t oflag) {
   return open(cwd_, path, oflag);
 }
 
@@ -577,7 +577,7 @@ bool SdBaseFile::open(const char* path, uint8_t oflag) {
  * a directory, \a path is invalid, the file does not exist
  * or can't be opened in the access mode specified by oflag.
  */
-bool SdBaseFile::open(SdBaseFile* dirFile, const char* path, uint8_t oflag) {
+bool SdBaseFile::open(SdBaseFile* dirFile, const char *path, uint8_t oflag) {
   uint8_t dname[11];
   SdBaseFile dir1, dir2;
   SdBaseFile *parent = dirFile, *sub = &dir1;
@@ -608,7 +608,7 @@ bool SdBaseFile::open(SdBaseFile* dirFile, const char* path, uint8_t oflag) {
 bool SdBaseFile::open(SdBaseFile* dirFile, const uint8_t dname[11], uint8_t oflag) {
   bool emptyFound = false, fileFound = false;
   uint8_t index;
-  dir_t* p;
+  dir_t *p;
 
   vol_ = dirFile->vol_;
 
@@ -697,7 +697,7 @@ bool SdBaseFile::open(SdBaseFile* dirFile, const uint8_t dname[11], uint8_t ofla
  * \return true for success or false for failure.
  */
 bool SdBaseFile::open(SdBaseFile* dirFile, uint16_t index, uint8_t oflag) {
-  dir_t* p;
+  dir_t *p;
 
   vol_ = dirFile->vol_;
 
@@ -725,7 +725,7 @@ bool SdBaseFile::open(SdBaseFile* dirFile, uint16_t index, uint8_t oflag) {
 
 // open a cached directory entry. Assumes vol_ is initialized
 bool SdBaseFile::openCachedEntry(uint8_t dirIndex, uint8_t oflag) {
-  dir_t* p;
+  dir_t *p;
 
   #if ENABLED(SDCARD_READONLY)
     if (oflag & (O_WRITE | O_CREAT | O_TRUNC)) goto FAIL;
@@ -785,7 +785,7 @@ bool SdBaseFile::openCachedEntry(uint8_t dirIndex, uint8_t oflag) {
  * \return true for success or false for failure.
  */
 bool SdBaseFile::openNext(SdBaseFile* dirFile, uint8_t oflag) {
-  dir_t* p;
+  dir_t *p;
   uint8_t index;
 
   if (!dirFile) return false;
@@ -827,7 +827,7 @@ bool SdBaseFile::openNext(SdBaseFile* dirFile, uint8_t oflag) {
  */
 bool SdBaseFile::openParent(SdBaseFile* dir) {
   dir_t entry;
-  dir_t* p;
+  dir_t *p;
   SdBaseFile file;
   uint32_t c;
   uint32_t cluster;
@@ -1009,7 +1009,7 @@ int16_t SdBaseFile::read() {
  * or an I/O error occurred.
  */
 int16_t SdBaseFile::read(void* buf, uint16_t nbyte) {
-  uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
+  uint8_t *dst = reinterpret_cast<uint8_t*>(buf);
   uint16_t offset, toRead;
   uint32_t block;  // raw device block number
 
@@ -1049,7 +1049,7 @@ int16_t SdBaseFile::read(void* buf, uint16_t nbyte) {
     else {
       // read block to cache and copy data to caller
       if (!vol_->cacheRawBlock(block, SdVolume::CACHE_FOR_READ)) return -1;
-      uint8_t* src = vol_->cache()->data + offset;
+      uint8_t *src = vol_->cache()->data + offset;
       memcpy(dst, src, n);
     }
     dst += n;
@@ -1070,7 +1070,7 @@ int16_t SdBaseFile::read(void* buf, uint16_t nbyte) {
  * readDir() called before a directory has been opened, this is not
  * a directory file or an I/O error occurred.
  */
-int8_t SdBaseFile::readDir(dir_t* dir, char* longFilename) {
+int8_t SdBaseFile::readDir(dir_t *dir, char *longFilename) {
   int16_t n;
   // if not a directory file or miss-positioned return an error
   if (!isDir() || (0x1F & curPosition_)) return -1;
@@ -1096,7 +1096,7 @@ int8_t SdBaseFile::readDir(dir_t* dir, char* longFilename) {
     // Fill the long filename if we have a long filename entry.
     // Long filename entries are stored before the short filename.
     if (longFilename && DIR_IS_LONG_NAME(dir)) {
-      vfat_t* VFAT = (vfat_t*)dir;
+      vfat_t *VFAT = (vfat_t*)dir;
       // Sanity-check the VFAT entry. The first cluster is always set to zero. And the sequence number should be higher than 0
       if (VFAT->firstClusterLow == 0) {
         const uint8_t seq = VFAT->sequenceNumber & 0x1F;
@@ -1199,7 +1199,7 @@ dir_t* SdBaseFile::readDirCache() {
 bool SdBaseFile::remove() {
   if (ENABLED(SDCARD_READONLY)) return false;
 
-  dir_t* d;
+  dir_t *d;
   // free any clusters - will fail if read-only or directory
   if (!truncate(0)) return false;
 
@@ -1235,7 +1235,7 @@ bool SdBaseFile::remove() {
  * \a dirFile is not a directory, \a path is not found
  * or an I/O error occurred.
  */
-bool SdBaseFile::remove(SdBaseFile* dirFile, const char* path) {
+bool SdBaseFile::remove(SdBaseFile* dirFile, const char *path) {
   if (ENABLED(SDCARD_READONLY)) return false;
 
   SdBaseFile file;
@@ -1252,13 +1252,13 @@ bool SdBaseFile::remove(SdBaseFile* dirFile, const char* path) {
  * Reasons for failure include \a dirFile is not open or is not a directory
  * file, newPath is invalid or already exists, or an I/O error occurs.
  */
-bool SdBaseFile::rename(SdBaseFile* dirFile, const char* newPath) {
+bool SdBaseFile::rename(SdBaseFile* dirFile, const char *newPath) {
   if (ENABLED(SDCARD_READONLY)) return false;
 
   dir_t entry;
   uint32_t dirCluster = 0;
   SdBaseFile file;
-  dir_t* d;
+  dir_t *d;
 
   // must be an open file or subdirectory
   if (!(isFile() || isSubDir())) return false;
@@ -1356,7 +1356,7 @@ bool SdBaseFile::rmdir() {
 
   // make sure directory is empty
   while (curPosition_ < fileSize_) {
-    dir_t* p = readDirCache();
+    dir_t *p = readDirCache();
     if (!p) return false;
     // done if past last used entry
     if (p->name[0] == DIR_NAME_FREE) break;
@@ -1396,7 +1396,7 @@ bool SdBaseFile::rmRfStar() {
     // remember position
     index = curPosition_ / 32;
 
-    dir_t* p = readDirCache();
+    dir_t *p = readDirCache();
     if (!p) return false;
 
     // done if past last entry
@@ -1438,7 +1438,7 @@ bool SdBaseFile::rmRfStar() {
  * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive
  * OR of open flags. see SdBaseFile::open(SdBaseFile*, const char*, uint8_t).
  */
-SdBaseFile::SdBaseFile(const char* path, uint8_t oflag) {
+SdBaseFile::SdBaseFile(const char *path, uint8_t oflag) {
   type_ = FAT_FILE_TYPE_CLOSED;
   writeError = false;
   open(path, oflag);
@@ -1481,7 +1481,7 @@ bool SdBaseFile::seekSet(const uint32_t pos) {
   return true;
 }
 
-void SdBaseFile::setpos(filepos_t* pos) {
+void SdBaseFile::setpos(filepos_t *pos) {
   curPosition_ = pos->position;
   curCluster_ = pos->cluster;
 }
@@ -1499,7 +1499,7 @@ bool SdBaseFile::sync() {
   if (ENABLED(SDCARD_READONLY) || !isOpen()) goto FAIL;
 
   if (flags_ & F_FILE_DIR_DIRTY) {
-    dir_t* d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
+    dir_t *d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
     // check for deleted by another open file object
     if (!d || d->name[0] == DIR_NAME_DELETED) goto FAIL;
 
@@ -1537,7 +1537,7 @@ bool SdBaseFile::sync() {
  * \return true for success, false for failure.
  */
 bool SdBaseFile::timestamp(SdBaseFile* file) {
-  dir_t* d;
+  dir_t *d;
   dir_t dir;
 
   // get timestamps
@@ -1599,7 +1599,7 @@ bool SdBaseFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
   if (ENABLED(SDCARD_READONLY)) return false;
 
   uint16_t dirDate, dirTime;
-  dir_t* d;
+  dir_t *d;
 
   if (!isOpen()
       || year < 1980
@@ -1716,7 +1716,7 @@ int16_t SdBaseFile::write(const void* buf, uint16_t nbyte) {
   #endif
 
   // convert void* to uint8_t*  -  must be before goto statements
-  const uint8_t* src = reinterpret_cast<const uint8_t*>(buf);
+  const uint8_t *src = reinterpret_cast<const uint8_t*>(buf);
 
   // number of bytes left to write  -  must be before goto statements
   uint16_t nToWrite = nbyte;
@@ -1782,7 +1782,7 @@ int16_t SdBaseFile::write(const void* buf, uint16_t nbyte) {
         // rewrite part of block
         if (!vol_->cacheRawBlock(block, SdVolume::CACHE_FOR_WRITE)) goto FAIL;
       }
-      uint8_t* dst = vol_->cache()->data + blockOffset;
+      uint8_t *dst = vol_->cache()->data + blockOffset;
       memcpy(dst, src, n);
     }
     curPosition_ += n;

commit e7c711996bd3080f5e343eff5556736cbf2e2416
Author: X-Ryl669 <boite.pour.spam@gmail.com>
Date:   Mon Feb 8 07:37:24 2021 +0100

    Serial refactor. Default 8-bit ECHO to int, not char (#20985)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index 7693c52330..3cd88318ff 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -926,7 +926,7 @@ int SdBaseFile::peek() {
 // print uint8_t with width 2
 static void print2u(const uint8_t v) {
   if (v < 10) SERIAL_CHAR('0');
-  SERIAL_ECHO((int)v);
+  SERIAL_ECHO(v);
 }
 
 /**

commit 27366197f3380627af365b005702bbe16393a18a
Author: X-Ryl669 <boite.pour.spam@gmail.com>
Date:   Mon Feb 1 00:21:27 2021 +0100

    Serial refactor followup (#20932)

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index 270053be3e..7693c52330 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -926,7 +926,7 @@ int SdBaseFile::peek() {
 // print uint8_t with width 2
 static void print2u(const uint8_t v) {
   if (v < 10) SERIAL_CHAR('0');
-  SERIAL_ECHO(int(v));
+  SERIAL_ECHO((int)v);
 }
 
 /**

commit 35c1b330ec62e698a455176330e7d75600af461d
Author: MKS-Sean <56996910+MKS-Sean@users.noreply.github.com>
Date:   Thu Jan 14 12:41:09 2021 +0800

    MKS WiFi for TFT_LVGL_UI (#20191)

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index 47875a08b1..270053be3e 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -401,8 +401,8 @@ bool SdBaseFile::make83Name(const char* str, uint8_t* name, const char** ptr) {
       // Fail for illegal characters
       PGM_P p = PSTR("|<>^+=?/[];,*\"\\");
       while (uint8_t b = pgm_read_byte(p++)) if (b == c) return false;
-      if (i > n || c < 0x21 || c == 0x7F) return false;           // Check size, non-printable characters
-      name[i++] = (c < 'a' || c > 'z') ? (c) : (c + ('A' - 'a')); // Uppercase required for 8.3 name
+      if (i > n || c < 0x21 || c == 0x7F) return false;       // Check size, non-printable characters
+      name[i++] = c + (WITHIN(c, 'a', 'z') ? 'A' - 'a' : 0);  // Uppercase required for 8.3 name
     }
   }
   *ptr = str;                         // Set passed pointer to the end

commit 6af6a35d9d5b1af8cb12002fd71e986f625920ae
Author: LinFor <linfor@gmail.com>
Date:   Wed Dec 23 09:51:59 2020 +0300

    FTDI EVE: Cyrillic font, some minor fixes (#20517)

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index db2a9e2de9..47875a08b1 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -1077,7 +1077,7 @@ int8_t SdBaseFile::readDir(dir_t* dir, char* longFilename) {
 
   // If we have a longFilename buffer, mark it as invalid.
   // If a long filename is found it will be filled automatically.
-  if (longFilename) longFilename[0] = '\0';
+  if (longFilename) { longFilename[0] = '\0'; longFilename[1] = '\0'; }
 
   while (1) {
 
@@ -1089,7 +1089,7 @@ int8_t SdBaseFile::readDir(dir_t* dir, char* longFilename) {
 
     // skip deleted entry and entry for .  and ..
     if (dir->name[0] == DIR_NAME_DELETED || dir->name[0] == '.') {
-      if (longFilename) longFilename[0] = '\0';     // Invalidate erased file long name, if any
+      if (longFilename) { longFilename[0] = '\0'; longFilename[1] = '\0'; } // Invalidate erased file long name, if any
       continue;
     }
 

commit 288eb06708b4d92d55bdea107eb06e1255d70c9d
Author: Jason Smith <jason.inet@gmail.com>
Date:   Thu Nov 12 20:26:49 2020 -0800

    UTF longname followup (#20115)

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index acc5ba17f2..db2a9e2de9 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -1109,8 +1109,8 @@ int8_t SdBaseFile::readDir(dir_t* dir, char* longFilename) {
               // We can't reconvert to UTF-8 here as UTF-8 is variable-size encoding, but joining LFN blocks
               // needs static bytes addressing. So here just store full UTF-16LE words to re-convert later.
               uint16_t idx = (n + i) * 2; // This is fixed as FAT LFN always contain UTF-16LE encoding
-              longFilename[idx] = utf16_ch & 0xFF;
-              longFilename[idx+1] = (utf16_ch >> 8) & 0xFF;
+              longFilename[idx]     =  utf16_ch       & 0xFF;
+              longFilename[idx + 1] = (utf16_ch >> 8) & 0xFF;
             #else
               // Replace all multibyte characters to '_'
               longFilename[n + i] = (utf16_ch > 0xFF) ? '_' : (utf16_ch & 0xFF);
@@ -1122,45 +1122,44 @@ int8_t SdBaseFile::readDir(dir_t* dir, char* longFilename) {
       }
     }
 
-    // Return if normal file or subdirectory
+    // Post-process normal file or subdirectory longname, if any
     if (DIR_IS_FILE_OR_SUBDIR(dir)) {
       #if ENABLED(UTF_FILENAME_SUPPORT)
-        // Convert filename from utf-16 to utf-8 as Marlin expects
         #if LONG_FILENAME_CHARSIZE > 2
           // Add warning for developers for currently not supported 3-byte cases (Conversion series of 2-byte
           // codepoints to 3-byte in-place will break the rest of filename)
           #error "Currently filename re-encoding is done in-place. It may break the remaining chars to use 3-byte codepoints."
         #endif
-        uint16_t currentPos = 0;
-        LOOP_L_N(i, (LONG_FILENAME_LENGTH / 2)) {
-          uint16_t idx = i * 2; // This is fixed as FAT LFN always contain UTF-16LE encoding
-
-          uint16_t utf16_ch = longFilename[idx] | (longFilename[idx + 1] << 8);
-          if (0xD800 == (utf16_ch & 0xF800))                                    // Surrogate pair - encode as '_'
-            longFilename[currentPos++] = '_';
-          else if (0 == (utf16_ch & 0xFF80))                                    // Encode as 1-byte utf-8 char
-            longFilename[currentPos++] = utf16_ch & 0x007F;
-          else if (0 == (utf16_ch & 0xF800)) {                                  // Encode as 2-byte utf-8 char
-            longFilename[currentPos++] = 0xC0 | ((utf16_ch >> 6) & 0x1F);
-            longFilename[currentPos++] = 0x80 | (utf16_ch & 0x3F);
-          }
-          else {
-            #if LONG_FILENAME_CHARSIZE > 2                                      // Encode as 3-byte utf-8 char
-              longFilename[currentPos++] = 0xE0 | ((utf16_ch >> 12) & 0x0F);
-              longFilename[currentPos++] = 0xC0 | ((utf16_ch >> 6) & 0x3F);
-              longFilename[currentPos++] = 0xC0 | (utf16_ch & 0x3F);
-            #else                                                               // Encode as '_'
-              longFilename[currentPos++] = '_';
-            #endif
-          }
 
-          if (0 == utf16_ch) break; // End of filename
-        }
-        return currentPos;
-      #else
-        return n;
+        // Is there a long filename to decode?
+        if (longFilename) {
+          // Reset n to the start of the long name
+          n = 0;
+          for (uint16_t idx = 0; idx < (LONG_FILENAME_LENGTH) / 2; idx += 2) {    // idx is fixed since FAT LFN always contains UTF-16LE encoding
+            uint16_t utf16_ch = longFilename[idx] | (longFilename[idx + 1] << 8);
+            if (0xD800 == (utf16_ch & 0xF800))                                    // Surrogate pair - encode as '_'
+              longFilename[n++] = '_';
+            else if (0 == (utf16_ch & 0xFF80))                                    // Encode as 1-byte UTF-8 char
+              longFilename[n++] = utf16_ch & 0x007F;
+            else if (0 == (utf16_ch & 0xF800)) {                                  // Encode as 2-byte UTF-8 char
+              longFilename[n++] = 0xC0 | ((utf16_ch >> 6) & 0x1F);
+              longFilename[n++] = 0x80 | ( utf16_ch       & 0x3F);
+            }
+            else {
+              #if LONG_FILENAME_CHARSIZE > 2                                      // Encode as 3-byte UTF-8 char
+                longFilename[n++] = 0xE0 | ((utf16_ch >> 12) & 0x0F);
+                longFilename[n++] = 0xC0 | ((utf16_ch >>  6) & 0x3F);
+                longFilename[n++] = 0xC0 | ( utf16_ch        & 0x3F);
+              #else                                                               // Encode as '_'
+                longFilename[n++] = '_';
+              #endif
+            }
+            if (0 == utf16_ch) break; // End of filename
+          } // idx
+        } // longFilename
       #endif
-    }
+      return n;
+    } // DIR_IS_FILE_OR_SUBDIR
   }
 }
 

commit 5b9aeb2e5f4abbe152fa4ba5dbb5dd8151d3f6f4
Author: LinFor <linfor@gmail.com>
Date:   Wed Nov 11 23:14:39 2020 +0300

    Handle UTF in long filenames (#20087)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index 46ed9372ab..acc5ba17f2 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -1103,19 +1103,67 @@ int8_t SdBaseFile::readDir(dir_t* dir, char* longFilename) {
         if (WITHIN(seq, 1, MAX_VFAT_ENTRIES)) {
           // TODO: Store the filename checksum to verify if a long-filename-unaware system modified the file table.
           n = (seq - 1) * (FILENAME_LENGTH);
-          LOOP_L_N(i, FILENAME_LENGTH)
-            longFilename[n + i] = (i < 5) ? VFAT->name1[i] : (i < 11) ? VFAT->name2[i - 5] : VFAT->name3[i - 11];
+          LOOP_L_N(i, FILENAME_LENGTH) {
+            uint16_t utf16_ch = (i < 5) ? VFAT->name1[i] : (i < 11) ? VFAT->name2[i - 5] : VFAT->name3[i - 11];
+            #if ENABLED(UTF_FILENAME_SUPPORT)
+              // We can't reconvert to UTF-8 here as UTF-8 is variable-size encoding, but joining LFN blocks
+              // needs static bytes addressing. So here just store full UTF-16LE words to re-convert later.
+              uint16_t idx = (n + i) * 2; // This is fixed as FAT LFN always contain UTF-16LE encoding
+              longFilename[idx] = utf16_ch & 0xFF;
+              longFilename[idx+1] = (utf16_ch >> 8) & 0xFF;
+            #else
+              // Replace all multibyte characters to '_'
+              longFilename[n + i] = (utf16_ch > 0xFF) ? '_' : (utf16_ch & 0xFF);
+            #endif
+          }
           // If this VFAT entry is the last one, add a NUL terminator at the end of the string
-          if (VFAT->sequenceNumber & 0x40) longFilename[n + FILENAME_LENGTH] = '\0';
+          if (VFAT->sequenceNumber & 0x40) longFilename[(n + FILENAME_LENGTH) * LONG_FILENAME_CHARSIZE] = '\0';
         }
       }
     }
+
     // Return if normal file or subdirectory
-    if (DIR_IS_FILE_OR_SUBDIR(dir)) return n;
+    if (DIR_IS_FILE_OR_SUBDIR(dir)) {
+      #if ENABLED(UTF_FILENAME_SUPPORT)
+        // Convert filename from utf-16 to utf-8 as Marlin expects
+        #if LONG_FILENAME_CHARSIZE > 2
+          // Add warning for developers for currently not supported 3-byte cases (Conversion series of 2-byte
+          // codepoints to 3-byte in-place will break the rest of filename)
+          #error "Currently filename re-encoding is done in-place. It may break the remaining chars to use 3-byte codepoints."
+        #endif
+        uint16_t currentPos = 0;
+        LOOP_L_N(i, (LONG_FILENAME_LENGTH / 2)) {
+          uint16_t idx = i * 2; // This is fixed as FAT LFN always contain UTF-16LE encoding
+
+          uint16_t utf16_ch = longFilename[idx] | (longFilename[idx + 1] << 8);
+          if (0xD800 == (utf16_ch & 0xF800))                                    // Surrogate pair - encode as '_'
+            longFilename[currentPos++] = '_';
+          else if (0 == (utf16_ch & 0xFF80))                                    // Encode as 1-byte utf-8 char
+            longFilename[currentPos++] = utf16_ch & 0x007F;
+          else if (0 == (utf16_ch & 0xF800)) {                                  // Encode as 2-byte utf-8 char
+            longFilename[currentPos++] = 0xC0 | ((utf16_ch >> 6) & 0x1F);
+            longFilename[currentPos++] = 0x80 | (utf16_ch & 0x3F);
+          }
+          else {
+            #if LONG_FILENAME_CHARSIZE > 2                                      // Encode as 3-byte utf-8 char
+              longFilename[currentPos++] = 0xE0 | ((utf16_ch >> 12) & 0x0F);
+              longFilename[currentPos++] = 0xC0 | ((utf16_ch >> 6) & 0x3F);
+              longFilename[currentPos++] = 0xC0 | (utf16_ch & 0x3F);
+            #else                                                               // Encode as '_'
+              longFilename[currentPos++] = '_';
+            #endif
+          }
+
+          if (0 == utf16_ch) break; // End of filename
+        }
+        return currentPos;
+      #else
+        return n;
+      #endif
+    }
   }
 }
 
-
 // Read next directory entry into the cache
 // Assumes file is correctly positioned
 dir_t* SdBaseFile::readDirCache() {

commit ec23e37a4a31d12febc06922d3fa68446f58d7fb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Oct 24 17:13:10 2020 -0500

    Clean up comments, USB flash, NULLs

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index 2bc9f96e8c..46ed9372ab 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -21,12 +21,12 @@
  */
 
 #if __GNUC__ > 8
-  // The NXP platform updated GCC from 7.2.1 to 9.2.1
-  // and this new warning apparently can be ignored.
   #pragma GCC diagnostic ignored "-Waddress-of-packed-member"
 #endif
 
 /**
+ * sd/SdBaseFile.cpp
+ *
  * Arduino SdFat Library
  * Copyright (c) 2009 by William Greiman
  *

commit 4424645e04c9e75462d36de8f7a82e67cc9c262e
Author: qwewer0 <57561110+qwewer0@users.noreply.github.com>
Date:   Mon Sep 28 21:53:50 2020 +0200

    Multi-line comments cleanup (#19535)

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index 98d762f10b..2bc9f96e8c 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -154,7 +154,6 @@ bool SdBaseFile::contiguousRange(uint32_t* bgnBlock, uint32_t* endBlock) {
  * an invalid DOS 8.3 file name, the FAT volume has not been initialized,
  * a file is already open, the file already exists, the root
  * directory is full or an I/O error.
- *
  */
 bool SdBaseFile::createContiguous(SdBaseFile* dirFile, const char* path, uint32_t size) {
   if (ENABLED(SDCARD_READONLY)) return false;
@@ -1663,7 +1662,6 @@ bool SdBaseFile::truncate(uint32_t length) {
  * \a nbyte.  If an error occurs, write() returns -1.  Possible errors
  * include write() is called before a file has been opened, write is called
  * for a read-only file, device is full, a corrupt file system or an I/O error.
- *
  */
 int16_t SdBaseFile::write(const void* buf, uint16_t nbyte) {
   #if ENABLED(SDCARD_READONLY)

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index 6e43c9f7c6..98d762f10b 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -16,7 +16,7 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 

commit 801f99edadbf37966f231a8ae4b06fd93ff58cb1
Author: Leandro A. F. Pereira <leandro@hardinfo.org>
Date:   Sat May 30 21:59:29 2020 -0700

    SDCARD_READONLY (#17884)

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index 27c191a6a6..6e43c9f7c6 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -47,6 +47,8 @@ void (*SdBaseFile::dateTime_)(uint16_t* date, uint16_t* time) = 0;
 
 // add a cluster to a file
 bool SdBaseFile::addCluster() {
+  if (ENABLED(SDCARD_READONLY)) return false;
+
   if (!vol_->allocContiguous(1, &curCluster_)) return false;
 
   // if first cluster of file link to directory entry
@@ -60,6 +62,8 @@ bool SdBaseFile::addCluster() {
 // Add a cluster to a directory file and zero the cluster.
 // return with first block of cluster in the cache
 bool SdBaseFile::addDirCluster() {
+  if (ENABLED(SDCARD_READONLY)) return false;
+
   uint32_t block;
   // max folder size
   if (fileSize_ / sizeof(dir_t) >= 0xFFFF) return false;
@@ -153,6 +157,8 @@ bool SdBaseFile::contiguousRange(uint32_t* bgnBlock, uint32_t* endBlock) {
  *
  */
 bool SdBaseFile::createContiguous(SdBaseFile* dirFile, const char* path, uint32_t size) {
+  if (ENABLED(SDCARD_READONLY)) return false;
+
   uint32_t count;
   // don't allow zero length file
   if (size == 0) return false;
@@ -419,6 +425,8 @@ bool SdBaseFile::make83Name(const char* str, uint8_t* name, const char** ptr) {
  * directory, \a path is invalid or already exists in \a parent.
  */
 bool SdBaseFile::mkdir(SdBaseFile* parent, const char* path, bool pFlag) {
+  if (ENABLED(SDCARD_READONLY)) return false;
+
   uint8_t dname[11];
   SdBaseFile dir1, dir2;
   SdBaseFile* sub = &dir1;
@@ -449,6 +457,8 @@ bool SdBaseFile::mkdir(SdBaseFile* parent, const char* path, bool pFlag) {
 }
 
 bool SdBaseFile::mkdir(SdBaseFile* parent, const uint8_t dname[11]) {
+  if (ENABLED(SDCARD_READONLY)) return false;
+
   uint32_t block;
   dir_t d;
   dir_t* p;
@@ -632,7 +642,7 @@ bool SdBaseFile::open(SdBaseFile* dirFile, const uint8_t dname[11], uint8_t ofla
   }
   else {
     // don't create unless O_CREAT and O_WRITE
-    if (!(oflag & O_CREAT) || !(oflag & O_WRITE)) return false;
+    if ((oflag & (O_CREAT | O_WRITE)) != (O_CREAT | O_WRITE)) return false;
     if (emptyFound) {
       index = dirIndex_;
       p = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
@@ -716,8 +726,14 @@ bool SdBaseFile::open(SdBaseFile* dirFile, uint16_t index, uint8_t oflag) {
 
 // open a cached directory entry. Assumes vol_ is initialized
 bool SdBaseFile::openCachedEntry(uint8_t dirIndex, uint8_t oflag) {
+  dir_t* p;
+
+  #if ENABLED(SDCARD_READONLY)
+    if (oflag & (O_WRITE | O_CREAT | O_TRUNC)) goto FAIL;
+  #endif
+
   // location of entry in cache
-  dir_t* p = &vol_->cache()->dir[dirIndex];
+  p = &vol_->cache()->dir[dirIndex];
 
   // write or truncate is an error for a directory or read-only file
   if (p->attributes & (DIR_ATT_READ_ONLY | DIR_ATT_DIRECTORY)) {
@@ -1135,6 +1151,8 @@ dir_t* SdBaseFile::readDirCache() {
  * or an I/O error occurred.
  */
 bool SdBaseFile::remove() {
+  if (ENABLED(SDCARD_READONLY)) return false;
+
   dir_t* d;
   // free any clusters - will fail if read-only or directory
   if (!truncate(0)) return false;
@@ -1172,6 +1190,8 @@ bool SdBaseFile::remove() {
  * or an I/O error occurred.
  */
 bool SdBaseFile::remove(SdBaseFile* dirFile, const char* path) {
+  if (ENABLED(SDCARD_READONLY)) return false;
+
   SdBaseFile file;
   return file.open(dirFile, path, O_WRITE) ? file.remove() : false;
 }
@@ -1187,6 +1207,8 @@ bool SdBaseFile::remove(SdBaseFile* dirFile, const char* path) {
  * file, newPath is invalid or already exists, or an I/O error occurs.
  */
 bool SdBaseFile::rename(SdBaseFile* dirFile, const char* newPath) {
+  if (ENABLED(SDCARD_READONLY)) return false;
+
   dir_t entry;
   uint32_t dirCluster = 0;
   SdBaseFile file;
@@ -1279,6 +1301,8 @@ restore:
  * directory, is not empty, or an I/O error occurred.
  */
 bool SdBaseFile::rmdir() {
+  if (ENABLED(SDCARD_READONLY)) return false;
+
   // must be open subdirectory
   if (!isSubDir()) return false;
 
@@ -1317,6 +1341,8 @@ bool SdBaseFile::rmdir() {
  * \return true for success, false for failure.
  */
 bool SdBaseFile::rmRfStar() {
+  if (ENABLED(SDCARD_READONLY)) return false;
+
   uint32_t index;
   SdBaseFile f;
   rewind();
@@ -1424,7 +1450,7 @@ void SdBaseFile::setpos(filepos_t* pos) {
  */
 bool SdBaseFile::sync() {
   // only allow open files and directories
-  if (!isOpen()) goto FAIL;
+  if (ENABLED(SDCARD_READONLY) || !isOpen()) goto FAIL;
 
   if (flags_ & F_FILE_DIR_DIRTY) {
     dir_t* d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
@@ -1524,6 +1550,8 @@ bool SdBaseFile::timestamp(SdBaseFile* file) {
  */
 bool SdBaseFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                            uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
+  if (ENABLED(SDCARD_READONLY)) return false;
+
   uint16_t dirDate, dirTime;
   dir_t* d;
 
@@ -1575,6 +1603,8 @@ bool SdBaseFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
  * \a length is greater than the current file size or an I/O error occurs.
  */
 bool SdBaseFile::truncate(uint32_t length) {
+  if (ENABLED(SDCARD_READONLY)) return false;
+
   uint32_t newPos;
   // error if not a normal file or read-only
   if (!isFile() || !(flags_ & O_WRITE)) return false;
@@ -1636,6 +1666,10 @@ bool SdBaseFile::truncate(uint32_t length) {
  *
  */
 int16_t SdBaseFile::write(const void* buf, uint16_t nbyte) {
+  #if ENABLED(SDCARD_READONLY)
+    writeError = true; return -1;
+  #endif
+
   // convert void* to uint8_t*  -  must be before goto statements
   const uint8_t* src = reinterpret_cast<const uint8_t*>(buf);
 

commit 118bd2f8b2a1f81884cb55a8fc00b708a51aa15b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 13 23:18:16 2020 -0500

    Apply loop shorthand macros (#17159)

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index cdb1072cbe..27c191a6a6 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -204,7 +204,7 @@ bool SdBaseFile::dirEntry(dir_t* dir) {
  */
 void SdBaseFile::dirName(const dir_t& dir, char* name) {
   uint8_t j = 0;
-  for (uint8_t i = 0; i < 11; i++) {
+  LOOP_L_N(i, 11) {
     if (dir.name[i] == ' ')continue;
     if (i == 8) name[j++] = '.';
     name[j++] = dir.name[i];
@@ -345,10 +345,10 @@ int8_t SdBaseFile::lsPrintNext(uint8_t flags, uint8_t indent) {
         && DIR_IS_FILE_OR_SUBDIR(&dir)) break;
   }
   // indent for dir level
-  for (uint8_t i = 0; i < indent; i++) SERIAL_CHAR(' ');
+  LOOP_L_N(i, indent) SERIAL_CHAR(' ');
 
   // print name
-  for (uint8_t i = 0; i < 11; i++) {
+  LOOP_L_N(i, 11) {
     if (dir.name[i] == ' ')continue;
     if (i == 8) {
       SERIAL_CHAR('.');
@@ -478,7 +478,7 @@ bool SdBaseFile::mkdir(SdBaseFile* parent, const uint8_t dname[11]) {
   // make entry for '.'
   memcpy(&d, p, sizeof(d));
   d.name[0] = '.';
-  for (uint8_t i = 1; i < 11; i++) d.name[i] = ' ';
+  LOOP_S_L_N(i, 1, 11) d.name[i] = ' ';
 
   // cache block for '.'  and '..'
   block = vol_->clusterStartBlock(firstCluster_);
@@ -1088,7 +1088,7 @@ int8_t SdBaseFile::readDir(dir_t* dir, char* longFilename) {
         if (WITHIN(seq, 1, MAX_VFAT_ENTRIES)) {
           // TODO: Store the filename checksum to verify if a long-filename-unaware system modified the file table.
           n = (seq - 1) * (FILENAME_LENGTH);
-          for (uint8_t i = 0; i < FILENAME_LENGTH; i++)
+          LOOP_L_N(i, FILENAME_LENGTH)
             longFilename[n + i] = (i < 5) ? VFAT->name1[i] : (i < 11) ? VFAT->name2[i - 5] : VFAT->name3[i - 11];
           // If this VFAT entry is the last one, add a NUL terminator at the end of the string
           if (VFAT->sequenceNumber & 0x40) longFilename[n + FILENAME_LENGTH] = '\0';

commit 1d431fe8d27b3b5c16333793c71408fe0156308b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Feb 22 19:26:52 2020 -0600

    Suppress "packed member" warning

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index 22c0cd2f75..cdb1072cbe 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -20,6 +20,12 @@
  *
  */
 
+#if __GNUC__ > 8
+  // The NXP platform updated GCC from 7.2.1 to 9.2.1
+  // and this new warning apparently can be ignored.
+  #pragma GCC diagnostic ignored "-Waddress-of-packed-member"
+#endif
+
 /**
  * Arduino SdFat Library
  * Copyright (c) 2009 by William Greiman

commit bfad23d3e2e590b257ebe4317d7b14cc2dd3435c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 3 08:00:57 2020 -0600

    (c) 2020

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index 5e3e57f0e0..22c0cd2f75 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -1,6 +1,6 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm

commit d0e1166cce60381fbdad1105d13765806a525d99
Author: Dirk O. Kaar <19971886+dok-net@users.noreply.github.com>
Date:   Fri Jan 3 02:01:38 2020 +0100

    Fix Visual Micro "Arduino IDE for Visual Studio" support (#16418)

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index 2969208838..5e3e57f0e0 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -33,7 +33,7 @@
 
 #include "SdBaseFile.h"
 
-#include "../Marlin.h"
+#include "../MarlinCore.h"
 SdBaseFile* SdBaseFile::cwd_ = 0;   // Pointer to Current Working Directory
 
 // callback function for date/time

commit 15bea5043c13c5958aac691e6e86e2489ca8aba4
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Sat Sep 14 13:42:28 2019 +0200

    Followup to SD menu optimization (#15252)

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index 08eb864095..2969208838 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -273,7 +273,7 @@ int16_t SdBaseFile::fgets(char* str, int16_t num, char* delim) {
  *
  * \return true for success, false for failure.
  */
-bool SdBaseFile::getFilename(char * const name) {
+bool SdBaseFile::getDosName(char * const name) {
   if (!isOpen()) return false;
 
   if (isRoot()) {
@@ -957,7 +957,7 @@ void SdBaseFile::printFatTime(uint16_t fatTime) {
  */
 bool SdBaseFile::printName() {
   char name[FILENAME_LENGTH];
-  if (!getFilename(name)) return false;
+  if (!getDosName(name)) return false;
   SERIAL_ECHO(name);
   return true;
 }

commit 93cd66ac1146603e8a9911fceb3c63f4351f4d8e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 23:57:50 2019 -0500

    Tweaky change from (C) to (c)

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index 7d41e1b88d..08eb864095 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -1,9 +1,9 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -22,7 +22,7 @@
 
 /**
  * Arduino SdFat Library
- * Copyright (C) 2009 by William Greiman
+ * Copyright (c) 2009 by William Greiman
  *
  * This file is part of the Arduino Sd2Card Library
  */

commit ad4ffa1d2fbd17ac09c816ba2052cdf714261042
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 9 11:45:55 2019 -0500

    Use C++ language supported 'nullptr' (#13944)

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index c0e91f85c9..7d41e1b88d 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -81,7 +81,7 @@ bool SdBaseFile::addDirCluster() {
 // cache a file's directory entry
 // return pointer to cached entry or null for failure
 dir_t* SdBaseFile::cacheDirEntry(uint8_t action) {
-  if (!vol_->cacheRawBlock(dirBlock_, action)) return NULL;
+  if (!vol_->cacheRawBlock(dirBlock_, action)) return nullptr;
   return vol_->cache()->dir + dirIndex_;
 }
 
@@ -841,7 +841,7 @@ bool SdBaseFile::openParent(SdBaseFile* dir) {
 
   // search for parent in '../..'
   do {
-    if (file.readDir(&entry, NULL) != 32) return false;
+    if (file.readDir(&entry, nullptr) != 32) return false;
     c = entry.firstClusterLow;
     c |= (uint32_t)entry.firstClusterHigh << 16;
   } while (c != cluster);

commit 0feeef26048883640b37ebe3994730f31ef6e922
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 15:06:53 2019 -0600

    Update copyright in headers

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index 8315f59470..c0e91f85c9 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -1,6 +1,6 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm

commit c98623983774b9773800bc7dcef695c4bad81c0e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Nov 29 16:58:58 2018 -0600

    A single SERIAL_ECHO macro type (#12557)

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index 63e0740f62..8315f59470 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -905,7 +905,7 @@ int SdBaseFile::peek() {
 // print uint8_t with width 2
 static void print2u(const uint8_t v) {
   if (v < 10) SERIAL_CHAR('0');
-  SERIAL_ECHO_F(v, DEC);
+  SERIAL_ECHO(int(v));
 }
 
 /**

commit 8b44745bc75918fec1aae8c57666a50e773499f5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 24 01:18:56 2018 -0500

    Clean up and consolidate SD-related code (#10831)

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index 1cf1e0ad6d..63e0740f62 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -1055,7 +1055,7 @@ int8_t SdBaseFile::readDir(dir_t* dir, char* longFilename) {
   if (!isDir() || (0x1F & curPosition_)) return -1;
 
   // If we have a longFilename buffer, mark it as invalid.
-  // If long filename is found it will be filled automatically.
+  // If a long filename is found it will be filled automatically.
   if (longFilename) longFilename[0] = '\0';
 
   while (1) {
@@ -1725,8 +1725,4 @@ int16_t SdBaseFile::write(const void* buf, uint16_t nbyte) {
   return -1;
 }
 
-#if ALLOW_DEPRECATED_FUNCTIONS
-  void (*SdBaseFile::oldDateTime_)(uint16_t &date, uint16_t &time) = 0;
-#endif
-
 #endif // SDSUPPORT

commit 6d4bc9a1f847d51047814583834c5a4cbfeb2ae6
Author: GMagician <3684609+GMagician@users.noreply.github.com>
Date:   Fri Jan 26 21:03:51 2018 +0100

    [2.0.x] Fix SD wrong filename list (#9342)
    
    If last file in directory has short filename and is preceded by a deleted long file name. SD menu will wrongly report long deleted file name as last entry

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index ddde1d0d1f..1cf1e0ad6d 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -1054,8 +1054,9 @@ int8_t SdBaseFile::readDir(dir_t* dir, char* longFilename) {
   // if not a directory file or miss-positioned return an error
   if (!isDir() || (0x1F & curPosition_)) return -1;
 
-  //If we have a longFilename buffer, mark it as invalid. If we find a long filename it will be filled automaticly.
-  if (longFilename != NULL) longFilename[0] = '\0';
+  // If we have a longFilename buffer, mark it as invalid.
+  // If long filename is found it will be filled automatically.
+  if (longFilename) longFilename[0] = '\0';
 
   while (1) {
 
@@ -1065,12 +1066,15 @@ int8_t SdBaseFile::readDir(dir_t* dir, char* longFilename) {
     // last entry if DIR_NAME_FREE
     if (dir->name[0] == DIR_NAME_FREE) return 0;
 
-    // skip empty entries and entry for .  and ..
-    if (dir->name[0] == DIR_NAME_DELETED || dir->name[0] == '.') continue;
+    // skip deleted entry and entry for .  and ..
+    if (dir->name[0] == DIR_NAME_DELETED || dir->name[0] == '.') {
+      if (longFilename) longFilename[0] = '\0';     // Invalidate erased file long name, if any
+      continue;
+    }
 
     // Fill the long filename if we have a long filename entry.
     // Long filename entries are stored before the short filename.
-    if (longFilename != NULL && DIR_IS_LONG_NAME(dir)) {
+    if (longFilename && DIR_IS_LONG_NAME(dir)) {
       vfat_t* VFAT = (vfat_t*)dir;
       // Sanity-check the VFAT entry. The first cluster is always set to zero. And the sequence number should be higher than 0
       if (VFAT->firstClusterLow == 0) {

commit f7efac57b7ac607405529a71b4e36a6545525c89
Author: Thomas Moore <tcm0116@gmail.com>
Date:   Sun Nov 5 08:49:38 2017 -0600

    Multi-host support

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index b25a7f9f5c..ddde1d0d1f 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -339,38 +339,38 @@ int8_t SdBaseFile::lsPrintNext(uint8_t flags, uint8_t indent) {
         && DIR_IS_FILE_OR_SUBDIR(&dir)) break;
   }
   // indent for dir level
-  for (uint8_t i = 0; i < indent; i++) MYSERIAL.write(' ');
+  for (uint8_t i = 0; i < indent; i++) SERIAL_CHAR(' ');
 
   // print name
   for (uint8_t i = 0; i < 11; i++) {
     if (dir.name[i] == ' ')continue;
     if (i == 8) {
-      MYSERIAL.write('.');
+      SERIAL_CHAR('.');
       w++;
     }
-    MYSERIAL.write(dir.name[i]);
+    SERIAL_CHAR(dir.name[i]);
     w++;
   }
   if (DIR_IS_SUBDIR(&dir)) {
-    MYSERIAL.write('/');
+    SERIAL_CHAR('/');
     w++;
   }
   if (flags & (LS_DATE | LS_SIZE)) {
-    while (w++ < 14) MYSERIAL.write(' ');
+    while (w++ < 14) SERIAL_CHAR(' ');
   }
   // print modify date/time if requested
   if (flags & LS_DATE) {
-    MYSERIAL.write(' ');
+    SERIAL_CHAR(' ');
     printFatDate(dir.lastWriteDate);
-    MYSERIAL.write(' ');
+    SERIAL_CHAR(' ');
     printFatTime(dir.lastWriteTime);
   }
   // print size if requested
   if (!DIR_IS_SUBDIR(&dir) && (flags & LS_SIZE)) {
-    MYSERIAL.write(' ');
-    MYSERIAL.print(dir.fileSize);
+    SERIAL_CHAR(' ');
+    SERIAL_ECHO(dir.fileSize);
   }
-  MYSERIAL.println();
+  SERIAL_EOL();
   return DIR_IS_FILE(&dir) ? 1 : 2;
 }
 
@@ -902,11 +902,10 @@ int SdBaseFile::peek() {
   return c;
 }
 
-
 // print uint8_t with width 2
-static void print2u(uint8_t v) {
-  if (v < 10) MYSERIAL.write('0');
-  MYSERIAL.print(v, DEC);
+static void print2u(const uint8_t v) {
+  if (v < 10) SERIAL_CHAR('0');
+  SERIAL_ECHO_F(v, DEC);
 }
 
 /**
@@ -927,10 +926,10 @@ static void print2u(uint8_t v) {
  * \param[in] fatDate The date field from a directory entry.
  */
 void SdBaseFile::printFatDate(uint16_t fatDate) {
-  MYSERIAL.print(FAT_YEAR(fatDate));
-  MYSERIAL.write('-');
+  SERIAL_ECHO(FAT_YEAR(fatDate));
+  SERIAL_CHAR('-');
   print2u(FAT_MONTH(fatDate));
-  MYSERIAL.write('-');
+  SERIAL_CHAR('-');
   print2u(FAT_DAY(fatDate));
 }
 
@@ -945,9 +944,9 @@ void SdBaseFile::printFatDate(uint16_t fatDate) {
  */
 void SdBaseFile::printFatTime(uint16_t fatTime) {
   print2u(FAT_HOUR(fatTime));
-  MYSERIAL.write(':');
+  SERIAL_CHAR(':');
   print2u(FAT_MINUTE(fatTime));
-  MYSERIAL.write(':');
+  SERIAL_CHAR(':');
   print2u(FAT_SECOND(fatTime));
 }
 
@@ -959,7 +958,7 @@ void SdBaseFile::printFatTime(uint16_t fatTime) {
 bool SdBaseFile::printName() {
   char name[FILENAME_LENGTH];
   if (!getFilename(name)) return false;
-  MYSERIAL.print(name);
+  SERIAL_ECHO(name);
   return true;
 }
 

commit 8b12371e45356aadf175e02e80c87a3df47ea60c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Dec 15 15:17:52 2017 -0600

    Change some hex case

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index d9eb292e7b..b25a7f9f5c 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -601,7 +601,7 @@ bool SdBaseFile::open(SdBaseFile* dirFile, const uint8_t dname[11], uint8_t ofla
   // search for file
 
   while (dirFile->curPosition_ < dirFile->fileSize_) {
-    index = 0XF & (dirFile->curPosition_ >> 5);
+    index = 0xF & (dirFile->curPosition_ >> 5);
     p = dirFile->readDirCache();
     if (!p) return false;
 
@@ -705,7 +705,7 @@ bool SdBaseFile::open(SdBaseFile* dirFile, uint16_t index, uint8_t oflag) {
     return false;
   }
   // open cached entry
-  return openCachedEntry(index & 0XF, oflag);
+  return openCachedEntry(index & 0xF, oflag);
 }
 
 // open a cached directory entry. Assumes vol_ is initialized
@@ -775,7 +775,7 @@ bool SdBaseFile::openNext(SdBaseFile* dirFile, uint8_t oflag) {
   vol_ = dirFile->vol_;
 
   while (1) {
-    index = 0XF & (dirFile->curPosition_ >> 5);
+    index = 0xF & (dirFile->curPosition_ >> 5);
 
     // read entry into cache
     p = dirFile->readDirCache();
@@ -1100,7 +1100,7 @@ dir_t* SdBaseFile::readDirCache() {
   if (!isDir()) return 0;
 
   // index of entry in cache
-  i = (curPosition_ >> 5) & 0XF;
+  i = (curPosition_ >> 5) & 0xF;
 
   // use read to locate and cache block
   if (read() < 0) return 0;

commit b634bfe1b1aca33e3351b344fdd2e79ae093db11
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Nov 26 18:25:00 2017 -0600

    Tweak to readDir code

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index 59e7d200ac..d9eb292e7b 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -1061,7 +1061,7 @@ int8_t SdBaseFile::readDir(dir_t* dir, char* longFilename) {
   while (1) {
 
     n = read(dir, sizeof(dir_t));
-    if (n != sizeof(dir_t)) return n == 0 ? 0 : -1;
+    if (n != sizeof(dir_t)) return n ? -1 : 0;
 
     // last entry if DIR_NAME_FREE
     if (dir->name[0] == DIR_NAME_FREE) return 0;
@@ -1074,13 +1074,16 @@ int8_t SdBaseFile::readDir(dir_t* dir, char* longFilename) {
     if (longFilename != NULL && DIR_IS_LONG_NAME(dir)) {
       vfat_t* VFAT = (vfat_t*)dir;
       // Sanity-check the VFAT entry. The first cluster is always set to zero. And the sequence number should be higher than 0
-      if (VFAT->firstClusterLow == 0 && (VFAT->sequenceNumber & 0x1F) > 0 && (VFAT->sequenceNumber & 0x1F) <= MAX_VFAT_ENTRIES) {
-        // TODO: Store the filename checksum to verify if a long-filename-unaware system modified the file table.
-        n = ((VFAT->sequenceNumber & 0x1F) - 1) * (FILENAME_LENGTH);
-        for (uint8_t i = 0; i < FILENAME_LENGTH; i++)
-          longFilename[n + i] = (i < 5) ? VFAT->name1[i] : (i < 11) ? VFAT->name2[i - 5] : VFAT->name3[i - 11];
-        // If this VFAT entry is the last one, add a NUL terminator at the end of the string
-        if (VFAT->sequenceNumber & 0x40) longFilename[n + FILENAME_LENGTH] = '\0';
+      if (VFAT->firstClusterLow == 0) {
+        const uint8_t seq = VFAT->sequenceNumber & 0x1F;
+        if (WITHIN(seq, 1, MAX_VFAT_ENTRIES)) {
+          // TODO: Store the filename checksum to verify if a long-filename-unaware system modified the file table.
+          n = (seq - 1) * (FILENAME_LENGTH);
+          for (uint8_t i = 0; i < FILENAME_LENGTH; i++)
+            longFilename[n + i] = (i < 5) ? VFAT->name1[i] : (i < 11) ? VFAT->name2[i - 5] : VFAT->name3[i - 11];
+          // If this VFAT entry is the last one, add a NUL terminator at the end of the string
+          if (VFAT->sequenceNumber & 0x40) longFilename[n + FILENAME_LENGTH] = '\0';
+        }
       }
     }
     // Return if normal file or subdirectory

commit 9f8b4c5ee858e80a48c35fcf6112f92dee58df79
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Nov 15 00:06:20 2017 -0600

    Patch SD lib files for readability

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index b6d98542e8..59e7d200ac 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -34,16 +34,14 @@
 #include "SdBaseFile.h"
 
 #include "../Marlin.h"
+SdBaseFile* SdBaseFile::cwd_ = 0;   // Pointer to Current Working Directory
 
-//------------------------------------------------------------------------------
-// pointer to cwd directory
-SdBaseFile* SdBaseFile::cwd_ = 0;
 // callback function for date/time
 void (*SdBaseFile::dateTime_)(uint16_t* date, uint16_t* time) = 0;
-//------------------------------------------------------------------------------
+
 // add a cluster to a file
 bool SdBaseFile::addCluster() {
-  if (!vol_->allocContiguous(1, &curCluster_)) goto FAIL;
+  if (!vol_->allocContiguous(1, &curCluster_)) return false;
 
   // if first cluster of file link to directory entry
   if (firstCluster_ == 0) {
@@ -51,20 +49,17 @@ bool SdBaseFile::addCluster() {
     flags_ |= F_FILE_DIR_DIRTY;
   }
   return true;
-
-  FAIL:
-  return false;
 }
-//------------------------------------------------------------------------------
+
 // Add a cluster to a directory file and zero the cluster.
 // return with first block of cluster in the cache
 bool SdBaseFile::addDirCluster() {
   uint32_t block;
   // max folder size
-  if (fileSize_ / sizeof(dir_t) >= 0xFFFF) goto FAIL;
+  if (fileSize_ / sizeof(dir_t) >= 0xFFFF) return false;
 
-  if (!addCluster()) goto FAIL;
-  if (!vol_->cacheFlush()) goto FAIL;
+  if (!addCluster()) return false;
+  if (!vol_->cacheFlush()) return false;
 
   block = vol_->clusterStartBlock(curCluster_);
 
@@ -76,29 +71,25 @@ bool SdBaseFile::addDirCluster() {
 
   // zero rest of cluster
   for (uint8_t i = 1; i < vol_->blocksPerCluster_; i++) {
-    if (!vol_->writeBlock(block + i, vol_->cacheBuffer_.data)) goto FAIL;
+    if (!vol_->writeBlock(block + i, vol_->cacheBuffer_.data)) return false;
   }
   // Increase directory file size by cluster size
   fileSize_ += 512UL << vol_->clusterSizeShift_;
   return true;
-  FAIL:
-  return false;
 }
-//------------------------------------------------------------------------------
+
 // cache a file's directory entry
 // return pointer to cached entry or null for failure
 dir_t* SdBaseFile::cacheDirEntry(uint8_t action) {
-  if (!vol_->cacheRawBlock(dirBlock_, action)) goto FAIL;
+  if (!vol_->cacheRawBlock(dirBlock_, action)) return NULL;
   return vol_->cache()->dir + dirIndex_;
-  FAIL:
-  return 0;
 }
-//------------------------------------------------------------------------------
-/** Close a file and force cached data and directory information
+
+/**
+ * Close a file and force cached data and directory information
  *  to be written to the storage device.
  *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
+ * \return true for success, false for failure.
  * Reasons for failure include no file is open or an I/O error.
  */
 bool SdBaseFile::close() {
@@ -106,41 +97,40 @@ bool SdBaseFile::close() {
   type_ = FAT_FILE_TYPE_CLOSED;
   return rtn;
 }
-//------------------------------------------------------------------------------
-/** Check for contiguous file and return its raw block range.
+
+/**
+ * Check for contiguous file and return its raw block range.
  *
  * \param[out] bgnBlock the first block address for the file.
  * \param[out] endBlock the last  block address for the file.
  *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
+ * \return true for success, false for failure.
  * Reasons for failure include file is not contiguous, file has zero length
  * or an I/O error occurred.
  */
 bool SdBaseFile::contiguousRange(uint32_t* bgnBlock, uint32_t* endBlock) {
   // error if no blocks
-  if (firstCluster_ == 0) goto FAIL;
+  if (firstCluster_ == 0) return false;
 
   for (uint32_t c = firstCluster_; ; c++) {
     uint32_t next;
-    if (!vol_->fatGet(c, &next)) goto FAIL;
+    if (!vol_->fatGet(c, &next)) return false;
 
     // check for contiguous
     if (next != (c + 1)) {
       // error if not end of chain
-      if (!vol_->isEOC(next)) goto FAIL;
+      if (!vol_->isEOC(next)) return false;
       *bgnBlock = vol_->clusterStartBlock(firstCluster_);
       *endBlock = vol_->clusterStartBlock(c)
                   + vol_->blocksPerCluster_ - 1;
       return true;
     }
   }
-
-  FAIL:
   return false;
 }
-//------------------------------------------------------------------------------
-/** Create and open a new contiguous file of a specified size.
+
+/**
+ * Create and open a new contiguous file of a specified size.
  *
  * \note This function only supports short DOS 8.3 names.
  * See open() for more information.
@@ -149,20 +139,18 @@ bool SdBaseFile::contiguousRange(uint32_t* bgnBlock, uint32_t* endBlock) {
  * \param[in] path A path with a valid DOS 8.3 file name.
  * \param[in] size The desired file size.
  *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
+ * \return true for success, false for failure.
  * Reasons for failure include \a path contains
  * an invalid DOS 8.3 file name, the FAT volume has not been initialized,
  * a file is already open, the file already exists, the root
  * directory is full or an I/O error.
  *
  */
-bool SdBaseFile::createContiguous(SdBaseFile* dirFile,
-                                  const char* path, uint32_t size) {
+bool SdBaseFile::createContiguous(SdBaseFile* dirFile, const char* path, uint32_t size) {
   uint32_t count;
   // don't allow zero length file
-  if (size == 0) goto FAIL;
-  if (!open(dirFile, path, O_CREAT | O_EXCL | O_RDWR)) goto FAIL;
+  if (size == 0) return false;
+  if (!open(dirFile, path, O_CREAT | O_EXCL | O_RDWR)) return false;
 
   // calculate number of clusters needed
   count = ((size - 1) >> (vol_->clusterSizeShift_ + 9)) + 1;
@@ -170,7 +158,7 @@ bool SdBaseFile::createContiguous(SdBaseFile* dirFile,
   // allocate clusters
   if (!vol_->allocContiguous(count, &firstCluster_)) {
     remove();
-    goto FAIL;
+    return false;
   }
   fileSize_ = size;
 
@@ -178,34 +166,31 @@ bool SdBaseFile::createContiguous(SdBaseFile* dirFile,
   flags_ |= F_FILE_DIR_DIRTY;
 
   return sync();
-  FAIL:
-  return false;
 }
-//------------------------------------------------------------------------------
-/** Return a file's directory entry.
+
+/**
+ * Return a file's directory entry.
  *
  * \param[out] dir Location for return of the file's directory entry.
  *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
+ * \return true for success, false for failure.
  */
 bool SdBaseFile::dirEntry(dir_t* dir) {
   dir_t* p;
   // make sure fields on SD are correct
-  if (!sync()) goto FAIL;
+  if (!sync()) return false;
 
   // read entry
   p = cacheDirEntry(SdVolume::CACHE_FOR_READ);
-  if (!p) goto FAIL;
+  if (!p) return false;
 
   // copy to caller's struct
   memcpy(dir, p, sizeof(dir_t));
   return true;
-  FAIL:
-  return false;
 }
-//------------------------------------------------------------------------------
-/** Format the name field of \a dir into the 13 byte array
+
+/**
+ * Format the name field of \a dir into the 13 byte array
  * \a name in standard 8.3 short name format.
  *
  * \param[in] dir The directory structure containing the name.
@@ -220,8 +205,9 @@ void SdBaseFile::dirName(const dir_t& dir, char* name) {
   }
   name[j] = 0;
 }
-//------------------------------------------------------------------------------
-/** Test for the existence of a file in a directory
+
+/**
+ * Test for the existence of a file in a directory
  *
  * \param[in] name Name of the file to be tested for.
  *
@@ -236,7 +222,7 @@ bool SdBaseFile::exists(const char* name) {
   SdBaseFile file;
   return file.open(this, name, O_READ);
 }
-//------------------------------------------------------------------------------
+
 /**
  * Get a string from a file.
  *
@@ -279,15 +265,15 @@ int16_t SdBaseFile::fgets(char* str, int16_t num, char* delim) {
   str[n] = '\0';
   return n;
 }
-//------------------------------------------------------------------------------
-/** Get a file's name
+
+/**
+ * Get a file's name
  *
  * \param[out] name An array of 13 characters for the file's name.
  *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
+ * \return true for success, false for failure.
  */
-bool SdBaseFile::getFilename(char* name) {
+bool SdBaseFile::getFilename(char * const name) {
   if (!isOpen()) return false;
 
   if (isRoot()) {
@@ -303,14 +289,14 @@ bool SdBaseFile::getFilename(char* name) {
   dirName(*p, name);
   return true;
 }
-//------------------------------------------------------------------------------
+
 void SdBaseFile::getpos(filepos_t* pos) {
   pos->position = curPosition_;
   pos->cluster = curCluster_;
 }
 
-//------------------------------------------------------------------------------
-/** List directory contents.
+/**
+ * List directory contents.
  *
  * \param[in] pr Print stream for list.
  *
@@ -337,7 +323,7 @@ void SdBaseFile::ls(uint8_t flags, uint8_t indent) {
     }
   }
 }
-//------------------------------------------------------------------------------
+
 // saves 32 bytes on stack for ls recursion
 // return 0 - EOF, 1 - normal file, or 2 - directory
 int8_t SdBaseFile::lsPrintNext(uint8_t flags, uint8_t indent) {
@@ -387,41 +373,33 @@ int8_t SdBaseFile::lsPrintNext(uint8_t flags, uint8_t indent) {
   MYSERIAL.println();
   return DIR_IS_FILE(&dir) ? 1 : 2;
 }
-//------------------------------------------------------------------------------
-// format directory name field from a 8.3 name string
+
+// Format directory name field from a 8.3 name string
 bool SdBaseFile::make83Name(const char* str, uint8_t* name, const char** ptr) {
-  uint8_t c;
-  uint8_t n = 7;  // max index for part before dot
-  uint8_t i = 0;
-  // blank fill name and extension
-  while (i < 11) name[i++] = ' ';
-  i = 0;
-  while (*str != '\0' && *str != '/') {
-    c = *str++;
-    if (c == '.') {
-      if (n == 10) goto FAIL;  // only one dot allowed
-      n = 10;  // max index for full 8.3 name
-      i = 8;   // place for extension
+  uint8_t n = 7,                      // Max index until a dot is found
+          i = 11;
+  while (i) name[--i] = ' ';          // Set whole FILENAME.EXT to spaces
+  while (*str && *str != '/') {       // For each character, until nul or '/'
+    uint8_t c = *str++;               // Get char and advance
+    if (c == '.') {                   // For a dot...
+      if (n == 10) return false;      // Already moved the max index? fail!
+      n = 10;                         // Move the max index for full 8.3 name
+      i = 8;                          // Move up to the extension place
     }
     else {
-      // illegal FAT characters
+      // Fail for illegal characters
       PGM_P p = PSTR("|<>^+=?/[];,*\"\\");
-      uint8_t b;
-      while ((b = pgm_read_byte(p++))) if (b == c) goto FAIL;
-      // check size and only allow ASCII printable characters
-      if (i > n || c < 0x21 || c == 0x7F) goto FAIL;
-      // only upper case allowed in 8.3 names - convert lower to upper
-      name[i++] = (c < 'a' || c > 'z') ? (c) : (c + ('A' - 'a'));
+      while (uint8_t b = pgm_read_byte(p++)) if (b == c) return false;
+      if (i > n || c < 0x21 || c == 0x7F) return false;           // Check size, non-printable characters
+      name[i++] = (c < 'a' || c > 'z') ? (c) : (c + ('A' - 'a')); // Uppercase required for 8.3 name
     }
   }
-  *ptr = str;
-  // must have a file name, extension is optional
-  return name[0] != ' ';
-  FAIL:
-  return false;
+  *ptr = str;                         // Set passed pointer to the end
+  return name[0] != ' ';              // Return true if any name was set
 }
-//------------------------------------------------------------------------------
-/** Make a new directory.
+
+/**
+ * Make a new directory.
  *
  * \param[in] parent An open SdFat instance for the directory that will contain
  * the new directory.
@@ -430,8 +408,7 @@ bool SdBaseFile::make83Name(const char* str, uint8_t* name, const char** ptr) {
  *
  * \param[in] pFlag Create missing parent directories if true.
  *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
+ * \return true for success, false for failure.
  * Reasons for failure include this file is already open, \a parent is not a
  * directory, \a path is invalid or already exists in \a parent.
  */
@@ -441,56 +418,53 @@ bool SdBaseFile::mkdir(SdBaseFile* parent, const char* path, bool pFlag) {
   SdBaseFile* sub = &dir1;
   SdBaseFile* start = parent;
 
-  if (!parent || isOpen()) goto FAIL;
+  if (!parent || isOpen()) return false;
 
   if (*path == '/') {
     while (*path == '/') path++;
     if (!parent->isRoot()) {
-      if (!dir2.openRoot(parent->vol_)) goto FAIL;
+      if (!dir2.openRoot(parent->vol_)) return false;
       parent = &dir2;
     }
   }
   while (1) {
-    if (!make83Name(path, dname, &path)) goto FAIL;
+    if (!make83Name(path, dname, &path)) return false;
     while (*path == '/') path++;
     if (!*path) break;
     if (!sub->open(parent, dname, O_READ)) {
-      if (!pFlag || !sub->mkdir(parent, dname)) {
-        goto FAIL;
-      }
+      if (!pFlag || !sub->mkdir(parent, dname))
+        return false;
     }
     if (parent != start) parent->close();
     parent = sub;
     sub = parent != &dir1 ? &dir1 : &dir2;
   }
   return mkdir(parent, dname);
-  FAIL:
-  return false;
 }
-//------------------------------------------------------------------------------
+
 bool SdBaseFile::mkdir(SdBaseFile* parent, const uint8_t dname[11]) {
   uint32_t block;
   dir_t d;
   dir_t* p;
 
-  if (!parent->isDir()) goto FAIL;
+  if (!parent->isDir()) return false;
 
   // create a normal file
-  if (!open(parent, dname, O_CREAT | O_EXCL | O_RDWR)) goto FAIL;
+  if (!open(parent, dname, O_CREAT | O_EXCL | O_RDWR)) return false;
 
   // convert file to directory
   flags_ = O_READ;
   type_ = FAT_FILE_TYPE_SUBDIR;
 
   // allocate and zero first cluster
-  if (!addDirCluster())goto FAIL;
+  if (!addDirCluster()) return false;
 
   // force entry to SD
-  if (!sync()) goto FAIL;
+  if (!sync()) return false;
 
   // cache entry - should already be in cache due to sync() call
   p = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
-  if (!p) goto FAIL;
+  if (!p) return false;
 
   // change directory entry  attribute
   p->attributes = DIR_ATT_DIRECTORY;
@@ -502,7 +476,7 @@ bool SdBaseFile::mkdir(SdBaseFile* parent, const uint8_t dname[11]) {
 
   // cache block for '.'  and '..'
   block = vol_->clusterStartBlock(firstCluster_);
-  if (!vol_->cacheRawBlock(block, SdVolume::CACHE_FOR_WRITE)) goto FAIL;
+  if (!vol_->cacheRawBlock(block, SdVolume::CACHE_FOR_WRITE)) return false;
 
   // copy '.' to block
   memcpy(&vol_->cache()->dir[0], &d, sizeof(d));
@@ -522,25 +496,24 @@ bool SdBaseFile::mkdir(SdBaseFile* parent, const uint8_t dname[11]) {
 
   // write first block
   return vol_->cacheFlush();
-  FAIL:
-  return false;
 }
-//------------------------------------------------------------------------------
-/** Open a file in the current working directory.
+
+/**
+ * Open a file in the current working directory.
  *
  * \param[in] path A path with a valid 8.3 DOS name for a file to be opened.
  *
  * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive
  * OR of open flags. see SdBaseFile::open(SdBaseFile*, const char*, uint8_t).
  *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
+ * \return true for success, false for failure.
  */
 bool SdBaseFile::open(const char* path, uint8_t oflag) {
   return open(cwd_, path, oflag);
 }
-//------------------------------------------------------------------------------
-/** Open a file or directory by name.
+
+/**
+ * Open a file or directory by name.
  *
  * \param[in] dirFile An open SdFat instance for the directory containing the
  * file to be opened.
@@ -584,8 +557,7 @@ bool SdBaseFile::open(const char* path, uint8_t oflag) {
  * \note Directory files must be opened read only.  Write and truncation is
  * not allowed for directory files.
  *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
+ * \return true for success, false for failure.
  * Reasons for failure include this file is already open, \a dirFile is not
  * a directory, \a path is invalid, the file does not exist
  * or can't be opened in the access mode specified by oflag.
@@ -593,40 +565,33 @@ bool SdBaseFile::open(const char* path, uint8_t oflag) {
 bool SdBaseFile::open(SdBaseFile* dirFile, const char* path, uint8_t oflag) {
   uint8_t dname[11];
   SdBaseFile dir1, dir2;
-  SdBaseFile* parent = dirFile;
-  SdBaseFile* sub = &dir1;
-
-  if (!dirFile) goto FAIL;
+  SdBaseFile *parent = dirFile, *sub = &dir1;
 
-  // error if already open
-  if (isOpen()) goto FAIL;
+  if (!dirFile || isOpen()) return false;
 
-  if (*path == '/') {
-    while (*path == '/') path++;
-    if (!dirFile->isRoot()) {
-      if (!dir2.openRoot(dirFile->vol_)) goto FAIL;
-      parent = &dir2;
+  if (*path == '/') {                                         // Path starts with '/'
+    if (!dirFile->isRoot()) {                                 // Is the passed dirFile the root?
+      if (!dir2.openRoot(dirFile->vol_)) return false;        // Get the root in dir2, if possible
+      parent = &dir2;                                         // Change 'parent' to point at the root dir
     }
+    while (*path == '/') path++;                              // Skip all leading slashes
   }
-  while (1) {
-    if (!make83Name(path, dname, &path)) goto FAIL;
+
+  for (;;) {
+    if (!make83Name(path, dname, &path)) return false;
     while (*path == '/') path++;
     if (!*path) break;
-    if (!sub->open(parent, dname, O_READ)) goto FAIL;
+    if (!sub->open(parent, dname, O_READ)) return false;
     if (parent != dirFile) parent->close();
     parent = sub;
     sub = parent != &dir1 ? &dir1 : &dir2;
   }
   return open(parent, dname, oflag);
-  FAIL:
-  return false;
 }
-//------------------------------------------------------------------------------
+
 // open with filename in dname
-bool SdBaseFile::open(SdBaseFile* dirFile,
-                      const uint8_t dname[11], uint8_t oflag) {
-  bool emptyFound = false;
-  bool fileFound = false;
+bool SdBaseFile::open(SdBaseFile* dirFile, const uint8_t dname[11], uint8_t oflag) {
+  bool emptyFound = false, fileFound = false;
   uint8_t index;
   dir_t* p;
 
@@ -638,7 +603,7 @@ bool SdBaseFile::open(SdBaseFile* dirFile,
   while (dirFile->curPosition_ < dirFile->fileSize_) {
     index = 0XF & (dirFile->curPosition_ >> 5);
     p = dirFile->readDirCache();
-    if (!p) goto FAIL;
+    if (!p) return false;
 
     if (p->name[0] == DIR_NAME_FREE || p->name[0] == DIR_NAME_DELETED) {
       // remember first empty slot
@@ -657,21 +622,21 @@ bool SdBaseFile::open(SdBaseFile* dirFile,
   }
   if (fileFound) {
     // don't open existing file if O_EXCL
-    if (oflag & O_EXCL) goto FAIL;
+    if (oflag & O_EXCL) return false;
   }
   else {
     // don't create unless O_CREAT and O_WRITE
-    if (!(oflag & O_CREAT) || !(oflag & O_WRITE)) goto FAIL;
+    if (!(oflag & O_CREAT) || !(oflag & O_WRITE)) return false;
     if (emptyFound) {
       index = dirIndex_;
       p = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
-      if (!p) goto FAIL;
+      if (!p) return false;
     }
     else {
-      if (dirFile->type_ == FAT_FILE_TYPE_ROOT_FIXED) goto FAIL;
+      if (dirFile->type_ == FAT_FILE_TYPE_ROOT_FIXED) return false;
 
       // add and zero cluster for dirFile - first cluster is in cache for write
-      if (!dirFile->addDirCluster()) goto FAIL;
+      if (!dirFile->addDirCluster()) return false;
 
       // use first entry in cluster
       p = dirFile->vol_->cache()->dir;
@@ -696,15 +661,14 @@ bool SdBaseFile::open(SdBaseFile* dirFile,
     p->lastWriteTime = p->creationTime;
 
     // write entry to SD
-    if (!dirFile->vol_->cacheFlush()) goto FAIL;
+    if (!dirFile->vol_->cacheFlush()) return false;
   }
   // open entry in cache
   return openCachedEntry(index, oflag);
-  FAIL:
-  return false;
 }
-//------------------------------------------------------------------------------
-/** Open a file by index.
+
+/**
+ * Open a file by index.
  *
  * \param[in] dirFile An open SdFat instance for the directory.
  *
@@ -723,29 +687,27 @@ bool SdBaseFile::open(SdBaseFile* dirFile, uint16_t index, uint8_t oflag) {
   vol_ = dirFile->vol_;
 
   // error if already open
-  if (isOpen() || !dirFile) goto FAIL;
+  if (isOpen() || !dirFile) return false;
 
   // don't open existing file if O_EXCL - user call error
-  if (oflag & O_EXCL) goto FAIL;
+  if (oflag & O_EXCL) return false;
 
   // seek to location of entry
-  if (!dirFile->seekSet(32 * index)) goto FAIL;
+  if (!dirFile->seekSet(32 * index)) return false;
 
   // read entry into cache
   p = dirFile->readDirCache();
-  if (!p) goto FAIL;
+  if (!p) return false;
 
   // error if empty slot or '.' or '..'
   if (p->name[0] == DIR_NAME_FREE ||
       p->name[0] == DIR_NAME_DELETED || p->name[0] == '.') {
-    goto FAIL;
+    return false;
   }
   // open cached entry
   return openCachedEntry(index & 0XF, oflag);
-  FAIL:
-  return false;
 }
-//------------------------------------------------------------------------------
+
 // open a cached directory entry. Assumes vol_ is initialized
 bool SdBaseFile::openCachedEntry(uint8_t dirIndex, uint8_t oflag) {
   // location of entry in cache
@@ -772,9 +734,9 @@ bool SdBaseFile::openCachedEntry(uint8_t dirIndex, uint8_t oflag) {
     if (!vol_->chainSize(firstCluster_, &fileSize_)) goto FAIL;
     type_ = FAT_FILE_TYPE_SUBDIR;
   }
-  else {
+  else
     goto FAIL;
-  }
+
   // save open flags for read/write
   flags_ = oflag & F_OFLAG;
 
@@ -783,12 +745,14 @@ bool SdBaseFile::openCachedEntry(uint8_t dirIndex, uint8_t oflag) {
   curPosition_ = 0;
   if ((oflag & O_TRUNC) && !truncate(0)) return false;
   return oflag & O_AT_END ? seekEnd(0) : true;
+
   FAIL:
   type_ = FAT_FILE_TYPE_CLOSED;
   return false;
 }
-//------------------------------------------------------------------------------
-/** Open the next file or subdirectory in a directory.
+
+/**
+ * Open the next file or subdirectory in a directory.
  *
  * \param[in] dirFile An open SdFat instance for the directory containing the
  * file to be opened.
@@ -803,10 +767,10 @@ bool SdBaseFile::openNext(SdBaseFile* dirFile, uint8_t oflag) {
   dir_t* p;
   uint8_t index;
 
-  if (!dirFile) goto FAIL;
+  if (!dirFile) return false;
 
   // error if already open
-  if (isOpen()) goto FAIL;
+  if (isOpen()) return false;
 
   vol_ = dirFile->vol_;
 
@@ -815,10 +779,10 @@ bool SdBaseFile::openNext(SdBaseFile* dirFile, uint8_t oflag) {
 
     // read entry into cache
     p = dirFile->readDirCache();
-    if (!p) goto FAIL;
+    if (!p) return false;
 
     // done if last entry
-    if (p->name[0] == DIR_NAME_FREE) goto FAIL;
+    if (p->name[0] == DIR_NAME_FREE) return false;
 
     // skip empty slot or '.' or '..'
     if (p->name[0] == DIR_NAME_DELETED || p->name[0] == '.') {
@@ -829,16 +793,16 @@ bool SdBaseFile::openNext(SdBaseFile* dirFile, uint8_t oflag) {
       return openCachedEntry(index, oflag);
     }
   }
-  FAIL:
   return false;
 }
-//------------------------------------------------------------------------------
-/** Open a directory's parent directory.
+
+#if 0
+/**
+ * Open a directory's parent directory.
  *
  * \param[in] dir Parent of this directory will be opened.  Must not be root.
  *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
+ * \return true for success, false for failure.
  */
 bool SdBaseFile::openParent(SdBaseFile* dir) {
   dir_t entry;
@@ -848,14 +812,14 @@ bool SdBaseFile::openParent(SdBaseFile* dir) {
   uint32_t cluster;
   uint32_t lbn;
   // error if already open or dir is root or dir is not a directory
-  if (isOpen() || !dir || dir->isRoot() || !dir->isDir()) goto FAIL;
+  if (isOpen() || !dir || dir->isRoot() || !dir->isDir()) return false;
   vol_ = dir->vol_;
   // position to '..'
-  if (!dir->seekSet(32)) goto FAIL;
+  if (!dir->seekSet(32)) return false;
   // read '..' entry
-  if (dir->read(&entry, sizeof(entry)) != 32) goto FAIL;
+  if (dir->read(&entry, sizeof(entry)) != 32) return false;
   // verify it is '..'
-  if (entry.name[0] != '.' || entry.name[1] != '.') goto FAIL;
+  if (entry.name[0] != '.' || entry.name[1] != '.') return false;
   // start cluster for '..'
   cluster = entry.firstClusterLow;
   cluster |= (uint32_t)entry.firstClusterHigh << 16;
@@ -863,43 +827,42 @@ bool SdBaseFile::openParent(SdBaseFile* dir) {
   // start block for '..'
   lbn = vol_->clusterStartBlock(cluster);
   // first block of parent dir
-  if (!vol_->cacheRawBlock(lbn, SdVolume::CACHE_FOR_READ)) {
-    goto FAIL;
-  }
+  if (!vol_->cacheRawBlock(lbn, SdVolume::CACHE_FOR_READ)) return false;
+
   p = &vol_->cacheBuffer_.dir[1];
   // verify name for '../..'
-  if (p->name[0] != '.' || p->name[1] != '.') goto FAIL;
+  if (p->name[0] != '.' || p->name[1] != '.') return false;
   // '..' is pointer to first cluster of parent. open '../..' to find parent
   if (p->firstClusterHigh == 0 && p->firstClusterLow == 0) {
-    if (!file.openRoot(dir->volume())) goto FAIL;
-  }
-  else if (!file.openCachedEntry(1, O_READ)) {
-    goto FAIL;
+    if (!file.openRoot(dir->volume())) return false;
   }
+  else if (!file.openCachedEntry(1, O_READ))
+    return false;
+
   // search for parent in '../..'
   do {
-    if (file.readDir(&entry, NULL) != 32) goto FAIL;
+    if (file.readDir(&entry, NULL) != 32) return false;
     c = entry.firstClusterLow;
     c |= (uint32_t)entry.firstClusterHigh << 16;
   } while (c != cluster);
+
   // open parent
   return open(&file, file.curPosition() / 32 - 1, O_READ);
-  FAIL:
-  return false;
 }
-//------------------------------------------------------------------------------
-/** Open a volume's root directory.
+#endif
+
+/**
+ * Open a volume's root directory.
  *
  * \param[in] vol The FAT volume containing the root directory to be opened.
  *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
+ * \return true for success, false for failure.
  * Reasons for failure include the file is already open, the FAT volume has
  * not been initialized or it a FAT12 volume.
  */
 bool SdBaseFile::openRoot(SdVolume* vol) {
   // error if file is already open
-  if (isOpen()) goto FAIL;
+  if (isOpen()) return false;
 
   if (vol->fatType() == 16 || (FAT12_SUPPORT && vol->fatType() == 12)) {
     type_ = FAT_FILE_TYPE_ROOT_FIXED;
@@ -909,29 +872,25 @@ bool SdBaseFile::openRoot(SdVolume* vol) {
   else if (vol->fatType() == 32) {
     type_ = FAT_FILE_TYPE_ROOT32;
     firstCluster_ = vol->rootDirStart();
-    if (!vol->chainSize(firstCluster_, &fileSize_)) goto FAIL;
+    if (!vol->chainSize(firstCluster_, &fileSize_)) return false;
   }
-  else {
-    // volume is not initialized, invalid, or FAT12 without support
+  else // volume is not initialized, invalid, or FAT12 without support
     return false;
-  }
+
   vol_ = vol;
   // read only
   flags_ = O_READ;
 
   // set to start of file
-  curCluster_ = 0;
-  curPosition_ = 0;
+  curCluster_ = curPosition_ = 0;
 
   // root has no directory entry
-  dirBlock_ = 0;
-  dirIndex_ = 0;
+  dirBlock_ = dirIndex_ = 0;
   return true;
-  FAIL:
-  return false;
 }
-//------------------------------------------------------------------------------
-/** Return the next available byte without consuming it.
+
+/**
+ * Return the next available byte without consuming it.
  *
  * \return The byte if no error and not at eof else -1;
  */
@@ -943,50 +902,24 @@ int SdBaseFile::peek() {
   return c;
 }
 
-//------------------------------------------------------------------------------
-/** %Print the name field of a directory entry in 8.3 format.
- * \param[in] pr Print stream for output.
- * \param[in] dir The directory structure containing the name.
- * \param[in] width Blank fill name if length is less than \a width.
- * \param[in] printSlash Print '/' after directory names if true.
- */
-void SdBaseFile::printDirName(const dir_t& dir,
-                              uint8_t width, bool printSlash) {
-  uint8_t w = 0;
-  for (uint8_t i = 0; i < 11; i++) {
-    if (dir.name[i] == ' ')continue;
-    if (i == 8) {
-      MYSERIAL.write('.');
-      w++;
-    }
-    MYSERIAL.write(dir.name[i]);
-    w++;
-  }
-  if (DIR_IS_SUBDIR(&dir) && printSlash) {
-    MYSERIAL.write('/');
-    w++;
-  }
-  while (w < width) {
-    MYSERIAL.write(' ');
-    w++;
-  }
-}
-//------------------------------------------------------------------------------
+
 // print uint8_t with width 2
 static void print2u(uint8_t v) {
   if (v < 10) MYSERIAL.write('0');
   MYSERIAL.print(v, DEC);
 }
-//------------------------------------------------------------------------------
-/** %Print a directory date field to Serial.
+
+/**
+ * %Print a directory date field to Serial.
  *
  *  Format is yyyy-mm-dd.
  *
  * \param[in] fatDate The date field from a directory entry.
  */
 
-//------------------------------------------------------------------------------
-/** %Print a directory date field.
+
+/**
+ * %Print a directory date field.
  *
  *  Format is yyyy-mm-dd.
  *
@@ -1001,8 +934,9 @@ void SdBaseFile::printFatDate(uint16_t fatDate) {
   print2u(FAT_DAY(fatDate));
 }
 
-//------------------------------------------------------------------------------
-/** %Print a directory time field.
+
+/**
+ * %Print a directory time field.
  *
  * Format is hh:mm:ss.
  *
@@ -1016,11 +950,11 @@ void SdBaseFile::printFatTime(uint16_t fatTime) {
   MYSERIAL.write(':');
   print2u(FAT_SECOND(fatTime));
 }
-//------------------------------------------------------------------------------
-/** Print a file's name to Serial
+
+/**
+ * Print a file's name to Serial
  *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
+ * \return true for success, false for failure.
  */
 bool SdBaseFile::printName() {
   char name[FILENAME_LENGTH];
@@ -1028,8 +962,9 @@ bool SdBaseFile::printName() {
   MYSERIAL.print(name);
   return true;
 }
-//------------------------------------------------------------------------------
-/** Read the next byte from a file.
+
+/**
+ * Read the next byte from a file.
  *
  * \return For success read returns the next byte in the file as an int.
  * If an error occurs or end of file is reached -1 is returned.
@@ -1038,8 +973,9 @@ int16_t SdBaseFile::read() {
   uint8_t b;
   return read(&b, 1) == 1 ? b : -1;
 }
-//------------------------------------------------------------------------------
-/** Read data from a file starting at the current position.
+
+/**
+ * Read data from a file starting at the current position.
  *
  * \param[out] buf Pointer to the location that will receive the data.
  *
@@ -1054,12 +990,11 @@ int16_t SdBaseFile::read() {
  */
 int16_t SdBaseFile::read(void* buf, uint16_t nbyte) {
   uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
-  uint16_t offset;
-  uint16_t toRead;
+  uint16_t offset, toRead;
   uint32_t block;  // raw device block number
 
   // error if not open or write only
-  if (!isOpen() || !(flags_ & O_READ)) goto FAIL;
+  if (!isOpen() || !(flags_ & O_READ)) return -1;
 
   // max bytes left in file
   NOMORE(nbyte, fileSize_ - curPosition_);
@@ -1075,14 +1010,10 @@ int16_t SdBaseFile::read(void* buf, uint16_t nbyte) {
       uint8_t blockOfCluster = vol_->blockOfCluster(curPosition_);
       if (offset == 0 && blockOfCluster == 0) {
         // start of new cluster
-        if (curPosition_ == 0) {
-          // use first cluster in file
-          curCluster_ = firstCluster_;
-        }
-        else {
-          // get next cluster from FAT
-          if (!vol_->fatGet(curCluster_, &curCluster_)) goto FAIL;
-        }
+        if (curPosition_ == 0)
+          curCluster_ = firstCluster_;                      // use first cluster in file
+        else if (!vol_->fatGet(curCluster_, &curCluster_))  // get next cluster from FAT
+          return -1;
       }
       block = vol_->clusterStartBlock(curCluster_) + blockOfCluster;
     }
@@ -1093,11 +1024,11 @@ int16_t SdBaseFile::read(void* buf, uint16_t nbyte) {
 
     // no buffering needed if n == 512
     if (n == 512 && block != vol_->cacheBlockNumber()) {
-      if (!vol_->readBlock(block, dst)) goto FAIL;
+      if (!vol_->readBlock(block, dst)) return -1;
     }
     else {
       // read block to cache and copy data to caller
-      if (!vol_->cacheRawBlock(block, SdVolume::CACHE_FOR_READ)) goto FAIL;
+      if (!vol_->cacheRawBlock(block, SdVolume::CACHE_FOR_READ)) return -1;
       uint8_t* src = vol_->cache()->data + offset;
       memcpy(dst, src, n);
     }
@@ -1106,8 +1037,6 @@ int16_t SdBaseFile::read(void* buf, uint16_t nbyte) {
     toRead -= n;
   }
   return nbyte;
-  FAIL:
-  return -1;
 }
 
 /**
@@ -1159,30 +1088,29 @@ int8_t SdBaseFile::readDir(dir_t* dir, char* longFilename) {
   }
 }
 
-//------------------------------------------------------------------------------
+
 // Read next directory entry into the cache
 // Assumes file is correctly positioned
 dir_t* SdBaseFile::readDirCache() {
   uint8_t i;
   // error if not directory
-  if (!isDir()) goto FAIL;
+  if (!isDir()) return 0;
 
   // index of entry in cache
   i = (curPosition_ >> 5) & 0XF;
 
   // use read to locate and cache block
-  if (read() < 0) goto FAIL;
+  if (read() < 0) return 0;
 
   // advance to next entry
   curPosition_ += 31;
 
   // return pointer to entry
   return vol_->cache()->dir + i;
-  FAIL:
-  return 0;
 }
-//------------------------------------------------------------------------------
-/** Remove a file.
+
+/**
+ * Remove a file.
  *
  * The directory entry and all data for the file are deleted.
  *
@@ -1190,19 +1118,18 @@ dir_t* SdBaseFile::readDirCache() {
  * file that has a long name. For example if a file has the long name
  * "New Text Document.txt" you should not delete the 8.3 name "NEWTEX~1.TXT".
  *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
+ * \return true for success, false for failure.
  * Reasons for failure include the file read-only, is a directory,
  * or an I/O error occurred.
  */
 bool SdBaseFile::remove() {
   dir_t* d;
   // free any clusters - will fail if read-only or directory
-  if (!truncate(0)) goto FAIL;
+  if (!truncate(0)) return false;
 
   // cache directory entry
   d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
-  if (!d) goto FAIL;
+  if (!d) return false;
 
   // mark entry deleted
   d->name[0] = DIR_NAME_DELETED;
@@ -1213,11 +1140,10 @@ bool SdBaseFile::remove() {
   // write entry to SD
   return vol_->cacheFlush();
   return true;
-  FAIL:
-  return false;
 }
-//------------------------------------------------------------------------------
-/** Remove a file.
+
+/**
+ * Remove a file.
  *
  * The directory entry and all data for the file are deleted.
  *
@@ -1228,28 +1154,23 @@ bool SdBaseFile::remove() {
  * file that has a long name. For example if a file has the long name
  * "New Text Document.txt" you should not delete the 8.3 name "NEWTEX~1.TXT".
  *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
+ * \return true for success, false for failure.
  * Reasons for failure include the file is a directory, is read only,
  * \a dirFile is not a directory, \a path is not found
  * or an I/O error occurred.
  */
 bool SdBaseFile::remove(SdBaseFile* dirFile, const char* path) {
   SdBaseFile file;
-  if (!file.open(dirFile, path, O_WRITE)) goto FAIL;
-  return file.remove();
-  FAIL:
-  // can't set iostate - static function
-  return false;
+  return file.open(dirFile, path, O_WRITE) ? file.remove() : false;
 }
-//------------------------------------------------------------------------------
-/** Rename a file or subdirectory.
+
+/**
+ * Rename a file or subdirectory.
  *
  * \param[in] dirFile Directory for the new path.
  * \param[in] newPath New path name for the file/directory.
  *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
+ * \return true for success, false for failure.
  * Reasons for failure include \a dirFile is not open or is not a directory
  * file, newPath is invalid or already exists, or an I/O error occurs.
  */
@@ -1260,15 +1181,15 @@ bool SdBaseFile::rename(SdBaseFile* dirFile, const char* newPath) {
   dir_t* d;
 
   // must be an open file or subdirectory
-  if (!(isFile() || isSubDir())) goto FAIL;
+  if (!(isFile() || isSubDir())) return false;
 
   // can't move file
-  if (vol_ != dirFile->vol_) goto FAIL;
+  if (vol_ != dirFile->vol_) return false;
 
   // sync() and cache directory entry
   sync();
   d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
-  if (!d) goto FAIL;
+  if (!d) return false;
 
   // save directory entry
   memcpy(&entry, d, sizeof(entry));
@@ -1299,7 +1220,7 @@ bool SdBaseFile::rename(SdBaseFile* dirFile, const char* newPath) {
 
   // cache new directory entry
   d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
-  if (!d) goto FAIL;
+  if (!d) return false;
 
   // copy all but name field to new directory entry
   memcpy(&d->attributes, &entry.attributes, sizeof(entry) - sizeof(d->name));
@@ -1308,31 +1229,30 @@ bool SdBaseFile::rename(SdBaseFile* dirFile, const char* newPath) {
   if (dirCluster) {
     // get new dot dot
     uint32_t block = vol_->clusterStartBlock(dirCluster);
-    if (!vol_->cacheRawBlock(block, SdVolume::CACHE_FOR_READ)) goto FAIL;
+    if (!vol_->cacheRawBlock(block, SdVolume::CACHE_FOR_READ)) return false;
     memcpy(&entry, &vol_->cache()->dir[1], sizeof(entry));
 
     // free unused cluster
-    if (!vol_->freeChain(dirCluster)) goto FAIL;
+    if (!vol_->freeChain(dirCluster)) return false;
 
     // store new dot dot
     block = vol_->clusterStartBlock(firstCluster_);
-    if (!vol_->cacheRawBlock(block, SdVolume::CACHE_FOR_WRITE)) goto FAIL;
+    if (!vol_->cacheRawBlock(block, SdVolume::CACHE_FOR_WRITE)) return false;
     memcpy(&vol_->cache()->dir[1], &entry, sizeof(entry));
   }
   return vol_->cacheFlush();
 
 restore:
-  d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
-  if (!d) goto FAIL;
-  // restore entry
-  d->name[0] = entry.name[0];
-  vol_->cacheFlush();
-
-  FAIL:
+  if ((d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE))) {
+    // restore entry
+    d->name[0] = entry.name[0];
+    vol_->cacheFlush();
+  }
   return false;
 }
-//------------------------------------------------------------------------------
-/** Remove a directory file.
+
+/**
+ * Remove a directory file.
  *
  * The directory file will be removed only if it is empty and is not the
  * root directory.  rmdir() follows DOS and Windows and ignores the
@@ -1342,37 +1262,35 @@ restore:
  * directory that has a long name. For example if a directory has the
  * long name "New folder" you should not delete the 8.3 name "NEWFOL~1".
  *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
+ * \return true for success, false for failure.
  * Reasons for failure include the file is not a directory, is the root
  * directory, is not empty, or an I/O error occurred.
  */
 bool SdBaseFile::rmdir() {
   // must be open subdirectory
-  if (!isSubDir()) goto FAIL;
+  if (!isSubDir()) return false;
 
   rewind();
 
   // make sure directory is empty
   while (curPosition_ < fileSize_) {
     dir_t* p = readDirCache();
-    if (!p) goto FAIL;
+    if (!p) return false;
     // done if past last used entry
     if (p->name[0] == DIR_NAME_FREE) break;
     // skip empty slot, '.' or '..'
     if (p->name[0] == DIR_NAME_DELETED || p->name[0] == '.') continue;
     // error not empty
-    if (DIR_IS_FILE_OR_SUBDIR(p)) goto FAIL;
+    if (DIR_IS_FILE_OR_SUBDIR(p)) return false;
   }
   // convert empty directory to normal file for remove
   type_ = FAT_FILE_TYPE_NORMAL;
   flags_ |= O_WRITE;
   return remove();
-  FAIL:
-  return false;
 }
-//------------------------------------------------------------------------------
-/** Recursively delete a directory and all contained files.
+
+/**
+ * Recursively delete a directory and all contained files.
  *
  * This is like the Unix/Linux 'rm -rf *' if called with the root directory
  * hence the name.
@@ -1384,8 +1302,7 @@ bool SdBaseFile::rmdir() {
  * \note This function should not be used to delete the 8.3 version of
  * a directory that has a long name.  See remove() and rmdir().
  *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
+ * \return true for success, false for failure.
  */
 bool SdBaseFile::rmRfStar() {
   uint32_t index;
@@ -1396,7 +1313,7 @@ bool SdBaseFile::rmRfStar() {
     index = curPosition_ / 32;
 
     dir_t* p = readDirCache();
-    if (!p) goto FAIL;
+    if (!p) return false;
 
     // done if past last entry
     if (p->name[0] == DIR_NAME_FREE) break;
@@ -1407,31 +1324,30 @@ bool SdBaseFile::rmRfStar() {
     // skip if part of long file name or volume label in root
     if (!DIR_IS_FILE_OR_SUBDIR(p)) continue;
 
-    if (!f.open(this, index, O_READ)) goto FAIL;
+    if (!f.open(this, index, O_READ)) return false;
     if (f.isSubDir()) {
       // recursively delete
-      if (!f.rmRfStar()) goto FAIL;
+      if (!f.rmRfStar()) return false;
     }
     else {
       // ignore read-only
       f.flags_ |= O_WRITE;
-      if (!f.remove()) goto FAIL;
+      if (!f.remove()) return false;
     }
     // position to next entry if required
     if (curPosition_ != (32 * (index + 1))) {
-      if (!seekSet(32 * (index + 1))) goto FAIL;
+      if (!seekSet(32 * (index + 1))) return false;
     }
   }
   // don't try to delete root
   if (!isRoot()) {
-    if (!rmdir()) goto FAIL;
+    if (!rmdir()) return false;
   }
   return true;
-  FAIL:
-  return false;
 }
-//------------------------------------------------------------------------------
-/**  Create a file object and open it in the current working directory.
+
+/**
+ * Create a file object and open it in the current working directory.
  *
  * \param[in] path A path with a valid 8.3 DOS name for a file to be opened.
  *
@@ -1443,64 +1359,54 @@ SdBaseFile::SdBaseFile(const char* path, uint8_t oflag) {
   writeError = false;
   open(path, oflag);
 }
-//------------------------------------------------------------------------------
-/** Sets a file's position.
+
+/**
+ * Sets a file's position.
  *
  * \param[in] pos The new position in bytes from the beginning of the file.
  *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
+ * \return true for success, false for failure.
  */
-bool SdBaseFile::seekSet(uint32_t pos) {
-  uint32_t nCur;
-  uint32_t nNew;
+bool SdBaseFile::seekSet(const uint32_t pos) {
+  uint32_t nCur, nNew;
   // error if file not open or seek past end of file
-  if (!isOpen() || pos > fileSize_) goto FAIL;
+  if (!isOpen() || pos > fileSize_) return false;
 
   if (type_ == FAT_FILE_TYPE_ROOT_FIXED) {
     curPosition_ = pos;
-    goto done;
+    return true;
   }
   if (pos == 0) {
-    // set position to start of file
-    curCluster_ = 0;
-    curPosition_ = 0;
-    goto done;
+    curCluster_ = curPosition_ = 0;   // set position to start of file
+    return true;
   }
+
   // calculate cluster index for cur and new position
   nCur = (curPosition_ - 1) >> (vol_->clusterSizeShift_ + 9);
   nNew = (pos - 1) >> (vol_->clusterSizeShift_ + 9);
 
-  if (nNew < nCur || curPosition_ == 0) {
-    // must follow chain from first cluster
-    curCluster_ = firstCluster_;
-  }
-  else {
-    // advance from curPosition
-    nNew -= nCur;
-  }
-  while (nNew--) {
-    if (!vol_->fatGet(curCluster_, &curCluster_)) goto FAIL;
-  }
-  curPosition_ = pos;
+  if (nNew < nCur || curPosition_ == 0)
+    curCluster_ = firstCluster_;      // must follow chain from first cluster
+  else
+    nNew -= nCur;                     // advance from curPosition
 
-done:
-  return true;
+  while (nNew--)
+    if (!vol_->fatGet(curCluster_, &curCluster_)) return false;
 
-  FAIL:
-  return false;
+  curPosition_ = pos;
+  return true;
 }
-//------------------------------------------------------------------------------
+
 void SdBaseFile::setpos(filepos_t* pos) {
   curPosition_ = pos->position;
   curCluster_ = pos->cluster;
 }
-//------------------------------------------------------------------------------
-/** The sync() call causes all modified data and directory fields
+
+/**
+ * The sync() call causes all modified data and directory fields
  * to be written to the storage device.
  *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
+ * \return true for success, false for failure.
  * Reasons for failure include a call to sync() before a file has been
  * opened or an I/O error.
  */
@@ -1534,8 +1440,9 @@ bool SdBaseFile::sync() {
   writeError = true;
   return false;
 }
-//------------------------------------------------------------------------------
-/** Copy a file's timestamps
+
+/**
+ * Copy a file's timestamps
  *
  * \param[in] file File to copy timestamps from.
  *
@@ -1543,21 +1450,20 @@ bool SdBaseFile::sync() {
  * Modify and access timestamps may be overwritten if a date time callback
  * function has been set by dateTimeCallback().
  *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
+ * \return true for success, false for failure.
  */
 bool SdBaseFile::timestamp(SdBaseFile* file) {
   dir_t* d;
   dir_t dir;
 
   // get timestamps
-  if (!file->dirEntry(&dir)) goto FAIL;
+  if (!file->dirEntry(&dir)) return false;
 
   // update directory fields
-  if (!sync()) goto FAIL;
+  if (!sync()) return false;
 
   d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
-  if (!d) goto FAIL;
+  if (!d) return false;
 
   // copy timestamps
   d->lastAccessDate = dir.lastAccessDate;
@@ -1569,12 +1475,10 @@ bool SdBaseFile::timestamp(SdBaseFile* file) {
 
   // write back entry
   return vol_->cacheFlush();
-
-  FAIL:
-  return false;
 }
-//------------------------------------------------------------------------------
-/** Set a file's timestamps in its directory entry.
+
+/**
+ * Set a file's timestamps in its directory entry.
  *
  * \param[in] flags Values for \a flags are constructed by a bitwise-inclusive
  * OR of flags from the following list
@@ -1604,13 +1508,11 @@ bool SdBaseFile::timestamp(SdBaseFile* file) {
  * Modify and access timestamps may be overwritten if a date time callback
  * function has been set by dateTimeCallback().
  *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
+ * \return true for success, false for failure.
  */
 bool SdBaseFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
                            uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
-  uint16_t dirDate;
-  uint16_t dirTime;
+  uint16_t dirDate, dirTime;
   dir_t* d;
 
   if (!isOpen()
@@ -1623,13 +1525,13 @@ bool SdBaseFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
       || hour > 23
       || minute > 59
       || second > 59) {
-    goto FAIL;
+    return false;
   }
   // update directory entry
-  if (!sync()) goto FAIL;
+  if (!sync()) return false;
 
   d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
-  if (!d) goto FAIL;
+  if (!d) return false;
 
   dirDate = FAT_DATE(year, month, day);
   dirTime = FAT_TIME(hour, minute, second);
@@ -1647,28 +1549,26 @@ bool SdBaseFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
     d->lastWriteTime = dirTime;
   }
   return vol_->cacheFlush();
-  FAIL:
-  return false;
 }
-//------------------------------------------------------------------------------
-/** Truncate a file to a specified length.  The current file position
+
+/**
+ * Truncate a file to a specified length.  The current file position
  * will be maintained if it is less than or equal to \a length otherwise
  * it will be set to end of file.
  *
  * \param[in] length The desired length for the file.
  *
- * \return The value one, true, is returned for success and
- * the value zero, false, is returned for failure.
+ * \return true for success, false for failure.
  * Reasons for failure include file is read only, file is a directory,
  * \a length is greater than the current file size or an I/O error occurs.
  */
 bool SdBaseFile::truncate(uint32_t length) {
   uint32_t newPos;
   // error if not a normal file or read-only
-  if (!isFile() || !(flags_ & O_WRITE)) goto FAIL;
+  if (!isFile() || !(flags_ & O_WRITE)) return false;
 
   // error if length is greater than current size
-  if (length > fileSize_) goto FAIL;
+  if (length > fileSize_) return false;
 
   // fileSize and length are zero - nothing to do
   if (fileSize_ == 0) return true;
@@ -1677,23 +1577,23 @@ bool SdBaseFile::truncate(uint32_t length) {
   newPos = curPosition_ > length ? length : curPosition_;
 
   // position to last cluster in truncated file
-  if (!seekSet(length)) goto FAIL;
+  if (!seekSet(length)) return false;
 
   if (length == 0) {
     // free all clusters
-    if (!vol_->freeChain(firstCluster_)) goto FAIL;
+    if (!vol_->freeChain(firstCluster_)) return false;
     firstCluster_ = 0;
   }
   else {
     uint32_t toFree;
-    if (!vol_->fatGet(curCluster_, &toFree)) goto FAIL;
+    if (!vol_->fatGet(curCluster_, &toFree)) return false;
 
     if (!vol_->isEOC(toFree)) {
       // free extra clusters
-      if (!vol_->freeChain(toFree)) goto FAIL;
+      if (!vol_->freeChain(toFree)) return false;
 
       // current cluster is end of chain
-      if (!vol_->fatPutEOC(curCluster_)) goto FAIL;
+      if (!vol_->fatPutEOC(curCluster_)) return false;
     }
   }
   fileSize_ = length;
@@ -1701,16 +1601,14 @@ bool SdBaseFile::truncate(uint32_t length) {
   // need to update directory entry
   flags_ |= F_FILE_DIR_DIRTY;
 
-  if (!sync()) goto FAIL;
+  if (!sync()) return false;
 
   // set file to correct position
   return seekSet(newPos);
-
-  FAIL:
-  return false;
 }
-//------------------------------------------------------------------------------
-/** Write data to an open file.
+
+/**
+ * Write data to an open file.
  *
  * \note Data is moved to the cache but may not be written to the
  * storage device until sync() is called.
@@ -1820,10 +1718,9 @@ int16_t SdBaseFile::write(const void* buf, uint16_t nbyte) {
   writeError = true;
   return -1;
 }
-//------------------------------------------------------------------------------
-// suppress cpplint warnings with NOLINT comment
-#if ALLOW_DEPRECATED_FUNCTIONS && !defined(DOXYGEN)
-  void (*SdBaseFile::oldDateTime_)(uint16_t &date, uint16_t &time) = 0;  // NOLINT
-#endif  // ALLOW_DEPRECATED_FUNCTIONS
+
+#if ALLOW_DEPRECATED_FUNCTIONS
+  void (*SdBaseFile::oldDateTime_)(uint16_t &date, uint16_t &time) = 0;
+#endif
 
 #endif // SDSUPPORT

commit 783ddf9691f425dc1c1bd5c4e4df4461ca717a06
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Oct 18 22:15:33 2017 -0500

    Add SCROLL_LONG_FILENAMES option

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index b5356c0674..b6d98542e8 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -1146,7 +1146,7 @@ int8_t SdBaseFile::readDir(dir_t* dir, char* longFilename) {
       vfat_t* VFAT = (vfat_t*)dir;
       // Sanity-check the VFAT entry. The first cluster is always set to zero. And the sequence number should be higher than 0
       if (VFAT->firstClusterLow == 0 && (VFAT->sequenceNumber & 0x1F) > 0 && (VFAT->sequenceNumber & 0x1F) <= MAX_VFAT_ENTRIES) {
-        // TODO: Store the filename checksum to verify if a none-long filename aware system modified the file table.
+        // TODO: Store the filename checksum to verify if a long-filename-unaware system modified the file table.
         n = ((VFAT->sequenceNumber & 0x1F) - 1) * (FILENAME_LENGTH);
         for (uint8_t i = 0; i < FILENAME_LENGTH; i++)
           longFilename[n + i] = (i < 5) ? VFAT->name1[i] : (i < 11) ? VFAT->name2[i - 5] : VFAT->name3[i - 11];

commit 0cb00f52d94773411e405ae10a463a4687b70658
Author: Thomas Moore <tcm0116@gmail.com>
Date:   Sat Sep 30 16:06:43 2017 -0500

    Cleanup warnings

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index d292cdb354..b5356c0674 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -1388,7 +1388,7 @@ bool SdBaseFile::rmdir() {
  * the value zero, false, is returned for failure.
  */
 bool SdBaseFile::rmRfStar() {
-  uint16_t index;
+  uint32_t index;
   SdBaseFile f;
   rewind();
   while (curPosition_ < fileSize_) {

commit 614a86a380cb23a5e22661f71de5bc2e3168bb11
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 6 06:28:32 2017 -0500

    SD file updates

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
index 95fc2b62b6..d292cdb354 100644
--- a/Marlin/src/sd/SdBaseFile.cpp
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -27,10 +27,14 @@
  * This file is part of the Arduino Sd2Card Library
  */
 
-#include "Marlin.h"
+#include "../inc/MarlinConfig.h"
+
 #if ENABLED(SDSUPPORT)
 
 #include "SdBaseFile.h"
+
+#include "../Marlin.h"
+
 //------------------------------------------------------------------------------
 // pointer to cwd directory
 SdBaseFile* SdBaseFile::cwd_ = 0;
@@ -1822,5 +1826,4 @@ int16_t SdBaseFile::write(const void* buf, uint16_t nbyte) {
   void (*SdBaseFile::oldDateTime_)(uint16_t &date, uint16_t &time) = 0;  // NOLINT
 #endif  // ALLOW_DEPRECATED_FUNCTIONS
 
-
-#endif
+#endif // SDSUPPORT

commit b66d65f8657efe2ddecfe4a4c255b2d260671ce1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 6 06:28:31 2017 -0500

    Move 'sd' files

diff --git a/Marlin/src/sd/SdBaseFile.cpp b/Marlin/src/sd/SdBaseFile.cpp
new file mode 100644
index 0000000000..95fc2b62b6
--- /dev/null
+++ b/Marlin/src/sd/SdBaseFile.cpp
@@ -0,0 +1,1826 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * Arduino SdFat Library
+ * Copyright (C) 2009 by William Greiman
+ *
+ * This file is part of the Arduino Sd2Card Library
+ */
+
+#include "Marlin.h"
+#if ENABLED(SDSUPPORT)
+
+#include "SdBaseFile.h"
+//------------------------------------------------------------------------------
+// pointer to cwd directory
+SdBaseFile* SdBaseFile::cwd_ = 0;
+// callback function for date/time
+void (*SdBaseFile::dateTime_)(uint16_t* date, uint16_t* time) = 0;
+//------------------------------------------------------------------------------
+// add a cluster to a file
+bool SdBaseFile::addCluster() {
+  if (!vol_->allocContiguous(1, &curCluster_)) goto FAIL;
+
+  // if first cluster of file link to directory entry
+  if (firstCluster_ == 0) {
+    firstCluster_ = curCluster_;
+    flags_ |= F_FILE_DIR_DIRTY;
+  }
+  return true;
+
+  FAIL:
+  return false;
+}
+//------------------------------------------------------------------------------
+// Add a cluster to a directory file and zero the cluster.
+// return with first block of cluster in the cache
+bool SdBaseFile::addDirCluster() {
+  uint32_t block;
+  // max folder size
+  if (fileSize_ / sizeof(dir_t) >= 0xFFFF) goto FAIL;
+
+  if (!addCluster()) goto FAIL;
+  if (!vol_->cacheFlush()) goto FAIL;
+
+  block = vol_->clusterStartBlock(curCluster_);
+
+  // set cache to first block of cluster
+  vol_->cacheSetBlockNumber(block, true);
+
+  // zero first block of cluster
+  memset(vol_->cacheBuffer_.data, 0, 512);
+
+  // zero rest of cluster
+  for (uint8_t i = 1; i < vol_->blocksPerCluster_; i++) {
+    if (!vol_->writeBlock(block + i, vol_->cacheBuffer_.data)) goto FAIL;
+  }
+  // Increase directory file size by cluster size
+  fileSize_ += 512UL << vol_->clusterSizeShift_;
+  return true;
+  FAIL:
+  return false;
+}
+//------------------------------------------------------------------------------
+// cache a file's directory entry
+// return pointer to cached entry or null for failure
+dir_t* SdBaseFile::cacheDirEntry(uint8_t action) {
+  if (!vol_->cacheRawBlock(dirBlock_, action)) goto FAIL;
+  return vol_->cache()->dir + dirIndex_;
+  FAIL:
+  return 0;
+}
+//------------------------------------------------------------------------------
+/** Close a file and force cached data and directory information
+ *  to be written to the storage device.
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ * Reasons for failure include no file is open or an I/O error.
+ */
+bool SdBaseFile::close() {
+  bool rtn = sync();
+  type_ = FAT_FILE_TYPE_CLOSED;
+  return rtn;
+}
+//------------------------------------------------------------------------------
+/** Check for contiguous file and return its raw block range.
+ *
+ * \param[out] bgnBlock the first block address for the file.
+ * \param[out] endBlock the last  block address for the file.
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ * Reasons for failure include file is not contiguous, file has zero length
+ * or an I/O error occurred.
+ */
+bool SdBaseFile::contiguousRange(uint32_t* bgnBlock, uint32_t* endBlock) {
+  // error if no blocks
+  if (firstCluster_ == 0) goto FAIL;
+
+  for (uint32_t c = firstCluster_; ; c++) {
+    uint32_t next;
+    if (!vol_->fatGet(c, &next)) goto FAIL;
+
+    // check for contiguous
+    if (next != (c + 1)) {
+      // error if not end of chain
+      if (!vol_->isEOC(next)) goto FAIL;
+      *bgnBlock = vol_->clusterStartBlock(firstCluster_);
+      *endBlock = vol_->clusterStartBlock(c)
+                  + vol_->blocksPerCluster_ - 1;
+      return true;
+    }
+  }
+
+  FAIL:
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Create and open a new contiguous file of a specified size.
+ *
+ * \note This function only supports short DOS 8.3 names.
+ * See open() for more information.
+ *
+ * \param[in] dirFile The directory where the file will be created.
+ * \param[in] path A path with a valid DOS 8.3 file name.
+ * \param[in] size The desired file size.
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ * Reasons for failure include \a path contains
+ * an invalid DOS 8.3 file name, the FAT volume has not been initialized,
+ * a file is already open, the file already exists, the root
+ * directory is full or an I/O error.
+ *
+ */
+bool SdBaseFile::createContiguous(SdBaseFile* dirFile,
+                                  const char* path, uint32_t size) {
+  uint32_t count;
+  // don't allow zero length file
+  if (size == 0) goto FAIL;
+  if (!open(dirFile, path, O_CREAT | O_EXCL | O_RDWR)) goto FAIL;
+
+  // calculate number of clusters needed
+  count = ((size - 1) >> (vol_->clusterSizeShift_ + 9)) + 1;
+
+  // allocate clusters
+  if (!vol_->allocContiguous(count, &firstCluster_)) {
+    remove();
+    goto FAIL;
+  }
+  fileSize_ = size;
+
+  // insure sync() will update dir entry
+  flags_ |= F_FILE_DIR_DIRTY;
+
+  return sync();
+  FAIL:
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Return a file's directory entry.
+ *
+ * \param[out] dir Location for return of the file's directory entry.
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ */
+bool SdBaseFile::dirEntry(dir_t* dir) {
+  dir_t* p;
+  // make sure fields on SD are correct
+  if (!sync()) goto FAIL;
+
+  // read entry
+  p = cacheDirEntry(SdVolume::CACHE_FOR_READ);
+  if (!p) goto FAIL;
+
+  // copy to caller's struct
+  memcpy(dir, p, sizeof(dir_t));
+  return true;
+  FAIL:
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Format the name field of \a dir into the 13 byte array
+ * \a name in standard 8.3 short name format.
+ *
+ * \param[in] dir The directory structure containing the name.
+ * \param[out] name A 13 byte char array for the formatted name.
+ */
+void SdBaseFile::dirName(const dir_t& dir, char* name) {
+  uint8_t j = 0;
+  for (uint8_t i = 0; i < 11; i++) {
+    if (dir.name[i] == ' ')continue;
+    if (i == 8) name[j++] = '.';
+    name[j++] = dir.name[i];
+  }
+  name[j] = 0;
+}
+//------------------------------------------------------------------------------
+/** Test for the existence of a file in a directory
+ *
+ * \param[in] name Name of the file to be tested for.
+ *
+ * The calling instance must be an open directory file.
+ *
+ * dirFile.exists("TOFIND.TXT") searches for "TOFIND.TXT" in  the directory
+ * dirFile.
+ *
+ * \return true if the file exists else false.
+ */
+bool SdBaseFile::exists(const char* name) {
+  SdBaseFile file;
+  return file.open(this, name, O_READ);
+}
+//------------------------------------------------------------------------------
+/**
+ * Get a string from a file.
+ *
+ * fgets() reads bytes from a file into the array pointed to by \a str, until
+ * \a num - 1 bytes are read, or a delimiter is read and transferred to \a str,
+ * or end-of-file is encountered. The string is then terminated
+ * with a null byte.
+ *
+ * fgets() deletes CR, '\\r', from the string.  This insures only a '\\n'
+ * terminates the string for Windows text files which use CRLF for newline.
+ *
+ * \param[out] str Pointer to the array where the string is stored.
+ * \param[in] num Maximum number of characters to be read
+ * (including the final null byte). Usually the length
+ * of the array \a str is used.
+ * \param[in] delim Optional set of delimiters. The default is "\n".
+ *
+ * \return For success fgets() returns the length of the string in \a str.
+ * If no data is read, fgets() returns zero for EOF or -1 if an error occurred.
+ **/
+int16_t SdBaseFile::fgets(char* str, int16_t num, char* delim) {
+  char ch;
+  int16_t n = 0;
+  int16_t r = -1;
+  while ((n + 1) < num && (r = read(&ch, 1)) == 1) {
+    // delete CR
+    if (ch == '\r') continue;
+    str[n++] = ch;
+    if (!delim) {
+      if (ch == '\n') break;
+    }
+    else {
+      if (strchr(delim, ch)) break;
+    }
+  }
+  if (r < 0) {
+    // read error
+    return -1;
+  }
+  str[n] = '\0';
+  return n;
+}
+//------------------------------------------------------------------------------
+/** Get a file's name
+ *
+ * \param[out] name An array of 13 characters for the file's name.
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ */
+bool SdBaseFile::getFilename(char* name) {
+  if (!isOpen()) return false;
+
+  if (isRoot()) {
+    name[0] = '/';
+    name[1] = '\0';
+    return true;
+  }
+  // cache entry
+  dir_t* p = cacheDirEntry(SdVolume::CACHE_FOR_READ);
+  if (!p) return false;
+
+  // format name
+  dirName(*p, name);
+  return true;
+}
+//------------------------------------------------------------------------------
+void SdBaseFile::getpos(filepos_t* pos) {
+  pos->position = curPosition_;
+  pos->cluster = curCluster_;
+}
+
+//------------------------------------------------------------------------------
+/** List directory contents.
+ *
+ * \param[in] pr Print stream for list.
+ *
+ * \param[in] flags The inclusive OR of
+ *
+ * LS_DATE - %Print file modification date
+ *
+ * LS_SIZE - %Print file size.
+ *
+ * LS_R - Recursive list of subdirectories.
+ *
+ * \param[in] indent Amount of space before file name. Used for recursive
+ * list to indicate subdirectory level.
+ */
+void SdBaseFile::ls(uint8_t flags, uint8_t indent) {
+  rewind();
+  int8_t status;
+  while ((status = lsPrintNext(flags, indent))) {
+    if (status > 1 && (flags & LS_R)) {
+      uint16_t index = curPosition() / 32 - 1;
+      SdBaseFile s;
+      if (s.open(this, index, O_READ)) s.ls(flags, indent + 2);
+      seekSet(32 * (index + 1));
+    }
+  }
+}
+//------------------------------------------------------------------------------
+// saves 32 bytes on stack for ls recursion
+// return 0 - EOF, 1 - normal file, or 2 - directory
+int8_t SdBaseFile::lsPrintNext(uint8_t flags, uint8_t indent) {
+  dir_t dir;
+  uint8_t w = 0;
+
+  while (1) {
+    if (read(&dir, sizeof(dir)) != sizeof(dir)) return 0;
+    if (dir.name[0] == DIR_NAME_FREE) return 0;
+
+    // skip deleted entry and entries for . and  ..
+    if (dir.name[0] != DIR_NAME_DELETED && dir.name[0] != '.'
+        && DIR_IS_FILE_OR_SUBDIR(&dir)) break;
+  }
+  // indent for dir level
+  for (uint8_t i = 0; i < indent; i++) MYSERIAL.write(' ');
+
+  // print name
+  for (uint8_t i = 0; i < 11; i++) {
+    if (dir.name[i] == ' ')continue;
+    if (i == 8) {
+      MYSERIAL.write('.');
+      w++;
+    }
+    MYSERIAL.write(dir.name[i]);
+    w++;
+  }
+  if (DIR_IS_SUBDIR(&dir)) {
+    MYSERIAL.write('/');
+    w++;
+  }
+  if (flags & (LS_DATE | LS_SIZE)) {
+    while (w++ < 14) MYSERIAL.write(' ');
+  }
+  // print modify date/time if requested
+  if (flags & LS_DATE) {
+    MYSERIAL.write(' ');
+    printFatDate(dir.lastWriteDate);
+    MYSERIAL.write(' ');
+    printFatTime(dir.lastWriteTime);
+  }
+  // print size if requested
+  if (!DIR_IS_SUBDIR(&dir) && (flags & LS_SIZE)) {
+    MYSERIAL.write(' ');
+    MYSERIAL.print(dir.fileSize);
+  }
+  MYSERIAL.println();
+  return DIR_IS_FILE(&dir) ? 1 : 2;
+}
+//------------------------------------------------------------------------------
+// format directory name field from a 8.3 name string
+bool SdBaseFile::make83Name(const char* str, uint8_t* name, const char** ptr) {
+  uint8_t c;
+  uint8_t n = 7;  // max index for part before dot
+  uint8_t i = 0;
+  // blank fill name and extension
+  while (i < 11) name[i++] = ' ';
+  i = 0;
+  while (*str != '\0' && *str != '/') {
+    c = *str++;
+    if (c == '.') {
+      if (n == 10) goto FAIL;  // only one dot allowed
+      n = 10;  // max index for full 8.3 name
+      i = 8;   // place for extension
+    }
+    else {
+      // illegal FAT characters
+      PGM_P p = PSTR("|<>^+=?/[];,*\"\\");
+      uint8_t b;
+      while ((b = pgm_read_byte(p++))) if (b == c) goto FAIL;
+      // check size and only allow ASCII printable characters
+      if (i > n || c < 0x21 || c == 0x7F) goto FAIL;
+      // only upper case allowed in 8.3 names - convert lower to upper
+      name[i++] = (c < 'a' || c > 'z') ? (c) : (c + ('A' - 'a'));
+    }
+  }
+  *ptr = str;
+  // must have a file name, extension is optional
+  return name[0] != ' ';
+  FAIL:
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Make a new directory.
+ *
+ * \param[in] parent An open SdFat instance for the directory that will contain
+ * the new directory.
+ *
+ * \param[in] path A path with a valid 8.3 DOS name for the new directory.
+ *
+ * \param[in] pFlag Create missing parent directories if true.
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ * Reasons for failure include this file is already open, \a parent is not a
+ * directory, \a path is invalid or already exists in \a parent.
+ */
+bool SdBaseFile::mkdir(SdBaseFile* parent, const char* path, bool pFlag) {
+  uint8_t dname[11];
+  SdBaseFile dir1, dir2;
+  SdBaseFile* sub = &dir1;
+  SdBaseFile* start = parent;
+
+  if (!parent || isOpen()) goto FAIL;
+
+  if (*path == '/') {
+    while (*path == '/') path++;
+    if (!parent->isRoot()) {
+      if (!dir2.openRoot(parent->vol_)) goto FAIL;
+      parent = &dir2;
+    }
+  }
+  while (1) {
+    if (!make83Name(path, dname, &path)) goto FAIL;
+    while (*path == '/') path++;
+    if (!*path) break;
+    if (!sub->open(parent, dname, O_READ)) {
+      if (!pFlag || !sub->mkdir(parent, dname)) {
+        goto FAIL;
+      }
+    }
+    if (parent != start) parent->close();
+    parent = sub;
+    sub = parent != &dir1 ? &dir1 : &dir2;
+  }
+  return mkdir(parent, dname);
+  FAIL:
+  return false;
+}
+//------------------------------------------------------------------------------
+bool SdBaseFile::mkdir(SdBaseFile* parent, const uint8_t dname[11]) {
+  uint32_t block;
+  dir_t d;
+  dir_t* p;
+
+  if (!parent->isDir()) goto FAIL;
+
+  // create a normal file
+  if (!open(parent, dname, O_CREAT | O_EXCL | O_RDWR)) goto FAIL;
+
+  // convert file to directory
+  flags_ = O_READ;
+  type_ = FAT_FILE_TYPE_SUBDIR;
+
+  // allocate and zero first cluster
+  if (!addDirCluster())goto FAIL;
+
+  // force entry to SD
+  if (!sync()) goto FAIL;
+
+  // cache entry - should already be in cache due to sync() call
+  p = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
+  if (!p) goto FAIL;
+
+  // change directory entry  attribute
+  p->attributes = DIR_ATT_DIRECTORY;
+
+  // make entry for '.'
+  memcpy(&d, p, sizeof(d));
+  d.name[0] = '.';
+  for (uint8_t i = 1; i < 11; i++) d.name[i] = ' ';
+
+  // cache block for '.'  and '..'
+  block = vol_->clusterStartBlock(firstCluster_);
+  if (!vol_->cacheRawBlock(block, SdVolume::CACHE_FOR_WRITE)) goto FAIL;
+
+  // copy '.' to block
+  memcpy(&vol_->cache()->dir[0], &d, sizeof(d));
+
+  // make entry for '..'
+  d.name[1] = '.';
+  if (parent->isRoot()) {
+    d.firstClusterLow = 0;
+    d.firstClusterHigh = 0;
+  }
+  else {
+    d.firstClusterLow = parent->firstCluster_ & 0xFFFF;
+    d.firstClusterHigh = parent->firstCluster_ >> 16;
+  }
+  // copy '..' to block
+  memcpy(&vol_->cache()->dir[1], &d, sizeof(d));
+
+  // write first block
+  return vol_->cacheFlush();
+  FAIL:
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Open a file in the current working directory.
+ *
+ * \param[in] path A path with a valid 8.3 DOS name for a file to be opened.
+ *
+ * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive
+ * OR of open flags. see SdBaseFile::open(SdBaseFile*, const char*, uint8_t).
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ */
+bool SdBaseFile::open(const char* path, uint8_t oflag) {
+  return open(cwd_, path, oflag);
+}
+//------------------------------------------------------------------------------
+/** Open a file or directory by name.
+ *
+ * \param[in] dirFile An open SdFat instance for the directory containing the
+ * file to be opened.
+ *
+ * \param[in] path A path with a valid 8.3 DOS name for a file to be opened.
+ *
+ * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive
+ * OR of flags from the following list
+ *
+ * O_READ - Open for reading.
+ *
+ * O_RDONLY - Same as O_READ.
+ *
+ * O_WRITE - Open for writing.
+ *
+ * O_WRONLY - Same as O_WRITE.
+ *
+ * O_RDWR - Open for reading and writing.
+ *
+ * O_APPEND - If set, the file offset shall be set to the end of the
+ * file prior to each write.
+ *
+ * O_AT_END - Set the initial position at the end of the file.
+ *
+ * O_CREAT - If the file exists, this flag has no effect except as noted
+ * under O_EXCL below. Otherwise, the file shall be created
+ *
+ * O_EXCL - If O_CREAT and O_EXCL are set, open() shall fail if the file exists.
+ *
+ * O_SYNC - Call sync() after each write.  This flag should not be used with
+ * write(uint8_t), write_P(PGM_P), writeln_P(PGM_P), or the Arduino Print class.
+ * These functions do character at a time writes so sync() will be called
+ * after each byte.
+ *
+ * O_TRUNC - If the file exists and is a regular file, and the file is
+ * successfully opened and is not read only, its length shall be truncated to 0.
+ *
+ * WARNING: A given file must not be opened by more than one SdBaseFile object
+ * of file corruption may occur.
+ *
+ * \note Directory files must be opened read only.  Write and truncation is
+ * not allowed for directory files.
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ * Reasons for failure include this file is already open, \a dirFile is not
+ * a directory, \a path is invalid, the file does not exist
+ * or can't be opened in the access mode specified by oflag.
+ */
+bool SdBaseFile::open(SdBaseFile* dirFile, const char* path, uint8_t oflag) {
+  uint8_t dname[11];
+  SdBaseFile dir1, dir2;
+  SdBaseFile* parent = dirFile;
+  SdBaseFile* sub = &dir1;
+
+  if (!dirFile) goto FAIL;
+
+  // error if already open
+  if (isOpen()) goto FAIL;
+
+  if (*path == '/') {
+    while (*path == '/') path++;
+    if (!dirFile->isRoot()) {
+      if (!dir2.openRoot(dirFile->vol_)) goto FAIL;
+      parent = &dir2;
+    }
+  }
+  while (1) {
+    if (!make83Name(path, dname, &path)) goto FAIL;
+    while (*path == '/') path++;
+    if (!*path) break;
+    if (!sub->open(parent, dname, O_READ)) goto FAIL;
+    if (parent != dirFile) parent->close();
+    parent = sub;
+    sub = parent != &dir1 ? &dir1 : &dir2;
+  }
+  return open(parent, dname, oflag);
+  FAIL:
+  return false;
+}
+//------------------------------------------------------------------------------
+// open with filename in dname
+bool SdBaseFile::open(SdBaseFile* dirFile,
+                      const uint8_t dname[11], uint8_t oflag) {
+  bool emptyFound = false;
+  bool fileFound = false;
+  uint8_t index;
+  dir_t* p;
+
+  vol_ = dirFile->vol_;
+
+  dirFile->rewind();
+  // search for file
+
+  while (dirFile->curPosition_ < dirFile->fileSize_) {
+    index = 0XF & (dirFile->curPosition_ >> 5);
+    p = dirFile->readDirCache();
+    if (!p) goto FAIL;
+
+    if (p->name[0] == DIR_NAME_FREE || p->name[0] == DIR_NAME_DELETED) {
+      // remember first empty slot
+      if (!emptyFound) {
+        dirBlock_ = dirFile->vol_->cacheBlockNumber();
+        dirIndex_ = index;
+        emptyFound = true;
+      }
+      // done if no entries follow
+      if (p->name[0] == DIR_NAME_FREE) break;
+    }
+    else if (!memcmp(dname, p->name, 11)) {
+      fileFound = true;
+      break;
+    }
+  }
+  if (fileFound) {
+    // don't open existing file if O_EXCL
+    if (oflag & O_EXCL) goto FAIL;
+  }
+  else {
+    // don't create unless O_CREAT and O_WRITE
+    if (!(oflag & O_CREAT) || !(oflag & O_WRITE)) goto FAIL;
+    if (emptyFound) {
+      index = dirIndex_;
+      p = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
+      if (!p) goto FAIL;
+    }
+    else {
+      if (dirFile->type_ == FAT_FILE_TYPE_ROOT_FIXED) goto FAIL;
+
+      // add and zero cluster for dirFile - first cluster is in cache for write
+      if (!dirFile->addDirCluster()) goto FAIL;
+
+      // use first entry in cluster
+      p = dirFile->vol_->cache()->dir;
+      index = 0;
+    }
+    // initialize as empty file
+    memset(p, 0, sizeof(*p));
+    memcpy(p->name, dname, 11);
+
+    // set timestamps
+    if (dateTime_) {
+      // call user date/time function
+      dateTime_(&p->creationDate, &p->creationTime);
+    }
+    else {
+      // use default date/time
+      p->creationDate = FAT_DEFAULT_DATE;
+      p->creationTime = FAT_DEFAULT_TIME;
+    }
+    p->lastAccessDate = p->creationDate;
+    p->lastWriteDate = p->creationDate;
+    p->lastWriteTime = p->creationTime;
+
+    // write entry to SD
+    if (!dirFile->vol_->cacheFlush()) goto FAIL;
+  }
+  // open entry in cache
+  return openCachedEntry(index, oflag);
+  FAIL:
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Open a file by index.
+ *
+ * \param[in] dirFile An open SdFat instance for the directory.
+ *
+ * \param[in] index The \a index of the directory entry for the file to be
+ * opened.  The value for \a index is (directory file position)/32.
+ *
+ * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive
+ * OR of flags O_READ, O_WRITE, O_TRUNC, and O_SYNC.
+ *
+ * See open() by path for definition of flags.
+ * \return true for success or false for failure.
+ */
+bool SdBaseFile::open(SdBaseFile* dirFile, uint16_t index, uint8_t oflag) {
+  dir_t* p;
+
+  vol_ = dirFile->vol_;
+
+  // error if already open
+  if (isOpen() || !dirFile) goto FAIL;
+
+  // don't open existing file if O_EXCL - user call error
+  if (oflag & O_EXCL) goto FAIL;
+
+  // seek to location of entry
+  if (!dirFile->seekSet(32 * index)) goto FAIL;
+
+  // read entry into cache
+  p = dirFile->readDirCache();
+  if (!p) goto FAIL;
+
+  // error if empty slot or '.' or '..'
+  if (p->name[0] == DIR_NAME_FREE ||
+      p->name[0] == DIR_NAME_DELETED || p->name[0] == '.') {
+    goto FAIL;
+  }
+  // open cached entry
+  return openCachedEntry(index & 0XF, oflag);
+  FAIL:
+  return false;
+}
+//------------------------------------------------------------------------------
+// open a cached directory entry. Assumes vol_ is initialized
+bool SdBaseFile::openCachedEntry(uint8_t dirIndex, uint8_t oflag) {
+  // location of entry in cache
+  dir_t* p = &vol_->cache()->dir[dirIndex];
+
+  // write or truncate is an error for a directory or read-only file
+  if (p->attributes & (DIR_ATT_READ_ONLY | DIR_ATT_DIRECTORY)) {
+    if (oflag & (O_WRITE | O_TRUNC)) goto FAIL;
+  }
+  // remember location of directory entry on SD
+  dirBlock_ = vol_->cacheBlockNumber();
+  dirIndex_ = dirIndex;
+
+  // copy first cluster number for directory fields
+  firstCluster_ = (uint32_t)p->firstClusterHigh << 16;
+  firstCluster_ |= p->firstClusterLow;
+
+  // make sure it is a normal file or subdirectory
+  if (DIR_IS_FILE(p)) {
+    fileSize_ = p->fileSize;
+    type_ = FAT_FILE_TYPE_NORMAL;
+  }
+  else if (DIR_IS_SUBDIR(p)) {
+    if (!vol_->chainSize(firstCluster_, &fileSize_)) goto FAIL;
+    type_ = FAT_FILE_TYPE_SUBDIR;
+  }
+  else {
+    goto FAIL;
+  }
+  // save open flags for read/write
+  flags_ = oflag & F_OFLAG;
+
+  // set to start of file
+  curCluster_ = 0;
+  curPosition_ = 0;
+  if ((oflag & O_TRUNC) && !truncate(0)) return false;
+  return oflag & O_AT_END ? seekEnd(0) : true;
+  FAIL:
+  type_ = FAT_FILE_TYPE_CLOSED;
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Open the next file or subdirectory in a directory.
+ *
+ * \param[in] dirFile An open SdFat instance for the directory containing the
+ * file to be opened.
+ *
+ * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive
+ * OR of flags O_READ, O_WRITE, O_TRUNC, and O_SYNC.
+ *
+ * See open() by path for definition of flags.
+ * \return true for success or false for failure.
+ */
+bool SdBaseFile::openNext(SdBaseFile* dirFile, uint8_t oflag) {
+  dir_t* p;
+  uint8_t index;
+
+  if (!dirFile) goto FAIL;
+
+  // error if already open
+  if (isOpen()) goto FAIL;
+
+  vol_ = dirFile->vol_;
+
+  while (1) {
+    index = 0XF & (dirFile->curPosition_ >> 5);
+
+    // read entry into cache
+    p = dirFile->readDirCache();
+    if (!p) goto FAIL;
+
+    // done if last entry
+    if (p->name[0] == DIR_NAME_FREE) goto FAIL;
+
+    // skip empty slot or '.' or '..'
+    if (p->name[0] == DIR_NAME_DELETED || p->name[0] == '.') {
+      continue;
+    }
+    // must be file or dir
+    if (DIR_IS_FILE_OR_SUBDIR(p)) {
+      return openCachedEntry(index, oflag);
+    }
+  }
+  FAIL:
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Open a directory's parent directory.
+ *
+ * \param[in] dir Parent of this directory will be opened.  Must not be root.
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ */
+bool SdBaseFile::openParent(SdBaseFile* dir) {
+  dir_t entry;
+  dir_t* p;
+  SdBaseFile file;
+  uint32_t c;
+  uint32_t cluster;
+  uint32_t lbn;
+  // error if already open or dir is root or dir is not a directory
+  if (isOpen() || !dir || dir->isRoot() || !dir->isDir()) goto FAIL;
+  vol_ = dir->vol_;
+  // position to '..'
+  if (!dir->seekSet(32)) goto FAIL;
+  // read '..' entry
+  if (dir->read(&entry, sizeof(entry)) != 32) goto FAIL;
+  // verify it is '..'
+  if (entry.name[0] != '.' || entry.name[1] != '.') goto FAIL;
+  // start cluster for '..'
+  cluster = entry.firstClusterLow;
+  cluster |= (uint32_t)entry.firstClusterHigh << 16;
+  if (cluster == 0) return openRoot(vol_);
+  // start block for '..'
+  lbn = vol_->clusterStartBlock(cluster);
+  // first block of parent dir
+  if (!vol_->cacheRawBlock(lbn, SdVolume::CACHE_FOR_READ)) {
+    goto FAIL;
+  }
+  p = &vol_->cacheBuffer_.dir[1];
+  // verify name for '../..'
+  if (p->name[0] != '.' || p->name[1] != '.') goto FAIL;
+  // '..' is pointer to first cluster of parent. open '../..' to find parent
+  if (p->firstClusterHigh == 0 && p->firstClusterLow == 0) {
+    if (!file.openRoot(dir->volume())) goto FAIL;
+  }
+  else if (!file.openCachedEntry(1, O_READ)) {
+    goto FAIL;
+  }
+  // search for parent in '../..'
+  do {
+    if (file.readDir(&entry, NULL) != 32) goto FAIL;
+    c = entry.firstClusterLow;
+    c |= (uint32_t)entry.firstClusterHigh << 16;
+  } while (c != cluster);
+  // open parent
+  return open(&file, file.curPosition() / 32 - 1, O_READ);
+  FAIL:
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Open a volume's root directory.
+ *
+ * \param[in] vol The FAT volume containing the root directory to be opened.
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ * Reasons for failure include the file is already open, the FAT volume has
+ * not been initialized or it a FAT12 volume.
+ */
+bool SdBaseFile::openRoot(SdVolume* vol) {
+  // error if file is already open
+  if (isOpen()) goto FAIL;
+
+  if (vol->fatType() == 16 || (FAT12_SUPPORT && vol->fatType() == 12)) {
+    type_ = FAT_FILE_TYPE_ROOT_FIXED;
+    firstCluster_ = 0;
+    fileSize_ = 32 * vol->rootDirEntryCount();
+  }
+  else if (vol->fatType() == 32) {
+    type_ = FAT_FILE_TYPE_ROOT32;
+    firstCluster_ = vol->rootDirStart();
+    if (!vol->chainSize(firstCluster_, &fileSize_)) goto FAIL;
+  }
+  else {
+    // volume is not initialized, invalid, or FAT12 without support
+    return false;
+  }
+  vol_ = vol;
+  // read only
+  flags_ = O_READ;
+
+  // set to start of file
+  curCluster_ = 0;
+  curPosition_ = 0;
+
+  // root has no directory entry
+  dirBlock_ = 0;
+  dirIndex_ = 0;
+  return true;
+  FAIL:
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Return the next available byte without consuming it.
+ *
+ * \return The byte if no error and not at eof else -1;
+ */
+int SdBaseFile::peek() {
+  filepos_t pos;
+  getpos(&pos);
+  int c = read();
+  if (c >= 0) setpos(&pos);
+  return c;
+}
+
+//------------------------------------------------------------------------------
+/** %Print the name field of a directory entry in 8.3 format.
+ * \param[in] pr Print stream for output.
+ * \param[in] dir The directory structure containing the name.
+ * \param[in] width Blank fill name if length is less than \a width.
+ * \param[in] printSlash Print '/' after directory names if true.
+ */
+void SdBaseFile::printDirName(const dir_t& dir,
+                              uint8_t width, bool printSlash) {
+  uint8_t w = 0;
+  for (uint8_t i = 0; i < 11; i++) {
+    if (dir.name[i] == ' ')continue;
+    if (i == 8) {
+      MYSERIAL.write('.');
+      w++;
+    }
+    MYSERIAL.write(dir.name[i]);
+    w++;
+  }
+  if (DIR_IS_SUBDIR(&dir) && printSlash) {
+    MYSERIAL.write('/');
+    w++;
+  }
+  while (w < width) {
+    MYSERIAL.write(' ');
+    w++;
+  }
+}
+//------------------------------------------------------------------------------
+// print uint8_t with width 2
+static void print2u(uint8_t v) {
+  if (v < 10) MYSERIAL.write('0');
+  MYSERIAL.print(v, DEC);
+}
+//------------------------------------------------------------------------------
+/** %Print a directory date field to Serial.
+ *
+ *  Format is yyyy-mm-dd.
+ *
+ * \param[in] fatDate The date field from a directory entry.
+ */
+
+//------------------------------------------------------------------------------
+/** %Print a directory date field.
+ *
+ *  Format is yyyy-mm-dd.
+ *
+ * \param[in] pr Print stream for output.
+ * \param[in] fatDate The date field from a directory entry.
+ */
+void SdBaseFile::printFatDate(uint16_t fatDate) {
+  MYSERIAL.print(FAT_YEAR(fatDate));
+  MYSERIAL.write('-');
+  print2u(FAT_MONTH(fatDate));
+  MYSERIAL.write('-');
+  print2u(FAT_DAY(fatDate));
+}
+
+//------------------------------------------------------------------------------
+/** %Print a directory time field.
+ *
+ * Format is hh:mm:ss.
+ *
+ * \param[in] pr Print stream for output.
+ * \param[in] fatTime The time field from a directory entry.
+ */
+void SdBaseFile::printFatTime(uint16_t fatTime) {
+  print2u(FAT_HOUR(fatTime));
+  MYSERIAL.write(':');
+  print2u(FAT_MINUTE(fatTime));
+  MYSERIAL.write(':');
+  print2u(FAT_SECOND(fatTime));
+}
+//------------------------------------------------------------------------------
+/** Print a file's name to Serial
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ */
+bool SdBaseFile::printName() {
+  char name[FILENAME_LENGTH];
+  if (!getFilename(name)) return false;
+  MYSERIAL.print(name);
+  return true;
+}
+//------------------------------------------------------------------------------
+/** Read the next byte from a file.
+ *
+ * \return For success read returns the next byte in the file as an int.
+ * If an error occurs or end of file is reached -1 is returned.
+ */
+int16_t SdBaseFile::read() {
+  uint8_t b;
+  return read(&b, 1) == 1 ? b : -1;
+}
+//------------------------------------------------------------------------------
+/** Read data from a file starting at the current position.
+ *
+ * \param[out] buf Pointer to the location that will receive the data.
+ *
+ * \param[in] nbyte Maximum number of bytes to read.
+ *
+ * \return For success read() returns the number of bytes read.
+ * A value less than \a nbyte, including zero, will be returned
+ * if end of file is reached.
+ * If an error occurs, read() returns -1.  Possible errors include
+ * read() called before a file has been opened, corrupt file system
+ * or an I/O error occurred.
+ */
+int16_t SdBaseFile::read(void* buf, uint16_t nbyte) {
+  uint8_t* dst = reinterpret_cast<uint8_t*>(buf);
+  uint16_t offset;
+  uint16_t toRead;
+  uint32_t block;  // raw device block number
+
+  // error if not open or write only
+  if (!isOpen() || !(flags_ & O_READ)) goto FAIL;
+
+  // max bytes left in file
+  NOMORE(nbyte, fileSize_ - curPosition_);
+
+  // amount left to read
+  toRead = nbyte;
+  while (toRead > 0) {
+    offset = curPosition_ & 0x1FF;  // offset in block
+    if (type_ == FAT_FILE_TYPE_ROOT_FIXED) {
+      block = vol_->rootDirStart() + (curPosition_ >> 9);
+    }
+    else {
+      uint8_t blockOfCluster = vol_->blockOfCluster(curPosition_);
+      if (offset == 0 && blockOfCluster == 0) {
+        // start of new cluster
+        if (curPosition_ == 0) {
+          // use first cluster in file
+          curCluster_ = firstCluster_;
+        }
+        else {
+          // get next cluster from FAT
+          if (!vol_->fatGet(curCluster_, &curCluster_)) goto FAIL;
+        }
+      }
+      block = vol_->clusterStartBlock(curCluster_) + blockOfCluster;
+    }
+    uint16_t n = toRead;
+
+    // amount to be read from current block
+    NOMORE(n, 512 - offset);
+
+    // no buffering needed if n == 512
+    if (n == 512 && block != vol_->cacheBlockNumber()) {
+      if (!vol_->readBlock(block, dst)) goto FAIL;
+    }
+    else {
+      // read block to cache and copy data to caller
+      if (!vol_->cacheRawBlock(block, SdVolume::CACHE_FOR_READ)) goto FAIL;
+      uint8_t* src = vol_->cache()->data + offset;
+      memcpy(dst, src, n);
+    }
+    dst += n;
+    curPosition_ += n;
+    toRead -= n;
+  }
+  return nbyte;
+  FAIL:
+  return -1;
+}
+
+/**
+ * Read the next entry in a directory.
+ *
+ * \param[out] dir The dir_t struct that will receive the data.
+ *
+ * \return For success readDir() returns the number of bytes read.
+ * A value of zero will be returned if end of file is reached.
+ * If an error occurs, readDir() returns -1.  Possible errors include
+ * readDir() called before a directory has been opened, this is not
+ * a directory file or an I/O error occurred.
+ */
+int8_t SdBaseFile::readDir(dir_t* dir, char* longFilename) {
+  int16_t n;
+  // if not a directory file or miss-positioned return an error
+  if (!isDir() || (0x1F & curPosition_)) return -1;
+
+  //If we have a longFilename buffer, mark it as invalid. If we find a long filename it will be filled automaticly.
+  if (longFilename != NULL) longFilename[0] = '\0';
+
+  while (1) {
+
+    n = read(dir, sizeof(dir_t));
+    if (n != sizeof(dir_t)) return n == 0 ? 0 : -1;
+
+    // last entry if DIR_NAME_FREE
+    if (dir->name[0] == DIR_NAME_FREE) return 0;
+
+    // skip empty entries and entry for .  and ..
+    if (dir->name[0] == DIR_NAME_DELETED || dir->name[0] == '.') continue;
+
+    // Fill the long filename if we have a long filename entry.
+    // Long filename entries are stored before the short filename.
+    if (longFilename != NULL && DIR_IS_LONG_NAME(dir)) {
+      vfat_t* VFAT = (vfat_t*)dir;
+      // Sanity-check the VFAT entry. The first cluster is always set to zero. And the sequence number should be higher than 0
+      if (VFAT->firstClusterLow == 0 && (VFAT->sequenceNumber & 0x1F) > 0 && (VFAT->sequenceNumber & 0x1F) <= MAX_VFAT_ENTRIES) {
+        // TODO: Store the filename checksum to verify if a none-long filename aware system modified the file table.
+        n = ((VFAT->sequenceNumber & 0x1F) - 1) * (FILENAME_LENGTH);
+        for (uint8_t i = 0; i < FILENAME_LENGTH; i++)
+          longFilename[n + i] = (i < 5) ? VFAT->name1[i] : (i < 11) ? VFAT->name2[i - 5] : VFAT->name3[i - 11];
+        // If this VFAT entry is the last one, add a NUL terminator at the end of the string
+        if (VFAT->sequenceNumber & 0x40) longFilename[n + FILENAME_LENGTH] = '\0';
+      }
+    }
+    // Return if normal file or subdirectory
+    if (DIR_IS_FILE_OR_SUBDIR(dir)) return n;
+  }
+}
+
+//------------------------------------------------------------------------------
+// Read next directory entry into the cache
+// Assumes file is correctly positioned
+dir_t* SdBaseFile::readDirCache() {
+  uint8_t i;
+  // error if not directory
+  if (!isDir()) goto FAIL;
+
+  // index of entry in cache
+  i = (curPosition_ >> 5) & 0XF;
+
+  // use read to locate and cache block
+  if (read() < 0) goto FAIL;
+
+  // advance to next entry
+  curPosition_ += 31;
+
+  // return pointer to entry
+  return vol_->cache()->dir + i;
+  FAIL:
+  return 0;
+}
+//------------------------------------------------------------------------------
+/** Remove a file.
+ *
+ * The directory entry and all data for the file are deleted.
+ *
+ * \note This function should not be used to delete the 8.3 version of a
+ * file that has a long name. For example if a file has the long name
+ * "New Text Document.txt" you should not delete the 8.3 name "NEWTEX~1.TXT".
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ * Reasons for failure include the file read-only, is a directory,
+ * or an I/O error occurred.
+ */
+bool SdBaseFile::remove() {
+  dir_t* d;
+  // free any clusters - will fail if read-only or directory
+  if (!truncate(0)) goto FAIL;
+
+  // cache directory entry
+  d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
+  if (!d) goto FAIL;
+
+  // mark entry deleted
+  d->name[0] = DIR_NAME_DELETED;
+
+  // set this file closed
+  type_ = FAT_FILE_TYPE_CLOSED;
+
+  // write entry to SD
+  return vol_->cacheFlush();
+  return true;
+  FAIL:
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Remove a file.
+ *
+ * The directory entry and all data for the file are deleted.
+ *
+ * \param[in] dirFile The directory that contains the file.
+ * \param[in] path Path for the file to be removed.
+ *
+ * \note This function should not be used to delete the 8.3 version of a
+ * file that has a long name. For example if a file has the long name
+ * "New Text Document.txt" you should not delete the 8.3 name "NEWTEX~1.TXT".
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ * Reasons for failure include the file is a directory, is read only,
+ * \a dirFile is not a directory, \a path is not found
+ * or an I/O error occurred.
+ */
+bool SdBaseFile::remove(SdBaseFile* dirFile, const char* path) {
+  SdBaseFile file;
+  if (!file.open(dirFile, path, O_WRITE)) goto FAIL;
+  return file.remove();
+  FAIL:
+  // can't set iostate - static function
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Rename a file or subdirectory.
+ *
+ * \param[in] dirFile Directory for the new path.
+ * \param[in] newPath New path name for the file/directory.
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ * Reasons for failure include \a dirFile is not open or is not a directory
+ * file, newPath is invalid or already exists, or an I/O error occurs.
+ */
+bool SdBaseFile::rename(SdBaseFile* dirFile, const char* newPath) {
+  dir_t entry;
+  uint32_t dirCluster = 0;
+  SdBaseFile file;
+  dir_t* d;
+
+  // must be an open file or subdirectory
+  if (!(isFile() || isSubDir())) goto FAIL;
+
+  // can't move file
+  if (vol_ != dirFile->vol_) goto FAIL;
+
+  // sync() and cache directory entry
+  sync();
+  d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
+  if (!d) goto FAIL;
+
+  // save directory entry
+  memcpy(&entry, d, sizeof(entry));
+
+  // mark entry deleted
+  d->name[0] = DIR_NAME_DELETED;
+
+  // make directory entry for new path
+  if (isFile()) {
+    if (!file.open(dirFile, newPath, O_CREAT | O_EXCL | O_WRITE)) {
+      goto restore;
+    }
+  }
+  else {
+    // don't create missing path prefix components
+    if (!file.mkdir(dirFile, newPath, false)) {
+      goto restore;
+    }
+    // save cluster containing new dot dot
+    dirCluster = file.firstCluster_;
+  }
+  // change to new directory entry
+  dirBlock_ = file.dirBlock_;
+  dirIndex_ = file.dirIndex_;
+
+  // mark closed to avoid possible destructor close call
+  file.type_ = FAT_FILE_TYPE_CLOSED;
+
+  // cache new directory entry
+  d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
+  if (!d) goto FAIL;
+
+  // copy all but name field to new directory entry
+  memcpy(&d->attributes, &entry.attributes, sizeof(entry) - sizeof(d->name));
+
+  // update dot dot if directory
+  if (dirCluster) {
+    // get new dot dot
+    uint32_t block = vol_->clusterStartBlock(dirCluster);
+    if (!vol_->cacheRawBlock(block, SdVolume::CACHE_FOR_READ)) goto FAIL;
+    memcpy(&entry, &vol_->cache()->dir[1], sizeof(entry));
+
+    // free unused cluster
+    if (!vol_->freeChain(dirCluster)) goto FAIL;
+
+    // store new dot dot
+    block = vol_->clusterStartBlock(firstCluster_);
+    if (!vol_->cacheRawBlock(block, SdVolume::CACHE_FOR_WRITE)) goto FAIL;
+    memcpy(&vol_->cache()->dir[1], &entry, sizeof(entry));
+  }
+  return vol_->cacheFlush();
+
+restore:
+  d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
+  if (!d) goto FAIL;
+  // restore entry
+  d->name[0] = entry.name[0];
+  vol_->cacheFlush();
+
+  FAIL:
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Remove a directory file.
+ *
+ * The directory file will be removed only if it is empty and is not the
+ * root directory.  rmdir() follows DOS and Windows and ignores the
+ * read-only attribute for the directory.
+ *
+ * \note This function should not be used to delete the 8.3 version of a
+ * directory that has a long name. For example if a directory has the
+ * long name "New folder" you should not delete the 8.3 name "NEWFOL~1".
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ * Reasons for failure include the file is not a directory, is the root
+ * directory, is not empty, or an I/O error occurred.
+ */
+bool SdBaseFile::rmdir() {
+  // must be open subdirectory
+  if (!isSubDir()) goto FAIL;
+
+  rewind();
+
+  // make sure directory is empty
+  while (curPosition_ < fileSize_) {
+    dir_t* p = readDirCache();
+    if (!p) goto FAIL;
+    // done if past last used entry
+    if (p->name[0] == DIR_NAME_FREE) break;
+    // skip empty slot, '.' or '..'
+    if (p->name[0] == DIR_NAME_DELETED || p->name[0] == '.') continue;
+    // error not empty
+    if (DIR_IS_FILE_OR_SUBDIR(p)) goto FAIL;
+  }
+  // convert empty directory to normal file for remove
+  type_ = FAT_FILE_TYPE_NORMAL;
+  flags_ |= O_WRITE;
+  return remove();
+  FAIL:
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Recursively delete a directory and all contained files.
+ *
+ * This is like the Unix/Linux 'rm -rf *' if called with the root directory
+ * hence the name.
+ *
+ * Warning - This will remove all contents of the directory including
+ * subdirectories.  The directory will then be removed if it is not root.
+ * The read-only attribute for files will be ignored.
+ *
+ * \note This function should not be used to delete the 8.3 version of
+ * a directory that has a long name.  See remove() and rmdir().
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ */
+bool SdBaseFile::rmRfStar() {
+  uint16_t index;
+  SdBaseFile f;
+  rewind();
+  while (curPosition_ < fileSize_) {
+    // remember position
+    index = curPosition_ / 32;
+
+    dir_t* p = readDirCache();
+    if (!p) goto FAIL;
+
+    // done if past last entry
+    if (p->name[0] == DIR_NAME_FREE) break;
+
+    // skip empty slot or '.' or '..'
+    if (p->name[0] == DIR_NAME_DELETED || p->name[0] == '.') continue;
+
+    // skip if part of long file name or volume label in root
+    if (!DIR_IS_FILE_OR_SUBDIR(p)) continue;
+
+    if (!f.open(this, index, O_READ)) goto FAIL;
+    if (f.isSubDir()) {
+      // recursively delete
+      if (!f.rmRfStar()) goto FAIL;
+    }
+    else {
+      // ignore read-only
+      f.flags_ |= O_WRITE;
+      if (!f.remove()) goto FAIL;
+    }
+    // position to next entry if required
+    if (curPosition_ != (32 * (index + 1))) {
+      if (!seekSet(32 * (index + 1))) goto FAIL;
+    }
+  }
+  // don't try to delete root
+  if (!isRoot()) {
+    if (!rmdir()) goto FAIL;
+  }
+  return true;
+  FAIL:
+  return false;
+}
+//------------------------------------------------------------------------------
+/**  Create a file object and open it in the current working directory.
+ *
+ * \param[in] path A path with a valid 8.3 DOS name for a file to be opened.
+ *
+ * \param[in] oflag Values for \a oflag are constructed by a bitwise-inclusive
+ * OR of open flags. see SdBaseFile::open(SdBaseFile*, const char*, uint8_t).
+ */
+SdBaseFile::SdBaseFile(const char* path, uint8_t oflag) {
+  type_ = FAT_FILE_TYPE_CLOSED;
+  writeError = false;
+  open(path, oflag);
+}
+//------------------------------------------------------------------------------
+/** Sets a file's position.
+ *
+ * \param[in] pos The new position in bytes from the beginning of the file.
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ */
+bool SdBaseFile::seekSet(uint32_t pos) {
+  uint32_t nCur;
+  uint32_t nNew;
+  // error if file not open or seek past end of file
+  if (!isOpen() || pos > fileSize_) goto FAIL;
+
+  if (type_ == FAT_FILE_TYPE_ROOT_FIXED) {
+    curPosition_ = pos;
+    goto done;
+  }
+  if (pos == 0) {
+    // set position to start of file
+    curCluster_ = 0;
+    curPosition_ = 0;
+    goto done;
+  }
+  // calculate cluster index for cur and new position
+  nCur = (curPosition_ - 1) >> (vol_->clusterSizeShift_ + 9);
+  nNew = (pos - 1) >> (vol_->clusterSizeShift_ + 9);
+
+  if (nNew < nCur || curPosition_ == 0) {
+    // must follow chain from first cluster
+    curCluster_ = firstCluster_;
+  }
+  else {
+    // advance from curPosition
+    nNew -= nCur;
+  }
+  while (nNew--) {
+    if (!vol_->fatGet(curCluster_, &curCluster_)) goto FAIL;
+  }
+  curPosition_ = pos;
+
+done:
+  return true;
+
+  FAIL:
+  return false;
+}
+//------------------------------------------------------------------------------
+void SdBaseFile::setpos(filepos_t* pos) {
+  curPosition_ = pos->position;
+  curCluster_ = pos->cluster;
+}
+//------------------------------------------------------------------------------
+/** The sync() call causes all modified data and directory fields
+ * to be written to the storage device.
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ * Reasons for failure include a call to sync() before a file has been
+ * opened or an I/O error.
+ */
+bool SdBaseFile::sync() {
+  // only allow open files and directories
+  if (!isOpen()) goto FAIL;
+
+  if (flags_ & F_FILE_DIR_DIRTY) {
+    dir_t* d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
+    // check for deleted by another open file object
+    if (!d || d->name[0] == DIR_NAME_DELETED) goto FAIL;
+
+    // do not set filesize for dir files
+    if (!isDir()) d->fileSize = fileSize_;
+
+    // update first cluster fields
+    d->firstClusterLow = firstCluster_ & 0xFFFF;
+    d->firstClusterHigh = firstCluster_ >> 16;
+
+    // set modify time if user supplied a callback date/time function
+    if (dateTime_) {
+      dateTime_(&d->lastWriteDate, &d->lastWriteTime);
+      d->lastAccessDate = d->lastWriteDate;
+    }
+    // clear directory dirty
+    flags_ &= ~F_FILE_DIR_DIRTY;
+  }
+  return vol_->cacheFlush();
+
+  FAIL:
+  writeError = true;
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Copy a file's timestamps
+ *
+ * \param[in] file File to copy timestamps from.
+ *
+ * \note
+ * Modify and access timestamps may be overwritten if a date time callback
+ * function has been set by dateTimeCallback().
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ */
+bool SdBaseFile::timestamp(SdBaseFile* file) {
+  dir_t* d;
+  dir_t dir;
+
+  // get timestamps
+  if (!file->dirEntry(&dir)) goto FAIL;
+
+  // update directory fields
+  if (!sync()) goto FAIL;
+
+  d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
+  if (!d) goto FAIL;
+
+  // copy timestamps
+  d->lastAccessDate = dir.lastAccessDate;
+  d->creationDate = dir.creationDate;
+  d->creationTime = dir.creationTime;
+  d->creationTimeTenths = dir.creationTimeTenths;
+  d->lastWriteDate = dir.lastWriteDate;
+  d->lastWriteTime = dir.lastWriteTime;
+
+  // write back entry
+  return vol_->cacheFlush();
+
+  FAIL:
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Set a file's timestamps in its directory entry.
+ *
+ * \param[in] flags Values for \a flags are constructed by a bitwise-inclusive
+ * OR of flags from the following list
+ *
+ * T_ACCESS - Set the file's last access date.
+ *
+ * T_CREATE - Set the file's creation date and time.
+ *
+ * T_WRITE - Set the file's last write/modification date and time.
+ *
+ * \param[in] year Valid range 1980 - 2107 inclusive.
+ *
+ * \param[in] month Valid range 1 - 12 inclusive.
+ *
+ * \param[in] day Valid range 1 - 31 inclusive.
+ *
+ * \param[in] hour Valid range 0 - 23 inclusive.
+ *
+ * \param[in] minute Valid range 0 - 59 inclusive.
+ *
+ * \param[in] second Valid range 0 - 59 inclusive
+ *
+ * \note It is possible to set an invalid date since there is no check for
+ * the number of days in a month.
+ *
+ * \note
+ * Modify and access timestamps may be overwritten if a date time callback
+ * function has been set by dateTimeCallback().
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ */
+bool SdBaseFile::timestamp(uint8_t flags, uint16_t year, uint8_t month,
+                           uint8_t day, uint8_t hour, uint8_t minute, uint8_t second) {
+  uint16_t dirDate;
+  uint16_t dirTime;
+  dir_t* d;
+
+  if (!isOpen()
+      || year < 1980
+      || year > 2107
+      || month < 1
+      || month > 12
+      || day < 1
+      || day > 31
+      || hour > 23
+      || minute > 59
+      || second > 59) {
+    goto FAIL;
+  }
+  // update directory entry
+  if (!sync()) goto FAIL;
+
+  d = cacheDirEntry(SdVolume::CACHE_FOR_WRITE);
+  if (!d) goto FAIL;
+
+  dirDate = FAT_DATE(year, month, day);
+  dirTime = FAT_TIME(hour, minute, second);
+  if (flags & T_ACCESS) {
+    d->lastAccessDate = dirDate;
+  }
+  if (flags & T_CREATE) {
+    d->creationDate = dirDate;
+    d->creationTime = dirTime;
+    // seems to be units of 1/100 second not 1/10 as Microsoft states
+    d->creationTimeTenths = second & 1 ? 100 : 0;
+  }
+  if (flags & T_WRITE) {
+    d->lastWriteDate = dirDate;
+    d->lastWriteTime = dirTime;
+  }
+  return vol_->cacheFlush();
+  FAIL:
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Truncate a file to a specified length.  The current file position
+ * will be maintained if it is less than or equal to \a length otherwise
+ * it will be set to end of file.
+ *
+ * \param[in] length The desired length for the file.
+ *
+ * \return The value one, true, is returned for success and
+ * the value zero, false, is returned for failure.
+ * Reasons for failure include file is read only, file is a directory,
+ * \a length is greater than the current file size or an I/O error occurs.
+ */
+bool SdBaseFile::truncate(uint32_t length) {
+  uint32_t newPos;
+  // error if not a normal file or read-only
+  if (!isFile() || !(flags_ & O_WRITE)) goto FAIL;
+
+  // error if length is greater than current size
+  if (length > fileSize_) goto FAIL;
+
+  // fileSize and length are zero - nothing to do
+  if (fileSize_ == 0) return true;
+
+  // remember position for seek after truncation
+  newPos = curPosition_ > length ? length : curPosition_;
+
+  // position to last cluster in truncated file
+  if (!seekSet(length)) goto FAIL;
+
+  if (length == 0) {
+    // free all clusters
+    if (!vol_->freeChain(firstCluster_)) goto FAIL;
+    firstCluster_ = 0;
+  }
+  else {
+    uint32_t toFree;
+    if (!vol_->fatGet(curCluster_, &toFree)) goto FAIL;
+
+    if (!vol_->isEOC(toFree)) {
+      // free extra clusters
+      if (!vol_->freeChain(toFree)) goto FAIL;
+
+      // current cluster is end of chain
+      if (!vol_->fatPutEOC(curCluster_)) goto FAIL;
+    }
+  }
+  fileSize_ = length;
+
+  // need to update directory entry
+  flags_ |= F_FILE_DIR_DIRTY;
+
+  if (!sync()) goto FAIL;
+
+  // set file to correct position
+  return seekSet(newPos);
+
+  FAIL:
+  return false;
+}
+//------------------------------------------------------------------------------
+/** Write data to an open file.
+ *
+ * \note Data is moved to the cache but may not be written to the
+ * storage device until sync() is called.
+ *
+ * \param[in] buf Pointer to the location of the data to be written.
+ *
+ * \param[in] nbyte Number of bytes to write.
+ *
+ * \return For success write() returns the number of bytes written, always
+ * \a nbyte.  If an error occurs, write() returns -1.  Possible errors
+ * include write() is called before a file has been opened, write is called
+ * for a read-only file, device is full, a corrupt file system or an I/O error.
+ *
+ */
+int16_t SdBaseFile::write(const void* buf, uint16_t nbyte) {
+  // convert void* to uint8_t*  -  must be before goto statements
+  const uint8_t* src = reinterpret_cast<const uint8_t*>(buf);
+
+  // number of bytes left to write  -  must be before goto statements
+  uint16_t nToWrite = nbyte;
+
+  // error if not a normal file or is read-only
+  if (!isFile() || !(flags_ & O_WRITE)) goto FAIL;
+
+  // seek to end of file if append flag
+  if ((flags_ & O_APPEND) && curPosition_ != fileSize_) {
+    if (!seekEnd()) goto FAIL;
+  }
+
+  while (nToWrite > 0) {
+    uint8_t blockOfCluster = vol_->blockOfCluster(curPosition_);
+    uint16_t blockOffset = curPosition_ & 0x1FF;
+    if (blockOfCluster == 0 && blockOffset == 0) {
+      // start of new cluster
+      if (curCluster_ == 0) {
+        if (firstCluster_ == 0) {
+          // allocate first cluster of file
+          if (!addCluster()) goto FAIL;
+        }
+        else {
+          curCluster_ = firstCluster_;
+        }
+      }
+      else {
+        uint32_t next;
+        if (!vol_->fatGet(curCluster_, &next)) goto FAIL;
+        if (vol_->isEOC(next)) {
+          // add cluster if at end of chain
+          if (!addCluster()) goto FAIL;
+        }
+        else {
+          curCluster_ = next;
+        }
+      }
+    }
+    // max space in block
+    uint16_t n = 512 - blockOffset;
+
+    // lesser of space and amount to write
+    NOMORE(n, nToWrite);
+
+    // block for data write
+    uint32_t block = vol_->clusterStartBlock(curCluster_) + blockOfCluster;
+    if (n == 512) {
+      // full block - don't need to use cache
+      if (vol_->cacheBlockNumber() == block) {
+        // invalidate cache if block is in cache
+        vol_->cacheSetBlockNumber(0xFFFFFFFF, false);
+      }
+      if (!vol_->writeBlock(block, src)) goto FAIL;
+    }
+    else {
+      if (blockOffset == 0 && curPosition_ >= fileSize_) {
+        // start of new block don't need to read into cache
+        if (!vol_->cacheFlush()) goto FAIL;
+        // set cache dirty and SD address of block
+        vol_->cacheSetBlockNumber(block, true);
+      }
+      else {
+        // rewrite part of block
+        if (!vol_->cacheRawBlock(block, SdVolume::CACHE_FOR_WRITE)) goto FAIL;
+      }
+      uint8_t* dst = vol_->cache()->data + blockOffset;
+      memcpy(dst, src, n);
+    }
+    curPosition_ += n;
+    src += n;
+    nToWrite -= n;
+  }
+  if (curPosition_ > fileSize_) {
+    // update fileSize and insure sync will update dir entry
+    fileSize_ = curPosition_;
+    flags_ |= F_FILE_DIR_DIRTY;
+  }
+  else if (dateTime_ && nbyte) {
+    // insure sync will update modified date and time
+    flags_ |= F_FILE_DIR_DIRTY;
+  }
+
+  if (flags_ & O_SYNC) {
+    if (!sync()) goto FAIL;
+  }
+  return nbyte;
+
+  FAIL:
+  // return for write error
+  writeError = true;
+  return -1;
+}
+//------------------------------------------------------------------------------
+// suppress cpplint warnings with NOLINT comment
+#if ALLOW_DEPRECATED_FUNCTIONS && !defined(DOXYGEN)
+  void (*SdBaseFile::oldDateTime_)(uint16_t &date, uint16_t &time) = 0;  // NOLINT
+#endif  // ALLOW_DEPRECATED_FUNCTIONS
+
+
+#endif
