commit 9a7d9e6995f4f66c4b48147ec7876d49d4b3ae77
Author: Martin Turski <turningtides@outlook.de>
Date:   Thu Apr 27 14:05:24 2023 +0200

    üßë‚Äçüíª Optimize PlatformIO source filtering (#25332)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/fontutils.cpp b/Marlin/src/lcd/fontutils.cpp
deleted file mode 100644
index 46329fd4be..0000000000
--- a/Marlin/src/lcd/fontutils.cpp
+++ /dev/null
@@ -1,205 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * @file    fontutils.cpp
- * @brief   help functions for font and char
- * @author  Yunhui Fu (yhfudev@gmail.com)
- * @version 1.0
- * @date    2016-08-19
- * @copyright GPL/BSD
- */
-
-#include "../inc/MarlinConfig.h"
-
-#if HAS_WIRED_LCD
-  #include "marlinui.h"
-  #include "../MarlinCore.h"
-#endif
-
-#include "fontutils.h"
-
-uint8_t read_byte_ram(const uint8_t *str) { return *str; }
-uint8_t read_byte_rom(const uint8_t *str) { return pgm_read_byte(str); }
-
-/**
- * @brief Using binary search to find the position by data_pin
- *
- * @param userdata : User's data
- * @param num_data : the item number of the sorted data
- * @param cb_comp : the callback function to compare the user's data and pin
- * @param data_pin : The reference data to be found
- * @param ret_idx : the position of the required data; If failed, then it is the failed position, which is the insert position if possible.
- *
- * @return 0 on found, <0 on failed(fail position is saved by ret_idx)
- *
- * Using binary search to find the position by data_pin. The user's data should be sorted.
- */
-int pf_bsearch_r(void *userdata, size_t num_data, pf_bsearch_cb_comp_t cb_comp, void *data_pinpoint, size_t *ret_idx) {
-  int retcomp;
-
-  if (num_data < 1) {
-    *ret_idx = 0;
-    return -1;
-  }
-
-  size_t i = 0, ileft = 1, iright = num_data;
-  bool flg_found = false;
-  for (; ileft <= iright;) {
-    i = (ileft + iright) / 2 - 1;
-    /* cb_comp should return the *userdata[i] - *data_pinpoint */
-    retcomp = cb_comp (userdata, i, data_pinpoint);
-    if (retcomp > 0)
-      iright = i;
-    else if (retcomp < 0)
-      ileft = i + 2;
-    else {
-      /* found ! */
-      flg_found = true;
-      break;
-    }
-  }
-
-  if (flg_found) {
-    *ret_idx = i;
-    return 0;
-  }
-  if (iright <= i)
-    *ret_idx = i;
-  else if (ileft >= i + 2)
-    *ret_idx = i + 1;
-  return -1;
-}
-
-/* Returns true if passed byte is first byte of UTF-8 char sequence */
-static inline bool utf8_is_start_byte_of_char(const uint8_t b) {
-  return 0x80 != (b & 0xC0);
-}
-
-/* This function gets the character at the pstart position, interpreting UTF8 multibyte sequences
-   and returns the pointer to the next character */
-const uint8_t* get_utf8_value_cb(const uint8_t *pstart, read_byte_cb_t cb_read_byte, lchar_t &pval) {
-  uint32_t val = 0;
-  const uint8_t *p = pstart;
-
-  #define NEXT_6_BITS() do{ val <<= 6; p++; valcur = cb_read_byte(p); val |= (valcur & 0x3F); }while(0)
-
-  uint8_t valcur = cb_read_byte(p);
-  if (0 == (0x80 & valcur)) {
-    val = valcur;
-    p++;
-  }
-  else if (0xC0 == (0xE0 & valcur)) {
-    val = valcur & 0x1F;
-    NEXT_6_BITS();
-    p++;
-  }
-  #if MAX_UTF8_CHAR_SIZE >= 3
-    else if (0xE0 == (0xF0 & valcur)) {
-      val = valcur & 0x0F;
-      NEXT_6_BITS();
-      NEXT_6_BITS();
-      p++;
-    }
-  #endif
-  #if MAX_UTF8_CHAR_SIZE >= 4
-    else if (0xF0 == (0xF8 & valcur)) {
-      val = valcur & 0x07;
-      NEXT_6_BITS();
-      NEXT_6_BITS();
-      NEXT_6_BITS();
-      p++;
-    }
-  #endif
-  #if MAX_UTF8_CHAR_SIZE >= 5
-    else if (0xF8 == (0xFC & valcur)) {
-      val = valcur & 0x03;
-      NEXT_6_BITS();
-      NEXT_6_BITS();
-      NEXT_6_BITS();
-      NEXT_6_BITS();
-      p++;
-    }
-  #endif
-  #if MAX_UTF8_CHAR_SIZE >= 6
-    else if (0xFC == (0xFE & valcur)) {
-      val = valcur & 0x01;
-      NEXT_6_BITS();
-      NEXT_6_BITS();
-      NEXT_6_BITS();
-      NEXT_6_BITS();
-      NEXT_6_BITS();
-      p++;
-    }
-  #endif
-  else if (!utf8_is_start_byte_of_char(valcur))
-    for (; !utf8_is_start_byte_of_char(valcur); ) { p++; valcur = cb_read_byte(p); }
-  else
-    for (; 0xFC < (0xFE & valcur); ) { p++; valcur = cb_read_byte(p); }
-
-  pval = val;
-
-  return p;
-}
-
-static inline uint8_t utf8_strlen_cb(const char *pstart, read_byte_cb_t cb_read_byte) {
-  uint8_t cnt = 0;
-  uint8_t *p = (uint8_t *)pstart;
-  if (p) for (;;) {
-    const uint8_t b = cb_read_byte(p);
-    if (!b) break;
-    if (utf8_is_start_byte_of_char(b)) cnt++;
-    p++;
-  }
-  return cnt;
-}
-
-uint8_t utf8_strlen(const char *pstart) {
-  return utf8_strlen_cb(pstart, read_byte_ram);
-}
-
-uint8_t utf8_strlen_P(PGM_P pstart) {
-  return utf8_strlen_cb(pstart, read_byte_rom);
-}
-
-static inline uint8_t utf8_byte_pos_by_char_num_cb(const char *pstart, read_byte_cb_t cb_read_byte, const uint8_t charnum) {
-  uint8_t *p = (uint8_t *)pstart;
-  uint8_t char_idx = 0;
-  uint8_t byte_idx = 0;
-  for (;;) {
-    const uint8_t b = cb_read_byte(p + byte_idx);
-    if (!b) return byte_idx; // Termination byte of string
-    if (utf8_is_start_byte_of_char(b)) {
-      char_idx++;
-      if (char_idx == charnum + 1) return byte_idx;
-    }
-    byte_idx++;
-  }
-}
-
-uint8_t utf8_byte_pos_by_char_num(const char *pstart, const uint8_t charnum) {
-  return utf8_byte_pos_by_char_num_cb(pstart, read_byte_ram, charnum);
-}
-
-uint8_t utf8_byte_pos_by_char_num_P(PGM_P pstart, const uint8_t charnum) {
-  return utf8_byte_pos_by_char_num_cb(pstart, read_byte_rom, charnum);
-}

commit f39e2bc1e428e540e5b031577dce683fb6811cea
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jul 3 23:44:06 2022 -0500

    ü©π Followup for lchar_t

diff --git a/Marlin/src/lcd/fontutils.cpp b/Marlin/src/lcd/fontutils.cpp
index 863c553b57..46329fd4be 100644
--- a/Marlin/src/lcd/fontutils.cpp
+++ b/Marlin/src/lcd/fontutils.cpp
@@ -31,8 +31,6 @@
 
 #include "../inc/MarlinConfig.h"
 
-#define MAX_UTF8_CHAR_SIZE 4
-
 #if HAS_WIRED_LCD
   #include "marlinui.h"
   #include "../MarlinCore.h"

commit 2b6ce3006ecad9573076e5fbac7b2a8dd03e74e7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jul 2 18:29:52 2022 -0500

    ü©π Followup for lchar_t

diff --git a/Marlin/src/lcd/fontutils.cpp b/Marlin/src/lcd/fontutils.cpp
index c8560f541c..863c553b57 100644
--- a/Marlin/src/lcd/fontutils.cpp
+++ b/Marlin/src/lcd/fontutils.cpp
@@ -99,7 +99,7 @@ static inline bool utf8_is_start_byte_of_char(const uint8_t b) {
 
 /* This function gets the character at the pstart position, interpreting UTF8 multibyte sequences
    and returns the pointer to the next character */
-const uint8_t* get_utf8_value_cb(const uint8_t *pstart, read_byte_cb_t cb_read_byte, lchar_t *pval) {
+const uint8_t* get_utf8_value_cb(const uint8_t *pstart, read_byte_cb_t cb_read_byte, lchar_t &pval) {
   uint32_t val = 0;
   const uint8_t *p = pstart;
 
@@ -158,7 +158,7 @@ const uint8_t* get_utf8_value_cb(const uint8_t *pstart, read_byte_cb_t cb_read_b
   else
     for (; 0xFC < (0xFE & valcur); ) { p++; valcur = cb_read_byte(p); }
 
-  if (pval) *pval = val;
+  pval = val;
 
   return p;
 }

commit d956a6ba0075e1b6856a074a566db7574e3f3dcf
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jul 1 21:14:28 2022 -0500

    ü©π Followup for lchar_t

diff --git a/Marlin/src/lcd/fontutils.cpp b/Marlin/src/lcd/fontutils.cpp
index a97e63ac4d..c8560f541c 100644
--- a/Marlin/src/lcd/fontutils.cpp
+++ b/Marlin/src/lcd/fontutils.cpp
@@ -99,7 +99,7 @@ static inline bool utf8_is_start_byte_of_char(const uint8_t b) {
 
 /* This function gets the character at the pstart position, interpreting UTF8 multibyte sequences
    and returns the pointer to the next character */
-const uint8_t* get_utf8_value_cb(const uint8_t *pstart, read_byte_cb_t cb_read_byte, wchar_t *pval) {
+const uint8_t* get_utf8_value_cb(const uint8_t *pstart, read_byte_cb_t cb_read_byte, lchar_t *pval) {
   uint32_t val = 0;
   const uint8_t *p = pstart;
 

commit 8aca38351cd6d33a1202bf9a13890dc8e5eadd49
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 3 22:56:38 2022 -0500

    üßë‚Äçüíª Extend LCD string substitution (#24278)

diff --git a/Marlin/src/lcd/fontutils.cpp b/Marlin/src/lcd/fontutils.cpp
index 50b671ea33..a97e63ac4d 100644
--- a/Marlin/src/lcd/fontutils.cpp
+++ b/Marlin/src/lcd/fontutils.cpp
@@ -40,13 +40,8 @@
 
 #include "fontutils.h"
 
-uint8_t read_byte_ram(uint8_t * str) {
-  return *str;
-}
-
-uint8_t read_byte_rom(uint8_t * str) {
-  return pgm_read_byte(str);
-}
+uint8_t read_byte_ram(const uint8_t *str) { return *str; }
+uint8_t read_byte_rom(const uint8_t *str) { return pgm_read_byte(str); }
 
 /**
  * @brief Using binary search to find the position by data_pin
@@ -104,9 +99,9 @@ static inline bool utf8_is_start_byte_of_char(const uint8_t b) {
 
 /* This function gets the character at the pstart position, interpreting UTF8 multibyte sequences
    and returns the pointer to the next character */
-uint8_t* get_utf8_value_cb(uint8_t *pstart, read_byte_cb_t cb_read_byte, wchar_t *pval) {
+const uint8_t* get_utf8_value_cb(const uint8_t *pstart, read_byte_cb_t cb_read_byte, wchar_t *pval) {
   uint32_t val = 0;
-  uint8_t *p = pstart;
+  const uint8_t *p = pstart;
 
   #define NEXT_6_BITS() do{ val <<= 6; p++; valcur = cb_read_byte(p); val |= (valcur & 0x3F); }while(0)
 

commit 323b38ee88dbf2a4691a20439dbb95a824822199
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Sep 16 04:36:26 2021 -0500

    üí° Adjust headers, formatting

diff --git a/Marlin/src/lcd/fontutils.cpp b/Marlin/src/lcd/fontutils.cpp
index 90fcb2ae7c..50b671ea33 100644
--- a/Marlin/src/lcd/fontutils.cpp
+++ b/Marlin/src/lcd/fontutils.cpp
@@ -1,3 +1,25 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+
 /**
  * @file    fontutils.cpp
  * @brief   help functions for font and char

commit 9bb5b10c0c9cf5a61d2bfb9dfdb6cfe210b6002b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jul 31 05:32:13 2021 -0500

    üöö Relocate and adjust DWIN E3V2 (#22471)

diff --git a/Marlin/src/lcd/fontutils.cpp b/Marlin/src/lcd/fontutils.cpp
index 65c8c06409..90fcb2ae7c 100644
--- a/Marlin/src/lcd/fontutils.cpp
+++ b/Marlin/src/lcd/fontutils.cpp
@@ -149,7 +149,7 @@ uint8_t* get_utf8_value_cb(uint8_t *pstart, read_byte_cb_t cb_read_byte, wchar_t
 static inline uint8_t utf8_strlen_cb(const char *pstart, read_byte_cb_t cb_read_byte) {
   uint8_t cnt = 0;
   uint8_t *p = (uint8_t *)pstart;
-  for (;;) {
+  if (p) for (;;) {
     const uint8_t b = cb_read_byte(p);
     if (!b) break;
     if (utf8_is_start_byte_of_char(b)) cnt++;

commit 99c377b4e4d982c4e8afe388351020efd042a543
Author: LinFor <linfor@gmail.com>
Date:   Fri Nov 13 07:49:19 2020 +0300

    Fix UTF filename scroll (#20121)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/fontutils.cpp b/Marlin/src/lcd/fontutils.cpp
index 4aaf621844..65c8c06409 100644
--- a/Marlin/src/lcd/fontutils.cpp
+++ b/Marlin/src/lcd/fontutils.cpp
@@ -75,6 +75,11 @@ int pf_bsearch_r(void *userdata, size_t num_data, pf_bsearch_cb_comp_t cb_comp,
   return -1;
 }
 
+/* Returns true if passed byte is first byte of UTF-8 char sequence */
+static inline bool utf8_is_start_byte_of_char(const uint8_t b) {
+  return 0x80 != (b & 0xC0);
+}
+
 /* This function gets the character at the pstart position, interpreting UTF8 multibyte sequences
    and returns the pointer to the next character */
 uint8_t* get_utf8_value_cb(uint8_t *pstart, read_byte_cb_t cb_read_byte, wchar_t *pval) {
@@ -131,8 +136,8 @@ uint8_t* get_utf8_value_cb(uint8_t *pstart, read_byte_cb_t cb_read_byte, wchar_t
       p++;
     }
   #endif
-  else if (0x80 == (0xC0 & valcur))
-    for (; 0x80 == (0xC0 & valcur); ) { p++; valcur = cb_read_byte(p); }
+  else if (!utf8_is_start_byte_of_char(valcur))
+    for (; !utf8_is_start_byte_of_char(valcur); ) { p++; valcur = cb_read_byte(p); }
   else
     for (; 0xFC < (0xFE & valcur); ) { p++; valcur = cb_read_byte(p); }
 
@@ -143,12 +148,12 @@ uint8_t* get_utf8_value_cb(uint8_t *pstart, read_byte_cb_t cb_read_byte, wchar_t
 
 static inline uint8_t utf8_strlen_cb(const char *pstart, read_byte_cb_t cb_read_byte) {
   uint8_t cnt = 0;
-  uint8_t *pnext = (uint8_t *)pstart;
+  uint8_t *p = (uint8_t *)pstart;
   for (;;) {
-    wchar_t ch;
-    pnext = get_utf8_value_cb(pnext, cb_read_byte, &ch);
-    if (!ch) break;
-    cnt++;
+    const uint8_t b = cb_read_byte(p);
+    if (!b) break;
+    if (utf8_is_start_byte_of_char(b)) cnt++;
+    p++;
   }
   return cnt;
 }
@@ -160,3 +165,26 @@ uint8_t utf8_strlen(const char *pstart) {
 uint8_t utf8_strlen_P(PGM_P pstart) {
   return utf8_strlen_cb(pstart, read_byte_rom);
 }
+
+static inline uint8_t utf8_byte_pos_by_char_num_cb(const char *pstart, read_byte_cb_t cb_read_byte, const uint8_t charnum) {
+  uint8_t *p = (uint8_t *)pstart;
+  uint8_t char_idx = 0;
+  uint8_t byte_idx = 0;
+  for (;;) {
+    const uint8_t b = cb_read_byte(p + byte_idx);
+    if (!b) return byte_idx; // Termination byte of string
+    if (utf8_is_start_byte_of_char(b)) {
+      char_idx++;
+      if (char_idx == charnum + 1) return byte_idx;
+    }
+    byte_idx++;
+  }
+}
+
+uint8_t utf8_byte_pos_by_char_num(const char *pstart, const uint8_t charnum) {
+  return utf8_byte_pos_by_char_num_cb(pstart, read_byte_ram, charnum);
+}
+
+uint8_t utf8_byte_pos_by_char_num_P(PGM_P pstart, const uint8_t charnum) {
+  return utf8_byte_pos_by_char_num_cb(pstart, read_byte_rom, charnum);
+}

commit 5b9aeb2e5f4abbe152fa4ba5dbb5dd8151d3f6f4
Author: LinFor <linfor@gmail.com>
Date:   Wed Nov 11 23:14:39 2020 +0300

    Handle UTF in long filenames (#20087)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/fontutils.cpp b/Marlin/src/lcd/fontutils.cpp
index 22b54c72de..4aaf621844 100644
--- a/Marlin/src/lcd/fontutils.cpp
+++ b/Marlin/src/lcd/fontutils.cpp
@@ -9,6 +9,8 @@
 
 #include "../inc/MarlinConfig.h"
 
+#define MAX_UTF8_CHAR_SIZE 4
+
 #if HAS_WIRED_LCD
   #include "marlinui.h"
   #include "../MarlinCore.h"
@@ -79,6 +81,8 @@ uint8_t* get_utf8_value_cb(uint8_t *pstart, read_byte_cb_t cb_read_byte, wchar_t
   uint32_t val = 0;
   uint8_t *p = pstart;
 
+  #define NEXT_6_BITS() do{ val <<= 6; p++; valcur = cb_read_byte(p); val |= (valcur & 0x3F); }while(0)
+
   uint8_t valcur = cb_read_byte(p);
   if (0 == (0x80 & valcur)) {
     val = valcur;
@@ -86,74 +90,51 @@ uint8_t* get_utf8_value_cb(uint8_t *pstart, read_byte_cb_t cb_read_byte, wchar_t
   }
   else if (0xC0 == (0xE0 & valcur)) {
     val = valcur & 0x1F;
-    val <<= 6;
-    p++;
-    valcur = cb_read_byte(p);
-    val |= (valcur & 0x3F);
-    p++;
-  }
-  else if (0xE0 == (0xF0 & valcur)) {
-    val = valcur & 0x0F;
-    val <<= 6; p++;
-    valcur = cb_read_byte(p);
-    val |= (valcur & 0x3F);
-    val <<= 6; p++;
-    valcur = cb_read_byte(p);
-    val |= (valcur & 0x3F);
-    p++;
-  }
-  else if (0xF0 == (0xF8 & valcur)) {
-    val = valcur & 0x07;
-    val <<= 6; p++;
-    valcur = cb_read_byte(p);
-    val |= (valcur & 0x3F);
-    val <<= 6; p++;
-    valcur = cb_read_byte(p);
-    val |= (valcur & 0x3F);
-    val <<= 6; p++;
-    valcur = cb_read_byte(p);
-    val |= (valcur & 0x3F);
-    p++;
-  }
-  else if (0xF8 == (0xFC & valcur)) {
-    val = valcur & 0x03;
-    val <<= 6; p++;
-    valcur = cb_read_byte(p);
-    val |= (valcur & 0x3F);
-    val <<= 6; p++;
-    valcur = cb_read_byte(p);
-    val |= (valcur & 0x3F);
-    val <<= 6; p++;
-    valcur = cb_read_byte(p);
-    val |= (valcur & 0x3F);
-    val <<= 6; p++;
-    valcur = cb_read_byte(p);
-    val |= (valcur & 0x3F);
-    p++;
-  }
-  else if (0xFC == (0xFE & valcur)) {
-    val = valcur & 0x01;
-    val <<= 6; p++;
-    valcur = cb_read_byte(p);
-    val |= (valcur & 0x3F);
-    val <<= 6; p++;
-    valcur = cb_read_byte(p);
-    val |= (valcur & 0x3F);
-    val <<= 6; p++;
-    valcur = cb_read_byte(p);
-    val |= (valcur & 0x3F);
-    val <<= 6; p++;
-    valcur = cb_read_byte(p);
-    val |= (valcur & 0x3F);
-    val <<= 6; p++;
-    valcur = cb_read_byte(p);
-    val |= (valcur & 0x3F);
+    NEXT_6_BITS();
     p++;
   }
+  #if MAX_UTF8_CHAR_SIZE >= 3
+    else if (0xE0 == (0xF0 & valcur)) {
+      val = valcur & 0x0F;
+      NEXT_6_BITS();
+      NEXT_6_BITS();
+      p++;
+    }
+  #endif
+  #if MAX_UTF8_CHAR_SIZE >= 4
+    else if (0xF0 == (0xF8 & valcur)) {
+      val = valcur & 0x07;
+      NEXT_6_BITS();
+      NEXT_6_BITS();
+      NEXT_6_BITS();
+      p++;
+    }
+  #endif
+  #if MAX_UTF8_CHAR_SIZE >= 5
+    else if (0xF8 == (0xFC & valcur)) {
+      val = valcur & 0x03;
+      NEXT_6_BITS();
+      NEXT_6_BITS();
+      NEXT_6_BITS();
+      NEXT_6_BITS();
+      p++;
+    }
+  #endif
+  #if MAX_UTF8_CHAR_SIZE >= 6
+    else if (0xFC == (0xFE & valcur)) {
+      val = valcur & 0x01;
+      NEXT_6_BITS();
+      NEXT_6_BITS();
+      NEXT_6_BITS();
+      NEXT_6_BITS();
+      NEXT_6_BITS();
+      p++;
+    }
+  #endif
   else if (0x80 == (0xC0 & valcur))
     for (; 0x80 == (0xC0 & valcur); ) { p++; valcur = cb_read_byte(p); }
   else
-    for (; ((0xFE & valcur) > 0xFC); ) { p++; valcur = cb_read_byte(p); }
+    for (; 0xFC < (0xFE & valcur); ) { p++; valcur = cb_read_byte(p); }
 
   if (pval) *pval = val;
 

commit eaf6777a6643a6fab23ceaaa4699cb2466ea6b83
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Oct 16 19:36:25 2020 -0500

    Rename ultralcd => marlinui

diff --git a/Marlin/src/lcd/fontutils.cpp b/Marlin/src/lcd/fontutils.cpp
index 5bf07e1bd4..22b54c72de 100644
--- a/Marlin/src/lcd/fontutils.cpp
+++ b/Marlin/src/lcd/fontutils.cpp
@@ -10,7 +10,7 @@
 #include "../inc/MarlinConfig.h"
 
 #if HAS_WIRED_LCD
-  #include "ultralcd.h"
+  #include "marlinui.h"
   #include "../MarlinCore.h"
 #endif
 

commit c2c6a679ea4bdf48ce1800a8831fcec36c09ce53
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 28 01:13:27 2020 -0500

    Rename LCD conditionals (#19533)

diff --git a/Marlin/src/lcd/fontutils.cpp b/Marlin/src/lcd/fontutils.cpp
index 8b046af9a7..5bf07e1bd4 100644
--- a/Marlin/src/lcd/fontutils.cpp
+++ b/Marlin/src/lcd/fontutils.cpp
@@ -9,7 +9,7 @@
 
 #include "../inc/MarlinConfig.h"
 
-#if HAS_SPI_LCD
+#if HAS_WIRED_LCD
   #include "ultralcd.h"
   #include "../MarlinCore.h"
 #endif

commit bff0c68078664fcb229e2b9a9d4eb6b858df2dd2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Aug 23 00:12:03 2020 -0500

    Consistent static/value item macros

diff --git a/Marlin/src/lcd/fontutils.cpp b/Marlin/src/lcd/fontutils.cpp
index ffa6d0df70..8b046af9a7 100644
--- a/Marlin/src/lcd/fontutils.cpp
+++ b/Marlin/src/lcd/fontutils.cpp
@@ -73,7 +73,7 @@ int pf_bsearch_r(void *userdata, size_t num_data, pf_bsearch_cb_comp_t cb_comp,
   return -1;
 }
 
-/* This function gets the character at the pstart position, interpreting UTF8 multybyte sequences
+/* This function gets the character at the pstart position, interpreting UTF8 multibyte sequences
    and returns the pointer to the next character */
 uint8_t* get_utf8_value_cb(uint8_t *pstart, read_byte_cb_t cb_read_byte, wchar_t *pval) {
   uint32_t val = 0;
@@ -161,7 +161,6 @@ uint8_t* get_utf8_value_cb(uint8_t *pstart, read_byte_cb_t cb_read_byte, wchar_t
 }
 
 static inline uint8_t utf8_strlen_cb(const char *pstart, read_byte_cb_t cb_read_byte) {
-
   uint8_t cnt = 0;
   uint8_t *pnext = (uint8_t *)pstart;
   for (;;) {

commit d0e1166cce60381fbdad1105d13765806a525d99
Author: Dirk O. Kaar <19971886+dok-net@users.noreply.github.com>
Date:   Fri Jan 3 02:01:38 2020 +0100

    Fix Visual Micro "Arduino IDE for Visual Studio" support (#16418)

diff --git a/Marlin/src/lcd/fontutils.cpp b/Marlin/src/lcd/fontutils.cpp
index fdccd082c3..ffa6d0df70 100644
--- a/Marlin/src/lcd/fontutils.cpp
+++ b/Marlin/src/lcd/fontutils.cpp
@@ -11,7 +11,7 @@
 
 #if HAS_SPI_LCD
   #include "ultralcd.h"
-  #include "../Marlin.h"
+  #include "../MarlinCore.h"
 #endif
 
 #include "fontutils.h"

commit eae543adf34268505f9321b7576495db20293c09
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jul 29 18:45:01 2019 -0500

    Apply HAS_SPI_LCD as needed

diff --git a/Marlin/src/lcd/fontutils.cpp b/Marlin/src/lcd/fontutils.cpp
index 4e714d0804..fdccd082c3 100644
--- a/Marlin/src/lcd/fontutils.cpp
+++ b/Marlin/src/lcd/fontutils.cpp
@@ -9,7 +9,7 @@
 
 #include "../inc/MarlinConfig.h"
 
-#if ENABLED(ULTRA_LCD)
+#if HAS_SPI_LCD
   #include "ultralcd.h"
   #include "../Marlin.h"
 #endif

commit 9abe9aff56d44d42c9dc52679cc9f17592cd0bd4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Apr 8 13:44:35 2019 -0500

    Confirm before starting SD print (#13616)

diff --git a/Marlin/src/lcd/fontutils.cpp b/Marlin/src/lcd/fontutils.cpp
index 5685e6e4c3..4e714d0804 100644
--- a/Marlin/src/lcd/fontutils.cpp
+++ b/Marlin/src/lcd/fontutils.cpp
@@ -10,8 +10,8 @@
 #include "../inc/MarlinConfig.h"
 
 #if ENABLED(ULTRA_LCD)
-#include "ultralcd.h"
-#include "../Marlin.h"
+  #include "ultralcd.h"
+  #include "../Marlin.h"
 #endif
 
 #include "fontutils.h"

commit 0c85869c26bfe177b9f99a2c41554297ee257b63
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Nov 4 18:17:49 2018 -0600

    Clean up file endings

diff --git a/Marlin/src/lcd/fontutils.cpp b/Marlin/src/lcd/fontutils.cpp
index 04b180785f..5685e6e4c3 100644
--- a/Marlin/src/lcd/fontutils.cpp
+++ b/Marlin/src/lcd/fontutils.cpp
@@ -180,4 +180,3 @@ uint8_t utf8_strlen(const char *pstart) {
 uint8_t utf8_strlen_P(PGM_P pstart) {
   return utf8_strlen_cb(pstart, read_byte_rom);
 }
-

commit 11ac75edcb34a2f90b50ca134ff40839f8c29199
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 30 23:44:33 2018 -0500

    Use PGM_P for PSTR pointers (#11977)

diff --git a/Marlin/src/lcd/fontutils.cpp b/Marlin/src/lcd/fontutils.cpp
index 08afb2ed8a..04b180785f 100644
--- a/Marlin/src/lcd/fontutils.cpp
+++ b/Marlin/src/lcd/fontutils.cpp
@@ -177,7 +177,7 @@ uint8_t utf8_strlen(const char *pstart) {
   return utf8_strlen_cb(pstart, read_byte_ram);
 }
 
-uint8_t utf8_strlen_P(const char *pstart) {
+uint8_t utf8_strlen_P(PGM_P pstart) {
   return utf8_strlen_cb(pstart, read_byte_rom);
 }
 

commit 6f330f397e58130dcc9871fba33786575ac37f6f
Author: Eduardo Jos√© Tagle <ejtagle@hotmail.com>
Date:   Sat May 26 01:32:37 2018 -0300

    [2.0.x] Buffer overflow and scroll fix, UTF8 cleanup (#10844)

diff --git a/Marlin/src/lcd/fontutils.cpp b/Marlin/src/lcd/fontutils.cpp
index 39f47bde33..08afb2ed8a 100644
--- a/Marlin/src/lcd/fontutils.cpp
+++ b/Marlin/src/lcd/fontutils.cpp
@@ -16,56 +16,14 @@
 
 #include "fontutils.h"
 
-uint8_t read_byte_ram(uint8_t * str) { return *str; }
-uint8_t read_byte_rom(uint8_t * str) { return pgm_read_byte(str); }
-
-#if DEBUG
-  #ifdef ARDUINO
-    #include <Arduino.h>
-    #include <stdarg.h>
-
-    void serial_printf_P(const char *format, ...) {
-      static char buff[128];
-      va_list args;
-      va_start(args,format);
-      vsnprintf_P(buff,sizeof(buff),format,args);
-      va_end(args);
-      buff[sizeof(buff)/sizeof(buff[0])-1]='\0';
-
-      //Serial.print(buff);
-      SERIAL_ECHO(buff); SERIAL_EOL;
-    }
-  #endif
-#endif
-
-
-#ifdef __WIN32__                // or whatever
-  #define PRIiSZ "ld"
-  #define PRIuSZ "Iu"
-#else
-  #define PRIiSZ "zd"
-  #define PRIuSZ "zu"
-#endif
-#define PRIiOFF "lld"
-#define PRIuOFF "llu"
-
+uint8_t read_byte_ram(uint8_t * str) {
+  return *str;
+}
 
-#define DBGMSG(a,b, ...) TRACE( #__VA_ARGS__ )
+uint8_t read_byte_rom(uint8_t * str) {
+  return pgm_read_byte(str);
+}
 
-//typedef int (* pf_bsearch_cb_comp_t)(void *userdata, size_t idx, void * data_pin); /*"data_list[idx] - *data_pin"*/
-/**
- * @brief ÊäòÂçäÊñπÂºèÊü•ÊâæËÆ∞ÂΩï
- *
- * @param userdata : Áî®Êà∑Êï∞ÊçÆÊåáÈíà
- * @param num_data : Êï∞ÊçÆ‰∏™Êï∞
- * @param cb_comp : ÊØîËæÉ‰∏§‰∏™Êï∞ÊçÆÁöÑÂõûË∞ÉÂáΩÊï∞
- * @param data_pinpoint : ÊâÄË¶ÅÊü•ÊâæÁöÑ ÂåπÈÖçÊï∞ÊçÆÊåáÈíà
- * @param ret_idx : Êü•ÊâæÂà∞ÁöÑ‰ΩçÁΩÆ;Â¶ÇÊûúÊ≤°ÊúâÊâæÂà∞ÔºåÂàôËøîÂõûÂ¶ÇÊ∑ªÂä†ËØ•ËÆ∞ÂΩïÊó∂ÂÖ∂ÊâÄÂú®ÁöÑ‰ΩçÁΩÆ„ÄÇ
- *
- * @return ÊâæÂà∞ÂàôËøîÂõû0ÔºåÂê¶ÂàôËøîÂõû<0
- *
- * ÊäòÂçäÊñπÂºèÊü•ÊâæËÆ∞ÂΩï, psl->marr ‰∏≠ÊåáÂêëÁöÑÊï∞ÊçÆÂ∑≤Áªè‰ª•ÂÖàÂ∞èÂêéÂ§ßÊñπÂºèÊéíÂ•ΩÂ∫è
- */
 /**
  * @brief Using binary search to find the position by data_pin
  *
@@ -82,21 +40,11 @@ uint8_t read_byte_rom(uint8_t * str) { return pgm_read_byte(str); }
 int pf_bsearch_r(void *userdata, size_t num_data, pf_bsearch_cb_comp_t cb_comp, void *data_pinpoint, size_t *ret_idx) {
   int retcomp;
 
-  FU_ASSERT(NULL != ret_idx);
-  /* Êü•ÊâæÂêàÈÄÇÁöÑ‰ΩçÁΩÆ */
   if (num_data < 1) {
     *ret_idx = 0;
-    DBGMSG (PFDBG_CATLOG_PF, PFDBG_LEVEL_ERROR, "num_data(%" PRIuSZ ") < 1", num_data);
     return -1;
   }
 
-  /* ÊäòÂçäÊü•Êâæ */
-  /* ‰∏∫‰∫Ü‰∏çÂá∫Áé∞Ë¥üÊï∞Ôºå‰ª•ÂÖçÁº©Â∞èÁ¥¢ÂºïÁöÑÊâÄË°®Á§∫ÁöÑÊï∞ÊçÆËåÉÂõ¥
-   * (Ë¥üÊï∞Ë°®ÊòéÂáèÂ∞ë‰∏Ä‰Ωç‰∫åËøõÂà∂‰ΩçÁöÑ‰ΩøÁî®)Ôºå
-   * ÂÜÖÈÉ® ileft Âíå iright‰ΩøÁî®‰ªé1ÂºÄÂßãÁöÑ‰∏ãÊ†áÔºå
-   *   Âç≥1Ë°®Á§∫CËØ≠Ë®Ä‰∏≠ÁöÑ0, 2Ë°®Á§∫ËØ≠Ë®Ä‰∏≠ÁöÑ1Ôºå‰ª•Ê≠§Á±ªÊé®„ÄÇ
-   * ÂØπÂ§ñËøòÊòØ‰ΩøÁî®‰ª• 0 ‰∏∫ÂºÄÂßãÁöÑ‰∏ãÊ†á
-   */
   size_t i = 0, ileft = 1, iright = num_data;
   bool flg_found = false;
   for (; ileft <= iright;) {
@@ -122,28 +70,15 @@ int pf_bsearch_r(void *userdata, size_t num_data, pf_bsearch_cb_comp_t cb_comp,
     *ret_idx = i;
   else if (ileft >= i + 2)
     *ret_idx = i + 1;
-  //DBGMSG (PFDBG_CATLOG_PF, PFDBG_LEVEL_DEBUG, "not found! num_data=%" PRIuSZ "; ileft=%" PRIuSZ ", iright=%" PRIuSZ ", i=%" PRIuSZ "", num_data, ileft, iright, i);
   return -1;
 }
 
-/**
- * @brief ËΩ¨Êç¢ UTF-8 ÁºñÁ†ÅÁöÑ‰∏Ä‰∏™Â≠óÁ¨¶‰∏∫Êú¨Âú∞ÁöÑ Unicode Â≠óÁ¨¶(wchar_t)
- *
- * @param pstart : Â≠òÂÇ® UTF-8 Â≠óÁ¨¶ÁöÑÊåáÈíà
- * @param cb_read_byte : ËØªÂèñÂ≠óÁ¨¶ÁöÑÂáΩÊï∞ÔºõÁî®‰∫é8‰ΩçMCU ROM
- * @param pval : ÈúÄË¶ÅËøîÂõûÁöÑ Unicode Â≠óÁ¨¶Â≠òÊîæÂú∞ÂùÄÊåáÈíà
- *
- * @return ÊàêÂäüËøîÂõû‰∏ã‰∏™ UTF-8 Â≠óÁ¨¶ÁöÑ‰ΩçÁΩÆ
- *
- * ËΩ¨Êç¢ UTF-8 ÁºñÁ†ÅÁöÑ‰∏Ä‰∏™Â≠óÁ¨¶‰∏∫Êú¨Âú∞ÁöÑ Unicode Â≠óÁ¨¶(wchar_t)
- */
+/* This function gets the character at the pstart position, interpreting UTF8 multybyte sequences
+   and returns the pointer to the next character */
 uint8_t* get_utf8_value_cb(uint8_t *pstart, read_byte_cb_t cb_read_byte, wchar_t *pval) {
   uint32_t val = 0;
   uint8_t *p = pstart;
 
-  FU_ASSERT(NULL != pstart);
-  FU_ASSERT(NULL != cb_read_byte);
-
   uint8_t valcur = cb_read_byte(p);
   if (0 == (0x80 & valcur)) {
     val = valcur;
@@ -215,113 +150,34 @@ uint8_t* get_utf8_value_cb(uint8_t *pstart, read_byte_cb_t cb_read_byte, wchar_t
     val |= (valcur & 0x3F);
     p++;
   }
-  else if (0x80 == (0xC0 & valcur)) {
-    /* error? */
-    TRACE("ERR 1");
+  else if (0x80 == (0xC0 & valcur))
     for (; 0x80 == (0xC0 & valcur); ) { p++; valcur = cb_read_byte(p); }
-  }
-  else {
-    /* error */
-    TRACE("ERR 2");
+  else
     for (; ((0xFE & valcur) > 0xFC); ) { p++; valcur = cb_read_byte(p); }
-  }
-  /*
-    if (val == 0) {
-      p = NULL;
-  */
-  /*
-    }
-    else if (pstart + maxlen < p) {
-      p = pstart;
-      if (pval) *pval = 0;
-    }
-  */
 
   if (pval) *pval = val;
 
   return p;
 }
 
-// uint8_t * get_utf8_value_cb (uint8_t *pstart, read_byte_cb_t cb_read_byte, wchar_t *pval);
-int utf8_strlen_cb(const char *pstart, read_byte_cb_t cb_read_byte) {
-  wchar_t ch;
-  uint8_t *pnext;
-  int cnt = 0;
+static inline uint8_t utf8_strlen_cb(const char *pstart, read_byte_cb_t cb_read_byte) {
 
-  for (pnext = (uint8_t *)pstart; ; ) {
+  uint8_t cnt = 0;
+  uint8_t *pnext = (uint8_t *)pstart;
+  for (;;) {
+    wchar_t ch;
     pnext = get_utf8_value_cb(pnext, cb_read_byte, &ch);
-    if (pnext == NULL || ch == 0) break;
+    if (!ch) break;
     cnt++;
-    TRACE("cnt=%d, ch=0x%X", cnt, (int)ch);
   }
   return cnt;
 }
 
-int
-my_strlen_P(const char *pstart)
-{
-  const char *p;
-  FU_ASSERT(NULL != pstart);
-  p = pstart;
-  while (p && pgm_read_byte(p) != '\0') p ++;
-  return (p - pstart);
+uint8_t utf8_strlen(const char *pstart) {
+  return utf8_strlen_cb(pstart, read_byte_ram);
 }
 
-uint8_t utf8_strlen(const char *pstart)   { return utf8_strlen_cb(pstart, read_byte_ram); }
-uint8_t utf8_strlen_P(const char *pstart) { return utf8_strlen_cb(pstart, read_byte_rom); }
-
-char* utf8_strncpy_cb( char * destination, const char *source, size_t num, int len_src, read_byte_cb_t cb_read_byte) {
-  uint8_t *p = (uint8_t *)source;
-  uint8_t *d = (uint8_t *)destination;
-
-  FU_ASSERT(NULL != destination);
-  FU_ASSERT(NULL != source);
-  FU_ASSERT(NULL != cb_read_byte);
-
-  uint8_t *pend = p + len_src;
-
-  while (p < pend) {
-    uint8_t valcur = cb_read_byte(p);
-    size_t len = 0;
-    if (0 == (0x80 & valcur))
-      len = 1;
-    else if (0xC0 == (0xE0 & valcur))
-      len = 2;
-    else if (0xE0 == (0xF0 & valcur))
-      len = 3;
-    else if (0xF0 == (0xF8 & valcur))
-      len = 4;
-    else if (0xF8 == (0xFC & valcur))
-      len = 5;
-    else if (0xFC == (0xFE & valcur))
-      len = 6;
-    else if (0x80 == (0xC0 & valcur)) {
-      /* error? */
-      for (; 0x80 == (0xC0 & valcur) && (p < pend); ) { p++; valcur = cb_read_byte(p); }
-    }
-    else {
-      /* error */
-      for (; ((0xFE & valcur) > 0xFC) && (p < pend); ) { p++; valcur = cb_read_byte(p); }
-    }
-    if (len < num) {
-      for (size_t i = 0; i < len; i++) {
-        valcur = cb_read_byte(p);
-        *d = valcur;
-        d++;
-        p++;
-      }
-    }
-    else
-      break;
-  }
-  *d = 0;
-  return destination;
-}
-
-char* utf8_strncpy(char * destination, const char * source, size_t num) {
-  return utf8_strncpy_cb(destination, source, num, strlen(source), read_byte_ram);
+uint8_t utf8_strlen_P(const char *pstart) {
+  return utf8_strlen_cb(pstart, read_byte_rom);
 }
 
-char* utf8_strncpy_P(char * destination, const char * source, size_t num) {
-  return utf8_strncpy_cb(destination, source, num, my_strlen_P(source), read_byte_rom);
-}

commit 744bcaee61a1e9cc7777561a8d1b4611cd36b5c4
Author: Chris Pepper <p3p@p3psoft.co.uk>
Date:   Tue Apr 17 23:28:55 2018 +0100

    [2.0.x] Fix problems compiling with Arduino IDE (#10441)
    
    * Fix problems compiling u8glib utf8 support on Arduino
    * Change header in auto-generated font data
    * Change include in font gen scripts

diff --git a/Marlin/src/lcd/fontutils.cpp b/Marlin/src/lcd/fontutils.cpp
index 2fc5cad3f9..39f47bde33 100644
--- a/Marlin/src/lcd/fontutils.cpp
+++ b/Marlin/src/lcd/fontutils.cpp
@@ -7,7 +7,6 @@
  * @copyright GPL/BSD
  */
 
-#include "../inc/MarlinConfigPre.h"
 #include "../inc/MarlinConfig.h"
 
 #if ENABLED(ULTRA_LCD)

commit c96412a78fbf7be0f1f4bca17edab49d8f1040bf
Author: Yunhui Fu <yhfudev@gmail.com>
Date:   Thu Apr 12 21:14:01 2018 -0400

    [2.0.x] UTF-8 language translation support (#10213)

diff --git a/Marlin/src/lcd/fontutils.cpp b/Marlin/src/lcd/fontutils.cpp
new file mode 100644
index 0000000000..2fc5cad3f9
--- /dev/null
+++ b/Marlin/src/lcd/fontutils.cpp
@@ -0,0 +1,328 @@
+/**
+ * @file    fontutils.cpp
+ * @brief   help functions for font and char
+ * @author  Yunhui Fu (yhfudev@gmail.com)
+ * @version 1.0
+ * @date    2016-08-19
+ * @copyright GPL/BSD
+ */
+
+#include "../inc/MarlinConfigPre.h"
+#include "../inc/MarlinConfig.h"
+
+#if ENABLED(ULTRA_LCD)
+#include "ultralcd.h"
+#include "../Marlin.h"
+#endif
+
+#include "fontutils.h"
+
+uint8_t read_byte_ram(uint8_t * str) { return *str; }
+uint8_t read_byte_rom(uint8_t * str) { return pgm_read_byte(str); }
+
+#if DEBUG
+  #ifdef ARDUINO
+    #include <Arduino.h>
+    #include <stdarg.h>
+
+    void serial_printf_P(const char *format, ...) {
+      static char buff[128];
+      va_list args;
+      va_start(args,format);
+      vsnprintf_P(buff,sizeof(buff),format,args);
+      va_end(args);
+      buff[sizeof(buff)/sizeof(buff[0])-1]='\0';
+
+      //Serial.print(buff);
+      SERIAL_ECHO(buff); SERIAL_EOL;
+    }
+  #endif
+#endif
+
+
+#ifdef __WIN32__                // or whatever
+  #define PRIiSZ "ld"
+  #define PRIuSZ "Iu"
+#else
+  #define PRIiSZ "zd"
+  #define PRIuSZ "zu"
+#endif
+#define PRIiOFF "lld"
+#define PRIuOFF "llu"
+
+
+#define DBGMSG(a,b, ...) TRACE( #__VA_ARGS__ )
+
+//typedef int (* pf_bsearch_cb_comp_t)(void *userdata, size_t idx, void * data_pin); /*"data_list[idx] - *data_pin"*/
+/**
+ * @brief ÊäòÂçäÊñπÂºèÊü•ÊâæËÆ∞ÂΩï
+ *
+ * @param userdata : Áî®Êà∑Êï∞ÊçÆÊåáÈíà
+ * @param num_data : Êï∞ÊçÆ‰∏™Êï∞
+ * @param cb_comp : ÊØîËæÉ‰∏§‰∏™Êï∞ÊçÆÁöÑÂõûË∞ÉÂáΩÊï∞
+ * @param data_pinpoint : ÊâÄË¶ÅÊü•ÊâæÁöÑ ÂåπÈÖçÊï∞ÊçÆÊåáÈíà
+ * @param ret_idx : Êü•ÊâæÂà∞ÁöÑ‰ΩçÁΩÆ;Â¶ÇÊûúÊ≤°ÊúâÊâæÂà∞ÔºåÂàôËøîÂõûÂ¶ÇÊ∑ªÂä†ËØ•ËÆ∞ÂΩïÊó∂ÂÖ∂ÊâÄÂú®ÁöÑ‰ΩçÁΩÆ„ÄÇ
+ *
+ * @return ÊâæÂà∞ÂàôËøîÂõû0ÔºåÂê¶ÂàôËøîÂõû<0
+ *
+ * ÊäòÂçäÊñπÂºèÊü•ÊâæËÆ∞ÂΩï, psl->marr ‰∏≠ÊåáÂêëÁöÑÊï∞ÊçÆÂ∑≤Áªè‰ª•ÂÖàÂ∞èÂêéÂ§ßÊñπÂºèÊéíÂ•ΩÂ∫è
+ */
+/**
+ * @brief Using binary search to find the position by data_pin
+ *
+ * @param userdata : User's data
+ * @param num_data : the item number of the sorted data
+ * @param cb_comp : the callback function to compare the user's data and pin
+ * @param data_pin : The reference data to be found
+ * @param ret_idx : the position of the required data; If failed, then it is the failed position, which is the insert position if possible.
+ *
+ * @return 0 on found, <0 on failed(fail position is saved by ret_idx)
+ *
+ * Using binary search to find the position by data_pin. The user's data should be sorted.
+ */
+int pf_bsearch_r(void *userdata, size_t num_data, pf_bsearch_cb_comp_t cb_comp, void *data_pinpoint, size_t *ret_idx) {
+  int retcomp;
+
+  FU_ASSERT(NULL != ret_idx);
+  /* Êü•ÊâæÂêàÈÄÇÁöÑ‰ΩçÁΩÆ */
+  if (num_data < 1) {
+    *ret_idx = 0;
+    DBGMSG (PFDBG_CATLOG_PF, PFDBG_LEVEL_ERROR, "num_data(%" PRIuSZ ") < 1", num_data);
+    return -1;
+  }
+
+  /* ÊäòÂçäÊü•Êâæ */
+  /* ‰∏∫‰∫Ü‰∏çÂá∫Áé∞Ë¥üÊï∞Ôºå‰ª•ÂÖçÁº©Â∞èÁ¥¢ÂºïÁöÑÊâÄË°®Á§∫ÁöÑÊï∞ÊçÆËåÉÂõ¥
+   * (Ë¥üÊï∞Ë°®ÊòéÂáèÂ∞ë‰∏Ä‰Ωç‰∫åËøõÂà∂‰ΩçÁöÑ‰ΩøÁî®)Ôºå
+   * ÂÜÖÈÉ® ileft Âíå iright‰ΩøÁî®‰ªé1ÂºÄÂßãÁöÑ‰∏ãÊ†áÔºå
+   *   Âç≥1Ë°®Á§∫CËØ≠Ë®Ä‰∏≠ÁöÑ0, 2Ë°®Á§∫ËØ≠Ë®Ä‰∏≠ÁöÑ1Ôºå‰ª•Ê≠§Á±ªÊé®„ÄÇ
+   * ÂØπÂ§ñËøòÊòØ‰ΩøÁî®‰ª• 0 ‰∏∫ÂºÄÂßãÁöÑ‰∏ãÊ†á
+   */
+  size_t i = 0, ileft = 1, iright = num_data;
+  bool flg_found = false;
+  for (; ileft <= iright;) {
+    i = (ileft + iright) / 2 - 1;
+    /* cb_comp should return the *userdata[i] - *data_pinpoint */
+    retcomp = cb_comp (userdata, i, data_pinpoint);
+    if (retcomp > 0)
+      iright = i;
+    else if (retcomp < 0)
+      ileft = i + 2;
+    else {
+      /* found ! */
+      flg_found = true;
+      break;
+    }
+  }
+
+  if (flg_found) {
+    *ret_idx = i;
+    return 0;
+  }
+  if (iright <= i)
+    *ret_idx = i;
+  else if (ileft >= i + 2)
+    *ret_idx = i + 1;
+  //DBGMSG (PFDBG_CATLOG_PF, PFDBG_LEVEL_DEBUG, "not found! num_data=%" PRIuSZ "; ileft=%" PRIuSZ ", iright=%" PRIuSZ ", i=%" PRIuSZ "", num_data, ileft, iright, i);
+  return -1;
+}
+
+/**
+ * @brief ËΩ¨Êç¢ UTF-8 ÁºñÁ†ÅÁöÑ‰∏Ä‰∏™Â≠óÁ¨¶‰∏∫Êú¨Âú∞ÁöÑ Unicode Â≠óÁ¨¶(wchar_t)
+ *
+ * @param pstart : Â≠òÂÇ® UTF-8 Â≠óÁ¨¶ÁöÑÊåáÈíà
+ * @param cb_read_byte : ËØªÂèñÂ≠óÁ¨¶ÁöÑÂáΩÊï∞ÔºõÁî®‰∫é8‰ΩçMCU ROM
+ * @param pval : ÈúÄË¶ÅËøîÂõûÁöÑ Unicode Â≠óÁ¨¶Â≠òÊîæÂú∞ÂùÄÊåáÈíà
+ *
+ * @return ÊàêÂäüËøîÂõû‰∏ã‰∏™ UTF-8 Â≠óÁ¨¶ÁöÑ‰ΩçÁΩÆ
+ *
+ * ËΩ¨Êç¢ UTF-8 ÁºñÁ†ÅÁöÑ‰∏Ä‰∏™Â≠óÁ¨¶‰∏∫Êú¨Âú∞ÁöÑ Unicode Â≠óÁ¨¶(wchar_t)
+ */
+uint8_t* get_utf8_value_cb(uint8_t *pstart, read_byte_cb_t cb_read_byte, wchar_t *pval) {
+  uint32_t val = 0;
+  uint8_t *p = pstart;
+
+  FU_ASSERT(NULL != pstart);
+  FU_ASSERT(NULL != cb_read_byte);
+
+  uint8_t valcur = cb_read_byte(p);
+  if (0 == (0x80 & valcur)) {
+    val = valcur;
+    p++;
+  }
+  else if (0xC0 == (0xE0 & valcur)) {
+    val = valcur & 0x1F;
+    val <<= 6;
+    p++;
+    valcur = cb_read_byte(p);
+    val |= (valcur & 0x3F);
+    p++;
+  }
+  else if (0xE0 == (0xF0 & valcur)) {
+    val = valcur & 0x0F;
+    val <<= 6; p++;
+    valcur = cb_read_byte(p);
+    val |= (valcur & 0x3F);
+    val <<= 6; p++;
+    valcur = cb_read_byte(p);
+    val |= (valcur & 0x3F);
+    p++;
+  }
+  else if (0xF0 == (0xF8 & valcur)) {
+    val = valcur & 0x07;
+    val <<= 6; p++;
+    valcur = cb_read_byte(p);
+    val |= (valcur & 0x3F);
+    val <<= 6; p++;
+    valcur = cb_read_byte(p);
+    val |= (valcur & 0x3F);
+    val <<= 6; p++;
+    valcur = cb_read_byte(p);
+    val |= (valcur & 0x3F);
+    p++;
+  }
+  else if (0xF8 == (0xFC & valcur)) {
+    val = valcur & 0x03;
+    val <<= 6; p++;
+    valcur = cb_read_byte(p);
+    val |= (valcur & 0x3F);
+    val <<= 6; p++;
+    valcur = cb_read_byte(p);
+    val |= (valcur & 0x3F);
+    val <<= 6; p++;
+    valcur = cb_read_byte(p);
+    val |= (valcur & 0x3F);
+    val <<= 6; p++;
+    valcur = cb_read_byte(p);
+    val |= (valcur & 0x3F);
+    p++;
+  }
+  else if (0xFC == (0xFE & valcur)) {
+    val = valcur & 0x01;
+    val <<= 6; p++;
+    valcur = cb_read_byte(p);
+    val |= (valcur & 0x3F);
+    val <<= 6; p++;
+    valcur = cb_read_byte(p);
+    val |= (valcur & 0x3F);
+    val <<= 6; p++;
+    valcur = cb_read_byte(p);
+    val |= (valcur & 0x3F);
+    val <<= 6; p++;
+    valcur = cb_read_byte(p);
+    val |= (valcur & 0x3F);
+    val <<= 6; p++;
+    valcur = cb_read_byte(p);
+    val |= (valcur & 0x3F);
+    p++;
+  }
+  else if (0x80 == (0xC0 & valcur)) {
+    /* error? */
+    TRACE("ERR 1");
+    for (; 0x80 == (0xC0 & valcur); ) { p++; valcur = cb_read_byte(p); }
+  }
+  else {
+    /* error */
+    TRACE("ERR 2");
+    for (; ((0xFE & valcur) > 0xFC); ) { p++; valcur = cb_read_byte(p); }
+  }
+  /*
+    if (val == 0) {
+      p = NULL;
+  */
+  /*
+    }
+    else if (pstart + maxlen < p) {
+      p = pstart;
+      if (pval) *pval = 0;
+    }
+  */
+
+  if (pval) *pval = val;
+
+  return p;
+}
+
+// uint8_t * get_utf8_value_cb (uint8_t *pstart, read_byte_cb_t cb_read_byte, wchar_t *pval);
+int utf8_strlen_cb(const char *pstart, read_byte_cb_t cb_read_byte) {
+  wchar_t ch;
+  uint8_t *pnext;
+  int cnt = 0;
+
+  for (pnext = (uint8_t *)pstart; ; ) {
+    pnext = get_utf8_value_cb(pnext, cb_read_byte, &ch);
+    if (pnext == NULL || ch == 0) break;
+    cnt++;
+    TRACE("cnt=%d, ch=0x%X", cnt, (int)ch);
+  }
+  return cnt;
+}
+
+int
+my_strlen_P(const char *pstart)
+{
+  const char *p;
+  FU_ASSERT(NULL != pstart);
+  p = pstart;
+  while (p && pgm_read_byte(p) != '\0') p ++;
+  return (p - pstart);
+}
+
+uint8_t utf8_strlen(const char *pstart)   { return utf8_strlen_cb(pstart, read_byte_ram); }
+uint8_t utf8_strlen_P(const char *pstart) { return utf8_strlen_cb(pstart, read_byte_rom); }
+
+char* utf8_strncpy_cb( char * destination, const char *source, size_t num, int len_src, read_byte_cb_t cb_read_byte) {
+  uint8_t *p = (uint8_t *)source;
+  uint8_t *d = (uint8_t *)destination;
+
+  FU_ASSERT(NULL != destination);
+  FU_ASSERT(NULL != source);
+  FU_ASSERT(NULL != cb_read_byte);
+
+  uint8_t *pend = p + len_src;
+
+  while (p < pend) {
+    uint8_t valcur = cb_read_byte(p);
+    size_t len = 0;
+    if (0 == (0x80 & valcur))
+      len = 1;
+    else if (0xC0 == (0xE0 & valcur))
+      len = 2;
+    else if (0xE0 == (0xF0 & valcur))
+      len = 3;
+    else if (0xF0 == (0xF8 & valcur))
+      len = 4;
+    else if (0xF8 == (0xFC & valcur))
+      len = 5;
+    else if (0xFC == (0xFE & valcur))
+      len = 6;
+    else if (0x80 == (0xC0 & valcur)) {
+      /* error? */
+      for (; 0x80 == (0xC0 & valcur) && (p < pend); ) { p++; valcur = cb_read_byte(p); }
+    }
+    else {
+      /* error */
+      for (; ((0xFE & valcur) > 0xFC) && (p < pend); ) { p++; valcur = cb_read_byte(p); }
+    }
+    if (len < num) {
+      for (size_t i = 0; i < len; i++) {
+        valcur = cb_read_byte(p);
+        *d = valcur;
+        d++;
+        p++;
+      }
+    }
+    else
+      break;
+  }
+  *d = 0;
+  return destination;
+}
+
+char* utf8_strncpy(char * destination, const char * source, size_t num) {
+  return utf8_strncpy_cb(destination, source, num, strlen(source), read_byte_ram);
+}
+
+char* utf8_strncpy_P(char * destination, const char * source, size_t num) {
+  return utf8_strncpy_cb(destination, source, num, my_strlen_P(source), read_byte_rom);
+}
