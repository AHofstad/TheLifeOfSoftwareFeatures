commit 1da947f54806437fdff84adfdc06f48d2e3d60a3
Author: narno2202 <130909513+narno2202@users.noreply.github.com>
Date:   Thu May 9 23:57:23 2024 +0200

    ‚ö°Ô∏è FT_MOTION : Core and other refinements (#26720)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>
    Co-authored-by: Ulendo Alex <alex@ulendo.io>

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 09154b65a2..d0ad234a7f 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -50,6 +50,10 @@
   #include "../feature/joystick.h"
 #endif
 
+#if ENABLED(FT_MOTION)
+  #include "ft_motion.h"
+#endif
+
 #if HAS_BED_PROBE
   #include "probe.h"
 #endif
@@ -782,6 +786,7 @@ void Endstops::update() {
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_DUAL_ENDSTOP(Z, MINMAX)
   #endif
 
+
   #if ENABLED(G38_PROBE_TARGET)
     // For G38 moves check the probe's pin for ALL movement
     if (G38_move && TEST_ENDSTOP(Z_MIN_PROBE) == TERN1(G38_PROBE_AWAY, (G38_move < 4))) {
@@ -796,8 +801,17 @@ void Endstops::update() {
   // Signal, after validation, if an endstop limit is pressed or not
 
   #if HAS_X_AXIS
-    if (stepper.axis_is_moving(X_AXIS)) {
-      if (!stepper.motor_direction(X_AXIS_HEAD)) { // -direction
+    #if ENABLED(FT_MOTION)
+      const bool x_moving_pos = ftMotion.axis_moving_pos(X_AXIS_HEAD),
+                 x_moving_neg = ftMotion.axis_moving_neg(X_AXIS_HEAD);
+      #define X_MOVE_TEST x_moving_pos || x_moving_neg
+      #define X_NEG_DIR_TEST x_moving_neg
+    #else
+      #define X_MOVE_TEST stepper.axis_is_moving(X_AXIS)
+      #define X_NEG_DIR_TEST !stepper.motor_direction(X_AXIS_HEAD)
+    #endif
+    if (X_MOVE_TEST) {
+      if (X_NEG_DIR_TEST) { // -direction
         #if HAS_X_MIN_STATE
           PROCESS_ENDSTOP_X(MIN);
           #if   CORE_DIAG(XY, Y, MIN)
@@ -829,8 +843,17 @@ void Endstops::update() {
   #endif // HAS_X_AXIS
 
   #if HAS_Y_AXIS
-    if (stepper.axis_is_moving(Y_AXIS)) {
-      if (!stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
+    #if ENABLED(FT_MOTION)
+      const bool y_moving_pos = ftMotion.axis_moving_pos(Y_AXIS_HEAD),
+                 y_moving_neg = ftMotion.axis_moving_neg(Y_AXIS_HEAD);
+      #define Y_MOVE_TEST y_moving_pos || y_moving_neg
+      #define Y_NEG_DIR_TEST y_moving_neg
+    #else
+      #define Y_MOVE_TEST stepper.axis_is_moving(Y_AXIS)
+      #define Y_NEG_DIR_TEST !stepper.motor_direction(Y_AXIS_HEAD)
+    #endif
+    if (Y_MOVE_TEST) {
+      if (Y_NEG_DIR_TEST) { // -direction
         #if HAS_Y_MIN_STATE
           PROCESS_ENDSTOP_Y(MIN);
           #if   CORE_DIAG(XY, X, MIN)
@@ -862,8 +885,17 @@ void Endstops::update() {
   #endif // HAS_Y_AXIS
 
   #if HAS_Z_AXIS
-    if (stepper.axis_is_moving(Z_AXIS)) {
-      if (!stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
+    #if ENABLED(FT_MOTION)
+      const bool z_moving_pos = ftMotion.axis_moving_pos(Z_AXIS_HEAD),
+                 z_moving_neg = ftMotion.axis_moving_neg(Z_AXIS_HEAD);
+      #define Z_MOVE_TEST z_moving_pos || z_moving_neg
+      #define Z_NEG_DIR_TEST z_moving_neg
+    #else
+      #define Z_MOVE_TEST stepper.axis_is_moving(Z_AXIS)
+      #define Z_NEG_DIR_TEST !stepper.motor_direction(Z_AXIS_HEAD)
+    #endif
+    if (Z_MOVE_TEST) {
+      if (Z_NEG_DIR_TEST) { // Z -direction. Gantry down, bed up.
         #if HAS_Z_MIN_STATE
           // If the Z_MIN_PIN is being used for the probe there's no
           // separate Z_MIN endstop. But a Z endstop could be wired
@@ -907,6 +939,7 @@ void Endstops::update() {
   #endif // HAS_Z_AXIS
 
   #if HAS_I_AXIS
+  // TODO: FT_Motion logic.
     if (stepper.axis_is_moving(I_AXIS)) {
       if (!stepper.motor_direction(I_AXIS_HEAD)) { // -direction
         #if HAS_I_MIN_STATE

commit 49348716f538a16f7232efb0eed5d4e01d5a1494
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Mon May 6 19:58:00 2024 -0400

    ü©π Fix printf et.al. expecting F-strings (#27032)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 490d6bc2ce..09154b65a2 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -351,7 +351,7 @@ void Endstops::event_handler() {
     TERN_(HAS_STATUS_MESSAGE,
       ui.status_printf(0,
         F(S_FMT GANG_N_1(NUM_AXES, " %c") " %c"),
-        GET_TEXT(MSG_LCD_ENDSTOPS),
+        GET_TEXT_F(MSG_LCD_ENDSTOPS),
         NUM_AXIS_LIST_(chrX, chrY, chrZ, chrI, chrJ, chrK, chrU, chrV, chrW) chrP
       )
     );

commit ce8535f01ca4b85ca1f7cae3908d3174ac11fff6
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jan 26 15:18:38 2024 -0600

    üßë‚Äçüíª Fix warning, adjust tests

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 9c6a3c011c..490d6bc2ce 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -788,7 +788,7 @@ void Endstops::update() {
       G38_did_trigger = true;
       #define _G38_SET(Q) | (stepper.axis_is_moving(_AXIS(Q)) << _AXIS(Q))
       #define _G38_RESP(Q) if (moving[_AXIS(Q)]) { _ENDSTOP_HIT(Q, ENDSTOP); planner.endstop_triggered(_AXIS(Q)); }
-      const Flags<NUM_AXES> moving = { value_t(NUM_AXES)(0 MAIN_AXIS_MAP(_G38_SET)) };
+      const Flags<NUM_AXES> moving = { uvalue_t(NUM_AXES)(0 MAIN_AXIS_MAP(_G38_SET)) };
       MAIN_AXIS_MAP(_G38_RESP);
     }
   #endif

commit 1a42c38e0eefdf62976bf7a5a35224d3c675f9ff
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Sat Dec 2 22:03:46 2023 -0800

    ü©π Replace more DEBUG_ECHOF (#26495)
    
    Followup to #25928

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 0f060f5720..9c6a3c011c 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -1360,7 +1360,7 @@ void Endstops::update() {
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         auto debug_current = [](FSTR_P const s, const int16_t a, const int16_t b) {
-          if (DEBUGGING(LEVELING)) { DEBUG_ECHOF(s); DEBUG_ECHOLNPGM(" current: ", a, " -> ", b); }
+          if (DEBUGGING(LEVELING)) { DEBUG_ECHOLN(s, F(" current: "), a, F(" -> "), b); }
         };
       #else
         #define debug_current(...)

commit bed26734a28175f7ef9669d5190bf7ebc6227223
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Aug 1 23:03:06 2023 -0500

    üîß More endstops refactoring (#25758)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 3c1fcc72a9..0f060f5720 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -138,7 +138,7 @@ void Endstops::init() {
   #if USE_Y2_MAX
     _INIT_ENDSTOP(MAX,Y,2);
   #endif
-  #if HAS_Z_MIN_PIN
+  #if USE_Z_MIN
     _INIT_ENDSTOP(MIN,Z,);
   #endif
   #if USE_Z_MAX
@@ -315,7 +315,7 @@ void Endstops::event_handler() {
       SERIAL_ECHOPGM(" " STRINGIFY(A) ":", planner.triggered_position_mm(_AXIS(A))); _SET_STOP_CHAR(A,C); }while(0)
 
     #define _ENDSTOP_HIT_TEST(A,C) \
-      if (TERN0(USE_##A##_MIN, TEST(hit_state, ES_ENUM(A,MIN))) || TERN0(USE_##A##_MAX, TEST(hit_state, ES_ENUM(A,MAX)))) \
+      if (TERN0(HAS_##A##_MIN_STATE, TEST(hit_state, ES_ENUM(A,MIN))) || TERN0(HAS_##A##_MAX_STATE, TEST(hit_state, ES_ENUM(A,MAX)))) \
         _ENDSTOP_HIT_ECHO(A,C)
 
     #define ENDSTOP_HIT_TEST_X() _ENDSTOP_HIT_TEST(X,'X')
@@ -504,11 +504,6 @@ void __O2 Endstops::report_states() {
 
 } // Endstops::report_states
 
-#define __ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
-#define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN
-#define _ENDSTOP_HIT_STATE(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_HIT_STATE
-#define _ENDSTOP(AXIS, MINMAX) __ENDSTOP(AXIS, MINMAX)
-
 /**
  * Called from interrupt context by the Endstop ISR or Stepper ISR!
  * Read endstops to get their current states, register hits for all
@@ -521,7 +516,9 @@ void Endstops::update() {
   #endif
 
   // Macros to update / copy the live_state
-  #define UPDATE_LIVE_STATE(AXIS, MINMAX) SET_BIT_TO(live_state, _ENDSTOP(AXIS, MINMAX), (READ_ENDSTOP(_ENDSTOP_PIN(AXIS, MINMAX)) == _ENDSTOP_HIT_STATE(AXIS, MINMAX)))
+  #define _ES_PIN(A,M) A##_##M##_PIN
+  #define _ES_HIT(A,M) A##_##M##_ENDSTOP_HIT_STATE
+  #define UPDATE_LIVE_STATE(AXIS, MINMAX) SET_BIT_TO(live_state, ES_ENUM(AXIS, MINMAX), (READ_ENDSTOP(_ES_PIN(AXIS, MINMAX)) == _ES_HIT(AXIS, MINMAX)))
   #define COPY_LIVE_STATE(SRC_BIT, DST_BIT) SET_BIT_TO(live_state, DST_BIT, TEST(live_state, SRC_BIT))
 
   #if ENABLED(G38_PROBE_TARGET)
@@ -560,7 +557,7 @@ void Endstops::update() {
   /**
    * Check and update endstops
    */
-  #if USE_X_MIN && !X_SPI_SENSORLESS
+  #if USE_X_MIN
     UPDATE_LIVE_STATE(X, MIN);
     #if ENABLED(X_DUAL_ENDSTOPS)
       #if USE_X2_MIN
@@ -571,7 +568,7 @@ void Endstops::update() {
     #endif
   #endif
 
-  #if USE_X_MAX && !X_SPI_SENSORLESS
+  #if USE_X_MAX
     UPDATE_LIVE_STATE(X, MAX);
     #if ENABLED(X_DUAL_ENDSTOPS)
       #if USE_X2_MAX
@@ -582,7 +579,7 @@ void Endstops::update() {
     #endif
   #endif
 
-  #if USE_Y_MIN && !Y_SPI_SENSORLESS
+  #if USE_Y_MIN
     UPDATE_LIVE_STATE(Y, MIN);
     #if ENABLED(Y_DUAL_ENDSTOPS)
       #if USE_Y2_MIN
@@ -593,7 +590,7 @@ void Endstops::update() {
     #endif
   #endif
 
-  #if USE_Y_MAX && !Y_SPI_SENSORLESS
+  #if USE_Y_MAX
     UPDATE_LIVE_STATE(Y, MAX);
     #if ENABLED(Y_DUAL_ENDSTOPS)
       #if USE_Y2_MAX
@@ -605,159 +602,84 @@ void Endstops::update() {
   #endif
 
   #if USE_Z_MIN && NONE(Z_SPI_SENSORLESS, Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
-    #if HAS_Z_MIN_PIN
-      UPDATE_LIVE_STATE(Z, MIN);
-    #endif
-    #if ENABLED(Z_MULTI_ENDSTOPS)
-      #if USE_Z2_MIN
-        UPDATE_LIVE_STATE(Z2, MIN);
-      #else
-        COPY_LIVE_STATE(Z_MIN, Z2_MIN);
-      #endif
-      #if NUM_Z_STEPPERS >= 3
-        #if USE_Z3_MIN
-          UPDATE_LIVE_STATE(Z3, MIN);
-        #else
-          COPY_LIVE_STATE(Z_MIN, Z3_MIN);
-        #endif
-      #endif
-      #if NUM_Z_STEPPERS >= 4
-        #if USE_Z4_MIN
-          UPDATE_LIVE_STATE(Z4, MIN);
-        #else
-          COPY_LIVE_STATE(Z_MIN, Z4_MIN);
-        #endif
-      #endif
-    #endif
+    UPDATE_LIVE_STATE(Z, MIN);
+  #endif
+  #if USE_Z2_MIN
+    UPDATE_LIVE_STATE(Z2, MIN);
+  #elif HAS_Z2_MIN_STATE
+    COPY_LIVE_STATE(Z_MIN, Z2_MIN);
+  #endif
+  #if USE_Z3_MIN
+    UPDATE_LIVE_STATE(Z3, MIN);
+  #elif HAS_Z3_MIN_STATE
+    COPY_LIVE_STATE(Z_MIN, Z3_MIN);
+  #endif
+  #if USE_Z4_MIN
+    UPDATE_LIVE_STATE(Z4, MIN);
+  #elif HAS_Z4_MIN_STATE
+    COPY_LIVE_STATE(Z_MIN, Z4_MIN);
   #endif
 
-  #if HAS_BED_PROBE
+  #if HAS_REAL_BED_PROBE
     // When closing the gap check the enabled probe
     if (probe_switch_activated())
       UPDATE_LIVE_STATE(Z, TERN(USE_Z_MIN_PROBE, MIN_PROBE, MIN));
   #endif
 
-  #if USE_Z_MAX && !Z_SPI_SENSORLESS
-    // Check both Z dual endstops
-    #if ENABLED(Z_MULTI_ENDSTOPS)
-      UPDATE_LIVE_STATE(Z, MAX);
-      #if USE_Z2_MAX
-        UPDATE_LIVE_STATE(Z2, MAX);
-      #else
-        COPY_LIVE_STATE(Z_MAX, Z2_MAX);
-      #endif
-      #if NUM_Z_STEPPERS >= 3
-        #if USE_Z3_MAX
-          UPDATE_LIVE_STATE(Z3, MAX);
-        #else
-          COPY_LIVE_STATE(Z_MAX, Z3_MAX);
-        #endif
-      #endif
-      #if NUM_Z_STEPPERS >= 4
-        #if USE_Z4_MAX
-          UPDATE_LIVE_STATE(Z4, MAX);
-        #else
-          COPY_LIVE_STATE(Z_MAX, Z4_MAX);
-        #endif
-      #endif
-    #elif TERN1(USE_Z_MIN_PROBE, Z_MAX_PIN != Z_MIN_PROBE_PIN)
-      // If this pin isn't the bed probe it's the Z endstop
-      UPDATE_LIVE_STATE(Z, MAX);
-    #endif
+  #if USE_Z_MAX
+    UPDATE_LIVE_STATE(Z, MAX);
   #endif
-
-  #if USE_I_MIN && !I_SPI_SENSORLESS
-    #if ENABLED(I_DUAL_ENDSTOPS)
-      UPDATE_LIVE_STATE(I, MIN);
-    #else
-      UPDATE_LIVE_STATE(I, MIN);
-    #endif
+  #if USE_Z2_MAX
+    UPDATE_LIVE_STATE(Z2, MAX);
+  #elif HAS_Z2_MAX_STATE
+    COPY_LIVE_STATE(Z_MAX, Z2_MAX);
   #endif
-
-  #if USE_I_MAX && !I_SPI_SENSORLESS
-    #if ENABLED(I_DUAL_ENDSTOPS)
-      UPDATE_LIVE_STATE(I, MAX);
-    #else
-      UPDATE_LIVE_STATE(I, MAX);
-    #endif
+  #if USE_Z3_MAX
+    UPDATE_LIVE_STATE(Z3, MAX);
+  #elif HAS_Z3_MAX_STATE
+    COPY_LIVE_STATE(Z_MAX, Z3_MAX);
   #endif
-
-  #if USE_J_MIN && !J_SPI_SENSORLESS
-    #if ENABLED(J_DUAL_ENDSTOPS)
-      UPDATE_LIVE_STATE(J, MIN);
-    #else
-      UPDATE_LIVE_STATE(J, MIN);
-    #endif
+  #if USE_Z4_MAX
+    UPDATE_LIVE_STATE(Z4, MAX);
+  #elif HAS_Z4_MAX_STATE
+    COPY_LIVE_STATE(Z_MAX, Z4_MAX);
   #endif
 
-  #if USE_J_MAX && !J_SPI_SENSORLESS
-    #if ENABLED(J_DUAL_ENDSTOPS)
-      UPDATE_LIVE_STATE(J, MAX);
-    #else
-      UPDATE_LIVE_STATE(J, MAX);
-    #endif
+  #if USE_I_MIN
+    UPDATE_LIVE_STATE(I, MIN);
   #endif
-
-  #if USE_K_MIN && !K_SPI_SENSORLESS
-    #if ENABLED(K_DUAL_ENDSTOPS)
-      UPDATE_LIVE_STATE(K, MIN);
-    #else
-      UPDATE_LIVE_STATE(K, MIN);
-    #endif
+  #if USE_I_MAX
+    UPDATE_LIVE_STATE(I, MAX);
   #endif
-
-  #if USE_K_MAX && !K_SPI_SENSORLESS
-    #if ENABLED(K_DUAL_ENDSTOPS)
-      UPDATE_LIVE_STATE(K, MAX);
-    #else
-      UPDATE_LIVE_STATE(K, MAX);
-    #endif
+  #if USE_J_MIN
+    UPDATE_LIVE_STATE(J, MIN);
   #endif
-
-  #if USE_U_MIN && !U_SPI_SENSORLESS
-    #if ENABLED(U_DUAL_ENDSTOPS)
-      UPDATE_LIVE_STATE(U, MIN);
-    #else
-      UPDATE_LIVE_STATE(U, MIN);
-    #endif
+  #if USE_J_MAX
+    UPDATE_LIVE_STATE(J, MAX);
   #endif
-
-  #if USE_U_MAX && !U_SPI_SENSORLESS
-    #if ENABLED(U_DUAL_ENDSTOPS)
-      UPDATE_LIVE_STATE(U, MAX);
-    #else
-      UPDATE_LIVE_STATE(U, MAX);
-    #endif
+  #if USE_K_MIN
+    UPDATE_LIVE_STATE(K, MIN);
   #endif
-
-  #if USE_V_MIN && !V_SPI_SENSORLESS
-    #if ENABLED(V_DUAL_ENDSTOPS)
-      UPDATE_LIVE_STATE(V, MIN);
-    #else
-      UPDATE_LIVE_STATE(V, MIN);
-    #endif
+  #if USE_K_MAX
+    UPDATE_LIVE_STATE(K, MAX);
   #endif
-  #if USE_V_MAX && !V_SPI_SENSORLESS
-    #if ENABLED(O_DUAL_ENDSTOPS)
-      UPDATE_LIVE_STATE(V, MAX);
-    #else
-      UPDATE_LIVE_STATE(V, MAX);
-    #endif
+  #if USE_U_MIN
+    UPDATE_LIVE_STATE(U, MIN);
   #endif
-
-  #if USE_W_MIN && !W_SPI_SENSORLESS
-    #if ENABLED(W_DUAL_ENDSTOPS)
-      UPDATE_LIVE_STATE(W, MIN);
-    #else
-      UPDATE_LIVE_STATE(W, MIN);
-    #endif
+  #if USE_U_MAX
+    UPDATE_LIVE_STATE(U, MAX);
   #endif
-  #if USE_W_MAX && !W_SPI_SENSORLESS
-    #if ENABLED(W_DUAL_ENDSTOPS)
-      UPDATE_LIVE_STATE(W, MAX);
-    #else
-      UPDATE_LIVE_STATE(W, MAX);
-    #endif
+  #if USE_V_MIN
+    UPDATE_LIVE_STATE(V, MIN);
+  #endif
+  #if USE_V_MAX
+    UPDATE_LIVE_STATE(V, MAX);
+  #endif
+  #if USE_W_MIN
+    UPDATE_LIVE_STATE(W, MIN);
+  #endif
+  #if USE_W_MAX
+    UPDATE_LIVE_STATE(W, MAX);
   #endif
 
   #if ENDSTOP_NOISE_THRESHOLD
@@ -788,11 +710,11 @@ void Endstops::update() {
   #define TEST_ENDSTOP(ENDSTOP) (TEST(state(), ENDSTOP))
 
   // Record endstop was hit
-  #define _ENDSTOP_HIT(AXIS, MINMAX) SBI(hit_state, _ENDSTOP(AXIS, MINMAX))
+  #define _ENDSTOP_HIT(AXIS, MINMAX) SBI(hit_state, ES_ENUM(AXIS, MINMAX))
 
   // Call the endstop triggered routine for single endstops
   #define PROCESS_ENDSTOP(AXIS, MINMAX) do { \
-    if (TEST_ENDSTOP(_ENDSTOP(AXIS, MINMAX))) { \
+    if (TEST_ENDSTOP(ES_ENUM(AXIS, MINMAX))) { \
       _ENDSTOP_HIT(AXIS, MINMAX); \
       planner.endstop_triggered(_AXIS(AXIS)); \
     } \
@@ -801,7 +723,7 @@ void Endstops::update() {
   // Core Sensorless Homing needs to test an Extra Pin
   #define CORE_DIAG(QQ,A,MM) (CORE_IS_##QQ && A##_SENSORLESS && !A##_SPI_SENSORLESS && USE_##A##_##MM)
   #define PROCESS_CORE_ENDSTOP(A1,M1,A2,M2) do { \
-    if (TEST_ENDSTOP(_ENDSTOP(A1,M1))) { \
+    if (TEST_ENDSTOP(ES_ENUM(A1,M1))) { \
       _ENDSTOP_HIT(A2,M2); \
       planner.endstop_triggered(_AXIS(A2)); \
     } \
@@ -809,7 +731,7 @@ void Endstops::update() {
 
   // Call the endstop triggered routine for dual endstops
   #define PROCESS_DUAL_ENDSTOP(A, MINMAX) do { \
-    const byte dual_hit = TEST_ENDSTOP(_ENDSTOP(A, MINMAX)) | (TEST_ENDSTOP(_ENDSTOP(A##2, MINMAX)) << 1); \
+    const byte dual_hit = TEST_ENDSTOP(ES_ENUM(A, MINMAX)) | (TEST_ENDSTOP(ES_ENUM(A##2, MINMAX)) << 1); \
     if (dual_hit) { \
       _ENDSTOP_HIT(A, MINMAX); \
       /* if not performing home or if both endstops were triggered during homing... */ \
@@ -819,7 +741,7 @@ void Endstops::update() {
   }while(0)
 
   #define PROCESS_TRIPLE_ENDSTOP(A, MINMAX) do { \
-    const byte triple_hit = TEST_ENDSTOP(_ENDSTOP(A, MINMAX)) | (TEST_ENDSTOP(_ENDSTOP(A##2, MINMAX)) << 1) | (TEST_ENDSTOP(_ENDSTOP(A##3, MINMAX)) << 2); \
+    const byte triple_hit = TEST_ENDSTOP(ES_ENUM(A, MINMAX)) | (TEST_ENDSTOP(ES_ENUM(A##2, MINMAX)) << 1) | (TEST_ENDSTOP(ES_ENUM(A##3, MINMAX)) << 2); \
     if (triple_hit) { \
       _ENDSTOP_HIT(A, MINMAX); \
       /* if not performing home or if both endstops were triggered during homing... */ \
@@ -829,7 +751,7 @@ void Endstops::update() {
   }while(0)
 
   #define PROCESS_QUAD_ENDSTOP(A, MINMAX) do { \
-    const byte quad_hit = TEST_ENDSTOP(_ENDSTOP(A, MINMAX)) | (TEST_ENDSTOP(_ENDSTOP(A##2, MINMAX)) << 1) | (TEST_ENDSTOP(_ENDSTOP(A##3, MINMAX)) << 2) | (TEST_ENDSTOP(_ENDSTOP(A##4, MINMAX)) << 3); \
+    const byte quad_hit = TEST_ENDSTOP(ES_ENUM(A, MINMAX)) | (TEST_ENDSTOP(ES_ENUM(A##2, MINMAX)) << 1) | (TEST_ENDSTOP(ES_ENUM(A##3, MINMAX)) << 2) | (TEST_ENDSTOP(ES_ENUM(A##4, MINMAX)) << 3); \
     if (quad_hit) { \
       _ENDSTOP_HIT(A, MINMAX); \
       /* if not performing home or if both endstops were triggered during homing... */ \
@@ -876,7 +798,7 @@ void Endstops::update() {
   #if HAS_X_AXIS
     if (stepper.axis_is_moving(X_AXIS)) {
       if (!stepper.motor_direction(X_AXIS_HEAD)) { // -direction
-        #if USE_X_MIN || (X_SPI_SENSORLESS && X_HOME_TO_MIN)
+        #if HAS_X_MIN_STATE
           PROCESS_ENDSTOP_X(MIN);
           #if   CORE_DIAG(XY, Y, MIN)
             PROCESS_CORE_ENDSTOP(Y,MIN,X,MIN);
@@ -890,7 +812,7 @@ void Endstops::update() {
         #endif
       }
       else { // +direction
-        #if USE_X_MAX || (X_SPI_SENSORLESS && X_HOME_TO_MAX)
+        #if HAS_X_MAX_STATE
           PROCESS_ENDSTOP_X(MAX);
           #if   CORE_DIAG(XY, Y, MIN)
             PROCESS_CORE_ENDSTOP(Y,MIN,X,MAX);
@@ -909,7 +831,7 @@ void Endstops::update() {
   #if HAS_Y_AXIS
     if (stepper.axis_is_moving(Y_AXIS)) {
       if (!stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
-        #if USE_Y_MIN || (Y_SPI_SENSORLESS && Y_HOME_TO_MIN)
+        #if HAS_Y_MIN_STATE
           PROCESS_ENDSTOP_Y(MIN);
           #if   CORE_DIAG(XY, X, MIN)
             PROCESS_CORE_ENDSTOP(X,MIN,Y,MIN);
@@ -923,7 +845,7 @@ void Endstops::update() {
         #endif
       }
       else { // +direction
-        #if USE_Y_MAX || (Y_SPI_SENSORLESS && Y_HOME_TO_MAX)
+        #if HAS_Y_MAX_STATE
           PROCESS_ENDSTOP_Y(MAX);
           #if   CORE_DIAG(XY, X, MIN)
             PROCESS_CORE_ENDSTOP(X,MIN,Y,MAX);
@@ -942,34 +864,34 @@ void Endstops::update() {
   #if HAS_Z_AXIS
     if (stepper.axis_is_moving(Z_AXIS)) {
       if (!stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
-
-        #if USE_Z_MIN || (Z_SPI_SENSORLESS && Z_HOME_TO_MIN)
-          if ( TERN1(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN, z_probe_enabled)
-            && TERN1(USE_Z_MIN_PROBE, !z_probe_enabled)
-          ) PROCESS_ENDSTOP_Z(MIN);
-          #if   CORE_DIAG(XZ, X, MIN)
-            PROCESS_CORE_ENDSTOP(X,MIN,Z,MIN);
-          #elif CORE_DIAG(XZ, X, MAX)
-            PROCESS_CORE_ENDSTOP(X,MAX,Z,MIN);
-          #elif CORE_DIAG(YZ, Y, MIN)
-            PROCESS_CORE_ENDSTOP(Y,MIN,Z,MIN);
-          #elif CORE_DIAG(YZ, Y, MAX)
-            PROCESS_CORE_ENDSTOP(Y,MAX,Z,MIN);
-          #endif
+        #if HAS_Z_MIN_STATE
+          // If the Z_MIN_PIN is being used for the probe there's no
+          // separate Z_MIN endstop. But a Z endstop could be wired
+          // in series, so someone might find this useful.
+          if ( TERN1(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN, z_probe_enabled) // When Z_MIN is the probe, the probe must be enabled
+            && TERN1(USE_Z_MIN_PROBE, !z_probe_enabled)                   // When Z_MIN isn't the probe, Z MIN is ignored while probing
+          ) {
+            PROCESS_ENDSTOP_Z(MIN);
+            #if   CORE_DIAG(XZ, X, MIN)
+              PROCESS_CORE_ENDSTOP(X,MIN,Z,MIN);
+            #elif CORE_DIAG(XZ, X, MAX)
+              PROCESS_CORE_ENDSTOP(X,MAX,Z,MIN);
+            #elif CORE_DIAG(YZ, Y, MIN)
+              PROCESS_CORE_ENDSTOP(Y,MIN,Z,MIN);
+            #elif CORE_DIAG(YZ, Y, MAX)
+              PROCESS_CORE_ENDSTOP(Y,MAX,Z,MIN);
+            #endif
+          }
         #endif
 
-        // When closing the gap check the enabled probe
+        // When closing the gap use the probe trigger state
         #if USE_Z_MIN_PROBE
           if (z_probe_enabled) PROCESS_ENDSTOP(Z, MIN_PROBE);
         #endif
       }
       else { // Z +direction. Gantry up, bed down.
-        #if USE_Z_MAX || (Z_SPI_SENSORLESS && Z_HOME_TO_MAX)
-          #if ENABLED(Z_MULTI_ENDSTOPS)
-            PROCESS_ENDSTOP_Z(MAX);
-          #elif TERN1(USE_Z_MIN_PROBE, Z_MAX_PIN != Z_MIN_PROBE_PIN)  // No probe or probe is Z_MIN || Probe is not Z_MAX
-            PROCESS_ENDSTOP(Z, MAX);
-          #endif
+        #if HAS_Z_MAX_STATE
+          PROCESS_ENDSTOP_Z(MAX);
           #if   CORE_DIAG(XZ, X, MIN)
             PROCESS_CORE_ENDSTOP(X,MIN,Z,MAX);
           #elif CORE_DIAG(XZ, X, MAX)
@@ -987,12 +909,12 @@ void Endstops::update() {
   #if HAS_I_AXIS
     if (stepper.axis_is_moving(I_AXIS)) {
       if (!stepper.motor_direction(I_AXIS_HEAD)) { // -direction
-        #if USE_I_MIN || (I_SPI_SENSORLESS && I_HOME_TO_MIN)
+        #if HAS_I_MIN_STATE
           PROCESS_ENDSTOP(I, MIN);
         #endif
       }
       else { // +direction
-        #if USE_I_MAX || (I_SPI_SENSORLESS && I_HOME_TO_MAX)
+        #if HAS_I_MAX_STATE
           PROCESS_ENDSTOP(I, MAX);
         #endif
       }
@@ -1002,12 +924,12 @@ void Endstops::update() {
   #if HAS_J_AXIS
     if (stepper.axis_is_moving(J_AXIS)) {
       if (!stepper.motor_direction(J_AXIS_HEAD)) { // -direction
-        #if USE_J_MIN || (J_SPI_SENSORLESS && J_HOME_TO_MIN)
+        #if HAS_J_MIN_STATE
           PROCESS_ENDSTOP(J, MIN);
         #endif
       }
       else { // +direction
-        #if USE_J_MAX || (J_SPI_SENSORLESS && J_HOME_TO_MAX)
+        #if HAS_J_MAX_STATE
           PROCESS_ENDSTOP(J, MAX);
         #endif
       }
@@ -1017,12 +939,12 @@ void Endstops::update() {
   #if HAS_K_AXIS
     if (stepper.axis_is_moving(K_AXIS)) {
       if (!stepper.motor_direction(K_AXIS_HEAD)) { // -direction
-        #if USE_K_MIN || (K_SPI_SENSORLESS && K_HOME_TO_MIN)
+        #if HAS_K_MIN_STATE
           PROCESS_ENDSTOP(K, MIN);
         #endif
       }
       else { // +direction
-        #if USE_K_MAX || (K_SPI_SENSORLESS && K_HOME_TO_MAX)
+        #if HAS_K_MAX_STATE
           PROCESS_ENDSTOP(K, MAX);
         #endif
       }
@@ -1032,12 +954,12 @@ void Endstops::update() {
   #if HAS_U_AXIS
     if (stepper.axis_is_moving(U_AXIS)) {
       if (!stepper.motor_direction(U_AXIS_HEAD)) { // -direction
-        #if USE_U_MIN || (U_SPI_SENSORLESS && U_HOME_TO_MIN)
+        #if HAS_U_MIN_STATE
           PROCESS_ENDSTOP(U, MIN);
         #endif
       }
       else { // +direction
-        #if USE_U_MAX || (U_SPI_SENSORLESS && U_HOME_TO_MAX)
+        #if HAS_U_MAX_STATE
           PROCESS_ENDSTOP(U, MAX);
         #endif
       }
@@ -1047,12 +969,12 @@ void Endstops::update() {
   #if HAS_V_AXIS
     if (stepper.axis_is_moving(V_AXIS)) {
       if (!stepper.motor_direction(V_AXIS_HEAD)) { // -direction
-        #if USE_V_MIN || (V_SPI_SENSORLESS && V_HOME_TO_MIN)
+        #if HAS_V_MIN_STATE
           PROCESS_ENDSTOP(V, MIN);
         #endif
       }
       else { // +direction
-        #if USE_V_MAX || (V_SPI_SENSORLESS && V_HOME_TO_MAX)
+        #if HAS_V_MAX_STATE
           PROCESS_ENDSTOP(V, MAX);
         #endif
       }
@@ -1062,17 +984,18 @@ void Endstops::update() {
   #if HAS_W_AXIS
     if (stepper.axis_is_moving(W_AXIS)) {
       if (!stepper.motor_direction(W_AXIS_HEAD)) { // -direction
-        #if USE_W_MIN || (W_SPI_SENSORLESS && W_HOME_TO_MIN)
+        #if HAS_W_MIN_STATE
           PROCESS_ENDSTOP(W, MIN);
         #endif
       }
       else { // +direction
-        #if USE_W_MAX || (W_SPI_SENSORLESS && W_HOME_TO_MAX)
+        #if HAS_W_MAX_STATE
           PROCESS_ENDSTOP(W, MAX);
         #endif
       }
     }
   #endif // HAS_W_AXIS
+
 } // Endstops::update()
 
 #if ENABLED(SPI_ENDSTOPS)
@@ -1080,39 +1003,67 @@ void Endstops::update() {
   // Called from idle() to read Trinamic stall states
   bool Endstops::tmc_spi_homing_check() {
     bool hit = false;
+
     #if X_SPI_SENSORLESS
-      if (tmc_spi_homing.x && (stepperX.test_stall_status()
-        #if Y_SPI_SENSORLESS && ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
-          || stepperY.test_stall_status()
-        #elif Z_SPI_SENSORLESS && CORE_IS_XZ
-          || stepperZ.test_stall_status()
+      if (tmc_spi_homing.x) {
+        #if ENABLED(DUAL_X_CARRIAGE)
+          const bool ismin = X_MIN_TEST();
         #endif
-      )) { SBI(live_state, X_ENDSTOP); hit = true; }
-      #if ENABLED(X_DUAL_ENDSTOPS)
-        if (tmc_spi_homing.x && stepperX2.test_stall_status()) { SBI(live_state, X2_ENDSTOP); hit = true; }
-      #endif
+        const bool xhit = (
+          #if ENABLED(DUAL_X_CARRIAGE)
+            ismin ? stepperX.test_stall_status() : stepperX2.test_stall_status()
+          #else
+            stepperX.test_stall_status()
+            #if Y_SPI_SENSORLESS && ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
+              || stepperY.test_stall_status()
+            #elif Z_SPI_SENSORLESS && CORE_IS_XZ
+              || stepperZ.test_stall_status()
+            #endif
+          #endif
+        );
+        if (xhit) { SBI(live_state, TERN(DUAL_X_CARRIAGE, ismin ? X_MIN : X_MAX, X_ENDSTOP)); hit = true; }
+        #if ENABLED(X_DUAL_ENDSTOPS)
+          if (stepperX2.test_stall_status()) { SBI(live_state, X2_ENDSTOP); hit = true; }
+        #endif
+      }
     #endif
+
     #if Y_SPI_SENSORLESS
-      if (tmc_spi_homing.y && (stepperY.test_stall_status()
-        #if X_SPI_SENSORLESS && ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
-          || stepperX.test_stall_status()
-        #elif Z_SPI_SENSORLESS && CORE_IS_YZ
-          || stepperZ.test_stall_status()
+      if (tmc_spi_homing.y) {
+        if (stepperY.test_stall_status()
+          #if X_SPI_SENSORLESS && ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
+            || stepperX.test_stall_status()
+          #elif Z_SPI_SENSORLESS && CORE_IS_YZ
+            || stepperZ.test_stall_status()
+          #endif
+        ) { SBI(live_state, Y_ENDSTOP); hit = true; }
+        #if ENABLED(Y_DUAL_ENDSTOPS)
+          if (stepperY2.test_stall_status()) { SBI(live_state, Y2_ENDSTOP); hit = true; }
         #endif
-      )) { SBI(live_state, Y_ENDSTOP); hit = true; }
-      #if ENABLED(Y_DUAL_ENDSTOPS)
-        if (tmc_spi_homing.y && stepperY2.test_stall_status()) { SBI(live_state, Y2_ENDSTOP); hit = true; }
-      #endif
+      }
     #endif
+
     #if Z_SPI_SENSORLESS
-      if (tmc_spi_homing.z && (stepperZ.test_stall_status()
-        #if X_SPI_SENSORLESS && CORE_IS_XZ
-          || stepperX.test_stall_status()
-        #elif Y_SPI_SENSORLESS && CORE_IS_YZ
-          || stepperY.test_stall_status()
+      if (tmc_spi_homing.z) {
+        if (stepperZ.test_stall_status()
+          #if X_SPI_SENSORLESS && CORE_IS_XZ
+            || stepperX.test_stall_status()
+          #elif Y_SPI_SENSORLESS && CORE_IS_YZ
+            || stepperY.test_stall_status()
+          #endif
+        ) { SBI(live_state, Z_ENDSTOP); hit = true; }
+        #if ENABLED(Z_MULTI_ENDSTOPS)
+          if (stepperZ2.test_stall_status()) { SBI(live_state, Z2_ENDSTOP); hit = true; }
+          #if NUM_Z_STEPPERS >= 3
+            if (stepperZ3.test_stall_status()) { SBI(live_state, Z3_ENDSTOP); hit = true; }
+            #if NUM_Z_STEPPERS >= 4
+              if (stepperZ4.test_stall_status()) { SBI(live_state, Z4_ENDSTOP); hit = true; }
+            #endif
+          #endif
         #endif
-      )) { SBI(live_state, Z_ENDSTOP); hit = true; }
+      }
     #endif
+
     #if I_SPI_SENSORLESS
       if (tmc_spi_homing.i && stepperI.test_stall_status()) { SBI(live_state, I_ENDSTOP); hit = true; }
     #endif
@@ -1147,6 +1098,15 @@ void Endstops::update() {
       CBI(live_state, Y2_ENDSTOP);
     #endif
     TERN_(Z_SPI_SENSORLESS, CBI(live_state, Z_ENDSTOP));
+    #if ALL(Z_SPI_SENSORLESS, Z_MULTI_ENDSTOPS)
+      CBI(live_state, Z2_ENDSTOP);
+      #if NUM_Z_STEPPERS >= 3
+        CBI(live_state, Z3_ENDSTOP);
+        #if NUM_Z_STEPPERS >= 4
+          CBI(live_state, Z4_ENDSTOP);
+        #endif
+      #endif
+    #endif
     TERN_(I_SPI_SENSORLESS, CBI(live_state, I_ENDSTOP));
     TERN_(J_SPI_SENSORLESS, CBI(live_state, J_ENDSTOP));
     TERN_(K_SPI_SENSORLESS, CBI(live_state, K_ENDSTOP));
@@ -1190,7 +1150,7 @@ void Endstops::update() {
     #if USE_Y_MAX
       ES_GET_STATE(Y_MAX);
     #endif
-    #if HAS_Z_MIN_PIN
+    #if USE_Z_MIN
       ES_GET_STATE(Z_MIN);
     #endif
     #if USE_Z_MAX
@@ -1266,7 +1226,7 @@ void Endstops::update() {
       ES_GET_STATE(W_MIN);
     #endif
 
-    uint16_t endstop_change = live_state_local ^ old_live_state_local;
+    const uint16_t endstop_change = live_state_local ^ old_live_state_local;
     #define ES_REPORT_CHANGE(S) if (TEST(endstop_change, S)) SERIAL_ECHOPGM("  " STRINGIFY(S) ":", TEST(live_state_local, S))
 
     if (endstop_change) {
@@ -1371,52 +1331,80 @@ void Endstops::update() {
   /**
    * Change TMC driver currents to N##_CURRENT_HOME, saving the current configuration of each.
    */
-  void Endstops::set_homing_current(const bool onoff) {
-    #define HAS_CURRENT_HOME(N) (defined(N##_CURRENT_HOME) && N##_CURRENT_HOME != N##_CURRENT)
-    #define HAS_DELTA_X_CURRENT (ENABLED(DELTA) && HAS_CURRENT_HOME(X))
-    #define HAS_DELTA_Y_CURRENT (ENABLED(DELTA) && HAS_CURRENT_HOME(Y))
-    #if HAS_DELTA_X_CURRENT || HAS_DELTA_Y_CURRENT || HAS_CURRENT_HOME(Z)
+  void Endstops::set_z_sensorless_current(const bool onoff) {
+    #if ENABLED(DELTA) && HAS_CURRENT_HOME(X)
+      #define HAS_DELTA_X_CURRENT 1
+    #endif
+    #if ENABLED(DELTA) && HAS_CURRENT_HOME(Y)
+      #define HAS_DELTA_Y_CURRENT 1
+    #endif
+    #if HAS_DELTA_X_CURRENT || HAS_DELTA_Y_CURRENT || HAS_CURRENT_HOME(Z) || HAS_CURRENT_HOME(Z2) || HAS_CURRENT_HOME(Z3) || HAS_CURRENT_HOME(Z4)
       #if HAS_DELTA_X_CURRENT
-        static int16_t saved_current_x;
+        static int16_t saved_current_X;
       #endif
       #if HAS_DELTA_Y_CURRENT
-        static int16_t saved_current_y;
+        static int16_t saved_current_Y;
       #endif
       #if HAS_CURRENT_HOME(Z)
-        static int16_t saved_current_z;
+        static int16_t saved_current_Z;
       #endif
-      auto debug_current_on = [](PGM_P const s, const int16_t a, const int16_t b) {
-        if (DEBUGGING(LEVELING)) { DEBUG_ECHOPGM_P(s); DEBUG_ECHOLNPGM(" current: ", a, " -> ", b); }
-      };
+      #if HAS_CURRENT_HOME(Z2)
+        static int16_t saved_current_Z2;
+      #endif
+      #if HAS_CURRENT_HOME(Z3)
+        static int16_t saved_current_Z3;
+      #endif
+      #if HAS_CURRENT_HOME(Z4)
+        static int16_t saved_current_Z4;
+      #endif
+
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        auto debug_current = [](FSTR_P const s, const int16_t a, const int16_t b) {
+          if (DEBUGGING(LEVELING)) { DEBUG_ECHOF(s); DEBUG_ECHOLNPGM(" current: ", a, " -> ", b); }
+        };
+      #else
+        #define debug_current(...)
+      #endif
+
+      #define _SAVE_SET_CURRENT(A) \
+        saved_current_##A = stepper##A.getMilliamps(); \
+        stepper##A.rms_current(A##_CURRENT_HOME); \
+        debug_current(F(STR_##A), saved_current_##A, A##_CURRENT_HOME)
+
+      #define _RESTORE_CURRENT(A) \
+        stepper##A.rms_current(saved_current_##A); \
+        debug_current(F(STR_##A), saved_current_##A, A##_CURRENT_HOME)
+
       if (onoff) {
-        #if HAS_DELTA_X_CURRENT
-          saved_current_x = stepperX.getMilliamps();
-          stepperX.rms_current(X_CURRENT_HOME);
-          debug_current_on(PSTR("X"), saved_current_x, X_CURRENT_HOME);
+        TERN_(HAS_DELTA_X_CURRENT, _SAVE_SET_CURRENT(X));
+        TERN_(HAS_DELTA_Y_CURRENT, _SAVE_SET_CURRENT(Y));
+        #if HAS_CURRENT_HOME(Z)
+          _SAVE_SET_CURRENT(Z);
         #endif
-        #if HAS_DELTA_Y_CURRENT
-          saved_current_y = stepperY.getMilliamps();
-          stepperY.rms_current(Y_CURRENT_HOME);
-          debug_current_on(PSTR("Y"), saved_current_y, Y_CURRENT_HOME);
+        #if HAS_CURRENT_HOME(Z2)
+          _SAVE_SET_CURRENT(Z2);
         #endif
-        #if HAS_CURRENT_HOME(Z)
-          saved_current_z = stepperZ.getMilliamps();
-          stepperZ.rms_current(Z_CURRENT_HOME);
-          debug_current_on(PSTR("Z"), saved_current_z, Z_CURRENT_HOME);
+        #if HAS_CURRENT_HOME(Z3)
+          _SAVE_SET_CURRENT(Z3);
+        #endif
+        #if HAS_CURRENT_HOME(Z4)
+          _SAVE_SET_CURRENT(Z4);
         #endif
       }
       else {
-        #if HAS_DELTA_X_CURRENT
-          stepperX.rms_current(saved_current_x);
-          debug_current_on(PSTR("X"), X_CURRENT_HOME, saved_current_x);
+        TERN_(HAS_DELTA_X_CURRENT, _RESTORE_CURRENT(X));
+        TERN_(HAS_DELTA_Y_CURRENT, _RESTORE_CURRENT(Y));
+        #if HAS_CURRENT_HOME(Z)
+          _RESTORE_CURRENT(Z);
         #endif
-        #if HAS_DELTA_Y_CURRENT
-          stepperY.rms_current(saved_current_y);
-          debug_current_on(PSTR("Y"), Y_CURRENT_HOME, saved_current_y);
+        #if HAS_CURRENT_HOME(Z2)
+          _RESTORE_CURRENT(Z2);
         #endif
-        #if HAS_CURRENT_HOME(Z)
-          stepperZ.rms_current(saved_current_z);
-          debug_current_on(PSTR("Z"), Z_CURRENT_HOME, saved_current_z);
+        #if HAS_CURRENT_HOME(Z3)
+          _RESTORE_CURRENT(Z3);
+        #endif
+        #if HAS_CURRENT_HOME(Z4)
+          _RESTORE_CURRENT(Z4);
         #endif
       }
 

commit 441416728cd7f0e9b6ebf94f895d1d27fe59d25a
Author: Mark <niujl123@sina.com>
Date:   Sun Jun 18 17:18:08 2023 +0800

    üö∏ Bed distance sensor improvements (#25847)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 63689bf7ca..3c1fcc72a9 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -65,7 +65,11 @@ Endstops::endstop_mask_t Endstops::live_state = 0;
 
 #if ENABLED(BD_SENSOR)
   bool Endstops::bdp_state; // = false
-  #define READ_ENDSTOP(P) ((P == Z_MIN_PIN) ? bdp_state : READ(P))
+  #if HOMING_Z_WITH_PROBE
+    #define READ_ENDSTOP(P) ((P == TERN(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN, Z_MIN_PIN, Z_MIN_PROBE_PIN)) ? bdp_state : READ(P))
+  #else
+    #define READ_ENDSTOP(P) READ(P)
+  #endif
 #else
   #define READ_ENDSTOP(P) READ(P)
 #endif

commit 2ef71c6ebaa1f1b496eb369879fe22c69cf9adb4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jun 12 16:38:14 2023 -0500

    ‚ôªÔ∏è Simplify SERIAL_ECHO (#25928)
    
    Since this increases AVR code size, try to optimize further.

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 3031e7d694..63689bf7ca 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -375,9 +375,8 @@ void Endstops::event_handler() {
   #endif
 
   static void print_es_state(const bool is_hit, FSTR_P const flabel=nullptr) {
-    if (flabel) SERIAL_ECHOF(flabel);
-    SERIAL_ECHOPGM(": ");
-    SERIAL_ECHOLNF(is_hit ? F(STR_ENDSTOP_HIT) : F(STR_ENDSTOP_OPEN));
+    if (flabel) SERIAL_ECHO(flabel);
+    SERIAL_ECHOLN(F(": "), is_hit ? F(STR_ENDSTOP_HIT) : F(STR_ENDSTOP_OPEN));
   }
 
   #pragma GCC diagnostic pop

commit 86c811660ebf0b3fcbae2f34273d4c9d0c22abc4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:30:34 2023 -0500

    üßë‚Äçüíª Remove LOOP macros (#25917)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index f73d0f1e6b..3031e7d694 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -480,7 +480,7 @@ void __O2 Endstops::report_states() {
   #endif
   #if MULTI_FILAMENT_SENSOR
     #define _CASE_RUNOUT(N) case N: pin = FIL_RUNOUT##N##_PIN; state = FIL_RUNOUT##N##_STATE; break;
-    LOOP_S_LE_N(i, 1, NUM_RUNOUT_SENSORS) {
+    for (uint8_t i = 1; i <= NUM_RUNOUT_SENSORS; ++i) {
       pin_t pin;
       uint8_t state;
       switch (i) {

commit 2691167afe02fbbe74b0fdca2c28a49fac635741
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:26:02 2023 -0500

    üßë‚Äçüíª Dump BOTH and EITHER macros (#25908)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index a22c4f0381..f73d0f1e6b 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -31,7 +31,7 @@
 #include "temperature.h"
 #include "../lcd/marlinui.h"
 
-#define DEBUG_OUT BOTH(USE_SENSORLESS, DEBUG_LEVELING_FEATURE)
+#define DEBUG_OUT ALL(USE_SENSORLESS, DEBUG_LEVELING_FEATURE)
 #include "../core/debug_out.h"
 
 #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
@@ -1136,11 +1136,11 @@ void Endstops::update() {
 
   void Endstops::clear_endstop_state() {
     TERN_(X_SPI_SENSORLESS, CBI(live_state, X_ENDSTOP));
-    #if BOTH(X_SPI_SENSORLESS, X_DUAL_ENDSTOPS)
+    #if ALL(X_SPI_SENSORLESS, X_DUAL_ENDSTOPS)
       CBI(live_state, X2_ENDSTOP);
     #endif
     TERN_(Y_SPI_SENSORLESS, CBI(live_state, Y_ENDSTOP));
-    #if BOTH(Y_SPI_SENSORLESS, Y_DUAL_ENDSTOPS)
+    #if ALL(Y_SPI_SENSORLESS, Y_DUAL_ENDSTOPS)
       CBI(live_state, Y2_ENDSTOP);
     #endif
     TERN_(Z_SPI_SENSORLESS, CBI(live_state, Z_ENDSTOP));

commit 25ddde0394361c23194c0f4a8f9777d389040af3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon May 15 22:00:15 2023 -0500

    üßë‚Äçüíª Change Marlin DIR bits: 1=Forward, 0=Reverse (#25791)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 0a12e1041d..a22c4f0381 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -872,7 +872,7 @@ void Endstops::update() {
 
   #if HAS_X_AXIS
     if (stepper.axis_is_moving(X_AXIS)) {
-      if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
+      if (!stepper.motor_direction(X_AXIS_HEAD)) { // -direction
         #if USE_X_MIN || (X_SPI_SENSORLESS && X_HOME_TO_MIN)
           PROCESS_ENDSTOP_X(MIN);
           #if   CORE_DIAG(XY, Y, MIN)
@@ -905,7 +905,7 @@ void Endstops::update() {
 
   #if HAS_Y_AXIS
     if (stepper.axis_is_moving(Y_AXIS)) {
-      if (stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
+      if (!stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
         #if USE_Y_MIN || (Y_SPI_SENSORLESS && Y_HOME_TO_MIN)
           PROCESS_ENDSTOP_Y(MIN);
           #if   CORE_DIAG(XY, X, MIN)
@@ -938,7 +938,7 @@ void Endstops::update() {
 
   #if HAS_Z_AXIS
     if (stepper.axis_is_moving(Z_AXIS)) {
-      if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
+      if (!stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
 
         #if USE_Z_MIN || (Z_SPI_SENSORLESS && Z_HOME_TO_MIN)
           if ( TERN1(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN, z_probe_enabled)
@@ -983,7 +983,7 @@ void Endstops::update() {
 
   #if HAS_I_AXIS
     if (stepper.axis_is_moving(I_AXIS)) {
-      if (stepper.motor_direction(I_AXIS_HEAD)) { // -direction
+      if (!stepper.motor_direction(I_AXIS_HEAD)) { // -direction
         #if USE_I_MIN || (I_SPI_SENSORLESS && I_HOME_TO_MIN)
           PROCESS_ENDSTOP(I, MIN);
         #endif
@@ -998,7 +998,7 @@ void Endstops::update() {
 
   #if HAS_J_AXIS
     if (stepper.axis_is_moving(J_AXIS)) {
-      if (stepper.motor_direction(J_AXIS_HEAD)) { // -direction
+      if (!stepper.motor_direction(J_AXIS_HEAD)) { // -direction
         #if USE_J_MIN || (J_SPI_SENSORLESS && J_HOME_TO_MIN)
           PROCESS_ENDSTOP(J, MIN);
         #endif
@@ -1013,7 +1013,7 @@ void Endstops::update() {
 
   #if HAS_K_AXIS
     if (stepper.axis_is_moving(K_AXIS)) {
-      if (stepper.motor_direction(K_AXIS_HEAD)) { // -direction
+      if (!stepper.motor_direction(K_AXIS_HEAD)) { // -direction
         #if USE_K_MIN || (K_SPI_SENSORLESS && K_HOME_TO_MIN)
           PROCESS_ENDSTOP(K, MIN);
         #endif
@@ -1028,7 +1028,7 @@ void Endstops::update() {
 
   #if HAS_U_AXIS
     if (stepper.axis_is_moving(U_AXIS)) {
-      if (stepper.motor_direction(U_AXIS_HEAD)) { // -direction
+      if (!stepper.motor_direction(U_AXIS_HEAD)) { // -direction
         #if USE_U_MIN || (U_SPI_SENSORLESS && U_HOME_TO_MIN)
           PROCESS_ENDSTOP(U, MIN);
         #endif
@@ -1043,7 +1043,7 @@ void Endstops::update() {
 
   #if HAS_V_AXIS
     if (stepper.axis_is_moving(V_AXIS)) {
-      if (stepper.motor_direction(V_AXIS_HEAD)) { // -direction
+      if (!stepper.motor_direction(V_AXIS_HEAD)) { // -direction
         #if USE_V_MIN || (V_SPI_SENSORLESS && V_HOME_TO_MIN)
           PROCESS_ENDSTOP(V, MIN);
         #endif
@@ -1058,7 +1058,7 @@ void Endstops::update() {
 
   #if HAS_W_AXIS
     if (stepper.axis_is_moving(W_AXIS)) {
-      if (stepper.motor_direction(W_AXIS_HEAD)) { // -direction
+      if (!stepper.motor_direction(W_AXIS_HEAD)) { // -direction
         #if USE_W_MIN || (W_SPI_SENSORLESS && W_HOME_TO_MIN)
           PROCESS_ENDSTOP(W, MIN);
         #endif

commit 1f9bfc5c7491d802d242623f8253b1f52c0917a3
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Wed May 10 06:59:25 2023 +1200

    üö∏ Optional X-Axis (#25418)
    
    Co-authored-by: alextrical <35117191+alextrical@users.noreply.github.com>
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index bf493023d8..0a12e1041d 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -300,7 +300,7 @@ void Endstops::event_handler() {
   prev_hit_state = hit_state;
   if (hit_state) {
     #if HAS_STATUS_MESSAGE
-      char NUM_AXIS_LIST(chrX = ' ', chrY = ' ', chrZ = ' ', chrI = ' ', chrJ = ' ', chrK = ' ', chrU = ' ', chrV = ' ', chrW = ' '),
+      char NUM_AXIS_LIST_(chrX = ' ', chrY = ' ', chrZ = ' ', chrI = ' ', chrJ = ' ', chrK = ' ', chrU = ' ', chrV = ' ', chrW = ' ')
            chrP = ' ';
       #define _SET_STOP_CHAR(A,C) (chr## A = C)
     #else
@@ -348,7 +348,7 @@ void Endstops::event_handler() {
       ui.status_printf(0,
         F(S_FMT GANG_N_1(NUM_AXES, " %c") " %c"),
         GET_TEXT(MSG_LCD_ENDSTOPS),
-        NUM_AXIS_LIST(chrX, chrY, chrZ, chrI, chrJ, chrK, chrU, chrV, chrW), chrP
+        NUM_AXIS_LIST_(chrX, chrY, chrZ, chrI, chrJ, chrK, chrU, chrV, chrW) chrP
       )
     );
 
@@ -367,18 +367,22 @@ void Endstops::event_handler() {
   }
 }
 
-#pragma GCC diagnostic push
-#if GCC_VERSION <= 50000
-  #pragma GCC diagnostic ignored "-Wunused-function"
-#endif
+#if NUM_AXES
 
-static void print_es_state(const bool is_hit, FSTR_P const flabel=nullptr) {
-  if (flabel) SERIAL_ECHOF(flabel);
-  SERIAL_ECHOPGM(": ");
-  SERIAL_ECHOLNF(is_hit ? F(STR_ENDSTOP_HIT) : F(STR_ENDSTOP_OPEN));
-}
+  #pragma GCC diagnostic push
+  #if GCC_VERSION <= 50000
+    #pragma GCC diagnostic ignored "-Wunused-function"
+  #endif
 
-#pragma GCC diagnostic pop
+  static void print_es_state(const bool is_hit, FSTR_P const flabel=nullptr) {
+    if (flabel) SERIAL_ECHOF(flabel);
+    SERIAL_ECHOPGM(": ");
+    SERIAL_ECHOLNF(is_hit ? F(STR_ENDSTOP_HIT) : F(STR_ENDSTOP_OPEN));
+  }
+
+  #pragma GCC diagnostic pop
+
+#endif
 
 void __O2 Endstops::report_states() {
   TERN_(BLTOUCH, bltouch._set_SW_mode());

commit 99a9e265b0b7356b4d3bc5fdef88e2afe1ab0623
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 6 19:07:07 2023 -0500

    ü©π Endstops prelim. followup

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 0a01dd2d04..bf493023d8 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -311,7 +311,7 @@ void Endstops::event_handler() {
       SERIAL_ECHOPGM(" " STRINGIFY(A) ":", planner.triggered_position_mm(_AXIS(A))); _SET_STOP_CHAR(A,C); }while(0)
 
     #define _ENDSTOP_HIT_TEST(A,C) \
-      if (TERN0(HAS_##A##_MIN, TEST(hit_state, A##_MIN)) || TERN0(HAS_##A##_MAX, TEST(hit_state, A##_MAX))) \
+      if (TERN0(USE_##A##_MIN, TEST(hit_state, ES_ENUM(A,MIN))) || TERN0(USE_##A##_MAX, TEST(hit_state, ES_ENUM(A,MAX)))) \
         _ENDSTOP_HIT_ECHO(A,C)
 
     #define ENDSTOP_HIT_TEST_X() _ENDSTOP_HIT_TEST(X,'X')
@@ -792,7 +792,7 @@ void Endstops::update() {
   }while(0)
 
   // Core Sensorless Homing needs to test an Extra Pin
-  #define CORE_DIAG(QQ,A,MM) (CORE_IS_##QQ && A##_SENSORLESS && !A##_SPI_SENSORLESS && HAS_##A##_##MM)
+  #define CORE_DIAG(QQ,A,MM) (CORE_IS_##QQ && A##_SENSORLESS && !A##_SPI_SENSORLESS && USE_##A##_##MM)
   #define PROCESS_CORE_ENDSTOP(A1,M1,A2,M2) do { \
     if (TEST_ENDSTOP(_ENDSTOP(A1,M1))) { \
       _ENDSTOP_HIT(A2,M2); \

commit 53d06be226a175a5a7950356746941a5319b06c5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 6 02:26:54 2023 -0500

    üßë‚Äçüíª Endstops preliminary followup
    
    Followup to #25780

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index ebe0a64bac..0a01dd2d04 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -869,7 +869,7 @@ void Endstops::update() {
   #if HAS_X_AXIS
     if (stepper.axis_is_moving(X_AXIS)) {
       if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
-        #if HAS_X_MIN || (X_SPI_SENSORLESS && X_HOME_TO_MIN)
+        #if USE_X_MIN || (X_SPI_SENSORLESS && X_HOME_TO_MIN)
           PROCESS_ENDSTOP_X(MIN);
           #if   CORE_DIAG(XY, Y, MIN)
             PROCESS_CORE_ENDSTOP(Y,MIN,X,MIN);
@@ -883,7 +883,7 @@ void Endstops::update() {
         #endif
       }
       else { // +direction
-        #if HAS_X_MAX || (X_SPI_SENSORLESS && X_HOME_TO_MAX)
+        #if USE_X_MAX || (X_SPI_SENSORLESS && X_HOME_TO_MAX)
           PROCESS_ENDSTOP_X(MAX);
           #if   CORE_DIAG(XY, Y, MIN)
             PROCESS_CORE_ENDSTOP(Y,MIN,X,MAX);

commit 85325f585ac4a9bb667423561540b5d58bdc3b6e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri May 5 19:37:13 2023 -0500

    üßë‚Äçüíª Endstops preliminary work (#25780)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 668be5f1f4..ebe0a64bac 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -38,7 +38,7 @@
   #include HAL_PATH(.., endstop_interrupts.h)
 #endif
 
-#if BOTH(SD_ABORT_ON_ENDSTOP_HIT, HAS_MEDIA)
+#if ENABLED(SD_ABORT_ON_ENDSTOP_HIT)
   #include "printcounter.h" // for print_job_timer
 #endif
 
@@ -110,88 +110,88 @@ Endstops::endstop_mask_t Endstops::live_state = 0;
 void Endstops::init() {
 
   #define _INIT_ENDSTOP(T,A,N) TERN(ENDSTOPPULLUP_##A##T, SET_INPUT_PULLUP, TERN(ENDSTOPPULLDOWN_##A##T, SET_INPUT_PULLDOWN, SET_INPUT))(A##N##_##T##_PIN)
-  #if HAS_X_MIN
+  #if USE_X_MIN
     _INIT_ENDSTOP(MIN,X,);
   #endif
-  #if HAS_X_MAX
+  #if USE_X_MAX
     _INIT_ENDSTOP(MAX,X,);
   #endif
-  #if HAS_X2_MIN
+  #if USE_X2_MIN
     _INIT_ENDSTOP(MIN,X,2);
   #endif
-  #if HAS_X2_MAX
+  #if USE_X2_MAX
     _INIT_ENDSTOP(MAX,X,2);
   #endif
-  #if HAS_Y_MIN
+  #if USE_Y_MIN
     _INIT_ENDSTOP(MIN,Y,);
   #endif
-  #if HAS_Y_MAX
+  #if USE_Y_MAX
     _INIT_ENDSTOP(MAX,Y,);
   #endif
-  #if HAS_Y2_MIN
+  #if USE_Y2_MIN
     _INIT_ENDSTOP(MIN,Y,2);
   #endif
-  #if HAS_Y2_MAX
+  #if USE_Y2_MAX
     _INIT_ENDSTOP(MAX,Y,2);
   #endif
   #if HAS_Z_MIN_PIN
     _INIT_ENDSTOP(MIN,Z,);
   #endif
-  #if HAS_Z_MAX
+  #if USE_Z_MAX
     _INIT_ENDSTOP(MAX,Z,);
   #endif
-  #if HAS_Z2_MIN
+  #if USE_Z2_MIN
     _INIT_ENDSTOP(MIN,Z,2);
   #endif
-  #if HAS_Z2_MAX
+  #if USE_Z2_MAX
     _INIT_ENDSTOP(MAX,Z,2);
   #endif
-  #if HAS_Z3_MIN
+  #if USE_Z3_MIN
     _INIT_ENDSTOP(MIN,Z,3);
   #endif
-  #if HAS_Z3_MAX
+  #if USE_Z3_MAX
     _INIT_ENDSTOP(MAX,Z,3);
   #endif
-  #if HAS_Z4_MIN
+  #if USE_Z4_MIN
     _INIT_ENDSTOP(MIN,Z,4);
   #endif
-  #if HAS_Z4_MAX
+  #if USE_Z4_MAX
     _INIT_ENDSTOP(MAX,Z,4);
   #endif
-  #if HAS_I_MIN
+  #if USE_I_MIN
     _INIT_ENDSTOP(MIN,I,);
   #endif
-  #if HAS_I_MAX
+  #if USE_I_MAX
     _INIT_ENDSTOP(MAX,I,);
   #endif
-  #if HAS_J_MIN
+  #if USE_J_MIN
     _INIT_ENDSTOP(MIN,J,);
   #endif
-  #if HAS_J_MAX
+  #if USE_J_MAX
     _INIT_ENDSTOP(MAX,J,);
   #endif
-  #if HAS_K_MIN
+  #if USE_K_MIN
     _INIT_ENDSTOP(MIN,K,);
   #endif
-  #if HAS_K_MAX
+  #if USE_K_MAX
     _INIT_ENDSTOP(MAX,K,);
   #endif
-  #if HAS_U_MIN
+  #if USE_U_MIN
     _INIT_ENDSTOP(MIN,U,);
   #endif
-  #if HAS_U_MAX
+  #if USE_U_MAX
     _INIT_ENDSTOP(MAX,U,);
   #endif
-  #if HAS_V_MIN
+  #if USE_V_MIN
     _INIT_ENDSTOP(MIN,V,);
   #endif
-  #if HAS_V_MAX
+  #if USE_V_MAX
     _INIT_ENDSTOP(MAX,V,);
   #endif
-  #if HAS_W_MIN
+  #if USE_W_MIN
     _INIT_ENDSTOP(MIN,W,);
   #endif
-  #if HAS_W_MAX
+  #if USE_W_MAX
     _INIT_ENDSTOP(MAX,W,);
   #endif
 
@@ -205,7 +205,7 @@ void Endstops::init() {
     #endif
   #endif
 
-  #if USES_Z_MIN_PROBE_PIN
+  #if USE_Z_MIN_PROBE
     #if ENABLED(ENDSTOPPULLUP_ZMIN_PROBE)
       SET_INPUT_PULLUP(Z_MIN_PROBE_PIN);
     #elif ENABLED(ENDSTOPPULLDOWN_ZMIN_PROBE)
@@ -338,7 +338,7 @@ void Endstops::event_handler() {
       _ENDSTOP_HIT_TEST(W,'W')
     );
 
-    #if USES_Z_MIN_PROBE_PIN
+    #if USE_Z_MIN_PROBE
       #define P_AXIS Z_AXIS
       if (TEST(hit_state, Z_MIN_PROBE)) _ENDSTOP_HIT_ECHO(P, 'P');
     #endif
@@ -352,7 +352,7 @@ void Endstops::event_handler() {
       )
     );
 
-    #if BOTH(SD_ABORT_ON_ENDSTOP_HIT, HAS_MEDIA)
+    #if ENABLED(SD_ABORT_ON_ENDSTOP_HIT)
       if (planner.abort_on_endstop_hit) {
         card.abortFilePrintNow();
         quickstop_stepper();
@@ -384,94 +384,94 @@ void __O2 Endstops::report_states() {
   TERN_(BLTOUCH, bltouch._set_SW_mode());
   SERIAL_ECHOLNPGM(STR_M119_REPORT);
   #define ES_REPORT(S) print_es_state(READ_ENDSTOP(S##_PIN) == S##_ENDSTOP_HIT_STATE, F(STR_##S))
-  #if HAS_X_MIN
+  #if USE_X_MIN
     ES_REPORT(X_MIN);
   #endif
-  #if HAS_X2_MIN
+  #if USE_X2_MIN
     ES_REPORT(X2_MIN);
   #endif
-  #if HAS_X_MAX
+  #if USE_X_MAX
     ES_REPORT(X_MAX);
   #endif
-  #if HAS_X2_MAX
+  #if USE_X2_MAX
     ES_REPORT(X2_MAX);
   #endif
-  #if HAS_Y_MIN
+  #if USE_Y_MIN
     ES_REPORT(Y_MIN);
   #endif
-  #if HAS_Y2_MIN
+  #if USE_Y2_MIN
     ES_REPORT(Y2_MIN);
   #endif
-  #if HAS_Y_MAX
+  #if USE_Y_MAX
     ES_REPORT(Y_MAX);
   #endif
-  #if HAS_Y2_MAX
+  #if USE_Y2_MAX
     ES_REPORT(Y2_MAX);
   #endif
-  #if HAS_Z_MIN
+  #if USE_Z_MIN
     ES_REPORT(Z_MIN);
   #endif
-  #if HAS_Z2_MIN
+  #if USE_Z2_MIN
     ES_REPORT(Z2_MIN);
   #endif
-  #if HAS_Z3_MIN
+  #if USE_Z3_MIN
     ES_REPORT(Z3_MIN);
   #endif
-  #if HAS_Z4_MIN
+  #if USE_Z4_MIN
     ES_REPORT(Z4_MIN);
   #endif
-  #if HAS_Z_MAX
+  #if USE_Z_MAX
     ES_REPORT(Z_MAX);
   #endif
-  #if HAS_Z2_MAX
+  #if USE_Z2_MAX
     ES_REPORT(Z2_MAX);
   #endif
-  #if HAS_Z3_MAX
+  #if USE_Z3_MAX
     ES_REPORT(Z3_MAX);
   #endif
-  #if HAS_Z4_MAX
+  #if USE_Z4_MAX
     ES_REPORT(Z4_MAX);
   #endif
-  #if HAS_I_MIN
+  #if USE_I_MIN
     ES_REPORT(I_MIN);
   #endif
-  #if HAS_I_MAX
+  #if USE_I_MAX
     ES_REPORT(I_MAX);
   #endif
-  #if HAS_J_MIN
+  #if USE_J_MIN
     ES_REPORT(J_MIN);
   #endif
-  #if HAS_J_MAX
+  #if USE_J_MAX
     ES_REPORT(J_MAX);
   #endif
-  #if HAS_K_MIN
+  #if USE_K_MIN
     ES_REPORT(K_MIN);
   #endif
-  #if HAS_K_MAX
+  #if USE_K_MAX
     ES_REPORT(K_MAX);
   #endif
-  #if HAS_U_MIN
+  #if USE_U_MIN
     ES_REPORT(U_MIN);
   #endif
-  #if HAS_U_MAX
+  #if USE_U_MAX
     ES_REPORT(U_MAX);
   #endif
-  #if HAS_V_MIN
+  #if USE_V_MIN
     ES_REPORT(V_MIN);
   #endif
-  #if HAS_V_MAX
+  #if USE_V_MAX
     ES_REPORT(V_MAX);
   #endif
-  #if HAS_W_MIN
+  #if USE_W_MIN
     ES_REPORT(W_MIN);
   #endif
-  #if HAS_W_MAX
+  #if USE_W_MAX
     ES_REPORT(W_MAX);
   #endif
   #if ENABLED(PROBE_ACTIVATION_SWITCH)
     print_es_state(probe_switch_activated(), F(STR_PROBE_EN));
   #endif
-  #if USES_Z_MIN_PROBE_PIN
+  #if USE_Z_MIN_PROBE
     print_es_state(PROBE_TRIGGERED(), F(STR_Z_PROBE));
   #endif
   #if MULTI_FILAMENT_SENSOR
@@ -519,12 +519,12 @@ void Endstops::update() {
 
   #if ENABLED(G38_PROBE_TARGET)
     // For G38 moves check the probe's pin for ALL movement
-    if (G38_move) UPDATE_LIVE_STATE(Z, TERN(USES_Z_MIN_PROBE_PIN, MIN_PROBE, MIN));
+    if (G38_move) UPDATE_LIVE_STATE(Z, TERN(USE_Z_MIN_PROBE, MIN_PROBE, MIN));
   #endif
 
   // With Dual X, endstops are only checked in the homing direction for the active extruder
-  #define X_MIN_TEST() TERN1(DUAL_X_CARRIAGE, TERN0(X_HOME_TO_MIN, stepper.last_moved_extruder == 0) || TERN0(X2_HOME_TO_MIN, stepper.last_moved_extruder != 0))
-  #define X_MAX_TEST() TERN1(DUAL_X_CARRIAGE, TERN0(X_HOME_TO_MAX, stepper.last_moved_extruder == 0) || TERN0(X2_HOME_TO_MAX, stepper.last_moved_extruder != 0))
+  #define X_MIN_TEST() TERN1(DUAL_X_CARRIAGE, stepper.last_moved_extruder == 0) // Check min for the left carriage
+  #define X_MAX_TEST() TERN1(DUAL_X_CARRIAGE, stepper.last_moved_extruder != 0) // Check max for the right carriage
 
   // Use HEAD for core axes, AXIS for others
   #if ANY(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY, MARKFORGED_YX)
@@ -553,10 +553,10 @@ void Endstops::update() {
   /**
    * Check and update endstops
    */
-  #if HAS_X_MIN && !X_SPI_SENSORLESS
+  #if USE_X_MIN && !X_SPI_SENSORLESS
     UPDATE_LIVE_STATE(X, MIN);
     #if ENABLED(X_DUAL_ENDSTOPS)
-      #if HAS_X2_MIN
+      #if USE_X2_MIN
         UPDATE_LIVE_STATE(X2, MIN);
       #else
         COPY_LIVE_STATE(X_MIN, X2_MIN);
@@ -564,10 +564,10 @@ void Endstops::update() {
     #endif
   #endif
 
-  #if HAS_X_MAX && !X_SPI_SENSORLESS
+  #if USE_X_MAX && !X_SPI_SENSORLESS
     UPDATE_LIVE_STATE(X, MAX);
     #if ENABLED(X_DUAL_ENDSTOPS)
-      #if HAS_X2_MAX
+      #if USE_X2_MAX
         UPDATE_LIVE_STATE(X2, MAX);
       #else
         COPY_LIVE_STATE(X_MAX, X2_MAX);
@@ -575,10 +575,10 @@ void Endstops::update() {
     #endif
   #endif
 
-  #if HAS_Y_MIN && !Y_SPI_SENSORLESS
+  #if USE_Y_MIN && !Y_SPI_SENSORLESS
     UPDATE_LIVE_STATE(Y, MIN);
     #if ENABLED(Y_DUAL_ENDSTOPS)
-      #if HAS_Y2_MIN
+      #if USE_Y2_MIN
         UPDATE_LIVE_STATE(Y2, MIN);
       #else
         COPY_LIVE_STATE(Y_MIN, Y2_MIN);
@@ -586,10 +586,10 @@ void Endstops::update() {
     #endif
   #endif
 
-  #if HAS_Y_MAX && !Y_SPI_SENSORLESS
+  #if USE_Y_MAX && !Y_SPI_SENSORLESS
     UPDATE_LIVE_STATE(Y, MAX);
     #if ENABLED(Y_DUAL_ENDSTOPS)
-      #if HAS_Y2_MAX
+      #if USE_Y2_MAX
         UPDATE_LIVE_STATE(Y2, MAX);
       #else
         COPY_LIVE_STATE(Y_MAX, Y2_MAX);
@@ -597,25 +597,25 @@ void Endstops::update() {
     #endif
   #endif
 
-  #if HAS_Z_MIN && NONE(Z_SPI_SENSORLESS, Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
+  #if USE_Z_MIN && NONE(Z_SPI_SENSORLESS, Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
     #if HAS_Z_MIN_PIN
       UPDATE_LIVE_STATE(Z, MIN);
     #endif
     #if ENABLED(Z_MULTI_ENDSTOPS)
-      #if HAS_Z2_MIN
+      #if USE_Z2_MIN
         UPDATE_LIVE_STATE(Z2, MIN);
       #else
         COPY_LIVE_STATE(Z_MIN, Z2_MIN);
       #endif
       #if NUM_Z_STEPPERS >= 3
-        #if HAS_Z3_MIN
+        #if USE_Z3_MIN
           UPDATE_LIVE_STATE(Z3, MIN);
         #else
           COPY_LIVE_STATE(Z_MIN, Z3_MIN);
         #endif
       #endif
       #if NUM_Z_STEPPERS >= 4
-        #if HAS_Z4_MIN
+        #if USE_Z4_MIN
           UPDATE_LIVE_STATE(Z4, MIN);
         #else
           COPY_LIVE_STATE(Z_MIN, Z4_MIN);
@@ -627,39 +627,39 @@ void Endstops::update() {
   #if HAS_BED_PROBE
     // When closing the gap check the enabled probe
     if (probe_switch_activated())
-      UPDATE_LIVE_STATE(Z, TERN(USES_Z_MIN_PROBE_PIN, MIN_PROBE, MIN));
+      UPDATE_LIVE_STATE(Z, TERN(USE_Z_MIN_PROBE, MIN_PROBE, MIN));
   #endif
 
-  #if HAS_Z_MAX && !Z_SPI_SENSORLESS
+  #if USE_Z_MAX && !Z_SPI_SENSORLESS
     // Check both Z dual endstops
     #if ENABLED(Z_MULTI_ENDSTOPS)
       UPDATE_LIVE_STATE(Z, MAX);
-      #if HAS_Z2_MAX
+      #if USE_Z2_MAX
         UPDATE_LIVE_STATE(Z2, MAX);
       #else
         COPY_LIVE_STATE(Z_MAX, Z2_MAX);
       #endif
       #if NUM_Z_STEPPERS >= 3
-        #if HAS_Z3_MAX
+        #if USE_Z3_MAX
           UPDATE_LIVE_STATE(Z3, MAX);
         #else
           COPY_LIVE_STATE(Z_MAX, Z3_MAX);
         #endif
       #endif
       #if NUM_Z_STEPPERS >= 4
-        #if HAS_Z4_MAX
+        #if USE_Z4_MAX
           UPDATE_LIVE_STATE(Z4, MAX);
         #else
           COPY_LIVE_STATE(Z_MAX, Z4_MAX);
         #endif
       #endif
-    #elif TERN1(USES_Z_MIN_PROBE_PIN, Z_MAX_PIN != Z_MIN_PROBE_PIN)
+    #elif TERN1(USE_Z_MIN_PROBE, Z_MAX_PIN != Z_MIN_PROBE_PIN)
       // If this pin isn't the bed probe it's the Z endstop
       UPDATE_LIVE_STATE(Z, MAX);
     #endif
   #endif
 
-  #if HAS_I_MIN && !I_SPI_SENSORLESS
+  #if USE_I_MIN && !I_SPI_SENSORLESS
     #if ENABLED(I_DUAL_ENDSTOPS)
       UPDATE_LIVE_STATE(I, MIN);
     #else
@@ -667,7 +667,7 @@ void Endstops::update() {
     #endif
   #endif
 
-  #if HAS_I_MAX && !I_SPI_SENSORLESS
+  #if USE_I_MAX && !I_SPI_SENSORLESS
     #if ENABLED(I_DUAL_ENDSTOPS)
       UPDATE_LIVE_STATE(I, MAX);
     #else
@@ -675,7 +675,7 @@ void Endstops::update() {
     #endif
   #endif
 
-  #if HAS_J_MIN && !J_SPI_SENSORLESS
+  #if USE_J_MIN && !J_SPI_SENSORLESS
     #if ENABLED(J_DUAL_ENDSTOPS)
       UPDATE_LIVE_STATE(J, MIN);
     #else
@@ -683,7 +683,7 @@ void Endstops::update() {
     #endif
   #endif
 
-  #if HAS_J_MAX && !J_SPI_SENSORLESS
+  #if USE_J_MAX && !J_SPI_SENSORLESS
     #if ENABLED(J_DUAL_ENDSTOPS)
       UPDATE_LIVE_STATE(J, MAX);
     #else
@@ -691,7 +691,7 @@ void Endstops::update() {
     #endif
   #endif
 
-  #if HAS_K_MIN && !K_SPI_SENSORLESS
+  #if USE_K_MIN && !K_SPI_SENSORLESS
     #if ENABLED(K_DUAL_ENDSTOPS)
       UPDATE_LIVE_STATE(K, MIN);
     #else
@@ -699,7 +699,7 @@ void Endstops::update() {
     #endif
   #endif
 
-  #if HAS_K_MAX && !K_SPI_SENSORLESS
+  #if USE_K_MAX && !K_SPI_SENSORLESS
     #if ENABLED(K_DUAL_ENDSTOPS)
       UPDATE_LIVE_STATE(K, MAX);
     #else
@@ -707,7 +707,7 @@ void Endstops::update() {
     #endif
   #endif
 
-  #if HAS_U_MIN && !U_SPI_SENSORLESS
+  #if USE_U_MIN && !U_SPI_SENSORLESS
     #if ENABLED(U_DUAL_ENDSTOPS)
       UPDATE_LIVE_STATE(U, MIN);
     #else
@@ -715,7 +715,7 @@ void Endstops::update() {
     #endif
   #endif
 
-  #if HAS_U_MAX && !U_SPI_SENSORLESS
+  #if USE_U_MAX && !U_SPI_SENSORLESS
     #if ENABLED(U_DUAL_ENDSTOPS)
       UPDATE_LIVE_STATE(U, MAX);
     #else
@@ -723,14 +723,14 @@ void Endstops::update() {
     #endif
   #endif
 
-  #if HAS_V_MIN && !V_SPI_SENSORLESS
+  #if USE_V_MIN && !V_SPI_SENSORLESS
     #if ENABLED(V_DUAL_ENDSTOPS)
       UPDATE_LIVE_STATE(V, MIN);
     #else
       UPDATE_LIVE_STATE(V, MIN);
     #endif
   #endif
-  #if HAS_V_MAX && !V_SPI_SENSORLESS
+  #if USE_V_MAX && !V_SPI_SENSORLESS
     #if ENABLED(O_DUAL_ENDSTOPS)
       UPDATE_LIVE_STATE(V, MAX);
     #else
@@ -738,14 +738,14 @@ void Endstops::update() {
     #endif
   #endif
 
-  #if HAS_W_MIN && !W_SPI_SENSORLESS
+  #if USE_W_MIN && !W_SPI_SENSORLESS
     #if ENABLED(W_DUAL_ENDSTOPS)
       UPDATE_LIVE_STATE(W, MIN);
     #else
       UPDATE_LIVE_STATE(W, MIN);
     #endif
   #endif
-  #if HAS_W_MAX && !W_SPI_SENSORLESS
+  #if USE_W_MAX && !W_SPI_SENSORLESS
     #if ENABLED(W_DUAL_ENDSTOPS)
       UPDATE_LIVE_STATE(W, MAX);
     #else
@@ -902,7 +902,7 @@ void Endstops::update() {
   #if HAS_Y_AXIS
     if (stepper.axis_is_moving(Y_AXIS)) {
       if (stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
-        #if HAS_Y_MIN || (Y_SPI_SENSORLESS && Y_HOME_TO_MIN)
+        #if USE_Y_MIN || (Y_SPI_SENSORLESS && Y_HOME_TO_MIN)
           PROCESS_ENDSTOP_Y(MIN);
           #if   CORE_DIAG(XY, X, MIN)
             PROCESS_CORE_ENDSTOP(X,MIN,Y,MIN);
@@ -916,7 +916,7 @@ void Endstops::update() {
         #endif
       }
       else { // +direction
-        #if HAS_Y_MAX || (Y_SPI_SENSORLESS && Y_HOME_TO_MAX)
+        #if USE_Y_MAX || (Y_SPI_SENSORLESS && Y_HOME_TO_MAX)
           PROCESS_ENDSTOP_Y(MAX);
           #if   CORE_DIAG(XY, X, MIN)
             PROCESS_CORE_ENDSTOP(X,MIN,Y,MAX);
@@ -936,9 +936,9 @@ void Endstops::update() {
     if (stepper.axis_is_moving(Z_AXIS)) {
       if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
 
-        #if HAS_Z_MIN || (Z_SPI_SENSORLESS && Z_HOME_TO_MIN)
+        #if USE_Z_MIN || (Z_SPI_SENSORLESS && Z_HOME_TO_MIN)
           if ( TERN1(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN, z_probe_enabled)
-            && TERN1(USES_Z_MIN_PROBE_PIN, !z_probe_enabled)
+            && TERN1(USE_Z_MIN_PROBE, !z_probe_enabled)
           ) PROCESS_ENDSTOP_Z(MIN);
           #if   CORE_DIAG(XZ, X, MIN)
             PROCESS_CORE_ENDSTOP(X,MIN,Z,MIN);
@@ -952,15 +952,15 @@ void Endstops::update() {
         #endif
 
         // When closing the gap check the enabled probe
-        #if USES_Z_MIN_PROBE_PIN
+        #if USE_Z_MIN_PROBE
           if (z_probe_enabled) PROCESS_ENDSTOP(Z, MIN_PROBE);
         #endif
       }
       else { // Z +direction. Gantry up, bed down.
-        #if HAS_Z_MAX || (Z_SPI_SENSORLESS && Z_HOME_TO_MAX)
+        #if USE_Z_MAX || (Z_SPI_SENSORLESS && Z_HOME_TO_MAX)
           #if ENABLED(Z_MULTI_ENDSTOPS)
             PROCESS_ENDSTOP_Z(MAX);
-          #elif TERN1(USES_Z_MIN_PROBE_PIN, Z_MAX_PIN != Z_MIN_PROBE_PIN)  // No probe or probe is Z_MIN || Probe is not Z_MAX
+          #elif TERN1(USE_Z_MIN_PROBE, Z_MAX_PIN != Z_MIN_PROBE_PIN)  // No probe or probe is Z_MIN || Probe is not Z_MAX
             PROCESS_ENDSTOP(Z, MAX);
           #endif
           #if   CORE_DIAG(XZ, X, MIN)
@@ -980,12 +980,12 @@ void Endstops::update() {
   #if HAS_I_AXIS
     if (stepper.axis_is_moving(I_AXIS)) {
       if (stepper.motor_direction(I_AXIS_HEAD)) { // -direction
-        #if HAS_I_MIN || (I_SPI_SENSORLESS && I_HOME_TO_MIN)
+        #if USE_I_MIN || (I_SPI_SENSORLESS && I_HOME_TO_MIN)
           PROCESS_ENDSTOP(I, MIN);
         #endif
       }
       else { // +direction
-        #if HAS_I_MAX || (I_SPI_SENSORLESS && I_HOME_TO_MAX)
+        #if USE_I_MAX || (I_SPI_SENSORLESS && I_HOME_TO_MAX)
           PROCESS_ENDSTOP(I, MAX);
         #endif
       }
@@ -995,12 +995,12 @@ void Endstops::update() {
   #if HAS_J_AXIS
     if (stepper.axis_is_moving(J_AXIS)) {
       if (stepper.motor_direction(J_AXIS_HEAD)) { // -direction
-        #if HAS_J_MIN || (J_SPI_SENSORLESS && J_HOME_TO_MIN)
+        #if USE_J_MIN || (J_SPI_SENSORLESS && J_HOME_TO_MIN)
           PROCESS_ENDSTOP(J, MIN);
         #endif
       }
       else { // +direction
-        #if HAS_J_MAX || (J_SPI_SENSORLESS && J_HOME_TO_MAX)
+        #if USE_J_MAX || (J_SPI_SENSORLESS && J_HOME_TO_MAX)
           PROCESS_ENDSTOP(J, MAX);
         #endif
       }
@@ -1010,12 +1010,12 @@ void Endstops::update() {
   #if HAS_K_AXIS
     if (stepper.axis_is_moving(K_AXIS)) {
       if (stepper.motor_direction(K_AXIS_HEAD)) { // -direction
-        #if HAS_K_MIN || (K_SPI_SENSORLESS && K_HOME_TO_MIN)
+        #if USE_K_MIN || (K_SPI_SENSORLESS && K_HOME_TO_MIN)
           PROCESS_ENDSTOP(K, MIN);
         #endif
       }
       else { // +direction
-        #if HAS_K_MAX || (K_SPI_SENSORLESS && K_HOME_TO_MAX)
+        #if USE_K_MAX || (K_SPI_SENSORLESS && K_HOME_TO_MAX)
           PROCESS_ENDSTOP(K, MAX);
         #endif
       }
@@ -1025,12 +1025,12 @@ void Endstops::update() {
   #if HAS_U_AXIS
     if (stepper.axis_is_moving(U_AXIS)) {
       if (stepper.motor_direction(U_AXIS_HEAD)) { // -direction
-        #if HAS_U_MIN || (U_SPI_SENSORLESS && U_HOME_TO_MIN)
+        #if USE_U_MIN || (U_SPI_SENSORLESS && U_HOME_TO_MIN)
           PROCESS_ENDSTOP(U, MIN);
         #endif
       }
       else { // +direction
-        #if HAS_U_MAX || (U_SPI_SENSORLESS && U_HOME_TO_MAX)
+        #if USE_U_MAX || (U_SPI_SENSORLESS && U_HOME_TO_MAX)
           PROCESS_ENDSTOP(U, MAX);
         #endif
       }
@@ -1040,12 +1040,12 @@ void Endstops::update() {
   #if HAS_V_AXIS
     if (stepper.axis_is_moving(V_AXIS)) {
       if (stepper.motor_direction(V_AXIS_HEAD)) { // -direction
-        #if HAS_V_MIN || (V_SPI_SENSORLESS && V_HOME_TO_MIN)
+        #if USE_V_MIN || (V_SPI_SENSORLESS && V_HOME_TO_MIN)
           PROCESS_ENDSTOP(V, MIN);
         #endif
       }
       else { // +direction
-        #if HAS_V_MAX || (V_SPI_SENSORLESS && V_HOME_TO_MAX)
+        #if USE_V_MAX || (V_SPI_SENSORLESS && V_HOME_TO_MAX)
           PROCESS_ENDSTOP(V, MAX);
         #endif
       }
@@ -1055,12 +1055,12 @@ void Endstops::update() {
   #if HAS_W_AXIS
     if (stepper.axis_is_moving(W_AXIS)) {
       if (stepper.motor_direction(W_AXIS_HEAD)) { // -direction
-        #if HAS_W_MIN || (W_SPI_SENSORLESS && W_HOME_TO_MIN)
+        #if USE_W_MIN || (W_SPI_SENSORLESS && W_HOME_TO_MIN)
           PROCESS_ENDSTOP(W, MIN);
         #endif
       }
       else { // +direction
-        #if HAS_W_MAX || (W_SPI_SENSORLESS && W_HOME_TO_MAX)
+        #if USE_W_MAX || (W_SPI_SENSORLESS && W_HOME_TO_MAX)
           PROCESS_ENDSTOP(W, MAX);
         #endif
       }
@@ -1171,91 +1171,91 @@ void Endstops::update() {
 
     #define ES_GET_STATE(S) if (READ_ENDSTOP(S##_PIN)) SBI(live_state_local, S)
 
-    #if HAS_X_MIN
+    #if USE_X_MIN
       ES_GET_STATE(X_MIN);
     #endif
-    #if HAS_X_MAX
+    #if USE_X_MAX
       ES_GET_STATE(X_MAX);
     #endif
-    #if HAS_Y_MIN
+    #if USE_Y_MIN
       ES_GET_STATE(Y_MIN);
     #endif
-    #if HAS_Y_MAX
+    #if USE_Y_MAX
       ES_GET_STATE(Y_MAX);
     #endif
     #if HAS_Z_MIN_PIN
       ES_GET_STATE(Z_MIN);
     #endif
-    #if HAS_Z_MAX
+    #if USE_Z_MAX
       ES_GET_STATE(Z_MAX);
     #endif
-    #if HAS_Z_MIN_PROBE_PIN
+    #if USE_Z_MIN_PROBE
       ES_GET_STATE(Z_MIN_PROBE);
     #endif
-    #if HAS_X2_MIN
+    #if USE_X2_MIN
       ES_GET_STATE(X2_MIN);
     #endif
-    #if HAS_X2_MAX
+    #if USE_X2_MAX
       ES_GET_STATE(X2_MAX);
     #endif
-    #if HAS_Y2_MIN
+    #if USE_Y2_MIN
       ES_GET_STATE(Y2_MIN);
     #endif
-    #if HAS_Y2_MAX
+    #if USE_Y2_MAX
       ES_GET_STATE(Y2_MAX);
     #endif
-    #if HAS_Z2_MIN
+    #if USE_Z2_MIN
       ES_GET_STATE(Z2_MIN);
     #endif
-    #if HAS_Z2_MAX
+    #if USE_Z2_MAX
       ES_GET_STATE(Z2_MAX);
     #endif
-    #if HAS_Z3_MIN
+    #if USE_Z3_MIN
       ES_GET_STATE(Z3_MIN);
     #endif
-    #if HAS_Z3_MAX
+    #if USE_Z3_MAX
       ES_GET_STATE(Z3_MAX);
     #endif
-    #if HAS_Z4_MIN
+    #if USE_Z4_MIN
       ES_GET_STATE(Z4_MIN);
     #endif
-    #if HAS_Z4_MAX
+    #if USE_Z4_MAX
       ES_GET_STATE(Z4_MAX);
     #endif
-    #if HAS_I_MAX
+    #if USE_I_MAX
       ES_GET_STATE(I_MAX);
     #endif
-    #if HAS_I_MIN
+    #if USE_I_MIN
       ES_GET_STATE(I_MIN);
     #endif
-    #if HAS_J_MAX
+    #if USE_J_MAX
       ES_GET_STATE(J_MAX);
     #endif
-    #if HAS_J_MIN
+    #if USE_J_MIN
       ES_GET_STATE(J_MIN);
     #endif
-    #if HAS_K_MAX
+    #if USE_K_MAX
       ES_GET_STATE(K_MAX);
     #endif
-    #if HAS_K_MIN
+    #if USE_K_MIN
       ES_GET_STATE(K_MIN);
     #endif
-    #if HAS_U_MAX
+    #if USE_U_MAX
       ES_GET_STATE(U_MAX);
     #endif
-    #if HAS_U_MIN
+    #if USE_U_MIN
       ES_GET_STATE(U_MIN);
     #endif
-    #if HAS_V_MAX
+    #if USE_V_MAX
       ES_GET_STATE(V_MAX);
     #endif
-    #if HAS_V_MIN
+    #if USE_V_MIN
       ES_GET_STATE(V_MIN);
     #endif
-    #if HAS_W_MAX
+    #if USE_W_MAX
       ES_GET_STATE(W_MAX);
     #endif
-    #if HAS_W_MIN
+    #if USE_W_MIN
       ES_GET_STATE(W_MIN);
     #endif
 
@@ -1263,91 +1263,91 @@ void Endstops::update() {
     #define ES_REPORT_CHANGE(S) if (TEST(endstop_change, S)) SERIAL_ECHOPGM("  " STRINGIFY(S) ":", TEST(live_state_local, S))
 
     if (endstop_change) {
-      #if HAS_X_MIN
+      #if USE_X_MIN
         ES_REPORT_CHANGE(X_MIN);
       #endif
-      #if HAS_X_MAX
+      #if USE_X_MAX
         ES_REPORT_CHANGE(X_MAX);
       #endif
-      #if HAS_Y_MIN
+      #if USE_Y_MIN
         ES_REPORT_CHANGE(Y_MIN);
       #endif
-      #if HAS_Y_MAX
+      #if USE_Y_MAX
         ES_REPORT_CHANGE(Y_MAX);
       #endif
-      #if HAS_Z_MIN
+      #if USE_Z_MIN
         ES_REPORT_CHANGE(Z_MIN);
       #endif
-      #if HAS_Z_MAX
+      #if USE_Z_MAX
         ES_REPORT_CHANGE(Z_MAX);
       #endif
-      #if HAS_Z_MIN_PROBE_PIN
+      #if USE_Z_MIN_PROBE
         ES_REPORT_CHANGE(Z_MIN_PROBE);
       #endif
-      #if HAS_X2_MIN
+      #if USE_X2_MIN
         ES_REPORT_CHANGE(X2_MIN);
       #endif
-      #if HAS_X2_MAX
+      #if USE_X2_MAX
         ES_REPORT_CHANGE(X2_MAX);
       #endif
-      #if HAS_Y2_MIN
+      #if USE_Y2_MIN
         ES_REPORT_CHANGE(Y2_MIN);
       #endif
-      #if HAS_Y2_MAX
+      #if USE_Y2_MAX
         ES_REPORT_CHANGE(Y2_MAX);
       #endif
-      #if HAS_Z2_MIN
+      #if USE_Z2_MIN
         ES_REPORT_CHANGE(Z2_MIN);
       #endif
-      #if HAS_Z2_MAX
+      #if USE_Z2_MAX
         ES_REPORT_CHANGE(Z2_MAX);
       #endif
-      #if HAS_Z3_MIN
+      #if USE_Z3_MIN
         ES_REPORT_CHANGE(Z3_MIN);
       #endif
-      #if HAS_Z3_MAX
+      #if USE_Z3_MAX
         ES_REPORT_CHANGE(Z3_MAX);
       #endif
-      #if HAS_Z4_MIN
+      #if USE_Z4_MIN
         ES_REPORT_CHANGE(Z4_MIN);
       #endif
-      #if HAS_Z4_MAX
+      #if USE_Z4_MAX
         ES_REPORT_CHANGE(Z4_MAX);
       #endif
-      #if HAS_I_MIN
+      #if USE_I_MIN
         ES_REPORT_CHANGE(I_MIN);
       #endif
-      #if HAS_I_MAX
+      #if USE_I_MAX
         ES_REPORT_CHANGE(I_MAX);
       #endif
-      #if HAS_J_MIN
+      #if USE_J_MIN
         ES_REPORT_CHANGE(J_MIN);
       #endif
-      #if HAS_J_MAX
+      #if USE_J_MAX
         ES_REPORT_CHANGE(J_MAX);
       #endif
-      #if HAS_K_MIN
+      #if USE_K_MIN
         ES_REPORT_CHANGE(K_MIN);
       #endif
-      #if HAS_K_MAX
+      #if USE_K_MAX
         ES_REPORT_CHANGE(K_MAX);
       #endif
-      #if HAS_U_MIN
+      #if USE_U_MIN
         ES_REPORT_CHANGE(U_MIN);
       #endif
-      #if HAS_U_MAX
+      #if USE_U_MAX
         ES_REPORT_CHANGE(U_MAX);
       #endif
-      #if HAS_V_MIN
+      #if USE_V_MIN
         ES_REPORT_CHANGE(V_MIN);
       #endif
-      #if HAS_V_MAX
+      #if USE_V_MAX
         ES_REPORT_CHANGE(V_MAX);
       #endif
-      #if HAS_W_MIN
+      #if USE_W_MIN
         ES_REPORT_CHANGE(W_MIN);
       #endif
-      #if HAS_W_MAX
+      #if USE_W_MAX
         ES_REPORT_CHANGE(W_MAX);
       #endif
 
@@ -1419,6 +1419,6 @@ void Endstops::update() {
         safe_delay(SENSORLESS_STALLGUARD_DELAY); // Short delay needed to settle
       #endif
 
-    #endif // XYZ
+    #endif
   }
-#endif
+#endif // USE_SENSORLESS

commit 573bc7344bcd66c08bf8cccbc90a29faa4d55030
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 29 20:20:49 2023 -0500

    üé® NORM_E_DIR => FWD_E_DIR

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index ca231f1cb2..668be5f1f4 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -866,36 +866,38 @@ void Endstops::update() {
 
   // Signal, after validation, if an endstop limit is pressed or not
 
-  if (stepper.axis_is_moving(X_AXIS)) {
-    if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
-      #if HAS_X_MIN || (X_SPI_SENSORLESS && X_HOME_TO_MIN)
-        PROCESS_ENDSTOP_X(MIN);
-        #if   CORE_DIAG(XY, Y, MIN)
-          PROCESS_CORE_ENDSTOP(Y,MIN,X,MIN);
-        #elif CORE_DIAG(XY, Y, MAX)
-          PROCESS_CORE_ENDSTOP(Y,MAX,X,MIN);
-        #elif CORE_DIAG(XZ, Z, MIN)
-          PROCESS_CORE_ENDSTOP(Z,MIN,X,MIN);
-        #elif CORE_DIAG(XZ, Z, MAX)
-          PROCESS_CORE_ENDSTOP(Z,MAX,X,MIN);
+  #if HAS_X_AXIS
+    if (stepper.axis_is_moving(X_AXIS)) {
+      if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
+        #if HAS_X_MIN || (X_SPI_SENSORLESS && X_HOME_TO_MIN)
+          PROCESS_ENDSTOP_X(MIN);
+          #if   CORE_DIAG(XY, Y, MIN)
+            PROCESS_CORE_ENDSTOP(Y,MIN,X,MIN);
+          #elif CORE_DIAG(XY, Y, MAX)
+            PROCESS_CORE_ENDSTOP(Y,MAX,X,MIN);
+          #elif CORE_DIAG(XZ, Z, MIN)
+            PROCESS_CORE_ENDSTOP(Z,MIN,X,MIN);
+          #elif CORE_DIAG(XZ, Z, MAX)
+            PROCESS_CORE_ENDSTOP(Z,MAX,X,MIN);
+          #endif
         #endif
-      #endif
-    }
-    else { // +direction
-      #if HAS_X_MAX || (X_SPI_SENSORLESS && X_HOME_TO_MAX)
-        PROCESS_ENDSTOP_X(MAX);
-        #if   CORE_DIAG(XY, Y, MIN)
-          PROCESS_CORE_ENDSTOP(Y,MIN,X,MAX);
-        #elif CORE_DIAG(XY, Y, MAX)
-          PROCESS_CORE_ENDSTOP(Y,MAX,X,MAX);
-        #elif CORE_DIAG(XZ, Z, MIN)
-          PROCESS_CORE_ENDSTOP(Z,MIN,X,MAX);
-        #elif CORE_DIAG(XZ, Z, MAX)
-          PROCESS_CORE_ENDSTOP(Z,MAX,X,MAX);
+      }
+      else { // +direction
+        #if HAS_X_MAX || (X_SPI_SENSORLESS && X_HOME_TO_MAX)
+          PROCESS_ENDSTOP_X(MAX);
+          #if   CORE_DIAG(XY, Y, MIN)
+            PROCESS_CORE_ENDSTOP(Y,MIN,X,MAX);
+          #elif CORE_DIAG(XY, Y, MAX)
+            PROCESS_CORE_ENDSTOP(Y,MAX,X,MAX);
+          #elif CORE_DIAG(XZ, Z, MIN)
+            PROCESS_CORE_ENDSTOP(Z,MIN,X,MAX);
+          #elif CORE_DIAG(XZ, Z, MAX)
+            PROCESS_CORE_ENDSTOP(Z,MAX,X,MAX);
+          #endif
         #endif
-      #endif
+      }
     }
-  }
+  #endif // HAS_X_AXIS
 
   #if HAS_Y_AXIS
     if (stepper.axis_is_moving(Y_AXIS)) {
@@ -928,7 +930,7 @@ void Endstops::update() {
         #endif
       }
     }
-  #endif
+  #endif // HAS_Y_AXIS
 
   #if HAS_Z_AXIS
     if (stepper.axis_is_moving(Z_AXIS)) {
@@ -973,7 +975,7 @@ void Endstops::update() {
         #endif
       }
     }
-  #endif
+  #endif // HAS_Z_AXIS
 
   #if HAS_I_AXIS
     if (stepper.axis_is_moving(I_AXIS)) {
@@ -988,7 +990,7 @@ void Endstops::update() {
         #endif
       }
     }
-  #endif
+  #endif // HAS_I_AXIS
 
   #if HAS_J_AXIS
     if (stepper.axis_is_moving(J_AXIS)) {
@@ -1003,7 +1005,7 @@ void Endstops::update() {
         #endif
       }
     }
-  #endif
+  #endif // HAS_J_AXIS
 
   #if HAS_K_AXIS
     if (stepper.axis_is_moving(K_AXIS)) {
@@ -1018,7 +1020,7 @@ void Endstops::update() {
         #endif
       }
     }
-  #endif
+  #endif // HAS_K_AXIS
 
   #if HAS_U_AXIS
     if (stepper.axis_is_moving(U_AXIS)) {
@@ -1033,7 +1035,7 @@ void Endstops::update() {
         #endif
       }
     }
-  #endif
+  #endif // HAS_U_AXIS
 
   #if HAS_V_AXIS
     if (stepper.axis_is_moving(V_AXIS)) {
@@ -1048,7 +1050,7 @@ void Endstops::update() {
         #endif
       }
     }
-  #endif
+  #endif // HAS_V_AXIS
 
   #if HAS_W_AXIS
     if (stepper.axis_is_moving(W_AXIS)) {
@@ -1063,7 +1065,7 @@ void Endstops::update() {
         #endif
       }
     }
-  #endif
+  #endif // HAS_W_AXIS
 } // Endstops::update()
 
 #if ENABLED(SPI_ENDSTOPS)

commit 467ab74523087a852ab50939d86a0ca0b78f17ad
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 26 14:56:23 2023 -0500

    üßë‚Äçüíª Simplify endstops config (#25748)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 233d848425..ca231f1cb2 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -134,7 +134,7 @@ void Endstops::init() {
   #if HAS_Y2_MAX
     _INIT_ENDSTOP(MAX,Y,2);
   #endif
-  #if HAS_Z_MIN
+  #if HAS_Z_MIN_PIN
     _INIT_ENDSTOP(MIN,Z,);
   #endif
   #if HAS_Z_MAX
@@ -598,7 +598,9 @@ void Endstops::update() {
   #endif
 
   #if HAS_Z_MIN && NONE(Z_SPI_SENSORLESS, Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
-    UPDATE_LIVE_STATE(Z, MIN);
+    #if HAS_Z_MIN_PIN
+      UPDATE_LIVE_STATE(Z, MIN);
+    #endif
     #if ENABLED(Z_MULTI_ENDSTOPS)
       #if HAS_Z2_MIN
         UPDATE_LIVE_STATE(Z2, MIN);
@@ -1179,7 +1181,7 @@ void Endstops::update() {
     #if HAS_Y_MAX
       ES_GET_STATE(Y_MAX);
     #endif
-    #if HAS_Z_MIN
+    #if HAS_Z_MIN_PIN
       ES_GET_STATE(Z_MIN);
     #endif
     #if HAS_Z_MAX

commit d364babbc0cdb73337d86e2c4fd9170b46b7361a
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 26 14:29:21 2023 -0500

    üßë‚Äçüíª Change HAL_PATH macro for easier HAL relocation (#25743)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 25553a98ac..233d848425 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -35,7 +35,7 @@
 #include "../core/debug_out.h"
 
 #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-  #include HAL_PATH(../HAL, endstop_interrupts.h)
+  #include HAL_PATH(.., endstop_interrupts.h)
 #endif
 
 #if BOTH(SD_ABORT_ON_ENDSTOP_HIT, HAS_MEDIA)

commit 68f74784a3a41c643984ee62a507b25903430591
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 26 13:50:45 2023 -0500

    üé® Misc. fixes, cleanup

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 56444d1aee..25553a98ac 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -514,12 +514,12 @@ void Endstops::update() {
   #endif
 
   // Macros to update / copy the live_state
-  #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT_TO(live_state, _ENDSTOP(AXIS, MINMAX), (READ_ENDSTOP(_ENDSTOP_PIN(AXIS, MINMAX)) == _ENDSTOP_HIT_STATE(AXIS, MINMAX)))
+  #define UPDATE_LIVE_STATE(AXIS, MINMAX) SET_BIT_TO(live_state, _ENDSTOP(AXIS, MINMAX), (READ_ENDSTOP(_ENDSTOP_PIN(AXIS, MINMAX)) == _ENDSTOP_HIT_STATE(AXIS, MINMAX)))
   #define COPY_LIVE_STATE(SRC_BIT, DST_BIT) SET_BIT_TO(live_state, DST_BIT, TEST(live_state, SRC_BIT))
 
   #if ENABLED(G38_PROBE_TARGET)
     // For G38 moves check the probe's pin for ALL movement
-    if (G38_move) UPDATE_ENDSTOP_BIT(Z, TERN(USES_Z_MIN_PROBE_PIN, MIN_PROBE, MIN));
+    if (G38_move) UPDATE_LIVE_STATE(Z, TERN(USES_Z_MIN_PROBE_PIN, MIN_PROBE, MIN));
   #endif
 
   // With Dual X, endstops are only checked in the homing direction for the active extruder
@@ -554,10 +554,10 @@ void Endstops::update() {
    * Check and update endstops
    */
   #if HAS_X_MIN && !X_SPI_SENSORLESS
-    UPDATE_ENDSTOP_BIT(X, MIN);
+    UPDATE_LIVE_STATE(X, MIN);
     #if ENABLED(X_DUAL_ENDSTOPS)
       #if HAS_X2_MIN
-        UPDATE_ENDSTOP_BIT(X2, MIN);
+        UPDATE_LIVE_STATE(X2, MIN);
       #else
         COPY_LIVE_STATE(X_MIN, X2_MIN);
       #endif
@@ -565,10 +565,10 @@ void Endstops::update() {
   #endif
 
   #if HAS_X_MAX && !X_SPI_SENSORLESS
-    UPDATE_ENDSTOP_BIT(X, MAX);
+    UPDATE_LIVE_STATE(X, MAX);
     #if ENABLED(X_DUAL_ENDSTOPS)
       #if HAS_X2_MAX
-        UPDATE_ENDSTOP_BIT(X2, MAX);
+        UPDATE_LIVE_STATE(X2, MAX);
       #else
         COPY_LIVE_STATE(X_MAX, X2_MAX);
       #endif
@@ -576,10 +576,10 @@ void Endstops::update() {
   #endif
 
   #if HAS_Y_MIN && !Y_SPI_SENSORLESS
-    UPDATE_ENDSTOP_BIT(Y, MIN);
+    UPDATE_LIVE_STATE(Y, MIN);
     #if ENABLED(Y_DUAL_ENDSTOPS)
       #if HAS_Y2_MIN
-        UPDATE_ENDSTOP_BIT(Y2, MIN);
+        UPDATE_LIVE_STATE(Y2, MIN);
       #else
         COPY_LIVE_STATE(Y_MIN, Y2_MIN);
       #endif
@@ -587,10 +587,10 @@ void Endstops::update() {
   #endif
 
   #if HAS_Y_MAX && !Y_SPI_SENSORLESS
-    UPDATE_ENDSTOP_BIT(Y, MAX);
+    UPDATE_LIVE_STATE(Y, MAX);
     #if ENABLED(Y_DUAL_ENDSTOPS)
       #if HAS_Y2_MAX
-        UPDATE_ENDSTOP_BIT(Y2, MAX);
+        UPDATE_LIVE_STATE(Y2, MAX);
       #else
         COPY_LIVE_STATE(Y_MAX, Y2_MAX);
       #endif
@@ -598,23 +598,23 @@ void Endstops::update() {
   #endif
 
   #if HAS_Z_MIN && NONE(Z_SPI_SENSORLESS, Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
-    UPDATE_ENDSTOP_BIT(Z, MIN);
+    UPDATE_LIVE_STATE(Z, MIN);
     #if ENABLED(Z_MULTI_ENDSTOPS)
       #if HAS_Z2_MIN
-        UPDATE_ENDSTOP_BIT(Z2, MIN);
+        UPDATE_LIVE_STATE(Z2, MIN);
       #else
         COPY_LIVE_STATE(Z_MIN, Z2_MIN);
       #endif
       #if NUM_Z_STEPPERS >= 3
         #if HAS_Z3_MIN
-          UPDATE_ENDSTOP_BIT(Z3, MIN);
+          UPDATE_LIVE_STATE(Z3, MIN);
         #else
           COPY_LIVE_STATE(Z_MIN, Z3_MIN);
         #endif
       #endif
       #if NUM_Z_STEPPERS >= 4
         #if HAS_Z4_MIN
-          UPDATE_ENDSTOP_BIT(Z4, MIN);
+          UPDATE_LIVE_STATE(Z4, MIN);
         #else
           COPY_LIVE_STATE(Z_MIN, Z4_MIN);
         #endif
@@ -625,189 +625,129 @@ void Endstops::update() {
   #if HAS_BED_PROBE
     // When closing the gap check the enabled probe
     if (probe_switch_activated())
-      UPDATE_ENDSTOP_BIT(Z, TERN(USES_Z_MIN_PROBE_PIN, MIN_PROBE, MIN));
+      UPDATE_LIVE_STATE(Z, TERN(USES_Z_MIN_PROBE_PIN, MIN_PROBE, MIN));
   #endif
 
   #if HAS_Z_MAX && !Z_SPI_SENSORLESS
     // Check both Z dual endstops
     #if ENABLED(Z_MULTI_ENDSTOPS)
-      UPDATE_ENDSTOP_BIT(Z, MAX);
+      UPDATE_LIVE_STATE(Z, MAX);
       #if HAS_Z2_MAX
-        UPDATE_ENDSTOP_BIT(Z2, MAX);
+        UPDATE_LIVE_STATE(Z2, MAX);
       #else
         COPY_LIVE_STATE(Z_MAX, Z2_MAX);
       #endif
       #if NUM_Z_STEPPERS >= 3
         #if HAS_Z3_MAX
-          UPDATE_ENDSTOP_BIT(Z3, MAX);
+          UPDATE_LIVE_STATE(Z3, MAX);
         #else
           COPY_LIVE_STATE(Z_MAX, Z3_MAX);
         #endif
       #endif
       #if NUM_Z_STEPPERS >= 4
         #if HAS_Z4_MAX
-          UPDATE_ENDSTOP_BIT(Z4, MAX);
+          UPDATE_LIVE_STATE(Z4, MAX);
         #else
           COPY_LIVE_STATE(Z_MAX, Z4_MAX);
         #endif
       #endif
     #elif TERN1(USES_Z_MIN_PROBE_PIN, Z_MAX_PIN != Z_MIN_PROBE_PIN)
       // If this pin isn't the bed probe it's the Z endstop
-      UPDATE_ENDSTOP_BIT(Z, MAX);
+      UPDATE_LIVE_STATE(Z, MAX);
     #endif
   #endif
 
   #if HAS_I_MIN && !I_SPI_SENSORLESS
     #if ENABLED(I_DUAL_ENDSTOPS)
-      UPDATE_ENDSTOP_BIT(I, MIN);
-      #if HAS_I2_MIN
-        UPDATE_ENDSTOP_BIT(I2, MAX);
-      #else
-        COPY_LIVE_STATE(I_MIN, I2_MIN);
-      #endif
+      UPDATE_LIVE_STATE(I, MIN);
     #else
-      UPDATE_ENDSTOP_BIT(I, MIN);
+      UPDATE_LIVE_STATE(I, MIN);
     #endif
   #endif
 
   #if HAS_I_MAX && !I_SPI_SENSORLESS
     #if ENABLED(I_DUAL_ENDSTOPS)
-      UPDATE_ENDSTOP_BIT(I, MAX);
-      #if HAS_I2_MAX
-        UPDATE_ENDSTOP_BIT(I2, MAX);
-      #else
-        COPY_LIVE_STATE(I_MAX, I2_MAX);
-      #endif
+      UPDATE_LIVE_STATE(I, MAX);
     #else
-      UPDATE_ENDSTOP_BIT(I, MAX);
+      UPDATE_LIVE_STATE(I, MAX);
     #endif
   #endif
 
   #if HAS_J_MIN && !J_SPI_SENSORLESS
     #if ENABLED(J_DUAL_ENDSTOPS)
-      UPDATE_ENDSTOP_BIT(J, MIN);
-      #if HAS_J2_MIN
-        UPDATE_ENDSTOP_BIT(J2, MIN);
-      #else
-        COPY_LIVE_STATE(J_MIN, J2_MIN);
-      #endif
+      UPDATE_LIVE_STATE(J, MIN);
     #else
-      UPDATE_ENDSTOP_BIT(J, MIN);
+      UPDATE_LIVE_STATE(J, MIN);
     #endif
   #endif
 
   #if HAS_J_MAX && !J_SPI_SENSORLESS
     #if ENABLED(J_DUAL_ENDSTOPS)
-      UPDATE_ENDSTOP_BIT(J, MAX);
-      #if HAS_J2_MAX
-        UPDATE_ENDSTOP_BIT(J2, MAX);
-      #else
-        COPY_LIVE_STATE(J_MAX, J2_MAX);
-      #endif
+      UPDATE_LIVE_STATE(J, MAX);
     #else
-      UPDATE_ENDSTOP_BIT(J, MAX);
+      UPDATE_LIVE_STATE(J, MAX);
     #endif
   #endif
 
   #if HAS_K_MIN && !K_SPI_SENSORLESS
     #if ENABLED(K_DUAL_ENDSTOPS)
-      UPDATE_ENDSTOP_BIT(K, MIN);
-      #if HAS_K2_MIN
-        UPDATE_ENDSTOP_BIT(K2, MIN);
-      #else
-        COPY_LIVE_STATE(K_MIN, K2_MIN);
-      #endif
+      UPDATE_LIVE_STATE(K, MIN);
     #else
-      UPDATE_ENDSTOP_BIT(K, MIN);
+      UPDATE_LIVE_STATE(K, MIN);
     #endif
   #endif
 
   #if HAS_K_MAX && !K_SPI_SENSORLESS
     #if ENABLED(K_DUAL_ENDSTOPS)
-      UPDATE_ENDSTOP_BIT(K, MAX);
-      #if HAS_K2_MAX
-        UPDATE_ENDSTOP_BIT(K2, MAX);
-      #else
-        COPY_LIVE_STATE(K_MAX, K2_MAX);
-      #endif
+      UPDATE_LIVE_STATE(K, MAX);
     #else
-      UPDATE_ENDSTOP_BIT(K, MAX);
+      UPDATE_LIVE_STATE(K, MAX);
     #endif
   #endif
 
   #if HAS_U_MIN && !U_SPI_SENSORLESS
     #if ENABLED(U_DUAL_ENDSTOPS)
-      UPDATE_ENDSTOP_BIT(U, MIN);
-      #if HAS_U2_MIN
-        UPDATE_ENDSTOP_BIT(U2, MIN);
-      #else
-        COPY_LIVE_STATE(U_MIN, U2_MIN);
-      #endif
+      UPDATE_LIVE_STATE(U, MIN);
     #else
-      UPDATE_ENDSTOP_BIT(U, MIN);
+      UPDATE_LIVE_STATE(U, MIN);
     #endif
   #endif
 
   #if HAS_U_MAX && !U_SPI_SENSORLESS
     #if ENABLED(U_DUAL_ENDSTOPS)
-      UPDATE_ENDSTOP_BIT(U, MAX);
-      #if HAS_U2_MAX
-        UPDATE_ENDSTOP_BIT(U2, MAX);
-      #else
-        COPY_LIVE_STATE(U_MAX, U2_MAX);
-      #endif
+      UPDATE_LIVE_STATE(U, MAX);
     #else
-      UPDATE_ENDSTOP_BIT(U, MAX);
+      UPDATE_LIVE_STATE(U, MAX);
     #endif
   #endif
 
   #if HAS_V_MIN && !V_SPI_SENSORLESS
     #if ENABLED(V_DUAL_ENDSTOPS)
-      UPDATE_ENDSTOP_BIT(V, MIN);
-      #if HAS_V2_MIN
-        UPDATE_ENDSTOP_BIT(V2, MIN);
-      #else
-        COPY_LIVE_STATE(V_MIN, V2_MIN);
-      #endif
+      UPDATE_LIVE_STATE(V, MIN);
     #else
-      UPDATE_ENDSTOP_BIT(V, MIN);
+      UPDATE_LIVE_STATE(V, MIN);
     #endif
   #endif
   #if HAS_V_MAX && !V_SPI_SENSORLESS
     #if ENABLED(O_DUAL_ENDSTOPS)
-      UPDATE_ENDSTOP_BIT(V, MAX);
-      #if HAS_V2_MAX
-        UPDATE_ENDSTOP_BIT(V2, MAX);
-      #else
-        COPY_LIVE_STATE(V_MAX, V2_MAX);
-      #endif
+      UPDATE_LIVE_STATE(V, MAX);
     #else
-      UPDATE_ENDSTOP_BIT(V, MAX);
+      UPDATE_LIVE_STATE(V, MAX);
     #endif
   #endif
 
   #if HAS_W_MIN && !W_SPI_SENSORLESS
     #if ENABLED(W_DUAL_ENDSTOPS)
-      UPDATE_ENDSTOP_BIT(W, MIN);
-      #if HAS_W2_MIN
-        UPDATE_ENDSTOP_BIT(W2, MIN);
-      #else
-        COPY_LIVE_STATE(W_MIN, W2_MIN);
-      #endif
+      UPDATE_LIVE_STATE(W, MIN);
     #else
-      UPDATE_ENDSTOP_BIT(W, MIN);
+      UPDATE_LIVE_STATE(W, MIN);
     #endif
   #endif
   #if HAS_W_MAX && !W_SPI_SENSORLESS
     #if ENABLED(W_DUAL_ENDSTOPS)
-      UPDATE_ENDSTOP_BIT(W, MAX);
-      #if HAS_W2_MAX
-        UPDATE_ENDSTOP_BIT(W2, MAX);
-      #else
-        COPY_LIVE_STATE(W_MAX, W2_MAX);
-      #endif
+      UPDATE_LIVE_STATE(W, MAX);
     #else
-      UPDATE_ENDSTOP_BIT(W, MAX);
+      UPDATE_LIVE_STATE(W, MAX);
     #endif
   #endif
 

commit 5664c02d077e028f84a24efd96c2eebe97ce8763
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 22 22:43:09 2023 -0500

    üßë‚Äçüíª Generalize SDSUPPORT as HAS_MEDIA
    
    In preparation for single- and multi-volume refactoring.

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 02af062eca..56444d1aee 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -38,7 +38,7 @@
   #include HAL_PATH(../HAL, endstop_interrupts.h)
 #endif
 
-#if BOTH(SD_ABORT_ON_ENDSTOP_HIT, SDSUPPORT)
+#if BOTH(SD_ABORT_ON_ENDSTOP_HIT, HAS_MEDIA)
   #include "printcounter.h" // for print_job_timer
 #endif
 
@@ -352,7 +352,7 @@ void Endstops::event_handler() {
       )
     );
 
-    #if BOTH(SD_ABORT_ON_ENDSTOP_HIT, SDSUPPORT)
+    #if BOTH(SD_ABORT_ON_ENDSTOP_HIT, HAS_MEDIA)
       if (planner.abort_on_endstop_hit) {
         card.abortFilePrintNow();
         quickstop_stepper();

commit de7726ca019461d029f9fe2a14a85b8ecf8723fe
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Wed Apr 19 17:21:53 2023 -0700

    üö∏ Permit G38 with Core (#25713)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index ccad00062e..02af062eca 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -517,8 +517,7 @@ void Endstops::update() {
   #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT_TO(live_state, _ENDSTOP(AXIS, MINMAX), (READ_ENDSTOP(_ENDSTOP_PIN(AXIS, MINMAX)) == _ENDSTOP_HIT_STATE(AXIS, MINMAX)))
   #define COPY_LIVE_STATE(SRC_BIT, DST_BIT) SET_BIT_TO(live_state, DST_BIT, TEST(live_state, SRC_BIT))
 
-  #if ENABLED(G38_PROBE_TARGET) && NONE(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY, MARKFORGED_YX)
-    #define HAS_G38_PROBE 1
+  #if ENABLED(G38_PROBE_TARGET)
     // For G38 moves check the probe's pin for ALL movement
     if (G38_move) UPDATE_ENDSTOP_BIT(Z, TERN(USES_Z_MIN_PROBE_PIN, MIN_PROBE, MIN));
   #endif
@@ -912,9 +911,9 @@ void Endstops::update() {
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_DUAL_ENDSTOP(Z, MINMAX)
   #endif
 
-  #if HAS_G38_PROBE // TODO (DerAndere): Add support for HAS_I_AXIS
+  #if ENABLED(G38_PROBE_TARGET)
     // For G38 moves check the probe's pin for ALL movement
-    if (G38_move && TEST_ENDSTOP(_ENDSTOP(Z, TERN(USES_Z_MIN_PROBE_PIN, MIN_PROBE, MIN))) == TERN1(G38_PROBE_AWAY, (G38_move < 4))) {
+    if (G38_move && TEST_ENDSTOP(Z_MIN_PROBE) == TERN1(G38_PROBE_AWAY, (G38_move < 4))) {
       G38_did_trigger = true;
       #define _G38_SET(Q) | (stepper.axis_is_moving(_AXIS(Q)) << _AXIS(Q))
       #define _G38_RESP(Q) if (moving[_AXIS(Q)]) { _ENDSTOP_HIT(Q, ENDSTOP); planner.endstop_triggered(_AXIS(Q)); }

commit fad1dcefbcd300128b474783f1183ea8a6d18496
Author: Jay Robson <45777442+jsrobson10@users.noreply.github.com>
Date:   Thu Apr 20 06:58:42 2023 +1000

    üêõ Fix G38 with Z, support 9 axes (#25691)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 6719925f15..ccad00062e 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -913,17 +913,13 @@ void Endstops::update() {
   #endif
 
   #if HAS_G38_PROBE // TODO (DerAndere): Add support for HAS_I_AXIS
-    #define _G38_OPEN_STATE TERN(G38_PROBE_AWAY, (G38_move >= 4), LOW)
     // For G38 moves check the probe's pin for ALL movement
-    if (G38_move && TEST_ENDSTOP(_ENDSTOP(Z, TERN(USES_Z_MIN_PROBE_PIN, MIN_PROBE, MIN))) != _G38_OPEN_STATE) {
-             if (stepper.axis_is_moving(X_AXIS)) { _ENDSTOP_HIT(X, TERN(X_HOME_TO_MIN, MIN, MAX)); planner.endstop_triggered(X_AXIS); }
-      #if HAS_Y_AXIS
-        else if (stepper.axis_is_moving(Y_AXIS)) { _ENDSTOP_HIT(Y, TERN(Y_HOME_TO_MIN, MIN, MAX)); planner.endstop_triggered(Y_AXIS); }
-      #endif
-      #if HAS_Z_AXIS
-        else if (stepper.axis_is_moving(Z_AXIS)) { _ENDSTOP_HIT(Z, TERN(Z_HOME_TO_MIN, MIN, MAX)); planner.endstop_triggered(Z_AXIS); }
-      #endif
+    if (G38_move && TEST_ENDSTOP(_ENDSTOP(Z, TERN(USES_Z_MIN_PROBE_PIN, MIN_PROBE, MIN))) == TERN1(G38_PROBE_AWAY, (G38_move < 4))) {
       G38_did_trigger = true;
+      #define _G38_SET(Q) | (stepper.axis_is_moving(_AXIS(Q)) << _AXIS(Q))
+      #define _G38_RESP(Q) if (moving[_AXIS(Q)]) { _ENDSTOP_HIT(Q, ENDSTOP); planner.endstop_triggered(_AXIS(Q)); }
+      const Flags<NUM_AXES> moving = { value_t(NUM_AXES)(0 MAIN_AXIS_MAP(_G38_SET)) };
+      MAIN_AXIS_MAP(_G38_RESP);
     }
   #endif
 

commit de0cd660705668f2e9f1e0cb8fff80b40be0f4e6
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Mar 28 05:39:35 2023 -0500

    üé® Misc. cleanup

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 9d73210025..6719925f15 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -1143,7 +1143,7 @@ void Endstops::update() {
         #endif
       )) { SBI(live_state, X_ENDSTOP); hit = true; }
       #if ENABLED(X_DUAL_ENDSTOPS)
-	      if (tmc_spi_homing.x && stepperX2.test_stall_status()) { SBI(live_state, X2_ENDSTOP); hit = true; }
+        if (tmc_spi_homing.x && stepperX2.test_stall_status()) { SBI(live_state, X2_ENDSTOP); hit = true; }
       #endif
     #endif
     #if Y_SPI_SENSORLESS
@@ -1155,7 +1155,7 @@ void Endstops::update() {
         #endif
       )) { SBI(live_state, Y_ENDSTOP); hit = true; }
       #if ENABLED(Y_DUAL_ENDSTOPS)
-	      if (tmc_spi_homing.y && stepperY2.test_stall_status()) { SBI(live_state, Y2_ENDSTOP); hit = true; }
+        if (tmc_spi_homing.y && stepperY2.test_stall_status()) { SBI(live_state, Y2_ENDSTOP); hit = true; }
       #endif
     #endif
     #if Z_SPI_SENSORLESS

commit ea5d7e2eee641122ddf56705f6c9060d84a20df3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Mar 26 04:00:12 2023 -0500

    üîß Refactor endstop state config (#25574)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index ef5f5d06e1..9d73210025 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -109,284 +109,90 @@ Endstops::endstop_mask_t Endstops::live_state = 0;
 
 void Endstops::init() {
 
+  #define _INIT_ENDSTOP(T,A,N) TERN(ENDSTOPPULLUP_##A##T, SET_INPUT_PULLUP, TERN(ENDSTOPPULLDOWN_##A##T, SET_INPUT_PULLDOWN, SET_INPUT))(A##N##_##T##_PIN)
   #if HAS_X_MIN
-    #if ENABLED(ENDSTOPPULLUP_XMIN)
-      SET_INPUT_PULLUP(X_MIN_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_XMIN)
-      SET_INPUT_PULLDOWN(X_MIN_PIN);
-    #else
-      SET_INPUT(X_MIN_PIN);
-    #endif
-  #endif
-
-  #if HAS_X2_MIN
-    #if ENABLED(ENDSTOPPULLUP_XMIN)
-      SET_INPUT_PULLUP(X2_MIN_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_XMIN)
-      SET_INPUT_PULLDOWN(X2_MIN_PIN);
-    #else
-      SET_INPUT(X2_MIN_PIN);
-    #endif
-  #endif
-
-  #if HAS_Y_MIN
-    #if ENABLED(ENDSTOPPULLUP_YMIN)
-      SET_INPUT_PULLUP(Y_MIN_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_YMIN)
-      SET_INPUT_PULLDOWN(Y_MIN_PIN);
-    #else
-      SET_INPUT(Y_MIN_PIN);
-    #endif
-  #endif
-
-  #if HAS_Y2_MIN
-    #if ENABLED(ENDSTOPPULLUP_YMIN)
-      SET_INPUT_PULLUP(Y2_MIN_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_YMIN)
-      SET_INPUT_PULLDOWN(Y2_MIN_PIN);
-    #else
-      SET_INPUT(Y2_MIN_PIN);
-    #endif
-  #endif
-
-  #if HAS_Z_MIN
-    #if ENABLED(ENDSTOPPULLUP_ZMIN)
-      SET_INPUT_PULLUP(Z_MIN_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_ZMIN)
-      SET_INPUT_PULLDOWN(Z_MIN_PIN);
-    #else
-      SET_INPUT(Z_MIN_PIN);
-    #endif
-  #endif
-
-  #if HAS_Z2_MIN
-    #if ENABLED(ENDSTOPPULLUP_ZMIN)
-      SET_INPUT_PULLUP(Z2_MIN_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_ZMIN)
-      SET_INPUT_PULLDOWN(Z2_MIN_PIN);
-    #else
-      SET_INPUT(Z2_MIN_PIN);
-    #endif
-  #endif
-
-  #if HAS_Z3_MIN
-    #if ENABLED(ENDSTOPPULLUP_ZMIN)
-      SET_INPUT_PULLUP(Z3_MIN_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_ZMIN)
-      SET_INPUT_PULLDOWN(Z3_MIN_PIN);
-    #else
-      SET_INPUT(Z3_MIN_PIN);
-    #endif
-  #endif
-
-  #if HAS_Z4_MIN
-    #if ENABLED(ENDSTOPPULLUP_ZMIN)
-      SET_INPUT_PULLUP(Z4_MIN_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_ZMIN)
-      SET_INPUT_PULLDOWN(Z4_MIN_PIN);
-    #else
-      SET_INPUT(Z4_MIN_PIN);
-    #endif
+    _INIT_ENDSTOP(MIN,X,);
   #endif
-
   #if HAS_X_MAX
-    #if ENABLED(ENDSTOPPULLUP_XMAX)
-      SET_INPUT_PULLUP(X_MAX_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_XMAX)
-      SET_INPUT_PULLDOWN(X_MAX_PIN);
-    #else
-      SET_INPUT(X_MAX_PIN);
-    #endif
+    _INIT_ENDSTOP(MAX,X,);
+  #endif
+  #if HAS_X2_MIN
+    _INIT_ENDSTOP(MIN,X,2);
   #endif
-
   #if HAS_X2_MAX
-    #if ENABLED(ENDSTOPPULLUP_XMAX)
-      SET_INPUT_PULLUP(X2_MAX_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_XMAX)
-      SET_INPUT_PULLDOWN(X2_MAX_PIN);
-    #else
-      SET_INPUT(X2_MAX_PIN);
-    #endif
+    _INIT_ENDSTOP(MAX,X,2);
+  #endif
+  #if HAS_Y_MIN
+    _INIT_ENDSTOP(MIN,Y,);
   #endif
-
   #if HAS_Y_MAX
-    #if ENABLED(ENDSTOPPULLUP_YMAX)
-      SET_INPUT_PULLUP(Y_MAX_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_YMAX)
-      SET_INPUT_PULLDOWN(Y_MAX_PIN);
-    #else
-      SET_INPUT(Y_MAX_PIN);
-    #endif
+    _INIT_ENDSTOP(MAX,Y,);
+  #endif
+  #if HAS_Y2_MIN
+    _INIT_ENDSTOP(MIN,Y,2);
   #endif
-
   #if HAS_Y2_MAX
-    #if ENABLED(ENDSTOPPULLUP_YMAX)
-      SET_INPUT_PULLUP(Y2_MAX_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_YMAX)
-      SET_INPUT_PULLDOWN(Y2_MAX_PIN);
-    #else
-      SET_INPUT(Y2_MAX_PIN);
-    #endif
+    _INIT_ENDSTOP(MAX,Y,2);
+  #endif
+  #if HAS_Z_MIN
+    _INIT_ENDSTOP(MIN,Z,);
   #endif
-
   #if HAS_Z_MAX
-    #if ENABLED(ENDSTOPPULLUP_ZMAX)
-      SET_INPUT_PULLUP(Z_MAX_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_ZMAX)
-      SET_INPUT_PULLDOWN(Z_MAX_PIN);
-    #else
-      SET_INPUT(Z_MAX_PIN);
-    #endif
+    _INIT_ENDSTOP(MAX,Z,);
+  #endif
+  #if HAS_Z2_MIN
+    _INIT_ENDSTOP(MIN,Z,2);
   #endif
-
   #if HAS_Z2_MAX
-    #if ENABLED(ENDSTOPPULLUP_ZMAX)
-      SET_INPUT_PULLUP(Z2_MAX_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_ZMAX)
-      SET_INPUT_PULLDOWN(Z2_MAX_PIN);
-    #else
-      SET_INPUT(Z2_MAX_PIN);
-    #endif
+    _INIT_ENDSTOP(MAX,Z,2);
+  #endif
+  #if HAS_Z3_MIN
+    _INIT_ENDSTOP(MIN,Z,3);
   #endif
-
   #if HAS_Z3_MAX
-    #if ENABLED(ENDSTOPPULLUP_ZMAX)
-      SET_INPUT_PULLUP(Z3_MAX_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_ZMAX)
-      SET_INPUT_PULLDOWN(Z3_MAX_PIN);
-    #else
-      SET_INPUT(Z3_MAX_PIN);
-    #endif
+    _INIT_ENDSTOP(MAX,Z,3);
+  #endif
+  #if HAS_Z4_MIN
+    _INIT_ENDSTOP(MIN,Z,4);
   #endif
-
   #if HAS_Z4_MAX
-    #if ENABLED(ENDSTOPPULLUP_ZMAX)
-      SET_INPUT_PULLUP(Z4_MAX_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_ZMAX)
-      SET_INPUT_PULLDOWN(Z4_MAX_PIN);
-    #else
-      SET_INPUT(Z4_MAX_PIN);
-    #endif
+    _INIT_ENDSTOP(MAX,Z,4);
   #endif
-
   #if HAS_I_MIN
-    #if ENABLED(ENDSTOPPULLUP_IMIN)
-      SET_INPUT_PULLUP(I_MIN_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_IMIN)
-      SET_INPUT_PULLDOWN(I_MIN_PIN);
-    #else
-      SET_INPUT(I_MIN_PIN);
-    #endif
+    _INIT_ENDSTOP(MIN,I,);
   #endif
-
   #if HAS_I_MAX
-    #if ENABLED(ENDSTOPPULLUP_IMAX)
-      SET_INPUT_PULLUP(I_MAX_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_IMAX)
-      SET_INPUT_PULLDOWN(I_MAX_PIN);
-    #else
-      SET_INPUT(I_MAX_PIN);
-    #endif
+    _INIT_ENDSTOP(MAX,I,);
   #endif
-
   #if HAS_J_MIN
-    #if ENABLED(ENDSTOPPULLUP_JMIN)
-      SET_INPUT_PULLUP(J_MIN_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_IMIN)
-      SET_INPUT_PULLDOWN(J_MIN_PIN);
-    #else
-      SET_INPUT(J_MIN_PIN);
-    #endif
+    _INIT_ENDSTOP(MIN,J,);
   #endif
-
   #if HAS_J_MAX
-    #if ENABLED(ENDSTOPPULLUP_JMAX)
-      SET_INPUT_PULLUP(J_MAX_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_JMAX)
-      SET_INPUT_PULLDOWN(J_MAX_PIN);
-    #else
-      SET_INPUT(J_MAX_PIN);
-    #endif
+    _INIT_ENDSTOP(MAX,J,);
   #endif
-
   #if HAS_K_MIN
-    #if ENABLED(ENDSTOPPULLUP_KMIN)
-      SET_INPUT_PULLUP(K_MIN_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_KMIN)
-      SET_INPUT_PULLDOWN(K_MIN_PIN);
-    #else
-      SET_INPUT(K_MIN_PIN);
-    #endif
+    _INIT_ENDSTOP(MIN,K,);
   #endif
-
   #if HAS_K_MAX
-    #if ENABLED(ENDSTOPPULLUP_KMAX)
-      SET_INPUT_PULLUP(K_MAX_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_KMIN)
-      SET_INPUT_PULLDOWN(K_MAX_PIN);
-    #else
-      SET_INPUT(K_MAX_PIN);
-    #endif
+    _INIT_ENDSTOP(MAX,K,);
   #endif
-
   #if HAS_U_MIN
-    #if ENABLED(ENDSTOPPULLUP_UMIN)
-      SET_INPUT_PULLUP(U_MIN_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_UMIN)
-      SET_INPUT_PULLDOWN(U_MIN_PIN);
-    #else
-      SET_INPUT(U_MIN_PIN);
-    #endif
+    _INIT_ENDSTOP(MIN,U,);
   #endif
-
   #if HAS_U_MAX
-    #if ENABLED(ENDSTOPPULLUP_UMAX)
-      SET_INPUT_PULLUP(U_MAX_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_UMIN)
-      SET_INPUT_PULLDOWN(U_MAX_PIN);
-    #else
-      SET_INPUT(U_MAX_PIN);
-    #endif
+    _INIT_ENDSTOP(MAX,U,);
   #endif
-
   #if HAS_V_MIN
-    #if ENABLED(ENDSTOPPULLUP_VMIN)
-      SET_INPUT_PULLUP(V_MIN_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_VMIN)
-      SET_INPUT_PULLDOWN(V_MIN_PIN);
-    #else
-      SET_INPUT(V_MIN_PIN);
-    #endif
+    _INIT_ENDSTOP(MIN,V,);
   #endif
-
   #if HAS_V_MAX
-    #if ENABLED(ENDSTOPPULLUP_VMAX)
-      SET_INPUT_PULLUP(V_MAX_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_VMIN)
-      SET_INPUT_PULLDOWN(V_MAX_PIN);
-    #else
-      SET_INPUT(V_MAX_PIN);
-    #endif
+    _INIT_ENDSTOP(MAX,V,);
   #endif
-
   #if HAS_W_MIN
-    #if ENABLED(ENDSTOPPULLUP_WMIN)
-      SET_INPUT_PULLUP(W_MIN_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_WMIN)
-      SET_INPUT_PULLDOWN(W_MIN_PIN);
-    #else
-      SET_INPUT(W_MIN_PIN);
-    #endif
+    _INIT_ENDSTOP(MIN,W,);
   #endif
-
   #if HAS_W_MAX
-    #if ENABLED(ENDSTOPPULLUP_WMAX)
-      SET_INPUT_PULLUP(W_MAX_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_WMIN)
-      SET_INPUT_PULLDOWN(W_MAX_PIN);
-    #else
-      SET_INPUT(W_MAX_PIN);
-    #endif
+    _INIT_ENDSTOP(MAX,W,);
   #endif
 
   #if PIN_EXISTS(CALIBRATION)
@@ -577,7 +383,7 @@ static void print_es_state(const bool is_hit, FSTR_P const flabel=nullptr) {
 void __O2 Endstops::report_states() {
   TERN_(BLTOUCH, bltouch._set_SW_mode());
   SERIAL_ECHOLNPGM(STR_M119_REPORT);
-  #define ES_REPORT(S) print_es_state(READ_ENDSTOP(S##_PIN) != S##_ENDSTOP_INVERTING, F(STR_##S))
+  #define ES_REPORT(S) print_es_state(READ_ENDSTOP(S##_PIN) == S##_ENDSTOP_HIT_STATE, F(STR_##S))
   #if HAS_X_MIN
     ES_REPORT(X_MIN);
   #endif
@@ -693,7 +499,7 @@ void __O2 Endstops::report_states() {
 
 #define __ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
 #define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN
-#define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_INVERTING
+#define _ENDSTOP_HIT_STATE(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_HIT_STATE
 #define _ENDSTOP(AXIS, MINMAX) __ENDSTOP(AXIS, MINMAX)
 
 /**
@@ -708,7 +514,7 @@ void Endstops::update() {
   #endif
 
   // Macros to update / copy the live_state
-  #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT_TO(live_state, _ENDSTOP(AXIS, MINMAX), (READ_ENDSTOP(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
+  #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT_TO(live_state, _ENDSTOP(AXIS, MINMAX), (READ_ENDSTOP(_ENDSTOP_PIN(AXIS, MINMAX)) == _ENDSTOP_HIT_STATE(AXIS, MINMAX)))
   #define COPY_LIVE_STATE(SRC_BIT, DST_BIT) SET_BIT_TO(live_state, DST_BIT, TEST(live_state, SRC_BIT))
 
   #if ENABLED(G38_PROBE_TARGET) && NONE(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY, MARKFORGED_YX)

commit aa8afe90b023b0ef1c4bc766566e81b894f66885
Author: Frederik Kemner <stuff+github@fredo.org>
Date:   Wed Feb 15 05:25:47 2023 +0100

    üö∏ SPI endstops for X/Y Dual and Core (#25371)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index cabb0fbf19..ef5f5d06e1 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -1330,75 +1330,54 @@ void Endstops::update() {
     bool hit = false;
     #if X_SPI_SENSORLESS
       if (tmc_spi_homing.x && (stepperX.test_stall_status()
-        #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX) && Y_SPI_SENSORLESS
+        #if Y_SPI_SENSORLESS && ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
           || stepperY.test_stall_status()
-        #elif CORE_IS_XZ && Z_SPI_SENSORLESS
+        #elif Z_SPI_SENSORLESS && CORE_IS_XZ
           || stepperZ.test_stall_status()
         #endif
-      )) {
-        SBI(live_state, X_ENDSTOP);
-        hit = true;
-      }
+      )) { SBI(live_state, X_ENDSTOP); hit = true; }
+      #if ENABLED(X_DUAL_ENDSTOPS)
+	      if (tmc_spi_homing.x && stepperX2.test_stall_status()) { SBI(live_state, X2_ENDSTOP); hit = true; }
+      #endif
     #endif
     #if Y_SPI_SENSORLESS
       if (tmc_spi_homing.y && (stepperY.test_stall_status()
-        #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX) && X_SPI_SENSORLESS
+        #if X_SPI_SENSORLESS && ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
           || stepperX.test_stall_status()
-        #elif CORE_IS_YZ && Z_SPI_SENSORLESS
+        #elif Z_SPI_SENSORLESS && CORE_IS_YZ
           || stepperZ.test_stall_status()
         #endif
-      )) {
-        SBI(live_state, Y_ENDSTOP);
-        hit = true;
-      }
+      )) { SBI(live_state, Y_ENDSTOP); hit = true; }
+      #if ENABLED(Y_DUAL_ENDSTOPS)
+	      if (tmc_spi_homing.y && stepperY2.test_stall_status()) { SBI(live_state, Y2_ENDSTOP); hit = true; }
+      #endif
     #endif
     #if Z_SPI_SENSORLESS
       if (tmc_spi_homing.z && (stepperZ.test_stall_status()
-        #if CORE_IS_XZ && X_SPI_SENSORLESS
+        #if X_SPI_SENSORLESS && CORE_IS_XZ
           || stepperX.test_stall_status()
-        #elif CORE_IS_YZ && Y_SPI_SENSORLESS
+        #elif Y_SPI_SENSORLESS && CORE_IS_YZ
           || stepperY.test_stall_status()
         #endif
-      )) {
-        SBI(live_state, Z_ENDSTOP);
-        hit = true;
-      }
+      )) { SBI(live_state, Z_ENDSTOP); hit = true; }
     #endif
     #if I_SPI_SENSORLESS
-      if (tmc_spi_homing.i && stepperI.test_stall_status()) {
-        SBI(live_state, I_ENDSTOP);
-        hit = true;
-      }
+      if (tmc_spi_homing.i && stepperI.test_stall_status()) { SBI(live_state, I_ENDSTOP); hit = true; }
     #endif
     #if J_SPI_SENSORLESS
-      if (tmc_spi_homing.j && stepperJ.test_stall_status()) {
-        SBI(live_state, J_ENDSTOP);
-        hit = true;
-      }
+      if (tmc_spi_homing.j && stepperJ.test_stall_status()) { SBI(live_state, J_ENDSTOP); hit = true; }
     #endif
     #if K_SPI_SENSORLESS
-      if (tmc_spi_homing.k && stepperK.test_stall_status()) {
-        SBI(live_state, K_ENDSTOP);
-        hit = true;
-      }
+      if (tmc_spi_homing.k && stepperK.test_stall_status()) { SBI(live_state, K_ENDSTOP); hit = true; }
     #endif
     #if U_SPI_SENSORLESS
-      if (tmc_spi_homing.u && stepperU.test_stall_status()) {
-        SBI(live_state, U_ENDSTOP);
-        hit = true;
-      }
+      if (tmc_spi_homing.u && stepperU.test_stall_status()) { SBI(live_state, U_ENDSTOP); hit = true; }
     #endif
     #if V_SPI_SENSORLESS
-      if (tmc_spi_homing.v && stepperV.test_stall_status()) {
-        SBI(live_state, V_ENDSTOP);
-        hit = true;
-      }
+      if (tmc_spi_homing.v && stepperV.test_stall_status()) { SBI(live_state, V_ENDSTOP); hit = true; }
     #endif
     #if W_SPI_SENSORLESS
-      if (tmc_spi_homing.w && stepperW.test_stall_status()) {
-        SBI(live_state, W_ENDSTOP);
-        hit = true;
-      }
+      if (tmc_spi_homing.w && stepperW.test_stall_status()) { SBI(live_state, W_ENDSTOP); hit = true; }
     #endif
 
     if (TERN0(ENDSTOP_INTERRUPTS_FEATURE, hit)) update();
@@ -1408,7 +1387,13 @@ void Endstops::update() {
 
   void Endstops::clear_endstop_state() {
     TERN_(X_SPI_SENSORLESS, CBI(live_state, X_ENDSTOP));
+    #if BOTH(X_SPI_SENSORLESS, X_DUAL_ENDSTOPS)
+      CBI(live_state, X2_ENDSTOP);
+    #endif
     TERN_(Y_SPI_SENSORLESS, CBI(live_state, Y_ENDSTOP));
+    #if BOTH(Y_SPI_SENSORLESS, Y_DUAL_ENDSTOPS)
+      CBI(live_state, Y2_ENDSTOP);
+    #endif
     TERN_(Z_SPI_SENSORLESS, CBI(live_state, Z_ENDSTOP));
     TERN_(I_SPI_SENSORLESS, CBI(live_state, I_ENDSTOP));
     TERN_(J_SPI_SENSORLESS, CBI(live_state, J_ENDSTOP));

commit 339773dcb5e8912e3bad2d916ff8c8ebb617694a
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Feb 8 20:31:02 2023 -0600

    ü©π Extra axis min home with Delta Sensorless Probe

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index f4fbda747b..cabb0fbf19 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -691,15 +691,9 @@ void __O2 Endstops::report_states() {
 
 } // Endstops::report_states
 
-#if HAS_DELTA_SENSORLESS_PROBING
-  #define __ENDSTOP(AXIS, ...) AXIS ##_MAX
-  #define _ENDSTOP_PIN(AXIS, ...) AXIS ##_MAX_PIN
-  #define _ENDSTOP_INVERTING(AXIS, ...) AXIS ##_MAX_ENDSTOP_INVERTING
-#else
-  #define __ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
-  #define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN
-  #define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_INVERTING
-#endif
+#define __ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
+#define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN
+#define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_INVERTING
 #define _ENDSTOP(AXIS, MINMAX) __ENDSTOP(AXIS, MINMAX)
 
 /**

commit 53b202cf9de385b039a4c929f4aa590cc0888865
Author: ExtNeon <33217029+ExtNeon@users.noreply.github.com>
Date:   Sat Aug 6 23:37:03 2022 +0000

    ‚ú® SD Endstop Abort G-Code (#24461)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 33c94ae357..f4fbda747b 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -551,6 +551,10 @@ void Endstops::event_handler() {
         card.abortFilePrintNow();
         quickstop_stepper();
         thermalManager.disable_all_heaters();
+        #ifdef SD_ABORT_ON_ENDSTOP_HIT_GCODE
+          queue.clear();
+          queue.inject(F(SD_ABORT_ON_ENDSTOP_HIT_GCODE));
+        #endif
         print_job_timer.stop();
       }
     #endif

commit 83320f1052dd09bff7aae789372e7bffccbced97
Author: Mark <niujl123@sina.com>
Date:   Sat Aug 6 14:14:58 2022 +0800

    ‚ú® Bed Distance Sensor (#24554)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 1ee4b92b5f..33c94ae357 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -63,6 +63,13 @@ bool Endstops::enabled, Endstops::enabled_globally; // Initialized by settings.l
 volatile Endstops::endstop_mask_t Endstops::hit_state;
 Endstops::endstop_mask_t Endstops::live_state = 0;
 
+#if ENABLED(BD_SENSOR)
+  bool Endstops::bdp_state; // = false
+  #define READ_ENDSTOP(P) ((P == Z_MIN_PIN) ? bdp_state : READ(P))
+#else
+  #define READ_ENDSTOP(P) READ(P)
+#endif
+
 #if ENDSTOP_NOISE_THRESHOLD
   Endstops::endstop_mask_t Endstops::validated_live_state;
   uint8_t Endstops::endstop_poll_count;
@@ -566,7 +573,7 @@ static void print_es_state(const bool is_hit, FSTR_P const flabel=nullptr) {
 void __O2 Endstops::report_states() {
   TERN_(BLTOUCH, bltouch._set_SW_mode());
   SERIAL_ECHOLNPGM(STR_M119_REPORT);
-  #define ES_REPORT(S) print_es_state(READ(S##_PIN) != S##_ENDSTOP_INVERTING, F(STR_##S))
+  #define ES_REPORT(S) print_es_state(READ_ENDSTOP(S##_PIN) != S##_ENDSTOP_INVERTING, F(STR_##S))
   #if HAS_X_MIN
     ES_REPORT(X_MIN);
   #endif
@@ -703,7 +710,7 @@ void Endstops::update() {
   #endif
 
   // Macros to update / copy the live_state
-  #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT_TO(live_state, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
+  #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT_TO(live_state, _ENDSTOP(AXIS, MINMAX), (READ_ENDSTOP(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
   #define COPY_LIVE_STATE(SRC_BIT, DST_BIT) SET_BIT_TO(live_state, DST_BIT, TEST(live_state, SRC_BIT))
 
   #if ENABLED(G38_PROBE_TARGET) && NONE(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY, MARKFORGED_YX)
@@ -1434,7 +1441,7 @@ void Endstops::update() {
     static uint8_t local_LED_status = 0;
     uint16_t live_state_local = 0;
 
-    #define ES_GET_STATE(S) if (READ(S##_PIN)) SBI(live_state_local, S)
+    #define ES_GET_STATE(S) if (READ_ENDSTOP(S##_PIN)) SBI(live_state_local, S)
 
     #if HAS_X_MIN
       ES_GET_STATE(X_MIN);

commit 3522d5376cbf03658b71ddaf8c341e35f59b369b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jun 3 20:55:15 2022 -0500

    ü©π Wrap SENSORLESS_STALLGUARD_DELAY

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 261ab80217..1ee4b92b5f 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -1679,7 +1679,10 @@ void Endstops::update() {
       }
 
       TERN_(IMPROVE_HOMING_RELIABILITY, planner.enable_stall_prevention(onoff));
-      safe_delay(SENSORLESS_STALLGUARD_DELAY); // Short delay needed to settle
+
+      #if SENSORLESS_STALLGUARD_DELAY
+        safe_delay(SENSORLESS_STALLGUARD_DELAY); // Short delay needed to settle
+      #endif
 
     #endif // XYZ
   }

commit 41f73cb457116ed9646932eb505b5e9fbe29e77d
Author: lujios <83166168+lujios@users.noreply.github.com>
Date:   Fri Jun 3 07:19:25 2022 +0200

    ‚ö°Ô∏è Improve Sensorless homing/probing accuracy for G28, G33, M48 (#24220)
    
    Co-authored-by: Robby Candra <robbycandra.mail@gmail.com>
    Co-authored-by: ellensp <530024+ellensp@users.noreply.github.com>

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index bebe09c99c..261ab80217 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -31,6 +31,9 @@
 #include "temperature.h"
 #include "../lcd/marlinui.h"
 
+#define DEBUG_OUT BOTH(USE_SENSORLESS, DEBUG_LEVELING_FEATURE)
+#include "../core/debug_out.h"
+
 #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
   #include HAL_PATH(../HAL, endstop_interrupts.h)
 #endif
@@ -1621,3 +1624,63 @@ void Endstops::update() {
   }
 
 #endif // PINS_DEBUGGING
+
+#if USE_SENSORLESS
+  /**
+   * Change TMC driver currents to N##_CURRENT_HOME, saving the current configuration of each.
+   */
+  void Endstops::set_homing_current(const bool onoff) {
+    #define HAS_CURRENT_HOME(N) (defined(N##_CURRENT_HOME) && N##_CURRENT_HOME != N##_CURRENT)
+    #define HAS_DELTA_X_CURRENT (ENABLED(DELTA) && HAS_CURRENT_HOME(X))
+    #define HAS_DELTA_Y_CURRENT (ENABLED(DELTA) && HAS_CURRENT_HOME(Y))
+    #if HAS_DELTA_X_CURRENT || HAS_DELTA_Y_CURRENT || HAS_CURRENT_HOME(Z)
+      #if HAS_DELTA_X_CURRENT
+        static int16_t saved_current_x;
+      #endif
+      #if HAS_DELTA_Y_CURRENT
+        static int16_t saved_current_y;
+      #endif
+      #if HAS_CURRENT_HOME(Z)
+        static int16_t saved_current_z;
+      #endif
+      auto debug_current_on = [](PGM_P const s, const int16_t a, const int16_t b) {
+        if (DEBUGGING(LEVELING)) { DEBUG_ECHOPGM_P(s); DEBUG_ECHOLNPGM(" current: ", a, " -> ", b); }
+      };
+      if (onoff) {
+        #if HAS_DELTA_X_CURRENT
+          saved_current_x = stepperX.getMilliamps();
+          stepperX.rms_current(X_CURRENT_HOME);
+          debug_current_on(PSTR("X"), saved_current_x, X_CURRENT_HOME);
+        #endif
+        #if HAS_DELTA_Y_CURRENT
+          saved_current_y = stepperY.getMilliamps();
+          stepperY.rms_current(Y_CURRENT_HOME);
+          debug_current_on(PSTR("Y"), saved_current_y, Y_CURRENT_HOME);
+        #endif
+        #if HAS_CURRENT_HOME(Z)
+          saved_current_z = stepperZ.getMilliamps();
+          stepperZ.rms_current(Z_CURRENT_HOME);
+          debug_current_on(PSTR("Z"), saved_current_z, Z_CURRENT_HOME);
+        #endif
+      }
+      else {
+        #if HAS_DELTA_X_CURRENT
+          stepperX.rms_current(saved_current_x);
+          debug_current_on(PSTR("X"), X_CURRENT_HOME, saved_current_x);
+        #endif
+        #if HAS_DELTA_Y_CURRENT
+          stepperY.rms_current(saved_current_y);
+          debug_current_on(PSTR("Y"), Y_CURRENT_HOME, saved_current_y);
+        #endif
+        #if HAS_CURRENT_HOME(Z)
+          stepperZ.rms_current(saved_current_z);
+          debug_current_on(PSTR("Z"), Z_CURRENT_HOME, saved_current_z);
+        #endif
+      }
+
+      TERN_(IMPROVE_HOMING_RELIABILITY, planner.enable_stall_prevention(onoff));
+      safe_delay(SENSORLESS_STALLGUARD_DELAY); // Short delay needed to settle
+
+    #endif // XYZ
+  }
+#endif

commit 5f4ec825448cd5c9a7a03d3292b3d4a74377bba2
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Sun May 8 14:56:09 2022 +1200

    ‚úèÔ∏èFix Markforged endstops/G38 (#24141)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 3f7b47a98b..bebe09c99c 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -703,7 +703,7 @@ void Endstops::update() {
   #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT_TO(live_state, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
   #define COPY_LIVE_STATE(SRC_BIT, DST_BIT) SET_BIT_TO(live_state, DST_BIT, TEST(live_state, SRC_BIT))
 
-  #if ENABLED(G38_PROBE_TARGET) && NONE(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY, MARKFORGED_XY)
+  #if ENABLED(G38_PROBE_TARGET) && NONE(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY, MARKFORGED_YX)
     #define HAS_G38_PROBE 1
     // For G38 moves check the probe's pin for ALL movement
     if (G38_move) UPDATE_ENDSTOP_BIT(Z, TERN(USES_Z_MIN_PROBE_PIN, MIN_PROBE, MIN));
@@ -714,7 +714,7 @@ void Endstops::update() {
   #define X_MAX_TEST() TERN1(DUAL_X_CARRIAGE, TERN0(X_HOME_TO_MAX, stepper.last_moved_extruder == 0) || TERN0(X2_HOME_TO_MAX, stepper.last_moved_extruder != 0))
 
   // Use HEAD for core axes, AXIS for others
-  #if ANY(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY, MARKFORGED_XY)
+  #if ANY(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY, MARKFORGED_YX)
     #define X_AXIS_HEAD X_HEAD
   #else
     #define X_AXIS_HEAD X_AXIS

commit 659b4172aa49d82e54a08b5ed674b3ba4ad51fb0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu May 5 18:55:43 2022 -0500

    üî® Prevent build attribute define conflicts

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 656018a48c..3f7b47a98b 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -560,7 +560,7 @@ static void print_es_state(const bool is_hit, FSTR_P const flabel=nullptr) {
 
 #pragma GCC diagnostic pop
 
-void _O2 Endstops::report_states() {
+void __O2 Endstops::report_states() {
   TERN_(BLTOUCH, bltouch._set_SW_mode());
   SERIAL_ECHOLNPGM(STR_M119_REPORT);
   #define ES_REPORT(S) print_es_state(READ(S##_PIN) != S##_ENDSTOP_INVERTING, F(STR_##S))

commit df40181357b08761766067ef5012b2b3d0e34d3e
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Wed May 4 17:25:02 2022 -0700

    üí• Num Axes and Multi-Stepper based on Driver Types (#24120)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 7381e98b01..656018a48c 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -78,9 +78,9 @@ Endstops::endstop_mask_t Endstops::live_state = 0;
 #endif
 #if ENABLED(Z_MULTI_ENDSTOPS)
   float Endstops::z2_endstop_adj;
-  #if NUM_Z_STEPPER_DRIVERS >= 3
+  #if NUM_Z_STEPPERS >= 3
     float Endstops::z3_endstop_adj;
-    #if NUM_Z_STEPPER_DRIVERS >= 4
+    #if NUM_Z_STEPPERS >= 4
       float Endstops::z4_endstop_adj;
     #endif
   #endif
@@ -792,14 +792,14 @@ void Endstops::update() {
       #else
         COPY_LIVE_STATE(Z_MIN, Z2_MIN);
       #endif
-      #if NUM_Z_STEPPER_DRIVERS >= 3
+      #if NUM_Z_STEPPERS >= 3
         #if HAS_Z3_MIN
           UPDATE_ENDSTOP_BIT(Z3, MIN);
         #else
           COPY_LIVE_STATE(Z_MIN, Z3_MIN);
         #endif
       #endif
-      #if NUM_Z_STEPPER_DRIVERS >= 4
+      #if NUM_Z_STEPPERS >= 4
         #if HAS_Z4_MIN
           UPDATE_ENDSTOP_BIT(Z4, MIN);
         #else
@@ -824,14 +824,14 @@ void Endstops::update() {
       #else
         COPY_LIVE_STATE(Z_MAX, Z2_MAX);
       #endif
-      #if NUM_Z_STEPPER_DRIVERS >= 3
+      #if NUM_Z_STEPPERS >= 3
         #if HAS_Z3_MAX
           UPDATE_ENDSTOP_BIT(Z3, MAX);
         #else
           COPY_LIVE_STATE(Z_MAX, Z3_MAX);
         #endif
       #endif
-      #if NUM_Z_STEPPER_DRIVERS >= 4
+      #if NUM_Z_STEPPERS >= 4
         #if HAS_Z4_MAX
           UPDATE_ENDSTOP_BIT(Z4, MAX);
         #else
@@ -1090,9 +1090,9 @@ void Endstops::update() {
 
   #if DISABLED(Z_MULTI_ENDSTOPS)
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_ENDSTOP(Z, MINMAX)
-  #elif NUM_Z_STEPPER_DRIVERS == 4
+  #elif NUM_Z_STEPPERS == 4
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_QUAD_ENDSTOP(Z, MINMAX)
-  #elif NUM_Z_STEPPER_DRIVERS == 3
+  #elif NUM_Z_STEPPERS == 3
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_TRIPLE_ENDSTOP(Z, MINMAX)
   #else
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_DUAL_ENDSTOP(Z, MINMAX)

commit e5b651f407fcb743e2d00c45b0d361fb98230efb
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Fri Apr 1 07:10:38 2022 +0200

    ‚ú® Support for up to 9 axes (linear, rotary) (#23112)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 3dd6d8aeb6..7381e98b01 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -319,6 +319,66 @@ void Endstops::init() {
     #endif
   #endif
 
+  #if HAS_U_MIN
+    #if ENABLED(ENDSTOPPULLUP_UMIN)
+      SET_INPUT_PULLUP(U_MIN_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_UMIN)
+      SET_INPUT_PULLDOWN(U_MIN_PIN);
+    #else
+      SET_INPUT(U_MIN_PIN);
+    #endif
+  #endif
+
+  #if HAS_U_MAX
+    #if ENABLED(ENDSTOPPULLUP_UMAX)
+      SET_INPUT_PULLUP(U_MAX_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_UMIN)
+      SET_INPUT_PULLDOWN(U_MAX_PIN);
+    #else
+      SET_INPUT(U_MAX_PIN);
+    #endif
+  #endif
+
+  #if HAS_V_MIN
+    #if ENABLED(ENDSTOPPULLUP_VMIN)
+      SET_INPUT_PULLUP(V_MIN_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_VMIN)
+      SET_INPUT_PULLDOWN(V_MIN_PIN);
+    #else
+      SET_INPUT(V_MIN_PIN);
+    #endif
+  #endif
+
+  #if HAS_V_MAX
+    #if ENABLED(ENDSTOPPULLUP_VMAX)
+      SET_INPUT_PULLUP(V_MAX_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_VMIN)
+      SET_INPUT_PULLDOWN(V_MAX_PIN);
+    #else
+      SET_INPUT(V_MAX_PIN);
+    #endif
+  #endif
+
+  #if HAS_W_MIN
+    #if ENABLED(ENDSTOPPULLUP_WMIN)
+      SET_INPUT_PULLUP(W_MIN_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_WMIN)
+      SET_INPUT_PULLDOWN(W_MIN_PIN);
+    #else
+      SET_INPUT(W_MIN_PIN);
+    #endif
+  #endif
+
+  #if HAS_W_MAX
+    #if ENABLED(ENDSTOPPULLUP_WMAX)
+      SET_INPUT_PULLUP(W_MAX_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_WMIN)
+      SET_INPUT_PULLDOWN(W_MAX_PIN);
+    #else
+      SET_INPUT(W_MAX_PIN);
+    #endif
+  #endif
+
   #if PIN_EXISTS(CALIBRATION)
     #if ENABLED(CALIBRATION_PIN_PULLUP)
       SET_INPUT_PULLUP(CALIBRATION_PIN);
@@ -424,7 +484,7 @@ void Endstops::event_handler() {
   prev_hit_state = hit_state;
   if (hit_state) {
     #if HAS_STATUS_MESSAGE
-      char LINEAR_AXIS_LIST(chrX = ' ', chrY = ' ', chrZ = ' ', chrI = ' ', chrJ = ' ', chrK = ' '),
+      char NUM_AXIS_LIST(chrX = ' ', chrY = ' ', chrZ = ' ', chrI = ' ', chrJ = ' ', chrK = ' ', chrU = ' ', chrV = ' ', chrW = ' '),
            chrP = ' ';
       #define _SET_STOP_CHAR(A,C) (chr## A = C)
     #else
@@ -444,16 +504,22 @@ void Endstops::event_handler() {
     #define ENDSTOP_HIT_TEST_I() _ENDSTOP_HIT_TEST(I,'I')
     #define ENDSTOP_HIT_TEST_J() _ENDSTOP_HIT_TEST(J,'J')
     #define ENDSTOP_HIT_TEST_K() _ENDSTOP_HIT_TEST(K,'K')
+    #define ENDSTOP_HIT_TEST_U() _ENDSTOP_HIT_TEST(U,'U')
+    #define ENDSTOP_HIT_TEST_V() _ENDSTOP_HIT_TEST(V,'V')
+    #define ENDSTOP_HIT_TEST_W() _ENDSTOP_HIT_TEST(W,'W')
 
     SERIAL_ECHO_START();
     SERIAL_ECHOPGM(STR_ENDSTOPS_HIT);
-    LINEAR_AXIS_CODE(
+    NUM_AXIS_CODE(
        ENDSTOP_HIT_TEST_X(),
        ENDSTOP_HIT_TEST_Y(),
        ENDSTOP_HIT_TEST_Z(),
       _ENDSTOP_HIT_TEST(I,'I'),
       _ENDSTOP_HIT_TEST(J,'J'),
-      _ENDSTOP_HIT_TEST(K,'K')
+      _ENDSTOP_HIT_TEST(K,'K'),
+      _ENDSTOP_HIT_TEST(U,'U'),
+      _ENDSTOP_HIT_TEST(V,'V'),
+      _ENDSTOP_HIT_TEST(W,'W')
     );
 
     #if USES_Z_MIN_PROBE_PIN
@@ -464,9 +530,9 @@ void Endstops::event_handler() {
 
     TERN_(HAS_STATUS_MESSAGE,
       ui.status_printf(0,
-        F(S_FMT GANG_N_1(LINEAR_AXES, " %c") " %c"),
+        F(S_FMT GANG_N_1(NUM_AXES, " %c") " %c"),
         GET_TEXT(MSG_LCD_ENDSTOPS),
-        LINEAR_AXIS_LIST(chrX, chrY, chrZ, chrI, chrJ, chrK), chrP
+        NUM_AXIS_LIST(chrX, chrY, chrZ, chrI, chrJ, chrK, chrU, chrV, chrW), chrP
       )
     );
 
@@ -564,6 +630,24 @@ void _O2 Endstops::report_states() {
   #if HAS_K_MAX
     ES_REPORT(K_MAX);
   #endif
+  #if HAS_U_MIN
+    ES_REPORT(U_MIN);
+  #endif
+  #if HAS_U_MAX
+    ES_REPORT(U_MAX);
+  #endif
+  #if HAS_V_MIN
+    ES_REPORT(V_MIN);
+  #endif
+  #if HAS_V_MAX
+    ES_REPORT(V_MAX);
+  #endif
+  #if HAS_W_MIN
+    ES_REPORT(W_MIN);
+  #endif
+  #if HAS_W_MAX
+    ES_REPORT(W_MAX);
+  #endif
   #if ENABLED(PROBE_ACTIVATION_SWITCH)
     print_es_state(probe_switch_activated(), F(STR_PROBE_EN));
   #endif
@@ -649,6 +733,9 @@ void Endstops::update() {
   #define I_AXIS_HEAD I_AXIS
   #define J_AXIS_HEAD J_AXIS
   #define K_AXIS_HEAD K_AXIS
+  #define U_AXIS_HEAD U_AXIS
+  #define V_AXIS_HEAD V_AXIS
+  #define W_AXIS_HEAD W_AXIS
 
   /**
    * Check and update endstops
@@ -835,6 +922,82 @@ void Endstops::update() {
     #endif
   #endif
 
+  #if HAS_U_MIN && !U_SPI_SENSORLESS
+    #if ENABLED(U_DUAL_ENDSTOPS)
+      UPDATE_ENDSTOP_BIT(U, MIN);
+      #if HAS_U2_MIN
+        UPDATE_ENDSTOP_BIT(U2, MIN);
+      #else
+        COPY_LIVE_STATE(U_MIN, U2_MIN);
+      #endif
+    #else
+      UPDATE_ENDSTOP_BIT(U, MIN);
+    #endif
+  #endif
+
+  #if HAS_U_MAX && !U_SPI_SENSORLESS
+    #if ENABLED(U_DUAL_ENDSTOPS)
+      UPDATE_ENDSTOP_BIT(U, MAX);
+      #if HAS_U2_MAX
+        UPDATE_ENDSTOP_BIT(U2, MAX);
+      #else
+        COPY_LIVE_STATE(U_MAX, U2_MAX);
+      #endif
+    #else
+      UPDATE_ENDSTOP_BIT(U, MAX);
+    #endif
+  #endif
+
+  #if HAS_V_MIN && !V_SPI_SENSORLESS
+    #if ENABLED(V_DUAL_ENDSTOPS)
+      UPDATE_ENDSTOP_BIT(V, MIN);
+      #if HAS_V2_MIN
+        UPDATE_ENDSTOP_BIT(V2, MIN);
+      #else
+        COPY_LIVE_STATE(V_MIN, V2_MIN);
+      #endif
+    #else
+      UPDATE_ENDSTOP_BIT(V, MIN);
+    #endif
+  #endif
+  #if HAS_V_MAX && !V_SPI_SENSORLESS
+    #if ENABLED(O_DUAL_ENDSTOPS)
+      UPDATE_ENDSTOP_BIT(V, MAX);
+      #if HAS_V2_MAX
+        UPDATE_ENDSTOP_BIT(V2, MAX);
+      #else
+        COPY_LIVE_STATE(V_MAX, V2_MAX);
+      #endif
+    #else
+      UPDATE_ENDSTOP_BIT(V, MAX);
+    #endif
+  #endif
+
+  #if HAS_W_MIN && !W_SPI_SENSORLESS
+    #if ENABLED(W_DUAL_ENDSTOPS)
+      UPDATE_ENDSTOP_BIT(W, MIN);
+      #if HAS_W2_MIN
+        UPDATE_ENDSTOP_BIT(W2, MIN);
+      #else
+        COPY_LIVE_STATE(W_MIN, W2_MIN);
+      #endif
+    #else
+      UPDATE_ENDSTOP_BIT(W, MIN);
+    #endif
+  #endif
+  #if HAS_W_MAX && !W_SPI_SENSORLESS
+    #if ENABLED(W_DUAL_ENDSTOPS)
+      UPDATE_ENDSTOP_BIT(W, MAX);
+      #if HAS_W2_MAX
+        UPDATE_ENDSTOP_BIT(W2, MAX);
+      #else
+        COPY_LIVE_STATE(W_MAX, W2_MAX);
+      #endif
+    #else
+      UPDATE_ENDSTOP_BIT(W, MAX);
+    #endif
+  #endif
+
   #if ENDSTOP_NOISE_THRESHOLD
 
     /**
@@ -935,7 +1098,7 @@ void Endstops::update() {
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_DUAL_ENDSTOP(Z, MINMAX)
   #endif
 
-  #if HAS_G38_PROBE
+  #if HAS_G38_PROBE // TODO (DerAndere): Add support for HAS_I_AXIS
     #define _G38_OPEN_STATE TERN(G38_PROBE_AWAY, (G38_move >= 4), LOW)
     // For G38 moves check the probe's pin for ALL movement
     if (G38_move && TEST_ENDSTOP(_ENDSTOP(Z, TERN(USES_Z_MIN_PROBE_PIN, MIN_PROBE, MIN))) != _G38_OPEN_STATE) {
@@ -1105,6 +1268,51 @@ void Endstops::update() {
       }
     }
   #endif
+
+  #if HAS_U_AXIS
+    if (stepper.axis_is_moving(U_AXIS)) {
+      if (stepper.motor_direction(U_AXIS_HEAD)) { // -direction
+        #if HAS_U_MIN || (U_SPI_SENSORLESS && U_HOME_TO_MIN)
+          PROCESS_ENDSTOP(U, MIN);
+        #endif
+      }
+      else { // +direction
+        #if HAS_U_MAX || (U_SPI_SENSORLESS && U_HOME_TO_MAX)
+          PROCESS_ENDSTOP(U, MAX);
+        #endif
+      }
+    }
+  #endif
+
+  #if HAS_V_AXIS
+    if (stepper.axis_is_moving(V_AXIS)) {
+      if (stepper.motor_direction(V_AXIS_HEAD)) { // -direction
+        #if HAS_V_MIN || (V_SPI_SENSORLESS && V_HOME_TO_MIN)
+          PROCESS_ENDSTOP(V, MIN);
+        #endif
+      }
+      else { // +direction
+        #if HAS_V_MAX || (V_SPI_SENSORLESS && V_HOME_TO_MAX)
+          PROCESS_ENDSTOP(V, MAX);
+        #endif
+      }
+    }
+  #endif
+
+  #if HAS_W_AXIS
+    if (stepper.axis_is_moving(W_AXIS)) {
+      if (stepper.motor_direction(W_AXIS_HEAD)) { // -direction
+        #if HAS_W_MIN || (W_SPI_SENSORLESS && W_HOME_TO_MIN)
+          PROCESS_ENDSTOP(W, MIN);
+        #endif
+      }
+      else { // +direction
+        #if HAS_W_MAX || (W_SPI_SENSORLESS && W_HOME_TO_MAX)
+          PROCESS_ENDSTOP(W, MAX);
+        #endif
+      }
+    }
+  #endif
 } // Endstops::update()
 
 #if ENABLED(SPI_ENDSTOPS)
@@ -1166,6 +1374,24 @@ void Endstops::update() {
         hit = true;
       }
     #endif
+    #if U_SPI_SENSORLESS
+      if (tmc_spi_homing.u && stepperU.test_stall_status()) {
+        SBI(live_state, U_ENDSTOP);
+        hit = true;
+      }
+    #endif
+    #if V_SPI_SENSORLESS
+      if (tmc_spi_homing.v && stepperV.test_stall_status()) {
+        SBI(live_state, V_ENDSTOP);
+        hit = true;
+      }
+    #endif
+    #if W_SPI_SENSORLESS
+      if (tmc_spi_homing.w && stepperW.test_stall_status()) {
+        SBI(live_state, W_ENDSTOP);
+        hit = true;
+      }
+    #endif
 
     if (TERN0(ENDSTOP_INTERRUPTS_FEATURE, hit)) update();
 
@@ -1179,6 +1405,9 @@ void Endstops::update() {
     TERN_(I_SPI_SENSORLESS, CBI(live_state, I_ENDSTOP));
     TERN_(J_SPI_SENSORLESS, CBI(live_state, J_ENDSTOP));
     TERN_(K_SPI_SENSORLESS, CBI(live_state, K_ENDSTOP));
+    TERN_(U_SPI_SENSORLESS, CBI(live_state, U_ENDSTOP));
+    TERN_(V_SPI_SENSORLESS, CBI(live_state, V_ENDSTOP));
+    TERN_(W_SPI_SENSORLESS, CBI(live_state, W_ENDSTOP));
   }
 
 #endif // SPI_ENDSTOPS
@@ -1273,6 +1502,24 @@ void Endstops::update() {
     #if HAS_K_MIN
       ES_GET_STATE(K_MIN);
     #endif
+    #if HAS_U_MAX
+      ES_GET_STATE(U_MAX);
+    #endif
+    #if HAS_U_MIN
+      ES_GET_STATE(U_MIN);
+    #endif
+    #if HAS_V_MAX
+      ES_GET_STATE(V_MAX);
+    #endif
+    #if HAS_V_MIN
+      ES_GET_STATE(V_MIN);
+    #endif
+    #if HAS_W_MAX
+      ES_GET_STATE(W_MAX);
+    #endif
+    #if HAS_W_MIN
+      ES_GET_STATE(W_MIN);
+    #endif
 
     uint16_t endstop_change = live_state_local ^ old_live_state_local;
     #define ES_REPORT_CHANGE(S) if (TEST(endstop_change, S)) SERIAL_ECHOPGM("  " STRINGIFY(S) ":", TEST(live_state_local, S))
@@ -1347,6 +1594,25 @@ void Endstops::update() {
       #if HAS_K_MAX
         ES_REPORT_CHANGE(K_MAX);
       #endif
+      #if HAS_U_MIN
+        ES_REPORT_CHANGE(U_MIN);
+      #endif
+      #if HAS_U_MAX
+        ES_REPORT_CHANGE(U_MAX);
+      #endif
+      #if HAS_V_MIN
+        ES_REPORT_CHANGE(V_MIN);
+      #endif
+      #if HAS_V_MAX
+        ES_REPORT_CHANGE(V_MAX);
+      #endif
+      #if HAS_W_MIN
+        ES_REPORT_CHANGE(W_MIN);
+      #endif
+      #if HAS_W_MAX
+        ES_REPORT_CHANGE(W_MAX);
+      #endif
+
       SERIAL_ECHOLNPGM("\n");
       hal.set_pwm_duty(pin_t(LED_PIN), local_LED_status);
       local_LED_status ^= 255;

commit 44eff9a23348dcc117fd1ea9b4b1ef0b54061808
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Feb 17 18:50:31 2022 -0600

    ‚ôªÔ∏è Refactor HAL as singleton (#23357)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index bce27dc88a..3dd6d8aeb6 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -1348,7 +1348,7 @@ void Endstops::update() {
         ES_REPORT_CHANGE(K_MAX);
       #endif
       SERIAL_ECHOLNPGM("\n");
-      set_pwm_duty(pin_t(LED_PIN), local_LED_status);
+      hal.set_pwm_duty(pin_t(LED_PIN), local_LED_status);
       local_LED_status ^= 255;
       old_live_state_local = live_state_local;
     }

commit 40481947fc1f11a01235c5c55333a4437fc45c5f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jan 14 03:14:13 2022 -0600

    üßë‚Äçüíª Misc. updates for extra axes (#23521)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 939dd6d537..bce27dc88a 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -558,7 +558,7 @@ void _O2 Endstops::report_states() {
   #if HAS_J_MAX
     ES_REPORT(J_MAX);
   #endif
-    #if HAS_K_MIN
+  #if HAS_K_MIN
     ES_REPORT(K_MIN);
   #endif
   #if HAS_K_MAX

commit 3e2a38b653b1d8479b7b38447d5fdff51ea9947f
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Wed Jan 12 08:24:56 2022 -0800

    üìù KHz => kHz (#23512)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index b9c5aebf39..939dd6d537 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -352,7 +352,7 @@ void Endstops::init() {
 
 } // Endstops::init
 
-// Called at ~1KHz from Temperature ISR: Poll endstop state if required
+// Called at ~1kHz from Temperature ISR: Poll endstop state if required
 void Endstops::poll() {
 
   TERN_(PINS_DEBUGGING, run_monitor()); // Report changes in endstop status
@@ -403,7 +403,7 @@ void Endstops::not_homing() {
 void Endstops::resync() {
   if (!abort_enabled()) return;     // If endstops/probes are disabled the loop below can hang
 
-  // Wait for Temperature ISR to run at least once (runs at 1KHz)
+  // Wait for Temperature ISR to run at least once (runs at 1kHz)
   TERN(ENDSTOP_INTERRUPTS_FEATURE, update(), safe_delay(2));
   while (TERN0(ENDSTOP_NOISE_THRESHOLD, endstop_poll_count)) safe_delay(1);
 }

commit 1bd921d6a69412686fa4b31c4c1e5710de9840cf
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jan 6 05:07:47 2022 -0600

    üé® Misc. cleanup, comments

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 50ee33b3c0..b9c5aebf39 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -593,9 +593,6 @@ void _O2 Endstops::report_states() {
 
 } // Endstops::report_states
 
-// The following routines are called from an ISR context. It could be the temperature ISR, the
-// endstop ISR or the Stepper ISR.
-
 #if HAS_DELTA_SENSORLESS_PROBING
   #define __ENDSTOP(AXIS, ...) AXIS ##_MAX
   #define _ENDSTOP_PIN(AXIS, ...) AXIS ##_MAX_PIN
@@ -607,13 +604,18 @@ void _O2 Endstops::report_states() {
 #endif
 #define _ENDSTOP(AXIS, MINMAX) __ENDSTOP(AXIS, MINMAX)
 
-// Check endstops - Could be called from Temperature ISR!
+/**
+ * Called from interrupt context by the Endstop ISR or Stepper ISR!
+ * Read endstops to get their current states, register hits for all
+ * axes moving in the direction of their endstops, and abort moves.
+ */
 void Endstops::update() {
 
-  #if !ENDSTOP_NOISE_THRESHOLD
-    if (!abort_enabled()) return;
+  #if !ENDSTOP_NOISE_THRESHOLD      // If not debouncing...
+    if (!abort_enabled()) return;   // ...and not enabled, exit.
   #endif
 
+  // Macros to update / copy the live_state
   #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT_TO(live_state, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
   #define COPY_LIVE_STATE(SRC_BIT, DST_BIT) SET_BIT_TO(live_state, DST_BIT, TEST(live_state, SRC_BIT))
 
@@ -1107,6 +1109,7 @@ void Endstops::update() {
 
 #if ENABLED(SPI_ENDSTOPS)
 
+  // Called from idle() to read Trinamic stall states
   bool Endstops::tmc_spi_homing_check() {
     bool hit = false;
     #if X_SPI_SENSORLESS

commit e65c12cf96a226019a7456099078ee5cb03f9a49
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jan 2 09:22:36 2022 -0600

    üßë‚Äçüíª Apply axis conditionals

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 7a2cefdd4c..50ee33b3c0 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -1059,7 +1059,7 @@ void Endstops::update() {
     }
   #endif
 
-  #if LINEAR_AXES >= 4
+  #if HAS_I_AXIS
     if (stepper.axis_is_moving(I_AXIS)) {
       if (stepper.motor_direction(I_AXIS_HEAD)) { // -direction
         #if HAS_I_MIN || (I_SPI_SENSORLESS && I_HOME_TO_MIN)
@@ -1074,7 +1074,7 @@ void Endstops::update() {
     }
   #endif
 
-  #if LINEAR_AXES >= 5
+  #if HAS_J_AXIS
     if (stepper.axis_is_moving(J_AXIS)) {
       if (stepper.motor_direction(J_AXIS_HEAD)) { // -direction
         #if HAS_J_MIN || (J_SPI_SENSORLESS && J_HOME_TO_MIN)
@@ -1089,7 +1089,7 @@ void Endstops::update() {
     }
   #endif
 
-  #if LINEAR_AXES >= 6
+  #if HAS_K_AXIS
     if (stepper.axis_is_moving(K_AXIS)) {
       if (stepper.motor_direction(K_AXIS_HEAD)) { // -direction
         #if HAS_K_MIN || (K_SPI_SENSORLESS && K_HOME_TO_MIN)

commit 6a8b9274a31d11c396ce1bc44b3a0b872a4606dc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Dec 25 23:15:17 2021 -0600

    ‚è™Ô∏è Refactor still needs work
    
    Reverting #23295

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index df6a857803..7a2cefdd4c 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -1345,7 +1345,7 @@ void Endstops::update() {
         ES_REPORT_CHANGE(K_MAX);
       #endif
       SERIAL_ECHOLNPGM("\n");
-      hal.set_pwm_duty(pin_t(LED_PIN), local_LED_status);
+      set_pwm_duty(pin_t(LED_PIN), local_LED_status);
       local_LED_status ^= 255;
       old_live_state_local = live_state_local;
     }

commit e211ff148c39bf5dace72de7cffbb83f19d3f1bf
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Dec 24 21:33:59 2021 -0600

    ‚ôªÔ∏è Refactor HAL as singleton (#23295)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 7a2cefdd4c..df6a857803 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -1345,7 +1345,7 @@ void Endstops::update() {
         ES_REPORT_CHANGE(K_MAX);
       #endif
       SERIAL_ECHOLNPGM("\n");
-      set_pwm_duty(pin_t(LED_PIN), local_LED_status);
+      hal.set_pwm_duty(pin_t(LED_PIN), local_LED_status);
       local_LED_status ^= 255;
       old_live_state_local = live_state_local;
     }

commit c3af6bd8ce731737d0812a0e554e37dc0779127f
Author: Scott Alfter <scott@alfter.us>
Date:   Wed Dec 8 23:18:04 2021 -0800

    Fix Endstops::report_states (#23280)
    
    Fix regression 4d45fdf0eb

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 7c08456fa5..7a2cefdd4c 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -564,7 +564,7 @@ void _O2 Endstops::report_states() {
   #if HAS_K_MAX
     ES_REPORT(K_MAX);
   #endif
-  #if BOTH(PROBE_ACTIVATION_SWITCH)
+  #if ENABLED(PROBE_ACTIVATION_SWITCH)
     print_es_state(probe_switch_activated(), F(STR_PROBE_EN));
   #endif
   #if USES_Z_MIN_PROBE_PIN

commit 4d45fdf0eb605629960d06abb86704cfbd62db49
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Dec 8 18:36:08 2021 -0600

    üé® Misc. probe / endstop cleanup

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 06cbb839cd..7c08456fa5 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -564,7 +564,7 @@ void _O2 Endstops::report_states() {
   #if HAS_K_MAX
     ES_REPORT(K_MAX);
   #endif
-  #if BOTH(MARLIN_DEV_MODE, PROBE_ACTIVATION_SWITCH)
+  #if BOTH(PROBE_ACTIVATION_SWITCH)
     print_es_state(probe_switch_activated(), F(STR_PROBE_EN));
   #endif
   #if USES_Z_MIN_PROBE_PIN

commit e5154ec28179c7dc7b58a830412e7cb09c2f878c
Author: John Robertson <john@cirtech.co.uk>
Date:   Tue Nov 23 21:24:24 2021 +0000

    ‚ú® MarkForged YX kinematics (#23163)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index aa5907477e..06cbb839cd 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -617,7 +617,7 @@ void Endstops::update() {
   #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT_TO(live_state, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
   #define COPY_LIVE_STATE(SRC_BIT, DST_BIT) SET_BIT_TO(live_state, DST_BIT, TEST(live_state, SRC_BIT))
 
-  #if ENABLED(G38_PROBE_TARGET) && NONE(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY)
+  #if ENABLED(G38_PROBE_TARGET) && NONE(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY, MARKFORGED_XY)
     #define HAS_G38_PROBE 1
     // For G38 moves check the probe's pin for ALL movement
     if (G38_move) UPDATE_ENDSTOP_BIT(Z, TERN(USES_Z_MIN_PROBE_PIN, MIN_PROBE, MIN));
@@ -628,12 +628,12 @@ void Endstops::update() {
   #define X_MAX_TEST() TERN1(DUAL_X_CARRIAGE, TERN0(X_HOME_TO_MAX, stepper.last_moved_extruder == 0) || TERN0(X2_HOME_TO_MAX, stepper.last_moved_extruder != 0))
 
   // Use HEAD for core axes, AXIS for others
-  #if ANY(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY)
+  #if ANY(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY, MARKFORGED_XY)
     #define X_AXIS_HEAD X_HEAD
   #else
     #define X_AXIS_HEAD X_AXIS
   #endif
-  #if ANY(CORE_IS_XY, CORE_IS_YZ, MARKFORGED_XY)
+  #if ANY(CORE_IS_XY, CORE_IS_YZ, MARKFORGED_XY, MARKFORGED_YX)
     #define Y_AXIS_HEAD Y_HEAD
   #else
     #define Y_AXIS_HEAD Y_AXIS
@@ -1111,7 +1111,7 @@ void Endstops::update() {
     bool hit = false;
     #if X_SPI_SENSORLESS
       if (tmc_spi_homing.x && (stepperX.test_stall_status()
-        #if ANY(CORE_IS_XY, MARKFORGED_XY) && Y_SPI_SENSORLESS
+        #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX) && Y_SPI_SENSORLESS
           || stepperY.test_stall_status()
         #elif CORE_IS_XZ && Z_SPI_SENSORLESS
           || stepperZ.test_stall_status()
@@ -1123,7 +1123,7 @@ void Endstops::update() {
     #endif
     #if Y_SPI_SENSORLESS
       if (tmc_spi_homing.y && (stepperY.test_stall_status()
-        #if ANY(CORE_IS_XY, MARKFORGED_XY) && X_SPI_SENSORLESS
+        #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX) && X_SPI_SENSORLESS
           || stepperX.test_stall_status()
         #elif CORE_IS_YZ && Z_SPI_SENSORLESS
           || stepperZ.test_stall_status()

commit 07befb545b2bc6ea284d444637a039127af6b4d1
Author: BigTreeTech <38851044+bigtreetech@users.noreply.github.com>
Date:   Wed Nov 10 23:56:10 2021 +0800

    ‚ú® Support for BIQU B1-SE-Plus strain gauge probe (#23101)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 04f20ca3a4..aa5907477e 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -392,6 +392,9 @@ void Endstops::not_homing() {
 #if HAS_BED_PROBE
   void Endstops::enable_z_probe(const bool onoff) {
     z_probe_enabled = onoff;
+    #if PIN_EXISTS(PROBE_ENABLE)
+      WRITE(PROBE_ENABLE_PIN, onoff);
+    #endif
     resync();
   }
 #endif

commit da830e6ced7f7c7e509e748104245064d1c1b265
Author: Andrei M <22990561+andrei-moraru@users.noreply.github.com>
Date:   Tue Nov 2 01:47:16 2021 -0400

    ‚öóÔ∏è Use pwm_set_duty over analogWrite to set PWM (#23048)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 332becfb73..04f20ca3a4 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -1342,7 +1342,7 @@ void Endstops::update() {
         ES_REPORT_CHANGE(K_MAX);
       #endif
       SERIAL_ECHOLNPGM("\n");
-      analogWrite(pin_t(LED_PIN), local_LED_status);
+      set_pwm_duty(pin_t(LED_PIN), local_LED_status);
       local_LED_status ^= 255;
       old_live_state_local = live_state_local;
     }

commit 1f3f9cb68ce9c9adad55a98ccea07e491d7b9785
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Oct 19 05:52:41 2021 -0500

    üé® Pragma GCC cleanup

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index da5a0073cf..332becfb73 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -478,8 +478,8 @@ void Endstops::event_handler() {
   }
 }
 
+#pragma GCC diagnostic push
 #if GCC_VERSION <= 50000
-  #pragma GCC diagnostic push
   #pragma GCC diagnostic ignored "-Wunused-function"
 #endif
 
@@ -489,9 +489,7 @@ static void print_es_state(const bool is_hit, FSTR_P const flabel=nullptr) {
   SERIAL_ECHOLNF(is_hit ? F(STR_ENDSTOP_HIT) : F(STR_ENDSTOP_OPEN));
 }
 
-#if GCC_VERSION <= 50000
-  #pragma GCC diagnostic pop
-#endif
+#pragma GCC diagnostic pop
 
 void _O2 Endstops::report_states() {
   TERN_(BLTOUCH, bltouch._set_SW_mode());

commit 65b950a489c35b1d5547da3a504af4dad8cde3d7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 28 20:15:52 2021 -0500

    üé® Apply F() to kill / sendinfoscreen

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 80e20a0778..da5a0073cf 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -384,7 +384,7 @@ void Endstops::not_homing() {
   // If the last move failed to trigger an endstop, call kill
   void Endstops::validate_homing_move() {
     if (trigger_state()) hit_on_purpose();
-    else kill(GET_TEXT(MSG_KILL_HOMING_FAILED));
+    else kill(GET_TEXT_F(MSG_KILL_HOMING_FAILED));
   }
 #endif
 

commit 1dafd1887e40399faf16e3455e3670ed3acfac52
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 27 13:46:42 2021 -0500

    üé® Apply F() to various reports

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index b5f270ee63..80e20a0778 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -483,10 +483,10 @@ void Endstops::event_handler() {
   #pragma GCC diagnostic ignored "-Wunused-function"
 #endif
 
-static void print_es_state(const bool is_hit, PGM_P const label=nullptr) {
-  if (label) SERIAL_ECHOPGM_P(label);
+static void print_es_state(const bool is_hit, FSTR_P const flabel=nullptr) {
+  if (flabel) SERIAL_ECHOF(flabel);
   SERIAL_ECHOPGM(": ");
-  SERIAL_ECHOLNPGM_P(is_hit ? PSTR(STR_ENDSTOP_HIT) : PSTR(STR_ENDSTOP_OPEN));
+  SERIAL_ECHOLNF(is_hit ? F(STR_ENDSTOP_HIT) : F(STR_ENDSTOP_OPEN));
 }
 
 #if GCC_VERSION <= 50000
@@ -496,7 +496,7 @@ static void print_es_state(const bool is_hit, PGM_P const label=nullptr) {
 void _O2 Endstops::report_states() {
   TERN_(BLTOUCH, bltouch._set_SW_mode());
   SERIAL_ECHOLNPGM(STR_M119_REPORT);
-  #define ES_REPORT(S) print_es_state(READ(S##_PIN) != S##_ENDSTOP_INVERTING, PSTR(STR_##S))
+  #define ES_REPORT(S) print_es_state(READ(S##_PIN) != S##_ENDSTOP_INVERTING, F(STR_##S))
   #if HAS_X_MIN
     ES_REPORT(X_MIN);
   #endif
@@ -564,10 +564,10 @@ void _O2 Endstops::report_states() {
     ES_REPORT(K_MAX);
   #endif
   #if BOTH(MARLIN_DEV_MODE, PROBE_ACTIVATION_SWITCH)
-    print_es_state(probe_switch_activated(), PSTR(STR_PROBE_EN));
+    print_es_state(probe_switch_activated(), F(STR_PROBE_EN));
   #endif
   #if USES_Z_MIN_PROBE_PIN
-    print_es_state(PROBE_TRIGGERED(), PSTR(STR_Z_PROBE));
+    print_es_state(PROBE_TRIGGERED(), F(STR_Z_PROBE));
   #endif
   #if MULTI_FILAMENT_SENSOR
     #define _CASE_RUNOUT(N) case N: pin = FIL_RUNOUT##N##_PIN; state = FIL_RUNOUT##N##_STATE; break;
@@ -584,7 +584,7 @@ void _O2 Endstops::report_states() {
     }
     #undef _CASE_RUNOUT
   #elif HAS_FILAMENT_SENSOR
-    print_es_state(READ(FIL_RUNOUT1_PIN) != FIL_RUNOUT1_STATE, PSTR(STR_FILAMENT));
+    print_es_state(READ(FIL_RUNOUT1_PIN) != FIL_RUNOUT1_STATE, F(STR_FILAMENT));
   #endif
 
   TERN_(BLTOUCH, bltouch._reset_SW_mode());

commit 7f1286a11f87065c4e666985e679cf9c77d668bf
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 25 17:05:11 2021 -0500

    üé® Apply F() to status message

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index d29fd3ecb3..b5f270ee63 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -460,8 +460,8 @@ void Endstops::event_handler() {
     SERIAL_EOL();
 
     TERN_(HAS_STATUS_MESSAGE,
-      ui.status_printf_P(0,
-        PSTR(S_FMT GANG_N_1(LINEAR_AXES, " %c") " %c"),
+      ui.status_printf(0,
+        F(S_FMT GANG_N_1(LINEAR_AXES, " %c") " %c"),
         GET_TEXT(MSG_LCD_ENDSTOPS),
         LINEAR_AXIS_LIST(chrX, chrY, chrZ, chrI, chrJ, chrK), chrP
       )

commit 08e581d5d7c6cfcedf400862fcfcd146c6ce837f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 11 15:41:42 2021 -0500

    üé® Apply more HAS_DELTA_SENSORLESS_PROBING

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index b5315f2f01..d29fd3ecb3 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -595,7 +595,7 @@ void _O2 Endstops::report_states() {
 // The following routines are called from an ISR context. It could be the temperature ISR, the
 // endstop ISR or the Stepper ISR.
 
-#if BOTH(DELTA, SENSORLESS_PROBING)
+#if HAS_DELTA_SENSORLESS_PROBING
   #define __ENDSTOP(AXIS, ...) AXIS ##_MAX
   #define _ENDSTOP_PIN(AXIS, ...) AXIS ##_MAX_PIN
   #define _ENDSTOP_INVERTING(AXIS, ...) AXIS ##_MAX_ENDSTOP_INVERTING

commit 754b31918a73cb08c322102be5d3926d2ac59c18
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 9 04:57:05 2021 -0500

    üé® Fewer serial macros

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 8ca19e4361..b5315f2f01 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -429,7 +429,7 @@ void Endstops::event_handler() {
     #endif
 
     #define _ENDSTOP_HIT_ECHO(A,C) do{ \
-      SERIAL_ECHOPAIR(" " STRINGIFY(A) ":", planner.triggered_position_mm(_AXIS(A))); _SET_STOP_CHAR(A,C); }while(0)
+      SERIAL_ECHOPGM(" " STRINGIFY(A) ":", planner.triggered_position_mm(_AXIS(A))); _SET_STOP_CHAR(A,C); }while(0)
 
     #define _ENDSTOP_HIT_TEST(A,C) \
       if (TERN0(HAS_##A##_MIN, TEST(hit_state, A##_MIN)) || TERN0(HAS_##A##_MAX, TEST(hit_state, A##_MAX))) \
@@ -1271,7 +1271,7 @@ void Endstops::update() {
     #endif
 
     uint16_t endstop_change = live_state_local ^ old_live_state_local;
-    #define ES_REPORT_CHANGE(S) if (TEST(endstop_change, S)) SERIAL_ECHOPAIR("  " STRINGIFY(S) ":", TEST(live_state_local, S))
+    #define ES_REPORT_CHANGE(S) if (TEST(endstop_change, S)) SERIAL_ECHOPGM("  " STRINGIFY(S) ":", TEST(live_state_local, S))
 
     if (endstop_change) {
       #if HAS_X_MIN

commit 79c72ed821564507b0ef46cbb26f9577585e2ccc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 7 18:06:10 2021 -0500

    üé® Standardize G-code reporting

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 0f4716ed87..8ca19e4361 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -578,13 +578,13 @@ void _O2 Endstops::report_states() {
         default: continue;
         REPEAT_1(NUM_RUNOUT_SENSORS, _CASE_RUNOUT)
       }
-      SERIAL_ECHOPGM(STR_FILAMENT_RUNOUT_SENSOR);
+      SERIAL_ECHOPGM(STR_FILAMENT);
       if (i > 1) SERIAL_CHAR(' ', '0' + i);
       print_es_state(extDigitalRead(pin) != state);
     }
     #undef _CASE_RUNOUT
   #elif HAS_FILAMENT_SENSOR
-    print_es_state(READ(FIL_RUNOUT1_PIN) != FIL_RUNOUT1_STATE, PSTR(STR_FILAMENT_RUNOUT_SENSOR));
+    print_es_state(READ(FIL_RUNOUT1_PIN) != FIL_RUNOUT1_STATE, PSTR(STR_FILAMENT));
   #endif
 
   TERN_(BLTOUCH, bltouch._reset_SW_mode());

commit afca6e745932d295b88d37fa9bd4274e22705b0b
Author: luzpaz <luzpaz@users.noreply.github.com>
Date:   Tue Aug 3 20:02:34 2021 -0400

    üêõ Spellcheck comments (#22496)
    
    codespell -q 3 --builtin=clear,rare,informal,code -S ./Marlin/src/lcd/language -L alo,amin,endcode,stdio,uint

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 523e133713..0f4716ed87 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -884,7 +884,7 @@ void Endstops::update() {
     const byte dual_hit = TEST_ENDSTOP(_ENDSTOP(A, MINMAX)) | (TEST_ENDSTOP(_ENDSTOP(A##2, MINMAX)) << 1); \
     if (dual_hit) { \
       _ENDSTOP_HIT(A, MINMAX); \
-      /* if not performing home or if both endstops were trigged during homing... */ \
+      /* if not performing home or if both endstops were triggered during homing... */ \
       if (!stepper.separate_multi_axis || dual_hit == 0b11) \
         planner.endstop_triggered(_AXIS(A)); \
     } \
@@ -894,7 +894,7 @@ void Endstops::update() {
     const byte triple_hit = TEST_ENDSTOP(_ENDSTOP(A, MINMAX)) | (TEST_ENDSTOP(_ENDSTOP(A##2, MINMAX)) << 1) | (TEST_ENDSTOP(_ENDSTOP(A##3, MINMAX)) << 2); \
     if (triple_hit) { \
       _ENDSTOP_HIT(A, MINMAX); \
-      /* if not performing home or if both endstops were trigged during homing... */ \
+      /* if not performing home or if both endstops were triggered during homing... */ \
       if (!stepper.separate_multi_axis || triple_hit == 0b111) \
         planner.endstop_triggered(_AXIS(A)); \
     } \
@@ -904,7 +904,7 @@ void Endstops::update() {
     const byte quad_hit = TEST_ENDSTOP(_ENDSTOP(A, MINMAX)) | (TEST_ENDSTOP(_ENDSTOP(A##2, MINMAX)) << 1) | (TEST_ENDSTOP(_ENDSTOP(A##3, MINMAX)) << 2) | (TEST_ENDSTOP(_ENDSTOP(A##4, MINMAX)) << 3); \
     if (quad_hit) { \
       _ENDSTOP_HIT(A, MINMAX); \
-      /* if not performing home or if both endstops were trigged during homing... */ \
+      /* if not performing home or if both endstops were triggered during homing... */ \
       if (!stepper.separate_multi_axis || quad_hit == 0b1111) \
         planner.endstop_triggered(_AXIS(A)); \
     } \

commit 0eda34e07d6b15ac889d21d84457401683c0345f
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Mon Aug 2 07:13:57 2021 +0200

    üêõ Followup to 6 linear axes (#22482)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 25c26aa7b5..523e133713 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -754,7 +754,7 @@ void Endstops::update() {
     #endif
   #endif
 
-  #if HAS_I_MIN
+  #if HAS_I_MIN && !I_SPI_SENSORLESS
     #if ENABLED(I_DUAL_ENDSTOPS)
       UPDATE_ENDSTOP_BIT(I, MIN);
       #if HAS_I2_MIN
@@ -767,7 +767,7 @@ void Endstops::update() {
     #endif
   #endif
 
-  #if HAS_I_MAX
+  #if HAS_I_MAX && !I_SPI_SENSORLESS
     #if ENABLED(I_DUAL_ENDSTOPS)
       UPDATE_ENDSTOP_BIT(I, MAX);
       #if HAS_I2_MAX
@@ -780,7 +780,7 @@ void Endstops::update() {
     #endif
   #endif
 
-  #if HAS_J_MIN
+  #if HAS_J_MIN && !J_SPI_SENSORLESS
     #if ENABLED(J_DUAL_ENDSTOPS)
       UPDATE_ENDSTOP_BIT(J, MIN);
       #if HAS_J2_MIN
@@ -793,7 +793,7 @@ void Endstops::update() {
     #endif
   #endif
 
-  #if HAS_J_MAX
+  #if HAS_J_MAX && !J_SPI_SENSORLESS
     #if ENABLED(J_DUAL_ENDSTOPS)
       UPDATE_ENDSTOP_BIT(J, MAX);
       #if HAS_J2_MAX
@@ -806,7 +806,7 @@ void Endstops::update() {
     #endif
   #endif
 
-  #if HAS_K_MIN
+  #if HAS_K_MIN && !K_SPI_SENSORLESS
     #if ENABLED(K_DUAL_ENDSTOPS)
       UPDATE_ENDSTOP_BIT(K, MIN);
       #if HAS_K2_MIN
@@ -819,7 +819,7 @@ void Endstops::update() {
     #endif
   #endif
 
-  #if HAS_K_MAX
+  #if HAS_K_MAX && !K_SPI_SENSORLESS
     #if ENABLED(K_DUAL_ENDSTOPS)
       UPDATE_ENDSTOP_BIT(K, MAX);
       #if HAS_K2_MAX

commit a90c8b762c8b8ca06093d6e62f4355e8a5726115
Author: Grayson <mxpklx@gmail.com>
Date:   Sat Jul 31 22:55:22 2021 -0500

    üêõ Fix G38 with probe on Z_MIN (#22452)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 39aefd21d8..25c26aa7b5 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -596,14 +596,15 @@ void _O2 Endstops::report_states() {
 // endstop ISR or the Stepper ISR.
 
 #if BOTH(DELTA, SENSORLESS_PROBING)
-  #define _ENDSTOP(AXIS, MINMAX) AXIS ##_MAX
-  #define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_MAX_PIN
-  #define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_MAX_ENDSTOP_INVERTING
+  #define __ENDSTOP(AXIS, ...) AXIS ##_MAX
+  #define _ENDSTOP_PIN(AXIS, ...) AXIS ##_MAX_PIN
+  #define _ENDSTOP_INVERTING(AXIS, ...) AXIS ##_MAX_ENDSTOP_INVERTING
 #else
-  #define _ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
+  #define __ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
   #define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN
   #define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_INVERTING
 #endif
+#define _ENDSTOP(AXIS, MINMAX) __ENDSTOP(AXIS, MINMAX)
 
 // Check endstops - Could be called from Temperature ISR!
 void Endstops::update() {
@@ -615,9 +616,10 @@ void Endstops::update() {
   #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT_TO(live_state, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
   #define COPY_LIVE_STATE(SRC_BIT, DST_BIT) SET_BIT_TO(live_state, DST_BIT, TEST(live_state, SRC_BIT))
 
-  #if BOTH(G38_PROBE_TARGET, HAS_Z_MIN_PROBE_PIN) && NONE(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY)
-    // If G38 command is active check Z_MIN_PROBE for ALL movement
-    if (G38_move) UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
+  #if ENABLED(G38_PROBE_TARGET) && NONE(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY)
+    #define HAS_G38_PROBE 1
+    // For G38 moves check the probe's pin for ALL movement
+    if (G38_move) UPDATE_ENDSTOP_BIT(Z, TERN(USES_Z_MIN_PROBE_PIN, MIN_PROBE, MIN));
   #endif
 
   // With Dual X, endstops are only checked in the homing direction for the active extruder
@@ -746,7 +748,7 @@ void Endstops::update() {
           COPY_LIVE_STATE(Z_MAX, Z4_MAX);
         #endif
       #endif
-    #elif !USES_Z_MIN_PROBE_PIN || Z_MAX_PIN != Z_MIN_PROBE_PIN
+    #elif TERN1(USES_Z_MIN_PROBE_PIN, Z_MAX_PIN != Z_MIN_PROBE_PIN)
       // If this pin isn't the bed probe it's the Z endstop
       UPDATE_ENDSTOP_BIT(Z, MAX);
     #endif
@@ -930,15 +932,11 @@ void Endstops::update() {
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_DUAL_ENDSTOP(Z, MINMAX)
   #endif
 
-  #if BOTH(G38_PROBE_TARGET, HAS_Z_MIN_PROBE_PIN) && NONE(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY)
-    #if ENABLED(G38_PROBE_AWAY)
-      #define _G38_OPEN_STATE (G38_move >= 4)
-    #else
-      #define _G38_OPEN_STATE LOW
-    #endif
-    // If G38 command is active check Z_MIN_PROBE for ALL movement
-    if (G38_move && TEST_ENDSTOP(_ENDSTOP(Z, MIN_PROBE)) != _G38_OPEN_STATE) {
-           if (stepper.axis_is_moving(X_AXIS)) { _ENDSTOP_HIT(X, TERN(X_HOME_TO_MIN, MIN, MAX)); planner.endstop_triggered(X_AXIS); }
+  #if HAS_G38_PROBE
+    #define _G38_OPEN_STATE TERN(G38_PROBE_AWAY, (G38_move >= 4), LOW)
+    // For G38 moves check the probe's pin for ALL movement
+    if (G38_move && TEST_ENDSTOP(_ENDSTOP(Z, TERN(USES_Z_MIN_PROBE_PIN, MIN_PROBE, MIN))) != _G38_OPEN_STATE) {
+             if (stepper.axis_is_moving(X_AXIS)) { _ENDSTOP_HIT(X, TERN(X_HOME_TO_MIN, MIN, MAX)); planner.endstop_triggered(X_AXIS); }
       #if HAS_Y_AXIS
         else if (stepper.axis_is_moving(Y_AXIS)) { _ENDSTOP_HIT(Y, TERN(Y_HOME_TO_MIN, MIN, MAX)); planner.endstop_triggered(Y_AXIS); }
       #endif
@@ -1043,7 +1041,7 @@ void Endstops::update() {
         #if HAS_Z_MAX || (Z_SPI_SENSORLESS && Z_HOME_TO_MAX)
           #if ENABLED(Z_MULTI_ENDSTOPS)
             PROCESS_ENDSTOP_Z(MAX);
-          #elif !USES_Z_MIN_PROBE_PIN || Z_MAX_PIN != Z_MIN_PROBE_PIN  // No probe or probe is Z_MIN || Probe is not Z_MAX
+          #elif TERN1(USES_Z_MIN_PROBE_PIN, Z_MAX_PIN != Z_MIN_PROBE_PIN)  // No probe or probe is Z_MIN || Probe is not Z_MAX
             PROCESS_ENDSTOP(Z, MAX);
           #endif
           #if   CORE_DIAG(XZ, X, MIN)

commit 363e83731f7b045d7b3e9842882b1f53e032ca89
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jul 28 23:24:30 2021 -0500

    üîß HAS_CUSTOM_PROBE_PIN => USES_Z_MIN_PROBE_PIN

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 420acccb58..39aefd21d8 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -329,7 +329,7 @@ void Endstops::init() {
     #endif
   #endif
 
-  #if HAS_CUSTOM_PROBE_PIN
+  #if USES_Z_MIN_PROBE_PIN
     #if ENABLED(ENDSTOPPULLUP_ZMIN_PROBE)
       SET_INPUT_PULLUP(Z_MIN_PROBE_PIN);
     #elif ENABLED(ENDSTOPPULLDOWN_ZMIN_PROBE)
@@ -453,7 +453,7 @@ void Endstops::event_handler() {
       _ENDSTOP_HIT_TEST(K,'K')
     );
 
-    #if HAS_CUSTOM_PROBE_PIN
+    #if USES_Z_MIN_PROBE_PIN
       #define P_AXIS Z_AXIS
       if (TEST(hit_state, Z_MIN_PROBE)) _ENDSTOP_HIT_ECHO(P, 'P');
     #endif
@@ -566,7 +566,7 @@ void _O2 Endstops::report_states() {
   #if BOTH(MARLIN_DEV_MODE, PROBE_ACTIVATION_SWITCH)
     print_es_state(probe_switch_activated(), PSTR(STR_PROBE_EN));
   #endif
-  #if HAS_CUSTOM_PROBE_PIN
+  #if USES_Z_MIN_PROBE_PIN
     print_es_state(PROBE_TRIGGERED(), PSTR(STR_Z_PROBE));
   #endif
   #if MULTI_FILAMENT_SENSOR
@@ -720,7 +720,7 @@ void Endstops::update() {
   #if HAS_BED_PROBE
     // When closing the gap check the enabled probe
     if (probe_switch_activated())
-      UPDATE_ENDSTOP_BIT(Z, TERN(HAS_CUSTOM_PROBE_PIN, MIN_PROBE, MIN));
+      UPDATE_ENDSTOP_BIT(Z, TERN(USES_Z_MIN_PROBE_PIN, MIN_PROBE, MIN));
   #endif
 
   #if HAS_Z_MAX && !Z_SPI_SENSORLESS
@@ -746,7 +746,7 @@ void Endstops::update() {
           COPY_LIVE_STATE(Z_MAX, Z4_MAX);
         #endif
       #endif
-    #elif !HAS_CUSTOM_PROBE_PIN || Z_MAX_PIN != Z_MIN_PROBE_PIN
+    #elif !USES_Z_MIN_PROBE_PIN || Z_MAX_PIN != Z_MIN_PROBE_PIN
       // If this pin isn't the bed probe it's the Z endstop
       UPDATE_ENDSTOP_BIT(Z, MAX);
     #endif
@@ -1021,7 +1021,7 @@ void Endstops::update() {
 
         #if HAS_Z_MIN || (Z_SPI_SENSORLESS && Z_HOME_TO_MIN)
           if ( TERN1(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN, z_probe_enabled)
-            && TERN1(HAS_CUSTOM_PROBE_PIN, !z_probe_enabled)
+            && TERN1(USES_Z_MIN_PROBE_PIN, !z_probe_enabled)
           ) PROCESS_ENDSTOP_Z(MIN);
           #if   CORE_DIAG(XZ, X, MIN)
             PROCESS_CORE_ENDSTOP(X,MIN,Z,MIN);
@@ -1035,7 +1035,7 @@ void Endstops::update() {
         #endif
 
         // When closing the gap check the enabled probe
-        #if HAS_CUSTOM_PROBE_PIN
+        #if USES_Z_MIN_PROBE_PIN
           if (z_probe_enabled) PROCESS_ENDSTOP(Z, MIN_PROBE);
         #endif
       }
@@ -1043,7 +1043,7 @@ void Endstops::update() {
         #if HAS_Z_MAX || (Z_SPI_SENSORLESS && Z_HOME_TO_MAX)
           #if ENABLED(Z_MULTI_ENDSTOPS)
             PROCESS_ENDSTOP_Z(MAX);
-          #elif !HAS_CUSTOM_PROBE_PIN || Z_MAX_PIN != Z_MIN_PROBE_PIN  // No probe or probe is Z_MIN || Probe is not Z_MAX
+          #elif !USES_Z_MIN_PROBE_PIN || Z_MAX_PIN != Z_MIN_PROBE_PIN  // No probe or probe is Z_MIN || Probe is not Z_MAX
             PROCESS_ENDSTOP(Z, MAX);
           #endif
           #if   CORE_DIAG(XZ, X, MIN)

commit 05ebde38127ca6c3bc056cb4068a414bade766b4
Author: lujios <83166168+lujios@users.noreply.github.com>
Date:   Tue Jul 13 02:19:29 2021 +0200

    ‚ö°Ô∏è Improve Sensorless homing/probing for G28, G33 (#21899)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 8f6827de27..420acccb58 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -595,9 +595,15 @@ void _O2 Endstops::report_states() {
 // The following routines are called from an ISR context. It could be the temperature ISR, the
 // endstop ISR or the Stepper ISR.
 
-#define _ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
-#define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN
-#define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_INVERTING
+#if BOTH(DELTA, SENSORLESS_PROBING)
+  #define _ENDSTOP(AXIS, MINMAX) AXIS ##_MAX
+  #define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_MAX_PIN
+  #define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_MAX_ENDSTOP_INVERTING
+#else
+  #define _ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
+  #define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN
+  #define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_INVERTING
+#endif
 
 // Check endstops - Could be called from Temperature ISR!
 void Endstops::update() {

commit 500b7872fb92d35dd0d1a690f4e5cf1aadea2f46
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 25 14:44:51 2021 -0500

    üêõ Trigger existing endstops on G38 hit

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index c750d56713..8f6827de27 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -932,9 +932,13 @@ void Endstops::update() {
     #endif
     // If G38 command is active check Z_MIN_PROBE for ALL movement
     if (G38_move && TEST_ENDSTOP(_ENDSTOP(Z, MIN_PROBE)) != _G38_OPEN_STATE) {
-           if (stepper.axis_is_moving(X_AXIS)) { _ENDSTOP_HIT(X, MIN); planner.endstop_triggered(X_AXIS); }
-      else if (stepper.axis_is_moving(Y_AXIS)) { _ENDSTOP_HIT(Y, MIN); planner.endstop_triggered(Y_AXIS); }
-      else if (stepper.axis_is_moving(Z_AXIS)) { _ENDSTOP_HIT(Z, MIN); planner.endstop_triggered(Z_AXIS); }
+           if (stepper.axis_is_moving(X_AXIS)) { _ENDSTOP_HIT(X, TERN(X_HOME_TO_MIN, MIN, MAX)); planner.endstop_triggered(X_AXIS); }
+      #if HAS_Y_AXIS
+        else if (stepper.axis_is_moving(Y_AXIS)) { _ENDSTOP_HIT(Y, TERN(Y_HOME_TO_MIN, MIN, MAX)); planner.endstop_triggered(Y_AXIS); }
+      #endif
+      #if HAS_Z_AXIS
+        else if (stepper.axis_is_moving(Z_AXIS)) { _ENDSTOP_HIT(Z, TERN(Z_HOME_TO_MIN, MIN, MAX)); planner.endstop_triggered(Z_AXIS); }
+      #endif
       G38_did_trigger = true;
     }
   #endif

commit 7726af9c5348c1c7d0fd9a56eca87d00cd75fee6
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Sat Jun 5 09:18:47 2021 +0200

    üèóÔ∏è Support for up to 6 linear axes (#19112)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index cf152ff028..c750d56713 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -259,6 +259,66 @@ void Endstops::init() {
     #endif
   #endif
 
+  #if HAS_I_MIN
+    #if ENABLED(ENDSTOPPULLUP_IMIN)
+      SET_INPUT_PULLUP(I_MIN_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_IMIN)
+      SET_INPUT_PULLDOWN(I_MIN_PIN);
+    #else
+      SET_INPUT(I_MIN_PIN);
+    #endif
+  #endif
+
+  #if HAS_I_MAX
+    #if ENABLED(ENDSTOPPULLUP_IMAX)
+      SET_INPUT_PULLUP(I_MAX_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_IMAX)
+      SET_INPUT_PULLDOWN(I_MAX_PIN);
+    #else
+      SET_INPUT(I_MAX_PIN);
+    #endif
+  #endif
+
+  #if HAS_J_MIN
+    #if ENABLED(ENDSTOPPULLUP_JMIN)
+      SET_INPUT_PULLUP(J_MIN_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_IMIN)
+      SET_INPUT_PULLDOWN(J_MIN_PIN);
+    #else
+      SET_INPUT(J_MIN_PIN);
+    #endif
+  #endif
+
+  #if HAS_J_MAX
+    #if ENABLED(ENDSTOPPULLUP_JMAX)
+      SET_INPUT_PULLUP(J_MAX_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_JMAX)
+      SET_INPUT_PULLDOWN(J_MAX_PIN);
+    #else
+      SET_INPUT(J_MAX_PIN);
+    #endif
+  #endif
+
+  #if HAS_K_MIN
+    #if ENABLED(ENDSTOPPULLUP_KMIN)
+      SET_INPUT_PULLUP(K_MIN_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_KMIN)
+      SET_INPUT_PULLDOWN(K_MIN_PIN);
+    #else
+      SET_INPUT(K_MIN_PIN);
+    #endif
+  #endif
+
+  #if HAS_K_MAX
+    #if ENABLED(ENDSTOPPULLUP_KMAX)
+      SET_INPUT_PULLUP(K_MAX_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_KMIN)
+      SET_INPUT_PULLDOWN(K_MAX_PIN);
+    #else
+      SET_INPUT(K_MAX_PIN);
+    #endif
+  #endif
+
   #if PIN_EXISTS(CALIBRATION)
     #if ENABLED(CALIBRATION_PIN_PULLUP)
       SET_INPUT_PULLUP(CALIBRATION_PIN);
@@ -361,7 +421,7 @@ void Endstops::event_handler() {
   prev_hit_state = hit_state;
   if (hit_state) {
     #if HAS_STATUS_MESSAGE
-      char LINEAR_AXIS_LIST(chrX = ' ', chrY = ' ', chrZ = ' '),
+      char LINEAR_AXIS_LIST(chrX = ' ', chrY = ' ', chrZ = ' ', chrI = ' ', chrJ = ' ', chrK = ' '),
            chrP = ' ';
       #define _SET_STOP_CHAR(A,C) (chr## A = C)
     #else
@@ -378,12 +438,20 @@ void Endstops::event_handler() {
     #define ENDSTOP_HIT_TEST_X() _ENDSTOP_HIT_TEST(X,'X')
     #define ENDSTOP_HIT_TEST_Y() _ENDSTOP_HIT_TEST(Y,'Y')
     #define ENDSTOP_HIT_TEST_Z() _ENDSTOP_HIT_TEST(Z,'Z')
+    #define ENDSTOP_HIT_TEST_I() _ENDSTOP_HIT_TEST(I,'I')
+    #define ENDSTOP_HIT_TEST_J() _ENDSTOP_HIT_TEST(J,'J')
+    #define ENDSTOP_HIT_TEST_K() _ENDSTOP_HIT_TEST(K,'K')
 
     SERIAL_ECHO_START();
     SERIAL_ECHOPGM(STR_ENDSTOPS_HIT);
-    ENDSTOP_HIT_TEST_X();
-    ENDSTOP_HIT_TEST_Y();
-    ENDSTOP_HIT_TEST_Z();
+    LINEAR_AXIS_CODE(
+       ENDSTOP_HIT_TEST_X(),
+       ENDSTOP_HIT_TEST_Y(),
+       ENDSTOP_HIT_TEST_Z(),
+      _ENDSTOP_HIT_TEST(I,'I'),
+      _ENDSTOP_HIT_TEST(J,'J'),
+      _ENDSTOP_HIT_TEST(K,'K')
+    );
 
     #if HAS_CUSTOM_PROBE_PIN
       #define P_AXIS Z_AXIS
@@ -395,7 +463,7 @@ void Endstops::event_handler() {
       ui.status_printf_P(0,
         PSTR(S_FMT GANG_N_1(LINEAR_AXES, " %c") " %c"),
         GET_TEXT(MSG_LCD_ENDSTOPS),
-        LINEAR_AXIS_LIST(chrX, chrY, chrZ), chrP
+        LINEAR_AXIS_LIST(chrX, chrY, chrZ, chrI, chrJ, chrK), chrP
       )
     );
 
@@ -477,6 +545,24 @@ void _O2 Endstops::report_states() {
   #if HAS_Z4_MAX
     ES_REPORT(Z4_MAX);
   #endif
+  #if HAS_I_MIN
+    ES_REPORT(I_MIN);
+  #endif
+  #if HAS_I_MAX
+    ES_REPORT(I_MAX);
+  #endif
+  #if HAS_J_MIN
+    ES_REPORT(J_MIN);
+  #endif
+  #if HAS_J_MAX
+    ES_REPORT(J_MAX);
+  #endif
+    #if HAS_K_MIN
+    ES_REPORT(K_MIN);
+  #endif
+  #if HAS_K_MAX
+    ES_REPORT(K_MAX);
+  #endif
   #if BOTH(MARLIN_DEV_MODE, PROBE_ACTIVATION_SWITCH)
     print_es_state(probe_switch_activated(), PSTR(STR_PROBE_EN));
   #endif
@@ -549,6 +635,10 @@ void Endstops::update() {
     #define Z_AXIS_HEAD Z_AXIS
   #endif
 
+  #define I_AXIS_HEAD I_AXIS
+  #define J_AXIS_HEAD J_AXIS
+  #define K_AXIS_HEAD K_AXIS
+
   /**
    * Check and update endstops
    */
@@ -656,6 +746,84 @@ void Endstops::update() {
     #endif
   #endif
 
+  #if HAS_I_MIN
+    #if ENABLED(I_DUAL_ENDSTOPS)
+      UPDATE_ENDSTOP_BIT(I, MIN);
+      #if HAS_I2_MIN
+        UPDATE_ENDSTOP_BIT(I2, MAX);
+      #else
+        COPY_LIVE_STATE(I_MIN, I2_MIN);
+      #endif
+    #else
+      UPDATE_ENDSTOP_BIT(I, MIN);
+    #endif
+  #endif
+
+  #if HAS_I_MAX
+    #if ENABLED(I_DUAL_ENDSTOPS)
+      UPDATE_ENDSTOP_BIT(I, MAX);
+      #if HAS_I2_MAX
+        UPDATE_ENDSTOP_BIT(I2, MAX);
+      #else
+        COPY_LIVE_STATE(I_MAX, I2_MAX);
+      #endif
+    #else
+      UPDATE_ENDSTOP_BIT(I, MAX);
+    #endif
+  #endif
+
+  #if HAS_J_MIN
+    #if ENABLED(J_DUAL_ENDSTOPS)
+      UPDATE_ENDSTOP_BIT(J, MIN);
+      #if HAS_J2_MIN
+        UPDATE_ENDSTOP_BIT(J2, MIN);
+      #else
+        COPY_LIVE_STATE(J_MIN, J2_MIN);
+      #endif
+    #else
+      UPDATE_ENDSTOP_BIT(J, MIN);
+    #endif
+  #endif
+
+  #if HAS_J_MAX
+    #if ENABLED(J_DUAL_ENDSTOPS)
+      UPDATE_ENDSTOP_BIT(J, MAX);
+      #if HAS_J2_MAX
+        UPDATE_ENDSTOP_BIT(J2, MAX);
+      #else
+        COPY_LIVE_STATE(J_MAX, J2_MAX);
+      #endif
+    #else
+      UPDATE_ENDSTOP_BIT(J, MAX);
+    #endif
+  #endif
+
+  #if HAS_K_MIN
+    #if ENABLED(K_DUAL_ENDSTOPS)
+      UPDATE_ENDSTOP_BIT(K, MIN);
+      #if HAS_K2_MIN
+        UPDATE_ENDSTOP_BIT(K2, MIN);
+      #else
+        COPY_LIVE_STATE(K_MIN, K2_MIN);
+      #endif
+    #else
+      UPDATE_ENDSTOP_BIT(K, MIN);
+    #endif
+  #endif
+
+  #if HAS_K_MAX
+    #if ENABLED(K_DUAL_ENDSTOPS)
+      UPDATE_ENDSTOP_BIT(K, MAX);
+      #if HAS_K2_MAX
+        UPDATE_ENDSTOP_BIT(K2, MAX);
+      #else
+        COPY_LIVE_STATE(K_MAX, K2_MAX);
+      #endif
+    #else
+      UPDATE_ENDSTOP_BIT(K, MAX);
+    #endif
+  #endif
+
   #if ENDSTOP_NOISE_THRESHOLD
 
     /**
@@ -804,79 +972,128 @@ void Endstops::update() {
     }
   }
 
-  if (stepper.axis_is_moving(Y_AXIS)) {
-    if (stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
-      #if HAS_Y_MIN || (Y_SPI_SENSORLESS && Y_HOME_TO_MIN)
-        PROCESS_ENDSTOP_Y(MIN);
-        #if   CORE_DIAG(XY, X, MIN)
-          PROCESS_CORE_ENDSTOP(X,MIN,Y,MIN);
-        #elif CORE_DIAG(XY, X, MAX)
-          PROCESS_CORE_ENDSTOP(X,MAX,Y,MIN);
-        #elif CORE_DIAG(YZ, Z, MIN)
-          PROCESS_CORE_ENDSTOP(Z,MIN,Y,MIN);
-        #elif CORE_DIAG(YZ, Z, MAX)
-          PROCESS_CORE_ENDSTOP(Z,MAX,Y,MIN);
+  #if HAS_Y_AXIS
+    if (stepper.axis_is_moving(Y_AXIS)) {
+      if (stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
+        #if HAS_Y_MIN || (Y_SPI_SENSORLESS && Y_HOME_TO_MIN)
+          PROCESS_ENDSTOP_Y(MIN);
+          #if   CORE_DIAG(XY, X, MIN)
+            PROCESS_CORE_ENDSTOP(X,MIN,Y,MIN);
+          #elif CORE_DIAG(XY, X, MAX)
+            PROCESS_CORE_ENDSTOP(X,MAX,Y,MIN);
+          #elif CORE_DIAG(YZ, Z, MIN)
+            PROCESS_CORE_ENDSTOP(Z,MIN,Y,MIN);
+          #elif CORE_DIAG(YZ, Z, MAX)
+            PROCESS_CORE_ENDSTOP(Z,MAX,Y,MIN);
+          #endif
         #endif
-      #endif
+      }
+      else { // +direction
+        #if HAS_Y_MAX || (Y_SPI_SENSORLESS && Y_HOME_TO_MAX)
+          PROCESS_ENDSTOP_Y(MAX);
+          #if   CORE_DIAG(XY, X, MIN)
+            PROCESS_CORE_ENDSTOP(X,MIN,Y,MAX);
+          #elif CORE_DIAG(XY, X, MAX)
+            PROCESS_CORE_ENDSTOP(X,MAX,Y,MAX);
+          #elif CORE_DIAG(YZ, Z, MIN)
+            PROCESS_CORE_ENDSTOP(Z,MIN,Y,MAX);
+          #elif CORE_DIAG(YZ, Z, MAX)
+            PROCESS_CORE_ENDSTOP(Z,MAX,Y,MAX);
+          #endif
+        #endif
+      }
     }
-    else { // +direction
-      #if HAS_Y_MAX || (Y_SPI_SENSORLESS && Y_HOME_TO_MAX)
-        PROCESS_ENDSTOP_Y(MAX);
-        #if   CORE_DIAG(XY, X, MIN)
-          PROCESS_CORE_ENDSTOP(X,MIN,Y,MAX);
-        #elif CORE_DIAG(XY, X, MAX)
-          PROCESS_CORE_ENDSTOP(X,MAX,Y,MAX);
-        #elif CORE_DIAG(YZ, Z, MIN)
-          PROCESS_CORE_ENDSTOP(Z,MIN,Y,MAX);
-        #elif CORE_DIAG(YZ, Z, MAX)
-          PROCESS_CORE_ENDSTOP(Z,MAX,Y,MAX);
+  #endif
+
+  #if HAS_Z_AXIS
+    if (stepper.axis_is_moving(Z_AXIS)) {
+      if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
+
+        #if HAS_Z_MIN || (Z_SPI_SENSORLESS && Z_HOME_TO_MIN)
+          if ( TERN1(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN, z_probe_enabled)
+            && TERN1(HAS_CUSTOM_PROBE_PIN, !z_probe_enabled)
+          ) PROCESS_ENDSTOP_Z(MIN);
+          #if   CORE_DIAG(XZ, X, MIN)
+            PROCESS_CORE_ENDSTOP(X,MIN,Z,MIN);
+          #elif CORE_DIAG(XZ, X, MAX)
+            PROCESS_CORE_ENDSTOP(X,MAX,Z,MIN);
+          #elif CORE_DIAG(YZ, Y, MIN)
+            PROCESS_CORE_ENDSTOP(Y,MIN,Z,MIN);
+          #elif CORE_DIAG(YZ, Y, MAX)
+            PROCESS_CORE_ENDSTOP(Y,MAX,Z,MIN);
+          #endif
         #endif
-      #endif
+
+        // When closing the gap check the enabled probe
+        #if HAS_CUSTOM_PROBE_PIN
+          if (z_probe_enabled) PROCESS_ENDSTOP(Z, MIN_PROBE);
+        #endif
+      }
+      else { // Z +direction. Gantry up, bed down.
+        #if HAS_Z_MAX || (Z_SPI_SENSORLESS && Z_HOME_TO_MAX)
+          #if ENABLED(Z_MULTI_ENDSTOPS)
+            PROCESS_ENDSTOP_Z(MAX);
+          #elif !HAS_CUSTOM_PROBE_PIN || Z_MAX_PIN != Z_MIN_PROBE_PIN  // No probe or probe is Z_MIN || Probe is not Z_MAX
+            PROCESS_ENDSTOP(Z, MAX);
+          #endif
+          #if   CORE_DIAG(XZ, X, MIN)
+            PROCESS_CORE_ENDSTOP(X,MIN,Z,MAX);
+          #elif CORE_DIAG(XZ, X, MAX)
+            PROCESS_CORE_ENDSTOP(X,MAX,Z,MAX);
+          #elif CORE_DIAG(YZ, Y, MIN)
+            PROCESS_CORE_ENDSTOP(Y,MIN,Z,MAX);
+          #elif CORE_DIAG(YZ, Y, MAX)
+            PROCESS_CORE_ENDSTOP(Y,MAX,Z,MAX);
+          #endif
+        #endif
+      }
     }
-  }
+  #endif
 
-  if (stepper.axis_is_moving(Z_AXIS)) {
-    if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
-
-      #if HAS_Z_MIN || (Z_SPI_SENSORLESS && Z_HOME_TO_MIN)
-        if ( TERN1(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN, z_probe_enabled)
-          && TERN1(HAS_CUSTOM_PROBE_PIN, !z_probe_enabled)
-        ) PROCESS_ENDSTOP_Z(MIN);
-        #if   CORE_DIAG(XZ, X, MIN)
-          PROCESS_CORE_ENDSTOP(X,MIN,Z,MIN);
-        #elif CORE_DIAG(XZ, X, MAX)
-          PROCESS_CORE_ENDSTOP(X,MAX,Z,MIN);
-        #elif CORE_DIAG(YZ, Y, MIN)
-          PROCESS_CORE_ENDSTOP(Y,MIN,Z,MIN);
-        #elif CORE_DIAG(YZ, Y, MAX)
-          PROCESS_CORE_ENDSTOP(Y,MAX,Z,MIN);
+  #if LINEAR_AXES >= 4
+    if (stepper.axis_is_moving(I_AXIS)) {
+      if (stepper.motor_direction(I_AXIS_HEAD)) { // -direction
+        #if HAS_I_MIN || (I_SPI_SENSORLESS && I_HOME_TO_MIN)
+          PROCESS_ENDSTOP(I, MIN);
         #endif
-      #endif
+      }
+      else { // +direction
+        #if HAS_I_MAX || (I_SPI_SENSORLESS && I_HOME_TO_MAX)
+          PROCESS_ENDSTOP(I, MAX);
+        #endif
+      }
+    }
+  #endif
 
-      // When closing the gap check the enabled probe
-      #if HAS_CUSTOM_PROBE_PIN
-        if (z_probe_enabled) PROCESS_ENDSTOP(Z, MIN_PROBE);
-      #endif
+  #if LINEAR_AXES >= 5
+    if (stepper.axis_is_moving(J_AXIS)) {
+      if (stepper.motor_direction(J_AXIS_HEAD)) { // -direction
+        #if HAS_J_MIN || (J_SPI_SENSORLESS && J_HOME_TO_MIN)
+          PROCESS_ENDSTOP(J, MIN);
+        #endif
+      }
+      else { // +direction
+        #if HAS_J_MAX || (J_SPI_SENSORLESS && J_HOME_TO_MAX)
+          PROCESS_ENDSTOP(J, MAX);
+        #endif
+      }
     }
-    else { // Z +direction. Gantry up, bed down.
-      #if HAS_Z_MAX || (Z_SPI_SENSORLESS && Z_HOME_TO_MAX)
-        #if ENABLED(Z_MULTI_ENDSTOPS)
-          PROCESS_ENDSTOP_Z(MAX);
-        #elif !HAS_CUSTOM_PROBE_PIN || Z_MAX_PIN != Z_MIN_PROBE_PIN  // No probe or probe is Z_MIN || Probe is not Z_MAX
-          PROCESS_ENDSTOP(Z, MAX);
+  #endif
+
+  #if LINEAR_AXES >= 6
+    if (stepper.axis_is_moving(K_AXIS)) {
+      if (stepper.motor_direction(K_AXIS_HEAD)) { // -direction
+        #if HAS_K_MIN || (K_SPI_SENSORLESS && K_HOME_TO_MIN)
+          PROCESS_ENDSTOP(K, MIN);
         #endif
-        #if   CORE_DIAG(XZ, X, MIN)
-          PROCESS_CORE_ENDSTOP(X,MIN,Z,MAX);
-        #elif CORE_DIAG(XZ, X, MAX)
-          PROCESS_CORE_ENDSTOP(X,MAX,Z,MAX);
-        #elif CORE_DIAG(YZ, Y, MIN)
-          PROCESS_CORE_ENDSTOP(Y,MIN,Z,MAX);
-        #elif CORE_DIAG(YZ, Y, MAX)
-          PROCESS_CORE_ENDSTOP(Y,MAX,Z,MAX);
+      }
+      else { // +direction
+        #if HAS_K_MAX || (K_SPI_SENSORLESS && K_HOME_TO_MAX)
+          PROCESS_ENDSTOP(K, MAX);
         #endif
-      #endif
+      }
     }
-  }
+  #endif
 } // Endstops::update()
 
 #if ENABLED(SPI_ENDSTOPS)
@@ -919,6 +1136,24 @@ void Endstops::update() {
         hit = true;
       }
     #endif
+    #if I_SPI_SENSORLESS
+      if (tmc_spi_homing.i && stepperI.test_stall_status()) {
+        SBI(live_state, I_ENDSTOP);
+        hit = true;
+      }
+    #endif
+    #if J_SPI_SENSORLESS
+      if (tmc_spi_homing.j && stepperJ.test_stall_status()) {
+        SBI(live_state, J_ENDSTOP);
+        hit = true;
+      }
+    #endif
+    #if K_SPI_SENSORLESS
+      if (tmc_spi_homing.k && stepperK.test_stall_status()) {
+        SBI(live_state, K_ENDSTOP);
+        hit = true;
+      }
+    #endif
 
     if (TERN0(ENDSTOP_INTERRUPTS_FEATURE, hit)) update();
 
@@ -929,6 +1164,9 @@ void Endstops::update() {
     TERN_(X_SPI_SENSORLESS, CBI(live_state, X_ENDSTOP));
     TERN_(Y_SPI_SENSORLESS, CBI(live_state, Y_ENDSTOP));
     TERN_(Z_SPI_SENSORLESS, CBI(live_state, Z_ENDSTOP));
+    TERN_(I_SPI_SENSORLESS, CBI(live_state, I_ENDSTOP));
+    TERN_(J_SPI_SENSORLESS, CBI(live_state, J_ENDSTOP));
+    TERN_(K_SPI_SENSORLESS, CBI(live_state, K_ENDSTOP));
   }
 
 #endif // SPI_ENDSTOPS
@@ -1005,6 +1243,24 @@ void Endstops::update() {
     #if HAS_Z4_MAX
       ES_GET_STATE(Z4_MAX);
     #endif
+    #if HAS_I_MAX
+      ES_GET_STATE(I_MAX);
+    #endif
+    #if HAS_I_MIN
+      ES_GET_STATE(I_MIN);
+    #endif
+    #if HAS_J_MAX
+      ES_GET_STATE(J_MAX);
+    #endif
+    #if HAS_J_MIN
+      ES_GET_STATE(J_MIN);
+    #endif
+    #if HAS_K_MAX
+      ES_GET_STATE(K_MAX);
+    #endif
+    #if HAS_K_MIN
+      ES_GET_STATE(K_MIN);
+    #endif
 
     uint16_t endstop_change = live_state_local ^ old_live_state_local;
     #define ES_REPORT_CHANGE(S) if (TEST(endstop_change, S)) SERIAL_ECHOPAIR("  " STRINGIFY(S) ":", TEST(live_state_local, S))
@@ -1061,6 +1317,24 @@ void Endstops::update() {
       #if HAS_Z4_MAX
         ES_REPORT_CHANGE(Z4_MAX);
       #endif
+      #if HAS_I_MIN
+        ES_REPORT_CHANGE(I_MIN);
+      #endif
+      #if HAS_I_MAX
+        ES_REPORT_CHANGE(I_MAX);
+      #endif
+      #if HAS_J_MIN
+        ES_REPORT_CHANGE(J_MIN);
+      #endif
+      #if HAS_J_MAX
+        ES_REPORT_CHANGE(J_MAX);
+      #endif
+      #if HAS_K_MIN
+        ES_REPORT_CHANGE(K_MIN);
+      #endif
+      #if HAS_K_MAX
+        ES_REPORT_CHANGE(K_MAX);
+      #endif
       SERIAL_ECHOLNPGM("\n");
       analogWrite(pin_t(LED_PIN), local_LED_status);
       local_LED_status ^= 255;

commit dd4990252e891cdfe56cb7d6e3bbe1e6289be649
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon May 24 16:38:57 2021 -0500

    ‚ôªÔ∏è Refactor Linear / Logical / Distinct Axes (#21953)
    
    * More patches supporting EXTRUDERS 0
    * Extend types in prep for more axes

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index dff0b6832a..cf152ff028 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -361,7 +361,8 @@ void Endstops::event_handler() {
   prev_hit_state = hit_state;
   if (hit_state) {
     #if HAS_STATUS_MESSAGE
-      char chrX = ' ', chrY = ' ', chrZ = ' ', chrP = ' ';
+      char LINEAR_AXIS_LIST(chrX = ' ', chrY = ' ', chrZ = ' '),
+           chrP = ' ';
       #define _SET_STOP_CHAR(A,C) (chr## A = C)
     #else
       #define _SET_STOP_CHAR(A,C) NOOP
@@ -390,7 +391,13 @@ void Endstops::event_handler() {
     #endif
     SERIAL_EOL();
 
-    TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " %c %c %c %c"), GET_TEXT(MSG_LCD_ENDSTOPS), chrX, chrY, chrZ, chrP));
+    TERN_(HAS_STATUS_MESSAGE,
+      ui.status_printf_P(0,
+        PSTR(S_FMT GANG_N_1(LINEAR_AXES, " %c") " %c"),
+        GET_TEXT(MSG_LCD_ENDSTOPS),
+        LINEAR_AXIS_LIST(chrX, chrY, chrZ), chrP
+      )
+    );
 
     #if BOTH(SD_ABORT_ON_ENDSTOP_HIT, SDSUPPORT)
       if (planner.abort_on_endstop_hit) {

commit 92dea8e6ccd26950eed817fce6f574fcfe866489
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 23 01:09:46 2021 -0500

    ‚ôªÔ∏è Refactor, comment endstop/probe enums

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 7a452f1fdd..dff0b6832a 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -403,12 +403,21 @@ void Endstops::event_handler() {
   }
 }
 
+#if GCC_VERSION <= 50000
+  #pragma GCC diagnostic push
+  #pragma GCC diagnostic ignored "-Wunused-function"
+#endif
+
 static void print_es_state(const bool is_hit, PGM_P const label=nullptr) {
   if (label) SERIAL_ECHOPGM_P(label);
   SERIAL_ECHOPGM(": ");
   SERIAL_ECHOLNPGM_P(is_hit ? PSTR(STR_ENDSTOP_HIT) : PSTR(STR_ENDSTOP_OPEN));
 }
 
+#if GCC_VERSION <= 50000
+  #pragma GCC diagnostic pop
+#endif
+
 void _O2 Endstops::report_states() {
   TERN_(BLTOUCH, bltouch._set_SW_mode());
   SERIAL_ECHOLNPGM(STR_M119_REPORT);

commit 49771c4a9ed2afa1e572f82a24b5edb3de120f78
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed May 19 00:21:34 2021 -0500

    üé® Flags for homing directions

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index d0befe71fb..7a452f1fdd 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -513,14 +513,8 @@ void Endstops::update() {
   #endif
 
   // With Dual X, endstops are only checked in the homing direction for the active extruder
-  #if ENABLED(DUAL_X_CARRIAGE)
-    #define E0_ACTIVE stepper.last_moved_extruder == 0
-    #define X_MIN_TEST() ((X_HOME_DIR < 0 && E0_ACTIVE) || (X2_HOME_DIR < 0 && !E0_ACTIVE))
-    #define X_MAX_TEST() ((X_HOME_DIR > 0 && E0_ACTIVE) || (X2_HOME_DIR > 0 && !E0_ACTIVE))
-  #else
-    #define X_MIN_TEST() true
-    #define X_MAX_TEST() true
-  #endif
+  #define X_MIN_TEST() TERN1(DUAL_X_CARRIAGE, TERN0(X_HOME_TO_MIN, stepper.last_moved_extruder == 0) || TERN0(X2_HOME_TO_MIN, stepper.last_moved_extruder != 0))
+  #define X_MAX_TEST() TERN1(DUAL_X_CARRIAGE, TERN0(X_HOME_TO_MAX, stepper.last_moved_extruder == 0) || TERN0(X2_HOME_TO_MAX, stepper.last_moved_extruder != 0))
 
   // Use HEAD for core axes, AXIS for others
   #if ANY(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY)
@@ -765,7 +759,7 @@ void Endstops::update() {
 
   if (stepper.axis_is_moving(X_AXIS)) {
     if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
-      #if HAS_X_MIN || (X_SPI_SENSORLESS && X_HOME_DIR < 0)
+      #if HAS_X_MIN || (X_SPI_SENSORLESS && X_HOME_TO_MIN)
         PROCESS_ENDSTOP_X(MIN);
         #if   CORE_DIAG(XY, Y, MIN)
           PROCESS_CORE_ENDSTOP(Y,MIN,X,MIN);
@@ -779,7 +773,7 @@ void Endstops::update() {
       #endif
     }
     else { // +direction
-      #if HAS_X_MAX || (X_SPI_SENSORLESS && X_HOME_DIR > 0)
+      #if HAS_X_MAX || (X_SPI_SENSORLESS && X_HOME_TO_MAX)
         PROCESS_ENDSTOP_X(MAX);
         #if   CORE_DIAG(XY, Y, MIN)
           PROCESS_CORE_ENDSTOP(Y,MIN,X,MAX);
@@ -796,7 +790,7 @@ void Endstops::update() {
 
   if (stepper.axis_is_moving(Y_AXIS)) {
     if (stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
-      #if HAS_Y_MIN || (Y_SPI_SENSORLESS && Y_HOME_DIR < 0)
+      #if HAS_Y_MIN || (Y_SPI_SENSORLESS && Y_HOME_TO_MIN)
         PROCESS_ENDSTOP_Y(MIN);
         #if   CORE_DIAG(XY, X, MIN)
           PROCESS_CORE_ENDSTOP(X,MIN,Y,MIN);
@@ -810,7 +804,7 @@ void Endstops::update() {
       #endif
     }
     else { // +direction
-      #if HAS_Y_MAX || (Y_SPI_SENSORLESS && Y_HOME_DIR > 0)
+      #if HAS_Y_MAX || (Y_SPI_SENSORLESS && Y_HOME_TO_MAX)
         PROCESS_ENDSTOP_Y(MAX);
         #if   CORE_DIAG(XY, X, MIN)
           PROCESS_CORE_ENDSTOP(X,MIN,Y,MAX);
@@ -828,7 +822,7 @@ void Endstops::update() {
   if (stepper.axis_is_moving(Z_AXIS)) {
     if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
 
-      #if HAS_Z_MIN || (Z_SPI_SENSORLESS && Z_HOME_DIR < 0)
+      #if HAS_Z_MIN || (Z_SPI_SENSORLESS && Z_HOME_TO_MIN)
         if ( TERN1(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN, z_probe_enabled)
           && TERN1(HAS_CUSTOM_PROBE_PIN, !z_probe_enabled)
         ) PROCESS_ENDSTOP_Z(MIN);
@@ -849,7 +843,7 @@ void Endstops::update() {
       #endif
     }
     else { // Z +direction. Gantry up, bed down.
-      #if HAS_Z_MAX || (Z_SPI_SENSORLESS && Z_HOME_DIR > 0)
+      #if HAS_Z_MAX || (Z_SPI_SENSORLESS && Z_HOME_TO_MAX)
         #if ENABLED(Z_MULTI_ENDSTOPS)
           PROCESS_ENDSTOP_Z(MAX);
         #elif !HAS_CUSTOM_PROBE_PIN || Z_MAX_PIN != Z_MIN_PROBE_PIN  // No probe or probe is Z_MIN || Probe is not Z_MAX

commit 02f904dbf9df999264099a26c563b07b1d163df4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 18 22:53:52 2021 -0500

    ‚ôªÔ∏è Minimize endstop bits

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 2ac20c92ef..d0befe71fb 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -56,12 +56,12 @@ Endstops endstops;
 // private:
 
 bool Endstops::enabled, Endstops::enabled_globally; // Initialized by settings.load()
-volatile uint8_t Endstops::hit_state;
 
-Endstops::esbits_t Endstops::live_state = 0;
+volatile Endstops::endstop_mask_t Endstops::hit_state;
+Endstops::endstop_mask_t Endstops::live_state = 0;
 
 #if ENDSTOP_NOISE_THRESHOLD
-  Endstops::esbits_t Endstops::validated_live_state;
+  Endstops::endstop_mask_t Endstops::validated_live_state;
   uint8_t Endstops::endstop_poll_count;
 #endif
 
@@ -356,7 +356,7 @@ void Endstops::resync() {
 #endif
 
 void Endstops::event_handler() {
-  static uint8_t prev_hit_state; // = 0
+  static endstop_mask_t prev_hit_state; // = 0
   if (hit_state == prev_hit_state) return;
   prev_hit_state = hit_state;
   if (hit_state) {
@@ -364,15 +364,14 @@ void Endstops::event_handler() {
       char chrX = ' ', chrY = ' ', chrZ = ' ', chrP = ' ';
       #define _SET_STOP_CHAR(A,C) (chr## A = C)
     #else
-      #define _SET_STOP_CHAR(A,C) ;
+      #define _SET_STOP_CHAR(A,C) NOOP
     #endif
 
     #define _ENDSTOP_HIT_ECHO(A,C) do{ \
-      SERIAL_ECHOPAIR(" " STRINGIFY(A) ":", planner.triggered_position_mm(_AXIS(A))); \
-      _SET_STOP_CHAR(A,C); }while(0)
+      SERIAL_ECHOPAIR(" " STRINGIFY(A) ":", planner.triggered_position_mm(_AXIS(A))); _SET_STOP_CHAR(A,C); }while(0)
 
     #define _ENDSTOP_HIT_TEST(A,C) \
-      if (TEST(hit_state, A ##_MIN) || TEST(hit_state, A ##_MAX)) \
+      if (TERN0(HAS_##A##_MIN, TEST(hit_state, A##_MIN)) || TERN0(HAS_##A##_MAX, TEST(hit_state, A##_MAX))) \
         _ENDSTOP_HIT_ECHO(A,C)
 
     #define ENDSTOP_HIT_TEST_X() _ENDSTOP_HIT_TEST(X,'X')
@@ -659,7 +658,7 @@ void Endstops::update() {
      * still exist. The only way to reduce them further is to increase the number of samples.
      * To reduce the chance to 1% (1/128th) requires 7 samples (adding 7ms of delay).
      */
-    static esbits_t old_live_state;
+    static endstop_mask_t old_live_state;
     if (old_live_state != live_state) {
       endstop_poll_count = ENDSTOP_NOISE_THRESHOLD;
       old_live_state = live_state;

commit abbe3f0dc7aa23bae4aa26f6d6b09a4a0665a1a0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 18 22:46:59 2021 -0500

    üé® Misc cleanup and fixes

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index d7f728ad4b..2ac20c92ef 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -508,7 +508,7 @@ void Endstops::update() {
   #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT_TO(live_state, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
   #define COPY_LIVE_STATE(SRC_BIT, DST_BIT) SET_BIT_TO(live_state, DST_BIT, TEST(live_state, SRC_BIT))
 
-  #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && NONE(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY)
+  #if BOTH(G38_PROBE_TARGET, HAS_Z_MIN_PROBE_PIN) && NONE(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY)
     // If G38 command is active check Z_MIN_PROBE for ALL movement
     if (G38_move) UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
   #endif
@@ -747,7 +747,7 @@ void Endstops::update() {
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_DUAL_ENDSTOP(Z, MINMAX)
   #endif
 
-  #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && NONE(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY)
+  #if BOTH(G38_PROBE_TARGET, HAS_Z_MIN_PROBE_PIN) && NONE(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY)
     #if ENABLED(G38_PROBE_AWAY)
       #define _G38_OPEN_STATE (G38_move >= 4)
     #else

commit b65cdbed91782c83188706a9c340de9c503cf430
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 8 04:35:35 2021 -0500

    Signal SD completion later (#21840)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 14c5f13367..d7f728ad4b 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -395,7 +395,7 @@ void Endstops::event_handler() {
 
     #if BOTH(SD_ABORT_ON_ENDSTOP_HIT, SDSUPPORT)
       if (planner.abort_on_endstop_hit) {
-        card.endFilePrint();
+        card.abortFilePrintNow();
         quickstop_stepper();
         thermalManager.disable_all_heaters();
         print_job_timer.stop();

commit f09fa69e867d1cfb18cbad720a5c1e566cb1bab4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat May 8 01:41:40 2021 -0500

    Add and apply REPEAT_1 macro

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index e11c4605e4..14c5f13367 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -475,7 +475,7 @@ void _O2 Endstops::report_states() {
       uint8_t state;
       switch (i) {
         default: continue;
-        REPEAT_S(1, INCREMENT(NUM_RUNOUT_SENSORS), _CASE_RUNOUT)
+        REPEAT_1(NUM_RUNOUT_SENSORS, _CASE_RUNOUT)
       }
       SERIAL_ECHOPGM(STR_FILAMENT_RUNOUT_SENSOR);
       if (i > 1) SERIAL_CHAR(' ', '0' + i);

commit 930752d46e6aacb484ea89dacae6baf823d78d62
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Wed Mar 24 10:12:57 2021 -0500

    Ender 3 V2 Status Line (#21369)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 4192b444bb..e11c4605e4 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -360,7 +360,7 @@ void Endstops::event_handler() {
   if (hit_state == prev_hit_state) return;
   prev_hit_state = hit_state;
   if (hit_state) {
-    #if HAS_WIRED_LCD
+    #if HAS_STATUS_MESSAGE
       char chrX = ' ', chrY = ' ', chrZ = ' ', chrP = ' ';
       #define _SET_STOP_CHAR(A,C) (chr## A = C)
     #else
@@ -391,7 +391,7 @@ void Endstops::event_handler() {
     #endif
     SERIAL_EOL();
 
-    TERN_(HAS_WIRED_LCD, ui.status_printf_P(0, PSTR(S_FMT " %c %c %c %c"), GET_TEXT(MSG_LCD_ENDSTOPS), chrX, chrY, chrZ, chrP));
+    TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " %c %c %c %c"), GET_TEXT(MSG_LCD_ENDSTOPS), chrX, chrY, chrZ, chrP));
 
     #if BOTH(SD_ABORT_ON_ENDSTOP_HIT, SDSUPPORT)
       if (planner.abort_on_endstop_hit) {

commit 713de872ce055bd10bd59b4f811136b0ec0cfbae
Author: Stephan <veigl@gmx.net>
Date:   Mon Mar 1 03:16:22 2021 +0100

    Filament Runout handling for Mixing Extruder (#20327)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 9550799a2d..4192b444bb 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -468,24 +468,22 @@ void _O2 Endstops::report_states() {
   #if HAS_CUSTOM_PROBE_PIN
     print_es_state(PROBE_TRIGGERED(), PSTR(STR_Z_PROBE));
   #endif
-  #if HAS_FILAMENT_SENSOR
-    #if NUM_RUNOUT_SENSORS == 1
-      print_es_state(READ(FIL_RUNOUT1_PIN) != FIL_RUNOUT1_STATE, PSTR(STR_FILAMENT_RUNOUT_SENSOR));
-    #else
-      #define _CASE_RUNOUT(N) case N: pin = FIL_RUNOUT##N##_PIN; state = FIL_RUNOUT##N##_STATE; break;
-      LOOP_S_LE_N(i, 1, NUM_RUNOUT_SENSORS) {
-        pin_t pin;
-        uint8_t state;
-        switch (i) {
-          default: continue;
-          REPEAT_S(1, INCREMENT(NUM_RUNOUT_SENSORS), _CASE_RUNOUT)
-        }
-        SERIAL_ECHOPGM(STR_FILAMENT_RUNOUT_SENSOR);
-        if (i > 1) SERIAL_CHAR(' ', '0' + i);
-        print_es_state(extDigitalRead(pin) != state);
+  #if MULTI_FILAMENT_SENSOR
+    #define _CASE_RUNOUT(N) case N: pin = FIL_RUNOUT##N##_PIN; state = FIL_RUNOUT##N##_STATE; break;
+    LOOP_S_LE_N(i, 1, NUM_RUNOUT_SENSORS) {
+      pin_t pin;
+      uint8_t state;
+      switch (i) {
+        default: continue;
+        REPEAT_S(1, INCREMENT(NUM_RUNOUT_SENSORS), _CASE_RUNOUT)
       }
-      #undef _CASE_RUNOUT
-    #endif
+      SERIAL_ECHOPGM(STR_FILAMENT_RUNOUT_SENSOR);
+      if (i > 1) SERIAL_CHAR(' ', '0' + i);
+      print_es_state(extDigitalRead(pin) != state);
+    }
+    #undef _CASE_RUNOUT
+  #elif HAS_FILAMENT_SENSOR
+    print_es_state(READ(FIL_RUNOUT1_PIN) != FIL_RUNOUT1_STATE, PSTR(STR_FILAMENT_RUNOUT_SENSOR));
   #endif
 
   TERN_(BLTOUCH, bltouch._reset_SW_mode());

commit dd42831cba7334c5d106ba435bdb41b6135971bb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Feb 28 19:43:46 2021 -0600

    Serial macros cleanup

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index b9d2c1cdf5..9550799a2d 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -405,10 +405,9 @@ void Endstops::event_handler() {
 }
 
 static void print_es_state(const bool is_hit, PGM_P const label=nullptr) {
-  if (label) serialprintPGM(label);
+  if (label) SERIAL_ECHOPGM_P(label);
   SERIAL_ECHOPGM(": ");
-  serialprintPGM(is_hit ? PSTR(STR_ENDSTOP_HIT) : PSTR(STR_ENDSTOP_OPEN));
-  SERIAL_EOL();
+  SERIAL_ECHOLNPGM_P(is_hit ? PSTR(STR_ENDSTOP_HIT) : PSTR(STR_ENDSTOP_OPEN));
 }
 
 void _O2 Endstops::report_states() {

commit c0870d417a68ff4303100f165282d41be9129a5c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jan 21 03:40:07 2021 -0600

    Move some MarlinCore and MarlinUI code (#20832)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index b1c7c1c585..b9d2c1cdf5 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -27,7 +27,6 @@
 #include "endstops.h"
 #include "stepper.h"
 
-#include "../MarlinCore.h"
 #include "../sd/cardreader.h"
 #include "temperature.h"
 #include "../lcd/marlinui.h"

commit f423edd938dcb593b58844cd7dc3b9164d792686
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Dec 27 16:21:01 2020 -0600

    Add probe_switch_activated

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 1467e1b70d..b1c7c1c585 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -465,7 +465,7 @@ void _O2 Endstops::report_states() {
     ES_REPORT(Z4_MAX);
   #endif
   #if BOTH(MARLIN_DEV_MODE, PROBE_ACTIVATION_SWITCH)
-    print_es_state(READ(PROBE_ACTIVATION_SWITCH_PIN) == PROBE_ACTIVATION_SWITCH_STATE, PSTR(STR_PROBE_EN));
+    print_es_state(probe_switch_activated(), PSTR(STR_PROBE_EN));
   #endif
   #if HAS_CUSTOM_PROBE_PIN
     print_es_state(PROBE_TRIGGERED(), PSTR(STR_Z_PROBE));
@@ -618,11 +618,8 @@ void Endstops::update() {
 
   #if HAS_BED_PROBE
     // When closing the gap check the enabled probe
-    if (true
-      #if ENABLED(PROBE_ACTIVATION_SWITCH)
-        || READ(PROBE_ACTIVATION_SWITCH_PIN) == PROBE_ACTIVATION_SWITCH_STATE
-      #endif
-    ) UPDATE_ENDSTOP_BIT(Z, TERN(HAS_CUSTOM_PROBE_PIN, MIN_PROBE, MIN));
+    if (probe_switch_activated())
+      UPDATE_ENDSTOP_BIT(Z, TERN(HAS_CUSTOM_PROBE_PIN, MIN_PROBE, MIN));
   #endif
 
   #if HAS_Z_MAX && !Z_SPI_SENSORLESS

commit 2963229dfa6648246951de90e4a86bf537cc876a
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sat Dec 19 23:11:43 2020 -0500

    Probe Tare, Probe Activation Switch (#20379)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>
    Co-authored-by: Victor Mateus Oliveira <rhapsodyv@gmail.com>
    Co-authored-by: Jason Smith <jason.inet@gmail.com>

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index ef0b92a7ee..1467e1b70d 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -280,6 +280,12 @@ void Endstops::init() {
     #endif
   #endif
 
+  #if ENABLED(PROBE_ACTIVATION_SWITCH)
+    SET_INPUT(PROBE_ACTIVATION_SWITCH_PIN);
+  #endif
+
+  TERN_(PROBE_TARE, probe.tare());
+
   TERN_(ENDSTOP_INTERRUPTS_FEATURE, setup_endstop_interrupts());
 
   // Enable endstops
@@ -458,6 +464,9 @@ void _O2 Endstops::report_states() {
   #if HAS_Z4_MAX
     ES_REPORT(Z4_MAX);
   #endif
+  #if BOTH(MARLIN_DEV_MODE, PROBE_ACTIVATION_SWITCH)
+    print_es_state(READ(PROBE_ACTIVATION_SWITCH_PIN) == PROBE_ACTIVATION_SWITCH_STATE, PSTR(STR_PROBE_EN));
+  #endif
   #if HAS_CUSTOM_PROBE_PIN
     print_es_state(PROBE_TRIGGERED(), PSTR(STR_Z_PROBE));
   #endif
@@ -582,7 +591,7 @@ void Endstops::update() {
     #endif
   #endif
 
-  #if HAS_Z_MIN && !Z_SPI_SENSORLESS
+  #if HAS_Z_MIN && NONE(Z_SPI_SENSORLESS, Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
     UPDATE_ENDSTOP_BIT(Z, MIN);
     #if ENABLED(Z_MULTI_ENDSTOPS)
       #if HAS_Z2_MIN
@@ -607,9 +616,13 @@ void Endstops::update() {
     #endif
   #endif
 
-  // When closing the gap check the enabled probe
-  #if HAS_CUSTOM_PROBE_PIN
-    UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
+  #if HAS_BED_PROBE
+    // When closing the gap check the enabled probe
+    if (true
+      #if ENABLED(PROBE_ACTIVATION_SWITCH)
+        || READ(PROBE_ACTIVATION_SWITCH_PIN) == PROBE_ACTIVATION_SWITCH_STATE
+      #endif
+    ) UPDATE_ENDSTOP_BIT(Z, TERN(HAS_CUSTOM_PROBE_PIN, MIN_PROBE, MIN));
   #endif
 
   #if HAS_Z_MAX && !Z_SPI_SENSORLESS

commit 58ac815822b4c04f29b66ddf076156e6b4994749
Author: wmariz <11435639+wmariz@users.noreply.github.com>
Date:   Thu Nov 26 10:58:19 2020 -0300

    Level Corners with Probe option (#20241)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 697ced7833..ef0b92a7ee 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -48,6 +48,10 @@
   #include "../feature/joystick.h"
 #endif
 
+#if HAS_BED_PROBE
+  #include "probe.h"
+#endif
+
 Endstops endstops;
 
 // private:
@@ -455,7 +459,7 @@ void _O2 Endstops::report_states() {
     ES_REPORT(Z4_MAX);
   #endif
   #if HAS_CUSTOM_PROBE_PIN
-    print_es_state(READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING, PSTR(STR_Z_PROBE));
+    print_es_state(PROBE_TRIGGERED(), PSTR(STR_Z_PROBE));
   #endif
   #if HAS_FILAMENT_SENSOR
     #if NUM_RUNOUT_SENSORS == 1

commit 0465e0ae3aaec257618d095f7e2b28ef677dbe4a
Author: Costas Basdekis <costas.basdekis@gmail.com>
Date:   Wed Nov 11 06:39:23 2020 +0000

    Distinct runout states (#19965)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 825194cf45..697ced7833 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -459,18 +459,19 @@ void _O2 Endstops::report_states() {
   #endif
   #if HAS_FILAMENT_SENSOR
     #if NUM_RUNOUT_SENSORS == 1
-      print_es_state(READ(FIL_RUNOUT_PIN) != FIL_RUNOUT_STATE, PSTR(STR_FILAMENT_RUNOUT_SENSOR));
+      print_es_state(READ(FIL_RUNOUT1_PIN) != FIL_RUNOUT1_STATE, PSTR(STR_FILAMENT_RUNOUT_SENSOR));
     #else
-      #define _CASE_RUNOUT(N) case N: pin = FIL_RUNOUT##N##_PIN; break;
+      #define _CASE_RUNOUT(N) case N: pin = FIL_RUNOUT##N##_PIN; state = FIL_RUNOUT##N##_STATE; break;
       LOOP_S_LE_N(i, 1, NUM_RUNOUT_SENSORS) {
         pin_t pin;
+        uint8_t state;
         switch (i) {
           default: continue;
           REPEAT_S(1, INCREMENT(NUM_RUNOUT_SENSORS), _CASE_RUNOUT)
         }
         SERIAL_ECHOPGM(STR_FILAMENT_RUNOUT_SENSOR);
         if (i > 1) SERIAL_CHAR(' ', '0' + i);
-        print_es_state(extDigitalRead(pin) != FIL_RUNOUT_STATE);
+        print_es_state(extDigitalRead(pin) != state);
       }
       #undef _CASE_RUNOUT
     #endif

commit 2da25d67e155fa0bbf07a6e3767a2a15abb75726
Author: LinFor <linfor@gmail.com>
Date:   Sat Nov 7 12:37:45 2020 +0300

    Fix Endstop Interrupts with SPI endstops, sanity checks (#20051)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 928c9ad8b9..825194cf45 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -899,6 +899,9 @@ void Endstops::update() {
         hit = true;
       }
     #endif
+
+    if (TERN0(ENDSTOP_INTERRUPTS_FEATURE, hit)) update();
+
     return hit;
   }
 

commit eaf6777a6643a6fab23ceaaa4699cb2466ea6b83
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Oct 16 19:36:25 2020 -0500

    Rename ultralcd => marlinui

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 712182a0ea..928c9ad8b9 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -30,7 +30,7 @@
 #include "../MarlinCore.h"
 #include "../sd/cardreader.h"
 #include "temperature.h"
-#include "../lcd/ultralcd.h"
+#include "../lcd/marlinui.h"
 
 #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
   #include HAL_PATH(../HAL, endstop_interrupts.h)

commit c2c6a679ea4bdf48ce1800a8831fcec36c09ce53
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 28 01:13:27 2020 -0500

    Rename LCD conditionals (#19533)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index a3a89736e5..712182a0ea 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -351,7 +351,7 @@ void Endstops::event_handler() {
   if (hit_state == prev_hit_state) return;
   prev_hit_state = hit_state;
   if (hit_state) {
-    #if HAS_SPI_LCD
+    #if HAS_WIRED_LCD
       char chrX = ' ', chrY = ' ', chrZ = ' ', chrP = ' ';
       #define _SET_STOP_CHAR(A,C) (chr## A = C)
     #else
@@ -382,7 +382,7 @@ void Endstops::event_handler() {
     #endif
     SERIAL_EOL();
 
-    TERN_(HAS_SPI_LCD, ui.status_printf_P(0, PSTR(S_FMT " %c %c %c %c"), GET_TEXT(MSG_LCD_ENDSTOPS), chrX, chrY, chrZ, chrP));
+    TERN_(HAS_WIRED_LCD, ui.status_printf_P(0, PSTR(S_FMT " %c %c %c %c"), GET_TEXT(MSG_LCD_ENDSTOPS), chrX, chrY, chrZ, chrP));
 
     #if BOTH(SD_ABORT_ON_ENDSTOP_HIT, SDSUPPORT)
       if (planner.abort_on_endstop_hit) {

commit 76d8d1742c1d4a1efe0fd6c0645d3fc656bfd0b2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 20 18:29:08 2020 -0500

    Add multi-extruder condition

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 1169ede2dc..a3a89736e5 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -505,7 +505,7 @@ void Endstops::update() {
 
   // With Dual X, endstops are only checked in the homing direction for the active extruder
   #if ENABLED(DUAL_X_CARRIAGE)
-    #define E0_ACTIVE stepper.movement_extruder() == 0
+    #define E0_ACTIVE stepper.last_moved_extruder == 0
     #define X_MIN_TEST() ((X_HOME_DIR < 0 && E0_ACTIVE) || (X2_HOME_DIR < 0 && !E0_ACTIVE))
     #define X_MAX_TEST() ((X_HOME_DIR > 0 && E0_ACTIVE) || (X2_HOME_DIR > 0 && !E0_ACTIVE))
   #else

commit e97e6865c3e587a04ae2878e72a8dfb137534b7e
Author: Victor Sokolov <gzigzigzeo@gmail.com>
Date:   Fri Sep 4 05:12:53 2020 +0400

    MarkForged kinematics (#19235)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 289270072d..1169ede2dc 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -498,7 +498,7 @@ void Endstops::update() {
   #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT_TO(live_state, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
   #define COPY_LIVE_STATE(SRC_BIT, DST_BIT) SET_BIT_TO(live_state, DST_BIT, TEST(live_state, SRC_BIT))
 
-  #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && !(CORE_IS_XY || CORE_IS_XZ)
+  #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && NONE(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY)
     // If G38 command is active check Z_MIN_PROBE for ALL movement
     if (G38_move) UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
   #endif
@@ -514,12 +514,12 @@ void Endstops::update() {
   #endif
 
   // Use HEAD for core axes, AXIS for others
-  #if CORE_IS_XY || CORE_IS_XZ
+  #if ANY(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY)
     #define X_AXIS_HEAD X_HEAD
   #else
     #define X_AXIS_HEAD X_AXIS
   #endif
-  #if CORE_IS_XY || CORE_IS_YZ
+  #if ANY(CORE_IS_XY, CORE_IS_YZ, MARKFORGED_XY)
     #define Y_AXIS_HEAD Y_HEAD
   #else
     #define Y_AXIS_HEAD Y_AXIS
@@ -736,7 +736,7 @@ void Endstops::update() {
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_DUAL_ENDSTOP(Z, MINMAX)
   #endif
 
-  #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && !(CORE_IS_XY || CORE_IS_XZ)
+  #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && NONE(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY)
     #if ENABLED(G38_PROBE_AWAY)
       #define _G38_OPEN_STATE (G38_move >= 4)
     #else
@@ -865,7 +865,7 @@ void Endstops::update() {
     bool hit = false;
     #if X_SPI_SENSORLESS
       if (tmc_spi_homing.x && (stepperX.test_stall_status()
-        #if CORE_IS_XY && Y_SPI_SENSORLESS
+        #if ANY(CORE_IS_XY, MARKFORGED_XY) && Y_SPI_SENSORLESS
           || stepperY.test_stall_status()
         #elif CORE_IS_XZ && Z_SPI_SENSORLESS
           || stepperZ.test_stall_status()
@@ -877,7 +877,7 @@ void Endstops::update() {
     #endif
     #if Y_SPI_SENSORLESS
       if (tmc_spi_homing.y && (stepperY.test_stall_status()
-        #if CORE_IS_XY && X_SPI_SENSORLESS
+        #if ANY(CORE_IS_XY, MARKFORGED_XY) && X_SPI_SENSORLESS
           || stepperX.test_stall_status()
         #elif CORE_IS_YZ && Z_SPI_SENSORLESS
           || stepperZ.test_stall_status()

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index a9a0a7e9bf..289270072d 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -16,7 +16,7 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 

commit 2c238e4fc2f18da08d7cb171bb7236beccdd6f83
Author: Speaka <48431623+Speaka@users.noreply.github.com>
Date:   Sun Jul 12 20:16:56 2020 +0200

    Option for extra endstop check (#18424)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 9cf283ccba..a9a0a7e9bf 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -861,10 +861,6 @@ void Endstops::update() {
 
 #if ENABLED(SPI_ENDSTOPS)
 
-  #define X_STOP (X_HOME_DIR < 0 ? X_MIN : X_MAX)
-  #define Y_STOP (Y_HOME_DIR < 0 ? Y_MIN : Y_MAX)
-  #define Z_STOP (Z_HOME_DIR < 0 ? Z_MIN : Z_MAX)
-
   bool Endstops::tmc_spi_homing_check() {
     bool hit = false;
     #if X_SPI_SENSORLESS
@@ -875,7 +871,7 @@ void Endstops::update() {
           || stepperZ.test_stall_status()
         #endif
       )) {
-        SBI(live_state, X_STOP);
+        SBI(live_state, X_ENDSTOP);
         hit = true;
       }
     #endif
@@ -887,7 +883,7 @@ void Endstops::update() {
           || stepperZ.test_stall_status()
         #endif
       )) {
-        SBI(live_state, Y_STOP);
+        SBI(live_state, Y_ENDSTOP);
         hit = true;
       }
     #endif
@@ -899,7 +895,7 @@ void Endstops::update() {
           || stepperY.test_stall_status()
         #endif
       )) {
-        SBI(live_state, Z_STOP);
+        SBI(live_state, Z_ENDSTOP);
         hit = true;
       }
     #endif
@@ -907,9 +903,9 @@ void Endstops::update() {
   }
 
   void Endstops::clear_endstop_state() {
-    TERN_(X_SPI_SENSORLESS, CBI(live_state, X_STOP));
-    TERN_(Y_SPI_SENSORLESS, CBI(live_state, Y_STOP));
-    TERN_(Z_SPI_SENSORLESS, CBI(live_state, Z_STOP));
+    TERN_(X_SPI_SENSORLESS, CBI(live_state, X_ENDSTOP));
+    TERN_(Y_SPI_SENSORLESS, CBI(live_state, Y_ENDSTOP));
+    TERN_(Z_SPI_SENSORLESS, CBI(live_state, Z_ENDSTOP));
   }
 
 #endif // SPI_ENDSTOPS

commit c02451b602d6ee24d09f4f41269c85c0972a2279
Author: Robby Candra <robbycandra.mail@gmail.com>
Date:   Mon Jul 6 05:42:19 2020 +0700

    Filament Runout Inverting => State (#18537)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 47d63df64b..9cf283ccba 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -459,7 +459,7 @@ void _O2 Endstops::report_states() {
   #endif
   #if HAS_FILAMENT_SENSOR
     #if NUM_RUNOUT_SENSORS == 1
-      print_es_state(READ(FIL_RUNOUT_PIN) != FIL_RUNOUT_INVERTING, PSTR(STR_FILAMENT_RUNOUT_SENSOR));
+      print_es_state(READ(FIL_RUNOUT_PIN) != FIL_RUNOUT_STATE, PSTR(STR_FILAMENT_RUNOUT_SENSOR));
     #else
       #define _CASE_RUNOUT(N) case N: pin = FIL_RUNOUT##N##_PIN; break;
       LOOP_S_LE_N(i, 1, NUM_RUNOUT_SENSORS) {
@@ -470,7 +470,7 @@ void _O2 Endstops::report_states() {
         }
         SERIAL_ECHOPGM(STR_FILAMENT_RUNOUT_SENSOR);
         if (i > 1) SERIAL_CHAR(' ', '0' + i);
-        print_es_state(extDigitalRead(pin) != FIL_RUNOUT_INVERTING);
+        print_es_state(extDigitalRead(pin) != FIL_RUNOUT_STATE);
       }
       #undef _CASE_RUNOUT
     #endif

commit 45a01a3ecab5247826c8d1cb3d7b531724d774e7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 16 01:06:18 2020 -0500

    Non-SPI core homing pin tests (#17996)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 5cfd7771a0..47d63df64b 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -674,6 +674,15 @@ void Endstops::update() {
     } \
   }while(0)
 
+  // Core Sensorless Homing needs to test an Extra Pin
+  #define CORE_DIAG(QQ,A,MM) (CORE_IS_##QQ && A##_SENSORLESS && !A##_SPI_SENSORLESS && HAS_##A##_##MM)
+  #define PROCESS_CORE_ENDSTOP(A1,M1,A2,M2) do { \
+    if (TEST_ENDSTOP(_ENDSTOP(A1,M1))) { \
+      _ENDSTOP_HIT(A2,M2); \
+      planner.endstop_triggered(_AXIS(A2)); \
+    } \
+  }while(0)
+
   // Call the endstop triggered routine for dual endstops
   #define PROCESS_DUAL_ENDSTOP(A, MINMAX) do { \
     const byte dual_hit = TEST_ENDSTOP(_ENDSTOP(A, MINMAX)) | (TEST_ENDSTOP(_ENDSTOP(A##2, MINMAX)) << 1); \
@@ -748,11 +757,29 @@ void Endstops::update() {
     if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
       #if HAS_X_MIN || (X_SPI_SENSORLESS && X_HOME_DIR < 0)
         PROCESS_ENDSTOP_X(MIN);
+        #if   CORE_DIAG(XY, Y, MIN)
+          PROCESS_CORE_ENDSTOP(Y,MIN,X,MIN);
+        #elif CORE_DIAG(XY, Y, MAX)
+          PROCESS_CORE_ENDSTOP(Y,MAX,X,MIN);
+        #elif CORE_DIAG(XZ, Z, MIN)
+          PROCESS_CORE_ENDSTOP(Z,MIN,X,MIN);
+        #elif CORE_DIAG(XZ, Z, MAX)
+          PROCESS_CORE_ENDSTOP(Z,MAX,X,MIN);
+        #endif
       #endif
     }
     else { // +direction
       #if HAS_X_MAX || (X_SPI_SENSORLESS && X_HOME_DIR > 0)
         PROCESS_ENDSTOP_X(MAX);
+        #if   CORE_DIAG(XY, Y, MIN)
+          PROCESS_CORE_ENDSTOP(Y,MIN,X,MAX);
+        #elif CORE_DIAG(XY, Y, MAX)
+          PROCESS_CORE_ENDSTOP(Y,MAX,X,MAX);
+        #elif CORE_DIAG(XZ, Z, MIN)
+          PROCESS_CORE_ENDSTOP(Z,MIN,X,MAX);
+        #elif CORE_DIAG(XZ, Z, MAX)
+          PROCESS_CORE_ENDSTOP(Z,MAX,X,MAX);
+        #endif
       #endif
     }
   }
@@ -761,11 +788,29 @@ void Endstops::update() {
     if (stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
       #if HAS_Y_MIN || (Y_SPI_SENSORLESS && Y_HOME_DIR < 0)
         PROCESS_ENDSTOP_Y(MIN);
+        #if   CORE_DIAG(XY, X, MIN)
+          PROCESS_CORE_ENDSTOP(X,MIN,Y,MIN);
+        #elif CORE_DIAG(XY, X, MAX)
+          PROCESS_CORE_ENDSTOP(X,MAX,Y,MIN);
+        #elif CORE_DIAG(YZ, Z, MIN)
+          PROCESS_CORE_ENDSTOP(Z,MIN,Y,MIN);
+        #elif CORE_DIAG(YZ, Z, MAX)
+          PROCESS_CORE_ENDSTOP(Z,MAX,Y,MIN);
+        #endif
       #endif
     }
     else { // +direction
       #if HAS_Y_MAX || (Y_SPI_SENSORLESS && Y_HOME_DIR > 0)
         PROCESS_ENDSTOP_Y(MAX);
+        #if   CORE_DIAG(XY, X, MIN)
+          PROCESS_CORE_ENDSTOP(X,MIN,Y,MAX);
+        #elif CORE_DIAG(XY, X, MAX)
+          PROCESS_CORE_ENDSTOP(X,MAX,Y,MAX);
+        #elif CORE_DIAG(YZ, Z, MIN)
+          PROCESS_CORE_ENDSTOP(Z,MIN,Y,MAX);
+        #elif CORE_DIAG(YZ, Z, MAX)
+          PROCESS_CORE_ENDSTOP(Z,MAX,Y,MAX);
+        #endif
       #endif
     }
   }
@@ -777,6 +822,15 @@ void Endstops::update() {
         if ( TERN1(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN, z_probe_enabled)
           && TERN1(HAS_CUSTOM_PROBE_PIN, !z_probe_enabled)
         ) PROCESS_ENDSTOP_Z(MIN);
+        #if   CORE_DIAG(XZ, X, MIN)
+          PROCESS_CORE_ENDSTOP(X,MIN,Z,MIN);
+        #elif CORE_DIAG(XZ, X, MAX)
+          PROCESS_CORE_ENDSTOP(X,MAX,Z,MIN);
+        #elif CORE_DIAG(YZ, Y, MIN)
+          PROCESS_CORE_ENDSTOP(Y,MIN,Z,MIN);
+        #elif CORE_DIAG(YZ, Y, MAX)
+          PROCESS_CORE_ENDSTOP(Y,MAX,Z,MIN);
+        #endif
       #endif
 
       // When closing the gap check the enabled probe
@@ -791,6 +845,15 @@ void Endstops::update() {
         #elif !HAS_CUSTOM_PROBE_PIN || Z_MAX_PIN != Z_MIN_PROBE_PIN  // No probe or probe is Z_MIN || Probe is not Z_MAX
           PROCESS_ENDSTOP(Z, MAX);
         #endif
+        #if   CORE_DIAG(XZ, X, MIN)
+          PROCESS_CORE_ENDSTOP(X,MIN,Z,MAX);
+        #elif CORE_DIAG(XZ, X, MAX)
+          PROCESS_CORE_ENDSTOP(X,MAX,Z,MAX);
+        #elif CORE_DIAG(YZ, Y, MIN)
+          PROCESS_CORE_ENDSTOP(Y,MIN,Z,MAX);
+        #elif CORE_DIAG(YZ, Y, MAX)
+          PROCESS_CORE_ENDSTOP(Y,MAX,Z,MAX);
+        #endif
       #endif
     }
   }

commit 6ae7a40f994ffb2d2be10a041bdfe89f4585db91
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 14 13:00:47 2020 -0500

    CoreXY sensorless homing (#17972)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 092043b59c..5cfd7771a0 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -742,7 +742,8 @@ void Endstops::update() {
     }
   #endif
 
-  // Now, we must signal, after validation, if an endstop limit is pressed or not
+  // Signal, after validation, if an endstop limit is pressed or not
+
   if (stepper.axis_is_moving(X_AXIS)) {
     if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
       #if HAS_X_MIN || (X_SPI_SENSORLESS && X_HOME_DIR < 0)
@@ -804,19 +805,37 @@ void Endstops::update() {
   bool Endstops::tmc_spi_homing_check() {
     bool hit = false;
     #if X_SPI_SENSORLESS
-      if (tmc_spi_homing.x && stepperX.test_stall_status()) {
+      if (tmc_spi_homing.x && (stepperX.test_stall_status()
+        #if CORE_IS_XY && Y_SPI_SENSORLESS
+          || stepperY.test_stall_status()
+        #elif CORE_IS_XZ && Z_SPI_SENSORLESS
+          || stepperZ.test_stall_status()
+        #endif
+      )) {
         SBI(live_state, X_STOP);
         hit = true;
       }
     #endif
     #if Y_SPI_SENSORLESS
-      if (tmc_spi_homing.y && stepperY.test_stall_status()) {
+      if (tmc_spi_homing.y && (stepperY.test_stall_status()
+        #if CORE_IS_XY && X_SPI_SENSORLESS
+          || stepperX.test_stall_status()
+        #elif CORE_IS_YZ && Z_SPI_SENSORLESS
+          || stepperZ.test_stall_status()
+        #endif
+      )) {
         SBI(live_state, Y_STOP);
         hit = true;
       }
     #endif
     #if Z_SPI_SENSORLESS
-      if (tmc_spi_homing.z && stepperZ.test_stall_status()) {
+      if (tmc_spi_homing.z && (stepperZ.test_stall_status()
+        #if CORE_IS_XZ && X_SPI_SENSORLESS
+          || stepperX.test_stall_status()
+        #elif CORE_IS_YZ && Y_SPI_SENSORLESS
+          || stepperY.test_stall_status()
+        #endif
+      )) {
         SBI(live_state, Z_STOP);
         hit = true;
       }

commit 6d90d1e1f552dca5e21bc61b676b8e8ce731b280
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 22 16:35:03 2020 -0500

    Apply TERN to compact code (#17619)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index f55d56b959..092043b59c 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -276,27 +276,17 @@ void Endstops::init() {
     #endif
   #endif
 
-  #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-    setup_endstop_interrupts();
-  #endif
+  TERN_(ENDSTOP_INTERRUPTS_FEATURE, setup_endstop_interrupts());
 
   // Enable endstops
-  enable_globally(
-    #if ENABLED(ENDSTOPS_ALWAYS_ON_DEFAULT)
-      true
-    #else
-      false
-    #endif
-  );
+  enable_globally(ENABLED(ENDSTOPS_ALWAYS_ON_DEFAULT));
 
 } // Endstops::init
 
 // Called at ~1KHz from Temperature ISR: Poll endstop state if required
 void Endstops::poll() {
 
-  #if ENABLED(PINS_DEBUGGING)
-    run_monitor();  // report changes in endstop status
-  #endif
+  TERN_(PINS_DEBUGGING, run_monitor()); // Report changes in endstop status
 
   #if DISABLED(ENDSTOP_INTERRUPTS_FEATURE)
     update();
@@ -341,14 +331,9 @@ void Endstops::not_homing() {
 void Endstops::resync() {
   if (!abort_enabled()) return;     // If endstops/probes are disabled the loop below can hang
 
-  #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-    update();
-  #else
-    safe_delay(2);  // Wait for Temperature ISR to run at least once (runs at 1KHz)
-  #endif
-  #if ENDSTOP_NOISE_THRESHOLD
-    while (endstop_poll_count) safe_delay(1);
-  #endif
+  // Wait for Temperature ISR to run at least once (runs at 1KHz)
+  TERN(ENDSTOP_INTERRUPTS_FEATURE, update(), safe_delay(2));
+  while (TERN0(ENDSTOP_NOISE_THRESHOLD, endstop_poll_count)) safe_delay(1);
 }
 
 #if ENABLED(PINS_DEBUGGING)
@@ -397,9 +382,7 @@ void Endstops::event_handler() {
     #endif
     SERIAL_EOL();
 
-    #if HAS_SPI_LCD
-      ui.status_printf_P(0, PSTR(S_FMT " %c %c %c %c"), GET_TEXT(MSG_LCD_ENDSTOPS), chrX, chrY, chrZ, chrP);
-    #endif
+    TERN_(HAS_SPI_LCD, ui.status_printf_P(0, PSTR(S_FMT " %c %c %c %c"), GET_TEXT(MSG_LCD_ENDSTOPS), chrX, chrY, chrZ, chrP));
 
     #if BOTH(SD_ABORT_ON_ENDSTOP_HIT, SDSUPPORT)
       if (planner.abort_on_endstop_hit) {
@@ -420,9 +403,7 @@ static void print_es_state(const bool is_hit, PGM_P const label=nullptr) {
 }
 
 void _O2 Endstops::report_states() {
-  #if ENABLED(BLTOUCH)
-    bltouch._set_SW_mode();
-  #endif
+  TERN_(BLTOUCH, bltouch._set_SW_mode());
   SERIAL_ECHOLNPGM(STR_M119_REPORT);
   #define ES_REPORT(S) print_es_state(READ(S##_PIN) != S##_ENDSTOP_INVERTING, PSTR(STR_##S))
   #if HAS_X_MIN
@@ -494,13 +475,9 @@ void _O2 Endstops::report_states() {
       #undef _CASE_RUNOUT
     #endif
   #endif
-  #if ENABLED(BLTOUCH)
-    bltouch._reset_SW_mode();
-  #endif
 
-  #if ENABLED(JOYSTICK_DEBUG)
-    joystick.report();
-  #endif
+  TERN_(BLTOUCH, bltouch._reset_SW_mode());
+  TERN_(JOYSTICK_DEBUG, joystick.report());
 
 } // Endstops::report_states
 
@@ -796,12 +773,8 @@ void Endstops::update() {
     if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
 
       #if HAS_Z_MIN || (Z_SPI_SENSORLESS && Z_HOME_DIR < 0)
-        if (true
-          #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
-            && z_probe_enabled
-          #elif HAS_CUSTOM_PROBE_PIN
-            && !z_probe_enabled
-          #endif
+        if ( TERN1(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN, z_probe_enabled)
+          && TERN1(HAS_CUSTOM_PROBE_PIN, !z_probe_enabled)
         ) PROCESS_ENDSTOP_Z(MIN);
       #endif
 
@@ -852,15 +825,9 @@ void Endstops::update() {
   }
 
   void Endstops::clear_endstop_state() {
-    #if X_SPI_SENSORLESS
-      CBI(live_state, X_STOP);
-    #endif
-    #if Y_SPI_SENSORLESS
-      CBI(live_state, Y_STOP);
-    #endif
-    #if Z_SPI_SENSORLESS
-      CBI(live_state, Z_STOP);
-    #endif
+    TERN_(X_SPI_SENSORLESS, CBI(live_state, X_STOP));
+    TERN_(Y_SPI_SENSORLESS, CBI(live_state, Y_STOP));
+    TERN_(Z_SPI_SENSORLESS, CBI(live_state, Z_STOP));
   }
 
 #endif // SPI_ENDSTOPS

commit 22da1b2b310158ae3362c54f2534f5f5af30fa83
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 13 14:53:21 2020 -0500

    Rename some "kill" messages

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 1c8384cc53..f55d56b959 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -325,7 +325,7 @@ void Endstops::not_homing() {
   // If the last move failed to trigger an endstop, call kill
   void Endstops::validate_homing_move() {
     if (trigger_state()) hit_on_purpose();
-    else kill(GET_TEXT(MSG_LCD_HOMING_FAILED));
+    else kill(GET_TEXT(MSG_KILL_HOMING_FAILED));
   }
 #endif
 

commit 118bd2f8b2a1f81884cb55a8fc00b708a51aa15b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 13 23:18:16 2020 -0500

    Apply loop shorthand macros (#17159)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 58de4a8d05..1c8384cc53 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -481,7 +481,7 @@ void _O2 Endstops::report_states() {
       print_es_state(READ(FIL_RUNOUT_PIN) != FIL_RUNOUT_INVERTING, PSTR(STR_FILAMENT_RUNOUT_SENSOR));
     #else
       #define _CASE_RUNOUT(N) case N: pin = FIL_RUNOUT##N##_PIN; break;
-      for (uint8_t i = 1; i <= NUM_RUNOUT_SENSORS; i++) {
+      LOOP_S_LE_N(i, 1, NUM_RUNOUT_SENSORS) {
         pin_t pin;
         switch (i) {
           default: continue;

commit 5ebba4b19fbfc4126e092cc382d0f878e3234f77
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Feb 26 04:11:03 2020 -0600

    More serial strings

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 018f471c34..58de4a8d05 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -424,7 +424,7 @@ void _O2 Endstops::report_states() {
     bltouch._set_SW_mode();
   #endif
   SERIAL_ECHOLNPGM(STR_M119_REPORT);
-  #define ES_REPORT(S) print_es_state(READ(S##_PIN) != S##_ENDSTOP_INVERTING, PSTR(MSG_##S))
+  #define ES_REPORT(S) print_es_state(READ(S##_PIN) != S##_ENDSTOP_INVERTING, PSTR(STR_##S))
   #if HAS_X_MIN
     ES_REPORT(X_MIN);
   #endif

commit e78f607ef33044eecde744e77beea87532817c47
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Feb 26 03:02:03 2020 -0600

    Use a STR_ prefix for non-translated strings

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index d291f972d3..018f471c34 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -386,7 +386,7 @@ void Endstops::event_handler() {
     #define ENDSTOP_HIT_TEST_Z() _ENDSTOP_HIT_TEST(Z,'Z')
 
     SERIAL_ECHO_START();
-    SERIAL_ECHOPGM(MSG_ENDSTOPS_HIT);
+    SERIAL_ECHOPGM(STR_ENDSTOPS_HIT);
     ENDSTOP_HIT_TEST_X();
     ENDSTOP_HIT_TEST_Y();
     ENDSTOP_HIT_TEST_Z();
@@ -415,7 +415,7 @@ void Endstops::event_handler() {
 static void print_es_state(const bool is_hit, PGM_P const label=nullptr) {
   if (label) serialprintPGM(label);
   SERIAL_ECHOPGM(": ");
-  serialprintPGM(is_hit ? PSTR(MSG_ENDSTOP_HIT) : PSTR(MSG_ENDSTOP_OPEN));
+  serialprintPGM(is_hit ? PSTR(STR_ENDSTOP_HIT) : PSTR(STR_ENDSTOP_OPEN));
   SERIAL_EOL();
 }
 
@@ -423,7 +423,7 @@ void _O2 Endstops::report_states() {
   #if ENABLED(BLTOUCH)
     bltouch._set_SW_mode();
   #endif
-  SERIAL_ECHOLNPGM(MSG_M119_REPORT);
+  SERIAL_ECHOLNPGM(STR_M119_REPORT);
   #define ES_REPORT(S) print_es_state(READ(S##_PIN) != S##_ENDSTOP_INVERTING, PSTR(MSG_##S))
   #if HAS_X_MIN
     ES_REPORT(X_MIN);
@@ -474,11 +474,11 @@ void _O2 Endstops::report_states() {
     ES_REPORT(Z4_MAX);
   #endif
   #if HAS_CUSTOM_PROBE_PIN
-    print_es_state(READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING, PSTR(MSG_Z_PROBE));
+    print_es_state(READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING, PSTR(STR_Z_PROBE));
   #endif
   #if HAS_FILAMENT_SENSOR
     #if NUM_RUNOUT_SENSORS == 1
-      print_es_state(READ(FIL_RUNOUT_PIN) != FIL_RUNOUT_INVERTING, PSTR(MSG_FILAMENT_RUNOUT_SENSOR));
+      print_es_state(READ(FIL_RUNOUT_PIN) != FIL_RUNOUT_INVERTING, PSTR(STR_FILAMENT_RUNOUT_SENSOR));
     #else
       #define _CASE_RUNOUT(N) case N: pin = FIL_RUNOUT##N##_PIN; break;
       for (uint8_t i = 1; i <= NUM_RUNOUT_SENSORS; i++) {
@@ -487,7 +487,7 @@ void _O2 Endstops::report_states() {
           default: continue;
           REPEAT_S(1, INCREMENT(NUM_RUNOUT_SENSORS), _CASE_RUNOUT)
         }
-        SERIAL_ECHOPGM(MSG_FILAMENT_RUNOUT_SENSOR);
+        SERIAL_ECHOPGM(STR_FILAMENT_RUNOUT_SENSOR);
         if (i > 1) SERIAL_CHAR(' ', '0' + i);
         print_es_state(extDigitalRead(pin) != FIL_RUNOUT_INVERTING);
       }

commit 5071fe82ab221627ef10cf4125896e3d2585993a
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Feb 25 22:18:14 2020 -0600

    Ensure proper SD print completion (#16967)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 1491d881d5..d291f972d3 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -403,7 +403,7 @@ void Endstops::event_handler() {
 
     #if BOTH(SD_ABORT_ON_ENDSTOP_HIT, SDSUPPORT)
       if (planner.abort_on_endstop_hit) {
-        card.stopSDPrint();
+        card.endFilePrint();
         quickstop_stepper();
         thermalManager.disable_all_heaters();
         print_job_timer.stop();

commit 3a3429b1ef2fdaf1e793fff17a89b069e3384fbc
Author: Robert Stein <robert.stein@requisis.com>
Date:   Thu Feb 6 22:28:46 2020 +0100

    Fix probe with multi-endstops (#16793)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index f3f73f3da1..1491d881d5 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -529,11 +529,11 @@ void Endstops::update() {
   // With Dual X, endstops are only checked in the homing direction for the active extruder
   #if ENABLED(DUAL_X_CARRIAGE)
     #define E0_ACTIVE stepper.movement_extruder() == 0
-    #define X_MIN_TEST ((X_HOME_DIR < 0 && E0_ACTIVE) || (X2_HOME_DIR < 0 && !E0_ACTIVE))
-    #define X_MAX_TEST ((X_HOME_DIR > 0 && E0_ACTIVE) || (X2_HOME_DIR > 0 && !E0_ACTIVE))
+    #define X_MIN_TEST() ((X_HOME_DIR < 0 && E0_ACTIVE) || (X2_HOME_DIR < 0 && !E0_ACTIVE))
+    #define X_MAX_TEST() ((X_HOME_DIR > 0 && E0_ACTIVE) || (X2_HOME_DIR > 0 && !E0_ACTIVE))
   #else
-    #define X_MIN_TEST true
-    #define X_MAX_TEST true
+    #define X_MIN_TEST() true
+    #define X_MAX_TEST() true
   #endif
 
   // Use HEAD for core axes, AXIS for others
@@ -690,7 +690,7 @@ void Endstops::update() {
   #define _ENDSTOP_HIT(AXIS, MINMAX) SBI(hit_state, _ENDSTOP(AXIS, MINMAX))
 
   // Call the endstop triggered routine for single endstops
-  #define PROCESS_ENDSTOP(AXIS,MINMAX) do { \
+  #define PROCESS_ENDSTOP(AXIS, MINMAX) do { \
     if (TEST_ENDSTOP(_ENDSTOP(AXIS, MINMAX))) { \
       _ENDSTOP_HIT(AXIS, MINMAX); \
       planner.endstop_triggered(_AXIS(AXIS)); \
@@ -698,36 +698,58 @@ void Endstops::update() {
   }while(0)
 
   // Call the endstop triggered routine for dual endstops
-  #define PROCESS_DUAL_ENDSTOP(AXIS1, AXIS2, MINMAX) do { \
-    const byte dual_hit = TEST_ENDSTOP(_ENDSTOP(AXIS1, MINMAX)) | (TEST_ENDSTOP(_ENDSTOP(AXIS2, MINMAX)) << 1); \
+  #define PROCESS_DUAL_ENDSTOP(A, MINMAX) do { \
+    const byte dual_hit = TEST_ENDSTOP(_ENDSTOP(A, MINMAX)) | (TEST_ENDSTOP(_ENDSTOP(A##2, MINMAX)) << 1); \
     if (dual_hit) { \
-      _ENDSTOP_HIT(AXIS1, MINMAX); \
+      _ENDSTOP_HIT(A, MINMAX); \
       /* if not performing home or if both endstops were trigged during homing... */ \
       if (!stepper.separate_multi_axis || dual_hit == 0b11) \
-        planner.endstop_triggered(_AXIS(AXIS1)); \
+        planner.endstop_triggered(_AXIS(A)); \
     } \
   }while(0)
 
-  #define PROCESS_TRIPLE_ENDSTOP(AXIS1, AXIS2, AXIS3, MINMAX) do { \
-    const byte triple_hit = TEST_ENDSTOP(_ENDSTOP(AXIS1, MINMAX)) | (TEST_ENDSTOP(_ENDSTOP(AXIS2, MINMAX)) << 1) | (TEST_ENDSTOP(_ENDSTOP(AXIS3, MINMAX)) << 2); \
+  #define PROCESS_TRIPLE_ENDSTOP(A, MINMAX) do { \
+    const byte triple_hit = TEST_ENDSTOP(_ENDSTOP(A, MINMAX)) | (TEST_ENDSTOP(_ENDSTOP(A##2, MINMAX)) << 1) | (TEST_ENDSTOP(_ENDSTOP(A##3, MINMAX)) << 2); \
     if (triple_hit) { \
-      _ENDSTOP_HIT(AXIS1, MINMAX); \
+      _ENDSTOP_HIT(A, MINMAX); \
       /* if not performing home or if both endstops were trigged during homing... */ \
       if (!stepper.separate_multi_axis || triple_hit == 0b111) \
-        planner.endstop_triggered(_AXIS(AXIS1)); \
+        planner.endstop_triggered(_AXIS(A)); \
     } \
   }while(0)
 
-  #define PROCESS_QUAD_ENDSTOP(AXIS1, AXIS2, AXIS3, AXIS4, MINMAX) do { \
-    const byte quad_hit = TEST_ENDSTOP(_ENDSTOP(AXIS1, MINMAX)) | (TEST_ENDSTOP(_ENDSTOP(AXIS2, MINMAX)) << 1) | (TEST_ENDSTOP(_ENDSTOP(AXIS3, MINMAX)) << 2) | (TEST_ENDSTOP(_ENDSTOP(AXIS4, MINMAX)) << 3); \
+  #define PROCESS_QUAD_ENDSTOP(A, MINMAX) do { \
+    const byte quad_hit = TEST_ENDSTOP(_ENDSTOP(A, MINMAX)) | (TEST_ENDSTOP(_ENDSTOP(A##2, MINMAX)) << 1) | (TEST_ENDSTOP(_ENDSTOP(A##3, MINMAX)) << 2) | (TEST_ENDSTOP(_ENDSTOP(A##4, MINMAX)) << 3); \
     if (quad_hit) { \
-      _ENDSTOP_HIT(AXIS1, MINMAX); \
+      _ENDSTOP_HIT(A, MINMAX); \
       /* if not performing home or if both endstops were trigged during homing... */ \
       if (!stepper.separate_multi_axis || quad_hit == 0b1111) \
-        planner.endstop_triggered(_AXIS(AXIS1)); \
+        planner.endstop_triggered(_AXIS(A)); \
     } \
   }while(0)
 
+  #if ENABLED(X_DUAL_ENDSTOPS)
+    #define PROCESS_ENDSTOP_X(MINMAX) PROCESS_DUAL_ENDSTOP(X, MINMAX)
+  #else
+    #define PROCESS_ENDSTOP_X(MINMAX) if (X_##MINMAX##_TEST()) PROCESS_ENDSTOP(X, MINMAX)
+  #endif
+
+  #if ENABLED(Y_DUAL_ENDSTOPS)
+    #define PROCESS_ENDSTOP_Y(MINMAX) PROCESS_DUAL_ENDSTOP(Y, MINMAX)
+  #else
+    #define PROCESS_ENDSTOP_Y(MINMAX) PROCESS_ENDSTOP(Y, MINMAX)
+  #endif
+
+  #if DISABLED(Z_MULTI_ENDSTOPS)
+    #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_ENDSTOP(Z, MINMAX)
+  #elif NUM_Z_STEPPER_DRIVERS == 4
+    #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_QUAD_ENDSTOP(Z, MINMAX)
+  #elif NUM_Z_STEPPER_DRIVERS == 3
+    #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_TRIPLE_ENDSTOP(Z, MINMAX)
+  #else
+    #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_DUAL_ENDSTOP(Z, MINMAX)
+  #endif
+
   #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && !(CORE_IS_XY || CORE_IS_XZ)
     #if ENABLED(G38_PROBE_AWAY)
       #define _G38_OPEN_STATE (G38_move >= 4)
@@ -747,20 +769,12 @@ void Endstops::update() {
   if (stepper.axis_is_moving(X_AXIS)) {
     if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
       #if HAS_X_MIN || (X_SPI_SENSORLESS && X_HOME_DIR < 0)
-        #if ENABLED(X_DUAL_ENDSTOPS)
-          PROCESS_DUAL_ENDSTOP(X, X2, MIN);
-        #else
-          if (X_MIN_TEST) PROCESS_ENDSTOP(X, MIN);
-        #endif
+        PROCESS_ENDSTOP_X(MIN);
       #endif
     }
     else { // +direction
       #if HAS_X_MAX || (X_SPI_SENSORLESS && X_HOME_DIR > 0)
-        #if ENABLED(X_DUAL_ENDSTOPS)
-          PROCESS_DUAL_ENDSTOP(X, X2, MAX);
-        #else
-          if (X_MAX_TEST) PROCESS_ENDSTOP(X, MAX);
-        #endif
+        PROCESS_ENDSTOP_X(MAX);
       #endif
     }
   }
@@ -768,44 +782,27 @@ void Endstops::update() {
   if (stepper.axis_is_moving(Y_AXIS)) {
     if (stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
       #if HAS_Y_MIN || (Y_SPI_SENSORLESS && Y_HOME_DIR < 0)
-        #if ENABLED(Y_DUAL_ENDSTOPS)
-          PROCESS_DUAL_ENDSTOP(Y, Y2, MIN);
-        #else
-          PROCESS_ENDSTOP(Y, MIN);
-        #endif
+        PROCESS_ENDSTOP_Y(MIN);
       #endif
     }
     else { // +direction
       #if HAS_Y_MAX || (Y_SPI_SENSORLESS && Y_HOME_DIR > 0)
-        #if ENABLED(Y_DUAL_ENDSTOPS)
-          PROCESS_DUAL_ENDSTOP(Y, Y2, MAX);
-        #else
-          PROCESS_ENDSTOP(Y, MAX);
-        #endif
+        PROCESS_ENDSTOP_Y(MAX);
       #endif
     }
   }
 
   if (stepper.axis_is_moving(Z_AXIS)) {
     if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
+
       #if HAS_Z_MIN || (Z_SPI_SENSORLESS && Z_HOME_DIR < 0)
-        #if ENABLED(Z_MULTI_ENDSTOPS)
-          #if NUM_Z_STEPPER_DRIVERS == 4
-            PROCESS_QUAD_ENDSTOP(Z, Z2, Z3, Z4, MIN);
-          #elif NUM_Z_STEPPER_DRIVERS == 3
-            PROCESS_TRIPLE_ENDSTOP(Z, Z2, Z3, MIN);
-          #else
-            PROCESS_DUAL_ENDSTOP(Z, Z2, MIN);
-          #endif
-        #else
+        if (true
           #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
-            if (z_probe_enabled) PROCESS_ENDSTOP(Z, MIN);
+            && z_probe_enabled
           #elif HAS_CUSTOM_PROBE_PIN
-            if (!z_probe_enabled) PROCESS_ENDSTOP(Z, MIN);
-          #else
-            PROCESS_ENDSTOP(Z, MIN);
+            && !z_probe_enabled
           #endif
-        #endif
+        ) PROCESS_ENDSTOP_Z(MIN);
       #endif
 
       // When closing the gap check the enabled probe
@@ -816,16 +813,8 @@ void Endstops::update() {
     else { // Z +direction. Gantry up, bed down.
       #if HAS_Z_MAX || (Z_SPI_SENSORLESS && Z_HOME_DIR > 0)
         #if ENABLED(Z_MULTI_ENDSTOPS)
-          #if NUM_Z_STEPPER_DRIVERS == 4
-            PROCESS_QUAD_ENDSTOP(Z, Z2, Z3, Z4, MAX);
-          #elif NUM_Z_STEPPER_DRIVERS == 3
-            PROCESS_TRIPLE_ENDSTOP(Z, Z2, Z3, MAX);
-          #else
-            PROCESS_DUAL_ENDSTOP(Z, Z2, MAX);
-          #endif
-        #elif !HAS_CUSTOM_PROBE_PIN || Z_MAX_PIN != Z_MIN_PROBE_PIN
-          // If this pin is not hijacked for the bed probe
-          // then it belongs to the Z endstop
+          PROCESS_ENDSTOP_Z(MAX);
+        #elif !HAS_CUSTOM_PROBE_PIN || Z_MAX_PIN != Z_MIN_PROBE_PIN  // No probe or probe is Z_MIN || Probe is not Z_MAX
           PROCESS_ENDSTOP(Z, MAX);
         #endif
       #endif

commit 7bf2190f03228666fdec3e1f8f0d8548a1ab2e95
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 4 08:32:43 2020 -0600

    Fix CALIBRATION_GCODE pin handling

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 47ccc5d567..f3f73f3da1 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -256,7 +256,7 @@ void Endstops::init() {
     #endif
   #endif
 
-  #if HAS_CALIBRATION_PIN
+  #if PIN_EXISTS(CALIBRATION)
     #if ENABLED(CALIBRATION_PIN_PULLUP)
       SET_INPUT_PULLUP(CALIBRATION_PIN);
     #elif ENABLED(CALIBRATION_PIN_PULLDOWN)

commit bfad23d3e2e590b257ebe4317d7b14cc2dd3435c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 3 08:00:57 2020 -0600

    (c) 2020

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 8eaab9bd55..47ccc5d567 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -1,6 +1,6 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm

commit 4716dac8742e536dde12773b579407fb1ae1cb66
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Feb 1 21:00:53 2020 -0600

    Apply REPEAT, RREPEAT, and loop macros (#16757)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 7d8e270fed..8eaab9bd55 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -480,35 +480,18 @@ void _O2 Endstops::report_states() {
     #if NUM_RUNOUT_SENSORS == 1
       print_es_state(READ(FIL_RUNOUT_PIN) != FIL_RUNOUT_INVERTING, PSTR(MSG_FILAMENT_RUNOUT_SENSOR));
     #else
+      #define _CASE_RUNOUT(N) case N: pin = FIL_RUNOUT##N##_PIN; break;
       for (uint8_t i = 1; i <= NUM_RUNOUT_SENSORS; i++) {
         pin_t pin;
         switch (i) {
           default: continue;
-          case 1: pin = FIL_RUNOUT_PIN; break;
-          case 2: pin = FIL_RUNOUT2_PIN; break;
-          #if NUM_RUNOUT_SENSORS >= 3
-            case 3: pin = FIL_RUNOUT3_PIN; break;
-            #if NUM_RUNOUT_SENSORS >= 4
-              case 4: pin = FIL_RUNOUT4_PIN; break;
-              #if NUM_RUNOUT_SENSORS >= 5
-                case 5: pin = FIL_RUNOUT5_PIN; break;
-                #if NUM_RUNOUT_SENSORS >= 6
-                  case 6: pin = FIL_RUNOUT6_PIN; break;
-                  #if NUM_RUNOUT_SENSORS >= 7
-                    case 7: pin = FIL_RUNOUT7_PIN; break;
-                    #if NUM_RUNOUT_SENSORS >= 8
-                      case 8: pin = FIL_RUNOUT8_PIN; break;
-                    #endif
-                  #endif
-                #endif
-              #endif
-            #endif
-          #endif
+          REPEAT_S(1, INCREMENT(NUM_RUNOUT_SENSORS), _CASE_RUNOUT)
         }
         SERIAL_ECHOPGM(MSG_FILAMENT_RUNOUT_SENSOR);
         if (i > 1) SERIAL_CHAR(' ', '0' + i);
         print_es_state(extDigitalRead(pin) != FIL_RUNOUT_INVERTING);
       }
+      #undef _CASE_RUNOUT
     #endif
   #endif
   #if ENABLED(BLTOUCH)

commit 248b7dfa591a34a8aa1c6960944e1a3a468ad1de
Author: yangwenxiong <46896566+yangwenxiong@users.noreply.github.com>
Date:   Sat Jan 25 16:13:39 2020 +0800

    BigTreeTech GTR V1.0 / Support 8 extruders, heaters, temp sensors, fans (#16595)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 27d5fb6fc7..7d8e270fed 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -486,14 +486,20 @@ void _O2 Endstops::report_states() {
           default: continue;
           case 1: pin = FIL_RUNOUT_PIN; break;
           case 2: pin = FIL_RUNOUT2_PIN; break;
-          #if NUM_RUNOUT_SENSORS > 2
+          #if NUM_RUNOUT_SENSORS >= 3
             case 3: pin = FIL_RUNOUT3_PIN; break;
-            #if NUM_RUNOUT_SENSORS > 3
+            #if NUM_RUNOUT_SENSORS >= 4
               case 4: pin = FIL_RUNOUT4_PIN; break;
-              #if NUM_RUNOUT_SENSORS > 4
+              #if NUM_RUNOUT_SENSORS >= 5
                 case 5: pin = FIL_RUNOUT5_PIN; break;
-                #if NUM_RUNOUT_SENSORS > 5
+                #if NUM_RUNOUT_SENSORS >= 6
                   case 6: pin = FIL_RUNOUT6_PIN; break;
+                  #if NUM_RUNOUT_SENSORS >= 7
+                    case 7: pin = FIL_RUNOUT7_PIN; break;
+                    #if NUM_RUNOUT_SENSORS >= 8
+                      case 8: pin = FIL_RUNOUT8_PIN; break;
+                    #endif
+                  #endif
                 #endif
               #endif
             #endif

commit 0fcf2b1110d9f0d362e5aab9cc73d963710e9865
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Mon Jan 20 00:35:07 2020 -0500

    Quad Z stepper support (#16277)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index a9b5cca227..27d5fb6fc7 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -73,11 +73,14 @@ Endstops::esbits_t Endstops::live_state = 0;
 #if ENABLED(Y_DUAL_ENDSTOPS)
   float Endstops::y2_endstop_adj;
 #endif
-#if Z_MULTI_ENDSTOPS
+#if ENABLED(Z_MULTI_ENDSTOPS)
   float Endstops::z2_endstop_adj;
-#endif
-#if ENABLED(Z_TRIPLE_ENDSTOPS)
-  float Endstops::z3_endstop_adj;
+  #if NUM_Z_STEPPER_DRIVERS >= 3
+    float Endstops::z3_endstop_adj;
+    #if NUM_Z_STEPPER_DRIVERS >= 4
+      float Endstops::z4_endstop_adj;
+    #endif
+  #endif
 #endif
 
 #if ENABLED(SPI_ENDSTOPS)
@@ -163,6 +166,16 @@ void Endstops::init() {
     #endif
   #endif
 
+  #if HAS_Z4_MIN
+    #if ENABLED(ENDSTOPPULLUP_ZMIN)
+      SET_INPUT_PULLUP(Z4_MIN_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_ZMIN)
+      SET_INPUT_PULLDOWN(Z4_MIN_PIN);
+    #else
+      SET_INPUT(Z4_MIN_PIN);
+    #endif
+  #endif
+
   #if HAS_X_MAX
     #if ENABLED(ENDSTOPPULLUP_XMAX)
       SET_INPUT_PULLUP(X_MAX_PIN);
@@ -233,6 +246,16 @@ void Endstops::init() {
     #endif
   #endif
 
+  #if HAS_Z4_MAX
+    #if ENABLED(ENDSTOPPULLUP_ZMAX)
+      SET_INPUT_PULLUP(Z4_MAX_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_ZMAX)
+      SET_INPUT_PULLDOWN(Z4_MAX_PIN);
+    #else
+      SET_INPUT(Z4_MAX_PIN);
+    #endif
+  #endif
+
   #if HAS_CALIBRATION_PIN
     #if ENABLED(CALIBRATION_PIN_PULLUP)
       SET_INPUT_PULLUP(CALIBRATION_PIN);
@@ -435,6 +458,9 @@ void _O2 Endstops::report_states() {
   #if HAS_Z3_MIN
     ES_REPORT(Z3_MIN);
   #endif
+  #if HAS_Z4_MIN
+    ES_REPORT(Z4_MIN);
+  #endif
   #if HAS_Z_MAX
     ES_REPORT(Z_MAX);
   #endif
@@ -444,6 +470,9 @@ void _O2 Endstops::report_states() {
   #if HAS_Z3_MAX
     ES_REPORT(Z3_MAX);
   #endif
+  #if HAS_Z4_MAX
+    ES_REPORT(Z4_MAX);
+  #endif
   #if HAS_CUSTOM_PROBE_PIN
     print_es_state(READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING, PSTR(MSG_Z_PROBE));
   #endif
@@ -584,19 +613,26 @@ void Endstops::update() {
 
   #if HAS_Z_MIN && !Z_SPI_SENSORLESS
     UPDATE_ENDSTOP_BIT(Z, MIN);
-    #if Z_MULTI_ENDSTOPS
+    #if ENABLED(Z_MULTI_ENDSTOPS)
       #if HAS_Z2_MIN
         UPDATE_ENDSTOP_BIT(Z2, MIN);
       #else
         COPY_LIVE_STATE(Z_MIN, Z2_MIN);
       #endif
-      #if ENABLED(Z_TRIPLE_ENDSTOPS)
+      #if NUM_Z_STEPPER_DRIVERS >= 3
         #if HAS_Z3_MIN
           UPDATE_ENDSTOP_BIT(Z3, MIN);
         #else
           COPY_LIVE_STATE(Z_MIN, Z3_MIN);
         #endif
       #endif
+      #if NUM_Z_STEPPER_DRIVERS >= 4
+        #if HAS_Z4_MIN
+          UPDATE_ENDSTOP_BIT(Z4, MIN);
+        #else
+          COPY_LIVE_STATE(Z_MIN, Z4_MIN);
+        #endif
+      #endif
     #endif
   #endif
 
@@ -607,20 +643,27 @@ void Endstops::update() {
 
   #if HAS_Z_MAX && !Z_SPI_SENSORLESS
     // Check both Z dual endstops
-    #if Z_MULTI_ENDSTOPS
+    #if ENABLED(Z_MULTI_ENDSTOPS)
       UPDATE_ENDSTOP_BIT(Z, MAX);
       #if HAS_Z2_MAX
         UPDATE_ENDSTOP_BIT(Z2, MAX);
       #else
         COPY_LIVE_STATE(Z_MAX, Z2_MAX);
       #endif
-      #if ENABLED(Z_TRIPLE_ENDSTOPS)
+      #if NUM_Z_STEPPER_DRIVERS >= 3
         #if HAS_Z3_MAX
           UPDATE_ENDSTOP_BIT(Z3, MAX);
         #else
           COPY_LIVE_STATE(Z_MAX, Z3_MAX);
         #endif
       #endif
+      #if NUM_Z_STEPPER_DRIVERS >= 4
+        #if HAS_Z4_MAX
+          UPDATE_ENDSTOP_BIT(Z4, MAX);
+        #else
+          COPY_LIVE_STATE(Z_MAX, Z4_MAX);
+        #endif
+      #endif
     #elif !HAS_CUSTOM_PROBE_PIN || Z_MAX_PIN != Z_MIN_PROBE_PIN
       // If this pin isn't the bed probe it's the Z endstop
       UPDATE_ENDSTOP_BIT(Z, MAX);
@@ -686,6 +729,16 @@ void Endstops::update() {
     } \
   }while(0)
 
+  #define PROCESS_QUAD_ENDSTOP(AXIS1, AXIS2, AXIS3, AXIS4, MINMAX) do { \
+    const byte quad_hit = TEST_ENDSTOP(_ENDSTOP(AXIS1, MINMAX)) | (TEST_ENDSTOP(_ENDSTOP(AXIS2, MINMAX)) << 1) | (TEST_ENDSTOP(_ENDSTOP(AXIS3, MINMAX)) << 2) | (TEST_ENDSTOP(_ENDSTOP(AXIS4, MINMAX)) << 3); \
+    if (quad_hit) { \
+      _ENDSTOP_HIT(AXIS1, MINMAX); \
+      /* if not performing home or if both endstops were trigged during homing... */ \
+      if (!stepper.separate_multi_axis || quad_hit == 0b1111) \
+        planner.endstop_triggered(_AXIS(AXIS1)); \
+    } \
+  }while(0)
+
   #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && !(CORE_IS_XY || CORE_IS_XZ)
     #if ENABLED(G38_PROBE_AWAY)
       #define _G38_OPEN_STATE (G38_move >= 4)
@@ -747,10 +800,14 @@ void Endstops::update() {
   if (stepper.axis_is_moving(Z_AXIS)) {
     if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
       #if HAS_Z_MIN || (Z_SPI_SENSORLESS && Z_HOME_DIR < 0)
-        #if ENABLED(Z_TRIPLE_ENDSTOPS)
-          PROCESS_TRIPLE_ENDSTOP(Z, Z2, Z3, MIN);
-        #elif ENABLED(Z_DUAL_ENDSTOPS)
-          PROCESS_DUAL_ENDSTOP(Z, Z2, MIN);
+        #if ENABLED(Z_MULTI_ENDSTOPS)
+          #if NUM_Z_STEPPER_DRIVERS == 4
+            PROCESS_QUAD_ENDSTOP(Z, Z2, Z3, Z4, MIN);
+          #elif NUM_Z_STEPPER_DRIVERS == 3
+            PROCESS_TRIPLE_ENDSTOP(Z, Z2, Z3, MIN);
+          #else
+            PROCESS_DUAL_ENDSTOP(Z, Z2, MIN);
+          #endif
         #else
           #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
             if (z_probe_enabled) PROCESS_ENDSTOP(Z, MIN);
@@ -769,10 +826,14 @@ void Endstops::update() {
     }
     else { // Z +direction. Gantry up, bed down.
       #if HAS_Z_MAX || (Z_SPI_SENSORLESS && Z_HOME_DIR > 0)
-        #if ENABLED(Z_TRIPLE_ENDSTOPS)
-          PROCESS_TRIPLE_ENDSTOP(Z, Z2, Z3, MAX);
-        #elif ENABLED(Z_DUAL_ENDSTOPS)
-          PROCESS_DUAL_ENDSTOP(Z, Z2, MAX);
+        #if ENABLED(Z_MULTI_ENDSTOPS)
+          #if NUM_Z_STEPPER_DRIVERS == 4
+            PROCESS_QUAD_ENDSTOP(Z, Z2, Z3, Z4, MAX);
+          #elif NUM_Z_STEPPER_DRIVERS == 3
+            PROCESS_TRIPLE_ENDSTOP(Z, Z2, Z3, MAX);
+          #else
+            PROCESS_DUAL_ENDSTOP(Z, Z2, MAX);
+          #endif
         #elif !HAS_CUSTOM_PROBE_PIN || Z_MAX_PIN != Z_MIN_PROBE_PIN
           // If this pin is not hijacked for the bed probe
           // then it belongs to the Z endstop
@@ -892,6 +953,12 @@ void Endstops::update() {
     #if HAS_Z3_MAX
       ES_GET_STATE(Z3_MAX);
     #endif
+    #if HAS_Z4_MIN
+      ES_GET_STATE(Z4_MIN);
+    #endif
+    #if HAS_Z4_MAX
+      ES_GET_STATE(Z4_MAX);
+    #endif
 
     uint16_t endstop_change = live_state_local ^ old_live_state_local;
     #define ES_REPORT_CHANGE(S) if (TEST(endstop_change, S)) SERIAL_ECHOPAIR("  " STRINGIFY(S) ":", TEST(live_state_local, S))
@@ -942,6 +1009,12 @@ void Endstops::update() {
       #if HAS_Z3_MAX
         ES_REPORT_CHANGE(Z3_MAX);
       #endif
+      #if HAS_Z4_MIN
+        ES_REPORT_CHANGE(Z4_MIN);
+      #endif
+      #if HAS_Z4_MAX
+        ES_REPORT_CHANGE(Z4_MAX);
+      #endif
       SERIAL_ECHOLNPGM("\n");
       analogWrite(pin_t(LED_PIN), local_LED_status);
       local_LED_status ^= 255;

commit 95046c90478c14d2c43bd41d30c4170dcbcdf53a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jan 8 18:31:57 2020 -0600

    Extend SERIAL_CHAR to take multiple arguments

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index f35493e86d..a9b5cca227 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -471,7 +471,7 @@ void _O2 Endstops::report_states() {
           #endif
         }
         SERIAL_ECHOPGM(MSG_FILAMENT_RUNOUT_SENSOR);
-        if (i > 1) { SERIAL_CHAR(' '); SERIAL_CHAR('0' + i); }
+        if (i > 1) SERIAL_CHAR(' ', '0' + i);
         print_es_state(extDigitalRead(pin) != FIL_RUNOUT_INVERTING);
       }
     #endif

commit d0e1166cce60381fbdad1105d13765806a525d99
Author: Dirk O. Kaar <19971886+dok-net@users.noreply.github.com>
Date:   Fri Jan 3 02:01:38 2020 +0100

    Fix Visual Micro "Arduino IDE for Visual Studio" support (#16418)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index cbe274a692..f35493e86d 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -27,7 +27,7 @@
 #include "endstops.h"
 #include "stepper.h"
 
-#include "../Marlin.h"
+#include "../MarlinCore.h"
 #include "../sd/cardreader.h"
 #include "temperature.h"
 #include "../lcd/ultralcd.h"

commit c80eda073f572705e7505a072b8229d93e400fe1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Oct 30 15:07:24 2019 -0500

    M119 => report_states

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index a5235ea058..cbe274a692 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -396,7 +396,7 @@ static void print_es_state(const bool is_hit, PGM_P const label=nullptr) {
   SERIAL_EOL();
 }
 
-void _O2 Endstops::M119() {
+void _O2 Endstops::report_states() {
   #if ENABLED(BLTOUCH)
     bltouch._set_SW_mode();
   #endif
@@ -484,7 +484,7 @@ void _O2 Endstops::M119() {
     joystick.report();
   #endif
 
-} // Endstops::M119
+} // Endstops::report_states
 
 // The following routines are called from an ISR context. It could be the temperature ISR, the
 // endstop ISR or the Stepper ISR.

commit c5713b5e981e0dc3646a10082cc061afd8e7406f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Oct 29 15:58:00 2019 -0500

    Clean Endstops::event_handler

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 24c357e2b7..a5235ea058 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -340,7 +340,9 @@ void Endstops::resync() {
 
 void Endstops::event_handler() {
   static uint8_t prev_hit_state; // = 0
-  if (hit_state && hit_state != prev_hit_state) {
+  if (hit_state == prev_hit_state) return;
+  prev_hit_state = hit_state;
+  if (hit_state) {
     #if HAS_SPI_LCD
       char chrX = ' ', chrY = ' ', chrZ = ' ', chrP = ' ';
       #define _SET_STOP_CHAR(A,C) (chr## A = C)
@@ -385,7 +387,6 @@ void Endstops::event_handler() {
       }
     #endif
   }
-  prev_hit_state = hit_state;
 }
 
 static void print_es_state(const bool is_hit, PGM_P const label=nullptr) {

commit fe4c69b64abc74bc1ee1eb16d3d3771e3afbf25d
Author: Piotr <peter_k@tut.by>
Date:   Tue Oct 15 21:28:04 2019 +0300

    Poll *all* enabled endstop pins (#15525)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index e5d07cbc65..24c357e2b7 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -243,7 +243,7 @@ void Endstops::init() {
     #endif
   #endif
 
-  #if USES_Z_MIN_PROBE_ENDSTOP
+  #if HAS_CUSTOM_PROBE_PIN
     #if ENABLED(ENDSTOPPULLUP_ZMIN_PROBE)
       SET_INPUT_PULLUP(Z_MIN_PROBE_PIN);
     #elif ENABLED(ENDSTOPPULLDOWN_ZMIN_PROBE)
@@ -366,7 +366,7 @@ void Endstops::event_handler() {
     ENDSTOP_HIT_TEST_Y();
     ENDSTOP_HIT_TEST_Z();
 
-    #if USES_Z_MIN_PROBE_ENDSTOP
+    #if HAS_CUSTOM_PROBE_PIN
       #define P_AXIS Z_AXIS
       if (TEST(hit_state, Z_MIN_PROBE)) _ENDSTOP_HIT_ECHO(P, 'P');
     #endif
@@ -443,7 +443,7 @@ void _O2 Endstops::M119() {
   #if HAS_Z3_MAX
     ES_REPORT(Z3_MAX);
   #endif
-  #if USES_Z_MIN_PROBE_ENDSTOP
+  #if HAS_CUSTOM_PROBE_PIN
     print_es_state(READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING, PSTR(MSG_Z_PROBE));
   #endif
   #if HAS_FILAMENT_SENSOR
@@ -538,60 +538,52 @@ void Endstops::update() {
    * Check and update endstops
    */
   #if HAS_X_MIN && !X_SPI_SENSORLESS
+    UPDATE_ENDSTOP_BIT(X, MIN);
     #if ENABLED(X_DUAL_ENDSTOPS)
-      UPDATE_ENDSTOP_BIT(X, MIN);
       #if HAS_X2_MIN
         UPDATE_ENDSTOP_BIT(X2, MIN);
       #else
         COPY_LIVE_STATE(X_MIN, X2_MIN);
       #endif
-    #else
-      UPDATE_ENDSTOP_BIT(X, MIN);
     #endif
   #endif
 
   #if HAS_X_MAX && !X_SPI_SENSORLESS
+    UPDATE_ENDSTOP_BIT(X, MAX);
     #if ENABLED(X_DUAL_ENDSTOPS)
-      UPDATE_ENDSTOP_BIT(X, MAX);
       #if HAS_X2_MAX
         UPDATE_ENDSTOP_BIT(X2, MAX);
       #else
         COPY_LIVE_STATE(X_MAX, X2_MAX);
       #endif
-    #else
-      UPDATE_ENDSTOP_BIT(X, MAX);
     #endif
   #endif
 
   #if HAS_Y_MIN && !Y_SPI_SENSORLESS
+    UPDATE_ENDSTOP_BIT(Y, MIN);
     #if ENABLED(Y_DUAL_ENDSTOPS)
-      UPDATE_ENDSTOP_BIT(Y, MIN);
       #if HAS_Y2_MIN
         UPDATE_ENDSTOP_BIT(Y2, MIN);
       #else
         COPY_LIVE_STATE(Y_MIN, Y2_MIN);
       #endif
-    #else
-      UPDATE_ENDSTOP_BIT(Y, MIN);
     #endif
   #endif
 
   #if HAS_Y_MAX && !Y_SPI_SENSORLESS
+    UPDATE_ENDSTOP_BIT(Y, MAX);
     #if ENABLED(Y_DUAL_ENDSTOPS)
-      UPDATE_ENDSTOP_BIT(Y, MAX);
       #if HAS_Y2_MAX
         UPDATE_ENDSTOP_BIT(Y2, MAX);
       #else
         COPY_LIVE_STATE(Y_MAX, Y2_MAX);
       #endif
-    #else
-      UPDATE_ENDSTOP_BIT(Y, MAX);
     #endif
   #endif
 
   #if HAS_Z_MIN && !Z_SPI_SENSORLESS
+    UPDATE_ENDSTOP_BIT(Z, MIN);
     #if Z_MULTI_ENDSTOPS
-      UPDATE_ENDSTOP_BIT(Z, MIN);
       #if HAS_Z2_MIN
         UPDATE_ENDSTOP_BIT(Z2, MIN);
       #else
@@ -604,15 +596,11 @@ void Endstops::update() {
           COPY_LIVE_STATE(Z_MIN, Z3_MIN);
         #endif
       #endif
-    #elif ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
-      UPDATE_ENDSTOP_BIT(Z, MIN);
-    #elif Z_HOME_DIR < 0
-      UPDATE_ENDSTOP_BIT(Z, MIN);
     #endif
   #endif
 
   // When closing the gap check the enabled probe
-  #if USES_Z_MIN_PROBE_ENDSTOP
+  #if HAS_CUSTOM_PROBE_PIN
     UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
   #endif
 
@@ -632,7 +620,7 @@ void Endstops::update() {
           COPY_LIVE_STATE(Z_MAX, Z3_MAX);
         #endif
       #endif
-    #elif !USES_Z_MIN_PROBE_ENDSTOP || Z_MAX_PIN != Z_MIN_PROBE_PIN
+    #elif !HAS_CUSTOM_PROBE_PIN || Z_MAX_PIN != Z_MIN_PROBE_PIN
       // If this pin isn't the bed probe it's the Z endstop
       UPDATE_ENDSTOP_BIT(Z, MAX);
     #endif
@@ -765,7 +753,7 @@ void Endstops::update() {
         #else
           #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
             if (z_probe_enabled) PROCESS_ENDSTOP(Z, MIN);
-          #elif USES_Z_MIN_PROBE_ENDSTOP
+          #elif HAS_CUSTOM_PROBE_PIN
             if (!z_probe_enabled) PROCESS_ENDSTOP(Z, MIN);
           #else
             PROCESS_ENDSTOP(Z, MIN);
@@ -774,7 +762,7 @@ void Endstops::update() {
       #endif
 
       // When closing the gap check the enabled probe
-      #if USES_Z_MIN_PROBE_ENDSTOP
+      #if HAS_CUSTOM_PROBE_PIN
         if (z_probe_enabled) PROCESS_ENDSTOP(Z, MIN_PROBE);
       #endif
     }
@@ -784,7 +772,7 @@ void Endstops::update() {
           PROCESS_TRIPLE_ENDSTOP(Z, Z2, Z3, MAX);
         #elif ENABLED(Z_DUAL_ENDSTOPS)
           PROCESS_DUAL_ENDSTOP(Z, Z2, MAX);
-        #elif !USES_Z_MIN_PROBE_ENDSTOP || Z_MAX_PIN != Z_MIN_PROBE_PIN
+        #elif !HAS_CUSTOM_PROBE_PIN || Z_MAX_PIN != Z_MIN_PROBE_PIN
           // If this pin is not hijacked for the bed probe
           // then it belongs to the Z endstop
           PROCESS_ENDSTOP(Z, MAX);

commit 437978d349d48a575b923eb4a6e020e5b42dadd5
Author: Markus Towara <towara@stce.rwth-aachen.de>
Date:   Tue Oct 15 18:34:45 2019 +0200

    Bring SPI_SENSORLESS code up to date (#15560)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 0cb7c603d4..e5d07cbc65 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -537,7 +537,7 @@ void Endstops::update() {
   /**
    * Check and update endstops
    */
-  #if HAS_X_MIN
+  #if HAS_X_MIN && !X_SPI_SENSORLESS
     #if ENABLED(X_DUAL_ENDSTOPS)
       UPDATE_ENDSTOP_BIT(X, MIN);
       #if HAS_X2_MIN
@@ -550,7 +550,7 @@ void Endstops::update() {
     #endif
   #endif
 
-  #if HAS_X_MAX
+  #if HAS_X_MAX && !X_SPI_SENSORLESS
     #if ENABLED(X_DUAL_ENDSTOPS)
       UPDATE_ENDSTOP_BIT(X, MAX);
       #if HAS_X2_MAX
@@ -563,7 +563,7 @@ void Endstops::update() {
     #endif
   #endif
 
-  #if HAS_Y_MIN
+  #if HAS_Y_MIN && !Y_SPI_SENSORLESS
     #if ENABLED(Y_DUAL_ENDSTOPS)
       UPDATE_ENDSTOP_BIT(Y, MIN);
       #if HAS_Y2_MIN
@@ -576,7 +576,7 @@ void Endstops::update() {
     #endif
   #endif
 
-  #if HAS_Y_MAX
+  #if HAS_Y_MAX && !Y_SPI_SENSORLESS
     #if ENABLED(Y_DUAL_ENDSTOPS)
       UPDATE_ENDSTOP_BIT(Y, MAX);
       #if HAS_Y2_MAX
@@ -589,7 +589,7 @@ void Endstops::update() {
     #endif
   #endif
 
-  #if HAS_Z_MIN
+  #if HAS_Z_MIN && !Z_SPI_SENSORLESS
     #if Z_MULTI_ENDSTOPS
       UPDATE_ENDSTOP_BIT(Z, MIN);
       #if HAS_Z2_MIN
@@ -616,7 +616,7 @@ void Endstops::update() {
     UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
   #endif
 
-  #if HAS_Z_MAX
+  #if HAS_Z_MAX && !Z_SPI_SENSORLESS
     // Check both Z dual endstops
     #if Z_MULTI_ENDSTOPS
       UPDATE_ENDSTOP_BIT(Z, MAX);

commit 6a865a614620d71521bd3dc032adffe0bf82378c
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Wed Oct 9 18:46:10 2019 -0600

    Multi-language support (#15453)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 6970a051b3..0cb7c603d4 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -302,7 +302,7 @@ void Endstops::not_homing() {
   // If the last move failed to trigger an endstop, call kill
   void Endstops::validate_homing_move() {
     if (trigger_state()) hit_on_purpose();
-    else kill(PSTR(MSG_ERR_HOMING_FAILED));
+    else kill(GET_TEXT(MSG_LCD_HOMING_FAILED));
   }
 #endif
 
@@ -373,7 +373,7 @@ void Endstops::event_handler() {
     SERIAL_EOL();
 
     #if HAS_SPI_LCD
-      ui.status_printf_P(0, PSTR(S_FMT " %c %c %c %c"), PSTR(MSG_LCD_ENDSTOPS), chrX, chrY, chrZ, chrP);
+      ui.status_printf_P(0, PSTR(S_FMT " %c %c %c %c"), GET_TEXT(MSG_LCD_ENDSTOPS), chrX, chrY, chrZ, chrP);
     #endif
 
     #if BOTH(SD_ABORT_ON_ENDSTOP_HIT, SDSUPPORT)

commit a18d16fb8b92c78093e25f8bb88cd0a49074678e
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Fri Sep 27 03:38:43 2019 -0600

    Do not implicitly concatenate localized strings (#15383)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 04f1ab6b17..6970a051b3 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -373,7 +373,7 @@ void Endstops::event_handler() {
     SERIAL_EOL();
 
     #if HAS_SPI_LCD
-      ui.status_printf_P(0, PSTR(MSG_LCD_ENDSTOPS " %c %c %c %c"), chrX, chrY, chrZ, chrP);
+      ui.status_printf_P(0, PSTR(S_FMT " %c %c %c %c"), PSTR(MSG_LCD_ENDSTOPS), chrX, chrY, chrZ, chrP);
     #endif
 
     #if BOTH(SD_ABORT_ON_ENDSTOP_HIT, SDSUPPORT)

commit dbee0e9c5424770b9abf8815c0cb8b49de7db77f
Author: Jamie <vector76@users.noreply.github.com>
Date:   Sun Sep 8 00:55:34 2019 -0500

    Analog joystick jogging control (#14648)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index b1a4f9e57f..04f1ab6b17 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -44,6 +44,10 @@
   #include "../feature/bltouch.h"
 #endif
 
+#if ENABLED(JOYSTICK)
+  #include "../feature/joystick.h"
+#endif
+
 Endstops endstops;
 
 // private:
@@ -474,6 +478,11 @@ void _O2 Endstops::M119() {
   #if ENABLED(BLTOUCH)
     bltouch._reset_SW_mode();
   #endif
+
+  #if ENABLED(JOYSTICK_DEBUG)
+    joystick.report();
+  #endif
+
 } // Endstops::M119
 
 // The following routines are called from an ISR context. It could be the temperature ISR, the

commit d4974ea719ceba2d76a678f77942d0b92e8fecb8
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Mon Aug 5 06:22:58 2019 +0300

    TMC SPI Endstops and Improved Sensorless Homing (#14044)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 9aaab38dd2..b1a4f9e57f 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -76,6 +76,13 @@ Endstops::esbits_t Endstops::live_state = 0;
   float Endstops::z3_endstop_adj;
 #endif
 
+#if ENABLED(SPI_ENDSTOPS)
+  Endstops::tmc_spi_homing_t Endstops::tmc_spi_homing; // = 0
+#endif
+#if ENABLED(IMPROVE_HOMING_RELIABILITY)
+  millis_t sg_guard_period; // = 0
+#endif
+
 /**
  * Class and Instance Methods
  */
@@ -699,7 +706,7 @@ void Endstops::update() {
   // Now, we must signal, after validation, if an endstop limit is pressed or not
   if (stepper.axis_is_moving(X_AXIS)) {
     if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
-      #if HAS_X_MIN
+      #if HAS_X_MIN || (X_SPI_SENSORLESS && X_HOME_DIR < 0)
         #if ENABLED(X_DUAL_ENDSTOPS)
           PROCESS_DUAL_ENDSTOP(X, X2, MIN);
         #else
@@ -708,7 +715,7 @@ void Endstops::update() {
       #endif
     }
     else { // +direction
-      #if HAS_X_MAX
+      #if HAS_X_MAX || (X_SPI_SENSORLESS && X_HOME_DIR > 0)
         #if ENABLED(X_DUAL_ENDSTOPS)
           PROCESS_DUAL_ENDSTOP(X, X2, MAX);
         #else
@@ -720,7 +727,7 @@ void Endstops::update() {
 
   if (stepper.axis_is_moving(Y_AXIS)) {
     if (stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
-      #if HAS_Y_MIN
+      #if HAS_Y_MIN || (Y_SPI_SENSORLESS && Y_HOME_DIR < 0)
         #if ENABLED(Y_DUAL_ENDSTOPS)
           PROCESS_DUAL_ENDSTOP(Y, Y2, MIN);
         #else
@@ -729,7 +736,7 @@ void Endstops::update() {
       #endif
     }
     else { // +direction
-      #if HAS_Y_MAX
+      #if HAS_Y_MAX || (Y_SPI_SENSORLESS && Y_HOME_DIR > 0)
         #if ENABLED(Y_DUAL_ENDSTOPS)
           PROCESS_DUAL_ENDSTOP(Y, Y2, MAX);
         #else
@@ -741,7 +748,7 @@ void Endstops::update() {
 
   if (stepper.axis_is_moving(Z_AXIS)) {
     if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
-      #if HAS_Z_MIN
+      #if HAS_Z_MIN || (Z_SPI_SENSORLESS && Z_HOME_DIR < 0)
         #if ENABLED(Z_TRIPLE_ENDSTOPS)
           PROCESS_TRIPLE_ENDSTOP(Z, Z2, Z3, MIN);
         #elif ENABLED(Z_DUAL_ENDSTOPS)
@@ -763,7 +770,7 @@ void Endstops::update() {
       #endif
     }
     else { // Z +direction. Gantry up, bed down.
-      #if HAS_Z_MAX
+      #if HAS_Z_MAX || (Z_SPI_SENSORLESS && Z_HOME_DIR > 0)
         #if ENABLED(Z_TRIPLE_ENDSTOPS)
           PROCESS_TRIPLE_ENDSTOP(Z, Z2, Z3, MAX);
         #elif ENABLED(Z_DUAL_ENDSTOPS)
@@ -778,6 +785,49 @@ void Endstops::update() {
   }
 } // Endstops::update()
 
+#if ENABLED(SPI_ENDSTOPS)
+
+  #define X_STOP (X_HOME_DIR < 0 ? X_MIN : X_MAX)
+  #define Y_STOP (Y_HOME_DIR < 0 ? Y_MIN : Y_MAX)
+  #define Z_STOP (Z_HOME_DIR < 0 ? Z_MIN : Z_MAX)
+
+  bool Endstops::tmc_spi_homing_check() {
+    bool hit = false;
+    #if X_SPI_SENSORLESS
+      if (tmc_spi_homing.x && stepperX.test_stall_status()) {
+        SBI(live_state, X_STOP);
+        hit = true;
+      }
+    #endif
+    #if Y_SPI_SENSORLESS
+      if (tmc_spi_homing.y && stepperY.test_stall_status()) {
+        SBI(live_state, Y_STOP);
+        hit = true;
+      }
+    #endif
+    #if Z_SPI_SENSORLESS
+      if (tmc_spi_homing.z && stepperZ.test_stall_status()) {
+        SBI(live_state, Z_STOP);
+        hit = true;
+      }
+    #endif
+    return hit;
+  }
+
+  void Endstops::clear_endstop_state() {
+    #if X_SPI_SENSORLESS
+      CBI(live_state, X_STOP);
+    #endif
+    #if Y_SPI_SENSORLESS
+      CBI(live_state, Y_STOP);
+    #endif
+    #if Z_SPI_SENSORLESS
+      CBI(live_state, Z_STOP);
+    #endif
+  }
+
+#endif // SPI_ENDSTOPS
+
 #if ENABLED(PINS_DEBUGGING)
 
   bool Endstops::monitor_flag = false;

commit eae543adf34268505f9321b7576495db20293c09
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jul 29 18:45:01 2019 -0500

    Apply HAS_SPI_LCD as needed

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index abc93e9f1d..9aaab38dd2 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -330,7 +330,7 @@ void Endstops::resync() {
 void Endstops::event_handler() {
   static uint8_t prev_hit_state; // = 0
   if (hit_state && hit_state != prev_hit_state) {
-    #if ENABLED(ULTRA_LCD)
+    #if HAS_SPI_LCD
       char chrX = ' ', chrY = ' ', chrZ = ' ', chrP = ' ';
       #define _SET_STOP_CHAR(A,C) (chr## A = C)
     #else
@@ -361,7 +361,7 @@ void Endstops::event_handler() {
     #endif
     SERIAL_EOL();
 
-    #if ENABLED(ULTRA_LCD)
+    #if HAS_SPI_LCD
       ui.status_printf_P(0, PSTR(MSG_LCD_ENDSTOPS " %c %c %c %c"), chrX, chrY, chrZ, chrP);
     #endif
 

commit 1088846caef6f660d5af65e1725a6a6deeef16fd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jul 24 01:52:36 2019 -0500

    Cosmetic updates from 14044

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 7234bf4769..abc93e9f1d 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -783,14 +783,13 @@ void Endstops::update() {
   bool Endstops::monitor_flag = false;
 
   /**
-   * monitors endstops & Z probe for changes
+   * Monitor Endstops and Z Probe for changes
    *
    * If a change is detected then the LED is toggled and
-   * a message is sent out the serial port
+   * a message is sent out the serial port.
    *
    * Yes, we could miss a rapid back & forth change but
    * that won't matter because this is all manual.
-   *
    */
   void Endstops::monitor() {
 

commit 93cd66ac1146603e8a9911fceb3c63f4351f4d8e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 23:57:50 2019 -0500

    Tweaky change from (C) to (c)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index a70ef19da9..7234bf4769 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -1,9 +1,9 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by

commit 52383633e7062bf5ffd72d9c41c4cf7df05c544c
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Fri Jun 21 08:20:17 2019 +0200

    STM32F1: M43 PINS_DEBUGGING (#14072)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 30bc3375d5..a70ef19da9 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -896,7 +896,7 @@ void Endstops::update() {
         ES_REPORT_CHANGE(Z3_MAX);
       #endif
       SERIAL_ECHOLNPGM("\n");
-      analogWrite(LED_PIN, local_LED_status);
+      analogWrite(pin_t(LED_PIN), local_LED_status);
       local_LED_status ^= 255;
       old_live_state_local = live_state_local;
     }

commit 0ca2073625fcf1eb35de8c37d49960bf20bed4b6
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jun 10 17:25:43 2019 -0500

    ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED => SD_ABORT_ON_ENDSTOP_HIT

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index deba8b33a4..30bc3375d5 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -36,7 +36,7 @@
   #include HAL_PATH(../HAL, endstop_interrupts.h)
 #endif
 
-#if BOTH(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED, SDSUPPORT)
+#if BOTH(SD_ABORT_ON_ENDSTOP_HIT, SDSUPPORT)
   #include "printcounter.h" // for print_job_timer
 #endif
 
@@ -365,7 +365,7 @@ void Endstops::event_handler() {
       ui.status_printf_P(0, PSTR(MSG_LCD_ENDSTOPS " %c %c %c %c"), chrX, chrY, chrZ, chrP);
     #endif
 
-    #if BOTH(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED, SDSUPPORT)
+    #if BOTH(SD_ABORT_ON_ENDSTOP_HIT, SDSUPPORT)
       if (planner.abort_on_endstop_hit) {
         card.stopSDPrint();
         quickstop_stepper();

commit 85fb33a060354a70348f220085405ae7bfb939c5
Author: FanDjango <FanDjango@users.noreply.github.com>
Date:   Sat May 18 02:10:18 2019 +0200

    BLTOUCH tweaks, new v3.1 command (#14015)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index bfb89fb7b5..deba8b33a4 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -465,8 +465,7 @@ void _O2 Endstops::M119() {
     #endif
   #endif
   #if ENABLED(BLTOUCH)
-    bltouch._reset();
-    if (enabled_globally) bltouch._stow();
+    bltouch._reset_SW_mode();
   #endif
 } // Endstops::M119
 

commit ad4ffa1d2fbd17ac09c816ba2052cdf714261042
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 9 11:45:55 2019 -0500

    Use C++ language supported 'nullptr' (#13944)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index fdcc076db5..bfb89fb7b5 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -377,7 +377,7 @@ void Endstops::event_handler() {
   prev_hit_state = hit_state;
 }
 
-static void print_es_state(const bool is_hit, PGM_P const label=NULL) {
+static void print_es_state(const bool is_hit, PGM_P const label=nullptr) {
   if (label) serialprintPGM(label);
   SERIAL_ECHOPGM(": ");
   serialprintPGM(is_hit ? PSTR(MSG_ENDSTOP_HIT) : PSTR(MSG_ENDSTOP_OPEN));

commit 6811e2921bcd272e7487e4f379b42a5a403a07c2
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue May 7 22:25:54 2019 -0400

    BLTouch v3 / 3DTouch Interoperability & performance (#13814)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index e077045ef5..fdcc076db5 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -40,6 +40,10 @@
   #include "printcounter.h" // for print_job_timer
 #endif
 
+#if ENABLED(BLTOUCH)
+  #include "../feature/bltouch.h"
+#endif
+
 Endstops endstops;
 
 // private:
@@ -381,6 +385,9 @@ static void print_es_state(const bool is_hit, PGM_P const label=NULL) {
 }
 
 void _O2 Endstops::M119() {
+  #if ENABLED(BLTOUCH)
+    bltouch._set_SW_mode();
+  #endif
   SERIAL_ECHOLNPGM(MSG_M119_REPORT);
   #define ES_REPORT(S) print_es_state(READ(S##_PIN) != S##_ENDSTOP_INVERTING, PSTR(MSG_##S))
   #if HAS_X_MIN
@@ -457,6 +464,10 @@ void _O2 Endstops::M119() {
       }
     #endif
   #endif
+  #if ENABLED(BLTOUCH)
+    bltouch._reset();
+    if (enabled_globally) bltouch._stow();
+  #endif
 } // Endstops::M119
 
 // The following routines are called from an ISR context. It could be the temperature ISR, the

commit 49cf92dc36424cf828436f32e72263eca39a1cc3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 16 23:43:06 2019 -0500

    Extended condition macros (#13419)
    
    Allow `ENABLED`, `DISABLED`, `PIN_EXISTS`, and `BUTTON_EXISTS` to take multiple arguments. Also add:
    - Alias `ANY(...)` for `!DISABLED(...)`
    - Alias `ANY_PIN(...)` for `PIN_EXISTS(a) || PIN_EXISTS(b) ...`
    - Alias `EITHER(A,B)` for `ANY(...)`
    - Alias `ALL(...)` and `BOTH(A,B)` for `ENABLED(...)`
    - `NONE(...)` for `DISABLED(...)`

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index c5185f1834..e077045ef5 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -36,7 +36,7 @@
   #include HAL_PATH(../HAL, endstop_interrupts.h)
 #endif
 
-#if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED) && ENABLED(SDSUPPORT)
+#if BOTH(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED, SDSUPPORT)
   #include "printcounter.h" // for print_job_timer
 #endif
 
@@ -361,7 +361,7 @@ void Endstops::event_handler() {
       ui.status_printf_P(0, PSTR(MSG_LCD_ENDSTOPS " %c %c %c %c"), chrX, chrY, chrZ, chrP);
     #endif
 
-    #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED) && ENABLED(SDSUPPORT)
+    #if BOTH(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED, SDSUPPORT)
       if (planner.abort_on_endstop_hit) {
         card.stopSDPrint();
         quickstop_stepper();

commit 67bee06e4371fca6511aae99125337b6e63560d8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 13 07:21:10 2019 -0500

    No patch needed for non-libmaple analogWrite
    
    See https://github.com/pinchies/Marlin/pull/1#issuecomment-471388743

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index fe076b6d38..c5185f1834 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -886,7 +886,7 @@ void Endstops::update() {
         ES_REPORT_CHANGE(Z3_MAX);
       #endif
       SERIAL_ECHOLNPGM("\n");
-      ANALOG_WRITE(LED_PIN, local_LED_status);
+      analogWrite(LED_PIN, local_LED_status);
       local_LED_status ^= 255;
       old_live_state_local = live_state_local;
     }

commit f89b375fb9ca9730a4165ac3bf9f0f9dc100a338
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 13 06:51:15 2019 -0500

    Fixes and improvements for PWM pins (#13383)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index c5185f1834..fe076b6d38 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -886,7 +886,7 @@ void Endstops::update() {
         ES_REPORT_CHANGE(Z3_MAX);
       #endif
       SERIAL_ECHOLNPGM("\n");
-      analogWrite(LED_PIN, local_LED_status);
+      ANALOG_WRITE(LED_PIN, local_LED_status);
       local_LED_status ^= 255;
       old_live_state_local = live_state_local;
     }

commit b824a517aaad62001cf815e577b2f383f4766402
Author: Michiel Baird <michielbaird@gmail.com>
Date:   Sun Mar 10 15:22:09 2019 -0700

    Add G38.4 and G38.5 (#13348)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 46c6db8998..c5185f1834 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -672,14 +672,17 @@ void Endstops::update() {
   }while(0)
 
   #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && !(CORE_IS_XY || CORE_IS_XZ)
+    #if ENABLED(G38_PROBE_AWAY)
+      #define _G38_OPEN_STATE (G38_move >= 4)
+    #else
+      #define _G38_OPEN_STATE LOW
+    #endif
     // If G38 command is active check Z_MIN_PROBE for ALL movement
-    if (G38_move) {
-      if (TEST_ENDSTOP(_ENDSTOP(Z, MIN_PROBE))) {
-        if      (stepper.axis_is_moving(X_AXIS)) { _ENDSTOP_HIT(X, MIN); planner.endstop_triggered(X_AXIS); }
-        else if (stepper.axis_is_moving(Y_AXIS)) { _ENDSTOP_HIT(Y, MIN); planner.endstop_triggered(Y_AXIS); }
-        else if (stepper.axis_is_moving(Z_AXIS)) { _ENDSTOP_HIT(Z, MIN); planner.endstop_triggered(Z_AXIS); }
-        G38_endstop_hit = true;
-      }
+    if (G38_move && TEST_ENDSTOP(_ENDSTOP(Z, MIN_PROBE)) != _G38_OPEN_STATE) {
+           if (stepper.axis_is_moving(X_AXIS)) { _ENDSTOP_HIT(X, MIN); planner.endstop_triggered(X_AXIS); }
+      else if (stepper.axis_is_moving(Y_AXIS)) { _ENDSTOP_HIT(Y, MIN); planner.endstop_triggered(Y_AXIS); }
+      else if (stepper.axis_is_moving(Z_AXIS)) { _ENDSTOP_HIT(Z, MIN); planner.endstop_triggered(Z_AXIS); }
+      G38_did_trigger = true;
     }
   #endif
 

commit 2212da453aa8a575df529cd4333b5248d9bae5b5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Mar 5 00:41:31 2019 -0600

    Distinguish between analog/digital auto fans (#13298)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index d79c63c77d..46c6db8998 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -453,7 +453,7 @@ void _O2 Endstops::M119() {
         }
         SERIAL_ECHOPGM(MSG_FILAMENT_RUNOUT_SENSOR);
         if (i > 1) { SERIAL_CHAR(' '); SERIAL_CHAR('0' + i); }
-        print_es_state(digitalRead(pin) != FIL_RUNOUT_INVERTING);
+        print_es_state(extDigitalRead(pin) != FIL_RUNOUT_INVERTING);
       }
     #endif
   #endif

commit 99d0022fae0efd9164946062bf641f7294597675
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 1 00:27:45 2019 -0600

    Drop the Z_MIN_PROBE_ENDSTOP option (#13276)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index addc6699af..d79c63c77d 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -228,7 +228,7 @@ void Endstops::init() {
     #endif
   #endif
 
-  #if ENABLED(Z_MIN_PROBE_ENDSTOP)
+  #if USES_Z_MIN_PROBE_ENDSTOP
     #if ENABLED(ENDSTOPPULLUP_ZMIN_PROBE)
       SET_INPUT_PULLUP(Z_MIN_PROBE_PIN);
     #elif ENABLED(ENDSTOPPULLDOWN_ZMIN_PROBE)
@@ -351,7 +351,7 @@ void Endstops::event_handler() {
     ENDSTOP_HIT_TEST_Y();
     ENDSTOP_HIT_TEST_Z();
 
-    #if ENABLED(Z_MIN_PROBE_ENDSTOP)
+    #if USES_Z_MIN_PROBE_ENDSTOP
       #define P_AXIS Z_AXIS
       if (TEST(hit_state, Z_MIN_PROBE)) _ENDSTOP_HIT_ECHO(P, 'P');
     #endif
@@ -425,7 +425,7 @@ void _O2 Endstops::M119() {
   #if HAS_Z3_MAX
     ES_REPORT(Z3_MAX);
   #endif
-  #if ENABLED(Z_MIN_PROBE_ENDSTOP)
+  #if USES_Z_MIN_PROBE_ENDSTOP
     print_es_state(READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING, PSTR(MSG_Z_PROBE));
   #endif
   #if HAS_FILAMENT_SENSOR
@@ -586,7 +586,7 @@ void Endstops::update() {
   #endif
 
   // When closing the gap check the enabled probe
-  #if ENABLED(Z_MIN_PROBE_ENDSTOP)
+  #if USES_Z_MIN_PROBE_ENDSTOP
     UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
   #endif
 
@@ -606,7 +606,7 @@ void Endstops::update() {
           COPY_LIVE_STATE(Z_MAX, Z3_MAX);
         #endif
       #endif
-    #elif DISABLED(Z_MIN_PROBE_ENDSTOP) || Z_MAX_PIN != Z_MIN_PROBE_PIN
+    #elif !USES_Z_MIN_PROBE_ENDSTOP || Z_MAX_PIN != Z_MIN_PROBE_PIN
       // If this pin isn't the bed probe it's the Z endstop
       UPDATE_ENDSTOP_BIT(Z, MAX);
     #endif
@@ -736,7 +736,7 @@ void Endstops::update() {
         #else
           #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
             if (z_probe_enabled) PROCESS_ENDSTOP(Z, MIN);
-          #elif ENABLED(Z_MIN_PROBE_ENDSTOP)
+          #elif USES_Z_MIN_PROBE_ENDSTOP
             if (!z_probe_enabled) PROCESS_ENDSTOP(Z, MIN);
           #else
             PROCESS_ENDSTOP(Z, MIN);
@@ -745,7 +745,7 @@ void Endstops::update() {
       #endif
 
       // When closing the gap check the enabled probe
-      #if ENABLED(Z_MIN_PROBE_ENDSTOP)
+      #if USES_Z_MIN_PROBE_ENDSTOP
         if (z_probe_enabled) PROCESS_ENDSTOP(Z, MIN_PROBE);
       #endif
     }
@@ -755,7 +755,7 @@ void Endstops::update() {
           PROCESS_TRIPLE_ENDSTOP(Z, Z2, Z3, MAX);
         #elif ENABLED(Z_DUAL_ENDSTOPS)
           PROCESS_DUAL_ENDSTOP(Z, Z2, MAX);
-        #elif DISABLED(Z_MIN_PROBE_ENDSTOP) || Z_MAX_PIN != Z_MIN_PROBE_PIN
+        #elif !USES_Z_MIN_PROBE_ENDSTOP || Z_MAX_PIN != Z_MIN_PROBE_PIN
           // If this pin is not hijacked for the bed probe
           // then it belongs to the Z endstop
           PROCESS_ENDSTOP(Z, MAX);

commit 7cf9b93f26f728f0104dc9b930f6b23096639d98
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 20:08:34 2019 -0600

    Add HAS_FILAMENT_SENSOR ahead of 12962

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 7d6b04f99c..addc6699af 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -428,7 +428,7 @@ void _O2 Endstops::M119() {
   #if ENABLED(Z_MIN_PROBE_ENDSTOP)
     print_es_state(READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING, PSTR(MSG_Z_PROBE));
   #endif
-  #if ENABLED(FILAMENT_RUNOUT_SENSOR)
+  #if HAS_FILAMENT_SENSOR
     #if NUM_RUNOUT_SENSORS == 1
       print_es_state(READ(FIL_RUNOUT_PIN) != FIL_RUNOUT_INVERTING, PSTR(MSG_FILAMENT_RUNOUT_SENSOR));
     #else

commit 0feeef26048883640b37ebe3994730f31ef6e922
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 15:06:53 2019 -0600

    Update copyright in headers

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 119bea1242..7d6b04f99c 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -1,6 +1,6 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm

commit e1604198ffa550f1eed2b8f5d39d51fdc0c2762f
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Wed Feb 6 16:20:17 2019 -0700

    G425 ‚Äî Auto-calibrate Backlash and Nozzle Offsets (#13050)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index cd543bcb7a..119bea1242 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -218,6 +218,16 @@ void Endstops::init() {
     #endif
   #endif
 
+  #if HAS_CALIBRATION_PIN
+    #if ENABLED(CALIBRATION_PIN_PULLUP)
+      SET_INPUT_PULLUP(CALIBRATION_PIN);
+    #elif ENABLED(CALIBRATION_PIN_PULLDOWN)
+      SET_INPUT_PULLDOWN(CALIBRATION_PIN);
+    #else
+      SET_INPUT(CALIBRATION_PIN);
+    #endif
+  #endif
+
   #if ENABLED(Z_MIN_PROBE_ENDSTOP)
     #if ENABLED(ENDSTOPPULLUP_ZMIN_PROBE)
       SET_INPUT_PULLUP(Z_MIN_PROBE_PIN);

commit d4d1b28a06caa57d26e300c1b814b2b8b62120cd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 4 03:41:55 2019 -0600

    Fix some include paths

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 1875782465..cd543bcb7a 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -29,7 +29,7 @@
 
 #include "../Marlin.h"
 #include "../sd/cardreader.h"
-#include "../module/temperature.h"
+#include "temperature.h"
 #include "../lcd/ultralcd.h"
 
 #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
@@ -37,7 +37,7 @@
 #endif
 
 #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED) && ENABLED(SDSUPPORT)
-  #include "../module/printcounter.h" // for print_job_timer
+  #include "printcounter.h" // for print_job_timer
 #endif
 
 Endstops endstops;

commit 4fa1c52688917b139f1a2a68dd9028a592d4567a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Feb 2 23:32:48 2019 -0600

    Tweak serial output code

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 41ac8a37d9..1875782465 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -872,7 +872,7 @@ void Endstops::update() {
       #if HAS_Z3_MAX
         ES_REPORT_CHANGE(Z3_MAX);
       #endif
-      SERIAL_ECHOPGM("\n\n");
+      SERIAL_ECHOLNPGM("\n");
       analogWrite(LED_PIN, local_LED_status);
       local_LED_status ^= 255;
       old_live_state_local = live_state_local;

commit e874f9664c541b5a9f0d24149fba2b5956b623ec
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Nov 30 14:25:43 2018 -0600

    Tweaks to endstops code

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index ff5311781c..41ac8a37d9 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -775,99 +775,102 @@ void Endstops::update() {
     static uint8_t local_LED_status = 0;
     uint16_t live_state_local = 0;
 
+    #define ES_GET_STATE(S) if (READ(S##_PIN)) SBI(live_state_local, S)
+
     #if HAS_X_MIN
-      if (READ(X_MIN_PIN)) SBI(live_state_local, X_MIN);
+      ES_GET_STATE(X_MIN);
     #endif
     #if HAS_X_MAX
-      if (READ(X_MAX_PIN)) SBI(live_state_local, X_MAX);
+      ES_GET_STATE(X_MAX);
     #endif
     #if HAS_Y_MIN
-      if (READ(Y_MIN_PIN)) SBI(live_state_local, Y_MIN);
+      ES_GET_STATE(Y_MIN);
     #endif
     #if HAS_Y_MAX
-      if (READ(Y_MAX_PIN)) SBI(live_state_local, Y_MAX);
+      ES_GET_STATE(Y_MAX);
     #endif
     #if HAS_Z_MIN
-      if (READ(Z_MIN_PIN)) SBI(live_state_local, Z_MIN);
+      ES_GET_STATE(Z_MIN);
     #endif
     #if HAS_Z_MAX
-      if (READ(Z_MAX_PIN)) SBI(live_state_local, Z_MAX);
+      ES_GET_STATE(Z_MAX);
     #endif
     #if HAS_Z_MIN_PROBE_PIN
-      if (READ(Z_MIN_PROBE_PIN)) SBI(live_state_local, Z_MIN_PROBE);
+      ES_GET_STATE(Z_MIN_PROBE);
     #endif
     #if HAS_X2_MIN
-      if (READ(X2_MIN_PIN)) SBI(live_state_local, X2_MIN);
+      ES_GET_STATE(X2_MIN);
     #endif
     #if HAS_X2_MAX
-      if (READ(X2_MAX_PIN)) SBI(live_state_local, X2_MAX);
+      ES_GET_STATE(X2_MAX);
     #endif
     #if HAS_Y2_MIN
-      if (READ(Y2_MIN_PIN)) SBI(live_state_local, Y2_MIN);
+      ES_GET_STATE(Y2_MIN);
     #endif
     #if HAS_Y2_MAX
-      if (READ(Y2_MAX_PIN)) SBI(live_state_local, Y2_MAX);
+      ES_GET_STATE(Y2_MAX);
     #endif
     #if HAS_Z2_MIN
-      if (READ(Z2_MIN_PIN)) SBI(live_state_local, Z2_MIN);
+      ES_GET_STATE(Z2_MIN);
     #endif
     #if HAS_Z2_MAX
-      if (READ(Z2_MAX_PIN)) SBI(live_state_local, Z2_MAX);
+      ES_GET_STATE(Z2_MAX);
     #endif
     #if HAS_Z3_MIN
-      if (READ(Z3_MIN_PIN)) SBI(live_state_local, Z3_MIN);
+      ES_GET_STATE(Z3_MIN);
     #endif
     #if HAS_Z3_MAX
-      if (READ(Z3_MAX_PIN)) SBI(live_state_local, Z3_MAX);
+      ES_GET_STATE(Z3_MAX);
     #endif
 
     uint16_t endstop_change = live_state_local ^ old_live_state_local;
+    #define ES_REPORT_CHANGE(S) if (TEST(endstop_change, S)) SERIAL_ECHOPAIR("  " STRINGIFY(S) ":", TEST(live_state_local, S))
 
     if (endstop_change) {
       #if HAS_X_MIN
-        if (TEST(endstop_change, X_MIN)) SERIAL_ECHOPAIR("  X_MIN:", TEST(live_state_local, X_MIN));
+        ES_REPORT_CHANGE(X_MIN);
       #endif
       #if HAS_X_MAX
-        if (TEST(endstop_change, X_MAX)) SERIAL_ECHOPAIR("  X_MAX:", TEST(live_state_local, X_MAX));
+        ES_REPORT_CHANGE(X_MAX);
       #endif
       #if HAS_Y_MIN
-        if (TEST(endstop_change, Y_MIN)) SERIAL_ECHOPAIR("  Y_MIN:", TEST(live_state_local, Y_MIN));
+        ES_REPORT_CHANGE(Y_MIN);
       #endif
       #if HAS_Y_MAX
-        if (TEST(endstop_change, Y_MAX)) SERIAL_ECHOPAIR("  Y_MAX:", TEST(live_state_local, Y_MAX));
+        ES_REPORT_CHANGE(Y_MAX);
       #endif
       #if HAS_Z_MIN
-        if (TEST(endstop_change, Z_MIN)) SERIAL_ECHOPAIR("  Z_MIN:", TEST(live_state_local, Z_MIN));
+        ES_REPORT_CHANGE(Z_MIN);
       #endif
       #if HAS_Z_MAX
-        if (TEST(endstop_change, Z_MAX)) SERIAL_ECHOPAIR("  Z_MAX:", TEST(live_state_local, Z_MAX));
+        ES_REPORT_CHANGE(Z_MAX);
       #endif
       #if HAS_Z_MIN_PROBE_PIN
-        if (TEST(endstop_change, Z_MIN_PROBE)) SERIAL_ECHOPAIR("  PROBE:", TEST(live_state_local, Z_MIN_PROBE));
+        ES_REPORT_CHANGE(Z_MIN_PROBE);
       #endif
       #if HAS_X2_MIN
-        if (TEST(endstop_change, X2_MIN)) SERIAL_ECHOPAIR("  X2_MIN:", TEST(live_state_local, X2_MIN));
+        ES_REPORT_CHANGE(X2_MIN);
       #endif
       #if HAS_X2_MAX
-        if (TEST(endstop_change, X2_MAX)) SERIAL_ECHOPAIR("  X2_MAX:", TEST(live_state_local, X2_MAX));
+        ES_REPORT_CHANGE(X2_MAX);
       #endif
       #if HAS_Y2_MIN
-        if (TEST(endstop_change, Y2_MIN)) SERIAL_ECHOPAIR("  Y2_MIN:", TEST(live_state_local, Y2_MIN));
+        ES_REPORT_CHANGE(Y2_MIN);
       #endif
       #if HAS_Y2_MAX
-        if (TEST(endstop_change, Y2_MAX)) SERIAL_ECHOPAIR("  Y2_MAX:", TEST(live_state_local, Y2_MAX));
+        ES_REPORT_CHANGE(Y2_MAX);
       #endif
       #if HAS_Z2_MIN
-        if (TEST(endstop_change, Z2_MIN)) SERIAL_ECHOPAIR("  Z2_MIN:", TEST(live_state_local, Z2_MIN));
+        ES_REPORT_CHANGE(Z2_MIN);
       #endif
       #if HAS_Z2_MAX
-        if (TEST(endstop_change, Z2_MAX)) SERIAL_ECHOPAIR("  Z2_MAX:", TEST(live_state_local, Z2_MAX));
+        ES_REPORT_CHANGE(Z2_MAX);
       #endif
       #if HAS_Z3_MIN
-        if (TEST(endstop_change, Z3_MIN)) SERIAL_ECHOPAIR("  Z3_MIN:", TEST(live_state_local, Z3_MIN));
+        ES_REPORT_CHANGE(Z3_MIN);
       #endif
       #if HAS_Z3_MAX
-        if (TEST(endstop_change, Z3_MAX)) SERIAL_ECHOPAIR("  Z3_MAX:", TEST(live_state_local, Z3_MAX));
+        ES_REPORT_CHANGE(Z3_MAX);
       #endif
       SERIAL_ECHOPGM("\n\n");
       analogWrite(LED_PIN, local_LED_status);

commit c98623983774b9773800bc7dcef695c4bad81c0e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Nov 29 16:58:58 2018 -0600

    A single SERIAL_ECHO macro type (#12557)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 988bc21b17..ff5311781c 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -365,13 +365,13 @@ void Endstops::event_handler() {
 
 static void print_es_state(const bool is_hit, PGM_P const label=NULL) {
   if (label) serialprintPGM(label);
-  SERIAL_PROTOCOLPGM(": ");
+  SERIAL_ECHOPGM(": ");
   serialprintPGM(is_hit ? PSTR(MSG_ENDSTOP_HIT) : PSTR(MSG_ENDSTOP_OPEN));
   SERIAL_EOL();
 }
 
 void _O2 Endstops::M119() {
-  SERIAL_PROTOCOLLNPGM(MSG_M119_REPORT);
+  SERIAL_ECHOLNPGM(MSG_M119_REPORT);
   #define ES_REPORT(S) print_es_state(READ(S##_PIN) != S##_ENDSTOP_INVERTING, PSTR(MSG_##S))
   #if HAS_X_MIN
     ES_REPORT(X_MIN);
@@ -441,7 +441,7 @@ void _O2 Endstops::M119() {
             #endif
           #endif
         }
-        SERIAL_PROTOCOLPGM(MSG_FILAMENT_RUNOUT_SENSOR);
+        SERIAL_ECHOPGM(MSG_FILAMENT_RUNOUT_SENSOR);
         if (i > 1) { SERIAL_CHAR(' '); SERIAL_CHAR('0' + i); }
         print_es_state(digitalRead(pin) != FIL_RUNOUT_INVERTING);
       }
@@ -825,51 +825,51 @@ void Endstops::update() {
 
     if (endstop_change) {
       #if HAS_X_MIN
-        if (TEST(endstop_change, X_MIN)) SERIAL_PROTOCOLPAIR("  X_MIN:", TEST(live_state_local, X_MIN));
+        if (TEST(endstop_change, X_MIN)) SERIAL_ECHOPAIR("  X_MIN:", TEST(live_state_local, X_MIN));
       #endif
       #if HAS_X_MAX
-        if (TEST(endstop_change, X_MAX)) SERIAL_PROTOCOLPAIR("  X_MAX:", TEST(live_state_local, X_MAX));
+        if (TEST(endstop_change, X_MAX)) SERIAL_ECHOPAIR("  X_MAX:", TEST(live_state_local, X_MAX));
       #endif
       #if HAS_Y_MIN
-        if (TEST(endstop_change, Y_MIN)) SERIAL_PROTOCOLPAIR("  Y_MIN:", TEST(live_state_local, Y_MIN));
+        if (TEST(endstop_change, Y_MIN)) SERIAL_ECHOPAIR("  Y_MIN:", TEST(live_state_local, Y_MIN));
       #endif
       #if HAS_Y_MAX
-        if (TEST(endstop_change, Y_MAX)) SERIAL_PROTOCOLPAIR("  Y_MAX:", TEST(live_state_local, Y_MAX));
+        if (TEST(endstop_change, Y_MAX)) SERIAL_ECHOPAIR("  Y_MAX:", TEST(live_state_local, Y_MAX));
       #endif
       #if HAS_Z_MIN
-        if (TEST(endstop_change, Z_MIN)) SERIAL_PROTOCOLPAIR("  Z_MIN:", TEST(live_state_local, Z_MIN));
+        if (TEST(endstop_change, Z_MIN)) SERIAL_ECHOPAIR("  Z_MIN:", TEST(live_state_local, Z_MIN));
       #endif
       #if HAS_Z_MAX
-        if (TEST(endstop_change, Z_MAX)) SERIAL_PROTOCOLPAIR("  Z_MAX:", TEST(live_state_local, Z_MAX));
+        if (TEST(endstop_change, Z_MAX)) SERIAL_ECHOPAIR("  Z_MAX:", TEST(live_state_local, Z_MAX));
       #endif
       #if HAS_Z_MIN_PROBE_PIN
-        if (TEST(endstop_change, Z_MIN_PROBE)) SERIAL_PROTOCOLPAIR("  PROBE:", TEST(live_state_local, Z_MIN_PROBE));
+        if (TEST(endstop_change, Z_MIN_PROBE)) SERIAL_ECHOPAIR("  PROBE:", TEST(live_state_local, Z_MIN_PROBE));
       #endif
       #if HAS_X2_MIN
-        if (TEST(endstop_change, X2_MIN)) SERIAL_PROTOCOLPAIR("  X2_MIN:", TEST(live_state_local, X2_MIN));
+        if (TEST(endstop_change, X2_MIN)) SERIAL_ECHOPAIR("  X2_MIN:", TEST(live_state_local, X2_MIN));
       #endif
       #if HAS_X2_MAX
-        if (TEST(endstop_change, X2_MAX)) SERIAL_PROTOCOLPAIR("  X2_MAX:", TEST(live_state_local, X2_MAX));
+        if (TEST(endstop_change, X2_MAX)) SERIAL_ECHOPAIR("  X2_MAX:", TEST(live_state_local, X2_MAX));
       #endif
       #if HAS_Y2_MIN
-        if (TEST(endstop_change, Y2_MIN)) SERIAL_PROTOCOLPAIR("  Y2_MIN:", TEST(live_state_local, Y2_MIN));
+        if (TEST(endstop_change, Y2_MIN)) SERIAL_ECHOPAIR("  Y2_MIN:", TEST(live_state_local, Y2_MIN));
       #endif
       #if HAS_Y2_MAX
-        if (TEST(endstop_change, Y2_MAX)) SERIAL_PROTOCOLPAIR("  Y2_MAX:", TEST(live_state_local, Y2_MAX));
+        if (TEST(endstop_change, Y2_MAX)) SERIAL_ECHOPAIR("  Y2_MAX:", TEST(live_state_local, Y2_MAX));
       #endif
       #if HAS_Z2_MIN
-        if (TEST(endstop_change, Z2_MIN)) SERIAL_PROTOCOLPAIR("  Z2_MIN:", TEST(live_state_local, Z2_MIN));
+        if (TEST(endstop_change, Z2_MIN)) SERIAL_ECHOPAIR("  Z2_MIN:", TEST(live_state_local, Z2_MIN));
       #endif
       #if HAS_Z2_MAX
-        if (TEST(endstop_change, Z2_MAX)) SERIAL_PROTOCOLPAIR("  Z2_MAX:", TEST(live_state_local, Z2_MAX));
+        if (TEST(endstop_change, Z2_MAX)) SERIAL_ECHOPAIR("  Z2_MAX:", TEST(live_state_local, Z2_MAX));
       #endif
       #if HAS_Z3_MIN
-        if (TEST(endstop_change, Z3_MIN)) SERIAL_PROTOCOLPAIR("  Z3_MIN:", TEST(live_state_local, Z3_MIN));
+        if (TEST(endstop_change, Z3_MIN)) SERIAL_ECHOPAIR("  Z3_MIN:", TEST(live_state_local, Z3_MIN));
       #endif
       #if HAS_Z3_MAX
-        if (TEST(endstop_change, Z3_MAX)) SERIAL_PROTOCOLPAIR("  Z3_MAX:", TEST(live_state_local, Z3_MAX));
+        if (TEST(endstop_change, Z3_MAX)) SERIAL_ECHOPAIR("  Z3_MAX:", TEST(live_state_local, Z3_MAX));
       #endif
-      SERIAL_PROTOCOLPGM("\n\n");
+      SERIAL_ECHOPGM("\n\n");
       analogWrite(LED_PIN, local_LED_status);
       local_LED_status ^= 255;
       old_live_state_local = live_state_local;

commit 98c2fc4e42eb3f0a1b2a40f2cab785f7a9f59517
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Wed Nov 14 00:10:07 2018 +0100

    Endstops fix followup (#12423)
    
    Followup to #12413

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 221783e211..988bc21b17 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -293,10 +293,10 @@ void Endstops::not_homing() {
 void Endstops::resync() {
   if (!abort_enabled()) return;     // If endstops/probes are disabled the loop below can hang
 
-  #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE) && !ENDSTOP_NOISE_THRESHOLD
+  #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
     update();
   #else
-    safe_delay(2);  // Wait for Temperature ISR (runs at 1KHz)
+    safe_delay(2);  // Wait for Temperature ISR to run at least once (runs at 1KHz)
   #endif
   #if ENDSTOP_NOISE_THRESHOLD
     while (endstop_poll_count) safe_delay(1);

commit d631267548fdcc8eee3a4d909e0ebc2c0de59d17
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Tue Nov 13 11:31:58 2018 +0100

    Refine endstops fixes (#12413)
    
    When endstops/probe are enabled `ENDSTOP_NOISE_THRESHOLD` calls to `update` are required to properly re-sync endstops/probe status.

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 1e2d805b6e..221783e211 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -42,7 +42,7 @@
 
 Endstops endstops;
 
-// public:
+// private:
 
 bool Endstops::enabled, Endstops::enabled_globally; // Initialized by settings.load()
 volatile uint8_t Endstops::hit_state;
@@ -259,15 +259,13 @@ void Endstops::poll() {
 
 void Endstops::enable_globally(const bool onoff) {
   enabled_globally = enabled = onoff;
-
-  update();
+  resync();
 }
 
 // Enable / disable endstop checking
 void Endstops::enable(const bool onoff) {
   enabled = onoff;
-
-  update();
+  resync();
 }
 
 // Disable / Enable endstops based on ENSTOPS_ONLY_FOR_HOMING and global enable
@@ -287,11 +285,24 @@ void Endstops::not_homing() {
 #if HAS_BED_PROBE
   void Endstops::enable_z_probe(const bool onoff) {
     z_probe_enabled = onoff;
-
-    update();
+    resync();
   }
 #endif
 
+// Get the stable endstop states when enabled
+void Endstops::resync() {
+  if (!abort_enabled()) return;     // If endstops/probes are disabled the loop below can hang
+
+  #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE) && !ENDSTOP_NOISE_THRESHOLD
+    update();
+  #else
+    safe_delay(2);  // Wait for Temperature ISR (runs at 1KHz)
+  #endif
+  #if ENDSTOP_NOISE_THRESHOLD
+    while (endstop_poll_count) safe_delay(1);
+  #endif
+}
+
 #if ENABLED(PINS_DEBUGGING)
   void Endstops::run_monitor() {
     if (!monitor_flag) return;

commit a0c795b097a30eff006c8dff178abf5f1f1907fa
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Nov 11 12:16:24 2018 -0600

    Encapsulate common display code in a singleton (#12395)
    
    * Encapsulate common LCD code in a singleton
    * Depend more UBL code on UBL_DEVEL_DEBUGGING
      - Since most users don't need the debugging on at all times, this helps reduce the default build size for UBL by over 2K, a little closer to fitting on 128K boards.

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 28e0d92f69..1e2d805b6e 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -337,7 +337,7 @@ void Endstops::event_handler() {
     SERIAL_EOL();
 
     #if ENABLED(ULTRA_LCD)
-      lcd_status_printf_P(0, PSTR(MSG_LCD_ENDSTOPS " %c %c %c %c"), chrX, chrY, chrZ, chrP);
+      ui.status_printf_P(0, PSTR(MSG_LCD_ENDSTOPS " %c %c %c %c"), chrX, chrY, chrZ, chrP);
     #endif
 
     #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED) && ENABLED(SDSUPPORT)

commit fd7fd55662f380c9015789e4af939d4a23894553
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Fri Nov 9 21:58:04 2018 +0100

    Solve endstops issues (#12382)
    
    - Partially reverts #11900 and tries to solve #12336

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index e3324d0c19..28e0d92f69 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -260,33 +260,19 @@ void Endstops::poll() {
 void Endstops::enable_globally(const bool onoff) {
   enabled_globally = enabled = onoff;
 
-  #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-    update();
-  #endif
+  update();
 }
 
 // Enable / disable endstop checking
 void Endstops::enable(const bool onoff) {
   enabled = onoff;
 
-  #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-    update();
-  #endif
+  update();
 }
 
 // Disable / Enable endstops based on ENSTOPS_ONLY_FOR_HOMING and global enable
 void Endstops::not_homing() {
   enabled = enabled_globally;
-
-  // Still 'enabled'? Then endstops are always on and kept in sync.
-  // Otherwise reset 'live's variables to let axes move in both directions.
-  if (!enabled) {
-    #if ENDSTOP_NOISE_THRESHOLD
-      endstop_poll_count = 0;   // Stop filtering (MUST be done first to prevent race condition)
-      validated_live_state = 0;
-    #endif
-    live_state = 0;
-  }
 }
 
 #if ENABLED(VALIDATE_HOMING_ENDSTOPS)
@@ -302,9 +288,7 @@ void Endstops::not_homing() {
   void Endstops::enable_z_probe(const bool onoff) {
     z_probe_enabled = onoff;
 
-    #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-      update();
-    #endif
+    update();
   }
 #endif
 

commit 4f72e041f21a5f595209ebc90dc466d910852ecc
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Nov 6 20:53:07 2018 -0600

    Use card.stopSDPrint() for completeness

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 102ba3744b..e3324d0c19 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -358,8 +358,7 @@ void Endstops::event_handler() {
 
     #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED) && ENABLED(SDSUPPORT)
       if (planner.abort_on_endstop_hit) {
-        card.sdprinting = false;
-        card.closefile();
+        card.stopSDPrint();
         quickstop_stepper();
         thermalManager.disable_all_heaters();
         print_job_timer.stop();

commit b7ca93ba37d8236cd4523b6f61120e6b9c6d0f08
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Nov 4 06:07:17 2018 -0600

    Remove dead comment

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 7049edb07c..102ba3744b 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -367,7 +367,7 @@ void Endstops::event_handler() {
     #endif
   }
   prev_hit_state = hit_state;
-} // Endstops::report_state
+}
 
 static void print_es_state(const bool is_hit, PGM_P const label=NULL) {
   if (label) serialprintPGM(label);

commit aa9202260dcf1add950afdb05942f3c0e89d9af4
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Fri Oct 19 20:45:39 2018 +0200

    Fix endstop when no interrupt (#12158)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 3ac7aef31a..7049edb07c 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -278,17 +278,15 @@ void Endstops::enable(const bool onoff) {
 void Endstops::not_homing() {
   enabled = enabled_globally;
 
-  #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-    // Still 'enabled'? Then endstops are always on and kept in sync.
-    // Otherwise reset 'live's variables to let axes move in both directions.
-    if (!enabled) {
-      #if ENDSTOP_NOISE_THRESHOLD
-        endstop_poll_count = 0;   // Stop filtering (MUST be done first to prevent race condition)
-        validated_live_state = 0;
-      #endif
-      live_state = 0;
-    }
-  #endif
+  // Still 'enabled'? Then endstops are always on and kept in sync.
+  // Otherwise reset 'live's variables to let axes move in both directions.
+  if (!enabled) {
+    #if ENDSTOP_NOISE_THRESHOLD
+      endstop_poll_count = 0;   // Stop filtering (MUST be done first to prevent race condition)
+      validated_live_state = 0;
+    #endif
+    live_state = 0;
+  }
 }
 
 #if ENABLED(VALIDATE_HOMING_ENDSTOPS)

commit 71e19baf691a5252841cca5871a29d7a65b62e5f
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Thu Oct 18 20:20:56 2018 -0600

    Fix kill => disable_all_heaters => print_job_timer.stop (#12146)
    
    - Remove `print_job_timer.stop()` from `disable_all_heaters`
    - Call `print_job_timer.stop()` for relevant `disable_all_heaters()`.
    - Split up `kill()` for watchdog interrupt safety

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 0430abb268..3ac7aef31a 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -36,6 +36,10 @@
   #include HAL_PATH(../HAL, endstop_interrupts.h)
 #endif
 
+#if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED) && ENABLED(SDSUPPORT)
+  #include "../module/printcounter.h" // for print_job_timer
+#endif
+
 Endstops endstops;
 
 // public:
@@ -359,7 +363,8 @@ void Endstops::event_handler() {
         card.sdprinting = false;
         card.closefile();
         quickstop_stepper();
-        thermalManager.disable_all_heaters(); // switch off all heaters.
+        thermalManager.disable_all_heaters();
+        print_job_timer.stop();
       }
     #endif
   }

commit 11ac75edcb34a2f90b50ca134ff40839f8c29199
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 30 23:44:33 2018 -0500

    Use PGM_P for PSTR pointers (#11977)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 38f0aae0bf..0430abb268 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -366,7 +366,7 @@ void Endstops::event_handler() {
   prev_hit_state = hit_state;
 } // Endstops::report_state
 
-static void print_es_state(const bool is_hit, const char * const label=NULL) {
+static void print_es_state(const bool is_hit, PGM_P const label=NULL) {
   if (label) serialprintPGM(label);
   SERIAL_PROTOCOLPGM(": ");
   serialprintPGM(is_hit ? PSTR(MSG_ENDSTOP_HIT) : PSTR(MSG_ENDSTOP_OPEN));

commit 23114aeb8114ae3e58e5710eca07cd5201642b9a
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Fri Sep 28 20:00:11 2018 -0400

    Fix garbled M119 output. Honor NUM_RUNOUT_SENSORS (#11948)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index a7e2a57d6e..38f0aae0bf 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -422,42 +422,26 @@ void _O2 Endstops::M119() {
     print_es_state(READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING, PSTR(MSG_Z_PROBE));
   #endif
   #if ENABLED(FILAMENT_RUNOUT_SENSOR)
-    #define FRS_COUNT (1 + PIN_EXISTS(FIL_RUNOUT2) + PIN_EXISTS(FIL_RUNOUT3) + PIN_EXISTS(FIL_RUNOUT4) + PIN_EXISTS(FIL_RUNOUT5) + PIN_EXISTS(FIL_RUNOUT6))
-    #if FRS_COUNT == 1
-      print_es_state(READ(FIL_RUNOUT_PIN) != FIL_RUNOUT_INVERTING, MSG_FILAMENT_RUNOUT_SENSOR);
+    #if NUM_RUNOUT_SENSORS == 1
+      print_es_state(READ(FIL_RUNOUT_PIN) != FIL_RUNOUT_INVERTING, PSTR(MSG_FILAMENT_RUNOUT_SENSOR));
     #else
-      for (uint8_t i = 1; i <=
-        #if   FRS_COUNT == 6
-          6
-        #elif FRS_COUNT == 5
-          5
-        #elif FRS_COUNT == 4
-          4
-        #elif FRS_COUNT == 3
-          3
-        #elif FRS_COUNT == 2
-          2
-        #endif
-        ; i++
-      ) {
+      for (uint8_t i = 1; i <= NUM_RUNOUT_SENSORS; i++) {
         pin_t pin;
         switch (i) {
           default: continue;
           case 1: pin = FIL_RUNOUT_PIN; break;
-          #if PIN_EXISTS(FIL_RUNOUT2)
-            case 2: pin = FIL_RUNOUT2_PIN; break;
-          #endif
-          #if PIN_EXISTS(FIL_RUNOUT3)
+          case 2: pin = FIL_RUNOUT2_PIN; break;
+          #if NUM_RUNOUT_SENSORS > 2
             case 3: pin = FIL_RUNOUT3_PIN; break;
-          #endif
-          #if PIN_EXISTS(FIL_RUNOUT4)
-            case 4: pin = FIL_RUNOUT4_PIN; break;
-          #endif
-          #if PIN_EXISTS(FIL_RUNOUT5)
-            case 5: pin = FIL_RUNOUT5_PIN; break;
-          #endif
-          #if PIN_EXISTS(FIL_RUNOUT6)
-            case 6: pin = FIL_RUNOUT6_PIN; break;
+            #if NUM_RUNOUT_SENSORS > 3
+              case 4: pin = FIL_RUNOUT4_PIN; break;
+              #if NUM_RUNOUT_SENSORS > 4
+                case 5: pin = FIL_RUNOUT5_PIN; break;
+                #if NUM_RUNOUT_SENSORS > 5
+                  case 6: pin = FIL_RUNOUT6_PIN; break;
+                #endif
+              #endif
+            #endif
           #endif
         }
         SERIAL_PROTOCOLPGM(MSG_FILAMENT_RUNOUT_SENSOR);

commit dc1113165601db4675036f52267f8489464107a1
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Tue Sep 25 19:56:57 2018 +0200

    [2.0.x] fix possible race condition (#11923)
    
    Fix some commits done in #11900

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index fb7a36ecb5..a7e2a57d6e 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -279,12 +279,11 @@ void Endstops::not_homing() {
     // Otherwise reset 'live's variables to let axes move in both directions.
     if (!enabled) {
       #if ENDSTOP_NOISE_THRESHOLD
-        endstop_poll_count = validated_live_state = 0; // Stop filtering
+        endstop_poll_count = 0;   // Stop filtering (MUST be done first to prevent race condition)
+        validated_live_state = 0;
       #endif
       live_state = 0;
     }
-  //#else
-    // When in polling endstops are always kept in sync
   #endif
 }
 

commit d6b9327c1119507a7369a72bc322bc6df2730fe9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Sep 25 13:50:49 2018 -0400

    Followup for Endstop Noise Threshold
    
    Followup to #11912

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 93a0001ab8..fb7a36ecb5 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -248,7 +248,7 @@ void Endstops::poll() {
 
   #if DISABLED(ENDSTOP_INTERRUPTS_FEATURE)
     update();
-  #elif ENABLED(ENDSTOP_NOISE_FILTER)
+  #elif ENDSTOP_NOISE_THRESHOLD
     if (endstop_poll_count) update();
   #endif
 }
@@ -278,7 +278,7 @@ void Endstops::not_homing() {
     // Still 'enabled'? Then endstops are always on and kept in sync.
     // Otherwise reset 'live's variables to let axes move in both directions.
     if (!enabled) {
-      #if ENABLED(ENDSTOP_NOISE_FILTER)
+      #if ENDSTOP_NOISE_THRESHOLD
         endstop_poll_count = validated_live_state = 0; // Stop filtering
       #endif
       live_state = 0;

commit 5490a664f51c3466fc171492a7016d21876ab33a
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 24 21:59:12 2018 -0400

    Expose: Homing Validation and Endstop Noise Threshold (#11912)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index dbef281f08..93a0001ab8 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -45,7 +45,7 @@ volatile uint8_t Endstops::hit_state;
 
 Endstops::esbits_t Endstops::live_state = 0;
 
-#if ENABLED(ENDSTOP_NOISE_FILTER)
+#if ENDSTOP_NOISE_THRESHOLD
   Endstops::esbits_t Endstops::validated_live_state;
   uint8_t Endstops::endstop_poll_count;
 #endif
@@ -479,7 +479,7 @@ void _O2 Endstops::M119() {
 // Check endstops - Could be called from Temperature ISR!
 void Endstops::update() {
 
-  #if DISABLED(ENDSTOP_NOISE_FILTER)
+  #if !ENDSTOP_NOISE_THRESHOLD
     if (!abort_enabled()) return;
   #endif
 
@@ -622,7 +622,8 @@ void Endstops::update() {
     #endif
   #endif
 
-  #if ENABLED(ENDSTOP_NOISE_FILTER)
+  #if ENDSTOP_NOISE_THRESHOLD
+
     /**
      * Filtering out noise on endstops requires a delayed decision. Let's assume, due to noise,
      * that 50% of endstop signal samples are good and 50% are bad (assuming normal distribution
@@ -635,7 +636,7 @@ void Endstops::update() {
      */
     static esbits_t old_live_state;
     if (old_live_state != live_state) {
-      endstop_poll_count = 7;
+      endstop_poll_count = ENDSTOP_NOISE_THRESHOLD;
       old_live_state = live_state;
     }
     else if (endstop_poll_count && !--endstop_poll_count)

commit 18e456d38d8625ac13970fbfc4e6bdbb8adefc28
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Mon Sep 24 22:56:01 2018 +0200

    [2.0.x] fix home endstop bug (DON'T MERGE, needs discussion) (#11900)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index f8f6db3d38..dbef281f08 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -246,10 +246,10 @@ void Endstops::poll() {
     run_monitor();  // report changes in endstop status
   #endif
 
-  #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE) && ENABLED(ENDSTOP_NOISE_FILTER)
-    if (endstop_poll_count) update();
-  #elif DISABLED(ENDSTOP_INTERRUPTS_FEATURE) || ENABLED(ENDSTOP_NOISE_FILTER)
+  #if DISABLED(ENDSTOP_INTERRUPTS_FEATURE)
     update();
+  #elif ENABLED(ENDSTOP_NOISE_FILTER)
+    if (endstop_poll_count) update();
   #endif
 }
 
@@ -275,7 +275,16 @@ void Endstops::not_homing() {
   enabled = enabled_globally;
 
   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-    update();
+    // Still 'enabled'? Then endstops are always on and kept in sync.
+    // Otherwise reset 'live's variables to let axes move in both directions.
+    if (!enabled) {
+      #if ENABLED(ENDSTOP_NOISE_FILTER)
+        endstop_poll_count = validated_live_state = 0; // Stop filtering
+      #endif
+      live_state = 0;
+    }
+  //#else
+    // When in polling endstops are always kept in sync
   #endif
 }
 
@@ -666,7 +675,7 @@ void Endstops::update() {
     if (triple_hit) { \
       _ENDSTOP_HIT(AXIS1, MINMAX); \
       /* if not performing home or if both endstops were trigged during homing... */ \
-      if (!stepper.separate_multi_axis || triple_hit == 0x7) \
+      if (!stepper.separate_multi_axis || triple_hit == 0b111) \
         planner.endstop_triggered(_AXIS(AXIS1)); \
     } \
   }while(0)

commit 4163c1a5140c3ef04af1f16e7aa0989893cdffce
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Fri Sep 21 16:45:12 2018 -0500

    Fix end stop and Z-probe reporting logic

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 6801c27098..f8f6db3d38 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -367,7 +367,7 @@ static void print_es_state(const bool is_hit, const char * const label=NULL) {
 
 void _O2 Endstops::M119() {
   SERIAL_PROTOCOLLNPGM(MSG_M119_REPORT);
-  #define ES_REPORT(S) print_es_state(READ(S##_PIN) == S##_ENDSTOP_INVERTING, PSTR(MSG_##S))
+  #define ES_REPORT(S) print_es_state(READ(S##_PIN) != S##_ENDSTOP_INVERTING, PSTR(MSG_##S))
   #if HAS_X_MIN
     ES_REPORT(X_MIN);
   #endif
@@ -411,12 +411,12 @@ void _O2 Endstops::M119() {
     ES_REPORT(Z3_MAX);
   #endif
   #if ENABLED(Z_MIN_PROBE_ENDSTOP)
-    print_es_state(READ(Z_MIN_PROBE_PIN) == Z_MIN_PROBE_ENDSTOP_INVERTING, PSTR(MSG_Z_PROBE));
+    print_es_state(READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING, PSTR(MSG_Z_PROBE));
   #endif
   #if ENABLED(FILAMENT_RUNOUT_SENSOR)
     #define FRS_COUNT (1 + PIN_EXISTS(FIL_RUNOUT2) + PIN_EXISTS(FIL_RUNOUT3) + PIN_EXISTS(FIL_RUNOUT4) + PIN_EXISTS(FIL_RUNOUT5) + PIN_EXISTS(FIL_RUNOUT6))
     #if FRS_COUNT == 1
-      print_es_state(READ(FIL_RUNOUT_PIN) == FIL_RUNOUT_INVERTING, MSG_FILAMENT_RUNOUT_SENSOR);
+      print_es_state(READ(FIL_RUNOUT_PIN) != FIL_RUNOUT_INVERTING, MSG_FILAMENT_RUNOUT_SENSOR);
     #else
       for (uint8_t i = 1; i <=
         #if   FRS_COUNT == 6
@@ -454,7 +454,7 @@ void _O2 Endstops::M119() {
         }
         SERIAL_PROTOCOLPGM(MSG_FILAMENT_RUNOUT_SENSOR);
         if (i > 1) { SERIAL_CHAR(' '); SERIAL_CHAR('0' + i); }
-        print_es_state(digitalRead(pin) == FIL_RUNOUT_INVERTING);
+        print_es_state(digitalRead(pin) != FIL_RUNOUT_INVERTING);
       }
     #endif
   #endif

commit 09a2bee8aaafb8b5a4aa45398e55f0689254f9d6
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 17 03:27:13 2018 -0500

    Support more filament runout sensors in M119 (#11851)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 7b76ea3b30..6801c27098 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -358,12 +358,16 @@ void Endstops::event_handler() {
   prev_hit_state = hit_state;
 } // Endstops::report_state
 
-void Endstops::M119() {
+static void print_es_state(const bool is_hit, const char * const label=NULL) {
+  if (label) serialprintPGM(label);
+  SERIAL_PROTOCOLPGM(": ");
+  serialprintPGM(is_hit ? PSTR(MSG_ENDSTOP_HIT) : PSTR(MSG_ENDSTOP_OPEN));
+  SERIAL_EOL();
+}
+
+void _O2 Endstops::M119() {
   SERIAL_PROTOCOLLNPGM(MSG_M119_REPORT);
-  #define ES_REPORT(AXIS) do{ \
-    SERIAL_PROTOCOLPGM(MSG_##AXIS); \
-    SERIAL_PROTOCOLLN(((READ(AXIS##_PIN)^AXIS##_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN)); \
-  }while(0)
+  #define ES_REPORT(S) print_es_state(READ(S##_PIN) == S##_ENDSTOP_INVERTING, PSTR(MSG_##S))
   #if HAS_X_MIN
     ES_REPORT(X_MIN);
   #endif
@@ -407,12 +411,52 @@ void Endstops::M119() {
     ES_REPORT(Z3_MAX);
   #endif
   #if ENABLED(Z_MIN_PROBE_ENDSTOP)
-    SERIAL_PROTOCOLPGM(MSG_Z_PROBE);
-    SERIAL_PROTOCOLLN(((READ(Z_MIN_PROBE_PIN)^Z_MIN_PROBE_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
+    print_es_state(READ(Z_MIN_PROBE_PIN) == Z_MIN_PROBE_ENDSTOP_INVERTING, PSTR(MSG_Z_PROBE));
   #endif
   #if ENABLED(FILAMENT_RUNOUT_SENSOR)
-    SERIAL_PROTOCOLPGM(MSG_FILAMENT_RUNOUT_SENSOR);
-    SERIAL_PROTOCOLLN(((READ(FIL_RUNOUT_PIN)^FIL_RUNOUT_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
+    #define FRS_COUNT (1 + PIN_EXISTS(FIL_RUNOUT2) + PIN_EXISTS(FIL_RUNOUT3) + PIN_EXISTS(FIL_RUNOUT4) + PIN_EXISTS(FIL_RUNOUT5) + PIN_EXISTS(FIL_RUNOUT6))
+    #if FRS_COUNT == 1
+      print_es_state(READ(FIL_RUNOUT_PIN) == FIL_RUNOUT_INVERTING, MSG_FILAMENT_RUNOUT_SENSOR);
+    #else
+      for (uint8_t i = 1; i <=
+        #if   FRS_COUNT == 6
+          6
+        #elif FRS_COUNT == 5
+          5
+        #elif FRS_COUNT == 4
+          4
+        #elif FRS_COUNT == 3
+          3
+        #elif FRS_COUNT == 2
+          2
+        #endif
+        ; i++
+      ) {
+        pin_t pin;
+        switch (i) {
+          default: continue;
+          case 1: pin = FIL_RUNOUT_PIN; break;
+          #if PIN_EXISTS(FIL_RUNOUT2)
+            case 2: pin = FIL_RUNOUT2_PIN; break;
+          #endif
+          #if PIN_EXISTS(FIL_RUNOUT3)
+            case 3: pin = FIL_RUNOUT3_PIN; break;
+          #endif
+          #if PIN_EXISTS(FIL_RUNOUT4)
+            case 4: pin = FIL_RUNOUT4_PIN; break;
+          #endif
+          #if PIN_EXISTS(FIL_RUNOUT5)
+            case 5: pin = FIL_RUNOUT5_PIN; break;
+          #endif
+          #if PIN_EXISTS(FIL_RUNOUT6)
+            case 6: pin = FIL_RUNOUT6_PIN; break;
+          #endif
+        }
+        SERIAL_PROTOCOLPGM(MSG_FILAMENT_RUNOUT_SENSOR);
+        if (i > 1) { SERIAL_CHAR(' '); SERIAL_CHAR('0' + i); }
+        print_es_state(digitalRead(pin) == FIL_RUNOUT_INVERTING);
+      }
+    #endif
   #endif
 } // Endstops::M119
 

commit 1a6f2b29b8dd3bc8e6ef56d4f376f49cacfc8785
Author: Holger MuÃàller <holger@mueller-gelff.de>
Date:   Tue Jun 19 18:55:49 2018 +0200

    Add support for Triple-Z steppers/endstops

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 68886eb84f..7b76ea3b30 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -56,13 +56,16 @@ Endstops::esbits_t Endstops::live_state = 0;
 
 // Initialized by settings.load()
 #if ENABLED(X_DUAL_ENDSTOPS)
-  float Endstops::x_endstop_adj;
+  float Endstops::x2_endstop_adj;
 #endif
 #if ENABLED(Y_DUAL_ENDSTOPS)
-  float Endstops::y_endstop_adj;
+  float Endstops::y2_endstop_adj;
 #endif
-#if ENABLED(Z_DUAL_ENDSTOPS)
-  float Endstops::z_endstop_adj;
+#if Z_MULTI_ENDSTOPS
+  float Endstops::z2_endstop_adj;
+#endif
+#if ENABLED(Z_TRIPLE_ENDSTOPS)
+  float Endstops::z3_endstop_adj;
 #endif
 
 /**
@@ -131,6 +134,16 @@ void Endstops::init() {
     #endif
   #endif
 
+  #if HAS_Z3_MIN
+    #if ENABLED(ENDSTOPPULLUP_ZMIN)
+      SET_INPUT_PULLUP(Z3_MIN_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_ZMIN)
+      SET_INPUT_PULLDOWN(Z3_MIN_PIN);
+    #else
+      SET_INPUT(Z3_MIN_PIN);
+    #endif
+  #endif
+
   #if HAS_X_MAX
     #if ENABLED(ENDSTOPPULLUP_XMAX)
       SET_INPUT_PULLUP(X_MAX_PIN);
@@ -191,6 +204,16 @@ void Endstops::init() {
     #endif
   #endif
 
+  #if HAS_Z3_MAX
+    #if ENABLED(ENDSTOPPULLUP_ZMAX)
+      SET_INPUT_PULLUP(Z3_MAX_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_ZMAX)
+      SET_INPUT_PULLDOWN(Z3_MAX_PIN);
+    #else
+      SET_INPUT(Z3_MAX_PIN);
+    #endif
+  #endif
+
   #if ENABLED(Z_MIN_PROBE_ENDSTOP)
     #if ENABLED(ENDSTOPPULLUP_ZMIN_PROBE)
       SET_INPUT_PULLUP(Z_MIN_PROBE_PIN);
@@ -371,12 +394,18 @@ void Endstops::M119() {
   #if HAS_Z2_MIN
     ES_REPORT(Z2_MIN);
   #endif
+  #if HAS_Z3_MIN
+    ES_REPORT(Z3_MIN);
+  #endif
   #if HAS_Z_MAX
     ES_REPORT(Z_MAX);
   #endif
   #if HAS_Z2_MAX
     ES_REPORT(Z2_MAX);
   #endif
+  #if HAS_Z3_MAX
+    ES_REPORT(Z3_MAX);
+  #endif
   #if ENABLED(Z_MIN_PROBE_ENDSTOP)
     SERIAL_PROTOCOLPGM(MSG_Z_PROBE);
     SERIAL_PROTOCOLLN(((READ(Z_MIN_PROBE_PIN)^Z_MIN_PROBE_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
@@ -492,13 +521,20 @@ void Endstops::update() {
   #endif
 
   #if HAS_Z_MIN
-    #if ENABLED(Z_DUAL_ENDSTOPS)
+    #if Z_MULTI_ENDSTOPS
       UPDATE_ENDSTOP_BIT(Z, MIN);
       #if HAS_Z2_MIN
         UPDATE_ENDSTOP_BIT(Z2, MIN);
       #else
         COPY_LIVE_STATE(Z_MIN, Z2_MIN);
       #endif
+      #if ENABLED(Z_TRIPLE_ENDSTOPS)
+        #if HAS_Z3_MIN
+          UPDATE_ENDSTOP_BIT(Z3, MIN);
+        #else
+          COPY_LIVE_STATE(Z_MIN, Z3_MIN);
+        #endif
+      #endif
     #elif ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
       UPDATE_ENDSTOP_BIT(Z, MIN);
     #elif Z_HOME_DIR < 0
@@ -513,13 +549,20 @@ void Endstops::update() {
 
   #if HAS_Z_MAX
     // Check both Z dual endstops
-    #if ENABLED(Z_DUAL_ENDSTOPS)
+    #if Z_MULTI_ENDSTOPS
       UPDATE_ENDSTOP_BIT(Z, MAX);
       #if HAS_Z2_MAX
         UPDATE_ENDSTOP_BIT(Z2, MAX);
       #else
         COPY_LIVE_STATE(Z_MAX, Z2_MAX);
       #endif
+      #if ENABLED(Z_TRIPLE_ENDSTOPS)
+        #if HAS_Z3_MAX
+          UPDATE_ENDSTOP_BIT(Z3, MAX);
+        #else
+          COPY_LIVE_STATE(Z_MAX, Z3_MAX);
+        #endif
+      #endif
     #elif DISABLED(Z_MIN_PROBE_ENDSTOP) || Z_MAX_PIN != Z_MIN_PROBE_PIN
       // If this pin isn't the bed probe it's the Z endstop
       UPDATE_ENDSTOP_BIT(Z, MAX);
@@ -569,7 +612,17 @@ void Endstops::update() {
     if (dual_hit) { \
       _ENDSTOP_HIT(AXIS1, MINMAX); \
       /* if not performing home or if both endstops were trigged during homing... */ \
-      if (!stepper.homing_dual_axis || dual_hit == 0b11) \
+      if (!stepper.separate_multi_axis || dual_hit == 0b11) \
+        planner.endstop_triggered(_AXIS(AXIS1)); \
+    } \
+  }while(0)
+
+  #define PROCESS_TRIPLE_ENDSTOP(AXIS1, AXIS2, AXIS3, MINMAX) do { \
+    const byte triple_hit = TEST_ENDSTOP(_ENDSTOP(AXIS1, MINMAX)) | (TEST_ENDSTOP(_ENDSTOP(AXIS2, MINMAX)) << 1) | (TEST_ENDSTOP(_ENDSTOP(AXIS3, MINMAX)) << 2); \
+    if (triple_hit) { \
+      _ENDSTOP_HIT(AXIS1, MINMAX); \
+      /* if not performing home or if both endstops were trigged during homing... */ \
+      if (!stepper.separate_multi_axis || triple_hit == 0x7) \
         planner.endstop_triggered(_AXIS(AXIS1)); \
     } \
   }while(0)
@@ -632,7 +685,9 @@ void Endstops::update() {
   if (stepper.axis_is_moving(Z_AXIS)) {
     if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
       #if HAS_Z_MIN
-        #if ENABLED(Z_DUAL_ENDSTOPS)
+        #if ENABLED(Z_TRIPLE_ENDSTOPS)
+          PROCESS_TRIPLE_ENDSTOP(Z, Z2, Z3, MIN);
+        #elif ENABLED(Z_DUAL_ENDSTOPS)
           PROCESS_DUAL_ENDSTOP(Z, Z2, MIN);
         #else
           #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
@@ -652,7 +707,9 @@ void Endstops::update() {
     }
     else { // Z +direction. Gantry up, bed down.
       #if HAS_Z_MAX
-        #if ENABLED(Z_DUAL_ENDSTOPS)
+        #if ENABLED(Z_TRIPLE_ENDSTOPS)
+          PROCESS_TRIPLE_ENDSTOP(Z, Z2, Z3, MAX);
+        #elif ENABLED(Z_DUAL_ENDSTOPS)
           PROCESS_DUAL_ENDSTOP(Z, Z2, MAX);
         #elif DISABLED(Z_MIN_PROBE_ENDSTOP) || Z_MAX_PIN != Z_MIN_PROBE_PIN
           // If this pin is not hijacked for the bed probe
@@ -723,6 +780,12 @@ void Endstops::update() {
     #if HAS_Z2_MAX
       if (READ(Z2_MAX_PIN)) SBI(live_state_local, Z2_MAX);
     #endif
+    #if HAS_Z3_MIN
+      if (READ(Z3_MIN_PIN)) SBI(live_state_local, Z3_MIN);
+    #endif
+    #if HAS_Z3_MAX
+      if (READ(Z3_MAX_PIN)) SBI(live_state_local, Z3_MAX);
+    #endif
 
     uint16_t endstop_change = live_state_local ^ old_live_state_local;
 
@@ -766,6 +829,12 @@ void Endstops::update() {
       #if HAS_Z2_MAX
         if (TEST(endstop_change, Z2_MAX)) SERIAL_PROTOCOLPAIR("  Z2_MAX:", TEST(live_state_local, Z2_MAX));
       #endif
+      #if HAS_Z3_MIN
+        if (TEST(endstop_change, Z3_MIN)) SERIAL_PROTOCOLPAIR("  Z3_MIN:", TEST(live_state_local, Z3_MIN));
+      #endif
+      #if HAS_Z3_MAX
+        if (TEST(endstop_change, Z3_MAX)) SERIAL_PROTOCOLPAIR("  Z3_MAX:", TEST(live_state_local, Z3_MAX));
+      #endif
       SERIAL_PROTOCOLPGM("\n\n");
       analogWrite(LED_PIN, local_LED_status);
       local_LED_status ^= 255;

commit 79835590e3009487d606c7de8de6a7e07095ea6b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Aug 6 23:11:37 2018 -0500

    Easier to disable homing validation (#11458)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index cecd303531..68886eb84f 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -256,11 +256,13 @@ void Endstops::not_homing() {
   #endif
 }
 
-// If the last move failed to trigger an endstop, call kill
-void Endstops::validate_homing_move() {
-  if (trigger_state()) hit_on_purpose();
-  else kill(PSTR(MSG_ERR_HOMING_FAILED));
-}
+#if ENABLED(VALIDATE_HOMING_ENDSTOPS)
+  // If the last move failed to trigger an endstop, call kill
+  void Endstops::validate_homing_move() {
+    if (trigger_state()) hit_on_purpose();
+    else kill(PSTR(MSG_ERR_HOMING_FAILED));
+  }
+#endif
 
 // Enable / disable endstop z-probe checking
 #if HAS_BED_PROBE

commit 566d05006da2ef30f0409664bf21b6211e1daf83
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jul 11 17:33:26 2018 -0500

    report_state > event_handler
    
    Make the endstop report method track endstop changes on its own.

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 5e9940a090..cecd303531 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -216,7 +216,7 @@ void Endstops::init() {
 
 } // Endstops::init
 
-// Called from ISR: Poll endstop state if required
+// Called at ~1KHz from Temperature ISR: Poll endstop state if required
 void Endstops::poll() {
 
   #if ENABLED(PINS_DEBUGGING)
@@ -258,8 +258,8 @@ void Endstops::not_homing() {
 
 // If the last move failed to trigger an endstop, call kill
 void Endstops::validate_homing_move() {
-  if (!trigger_state()) kill(PSTR(MSG_ERR_HOMING_FAILED));
-  hit_on_purpose();
+  if (trigger_state()) hit_on_purpose();
+  else kill(PSTR(MSG_ERR_HOMING_FAILED));
 }
 
 // Enable / disable endstop z-probe checking
@@ -283,8 +283,9 @@ void Endstops::validate_homing_move() {
   }
 #endif
 
-void Endstops::report_state() {
-  if (hit_state) {
+void Endstops::event_handler() {
+  static uint8_t prev_hit_state; // = 0
+  if (hit_state && hit_state != prev_hit_state) {
     #if ENABLED(ULTRA_LCD)
       char chrX = ' ', chrY = ' ', chrZ = ' ', chrP = ' ';
       #define _SET_STOP_CHAR(A,C) (chr## A = C)
@@ -320,8 +321,6 @@ void Endstops::report_state() {
       lcd_status_printf_P(0, PSTR(MSG_LCD_ENDSTOPS " %c %c %c %c"), chrX, chrY, chrZ, chrP);
     #endif
 
-    hit_on_purpose();
-
     #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED) && ENABLED(SDSUPPORT)
       if (planner.abort_on_endstop_hit) {
         card.sdprinting = false;
@@ -331,6 +330,7 @@ void Endstops::report_state() {
       }
     #endif
   }
+  prev_hit_state = hit_state;
 } // Endstops::report_state
 
 void Endstops::M119() {
@@ -392,7 +392,7 @@ void Endstops::M119() {
 #define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN
 #define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_INVERTING
 
-// Check endstops - Could be called from ISR!
+// Check endstops - Could be called from Temperature ISR!
 void Endstops::update() {
 
   #if DISABLED(ENDSTOP_NOISE_FILTER)
@@ -567,7 +567,7 @@ void Endstops::update() {
     if (dual_hit) { \
       _ENDSTOP_HIT(AXIS1, MINMAX); \
       /* if not performing home or if both endstops were trigged during homing... */ \
-      if (!stepper.homing_dual_axis || dual_hit == 0x3) \
+      if (!stepper.homing_dual_axis || dual_hit == 0b11) \
         planner.endstop_triggered(_AXIS(AXIS1)); \
     } \
   }while(0)

commit c51e27d11d9ff0b7ed0c50d4895db322659023d4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jun 30 21:54:07 2018 -0500

    Do a hard kill for failed homing moves (#11161)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 6da2f68e95..5e9940a090 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -256,6 +256,12 @@ void Endstops::not_homing() {
   #endif
 }
 
+// If the last move failed to trigger an endstop, call kill
+void Endstops::validate_homing_move() {
+  if (!trigger_state()) kill(PSTR(MSG_ERR_HOMING_FAILED));
+  hit_on_purpose();
+}
+
 // Enable / disable endstop z-probe checking
 #if HAS_BED_PROBE
   void Endstops::enable_z_probe(const bool onoff) {

commit 2421f3a47d111209aa0890f6f6710bf43056d568
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Jun 30 17:27:37 2018 -0500

    Detect endstop hits in any direction

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 21f5320f83..6da2f68e95 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -432,7 +432,7 @@ void Endstops::update() {
    * Check and update endstops
    */
   #if HAS_X_MIN
-    #if ENABLED(X_DUAL_ENDSTOPS) && X_HOME_DIR < 0
+    #if ENABLED(X_DUAL_ENDSTOPS)
       UPDATE_ENDSTOP_BIT(X, MIN);
       #if HAS_X2_MIN
         UPDATE_ENDSTOP_BIT(X2, MIN);
@@ -445,7 +445,7 @@ void Endstops::update() {
   #endif
 
   #if HAS_X_MAX
-    #if ENABLED(X_DUAL_ENDSTOPS) && X_HOME_DIR > 0
+    #if ENABLED(X_DUAL_ENDSTOPS)
       UPDATE_ENDSTOP_BIT(X, MAX);
       #if HAS_X2_MAX
         UPDATE_ENDSTOP_BIT(X2, MAX);
@@ -457,7 +457,7 @@ void Endstops::update() {
     #endif
   #endif
 
-  #if HAS_Y_MIN && Y_HOME_DIR < 0
+  #if HAS_Y_MIN
     #if ENABLED(Y_DUAL_ENDSTOPS)
       UPDATE_ENDSTOP_BIT(Y, MIN);
       #if HAS_Y2_MIN
@@ -470,7 +470,7 @@ void Endstops::update() {
     #endif
   #endif
 
-  #if HAS_Y_MAX && Y_HOME_DIR > 0
+  #if HAS_Y_MAX
     #if ENABLED(Y_DUAL_ENDSTOPS)
       UPDATE_ENDSTOP_BIT(Y, MAX);
       #if HAS_Y2_MAX
@@ -484,7 +484,7 @@ void Endstops::update() {
   #endif
 
   #if HAS_Z_MIN
-    #if ENABLED(Z_DUAL_ENDSTOPS) && Z_HOME_DIR < 0
+    #if ENABLED(Z_DUAL_ENDSTOPS)
       UPDATE_ENDSTOP_BIT(Z, MIN);
       #if HAS_Z2_MIN
         UPDATE_ENDSTOP_BIT(Z2, MIN);
@@ -503,7 +503,7 @@ void Endstops::update() {
     UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
   #endif
 
-  #if HAS_Z_MAX && Z_HOME_DIR > 0
+  #if HAS_Z_MAX
     // Check both Z dual endstops
     #if ENABLED(Z_DUAL_ENDSTOPS)
       UPDATE_ENDSTOP_BIT(Z, MAX);

commit 42f99214822cee44279d34e6523b539e057de385
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 28 05:06:11 2018 -0500

    Ignore Z min endstop with separate Z-probe
    
    To allow for the case where a Z endstop (e.g., hall effect) is higher than the probe trigger point, don't check the Z min endstop during probe moves. See #11134

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 6770286aee..21f5320f83 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -629,6 +629,8 @@ void Endstops::update() {
         #else
           #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
             if (z_probe_enabled) PROCESS_ENDSTOP(Z, MIN);
+          #elif ENABLED(Z_MIN_PROBE_ENDSTOP)
+            if (!z_probe_enabled) PROCESS_ENDSTOP(Z, MIN);
           #else
             PROCESS_ENDSTOP(Z, MIN);
           #endif

commit 053438a3aa1b6b8318f84f4a9105d39c3a0be46a
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jun 27 04:18:57 2018 -0400

    Poll all endstops, even when stationary (#11123)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 0b3baf5dc2..6770286aee 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -429,109 +429,94 @@ void Endstops::update() {
   #endif
 
   /**
-   * Check and update endstops according to conditions
+   * Check and update endstops
    */
-  if (stepper.axis_is_moving(X_AXIS)) {
-    if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
-      #if HAS_X_MIN
-        #if ENABLED(X_DUAL_ENDSTOPS) && X_HOME_DIR < 0
-          UPDATE_ENDSTOP_BIT(X, MIN);
-          #if HAS_X2_MIN
-            UPDATE_ENDSTOP_BIT(X2, MIN);
-          #else
-            COPY_LIVE_STATE(X_MIN, X2_MIN);
-          #endif
-        #else
-          if (X_MIN_TEST) UPDATE_ENDSTOP_BIT(X, MIN);
-        #endif
-      #endif
-    }
-    else { // +direction
-      #if HAS_X_MAX
-        #if ENABLED(X_DUAL_ENDSTOPS) && X_HOME_DIR > 0
-          UPDATE_ENDSTOP_BIT(X, MAX);
-          #if HAS_X2_MAX
-            UPDATE_ENDSTOP_BIT(X2, MAX);
-          #else
-            COPY_LIVE_STATE(X_MAX, X2_MAX);
-          #endif
-        #else
-          if (X_MAX_TEST) UPDATE_ENDSTOP_BIT(X, MAX);
-        #endif
+  #if HAS_X_MIN
+    #if ENABLED(X_DUAL_ENDSTOPS) && X_HOME_DIR < 0
+      UPDATE_ENDSTOP_BIT(X, MIN);
+      #if HAS_X2_MIN
+        UPDATE_ENDSTOP_BIT(X2, MIN);
+      #else
+        COPY_LIVE_STATE(X_MIN, X2_MIN);
       #endif
-    }
-  }
+    #else
+      UPDATE_ENDSTOP_BIT(X, MIN);
+    #endif
+  #endif
 
-  if (stepper.axis_is_moving(Y_AXIS)) {
-    if (stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
-      #if HAS_Y_MIN && Y_HOME_DIR < 0
-        #if ENABLED(Y_DUAL_ENDSTOPS)
-          UPDATE_ENDSTOP_BIT(Y, MIN);
-          #if HAS_Y2_MIN
-            UPDATE_ENDSTOP_BIT(Y2, MIN);
-          #else
-            COPY_LIVE_STATE(Y_MIN, Y2_MIN);
-          #endif
-        #else
-          UPDATE_ENDSTOP_BIT(Y, MIN);
-        #endif
+  #if HAS_X_MAX
+    #if ENABLED(X_DUAL_ENDSTOPS) && X_HOME_DIR > 0
+      UPDATE_ENDSTOP_BIT(X, MAX);
+      #if HAS_X2_MAX
+        UPDATE_ENDSTOP_BIT(X2, MAX);
+      #else
+        COPY_LIVE_STATE(X_MAX, X2_MAX);
       #endif
-    }
-    else { // +direction
-      #if HAS_Y_MAX && Y_HOME_DIR > 0
-        #if ENABLED(Y_DUAL_ENDSTOPS)
-          UPDATE_ENDSTOP_BIT(Y, MAX);
-          #if HAS_Y2_MAX
-            UPDATE_ENDSTOP_BIT(Y2, MAX);
-          #else
-            COPY_LIVE_STATE(Y_MAX, Y2_MAX);
-          #endif
-        #else
-          UPDATE_ENDSTOP_BIT(Y, MAX);
-        #endif
+    #else
+      UPDATE_ENDSTOP_BIT(X, MAX);
+    #endif
+  #endif
+
+  #if HAS_Y_MIN && Y_HOME_DIR < 0
+    #if ENABLED(Y_DUAL_ENDSTOPS)
+      UPDATE_ENDSTOP_BIT(Y, MIN);
+      #if HAS_Y2_MIN
+        UPDATE_ENDSTOP_BIT(Y2, MIN);
+      #else
+        COPY_LIVE_STATE(Y_MIN, Y2_MIN);
       #endif
-    }
-  }
+    #else
+      UPDATE_ENDSTOP_BIT(Y, MIN);
+    #endif
+  #endif
 
-  if (stepper.axis_is_moving(Z_AXIS)) {
-    if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
-      #if HAS_Z_MIN
-        #if ENABLED(Z_DUAL_ENDSTOPS) && Z_HOME_DIR < 0
-          UPDATE_ENDSTOP_BIT(Z, MIN);
-          #if HAS_Z2_MIN
-            UPDATE_ENDSTOP_BIT(Z2, MIN);
-          #else
-            COPY_LIVE_STATE(Z_MIN, Z2_MIN);
-          #endif
-        #elif ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
-          if (z_probe_enabled) UPDATE_ENDSTOP_BIT(Z, MIN);
-        #elif Z_HOME_DIR < 0
-          UPDATE_ENDSTOP_BIT(Z, MIN);
-        #endif
+  #if HAS_Y_MAX && Y_HOME_DIR > 0
+    #if ENABLED(Y_DUAL_ENDSTOPS)
+      UPDATE_ENDSTOP_BIT(Y, MAX);
+      #if HAS_Y2_MAX
+        UPDATE_ENDSTOP_BIT(Y2, MAX);
+      #else
+        COPY_LIVE_STATE(Y_MAX, Y2_MAX);
       #endif
+    #else
+      UPDATE_ENDSTOP_BIT(Y, MAX);
+    #endif
+  #endif
 
-      // When closing the gap check the enabled probe
-      #if ENABLED(Z_MIN_PROBE_ENDSTOP)
-        if (z_probe_enabled) UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
+  #if HAS_Z_MIN
+    #if ENABLED(Z_DUAL_ENDSTOPS) && Z_HOME_DIR < 0
+      UPDATE_ENDSTOP_BIT(Z, MIN);
+      #if HAS_Z2_MIN
+        UPDATE_ENDSTOP_BIT(Z2, MIN);
+      #else
+        COPY_LIVE_STATE(Z_MIN, Z2_MIN);
       #endif
-    }
-    else { // Z +direction. Gantry up, bed down.
-      #if HAS_Z_MAX && Z_HOME_DIR > 0
-        // Check both Z dual endstops
-        #if ENABLED(Z_DUAL_ENDSTOPS)
-          UPDATE_ENDSTOP_BIT(Z, MAX);
-          #if HAS_Z2_MAX
-            UPDATE_ENDSTOP_BIT(Z2, MAX);
-          #else
-            COPY_LIVE_STATE(Z_MAX, Z2_MAX);
-          #endif
-        #elif DISABLED(Z_MIN_PROBE_ENDSTOP) || Z_MAX_PIN != Z_MIN_PROBE_PIN
-          // If this pin isn't the bed probe it's the Z endstop
-          UPDATE_ENDSTOP_BIT(Z, MAX);
-        #endif
+    #elif ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
+      UPDATE_ENDSTOP_BIT(Z, MIN);
+    #elif Z_HOME_DIR < 0
+      UPDATE_ENDSTOP_BIT(Z, MIN);
+    #endif
+  #endif
+
+  // When closing the gap check the enabled probe
+  #if ENABLED(Z_MIN_PROBE_ENDSTOP)
+    UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
+  #endif
+
+  #if HAS_Z_MAX && Z_HOME_DIR > 0
+    // Check both Z dual endstops
+    #if ENABLED(Z_DUAL_ENDSTOPS)
+      UPDATE_ENDSTOP_BIT(Z, MAX);
+      #if HAS_Z2_MAX
+        UPDATE_ENDSTOP_BIT(Z2, MAX);
+      #else
+        COPY_LIVE_STATE(Z_MAX, Z2_MAX);
       #endif
-    }
-  }
+    #elif DISABLED(Z_MIN_PROBE_ENDSTOP) || Z_MAX_PIN != Z_MIN_PROBE_PIN
+      // If this pin isn't the bed probe it's the Z endstop
+      UPDATE_ENDSTOP_BIT(Z, MAX);
+    #endif
+  #endif
 
   #if ENABLED(ENDSTOP_NOISE_FILTER)
     /**

commit 99591dc20cbe6f998850e3b42b5f13e7789ff837
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jun 21 20:14:16 2018 -0500

    Filter endstops state at all times (#11066)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index acf0be796b..0b3baf5dc2 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -36,12 +36,6 @@
   #include HAL_PATH(../HAL, endstop_interrupts.h)
 #endif
 
-#if HAS_BED_PROBE
-  #define ENDSTOPS_ENABLED  (enabled || z_probe_enabled)
-#else
-  #define ENDSTOPS_ENABLED  enabled
-#endif
-
 Endstops endstops;
 
 // public:
@@ -50,9 +44,9 @@ bool Endstops::enabled, Endstops::enabled_globally; // Initialized by settings.l
 volatile uint8_t Endstops::hit_state;
 
 Endstops::esbits_t Endstops::live_state = 0;
+
 #if ENABLED(ENDSTOP_NOISE_FILTER)
-  Endstops::esbits_t Endstops::old_live_state,
-                     Endstops::validated_live_state;
+  Endstops::esbits_t Endstops::validated_live_state;
   uint8_t Endstops::endstop_poll_count;
 #endif
 
@@ -222,9 +216,6 @@ void Endstops::init() {
 
 } // Endstops::init
 
-// Called from ISR. A change was detected. Find out what happened!
-void Endstops::check_possible_change() { if (ENDSTOPS_ENABLED) update(); }
-
 // Called from ISR: Poll endstop state if required
 void Endstops::poll() {
 
@@ -232,8 +223,10 @@ void Endstops::poll() {
     run_monitor();  // report changes in endstop status
   #endif
 
-  #if DISABLED(ENDSTOP_INTERRUPTS_FEATURE) || ENABLED(ENDSTOP_NOISE_FILTER)
-    if (ENDSTOPS_ENABLED) update();
+  #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE) && ENABLED(ENDSTOP_NOISE_FILTER)
+    if (endstop_poll_count) update();
+  #elif DISABLED(ENDSTOP_INTERRUPTS_FEATURE) || ENABLED(ENDSTOP_NOISE_FILTER)
+    update();
   #endif
 }
 
@@ -241,7 +234,7 @@ void Endstops::enable_globally(const bool onoff) {
   enabled_globally = enabled = onoff;
 
   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-    if (onoff) update(); // If enabling, update state now
+    update();
   #endif
 }
 
@@ -250,7 +243,7 @@ void Endstops::enable(const bool onoff) {
   enabled = onoff;
 
   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-    if (onoff) update(); // If enabling, update state now
+    update();
   #endif
 }
 
@@ -259,7 +252,7 @@ void Endstops::not_homing() {
   enabled = enabled_globally;
 
   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-    if (enabled) update(); // If enabling, update state now
+    update();
   #endif
 }
 
@@ -269,7 +262,7 @@ void Endstops::not_homing() {
     z_probe_enabled = onoff;
 
     #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-      if (enabled) update(); // If enabling, update state now
+      update();
     #endif
   }
 #endif
@@ -396,10 +389,12 @@ void Endstops::M119() {
 // Check endstops - Could be called from ISR!
 void Endstops::update() {
 
-  // UPDATE_ENDSTOP_BIT: set the current endstop bits for an endstop to its status
+  #if DISABLED(ENDSTOP_NOISE_FILTER)
+    if (!abort_enabled()) return;
+  #endif
+
   #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT_TO(live_state, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
-  // COPY_BIT: copy the value of SRC_BIT to DST_BIT in DST
-  #define COPY_BIT(DST, SRC_BIT, DST_BIT) SET_BIT_TO(DST, DST_BIT, TEST(DST, SRC_BIT))
+  #define COPY_LIVE_STATE(SRC_BIT, DST_BIT) SET_BIT_TO(live_state, DST_BIT, TEST(live_state, SRC_BIT))
 
   #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && !(CORE_IS_XY || CORE_IS_XZ)
     // If G38 command is active check Z_MIN_PROBE for ALL movement
@@ -444,7 +439,7 @@ void Endstops::update() {
           #if HAS_X2_MIN
             UPDATE_ENDSTOP_BIT(X2, MIN);
           #else
-            COPY_BIT(live_state, X_MIN, X2_MIN);
+            COPY_LIVE_STATE(X_MIN, X2_MIN);
           #endif
         #else
           if (X_MIN_TEST) UPDATE_ENDSTOP_BIT(X, MIN);
@@ -458,7 +453,7 @@ void Endstops::update() {
           #if HAS_X2_MAX
             UPDATE_ENDSTOP_BIT(X2, MAX);
           #else
-            COPY_BIT(live_state, X_MAX, X2_MAX);
+            COPY_LIVE_STATE(X_MAX, X2_MAX);
           #endif
         #else
           if (X_MAX_TEST) UPDATE_ENDSTOP_BIT(X, MAX);
@@ -475,7 +470,7 @@ void Endstops::update() {
           #if HAS_Y2_MIN
             UPDATE_ENDSTOP_BIT(Y2, MIN);
           #else
-            COPY_BIT(live_state, Y_MIN, Y2_MIN);
+            COPY_LIVE_STATE(Y_MIN, Y2_MIN);
           #endif
         #else
           UPDATE_ENDSTOP_BIT(Y, MIN);
@@ -489,7 +484,7 @@ void Endstops::update() {
           #if HAS_Y2_MAX
             UPDATE_ENDSTOP_BIT(Y2, MAX);
           #else
-            COPY_BIT(live_state, Y_MAX, Y2_MAX);
+            COPY_LIVE_STATE(Y_MAX, Y2_MAX);
           #endif
         #else
           UPDATE_ENDSTOP_BIT(Y, MAX);
@@ -506,7 +501,7 @@ void Endstops::update() {
           #if HAS_Z2_MIN
             UPDATE_ENDSTOP_BIT(Z2, MIN);
           #else
-            COPY_BIT(live_state, Z_MIN, Z2_MIN);
+            COPY_LIVE_STATE(Z_MIN, Z2_MIN);
           #endif
         #elif ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
           if (z_probe_enabled) UPDATE_ENDSTOP_BIT(Z, MIN);
@@ -528,7 +523,7 @@ void Endstops::update() {
           #if HAS_Z2_MAX
             UPDATE_ENDSTOP_BIT(Z2, MAX);
           #else
-            COPY_BIT(live_state, Z_MAX, Z2_MAX);
+            COPY_LIVE_STATE(Z_MAX, Z2_MAX);
           #endif
         #elif DISABLED(Z_MIN_PROBE_ENDSTOP) || Z_MAX_PIN != Z_MIN_PROBE_PIN
           // If this pin isn't the bed probe it's the Z endstop
@@ -538,36 +533,31 @@ void Endstops::update() {
     }
   }
 
-  // All endstops were updated.
   #if ENABLED(ENDSTOP_NOISE_FILTER)
-    if (old_live_state != live_state) { // We detected a change. Reinit the timeout
-      /**
-       * Filtering out noise on endstops requires a delayed decision. Let's assume, due to noise,
-       * that 50% of endstop signal samples are good and 50% are bad (assuming normal distribution
-       * of random noise). Then the first sample has a 50% chance to be good or bad. The 2nd sample
-       * also has a 50% chance to be good or bad. The chances of 2 samples both being bad becomes
-       * 50% of 50%, or 25%. That was the previous implementation of Marlin endstop handling. It
-       * reduces chances of bad readings in half, at the cost of 1 extra sample period, but chances
-       * still exist. The only way to reduce them further is to increase the number of samples.
-       * To reduce the chance to 1% (1/128th) requires 7 samples (adding 7ms of delay).
-       */
+    /**
+     * Filtering out noise on endstops requires a delayed decision. Let's assume, due to noise,
+     * that 50% of endstop signal samples are good and 50% are bad (assuming normal distribution
+     * of random noise). Then the first sample has a 50% chance to be good or bad. The 2nd sample
+     * also has a 50% chance to be good or bad. The chances of 2 samples both being bad becomes
+     * 50% of 50%, or 25%. That was the previous implementation of Marlin endstop handling. It
+     * reduces chances of bad readings in half, at the cost of 1 extra sample period, but chances
+     * still exist. The only way to reduce them further is to increase the number of samples.
+     * To reduce the chance to 1% (1/128th) requires 7 samples (adding 7ms of delay).
+     */
+    static esbits_t old_live_state;
+    if (old_live_state != live_state) {
       endstop_poll_count = 7;
       old_live_state = live_state;
     }
     else if (endstop_poll_count && !--endstop_poll_count)
       validated_live_state = live_state;
 
-  #else
-
-    // Lets accept the new endstop values as valid - We assume hardware filtering of lines
-    esbits_t validated_live_state = live_state;
+    if (!abort_enabled()) return;
 
   #endif
 
-  // Endstop readings are validated in validated_live_state
-
   // Test the current status of an endstop
-  #define TEST_ENDSTOP(ENDSTOP) (TEST(validated_live_state, ENDSTOP))
+  #define TEST_ENDSTOP(ENDSTOP) (TEST(state(), ENDSTOP))
 
   // Record endstop was hit
   #define _ENDSTOP_HIT(AXIS, MINMAX) SBI(hit_state, _ENDSTOP(AXIS, MINMAX))

commit 4c8d6df13c70af8505c2b58796699aa74a303235
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jun 13 01:22:02 2018 -0500

    Extra insurance against endstop false positives (#11013)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index d6842a5800..acf0be796b 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -265,7 +265,7 @@ void Endstops::not_homing() {
 
 // Enable / disable endstop z-probe checking
 #if HAS_BED_PROBE
-  void Endstops::enable_z_probe(bool onoff) {
+  void Endstops::enable_z_probe(const bool onoff) {
     z_probe_enabled = onoff;
 
     #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
@@ -439,7 +439,7 @@ void Endstops::update() {
   if (stepper.axis_is_moving(X_AXIS)) {
     if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
       #if HAS_X_MIN
-        #if ENABLED(X_DUAL_ENDSTOPS)
+        #if ENABLED(X_DUAL_ENDSTOPS) && X_HOME_DIR < 0
           UPDATE_ENDSTOP_BIT(X, MIN);
           #if HAS_X2_MIN
             UPDATE_ENDSTOP_BIT(X2, MIN);
@@ -453,7 +453,7 @@ void Endstops::update() {
     }
     else { // +direction
       #if HAS_X_MAX
-        #if ENABLED(X_DUAL_ENDSTOPS)
+        #if ENABLED(X_DUAL_ENDSTOPS) && X_HOME_DIR > 0
           UPDATE_ENDSTOP_BIT(X, MAX);
           #if HAS_X2_MAX
             UPDATE_ENDSTOP_BIT(X2, MAX);
@@ -469,7 +469,7 @@ void Endstops::update() {
 
   if (stepper.axis_is_moving(Y_AXIS)) {
     if (stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
-      #if HAS_Y_MIN
+      #if HAS_Y_MIN && Y_HOME_DIR < 0
         #if ENABLED(Y_DUAL_ENDSTOPS)
           UPDATE_ENDSTOP_BIT(Y, MIN);
           #if HAS_Y2_MIN
@@ -483,7 +483,7 @@ void Endstops::update() {
       #endif
     }
     else { // +direction
-      #if HAS_Y_MAX
+      #if HAS_Y_MAX && Y_HOME_DIR > 0
         #if ENABLED(Y_DUAL_ENDSTOPS)
           UPDATE_ENDSTOP_BIT(Y, MAX);
           #if HAS_Y2_MAX
@@ -501,19 +501,17 @@ void Endstops::update() {
   if (stepper.axis_is_moving(Z_AXIS)) {
     if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
       #if HAS_Z_MIN
-        #if ENABLED(Z_DUAL_ENDSTOPS)
+        #if ENABLED(Z_DUAL_ENDSTOPS) && Z_HOME_DIR < 0
           UPDATE_ENDSTOP_BIT(Z, MIN);
           #if HAS_Z2_MIN
             UPDATE_ENDSTOP_BIT(Z2, MIN);
           #else
             COPY_BIT(live_state, Z_MIN, Z2_MIN);
           #endif
-        #else
-          #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
-            if (z_probe_enabled) UPDATE_ENDSTOP_BIT(Z, MIN);
-          #else
-            UPDATE_ENDSTOP_BIT(Z, MIN);
-          #endif
+        #elif ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
+          if (z_probe_enabled) UPDATE_ENDSTOP_BIT(Z, MIN);
+        #elif Z_HOME_DIR < 0
+          UPDATE_ENDSTOP_BIT(Z, MIN);
         #endif
       #endif
 
@@ -523,7 +521,7 @@ void Endstops::update() {
       #endif
     }
     else { // Z +direction. Gantry up, bed down.
-      #if HAS_Z_MAX
+      #if HAS_Z_MAX && Z_HOME_DIR > 0
         // Check both Z dual endstops
         #if ENABLED(Z_DUAL_ENDSTOPS)
           UPDATE_ENDSTOP_BIT(Z, MAX);
@@ -532,9 +530,8 @@ void Endstops::update() {
           #else
             COPY_BIT(live_state, Z_MAX, Z2_MAX);
           #endif
-        // If this pin is not hijacked for the bed probe
-        // then it belongs to the Z endstop
         #elif DISABLED(Z_MIN_PROBE_ENDSTOP) || Z_MAX_PIN != Z_MIN_PROBE_PIN
+          // If this pin isn't the bed probe it's the Z endstop
           UPDATE_ENDSTOP_BIT(Z, MAX);
         #endif
       #endif

commit ad8d3150aa4d6b792b5e06a63d2645991136fc50
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Jun 2 20:39:00 2018 -0500

    Cleanup for dual endstops homing

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index ee312da2d0..d6842a5800 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -396,7 +396,6 @@ void Endstops::M119() {
 // Check endstops - Could be called from ISR!
 void Endstops::update() {
 
-  #define SET_BIT_TO(N,B,TF) do{ if (TF) SBI(N,B); else CBI(N,B); }while(0)
   // UPDATE_ENDSTOP_BIT: set the current endstop bits for an endstop to its status
   #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT_TO(live_state, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
   // COPY_BIT: copy the value of SRC_BIT to DST_BIT in DST
@@ -590,7 +589,7 @@ void Endstops::update() {
     if (dual_hit) { \
       _ENDSTOP_HIT(AXIS1, MINMAX); \
       /* if not performing home or if both endstops were trigged during homing... */ \
-      if (!stepper.performing_homing || dual_hit == 0x3) \
+      if (!stepper.homing_dual_axis || dual_hit == 0x3) \
         planner.endstop_triggered(_AXIS(AXIS1)); \
     } \
   }while(0)

commit d3c02410a84b369443654ef77f925562e9b87830
Author: Eduardo Jos√© Tagle <ejtagle@hotmail.com>
Date:   Fri Jun 1 21:02:22 2018 -0300

    [2.0.x] Small assorted collection of fixes and improvements (#10911)
    
    * Misc fixes and improvements
    
    - Get rid of most critical sections on the Serial port drivers for AVR and DUE. Proper usage of FIFOs should allow interrupts to stay enabled without harm to queuing and dequeuing.
      Also, with 8-bit indices (for AVR) and up to 32-bit indices (for ARM), there is no need to protect reads and writes to those indices.
    - Simplify the XON/XOFF logic quite a bit. Much cleaner now (both for AVR and ARM)
    - Prevent a race condition (edge case) that could happen when estimating the proper value for the stepper timer (by reading it) and writing the calculated value for the time to the next ISR by disabling interrupts in those critical and small sections of the code - The problem could lead to lost steps.
    - Fix dual endstops not properly homing bug (maybe).
    
    * Set position immediately when possible

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 29ac1e7ce1..ee312da2d0 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -578,19 +578,22 @@ void Endstops::update() {
 
   // Call the endstop triggered routine for single endstops
   #define PROCESS_ENDSTOP(AXIS,MINMAX) do { \
-      if (TEST_ENDSTOP(_ENDSTOP(AXIS, MINMAX))) { \
-        _ENDSTOP_HIT(AXIS, MINMAX); \
-        planner.endstop_triggered(_AXIS(AXIS)); \
-      } \
-    }while(0)
+    if (TEST_ENDSTOP(_ENDSTOP(AXIS, MINMAX))) { \
+      _ENDSTOP_HIT(AXIS, MINMAX); \
+      planner.endstop_triggered(_AXIS(AXIS)); \
+    } \
+  }while(0)
 
-  // Call the endstop triggered routine for single endstops
+  // Call the endstop triggered routine for dual endstops
   #define PROCESS_DUAL_ENDSTOP(AXIS1, AXIS2, MINMAX) do { \
-      if (TEST_ENDSTOP(_ENDSTOP(AXIS1, MINMAX)) || TEST_ENDSTOP(_ENDSTOP(AXIS2, MINMAX))) { \
-        _ENDSTOP_HIT(AXIS1, MINMAX); \
+    const byte dual_hit = TEST_ENDSTOP(_ENDSTOP(AXIS1, MINMAX)) | (TEST_ENDSTOP(_ENDSTOP(AXIS2, MINMAX)) << 1); \
+    if (dual_hit) { \
+      _ENDSTOP_HIT(AXIS1, MINMAX); \
+      /* if not performing home or if both endstops were trigged during homing... */ \
+      if (!stepper.performing_homing || dual_hit == 0x3) \
         planner.endstop_triggered(_AXIS(AXIS1)); \
-      } \
-    }while(0)
+    } \
+  }while(0)
 
   #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && !(CORE_IS_XY || CORE_IS_XZ)
     // If G38 command is active check Z_MIN_PROBE for ALL movement

commit 7261f48872fd9adba6ac890f886a00daeb852b0c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu May 24 19:28:15 2018 -0500

    Fix reset of endstops and move state

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 319562a6a6..29ac1e7ce1 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -263,15 +263,6 @@ void Endstops::not_homing() {
   #endif
 }
 
-// Clear endstops (i.e., they were hit intentionally) to suppress the report
-void Endstops::hit_on_purpose() {
-  hit_state = 0;
-
-  #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-    if (enabled) update(); // If enabling, update state now
-  #endif
-}
-
 // Enable / disable endstop z-probe checking
 #if HAS_BED_PROBE
   void Endstops::enable_z_probe(bool onoff) {

commit 9644d56b42de1d45b292f67cda950387fd76aa06
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu May 24 00:04:47 2018 -0500

    Patches for core motion tests

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 8c51662922..319562a6a6 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -405,11 +405,11 @@ void Endstops::M119() {
 // Check endstops - Could be called from ISR!
 void Endstops::update() {
 
-  #define SET_BIT(N,B,TF) do{ if (TF) SBI(N,B); else CBI(N,B); }while(0)
+  #define SET_BIT_TO(N,B,TF) do{ if (TF) SBI(N,B); else CBI(N,B); }while(0)
   // UPDATE_ENDSTOP_BIT: set the current endstop bits for an endstop to its status
-  #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT(live_state, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
+  #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT_TO(live_state, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
   // COPY_BIT: copy the value of SRC_BIT to DST_BIT in DST
-  #define COPY_BIT(DST, SRC_BIT, DST_BIT) SET_BIT(DST, DST_BIT, TEST(DST, SRC_BIT))
+  #define COPY_BIT(DST, SRC_BIT, DST_BIT) SET_BIT_TO(DST, DST_BIT, TEST(DST, SRC_BIT))
 
   #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && !(CORE_IS_XY || CORE_IS_XZ)
     // If G38 command is active check Z_MIN_PROBE for ALL movement
@@ -605,9 +605,9 @@ void Endstops::update() {
     // If G38 command is active check Z_MIN_PROBE for ALL movement
     if (G38_move) {
       if (TEST_ENDSTOP(_ENDSTOP(Z, MIN_PROBE))) {
-        if      (stepper.axis_is_moving(_AXIS(X))) { _ENDSTOP_HIT(X, MIN); planner.endstop_triggered(_AXIS(X)); }
-        else if (stepper.axis_is_moving(_AXIS(Y))) { _ENDSTOP_HIT(Y, MIN); planner.endstop_triggered(_AXIS(Y)); }
-        else if (stepper.axis_is_moving(_AXIS(Z))) { _ENDSTOP_HIT(Z, MIN); planner.endstop_triggered(_AXIS(Z)); }
+        if      (stepper.axis_is_moving(X_AXIS)) { _ENDSTOP_HIT(X, MIN); planner.endstop_triggered(X_AXIS); }
+        else if (stepper.axis_is_moving(Y_AXIS)) { _ENDSTOP_HIT(Y, MIN); planner.endstop_triggered(Y_AXIS); }
+        else if (stepper.axis_is_moving(Z_AXIS)) { _ENDSTOP_HIT(Z, MIN); planner.endstop_triggered(Z_AXIS); }
         G38_endstop_hit = true;
       }
     }

commit 3e3789da85e4d25693506df9dfd094aabf98d50e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed May 23 03:45:25 2018 -0500

    Regression: Endstops Core compatibility (#10823)
    
    Co-Authored-By: ejtagle <ejtagle@hotmail.com>

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 83b1a504db..8c51662922 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -37,9 +37,9 @@
 #endif
 
 #if HAS_BED_PROBE
-  #define ENDSTOPS_ENABLED  (endstops.enabled || endstops.z_probe_enabled)
+  #define ENDSTOPS_ENABLED  (enabled || z_probe_enabled)
 #else
-  #define ENDSTOPS_ENABLED  endstops.enabled
+  #define ENDSTOPS_ENABLED  enabled
 #endif
 
 Endstops endstops;
@@ -223,17 +223,17 @@ void Endstops::init() {
 } // Endstops::init
 
 // Called from ISR. A change was detected. Find out what happened!
-void Endstops::check_possible_change() { if (ENDSTOPS_ENABLED) endstops.update(); }
+void Endstops::check_possible_change() { if (ENDSTOPS_ENABLED) update(); }
 
 // Called from ISR: Poll endstop state if required
 void Endstops::poll() {
 
   #if ENABLED(PINS_DEBUGGING)
-    endstops.run_monitor();  // report changes in endstop status
+    run_monitor();  // report changes in endstop status
   #endif
 
   #if DISABLED(ENDSTOP_INTERRUPTS_FEATURE) || ENABLED(ENDSTOP_NOISE_FILTER)
-    if (ENDSTOPS_ENABLED) endstops.update();
+    if (ENDSTOPS_ENABLED) update();
   #endif
 }
 
@@ -241,7 +241,7 @@ void Endstops::enable_globally(const bool onoff) {
   enabled_globally = enabled = onoff;
 
   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-    if (onoff) endstops.update(); // If enabling, update state now
+    if (onoff) update(); // If enabling, update state now
   #endif
 }
 
@@ -250,17 +250,16 @@ void Endstops::enable(const bool onoff) {
   enabled = onoff;
 
   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-    if (onoff) endstops.update(); // If enabling, update state now
+    if (onoff) update(); // If enabling, update state now
   #endif
 }
 
-
 // Disable / Enable endstops based on ENSTOPS_ONLY_FOR_HOMING and global enable
 void Endstops::not_homing() {
   enabled = enabled_globally;
 
   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-    if (enabled) endstops.update(); // If enabling, update state now
+    if (enabled) update(); // If enabling, update state now
   #endif
 }
 
@@ -269,7 +268,7 @@ void Endstops::hit_on_purpose() {
   hit_state = 0;
 
   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-    if (enabled) endstops.update(); // If enabling, update state now
+    if (enabled) update(); // If enabling, update state now
   #endif
 }
 
@@ -279,7 +278,7 @@ void Endstops::hit_on_purpose() {
     z_probe_enabled = onoff;
 
     #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-      if (enabled) endstops.update(); // If enabling, update state now
+      if (enabled) update(); // If enabling, update state now
     #endif
   }
 #endif
@@ -417,89 +416,37 @@ void Endstops::update() {
     if (G38_move) UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
   #endif
 
-  /**
-   * Define conditions for checking endstops
-   */
-
-  #if IS_CORE
-    #define S_(N) stepper.movement_non_null(CORE_AXIS_##N)
-    #define D_(N) stepper.motor_direction(CORE_AXIS_##N)
+  // With Dual X, endstops are only checked in the homing direction for the active extruder
+  #if ENABLED(DUAL_X_CARRIAGE)
+    #define E0_ACTIVE stepper.movement_extruder() == 0
+    #define X_MIN_TEST ((X_HOME_DIR < 0 && E0_ACTIVE) || (X2_HOME_DIR < 0 && !E0_ACTIVE))
+    #define X_MAX_TEST ((X_HOME_DIR > 0 && E0_ACTIVE) || (X2_HOME_DIR > 0 && !E0_ACTIVE))
+  #else
+    #define X_MIN_TEST true
+    #define X_MAX_TEST true
   #endif
 
+  // Use HEAD for core axes, AXIS for others
   #if CORE_IS_XY || CORE_IS_XZ
-    /**
-     * Head direction in -X axis for CoreXY and CoreXZ bots.
-     *
-     * If steps differ, both axes are moving.
-     * If DeltaA == -DeltaB, the movement is only in the 2nd axis (Y or Z, handled below)
-     * If DeltaA ==  DeltaB, the movement is only in the 1st axis (X)
-     */
-    #if ENABLED(COREXY) || ENABLED(COREXZ)
-      #define X_CMP ==
-    #else
-      #define X_CMP !=
-    #endif
-    #define X_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && D_(1) X_CMP D_(2)) )
     #define X_AXIS_HEAD X_HEAD
   #else
-    #define X_MOVE_TEST stepper.movement_non_null(X_AXIS)
     #define X_AXIS_HEAD X_AXIS
   #endif
-
   #if CORE_IS_XY || CORE_IS_YZ
-    /**
-     * Head direction in -Y axis for CoreXY / CoreYZ bots.
-     *
-     * If steps differ, both axes are moving
-     * If DeltaA ==  DeltaB, the movement is only in the 1st axis (X or Y)
-     * If DeltaA == -DeltaB, the movement is only in the 2nd axis (Y or Z)
-     */
-    #if ENABLED(COREYX) || ENABLED(COREYZ)
-      #define Y_CMP ==
-    #else
-      #define Y_CMP !=
-    #endif
-    #define Y_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && D_(1) Y_CMP D_(2)) )
     #define Y_AXIS_HEAD Y_HEAD
   #else
-    #define Y_MOVE_TEST stepper.movement_non_null(Y_AXIS)
     #define Y_AXIS_HEAD Y_AXIS
   #endif
-
   #if CORE_IS_XZ || CORE_IS_YZ
-    /**
-     * Head direction in -Z axis for CoreXZ or CoreYZ bots.
-     *
-     * If steps differ, both axes are moving
-     * If DeltaA ==  DeltaB, the movement is only in the 1st axis (X or Y, already handled above)
-     * If DeltaA == -DeltaB, the movement is only in the 2nd axis (Z)
-     */
-    #if ENABLED(COREZX) || ENABLED(COREZY)
-      #define Z_CMP ==
-    #else
-      #define Z_CMP !=
-    #endif
-    #define Z_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && D_(1) Z_CMP D_(2)) )
     #define Z_AXIS_HEAD Z_HEAD
   #else
-    #define Z_MOVE_TEST stepper.movement_non_null(Z_AXIS)
     #define Z_AXIS_HEAD Z_AXIS
   #endif
 
-  // With Dual X, endstops are only checked in the homing direction for the active extruder
-  #if ENABLED(DUAL_X_CARRIAGE)
-    #define E0_ACTIVE stepper.movement_extruder() == 0
-    #define X_MIN_TEST ((X_HOME_DIR < 0 && E0_ACTIVE) || (X2_HOME_DIR < 0 && !E0_ACTIVE))
-    #define X_MAX_TEST ((X_HOME_DIR > 0 && E0_ACTIVE) || (X2_HOME_DIR > 0 && !E0_ACTIVE))
-  #else
-    #define X_MIN_TEST true
-    #define X_MAX_TEST true
-  #endif
-
   /**
    * Check and update endstops according to conditions
    */
-  if (X_MOVE_TEST) {
+  if (stepper.axis_is_moving(X_AXIS)) {
     if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
       #if HAS_X_MIN
         #if ENABLED(X_DUAL_ENDSTOPS)
@@ -530,7 +477,7 @@ void Endstops::update() {
     }
   }
 
-  if (Y_MOVE_TEST) {
+  if (stepper.axis_is_moving(Y_AXIS)) {
     if (stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
       #if HAS_Y_MIN
         #if ENABLED(Y_DUAL_ENDSTOPS)
@@ -561,7 +508,7 @@ void Endstops::update() {
     }
   }
 
-  if (Z_MOVE_TEST) {
+  if (stepper.axis_is_moving(Z_AXIS)) {
     if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
       #if HAS_Z_MIN
         #if ENABLED(Z_DUAL_ENDSTOPS)
@@ -582,9 +529,7 @@ void Endstops::update() {
 
       // When closing the gap check the enabled probe
       #if ENABLED(Z_MIN_PROBE_ENDSTOP)
-        if (z_probe_enabled) {
-          UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
-        }
+        if (z_probe_enabled) UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
       #endif
     }
     else { // Z +direction. Gantry up, bed down.
@@ -660,16 +605,16 @@ void Endstops::update() {
     // If G38 command is active check Z_MIN_PROBE for ALL movement
     if (G38_move) {
       if (TEST_ENDSTOP(_ENDSTOP(Z, MIN_PROBE))) {
-        if      (stepper.movement_non_null(_AXIS(X))) { _ENDSTOP_HIT(X, MIN); planner.endstop_triggered(_AXIS(X)); }
-        else if (stepper.movement_non_null(_AXIS(Y))) { _ENDSTOP_HIT(Y, MIN); planner.endstop_triggered(_AXIS(Y)); }
-        else if (stepper.movement_non_null(_AXIS(Z))) { _ENDSTOP_HIT(Z, MIN); planner.endstop_triggered(_AXIS(Z)); }
+        if      (stepper.axis_is_moving(_AXIS(X))) { _ENDSTOP_HIT(X, MIN); planner.endstop_triggered(_AXIS(X)); }
+        else if (stepper.axis_is_moving(_AXIS(Y))) { _ENDSTOP_HIT(Y, MIN); planner.endstop_triggered(_AXIS(Y)); }
+        else if (stepper.axis_is_moving(_AXIS(Z))) { _ENDSTOP_HIT(Z, MIN); planner.endstop_triggered(_AXIS(Z)); }
         G38_endstop_hit = true;
       }
     }
   #endif
 
   // Now, we must signal, after validation, if an endstop limit is pressed or not
-  if (X_MOVE_TEST) {
+  if (stepper.axis_is_moving(X_AXIS)) {
     if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
       #if HAS_X_MIN
         #if ENABLED(X_DUAL_ENDSTOPS)
@@ -690,7 +635,7 @@ void Endstops::update() {
     }
   }
 
-  if (Y_MOVE_TEST) {
+  if (stepper.axis_is_moving(Y_AXIS)) {
     if (stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
       #if HAS_Y_MIN
         #if ENABLED(Y_DUAL_ENDSTOPS)
@@ -711,7 +656,7 @@ void Endstops::update() {
     }
   }
 
-  if (Z_MOVE_TEST) {
+  if (stepper.axis_is_moving(Z_AXIS)) {
     if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
       #if HAS_Z_MIN
         #if ENABLED(Z_DUAL_ENDSTOPS)

commit 4b610b333e3893d8ce3c4566d01d89d70263ca04
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 22 01:56:03 2018 -0500

    Tweak G38 formatting

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index fec473e2bf..83b1a504db 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -414,9 +414,7 @@ void Endstops::update() {
 
   #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && !(CORE_IS_XY || CORE_IS_XZ)
     // If G38 command is active check Z_MIN_PROBE for ALL movement
-    if (G38_move) {
-      UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
-    }
+    if (G38_move) UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
   #endif
 
   /**

commit 4b2f6e3b2b0d6773cb15e55433bb243625ba71ea
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon May 21 15:51:38 2018 -0500

    [2.0.x] Add endstop noise filter (#10796)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index d354774afe..fec473e2bf 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -36,9 +36,6 @@
   #include HAL_PATH(../HAL, endstop_interrupts.h)
 #endif
 
-// TEST_ENDSTOP: test the current status of an endstop
-#define TEST_ENDSTOP(ENDSTOP) (TEST(current_endstop_bits, ENDSTOP))
-
 #if HAS_BED_PROBE
   #define ENDSTOPS_ENABLED  (endstops.enabled || endstops.z_probe_enabled)
 #else
@@ -50,9 +47,14 @@ Endstops endstops;
 // public:
 
 bool Endstops::enabled, Endstops::enabled_globally; // Initialized by settings.load()
-volatile uint8_t Endstops::endstop_hit_bits; // use X_MIN, Y_MIN, Z_MIN and Z_MIN_PROBE as BIT value
+volatile uint8_t Endstops::hit_state;
 
-Endstops::esbits_t Endstops::current_endstop_bits = 0;
+Endstops::esbits_t Endstops::live_state = 0;
+#if ENABLED(ENDSTOP_NOISE_FILTER)
+  Endstops::esbits_t Endstops::old_live_state,
+                     Endstops::validated_live_state;
+  uint8_t Endstops::endstop_poll_count;
+#endif
 
 #if HAS_BED_PROBE
   volatile bool Endstops::z_probe_enabled = false;
@@ -230,7 +232,7 @@ void Endstops::poll() {
     endstops.run_monitor();  // report changes in endstop status
   #endif
 
-  #if DISABLED(ENDSTOP_INTERRUPTS_FEATURE)
+  #if DISABLED(ENDSTOP_INTERRUPTS_FEATURE) || ENABLED(ENDSTOP_NOISE_FILTER)
     if (ENDSTOPS_ENABLED) endstops.update();
   #endif
 }
@@ -264,7 +266,7 @@ void Endstops::not_homing() {
 
 // Clear endstops (i.e., they were hit intentionally) to suppress the report
 void Endstops::hit_on_purpose() {
-  endstop_hit_bits = 0;
+  hit_state = 0;
 
   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
     if (enabled) endstops.update(); // If enabling, update state now
@@ -293,7 +295,7 @@ void Endstops::hit_on_purpose() {
 #endif
 
 void Endstops::report_state() {
-  if (endstop_hit_bits) {
+  if (hit_state) {
     #if ENABLED(ULTRA_LCD)
       char chrX = ' ', chrY = ' ', chrZ = ' ', chrP = ' ';
       #define _SET_STOP_CHAR(A,C) (chr## A = C)
@@ -306,7 +308,7 @@ void Endstops::report_state() {
       _SET_STOP_CHAR(A,C); }while(0)
 
     #define _ENDSTOP_HIT_TEST(A,C) \
-      if (TEST(endstop_hit_bits, A ##_MIN) || TEST(endstop_hit_bits, A ##_MAX)) \
+      if (TEST(hit_state, A ##_MIN) || TEST(hit_state, A ##_MAX)) \
         _ENDSTOP_HIT_ECHO(A,C)
 
     #define ENDSTOP_HIT_TEST_X() _ENDSTOP_HIT_TEST(X,'X')
@@ -321,7 +323,7 @@ void Endstops::report_state() {
 
     #if ENABLED(Z_MIN_PROBE_ENDSTOP)
       #define P_AXIS Z_AXIS
-      if (TEST(endstop_hit_bits, Z_MIN_PROBE)) _ENDSTOP_HIT_ECHO(P, 'P');
+      if (TEST(hit_state, Z_MIN_PROBE)) _ENDSTOP_HIT_ECHO(P, 'P');
     #endif
     SERIAL_EOL();
 
@@ -397,69 +399,23 @@ void Endstops::M119() {
 // The following routines are called from an ISR context. It could be the temperature ISR, the
 // endstop ISR or the Stepper ISR.
 
-#if ENABLED(X_DUAL_ENDSTOPS)
-  void Endstops::test_dual_x_endstops(const EndstopEnum es1, const EndstopEnum es2) {
-    const byte x_test = TEST_ENDSTOP(es1) | (TEST_ENDSTOP(es2) << 1); // bit 0 for X, bit 1 for X2
-    if (x_test && stepper.movement_non_null(X_AXIS)) {
-      SBI(endstop_hit_bits, X_MIN);
-      if (!stepper.performing_homing || (x_test == 0x3))  //if not performing home or if both endstops were trigged during homing...
-        stepper.quick_stop();
-    }
-  }
-#endif
-#if ENABLED(Y_DUAL_ENDSTOPS)
-  void Endstops::test_dual_y_endstops(const EndstopEnum es1, const EndstopEnum es2) {
-    const byte y_test = TEST_ENDSTOP(es1) | (TEST_ENDSTOP(es2) << 1); // bit 0 for Y, bit 1 for Y2
-    if (y_test && stepper.movement_non_null(Y_AXIS)) {
-      SBI(endstop_hit_bits, Y_MIN);
-      if (!stepper.performing_homing || (y_test == 0x3))  //if not performing home or if both endstops were trigged during homing...
-        stepper.quick_stop();
-    }
-  }
-#endif
-#if ENABLED(Z_DUAL_ENDSTOPS)
-  void Endstops::test_dual_z_endstops(const EndstopEnum es1, const EndstopEnum es2) {
-    const byte z_test = TEST_ENDSTOP(es1) | (TEST_ENDSTOP(es2) << 1); // bit 0 for Z, bit 1 for Z2
-    if (z_test && stepper.movement_non_null(Z_AXIS)) {
-      SBI(endstop_hit_bits, Z_MIN);
-      if (!stepper.performing_homing || (z_test == 0x3))  //if not performing home or if both endstops were trigged during homing...
-        stepper.quick_stop();
-    }
-  }
-#endif
+#define _ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
+#define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN
+#define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_INVERTING
 
 // Check endstops - Could be called from ISR!
 void Endstops::update() {
 
-  #define _ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
-  #define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN
-  #define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_INVERTING
-  #define _ENDSTOP_HIT(AXIS, MINMAX) SBI(endstop_hit_bits, _ENDSTOP(AXIS, MINMAX))
-
   #define SET_BIT(N,B,TF) do{ if (TF) SBI(N,B); else CBI(N,B); }while(0)
   // UPDATE_ENDSTOP_BIT: set the current endstop bits for an endstop to its status
-  #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT(current_endstop_bits, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
+  #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT(live_state, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
   // COPY_BIT: copy the value of SRC_BIT to DST_BIT in DST
   #define COPY_BIT(DST, SRC_BIT, DST_BIT) SET_BIT(DST, DST_BIT, TEST(DST, SRC_BIT))
 
-  #define UPDATE_ENDSTOP(AXIS,MINMAX) do { \
-      UPDATE_ENDSTOP_BIT(AXIS, MINMAX); \
-      if (TEST_ENDSTOP(_ENDSTOP(AXIS, MINMAX))) { \
-        _ENDSTOP_HIT(AXIS, MINMAX); \
-        planner.endstop_triggered(_AXIS(AXIS)); \
-      } \
-    }while(0)
-
   #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && !(CORE_IS_XY || CORE_IS_XZ)
     // If G38 command is active check Z_MIN_PROBE for ALL movement
     if (G38_move) {
       UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
-      if (TEST_ENDSTOP(_ENDSTOP(Z, MIN_PROBE))) {
-        if      (stepper.movement_non_null(_AXIS(X))) { _ENDSTOP_HIT(X, MIN); planner.endstop_triggered(_AXIS(X)); }
-        else if (stepper.movement_non_null(_AXIS(Y))) { _ENDSTOP_HIT(Y, MIN); planner.endstop_triggered(_AXIS(Y)); }
-        else if (stepper.movement_non_null(_AXIS(Z))) { _ENDSTOP_HIT(Z, MIN); planner.endstop_triggered(_AXIS(Z)); }
-        G38_endstop_hit = true;
-      }
     }
   #endif
 
@@ -553,11 +509,10 @@ void Endstops::update() {
           #if HAS_X2_MIN
             UPDATE_ENDSTOP_BIT(X2, MIN);
           #else
-            COPY_BIT(current_endstop_bits, X_MIN, X2_MIN);
+            COPY_BIT(live_state, X_MIN, X2_MIN);
           #endif
-          test_dual_x_endstops(X_MIN, X2_MIN);
         #else
-          if (X_MIN_TEST) UPDATE_ENDSTOP(X, MIN);
+          if (X_MIN_TEST) UPDATE_ENDSTOP_BIT(X, MIN);
         #endif
       #endif
     }
@@ -568,11 +523,10 @@ void Endstops::update() {
           #if HAS_X2_MAX
             UPDATE_ENDSTOP_BIT(X2, MAX);
           #else
-            COPY_BIT(current_endstop_bits, X_MAX, X2_MAX);
+            COPY_BIT(live_state, X_MAX, X2_MAX);
           #endif
-          test_dual_x_endstops(X_MAX, X2_MAX);
         #else
-          if (X_MAX_TEST) UPDATE_ENDSTOP(X, MAX);
+          if (X_MAX_TEST) UPDATE_ENDSTOP_BIT(X, MAX);
         #endif
       #endif
     }
@@ -586,11 +540,10 @@ void Endstops::update() {
           #if HAS_Y2_MIN
             UPDATE_ENDSTOP_BIT(Y2, MIN);
           #else
-            COPY_BIT(current_endstop_bits, Y_MIN, Y2_MIN);
+            COPY_BIT(live_state, Y_MIN, Y2_MIN);
           #endif
-          test_dual_y_endstops(Y_MIN, Y2_MIN);
         #else
-          UPDATE_ENDSTOP(Y, MIN);
+          UPDATE_ENDSTOP_BIT(Y, MIN);
         #endif
       #endif
     }
@@ -601,11 +554,10 @@ void Endstops::update() {
           #if HAS_Y2_MAX
             UPDATE_ENDSTOP_BIT(Y2, MAX);
           #else
-            COPY_BIT(current_endstop_bits, Y_MAX, Y2_MAX);
+            COPY_BIT(live_state, Y_MAX, Y2_MAX);
           #endif
-          test_dual_y_endstops(Y_MAX, Y2_MAX);
         #else
-          UPDATE_ENDSTOP(Y, MAX);
+          UPDATE_ENDSTOP_BIT(Y, MAX);
         #endif
       #endif
     }
@@ -619,14 +571,13 @@ void Endstops::update() {
           #if HAS_Z2_MIN
             UPDATE_ENDSTOP_BIT(Z2, MIN);
           #else
-            COPY_BIT(current_endstop_bits, Z_MIN, Z2_MIN);
+            COPY_BIT(live_state, Z_MIN, Z2_MIN);
           #endif
-          test_dual_z_endstops(Z_MIN, Z2_MIN);
         #else
           #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
-            if (z_probe_enabled) UPDATE_ENDSTOP(Z, MIN);
+            if (z_probe_enabled) UPDATE_ENDSTOP_BIT(Z, MIN);
           #else
-            UPDATE_ENDSTOP(Z, MIN);
+            UPDATE_ENDSTOP_BIT(Z, MIN);
           #endif
         #endif
       #endif
@@ -634,8 +585,7 @@ void Endstops::update() {
       // When closing the gap check the enabled probe
       #if ENABLED(Z_MIN_PROBE_ENDSTOP)
         if (z_probe_enabled) {
-          UPDATE_ENDSTOP(Z, MIN_PROBE);
-          if (TEST_ENDSTOP(Z_MIN_PROBE)) SBI(endstop_hit_bits, Z_MIN_PROBE);
+          UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
         }
       #endif
     }
@@ -647,13 +597,149 @@ void Endstops::update() {
           #if HAS_Z2_MAX
             UPDATE_ENDSTOP_BIT(Z2, MAX);
           #else
-            COPY_BIT(current_endstop_bits, Z_MAX, Z2_MAX);
+            COPY_BIT(live_state, Z_MAX, Z2_MAX);
           #endif
-          test_dual_z_endstops(Z_MAX, Z2_MAX);
         // If this pin is not hijacked for the bed probe
         // then it belongs to the Z endstop
         #elif DISABLED(Z_MIN_PROBE_ENDSTOP) || Z_MAX_PIN != Z_MIN_PROBE_PIN
-          UPDATE_ENDSTOP(Z, MAX);
+          UPDATE_ENDSTOP_BIT(Z, MAX);
+        #endif
+      #endif
+    }
+  }
+
+  // All endstops were updated.
+  #if ENABLED(ENDSTOP_NOISE_FILTER)
+    if (old_live_state != live_state) { // We detected a change. Reinit the timeout
+      /**
+       * Filtering out noise on endstops requires a delayed decision. Let's assume, due to noise,
+       * that 50% of endstop signal samples are good and 50% are bad (assuming normal distribution
+       * of random noise). Then the first sample has a 50% chance to be good or bad. The 2nd sample
+       * also has a 50% chance to be good or bad. The chances of 2 samples both being bad becomes
+       * 50% of 50%, or 25%. That was the previous implementation of Marlin endstop handling. It
+       * reduces chances of bad readings in half, at the cost of 1 extra sample period, but chances
+       * still exist. The only way to reduce them further is to increase the number of samples.
+       * To reduce the chance to 1% (1/128th) requires 7 samples (adding 7ms of delay).
+       */
+      endstop_poll_count = 7;
+      old_live_state = live_state;
+    }
+    else if (endstop_poll_count && !--endstop_poll_count)
+      validated_live_state = live_state;
+
+  #else
+
+    // Lets accept the new endstop values as valid - We assume hardware filtering of lines
+    esbits_t validated_live_state = live_state;
+
+  #endif
+
+  // Endstop readings are validated in validated_live_state
+
+  // Test the current status of an endstop
+  #define TEST_ENDSTOP(ENDSTOP) (TEST(validated_live_state, ENDSTOP))
+
+  // Record endstop was hit
+  #define _ENDSTOP_HIT(AXIS, MINMAX) SBI(hit_state, _ENDSTOP(AXIS, MINMAX))
+
+  // Call the endstop triggered routine for single endstops
+  #define PROCESS_ENDSTOP(AXIS,MINMAX) do { \
+      if (TEST_ENDSTOP(_ENDSTOP(AXIS, MINMAX))) { \
+        _ENDSTOP_HIT(AXIS, MINMAX); \
+        planner.endstop_triggered(_AXIS(AXIS)); \
+      } \
+    }while(0)
+
+  // Call the endstop triggered routine for single endstops
+  #define PROCESS_DUAL_ENDSTOP(AXIS1, AXIS2, MINMAX) do { \
+      if (TEST_ENDSTOP(_ENDSTOP(AXIS1, MINMAX)) || TEST_ENDSTOP(_ENDSTOP(AXIS2, MINMAX))) { \
+        _ENDSTOP_HIT(AXIS1, MINMAX); \
+        planner.endstop_triggered(_AXIS(AXIS1)); \
+      } \
+    }while(0)
+
+  #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && !(CORE_IS_XY || CORE_IS_XZ)
+    // If G38 command is active check Z_MIN_PROBE for ALL movement
+    if (G38_move) {
+      if (TEST_ENDSTOP(_ENDSTOP(Z, MIN_PROBE))) {
+        if      (stepper.movement_non_null(_AXIS(X))) { _ENDSTOP_HIT(X, MIN); planner.endstop_triggered(_AXIS(X)); }
+        else if (stepper.movement_non_null(_AXIS(Y))) { _ENDSTOP_HIT(Y, MIN); planner.endstop_triggered(_AXIS(Y)); }
+        else if (stepper.movement_non_null(_AXIS(Z))) { _ENDSTOP_HIT(Z, MIN); planner.endstop_triggered(_AXIS(Z)); }
+        G38_endstop_hit = true;
+      }
+    }
+  #endif
+
+  // Now, we must signal, after validation, if an endstop limit is pressed or not
+  if (X_MOVE_TEST) {
+    if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
+      #if HAS_X_MIN
+        #if ENABLED(X_DUAL_ENDSTOPS)
+          PROCESS_DUAL_ENDSTOP(X, X2, MIN);
+        #else
+          if (X_MIN_TEST) PROCESS_ENDSTOP(X, MIN);
+        #endif
+      #endif
+    }
+    else { // +direction
+      #if HAS_X_MAX
+        #if ENABLED(X_DUAL_ENDSTOPS)
+          PROCESS_DUAL_ENDSTOP(X, X2, MAX);
+        #else
+          if (X_MAX_TEST) PROCESS_ENDSTOP(X, MAX);
+        #endif
+      #endif
+    }
+  }
+
+  if (Y_MOVE_TEST) {
+    if (stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
+      #if HAS_Y_MIN
+        #if ENABLED(Y_DUAL_ENDSTOPS)
+          PROCESS_DUAL_ENDSTOP(Y, Y2, MIN);
+        #else
+          PROCESS_ENDSTOP(Y, MIN);
+        #endif
+      #endif
+    }
+    else { // +direction
+      #if HAS_Y_MAX
+        #if ENABLED(Y_DUAL_ENDSTOPS)
+          PROCESS_DUAL_ENDSTOP(Y, Y2, MAX);
+        #else
+          PROCESS_ENDSTOP(Y, MAX);
+        #endif
+      #endif
+    }
+  }
+
+  if (Z_MOVE_TEST) {
+    if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
+      #if HAS_Z_MIN
+        #if ENABLED(Z_DUAL_ENDSTOPS)
+          PROCESS_DUAL_ENDSTOP(Z, Z2, MIN);
+        #else
+          #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
+            if (z_probe_enabled) PROCESS_ENDSTOP(Z, MIN);
+          #else
+            PROCESS_ENDSTOP(Z, MIN);
+          #endif
+        #endif
+      #endif
+
+      // When closing the gap check the enabled probe
+      #if ENABLED(Z_MIN_PROBE_ENDSTOP)
+        if (z_probe_enabled) PROCESS_ENDSTOP(Z, MIN_PROBE);
+      #endif
+    }
+    else { // Z +direction. Gantry up, bed down.
+      #if HAS_Z_MAX
+        #if ENABLED(Z_DUAL_ENDSTOPS)
+          PROCESS_DUAL_ENDSTOP(Z, Z2, MAX);
+        #elif DISABLED(Z_MIN_PROBE_ENDSTOP) || Z_MAX_PIN != Z_MIN_PROBE_PIN
+          // If this pin is not hijacked for the bed probe
+          // then it belongs to the Z endstop
+          PROCESS_ENDSTOP(Z, MAX);
         #endif
       #endif
     }
@@ -676,96 +762,96 @@ void Endstops::update() {
    */
   void Endstops::monitor() {
 
-    static uint16_t old_endstop_bits_local = 0;
+    static uint16_t old_live_state_local = 0;
     static uint8_t local_LED_status = 0;
-    uint16_t current_endstop_bits_local = 0;
+    uint16_t live_state_local = 0;
 
     #if HAS_X_MIN
-      if (READ(X_MIN_PIN)) SBI(current_endstop_bits_local, X_MIN);
+      if (READ(X_MIN_PIN)) SBI(live_state_local, X_MIN);
     #endif
     #if HAS_X_MAX
-      if (READ(X_MAX_PIN)) SBI(current_endstop_bits_local, X_MAX);
+      if (READ(X_MAX_PIN)) SBI(live_state_local, X_MAX);
     #endif
     #if HAS_Y_MIN
-      if (READ(Y_MIN_PIN)) SBI(current_endstop_bits_local, Y_MIN);
+      if (READ(Y_MIN_PIN)) SBI(live_state_local, Y_MIN);
     #endif
     #if HAS_Y_MAX
-      if (READ(Y_MAX_PIN)) SBI(current_endstop_bits_local, Y_MAX);
+      if (READ(Y_MAX_PIN)) SBI(live_state_local, Y_MAX);
     #endif
     #if HAS_Z_MIN
-      if (READ(Z_MIN_PIN)) SBI(current_endstop_bits_local, Z_MIN);
+      if (READ(Z_MIN_PIN)) SBI(live_state_local, Z_MIN);
     #endif
     #if HAS_Z_MAX
-      if (READ(Z_MAX_PIN)) SBI(current_endstop_bits_local, Z_MAX);
+      if (READ(Z_MAX_PIN)) SBI(live_state_local, Z_MAX);
     #endif
     #if HAS_Z_MIN_PROBE_PIN
-      if (READ(Z_MIN_PROBE_PIN)) SBI(current_endstop_bits_local, Z_MIN_PROBE);
+      if (READ(Z_MIN_PROBE_PIN)) SBI(live_state_local, Z_MIN_PROBE);
     #endif
     #if HAS_X2_MIN
-      if (READ(X2_MIN_PIN)) SBI(current_endstop_bits_local, X2_MIN);
+      if (READ(X2_MIN_PIN)) SBI(live_state_local, X2_MIN);
     #endif
     #if HAS_X2_MAX
-      if (READ(X2_MAX_PIN)) SBI(current_endstop_bits_local, X2_MAX);
+      if (READ(X2_MAX_PIN)) SBI(live_state_local, X2_MAX);
     #endif
     #if HAS_Y2_MIN
-      if (READ(Y2_MIN_PIN)) SBI(current_endstop_bits_local, Y2_MIN);
+      if (READ(Y2_MIN_PIN)) SBI(live_state_local, Y2_MIN);
     #endif
     #if HAS_Y2_MAX
-      if (READ(Y2_MAX_PIN)) SBI(current_endstop_bits_local, Y2_MAX);
+      if (READ(Y2_MAX_PIN)) SBI(live_state_local, Y2_MAX);
     #endif
     #if HAS_Z2_MIN
-      if (READ(Z2_MIN_PIN)) SBI(current_endstop_bits_local, Z2_MIN);
+      if (READ(Z2_MIN_PIN)) SBI(live_state_local, Z2_MIN);
     #endif
     #if HAS_Z2_MAX
-      if (READ(Z2_MAX_PIN)) SBI(current_endstop_bits_local, Z2_MAX);
+      if (READ(Z2_MAX_PIN)) SBI(live_state_local, Z2_MAX);
     #endif
 
-    uint16_t endstop_change = current_endstop_bits_local ^ old_endstop_bits_local;
+    uint16_t endstop_change = live_state_local ^ old_live_state_local;
 
     if (endstop_change) {
       #if HAS_X_MIN
-        if (TEST(endstop_change, X_MIN)) SERIAL_PROTOCOLPAIR("  X_MIN:", TEST(current_endstop_bits_local, X_MIN));
+        if (TEST(endstop_change, X_MIN)) SERIAL_PROTOCOLPAIR("  X_MIN:", TEST(live_state_local, X_MIN));
       #endif
       #if HAS_X_MAX
-        if (TEST(endstop_change, X_MAX)) SERIAL_PROTOCOLPAIR("  X_MAX:", TEST(current_endstop_bits_local, X_MAX));
+        if (TEST(endstop_change, X_MAX)) SERIAL_PROTOCOLPAIR("  X_MAX:", TEST(live_state_local, X_MAX));
       #endif
       #if HAS_Y_MIN
-        if (TEST(endstop_change, Y_MIN)) SERIAL_PROTOCOLPAIR("  Y_MIN:", TEST(current_endstop_bits_local, Y_MIN));
+        if (TEST(endstop_change, Y_MIN)) SERIAL_PROTOCOLPAIR("  Y_MIN:", TEST(live_state_local, Y_MIN));
       #endif
       #if HAS_Y_MAX
-        if (TEST(endstop_change, Y_MAX)) SERIAL_PROTOCOLPAIR("  Y_MAX:", TEST(current_endstop_bits_local, Y_MAX));
+        if (TEST(endstop_change, Y_MAX)) SERIAL_PROTOCOLPAIR("  Y_MAX:", TEST(live_state_local, Y_MAX));
       #endif
       #if HAS_Z_MIN
-        if (TEST(endstop_change, Z_MIN)) SERIAL_PROTOCOLPAIR("  Z_MIN:", TEST(current_endstop_bits_local, Z_MIN));
+        if (TEST(endstop_change, Z_MIN)) SERIAL_PROTOCOLPAIR("  Z_MIN:", TEST(live_state_local, Z_MIN));
       #endif
       #if HAS_Z_MAX
-        if (TEST(endstop_change, Z_MAX)) SERIAL_PROTOCOLPAIR("  Z_MAX:", TEST(current_endstop_bits_local, Z_MAX));
+        if (TEST(endstop_change, Z_MAX)) SERIAL_PROTOCOLPAIR("  Z_MAX:", TEST(live_state_local, Z_MAX));
       #endif
       #if HAS_Z_MIN_PROBE_PIN
-        if (TEST(endstop_change, Z_MIN_PROBE)) SERIAL_PROTOCOLPAIR("  PROBE:", TEST(current_endstop_bits_local, Z_MIN_PROBE));
+        if (TEST(endstop_change, Z_MIN_PROBE)) SERIAL_PROTOCOLPAIR("  PROBE:", TEST(live_state_local, Z_MIN_PROBE));
       #endif
       #if HAS_X2_MIN
-        if (TEST(endstop_change, X2_MIN)) SERIAL_PROTOCOLPAIR("  X2_MIN:", TEST(current_endstop_bits_local, X2_MIN));
+        if (TEST(endstop_change, X2_MIN)) SERIAL_PROTOCOLPAIR("  X2_MIN:", TEST(live_state_local, X2_MIN));
       #endif
       #if HAS_X2_MAX
-        if (TEST(endstop_change, X2_MAX)) SERIAL_PROTOCOLPAIR("  X2_MAX:", TEST(current_endstop_bits_local, X2_MAX));
+        if (TEST(endstop_change, X2_MAX)) SERIAL_PROTOCOLPAIR("  X2_MAX:", TEST(live_state_local, X2_MAX));
       #endif
       #if HAS_Y2_MIN
-        if (TEST(endstop_change, Y2_MIN)) SERIAL_PROTOCOLPAIR("  Y2_MIN:", TEST(current_endstop_bits_local, Y2_MIN));
+        if (TEST(endstop_change, Y2_MIN)) SERIAL_PROTOCOLPAIR("  Y2_MIN:", TEST(live_state_local, Y2_MIN));
       #endif
       #if HAS_Y2_MAX
-        if (TEST(endstop_change, Y2_MAX)) SERIAL_PROTOCOLPAIR("  Y2_MAX:", TEST(current_endstop_bits_local, Y2_MAX));
+        if (TEST(endstop_change, Y2_MAX)) SERIAL_PROTOCOLPAIR("  Y2_MAX:", TEST(live_state_local, Y2_MAX));
       #endif
       #if HAS_Z2_MIN
-        if (TEST(endstop_change, Z2_MIN)) SERIAL_PROTOCOLPAIR("  Z2_MIN:", TEST(current_endstop_bits_local, Z2_MIN));
+        if (TEST(endstop_change, Z2_MIN)) SERIAL_PROTOCOLPAIR("  Z2_MIN:", TEST(live_state_local, Z2_MIN));
       #endif
       #if HAS_Z2_MAX
-        if (TEST(endstop_change, Z2_MAX)) SERIAL_PROTOCOLPAIR("  Z2_MAX:", TEST(current_endstop_bits_local, Z2_MAX));
+        if (TEST(endstop_change, Z2_MAX)) SERIAL_PROTOCOLPAIR("  Z2_MAX:", TEST(live_state_local, Z2_MAX));
       #endif
       SERIAL_PROTOCOLPGM("\n\n");
       analogWrite(LED_PIN, local_LED_status);
       local_LED_status ^= 255;
-      old_endstop_bits_local = current_endstop_bits_local;
+      old_live_state_local = live_state_local;
     }
   }
 

commit 569df3fc0ccb8b000cc56dd55e6369008ed3f7a2
Author: etagle <ejtagle@hotmail.com>
Date:   Wed May 16 04:08:43 2018 -0300

    Fix interrupt-based endstop detection
    
    - Also implemented real endstop reading on interrupt.

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 17f9277ae4..d354774afe 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -32,18 +32,27 @@
 #include "../module/temperature.h"
 #include "../lcd/ultralcd.h"
 
-// TEST_ENDSTOP: test the old and the current status of an endstop
-#define TEST_ENDSTOP(ENDSTOP) (TEST(current_endstop_bits & old_endstop_bits, ENDSTOP))
+#if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
+  #include HAL_PATH(../HAL, endstop_interrupts.h)
+#endif
+
+// TEST_ENDSTOP: test the current status of an endstop
+#define TEST_ENDSTOP(ENDSTOP) (TEST(current_endstop_bits, ENDSTOP))
+
+#if HAS_BED_PROBE
+  #define ENDSTOPS_ENABLED  (endstops.enabled || endstops.z_probe_enabled)
+#else
+  #define ENDSTOPS_ENABLED  endstops.enabled
+#endif
 
 Endstops endstops;
 
 // public:
 
 bool Endstops::enabled, Endstops::enabled_globally; // Initialized by settings.load()
-volatile char Endstops::endstop_hit_bits; // use X_MIN, Y_MIN, Z_MIN and Z_MIN_PROBE as BIT value
+volatile uint8_t Endstops::endstop_hit_bits; // use X_MIN, Y_MIN, Z_MIN and Z_MIN_PROBE as BIT value
 
-Endstops::esbits_t Endstops::current_endstop_bits = 0,
-                   Endstops::old_endstop_bits = 0;
+Endstops::esbits_t Endstops::current_endstop_bits = 0;
 
 #if HAS_BED_PROBE
   volatile bool Endstops::z_probe_enabled = false;
@@ -196,8 +205,93 @@ void Endstops::init() {
     #endif
   #endif
 
+  #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
+    setup_endstop_interrupts();
+  #endif
+
+  // Enable endstops
+  enable_globally(
+    #if ENABLED(ENDSTOPS_ALWAYS_ON_DEFAULT)
+      true
+    #else
+      false
+    #endif
+  );
+
 } // Endstops::init
 
+// Called from ISR. A change was detected. Find out what happened!
+void Endstops::check_possible_change() { if (ENDSTOPS_ENABLED) endstops.update(); }
+
+// Called from ISR: Poll endstop state if required
+void Endstops::poll() {
+
+  #if ENABLED(PINS_DEBUGGING)
+    endstops.run_monitor();  // report changes in endstop status
+  #endif
+
+  #if DISABLED(ENDSTOP_INTERRUPTS_FEATURE)
+    if (ENDSTOPS_ENABLED) endstops.update();
+  #endif
+}
+
+void Endstops::enable_globally(const bool onoff) {
+  enabled_globally = enabled = onoff;
+
+  #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
+    if (onoff) endstops.update(); // If enabling, update state now
+  #endif
+}
+
+// Enable / disable endstop checking
+void Endstops::enable(const bool onoff) {
+  enabled = onoff;
+
+  #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
+    if (onoff) endstops.update(); // If enabling, update state now
+  #endif
+}
+
+
+// Disable / Enable endstops based on ENSTOPS_ONLY_FOR_HOMING and global enable
+void Endstops::not_homing() {
+  enabled = enabled_globally;
+
+  #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
+    if (enabled) endstops.update(); // If enabling, update state now
+  #endif
+}
+
+// Clear endstops (i.e., they were hit intentionally) to suppress the report
+void Endstops::hit_on_purpose() {
+  endstop_hit_bits = 0;
+
+  #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
+    if (enabled) endstops.update(); // If enabling, update state now
+  #endif
+}
+
+// Enable / disable endstop z-probe checking
+#if HAS_BED_PROBE
+  void Endstops::enable_z_probe(bool onoff) {
+    z_probe_enabled = onoff;
+
+    #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
+      if (enabled) endstops.update(); // If enabling, update state now
+    #endif
+  }
+#endif
+
+#if ENABLED(PINS_DEBUGGING)
+  void Endstops::run_monitor() {
+    if (!monitor_flag) return;
+    static uint8_t monitor_count = 16;  // offset this check from the others
+    monitor_count += _BV(1);            //  15 Hz
+    monitor_count &= 0x7F;
+    if (!monitor_count) monitor();      // report changes in endstop status
+  }
+#endif
+
 void Endstops::report_state() {
   if (endstop_hit_bits) {
     #if ENABLED(ULTRA_LCD)
@@ -300,38 +394,41 @@ void Endstops::M119() {
   #endif
 } // Endstops::M119
 
+// The following routines are called from an ISR context. It could be the temperature ISR, the
+// endstop ISR or the Stepper ISR.
+
 #if ENABLED(X_DUAL_ENDSTOPS)
   void Endstops::test_dual_x_endstops(const EndstopEnum es1, const EndstopEnum es2) {
     const byte x_test = TEST_ENDSTOP(es1) | (TEST_ENDSTOP(es2) << 1); // bit 0 for X, bit 1 for X2
-    if (x_test && stepper.current_block->steps[X_AXIS] > 0) {
+    if (x_test && stepper.movement_non_null(X_AXIS)) {
       SBI(endstop_hit_bits, X_MIN);
       if (!stepper.performing_homing || (x_test == 0x3))  //if not performing home or if both endstops were trigged during homing...
-        stepper.kill_current_block();
+        stepper.quick_stop();
     }
   }
 #endif
 #if ENABLED(Y_DUAL_ENDSTOPS)
   void Endstops::test_dual_y_endstops(const EndstopEnum es1, const EndstopEnum es2) {
     const byte y_test = TEST_ENDSTOP(es1) | (TEST_ENDSTOP(es2) << 1); // bit 0 for Y, bit 1 for Y2
-    if (y_test && stepper.current_block->steps[Y_AXIS] > 0) {
+    if (y_test && stepper.movement_non_null(Y_AXIS)) {
       SBI(endstop_hit_bits, Y_MIN);
       if (!stepper.performing_homing || (y_test == 0x3))  //if not performing home or if both endstops were trigged during homing...
-        stepper.kill_current_block();
+        stepper.quick_stop();
     }
   }
 #endif
 #if ENABLED(Z_DUAL_ENDSTOPS)
   void Endstops::test_dual_z_endstops(const EndstopEnum es1, const EndstopEnum es2) {
     const byte z_test = TEST_ENDSTOP(es1) | (TEST_ENDSTOP(es2) << 1); // bit 0 for Z, bit 1 for Z2
-    if (z_test && stepper.current_block->steps[Z_AXIS] > 0) {
+    if (z_test && stepper.movement_non_null(Z_AXIS)) {
       SBI(endstop_hit_bits, Z_MIN);
       if (!stepper.performing_homing || (z_test == 0x3))  //if not performing home or if both endstops were trigged during homing...
-        stepper.kill_current_block();
+        stepper.quick_stop();
     }
   }
 #endif
 
-// Check endstops - Called from ISR!
+// Check endstops - Could be called from ISR!
 void Endstops::update() {
 
   #define _ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
@@ -358,9 +455,9 @@ void Endstops::update() {
     if (G38_move) {
       UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
       if (TEST_ENDSTOP(_ENDSTOP(Z, MIN_PROBE))) {
-        if      (stepper.current_block->steps[_AXIS(X)] > 0) { _ENDSTOP_HIT(X, MIN); planner.endstop_triggered(_AXIS(X)); }
-        else if (stepper.current_block->steps[_AXIS(Y)] > 0) { _ENDSTOP_HIT(Y, MIN); planner.endstop_triggered(_AXIS(Y)); }
-        else if (stepper.current_block->steps[_AXIS(Z)] > 0) { _ENDSTOP_HIT(Z, MIN); planner.endstop_triggered(_AXIS(Z)); }
+        if      (stepper.movement_non_null(_AXIS(X))) { _ENDSTOP_HIT(X, MIN); planner.endstop_triggered(_AXIS(X)); }
+        else if (stepper.movement_non_null(_AXIS(Y))) { _ENDSTOP_HIT(Y, MIN); planner.endstop_triggered(_AXIS(Y)); }
+        else if (stepper.movement_non_null(_AXIS(Z))) { _ENDSTOP_HIT(Z, MIN); planner.endstop_triggered(_AXIS(Z)); }
         G38_endstop_hit = true;
       }
     }
@@ -371,7 +468,7 @@ void Endstops::update() {
    */
 
   #if IS_CORE
-    #define S_(N) stepper.current_block->steps[CORE_AXIS_##N]
+    #define S_(N) stepper.movement_non_null(CORE_AXIS_##N)
     #define D_(N) stepper.motor_direction(CORE_AXIS_##N)
   #endif
 
@@ -391,7 +488,7 @@ void Endstops::update() {
     #define X_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && D_(1) X_CMP D_(2)) )
     #define X_AXIS_HEAD X_HEAD
   #else
-    #define X_MOVE_TEST stepper.current_block->steps[X_AXIS] > 0
+    #define X_MOVE_TEST stepper.movement_non_null(X_AXIS)
     #define X_AXIS_HEAD X_AXIS
   #endif
 
@@ -411,7 +508,7 @@ void Endstops::update() {
     #define Y_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && D_(1) Y_CMP D_(2)) )
     #define Y_AXIS_HEAD Y_HEAD
   #else
-    #define Y_MOVE_TEST stepper.current_block->steps[Y_AXIS] > 0
+    #define Y_MOVE_TEST stepper.movement_non_null(Y_AXIS)
     #define Y_AXIS_HEAD Y_AXIS
   #endif
 
@@ -431,13 +528,13 @@ void Endstops::update() {
     #define Z_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && D_(1) Z_CMP D_(2)) )
     #define Z_AXIS_HEAD Z_HEAD
   #else
-    #define Z_MOVE_TEST stepper.current_block->steps[Z_AXIS] > 0
+    #define Z_MOVE_TEST stepper.movement_non_null(Z_AXIS)
     #define Z_AXIS_HEAD Z_AXIS
   #endif
 
   // With Dual X, endstops are only checked in the homing direction for the active extruder
   #if ENABLED(DUAL_X_CARRIAGE)
-    #define E0_ACTIVE stepper.current_block->active_extruder == 0
+    #define E0_ACTIVE stepper.movement_extruder() == 0
     #define X_MIN_TEST ((X_HOME_DIR < 0 && E0_ACTIVE) || (X2_HOME_DIR < 0 && !E0_ACTIVE))
     #define X_MAX_TEST ((X_HOME_DIR > 0 && E0_ACTIVE) || (X2_HOME_DIR > 0 && !E0_ACTIVE))
   #else
@@ -448,126 +545,119 @@ void Endstops::update() {
   /**
    * Check and update endstops according to conditions
    */
-  if (stepper.current_block) {
-
-    if (X_MOVE_TEST) {
-      if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
-        #if HAS_X_MIN
-          #if ENABLED(X_DUAL_ENDSTOPS)
-            UPDATE_ENDSTOP_BIT(X, MIN);
-            #if HAS_X2_MIN
-              UPDATE_ENDSTOP_BIT(X2, MIN);
-            #else
-              COPY_BIT(current_endstop_bits, X_MIN, X2_MIN);
-            #endif
-            test_dual_x_endstops(X_MIN, X2_MIN);
+  if (X_MOVE_TEST) {
+    if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
+      #if HAS_X_MIN
+        #if ENABLED(X_DUAL_ENDSTOPS)
+          UPDATE_ENDSTOP_BIT(X, MIN);
+          #if HAS_X2_MIN
+            UPDATE_ENDSTOP_BIT(X2, MIN);
           #else
-            if (X_MIN_TEST) UPDATE_ENDSTOP(X, MIN);
+            COPY_BIT(current_endstop_bits, X_MIN, X2_MIN);
           #endif
+          test_dual_x_endstops(X_MIN, X2_MIN);
+        #else
+          if (X_MIN_TEST) UPDATE_ENDSTOP(X, MIN);
         #endif
-      }
-      else { // +direction
-        #if HAS_X_MAX
-          #if ENABLED(X_DUAL_ENDSTOPS)
-            UPDATE_ENDSTOP_BIT(X, MAX);
-            #if HAS_X2_MAX
-              UPDATE_ENDSTOP_BIT(X2, MAX);
-            #else
-              COPY_BIT(current_endstop_bits, X_MAX, X2_MAX);
-            #endif
-            test_dual_x_endstops(X_MAX, X2_MAX);
+      #endif
+    }
+    else { // +direction
+      #if HAS_X_MAX
+        #if ENABLED(X_DUAL_ENDSTOPS)
+          UPDATE_ENDSTOP_BIT(X, MAX);
+          #if HAS_X2_MAX
+            UPDATE_ENDSTOP_BIT(X2, MAX);
           #else
-            if (X_MAX_TEST) UPDATE_ENDSTOP(X, MAX);
+            COPY_BIT(current_endstop_bits, X_MAX, X2_MAX);
           #endif
+          test_dual_x_endstops(X_MAX, X2_MAX);
+        #else
+          if (X_MAX_TEST) UPDATE_ENDSTOP(X, MAX);
         #endif
-      }
+      #endif
     }
+  }
 
-    if (Y_MOVE_TEST) {
-      if (stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
-        #if HAS_Y_MIN
-          #if ENABLED(Y_DUAL_ENDSTOPS)
-            UPDATE_ENDSTOP_BIT(Y, MIN);
-            #if HAS_Y2_MIN
-              UPDATE_ENDSTOP_BIT(Y2, MIN);
-            #else
-              COPY_BIT(current_endstop_bits, Y_MIN, Y2_MIN);
-            #endif
-            test_dual_y_endstops(Y_MIN, Y2_MIN);
+  if (Y_MOVE_TEST) {
+    if (stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
+      #if HAS_Y_MIN
+        #if ENABLED(Y_DUAL_ENDSTOPS)
+          UPDATE_ENDSTOP_BIT(Y, MIN);
+          #if HAS_Y2_MIN
+            UPDATE_ENDSTOP_BIT(Y2, MIN);
           #else
-            UPDATE_ENDSTOP(Y, MIN);
+            COPY_BIT(current_endstop_bits, Y_MIN, Y2_MIN);
           #endif
+          test_dual_y_endstops(Y_MIN, Y2_MIN);
+        #else
+          UPDATE_ENDSTOP(Y, MIN);
         #endif
-      }
-      else { // +direction
-        #if HAS_Y_MAX
-          #if ENABLED(Y_DUAL_ENDSTOPS)
-            UPDATE_ENDSTOP_BIT(Y, MAX);
-            #if HAS_Y2_MAX
-              UPDATE_ENDSTOP_BIT(Y2, MAX);
-            #else
-              COPY_BIT(current_endstop_bits, Y_MAX, Y2_MAX);
-            #endif
-            test_dual_y_endstops(Y_MAX, Y2_MAX);
+      #endif
+    }
+    else { // +direction
+      #if HAS_Y_MAX
+        #if ENABLED(Y_DUAL_ENDSTOPS)
+          UPDATE_ENDSTOP_BIT(Y, MAX);
+          #if HAS_Y2_MAX
+            UPDATE_ENDSTOP_BIT(Y2, MAX);
           #else
-            UPDATE_ENDSTOP(Y, MAX);
+            COPY_BIT(current_endstop_bits, Y_MAX, Y2_MAX);
           #endif
+          test_dual_y_endstops(Y_MAX, Y2_MAX);
+        #else
+          UPDATE_ENDSTOP(Y, MAX);
         #endif
-      }
+      #endif
     }
+  }
 
-    if (Z_MOVE_TEST) {
-      if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
-        #if HAS_Z_MIN
-          #if ENABLED(Z_DUAL_ENDSTOPS)
-            UPDATE_ENDSTOP_BIT(Z, MIN);
-            #if HAS_Z2_MIN
-              UPDATE_ENDSTOP_BIT(Z2, MIN);
-            #else
-              COPY_BIT(current_endstop_bits, Z_MIN, Z2_MIN);
-            #endif
-            test_dual_z_endstops(Z_MIN, Z2_MIN);
+  if (Z_MOVE_TEST) {
+    if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
+      #if HAS_Z_MIN
+        #if ENABLED(Z_DUAL_ENDSTOPS)
+          UPDATE_ENDSTOP_BIT(Z, MIN);
+          #if HAS_Z2_MIN
+            UPDATE_ENDSTOP_BIT(Z2, MIN);
+          #else
+            COPY_BIT(current_endstop_bits, Z_MIN, Z2_MIN);
+          #endif
+          test_dual_z_endstops(Z_MIN, Z2_MIN);
+        #else
+          #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
+            if (z_probe_enabled) UPDATE_ENDSTOP(Z, MIN);
           #else
-            #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
-              if (z_probe_enabled) UPDATE_ENDSTOP(Z, MIN);
-            #else
-              UPDATE_ENDSTOP(Z, MIN);
-            #endif
+            UPDATE_ENDSTOP(Z, MIN);
           #endif
         #endif
+      #endif
 
-        // When closing the gap check the enabled probe
-        #if ENABLED(Z_MIN_PROBE_ENDSTOP)
-          if (z_probe_enabled) {
-            UPDATE_ENDSTOP(Z, MIN_PROBE);
-            if (TEST_ENDSTOP(Z_MIN_PROBE)) SBI(endstop_hit_bits, Z_MIN_PROBE);
-          }
-        #endif
-      }
-      else { // Z +direction. Gantry up, bed down.
-        #if HAS_Z_MAX
-          // Check both Z dual endstops
-          #if ENABLED(Z_DUAL_ENDSTOPS)
-            UPDATE_ENDSTOP_BIT(Z, MAX);
-            #if HAS_Z2_MAX
-              UPDATE_ENDSTOP_BIT(Z2, MAX);
-            #else
-              COPY_BIT(current_endstop_bits, Z_MAX, Z2_MAX);
-            #endif
-            test_dual_z_endstops(Z_MAX, Z2_MAX);
-          // If this pin is not hijacked for the bed probe
-          // then it belongs to the Z endstop
-          #elif DISABLED(Z_MIN_PROBE_ENDSTOP) || Z_MAX_PIN != Z_MIN_PROBE_PIN
-            UPDATE_ENDSTOP(Z, MAX);
+      // When closing the gap check the enabled probe
+      #if ENABLED(Z_MIN_PROBE_ENDSTOP)
+        if (z_probe_enabled) {
+          UPDATE_ENDSTOP(Z, MIN_PROBE);
+          if (TEST_ENDSTOP(Z_MIN_PROBE)) SBI(endstop_hit_bits, Z_MIN_PROBE);
+        }
+      #endif
+    }
+    else { // Z +direction. Gantry up, bed down.
+      #if HAS_Z_MAX
+        // Check both Z dual endstops
+        #if ENABLED(Z_DUAL_ENDSTOPS)
+          UPDATE_ENDSTOP_BIT(Z, MAX);
+          #if HAS_Z2_MAX
+            UPDATE_ENDSTOP_BIT(Z2, MAX);
+          #else
+            COPY_BIT(current_endstop_bits, Z_MAX, Z2_MAX);
           #endif
+          test_dual_z_endstops(Z_MAX, Z2_MAX);
+        // If this pin is not hijacked for the bed probe
+        // then it belongs to the Z endstop
+        #elif DISABLED(Z_MIN_PROBE_ENDSTOP) || Z_MAX_PIN != Z_MIN_PROBE_PIN
+          UPDATE_ENDSTOP(Z, MAX);
         #endif
-      }
+      #endif
     }
-
-  } // stepper.current_block
-
-  old_endstop_bits = current_endstop_bits;
-
+  }
 } // Endstops::update()
 
 #if ENABLED(PINS_DEBUGGING)

commit a11eb50a3eab6d58d595a67e526fb51190018db3
Author: etagle <ejtagle@hotmail.com>
Date:   Wed May 9 02:17:53 2018 -0300

    Refactor and optimize Stepper/Planner
    
    Better encapsulation and considerably reduce stepper jitter

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index f0942a3a3a..17f9277ae4 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -208,7 +208,7 @@ void Endstops::report_state() {
     #endif
 
     #define _ENDSTOP_HIT_ECHO(A,C) do{ \
-      SERIAL_ECHOPAIR(" " STRINGIFY(A) ":", stepper.triggered_position_mm(_AXIS(A))); \
+      SERIAL_ECHOPAIR(" " STRINGIFY(A) ":", planner.triggered_position_mm(_AXIS(A))); \
       _SET_STOP_CHAR(A,C); }while(0)
 
     #define _ENDSTOP_HIT_TEST(A,C) \
@@ -238,7 +238,7 @@ void Endstops::report_state() {
     hit_on_purpose();
 
     #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED) && ENABLED(SDSUPPORT)
-      if (stepper.abort_on_endstop_hit) {
+      if (planner.abort_on_endstop_hit) {
         card.sdprinting = false;
         card.closefile();
         quickstop_stepper();
@@ -349,7 +349,7 @@ void Endstops::update() {
       UPDATE_ENDSTOP_BIT(AXIS, MINMAX); \
       if (TEST_ENDSTOP(_ENDSTOP(AXIS, MINMAX))) { \
         _ENDSTOP_HIT(AXIS, MINMAX); \
-        stepper.endstop_triggered(_AXIS(AXIS)); \
+        planner.endstop_triggered(_AXIS(AXIS)); \
       } \
     }while(0)
 
@@ -358,9 +358,9 @@ void Endstops::update() {
     if (G38_move) {
       UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
       if (TEST_ENDSTOP(_ENDSTOP(Z, MIN_PROBE))) {
-        if      (stepper.current_block->steps[_AXIS(X)] > 0) { _ENDSTOP_HIT(X, MIN); stepper.endstop_triggered(_AXIS(X)); }
-        else if (stepper.current_block->steps[_AXIS(Y)] > 0) { _ENDSTOP_HIT(Y, MIN); stepper.endstop_triggered(_AXIS(Y)); }
-        else if (stepper.current_block->steps[_AXIS(Z)] > 0) { _ENDSTOP_HIT(Z, MIN); stepper.endstop_triggered(_AXIS(Z)); }
+        if      (stepper.current_block->steps[_AXIS(X)] > 0) { _ENDSTOP_HIT(X, MIN); planner.endstop_triggered(_AXIS(X)); }
+        else if (stepper.current_block->steps[_AXIS(Y)] > 0) { _ENDSTOP_HIT(Y, MIN); planner.endstop_triggered(_AXIS(Y)); }
+        else if (stepper.current_block->steps[_AXIS(Z)] > 0) { _ENDSTOP_HIT(Z, MIN); planner.endstop_triggered(_AXIS(Z)); }
         G38_endstop_hit = true;
       }
     }

commit ba4c32eec52353159d5a5dd9c5a7402b8113a036
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 13 10:40:45 2018 -0500

    Followup to _AXIS patch

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index c7bb167b29..f0942a3a3a 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -208,7 +208,7 @@ void Endstops::report_state() {
     #endif
 
     #define _ENDSTOP_HIT_ECHO(A,C) do{ \
-      SERIAL_ECHOPAIR(" " STRINGIFY(A) ":", stepper.triggered_position_mm(A ##_AXIS)); \
+      SERIAL_ECHOPAIR(" " STRINGIFY(A) ":", stepper.triggered_position_mm(_AXIS(A))); \
       _SET_STOP_CHAR(A,C); }while(0)
 
     #define _ENDSTOP_HIT_TEST(A,C) \

commit a5c6d3c7b88f90db911db79b00734dd215bf72c4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Mar 20 04:20:45 2018 -0500

    Prevent null pointer crash in Endstops::update
    
    Thanks to Evgeny Kotsuba!

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index c6c84cee8f..c7bb167b29 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -448,119 +448,123 @@ void Endstops::update() {
   /**
    * Check and update endstops according to conditions
    */
-  if (X_MOVE_TEST) {
-    if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
-      #if HAS_X_MIN
-        #if ENABLED(X_DUAL_ENDSTOPS)
-          UPDATE_ENDSTOP_BIT(X, MIN);
-          #if HAS_X2_MIN
-            UPDATE_ENDSTOP_BIT(X2, MIN);
+  if (stepper.current_block) {
+
+    if (X_MOVE_TEST) {
+      if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
+        #if HAS_X_MIN
+          #if ENABLED(X_DUAL_ENDSTOPS)
+            UPDATE_ENDSTOP_BIT(X, MIN);
+            #if HAS_X2_MIN
+              UPDATE_ENDSTOP_BIT(X2, MIN);
+            #else
+              COPY_BIT(current_endstop_bits, X_MIN, X2_MIN);
+            #endif
+            test_dual_x_endstops(X_MIN, X2_MIN);
           #else
-            COPY_BIT(current_endstop_bits, X_MIN, X2_MIN);
+            if (X_MIN_TEST) UPDATE_ENDSTOP(X, MIN);
           #endif
-          test_dual_x_endstops(X_MIN, X2_MIN);
-        #else
-          if (X_MIN_TEST) UPDATE_ENDSTOP(X, MIN);
         #endif
-      #endif
-    }
-    else { // +direction
-      #if HAS_X_MAX
-        #if ENABLED(X_DUAL_ENDSTOPS)
-          UPDATE_ENDSTOP_BIT(X, MAX);
-          #if HAS_X2_MAX
-            UPDATE_ENDSTOP_BIT(X2, MAX);
+      }
+      else { // +direction
+        #if HAS_X_MAX
+          #if ENABLED(X_DUAL_ENDSTOPS)
+            UPDATE_ENDSTOP_BIT(X, MAX);
+            #if HAS_X2_MAX
+              UPDATE_ENDSTOP_BIT(X2, MAX);
+            #else
+              COPY_BIT(current_endstop_bits, X_MAX, X2_MAX);
+            #endif
+            test_dual_x_endstops(X_MAX, X2_MAX);
           #else
-            COPY_BIT(current_endstop_bits, X_MAX, X2_MAX);
+            if (X_MAX_TEST) UPDATE_ENDSTOP(X, MAX);
           #endif
-          test_dual_x_endstops(X_MAX, X2_MAX);
-        #else
-          if (X_MAX_TEST) UPDATE_ENDSTOP(X, MAX);
         #endif
-      #endif
+      }
     }
-  }
 
-  if (Y_MOVE_TEST) {
-    if (stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
-      #if HAS_Y_MIN
-        #if ENABLED(Y_DUAL_ENDSTOPS)
-          UPDATE_ENDSTOP_BIT(Y, MIN);
-          #if HAS_Y2_MIN
-            UPDATE_ENDSTOP_BIT(Y2, MIN);
+    if (Y_MOVE_TEST) {
+      if (stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
+        #if HAS_Y_MIN
+          #if ENABLED(Y_DUAL_ENDSTOPS)
+            UPDATE_ENDSTOP_BIT(Y, MIN);
+            #if HAS_Y2_MIN
+              UPDATE_ENDSTOP_BIT(Y2, MIN);
+            #else
+              COPY_BIT(current_endstop_bits, Y_MIN, Y2_MIN);
+            #endif
+            test_dual_y_endstops(Y_MIN, Y2_MIN);
           #else
-            COPY_BIT(current_endstop_bits, Y_MIN, Y2_MIN);
+            UPDATE_ENDSTOP(Y, MIN);
           #endif
-          test_dual_y_endstops(Y_MIN, Y2_MIN);
-        #else
-          UPDATE_ENDSTOP(Y, MIN);
         #endif
-      #endif
-    }
-    else { // +direction
-      #if HAS_Y_MAX
-        #if ENABLED(Y_DUAL_ENDSTOPS)
-          UPDATE_ENDSTOP_BIT(Y, MAX);
-          #if HAS_Y2_MAX
-            UPDATE_ENDSTOP_BIT(Y2, MAX);
+      }
+      else { // +direction
+        #if HAS_Y_MAX
+          #if ENABLED(Y_DUAL_ENDSTOPS)
+            UPDATE_ENDSTOP_BIT(Y, MAX);
+            #if HAS_Y2_MAX
+              UPDATE_ENDSTOP_BIT(Y2, MAX);
+            #else
+              COPY_BIT(current_endstop_bits, Y_MAX, Y2_MAX);
+            #endif
+            test_dual_y_endstops(Y_MAX, Y2_MAX);
           #else
-            COPY_BIT(current_endstop_bits, Y_MAX, Y2_MAX);
+            UPDATE_ENDSTOP(Y, MAX);
           #endif
-          test_dual_y_endstops(Y_MAX, Y2_MAX);
-        #else
-          UPDATE_ENDSTOP(Y, MAX);
         #endif
-      #endif
+      }
     }
-  }
 
-  if (Z_MOVE_TEST) {
-    if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
-      #if HAS_Z_MIN
-        #if ENABLED(Z_DUAL_ENDSTOPS)
-          UPDATE_ENDSTOP_BIT(Z, MIN);
-          #if HAS_Z2_MIN
-            UPDATE_ENDSTOP_BIT(Z2, MIN);
-          #else
-            COPY_BIT(current_endstop_bits, Z_MIN, Z2_MIN);
-          #endif
-          test_dual_z_endstops(Z_MIN, Z2_MIN);
-        #else
-          #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
-            if (z_probe_enabled) UPDATE_ENDSTOP(Z, MIN);
+    if (Z_MOVE_TEST) {
+      if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
+        #if HAS_Z_MIN
+          #if ENABLED(Z_DUAL_ENDSTOPS)
+            UPDATE_ENDSTOP_BIT(Z, MIN);
+            #if HAS_Z2_MIN
+              UPDATE_ENDSTOP_BIT(Z2, MIN);
+            #else
+              COPY_BIT(current_endstop_bits, Z_MIN, Z2_MIN);
+            #endif
+            test_dual_z_endstops(Z_MIN, Z2_MIN);
           #else
-            UPDATE_ENDSTOP(Z, MIN);
+            #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
+              if (z_probe_enabled) UPDATE_ENDSTOP(Z, MIN);
+            #else
+              UPDATE_ENDSTOP(Z, MIN);
+            #endif
           #endif
         #endif
-      #endif
 
-      // When closing the gap check the enabled probe
-      #if ENABLED(Z_MIN_PROBE_ENDSTOP)
-        if (z_probe_enabled) {
-          UPDATE_ENDSTOP(Z, MIN_PROBE);
-          if (TEST_ENDSTOP(Z_MIN_PROBE)) SBI(endstop_hit_bits, Z_MIN_PROBE);
-        }
-      #endif
-    }
-    else { // Z +direction. Gantry up, bed down.
-      #if HAS_Z_MAX
-        // Check both Z dual endstops
-        #if ENABLED(Z_DUAL_ENDSTOPS)
-          UPDATE_ENDSTOP_BIT(Z, MAX);
-          #if HAS_Z2_MAX
-            UPDATE_ENDSTOP_BIT(Z2, MAX);
-          #else
-            COPY_BIT(current_endstop_bits, Z_MAX, Z2_MAX);
+        // When closing the gap check the enabled probe
+        #if ENABLED(Z_MIN_PROBE_ENDSTOP)
+          if (z_probe_enabled) {
+            UPDATE_ENDSTOP(Z, MIN_PROBE);
+            if (TEST_ENDSTOP(Z_MIN_PROBE)) SBI(endstop_hit_bits, Z_MIN_PROBE);
+          }
+        #endif
+      }
+      else { // Z +direction. Gantry up, bed down.
+        #if HAS_Z_MAX
+          // Check both Z dual endstops
+          #if ENABLED(Z_DUAL_ENDSTOPS)
+            UPDATE_ENDSTOP_BIT(Z, MAX);
+            #if HAS_Z2_MAX
+              UPDATE_ENDSTOP_BIT(Z2, MAX);
+            #else
+              COPY_BIT(current_endstop_bits, Z_MAX, Z2_MAX);
+            #endif
+            test_dual_z_endstops(Z_MAX, Z2_MAX);
+          // If this pin is not hijacked for the bed probe
+          // then it belongs to the Z endstop
+          #elif DISABLED(Z_MIN_PROBE_ENDSTOP) || Z_MAX_PIN != Z_MIN_PROBE_PIN
+            UPDATE_ENDSTOP(Z, MAX);
           #endif
-          test_dual_z_endstops(Z_MAX, Z2_MAX);
-        // If this pin is not hijacked for the bed probe
-        // then it belongs to the Z endstop
-        #elif DISABLED(Z_MIN_PROBE_ENDSTOP) || Z_MAX_PIN != Z_MIN_PROBE_PIN
-          UPDATE_ENDSTOP(Z, MAX);
         #endif
-      #endif
+      }
     }
-  }
+
+  } // stepper.current_block
 
   old_endstop_bits = current_endstop_bits;
 

commit f10c87b442dd5a3aa0e5a327d85e5c509c2cb02b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Mar 10 05:56:04 2018 -0600

    Update Endstops class for 1.1.x parity

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 06472e112c..c6c84cee8f 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -42,26 +42,22 @@ Endstops endstops;
 bool Endstops::enabled, Endstops::enabled_globally; // Initialized by settings.load()
 volatile char Endstops::endstop_hit_bits; // use X_MIN, Y_MIN, Z_MIN and Z_MIN_PROBE as BIT value
 
-#if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
-  uint16_t
-#else
-  byte
-#endif
-    Endstops::current_endstop_bits = 0,
-    Endstops::old_endstop_bits = 0;
+Endstops::esbits_t Endstops::current_endstop_bits = 0,
+                   Endstops::old_endstop_bits = 0;
 
 #if HAS_BED_PROBE
   volatile bool Endstops::z_probe_enabled = false;
 #endif
 
+// Initialized by settings.load()
 #if ENABLED(X_DUAL_ENDSTOPS)
-  float Endstops::x_endstop_adj; // Initialized by settings.load()
+  float Endstops::x_endstop_adj;
 #endif
 #if ENABLED(Y_DUAL_ENDSTOPS)
-  float Endstops::y_endstop_adj; // Initialized by settings.load()
+  float Endstops::y_endstop_adj;
 #endif
 #if ENABLED(Z_DUAL_ENDSTOPS)
-  float Endstops::z_endstop_adj; // Initialized by settings.load()
+  float Endstops::z_endstop_adj;
 #endif
 
 /**
@@ -355,7 +351,7 @@ void Endstops::update() {
         _ENDSTOP_HIT(AXIS, MINMAX); \
         stepper.endstop_triggered(_AXIS(AXIS)); \
       } \
-    } while(0)
+    }while(0)
 
   #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && !(CORE_IS_XY || CORE_IS_XZ)
     // If G38 command is active check Z_MIN_PROBE for ALL movement
@@ -452,7 +448,6 @@ void Endstops::update() {
   /**
    * Check and update endstops according to conditions
    */
-
   if (X_MOVE_TEST) {
     if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
       #if HAS_X_MIN

commit 161ff9ff356e2ef608f510d28b87d28d287c05a5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Mar 9 08:54:48 2018 -0600

    Fix UPDATE_ENDSTOP for CorePQ compatibility
    
    Fixes #9939

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 9b424a95c4..06472e112c 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -351,7 +351,7 @@ void Endstops::update() {
 
   #define UPDATE_ENDSTOP(AXIS,MINMAX) do { \
       UPDATE_ENDSTOP_BIT(AXIS, MINMAX); \
-      if (TEST_ENDSTOP(_ENDSTOP(AXIS, MINMAX)) && stepper.current_block->steps[_AXIS(AXIS)] > 0) { \
+      if (TEST_ENDSTOP(_ENDSTOP(AXIS, MINMAX))) { \
         _ENDSTOP_HIT(AXIS, MINMAX); \
         stepper.endstop_triggered(_AXIS(AXIS)); \
       } \
@@ -482,7 +482,6 @@ void Endstops::update() {
         #else
           if (X_MAX_TEST) UPDATE_ENDSTOP(X, MAX);
         #endif
-
       #endif
     }
   }

commit ca55f2927ab7416c6f404cfdeade4c9d5103929c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Feb 18 19:26:23 2018 -0600

    Pulldown pin mode support (#9701)
    
    Implemented for LPC1768.

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index c57c71ff8f..9b424a95c4 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -73,6 +73,8 @@ void Endstops::init() {
   #if HAS_X_MIN
     #if ENABLED(ENDSTOPPULLUP_XMIN)
       SET_INPUT_PULLUP(X_MIN_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_XMIN)
+      SET_INPUT_PULLDOWN(X_MIN_PIN);
     #else
       SET_INPUT(X_MIN_PIN);
     #endif
@@ -81,6 +83,8 @@ void Endstops::init() {
   #if HAS_X2_MIN
     #if ENABLED(ENDSTOPPULLUP_XMIN)
       SET_INPUT_PULLUP(X2_MIN_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_XMIN)
+      SET_INPUT_PULLDOWN(X2_MIN_PIN);
     #else
       SET_INPUT(X2_MIN_PIN);
     #endif
@@ -89,6 +93,8 @@ void Endstops::init() {
   #if HAS_Y_MIN
     #if ENABLED(ENDSTOPPULLUP_YMIN)
       SET_INPUT_PULLUP(Y_MIN_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_YMIN)
+      SET_INPUT_PULLDOWN(Y_MIN_PIN);
     #else
       SET_INPUT(Y_MIN_PIN);
     #endif
@@ -97,6 +103,8 @@ void Endstops::init() {
   #if HAS_Y2_MIN
     #if ENABLED(ENDSTOPPULLUP_YMIN)
       SET_INPUT_PULLUP(Y2_MIN_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_YMIN)
+      SET_INPUT_PULLDOWN(Y2_MIN_PIN);
     #else
       SET_INPUT(Y2_MIN_PIN);
     #endif
@@ -105,6 +113,8 @@ void Endstops::init() {
   #if HAS_Z_MIN
     #if ENABLED(ENDSTOPPULLUP_ZMIN)
       SET_INPUT_PULLUP(Z_MIN_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_ZMIN)
+      SET_INPUT_PULLDOWN(Z_MIN_PIN);
     #else
       SET_INPUT(Z_MIN_PIN);
     #endif
@@ -113,6 +123,8 @@ void Endstops::init() {
   #if HAS_Z2_MIN
     #if ENABLED(ENDSTOPPULLUP_ZMIN)
       SET_INPUT_PULLUP(Z2_MIN_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_ZMIN)
+      SET_INPUT_PULLDOWN(Z2_MIN_PIN);
     #else
       SET_INPUT(Z2_MIN_PIN);
     #endif
@@ -121,6 +133,8 @@ void Endstops::init() {
   #if HAS_X_MAX
     #if ENABLED(ENDSTOPPULLUP_XMAX)
       SET_INPUT_PULLUP(X_MAX_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_XMAX)
+      SET_INPUT_PULLDOWN(X_MAX_PIN);
     #else
       SET_INPUT(X_MAX_PIN);
     #endif
@@ -129,6 +143,8 @@ void Endstops::init() {
   #if HAS_X2_MAX
     #if ENABLED(ENDSTOPPULLUP_XMAX)
       SET_INPUT_PULLUP(X2_MAX_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_XMAX)
+      SET_INPUT_PULLDOWN(X2_MAX_PIN);
     #else
       SET_INPUT(X2_MAX_PIN);
     #endif
@@ -137,6 +153,8 @@ void Endstops::init() {
   #if HAS_Y_MAX
     #if ENABLED(ENDSTOPPULLUP_YMAX)
       SET_INPUT_PULLUP(Y_MAX_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_YMAX)
+      SET_INPUT_PULLDOWN(Y_MAX_PIN);
     #else
       SET_INPUT(Y_MAX_PIN);
     #endif
@@ -145,6 +163,8 @@ void Endstops::init() {
   #if HAS_Y2_MAX
     #if ENABLED(ENDSTOPPULLUP_YMAX)
       SET_INPUT_PULLUP(Y2_MAX_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_YMAX)
+      SET_INPUT_PULLDOWN(Y2_MAX_PIN);
     #else
       SET_INPUT(Y2_MAX_PIN);
     #endif
@@ -153,6 +173,8 @@ void Endstops::init() {
   #if HAS_Z_MAX
     #if ENABLED(ENDSTOPPULLUP_ZMAX)
       SET_INPUT_PULLUP(Z_MAX_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_ZMAX)
+      SET_INPUT_PULLDOWN(Z_MAX_PIN);
     #else
       SET_INPUT(Z_MAX_PIN);
     #endif
@@ -161,6 +183,8 @@ void Endstops::init() {
   #if HAS_Z2_MAX
     #if ENABLED(ENDSTOPPULLUP_ZMAX)
       SET_INPUT_PULLUP(Z2_MAX_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_ZMAX)
+      SET_INPUT_PULLDOWN(Z2_MAX_PIN);
     #else
       SET_INPUT(Z2_MAX_PIN);
     #endif
@@ -169,6 +193,8 @@ void Endstops::init() {
   #if ENABLED(Z_MIN_PROBE_ENDSTOP)
     #if ENABLED(ENDSTOPPULLUP_ZMIN_PROBE)
       SET_INPUT_PULLUP(Z_MIN_PROBE_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_ZMIN_PROBE)
+      SET_INPUT_PULLDOWN(Z_MIN_PROBE_PIN);
     #else
       SET_INPUT(Z_MIN_PROBE_PIN);
     #endif

commit c251601916c69bf3a67bc62048c5694f03b410e5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Feb 1 23:58:35 2018 -0600

    Simplified SET_BIT, moved to endstops.cpp

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 3bc9a625dc..c57c71ff8f 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -317,6 +317,7 @@ void Endstops::update() {
   #define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_INVERTING
   #define _ENDSTOP_HIT(AXIS, MINMAX) SBI(endstop_hit_bits, _ENDSTOP(AXIS, MINMAX))
 
+  #define SET_BIT(N,B,TF) do{ if (TF) SBI(N,B); else CBI(N,B); }while(0)
   // UPDATE_ENDSTOP_BIT: set the current endstop bits for an endstop to its status
   #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT(current_endstop_bits, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
   // COPY_BIT: copy the value of SRC_BIT to DST_BIT in DST

commit 441517bbe1625aa68a49aef0f98c6c4184e66dff
Author: √òystein Krog <oystein.krog@gmail.com>
Date:   Sun Jan 21 15:29:32 2018 +0100

    Fix DUAL_X_CARRIAGE endstops
    
    \#8170 fixed

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 32fed65bdc..3bc9a625dc 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -453,7 +453,7 @@ void Endstops::update() {
           #endif
           test_dual_x_endstops(X_MAX, X2_MAX);
         #else
-          if (X_MIN_TEST) UPDATE_ENDSTOP(X, MAX);
+          if (X_MAX_TEST) UPDATE_ENDSTOP(X, MAX);
         #endif
 
       #endif

commit 617993d0ea3fbdd1b20d1f24e019f9cea01f81eb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Nov 21 00:17:36 2017 -0600

    Patch for !!TEST (was _BV once?)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index dae888611c..32fed65bdc 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -609,43 +609,43 @@ void Endstops::update() {
 
     if (endstop_change) {
       #if HAS_X_MIN
-        if (TEST(endstop_change, X_MIN)) SERIAL_PROTOCOLPAIR("  X_MIN:", !!TEST(current_endstop_bits_local, X_MIN));
+        if (TEST(endstop_change, X_MIN)) SERIAL_PROTOCOLPAIR("  X_MIN:", TEST(current_endstop_bits_local, X_MIN));
       #endif
       #if HAS_X_MAX
-        if (TEST(endstop_change, X_MAX)) SERIAL_PROTOCOLPAIR("  X_MAX:", !!TEST(current_endstop_bits_local, X_MAX));
+        if (TEST(endstop_change, X_MAX)) SERIAL_PROTOCOLPAIR("  X_MAX:", TEST(current_endstop_bits_local, X_MAX));
       #endif
       #if HAS_Y_MIN
-        if (TEST(endstop_change, Y_MIN)) SERIAL_PROTOCOLPAIR("  Y_MIN:", !!TEST(current_endstop_bits_local, Y_MIN));
+        if (TEST(endstop_change, Y_MIN)) SERIAL_PROTOCOLPAIR("  Y_MIN:", TEST(current_endstop_bits_local, Y_MIN));
       #endif
       #if HAS_Y_MAX
-        if (TEST(endstop_change, Y_MAX)) SERIAL_PROTOCOLPAIR("  Y_MAX:", !!TEST(current_endstop_bits_local, Y_MAX));
+        if (TEST(endstop_change, Y_MAX)) SERIAL_PROTOCOLPAIR("  Y_MAX:", TEST(current_endstop_bits_local, Y_MAX));
       #endif
       #if HAS_Z_MIN
-        if (TEST(endstop_change, Z_MIN)) SERIAL_PROTOCOLPAIR("  Z_MIN:", !!TEST(current_endstop_bits_local, Z_MIN));
+        if (TEST(endstop_change, Z_MIN)) SERIAL_PROTOCOLPAIR("  Z_MIN:", TEST(current_endstop_bits_local, Z_MIN));
       #endif
       #if HAS_Z_MAX
-        if (TEST(endstop_change, Z_MAX)) SERIAL_PROTOCOLPAIR("  Z_MAX:", !!TEST(current_endstop_bits_local, Z_MAX));
+        if (TEST(endstop_change, Z_MAX)) SERIAL_PROTOCOLPAIR("  Z_MAX:", TEST(current_endstop_bits_local, Z_MAX));
       #endif
       #if HAS_Z_MIN_PROBE_PIN
-        if (TEST(endstop_change, Z_MIN_PROBE)) SERIAL_PROTOCOLPAIR("  PROBE:", !!TEST(current_endstop_bits_local, Z_MIN_PROBE));
+        if (TEST(endstop_change, Z_MIN_PROBE)) SERIAL_PROTOCOLPAIR("  PROBE:", TEST(current_endstop_bits_local, Z_MIN_PROBE));
       #endif
       #if HAS_X2_MIN
-        if (TEST(endstop_change, X2_MIN)) SERIAL_PROTOCOLPAIR("  X2_MIN:", !!TEST(current_endstop_bits_local, X2_MIN));
+        if (TEST(endstop_change, X2_MIN)) SERIAL_PROTOCOLPAIR("  X2_MIN:", TEST(current_endstop_bits_local, X2_MIN));
       #endif
       #if HAS_X2_MAX
-        if (TEST(endstop_change, X2_MAX)) SERIAL_PROTOCOLPAIR("  X2_MAX:", !!TEST(current_endstop_bits_local, X2_MAX));
+        if (TEST(endstop_change, X2_MAX)) SERIAL_PROTOCOLPAIR("  X2_MAX:", TEST(current_endstop_bits_local, X2_MAX));
       #endif
       #if HAS_Y2_MIN
-        if (TEST(endstop_change, Y2_MIN)) SERIAL_PROTOCOLPAIR("  Y2_MIN:", !!TEST(current_endstop_bits_local, Y2_MIN));
+        if (TEST(endstop_change, Y2_MIN)) SERIAL_PROTOCOLPAIR("  Y2_MIN:", TEST(current_endstop_bits_local, Y2_MIN));
       #endif
       #if HAS_Y2_MAX
-        if (TEST(endstop_change, Y2_MAX)) SERIAL_PROTOCOLPAIR("  Y2_MAX:", !!TEST(current_endstop_bits_local, Y2_MAX));
+        if (TEST(endstop_change, Y2_MAX)) SERIAL_PROTOCOLPAIR("  Y2_MAX:", TEST(current_endstop_bits_local, Y2_MAX));
       #endif
       #if HAS_Z2_MIN
-        if (TEST(endstop_change, Z2_MIN)) SERIAL_PROTOCOLPAIR("  Z2_MIN:", !!TEST(current_endstop_bits_local, Z2_MIN));
+        if (TEST(endstop_change, Z2_MIN)) SERIAL_PROTOCOLPAIR("  Z2_MIN:", TEST(current_endstop_bits_local, Z2_MIN));
       #endif
       #if HAS_Z2_MAX
-        if (TEST(endstop_change, Z2_MAX)) SERIAL_PROTOCOLPAIR("  Z2_MAX:", !!TEST(current_endstop_bits_local, Z2_MAX));
+        if (TEST(endstop_change, Z2_MAX)) SERIAL_PROTOCOLPAIR("  Z2_MAX:", TEST(current_endstop_bits_local, Z2_MAX));
       #endif
       SERIAL_PROTOCOLPGM("\n\n");
       analogWrite(LED_PIN, local_LED_status);

commit 723f2a77f6de40024508ea07fd7324e0987a2aa9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Oct 29 03:43:44 2017 -0500

    Implement support for Dual X and Y endstops

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index b194abd5df..dae888611c 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -42,7 +42,7 @@ Endstops endstops;
 bool Endstops::enabled, Endstops::enabled_globally; // Initialized by settings.load()
 volatile char Endstops::endstop_hit_bits; // use X_MIN, Y_MIN, Z_MIN and Z_MIN_PROBE as BIT value
 
-#if ENABLED(Z_DUAL_ENDSTOPS)
+#if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
   uint16_t
 #else
   byte
@@ -54,8 +54,14 @@ volatile char Endstops::endstop_hit_bits; // use X_MIN, Y_MIN, Z_MIN and Z_MIN_P
   volatile bool Endstops::z_probe_enabled = false;
 #endif
 
+#if ENABLED(X_DUAL_ENDSTOPS)
+  float Endstops::x_endstop_adj; // Initialized by settings.load()
+#endif
+#if ENABLED(Y_DUAL_ENDSTOPS)
+  float Endstops::y_endstop_adj; // Initialized by settings.load()
+#endif
 #if ENABLED(Z_DUAL_ENDSTOPS)
-  float Endstops::z_endstop_adj;
+  float Endstops::z_endstop_adj; // Initialized by settings.load()
 #endif
 
 /**
@@ -72,6 +78,14 @@ void Endstops::init() {
     #endif
   #endif
 
+  #if HAS_X2_MIN
+    #if ENABLED(ENDSTOPPULLUP_XMIN)
+      SET_INPUT_PULLUP(X2_MIN_PIN);
+    #else
+      SET_INPUT(X2_MIN_PIN);
+    #endif
+  #endif
+
   #if HAS_Y_MIN
     #if ENABLED(ENDSTOPPULLUP_YMIN)
       SET_INPUT_PULLUP(Y_MIN_PIN);
@@ -80,6 +94,14 @@ void Endstops::init() {
     #endif
   #endif
 
+  #if HAS_Y2_MIN
+    #if ENABLED(ENDSTOPPULLUP_YMIN)
+      SET_INPUT_PULLUP(Y2_MIN_PIN);
+    #else
+      SET_INPUT(Y2_MIN_PIN);
+    #endif
+  #endif
+
   #if HAS_Z_MIN
     #if ENABLED(ENDSTOPPULLUP_ZMIN)
       SET_INPUT_PULLUP(Z_MIN_PIN);
@@ -104,6 +126,14 @@ void Endstops::init() {
     #endif
   #endif
 
+  #if HAS_X2_MAX
+    #if ENABLED(ENDSTOPPULLUP_XMAX)
+      SET_INPUT_PULLUP(X2_MAX_PIN);
+    #else
+      SET_INPUT(X2_MAX_PIN);
+    #endif
+  #endif
+
   #if HAS_Y_MAX
     #if ENABLED(ENDSTOPPULLUP_YMAX)
       SET_INPUT_PULLUP(Y_MAX_PIN);
@@ -112,6 +142,14 @@ void Endstops::init() {
     #endif
   #endif
 
+  #if HAS_Y2_MAX
+    #if ENABLED(ENDSTOPPULLUP_YMAX)
+      SET_INPUT_PULLUP(Y2_MAX_PIN);
+    #else
+      SET_INPUT(Y2_MAX_PIN);
+    #endif
+  #endif
+
   #if HAS_Z_MAX
     #if ENABLED(ENDSTOPPULLUP_ZMAX)
       SET_INPUT_PULLUP(Z_MAX_PIN);
@@ -190,37 +228,45 @@ void Endstops::report_state() {
 
 void Endstops::M119() {
   SERIAL_PROTOCOLLNPGM(MSG_M119_REPORT);
+  #define ES_REPORT(AXIS) do{ \
+    SERIAL_PROTOCOLPGM(MSG_##AXIS); \
+    SERIAL_PROTOCOLLN(((READ(AXIS##_PIN)^AXIS##_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN)); \
+  }while(0)
   #if HAS_X_MIN
-    SERIAL_PROTOCOLPGM(MSG_X_MIN);
-    SERIAL_PROTOCOLLN(((READ(X_MIN_PIN)^X_MIN_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
+    ES_REPORT(X_MIN);
+  #endif
+  #if HAS_X2_MIN
+    ES_REPORT(X2_MIN);
   #endif
   #if HAS_X_MAX
-    SERIAL_PROTOCOLPGM(MSG_X_MAX);
-    SERIAL_PROTOCOLLN(((READ(X_MAX_PIN)^X_MAX_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
+    ES_REPORT(X_MAX);
+  #endif
+  #if HAS_X2_MAX
+    ES_REPORT(X2_MAX);
   #endif
   #if HAS_Y_MIN
-    SERIAL_PROTOCOLPGM(MSG_Y_MIN);
-    SERIAL_PROTOCOLLN(((READ(Y_MIN_PIN)^Y_MIN_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
+    ES_REPORT(Y_MIN);
+  #endif
+  #if HAS_Y2_MIN
+    ES_REPORT(Y2_MIN);
   #endif
   #if HAS_Y_MAX
-    SERIAL_PROTOCOLPGM(MSG_Y_MAX);
-    SERIAL_PROTOCOLLN(((READ(Y_MAX_PIN)^Y_MAX_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
+    ES_REPORT(Y_MAX);
+  #endif
+  #if HAS_Y2_MAX
+    ES_REPORT(Y2_MAX);
   #endif
   #if HAS_Z_MIN
-    SERIAL_PROTOCOLPGM(MSG_Z_MIN);
-    SERIAL_PROTOCOLLN(((READ(Z_MIN_PIN)^Z_MIN_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
+    ES_REPORT(Z_MIN);
   #endif
   #if HAS_Z2_MIN
-    SERIAL_PROTOCOLPGM(MSG_Z2_MIN);
-    SERIAL_PROTOCOLLN(((READ(Z2_MIN_PIN)^Z2_MIN_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
+    ES_REPORT(Z2_MIN);
   #endif
   #if HAS_Z_MAX
-    SERIAL_PROTOCOLPGM(MSG_Z_MAX);
-    SERIAL_PROTOCOLLN(((READ(Z_MAX_PIN)^Z_MAX_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
+    ES_REPORT(Z_MAX);
   #endif
   #if HAS_Z2_MAX
-    SERIAL_PROTOCOLPGM(MSG_Z2_MAX);
-    SERIAL_PROTOCOLLN(((READ(Z2_MAX_PIN)^Z2_MAX_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
+    ES_REPORT(Z2_MAX);
   #endif
   #if ENABLED(Z_MIN_PROBE_ENDSTOP)
     SERIAL_PROTOCOLPGM(MSG_Z_PROBE);
@@ -232,18 +278,35 @@ void Endstops::M119() {
   #endif
 } // Endstops::M119
 
+#if ENABLED(X_DUAL_ENDSTOPS)
+  void Endstops::test_dual_x_endstops(const EndstopEnum es1, const EndstopEnum es2) {
+    const byte x_test = TEST_ENDSTOP(es1) | (TEST_ENDSTOP(es2) << 1); // bit 0 for X, bit 1 for X2
+    if (x_test && stepper.current_block->steps[X_AXIS] > 0) {
+      SBI(endstop_hit_bits, X_MIN);
+      if (!stepper.performing_homing || (x_test == 0x3))  //if not performing home or if both endstops were trigged during homing...
+        stepper.kill_current_block();
+    }
+  }
+#endif
+#if ENABLED(Y_DUAL_ENDSTOPS)
+  void Endstops::test_dual_y_endstops(const EndstopEnum es1, const EndstopEnum es2) {
+    const byte y_test = TEST_ENDSTOP(es1) | (TEST_ENDSTOP(es2) << 1); // bit 0 for Y, bit 1 for Y2
+    if (y_test && stepper.current_block->steps[Y_AXIS] > 0) {
+      SBI(endstop_hit_bits, Y_MIN);
+      if (!stepper.performing_homing || (y_test == 0x3))  //if not performing home or if both endstops were trigged during homing...
+        stepper.kill_current_block();
+    }
+  }
+#endif
 #if ENABLED(Z_DUAL_ENDSTOPS)
-
-  // Pass the result of the endstop test
   void Endstops::test_dual_z_endstops(const EndstopEnum es1, const EndstopEnum es2) {
-    byte z_test = TEST_ENDSTOP(es1) | (TEST_ENDSTOP(es2) << 1); // bit 0 for Z, bit 1 for Z2
+    const byte z_test = TEST_ENDSTOP(es1) | (TEST_ENDSTOP(es2) << 1); // bit 0 for Z, bit 1 for Z2
     if (z_test && stepper.current_block->steps[Z_AXIS] > 0) {
       SBI(endstop_hit_bits, Z_MIN);
       if (!stepper.performing_homing || (z_test == 0x3))  //if not performing home or if both endstops were trigged during homing...
         stepper.kill_current_block();
     }
   }
-
 #endif
 
 // Check endstops - Called from ISR!
@@ -364,16 +427,35 @@ void Endstops::update() {
    */
 
   if (X_MOVE_TEST) {
-    if (stepper.motor_direction(X_AXIS_HEAD)) {
-      if (X_MIN_TEST) { // -direction
-        #if HAS_X_MIN
-          UPDATE_ENDSTOP(X, MIN);
+    if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
+      #if HAS_X_MIN
+        #if ENABLED(X_DUAL_ENDSTOPS)
+          UPDATE_ENDSTOP_BIT(X, MIN);
+          #if HAS_X2_MIN
+            UPDATE_ENDSTOP_BIT(X2, MIN);
+          #else
+            COPY_BIT(current_endstop_bits, X_MIN, X2_MIN);
+          #endif
+          test_dual_x_endstops(X_MIN, X2_MIN);
+        #else
+          if (X_MIN_TEST) UPDATE_ENDSTOP(X, MIN);
         #endif
-      }
+      #endif
     }
-    else if (X_MAX_TEST) { // +direction
+    else { // +direction
       #if HAS_X_MAX
-        UPDATE_ENDSTOP(X, MAX);
+        #if ENABLED(X_DUAL_ENDSTOPS)
+          UPDATE_ENDSTOP_BIT(X, MAX);
+          #if HAS_X2_MAX
+            UPDATE_ENDSTOP_BIT(X2, MAX);
+          #else
+            COPY_BIT(current_endstop_bits, X_MAX, X2_MAX);
+          #endif
+          test_dual_x_endstops(X_MAX, X2_MAX);
+        #else
+          if (X_MIN_TEST) UPDATE_ENDSTOP(X, MAX);
+        #endif
+
       #endif
     }
   }
@@ -381,12 +463,32 @@ void Endstops::update() {
   if (Y_MOVE_TEST) {
     if (stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
       #if HAS_Y_MIN
-        UPDATE_ENDSTOP(Y, MIN);
+        #if ENABLED(Y_DUAL_ENDSTOPS)
+          UPDATE_ENDSTOP_BIT(Y, MIN);
+          #if HAS_Y2_MIN
+            UPDATE_ENDSTOP_BIT(Y2, MIN);
+          #else
+            COPY_BIT(current_endstop_bits, Y_MIN, Y2_MIN);
+          #endif
+          test_dual_y_endstops(Y_MIN, Y2_MIN);
+        #else
+          UPDATE_ENDSTOP(Y, MIN);
+        #endif
       #endif
     }
     else { // +direction
       #if HAS_Y_MAX
-        UPDATE_ENDSTOP(Y, MAX);
+        #if ENABLED(Y_DUAL_ENDSTOPS)
+          UPDATE_ENDSTOP_BIT(Y, MAX);
+          #if HAS_Y2_MAX
+            UPDATE_ENDSTOP_BIT(Y2, MAX);
+          #else
+            COPY_BIT(current_endstop_bits, Y_MAX, Y2_MAX);
+          #endif
+          test_dual_y_endstops(Y_MAX, Y2_MAX);
+        #else
+          UPDATE_ENDSTOP(Y, MAX);
+        #endif
       #endif
     }
   }
@@ -395,27 +497,21 @@ void Endstops::update() {
     if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
       #if HAS_Z_MIN
         #if ENABLED(Z_DUAL_ENDSTOPS)
-
           UPDATE_ENDSTOP_BIT(Z, MIN);
           #if HAS_Z2_MIN
             UPDATE_ENDSTOP_BIT(Z2, MIN);
           #else
             COPY_BIT(current_endstop_bits, Z_MIN, Z2_MIN);
           #endif
-
           test_dual_z_endstops(Z_MIN, Z2_MIN);
-
-        #else // !Z_DUAL_ENDSTOPS
-
+        #else
           #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
             if (z_probe_enabled) UPDATE_ENDSTOP(Z, MIN);
           #else
             UPDATE_ENDSTOP(Z, MIN);
           #endif
-
-        #endif // !Z_DUAL_ENDSTOPS
-
-      #endif // HAS_Z_MIN
+        #endif
+      #endif
 
       // When closing the gap check the enabled probe
       #if ENABLED(Z_MIN_PROBE_ENDSTOP)
@@ -427,27 +523,21 @@ void Endstops::update() {
     }
     else { // Z +direction. Gantry up, bed down.
       #if HAS_Z_MAX
-
         // Check both Z dual endstops
         #if ENABLED(Z_DUAL_ENDSTOPS)
-
           UPDATE_ENDSTOP_BIT(Z, MAX);
           #if HAS_Z2_MAX
             UPDATE_ENDSTOP_BIT(Z2, MAX);
           #else
             COPY_BIT(current_endstop_bits, Z_MAX, Z2_MAX);
           #endif
-
           test_dual_z_endstops(Z_MAX, Z2_MAX);
-
         // If this pin is not hijacked for the bed probe
         // then it belongs to the Z endstop
         #elif DISABLED(Z_MIN_PROBE_ENDSTOP) || Z_MAX_PIN != Z_MIN_PROBE_PIN
-
           UPDATE_ENDSTOP(Z, MAX);
-
-        #endif // !Z_MIN_PROBE_PIN...
-      #endif // Z_MAX_PIN
+        #endif
+      #endif
     }
   }
 
@@ -496,6 +586,18 @@ void Endstops::update() {
     #if HAS_Z_MIN_PROBE_PIN
       if (READ(Z_MIN_PROBE_PIN)) SBI(current_endstop_bits_local, Z_MIN_PROBE);
     #endif
+    #if HAS_X2_MIN
+      if (READ(X2_MIN_PIN)) SBI(current_endstop_bits_local, X2_MIN);
+    #endif
+    #if HAS_X2_MAX
+      if (READ(X2_MAX_PIN)) SBI(current_endstop_bits_local, X2_MAX);
+    #endif
+    #if HAS_Y2_MIN
+      if (READ(Y2_MIN_PIN)) SBI(current_endstop_bits_local, Y2_MIN);
+    #endif
+    #if HAS_Y2_MAX
+      if (READ(Y2_MAX_PIN)) SBI(current_endstop_bits_local, Y2_MAX);
+    #endif
     #if HAS_Z2_MIN
       if (READ(Z2_MIN_PIN)) SBI(current_endstop_bits_local, Z2_MIN);
     #endif
@@ -527,6 +629,18 @@ void Endstops::update() {
       #if HAS_Z_MIN_PROBE_PIN
         if (TEST(endstop_change, Z_MIN_PROBE)) SERIAL_PROTOCOLPAIR("  PROBE:", !!TEST(current_endstop_bits_local, Z_MIN_PROBE));
       #endif
+      #if HAS_X2_MIN
+        if (TEST(endstop_change, X2_MIN)) SERIAL_PROTOCOLPAIR("  X2_MIN:", !!TEST(current_endstop_bits_local, X2_MIN));
+      #endif
+      #if HAS_X2_MAX
+        if (TEST(endstop_change, X2_MAX)) SERIAL_PROTOCOLPAIR("  X2_MAX:", !!TEST(current_endstop_bits_local, X2_MAX));
+      #endif
+      #if HAS_Y2_MIN
+        if (TEST(endstop_change, Y2_MIN)) SERIAL_PROTOCOLPAIR("  Y2_MIN:", !!TEST(current_endstop_bits_local, Y2_MIN));
+      #endif
+      #if HAS_Y2_MAX
+        if (TEST(endstop_change, Y2_MAX)) SERIAL_PROTOCOLPAIR("  Y2_MAX:", !!TEST(current_endstop_bits_local, Y2_MAX));
+      #endif
       #if HAS_Z2_MIN
         if (TEST(endstop_change, Z2_MIN)) SERIAL_PROTOCOLPAIR("  Z2_MIN:", !!TEST(current_endstop_bits_local, Z2_MIN));
       #endif

commit 64dfb464610e35c3a65748170b5f015ffe1bc9bd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 18 05:56:10 2017 -0500

    Move z_endstop_adj to Endstops

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 510f13df41..b194abd5df 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -54,6 +54,10 @@ volatile char Endstops::endstop_hit_bits; // use X_MIN, Y_MIN, Z_MIN and Z_MIN_P
   volatile bool Endstops::z_probe_enabled = false;
 #endif
 
+#if ENABLED(Z_DUAL_ENDSTOPS)
+  float Endstops::z_endstop_adj;
+#endif
+
 /**
  * Class and Instance Methods
  */

commit 2e20c53c9d3f1ef29a51db9030dd10b2be8c65fb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 18 05:55:09 2017 -0500

    Move endstop debug to Endstops

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index a7e4b7342e..510f13df41 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -450,3 +450,90 @@ void Endstops::update() {
   old_endstop_bits = current_endstop_bits;
 
 } // Endstops::update()
+
+#if ENABLED(PINS_DEBUGGING)
+
+  bool Endstops::monitor_flag = false;
+
+  /**
+   * monitors endstops & Z probe for changes
+   *
+   * If a change is detected then the LED is toggled and
+   * a message is sent out the serial port
+   *
+   * Yes, we could miss a rapid back & forth change but
+   * that won't matter because this is all manual.
+   *
+   */
+  void Endstops::monitor() {
+
+    static uint16_t old_endstop_bits_local = 0;
+    static uint8_t local_LED_status = 0;
+    uint16_t current_endstop_bits_local = 0;
+
+    #if HAS_X_MIN
+      if (READ(X_MIN_PIN)) SBI(current_endstop_bits_local, X_MIN);
+    #endif
+    #if HAS_X_MAX
+      if (READ(X_MAX_PIN)) SBI(current_endstop_bits_local, X_MAX);
+    #endif
+    #if HAS_Y_MIN
+      if (READ(Y_MIN_PIN)) SBI(current_endstop_bits_local, Y_MIN);
+    #endif
+    #if HAS_Y_MAX
+      if (READ(Y_MAX_PIN)) SBI(current_endstop_bits_local, Y_MAX);
+    #endif
+    #if HAS_Z_MIN
+      if (READ(Z_MIN_PIN)) SBI(current_endstop_bits_local, Z_MIN);
+    #endif
+    #if HAS_Z_MAX
+      if (READ(Z_MAX_PIN)) SBI(current_endstop_bits_local, Z_MAX);
+    #endif
+    #if HAS_Z_MIN_PROBE_PIN
+      if (READ(Z_MIN_PROBE_PIN)) SBI(current_endstop_bits_local, Z_MIN_PROBE);
+    #endif
+    #if HAS_Z2_MIN
+      if (READ(Z2_MIN_PIN)) SBI(current_endstop_bits_local, Z2_MIN);
+    #endif
+    #if HAS_Z2_MAX
+      if (READ(Z2_MAX_PIN)) SBI(current_endstop_bits_local, Z2_MAX);
+    #endif
+
+    uint16_t endstop_change = current_endstop_bits_local ^ old_endstop_bits_local;
+
+    if (endstop_change) {
+      #if HAS_X_MIN
+        if (TEST(endstop_change, X_MIN)) SERIAL_PROTOCOLPAIR("  X_MIN:", !!TEST(current_endstop_bits_local, X_MIN));
+      #endif
+      #if HAS_X_MAX
+        if (TEST(endstop_change, X_MAX)) SERIAL_PROTOCOLPAIR("  X_MAX:", !!TEST(current_endstop_bits_local, X_MAX));
+      #endif
+      #if HAS_Y_MIN
+        if (TEST(endstop_change, Y_MIN)) SERIAL_PROTOCOLPAIR("  Y_MIN:", !!TEST(current_endstop_bits_local, Y_MIN));
+      #endif
+      #if HAS_Y_MAX
+        if (TEST(endstop_change, Y_MAX)) SERIAL_PROTOCOLPAIR("  Y_MAX:", !!TEST(current_endstop_bits_local, Y_MAX));
+      #endif
+      #if HAS_Z_MIN
+        if (TEST(endstop_change, Z_MIN)) SERIAL_PROTOCOLPAIR("  Z_MIN:", !!TEST(current_endstop_bits_local, Z_MIN));
+      #endif
+      #if HAS_Z_MAX
+        if (TEST(endstop_change, Z_MAX)) SERIAL_PROTOCOLPAIR("  Z_MAX:", !!TEST(current_endstop_bits_local, Z_MAX));
+      #endif
+      #if HAS_Z_MIN_PROBE_PIN
+        if (TEST(endstop_change, Z_MIN_PROBE)) SERIAL_PROTOCOLPAIR("  PROBE:", !!TEST(current_endstop_bits_local, Z_MIN_PROBE));
+      #endif
+      #if HAS_Z2_MIN
+        if (TEST(endstop_change, Z2_MIN)) SERIAL_PROTOCOLPAIR("  Z2_MIN:", !!TEST(current_endstop_bits_local, Z2_MIN));
+      #endif
+      #if HAS_Z2_MAX
+        if (TEST(endstop_change, Z2_MAX)) SERIAL_PROTOCOLPAIR("  Z2_MAX:", !!TEST(current_endstop_bits_local, Z2_MAX));
+      #endif
+      SERIAL_PROTOCOLPGM("\n\n");
+      analogWrite(LED_PIN, local_LED_status);
+      local_LED_status ^= 255;
+      old_endstop_bits_local = current_endstop_bits_local;
+    }
+  }
+
+#endif // PINS_DEBUGGING

commit 3d8a0ab4b215a3869a0388e5c0ef35a6372ed7d5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 6 06:28:32 2017 -0500

    Module updates

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 8ff6c7668a..a7e4b7342e 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -24,12 +24,13 @@
  * endstops.cpp - A singleton object to manage endstops
  */
 
-#include "Marlin.h"
-#include "cardreader.h"
 #include "endstops.h"
-#include "temperature.h"
 #include "stepper.h"
-#include "ultralcd.h"
+
+#include "../Marlin.h"
+#include "../sd/cardreader.h"
+#include "../module/temperature.h"
+#include "../lcd/ultralcd.h"
 
 // TEST_ENDSTOP: test the old and the current status of an endstop
 #define TEST_ENDSTOP(ENDSTOP) (TEST(current_endstop_bits & old_endstop_bits, ENDSTOP))

commit 0c9231fd04798c30830513a0cad8b204a6b9633f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 6 06:28:30 2017 -0500

    Move 'module' files

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
new file mode 100644
index 0000000000..8ff6c7668a
--- /dev/null
+++ b/Marlin/src/module/endstops.cpp
@@ -0,0 +1,451 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * endstops.cpp - A singleton object to manage endstops
+ */
+
+#include "Marlin.h"
+#include "cardreader.h"
+#include "endstops.h"
+#include "temperature.h"
+#include "stepper.h"
+#include "ultralcd.h"
+
+// TEST_ENDSTOP: test the old and the current status of an endstop
+#define TEST_ENDSTOP(ENDSTOP) (TEST(current_endstop_bits & old_endstop_bits, ENDSTOP))
+
+Endstops endstops;
+
+// public:
+
+bool Endstops::enabled, Endstops::enabled_globally; // Initialized by settings.load()
+volatile char Endstops::endstop_hit_bits; // use X_MIN, Y_MIN, Z_MIN and Z_MIN_PROBE as BIT value
+
+#if ENABLED(Z_DUAL_ENDSTOPS)
+  uint16_t
+#else
+  byte
+#endif
+    Endstops::current_endstop_bits = 0,
+    Endstops::old_endstop_bits = 0;
+
+#if HAS_BED_PROBE
+  volatile bool Endstops::z_probe_enabled = false;
+#endif
+
+/**
+ * Class and Instance Methods
+ */
+
+void Endstops::init() {
+
+  #if HAS_X_MIN
+    #if ENABLED(ENDSTOPPULLUP_XMIN)
+      SET_INPUT_PULLUP(X_MIN_PIN);
+    #else
+      SET_INPUT(X_MIN_PIN);
+    #endif
+  #endif
+
+  #if HAS_Y_MIN
+    #if ENABLED(ENDSTOPPULLUP_YMIN)
+      SET_INPUT_PULLUP(Y_MIN_PIN);
+    #else
+      SET_INPUT(Y_MIN_PIN);
+    #endif
+  #endif
+
+  #if HAS_Z_MIN
+    #if ENABLED(ENDSTOPPULLUP_ZMIN)
+      SET_INPUT_PULLUP(Z_MIN_PIN);
+    #else
+      SET_INPUT(Z_MIN_PIN);
+    #endif
+  #endif
+
+  #if HAS_Z2_MIN
+    #if ENABLED(ENDSTOPPULLUP_ZMIN)
+      SET_INPUT_PULLUP(Z2_MIN_PIN);
+    #else
+      SET_INPUT(Z2_MIN_PIN);
+    #endif
+  #endif
+
+  #if HAS_X_MAX
+    #if ENABLED(ENDSTOPPULLUP_XMAX)
+      SET_INPUT_PULLUP(X_MAX_PIN);
+    #else
+      SET_INPUT(X_MAX_PIN);
+    #endif
+  #endif
+
+  #if HAS_Y_MAX
+    #if ENABLED(ENDSTOPPULLUP_YMAX)
+      SET_INPUT_PULLUP(Y_MAX_PIN);
+    #else
+      SET_INPUT(Y_MAX_PIN);
+    #endif
+  #endif
+
+  #if HAS_Z_MAX
+    #if ENABLED(ENDSTOPPULLUP_ZMAX)
+      SET_INPUT_PULLUP(Z_MAX_PIN);
+    #else
+      SET_INPUT(Z_MAX_PIN);
+    #endif
+  #endif
+
+  #if HAS_Z2_MAX
+    #if ENABLED(ENDSTOPPULLUP_ZMAX)
+      SET_INPUT_PULLUP(Z2_MAX_PIN);
+    #else
+      SET_INPUT(Z2_MAX_PIN);
+    #endif
+  #endif
+
+  #if ENABLED(Z_MIN_PROBE_ENDSTOP)
+    #if ENABLED(ENDSTOPPULLUP_ZMIN_PROBE)
+      SET_INPUT_PULLUP(Z_MIN_PROBE_PIN);
+    #else
+      SET_INPUT(Z_MIN_PROBE_PIN);
+    #endif
+  #endif
+
+} // Endstops::init
+
+void Endstops::report_state() {
+  if (endstop_hit_bits) {
+    #if ENABLED(ULTRA_LCD)
+      char chrX = ' ', chrY = ' ', chrZ = ' ', chrP = ' ';
+      #define _SET_STOP_CHAR(A,C) (chr## A = C)
+    #else
+      #define _SET_STOP_CHAR(A,C) ;
+    #endif
+
+    #define _ENDSTOP_HIT_ECHO(A,C) do{ \
+      SERIAL_ECHOPAIR(" " STRINGIFY(A) ":", stepper.triggered_position_mm(A ##_AXIS)); \
+      _SET_STOP_CHAR(A,C); }while(0)
+
+    #define _ENDSTOP_HIT_TEST(A,C) \
+      if (TEST(endstop_hit_bits, A ##_MIN) || TEST(endstop_hit_bits, A ##_MAX)) \
+        _ENDSTOP_HIT_ECHO(A,C)
+
+    #define ENDSTOP_HIT_TEST_X() _ENDSTOP_HIT_TEST(X,'X')
+    #define ENDSTOP_HIT_TEST_Y() _ENDSTOP_HIT_TEST(Y,'Y')
+    #define ENDSTOP_HIT_TEST_Z() _ENDSTOP_HIT_TEST(Z,'Z')
+
+    SERIAL_ECHO_START();
+    SERIAL_ECHOPGM(MSG_ENDSTOPS_HIT);
+    ENDSTOP_HIT_TEST_X();
+    ENDSTOP_HIT_TEST_Y();
+    ENDSTOP_HIT_TEST_Z();
+
+    #if ENABLED(Z_MIN_PROBE_ENDSTOP)
+      #define P_AXIS Z_AXIS
+      if (TEST(endstop_hit_bits, Z_MIN_PROBE)) _ENDSTOP_HIT_ECHO(P, 'P');
+    #endif
+    SERIAL_EOL();
+
+    #if ENABLED(ULTRA_LCD)
+      lcd_status_printf_P(0, PSTR(MSG_LCD_ENDSTOPS " %c %c %c %c"), chrX, chrY, chrZ, chrP);
+    #endif
+
+    hit_on_purpose();
+
+    #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED) && ENABLED(SDSUPPORT)
+      if (stepper.abort_on_endstop_hit) {
+        card.sdprinting = false;
+        card.closefile();
+        quickstop_stepper();
+        thermalManager.disable_all_heaters(); // switch off all heaters.
+      }
+    #endif
+  }
+} // Endstops::report_state
+
+void Endstops::M119() {
+  SERIAL_PROTOCOLLNPGM(MSG_M119_REPORT);
+  #if HAS_X_MIN
+    SERIAL_PROTOCOLPGM(MSG_X_MIN);
+    SERIAL_PROTOCOLLN(((READ(X_MIN_PIN)^X_MIN_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
+  #endif
+  #if HAS_X_MAX
+    SERIAL_PROTOCOLPGM(MSG_X_MAX);
+    SERIAL_PROTOCOLLN(((READ(X_MAX_PIN)^X_MAX_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
+  #endif
+  #if HAS_Y_MIN
+    SERIAL_PROTOCOLPGM(MSG_Y_MIN);
+    SERIAL_PROTOCOLLN(((READ(Y_MIN_PIN)^Y_MIN_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
+  #endif
+  #if HAS_Y_MAX
+    SERIAL_PROTOCOLPGM(MSG_Y_MAX);
+    SERIAL_PROTOCOLLN(((READ(Y_MAX_PIN)^Y_MAX_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
+  #endif
+  #if HAS_Z_MIN
+    SERIAL_PROTOCOLPGM(MSG_Z_MIN);
+    SERIAL_PROTOCOLLN(((READ(Z_MIN_PIN)^Z_MIN_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
+  #endif
+  #if HAS_Z2_MIN
+    SERIAL_PROTOCOLPGM(MSG_Z2_MIN);
+    SERIAL_PROTOCOLLN(((READ(Z2_MIN_PIN)^Z2_MIN_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
+  #endif
+  #if HAS_Z_MAX
+    SERIAL_PROTOCOLPGM(MSG_Z_MAX);
+    SERIAL_PROTOCOLLN(((READ(Z_MAX_PIN)^Z_MAX_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
+  #endif
+  #if HAS_Z2_MAX
+    SERIAL_PROTOCOLPGM(MSG_Z2_MAX);
+    SERIAL_PROTOCOLLN(((READ(Z2_MAX_PIN)^Z2_MAX_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
+  #endif
+  #if ENABLED(Z_MIN_PROBE_ENDSTOP)
+    SERIAL_PROTOCOLPGM(MSG_Z_PROBE);
+    SERIAL_PROTOCOLLN(((READ(Z_MIN_PROBE_PIN)^Z_MIN_PROBE_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
+  #endif
+  #if ENABLED(FILAMENT_RUNOUT_SENSOR)
+    SERIAL_PROTOCOLPGM(MSG_FILAMENT_RUNOUT_SENSOR);
+    SERIAL_PROTOCOLLN(((READ(FIL_RUNOUT_PIN)^FIL_RUNOUT_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
+  #endif
+} // Endstops::M119
+
+#if ENABLED(Z_DUAL_ENDSTOPS)
+
+  // Pass the result of the endstop test
+  void Endstops::test_dual_z_endstops(const EndstopEnum es1, const EndstopEnum es2) {
+    byte z_test = TEST_ENDSTOP(es1) | (TEST_ENDSTOP(es2) << 1); // bit 0 for Z, bit 1 for Z2
+    if (z_test && stepper.current_block->steps[Z_AXIS] > 0) {
+      SBI(endstop_hit_bits, Z_MIN);
+      if (!stepper.performing_homing || (z_test == 0x3))  //if not performing home or if both endstops were trigged during homing...
+        stepper.kill_current_block();
+    }
+  }
+
+#endif
+
+// Check endstops - Called from ISR!
+void Endstops::update() {
+
+  #define _ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
+  #define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN
+  #define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_INVERTING
+  #define _ENDSTOP_HIT(AXIS, MINMAX) SBI(endstop_hit_bits, _ENDSTOP(AXIS, MINMAX))
+
+  // UPDATE_ENDSTOP_BIT: set the current endstop bits for an endstop to its status
+  #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT(current_endstop_bits, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
+  // COPY_BIT: copy the value of SRC_BIT to DST_BIT in DST
+  #define COPY_BIT(DST, SRC_BIT, DST_BIT) SET_BIT(DST, DST_BIT, TEST(DST, SRC_BIT))
+
+  #define UPDATE_ENDSTOP(AXIS,MINMAX) do { \
+      UPDATE_ENDSTOP_BIT(AXIS, MINMAX); \
+      if (TEST_ENDSTOP(_ENDSTOP(AXIS, MINMAX)) && stepper.current_block->steps[_AXIS(AXIS)] > 0) { \
+        _ENDSTOP_HIT(AXIS, MINMAX); \
+        stepper.endstop_triggered(_AXIS(AXIS)); \
+      } \
+    } while(0)
+
+  #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && !(CORE_IS_XY || CORE_IS_XZ)
+    // If G38 command is active check Z_MIN_PROBE for ALL movement
+    if (G38_move) {
+      UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
+      if (TEST_ENDSTOP(_ENDSTOP(Z, MIN_PROBE))) {
+        if      (stepper.current_block->steps[_AXIS(X)] > 0) { _ENDSTOP_HIT(X, MIN); stepper.endstop_triggered(_AXIS(X)); }
+        else if (stepper.current_block->steps[_AXIS(Y)] > 0) { _ENDSTOP_HIT(Y, MIN); stepper.endstop_triggered(_AXIS(Y)); }
+        else if (stepper.current_block->steps[_AXIS(Z)] > 0) { _ENDSTOP_HIT(Z, MIN); stepper.endstop_triggered(_AXIS(Z)); }
+        G38_endstop_hit = true;
+      }
+    }
+  #endif
+
+  /**
+   * Define conditions for checking endstops
+   */
+
+  #if IS_CORE
+    #define S_(N) stepper.current_block->steps[CORE_AXIS_##N]
+    #define D_(N) stepper.motor_direction(CORE_AXIS_##N)
+  #endif
+
+  #if CORE_IS_XY || CORE_IS_XZ
+    /**
+     * Head direction in -X axis for CoreXY and CoreXZ bots.
+     *
+     * If steps differ, both axes are moving.
+     * If DeltaA == -DeltaB, the movement is only in the 2nd axis (Y or Z, handled below)
+     * If DeltaA ==  DeltaB, the movement is only in the 1st axis (X)
+     */
+    #if ENABLED(COREXY) || ENABLED(COREXZ)
+      #define X_CMP ==
+    #else
+      #define X_CMP !=
+    #endif
+    #define X_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && D_(1) X_CMP D_(2)) )
+    #define X_AXIS_HEAD X_HEAD
+  #else
+    #define X_MOVE_TEST stepper.current_block->steps[X_AXIS] > 0
+    #define X_AXIS_HEAD X_AXIS
+  #endif
+
+  #if CORE_IS_XY || CORE_IS_YZ
+    /**
+     * Head direction in -Y axis for CoreXY / CoreYZ bots.
+     *
+     * If steps differ, both axes are moving
+     * If DeltaA ==  DeltaB, the movement is only in the 1st axis (X or Y)
+     * If DeltaA == -DeltaB, the movement is only in the 2nd axis (Y or Z)
+     */
+    #if ENABLED(COREYX) || ENABLED(COREYZ)
+      #define Y_CMP ==
+    #else
+      #define Y_CMP !=
+    #endif
+    #define Y_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && D_(1) Y_CMP D_(2)) )
+    #define Y_AXIS_HEAD Y_HEAD
+  #else
+    #define Y_MOVE_TEST stepper.current_block->steps[Y_AXIS] > 0
+    #define Y_AXIS_HEAD Y_AXIS
+  #endif
+
+  #if CORE_IS_XZ || CORE_IS_YZ
+    /**
+     * Head direction in -Z axis for CoreXZ or CoreYZ bots.
+     *
+     * If steps differ, both axes are moving
+     * If DeltaA ==  DeltaB, the movement is only in the 1st axis (X or Y, already handled above)
+     * If DeltaA == -DeltaB, the movement is only in the 2nd axis (Z)
+     */
+    #if ENABLED(COREZX) || ENABLED(COREZY)
+      #define Z_CMP ==
+    #else
+      #define Z_CMP !=
+    #endif
+    #define Z_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && D_(1) Z_CMP D_(2)) )
+    #define Z_AXIS_HEAD Z_HEAD
+  #else
+    #define Z_MOVE_TEST stepper.current_block->steps[Z_AXIS] > 0
+    #define Z_AXIS_HEAD Z_AXIS
+  #endif
+
+  // With Dual X, endstops are only checked in the homing direction for the active extruder
+  #if ENABLED(DUAL_X_CARRIAGE)
+    #define E0_ACTIVE stepper.current_block->active_extruder == 0
+    #define X_MIN_TEST ((X_HOME_DIR < 0 && E0_ACTIVE) || (X2_HOME_DIR < 0 && !E0_ACTIVE))
+    #define X_MAX_TEST ((X_HOME_DIR > 0 && E0_ACTIVE) || (X2_HOME_DIR > 0 && !E0_ACTIVE))
+  #else
+    #define X_MIN_TEST true
+    #define X_MAX_TEST true
+  #endif
+
+  /**
+   * Check and update endstops according to conditions
+   */
+
+  if (X_MOVE_TEST) {
+    if (stepper.motor_direction(X_AXIS_HEAD)) {
+      if (X_MIN_TEST) { // -direction
+        #if HAS_X_MIN
+          UPDATE_ENDSTOP(X, MIN);
+        #endif
+      }
+    }
+    else if (X_MAX_TEST) { // +direction
+      #if HAS_X_MAX
+        UPDATE_ENDSTOP(X, MAX);
+      #endif
+    }
+  }
+
+  if (Y_MOVE_TEST) {
+    if (stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
+      #if HAS_Y_MIN
+        UPDATE_ENDSTOP(Y, MIN);
+      #endif
+    }
+    else { // +direction
+      #if HAS_Y_MAX
+        UPDATE_ENDSTOP(Y, MAX);
+      #endif
+    }
+  }
+
+  if (Z_MOVE_TEST) {
+    if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
+      #if HAS_Z_MIN
+        #if ENABLED(Z_DUAL_ENDSTOPS)
+
+          UPDATE_ENDSTOP_BIT(Z, MIN);
+          #if HAS_Z2_MIN
+            UPDATE_ENDSTOP_BIT(Z2, MIN);
+          #else
+            COPY_BIT(current_endstop_bits, Z_MIN, Z2_MIN);
+          #endif
+
+          test_dual_z_endstops(Z_MIN, Z2_MIN);
+
+        #else // !Z_DUAL_ENDSTOPS
+
+          #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
+            if (z_probe_enabled) UPDATE_ENDSTOP(Z, MIN);
+          #else
+            UPDATE_ENDSTOP(Z, MIN);
+          #endif
+
+        #endif // !Z_DUAL_ENDSTOPS
+
+      #endif // HAS_Z_MIN
+
+      // When closing the gap check the enabled probe
+      #if ENABLED(Z_MIN_PROBE_ENDSTOP)
+        if (z_probe_enabled) {
+          UPDATE_ENDSTOP(Z, MIN_PROBE);
+          if (TEST_ENDSTOP(Z_MIN_PROBE)) SBI(endstop_hit_bits, Z_MIN_PROBE);
+        }
+      #endif
+    }
+    else { // Z +direction. Gantry up, bed down.
+      #if HAS_Z_MAX
+
+        // Check both Z dual endstops
+        #if ENABLED(Z_DUAL_ENDSTOPS)
+
+          UPDATE_ENDSTOP_BIT(Z, MAX);
+          #if HAS_Z2_MAX
+            UPDATE_ENDSTOP_BIT(Z2, MAX);
+          #else
+            COPY_BIT(current_endstop_bits, Z_MAX, Z2_MAX);
+          #endif
+
+          test_dual_z_endstops(Z_MAX, Z2_MAX);
+
+        // If this pin is not hijacked for the bed probe
+        // then it belongs to the Z endstop
+        #elif DISABLED(Z_MIN_PROBE_ENDSTOP) || Z_MAX_PIN != Z_MIN_PROBE_PIN
+
+          UPDATE_ENDSTOP(Z, MAX);
+
+        #endif // !Z_MIN_PROBE_PIN...
+      #endif // Z_MAX_PIN
+    }
+  }
+
+  old_endstop_bits = current_endstop_bits;
+
+} // Endstops::update()
