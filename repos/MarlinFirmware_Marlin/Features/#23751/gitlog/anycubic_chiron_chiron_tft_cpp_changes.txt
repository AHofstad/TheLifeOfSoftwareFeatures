commit 521e7eafce4921a36532e0a89f2cc7417c2c4e21
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue May 21 15:42:56 2024 -0500

    üßë‚Äçüíª Clarify media "mounted"

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index 5e80b79acf..9e38face6f 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -557,22 +557,22 @@ void ChironTFT::panelInfo(uint8_t req) {
       TFTSer.print(ui8tostr2(time / 60));
       tftSend(F(" H "));
       TFTSer.print(ui8tostr2(time % 60));
       tftSend(F(" M"));
       #if ACDEBUG(AC_ALL)
         DEBUG_ECHOLNPGM("Print time ", ui8tostr2(time / 60), ":", ui8tostr2(time % 60));
       #endif
     } break;
 
     case 8:   // A8 Get SD Card list A8 S0
-      if (!isMediaInserted()) safe_delay(500);
-      if (!isMediaInserted())   // Make sure the card is removed
+      if (!isMediaMounted()) safe_delay(500);
+      if (!isMediaMounted())   // Make sure the card is removed
         tftSendLn(AC_msg_no_sd_card);
       else if (panel_command[3] == 'S')
         sendFileList( atoi( &panel_command[4] ) );
       break;
 
     case 33:   // A33 Get firmware info
       tftSend(F("J33 "));
       // If there is an error recorded, show that instead of the FW version
       if (!getLastError()) tftSendLn(F(SHORT_BUILD_VERSION));
       break;

commit f5f6c37c17edd6e710bc48578aa325f317d47d51
Author: Alexander Thomas Julian <ajulian@hawk.iit.edu>
Date:   Sun May 12 13:25:14 2024 -0500

    üêõ LCD Bed Tramming fixes (#26962)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index 63b1ef9c19..5e80b79acf 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -773,25 +773,25 @@ void ChironTFT::panelProcess(uint8_t req) {
         // If the same meshpoint is selected twice in a row, move the head to that ready for adjustment
         if ((selectedmeshpoint.x == pos.x) && (selectedmeshpoint.y == pos.y)) {
           if (!isPositionKnown())
             injectCommands_P(G28_STR); // home
 
           if (isPositionKnown()) {
             #if ACDEBUG(AC_INFO)
               DEBUG_ECHOLNPGM("Moving to mesh point at x: ", pos.x, " y: ", pos.y, " z: ", pos_z);
             #endif
             // Go up before moving
-            setAxisPosition_mm(3.0,Z);
+            setAxisPosition_mm(3.0f, Z);
 
-            setAxisPosition_mm(17 + (93 * pos.x), X);
-            setAxisPosition_mm(20 + (93 * pos.y), Y);
-            setAxisPosition_mm(0.0, Z);
+            setAxisPosition_mm(17.0f + (93.0f * pos.x), X);
+            setAxisPosition_mm(20.0f + (93.0f * pos.y), Y);
+            setAxisPosition_mm(0.0f, Z);
             #if ACDEBUG(AC_INFO)
               DEBUG_ECHOLNPGM("Current Z: ", getAxisPosition_mm(Z));
             #endif
           }
         }
         selectedmeshpoint.x = pos.x;
         selectedmeshpoint.y = pos.y;
       }
     } break;
 

commit dfec58e5dced9fd794cc4a8e7a88a4d34f0cacda
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Dec 8 00:47:18 2023 -0600

    ‚ö°Ô∏è Use strlcpy with buffer size (#26513)

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index df0c4df30d..63b1ef9c19 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -426,40 +426,39 @@ void ChironTFT::sendFileList(int8_t startindex) {
   // Respond to panel request for 4 files starting at index
   #if ACDEBUG(AC_INFO)
     DEBUG_ECHOLNPGM("## sendFileList ## ", startindex);
   #endif
   tftSendLn(F("FN "));
   filenavigator.getFiles(startindex, panel_type, 4);
   tftSendLn(F("END"));
 }
 
 void ChironTFT::selectFile() {
-  const size_t namelen = command_len - 4 + (panel_type <= AC_panel_new);
-  strncpy(selectedfile, panel_command + 4, namelen);
-  selectedfile[namelen] = '\0';
+  const size_t fnlen = command_len - 4 + (panel_type <= AC_panel_new);
+  strlcpy(selectedfile, panel_command + 4, fnlen + 1);
   #if ACDEBUG(AC_FILE)
     DEBUG_ECHOLNPGM(" Selected File: ", selectedfile);
   #endif
+
   switch (selectedfile[0]) {
     case '/':   // Valid file selected
       tftSendLn(AC_msg_sd_file_open_success);
       break;
 
     case '<':   // .. (go up folder level)
       filenavigator.upDIR();
       tftSendLn(AC_msg_sd_file_open_failed);
       sendFileList( 0 );
       break;
-    default:   // enter sub folder
-      // for new panel remove the '.GCO' tag that was added to the end of the path
-      if (panel_type <= AC_panel_new)
-        selectedfile[strlen(selectedfile) - 4] = '\0';
+    default:    // enter subfolder
+      // For new panel remove the '.GCO' tag that was added to the end of the path
+      if (panel_type <= AC_panel_new) selectedfile[fnlen - 4] = '\0';
       filenavigator.changeDIR(selectedfile);
       tftSendLn(AC_msg_sd_file_open_failed);
       sendFileList( 0 );
       break;
   }
 }
 
 void ChironTFT::processPanelRequest() {
   // Break these up into logical blocks // as its easier to navigate than one huge switch case!
   int8_t tpos = findToken('A');

commit 36e66bdd9ff22ddfdcaa36ac8a9b9448c78ca44c
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Sat Nov 18 09:11:59 2023 +1300

    üîß Define MarlinUI axis moves with lists (#26344)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index 6c8c3aa3a5..df0c4df30d 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -426,28 +426,23 @@ void ChironTFT::sendFileList(int8_t startindex) {
   // Respond to panel request for 4 files starting at index
   #if ACDEBUG(AC_INFO)
     DEBUG_ECHOLNPGM("## sendFileList ## ", startindex);
   #endif
   tftSendLn(F("FN "));
   filenavigator.getFiles(startindex, panel_type, 4);
   tftSendLn(F("END"));
 }
 
 void ChironTFT::selectFile() {
-  if (panel_type <= AC_panel_new) {
-    strncpy(selectedfile, panel_command + 4, command_len - 3);
-    selectedfile[command_len - 4] = '\0';
-  }
-  else {
-    strncpy(selectedfile, panel_command + 4, command_len - 4);
-    selectedfile[command_len - 5] = '\0';
-  }
+  const size_t namelen = command_len - 4 + (panel_type <= AC_panel_new);
+  strncpy(selectedfile, panel_command + 4, namelen);
+  selectedfile[namelen] = '\0';
   #if ACDEBUG(AC_FILE)
     DEBUG_ECHOLNPGM(" Selected File: ", selectedfile);
   #endif
   switch (selectedfile[0]) {
     case '/':   // Valid file selected
       tftSendLn(AC_msg_sd_file_open_success);
       break;
 
     case '<':   // .. (go up folder level)
       filenavigator.upDIR();

commit c3694f1c038fa20ad749118b0a1c7aa88e3dd5f2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jun 14 17:24:50 2023 -0500

    üé® Lowercase methods, functions, data members (#25939)
    
    For: TFT, DGUS, MarlinUI, Anycubic, JyersUI, CrealityUI

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index 7d44e63537..6c8c3aa3a5 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -96,21 +96,21 @@ void ChironTFT::startup() {
   }
 
   // Signal Board has reset
   tftSendLn(AC_msg_main_board_has_reset);
 
   // Enable leveling and Disable end stops during print
   // as Z home places nozzle above the bed so we need to allow it past the end stops
   injectCommands(AC_cmnd_enable_leveling);
 
   // startup tunes are defined in Tunes.h
-  PlayTune(TERN(AC_DEFAULT_STARTUP_TUNE, Anycubic_PowerOn, GB_PowerOn));
+  playTune(TERN(AC_DEFAULT_STARTUP_TUNE, Anycubic_PowerOn, GB_PowerOn));
 
   #if ACDEBUGLEVEL
     DEBUG_ECHOLNPGM("AC Debug Level ", ACDEBUGLEVEL);
   #endif
   tftSendLn(AC_msg_ready);
 }
 
 void ChironTFT::detectPanelType() {
   #if AUTO_DETECT_CHIRON_TFT
     // Send a query to the TFT
@@ -184,21 +184,21 @@ void ChironTFT::timerEvent(timer_event_t event)  {
   }
 }
 
 void ChironTFT::filamentRunout()  {
   #if ACDEBUG(AC_MARLIN)
     DEBUG_ECHOLNPGM("filamentRunout() printer_state ", printer_state);
   #endif
   // 1 Signal filament out
   last_error = AC_error_filament_runout;
   tftSendLn(isPrintingFromMedia() ? AC_msg_filament_out_alert : AC_msg_filament_out_block);
-  PlayTune(FilamentOut);
+  playTune(FilamentOut);
 }
 
 void ChironTFT::confirmationRequest(const char * const msg)  {
   // M108 continue
   #if ACDEBUG(AC_MARLIN)
     DEBUG_ECHOLNPGM("confirmationRequest() ", msg, " printer_state:", printer_state);
   #endif
   switch (printer_state) {
     case AC_printer_pausing: {
       if (strcmp_P(msg, MARLIN_msg_print_paused) == 0 || strcmp_P(msg, MARLIN_msg_nozzle_parked) == 0) {
@@ -207,21 +207,21 @@ void ChironTFT::confirmationRequest(const char * const msg)  {
       }
     } break;
 
     case AC_printer_resuming_from_power_outage:
     case AC_printer_printing:
     case AC_printer_paused: {
       // Heater timeout, send acknowledgement
       if (strcmp_P(msg, MARLIN_msg_heater_timeout) == 0) {
         pause_state = AC_paused_heater_timed_out;
         tftSendLn(AC_msg_paused); // enable continue button
-        PlayTune(HeaterTimeout);
+        playTune(HeaterTimeout);
       }
       // Reheat finished, send acknowledgement
       else if (strcmp_P(msg, MARLIN_msg_reheat_done) == 0) {
         pause_state = AC_paused_idle;
         tftSendLn(AC_msg_paused); // enable continue button
       }
       // Filament Purging, send acknowledgement enter run mode
       else if (strcmp_P(msg, MARLIN_msg_filament_purging) == 0) {
         pause_state = AC_paused_purging_filament;
         tftSendLn(AC_msg_paused); // enable continue button
@@ -245,21 +245,21 @@ void ChironTFT::statusChange(const char * const msg)  {
       // If probing completes ok save the mesh and park
       // Ignore the custom machine name
       if (strcmp_P(msg + strlen(MACHINE_NAME), MARLIN_msg_ready) == 0) {
         injectCommands(F("M500\nG27"));
         tftSendLn(AC_msg_probing_complete);
         printer_state = AC_printer_idle;
         msg_matched = true;
       }
       // If probing fails don't save the mesh raise the probe above the bad point
       if (strcmp_P(msg, MARLIN_msg_probing_failed) == 0) {
-        PlayTune(BeepBeepBeeep);
+        playTune(BeepBeepBeeep);
         injectCommands(F("G1 Z50 F500"));
         tftSendLn(AC_msg_probing_complete);
         printer_state = AC_printer_idle;
         msg_matched = true;
       }
     } break;
 
     case AC_printer_printing: {
       if (strcmp_P(msg, MARLIN_msg_reheating) == 0) {
         tftSendLn(AC_msg_paused); // enable continue button
@@ -299,21 +299,21 @@ void ChironTFT::statusChange(const char * const msg)  {
     }
     else if (strcmp_P(msg, MARLIN_msg_EEPROM_version) == 0) {
       last_error = AC_error_EEPROM;
     }
   }
 }
 
 void ChironTFT::powerLossRecovery()  {
   printer_state = AC_printer_resuming_from_power_outage; // Play tune to notify user we can recover.
   last_error = AC_error_powerloss;
-  PlayTune(SOS);
+  playTune(SOS);
   SERIAL_ECHOLN(AC_msg_powerloss_recovery);
 }
 
 void ChironTFT::printComplete() {
   tftSend(AC_msg_print_complete);
   printer_state = AC_printer_idle;
   setSoftEndstopState(true); // enable endstops
 }
 
 void ChironTFT::tftSend(FSTR_P const fstr/*=nullptr*/) {  // A helper to print PROGMEM string to the panel

commit 2ef71c6ebaa1f1b496eb369879fe22c69cf9adb4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jun 12 16:38:14 2023 -0500

    ‚ôªÔ∏è Simplify SERIAL_ECHO (#25928)
    
    Since this increases AVR code size, try to optimize further.

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index bcf78746a2..7d44e63537 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -81,28 +81,23 @@ void ChironTFT::startup() {
   // opt_enable FIL_RUNOUT_PULLUP
   TFTSer.begin(115200);
 
   // Wait for the TFT panel to initialize and finish the animation
   safe_delay(1000);
 
   // There are different panels for the Chiron with slightly different commands
   // So we need to know what we are working with.
   // Panel type can be defined otherwise detect it automatically
   switch (panel_type) {
-    case AC_panel_new:
-      SERIAL_ECHOLNF(AC_msg_new_panel_set);
-      break;
-    case AC_panel_standard:
-      SERIAL_ECHOLNF(AC_msg_old_panel_set);
-      break;
-    default:
-      SERIAL_ECHOLNF(AC_msg_auto_panel_detection);
+    case AC_panel_new: SERIAL_ECHOLN(AC_msg_new_panel_set); break;
+    case AC_panel_standard: SERIAL_ECHOLN(AC_msg_old_panel_set); break;
+    default: SERIAL_ECHOLN(AC_msg_auto_panel_detection);
       detectPanelType();
       break;
   }
 
   // Signal Board has reset
   tftSendLn(AC_msg_main_board_has_reset);
 
   // Enable leveling and Disable end stops during print
   // as Z home places nozzle above the bed so we need to allow it past the end stops
   injectCommands(AC_cmnd_enable_leveling);
@@ -305,32 +300,32 @@ void ChironTFT::statusChange(const char * const msg)  {
     else if (strcmp_P(msg, MARLIN_msg_EEPROM_version) == 0) {
       last_error = AC_error_EEPROM;
     }
   }
 }
 
 void ChironTFT::powerLossRecovery()  {
   printer_state = AC_printer_resuming_from_power_outage; // Play tune to notify user we can recover.
   last_error = AC_error_powerloss;
   PlayTune(SOS);
-  SERIAL_ECHOLNF(AC_msg_powerloss_recovery);
+  SERIAL_ECHOLN(AC_msg_powerloss_recovery);
 }
 
 void ChironTFT::printComplete() {
   tftSend(AC_msg_print_complete);
   printer_state = AC_printer_idle;
   setSoftEndstopState(true); // enable endstops
 }
 
 void ChironTFT::tftSend(FSTR_P const fstr/*=nullptr*/) {  // A helper to print PROGMEM string to the panel
   #if ACDEBUG(AC_SOME)
-    DEBUG_ECHOF(fstr);
+    DEBUG_ECHO(fstr);
   #endif
   PGM_P str = FTOP(fstr);
   while (const char c = pgm_read_byte(str++)) TFTSer.write(c);
 }
 
 void ChironTFT::tftSendLn(FSTR_P const fstr/*=nullptr*/) {
   if (fstr) {
     #if ACDEBUG(AC_SOME)
       DEBUG_ECHOPGM("> ");
     #endif
@@ -440,21 +435,21 @@ void ChironTFT::sendFileList(int8_t startindex) {
 void ChironTFT::selectFile() {
   if (panel_type <= AC_panel_new) {
     strncpy(selectedfile, panel_command + 4, command_len - 3);
     selectedfile[command_len - 4] = '\0';
   }
   else {
     strncpy(selectedfile, panel_command + 4, command_len - 4);
     selectedfile[command_len - 5] = '\0';
   }
   #if ACDEBUG(AC_FILE)
-    DEBUG_ECHOLNPGM(" Selected File: ",selectedfile);
+    DEBUG_ECHOLNPGM(" Selected File: ", selectedfile);
   #endif
   switch (selectedfile[0]) {
     case '/':   // Valid file selected
       tftSendLn(AC_msg_sd_file_open_success);
       break;
 
     case '<':   // .. (go up folder level)
       filenavigator.upDIR();
       tftSendLn(AC_msg_sd_file_open_failed);
       sendFileList( 0 );
@@ -487,31 +482,31 @@ void ChironTFT::processPanelRequest() {
     else if (req <= 36) panelProcess(req);
   }
   else {
     #if AUTO_DETECT_CHIRON_TFT
       // This may be a response to a panel type detection query
       if (panel_type == AC_panel_unknown) {
         tpos = findToken('S'); // old panel will respond to 'SIZE' with 'SXY 480 320'
         if (tpos >= 0) {
           if (panel_command[tpos + 1] == 'X' && panel_command[tpos + 2] =='Y') {
             panel_type = AC_panel_standard;
-            SERIAL_ECHOLNF(AC_msg_old_panel_detected);
+            SERIAL_ECHOLN(AC_msg_old_panel_detected);
           }
         }
         else {
           // new panel will respond to 'J200' with '[0]=0'
           // it seems only after a power cycle so detection assumes a new panel
           tpos = findToken('[');
           if (tpos >= 0) {
             if (panel_command[tpos + 1] == '0' && panel_command[tpos + 2] ==']') {
               panel_type = AC_panel_new;
-              SERIAL_ECHOLNF(AC_msg_new_panel_detected);
+              SERIAL_ECHOLN(AC_msg_new_panel_detected);
             }
           }
         }
         return;
       }
     #endif
 
     tftSendLn(); // Ignore unknown requests
   }
 }
@@ -821,29 +816,29 @@ void ChironTFT::panelProcess(uint8_t req) {
         tftSendLn(AC_msg_start_probing); // Just enter levelling menu
       break;
 
     case 31:   // A31 Adjust all Probe Points
       // The tokens can occur in different places on the new panel so we need to find it.
 
       if (findToken('C') >= 0) { // Restore and apply original offsets
         if (!isPrinting()) {
           injectCommands(F("M501\nM420 S1"));
           selectedmeshpoint.x = selectedmeshpoint.y = 99;
-          SERIAL_ECHOLNF(AC_msg_mesh_changes_abandoned);
+          SERIAL_ECHOLN(AC_msg_mesh_changes_abandoned);
         }
       }
 
       else if (findToken('D') >= 0) { // Save Z Offset tables and restore leveling state
         if (!isPrinting()) {
           setAxisPosition_mm(1.0,Z); // Lift nozzle before any further movements are made
           injectCommands(F("M500"));
-          SERIAL_ECHOLNF(AC_msg_mesh_changes_saved);
+          SERIAL_ECHOLN(AC_msg_mesh_changes_saved);
           selectedmeshpoint.x = selectedmeshpoint.y = 99;
         }
       }
 
       else if (findToken('G') >= 0) { // Get current offset
         tftSend(F("A31V "));
         // When printing use the live z Offset position
         // we will use babystepping to move the print head
         if (isPrinting())
           TFTSer.println(live_Zoffset);

commit 37d0f49a82cd2e4d91dce4e62671b266924eb2a7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed May 24 01:05:55 2023 -0500

    üßë‚Äçüíª Misc. ExtUI LCD cleanup (#25872)

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index f3bc64a024..bcf78746a2 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -35,39 +35,43 @@
 #include "chiron_tft.h"
 #include "../anycubic/Tunes.h"
 #include "FileNavigator.h"
 
 #include "../../../gcode/queue.h"
 #include "../../../module/stepper.h"
 #include "../../../sd/cardreader.h"
 #include "../../../libs/numtostr.h"
 #include "../../../MarlinCore.h"
 
+#define DEBUG_OUT ACDEBUGLEVEL
+#include "../../../core/debug_out.h"
+
 namespace Anycubic {
 
-ChironTFT Chiron;
+ChironTFT chiron;
+
 #if AUTO_DETECT_CHIRON_TFT
   panel_type_t   ChironTFT::panel_type = AC_panel_unknown;
 #endif
 last_error_t     ChironTFT::last_error;
 printer_state_t  ChironTFT::printer_state;
 paused_state_t   ChironTFT::pause_state;
 heater_state_t   ChironTFT::hotend_state;
 heater_state_t   ChironTFT::hotbed_state;
 xy_uint8_t       ChironTFT::selectedmeshpoint;
 char             ChironTFT::selectedfile[MAX_PATH_LEN + 1];
 char             ChironTFT::panel_command[MAX_CMND_LEN + 1];
 uint8_t          ChironTFT::command_len;
 float            ChironTFT::live_Zoffset;
 file_menu_t      ChironTFT::file_menu;
 
-void ChironTFT::Startup() {
+void ChironTFT::startup() {
   selectedfile[0]   = '\0';
   panel_command[0]  = '\0';
   command_len       = 0;
   last_error        = AC_error_none;
   printer_state     = AC_printer_idle;
   pause_state       = AC_paused_idle;
   hotend_state      = AC_heater_off;
   hotbed_state      = AC_heater_off;
   live_Zoffset      = 0.0;
   file_menu         = AC_menu_file;
@@ -85,565 +89,563 @@ void ChironTFT::Startup() {
   // Panel type can be defined otherwise detect it automatically
   switch (panel_type) {
     case AC_panel_new:
       SERIAL_ECHOLNF(AC_msg_new_panel_set);
       break;
     case AC_panel_standard:
       SERIAL_ECHOLNF(AC_msg_old_panel_set);
       break;
     default:
       SERIAL_ECHOLNF(AC_msg_auto_panel_detection);
-      DetectPanelType();
+      detectPanelType();
       break;
   }
 
   // Signal Board has reset
-  SendtoTFTLN(AC_msg_main_board_has_reset);
+  tftSendLn(AC_msg_main_board_has_reset);
 
   // Enable leveling and Disable end stops during print
   // as Z home places nozzle above the bed so we need to allow it past the end stops
   injectCommands(AC_cmnd_enable_leveling);
 
-  // Startup tunes are defined in Tunes.h
+  // startup tunes are defined in Tunes.h
   PlayTune(TERN(AC_DEFAULT_STARTUP_TUNE, Anycubic_PowerOn, GB_PowerOn));
 
   #if ACDEBUGLEVEL
-    SERIAL_ECHOLNPGM("AC Debug Level ", ACDEBUGLEVEL);
+    DEBUG_ECHOLNPGM("AC Debug Level ", ACDEBUGLEVEL);
   #endif
-  SendtoTFTLN(AC_msg_ready);
+  tftSendLn(AC_msg_ready);
 }
 
-void ChironTFT::DetectPanelType() {
+void ChironTFT::detectPanelType() {
   #if AUTO_DETECT_CHIRON_TFT
     // Send a query to the TFT
-    SendtoTFTLN(AC_Test_for_OldPanel); // The panel will respond with 'SXY 480 320'
-    SendtoTFTLN(AC_Test_for_NewPanel); // the panel will respond with '[0]=0   ' to '[19]=0   '
+    tftSendLn(AC_Test_for_OldPanel); // The panel will respond with 'SXY 480 320'
+    tftSendLn(AC_Test_for_NewPanel); // the panel will respond with '[0]=0   ' to '[19]=0   '
   #endif
 }
 
-void ChironTFT::IdleLoop()  {
-  if (ReadTFTCommand()) {
-    ProcessPanelRequest();
+void ChironTFT::idleLoop()  {
+  if (readTFTCommand()) {
+    processPanelRequest();
     command_len = 0;
   }
-  CheckHeaters();
+  checkHeaters();
 }
 
-void ChironTFT::PrinterKilled(FSTR_P const error, FSTR_P const component)  {
-  SendtoTFTLN(AC_msg_kill_lcd);
+void ChironTFT::printerKilled(FSTR_P const error, FSTR_P const component)  {
+  tftSendLn(AC_msg_kill_lcd);
   #if ACDEBUG(AC_MARLIN)
-    SERIAL_ECHOLNPGM("PrinterKilled()\nerror: ", error , "\ncomponent: ", component);
+    DEBUG_ECHOLNPGM("printerKilled()\nerror: ", error , "\ncomponent: ", component);
   #endif
 }
 
-void ChironTFT::MediaEvent(media_event_t event)  {
+void ChironTFT::mediaEvent(media_event_t event)  {
   #if ACDEBUG(AC_MARLIN)
-    SERIAL_ECHOLNPGM("ProcessMediaStatus() ", event);
+    DEBUG_ECHOLNPGM("ProcessMediaStatus() ", event);
   #endif
   switch (event) {
     case AC_media_inserted:
-      SendtoTFTLN(AC_msg_sd_card_inserted);
+      tftSendLn(AC_msg_sd_card_inserted);
       break;
 
     case AC_media_removed:
-      SendtoTFTLN(AC_msg_sd_card_removed);
+      tftSendLn(AC_msg_sd_card_removed);
       break;
 
     case AC_media_error:
       last_error = AC_error_noSD;
-      SendtoTFTLN(AC_msg_no_sd_card);
+      tftSendLn(AC_msg_no_sd_card);
       break;
   }
 }
 
-void ChironTFT::TimerEvent(timer_event_t event)  {
+void ChironTFT::timerEvent(timer_event_t event)  {
   #if ACDEBUG(AC_MARLIN)
-    SERIAL_ECHOLNPGM("TimerEvent() ", event);
-    SERIAL_ECHOLNPGM("Printer State: ", printer_state);
+    DEBUG_ECHOLNPGM("timerEvent() ", event);
+    DEBUG_ECHOLNPGM("Printer State: ", printer_state);
   #endif
 
   switch (event) {
     case AC_timer_started: {
       live_Zoffset = 0.0; // reset print offset
       setSoftEndstopState(false);  // disable endstops to print
       printer_state = AC_printer_printing;
-      SendtoTFTLN(AC_msg_print_from_sd_card);
+      tftSendLn(AC_msg_print_from_sd_card);
     } break;
 
     case AC_timer_paused: {
       printer_state = AC_printer_paused;
       pause_state   = AC_paused_idle;
-      SendtoTFTLN(AC_msg_paused);
+      tftSendLn(AC_msg_paused);
     } break;
 
     case AC_timer_stopped: {
       if (printer_state != AC_printer_idle) {
         printer_state = AC_printer_stopping;
-        SendtoTFTLN(AC_msg_print_complete);
+        tftSendLn(AC_msg_print_complete);
       }
       setSoftEndstopState(true); // enable endstops
     } break;
   }
 }
 
-void ChironTFT::FilamentRunout()  {
+void ChironTFT::filamentRunout()  {
   #if ACDEBUG(AC_MARLIN)
-    SERIAL_ECHOLNPGM("FilamentRunout() printer_state ", printer_state);
+    DEBUG_ECHOLNPGM("filamentRunout() printer_state ", printer_state);
   #endif
   // 1 Signal filament out
   last_error = AC_error_filament_runout;
-  SendtoTFTLN(isPrintingFromMedia() ? AC_msg_filament_out_alert : AC_msg_filament_out_block);
+  tftSendLn(isPrintingFromMedia() ? AC_msg_filament_out_alert : AC_msg_filament_out_block);
   PlayTune(FilamentOut);
 }
 
-void ChironTFT::ConfirmationRequest(const char * const msg)  {
+void ChironTFT::confirmationRequest(const char * const msg)  {
   // M108 continue
   #if ACDEBUG(AC_MARLIN)
-    SERIAL_ECHOLNPGM("ConfirmationRequest() ", msg, " printer_state:", printer_state);
+    DEBUG_ECHOLNPGM("confirmationRequest() ", msg, " printer_state:", printer_state);
   #endif
   switch (printer_state) {
     case AC_printer_pausing: {
       if (strcmp_P(msg, MARLIN_msg_print_paused) == 0 || strcmp_P(msg, MARLIN_msg_nozzle_parked) == 0) {
-        SendtoTFTLN(AC_msg_paused); // enable continue button
+        tftSendLn(AC_msg_paused); // enable continue button
         printer_state = AC_printer_paused;
       }
     } break;
 
     case AC_printer_resuming_from_power_outage:
     case AC_printer_printing:
     case AC_printer_paused: {
       // Heater timeout, send acknowledgement
       if (strcmp_P(msg, MARLIN_msg_heater_timeout) == 0) {
         pause_state = AC_paused_heater_timed_out;
-        SendtoTFTLN(AC_msg_paused); // enable continue button
+        tftSendLn(AC_msg_paused); // enable continue button
         PlayTune(HeaterTimeout);
       }
       // Reheat finished, send acknowledgement
       else if (strcmp_P(msg, MARLIN_msg_reheat_done) == 0) {
         pause_state = AC_paused_idle;
-        SendtoTFTLN(AC_msg_paused); // enable continue button
+        tftSendLn(AC_msg_paused); // enable continue button
       }
       // Filament Purging, send acknowledgement enter run mode
       else if (strcmp_P(msg, MARLIN_msg_filament_purging) == 0) {
         pause_state = AC_paused_purging_filament;
-        SendtoTFTLN(AC_msg_paused); // enable continue button
+        tftSendLn(AC_msg_paused); // enable continue button
       }
     } break;
     default:
     break;
   }
 }
 
-void ChironTFT::StatusChange(const char * const msg)  {
+void ChironTFT::statusChange(const char * const msg)  {
   #if ACDEBUG(AC_MARLIN)
-    SERIAL_ECHOLNPGM("StatusChange() ", msg);
-    SERIAL_ECHOLNPGM("printer_state:", printer_state);
+    DEBUG_ECHOLNPGM("statusChange() ", msg);
+    DEBUG_ECHOLNPGM("printer_state:", printer_state);
   #endif
   bool msg_matched = false;
   // The only way to get printer status is to parse messages
   // Use the state to minimise the work we do here.
   switch (printer_state) {
     case AC_printer_probing: {
       // If probing completes ok save the mesh and park
       // Ignore the custom machine name
       if (strcmp_P(msg + strlen(MACHINE_NAME), MARLIN_msg_ready) == 0) {
         injectCommands(F("M500\nG27"));
-        SendtoTFTLN(AC_msg_probing_complete);
+        tftSendLn(AC_msg_probing_complete);
         printer_state = AC_printer_idle;
         msg_matched = true;
       }
       // If probing fails don't save the mesh raise the probe above the bad point
       if (strcmp_P(msg, MARLIN_msg_probing_failed) == 0) {
         PlayTune(BeepBeepBeeep);
         injectCommands(F("G1 Z50 F500"));
-        SendtoTFTLN(AC_msg_probing_complete);
+        tftSendLn(AC_msg_probing_complete);
         printer_state = AC_printer_idle;
         msg_matched = true;
       }
     } break;
 
     case AC_printer_printing: {
       if (strcmp_P(msg, MARLIN_msg_reheating) == 0) {
-        SendtoTFTLN(AC_msg_paused); // enable continue button
+        tftSendLn(AC_msg_paused); // enable continue button
         msg_matched = true;
        }
     } break;
 
     case AC_printer_pausing: {
       if (strcmp_P(msg, MARLIN_msg_print_paused) == 0) {
-        SendtoTFTLN(AC_msg_paused);
+        tftSendLn(AC_msg_paused);
         printer_state = AC_printer_paused;
         pause_state = AC_paused_idle;
         msg_matched = true;
        }
     } break;
 
     case AC_printer_stopping: {
       if (strcmp_P(msg, MARLIN_msg_print_aborted) == 0) {
-        SendtoTFTLN(AC_msg_stop);
+        tftSendLn(AC_msg_stop);
         printer_state = AC_printer_idle;
         msg_matched = true;
       }
     } break;
     default:
     break;
   }
 
   // If not matched earlier see if this was a heater message
   if (!msg_matched) {
     if (strcmp_P(msg, MARLIN_msg_extruder_heating) == 0) {
-      SendtoTFTLN(AC_msg_nozzle_heating);
+      tftSendLn(AC_msg_nozzle_heating);
       hotend_state = AC_heater_temp_set;
     }
     else if (strcmp_P(msg, MARLIN_msg_bed_heating) == 0) {
-      SendtoTFTLN(AC_msg_bed_heating);
+      tftSendLn(AC_msg_bed_heating);
       hotbed_state = AC_heater_temp_set;
     }
     else if (strcmp_P(msg, MARLIN_msg_EEPROM_version) == 0) {
       last_error = AC_error_EEPROM;
     }
   }
 }
 
-void ChironTFT::PowerLossRecovery()  {
+void ChironTFT::powerLossRecovery()  {
   printer_state = AC_printer_resuming_from_power_outage; // Play tune to notify user we can recover.
   last_error = AC_error_powerloss;
   PlayTune(SOS);
   SERIAL_ECHOLNF(AC_msg_powerloss_recovery);
 }
 
-void ChironTFT::PrintComplete() {
-  SendtoTFT(AC_msg_print_complete);
+void ChironTFT::printComplete() {
+  tftSend(AC_msg_print_complete);
   printer_state = AC_printer_idle;
   setSoftEndstopState(true); // enable endstops
 }
 
-void ChironTFT::SendtoTFT(FSTR_P const fstr/*=nullptr*/) {  // A helper to print PROGMEM string to the panel
+void ChironTFT::tftSend(FSTR_P const fstr/*=nullptr*/) {  // A helper to print PROGMEM string to the panel
   #if ACDEBUG(AC_SOME)
-    SERIAL_ECHOF(fstr);
+    DEBUG_ECHOF(fstr);
   #endif
   PGM_P str = FTOP(fstr);
   while (const char c = pgm_read_byte(str++)) TFTSer.write(c);
 }
 
-void ChironTFT::SendtoTFTLN(FSTR_P const fstr/*=nullptr*/) {
+void ChironTFT::tftSendLn(FSTR_P const fstr/*=nullptr*/) {
   if (fstr) {
     #if ACDEBUG(AC_SOME)
-      SERIAL_ECHOPGM("> ");
+      DEBUG_ECHOPGM("> ");
     #endif
-    SendtoTFT(fstr);
+    tftSend(fstr);
     #if ACDEBUG(AC_SOME)
       SERIAL_EOL();
     #endif
   }
   TFTSer.println();
 }
 
-bool ChironTFT::ReadTFTCommand() {
+bool ChironTFT::readTFTCommand() {
   bool command_ready = false;
   while (TFTSer.available() > 0 && command_len < MAX_CMND_LEN) {
     panel_command[command_len] = TFTSer.read();
     if (panel_command[command_len] == '\n') {
       command_ready = true;
       break;
     }
     command_len++;
   }
 
   if (command_ready || command_len == MAX_CMND_LEN) {
     panel_command[command_len] = '\0';
     #if ACDEBUG(AC_ALL)
-      SERIAL_ECHOLNPGM("len(",command_len,") < ", panel_command);
+      DEBUG_ECHOLNPGM("len(",command_len,") < ", panel_command);
     #endif
     command_ready = true;
   }
   return command_ready;
 }
 
-int8_t ChironTFT::FindToken(char c) {
+int8_t ChironTFT::findToken(char c) {
   for (int8_t pos = 0; pos < command_len; pos++) {
     if (panel_command[pos] == c) {
       #if ACDEBUG(AC_INFO)
-        SERIAL_ECHOLNPGM("Tpos:", pos, " ", c);
+        DEBUG_ECHOLNPGM("Tpos:", pos, " ", c);
       #endif
       return pos;
     }
   }
   #if ACDEBUG(AC_INFO)
-    SERIAL_ECHOLNPGM("Not found: ", c);
+    DEBUG_ECHOLNPGM("Not found: ", c);
   #endif
   return -1;
 }
 
-void ChironTFT::CheckHeaters() {
+void ChironTFT::checkHeaters() {
   uint8_t faultDuration = 0;
 
   // if the hotend temp is abnormal, confirm state before signalling panel
   celsius_float_t temp = getActualTemp_celsius(E0);
   while (!WITHIN(temp, HEATER_0_MINTEMP, HEATER_0_MAXTEMP)) {
     faultDuration++;
     if (faultDuration >= AC_HEATER_FAULT_VALIDATION_TIME) {
-      SendtoTFTLN(AC_msg_nozzle_temp_abnormal);
+      tftSendLn(AC_msg_nozzle_temp_abnormal);
       last_error = AC_error_abnormal_temp_t0;
       SERIAL_ECHOLNPGM("Extruder temp abnormal! : ", temp);
       break;
     }
     delay_ms(500);
     temp = getActualTemp_celsius(E0);
   }
 
   // If the hotbed temp is abnormal, confirm state before signaling panel
   faultDuration = 0;
   temp = getActualTemp_celsius(BED);
   while (!WITHIN(temp, BED_MINTEMP, BED_MAXTEMP)) {
     faultDuration++;
     if (faultDuration >= AC_HEATER_FAULT_VALIDATION_TIME) {
-      SendtoTFTLN(AC_msg_nozzle_temp_abnormal);
+      tftSendLn(AC_msg_nozzle_temp_abnormal);
       last_error = AC_error_abnormal_temp_bed;
       SERIAL_ECHOLNPGM("Bed temp abnormal! : ", temp);
       break;
     }
     delay_ms(500);
     temp = getActualTemp_celsius(E0);
   }
 
   // Update panel with hotend heater status
   if (hotend_state != AC_heater_temp_reached) {
     if (WITHIN(getActualTemp_celsius(E0) - getTargetTemp_celsius(E0), -(TEMP_WINDOW), TEMP_WINDOW)) {
-      SendtoTFTLN(AC_msg_nozzle_heating_done);
+      tftSendLn(AC_msg_nozzle_heating_done);
       hotend_state = AC_heater_temp_reached;
     }
   }
 
   // Update panel with bed heater status
   if (hotbed_state != AC_heater_temp_reached) {
     if (WITHIN(getActualTemp_celsius(BED) - getTargetTemp_celsius(BED), -(TEMP_BED_WINDOW), TEMP_BED_WINDOW)) {
-      SendtoTFTLN(AC_msg_bed_heating_done);
+      tftSendLn(AC_msg_bed_heating_done);
       hotbed_state = AC_heater_temp_reached;
     }
   }
 }
 
-void ChironTFT::SendFileList(int8_t startindex) {
+void ChironTFT::sendFileList(int8_t startindex) {
   // Respond to panel request for 4 files starting at index
   #if ACDEBUG(AC_INFO)
-    SERIAL_ECHOLNPGM("## SendFileList ## ", startindex);
+    DEBUG_ECHOLNPGM("## sendFileList ## ", startindex);
   #endif
-  SendtoTFTLN(F("FN "));
+  tftSendLn(F("FN "));
   filenavigator.getFiles(startindex, panel_type, 4);
-  SendtoTFTLN(F("END"));
+  tftSendLn(F("END"));
 }
 
-void ChironTFT::SelectFile() {
+void ChironTFT::selectFile() {
   if (panel_type <= AC_panel_new) {
     strncpy(selectedfile, panel_command + 4, command_len - 3);
     selectedfile[command_len - 4] = '\0';
   }
   else {
     strncpy(selectedfile, panel_command + 4, command_len - 4);
     selectedfile[command_len - 5] = '\0';
   }
   #if ACDEBUG(AC_FILE)
-    SERIAL_ECHOLNPGM(" Selected File: ",selectedfile);
+    DEBUG_ECHOLNPGM(" Selected File: ",selectedfile);
   #endif
   switch (selectedfile[0]) {
     case '/':   // Valid file selected
-      SendtoTFTLN(AC_msg_sd_file_open_success);
+      tftSendLn(AC_msg_sd_file_open_success);
       break;
 
     case '<':   // .. (go up folder level)
       filenavigator.upDIR();
-      SendtoTFTLN(AC_msg_sd_file_open_failed);
-      SendFileList( 0 );
+      tftSendLn(AC_msg_sd_file_open_failed);
+      sendFileList( 0 );
       break;
     default:   // enter sub folder
       // for new panel remove the '.GCO' tag that was added to the end of the path
       if (panel_type <= AC_panel_new)
         selectedfile[strlen(selectedfile) - 4] = '\0';
       filenavigator.changeDIR(selectedfile);
-      SendtoTFTLN(AC_msg_sd_file_open_failed);
-      SendFileList( 0 );
+      tftSendLn(AC_msg_sd_file_open_failed);
+      sendFileList( 0 );
       break;
   }
 }
 
-void ChironTFT::ProcessPanelRequest() {
+void ChironTFT::processPanelRequest() {
   // Break these up into logical blocks // as its easier to navigate than one huge switch case!
-  int8_t tpos = FindToken('A');
+  int8_t tpos = findToken('A');
   // Panel request are 'A0' - 'A36'
   if (tpos >= 0) {
     const int8_t req = atoi(&panel_command[tpos + 1]);
 
     // Information requests A0 - A8 and A33
-    if (req <= 8 || req == 33) PanelInfo(req);
+    if (req <= 8 || req == 33) panelInfo(req);
 
     // Simple Actions A9 - A28
-    else if (req <= 28) PanelAction(req);
+    else if (req <= 28) panelAction(req);
 
     // Process Initiation
-    else if (req <= 36) PanelProcess(req);
+    else if (req <= 36) panelProcess(req);
   }
   else {
     #if AUTO_DETECT_CHIRON_TFT
       // This may be a response to a panel type detection query
       if (panel_type == AC_panel_unknown) {
-        tpos = FindToken('S'); // old panel will respond to 'SIZE' with 'SXY 480 320'
+        tpos = findToken('S'); // old panel will respond to 'SIZE' with 'SXY 480 320'
         if (tpos >= 0) {
           if (panel_command[tpos + 1] == 'X' && panel_command[tpos + 2] =='Y') {
             panel_type = AC_panel_standard;
             SERIAL_ECHOLNF(AC_msg_old_panel_detected);
           }
         }
         else {
           // new panel will respond to 'J200' with '[0]=0'
           // it seems only after a power cycle so detection assumes a new panel
-          tpos = FindToken('[');
+          tpos = findToken('[');
           if (tpos >= 0) {
             if (panel_command[tpos + 1] == '0' && panel_command[tpos + 2] ==']') {
               panel_type = AC_panel_new;
               SERIAL_ECHOLNF(AC_msg_new_panel_detected);
             }
           }
         }
         return;
       }
     #endif
 
-    SendtoTFTLN(); // Ignore unknown requests
+    tftSendLn(); // Ignore unknown requests
   }
 }
 
-void ChironTFT::PanelInfo(uint8_t req) {
+void ChironTFT::panelInfo(uint8_t req) {
   // information requests A0-A8 and A33
   switch (req) {
     case 0:   // A0 Get HOTEND Temp
-      SendtoTFT(F("A0V "));
+      tftSend(F("A0V "));
       TFTSer.println(getActualTemp_celsius(E0));
       break;
 
     case 1:   // A1 Get HOTEND Target Temp
-      SendtoTFT(F("A1V "));
+      tftSend(F("A1V "));
       TFTSer.println(getTargetTemp_celsius(E0));
       break;
 
     case 2:   // A2 Get BED Temp
-      SendtoTFT(F("A2V "));
+      tftSend(F("A2V "));
       TFTSer.println(getActualTemp_celsius(BED));
       break;
 
     case 3:   // A3 Get BED Target Temp
-      SendtoTFT(F("A3V "));
+      tftSend(F("A3V "));
       TFTSer.println(getTargetTemp_celsius(BED));
       break;
 
     case 4:   // A4 Get FAN Speed
-      SendtoTFT(F("A4V "));
+      tftSend(F("A4V "));
       TFTSer.println(getActualFan_percent(FAN0));
       break;
 
     case 5:   // A5 Get Current Coordinates
-      SendtoTFT(F("A5V X: "));
+      tftSend(F("A5V X: "));
       TFTSer.print(getAxisPosition_mm(X));
-      SendtoTFT(F(" Y: "));
+      tftSend(F(" Y: "));
       TFTSer.print(getAxisPosition_mm(Y));
-      SendtoTFT(F(" Z: "));
+      tftSend(F(" Z: "));
       TFTSer.println(getAxisPosition_mm(Z));
       break;
 
     case 6:   // A6 Get printing progress
       if (isPrintingFromMedia()) {
-        SendtoTFT(F("A6V "));
+        tftSend(F("A6V "));
         TFTSer.println(ui8tostr2(getProgress_percent()));
       }
       else
-        SendtoTFTLN(F("A6V ---"));
+        tftSendLn(F("A6V ---"));
       break;
 
     case 7: { // A7 Get Printing Time
       uint32_t time = getProgress_seconds_elapsed() / 60;
-      SendtoTFT(F("A7V "));
+      tftSend(F("A7V "));
       TFTSer.print(ui8tostr2(time / 60));
-      SendtoTFT(F(" H "));
+      tftSend(F(" H "));
       TFTSer.print(ui8tostr2(time % 60));
-      SendtoTFT(F(" M"));
+      tftSend(F(" M"));
       #if ACDEBUG(AC_ALL)
-        SERIAL_ECHOLNPGM("Print time ", ui8tostr2(time / 60), ":", ui8tostr2(time % 60));
+        DEBUG_ECHOLNPGM("Print time ", ui8tostr2(time / 60), ":", ui8tostr2(time % 60));
       #endif
     } break;
 
     case 8:   // A8 Get SD Card list A8 S0
       if (!isMediaInserted()) safe_delay(500);
       if (!isMediaInserted())   // Make sure the card is removed
-        SendtoTFTLN(AC_msg_no_sd_card);
+        tftSendLn(AC_msg_no_sd_card);
       else if (panel_command[3] == 'S')
-        SendFileList( atoi( &panel_command[4] ) );
+        sendFileList( atoi( &panel_command[4] ) );
       break;
 
     case 33:   // A33 Get firmware info
-      SendtoTFT(F("J33 "));
+      tftSend(F("J33 "));
       // If there is an error recorded, show that instead of the FW version
-      if (!GetLastError()) SendtoTFTLN(F(SHORT_BUILD_VERSION));
+      if (!getLastError()) tftSendLn(F(SHORT_BUILD_VERSION));
       break;
   }
 }
 
-void ChironTFT::PanelAction(uint8_t req) {
+void ChironTFT::panelAction(uint8_t req) {
   switch (req) {
     case  9:   // A9 Pause SD print
       if (isPrintingFromMedia()) {
-        SendtoTFTLN(AC_msg_pause);
+        tftSendLn(AC_msg_pause);
         pausePrint();
         printer_state = AC_printer_pausing;
       }
       else
-        SendtoTFTLN(AC_msg_stop);
+        tftSendLn(AC_msg_stop);
       break;
 
     case 10: // A10 Resume SD Print
       if (pause_state == AC_paused_idle || printer_state == AC_printer_resuming_from_power_outage)
         resumePrint();
       else
         setUserConfirmed();
       break;
 
     case 11:   // A11 Stop SD print
       if (isPrintingFromMedia()) {
         printer_state = AC_printer_stopping;
         stopPrint();
       }
       else {
         if (printer_state == AC_printer_resuming_from_power_outage)
           injectCommands(F("M1000 C")); // Cancel recovery
-        SendtoTFTLN(AC_msg_stop);
+        tftSendLn(AC_msg_stop);
         printer_state = AC_printer_idle;
       }
       break;
 
     case 12:   // A12 Kill printer
       kill();  // from marlincore.h
       break;
 
     case 13:   // A13 Select file
-      SelectFile();
+      selectFile();
       break;
 
     case 14:   // A14 Start Printing
       // Allows printer to restart the job if we don't want to recover
       if (printer_state == AC_printer_resuming_from_power_outage) {
         injectCommands(F("M1000 C")); // Cancel recovery
         printer_state = AC_printer_idle;
       }
-      #if ACDebugLevel >= 1
-        SERIAL_ECHOLNPGM("Print: ", selectedfile);
-      #endif
+      DEBUG_ECHOLNPGM("Print: ", selectedfile);
       printFile(selectedfile);
-      SendtoTFTLN(AC_msg_print_from_sd_card);
+      tftSendLn(AC_msg_print_from_sd_card);
       break;
 
     case 15:   // A15 Resuming from outage
       if (printer_state == AC_printer_resuming_from_power_outage) {
         // Need to home here to restore the Z position
         injectCommands(AC_cmnd_power_loss_recovery);
         injectCommands(F("M1000"));  // home and start recovery
       }
       break;
 
@@ -664,29 +666,29 @@ void ChironTFT::PanelAction(uint8_t req) {
     } break;
 
     case 18:   // A18 Set Fan Speed
       if (panel_command[4] == 'S')
         setTargetFan_percent(atof(&panel_command[5]), FAN0);
       break;
 
     case 19:   // A19 Motors off
       if (!isPrinting()) {
         stepper.disable_all_steppers();
-        SendtoTFTLN(AC_msg_ready);
+        tftSendLn(AC_msg_ready);
       }
       break;
 
     case 20:   // A20 Read/write print speed
       if (panel_command[4] == 'S')
         setFeedrate_percent(atoi(&panel_command[5]));
       else {
-        SendtoTFT(F("A20V "));
+        tftSend(F("A20V "));
         TFTSer.println(getFeedrate_percent());
       }
       break;
 
     case 21:   // A21 Home Axis  A21 X
       if (!isPrinting()) {
         switch ((char)panel_command[4]) {
           case 'X': injectCommands(F("G28X")); break;
           case 'Y': injectCommands(F("G28Y")); break;
           case 'Z': injectCommands(F("G28Z")); break;
@@ -700,278 +702,278 @@ void ChironTFT::PanelAction(uint8_t req) {
       // Old TFT A22 X -1F1500      A22 X +1F1500
       // New TFT A22 X-1.0 F1500    A22 X1.0 F1500
 
       // Send a G-code-relative non-print move and let the controller deal with it
       // G91 G0 <panel command> G90
 
       if (!isPrinting()) { // Ignore request if printing
         char MoveCmnd[30];
         sprintf_P(MoveCmnd, PSTR("G91\nG0%s\nG90"), panel_command + 3);
         #if ACDEBUG(AC_ACTION)
-          SERIAL_ECHOLNPGM("Move: ", MoveCmnd);
+          DEBUG_ECHOLNPGM("Move: ", MoveCmnd);
         #endif
         setSoftEndstopState(true);  // enable endstops
         injectCommands(MoveCmnd);
       }
     } break;
 
     case 23:   // A23 Preheat PLA
       // Ignore request if printing
       if (!isPrinting()) {
         // Temps defined in configuration.h
         setTargetTemp_celsius(PREHEAT_1_TEMP_BED, BED);
         setTargetTemp_celsius(PREHEAT_1_TEMP_HOTEND, E0);
-        SendtoTFTLN();
+        tftSendLn();
         hotbed_state = AC_heater_temp_set;
         hotend_state = AC_heater_temp_set;
       }
       break;
 
     case 24:   // A24 Preheat ABS
       // Ignore request if printing
       if (!isPrinting()) {
         setTargetTemp_celsius(PREHEAT_2_TEMP_BED, BED);
         setTargetTemp_celsius(PREHEAT_2_TEMP_HOTEND, E0);
-        SendtoTFTLN();
+        tftSendLn();
         hotbed_state = AC_heater_temp_set;
         hotend_state = AC_heater_temp_set;
       }
       break;
 
     case 25:   // A25 Cool Down
       // Ignore request if printing
       if (!isPrinting()) {
         setTargetTemp_celsius(0, E0);
         setTargetTemp_celsius(0, BED);
-        SendtoTFTLN(AC_msg_ready);
+        tftSendLn(AC_msg_ready);
         hotbed_state = AC_heater_off;
         hotend_state = AC_heater_off;
       }
       break;
 
     case 26:   // A26 Refresh SD
       if (card.isMounted())card.release();
       card.mount();
       safe_delay(500);
       filenavigator.reset();
       break;
 
     case 27:   // A27 Servo Angles adjust
       break;
 
     case 28:   // A28 Filament set A28 O/C
       // Ignore request if printing
       if (isPrinting()) break;
-      SendtoTFTLN();
+      tftSendLn();
       break;
   }
 }
 
-void ChironTFT::PanelProcess(uint8_t req) {
+void ChironTFT::panelProcess(uint8_t req) {
   switch (req) {
     case 29: { // A29 Read Mesh Point A29 X1 Y1
       xy_uint8_t pos;
       float pos_z;
-      pos.x = atoi(&panel_command[FindToken('X')+1]);
-      pos.y = atoi(&panel_command[FindToken('Y')+1]);
+      pos.x = atoi(&panel_command[findToken('X')+1]);
+      pos.y = atoi(&panel_command[findToken('Y')+1]);
       pos_z = getMeshPoint(pos);
 
-      SendtoTFT(F("A29V "));
+      tftSend(F("A29V "));
       TFTSer.println(pos_z * 100);
       if (!isPrinting()) {
         setSoftEndstopState(true);  // disable endstops
         // If the same meshpoint is selected twice in a row, move the head to that ready for adjustment
         if ((selectedmeshpoint.x == pos.x) && (selectedmeshpoint.y == pos.y)) {
           if (!isPositionKnown())
             injectCommands_P(G28_STR); // home
 
           if (isPositionKnown()) {
             #if ACDEBUG(AC_INFO)
-              SERIAL_ECHOLNPGM("Moving to mesh point at x: ", pos.x, " y: ", pos.y, " z: ", pos_z);
+              DEBUG_ECHOLNPGM("Moving to mesh point at x: ", pos.x, " y: ", pos.y, " z: ", pos_z);
             #endif
             // Go up before moving
             setAxisPosition_mm(3.0,Z);
 
             setAxisPosition_mm(17 + (93 * pos.x), X);
             setAxisPosition_mm(20 + (93 * pos.y), Y);
             setAxisPosition_mm(0.0, Z);
             #if ACDEBUG(AC_INFO)
-              SERIAL_ECHOLNPGM("Current Z: ", getAxisPosition_mm(Z));
+              DEBUG_ECHOLNPGM("Current Z: ", getAxisPosition_mm(Z));
             #endif
           }
         }
         selectedmeshpoint.x = pos.x;
         selectedmeshpoint.y = pos.y;
       }
     } break;
 
     case 30:     // A30 Auto leveling
-      if (FindToken('S') >= 0) { // Start probing New panel adds spaces..
+      if (findToken('S') >= 0) { // Start probing New panel adds spaces..
         // Ignore request if printing
         if (isPrinting())
-          SendtoTFTLN(AC_msg_probing_not_allowed); // forbid auto leveling
+          tftSendLn(AC_msg_probing_not_allowed); // forbid auto leveling
         else {
-          SendtoTFTLN(AC_msg_start_probing);
+          tftSendLn(AC_msg_start_probing);
           injectCommands(F("G28\nG29"));
           printer_state = AC_printer_probing;
         }
       }
       else
-        SendtoTFTLN(AC_msg_start_probing); // Just enter levelling menu
+        tftSendLn(AC_msg_start_probing); // Just enter levelling menu
       break;
 
     case 31:   // A31 Adjust all Probe Points
       // The tokens can occur in different places on the new panel so we need to find it.
 
-      if (FindToken('C') >= 0) { // Restore and apply original offsets
+      if (findToken('C') >= 0) { // Restore and apply original offsets
         if (!isPrinting()) {
           injectCommands(F("M501\nM420 S1"));
           selectedmeshpoint.x = selectedmeshpoint.y = 99;
           SERIAL_ECHOLNF(AC_msg_mesh_changes_abandoned);
         }
       }
 
-      else if (FindToken('D') >= 0) { // Save Z Offset tables and restore leveling state
+      else if (findToken('D') >= 0) { // Save Z Offset tables and restore leveling state
         if (!isPrinting()) {
           setAxisPosition_mm(1.0,Z); // Lift nozzle before any further movements are made
           injectCommands(F("M500"));
           SERIAL_ECHOLNF(AC_msg_mesh_changes_saved);
           selectedmeshpoint.x = selectedmeshpoint.y = 99;
         }
       }
 
-      else if (FindToken('G') >= 0) { // Get current offset
-        SendtoTFT(F("A31V "));
+      else if (findToken('G') >= 0) { // Get current offset
+        tftSend(F("A31V "));
         // When printing use the live z Offset position
         // we will use babystepping to move the print head
         if (isPrinting())
           TFTSer.println(live_Zoffset);
         else {
           TFTSer.println(getZOffset_mm());
           selectedmeshpoint.x = selectedmeshpoint.y = 99;
         }
       }
 
       else {
-        int8_t tokenpos = FindToken('S');
+        int8_t tokenpos = findToken('S');
         if (tokenpos >= 0) { // Set offset (adjusts all points by value)
           float Zshift = atof(&panel_command[tokenpos+1]);
           setSoftEndstopState(false);  // disable endstops
           // Allow temporary Z position nudging during print
           // From the leveling panel use the all points UI to adjust the print pos.
           if (isPrinting()) {
             #if ACDEBUG(AC_INFO)
-              SERIAL_ECHOLNPGM("Change Zoffset from:", live_Zoffset, " to ", live_Zoffset + Zshift);
+              DEBUG_ECHOLNPGM("Change Zoffset from:", live_Zoffset, " to ", live_Zoffset + Zshift);
             #endif
             if (isAxisPositionKnown(Z)) {
               #if ACDEBUG(AC_INFO)
                 const float currZpos = getAxisPosition_mm(Z);
-                SERIAL_ECHOLNPGM("Nudge Z pos from ", currZpos, " to ", currZpos + constrain(Zshift, -0.05, 0.05));
+                DEBUG_ECHOLNPGM("Nudge Z pos from ", currZpos, " to ", currZpos + constrain(Zshift, -0.05, 0.05));
               #endif
               // Use babystepping to adjust the head position
               int16_t steps = mmToWholeSteps(constrain(Zshift,-0.05,0.05), Z);
               #if ACDEBUG(AC_INFO)
-                SERIAL_ECHOLNPGM("Steps to move Z: ", steps);
+                DEBUG_ECHOLNPGM("Steps to move Z: ", steps);
               #endif
               babystepAxis_steps(steps, Z);
               live_Zoffset += Zshift;
             }
-            SendtoTFT(F("A31V "));
+            tftSend(F("A31V "));
             TFTSer.println(live_Zoffset);
           }
           else {
             GRID_LOOP(x, y) {
               const xy_uint8_t pos { x, y };
               const float currval = getMeshPoint(pos);
               setMeshPoint(pos, constrain(currval + Zshift, AC_LOWEST_MESHPOINT_VAL, 2));
               #if ACDEBUG(AC_INFO)
-                SERIAL_ECHOLNPGM("Change mesh point X", x," Y",y ," from ", currval, " to ", getMeshPoint(pos) );
+                DEBUG_ECHOLNPGM("Change mesh point X", x," Y",y ," from ", currval, " to ", getMeshPoint(pos) );
               #endif
             }
             const float currZOffset = getZOffset_mm();
             #if ACDEBUG(AC_INFO)
-              SERIAL_ECHOLNPGM("Change probe offset from ", currZOffset, " to  ", currZOffset + Zshift);
+              DEBUG_ECHOLNPGM("Change probe offset from ", currZOffset, " to  ", currZOffset + Zshift);
             #endif
 
             setZOffset_mm(currZOffset + Zshift);
-            SendtoTFT(F("A31V "));
+            tftSend(F("A31V "));
             TFTSer.println(getZOffset_mm());
 
             if (isAxisPositionKnown(Z)) {
               // Move Z axis
               const float currZpos = getAxisPosition_mm(Z);
               #if ACDEBUG(AC_INFO)
-                SERIAL_ECHOLNPGM("Move Z pos from ", currZpos, " to ", currZpos + constrain(Zshift, -0.05, 0.05));
+                DEBUG_ECHOLNPGM("Move Z pos from ", currZpos, " to ", currZpos + constrain(Zshift, -0.05, 0.05));
               #endif
               setAxisPosition_mm(currZpos+constrain(Zshift,-0.05,0.05),Z);
             }
           }
         }
       }
       break;
 
     case 32:   // A32 clean leveling beep flag
       // Ignore request if printing
       //if (isPrinting()) break;
       //injectCommands(F("M500\nM420 S1\nG1 Z10 F240\nG1 X0 Y0 F6000"));
       //TFTSer.println();
       break;
 
-    // A33 firmware info request see PanelInfo()
+    // A33 firmware info request see panelInfo()
 
     case 34:    // A34 Adjust single mesh point A34 C/S X1 Y1 V123
       if (panel_command[3] == 'C') { // Restore original offsets
         injectCommands(F("M501\nM420 S1"));
         selectedmeshpoint.x = selectedmeshpoint.y = 99;
         //printer_state = AC_printer_idle;
       }
       else {
         xy_uint8_t pos;
         pos.x = atoi(&panel_command[5]);
         pos.y = atoi(&panel_command[8]);
 
         float currmesh = getMeshPoint(pos);
         float newval   = atof(&panel_command[11])/100;
         #if ACDEBUG(AC_INFO)
-          SERIAL_ECHOLNPGM("Change mesh point x:", pos.x, " y:", pos.y);
-          SERIAL_ECHOLNPGM("from ", currmesh, " to ", newval);
+          DEBUG_ECHOLNPGM("Change mesh point x:", pos.x, " y:", pos.y);
+          DEBUG_ECHOLNPGM("from ", currmesh, " to ", newval);
         #endif
         // Update Meshpoint
         setMeshPoint(pos,newval);
         if (printer_state == AC_printer_idle || printer_state == AC_printer_probing /*!isPrinting()*/) {
           // if we are at the current mesh point indicated on the panel Move Z pos +/- 0.05mm
           // (The panel changes the mesh value by +/- 0.05mm on each button press)
           if (selectedmeshpoint.x == pos.x && selectedmeshpoint.y == pos.y) {
             setSoftEndstopState(false);
             float currZpos = getAxisPosition_mm(Z);
             #if ACDEBUG(AC_INFO)
-              SERIAL_ECHOLNPGM("Move Z pos from ", currZpos, " to ", currZpos + constrain(newval - currmesh, -0.05, 0.05));
+              DEBUG_ECHOLNPGM("Move Z pos from ", currZpos, " to ", currZpos + constrain(newval - currmesh, -0.05, 0.05));
             #endif
             setAxisPosition_mm(currZpos + constrain(newval - currmesh, -0.05, 0.05), Z);
           }
         }
       }
       break;
 
     case 36:    // A36 Auto leveling for new TFT bet that was a typo in the panel code!
-      SendtoTFTLN(AC_msg_start_probing);
+      tftSendLn(AC_msg_start_probing);
       break;
   }
 }
 
-bool ChironTFT::GetLastError() {
+bool ChironTFT::getLastError() {
   switch (last_error) {
-    case AC_error_abnormal_temp_bed: SendtoTFTLN(AC_msg_error_bed_temp);    break;
-    case AC_error_abnormal_temp_t0:  SendtoTFTLN(AC_msg_error_hotend_temp); break;
-    case AC_error_noSD:              SendtoTFTLN(AC_msg_error_sd_card);     break;
-    case AC_error_powerloss:         SendtoTFTLN(AC_msg_power_loss);        break;
-    case AC_error_EEPROM:            SendtoTFTLN(AC_msg_eeprom_version);    break;
-    case AC_error_filament_runout:   SendtoTFTLN(AC_msg_filament_out);      break;
+    case AC_error_abnormal_temp_bed: tftSendLn(AC_msg_error_bed_temp);    break;
+    case AC_error_abnormal_temp_t0:  tftSendLn(AC_msg_error_hotend_temp); break;
+    case AC_error_noSD:              tftSendLn(AC_msg_error_sd_card);     break;
+    case AC_error_powerloss:         tftSendLn(AC_msg_power_loss);        break;
+    case AC_error_EEPROM:            tftSendLn(AC_msg_eeprom_version);    break;
+    case AC_error_filament_runout:   tftSendLn(AC_msg_filament_out);      break;
     default: return false;
   }
   last_error = AC_error_none;
   return true;
 }
 
 } // Anycubic namespace
 
 #endif // ANYCUBIC_LCD_CHIRON

commit 743903b96fd64ef8cbe23d84eed7de1e29b1abed
Author: Nick <nick@n-wells.co.uk>
Date:   Mon Apr 24 01:50:39 2023 +0100

    ü©π Fix Anycubic PlayTune (#25735)
    
    Followup to #25690
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index 45fb73c02f..f3bc64a024 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -97,21 +97,21 @@ void ChironTFT::Startup() {
   }
 
   // Signal Board has reset
   SendtoTFTLN(AC_msg_main_board_has_reset);
 
   // Enable leveling and Disable end stops during print
   // as Z home places nozzle above the bed so we need to allow it past the end stops
   injectCommands(AC_cmnd_enable_leveling);
 
   // Startup tunes are defined in Tunes.h
-  PlayTune(TERN(AC_DEFAULT_STARTUP_TUNE, Anycubic_PowerOn, GB_PowerOn), 1);
+  PlayTune(TERN(AC_DEFAULT_STARTUP_TUNE, Anycubic_PowerOn, GB_PowerOn));
 
   #if ACDEBUGLEVEL
     SERIAL_ECHOLNPGM("AC Debug Level ", ACDEBUGLEVEL);
   #endif
   SendtoTFTLN(AC_msg_ready);
 }
 
 void ChironTFT::DetectPanelType() {
   #if AUTO_DETECT_CHIRON_TFT
     // Send a query to the TFT
@@ -185,21 +185,21 @@ void ChironTFT::TimerEvent(timer_event_t event)  {
   }
 }
 
 void ChironTFT::FilamentRunout()  {
   #if ACDEBUG(AC_MARLIN)
     SERIAL_ECHOLNPGM("FilamentRunout() printer_state ", printer_state);
   #endif
   // 1 Signal filament out
   last_error = AC_error_filament_runout;
   SendtoTFTLN(isPrintingFromMedia() ? AC_msg_filament_out_alert : AC_msg_filament_out_block);
-  PlayTune(FilamentOut, 1);
+  PlayTune(FilamentOut);
 }
 
 void ChironTFT::ConfirmationRequest(const char * const msg)  {
   // M108 continue
   #if ACDEBUG(AC_MARLIN)
     SERIAL_ECHOLNPGM("ConfirmationRequest() ", msg, " printer_state:", printer_state);
   #endif
   switch (printer_state) {
     case AC_printer_pausing: {
       if (strcmp_P(msg, MARLIN_msg_print_paused) == 0 || strcmp_P(msg, MARLIN_msg_nozzle_parked) == 0) {
@@ -208,21 +208,21 @@ void ChironTFT::ConfirmationRequest(const char * const msg)  {
       }
     } break;
 
     case AC_printer_resuming_from_power_outage:
     case AC_printer_printing:
     case AC_printer_paused: {
       // Heater timeout, send acknowledgement
       if (strcmp_P(msg, MARLIN_msg_heater_timeout) == 0) {
         pause_state = AC_paused_heater_timed_out;
         SendtoTFTLN(AC_msg_paused); // enable continue button
-        PlayTune(BEEPER_PIN,Heater_Timedout,1);
+        PlayTune(HeaterTimeout);
       }
       // Reheat finished, send acknowledgement
       else if (strcmp_P(msg, MARLIN_msg_reheat_done) == 0) {
         pause_state = AC_paused_idle;
         SendtoTFTLN(AC_msg_paused); // enable continue button
       }
       // Filament Purging, send acknowledgement enter run mode
       else if (strcmp_P(msg, MARLIN_msg_filament_purging) == 0) {
         pause_state = AC_paused_purging_filament;
         SendtoTFTLN(AC_msg_paused); // enable continue button
@@ -246,21 +246,21 @@ void ChironTFT::StatusChange(const char * const msg)  {
       // If probing completes ok save the mesh and park
       // Ignore the custom machine name
       if (strcmp_P(msg + strlen(MACHINE_NAME), MARLIN_msg_ready) == 0) {
         injectCommands(F("M500\nG27"));
         SendtoTFTLN(AC_msg_probing_complete);
         printer_state = AC_printer_idle;
         msg_matched = true;
       }
       // If probing fails don't save the mesh raise the probe above the bad point
       if (strcmp_P(msg, MARLIN_msg_probing_failed) == 0) {
-        PlayTune(BeepBeepBeeep, 1);
+        PlayTune(BeepBeepBeeep);
         injectCommands(F("G1 Z50 F500"));
         SendtoTFTLN(AC_msg_probing_complete);
         printer_state = AC_printer_idle;
         msg_matched = true;
       }
     } break;
 
     case AC_printer_printing: {
       if (strcmp_P(msg, MARLIN_msg_reheating) == 0) {
         SendtoTFTLN(AC_msg_paused); // enable continue button
@@ -300,21 +300,21 @@ void ChironTFT::StatusChange(const char * const msg)  {
     }
     else if (strcmp_P(msg, MARLIN_msg_EEPROM_version) == 0) {
       last_error = AC_error_EEPROM;
     }
   }
 }
 
 void ChironTFT::PowerLossRecovery()  {
   printer_state = AC_printer_resuming_from_power_outage; // Play tune to notify user we can recover.
   last_error = AC_error_powerloss;
-  PlayTune(SOS, 1);
+  PlayTune(SOS);
   SERIAL_ECHOLNF(AC_msg_powerloss_recovery);
 }
 
 void ChironTFT::PrintComplete() {
   SendtoTFT(AC_msg_print_complete);
   printer_state = AC_printer_idle;
   setSoftEndstopState(true); // enable endstops
 }
 
 void ChironTFT::SendtoTFT(FSTR_P const fstr/*=nullptr*/) {  // A helper to print PROGMEM string to the panel

commit 6e3b58d76a00e861a9945f3073719f82473a0faf
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 15 22:24:14 2023 -0500

    üßë‚Äçüíª Anycubic shared code (#25690)

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index dce503776b..45fb73c02f 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -26,21 +26,21 @@
  * Extensible_UI implementation for Anycubic Chiron
  * Written By Nick Wells, 2020 [https://github.com/SwiftNick]
  *  (not affiliated with Anycubic, Ltd.)
  */
 
 #include "../../../inc/MarlinConfigPre.h"
 
 #if ENABLED(ANYCUBIC_LCD_CHIRON)
 
 #include "chiron_tft.h"
-#include "Tunes.h"
+#include "../anycubic/Tunes.h"
 #include "FileNavigator.h"
 
 #include "../../../gcode/queue.h"
 #include "../../../module/stepper.h"
 #include "../../../sd/cardreader.h"
 #include "../../../libs/numtostr.h"
 #include "../../../MarlinCore.h"
 
 namespace Anycubic {
 
@@ -97,21 +97,21 @@ void ChironTFT::Startup() {
   }
 
   // Signal Board has reset
   SendtoTFTLN(AC_msg_main_board_has_reset);
 
   // Enable leveling and Disable end stops during print
   // as Z home places nozzle above the bed so we need to allow it past the end stops
   injectCommands(AC_cmnd_enable_leveling);
 
   // Startup tunes are defined in Tunes.h
-  PlayTune(BEEPER_PIN, TERN(AC_DEFAULT_STARTUP_TUNE, Anycubic_PowerOn, GB_PowerOn), 1);
+  PlayTune(TERN(AC_DEFAULT_STARTUP_TUNE, Anycubic_PowerOn, GB_PowerOn), 1);
 
   #if ACDEBUGLEVEL
     SERIAL_ECHOLNPGM("AC Debug Level ", ACDEBUGLEVEL);
   #endif
   SendtoTFTLN(AC_msg_ready);
 }
 
 void ChironTFT::DetectPanelType() {
   #if AUTO_DETECT_CHIRON_TFT
     // Send a query to the TFT
@@ -185,21 +185,21 @@ void ChironTFT::TimerEvent(timer_event_t event)  {
   }
 }
 
 void ChironTFT::FilamentRunout()  {
   #if ACDEBUG(AC_MARLIN)
     SERIAL_ECHOLNPGM("FilamentRunout() printer_state ", printer_state);
   #endif
   // 1 Signal filament out
   last_error = AC_error_filament_runout;
   SendtoTFTLN(isPrintingFromMedia() ? AC_msg_filament_out_alert : AC_msg_filament_out_block);
-  PlayTune(BEEPER_PIN, FilamentOut, 1);
+  PlayTune(FilamentOut, 1);
 }
 
 void ChironTFT::ConfirmationRequest(const char * const msg)  {
   // M108 continue
   #if ACDEBUG(AC_MARLIN)
     SERIAL_ECHOLNPGM("ConfirmationRequest() ", msg, " printer_state:", printer_state);
   #endif
   switch (printer_state) {
     case AC_printer_pausing: {
       if (strcmp_P(msg, MARLIN_msg_print_paused) == 0 || strcmp_P(msg, MARLIN_msg_nozzle_parked) == 0) {
@@ -246,21 +246,21 @@ void ChironTFT::StatusChange(const char * const msg)  {
       // If probing completes ok save the mesh and park
       // Ignore the custom machine name
       if (strcmp_P(msg + strlen(MACHINE_NAME), MARLIN_msg_ready) == 0) {
         injectCommands(F("M500\nG27"));
         SendtoTFTLN(AC_msg_probing_complete);
         printer_state = AC_printer_idle;
         msg_matched = true;
       }
       // If probing fails don't save the mesh raise the probe above the bad point
       if (strcmp_P(msg, MARLIN_msg_probing_failed) == 0) {
-        PlayTune(BEEPER_PIN, BeepBeepBeeep, 1);
+        PlayTune(BeepBeepBeeep, 1);
         injectCommands(F("G1 Z50 F500"));
         SendtoTFTLN(AC_msg_probing_complete);
         printer_state = AC_printer_idle;
         msg_matched = true;
       }
     } break;
 
     case AC_printer_printing: {
       if (strcmp_P(msg, MARLIN_msg_reheating) == 0) {
         SendtoTFTLN(AC_msg_paused); // enable continue button
@@ -300,21 +300,21 @@ void ChironTFT::StatusChange(const char * const msg)  {
     }
     else if (strcmp_P(msg, MARLIN_msg_EEPROM_version) == 0) {
       last_error = AC_error_EEPROM;
     }
   }
 }
 
 void ChironTFT::PowerLossRecovery()  {
   printer_state = AC_printer_resuming_from_power_outage; // Play tune to notify user we can recover.
   last_error = AC_error_powerloss;
-  PlayTune(BEEPER_PIN, SOS, 1);
+  PlayTune(SOS, 1);
   SERIAL_ECHOLNF(AC_msg_powerloss_recovery);
 }
 
 void ChironTFT::PrintComplete() {
   SendtoTFT(AC_msg_print_complete);
   printer_state = AC_printer_idle;
   setSoftEndstopState(true); // enable endstops
 }
 
 void ChironTFT::SendtoTFT(FSTR_P const fstr/*=nullptr*/) {  // A helper to print PROGMEM string to the panel

commit 0021a58943721a81b1ef23fa5e7366cfd80a3d28
Author: Bob Kuhn <bob.kuhn@att.net>
Date:   Sun Mar 26 04:07:25 2023 -0500

    ‚ú® AnyCubic Vyper / Vyper LCD (#25405)

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index 285729cc15..dce503776b 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -65,28 +65,20 @@ void ChironTFT::Startup() {
   panel_command[0]  = '\0';
   command_len       = 0;
   last_error        = AC_error_none;
   printer_state     = AC_printer_idle;
   pause_state       = AC_paused_idle;
   hotend_state      = AC_heater_off;
   hotbed_state      = AC_heater_off;
   live_Zoffset      = 0.0;
   file_menu         = AC_menu_file;
 
-  // Setup pins for powerloss detection
-  // Two IO pins are connected on the Trigorilla Board
-  // On a power interruption the OUTAGECON_PIN goes low.
-
-  #if ENABLED(POWER_LOSS_RECOVERY)
-    OUT_WRITE(OUTAGECON_PIN, HIGH);
-  #endif
-
   // Filament runout is handled by Marlin settings in Configuration.h
   // opt_set    FIL_RUNOUT_STATE HIGH  // Pin state indicating that filament is NOT present.
   // opt_enable FIL_RUNOUT_PULLUP
   TFTSer.begin(115200);
 
   // Wait for the TFT panel to initialize and finish the animation
   safe_delay(1000);
 
   // There are different panels for the Chiron with slightly different commands
   // So we need to know what we are working with.

commit 049cfe659c8e4af282c50169ebbed98638a013fa
Author: Bart Meijer <brupje@gmail.com>
Date:   Mon Dec 12 22:36:50 2022 +0100

    ‚ú® SAMD21 HAL / Minitronics v2.0 (#24976)

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index 4be023df0a..285729cc15 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -65,20 +65,31 @@ void ChironTFT::Startup() {
   panel_command[0]  = '\0';
   command_len       = 0;
   last_error        = AC_error_none;
   printer_state     = AC_printer_idle;
   pause_state       = AC_paused_idle;
   hotend_state      = AC_heater_off;
   hotbed_state      = AC_heater_off;
   live_Zoffset      = 0.0;
   file_menu         = AC_menu_file;
 
+  // Setup pins for powerloss detection
+  // Two IO pins are connected on the Trigorilla Board
+  // On a power interruption the OUTAGECON_PIN goes low.
+
+  #if ENABLED(POWER_LOSS_RECOVERY)
+    OUT_WRITE(OUTAGECON_PIN, HIGH);
+  #endif
+
+  // Filament runout is handled by Marlin settings in Configuration.h
+  // opt_set    FIL_RUNOUT_STATE HIGH  // Pin state indicating that filament is NOT present.
+  // opt_enable FIL_RUNOUT_PULLUP
   TFTSer.begin(115200);
 
   // Wait for the TFT panel to initialize and finish the animation
   safe_delay(1000);
 
   // There are different panels for the Chiron with slightly different commands
   // So we need to know what we are working with.
   // Panel type can be defined otherwise detect it automatically
   switch (panel_type) {
     case AC_panel_new:

commit 739556905575e967e10b1e164ae549be28772964
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Nov 11 20:35:07 2022 -0600

    üêõ Fix Anycubic / Trigorilla pins, etc. (#24971)

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index 285729cc15..4be023df0a 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -65,31 +65,20 @@ void ChironTFT::Startup() {
   panel_command[0]  = '\0';
   command_len       = 0;
   last_error        = AC_error_none;
   printer_state     = AC_printer_idle;
   pause_state       = AC_paused_idle;
   hotend_state      = AC_heater_off;
   hotbed_state      = AC_heater_off;
   live_Zoffset      = 0.0;
   file_menu         = AC_menu_file;
 
-  // Setup pins for powerloss detection
-  // Two IO pins are connected on the Trigorilla Board
-  // On a power interruption the OUTAGECON_PIN goes low.
-
-  #if ENABLED(POWER_LOSS_RECOVERY)
-    OUT_WRITE(OUTAGECON_PIN, HIGH);
-  #endif
-
-  // Filament runout is handled by Marlin settings in Configuration.h
-  // opt_set    FIL_RUNOUT_STATE HIGH  // Pin state indicating that filament is NOT present.
-  // opt_enable FIL_RUNOUT_PULLUP
   TFTSer.begin(115200);
 
   // Wait for the TFT panel to initialize and finish the animation
   safe_delay(1000);
 
   // There are different panels for the Chiron with slightly different commands
   // So we need to know what we are working with.
   // Panel type can be defined otherwise detect it automatically
   switch (panel_type) {
     case AC_panel_new:

commit 58ce5182c2ea93e79ccaef4c912c68aa554e637e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 31 12:43:44 2022 -0500

    üé® Fix spelling, whitespace

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index 7561c89d79..285729cc15 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -701,21 +701,21 @@ void ChironTFT::PanelAction(uint8_t req) {
           case 'C': injectCommands_P(G28_STR); break;
         }
       }
       break;
 
     case 22: {   // A22 Move Axis
       // The commands have changed on the new panel
       // Old TFT A22 X -1F1500      A22 X +1F1500
       // New TFT A22 X-1.0 F1500    A22 X1.0 F1500
 
-      // lets just wrap this in a gcode relative nonprint move and let the controller deal with it
+      // Send a G-code-relative non-print move and let the controller deal with it
       // G91 G0 <panel command> G90
 
       if (!isPrinting()) { // Ignore request if printing
         char MoveCmnd[30];
         sprintf_P(MoveCmnd, PSTR("G91\nG0%s\nG90"), panel_command + 3);
         #if ACDEBUG(AC_ACTION)
           SERIAL_ECHOLNPGM("Move: ", MoveCmnd);
         #endif
         setSoftEndstopState(true);  // enable endstops
         injectCommands(MoveCmnd);

commit 72b2e2b2c7230245dea9fcb46b9b8a92bcb11bcc
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Fri Apr 1 08:14:14 2022 +0100

    ‚öóÔ∏è Temperature Model Predictive Control (#23751)

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index fa85de2a8e..7561c89d79 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -78,21 +78,21 @@ void ChironTFT::Startup() {
 
   #if ENABLED(POWER_LOSS_RECOVERY)
     OUT_WRITE(OUTAGECON_PIN, HIGH);
   #endif
 
   // Filament runout is handled by Marlin settings in Configuration.h
   // opt_set    FIL_RUNOUT_STATE HIGH  // Pin state indicating that filament is NOT present.
   // opt_enable FIL_RUNOUT_PULLUP
   TFTSer.begin(115200);
 
-  // wait for the TFT panel to initialise and finish the animation
+  // Wait for the TFT panel to initialize and finish the animation
   safe_delay(1000);
 
   // There are different panels for the Chiron with slightly different commands
   // So we need to know what we are working with.
   // Panel type can be defined otherwise detect it automatically
   switch (panel_type) {
     case AC_panel_new:
       SERIAL_ECHOLNF(AC_msg_new_panel_set);
       break;
     case AC_panel_standard:

commit 9c9300ff9dfa3f6b16c9a87be6ff1136ccc7e880
Author: Nick <nick@n-wells.co.uk>
Date:   Sat Mar 12 23:47:47 2022 +0000

    üêõ Fix Chiron new TFT SD print after reset (#23855)

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index fac0615cd6..fa85de2a8e 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -435,21 +435,21 @@ void ChironTFT::SendFileList(int8_t startindex) {
   // Respond to panel request for 4 files starting at index
   #if ACDEBUG(AC_INFO)
     SERIAL_ECHOLNPGM("## SendFileList ## ", startindex);
   #endif
   SendtoTFTLN(F("FN "));
   filenavigator.getFiles(startindex, panel_type, 4);
   SendtoTFTLN(F("END"));
 }
 
 void ChironTFT::SelectFile() {
-  if (panel_type == AC_panel_new) {
+  if (panel_type <= AC_panel_new) {
     strncpy(selectedfile, panel_command + 4, command_len - 3);
     selectedfile[command_len - 4] = '\0';
   }
   else {
     strncpy(selectedfile, panel_command + 4, command_len - 4);
     selectedfile[command_len - 5] = '\0';
   }
   #if ACDEBUG(AC_FILE)
     SERIAL_ECHOLNPGM(" Selected File: ",selectedfile);
   #endif
@@ -458,60 +458,62 @@ void ChironTFT::SelectFile() {
       SendtoTFTLN(AC_msg_sd_file_open_success);
       break;
 
     case '<':   // .. (go up folder level)
       filenavigator.upDIR();
       SendtoTFTLN(AC_msg_sd_file_open_failed);
       SendFileList( 0 );
       break;
     default:   // enter sub folder
       // for new panel remove the '.GCO' tag that was added to the end of the path
-      if (panel_type == AC_panel_new)
+      if (panel_type <= AC_panel_new)
         selectedfile[strlen(selectedfile) - 4] = '\0';
       filenavigator.changeDIR(selectedfile);
       SendtoTFTLN(AC_msg_sd_file_open_failed);
       SendFileList( 0 );
       break;
   }
 }
 
 void ChironTFT::ProcessPanelRequest() {
   // Break these up into logical blocks // as its easier to navigate than one huge switch case!
   int8_t tpos = FindToken('A');
   // Panel request are 'A0' - 'A36'
-  if (tpos != -1) {
-    const int8_t req = atoi(&panel_command[tpos+1]);
+  if (tpos >= 0) {
+    const int8_t req = atoi(&panel_command[tpos + 1]);
 
     // Information requests A0 - A8 and A33
     if (req <= 8 || req == 33) PanelInfo(req);
 
     // Simple Actions A9 - A28
     else if (req <= 28) PanelAction(req);
 
     // Process Initiation
     else if (req <= 36) PanelProcess(req);
   }
   else {
     #if AUTO_DETECT_CHIRON_TFT
       // This may be a response to a panel type detection query
       if (panel_type == AC_panel_unknown) {
         tpos = FindToken('S'); // old panel will respond to 'SIZE' with 'SXY 480 320'
-        if (tpos != -1) {
-          if (panel_command[tpos+1]== 'X' && panel_command[tpos+2]=='Y') {
+        if (tpos >= 0) {
+          if (panel_command[tpos + 1] == 'X' && panel_command[tpos + 2] =='Y') {
             panel_type = AC_panel_standard;
             SERIAL_ECHOLNF(AC_msg_old_panel_detected);
           }
         }
         else {
-          tpos = FindToken('['); // new panel will respond to 'J200' with '[0]=0'
-          if (tpos != -1) {
-            if (panel_command[tpos+1]== '0' && panel_command[tpos+2]==']') {
+          // new panel will respond to 'J200' with '[0]=0'
+          // it seems only after a power cycle so detection assumes a new panel
+          tpos = FindToken('[');
+          if (tpos >= 0) {
+            if (panel_command[tpos + 1] == '0' && panel_command[tpos + 2] ==']') {
               panel_type = AC_panel_new;
               SERIAL_ECHOLNF(AC_msg_new_panel_detected);
             }
           }
         }
         return;
       }
     #endif
 
     SendtoTFTLN(); // Ignore unknown requests
@@ -804,69 +806,69 @@ void ChironTFT::PanelProcess(uint8_t req) {
               SERIAL_ECHOLNPGM("Current Z: ", getAxisPosition_mm(Z));
             #endif
           }
         }
         selectedmeshpoint.x = pos.x;
         selectedmeshpoint.y = pos.y;
       }
     } break;
 
     case 30:     // A30 Auto leveling
-      if (FindToken('S') != -1) { // Start probing New panel adds spaces..
+      if (FindToken('S') >= 0) { // Start probing New panel adds spaces..
         // Ignore request if printing
         if (isPrinting())
           SendtoTFTLN(AC_msg_probing_not_allowed); // forbid auto leveling
         else {
           SendtoTFTLN(AC_msg_start_probing);
           injectCommands(F("G28\nG29"));
           printer_state = AC_printer_probing;
         }
       }
       else
         SendtoTFTLN(AC_msg_start_probing); // Just enter levelling menu
       break;
 
     case 31:   // A31 Adjust all Probe Points
       // The tokens can occur in different places on the new panel so we need to find it.
 
-      if (FindToken('C') != -1) { // Restore and apply original offsets
+      if (FindToken('C') >= 0) { // Restore and apply original offsets
         if (!isPrinting()) {
           injectCommands(F("M501\nM420 S1"));
           selectedmeshpoint.x = selectedmeshpoint.y = 99;
           SERIAL_ECHOLNF(AC_msg_mesh_changes_abandoned);
         }
       }
 
-      else if (FindToken('D') != -1) { // Save Z Offset tables and restore leveling state
+      else if (FindToken('D') >= 0) { // Save Z Offset tables and restore leveling state
         if (!isPrinting()) {
           setAxisPosition_mm(1.0,Z); // Lift nozzle before any further movements are made
           injectCommands(F("M500"));
           SERIAL_ECHOLNF(AC_msg_mesh_changes_saved);
           selectedmeshpoint.x = selectedmeshpoint.y = 99;
         }
       }
 
-      else if (FindToken('G') != -1) { // Get current offset
+      else if (FindToken('G') >= 0) { // Get current offset
         SendtoTFT(F("A31V "));
         // When printing use the live z Offset position
         // we will use babystepping to move the print head
         if (isPrinting())
           TFTSer.println(live_Zoffset);
         else {
           TFTSer.println(getZOffset_mm());
           selectedmeshpoint.x = selectedmeshpoint.y = 99;
         }
       }
 
       else {
         int8_t tokenpos = FindToken('S');
-        if (tokenpos != -1) { // Set offset (adjusts all points by value)
+        if (tokenpos >= 0) { // Set offset (adjusts all points by value)
           float Zshift = atof(&panel_command[tokenpos+1]);
           setSoftEndstopState(false);  // disable endstops
           // Allow temporary Z position nudging during print
           // From the leveling panel use the all points UI to adjust the print pos.
           if (isPrinting()) {
             #if ACDEBUG(AC_INFO)
               SERIAL_ECHOLNPGM("Change Zoffset from:", live_Zoffset, " to ", live_Zoffset + Zshift);
             #endif
             if (isAxisPositionKnown(Z)) {
               #if ACDEBUG(AC_INFO)

commit 623c6b720b0d9b14934fb8ccb895d421ab043cc9
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 12 15:58:28 2022 -0600

    üßë‚Äçüíª Add ExtUI::onLevelingDone, match DWIN to ExtUI

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index c56d8aa7fb..fac0615cd6 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -79,27 +79,37 @@ void ChironTFT::Startup() {
   #if ENABLED(POWER_LOSS_RECOVERY)
     OUT_WRITE(OUTAGECON_PIN, HIGH);
   #endif
 
   // Filament runout is handled by Marlin settings in Configuration.h
   // opt_set    FIL_RUNOUT_STATE HIGH  // Pin state indicating that filament is NOT present.
   // opt_enable FIL_RUNOUT_PULLUP
   TFTSer.begin(115200);
 
   // wait for the TFT panel to initialise and finish the animation
-  delay_ms(250);
+  safe_delay(1000);
 
   // There are different panels for the Chiron with slightly different commands
   // So we need to know what we are working with.
-
   // Panel type can be defined otherwise detect it automatically
-  if (panel_type == AC_panel_unknown) DetectPanelType();
+  switch (panel_type) {
+    case AC_panel_new:
+      SERIAL_ECHOLNF(AC_msg_new_panel_set);
+      break;
+    case AC_panel_standard:
+      SERIAL_ECHOLNF(AC_msg_old_panel_set);
+      break;
+    default:
+      SERIAL_ECHOLNF(AC_msg_auto_panel_detection);
+      DetectPanelType();
+      break;
+  }
 
   // Signal Board has reset
   SendtoTFTLN(AC_msg_main_board_has_reset);
 
   // Enable leveling and Disable end stops during print
   // as Z home places nozzle above the bed so we need to allow it past the end stops
   injectCommands(AC_cmnd_enable_leveling);
 
   // Startup tunes are defined in Tunes.h
   PlayTune(BEEPER_PIN, TERN(AC_DEFAULT_STARTUP_TUNE, Anycubic_PowerOn, GB_PowerOn), 1);
@@ -351,29 +361,28 @@ bool ChironTFT::ReadTFTCommand() {
     panel_command[command_len] = '\0';
     #if ACDEBUG(AC_ALL)
       SERIAL_ECHOLNPGM("len(",command_len,") < ", panel_command);
     #endif
     command_ready = true;
   }
   return command_ready;
 }
 
 int8_t ChironTFT::FindToken(char c) {
-  int8_t pos = 0;
-  do {
+  for (int8_t pos = 0; pos < command_len; pos++) {
     if (panel_command[pos] == c) {
       #if ACDEBUG(AC_INFO)
         SERIAL_ECHOLNPGM("Tpos:", pos, " ", c);
       #endif
       return pos;
     }
-  } while (++pos < command_len);
+  }
   #if ACDEBUG(AC_INFO)
     SERIAL_ECHOLNPGM("Not found: ", c);
   #endif
   return -1;
 }
 
 void ChironTFT::CheckHeaters() {
   uint8_t faultDuration = 0;
 
   // if the hotend temp is abnormal, confirm state before signalling panel
@@ -616,32 +625,32 @@ void ChironTFT::PanelAction(uint8_t req) {
       break;
 
     case 12:   // A12 Kill printer
       kill();  // from marlincore.h
       break;
 
     case 13:   // A13 Select file
       SelectFile();
       break;
 
-    case 14: { // A14 Start Printing
+    case 14:   // A14 Start Printing
       // Allows printer to restart the job if we don't want to recover
       if (printer_state == AC_printer_resuming_from_power_outage) {
         injectCommands(F("M1000 C")); // Cancel recovery
         printer_state = AC_printer_idle;
       }
       #if ACDebugLevel >= 1
-        SERIAL_ECHOLNPAIR_F("Print: ", selectedfile);
+        SERIAL_ECHOLNPGM("Print: ", selectedfile);
       #endif
       printFile(selectedfile);
       SendtoTFTLN(AC_msg_print_from_sd_card);
-    } break;
+      break;
 
     case 15:   // A15 Resuming from outage
       if (printer_state == AC_printer_resuming_from_power_outage) {
         // Need to home here to restore the Z position
         injectCommands(AC_cmnd_power_loss_recovery);
         injectCommands(F("M1000"));  // home and start recovery
       }
       break;
 
     case 16: { // A16 Set HotEnd temp  A17 S170
@@ -794,39 +803,36 @@ void ChironTFT::PanelProcess(uint8_t req) {
             #if ACDEBUG(AC_INFO)
               SERIAL_ECHOLNPGM("Current Z: ", getAxisPosition_mm(Z));
             #endif
           }
         }
         selectedmeshpoint.x = pos.x;
         selectedmeshpoint.y = pos.y;
       }
     } break;
 
-    case 30: {   // A30 Auto leveling
+    case 30:     // A30 Auto leveling
       if (FindToken('S') != -1) { // Start probing New panel adds spaces..
         // Ignore request if printing
         if (isPrinting())
           SendtoTFTLN(AC_msg_probing_not_allowed); // forbid auto leveling
         else {
-
-
           SendtoTFTLN(AC_msg_start_probing);
           injectCommands(F("G28\nG29"));
           printer_state = AC_printer_probing;
         }
       }
-      else {
+      else
         SendtoTFTLN(AC_msg_start_probing); // Just enter levelling menu
-      }
-    } break;
+      break;
 
-    case 31: { // A31 Adjust all Probe Points
+    case 31:   // A31 Adjust all Probe Points
       // The tokens can occur in different places on the new panel so we need to find it.
 
       if (FindToken('C') != -1) { // Restore and apply original offsets
         if (!isPrinting()) {
           injectCommands(F("M501\nM420 S1"));
           selectedmeshpoint.x = selectedmeshpoint.y = 99;
           SERIAL_ECHOLNF(AC_msg_mesh_changes_abandoned);
         }
       }
 
@@ -900,32 +906,32 @@ void ChironTFT::PanelProcess(uint8_t req) {
               // Move Z axis
               const float currZpos = getAxisPosition_mm(Z);
               #if ACDEBUG(AC_INFO)
                 SERIAL_ECHOLNPGM("Move Z pos from ", currZpos, " to ", currZpos + constrain(Zshift, -0.05, 0.05));
               #endif
               setAxisPosition_mm(currZpos+constrain(Zshift,-0.05,0.05),Z);
             }
           }
         }
       }
-    } break;
+      break;
 
-    case 32: { // A32 clean leveling beep flag
+    case 32:   // A32 clean leveling beep flag
       // Ignore request if printing
       //if (isPrinting()) break;
       //injectCommands(F("M500\nM420 S1\nG1 Z10 F240\nG1 X0 Y0 F6000"));
       //TFTSer.println();
-    } break;
+      break;
 
     // A33 firmware info request see PanelInfo()
 
-    case 34: {  // A34 Adjust single mesh point A34 C/S X1 Y1 V123
+    case 34:    // A34 Adjust single mesh point A34 C/S X1 Y1 V123
       if (panel_command[3] == 'C') { // Restore original offsets
         injectCommands(F("M501\nM420 S1"));
         selectedmeshpoint.x = selectedmeshpoint.y = 99;
         //printer_state = AC_printer_idle;
       }
       else {
         xy_uint8_t pos;
         pos.x = atoi(&panel_command[5]);
         pos.y = atoi(&panel_command[8]);
 
@@ -943,21 +949,21 @@ void ChironTFT::PanelProcess(uint8_t req) {
           if (selectedmeshpoint.x == pos.x && selectedmeshpoint.y == pos.y) {
             setSoftEndstopState(false);
             float currZpos = getAxisPosition_mm(Z);
             #if ACDEBUG(AC_INFO)
               SERIAL_ECHOLNPGM("Move Z pos from ", currZpos, " to ", currZpos + constrain(newval - currmesh, -0.05, 0.05));
             #endif
             setAxisPosition_mm(currZpos + constrain(newval - currmesh, -0.05, 0.05), Z);
           }
         }
       }
-    }  break;
+      break;
 
     case 36:    // A36 Auto leveling for new TFT bet that was a typo in the panel code!
       SendtoTFTLN(AC_msg_start_probing);
       break;
   }
 }
 
 bool ChironTFT::GetLastError() {
   switch (last_error) {
     case AC_error_abnormal_temp_bed: SendtoTFTLN(AC_msg_error_bed_temp);    break;

commit 13ce5aa1ed4ab4f8fc01f7ff6f7ad7884fc28ea9
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Dec 21 22:15:48 2021 -0600

    üé® Misc. cleanup

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index 6db5972fa7..c56d8aa7fb 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -359,21 +359,21 @@ bool ChironTFT::ReadTFTCommand() {
 
 int8_t ChironTFT::FindToken(char c) {
   int8_t pos = 0;
   do {
     if (panel_command[pos] == c) {
       #if ACDEBUG(AC_INFO)
         SERIAL_ECHOLNPGM("Tpos:", pos, " ", c);
       #endif
       return pos;
     }
-  } while(++pos < command_len);
+  } while (++pos < command_len);
   #if ACDEBUG(AC_INFO)
     SERIAL_ECHOLNPGM("Not found: ", c);
   #endif
   return -1;
 }
 
 void ChironTFT::CheckHeaters() {
   uint8_t faultDuration = 0;
 
   // if the hotend temp is abnormal, confirm state before signalling panel

commit 7762df7251f1da3be2933670084b416d4a06c89f
Author: EvilGremlin <22657714+EvilGremlin@users.noreply.github.com>
Date:   Sun Dec 26 09:46:13 2021 +0300

    üîß Check Chiron LCD requirements (#23353)
    
    Co-Authored-By: EvilGremlin <22657714+EvilGremlin@users.noreply.github.com>

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index 9f558e3a98..6db5972fa7 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -236,21 +236,21 @@ void ChironTFT::StatusChange(const char * const msg)  {
     SERIAL_ECHOLNPGM("StatusChange() ", msg);
     SERIAL_ECHOLNPGM("printer_state:", printer_state);
   #endif
   bool msg_matched = false;
   // The only way to get printer status is to parse messages
   // Use the state to minimise the work we do here.
   switch (printer_state) {
     case AC_printer_probing: {
       // If probing completes ok save the mesh and park
       // Ignore the custom machine name
-      if (strcmp_P(msg + strlen(CUSTOM_MACHINE_NAME), MARLIN_msg_ready) == 0) {
+      if (strcmp_P(msg + strlen(MACHINE_NAME), MARLIN_msg_ready) == 0) {
         injectCommands(F("M500\nG27"));
         SendtoTFTLN(AC_msg_probing_complete);
         printer_state = AC_printer_idle;
         msg_matched = true;
       }
       // If probing fails don't save the mesh raise the probe above the bad point
       if (strcmp_P(msg, MARLIN_msg_probing_failed) == 0) {
         PlayTune(BEEPER_PIN, BeepBeepBeeep, 1);
         injectCommands(F("G1 Z50 F500"));
         SendtoTFTLN(AC_msg_probing_complete);

commit e8459ae63c8290123827b4e45bbe051c95060783
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Oct 4 19:50:14 2021 -0500

    üêõ ExtUI F() followups
    
    Followup to 12b5d997a2

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index c3fc6aa96e..9f558e3a98 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -308,29 +308,29 @@ void ChironTFT::PowerLossRecovery()  {
   PlayTune(BEEPER_PIN, SOS, 1);
   SERIAL_ECHOLNF(AC_msg_powerloss_recovery);
 }
 
 void ChironTFT::PrintComplete() {
   SendtoTFT(AC_msg_print_complete);
   printer_state = AC_printer_idle;
   setSoftEndstopState(true); // enable endstops
 }
 
-void ChironTFT::SendtoTFT(FSTR_P const fstr) {  // A helper to print PROGMEM string to the panel
+void ChironTFT::SendtoTFT(FSTR_P const fstr/*=nullptr*/) {  // A helper to print PROGMEM string to the panel
   #if ACDEBUG(AC_SOME)
     SERIAL_ECHOF(fstr);
   #endif
   PGM_P str = FTOP(fstr);
   while (const char c = pgm_read_byte(str++)) TFTSer.write(c);
 }
 
-void ChironTFT::SendtoTFTLN(FSTR_P const fstr) {
+void ChironTFT::SendtoTFTLN(FSTR_P const fstr/*=nullptr*/) {
   if (fstr) {
     #if ACDEBUG(AC_SOME)
       SERIAL_ECHOPGM("> ");
     #endif
     SendtoTFT(fstr);
     #if ACDEBUG(AC_SOME)
       SERIAL_EOL();
     #endif
   }
   TFTSer.println();

commit 65b950a489c35b1d5547da3a504af4dad8cde3d7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 28 20:15:52 2021 -0500

    üé® Apply F() to kill / sendinfoscreen

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index 483da200e8..c3fc6aa96e 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -119,21 +119,21 @@ void ChironTFT::DetectPanelType() {
 }
 
 void ChironTFT::IdleLoop()  {
   if (ReadTFTCommand()) {
     ProcessPanelRequest();
     command_len = 0;
   }
   CheckHeaters();
 }
 
-void ChironTFT::PrinterKilled(PGM_P error,PGM_P component)  {
+void ChironTFT::PrinterKilled(FSTR_P const error, FSTR_P const component)  {
   SendtoTFTLN(AC_msg_kill_lcd);
   #if ACDEBUG(AC_MARLIN)
     SERIAL_ECHOLNPGM("PrinterKilled()\nerror: ", error , "\ncomponent: ", component);
   #endif
 }
 
 void ChironTFT::MediaEvent(media_event_t event)  {
   #if ACDEBUG(AC_MARLIN)
     SERIAL_ECHOLNPGM("ProcessMediaStatus() ", event);
   #endif

commit 12b5d997a2cee538e5026a68f8e0cfdd53248986
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Sep 25 22:11:48 2021 -0500

    üé® Apply F() to some ExtUI functions

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index e7b3941928..483da200e8 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -92,21 +92,21 @@ void ChironTFT::Startup() {
   // So we need to know what we are working with.
 
   // Panel type can be defined otherwise detect it automatically
   if (panel_type == AC_panel_unknown) DetectPanelType();
 
   // Signal Board has reset
   SendtoTFTLN(AC_msg_main_board_has_reset);
 
   // Enable leveling and Disable end stops during print
   // as Z home places nozzle above the bed so we need to allow it past the end stops
-  injectCommands_P(AC_cmnd_enable_leveling);
+  injectCommands(AC_cmnd_enable_leveling);
 
   // Startup tunes are defined in Tunes.h
   PlayTune(BEEPER_PIN, TERN(AC_DEFAULT_STARTUP_TUNE, Anycubic_PowerOn, GB_PowerOn), 1);
 
   #if ACDEBUGLEVEL
     SERIAL_ECHOLNPGM("AC Debug Level ", ACDEBUGLEVEL);
   #endif
   SendtoTFTLN(AC_msg_ready);
 }
 
@@ -237,29 +237,29 @@ void ChironTFT::StatusChange(const char * const msg)  {
     SERIAL_ECHOLNPGM("printer_state:", printer_state);
   #endif
   bool msg_matched = false;
   // The only way to get printer status is to parse messages
   // Use the state to minimise the work we do here.
   switch (printer_state) {
     case AC_printer_probing: {
       // If probing completes ok save the mesh and park
       // Ignore the custom machine name
       if (strcmp_P(msg + strlen(CUSTOM_MACHINE_NAME), MARLIN_msg_ready) == 0) {
-        injectCommands_P(PSTR("M500\nG27"));
+        injectCommands(F("M500\nG27"));
         SendtoTFTLN(AC_msg_probing_complete);
         printer_state = AC_printer_idle;
         msg_matched = true;
       }
       // If probing fails don't save the mesh raise the probe above the bad point
       if (strcmp_P(msg, MARLIN_msg_probing_failed) == 0) {
         PlayTune(BEEPER_PIN, BeepBeepBeeep, 1);
-        injectCommands_P(PSTR("G1 Z50 F500"));
+        injectCommands(F("G1 Z50 F500"));
         SendtoTFTLN(AC_msg_probing_complete);
         printer_state = AC_printer_idle;
         msg_matched = true;
       }
     } break;
 
     case AC_printer_printing: {
       if (strcmp_P(msg, MARLIN_msg_reheating) == 0) {
         SendtoTFTLN(AC_msg_paused); // enable continue button
         msg_matched = true;
@@ -308,33 +308,34 @@ void ChironTFT::PowerLossRecovery()  {
   PlayTune(BEEPER_PIN, SOS, 1);
   SERIAL_ECHOLNF(AC_msg_powerloss_recovery);
 }
 
 void ChironTFT::PrintComplete() {
   SendtoTFT(AC_msg_print_complete);
   printer_state = AC_printer_idle;
   setSoftEndstopState(true); // enable endstops
 }
 
-void ChironTFT::SendtoTFT(PGM_P str) {  // A helper to print PROGMEM string to the panel
+void ChironTFT::SendtoTFT(FSTR_P const fstr) {  // A helper to print PROGMEM string to the panel
   #if ACDEBUG(AC_SOME)
-    SERIAL_ECHOPGM_P(str);
+    SERIAL_ECHOF(fstr);
   #endif
+  PGM_P str = FTOP(fstr);
   while (const char c = pgm_read_byte(str++)) TFTSer.write(c);
 }
 
-void ChironTFT::SendtoTFTLN(PGM_P str = nullptr) {
-  if (str) {
+void ChironTFT::SendtoTFTLN(FSTR_P const fstr) {
+  if (fstr) {
     #if ACDEBUG(AC_SOME)
       SERIAL_ECHOPGM("> ");
     #endif
-    SendtoTFT(str);
+    SendtoTFT(fstr);
     #if ACDEBUG(AC_SOME)
       SERIAL_EOL();
     #endif
   }
   TFTSer.println();
 }
 
 bool ChironTFT::ReadTFTCommand() {
   bool command_ready = false;
   while (TFTSer.available() > 0 && command_len < MAX_CMND_LEN) {
@@ -419,23 +420,23 @@ void ChironTFT::CheckHeaters() {
       hotbed_state = AC_heater_temp_reached;
     }
   }
 }
 
 void ChironTFT::SendFileList(int8_t startindex) {
   // Respond to panel request for 4 files starting at index
   #if ACDEBUG(AC_INFO)
     SERIAL_ECHOLNPGM("## SendFileList ## ", startindex);
   #endif
-  SendtoTFTLN(PSTR("FN "));
+  SendtoTFTLN(F("FN "));
   filenavigator.getFiles(startindex, panel_type, 4);
-  SendtoTFTLN(PSTR("END"));
+  SendtoTFTLN(F("END"));
 }
 
 void ChironTFT::SelectFile() {
   if (panel_type == AC_panel_new) {
     strncpy(selectedfile, panel_command + 4, command_len - 3);
     selectedfile[command_len - 4] = '\0';
   }
   else {
     strncpy(selectedfile, panel_command + 4, command_len - 4);
     selectedfile[command_len - 5] = '\0';
@@ -505,86 +506,86 @@ void ChironTFT::ProcessPanelRequest() {
     #endif
 
     SendtoTFTLN(); // Ignore unknown requests
   }
 }
 
 void ChironTFT::PanelInfo(uint8_t req) {
   // information requests A0-A8 and A33
   switch (req) {
     case 0:   // A0 Get HOTEND Temp
-      SendtoTFT(PSTR("A0V "));
+      SendtoTFT(F("A0V "));
       TFTSer.println(getActualTemp_celsius(E0));
       break;
 
     case 1:   // A1 Get HOTEND Target Temp
-      SendtoTFT(PSTR("A1V "));
+      SendtoTFT(F("A1V "));
       TFTSer.println(getTargetTemp_celsius(E0));
       break;
 
     case 2:   // A2 Get BED Temp
-      SendtoTFT(PSTR("A2V "));
+      SendtoTFT(F("A2V "));
       TFTSer.println(getActualTemp_celsius(BED));
       break;
 
     case 3:   // A3 Get BED Target Temp
-      SendtoTFT(PSTR("A3V "));
+      SendtoTFT(F("A3V "));
       TFTSer.println(getTargetTemp_celsius(BED));
       break;
 
     case 4:   // A4 Get FAN Speed
-      SendtoTFT(PSTR("A4V "));
+      SendtoTFT(F("A4V "));
       TFTSer.println(getActualFan_percent(FAN0));
       break;
 
     case 5:   // A5 Get Current Coordinates
-      SendtoTFT(PSTR("A5V X: "));
+      SendtoTFT(F("A5V X: "));
       TFTSer.print(getAxisPosition_mm(X));
-      SendtoTFT(PSTR(" Y: "));
+      SendtoTFT(F(" Y: "));
       TFTSer.print(getAxisPosition_mm(Y));
-      SendtoTFT(PSTR(" Z: "));
+      SendtoTFT(F(" Z: "));
       TFTSer.println(getAxisPosition_mm(Z));
       break;
 
     case 6:   // A6 Get printing progress
       if (isPrintingFromMedia()) {
-        SendtoTFT(PSTR("A6V "));
+        SendtoTFT(F("A6V "));
         TFTSer.println(ui8tostr2(getProgress_percent()));
       }
       else
-        SendtoTFTLN(PSTR("A6V ---"));
+        SendtoTFTLN(F("A6V ---"));
       break;
 
     case 7: { // A7 Get Printing Time
       uint32_t time = getProgress_seconds_elapsed() / 60;
-      SendtoTFT(PSTR("A7V "));
+      SendtoTFT(F("A7V "));
       TFTSer.print(ui8tostr2(time / 60));
-      SendtoTFT(PSTR(" H "));
+      SendtoTFT(F(" H "));
       TFTSer.print(ui8tostr2(time % 60));
-      SendtoTFT(PSTR(" M"));
+      SendtoTFT(F(" M"));
       #if ACDEBUG(AC_ALL)
         SERIAL_ECHOLNPGM("Print time ", ui8tostr2(time / 60), ":", ui8tostr2(time % 60));
       #endif
     } break;
 
     case 8:   // A8 Get SD Card list A8 S0
       if (!isMediaInserted()) safe_delay(500);
       if (!isMediaInserted())   // Make sure the card is removed
         SendtoTFTLN(AC_msg_no_sd_card);
       else if (panel_command[3] == 'S')
         SendFileList( atoi( &panel_command[4] ) );
       break;
 
     case 33:   // A33 Get firmware info
-      SendtoTFT(PSTR("J33 "));
+      SendtoTFT(F("J33 "));
       // If there is an error recorded, show that instead of the FW version
-      if (!GetLastError()) SendtoTFTLN(PSTR(SHORT_BUILD_VERSION));
+      if (!GetLastError()) SendtoTFTLN(F(SHORT_BUILD_VERSION));
       break;
   }
 }
 
 void ChironTFT::PanelAction(uint8_t req) {
   switch (req) {
     case  9:   // A9 Pause SD print
       if (isPrintingFromMedia()) {
         SendtoTFTLN(AC_msg_pause);
         pausePrint();
@@ -601,52 +602,52 @@ void ChironTFT::PanelAction(uint8_t req) {
         setUserConfirmed();
       break;
 
     case 11:   // A11 Stop SD print
       if (isPrintingFromMedia()) {
         printer_state = AC_printer_stopping;
         stopPrint();
       }
       else {
         if (printer_state == AC_printer_resuming_from_power_outage)
-          injectCommands_P(PSTR("M1000 C")); // Cancel recovery
+          injectCommands(F("M1000 C")); // Cancel recovery
         SendtoTFTLN(AC_msg_stop);
         printer_state = AC_printer_idle;
       }
       break;
 
     case 12:   // A12 Kill printer
       kill();  // from marlincore.h
       break;
 
     case 13:   // A13 Select file
       SelectFile();
       break;
 
     case 14: { // A14 Start Printing
       // Allows printer to restart the job if we don't want to recover
       if (printer_state == AC_printer_resuming_from_power_outage) {
-        injectCommands_P(PSTR("M1000 C")); // Cancel recovery
+        injectCommands(F("M1000 C")); // Cancel recovery
         printer_state = AC_printer_idle;
       }
       #if ACDebugLevel >= 1
         SERIAL_ECHOLNPAIR_F("Print: ", selectedfile);
       #endif
       printFile(selectedfile);
       SendtoTFTLN(AC_msg_print_from_sd_card);
     } break;
 
     case 15:   // A15 Resuming from outage
       if (printer_state == AC_printer_resuming_from_power_outage) {
         // Need to home here to restore the Z position
-        injectCommands_P(AC_cmnd_power_loss_recovery);
-        injectCommands_P(PSTR("M1000"));  // home and start recovery
+        injectCommands(AC_cmnd_power_loss_recovery);
+        injectCommands(F("M1000"));  // home and start recovery
       }
       break;
 
     case 16: { // A16 Set HotEnd temp  A17 S170
       const float set_Htemp = atof(&panel_command[5]);
       hotend_state = set_Htemp ? AC_heater_temp_set : AC_heater_off;
       switch ((char)panel_command[4]) {
         // Set Temp
         case 'S': case 'C': setTargetTemp_celsius(set_Htemp, E0);
       }
@@ -668,31 +669,31 @@ void ChironTFT::PanelAction(uint8_t req) {
       if (!isPrinting()) {
         stepper.disable_all_steppers();
         SendtoTFTLN(AC_msg_ready);
       }
       break;
 
     case 20:   // A20 Read/write print speed
       if (panel_command[4] == 'S')
         setFeedrate_percent(atoi(&panel_command[5]));
       else {
-        SendtoTFT(PSTR("A20V "));
+        SendtoTFT(F("A20V "));
         TFTSer.println(getFeedrate_percent());
       }
       break;
 
     case 21:   // A21 Home Axis  A21 X
       if (!isPrinting()) {
         switch ((char)panel_command[4]) {
-          case 'X': injectCommands_P(PSTR("G28X")); break;
-          case 'Y': injectCommands_P(PSTR("G28Y")); break;
-          case 'Z': injectCommands_P(PSTR("G28Z")); break;
+          case 'X': injectCommands(F("G28X")); break;
+          case 'Y': injectCommands(F("G28Y")); break;
+          case 'Z': injectCommands(F("G28Z")); break;
           case 'C': injectCommands_P(G28_STR); break;
         }
       }
       break;
 
     case 22: {   // A22 Move Axis
       // The commands have changed on the new panel
       // Old TFT A22 X -1F1500      A22 X +1F1500
       // New TFT A22 X-1.0 F1500    A22 X1.0 F1500
 
@@ -764,21 +765,21 @@ void ChironTFT::PanelAction(uint8_t req) {
 
 void ChironTFT::PanelProcess(uint8_t req) {
   switch (req) {
     case 29: { // A29 Read Mesh Point A29 X1 Y1
       xy_uint8_t pos;
       float pos_z;
       pos.x = atoi(&panel_command[FindToken('X')+1]);
       pos.y = atoi(&panel_command[FindToken('Y')+1]);
       pos_z = getMeshPoint(pos);
 
-      SendtoTFT(PSTR("A29V "));
+      SendtoTFT(F("A29V "));
       TFTSer.println(pos_z * 100);
       if (!isPrinting()) {
         setSoftEndstopState(true);  // disable endstops
         // If the same meshpoint is selected twice in a row, move the head to that ready for adjustment
         if ((selectedmeshpoint.x == pos.x) && (selectedmeshpoint.y == pos.y)) {
           if (!isPositionKnown())
             injectCommands_P(G28_STR); // home
 
           if (isPositionKnown()) {
             #if ACDEBUG(AC_INFO)
@@ -802,51 +803,51 @@ void ChironTFT::PanelProcess(uint8_t req) {
 
     case 30: {   // A30 Auto leveling
       if (FindToken('S') != -1) { // Start probing New panel adds spaces..
         // Ignore request if printing
         if (isPrinting())
           SendtoTFTLN(AC_msg_probing_not_allowed); // forbid auto leveling
         else {
 
 
           SendtoTFTLN(AC_msg_start_probing);
-          injectCommands_P(PSTR("G28\nG29"));
+          injectCommands(F("G28\nG29"));
           printer_state = AC_printer_probing;
         }
       }
       else {
         SendtoTFTLN(AC_msg_start_probing); // Just enter levelling menu
       }
     } break;
 
     case 31: { // A31 Adjust all Probe Points
       // The tokens can occur in different places on the new panel so we need to find it.
 
       if (FindToken('C') != -1) { // Restore and apply original offsets
         if (!isPrinting()) {
-          injectCommands_P(PSTR("M501\nM420 S1"));
+          injectCommands(F("M501\nM420 S1"));
           selectedmeshpoint.x = selectedmeshpoint.y = 99;
           SERIAL_ECHOLNF(AC_msg_mesh_changes_abandoned);
         }
       }
 
       else if (FindToken('D') != -1) { // Save Z Offset tables and restore leveling state
         if (!isPrinting()) {
           setAxisPosition_mm(1.0,Z); // Lift nozzle before any further movements are made
-          injectCommands_P(PSTR("M500"));
+          injectCommands(F("M500"));
           SERIAL_ECHOLNF(AC_msg_mesh_changes_saved);
           selectedmeshpoint.x = selectedmeshpoint.y = 99;
         }
       }
 
       else if (FindToken('G') != -1) { // Get current offset
-        SendtoTFT(PSTR("A31V "));
+        SendtoTFT(F("A31V "));
         // When printing use the live z Offset position
         // we will use babystepping to move the print head
         if (isPrinting())
           TFTSer.println(live_Zoffset);
         else {
           TFTSer.println(getZOffset_mm());
           selectedmeshpoint.x = selectedmeshpoint.y = 99;
         }
       }
 
@@ -867,66 +868,66 @@ void ChironTFT::PanelProcess(uint8_t req) {
                 SERIAL_ECHOLNPGM("Nudge Z pos from ", currZpos, " to ", currZpos + constrain(Zshift, -0.05, 0.05));
               #endif
               // Use babystepping to adjust the head position
               int16_t steps = mmToWholeSteps(constrain(Zshift,-0.05,0.05), Z);
               #if ACDEBUG(AC_INFO)
                 SERIAL_ECHOLNPGM("Steps to move Z: ", steps);
               #endif
               babystepAxis_steps(steps, Z);
               live_Zoffset += Zshift;
             }
-            SendtoTFT(PSTR("A31V "));
+            SendtoTFT(F("A31V "));
             TFTSer.println(live_Zoffset);
           }
           else {
             GRID_LOOP(x, y) {
               const xy_uint8_t pos { x, y };
               const float currval = getMeshPoint(pos);
               setMeshPoint(pos, constrain(currval + Zshift, AC_LOWEST_MESHPOINT_VAL, 2));
               #if ACDEBUG(AC_INFO)
                 SERIAL_ECHOLNPGM("Change mesh point X", x," Y",y ," from ", currval, " to ", getMeshPoint(pos) );
               #endif
             }
             const float currZOffset = getZOffset_mm();
             #if ACDEBUG(AC_INFO)
               SERIAL_ECHOLNPGM("Change probe offset from ", currZOffset, " to  ", currZOffset + Zshift);
             #endif
 
             setZOffset_mm(currZOffset + Zshift);
-            SendtoTFT(PSTR("A31V "));
+            SendtoTFT(F("A31V "));
             TFTSer.println(getZOffset_mm());
 
             if (isAxisPositionKnown(Z)) {
               // Move Z axis
               const float currZpos = getAxisPosition_mm(Z);
               #if ACDEBUG(AC_INFO)
                 SERIAL_ECHOLNPGM("Move Z pos from ", currZpos, " to ", currZpos + constrain(Zshift, -0.05, 0.05));
               #endif
               setAxisPosition_mm(currZpos+constrain(Zshift,-0.05,0.05),Z);
             }
           }
         }
       }
     } break;
 
     case 32: { // A32 clean leveling beep flag
       // Ignore request if printing
       //if (isPrinting()) break;
-      //injectCommands_P(PSTR("M500\nM420 S1\nG1 Z10 F240\nG1 X0 Y0 F6000"));
+      //injectCommands(F("M500\nM420 S1\nG1 Z10 F240\nG1 X0 Y0 F6000"));
       //TFTSer.println();
     } break;
 
     // A33 firmware info request see PanelInfo()
 
     case 34: {  // A34 Adjust single mesh point A34 C/S X1 Y1 V123
       if (panel_command[3] == 'C') { // Restore original offsets
-        injectCommands_P(PSTR("M501\nM420 S1"));
+        injectCommands(F("M501\nM420 S1"));
         selectedmeshpoint.x = selectedmeshpoint.y = 99;
         //printer_state = AC_printer_idle;
       }
       else {
         xy_uint8_t pos;
         pos.x = atoi(&panel_command[5]);
         pos.y = atoi(&panel_command[8]);
 
         float currmesh = getMeshPoint(pos);
         float newval   = atof(&panel_command[11])/100;

commit 520b97083e52efdd47ab434b97823e48d85ade62
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 27 11:03:07 2021 -0500

    üé® Apply F() to serial macros

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index 1b572367f2..e7b3941928 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -299,21 +299,21 @@ void ChironTFT::StatusChange(const char * const msg)  {
     else if (strcmp_P(msg, MARLIN_msg_EEPROM_version) == 0) {
       last_error = AC_error_EEPROM;
     }
   }
 }
 
 void ChironTFT::PowerLossRecovery()  {
   printer_state = AC_printer_resuming_from_power_outage; // Play tune to notify user we can recover.
   last_error = AC_error_powerloss;
   PlayTune(BEEPER_PIN, SOS, 1);
-  SERIAL_ECHOLNPGM_P(AC_msg_powerloss_recovery);
+  SERIAL_ECHOLNF(AC_msg_powerloss_recovery);
 }
 
 void ChironTFT::PrintComplete() {
   SendtoTFT(AC_msg_print_complete);
   printer_state = AC_printer_idle;
   setSoftEndstopState(true); // enable endstops
 }
 
 void ChironTFT::SendtoTFT(PGM_P str) {  // A helper to print PROGMEM string to the panel
   #if ACDEBUG(AC_SOME)
@@ -481,29 +481,29 @@ void ChironTFT::ProcessPanelRequest() {
     else if (req <= 36) PanelProcess(req);
   }
   else {
     #if AUTO_DETECT_CHIRON_TFT
       // This may be a response to a panel type detection query
       if (panel_type == AC_panel_unknown) {
         tpos = FindToken('S'); // old panel will respond to 'SIZE' with 'SXY 480 320'
         if (tpos != -1) {
           if (panel_command[tpos+1]== 'X' && panel_command[tpos+2]=='Y') {
             panel_type = AC_panel_standard;
-            SERIAL_ECHOLNPGM_P(AC_msg_old_panel_detected);
+            SERIAL_ECHOLNF(AC_msg_old_panel_detected);
           }
         }
         else {
           tpos = FindToken('['); // new panel will respond to 'J200' with '[0]=0'
           if (tpos != -1) {
             if (panel_command[tpos+1]== '0' && panel_command[tpos+2]==']') {
               panel_type = AC_panel_new;
-              SERIAL_ECHOLNPGM_P(AC_msg_new_panel_detected);
+              SERIAL_ECHOLNF(AC_msg_new_panel_detected);
             }
           }
         }
         return;
       }
     #endif
 
     SendtoTFTLN(); // Ignore unknown requests
   }
 }
@@ -818,29 +818,29 @@ void ChironTFT::PanelProcess(uint8_t req) {
       }
     } break;
 
     case 31: { // A31 Adjust all Probe Points
       // The tokens can occur in different places on the new panel so we need to find it.
 
       if (FindToken('C') != -1) { // Restore and apply original offsets
         if (!isPrinting()) {
           injectCommands_P(PSTR("M501\nM420 S1"));
           selectedmeshpoint.x = selectedmeshpoint.y = 99;
-          SERIAL_ECHOLNPGM_P(AC_msg_mesh_changes_abandoned);
+          SERIAL_ECHOLNF(AC_msg_mesh_changes_abandoned);
         }
       }
 
       else if (FindToken('D') != -1) { // Save Z Offset tables and restore leveling state
         if (!isPrinting()) {
           setAxisPosition_mm(1.0,Z); // Lift nozzle before any further movements are made
           injectCommands_P(PSTR("M500"));
-          SERIAL_ECHOLNPGM_P(AC_msg_mesh_changes_saved);
+          SERIAL_ECHOLNF(AC_msg_mesh_changes_saved);
           selectedmeshpoint.x = selectedmeshpoint.y = 99;
         }
       }
 
       else if (FindToken('G') != -1) { // Get current offset
         SendtoTFT(PSTR("A31V "));
         // When printing use the live z Offset position
         // we will use babystepping to move the print head
         if (isPrinting())
           TFTSer.println(live_Zoffset);

commit 33e0855e2c173680865aaa6c6aa93047d63fc469
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 28 01:07:51 2021 -0500

    ‚ö°Ô∏è Handle shared enable pins (#22824)

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index 42364f2890..1b572367f2 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -30,20 +30,21 @@
 
 #include "../../../inc/MarlinConfigPre.h"
 
 #if ENABLED(ANYCUBIC_LCD_CHIRON)
 
 #include "chiron_tft.h"
 #include "Tunes.h"
 #include "FileNavigator.h"
 
 #include "../../../gcode/queue.h"
+#include "../../../module/stepper.h"
 #include "../../../sd/cardreader.h"
 #include "../../../libs/numtostr.h"
 #include "../../../MarlinCore.h"
 
 namespace Anycubic {
 
 ChironTFT Chiron;
 #if AUTO_DETECT_CHIRON_TFT
   panel_type_t   ChironTFT::panel_type = AC_panel_unknown;
 #endif
@@ -658,21 +659,21 @@ void ChironTFT::PanelAction(uint8_t req) {
         setTargetTemp_celsius(set_Btemp, BED);
     } break;
 
     case 18:   // A18 Set Fan Speed
       if (panel_command[4] == 'S')
         setTargetFan_percent(atof(&panel_command[5]), FAN0);
       break;
 
     case 19:   // A19 Motors off
       if (!isPrinting()) {
-        disable_all_steppers(); // from marlincore.h
+        stepper.disable_all_steppers();
         SendtoTFTLN(AC_msg_ready);
       }
       break;
 
     case 20:   // A20 Read/write print speed
       if (panel_command[4] == 'S')
         setFeedrate_percent(atoi(&panel_command[5]));
       else {
         SendtoTFT(PSTR("A20V "));
         TFTSer.println(getFeedrate_percent());

commit 754b31918a73cb08c322102be5d3926d2ac59c18
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 9 04:57:05 2021 -0500

    üé® Fewer serial macros

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index 0ecb138bd5..42364f2890 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -97,21 +97,21 @@ void ChironTFT::Startup() {
   SendtoTFTLN(AC_msg_main_board_has_reset);
 
   // Enable leveling and Disable end stops during print
   // as Z home places nozzle above the bed so we need to allow it past the end stops
   injectCommands_P(AC_cmnd_enable_leveling);
 
   // Startup tunes are defined in Tunes.h
   PlayTune(BEEPER_PIN, TERN(AC_DEFAULT_STARTUP_TUNE, Anycubic_PowerOn, GB_PowerOn), 1);
 
   #if ACDEBUGLEVEL
-    SERIAL_ECHOLNPAIR("AC Debug Level ", ACDEBUGLEVEL);
+    SERIAL_ECHOLNPGM("AC Debug Level ", ACDEBUGLEVEL);
   #endif
   SendtoTFTLN(AC_msg_ready);
 }
 
 void ChironTFT::DetectPanelType() {
   #if AUTO_DETECT_CHIRON_TFT
     // Send a query to the TFT
     SendtoTFTLN(AC_Test_for_OldPanel); // The panel will respond with 'SXY 480 320'
     SendtoTFTLN(AC_Test_for_NewPanel); // the panel will respond with '[0]=0   ' to '[19]=0   '
   #endif
@@ -121,48 +121,48 @@ void ChironTFT::IdleLoop()  {
   if (ReadTFTCommand()) {
     ProcessPanelRequest();
     command_len = 0;
   }
   CheckHeaters();
 }
 
 void ChironTFT::PrinterKilled(PGM_P error,PGM_P component)  {
   SendtoTFTLN(AC_msg_kill_lcd);
   #if ACDEBUG(AC_MARLIN)
-    SERIAL_ECHOLNPAIR("PrinterKilled()\nerror: ", error , "\ncomponent: ", component);
+    SERIAL_ECHOLNPGM("PrinterKilled()\nerror: ", error , "\ncomponent: ", component);
   #endif
 }
 
 void ChironTFT::MediaEvent(media_event_t event)  {
   #if ACDEBUG(AC_MARLIN)
-    SERIAL_ECHOLNPAIR("ProcessMediaStatus() ", event);
+    SERIAL_ECHOLNPGM("ProcessMediaStatus() ", event);
   #endif
   switch (event) {
     case AC_media_inserted:
       SendtoTFTLN(AC_msg_sd_card_inserted);
       break;
 
     case AC_media_removed:
       SendtoTFTLN(AC_msg_sd_card_removed);
       break;
 
     case AC_media_error:
       last_error = AC_error_noSD;
       SendtoTFTLN(AC_msg_no_sd_card);
       break;
   }
 }
 
 void ChironTFT::TimerEvent(timer_event_t event)  {
   #if ACDEBUG(AC_MARLIN)
-    SERIAL_ECHOLNPAIR("TimerEvent() ", event);
-    SERIAL_ECHOLNPAIR("Printer State: ", printer_state);
+    SERIAL_ECHOLNPGM("TimerEvent() ", event);
+    SERIAL_ECHOLNPGM("Printer State: ", printer_state);
   #endif
 
   switch (event) {
     case AC_timer_started: {
       live_Zoffset = 0.0; // reset print offset
       setSoftEndstopState(false);  // disable endstops to print
       printer_state = AC_printer_printing;
       SendtoTFTLN(AC_msg_print_from_sd_card);
     } break;
 
@@ -177,32 +177,32 @@ void ChironTFT::TimerEvent(timer_event_t event)  {
         printer_state = AC_printer_stopping;
         SendtoTFTLN(AC_msg_print_complete);
       }
       setSoftEndstopState(true); // enable endstops
     } break;
   }
 }
 
 void ChironTFT::FilamentRunout()  {
   #if ACDEBUG(AC_MARLIN)
-    SERIAL_ECHOLNPAIR("FilamentRunout() printer_state ", printer_state);
+    SERIAL_ECHOLNPGM("FilamentRunout() printer_state ", printer_state);
   #endif
   // 1 Signal filament out
   last_error = AC_error_filament_runout;
   SendtoTFTLN(isPrintingFromMedia() ? AC_msg_filament_out_alert : AC_msg_filament_out_block);
   PlayTune(BEEPER_PIN, FilamentOut, 1);
 }
 
 void ChironTFT::ConfirmationRequest(const char * const msg)  {
   // M108 continue
   #if ACDEBUG(AC_MARLIN)
-    SERIAL_ECHOLNPAIR("ConfirmationRequest() ", msg, " printer_state:", printer_state);
+    SERIAL_ECHOLNPGM("ConfirmationRequest() ", msg, " printer_state:", printer_state);
   #endif
   switch (printer_state) {
     case AC_printer_pausing: {
       if (strcmp_P(msg, MARLIN_msg_print_paused) == 0 || strcmp_P(msg, MARLIN_msg_nozzle_parked) == 0) {
         SendtoTFTLN(AC_msg_paused); // enable continue button
         printer_state = AC_printer_paused;
       }
     } break;
 
     case AC_printer_resuming_from_power_outage:
@@ -225,22 +225,22 @@ void ChironTFT::ConfirmationRequest(const char * const msg)  {
         SendtoTFTLN(AC_msg_paused); // enable continue button
       }
     } break;
     default:
     break;
   }
 }
 
 void ChironTFT::StatusChange(const char * const msg)  {
   #if ACDEBUG(AC_MARLIN)
-    SERIAL_ECHOLNPAIR("StatusChange() ", msg);
-    SERIAL_ECHOLNPAIR("printer_state:", printer_state);
+    SERIAL_ECHOLNPGM("StatusChange() ", msg);
+    SERIAL_ECHOLNPGM("printer_state:", printer_state);
   #endif
   bool msg_matched = false;
   // The only way to get printer status is to parse messages
   // Use the state to minimise the work we do here.
   switch (printer_state) {
     case AC_printer_probing: {
       // If probing completes ok save the mesh and park
       // Ignore the custom machine name
       if (strcmp_P(msg + strlen(CUSTOM_MACHINE_NAME), MARLIN_msg_ready) == 0) {
         injectCommands_P(PSTR("M500\nG27"));
@@ -341,69 +341,69 @@ bool ChironTFT::ReadTFTCommand() {
     if (panel_command[command_len] == '\n') {
       command_ready = true;
       break;
     }
     command_len++;
   }
 
   if (command_ready || command_len == MAX_CMND_LEN) {
     panel_command[command_len] = '\0';
     #if ACDEBUG(AC_ALL)
-      SERIAL_ECHOLNPAIR("len(",command_len,") < ", panel_command);
+      SERIAL_ECHOLNPGM("len(",command_len,") < ", panel_command);
     #endif
     command_ready = true;
   }
   return command_ready;
 }
 
 int8_t ChironTFT::FindToken(char c) {
   int8_t pos = 0;
   do {
     if (panel_command[pos] == c) {
       #if ACDEBUG(AC_INFO)
-        SERIAL_ECHOLNPAIR("Tpos:", pos, " ", c);
+        SERIAL_ECHOLNPGM("Tpos:", pos, " ", c);
       #endif
       return pos;
     }
   } while(++pos < command_len);
   #if ACDEBUG(AC_INFO)
-    SERIAL_ECHOLNPAIR("Not found: ", c);
+    SERIAL_ECHOLNPGM("Not found: ", c);
   #endif
   return -1;
 }
 
 void ChironTFT::CheckHeaters() {
   uint8_t faultDuration = 0;
 
   // if the hotend temp is abnormal, confirm state before signalling panel
   celsius_float_t temp = getActualTemp_celsius(E0);
   while (!WITHIN(temp, HEATER_0_MINTEMP, HEATER_0_MAXTEMP)) {
     faultDuration++;
     if (faultDuration >= AC_HEATER_FAULT_VALIDATION_TIME) {
       SendtoTFTLN(AC_msg_nozzle_temp_abnormal);
       last_error = AC_error_abnormal_temp_t0;
-      SERIAL_ECHOLNPAIR("Extruder temp abnormal! : ", temp);
+      SERIAL_ECHOLNPGM("Extruder temp abnormal! : ", temp);
       break;
     }
     delay_ms(500);
     temp = getActualTemp_celsius(E0);
   }
 
   // If the hotbed temp is abnormal, confirm state before signaling panel
   faultDuration = 0;
   temp = getActualTemp_celsius(BED);
   while (!WITHIN(temp, BED_MINTEMP, BED_MAXTEMP)) {
     faultDuration++;
     if (faultDuration >= AC_HEATER_FAULT_VALIDATION_TIME) {
       SendtoTFTLN(AC_msg_nozzle_temp_abnormal);
       last_error = AC_error_abnormal_temp_bed;
-      SERIAL_ECHOLNPAIR("Bed temp abnormal! : ", temp);
+      SERIAL_ECHOLNPGM("Bed temp abnormal! : ", temp);
       break;
     }
     delay_ms(500);
     temp = getActualTemp_celsius(E0);
   }
 
   // Update panel with hotend heater status
   if (hotend_state != AC_heater_temp_reached) {
     if (WITHIN(getActualTemp_celsius(E0) - getTargetTemp_celsius(E0), -(TEMP_WINDOW), TEMP_WINDOW)) {
       SendtoTFTLN(AC_msg_nozzle_heating_done);
@@ -416,38 +416,38 @@ void ChironTFT::CheckHeaters() {
     if (WITHIN(getActualTemp_celsius(BED) - getTargetTemp_celsius(BED), -(TEMP_BED_WINDOW), TEMP_BED_WINDOW)) {
       SendtoTFTLN(AC_msg_bed_heating_done);
       hotbed_state = AC_heater_temp_reached;
     }
   }
 }
 
 void ChironTFT::SendFileList(int8_t startindex) {
   // Respond to panel request for 4 files starting at index
   #if ACDEBUG(AC_INFO)
-    SERIAL_ECHOLNPAIR("## SendFileList ## ", startindex);
+    SERIAL_ECHOLNPGM("## SendFileList ## ", startindex);
   #endif
   SendtoTFTLN(PSTR("FN "));
   filenavigator.getFiles(startindex, panel_type, 4);
   SendtoTFTLN(PSTR("END"));
 }
 
 void ChironTFT::SelectFile() {
   if (panel_type == AC_panel_new) {
     strncpy(selectedfile, panel_command + 4, command_len - 3);
     selectedfile[command_len - 4] = '\0';
   }
   else {
     strncpy(selectedfile, panel_command + 4, command_len - 4);
     selectedfile[command_len - 5] = '\0';
   }
   #if ACDEBUG(AC_FILE)
-    SERIAL_ECHOLNPAIR(" Selected File: ",selectedfile);
+    SERIAL_ECHOLNPGM(" Selected File: ",selectedfile);
   #endif
   switch (selectedfile[0]) {
     case '/':   // Valid file selected
       SendtoTFTLN(AC_msg_sd_file_open_success);
       break;
 
     case '<':   // .. (go up folder level)
       filenavigator.upDIR();
       SendtoTFTLN(AC_msg_sd_file_open_failed);
       SendFileList( 0 );
@@ -554,21 +554,21 @@ void ChironTFT::PanelInfo(uint8_t req) {
       break;
 
     case 7: { // A7 Get Printing Time
       uint32_t time = getProgress_seconds_elapsed() / 60;
       SendtoTFT(PSTR("A7V "));
       TFTSer.print(ui8tostr2(time / 60));
       SendtoTFT(PSTR(" H "));
       TFTSer.print(ui8tostr2(time % 60));
       SendtoTFT(PSTR(" M"));
       #if ACDEBUG(AC_ALL)
-        SERIAL_ECHOLNPAIR("Print time ", ui8tostr2(time / 60), ":", ui8tostr2(time % 60));
+        SERIAL_ECHOLNPGM("Print time ", ui8tostr2(time / 60), ":", ui8tostr2(time % 60));
       #endif
     } break;
 
     case 8:   // A8 Get SD Card list A8 S0
       if (!isMediaInserted()) safe_delay(500);
       if (!isMediaInserted())   // Make sure the card is removed
         SendtoTFTLN(AC_msg_no_sd_card);
       else if (panel_command[3] == 'S')
         SendFileList( atoi( &panel_command[4] ) );
       break;
@@ -695,21 +695,21 @@ void ChironTFT::PanelAction(uint8_t req) {
       // Old TFT A22 X -1F1500      A22 X +1F1500
       // New TFT A22 X-1.0 F1500    A22 X1.0 F1500
 
       // lets just wrap this in a gcode relative nonprint move and let the controller deal with it
       // G91 G0 <panel command> G90
 
       if (!isPrinting()) { // Ignore request if printing
         char MoveCmnd[30];
         sprintf_P(MoveCmnd, PSTR("G91\nG0%s\nG90"), panel_command + 3);
         #if ACDEBUG(AC_ACTION)
-          SERIAL_ECHOLNPAIR("Move: ", MoveCmnd);
+          SERIAL_ECHOLNPGM("Move: ", MoveCmnd);
         #endif
         setSoftEndstopState(true);  // enable endstops
         injectCommands(MoveCmnd);
       }
     } break;
 
     case 23:   // A23 Preheat PLA
       // Ignore request if printing
       if (!isPrinting()) {
         // Temps defined in configuration.h
@@ -774,30 +774,30 @@ void ChironTFT::PanelProcess(uint8_t req) {
       TFTSer.println(pos_z * 100);
       if (!isPrinting()) {
         setSoftEndstopState(true);  // disable endstops
         // If the same meshpoint is selected twice in a row, move the head to that ready for adjustment
         if ((selectedmeshpoint.x == pos.x) && (selectedmeshpoint.y == pos.y)) {
           if (!isPositionKnown())
             injectCommands_P(G28_STR); // home
 
           if (isPositionKnown()) {
             #if ACDEBUG(AC_INFO)
-              SERIAL_ECHOLNPAIR("Moving to mesh point at x: ", pos.x, " y: ", pos.y, " z: ", pos_z);
+              SERIAL_ECHOLNPGM("Moving to mesh point at x: ", pos.x, " y: ", pos.y, " z: ", pos_z);
             #endif
             // Go up before moving
             setAxisPosition_mm(3.0,Z);
 
             setAxisPosition_mm(17 + (93 * pos.x), X);
             setAxisPosition_mm(20 + (93 * pos.y), Y);
             setAxisPosition_mm(0.0, Z);
             #if ACDEBUG(AC_INFO)
-              SERIAL_ECHOLNPAIR("Current Z: ", getAxisPosition_mm(Z));
+              SERIAL_ECHOLNPGM("Current Z: ", getAxisPosition_mm(Z));
             #endif
           }
         }
         selectedmeshpoint.x = pos.x;
         selectedmeshpoint.y = pos.y;
       }
     } break;
 
     case 30: {   // A30 Auto leveling
       if (FindToken('S') != -1) { // Start probing New panel adds spaces..
@@ -851,61 +851,61 @@ void ChironTFT::PanelProcess(uint8_t req) {
 
       else {
         int8_t tokenpos = FindToken('S');
         if (tokenpos != -1) { // Set offset (adjusts all points by value)
           float Zshift = atof(&panel_command[tokenpos+1]);
           setSoftEndstopState(false);  // disable endstops
           // Allow temporary Z position nudging during print
           // From the leveling panel use the all points UI to adjust the print pos.
           if (isPrinting()) {
             #if ACDEBUG(AC_INFO)
-              SERIAL_ECHOLNPAIR("Change Zoffset from:", live_Zoffset, " to ", live_Zoffset + Zshift);
+              SERIAL_ECHOLNPGM("Change Zoffset from:", live_Zoffset, " to ", live_Zoffset + Zshift);
             #endif
             if (isAxisPositionKnown(Z)) {
               #if ACDEBUG(AC_INFO)
                 const float currZpos = getAxisPosition_mm(Z);
-                SERIAL_ECHOLNPAIR("Nudge Z pos from ", currZpos, " to ", currZpos + constrain(Zshift, -0.05, 0.05));
+                SERIAL_ECHOLNPGM("Nudge Z pos from ", currZpos, " to ", currZpos + constrain(Zshift, -0.05, 0.05));
               #endif
               // Use babystepping to adjust the head position
               int16_t steps = mmToWholeSteps(constrain(Zshift,-0.05,0.05), Z);
               #if ACDEBUG(AC_INFO)
-                SERIAL_ECHOLNPAIR("Steps to move Z: ", steps);
+                SERIAL_ECHOLNPGM("Steps to move Z: ", steps);
               #endif
               babystepAxis_steps(steps, Z);
               live_Zoffset += Zshift;
             }
             SendtoTFT(PSTR("A31V "));
             TFTSer.println(live_Zoffset);
           }
           else {
             GRID_LOOP(x, y) {
               const xy_uint8_t pos { x, y };
               const float currval = getMeshPoint(pos);
               setMeshPoint(pos, constrain(currval + Zshift, AC_LOWEST_MESHPOINT_VAL, 2));
               #if ACDEBUG(AC_INFO)
-                SERIAL_ECHOLNPAIR("Change mesh point X", x," Y",y ," from ", currval, " to ", getMeshPoint(pos) );
+                SERIAL_ECHOLNPGM("Change mesh point X", x," Y",y ," from ", currval, " to ", getMeshPoint(pos) );
               #endif
             }
             const float currZOffset = getZOffset_mm();
             #if ACDEBUG(AC_INFO)
-              SERIAL_ECHOLNPAIR("Change probe offset from ", currZOffset, " to  ", currZOffset + Zshift);
+              SERIAL_ECHOLNPGM("Change probe offset from ", currZOffset, " to  ", currZOffset + Zshift);
             #endif
 
             setZOffset_mm(currZOffset + Zshift);
             SendtoTFT(PSTR("A31V "));
             TFTSer.println(getZOffset_mm());
 
             if (isAxisPositionKnown(Z)) {
               // Move Z axis
               const float currZpos = getAxisPosition_mm(Z);
               #if ACDEBUG(AC_INFO)
-                SERIAL_ECHOLNPAIR("Move Z pos from ", currZpos, " to ", currZpos + constrain(Zshift, -0.05, 0.05));
+                SERIAL_ECHOLNPGM("Move Z pos from ", currZpos, " to ", currZpos + constrain(Zshift, -0.05, 0.05));
               #endif
               setAxisPosition_mm(currZpos+constrain(Zshift,-0.05,0.05),Z);
             }
           }
         }
       }
     } break;
 
     case 32: { // A32 clean leveling beep flag
       // Ignore request if printing
@@ -923,33 +923,33 @@ void ChironTFT::PanelProcess(uint8_t req) {
         //printer_state = AC_printer_idle;
       }
       else {
         xy_uint8_t pos;
         pos.x = atoi(&panel_command[5]);
         pos.y = atoi(&panel_command[8]);
 
         float currmesh = getMeshPoint(pos);
         float newval   = atof(&panel_command[11])/100;
         #if ACDEBUG(AC_INFO)
-          SERIAL_ECHOLNPAIR("Change mesh point x:", pos.x, " y:", pos.y);
-          SERIAL_ECHOLNPAIR("from ", currmesh, " to ", newval);
+          SERIAL_ECHOLNPGM("Change mesh point x:", pos.x, " y:", pos.y);
+          SERIAL_ECHOLNPGM("from ", currmesh, " to ", newval);
         #endif
         // Update Meshpoint
         setMeshPoint(pos,newval);
         if (printer_state == AC_printer_idle || printer_state == AC_printer_probing /*!isPrinting()*/) {
           // if we are at the current mesh point indicated on the panel Move Z pos +/- 0.05mm
           // (The panel changes the mesh value by +/- 0.05mm on each button press)
           if (selectedmeshpoint.x == pos.x && selectedmeshpoint.y == pos.y) {
             setSoftEndstopState(false);
             float currZpos = getAxisPosition_mm(Z);
             #if ACDEBUG(AC_INFO)
-              SERIAL_ECHOLNPAIR("Move Z pos from ", currZpos, " to ", currZpos + constrain(newval - currmesh, -0.05, 0.05));
+              SERIAL_ECHOLNPGM("Move Z pos from ", currZpos, " to ", currZpos + constrain(newval - currmesh, -0.05, 0.05));
             #endif
             setAxisPosition_mm(currZpos + constrain(newval - currmesh, -0.05, 0.05), Z);
           }
         }
       }
     }  break;
 
     case 36:    // A36 Auto leveling for new TFT bet that was a typo in the panel code!
       SendtoTFTLN(AC_msg_start_probing);
       break;

commit afca6e745932d295b88d37fa9bd4274e22705b0b
Author: luzpaz <luzpaz@users.noreply.github.com>
Date:   Tue Aug 3 20:02:34 2021 -0400

    üêõ Spellcheck comments (#22496)
    
    codespell -q 3 --builtin=clear,rare,informal,code -S ./Marlin/src/lcd/language -L alo,amin,endcode,stdio,uint

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
index 14d394db72..0ecb138bd5 100644
--- a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -201,21 +201,21 @@ void ChironTFT::ConfirmationRequest(const char * const msg)  {
     case AC_printer_pausing: {
       if (strcmp_P(msg, MARLIN_msg_print_paused) == 0 || strcmp_P(msg, MARLIN_msg_nozzle_parked) == 0) {
         SendtoTFTLN(AC_msg_paused); // enable continue button
         printer_state = AC_printer_paused;
       }
     } break;
 
     case AC_printer_resuming_from_power_outage:
     case AC_printer_printing:
     case AC_printer_paused: {
-      // Heater timout, send acknowledgement
+      // Heater timeout, send acknowledgement
       if (strcmp_P(msg, MARLIN_msg_heater_timeout) == 0) {
         pause_state = AC_paused_heater_timed_out;
         SendtoTFTLN(AC_msg_paused); // enable continue button
         PlayTune(BEEPER_PIN,Heater_Timedout,1);
       }
       // Reheat finished, send acknowledgement
       else if (strcmp_P(msg, MARLIN_msg_reheat_done) == 0) {
         pause_state = AC_paused_idle;
         SendtoTFTLN(AC_msg_paused); // enable continue button
       }
@@ -241,21 +241,21 @@ void ChironTFT::StatusChange(const char * const msg)  {
   switch (printer_state) {
     case AC_printer_probing: {
       // If probing completes ok save the mesh and park
       // Ignore the custom machine name
       if (strcmp_P(msg + strlen(CUSTOM_MACHINE_NAME), MARLIN_msg_ready) == 0) {
         injectCommands_P(PSTR("M500\nG27"));
         SendtoTFTLN(AC_msg_probing_complete);
         printer_state = AC_printer_idle;
         msg_matched = true;
       }
-      // If probing fails dont save the mesh raise the probe above the bad point
+      // If probing fails don't save the mesh raise the probe above the bad point
       if (strcmp_P(msg, MARLIN_msg_probing_failed) == 0) {
         PlayTune(BEEPER_PIN, BeepBeepBeeep, 1);
         injectCommands_P(PSTR("G1 Z50 F500"));
         SendtoTFTLN(AC_msg_probing_complete);
         printer_state = AC_printer_idle;
         msg_matched = true;
       }
     } break;
 
     case AC_printer_printing: {
@@ -615,21 +615,21 @@ void ChironTFT::PanelAction(uint8_t req) {
 
     case 12:   // A12 Kill printer
       kill();  // from marlincore.h
       break;
 
     case 13:   // A13 Select file
       SelectFile();
       break;
 
     case 14: { // A14 Start Printing
-      // Allows printer to restart the job if we dont want to recover
+      // Allows printer to restart the job if we don't want to recover
       if (printer_state == AC_printer_resuming_from_power_outage) {
         injectCommands_P(PSTR("M1000 C")); // Cancel recovery
         printer_state = AC_printer_idle;
       }
       #if ACDebugLevel >= 1
         SERIAL_ECHOLNPAIR_F("Print: ", selectedfile);
       #endif
       printFile(selectedfile);
       SendtoTFTLN(AC_msg_print_from_sd_card);
     } break;

commit 8d9021e8069c0550e9a31107adf44b9112b87471
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 6 04:17:59 2021 -0500

    Move ExtUI subfolders up a level (#21820)

diff --git a/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
new file mode 100644
index 0000000000..14d394db72
--- /dev/null
+++ b/Marlin/src/lcd/extui/anycubic_chiron/chiron_tft.cpp
@@ -0,0 +1,975 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * lcd/extui/anycubic_chiron/chiron_tft.cpp
+ *
+ * Extensible_UI implementation for Anycubic Chiron
+ * Written By Nick Wells, 2020 [https://github.com/SwiftNick]
+ *  (not affiliated with Anycubic, Ltd.)
+ */
+
+#include "../../../inc/MarlinConfigPre.h"
+
+#if ENABLED(ANYCUBIC_LCD_CHIRON)
+
+#include "chiron_tft.h"
+#include "Tunes.h"
+#include "FileNavigator.h"
+
+#include "../../../gcode/queue.h"
+#include "../../../sd/cardreader.h"
+#include "../../../libs/numtostr.h"
+#include "../../../MarlinCore.h"
+
+namespace Anycubic {
+
+ChironTFT Chiron;
+#if AUTO_DETECT_CHIRON_TFT
+  panel_type_t   ChironTFT::panel_type = AC_panel_unknown;
+#endif
+last_error_t     ChironTFT::last_error;
+printer_state_t  ChironTFT::printer_state;
+paused_state_t   ChironTFT::pause_state;
+heater_state_t   ChironTFT::hotend_state;
+heater_state_t   ChironTFT::hotbed_state;
+xy_uint8_t       ChironTFT::selectedmeshpoint;
+char             ChironTFT::selectedfile[MAX_PATH_LEN + 1];
+char             ChironTFT::panel_command[MAX_CMND_LEN + 1];
+uint8_t          ChironTFT::command_len;
+float            ChironTFT::live_Zoffset;
+file_menu_t      ChironTFT::file_menu;
+
+void ChironTFT::Startup() {
+  selectedfile[0]   = '\0';
+  panel_command[0]  = '\0';
+  command_len       = 0;
+  last_error        = AC_error_none;
+  printer_state     = AC_printer_idle;
+  pause_state       = AC_paused_idle;
+  hotend_state      = AC_heater_off;
+  hotbed_state      = AC_heater_off;
+  live_Zoffset      = 0.0;
+  file_menu         = AC_menu_file;
+
+  // Setup pins for powerloss detection
+  // Two IO pins are connected on the Trigorilla Board
+  // On a power interruption the OUTAGECON_PIN goes low.
+
+  #if ENABLED(POWER_LOSS_RECOVERY)
+    OUT_WRITE(OUTAGECON_PIN, HIGH);
+  #endif
+
+  // Filament runout is handled by Marlin settings in Configuration.h
+  // opt_set    FIL_RUNOUT_STATE HIGH  // Pin state indicating that filament is NOT present.
+  // opt_enable FIL_RUNOUT_PULLUP
+  TFTSer.begin(115200);
+
+  // wait for the TFT panel to initialise and finish the animation
+  delay_ms(250);
+
+  // There are different panels for the Chiron with slightly different commands
+  // So we need to know what we are working with.
+
+  // Panel type can be defined otherwise detect it automatically
+  if (panel_type == AC_panel_unknown) DetectPanelType();
+
+  // Signal Board has reset
+  SendtoTFTLN(AC_msg_main_board_has_reset);
+
+  // Enable leveling and Disable end stops during print
+  // as Z home places nozzle above the bed so we need to allow it past the end stops
+  injectCommands_P(AC_cmnd_enable_leveling);
+
+  // Startup tunes are defined in Tunes.h
+  PlayTune(BEEPER_PIN, TERN(AC_DEFAULT_STARTUP_TUNE, Anycubic_PowerOn, GB_PowerOn), 1);
+
+  #if ACDEBUGLEVEL
+    SERIAL_ECHOLNPAIR("AC Debug Level ", ACDEBUGLEVEL);
+  #endif
+  SendtoTFTLN(AC_msg_ready);
+}
+
+void ChironTFT::DetectPanelType() {
+  #if AUTO_DETECT_CHIRON_TFT
+    // Send a query to the TFT
+    SendtoTFTLN(AC_Test_for_OldPanel); // The panel will respond with 'SXY 480 320'
+    SendtoTFTLN(AC_Test_for_NewPanel); // the panel will respond with '[0]=0   ' to '[19]=0   '
+  #endif
+}
+
+void ChironTFT::IdleLoop()  {
+  if (ReadTFTCommand()) {
+    ProcessPanelRequest();
+    command_len = 0;
+  }
+  CheckHeaters();
+}
+
+void ChironTFT::PrinterKilled(PGM_P error,PGM_P component)  {
+  SendtoTFTLN(AC_msg_kill_lcd);
+  #if ACDEBUG(AC_MARLIN)
+    SERIAL_ECHOLNPAIR("PrinterKilled()\nerror: ", error , "\ncomponent: ", component);
+  #endif
+}
+
+void ChironTFT::MediaEvent(media_event_t event)  {
+  #if ACDEBUG(AC_MARLIN)
+    SERIAL_ECHOLNPAIR("ProcessMediaStatus() ", event);
+  #endif
+  switch (event) {
+    case AC_media_inserted:
+      SendtoTFTLN(AC_msg_sd_card_inserted);
+      break;
+
+    case AC_media_removed:
+      SendtoTFTLN(AC_msg_sd_card_removed);
+      break;
+
+    case AC_media_error:
+      last_error = AC_error_noSD;
+      SendtoTFTLN(AC_msg_no_sd_card);
+      break;
+  }
+}
+
+void ChironTFT::TimerEvent(timer_event_t event)  {
+  #if ACDEBUG(AC_MARLIN)
+    SERIAL_ECHOLNPAIR("TimerEvent() ", event);
+    SERIAL_ECHOLNPAIR("Printer State: ", printer_state);
+  #endif
+
+  switch (event) {
+    case AC_timer_started: {
+      live_Zoffset = 0.0; // reset print offset
+      setSoftEndstopState(false);  // disable endstops to print
+      printer_state = AC_printer_printing;
+      SendtoTFTLN(AC_msg_print_from_sd_card);
+    } break;
+
+    case AC_timer_paused: {
+      printer_state = AC_printer_paused;
+      pause_state   = AC_paused_idle;
+      SendtoTFTLN(AC_msg_paused);
+    } break;
+
+    case AC_timer_stopped: {
+      if (printer_state != AC_printer_idle) {
+        printer_state = AC_printer_stopping;
+        SendtoTFTLN(AC_msg_print_complete);
+      }
+      setSoftEndstopState(true); // enable endstops
+    } break;
+  }
+}
+
+void ChironTFT::FilamentRunout()  {
+  #if ACDEBUG(AC_MARLIN)
+    SERIAL_ECHOLNPAIR("FilamentRunout() printer_state ", printer_state);
+  #endif
+  // 1 Signal filament out
+  last_error = AC_error_filament_runout;
+  SendtoTFTLN(isPrintingFromMedia() ? AC_msg_filament_out_alert : AC_msg_filament_out_block);
+  PlayTune(BEEPER_PIN, FilamentOut, 1);
+}
+
+void ChironTFT::ConfirmationRequest(const char * const msg)  {
+  // M108 continue
+  #if ACDEBUG(AC_MARLIN)
+    SERIAL_ECHOLNPAIR("ConfirmationRequest() ", msg, " printer_state:", printer_state);
+  #endif
+  switch (printer_state) {
+    case AC_printer_pausing: {
+      if (strcmp_P(msg, MARLIN_msg_print_paused) == 0 || strcmp_P(msg, MARLIN_msg_nozzle_parked) == 0) {
+        SendtoTFTLN(AC_msg_paused); // enable continue button
+        printer_state = AC_printer_paused;
+      }
+    } break;
+
+    case AC_printer_resuming_from_power_outage:
+    case AC_printer_printing:
+    case AC_printer_paused: {
+      // Heater timout, send acknowledgement
+      if (strcmp_P(msg, MARLIN_msg_heater_timeout) == 0) {
+        pause_state = AC_paused_heater_timed_out;
+        SendtoTFTLN(AC_msg_paused); // enable continue button
+        PlayTune(BEEPER_PIN,Heater_Timedout,1);
+      }
+      // Reheat finished, send acknowledgement
+      else if (strcmp_P(msg, MARLIN_msg_reheat_done) == 0) {
+        pause_state = AC_paused_idle;
+        SendtoTFTLN(AC_msg_paused); // enable continue button
+      }
+      // Filament Purging, send acknowledgement enter run mode
+      else if (strcmp_P(msg, MARLIN_msg_filament_purging) == 0) {
+        pause_state = AC_paused_purging_filament;
+        SendtoTFTLN(AC_msg_paused); // enable continue button
+      }
+    } break;
+    default:
+    break;
+  }
+}
+
+void ChironTFT::StatusChange(const char * const msg)  {
+  #if ACDEBUG(AC_MARLIN)
+    SERIAL_ECHOLNPAIR("StatusChange() ", msg);
+    SERIAL_ECHOLNPAIR("printer_state:", printer_state);
+  #endif
+  bool msg_matched = false;
+  // The only way to get printer status is to parse messages
+  // Use the state to minimise the work we do here.
+  switch (printer_state) {
+    case AC_printer_probing: {
+      // If probing completes ok save the mesh and park
+      // Ignore the custom machine name
+      if (strcmp_P(msg + strlen(CUSTOM_MACHINE_NAME), MARLIN_msg_ready) == 0) {
+        injectCommands_P(PSTR("M500\nG27"));
+        SendtoTFTLN(AC_msg_probing_complete);
+        printer_state = AC_printer_idle;
+        msg_matched = true;
+      }
+      // If probing fails dont save the mesh raise the probe above the bad point
+      if (strcmp_P(msg, MARLIN_msg_probing_failed) == 0) {
+        PlayTune(BEEPER_PIN, BeepBeepBeeep, 1);
+        injectCommands_P(PSTR("G1 Z50 F500"));
+        SendtoTFTLN(AC_msg_probing_complete);
+        printer_state = AC_printer_idle;
+        msg_matched = true;
+      }
+    } break;
+
+    case AC_printer_printing: {
+      if (strcmp_P(msg, MARLIN_msg_reheating) == 0) {
+        SendtoTFTLN(AC_msg_paused); // enable continue button
+        msg_matched = true;
+       }
+    } break;
+
+    case AC_printer_pausing: {
+      if (strcmp_P(msg, MARLIN_msg_print_paused) == 0) {
+        SendtoTFTLN(AC_msg_paused);
+        printer_state = AC_printer_paused;
+        pause_state = AC_paused_idle;
+        msg_matched = true;
+       }
+    } break;
+
+    case AC_printer_stopping: {
+      if (strcmp_P(msg, MARLIN_msg_print_aborted) == 0) {
+        SendtoTFTLN(AC_msg_stop);
+        printer_state = AC_printer_idle;
+        msg_matched = true;
+      }
+    } break;
+    default:
+    break;
+  }
+
+  // If not matched earlier see if this was a heater message
+  if (!msg_matched) {
+    if (strcmp_P(msg, MARLIN_msg_extruder_heating) == 0) {
+      SendtoTFTLN(AC_msg_nozzle_heating);
+      hotend_state = AC_heater_temp_set;
+    }
+    else if (strcmp_P(msg, MARLIN_msg_bed_heating) == 0) {
+      SendtoTFTLN(AC_msg_bed_heating);
+      hotbed_state = AC_heater_temp_set;
+    }
+    else if (strcmp_P(msg, MARLIN_msg_EEPROM_version) == 0) {
+      last_error = AC_error_EEPROM;
+    }
+  }
+}
+
+void ChironTFT::PowerLossRecovery()  {
+  printer_state = AC_printer_resuming_from_power_outage; // Play tune to notify user we can recover.
+  last_error = AC_error_powerloss;
+  PlayTune(BEEPER_PIN, SOS, 1);
+  SERIAL_ECHOLNPGM_P(AC_msg_powerloss_recovery);
+}
+
+void ChironTFT::PrintComplete() {
+  SendtoTFT(AC_msg_print_complete);
+  printer_state = AC_printer_idle;
+  setSoftEndstopState(true); // enable endstops
+}
+
+void ChironTFT::SendtoTFT(PGM_P str) {  // A helper to print PROGMEM string to the panel
+  #if ACDEBUG(AC_SOME)
+    SERIAL_ECHOPGM_P(str);
+  #endif
+  while (const char c = pgm_read_byte(str++)) TFTSer.write(c);
+}
+
+void ChironTFT::SendtoTFTLN(PGM_P str = nullptr) {
+  if (str) {
+    #if ACDEBUG(AC_SOME)
+      SERIAL_ECHOPGM("> ");
+    #endif
+    SendtoTFT(str);
+    #if ACDEBUG(AC_SOME)
+      SERIAL_EOL();
+    #endif
+  }
+  TFTSer.println();
+}
+
+bool ChironTFT::ReadTFTCommand() {
+  bool command_ready = false;
+  while (TFTSer.available() > 0 && command_len < MAX_CMND_LEN) {
+    panel_command[command_len] = TFTSer.read();
+    if (panel_command[command_len] == '\n') {
+      command_ready = true;
+      break;
+    }
+    command_len++;
+  }
+
+  if (command_ready || command_len == MAX_CMND_LEN) {
+    panel_command[command_len] = '\0';
+    #if ACDEBUG(AC_ALL)
+      SERIAL_ECHOLNPAIR("len(",command_len,") < ", panel_command);
+    #endif
+    command_ready = true;
+  }
+  return command_ready;
+}
+
+int8_t ChironTFT::FindToken(char c) {
+  int8_t pos = 0;
+  do {
+    if (panel_command[pos] == c) {
+      #if ACDEBUG(AC_INFO)
+        SERIAL_ECHOLNPAIR("Tpos:", pos, " ", c);
+      #endif
+      return pos;
+    }
+  } while(++pos < command_len);
+  #if ACDEBUG(AC_INFO)
+    SERIAL_ECHOLNPAIR("Not found: ", c);
+  #endif
+  return -1;
+}
+
+void ChironTFT::CheckHeaters() {
+  uint8_t faultDuration = 0;
+
+  // if the hotend temp is abnormal, confirm state before signalling panel
+  celsius_float_t temp = getActualTemp_celsius(E0);
+  while (!WITHIN(temp, HEATER_0_MINTEMP, HEATER_0_MAXTEMP)) {
+    faultDuration++;
+    if (faultDuration >= AC_HEATER_FAULT_VALIDATION_TIME) {
+      SendtoTFTLN(AC_msg_nozzle_temp_abnormal);
+      last_error = AC_error_abnormal_temp_t0;
+      SERIAL_ECHOLNPAIR("Extruder temp abnormal! : ", temp);
+      break;
+    }
+    delay_ms(500);
+    temp = getActualTemp_celsius(E0);
+  }
+
+  // If the hotbed temp is abnormal, confirm state before signaling panel
+  faultDuration = 0;
+  temp = getActualTemp_celsius(BED);
+  while (!WITHIN(temp, BED_MINTEMP, BED_MAXTEMP)) {
+    faultDuration++;
+    if (faultDuration >= AC_HEATER_FAULT_VALIDATION_TIME) {
+      SendtoTFTLN(AC_msg_nozzle_temp_abnormal);
+      last_error = AC_error_abnormal_temp_bed;
+      SERIAL_ECHOLNPAIR("Bed temp abnormal! : ", temp);
+      break;
+    }
+    delay_ms(500);
+    temp = getActualTemp_celsius(E0);
+  }
+
+  // Update panel with hotend heater status
+  if (hotend_state != AC_heater_temp_reached) {
+    if (WITHIN(getActualTemp_celsius(E0) - getTargetTemp_celsius(E0), -(TEMP_WINDOW), TEMP_WINDOW)) {
+      SendtoTFTLN(AC_msg_nozzle_heating_done);
+      hotend_state = AC_heater_temp_reached;
+    }
+  }
+
+  // Update panel with bed heater status
+  if (hotbed_state != AC_heater_temp_reached) {
+    if (WITHIN(getActualTemp_celsius(BED) - getTargetTemp_celsius(BED), -(TEMP_BED_WINDOW), TEMP_BED_WINDOW)) {
+      SendtoTFTLN(AC_msg_bed_heating_done);
+      hotbed_state = AC_heater_temp_reached;
+    }
+  }
+}
+
+void ChironTFT::SendFileList(int8_t startindex) {
+  // Respond to panel request for 4 files starting at index
+  #if ACDEBUG(AC_INFO)
+    SERIAL_ECHOLNPAIR("## SendFileList ## ", startindex);
+  #endif
+  SendtoTFTLN(PSTR("FN "));
+  filenavigator.getFiles(startindex, panel_type, 4);
+  SendtoTFTLN(PSTR("END"));
+}
+
+void ChironTFT::SelectFile() {
+  if (panel_type == AC_panel_new) {
+    strncpy(selectedfile, panel_command + 4, command_len - 3);
+    selectedfile[command_len - 4] = '\0';
+  }
+  else {
+    strncpy(selectedfile, panel_command + 4, command_len - 4);
+    selectedfile[command_len - 5] = '\0';
+  }
+  #if ACDEBUG(AC_FILE)
+    SERIAL_ECHOLNPAIR(" Selected File: ",selectedfile);
+  #endif
+  switch (selectedfile[0]) {
+    case '/':   // Valid file selected
+      SendtoTFTLN(AC_msg_sd_file_open_success);
+      break;
+
+    case '<':   // .. (go up folder level)
+      filenavigator.upDIR();
+      SendtoTFTLN(AC_msg_sd_file_open_failed);
+      SendFileList( 0 );
+      break;
+    default:   // enter sub folder
+      // for new panel remove the '.GCO' tag that was added to the end of the path
+      if (panel_type == AC_panel_new)
+        selectedfile[strlen(selectedfile) - 4] = '\0';
+      filenavigator.changeDIR(selectedfile);
+      SendtoTFTLN(AC_msg_sd_file_open_failed);
+      SendFileList( 0 );
+      break;
+  }
+}
+
+void ChironTFT::ProcessPanelRequest() {
+  // Break these up into logical blocks // as its easier to navigate than one huge switch case!
+  int8_t tpos = FindToken('A');
+  // Panel request are 'A0' - 'A36'
+  if (tpos != -1) {
+    const int8_t req = atoi(&panel_command[tpos+1]);
+
+    // Information requests A0 - A8 and A33
+    if (req <= 8 || req == 33) PanelInfo(req);
+
+    // Simple Actions A9 - A28
+    else if (req <= 28) PanelAction(req);
+
+    // Process Initiation
+    else if (req <= 36) PanelProcess(req);
+  }
+  else {
+    #if AUTO_DETECT_CHIRON_TFT
+      // This may be a response to a panel type detection query
+      if (panel_type == AC_panel_unknown) {
+        tpos = FindToken('S'); // old panel will respond to 'SIZE' with 'SXY 480 320'
+        if (tpos != -1) {
+          if (panel_command[tpos+1]== 'X' && panel_command[tpos+2]=='Y') {
+            panel_type = AC_panel_standard;
+            SERIAL_ECHOLNPGM_P(AC_msg_old_panel_detected);
+          }
+        }
+        else {
+          tpos = FindToken('['); // new panel will respond to 'J200' with '[0]=0'
+          if (tpos != -1) {
+            if (panel_command[tpos+1]== '0' && panel_command[tpos+2]==']') {
+              panel_type = AC_panel_new;
+              SERIAL_ECHOLNPGM_P(AC_msg_new_panel_detected);
+            }
+          }
+        }
+        return;
+      }
+    #endif
+
+    SendtoTFTLN(); // Ignore unknown requests
+  }
+}
+
+void ChironTFT::PanelInfo(uint8_t req) {
+  // information requests A0-A8 and A33
+  switch (req) {
+    case 0:   // A0 Get HOTEND Temp
+      SendtoTFT(PSTR("A0V "));
+      TFTSer.println(getActualTemp_celsius(E0));
+      break;
+
+    case 1:   // A1 Get HOTEND Target Temp
+      SendtoTFT(PSTR("A1V "));
+      TFTSer.println(getTargetTemp_celsius(E0));
+      break;
+
+    case 2:   // A2 Get BED Temp
+      SendtoTFT(PSTR("A2V "));
+      TFTSer.println(getActualTemp_celsius(BED));
+      break;
+
+    case 3:   // A3 Get BED Target Temp
+      SendtoTFT(PSTR("A3V "));
+      TFTSer.println(getTargetTemp_celsius(BED));
+      break;
+
+    case 4:   // A4 Get FAN Speed
+      SendtoTFT(PSTR("A4V "));
+      TFTSer.println(getActualFan_percent(FAN0));
+      break;
+
+    case 5:   // A5 Get Current Coordinates
+      SendtoTFT(PSTR("A5V X: "));
+      TFTSer.print(getAxisPosition_mm(X));
+      SendtoTFT(PSTR(" Y: "));
+      TFTSer.print(getAxisPosition_mm(Y));
+      SendtoTFT(PSTR(" Z: "));
+      TFTSer.println(getAxisPosition_mm(Z));
+      break;
+
+    case 6:   // A6 Get printing progress
+      if (isPrintingFromMedia()) {
+        SendtoTFT(PSTR("A6V "));
+        TFTSer.println(ui8tostr2(getProgress_percent()));
+      }
+      else
+        SendtoTFTLN(PSTR("A6V ---"));
+      break;
+
+    case 7: { // A7 Get Printing Time
+      uint32_t time = getProgress_seconds_elapsed() / 60;
+      SendtoTFT(PSTR("A7V "));
+      TFTSer.print(ui8tostr2(time / 60));
+      SendtoTFT(PSTR(" H "));
+      TFTSer.print(ui8tostr2(time % 60));
+      SendtoTFT(PSTR(" M"));
+      #if ACDEBUG(AC_ALL)
+        SERIAL_ECHOLNPAIR("Print time ", ui8tostr2(time / 60), ":", ui8tostr2(time % 60));
+      #endif
+    } break;
+
+    case 8:   // A8 Get SD Card list A8 S0
+      if (!isMediaInserted()) safe_delay(500);
+      if (!isMediaInserted())   // Make sure the card is removed
+        SendtoTFTLN(AC_msg_no_sd_card);
+      else if (panel_command[3] == 'S')
+        SendFileList( atoi( &panel_command[4] ) );
+      break;
+
+    case 33:   // A33 Get firmware info
+      SendtoTFT(PSTR("J33 "));
+      // If there is an error recorded, show that instead of the FW version
+      if (!GetLastError()) SendtoTFTLN(PSTR(SHORT_BUILD_VERSION));
+      break;
+  }
+}
+
+void ChironTFT::PanelAction(uint8_t req) {
+  switch (req) {
+    case  9:   // A9 Pause SD print
+      if (isPrintingFromMedia()) {
+        SendtoTFTLN(AC_msg_pause);
+        pausePrint();
+        printer_state = AC_printer_pausing;
+      }
+      else
+        SendtoTFTLN(AC_msg_stop);
+      break;
+
+    case 10: // A10 Resume SD Print
+      if (pause_state == AC_paused_idle || printer_state == AC_printer_resuming_from_power_outage)
+        resumePrint();
+      else
+        setUserConfirmed();
+      break;
+
+    case 11:   // A11 Stop SD print
+      if (isPrintingFromMedia()) {
+        printer_state = AC_printer_stopping;
+        stopPrint();
+      }
+      else {
+        if (printer_state == AC_printer_resuming_from_power_outage)
+          injectCommands_P(PSTR("M1000 C")); // Cancel recovery
+        SendtoTFTLN(AC_msg_stop);
+        printer_state = AC_printer_idle;
+      }
+      break;
+
+    case 12:   // A12 Kill printer
+      kill();  // from marlincore.h
+      break;
+
+    case 13:   // A13 Select file
+      SelectFile();
+      break;
+
+    case 14: { // A14 Start Printing
+      // Allows printer to restart the job if we dont want to recover
+      if (printer_state == AC_printer_resuming_from_power_outage) {
+        injectCommands_P(PSTR("M1000 C")); // Cancel recovery
+        printer_state = AC_printer_idle;
+      }
+      #if ACDebugLevel >= 1
+        SERIAL_ECHOLNPAIR_F("Print: ", selectedfile);
+      #endif
+      printFile(selectedfile);
+      SendtoTFTLN(AC_msg_print_from_sd_card);
+    } break;
+
+    case 15:   // A15 Resuming from outage
+      if (printer_state == AC_printer_resuming_from_power_outage) {
+        // Need to home here to restore the Z position
+        injectCommands_P(AC_cmnd_power_loss_recovery);
+        injectCommands_P(PSTR("M1000"));  // home and start recovery
+      }
+      break;
+
+    case 16: { // A16 Set HotEnd temp  A17 S170
+      const float set_Htemp = atof(&panel_command[5]);
+      hotend_state = set_Htemp ? AC_heater_temp_set : AC_heater_off;
+      switch ((char)panel_command[4]) {
+        // Set Temp
+        case 'S': case 'C': setTargetTemp_celsius(set_Htemp, E0);
+      }
+    } break;
+
+    case 17: { // A17 Set bed temp
+      const float set_Btemp = atof(&panel_command[5]);
+      hotbed_state = set_Btemp ? AC_heater_temp_set : AC_heater_off;
+      if (panel_command[4] == 'S')
+        setTargetTemp_celsius(set_Btemp, BED);
+    } break;
+
+    case 18:   // A18 Set Fan Speed
+      if (panel_command[4] == 'S')
+        setTargetFan_percent(atof(&panel_command[5]), FAN0);
+      break;
+
+    case 19:   // A19 Motors off
+      if (!isPrinting()) {
+        disable_all_steppers(); // from marlincore.h
+        SendtoTFTLN(AC_msg_ready);
+      }
+      break;
+
+    case 20:   // A20 Read/write print speed
+      if (panel_command[4] == 'S')
+        setFeedrate_percent(atoi(&panel_command[5]));
+      else {
+        SendtoTFT(PSTR("A20V "));
+        TFTSer.println(getFeedrate_percent());
+      }
+      break;
+
+    case 21:   // A21 Home Axis  A21 X
+      if (!isPrinting()) {
+        switch ((char)panel_command[4]) {
+          case 'X': injectCommands_P(PSTR("G28X")); break;
+          case 'Y': injectCommands_P(PSTR("G28Y")); break;
+          case 'Z': injectCommands_P(PSTR("G28Z")); break;
+          case 'C': injectCommands_P(G28_STR); break;
+        }
+      }
+      break;
+
+    case 22: {   // A22 Move Axis
+      // The commands have changed on the new panel
+      // Old TFT A22 X -1F1500      A22 X +1F1500
+      // New TFT A22 X-1.0 F1500    A22 X1.0 F1500
+
+      // lets just wrap this in a gcode relative nonprint move and let the controller deal with it
+      // G91 G0 <panel command> G90
+
+      if (!isPrinting()) { // Ignore request if printing
+        char MoveCmnd[30];
+        sprintf_P(MoveCmnd, PSTR("G91\nG0%s\nG90"), panel_command + 3);
+        #if ACDEBUG(AC_ACTION)
+          SERIAL_ECHOLNPAIR("Move: ", MoveCmnd);
+        #endif
+        setSoftEndstopState(true);  // enable endstops
+        injectCommands(MoveCmnd);
+      }
+    } break;
+
+    case 23:   // A23 Preheat PLA
+      // Ignore request if printing
+      if (!isPrinting()) {
+        // Temps defined in configuration.h
+        setTargetTemp_celsius(PREHEAT_1_TEMP_BED, BED);
+        setTargetTemp_celsius(PREHEAT_1_TEMP_HOTEND, E0);
+        SendtoTFTLN();
+        hotbed_state = AC_heater_temp_set;
+        hotend_state = AC_heater_temp_set;
+      }
+      break;
+
+    case 24:   // A24 Preheat ABS
+      // Ignore request if printing
+      if (!isPrinting()) {
+        setTargetTemp_celsius(PREHEAT_2_TEMP_BED, BED);
+        setTargetTemp_celsius(PREHEAT_2_TEMP_HOTEND, E0);
+        SendtoTFTLN();
+        hotbed_state = AC_heater_temp_set;
+        hotend_state = AC_heater_temp_set;
+      }
+      break;
+
+    case 25:   // A25 Cool Down
+      // Ignore request if printing
+      if (!isPrinting()) {
+        setTargetTemp_celsius(0, E0);
+        setTargetTemp_celsius(0, BED);
+        SendtoTFTLN(AC_msg_ready);
+        hotbed_state = AC_heater_off;
+        hotend_state = AC_heater_off;
+      }
+      break;
+
+    case 26:   // A26 Refresh SD
+      if (card.isMounted())card.release();
+      card.mount();
+      safe_delay(500);
+      filenavigator.reset();
+      break;
+
+    case 27:   // A27 Servo Angles adjust
+      break;
+
+    case 28:   // A28 Filament set A28 O/C
+      // Ignore request if printing
+      if (isPrinting()) break;
+      SendtoTFTLN();
+      break;
+  }
+}
+
+void ChironTFT::PanelProcess(uint8_t req) {
+  switch (req) {
+    case 29: { // A29 Read Mesh Point A29 X1 Y1
+      xy_uint8_t pos;
+      float pos_z;
+      pos.x = atoi(&panel_command[FindToken('X')+1]);
+      pos.y = atoi(&panel_command[FindToken('Y')+1]);
+      pos_z = getMeshPoint(pos);
+
+      SendtoTFT(PSTR("A29V "));
+      TFTSer.println(pos_z * 100);
+      if (!isPrinting()) {
+        setSoftEndstopState(true);  // disable endstops
+        // If the same meshpoint is selected twice in a row, move the head to that ready for adjustment
+        if ((selectedmeshpoint.x == pos.x) && (selectedmeshpoint.y == pos.y)) {
+          if (!isPositionKnown())
+            injectCommands_P(G28_STR); // home
+
+          if (isPositionKnown()) {
+            #if ACDEBUG(AC_INFO)
+              SERIAL_ECHOLNPAIR("Moving to mesh point at x: ", pos.x, " y: ", pos.y, " z: ", pos_z);
+            #endif
+            // Go up before moving
+            setAxisPosition_mm(3.0,Z);
+
+            setAxisPosition_mm(17 + (93 * pos.x), X);
+            setAxisPosition_mm(20 + (93 * pos.y), Y);
+            setAxisPosition_mm(0.0, Z);
+            #if ACDEBUG(AC_INFO)
+              SERIAL_ECHOLNPAIR("Current Z: ", getAxisPosition_mm(Z));
+            #endif
+          }
+        }
+        selectedmeshpoint.x = pos.x;
+        selectedmeshpoint.y = pos.y;
+      }
+    } break;
+
+    case 30: {   // A30 Auto leveling
+      if (FindToken('S') != -1) { // Start probing New panel adds spaces..
+        // Ignore request if printing
+        if (isPrinting())
+          SendtoTFTLN(AC_msg_probing_not_allowed); // forbid auto leveling
+        else {
+
+
+          SendtoTFTLN(AC_msg_start_probing);
+          injectCommands_P(PSTR("G28\nG29"));
+          printer_state = AC_printer_probing;
+        }
+      }
+      else {
+        SendtoTFTLN(AC_msg_start_probing); // Just enter levelling menu
+      }
+    } break;
+
+    case 31: { // A31 Adjust all Probe Points
+      // The tokens can occur in different places on the new panel so we need to find it.
+
+      if (FindToken('C') != -1) { // Restore and apply original offsets
+        if (!isPrinting()) {
+          injectCommands_P(PSTR("M501\nM420 S1"));
+          selectedmeshpoint.x = selectedmeshpoint.y = 99;
+          SERIAL_ECHOLNPGM_P(AC_msg_mesh_changes_abandoned);
+        }
+      }
+
+      else if (FindToken('D') != -1) { // Save Z Offset tables and restore leveling state
+        if (!isPrinting()) {
+          setAxisPosition_mm(1.0,Z); // Lift nozzle before any further movements are made
+          injectCommands_P(PSTR("M500"));
+          SERIAL_ECHOLNPGM_P(AC_msg_mesh_changes_saved);
+          selectedmeshpoint.x = selectedmeshpoint.y = 99;
+        }
+      }
+
+      else if (FindToken('G') != -1) { // Get current offset
+        SendtoTFT(PSTR("A31V "));
+        // When printing use the live z Offset position
+        // we will use babystepping to move the print head
+        if (isPrinting())
+          TFTSer.println(live_Zoffset);
+        else {
+          TFTSer.println(getZOffset_mm());
+          selectedmeshpoint.x = selectedmeshpoint.y = 99;
+        }
+      }
+
+      else {
+        int8_t tokenpos = FindToken('S');
+        if (tokenpos != -1) { // Set offset (adjusts all points by value)
+          float Zshift = atof(&panel_command[tokenpos+1]);
+          setSoftEndstopState(false);  // disable endstops
+          // Allow temporary Z position nudging during print
+          // From the leveling panel use the all points UI to adjust the print pos.
+          if (isPrinting()) {
+            #if ACDEBUG(AC_INFO)
+              SERIAL_ECHOLNPAIR("Change Zoffset from:", live_Zoffset, " to ", live_Zoffset + Zshift);
+            #endif
+            if (isAxisPositionKnown(Z)) {
+              #if ACDEBUG(AC_INFO)
+                const float currZpos = getAxisPosition_mm(Z);
+                SERIAL_ECHOLNPAIR("Nudge Z pos from ", currZpos, " to ", currZpos + constrain(Zshift, -0.05, 0.05));
+              #endif
+              // Use babystepping to adjust the head position
+              int16_t steps = mmToWholeSteps(constrain(Zshift,-0.05,0.05), Z);
+              #if ACDEBUG(AC_INFO)
+                SERIAL_ECHOLNPAIR("Steps to move Z: ", steps);
+              #endif
+              babystepAxis_steps(steps, Z);
+              live_Zoffset += Zshift;
+            }
+            SendtoTFT(PSTR("A31V "));
+            TFTSer.println(live_Zoffset);
+          }
+          else {
+            GRID_LOOP(x, y) {
+              const xy_uint8_t pos { x, y };
+              const float currval = getMeshPoint(pos);
+              setMeshPoint(pos, constrain(currval + Zshift, AC_LOWEST_MESHPOINT_VAL, 2));
+              #if ACDEBUG(AC_INFO)
+                SERIAL_ECHOLNPAIR("Change mesh point X", x," Y",y ," from ", currval, " to ", getMeshPoint(pos) );
+              #endif
+            }
+            const float currZOffset = getZOffset_mm();
+            #if ACDEBUG(AC_INFO)
+              SERIAL_ECHOLNPAIR("Change probe offset from ", currZOffset, " to  ", currZOffset + Zshift);
+            #endif
+
+            setZOffset_mm(currZOffset + Zshift);
+            SendtoTFT(PSTR("A31V "));
+            TFTSer.println(getZOffset_mm());
+
+            if (isAxisPositionKnown(Z)) {
+              // Move Z axis
+              const float currZpos = getAxisPosition_mm(Z);
+              #if ACDEBUG(AC_INFO)
+                SERIAL_ECHOLNPAIR("Move Z pos from ", currZpos, " to ", currZpos + constrain(Zshift, -0.05, 0.05));
+              #endif
+              setAxisPosition_mm(currZpos+constrain(Zshift,-0.05,0.05),Z);
+            }
+          }
+        }
+      }
+    } break;
+
+    case 32: { // A32 clean leveling beep flag
+      // Ignore request if printing
+      //if (isPrinting()) break;
+      //injectCommands_P(PSTR("M500\nM420 S1\nG1 Z10 F240\nG1 X0 Y0 F6000"));
+      //TFTSer.println();
+    } break;
+
+    // A33 firmware info request see PanelInfo()
+
+    case 34: {  // A34 Adjust single mesh point A34 C/S X1 Y1 V123
+      if (panel_command[3] == 'C') { // Restore original offsets
+        injectCommands_P(PSTR("M501\nM420 S1"));
+        selectedmeshpoint.x = selectedmeshpoint.y = 99;
+        //printer_state = AC_printer_idle;
+      }
+      else {
+        xy_uint8_t pos;
+        pos.x = atoi(&panel_command[5]);
+        pos.y = atoi(&panel_command[8]);
+
+        float currmesh = getMeshPoint(pos);
+        float newval   = atof(&panel_command[11])/100;
+        #if ACDEBUG(AC_INFO)
+          SERIAL_ECHOLNPAIR("Change mesh point x:", pos.x, " y:", pos.y);
+          SERIAL_ECHOLNPAIR("from ", currmesh, " to ", newval);
+        #endif
+        // Update Meshpoint
+        setMeshPoint(pos,newval);
+        if (printer_state == AC_printer_idle || printer_state == AC_printer_probing /*!isPrinting()*/) {
+          // if we are at the current mesh point indicated on the panel Move Z pos +/- 0.05mm
+          // (The panel changes the mesh value by +/- 0.05mm on each button press)
+          if (selectedmeshpoint.x == pos.x && selectedmeshpoint.y == pos.y) {
+            setSoftEndstopState(false);
+            float currZpos = getAxisPosition_mm(Z);
+            #if ACDEBUG(AC_INFO)
+              SERIAL_ECHOLNPAIR("Move Z pos from ", currZpos, " to ", currZpos + constrain(newval - currmesh, -0.05, 0.05));
+            #endif
+            setAxisPosition_mm(currZpos + constrain(newval - currmesh, -0.05, 0.05), Z);
+          }
+        }
+      }
+    }  break;
+
+    case 36:    // A36 Auto leveling for new TFT bet that was a typo in the panel code!
+      SendtoTFTLN(AC_msg_start_probing);
+      break;
+  }
+}
+
+bool ChironTFT::GetLastError() {
+  switch (last_error) {
+    case AC_error_abnormal_temp_bed: SendtoTFTLN(AC_msg_error_bed_temp);    break;
+    case AC_error_abnormal_temp_t0:  SendtoTFTLN(AC_msg_error_hotend_temp); break;
+    case AC_error_noSD:              SendtoTFTLN(AC_msg_error_sd_card);     break;
+    case AC_error_powerloss:         SendtoTFTLN(AC_msg_power_loss);        break;
+    case AC_error_EEPROM:            SendtoTFTLN(AC_msg_eeprom_version);    break;
+    case AC_error_filament_runout:   SendtoTFTLN(AC_msg_filament_out);      break;
+    default: return false;
+  }
+  last_error = AC_error_none;
+  return true;
+}
+
+} // Anycubic namespace
+
+#endif // ANYCUBIC_LCD_CHIRON
