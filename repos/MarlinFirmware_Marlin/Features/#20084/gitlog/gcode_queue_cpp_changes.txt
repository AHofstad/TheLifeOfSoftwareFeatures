commit ab3497161a37ae309e030a23e0f8e3f3eb61daea
Author: ThomasToka <117008525+ThomasToka@users.noreply.github.com>
Date:   Fri Jan 12 06:56:45 2024 +0100

    üêõ Fix PLR pos/sdpos (#26365)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index db06af82f0..6b34a3b46b 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -91,6 +91,10 @@ PGM_P GCodeQueue::injected_commands_P; // = nullptr
  */
 char GCodeQueue::injected_commands[64]; // = { 0 }
 
+/**
+ * Commit the accumulated G-code command to the ring buffer,
+ * also setting its origin info.
+ */
 void GCodeQueue::RingBuffer::commit_command(const bool skip_ok
   OPTARG(HAS_MULTI_SERIAL, serial_index_t serial_ind/*=-1*/)
 ) {

commit be1dee7caf8197f10811574265714e78ca08ec83
Author: Orel <37673727+0r31@users.noreply.github.com>
Date:   Wed Jan 3 21:02:20 2024 +0100

    üé® Clean up old #includes (#26621)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 9ce28f781c..db06af82f0 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -37,14 +37,6 @@ GCodeQueue queue;
 #include "../MarlinCore.h"
 #include "../core/bug_on.h"
 
-#if ENABLED(PRINTER_EVENT_LEDS)
-  #include "../feature/leds/printer_event_leds.h"
-#endif
-
-#if HAS_ETHERNET
-  #include "../feature/ethernet.h"
-#endif
-
 #if ENABLED(BINARY_FILE_TRANSFER)
   #include "../feature/binary_stream.h"
 #endif

commit 2ef71c6ebaa1f1b496eb369879fe22c69cf9adb4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jun 12 16:38:14 2023 -0500

    ‚ôªÔ∏è Simplify SERIAL_ECHO (#25928)
    
    Since this increases AVR code size, try to optimize further.

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 967ab76897..9ce28f781c 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -324,7 +324,7 @@ inline int read_serial(const serial_index_t index) { return SERIAL_IMPL.read(ind
 void GCodeQueue::gcode_line_error(FSTR_P const ferr, const serial_index_t serial_ind) {
   PORT_REDIRECT(SERIAL_PORTMASK(serial_ind)); // Reply to the serial port that sent the command
   SERIAL_ERROR_START();
-  SERIAL_ECHOLNF(ferr, serial_state[serial_ind.index].last_N);
+  SERIAL_ECHOLN(ferr, serial_state[serial_ind.index].last_N);
   while (read_serial(serial_ind) != -1) { /* nada */ } // Clear out the RX buffer. Why don't use flush here ?
   flush_and_request_resend(serial_ind);
   serial_state[serial_ind.index].count = 0;

commit f8423f9da09a8d67074b4243917953a6b2b8d279
Author: kisslorand <50251547+kisslorand@users.noreply.github.com>
Date:   Sun Jun 4 12:49:27 2023 +0300

    ü©π Fix D576 buffer underrun reporting (#25931)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 156436b7dd..967ab76897 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -713,8 +713,8 @@ void GCodeQueue::advance() {
 
   void GCodeQueue::report_buffer_statistics() {
     SERIAL_ECHOLNPGM("D576"
-      " P:", planner.moves_free(),         " ", -planner_buffer_underruns, " (", max_planner_buffer_empty_duration, ")"
-      " B:", BUFSIZE - ring_buffer.length, " ", -command_buffer_underruns, " (", max_command_buffer_empty_duration, ")"
+      " P:", planner.moves_free(),         " ", planner_buffer_underruns, " (", max_planner_buffer_empty_duration, ")"
+      " B:", BUFSIZE - ring_buffer.length, " ", command_buffer_underruns, " (", max_command_buffer_empty_duration, ")"
     );
     command_buffer_underruns = planner_buffer_underruns = 0;
     max_command_buffer_empty_duration = max_planner_buffer_empty_duration = 0;

commit 86c811660ebf0b3fcbae2f34273d4c9d0c22abc4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:30:34 2023 -0500

    üßë‚Äçüíª Remove LOOP macros (#25917)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index b64aa95112..156436b7dd 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -294,7 +294,7 @@ static bool serial_data_available(serial_index_t index) {
 #if NO_TIMEOUTS > 0
   // Multiserial already handles dispatch to/from multiple ports
   static bool any_serial_data_available() {
-    LOOP_L_N(p, NUM_SERIAL)
+    for (uint8_t p = 0; p < NUM_SERIAL; ++p)
       if (serial_data_available(p))
         return true;
     return false;
@@ -313,7 +313,7 @@ inline int read_serial(const serial_index_t index) { return SERIAL_IMPL.read(ind
    */
   void GCodeQueue::flush_rx() {
     // Flush receive buffer
-    LOOP_L_N(p, NUM_SERIAL) {
+    for (uint8_t p = 0; p < NUM_SERIAL; ++p) {
       if (!serial_data_available(p)) continue; // No data for this port? Skip.
       while (SERIAL_IMPL.available(p)) (void)read_serial(p);
     }
@@ -441,7 +441,7 @@ void GCodeQueue::get_serial_commands() {
     // Unless a serial port has data, this will exit on next iteration
     hadData = false;
 
-    LOOP_L_N(p, NUM_SERIAL) {
+    for (uint8_t p = 0; p < NUM_SERIAL; ++p) {
       // Check if the queue is full and exit if it is.
       if (ring_buffer.full()) return;
 

commit 4812ed5053983212c9ec8a6229a150a1af7822f1
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon May 1 18:45:42 2023 -0500

    üé® Misc. code cleanup

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index af8e877436..b64aa95112 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -99,7 +99,7 @@ PGM_P GCodeQueue::injected_commands_P; // = nullptr
  */
 char GCodeQueue::injected_commands[64]; // = { 0 }
 
-void GCodeQueue::RingBuffer::commit_command(bool skip_ok
+void GCodeQueue::RingBuffer::commit_command(const bool skip_ok
   OPTARG(HAS_MULTI_SERIAL, serial_index_t serial_ind/*=-1*/)
 ) {
   commands[index_w].skip_ok = skip_ok;
@@ -113,7 +113,7 @@ void GCodeQueue::RingBuffer::commit_command(bool skip_ok
  * Return true if the command was successfully added.
  * Return false for a full buffer, or if the 'command' is a comment.
  */
-bool GCodeQueue::RingBuffer::enqueue(const char *cmd, bool skip_ok/*=true*/
+bool GCodeQueue::RingBuffer::enqueue(const char *cmd, const bool skip_ok/*=true*/
   OPTARG(HAS_MULTI_SERIAL, serial_index_t serial_ind/*=-1*/)
 ) {
   if (*cmd == ';' || length >= BUFSIZE) return false;

commit 5664c02d077e028f84a24efd96c2eebe97ce8763
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 22 22:43:09 2023 -0500

    üßë‚Äçüíª Generalize SDSUPPORT as HAS_MEDIA
    
    In preparation for single- and multi-volume refactoring.

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index edf0ddfdbf..af8e877436 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -512,7 +512,7 @@ void GCodeQueue::get_serial_commands() {
 
           serial.last_N = gcode_N;
         }
-        #if ENABLED(SDSUPPORT)
+        #if HAS_MEDIA
           // Pronterface "M29" and "M29 " has no line number
           else if (card.flag.saving && !is_M29(command)) {
             gcode_line_error(F(STR_ERR_NO_CHECKSUM), p);
@@ -562,7 +562,7 @@ void GCodeQueue::get_serial_commands() {
   } // queue has space, serial has data
 }
 
-#if ENABLED(SDSUPPORT)
+#if HAS_MEDIA
 
   /**
    * Get lines from the SD Card until the command buffer is full
@@ -615,7 +615,7 @@ void GCodeQueue::get_serial_commands() {
     }
   }
 
-#endif // SDSUPPORT
+#endif // HAS_MEDIA
 
 /**
  * Add to the circular command queue the next command from:
@@ -628,7 +628,7 @@ void GCodeQueue::get_available_commands() {
 
   get_serial_commands();
 
-  TERN_(SDSUPPORT, get_sdcard_commands());
+  TERN_(HAS_MEDIA, get_sdcard_commands());
 }
 
 /**
@@ -667,7 +667,7 @@ void GCodeQueue::advance() {
     }
   #endif
 
-  #if ENABLED(SDSUPPORT)
+  #if HAS_MEDIA
 
     if (card.flag.saving) {
       char * const cmd = ring_buffer.peek_next_command_string();
@@ -703,7 +703,7 @@ void GCodeQueue::advance() {
 
     gcode.process_next_command();
 
-  #endif // SDSUPPORT
+  #endif // HAS_MEDIA
 
   // The queue may be reset by a command handler or by code invoked by idle() within a handler
   ring_buffer.advance_pos(ring_buffer.index_r, -1);

commit 0021a58943721a81b1ef23fa5e7366cfd80a3d28
Author: Bob Kuhn <bob.kuhn@att.net>
Date:   Sun Mar 26 04:07:25 2023 -0500

    ‚ú® AnyCubic Vyper / Vyper LCD (#25405)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index c951fc6333..edf0ddfdbf 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -303,6 +303,24 @@ static bool serial_data_available(serial_index_t index) {
 
 inline int read_serial(const serial_index_t index) { return SERIAL_IMPL.read(index); }
 
+#if (defined(ARDUINO_ARCH_STM32F4) || defined(ARDUINO_ARCH_STM32)) && defined(USBCON)
+
+  /**
+   * arduinoststm32's USB receive buffer is not well behaved when the buffer overflows
+   *
+   * This can happen when the host programs (such as Pronterface) automatically
+   * send M105 temperature requests.
+   */
+  void GCodeQueue::flush_rx() {
+    // Flush receive buffer
+    LOOP_L_N(p, NUM_SERIAL) {
+      if (!serial_data_available(p)) continue; // No data for this port? Skip.
+      while (SERIAL_IMPL.available(p)) (void)read_serial(p);
+    }
+  }
+
+#endif // (ARDUINO_ARCH_STM32F4 || ARDUINO_ARCH_STM32) && USBCON
+
 void GCodeQueue::gcode_line_error(FSTR_P const ferr, const serial_index_t serial_ind) {
   PORT_REDIRECT(SERIAL_PORTMASK(serial_ind)); // Reply to the serial port that sent the command
   SERIAL_ERROR_START();

commit 791de408857258f448c7462d7b296a3f526f2c5d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Nov 27 23:23:00 2022 -0600

    üêõ Fix G-code resend race condition
    
    As pointed out in #24972 by @silycr, but simplified.

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index a390a46d8e..c951fc6333 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -469,8 +469,11 @@ void GCodeQueue::get_serial_commands() {
 
           const long gcode_N = strtol(npos + 1, nullptr, 10);
 
+          // The line number must be in the correct sequence.
           if (gcode_N != serial.last_N + 1 && !M110) {
-            // In case of error on a serial port, don't prevent other serial port from making progress
+            // A request-for-resend line was already in transit so we got two - oops!
+            if (WITHIN(gcode_N, serial.last_N - 1, serial.last_N)) continue;
+            // A corrupted line or too high, indicating a lost line
             gcode_line_error(F(STR_ERR_LINE_NO), p);
             break;
           }
@@ -480,13 +483,11 @@ void GCodeQueue::get_serial_commands() {
             uint8_t checksum = 0, count = uint8_t(apos - command);
             while (count) checksum ^= command[--count];
             if (strtol(apos + 1, nullptr, 10) != checksum) {
-              // In case of error on a serial port, don't prevent other serial port from making progress
               gcode_line_error(F(STR_ERR_CHECKSUM_MISMATCH), p);
               break;
             }
           }
           else {
-            // In case of error on a serial port, don't prevent other serial port from making progress
             gcode_line_error(F(STR_ERR_NO_CHECKSUM), p);
             break;
           }

commit 54e7b933cdb6d0bf0d69fd661b585100d76e3c88
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jul 3 10:32:47 2022 -0500

    ‚ôªÔ∏è Encapsulate PID in class (#24389)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 454a009b85..a390a46d8e 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -384,7 +384,7 @@ inline bool process_line_done(uint8_t &sis, char (&buff)[MAX_CMD_SIZE], int &ind
   buff[ind] = '\0';                   // Of course, I'm a Terminator.
   const bool is_empty = (ind == 0);   // An empty line?
   if (is_empty)
-    thermalManager.manage_heater();   // Keep sensors satisfied
+    thermalManager.task();            // Keep sensors satisfied
   else
     ind = 0;                          // Start a new line
   return is_empty;                    // Inform the caller

commit 640282b8dc5de4ccdfb607b99e795d3eaa1334a7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jun 13 20:43:23 2022 -0500

    üßë‚Äçüíª Apply F() to some LCD / TFT strings
    
    Followup to #24228

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 2250cd3b74..454a009b85 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -196,14 +196,15 @@ bool GCodeQueue::process_injected_command() {
  * Never call this from a G-code handler!
  */
 void GCodeQueue::enqueue_one_now(const char * const cmd) { while (!enqueue_one(cmd)) idle(); }
+void GCodeQueue::enqueue_one_now(FSTR_P const fcmd) { while (!enqueue_one(fcmd)) idle(); }
 
 /**
  * Attempt to enqueue a single G-code command
  * and return 'true' if successful.
  */
-bool GCodeQueue::enqueue_one(FSTR_P const fgcode) {
+bool GCodeQueue::enqueue_one(FSTR_P const fcmd) {
   size_t i = 0;
-  PGM_P p = FTOP(fgcode);
+  PGM_P p = FTOP(fcmd);
   char c;
   while ((c = pgm_read_byte(&p[i])) && c != '\n') i++;
   char cmd[i + 1];

commit ab46b7e2f298826a5512569d6e79bb59a7a6b8ea
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jan 25 15:33:03 2022 -0600

    üßë‚Äçüíª HAS_MARLINUI_MENU, HAS_MANUAL_MOVE_MENU

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index cc52a3bb9e..2250cd3b74 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -522,7 +522,7 @@ void GCodeQueue::get_serial_commands() {
         #if DISABLED(EMERGENCY_PARSER)
           // Process critical commands early
           if (command[0] == 'M') switch (command[3]) {
-            case '8': if (command[2] == '0' && command[1] == '1') { wait_for_heatup = false; TERN_(HAS_LCD_MENU, wait_for_user = false); } break;
+            case '8': if (command[2] == '0' && command[1] == '1') { wait_for_heatup = false; TERN_(HAS_MARLINUI_MENU, wait_for_user = false); } break;
             case '2': if (command[2] == '1' && command[1] == '1') kill(FPSTR(M112_KILL_STR), nullptr, true); break;
             case '0': if (command[1] == '4' && command[2] == '1') quickstop_stepper(); break;
           }

commit de398b4fd2f96349e73d63512021a3fca800712d
Author: Robby Candra <robbycandra.mail@gmail.com>
Date:   Wed Nov 24 04:19:32 2021 +0700

    üêõ Fix serial_data_available (#23160)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index fd98a39cd6..cc52a3bb9e 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -281,7 +281,7 @@ void GCodeQueue::flush_and_request_resend(const serial_index_t serial_ind) {
 
 static bool serial_data_available(serial_index_t index) {
   const int a = SERIAL_IMPL.available(index);
-  #if BOTH(RX_BUFFER_MONITOR, RX_BUFFER_SIZE)
+  #if ENABLED(RX_BUFFER_MONITOR) && RX_BUFFER_SIZE
     if (a > RX_BUFFER_SIZE - 2) {
       PORT_REDIRECT(SERIAL_PORTMASK(index));
       SERIAL_ERROR_MSG("RX BUF overflow, increase RX_BUFFER_SIZE: ", a);

commit 3f6c8d5dc56938f95edaecddf20e9b76aec6df29
Author: somehibs <hibs@circuitco.de>
Date:   Wed Oct 27 21:00:02 2021 +0100

    üêõ Fix serial PORT_RESTORE (and BUFFER_MONITORING) (#23022)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index cc072e51a1..fd98a39cd6 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -719,7 +719,7 @@ void GCodeQueue::advance() {
 
     if (auto_buffer_report_interval && ELAPSED(ms, next_buffer_report_ms)) {
       next_buffer_report_ms = ms + 1000UL * auto_buffer_report_interval;
-      PORT_REDIRECT(SERIAL_BOTH);
+      PORT_REDIRECT(SerialMask::All);
       report_buffer_statistics();
       PORT_RESTORE();
     }

commit 65b950a489c35b1d5547da3a504af4dad8cde3d7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 28 20:15:52 2021 -0500

    üé® Apply F() to kill / sendinfoscreen

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 9c3175da58..cc072e51a1 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -523,7 +523,7 @@ void GCodeQueue::get_serial_commands() {
           // Process critical commands early
           if (command[0] == 'M') switch (command[3]) {
             case '8': if (command[2] == '0' && command[1] == '1') { wait_for_heatup = false; TERN_(HAS_LCD_MENU, wait_for_user = false); } break;
-            case '2': if (command[2] == '1' && command[1] == '1') kill(M112_KILL_STR, nullptr, true); break;
+            case '2': if (command[2] == '1' && command[1] == '1') kill(FPSTR(M112_KILL_STR), nullptr, true); break;
             case '0': if (command[1] == '4' && command[2] == '1') quickstop_stepper(); break;
           }
         #endif

commit 1dafd1887e40399faf16e3455e3670ed3acfac52
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 27 13:46:42 2021 -0500

    üé® Apply F() to various reports

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 5424809699..9c3175da58 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -302,10 +302,10 @@ static bool serial_data_available(serial_index_t index) {
 
 inline int read_serial(const serial_index_t index) { return SERIAL_IMPL.read(index); }
 
-void GCodeQueue::gcode_line_error(PGM_P const err, const serial_index_t serial_ind) {
+void GCodeQueue::gcode_line_error(FSTR_P const ferr, const serial_index_t serial_ind) {
   PORT_REDIRECT(SERIAL_PORTMASK(serial_ind)); // Reply to the serial port that sent the command
   SERIAL_ERROR_START();
-  SERIAL_ECHOLNPGM_P(err, serial_state[serial_ind.index].last_N);
+  SERIAL_ECHOLNF(ferr, serial_state[serial_ind.index].last_N);
   while (read_serial(serial_ind) != -1) { /* nada */ } // Clear out the RX buffer. Why don't use flush here ?
   flush_and_request_resend(serial_ind);
   serial_state[serial_ind.index].count = 0;
@@ -470,7 +470,7 @@ void GCodeQueue::get_serial_commands() {
 
           if (gcode_N != serial.last_N + 1 && !M110) {
             // In case of error on a serial port, don't prevent other serial port from making progress
-            gcode_line_error(PSTR(STR_ERR_LINE_NO), p);
+            gcode_line_error(F(STR_ERR_LINE_NO), p);
             break;
           }
 
@@ -480,13 +480,13 @@ void GCodeQueue::get_serial_commands() {
             while (count) checksum ^= command[--count];
             if (strtol(apos + 1, nullptr, 10) != checksum) {
               // In case of error on a serial port, don't prevent other serial port from making progress
-              gcode_line_error(PSTR(STR_ERR_CHECKSUM_MISMATCH), p);
+              gcode_line_error(F(STR_ERR_CHECKSUM_MISMATCH), p);
               break;
             }
           }
           else {
             // In case of error on a serial port, don't prevent other serial port from making progress
-            gcode_line_error(PSTR(STR_ERR_NO_CHECKSUM), p);
+            gcode_line_error(F(STR_ERR_NO_CHECKSUM), p);
             break;
           }
 
@@ -495,7 +495,7 @@ void GCodeQueue::get_serial_commands() {
         #if ENABLED(SDSUPPORT)
           // Pronterface "M29" and "M29 " has no line number
           else if (card.flag.saving && !is_M29(command)) {
-            gcode_line_error(PSTR(STR_ERR_NO_CHECKSUM), p);
+            gcode_line_error(F(STR_ERR_NO_CHECKSUM), p);
             break;
           }
         #endif

commit 7f1286a11f87065c4e666985e679cf9c77d668bf
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 25 17:05:11 2021 -0500

    üé® Apply F() to status message

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 063f76bd85..5424809699 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -513,7 +513,7 @@ void GCodeQueue::get_serial_commands() {
               TERN_(BEZIER_CURVE_SUPPORT, case 5:)
                 PORT_REDIRECT(SERIAL_PORTMASK(p));     // Reply to the serial port that sent the command
                 SERIAL_ECHOLNPGM(STR_ERR_STOPPED);
-                LCD_MESSAGEPGM(MSG_STOPPED);
+                LCD_MESSAGE(MSG_STOPPED);
                 break;
             }
           }

commit 417e2530ebc5b6c74ac34adaba8be552b407383a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 25 21:11:31 2021 -0500

    üé® Apply F() to G-code suite and queue

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 8ffa043b51..063f76bd85 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -126,7 +126,7 @@ bool GCodeQueue::RingBuffer::enqueue(const char *cmd, bool skip_ok/*=true*/
  * Enqueue with Serial Echo
  * Return true if the command was consumed
  */
-bool GCodeQueue::enqueue_one(const char *cmd) {
+bool GCodeQueue::enqueue_one(const char * const cmd) {
   //SERIAL_ECHOLNPGM("enqueue_one(\"", cmd, "\")");
 
   if (*cmd == 0 || ISEOL(*cmd)) return true;
@@ -195,15 +195,15 @@ bool GCodeQueue::process_injected_command() {
  * Enqueue and return only when commands are actually enqueued.
  * Never call this from a G-code handler!
  */
-void GCodeQueue::enqueue_one_now(const char *cmd) { while (!enqueue_one(cmd)) idle(); }
+void GCodeQueue::enqueue_one_now(const char * const cmd) { while (!enqueue_one(cmd)) idle(); }
 
 /**
  * Attempt to enqueue a single G-code command
  * and return 'true' if successful.
  */
-bool GCodeQueue::enqueue_one_P(PGM_P const pgcode) {
+bool GCodeQueue::enqueue_one(FSTR_P const fgcode) {
   size_t i = 0;
-  PGM_P p = pgcode;
+  PGM_P p = FTOP(fgcode);
   char c;
   while ((c = pgm_read_byte(&p[i])) && c != '\n') i++;
   char cmd[i + 1];

commit 59dac3a7e41ae7964686d9dff56baba821a278f7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 25 18:43:52 2021 -0500

    üé® Apply F() to G-code subcommands

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index d11b2823f2..8ffa043b51 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -693,8 +693,8 @@ void GCodeQueue::advance() {
 
   void GCodeQueue::report_buffer_statistics() {
     SERIAL_ECHOLNPGM("D576"
-      " P:", planner.moves_free(),         " ", -queue.planner_buffer_underruns, " (", queue.max_planner_buffer_empty_duration, ")"
-      " B:", BUFSIZE - ring_buffer.length, " ", -queue.command_buffer_underruns, " (", queue.max_command_buffer_empty_duration, ")"
+      " P:", planner.moves_free(),         " ", -planner_buffer_underruns, " (", max_planner_buffer_empty_duration, ")"
+      " B:", BUFSIZE - ring_buffer.length, " ", -command_buffer_underruns, " (", max_command_buffer_empty_duration, ")"
     );
     command_buffer_underruns = planner_buffer_underruns = 0;
     max_command_buffer_empty_duration = max_planner_buffer_empty_duration = 0;
@@ -717,8 +717,8 @@ void GCodeQueue::advance() {
       NOLESS(max_planner_buffer_empty_duration, planner_buffer_empty_duration); // if it's longer than the currently tracked max duration, replace it
     }
 
-    if (queue.auto_buffer_report_interval && ELAPSED(ms, queue.next_buffer_report_ms)) {
-      queue.next_buffer_report_ms = ms + 1000UL * queue.auto_buffer_report_interval;
+    if (auto_buffer_report_interval && ELAPSED(ms, next_buffer_report_ms)) {
+      next_buffer_report_ms = ms + 1000UL * auto_buffer_report_interval;
       PORT_REDIRECT(SERIAL_BOTH);
       report_buffer_statistics();
       PORT_RESTORE();

commit dc5bef62ba185461ba969db6af996ebc93a33ba7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 23 10:01:37 2021 -0500

    üé® Various multi-axis patches (#22823)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 07d7c536a6..d11b2823f2 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -260,8 +260,7 @@ void GCodeQueue::RingBuffer::ok_to_send() {
       while (NUMERIC_SIGNED(*p))
         SERIAL_CHAR(*p++);
     }
-    SERIAL_ECHOPGM_P(SP_P_STR, planner.moves_free(),
-                      SP_B_STR, BUFSIZE - length);
+    SERIAL_ECHOPGM_P(SP_P_STR, planner.moves_free(), SP_B_STR, BUFSIZE - length);
   #endif
   SERIAL_EOL();
 }

commit 754b31918a73cb08c322102be5d3926d2ac59c18
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 9 04:57:05 2021 -0500

    üé® Fewer serial macros

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 37acc8d58c..07d7c536a6 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -127,7 +127,7 @@ bool GCodeQueue::RingBuffer::enqueue(const char *cmd, bool skip_ok/*=true*/
  * Return true if the command was consumed
  */
 bool GCodeQueue::enqueue_one(const char *cmd) {
-  //SERIAL_ECHOLNPAIR("enqueue_one(\"", cmd, "\")");
+  //SERIAL_ECHOLNPGM("enqueue_one(\"", cmd, "\")");
 
   if (*cmd == 0 || ISEOL(*cmd)) return true;
 
@@ -260,7 +260,7 @@ void GCodeQueue::RingBuffer::ok_to_send() {
       while (NUMERIC_SIGNED(*p))
         SERIAL_CHAR(*p++);
     }
-    SERIAL_ECHOPAIR_P(SP_P_STR, planner.moves_free(),
+    SERIAL_ECHOPGM_P(SP_P_STR, planner.moves_free(),
                       SP_B_STR, BUFSIZE - length);
   #endif
   SERIAL_EOL();
@@ -276,7 +276,7 @@ void GCodeQueue::flush_and_request_resend(const serial_index_t serial_ind) {
     PORT_REDIRECT(SERIAL_PORTMASK(serial_ind));   // Reply to the serial port that sent the command
   #endif
   SERIAL_FLUSH();
-  SERIAL_ECHOLNPAIR(STR_RESEND, serial_state[serial_ind.index].last_N + 1);
+  SERIAL_ECHOLNPGM(STR_RESEND, serial_state[serial_ind.index].last_N + 1);
   SERIAL_ECHOLNPGM(STR_OK);
 }
 
@@ -306,7 +306,7 @@ inline int read_serial(const serial_index_t index) { return SERIAL_IMPL.read(ind
 void GCodeQueue::gcode_line_error(PGM_P const err, const serial_index_t serial_ind) {
   PORT_REDIRECT(SERIAL_PORTMASK(serial_ind)); // Reply to the serial port that sent the command
   SERIAL_ERROR_START();
-  SERIAL_ECHOLNPAIR_P(err, serial_state[serial_ind.index].last_N);
+  SERIAL_ECHOLNPGM_P(err, serial_state[serial_ind.index].last_N);
   while (read_serial(serial_ind) != -1) { /* nada */ } // Clear out the RX buffer. Why don't use flush here ?
   flush_and_request_resend(serial_ind);
   serial_state[serial_ind.index].count = 0;
@@ -659,10 +659,10 @@ void GCodeQueue::advance() {
 
         #if !defined(__AVR__) || !defined(USBCON)
           #if ENABLED(SERIAL_STATS_DROPPED_RX)
-            SERIAL_ECHOLNPAIR("Dropped bytes: ", MYSERIAL1.dropped());
+            SERIAL_ECHOLNPGM("Dropped bytes: ", MYSERIAL1.dropped());
           #endif
           #if ENABLED(SERIAL_STATS_MAX_RX_QUEUED)
-            SERIAL_ECHOLNPAIR("Max RX Queue Size: ", MYSERIAL1.rxMaxEnqueued());
+            SERIAL_ECHOLNPGM("Max RX Queue Size: ", MYSERIAL1.rxMaxEnqueued());
           #endif
         #endif
 
@@ -693,7 +693,7 @@ void GCodeQueue::advance() {
 #if ENABLED(BUFFER_MONITORING)
 
   void GCodeQueue::report_buffer_statistics() {
-    SERIAL_ECHOLNPAIR("D576"
+    SERIAL_ECHOLNPGM("D576"
       " P:", planner.moves_free(),         " ", -queue.planner_buffer_underruns, " (", queue.max_planner_buffer_empty_duration, ")"
       " B:", BUFSIZE - ring_buffer.length, " ", -queue.command_buffer_underruns, " (", queue.max_command_buffer_empty_duration, ")"
     );

commit 536cf287a6f642aa3eccd290b421b0e3869f018a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Aug 21 18:00:55 2021 -0500

    üé® Misc code and spacing cleanup

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index fa83c82ddc..37acc8d58c 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -118,11 +118,7 @@ bool GCodeQueue::RingBuffer::enqueue(const char *cmd, bool skip_ok/*=true*/
 ) {
   if (*cmd == ';' || length >= BUFSIZE) return false;
   strcpy(commands[index_w].buffer, cmd);
-  commit_command(skip_ok
-    #if HAS_MULTI_SERIAL
-      , serial_ind
-    #endif
-  );
+  commit_command(skip_ok OPTARG(HAS_MULTI_SERIAL, serial_ind));
   return true;
 }
 
@@ -538,11 +534,7 @@ void GCodeQueue::get_serial_commands() {
         #endif
 
         // Add the command to the queue
-        ring_buffer.enqueue(serial.line_buffer, false
-          #if HAS_MULTI_SERIAL
-            , p
-          #endif
-        );
+        ring_buffer.enqueue(serial.line_buffer, false OPTARG(HAS_MULTI_SERIAL, p));
       }
       else
         process_stream_char(serial_char, serial.input_state, serial.line_buffer, serial.count);

commit 2c49283e97f4bb9cac9577af7c38bcf5e0e06826
Author: chendo <chendo@users.noreply.github.com>
Date:   Fri Jul 23 13:53:00 2021 +1000

    ‚ú® D576 Buffer Monitoring (#19674)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 09755fbf21..fa83c82ddc 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -67,6 +67,23 @@ GCodeQueue::RingBuffer GCodeQueue::ring_buffer = { 0 };
   static millis_t last_command_time = 0;
 #endif
 
+/**
+ * Track buffer underruns
+ */
+#if ENABLED(BUFFER_MONITORING)
+  uint32_t GCodeQueue::command_buffer_underruns = 0,
+           GCodeQueue::planner_buffer_underruns = 0;
+  bool GCodeQueue::command_buffer_empty = false,
+       GCodeQueue::planner_buffer_empty = false;
+  millis_t GCodeQueue::max_command_buffer_empty_duration = 0,
+           GCodeQueue::max_planner_buffer_empty_duration = 0,
+           GCodeQueue::command_buffer_empty_at = 0,
+           GCodeQueue::planner_buffer_empty_at = 0;
+
+  uint8_t GCodeQueue::auto_buffer_report_interval;
+  millis_t GCodeQueue::next_buffer_report_ms;
+#endif
+
 /**
  * Serial command injection
  */
@@ -82,7 +99,6 @@ PGM_P GCodeQueue::injected_commands_P; // = nullptr
  */
 char GCodeQueue::injected_commands[64]; // = { 0 }
 
-
 void GCodeQueue::RingBuffer::commit_command(bool skip_ok
   OPTARG(HAS_MULTI_SERIAL, serial_index_t serial_ind/*=-1*/)
 ) {
@@ -621,7 +637,24 @@ void GCodeQueue::advance() {
   if (process_injected_command_P() || process_injected_command()) return;
 
   // Return if the G-code buffer is empty
-  if (ring_buffer.empty()) return;
+  if (ring_buffer.empty()) {
+    #if ENABLED(BUFFER_MONITORING)
+      if (!command_buffer_empty) {
+        command_buffer_empty = true;
+        command_buffer_underruns++;
+        command_buffer_empty_at = millis();
+      }
+    #endif
+    return;
+  }
+
+  #if ENABLED(BUFFER_MONITORING)
+    if (command_buffer_empty) {
+      command_buffer_empty = false;
+      const millis_t command_buffer_empty_duration = millis() - command_buffer_empty_at;
+      NOLESS(max_command_buffer_empty_duration, command_buffer_empty_duration);
+    }
+  #endif
 
   #if ENABLED(SDSUPPORT)
 
@@ -664,3 +697,41 @@ void GCodeQueue::advance() {
   // The queue may be reset by a command handler or by code invoked by idle() within a handler
   ring_buffer.advance_pos(ring_buffer.index_r, -1);
 }
+
+#if ENABLED(BUFFER_MONITORING)
+
+  void GCodeQueue::report_buffer_statistics() {
+    SERIAL_ECHOLNPAIR("D576"
+      " P:", planner.moves_free(),         " ", -queue.planner_buffer_underruns, " (", queue.max_planner_buffer_empty_duration, ")"
+      " B:", BUFSIZE - ring_buffer.length, " ", -queue.command_buffer_underruns, " (", queue.max_command_buffer_empty_duration, ")"
+    );
+    command_buffer_underruns = planner_buffer_underruns = 0;
+    max_command_buffer_empty_duration = max_planner_buffer_empty_duration = 0;
+  }
+
+  void GCodeQueue::auto_report_buffer_statistics() {
+    // Bit of a hack to try to catch planner buffer underruns without having logic
+    // running inside Stepper::block_phase_isr
+    const millis_t ms = millis();
+    if (planner.movesplanned() == 0) {
+      if (!planner_buffer_empty) { // the planner buffer wasn't empty, but now it is
+        planner_buffer_empty = true;
+        planner_buffer_underruns++;
+        planner_buffer_empty_at = ms;
+      }
+    }
+    else if (planner_buffer_empty) { // the planner buffer was empty, but now it's not
+      planner_buffer_empty = false;
+      const millis_t planner_buffer_empty_duration = ms - planner_buffer_empty_at;
+      NOLESS(max_planner_buffer_empty_duration, planner_buffer_empty_duration); // if it's longer than the currently tracked max duration, replace it
+    }
+
+    if (queue.auto_buffer_report_interval && ELAPSED(ms, queue.next_buffer_report_ms)) {
+      queue.next_buffer_report_ms = ms + 1000UL * queue.auto_buffer_report_interval;
+      PORT_REDIRECT(SERIAL_BOTH);
+      report_buffer_statistics();
+      PORT_RESTORE();
+    }
+  }
+
+#endif // BUFFER_MONITORING

commit 84fd0eff17d089e3f75f6585d4bba47f15c00ba7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 23 21:33:22 2021 -0500

    üé® Macros for optional arguments (#21969)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index c007537398..09755fbf21 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -84,9 +84,7 @@ char GCodeQueue::injected_commands[64]; // = { 0 }
 
 
 void GCodeQueue::RingBuffer::commit_command(bool skip_ok
-  #if HAS_MULTI_SERIAL
-    , serial_index_t serial_ind/*=-1*/
-  #endif
+  OPTARG(HAS_MULTI_SERIAL, serial_index_t serial_ind/*=-1*/)
 ) {
   commands[index_w].skip_ok = skip_ok;
   TERN_(HAS_MULTI_SERIAL, commands[index_w].port = serial_ind);
@@ -100,9 +98,7 @@ void GCodeQueue::RingBuffer::commit_command(bool skip_ok
  * Return false for a full buffer, or if the 'command' is a comment.
  */
 bool GCodeQueue::RingBuffer::enqueue(const char *cmd, bool skip_ok/*=true*/
-  #if HAS_MULTI_SERIAL
-    , serial_index_t serial_ind/*=-1*/
-  #endif
+  OPTARG(HAS_MULTI_SERIAL, serial_index_t serial_ind/*=-1*/)
 ) {
   if (*cmd == ';' || length >= BUFSIZE) return false;
   strcpy(commands[index_w].buffer, cmd);

commit b65cdbed91782c83188706a9c340de9c503cf430
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 8 04:35:35 2021 -0500

    Signal SD completion later (#21840)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 47b7d1febb..c007537398 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -550,7 +550,8 @@ void GCodeQueue::get_serial_commands() {
   inline void GCodeQueue::get_sdcard_commands() {
     static uint8_t sd_input_state = PS_NORMAL;
 
-    if (!IS_SD_PRINTING()) return;
+    // Get commands if there are more in the file
+    if (!IS_SD_FETCHING()) return;
 
     int sd_count = 0;
     while (!ring_buffer.full() && !card.eof()) {

commit 206d495ba4235a79db158fe6687e301bb055623f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri May 7 22:39:34 2021 -0500

    Misc. code cleanup

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 319ebe8a17..47b7d1febb 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -501,13 +501,9 @@ void GCodeQueue::get_serial_commands() {
           char* gpos = strchr(command, 'G');
           if (gpos) {
             switch (strtol(gpos + 1, nullptr, 10)) {
-              case 0: case 1:
-              #if ENABLED(ARC_SUPPORT)
-                case 2: case 3:
-              #endif
-              #if ENABLED(BEZIER_CURVE_SUPPORT)
-                case 5:
-              #endif
+              case 0 ... 1:
+              TERN_(ARC_SUPPORT, case 2 ... 3:)
+              TERN_(BEZIER_CURVE_SUPPORT, case 5:)
                 PORT_REDIRECT(SERIAL_PORTMASK(p));     // Reply to the serial port that sent the command
                 SERIAL_ECHOLNPGM(STR_ERR_STOPPED);
                 LCD_MESSAGEPGM(MSG_STOPPED);

commit 28318f27d98caf256bca238ef712a9de5fc71da6
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu May 6 01:51:19 2021 -0500

    Use SERIAL_ECHOLNPAIR for resend

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 39ec338bbf..319ebe8a17 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -268,8 +268,7 @@ void GCodeQueue::flush_and_request_resend(const serial_index_t serial_ind) {
     PORT_REDIRECT(SERIAL_PORTMASK(serial_ind));   // Reply to the serial port that sent the command
   #endif
   SERIAL_FLUSH();
-  SERIAL_ECHOPGM(STR_RESEND);
-  SERIAL_ECHOLN(serial_state[serial_ind.index].last_N + 1);
+  SERIAL_ECHOLNPAIR(STR_RESEND, serial_state[serial_ind.index].last_N + 1);
   SERIAL_ECHOLNPGM(STR_OK);
 }
 

commit 9405a5e443b78153bf5e2562ed4aaa0be950970b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 4 01:47:42 2021 -0500

    Fix flush_and_request_resend

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index a79909917e..39ec338bbf 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -270,6 +270,7 @@ void GCodeQueue::flush_and_request_resend(const serial_index_t serial_ind) {
   SERIAL_FLUSH();
   SERIAL_ECHOPGM(STR_RESEND);
   SERIAL_ECHOLN(serial_state[serial_ind.index].last_N + 1);
+  SERIAL_ECHOLNPGM(STR_OK);
 }
 
 static bool serial_data_available(serial_index_t index) {

commit 98b2b45264c142053b6ddb015472d4fe2a08c78d
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Apr 4 18:35:58 2021 -0400

    Revert "Optimized string-to-number functions" (#21532)
    
    This reverts #21484

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index eb7ad79102..a79909917e 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -445,7 +445,7 @@ void GCodeQueue::get_serial_commands() {
         if (process_line_done(serial.input_state, serial.line_buffer, serial.count))
           continue;
 
-        char *command = serial.line_buffer;
+        char* command = serial.line_buffer;
 
         while (*command == ' ') command++;                   // Skip leading spaces
         char *npos = (*command == 'N') ? command : nullptr;  // Require the N parameter to start the line
@@ -459,7 +459,7 @@ void GCodeQueue::get_serial_commands() {
             if (n2pos) npos = n2pos;
           }
 
-          const long gcode_N = parse_int32(npos + 1);
+          const long gcode_N = strtol(npos + 1, nullptr, 10);
 
           if (gcode_N != serial.last_N + 1 && !M110) {
             // In case of error on a serial port, don't prevent other serial port from making progress
@@ -471,7 +471,7 @@ void GCodeQueue::get_serial_commands() {
           if (apos) {
             uint8_t checksum = 0, count = uint8_t(apos - command);
             while (count) checksum ^= command[--count];
-            if (parse_int32(apos + 1) != checksum) {
+            if (strtol(apos + 1, nullptr, 10) != checksum) {
               // In case of error on a serial port, don't prevent other serial port from making progress
               gcode_line_error(PSTR(STR_ERR_CHECKSUM_MISMATCH), p);
               break;
@@ -500,7 +500,7 @@ void GCodeQueue::get_serial_commands() {
         if (IsStopped()) {
           char* gpos = strchr(command, 'G');
           if (gpos) {
-            switch (parse_int32(gpos + 1)) {
+            switch (strtol(gpos + 1, nullptr, 10)) {
               case 0: case 1:
               #if ENABLED(ARC_SUPPORT)
                 case 2: case 3:

commit 20d2061f22790bb30cf3b934bef2be54d931293e
Author: Ramiro Polla <ramiropolla@users.noreply.github.com>
Date:   Wed Mar 31 04:20:33 2021 +0200

    Optimized string-to-number functions (#21484)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index a79909917e..eb7ad79102 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -445,7 +445,7 @@ void GCodeQueue::get_serial_commands() {
         if (process_line_done(serial.input_state, serial.line_buffer, serial.count))
           continue;
 
-        char* command = serial.line_buffer;
+        char *command = serial.line_buffer;
 
         while (*command == ' ') command++;                   // Skip leading spaces
         char *npos = (*command == 'N') ? command : nullptr;  // Require the N parameter to start the line
@@ -459,7 +459,7 @@ void GCodeQueue::get_serial_commands() {
             if (n2pos) npos = n2pos;
           }
 
-          const long gcode_N = strtol(npos + 1, nullptr, 10);
+          const long gcode_N = parse_int32(npos + 1);
 
           if (gcode_N != serial.last_N + 1 && !M110) {
             // In case of error on a serial port, don't prevent other serial port from making progress
@@ -471,7 +471,7 @@ void GCodeQueue::get_serial_commands() {
           if (apos) {
             uint8_t checksum = 0, count = uint8_t(apos - command);
             while (count) checksum ^= command[--count];
-            if (strtol(apos + 1, nullptr, 10) != checksum) {
+            if (parse_int32(apos + 1) != checksum) {
               // In case of error on a serial port, don't prevent other serial port from making progress
               gcode_line_error(PSTR(STR_ERR_CHECKSUM_MISMATCH), p);
               break;
@@ -500,7 +500,7 @@ void GCodeQueue::get_serial_commands() {
         if (IsStopped()) {
           char* gpos = strchr(command, 'G');
           if (gpos) {
-            switch (strtol(gpos + 1, nullptr, 10)) {
+            switch (parse_int32(gpos + 1)) {
               case 0: case 1:
               #if ENABLED(ARC_SUPPORT)
                 case 2: case 3:

commit 3b73b115ca9366f0155986b717d4c85c31ed2f80
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 29 20:36:37 2021 -0500

    Apply pointer formatting

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 7845b01ad6..a79909917e 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -99,7 +99,7 @@ void GCodeQueue::RingBuffer::commit_command(bool skip_ok
  * Return true if the command was successfully added.
  * Return false for a full buffer, or if the 'command' is a comment.
  */
-bool GCodeQueue::RingBuffer::enqueue(const char* cmd, bool skip_ok/*=true*/
+bool GCodeQueue::RingBuffer::enqueue(const char *cmd, bool skip_ok/*=true*/
   #if HAS_MULTI_SERIAL
     , serial_index_t serial_ind/*=-1*/
   #endif
@@ -118,7 +118,7 @@ bool GCodeQueue::RingBuffer::enqueue(const char* cmd, bool skip_ok/*=true*/
  * Enqueue with Serial Echo
  * Return true if the command was consumed
  */
-bool GCodeQueue::enqueue_one(const char* cmd) {
+bool GCodeQueue::enqueue_one(const char *cmd) {
   //SERIAL_ECHOLNPAIR("enqueue_one(\"", cmd, "\")");
 
   if (*cmd == 0 || ISEOL(*cmd)) return true;
@@ -187,7 +187,7 @@ bool GCodeQueue::process_injected_command() {
  * Enqueue and return only when commands are actually enqueued.
  * Never call this from a G-code handler!
  */
-void GCodeQueue::enqueue_one_now(const char* cmd) { while (!enqueue_one(cmd)) idle(); }
+void GCodeQueue::enqueue_one_now(const char *cmd) { while (!enqueue_one(cmd)) idle(); }
 
 /**
  * Attempt to enqueue a single G-code command

commit 71f261726381e07fa92f2aac07e8253779a4f487
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 12 08:34:22 2021 -0600

    Pause SD queue early on M25 (#21317)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index b093184c91..7845b01ad6 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -567,7 +567,6 @@ void GCodeQueue::get_serial_commands() {
       const bool is_eol = ISEOL(sd_char);
       if (is_eol || card_eof) {
 
-
         // Reset stream state, terminate the buffer, and commit a non-empty command
         if (!is_eol && sd_count) ++sd_count;          // End of file with no newline
         if (!process_line_done(sd_input_state, command.buffer, sd_count)) {
@@ -575,6 +574,13 @@ void GCodeQueue::get_serial_commands() {
           // M808 L saves the sdpos of the next line. M808 loops to a new sdpos.
           TERN_(GCODE_REPEAT_MARKERS, repeat.early_parse_M808(command.buffer));
 
+          #if DISABLED(PARK_HEAD_ON_PAUSE)
+            // When M25 is non-blocking it can still suspend SD commands
+            // Otherwise the M125 handler needs to know SD printing is active
+            if (command.buffer[0] == 'M' && command.buffer[1] == '2' && command.buffer[2] == '5' && !NUMERIC(command.buffer[3]))
+              card.pauseSDPrint();
+          #endif
+
           // Put the new command into the buffer (no "ok" sent)
           ring_buffer.commit_command(true);
 

commit dbd28eecc9cd4b5954a4fd1ed0c02bd9788c279b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 10 12:05:05 2021 -0600

    Number serial from 1 to match settings

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 6b48000248..b093184c91 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -635,10 +635,10 @@ void GCodeQueue::advance() {
 
         #if !defined(__AVR__) || !defined(USBCON)
           #if ENABLED(SERIAL_STATS_DROPPED_RX)
-            SERIAL_ECHOLNPAIR("Dropped bytes: ", MYSERIAL0.dropped());
+            SERIAL_ECHOLNPAIR("Dropped bytes: ", MYSERIAL1.dropped());
           #endif
           #if ENABLED(SERIAL_STATS_MAX_RX_QUEUED)
-            SERIAL_ECHOLNPAIR("Max RX Queue Size: ", MYSERIAL0.rxMaxEnqueued());
+            SERIAL_ECHOLNPAIR("Max RX Queue Size: ", MYSERIAL1.rxMaxEnqueued());
           #endif
         #endif
 

commit 2c62886c719c67c9ed9a3d0741020a004633a109
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 10 11:35:19 2021 -0600

    Clean up spaces and words

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 4f676eaeb3..6b48000248 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -272,7 +272,7 @@ void GCodeQueue::flush_and_request_resend(const serial_index_t serial_ind) {
   SERIAL_ECHOLN(serial_state[serial_ind.index].last_N + 1);
 }
 
-inline bool serial_data_available(serial_index_t index) {
+static bool serial_data_available(serial_index_t index) {
   const int a = SERIAL_IMPL.available(index);
   #if BOTH(RX_BUFFER_MONITOR, RX_BUFFER_SIZE)
     if (a > RX_BUFFER_SIZE - 2) {
@@ -283,13 +283,15 @@ inline bool serial_data_available(serial_index_t index) {
   return a > 0;
 }
 
-// Multiserial already handles dispatch to/from multiple ports
-inline bool any_serial_data_available() {
-  LOOP_L_N(p, NUM_SERIAL)
-    if (serial_data_available(p))
-      return true;
-  return false;
-}
+#if NO_TIMEOUTS > 0
+  // Multiserial already handles dispatch to/from multiple ports
+  static bool any_serial_data_available() {
+    LOOP_L_N(p, NUM_SERIAL)
+      if (serial_data_available(p))
+        return true;
+    return false;
+  }
+#endif
 
 inline int read_serial(const serial_index_t index) { return SERIAL_IMPL.read(index); }
 

commit fe0b7700335470f03f5b5b8404b126efca8afbb6
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 10 11:33:29 2021 -0600

    Fix serial index types

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 0f4169a2c4..4f676eaeb3 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -393,7 +393,7 @@ void GCodeQueue::get_serial_commands() {
        * receive buffer (which limits the packet size to MAX_CMD_SIZE).
        * The receive buffer also limits the packet size for reliable transmission.
        */
-      binaryStream[card.transfer_port_index].receive(serial_state[card.transfer_port_index].line_buffer);
+      binaryStream[card.transfer_port_index.index].receive(serial_state[card.transfer_port_index.index].line_buffer);
       return;
     }
   #endif

commit bb6d718e19c7c0e6db743b0bc615b17f121f0073
Author: Victor Mateus Oliveira <rhapsodyv@gmail.com>
Date:   Tue Mar 9 20:21:49 2021 -0300

    fix meat pack internal buffer for multi serial

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index a764d80eca..0f4169a2c4 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -288,6 +288,7 @@ inline bool any_serial_data_available() {
   LOOP_L_N(p, NUM_SERIAL)
     if (serial_data_available(p))
       return true;
+  return false;
 }
 
 inline int read_serial(const serial_index_t index) { return SERIAL_IMPL.read(index); }

commit 55c31fbe9a70710c6a209d40b7d0165d081dcdd0
Author: X-Ryl669 <boite.pour.spam@gmail.com>
Date:   Tue Mar 9 10:20:37 2021 +0100

    Distinguish serial index from mask (#21287)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 9b69f9f1fc..a764d80eca 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -240,7 +240,7 @@ void GCodeQueue::RingBuffer::ok_to_send() {
   CommandLine &command = commands[index_r];
   #if HAS_MULTI_SERIAL
     const serial_index_t serial_ind = command.port;
-    if (serial_ind < 0) return;
+    if (!serial_ind.valid()) return;              // Optimization here, skip processing if it's not going anywhere
     PORT_REDIRECT(SERIAL_PORTMASK(serial_ind));   // Reply to the serial port that sent the command
   #endif
   if (command.skip_ok) return;
@@ -264,15 +264,15 @@ void GCodeQueue::RingBuffer::ok_to_send() {
  */
 void GCodeQueue::flush_and_request_resend(const serial_index_t serial_ind) {
   #if HAS_MULTI_SERIAL
-    if (serial_ind < 0) return;                   // Never mind. Command came from SD or Flash Drive
+    if (!serial_ind.valid()) return;              // Optimization here, skip if the command came from SD or Flash Drive
     PORT_REDIRECT(SERIAL_PORTMASK(serial_ind));   // Reply to the serial port that sent the command
   #endif
   SERIAL_FLUSH();
   SERIAL_ECHOPGM(STR_RESEND);
-  SERIAL_ECHOLN(serial_state[serial_ind].last_N + 1);
+  SERIAL_ECHOLN(serial_state[serial_ind.index].last_N + 1);
 }
 
-inline bool serial_data_available(uint8_t index) {
+inline bool serial_data_available(serial_index_t index) {
   const int a = SERIAL_IMPL.available(index);
   #if BOTH(RX_BUFFER_MONITOR, RX_BUFFER_SIZE)
     if (a > RX_BUFFER_SIZE - 2) {
@@ -290,15 +290,15 @@ inline bool any_serial_data_available() {
       return true;
 }
 
-inline int read_serial(const uint8_t index) { return SERIAL_IMPL.read(index); }
+inline int read_serial(const serial_index_t index) { return SERIAL_IMPL.read(index); }
 
 void GCodeQueue::gcode_line_error(PGM_P const err, const serial_index_t serial_ind) {
   PORT_REDIRECT(SERIAL_PORTMASK(serial_ind)); // Reply to the serial port that sent the command
   SERIAL_ERROR_START();
-  SERIAL_ECHOLNPAIR_P(err, serial_state[serial_ind].last_N);
+  SERIAL_ECHOLNPAIR_P(err, serial_state[serial_ind.index].last_N);
   while (read_serial(serial_ind) != -1) { /* nada */ } // Clear out the RX buffer. Why don't use flush here ?
   flush_and_request_resend(serial_ind);
-  serial_state[serial_ind].count = 0;
+  serial_state[serial_ind.index].count = 0;
 }
 
 FORCE_INLINE bool is_M29(const char * const cmd) {  // matches "M29" & "M29 ", but not "M290", etc

commit 1b9ff68f8ce59a2b142bbabd0fad3d3b377b5997
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Mon Mar 8 04:11:37 2021 -0300

    Fix Host Keepalive serial target (#21283)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 136293fd34..9b69f9f1fc 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -272,21 +272,7 @@ void GCodeQueue::flush_and_request_resend(const serial_index_t serial_ind) {
   SERIAL_ECHOLN(serial_state[serial_ind].last_N + 1);
 }
 
-// Multiserial already handle the dispatch to/from multiple port by itself
-inline bool serial_data_available(uint8_t index = SERIAL_ALL) {
-  if (index == SERIAL_ALL) {
-    for (index = 0; index < NUM_SERIAL; index++) {
-      const int a = SERIAL_IMPL.available(index);
-      #if BOTH(RX_BUFFER_MONITOR, RX_BUFFER_SIZE)
-        if (a > RX_BUFFER_SIZE - 2) {
-          PORT_REDIRECT(SERIAL_PORTMASK(index));
-          SERIAL_ERROR_MSG("RX BUF overflow, increase RX_BUFFER_SIZE: ", a);
-        }
-      #endif
-      if (a > 0) return true;
-    }
-    return false;
-  }
+inline bool serial_data_available(uint8_t index) {
   const int a = SERIAL_IMPL.available(index);
   #if BOTH(RX_BUFFER_MONITOR, RX_BUFFER_SIZE)
     if (a > RX_BUFFER_SIZE - 2) {
@@ -294,10 +280,16 @@ inline bool serial_data_available(uint8_t index = SERIAL_ALL) {
       SERIAL_ERROR_MSG("RX BUF overflow, increase RX_BUFFER_SIZE: ", a);
     }
   #endif
-
   return a > 0;
 }
 
+// Multiserial already handles dispatch to/from multiple ports
+inline bool any_serial_data_available() {
+  LOOP_L_N(p, NUM_SERIAL)
+    if (serial_data_available(p))
+      return true;
+}
+
 inline int read_serial(const uint8_t index) { return SERIAL_IMPL.read(index); }
 
 void GCodeQueue::gcode_line_error(PGM_P const err, const serial_index_t serial_ind) {
@@ -409,7 +401,7 @@ void GCodeQueue::get_serial_commands() {
   // send "wait" to indicate Marlin is still waiting.
   #if NO_TIMEOUTS > 0
     const millis_t ms = millis();
-    if (ring_buffer.empty() && !serial_data_available() && ELAPSED(ms, last_command_time + NO_TIMEOUTS)) {
+    if (ring_buffer.empty() && !any_serial_data_available() && ELAPSED(ms, last_command_time + NO_TIMEOUTS)) {
       SERIAL_ECHOLNPGM(STR_WAIT);
       last_command_time = ms;
     }

commit 72cc5a49e6fdcf7246b6bded66a4b4fc043054a3
Author: Sola <42537573+solawc@users.noreply.github.com>
Date:   Sat Mar 6 23:04:05 2021 +0800

    MKS H43 fixup (#21267)
    
    Co-authored-by: makerbase <4164049@qq.com>
    Co-authored-by: MKS-Sean <56996910+MKS-Sean@users.noreply.github.com>
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 93deac0566..136293fd34 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -610,6 +610,14 @@ void GCodeQueue::get_available_commands() {
   TERN_(SDSUPPORT, get_sdcard_commands());
 }
 
+/**
+ * Run the entire queue in-place. Blocks SD completion/abort until complete.
+ */
+void GCodeQueue::exhaust() {
+  while (ring_buffer.occupied()) advance();
+  planner.synchronize();
+}
+
 /**
  * Get the next command in the queue, optionally log it to SD, then dispatch it
  */

commit 101f09aabde0a903051eab12653b1f7dc042bed4
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Thu Mar 4 20:39:08 2021 -0300

    Fix multi-serial CRC error crash (#21249)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index ebf95f86c6..93deac0566 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -262,8 +262,7 @@ void GCodeQueue::RingBuffer::ok_to_send() {
  * Send a "Resend: nnn" message to the host to
  * indicate that a command needs to be re-sent.
  */
-void GCodeQueue::flush_and_request_resend() {
-  const serial_index_t serial_ind = ring_buffer.command_port();
+void GCodeQueue::flush_and_request_resend(const serial_index_t serial_ind) {
   #if HAS_MULTI_SERIAL
     if (serial_ind < 0) return;                   // Never mind. Command came from SD or Flash Drive
     PORT_REDIRECT(SERIAL_PORTMASK(serial_ind));   // Reply to the serial port that sent the command
@@ -306,7 +305,7 @@ void GCodeQueue::gcode_line_error(PGM_P const err, const serial_index_t serial_i
   SERIAL_ERROR_START();
   SERIAL_ECHOLNPAIR_P(err, serial_state[serial_ind].last_N);
   while (read_serial(serial_ind) != -1) { /* nada */ } // Clear out the RX buffer. Why don't use flush here ?
-  flush_and_request_resend();
+  flush_and_request_resend(serial_ind);
   serial_state[serial_ind].count = 0;
 }
 

commit dd42831cba7334c5d106ba435bdb41b6135971bb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Feb 28 19:43:46 2021 -0600

    Serial macros cleanup

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 7ce8211484..ebf95f86c6 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -304,8 +304,7 @@ inline int read_serial(const uint8_t index) { return SERIAL_IMPL.read(index); }
 void GCodeQueue::gcode_line_error(PGM_P const err, const serial_index_t serial_ind) {
   PORT_REDIRECT(SERIAL_PORTMASK(serial_ind)); // Reply to the serial port that sent the command
   SERIAL_ERROR_START();
-  SERIAL_ECHOPGM_P(err);
-  SERIAL_ECHOLN(serial_state[serial_ind].last_N);
+  SERIAL_ECHOLNPAIR_P(err, serial_state[serial_ind].last_N);
   while (read_serial(serial_ind) != -1) { /* nada */ } // Clear out the RX buffer. Why don't use flush here ?
   flush_and_request_resend();
   serial_state[serial_ind].count = 0;

commit db5967472b13cca8ea1fd778e46607032f7953e5
Author: X-Ryl669 <boite.pour.spam@gmail.com>
Date:   Sat Feb 27 20:16:33 2021 +0100

    Fix G-code Queue merge (#21213)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index f28c0586d9..7ce8211484 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -60,10 +60,6 @@ GCodeQueue queue;
 // Frequently used G-code strings
 PGMSTR(G28_STR, "G28");
 
-#if NO_TIMEOUTS > 0
-  static millis_t last_command_time = 0;
-#endif
-
 GCodeQueue::SerialState GCodeQueue::serial_state[NUM_SERIAL] = { 0 };
 GCodeQueue::RingBuffer GCodeQueue::ring_buffer = { 0 };
 

commit ec42be346d5c0d072feb8a1b63ef2fdbd6dc1e98
Author: X-Ryl669 <boite.pour.spam@gmail.com>
Date:   Fri Feb 26 23:54:46 2021 +0100

    Fix and improve G-code queue (#21122)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 8c9e9afdc1..f28c0586d9 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -35,6 +35,7 @@ GCodeQueue queue;
 #include "../module/planner.h"
 #include "../module/temperature.h"
 #include "../MarlinCore.h"
+#include "../core/bug_on.h"
 
 #if ENABLED(PRINTER_EVENT_LEDS)
   #include "../feature/leds/printer_event_leds.h"
@@ -48,10 +49,6 @@ GCodeQueue queue;
   #include "../feature/binary_stream.h"
 #endif
 
-#if ENABLED(MEATPACK)
-  #include "../feature/meatpack.h"
-#endif
-
 #if ENABLED(POWER_LOSS_RECOVERY)
   #include "../feature/powerloss.h"
 #endif
@@ -67,44 +64,17 @@ PGMSTR(G28_STR, "G28");
   static millis_t last_command_time = 0;
 #endif
 
-/**
- * GCode line number handling. Hosts may opt to include line numbers when
- * sending commands to Marlin, and lines will be checked for sequentiality.
- * M110 N<int> sets the current line number.
- */
-long GCodeQueue::last_N[NUM_SERIAL];
-
-/**
- * GCode Command Queue
- * A simple ring buffer of BUFSIZE command strings.
- *
- * Commands are copied into this buffer by the command injectors
- * (immediate, serial, sd card) and they are processed sequentially by
- * the main loop. The gcode.process_next_command method parses the next
- * command and hands off execution to individual handler functions.
- */
-uint8_t GCodeQueue::length = 0,  // Count of commands in the queue
-        GCodeQueue::index_r = 0, // Ring buffer read position
-        GCodeQueue::index_w = 0; // Ring buffer write position
-
-char GCodeQueue::command_buffer[BUFSIZE][MAX_CMD_SIZE];
+GCodeQueue::SerialState GCodeQueue::serial_state[NUM_SERIAL] = { 0 };
+GCodeQueue::RingBuffer GCodeQueue::ring_buffer = { 0 };
 
-/*
- * The port that the command was received on
- */
-#if HAS_MULTI_SERIAL
-  serial_index_t GCodeQueue::port[BUFSIZE];
+#if NO_TIMEOUTS > 0
+  static millis_t last_command_time = 0;
 #endif
 
 /**
  * Serial command injection
  */
 
-// Number of characters read in the current line of serial input
-static int serial_count[NUM_SERIAL] = { 0 };
-
-bool send_ok[BUFSIZE];
-
 /**
  * Next Injected PROGMEM Command pointer. (nullptr == empty)
  * Internal commands are enqueued ahead of serial / SD commands.
@@ -116,38 +86,16 @@ PGM_P GCodeQueue::injected_commands_P; // = nullptr
  */
 char GCodeQueue::injected_commands[64]; // = { 0 }
 
-GCodeQueue::GCodeQueue() {
-  // Send "ok" after commands by default
-  LOOP_L_N(i, COUNT(send_ok)) send_ok[i] = true;
-}
-
-/**
- * Check whether there are any commands yet to be executed
- */
-bool GCodeQueue::has_commands_queued() {
-  return queue.length || injected_commands_P || injected_commands[0];
-}
-
-/**
- * Clear the Marlin command queue
- */
-void GCodeQueue::clear() {
-  index_r = index_w = length = 0;
-}
 
-/**
- * Once a new command is in the ring buffer, call this to commit it
- */
-void GCodeQueue::_commit_command(bool say_ok
+void GCodeQueue::RingBuffer::commit_command(bool skip_ok
   #if HAS_MULTI_SERIAL
     , serial_index_t serial_ind/*=-1*/
   #endif
 ) {
-  send_ok[index_w] = say_ok;
-  TERN_(HAS_MULTI_SERIAL, port[index_w] = serial_ind);
+  commands[index_w].skip_ok = skip_ok;
+  TERN_(HAS_MULTI_SERIAL, commands[index_w].port = serial_ind);
   TERN_(POWER_LOSS_RECOVERY, recovery.commit_sdpos(index_w));
-  if (++index_w >= BUFSIZE) index_w = 0;
-  length++;
+  advance_pos(index_w, 1);
 }
 
 /**
@@ -155,14 +103,14 @@ void GCodeQueue::_commit_command(bool say_ok
  * Return true if the command was successfully added.
  * Return false for a full buffer, or if the 'command' is a comment.
  */
-bool GCodeQueue::_enqueue(const char* cmd, bool say_ok/*=false*/
+bool GCodeQueue::RingBuffer::enqueue(const char* cmd, bool skip_ok/*=true*/
   #if HAS_MULTI_SERIAL
     , serial_index_t serial_ind/*=-1*/
   #endif
 ) {
   if (*cmd == ';' || length >= BUFSIZE) return false;
-  strcpy(command_buffer[index_w], cmd);
-  _commit_command(say_ok
+  strcpy(commands[index_w].buffer, cmd);
+  commit_command(skip_ok
     #if HAS_MULTI_SERIAL
       , serial_ind
     #endif
@@ -175,14 +123,11 @@ bool GCodeQueue::_enqueue(const char* cmd, bool say_ok/*=false*/
  * Return true if the command was consumed
  */
 bool GCodeQueue::enqueue_one(const char* cmd) {
-
-  //SERIAL_ECHOPGM("enqueue_one(\"");
-  //SERIAL_ECHO(cmd);
-  //SERIAL_ECHOPGM("\") \n");
+  //SERIAL_ECHOLNPAIR("enqueue_one(\"", cmd, "\")");
 
   if (*cmd == 0 || ISEOL(*cmd)) return true;
 
-  if (_enqueue(cmd)) {
+  if (ring_buffer.enqueue(cmd)) {
     SERIAL_ECHO_MSG(STR_ENQUEUEING, cmd, "\"");
     return true;
   }
@@ -260,7 +205,7 @@ bool GCodeQueue::enqueue_one_P(PGM_P const pgcode) {
   char cmd[i + 1];
   memcpy_P(cmd, p, i);
   cmd[i] = '\0';
-  return _enqueue(cmd);
+  return ring_buffer.enqueue(cmd);
 }
 
 /**
@@ -291,20 +236,21 @@ void GCodeQueue::enqueue_now_P(PGM_P const pgcode) {
  *   P<int>  Planner space remaining
  *   B<int>  Block queue space remaining
  */
-void GCodeQueue::ok_to_send() {
+void GCodeQueue::RingBuffer::ok_to_send() {
   #if NO_TIMEOUTS > 0
     // Start counting from the last command's execution
     last_command_time = millis();
   #endif
+  CommandLine &command = commands[index_r];
   #if HAS_MULTI_SERIAL
-    const serial_index_t serial_ind = command_port();
+    const serial_index_t serial_ind = command.port;
     if (serial_ind < 0) return;
     PORT_REDIRECT(SERIAL_PORTMASK(serial_ind));   // Reply to the serial port that sent the command
   #endif
-  if (!send_ok[index_r]) return;
+  if (command.skip_ok) return;
   SERIAL_ECHOPGM(STR_OK);
   #if ENABLED(ADVANCED_OK)
-    char* p = command_buffer[index_r];
+    char* p = command.buffer;
     if (*p == 'N') {
       SERIAL_CHAR(' ', *p++);
       while (NUMERIC_SIGNED(*p))
@@ -321,27 +267,40 @@ void GCodeQueue::ok_to_send() {
  * indicate that a command needs to be re-sent.
  */
 void GCodeQueue::flush_and_request_resend() {
-  const serial_index_t serial_ind = command_port();
+  const serial_index_t serial_ind = ring_buffer.command_port();
   #if HAS_MULTI_SERIAL
     if (serial_ind < 0) return;                   // Never mind. Command came from SD or Flash Drive
     PORT_REDIRECT(SERIAL_PORTMASK(serial_ind));   // Reply to the serial port that sent the command
   #endif
   SERIAL_FLUSH();
   SERIAL_ECHOPGM(STR_RESEND);
-  SERIAL_ECHOLN(last_N[serial_ind] + 1);
-  ok_to_send();
+  SERIAL_ECHOLN(serial_state[serial_ind].last_N + 1);
 }
 
-
 // Multiserial already handle the dispatch to/from multiple port by itself
 inline bool serial_data_available(uint8_t index = SERIAL_ALL) {
   if (index == SERIAL_ALL) {
     for (index = 0; index < NUM_SERIAL; index++) {
-      if (SERIAL_IMPL.available(index) > 0) return true;
+      const int a = SERIAL_IMPL.available(index);
+      #if BOTH(RX_BUFFER_MONITOR, RX_BUFFER_SIZE)
+        if (a > RX_BUFFER_SIZE - 2) {
+          PORT_REDIRECT(SERIAL_PORTMASK(index));
+          SERIAL_ERROR_MSG("RX BUF overflow, increase RX_BUFFER_SIZE: ", a);
+        }
+      #endif
+      if (a > 0) return true;
     }
     return false;
   }
-  return SERIAL_IMPL.available(index) > 0;
+  const int a = SERIAL_IMPL.available(index);
+  #if BOTH(RX_BUFFER_MONITOR, RX_BUFFER_SIZE)
+    if (a > RX_BUFFER_SIZE - 2) {
+      PORT_REDIRECT(SERIAL_PORTMASK(index));
+      SERIAL_ERROR_MSG("RX BUF overflow, increase RX_BUFFER_SIZE: ", a);
+    }
+  #endif
+
+  return a > 0;
 }
 
 inline int read_serial(const uint8_t index) { return SERIAL_IMPL.read(index); }
@@ -349,11 +308,11 @@ inline int read_serial(const uint8_t index) { return SERIAL_IMPL.read(index); }
 void GCodeQueue::gcode_line_error(PGM_P const err, const serial_index_t serial_ind) {
   PORT_REDIRECT(SERIAL_PORTMASK(serial_ind)); // Reply to the serial port that sent the command
   SERIAL_ERROR_START();
-  serialprintPGM(err);
-  SERIAL_ECHOLN(last_N[serial_ind]);
-  while (read_serial(serial_ind) != -1);      // Clear out the RX buffer
+  SERIAL_ECHOPGM_P(err);
+  SERIAL_ECHOLN(serial_state[serial_ind].last_N);
+  while (read_serial(serial_ind) != -1) { /* nada */ } // Clear out the RX buffer. Why don't use flush here ?
   flush_and_request_resend();
-  serial_count[serial_ind] = 0;
+  serial_state[serial_ind].count = 0;
 }
 
 FORCE_INLINE bool is_M29(const char * const cmd) {  // matches "M29" & "M29 ", but not "M290", etc
@@ -440,10 +399,6 @@ inline bool process_line_done(uint8_t &sis, char (&buff)[MAX_CMD_SIZE], int &ind
  * left on the serial port.
  */
 void GCodeQueue::get_serial_commands() {
-  static char serial_line_buffer[NUM_SERIAL][MAX_CMD_SIZE];
-
-  static uint8_t serial_input_state[NUM_SERIAL] = { PS_NORMAL };
-
   #if ENABLED(BINARY_FILE_TRANSFER)
     if (card.flag.binary_mode) {
       /**
@@ -451,7 +406,7 @@ void GCodeQueue::get_serial_commands() {
        * receive buffer (which limits the packet size to MAX_CMD_SIZE).
        * The receive buffer also limits the packet size for reliable transmission.
        */
-      binaryStream[card.transfer_port_index].receive(serial_line_buffer[card.transfer_port_index]);
+      binaryStream[card.transfer_port_index].receive(serial_state[card.transfer_port_index].line_buffer);
       return;
     }
   #endif
@@ -460,122 +415,140 @@ void GCodeQueue::get_serial_commands() {
   // send "wait" to indicate Marlin is still waiting.
   #if NO_TIMEOUTS > 0
     const millis_t ms = millis();
-    if (length == 0 && !serial_data_available() && ELAPSED(ms, last_command_time + NO_TIMEOUTS)) {
+    if (ring_buffer.empty() && !serial_data_available() && ELAPSED(ms, last_command_time + NO_TIMEOUTS)) {
       SERIAL_ECHOLNPGM(STR_WAIT);
       last_command_time = ms;
     }
   #endif
 
-  /**
-   * Loop while serial characters are incoming and the queue is not full
-   */
-  while (length < BUFSIZE && serial_data_available()) {
+  // Loop while serial characters are incoming and the queue is not full
+  for (bool hadData = true; hadData;) {
+    // Unless a serial port has data, this will exit on next iteration
+    hadData = false;
+
     LOOP_L_N(p, NUM_SERIAL) {
+      // Check if the queue is full and exit if it is.
+      if (ring_buffer.full()) return;
 
-      const int c = read_serial(p);
-      if (c < 0) continue;
-
-      #if ENABLED(MEATPACK)
-        meatpack.handle_rx_char(uint8_t(c), p);
-        char c_res[2] = { 0, 0 };
-        const uint8_t char_count = meatpack.get_result_char(c_res);
-      #else
-        constexpr uint8_t char_count = 1;
-      #endif
+      // No data for this port ? Skip it
+      if (!serial_data_available(p)) continue;
 
-      LOOP_L_N(char_index, char_count) {
-        const char serial_char = TERN(MEATPACK, c_res[char_index], c);
+      // Ok, we have some data to process, let's make progress here
+      hadData = true;
 
-        if (ISEOL(serial_char)) {
+      const int c = read_serial(p);
+      if (c < 0) {
+        // This should never happen, let's log it
+        PORT_REDIRECT(SERIAL_PORTMASK(p));     // Reply to the serial port that sent the command
+        // Crash here to get more information why it failed
+        BUG_ON("SP available but read -1");
+        SERIAL_ERROR_MSG(STR_ERR_SERIAL_MISMATCH);
+        SERIAL_FLUSH();
+        continue;
+      }
 
-          // Reset our state, continue if the line was empty
-          if (process_line_done(serial_input_state[p], serial_line_buffer[p], serial_count[p]))
-            continue;
+      const char serial_char = (char)c;
+      SerialState &serial = serial_state[p];
 
-          char* command = serial_line_buffer[p];
+      if (ISEOL(serial_char)) {
 
-          while (*command == ' ') command++;                   // Skip leading spaces
-          char *npos = (*command == 'N') ? command : nullptr;  // Require the N parameter to start the line
+        // Reset our state, continue if the line was empty
+        if (process_line_done(serial.input_state, serial.line_buffer, serial.count))
+          continue;
 
-          if (npos) {
+        char* command = serial.line_buffer;
 
-            const bool M110 = !!strstr_P(command, PSTR("M110"));
+        while (*command == ' ') command++;                   // Skip leading spaces
+        char *npos = (*command == 'N') ? command : nullptr;  // Require the N parameter to start the line
 
-            if (M110) {
-              char* n2pos = strchr(command + 4, 'N');
-              if (n2pos) npos = n2pos;
-            }
+        if (npos) {
 
-            const long gcode_N = strtol(npos + 1, nullptr, 10);
+          const bool M110 = !!strstr_P(command, PSTR("M110"));
 
-            if (gcode_N != last_N[p] + 1 && !M110)
-              return gcode_line_error(PSTR(STR_ERR_LINE_NO), p);
+          if (M110) {
+            char* n2pos = strchr(command + 4, 'N');
+            if (n2pos) npos = n2pos;
+          }
 
-            char *apos = strrchr(command, '*');
-            if (apos) {
-              uint8_t checksum = 0, count = uint8_t(apos - command);
-              while (count) checksum ^= command[--count];
-              if (strtol(apos + 1, nullptr, 10) != checksum)
-                return gcode_line_error(PSTR(STR_ERR_CHECKSUM_MISMATCH), p);
-            }
-            else
-              return gcode_line_error(PSTR(STR_ERR_NO_CHECKSUM), p);
+          const long gcode_N = strtol(npos + 1, nullptr, 10);
 
-            last_N[p] = gcode_N;
+          if (gcode_N != serial.last_N + 1 && !M110) {
+            // In case of error on a serial port, don't prevent other serial port from making progress
+            gcode_line_error(PSTR(STR_ERR_LINE_NO), p);
+            break;
           }
-          #if ENABLED(SDSUPPORT)
-            // Pronterface "M29" and "M29 " has no line number
-            else if (card.flag.saving && !is_M29(command))
-              return gcode_line_error(PSTR(STR_ERR_NO_CHECKSUM), p);
-          #endif
 
-          //
-          // Movement commands give an alert when the machine is stopped
-          //
-
-          if (IsStopped()) {
-            char* gpos = strchr(command, 'G');
-            if (gpos) {
-              switch (strtol(gpos + 1, nullptr, 10)) {
-                case 0: case 1:
-                #if ENABLED(ARC_SUPPORT)
-                  case 2: case 3:
-                #endif
-                #if ENABLED(BEZIER_CURVE_SUPPORT)
-                  case 5:
-                #endif
-                  PORT_REDIRECT(SERIAL_PORTMASK(p));     // Reply to the serial port that sent the command
-                  SERIAL_ECHOLNPGM(STR_ERR_STOPPED);
-                  LCD_MESSAGEPGM(MSG_STOPPED);
-                  break;
-              }
+          char *apos = strrchr(command, '*');
+          if (apos) {
+            uint8_t checksum = 0, count = uint8_t(apos - command);
+            while (count) checksum ^= command[--count];
+            if (strtol(apos + 1, nullptr, 10) != checksum) {
+              // In case of error on a serial port, don't prevent other serial port from making progress
+              gcode_line_error(PSTR(STR_ERR_CHECKSUM_MISMATCH), p);
+              break;
             }
           }
+          else {
+            // In case of error on a serial port, don't prevent other serial port from making progress
+            gcode_line_error(PSTR(STR_ERR_NO_CHECKSUM), p);
+            break;
+          }
+
+          serial.last_N = gcode_N;
+        }
+        #if ENABLED(SDSUPPORT)
+          // Pronterface "M29" and "M29 " has no line number
+          else if (card.flag.saving && !is_M29(command)) {
+            gcode_line_error(PSTR(STR_ERR_NO_CHECKSUM), p);
+            break;
+          }
+        #endif
 
-          #if DISABLED(EMERGENCY_PARSER)
-            // Process critical commands early
-            if (command[0] == 'M') switch (command[3]) {
-              case '8': if (command[2] == '0' && command[1] == '1') { wait_for_heatup = false; TERN_(HAS_LCD_MENU, wait_for_user = false); } break;
-              case '2': if (command[2] == '1' && command[1] == '1') kill(M112_KILL_STR, nullptr, true); break;
-              case '0': if (command[1] == '4' && command[2] == '1') quickstop_stepper(); break;
+        //
+        // Movement commands give an alert when the machine is stopped
+        //
+
+        if (IsStopped()) {
+          char* gpos = strchr(command, 'G');
+          if (gpos) {
+            switch (strtol(gpos + 1, nullptr, 10)) {
+              case 0: case 1:
+              #if ENABLED(ARC_SUPPORT)
+                case 2: case 3:
+              #endif
+              #if ENABLED(BEZIER_CURVE_SUPPORT)
+                case 5:
+              #endif
+                PORT_REDIRECT(SERIAL_PORTMASK(p));     // Reply to the serial port that sent the command
+                SERIAL_ECHOLNPGM(STR_ERR_STOPPED);
+                LCD_MESSAGEPGM(MSG_STOPPED);
+                break;
             }
-          #endif
+          }
+        }
 
-          #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0
-            last_command_time = ms;
-          #endif
+        #if DISABLED(EMERGENCY_PARSER)
+          // Process critical commands early
+          if (command[0] == 'M') switch (command[3]) {
+            case '8': if (command[2] == '0' && command[1] == '1') { wait_for_heatup = false; TERN_(HAS_LCD_MENU, wait_for_user = false); } break;
+            case '2': if (command[2] == '1' && command[1] == '1') kill(M112_KILL_STR, nullptr, true); break;
+            case '0': if (command[1] == '4' && command[2] == '1') quickstop_stepper(); break;
+          }
+        #endif
 
-          // Add the command to the queue
-          _enqueue(serial_line_buffer[p], true
-            #if HAS_MULTI_SERIAL
-              , p
-            #endif
-          );
-        }
-        else
-          process_stream_char(serial_char, serial_input_state[p], serial_line_buffer[p], serial_count[p]);
+        #if NO_TIMEOUTS > 0
+          last_command_time = ms;
+        #endif
 
-      } // char_count loop
+        // Add the command to the queue
+        ring_buffer.enqueue(serial.line_buffer, false
+          #if HAS_MULTI_SERIAL
+            , p
+          #endif
+        );
+      }
+      else
+        process_stream_char(serial_char, serial.input_state, serial.line_buffer, serial.count);
 
     } // NUM_SERIAL loop
   } // queue has space, serial has data
@@ -595,33 +568,35 @@ void GCodeQueue::get_serial_commands() {
     if (!IS_SD_PRINTING()) return;
 
     int sd_count = 0;
-    while (length < BUFSIZE && !card.eof()) {
+    while (!ring_buffer.full() && !card.eof()) {
       const int16_t n = card.get();
       const bool card_eof = card.eof();
       if (n < 0 && !card_eof) { SERIAL_ERROR_MSG(STR_SD_ERR_READ); continue; }
 
+      CommandLine &command = ring_buffer.commands[ring_buffer.index_w];
       const char sd_char = (char)n;
       const bool is_eol = ISEOL(sd_char);
       if (is_eol || card_eof) {
 
+
         // Reset stream state, terminate the buffer, and commit a non-empty command
         if (!is_eol && sd_count) ++sd_count;          // End of file with no newline
-        if (!process_line_done(sd_input_state, command_buffer[index_w], sd_count)) {
+        if (!process_line_done(sd_input_state, command.buffer, sd_count)) {
 
           // M808 L saves the sdpos of the next line. M808 loops to a new sdpos.
-          TERN_(GCODE_REPEAT_MARKERS, repeat.early_parse_M808(command_buffer[index_w]));
+          TERN_(GCODE_REPEAT_MARKERS, repeat.early_parse_M808(command.buffer));
 
           // Put the new command into the buffer (no "ok" sent)
-          _commit_command(false);
+          ring_buffer.commit_command(true);
 
-          // Prime Power-Loss Recovery for the NEXT _commit_command
+          // Prime Power-Loss Recovery for the NEXT commit_command
           TERN_(POWER_LOSS_RECOVERY, recovery.cmd_sdpos = card.getIndex());
         }
 
         if (card.eof()) card.fileHasFinished();         // Handle end of file reached
       }
       else
-        process_stream_char(sd_char, sd_input_state, command_buffer[index_w], sd_count);
+        process_stream_char(sd_char, sd_input_state, command.buffer, sd_count);
     }
   }
 
@@ -634,6 +609,7 @@ void GCodeQueue::get_serial_commands() {
  *  - The SD card file being actively printed
  */
 void GCodeQueue::get_available_commands() {
+  if (ring_buffer.full()) return;
 
   get_serial_commands();
 
@@ -649,13 +625,13 @@ void GCodeQueue::advance() {
   if (process_injected_command_P() || process_injected_command()) return;
 
   // Return if the G-code buffer is empty
-  if (!length) return;
+  if (ring_buffer.empty()) return;
 
   #if ENABLED(SDSUPPORT)
 
     if (card.flag.saving) {
-      char* command = command_buffer[index_r];
-      if (is_M29(command)) {
+      char * const cmd = ring_buffer.peek_next_command_string();
+      if (is_M29(cmd)) {
         // M29 closes the file
         card.closefile();
         SERIAL_ECHOLNPGM(STR_FILE_SAVED);
@@ -673,7 +649,7 @@ void GCodeQueue::advance() {
       }
       else {
         // Write the string from the read buffer to SD
-        card.write_command(command);
+        card.write_command(cmd);
         if (card.flag.logging)
           gcode.process_next_command(); // The card is saving because it's logging
         else
@@ -690,7 +666,5 @@ void GCodeQueue::advance() {
   #endif // SDSUPPORT
 
   // The queue may be reset by a command handler or by code invoked by idle() within a handler
-  --length;
-  if (++index_r >= BUFSIZE) index_r = 0;
-
+  ring_buffer.advance_pos(ring_buffer.index_r, -1);
 }

commit f003e52009ba649f95463a115253d6dadcf361e6
Author: X-Ryl669 <boite.pour.spam@gmail.com>
Date:   Thu Feb 25 08:23:29 2021 +0100

    Combined LPC / Serial fixes (#21178)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index c49247912c..8c9e9afdc1 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -63,6 +63,10 @@ GCodeQueue queue;
 // Frequently used G-code strings
 PGMSTR(G28_STR, "G28");
 
+#if NO_TIMEOUTS > 0
+  static millis_t last_command_time = 0;
+#endif
+
 /**
  * GCode line number handling. Hosts may opt to include line numbers when
  * sending commands to Marlin, and lines will be checked for sequentiality.
@@ -288,6 +292,10 @@ void GCodeQueue::enqueue_now_P(PGM_P const pgcode) {
  *   B<int>  Block queue space remaining
  */
 void GCodeQueue::ok_to_send() {
+  #if NO_TIMEOUTS > 0
+    // Start counting from the last command's execution
+    last_command_time = millis();
+  #endif
   #if HAS_MULTI_SERIAL
     const serial_index_t serial_ind = command_port();
     if (serial_ind < 0) return;
@@ -324,29 +332,20 @@ void GCodeQueue::flush_and_request_resend() {
   ok_to_send();
 }
 
-inline bool serial_data_available() {
-  byte data_available = 0;
-  if (MYSERIAL0.available()) data_available++;
-  #ifdef SERIAL_PORT_2
-    const bool port2_open = TERN1(HAS_ETHERNET, ethernet.have_telnet_client);
-    if (port2_open && MYSERIAL1.available()) data_available++;
-  #endif
-  return data_available > 0;
-}
 
-inline int read_serial(const uint8_t index) {
-  switch (index) {
-    case 0: return MYSERIAL0.read();
-    case 1: {
-      #if HAS_MULTI_SERIAL
-        const bool port2_open = TERN1(HAS_ETHERNET, ethernet.have_telnet_client);
-        if (port2_open) return MYSERIAL1.read();
-      #endif
+// Multiserial already handle the dispatch to/from multiple port by itself
+inline bool serial_data_available(uint8_t index = SERIAL_ALL) {
+  if (index == SERIAL_ALL) {
+    for (index = 0; index < NUM_SERIAL; index++) {
+      if (SERIAL_IMPL.available(index) > 0) return true;
     }
-    default: return -1;
+    return false;
   }
+  return SERIAL_IMPL.available(index) > 0;
 }
 
+inline int read_serial(const uint8_t index) { return SERIAL_IMPL.read(index); }
+
 void GCodeQueue::gcode_line_error(PGM_P const err, const serial_index_t serial_ind) {
   PORT_REDIRECT(SERIAL_PORTMASK(serial_ind)); // Reply to the serial port that sent the command
   SERIAL_ERROR_START();
@@ -460,7 +459,6 @@ void GCodeQueue::get_serial_commands() {
   // If the command buffer is empty for too long,
   // send "wait" to indicate Marlin is still waiting.
   #if NO_TIMEOUTS > 0
-    static millis_t last_command_time = 0;
     const millis_t ms = millis();
     if (length == 0 && !serial_data_available() && ELAPSED(ms, last_command_time + NO_TIMEOUTS)) {
       SERIAL_ECHOLNPGM(STR_WAIT);

commit 187602dfaf744615e715c540b9e2d4f01d308224
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Feb 7 18:16:43 2021 -0600

    Update M808 comment

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index c483522cd7..c49247912c 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -610,7 +610,7 @@ void GCodeQueue::get_serial_commands() {
         if (!is_eol && sd_count) ++sd_count;          // End of file with no newline
         if (!process_line_done(sd_input_state, command_buffer[index_w], sd_count)) {
 
-          // M808 S saves the sdpos of the next line. M808 loops to a new sdpos.
+          // M808 L saves the sdpos of the next line. M808 loops to a new sdpos.
           TERN_(GCODE_REPEAT_MARKERS, repeat.early_parse_M808(command_buffer[index_w]));
 
           // Put the new command into the buffer (no "ok" sent)

commit e7c711996bd3080f5e343eff5556736cbf2e2416
Author: X-Ryl669 <boite.pour.spam@gmail.com>
Date:   Mon Feb 8 07:37:24 2021 +0100

    Serial refactor. Default 8-bit ECHO to int, not char (#20985)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index d5bc857286..c483522cd7 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -302,8 +302,8 @@ void GCodeQueue::ok_to_send() {
       while (NUMERIC_SIGNED(*p))
         SERIAL_CHAR(*p++);
     }
-    SERIAL_ECHOPAIR_P(SP_P_STR, int(planner.moves_free()),
-                      SP_B_STR, int(BUFSIZE - length));
+    SERIAL_ECHOPAIR_P(SP_P_STR, planner.moves_free(),
+                      SP_B_STR, BUFSIZE - length);
   #endif
   SERIAL_EOL();
 }

commit 604afd52d11f45c21194ff5679c829b57e5387e6
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Feb 4 19:18:31 2021 -0600

    Fix some serial char, echo
    
    Co-Authored-By: X-Ryl669 <3277165+X-Ryl669@users.noreply.github.com>

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 4c42f7e353..d5bc857286 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -298,10 +298,9 @@ void GCodeQueue::ok_to_send() {
   #if ENABLED(ADVANCED_OK)
     char* p = command_buffer[index_r];
     if (*p == 'N') {
-      SERIAL_ECHO(' ');
-      SERIAL_ECHO(*p++);
+      SERIAL_CHAR(' ', *p++);
       while (NUMERIC_SIGNED(*p))
-        SERIAL_ECHO(*p++);
+        SERIAL_CHAR(*p++);
     }
     SERIAL_ECHOPAIR_P(SP_P_STR, int(planner.moves_free()),
                       SP_B_STR, int(BUFSIZE - length));

commit 3f01b222b2b4f77cff66096dd5a18a64828e1fa4
Author: X-Ryl669 <boite.pour.spam@gmail.com>
Date:   Thu Jan 28 09:02:06 2021 +0100

    Refactor serial class with templates (#20783)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 1059997edb..4c42f7e353 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -290,8 +290,8 @@ void GCodeQueue::enqueue_now_P(PGM_P const pgcode) {
 void GCodeQueue::ok_to_send() {
   #if HAS_MULTI_SERIAL
     const serial_index_t serial_ind = command_port();
-    if (serial_ind < 0) return;                   // Never mind. Command came from SD or Flash Drive
-    PORT_REDIRECT(serial_ind);                    // Reply to the serial port that sent the command
+    if (serial_ind < 0) return;
+    PORT_REDIRECT(SERIAL_PORTMASK(serial_ind));   // Reply to the serial port that sent the command
   #endif
   if (!send_ok[index_r]) return;
   SERIAL_ECHOPGM(STR_OK);
@@ -317,7 +317,7 @@ void GCodeQueue::flush_and_request_resend() {
   const serial_index_t serial_ind = command_port();
   #if HAS_MULTI_SERIAL
     if (serial_ind < 0) return;                   // Never mind. Command came from SD or Flash Drive
-    PORT_REDIRECT(serial_ind);                    // Reply to the serial port that sent the command
+    PORT_REDIRECT(SERIAL_PORTMASK(serial_ind));   // Reply to the serial port that sent the command
   #endif
   SERIAL_FLUSH();
   SERIAL_ECHOPGM(STR_RESEND);
@@ -349,11 +349,11 @@ inline int read_serial(const uint8_t index) {
 }
 
 void GCodeQueue::gcode_line_error(PGM_P const err, const serial_index_t serial_ind) {
-  PORT_REDIRECT(serial_ind);                      // Reply to the serial port that sent the command
+  PORT_REDIRECT(SERIAL_PORTMASK(serial_ind)); // Reply to the serial port that sent the command
   SERIAL_ERROR_START();
   serialprintPGM(err);
   SERIAL_ECHOLN(last_N[serial_ind]);
-  while (read_serial(serial_ind) != -1);          // Clear out the RX buffer
+  while (read_serial(serial_ind) != -1);      // Clear out the RX buffer
   flush_and_request_resend();
   serial_count[serial_ind] = 0;
 }
@@ -547,7 +547,7 @@ void GCodeQueue::get_serial_commands() {
                 #if ENABLED(BEZIER_CURVE_SUPPORT)
                   case 5:
                 #endif
-                  PORT_REDIRECT(p);                      // Reply to the serial port that sent the command
+                  PORT_REDIRECT(SERIAL_PORTMASK(p));     // Reply to the serial port that sent the command
                   SERIAL_ECHOLNPGM(STR_ERR_STOPPED);
                   LCD_MESSAGEPGM(MSG_STOPPED);
                   break;

commit c929fb52dd5ed9b265f93e3df4b69ac8ea581735
Author: ellensp <ellensp@hotmail.com>
Date:   Thu Jan 28 20:47:12 2021 +1300

    Meatpack::report_state on serial port init (#20903)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 51fec7d41c..1059997edb 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -89,7 +89,7 @@ char GCodeQueue::command_buffer[BUFSIZE][MAX_CMD_SIZE];
  * The port that the command was received on
  */
 #if HAS_MULTI_SERIAL
-  int16_t GCodeQueue::port[BUFSIZE];
+  serial_index_t GCodeQueue::port[BUFSIZE];
 #endif
 
 /**
@@ -136,11 +136,11 @@ void GCodeQueue::clear() {
  */
 void GCodeQueue::_commit_command(bool say_ok
   #if HAS_MULTI_SERIAL
-    , int16_t p/*=-1*/
+    , serial_index_t serial_ind/*=-1*/
   #endif
 ) {
   send_ok[index_w] = say_ok;
-  TERN_(HAS_MULTI_SERIAL, port[index_w] = p);
+  TERN_(HAS_MULTI_SERIAL, port[index_w] = serial_ind);
   TERN_(POWER_LOSS_RECOVERY, recovery.commit_sdpos(index_w));
   if (++index_w >= BUFSIZE) index_w = 0;
   length++;
@@ -153,14 +153,14 @@ void GCodeQueue::_commit_command(bool say_ok
  */
 bool GCodeQueue::_enqueue(const char* cmd, bool say_ok/*=false*/
   #if HAS_MULTI_SERIAL
-    , int16_t pn/*=-1*/
+    , serial_index_t serial_ind/*=-1*/
   #endif
 ) {
   if (*cmd == ';' || length >= BUFSIZE) return false;
   strcpy(command_buffer[index_w], cmd);
   _commit_command(say_ok
     #if HAS_MULTI_SERIAL
-      , pn
+      , serial_ind
     #endif
   );
   return true;
@@ -289,9 +289,9 @@ void GCodeQueue::enqueue_now_P(PGM_P const pgcode) {
  */
 void GCodeQueue::ok_to_send() {
   #if HAS_MULTI_SERIAL
-    const int16_t pn = command_port();
-    if (pn < 0) return;
-    PORT_REDIRECT(pn);                    // Reply to the serial port that sent the command
+    const serial_index_t serial_ind = command_port();
+    if (serial_ind < 0) return;                   // Never mind. Command came from SD or Flash Drive
+    PORT_REDIRECT(serial_ind);                    // Reply to the serial port that sent the command
   #endif
   if (!send_ok[index_r]) return;
   SERIAL_ECHOPGM(STR_OK);
@@ -314,14 +314,14 @@ void GCodeQueue::ok_to_send() {
  * indicate that a command needs to be re-sent.
  */
 void GCodeQueue::flush_and_request_resend() {
-  const int16_t pn = command_port();
+  const serial_index_t serial_ind = command_port();
   #if HAS_MULTI_SERIAL
-    if (pn < 0) return;
-    PORT_REDIRECT(pn);                    // Reply to the serial port that sent the command
+    if (serial_ind < 0) return;                   // Never mind. Command came from SD or Flash Drive
+    PORT_REDIRECT(serial_ind);                    // Reply to the serial port that sent the command
   #endif
   SERIAL_FLUSH();
   SERIAL_ECHOPGM(STR_RESEND);
-  SERIAL_ECHOLN(last_N[pn] + 1);
+  SERIAL_ECHOLN(last_N[serial_ind] + 1);
   ok_to_send();
 }
 
@@ -348,14 +348,14 @@ inline int read_serial(const uint8_t index) {
   }
 }
 
-void GCodeQueue::gcode_line_error(PGM_P const err, const int8_t pn) {
-  PORT_REDIRECT(pn);                      // Reply to the serial port that sent the command
+void GCodeQueue::gcode_line_error(PGM_P const err, const serial_index_t serial_ind) {
+  PORT_REDIRECT(serial_ind);                      // Reply to the serial port that sent the command
   SERIAL_ERROR_START();
   serialprintPGM(err);
-  SERIAL_ECHOLN(last_N[pn]);
-  while (read_serial(pn) != -1);          // Clear out the RX buffer
+  SERIAL_ECHOLN(last_N[serial_ind]);
+  while (read_serial(serial_ind) != -1);          // Clear out the RX buffer
   flush_and_request_resend();
-  serial_count[pn] = 0;
+  serial_count[serial_ind] = 0;
 }
 
 FORCE_INLINE bool is_M29(const char * const cmd) {  // matches "M29" & "M29 ", but not "M290", etc
@@ -473,13 +473,13 @@ void GCodeQueue::get_serial_commands() {
    * Loop while serial characters are incoming and the queue is not full
    */
   while (length < BUFSIZE && serial_data_available()) {
-    LOOP_L_N(i, NUM_SERIAL) {
+    LOOP_L_N(p, NUM_SERIAL) {
 
-      const int c = read_serial(i);
+      const int c = read_serial(p);
       if (c < 0) continue;
 
       #if ENABLED(MEATPACK)
-        meatpack.handle_rx_char(uint8_t(c));
+        meatpack.handle_rx_char(uint8_t(c), p);
         char c_res[2] = { 0, 0 };
         const uint8_t char_count = meatpack.get_result_char(c_res);
       #else
@@ -492,10 +492,10 @@ void GCodeQueue::get_serial_commands() {
         if (ISEOL(serial_char)) {
 
           // Reset our state, continue if the line was empty
-          if (process_line_done(serial_input_state[i], serial_line_buffer[i], serial_count[i]))
+          if (process_line_done(serial_input_state[p], serial_line_buffer[p], serial_count[p]))
             continue;
 
-          char* command = serial_line_buffer[i];
+          char* command = serial_line_buffer[p];
 
           while (*command == ' ') command++;                   // Skip leading spaces
           char *npos = (*command == 'N') ? command : nullptr;  // Require the N parameter to start the line
@@ -511,25 +511,25 @@ void GCodeQueue::get_serial_commands() {
 
             const long gcode_N = strtol(npos + 1, nullptr, 10);
 
-            if (gcode_N != last_N[i] + 1 && !M110)
-              return gcode_line_error(PSTR(STR_ERR_LINE_NO), i);
+            if (gcode_N != last_N[p] + 1 && !M110)
+              return gcode_line_error(PSTR(STR_ERR_LINE_NO), p);
 
             char *apos = strrchr(command, '*');
             if (apos) {
               uint8_t checksum = 0, count = uint8_t(apos - command);
               while (count) checksum ^= command[--count];
               if (strtol(apos + 1, nullptr, 10) != checksum)
-                return gcode_line_error(PSTR(STR_ERR_CHECKSUM_MISMATCH), i);
+                return gcode_line_error(PSTR(STR_ERR_CHECKSUM_MISMATCH), p);
             }
             else
-              return gcode_line_error(PSTR(STR_ERR_NO_CHECKSUM), i);
+              return gcode_line_error(PSTR(STR_ERR_NO_CHECKSUM), p);
 
-            last_N[i] = gcode_N;
+            last_N[p] = gcode_N;
           }
           #if ENABLED(SDSUPPORT)
             // Pronterface "M29" and "M29 " has no line number
             else if (card.flag.saving && !is_M29(command))
-              return gcode_line_error(PSTR(STR_ERR_NO_CHECKSUM), i);
+              return gcode_line_error(PSTR(STR_ERR_NO_CHECKSUM), p);
           #endif
 
           //
@@ -547,7 +547,7 @@ void GCodeQueue::get_serial_commands() {
                 #if ENABLED(BEZIER_CURVE_SUPPORT)
                   case 5:
                 #endif
-                  PORT_REDIRECT(i);                      // Reply to the serial port that sent the command
+                  PORT_REDIRECT(p);                      // Reply to the serial port that sent the command
                   SERIAL_ECHOLNPGM(STR_ERR_STOPPED);
                   LCD_MESSAGEPGM(MSG_STOPPED);
                   break;
@@ -569,14 +569,14 @@ void GCodeQueue::get_serial_commands() {
           #endif
 
           // Add the command to the queue
-          _enqueue(serial_line_buffer[i], true
+          _enqueue(serial_line_buffer[p], true
             #if HAS_MULTI_SERIAL
-              , i
+              , p
             #endif
           );
         }
         else
-          process_stream_char(serial_char, serial_input_state[i], serial_line_buffer[i], serial_count[i]);
+          process_stream_char(serial_char, serial_input_state[p], serial_line_buffer[p], serial_count[p]);
 
       } // char_count loop
 

commit 3921369f98f39280800b1c9944677e9644278106
Author: ellensp <ellensp@hotmail.com>
Date:   Sun Jan 24 19:43:23 2021 +1300

    MeatPack serial encoding (#20802)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 9e626bd235..51fec7d41c 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -48,6 +48,10 @@ GCodeQueue queue;
   #include "../feature/binary_stream.h"
 #endif
 
+#if ENABLED(MEATPACK)
+  #include "../feature/meatpack.h"
+#endif
+
 #if ENABLED(POWER_LOSS_RECOVERY)
   #include "../feature/powerloss.h"
 #endif
@@ -474,98 +478,109 @@ void GCodeQueue::get_serial_commands() {
       const int c = read_serial(i);
       if (c < 0) continue;
 
-      const char serial_char = c;
-
-      if (ISEOL(serial_char)) {
+      #if ENABLED(MEATPACK)
+        meatpack.handle_rx_char(uint8_t(c));
+        char c_res[2] = { 0, 0 };
+        const uint8_t char_count = meatpack.get_result_char(c_res);
+      #else
+        constexpr uint8_t char_count = 1;
+      #endif
 
-        // Reset our state, continue if the line was empty
-        if (process_line_done(serial_input_state[i], serial_line_buffer[i], serial_count[i]))
-          continue;
+      LOOP_L_N(char_index, char_count) {
+        const char serial_char = TERN(MEATPACK, c_res[char_index], c);
 
-        char* command = serial_line_buffer[i];
+        if (ISEOL(serial_char)) {
 
-        while (*command == ' ') command++;                   // Skip leading spaces
-        char *npos = (*command == 'N') ? command : nullptr;  // Require the N parameter to start the line
+          // Reset our state, continue if the line was empty
+          if (process_line_done(serial_input_state[i], serial_line_buffer[i], serial_count[i]))
+            continue;
 
-        if (npos) {
+          char* command = serial_line_buffer[i];
 
-          const bool M110 = !!strstr_P(command, PSTR("M110"));
+          while (*command == ' ') command++;                   // Skip leading spaces
+          char *npos = (*command == 'N') ? command : nullptr;  // Require the N parameter to start the line
 
-          if (M110) {
-            char* n2pos = strchr(command + 4, 'N');
-            if (n2pos) npos = n2pos;
-          }
+          if (npos) {
 
-          const long gcode_N = strtol(npos + 1, nullptr, 10);
+            const bool M110 = !!strstr_P(command, PSTR("M110"));
 
-          if (gcode_N != last_N[i] + 1 && !M110)
-            return gcode_line_error(PSTR(STR_ERR_LINE_NO), i);
+            if (M110) {
+              char* n2pos = strchr(command + 4, 'N');
+              if (n2pos) npos = n2pos;
+            }
 
-          char *apos = strrchr(command, '*');
-          if (apos) {
-            uint8_t checksum = 0, count = uint8_t(apos - command);
-            while (count) checksum ^= command[--count];
-            if (strtol(apos + 1, nullptr, 10) != checksum)
-              return gcode_line_error(PSTR(STR_ERR_CHECKSUM_MISMATCH), i);
-          }
-          else
-            return gcode_line_error(PSTR(STR_ERR_NO_CHECKSUM), i);
+            const long gcode_N = strtol(npos + 1, nullptr, 10);
 
-          last_N[i] = gcode_N;
-        }
-        #if ENABLED(SDSUPPORT)
-          // Pronterface "M29" and "M29 " has no line number
-          else if (card.flag.saving && !is_M29(command))
-            return gcode_line_error(PSTR(STR_ERR_NO_CHECKSUM), i);
-        #endif
+            if (gcode_N != last_N[i] + 1 && !M110)
+              return gcode_line_error(PSTR(STR_ERR_LINE_NO), i);
 
-        //
-        // Movement commands give an alert when the machine is stopped
-        //
-
-        if (IsStopped()) {
-          char* gpos = strchr(command, 'G');
-          if (gpos) {
-            switch (strtol(gpos + 1, nullptr, 10)) {
-              case 0: case 1:
-              #if ENABLED(ARC_SUPPORT)
-                case 2: case 3:
-              #endif
-              #if ENABLED(BEZIER_CURVE_SUPPORT)
-                case 5:
-              #endif
-                PORT_REDIRECT(i);                      // Reply to the serial port that sent the command
-                SERIAL_ECHOLNPGM(STR_ERR_STOPPED);
-                LCD_MESSAGEPGM(MSG_STOPPED);
-                break;
+            char *apos = strrchr(command, '*');
+            if (apos) {
+              uint8_t checksum = 0, count = uint8_t(apos - command);
+              while (count) checksum ^= command[--count];
+              if (strtol(apos + 1, nullptr, 10) != checksum)
+                return gcode_line_error(PSTR(STR_ERR_CHECKSUM_MISMATCH), i);
             }
+            else
+              return gcode_line_error(PSTR(STR_ERR_NO_CHECKSUM), i);
+
+            last_N[i] = gcode_N;
           }
-        }
+          #if ENABLED(SDSUPPORT)
+            // Pronterface "M29" and "M29 " has no line number
+            else if (card.flag.saving && !is_M29(command))
+              return gcode_line_error(PSTR(STR_ERR_NO_CHECKSUM), i);
+          #endif
 
-        #if DISABLED(EMERGENCY_PARSER)
-          // Process critical commands early
-          if (command[0] == 'M') switch (command[3]) {
-            case '8': if (command[2] == '0' && command[1] == '1') { wait_for_heatup = false; TERN_(HAS_LCD_MENU, wait_for_user = false); } break;
-            case '2': if (command[2] == '1' && command[1] == '1') kill(M112_KILL_STR, nullptr, true); break;
-            case '0': if (command[1] == '4' && command[2] == '1') quickstop_stepper(); break;
+          //
+          // Movement commands give an alert when the machine is stopped
+          //
+
+          if (IsStopped()) {
+            char* gpos = strchr(command, 'G');
+            if (gpos) {
+              switch (strtol(gpos + 1, nullptr, 10)) {
+                case 0: case 1:
+                #if ENABLED(ARC_SUPPORT)
+                  case 2: case 3:
+                #endif
+                #if ENABLED(BEZIER_CURVE_SUPPORT)
+                  case 5:
+                #endif
+                  PORT_REDIRECT(i);                      // Reply to the serial port that sent the command
+                  SERIAL_ECHOLNPGM(STR_ERR_STOPPED);
+                  LCD_MESSAGEPGM(MSG_STOPPED);
+                  break;
+              }
+            }
           }
-        #endif
 
-        #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0
-          last_command_time = ms;
-        #endif
+          #if DISABLED(EMERGENCY_PARSER)
+            // Process critical commands early
+            if (command[0] == 'M') switch (command[3]) {
+              case '8': if (command[2] == '0' && command[1] == '1') { wait_for_heatup = false; TERN_(HAS_LCD_MENU, wait_for_user = false); } break;
+              case '2': if (command[2] == '1' && command[1] == '1') kill(M112_KILL_STR, nullptr, true); break;
+              case '0': if (command[1] == '4' && command[2] == '1') quickstop_stepper(); break;
+            }
+          #endif
 
-        // Add the command to the queue
-        _enqueue(serial_line_buffer[i], true
-          #if HAS_MULTI_SERIAL
-            , i
+          #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0
+            last_command_time = ms;
           #endif
-        );
-      }
-      else
-        process_stream_char(serial_char, serial_input_state[i], serial_line_buffer[i], serial_count[i]);
 
-    } // for NUM_SERIAL
+          // Add the command to the queue
+          _enqueue(serial_line_buffer[i], true
+            #if HAS_MULTI_SERIAL
+              , i
+            #endif
+          );
+        }
+        else
+          process_stream_char(serial_char, serial_input_state[i], serial_line_buffer[i], serial_count[i]);
+
+      } // char_count loop
+
+    } // NUM_SERIAL loop
   } // queue has space, serial has data
 }
 

commit d33fe2378c25d258b02440aef6cc31e36753f98f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jan 22 15:01:19 2021 -0600

    Move common strings (#20846)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 8197205eda..9e626bd235 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -56,6 +56,9 @@ GCodeQueue queue;
   #include "../feature/repeat.h"
 #endif
 
+// Frequently used G-code strings
+PGMSTR(G28_STR, "G28");
+
 /**
  * GCode line number handling. Hosts may opt to include line numbers when
  * sending commands to Marlin, and lines will be checked for sequentiality.

commit c0870d417a68ff4303100f165282d41be9129a5c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jan 21 03:40:07 2021 -0600

    Move some MarlinCore and MarlinUI code (#20832)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 98fe91db40..8197205eda 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -31,6 +31,7 @@ GCodeQueue queue;
 
 #include "../lcd/marlinui.h"
 #include "../sd/cardreader.h"
+#include "../module/motion.h"
 #include "../module/planner.h"
 #include "../module/temperature.h"
 #include "../MarlinCore.h"

commit 90a2b482e6e59079d7cad1bc04b87a82fe99816c
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Tue Dec 29 01:07:11 2020 -0300

    LVGL G-code preview. Legacy MKS WiFi Cura plugin compatibility (#20589)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index d23e9ee07f..98fe91db40 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -158,8 +158,6 @@ bool GCodeQueue::_enqueue(const char* cmd, bool say_ok/*=false*/
   return true;
 }
 
-#define ISEOL(C) ((C) == '\n' || (C) == '\r')
-
 /**
  * Enqueue with Serial Echo
  * Return true if the command was consumed

commit b6a32500c401877e3ee1300fa613e81086bb31d3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Nov 26 21:18:40 2020 -0600

    M808 Repeat Markers (#20084)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index ba2cdf35b1..d23e9ee07f 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -51,6 +51,10 @@ GCodeQueue queue;
   #include "../feature/powerloss.h"
 #endif
 
+#if ENABLED(GCODE_REPEAT_MARKERS)
+  #include "../feature/repeat.h"
+#endif
+
 /**
  * GCode line number handling. Hosts may opt to include line numbers when
  * sending commands to Marlin, and lines will be checked for sequentiality.
@@ -577,10 +581,9 @@ void GCodeQueue::get_serial_commands() {
     if (!IS_SD_PRINTING()) return;
 
     int sd_count = 0;
-    bool card_eof = card.eof();
-    while (length < BUFSIZE && !card_eof) {
+    while (length < BUFSIZE && !card.eof()) {
       const int16_t n = card.get();
-      card_eof = card.eof();
+      const bool card_eof = card.eof();
       if (n < 0 && !card_eof) { SERIAL_ERROR_MSG(STR_SD_ERR_READ); continue; }
 
       const char sd_char = (char)n;
@@ -590,17 +593,21 @@ void GCodeQueue::get_serial_commands() {
         // Reset stream state, terminate the buffer, and commit a non-empty command
         if (!is_eol && sd_count) ++sd_count;          // End of file with no newline
         if (!process_line_done(sd_input_state, command_buffer[index_w], sd_count)) {
+
+          // M808 S saves the sdpos of the next line. M808 loops to a new sdpos.
+          TERN_(GCODE_REPEAT_MARKERS, repeat.early_parse_M808(command_buffer[index_w]));
+
+          // Put the new command into the buffer (no "ok" sent)
           _commit_command(false);
-          #if ENABLED(POWER_LOSS_RECOVERY)
-            recovery.cmd_sdpos = card.getIndex();     // Prime for the NEXT _commit_command
-          #endif
+
+          // Prime Power-Loss Recovery for the NEXT _commit_command
+          TERN_(POWER_LOSS_RECOVERY, recovery.cmd_sdpos = card.getIndex());
         }
 
-        if (card_eof) card.fileHasFinished();         // Handle end of file reached
+        if (card.eof()) card.fileHasFinished();         // Handle end of file reached
       }
       else
         process_stream_char(sd_char, sd_input_state, command_buffer[index_w], sd_count);
-
     }
   }
 

commit 3ba374a29eff40535e72267f4d5cf89ca07a3ce6
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Nov 25 22:28:42 2020 -0600

    Optimize emergency parser check

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 12dfce5111..ba2cdf35b1 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -538,12 +538,11 @@ void GCodeQueue::get_serial_commands() {
 
         #if DISABLED(EMERGENCY_PARSER)
           // Process critical commands early
-          if (strcmp_P(command, PSTR("M108")) == 0) {
-            wait_for_heatup = false;
-            TERN_(HAS_LCD_MENU, wait_for_user = false);
+          if (command[0] == 'M') switch (command[3]) {
+            case '8': if (command[2] == '0' && command[1] == '1') { wait_for_heatup = false; TERN_(HAS_LCD_MENU, wait_for_user = false); } break;
+            case '2': if (command[2] == '1' && command[1] == '1') kill(M112_KILL_STR, nullptr, true); break;
+            case '0': if (command[1] == '4' && command[2] == '1') quickstop_stepper(); break;
           }
-          if (strcmp_P(command, PSTR("M112")) == 0) kill(M112_KILL_STR, nullptr, true);
-          if (strcmp_P(command, PSTR("M410")) == 0) quickstop_stepper();
         #endif
 
         #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0

commit c5e411f49218535cd71c92b26bc226f9a9146e7d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Nov 14 18:09:17 2020 -0600

    Add parser.is_command(letter, code)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index f481052cbf..12dfce5111 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -416,11 +416,14 @@ inline void process_stream_char(const char c, uint8_t &sis, char (&buff)[MAX_CMD
  * keep sensor readings going and watchdog alive.
  */
 inline bool process_line_done(uint8_t &sis, char (&buff)[MAX_CMD_SIZE], int &ind) {
-  sis = PS_NORMAL;
-  buff[ind] = 0;
-  if (ind) { ind = 0; return false; }
-  thermalManager.manage_heater();
-  return true;
+  sis = PS_NORMAL;                    // "Normal" Serial Input State
+  buff[ind] = '\0';                   // Of course, I'm a Terminator.
+  const bool is_empty = (ind == 0);   // An empty line?
+  if (is_empty)
+    thermalManager.manage_heater();   // Keep sensors satisfied
+  else
+    ind = 0;                          // Start a new line
+  return is_empty;                    // Inform the caller
 }
 
 /**

commit ec23e37a4a31d12febc06922d3fa68446f58d7fb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Oct 24 17:13:10 2020 -0500

    Clean up comments, USB flash, NULLs

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 6139e3e2b8..f481052cbf 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -180,7 +180,7 @@ bool GCodeQueue::enqueue_one(const char* cmd) {
  * Return 'true' if any commands were processed.
  */
 bool GCodeQueue::process_injected_command_P() {
-  if (injected_commands_P == nullptr) return false;
+  if (!injected_commands_P) return false;
 
   char c;
   size_t i = 0;
@@ -480,7 +480,7 @@ void GCodeQueue::get_serial_commands() {
 
         if (npos) {
 
-          bool M110 = strstr_P(command, PSTR("M110")) != nullptr;
+          const bool M110 = !!strstr_P(command, PSTR("M110"));
 
           if (M110) {
             char* n2pos = strchr(command + 4, 'N');

commit 9baa944460e0bf5f15e46a501b64ebd39a9d5f34
Author: bilsef <bilsef1@gmail.com>
Date:   Tue Oct 20 12:35:29 2020 -0700

    Teensy 4.1 Ethernet support (#19801)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 4de5056fb2..6139e3e2b8 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -39,6 +39,10 @@ GCodeQueue queue;
   #include "../feature/leds/printer_event_leds.h"
 #endif
 
+#if HAS_ETHERNET
+  #include "../feature/ethernet.h"
+#endif
+
 #if ENABLED(BINARY_FILE_TRANSFER)
   #include "../feature/binary_stream.h"
 #endif
@@ -312,15 +316,24 @@ void GCodeQueue::flush_and_request_resend() {
 }
 
 inline bool serial_data_available() {
-  return MYSERIAL0.available() || TERN0(HAS_MULTI_SERIAL, MYSERIAL1.available());
+  byte data_available = 0;
+  if (MYSERIAL0.available()) data_available++;
+  #ifdef SERIAL_PORT_2
+    const bool port2_open = TERN1(HAS_ETHERNET, ethernet.have_telnet_client);
+    if (port2_open && MYSERIAL1.available()) data_available++;
+  #endif
+  return data_available > 0;
 }
 
 inline int read_serial(const uint8_t index) {
   switch (index) {
     case 0: return MYSERIAL0.read();
-    #if HAS_MULTI_SERIAL
-      case 1: return MYSERIAL1.read();
-    #endif
+    case 1: {
+      #if HAS_MULTI_SERIAL
+        const bool port2_open = TERN1(HAS_ETHERNET, ethernet.have_telnet_client);
+        if (port2_open) return MYSERIAL1.read();
+      #endif
+    }
     default: return -1;
   }
 }

commit eaf6777a6643a6fab23ceaaa4699cb2466ea6b83
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Oct 16 19:36:25 2020 -0500

    Rename ultralcd => marlinui

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index b9169d90e1..4de5056fb2 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -29,7 +29,7 @@ GCodeQueue queue;
 
 #include "gcode.h"
 
-#include "../lcd/ultralcd.h"
+#include "../lcd/marlinui.h"
 #include "../sd/cardreader.h"
 #include "../module/planner.h"
 #include "../module/temperature.h"

commit 90d364fc37de5880582aec9537da11f4b125d660
Author: Jason Smith <jason.inet@gmail.com>
Date:   Wed Oct 14 11:48:46 2020 -0700

    Revert at90usb1286 conditional (#19733)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index a02d2c0160..b9169d90e1 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -624,7 +624,7 @@ void GCodeQueue::advance() {
         card.closefile();
         SERIAL_ECHOLNPGM(STR_FILE_SAVED);
 
-        #if !IS_AT90USB
+        #if !defined(__AVR__) || !defined(USBCON)
           #if ENABLED(SERIAL_STATS_DROPPED_RX)
             SERIAL_ECHOLNPAIR("Dropped bytes: ", MYSERIAL0.dropped());
           #endif

commit 45731bd0221beee768e009195ee3aa9a0b0f2a88
Author: Jason Smith <jason.inet@gmail.com>
Date:   Sun Oct 11 16:13:01 2020 -0700

    Fix at90usb1286 build (#19687)
    
    * Skip check for USBCON during dependency detection
    * Ignore incompatible Teensy_ADC library, which requires Teensy >= 3
    * Add IS_AT90USB
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index b9169d90e1..a02d2c0160 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -624,7 +624,7 @@ void GCodeQueue::advance() {
         card.closefile();
         SERIAL_ECHOLNPGM(STR_FILE_SAVED);
 
-        #if !defined(__AVR__) || !defined(USBCON)
+        #if !IS_AT90USB
           #if ENABLED(SERIAL_STATS_DROPPED_RX)
             SERIAL_ECHOLNPAIR("Dropped bytes: ", MYSERIAL0.dropped());
           #endif

commit 99ba866d8d3c9abc16558ca12ba34efb9a7922e5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Aug 6 08:14:00 2020 -0500

    Optimize G-code / feature dependencies (#18919)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index c77db0bf2a..b9169d90e1 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -40,7 +40,7 @@ GCodeQueue queue;
 #endif
 
 #if ENABLED(BINARY_FILE_TRANSFER)
-  #include "../feature/binary_protocol.h"
+  #include "../feature/binary_stream.h"
 #endif
 
 #if ENABLED(POWER_LOSS_RECOVERY)
@@ -628,11 +628,10 @@ void GCodeQueue::advance() {
           #if ENABLED(SERIAL_STATS_DROPPED_RX)
             SERIAL_ECHOLNPAIR("Dropped bytes: ", MYSERIAL0.dropped());
           #endif
-
           #if ENABLED(SERIAL_STATS_MAX_RX_QUEUED)
             SERIAL_ECHOLNPAIR("Max RX Queue Size: ", MYSERIAL0.rxMaxEnqueued());
           #endif
-        #endif //  !defined(__AVR__) || !defined(USBCON)
+        #endif
 
         ok_to_send();
       }

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 330f0513ef..c77db0bf2a 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -16,7 +16,7 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 

commit dc6d8357a681cc99e04c5980c0ac66009c173e85
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Jun 27 23:27:28 2020 -0500

    Reduce string duplication

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index d87166d979..330f0513ef 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -289,8 +289,8 @@ void GCodeQueue::ok_to_send() {
       while (NUMERIC_SIGNED(*p))
         SERIAL_ECHO(*p++);
     }
-    SERIAL_ECHOPAIR_P(SP_P_STR, int(planner.moves_free()));
-    SERIAL_ECHOPAIR(" B", int(BUFSIZE - length));
+    SERIAL_ECHOPAIR_P(SP_P_STR, int(planner.moves_free()),
+                      SP_B_STR, int(BUFSIZE - length));
   #endif
   SERIAL_EOL();
 }

commit ca5a8ea827e99a681fa1dfc7e8d4949ef0c45d9a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jun 8 17:28:25 2020 -0500

    Add G-code "backspace" support

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 24d1d2cf67..d87166d979 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -387,9 +387,15 @@ inline void process_stream_char(const char c, uint8_t &sis, char (&buff)[MAX_CMD
     }
   #endif
 
-  buff[ind++] = c;
-  if (ind >= MAX_CMD_SIZE - 1)
-    sis = PS_EOL;               // Skip the rest on overflow
+  // Backspace erases previous characters
+  if (c == 0x08) {
+    if (ind) buff[--ind] = '\0';
+  }
+  else {
+    buff[ind++] = c;
+    if (ind >= MAX_CMD_SIZE - 1)
+      sis = PS_EOL;             // Skip the rest on overflow
+  }
 }
 
 /**

commit 63717822637064b347d046f8f39be824eff51785
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 12 05:50:28 2020 -0500

    Add HAS_MULTI_SERIAL conditional

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index a4a4993556..24d1d2cf67 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -72,7 +72,7 @@ char GCodeQueue::command_buffer[BUFSIZE][MAX_CMD_SIZE];
 /*
  * The port that the command was received on
  */
-#if NUM_SERIAL > 1
+#if HAS_MULTI_SERIAL
   int16_t GCodeQueue::port[BUFSIZE];
 #endif
 
@@ -119,14 +119,12 @@ void GCodeQueue::clear() {
  * Once a new command is in the ring buffer, call this to commit it
  */
 void GCodeQueue::_commit_command(bool say_ok
-  #if NUM_SERIAL > 1
+  #if HAS_MULTI_SERIAL
     , int16_t p/*=-1*/
   #endif
 ) {
   send_ok[index_w] = say_ok;
-  #if NUM_SERIAL > 1
-    port[index_w] = p;
-  #endif
+  TERN_(HAS_MULTI_SERIAL, port[index_w] = p);
   TERN_(POWER_LOSS_RECOVERY, recovery.commit_sdpos(index_w));
   if (++index_w >= BUFSIZE) index_w = 0;
   length++;
@@ -138,14 +136,14 @@ void GCodeQueue::_commit_command(bool say_ok
  * Return false for a full buffer, or if the 'command' is a comment.
  */
 bool GCodeQueue::_enqueue(const char* cmd, bool say_ok/*=false*/
-  #if NUM_SERIAL > 1
+  #if HAS_MULTI_SERIAL
     , int16_t pn/*=-1*/
   #endif
 ) {
   if (*cmd == ';' || length >= BUFSIZE) return false;
   strcpy(command_buffer[index_w], cmd);
   _commit_command(say_ok
-    #if NUM_SERIAL > 1
+    #if HAS_MULTI_SERIAL
       , pn
     #endif
   );
@@ -276,7 +274,7 @@ void GCodeQueue::enqueue_now_P(PGM_P const pgcode) {
  *   B<int>  Block queue space remaining
  */
 void GCodeQueue::ok_to_send() {
-  #if NUM_SERIAL > 1
+  #if HAS_MULTI_SERIAL
     const int16_t pn = command_port();
     if (pn < 0) return;
     PORT_REDIRECT(pn);                    // Reply to the serial port that sent the command
@@ -303,30 +301,24 @@ void GCodeQueue::ok_to_send() {
  */
 void GCodeQueue::flush_and_request_resend() {
   const int16_t pn = command_port();
-  #if NUM_SERIAL > 1
+  #if HAS_MULTI_SERIAL
     if (pn < 0) return;
     PORT_REDIRECT(pn);                    // Reply to the serial port that sent the command
   #endif
   SERIAL_FLUSH();
   SERIAL_ECHOPGM(STR_RESEND);
-  
-  SERIAL_ECHOLN(last_N[pn] + 1);  
+  SERIAL_ECHOLN(last_N[pn] + 1);
   ok_to_send();
 }
 
 inline bool serial_data_available() {
-  return false
-    || MYSERIAL0.available()
-    #if NUM_SERIAL > 1
-      || MYSERIAL1.available()
-    #endif
-  ;
+  return MYSERIAL0.available() || TERN0(HAS_MULTI_SERIAL, MYSERIAL1.available());
 }
 
 inline int read_serial(const uint8_t index) {
   switch (index) {
     case 0: return MYSERIAL0.read();
-    #if NUM_SERIAL > 1
+    #if HAS_MULTI_SERIAL
       case 1: return MYSERIAL1.read();
     #endif
     default: return -1;
@@ -538,7 +530,7 @@ void GCodeQueue::get_serial_commands() {
 
         // Add the command to the queue
         _enqueue(serial_line_buffer[i], true
-          #if NUM_SERIAL > 1
+          #if HAS_MULTI_SERIAL
             , i
           #endif
         );

commit 71195961701578d91bb348d71f5adcaa028ae9e9
Author: Mark Scammacca <github@cnrdesigns.com>
Date:   Mon Jun 1 22:19:10 2020 -0500

    G-code line number for each serial port (for TFTs) (#18165)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index b98ef10992..a4a4993556 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -52,7 +52,7 @@ GCodeQueue queue;
  * sending commands to Marlin, and lines will be checked for sequentiality.
  * M110 N<int> sets the current line number.
  */
-long gcode_N, GCodeQueue::last_N;
+long GCodeQueue::last_N[NUM_SERIAL];
 
 /**
  * GCode Command Queue
@@ -277,7 +277,7 @@ void GCodeQueue::enqueue_now_P(PGM_P const pgcode) {
  */
 void GCodeQueue::ok_to_send() {
   #if NUM_SERIAL > 1
-    const int16_t pn = port[index_r];
+    const int16_t pn = command_port();
     if (pn < 0) return;
     PORT_REDIRECT(pn);                    // Reply to the serial port that sent the command
   #endif
@@ -302,14 +302,15 @@ void GCodeQueue::ok_to_send() {
  * indicate that a command needs to be re-sent.
  */
 void GCodeQueue::flush_and_request_resend() {
+  const int16_t pn = command_port();
   #if NUM_SERIAL > 1
-    const int16_t pn = port[index_r];
     if (pn < 0) return;
     PORT_REDIRECT(pn);                    // Reply to the serial port that sent the command
   #endif
   SERIAL_FLUSH();
   SERIAL_ECHOPGM(STR_RESEND);
-  SERIAL_ECHOLN(last_N + 1);
+  
+  SERIAL_ECHOLN(last_N[pn] + 1);  
   ok_to_send();
 }
 
@@ -336,7 +337,7 @@ void GCodeQueue::gcode_line_error(PGM_P const err, const int8_t pn) {
   PORT_REDIRECT(pn);                      // Reply to the serial port that sent the command
   SERIAL_ERROR_START();
   serialprintPGM(err);
-  SERIAL_ECHOLN(last_N);
+  SERIAL_ECHOLN(last_N[pn]);
   while (read_serial(pn) != -1);          // Clear out the RX buffer
   flush_and_request_resend();
   serial_count[pn] = 0;
@@ -475,9 +476,9 @@ void GCodeQueue::get_serial_commands() {
             if (n2pos) npos = n2pos;
           }
 
-          gcode_N = strtol(npos + 1, nullptr, 10);
+          const long gcode_N = strtol(npos + 1, nullptr, 10);
 
-          if (gcode_N != last_N + 1 && !M110)
+          if (gcode_N != last_N[i] + 1 && !M110)
             return gcode_line_error(PSTR(STR_ERR_LINE_NO), i);
 
           char *apos = strrchr(command, '*');
@@ -490,7 +491,7 @@ void GCodeQueue::get_serial_commands() {
           else
             return gcode_line_error(PSTR(STR_ERR_NO_CHECKSUM), i);
 
-          last_N = gcode_N;
+          last_N[i] = gcode_N;
         }
         #if ENABLED(SDSUPPORT)
           // Pronterface "M29" and "M29 " has no line number

commit 0578bbbf5d744f025978dbc81d7941048a45698f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat May 23 16:12:54 2020 -0500

    Marlin: Use strcmp_P

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 4b974113fb..b98ef10992 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -523,12 +523,12 @@ void GCodeQueue::get_serial_commands() {
 
         #if DISABLED(EMERGENCY_PARSER)
           // Process critical commands early
-          if (strcmp(command, "M108") == 0) {
+          if (strcmp_P(command, PSTR("M108")) == 0) {
             wait_for_heatup = false;
             TERN_(HAS_LCD_MENU, wait_for_user = false);
           }
-          if (strcmp(command, "M112") == 0) kill(M112_KILL_STR, nullptr, true);
-          if (strcmp(command, "M410") == 0) quickstop_stepper();
+          if (strcmp_P(command, PSTR("M112")) == 0) kill(M112_KILL_STR, nullptr, true);
+          if (strcmp_P(command, PSTR("M410")) == 0) quickstop_stepper();
         #endif
 
         #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0

commit d853a70556f89c76dbf02b3723d71d9b56c2c4cf
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 12 01:45:28 2020 -0500

    Remove strcpy compile warning

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 4d7d107ebd..4b974113fb 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -216,13 +216,12 @@ bool GCodeQueue::process_injected_command() {
     gcode.process_parsed_command();
   }
 
-  #pragma GCC diagnostic push
-  #pragma GCC diagnostic ignored "-Wrestrict"
-
   // Copy the next command into place
-  strcpy(injected_commands, &injected_commands[i + (c != '\0')]);
-
-  #pragma GCC diagnostic pop
+  for (
+    uint8_t d = 0, s = i + !!c;                     // dst, src
+    (injected_commands[d] = injected_commands[s]);  // copy, exit if 0
+    d++, s++                                        // next dst, src
+  );
 
   return true;
 }

commit bd82b8bc7ee506d89a99a408fccdad5853ab39b6
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Apr 28 08:30:52 2020 -0500

    Suppress compile warnings

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 7c4dc08486..4d7d107ebd 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -216,8 +216,14 @@ bool GCodeQueue::process_injected_command() {
     gcode.process_parsed_command();
   }
 
+  #pragma GCC diagnostic push
+  #pragma GCC diagnostic ignored "-Wrestrict"
+
   // Copy the next command into place
   strcpy(injected_commands, &injected_commands[i + (c != '\0')]);
+
+  #pragma GCC diagnostic pop
+
   return true;
 }
 

commit 6d90d1e1f552dca5e21bc61b676b8e8ce731b280
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 22 16:35:03 2020 -0500

    Apply TERN to compact code (#17619)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 43272e7835..7c4dc08486 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -127,9 +127,7 @@ void GCodeQueue::_commit_command(bool say_ok
   #if NUM_SERIAL > 1
     port[index_w] = p;
   #endif
-  #if ENABLED(POWER_LOSS_RECOVERY)
-    recovery.commit_sdpos(index_w);
-  #endif
+  TERN_(POWER_LOSS_RECOVERY, recovery.commit_sdpos(index_w));
   if (++index_w >= BUFSIZE) index_w = 0;
   length++;
 }
@@ -522,9 +520,7 @@ void GCodeQueue::get_serial_commands() {
           // Process critical commands early
           if (strcmp(command, "M108") == 0) {
             wait_for_heatup = false;
-            #if HAS_LCD_MENU
-              wait_for_user = false;
-            #endif
+            TERN_(HAS_LCD_MENU, wait_for_user = false);
           }
           if (strcmp(command, "M112") == 0) kill(M112_KILL_STR, nullptr, true);
           if (strcmp(command, "M410") == 0) quickstop_stepper();
@@ -601,9 +597,7 @@ void GCodeQueue::get_available_commands() {
 
   get_serial_commands();
 
-  #if ENABLED(SDSUPPORT)
-    get_sdcard_commands();
-  #endif
+  TERN_(SDSUPPORT, get_sdcard_commands());
 }
 
 /**

commit 48919c54fb4e793b6bb17022f9badbd3530733ae
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Apr 9 20:05:58 2020 -0500

    Add SRAM command injection (#17459)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index abb50b960d..43272e7835 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -86,11 +86,15 @@ static int serial_count[NUM_SERIAL] = { 0 };
 bool send_ok[BUFSIZE];
 
 /**
- * Next Injected Command pointer. nullptr if no commands are being injected.
- * Used by Marlin internally to ensure that commands initiated from within
- * are enqueued ahead of any pending serial or sd card commands.
+ * Next Injected PROGMEM Command pointer. (nullptr == empty)
+ * Internal commands are enqueued ahead of serial / SD commands.
  */
-static PGM_P injected_commands_P = nullptr;
+PGM_P GCodeQueue::injected_commands_P; // = nullptr
+
+/**
+ * Injected SRAM Commands
+ */
+char GCodeQueue::injected_commands[64]; // = { 0 }
 
 GCodeQueue::GCodeQueue() {
   // Send "ok" after commands by default
@@ -101,7 +105,7 @@ GCodeQueue::GCodeQueue() {
  * Check whether there are any commands yet to be executed
  */
 bool GCodeQueue::has_commands_queued() {
-  return queue.length || injected_commands_P;
+  return queue.length || injected_commands_P || injected_commands[0];
 }
 
 /**
@@ -172,11 +176,10 @@ bool GCodeQueue::enqueue_one(const char* cmd) {
 }
 
 /**
- * Process the next "immediate" command.
- * Return 'true' if any commands were processed,
- * or remain to process.
+ * Process the next "immediate" command from PROGMEM.
+ * Return 'true' if any commands were processed.
  */
-bool GCodeQueue::process_injected_command() {
+bool GCodeQueue::process_injected_command_P() {
   if (injected_commands_P == nullptr) return false;
 
   char c;
@@ -198,12 +201,27 @@ bool GCodeQueue::process_injected_command() {
 }
 
 /**
- * Enqueue one or many commands to run from program memory.
- * Do not inject a comment or use leading spaces!
- * Aborts the current queue, if any.
- * Note: process_injected_command() will be called to drain any commands afterwards
+ * Process the next "immediate" command from SRAM.
+ * Return 'true' if any commands were processed.
  */
-void GCodeQueue::inject_P(PGM_P const pgcode) { injected_commands_P = pgcode; }
+bool GCodeQueue::process_injected_command() {
+  if (injected_commands[0] == '\0') return false;
+
+  char c;
+  size_t i = 0;
+  while ((c = injected_commands[i]) && c != '\n') i++;
+
+  // Execute a non-blank command
+  if (i) {
+    injected_commands[i] = '\0';
+    parser.parse(injected_commands);
+    gcode.process_parsed_command();
+  }
+
+  // Copy the next command into place
+  strcpy(injected_commands, &injected_commands[i + (c != '\0')]);
+  return true;
+}
 
 /**
  * Enqueue and return only when commands are actually enqueued.
@@ -575,7 +593,7 @@ void GCodeQueue::get_serial_commands() {
 
 /**
  * Add to the circular command queue the next command from:
- *  - The command-injection queue (injected_commands_P)
+ *  - The command-injection queues (injected_commands_P, injected_commands)
  *  - The active serial input (usually USB)
  *  - The SD card file being actively printed
  */
@@ -594,7 +612,7 @@ void GCodeQueue::get_available_commands() {
 void GCodeQueue::advance() {
 
   // Process immediate commands
-  if (process_injected_command()) return;
+  if (process_injected_command_P() || process_injected_command()) return;
 
   // Return if the G-code buffer is empty
   if (!length) return;

commit 118bd2f8b2a1f81884cb55a8fc00b708a51aa15b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 13 23:18:16 2020 -0500

    Apply loop shorthand macros (#17159)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 13047b2151..abb50b960d 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -94,7 +94,7 @@ static PGM_P injected_commands_P = nullptr;
 
 GCodeQueue::GCodeQueue() {
   // Send "ok" after commands by default
-  for (uint8_t i = 0; i < COUNT(send_ok); i++) send_ok[i] = true;
+  LOOP_L_N(i, COUNT(send_ok)) send_ok[i] = true;
 }
 
 /**
@@ -427,7 +427,7 @@ void GCodeQueue::get_serial_commands() {
    * Loop while serial characters are incoming and the queue is not full
    */
   while (length < BUFSIZE && serial_data_available()) {
-    for (uint8_t i = 0; i < NUM_SERIAL; ++i) {
+    LOOP_L_N(i, NUM_SERIAL) {
 
       const int c = read_serial(i);
       if (c < 0) continue;

commit 6bead0c1b04152f6a291d851f6cd4029fe0fc616
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 13 16:29:29 2020 -0500

    Shorter paths to HAL, ExtUI (#17156)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 3a1f3d2d3d..13047b2151 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -44,7 +44,7 @@ GCodeQueue queue;
 #endif
 
 #if ENABLED(POWER_LOSS_RECOVERY)
-  #include "../feature/power_loss_recovery.h"
+  #include "../feature/powerloss.h"
 #endif
 
 /**
@@ -150,6 +150,8 @@ bool GCodeQueue::_enqueue(const char* cmd, bool say_ok/*=false*/
   return true;
 }
 
+#define ISEOL(C) ((C) == '\n' || (C) == '\r')
+
 /**
  * Enqueue with Serial Echo
  * Return true if the command was consumed
@@ -160,7 +162,7 @@ bool GCodeQueue::enqueue_one(const char* cmd) {
   //SERIAL_ECHO(cmd);
   //SERIAL_ECHOPGM("\") \n");
 
-  if (*cmd == 0 || *cmd == '\n' || *cmd == '\r') return true;
+  if (*cmd == 0 || ISEOL(*cmd)) return true;
 
   if (_enqueue(cmd)) {
     SERIAL_ECHO_MSG(STR_ENQUEUEING, cmd, "\"");
@@ -432,7 +434,7 @@ void GCodeQueue::get_serial_commands() {
 
       const char serial_char = c;
 
-      if (serial_char == '\n' || serial_char == '\r') {
+      if (ISEOL(serial_char)) {
 
         // Reset our state, continue if the line was empty
         if (process_line_done(serial_input_state[i], serial_line_buffer[i], serial_count[i]))
@@ -549,7 +551,7 @@ void GCodeQueue::get_serial_commands() {
       if (n < 0 && !card_eof) { SERIAL_ERROR_MSG(STR_SD_ERR_READ); continue; }
 
       const char sd_char = (char)n;
-      const bool is_eol = sd_char == '\n' || sd_char == '\r';
+      const bool is_eol = ISEOL(sd_char);
       if (is_eol || card_eof) {
 
         // Reset stream state, terminate the buffer, and commit a non-empty command

commit 4e3a793f1ec29f2e9df5f84818f5fbfa2e832fac
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Mar 10 18:04:54 2020 -0500

    Fix broken enqueue_P

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 0a5dfd0378..3a1f3d2d3d 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -209,6 +209,21 @@ void GCodeQueue::inject_P(PGM_P const pgcode) { injected_commands_P = pgcode; }
  */
 void GCodeQueue::enqueue_one_now(const char* cmd) { while (!enqueue_one(cmd)) idle(); }
 
+/**
+ * Attempt to enqueue a single G-code command
+ * and return 'true' if successful.
+ */
+bool GCodeQueue::enqueue_one_P(PGM_P const pgcode) {
+  size_t i = 0;
+  PGM_P p = pgcode;
+  char c;
+  while ((c = pgm_read_byte(&p[i])) && c != '\n') i++;
+  char cmd[i + 1];
+  memcpy_P(cmd, p, i);
+  cmd[i] = '\0';
+  return _enqueue(cmd);
+}
+
 /**
  * Enqueue from program memory and return only when commands are actually enqueued
  * Never call this from a G-code handler!

commit 20f93404a7b7fca91176508fa6d304dc61e8dddb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 1 21:08:01 2020 -0600

    Add / correct comments

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 7d17ca602b..0a5dfd0378 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -361,6 +361,10 @@ inline void process_stream_char(const char c, uint8_t &sis, char (&buff)[MAX_CMD
     sis = PS_EOL;               // Skip the rest on overflow
 }
 
+/**
+ * Handle a line being completed. For an empty line
+ * keep sensor readings going and watchdog alive.
+ */
 inline bool process_line_done(uint8_t &sis, char (&buff)[MAX_CMD_SIZE], int &ind) {
   sis = PS_NORMAL;
   buff[ind] = 0;

commit e78f607ef33044eecde744e77beea87532817c47
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Feb 26 03:02:03 2020 -0600

    Use a STR_ prefix for non-translated strings

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index ec1d3ebd35..7d17ca602b 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -163,7 +163,7 @@ bool GCodeQueue::enqueue_one(const char* cmd) {
   if (*cmd == 0 || *cmd == '\n' || *cmd == '\r') return true;
 
   if (_enqueue(cmd)) {
-    SERIAL_ECHO_MSG(MSG_ENQUEUEING, cmd, "\"");
+    SERIAL_ECHO_MSG(STR_ENQUEUEING, cmd, "\"");
     return true;
   }
   return false;
@@ -244,7 +244,7 @@ void GCodeQueue::ok_to_send() {
     PORT_REDIRECT(pn);                    // Reply to the serial port that sent the command
   #endif
   if (!send_ok[index_r]) return;
-  SERIAL_ECHOPGM(MSG_OK);
+  SERIAL_ECHOPGM(STR_OK);
   #if ENABLED(ADVANCED_OK)
     char* p = command_buffer[index_r];
     if (*p == 'N') {
@@ -270,7 +270,7 @@ void GCodeQueue::flush_and_request_resend() {
     PORT_REDIRECT(pn);                    // Reply to the serial port that sent the command
   #endif
   SERIAL_FLUSH();
-  SERIAL_ECHOPGM(MSG_RESEND);
+  SERIAL_ECHOPGM(STR_RESEND);
   SERIAL_ECHOLN(last_N + 1);
   ok_to_send();
 }
@@ -397,7 +397,7 @@ void GCodeQueue::get_serial_commands() {
     static millis_t last_command_time = 0;
     const millis_t ms = millis();
     if (length == 0 && !serial_data_available() && ELAPSED(ms, last_command_time + NO_TIMEOUTS)) {
-      SERIAL_ECHOLNPGM(MSG_WAIT);
+      SERIAL_ECHOLNPGM(STR_WAIT);
       last_command_time = ms;
     }
   #endif
@@ -436,24 +436,24 @@ void GCodeQueue::get_serial_commands() {
           gcode_N = strtol(npos + 1, nullptr, 10);
 
           if (gcode_N != last_N + 1 && !M110)
-            return gcode_line_error(PSTR(MSG_ERR_LINE_NO), i);
+            return gcode_line_error(PSTR(STR_ERR_LINE_NO), i);
 
           char *apos = strrchr(command, '*');
           if (apos) {
             uint8_t checksum = 0, count = uint8_t(apos - command);
             while (count) checksum ^= command[--count];
             if (strtol(apos + 1, nullptr, 10) != checksum)
-              return gcode_line_error(PSTR(MSG_ERR_CHECKSUM_MISMATCH), i);
+              return gcode_line_error(PSTR(STR_ERR_CHECKSUM_MISMATCH), i);
           }
           else
-            return gcode_line_error(PSTR(MSG_ERR_NO_CHECKSUM), i);
+            return gcode_line_error(PSTR(STR_ERR_NO_CHECKSUM), i);
 
           last_N = gcode_N;
         }
         #if ENABLED(SDSUPPORT)
           // Pronterface "M29" and "M29 " has no line number
           else if (card.flag.saving && !is_M29(command))
-            return gcode_line_error(PSTR(MSG_ERR_NO_CHECKSUM), i);
+            return gcode_line_error(PSTR(STR_ERR_NO_CHECKSUM), i);
         #endif
 
         //
@@ -472,7 +472,7 @@ void GCodeQueue::get_serial_commands() {
                 case 5:
               #endif
                 PORT_REDIRECT(i);                      // Reply to the serial port that sent the command
-                SERIAL_ECHOLNPGM(MSG_ERR_STOPPED);
+                SERIAL_ECHOLNPGM(STR_ERR_STOPPED);
                 LCD_MESSAGEPGM(MSG_STOPPED);
                 break;
             }
@@ -527,7 +527,7 @@ void GCodeQueue::get_serial_commands() {
     while (length < BUFSIZE && !card_eof) {
       const int16_t n = card.get();
       card_eof = card.eof();
-      if (n < 0 && !card_eof) { SERIAL_ERROR_MSG(MSG_SD_ERR_READ); continue; }
+      if (n < 0 && !card_eof) { SERIAL_ERROR_MSG(STR_SD_ERR_READ); continue; }
 
       const char sd_char = (char)n;
       const bool is_eol = sd_char == '\n' || sd_char == '\r';
@@ -585,7 +585,7 @@ void GCodeQueue::advance() {
       if (is_M29(command)) {
         // M29 closes the file
         card.closefile();
-        SERIAL_ECHOLNPGM(MSG_FILE_SAVED);
+        SERIAL_ECHOLNPGM(STR_FILE_SAVED);
 
         #if !defined(__AVR__) || !defined(USBCON)
           #if ENABLED(SERIAL_STATS_DROPPED_RX)

commit 5071fe82ab221627ef10cf4125896e3d2585993a
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Feb 25 22:18:14 2020 -0600

    Ensure proper SD print completion (#16967)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index edcb025bb3..ec1d3ebd35 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -512,9 +512,10 @@ void GCodeQueue::get_serial_commands() {
 #if ENABLED(SDSUPPORT)
 
   /**
-   * Get commands from the SD Card until the command buffer is full
-   * or until the end of the file is reached. The special character '#'
-   * can also interrupt buffering.
+   * Get lines from the SD Card until the command buffer is full
+   * or until the end of the file is reached. Because this method
+   * always receives complete command-lines, they can go directly
+   * into the main command queue.
    */
   inline void GCodeQueue::get_sdcard_commands() {
     static uint8_t sd_input_state = PS_NORMAL;
@@ -527,37 +528,21 @@ void GCodeQueue::get_serial_commands() {
       const int16_t n = card.get();
       card_eof = card.eof();
       if (n < 0 && !card_eof) { SERIAL_ERROR_MSG(MSG_SD_ERR_READ); continue; }
+
       const char sd_char = (char)n;
-      if (sd_char == '\n' || sd_char == '\r' || card_eof) {
+      const bool is_eol = sd_char == '\n' || sd_char == '\r';
+      if (is_eol || card_eof) {
 
         // Reset stream state, terminate the buffer, and commit a non-empty command
+        if (!is_eol && sd_count) ++sd_count;          // End of file with no newline
         if (!process_line_done(sd_input_state, command_buffer[index_w], sd_count)) {
-          _commit_command(false);                     // Can handle last line missing a newline terminator
+          _commit_command(false);
           #if ENABLED(POWER_LOSS_RECOVERY)
-            recovery.cmd_sdpos = card.getIndex();     // Prime for the next _commit_command
+            recovery.cmd_sdpos = card.getIndex();     // Prime for the NEXT _commit_command
           #endif
         }
 
-        if (card_eof) {
-
-          card.fileHasFinished();                     // Handle end of file reached
-
-          if (!IS_SD_PRINTING()) {                    // Was it the main job file?
-            SERIAL_ECHOLNPGM(MSG_FILE_PRINTED);       // Tell the host the file is printed.
-            #if ENABLED(PRINTER_EVENT_LEDS)
-              printerEventLEDs.onPrintCompleted();    // Change LED color for Print Completed
-              #if HAS_RESUME_CONTINUE
-                enqueue_now_P(PSTR("M0 S"             // Display "Click to Continue..."
-                  #if HAS_LCD_MENU
-                    "1800"                            // ...for 30 minutes with LCD
-                  #else
-                    "60"                              // ...for 1 minute with no LCD
-                  #endif
-                ));
-              #endif
-            #endif
-          }
-        }
+        if (card_eof) card.fileHasFinished();         // Handle end of file reached
       }
       else
         process_stream_char(sd_char, sd_input_state, command_buffer[index_w], sd_count);
@@ -633,9 +618,7 @@ void GCodeQueue::advance() {
   #endif // SDSUPPORT
 
   // The queue may be reset by a command handler or by code invoked by idle() within a handler
-  if (length) {
-    --length;
-    if (++index_r >= BUFSIZE) index_r = 0;
-  }
+  --length;
+  if (++index_r >= BUFSIZE) index_r = 0;
 
 }

commit 9040394e8e1eb67e995bee59b340309448329c2e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 24 10:58:54 2020 -0600

    Fix card_eof error

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 5edd2d926b..edcb025bb3 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -526,7 +526,7 @@ void GCodeQueue::get_serial_commands() {
     while (length < BUFSIZE && !card_eof) {
       const int16_t n = card.get();
       card_eof = card.eof();
-      if (n < 0) { SERIAL_ERROR_MSG(MSG_SD_ERR_READ); continue; }
+      if (n < 0 && !card_eof) { SERIAL_ERROR_MSG(MSG_SD_ERR_READ); continue; }
       const char sd_char = (char)n;
       if (sd_char == '\n' || sd_char == '\r' || card_eof) {
 

commit b2328d089a1c3c375de729c0af623c638d631078
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Feb 22 21:36:12 2020 -0600

    Allow LCD_PIXEL_WIDTH/HEIGHT override

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index c3c155e4c3..5edd2d926b 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -532,7 +532,7 @@ void GCodeQueue::get_serial_commands() {
 
         // Reset stream state, terminate the buffer, and commit a non-empty command
         if (!process_line_done(sd_input_state, command_buffer[index_w], sd_count)) {
-          _commit_command(false);                     // The file was not terminated with a newline
+          _commit_command(false);                     // Can handle last line missing a newline terminator
           #if ENABLED(POWER_LOSS_RECOVERY)
             recovery.cmd_sdpos = card.getIndex();     // Prime for the next _commit_command
           #endif

commit 29ec868c4bc19058f02039c2a90e21fed816c257
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Feb 22 20:45:59 2020 -0600

    Commit last SD line before fileHasFinished

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 12c3703630..c3c155e4c3 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -526,42 +526,38 @@ void GCodeQueue::get_serial_commands() {
     while (length < BUFSIZE && !card_eof) {
       const int16_t n = card.get();
       card_eof = card.eof();
+      if (n < 0) { SERIAL_ERROR_MSG(MSG_SD_ERR_READ); continue; }
       const char sd_char = (char)n;
-      if (card_eof || n < 0 || sd_char == '\n' || sd_char == '\r') {
+      if (sd_char == '\n' || sd_char == '\r' || card_eof) {
+
+        // Reset stream state, terminate the buffer, and commit a non-empty command
+        if (!process_line_done(sd_input_state, command_buffer[index_w], sd_count)) {
+          _commit_command(false);                     // The file was not terminated with a newline
+          #if ENABLED(POWER_LOSS_RECOVERY)
+            recovery.cmd_sdpos = card.getIndex();     // Prime for the next _commit_command
+          #endif
+        }
+
         if (card_eof) {
 
-          card.printingHasFinished();
+          card.fileHasFinished();                     // Handle end of file reached
 
-          if (IS_SD_PRINTING())
-            sd_count = 0; // If a sub-file was printing, continue from call point
-          else {
-            SERIAL_ECHOLNPGM(MSG_FILE_PRINTED);
+          if (!IS_SD_PRINTING()) {                    // Was it the main job file?
+            SERIAL_ECHOLNPGM(MSG_FILE_PRINTED);       // Tell the host the file is printed.
             #if ENABLED(PRINTER_EVENT_LEDS)
-              printerEventLEDs.onPrintCompleted();
+              printerEventLEDs.onPrintCompleted();    // Change LED color for Print Completed
               #if HAS_RESUME_CONTINUE
-                enqueue_now_P(PSTR("M0 S"
+                enqueue_now_P(PSTR("M0 S"             // Display "Click to Continue..."
                   #if HAS_LCD_MENU
-                    "1800"
+                    "1800"                            // ...for 30 minutes with LCD
                   #else
-                    "60"
+                    "60"                              // ...for 1 minute with no LCD
                   #endif
                 ));
               #endif
             #endif
           }
         }
-        else if (n < 0)
-          SERIAL_ERROR_MSG(MSG_SD_ERR_READ);
-
-        // Terminate the buffer, reset the input state, continue for empty line
-        if (process_line_done(sd_input_state, command_buffer[index_w], sd_count))
-          continue;
-
-        _commit_command(false);
-
-        #if ENABLED(POWER_LOSS_RECOVERY)
-          recovery.cmd_sdpos = card.getIndex(); // Prime for the next _commit_command
-        #endif
       }
       else
         process_stream_char(sd_char, sd_input_state, command_buffer[index_w], sd_count);

commit 1ab6f910b630905711203491b6edae39bf8328c1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Feb 21 07:24:58 2020 -0600

    Use moves_free in ok_to_send

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 397b5a3923..12c3703630 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -253,7 +253,7 @@ void GCodeQueue::ok_to_send() {
       while (NUMERIC_SIGNED(*p))
         SERIAL_ECHO(*p++);
     }
-    SERIAL_ECHOPAIR_P(SP_P_STR, int(BLOCK_BUFFER_SIZE - planner.movesplanned() - 1));
+    SERIAL_ECHOPAIR_P(SP_P_STR, int(planner.moves_free()));
     SERIAL_ECHOPAIR(" B", int(BUFSIZE - length));
   #endif
   SERIAL_EOL();

commit 22b974691eee6f27d5f790dc2dccda6935b87a08
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Feb 20 20:22:27 2020 -0600

    Tweak process_line_done for speed

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 000747b489..397b5a3923 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -254,7 +254,7 @@ void GCodeQueue::ok_to_send() {
         SERIAL_ECHO(*p++);
     }
     SERIAL_ECHOPAIR_P(SP_P_STR, int(BLOCK_BUFFER_SIZE - planner.movesplanned() - 1));
-    SERIAL_ECHOPAIR(" B", BUFSIZE - length);
+    SERIAL_ECHOPAIR(" B", int(BUFSIZE - length));
   #endif
   SERIAL_EOL();
 }
@@ -364,9 +364,9 @@ inline void process_stream_char(const char c, uint8_t &sis, char (&buff)[MAX_CMD
 inline bool process_line_done(uint8_t &sis, char (&buff)[MAX_CMD_SIZE], int &ind) {
   sis = PS_NORMAL;
   buff[ind] = 0;
-  if (!ind) { thermalManager.manage_heater(); return true; }
-  ind = 0;
-  return false;
+  if (ind) { ind = 0; return false; }
+  thermalManager.manage_heater();
+  return true;
 }
 
 /**
@@ -415,11 +415,13 @@ void GCodeQueue::get_serial_commands() {
 
       if (serial_char == '\n' || serial_char == '\r') {
 
-        if (process_line_done(serial_input_state[i], serial_line_buffer[i], serial_count[i])) continue;
+        // Reset our state, continue if the line was empty
+        if (process_line_done(serial_input_state[i], serial_line_buffer[i], serial_count[i]))
+          continue;
 
         char* command = serial_line_buffer[i];
 
-        while (*command == ' ') command++;                // Skip leading spaces
+        while (*command == ' ') command++;                   // Skip leading spaces
         char *npos = (*command == 'N') ? command : nullptr;  // Require the N parameter to start the line
 
         if (npos) {
@@ -551,7 +553,9 @@ void GCodeQueue::get_serial_commands() {
         else if (n < 0)
           SERIAL_ERROR_MSG(MSG_SD_ERR_READ);
 
-        if (process_line_done(sd_input_state, command_buffer[index_w], sd_count)) continue;
+        // Terminate the buffer, reset the input state, continue for empty line
+        if (process_line_done(sd_input_state, command_buffer[index_w], sd_count))
+          continue;
 
         _commit_command(false);
 

commit 19991e269b07f77e2ef4134da406bb1a6afe9d25
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Feb 20 20:15:08 2020 -0600

    Show end prompt with Print Event LEDs

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 21d6d773ee..000747b489 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -537,7 +537,7 @@ void GCodeQueue::get_serial_commands() {
             #if ENABLED(PRINTER_EVENT_LEDS)
               printerEventLEDs.onPrintCompleted();
               #if HAS_RESUME_CONTINUE
-                enqueue_now_P(PSTR("M0 Q S"
+                enqueue_now_P(PSTR("M0 S"
                   #if HAS_LCD_MENU
                     "1800"
                   #else

commit 1c52d76668cafb28a1838825107e38362cd31c6c
Author: Robby Candra <robbycandra.mail@gmail.com>
Date:   Thu Feb 20 15:22:08 2020 +0700

    Serial redirect for Move Command when stopping (#16906)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index eca6d5cb1d..21d6d773ee 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -469,6 +469,7 @@ void GCodeQueue::get_serial_commands() {
               #if ENABLED(BEZIER_CURVE_SUPPORT)
                 case 5:
               #endif
+                PORT_REDIRECT(i);                      // Reply to the serial port that sent the command
                 SERIAL_ECHOLNPGM(MSG_ERR_STOPPED);
                 LCD_MESSAGEPGM(MSG_STOPPED);
                 break;

commit 42208bc031aae9761d512183c554763df41a34cb
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Sun Feb 16 08:10:20 2020 +0100

    Fix unknown command on empty lines (#16867)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 4d0861c2bc..eca6d5cb1d 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -415,7 +415,7 @@ void GCodeQueue::get_serial_commands() {
 
       if (serial_char == '\n' || serial_char == '\r') {
 
-        process_line_done(serial_input_state[i], serial_line_buffer[i], serial_count[i]);
+        if (process_line_done(serial_input_state[i], serial_line_buffer[i], serial_count[i])) continue;
 
         char* command = serial_line_buffer[i];
 
@@ -550,7 +550,7 @@ void GCodeQueue::get_serial_commands() {
         else if (n < 0)
           SERIAL_ERROR_MSG(MSG_SD_ERR_READ);
 
-        process_line_done(sd_input_state, command_buffer[index_w], sd_count);
+        if (process_line_done(sd_input_state, command_buffer[index_w], sd_count)) continue;
 
         _commit_command(false);
 

commit af84e362cc56404c07b176ee24f3eaad165c0b60
Author: Robby Candra <robbycandra.mail@gmail.com>
Date:   Fri Feb 14 07:59:32 2020 +0700

    Remove unused queue.stopped_N (#16850)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index dbef8d2332..4d0861c2bc 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -52,7 +52,7 @@ GCodeQueue queue;
  * sending commands to Marlin, and lines will be checked for sequentiality.
  * M110 N<int> sets the current line number.
  */
-long gcode_N, GCodeQueue::last_N, GCodeQueue::stopped_N = 0;
+long gcode_N, GCodeQueue::last_N;
 
 /**
  * GCode Command Queue

commit 0e17d10bf325afed9ca3f133dd3d2e5cfb3a7724
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Fri Feb 14 01:30:48 2020 +0100

    Fix G-code line parsing (#16840)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index c01a92ab10..dbef8d2332 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -363,8 +363,8 @@ inline void process_stream_char(const char c, uint8_t &sis, char (&buff)[MAX_CMD
 
 inline bool process_line_done(uint8_t &sis, char (&buff)[MAX_CMD_SIZE], int &ind) {
   sis = PS_NORMAL;
-  if (!ind) { thermalManager.manage_heater(); return true; }
   buff[ind] = 0;
+  if (!ind) { thermalManager.manage_heater(); return true; }
   ind = 0;
   return false;
 }
@@ -377,7 +377,7 @@ inline bool process_line_done(uint8_t &sis, char (&buff)[MAX_CMD_SIZE], int &ind
 void GCodeQueue::get_serial_commands() {
   static char serial_line_buffer[NUM_SERIAL][MAX_CMD_SIZE];
 
-  static uint8_t serial_input_state[NUM_SERIAL] = { 0 };
+  static uint8_t serial_input_state[NUM_SERIAL] = { PS_NORMAL };
 
   #if ENABLED(BINARY_FILE_TRANSFER)
     if (card.flag.binary_mode) {

commit fa4a6cdb5c05abc812a9dce5f20956c0dd42386a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 10 16:33:21 2020 -0600

    Fix out-of-order M0 after SD printing
    
    Fixes #14774
    
    Co-Authored-By: tol2cj <tol2cj@users.noreply.github.com>

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index b83a211967..c01a92ab10 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -536,7 +536,7 @@ void GCodeQueue::get_serial_commands() {
             #if ENABLED(PRINTER_EVENT_LEDS)
               printerEventLEDs.onPrintCompleted();
               #if HAS_RESUME_CONTINUE
-                inject_P(PSTR("M0 Q S"
+                enqueue_now_P(PSTR("M0 Q S"
                   #if HAS_LCD_MENU
                     "1800"
                   #else
@@ -544,7 +544,7 @@ void GCodeQueue::get_serial_commands() {
                   #endif
                 ));
               #endif
-            #endif // PRINTER_EVENT_LEDS
+            #endif
           }
         }
         else if (n < 0)

commit 3bef7a445080fcb133dfa49aefddc0f28057b226
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Feb 10 14:52:15 2020 -0600

    Add g-code quoted strings, improve stream code (#16818)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 5d317b6ca5..b83a211967 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -309,6 +309,66 @@ FORCE_INLINE bool is_M29(const char * const cmd) {  // matches "M29" & "M29 ", b
   return m29 && !NUMERIC(m29[3]);
 }
 
+#define PS_NORMAL 0
+#define PS_EOL    1
+#define PS_QUOTED 2
+#define PS_PAREN  3
+#define PS_ESC    4
+
+inline void process_stream_char(const char c, uint8_t &sis, char (&buff)[MAX_CMD_SIZE], int &ind) {
+
+  if (sis == PS_EOL) return;    // EOL comment or overflow
+
+  #if ENABLED(PAREN_COMMENTS)
+    else if (sis == PS_PAREN) { // Inline comment
+      if (c == ')') sis = PS_NORMAL;
+      return;
+    }
+  #endif
+
+  else if (sis >= PS_ESC)       // End escaped char
+    sis -= PS_ESC;
+
+  else if (c == '\\') {         // Start escaped char
+    sis += PS_ESC;
+    if (sis == PS_ESC) return;  // Keep if quoting
+  }
+
+  #if ENABLED(GCODE_QUOTED_STRINGS)
+
+    else if (sis == PS_QUOTED) {
+      if (c == '"') sis = PS_NORMAL; // End quoted string
+    }
+    else if (c == '"')          // Start quoted string
+      sis = PS_QUOTED;
+
+  #endif
+
+  else if (c == ';') {          // Start end-of-line comment
+    sis = PS_EOL;
+    return;
+  }
+
+  #if ENABLED(PAREN_COMMENTS)
+    else if (c == '(') {        // Start inline comment
+      sis = PS_PAREN;
+      return;
+    }
+  #endif
+
+  buff[ind++] = c;
+  if (ind >= MAX_CMD_SIZE - 1)
+    sis = PS_EOL;               // Skip the rest on overflow
+}
+
+inline bool process_line_done(uint8_t &sis, char (&buff)[MAX_CMD_SIZE], int &ind) {
+  sis = PS_NORMAL;
+  if (!ind) { thermalManager.manage_heater(); return true; }
+  buff[ind] = 0;
+  ind = 0;
+  return false;
+}
+
 /**
  * Get all commands waiting on the serial port and queue them.
  * Exit when the buffer is full or when no more characters are
@@ -316,11 +376,8 @@ FORCE_INLINE bool is_M29(const char * const cmd) {  // matches "M29" & "M29 ", b
  */
 void GCodeQueue::get_serial_commands() {
   static char serial_line_buffer[NUM_SERIAL][MAX_CMD_SIZE];
-  static bool serial_comment_mode[NUM_SERIAL] = { false }
-              #if ENABLED(PAREN_COMMENTS)
-                , serial_comment_paren_mode[NUM_SERIAL] = { false }
-              #endif
-            ;
+
+  static uint8_t serial_input_state[NUM_SERIAL] = { 0 };
 
   #if ENABLED(BINARY_FILE_TRANSFER)
     if (card.flag.binary_mode) {
@@ -350,27 +407,15 @@ void GCodeQueue::get_serial_commands() {
    */
   while (length < BUFSIZE && serial_data_available()) {
     for (uint8_t i = 0; i < NUM_SERIAL; ++i) {
-      int c;
-      if ((c = read_serial(i)) < 0) continue;
 
-      char serial_char = c;
+      const int c = read_serial(i);
+      if (c < 0) continue;
 
-      /**
-       * If the character ends the line
-       */
-      if (serial_char == '\n' || serial_char == '\r') {
-
-        // Start with comment mode off
-        serial_comment_mode[i] = false;
-        #if ENABLED(PAREN_COMMENTS)
-          serial_comment_paren_mode[i] = false;
-        #endif
+      const char serial_char = c;
 
-        // Skip empty lines and comments
-        if (!serial_count[i]) { thermalManager.manage_heater(); continue; }
+      if (serial_char == '\n' || serial_char == '\r') {
 
-        serial_line_buffer[i][serial_count[i]] = 0;       // Terminate string
-        serial_count[i] = 0;                              // Reset buffer
+        process_line_done(serial_input_state[i], serial_line_buffer[i], serial_count[i]);
 
         char* command = serial_line_buffer[i];
 
@@ -409,16 +454,17 @@ void GCodeQueue::get_serial_commands() {
             return gcode_line_error(PSTR(MSG_ERR_NO_CHECKSUM), i);
         #endif
 
-        // Movement commands alert when stopped
+        //
+        // Movement commands give an alert when the machine is stopped
+        //
+
         if (IsStopped()) {
           char* gpos = strchr(command, 'G');
           if (gpos) {
             switch (strtol(gpos + 1, nullptr, 10)) {
-              case 0:
-              case 1:
+              case 0: case 1:
               #if ENABLED(ARC_SUPPORT)
-                case 2:
-                case 3:
+                case 2: case 3:
               #endif
               #if ENABLED(BEZIER_CURVE_SUPPORT)
                 case 5:
@@ -453,31 +499,9 @@ void GCodeQueue::get_serial_commands() {
           #endif
         );
       }
-      else if (serial_count[i] >= MAX_CMD_SIZE - 1) {
-        // Keep fetching, but ignore normal characters beyond the max length
-        // The command will be injected when EOL is reached
-      }
-      else if (serial_char == '\\') {  // Handle escapes
-        // if we have one more character, copy it over
-        if ((c = read_serial(i)) >= 0 && !serial_comment_mode[i]
-          #if ENABLED(PAREN_COMMENTS)
-            && !serial_comment_paren_mode[i]
-          #endif
-        )
-          serial_line_buffer[i][serial_count[i]++] = (char)c;
-      }
-      else { // it's not a newline, carriage return or escape char
-        if (serial_char == ';') serial_comment_mode[i] = true;
-        #if ENABLED(PAREN_COMMENTS)
-          else if (serial_char == '(') serial_comment_paren_mode[i] = true;
-          else if (serial_char == ')') serial_comment_paren_mode[i] = false;
-        #endif
-        else if (!serial_comment_mode[i]
-          #if ENABLED(PAREN_COMMENTS)
-            && ! serial_comment_paren_mode[i]
-          #endif
-        ) serial_line_buffer[i][serial_count[i]++] = serial_char;
-      }
+      else
+        process_stream_char(serial_char, serial_input_state[i], serial_line_buffer[i], serial_count[i]);
+
     } // for NUM_SERIAL
   } // queue has space, serial has data
 }
@@ -490,21 +514,17 @@ void GCodeQueue::get_serial_commands() {
    * can also interrupt buffering.
    */
   inline void GCodeQueue::get_sdcard_commands() {
-    static bool sd_comment_mode = false
-                #if ENABLED(PAREN_COMMENTS)
-                  , sd_comment_paren_mode = false
-                #endif
-              ;
+    static uint8_t sd_input_state = PS_NORMAL;
 
     if (!IS_SD_PRINTING()) return;
 
-    uint16_t sd_count = 0;
+    int sd_count = 0;
     bool card_eof = card.eof();
     while (length < BUFSIZE && !card_eof) {
       const int16_t n = card.get();
-      char sd_char = (char)n;
       card_eof = card.eof();
-      if (card_eof || n == -1 || sd_char == '\n' || sd_char == '\r') {
+      const char sd_char = (char)n;
+      if (card_eof || n < 0 || sd_char == '\n' || sd_char == '\r') {
         if (card_eof) {
 
           card.printingHasFinished();
@@ -527,19 +547,10 @@ void GCodeQueue::get_serial_commands() {
             #endif // PRINTER_EVENT_LEDS
           }
         }
-        else if (n == -1)
+        else if (n < 0)
           SERIAL_ERROR_MSG(MSG_SD_ERR_READ);
 
-        sd_comment_mode = false; // for new command
-        #if ENABLED(PAREN_COMMENTS)
-          sd_comment_paren_mode = false;
-        #endif
-
-        // Skip empty lines and comments
-        if (!sd_count) { thermalManager.manage_heater(); continue; }
-
-        command_buffer[index_w][sd_count] = '\0'; // terminate string
-        sd_count = 0; // clear sd line buffer
+        process_line_done(sd_input_state, command_buffer[index_w], sd_count);
 
         _commit_command(false);
 
@@ -547,24 +558,9 @@ void GCodeQueue::get_serial_commands() {
           recovery.cmd_sdpos = card.getIndex(); // Prime for the next _commit_command
         #endif
       }
-      else if (sd_count >= MAX_CMD_SIZE - 1) {
-        /**
-         * Keep fetching, but ignore normal characters beyond the max length
-         * The command will be injected when EOL is reached
-         */
-      }
-      else {
-        if (sd_char == ';') sd_comment_mode = true;
-        #if ENABLED(PAREN_COMMENTS)
-          else if (sd_char == '(') sd_comment_paren_mode = true;
-          else if (sd_char == ')') sd_comment_paren_mode = false;
-        #endif
-        else if (!sd_comment_mode
-          #if ENABLED(PAREN_COMMENTS)
-            && ! sd_comment_paren_mode
-          #endif
-        ) command_buffer[index_w][sd_count++] = sd_char;
-      }
+      else
+        process_stream_char(sd_char, sd_input_state, command_buffer[index_w], sd_count);
+
     }
   }
 

commit 0ce83dee9560fc30f27fdddc450d3861725d9a22
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Feb 8 23:10:01 2020 -0600

    Show print time with PRINTER_EVENT_LEDS

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 324e6bcb50..5d317b6ca5 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -163,8 +163,7 @@ bool GCodeQueue::enqueue_one(const char* cmd) {
   if (*cmd == 0 || *cmd == '\n' || *cmd == '\r') return true;
 
   if (_enqueue(cmd)) {
-    SERIAL_ECHO_START();
-    SERIAL_ECHOLNPAIR(MSG_ENQUEUEING, cmd, "\"");
+    SERIAL_ECHO_MSG(MSG_ENQUEUEING, cmd, "\"");
     return true;
   }
   return false;
@@ -517,7 +516,7 @@ void GCodeQueue::get_serial_commands() {
             #if ENABLED(PRINTER_EVENT_LEDS)
               printerEventLEDs.onPrintCompleted();
               #if HAS_RESUME_CONTINUE
-                inject_P(PSTR("M0 S"
+                inject_P(PSTR("M0 Q S"
                   #if HAS_LCD_MENU
                     "1800"
                   #else

commit bfad23d3e2e590b257ebe4317d7b14cc2dd3435c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 3 08:00:57 2020 -0600

    (c) 2020

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index d581509963..324e6bcb50 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -1,6 +1,6 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm

commit 0e72c315a0be49e98758d9744ac0117b0904b7e1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Feb 1 17:05:42 2020 -0600

    Minor string storage optimization

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index b9b4d1bd96..d581509963 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -254,8 +254,8 @@ void GCodeQueue::ok_to_send() {
       while (NUMERIC_SIGNED(*p))
         SERIAL_ECHO(*p++);
     }
-    SERIAL_ECHOPGM(" P"); SERIAL_ECHO(int(BLOCK_BUFFER_SIZE - planner.movesplanned() - 1));
-    SERIAL_ECHOPGM(" B"); SERIAL_ECHO(BUFSIZE - length);
+    SERIAL_ECHOPAIR_P(SP_P_STR, int(BLOCK_BUFFER_SIZE - planner.movesplanned() - 1));
+    SERIAL_ECHOPAIR(" B", BUFSIZE - length);
   #endif
   SERIAL_EOL();
 }

commit 5296af94d22074112ed1a7ca4a7af720cc1ebe94
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Feb 1 06:49:56 2020 -0600

    Drop obsolete SD special char handling
    
    See #14035

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index b1673f57f3..b9b4d1bd96 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -491,8 +491,7 @@ void GCodeQueue::get_serial_commands() {
    * can also interrupt buffering.
    */
   inline void GCodeQueue::get_sdcard_commands() {
-    static bool stop_buffering = false,
-                sd_comment_mode = false
+    static bool sd_comment_mode = false
                 #if ENABLED(PAREN_COMMENTS)
                   , sd_comment_paren_mode = false
                 #endif
@@ -500,29 +499,13 @@ void GCodeQueue::get_serial_commands() {
 
     if (!IS_SD_PRINTING()) return;
 
-    /**
-     * '#' stops reading from SD to the buffer prematurely, so procedural
-     * macro calls are possible. If it occurs, stop_buffering is triggered
-     * and the buffer is run dry; this character _can_ occur in serial com
-     * due to checksums, however, no checksums are used in SD printing.
-     */
-
-    if (length == 0) stop_buffering = false;
-
     uint16_t sd_count = 0;
     bool card_eof = card.eof();
-    while (length < BUFSIZE && !card_eof && !stop_buffering) {
+    while (length < BUFSIZE && !card_eof) {
       const int16_t n = card.get();
       char sd_char = (char)n;
       card_eof = card.eof();
-      if (card_eof || n == -1
-          || sd_char == '\n' || sd_char == '\r'
-          || ((sd_char == '#' || sd_char == ':') && !sd_comment_mode
-            #if ENABLED(PAREN_COMMENTS)
-              && !sd_comment_paren_mode
-            #endif
-          )
-      ) {
+      if (card_eof || n == -1 || sd_char == '\n' || sd_char == '\r') {
         if (card_eof) {
 
           card.printingHasFinished();
@@ -548,8 +531,6 @@ void GCodeQueue::get_serial_commands() {
         else if (n == -1)
           SERIAL_ERROR_MSG(MSG_SD_ERR_READ);
 
-        if (sd_char == '#') stop_buffering = true;
-
         sd_comment_mode = false; // for new command
         #if ENABLED(PAREN_COMMENTS)
           sd_comment_paren_mode = false;

commit a0a93e35ae4275c1f99d776b5cc32d91ee7160d2
Author: Robby Candra <robbycandra.mail@gmail.com>
Date:   Mon Jan 27 11:46:26 2020 +0700

    Fix serial port redirection (index ‚â† port num) (#16687)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index ff35b553a8..b1673f57f3 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -191,7 +191,6 @@ bool GCodeQueue::process_injected_command() {
   // Execute command if non-blank
   if (i) {
     parser.parse(cmd);
-    PORT_REDIRECT(SERIAL_PORT);
     gcode.process_parsed_command();
   }
   return true;
@@ -243,7 +242,7 @@ void GCodeQueue::ok_to_send() {
   #if NUM_SERIAL > 1
     const int16_t pn = port[index_r];
     if (pn < 0) return;
-    PORT_REDIRECT(pn);
+    PORT_REDIRECT(pn);                    // Reply to the serial port that sent the command
   #endif
   if (!send_ok[index_r]) return;
   SERIAL_ECHOPGM(MSG_OK);
@@ -267,9 +266,9 @@ void GCodeQueue::ok_to_send() {
  */
 void GCodeQueue::flush_and_request_resend() {
   #if NUM_SERIAL > 1
-    const int16_t p = port[index_r];
-    if (p < 0) return;
-    PORT_REDIRECT(p);
+    const int16_t pn = port[index_r];
+    if (pn < 0) return;
+    PORT_REDIRECT(pn);                    // Reply to the serial port that sent the command
   #endif
   SERIAL_FLUSH();
   SERIAL_ECHOPGM(MSG_RESEND);
@@ -296,14 +295,14 @@ inline int read_serial(const uint8_t index) {
   }
 }
 
-void GCodeQueue::gcode_line_error(PGM_P const err, const int8_t port) {
-  PORT_REDIRECT(port);
+void GCodeQueue::gcode_line_error(PGM_P const err, const int8_t pn) {
+  PORT_REDIRECT(pn);                      // Reply to the serial port that sent the command
   SERIAL_ERROR_START();
   serialprintPGM(err);
   SERIAL_ECHOLN(last_N);
-  while (read_serial(port) != -1);           // clear out the RX buffer
+  while (read_serial(pn) != -1);          // Clear out the RX buffer
   flush_and_request_resend();
-  serial_count[port] = 0;
+  serial_count[pn] = 0;
 }
 
 FORCE_INLINE bool is_M29(const char * const cmd) {  // matches "M29" & "M29 ", but not "M290", etc

commit 79c2f05e7d1e83817f23e09bcafa3b9f55c3acf5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Jan 19 19:00:17 2020 -0600

    Fix M112 with Emergency Parser

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index a026e479a9..ff35b553a8 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -440,7 +440,7 @@ void GCodeQueue::get_serial_commands() {
               wait_for_user = false;
             #endif
           }
-          if (strcmp(command, "M112") == 0) kill();
+          if (strcmp(command, "M112") == 0) kill(M112_KILL_STR, nullptr, true);
           if (strcmp(command, "M410") == 0) quickstop_stepper();
         #endif
 

commit d0e1166cce60381fbdad1105d13765806a525d99
Author: Dirk O. Kaar <19971886+dok-net@users.noreply.github.com>
Date:   Fri Jan 3 02:01:38 2020 +0100

    Fix Visual Micro "Arduino IDE for Visual Studio" support (#16418)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index a9bd714c1e..a026e479a9 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -33,7 +33,7 @@ GCodeQueue queue;
 #include "../sd/cardreader.h"
 #include "../module/planner.h"
 #include "../module/temperature.h"
-#include "../Marlin.h"
+#include "../MarlinCore.h"
 
 #if ENABLED(PRINTER_EVENT_LEDS)
   #include "../feature/leds/printer_event_leds.h"

commit c590e8ac05c3b417aa42ecd1f4967c4f70cfdd71
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 10 18:52:41 2019 -0500

    Improve Power-loss Recovery (#15135)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index e741b01fb4..a9bd714c1e 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -43,6 +43,9 @@ GCodeQueue queue;
   #include "../feature/binary_protocol.h"
 #endif
 
+#if ENABLED(POWER_LOSS_RECOVERY)
+  #include "../feature/power_loss_recovery.h"
+#endif
 
 /**
  * GCode line number handling. Hosts may opt to include line numbers when
@@ -120,6 +123,9 @@ void GCodeQueue::_commit_command(bool say_ok
   #if NUM_SERIAL > 1
     port[index_w] = p;
   #endif
+  #if ENABLED(POWER_LOSS_RECOVERY)
+    recovery.commit_sdpos(index_w);
+  #endif
   if (++index_w >= BUFSIZE) index_w = 0;
   length++;
 }
@@ -557,6 +563,10 @@ void GCodeQueue::get_serial_commands() {
         sd_count = 0; // clear sd line buffer
 
         _commit_command(false);
+
+        #if ENABLED(POWER_LOSS_RECOVERY)
+          recovery.cmd_sdpos = card.getIndex(); // Prime for the next _commit_command
+        #endif
       }
       else if (sd_count >= MAX_CMD_SIZE - 1) {
         /**

commit a2e412c0ce9865c170f72331052bb3b88a28ffce
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 1 20:21:11 2019 -0500

    Rename command buffer var

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 8159fa3285..e741b01fb4 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -64,7 +64,7 @@ uint8_t GCodeQueue::length = 0,  // Count of commands in the queue
         GCodeQueue::index_r = 0, // Ring buffer read position
         GCodeQueue::index_w = 0; // Ring buffer write position
 
-char GCodeQueue::buffer[BUFSIZE][MAX_CMD_SIZE];
+char GCodeQueue::command_buffer[BUFSIZE][MAX_CMD_SIZE];
 
 /*
  * The port that the command was received on
@@ -135,7 +135,7 @@ bool GCodeQueue::_enqueue(const char* cmd, bool say_ok/*=false*/
   #endif
 ) {
   if (*cmd == ';' || length >= BUFSIZE) return false;
-  strcpy(buffer[index_w], cmd);
+  strcpy(command_buffer[index_w], cmd);
   _commit_command(say_ok
     #if NUM_SERIAL > 1
       , pn
@@ -242,7 +242,7 @@ void GCodeQueue::ok_to_send() {
   if (!send_ok[index_r]) return;
   SERIAL_ECHOPGM(MSG_OK);
   #if ENABLED(ADVANCED_OK)
-    char* p = buffer[index_r];
+    char* p = command_buffer[index_r];
     if (*p == 'N') {
       SERIAL_ECHO(' ');
       SERIAL_ECHO(*p++);
@@ -553,7 +553,7 @@ void GCodeQueue::get_serial_commands() {
         // Skip empty lines and comments
         if (!sd_count) { thermalManager.manage_heater(); continue; }
 
-        buffer[index_w][sd_count] = '\0'; // terminate string
+        command_buffer[index_w][sd_count] = '\0'; // terminate string
         sd_count = 0; // clear sd line buffer
 
         _commit_command(false);
@@ -574,7 +574,7 @@ void GCodeQueue::get_serial_commands() {
           #if ENABLED(PAREN_COMMENTS)
             && ! sd_comment_paren_mode
           #endif
-        ) buffer[index_w][sd_count++] = sd_char;
+        ) command_buffer[index_w][sd_count++] = sd_char;
       }
     }
   }
@@ -610,7 +610,7 @@ void GCodeQueue::advance() {
   #if ENABLED(SDSUPPORT)
 
     if (card.flag.saving) {
-      char* command = buffer[index_r];
+      char* command = command_buffer[index_r];
       if (is_M29(command)) {
         // M29 closes the file
         card.closefile();

commit f499cecf0ddcdac4fad4eced6ca1efe0751a390f
Author: Chris Pepper <p3p@p3psoft.co.uk>
Date:   Tue Aug 6 02:41:53 2019 +0100

    Marlin Binary Protocol Mark II (#14817)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 08cc26eb94..8159fa3285 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -39,6 +39,11 @@ GCodeQueue queue;
   #include "../feature/leds/printer_event_leds.h"
 #endif
 
+#if ENABLED(BINARY_FILE_TRANSFER)
+  #include "../feature/binary_protocol.h"
+#endif
+
+
 /**
  * GCode line number handling. Hosts may opt to include line numbers when
  * sending commands to Marlin, and lines will be checked for sequentiality.
@@ -285,256 +290,6 @@ inline int read_serial(const uint8_t index) {
   }
 }
 
-#if ENABLED(BINARY_FILE_TRANSFER)
-
-  inline bool serial_data_available(const uint8_t index) {
-    switch (index) {
-      case 0: return MYSERIAL0.available();
-      #if NUM_SERIAL > 1
-        case 1: return MYSERIAL1.available();
-      #endif
-      default: return false;
-    }
-  }
-
-  class BinaryStream {
-  public:
-    enum class StreamState : uint8_t {
-      STREAM_RESET,
-      PACKET_RESET,
-      STREAM_HEADER,
-      PACKET_HEADER,
-      PACKET_DATA,
-      PACKET_VALIDATE,
-      PACKET_RESEND,
-      PACKET_FLUSHRX,
-      PACKET_TIMEOUT,
-      STREAM_COMPLETE,
-      STREAM_FAILED,
-    };
-
-    #pragma pack(push, 1)
-
-      struct StreamHeader {
-        uint16_t token;
-        uint32_t filesize;
-      };
-      union {
-        uint8_t stream_header_bytes[sizeof(StreamHeader)];
-        StreamHeader stream_header;
-      };
-
-      struct Packet {
-        struct Header {
-          uint32_t id;
-          uint16_t size, checksum;
-        };
-        union {
-          uint8_t header_bytes[sizeof(Header)];
-          Header header;
-        };
-        uint32_t bytes_received;
-        uint16_t checksum;
-        millis_t timeout;
-      } packet{};
-
-    #pragma pack(pop)
-
-    void packet_reset() {
-      packet.header.id = 0;
-      packet.header.size = 0;
-      packet.header.checksum = 0;
-      packet.bytes_received = 0;
-      packet.checksum = 0x53A2;
-      packet.timeout = millis() + STREAM_MAX_WAIT;
-    }
-
-    void stream_reset() {
-      packets_received = 0;
-      bytes_received = 0;
-      packet_retries = 0;
-      buffer_next_index = 0;
-      stream_header.token = 0;
-      stream_header.filesize = 0;
-    }
-
-    uint32_t checksum(uint32_t seed, uint8_t value) {
-      return ((seed ^ value) ^ (seed << 8)) & 0xFFFF;
-    }
-
-    // read the next byte from the data stream keeping track of
-    // whether the stream times out from data starvation
-    // takes the data variable by reference in order to return status
-    bool stream_read(uint8_t& data) {
-      if (ELAPSED(millis(), packet.timeout)) {
-        stream_state = StreamState::PACKET_TIMEOUT;
-        return false;
-      }
-      if (!serial_data_available(card.transfer_port_index)) return false;
-      data = read_serial(card.transfer_port_index);
-      packet.timeout = millis() + STREAM_MAX_WAIT;
-      return true;
-    }
-
-    template<const size_t buffer_size>
-    void receive(char (&buffer)[buffer_size]) {
-      uint8_t data = 0;
-      millis_t transfer_timeout = millis() + RX_TIMESLICE;
-
-      #if ENABLED(SDSUPPORT)
-        PORT_REDIRECT(card.transfer_port_index);
-      #endif
-
-      while (PENDING(millis(), transfer_timeout)) {
-        switch (stream_state) {
-          case StreamState::STREAM_RESET:
-            stream_reset();
-          case StreamState::PACKET_RESET:
-            packet_reset();
-            stream_state = StreamState::PACKET_HEADER;
-            break;
-          case StreamState::STREAM_HEADER: // The filename could also be in this packet, rather than handling it in the gcode
-            for (size_t i = 0; i < sizeof(stream_header); ++i)
-              stream_header_bytes[i] = buffer[i];
-
-            if (stream_header.token == 0x1234) {
-              stream_state = StreamState::PACKET_RESET;
-              bytes_received = 0;
-              time_stream_start = millis();
-              // confirm active stream and the maximum block size supported
-              SERIAL_ECHO_START();
-              SERIAL_ECHOLNPAIR("Datastream initialized (", stream_header.filesize, " bytes expected)");
-              SERIAL_ECHOLNPAIR("so", buffer_size);
-            }
-            else {
-              SERIAL_ECHO_MSG("Datastream init error (invalid token)");
-              stream_state = StreamState::STREAM_FAILED;
-            }
-            buffer_next_index = 0;
-            break;
-          case StreamState::PACKET_HEADER:
-            if (!stream_read(data)) break;
-
-            packet.header_bytes[packet.bytes_received++] = data;
-            if (packet.bytes_received == sizeof(Packet::Header)) {
-              if (packet.header.id == packets_received) {
-                buffer_next_index = 0;
-                packet.bytes_received = 0;
-                stream_state = StreamState::PACKET_DATA;
-              }
-              else {
-                SERIAL_ECHO_MSG("Datastream packet out of order");
-                stream_state = StreamState::PACKET_FLUSHRX;
-              }
-            }
-            break;
-          case StreamState::PACKET_DATA:
-            if (!stream_read(data)) break;
-
-            if (buffer_next_index < buffer_size)
-              buffer[buffer_next_index] = data;
-            else {
-              SERIAL_ECHO_MSG("Datastream packet data buffer overrun");
-              stream_state = StreamState::STREAM_FAILED;
-              break;
-            }
-
-            packet.checksum = checksum(packet.checksum, data);
-            packet.bytes_received++;
-            buffer_next_index++;
-
-            if (packet.bytes_received == packet.header.size)
-              stream_state = StreamState::PACKET_VALIDATE;
-
-            break;
-          case StreamState::PACKET_VALIDATE:
-            if (packet.header.checksum == packet.checksum) {
-              packet_retries = 0;
-              packets_received++;
-              bytes_received += packet.header.size;
-
-              if (packet.header.id == 0)                   // id 0 is always the stream descriptor
-                stream_state = StreamState::STREAM_HEADER; // defer packet confirmation to STREAM_HEADER state
-              else {
-                if (bytes_received < stream_header.filesize) {
-                  stream_state = StreamState::PACKET_RESET;  // reset and receive next packet
-                  SERIAL_ECHOLNPAIR("ok", packet.header.id); // transmit confirm packet received and valid token
-                }
-                else
-                  stream_state = StreamState::STREAM_COMPLETE; // no more data required
-
-                if (card.write(buffer, buffer_next_index) < 0) {
-                  stream_state = StreamState::STREAM_FAILED;
-                  SERIAL_ECHO_MSG("SDCard IO Error");
-                  break;
-                };
-              }
-            }
-            else {
-              SERIAL_ECHO_START();
-              SERIAL_ECHOLNPAIR("Block(", packet.header.id, ") Corrupt");
-              stream_state = StreamState::PACKET_FLUSHRX;
-            }
-            break;
-          case StreamState::PACKET_RESEND:
-            if (packet_retries < MAX_RETRIES) {
-              packet_retries++;
-              stream_state = StreamState::PACKET_RESET;
-              SERIAL_ECHO_START();
-              SERIAL_ECHOLNPAIR("Resend request ", int(packet_retries));
-              SERIAL_ECHOLNPAIR("rs", packet.header.id); // transmit resend packet token
-            }
-            else {
-              stream_state = StreamState::STREAM_FAILED;
-            }
-            break;
-          case StreamState::PACKET_FLUSHRX:
-            if (ELAPSED(millis(), packet.timeout)) {
-              stream_state = StreamState::PACKET_RESEND;
-              break;
-            }
-            if (!serial_data_available(card.transfer_port_index)) break;
-            read_serial(card.transfer_port_index); // throw away data
-            packet.timeout = millis() + STREAM_MAX_WAIT;
-            break;
-          case StreamState::PACKET_TIMEOUT:
-            SERIAL_ECHO_START();
-            SERIAL_ECHOLNPGM("Datastream timeout");
-            stream_state = StreamState::PACKET_RESEND;
-            break;
-          case StreamState::STREAM_COMPLETE:
-            stream_state = StreamState::STREAM_RESET;
-            card.flag.binary_mode = false;
-            SERIAL_ECHO_START();
-            SERIAL_ECHO(card.filename);
-            SERIAL_ECHOLNPAIR(" transfer completed @ ", ((bytes_received / (millis() - time_stream_start) * 1000) / 1024), "KiB/s");
-            SERIAL_ECHOLNPGM("sc"); // transmit stream complete token
-            card.closefile();
-            return;
-          case StreamState::STREAM_FAILED:
-            stream_state = StreamState::STREAM_RESET;
-            card.flag.binary_mode = false;
-            card.closefile();
-            card.removeFile(card.filename);
-            SERIAL_ECHO_START();
-            SERIAL_ECHOLNPGM("File transfer failed");
-            SERIAL_ECHOLNPGM("sf"); // transmit stream failed token
-            return;
-        }
-      }
-    }
-
-    static const uint16_t STREAM_MAX_WAIT = 500, RX_TIMESLICE = 20, MAX_RETRIES = 3;
-    uint8_t  packet_retries;
-    uint16_t buffer_next_index;
-    uint32_t packets_received,  bytes_received;
-    millis_t time_stream_start;
-    StreamState stream_state = StreamState::STREAM_RESET;
-
-  } binaryStream{};
-
-#endif // BINARY_FILE_TRANSFER
-
 void GCodeQueue::gcode_line_error(PGM_P const err, const int8_t port) {
   PORT_REDIRECT(port);
   SERIAL_ERROR_START();
@@ -564,13 +319,13 @@ void GCodeQueue::get_serial_commands() {
             ;
 
   #if ENABLED(BINARY_FILE_TRANSFER)
-    if (card.flag.saving && card.flag.binary_mode) {
+    if (card.flag.binary_mode) {
       /**
        * For binary stream file transfer, use serial_line_buffer as the working
        * receive buffer (which limits the packet size to MAX_CMD_SIZE).
        * The receive buffer also limits the packet size for reliable transmission.
        */
-      binaryStream.receive(serial_line_buffer[card.transfer_port_index]);
+      binaryStream[card.transfer_port_index].receive(serial_line_buffer[card.transfer_port_index]);
       return;
     }
   #endif

commit cbe4bf2ba8109ede73605a9287d6afc07b655ea6
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Sun Jul 14 09:12:48 2019 -0600

    Fix process_injected_command undefined behavior (#14602)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index d519378a29..08cc26eb94 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -170,16 +170,19 @@ bool GCodeQueue::process_injected_command() {
   char c;
   size_t i = 0;
   while ((c = pgm_read_byte(&injected_commands_P[i])) && c != '\n') i++;
-  if (i) {
-    char cmd[i + 1];
-    memcpy_P(cmd, injected_commands_P, i);
-    cmd[i] = '\0';
 
+  // Extract current command and move pointer to next command
+  char cmd[i + 1];
+  memcpy_P(cmd, injected_commands_P, i);
+  cmd[i] = '\0';
+  injected_commands_P = c ? injected_commands_P + i + 1 : nullptr;
+
+  // Execute command if non-blank
+  if (i) {
     parser.parse(cmd);
     PORT_REDIRECT(SERIAL_PORT);
     gcode.process_parsed_command();
   }
-  injected_commands_P = c ? injected_commands_P + i + 1 : nullptr;
   return true;
 }
 

commit e6cf7860e8fafb5c2bdb95ff36ad7d598fa5636a
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Fri Jun 28 23:23:57 2019 -0600

    Improve ExtUI, fix compiler errors, warnings (#14441)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 9e2d5984a4..d519378a29 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -89,6 +89,13 @@ GCodeQueue::GCodeQueue() {
   for (uint8_t i = 0; i < COUNT(send_ok); i++) send_ok[i] = true;
 }
 
+/**
+ * Check whether there are any commands yet to be executed
+ */
+bool GCodeQueue::has_commands_queued() {
+  return queue.length || injected_commands_P;
+}
+
 /**
  * Clear the Marlin command queue
  */
@@ -154,6 +161,8 @@ bool GCodeQueue::enqueue_one(const char* cmd) {
 
 /**
  * Process the next "immediate" command.
+ * Return 'true' if any commands were processed,
+ * or remain to process.
  */
 bool GCodeQueue::process_injected_command() {
   if (injected_commands_P == nullptr) return false;
@@ -161,19 +170,16 @@ bool GCodeQueue::process_injected_command() {
   char c;
   size_t i = 0;
   while ((c = pgm_read_byte(&injected_commands_P[i])) && c != '\n') i++;
-  if (!i) return false;
-
-  char cmd[i + 1];
-  memcpy_P(cmd, injected_commands_P, i);
-  cmd[i] = '\0';
+  if (i) {
+    char cmd[i + 1];
+    memcpy_P(cmd, injected_commands_P, i);
+    cmd[i] = '\0';
 
+    parser.parse(cmd);
+    PORT_REDIRECT(SERIAL_PORT);
+    gcode.process_parsed_command();
+  }
   injected_commands_P = c ? injected_commands_P + i + 1 : nullptr;
-
-  parser.parse(cmd);
-  PORT_REDIRECT(SERIAL_PORT);
-  gcode.process_parsed_command();
-  PORT_RESTORE();
-
   return true;
 }
 
@@ -183,17 +189,13 @@ bool GCodeQueue::process_injected_command() {
  * Aborts the current queue, if any.
  * Note: process_injected_command() will be called to drain any commands afterwards
  */
-void GCodeQueue::inject_P(PGM_P const pgcode) {
-  injected_commands_P = pgcode;
-}
+void GCodeQueue::inject_P(PGM_P const pgcode) { injected_commands_P = pgcode; }
 
 /**
  * Enqueue and return only when commands are actually enqueued.
  * Never call this from a G-code handler!
  */
-void GCodeQueue::enqueue_one_now(const char* cmd) {
-  while (!enqueue_one(cmd)) idle();
-}
+void GCodeQueue::enqueue_one_now(const char* cmd) { while (!enqueue_one(cmd)) idle(); }
 
 /**
  * Enqueue from program memory and return only when commands are actually enqueued

commit 93cd66ac1146603e8a9911fceb3c63f4351f4d8e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 23:57:50 2019 -0500

    Tweaky change from (C) to (c)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index dbf966fb0b..9e2d5984a4 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -1,9 +1,9 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by

commit cf762d2c7335d539aa09595ac57634ec4beee400
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Jun 23 22:21:33 2019 -0500

    Fix enqueueing bug

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 7dbe3259e1..dbf966fb0b 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -204,7 +204,7 @@ void GCodeQueue::enqueue_now_P(PGM_P const pgcode) {
   PGM_P p = pgcode;
   for (;;) {
     char c;
-    while ((c = p[i]) && c != '\n') i++;
+    while ((c = pgm_read_byte(&p[i])) && c != '\n') i++;
     char cmd[i + 1];
     memcpy_P(cmd, p, i);
     cmd[i] = '\0';

commit 0f6f5132c130a2596c9ea50a7f8a81e0f1e3f9d4
Author: LinFor <linfor@gmail.com>
Date:   Sat Jun 22 03:04:30 2019 +0300

    Fix variable conflict in ok_to_send (#14351)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index d09f678c3c..7dbe3259e1 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -225,9 +225,9 @@ void GCodeQueue::enqueue_now_P(PGM_P const pgcode) {
  */
 void GCodeQueue::ok_to_send() {
   #if NUM_SERIAL > 1
-    const int16_t p = port[index_r];
-    if (p < 0) return;
-    PORT_REDIRECT(p);
+    const int16_t pn = port[index_r];
+    if (pn < 0) return;
+    PORT_REDIRECT(pn);
   #endif
   if (!send_ok[index_r]) return;
   SERIAL_ECHOPGM(MSG_OK);

commit 4c872a01f284cbf181f52c84e2ba6b4618e62556
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jun 19 00:00:19 2019 -0500

    G-code queue singleton, front injection (#14236)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index afc76bbe1f..d09f678c3c 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -25,6 +25,8 @@
  */
 
 #include "queue.h"
+GCodeQueue queue;
+
 #include "gcode.h"
 
 #include "../lcd/ultralcd.h"
@@ -42,7 +44,7 @@
  * sending commands to Marlin, and lines will be checked for sequentiality.
  * M110 N<int> sets the current line number.
  */
-long gcode_N, gcode_LastN, Stopped_gcode_LastN = 0;
+long gcode_N, GCodeQueue::last_N, GCodeQueue::stopped_N = 0;
 
 /**
  * GCode Command Queue
@@ -53,17 +55,17 @@ long gcode_N, gcode_LastN, Stopped_gcode_LastN = 0;
  * the main loop. The gcode.process_next_command method parses the next
  * command and hands off execution to individual handler functions.
  */
-uint8_t commands_in_queue = 0, // Count of commands in the queue
-        cmd_queue_index_r = 0, // Ring buffer read position
-        cmd_queue_index_w = 0; // Ring buffer write position
+uint8_t GCodeQueue::length = 0,  // Count of commands in the queue
+        GCodeQueue::index_r = 0, // Ring buffer read position
+        GCodeQueue::index_w = 0; // Ring buffer write position
 
-char command_queue[BUFSIZE][MAX_CMD_SIZE];
+char GCodeQueue::buffer[BUFSIZE][MAX_CMD_SIZE];
 
 /*
  * The port that the command was received on
  */
 #if NUM_SERIAL > 1
-  int16_t command_queue_port[BUFSIZE];
+  int16_t GCodeQueue::port[BUFSIZE];
 #endif
 
 /**
@@ -82,7 +84,7 @@ bool send_ok[BUFSIZE];
  */
 static PGM_P injected_commands_P = nullptr;
 
-void queue_setup() {
+GCodeQueue::GCodeQueue() {
   // Send "ok" after commands by default
   for (uint8_t i = 0; i < COUNT(send_ok); i++) send_ok[i] = true;
 }
@@ -90,24 +92,24 @@ void queue_setup() {
 /**
  * Clear the Marlin command queue
  */
-void clear_command_queue() {
-  cmd_queue_index_r = cmd_queue_index_w = commands_in_queue = 0;
+void GCodeQueue::clear() {
+  index_r = index_w = length = 0;
 }
 
 /**
  * Once a new command is in the ring buffer, call this to commit it
  */
-inline void _commit_command(bool say_ok
+void GCodeQueue::_commit_command(bool say_ok
   #if NUM_SERIAL > 1
-    , int16_t port = -1
+    , int16_t p/*=-1*/
   #endif
 ) {
-  send_ok[cmd_queue_index_w] = say_ok;
+  send_ok[index_w] = say_ok;
   #if NUM_SERIAL > 1
-    command_queue_port[cmd_queue_index_w] = port;
+    port[index_w] = p;
   #endif
-  if (++cmd_queue_index_w >= BUFSIZE) cmd_queue_index_w = 0;
-  commands_in_queue++;
+  if (++index_w >= BUFSIZE) index_w = 0;
+  length++;
 }
 
 /**
@@ -115,16 +117,16 @@ inline void _commit_command(bool say_ok
  * Return true if the command was successfully added.
  * Return false for a full buffer, or if the 'command' is a comment.
  */
-inline bool _enqueuecommand(const char* cmd, bool say_ok=false
+bool GCodeQueue::_enqueue(const char* cmd, bool say_ok/*=false*/
   #if NUM_SERIAL > 1
-    , int16_t port = -1
+    , int16_t pn/*=-1*/
   #endif
 ) {
-  if (*cmd == ';' || commands_in_queue >= BUFSIZE) return false;
-  strcpy(command_queue[cmd_queue_index_w], cmd);
+  if (*cmd == ';' || length >= BUFSIZE) return false;
+  strcpy(buffer[index_w], cmd);
   _commit_command(say_ok
     #if NUM_SERIAL > 1
-      , port
+      , pn
     #endif
   );
   return true;
@@ -134,15 +136,15 @@ inline bool _enqueuecommand(const char* cmd, bool say_ok=false
  * Enqueue with Serial Echo
  * Return true if the command was consumed
  */
-bool enqueue_and_echo_command(const char* cmd) {
+bool GCodeQueue::enqueue_one(const char* cmd) {
 
-  //SERIAL_ECHOPGM("enqueue_and_echo_command(\"");
+  //SERIAL_ECHOPGM("enqueue_one(\"");
   //SERIAL_ECHO(cmd);
   //SERIAL_ECHOPGM("\") \n");
 
   if (*cmd == 0 || *cmd == '\n' || *cmd == '\r') return true;
 
-  if (_enqueuecommand(cmd)) {
+  if (_enqueue(cmd)) {
     SERIAL_ECHO_START();
     SERIAL_ECHOLNPAIR(MSG_ENQUEUEING, cmd, "\"");
     return true;
@@ -150,104 +152,67 @@ bool enqueue_and_echo_command(const char* cmd) {
   return false;
 }
 
-#if HAS_QUEUE_FRONT
+/**
+ * Process the next "immediate" command.
+ */
+bool GCodeQueue::process_injected_command() {
+  if (injected_commands_P == nullptr) return false;
 
-  bool early_cmd; // = false
+  char c;
+  size_t i = 0;
+  while ((c = pgm_read_byte(&injected_commands_P[i])) && c != '\n') i++;
+  if (!i) return false;
 
-  /**
-   * Insert a high Priority command from RAM into the main command buffer.
-   * Return true if the command was consumed
-   * Return false for a full buffer, or if the 'command' is a comment.
-   */
-  inline bool _enqueuecommand_front(const char* cmd) {
-    if (*cmd == 0 || *cmd == '\n' || *cmd == '\r') return true;
-    if (*cmd == ';' || commands_in_queue >= BUFSIZE) return false;
-    if (cmd_queue_index_r == 0) cmd_queue_index_r = BUFSIZE;
-    --cmd_queue_index_r;
-    strcpy(command_queue[cmd_queue_index_r], cmd);
-    send_ok[cmd_queue_index_r] = false;
-    #if NUM_SERIAL > 1
-      command_queue_port[cmd_queue_index_r] = -1;
-    #endif
-    commands_in_queue++;
-    return true;
-  }
+  char cmd[i + 1];
+  memcpy_P(cmd, injected_commands_P, i);
+  cmd[i] = '\0';
 
-  /**
-   * Insert in the front of queue, one or many commands to run from program memory.
-   * Aborts the current queue, if any.
-   * Note: drain_injected_commands_P() must be called repeatedly to drain the commands afterwards
-   */
-  void enqueue_and_echo_commands_front_P(PGM_P const pgcode) {
-    early_cmd = true;
-    enqueue_and_echo_commands_P(pgcode);
-  }
+  injected_commands_P = c ? injected_commands_P + i + 1 : nullptr;
 
-#endif
+  parser.parse(cmd);
+  PORT_REDIRECT(SERIAL_PORT);
+  gcode.process_parsed_command();
+  PORT_RESTORE();
 
-/**
- * Inject the next "immediate" command, when possible, onto the front of the queue.
- * Return true if any immediate commands remain to inject.
- * Do not inject a comment or use leading space!.
- */
-static bool drain_injected_commands_P() {
-  while (injected_commands_P != nullptr) {
-    size_t i = 0;
-    char c, cmd[60];
-    strncpy_P(cmd, injected_commands_P, sizeof(cmd) - 1);
-    cmd[sizeof(cmd) - 1] = '\0';
-    while ((c = cmd[i]) && c != '\n') i++; // find the end of this gcode command
-    cmd[i] = '\0';
-
-    if (
-      #if HAS_QUEUE_FRONT
-        early_cmd ? _enqueuecommand_front(cmd) :
-      #endif
-      enqueue_and_echo_command(cmd)
-    ) {
-      injected_commands_P = c ? injected_commands_P + i + 1 : nullptr; // next command or done
-      #if HAS_QUEUE_FRONT
-        if (!c) early_cmd = false;
-      #endif
-    }
-    else
-      return true; // buffer is full (or command is comment);
-  }
-  return false;   // return whether any more remain
+  return true;
 }
 
 /**
  * Enqueue one or many commands to run from program memory.
+ * Do not inject a comment or use leading spaces!
  * Aborts the current queue, if any.
- * Note: drain_injected_commands_P() must be called repeatedly to drain the commands afterwards
+ * Note: process_injected_command() will be called to drain any commands afterwards
  */
-void enqueue_and_echo_commands_P(PGM_P const pgcode) {
-  #if HAS_QUEUE_FRONT
-    early_cmd = false;
-  #endif
+void GCodeQueue::inject_P(PGM_P const pgcode) {
   injected_commands_P = pgcode;
-  (void)drain_injected_commands_P(); // first command executed asap (when possible)
 }
 
-#if HAS_QUEUE_NOW
-  /**
-   * Enqueue and return only when commands are actually enqueued.
-   * Never call this from a G-code handler!
-   */
-  void enqueue_and_echo_command_now(const char* cmd) {
-    while (!enqueue_and_echo_command(cmd)) idle();
+/**
+ * Enqueue and return only when commands are actually enqueued.
+ * Never call this from a G-code handler!
+ */
+void GCodeQueue::enqueue_one_now(const char* cmd) {
+  while (!enqueue_one(cmd)) idle();
+}
+
+/**
+ * Enqueue from program memory and return only when commands are actually enqueued
+ * Never call this from a G-code handler!
+ */
+void GCodeQueue::enqueue_now_P(PGM_P const pgcode) {
+  size_t i = 0;
+  PGM_P p = pgcode;
+  for (;;) {
+    char c;
+    while ((c = p[i]) && c != '\n') i++;
+    char cmd[i + 1];
+    memcpy_P(cmd, p, i);
+    cmd[i] = '\0';
+    enqueue_one_now(cmd);
+    if (!c) break;
+    p += i + 1;
   }
-  #if HAS_LCD_QUEUE_NOW
-    /**
-     * Enqueue from program memory and return only when commands are actually enqueued
-     * Never call this from a G-code handler!
-     */
-    void enqueue_and_echo_commands_now_P(PGM_P const pgcode) {
-      enqueue_and_echo_commands_P(pgcode);
-      while (drain_injected_commands_P()) idle();
-    }
-  #endif
-#endif
+}
 
 /**
  * Send an "ok" message to the host, indicating
@@ -258,16 +223,16 @@ void enqueue_and_echo_commands_P(PGM_P const pgcode) {
  *   P<int>  Planner space remaining
  *   B<int>  Block queue space remaining
  */
-void ok_to_send() {
+void GCodeQueue::ok_to_send() {
   #if NUM_SERIAL > 1
-    const int16_t port = command_queue_port[cmd_queue_index_r];
-    if (port < 0) return;
-    PORT_REDIRECT(port);
+    const int16_t p = port[index_r];
+    if (p < 0) return;
+    PORT_REDIRECT(p);
   #endif
-  if (!send_ok[cmd_queue_index_r]) return;
+  if (!send_ok[index_r]) return;
   SERIAL_ECHOPGM(MSG_OK);
   #if ENABLED(ADVANCED_OK)
-    char* p = command_queue[cmd_queue_index_r];
+    char* p = buffer[index_r];
     if (*p == 'N') {
       SERIAL_ECHO(' ');
       SERIAL_ECHO(*p++);
@@ -275,7 +240,7 @@ void ok_to_send() {
         SERIAL_ECHO(*p++);
     }
     SERIAL_ECHOPGM(" P"); SERIAL_ECHO(int(BLOCK_BUFFER_SIZE - planner.movesplanned() - 1));
-    SERIAL_ECHOPGM(" B"); SERIAL_ECHO(BUFSIZE - commands_in_queue);
+    SERIAL_ECHOPGM(" B"); SERIAL_ECHO(BUFSIZE - length);
   #endif
   SERIAL_EOL();
 }
@@ -284,15 +249,15 @@ void ok_to_send() {
  * Send a "Resend: nnn" message to the host to
  * indicate that a command needs to be re-sent.
  */
-void flush_and_request_resend() {
+void GCodeQueue::flush_and_request_resend() {
   #if NUM_SERIAL > 1
-    const int16_t port = command_queue_port[cmd_queue_index_r];
-    if (port < 0) return;
-    PORT_REDIRECT(port);
+    const int16_t p = port[index_r];
+    if (p < 0) return;
+    PORT_REDIRECT(p);
   #endif
   SERIAL_FLUSH();
   SERIAL_ECHOPGM(MSG_RESEND);
-  SERIAL_ECHOLN(gcode_LastN + 1);
+  SERIAL_ECHOLN(last_N + 1);
   ok_to_send();
 }
 
@@ -315,16 +280,6 @@ inline int read_serial(const uint8_t index) {
   }
 }
 
-void gcode_line_error(PGM_P const err, const int8_t port) {
-  PORT_REDIRECT(port);
-  SERIAL_ERROR_START();
-  serialprintPGM(err);
-  SERIAL_ECHOLN(gcode_LastN);
-  while (read_serial(port) != -1);           // clear out the RX buffer
-  flush_and_request_resend();
-  serial_count[port] = 0;
-}
-
 #if ENABLED(BINARY_FILE_TRANSFER)
 
   inline bool serial_data_available(const uint8_t index) {
@@ -575,6 +530,16 @@ void gcode_line_error(PGM_P const err, const int8_t port) {
 
 #endif // BINARY_FILE_TRANSFER
 
+void GCodeQueue::gcode_line_error(PGM_P const err, const int8_t port) {
+  PORT_REDIRECT(port);
+  SERIAL_ERROR_START();
+  serialprintPGM(err);
+  SERIAL_ECHOLN(last_N);
+  while (read_serial(port) != -1);           // clear out the RX buffer
+  flush_and_request_resend();
+  serial_count[port] = 0;
+}
+
 FORCE_INLINE bool is_M29(const char * const cmd) {  // matches "M29" & "M29 ", but not "M290", etc
   const char * const m29 = strstr_P(cmd, PSTR("M29"));
   return m29 && !NUMERIC(m29[3]);
@@ -585,7 +550,7 @@ FORCE_INLINE bool is_M29(const char * const cmd) {  // matches "M29" & "M29 ", b
  * Exit when the buffer is full or when no more characters are
  * left on the serial port.
  */
-inline void get_serial_commands() {
+void GCodeQueue::get_serial_commands() {
   static char serial_line_buffer[NUM_SERIAL][MAX_CMD_SIZE];
   static bool serial_comment_mode[NUM_SERIAL] = { false }
               #if ENABLED(PAREN_COMMENTS)
@@ -610,7 +575,7 @@ inline void get_serial_commands() {
   #if NO_TIMEOUTS > 0
     static millis_t last_command_time = 0;
     const millis_t ms = millis();
-    if (commands_in_queue == 0 && !serial_data_available() && ELAPSED(ms, last_command_time + NO_TIMEOUTS)) {
+    if (length == 0 && !serial_data_available() && ELAPSED(ms, last_command_time + NO_TIMEOUTS)) {
       SERIAL_ECHOLNPGM(MSG_WAIT);
       last_command_time = ms;
     }
@@ -619,7 +584,7 @@ inline void get_serial_commands() {
   /**
    * Loop while serial characters are incoming and the queue is not full
    */
-  while (commands_in_queue < BUFSIZE && serial_data_available()) {
+  while (length < BUFSIZE && serial_data_available()) {
     for (uint8_t i = 0; i < NUM_SERIAL; ++i) {
       int c;
       if ((c = read_serial(i)) < 0) continue;
@@ -659,7 +624,7 @@ inline void get_serial_commands() {
 
           gcode_N = strtol(npos + 1, nullptr, 10);
 
-          if (gcode_N != gcode_LastN + 1 && !M110)
+          if (gcode_N != last_N + 1 && !M110)
             return gcode_line_error(PSTR(MSG_ERR_LINE_NO), i);
 
           char *apos = strrchr(command, '*');
@@ -672,7 +637,7 @@ inline void get_serial_commands() {
           else
             return gcode_line_error(PSTR(MSG_ERR_NO_CHECKSUM), i);
 
-          gcode_LastN = gcode_N;
+          last_N = gcode_N;
         }
         #if ENABLED(SDSUPPORT)
           // Pronterface "M29" and "M29 " has no line number
@@ -718,7 +683,7 @@ inline void get_serial_commands() {
         #endif
 
         // Add the command to the queue
-        _enqueuecommand(serial_line_buffer[i], true
+        _enqueue(serial_line_buffer[i], true
           #if NUM_SERIAL > 1
             , i
           #endif
@@ -760,7 +725,7 @@ inline void get_serial_commands() {
    * or until the end of the file is reached. The special character '#'
    * can also interrupt buffering.
    */
-  inline void get_sdcard_commands() {
+  inline void GCodeQueue::get_sdcard_commands() {
     static bool stop_buffering = false,
                 sd_comment_mode = false
                 #if ENABLED(PAREN_COMMENTS)
@@ -777,11 +742,11 @@ inline void get_serial_commands() {
      * due to checksums, however, no checksums are used in SD printing.
      */
 
-    if (commands_in_queue == 0) stop_buffering = false;
+    if (length == 0) stop_buffering = false;
 
     uint16_t sd_count = 0;
     bool card_eof = card.eof();
-    while (commands_in_queue < BUFSIZE && !card_eof && !stop_buffering) {
+    while (length < BUFSIZE && !card_eof && !stop_buffering) {
       const int16_t n = card.get();
       char sd_char = (char)n;
       card_eof = card.eof();
@@ -804,7 +769,7 @@ inline void get_serial_commands() {
             #if ENABLED(PRINTER_EVENT_LEDS)
               printerEventLEDs.onPrintCompleted();
               #if HAS_RESUME_CONTINUE
-                enqueue_and_echo_commands_P(PSTR("M0 S"
+                inject_P(PSTR("M0 S"
                   #if HAS_LCD_MENU
                     "1800"
                   #else
@@ -828,7 +793,7 @@ inline void get_serial_commands() {
         // Skip empty lines and comments
         if (!sd_count) { thermalManager.manage_heater(); continue; }
 
-        command_queue[cmd_queue_index_w][sd_count] = '\0'; // terminate string
+        buffer[index_w][sd_count] = '\0'; // terminate string
         sd_count = 0; // clear sd line buffer
 
         _commit_command(false);
@@ -849,7 +814,7 @@ inline void get_serial_commands() {
           #if ENABLED(PAREN_COMMENTS)
             && ! sd_comment_paren_mode
           #endif
-        ) command_queue[cmd_queue_index_w][sd_count++] = sd_char;
+        ) buffer[index_w][sd_count++] = sd_char;
       }
     }
   }
@@ -862,10 +827,7 @@ inline void get_serial_commands() {
  *  - The active serial input (usually USB)
  *  - The SD card file being actively printed
  */
-void get_available_commands() {
-
-  // if any immediate commands remain, don't get other commands yet
-  if (drain_injected_commands_P()) return;
+void GCodeQueue::get_available_commands() {
 
   get_serial_commands();
 
@@ -877,14 +839,18 @@ void get_available_commands() {
 /**
  * Get the next command in the queue, optionally log it to SD, then dispatch it
  */
-void advance_command_queue() {
+void GCodeQueue::advance() {
+
+  // Process immediate commands
+  if (process_injected_command()) return;
 
-  if (!commands_in_queue) return;
+  // Return if the G-code buffer is empty
+  if (!length) return;
 
   #if ENABLED(SDSUPPORT)
 
     if (card.flag.saving) {
-      char* command = command_queue[cmd_queue_index_r];
+      char* command = buffer[index_r];
       if (is_M29(command)) {
         // M29 closes the file
         card.closefile();
@@ -921,9 +887,9 @@ void advance_command_queue() {
   #endif // SDSUPPORT
 
   // The queue may be reset by a command handler or by code invoked by idle() within a handler
-  if (commands_in_queue) {
-    --commands_in_queue;
-    if (++cmd_queue_index_r >= BUFSIZE) cmd_queue_index_r = 0;
+  if (length) {
+    --length;
+    if (++index_r >= BUFSIZE) index_r = 0;
   }
 
 }

commit 5ca8d51e123463004626e853a930e2f88febd66d
Author: Robby Candra <robbycandra.mail@gmail.com>
Date:   Sat Jun 8 17:23:53 2019 +0700

    Ability to insert G-code in front of queue (#14229)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index d8bd91c5f3..afc76bbe1f 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -132,6 +132,7 @@ inline bool _enqueuecommand(const char* cmd, bool say_ok=false
 
 /**
  * Enqueue with Serial Echo
+ * Return true if the command was consumed
  */
 bool enqueue_and_echo_command(const char* cmd) {
 
@@ -139,10 +140,7 @@ bool enqueue_and_echo_command(const char* cmd) {
   //SERIAL_ECHO(cmd);
   //SERIAL_ECHOPGM("\") \n");
 
-  if (*cmd == 0 || *cmd == '\n' || *cmd == '\r') {
-    //SERIAL_ECHOLNPGM("Null command found...   Did not queue!");
-    return true;
-  }
+  if (*cmd == 0 || *cmd == '\n' || *cmd == '\r') return true;
 
   if (_enqueuecommand(cmd)) {
     SERIAL_ECHO_START();
@@ -152,30 +150,81 @@ bool enqueue_and_echo_command(const char* cmd) {
   return false;
 }
 
+#if HAS_QUEUE_FRONT
+
+  bool early_cmd; // = false
+
+  /**
+   * Insert a high Priority command from RAM into the main command buffer.
+   * Return true if the command was consumed
+   * Return false for a full buffer, or if the 'command' is a comment.
+   */
+  inline bool _enqueuecommand_front(const char* cmd) {
+    if (*cmd == 0 || *cmd == '\n' || *cmd == '\r') return true;
+    if (*cmd == ';' || commands_in_queue >= BUFSIZE) return false;
+    if (cmd_queue_index_r == 0) cmd_queue_index_r = BUFSIZE;
+    --cmd_queue_index_r;
+    strcpy(command_queue[cmd_queue_index_r], cmd);
+    send_ok[cmd_queue_index_r] = false;
+    #if NUM_SERIAL > 1
+      command_queue_port[cmd_queue_index_r] = -1;
+    #endif
+    commands_in_queue++;
+    return true;
+  }
+
+  /**
+   * Insert in the front of queue, one or many commands to run from program memory.
+   * Aborts the current queue, if any.
+   * Note: drain_injected_commands_P() must be called repeatedly to drain the commands afterwards
+   */
+  void enqueue_and_echo_commands_front_P(PGM_P const pgcode) {
+    early_cmd = true;
+    enqueue_and_echo_commands_P(pgcode);
+  }
+
+#endif
+
 /**
  * Inject the next "immediate" command, when possible, onto the front of the queue.
  * Return true if any immediate commands remain to inject.
+ * Do not inject a comment or use leading space!.
  */
 static bool drain_injected_commands_P() {
-  if (injected_commands_P != nullptr) {
+  while (injected_commands_P != nullptr) {
     size_t i = 0;
     char c, cmd[60];
     strncpy_P(cmd, injected_commands_P, sizeof(cmd) - 1);
     cmd[sizeof(cmd) - 1] = '\0';
     while ((c = cmd[i]) && c != '\n') i++; // find the end of this gcode command
     cmd[i] = '\0';
-    if (enqueue_and_echo_command(cmd))     // success?
+
+    if (
+      #if HAS_QUEUE_FRONT
+        early_cmd ? _enqueuecommand_front(cmd) :
+      #endif
+      enqueue_and_echo_command(cmd)
+    ) {
       injected_commands_P = c ? injected_commands_P + i + 1 : nullptr; // next command or done
+      #if HAS_QUEUE_FRONT
+        if (!c) early_cmd = false;
+      #endif
+    }
+    else
+      return true; // buffer is full (or command is comment);
   }
-  return (injected_commands_P != nullptr);    // return whether any more remain
+  return false;   // return whether any more remain
 }
 
 /**
- * Record one or many commands to run from program memory.
+ * Enqueue one or many commands to run from program memory.
  * Aborts the current queue, if any.
  * Note: drain_injected_commands_P() must be called repeatedly to drain the commands afterwards
  */
 void enqueue_and_echo_commands_P(PGM_P const pgcode) {
+  #if HAS_QUEUE_FRONT
+    early_cmd = false;
+  #endif
   injected_commands_P = pgcode;
   (void)drain_injected_commands_P(); // first command executed asap (when possible)
 }

commit ad4ffa1d2fbd17ac09c816ba2052cdf714261042
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 9 11:45:55 2019 -0500

    Use C++ language supported 'nullptr' (#13944)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 817d6bca18..d8bd91c5f3 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -76,11 +76,11 @@ static int serial_count[NUM_SERIAL] = { 0 };
 bool send_ok[BUFSIZE];
 
 /**
- * Next Injected Command pointer. NULL if no commands are being injected.
+ * Next Injected Command pointer. nullptr if no commands are being injected.
  * Used by Marlin internally to ensure that commands initiated from within
  * are enqueued ahead of any pending serial or sd card commands.
  */
-static PGM_P injected_commands_P = NULL;
+static PGM_P injected_commands_P = nullptr;
 
 void queue_setup() {
   // Send "ok" after commands by default
@@ -157,7 +157,7 @@ bool enqueue_and_echo_command(const char* cmd) {
  * Return true if any immediate commands remain to inject.
  */
 static bool drain_injected_commands_P() {
-  if (injected_commands_P != NULL) {
+  if (injected_commands_P != nullptr) {
     size_t i = 0;
     char c, cmd[60];
     strncpy_P(cmd, injected_commands_P, sizeof(cmd) - 1);
@@ -165,9 +165,9 @@ static bool drain_injected_commands_P() {
     while ((c = cmd[i]) && c != '\n') i++; // find the end of this gcode command
     cmd[i] = '\0';
     if (enqueue_and_echo_command(cmd))     // success?
-      injected_commands_P = c ? injected_commands_P + i + 1 : NULL; // next command or done
+      injected_commands_P = c ? injected_commands_P + i + 1 : nullptr; // next command or done
   }
-  return (injected_commands_P != NULL);    // return whether any more remain
+  return (injected_commands_P != nullptr);    // return whether any more remain
 }
 
 /**
@@ -597,18 +597,18 @@ inline void get_serial_commands() {
         char* command = serial_line_buffer[i];
 
         while (*command == ' ') command++;                // Skip leading spaces
-        char *npos = (*command == 'N') ? command : NULL;  // Require the N parameter to start the line
+        char *npos = (*command == 'N') ? command : nullptr;  // Require the N parameter to start the line
 
         if (npos) {
 
-          bool M110 = strstr_P(command, PSTR("M110")) != NULL;
+          bool M110 = strstr_P(command, PSTR("M110")) != nullptr;
 
           if (M110) {
             char* n2pos = strchr(command + 4, 'N');
             if (n2pos) npos = n2pos;
           }
 
-          gcode_N = strtol(npos + 1, NULL, 10);
+          gcode_N = strtol(npos + 1, nullptr, 10);
 
           if (gcode_N != gcode_LastN + 1 && !M110)
             return gcode_line_error(PSTR(MSG_ERR_LINE_NO), i);
@@ -617,7 +617,7 @@ inline void get_serial_commands() {
           if (apos) {
             uint8_t checksum = 0, count = uint8_t(apos - command);
             while (count) checksum ^= command[--count];
-            if (strtol(apos + 1, NULL, 10) != checksum)
+            if (strtol(apos + 1, nullptr, 10) != checksum)
               return gcode_line_error(PSTR(MSG_ERR_CHECKSUM_MISMATCH), i);
           }
           else
@@ -635,7 +635,7 @@ inline void get_serial_commands() {
         if (IsStopped()) {
           char* gpos = strchr(command, 'G');
           if (gpos) {
-            switch (strtol(gpos + 1, NULL, 10)) {
+            switch (strtol(gpos + 1, nullptr, 10)) {
               case 0:
               case 1:
               #if ENABLED(ARC_SUPPORT)

commit 92ed9a2bb6d90a969f2ceaf0a73ebe3c0cdc4c16
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 15 23:46:36 2019 -0500

    Fix is_M29
    
    Followup for #13013

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index f448efb117..817d6bca18 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -526,8 +526,9 @@ void gcode_line_error(PGM_P const err, const int8_t port) {
 
 #endif // BINARY_FILE_TRANSFER
 
-FORCE_INLINE bool is_M29(const char * const cmd) {
-  return cmd[0] == 'M' && cmd[1] == '2' && cmd[2] == '9' && !WITHIN(cmd[3], '0', '9');
+FORCE_INLINE bool is_M29(const char * const cmd) {  // matches "M29" & "M29 ", but not "M290", etc
+  const char * const m29 = strstr_P(cmd, PSTR("M29"));
+  return m29 && !NUMERIC(m29[3]);
 }
 
 /**

commit af92ee9dd6e66e4b0d5a50be85d14bf34964a2e8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Apr 3 18:25:42 2019 -0500

    No PLR include needed in queue.cpp

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 515502bdca..f448efb117 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -37,10 +37,6 @@
   #include "../feature/leds/printer_event_leds.h"
 #endif
 
-#if ENABLED(POWER_LOSS_RECOVERY)
-  #include "../feature/power_loss_recovery.h"
-#endif
-
 /**
  * GCode line number handling. Hosts may opt to include line numbers when
  * sending commands to Marlin, and lines will be checked for sequentiality.

commit cfdb38eda4b4d993bac4a0e8600e776429b42b6e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Mar 5 06:46:19 2019 -0600

    Allow SERIAL_ECHOPAIR to take up to 12 pairs (#13311)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 161c3a4d0b..515502bdca 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -150,9 +150,7 @@ bool enqueue_and_echo_command(const char* cmd) {
 
   if (_enqueuecommand(cmd)) {
     SERIAL_ECHO_START();
-    SERIAL_ECHOPAIR(MSG_ENQUEUEING, cmd);
-    SERIAL_CHAR('"');
-    SERIAL_EOL();
+    SERIAL_ECHOLNPAIR(MSG_ENQUEUEING, cmd, "\"");
     return true;
   }
   return false;
@@ -398,9 +396,10 @@ void gcode_line_error(PGM_P const err, const int8_t port) {
               stream_state = StreamState::PACKET_RESET;
               bytes_received = 0;
               time_stream_start = millis();
-              SERIAL_ECHOPAIR("echo: Datastream initialized (", stream_header.filesize);
-              SERIAL_ECHOLNPGM(" bytes expected)");
-              SERIAL_ECHOLNPAIR("so", buffer_size); // confirm active stream and the maximum block size supported
+              // confirm active stream and the maximum block size supported
+              SERIAL_ECHO_START();
+              SERIAL_ECHOLNPAIR("Datastream initialized (", stream_header.filesize, " bytes expected)");
+              SERIAL_ECHOLNPAIR("so", buffer_size);
             }
             else {
               SERIAL_ECHO_MSG("Datastream init error (invalid token)");
@@ -468,8 +467,7 @@ void gcode_line_error(PGM_P const err, const int8_t port) {
             }
             else {
               SERIAL_ECHO_START();
-              SERIAL_ECHOPAIR("Block(", packet.header.id);
-              SERIAL_ECHOLNPGM(") Corrupt");
+              SERIAL_ECHOLNPAIR("Block(", packet.header.id, ") Corrupt");
               stream_state = StreamState::PACKET_FLUSHRX;
             }
             break;
@@ -504,8 +502,7 @@ void gcode_line_error(PGM_P const err, const int8_t port) {
             card.flag.binary_mode = false;
             SERIAL_ECHO_START();
             SERIAL_ECHO(card.filename);
-            SERIAL_ECHOPAIR(" transfer completed @ ", ((bytes_received / (millis() - time_stream_start) * 1000) / 1024));
-            SERIAL_ECHOLNPGM("KiB/s");
+            SERIAL_ECHOLNPAIR(" transfer completed @ ", ((bytes_received / (millis() - time_stream_start) * 1000) / 1024), "KiB/s");
             SERIAL_ECHOLNPGM("sc"); // transmit stream complete token
             card.closefile();
             return;

commit 2e5a3b01fd7e6a5510f0f0251d0a9cc0f63c79fb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Mar 5 01:47:06 2019 -0600

    Save Power Loss Recovery only on move commands

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index eb7f6a74c4..161c3a4d0b 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -868,12 +868,8 @@ void advance_command_queue() {
           ok_to_send();
       }
     }
-    else {
+    else
       gcode.process_next_command();
-      #if ENABLED(POWER_LOSS_RECOVERY)
-        if (IS_SD_PRINTING()) recovery.save();
-      #endif
-    }
 
   #else
 

commit 7de6476b3d2d2a40b7d0cfc0fdafe077fbebc43f
Author: Chris Pepper <p3p@p3psoft.co.uk>
Date:   Thu Feb 28 02:31:42 2019 +0000

    Fix binary protocol error

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 4e9a47eafe..eb7f6a74c4 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -453,9 +453,8 @@ void gcode_line_error(PGM_P const err, const int8_t port) {
                 stream_state = StreamState::STREAM_HEADER; // defer packet confirmation to STREAM_HEADER state
               else {
                 if (bytes_received < stream_header.filesize) {
-                  stream_state = StreamState::PACKET_RESET; // reset and receive next packet
-                  SERIAL_ECHOLNPGM("ok");                   // transmit confirm packet received and valid token
-                  SERIAL_ECHOLN(packet.header.id);
+                  stream_state = StreamState::PACKET_RESET;  // reset and receive next packet
+                  SERIAL_ECHOLNPAIR("ok", packet.header.id); // transmit confirm packet received and valid token
                 }
                 else
                   stream_state = StreamState::STREAM_COMPLETE; // no more data required

commit 2c10222e87925afa0c4adfbd15321866fbea23fc
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Feb 27 20:14:17 2019 -0600

    card.transfer_port => transfer_port_index

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index d697baae05..4e9a47eafe 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -367,8 +367,8 @@ void gcode_line_error(PGM_P const err, const int8_t port) {
         stream_state = StreamState::PACKET_TIMEOUT;
         return false;
       }
-      if (!serial_data_available(card.transfer_port)) return false;
-      data = read_serial(card.transfer_port);
+      if (!serial_data_available(card.transfer_port_index)) return false;
+      data = read_serial(card.transfer_port_index);
       packet.timeout = millis() + STREAM_MAX_WAIT;
       return true;
     }
@@ -379,7 +379,7 @@ void gcode_line_error(PGM_P const err, const int8_t port) {
       millis_t transfer_timeout = millis() + RX_TIMESLICE;
 
       #if ENABLED(SDSUPPORT)
-        PORT_REDIRECT(card.transfer_port);
+        PORT_REDIRECT(card.transfer_port_index);
       #endif
 
       while (PENDING(millis(), transfer_timeout)) {
@@ -491,8 +491,8 @@ void gcode_line_error(PGM_P const err, const int8_t port) {
               stream_state = StreamState::PACKET_RESEND;
               break;
             }
-            if (!serial_data_available(card.transfer_port)) break;
-            read_serial(card.transfer_port); // throw away data
+            if (!serial_data_available(card.transfer_port_index)) break;
+            read_serial(card.transfer_port_index); // throw away data
             packet.timeout = millis() + STREAM_MAX_WAIT;
             break;
           case StreamState::PACKET_TIMEOUT:
@@ -558,7 +558,7 @@ inline void get_serial_commands() {
        * receive buffer (which limits the packet size to MAX_CMD_SIZE).
        * The receive buffer also limits the packet size for reliable transmission.
        */
-      binaryStream.receive(serial_line_buffer[card.transfer_port]);
+      binaryStream.receive(serial_line_buffer[card.transfer_port_index]);
       return;
     }
   #endif

commit 4ab433d39136ed8c94a188a6cdec70c24432944a
Author: Chris Pepper <p3p@p3psoft.co.uk>
Date:   Thu Feb 28 01:57:48 2019 +0000

    Fix binary protocol with one serial port (#13270)
    
    - The `sdcard.transfer_port` variable is Marlin's internal serial port index, not the physical serial port number.
    - Added packet number to "ok" response so hosts don't need to wait for the ACK.
    - Renamed feature to `BINARY_FILE_TRANSFER`, as the speed up is only consequential to the ability to transfer binaries over serial.

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 0b6296ebea..d697baae05 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -282,7 +282,7 @@ void gcode_line_error(PGM_P const err, const int8_t port) {
   serial_count[port] = 0;
 }
 
-#if ENABLED(FAST_FILE_TRANSFER)
+#if ENABLED(BINARY_FILE_TRANSFER)
 
   inline bool serial_data_available(const uint8_t index) {
     switch (index) {
@@ -398,16 +398,12 @@ void gcode_line_error(PGM_P const err, const int8_t port) {
               stream_state = StreamState::PACKET_RESET;
               bytes_received = 0;
               time_stream_start = millis();
-              SERIAL_ECHO("echo: Datastream initialized (");
-              SERIAL_ECHO(stream_header.filesize);
-              SERIAL_ECHOLN("Bytes expected)");
-              SERIAL_ECHO("so"); // confirm active stream and the maximum block size supported
-              SERIAL_CHAR(static_cast<uint8_t>(buffer_size & 0xFF));
-              SERIAL_CHAR(static_cast<uint8_t>((buffer_size >> 8) & 0xFF));
-              SERIAL_CHAR('\n');
+              SERIAL_ECHOPAIR("echo: Datastream initialized (", stream_header.filesize);
+              SERIAL_ECHOLNPGM(" bytes expected)");
+              SERIAL_ECHOLNPAIR("so", buffer_size); // confirm active stream and the maximum block size supported
             }
             else {
-              SERIAL_ECHOLN("echo: Datastream initialization error (invalid token)");
+              SERIAL_ECHO_MSG("Datastream init error (invalid token)");
               stream_state = StreamState::STREAM_FAILED;
             }
             buffer_next_index = 0;
@@ -423,7 +419,7 @@ void gcode_line_error(PGM_P const err, const int8_t port) {
                 stream_state = StreamState::PACKET_DATA;
               }
               else {
-                SERIAL_ECHO("echo: Datastream packet out of order");
+                SERIAL_ECHO_MSG("Datastream packet out of order");
                 stream_state = StreamState::PACKET_FLUSHRX;
               }
             }
@@ -431,61 +427,60 @@ void gcode_line_error(PGM_P const err, const int8_t port) {
           case StreamState::PACKET_DATA:
             if (!stream_read(data)) break;
 
-            if (buffer_next_index < buffer_size) {
+            if (buffer_next_index < buffer_size)
               buffer[buffer_next_index] = data;
-            }
             else {
-              SERIAL_ECHO("echo: Datastream packet data buffer overrun");
+              SERIAL_ECHO_MSG("Datastream packet data buffer overrun");
               stream_state = StreamState::STREAM_FAILED;
               break;
             }
 
             packet.checksum = checksum(packet.checksum, data);
-            packet.bytes_received ++;
-            buffer_next_index ++;
+            packet.bytes_received++;
+            buffer_next_index++;
 
-            if (packet.bytes_received == packet.header.size) {
+            if (packet.bytes_received == packet.header.size)
               stream_state = StreamState::PACKET_VALIDATE;
-            }
+
             break;
           case StreamState::PACKET_VALIDATE:
             if (packet.header.checksum == packet.checksum) {
               packet_retries = 0;
-              packets_received ++;
+              packets_received++;
               bytes_received += packet.header.size;
 
-              if (packet.header.id == 0) {                 // id 0 is always the stream descriptor
+              if (packet.header.id == 0)                   // id 0 is always the stream descriptor
                 stream_state = StreamState::STREAM_HEADER; // defer packet confirmation to STREAM_HEADER state
-              }
               else {
                 if (bytes_received < stream_header.filesize) {
-                  stream_state = StreamState::PACKET_RESET;    // reset and receive next packet
-                  SERIAL_ECHOLN("ok");   // transmit confirm packet received and valid token
+                  stream_state = StreamState::PACKET_RESET; // reset and receive next packet
+                  SERIAL_ECHOLNPGM("ok");                   // transmit confirm packet received and valid token
+                  SERIAL_ECHOLN(packet.header.id);
                 }
-                else  {
+                else
                   stream_state = StreamState::STREAM_COMPLETE; // no more data required
-                }
+
                 if (card.write(buffer, buffer_next_index) < 0) {
                   stream_state = StreamState::STREAM_FAILED;
-                  SERIAL_ECHO("echo: IO ERROR");
+                  SERIAL_ECHO_MSG("SDCard IO Error");
                   break;
                 };
               }
             }
             else {
-              SERIAL_ECHO("echo: Block(");
-              SERIAL_ECHO(packet.header.id);
-              SERIAL_ECHOLN(") Corrupt");
+              SERIAL_ECHO_START();
+              SERIAL_ECHOPAIR("Block(", packet.header.id);
+              SERIAL_ECHOLNPGM(") Corrupt");
               stream_state = StreamState::PACKET_FLUSHRX;
             }
             break;
           case StreamState::PACKET_RESEND:
             if (packet_retries < MAX_RETRIES) {
-              packet_retries ++;
+              packet_retries++;
               stream_state = StreamState::PACKET_RESET;
-              SERIAL_ECHO("echo: Resend request ");
-              SERIAL_ECHOLN(packet_retries);
-              SERIAL_ECHOLN("rs"); // transmit resend packet token
+              SERIAL_ECHO_START();
+              SERIAL_ECHOLNPAIR("Resend request ", int(packet_retries));
+              SERIAL_ECHOLNPAIR("rs", packet.header.id); // transmit resend packet token
             }
             else {
               stream_state = StreamState::STREAM_FAILED;
@@ -501,27 +496,28 @@ void gcode_line_error(PGM_P const err, const int8_t port) {
             packet.timeout = millis() + STREAM_MAX_WAIT;
             break;
           case StreamState::PACKET_TIMEOUT:
-            SERIAL_ECHOLN("echo: Datastream timeout");
+            SERIAL_ECHO_START();
+            SERIAL_ECHOLNPGM("Datastream timeout");
             stream_state = StreamState::PACKET_RESEND;
             break;
           case StreamState::STREAM_COMPLETE:
             stream_state = StreamState::STREAM_RESET;
             card.flag.binary_mode = false;
-            card.closefile();
-            SERIAL_ECHO("echo: ");
+            SERIAL_ECHO_START();
             SERIAL_ECHO(card.filename);
-            SERIAL_ECHO(" transfer completed @ ");
-            SERIAL_ECHO(((bytes_received / (millis() - time_stream_start) * 1000) / 1024 ));
-            SERIAL_ECHOLN("KiB/s");
-            SERIAL_ECHOLN("sc"); // transmit stream complete token
+            SERIAL_ECHOPAIR(" transfer completed @ ", ((bytes_received / (millis() - time_stream_start) * 1000) / 1024));
+            SERIAL_ECHOLNPGM("KiB/s");
+            SERIAL_ECHOLNPGM("sc"); // transmit stream complete token
+            card.closefile();
             return;
           case StreamState::STREAM_FAILED:
             stream_state = StreamState::STREAM_RESET;
             card.flag.binary_mode = false;
             card.closefile();
             card.removeFile(card.filename);
-            SERIAL_ECHOLN("echo: File transfer failed");
-            SERIAL_ECHOLN("sf"); // transmit stream failed token
+            SERIAL_ECHO_START();
+            SERIAL_ECHOLNPGM("File transfer failed");
+            SERIAL_ECHOLNPGM("sf"); // transmit stream failed token
             return;
         }
       }
@@ -536,7 +532,7 @@ void gcode_line_error(PGM_P const err, const int8_t port) {
 
   } binaryStream{};
 
-#endif // FAST_FILE_TRANSFER
+#endif // BINARY_FILE_TRANSFER
 
 FORCE_INLINE bool is_M29(const char * const cmd) {
   return cmd[0] == 'M' && cmd[1] == '2' && cmd[2] == '9' && !WITHIN(cmd[3], '0', '9');
@@ -555,7 +551,7 @@ inline void get_serial_commands() {
               #endif
             ;
 
-  #if ENABLED(FAST_FILE_TRANSFER)
+  #if ENABLED(BINARY_FILE_TRANSFER)
     if (card.flag.saving && card.flag.binary_mode) {
       /**
        * For binary stream file transfer, use serial_line_buffer as the working

commit e15354e387cc825390fc4eaaf3ae4b784a8fd588
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Feb 23 22:53:01 2019 -0600

    Simplify serial port redirect (#13234)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 2c85d7da03..0b6296ebea 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -219,21 +219,22 @@ void ok_to_send() {
   #if NUM_SERIAL > 1
     const int16_t port = command_queue_port[cmd_queue_index_r];
     if (port < 0) return;
+    PORT_REDIRECT(port);
   #endif
   if (!send_ok[cmd_queue_index_r]) return;
-  SERIAL_ECHOPGM_P(port, MSG_OK);
+  SERIAL_ECHOPGM(MSG_OK);
   #if ENABLED(ADVANCED_OK)
     char* p = command_queue[cmd_queue_index_r];
     if (*p == 'N') {
-      SERIAL_ECHO_P(port, ' ');
-      SERIAL_ECHO_P(port, *p++);
+      SERIAL_ECHO(' ');
+      SERIAL_ECHO(*p++);
       while (NUMERIC_SIGNED(*p))
-        SERIAL_ECHO_P(port, *p++);
+        SERIAL_ECHO(*p++);
     }
-    SERIAL_ECHOPGM_P(port, " P"); SERIAL_ECHO_P(port, int(BLOCK_BUFFER_SIZE - planner.movesplanned() - 1));
-    SERIAL_ECHOPGM_P(port, " B"); SERIAL_ECHO_P(port, BUFSIZE - commands_in_queue);
+    SERIAL_ECHOPGM(" P"); SERIAL_ECHO(int(BLOCK_BUFFER_SIZE - planner.movesplanned() - 1));
+    SERIAL_ECHOPGM(" B"); SERIAL_ECHO(BUFSIZE - commands_in_queue);
   #endif
-  SERIAL_EOL_P(port);
+  SERIAL_EOL();
 }
 
 /**
@@ -244,10 +245,11 @@ void flush_and_request_resend() {
   #if NUM_SERIAL > 1
     const int16_t port = command_queue_port[cmd_queue_index_r];
     if (port < 0) return;
+    PORT_REDIRECT(port);
   #endif
-  SERIAL_FLUSH_P(port);
-  SERIAL_ECHOPGM_P(port, MSG_RESEND);
-  SERIAL_ECHOLN_P(port, gcode_LastN + 1);
+  SERIAL_FLUSH();
+  SERIAL_ECHOPGM(MSG_RESEND);
+  SERIAL_ECHOLN(gcode_LastN + 1);
   ok_to_send();
 }
 
@@ -270,10 +272,11 @@ inline int read_serial(const uint8_t index) {
   }
 }
 
-void gcode_line_error(PGM_P err, uint8_t port) {
-  SERIAL_ERROR_START_P(port);
-  serialprintPGM_P(port, err);
-  SERIAL_ECHOLN_P(port, gcode_LastN);
+void gcode_line_error(PGM_P const err, const int8_t port) {
+  PORT_REDIRECT(port);
+  SERIAL_ERROR_START();
+  serialprintPGM(err);
+  SERIAL_ECHOLN(gcode_LastN);
   while (read_serial(port) != -1);           // clear out the RX buffer
   flush_and_request_resend();
   serial_count[port] = 0;
@@ -281,12 +284,6 @@ void gcode_line_error(PGM_P err, uint8_t port) {
 
 #if ENABLED(FAST_FILE_TRANSFER)
 
-  #if ENABLED(SDSUPPORT)
-    #define CARD_CHAR_P(C)   SERIAL_CHAR_P(card.transfer_port, C)
-    #define CARD_ECHO_P(V)   SERIAL_ECHO_P(card.transfer_port, V)
-    #define CARD_ECHOLN_P(V) SERIAL_ECHOLN_P(card.transfer_port, V)
-  #endif
-
   inline bool serial_data_available(const uint8_t index) {
     switch (index) {
       case 0: return MYSERIAL0.available();
@@ -380,6 +377,11 @@ void gcode_line_error(PGM_P err, uint8_t port) {
     void receive(char (&buffer)[buffer_size]) {
       uint8_t data = 0;
       millis_t transfer_timeout = millis() + RX_TIMESLICE;
+
+      #if ENABLED(SDSUPPORT)
+        PORT_REDIRECT(card.transfer_port);
+      #endif
+
       while (PENDING(millis(), transfer_timeout)) {
         switch (stream_state) {
           case StreamState::STREAM_RESET:
@@ -388,24 +390,24 @@ void gcode_line_error(PGM_P err, uint8_t port) {
             packet_reset();
             stream_state = StreamState::PACKET_HEADER;
             break;
-          case StreamState::STREAM_HEADER: // we could also transfer the filename in this packet, rather than handling it in the gcode
-            for (size_t i = 0; i < sizeof(stream_header); ++i) {
+          case StreamState::STREAM_HEADER: // The filename could also be in this packet, rather than handling it in the gcode
+            for (size_t i = 0; i < sizeof(stream_header); ++i)
               stream_header_bytes[i] = buffer[i];
-            }
+
             if (stream_header.token == 0x1234) {
               stream_state = StreamState::PACKET_RESET;
               bytes_received = 0;
               time_stream_start = millis();
-              CARD_ECHO_P("echo: Datastream initialized (");
-              CARD_ECHO_P(stream_header.filesize);
-              CARD_ECHOLN_P("Bytes expected)");
-              CARD_ECHO_P("so"); // confirm active stream and the maximum block size supported
-              CARD_CHAR_P(static_cast<uint8_t>(buffer_size & 0xFF));
-              CARD_CHAR_P(static_cast<uint8_t>((buffer_size >> 8) & 0xFF));
-              CARD_CHAR_P('\n');
+              SERIAL_ECHO("echo: Datastream initialized (");
+              SERIAL_ECHO(stream_header.filesize);
+              SERIAL_ECHOLN("Bytes expected)");
+              SERIAL_ECHO("so"); // confirm active stream and the maximum block size supported
+              SERIAL_CHAR(static_cast<uint8_t>(buffer_size & 0xFF));
+              SERIAL_CHAR(static_cast<uint8_t>((buffer_size >> 8) & 0xFF));
+              SERIAL_CHAR('\n');
             }
             else {
-              CARD_ECHOLN_P("echo: Datastream initialization error (invalid token)");
+              SERIAL_ECHOLN("echo: Datastream initialization error (invalid token)");
               stream_state = StreamState::STREAM_FAILED;
             }
             buffer_next_index = 0;
@@ -421,7 +423,7 @@ void gcode_line_error(PGM_P err, uint8_t port) {
                 stream_state = StreamState::PACKET_DATA;
               }
               else {
-                CARD_ECHO_P("echo: Datastream packet out of order");
+                SERIAL_ECHO("echo: Datastream packet out of order");
                 stream_state = StreamState::PACKET_FLUSHRX;
               }
             }
@@ -433,7 +435,7 @@ void gcode_line_error(PGM_P err, uint8_t port) {
               buffer[buffer_next_index] = data;
             }
             else {
-              CARD_ECHO_P("echo: Datastream packet data buffer overrun");
+              SERIAL_ECHO("echo: Datastream packet data buffer overrun");
               stream_state = StreamState::STREAM_FAILED;
               break;
             }
@@ -458,22 +460,22 @@ void gcode_line_error(PGM_P err, uint8_t port) {
               else {
                 if (bytes_received < stream_header.filesize) {
                   stream_state = StreamState::PACKET_RESET;    // reset and receive next packet
-                  CARD_ECHOLN_P("ok");   // transmit confirm packet received and valid token
+                  SERIAL_ECHOLN("ok");   // transmit confirm packet received and valid token
                 }
                 else  {
                   stream_state = StreamState::STREAM_COMPLETE; // no more data required
                 }
                 if (card.write(buffer, buffer_next_index) < 0) {
                   stream_state = StreamState::STREAM_FAILED;
-                  CARD_ECHO_P("echo: IO ERROR");
+                  SERIAL_ECHO("echo: IO ERROR");
                   break;
                 };
               }
             }
             else {
-              CARD_ECHO_P("echo: Block(");
-              CARD_ECHO_P(packet.header.id);
-              CARD_ECHOLN_P(") Corrupt");
+              SERIAL_ECHO("echo: Block(");
+              SERIAL_ECHO(packet.header.id);
+              SERIAL_ECHOLN(") Corrupt");
               stream_state = StreamState::PACKET_FLUSHRX;
             }
             break;
@@ -481,9 +483,9 @@ void gcode_line_error(PGM_P err, uint8_t port) {
             if (packet_retries < MAX_RETRIES) {
               packet_retries ++;
               stream_state = StreamState::PACKET_RESET;
-              CARD_ECHO_P("echo: Resend request ");
-              CARD_ECHOLN_P(packet_retries);
-              CARD_ECHOLN_P("rs"); // transmit resend packet token
+              SERIAL_ECHO("echo: Resend request ");
+              SERIAL_ECHOLN(packet_retries);
+              SERIAL_ECHOLN("rs"); // transmit resend packet token
             }
             else {
               stream_state = StreamState::STREAM_FAILED;
@@ -499,27 +501,27 @@ void gcode_line_error(PGM_P err, uint8_t port) {
             packet.timeout = millis() + STREAM_MAX_WAIT;
             break;
           case StreamState::PACKET_TIMEOUT:
-            CARD_ECHOLN_P("echo: Datastream timeout");
+            SERIAL_ECHOLN("echo: Datastream timeout");
             stream_state = StreamState::PACKET_RESEND;
             break;
           case StreamState::STREAM_COMPLETE:
             stream_state = StreamState::STREAM_RESET;
             card.flag.binary_mode = false;
             card.closefile();
-            CARD_ECHO_P("echo: ");
-            CARD_ECHO_P(card.filename);
-            CARD_ECHO_P(" transfer completed @ ");
-            CARD_ECHO_P(((bytes_received / (millis() - time_stream_start) * 1000) / 1024 ));
-            CARD_ECHOLN_P("KiB/s");
-            CARD_ECHOLN_P("sc"); // transmit stream complete token
+            SERIAL_ECHO("echo: ");
+            SERIAL_ECHO(card.filename);
+            SERIAL_ECHO(" transfer completed @ ");
+            SERIAL_ECHO(((bytes_received / (millis() - time_stream_start) * 1000) / 1024 ));
+            SERIAL_ECHOLN("KiB/s");
+            SERIAL_ECHOLN("sc"); // transmit stream complete token
             return;
           case StreamState::STREAM_FAILED:
             stream_state = StreamState::STREAM_RESET;
             card.flag.binary_mode = false;
             card.closefile();
             card.removeFile(card.filename);
-            CARD_ECHOLN_P("echo: File transfer failed");
-            CARD_ECHOLN_P("sf"); // transmit stream failed token
+            SERIAL_ECHOLN("echo: File transfer failed");
+            SERIAL_ECHOLN("sf"); // transmit stream failed token
             return;
         }
       }

commit 0feeef26048883640b37ebe3994730f31ef6e922
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 15:06:53 2019 -0600

    Update copyright in headers

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index bdeb574b08..2c85d7da03 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -1,6 +1,6 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm

commit 1bd9a630492e0b029c39e4c885c6a1f49dc0c6ee
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Feb 6 04:59:22 2019 -0600

    Add HAS_EXTRA_ENDSTOPS macro

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 4acea17b0b..bdeb574b08 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -635,7 +635,7 @@ inline void get_serial_commands() {
           gcode_LastN = gcode_N;
         }
         #if ENABLED(SDSUPPORT)
-          // Pronterface "M29" and "M29 " has no line number 
+          // Pronterface "M29" and "M29 " has no line number
           else if (card.flag.saving && !is_M29(command))
             return gcode_line_error(PSTR(MSG_ERR_NO_CHECKSUM), i);
         #endif

commit 1497fb388a6f168e5fbf3e3f4228dda804a0602c
Merge: b5fd2fb58b c03bac9ad4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Feb 4 07:23:42 2019 -0600

    M29 match logic was reversed (#13013)
    
    * M29 logic was reversed
    
    If in card-saving mode generate errors line errors for anything that's *NOT* "M29 ?"
    
    * Update queue.cpp
    
    * Update queue.cpp

diff --combined Marlin/src/gcode/queue.cpp
index 473e170705,9742bcb161..4acea17b0b
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@@ -144,7 -144,7 +144,7 @@@ bool enqueue_and_echo_command(const cha
    //SERIAL_ECHOPGM("\") \n");
  
    if (*cmd == 0 || *cmd == '\n' || *cmd == '\r') {
 -    //SERIAL_ECHOPGM("Null command found...   Did not queue!\n");
 +    //SERIAL_ECHOLNPGM("Null command found...   Did not queue!");
      return true;
    }
  
@@@ -251,7 -251,15 +251,7 @@@ void flush_and_request_resend() 
    ok_to_send();
  }
  
 -void gcode_line_error(PGM_P err, uint8_t port) {
 -  SERIAL_ERROR_START_P(port);
 -  serialprintPGM_P(port, err);
 -  SERIAL_ECHOLN_P(port, gcode_LastN);
 -  flush_and_request_resend();
 -  serial_count[port] = 0;
 -}
 -
 -static bool serial_data_available() {
 +inline bool serial_data_available() {
    return false
      || MYSERIAL0.available()
      #if NUM_SERIAL > 1
@@@ -260,7 -268,7 +260,7 @@@
    ;
  }
  
 -static int read_serial(const uint8_t index) {
 +inline int read_serial(const uint8_t index) {
    switch (index) {
      case 0: return MYSERIAL0.read();
      #if NUM_SERIAL > 1
@@@ -270,15 -278,6 +270,15 @@@
    }
  }
  
 +void gcode_line_error(PGM_P err, uint8_t port) {
 +  SERIAL_ERROR_START_P(port);
 +  serialprintPGM_P(port, err);
 +  SERIAL_ECHOLN_P(port, gcode_LastN);
 +  while (read_serial(port) != -1);           // clear out the RX buffer
 +  flush_and_request_resend();
 +  serial_count[port] = 0;
 +}
 +
  #if ENABLED(FAST_FILE_TRANSFER)
  
    #if ENABLED(SDSUPPORT)
@@@ -287,7 -286,7 +287,7 @@@
      #define CARD_ECHOLN_P(V) SERIAL_ECHOLN_P(card.transfer_port, V)
    #endif
  
 -  static bool serial_data_available(const uint8_t index) {
 +  inline bool serial_data_available(const uint8_t index) {
      switch (index) {
        case 0: return MYSERIAL0.available();
        #if NUM_SERIAL > 1
@@@ -536,6 -535,10 +536,10 @@@
  
  #endif // FAST_FILE_TRANSFER
  
+ FORCE_INLINE bool is_M29(const char * const cmd) {
+   return cmd[0] == 'M' && cmd[1] == '2' && cmd[2] == '9' && !WITHIN(cmd[3], '0', '9');
+ }
+ 
  /**
   * Get all commands waiting on the serial port and queue them.
   * Exit when the buffer is full or when no more characters are
@@@ -631,7 -634,8 +635,8 @@@ inline void get_serial_commands() 
            gcode_LastN = gcode_N;
          }
          #if ENABLED(SDSUPPORT)
-           else if (card.flag.saving && command[0] == 'M' && command[1] == '2' && command[2] == '9' && (command[3] == '\0' || command[3] == ' '))
+           // Pronterface "M29" and "M29 " has no line number 
+           else if (card.flag.saving && !is_M29(command))
              return gcode_line_error(PSTR(MSG_ERR_NO_CHECKSUM), i);
          #endif
  
@@@ -840,7 -844,7 +845,7 @@@ void advance_command_queue() 
  
      if (card.flag.saving) {
        char* command = command_queue[cmd_queue_index_r];
-       if (command[0] == 'M' && command[1] == '2' && command[2] == '9' && (command[3] == '\0' || command[3] == ' ')) {
+       if (is_M29(command)) {
          // M29 closes the file
          card.closefile();
          SERIAL_ECHOLNPGM(MSG_FILE_SAVED);

commit c03bac9ad4d5a32b0c20054ae81998e5a3786af1
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Feb 4 07:17:40 2019 -0600

    Update queue.cpp

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 092b94c78e..9742bcb161 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -535,6 +535,10 @@ static int read_serial(const uint8_t index) {
 
 #endif // FAST_FILE_TRANSFER
 
+FORCE_INLINE bool is_M29(const char * const cmd) {
+  return cmd[0] == 'M' && cmd[1] == '2' && cmd[2] == '9' && !WITHIN(cmd[3], '0', '9');
+}
+
 /**
  * Get all commands waiting on the serial port and queue them.
  * Exit when the buffer is full or when no more characters are
@@ -631,7 +635,7 @@ inline void get_serial_commands() {
         }
         #if ENABLED(SDSUPPORT)
           // Pronterface "M29" and "M29 " has no line number 
-          else if (card.flag.saving && !(command[0] == 'M' && command[1] == '2' && command[2] == '9' && (command[3] == '\0' || command[3] == ' ' ||  || command[3] == '*')))
+          else if (card.flag.saving && !is_M29(command))
             return gcode_line_error(PSTR(MSG_ERR_NO_CHECKSUM), i);
         #endif
 
@@ -840,7 +844,7 @@ void advance_command_queue() {
 
     if (card.flag.saving) {
       char* command = command_queue[cmd_queue_index_r];
-      if (command[0] == 'M' && command[1] == '2' && command[2] == '9' && (command[3] == '\0' || command[3] == ' ' ||  || command[3] == '*')) {
+      if (is_M29(command)) {
         // M29 closes the file
         card.closefile();
         SERIAL_ECHOLNPGM(MSG_FILE_SAVED);

commit a49f0205eae59dc0d0bb1a18d311a5dd4dc4d61e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Feb 4 07:11:08 2019 -0600

    Update queue.cpp

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 1dceb2243e..092b94c78e 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -631,7 +631,7 @@ inline void get_serial_commands() {
         }
         #if ENABLED(SDSUPPORT)
           // Pronterface "M29" and "M29 " has no line number 
-          else if (card.flag.saving && !(command[0] == 'M' && command[1] == '2' && command[2] == '9' && (command[3] == '\0' || command[3] == ' ')))
+          else if (card.flag.saving && !(command[0] == 'M' && command[1] == '2' && command[2] == '9' && (command[3] == '\0' || command[3] == ' ' ||  || command[3] == '*')))
             return gcode_line_error(PSTR(MSG_ERR_NO_CHECKSUM), i);
         #endif
 
@@ -840,7 +840,7 @@ void advance_command_queue() {
 
     if (card.flag.saving) {
       char* command = command_queue[cmd_queue_index_r];
-      if (command[0] == 'M' && command[1] == '2' && command[2] == '9' && (command[3] == '\0' || command[3] == ' ')) {
+      if (command[0] == 'M' && command[1] == '2' && command[2] == '9' && (command[3] == '\0' || command[3] == ' ' ||  || command[3] == '*')) {
         // M29 closes the file
         card.closefile();
         SERIAL_ECHOLNPGM(MSG_FILE_SAVED);

commit 2f176d6fb8b71e33b7dc50a86e4f8dfa8c2b27d8
Author: jeffstaley <jeffstaley@gmail.com>
Date:   Mon Feb 4 04:03:49 2019 -0800

    Flush RX buffer on G-code line errors to prevent hang (#13018)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index b11304d12a..473e170705 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -251,15 +251,7 @@ void flush_and_request_resend() {
   ok_to_send();
 }
 
-void gcode_line_error(PGM_P err, uint8_t port) {
-  SERIAL_ERROR_START_P(port);
-  serialprintPGM_P(port, err);
-  SERIAL_ECHOLN_P(port, gcode_LastN);
-  flush_and_request_resend();
-  serial_count[port] = 0;
-}
-
-static bool serial_data_available() {
+inline bool serial_data_available() {
   return false
     || MYSERIAL0.available()
     #if NUM_SERIAL > 1
@@ -268,7 +260,7 @@ static bool serial_data_available() {
   ;
 }
 
-static int read_serial(const uint8_t index) {
+inline int read_serial(const uint8_t index) {
   switch (index) {
     case 0: return MYSERIAL0.read();
     #if NUM_SERIAL > 1
@@ -278,6 +270,15 @@ static int read_serial(const uint8_t index) {
   }
 }
 
+void gcode_line_error(PGM_P err, uint8_t port) {
+  SERIAL_ERROR_START_P(port);
+  serialprintPGM_P(port, err);
+  SERIAL_ECHOLN_P(port, gcode_LastN);
+  while (read_serial(port) != -1);           // clear out the RX buffer
+  flush_and_request_resend();
+  serial_count[port] = 0;
+}
+
 #if ENABLED(FAST_FILE_TRANSFER)
 
   #if ENABLED(SDSUPPORT)
@@ -286,7 +287,7 @@ static int read_serial(const uint8_t index) {
     #define CARD_ECHOLN_P(V) SERIAL_ECHOLN_P(card.transfer_port, V)
   #endif
 
-  static bool serial_data_available(const uint8_t index) {
+  inline bool serial_data_available(const uint8_t index) {
     switch (index) {
       case 0: return MYSERIAL0.available();
       #if NUM_SERIAL > 1

commit 4fa1c52688917b139f1a2a68dd9028a592d4567a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Feb 2 23:32:48 2019 -0600

    Tweak serial output code

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index b0389848cf..b11304d12a 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -144,7 +144,7 @@ bool enqueue_and_echo_command(const char* cmd) {
   //SERIAL_ECHOPGM("\") \n");
 
   if (*cmd == 0 || *cmd == '\n' || *cmd == '\r') {
-    //SERIAL_ECHOPGM("Null command found...   Did not queue!\n");
+    //SERIAL_ECHOLNPGM("Null command found...   Did not queue!");
     return true;
   }
 

commit 3f91233f6df84d46fd9bdcb0ea38ceeb6d983623
Author: jeffstaley <jeffstaley@gmail.com>
Date:   Fri Jan 25 07:36:52 2019 -0800

    M29 logic was reversed
    
    If in card-saving mode generate errors line errors for anything that's *NOT* "M29 ?"

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index b0389848cf..1dceb2243e 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -630,7 +630,8 @@ inline void get_serial_commands() {
           gcode_LastN = gcode_N;
         }
         #if ENABLED(SDSUPPORT)
-          else if (card.flag.saving && command[0] == 'M' && command[1] == '2' && command[2] == '9' && (command[3] == '\0' || command[3] == ' '))
+          // Pronterface "M29" and "M29 " has no line number 
+          else if (card.flag.saving && !(command[0] == 'M' && command[1] == '2' && command[2] == '9' && (command[3] == '\0' || command[3] == ' ')))
             return gcode_line_error(PSTR(MSG_ERR_NO_CHECKSUM), i);
         #endif
 

commit 0e0cc13650cd9174114baf02b06a98310f976b6d
Author: jeffstaley <jeffstaley@gmail.com>
Date:   Thu Jan 24 19:10:59 2019 -0800

    Fix M29 for Pronterface SD card upload (#13010)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 28a9eaf0fc..b0389848cf 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -630,7 +630,7 @@ inline void get_serial_commands() {
           gcode_LastN = gcode_N;
         }
         #if ENABLED(SDSUPPORT)
-          else if (card.flag.saving && strcmp(command, "M29") != 0) // No line number with M29 in Pronterface
+          else if (card.flag.saving && command[0] == 'M' && command[1] == '2' && command[2] == '9' && (command[3] == '\0' || command[3] == ' '))
             return gcode_line_error(PSTR(MSG_ERR_NO_CHECKSUM), i);
         #endif
 
@@ -839,7 +839,7 @@ void advance_command_queue() {
 
     if (card.flag.saving) {
       char* command = command_queue[cmd_queue_index_r];
-      if (strstr_P(command, PSTR("M29"))) {
+      if (command[0] == 'M' && command[1] == '2' && command[2] == '9' && (command[3] == '\0' || command[3] == ' ')) {
         // M29 closes the file
         card.closefile();
         SERIAL_ECHOLNPGM(MSG_FILE_SAVED);

commit 50b2fbd03140d21076b8dd3015219ffed0f761c9
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Fri Dec 7 23:34:21 2018 +0200

    Trinamic: Split stealthChop, improve driver monitoring, etc. (#12582)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index b73e2af02b..28a9eaf0fc 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -378,8 +378,8 @@ static int read_serial(const uint8_t index) {
     template<const size_t buffer_size>
     void receive(char (&buffer)[buffer_size]) {
       uint8_t data = 0;
-      millis_t tranfer_timeout = millis() + RX_TIMESLICE;
-      while (PENDING(millis(), tranfer_timeout)) {
+      millis_t transfer_timeout = millis() + RX_TIMESLICE;
+      while (PENDING(millis(), transfer_timeout)) {
         switch (stream_state) {
           case StreamState::STREAM_RESET:
             stream_reset();

commit c98623983774b9773800bc7dcef695c4bad81c0e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Nov 29 16:58:58 2018 -0600

    A single SERIAL_ECHO macro type (#12557)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 0b6bb4ba77..b73e2af02b 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -221,17 +221,17 @@ void ok_to_send() {
     if (port < 0) return;
   #endif
   if (!send_ok[cmd_queue_index_r]) return;
-  SERIAL_PROTOCOLPGM_P(port, MSG_OK);
+  SERIAL_ECHOPGM_P(port, MSG_OK);
   #if ENABLED(ADVANCED_OK)
     char* p = command_queue[cmd_queue_index_r];
     if (*p == 'N') {
-      SERIAL_PROTOCOL_P(port, ' ');
+      SERIAL_ECHO_P(port, ' ');
       SERIAL_ECHO_P(port, *p++);
       while (NUMERIC_SIGNED(*p))
         SERIAL_ECHO_P(port, *p++);
     }
-    SERIAL_PROTOCOLPGM_P(port, " P"); SERIAL_PROTOCOL_P(port, int(BLOCK_BUFFER_SIZE - planner.movesplanned() - 1));
-    SERIAL_PROTOCOLPGM_P(port, " B"); SERIAL_PROTOCOL_P(port, BUFSIZE - commands_in_queue);
+    SERIAL_ECHOPGM_P(port, " P"); SERIAL_ECHO_P(port, int(BLOCK_BUFFER_SIZE - planner.movesplanned() - 1));
+    SERIAL_ECHOPGM_P(port, " B"); SERIAL_ECHO_P(port, BUFSIZE - commands_in_queue);
   #endif
   SERIAL_EOL_P(port);
 }
@@ -246,15 +246,15 @@ void flush_and_request_resend() {
     if (port < 0) return;
   #endif
   SERIAL_FLUSH_P(port);
-  SERIAL_PROTOCOLPGM_P(port, MSG_RESEND);
-  SERIAL_PROTOCOLLN_P(port, gcode_LastN + 1);
+  SERIAL_ECHOPGM_P(port, MSG_RESEND);
+  SERIAL_ECHOLN_P(port, gcode_LastN + 1);
   ok_to_send();
 }
 
 void gcode_line_error(PGM_P err, uint8_t port) {
   SERIAL_ERROR_START_P(port);
   serialprintPGM_P(port, err);
-  SERIAL_ERRORLN_P(port, gcode_LastN);
+  SERIAL_ECHOLN_P(port, gcode_LastN);
   flush_and_request_resend();
   serial_count[port] = 0;
 }
@@ -648,7 +648,7 @@ inline void get_serial_commands() {
               #if ENABLED(BEZIER_CURVE_SUPPORT)
                 case 5:
               #endif
-                SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
+                SERIAL_ECHOLNPGM(MSG_ERR_STOPPED);
                 LCD_MESSAGEPGM(MSG_STOPPED);
                 break;
             }
@@ -754,7 +754,7 @@ inline void get_serial_commands() {
           if (IS_SD_PRINTING())
             sd_count = 0; // If a sub-file was printing, continue from call point
           else {
-            SERIAL_PROTOCOLLNPGM(MSG_FILE_PRINTED);
+            SERIAL_ECHOLNPGM(MSG_FILE_PRINTED);
             #if ENABLED(PRINTER_EVENT_LEDS)
               printerEventLEDs.onPrintCompleted();
               #if HAS_RESUME_CONTINUE
@@ -769,10 +769,9 @@ inline void get_serial_commands() {
             #endif // PRINTER_EVENT_LEDS
           }
         }
-        else if (n == -1) {
-          SERIAL_ERROR_START();
-          SERIAL_ECHOLNPGM(MSG_SD_ERR_READ);
-        }
+        else if (n == -1)
+          SERIAL_ERROR_MSG(MSG_SD_ERR_READ);
+
         if (sd_char == '#') stop_buffering = true;
 
         sd_comment_mode = false; // for new command
@@ -843,7 +842,7 @@ void advance_command_queue() {
       if (strstr_P(command, PSTR("M29"))) {
         // M29 closes the file
         card.closefile();
-        SERIAL_PROTOCOLLNPGM(MSG_FILE_SAVED);
+        SERIAL_ECHOLNPGM(MSG_FILE_SAVED);
 
         #if !defined(__AVR__) || !defined(USBCON)
           #if ENABLED(SERIAL_STATS_DROPPED_RX)

commit 66580f32c2f4d39a82b77e4b6982e7ea6dde0766
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Nov 16 22:39:16 2018 -0600

    Make CardReader class static (#12451)
    
    * Make CardReader a static class
    * Make CardReader flags into bitfields

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 4cf508dca4..0b6bb4ba77 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -503,7 +503,7 @@ static int read_serial(const uint8_t index) {
             break;
           case StreamState::STREAM_COMPLETE:
             stream_state = StreamState::STREAM_RESET;
-            card.binary_mode = false;
+            card.flag.binary_mode = false;
             card.closefile();
             CARD_ECHO_P("echo: ");
             CARD_ECHO_P(card.filename);
@@ -514,7 +514,7 @@ static int read_serial(const uint8_t index) {
             return;
           case StreamState::STREAM_FAILED:
             stream_state = StreamState::STREAM_RESET;
-            card.binary_mode = false;
+            card.flag.binary_mode = false;
             card.closefile();
             card.removeFile(card.filename);
             CARD_ECHOLN_P("echo: File transfer failed");
@@ -549,7 +549,7 @@ inline void get_serial_commands() {
             ;
 
   #if ENABLED(FAST_FILE_TRANSFER)
-    if (card.saving && card.binary_mode) {
+    if (card.flag.saving && card.flag.binary_mode) {
       /**
        * For binary stream file transfer, use serial_line_buffer as the working
        * receive buffer (which limits the packet size to MAX_CMD_SIZE).
@@ -630,7 +630,7 @@ inline void get_serial_commands() {
           gcode_LastN = gcode_N;
         }
         #if ENABLED(SDSUPPORT)
-          else if (card.saving && strcmp(command, "M29") != 0) // No line number with M29 in Pronterface
+          else if (card.flag.saving && strcmp(command, "M29") != 0) // No line number with M29 in Pronterface
             return gcode_line_error(PSTR(MSG_ERR_NO_CHECKSUM), i);
         #endif
 
@@ -838,7 +838,7 @@ void advance_command_queue() {
 
   #if ENABLED(SDSUPPORT)
 
-    if (card.saving) {
+    if (card.flag.saving) {
       char* command = command_queue[cmd_queue_index_r];
       if (strstr_P(command, PSTR("M29"))) {
         // M29 closes the file
@@ -860,7 +860,7 @@ void advance_command_queue() {
       else {
         // Write the string from the read buffer to SD
         card.write_command(command);
-        if (card.logging)
+        if (card.flag.logging)
           gcode.process_next_command(); // The card is saving because it's logging
         else
           ok_to_send();

commit d97e31db4c2b8b27ab1c6fbbe05f11aa9d5e94e2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Nov 16 20:47:07 2018 -0600

    Optimize Power-Loss Recovery (#12440)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 70c2b3e0ce..4cf508dca4 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -809,22 +809,6 @@ inline void get_serial_commands() {
     }
   }
 
-  #if ENABLED(POWER_LOSS_RECOVERY)
-
-    inline bool drain_job_recovery_commands() {
-      static uint8_t job_recovery_commands_index = 0; // Resets on reboot
-      if (job_recovery_commands_count) {
-        if (_enqueuecommand(job_recovery_commands[job_recovery_commands_index])) {
-          ++job_recovery_commands_index;
-          if (!--job_recovery_commands_count) job_recovery_phase = JOB_RECOVERY_DONE;
-        }
-        return true;
-      }
-      return false;
-    }
-
-  #endif
-
 #endif // SDSUPPORT
 
 /**
@@ -840,11 +824,6 @@ void get_available_commands() {
 
   get_serial_commands();
 
-  #if ENABLED(POWER_LOSS_RECOVERY)
-    // Commands for power-loss recovery take precedence
-    if (job_recovery_phase == JOB_RECOVERY_YES && drain_job_recovery_commands()) return;
-  #endif
-
   #if ENABLED(SDSUPPORT)
     get_sdcard_commands();
   #endif
@@ -890,7 +869,7 @@ void advance_command_queue() {
     else {
       gcode.process_next_command();
       #if ENABLED(POWER_LOSS_RECOVERY)
-        if (card.cardOK && IS_SD_PRINTING()) save_job_recovery_info();
+        if (IS_SD_PRINTING()) recovery.save();
       #endif
     }
 

commit b60abc7c378e47959fb11f890d49ee7e90588d3d
Author: revilor <oliver.rossmueller@web.de>
Date:   Fri Nov 9 12:25:08 2018 +0100

    [2.0.x] Macro G-codes (#9365)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 57d26dec78..70c2b3e0ce 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -188,7 +188,8 @@ void enqueue_and_echo_commands_P(PGM_P const pgcode) {
 
 #if HAS_QUEUE_NOW
   /**
-   * Enqueue and return only when commands are actually enqueued
+   * Enqueue and return only when commands are actually enqueued.
+   * Never call this from a G-code handler!
    */
   void enqueue_and_echo_command_now(const char* cmd) {
     while (!enqueue_and_echo_command(cmd)) idle();
@@ -196,6 +197,7 @@ void enqueue_and_echo_commands_P(PGM_P const pgcode) {
   #if HAS_LCD_QUEUE_NOW
     /**
      * Enqueue from program memory and return only when commands are actually enqueued
+     * Never call this from a G-code handler!
      */
     void enqueue_and_echo_commands_now_P(PGM_P const pgcode) {
       enqueue_and_echo_commands_P(pgcode);

commit 488a17b3f5224ccd50f0cbc916a1e7c7ccf1ad6b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Nov 6 20:52:39 2018 -0600

    Use IS_SD_PRINTING() more

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index b72af75e5a..57d26dec78 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -749,7 +749,7 @@ inline void get_serial_commands() {
 
           card.printingHasFinished();
 
-          if (card.sdprinting)
+          if (IS_SD_PRINTING())
             sd_count = 0; // If a sub-file was printing, continue from call point
           else {
             SERIAL_PROTOCOLLNPGM(MSG_FILE_PRINTED);
@@ -888,7 +888,7 @@ void advance_command_queue() {
     else {
       gcode.process_next_command();
       #if ENABLED(POWER_LOSS_RECOVERY)
-        if (card.cardOK && card.sdprinting) save_job_recovery_info();
+        if (card.cardOK && IS_SD_PRINTING()) save_job_recovery_info();
       #endif
     }
 

commit cc2bc67440bdd17851cd76fcda301c9bffb788cf
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Nov 3 02:07:53 2018 -0500

    ENABLED(NEWPANEL) => HAS_LCD_MENU

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index ad28877115..b72af75e5a 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -757,7 +757,7 @@ inline void get_serial_commands() {
               printerEventLEDs.onPrintCompleted();
               #if HAS_RESUME_CONTINUE
                 enqueue_and_echo_commands_P(PSTR("M0 S"
-                  #if ENABLED(NEWPANEL)
+                  #if HAS_LCD_MENU
                     "1800"
                   #else
                     "60"

commit 66d44c72c30991965ac7f1daea1c22c17cf12a6f
Author: Chris Pepper <p3p@p3psoft.co.uk>
Date:   Wed Oct 31 00:44:12 2018 +0000

    Add fast binary file transfer to SD card option (#12249)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 2d7fe1ab5e..ad28877115 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -258,14 +258,15 @@ void gcode_line_error(PGM_P err, uint8_t port) {
 }
 
 static bool serial_data_available() {
-  return (MYSERIAL0.available() ? true :
+  return false
+    || MYSERIAL0.available()
     #if NUM_SERIAL > 1
-      MYSERIAL1.available() ? true :
+      || MYSERIAL1.available()
     #endif
-    false);
+  ;
 }
 
-static int read_serial(const int index) {
+static int read_serial(const uint8_t index) {
   switch (index) {
     case 0: return MYSERIAL0.read();
     #if NUM_SERIAL > 1
@@ -275,6 +276,263 @@ static int read_serial(const int index) {
   }
 }
 
+#if ENABLED(FAST_FILE_TRANSFER)
+
+  #if ENABLED(SDSUPPORT)
+    #define CARD_CHAR_P(C)   SERIAL_CHAR_P(card.transfer_port, C)
+    #define CARD_ECHO_P(V)   SERIAL_ECHO_P(card.transfer_port, V)
+    #define CARD_ECHOLN_P(V) SERIAL_ECHOLN_P(card.transfer_port, V)
+  #endif
+
+  static bool serial_data_available(const uint8_t index) {
+    switch (index) {
+      case 0: return MYSERIAL0.available();
+      #if NUM_SERIAL > 1
+        case 1: return MYSERIAL1.available();
+      #endif
+      default: return false;
+    }
+  }
+
+  class BinaryStream {
+  public:
+    enum class StreamState : uint8_t {
+      STREAM_RESET,
+      PACKET_RESET,
+      STREAM_HEADER,
+      PACKET_HEADER,
+      PACKET_DATA,
+      PACKET_VALIDATE,
+      PACKET_RESEND,
+      PACKET_FLUSHRX,
+      PACKET_TIMEOUT,
+      STREAM_COMPLETE,
+      STREAM_FAILED,
+    };
+
+    #pragma pack(push, 1)
+
+      struct StreamHeader {
+        uint16_t token;
+        uint32_t filesize;
+      };
+      union {
+        uint8_t stream_header_bytes[sizeof(StreamHeader)];
+        StreamHeader stream_header;
+      };
+
+      struct Packet {
+        struct Header {
+          uint32_t id;
+          uint16_t size, checksum;
+        };
+        union {
+          uint8_t header_bytes[sizeof(Header)];
+          Header header;
+        };
+        uint32_t bytes_received;
+        uint16_t checksum;
+        millis_t timeout;
+      } packet{};
+
+    #pragma pack(pop)
+
+    void packet_reset() {
+      packet.header.id = 0;
+      packet.header.size = 0;
+      packet.header.checksum = 0;
+      packet.bytes_received = 0;
+      packet.checksum = 0x53A2;
+      packet.timeout = millis() + STREAM_MAX_WAIT;
+    }
+
+    void stream_reset() {
+      packets_received = 0;
+      bytes_received = 0;
+      packet_retries = 0;
+      buffer_next_index = 0;
+      stream_header.token = 0;
+      stream_header.filesize = 0;
+    }
+
+    uint32_t checksum(uint32_t seed, uint8_t value) {
+      return ((seed ^ value) ^ (seed << 8)) & 0xFFFF;
+    }
+
+    // read the next byte from the data stream keeping track of
+    // whether the stream times out from data starvation
+    // takes the data variable by reference in order to return status
+    bool stream_read(uint8_t& data) {
+      if (ELAPSED(millis(), packet.timeout)) {
+        stream_state = StreamState::PACKET_TIMEOUT;
+        return false;
+      }
+      if (!serial_data_available(card.transfer_port)) return false;
+      data = read_serial(card.transfer_port);
+      packet.timeout = millis() + STREAM_MAX_WAIT;
+      return true;
+    }
+
+    template<const size_t buffer_size>
+    void receive(char (&buffer)[buffer_size]) {
+      uint8_t data = 0;
+      millis_t tranfer_timeout = millis() + RX_TIMESLICE;
+      while (PENDING(millis(), tranfer_timeout)) {
+        switch (stream_state) {
+          case StreamState::STREAM_RESET:
+            stream_reset();
+          case StreamState::PACKET_RESET:
+            packet_reset();
+            stream_state = StreamState::PACKET_HEADER;
+            break;
+          case StreamState::STREAM_HEADER: // we could also transfer the filename in this packet, rather than handling it in the gcode
+            for (size_t i = 0; i < sizeof(stream_header); ++i) {
+              stream_header_bytes[i] = buffer[i];
+            }
+            if (stream_header.token == 0x1234) {
+              stream_state = StreamState::PACKET_RESET;
+              bytes_received = 0;
+              time_stream_start = millis();
+              CARD_ECHO_P("echo: Datastream initialized (");
+              CARD_ECHO_P(stream_header.filesize);
+              CARD_ECHOLN_P("Bytes expected)");
+              CARD_ECHO_P("so"); // confirm active stream and the maximum block size supported
+              CARD_CHAR_P(static_cast<uint8_t>(buffer_size & 0xFF));
+              CARD_CHAR_P(static_cast<uint8_t>((buffer_size >> 8) & 0xFF));
+              CARD_CHAR_P('\n');
+            }
+            else {
+              CARD_ECHOLN_P("echo: Datastream initialization error (invalid token)");
+              stream_state = StreamState::STREAM_FAILED;
+            }
+            buffer_next_index = 0;
+            break;
+          case StreamState::PACKET_HEADER:
+            if (!stream_read(data)) break;
+
+            packet.header_bytes[packet.bytes_received++] = data;
+            if (packet.bytes_received == sizeof(Packet::Header)) {
+              if (packet.header.id == packets_received) {
+                buffer_next_index = 0;
+                packet.bytes_received = 0;
+                stream_state = StreamState::PACKET_DATA;
+              }
+              else {
+                CARD_ECHO_P("echo: Datastream packet out of order");
+                stream_state = StreamState::PACKET_FLUSHRX;
+              }
+            }
+            break;
+          case StreamState::PACKET_DATA:
+            if (!stream_read(data)) break;
+
+            if (buffer_next_index < buffer_size) {
+              buffer[buffer_next_index] = data;
+            }
+            else {
+              CARD_ECHO_P("echo: Datastream packet data buffer overrun");
+              stream_state = StreamState::STREAM_FAILED;
+              break;
+            }
+
+            packet.checksum = checksum(packet.checksum, data);
+            packet.bytes_received ++;
+            buffer_next_index ++;
+
+            if (packet.bytes_received == packet.header.size) {
+              stream_state = StreamState::PACKET_VALIDATE;
+            }
+            break;
+          case StreamState::PACKET_VALIDATE:
+            if (packet.header.checksum == packet.checksum) {
+              packet_retries = 0;
+              packets_received ++;
+              bytes_received += packet.header.size;
+
+              if (packet.header.id == 0) {                 // id 0 is always the stream descriptor
+                stream_state = StreamState::STREAM_HEADER; // defer packet confirmation to STREAM_HEADER state
+              }
+              else {
+                if (bytes_received < stream_header.filesize) {
+                  stream_state = StreamState::PACKET_RESET;    // reset and receive next packet
+                  CARD_ECHOLN_P("ok");   // transmit confirm packet received and valid token
+                }
+                else  {
+                  stream_state = StreamState::STREAM_COMPLETE; // no more data required
+                }
+                if (card.write(buffer, buffer_next_index) < 0) {
+                  stream_state = StreamState::STREAM_FAILED;
+                  CARD_ECHO_P("echo: IO ERROR");
+                  break;
+                };
+              }
+            }
+            else {
+              CARD_ECHO_P("echo: Block(");
+              CARD_ECHO_P(packet.header.id);
+              CARD_ECHOLN_P(") Corrupt");
+              stream_state = StreamState::PACKET_FLUSHRX;
+            }
+            break;
+          case StreamState::PACKET_RESEND:
+            if (packet_retries < MAX_RETRIES) {
+              packet_retries ++;
+              stream_state = StreamState::PACKET_RESET;
+              CARD_ECHO_P("echo: Resend request ");
+              CARD_ECHOLN_P(packet_retries);
+              CARD_ECHOLN_P("rs"); // transmit resend packet token
+            }
+            else {
+              stream_state = StreamState::STREAM_FAILED;
+            }
+            break;
+          case StreamState::PACKET_FLUSHRX:
+            if (ELAPSED(millis(), packet.timeout)) {
+              stream_state = StreamState::PACKET_RESEND;
+              break;
+            }
+            if (!serial_data_available(card.transfer_port)) break;
+            read_serial(card.transfer_port); // throw away data
+            packet.timeout = millis() + STREAM_MAX_WAIT;
+            break;
+          case StreamState::PACKET_TIMEOUT:
+            CARD_ECHOLN_P("echo: Datastream timeout");
+            stream_state = StreamState::PACKET_RESEND;
+            break;
+          case StreamState::STREAM_COMPLETE:
+            stream_state = StreamState::STREAM_RESET;
+            card.binary_mode = false;
+            card.closefile();
+            CARD_ECHO_P("echo: ");
+            CARD_ECHO_P(card.filename);
+            CARD_ECHO_P(" transfer completed @ ");
+            CARD_ECHO_P(((bytes_received / (millis() - time_stream_start) * 1000) / 1024 ));
+            CARD_ECHOLN_P("KiB/s");
+            CARD_ECHOLN_P("sc"); // transmit stream complete token
+            return;
+          case StreamState::STREAM_FAILED:
+            stream_state = StreamState::STREAM_RESET;
+            card.binary_mode = false;
+            card.closefile();
+            card.removeFile(card.filename);
+            CARD_ECHOLN_P("echo: File transfer failed");
+            CARD_ECHOLN_P("sf"); // transmit stream failed token
+            return;
+        }
+      }
+    }
+
+    static const uint16_t STREAM_MAX_WAIT = 500, RX_TIMESLICE = 20, MAX_RETRIES = 3;
+    uint8_t  packet_retries;
+    uint16_t buffer_next_index;
+    uint32_t packets_received,  bytes_received;
+    millis_t time_stream_start;
+    StreamState stream_state = StreamState::STREAM_RESET;
+
+  } binaryStream{};
+
+#endif // FAST_FILE_TRANSFER
+
 /**
  * Get all commands waiting on the serial port and queue them.
  * Exit when the buffer is full or when no more characters are
@@ -288,6 +546,18 @@ inline void get_serial_commands() {
               #endif
             ;
 
+  #if ENABLED(FAST_FILE_TRANSFER)
+    if (card.saving && card.binary_mode) {
+      /**
+       * For binary stream file transfer, use serial_line_buffer as the working
+       * receive buffer (which limits the packet size to MAX_CMD_SIZE).
+       * The receive buffer also limits the packet size for reliable transmission.
+       */
+      binaryStream.receive(serial_line_buffer[card.transfer_port]);
+      return;
+    }
+  #endif
+
   // If the command buffer is empty for too long,
   // send "wait" to indicate Marlin is still waiting.
   #if NO_TIMEOUTS > 0

commit 3583e2b4490e8fd6778d18003641c2fdd333e8a5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Oct 30 16:34:45 2018 -0500

    Followup to Menu Refactor (#12275)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 7de38442dc..2d7fe1ab5e 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -387,7 +387,7 @@ inline void get_serial_commands() {
           // Process critical commands early
           if (strcmp(command, "M108") == 0) {
             wait_for_heatup = false;
-            #if ENABLED(ULTIPANEL)
+            #if HAS_LCD_MENU
               wait_for_user = false;
             #endif
           }

commit c6a5c7420895bbb32ac3c70f0382ed5622c3746e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 19 13:52:44 2018 -0500

    Add parentheses to SD macros

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index f911c946a6..7de38442dc 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -450,7 +450,7 @@ inline void get_serial_commands() {
                 #endif
               ;
 
-    if (!IS_SD_PRINTING) return;
+    if (!IS_SD_PRINTING()) return;
 
     /**
      * '#' stops reading from SD to the buffer prematurely, so procedural

commit 71e19baf691a5252841cca5871a29d7a65b62e5f
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Thu Oct 18 20:20:56 2018 -0600

    Fix kill => disable_all_heaters => print_job_timer.stop (#12146)
    
    - Remove `print_job_timer.stop()` from `disable_all_heaters`
    - Call `print_job_timer.stop()` for relevant `disable_all_heaters()`.
    - Split up `kill()` for watchdog interrupt safety

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 0c1b406f32..f911c946a6 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -391,7 +391,7 @@ inline void get_serial_commands() {
               wait_for_user = false;
             #endif
           }
-          if (strcmp(command, "M112") == 0) kill(PSTR(MSG_KILLED));
+          if (strcmp(command, "M112") == 0) kill();
           if (strcmp(command, "M410") == 0) quickstop_stepper();
         #endif
 

commit d43d4e421977e333f1a7fbff8b939e0288b3616c
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Thu Oct 11 04:25:43 2018 +0200

    Refactor PRINTER_EVENT_LEDS, apply to M303 (#12038)
    
    Co-Authored-By: Giuliano Zaro <gmagician@users.noreply.github.com>

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 61d7c1d158..0c1b406f32 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -33,8 +33,8 @@
 #include "../module/temperature.h"
 #include "../Marlin.h"
 
-#if HAS_COLOR_LEDS
-  #include "../feature/leds/leds.h"
+#if ENABLED(PRINTER_EVENT_LEDS)
+  #include "../feature/leds/printer_event_leds.h"
 #endif
 
 #if ENABLED(POWER_LOSS_RECOVERY)
@@ -484,10 +484,8 @@ inline void get_serial_commands() {
           else {
             SERIAL_PROTOCOLLNPGM(MSG_FILE_PRINTED);
             #if ENABLED(PRINTER_EVENT_LEDS)
-              LCD_MESSAGEPGM(MSG_INFO_COMPLETED_PRINTS);
-              leds.set_green();
+              printerEventLEDs.onPrintCompleted();
               #if HAS_RESUME_CONTINUE
-                gcode.lights_off_after_print = true;
                 enqueue_and_echo_commands_P(PSTR("M0 S"
                   #if ENABLED(NEWPANEL)
                     "1800"
@@ -495,9 +493,6 @@ inline void get_serial_commands() {
                     "60"
                   #endif
                 ));
-              #else
-                safe_delay(2000);
-                leds.set_off();
               #endif
             #endif // PRINTER_EVENT_LEDS
           }

commit 52a37913c16ab50a0c35e34a4c597bd1428edc7e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 5 18:19:45 2018 -0500

    Extend and apply some corrections

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 6cbd0cc331..61d7c1d158 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -282,10 +282,11 @@ static int read_serial(const int index) {
  */
 inline void get_serial_commands() {
   static char serial_line_buffer[NUM_SERIAL][MAX_CMD_SIZE];
-  static bool serial_comment_mode[NUM_SERIAL] = { false };
-  #if ENABLED(PARENTHESE_COMMENTS)
-    static bool serial_comment_paranthese_mode[NUM_SERIAL] = { false };
-  #endif
+  static bool serial_comment_mode[NUM_SERIAL] = { false }
+              #if ENABLED(PAREN_COMMENTS)
+                , serial_comment_paren_mode[NUM_SERIAL] = { false }
+              #endif
+            ;
 
   // If the command buffer is empty for too long,
   // send "wait" to indicate Marlin is still waiting.
@@ -313,9 +314,10 @@ inline void get_serial_commands() {
        */
       if (serial_char == '\n' || serial_char == '\r') {
 
-        serial_comment_mode[i] = false;                   // end of line == end of comment
-        #if ENABLED(PARENTHESE_COMMENTS)
-          serial_comment_paranthese_mode[i] = false;                   // end of line == end of comment
+        // Start with comment mode off
+        serial_comment_mode[i] = false;
+        #if ENABLED(PAREN_COMMENTS)
+          serial_comment_paren_mode[i] = false;
         #endif
 
         // Skip empty lines and comments
@@ -411,22 +413,22 @@ inline void get_serial_commands() {
       else if (serial_char == '\\') {  // Handle escapes
         // if we have one more character, copy it over
         if ((c = read_serial(i)) >= 0 && !serial_comment_mode[i]
-        #if ENABLED(PARENTHESE_COMMENTS)
-         && ! serial_comment_paranthese_mode[i]
-        #endif
-         )
+          #if ENABLED(PAREN_COMMENTS)
+            && !serial_comment_paren_mode[i]
+          #endif
+        )
           serial_line_buffer[i][serial_count[i]++] = (char)c;
       }
       else { // it's not a newline, carriage return or escape char
-        if (serial_char == ';') serial_comment_mode[i] = true; 
-        #if ENABLED(PARENTHESE_COMMENTS)
-          else if (serial_char == '(') serial_comment_paranthese_mode[i] = true;
-          else if (serial_char == ')') serial_comment_paranthese_mode[i] = false;
-        #endif
-        else if (!serial_comment_mode[i] 
-        #if ENABLED(PARENTHESE_COMMENTS)
-          && ! serial_comment_paranthese_mode[i]
+        if (serial_char == ';') serial_comment_mode[i] = true;
+        #if ENABLED(PAREN_COMMENTS)
+          else if (serial_char == '(') serial_comment_paren_mode[i] = true;
+          else if (serial_char == ')') serial_comment_paren_mode[i] = false;
         #endif
+        else if (!serial_comment_mode[i]
+          #if ENABLED(PAREN_COMMENTS)
+            && ! serial_comment_paren_mode[i]
+          #endif
         ) serial_line_buffer[i][serial_count[i]++] = serial_char;
       }
     } // for NUM_SERIAL
@@ -442,11 +444,12 @@ inline void get_serial_commands() {
    */
   inline void get_sdcard_commands() {
     static bool stop_buffering = false,
-                sd_comment_mode = false;
+                sd_comment_mode = false
+                #if ENABLED(PAREN_COMMENTS)
+                  , sd_comment_paren_mode = false
+                #endif
+              ;
 
-    #if ENABLED(PARENTHESE_COMMENTS)
-      static bool sd_comment_parenthese_mode = false;
-    #endif
     if (!IS_SD_PRINTING) return;
 
     /**
@@ -467,9 +470,9 @@ inline void get_serial_commands() {
       if (card_eof || n == -1
           || sd_char == '\n' || sd_char == '\r'
           || ((sd_char == '#' || sd_char == ':') && !sd_comment_mode
-          #if ENABLED(PARENTHESE_COMMENTS)
-            && ! sd_comment_parenthese_mode
-          #endif
+            #if ENABLED(PAREN_COMMENTS)
+              && !sd_comment_paren_mode
+            #endif
           )
       ) {
         if (card_eof) {
@@ -506,8 +509,8 @@ inline void get_serial_commands() {
         if (sd_char == '#') stop_buffering = true;
 
         sd_comment_mode = false; // for new command
-        #if ENABLED(PARENTHESE_COMMENTS)
-          sd_comment_parenthese_mode = false;
+        #if ENABLED(PAREN_COMMENTS)
+          sd_comment_paren_mode = false;
         #endif
 
         // Skip empty lines and comments
@@ -525,17 +528,16 @@ inline void get_serial_commands() {
          */
       }
       else {
-        if (sd_char == ';') sd_comment_mode = true; 
-        #if ENABLED(PARENTHESE_COMMENTS)
-          else if (sd_char == '(') sd_comment_parenthese_mode = true; 
-          else if (sd_char == ')') sd_comment_parenthese_mode = false; 
+        if (sd_char == ';') sd_comment_mode = true;
+        #if ENABLED(PAREN_COMMENTS)
+          else if (sd_char == '(') sd_comment_paren_mode = true;
+          else if (sd_char == ')') sd_comment_paren_mode = false;
         #endif
         else if (!sd_comment_mode
-        #if ENABLED(PARENTHESE_COMMENTS) 
-        && ! sd_comment_parenthese_mode
-        #endif
-        ) 
-          command_queue[cmd_queue_index_w][sd_count++] = sd_char;
+          #if ENABLED(PAREN_COMMENTS)
+            && ! sd_comment_paren_mode
+          #endif
+        ) command_queue[cmd_queue_index_w][sd_count++] = sd_char;
       }
     }
   }

commit e09c144674fffa39a0077a6af0bd6093eaa138b0
Author: thesfreader <thesfreader@gmail.com>
Date:   Fri Oct 5 09:35:55 2018 +0200

    Add CNC-like G-code options

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 8e30248853..6cbd0cc331 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -283,6 +283,9 @@ static int read_serial(const int index) {
 inline void get_serial_commands() {
   static char serial_line_buffer[NUM_SERIAL][MAX_CMD_SIZE];
   static bool serial_comment_mode[NUM_SERIAL] = { false };
+  #if ENABLED(PARENTHESE_COMMENTS)
+    static bool serial_comment_paranthese_mode[NUM_SERIAL] = { false };
+  #endif
 
   // If the command buffer is empty for too long,
   // send "wait" to indicate Marlin is still waiting.
@@ -311,6 +314,9 @@ inline void get_serial_commands() {
       if (serial_char == '\n' || serial_char == '\r') {
 
         serial_comment_mode[i] = false;                   // end of line == end of comment
+        #if ENABLED(PARENTHESE_COMMENTS)
+          serial_comment_paranthese_mode[i] = false;                   // end of line == end of comment
+        #endif
 
         // Skip empty lines and comments
         if (!serial_count[i]) { thermalManager.manage_heater(); continue; }
@@ -404,12 +410,24 @@ inline void get_serial_commands() {
       }
       else if (serial_char == '\\') {  // Handle escapes
         // if we have one more character, copy it over
-        if ((c = read_serial(i)) >= 0 && !serial_comment_mode[i])
+        if ((c = read_serial(i)) >= 0 && !serial_comment_mode[i]
+        #if ENABLED(PARENTHESE_COMMENTS)
+         && ! serial_comment_paranthese_mode[i]
+        #endif
+         )
           serial_line_buffer[i][serial_count[i]++] = (char)c;
       }
       else { // it's not a newline, carriage return or escape char
-        if (serial_char == ';') serial_comment_mode[i] = true;
-        if (!serial_comment_mode[i]) serial_line_buffer[i][serial_count[i]++] = serial_char;
+        if (serial_char == ';') serial_comment_mode[i] = true; 
+        #if ENABLED(PARENTHESE_COMMENTS)
+          else if (serial_char == '(') serial_comment_paranthese_mode[i] = true;
+          else if (serial_char == ')') serial_comment_paranthese_mode[i] = false;
+        #endif
+        else if (!serial_comment_mode[i] 
+        #if ENABLED(PARENTHESE_COMMENTS)
+          && ! serial_comment_paranthese_mode[i]
+        #endif
+        ) serial_line_buffer[i][serial_count[i]++] = serial_char;
       }
     } // for NUM_SERIAL
   } // queue has space, serial has data
@@ -426,6 +444,9 @@ inline void get_serial_commands() {
     static bool stop_buffering = false,
                 sd_comment_mode = false;
 
+    #if ENABLED(PARENTHESE_COMMENTS)
+      static bool sd_comment_parenthese_mode = false;
+    #endif
     if (!IS_SD_PRINTING) return;
 
     /**
@@ -445,7 +466,11 @@ inline void get_serial_commands() {
       card_eof = card.eof();
       if (card_eof || n == -1
           || sd_char == '\n' || sd_char == '\r'
-          || ((sd_char == '#' || sd_char == ':') && !sd_comment_mode)
+          || ((sd_char == '#' || sd_char == ':') && !sd_comment_mode
+          #if ENABLED(PARENTHESE_COMMENTS)
+            && ! sd_comment_parenthese_mode
+          #endif
+          )
       ) {
         if (card_eof) {
 
@@ -481,6 +506,9 @@ inline void get_serial_commands() {
         if (sd_char == '#') stop_buffering = true;
 
         sd_comment_mode = false; // for new command
+        #if ENABLED(PARENTHESE_COMMENTS)
+          sd_comment_parenthese_mode = false;
+        #endif
 
         // Skip empty lines and comments
         if (!sd_count) { thermalManager.manage_heater(); continue; }
@@ -497,8 +525,17 @@ inline void get_serial_commands() {
          */
       }
       else {
-        if (sd_char == ';') sd_comment_mode = true;
-        if (!sd_comment_mode) command_queue[cmd_queue_index_w][sd_count++] = sd_char;
+        if (sd_char == ';') sd_comment_mode = true; 
+        #if ENABLED(PARENTHESE_COMMENTS)
+          else if (sd_char == '(') sd_comment_parenthese_mode = true; 
+          else if (sd_char == ')') sd_comment_parenthese_mode = false; 
+        #endif
+        else if (!sd_comment_mode
+        #if ENABLED(PARENTHESE_COMMENTS) 
+        && ! sd_comment_parenthese_mode
+        #endif
+        ) 
+          command_queue[cmd_queue_index_w][sd_count++] = sd_char;
       }
     }
   }

commit d6955f25b278904e61b296201a5bee9f222cd4ca
Author: Eduardo Jos√© Tagle <ejtagle@hotmail.com>
Date:   Wed Oct 3 02:47:27 2018 -0300

    Expand serial support in DUE/AVR hals exploiting the templated MarlinSerial classes (#11988)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 4f90f0f157..8e30248853 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -562,11 +562,11 @@ void advance_command_queue() {
 
         #if !defined(__AVR__) || !defined(USBCON)
           #if ENABLED(SERIAL_STATS_DROPPED_RX)
-            SERIAL_ECHOLNPAIR("Dropped bytes: ", customizedSerial.dropped());
+            SERIAL_ECHOLNPAIR("Dropped bytes: ", MYSERIAL0.dropped());
           #endif
 
           #if ENABLED(SERIAL_STATS_MAX_RX_QUEUED)
-            SERIAL_ECHOLNPAIR("Max RX Queue Size: ", customizedSerial.rxMaxEnqueued());
+            SERIAL_ECHOLNPAIR("Max RX Queue Size: ", MYSERIAL0.rxMaxEnqueued());
           #endif
         #endif //  !defined(__AVR__) || !defined(USBCON)
 

commit 11ac75edcb34a2f90b50ca134ff40839f8c29199
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 30 23:44:33 2018 -0500

    Use PGM_P for PSTR pointers (#11977)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 8eafd13990..4f90f0f157 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -84,7 +84,7 @@ bool send_ok[BUFSIZE];
  * Used by Marlin internally to ensure that commands initiated from within
  * are enqueued ahead of any pending serial or sd card commands.
  */
-static const char *injected_commands_P = NULL;
+static PGM_P injected_commands_P = NULL;
 
 void queue_setup() {
   // Send "ok" after commands by default
@@ -181,7 +181,7 @@ static bool drain_injected_commands_P() {
  * Aborts the current queue, if any.
  * Note: drain_injected_commands_P() must be called repeatedly to drain the commands afterwards
  */
-void enqueue_and_echo_commands_P(const char * const pgcode) {
+void enqueue_and_echo_commands_P(PGM_P const pgcode) {
   injected_commands_P = pgcode;
   (void)drain_injected_commands_P(); // first command executed asap (when possible)
 }
@@ -197,7 +197,7 @@ void enqueue_and_echo_commands_P(const char * const pgcode) {
     /**
      * Enqueue from program memory and return only when commands are actually enqueued
      */
-    void enqueue_and_echo_commands_now_P(const char * const pgcode) {
+    void enqueue_and_echo_commands_now_P(PGM_P const pgcode) {
       enqueue_and_echo_commands_P(pgcode);
       while (drain_injected_commands_P()) idle();
     }
@@ -249,7 +249,7 @@ void flush_and_request_resend() {
   ok_to_send();
 }
 
-void gcode_line_error(const char* err, uint8_t port) {
+void gcode_line_error(PGM_P err, uint8_t port) {
   SERIAL_ERROR_START_P(port);
   serialprintPGM_P(port, err);
   SERIAL_ERRORLN_P(port, gcode_LastN);

commit cb6454118ccf99f03bf9264dc27546b5023bc646
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Sep 27 15:40:19 2018 -0500

    Workaround for Pronterface M29

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 7187f1fee0..8eafd13990 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -350,7 +350,7 @@ inline void get_serial_commands() {
           gcode_LastN = gcode_N;
         }
         #if ENABLED(SDSUPPORT)
-          else if (card.saving)
+          else if (card.saving && strcmp(command, "M29") != 0) // No line number with M29 in Pronterface
             return gcode_line_error(PSTR(MSG_ERR_NO_CHECKSUM), i);
         #endif
 
@@ -358,13 +358,17 @@ inline void get_serial_commands() {
         if (IsStopped()) {
           char* gpos = strchr(command, 'G');
           if (gpos) {
-            const int codenum = strtol(gpos + 1, NULL, 10);
-            switch (codenum) {
+            switch (strtol(gpos + 1, NULL, 10)) {
               case 0:
               case 1:
-              case 2:
-              case 3:
-                SERIAL_ERRORLNPGM_P(i, MSG_ERR_STOPPED);
+              #if ENABLED(ARC_SUPPORT)
+                case 2:
+                case 3:
+              #endif
+              #if ENABLED(BEZIER_CURVE_SUPPORT)
+                case 5:
+              #endif
+                SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
                 LCD_MESSAGEPGM(MSG_STOPPED);
                 break;
             }

commit 0780913848eea5048947808dfcc9143131f094d3
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Mon Sep 17 01:06:22 2018 -0500

    IDEX Improvements (#11848)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 7951e5904f..7187f1fee0 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -139,12 +139,12 @@ inline bool _enqueuecommand(const char* cmd, bool say_ok=false
  */
 bool enqueue_and_echo_command(const char* cmd) {
 
-  //SERIAL_ECHO("enqueue_and_echo_command(\"");
+  //SERIAL_ECHOPGM("enqueue_and_echo_command(\"");
   //SERIAL_ECHO(cmd);
-  //SERIAL_ECHO("\") \n");
+  //SERIAL_ECHOPGM("\") \n");
 
   if (*cmd == 0 || *cmd == '\n' || *cmd == '\r') {
-    //SERIAL_ECHO("Null command found...   Did not queue!\n");
+    //SERIAL_ECHOPGM("Null command found...   Did not queue!\n");
     return true;
   }
 

commit d5379ee9d68061b58207c3a2d4e81f4ea3c7cc7d
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Wed Sep 5 16:57:08 2018 -0500

    Fix search for white space in enqueued commands

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index ae56e87450..7951e5904f 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -143,7 +143,7 @@ bool enqueue_and_echo_command(const char* cmd) {
   //SERIAL_ECHO(cmd);
   //SERIAL_ECHO("\") \n");
 
-  if (*cmd == 0 || *cmd == '\n' || *cmd == 'r') {
+  if (*cmd == 0 || *cmd == '\n' || *cmd == '\r') {
     //SERIAL_ECHO("Null command found...   Did not queue!\n");
     return true;
   }

commit d1ceaf5550a98049fce5c78983f798d096e43c1f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 3 23:15:31 2018 -0500

    [2.0.x] Followup to IDEX changes (#11707)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index f690755087..ae56e87450 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -139,15 +139,14 @@ inline bool _enqueuecommand(const char* cmd, bool say_ok=false
  */
 bool enqueue_and_echo_command(const char* cmd) {
 
-//SERIAL_ECHO("enqueue_and_echo_command(\"");
-//SERIAL_ECHO(cmd);
-//SERIAL_ECHO("\") \n");
-//
-  if ( *cmd == 0 || *cmd == '\n' || *cmd == 'r')
-//{
-//SERIAL_ECHO("Null command found...   Did not queue!\n");
+  //SERIAL_ECHO("enqueue_and_echo_command(\"");
+  //SERIAL_ECHO(cmd);
+  //SERIAL_ECHO("\") \n");
+
+  if (*cmd == 0 || *cmd == '\n' || *cmd == 'r') {
+    //SERIAL_ECHO("Null command found...   Did not queue!\n");
     return true;
-//}
+  }
 
   if (_enqueuecommand(cmd)) {
     SERIAL_ECHO_START();

commit 7680b64aa66d3aecbc8d682af9912797e59c12aa
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Sun Sep 2 10:18:59 2018 -0500

    IDEX clean up (#11690)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 9bf161e200..f690755087 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -138,6 +138,17 @@ inline bool _enqueuecommand(const char* cmd, bool say_ok=false
  * Enqueue with Serial Echo
  */
 bool enqueue_and_echo_command(const char* cmd) {
+
+//SERIAL_ECHO("enqueue_and_echo_command(\"");
+//SERIAL_ECHO(cmd);
+//SERIAL_ECHO("\") \n");
+//
+  if ( *cmd == 0 || *cmd == '\n' || *cmd == 'r')
+//{
+//SERIAL_ECHO("Null command found...   Did not queue!\n");
+    return true;
+//}
+
   if (_enqueuecommand(cmd)) {
     SERIAL_ECHO_START();
     SERIAL_ECHOPAIR(MSG_ENQUEUEING, cmd);
@@ -155,7 +166,7 @@ bool enqueue_and_echo_command(const char* cmd) {
 static bool drain_injected_commands_P() {
   if (injected_commands_P != NULL) {
     size_t i = 0;
-    char c, cmd[30];
+    char c, cmd[60];
     strncpy_P(cmd, injected_commands_P, sizeof(cmd) - 1);
     cmd[sizeof(cmd) - 1] = '\0';
     while ((c = cmd[i]) && c != '\n') i++; // find the end of this gcode command

commit 1a0f4dedad5a564800520418ec01448982b9b023
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jul 2 23:21:28 2018 -0500

    Fix and improve POWER_LOSS_RECOVERY (#11187)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 7e92579eed..9bf161e200 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -496,7 +496,7 @@ inline void get_serial_commands() {
       if (job_recovery_commands_count) {
         if (_enqueuecommand(job_recovery_commands[job_recovery_commands_index])) {
           ++job_recovery_commands_index;
-          if (!--job_recovery_commands_count) job_recovery_phase = JOB_RECOVERY_IDLE;
+          if (!--job_recovery_commands_count) job_recovery_phase = JOB_RECOVERY_DONE;
         }
         return true;
       }

commit 05fca752d6d7b88b7697dd5273b6f0428655f3d5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 1 01:01:02 2018 -0500

    Clean up autostart handling

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index a8f5e62dab..7e92579eed 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -458,7 +458,6 @@ inline void get_serial_commands() {
                 leds.set_off();
               #endif
             #endif // PRINTER_EVENT_LEDS
-            card.checkautostart(true);
           }
         }
         else if (n == -1) {

commit 11ab017dd06bb9d06435dc03469a799d53893493
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Apr 21 19:41:26 2018 -0500

    Creality3D Power-Loss Recovery

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 7ac8c7912e..a8f5e62dab 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -37,6 +37,10 @@
   #include "../feature/leds/leds.h"
 #endif
 
+#if ENABLED(POWER_LOSS_RECOVERY)
+  #include "../feature/power_loss_recovery.h"
+#endif
+
 /**
  * GCode line number handling. Hosts may opt to include line numbers when
  * sending commands to Marlin, and lines will be checked for sequentiality.
@@ -115,7 +119,7 @@ inline void _commit_command(bool say_ok
  * Return true if the command was successfully added.
  * Return false for a full buffer, or if the 'command' is a comment.
  */
-inline bool _enqueuecommand(const char* cmd, bool say_ok
+inline bool _enqueuecommand(const char* cmd, bool say_ok=false
   #if NUM_SERIAL > 1
     , int16_t port = -1
   #endif
@@ -133,8 +137,8 @@ inline bool _enqueuecommand(const char* cmd, bool say_ok
 /**
  * Enqueue with Serial Echo
  */
-bool enqueue_and_echo_command(const char* cmd, bool say_ok/*=false*/) {
-  if (_enqueuecommand(cmd, say_ok)) {
+bool enqueue_and_echo_command(const char* cmd) {
+  if (_enqueuecommand(cmd)) {
     SERIAL_ECHO_START();
     SERIAL_ECHOPAIR(MSG_ENQUEUEING, cmd);
     SERIAL_CHAR('"');
@@ -486,6 +490,22 @@ inline void get_serial_commands() {
     }
   }
 
+  #if ENABLED(POWER_LOSS_RECOVERY)
+
+    inline bool drain_job_recovery_commands() {
+      static uint8_t job_recovery_commands_index = 0; // Resets on reboot
+      if (job_recovery_commands_count) {
+        if (_enqueuecommand(job_recovery_commands[job_recovery_commands_index])) {
+          ++job_recovery_commands_index;
+          if (!--job_recovery_commands_count) job_recovery_phase = JOB_RECOVERY_IDLE;
+        }
+        return true;
+      }
+      return false;
+    }
+
+  #endif
+
 #endif // SDSUPPORT
 
 /**
@@ -501,6 +521,11 @@ void get_available_commands() {
 
   get_serial_commands();
 
+  #if ENABLED(POWER_LOSS_RECOVERY)
+    // Commands for power-loss recovery take precedence
+    if (job_recovery_phase == JOB_RECOVERY_YES && drain_job_recovery_commands()) return;
+  #endif
+
   #if ENABLED(SDSUPPORT)
     get_sdcard_commands();
   #endif
@@ -543,8 +568,12 @@ void advance_command_queue() {
           ok_to_send();
       }
     }
-    else
+    else {
       gcode.process_next_command();
+      #if ENABLED(POWER_LOSS_RECOVERY)
+        if (card.cardOK && card.sdprinting) save_job_recovery_info();
+      #endif
+    }
 
   #else
 

commit 78ea4871f9916e859e8a7b45cc8d62612d382fd8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Apr 19 18:11:03 2018 -0500

    Fix up enqueue now functions
    
    ‚Ä¶and apply to MALYAN_LCD.

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 169aa3add5..7ac8c7912e 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -176,14 +176,14 @@ void enqueue_and_echo_commands_P(const char * const pgcode) {
   /**
    * Enqueue and return only when commands are actually enqueued
    */
-  void enqueue_and_echo_command_now(const char* cmd, bool say_ok/*=false*/) {
-    while (!enqueue_and_echo_command(cmd, say_ok)) idle();
+  void enqueue_and_echo_command_now(const char* cmd) {
+    while (!enqueue_and_echo_command(cmd)) idle();
   }
   #if HAS_LCD_QUEUE_NOW
     /**
      * Enqueue from program memory and return only when commands are actually enqueued
      */
-    void enqueue_and_echo_commands_P_now(const char * const pgcode) {
+    void enqueue_and_echo_commands_now_P(const char * const pgcode) {
       enqueue_and_echo_commands_P(pgcode);
       while (drain_injected_commands_P()) idle();
     }

commit cea398849eee4e2bf16ce0a52eb94dc196a79d31
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Apr 7 21:25:39 2018 -0500

    Tweak to gcode_line_error/return

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 8ad6d842fc..169aa3add5 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -320,32 +320,24 @@ inline void get_serial_commands() {
 
           gcode_N = strtol(npos + 1, NULL, 10);
 
-          if (gcode_N != gcode_LastN + 1 && !M110) {
-            gcode_line_error(PSTR(MSG_ERR_LINE_NO), i);
-            return;
-          }
+          if (gcode_N != gcode_LastN + 1 && !M110)
+            return gcode_line_error(PSTR(MSG_ERR_LINE_NO), i);
 
           char *apos = strrchr(command, '*');
           if (apos) {
             uint8_t checksum = 0, count = uint8_t(apos - command);
             while (count) checksum ^= command[--count];
-            if (strtol(apos + 1, NULL, 10) != checksum) {
-              gcode_line_error(PSTR(MSG_ERR_CHECKSUM_MISMATCH), i);
-              return;
-            }
-          }
-          else {
-            gcode_line_error(PSTR(MSG_ERR_NO_CHECKSUM), i);
-            return;
+            if (strtol(apos + 1, NULL, 10) != checksum)
+              return gcode_line_error(PSTR(MSG_ERR_CHECKSUM_MISMATCH), i);
           }
+          else
+            return gcode_line_error(PSTR(MSG_ERR_NO_CHECKSUM), i);
 
           gcode_LastN = gcode_N;
         }
         #if ENABLED(SDSUPPORT)
-          else if (card.saving) {
-            gcode_line_error(PSTR(MSG_ERR_NO_CHECKSUM), i);
-            return;
-          }
+          else if (card.saving)
+            return gcode_line_error(PSTR(MSG_ERR_NO_CHECKSUM), i);
         #endif
 
         // Movement commands alert when stopped

commit 9e4c037cefe0d457b21867121e3371f3400c5473
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 28 22:59:28 2018 -0500

    Wait before turning off PRINTER_EVENT_LEDS at print end (#10248)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 1e7717ed1c..8ad6d842fc 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -449,12 +449,19 @@ inline void get_serial_commands() {
               LCD_MESSAGEPGM(MSG_INFO_COMPLETED_PRINTS);
               leds.set_green();
               #if HAS_RESUME_CONTINUE
-                enqueue_and_echo_commands_P(PSTR("M0")); // end of the queue!
+                gcode.lights_off_after_print = true;
+                enqueue_and_echo_commands_P(PSTR("M0 S"
+                  #if ENABLED(NEWPANEL)
+                    "1800"
+                  #else
+                    "60"
+                  #endif
+                ));
               #else
-                safe_delay(1000);
+                safe_delay(2000);
+                leds.set_off();
               #endif
-              leds.set_off();
-            #endif
+            #endif // PRINTER_EVENT_LEDS
             card.checkautostart(true);
           }
         }

commit 7b8bb2519e2e13f17267f0d5381380345d27ed08
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 28 20:29:27 2018 -0500

    Fix gcode_line_error call
    
    Followup to 3007eee

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 727b45ca39..1e7717ed1c 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -343,7 +343,7 @@ inline void get_serial_commands() {
         }
         #if ENABLED(SDSUPPORT)
           else if (card.saving) {
-            gcode_line_error(PSTR(MSG_ERR_NO_CHECKSUM));
+            gcode_line_error(PSTR(MSG_ERR_NO_CHECKSUM), i);
             return;
           }
         #endif

commit 3007eee22e837ad45c25213dfba4f706f0327e4a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 28 13:45:47 2018 -0500

    Require a checksum when writing to SD
    
    From #10204 by @adriancuzman

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 08ba22c43c..727b45ca39 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -341,6 +341,12 @@ inline void get_serial_commands() {
 
           gcode_LastN = gcode_N;
         }
+        #if ENABLED(SDSUPPORT)
+          else if (card.saving) {
+            gcode_line_error(PSTR(MSG_ERR_NO_CHECKSUM));
+            return;
+          }
+        #endif
 
         // Movement commands alert when stopped
         if (IsStopped()) {

commit 1cb810ff1c04065daa29182a6c22ecf6b0c0098b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 21 19:30:06 2018 -0500

    [2.0.x] Automatically reset stepper timeout (#10179)
    
    * Automatically reset stepper timeout in manage_inactivity
    
    Any code that adds moves to the planner can skip resetting the stepper timeout. We can let `idle` / `manage_inactivity` reset the timer whenever it detects any moves in the planner.
    
    * blocks_queued => has_blocks_queued

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index e3f4b0bf7a..08ba22c43c 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -204,7 +204,6 @@ void ok_to_send() {
     const int16_t port = command_queue_port[cmd_queue_index_r];
     if (port < 0) return;
   #endif
-  gcode.refresh_cmd_timeout();
   if (!send_ok[cmd_queue_index_r]) return;
   SERIAL_PROTOCOLPGM_P(port, MSG_OK);
   #if ENABLED(ADVANCED_OK)

commit bae1cb859c1f3610bd5aab33fef20797cffcc320
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 11 07:36:00 2018 -0500

    Patch flush_and_request_resend for 1.1.x parity

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 94b27abce2..e3f4b0bf7a 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -233,6 +233,7 @@ void flush_and_request_resend() {
   SERIAL_FLUSH_P(port);
   SERIAL_PROTOCOLPGM_P(port, MSG_RESEND);
   SERIAL_PROTOCOLLN_P(port, gcode_LastN + 1);
+  ok_to_send();
 }
 
 void gcode_line_error(const char* err, uint8_t port) {

commit 0d8c15c01f0ded7663d44af61aabf7dc9083c42f
Author: Bob-the-Kuhn <bob.kuhn@att.net>
Date:   Sat Mar 10 22:46:32 2018 -0600

    restore PR 9661 files & V1 fix

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 67471cb80e..94b27abce2 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -517,7 +517,7 @@ void advance_command_queue() {
         card.closefile();
         SERIAL_PROTOCOLLNPGM(MSG_FILE_SAVED);
 
-        #ifndef USBCON
+        #if !defined(__AVR__) || !defined(USBCON)
           #if ENABLED(SERIAL_STATS_DROPPED_RX)
             SERIAL_ECHOLNPAIR("Dropped bytes: ", customizedSerial.dropped());
           #endif
@@ -525,7 +525,7 @@ void advance_command_queue() {
           #if ENABLED(SERIAL_STATS_MAX_RX_QUEUED)
             SERIAL_ECHOLNPAIR("Max RX Queue Size: ", customizedSerial.rxMaxEnqueued());
           #endif
-        #endif // !USBCON
+        #endif //  !defined(__AVR__) || !defined(USBCON)
 
         ok_to_send();
       }

commit bf59a4a6df98f5d79f68848c5163621ebe24abbb
Author: Bob-the-Kuhn <bob.kuhn@att.net>
Date:   Sat Mar 10 17:22:20 2018 -0600

    Revert "[2.0.x] DUE compatibility with shared SPI LCDs, USB mass storage, add pin defs & update examples\MakerParts\Configuration.h"

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 94b27abce2..67471cb80e 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -517,7 +517,7 @@ void advance_command_queue() {
         card.closefile();
         SERIAL_PROTOCOLLNPGM(MSG_FILE_SAVED);
 
-        #if !defined(__AVR__) || !defined(USBCON)
+        #ifndef USBCON
           #if ENABLED(SERIAL_STATS_DROPPED_RX)
             SERIAL_ECHOLNPAIR("Dropped bytes: ", customizedSerial.dropped());
           #endif
@@ -525,7 +525,7 @@ void advance_command_queue() {
           #if ENABLED(SERIAL_STATS_MAX_RX_QUEUED)
             SERIAL_ECHOLNPAIR("Max RX Queue Size: ", customizedSerial.rxMaxEnqueued());
           #endif
-        #endif //  !defined(__AVR__) || !defined(USBCON)
+        #endif // !USBCON
 
         ok_to_send();
       }

commit 914bb80bdeff8f6f264204f4d7264d9ef2ee5932
Author: Bob-the-Kuhn <bob.kuhn@att.net>
Date:   Mon Mar 5 10:51:09 2018 -0600

    removed SDSS init
    
    added device & comm drivers for shared SPI LCDs
    
    mistyped some updates in ultralcd_impl_DOGM.h
    
    remove unwanted changes in onfiguration.h
    
    still can't type
    
    Update HAL_LCD_class_defines.h
    
    include USB mass storage & misc

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 67471cb80e..94b27abce2 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -517,7 +517,7 @@ void advance_command_queue() {
         card.closefile();
         SERIAL_PROTOCOLLNPGM(MSG_FILE_SAVED);
 
-        #ifndef USBCON
+        #if !defined(__AVR__) || !defined(USBCON)
           #if ENABLED(SERIAL_STATS_DROPPED_RX)
             SERIAL_ECHOLNPAIR("Dropped bytes: ", customizedSerial.dropped());
           #endif
@@ -525,7 +525,7 @@ void advance_command_queue() {
           #if ENABLED(SERIAL_STATS_MAX_RX_QUEUED)
             SERIAL_ECHOLNPAIR("Max RX Queue Size: ", customizedSerial.rxMaxEnqueued());
           #endif
-        #endif // !USBCON
+        #endif //  !defined(__AVR__) || !defined(USBCON)
 
         ok_to_send();
       }

commit da693a636e603512c3195a4e184117a63a532e06
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Feb 9 04:02:42 2018 -0600

    Fix handling of escapes in serial input

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 7aecaf3c04..67471cb80e 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -389,7 +389,7 @@ inline void get_serial_commands() {
       else if (serial_char == '\\') {  // Handle escapes
         // if we have one more character, copy it over
         if ((c = read_serial(i)) >= 0 && !serial_comment_mode[i])
-          serial_line_buffer[i][serial_count[i]++] = serial_char;
+          serial_line_buffer[i][serial_count[i]++] = (char)c;
       }
       else { // it's not a newline, carriage return or escape char
         if (serial_char == ';') serial_comment_mode[i] = true;

commit c30a8067ab7b108ff8c55ad3fb21be0618877363
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Feb 9 01:50:14 2018 -0600

    Prevent watchdog reset due to many comments
    
    Addressing #7449

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index ce619814a7..7aecaf3c04 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -30,6 +30,7 @@
 #include "../lcd/ultralcd.h"
 #include "../sd/cardreader.h"
 #include "../module/planner.h"
+#include "../module/temperature.h"
 #include "../Marlin.h"
 
 #if HAS_COLOR_LEDS
@@ -297,7 +298,8 @@ inline void get_serial_commands() {
 
         serial_comment_mode[i] = false;                   // end of line == end of comment
 
-        if (!serial_count[i]) continue;                   // Skip empty lines
+        // Skip empty lines and comments
+        if (!serial_count[i]) { thermalManager.manage_heater(); continue; }
 
         serial_line_buffer[i][serial_count[i]] = 0;       // Terminate string
         serial_count[i] = 0;                              // Reset buffer
@@ -458,7 +460,8 @@ inline void get_serial_commands() {
 
         sd_comment_mode = false; // for new command
 
-        if (!sd_count) continue; // skip empty lines (and comment lines)
+        // Skip empty lines and comments
+        if (!sd_count) { thermalManager.manage_heater(); continue; }
 
         command_queue[cmd_queue_index_w][sd_count] = '\0'; // terminate string
         sd_count = 0; // clear sd line buffer

commit b7053156fed8b492c3517ea6bf4986fcd9cdb433
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Feb 9 01:52:28 2018 -0600

    Minor comment/condition cleanup

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index d5ad43550a..ce619814a7 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -271,7 +271,7 @@ inline void get_serial_commands() {
 
   // If the command buffer is empty for too long,
   // send "wait" to indicate Marlin is still waiting.
-  #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0
+  #if NO_TIMEOUTS > 0
     static millis_t last_command_time = 0;
     const millis_t ms = millis();
     if (commands_in_queue == 0 && !serial_data_available() && ELAPSED(ms, last_command_time + NO_TIMEOUTS)) {

commit 09c8807a36cdbb777612431926ac8c528b0d84b5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Feb 8 01:31:19 2018 -0600

    Minor formatting in queue.cpp

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index f613ab1362..d5ad43550a 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -358,7 +358,7 @@ inline void get_serial_commands() {
         }
 
         #if DISABLED(EMERGENCY_PARSER)
-          // If command was e-stop process now
+          // Process critical commands early
           if (strcmp(command, "M108") == 0) {
             wait_for_heatup = false;
             #if ENABLED(ULTIPANEL)
@@ -366,7 +366,7 @@ inline void get_serial_commands() {
             #endif
           }
           if (strcmp(command, "M112") == 0) kill(PSTR(MSG_KILLED));
-          if (strcmp(command, "M410") == 0) { quickstop_stepper(); }
+          if (strcmp(command, "M410") == 0) quickstop_stepper();
         #endif
 
         #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0

commit bfd9728cf4c4adb426c926584f42501949ca74c8
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Thu Jan 18 19:57:18 2018 -0600

    Serial buffer over run work around for v2.0.0 (#9236)
    
    * Work around for serial buffer over run
    
    PronterFace sends a lot of M105 commands.  During long operations such
    as UBL's G29 P1, G29 P2, G29 P4 and G26 this can over run the serial
    buffer.   This results (very often) in a M1 (actually a M1M105) ending
    up in the command queue.
    
    Until we figure out a better way to resolve this issue, this will keep
    the UBL commands from experiencing bogus commands at thier completion.

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 8e5985e7ae..f613ab1362 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -90,8 +90,7 @@ void queue_setup() {
  * Clear the Marlin command queue
  */
 void clear_command_queue() {
-  cmd_queue_index_r = cmd_queue_index_w;
-  commands_in_queue = 0;
+  cmd_queue_index_r = cmd_queue_index_w = commands_in_queue = 0;
 }
 
 /**

commit 2c18faf3e48c970f3ef9f20e3a3cb4dc01394729
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jan 15 02:29:23 2018 -0600

    General cleanups for HAL

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 11fd46fa75..8e5985e7ae 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -254,7 +254,7 @@ static bool serial_data_available() {
 static int read_serial(const int index) {
   switch (index) {
     case 0: return MYSERIAL0.read();
-    #if NUM_SERIAL > 1 
+    #if NUM_SERIAL > 1
       case 1: return MYSERIAL1.read();
     #endif
     default: return -1;

commit f7efac57b7ac607405529a71b4e36a6545525c89
Author: Thomas Moore <tcm0116@gmail.com>
Date:   Sun Nov 5 08:49:38 2017 -0600

    Multi-host support

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 6a7916c538..11fd46fa75 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -58,12 +58,19 @@ uint8_t commands_in_queue = 0, // Count of commands in the queue
 
 char command_queue[BUFSIZE][MAX_CMD_SIZE];
 
+/*
+ * The port that the command was received on
+ */
+#if NUM_SERIAL > 1
+  int16_t command_queue_port[BUFSIZE];
+#endif
+
 /**
  * Serial command injection
  */
 
 // Number of characters read in the current line of serial input
-static int serial_count = 0;
+static int serial_count[NUM_SERIAL] = { 0 };
 
 bool send_ok[BUFSIZE];
 
@@ -90,8 +97,15 @@ void clear_command_queue() {
 /**
  * Once a new command is in the ring buffer, call this to commit it
  */
-inline void _commit_command(bool say_ok) {
+inline void _commit_command(bool say_ok
+  #if NUM_SERIAL > 1
+    , int16_t port = -1
+  #endif
+) {
   send_ok[cmd_queue_index_w] = say_ok;
+  #if NUM_SERIAL > 1
+    command_queue_port[cmd_queue_index_w] = port;
+  #endif
   if (++cmd_queue_index_w >= BUFSIZE) cmd_queue_index_w = 0;
   commands_in_queue++;
 }
@@ -101,10 +115,18 @@ inline void _commit_command(bool say_ok) {
  * Return true if the command was successfully added.
  * Return false for a full buffer, or if the 'command' is a comment.
  */
-inline bool _enqueuecommand(const char* cmd, bool say_ok/*=false*/) {
+inline bool _enqueuecommand(const char* cmd, bool say_ok
+  #if NUM_SERIAL > 1
+    , int16_t port = -1
+  #endif
+) {
   if (*cmd == ';' || commands_in_queue >= BUFSIZE) return false;
   strcpy(command_queue[cmd_queue_index_w], cmd);
-  _commit_command(say_ok);
+  _commit_command(say_ok
+    #if NUM_SERIAL > 1
+      , port
+    #endif
+  );
   return true;
 }
 
@@ -178,21 +200,25 @@ void enqueue_and_echo_commands_P(const char * const pgcode) {
  *   B<int>  Block queue space remaining
  */
 void ok_to_send() {
+  #if NUM_SERIAL > 1
+    const int16_t port = command_queue_port[cmd_queue_index_r];
+    if (port < 0) return;
+  #endif
   gcode.refresh_cmd_timeout();
   if (!send_ok[cmd_queue_index_r]) return;
-  SERIAL_PROTOCOLPGM(MSG_OK);
+  SERIAL_PROTOCOLPGM_P(port, MSG_OK);
   #if ENABLED(ADVANCED_OK)
     char* p = command_queue[cmd_queue_index_r];
     if (*p == 'N') {
-      SERIAL_PROTOCOL(' ');
-      SERIAL_ECHO(*p++);
+      SERIAL_PROTOCOL_P(port, ' ');
+      SERIAL_ECHO_P(port, *p++);
       while (NUMERIC_SIGNED(*p))
-        SERIAL_ECHO(*p++);
+        SERIAL_ECHO_P(port, *p++);
     }
-    SERIAL_PROTOCOLPGM(" P"); SERIAL_PROTOCOL(int(BLOCK_BUFFER_SIZE - planner.movesplanned() - 1));
-    SERIAL_PROTOCOLPGM(" B"); SERIAL_PROTOCOL(BUFSIZE - commands_in_queue);
+    SERIAL_PROTOCOLPGM_P(port, " P"); SERIAL_PROTOCOL_P(port, int(BLOCK_BUFFER_SIZE - planner.movesplanned() - 1));
+    SERIAL_PROTOCOLPGM_P(port, " B"); SERIAL_PROTOCOL_P(port, BUFSIZE - commands_in_queue);
   #endif
-  SERIAL_EOL();
+  SERIAL_EOL_P(port);
 }
 
 /**
@@ -200,20 +226,39 @@ void ok_to_send() {
  * indicate that a command needs to be re-sent.
  */
 void flush_and_request_resend() {
-  //char command_queue[cmd_queue_index_r][100]="Resend:";
-  MYSERIAL.flush();
-  SERIAL_PROTOCOLPGM(MSG_RESEND);
-  SERIAL_PROTOCOLLN(gcode_LastN + 1);
-  ok_to_send();
+  #if NUM_SERIAL > 1
+    const int16_t port = command_queue_port[cmd_queue_index_r];
+    if (port < 0) return;
+  #endif
+  SERIAL_FLUSH_P(port);
+  SERIAL_PROTOCOLPGM_P(port, MSG_RESEND);
+  SERIAL_PROTOCOLLN_P(port, gcode_LastN + 1);
 }
 
-void gcode_line_error(const char* err, bool doFlush = true) {
-  SERIAL_ERROR_START();
-  serialprintPGM(err);
-  SERIAL_ERRORLN(gcode_LastN);
-  //Serial.println(gcode_N);
-  if (doFlush) flush_and_request_resend();
-  serial_count = 0;
+void gcode_line_error(const char* err, uint8_t port) {
+  SERIAL_ERROR_START_P(port);
+  serialprintPGM_P(port, err);
+  SERIAL_ERRORLN_P(port, gcode_LastN);
+  flush_and_request_resend();
+  serial_count[port] = 0;
+}
+
+static bool serial_data_available() {
+  return (MYSERIAL0.available() ? true :
+    #if NUM_SERIAL > 1
+      MYSERIAL1.available() ? true :
+    #endif
+    false);
+}
+
+static int read_serial(const int index) {
+  switch (index) {
+    case 0: return MYSERIAL0.read();
+    #if NUM_SERIAL > 1 
+      case 1: return MYSERIAL1.read();
+    #endif
+    default: return -1;
+  }
 }
 
 /**
@@ -222,15 +267,15 @@ void gcode_line_error(const char* err, bool doFlush = true) {
  * left on the serial port.
  */
 inline void get_serial_commands() {
-  static char serial_line_buffer[MAX_CMD_SIZE];
-  static bool serial_comment_mode = false;
+  static char serial_line_buffer[NUM_SERIAL][MAX_CMD_SIZE];
+  static bool serial_comment_mode[NUM_SERIAL] = { false };
 
   // If the command buffer is empty for too long,
   // send "wait" to indicate Marlin is still waiting.
   #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0
     static millis_t last_command_time = 0;
     const millis_t ms = millis();
-    if (commands_in_queue == 0 && !MYSERIAL.available() && ELAPSED(ms, last_command_time + NO_TIMEOUTS)) {
+    if (commands_in_queue == 0 && !serial_data_available() && ELAPSED(ms, last_command_time + NO_TIMEOUTS)) {
       SERIAL_ECHOLNPGM(MSG_WAIT);
       last_command_time = ms;
     }
@@ -239,110 +284,117 @@ inline void get_serial_commands() {
   /**
    * Loop while serial characters are incoming and the queue is not full
    */
-  int c;
-  while (commands_in_queue < BUFSIZE && (c = MYSERIAL.read()) >= 0) {
-    char serial_char = c;
+  while (commands_in_queue < BUFSIZE && serial_data_available()) {
+    for (uint8_t i = 0; i < NUM_SERIAL; ++i) {
+      int c;
+      if ((c = read_serial(i)) < 0) continue;
 
-    /**
-     * If the character ends the line
-     */
-    if (serial_char == '\n' || serial_char == '\r') {
+      char serial_char = c;
 
-      serial_comment_mode = false;                      // end of line == end of comment
+      /**
+       * If the character ends the line
+       */
+      if (serial_char == '\n' || serial_char == '\r') {
 
-      if (!serial_count) continue;                      // Skip empty lines
+        serial_comment_mode[i] = false;                   // end of line == end of comment
 
-      serial_line_buffer[serial_count] = 0;             // Terminate string
-      serial_count = 0;                                 // Reset buffer
+        if (!serial_count[i]) continue;                   // Skip empty lines
 
-      char* command = serial_line_buffer;
+        serial_line_buffer[i][serial_count[i]] = 0;       // Terminate string
+        serial_count[i] = 0;                              // Reset buffer
 
-      while (*command == ' ') command++;                // Skip leading spaces
-      char *npos = (*command == 'N') ? command : NULL;  // Require the N parameter to start the line
+        char* command = serial_line_buffer[i];
 
-      if (npos) {
+        while (*command == ' ') command++;                // Skip leading spaces
+        char *npos = (*command == 'N') ? command : NULL;  // Require the N parameter to start the line
 
-        bool M110 = strstr_P(command, PSTR("M110")) != NULL;
+        if (npos) {
 
-        if (M110) {
-          char* n2pos = strchr(command + 4, 'N');
-          if (n2pos) npos = n2pos;
-        }
+          bool M110 = strstr_P(command, PSTR("M110")) != NULL;
 
-        gcode_N = strtol(npos + 1, NULL, 10);
+          if (M110) {
+            char* n2pos = strchr(command + 4, 'N');
+            if (n2pos) npos = n2pos;
+          }
 
-        if (gcode_N != gcode_LastN + 1 && !M110) {
-          gcode_line_error(PSTR(MSG_ERR_LINE_NO));
-          return;
-        }
+          gcode_N = strtol(npos + 1, NULL, 10);
 
-        char *apos = strrchr(command, '*');
-        if (apos) {
-          uint8_t checksum = 0, count = uint8_t(apos - command);
-          while (count) checksum ^= command[--count];
-          if (strtol(apos + 1, NULL, 10) != checksum) {
-            gcode_line_error(PSTR(MSG_ERR_CHECKSUM_MISMATCH));
+          if (gcode_N != gcode_LastN + 1 && !M110) {
+            gcode_line_error(PSTR(MSG_ERR_LINE_NO), i);
             return;
           }
-        }
-        else {
-          gcode_line_error(PSTR(MSG_ERR_NO_CHECKSUM));
-          return;
-        }
-
-        gcode_LastN = gcode_N;
-      }
 
-      // Movement commands alert when stopped
-      if (IsStopped()) {
-        char* gpos = strchr(command, 'G');
-        if (gpos) {
-          const int codenum = strtol(gpos + 1, NULL, 10);
-          switch (codenum) {
-            case 0:
-            case 1:
-            case 2:
-            case 3:
-              SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
-              LCD_MESSAGEPGM(MSG_STOPPED);
-              break;
+          char *apos = strrchr(command, '*');
+          if (apos) {
+            uint8_t checksum = 0, count = uint8_t(apos - command);
+            while (count) checksum ^= command[--count];
+            if (strtol(apos + 1, NULL, 10) != checksum) {
+              gcode_line_error(PSTR(MSG_ERR_CHECKSUM_MISMATCH), i);
+              return;
+            }
+          }
+          else {
+            gcode_line_error(PSTR(MSG_ERR_NO_CHECKSUM), i);
+            return;
           }
-        }
-      }
 
-      #if DISABLED(EMERGENCY_PARSER)
-        // If command was e-stop process now
-        if (strcmp(command, "M108") == 0) {
-          wait_for_heatup = false;
-          #if ENABLED(ULTIPANEL)
-            wait_for_user = false;
-          #endif
+          gcode_LastN = gcode_N;
         }
-        if (strcmp(command, "M112") == 0) kill(PSTR(MSG_KILLED));
-        if (strcmp(command, "M410") == 0) { quickstop_stepper(); }
-      #endif
-
-      #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0
-        last_command_time = ms;
-      #endif
 
-      // Add the command to the queue
-      _enqueuecommand(serial_line_buffer, true);
-    }
-    else if (serial_count >= MAX_CMD_SIZE - 1) {
-      // Keep fetching, but ignore normal characters beyond the max length
-      // The command will be injected when EOL is reached
-    }
-    else if (serial_char == '\\') {  // Handle escapes
-      // if we have one more character, copy it over
-      if ((c = MYSERIAL.read()) >= 0 && !serial_comment_mode)
-        serial_line_buffer[serial_count++] = serial_char;
-    }
-    else { // it's not a newline, carriage return or escape char
-      if (serial_char == ';') serial_comment_mode = true;
-      if (!serial_comment_mode) serial_line_buffer[serial_count++] = serial_char;
-    }
+        // Movement commands alert when stopped
+        if (IsStopped()) {
+          char* gpos = strchr(command, 'G');
+          if (gpos) {
+            const int codenum = strtol(gpos + 1, NULL, 10);
+            switch (codenum) {
+              case 0:
+              case 1:
+              case 2:
+              case 3:
+                SERIAL_ERRORLNPGM_P(i, MSG_ERR_STOPPED);
+                LCD_MESSAGEPGM(MSG_STOPPED);
+                break;
+            }
+          }
+        }
 
+        #if DISABLED(EMERGENCY_PARSER)
+          // If command was e-stop process now
+          if (strcmp(command, "M108") == 0) {
+            wait_for_heatup = false;
+            #if ENABLED(ULTIPANEL)
+              wait_for_user = false;
+            #endif
+          }
+          if (strcmp(command, "M112") == 0) kill(PSTR(MSG_KILLED));
+          if (strcmp(command, "M410") == 0) { quickstop_stepper(); }
+        #endif
+
+        #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0
+          last_command_time = ms;
+        #endif
+
+        // Add the command to the queue
+        _enqueuecommand(serial_line_buffer[i], true
+          #if NUM_SERIAL > 1
+            , i
+          #endif
+        );
+      }
+      else if (serial_count[i] >= MAX_CMD_SIZE - 1) {
+        // Keep fetching, but ignore normal characters beyond the max length
+        // The command will be injected when EOL is reached
+      }
+      else if (serial_char == '\\') {  // Handle escapes
+        // if we have one more character, copy it over
+        if ((c = read_serial(i)) >= 0 && !serial_comment_mode[i])
+          serial_line_buffer[i][serial_count[i]++] = serial_char;
+      }
+      else { // it's not a newline, carriage return or escape char
+        if (serial_char == ';') serial_comment_mode[i] = true;
+        if (!serial_comment_mode[i]) serial_line_buffer[i][serial_count[i]++] = serial_char;
+      }
+    } // for NUM_SERIAL
   } // queue has space, serial has data
 }
 

commit 554e577676fb506e40b391ed5b7e65d545b04ac4
Author: Dave Johnson <davejohnson3000@gmail.com>
Date:   Tue Jan 9 16:42:55 2018 -0800

    SERIAL_STATS_* features not supported on USBCON targets (#9127)

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index ab25fe5a49..6a7916c538 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -463,13 +463,15 @@ void advance_command_queue() {
         card.closefile();
         SERIAL_PROTOCOLLNPGM(MSG_FILE_SAVED);
 
-        #if ENABLED(SERIAL_STATS_DROPPED_RX)
-          SERIAL_ECHOLNPAIR("Dropped bytes: ", customizedSerial.dropped());
-        #endif
+        #ifndef USBCON
+          #if ENABLED(SERIAL_STATS_DROPPED_RX)
+            SERIAL_ECHOLNPAIR("Dropped bytes: ", customizedSerial.dropped());
+          #endif
 
-        #if ENABLED(SERIAL_STATS_MAX_RX_QUEUED)
-          SERIAL_ECHOLNPAIR("Max RX Queue Size: ", customizedSerial.rxMaxEnqueued());
-        #endif
+          #if ENABLED(SERIAL_STATS_MAX_RX_QUEUED)
+            SERIAL_ECHOLNPAIR("Max RX Queue Size: ", customizedSerial.rxMaxEnqueued());
+          #endif
+        #endif // !USBCON
 
         ok_to_send();
       }

commit 8afc4f8d9d629781f847b628ca1708e44be83725
Author: Thomas Moore <tcm0116@gmail.com>
Date:   Tue Jan 2 21:00:06 2018 -0600

    Fix UBL compilation warnings

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 9f404f9473..ab25fe5a49 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -147,9 +147,27 @@ static bool drain_injected_commands_P() {
  */
 void enqueue_and_echo_commands_P(const char * const pgcode) {
   injected_commands_P = pgcode;
-  drain_injected_commands_P(); // first command executed asap (when possible)
+  (void)drain_injected_commands_P(); // first command executed asap (when possible)
 }
 
+#if HAS_QUEUE_NOW
+  /**
+   * Enqueue and return only when commands are actually enqueued
+   */
+  void enqueue_and_echo_command_now(const char* cmd, bool say_ok/*=false*/) {
+    while (!enqueue_and_echo_command(cmd, say_ok)) idle();
+  }
+  #if HAS_LCD_QUEUE_NOW
+    /**
+     * Enqueue from program memory and return only when commands are actually enqueued
+     */
+    void enqueue_and_echo_commands_P_now(const char * const pgcode) {
+      enqueue_and_echo_commands_P(pgcode);
+      while (drain_injected_commands_P()) idle();
+    }
+  #endif
+#endif
+
 /**
  * Send an "ok" message to the host, indicating
  * that a command was successfully processed.

commit e37dd645488ffc4377b6ec818c1e38e55b5903b7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Nov 28 01:07:10 2017 -0600

    Apply LEDColor, language fixes

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 54614bc25e..9f404f9473 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -370,13 +370,13 @@ inline void get_serial_commands() {
             SERIAL_PROTOCOLLNPGM(MSG_FILE_PRINTED);
             #if ENABLED(PRINTER_EVENT_LEDS)
               LCD_MESSAGEPGM(MSG_INFO_COMPLETED_PRINTS);
-              set_led_color(0, 255, 0); // Green
+              leds.set_green();
               #if HAS_RESUME_CONTINUE
                 enqueue_and_echo_commands_P(PSTR("M0")); // end of the queue!
               #else
                 safe_delay(1000);
               #endif
-              set_led_color(0, 0, 0);   // OFF
+              leds.set_off();
             #endif
             card.checkautostart(true);
           }

commit e0d367f1fb12c57eca03df7994eeee629c0fea50
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Nov 15 00:15:57 2017 -0600

    Fix M32 P subroutine handling

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 9f104ce801..54614bc25e 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -361,19 +361,25 @@ inline void get_serial_commands() {
           || ((sd_char == '#' || sd_char == ':') && !sd_comment_mode)
       ) {
         if (card_eof) {
-          SERIAL_PROTOCOLLNPGM(MSG_FILE_PRINTED);
+
           card.printingHasFinished();
-          #if ENABLED(PRINTER_EVENT_LEDS)
-            LCD_MESSAGEPGM(MSG_INFO_COMPLETED_PRINTS);
-            set_led_color(0, 255, 0); // Green
-            #if HAS_RESUME_CONTINUE
-              enqueue_and_echo_commands_P(PSTR("M0")); // end of the queue!
-            #else
-              safe_delay(1000);
+
+          if (card.sdprinting)
+            sd_count = 0; // If a sub-file was printing, continue from call point
+          else {
+            SERIAL_PROTOCOLLNPGM(MSG_FILE_PRINTED);
+            #if ENABLED(PRINTER_EVENT_LEDS)
+              LCD_MESSAGEPGM(MSG_INFO_COMPLETED_PRINTS);
+              set_led_color(0, 255, 0); // Green
+              #if HAS_RESUME_CONTINUE
+                enqueue_and_echo_commands_P(PSTR("M0")); // end of the queue!
+              #else
+                safe_delay(1000);
+              #endif
+              set_led_color(0, 0, 0);   // OFF
             #endif
-            set_led_color(0, 0, 0);   // OFF
-          #endif
-          card.checkautostart(true);
+            card.checkautostart(true);
+          }
         }
         else if (n == -1) {
           SERIAL_ERROR_START();

commit 0108d5181f3eb13df4297972cc95184e292ba1b4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Oct 31 21:19:24 2017 -0500

    Allow asterisks in G-Code commands
    
    Addressing #6655

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index fd28d20cfe..9f104ce801 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -230,18 +230,17 @@ inline void get_serial_commands() {
      */
     if (serial_char == '\n' || serial_char == '\r') {
 
-      serial_comment_mode = false; // end of line == end of comment
+      serial_comment_mode = false;                      // end of line == end of comment
 
-      if (!serial_count) continue; // skip empty lines
+      if (!serial_count) continue;                      // Skip empty lines
 
-      serial_line_buffer[serial_count] = 0; // terminate string
-      serial_count = 0; //reset buffer
+      serial_line_buffer[serial_count] = 0;             // Terminate string
+      serial_count = 0;                                 // Reset buffer
 
       char* command = serial_line_buffer;
 
-      while (*command == ' ') command++; // skip any leading spaces
-      char *npos = (*command == 'N') ? command : NULL, // Require the N parameter to start the line
-           *apos = strchr(command, '*');
+      while (*command == ' ') command++;                // Skip leading spaces
+      char *npos = (*command == 'N') ? command : NULL;  // Require the N parameter to start the line
 
       if (npos) {
 
@@ -259,15 +258,14 @@ inline void get_serial_commands() {
           return;
         }
 
+        char *apos = strrchr(command, '*');
         if (apos) {
-          byte checksum = 0, count = 0;
-          while (command[count] != '*') checksum ^= command[count++];
-
+          uint8_t checksum = 0, count = uint8_t(apos - command);
+          while (count) checksum ^= command[--count];
           if (strtol(apos + 1, NULL, 10) != checksum) {
             gcode_line_error(PSTR(MSG_ERR_CHECKSUM_MISMATCH));
             return;
           }
-          // if no errors, continue parsing
         }
         else {
           gcode_line_error(PSTR(MSG_ERR_NO_CHECKSUM));
@@ -275,11 +273,6 @@ inline void get_serial_commands() {
         }
 
         gcode_LastN = gcode_N;
-        // if no errors, continue parsing
-      }
-      else if (apos) { // No '*' without 'N'
-        gcode_line_error(PSTR(MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM), false);
-        return;
       }
 
       // Movement commands alert when stopped

commit 508d764d63c26376683eb1de7ef9c0f8f1d19abf
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Oct 2 02:47:30 2017 -0500

    Add serial XON/XOFF handshaking
    
    From @ejtagle, originally #7459

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 09c49933a6..fd28d20cfe 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -221,9 +221,9 @@ inline void get_serial_commands() {
   /**
    * Loop while serial characters are incoming and the queue is not full
    */
-  while (commands_in_queue < BUFSIZE && MYSERIAL.available() > 0) {
-
-    char serial_char = MYSERIAL.read();
+  int c;
+  while (commands_in_queue < BUFSIZE && (c = MYSERIAL.read()) >= 0) {
+    char serial_char = c;
 
     /**
      * If the character ends the line
@@ -323,12 +323,9 @@ inline void get_serial_commands() {
       // The command will be injected when EOL is reached
     }
     else if (serial_char == '\\') {  // Handle escapes
-      if (MYSERIAL.available() > 0) {
-        // if we have one more character, copy it over
-        serial_char = MYSERIAL.read();
-        if (!serial_comment_mode) serial_line_buffer[serial_count++] = serial_char;
-      }
-      // otherwise do nothing
+      // if we have one more character, copy it over
+      if ((c = MYSERIAL.read()) >= 0 && !serial_comment_mode)
+        serial_line_buffer[serial_count++] = serial_char;
     }
     else { // it's not a newline, carriage return or escape char
       if (serial_char == ';') serial_comment_mode = true;
@@ -448,6 +445,15 @@ void advance_command_queue() {
         // M29 closes the file
         card.closefile();
         SERIAL_PROTOCOLLNPGM(MSG_FILE_SAVED);
+
+        #if ENABLED(SERIAL_STATS_DROPPED_RX)
+          SERIAL_ECHOLNPAIR("Dropped bytes: ", customizedSerial.dropped());
+        #endif
+
+        #if ENABLED(SERIAL_STATS_MAX_RX_QUEUED)
+          SERIAL_ECHOLNPAIR("Max RX Queue Size: ", customizedSerial.rxMaxEnqueued());
+        #endif
+
         ok_to_send();
       }
       else {

commit 8fbb833de9309c53abb73dba7d33b76f0068c61a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Sep 8 14:47:47 2017 -0500

    Encapsulate RGB(W) LEDs

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
index 6af72c949a..09c49933a6 100644
--- a/Marlin/src/gcode/queue.cpp
+++ b/Marlin/src/gcode/queue.cpp
@@ -32,6 +32,10 @@
 #include "../module/planner.h"
 #include "../Marlin.h"
 
+#if HAS_COLOR_LEDS
+  #include "../feature/leds/leds.h"
+#endif
+
 /**
  * GCode line number handling. Hosts may opt to include line numbers when
  * sending commands to Marlin, and lines will be checked for sequentiality.

commit 722786966ad284a708502d18ac5daad02012bfc8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Sep 7 22:33:16 2017 -0500

    Add gcode.cpp, motion.*, queue.* - Apply to some G-codes.

diff --git a/Marlin/src/gcode/queue.cpp b/Marlin/src/gcode/queue.cpp
new file mode 100644
index 0000000000..6af72c949a
--- /dev/null
+++ b/Marlin/src/gcode/queue.cpp
@@ -0,0 +1,473 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * queue.cpp - The G-code command queue
+ */
+
+#include "queue.h"
+#include "gcode.h"
+
+#include "../lcd/ultralcd.h"
+#include "../sd/cardreader.h"
+#include "../module/planner.h"
+#include "../Marlin.h"
+
+/**
+ * GCode line number handling. Hosts may opt to include line numbers when
+ * sending commands to Marlin, and lines will be checked for sequentiality.
+ * M110 N<int> sets the current line number.
+ */
+long gcode_N, gcode_LastN, Stopped_gcode_LastN = 0;
+
+/**
+ * GCode Command Queue
+ * A simple ring buffer of BUFSIZE command strings.
+ *
+ * Commands are copied into this buffer by the command injectors
+ * (immediate, serial, sd card) and they are processed sequentially by
+ * the main loop. The gcode.process_next_command method parses the next
+ * command and hands off execution to individual handler functions.
+ */
+uint8_t commands_in_queue = 0, // Count of commands in the queue
+        cmd_queue_index_r = 0, // Ring buffer read position
+        cmd_queue_index_w = 0; // Ring buffer write position
+
+char command_queue[BUFSIZE][MAX_CMD_SIZE];
+
+/**
+ * Serial command injection
+ */
+
+// Number of characters read in the current line of serial input
+static int serial_count = 0;
+
+bool send_ok[BUFSIZE];
+
+/**
+ * Next Injected Command pointer. NULL if no commands are being injected.
+ * Used by Marlin internally to ensure that commands initiated from within
+ * are enqueued ahead of any pending serial or sd card commands.
+ */
+static const char *injected_commands_P = NULL;
+
+void queue_setup() {
+  // Send "ok" after commands by default
+  for (uint8_t i = 0; i < COUNT(send_ok); i++) send_ok[i] = true;
+}
+
+/**
+ * Clear the Marlin command queue
+ */
+void clear_command_queue() {
+  cmd_queue_index_r = cmd_queue_index_w;
+  commands_in_queue = 0;
+}
+
+/**
+ * Once a new command is in the ring buffer, call this to commit it
+ */
+inline void _commit_command(bool say_ok) {
+  send_ok[cmd_queue_index_w] = say_ok;
+  if (++cmd_queue_index_w >= BUFSIZE) cmd_queue_index_w = 0;
+  commands_in_queue++;
+}
+
+/**
+ * Copy a command from RAM into the main command buffer.
+ * Return true if the command was successfully added.
+ * Return false for a full buffer, or if the 'command' is a comment.
+ */
+inline bool _enqueuecommand(const char* cmd, bool say_ok/*=false*/) {
+  if (*cmd == ';' || commands_in_queue >= BUFSIZE) return false;
+  strcpy(command_queue[cmd_queue_index_w], cmd);
+  _commit_command(say_ok);
+  return true;
+}
+
+/**
+ * Enqueue with Serial Echo
+ */
+bool enqueue_and_echo_command(const char* cmd, bool say_ok/*=false*/) {
+  if (_enqueuecommand(cmd, say_ok)) {
+    SERIAL_ECHO_START();
+    SERIAL_ECHOPAIR(MSG_ENQUEUEING, cmd);
+    SERIAL_CHAR('"');
+    SERIAL_EOL();
+    return true;
+  }
+  return false;
+}
+
+/**
+ * Inject the next "immediate" command, when possible, onto the front of the queue.
+ * Return true if any immediate commands remain to inject.
+ */
+static bool drain_injected_commands_P() {
+  if (injected_commands_P != NULL) {
+    size_t i = 0;
+    char c, cmd[30];
+    strncpy_P(cmd, injected_commands_P, sizeof(cmd) - 1);
+    cmd[sizeof(cmd) - 1] = '\0';
+    while ((c = cmd[i]) && c != '\n') i++; // find the end of this gcode command
+    cmd[i] = '\0';
+    if (enqueue_and_echo_command(cmd))     // success?
+      injected_commands_P = c ? injected_commands_P + i + 1 : NULL; // next command or done
+  }
+  return (injected_commands_P != NULL);    // return whether any more remain
+}
+
+/**
+ * Record one or many commands to run from program memory.
+ * Aborts the current queue, if any.
+ * Note: drain_injected_commands_P() must be called repeatedly to drain the commands afterwards
+ */
+void enqueue_and_echo_commands_P(const char * const pgcode) {
+  injected_commands_P = pgcode;
+  drain_injected_commands_P(); // first command executed asap (when possible)
+}
+
+/**
+ * Send an "ok" message to the host, indicating
+ * that a command was successfully processed.
+ *
+ * If ADVANCED_OK is enabled also include:
+ *   N<int>  Line number of the command, if any
+ *   P<int>  Planner space remaining
+ *   B<int>  Block queue space remaining
+ */
+void ok_to_send() {
+  gcode.refresh_cmd_timeout();
+  if (!send_ok[cmd_queue_index_r]) return;
+  SERIAL_PROTOCOLPGM(MSG_OK);
+  #if ENABLED(ADVANCED_OK)
+    char* p = command_queue[cmd_queue_index_r];
+    if (*p == 'N') {
+      SERIAL_PROTOCOL(' ');
+      SERIAL_ECHO(*p++);
+      while (NUMERIC_SIGNED(*p))
+        SERIAL_ECHO(*p++);
+    }
+    SERIAL_PROTOCOLPGM(" P"); SERIAL_PROTOCOL(int(BLOCK_BUFFER_SIZE - planner.movesplanned() - 1));
+    SERIAL_PROTOCOLPGM(" B"); SERIAL_PROTOCOL(BUFSIZE - commands_in_queue);
+  #endif
+  SERIAL_EOL();
+}
+
+/**
+ * Send a "Resend: nnn" message to the host to
+ * indicate that a command needs to be re-sent.
+ */
+void flush_and_request_resend() {
+  //char command_queue[cmd_queue_index_r][100]="Resend:";
+  MYSERIAL.flush();
+  SERIAL_PROTOCOLPGM(MSG_RESEND);
+  SERIAL_PROTOCOLLN(gcode_LastN + 1);
+  ok_to_send();
+}
+
+void gcode_line_error(const char* err, bool doFlush = true) {
+  SERIAL_ERROR_START();
+  serialprintPGM(err);
+  SERIAL_ERRORLN(gcode_LastN);
+  //Serial.println(gcode_N);
+  if (doFlush) flush_and_request_resend();
+  serial_count = 0;
+}
+
+/**
+ * Get all commands waiting on the serial port and queue them.
+ * Exit when the buffer is full or when no more characters are
+ * left on the serial port.
+ */
+inline void get_serial_commands() {
+  static char serial_line_buffer[MAX_CMD_SIZE];
+  static bool serial_comment_mode = false;
+
+  // If the command buffer is empty for too long,
+  // send "wait" to indicate Marlin is still waiting.
+  #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0
+    static millis_t last_command_time = 0;
+    const millis_t ms = millis();
+    if (commands_in_queue == 0 && !MYSERIAL.available() && ELAPSED(ms, last_command_time + NO_TIMEOUTS)) {
+      SERIAL_ECHOLNPGM(MSG_WAIT);
+      last_command_time = ms;
+    }
+  #endif
+
+  /**
+   * Loop while serial characters are incoming and the queue is not full
+   */
+  while (commands_in_queue < BUFSIZE && MYSERIAL.available() > 0) {
+
+    char serial_char = MYSERIAL.read();
+
+    /**
+     * If the character ends the line
+     */
+    if (serial_char == '\n' || serial_char == '\r') {
+
+      serial_comment_mode = false; // end of line == end of comment
+
+      if (!serial_count) continue; // skip empty lines
+
+      serial_line_buffer[serial_count] = 0; // terminate string
+      serial_count = 0; //reset buffer
+
+      char* command = serial_line_buffer;
+
+      while (*command == ' ') command++; // skip any leading spaces
+      char *npos = (*command == 'N') ? command : NULL, // Require the N parameter to start the line
+           *apos = strchr(command, '*');
+
+      if (npos) {
+
+        bool M110 = strstr_P(command, PSTR("M110")) != NULL;
+
+        if (M110) {
+          char* n2pos = strchr(command + 4, 'N');
+          if (n2pos) npos = n2pos;
+        }
+
+        gcode_N = strtol(npos + 1, NULL, 10);
+
+        if (gcode_N != gcode_LastN + 1 && !M110) {
+          gcode_line_error(PSTR(MSG_ERR_LINE_NO));
+          return;
+        }
+
+        if (apos) {
+          byte checksum = 0, count = 0;
+          while (command[count] != '*') checksum ^= command[count++];
+
+          if (strtol(apos + 1, NULL, 10) != checksum) {
+            gcode_line_error(PSTR(MSG_ERR_CHECKSUM_MISMATCH));
+            return;
+          }
+          // if no errors, continue parsing
+        }
+        else {
+          gcode_line_error(PSTR(MSG_ERR_NO_CHECKSUM));
+          return;
+        }
+
+        gcode_LastN = gcode_N;
+        // if no errors, continue parsing
+      }
+      else if (apos) { // No '*' without 'N'
+        gcode_line_error(PSTR(MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM), false);
+        return;
+      }
+
+      // Movement commands alert when stopped
+      if (IsStopped()) {
+        char* gpos = strchr(command, 'G');
+        if (gpos) {
+          const int codenum = strtol(gpos + 1, NULL, 10);
+          switch (codenum) {
+            case 0:
+            case 1:
+            case 2:
+            case 3:
+              SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
+              LCD_MESSAGEPGM(MSG_STOPPED);
+              break;
+          }
+        }
+      }
+
+      #if DISABLED(EMERGENCY_PARSER)
+        // If command was e-stop process now
+        if (strcmp(command, "M108") == 0) {
+          wait_for_heatup = false;
+          #if ENABLED(ULTIPANEL)
+            wait_for_user = false;
+          #endif
+        }
+        if (strcmp(command, "M112") == 0) kill(PSTR(MSG_KILLED));
+        if (strcmp(command, "M410") == 0) { quickstop_stepper(); }
+      #endif
+
+      #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0
+        last_command_time = ms;
+      #endif
+
+      // Add the command to the queue
+      _enqueuecommand(serial_line_buffer, true);
+    }
+    else if (serial_count >= MAX_CMD_SIZE - 1) {
+      // Keep fetching, but ignore normal characters beyond the max length
+      // The command will be injected when EOL is reached
+    }
+    else if (serial_char == '\\') {  // Handle escapes
+      if (MYSERIAL.available() > 0) {
+        // if we have one more character, copy it over
+        serial_char = MYSERIAL.read();
+        if (!serial_comment_mode) serial_line_buffer[serial_count++] = serial_char;
+      }
+      // otherwise do nothing
+    }
+    else { // it's not a newline, carriage return or escape char
+      if (serial_char == ';') serial_comment_mode = true;
+      if (!serial_comment_mode) serial_line_buffer[serial_count++] = serial_char;
+    }
+
+  } // queue has space, serial has data
+}
+
+#if ENABLED(SDSUPPORT)
+
+  /**
+   * Get commands from the SD Card until the command buffer is full
+   * or until the end of the file is reached. The special character '#'
+   * can also interrupt buffering.
+   */
+  inline void get_sdcard_commands() {
+    static bool stop_buffering = false,
+                sd_comment_mode = false;
+
+    if (!IS_SD_PRINTING) return;
+
+    /**
+     * '#' stops reading from SD to the buffer prematurely, so procedural
+     * macro calls are possible. If it occurs, stop_buffering is triggered
+     * and the buffer is run dry; this character _can_ occur in serial com
+     * due to checksums, however, no checksums are used in SD printing.
+     */
+
+    if (commands_in_queue == 0) stop_buffering = false;
+
+    uint16_t sd_count = 0;
+    bool card_eof = card.eof();
+    while (commands_in_queue < BUFSIZE && !card_eof && !stop_buffering) {
+      const int16_t n = card.get();
+      char sd_char = (char)n;
+      card_eof = card.eof();
+      if (card_eof || n == -1
+          || sd_char == '\n' || sd_char == '\r'
+          || ((sd_char == '#' || sd_char == ':') && !sd_comment_mode)
+      ) {
+        if (card_eof) {
+          SERIAL_PROTOCOLLNPGM(MSG_FILE_PRINTED);
+          card.printingHasFinished();
+          #if ENABLED(PRINTER_EVENT_LEDS)
+            LCD_MESSAGEPGM(MSG_INFO_COMPLETED_PRINTS);
+            set_led_color(0, 255, 0); // Green
+            #if HAS_RESUME_CONTINUE
+              enqueue_and_echo_commands_P(PSTR("M0")); // end of the queue!
+            #else
+              safe_delay(1000);
+            #endif
+            set_led_color(0, 0, 0);   // OFF
+          #endif
+          card.checkautostart(true);
+        }
+        else if (n == -1) {
+          SERIAL_ERROR_START();
+          SERIAL_ECHOLNPGM(MSG_SD_ERR_READ);
+        }
+        if (sd_char == '#') stop_buffering = true;
+
+        sd_comment_mode = false; // for new command
+
+        if (!sd_count) continue; // skip empty lines (and comment lines)
+
+        command_queue[cmd_queue_index_w][sd_count] = '\0'; // terminate string
+        sd_count = 0; // clear sd line buffer
+
+        _commit_command(false);
+      }
+      else if (sd_count >= MAX_CMD_SIZE - 1) {
+        /**
+         * Keep fetching, but ignore normal characters beyond the max length
+         * The command will be injected when EOL is reached
+         */
+      }
+      else {
+        if (sd_char == ';') sd_comment_mode = true;
+        if (!sd_comment_mode) command_queue[cmd_queue_index_w][sd_count++] = sd_char;
+      }
+    }
+  }
+
+#endif // SDSUPPORT
+
+/**
+ * Add to the circular command queue the next command from:
+ *  - The command-injection queue (injected_commands_P)
+ *  - The active serial input (usually USB)
+ *  - The SD card file being actively printed
+ */
+void get_available_commands() {
+
+  // if any immediate commands remain, don't get other commands yet
+  if (drain_injected_commands_P()) return;
+
+  get_serial_commands();
+
+  #if ENABLED(SDSUPPORT)
+    get_sdcard_commands();
+  #endif
+}
+
+/**
+ * Get the next command in the queue, optionally log it to SD, then dispatch it
+ */
+void advance_command_queue() {
+
+  if (!commands_in_queue) return;
+
+  #if ENABLED(SDSUPPORT)
+
+    if (card.saving) {
+      char* command = command_queue[cmd_queue_index_r];
+      if (strstr_P(command, PSTR("M29"))) {
+        // M29 closes the file
+        card.closefile();
+        SERIAL_PROTOCOLLNPGM(MSG_FILE_SAVED);
+        ok_to_send();
+      }
+      else {
+        // Write the string from the read buffer to SD
+        card.write_command(command);
+        if (card.logging)
+          gcode.process_next_command(); // The card is saving because it's logging
+        else
+          ok_to_send();
+      }
+    }
+    else
+      gcode.process_next_command();
+
+  #else
+
+    gcode.process_next_command();
+
+  #endif // SDSUPPORT
+
+  // The queue may be reset by a command handler or by code invoked by idle() within a handler
+  if (commands_in_queue) {
+    --commands_in_queue;
+    if (++cmd_queue_index_r >= BUFSIZE) cmd_queue_index_r = 0;
+  }
+
+}
