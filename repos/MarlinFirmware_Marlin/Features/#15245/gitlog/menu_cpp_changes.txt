commit 4aa48beb378fec6a6e7de0c8c3c7fe47f6551c24
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Feb 7 18:25:13 2024 -0600

    üö∏ Adjust encoder multiplier

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index e98c9b48c0..892af5dbab 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -222,6 +222,7 @@ void MarlinUI::goto_screen(screenFunc_t screen, const uint16_t encoder/*=0*/, co
     TERN_(HAS_MARLINUI_U8GLIB, drawing_screen = false);
 
     TERN_(HAS_MARLINUI_MENU, encoder_direction_normal());
+    enable_encoder_multiplier(false);
 
     set_selection(false);
   }
@@ -255,7 +256,6 @@ void MarlinUI::synchronize(FSTR_P const fmsg/*=nullptr*/) {
  */
 void scroll_screen(const uint8_t limit, const bool is_menu) {
   ui.encoder_direction_menus();
-  ENCODER_RATE_MULTIPLY(false);
   if (int32_t(ui.encoderPosition) < 0) ui.encoderPosition = 0;
   if (ui.first_page) {
     encoderLine = ui.encoderPosition / (ENCODER_STEPS_PER_MENU_ITEM);

commit 1dee4d92c61b14458cd394d1f609f0dc80282092
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Feb 4 12:09:08 2024 -0600

    üîß TOUCH_IDLE_SLEEP_MINS => DISPLAY_SLEEP_MINUTES
    
    Follow up to #26517

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 1c77d9a092..e98c9b48c0 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -168,6 +168,9 @@ void MenuEditItemBase::goto_edit_screen(
  */
 void MarlinUI::goto_screen(screenFunc_t screen, const uint16_t encoder/*=0*/, const uint8_t top/*=0*/, const uint8_t items/*=0*/) {
   if (currentScreen != screen) {
+
+    wake_display();
+
     thermalManager.set_menu_cold_override(false);
 
     TERN_(IS_DWIN_MARLINUI, did_first_redraw = false);

commit cb044d989c397fcbf6f106502df69a7e5c41d34b
Author: Vladimir Sitnikov <sitnikov.vladimir@gmail.com>
Date:   Sun Nov 5 09:46:57 2023 +0300

    ‚ú® Probe XY Offset value limits (#26267)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index a4eab8fc9d..1c77d9a092 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -298,7 +298,7 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
                     , do_probe ? new_probe_offset : hotend_offset[active_extruder].z - diff
                     , new_probe_offset
                   );
-      if (WITHIN(new_offs, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
+      if (WITHIN(new_offs, PROBE_OFFSET_ZMIN, PROBE_OFFSET_ZMAX)) {
 
         babystep.add_steps(Z_AXIS, babystep_increment);
 

commit 2a88e7600298fef27e8cbbe01b708959515677fb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Oct 25 19:41:32 2023 -0500

    üßë‚Äçüíª Misc. LCD / string updates

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index a9574dd4d9..a4eab8fc9d 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -352,13 +352,13 @@ bool MarlinUI::update_selection() {
 void MenuItem_confirm::select_screen(
   FSTR_P const yes, FSTR_P const no,
   selectFunc_t yesFunc, selectFunc_t noFunc,
-  FSTR_P const pref, const char * const string/*=nullptr*/, FSTR_P const suff/*=nullptr*/
+  FSTR_P const fpre, const char * const string/*=nullptr*/, FSTR_P const fsuf/*=nullptr*/
 ) {
   ui.defer_status_screen();
   const bool ui_selection = !yes ? false : !no || ui.update_selection(),
              got_click = ui.use_click();
   if (got_click || ui.should_draw()) {
-    draw_select_screen(yes, no, ui_selection, pref, string, suff);
+    draw_select_screen(yes, no, ui_selection, fpre, string, fsuf);
     if (got_click) {
       selectFunc_t callFunc = ui_selection ? yesFunc : noFunc;
       if (callFunc) callFunc(); else ui.goto_previous_screen();

commit 2691167afe02fbbe74b0fdca2c28a49fac635741
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:26:02 2023 -0500

    üßë‚Äçüíª Dump BOTH and EITHER macros (#25908)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 911a35d482..a9574dd4d9 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -176,7 +176,7 @@ void MarlinUI::goto_screen(screenFunc_t screen, const uint16_t encoder/*=0*/, co
 
     TERN_(SET_PROGRESS_PERCENT, progress_reset());
 
-    #if BOTH(DOUBLECLICK_FOR_Z_BABYSTEPPING, BABYSTEPPING)
+    #if ALL(DOUBLECLICK_FOR_Z_BABYSTEPPING, BABYSTEPPING)
       static millis_t doubleclick_expire_ms = 0;
       // Going to menu_main from status screen? Remember first click time.
       // Going back to status screen within a very short time? Go to Z babystepping.

commit 40aa39828598108d519a536d6735354a500a31c6
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Sun May 14 09:43:57 2023 +1200

    üêõ Fix large edit value to encoder conversion (#25812)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 5c4dc12d26..911a35d482 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -138,7 +138,7 @@ void MenuEditItemBase::goto_edit_screen(
   void * const ev,        // Edit value pointer
   const int32_t minv,     // Encoder minimum
   const int32_t maxv,     // Encoder maximum
-  const uint16_t ep,      // Initial encoder value
+  const uint32_t ep,      // Initial encoder value
   const screenFunc_t cs,  // MenuItem_type::draw_edit_screen => MenuEditItemBase::edit()
   const screenFunc_t cb,  // Callback after edit
   const bool le           // Flag to call cb() during editing

commit 5d8d38a911f96dadd56471f6dacaa6bda64b66fb
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Sun Apr 23 08:59:51 2023 +1200

    ü©π Status / Host Prompt followup (#25720)
    
    Followup to #25679
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 85b773bebc..5c4dc12d26 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -271,13 +271,6 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
     encoderTopLine = encoderLine;
 }
 
-#if HAS_SOUND
-  void MarlinUI::completion_feedback(const bool good/*=true*/) {
-    TERN_(HAS_TOUCH_SLEEP, wakeup_screen()); // Wake up on rotary encoder click...
-    if (good) OKAY_BUZZ(); else ERR_BUZZ();
-  }
-#endif
-
 #if HAS_LINE_TO_Z
 
   void line_to_z(const_float_t z) {

commit 10983d0cfe3e353ba465cfcadf8aeb51327f1197
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 15 00:29:37 2023 -0500

    üé® Misc. tramming menu cleanup (#25519)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index c529ae757a..85b773bebc 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -48,7 +48,7 @@
 ////////////////////////////////////////////
 
 #if HAS_LEVELING && ANY(LCD_BED_TRAMMING, PROBE_OFFSET_WIZARD, X_AXIS_TWIST_COMPENSATION)
-  bool leveling_was_active; // = false
+  bool menu_leveling_was_active; // = false
 #endif
 #if ANY(PROBE_MANUALLY, MESH_BED_LEVELING, X_AXIS_TWIST_COMPENSATION)
   uint8_t manual_probe_index; // = 0

commit c5d5c375fdee7c4912b22e717caa82465ce6ccf4
Author: Gu√∞ni M√°r Gilbert <gudni.m.g@gmail.com>
Date:   Fri Feb 24 03:29:47 2023 +0000

    ‚ö°Ô∏è Reduce edit_screen code size (#25420)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 7f55f79f03..c529ae757a 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -117,8 +117,7 @@ void MenuEditItemBase::edit_screen(strfunc_t strfunc, loadfunc_t loadfunc) {
   // Reset repeat_delay for Touch Buttons
   TERN_(HAS_TOUCH_BUTTONS, ui.repeat_delay = BUTTON_DELAY_EDIT);
   // Constrain ui.encoderPosition to 0 ... maxEditValue (calculated in encoder steps)
-  if (int32_t(ui.encoderPosition) < 0) ui.encoderPosition = 0;
-  if (int32_t(ui.encoderPosition) > maxEditValue) ui.encoderPosition = maxEditValue;
+  ui.encoderPosition = constrain(int32_t(ui.encoderPosition), 0, maxEditValue);
   // If drawing is flagged then redraw the (whole) edit screen
   if (ui.should_draw())
     draw_edit_screen(strfunc(ui.encoderPosition + minEditValue));

commit 96bc084f3d791bc93265f217181986863e8e5fc7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Feb 18 02:15:16 2023 -0600

    üé® Misc. LCD cleanup (#25400)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 6389383d28..7f55f79f03 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -321,7 +321,7 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
     if (ui.should_draw()) {
       if (do_probe) {
         MenuEditItemBase::draw_edit_screen(GET_TEXT_F(MSG_ZPROBE_ZOFFSET), BABYSTEP_TO_STR(probe.offset.z));
-        TERN_(BABYSTEP_ZPROBE_GFX_OVERLAY, ui.zoffset_overlay(probe.offset.z));
+        TERN_(BABYSTEP_GFX_OVERLAY, ui.zoffset_overlay(probe.offset.z));
       }
       else {
         #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)

commit 81f88fefdc1d32fade897ddd0daff604c92b5da0
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Mon Oct 24 17:44:52 2022 -0400

    üêõ Fix FTDUI Status Screen Timeout (#24899)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 7ae1078f4d..6389383d28 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -61,7 +61,7 @@ typedef struct {
   screenFunc_t menu_function;     // The screen's function
   uint32_t encoder_position;      // The position of the encoder
   int8_t top_line, items;         // The amount of scroll, and the number of items
-  #if SCREENS_CAN_TIME_OUT
+  #if HAS_SCREEN_TIMEOUT
     bool sticky;                  // The screen is sticky
   #endif
 } menuPosition;
@@ -89,7 +89,7 @@ void MarlinUI::return_to_status() { goto_screen(status_screen); }
 
 void MarlinUI::push_current_screen() {
   if (screen_history_depth < COUNT(screen_history))
-    screen_history[screen_history_depth++] = { currentScreen, encoderPosition, encoderTopLine, screen_items OPTARG(SCREENS_CAN_TIME_OUT, screen_is_sticky()) };
+    screen_history[screen_history_depth++] = { currentScreen, encoderPosition, encoderTopLine, screen_items OPTARG(HAS_SCREEN_TIMEOUT, screen_is_sticky()) };
 }
 
 void MarlinUI::_goto_previous_screen(TERN_(TURBO_BACK_MENU_ITEM, const bool is_back/*=false*/)) {
@@ -102,7 +102,7 @@ void MarlinUI::_goto_previous_screen(TERN_(TURBO_BACK_MENU_ITEM, const bool is_b
       is_back ? 0 : sh.top_line,
       sh.items
     );
-    defer_status_screen(TERN_(SCREENS_CAN_TIME_OUT, sh.sticky));
+    defer_status_screen(TERN_(HAS_SCREEN_TIMEOUT, sh.sticky));
   }
   else
     return_to_status();

commit f595e40ceb0c79d7f0d6438636658dfcfa2a75b8
Author: EvilGremlin <22657714+EvilGremlin@users.noreply.github.com>
Date:   Sun Oct 9 18:30:47 2022 +0300

    ‚ôªÔ∏è Set Progress without LCD (#24767)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 9dd74988f3..7ae1078f4d 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -175,7 +175,7 @@ void MarlinUI::goto_screen(screenFunc_t screen, const uint16_t encoder/*=0*/, co
 
     TERN_(HAS_TOUCH_BUTTONS, repeat_delay = BUTTON_DELAY_MENU);
 
-    TERN_(LCD_SET_PROGRESS_MANUALLY, progress_reset());
+    TERN_(SET_PROGRESS_PERCENT, progress_reset());
 
     #if BOTH(DOUBLECLICK_FOR_Z_BABYSTEPPING, BABYSTEPPING)
       static millis_t doubleclick_expire_ms = 0;

commit 5f2908a117ab45cf9e5a03a39e499979a40bf0f3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jul 18 19:53:36 2022 -0500

    ‚ôªÔ∏è Small sound / buzz refactor (#24520)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index c11f389276..9dd74988f3 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -31,7 +31,7 @@
 #include "../../module/temperature.h"
 #include "../../gcode/queue.h"
 
-#if HAS_BUZZER
+#if HAS_SOUND
   #include "../../libs/buzzer.h"
 #endif
 
@@ -272,7 +272,7 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
     encoderTopLine = encoderLine;
 }
 
-#if HAS_BUZZER
+#if HAS_SOUND
   void MarlinUI::completion_feedback(const bool good/*=true*/) {
     TERN_(HAS_TOUCH_SLEEP, wakeup_screen()); // Wake up on rotary encoder click...
     if (good) OKAY_BUZZ(); else ERR_BUZZ();

commit ed2071aabdebf0c1d9b82b6d8575b8fefae763c4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jul 18 19:52:47 2022 -0500

    ü©π Fix manual move titles (#24518)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index a1e2beaf72..c11f389276 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -191,7 +191,7 @@ void MarlinUI::goto_screen(screenFunc_t screen, const uint16_t encoder/*=0*/, co
         else {
           #if ENABLED(MOVE_Z_WHEN_IDLE)
             ui.manual_move.menu_scale = MOVE_Z_IDLE_MULTIPLICATOR;
-            screen = lcd_move_z;
+            screen = []{ lcd_move_axis(Z_AXIS); };
           #endif
         }
       }

commit 8aca38351cd6d33a1202bf9a13890dc8e5eadd49
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 3 22:56:38 2022 -0500

    üßë‚Äçüíª Extend LCD string substitution (#24278)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 13ef0d2bc1..a1e2beaf72 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -68,9 +68,10 @@ typedef struct {
 menuPosition screen_history[6];
 uint8_t screen_history_depth = 0;
 
-int8_t MenuItemBase::itemIndex;   // Index number for draw and action
-FSTR_P MenuItemBase::itemString;  // A string for substitution
-chimera_t editable;               // Value Editing
+int8_t MenuItemBase::itemIndex;         // Index number for draw and action
+FSTR_P MenuItemBase::itemStringF;       // A string for substitution
+const char *MenuItemBase::itemStringC;
+chimera_t editable;                     // Value Editing
 
 // Menu Edit Items
 FSTR_P       MenuEditItemBase::editLabel;

commit 2b3ba02f09832379cffa4fc1baaa055228b82fe8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jun 3 18:16:43 2022 -0500

    üîß LEVEL_BED_CORNERS => LCD_BED_TRAMMING

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 92be24aa06..13ef0d2bc1 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -47,7 +47,7 @@
 ///////////// Global Variables /////////////
 ////////////////////////////////////////////
 
-#if HAS_LEVELING && ANY(LEVEL_BED_CORNERS, PROBE_OFFSET_WIZARD, X_AXIS_TWIST_COMPENSATION)
+#if HAS_LEVELING && ANY(LCD_BED_TRAMMING, PROBE_OFFSET_WIZARD, X_AXIS_TWIST_COMPENSATION)
   bool leveling_was_active; // = false
 #endif
 #if ANY(PROBE_MANUALLY, MESH_BED_LEVELING, X_AXIS_TWIST_COMPENSATION)

commit a5e1d4c50ae40c8203d8490be83ef86e16ebf1c2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 22 19:56:46 2022 -0500

    ‚ôªÔ∏è Apply F() to more LCD code (#24228)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 2f075238e4..92be24aa06 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -69,11 +69,11 @@ menuPosition screen_history[6];
 uint8_t screen_history_depth = 0;
 
 int8_t MenuItemBase::itemIndex;   // Index number for draw and action
-PGM_P MenuItemBase::itemString;   // A PSTR for substitution
+FSTR_P MenuItemBase::itemString;  // A string for substitution
 chimera_t editable;               // Value Editing
 
 // Menu Edit Items
-PGM_P        MenuEditItemBase::editLabel;
+FSTR_P       MenuEditItemBase::editLabel;
 void*        MenuEditItemBase::editValue;
 int32_t      MenuEditItemBase::minEditValue,
              MenuEditItemBase::maxEditValue;
@@ -134,7 +134,7 @@ void MenuEditItemBase::edit_screen(strfunc_t strfunc, loadfunc_t loadfunc) {
 
 // Going to an edit screen sets up some persistent values first
 void MenuEditItemBase::goto_edit_screen(
-  PGM_P const el,         // Edit label
+  FSTR_P const el,        // Edit label
   void * const ev,        // Edit value pointer
   const int32_t minv,     // Encoder minimum
   const int32_t maxv,     // Encoder maximum
@@ -232,8 +232,8 @@ void MarlinUI::goto_screen(screenFunc_t screen, const uint16_t encoder/*=0*/, co
 // Display a "synchronize" screen with a custom message until
 // all moves are finished. Go back to calling screen when done.
 //
-void MarlinUI::synchronize(PGM_P const msg/*=nullptr*/) {
-  static PGM_P sync_message = msg ?: GET_TEXT(MSG_MOVING);
+void MarlinUI::synchronize(FSTR_P const fmsg/*=nullptr*/) {
+  static FSTR_P sync_message = fmsg ?: GET_TEXT_F(MSG_MOVING);
   push_current_screen();
   goto_screen([]{
     if (should_draw()) MenuItem_static::draw(LCD_HEIGHT >= 4, sync_message);
@@ -319,12 +319,12 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
     }
     if (ui.should_draw()) {
       if (do_probe) {
-        MenuEditItemBase::draw_edit_screen(GET_TEXT(MSG_ZPROBE_ZOFFSET), BABYSTEP_TO_STR(probe.offset.z));
+        MenuEditItemBase::draw_edit_screen(GET_TEXT_F(MSG_ZPROBE_ZOFFSET), BABYSTEP_TO_STR(probe.offset.z));
         TERN_(BABYSTEP_ZPROBE_GFX_OVERLAY, ui.zoffset_overlay(probe.offset.z));
       }
       else {
         #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
-          MenuEditItemBase::draw_edit_screen(GET_TEXT(MSG_HOTEND_OFFSET_Z), ftostr54sign(hotend_offset[active_extruder].z));
+          MenuEditItemBase::draw_edit_screen(GET_TEXT_F(MSG_HOTEND_OFFSET_Z), ftostr54sign(hotend_offset[active_extruder].z));
         #endif
       }
     }
@@ -335,7 +335,7 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
 void _lcd_draw_homing() {
   if (ui.should_draw()) {
     constexpr uint8_t line = (LCD_HEIGHT - 1) / 2;
-    MenuItem_static::draw(line, GET_TEXT(MSG_LEVEL_BED_HOMING));
+    MenuItem_static::draw(line, GET_TEXT_F(MSG_LEVEL_BED_HOMING));
   }
 }
 
@@ -357,9 +357,9 @@ bool MarlinUI::update_selection() {
 }
 
 void MenuItem_confirm::select_screen(
-  PGM_P const yes, PGM_P const no,
+  FSTR_P const yes, FSTR_P const no,
   selectFunc_t yesFunc, selectFunc_t noFunc,
-  PGM_P const pref, const char * const string/*=nullptr*/, PGM_P const suff/*=nullptr*/
+  FSTR_P const pref, const char * const string/*=nullptr*/, FSTR_P const suff/*=nullptr*/
 ) {
   ui.defer_status_screen();
   const bool ui_selection = !yes ? false : !no || ui.update_selection(),

commit b523ddf1b2820488c6cc46887ee85e8a781ce726
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 19 06:05:52 2022 -0500

    ‚ôªÔ∏è Common Bed Leveling object name, accessors (#24214)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index d56bc9b5ff..2f075238e4 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -203,14 +203,14 @@ void MarlinUI::goto_screen(screenFunc_t screen, const uint16_t encoder/*=0*/, co
     if (on_status_screen()) {
       defer_status_screen(false);
       clear_menu_history();
-      TERN_(AUTO_BED_LEVELING_UBL, ubl.lcd_map_control = false);
+      TERN_(AUTO_BED_LEVELING_UBL, bedlevel.lcd_map_control = false);
     }
 
     clear_lcd();
 
     // Re-initialize custom characters that may be re-used
     #if HAS_MARLINUI_HD44780
-      if (TERN1(AUTO_BED_LEVELING_UBL, !ubl.lcd_map_control))
+      if (TERN1(AUTO_BED_LEVELING_UBL, !bedlevel.lcd_map_control))
         set_custom_characters(on_status_screen() ? CHARSET_INFO : CHARSET_MENU);
     #endif
 

commit 1e749e4f48f528179213e736c99371843a90b4fb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu May 12 20:13:59 2022 -0500

    üßë‚Äçüíª Misc. LCD cleanup

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index bcdff450bd..d56bc9b5ff 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -163,10 +163,6 @@ void MenuEditItemBase::goto_edit_screen(
 
 #include "../../MarlinCore.h"
 
-bool printer_busy() {
-  return planner.movesplanned() || printingIsActive();
-}
-
 /**
  * General function to go directly to a screen
  */

commit 5005c7b64c1763eca767ad476f404301d6ef754a
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Tue Apr 19 15:03:42 2022 +1200

    üêõ Fix Manual Move cold extrude override (#24045)
    
    Followup to #19606
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 52c43ec5e9..bcdff450bd 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -28,6 +28,7 @@
 #include "../../module/planner.h"
 #include "../../module/motion.h"
 #include "../../module/printcounter.h"
+#include "../../module/temperature.h"
 #include "../../gcode/queue.h"
 
 #if HAS_BUZZER
@@ -171,6 +172,7 @@ bool printer_busy() {
  */
 void MarlinUI::goto_screen(screenFunc_t screen, const uint16_t encoder/*=0*/, const uint8_t top/*=0*/, const uint8_t items/*=0*/) {
   if (currentScreen != screen) {
+    thermalManager.set_menu_cold_override(false);
 
     TERN_(IS_DWIN_MARLINUI, did_first_redraw = false);
 

commit 89a9c3a391101e4d2d8dbfbf0cdb261ad2d9592b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 12 16:34:58 2022 -0600

    üßë‚Äçüíª  Add standard BUZZ types

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 2dca6c1b82..52c43ec5e9 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -276,11 +276,7 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
 #if HAS_BUZZER
   void MarlinUI::completion_feedback(const bool good/*=true*/) {
     TERN_(HAS_TOUCH_SLEEP, wakeup_screen()); // Wake up on rotary encoder click...
-    if (good) {
-      BUZZ(100, 659);
-      BUZZ(100, 698);
-    }
-    else BUZZ(20, 440);
+    if (good) OKAY_BUZZ(); else ERR_BUZZ();
   }
 #endif
 

commit 5b35f3a95582a477e879be5cc7d1406a42d3e740
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Wed Jan 26 10:33:10 2022 -0800

    üö∏ Better "Bed Tramming Done" dialog (#23616)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 01b845da6e..2dca6c1b82 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -368,7 +368,8 @@ void MenuItem_confirm::select_screen(
   PGM_P const pref, const char * const string/*=nullptr*/, PGM_P const suff/*=nullptr*/
 ) {
   ui.defer_status_screen();
-  const bool ui_selection = ui.update_selection(), got_click = ui.use_click();
+  const bool ui_selection = !yes ? false : !no || ui.update_selection(),
+             got_click = ui.use_click();
   if (got_click || ui.should_draw()) {
     draw_select_screen(yes, no, ui_selection, pref, string, suff);
     if (got_click) {

commit ab46b7e2f298826a5512569d6e79bb59a7a6b8ea
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jan 25 15:33:03 2022 -0600

    üßë‚Äçüíª HAS_MARLINUI_MENU, HAS_MANUAL_MOVE_MENU

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 9337cf4774..01b845da6e 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -22,7 +22,7 @@
 
 #include "../../inc/MarlinConfigPre.h"
 
-#if HAS_LCD_MENU
+#if HAS_MARLINUI_MENU
 
 #include "menu.h"
 #include "../../module/planner.h"
@@ -220,7 +220,7 @@ void MarlinUI::goto_screen(screenFunc_t screen, const uint16_t encoder/*=0*/, co
     screen_changed = true;
     TERN_(HAS_MARLINUI_U8GLIB, drawing_screen = false);
 
-    TERN_(HAS_LCD_MENU, encoder_direction_normal());
+    TERN_(HAS_MARLINUI_MENU, encoder_direction_normal());
 
     set_selection(false);
   }
@@ -378,4 +378,4 @@ void MenuItem_confirm::select_screen(
   }
 }
 
-#endif // HAS_LCD_MENU
+#endif // HAS_MARLINUI_MENU

commit a4678d9e2798f203054ffa7c796f7b5b063c36d4
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Tue Dec 14 19:25:28 2021 +1300

    üêõ Fix LCD_BED_LEVELING compile (#23298)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index c566e9b2a6..9337cf4774 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -345,7 +345,7 @@ void _lcd_draw_homing() {
   }
 }
 
-#if HAS_LEVELING && DISABLED(SLIM_LCD_MENUS)
+#if ENABLED(LCD_BED_LEVELING) || (HAS_LEVELING && DISABLED(SLIM_LCD_MENUS))
   void _lcd_toggle_bed_leveling() { set_bed_leveling_enabled(!planner.leveling_active); }
 #endif
 

commit a16a059312b0ddb822da2769b5ba5372f9857c48
Author: Giuseppe499 <giuseppe499@live.it>
Date:   Tue Dec 7 02:53:51 2021 +0100

    ‚ú® X Twist Compensation & Calibration (#23238)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index a24ad883f7..c566e9b2a6 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -38,7 +38,7 @@
   #include "../../module/probe.h"
 #endif
 
-#if EITHER(ENABLE_LEVELING_FADE_HEIGHT, AUTO_BED_LEVELING_UBL)
+#if HAS_LEVELING
   #include "../../feature/bedlevel/bedlevel.h"
 #endif
 
@@ -46,6 +46,13 @@
 ///////////// Global Variables /////////////
 ////////////////////////////////////////////
 
+#if HAS_LEVELING && ANY(LEVEL_BED_CORNERS, PROBE_OFFSET_WIZARD, X_AXIS_TWIST_COMPENSATION)
+  bool leveling_was_active; // = false
+#endif
+#if ANY(PROBE_MANUALLY, MESH_BED_LEVELING, X_AXIS_TWIST_COMPENSATION)
+  uint8_t manual_probe_index; // = 0
+#endif
+
 // Menu Navigation
 int8_t encoderTopLine, encoderLine, screen_items;
 
@@ -338,8 +345,7 @@ void _lcd_draw_homing() {
   }
 }
 
-#if ENABLED(LCD_BED_LEVELING) || (HAS_LEVELING && DISABLED(SLIM_LCD_MENUS))
-  #include "../../feature/bedlevel/bedlevel.h"
+#if HAS_LEVELING && DISABLED(SLIM_LCD_MENUS)
   void _lcd_toggle_bed_leveling() { set_bed_leveling_enabled(!planner.leveling_active); }
 #endif
 

commit 54d400608db83bfa606e1b757589c169c9a38fc2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Oct 4 00:24:41 2021 -0500

    üé® Axis name string interpolation, with examples (#22879)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 61a1a16c6a..a24ad883f7 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -103,42 +103,28 @@ void MarlinUI::_goto_previous_screen(TERN_(TURBO_BACK_MENU_ITEM, const bool is_b
 /////////// Menu Editing Actions ///////////
 ////////////////////////////////////////////
 
-/**
- * Functions for editing single values
- *
- * The "DEFINE_MENU_EDIT_ITEM" macro generates the classes needed to edit a numerical value.
- *
- * The prerequisite is that in the header the type was already declared:
- *
- *   DEFINE_MENU_EDIT_ITEM_TYPE(int3, int16_t, i16tostr3rj, 1)
- *
- * For example, DEFINE_MENU_EDIT_ITEM(int3) expands into:
- *
- *   template class TMenuEditItem<MenuEditItemInfo_int3>
- *
- * You can then use one of the menu macros to present the edit interface:
- *   EDIT_ITEM(int3, MSG_SPEED, &feedrate_percentage, 10, 999)
- *
- * This expands into a more primitive menu item:
- *  _MENU_ITEM_P(int3, false, GET_TEXT(MSG_SPEED), &feedrate_percentage, 10, 999)
- *
- * ...which calls:
- *       MenuItem_int3::action(plabel, &feedrate_percentage, 10, 999)
- *       MenuItem_int3::draw(encoderLine == _thisItemNr, _lcdLineNr, plabel, &feedrate_percentage, 10, 999)
- */
+// All Edit Screens run the same way, but `draw_edit_screen` is implementation-specific
 void MenuEditItemBase::edit_screen(strfunc_t strfunc, loadfunc_t loadfunc) {
+  // Reset repeat_delay for Touch Buttons
   TERN_(HAS_TOUCH_BUTTONS, ui.repeat_delay = BUTTON_DELAY_EDIT);
+  // Constrain ui.encoderPosition to 0 ... maxEditValue (calculated in encoder steps)
   if (int32_t(ui.encoderPosition) < 0) ui.encoderPosition = 0;
   if (int32_t(ui.encoderPosition) > maxEditValue) ui.encoderPosition = maxEditValue;
+  // If drawing is flagged then redraw the (whole) edit screen
   if (ui.should_draw())
     draw_edit_screen(strfunc(ui.encoderPosition + minEditValue));
+  // If there was a click or "live editing" and encoder moved...
   if (ui.lcd_clicked || (liveEdit && ui.should_draw())) {
+    // Pass the editValue pointer to the loadfunc along with the encoder plus min
     if (editValue) loadfunc(editValue, ui.encoderPosition + minEditValue);
+    // If a callbackFunc was set, call it for click or always for "live editing"
     if (callbackFunc && (liveEdit || ui.lcd_clicked)) (*callbackFunc)();
+    // Use up the click to finish editing and go to the previous screen
     if (ui.use_click()) ui.goto_previous_screen();
   }
 }
 
+// Going to an edit screen sets up some persistent values first
 void MenuEditItemBase::goto_edit_screen(
   PGM_P const el,         // Edit label
   void * const ev,        // Edit value pointer

commit eb784d6e55c84c05b2a5353899d8bc25276e0640
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Oct 2 02:33:14 2021 -0500

    üé® Rename MarlinUI::zoffset_overlay

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 76cdd51cd5..61a1a16c6a 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -257,9 +257,6 @@ void MarlinUI::synchronize(PGM_P const msg/*=nullptr*/) {
  *
  *   encoderLine is the position based on the encoder
  *   encoderTopLine is the top menu line to display
- *   _lcdLineNr is the index of the LCD line (e.g., 0-3)
- *   _menuLineNr is the menu item to draw and process
- *   _thisItemNr is the index of each MENU_ITEM or STATIC_ITEM
  *   screen_items is the total number of items in the menu (after one call)
  */
 void scroll_screen(const uint8_t limit, const bool is_menu) {
@@ -336,7 +333,7 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
     if (ui.should_draw()) {
       if (do_probe) {
         MenuEditItemBase::draw_edit_screen(GET_TEXT(MSG_ZPROBE_ZOFFSET), BABYSTEP_TO_STR(probe.offset.z));
-        TERN_(BABYSTEP_ZPROBE_GFX_OVERLAY, _lcd_zoffset_overlay_gfx(probe.offset.z));
+        TERN_(BABYSTEP_ZPROBE_GFX_OVERLAY, ui.zoffset_overlay(probe.offset.z));
       }
       else {
         #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)

commit 228eb9c404fcbcebb507bbfe781ebe3ca0a1ccdf
Author: espr14 <espr14@gmail.com>
Date:   Mon Sep 27 21:05:52 2021 +0200

    üé® steps_to_mm => mm_per_step (#22847)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index a177f32932..76cdd51cd5 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -315,7 +315,7 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
       const int16_t babystep_increment = int16_t(ui.encoderPosition) * (BABYSTEP_SIZE_Z);
       ui.encoderPosition = 0;
 
-      const float diff = planner.steps_to_mm[Z_AXIS] * babystep_increment,
+      const float diff = planner.mm_per_step[Z_AXIS] * babystep_increment,
                   new_probe_offset = probe.offset.z + diff,
                   new_offs = TERN(BABYSTEP_HOTEND_Z_OFFSET
                     , do_probe ? new_probe_offset : hotend_offset[active_extruder].z - diff

commit c2e4b1626f0cce82a55e8de9dc98ed9381e1d9ad
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Tue Sep 14 04:07:08 2021 +0200

    ‚ú® TFT Screen/Backlight Sleep (#22617)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index dd52eb2b5b..a177f32932 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -285,6 +285,7 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
 
 #if HAS_BUZZER
   void MarlinUI::completion_feedback(const bool good/*=true*/) {
+    TERN_(HAS_TOUCH_SLEEP, wakeup_screen()); // Wake up on rotary encoder click...
     if (good) {
       BUZZ(100, 659);
       BUZZ(100, 698);

commit 7d416bd055e3ccddf765208b2937dcc1fcd4ea8b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Aug 22 05:25:07 2021 -0500

    ‚ú® MarlinUI for Ender 3 v2 DWIN LCD (#22594)
    
    Co-Authored-By: Taylor Talkington <taylor.talkington@gmail.com>

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 01c8bb80c0..dd52eb2b5b 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -179,6 +179,8 @@ bool printer_busy() {
 void MarlinUI::goto_screen(screenFunc_t screen, const uint16_t encoder/*=0*/, const uint8_t top/*=0*/, const uint8_t items/*=0*/) {
   if (currentScreen != screen) {
 
+    TERN_(IS_DWIN_MARLINUI, did_first_redraw = false);
+
     TERN_(HAS_TOUCH_BUTTONS, repeat_delay = BUTTON_DELAY_MENU);
 
     TERN_(LCD_SET_PROGRESS_MANUALLY, progress_reset());

commit f9051e5469cdd99bcb93bc46124e95984c279984
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jun 27 00:33:44 2021 -0500

    ‚ôªÔ∏è Refactor status screen timeout

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 6143e8da1e..01c8bb80c0 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -50,9 +50,12 @@
 int8_t encoderTopLine, encoderLine, screen_items;
 
 typedef struct {
-  screenFunc_t menu_function;
-  uint32_t encoder_position;
-  int8_t top_line, items;
+  screenFunc_t menu_function;     // The screen's function
+  uint32_t encoder_position;      // The position of the encoder
+  int8_t top_line, items;         // The amount of scroll, and the number of items
+  #if SCREENS_CAN_TIME_OUT
+    bool sticky;                  // The screen is sticky
+  #endif
 } menuPosition;
 menuPosition screen_history[6];
 uint8_t screen_history_depth = 0;
@@ -75,9 +78,9 @@ bool         MenuEditItemBase::liveEdit;
 
 void MarlinUI::return_to_status() { goto_screen(status_screen); }
 
-void MarlinUI::save_previous_screen() {
+void MarlinUI::push_current_screen() {
   if (screen_history_depth < COUNT(screen_history))
-    screen_history[screen_history_depth++] = { currentScreen, encoderPosition, encoderTopLine, screen_items };
+    screen_history[screen_history_depth++] = { currentScreen, encoderPosition, encoderTopLine, screen_items OPTARG(SCREENS_CAN_TIME_OUT, screen_is_sticky()) };
 }
 
 void MarlinUI::_goto_previous_screen(TERN_(TURBO_BACK_MENU_ITEM, const bool is_back/*=false*/)) {
@@ -90,6 +93,7 @@ void MarlinUI::_goto_previous_screen(TERN_(TURBO_BACK_MENU_ITEM, const bool is_b
       is_back ? 0 : sh.top_line,
       sh.items
     );
+    defer_status_screen(TERN_(SCREENS_CAN_TIME_OUT, sh.sticky));
   }
   else
     return_to_status();
@@ -147,7 +151,7 @@ void MenuEditItemBase::goto_edit_screen(
 ) {
   TERN_(HAS_TOUCH_BUTTONS, ui.on_edit_screen = true);
   ui.screen_changed = true;
-  ui.save_previous_screen();
+  ui.push_current_screen();
   ui.refresh();
   editLabel = el;
   editValue = ev;
@@ -237,7 +241,7 @@ void MarlinUI::goto_screen(screenFunc_t screen, const uint16_t encoder/*=0*/, co
 //
 void MarlinUI::synchronize(PGM_P const msg/*=nullptr*/) {
   static PGM_P sync_message = msg ?: GET_TEXT(MSG_MOVING);
-  save_previous_screen();
+  push_current_screen();
   goto_screen([]{
     if (should_draw()) MenuItem_static::draw(LCD_HEIGHT >= 4, sync_message);
   });
@@ -371,6 +375,7 @@ void MenuItem_confirm::select_screen(
   selectFunc_t yesFunc, selectFunc_t noFunc,
   PGM_P const pref, const char * const string/*=nullptr*/, PGM_P const suff/*=nullptr*/
 ) {
+  ui.defer_status_screen();
   const bool ui_selection = ui.update_selection(), got_click = ui.use_click();
   if (got_click || ui.should_draw()) {
     draw_select_screen(yes, no, ui_selection, pref, string, suff);
@@ -378,7 +383,6 @@ void MenuItem_confirm::select_screen(
       selectFunc_t callFunc = ui_selection ? yesFunc : noFunc;
       if (callFunc) callFunc(); else ui.goto_previous_screen();
     }
-    ui.defer_status_screen();
   }
 }
 

commit 62f37669dc506a6e579389ca549ce5993548944d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Apr 1 17:59:57 2021 -0500

    Replace 'const float &' with 'const_float_t' (#21505)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index add306b6e3..6143e8da1e 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -289,7 +289,7 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
 
 #if HAS_LINE_TO_Z
 
-  void line_to_z(const float &z) {
+  void line_to_z(const_float_t z) {
     current_position.z = z;
     line_to_current_position(manual_feedrate_mm_s.z);
   }

commit 8fd8772a6fffe63d99d0b88aec7a77d283df8584
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Nov 29 19:06:40 2020 -0600

    Adjust axis homed / trusted methods (#20323)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 1497940ffe..add306b6e3 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -188,8 +188,7 @@ void MarlinUI::goto_screen(screenFunc_t screen, const uint16_t encoder/*=0*/, co
           doubleclick_expire_ms = millis() + DOUBLECLICK_MAX_INTERVAL;
       }
       else if (screen == status_screen && currentScreen == menu_main && PENDING(millis(), doubleclick_expire_ms)) {
-        if ( (ENABLED(BABYSTEP_WITHOUT_HOMING) || all_axes_known())
-          && (ENABLED(BABYSTEP_ALWAYS_AVAILABLE) || printer_busy()) )
+        if (BABYSTEP_ALLOWED())
           screen = TERN(BABYSTEP_ZPROBE_OFFSET, lcd_babystep_zoffset, lcd_babystep_z);
         else {
           #if ENABLED(MOVE_Z_WHEN_IDLE)

commit e19c016c74c9627afe7c4527dfc08d5c77539261
Author: qwewer0 <57561110+qwewer0@users.noreply.github.com>
Date:   Sun Nov 22 01:21:43 2020 +0100

    Clear menu history for browse media on insert (#20236)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 81ac32a60c..1497940ffe 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -206,8 +206,8 @@ void MarlinUI::goto_screen(screenFunc_t screen, const uint16_t encoder/*=0*/, co
     screen_items = items;
     if (on_status_screen()) {
       defer_status_screen(false);
+      clear_menu_history();
       TERN_(AUTO_BED_LEVELING_UBL, ubl.lcd_map_control = false);
-      screen_history_depth = 0;
     }
 
     clear_lcd();

commit ea371618da71dc43e6aee95a8e479c8797867e04
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Sun Nov 15 19:39:58 2020 -0300

    Add Touch Calibration screen (#20049)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 35c736c560..81ac32a60c 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -82,7 +82,7 @@ void MarlinUI::save_previous_screen() {
 
 void MarlinUI::_goto_previous_screen(TERN_(TURBO_BACK_MENU_ITEM, const bool is_back/*=false*/)) {
   IF_DISABLED(TURBO_BACK_MENU_ITEM, constexpr bool is_back = false);
-  TERN_(HAS_TOUCH_XPT2046, on_edit_screen = false);
+  TERN_(HAS_TOUCH_BUTTONS, on_edit_screen = false);
   if (screen_history_depth > 0) {
     menuPosition &sh = screen_history[--screen_history_depth];
     goto_screen(sh.menu_function,
@@ -123,7 +123,7 @@ void MarlinUI::_goto_previous_screen(TERN_(TURBO_BACK_MENU_ITEM, const bool is_b
  *       MenuItem_int3::draw(encoderLine == _thisItemNr, _lcdLineNr, plabel, &feedrate_percentage, 10, 999)
  */
 void MenuEditItemBase::edit_screen(strfunc_t strfunc, loadfunc_t loadfunc) {
-  TERN_(HAS_TOUCH_XPT2046, ui.repeat_delay = BUTTON_DELAY_EDIT);
+  TERN_(HAS_TOUCH_BUTTONS, ui.repeat_delay = BUTTON_DELAY_EDIT);
   if (int32_t(ui.encoderPosition) < 0) ui.encoderPosition = 0;
   if (int32_t(ui.encoderPosition) > maxEditValue) ui.encoderPosition = maxEditValue;
   if (ui.should_draw())
@@ -145,7 +145,7 @@ void MenuEditItemBase::goto_edit_screen(
   const screenFunc_t cb,  // Callback after edit
   const bool le           // Flag to call cb() during editing
 ) {
-  TERN_(HAS_TOUCH_XPT2046, ui.on_edit_screen = true);
+  TERN_(HAS_TOUCH_BUTTONS, ui.on_edit_screen = true);
   ui.screen_changed = true;
   ui.save_previous_screen();
   ui.refresh();
@@ -175,7 +175,7 @@ bool printer_busy() {
 void MarlinUI::goto_screen(screenFunc_t screen, const uint16_t encoder/*=0*/, const uint8_t top/*=0*/, const uint8_t items/*=0*/) {
   if (currentScreen != screen) {
 
-    TERN_(HAS_TOUCH_XPT2046, repeat_delay = BUTTON_DELAY_MENU);
+    TERN_(HAS_TOUCH_BUTTONS, repeat_delay = BUTTON_DELAY_MENU);
 
     TERN_(LCD_SET_PROGRESS_MANUALLY, progress_reset());
 

commit 06bf3ccfb7a19c972e5f40816d49e3860711f976
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Nov 7 18:28:29 2020 -0600

    Add alternative TERN macros

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index cd94927049..35c736c560 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -81,7 +81,7 @@ void MarlinUI::save_previous_screen() {
 }
 
 void MarlinUI::_goto_previous_screen(TERN_(TURBO_BACK_MENU_ITEM, const bool is_back/*=false*/)) {
-  TERN(TURBO_BACK_MENU_ITEM,,constexpr bool is_back = false);
+  IF_DISABLED(TURBO_BACK_MENU_ITEM, constexpr bool is_back = false);
   TERN_(HAS_TOUCH_XPT2046, on_edit_screen = false);
   if (screen_history_depth > 0) {
     menuPosition &sh = screen_history[--screen_history_depth];

commit ec23e37a4a31d12febc06922d3fa68446f58d7fb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Oct 24 17:13:10 2020 -0500

    Clean up comments, USB flash, NULLs

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 5d67410351..cd94927049 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -129,7 +129,7 @@ void MenuEditItemBase::edit_screen(strfunc_t strfunc, loadfunc_t loadfunc) {
   if (ui.should_draw())
     draw_edit_screen(strfunc(ui.encoderPosition + minEditValue));
   if (ui.lcd_clicked || (liveEdit && ui.should_draw())) {
-    if (editValue != nullptr) loadfunc(editValue, ui.encoderPosition + minEditValue);
+    if (editValue) loadfunc(editValue, ui.encoderPosition + minEditValue);
     if (callbackFunc && (liveEdit || ui.lcd_clicked)) (*callbackFunc)();
     if (ui.use_click()) ui.goto_previous_screen();
   }

commit c2c6a679ea4bdf48ce1800a8831fcec36c09ce53
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 28 01:13:27 2020 -0500

    Rename LCD conditionals (#19533)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 474f40ceca..5d67410351 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -213,14 +213,14 @@ void MarlinUI::goto_screen(screenFunc_t screen, const uint16_t encoder/*=0*/, co
     clear_lcd();
 
     // Re-initialize custom characters that may be re-used
-    #if HAS_CHARACTER_LCD
+    #if HAS_MARLINUI_HD44780
       if (TERN1(AUTO_BED_LEVELING_UBL, !ubl.lcd_map_control))
         set_custom_characters(on_status_screen() ? CHARSET_INFO : CHARSET_MENU);
     #endif
 
     refresh(LCDVIEW_CALL_REDRAW_NEXT);
     screen_changed = true;
-    TERN_(HAS_GRAPHICAL_LCD, drawing_screen = false);
+    TERN_(HAS_MARLINUI_U8GLIB, drawing_screen = false);
 
     TERN_(HAS_LCD_MENU, encoder_direction_normal());
 

commit 3a91ab4706d9fb7177bd24ce3e87f852161768d1
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 28 01:01:35 2020 -0500

    Menu tweak

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 64923547e8..474f40ceca 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -343,8 +343,10 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
 #endif // BABYSTEP_ZPROBE_OFFSET
 
 void _lcd_draw_homing() {
-  constexpr uint8_t line = (LCD_HEIGHT - 1) / 2;
-  if (ui.should_draw()) MenuItem_static::draw(line, GET_TEXT(MSG_LEVEL_BED_HOMING));
+  if (ui.should_draw()) {
+    constexpr uint8_t line = (LCD_HEIGHT - 1) / 2;
+    MenuItem_static::draw(line, GET_TEXT(MSG_LEVEL_BED_HOMING));
+  }
 }
 
 #if ENABLED(LCD_BED_LEVELING) || (HAS_LEVELING && DISABLED(SLIM_LCD_MENUS))

commit 979876e958e73e642b51eb655461c92947fe1deb
Author: ellensp <ellensp@hotmail.com>
Date:   Mon Sep 14 16:58:39 2020 +1200

    Improve temperature runaway, idle timeout (#19339)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index e6739a135c..64923547e8 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -34,10 +34,6 @@
   #include "../../libs/buzzer.h"
 #endif
 
-#if WATCH_HOTENDS || WATCH_BED
-  #include "../../module/temperature.h"
-#endif
-
 #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
   #include "../../module/probe.h"
 #endif

commit b8c4098de24c7876fe48f27a69aaa96f3557a7e2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Aug 21 05:21:55 2020 -0500

    Remove extraneous defines

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 309ad06a4c..e6739a135c 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -163,30 +163,6 @@ void MenuEditItemBase::goto_edit_screen(
   liveEdit = le;
 }
 
-// TODO: Remove these but test build size with and without
-#define DEFINE_MENU_EDIT_ITEM(NAME) template class TMenuEditItem<MenuEditItemInfo_##NAME>
-
-DEFINE_MENU_EDIT_ITEM(percent);     // 100%       right-justified
-DEFINE_MENU_EDIT_ITEM(int3);        // 123, -12   right-justified
-DEFINE_MENU_EDIT_ITEM(int4);        // 1234, -123 right-justified
-DEFINE_MENU_EDIT_ITEM(int8);        // 123, -12   right-justified
-DEFINE_MENU_EDIT_ITEM(uint8);       // 123        right-justified
-DEFINE_MENU_EDIT_ITEM(uint16_3);    // 123        right-justified
-DEFINE_MENU_EDIT_ITEM(uint16_4);    // 1234       right-justified
-DEFINE_MENU_EDIT_ITEM(uint16_5);    // 12345      right-justified
-DEFINE_MENU_EDIT_ITEM(float3);      // 123        right-justified
-DEFINE_MENU_EDIT_ITEM(float42_52);  // _2.34, 12.34, -2.34 or 123.45, -23.45
-DEFINE_MENU_EDIT_ITEM(float43);     // 1.234
-DEFINE_MENU_EDIT_ITEM(float5);      // 12345      right-justified
-DEFINE_MENU_EDIT_ITEM(float5_25);   // 12345      right-justified (25 increment)
-DEFINE_MENU_EDIT_ITEM(float51);     // 1234.5     right-justified
-DEFINE_MENU_EDIT_ITEM(float31sign); // +12.3
-DEFINE_MENU_EDIT_ITEM(float41sign); // +123.4
-DEFINE_MENU_EDIT_ITEM(float51sign); // +1234.5
-DEFINE_MENU_EDIT_ITEM(float52sign); // +123.45
-DEFINE_MENU_EDIT_ITEM(long5);       // 12345      right-justified
-DEFINE_MENU_EDIT_ITEM(long5_25);    // 12345      right-justified (25 increment)
-
 ////////////////////////////////////////////
 ///////////////// Menu Tree ////////////////
 ////////////////////////////////////////////

commit 4f67642122059a9270f9e3690978248355f88e72
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Aug 21 05:21:34 2020 -0500

    Header for individual menus

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 3a3cd0934b..309ad06a4c 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -99,12 +99,6 @@ void MarlinUI::_goto_previous_screen(TERN_(TURBO_BACK_MENU_ITEM, const bool is_b
     return_to_status();
 }
 
-////////////////////////////////////////////
-/////////// Common Menu Actions ////////////
-////////////////////////////////////////////
-
-void MenuItem_gcode::action(PGM_P const, PGM_P const pgcode) { queue.inject_P(pgcode); }
-
 ////////////////////////////////////////////
 /////////// Menu Editing Actions ///////////
 ////////////////////////////////////////////
@@ -193,11 +187,6 @@ DEFINE_MENU_EDIT_ITEM(float52sign); // +123.45
 DEFINE_MENU_EDIT_ITEM(long5);       // 12345      right-justified
 DEFINE_MENU_EDIT_ITEM(long5_25);    // 12345      right-justified (25 increment)
 
-void MenuItem_bool::action(PGM_P const, bool * const ptr, screenFunc_t callback) {
-  *ptr ^= true; ui.refresh();
-  if (callback) (*callback)();
-}
-
 ////////////////////////////////////////////
 ///////////////// Menu Tree ////////////////
 ////////////////////////////////////////////

commit bf316d9ec5e9472d78c6548a0a9e7a5988970e2c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Aug 21 02:41:33 2020 -0500

    Fix Select Screen cancel destination

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 373051fd4e..3a3cd0934b 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -412,7 +412,10 @@ void MenuItem_confirm::select_screen(
   const bool ui_selection = ui.update_selection(), got_click = ui.use_click();
   if (got_click || ui.should_draw()) {
     draw_select_screen(yes, no, ui_selection, pref, string, suff);
-    if (got_click) { ui_selection ? yesFunc() : noFunc(); }
+    if (got_click) {
+      selectFunc_t callFunc = ui_selection ? yesFunc : noFunc;
+      if (callFunc) callFunc(); else ui.goto_previous_screen();
+    }
     ui.defer_status_screen();
   }
 }

commit 117df87d193994f6fbcd46c45573095adf921784
Author: Alexander Gavrilenko <jmz52@users.noreply.github.com>
Date:   Thu Jul 30 09:43:19 2020 +0300

    Support for TFT & Touch Screens (#18130)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 2a9e4766d8..373051fd4e 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -86,7 +86,7 @@ void MarlinUI::save_previous_screen() {
 
 void MarlinUI::_goto_previous_screen(TERN_(TURBO_BACK_MENU_ITEM, const bool is_back/*=false*/)) {
   TERN(TURBO_BACK_MENU_ITEM,,constexpr bool is_back = false);
-  TERN_(TOUCH_BUTTONS, on_edit_screen = false);
+  TERN_(HAS_TOUCH_XPT2046, on_edit_screen = false);
   if (screen_history_depth > 0) {
     menuPosition &sh = screen_history[--screen_history_depth];
     goto_screen(sh.menu_function,
@@ -133,7 +133,7 @@ void MenuItem_gcode::action(PGM_P const, PGM_P const pgcode) { queue.inject_P(pg
  *       MenuItem_int3::draw(encoderLine == _thisItemNr, _lcdLineNr, plabel, &feedrate_percentage, 10, 999)
  */
 void MenuEditItemBase::edit_screen(strfunc_t strfunc, loadfunc_t loadfunc) {
-  TERN_(TOUCH_BUTTONS, ui.repeat_delay = BUTTON_DELAY_EDIT);
+  TERN_(HAS_TOUCH_XPT2046, ui.repeat_delay = BUTTON_DELAY_EDIT);
   if (int32_t(ui.encoderPosition) < 0) ui.encoderPosition = 0;
   if (int32_t(ui.encoderPosition) > maxEditValue) ui.encoderPosition = maxEditValue;
   if (ui.should_draw())
@@ -155,7 +155,7 @@ void MenuEditItemBase::goto_edit_screen(
   const screenFunc_t cb,  // Callback after edit
   const bool le           // Flag to call cb() during editing
 ) {
-  TERN_(TOUCH_BUTTONS, ui.on_edit_screen = true);
+  TERN_(HAS_TOUCH_XPT2046, ui.on_edit_screen = true);
   ui.screen_changed = true;
   ui.save_previous_screen();
   ui.refresh();
@@ -214,7 +214,7 @@ bool printer_busy() {
 void MarlinUI::goto_screen(screenFunc_t screen, const uint16_t encoder/*=0*/, const uint8_t top/*=0*/, const uint8_t items/*=0*/) {
   if (currentScreen != screen) {
 
-    TERN_(TOUCH_BUTTONS, repeat_delay = BUTTON_DELAY_MENU);
+    TERN_(HAS_TOUCH_XPT2046, repeat_delay = BUTTON_DELAY_MENU);
 
     TERN_(LCD_SET_PROGRESS_MANUALLY, progress_reset());
 

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index e858b5d537..2a9e4766d8 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -16,7 +16,7 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 

commit 0e1cb10909b47d939d0766c35cdd3cbbd1d37def
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jul 13 19:59:32 2020 -0500

    Fix / improve menu items (#18644)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 676b2d0a43..e858b5d537 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -186,6 +186,7 @@ DEFINE_MENU_EDIT_ITEM(float43);     // 1.234
 DEFINE_MENU_EDIT_ITEM(float5);      // 12345      right-justified
 DEFINE_MENU_EDIT_ITEM(float5_25);   // 12345      right-justified (25 increment)
 DEFINE_MENU_EDIT_ITEM(float51);     // 1234.5     right-justified
+DEFINE_MENU_EDIT_ITEM(float31sign); // +12.3
 DEFINE_MENU_EDIT_ITEM(float41sign); // +123.4
 DEFINE_MENU_EDIT_ITEM(float51sign); // +1234.5
 DEFINE_MENU_EDIT_ITEM(float52sign); // +123.45

commit b0c6cfb0511b8d71fec26ab91cd945f3d623b3c0
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Thu Jul 9 10:11:57 2020 +0200

    MarlinUI support for up to 5 Material Presets (#18488)
    
    - Add `I` preset parameter to `G26`, `M106`, `M140`, and `M190`.
    - Extend menu items to permit a string interpolation.
    - Keep material names in a list and interpolate in menu items.
    - Extend material presets to support up to 5 predefined materials.
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 7c384f1618..676b2d0a43 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -62,6 +62,7 @@ menuPosition screen_history[6];
 uint8_t screen_history_depth = 0;
 
 int8_t MenuItemBase::itemIndex;   // Index number for draw and action
+PGM_P MenuItemBase::itemString;   // A PSTR for substitution
 chimera_t editable;               // Value Editing
 
 // Menu Edit Items

commit f6a2b6409192c4e349321f42a5c0ebfd4e278b82
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jul 3 09:53:22 2020 -0500

    Clean up LCD Manual Move / UBL Mesh Edit (#18373)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 05491bfeea..7c384f1618 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -230,7 +230,7 @@ void MarlinUI::goto_screen(screenFunc_t screen, const uint16_t encoder/*=0*/, co
           screen = TERN(BABYSTEP_ZPROBE_OFFSET, lcd_babystep_zoffset, lcd_babystep_z);
         else {
           #if ENABLED(MOVE_Z_WHEN_IDLE)
-            move_menu_scale = MOVE_Z_IDLE_MULTIPLICATOR;
+            ui.manual_move.menu_scale = MOVE_Z_IDLE_MULTIPLICATOR;
             screen = lcd_move_z;
           #endif
         }

commit 2c15a787c7f235a64255beb7fb6264a7a35e3d36
Author: cbteeple <cbteeple@g.harvard.edu>
Date:   Fri Jul 3 10:24:41 2020 -0400

    Option to set manual Babystepping distance in mm (#18503)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 58a759655c..05491bfeea 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -343,7 +343,7 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
     ui.defer_status_screen();
     const bool do_probe = DISABLED(BABYSTEP_HOTEND_Z_OFFSET) || active_extruder == 0;
     if (ui.encoderPosition) {
-      const int16_t babystep_increment = int16_t(ui.encoderPosition) * (BABYSTEP_MULTIPLICATOR_Z);
+      const int16_t babystep_increment = int16_t(ui.encoderPosition) * (BABYSTEP_SIZE_Z);
       ui.encoderPosition = 0;
 
       const float diff = planner.steps_to_mm[Z_AXIS] * babystep_increment,

commit 1d504e596df79b0572de23f628af457a017b6be3
Author: Victor <rhapsodyv@gmail.com>
Date:   Thu Jun 11 23:21:18 2020 -0300

    Touch-to-jog on edit screens (#18266)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 0832ed8b3f..58a759655c 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -84,9 +84,8 @@ void MarlinUI::save_previous_screen() {
 }
 
 void MarlinUI::_goto_previous_screen(TERN_(TURBO_BACK_MENU_ITEM, const bool is_back/*=false*/)) {
-  #if DISABLED(TURBO_BACK_MENU_ITEM)
-    constexpr bool is_back = false;
-  #endif
+  TERN(TURBO_BACK_MENU_ITEM,,constexpr bool is_back = false);
+  TERN_(TOUCH_BUTTONS, on_edit_screen = false);
   if (screen_history_depth > 0) {
     menuPosition &sh = screen_history[--screen_history_depth];
     goto_screen(sh.menu_function,
@@ -155,6 +154,7 @@ void MenuEditItemBase::goto_edit_screen(
   const screenFunc_t cb,  // Callback after edit
   const bool le           // Flag to call cb() during editing
 ) {
+  TERN_(TOUCH_BUTTONS, ui.on_edit_screen = true);
   ui.screen_changed = true;
   ui.save_previous_screen();
   ui.refresh();

commit 67305f7976c8ec66459f22e80add8b040fc4c6a4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jun 10 18:35:56 2020 -0500

    Add "Bed" / "Chamber" substitutions (#18255)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 9d406c1a37..0832ed8b3f 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -61,7 +61,7 @@ typedef struct {
 menuPosition screen_history[6];
 uint8_t screen_history_depth = 0;
 
-uint8_t MenuItemBase::itemIndex;  // Index number for draw and action
+int8_t MenuItemBase::itemIndex;   // Index number for draw and action
 chimera_t editable;               // Value Editing
 
 // Menu Edit Items

commit d35dd2a47e78be6a39e99acc1bf5a8e8cbe71ac0
Author: Daniel Callander <Knifa@users.noreply.github.com>
Date:   Tue May 12 04:01:47 2020 +0100

    Fix babystep / double-click check (#17962)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index dfd55ae682..9d406c1a37 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -224,7 +224,7 @@ void MarlinUI::goto_screen(screenFunc_t screen, const uint16_t encoder/*=0*/, co
         if (on_status_screen())
           doubleclick_expire_ms = millis() + DOUBLECLICK_MAX_INTERVAL;
       }
-      else if (on_status_screen() && currentScreen == menu_main && PENDING(millis(), doubleclick_expire_ms)) {
+      else if (screen == status_screen && currentScreen == menu_main && PENDING(millis(), doubleclick_expire_ms)) {
         if ( (ENABLED(BABYSTEP_WITHOUT_HOMING) || all_axes_known())
           && (ENABLED(BABYSTEP_ALWAYS_AVAILABLE) || printer_busy()) )
           screen = TERN(BABYSTEP_ZPROBE_OFFSET, lcd_babystep_zoffset, lcd_babystep_z);

commit 71b41c963b617204f45286cddd029d4c1a4c664c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 10 00:37:19 2020 -0500

    Better EEPROM alert message

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 013186a92a..dfd55ae682 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -402,7 +402,11 @@ bool MarlinUI::update_selection() {
   return selection;
 }
 
-void MenuItem_confirm::select_screen(PGM_P const yes, PGM_P const no, selectFunc_t yesFunc, selectFunc_t noFunc, PGM_P const pref, const char * const string/*=nullptr*/, PGM_P const suff/*=nullptr*/) {
+void MenuItem_confirm::select_screen(
+  PGM_P const yes, PGM_P const no,
+  selectFunc_t yesFunc, selectFunc_t noFunc,
+  PGM_P const pref, const char * const string/*=nullptr*/, PGM_P const suff/*=nullptr*/
+) {
   const bool ui_selection = ui.update_selection(), got_click = ui.use_click();
   if (got_click || ui.should_draw()) {
     draw_select_screen(yes, no, ui_selection, pref, string, suff);

commit 52aa459a2dc08a8f803ad9ffb7aa173dc449637f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 10 00:12:56 2020 -0500

    Improved EEPROM boot error (#17916)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 39e8899313..013186a92a 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -34,10 +34,6 @@
   #include "../../libs/buzzer.h"
 #endif
 
-#if ENABLED(EEPROM_SETTINGS)
-  #include "../../module/configuration_store.h"
-#endif
-
 #if WATCH_HOTENDS || WATCH_BED
   #include "../../module/temperature.h"
 #endif
@@ -228,7 +224,7 @@ void MarlinUI::goto_screen(screenFunc_t screen, const uint16_t encoder/*=0*/, co
         if (on_status_screen())
           doubleclick_expire_ms = millis() + DOUBLECLICK_MAX_INTERVAL;
       }
-      else if (screen == status_screen && currentScreen == menu_main && PENDING(millis(), doubleclick_expire_ms)) {
+      else if (on_status_screen() && currentScreen == menu_main && PENDING(millis(), doubleclick_expire_ms)) {
         if ( (ENABLED(BABYSTEP_WITHOUT_HOMING) || all_axes_known())
           && (ENABLED(BABYSTEP_ALWAYS_AVAILABLE) || printer_busy()) )
           screen = TERN(BABYSTEP_ZPROBE_OFFSET, lcd_babystep_zoffset, lcd_babystep_z);
@@ -245,7 +241,7 @@ void MarlinUI::goto_screen(screenFunc_t screen, const uint16_t encoder/*=0*/, co
     encoderPosition = encoder;
     encoderTopLine = top;
     screen_items = items;
-    if (screen == status_screen) {
+    if (on_status_screen()) {
       defer_status_screen(false);
       TERN_(AUTO_BED_LEVELING_UBL, ubl.lcd_map_control = false);
       screen_history_depth = 0;
@@ -256,7 +252,7 @@ void MarlinUI::goto_screen(screenFunc_t screen, const uint16_t encoder/*=0*/, co
     // Re-initialize custom characters that may be re-used
     #if HAS_CHARACTER_LCD
       if (TERN1(AUTO_BED_LEVELING_UBL, !ubl.lcd_map_control))
-        set_custom_characters(screen == status_screen ? CHARSET_INFO : CHARSET_MENU);
+        set_custom_characters(on_status_screen() ? CHARSET_INFO : CHARSET_MENU);
     #endif
 
     refresh(LCDVIEW_CALL_REDRAW_NEXT);
@@ -383,11 +379,6 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
 
 #endif // BABYSTEP_ZPROBE_OFFSET
 
-#if ENABLED(EEPROM_SETTINGS)
-  void lcd_store_settings() { ui.completion_feedback(settings.save()); }
-  void lcd_load_settings()  { ui.completion_feedback(settings.load()); }
-#endif
-
 void _lcd_draw_homing() {
   constexpr uint8_t line = (LCD_HEIGHT - 1) / 2;
   if (ui.should_draw()) MenuItem_static::draw(line, GET_TEXT(MSG_LEVEL_BED_HOMING));
@@ -416,6 +407,7 @@ void MenuItem_confirm::select_screen(PGM_P const yes, PGM_P const no, selectFunc
   if (got_click || ui.should_draw()) {
     draw_select_screen(yes, no, ui_selection, pref, string, suff);
     if (got_click) { ui_selection ? yesFunc() : noFunc(); }
+    ui.defer_status_screen();
   }
 }
 

commit c536b8de629807b489f054051bb120457f112a11
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Apr 25 17:53:06 2020 -0500

    Apply ternary macros

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 1518e1f50a..39e8899313 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -87,11 +87,7 @@ void MarlinUI::save_previous_screen() {
     screen_history[screen_history_depth++] = { currentScreen, encoderPosition, encoderTopLine, screen_items };
 }
 
-void MarlinUI::_goto_previous_screen(
-  #if ENABLED(TURBO_BACK_MENU_ITEM)
-    const bool is_back/*=false*/
-  #endif
-) {
+void MarlinUI::_goto_previous_screen(TERN_(TURBO_BACK_MENU_ITEM, const bool is_back/*=false*/)) {
   #if DISABLED(TURBO_BACK_MENU_ITEM)
     constexpr bool is_back = false;
   #endif
@@ -233,33 +229,15 @@ void MarlinUI::goto_screen(screenFunc_t screen, const uint16_t encoder/*=0*/, co
           doubleclick_expire_ms = millis() + DOUBLECLICK_MAX_INTERVAL;
       }
       else if (screen == status_screen && currentScreen == menu_main && PENDING(millis(), doubleclick_expire_ms)) {
-
-        #if ENABLED(BABYSTEP_WITHOUT_HOMING)
-          constexpr bool can_babystep = true;
-        #else
-          const bool can_babystep = all_axes_known();
-        #endif
-        #if ENABLED(BABYSTEP_ALWAYS_AVAILABLE)
-          constexpr bool should_babystep = true;
-        #else
-          const bool should_babystep = printer_busy();
-        #endif
-
-        if (should_babystep && can_babystep) {
-          screen =
-            #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
-              lcd_babystep_zoffset
-            #else
-              lcd_babystep_z
-            #endif
-          ;
-        }
-        #if ENABLED(MOVE_Z_WHEN_IDLE)
-          else {
+        if ( (ENABLED(BABYSTEP_WITHOUT_HOMING) || all_axes_known())
+          && (ENABLED(BABYSTEP_ALWAYS_AVAILABLE) || printer_busy()) )
+          screen = TERN(BABYSTEP_ZPROBE_OFFSET, lcd_babystep_zoffset, lcd_babystep_z);
+        else {
+          #if ENABLED(MOVE_Z_WHEN_IDLE)
             move_menu_scale = MOVE_Z_IDLE_MULTIPLICATOR;
             screen = lcd_move_z;
-          }
-        #endif
+          #endif
+        }
       }
     #endif
 
@@ -277,11 +255,8 @@ void MarlinUI::goto_screen(screenFunc_t screen, const uint16_t encoder/*=0*/, co
 
     // Re-initialize custom characters that may be re-used
     #if HAS_CHARACTER_LCD
-      if (true
-        #if ENABLED(AUTO_BED_LEVELING_UBL)
-          && !ubl.lcd_map_control
-        #endif
-      ) set_custom_characters(screen == status_screen ? CHARSET_INFO : CHARSET_MENU);
+      if (TERN1(AUTO_BED_LEVELING_UBL, !ubl.lcd_map_control))
+        set_custom_characters(screen == status_screen ? CHARSET_INFO : CHARSET_MENU);
     #endif
 
     refresh(LCDVIEW_CALL_REDRAW_NEXT);
@@ -377,13 +352,10 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
 
       const float diff = planner.steps_to_mm[Z_AXIS] * babystep_increment,
                   new_probe_offset = probe.offset.z + diff,
-                  new_offs =
-                    #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
-                      do_probe ? new_probe_offset : hotend_offset[active_extruder].z - diff
-                    #else
-                      new_probe_offset
-                    #endif
-                  ;
+                  new_offs = TERN(BABYSTEP_HOTEND_Z_OFFSET
+                    , do_probe ? new_probe_offset : hotend_offset[active_extruder].z - diff
+                    , new_probe_offset
+                  );
       if (WITHIN(new_offs, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
 
         babystep.add_steps(Z_AXIS, babystep_increment);
@@ -397,30 +369,23 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
       }
     }
     if (ui.should_draw()) {
-      #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
-        if (!do_probe)
-          MenuEditItemBase::draw_edit_screen(GET_TEXT(MSG_HOTEND_OFFSET_Z), ftostr54sign(hotend_offset[active_extruder].z));
-      #endif
       if (do_probe) {
         MenuEditItemBase::draw_edit_screen(GET_TEXT(MSG_ZPROBE_ZOFFSET), BABYSTEP_TO_STR(probe.offset.z));
         TERN_(BABYSTEP_ZPROBE_GFX_OVERLAY, _lcd_zoffset_overlay_gfx(probe.offset.z));
       }
+      else {
+        #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
+          MenuEditItemBase::draw_edit_screen(GET_TEXT(MSG_HOTEND_OFFSET_Z), ftostr54sign(hotend_offset[active_extruder].z));
+        #endif
+      }
     }
   }
 
 #endif // BABYSTEP_ZPROBE_OFFSET
 
 #if ENABLED(EEPROM_SETTINGS)
-  void lcd_store_settings() {
-    const bool saved = settings.save();
-    ui.completion_feedback(saved);
-    UNUSED(saved);
-  }
-  void lcd_load_settings() {
-    const bool loaded = settings.load();
-    ui.completion_feedback(loaded);
-    UNUSED(loaded);
-  }
+  void lcd_store_settings() { ui.completion_feedback(settings.save()); }
+  void lcd_load_settings()  { ui.completion_feedback(settings.load()); }
 #endif
 
 void _lcd_draw_homing() {

commit 69f211cf78c1b25469fbd1f6e4c28e0aa6dd6b0a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Apr 23 15:14:32 2020 -0500

    Add empty ui.completion_feedback

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 1698c7d7ad..1518e1f50a 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -413,12 +413,12 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
 #if ENABLED(EEPROM_SETTINGS)
   void lcd_store_settings() {
     const bool saved = settings.save();
-    TERN_(HAS_BUZZER, ui.completion_feedback(saved));
+    ui.completion_feedback(saved);
     UNUSED(saved);
   }
   void lcd_load_settings() {
     const bool loaded = settings.load();
-    TERN_(HAS_BUZZER, ui.completion_feedback(loaded));
+    ui.completion_feedback(loaded);
     UNUSED(loaded);
   }
 #endif

commit 6d90d1e1f552dca5e21bc61b676b8e8ce731b280
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 22 16:35:03 2020 -0500

    Apply TERN to compact code (#17619)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 3dd9932044..1698c7d7ad 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -141,9 +141,7 @@ void MenuItem_gcode::action(PGM_P const, PGM_P const pgcode) { queue.inject_P(pg
  *       MenuItem_int3::draw(encoderLine == _thisItemNr, _lcdLineNr, plabel, &feedrate_percentage, 10, 999)
  */
 void MenuEditItemBase::edit_screen(strfunc_t strfunc, loadfunc_t loadfunc) {
-  #if ENABLED(TOUCH_BUTTONS)
-    ui.repeat_delay = BUTTON_DELAY_EDIT;
-  #endif
+  TERN_(TOUCH_BUTTONS, ui.repeat_delay = BUTTON_DELAY_EDIT);
   if (int32_t(ui.encoderPosition) < 0) ui.encoderPosition = 0;
   if (int32_t(ui.encoderPosition) > maxEditValue) ui.encoderPosition = maxEditValue;
   if (ui.should_draw())
@@ -222,13 +220,9 @@ bool printer_busy() {
 void MarlinUI::goto_screen(screenFunc_t screen, const uint16_t encoder/*=0*/, const uint8_t top/*=0*/, const uint8_t items/*=0*/) {
   if (currentScreen != screen) {
 
-    #if ENABLED(TOUCH_BUTTONS)
-      repeat_delay = BUTTON_DELAY_MENU;
-    #endif
+    TERN_(TOUCH_BUTTONS, repeat_delay = BUTTON_DELAY_MENU);
 
-    #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
-      progress_reset();
-    #endif
+    TERN_(LCD_SET_PROGRESS_MANUALLY, progress_reset());
 
     #if BOTH(DOUBLECLICK_FOR_Z_BABYSTEPPING, BABYSTEPPING)
       static millis_t doubleclick_expire_ms = 0;
@@ -275,9 +269,7 @@ void MarlinUI::goto_screen(screenFunc_t screen, const uint16_t encoder/*=0*/, co
     screen_items = items;
     if (screen == status_screen) {
       defer_status_screen(false);
-      #if ENABLED(AUTO_BED_LEVELING_UBL)
-        ubl.lcd_map_control = false;
-      #endif
+      TERN_(AUTO_BED_LEVELING_UBL, ubl.lcd_map_control = false);
       screen_history_depth = 0;
     }
 
@@ -294,13 +286,9 @@ void MarlinUI::goto_screen(screenFunc_t screen, const uint16_t encoder/*=0*/, co
 
     refresh(LCDVIEW_CALL_REDRAW_NEXT);
     screen_changed = true;
-    #if HAS_GRAPHICAL_LCD
-      drawing_screen = false;
-    #endif
+    TERN_(HAS_GRAPHICAL_LCD, drawing_screen = false);
 
-    #if HAS_LCD_MENU
-      encoder_direction_normal();
-    #endif
+    TERN_(HAS_LCD_MENU, encoder_direction_normal());
 
     set_selection(false);
   }
@@ -400,10 +388,10 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
 
         babystep.add_steps(Z_AXIS, babystep_increment);
 
-        if (do_probe) probe.offset.z = new_offs;
-        #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
-          else hotend_offset[active_extruder].z = new_offs;
-        #endif
+        if (do_probe)
+          probe.offset.z = new_offs;
+        else
+          TERN(BABYSTEP_HOTEND_Z_OFFSET, hotend_offset[active_extruder].z = new_offs, NOOP);
 
         ui.refresh(LCDVIEW_CALL_REDRAW_NEXT);
       }
@@ -415,9 +403,7 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
       #endif
       if (do_probe) {
         MenuEditItemBase::draw_edit_screen(GET_TEXT(MSG_ZPROBE_ZOFFSET), BABYSTEP_TO_STR(probe.offset.z));
-        #if ENABLED(BABYSTEP_ZPROBE_GFX_OVERLAY)
-          _lcd_zoffset_overlay_gfx(probe.offset.z);
-        #endif
+        TERN_(BABYSTEP_ZPROBE_GFX_OVERLAY, _lcd_zoffset_overlay_gfx(probe.offset.z));
       }
     }
   }
@@ -427,16 +413,12 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
 #if ENABLED(EEPROM_SETTINGS)
   void lcd_store_settings() {
     const bool saved = settings.save();
-    #if HAS_BUZZER
-      ui.completion_feedback(saved);
-    #endif
+    TERN_(HAS_BUZZER, ui.completion_feedback(saved));
     UNUSED(saved);
   }
   void lcd_load_settings() {
     const bool loaded = settings.load();
-    #if HAS_BUZZER
-      ui.completion_feedback(loaded);
-    #endif
+    TERN_(HAS_BUZZER, ui.completion_feedback(loaded));
     UNUSED(loaded);
   }
 #endif

commit e4903396d4ac2fa9b89dd535dae9c3e8a68b3526
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 11 20:36:17 2020 -0500

    Fix up pausing / parking display (#17460)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 192125c7d0..3dd9932044 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -76,9 +76,6 @@ int32_t      MenuEditItemBase::minEditValue,
 screenFunc_t MenuEditItemBase::callbackFunc;
 bool         MenuEditItemBase::liveEdit;
 
-// Prevent recursion into screen handlers
-bool no_reentry = false;
-
 ////////////////////////////////////////////
 //////// Menu Navigation & History /////////
 ////////////////////////////////////////////
@@ -314,29 +311,18 @@ void MarlinUI::goto_screen(screenFunc_t screen, const uint16_t encoder/*=0*/, co
 ////////////////////////////////////////////
 
 //
-// Display the synchronize screen until moves are
-// finished, and don't return to the caller until
-// done. ** This blocks the command queue! **
+// Display a "synchronize" screen with a custom message until
+// all moves are finished. Go back to calling screen when done.
 //
-static PGM_P sync_message;
-
-void MarlinUI::_synchronize() {
-  if (should_draw()) MenuItem_static::draw(LCD_HEIGHT >= 4, sync_message);
-  if (no_reentry) return;
-  // Make this the current handler till all moves are done
-  const screenFunc_t old_screen = currentScreen;
-  goto_screen(_synchronize);
-  no_reentry = true;
-  planner.synchronize(); // idle() is called until moves complete
-  no_reentry = false;
-  goto_screen(old_screen);
-}
-
-// Display the synchronize screen with a custom message
-// ** This blocks the command queue! **
 void MarlinUI::synchronize(PGM_P const msg/*=nullptr*/) {
-  sync_message = msg ?: GET_TEXT(MSG_MOVING);
-  _synchronize();
+  static PGM_P sync_message = msg ?: GET_TEXT(MSG_MOVING);
+  save_previous_screen();
+  goto_screen([]{
+    if (should_draw()) MenuItem_static::draw(LCD_HEIGHT >= 4, sync_message);
+  });
+  defer_status_screen();
+  planner.synchronize(); // idle() is called until moves complete
+  goto_previous_screen_no_defer();
 }
 
 /**

commit 48919c54fb4e793b6bb17022f9badbd3530733ae
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Apr 9 20:05:58 2020 -0500

    Add SRAM command injection (#17459)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 501120252a..192125c7d0 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -438,22 +438,6 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
 
 #endif // BABYSTEP_ZPROBE_OFFSET
 
-#if ANY(AUTO_BED_LEVELING_UBL, PID_AUTOTUNE_MENU, ADVANCED_PAUSE_FEATURE)
-
-  void lcd_enqueue_one_now(const char * const cmd) {
-    no_reentry = true;
-    queue.enqueue_one_now(cmd);
-    no_reentry = false;
-  }
-
-  void lcd_enqueue_one_now_P(PGM_P const cmd) {
-    no_reentry = true;
-    queue.enqueue_now_P(cmd);
-    no_reentry = false;
-  }
-
-#endif
-
 #if ENABLED(EEPROM_SETTINGS)
   void lcd_store_settings() {
     const bool saved = settings.save();

commit 1f5824247f632af71b1725f8bb41e66f55b14919
Author: Joe Prints <33383148+JoePrints@users.noreply.github.com>
Date:   Tue Mar 17 15:12:52 2020 -0500

    More decimal places for babystep / Z probe offset (#17195)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 959c1c4160..501120252a 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -193,7 +193,7 @@ DEFINE_MENU_EDIT_ITEM(uint16_3);    // 123        right-justified
 DEFINE_MENU_EDIT_ITEM(uint16_4);    // 1234       right-justified
 DEFINE_MENU_EDIT_ITEM(uint16_5);    // 12345      right-justified
 DEFINE_MENU_EDIT_ITEM(float3);      // 123        right-justified
-DEFINE_MENU_EDIT_ITEM(float52);     // _2.34, 12.34, -2.34 or 123.45, -23.45
+DEFINE_MENU_EDIT_ITEM(float42_52);  // _2.34, 12.34, -2.34 or 123.45, -23.45
 DEFINE_MENU_EDIT_ITEM(float43);     // 1.234
 DEFINE_MENU_EDIT_ITEM(float5);      // 12345      right-justified
 DEFINE_MENU_EDIT_ITEM(float5_25);   // 12345      right-justified (25 increment)
@@ -428,7 +428,7 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
           MenuEditItemBase::draw_edit_screen(GET_TEXT(MSG_HOTEND_OFFSET_Z), ftostr54sign(hotend_offset[active_extruder].z));
       #endif
       if (do_probe) {
-        MenuEditItemBase::draw_edit_screen(GET_TEXT(MSG_ZPROBE_ZOFFSET), ftostr52sign(probe.offset.z));
+        MenuEditItemBase::draw_edit_screen(GET_TEXT(MSG_ZPROBE_ZOFFSET), BABYSTEP_TO_STR(probe.offset.z));
         #if ENABLED(BABYSTEP_ZPROBE_GFX_OVERLAY)
           _lcd_zoffset_overlay_gfx(probe.offset.z);
         #endif

commit 13118dbd8d9142d7698ca113cb05d1feae3b1bd3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 8 19:42:18 2020 -0500

    Additional numtostr functions

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index f1bcb970d4..959c1c4160 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -127,7 +127,7 @@ void MenuItem_gcode::action(PGM_P const, PGM_P const pgcode) { queue.inject_P(pg
  *
  * The prerequisite is that in the header the type was already declared:
  *
- *   DEFINE_MENU_EDIT_ITEM_TYPE(int16_t, int3, i16tostr3, 1)
+ *   DEFINE_MENU_EDIT_ITEM_TYPE(int3, int16_t, i16tostr3rj, 1)
  *
  * For example, DEFINE_MENU_EDIT_ITEM(int3) expands into:
  *
@@ -396,11 +396,7 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
   void lcd_babystep_zoffset() {
     if (ui.use_click()) return ui.goto_previous_screen_no_defer();
     ui.defer_status_screen();
-    #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
-      const bool do_probe = (active_extruder == 0);
-    #else
-      constexpr bool do_probe = true;
-    #endif
+    const bool do_probe = DISABLED(BABYSTEP_HOTEND_Z_OFFSET) || active_extruder == 0;
     if (ui.encoderPosition) {
       const int16_t babystep_increment = int16_t(ui.encoderPosition) * (BABYSTEP_MULTIPLICATOR_Z);
       ui.encoderPosition = 0;
@@ -429,14 +425,14 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
     if (ui.should_draw()) {
       #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
         if (!do_probe)
-          MenuEditItemBase::draw_edit_screen(GET_TEXT(MSG_HOTEND_OFFSET_Z), LCD_Z_OFFSET_FUNC(hotend_offset[active_extruder].z));
-        else
-      #endif
-          MenuEditItemBase::draw_edit_screen(GET_TEXT(MSG_ZPROBE_ZOFFSET), LCD_Z_OFFSET_FUNC(probe.offset.z));
-
-      #if ENABLED(BABYSTEP_ZPROBE_GFX_OVERLAY)
-        if (do_probe) _lcd_zoffset_overlay_gfx(probe.offset.z);
+          MenuEditItemBase::draw_edit_screen(GET_TEXT(MSG_HOTEND_OFFSET_Z), ftostr54sign(hotend_offset[active_extruder].z));
       #endif
+      if (do_probe) {
+        MenuEditItemBase::draw_edit_screen(GET_TEXT(MSG_ZPROBE_ZOFFSET), ftostr52sign(probe.offset.z));
+        #if ENABLED(BABYSTEP_ZPROBE_GFX_OVERLAY)
+          _lcd_zoffset_overlay_gfx(probe.offset.z);
+        #endif
+      }
     }
   }
 

commit 5071fe82ab221627ef10cf4125896e3d2585993a
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Feb 25 22:18:14 2020 -0600

    Ensure proper SD print completion (#16967)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index f787e492e8..f1bcb970d4 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -324,9 +324,9 @@ void MarlinUI::_synchronize() {
   if (should_draw()) MenuItem_static::draw(LCD_HEIGHT >= 4, sync_message);
   if (no_reentry) return;
   // Make this the current handler till all moves are done
-  no_reentry = true;
   const screenFunc_t old_screen = currentScreen;
   goto_screen(_synchronize);
+  no_reentry = true;
   planner.synchronize(); // idle() is called until moves complete
   no_reentry = false;
   goto_screen(old_screen);

commit bfad23d3e2e590b257ebe4317d7b14cc2dd3435c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 3 08:00:57 2020 -0600

    (c) 2020

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 269709bf24..f787e492e8 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -1,6 +1,6 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm

commit 7f9c62437e5c72947acc3310d94829f132697c81
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Feb 3 00:00:35 2020 -0600

    Corner Leveling: Add inset for each side (#16759)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 9c3cf057d6..269709bf24 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -384,7 +384,7 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
 
   void line_to_z(const float &z) {
     current_position.z = z;
-    line_to_current_position(MMM_TO_MMS(manual_feedrate_mm_m.z));
+    line_to_current_position(manual_feedrate_mm_s.z);
   }
 
 #endif

commit 90b6324563b806ea7dc24ddf299f055dc4854341
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Feb 1 04:21:36 2020 -0600

    Encapsulate probe as singleton class (#16751)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 2bae1258e9..9c3cf057d6 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -406,7 +406,7 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
       ui.encoderPosition = 0;
 
       const float diff = planner.steps_to_mm[Z_AXIS] * babystep_increment,
-                  new_probe_offset = probe_offset.z + diff,
+                  new_probe_offset = probe.offset.z + diff,
                   new_offs =
                     #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
                       do_probe ? new_probe_offset : hotend_offset[active_extruder].z - diff
@@ -418,7 +418,7 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
 
         babystep.add_steps(Z_AXIS, babystep_increment);
 
-        if (do_probe) probe_offset.z = new_offs;
+        if (do_probe) probe.offset.z = new_offs;
         #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
           else hotend_offset[active_extruder].z = new_offs;
         #endif
@@ -432,10 +432,10 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
           MenuEditItemBase::draw_edit_screen(GET_TEXT(MSG_HOTEND_OFFSET_Z), LCD_Z_OFFSET_FUNC(hotend_offset[active_extruder].z));
         else
       #endif
-          MenuEditItemBase::draw_edit_screen(GET_TEXT(MSG_ZPROBE_ZOFFSET), LCD_Z_OFFSET_FUNC(probe_offset.z));
+          MenuEditItemBase::draw_edit_screen(GET_TEXT(MSG_ZPROBE_ZOFFSET), LCD_Z_OFFSET_FUNC(probe.offset.z));
 
       #if ENABLED(BABYSTEP_ZPROBE_GFX_OVERLAY)
-        if (do_probe) _lcd_zoffset_overlay_gfx(probe_offset.z);
+        if (do_probe) _lcd_zoffset_overlay_gfx(probe.offset.z);
       #endif
     }
   }

commit d129ac1b37b96a48f7c4cb87ca3f71e7b5e783bc
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Thu Jan 2 21:40:40 2020 -0500

    Z-offset edit precision based on value limits (#16425)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 1f7db8a8ea..2bae1258e9 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -429,10 +429,10 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
     if (ui.should_draw()) {
       #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
         if (!do_probe)
-          MenuEditItemBase::draw_edit_screen(GET_TEXT(MSG_HOTEND_OFFSET_Z), ftostr43sign(hotend_offset[active_extruder].z));
+          MenuEditItemBase::draw_edit_screen(GET_TEXT(MSG_HOTEND_OFFSET_Z), LCD_Z_OFFSET_FUNC(hotend_offset[active_extruder].z));
         else
       #endif
-          MenuEditItemBase::draw_edit_screen(GET_TEXT(MSG_ZPROBE_ZOFFSET), ftostr43sign(probe_offset.z));
+          MenuEditItemBase::draw_edit_screen(GET_TEXT(MSG_ZPROBE_ZOFFSET), LCD_Z_OFFSET_FUNC(probe_offset.z));
 
       #if ENABLED(BABYSTEP_ZPROBE_GFX_OVERLAY)
         if (do_probe) _lcd_zoffset_overlay_gfx(probe_offset.z);

commit d0e1166cce60381fbdad1105d13765806a525d99
Author: Dirk O. Kaar <19971886+dok-net@users.noreply.github.com>
Date:   Fri Jan 3 02:01:38 2020 +0100

    Fix Visual Micro "Arduino IDE for Visual Studio" support (#16418)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index f4a2e6cbbd..1f7db8a8ea 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -213,7 +213,7 @@ void MenuItem_bool::action(PGM_P const, bool * const ptr, screenFunc_t callback)
 ///////////////// Menu Tree ////////////////
 ////////////////////////////////////////////
 
-#include "../../Marlin.h"
+#include "../../MarlinCore.h"
 
 bool printer_busy() {
   return planner.movesplanned() || printingIsActive();

commit 27cb4db80eae73eb842f1a944260517bb8783eb3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Nov 14 20:30:30 2019 -0600

    Reduced string storage using tokens (#15593)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index fda49bb51e..f4a2e6cbbd 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -64,15 +64,17 @@ typedef struct {
 } menuPosition;
 menuPosition screen_history[6];
 uint8_t screen_history_depth = 0;
-bool screen_changed;
 
-// Value Editing
-chimera_t editable;
-PGM_P MenuEditItemBase::editLabel;
-void* MenuEditItemBase::editValue;
-int32_t MenuEditItemBase::minEditValue, MenuEditItemBase::maxEditValue;
+uint8_t MenuItemBase::itemIndex;  // Index number for draw and action
+chimera_t editable;               // Value Editing
+
+// Menu Edit Items
+PGM_P        MenuEditItemBase::editLabel;
+void*        MenuEditItemBase::editValue;
+int32_t      MenuEditItemBase::minEditValue,
+             MenuEditItemBase::maxEditValue;
 screenFunc_t MenuEditItemBase::callbackFunc;
-bool MenuEditItemBase::liveEdit;
+bool         MenuEditItemBase::liveEdit;
 
 // Prevent recursion into screen handlers
 bool no_reentry = false;
@@ -121,17 +123,15 @@ void MenuItem_gcode::action(PGM_P const, PGM_P const pgcode) { queue.inject_P(pg
 /**
  * Functions for editing single values
  *
- * The "DEFINE_MENU_EDIT_ITEM" macro generates the functions needed to edit a numerical value.
+ * The "DEFINE_MENU_EDIT_ITEM" macro generates the classes needed to edit a numerical value.
  *
  * The prerequisite is that in the header the type was already declared:
  *
- *   DECLARE_MENU_EDIT_TYPE(int16_t, int3, i16tostr3, 1)
+ *   DEFINE_MENU_EDIT_ITEM_TYPE(int16_t, int3, i16tostr3, 1)
  *
- * For example, DEFINE_MENU_EDIT_ITEM(int3) expands into these functions:
+ * For example, DEFINE_MENU_EDIT_ITEM(int3) expands into:
  *
- *   bool MenuItem_int3::_edit();
- *   void MenuItem_int3::edit(); // edit int16_t (interactively)
- *   void MenuItem_int3::action(PGM_P const pstr, int16_t * const ptr, const int32_t minValue, const int32_t maxValue, const screenFunc_t callback = null, const bool live = false);
+ *   template class TMenuEditItem<MenuEditItemInfo_int3>
  *
  * You can then use one of the menu macros to present the edit interface:
  *   EDIT_ITEM(int3, MSG_SPEED, &feedrate_percentage, 10, 999)
@@ -143,14 +143,14 @@ void MenuItem_gcode::action(PGM_P const, PGM_P const pgcode) { queue.inject_P(pg
  *       MenuItem_int3::action(plabel, &feedrate_percentage, 10, 999)
  *       MenuItem_int3::draw(encoderLine == _thisItemNr, _lcdLineNr, plabel, &feedrate_percentage, 10, 999)
  */
-void MenuEditItemBase::edit(strfunc_t strfunc, loadfunc_t loadfunc) {
+void MenuEditItemBase::edit_screen(strfunc_t strfunc, loadfunc_t loadfunc) {
   #if ENABLED(TOUCH_BUTTONS)
     ui.repeat_delay = BUTTON_DELAY_EDIT;
   #endif
   if (int32_t(ui.encoderPosition) < 0) ui.encoderPosition = 0;
   if (int32_t(ui.encoderPosition) > maxEditValue) ui.encoderPosition = maxEditValue;
   if (ui.should_draw())
-    edit_screen(editLabel, strfunc(ui.encoderPosition + minEditValue));
+    draw_edit_screen(strfunc(ui.encoderPosition + minEditValue));
   if (ui.lcd_clicked || (liveEdit && ui.should_draw())) {
     if (editValue != nullptr) loadfunc(editValue, ui.encoderPosition + minEditValue);
     if (callbackFunc && (liveEdit || ui.lcd_clicked)) (*callbackFunc)();
@@ -158,7 +158,17 @@ void MenuEditItemBase::edit(strfunc_t strfunc, loadfunc_t loadfunc) {
   }
 }
 
-void MenuEditItemBase::init(PGM_P const el, void * const ev, const int32_t minv, const int32_t maxv, const uint16_t ep, const screenFunc_t cs, const screenFunc_t cb, const bool le) {
+void MenuEditItemBase::goto_edit_screen(
+  PGM_P const el,         // Edit label
+  void * const ev,        // Edit value pointer
+  const int32_t minv,     // Encoder minimum
+  const int32_t maxv,     // Encoder maximum
+  const uint16_t ep,      // Initial encoder value
+  const screenFunc_t cs,  // MenuItem_type::draw_edit_screen => MenuEditItemBase::edit()
+  const screenFunc_t cb,  // Callback after edit
+  const bool le           // Flag to call cb() during editing
+) {
+  ui.screen_changed = true;
   ui.save_previous_screen();
   ui.refresh();
   editLabel = el;
@@ -171,6 +181,7 @@ void MenuEditItemBase::init(PGM_P const el, void * const ev, const int32_t minv,
   liveEdit = le;
 }
 
+// TODO: Remove these but test build size with and without
 #define DEFINE_MENU_EDIT_ITEM(NAME) template class TMenuEditItem<MenuEditItemInfo_##NAME>
 
 DEFINE_MENU_EDIT_ITEM(percent);     // 100%       right-justified
@@ -193,8 +204,8 @@ DEFINE_MENU_EDIT_ITEM(float52sign); // +123.45
 DEFINE_MENU_EDIT_ITEM(long5);       // 12345      right-justified
 DEFINE_MENU_EDIT_ITEM(long5_25);    // 12345      right-justified (25 increment)
 
-void MenuItem_bool::action(PGM_P pstr, bool *ptr, screenFunc_t callback) {
-  UNUSED(pstr); *ptr ^= true; ui.refresh();
+void MenuItem_bool::action(PGM_P const, bool * const ptr, screenFunc_t callback) {
+  *ptr ^= true; ui.refresh();
   if (callback) (*callback)();
 }
 
@@ -344,7 +355,7 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
   if (int32_t(ui.encoderPosition) < 0) ui.encoderPosition = 0;
   if (ui.first_page) {
     encoderLine = ui.encoderPosition / (ENCODER_STEPS_PER_MENU_ITEM);
-    screen_changed = false;
+    ui.screen_changed = false;
   }
   if (screen_items > 0 && encoderLine >= screen_items - limit) {
     encoderLine = _MAX(0, screen_items - limit);
@@ -418,10 +429,10 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
     if (ui.should_draw()) {
       #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
         if (!do_probe)
-          MenuEditItemBase::edit_screen(GET_TEXT(MSG_HOTEND_OFFSET_Z), ftostr43sign(hotend_offset[active_extruder].z));
+          MenuEditItemBase::draw_edit_screen(GET_TEXT(MSG_HOTEND_OFFSET_Z), ftostr43sign(hotend_offset[active_extruder].z));
         else
       #endif
-          MenuEditItemBase::edit_screen(GET_TEXT(MSG_ZPROBE_ZOFFSET), ftostr43sign(probe_offset.z));
+          MenuEditItemBase::draw_edit_screen(GET_TEXT(MSG_ZPROBE_ZOFFSET), ftostr43sign(probe_offset.z));
 
       #if ENABLED(BABYSTEP_ZPROBE_GFX_OVERLAY)
         if (do_probe) _lcd_zoffset_overlay_gfx(probe_offset.z);

commit b3f81eead5179d70e4e205f3ff0c9a8617ad780d
Author: Jason Smith <jason.inet@gmail.com>
Date:   Sat Nov 9 17:27:30 2019 -0800

    Fix/improve TURBO_BACK_MENU_ITEM (#15856)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 56f47cfe45..fda49bb51e 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -88,7 +88,7 @@ void MarlinUI::save_previous_screen() {
     screen_history[screen_history_depth++] = { currentScreen, encoderPosition, encoderTopLine, screen_items };
 }
 
-void MarlinUI::goto_previous_screen(
+void MarlinUI::_goto_previous_screen(
   #if ENABLED(TURBO_BACK_MENU_ITEM)
     const bool is_back/*=false*/
   #endif

commit ed6bbe012b61f7ddf9844a5b23c58a5a947bd4ae
Author: Luu Lac <45380455+shitcreek@users.noreply.github.com>
Date:   Thu Nov 7 19:14:02 2019 -0600

    Fix incomplete 'Homing XYZ' screen draw (#15830)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index a41de36438..56f47cfe45 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -467,7 +467,6 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
 void _lcd_draw_homing() {
   constexpr uint8_t line = (LCD_HEIGHT - 1) / 2;
   if (ui.should_draw()) MenuItem_static::draw(line, GET_TEXT(MSG_LEVEL_BED_HOMING));
-  ui.refresh(LCDVIEW_CALL_NO_REDRAW);
 }
 
 #if ENABLED(LCD_BED_LEVELING) || (HAS_LEVELING && DISABLED(SLIM_LCD_MENUS))

commit ea3217cd4613d723567d9bc8ab375e68d75b294b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Nov 2 07:28:20 2019 -0500

    Move 'draw' methods into Menu Item classes (#15760)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 60461528d0..a41de36438 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -141,7 +141,7 @@ void MenuItem_gcode::action(PGM_P const, PGM_P const pgcode) { queue.inject_P(pg
  *
  * ...which calls:
  *       MenuItem_int3::action(plabel, &feedrate_percentage, 10, 999)
- *       draw_menu_item_int3(encoderLine == _thisItemNr, _lcdLineNr, plabel, &feedrate_percentage, 10, 999)
+ *       MenuItem_int3::draw(encoderLine == _thisItemNr, _lcdLineNr, plabel, &feedrate_percentage, 10, 999)
  */
 void MenuEditItemBase::edit(strfunc_t strfunc, loadfunc_t loadfunc) {
   #if ENABLED(TOUCH_BUTTONS)
@@ -150,7 +150,7 @@ void MenuEditItemBase::edit(strfunc_t strfunc, loadfunc_t loadfunc) {
   if (int32_t(ui.encoderPosition) < 0) ui.encoderPosition = 0;
   if (int32_t(ui.encoderPosition) > maxEditValue) ui.encoderPosition = maxEditValue;
   if (ui.should_draw())
-    draw_edit_screen(editLabel, strfunc(ui.encoderPosition + minEditValue));
+    edit_screen(editLabel, strfunc(ui.encoderPosition + minEditValue));
   if (ui.lcd_clicked || (liveEdit && ui.should_draw())) {
     if (editValue != nullptr) loadfunc(editValue, ui.encoderPosition + minEditValue);
     if (callbackFunc && (liveEdit || ui.lcd_clicked)) (*callbackFunc)();
@@ -187,6 +187,7 @@ DEFINE_MENU_EDIT_ITEM(float43);     // 1.234
 DEFINE_MENU_EDIT_ITEM(float5);      // 12345      right-justified
 DEFINE_MENU_EDIT_ITEM(float5_25);   // 12345      right-justified (25 increment)
 DEFINE_MENU_EDIT_ITEM(float51);     // 1234.5     right-justified
+DEFINE_MENU_EDIT_ITEM(float41sign); // +123.4
 DEFINE_MENU_EDIT_ITEM(float51sign); // +1234.5
 DEFINE_MENU_EDIT_ITEM(float52sign); // +123.45
 DEFINE_MENU_EDIT_ITEM(long5);       // 12345      right-justified
@@ -309,7 +310,7 @@ void MarlinUI::goto_screen(screenFunc_t screen, const uint16_t encoder/*=0*/, co
 static PGM_P sync_message;
 
 void MarlinUI::_synchronize() {
-  if (should_draw()) draw_menu_item_static(LCD_HEIGHT >= 4 ? 1 : 0, sync_message);
+  if (should_draw()) MenuItem_static::draw(LCD_HEIGHT >= 4, sync_message);
   if (no_reentry) return;
   // Make this the current handler till all moves are done
   no_reentry = true;
@@ -417,10 +418,10 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
     if (ui.should_draw()) {
       #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
         if (!do_probe)
-          draw_edit_screen(GET_TEXT(MSG_Z_OFFSET), ftostr43sign(hotend_offset[active_extruder].z));
+          MenuEditItemBase::edit_screen(GET_TEXT(MSG_HOTEND_OFFSET_Z), ftostr43sign(hotend_offset[active_extruder].z));
         else
       #endif
-          draw_edit_screen(GET_TEXT(MSG_ZPROBE_ZOFFSET), ftostr43sign(probe_offset.z));
+          MenuEditItemBase::edit_screen(GET_TEXT(MSG_ZPROBE_ZOFFSET), ftostr43sign(probe_offset.z));
 
       #if ENABLED(BABYSTEP_ZPROBE_GFX_OVERLAY)
         if (do_probe) _lcd_zoffset_overlay_gfx(probe_offset.z);
@@ -465,7 +466,7 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
 
 void _lcd_draw_homing() {
   constexpr uint8_t line = (LCD_HEIGHT - 1) / 2;
-  if (ui.should_draw()) draw_menu_item_static(line, GET_TEXT(MSG_LEVEL_BED_HOMING));
+  if (ui.should_draw()) MenuItem_static::draw(line, GET_TEXT(MSG_LEVEL_BED_HOMING));
   ui.refresh(LCDVIEW_CALL_NO_REDRAW);
 }
 
@@ -486,7 +487,8 @@ bool MarlinUI::update_selection() {
   }
   return selection;
 }
-void do_select_screen(PGM_P const yes, PGM_P const no, selectFunc_t yesFunc, selectFunc_t noFunc, PGM_P const pref, const char * const string/*=nullptr*/, PGM_P const suff/*=nullptr*/) {
+
+void MenuItem_confirm::select_screen(PGM_P const yes, PGM_P const no, selectFunc_t yesFunc, selectFunc_t noFunc, PGM_P const pref, const char * const string/*=nullptr*/, PGM_P const suff/*=nullptr*/) {
   const bool ui_selection = ui.update_selection(), got_click = ui.use_click();
   if (got_click || ui.should_draw()) {
     draw_select_screen(yes, no, ui_selection, pref, string, suff);

commit f139642e0fe99820766c577433e652e2b41ea8c9
Author: studiodyne <42887851+studiodyne@users.noreply.github.com>
Date:   Mon Oct 28 22:44:17 2019 +0100

    XY/Z Babystep Multiplicators (#15691)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 3c300843e0..60461528d0 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -390,7 +390,7 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
       constexpr bool do_probe = true;
     #endif
     if (ui.encoderPosition) {
-      const int16_t babystep_increment = int16_t(ui.encoderPosition) * (BABYSTEP_MULTIPLICATOR);
+      const int16_t babystep_increment = int16_t(ui.encoderPosition) * (BABYSTEP_MULTIPLICATOR_Z);
       ui.encoderPosition = 0;
 
       const float diff = planner.steps_to_mm[Z_AXIS] * babystep_increment,

commit 600429a067376cbc1d56efd064435458d6575a8c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 25 19:49:48 2019 -0500

    Cancel Objects followup

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index eac5b7b2d7..3c300843e0 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -25,7 +25,6 @@
 #if HAS_LCD_MENU
 
 #include "menu.h"
-#include "../ultralcd.h"
 #include "../../module/planner.h"
 #include "../../module/motion.h"
 #include "../../module/printcounter.h"

commit f00b48f9a8da77d0d603b74c843359b82ee306e3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Oct 21 18:34:29 2019 -0500

    Expand encoder value range

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index a953318bfa..eac5b7b2d7 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -132,7 +132,7 @@ void MenuItem_gcode::action(PGM_P const, PGM_P const pgcode) { queue.inject_P(pg
  *
  *   bool MenuItem_int3::_edit();
  *   void MenuItem_int3::edit(); // edit int16_t (interactively)
- *   void MenuItem_int3::action(PGM_P const pstr, int16_t * const ptr, const int16_t minValue, const int16_t maxValue, const screenFunc_t callback = null, const bool live = false);
+ *   void MenuItem_int3::action(PGM_P const pstr, int16_t * const ptr, const int32_t minValue, const int32_t maxValue, const screenFunc_t callback = null, const bool live = false);
  *
  * You can then use one of the menu macros to present the edit interface:
  *   EDIT_ITEM(int3, MSG_SPEED, &feedrate_percentage, 10, 999)
@@ -148,8 +148,8 @@ void MenuEditItemBase::edit(strfunc_t strfunc, loadfunc_t loadfunc) {
   #if ENABLED(TOUCH_BUTTONS)
     ui.repeat_delay = BUTTON_DELAY_EDIT;
   #endif
-  if (int16_t(ui.encoderPosition) < 0) ui.encoderPosition = 0;
-  if (int16_t(ui.encoderPosition) > maxEditValue) ui.encoderPosition = maxEditValue;
+  if (int32_t(ui.encoderPosition) < 0) ui.encoderPosition = 0;
+  if (int32_t(ui.encoderPosition) > maxEditValue) ui.encoderPosition = maxEditValue;
   if (ui.should_draw())
     draw_edit_screen(editLabel, strfunc(ui.encoderPosition + minEditValue));
   if (ui.lcd_clicked || (liveEdit && ui.should_draw())) {
@@ -341,7 +341,7 @@ void MarlinUI::synchronize(PGM_P const msg/*=nullptr*/) {
 void scroll_screen(const uint8_t limit, const bool is_menu) {
   ui.encoder_direction_menus();
   ENCODER_RATE_MULTIPLY(false);
-  if (ui.encoderPosition > 0x8000) ui.encoderPosition = 0;
+  if (int32_t(ui.encoderPosition) < 0) ui.encoderPosition = 0;
   if (ui.first_page) {
     encoderLine = ui.encoderPosition / (ENCODER_STEPS_PER_MENU_ITEM);
     screen_changed = false;

commit 6a865a614620d71521bd3dc032adffe0bf82378c
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Wed Oct 9 18:46:10 2019 -0600

    Multi-language support (#15453)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 1691e47995..a953318bfa 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -138,7 +138,7 @@ void MenuItem_gcode::action(PGM_P const, PGM_P const pgcode) { queue.inject_P(pg
  *   EDIT_ITEM(int3, MSG_SPEED, &feedrate_percentage, 10, 999)
  *
  * This expands into a more primitive menu item:
- *  _MENU_ITEM_P(int3, false, PSTR(MSG_SPEED), &feedrate_percentage, 10, 999)
+ *  _MENU_ITEM_P(int3, false, GET_TEXT(MSG_SPEED), &feedrate_percentage, 10, 999)
  *
  * ...which calls:
  *       MenuItem_int3::action(plabel, &feedrate_percentage, 10, 999)
@@ -324,8 +324,7 @@ void MarlinUI::_synchronize() {
 // Display the synchronize screen with a custom message
 // ** This blocks the command queue! **
 void MarlinUI::synchronize(PGM_P const msg/*=nullptr*/) {
-  static const char moving[] PROGMEM = MSG_MOVING;
-  sync_message = msg ? msg : moving;
+  sync_message = msg ?: GET_TEXT(MSG_MOVING);
   _synchronize();
 }
 
@@ -419,10 +418,10 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
     if (ui.should_draw()) {
       #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
         if (!do_probe)
-          draw_edit_screen(PSTR(MSG_Z_OFFSET), ftostr43sign(hotend_offset[active_extruder].z));
+          draw_edit_screen(GET_TEXT(MSG_Z_OFFSET), ftostr43sign(hotend_offset[active_extruder].z));
         else
       #endif
-          draw_edit_screen(PSTR(MSG_ZPROBE_ZOFFSET), ftostr43sign(probe_offset.z));
+          draw_edit_screen(GET_TEXT(MSG_ZPROBE_ZOFFSET), ftostr43sign(probe_offset.z));
 
       #if ENABLED(BABYSTEP_ZPROBE_GFX_OVERLAY)
         if (do_probe) _lcd_zoffset_overlay_gfx(probe_offset.z);
@@ -467,7 +466,7 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
 
 void _lcd_draw_homing() {
   constexpr uint8_t line = (LCD_HEIGHT - 1) / 2;
-  if (ui.should_draw()) draw_menu_item_static(line, PSTR(MSG_LEVEL_BED_HOMING));
+  if (ui.should_draw()) draw_menu_item_static(line, GET_TEXT(MSG_LEVEL_BED_HOMING));
   ui.refresh(LCDVIEW_CALL_NO_REDRAW);
 }
 

commit cc822c1a0513362e28f1b3aff76d4c4c06446f01
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Oct 7 19:44:33 2019 -0500

    Use lambdas in menus, where possible (#15452)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index eaef66325f..1691e47995 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -68,6 +68,7 @@ uint8_t screen_history_depth = 0;
 bool screen_changed;
 
 // Value Editing
+chimera_t editable;
 PGM_P MenuEditItemBase::editLabel;
 void* MenuEditItemBase::editValue;
 int32_t MenuEditItemBase::minEditValue, MenuEditItemBase::maxEditValue;
@@ -201,11 +202,6 @@ void MenuItem_bool::action(PGM_P pstr, bool *ptr, screenFunc_t callback) {
 ///////////////// Menu Tree ////////////////
 ////////////////////////////////////////////
 
-#if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-  float lcd_z_fade_height;
-  void _lcd_set_z_fade_height() { set_z_fade_height(lcd_z_fade_height); }
-#endif
-
 #include "../../Marlin.h"
 
 bool printer_busy() {
@@ -222,11 +218,6 @@ void MarlinUI::goto_screen(screenFunc_t screen, const uint16_t encoder/*=0*/, co
       repeat_delay = BUTTON_DELAY_MENU;
     #endif
 
-    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-      // Shadow for editing the fade height
-      lcd_z_fade_height = planner.z_fade_height;
-    #endif
-
     #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
       progress_reset();
     #endif

commit 72d791a73682fa676959189c89dbf34e85bbfe61
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Oct 2 18:54:20 2019 -0500

    Standardize active/paused functions

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 2f1825c59a..eaef66325f 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -30,7 +30,7 @@
 #include "../../module/motion.h"
 #include "../../module/printcounter.h"
 #include "../../gcode/queue.h"
-#include "../../sd/cardreader.h"
+
 #if HAS_BUZZER
   #include "../../libs/buzzer.h"
 #endif
@@ -206,8 +206,10 @@ void MenuItem_bool::action(PGM_P pstr, bool *ptr, screenFunc_t callback) {
   void _lcd_set_z_fade_height() { set_z_fade_height(lcd_z_fade_height); }
 #endif
 
+#include "../../Marlin.h"
+
 bool printer_busy() {
-  return planner.movesplanned() || IS_SD_PRINTING() || print_job_timer.isRunning();
+  return planner.movesplanned() || printingIsActive();
 }
 
 /**

commit 719615a6b6049713943b3a1e29ffdca3fe8a1877
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Oct 2 19:04:16 2019 -0500

    Simplify edit menu items
    
    The `edit` part of menu items displaying values is not needed. Menu edit types can be modeled on sub-menus.

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 4651d29106..2f1825c59a 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -68,11 +68,11 @@ uint8_t screen_history_depth = 0;
 bool screen_changed;
 
 // Value Editing
-PGM_P MenuItemBase::editLabel;
-void* MenuItemBase::editValue;
-int32_t MenuItemBase::minEditValue, MenuItemBase::maxEditValue;
-screenFunc_t MenuItemBase::callbackFunc;
-bool MenuItemBase::liveEdit;
+PGM_P MenuEditItemBase::editLabel;
+void* MenuEditItemBase::editValue;
+int32_t MenuEditItemBase::minEditValue, MenuEditItemBase::maxEditValue;
+screenFunc_t MenuEditItemBase::callbackFunc;
+bool MenuEditItemBase::liveEdit;
 
 // Prevent recursion into screen handlers
 bool no_reentry = false;
@@ -131,18 +131,19 @@ void MenuItem_gcode::action(PGM_P const, PGM_P const pgcode) { queue.inject_P(pg
  *
  *   bool MenuItem_int3::_edit();
  *   void MenuItem_int3::edit(); // edit int16_t (interactively)
- *   void MenuItem_int3::action_edit(PGM_P const pstr, int16_t * const ptr, const int16_t minValue, const int16_t maxValue, const screenFunc_t callback = null, const bool live = false);
+ *   void MenuItem_int3::action(PGM_P const pstr, int16_t * const ptr, const int16_t minValue, const int16_t maxValue, const screenFunc_t callback = null, const bool live = false);
  *
  * You can then use one of the menu macros to present the edit interface:
  *   EDIT_ITEM(int3, MSG_SPEED, &feedrate_percentage, 10, 999)
  *
  * This expands into a more primitive menu item:
- *   MENU_ITEM_VARIANT(int3, _edit, MSG_SPEED, PSTR(MSG_SPEED), &feedrate_percentage, 10, 999)
+ *  _MENU_ITEM_P(int3, false, PSTR(MSG_SPEED), &feedrate_percentage, 10, 999)
  *
  * ...which calls:
- *       MenuItem_int3::action_edit(PSTR(MSG_SPEED), &feedrate_percentage, 10, 999)
+ *       MenuItem_int3::action(plabel, &feedrate_percentage, 10, 999)
+ *       draw_menu_item_int3(encoderLine == _thisItemNr, _lcdLineNr, plabel, &feedrate_percentage, 10, 999)
  */
-void MenuItemBase::edit(strfunc_t strfunc, loadfunc_t loadfunc) {
+void MenuEditItemBase::edit(strfunc_t strfunc, loadfunc_t loadfunc) {
   #if ENABLED(TOUCH_BUTTONS)
     ui.repeat_delay = BUTTON_DELAY_EDIT;
   #endif
@@ -157,7 +158,7 @@ void MenuItemBase::edit(strfunc_t strfunc, loadfunc_t loadfunc) {
   }
 }
 
-void MenuItemBase::init(PGM_P const el, void * const ev, const int32_t minv, const int32_t maxv, const uint16_t ep, const screenFunc_t cs, const screenFunc_t cb, const bool le) {
+void MenuEditItemBase::init(PGM_P const el, void * const ev, const int32_t minv, const int32_t maxv, const uint16_t ep, const screenFunc_t cs, const screenFunc_t cb, const bool le) {
   ui.save_previous_screen();
   ui.refresh();
   editLabel = el;
@@ -170,7 +171,7 @@ void MenuItemBase::init(PGM_P const el, void * const ev, const int32_t minv, con
   liveEdit = le;
 }
 
-#define DEFINE_MENU_EDIT_ITEM(NAME) template class TMenuItem<MenuItemInfo_##NAME>
+#define DEFINE_MENU_EDIT_ITEM(NAME) template class TMenuEditItem<MenuEditItemInfo_##NAME>
 
 DEFINE_MENU_EDIT_ITEM(percent);     // 100%       right-justified
 DEFINE_MENU_EDIT_ITEM(int3);        // 123, -12   right-justified
@@ -191,7 +192,7 @@ DEFINE_MENU_EDIT_ITEM(float52sign); // +123.45
 DEFINE_MENU_EDIT_ITEM(long5);       // 12345      right-justified
 DEFINE_MENU_EDIT_ITEM(long5_25);    // 12345      right-justified (25 increment)
 
-void MenuItem_bool::action_edit(PGM_P pstr, bool *ptr, screenFunc_t callback) {
+void MenuItem_bool::action(PGM_P pstr, bool *ptr, screenFunc_t callback) {
   UNUSED(pstr); *ptr ^= true; ui.refresh();
   if (callback) (*callback)();
 }

commit 273cbe931e868554bf6782881443ccbf5fdd4208
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Oct 3 05:38:30 2019 -0500

    Aliases for common menu item types

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 69144fd64c..4651d29106 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -134,7 +134,7 @@ void MenuItem_gcode::action(PGM_P const, PGM_P const pgcode) { queue.inject_P(pg
  *   void MenuItem_int3::action_edit(PGM_P const pstr, int16_t * const ptr, const int16_t minValue, const int16_t maxValue, const screenFunc_t callback = null, const bool live = false);
  *
  * You can then use one of the menu macros to present the edit interface:
- *   MENU_ITEM_EDIT(int3, MSG_SPEED, &feedrate_percentage, 10, 999)
+ *   EDIT_ITEM(int3, MSG_SPEED, &feedrate_percentage, 10, 999)
  *
  * This expands into a more primitive menu item:
  *   MENU_ITEM_VARIANT(int3, _edit, MSG_SPEED, PSTR(MSG_SPEED), &feedrate_percentage, 10, 999)

commit e3ff27c95a8be758afba5e0f44668f1d1fc1ad0f
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Mon Sep 30 21:53:34 2019 -0600

    Prevent duplication of PSTRs to save memory (#15435)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index ca5dd29a24..69144fd64c 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -112,7 +112,7 @@ void MarlinUI::goto_previous_screen(
 /////////// Common Menu Actions ////////////
 ////////////////////////////////////////////
 
-void MenuItem_gcode::action(PGM_P const pgcode) { queue.inject_P(pgcode); }
+void MenuItem_gcode::action(PGM_P const, PGM_P const pgcode) { queue.inject_P(pgcode); }
 
 ////////////////////////////////////////////
 /////////// Menu Editing Actions ///////////

commit 50e4545255605eb506c20eb107270038b0fe7bdb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 29 04:25:39 2019 -0500

    Add custom types for position (#15204)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 012b3b5847..ca5dd29a24 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -379,8 +379,8 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
 #if HAS_LINE_TO_Z
 
   void line_to_z(const float &z) {
-    current_position[Z_AXIS] = z;
-    planner.buffer_line(current_position, MMM_TO_MMS(manual_feedrate_mm_m[Z_AXIS]), active_extruder);
+    current_position.z = z;
+    line_to_current_position(MMM_TO_MMS(manual_feedrate_mm_m.z));
   }
 
 #endif
@@ -402,10 +402,10 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
       ui.encoderPosition = 0;
 
       const float diff = planner.steps_to_mm[Z_AXIS] * babystep_increment,
-                  new_probe_offset = probe_offset[Z_AXIS] + diff,
+                  new_probe_offset = probe_offset.z + diff,
                   new_offs =
                     #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
-                      do_probe ? new_probe_offset : hotend_offset[Z_AXIS][active_extruder] - diff
+                      do_probe ? new_probe_offset : hotend_offset[active_extruder].z - diff
                     #else
                       new_probe_offset
                     #endif
@@ -414,9 +414,9 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
 
         babystep.add_steps(Z_AXIS, babystep_increment);
 
-        if (do_probe) probe_offset[Z_AXIS] = new_offs;
+        if (do_probe) probe_offset.z = new_offs;
         #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
-          else hotend_offset[Z_AXIS][active_extruder] = new_offs;
+          else hotend_offset[active_extruder].z = new_offs;
         #endif
 
         ui.refresh(LCDVIEW_CALL_REDRAW_NEXT);
@@ -425,13 +425,13 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
     if (ui.should_draw()) {
       #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
         if (!do_probe)
-          draw_edit_screen(PSTR(MSG_Z_OFFSET), ftostr43sign(hotend_offset[Z_AXIS][active_extruder]));
+          draw_edit_screen(PSTR(MSG_Z_OFFSET), ftostr43sign(hotend_offset[active_extruder].z));
         else
       #endif
-          draw_edit_screen(PSTR(MSG_ZPROBE_ZOFFSET), ftostr43sign(probe_offset[Z_AXIS]));
+          draw_edit_screen(PSTR(MSG_ZPROBE_ZOFFSET), ftostr43sign(probe_offset.z));
 
       #if ENABLED(BABYSTEP_ZPROBE_GFX_OVERLAY)
-        if (do_probe) _lcd_zoffset_overlay_gfx(probe_offset[Z_AXIS]);
+        if (do_probe) _lcd_zoffset_overlay_gfx(probe_offset.z);
       #endif
     }
   }

commit 4e8d9fe59b53fc5937d907fcf6d79b58233ab6ef
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Sep 24 23:35:49 2019 -0500

    zprobe_offset => probe_offset

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 800b4f03d0..012b3b5847 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -402,7 +402,7 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
       ui.encoderPosition = 0;
 
       const float diff = planner.steps_to_mm[Z_AXIS] * babystep_increment,
-                  new_probe_offset = zprobe_offset[Z_AXIS] + diff,
+                  new_probe_offset = probe_offset[Z_AXIS] + diff,
                   new_offs =
                     #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
                       do_probe ? new_probe_offset : hotend_offset[Z_AXIS][active_extruder] - diff
@@ -414,7 +414,7 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
 
         babystep.add_steps(Z_AXIS, babystep_increment);
 
-        if (do_probe) zprobe_offset[Z_AXIS] = new_offs;
+        if (do_probe) probe_offset[Z_AXIS] = new_offs;
         #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
           else hotend_offset[Z_AXIS][active_extruder] = new_offs;
         #endif
@@ -428,10 +428,10 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
           draw_edit_screen(PSTR(MSG_Z_OFFSET), ftostr43sign(hotend_offset[Z_AXIS][active_extruder]));
         else
       #endif
-          draw_edit_screen(PSTR(MSG_ZPROBE_ZOFFSET), ftostr43sign(zprobe_offset[Z_AXIS]));
+          draw_edit_screen(PSTR(MSG_ZPROBE_ZOFFSET), ftostr43sign(probe_offset[Z_AXIS]));
 
       #if ENABLED(BABYSTEP_ZPROBE_GFX_OVERLAY)
-        if (do_probe) _lcd_zoffset_overlay_gfx(zprobe_offset[Z_AXIS]);
+        if (do_probe) _lcd_zoffset_overlay_gfx(probe_offset[Z_AXIS]);
       #endif
     }
   }

commit df1e51258a8bcc432deed9f5bd60df41a75b2c32
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue Sep 24 22:29:21 2019 -0400

    Add M851 X Y probe offsets (#15202)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 5590ef7143..800b4f03d0 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -402,7 +402,7 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
       ui.encoderPosition = 0;
 
       const float diff = planner.steps_to_mm[Z_AXIS] * babystep_increment,
-                  new_probe_offset = zprobe_zoffset + diff,
+                  new_probe_offset = zprobe_offset[Z_AXIS] + diff,
                   new_offs =
                     #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
                       do_probe ? new_probe_offset : hotend_offset[Z_AXIS][active_extruder] - diff
@@ -414,7 +414,7 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
 
         babystep.add_steps(Z_AXIS, babystep_increment);
 
-        if (do_probe) zprobe_zoffset = new_offs;
+        if (do_probe) zprobe_offset[Z_AXIS] = new_offs;
         #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
           else hotend_offset[Z_AXIS][active_extruder] = new_offs;
         #endif
@@ -428,10 +428,10 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
           draw_edit_screen(PSTR(MSG_Z_OFFSET), ftostr43sign(hotend_offset[Z_AXIS][active_extruder]));
         else
       #endif
-          draw_edit_screen(PSTR(MSG_ZPROBE_ZOFFSET), ftostr43sign(zprobe_zoffset));
+          draw_edit_screen(PSTR(MSG_ZPROBE_ZOFFSET), ftostr43sign(zprobe_offset[Z_AXIS]));
 
       #if ENABLED(BABYSTEP_ZPROBE_GFX_OVERLAY)
-        if (do_probe) _lcd_zoffset_overlay_gfx(zprobe_zoffset);
+        if (do_probe) _lcd_zoffset_overlay_gfx(zprobe_offset[Z_AXIS]);
       #endif
     }
   }

commit d277e93f4df441e0ce9f21e7d3466f8649433875
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Tue Sep 17 04:32:55 2019 +0200

    Configurable TOUCH_BUTTONS repeat delays (#15245)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index fb4db9742d..5590ef7143 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -144,7 +144,7 @@ void MenuItem_gcode::action(PGM_P const pgcode) { queue.inject_P(pgcode); }
  */
 void MenuItemBase::edit(strfunc_t strfunc, loadfunc_t loadfunc) {
   #if ENABLED(TOUCH_BUTTONS)
-    ui.repeat_delay = 50;
+    ui.repeat_delay = BUTTON_DELAY_EDIT;
   #endif
   if (int16_t(ui.encoderPosition) < 0) ui.encoderPosition = 0;
   if (int16_t(ui.encoderPosition) > maxEditValue) ui.encoderPosition = maxEditValue;
@@ -216,7 +216,7 @@ void MarlinUI::goto_screen(screenFunc_t screen, const uint16_t encoder/*=0*/, co
   if (currentScreen != screen) {
 
     #if ENABLED(TOUCH_BUTTONS)
-      repeat_delay = 250;
+      repeat_delay = BUTTON_DELAY_MENU;
     #endif
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)

commit 3f129b657466d31757ed41369015a772ca9f09f7
Author: Robby Candra <robbycandra.mail@gmail.com>
Date:   Fri Sep 13 10:14:24 2019 +0700

    Touch Buttons variable repeat delay (#15236)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 5f6db8196d..fb4db9742d 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -143,6 +143,9 @@ void MenuItem_gcode::action(PGM_P const pgcode) { queue.inject_P(pgcode); }
  *       MenuItem_int3::action_edit(PSTR(MSG_SPEED), &feedrate_percentage, 10, 999)
  */
 void MenuItemBase::edit(strfunc_t strfunc, loadfunc_t loadfunc) {
+  #if ENABLED(TOUCH_BUTTONS)
+    ui.repeat_delay = 50;
+  #endif
   if (int16_t(ui.encoderPosition) < 0) ui.encoderPosition = 0;
   if (int16_t(ui.encoderPosition) > maxEditValue) ui.encoderPosition = maxEditValue;
   if (ui.should_draw())
@@ -212,6 +215,10 @@ bool printer_busy() {
 void MarlinUI::goto_screen(screenFunc_t screen, const uint16_t encoder/*=0*/, const uint8_t top/*=0*/, const uint8_t items/*=0*/) {
   if (currentScreen != screen) {
 
+    #if ENABLED(TOUCH_BUTTONS)
+      repeat_delay = 250;
+    #endif
+
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
       // Shadow for editing the fade height
       lcd_z_fade_height = planner.z_fade_height;

commit 0a280f00c2e1d0a59791fbefeca578ca9ef73f6e
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Sat Aug 24 05:21:30 2019 +0200

    Flag unused variables without buzzer (#15016)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 34e01b09c3..5f6db8196d 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -453,12 +453,14 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
     #if HAS_BUZZER
       ui.completion_feedback(saved);
     #endif
+    UNUSED(saved);
   }
   void lcd_load_settings() {
     const bool loaded = settings.load();
     #if HAS_BUZZER
       ui.completion_feedback(loaded);
     #endif
+    UNUSED(loaded);
   }
 #endif
 

commit 5e777601f3c9816dd1ff349886c748add245bea4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Aug 20 19:37:03 2019 -0500

    Add TURBO_BACK_MENU_ITEM option (#14991)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 9bea6c1352..34e01b09c3 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -88,10 +88,21 @@ void MarlinUI::save_previous_screen() {
     screen_history[screen_history_depth++] = { currentScreen, encoderPosition, encoderTopLine, screen_items };
 }
 
-void MarlinUI::goto_previous_screen() {
+void MarlinUI::goto_previous_screen(
+  #if ENABLED(TURBO_BACK_MENU_ITEM)
+    const bool is_back/*=false*/
+  #endif
+) {
+  #if DISABLED(TURBO_BACK_MENU_ITEM)
+    constexpr bool is_back = false;
+  #endif
   if (screen_history_depth > 0) {
     menuPosition &sh = screen_history[--screen_history_depth];
-    goto_screen(sh.menu_function, sh.encoder_position, sh.top_line, sh.items);
+    goto_screen(sh.menu_function,
+      is_back ? 0 : sh.encoder_position,
+      is_back ? 0 : sh.top_line,
+      sh.items
+    );
   }
   else
     return_to_status();

commit 128eed6b57a8dd67d0fe02511e9437755e326c31
Author: Robby Candra <robbycandra.mail@gmail.com>
Date:   Wed Jul 31 05:42:57 2019 +0700

    Option to reverse select direction/buttons (#14693)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 18fb599f56..9bea6c1352 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -467,6 +467,7 @@ void _lcd_draw_homing() {
 //
 bool MarlinUI::selection; // = false
 bool MarlinUI::update_selection() {
+  encoder_direction_select();
   if (encoderPosition) {
     selection = int16_t(encoderPosition) > 0;
     encoderPosition = 0;

commit c4bb458763c810f29025fc6b2c5829022ed509c7
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Mon Jul 29 02:14:50 2019 +0200

    BUZZ cleanup (#14760)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 237cd69707..18fb599f56 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -31,7 +31,9 @@
 #include "../../module/printcounter.h"
 #include "../../gcode/queue.h"
 #include "../../sd/cardreader.h"
-#include "../../libs/buzzer.h"
+#if HAS_BUZZER
+  #include "../../libs/buzzer.h"
+#endif
 
 #if ENABLED(EEPROM_SETTINGS)
   #include "../../module/configuration_store.h"
@@ -346,13 +348,15 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
     encoderTopLine = encoderLine;
 }
 
-void MarlinUI::completion_feedback(const bool good/*=true*/) {
-  if (good) {
-    BUZZ(100, 659);
-    BUZZ(100, 698);
+#if HAS_BUZZER
+  void MarlinUI::completion_feedback(const bool good/*=true*/) {
+    if (good) {
+      BUZZ(100, 659);
+      BUZZ(100, 698);
+    }
+    else BUZZ(20, 440);
   }
-  else BUZZ(20, 440);
-}
+#endif
 
 #if HAS_LINE_TO_Z
 
@@ -433,8 +437,18 @@ void MarlinUI::completion_feedback(const bool good/*=true*/) {
 #endif
 
 #if ENABLED(EEPROM_SETTINGS)
-  void lcd_store_settings()   { ui.completion_feedback(settings.save()); }
-  void lcd_load_settings()    { ui.completion_feedback(settings.load()); }
+  void lcd_store_settings() {
+    const bool saved = settings.save();
+    #if HAS_BUZZER
+      ui.completion_feedback(saved);
+    #endif
+  }
+  void lcd_load_settings() {
+    const bool loaded = settings.load();
+    #if HAS_BUZZER
+      ui.completion_feedback(loaded);
+    #endif
+  }
 #endif
 
 void _lcd_draw_homing() {

commit 39e1726498a79d99fc15728cdebde5a41f4cfc19
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Sat Jul 20 08:41:34 2019 +0200

    Comments, includes (#14671)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index d8f734bb02..237cd69707 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -156,15 +156,16 @@ void MenuItemBase::init(PGM_P const el, void * const ev, const int32_t minv, con
 
 #define DEFINE_MENU_EDIT_ITEM(NAME) template class TMenuItem<MenuItemInfo_##NAME>
 
+DEFINE_MENU_EDIT_ITEM(percent);     // 100%       right-justified
 DEFINE_MENU_EDIT_ITEM(int3);        // 123, -12   right-justified
 DEFINE_MENU_EDIT_ITEM(int4);        // 1234, -123 right-justified
 DEFINE_MENU_EDIT_ITEM(int8);        // 123, -12   right-justified
 DEFINE_MENU_EDIT_ITEM(uint8);       // 123        right-justified
-DEFINE_MENU_EDIT_ITEM(uint16_3);    // 123, -12   right-justified
+DEFINE_MENU_EDIT_ITEM(uint16_3);    // 123        right-justified
 DEFINE_MENU_EDIT_ITEM(uint16_4);    // 1234       right-justified
 DEFINE_MENU_EDIT_ITEM(uint16_5);    // 12345      right-justified
 DEFINE_MENU_EDIT_ITEM(float3);      // 123        right-justified
-DEFINE_MENU_EDIT_ITEM(float52);     // 123.45
+DEFINE_MENU_EDIT_ITEM(float52);     // _2.34, 12.34, -2.34 or 123.45, -23.45
 DEFINE_MENU_EDIT_ITEM(float43);     // 1.234
 DEFINE_MENU_EDIT_ITEM(float5);      // 12345      right-justified
 DEFINE_MENU_EDIT_ITEM(float5_25);   // 12345      right-justified (25 increment)

commit c9aa68ef7aa358bb633b6d87232a94bfa6b7d7c8
Author: Robby Candra <robbycandra.mail@gmail.com>
Date:   Thu Jul 18 07:41:15 2019 +0700

    Encoder direction: Wrangle, Revert select screen change (#14628)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 3d661c6f0f..d8f734bb02 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -130,7 +130,6 @@ void MenuItem_gcode::action(PGM_P const pgcode) { queue.inject_P(pgcode); }
  *       MenuItem_int3::action_edit(PSTR(MSG_SPEED), &feedrate_percentage, 10, 999)
  */
 void MenuItemBase::edit(strfunc_t strfunc, loadfunc_t loadfunc) {
-  ui.encoder_direction_normal();
   if (int16_t(ui.encoderPosition) < 0) ui.encoderPosition = 0;
   if (int16_t(ui.encoderPosition) > maxEditValue) ui.encoderPosition = maxEditValue;
   if (ui.should_draw())
@@ -276,7 +275,11 @@ void MarlinUI::goto_screen(screenFunc_t screen, const uint16_t encoder/*=0*/, co
       drawing_screen = false;
     #endif
 
-    set_ui_selection(false);
+    #if HAS_LCD_MENU
+      encoder_direction_normal();
+    #endif
+
+    set_selection(false);
   }
 }
 
@@ -371,7 +374,6 @@ void MarlinUI::completion_feedback(const bool good/*=true*/) {
     #else
       constexpr bool do_probe = true;
     #endif
-    ui.encoder_direction_normal();
     if (ui.encoderPosition) {
       const int16_t babystep_increment = int16_t(ui.encoderPosition) * (BABYSTEP_MULTIPLICATOR);
       ui.encoderPosition = 0;
@@ -448,14 +450,16 @@ void _lcd_draw_homing() {
 //
 // Selection screen presents a prompt and two options
 //
-bool ui_selection; // = false
-void set_ui_selection(const bool sel) { ui_selection = sel; }
-void do_select_screen(PGM_P const yes, PGM_P const no, selectFunc_t yesFunc, selectFunc_t noFunc, PGM_P const pref, const char * const string/*=nullptr*/, PGM_P const suff/*=nullptr*/) {
-  if (ui.encoderPosition) {
-    ui_selection = ((ENCODERBASE) > 0) == (int16_t(ui.encoderPosition) > 0);
-    ui.encoderPosition = 0;
+bool MarlinUI::selection; // = false
+bool MarlinUI::update_selection() {
+  if (encoderPosition) {
+    selection = int16_t(encoderPosition) > 0;
+    encoderPosition = 0;
   }
-  const bool got_click = ui.use_click();
+  return selection;
+}
+void do_select_screen(PGM_P const yes, PGM_P const no, selectFunc_t yesFunc, selectFunc_t noFunc, PGM_P const pref, const char * const string/*=nullptr*/, PGM_P const suff/*=nullptr*/) {
+  const bool ui_selection = ui.update_selection(), got_click = ui.use_click();
   if (got_click || ui.should_draw()) {
     draw_select_screen(yes, no, ui_selection, pref, string, suff);
     if (got_click) { ui_selection ? yesFunc() : noFunc(); }

commit 27c487bab744a22aeb580a0471591adba040bc68
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Wed Jul 17 02:12:39 2019 -0600

    Print progress enhancements (#14647)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 879c62476a..3d661c6f0f 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -204,6 +204,10 @@ void MarlinUI::goto_screen(screenFunc_t screen, const uint16_t encoder/*=0*/, co
       lcd_z_fade_height = planner.z_fade_height;
     #endif
 
+    #if ENABLED(LCD_SET_PROGRESS_MANUALLY)
+      progress_reset();
+    #endif
+
     #if BOTH(DOUBLECLICK_FOR_Z_BABYSTEPPING, BABYSTEPPING)
       static millis_t doubleclick_expire_ms = 0;
       // Going to menu_main from status screen? Remember first click time.

commit 6dcb85927ae570423fc0308590fe9facbbd1e74f
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Sun Jul 14 11:34:55 2019 +0200

    Update German language, &c. (#14613)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 3274c904c3..879c62476a 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -448,7 +448,7 @@ bool ui_selection; // = false
 void set_ui_selection(const bool sel) { ui_selection = sel; }
 void do_select_screen(PGM_P const yes, PGM_P const no, selectFunc_t yesFunc, selectFunc_t noFunc, PGM_P const pref, const char * const string/*=nullptr*/, PGM_P const suff/*=nullptr*/) {
   if (ui.encoderPosition) {
-    ui_selection = (ENCODERBASE) > 0 == int16_t(ui.encoderPosition) > 0;
+    ui_selection = ((ENCODERBASE) > 0) == (int16_t(ui.encoderPosition) > 0);
     ui.encoderPosition = 0;
   }
   const bool got_click = ui.use_click();

commit 3cd9a92dcc525e97768330651c40e5dc349c9e19
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jul 11 15:15:35 2019 -0500

    Use REVERSE_ENCODER_DIRECTION in do_select_screen

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 9ede8da301..3274c904c3 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -448,7 +448,7 @@ bool ui_selection; // = false
 void set_ui_selection(const bool sel) { ui_selection = sel; }
 void do_select_screen(PGM_P const yes, PGM_P const no, selectFunc_t yesFunc, selectFunc_t noFunc, PGM_P const pref, const char * const string/*=nullptr*/, PGM_P const suff/*=nullptr*/) {
   if (ui.encoderPosition) {
-    ui_selection = int16_t(ui.encoderPosition) > 0;
+    ui_selection = (ENCODERBASE) > 0 == int16_t(ui.encoderPosition) > 0;
     ui.encoderPosition = 0;
   }
   const bool got_click = ui.use_click();

commit 750a16ad385dca893d482cb51d8af2ac3f8a1da1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jul 5 18:01:21 2019 -0500

    Fix MIN/MAX function collision with macros

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index ac41a72292..9ede8da301 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -326,7 +326,7 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
     screen_changed = false;
   }
   if (screen_items > 0 && encoderLine >= screen_items - limit) {
-    encoderLine = MAX(0, screen_items - limit);
+    encoderLine = _MAX(0, screen_items - limit);
     ui.encoderPosition = encoderLine * (ENCODER_STEPS_PER_MENU_ITEM);
   }
   if (is_menu) {

commit 93cd66ac1146603e8a9911fceb3c63f4351f4d8e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 23:57:50 2019 -0500

    Tweaky change from (C) to (c)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 16dfd22a43..ac41a72292 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -1,9 +1,9 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by

commit d7d80418aedad1c89e27fcba6aab9aa48187b5cc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jun 27 23:06:49 2019 -0500

    Singleton for cutting tools (#14429)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index f13b370d29..16dfd22a43 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -162,7 +162,8 @@ DEFINE_MENU_EDIT_ITEM(int4);        // 1234, -123 right-justified
 DEFINE_MENU_EDIT_ITEM(int8);        // 123, -12   right-justified
 DEFINE_MENU_EDIT_ITEM(uint8);       // 123        right-justified
 DEFINE_MENU_EDIT_ITEM(uint16_3);    // 123, -12   right-justified
-DEFINE_MENU_EDIT_ITEM(uint16_4);    // 1234, -123 right-justified
+DEFINE_MENU_EDIT_ITEM(uint16_4);    // 1234       right-justified
+DEFINE_MENU_EDIT_ITEM(uint16_5);    // 12345      right-justified
 DEFINE_MENU_EDIT_ITEM(float3);      // 123        right-justified
 DEFINE_MENU_EDIT_ITEM(float52);     // 123.45
 DEFINE_MENU_EDIT_ITEM(float43);     // 1.234

commit 3d9d72e8db818c856e1018813e51b0ac736436e4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Jun 23 03:43:36 2019 -0500

    Include order, spacing, etc.

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 85f876d68e..f13b370d29 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -99,7 +99,7 @@ void MarlinUI::goto_previous_screen() {
 /////////// Common Menu Actions ////////////
 ////////////////////////////////////////////
 
-void MenuItem_gcode::action(PGM_P pgcode) { queue.inject_P(pgcode); }
+void MenuItem_gcode::action(PGM_P const pgcode) { queue.inject_P(pgcode); }
 
 ////////////////////////////////////////////
 /////////// Menu Editing Actions ///////////

commit 4c872a01f284cbf181f52c84e2ba6b4618e62556
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jun 19 00:00:19 2019 -0500

    G-code queue singleton, front injection (#14236)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index ff2b5fd6e9..85f876d68e 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -99,7 +99,7 @@ void MarlinUI::goto_previous_screen() {
 /////////// Common Menu Actions ////////////
 ////////////////////////////////////////////
 
-void MenuItem_gcode::action(PGM_P pgcode) { enqueue_and_echo_commands_P(pgcode); }
+void MenuItem_gcode::action(PGM_P pgcode) { queue.inject_P(pgcode); }
 
 ////////////////////////////////////////////
 /////////// Menu Editing Actions ///////////
@@ -410,15 +410,15 @@ void MarlinUI::completion_feedback(const bool good/*=true*/) {
 
 #if ANY(AUTO_BED_LEVELING_UBL, PID_AUTOTUNE_MENU, ADVANCED_PAUSE_FEATURE)
 
-  void lcd_enqueue_command(const char * const cmd) {
+  void lcd_enqueue_one_now(const char * const cmd) {
     no_reentry = true;
-    enqueue_and_echo_command_now(cmd);
+    queue.enqueue_one_now(cmd);
     no_reentry = false;
   }
 
-  void lcd_enqueue_commands_P(PGM_P const cmd) {
+  void lcd_enqueue_one_now_P(PGM_P const cmd) {
     no_reentry = true;
-    enqueue_and_echo_commands_now_P(cmd);
+    queue.enqueue_now_P(cmd);
     no_reentry = false;
   }
 

commit 991ee7552b01330afadac37a4d8009e6aaa07892
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sat May 11 19:44:35 2019 -0400

    Restore menu edit to 32bit value (#13976)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 2342f0b984..ff2b5fd6e9 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -68,7 +68,7 @@ bool screen_changed;
 // Value Editing
 PGM_P MenuItemBase::editLabel;
 void* MenuItemBase::editValue;
-int16_t MenuItemBase::minEditValue, MenuItemBase::maxEditValue;
+int32_t MenuItemBase::minEditValue, MenuItemBase::maxEditValue;
 screenFunc_t MenuItemBase::callbackFunc;
 bool MenuItemBase::liveEdit;
 
@@ -142,7 +142,7 @@ void MenuItemBase::edit(strfunc_t strfunc, loadfunc_t loadfunc) {
   }
 }
 
-void MenuItemBase::init(PGM_P const el, void * const ev, const int16_t minv, const int16_t maxv, const uint16_t ep, const screenFunc_t cs, const screenFunc_t cb, const bool le) {
+void MenuItemBase::init(PGM_P const el, void * const ev, const int32_t minv, const int32_t maxv, const uint16_t ep, const screenFunc_t cs, const screenFunc_t cb, const bool le) {
   ui.save_previous_screen();
   ui.refresh();
   editLabel = el;

commit ad4ffa1d2fbd17ac09c816ba2052cdf714261042
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 9 11:45:55 2019 -0500

    Use C++ language supported 'nullptr' (#13944)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index dd9babe306..2342f0b984 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -136,7 +136,7 @@ void MenuItemBase::edit(strfunc_t strfunc, loadfunc_t loadfunc) {
   if (ui.should_draw())
     draw_edit_screen(editLabel, strfunc(ui.encoderPosition + minEditValue));
   if (ui.lcd_clicked || (liveEdit && ui.should_draw())) {
-    if (editValue != NULL) loadfunc(editValue, ui.encoderPosition + minEditValue);
+    if (editValue != nullptr) loadfunc(editValue, ui.encoderPosition + minEditValue);
     if (callbackFunc && (liveEdit || ui.lcd_clicked)) (*callbackFunc)();
     if (ui.use_click()) ui.goto_previous_screen();
   }
@@ -300,7 +300,7 @@ void MarlinUI::_synchronize() {
 
 // Display the synchronize screen with a custom message
 // ** This blocks the command queue! **
-void MarlinUI::synchronize(PGM_P const msg/*=NULL*/) {
+void MarlinUI::synchronize(PGM_P const msg/*=nullptr*/) {
   static const char moving[] PROGMEM = MSG_MOVING;
   sync_message = msg ? msg : moving;
   _synchronize();
@@ -445,7 +445,7 @@ void _lcd_draw_homing() {
 //
 bool ui_selection; // = false
 void set_ui_selection(const bool sel) { ui_selection = sel; }
-void do_select_screen(PGM_P const yes, PGM_P const no, selectFunc_t yesFunc, selectFunc_t noFunc, PGM_P const pref, const char * const string/*=NULL*/, PGM_P const suff/*=NULL*/) {
+void do_select_screen(PGM_P const yes, PGM_P const no, selectFunc_t yesFunc, selectFunc_t noFunc, PGM_P const pref, const char * const string/*=nullptr*/, PGM_P const suff/*=nullptr*/) {
   if (ui.encoderPosition) {
     ui_selection = int16_t(ui.encoderPosition) > 0;
     ui.encoderPosition = 0;

commit e7b3720b8193c76d1766898923b59261371e1c79
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Sun May 5 00:21:58 2019 +0200

    Menu edit accel in increments of 25 (#13850)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index ba6957ddaf..dd9babe306 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -167,10 +167,12 @@ DEFINE_MENU_EDIT_ITEM(float3);      // 123        right-justified
 DEFINE_MENU_EDIT_ITEM(float52);     // 123.45
 DEFINE_MENU_EDIT_ITEM(float43);     // 1.234
 DEFINE_MENU_EDIT_ITEM(float5);      // 12345      right-justified
+DEFINE_MENU_EDIT_ITEM(float5_25);   // 12345      right-justified (25 increment)
 DEFINE_MENU_EDIT_ITEM(float51);     // 1234.5     right-justified
 DEFINE_MENU_EDIT_ITEM(float51sign); // +1234.5
 DEFINE_MENU_EDIT_ITEM(float52sign); // +123.45
 DEFINE_MENU_EDIT_ITEM(long5);       // 12345      right-justified
+DEFINE_MENU_EDIT_ITEM(long5_25);    // 12345      right-justified (25 increment)
 
 void MenuItem_bool::action_edit(PGM_P pstr, bool *ptr, screenFunc_t callback) {
   UNUSED(pstr); *ptr ^= true; ui.refresh();

commit 5051909c3c43ae42c14765d0adce4405b8e9a423
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 24 10:13:44 2019 -0500

    Update do_select_screen for general use (#13800)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 1a053ad850..ba6957ddaf 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -268,6 +268,8 @@ void MarlinUI::goto_screen(screenFunc_t screen, const uint16_t encoder/*=0*/, co
     #if HAS_GRAPHICAL_LCD
       drawing_screen = false;
     #endif
+
+    set_ui_selection(false);
   }
 }
 
@@ -436,12 +438,21 @@ void _lcd_draw_homing() {
   void _lcd_toggle_bed_leveling() { set_bed_leveling_enabled(!planner.leveling_active); }
 #endif
 
-void do_select_screen(PGM_P const yes, PGM_P const no, bool &yesno, PGM_P const pref, const char * const string, PGM_P const suff) {
+//
+// Selection screen presents a prompt and two options
+//
+bool ui_selection; // = false
+void set_ui_selection(const bool sel) { ui_selection = sel; }
+void do_select_screen(PGM_P const yes, PGM_P const no, selectFunc_t yesFunc, selectFunc_t noFunc, PGM_P const pref, const char * const string/*=NULL*/, PGM_P const suff/*=NULL*/) {
   if (ui.encoderPosition) {
-    yesno = int16_t(ui.encoderPosition) > 0;
+    ui_selection = int16_t(ui.encoderPosition) > 0;
     ui.encoderPosition = 0;
   }
-  draw_select_screen(yes, no, yesno, pref, string, suff);
+  const bool got_click = ui.use_click();
+  if (got_click || ui.should_draw()) {
+    draw_select_screen(yes, no, ui_selection, pref, string, suff);
+    if (got_click) { ui_selection ? yesFunc() : noFunc(); }
+  }
 }
 
 #endif // HAS_LCD_MENU

commit 866e2d41dca277a1913a7e505a3d07d6d10f7ce3
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Tue Apr 16 14:45:31 2019 -0600

    Correct range of LCD axis step editing (#13727)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 91b1ad448e..1a053ad850 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -167,9 +167,9 @@ DEFINE_MENU_EDIT_ITEM(float3);      // 123        right-justified
 DEFINE_MENU_EDIT_ITEM(float52);     // 123.45
 DEFINE_MENU_EDIT_ITEM(float43);     // 1.234
 DEFINE_MENU_EDIT_ITEM(float5);      // 12345      right-justified
-DEFINE_MENU_EDIT_ITEM(float51);     // +1234.5
+DEFINE_MENU_EDIT_ITEM(float51);     // 1234.5     right-justified
+DEFINE_MENU_EDIT_ITEM(float51sign); // +1234.5
 DEFINE_MENU_EDIT_ITEM(float52sign); // +123.45
-DEFINE_MENU_EDIT_ITEM(float62);     // 1234.56    right-justified
 DEFINE_MENU_EDIT_ITEM(long5);       // 12345      right-justified
 
 void MenuItem_bool::action_edit(PGM_P pstr, bool *ptr, screenFunc_t callback) {

commit 4900c28bf600f86ccbc3943072e9c573a443ecae
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue Apr 9 19:33:40 2019 -0400

    Fix IDEX tool-change, and more (#13614)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index e737f32788..91b1ad448e 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -391,7 +391,7 @@ void MarlinUI::completion_feedback(const bool good/*=true*/) {
     if (ui.should_draw()) {
       #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
         if (!do_probe)
-          draw_edit_screen(PSTR(MSG_IDEX_Z_OFFSET), ftostr43sign(hotend_offset[Z_AXIS][active_extruder]));
+          draw_edit_screen(PSTR(MSG_Z_OFFSET), ftostr43sign(hotend_offset[Z_AXIS][active_extruder]));
         else
       #endif
           draw_edit_screen(PSTR(MSG_ZPROBE_ZOFFSET), ftostr43sign(zprobe_zoffset));

commit 321a5e65805f51e6817ff51db448dc5d8f28c900
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Apr 8 21:10:41 2019 -0500

    Fix SD card reselect when scrolled (#13624)
    
    - Change encoder position to 16-bit integer.
    - Fix `SD_REPRINT_LAST_SELECTED_FILE` when the screen is scrolled.

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 69e5c8355c..e737f32788 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -66,11 +66,11 @@ uint8_t screen_history_depth = 0;
 bool screen_changed;
 
 // Value Editing
-PGM_P editLabel;
-void *editValue;
-int32_t minEditValue, maxEditValue;
-screenFunc_t callbackFunc;
-bool liveEdit;
+PGM_P MenuItemBase::editLabel;
+void* MenuItemBase::editValue;
+int16_t MenuItemBase::minEditValue, MenuItemBase::maxEditValue;
+screenFunc_t MenuItemBase::callbackFunc;
+bool MenuItemBase::liveEdit;
 
 // Prevent recursion into screen handlers
 bool no_reentry = false;
@@ -131,8 +131,8 @@ void MenuItem_gcode::action(PGM_P pgcode) { enqueue_and_echo_commands_P(pgcode);
  */
 void MenuItemBase::edit(strfunc_t strfunc, loadfunc_t loadfunc) {
   ui.encoder_direction_normal();
-  if ((int32_t)ui.encoderPosition < 0) ui.encoderPosition = 0;
-  if ((int32_t)ui.encoderPosition > maxEditValue) ui.encoderPosition = maxEditValue;
+  if (int16_t(ui.encoderPosition) < 0) ui.encoderPosition = 0;
+  if (int16_t(ui.encoderPosition) > maxEditValue) ui.encoderPosition = maxEditValue;
   if (ui.should_draw())
     draw_edit_screen(editLabel, strfunc(ui.encoderPosition + minEditValue));
   if (ui.lcd_clicked || (liveEdit && ui.should_draw())) {
@@ -142,7 +142,7 @@ void MenuItemBase::edit(strfunc_t strfunc, loadfunc_t loadfunc) {
   }
 }
 
-void MenuItemBase::init(PGM_P const el, void * const ev, const int32_t minv, const int32_t maxv, const uint32_t ep, const screenFunc_t cs, const screenFunc_t cb, const bool le) {
+void MenuItemBase::init(PGM_P const el, void * const ev, const int16_t minv, const int16_t maxv, const uint16_t ep, const screenFunc_t cs, const screenFunc_t cb, const bool le) {
   ui.save_previous_screen();
   ui.refresh();
   editLabel = el;
@@ -193,7 +193,7 @@ bool printer_busy() {
 /**
  * General function to go directly to a screen
  */
-void MarlinUI::goto_screen(screenFunc_t screen, const uint32_t encoder/*=0*/, const uint8_t top/*=0*/, const uint8_t items/*=0*/) {
+void MarlinUI::goto_screen(screenFunc_t screen, const uint16_t encoder/*=0*/, const uint8_t top/*=0*/, const uint8_t items/*=0*/) {
   if (currentScreen != screen) {
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
@@ -364,7 +364,7 @@ void MarlinUI::completion_feedback(const bool good/*=true*/) {
     #endif
     ui.encoder_direction_normal();
     if (ui.encoderPosition) {
-      const int16_t babystep_increment = (int32_t)ui.encoderPosition * (BABYSTEP_MULTIPLICATOR);
+      const int16_t babystep_increment = int16_t(ui.encoderPosition) * (BABYSTEP_MULTIPLICATOR);
       ui.encoderPosition = 0;
 
       const float diff = planner.steps_to_mm[Z_AXIS] * babystep_increment,
@@ -438,7 +438,7 @@ void _lcd_draw_homing() {
 
 void do_select_screen(PGM_P const yes, PGM_P const no, bool &yesno, PGM_P const pref, const char * const string, PGM_P const suff) {
   if (ui.encoderPosition) {
-    yesno = int32_t(ui.encoderPosition) > 0;
+    yesno = int16_t(ui.encoderPosition) > 0;
     ui.encoderPosition = 0;
   }
   draw_select_screen(yes, no, yesno, pref, string, suff);

commit 9abe9aff56d44d42c9dc52679cc9f17592cd0bd4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Apr 8 13:44:35 2019 -0500

    Confirm before starting SD print (#13616)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index d69238eb27..69e5c8355c 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -436,4 +436,12 @@ void _lcd_draw_homing() {
   void _lcd_toggle_bed_leveling() { set_bed_leveling_enabled(!planner.leveling_active); }
 #endif
 
+void do_select_screen(PGM_P const yes, PGM_P const no, bool &yesno, PGM_P const pref, const char * const string, PGM_P const suff) {
+  if (ui.encoderPosition) {
+    yesno = int32_t(ui.encoderPosition) > 0;
+    ui.encoderPosition = 0;
+  }
+  draw_select_screen(yes, no, yesno, pref, string, suff);
+}
+
 #endif // HAS_LCD_MENU

commit c29820f649dde443a6a768c5d8a155ba9cc024b7
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Sun Apr 7 23:53:30 2019 +0200

    Suppress compile warning (#13612)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 219c24a4f3..d69238eb27 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -59,7 +59,7 @@ int8_t encoderTopLine, encoderLine, screen_items;
 typedef struct {
   screenFunc_t menu_function;
   uint32_t encoder_position;
-  uint8_t top_line, items;
+  int8_t top_line, items;
 } menuPosition;
 menuPosition screen_history[6];
 uint8_t screen_history_depth = 0;

commit 9cee81d47eea0c8700e265f10f103ca99499511f
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Sat Apr 6 18:04:34 2019 -0500

    Option to show babysteps total since G28 (#13580)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 0365df2356..219c24a4f3 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -37,7 +37,7 @@
   #include "../../module/configuration_store.h"
 #endif
 
-#if WATCH_HOTENDS || WATCH_BED || ENABLED(BABYSTEP_ZPROBE_OFFSET)
+#if WATCH_HOTENDS || WATCH_BED
   #include "../../module/temperature.h"
 #endif
 
@@ -352,6 +352,8 @@ void MarlinUI::completion_feedback(const bool good/*=true*/) {
 
 #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
 
+  #include "../../feature/babystep.h"
+
   void lcd_babystep_zoffset() {
     if (ui.use_click()) return ui.goto_previous_screen_no_defer();
     ui.defer_status_screen();
@@ -376,7 +378,7 @@ void MarlinUI::completion_feedback(const bool good/*=true*/) {
                   ;
       if (WITHIN(new_offs, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
 
-        thermalManager.babystep_axis(Z_AXIS, babystep_increment);
+        babystep.add_steps(Z_AXIS, babystep_increment);
 
         if (do_probe) zprobe_zoffset = new_offs;
         #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)

commit 10b9632bed6ef78ef2460b71526111d89b4113c2
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Apr 4 02:29:44 2019 -0500

    Fix menu history item selection

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 77b2e18fa7..0365df2356 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -54,10 +54,12 @@
 ////////////////////////////////////////////
 
 // Menu Navigation
-int8_t encoderTopLine;
+int8_t encoderTopLine, encoderLine, screen_items;
+
 typedef struct {
   screenFunc_t menu_function;
   uint32_t encoder_position;
+  uint8_t top_line, items;
 } menuPosition;
 menuPosition screen_history[6];
 uint8_t screen_history_depth = 0;
@@ -80,20 +82,14 @@ bool no_reentry = false;
 void MarlinUI::return_to_status() { goto_screen(status_screen); }
 
 void MarlinUI::save_previous_screen() {
-  if (screen_history_depth < COUNT(screen_history)) {
-    screen_history[screen_history_depth].menu_function = currentScreen;
-    screen_history[screen_history_depth].encoder_position = encoderPosition;
-    ++screen_history_depth;
-  }
+  if (screen_history_depth < COUNT(screen_history))
+    screen_history[screen_history_depth++] = { currentScreen, encoderPosition, encoderTopLine, screen_items };
 }
 
 void MarlinUI::goto_previous_screen() {
   if (screen_history_depth > 0) {
-    --screen_history_depth;
-    goto_screen(
-      screen_history[screen_history_depth].menu_function,
-      screen_history[screen_history_depth].encoder_position
-    );
+    menuPosition &sh = screen_history[--screen_history_depth];
+    goto_screen(sh.menu_function, sh.encoder_position, sh.top_line, sh.items);
   }
   else
     return_to_status();
@@ -197,7 +193,7 @@ bool printer_busy() {
 /**
  * General function to go directly to a screen
  */
-void MarlinUI::goto_screen(screenFunc_t screen, const uint32_t encoder/*=0*/) {
+void MarlinUI::goto_screen(screenFunc_t screen, const uint32_t encoder/*=0*/, const uint8_t top/*=0*/, const uint8_t items/*=0*/) {
   if (currentScreen != screen) {
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
@@ -246,6 +242,8 @@ void MarlinUI::goto_screen(screenFunc_t screen, const uint32_t encoder/*=0*/) {
 
     currentScreen = screen;
     encoderPosition = encoder;
+    encoderTopLine = top;
+    screen_items = items;
     if (screen == status_screen) {
       defer_status_screen(false);
       #if ENABLED(AUTO_BED_LEVELING_UBL)
@@ -314,7 +312,6 @@ void MarlinUI::synchronize(PGM_P const msg/*=NULL*/) {
  *   _thisItemNr is the index of each MENU_ITEM or STATIC_ITEM
  *   screen_items is the total number of items in the menu (after one call)
  */
-int8_t encoderLine, screen_items;
 void scroll_screen(const uint8_t limit, const bool is_menu) {
   ui.encoder_direction_menus();
   ENCODER_RATE_MULTIPLY(false);

commit d8329d858d7d2c2b2a9107f99df39a93816c0841
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Mar 23 16:30:43 2019 -0500

    Default argument to defer_status_screen

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 7f0d1a370e..77b2e18fa7 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -357,7 +357,7 @@ void MarlinUI::completion_feedback(const bool good/*=true*/) {
 
   void lcd_babystep_zoffset() {
     if (ui.use_click()) return ui.goto_previous_screen_no_defer();
-    ui.defer_status_screen(true);
+    ui.defer_status_screen();
     #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
       const bool do_probe = (active_extruder == 0);
     #else

commit 49cf92dc36424cf828436f32e72263eca39a1cc3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 16 23:43:06 2019 -0500

    Extended condition macros (#13419)
    
    Allow `ENABLED`, `DISABLED`, `PIN_EXISTS`, and `BUTTON_EXISTS` to take multiple arguments. Also add:
    - Alias `ANY(...)` for `!DISABLED(...)`
    - Alias `ANY_PIN(...)` for `PIN_EXISTS(a) || PIN_EXISTS(b) ...`
    - Alias `EITHER(A,B)` for `ANY(...)`
    - Alias `ALL(...)` and `BOTH(A,B)` for `ENABLED(...)`
    - `NONE(...)` for `DISABLED(...)`

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index b1083bd548..7f0d1a370e 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -45,7 +45,7 @@
   #include "../../module/probe.h"
 #endif
 
-#if ENABLED(ENABLE_LEVELING_FADE_HEIGHT) || ENABLED(AUTO_BED_LEVELING_UBL)
+#if EITHER(ENABLE_LEVELING_FADE_HEIGHT, AUTO_BED_LEVELING_UBL)
   #include "../../feature/bedlevel/bedlevel.h"
 #endif
 
@@ -205,7 +205,7 @@ void MarlinUI::goto_screen(screenFunc_t screen, const uint32_t encoder/*=0*/) {
       lcd_z_fade_height = planner.z_fade_height;
     #endif
 
-    #if ENABLED(DOUBLECLICK_FOR_Z_BABYSTEPPING) && ENABLED(BABYSTEPPING)
+    #if BOTH(DOUBLECLICK_FOR_Z_BABYSTEPPING, BABYSTEPPING)
       static millis_t doubleclick_expire_ms = 0;
       // Going to menu_main from status screen? Remember first click time.
       // Going back to status screen within a very short time? Go to Z babystepping.
@@ -405,7 +405,7 @@ void MarlinUI::completion_feedback(const bool good/*=true*/) {
 
 #endif // BABYSTEP_ZPROBE_OFFSET
 
-#if ENABLED(AUTO_BED_LEVELING_UBL) || ENABLED(PID_AUTOTUNE_MENU) || ENABLED(ADVANCED_PAUSE_FEATURE)
+#if ANY(AUTO_BED_LEVELING_UBL, PID_AUTOTUNE_MENU, ADVANCED_PAUSE_FEATURE)
 
   void lcd_enqueue_command(const char * const cmd) {
     no_reentry = true;

commit 645ca7af7ac27af9d6690659dc71ff9867b34b6c
Author: 3dlabsio <shane@warnertci.com>
Date:   Thu Mar 7 00:09:39 2019 -0800

    M141 Heated Chamber, Temperature rework (#12201)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index f6a5e2c317..b1083bd548 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -37,7 +37,7 @@
   #include "../../module/configuration_store.h"
 #endif
 
-#if WATCH_HOTENDS || WATCH_THE_BED || ENABLED(BABYSTEP_ZPROBE_OFFSET)
+#if WATCH_HOTENDS || WATCH_BED || ENABLED(BABYSTEP_ZPROBE_OFFSET)
   #include "../../module/temperature.h"
 #endif
 
@@ -405,39 +405,6 @@ void MarlinUI::completion_feedback(const bool good/*=true*/) {
 
 #endif // BABYSTEP_ZPROBE_OFFSET
 
-/**
- * Watch temperature callbacks
- */
-#if HAS_TEMP_HOTEND
-  #if WATCH_HOTENDS
-    #define _WATCH_FUNC(N) thermalManager.start_watching_heater(N)
-  #else
-    #define _WATCH_FUNC(N) NOOP
-  #endif
-  void watch_temp_callback_E0() { _WATCH_FUNC(0); }
-  #if HOTENDS > 1
-    void watch_temp_callback_E1() { _WATCH_FUNC(1); }
-    #if HOTENDS > 2
-      void watch_temp_callback_E2() { _WATCH_FUNC(2); }
-      #if HOTENDS > 3
-        void watch_temp_callback_E3() { _WATCH_FUNC(3); }
-        #if HOTENDS > 4
-          void watch_temp_callback_E4() { _WATCH_FUNC(4); }
-          #if HOTENDS > 5
-            void watch_temp_callback_E5() { _WATCH_FUNC(5); }
-          #endif // HOTENDS > 5
-        #endif // HOTENDS > 4
-      #endif // HOTENDS > 3
-    #endif // HOTENDS > 2
-  #endif // HOTENDS > 1
-#endif // HAS_TEMP_HOTEND
-
-void watch_temp_callback_bed() {
-  #if WATCH_THE_BED
-    thermalManager.start_watching_bed();
-  #endif
-}
-
 #if ENABLED(AUTO_BED_LEVELING_UBL) || ENABLED(PID_AUTOTUNE_MENU) || ENABLED(ADVANCED_PAUSE_FEATURE)
 
   void lcd_enqueue_command(const char * const cmd) {

commit eb4bf93ea42c4c83335ca9cef21e78d0c752213f
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Wed Feb 27 05:38:56 2019 -0500

    Add more Babystep options (#13262)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 2c4a4bfce1..f6a5e2c317 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -214,7 +214,19 @@ void MarlinUI::goto_screen(screenFunc_t screen, const uint32_t encoder/*=0*/) {
           doubleclick_expire_ms = millis() + DOUBLECLICK_MAX_INTERVAL;
       }
       else if (screen == status_screen && currentScreen == menu_main && PENDING(millis(), doubleclick_expire_ms)) {
-        if (all_axes_known() && printer_busy()) {
+
+        #if ENABLED(BABYSTEP_WITHOUT_HOMING)
+          constexpr bool can_babystep = true;
+        #else
+          const bool can_babystep = all_axes_known();
+        #endif
+        #if ENABLED(BABYSTEP_ALWAYS_AVAILABLE)
+          constexpr bool should_babystep = true;
+        #else
+          const bool should_babystep = printer_busy();
+        #endif
+
+        if (should_babystep && can_babystep) {
           screen =
             #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
               lcd_babystep_zoffset
@@ -246,10 +258,11 @@ void MarlinUI::goto_screen(screenFunc_t screen, const uint32_t encoder/*=0*/) {
 
     // Re-initialize custom characters that may be re-used
     #if HAS_CHARACTER_LCD
-      #if ENABLED(AUTO_BED_LEVELING_UBL)
-        if (!ubl.lcd_map_control)
-      #endif
-          set_custom_characters(screen == status_screen ? CHARSET_INFO : CHARSET_MENU);
+      if (true
+        #if ENABLED(AUTO_BED_LEVELING_UBL)
+          && !ubl.lcd_map_control
+        #endif
+      ) set_custom_characters(screen == status_screen ? CHARSET_INFO : CHARSET_MENU);
     #endif
 
     refresh(LCDVIEW_CALL_REDRAW_NEXT);

commit d4ed9b3ef12436fc504316ee24b027e5fa7b6dd2
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Feb 17 15:35:45 2019 -0500

    Babystep also requires homing (#13191)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index d2e4cd4fdb..2c4a4bfce1 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -214,7 +214,7 @@ void MarlinUI::goto_screen(screenFunc_t screen, const uint32_t encoder/*=0*/) {
           doubleclick_expire_ms = millis() + DOUBLECLICK_MAX_INTERVAL;
       }
       else if (screen == status_screen && currentScreen == menu_main && PENDING(millis(), doubleclick_expire_ms)) {
-        if (printer_busy()) {
+        if (all_axes_known() && printer_busy()) {
           screen =
             #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
               lcd_babystep_zoffset

commit 7f1b69b0c83ae914ed9ae35fdad9f79814069652
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue Feb 12 16:55:47 2019 -0500

    Add HOST_PROMPT_SUPPORT (#13039)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 648e4bb108..d2e4cd4fdb 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -28,6 +28,7 @@
 #include "../ultralcd.h"
 #include "../../module/planner.h"
 #include "../../module/motion.h"
+#include "../../module/printcounter.h"
 #include "../../gcode/queue.h"
 #include "../../sd/cardreader.h"
 #include "../../libs/buzzer.h"
@@ -189,7 +190,9 @@ void MenuItem_bool::action_edit(PGM_P pstr, bool *ptr, screenFunc_t callback) {
   void _lcd_set_z_fade_height() { set_z_fade_height(lcd_z_fade_height); }
 #endif
 
-bool printer_busy() { return planner.movesplanned() || IS_SD_PRINTING(); }
+bool printer_busy() {
+  return planner.movesplanned() || IS_SD_PRINTING() || print_job_timer.isRunning();
+}
 
 /**
  * General function to go directly to a screen

commit 0feeef26048883640b37ebe3994730f31ef6e922
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 15:06:53 2019 -0600

    Update copyright in headers

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 89318a26e9..648e4bb108 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -1,6 +1,6 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm

commit 6de3d3437849c0710881311bc9ad4069b0aee55d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Feb 10 04:54:23 2019 -0600

    M166 Gradients, LCD Menu for 2-channel Mixer (Geeetech A10M/A20M) (#13022)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index b871989943..89318a26e9 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -158,7 +158,7 @@ void MenuItemBase::init(PGM_P const el, void * const ev, const int32_t minv, con
   liveEdit = le;
 }
 
-#define DEFINE_MENU_EDIT_ITEM(NAME) template class TMenuItem<MenuItemInfo_##NAME>;
+#define DEFINE_MENU_EDIT_ITEM(NAME) template class TMenuItem<MenuItemInfo_##NAME>
 
 DEFINE_MENU_EDIT_ITEM(int3);        // 123, -12   right-justified
 DEFINE_MENU_EDIT_ITEM(int4);        // 1234, -123 right-justified

commit 2f8e89adc395c59678ba0b4a8b2f65230371a732
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 5 19:04:26 2019 -0600

    Remove extraneous ui. prefixes

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 3ea6198b1e..b871989943 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -232,7 +232,7 @@ void MarlinUI::goto_screen(screenFunc_t screen, const uint32_t encoder/*=0*/) {
     currentScreen = screen;
     encoderPosition = encoder;
     if (screen == status_screen) {
-      ui.defer_status_screen(false);
+      defer_status_screen(false);
       #if ENABLED(AUTO_BED_LEVELING_UBL)
         ubl.lcd_map_control = false;
       #endif

commit 17a8c3714843c40cad5686dc19e76a285f848aaa
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jan 28 20:18:58 2019 -0600

    Label menu edit items

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 854edbb7a9..3ea6198b1e 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -160,20 +160,20 @@ void MenuItemBase::init(PGM_P const el, void * const ev, const int32_t minv, con
 
 #define DEFINE_MENU_EDIT_ITEM(NAME) template class TMenuItem<MenuItemInfo_##NAME>;
 
-DEFINE_MENU_EDIT_ITEM(int3);
-DEFINE_MENU_EDIT_ITEM(int4);
-DEFINE_MENU_EDIT_ITEM(int8);
-DEFINE_MENU_EDIT_ITEM(uint8);
-DEFINE_MENU_EDIT_ITEM(uint16_3);
-DEFINE_MENU_EDIT_ITEM(uint16_4);
-DEFINE_MENU_EDIT_ITEM(float3);
-DEFINE_MENU_EDIT_ITEM(float52);
-DEFINE_MENU_EDIT_ITEM(float43);
-DEFINE_MENU_EDIT_ITEM(float5);
-DEFINE_MENU_EDIT_ITEM(float51);
-DEFINE_MENU_EDIT_ITEM(float52sign);
-DEFINE_MENU_EDIT_ITEM(float62);
-DEFINE_MENU_EDIT_ITEM(long5);
+DEFINE_MENU_EDIT_ITEM(int3);        // 123, -12   right-justified
+DEFINE_MENU_EDIT_ITEM(int4);        // 1234, -123 right-justified
+DEFINE_MENU_EDIT_ITEM(int8);        // 123, -12   right-justified
+DEFINE_MENU_EDIT_ITEM(uint8);       // 123        right-justified
+DEFINE_MENU_EDIT_ITEM(uint16_3);    // 123, -12   right-justified
+DEFINE_MENU_EDIT_ITEM(uint16_4);    // 1234, -123 right-justified
+DEFINE_MENU_EDIT_ITEM(float3);      // 123        right-justified
+DEFINE_MENU_EDIT_ITEM(float52);     // 123.45
+DEFINE_MENU_EDIT_ITEM(float43);     // 1.234
+DEFINE_MENU_EDIT_ITEM(float5);      // 12345      right-justified
+DEFINE_MENU_EDIT_ITEM(float51);     // +1234.5
+DEFINE_MENU_EDIT_ITEM(float52sign); // +123.45
+DEFINE_MENU_EDIT_ITEM(float62);     // 1234.56    right-justified
+DEFINE_MENU_EDIT_ITEM(long5);       // 12345      right-justified
 
 void MenuItem_bool::action_edit(PGM_P pstr, bool *ptr, screenFunc_t callback) {
   UNUSED(pstr); *ptr ^= true; ui.refresh();

commit e6805582a67b106691423a35ab580bd6b0895949
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Thu Jan 17 21:17:16 2019 +0200

    M569 to change stepping mode. Add new TMC section to LCD. (#12884)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index d440a63f94..854edbb7a9 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -164,7 +164,8 @@ DEFINE_MENU_EDIT_ITEM(int3);
 DEFINE_MENU_EDIT_ITEM(int4);
 DEFINE_MENU_EDIT_ITEM(int8);
 DEFINE_MENU_EDIT_ITEM(uint8);
-DEFINE_MENU_EDIT_ITEM(uint16);
+DEFINE_MENU_EDIT_ITEM(uint16_3);
+DEFINE_MENU_EDIT_ITEM(uint16_4);
 DEFINE_MENU_EDIT_ITEM(float3);
 DEFINE_MENU_EDIT_ITEM(float52);
 DEFINE_MENU_EDIT_ITEM(float43);

commit eb78aed863cf20cc02f07b8c3e47d27ae4ed91dd
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jan 12 16:01:04 2019 -0600

    Rename LCD menus according to variable types (#12892)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 8046a5d811..d440a63f94 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -115,7 +115,7 @@ void MenuItem_gcode::action(PGM_P pgcode) { enqueue_and_echo_commands_P(pgcode);
  *
  * The prerequisite is that in the header the type was already declared:
  *
- *   DECLARE_MENU_EDIT_TYPE(int16_t, int3, itostr3, 1)
+ *   DECLARE_MENU_EDIT_TYPE(int16_t, int3, i16tostr3, 1)
  *
  * For example, DEFINE_MENU_EDIT_ITEM(int3) expands into these functions:
  *
@@ -163,6 +163,8 @@ void MenuItemBase::init(PGM_P const el, void * const ev, const int32_t minv, con
 DEFINE_MENU_EDIT_ITEM(int3);
 DEFINE_MENU_EDIT_ITEM(int4);
 DEFINE_MENU_EDIT_ITEM(int8);
+DEFINE_MENU_EDIT_ITEM(uint8);
+DEFINE_MENU_EDIT_ITEM(uint16);
 DEFINE_MENU_EDIT_ITEM(float3);
 DEFINE_MENU_EDIT_ITEM(float52);
 DEFINE_MENU_EDIT_ITEM(float43);

commit 826d5701627f4c725ab9e0c61a53643008c5dbbf
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Nov 18 19:58:02 2018 -0600

    Combine Travis CI option-setting commands (#12474)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 352eed24df..8046a5d811 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -243,7 +243,7 @@ void MarlinUI::goto_screen(screenFunc_t screen, const uint32_t encoder/*=0*/) {
       #if ENABLED(AUTO_BED_LEVELING_UBL)
         if (!ubl.lcd_map_control)
       #endif
-          LCD_SET_CHARSET(screen == status_screen ? CHARSET_INFO : CHARSET_MENU);
+          set_custom_characters(screen == status_screen ? CHARSET_INFO : CHARSET_MENU);
     #endif
 
     refresh(LCDVIEW_CALL_REDRAW_NEXT);

commit d82c350de741b6f20a3d4860c9cdc30dae20f746
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Nov 14 13:13:51 2018 -0600

    Miscellaneous LCD code renaming, reordering (#12430)
    
    * Move special characters to language.h
    * Apply some naming standards
    * Clean up menu item draw functions
    * Rename some Temperature methods
    * UI => ExtUI

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index c67dbdb48e..352eed24df 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -102,7 +102,7 @@ void MarlinUI::goto_previous_screen() {
 /////////// Common Menu Actions ////////////
 ////////////////////////////////////////////
 
-void menu_item_gcode::action(PGM_P pgcode) { enqueue_and_echo_commands_P(pgcode); }
+void MenuItem_gcode::action(PGM_P pgcode) { enqueue_and_echo_commands_P(pgcode); }
 
 ////////////////////////////////////////////
 /////////// Menu Editing Actions ///////////
@@ -119,18 +119,18 @@ void menu_item_gcode::action(PGM_P pgcode) { enqueue_and_echo_commands_P(pgcode)
  *
  * For example, DEFINE_MENU_EDIT_ITEM(int3) expands into these functions:
  *
- *   bool menu_item_int3::_edit();
- *   void menu_item_int3::edit(); // edit int16_t (interactively)
- *   void menu_item_int3::action_setting_edit(PGM_P const pstr, int16_t * const ptr, const int16_t minValue, const int16_t maxValue, const screenFunc_t callback = null, const bool live = false);
+ *   bool MenuItem_int3::_edit();
+ *   void MenuItem_int3::edit(); // edit int16_t (interactively)
+ *   void MenuItem_int3::action_edit(PGM_P const pstr, int16_t * const ptr, const int16_t minValue, const int16_t maxValue, const screenFunc_t callback = null, const bool live = false);
  *
  * You can then use one of the menu macros to present the edit interface:
  *   MENU_ITEM_EDIT(int3, MSG_SPEED, &feedrate_percentage, 10, 999)
  *
  * This expands into a more primitive menu item:
- *   MENU_ITEM_VARIANT(int3, _setting_edit, MSG_SPEED, PSTR(MSG_SPEED), &feedrate_percentage, 10, 999)
+ *   MENU_ITEM_VARIANT(int3, _edit, MSG_SPEED, PSTR(MSG_SPEED), &feedrate_percentage, 10, 999)
  *
  * ...which calls:
- *       menu_item_int3::action_setting_edit(PSTR(MSG_SPEED), &feedrate_percentage, 10, 999)
+ *       MenuItem_int3::action_edit(PSTR(MSG_SPEED), &feedrate_percentage, 10, 999)
  */
 void MenuItemBase::edit(strfunc_t strfunc, loadfunc_t loadfunc) {
   ui.encoder_direction_normal();
@@ -158,7 +158,7 @@ void MenuItemBase::init(PGM_P const el, void * const ev, const int32_t minv, con
   liveEdit = le;
 }
 
-#define DEFINE_MENU_EDIT_ITEM(NAME) template class TMenuItem<NAME ## _item_info>;
+#define DEFINE_MENU_EDIT_ITEM(NAME) template class TMenuItem<MenuItemInfo_##NAME>;
 
 DEFINE_MENU_EDIT_ITEM(int3);
 DEFINE_MENU_EDIT_ITEM(int4);
@@ -172,7 +172,7 @@ DEFINE_MENU_EDIT_ITEM(float52sign);
 DEFINE_MENU_EDIT_ITEM(float62);
 DEFINE_MENU_EDIT_ITEM(long5);
 
-void menu_item_bool::action_setting_edit(PGM_P pstr, bool *ptr, screenFunc_t callback) {
+void MenuItem_bool::action_edit(PGM_P pstr, bool *ptr, screenFunc_t callback) {
   UNUSED(pstr); *ptr ^= true; ui.refresh();
   if (callback) (*callback)();
 }

commit be6271767fd06b7a333031e2fbff2cbd711330af
Author: AnHardt <github@kitelab.de>
Date:   Tue Nov 13 00:44:21 2018 +0100

    Fix BABYSTEP_ZPROBE_OFFSET (#12408)
    
    Fix #12399
    
    Did not compile without  `WATCH_HOTENDS || WATCH_THE_BED`.
    Add condition to include "../../module/temperature.h".

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index e3d9f09d49..c67dbdb48e 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -36,7 +36,7 @@
   #include "../../module/configuration_store.h"
 #endif
 
-#if WATCH_HOTENDS || WATCH_THE_BED
+#if WATCH_HOTENDS || WATCH_THE_BED || ENABLED(BABYSTEP_ZPROBE_OFFSET)
   #include "../../module/temperature.h"
 #endif
 

commit a0c795b097a30eff006c8dff178abf5f1f1907fa
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Nov 11 12:16:24 2018 -0600

    Encapsulate common display code in a singleton (#12395)
    
    * Encapsulate common LCD code in a singleton
    * Depend more UBL code on UBL_DEVEL_DEBUGGING
      - Since most users don't need the debugging on at all times, this helps reduce the default build size for UBL by over 2K, a little closer to fitting on 128K boards.

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 346a81729d..e3d9f09d49 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -30,6 +30,7 @@
 #include "../../module/motion.h"
 #include "../../gcode/queue.h"
 #include "../../sd/cardreader.h"
+#include "../../libs/buzzer.h"
 
 #if ENABLED(EEPROM_SETTINGS)
   #include "../../module/configuration_store.h"
@@ -61,10 +62,6 @@ menuPosition screen_history[6];
 uint8_t screen_history_depth = 0;
 bool screen_changed;
 
-#if LCD_TIMEOUT_TO_STATUS
-  bool defer_return_to_status;
-#endif
-
 // Value Editing
 PGM_P editLabel;
 void *editValue;
@@ -79,9 +76,9 @@ bool no_reentry = false;
 //////// Menu Navigation & History /////////
 ////////////////////////////////////////////
 
-void lcd_return_to_status() { lcd_goto_screen(lcd_status_screen); }
+void MarlinUI::return_to_status() { goto_screen(status_screen); }
 
-void lcd_save_previous_screen() {
+void MarlinUI::save_previous_screen() {
   if (screen_history_depth < COUNT(screen_history)) {
     screen_history[screen_history_depth].menu_function = currentScreen;
     screen_history[screen_history_depth].encoder_position = encoderPosition;
@@ -89,25 +86,18 @@ void lcd_save_previous_screen() {
   }
 }
 
-void lcd_goto_previous_menu() {
+void MarlinUI::goto_previous_screen() {
   if (screen_history_depth > 0) {
     --screen_history_depth;
-    lcd_goto_screen(
+    goto_screen(
       screen_history[screen_history_depth].menu_function,
       screen_history[screen_history_depth].encoder_position
     );
   }
   else
-    lcd_return_to_status();
+    return_to_status();
 }
 
-#if LCD_TIMEOUT_TO_STATUS
-  void lcd_goto_previous_menu_no_defer() {
-    set_defer_return_to_status(false);
-    lcd_goto_previous_menu();
-  }
-#endif
-
 ////////////////////////////////////////////
 /////////// Common Menu Actions ////////////
 ////////////////////////////////////////////
@@ -142,34 +132,33 @@ void menu_item_gcode::action(PGM_P pgcode) { enqueue_and_echo_commands_P(pgcode)
  * ...which calls:
  *       menu_item_int3::action_setting_edit(PSTR(MSG_SPEED), &feedrate_percentage, 10, 999)
  */
-void menu_item_invariants::edit(strfunc_t strfunc, loadfunc_t loadfunc) {
-  ENCODER_DIRECTION_NORMAL();
-  if ((int32_t)encoderPosition < 0) encoderPosition = 0;
-  if ((int32_t)encoderPosition > maxEditValue) encoderPosition = maxEditValue;
-  if (lcdDrawUpdate)
-    lcd_implementation_drawedit(editLabel, strfunc(encoderPosition + minEditValue));
-  if (lcd_clicked || (liveEdit && lcdDrawUpdate)) {
-    if (editValue != NULL) loadfunc(editValue, encoderPosition + minEditValue);
-    if (callbackFunc && (liveEdit || lcd_clicked)) (*callbackFunc)();
-    if (lcd_clicked) lcd_goto_previous_menu();
-    lcd_clicked = false;
+void MenuItemBase::edit(strfunc_t strfunc, loadfunc_t loadfunc) {
+  ui.encoder_direction_normal();
+  if ((int32_t)ui.encoderPosition < 0) ui.encoderPosition = 0;
+  if ((int32_t)ui.encoderPosition > maxEditValue) ui.encoderPosition = maxEditValue;
+  if (ui.should_draw())
+    draw_edit_screen(editLabel, strfunc(ui.encoderPosition + minEditValue));
+  if (ui.lcd_clicked || (liveEdit && ui.should_draw())) {
+    if (editValue != NULL) loadfunc(editValue, ui.encoderPosition + minEditValue);
+    if (callbackFunc && (liveEdit || ui.lcd_clicked)) (*callbackFunc)();
+    if (ui.use_click()) ui.goto_previous_screen();
   }
 }
 
-void menu_item_invariants::init(PGM_P const el, void * const ev, const int32_t minv, const int32_t maxv, const uint32_t ep, const screenFunc_t cs, const screenFunc_t cb, const bool le) {
-  lcd_save_previous_screen();
-  lcd_refresh();
+void MenuItemBase::init(PGM_P const el, void * const ev, const int32_t minv, const int32_t maxv, const uint32_t ep, const screenFunc_t cs, const screenFunc_t cb, const bool le) {
+  ui.save_previous_screen();
+  ui.refresh();
   editLabel = el;
   editValue = ev;
   minEditValue = minv;
   maxEditValue = maxv;
-  encoderPosition = ep;
-  currentScreen = cs;
+  ui.encoderPosition = ep;
+  ui.currentScreen = cs;
   callbackFunc = cb;
   liveEdit = le;
 }
 
-#define DEFINE_MENU_EDIT_ITEM(NAME) template class menu_item_template<NAME ## _item_info>;
+#define DEFINE_MENU_EDIT_ITEM(NAME) template class TMenuItem<NAME ## _item_info>;
 
 DEFINE_MENU_EDIT_ITEM(int3);
 DEFINE_MENU_EDIT_ITEM(int4);
@@ -184,7 +173,7 @@ DEFINE_MENU_EDIT_ITEM(float62);
 DEFINE_MENU_EDIT_ITEM(long5);
 
 void menu_item_bool::action_setting_edit(PGM_P pstr, bool *ptr, screenFunc_t callback) {
-  UNUSED(pstr); *ptr ^= true; lcd_refresh();
+  UNUSED(pstr); *ptr ^= true; ui.refresh();
   if (callback) (*callback)();
 }
 
@@ -202,7 +191,7 @@ bool printer_busy() { return planner.movesplanned() || IS_SD_PRINTING(); }
 /**
  * General function to go directly to a screen
  */
-void lcd_goto_screen(screenFunc_t screen, const uint32_t encoder/*=0*/) {
+void MarlinUI::goto_screen(screenFunc_t screen, const uint32_t encoder/*=0*/) {
   if (currentScreen != screen) {
 
     #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
@@ -215,10 +204,10 @@ void lcd_goto_screen(screenFunc_t screen, const uint32_t encoder/*=0*/) {
       // Going to menu_main from status screen? Remember first click time.
       // Going back to status screen within a very short time? Go to Z babystepping.
       if (screen == menu_main) {
-        if (currentScreen == lcd_status_screen)
+        if (on_status_screen())
           doubleclick_expire_ms = millis() + DOUBLECLICK_MAX_INTERVAL;
       }
-      else if (screen == lcd_status_screen && currentScreen == menu_main && PENDING(millis(), doubleclick_expire_ms)) {
+      else if (screen == status_screen && currentScreen == menu_main && PENDING(millis(), doubleclick_expire_ms)) {
         if (printer_busy()) {
           screen =
             #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
@@ -239,25 +228,25 @@ void lcd_goto_screen(screenFunc_t screen, const uint32_t encoder/*=0*/) {
 
     currentScreen = screen;
     encoderPosition = encoder;
-    if (screen == lcd_status_screen) {
-      set_defer_return_to_status(false);
+    if (screen == status_screen) {
+      ui.defer_status_screen(false);
       #if ENABLED(AUTO_BED_LEVELING_UBL)
         ubl.lcd_map_control = false;
       #endif
       screen_history_depth = 0;
     }
 
-    lcd_implementation_clear();
+    clear_lcd();
 
     // Re-initialize custom characters that may be re-used
     #if HAS_CHARACTER_LCD
       #if ENABLED(AUTO_BED_LEVELING_UBL)
         if (!ubl.lcd_map_control)
       #endif
-          LCD_SET_CHARSET(screen == lcd_status_screen ? CHARSET_INFO : CHARSET_MENU);
+          LCD_SET_CHARSET(screen == status_screen ? CHARSET_INFO : CHARSET_MENU);
     #endif
 
-    lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
+    refresh(LCDVIEW_CALL_REDRAW_NEXT);
     screen_changed = true;
     #if HAS_GRAPHICAL_LCD
       drawing_screen = false;
@@ -276,24 +265,24 @@ void lcd_goto_screen(screenFunc_t screen, const uint32_t encoder/*=0*/) {
 //
 static PGM_P sync_message;
 
-void _lcd_synchronize() {
-  if (lcdDrawUpdate) lcd_implementation_drawmenu_static(LCD_HEIGHT >= 4 ? 1 : 0, sync_message);
+void MarlinUI::_synchronize() {
+  if (should_draw()) draw_menu_item_static(LCD_HEIGHT >= 4 ? 1 : 0, sync_message);
   if (no_reentry) return;
   // Make this the current handler till all moves are done
   no_reentry = true;
   const screenFunc_t old_screen = currentScreen;
-  lcd_goto_screen(_lcd_synchronize);
+  goto_screen(_synchronize);
   planner.synchronize(); // idle() is called until moves complete
   no_reentry = false;
-  lcd_goto_screen(old_screen);
+  goto_screen(old_screen);
 }
 
 // Display the synchronize screen with a custom message
 // ** This blocks the command queue! **
-void lcd_synchronize(PGM_P const msg/*=NULL*/) {
+void MarlinUI::synchronize(PGM_P const msg/*=NULL*/) {
   static const char moving[] PROGMEM = MSG_MOVING;
   sync_message = msg ? msg : moving;
-  _lcd_synchronize();
+  _synchronize();
 }
 
 /**
@@ -308,16 +297,16 @@ void lcd_synchronize(PGM_P const msg/*=NULL*/) {
  */
 int8_t encoderLine, screen_items;
 void scroll_screen(const uint8_t limit, const bool is_menu) {
-  ENCODER_DIRECTION_MENUS();
+  ui.encoder_direction_menus();
   ENCODER_RATE_MULTIPLY(false);
-  if (encoderPosition > 0x8000) encoderPosition = 0;
-  if (first_page) {
-    encoderLine = encoderPosition / (ENCODER_STEPS_PER_MENU_ITEM);
+  if (ui.encoderPosition > 0x8000) ui.encoderPosition = 0;
+  if (ui.first_page) {
+    encoderLine = ui.encoderPosition / (ENCODER_STEPS_PER_MENU_ITEM);
     screen_changed = false;
   }
   if (screen_items > 0 && encoderLine >= screen_items - limit) {
     encoderLine = MAX(0, screen_items - limit);
-    encoderPosition = encoderLine * (ENCODER_STEPS_PER_MENU_ITEM);
+    ui.encoderPosition = encoderLine * (ENCODER_STEPS_PER_MENU_ITEM);
   }
   if (is_menu) {
     NOMORE(encoderTopLine, encoderLine);
@@ -328,12 +317,12 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
     encoderTopLine = encoderLine;
 }
 
-void lcd_completion_feedback(const bool good/*=true*/) {
+void MarlinUI::completion_feedback(const bool good/*=true*/) {
   if (good) {
-    lcd_buzz(100, 659);
-    lcd_buzz(100, 698);
+    BUZZ(100, 659);
+    BUZZ(100, 698);
   }
-  else lcd_buzz(20, 440);
+  else BUZZ(20, 440);
 }
 
 #if HAS_LINE_TO_Z
@@ -348,17 +337,17 @@ void lcd_completion_feedback(const bool good/*=true*/) {
 #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
 
   void lcd_babystep_zoffset() {
-    if (use_click()) { return lcd_goto_previous_menu_no_defer(); }
-    set_defer_return_to_status(true);
+    if (ui.use_click()) return ui.goto_previous_screen_no_defer();
+    ui.defer_status_screen(true);
     #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
       const bool do_probe = (active_extruder == 0);
     #else
       constexpr bool do_probe = true;
     #endif
-    ENCODER_DIRECTION_NORMAL();
-    if (encoderPosition) {
-      const int16_t babystep_increment = (int32_t)encoderPosition * (BABYSTEP_MULTIPLICATOR);
-      encoderPosition = 0;
+    ui.encoder_direction_normal();
+    if (ui.encoderPosition) {
+      const int16_t babystep_increment = (int32_t)ui.encoderPosition * (BABYSTEP_MULTIPLICATOR);
+      ui.encoderPosition = 0;
 
       const float diff = planner.steps_to_mm[Z_AXIS] * babystep_increment,
                   new_probe_offset = zprobe_zoffset + diff,
@@ -378,16 +367,16 @@ void lcd_completion_feedback(const bool good/*=true*/) {
           else hotend_offset[Z_AXIS][active_extruder] = new_offs;
         #endif
 
-        lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
+        ui.refresh(LCDVIEW_CALL_REDRAW_NEXT);
       }
     }
-    if (lcdDrawUpdate) {
+    if (ui.should_draw()) {
       #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
         if (!do_probe)
-          lcd_implementation_drawedit(PSTR(MSG_IDEX_Z_OFFSET), ftostr43sign(hotend_offset[Z_AXIS][active_extruder]));
+          draw_edit_screen(PSTR(MSG_IDEX_Z_OFFSET), ftostr43sign(hotend_offset[Z_AXIS][active_extruder]));
         else
       #endif
-          lcd_implementation_drawedit(PSTR(MSG_ZPROBE_ZOFFSET), ftostr43sign(zprobe_zoffset));
+          draw_edit_screen(PSTR(MSG_ZPROBE_ZOFFSET), ftostr43sign(zprobe_zoffset));
 
       #if ENABLED(BABYSTEP_ZPROBE_GFX_OVERLAY)
         if (do_probe) _lcd_zoffset_overlay_gfx(zprobe_zoffset);
@@ -447,14 +436,14 @@ void watch_temp_callback_bed() {
 #endif
 
 #if ENABLED(EEPROM_SETTINGS)
-  void lcd_store_settings()   { lcd_completion_feedback(settings.save()); }
-  void lcd_load_settings()    { lcd_completion_feedback(settings.load()); }
+  void lcd_store_settings()   { ui.completion_feedback(settings.save()); }
+  void lcd_load_settings()    { ui.completion_feedback(settings.load()); }
 #endif
 
 void _lcd_draw_homing() {
   constexpr uint8_t line = (LCD_HEIGHT - 1) / 2;
-  if (lcdDrawUpdate) lcd_implementation_drawmenu_static(line, PSTR(MSG_LEVEL_BED_HOMING));
-  lcdDrawUpdate = LCDVIEW_CALL_NO_REDRAW;
+  if (ui.should_draw()) draw_menu_item_static(line, PSTR(MSG_LEVEL_BED_HOMING));
+  ui.refresh(LCDVIEW_CALL_NO_REDRAW);
 }
 
 #if ENABLED(LCD_BED_LEVELING) || (HAS_LEVELING && DISABLED(SLIM_LCD_MENUS))

commit e574f015680f88137b2ccb0fa159ebd5749c26fb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Nov 6 19:25:57 2018 -0600

    More advanced pause tweaks (#12356)
    
    * Followup to LCD_TIMEOUT_TO_STATUS=0
    * Make continuous purge screen fit 20x4
    * Unify purge message modes
    * Preserve last-set pause header mode

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index cd7e193fc6..346a81729d 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -59,7 +59,11 @@ typedef struct {
 } menuPosition;
 menuPosition screen_history[6];
 uint8_t screen_history_depth = 0;
-bool screen_changed, defer_return_to_status;
+bool screen_changed;
+
+#if LCD_TIMEOUT_TO_STATUS
+  bool defer_return_to_status;
+#endif
 
 // Value Editing
 PGM_P editLabel;
@@ -97,10 +101,12 @@ void lcd_goto_previous_menu() {
     lcd_return_to_status();
 }
 
-void lcd_goto_previous_menu_no_defer() {
-  defer_return_to_status = false;
-  lcd_goto_previous_menu();
-}
+#if LCD_TIMEOUT_TO_STATUS
+  void lcd_goto_previous_menu_no_defer() {
+    set_defer_return_to_status(false);
+    lcd_goto_previous_menu();
+  }
+#endif
 
 ////////////////////////////////////////////
 /////////// Common Menu Actions ////////////
@@ -234,7 +240,7 @@ void lcd_goto_screen(screenFunc_t screen, const uint32_t encoder/*=0*/) {
     currentScreen = screen;
     encoderPosition = encoder;
     if (screen == lcd_status_screen) {
-      defer_return_to_status = false;
+      set_defer_return_to_status(false);
       #if ENABLED(AUTO_BED_LEVELING_UBL)
         ubl.lcd_map_control = false;
       #endif
@@ -343,7 +349,7 @@ void lcd_completion_feedback(const bool good/*=true*/) {
 
   void lcd_babystep_zoffset() {
     if (use_click()) { return lcd_goto_previous_menu_no_defer(); }
-    defer_return_to_status = true;
+    set_defer_return_to_status(true);
     #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
       const bool do_probe = (active_extruder == 0);
     #else

commit 8517d5f91560cb3c6ee32f5220759ee535d64fb7
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Mon Nov 5 21:51:10 2018 -0700

    LCD menu code refactoring and cleanup (#12308)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 52b6573328..cd7e193fc6 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -106,10 +106,7 @@ void lcd_goto_previous_menu_no_defer() {
 /////////// Common Menu Actions ////////////
 ////////////////////////////////////////////
 
-void _menu_action_back() { lcd_goto_previous_menu(); }
-void menu_action_submenu(screenFunc_t func) { lcd_save_previous_screen(); lcd_goto_screen(func); }
-void menu_action_gcode(PGM_P pgcode) { enqueue_and_echo_commands_P(pgcode); }
-void menu_action_function(screenFunc_t func) { (*func)(); }
+void menu_item_gcode::action(PGM_P pgcode) { enqueue_and_echo_commands_P(pgcode); }
 
 ////////////////////////////////////////////
 /////////// Menu Editing Actions ///////////
@@ -118,76 +115,71 @@ void menu_action_function(screenFunc_t func) { (*func)(); }
 /**
  * Functions for editing single values
  *
- * The "DEFINE_MENU_EDIT_TYPE" macro generates the functions needed to edit a numerical value.
+ * The "DEFINE_MENU_EDIT_ITEM" macro generates the functions needed to edit a numerical value.
  *
- * For example, DEFINE_MENU_EDIT_TYPE(int16_t, int3, itostr3, 1) expands into these functions:
+ * The prerequisite is that in the header the type was already declared:
  *
- *   bool _menu_edit_int3();
- *   void menu_edit_int3(); // edit int16_t (interactively)
- *   void menu_edit_callback_int3(); // edit int16_t (interactively) with callback on completion
- *   void _menu_action_setting_edit_int3(PGM_P const pstr, int16_t * const ptr, const int16_t minValue, const int16_t maxValue);
- *   void menu_action_setting_edit_int3(PGM_P const pstr, int16_t * const ptr, const int16_t minValue, const int16_t maxValue);
- *   void menu_action_setting_edit_callback_int3(PGM_P const pstr, int16_t * const ptr, const int16_t minValue, const int16_t maxValue, const screenFunc_t callback, const bool live); // edit int16_t with callback
+ *   DECLARE_MENU_EDIT_TYPE(int16_t, int3, itostr3, 1)
+ *
+ * For example, DEFINE_MENU_EDIT_ITEM(int3) expands into these functions:
+ *
+ *   bool menu_item_int3::_edit();
+ *   void menu_item_int3::edit(); // edit int16_t (interactively)
+ *   void menu_item_int3::action_setting_edit(PGM_P const pstr, int16_t * const ptr, const int16_t minValue, const int16_t maxValue, const screenFunc_t callback = null, const bool live = false);
  *
  * You can then use one of the menu macros to present the edit interface:
  *   MENU_ITEM_EDIT(int3, MSG_SPEED, &feedrate_percentage, 10, 999)
  *
  * This expands into a more primitive menu item:
- *   MENU_ITEM(setting_edit_int3, MSG_SPEED, PSTR(MSG_SPEED), &feedrate_percentage, 10, 999)
+ *   MENU_ITEM_VARIANT(int3, _setting_edit, MSG_SPEED, PSTR(MSG_SPEED), &feedrate_percentage, 10, 999)
  *
  * ...which calls:
- *       menu_action_setting_edit_int3(PSTR(MSG_SPEED), &feedrate_percentage, 10, 999)
+ *       menu_item_int3::action_setting_edit(PSTR(MSG_SPEED), &feedrate_percentage, 10, 999)
  */
-#define DEFINE_MENU_EDIT_TYPE(TYPE, NAME, STRFUNC, SCALE) \
-  bool _menu_edit_ ## NAME() { \
-    ENCODER_DIRECTION_NORMAL(); \
-    if ((int32_t)encoderPosition < 0) encoderPosition = 0; \
-    if ((int32_t)encoderPosition > maxEditValue) encoderPosition = maxEditValue; \
-    if (lcdDrawUpdate) \
-      lcd_implementation_drawedit(editLabel, STRFUNC(((TYPE)((int32_t)encoderPosition + minEditValue)) * (1.0f / SCALE))); \
-    if (lcd_clicked || (liveEdit && lcdDrawUpdate)) { \
-      TYPE value = ((TYPE)((int32_t)encoderPosition + minEditValue)) * (1.0f / SCALE); \
-      if (editValue != NULL) *((TYPE*)editValue) = value; \
-      if (callbackFunc && (liveEdit || lcd_clicked)) (*callbackFunc)(); \
-      if (lcd_clicked) lcd_goto_previous_menu(); \
-    } \
-    return use_click(); \
-  } \
-  void menu_edit_ ## NAME() { _menu_edit_ ## NAME(); } \
-  void _menu_action_setting_edit_ ## NAME(PGM_P const pstr, TYPE* const ptr, const TYPE minValue, const TYPE maxValue) { \
-    lcd_save_previous_screen(); \
-    lcd_refresh(); \
-    \
-    editLabel = pstr; \
-    editValue = ptr; \
-    minEditValue = minValue * SCALE; \
-    maxEditValue = maxValue * SCALE - minEditValue; \
-    encoderPosition = (*ptr) * SCALE - minEditValue; \
-  } \
-  void menu_action_setting_edit_callback_ ## NAME(PGM_P const pstr, TYPE * const ptr, const TYPE minValue, const TYPE maxValue, const screenFunc_t callback/*=NULL*/, const bool live/*=false*/) { \
-    _menu_action_setting_edit_ ## NAME(pstr, ptr, minValue, maxValue); \
-    currentScreen = menu_edit_ ## NAME; \
-    callbackFunc = callback; \
-    liveEdit = live; \
-  } \
-  typedef void NAME##_void
-
-DEFINE_MENU_EDIT_TYPE(int16_t, int3, itostr3, 1);
-DEFINE_MENU_EDIT_TYPE(int16_t, int4, itostr4sign, 1);
-DEFINE_MENU_EDIT_TYPE(uint8_t, int8, i8tostr3, 1);
-DEFINE_MENU_EDIT_TYPE(float, float3, ftostr3, 1);
-DEFINE_MENU_EDIT_TYPE(float, float52, ftostr52, 100);
-DEFINE_MENU_EDIT_TYPE(float, float43, ftostr43sign, 1000);
-DEFINE_MENU_EDIT_TYPE(float, float5, ftostr5rj, 0.01f);
-DEFINE_MENU_EDIT_TYPE(float, float51, ftostr51sign, 10);
-DEFINE_MENU_EDIT_TYPE(float, float52sign, ftostr52sign, 100);
-DEFINE_MENU_EDIT_TYPE(float, float62, ftostr62rj, 100);
-DEFINE_MENU_EDIT_TYPE(uint32_t, long5, ftostr5rj, 0.01f);
-
-void menu_action_setting_edit_bool(PGM_P pstr, bool* ptr) { UNUSED(pstr); *ptr ^= true; lcd_refresh(); }
-void menu_action_setting_edit_callback_bool(PGM_P pstr, bool* ptr, screenFunc_t callback) {
-  menu_action_setting_edit_bool(pstr, ptr);
-  (*callback)();
+void menu_item_invariants::edit(strfunc_t strfunc, loadfunc_t loadfunc) {
+  ENCODER_DIRECTION_NORMAL();
+  if ((int32_t)encoderPosition < 0) encoderPosition = 0;
+  if ((int32_t)encoderPosition > maxEditValue) encoderPosition = maxEditValue;
+  if (lcdDrawUpdate)
+    lcd_implementation_drawedit(editLabel, strfunc(encoderPosition + minEditValue));
+  if (lcd_clicked || (liveEdit && lcdDrawUpdate)) {
+    if (editValue != NULL) loadfunc(editValue, encoderPosition + minEditValue);
+    if (callbackFunc && (liveEdit || lcd_clicked)) (*callbackFunc)();
+    if (lcd_clicked) lcd_goto_previous_menu();
+    lcd_clicked = false;
+  }
+}
+
+void menu_item_invariants::init(PGM_P const el, void * const ev, const int32_t minv, const int32_t maxv, const uint32_t ep, const screenFunc_t cs, const screenFunc_t cb, const bool le) {
+  lcd_save_previous_screen();
+  lcd_refresh();
+  editLabel = el;
+  editValue = ev;
+  minEditValue = minv;
+  maxEditValue = maxv;
+  encoderPosition = ep;
+  currentScreen = cs;
+  callbackFunc = cb;
+  liveEdit = le;
+}
+
+#define DEFINE_MENU_EDIT_ITEM(NAME) template class menu_item_template<NAME ## _item_info>;
+
+DEFINE_MENU_EDIT_ITEM(int3);
+DEFINE_MENU_EDIT_ITEM(int4);
+DEFINE_MENU_EDIT_ITEM(int8);
+DEFINE_MENU_EDIT_ITEM(float3);
+DEFINE_MENU_EDIT_ITEM(float52);
+DEFINE_MENU_EDIT_ITEM(float43);
+DEFINE_MENU_EDIT_ITEM(float5);
+DEFINE_MENU_EDIT_ITEM(float51);
+DEFINE_MENU_EDIT_ITEM(float52sign);
+DEFINE_MENU_EDIT_ITEM(float62);
+DEFINE_MENU_EDIT_ITEM(long5);
+
+void menu_item_bool::action_setting_edit(PGM_P pstr, bool *ptr, screenFunc_t callback) {
+  UNUSED(pstr); *ptr ^= true; lcd_refresh();
+  if (callback) (*callback)();
 }
 
 ////////////////////////////////////////////

commit 3583e2b4490e8fd6778d18003641c2fdd333e8a5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Oct 30 16:34:45 2018 -0500

    Followup to Menu Refactor (#12275)

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 181d067333..52b6573328 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -22,7 +22,7 @@
 
 #include "../../inc/MarlinConfigPre.h"
 
-#if ENABLED(ULTIPANEL)
+#if HAS_LCD_MENU
 
 #include "menu.h"
 #include "../ultralcd.h"
@@ -75,8 +75,6 @@ bool no_reentry = false;
 //////// Menu Navigation & History /////////
 ////////////////////////////////////////////
 
-void lcd_status_screen();
-
 void lcd_return_to_status() { lcd_goto_screen(lcd_status_screen); }
 
 void lcd_save_previous_screen() {
@@ -203,14 +201,6 @@ void menu_action_setting_edit_callback_bool(PGM_P pstr, bool* ptr, screenFunc_t
 
 bool printer_busy() { return planner.movesplanned() || IS_SD_PRINTING(); }
 
-#if HAS_CHARACTER_LCD && (ENABLED(LCD_PROGRESS_BAR) || ENABLED(LCD_PROGRESS_BAR_TEST) || ENABLED(AUTO_BED_LEVELING_UBL))
-  void lcd_set_custom_characters(
-    #if ENABLED(LCD_PROGRESS_BAR) || ENABLED(SHOW_BOOTSCREEN)
-      const uint8_t screen_charset=CHARSET_INFO
-    #endif
-  );
-#endif
-
 /**
  * General function to go directly to a screen
  */
@@ -258,19 +248,17 @@ void lcd_goto_screen(screenFunc_t screen, const uint32_t encoder/*=0*/) {
       #endif
       screen_history_depth = 0;
     }
+
     lcd_implementation_clear();
+
     // Re-initialize custom characters that may be re-used
-    #if HAS_CHARACTER_LCD && ENABLED(AUTO_BED_LEVELING_UBL)
-      if (!ubl.lcd_map_control) {
-        lcd_set_custom_characters(
-          #if ENABLED(LCD_PROGRESS_BAR)
-            screen == lcd_status_screen ? CHARSET_INFO : CHARSET_MENU
-          #endif
-        );
-      }
-    #elif ENABLED(LCD_PROGRESS_BAR)
-      lcd_set_custom_characters(screen == lcd_status_screen ? CHARSET_INFO : CHARSET_MENU);
+    #if HAS_CHARACTER_LCD
+      #if ENABLED(AUTO_BED_LEVELING_UBL)
+        if (!ubl.lcd_map_control)
+      #endif
+          LCD_SET_CHARSET(screen == lcd_status_screen ? CHARSET_INFO : CHARSET_MENU);
     #endif
+
     lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
     screen_changed = true;
     #if HAS_GRAPHICAL_LCD
@@ -476,4 +464,4 @@ void _lcd_draw_homing() {
   void _lcd_toggle_bed_leveling() { set_bed_leveling_enabled(!planner.leveling_active); }
 #endif
 
-#endif // ULTIPANEL
+#endif // HAS_LCD_MENU

commit b063b1b7229c1706690f167a99528e13d4ff371d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Oct 28 02:59:21 2018 -0500

    Reorganize includes and declarations

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index e31a12d93a..181d067333 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -25,34 +25,32 @@
 #if ENABLED(ULTIPANEL)
 
 #include "menu.h"
-
 #include "../ultralcd.h"
 #include "../../module/planner.h"
 #include "../../module/motion.h"
-#include "../../module/probe.h"
-#include "../../module/printcounter.h"
-#include "../../gcode/gcode.h"
 #include "../../gcode/queue.h"
-#include "../../module/configuration_store.h"
-#include "../../module/tool_change.h"
-#include "../../Marlin.h"
+#include "../../sd/cardreader.h"
 
-#include <stdarg.h>
+#if ENABLED(EEPROM_SETTINGS)
+  #include "../../module/configuration_store.h"
+#endif
+
+#if WATCH_HOTENDS || WATCH_THE_BED
+  #include "../../module/temperature.h"
+#endif
 
-#if ENABLED(SDSUPPORT)
-  #include "../../sd/cardreader.h"
+#if ENABLED(BABYSTEP_ZPROBE_OFFSET)
+  #include "../../module/probe.h"
+#endif
+
+#if ENABLED(ENABLE_LEVELING_FADE_HEIGHT) || ENABLED(AUTO_BED_LEVELING_UBL)
+  #include "../../feature/bedlevel/bedlevel.h"
 #endif
 
 ////////////////////////////////////////////
 ///////////// Global Variables /////////////
 ////////////////////////////////////////////
 
-// Buttons
-volatile uint8_t buttons;
-#if ENABLED(REPRAPWORLD_KEYPAD)
-  volatile uint8_t buttons_reprapworld_keypad;
-#endif
-
 // Menu Navigation
 int8_t encoderTopLine;
 typedef struct {
@@ -70,12 +68,9 @@ int32_t minEditValue, maxEditValue;
 screenFunc_t callbackFunc;
 bool liveEdit;
 
+// Prevent recursion into screen handlers
 bool no_reentry = false;
 
-// Initialized by settings.load()
-int16_t lcd_preheat_hotend_temp[2], lcd_preheat_bed_temp[2];
-uint8_t lcd_preheat_fan_speed[2];
-
 ////////////////////////////////////////////
 //////// Menu Navigation & History /////////
 ////////////////////////////////////////////
@@ -110,7 +105,7 @@ void lcd_goto_previous_menu_no_defer() {
 }
 
 ////////////////////////////////////////////
-/////////////// Menu Actions ///////////////
+/////////// Common Menu Actions ////////////
 ////////////////////////////////////////////
 
 void _menu_action_back() { lcd_goto_previous_menu(); }
@@ -355,14 +350,14 @@ void lcd_completion_feedback(const bool good/*=true*/) {
   else lcd_buzz(20, 440);
 }
 
-inline void line_to_current_z() {
-  planner.buffer_line(current_position, MMM_TO_MMS(manual_feedrate_mm_m[Z_AXIS]), active_extruder);
-}
+#if HAS_LINE_TO_Z
 
-void line_to_z(const float &z) {
-  current_position[Z_AXIS] = z;
-  line_to_current_z();
-}
+  void line_to_z(const float &z) {
+    current_position[Z_AXIS] = z;
+    planner.buffer_line(current_position, MMM_TO_MMS(manual_feedrate_mm_m[Z_AXIS]), active_extruder);
+  }
+
+#endif
 
 #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
 

commit 43cf9130481a497984a935933d13c6d097157e64
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Oct 28 03:10:25 2018 -0500

    Move SD Card Menu to its own file

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index b95b7b9836..e31a12d93a 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -118,30 +118,6 @@ void menu_action_submenu(screenFunc_t func) { lcd_save_previous_screen(); lcd_go
 void menu_action_gcode(PGM_P pgcode) { enqueue_and_echo_commands_P(pgcode); }
 void menu_action_function(screenFunc_t func) { (*func)(); }
 
-#if ENABLED(SDSUPPORT)
-
-  void menu_action_sdfile(CardReader &theCard) {
-    #if ENABLED(SD_REPRINT_LAST_SELECTED_FILE)
-      last_sdfile_encoderPosition = encoderPosition;  // Save which file was selected for later use
-    #endif
-    card.openAndPrintFile(theCard.filename);
-    lcd_return_to_status();
-    lcd_reset_status();
-  }
-
-  void menu_action_sddirectory(CardReader &theCard) {
-    card.chdir(theCard.filename);
-    encoderTopLine = 0;
-    encoderPosition = 2 * ENCODER_STEPS_PER_MENU_ITEM;
-    screen_changed = true;
-    #if HAS_GRAPHICAL_LCD
-      drawing_screen = false;
-    #endif
-    lcd_refresh();
-  }
-
-#endif // SDSUPPORT
-
 ////////////////////////////////////////////
 /////////// Menu Editing Actions ///////////
 ////////////////////////////////////////////
@@ -505,97 +481,4 @@ void _lcd_draw_homing() {
   void _lcd_toggle_bed_leveling() { set_bed_leveling_enabled(!planner.leveling_active); }
 #endif
 
-#if ENABLED(SDSUPPORT)
-
-  #if !PIN_EXISTS(SD_DETECT)
-    void lcd_sd_refresh() {
-      card.initsd();
-      encoderTopLine = 0;
-    }
-  #endif
-
-  void lcd_sd_updir() {
-    encoderPosition = card.updir() ? ENCODER_STEPS_PER_MENU_ITEM : 0;
-    encoderTopLine = 0;
-    screen_changed = true;
-    lcd_refresh();
-  }
-
-  /**
-   *
-   * "Print from SD" submenu
-   *
-   */
-
-  #if ENABLED(SD_REPRINT_LAST_SELECTED_FILE)
-    uint32_t last_sdfile_encoderPosition = 0xFFFF;
-
-    void lcd_reselect_last_file() {
-      if (last_sdfile_encoderPosition == 0xFFFF) return;
-      #if HAS_GRAPHICAL_LCD
-        // Some of this is a hack to force the screen update to work.
-        // TODO: Fix the real issue that causes this!
-        lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
-        lcd_synchronize();
-        safe_delay(50);
-        lcd_synchronize();
-        lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
-        drawing_screen = screen_changed = true;
-      #endif
-
-      lcd_goto_screen(menu_sdcard, last_sdfile_encoderPosition);
-      defer_return_to_status = true;
-      last_sdfile_encoderPosition = 0xFFFF;
-
-      #if HAS_GRAPHICAL_LCD
-        lcd_update();
-      #endif
-    }
-  #endif
-
-  void menu_sdcard() {
-    ENCODER_DIRECTION_MENUS();
-
-    const uint16_t fileCnt = card.get_num_Files();
-
-    START_MENU();
-    MENU_BACK(MSG_MAIN);
-    card.getWorkDirName();
-    if (card.filename[0] == '/') {
-      #if !PIN_EXISTS(SD_DETECT)
-        MENU_ITEM(function, LCD_STR_REFRESH MSG_REFRESH, lcd_sd_refresh);
-      #endif
-    }
-    else {
-      MENU_ITEM(function, LCD_STR_FOLDER "..", lcd_sd_updir);
-    }
-
-    for (uint16_t i = 0; i < fileCnt; i++) {
-      if (_menuLineNr == _thisItemNr) {
-        const uint16_t nr =
-          #if ENABLED(SDCARD_RATHERRECENTFIRST) && DISABLED(SDCARD_SORT_ALPHA)
-            fileCnt - 1 -
-          #endif
-        i;
-
-        #if ENABLED(SDCARD_SORT_ALPHA)
-          card.getfilename_sorted(nr);
-        #else
-          card.getfilename(nr);
-        #endif
-
-        if (card.filenameIsDir)
-          MENU_ITEM(sddirectory, MSG_CARD_MENU, card);
-        else
-          MENU_ITEM(sdfile, MSG_CARD_MENU, card);
-      }
-      else {
-        MENU_ITEM_DUMMY();
-      }
-    }
-    END_MENU();
-  }
-
-#endif // SDSUPPORT
-
 #endif // ULTIPANEL

commit 0161d3f733a8b67d6aedd63aba6fc7beae229890
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Oct 28 03:05:17 2018 -0500

    Move Custom User Menu to its own file

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 55209ed3c0..b95b7b9836 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -388,63 +388,6 @@ void line_to_z(const float &z) {
   line_to_current_z();
 }
 
-#if ENABLED(CUSTOM_USER_MENUS)
-
-  #ifdef USER_SCRIPT_DONE
-    #define _DONE_SCRIPT "\n" USER_SCRIPT_DONE
-  #else
-    #define _DONE_SCRIPT ""
-  #endif
-
-  void _lcd_user_gcode(PGM_P const cmd) {
-    enqueue_and_echo_commands_P(cmd);
-    #if ENABLED(USER_SCRIPT_AUDIBLE_FEEDBACK)
-      lcd_completion_feedback();
-    #endif
-    #if ENABLED(USER_SCRIPT_RETURN)
-      lcd_return_to_status();
-    #endif
-  }
-
-  #if defined(USER_DESC_1) && defined(USER_GCODE_1)
-    void lcd_user_gcode_1() { _lcd_user_gcode(PSTR(USER_GCODE_1 _DONE_SCRIPT)); }
-  #endif
-  #if defined(USER_DESC_2) && defined(USER_GCODE_2)
-    void lcd_user_gcode_2() { _lcd_user_gcode(PSTR(USER_GCODE_2 _DONE_SCRIPT)); }
-  #endif
-  #if defined(USER_DESC_3) && defined(USER_GCODE_3)
-    void lcd_user_gcode_3() { _lcd_user_gcode(PSTR(USER_GCODE_3 _DONE_SCRIPT)); }
-  #endif
-  #if defined(USER_DESC_4) && defined(USER_GCODE_4)
-    void lcd_user_gcode_4() { _lcd_user_gcode(PSTR(USER_GCODE_4 _DONE_SCRIPT)); }
-  #endif
-  #if defined(USER_DESC_5) && defined(USER_GCODE_5)
-    void lcd_user_gcode_5() { _lcd_user_gcode(PSTR(USER_GCODE_5 _DONE_SCRIPT)); }
-  #endif
-
-  void _menu_user() {
-    START_MENU();
-    MENU_BACK(MSG_MAIN);
-    #if defined(USER_DESC_1) && defined(USER_GCODE_1)
-      MENU_ITEM(function, USER_DESC_1, lcd_user_gcode_1);
-    #endif
-    #if defined(USER_DESC_2) && defined(USER_GCODE_2)
-      MENU_ITEM(function, USER_DESC_2, lcd_user_gcode_2);
-    #endif
-    #if defined(USER_DESC_3) && defined(USER_GCODE_3)
-      MENU_ITEM(function, USER_DESC_3, lcd_user_gcode_3);
-    #endif
-    #if defined(USER_DESC_4) && defined(USER_GCODE_4)
-      MENU_ITEM(function, USER_DESC_4, lcd_user_gcode_4);
-    #endif
-    #if defined(USER_DESC_5) && defined(USER_GCODE_5)
-      MENU_ITEM(function, USER_DESC_5, lcd_user_gcode_5);
-    #endif
-    END_MENU();
-  }
-
-#endif
-
 #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
 
   void lcd_babystep_zoffset() {

commit 3b0d2330b6d6904e08f8bb6ba5ca2c488b040f65
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Oct 28 01:59:47 2018 -0500

    Move Delta Calibrate Menu to its own file

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 17b4d42ff8..55209ed3c0 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -43,10 +43,6 @@
   #include "../../sd/cardreader.h"
 #endif
 
-#if HAS_LEVELING
-  #include "../../feature/bedlevel/bedlevel.h"
-#endif
-
 ////////////////////////////////////////////
 ///////////// Global Variables /////////////
 ////////////////////////////////////////////
@@ -562,107 +558,10 @@ void _lcd_draw_homing() {
 }
 
 #if ENABLED(LCD_BED_LEVELING) || (HAS_LEVELING && DISABLED(SLIM_LCD_MENUS))
+  #include "../../feature/bedlevel/bedlevel.h"
   void _lcd_toggle_bed_leveling() { set_bed_leveling_enabled(!planner.leveling_active); }
 #endif
 
-#if ENABLED(DELTA_CALIBRATION_MENU) || ENABLED(DELTA_AUTO_CALIBRATION)
-
-  void _man_probe_pt(const float &rx, const float &ry) {
-    do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
-    do_blocking_move_to_xy(rx, ry);
-
-    lcd_synchronize();
-    move_menu_scale = MAX(PROBE_MANUALLY_STEP, MIN_STEPS_PER_SEGMENT / float(DEFAULT_XYZ_STEPS_PER_UNIT));
-    lcd_goto_screen(lcd_move_z);
-  }
-
-#endif // DELTA_CALIBRATION_MENU || DELTA_AUTO_CALIBRATION
-
-#if ENABLED(DELTA_AUTO_CALIBRATION)
-
-  float lcd_probe_pt(const float &rx, const float &ry) {
-    _man_probe_pt(rx, ry);
-    KEEPALIVE_STATE(PAUSED_FOR_USER);
-    defer_return_to_status = true;
-    wait_for_user = true;
-    while (wait_for_user) idle();
-    KEEPALIVE_STATE(IN_HANDLER);
-    lcd_goto_previous_menu_no_defer();
-    return current_position[Z_AXIS];
-  }
-
-#endif // DELTA_AUTO_CALIBRATION
-
-#if ENABLED(DELTA_CALIBRATION_MENU)
-
-  void _lcd_calibrate_homing() {
-    _lcd_draw_homing();
-    if (all_axes_homed()) lcd_goto_previous_menu();
-  }
-
-  void _lcd_delta_calibrate_home() {
-    enqueue_and_echo_commands_P(PSTR("G28"));
-    lcd_goto_screen(_lcd_calibrate_homing);
-  }
-
-  void _goto_tower_x() { _man_probe_pt(cos(RADIANS(210)) * delta_calibration_radius, sin(RADIANS(210)) * delta_calibration_radius); }
-  void _goto_tower_y() { _man_probe_pt(cos(RADIANS(330)) * delta_calibration_radius, sin(RADIANS(330)) * delta_calibration_radius); }
-  void _goto_tower_z() { _man_probe_pt(cos(RADIANS( 90)) * delta_calibration_radius, sin(RADIANS( 90)) * delta_calibration_radius); }
-  void _goto_center()  { _man_probe_pt(0,0); }
-
-#endif // DELTA_CALIBRATION_MENU
-
-#if ENABLED(DELTA_CALIBRATION_MENU) || ENABLED(DELTA_AUTO_CALIBRATION)
-
-  void _recalc_delta_settings() {
-    #if HAS_LEVELING
-      reset_bed_level(); // After changing kinematics bed-level data is no longer valid
-    #endif
-    recalc_delta_settings();
-  }
-
-  void lcd_delta_settings() {
-    START_MENU();
-    MENU_BACK(MSG_DELTA_CALIBRATE);
-    MENU_ITEM_EDIT_CALLBACK(float52sign, MSG_DELTA_HEIGHT, &delta_height, delta_height - 10, delta_height + 10, _recalc_delta_settings);
-    MENU_ITEM_EDIT_CALLBACK(float43, "Ex", &delta_endstop_adj[A_AXIS], -5, 5, _recalc_delta_settings);
-    MENU_ITEM_EDIT_CALLBACK(float43, "Ey", &delta_endstop_adj[B_AXIS], -5, 5, _recalc_delta_settings);
-    MENU_ITEM_EDIT_CALLBACK(float43, "Ez", &delta_endstop_adj[C_AXIS], -5, 5, _recalc_delta_settings);
-    MENU_ITEM_EDIT_CALLBACK(float52sign, MSG_DELTA_RADIUS, &delta_radius, delta_radius - 5, delta_radius + 5, _recalc_delta_settings);
-    MENU_ITEM_EDIT_CALLBACK(float43, "Tx", &delta_tower_angle_trim[A_AXIS], -5, 5, _recalc_delta_settings);
-    MENU_ITEM_EDIT_CALLBACK(float43, "Ty", &delta_tower_angle_trim[B_AXIS], -5, 5, _recalc_delta_settings);
-    MENU_ITEM_EDIT_CALLBACK(float43, "Tz", &delta_tower_angle_trim[C_AXIS], -5, 5, _recalc_delta_settings);
-    MENU_ITEM_EDIT_CALLBACK(float52sign, MSG_DELTA_DIAG_ROD, &delta_diagonal_rod, delta_diagonal_rod - 5, delta_diagonal_rod + 5, _recalc_delta_settings);
-    END_MENU();
-  }
-
-  void menu_delta_calibrate() {
-    START_MENU();
-    MENU_BACK(MSG_MAIN);
-    #if ENABLED(DELTA_AUTO_CALIBRATION)
-      MENU_ITEM(gcode, MSG_DELTA_AUTO_CALIBRATE, PSTR("G33"));
-      MENU_ITEM(gcode, MSG_DELTA_HEIGHT_CALIBRATE, PSTR("G33 S P1"));
-      MENU_ITEM(gcode, MSG_DELTA_Z_OFFSET_CALIBRATE, PSTR("G33 P-1"));
-      #if ENABLED(EEPROM_SETTINGS)
-        MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
-        MENU_ITEM(function, MSG_LOAD_EEPROM, lcd_load_settings);
-      #endif
-    #endif
-    MENU_ITEM(submenu, MSG_DELTA_SETTINGS, lcd_delta_settings);
-    #if ENABLED(DELTA_CALIBRATION_MENU)
-      MENU_ITEM(submenu, MSG_AUTO_HOME, _lcd_delta_calibrate_home);
-      if (all_axes_homed()) {
-        MENU_ITEM(submenu, MSG_DELTA_CALIBRATE_X, _goto_tower_x);
-        MENU_ITEM(submenu, MSG_DELTA_CALIBRATE_Y, _goto_tower_y);
-        MENU_ITEM(submenu, MSG_DELTA_CALIBRATE_Z, _goto_tower_z);
-        MENU_ITEM(submenu, MSG_DELTA_CALIBRATE_CENTER, _goto_center);
-      }
-    #endif
-    END_MENU();
-  }
-
-#endif // DELTA_CALIBRATION_MENU || DELTA_AUTO_CALIBRATION
-
 #if ENABLED(SDSUPPORT)
 
   #if !PIN_EXISTS(SD_DETECT)

commit 6896847210c7b9e594e373d3f698d897870ced0d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Oct 28 01:48:56 2018 -0500

    Move LED Menu to its own file

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index a65d9020b4..17b4d42ff8 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -43,18 +43,10 @@
   #include "../../sd/cardreader.h"
 #endif
 
-#if ENABLED(ADVANCED_PAUSE_FEATURE)
-  #include "../../feature/pause.h"
-#endif
-
 #if HAS_LEVELING
   #include "../../feature/bedlevel/bedlevel.h"
 #endif
 
-#if ENABLED(LED_CONTROL_MENU)
-  #include "../../feature/leds/leds.h"
-#endif
-
 ////////////////////////////////////////////
 ///////////// Global Variables /////////////
 ////////////////////////////////////////////
@@ -764,62 +756,4 @@ void _lcd_draw_homing() {
 
 #endif // SDSUPPORT
 
-/**
- *
- * LED Menu
- *
- */
-
-#if ENABLED(LED_CONTROL_MENU)
-
-  #if ENABLED(LED_COLOR_PRESETS)
-
-    void menu_led_presets() {
-      START_MENU();
-      #if LCD_HEIGHT > 2
-        STATIC_ITEM(MSG_LED_PRESETS, true, true);
-      #endif
-      MENU_BACK(MSG_LED_CONTROL);
-      MENU_ITEM(function, MSG_SET_LEDS_WHITE, leds.set_white);
-      MENU_ITEM(function, MSG_SET_LEDS_RED, leds.set_red);
-      MENU_ITEM(function, MSG_SET_LEDS_ORANGE, leds.set_orange);
-      MENU_ITEM(function, MSG_SET_LEDS_YELLOW,leds.set_yellow);
-      MENU_ITEM(function, MSG_SET_LEDS_GREEN, leds.set_green);
-      MENU_ITEM(function, MSG_SET_LEDS_BLUE, leds.set_blue);
-      MENU_ITEM(function, MSG_SET_LEDS_INDIGO, leds.set_indigo);
-      MENU_ITEM(function, MSG_SET_LEDS_VIOLET, leds.set_violet);
-      END_MENU();
-    }
-  #endif // LED_COLOR_PRESETS
-
-  void menu_led_custom() {
-    START_MENU();
-    MENU_BACK(MSG_LED_CONTROL);
-    MENU_ITEM_EDIT_CALLBACK(int8, MSG_INTENSITY_R, &leds.color.r, 0, 255, leds.update, true);
-    MENU_ITEM_EDIT_CALLBACK(int8, MSG_INTENSITY_G, &leds.color.g, 0, 255, leds.update, true);
-    MENU_ITEM_EDIT_CALLBACK(int8, MSG_INTENSITY_B, &leds.color.b, 0, 255, leds.update, true);
-    #if ENABLED(RGBW_LED) || ENABLED(NEOPIXEL_LED)
-      MENU_ITEM_EDIT_CALLBACK(int8, MSG_INTENSITY_W, &leds.color.w, 0, 255, leds.update, true);
-      #if ENABLED(NEOPIXEL_LED)
-        MENU_ITEM_EDIT_CALLBACK(int8, MSG_LED_BRIGHTNESS, &leds.color.i, 0, 255, leds.update, true);
-      #endif
-    #endif
-    END_MENU();
-  }
-
-  void menu_led() {
-    START_MENU();
-    MENU_BACK(MSG_MAIN);
-    bool led_on = leds.lights_on;
-    MENU_ITEM_EDIT_CALLBACK(bool, MSG_LEDS, &led_on, leds.toggle);
-    MENU_ITEM(function, MSG_SET_LEDS_DEFAULT, leds.set_default);
-    #if ENABLED(LED_COLOR_PRESETS)
-      MENU_ITEM(submenu, MSG_LED_PRESETS, menu_led_presets);
-    #endif
-    MENU_ITEM(submenu, MSG_CUSTOM_LEDS, menu_led_custom);
-    END_MENU();
-  }
-
-#endif // LED_CONTROL_MENU
-
 #endif // ULTIPANEL

commit 9cd54712021568fc3dbb1dc49388b912a88116c5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Oct 27 22:48:28 2018 -0500

    Move Job Recovery Menu to its own file

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index ff449d6f39..a65d9020b4 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -27,7 +27,6 @@
 #include "menu.h"
 
 #include "../ultralcd.h"
-#include "../../sd/cardreader.h"
 #include "../../module/planner.h"
 #include "../../module/motion.h"
 #include "../../module/probe.h"
@@ -40,16 +39,12 @@
 
 #include <stdarg.h>
 
-#if ENABLED(ADVANCED_PAUSE_FEATURE)
-  #include "../../feature/pause.h"
-#endif
-
-#if ENABLED(POWER_LOSS_RECOVERY)
-  #include "../../feature/power_loss_recovery.h"
+#if ENABLED(SDSUPPORT)
+  #include "../../sd/cardreader.h"
 #endif
 
-#if ENABLED(PRINTCOUNTER) && ENABLED(LCD_INFO_MENU)
-  #include "../../libs/duration_t.h"
+#if ENABLED(ADVANCED_PAUSE_FEATURE)
+  #include "../../feature/pause.h"
 #endif
 
 #if HAS_LEVELING
@@ -405,80 +400,6 @@ void line_to_z(const float &z) {
   line_to_current_z();
 }
 
-#if ENABLED(POWER_LOSS_RECOVERY)
-
-  static void lcd_power_loss_recovery_resume() {
-    char cmd[20];
-
-    // Return to status now
-    lcd_return_to_status();
-
-    // Turn leveling off and home
-    enqueue_and_echo_commands_P(PSTR("M420 S0\nG28 R0"
-      #if ENABLED(MARLIN_DEV_MODE)
-        " S"
-      #elif !IS_KINEMATIC
-        " X Y"
-      #endif
-    ));
-
-    #if HAS_HEATED_BED
-      const int16_t bt = job_recovery_info.target_temperature_bed;
-      if (bt) {
-        // Restore the bed temperature
-        sprintf_P(cmd, PSTR("M190 S%i"), bt);
-        enqueue_and_echo_command(cmd);
-      }
-    #endif
-
-    // Restore all hotend temperatures
-    HOTEND_LOOP() {
-      const int16_t et = job_recovery_info.target_temperature[e];
-      if (et) {
-        #if HOTENDS > 1
-          sprintf_P(cmd, PSTR("T%i"), e);
-          enqueue_and_echo_command(cmd);
-        #endif
-        sprintf_P(cmd, PSTR("M109 S%i"), et);
-        enqueue_and_echo_command(cmd);
-      }
-    }
-
-    #if HOTENDS > 1
-      sprintf_P(cmd, PSTR("T%i"), job_recovery_info.active_hotend);
-      enqueue_and_echo_command(cmd);
-    #endif
-
-    // Restore print cooling fan speeds
-    for (uint8_t i = 0; i < FAN_COUNT; i++) {
-      uint8_t f = job_recovery_info.fan_speed[i];
-      if (f) {
-        sprintf_P(cmd, PSTR("M106 P%i S%i"), i, f);
-        enqueue_and_echo_command(cmd);
-      }
-    }
-
-    // Start draining the job recovery command queue
-    job_recovery_phase = JOB_RECOVERY_YES;
-  }
-
-  static void lcd_power_loss_recovery_cancel() {
-    card.removeJobRecoveryFile();
-    card.autostart_index = 0;
-    lcd_return_to_status();
-  }
-
-  void menu_job_recovery() {
-    defer_return_to_status = true;
-    START_MENU();
-    STATIC_ITEM(MSG_POWER_LOSS_RECOVERY);
-    MENU_ITEM(function, MSG_RESUME_PRINT, lcd_power_loss_recovery_resume);
-    MENU_ITEM(function, MSG_STOP_PRINT, lcd_power_loss_recovery_cancel);
-    END_MENU();
-  }
-
-#endif // POWER_LOSS_RECOVERY
-
 #if ENABLED(CUSTOM_USER_MENUS)
 
   #ifdef USER_SCRIPT_DONE

commit 9f11e0284c3ea690c2583a9e260eaf203946c476
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Oct 27 21:31:06 2018 -0500

    Move Filament Change Menu to its own file

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 892b1cc056..ff449d6f39 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -28,7 +28,6 @@
 
 #include "../ultralcd.h"
 #include "../../sd/cardreader.h"
-#include "../../module/temperature.h"
 #include "../../module/planner.h"
 #include "../../module/motion.h"
 #include "../../module/probe.h"
@@ -243,14 +242,6 @@ void menu_action_setting_edit_callback_bool(PGM_P pstr, bool* ptr, screenFunc_t
 ///////////////// Menu Tree ////////////////
 ////////////////////////////////////////////
 
-#if ENABLED(ADVANCED_PAUSE_FEATURE)
-  #if E_STEPPERS > 1 || ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
-    void menu_change_filament();
-  #else
-    void menu_temp_e0_filament_change();
-  #endif
-#endif
-
 #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
   float lcd_z_fade_height;
   void _lcd_set_z_fade_height() { set_z_fade_height(lcd_z_fade_height); }
@@ -910,561 +901,4 @@ void _lcd_draw_homing() {
 
 #endif // LED_CONTROL_MENU
 
-/**
- *
- * Filament Change Feature Screens
- *
- */
-#if ENABLED(ADVANCED_PAUSE_FEATURE)
-
-  /**
-   *
-   * "Change Filament" > "Change/Unload/Load Filament" submenu
-   *
-   */
-  static AdvancedPauseMode _change_filament_temp_mode; // =ADVANCED_PAUSE_MODE_PAUSE_PRINT
-  static int8_t _change_filament_temp_extruder; // =0
-
-  static PGM_P _change_filament_temp_command() {
-    switch (_change_filament_temp_mode) {
-      case ADVANCED_PAUSE_MODE_LOAD_FILAMENT:
-        return PSTR("M701 T%d");
-      case ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT:
-        return _change_filament_temp_extruder >= 0 ? PSTR("M702 T%d") : PSTR("M702 ;%d");
-      case ADVANCED_PAUSE_MODE_PAUSE_PRINT:
-      default:
-        return PSTR("M600 B0 T%d");
-    }
-    return PSTR(MSG_FILAMENTCHANGE);
-  }
-
-  void _change_filament_temp(const uint16_t temperature) {
-    char cmd[11];
-    sprintf_P(cmd, _change_filament_temp_command(), _change_filament_temp_extruder);
-    thermalManager.setTargetHotend(temperature, _change_filament_temp_extruder);
-    lcd_enqueue_command(cmd);
-  }
-  void _menu_change_filament_temp_1() { _change_filament_temp(PREHEAT_1_TEMP_HOTEND); }
-  void _menu_change_filament_temp_2() { _change_filament_temp(PREHEAT_2_TEMP_HOTEND); }
-  void _menu_change_filament_temp_custom() { _change_filament_temp(thermalManager.target_temperature[_change_filament_temp_extruder]); }
-
-  static PGM_P change_filament_header(const AdvancedPauseMode mode) {
-    switch (mode) {
-      case ADVANCED_PAUSE_MODE_LOAD_FILAMENT:
-        return PSTR(MSG_FILAMENTLOAD);
-      case ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT:
-        return PSTR(MSG_FILAMENTUNLOAD);
-      default: break;
-    }
-    return PSTR(MSG_FILAMENTCHANGE);
-  }
-
-  void _menu_temp_filament_op(const AdvancedPauseMode mode, const int8_t extruder) {
-    _change_filament_temp_mode = mode;
-    _change_filament_temp_extruder = extruder;
-    START_MENU();
-    if (LCD_HEIGHT >= 4) STATIC_ITEM_P(change_filament_header(mode), true, true);
-    MENU_BACK(MSG_BACK);
-    MENU_ITEM(submenu, MSG_PREHEAT_1, _menu_change_filament_temp_1);
-    MENU_ITEM(submenu, MSG_PREHEAT_2, _menu_change_filament_temp_2);
-    uint16_t max_temp;
-    switch (extruder) {
-      default: max_temp = HEATER_0_MAXTEMP;
-      #if HOTENDS > 1
-        case 1: max_temp = HEATER_1_MAXTEMP; break;
-        #if HOTENDS > 2
-          case 2: max_temp = HEATER_2_MAXTEMP; break;
-          #if HOTENDS > 3
-            case 3: max_temp = HEATER_3_MAXTEMP; break;
-            #if HOTENDS > 4
-              case 4: max_temp = HEATER_4_MAXTEMP; break;
-              #if HOTENDS > 5
-                case 5: max_temp = HEATER_5_MAXTEMP; break;
-              #endif
-            #endif
-          #endif
-        #endif
-      #endif
-    }
-    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_PREHEAT_CUSTOM, &thermalManager.target_temperature[_change_filament_temp_extruder], EXTRUDE_MINTEMP, max_temp - 15, _menu_change_filament_temp_custom);
-    END_MENU();
-  }
-  void menu_temp_e0_filament_change()  { _menu_temp_filament_op(ADVANCED_PAUSE_MODE_PAUSE_PRINT, 0); }
-  void menu_temp_e0_filament_load()    { _menu_temp_filament_op(ADVANCED_PAUSE_MODE_LOAD_FILAMENT, 0); }
-  void menu_temp_e0_filament_unload()  { _menu_temp_filament_op(ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT, 0); }
-  #if E_STEPPERS > 1
-    void menu_temp_e1_filament_change()  { _menu_temp_filament_op(ADVANCED_PAUSE_MODE_PAUSE_PRINT, 1); }
-    void menu_temp_e1_filament_load()    { _menu_temp_filament_op(ADVANCED_PAUSE_MODE_LOAD_FILAMENT, 1); }
-    void menu_temp_e1_filament_unload()  { _menu_temp_filament_op(ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT, 1); }
-    #if ENABLED(FILAMENT_UNLOAD_ALL_EXTRUDERS)
-      void menu_unload_filament_all_temp() { _menu_temp_filament_op(ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT, -1); }
-    #endif
-    #if E_STEPPERS > 2
-      void menu_temp_e2_filament_change()  { _menu_temp_filament_op(ADVANCED_PAUSE_MODE_PAUSE_PRINT, 2); }
-      void menu_temp_e2_filament_load()    { _menu_temp_filament_op(ADVANCED_PAUSE_MODE_LOAD_FILAMENT, 2); }
-      void menu_temp_e2_filament_unload()  { _menu_temp_filament_op(ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT, 2); }
-      #if E_STEPPERS > 3
-        void menu_temp_e3_filament_change()  { _menu_temp_filament_op(ADVANCED_PAUSE_MODE_PAUSE_PRINT, 3); }
-        void menu_temp_e3_filament_load()    { _menu_temp_filament_op(ADVANCED_PAUSE_MODE_LOAD_FILAMENT, 3); }
-        void menu_temp_e3_filament_unload()  { _menu_temp_filament_op(ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT, 3); }
-        #if E_STEPPERS > 4
-          void menu_temp_e4_filament_change()  { _menu_temp_filament_op(ADVANCED_PAUSE_MODE_PAUSE_PRINT, 4); }
-          void menu_temp_e4_filament_load()    { _menu_temp_filament_op(ADVANCED_PAUSE_MODE_LOAD_FILAMENT, 4); }
-          void menu_temp_e4_filament_unload()  { _menu_temp_filament_op(ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT, 4); }
-        #endif // E_STEPPERS > 4
-      #endif // E_STEPPERS > 3
-    #endif // E_STEPPERS > 2
-  #endif // E_STEPPERS > 1
-
-  /**
-   *
-   * "Change Filament" submenu
-   *
-   */
-  #if E_STEPPERS > 1 || ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
-    void menu_change_filament() {
-      START_MENU();
-      MENU_BACK(MSG_MAIN);
-
-      // Change filament
-      #if E_STEPPERS == 1
-        PGM_P msg0 = PSTR(MSG_FILAMENTCHANGE);
-        if (thermalManager.targetTooColdToExtrude(active_extruder))
-          MENU_ITEM_P(submenu, msg0, menu_temp_e0_filament_change);
-        else
-          MENU_ITEM_P(gcode, msg0, PSTR("M600 B0"));
-      #else
-        PGM_P msg0 = PSTR(MSG_FILAMENTCHANGE " " MSG_E1);
-        PGM_P msg1 = PSTR(MSG_FILAMENTCHANGE " " MSG_E2);
-        if (thermalManager.targetTooColdToExtrude(0))
-          MENU_ITEM_P(submenu, msg0, menu_temp_e0_filament_change);
-        else
-          MENU_ITEM_P(gcode, msg0, PSTR("M600 B0 T0"));
-        if (thermalManager.targetTooColdToExtrude(1))
-          MENU_ITEM_P(submenu, msg1, menu_temp_e1_filament_change);
-        else
-          MENU_ITEM_P(gcode, msg1, PSTR("M600 B0 T1"));
-        #if E_STEPPERS > 2
-          PGM_P msg2 = PSTR(MSG_FILAMENTCHANGE " " MSG_E3);
-          if (thermalManager.targetTooColdToExtrude(2))
-            MENU_ITEM_P(submenu, msg2, menu_temp_e2_filament_change);
-          else
-            MENU_ITEM_P(gcode, msg2, PSTR("M600 B0 T2"));
-          #if E_STEPPERS > 3
-            PGM_P msg3 = PSTR(MSG_FILAMENTCHANGE " " MSG_E4);
-            if (thermalManager.targetTooColdToExtrude(3))
-              MENU_ITEM_P(submenu, msg3, menu_temp_e3_filament_change);
-            else
-              MENU_ITEM_P(gcode, msg3, PSTR("M600 B0 T3"));
-            #if E_STEPPERS > 4
-              PGM_P msg4 = PSTR(MSG_FILAMENTCHANGE " " MSG_E5);
-              if (thermalManager.targetTooColdToExtrude(4))
-                MENU_ITEM_P(submenu, msg4, menu_temp_e4_filament_change);
-              else
-                MENU_ITEM_P(gcode, msg4, PSTR("M600 B0 T4"));
-              #if E_STEPPERS > 5
-                PGM_P msg5 = PSTR(MSG_FILAMENTCHANGE " " MSG_E6);
-                if (thermalManager.targetTooColdToExtrude(5))
-                  MENU_ITEM_P(submenu, msg5, menu_temp_e5_filament_change);
-                else
-                  MENU_ITEM_P(gcode, msg5, PSTR("M600 B0 T5"));
-              #endif // E_STEPPERS > 5
-            #endif // E_STEPPERS > 4
-          #endif // E_STEPPERS > 3
-        #endif // E_STEPPERS > 2
-      #endif // E_STEPPERS == 1
-
-      #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
-        if (!printer_busy()) {
-          // Load filament
-          #if E_STEPPERS == 1
-            PGM_P msg0 = PSTR(MSG_FILAMENTLOAD);
-            if (thermalManager.targetTooColdToExtrude(active_extruder))
-              MENU_ITEM_P(submenu, msg0, menu_temp_e0_filament_load);
-            else
-              MENU_ITEM_P(gcode, msg0, PSTR("M701"));
-          #else
-            PGM_P msg0 = PSTR(MSG_FILAMENTLOAD " " MSG_E1);
-            PGM_P msg1 = PSTR(MSG_FILAMENTLOAD " " MSG_E2);
-            if (thermalManager.targetTooColdToExtrude(0))
-              MENU_ITEM_P(submenu, msg0, menu_temp_e0_filament_load);
-            else
-              MENU_ITEM_P(gcode, msg0, PSTR("M701 T0"));
-            if (thermalManager.targetTooColdToExtrude(1))
-              MENU_ITEM_P(submenu, msg1, menu_temp_e1_filament_load);
-            else
-              MENU_ITEM_P(gcode, msg1, PSTR("M701 T1"));
-            #if E_STEPPERS > 2
-              PGM_P msg2 = PSTR(MSG_FILAMENTLOAD " " MSG_E3);
-              if (thermalManager.targetTooColdToExtrude(2))
-                MENU_ITEM_P(submenu, msg2, menu_temp_e2_filament_load);
-              else
-                MENU_ITEM_P(gcode, msg2, PSTR("M701 T2"));
-              #if E_STEPPERS > 3
-                PGM_P msg3 = PSTR(MSG_FILAMENTLOAD " " MSG_E4);
-                if (thermalManager.targetTooColdToExtrude(3))
-                  MENU_ITEM_P(submenu, msg3, menu_temp_e3_filament_load);
-                else
-                  MENU_ITEM_P(gcode, msg3, PSTR("M701 T3"));
-                #if E_STEPPERS > 4
-                  PGM_P msg4 = PSTR(MSG_FILAMENTLOAD " " MSG_E5);
-                  if (thermalManager.targetTooColdToExtrude(4))
-                    MENU_ITEM_P(submenu, msg4, menu_temp_e4_filament_load);
-                  else
-                    MENU_ITEM_P(gcode, msg4, PSTR("M701 T4"));
-                  #if E_STEPPERS > 5
-                    PGM_P msg5 = PSTR(MSG_FILAMENTLOAD " " MSG_E6);
-                    if (thermalManager.targetTooColdToExtrude(5))
-                      MENU_ITEM_P(submenu, msg5, menu_temp_e5_filament_load);
-                    else
-                      MENU_ITEM_P(gcode, msg5, PSTR("M701 T5"));
-                  #endif // E_STEPPERS > 5
-                #endif // E_STEPPERS > 4
-              #endif // E_STEPPERS > 3
-            #endif // E_STEPPERS > 2
-          #endif // E_STEPPERS == 1
-
-          // Unload filament
-          #if E_STEPPERS == 1
-            if (thermalManager.targetHotEnoughToExtrude(active_extruder))
-              MENU_ITEM(gcode, MSG_FILAMENTUNLOAD, PSTR("M702"));
-            else
-              MENU_ITEM(submenu, MSG_FILAMENTUNLOAD, menu_temp_e0_filament_unload);
-          #else
-            #if ENABLED(FILAMENT_UNLOAD_ALL_EXTRUDERS)
-              if (thermalManager.targetHotEnoughToExtrude(0)
-                #if E_STEPPERS > 1
-                  && thermalManager.targetHotEnoughToExtrude(1)
-                  #if E_STEPPERS > 2
-                    && thermalManager.targetHotEnoughToExtrude(2)
-                    #if E_STEPPERS > 3
-                      && thermalManager.targetHotEnoughToExtrude(3)
-                      #if E_STEPPERS > 4
-                        && thermalManager.targetHotEnoughToExtrude(4)
-                        #if E_STEPPERS > 5
-                          && thermalManager.targetHotEnoughToExtrude(5)
-                        #endif // E_STEPPERS > 5
-                      #endif // E_STEPPERS > 4
-                    #endif // E_STEPPERS > 3
-                  #endif // E_STEPPERS > 2
-                #endif // E_STEPPERS > 1
-              )
-                MENU_ITEM(gcode, MSG_FILAMENTUNLOAD_ALL, PSTR("M702"));
-            else
-              MENU_ITEM(submenu, MSG_FILAMENTUNLOAD_ALL, menu_unload_filament_all_temp);
-            #endif
-            if (thermalManager.targetHotEnoughToExtrude(0))
-              MENU_ITEM(gcode, MSG_FILAMENTUNLOAD " " MSG_E1, PSTR("M702 T0"));
-            else
-              MENU_ITEM(submenu, MSG_FILAMENTUNLOAD " " MSG_E1, menu_temp_e0_filament_unload);
-            if (thermalManager.targetHotEnoughToExtrude(1))
-              MENU_ITEM(gcode, MSG_FILAMENTUNLOAD " " MSG_E2, PSTR("M702 T1"));
-            else
-              MENU_ITEM(submenu, MSG_FILAMENTUNLOAD " " MSG_E2, menu_temp_e1_filament_unload);
-            #if E_STEPPERS > 2
-              if (thermalManager.targetHotEnoughToExtrude(2))
-                MENU_ITEM(gcode, MSG_FILAMENTUNLOAD " " MSG_E3, PSTR("M702 T2"));
-              else
-                MENU_ITEM(submenu, MSG_FILAMENTUNLOAD " " MSG_E3, menu_temp_e2_filament_unload);
-              #if E_STEPPERS > 3
-                if (thermalManager.targetHotEnoughToExtrude(3))
-                  MENU_ITEM(gcode, MSG_FILAMENTUNLOAD " " MSG_E4, PSTR("M702 T3"));
-                else
-                  MENU_ITEM(submenu, MSG_FILAMENTUNLOAD " " MSG_E4, menu_temp_e3_filament_unload);
-                #if E_STEPPERS > 4
-                  if (thermalManager.targetHotEnoughToExtrude(4))
-                    MENU_ITEM(gcode, MSG_FILAMENTUNLOAD " " MSG_E5, PSTR("M702 T4"));
-                  else
-                    MENU_ITEM(submenu, MSG_FILAMENTUNLOAD " " MSG_E5, menu_temp_e4_filament_unload);
-                  #if E_STEPPERS > 5
-                    if (thermalManager.targetHotEnoughToExtrude(5))
-                      MENU_ITEM(gcode, MSG_FILAMENTUNLOAD " " MSG_E6, PSTR("M702 T5"));
-                    else
-                      MENU_ITEM(submenu, MSG_FILAMENTUNLOAD " " MSG_E6, menu_temp_e5_filament_unload);
-                  #endif // E_STEPPERS > 5
-                #endif // E_STEPPERS > 4
-              #endif // E_STEPPERS > 3
-            #endif // E_STEPPERS > 2
-          #endif // E_STEPPERS == 1
-        }
-      #endif
-
-      END_MENU();
-    }
-  #endif
-
-  static AdvancedPauseMode advanced_pause_mode = ADVANCED_PAUSE_MODE_PAUSE_PRINT;
-  static uint8_t hotend_status_extruder = 0;
-
-  static PGM_P advanced_pause_header() {
-    switch (advanced_pause_mode) {
-      case ADVANCED_PAUSE_MODE_LOAD_FILAMENT:
-        return PSTR(MSG_FILAMENT_CHANGE_HEADER_LOAD);
-      case ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT:
-        return PSTR(MSG_FILAMENT_CHANGE_HEADER_UNLOAD);
-      default: break;
-    }
-    return PSTR(MSG_FILAMENT_CHANGE_HEADER_PAUSE);
-  }
-
-  // Portions from STATIC_ITEM...
-  #define HOTEND_STATUS_ITEM() do { \
-    if (_menuLineNr == _thisItemNr) { \
-      if (lcdDrawUpdate) { \
-        lcd_implementation_drawmenu_static(_lcdLineNr, PSTR(MSG_FILAMENT_CHANGE_NOZZLE), false, true); \
-        lcd_implementation_hotend_status(_lcdLineNr, hotend_status_extruder); \
-      } \
-      if (_skipStatic && encoderLine <= _thisItemNr) { \
-        encoderPosition += ENCODER_STEPS_PER_MENU_ITEM; \
-        ++encoderLine; \
-      } \
-      lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT; \
-    } \
-    ++_thisItemNr; \
-  }while(0)
-
-  void lcd_advanced_pause_resume_print() {
-    advanced_pause_menu_response = ADVANCED_PAUSE_RESPONSE_RESUME_PRINT;
-  }
-
-  void lcd_advanced_pause_extrude_more() {
-    advanced_pause_menu_response = ADVANCED_PAUSE_RESPONSE_EXTRUDE_MORE;
-  }
-
-  void menu_advanced_pause_option() {
-    START_MENU();
-    #if LCD_HEIGHT > 2
-      STATIC_ITEM(MSG_FILAMENT_CHANGE_OPTION_HEADER, true, false);
-    #endif
-    MENU_ITEM(function, MSG_FILAMENT_CHANGE_OPTION_RESUME, lcd_advanced_pause_resume_print);
-    MENU_ITEM(function, MSG_FILAMENT_CHANGE_OPTION_PURGE, lcd_advanced_pause_extrude_more);
-    END_MENU();
-  }
-
-  void lcd_advanced_pause_init_message() {
-    START_SCREEN();
-    STATIC_ITEM_P(advanced_pause_header(), true, true);
-    STATIC_ITEM(MSG_FILAMENT_CHANGE_INIT_1);
-    #ifdef MSG_FILAMENT_CHANGE_INIT_2
-      STATIC_ITEM(MSG_FILAMENT_CHANGE_INIT_2);
-      #define __FC_LINES_A 3
-    #else
-      #define __FC_LINES_A 2
-    #endif
-    #ifdef MSG_FILAMENT_CHANGE_INIT_3
-      STATIC_ITEM(MSG_FILAMENT_CHANGE_INIT_3);
-      #define _FC_LINES_A (__FC_LINES_A + 1)
-    #else
-      #define _FC_LINES_A __FC_LINES_A
-    #endif
-    #if LCD_HEIGHT > _FC_LINES_A + 1
-      STATIC_ITEM(" ");
-    #endif
-    HOTEND_STATUS_ITEM();
-    END_SCREEN();
-  }
-
-  void lcd_advanced_pause_unload_message() {
-    START_SCREEN();
-    STATIC_ITEM_P(advanced_pause_header(), true, true);
-    STATIC_ITEM(MSG_FILAMENT_CHANGE_UNLOAD_1);
-    #ifdef MSG_FILAMENT_CHANGE_UNLOAD_2
-      STATIC_ITEM(MSG_FILAMENT_CHANGE_UNLOAD_2);
-      #define __FC_LINES_B 3
-    #else
-      #define __FC_LINES_B 2
-    #endif
-    #ifdef MSG_FILAMENT_CHANGE_UNLOAD_3
-      STATIC_ITEM(MSG_FILAMENT_CHANGE_UNLOAD_3);
-      #define _FC_LINES_B (__FC_LINES_B + 1)
-    #else
-      #define _FC_LINES_B __FC_LINES_B
-    #endif
-    #if LCD_HEIGHT > _FC_LINES_B + 1
-      STATIC_ITEM(" ");
-    #endif
-    HOTEND_STATUS_ITEM();
-    END_SCREEN();
-  }
-
-  void lcd_advanced_pause_wait_for_nozzles_to_heat() {
-    START_SCREEN();
-    STATIC_ITEM_P(advanced_pause_header(), true, true);
-    STATIC_ITEM(MSG_FILAMENT_CHANGE_HEATING_1);
-    #ifdef MSG_FILAMENT_CHANGE_HEATING_2
-      STATIC_ITEM(MSG_FILAMENT_CHANGE_HEATING_2);
-      #define _FC_LINES_C 3
-    #else
-      #define _FC_LINES_C 2
-    #endif
-    #if LCD_HEIGHT > _FC_LINES_C + 1
-      STATIC_ITEM(" ");
-    #endif
-    HOTEND_STATUS_ITEM();
-    END_SCREEN();
-  }
-
-  void lcd_advanced_pause_heat_nozzle() {
-    START_SCREEN();
-    STATIC_ITEM_P(advanced_pause_header(), true, true);
-    STATIC_ITEM(MSG_FILAMENT_CHANGE_HEAT_1);
-    #ifdef MSG_FILAMENT_CHANGE_INSERT_2
-      STATIC_ITEM(MSG_FILAMENT_CHANGE_HEAT_2);
-      #define _FC_LINES_D 3
-    #else
-      #define _FC_LINES_D 2
-    #endif
-    #if LCD_HEIGHT > _FC_LINES_D + 1
-      STATIC_ITEM(" ");
-    #endif
-    HOTEND_STATUS_ITEM();
-    END_SCREEN();
-  }
-
-  void lcd_advanced_pause_insert_message() {
-    START_SCREEN();
-    STATIC_ITEM_P(advanced_pause_header(), true, true);
-    STATIC_ITEM(MSG_FILAMENT_CHANGE_INSERT_1);
-    #ifdef MSG_FILAMENT_CHANGE_INSERT_2
-      STATIC_ITEM(MSG_FILAMENT_CHANGE_INSERT_2);
-      #define __FC_LINES_E 3
-    #else
-      #define __FC_LINES_E 2
-    #endif
-    #ifdef MSG_FILAMENT_CHANGE_INSERT_3
-      STATIC_ITEM(MSG_FILAMENT_CHANGE_INSERT_3);
-      #define _FC_LINES_E (__FC_LINES_E + 1)
-    #else
-      #define _FC_LINES_E __FC_LINES_E
-    #endif
-    #if LCD_HEIGHT > _FC_LINES_E + 1
-      STATIC_ITEM(" ");
-    #endif
-    HOTEND_STATUS_ITEM();
-    END_SCREEN();
-  }
-
-  void lcd_advanced_pause_load_message() {
-    START_SCREEN();
-    STATIC_ITEM_P(advanced_pause_header(), true, true);
-    STATIC_ITEM(MSG_FILAMENT_CHANGE_LOAD_1);
-    #ifdef MSG_FILAMENT_CHANGE_LOAD_2
-      STATIC_ITEM(MSG_FILAMENT_CHANGE_LOAD_2);
-      #define __FC_LINES_F 3
-    #else
-      #define __FC_LINES_F 2
-    #endif
-    #ifdef MSG_FILAMENT_CHANGE_LOAD_3
-      STATIC_ITEM(MSG_FILAMENT_CHANGE_LOAD_3);
-      #define _FC_LINES_F (__FC_LINES_F + 1)
-    #else
-      #define _FC_LINES_F __FC_LINES_F
-    #endif
-    #if LCD_HEIGHT > _FC_LINES_F + 1
-      STATIC_ITEM(" ");
-    #endif
-    HOTEND_STATUS_ITEM();
-    END_SCREEN();
-  }
-
-  void lcd_advanced_pause_purge_message() {
-    START_SCREEN();
-    STATIC_ITEM_P(advanced_pause_header(), true, true);
-    STATIC_ITEM(MSG_FILAMENT_CHANGE_PURGE_1);
-    #ifdef MSG_FILAMENT_CHANGE_PURGE_2
-      STATIC_ITEM(MSG_FILAMENT_CHANGE_PURGE_2);
-      #define __FC_LINES_G 3
-    #else
-      #define __FC_LINES_G 2
-    #endif
-    #ifdef MSG_FILAMENT_CHANGE_PURGE_3
-      STATIC_ITEM(MSG_FILAMENT_CHANGE_PURGE_3);
-      #define _FC_LINES_G (__FC_LINES_G + 1)
-    #else
-      #define _FC_LINES_G __FC_LINES_G
-    #endif
-    #if LCD_HEIGHT > _FC_LINES_G + 1
-      STATIC_ITEM(" ");
-    #endif
-    HOTEND_STATUS_ITEM();
-    END_SCREEN();
-  }
-
-  #if ENABLED(ADVANCED_PAUSE_CONTINUOUS_PURGE)
-    void menu_advanced_pause_continuous_purge() {
-      START_SCREEN();
-      STATIC_ITEM(MSG_FILAMENT_CHANGE_PURGE_1);
-      #ifdef MSG_FILAMENT_CHANGE_PURGE_2
-        STATIC_ITEM(MSG_FILAMENT_CHANGE_PURGE_2);
-        #define __FC_LINES_G 3
-      #else
-        #define __FC_LINES_G 2
-      #endif
-      #ifdef MSG_FILAMENT_CHANGE_PURGE_3
-        STATIC_ITEM(MSG_FILAMENT_CHANGE_PURGE_3);
-        #define _FC_LINES_G (__FC_LINES_G + 1)
-      #else
-        #define _FC_LINES_G __FC_LINES_G
-      #endif
-      #if LCD_HEIGHT > _FC_LINES_G + 1
-        STATIC_ITEM(" ");
-      #endif
-      HOTEND_STATUS_ITEM();
-      STATIC_ITEM(MSG_USERWAIT);
-      END_SCREEN();
-    }
-  #endif
-
-  void lcd_advanced_pause_resume_message() {
-    START_SCREEN();
-    STATIC_ITEM_P(advanced_pause_header(), true, true);
-    STATIC_ITEM(MSG_FILAMENT_CHANGE_RESUME_1);
-    #ifdef MSG_FILAMENT_CHANGE_RESUME_2
-      STATIC_ITEM(MSG_FILAMENT_CHANGE_RESUME_2);
-    #endif
-    #ifdef MSG_FILAMENT_CHANGE_RESUME_3
-      STATIC_ITEM(MSG_FILAMENT_CHANGE_RESUME_3);
-    #endif
-    END_SCREEN();
-  }
-
-  FORCE_INLINE screenFunc_t ap_message_screen(const AdvancedPauseMessage message) {
-    switch (message) {
-      case ADVANCED_PAUSE_MESSAGE_INIT: return lcd_advanced_pause_init_message;
-      case ADVANCED_PAUSE_MESSAGE_UNLOAD: return lcd_advanced_pause_unload_message;
-      case ADVANCED_PAUSE_MESSAGE_INSERT: return lcd_advanced_pause_insert_message;
-      case ADVANCED_PAUSE_MESSAGE_LOAD: return lcd_advanced_pause_load_message;
-      case ADVANCED_PAUSE_MESSAGE_PURGE: return lcd_advanced_pause_purge_message;
-      case ADVANCED_PAUSE_MESSAGE_RESUME: return lcd_advanced_pause_resume_message;
-      case ADVANCED_PAUSE_MESSAGE_CLICK_TO_HEAT_NOZZLE: return lcd_advanced_pause_heat_nozzle;
-      case ADVANCED_PAUSE_MESSAGE_WAIT_FOR_NOZZLES_TO_HEAT: return lcd_advanced_pause_wait_for_nozzles_to_heat;
-      case ADVANCED_PAUSE_MESSAGE_OPTION: advanced_pause_menu_response = ADVANCED_PAUSE_RESPONSE_WAIT_FOR;
-                                          return menu_advanced_pause_option;
-      #if ENABLED(ADVANCED_PAUSE_CONTINUOUS_PURGE)
-        case ADVANCED_PAUSE_MESSAGE_CONTINUOUS_PURGE: return menu_advanced_pause_continuous_purge;
-      #endif
-      case ADVANCED_PAUSE_MESSAGE_STATUS:
-      default: break;
-    }
-    return NULL;
-  }
-
-  void lcd_advanced_pause_show_message(
-    const AdvancedPauseMessage message,
-    const AdvancedPauseMode mode/*=ADVANCED_PAUSE_MODE_PAUSE_PRINT*/,
-    const uint8_t extruder/*=active_extruder*/
-  ) {
-    advanced_pause_mode = mode;
-    hotend_status_extruder = extruder;
-    const screenFunc_t next_screen = ap_message_screen(message);
-    if (next_screen) {
-      defer_return_to_status = true;
-      lcd_goto_screen(next_screen);
-    }
-    else
-      lcd_return_to_status();
-  }
-
-#endif // ADVANCED_PAUSE_FEATURE
-
 #endif // ULTIPANEL

commit d87ab3ed2052e28bfbf4282c3dc14b071c71ca32
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Oct 27 21:01:41 2018 -0500

    Move Advanced Settings Menu to its own file

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 70efbe6e6a..892b1cc056 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -53,10 +53,6 @@
   #include "../../libs/duration_t.h"
 #endif
 
-#if ENABLED(BLTOUCH)
-  #include "../../module/endstops.h"
-#endif
-
 #if HAS_LEVELING
   #include "../../feature/bedlevel/bedlevel.h"
 #endif
@@ -92,10 +88,6 @@ int32_t minEditValue, maxEditValue;
 screenFunc_t callbackFunc;
 bool liveEdit;
 
-#if ENABLED(PIDTEMP)
-  float raw_Ki, raw_Kd; // place-holders for Ki and Kd edits
-#endif
-
 bool no_reentry = false;
 
 // Initialized by settings.load()
@@ -251,10 +243,6 @@ void menu_action_setting_edit_callback_bool(PGM_P pstr, bool* ptr, screenFunc_t
 ///////////////// Menu Tree ////////////////
 ////////////////////////////////////////////
 
-#if DISABLED(NO_VOLUMETRICS) || ENABLED(ADVANCED_PAUSE_FEATURE)
-  void menu_advanced_filament();
-#endif
-
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   #if E_STEPPERS > 1 || ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
     void menu_change_filament();
@@ -661,18 +649,6 @@ void watch_temp_callback_bed() {
 #if ENABLED(EEPROM_SETTINGS)
   void lcd_store_settings()   { lcd_completion_feedback(settings.save()); }
   void lcd_load_settings()    { lcd_completion_feedback(settings.load()); }
-  #if DISABLED(SLIM_LCD_MENUS)
-    static void lcd_init_eeprom() {
-      lcd_completion_feedback(settings.init_eeprom());
-      lcd_goto_previous_menu();
-    }
-    static void lcd_init_eeprom_confirm() {
-      START_MENU();
-      MENU_BACK(MSG_ADVANCED_SETTINGS);
-      MENU_ITEM(function, MSG_INIT_EEPROM, lcd_init_eeprom);
-      END_MENU();
-    }
-  #endif
 #endif
 
 void _lcd_draw_homing() {
@@ -783,578 +759,6 @@ void _lcd_draw_homing() {
 
 #endif // DELTA_CALIBRATION_MENU || DELTA_AUTO_CALIBRATION
 
-/**
- *
- * "Temperature" submenu
- *
- */
-
-#if ENABLED(PID_AUTOTUNE_MENU)
-
-  #if ENABLED(PIDTEMP)
-    int16_t autotune_temp[HOTENDS] = ARRAY_BY_HOTENDS1(150);
-  #endif
-
-  #if ENABLED(PIDTEMPBED)
-    int16_t autotune_temp_bed = 70;
-  #endif
-
-  void _lcd_autotune(int16_t e) {
-    char cmd[30];
-    sprintf_P(cmd, PSTR("M303 U1 E%i S%i"), e,
-      #if HAS_PID_FOR_BOTH
-        e < 0 ? autotune_temp_bed : autotune_temp[e]
-      #elif ENABLED(PIDTEMPBED)
-        autotune_temp_bed
-      #else
-        autotune_temp[e]
-      #endif
-    );
-    lcd_enqueue_command(cmd);
-  }
-
-#endif // PID_AUTOTUNE_MENU
-
-#if ENABLED(PIDTEMP)
-
-  // Helpers for editing PID Ki & Kd values
-  // grab the PID value out of the temp variable; scale it; then update the PID driver
-  void copy_and_scalePID_i(int16_t e) {
-    #if DISABLED(PID_PARAMS_PER_HOTEND) || HOTENDS == 1
-      UNUSED(e);
-    #endif
-    PID_PARAM(Ki, e) = scalePID_i(raw_Ki);
-    thermalManager.updatePID();
-  }
-  void copy_and_scalePID_d(int16_t e) {
-    #if DISABLED(PID_PARAMS_PER_HOTEND) || HOTENDS == 1
-      UNUSED(e);
-    #endif
-    PID_PARAM(Kd, e) = scalePID_d(raw_Kd);
-    thermalManager.updatePID();
-  }
-  #define _DEFINE_PIDTEMP_BASE_FUNCS(N) \
-    void copy_and_scalePID_i_E ## N() { copy_and_scalePID_i(N); } \
-    void copy_and_scalePID_d_E ## N() { copy_and_scalePID_d(N); }
-
-  #if ENABLED(PID_AUTOTUNE_MENU)
-    #define DEFINE_PIDTEMP_FUNCS(N) \
-      _DEFINE_PIDTEMP_BASE_FUNCS(N); \
-      void lcd_autotune_callback_E ## N() { _lcd_autotune(N); } typedef void _pid_##N##_void
-  #else
-    #define DEFINE_PIDTEMP_FUNCS(N) _DEFINE_PIDTEMP_BASE_FUNCS(N) typedef void _pid_##N##_void
-  #endif
-
-  DEFINE_PIDTEMP_FUNCS(0);
-  #if ENABLED(PID_PARAMS_PER_HOTEND)
-    #if HOTENDS > 1
-      DEFINE_PIDTEMP_FUNCS(1);
-      #if HOTENDS > 2
-        DEFINE_PIDTEMP_FUNCS(2);
-        #if HOTENDS > 3
-          DEFINE_PIDTEMP_FUNCS(3);
-          #if HOTENDS > 4
-            DEFINE_PIDTEMP_FUNCS(4);
-            #if HOTENDS > 5
-              DEFINE_PIDTEMP_FUNCS(5);
-            #endif // HOTENDS > 5
-          #endif // HOTENDS > 4
-        #endif // HOTENDS > 3
-      #endif // HOTENDS > 2
-    #endif // HOTENDS > 1
-  #endif // PID_PARAMS_PER_HOTEND
-
-#endif // PIDTEMP
-
-/**
- *
- * "Advanced Settings" -> "Temperature" submenu
- *
- */
-void menu_advanced_temperature() {
-  START_MENU();
-  MENU_BACK(MSG_ADVANCED_SETTINGS);
-  //
-  // Autotemp, Min, Max, Fact
-  //
-  #if ENABLED(AUTOTEMP) && HAS_TEMP_HOTEND
-    MENU_ITEM_EDIT(bool, MSG_AUTOTEMP, &planner.autotemp_enabled);
-    MENU_ITEM_EDIT(float3, MSG_MIN, &planner.autotemp_min, 0, float(HEATER_0_MAXTEMP) - 15);
-    MENU_ITEM_EDIT(float3, MSG_MAX, &planner.autotemp_max, 0, float(HEATER_0_MAXTEMP) - 15);
-    MENU_ITEM_EDIT(float52, MSG_FACTOR, &planner.autotemp_factor, 0, 1);
-  #endif
-
-  //
-  // PID-P, PID-I, PID-D, PID-C, PID Autotune
-  // PID-P E1, PID-I E1, PID-D E1, PID-C E1, PID Autotune E1
-  // PID-P E2, PID-I E2, PID-D E2, PID-C E2, PID Autotune E2
-  // PID-P E3, PID-I E3, PID-D E3, PID-C E3, PID Autotune E3
-  // PID-P E4, PID-I E4, PID-D E4, PID-C E4, PID Autotune E4
-  // PID-P E5, PID-I E5, PID-D E5, PID-C E5, PID Autotune E5
-  //
-  #if ENABLED(PIDTEMP)
-
-    #define _PID_BASE_MENU_ITEMS(ELABEL, eindex) \
-      raw_Ki = unscalePID_i(PID_PARAM(Ki, eindex)); \
-      raw_Kd = unscalePID_d(PID_PARAM(Kd, eindex)); \
-      MENU_ITEM_EDIT(float52sign, MSG_PID_P ELABEL, &PID_PARAM(Kp, eindex), 1, 9990); \
-      MENU_ITEM_EDIT_CALLBACK(float52sign, MSG_PID_I ELABEL, &raw_Ki, 0.01f, 9990, copy_and_scalePID_i_E ## eindex); \
-      MENU_ITEM_EDIT_CALLBACK(float52sign, MSG_PID_D ELABEL, &raw_Kd, 1, 9990, copy_and_scalePID_d_E ## eindex)
-
-    #if ENABLED(PID_EXTRUSION_SCALING)
-      #define _PID_MENU_ITEMS(ELABEL, eindex) \
-        _PID_BASE_MENU_ITEMS(ELABEL, eindex); \
-        MENU_ITEM_EDIT(float3, MSG_PID_C ELABEL, &PID_PARAM(Kc, eindex), 1, 9990)
-    #else
-      #define _PID_MENU_ITEMS(ELABEL, eindex) _PID_BASE_MENU_ITEMS(ELABEL, eindex)
-    #endif
-
-    #if ENABLED(PID_AUTOTUNE_MENU)
-      #define PID_MENU_ITEMS(ELABEL, eindex) \
-        _PID_MENU_ITEMS(ELABEL, eindex); \
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_PID_AUTOTUNE ELABEL, &autotune_temp[eindex], 150, heater_maxtemp[eindex] - 15, lcd_autotune_callback_E ## eindex)
-    #else
-      #define PID_MENU_ITEMS(ELABEL, eindex) _PID_MENU_ITEMS(ELABEL, eindex)
-    #endif
-
-    #if ENABLED(PID_PARAMS_PER_HOTEND) && HOTENDS > 1
-      PID_MENU_ITEMS(" " MSG_E1, 0);
-      PID_MENU_ITEMS(" " MSG_E2, 1);
-      #if HOTENDS > 2
-        PID_MENU_ITEMS(" " MSG_E3, 2);
-        #if HOTENDS > 3
-          PID_MENU_ITEMS(" " MSG_E4, 3);
-          #if HOTENDS > 4
-            PID_MENU_ITEMS(" " MSG_E5, 4);
-            #if HOTENDS > 5
-              PID_MENU_ITEMS(" " MSG_E6, 5);
-            #endif // HOTENDS > 5
-          #endif // HOTENDS > 4
-        #endif // HOTENDS > 3
-      #endif // HOTENDS > 2
-    #else // !PID_PARAMS_PER_HOTEND || HOTENDS == 1
-      PID_MENU_ITEMS("", 0);
-    #endif // !PID_PARAMS_PER_HOTEND || HOTENDS == 1
-
-  #endif // PIDTEMP
-
-  END_MENU();
-}
-
-#if DISABLED(SLIM_LCD_MENUS)
-
-  void _reset_acceleration_rates() { planner.reset_acceleration_rates(); }
-  #if ENABLED(DISTINCT_E_FACTORS)
-    void _reset_e_acceleration_rate(const uint8_t e) { if (e == active_extruder) _reset_acceleration_rates(); }
-    void _reset_e0_acceleration_rate() { _reset_e_acceleration_rate(0); }
-    void _reset_e1_acceleration_rate() { _reset_e_acceleration_rate(1); }
-    #if E_STEPPERS > 2
-      void _reset_e2_acceleration_rate() { _reset_e_acceleration_rate(2); }
-      #if E_STEPPERS > 3
-        void _reset_e3_acceleration_rate() { _reset_e_acceleration_rate(3); }
-        #if E_STEPPERS > 4
-          void _reset_e4_acceleration_rate() { _reset_e_acceleration_rate(4); }
-          #if E_STEPPERS > 5
-            void _reset_e5_acceleration_rate() { _reset_e_acceleration_rate(5); }
-          #endif // E_STEPPERS > 5
-        #endif // E_STEPPERS > 4
-      #endif // E_STEPPERS > 3
-    #endif // E_STEPPERS > 2
-  #endif
-
-  void _planner_refresh_positioning() { planner.refresh_positioning(); }
-  #if ENABLED(DISTINCT_E_FACTORS)
-    void _planner_refresh_e_positioning(const uint8_t e) {
-      if (e == active_extruder)
-        _planner_refresh_positioning();
-      else
-        planner.steps_to_mm[E_AXIS + e] = 1.0f / planner.settings.axis_steps_per_mm[E_AXIS + e];
-    }
-    void _planner_refresh_e0_positioning() { _planner_refresh_e_positioning(0); }
-    void _planner_refresh_e1_positioning() { _planner_refresh_e_positioning(1); }
-    #if E_STEPPERS > 2
-      void _planner_refresh_e2_positioning() { _planner_refresh_e_positioning(2); }
-      #if E_STEPPERS > 3
-        void _planner_refresh_e3_positioning() { _planner_refresh_e_positioning(3); }
-        #if E_STEPPERS > 4
-          void _planner_refresh_e4_positioning() { _planner_refresh_e_positioning(4); }
-          #if E_STEPPERS > 5
-            void _planner_refresh_e5_positioning() { _planner_refresh_e_positioning(5); }
-          #endif // E_STEPPERS > 5
-        #endif // E_STEPPERS > 4
-      #endif // E_STEPPERS > 3
-    #endif // E_STEPPERS > 2
-  #endif
-
-  // M203 / M205 Velocity options
-  void menu_advanced_velocity() {
-    START_MENU();
-    MENU_BACK(MSG_ADVANCED_SETTINGS);
-
-    // M203 Max Feedrate
-    MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_A, &planner.settings.max_feedrate_mm_s[A_AXIS], 1, 999);
-    MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_B, &planner.settings.max_feedrate_mm_s[B_AXIS], 1, 999);
-    MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_C, &planner.settings.max_feedrate_mm_s[C_AXIS], 1, 999);
-
-    #if ENABLED(DISTINCT_E_FACTORS)
-      MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E, &planner.settings.max_feedrate_mm_s[E_AXIS + active_extruder], 1, 999);
-      MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E1, &planner.settings.max_feedrate_mm_s[E_AXIS], 1, 999);
-      MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E2, &planner.settings.max_feedrate_mm_s[E_AXIS + 1], 1, 999);
-      #if E_STEPPERS > 2
-        MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E3, &planner.settings.max_feedrate_mm_s[E_AXIS + 2], 1, 999);
-        #if E_STEPPERS > 3
-          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E4, &planner.settings.max_feedrate_mm_s[E_AXIS + 3], 1, 999);
-          #if E_STEPPERS > 4
-            MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E5, &planner.settings.max_feedrate_mm_s[E_AXIS + 4], 1, 999);
-            #if E_STEPPERS > 5
-              MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E6, &planner.settings.max_feedrate_mm_s[E_AXIS + 5], 1, 999);
-            #endif // E_STEPPERS > 5
-          #endif // E_STEPPERS > 4
-        #endif // E_STEPPERS > 3
-      #endif // E_STEPPERS > 2
-    #else
-      MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E, &planner.settings.max_feedrate_mm_s[E_AXIS], 1, 999);
-    #endif
-
-    // M205 S Min Feedrate
-    MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMIN, &planner.settings.min_feedrate_mm_s, 0, 999);
-
-    // M205 T Min Travel Feedrate
-    MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VTRAV_MIN, &planner.settings.min_travel_feedrate_mm_s, 0, 999);
-
-    END_MENU();
-  }
-
-  // M201 / M204 Accelerations
-  void menu_advanced_acceleration() {
-    START_MENU();
-    MENU_BACK(MSG_ADVANCED_SETTINGS);
-
-    // M204 P Acceleration
-    MENU_MULTIPLIER_ITEM_EDIT(float5, MSG_ACC, &planner.settings.acceleration, 10, 99000);
-
-    // M204 R Retract Acceleration
-    MENU_MULTIPLIER_ITEM_EDIT(float5, MSG_A_RETRACT, &planner.settings.retract_acceleration, 100, 99000);
-
-    // M204 T Travel Acceleration
-    MENU_MULTIPLIER_ITEM_EDIT(float5, MSG_A_TRAVEL, &planner.settings.travel_acceleration, 100, 99000);
-
-    // M201 settings
-    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_A, &planner.settings.max_acceleration_mm_per_s2[A_AXIS], 100, 99000, _reset_acceleration_rates);
-    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_B, &planner.settings.max_acceleration_mm_per_s2[B_AXIS], 100, 99000, _reset_acceleration_rates);
-    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_C, &planner.settings.max_acceleration_mm_per_s2[C_AXIS], 10, 99000, _reset_acceleration_rates);
-
-    #if ENABLED(DISTINCT_E_FACTORS)
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E, &planner.settings.max_acceleration_mm_per_s2[E_AXIS + active_extruder], 100, 99000, _reset_acceleration_rates);
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E1, &planner.settings.max_acceleration_mm_per_s2[E_AXIS], 100, 99000, _reset_e0_acceleration_rate);
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E2, &planner.settings.max_acceleration_mm_per_s2[E_AXIS + 1], 100, 99000, _reset_e1_acceleration_rate);
-      #if E_STEPPERS > 2
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E3, &planner.settings.max_acceleration_mm_per_s2[E_AXIS + 2], 100, 99000, _reset_e2_acceleration_rate);
-        #if E_STEPPERS > 3
-          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E4, &planner.settings.max_acceleration_mm_per_s2[E_AXIS + 3], 100, 99000, _reset_e3_acceleration_rate);
-          #if E_STEPPERS > 4
-            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E5, &planner.settings.max_acceleration_mm_per_s2[E_AXIS + 4], 100, 99000, _reset_e4_acceleration_rate);
-            #if E_STEPPERS > 5
-              MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E6, &planner.settings.max_acceleration_mm_per_s2[E_AXIS + 5], 100, 99000, _reset_e5_acceleration_rate);
-            #endif // E_STEPPERS > 5
-          #endif // E_STEPPERS > 4
-        #endif // E_STEPPERS > 3
-      #endif // E_STEPPERS > 2
-    #else
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E, &planner.settings.max_acceleration_mm_per_s2[E_AXIS], 100, 99000, _reset_acceleration_rates);
-    #endif
-
-    END_MENU();
-  }
-
-  // M205 Jerk
-  void menu_advanced_jerk() {
-    START_MENU();
-    MENU_BACK(MSG_ADVANCED_SETTINGS);
-
-    #if ENABLED(JUNCTION_DEVIATION)
-      #if ENABLED(LIN_ADVANCE)
-        MENU_ITEM_EDIT_CALLBACK(float43, MSG_JUNCTION_DEVIATION, &planner.junction_deviation_mm, 0.01f, 0.3f, planner.recalculate_max_e_jerk);
-      #else
-        MENU_ITEM_EDIT(float43, MSG_JUNCTION_DEVIATION, &planner.junction_deviation_mm, 0.01f, 0.3f);
-      #endif
-    #endif
-    #if HAS_CLASSIC_JERK
-      MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VA_JERK, &planner.max_jerk[A_AXIS], 1, 990);
-      MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VB_JERK, &planner.max_jerk[B_AXIS], 1, 990);
-      #if ENABLED(DELTA)
-        MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VC_JERK, &planner.max_jerk[C_AXIS], 1, 990);
-      #else
-        MENU_MULTIPLIER_ITEM_EDIT(float52sign, MSG_VC_JERK, &planner.max_jerk[C_AXIS], 0.1f, 990);
-      #endif
-      #if DISABLED(JUNCTION_DEVIATION) || DISABLED(LIN_ADVANCE)
-        MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VE_JERK, &planner.max_jerk[E_AXIS], 1, 990);
-      #endif
-    #endif
-
-    END_MENU();
-  }
-
-  // M92 Steps-per-mm
-  void menu_advanced_steps_per_mm() {
-    START_MENU();
-    MENU_BACK(MSG_ADVANCED_SETTINGS);
-
-    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_ASTEPS, &planner.settings.axis_steps_per_mm[A_AXIS], 5, 9999, _planner_refresh_positioning);
-    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_BSTEPS, &planner.settings.axis_steps_per_mm[B_AXIS], 5, 9999, _planner_refresh_positioning);
-    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_CSTEPS, &planner.settings.axis_steps_per_mm[C_AXIS], 5, 9999, _planner_refresh_positioning);
-
-    #if ENABLED(DISTINCT_E_FACTORS)
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_ESTEPS, &planner.settings.axis_steps_per_mm[E_AXIS + active_extruder], 5, 9999, _planner_refresh_positioning);
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E1STEPS, &planner.settings.axis_steps_per_mm[E_AXIS], 5, 9999, _planner_refresh_e0_positioning);
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E2STEPS, &planner.settings.axis_steps_per_mm[E_AXIS + 1], 5, 9999, _planner_refresh_e1_positioning);
-      #if E_STEPPERS > 2
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E3STEPS, &planner.settings.axis_steps_per_mm[E_AXIS + 2], 5, 9999, _planner_refresh_e2_positioning);
-        #if E_STEPPERS > 3
-          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E4STEPS, &planner.settings.axis_steps_per_mm[E_AXIS + 3], 5, 9999, _planner_refresh_e3_positioning);
-          #if E_STEPPERS > 4
-            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E5STEPS, &planner.settings.axis_steps_per_mm[E_AXIS + 4], 5, 9999, _planner_refresh_e4_positioning);
-            #if E_STEPPERS > 5
-              MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E6STEPS, &planner.settings.axis_steps_per_mm[E_AXIS + 5], 5, 9999, _planner_refresh_e5_positioning);
-            #endif // E_STEPPERS > 5
-          #endif // E_STEPPERS > 4
-        #endif // E_STEPPERS > 3
-      #endif // E_STEPPERS > 2
-    #else
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_ESTEPS, &planner.settings.axis_steps_per_mm[E_AXIS], 5, 9999, _planner_refresh_positioning);
-    #endif
-
-    END_MENU();
-  }
-
-#endif // !SLIM_LCD_MENUS
-
-/**
- *
- * "Advanced Settings" submenu
- *
- */
-
-#if HAS_M206_COMMAND
-  /**
-   * Set the home offset based on the current_position
-   */
-  void lcd_set_home_offsets() {
-    // M428 Command
-    enqueue_and_echo_commands_P(PSTR("M428"));
-    lcd_return_to_status();
-  }
-#endif
-
-#if ENABLED(SD_FIRMWARE_UPDATE)
-  /**
-   * Toggle the SD Firmware Update state in EEPROM
-   */
-  static void _lcd_toggle_sd_update() {
-    const bool new_state = !settings.sd_update_status();
-    lcd_completion_feedback(settings.set_sd_update_status(new_state));
-    lcd_return_to_status();
-    if (new_state) LCD_MESSAGEPGM(MSG_RESET_PRINTER); else lcd_reset_status();
-  }
-#endif
-
-void menu_advanced_settings() {
-  START_MENU();
-  MENU_BACK(MSG_CONFIGURATION);
-
-  #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
-    MENU_ITEM(submenu, MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
-  #elif HAS_BED_PROBE
-    MENU_ITEM_EDIT(float52, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
-  #endif
-
-  #if DISABLED(SLIM_LCD_MENUS)
-
-    #if HAS_M206_COMMAND
-      //
-      // Set Home Offsets
-      //
-      MENU_ITEM(function, MSG_SET_HOME_OFFSETS, lcd_set_home_offsets);
-    #endif
-
-    // M203 / M205 - Feedrate items
-    MENU_ITEM(submenu, MSG_VELOCITY, menu_advanced_velocity);
-
-    // M201 - Acceleration items
-    MENU_ITEM(submenu, MSG_ACCELERATION, menu_advanced_acceleration);
-
-    // M205 - Max Jerk
-    MENU_ITEM(submenu, MSG_JERK, menu_advanced_jerk);
-
-    if (!printer_busy()) {
-      // M92 - Steps Per mm
-      MENU_ITEM(submenu, MSG_STEPS_PER_MM, menu_advanced_steps_per_mm);
-    }
-
-  #endif // !SLIM_LCD_MENUS
-
-  MENU_ITEM(submenu, MSG_TEMPERATURE, menu_advanced_temperature);
-
-  #if DISABLED(NO_VOLUMETRICS) || ENABLED(ADVANCED_PAUSE_FEATURE)
-    MENU_ITEM(submenu, MSG_FILAMENT, menu_advanced_filament);
-  #elif ENABLED(LIN_ADVANCE)
-    #if EXTRUDERS == 1
-      MENU_ITEM_EDIT(float52, MSG_ADVANCE_K, &planner.extruder_advance_K[0], 0, 999);
-    #elif EXTRUDERS > 1
-      MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E1, &planner.extruder_advance_K[0], 0, 999);
-      MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E2, &planner.extruder_advance_K[1], 0, 999);
-      #if EXTRUDERS > 2
-        MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E3, &planner.extruder_advance_K[2], 0, 999);
-        #if EXTRUDERS > 3
-          MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E4, &planner.extruder_advance_K[3], 0, 999);
-          #if EXTRUDERS > 4
-            MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E5, &planner.extruder_advance_K[4], 0, 999);
-            #if EXTRUDERS > 5
-              MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E6, &planner.extruder_advance_K[5], 0, 999);
-            #endif // EXTRUDERS > 5
-          #endif // EXTRUDERS > 4
-        #endif // EXTRUDERS > 3
-      #endif // EXTRUDERS > 2
-    #endif // EXTRUDERS > 1
-  #endif
-
-  // M540 S - Abort on endstop hit when SD printing
-  #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
-    MENU_ITEM_EDIT(bool, MSG_ENDSTOP_ABORT, &planner.abort_on_endstop_hit);
-  #endif
-
-  //
-  // BLTouch Self-Test and Reset
-  //
-  #if ENABLED(BLTOUCH)
-    MENU_ITEM(gcode, MSG_BLTOUCH_SELFTEST, PSTR("M280 P" STRINGIFY(Z_PROBE_SERVO_NR) " S" STRINGIFY(BLTOUCH_SELFTEST)));
-    if (!endstops.z_probe_enabled && TEST_BLTOUCH())
-      MENU_ITEM(gcode, MSG_BLTOUCH_RESET, PSTR("M280 P" STRINGIFY(Z_PROBE_SERVO_NR) " S" STRINGIFY(BLTOUCH_RESET)));
-  #endif
-
-  #if ENABLED(SD_FIRMWARE_UPDATE)
-    bool sd_update_state = settings.sd_update_status();
-    MENU_ITEM_EDIT_CALLBACK(bool, MSG_SD_UPDATE, &sd_update_state, _lcd_toggle_sd_update);
-  #endif
-
-  #if ENABLED(EEPROM_SETTINGS) && DISABLED(SLIM_LCD_MENUS)
-    MENU_ITEM(submenu, MSG_INIT_EEPROM, lcd_init_eeprom_confirm);
-  #endif
-
-  END_MENU();
-}
-
-#if DISABLED(NO_VOLUMETRICS) || ENABLED(ADVANCED_PAUSE_FEATURE)
-  /**
-   *
-   * "Advanced Settings" > "Filament" submenu
-   *
-   */
-  void menu_advanced_filament() {
-    START_MENU();
-    MENU_BACK(MSG_ADVANCED_SETTINGS);
-
-    #if ENABLED(LIN_ADVANCE)
-      #if EXTRUDERS == 1
-        MENU_ITEM_EDIT(float52, MSG_ADVANCE_K, &planner.extruder_advance_K[0], 0, 999);
-      #elif EXTRUDERS > 1
-        MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E1, &planner.extruder_advance_K[0], 0, 999);
-        MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E2, &planner.extruder_advance_K[1], 0, 999);
-        #if EXTRUDERS > 2
-          MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E3, &planner.extruder_advance_K[2], 0, 999);
-          #if EXTRUDERS > 3
-            MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E4, &planner.extruder_advance_K[3], 0, 999);
-            #if EXTRUDERS > 4
-              MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E5, &planner.extruder_advance_K[4], 0, 999);
-              #if EXTRUDERS > 5
-                MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E6, &planner.extruder_advance_K[5], 0, 999);
-              #endif // EXTRUDERS > 5
-            #endif // EXTRUDERS > 4
-          #endif // EXTRUDERS > 3
-        #endif // EXTRUDERS > 2
-      #endif // EXTRUDERS > 1
-    #endif
-
-    #if DISABLED(NO_VOLUMETRICS)
-      MENU_ITEM_EDIT_CALLBACK(bool, MSG_VOLUMETRIC_ENABLED, &parser.volumetric_enabled, planner.calculate_volumetric_multipliers);
-
-      if (parser.volumetric_enabled) {
-        #if EXTRUDERS == 1
-          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM, &planner.filament_size[0], 1.5f, 3.25f, planner.calculate_volumetric_multipliers);
-        #else // EXTRUDERS > 1
-          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM, &planner.filament_size[active_extruder], 1.5f, 3.25f, planner.calculate_volumetric_multipliers);
-          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E1, &planner.filament_size[0], 1.5f, 3.25f, planner.calculate_volumetric_multipliers);
-          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E2, &planner.filament_size[1], 1.5f, 3.25f, planner.calculate_volumetric_multipliers);
-          #if EXTRUDERS > 2
-            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E3, &planner.filament_size[2], 1.5f, 3.25f, planner.calculate_volumetric_multipliers);
-            #if EXTRUDERS > 3
-              MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E4, &planner.filament_size[3], 1.5f, 3.25f, planner.calculate_volumetric_multipliers);
-              #if EXTRUDERS > 4
-                MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E5, &planner.filament_size[4], 1.5f, 3.25f, planner.calculate_volumetric_multipliers);
-                #if EXTRUDERS > 5
-                  MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E6, &planner.filament_size[5], 1.5f, 3.25f, planner.calculate_volumetric_multipliers);
-                #endif // EXTRUDERS > 5
-              #endif // EXTRUDERS > 4
-            #endif // EXTRUDERS > 3
-          #endif // EXTRUDERS > 2
-        #endif // EXTRUDERS > 1
-      }
-    #endif
-
-    #if ENABLED(ADVANCED_PAUSE_FEATURE)
-      constexpr float extrude_maxlength =
-        #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
-          EXTRUDE_MAXLENGTH
-        #else
-          999
-        #endif
-      ;
-
-      #if EXTRUDERS == 1
-        MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD, &fc_settings[0].unload_length, 0, extrude_maxlength);
-      #else // EXTRUDERS > 1
-        MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD, &fc_settings[active_extruder].unload_length, 0, extrude_maxlength);
-        MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E1, &fc_settings[0].unload_length, 0, extrude_maxlength);
-        MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E2, &fc_settings[1].unload_length, 0, extrude_maxlength);
-        #if EXTRUDERS > 2
-          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E3, &fc_settings[2].unload_length, 0, extrude_maxlength);
-          #if EXTRUDERS > 3
-            MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E4, &fc_settings[3].unload_length, 0, extrude_maxlength);
-            #if EXTRUDERS > 4
-              MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E5, &fc_settings[4].unload_length, 0, extrude_maxlength);
-              #if EXTRUDERS > 5
-                MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E6, &fc_settings[5].unload_length, 0, extrude_maxlength);
-              #endif // EXTRUDERS > 5
-            #endif // EXTRUDERS > 4
-          #endif // EXTRUDERS > 3
-        #endif // EXTRUDERS > 2
-      #endif // EXTRUDERS > 1
-
-      #if EXTRUDERS == 1
-        MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD, &fc_settings[0].load_length, 0, extrude_maxlength);
-      #else // EXTRUDERS > 1
-        MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD, &fc_settings[active_extruder].load_length, 0, extrude_maxlength);
-        MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E1, &fc_settings[0].load_length, 0, extrude_maxlength);
-        MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E2, &fc_settings[1].load_length, 0, extrude_maxlength);
-        #if EXTRUDERS > 2
-          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E3, &fc_settings[2].load_length, 0, extrude_maxlength);
-          #if EXTRUDERS > 3
-            MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E4, &fc_settings[3].load_length, 0, extrude_maxlength);
-            #if EXTRUDERS > 4
-              MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E5, &fc_settings[4].load_length, 0, extrude_maxlength);
-              #if EXTRUDERS > 5
-                MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E6, &fc_settings[5].load_length, 0, extrude_maxlength);
-              #endif // EXTRUDERS > 5
-            #endif // EXTRUDERS > 4
-          #endif // EXTRUDERS > 3
-        #endif // EXTRUDERS > 2
-      #endif // EXTRUDERS > 1
-    #endif
-
-    END_MENU();
-  }
-#endif // !NO_VOLUMETRICS || ADVANCED_PAUSE_FEATURE
-
 #if ENABLED(SDSUPPORT)
 
   #if !PIN_EXISTS(SD_DETECT)

commit 587a64d80c5e9c87614f2fdb8a8b3973283e1226
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Oct 27 19:48:37 2018 -0500

    Move Bed Leveling Menu to its own file

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 30c9f8f1eb..70efbe6e6a 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -263,10 +263,6 @@ void menu_action_setting_edit_callback_bool(PGM_P pstr, bool* ptr, screenFunc_t
   #endif
 #endif
 
-#if ENABLED(MESH_BED_LEVELING) && ENABLED(LCD_BED_LEVELING)
-  #include "../../feature/bedlevel/mbl/mesh_bed_leveling.h"
-#endif
-
 #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
   float lcd_z_fade_height;
   void _lcd_set_z_fade_height() { set_z_fade_height(lcd_z_fade_height); }
@@ -685,317 +681,10 @@ void _lcd_draw_homing() {
   lcdDrawUpdate = LCDVIEW_CALL_NO_REDRAW;
 }
 
-#if ENABLED(LEVEL_BED_CORNERS)
-
-  /**
-   * Level corners, starting in the front-left corner.
-   */
-  static int8_t bed_corner;
-  void _lcd_goto_next_corner() {
-    line_to_z(4.0);
-    switch (bed_corner) {
-      case 0:
-        current_position[X_AXIS] = X_MIN_BED + LEVEL_CORNERS_INSET;
-        current_position[Y_AXIS] = Y_MIN_BED + LEVEL_CORNERS_INSET;
-        break;
-      case 1:
-        current_position[X_AXIS] = X_MAX_BED - LEVEL_CORNERS_INSET;
-        break;
-      case 2:
-        current_position[Y_AXIS] = Y_MAX_BED - LEVEL_CORNERS_INSET;
-        break;
-      case 3:
-        current_position[X_AXIS] = X_MIN_BED + LEVEL_CORNERS_INSET;
-        break;
-      #if ENABLED(LEVEL_CENTER_TOO)
-        case 4:
-          current_position[X_AXIS] = X_CENTER;
-          current_position[Y_AXIS] = Y_CENTER;
-          break;
-      #endif
-    }
-    planner.buffer_line(current_position, MMM_TO_MMS(manual_feedrate_mm_m[X_AXIS]), active_extruder);
-    line_to_z(0.0);
-    if (++bed_corner > 3
-      #if ENABLED(LEVEL_CENTER_TOO)
-        + 1
-      #endif
-    ) bed_corner = 0;
-  }
-
-  void _lcd_corner_submenu() {
-    START_MENU();
-    MENU_ITEM(function,
-      #if ENABLED(LEVEL_CENTER_TOO)
-        MSG_LEVEL_BED_NEXT_POINT
-      #else
-        MSG_NEXT_CORNER
-      #endif
-      , _lcd_goto_next_corner);
-    MENU_ITEM(function, MSG_BACK, lcd_goto_previous_menu_no_defer);
-    END_MENU();
-  }
-
-  void _lcd_level_bed_corners_homing() {
-    _lcd_draw_homing();
-    if (all_axes_homed()) {
-      bed_corner = 0;
-      lcd_goto_screen(_lcd_corner_submenu);
-      _lcd_goto_next_corner();
-    }
-  }
-
-  void _lcd_level_bed_corners() {
-    defer_return_to_status = true;
-    if (!all_axes_known()) {
-      axis_homed = 0;
-      enqueue_and_echo_commands_P(PSTR("G28"));
-    }
-    lcd_goto_screen(_lcd_level_bed_corners_homing);
-  }
-
-#endif // LEVEL_BED_CORNERS
-
-#if ENABLED(LCD_BED_LEVELING) && (ENABLED(PROBE_MANUALLY) || ENABLED(MESH_BED_LEVELING))
-
-  /**
-   *
-   * "Motion" > "Level Bed" handlers
-   *
-   */
-
-  static uint8_t manual_probe_index;
-
-  // LCD probed points are from defaults
-  constexpr uint8_t total_probe_points = (
-    #if ENABLED(AUTO_BED_LEVELING_3POINT)
-      3
-    #elif ABL_GRID || ENABLED(MESH_BED_LEVELING)
-      GRID_MAX_POINTS
-    #endif
-  );
-
-  bool lcd_wait_for_move;
-
-  //
-  // Bed leveling is done. Wait for G29 to complete.
-  // A flag is used so that this can release control
-  // and allow the command queue to be processed.
-  //
-  // When G29 finishes the last move:
-  // - Raise Z to the "manual probe height"
-  // - Don't return until done.
-  //
-  // ** This blocks the command queue! **
-  //
-  void _lcd_level_bed_done() {
-    if (!lcd_wait_for_move) {
-      #if MANUAL_PROBE_HEIGHT > 0 && DISABLED(MESH_BED_LEVELING)
-        // Display "Done" screen and wait for moves to complete
-        line_to_z(MANUAL_PROBE_HEIGHT);
-        lcd_synchronize(PSTR(MSG_LEVEL_BED_DONE));
-      #endif
-      lcd_goto_previous_menu_no_defer();
-      lcd_completion_feedback();
-    }
-    if (lcdDrawUpdate) lcd_implementation_drawmenu_static(LCD_HEIGHT >= 4 ? 1 : 0, PSTR(MSG_LEVEL_BED_DONE));
-    lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
-  }
-
-  void _lcd_level_goto_next_point();
-
-  /**
-   * Step 7: Get the Z coordinate, click goes to the next point or exits
-   */
-  void _lcd_level_bed_get_z() {
-    ENCODER_DIRECTION_NORMAL();
-
-    if (use_click()) {
-
-      //
-      // Save the current Z position and move
-      //
-
-      // If done...
-      if (++manual_probe_index >= total_probe_points) {
-        //
-        // The last G29 records the point and enables bed leveling
-        //
-        lcd_wait_for_move = true;
-        lcd_goto_screen(_lcd_level_bed_done);
-        #if ENABLED(MESH_BED_LEVELING)
-          enqueue_and_echo_commands_P(PSTR("G29 S2"));
-        #elif ENABLED(PROBE_MANUALLY)
-          enqueue_and_echo_commands_P(PSTR("G29 V1"));
-        #endif
-      }
-      else
-        _lcd_level_goto_next_point();
-
-      return;
-    }
-
-    //
-    // Encoder knob or keypad buttons adjust the Z position
-    //
-    if (encoderPosition) {
-      const float z = current_position[Z_AXIS] + float((int32_t)encoderPosition) * (MBL_Z_STEP);
-      line_to_z(constrain(z, -(LCD_PROBE_Z_RANGE) * 0.5f, (LCD_PROBE_Z_RANGE) * 0.5f));
-      lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
-      encoderPosition = 0;
-    }
-
-    //
-    // Draw on first display, then only on Z change
-    //
-    if (lcdDrawUpdate) {
-      const float v = current_position[Z_AXIS];
-      lcd_implementation_drawedit(PSTR(MSG_MOVE_Z), ftostr43sign(v + (v < 0 ? -0.0001f : 0.0001f), '+'));
-    }
-  }
-
-  /**
-   * Step 6: Display "Next point: 1 / 9" while waiting for move to finish
-   */
-  void _lcd_level_bed_moving() {
-    if (lcdDrawUpdate) {
-      char msg[10];
-      sprintf_P(msg, PSTR("%i / %u"), (int)(manual_probe_index + 1), total_probe_points);
-      lcd_implementation_drawedit(PSTR(MSG_LEVEL_BED_NEXT_POINT), msg);
-    }
-    lcdDrawUpdate = LCDVIEW_CALL_NO_REDRAW;
-    if (!lcd_wait_for_move) lcd_goto_screen(_lcd_level_bed_get_z);
-  }
-
-  /**
-   * Step 5: Initiate a move to the next point
-   */
-  void _lcd_level_goto_next_point() {
-    lcd_goto_screen(_lcd_level_bed_moving);
-
-    // G29 Records Z, moves, and signals when it pauses
-    lcd_wait_for_move = true;
-    #if ENABLED(MESH_BED_LEVELING)
-      enqueue_and_echo_commands_P(manual_probe_index ? PSTR("G29 S2") : PSTR("G29 S1"));
-    #elif ENABLED(PROBE_MANUALLY)
-      enqueue_and_echo_commands_P(PSTR("G29 V1"));
-    #endif
-  }
-
-  /**
-   * Step 4: Display "Click to Begin", wait for click
-   *         Move to the first probe position
-   */
-  void _lcd_level_bed_homing_done() {
-    if (lcdDrawUpdate) lcd_implementation_drawedit(PSTR(MSG_LEVEL_BED_WAITING));
-    if (use_click()) {
-      manual_probe_index = 0;
-      _lcd_level_goto_next_point();
-    }
-  }
-
-  /**
-   * Step 3: Display "Homing XYZ" - Wait for homing to finish
-   */
-  void _lcd_level_bed_homing() {
-    _lcd_draw_homing();
-    if (all_axes_homed()) lcd_goto_screen(_lcd_level_bed_homing_done);
-  }
-
-  #if ENABLED(PROBE_MANUALLY)
-    extern bool g29_in_progress;
-  #endif
-
-  /**
-   * Step 2: Continue Bed Leveling...
-   */
-  void _lcd_level_bed_continue() {
-    defer_return_to_status = true;
-    axis_homed = 0;
-    lcd_goto_screen(_lcd_level_bed_homing);
-    enqueue_and_echo_commands_P(PSTR("G28"));
-  }
-
-#endif // LCD_BED_LEVELING && (PROBE_MANUALLY || MESH_BED_LEVELING)
-
 #if ENABLED(LCD_BED_LEVELING) || (HAS_LEVELING && DISABLED(SLIM_LCD_MENUS))
   void _lcd_toggle_bed_leveling() { set_bed_leveling_enabled(!planner.leveling_active); }
 #endif
 
-#if ENABLED(LCD_BED_LEVELING)
-
-  /**
-   * Step 1: Bed Level entry-point
-   *
-   * << Motion
-   *    Auto Home           (if homing needed)
-   *    Leveling On/Off     (if data exists, and homed)
-   *    Fade Height: ---    (Req: ENABLE_LEVELING_FADE_HEIGHT)
-   *    Mesh Z Offset: ---  (Req: MESH_BED_LEVELING)
-   *    Z Probe Offset: --- (Req: HAS_BED_PROBE, Opt: BABYSTEP_ZPROBE_OFFSET)
-   *    Level Bed >
-   *    Level Corners >     (if homed)
-   *    Load Settings       (Req: EEPROM_SETTINGS)
-   *    Save Settings       (Req: EEPROM_SETTINGS)
-   */
-  void menu_bed_leveling() {
-    START_MENU();
-    MENU_BACK(MSG_MOTION);
-
-    const bool is_homed = all_axes_known();
-
-    // Auto Home if not using manual probing
-    #if DISABLED(PROBE_MANUALLY) && DISABLED(MESH_BED_LEVELING)
-      if (!is_homed) MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
-    #endif
-
-    // Level Bed
-    #if ENABLED(PROBE_MANUALLY) || ENABLED(MESH_BED_LEVELING)
-      // Manual leveling uses a guided procedure
-      MENU_ITEM(submenu, MSG_LEVEL_BED, _lcd_level_bed_continue);
-    #else
-      // Automatic leveling can just run the G-code
-      MENU_ITEM(gcode, MSG_LEVEL_BED, is_homed ? PSTR("G29") : PSTR("G28\nG29"));
-    #endif
-
-    // Homed and leveling is valid? Then leveling can be toggled.
-    if (is_homed && leveling_is_valid()) {
-      bool new_level_state = planner.leveling_active;
-      MENU_ITEM_EDIT_CALLBACK(bool, MSG_BED_LEVELING, &new_level_state, _lcd_toggle_bed_leveling);
-    }
-
-    // Z Fade Height
-    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float3, MSG_Z_FADE_HEIGHT, &lcd_z_fade_height, 0, 100, _lcd_set_z_fade_height);
-    #endif
-
-    //
-    // MBL Z Offset
-    //
-    #if ENABLED(MESH_BED_LEVELING)
-      MENU_ITEM_EDIT(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
-    #endif
-
-    #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
-      MENU_ITEM(submenu, MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
-    #elif HAS_BED_PROBE
-      MENU_ITEM_EDIT(float52, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
-    #endif
-
-    #if ENABLED(LEVEL_BED_CORNERS)
-      // Move to the next corner for leveling
-      MENU_ITEM(submenu, MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
-    #endif
-
-    #if ENABLED(EEPROM_SETTINGS)
-      MENU_ITEM(function, MSG_LOAD_EEPROM, lcd_load_settings);
-      MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
-    #endif
-    END_MENU();
-  }
-
-#endif // LCD_BED_LEVELING
-
 #if ENABLED(DELTA_CALIBRATION_MENU) || ENABLED(DELTA_AUTO_CALIBRATION)
 
   void _man_probe_pt(const float &rx, const float &ry) {

commit 96f313fb410b764958de61c213dcd5da084ba581
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Oct 27 18:52:20 2018 -0500

    Move Info Menu to its own file

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 9c2317fa2e..30c9f8f1eb 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -255,14 +255,6 @@ void menu_action_setting_edit_callback_bool(PGM_P pstr, bool* ptr, screenFunc_t
   void menu_advanced_filament();
 #endif
 
-#if ENABLED(LCD_INFO_MENU)
-  #if ENABLED(PRINTCOUNTER)
-    void menu_info_stats();
-  #endif
-  void menu_info_thermistors();
-  void menu_info_board();
-#endif
-
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   #if E_STEPPERS > 1 || ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
     void menu_change_filament();
@@ -1767,171 +1759,6 @@ void menu_advanced_settings() {
 
 #endif // SDSUPPORT
 
-#if ENABLED(LCD_INFO_MENU)
-
-  #if ENABLED(PRINTCOUNTER)
-    /**
-     *
-     * About Printer > Statistics submenu
-     *
-     */
-    void menu_info_stats() {
-      if (use_click()) { return lcd_goto_previous_menu(); }
-
-      char buffer[21];
-      printStatistics stats = print_job_timer.getStats();
-
-      START_SCREEN();                                                                                // 12345678901234567890
-      STATIC_ITEM(MSG_INFO_PRINT_COUNT ": ", false, false, itostr3left(stats.totalPrints));          // Print Count: 999
-      STATIC_ITEM(MSG_INFO_COMPLETED_PRINTS": ", false, false, itostr3left(stats.finishedPrints));   // Completed  : 666
-
-      duration_t elapsed = stats.printTime;
-      elapsed.toString(buffer);
-
-      STATIC_ITEM(MSG_INFO_PRINT_TIME ": ", false, false);                                           // Total print Time:
-      STATIC_ITEM("", false, false, buffer);                                                         // 99y 364d 23h 59m 59s
-
-      elapsed = stats.longestPrint;
-      elapsed.toString(buffer);
-
-      STATIC_ITEM(MSG_INFO_PRINT_LONGEST ": ", false, false);                                        // Longest job time:
-      STATIC_ITEM("", false, false, buffer);                                                         // 99y 364d 23h 59m 59s
-
-      sprintf_P(buffer, PSTR("%ld.%im"), long(stats.filamentUsed / 1000), int16_t(stats.filamentUsed / 100) % 10);
-      STATIC_ITEM(MSG_INFO_PRINT_FILAMENT ": ", false, false);                                       // Extruded total:
-      STATIC_ITEM("", false, false, buffer);                                                         // 125m
-      END_SCREEN();
-    }
-  #endif // PRINTCOUNTER
-
-  /**
-   *
-   * About Printer > Thermistors
-   *
-   */
-  void menu_info_thermistors() {
-    if (use_click()) { return lcd_goto_previous_menu(); }
-    START_SCREEN();
-    #define THERMISTOR_ID TEMP_SENSOR_0
-    #include "../thermistornames.h"
-    STATIC_ITEM("T0: " THERMISTOR_NAME, false, true);
-    STATIC_ITEM(MSG_INFO_MIN_TEMP ": " STRINGIFY(HEATER_0_MINTEMP), false);
-    STATIC_ITEM(MSG_INFO_MAX_TEMP ": " STRINGIFY(HEATER_0_MAXTEMP), false);
-
-    #if TEMP_SENSOR_1 != 0
-      #undef THERMISTOR_ID
-      #define THERMISTOR_ID TEMP_SENSOR_1
-      #include "../thermistornames.h"
-      STATIC_ITEM("T1: " THERMISTOR_NAME, false, true);
-      STATIC_ITEM(MSG_INFO_MIN_TEMP ": " STRINGIFY(HEATER_1_MINTEMP), false);
-      STATIC_ITEM(MSG_INFO_MAX_TEMP ": " STRINGIFY(HEATER_1_MAXTEMP), false);
-    #endif
-
-    #if TEMP_SENSOR_2 != 0
-      #undef THERMISTOR_ID
-      #define THERMISTOR_ID TEMP_SENSOR_2
-      #include "../thermistornames.h"
-      STATIC_ITEM("T2: " THERMISTOR_NAME, false, true);
-      STATIC_ITEM(MSG_INFO_MIN_TEMP ": " STRINGIFY(HEATER_2_MINTEMP), false);
-      STATIC_ITEM(MSG_INFO_MAX_TEMP ": " STRINGIFY(HEATER_2_MAXTEMP), false);
-    #endif
-
-    #if TEMP_SENSOR_3 != 0
-      #undef THERMISTOR_ID
-      #define THERMISTOR_ID TEMP_SENSOR_3
-      #include "../thermistornames.h"
-      STATIC_ITEM("T3: " THERMISTOR_NAME, false, true);
-      STATIC_ITEM(MSG_INFO_MIN_TEMP ": " STRINGIFY(HEATER_3_MINTEMP), false);
-      STATIC_ITEM(MSG_INFO_MAX_TEMP ": " STRINGIFY(HEATER_3_MAXTEMP), false);
-    #endif
-
-    #if TEMP_SENSOR_4 != 0
-      #undef THERMISTOR_ID
-      #define THERMISTOR_ID TEMP_SENSOR_4
-      #include "../thermistornames.h"
-      STATIC_ITEM("T4: " THERMISTOR_NAME, false, true);
-      STATIC_ITEM(MSG_INFO_MIN_TEMP ": " STRINGIFY(HEATER_4_MINTEMP), false);
-      STATIC_ITEM(MSG_INFO_MAX_TEMP ": " STRINGIFY(HEATER_4_MAXTEMP), false);
-    #endif
-
-    #if HAS_HEATED_BED
-      #undef THERMISTOR_ID
-      #define THERMISTOR_ID TEMP_SENSOR_BED
-      #include "../thermistornames.h"
-      STATIC_ITEM("TBed:" THERMISTOR_NAME, false, true);
-      STATIC_ITEM(MSG_INFO_MIN_TEMP ": " STRINGIFY(BED_MINTEMP), false);
-      STATIC_ITEM(MSG_INFO_MAX_TEMP ": " STRINGIFY(BED_MAXTEMP), false);
-    #endif
-    END_SCREEN();
-  }
-
-  /**
-   *
-   * About Printer > Board Info
-   *
-   */
-  void menu_info_board() {
-    if (use_click()) { return lcd_goto_previous_menu(); }
-    START_SCREEN();
-    STATIC_ITEM(BOARD_NAME, true, true);                           // MyPrinterController
-    STATIC_ITEM(MSG_INFO_BAUDRATE ": " STRINGIFY(BAUDRATE), true); // Baud: 250000
-    STATIC_ITEM(MSG_INFO_PROTOCOL ": " PROTOCOL_VERSION, true);    // Protocol: 1.0
-    #if POWER_SUPPLY == 0
-      STATIC_ITEM(MSG_INFO_PSU ": Generic", true);
-    #elif POWER_SUPPLY == 1
-      STATIC_ITEM(MSG_INFO_PSU ": ATX", true);  // Power Supply: ATX
-    #elif POWER_SUPPLY == 2
-      STATIC_ITEM(MSG_INFO_PSU ": XBox", true); // Power Supply: XBox
-    #endif
-    END_SCREEN();
-  }
-
-  /**
-   *
-   * About Printer > Printer Info
-   *
-   */
-  void menu_info_printer() {
-    if (use_click()) { return lcd_goto_previous_menu(); }
-    START_SCREEN();
-    STATIC_ITEM(MSG_MARLIN, true, true);                             // Marlin
-    STATIC_ITEM(SHORT_BUILD_VERSION, true);                          // x.x.x-Branch
-    STATIC_ITEM(STRING_DISTRIBUTION_DATE, true);                     // YYYY-MM-DD HH:MM
-    STATIC_ITEM(MACHINE_NAME, true);                                 // My3DPrinter
-    STATIC_ITEM(WEBSITE_URL, true);                                  // www.my3dprinter.com
-    STATIC_ITEM(MSG_INFO_EXTRUDERS ": " STRINGIFY(EXTRUDERS), true); // Extruders: 2
-    #if ENABLED(AUTO_BED_LEVELING_3POINT)
-      STATIC_ITEM(MSG_3POINT_LEVELING, true);                        // 3-Point Leveling
-    #elif ENABLED(AUTO_BED_LEVELING_LINEAR)
-      STATIC_ITEM(MSG_LINEAR_LEVELING, true);                        // Linear Leveling
-    #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
-      STATIC_ITEM(MSG_BILINEAR_LEVELING, true);                      // Bi-linear Leveling
-    #elif ENABLED(AUTO_BED_LEVELING_UBL)
-      STATIC_ITEM(MSG_UBL_LEVELING, true);                           // Unified Bed Leveling
-    #elif ENABLED(MESH_BED_LEVELING)
-      STATIC_ITEM(MSG_MESH_LEVELING, true);                          // Mesh Leveling
-    #endif
-    END_SCREEN();
-  }
-
-  /**
-   *
-   * "About Printer" submenu
-   *
-   */
-  void menu_info() {
-    START_MENU();
-    MENU_BACK(MSG_MAIN);
-    MENU_ITEM(submenu, MSG_INFO_PRINTER_MENU, menu_info_printer);        // Printer Info >
-    MENU_ITEM(submenu, MSG_INFO_BOARD_MENU, menu_info_board);            // Board Info >
-    MENU_ITEM(submenu, MSG_INFO_THERMISTOR_MENU, menu_info_thermistors); // Thermistors >
-    #if ENABLED(PRINTCOUNTER)
-      MENU_ITEM(submenu, MSG_INFO_STATS_MENU, menu_info_stats);          // Printer Statistics >
-    #endif
-    END_MENU();
-  }
-#endif // LCD_INFO_MENU
-
 /**
  *
  * LED Menu

commit 423ab029b2509ca5844a80f2eeb78e8c054eb409
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Oct 27 18:30:37 2018 -0500

    Move Temperature Menu to its own file

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 256b6ab5d4..9c2317fa2e 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -654,261 +654,6 @@ void watch_temp_callback_bed() {
   #endif
 }
 
-/**
- *
- * "Temperature" submenu items
- *
- */
-void _lcd_preheat(const int16_t endnum, const int16_t temph, const int16_t tempb, const uint8_t fan) {
-  if (temph > 0) thermalManager.setTargetHotend(MIN(heater_maxtemp[endnum], temph), endnum);
-  #if HAS_HEATED_BED
-    if (tempb >= 0) thermalManager.setTargetBed(tempb);
-  #else
-    UNUSED(tempb);
-  #endif
-  #if FAN_COUNT > 0
-    #if FAN_COUNT > 1
-      fan_speed[active_extruder < FAN_COUNT ? active_extruder : 0] = fan;
-    #else
-      fan_speed[0] = fan;
-    #endif
-  #else
-    UNUSED(fan);
-  #endif
-  lcd_return_to_status();
-}
-
-#if HAS_TEMP_HOTEND
-  void lcd_preheat_m1_e0_only() { _lcd_preheat(0, lcd_preheat_hotend_temp[0], -1, lcd_preheat_fan_speed[0]); }
-  void lcd_preheat_m2_e0_only() { _lcd_preheat(0, lcd_preheat_hotend_temp[1], -1, lcd_preheat_fan_speed[1]); }
-  #if HAS_HEATED_BED
-    void lcd_preheat_m1_e0() { _lcd_preheat(0, lcd_preheat_hotend_temp[0], lcd_preheat_bed_temp[0], lcd_preheat_fan_speed[0]); }
-    void lcd_preheat_m2_e0() { _lcd_preheat(0, lcd_preheat_hotend_temp[1], lcd_preheat_bed_temp[1], lcd_preheat_fan_speed[1]); }
-  #endif
-#endif
-
-#if HOTENDS > 1
-  void lcd_preheat_m1_e1_only() { _lcd_preheat(1, lcd_preheat_hotend_temp[0], -1, lcd_preheat_fan_speed[0]); }
-  void lcd_preheat_m2_e1_only() { _lcd_preheat(1, lcd_preheat_hotend_temp[1], -1, lcd_preheat_fan_speed[1]); }
-  #if HAS_HEATED_BED
-    void lcd_preheat_m1_e1() { _lcd_preheat(1, lcd_preheat_hotend_temp[0], lcd_preheat_bed_temp[0], lcd_preheat_fan_speed[0]); }
-    void lcd_preheat_m2_e1() { _lcd_preheat(1, lcd_preheat_hotend_temp[1], lcd_preheat_bed_temp[1], lcd_preheat_fan_speed[1]); }
-  #endif
-  #if HOTENDS > 2
-    void lcd_preheat_m1_e2_only() { _lcd_preheat(2, lcd_preheat_hotend_temp[0], -1, lcd_preheat_fan_speed[0]); }
-    void lcd_preheat_m2_e2_only() { _lcd_preheat(2, lcd_preheat_hotend_temp[1], -1, lcd_preheat_fan_speed[1]); }
-    #if HAS_HEATED_BED
-      void lcd_preheat_m1_e2() { _lcd_preheat(2, lcd_preheat_hotend_temp[0], lcd_preheat_bed_temp[0], lcd_preheat_fan_speed[0]); }
-      void lcd_preheat_m2_e2() { _lcd_preheat(2, lcd_preheat_hotend_temp[1], lcd_preheat_bed_temp[1], lcd_preheat_fan_speed[1]); }
-    #endif
-    #if HOTENDS > 3
-      void lcd_preheat_m1_e3_only() { _lcd_preheat(3, lcd_preheat_hotend_temp[0], -1, lcd_preheat_fan_speed[0]); }
-      void lcd_preheat_m2_e3_only() { _lcd_preheat(3, lcd_preheat_hotend_temp[1], -1, lcd_preheat_fan_speed[1]); }
-      #if HAS_HEATED_BED
-        void lcd_preheat_m1_e3() { _lcd_preheat(3, lcd_preheat_hotend_temp[0], lcd_preheat_bed_temp[0], lcd_preheat_fan_speed[0]); }
-        void lcd_preheat_m2_e3() { _lcd_preheat(3, lcd_preheat_hotend_temp[1], lcd_preheat_bed_temp[1], lcd_preheat_fan_speed[1]); }
-      #endif
-      #if HOTENDS > 4
-        void lcd_preheat_m1_e4_only() { _lcd_preheat(4, lcd_preheat_hotend_temp[0], -1, lcd_preheat_fan_speed[0]); }
-        void lcd_preheat_m2_e4_only() { _lcd_preheat(4, lcd_preheat_hotend_temp[1], -1, lcd_preheat_fan_speed[1]); }
-        #if HAS_HEATED_BED
-          void lcd_preheat_m1_e4() { _lcd_preheat(4, lcd_preheat_hotend_temp[0], lcd_preheat_bed_temp[0], lcd_preheat_fan_speed[0]); }
-          void lcd_preheat_m2_e4() { _lcd_preheat(4, lcd_preheat_hotend_temp[1], lcd_preheat_bed_temp[1], lcd_preheat_fan_speed[1]); }
-        #endif
-        #if HOTENDS > 5
-          void lcd_preheat_m1_e5_only() { _lcd_preheat(5, lcd_preheat_hotend_temp[0], -1, lcd_preheat_fan_speed[0]); }
-          void lcd_preheat_m2_e5_only() { _lcd_preheat(5, lcd_preheat_hotend_temp[1], -1, lcd_preheat_fan_speed[1]); }
-          #if HAS_HEATED_BED
-            void lcd_preheat_m1_e5() { _lcd_preheat(5, lcd_preheat_hotend_temp[0], lcd_preheat_bed_temp[0], lcd_preheat_fan_speed[0]); }
-            void lcd_preheat_m2_e5() { _lcd_preheat(5, lcd_preheat_hotend_temp[1], lcd_preheat_bed_temp[1], lcd_preheat_fan_speed[1]); }
-          #endif
-        #endif // HOTENDS > 5
-      #endif // HOTENDS > 4
-    #endif // HOTENDS > 3
-  #endif // HOTENDS > 2
-
-  void lcd_preheat_m1_all() {
-    #if HOTENDS > 1
-      thermalManager.setTargetHotend(lcd_preheat_hotend_temp[0], 1);
-      #if HOTENDS > 2
-        thermalManager.setTargetHotend(lcd_preheat_hotend_temp[0], 2);
-        #if HOTENDS > 3
-          thermalManager.setTargetHotend(lcd_preheat_hotend_temp[0], 3);
-          #if HOTENDS > 4
-            thermalManager.setTargetHotend(lcd_preheat_hotend_temp[0], 4);
-            #if HOTENDS > 5
-              thermalManager.setTargetHotend(lcd_preheat_hotend_temp[0], 5);
-            #endif // HOTENDS > 5
-          #endif // HOTENDS > 4
-        #endif // HOTENDS > 3
-      #endif // HOTENDS > 2
-    #endif // HOTENDS > 1
-    #if HAS_HEATED_BED
-      lcd_preheat_m1_e0();
-    #else
-      lcd_preheat_m1_e0_only();
-    #endif
-  }
-  void lcd_preheat_m2_all() {
-    #if HOTENDS > 1
-      thermalManager.setTargetHotend(lcd_preheat_hotend_temp[1], 1);
-      #if HOTENDS > 2
-        thermalManager.setTargetHotend(lcd_preheat_hotend_temp[1], 2);
-        #if HOTENDS > 3
-          thermalManager.setTargetHotend(lcd_preheat_hotend_temp[1], 3);
-          #if HOTENDS > 4
-            thermalManager.setTargetHotend(lcd_preheat_hotend_temp[1], 4);
-            #if HOTENDS > 5
-              thermalManager.setTargetHotend(lcd_preheat_hotend_temp[1], 5);
-            #endif // HOTENDS > 5
-          #endif // HOTENDS > 4
-        #endif // HOTENDS > 3
-      #endif // HOTENDS > 2
-    #endif // HOTENDS > 1
-    #if HAS_HEATED_BED
-      lcd_preheat_m2_e0();
-    #else
-      lcd_preheat_m2_e0_only();
-    #endif
-  }
-
-#endif // HOTENDS > 1
-
-#if HAS_HEATED_BED
-  void lcd_preheat_m1_bedonly() { _lcd_preheat(0, 0, lcd_preheat_bed_temp[0], lcd_preheat_fan_speed[0]); }
-  void lcd_preheat_m2_bedonly() { _lcd_preheat(0, 0, lcd_preheat_bed_temp[1], lcd_preheat_fan_speed[1]); }
-#endif
-
-#if HAS_TEMP_HOTEND || HAS_HEATED_BED
-
-  void menu_preheat_m1() {
-    START_MENU();
-    MENU_BACK(MSG_TEMPERATURE);
-    #if HOTENDS == 1
-      #if HAS_HEATED_BED
-        MENU_ITEM(function, MSG_PREHEAT_1, lcd_preheat_m1_e0);
-        MENU_ITEM(function, MSG_PREHEAT_1_END, lcd_preheat_m1_e0_only);
-      #else
-        MENU_ITEM(function, MSG_PREHEAT_1, lcd_preheat_m1_e0_only);
-      #endif
-    #elif HOTENDS > 1
-      #if HAS_HEATED_BED
-        MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H1, lcd_preheat_m1_e0);
-        MENU_ITEM(function, MSG_PREHEAT_1_END " " MSG_E1, lcd_preheat_m1_e0_only);
-        MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H2, lcd_preheat_m1_e1);
-        MENU_ITEM(function, MSG_PREHEAT_1_END " " MSG_E2, lcd_preheat_m1_e1_only);
-      #else
-        MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H1, lcd_preheat_m1_e0_only);
-        MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H2, lcd_preheat_m1_e1_only);
-      #endif
-      #if HOTENDS > 2
-        #if HAS_HEATED_BED
-          MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H3, lcd_preheat_m1_e2);
-          MENU_ITEM(function, MSG_PREHEAT_1_END " " MSG_E3, lcd_preheat_m1_e2_only);
-        #else
-          MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H3, lcd_preheat_m1_e2_only);
-        #endif
-        #if HOTENDS > 3
-          #if HAS_HEATED_BED
-            MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H4, lcd_preheat_m1_e3);
-            MENU_ITEM(function, MSG_PREHEAT_1_END " " MSG_E4, lcd_preheat_m1_e3_only);
-          #else
-            MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H4, lcd_preheat_m1_e3_only);
-          #endif
-          #if HOTENDS > 4
-            #if HAS_HEATED_BED
-              MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H5, lcd_preheat_m1_e4);
-              MENU_ITEM(function, MSG_PREHEAT_1_END " " MSG_E5, lcd_preheat_m1_e4_only);
-            #else
-              MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H5, lcd_preheat_m1_e4_only);
-            #endif
-            #if HOTENDS > 5
-              #if HAS_HEATED_BED
-                MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H6, lcd_preheat_m1_e5);
-                MENU_ITEM(function, MSG_PREHEAT_1_END " " MSG_E6, lcd_preheat_m1_e5_only);
-              #else
-                MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H6, lcd_preheat_m1_e5_only);
-              #endif
-            #endif // HOTENDS > 5
-          #endif // HOTENDS > 4
-        #endif // HOTENDS > 3
-      #endif // HOTENDS > 2
-      MENU_ITEM(function, MSG_PREHEAT_1_ALL, lcd_preheat_m1_all);
-    #endif // HOTENDS > 1
-    #if HAS_HEATED_BED
-      MENU_ITEM(function, MSG_PREHEAT_1_BEDONLY, lcd_preheat_m1_bedonly);
-    #endif
-    END_MENU();
-  }
-
-  void menu_preheat_m2() {
-    START_MENU();
-    MENU_BACK(MSG_TEMPERATURE);
-    #if HOTENDS == 1
-      #if HAS_HEATED_BED
-        MENU_ITEM(function, MSG_PREHEAT_2, lcd_preheat_m2_e0);
-        MENU_ITEM(function, MSG_PREHEAT_2_END, lcd_preheat_m2_e0_only);
-      #else
-        MENU_ITEM(function, MSG_PREHEAT_2, lcd_preheat_m2_e0_only);
-      #endif
-    #elif HOTENDS > 1
-      #if HAS_HEATED_BED
-        MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H1, lcd_preheat_m2_e0);
-        MENU_ITEM(function, MSG_PREHEAT_2_END " " MSG_E1, lcd_preheat_m2_e0_only);
-        MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H2, lcd_preheat_m2_e1);
-        MENU_ITEM(function, MSG_PREHEAT_2_END " " MSG_E2, lcd_preheat_m2_e1_only);
-      #else
-        MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H1, lcd_preheat_m2_e0_only);
-        MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H2, lcd_preheat_m2_e1_only);
-      #endif
-      #if HOTENDS > 2
-        #if HAS_HEATED_BED
-          MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H3, lcd_preheat_m2_e2);
-          MENU_ITEM(function, MSG_PREHEAT_2_END " " MSG_E3, lcd_preheat_m2_e2_only);
-        #else
-          MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H3, lcd_preheat_m2_e2_only);
-        #endif
-        #if HOTENDS > 3
-          #if HAS_HEATED_BED
-            MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H4, lcd_preheat_m2_e3);
-            MENU_ITEM(function, MSG_PREHEAT_2_END " " MSG_E4, lcd_preheat_m2_e3_only);
-          #else
-            MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H4, lcd_preheat_m2_e3_only);
-          #endif
-          #if HOTENDS > 4
-            #if HAS_HEATED_BED
-              MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H5, lcd_preheat_m2_e4);
-              MENU_ITEM(function, MSG_PREHEAT_2_END " " MSG_E5, lcd_preheat_m2_e4_only);
-            #else
-              MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H5, lcd_preheat_m2_e4_only);
-            #endif
-            #if HOTENDS > 5
-              #if HAS_HEATED_BED
-                MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H6, lcd_preheat_m2_e5);
-                MENU_ITEM(function, MSG_PREHEAT_2_END " " MSG_E6, lcd_preheat_m2_e5_only);
-              #else
-                MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H6, lcd_preheat_m2_e5_only);
-              #endif
-            #endif // HOTENDS > 5
-          #endif // HOTENDS > 4
-        #endif // HOTENDS > 3
-      #endif // HOTENDS > 2
-      MENU_ITEM(function, MSG_PREHEAT_2_ALL, lcd_preheat_m2_all);
-    #endif // HOTENDS > 1
-    #if HAS_HEATED_BED
-      MENU_ITEM(function, MSG_PREHEAT_2_BEDONLY, lcd_preheat_m2_bedonly);
-    #endif
-    END_MENU();
-  }
-
-#endif // HAS_TEMP_HOTEND || HAS_HEATED_BED
-
-void lcd_cooldown() {
-  zero_fan_speeds();
-  thermalManager.disable_all_heaters();
-  lcd_return_to_status();
-}
-
 #if ENABLED(AUTO_BED_LEVELING_UBL) || ENABLED(PID_AUTOTUNE_MENU) || ENABLED(ADVANCED_PAUSE_FEATURE)
 
   void lcd_enqueue_command(const char * const cmd) {
@@ -1440,97 +1185,6 @@ void _lcd_draw_homing() {
 
 #endif // PIDTEMP
 
-/**
- *
- * "Temperature" submenu
- *
- */
-void menu_temperature() {
-  START_MENU();
-  MENU_BACK(MSG_MAIN);
-
-  //
-  // Nozzle:
-  // Nozzle [1-5]:
-  //
-  #if HOTENDS == 1
-    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE, &thermalManager.target_temperature[0], 0, HEATER_0_MAXTEMP - 15, watch_temp_callback_E0);
-  #else // HOTENDS > 1
-    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N1, &thermalManager.target_temperature[0], 0, HEATER_0_MAXTEMP - 15, watch_temp_callback_E0);
-    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N2, &thermalManager.target_temperature[1], 0, HEATER_1_MAXTEMP - 15, watch_temp_callback_E1);
-    #if HOTENDS > 2
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N3, &thermalManager.target_temperature[2], 0, HEATER_2_MAXTEMP - 15, watch_temp_callback_E2);
-      #if HOTENDS > 3
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N4, &thermalManager.target_temperature[3], 0, HEATER_3_MAXTEMP - 15, watch_temp_callback_E3);
-        #if HOTENDS > 4
-          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N5, &thermalManager.target_temperature[4], 0, HEATER_4_MAXTEMP - 15, watch_temp_callback_E4);
-          #if HOTENDS > 5
-            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N6, &thermalManager.target_temperature[5], 0, HEATER_5_MAXTEMP - 15, watch_temp_callback_E5);
-          #endif // HOTENDS > 5
-        #endif // HOTENDS > 4
-      #endif // HOTENDS > 3
-    #endif // HOTENDS > 2
-  #endif // HOTENDS > 1
-
-  //
-  // Bed:
-  //
-  #if HAS_HEATED_BED
-    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_BED, &thermalManager.target_temperature_bed, 0, BED_MAXTEMP - 15, watch_temp_callback_bed);
-  #endif
-
-  //
-  // Fan Speed:
-  //
-  #if FAN_COUNT > 0
-    #if HAS_FAN0
-      MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_FAN_SPEED FAN_SPEED_1_SUFFIX, &fan_speed[0], 0, 255);
-      #if ENABLED(EXTRA_FAN_SPEED)
-        MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_EXTRA_FAN_SPEED FAN_SPEED_1_SUFFIX, &new_fan_speed[0], 3, 255);
-      #endif
-    #endif
-    #if HAS_FAN1
-      MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_FAN_SPEED " 2", &fan_speed[1], 0, 255);
-      #if ENABLED(EXTRA_FAN_SPEED)
-        MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_EXTRA_FAN_SPEED " 2", &new_fan_speed[1], 3, 255);
-      #endif
-    #endif
-    #if HAS_FAN2
-      MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_FAN_SPEED " 3", &fan_speed[2], 0, 255);
-      #if ENABLED(EXTRA_FAN_SPEED)
-        MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_EXTRA_FAN_SPEED " 3", &new_fan_speed[2], 3, 255);
-      #endif
-    #endif
-  #endif // FAN_COUNT > 0
-
-  #if HAS_TEMP_HOTEND
-
-    //
-    // Cooldown
-    //
-    bool has_heat = false;
-    HOTEND_LOOP() if (thermalManager.target_temperature[HOTEND_INDEX]) { has_heat = true; break; }
-    #if HAS_TEMP_BED
-      if (thermalManager.target_temperature_bed) has_heat = true;
-    #endif
-    if (has_heat) MENU_ITEM(function, MSG_COOLDOWN, lcd_cooldown);
-
-    //
-    // Preheat for Material 1 and 2
-    //
-    #if TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 || TEMP_SENSOR_3 != 0 || TEMP_SENSOR_4 != 0 || HAS_HEATED_BED
-      MENU_ITEM(submenu, MSG_PREHEAT_1, menu_preheat_m1);
-      MENU_ITEM(submenu, MSG_PREHEAT_2, menu_preheat_m2);
-    #else
-      MENU_ITEM(function, MSG_PREHEAT_1, lcd_preheat_m1_e0_only);
-      MENU_ITEM(function, MSG_PREHEAT_2, lcd_preheat_m2_e0_only);
-    #endif
-
-  #endif // HAS_TEMP_HOTEND
-
-  END_MENU();
-}
-
 /**
  *
  * "Advanced Settings" -> "Temperature" submenu

commit 489017995e5eb799df9eb0ea6b2a721a32ab1106
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Oct 27 18:10:44 2018 -0500

    Move UBL Menu to its own file

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index a58f006aa5..256b6ab5d4 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -621,68 +621,6 @@ void line_to_z(const float &z) {
 
 #endif // BABYSTEP_ZPROBE_OFFSET
 
-#if ENABLED(AUTO_BED_LEVELING_UBL)
-
-  float mesh_edit_value, mesh_edit_accumulator; // We round mesh_edit_value to 2.5 decimal places. So we keep a
-                                                // separate value that doesn't lose precision.
-  static int16_t ubl_encoderPosition = 0;
-
-  static void _lcd_mesh_fine_tune(PGM_P msg) {
-    defer_return_to_status = true;
-    if (ubl.encoder_diff) {
-      ubl_encoderPosition = (ubl.encoder_diff > 0) ? 1 : -1;
-      ubl.encoder_diff = 0;
-
-      mesh_edit_accumulator += float(ubl_encoderPosition) * 0.005f * 0.5f;
-      mesh_edit_value = mesh_edit_accumulator;
-      encoderPosition = 0;
-      lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
-
-      const int32_t rounded = (int32_t)(mesh_edit_value * 1000);
-      mesh_edit_value = float(rounded - (rounded % 5L)) / 1000;
-    }
-
-    if (lcdDrawUpdate) {
-      lcd_implementation_drawedit(msg, ftostr43sign(mesh_edit_value));
-      #if ENABLED(MESH_EDIT_GFX_OVERLAY)
-        _lcd_zoffset_overlay_gfx(mesh_edit_value);
-      #endif
-    }
-  }
-
-  void _lcd_mesh_edit_NOP() {
-    defer_return_to_status = true;
-  }
-
-  float lcd_mesh_edit() {
-    lcd_goto_screen(_lcd_mesh_edit_NOP);
-    lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
-    _lcd_mesh_fine_tune(PSTR("Mesh Editor"));
-    return mesh_edit_value;
-  }
-
-  void lcd_mesh_edit_setup(const float &initial) {
-    mesh_edit_value = mesh_edit_accumulator = initial;
-    lcd_goto_screen(_lcd_mesh_edit_NOP);
-  }
-
-  void _lcd_z_offset_edit() {
-    _lcd_mesh_fine_tune(PSTR("Z-Offset: "));
-  }
-
-  float lcd_z_offset_edit() {
-    lcd_goto_screen(_lcd_z_offset_edit);
-    return mesh_edit_value;
-  }
-
-  void lcd_z_offset_edit_setup(const float &initial) {
-    mesh_edit_value = mesh_edit_accumulator = initial;
-    lcd_goto_screen(_lcd_z_offset_edit);
-  }
-
-#endif // AUTO_BED_LEVELING_UBL
-
-
 /**
  * Watch temperature callbacks
  */
@@ -1241,522 +1179,7 @@ void _lcd_draw_homing() {
     enqueue_and_echo_commands_P(PSTR("G28"));
   }
 
-#elif ENABLED(AUTO_BED_LEVELING_UBL)
-
-  static int16_t ubl_storage_slot = 0,
-             custom_hotend_temp = 190,
-             side_points = 3,
-             ubl_fillin_amount = 5,
-             ubl_height_amount = 1,
-             n_edit_pts = 1,
-             x_plot = 0,
-             y_plot = 0;
-
-  #if HAS_HEATED_BED
-    static int16_t custom_bed_temp = 50;
-  #endif
-
-  /**
-   * UBL Build Custom Mesh Command
-   */
-  void _lcd_ubl_build_custom_mesh() {
-    char UBL_LCD_GCODE[20];
-    enqueue_and_echo_commands_P(PSTR("G28"));
-    #if HAS_HEATED_BED
-      sprintf_P(UBL_LCD_GCODE, PSTR("M190 S%i"), custom_bed_temp);
-      lcd_enqueue_command(UBL_LCD_GCODE);
-    #endif
-    sprintf_P(UBL_LCD_GCODE, PSTR("M109 S%i"), custom_hotend_temp);
-    lcd_enqueue_command(UBL_LCD_GCODE);
-    enqueue_and_echo_commands_P(PSTR("G29 P1"));
-  }
-
-  /**
-   * UBL Custom Mesh submenu
-   *
-   * << Build Mesh
-   *    Hotend Temp: ---
-   *    Bed Temp: ---
-   *    Build Custom Mesh
-   */
-  void _lcd_ubl_custom_mesh() {
-    START_MENU();
-    MENU_BACK(MSG_UBL_BUILD_MESH_MENU);
-    MENU_ITEM_EDIT(int3, MSG_UBL_HOTEND_TEMP_CUSTOM, &custom_hotend_temp, EXTRUDE_MINTEMP, (HEATER_0_MAXTEMP - 10));
-    #if HAS_HEATED_BED
-      MENU_ITEM_EDIT(int3, MSG_UBL_BED_TEMP_CUSTOM, &custom_bed_temp, BED_MINTEMP, (BED_MAXTEMP - 15));
-    #endif
-    MENU_ITEM(function, MSG_UBL_BUILD_CUSTOM_MESH, _lcd_ubl_build_custom_mesh);
-    END_MENU();
-  }
-
-  /**
-   * UBL Adjust Mesh Height Command
-   */
-  void _lcd_ubl_adjust_height_cmd() {
-    char UBL_LCD_GCODE[16];
-    const int ind = ubl_height_amount > 0 ? 9 : 10;
-    strcpy_P(UBL_LCD_GCODE, PSTR("G29 P6 C -"));
-    sprintf_P(&UBL_LCD_GCODE[ind], PSTR(".%i"), ABS(ubl_height_amount));
-    lcd_enqueue_command(UBL_LCD_GCODE);
-  }
-
-  /**
-   * UBL Adjust Mesh Height submenu
-   *
-   * << Edit Mesh
-   *    Height Amount: ---
-   *    Adjust Mesh Height
-   * << Info Screen
-   */
-  void _menu_ubl_height_adjust() {
-    START_MENU();
-    MENU_BACK(MSG_UBL_EDIT_MESH_MENU);
-    MENU_ITEM_EDIT_CALLBACK(int3, MSG_UBL_MESH_HEIGHT_AMOUNT, &ubl_height_amount, -9, 9, _lcd_ubl_adjust_height_cmd);
-    MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
-    END_MENU();
-  }
-
-  /**
-   * UBL Edit Mesh submenu
-   *
-   * << UBL Tools
-   *    Fine Tune All
-   *    Fine Tune Closest
-   *  - Adjust Mesh Height >>
-   * << Info Screen
-   */
-  void _lcd_ubl_edit_mesh() {
-    START_MENU();
-    MENU_BACK(MSG_UBL_TOOLS);
-    MENU_ITEM(gcode, MSG_UBL_FINE_TUNE_ALL, PSTR("G29 P4 R999 T"));
-    MENU_ITEM(gcode, MSG_UBL_FINE_TUNE_CLOSEST, PSTR("G29 P4 T"));
-    MENU_ITEM(submenu, MSG_UBL_MESH_HEIGHT_ADJUST, _menu_ubl_height_adjust);
-    MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
-    END_MENU();
-  }
-
-  /**
-   * UBL Validate Custom Mesh Command
-   */
-  void _lcd_ubl_validate_custom_mesh() {
-    char UBL_LCD_GCODE[24];
-    const int temp =
-      #if HAS_HEATED_BED
-        custom_bed_temp
-      #else
-        0
-      #endif
-    ;
-    sprintf_P(UBL_LCD_GCODE, PSTR("G26 C B%i H%i P"), temp, custom_hotend_temp);
-    lcd_enqueue_commands_P(PSTR("G28"));
-    lcd_enqueue_command(UBL_LCD_GCODE);
-  }
-
-  /**
-   * UBL Validate Mesh submenu
-   *
-   * << UBL Tools
-   *    Mesh Validation with Material 1
-   *    Mesh Validation with Material 2
-   *    Validate Custom Mesh
-   * << Info Screen
-   */
-  void _lcd_ubl_validate_mesh() {
-    START_MENU();
-    MENU_BACK(MSG_UBL_TOOLS);
-    #if HAS_HEATED_BED
-      MENU_ITEM(gcode, MSG_UBL_VALIDATE_MESH_M1, PSTR("G28\nG26 C B" STRINGIFY(PREHEAT_1_TEMP_BED) " H" STRINGIFY(PREHEAT_1_TEMP_HOTEND) " P"));
-      MENU_ITEM(gcode, MSG_UBL_VALIDATE_MESH_M2, PSTR("G28\nG26 C B" STRINGIFY(PREHEAT_2_TEMP_BED) " H" STRINGIFY(PREHEAT_2_TEMP_HOTEND) " P"));
-    #else
-      MENU_ITEM(gcode, MSG_UBL_VALIDATE_MESH_M1, PSTR("G28\nG26 C B0 H" STRINGIFY(PREHEAT_1_TEMP_HOTEND) " P"));
-      MENU_ITEM(gcode, MSG_UBL_VALIDATE_MESH_M2, PSTR("G28\nG26 C B0 H" STRINGIFY(PREHEAT_2_TEMP_HOTEND) " P"));
-    #endif
-    MENU_ITEM(function, MSG_UBL_VALIDATE_CUSTOM_MESH, _lcd_ubl_validate_custom_mesh);
-    MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
-    END_MENU();
-  }
-
-  /**
-   * UBL Grid Leveling Command
-   */
-  void _lcd_ubl_grid_level_cmd() {
-    char UBL_LCD_GCODE[10];
-    sprintf_P(UBL_LCD_GCODE, PSTR("G29 J%i"), side_points);
-    lcd_enqueue_command(UBL_LCD_GCODE);
-  }
-
-  /**
-   * UBL Grid Leveling submenu
-   *
-   * << UBL Tools
-   *    Side points: ---
-   *    Level Mesh
-   */
-  void _lcd_ubl_grid_level() {
-    START_MENU();
-    MENU_BACK(MSG_UBL_TOOLS);
-    MENU_ITEM_EDIT(int3, MSG_UBL_SIDE_POINTS, &side_points, 2, 6);
-    MENU_ITEM(function, MSG_UBL_MESH_LEVEL, _lcd_ubl_grid_level_cmd);
-    END_MENU();
-  }
-
-  /**
-   * UBL Mesh Leveling submenu
-   *
-   * << UBL Tools
-   *    3-Point Mesh Leveling
-   *  - Grid Mesh Leveling >>
-   * << Info Screen
-   */
-  void _lcd_ubl_mesh_leveling() {
-    START_MENU();
-    MENU_BACK(MSG_UBL_TOOLS);
-    MENU_ITEM(gcode, MSG_UBL_3POINT_MESH_LEVELING, PSTR("G29 J0"));
-    MENU_ITEM(submenu, MSG_UBL_GRID_MESH_LEVELING, _lcd_ubl_grid_level);
-    MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
-    END_MENU();
-  }
-
-  /**
-   * UBL Fill-in Amount Mesh Command
-   */
-  void _lcd_ubl_fillin_amount_cmd() {
-    char UBL_LCD_GCODE[16];
-    sprintf_P(UBL_LCD_GCODE, PSTR("G29 P3 R C.%i"), ubl_fillin_amount);
-    lcd_enqueue_command(UBL_LCD_GCODE);
-  }
-
-  /**
-   * UBL Fill-in Mesh submenu
-   *
-   * << Build Mesh
-   *    Fill-in Amount: ---
-   *    Fill-in Mesh
-   *    Smart Fill-in
-   *    Manual Fill-in
-   * << Info Screen
-   */
-  void _menu_ubl_fillin() {
-    START_MENU();
-    MENU_BACK(MSG_UBL_BUILD_MESH_MENU);
-    MENU_ITEM_EDIT_CALLBACK(int3, MSG_UBL_FILLIN_AMOUNT, &ubl_fillin_amount, 0, 9, _lcd_ubl_fillin_amount_cmd);
-    MENU_ITEM(gcode, MSG_UBL_SMART_FILLIN, PSTR("G29 P3 T0"));
-    MENU_ITEM(gcode, MSG_UBL_MANUAL_FILLIN, PSTR("G29 P2 B T0"));
-    MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
-    END_MENU();
-  }
-
-  void _lcd_ubl_invalidate() {
-    ubl.invalidate();
-    SERIAL_PROTOCOLLNPGM("Mesh invalidated.");
-  }
-
-  /**
-   * UBL Build Mesh submenu
-   *
-   * << UBL Tools
-   *    Build Mesh with Material 1
-   *    Build Mesh with Material 2
-   *  - Build Custom Mesh >>
-   *    Build Cold Mesh
-   *  - Fill-in Mesh >>
-   *    Continue Bed Mesh
-   *    Invalidate All
-   *    Invalidate Closest
-   * << Info Screen
-   */
-  void _lcd_ubl_build_mesh() {
-    START_MENU();
-    MENU_BACK(MSG_UBL_TOOLS);
-    #if HAS_HEATED_BED
-      MENU_ITEM(gcode, MSG_UBL_BUILD_MESH_M1, PSTR(
-        "G28\n"
-        "M190 S" STRINGIFY(PREHEAT_1_TEMP_BED) "\n"
-        "M109 S" STRINGIFY(PREHEAT_1_TEMP_HOTEND) "\n"
-        "G29 P1\n"
-        "M104 S0\n"
-        "M140 S0"
-      ));
-      MENU_ITEM(gcode, MSG_UBL_BUILD_MESH_M2, PSTR(
-        "G28\n"
-        "M190 S" STRINGIFY(PREHEAT_2_TEMP_BED) "\n"
-        "M109 S" STRINGIFY(PREHEAT_2_TEMP_HOTEND) "\n"
-        "G29 P1\n"
-        "M104 S0\n"
-        "M140 S0"
-      ));
-    #else
-      MENU_ITEM(gcode, MSG_UBL_BUILD_MESH_M1, PSTR(
-        "G28\n"
-        "M109 S" STRINGIFY(PREHEAT_1_TEMP_HOTEND) "\n"
-        "G29 P1\n"
-        "M104 S0"
-      ));
-      MENU_ITEM(gcode, MSG_UBL_BUILD_MESH_M2, PSTR(
-        "G28\n"
-        "M109 S" STRINGIFY(PREHEAT_2_TEMP_HOTEND) "\n"
-        "G29 P1\n"
-        "M104 S0"
-      ));
-    #endif
-    MENU_ITEM(submenu, MSG_UBL_BUILD_CUSTOM_MESH, _lcd_ubl_custom_mesh);
-    MENU_ITEM(gcode, MSG_UBL_BUILD_COLD_MESH, PSTR("G28\nG29 P1"));
-    MENU_ITEM(submenu, MSG_UBL_FILLIN_MESH, _menu_ubl_fillin);
-    MENU_ITEM(gcode, MSG_UBL_CONTINUE_MESH, PSTR("G29 P1 C"));
-    MENU_ITEM(function, MSG_UBL_INVALIDATE_ALL, _lcd_ubl_invalidate);
-    MENU_ITEM(gcode, MSG_UBL_INVALIDATE_CLOSEST, PSTR("G29 I"));
-    MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
-    END_MENU();
-  }
-
-  /**
-   * UBL Load Mesh Command
-   */
-  void _lcd_ubl_load_mesh_cmd() {
-    char UBL_LCD_GCODE[25];
-    sprintf_P(UBL_LCD_GCODE, PSTR("G29 L%i"), ubl_storage_slot);
-    lcd_enqueue_command(UBL_LCD_GCODE);
-    sprintf_P(UBL_LCD_GCODE, PSTR("M117 " MSG_MESH_LOADED), ubl_storage_slot);
-    lcd_enqueue_command(UBL_LCD_GCODE);
-  }
-
-  /**
-   * UBL Save Mesh Command
-   */
-  void _lcd_ubl_save_mesh_cmd() {
-    char UBL_LCD_GCODE[25];
-    sprintf_P(UBL_LCD_GCODE, PSTR("G29 S%i"), ubl_storage_slot);
-    lcd_enqueue_command(UBL_LCD_GCODE);
-    sprintf_P(UBL_LCD_GCODE, PSTR("M117 " MSG_MESH_SAVED), ubl_storage_slot);
-    lcd_enqueue_command(UBL_LCD_GCODE);
-  }
-
-  /**
-   * UBL Mesh Storage submenu
-   *
-   * << Unified Bed Leveling
-   *    Memory Slot: ---
-   *    Load Bed Mesh
-   *    Save Bed Mesh
-   */
-  void _lcd_ubl_storage_mesh() {
-    int16_t a = settings.calc_num_meshes();
-    START_MENU();
-    MENU_BACK(MSG_UBL_LEVEL_BED);
-    if (!WITHIN(ubl_storage_slot, 0, a - 1)) {
-      STATIC_ITEM(MSG_NO_STORAGE);
-    }
-    else {
-      MENU_ITEM_EDIT(int3, MSG_UBL_STORAGE_SLOT, &ubl_storage_slot, 0, a - 1);
-      MENU_ITEM(function, MSG_UBL_LOAD_MESH, _lcd_ubl_load_mesh_cmd);
-      MENU_ITEM(function, MSG_UBL_SAVE_MESH, _lcd_ubl_save_mesh_cmd);
-    }
-    END_MENU();
-  }
-
-  /**
-   * UBL LCD "radar" map homing
-   */
-  void _lcd_ubl_output_map_lcd();
-
-  void _lcd_ubl_map_homing() {
-    defer_return_to_status = true;
-    _lcd_draw_homing();
-    if (all_axes_homed()) {
-      ubl.lcd_map_control = true; // Return to the map screen
-      lcd_goto_screen(_lcd_ubl_output_map_lcd);
-    }
-  }
-
-  /**
-   * UBL LCD "radar" map point editing
-   */
-  void _lcd_ubl_map_lcd_edit_cmd() {
-    char UBL_LCD_GCODE[50], str[10], str2[10];
-    dtostrf(pgm_read_float(&ubl._mesh_index_to_xpos[x_plot]), 0, 2, str);
-    dtostrf(pgm_read_float(&ubl._mesh_index_to_ypos[y_plot]), 0, 2, str2);
-    snprintf_P(UBL_LCD_GCODE, sizeof(UBL_LCD_GCODE), PSTR("G29 P4 X%s Y%s R%i"), str, str2, n_edit_pts);
-    lcd_enqueue_command(UBL_LCD_GCODE);
-  }
-
-  /**
-   * UBL LCD Map Movement
-   */
-  void ubl_map_move_to_xy() {
-    current_position[X_AXIS] = pgm_read_float(&ubl._mesh_index_to_xpos[x_plot]);
-    current_position[Y_AXIS] = pgm_read_float(&ubl._mesh_index_to_ypos[y_plot]);
-    planner.buffer_line(current_position, MMM_TO_MMS(XY_PROBE_SPEED), active_extruder);
-  }
-
-  /**
-   * UBL LCD "radar" map
-   */
-  void set_current_from_steppers_for_axis(const AxisEnum axis);
-  void sync_plan_position();
-
-  void _lcd_do_nothing() {}
-  void _lcd_hard_stop() {
-    const screenFunc_t old_screen = currentScreen;
-    currentScreen = _lcd_do_nothing;
-    planner.quick_stop();
-    currentScreen = old_screen;
-    set_current_from_steppers_for_axis(ALL_AXES);
-    sync_plan_position();
-  }
-
-  void _lcd_ubl_output_map_lcd() {
-    static int16_t step_scaler = 0;
-
-    if (use_click()) return _lcd_ubl_map_lcd_edit_cmd();
-    ENCODER_DIRECTION_NORMAL();
-
-    if (encoderPosition) {
-      step_scaler += (int32_t)encoderPosition;
-      x_plot += step_scaler / (ENCODER_STEPS_PER_MENU_ITEM);
-      if (ABS(step_scaler) >= ENCODER_STEPS_PER_MENU_ITEM) step_scaler = 0;
-      encoderPosition = 0;
-      lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
-    }
-
-    // Encoder to the right (++)
-    if (x_plot >= GRID_MAX_POINTS_X) { x_plot = 0; y_plot++; }
-    if (y_plot >= GRID_MAX_POINTS_Y) y_plot = 0;
-
-    // Encoder to the left (--)
-    if (x_plot <= GRID_MAX_POINTS_X - (GRID_MAX_POINTS_X + 1)) { x_plot = GRID_MAX_POINTS_X - 1; y_plot--; }
-    if (y_plot <= GRID_MAX_POINTS_Y - (GRID_MAX_POINTS_Y + 1)) y_plot = GRID_MAX_POINTS_Y - 1;
-
-    // Prevent underrun/overrun of plot numbers
-    x_plot = constrain(x_plot, GRID_MAX_POINTS_X - (GRID_MAX_POINTS_X + 1), GRID_MAX_POINTS_X + 1);
-    y_plot = constrain(y_plot, GRID_MAX_POINTS_Y - (GRID_MAX_POINTS_Y + 1), GRID_MAX_POINTS_Y + 1);
-
-    // Determine number of points to edit
-    #if IS_KINEMATIC
-      n_edit_pts = 9; //TODO: Delta accessible edit points
-    #else
-      const bool xc = WITHIN(x_plot, 1, GRID_MAX_POINTS_X - 2),
-                 yc = WITHIN(y_plot, 1, GRID_MAX_POINTS_Y - 2);
-      n_edit_pts = yc ? (xc ? 9 : 6) : (xc ? 6 : 4); // Corners
-    #endif
-
-    if (lcdDrawUpdate) {
-      lcd_implementation_ubl_plot(x_plot, y_plot);
-
-      if (planner.movesplanned()) // If the nozzle is already moving, cancel the move.
-        _lcd_hard_stop();
-
-      ubl_map_move_to_xy();       // Move to new location
-    }
-  }
-
-  /**
-   * UBL Homing before LCD map
-   */
-  void _lcd_ubl_output_map_lcd_cmd() {
-    if (!all_axes_known()) {
-      axis_homed = 0;
-      enqueue_and_echo_commands_P(PSTR("G28"));
-    }
-    lcd_goto_screen(_lcd_ubl_map_homing);
-  }
-
-  /**
-   * UBL Output map submenu
-   *
-   * << Unified Bed Leveling
-   *  Output for Host
-   *  Output for CSV
-   *  Off Printer Backup
-   *  Output Mesh Map
-   */
-  void _lcd_ubl_output_map() {
-    START_MENU();
-    MENU_BACK(MSG_UBL_LEVEL_BED);
-    MENU_ITEM(gcode, MSG_UBL_OUTPUT_MAP_HOST, PSTR("G29 T0"));
-    MENU_ITEM(gcode, MSG_UBL_OUTPUT_MAP_CSV, PSTR("G29 T1"));
-    MENU_ITEM(gcode, MSG_UBL_OUTPUT_MAP_BACKUP, PSTR("G29 S-1"));
-    MENU_ITEM(function, MSG_UBL_OUTPUT_MAP, _lcd_ubl_output_map_lcd_cmd);
-    END_MENU();
-  }
-
-  /**
-   * UBL Tools submenu
-   *
-   * << Unified Bed Leveling
-   *  - Build Mesh >>
-   *  - Validate Mesh >>
-   *  - Edit Mesh >>
-   *  - Mesh Leveling >>
-   */
-  void _menu_ubl_tools() {
-    START_MENU();
-    MENU_BACK(MSG_UBL_LEVEL_BED);
-    MENU_ITEM(submenu, MSG_UBL_BUILD_MESH_MENU, _lcd_ubl_build_mesh);
-    MENU_ITEM(gcode, MSG_UBL_MANUAL_MESH, PSTR("G29 I999\nG29 P2 B T0"));
-    MENU_ITEM(submenu, MSG_UBL_VALIDATE_MESH_MENU, _lcd_ubl_validate_mesh);
-    MENU_ITEM(submenu, MSG_UBL_EDIT_MESH_MENU, _lcd_ubl_edit_mesh);
-    MENU_ITEM(submenu, MSG_UBL_MESH_LEVELING, _lcd_ubl_mesh_leveling);
-    END_MENU();
-  }
-
-  /**
-   * UBL Step-By-Step submenu
-   *
-   * << Unified Bed Leveling
-   *    1 Build Cold Mesh
-   *    2 Smart Fill-in
-   *  - 3 Validate Mesh >>
-   *    4 Fine Tune All
-   *  - 5 Validate Mesh >>
-   *    6 Fine Tune All
-   *    7 Save Bed Mesh
-   */
-  void _lcd_ubl_step_by_step() {
-    START_MENU();
-    MENU_BACK(MSG_UBL_LEVEL_BED);
-    MENU_ITEM(gcode, "1 " MSG_UBL_BUILD_COLD_MESH, PSTR("G28\nG29 P1"));
-    MENU_ITEM(gcode, "2 " MSG_UBL_SMART_FILLIN, PSTR("G29 P3 T0"));
-    MENU_ITEM(submenu, "3 " MSG_UBL_VALIDATE_MESH_MENU, _lcd_ubl_validate_mesh);
-    MENU_ITEM(gcode, "4 " MSG_UBL_FINE_TUNE_ALL, PSTR("G29 P4 R999 T"));
-    MENU_ITEM(submenu, "5 " MSG_UBL_VALIDATE_MESH_MENU, _lcd_ubl_validate_mesh);
-    MENU_ITEM(gcode, "6 " MSG_UBL_FINE_TUNE_ALL, PSTR("G29 P4 R999 T"));
-    MENU_ITEM(function, "7 " MSG_UBL_SAVE_MESH, _lcd_ubl_save_mesh_cmd);
-    END_MENU();
-  }
-
-  /**
-   * UBL System submenu
-   *
-   * << Motion
-   *  - Manually Build Mesh >>
-   *  - Activate UBL >>
-   *  - Deactivate UBL >>
-   *  - Step-By-Step UBL >>
-   *  - Mesh Storage >>
-   *  - Output Map >>
-   *  - UBL Tools >>
-   *  - Output UBL Info >>
-   */
-
-  void _lcd_ubl_level_bed() {
-    START_MENU();
-    MENU_BACK(MSG_MOTION);
-    MENU_ITEM(gcode, MSG_UBL_ACTIVATE_MESH, PSTR("G29 A"));
-    MENU_ITEM(gcode, MSG_UBL_DEACTIVATE_MESH, PSTR("G29 D"));
-    MENU_ITEM(submenu, MSG_UBL_STEP_BY_STEP_MENU, _lcd_ubl_step_by_step);
-    MENU_ITEM(function, MSG_UBL_MESH_EDIT, _lcd_ubl_output_map_lcd_cmd);
-    MENU_ITEM(submenu, MSG_UBL_STORAGE_MESH_MENU, _lcd_ubl_storage_mesh);
-    MENU_ITEM(submenu, MSG_UBL_OUTPUT_MAP, _lcd_ubl_output_map);
-    MENU_ITEM(submenu, MSG_UBL_TOOLS, _menu_ubl_tools);
-    MENU_ITEM(gcode, MSG_UBL_INFO_UBL, PSTR("G29 W"));
-    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float3, MSG_Z_FADE_HEIGHT, &lcd_z_fade_height, 0, 100, _lcd_set_z_fade_height);
-    #endif
-    END_MENU();
-  }
-
-#endif // AUTO_BED_LEVELING_UBL
+#endif // LCD_BED_LEVELING && (PROBE_MANUALLY || MESH_BED_LEVELING)
 
 #if ENABLED(LCD_BED_LEVELING) || (HAS_LEVELING && DISABLED(SLIM_LCD_MENUS))
   void _lcd_toggle_bed_leveling() { set_bed_leveling_enabled(!planner.leveling_active); }

commit a489c9fa52261cd5836771f0f0c5f3dff20f696d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Oct 27 16:45:37 2018 -0500

    Move Motion Menu to its own file

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 828e0f3209..a58f006aa5 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -282,8 +282,6 @@ void menu_action_setting_edit_callback_bool(PGM_P pstr, bool* ptr, screenFunc_t
 
 bool printer_busy() { return planner.movesplanned() || IS_SD_PRINTING(); }
 
-float move_menu_scale;
-
 #if HAS_CHARACTER_LCD && (ENABLED(LCD_PROGRESS_BAR) || ENABLED(LCD_PROGRESS_BAR_TEST) || ENABLED(AUTO_BED_LEVELING_UBL))
   void lcd_set_custom_characters(
     #if ENABLED(LCD_PROGRESS_BAR) || ENABLED(SHOW_BOOTSCREEN)
@@ -364,22 +362,6 @@ void lcd_goto_screen(screenFunc_t screen, const uint32_t encoder/*=0*/) {
 ///////////// Manual Movement //////////////
 ////////////////////////////////////////////
 
-extern millis_t manual_move_start_time;
-extern int8_t manual_move_axis;
-
-#if IS_KINEMATIC
-  extern float manual_move_offset;
-#endif
-
-#if ENABLED(DUAL_X_CARRIAGE) || E_MANUAL > 1
-  extern int8_t manual_move_e_index;
-#endif
-
-#if ENABLED(MANUAL_E_MOVES_RELATIVE)
-  float manual_move_e_origin = 0;
-#endif
-
-
 //
 // Display the synchronize screen until moves are
 // finished, and don't return to the caller until
@@ -1261,8 +1243,6 @@ void _lcd_draw_homing() {
 
 #elif ENABLED(AUTO_BED_LEVELING_UBL)
 
-  void _lcd_ubl_level_bed();
-
   static int16_t ubl_storage_slot = 0,
              custom_hotend_temp = 190,
              side_points = 3,
@@ -1856,86 +1836,6 @@ void _lcd_draw_homing() {
 
 #endif // LCD_BED_LEVELING
 
-/**
- *
- * "Movement" submenu
- *
- */
-
-void menu_movement() {
-  START_MENU();
-
-  //
-  // ^ Main
-  //
-  MENU_BACK(MSG_MAIN);
-
-  //
-  // Move Axis
-  //
-  #if ENABLED(DELTA)
-    if (all_axes_homed())
-  #endif
-      MENU_ITEM(submenu, MSG_MOVE_AXIS, menu_move);
-
-  //
-  // Auto Home
-  //
-  MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
-  #if ENABLED(INDIVIDUAL_AXIS_HOMING_MENU)
-    MENU_ITEM(gcode, MSG_AUTO_HOME_X, PSTR("G28 X"));
-    MENU_ITEM(gcode, MSG_AUTO_HOME_Y, PSTR("G28 Y"));
-    MENU_ITEM(gcode, MSG_AUTO_HOME_Z, PSTR("G28 Z"));
-  #endif
-
-  //
-  // TMC Z Calibration
-  //
-  #if ENABLED(TMC_Z_CALIBRATION)
-    MENU_ITEM(gcode, MSG_TMC_Z_CALIBRATION, PSTR("G28\nM915"));
-  #endif
-
-  //
-  // Level Bed
-  //
-  #if ENABLED(AUTO_BED_LEVELING_UBL)
-
-    MENU_ITEM(submenu, MSG_UBL_LEVEL_BED, _lcd_ubl_level_bed);
-
-  #elif ENABLED(LCD_BED_LEVELING)
-
-    #if ENABLED(PROBE_MANUALLY)
-      if (!g29_in_progress)
-    #endif
-        MENU_ITEM(submenu, MSG_BED_LEVELING, menu_bed_leveling);
-
-  #elif HAS_LEVELING && DISABLED(SLIM_LCD_MENUS)
-
-    #if DISABLED(PROBE_MANUALLY)
-      MENU_ITEM(gcode, MSG_LEVEL_BED, PSTR("G28\nG29"));
-    #endif
-    if (leveling_is_valid()) {
-      bool new_level_state = planner.leveling_active;
-      MENU_ITEM_EDIT_CALLBACK(bool, MSG_BED_LEVELING, &new_level_state, _lcd_toggle_bed_leveling);
-    }
-    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float3, MSG_Z_FADE_HEIGHT, &lcd_z_fade_height, 0, 100, _lcd_set_z_fade_height);
-    #endif
-
-  #endif
-
-  #if ENABLED(LEVEL_BED_CORNERS) && DISABLED(LCD_BED_LEVELING)
-      MENU_ITEM(function, MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
-  #endif
-
-  //
-  // Disable Steppers
-  //
-  MENU_ITEM(gcode, MSG_DISABLE_STEPPERS, PSTR("M84"));
-
-  END_MENU();
-}
-
 #if ENABLED(DELTA_CALIBRATION_MENU) || ENABLED(DELTA_AUTO_CALIBRATION)
 
   void _man_probe_pt(const float &rx, const float &ry) {
@@ -2034,383 +1934,6 @@ void menu_movement() {
 
 #endif // DELTA_CALIBRATION_MENU || DELTA_AUTO_CALIBRATION
 
-/**
- * Set a flag that lcd_update() should start a move
- * to "current_position" after a short delay.
- */
-inline void manual_move_to_current(AxisEnum axis
-  #if E_MANUAL > 1
-    , const int8_t eindex=-1
-  #endif
-) {
-  #if ENABLED(DUAL_X_CARRIAGE) || E_MANUAL > 1
-    #if E_MANUAL > 1
-      if (axis == E_AXIS)
-    #endif
-        manual_move_e_index = eindex >= 0 ? eindex : active_extruder;
-  #endif
-  manual_move_start_time = millis() + (move_menu_scale < 0.99f ? 0UL : 250UL); // delay for bigger moves
-  manual_move_axis = (int8_t)axis;
-}
-
-/**
- *
- * "Motion" > "Move Axis" submenu
- *
- */
-
-void _lcd_move_xyz(PGM_P name, AxisEnum axis) {
-  if (use_click()) { return lcd_goto_previous_menu_no_defer(); }
-  ENCODER_DIRECTION_NORMAL();
-  if (encoderPosition && !processing_manual_move) {
-
-    // Start with no limits to movement
-    float min = current_position[axis] - 1000,
-          max = current_position[axis] + 1000;
-
-    // Limit to software endstops, if enabled
-    #if ENABLED(MIN_SOFTWARE_ENDSTOPS) || ENABLED(MAX_SOFTWARE_ENDSTOPS)
-      if (soft_endstops_enabled) switch (axis) {
-        case X_AXIS:
-          #if ENABLED(MIN_SOFTWARE_ENDSTOP_X)
-            min = soft_endstop_min[X_AXIS];
-          #endif
-          #if ENABLED(MAX_SOFTWARE_ENDSTOP_X)
-            max = soft_endstop_max[X_AXIS];
-          #endif
-          break;
-        case Y_AXIS:
-          #if ENABLED(MIN_SOFTWARE_ENDSTOP_Y)
-            min = soft_endstop_min[Y_AXIS];
-          #endif
-          #if ENABLED(MAX_SOFTWARE_ENDSTOP_Y)
-            max = soft_endstop_max[Y_AXIS];
-          #endif
-          break;
-        case Z_AXIS:
-          #if ENABLED(MIN_SOFTWARE_ENDSTOP_Z)
-            min = soft_endstop_min[Z_AXIS];
-          #endif
-          #if ENABLED(MAX_SOFTWARE_ENDSTOP_Z)
-            max = soft_endstop_max[Z_AXIS];
-          #endif
-        default: break;
-      }
-    #endif // MIN_SOFTWARE_ENDSTOPS || MAX_SOFTWARE_ENDSTOPS
-
-    // Delta limits XY based on the current offset from center
-    // This assumes the center is 0,0
-    #if ENABLED(DELTA)
-      if (axis != Z_AXIS) {
-        max = SQRT(sq((float)(DELTA_PRINTABLE_RADIUS)) - sq(current_position[Y_AXIS - axis])); // (Y_AXIS - axis) == the other axis
-        min = -max;
-      }
-    #endif
-
-    // Get the new position
-    const float diff = float((int32_t)encoderPosition) * move_menu_scale;
-    #if IS_KINEMATIC
-      manual_move_offset += diff;
-      if ((int32_t)encoderPosition < 0)
-        NOLESS(manual_move_offset, min - current_position[axis]);
-      else
-        NOMORE(manual_move_offset, max - current_position[axis]);
-    #else
-      current_position[axis] += diff;
-      if ((int32_t)encoderPosition < 0)
-        NOLESS(current_position[axis], min);
-      else
-        NOMORE(current_position[axis], max);
-    #endif
-
-    manual_move_to_current(axis);
-    lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
-  }
-  encoderPosition = 0;
-  if (lcdDrawUpdate) {
-    const float pos = NATIVE_TO_LOGICAL(processing_manual_move ? destination[axis] : current_position[axis]
-      #if IS_KINEMATIC
-        + manual_move_offset
-      #endif
-    , axis);
-    lcd_implementation_drawedit(name, move_menu_scale >= 0.1f ? ftostr41sign(pos) : ftostr43sign(pos));
-  }
-}
-void lcd_move_x() { _lcd_move_xyz(PSTR(MSG_MOVE_X), X_AXIS); }
-void lcd_move_y() { _lcd_move_xyz(PSTR(MSG_MOVE_Y), Y_AXIS); }
-void lcd_move_z() { _lcd_move_xyz(PSTR(MSG_MOVE_Z), Z_AXIS); }
-void _lcd_move_e(
-  #if E_MANUAL > 1
-    const int8_t eindex=-1
-  #endif
-) {
-  if (use_click()) { return lcd_goto_previous_menu_no_defer(); }
-  ENCODER_DIRECTION_NORMAL();
-  if (encoderPosition) {
-    if (!processing_manual_move) {
-      const float diff = float((int32_t)encoderPosition) * move_menu_scale;
-      #if IS_KINEMATIC
-        manual_move_offset += diff;
-      #else
-        current_position[E_AXIS] += diff;
-      #endif
-      manual_move_to_current(E_AXIS
-        #if E_MANUAL > 1
-          , eindex
-        #endif
-      );
-      lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
-    }
-    encoderPosition = 0;
-  }
-  if (lcdDrawUpdate) {
-    PGM_P pos_label;
-    #if E_MANUAL == 1
-      pos_label = PSTR(MSG_MOVE_E);
-    #else
-      switch (eindex) {
-        default: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E1); break;
-        case 1: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E2); break;
-        #if E_MANUAL > 2
-          case 2: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E3); break;
-          #if E_MANUAL > 3
-            case 3: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E4); break;
-            #if E_MANUAL > 4
-              case 4: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E5); break;
-              #if E_MANUAL > 5
-                case 5: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E6); break;
-              #endif // E_MANUAL > 5
-            #endif // E_MANUAL > 4
-          #endif // E_MANUAL > 3
-        #endif // E_MANUAL > 2
-      }
-    #endif // E_MANUAL > 1
-
-    lcd_implementation_drawedit(pos_label, ftostr41sign(current_position[E_AXIS]
-      #if IS_KINEMATIC
-        + manual_move_offset
-      #endif
-      #if ENABLED(MANUAL_E_MOVES_RELATIVE)
-        - manual_move_e_origin
-      #endif
-    ));
-  }
-}
-
-void lcd_move_e() { _lcd_move_e(); }
-#if E_MANUAL > 1
-  void lcd_move_e0() { _lcd_move_e(0); }
-  void lcd_move_e1() { _lcd_move_e(1); }
-  #if E_MANUAL > 2
-    void lcd_move_e2() { _lcd_move_e(2); }
-    #if E_MANUAL > 3
-      void lcd_move_e3() { _lcd_move_e(3); }
-      #if E_MANUAL > 4
-        void lcd_move_e4() { _lcd_move_e(4); }
-        #if E_MANUAL > 5
-          void lcd_move_e5() { _lcd_move_e(5); }
-        #endif // E_MANUAL > 5
-      #endif // E_MANUAL > 4
-    #endif // E_MANUAL > 3
-  #endif // E_MANUAL > 2
-#endif // E_MANUAL > 1
-
-/**
- *
- * "Motion" > "Move Xmm" > "Move XYZ" submenu
- *
- */
-
-screenFunc_t _manual_move_func_ptr;
-
-void _goto_manual_move(const float scale) {
-  defer_return_to_status = true;
-  move_menu_scale = scale;
-  lcd_goto_screen(_manual_move_func_ptr);
-}
-void menu_move_10mm() { _goto_manual_move(10); }
-void menu_move_1mm()  { _goto_manual_move( 1); }
-void menu_move_01mm() { _goto_manual_move( 0.1f); }
-
-void _menu_move_distance(const AxisEnum axis, const screenFunc_t func, const int8_t eindex=-1) {
-  _manual_move_func_ptr = func;
-  START_MENU();
-  if (LCD_HEIGHT >= 4) {
-    switch (axis) {
-      case X_AXIS:
-        STATIC_ITEM(MSG_MOVE_X, true, true); break;
-      case Y_AXIS:
-        STATIC_ITEM(MSG_MOVE_Y, true, true); break;
-      case Z_AXIS:
-        STATIC_ITEM(MSG_MOVE_Z, true, true); break;
-      default:
-        #if ENABLED(MANUAL_E_MOVES_RELATIVE)
-          manual_move_e_origin = current_position[E_AXIS];
-        #endif
-        STATIC_ITEM(MSG_MOVE_E, true, true);
-        break;
-    }
-  }
-  #if ENABLED(PREVENT_COLD_EXTRUSION)
-    if (axis == E_AXIS && thermalManager.tooColdToExtrude(eindex >= 0 ? eindex : active_extruder))
-      MENU_BACK(MSG_HOTEND_TOO_COLD);
-    else
-  #endif
-  {
-    MENU_BACK(MSG_MOVE_AXIS);
-    MENU_ITEM(submenu, MSG_MOVE_10MM, menu_move_10mm);
-    MENU_ITEM(submenu, MSG_MOVE_1MM, menu_move_1mm);
-    MENU_ITEM(submenu, MSG_MOVE_01MM, menu_move_01mm);
-  }
-  END_MENU();
-}
-void lcd_move_get_x_amount()        { _menu_move_distance(X_AXIS, lcd_move_x); }
-void lcd_move_get_y_amount()        { _menu_move_distance(Y_AXIS, lcd_move_y); }
-void lcd_move_get_z_amount()        { _menu_move_distance(Z_AXIS, lcd_move_z); }
-void lcd_move_get_e_amount()        { _menu_move_distance(E_AXIS, lcd_move_e, -1); }
-#if E_MANUAL > 1
-  void lcd_move_get_e0_amount()     { _menu_move_distance(E_AXIS, lcd_move_e0, 0); }
-  void lcd_move_get_e1_amount()     { _menu_move_distance(E_AXIS, lcd_move_e1, 1); }
-  #if E_MANUAL > 2
-    void lcd_move_get_e2_amount()   { _menu_move_distance(E_AXIS, lcd_move_e2, 2); }
-    #if E_MANUAL > 3
-      void lcd_move_get_e3_amount() { _menu_move_distance(E_AXIS, lcd_move_e3, 3); }
-      #if E_MANUAL > 4
-        void lcd_move_get_e4_amount() { _menu_move_distance(E_AXIS, lcd_move_e4, 4); }
-        #if E_MANUAL > 5
-          void lcd_move_get_e5_amount() { _menu_move_distance(E_AXIS, lcd_move_e5, 5); }
-        #endif // E_MANUAL > 5
-      #endif // E_MANUAL > 4
-    #endif // E_MANUAL > 3
-  #endif // E_MANUAL > 2
-#endif // E_MANUAL > 1
-
-/**
- *
- * "Motion" > "Move Axis" submenu
- *
- */
-
-#if ENABLED(DELTA)
-  void lcd_lower_z_to_clip_height() {
-    line_to_z(delta_clip_start_height);
-    lcd_synchronize();
-  }
-#endif
-
-void menu_move() {
-  START_MENU();
-  MENU_BACK(MSG_MOTION);
-
-  #if HAS_SOFTWARE_ENDSTOPS && ENABLED(SOFT_ENDSTOPS_MENU_ITEM)
-    MENU_ITEM_EDIT(bool, MSG_LCD_SOFT_ENDSTOPS, &soft_endstops_enabled);
-  #endif
-
-  if (
-    #if IS_KINEMATIC || ENABLED(NO_MOTION_BEFORE_HOMING)
-      all_axes_homed()
-    #else
-      true
-    #endif
-  ) {
-    if (
-      #if ENABLED(DELTA)
-        current_position[Z_AXIS] <= delta_clip_start_height
-      #else
-        true
-      #endif
-    ) {
-      MENU_ITEM(submenu, MSG_MOVE_X, lcd_move_get_x_amount);
-      MENU_ITEM(submenu, MSG_MOVE_Y, lcd_move_get_y_amount);
-    }
-    #if ENABLED(DELTA)
-      else
-        MENU_ITEM(function, MSG_FREE_XY, lcd_lower_z_to_clip_height);
-    #endif
-
-    MENU_ITEM(submenu, MSG_MOVE_Z, lcd_move_get_z_amount);
-  }
-  else
-    MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
-
-  #if ENABLED(SWITCHING_EXTRUDER) || ENABLED(SWITCHING_NOZZLE)
-
-    #if EXTRUDERS == 6
-      switch (active_extruder) {
-        case 0: MENU_ITEM(gcode, MSG_SELECT " " MSG_E2, PSTR("T1")); break;
-        case 1: MENU_ITEM(gcode, MSG_SELECT " " MSG_E1, PSTR("T0")); break;
-        case 2: MENU_ITEM(gcode, MSG_SELECT " " MSG_E4, PSTR("T3")); break;
-        case 3: MENU_ITEM(gcode, MSG_SELECT " " MSG_E3, PSTR("T2")); break;
-        case 4: MENU_ITEM(gcode, MSG_SELECT " " MSG_E6, PSTR("T5")); break;
-        case 5: MENU_ITEM(gcode, MSG_SELECT " " MSG_E5, PSTR("T4")); break;
-      }
-    #elif EXTRUDERS == 5 || EXTRUDERS == 4
-      switch (active_extruder) {
-        case 0: MENU_ITEM(gcode, MSG_SELECT " " MSG_E2, PSTR("T1")); break;
-        case 1: MENU_ITEM(gcode, MSG_SELECT " " MSG_E1, PSTR("T0")); break;
-        case 2: MENU_ITEM(gcode, MSG_SELECT " " MSG_E4, PSTR("T3")); break;
-        case 3: MENU_ITEM(gcode, MSG_SELECT " " MSG_E3, PSTR("T2")); break;
-      }
-    #elif EXTRUDERS == 3
-      if (active_extruder < 2) {
-        if (active_extruder)
-          MENU_ITEM(gcode, MSG_SELECT " " MSG_E1, PSTR("T0"));
-        else
-          MENU_ITEM(gcode, MSG_SELECT " " MSG_E2, PSTR("T1"));
-      }
-    #else
-      if (active_extruder)
-        MENU_ITEM(gcode, MSG_SELECT " " MSG_E1, PSTR("T0"));
-      else
-        MENU_ITEM(gcode, MSG_SELECT " " MSG_E2, PSTR("T1"));
-    #endif
-
-  #elif ENABLED(DUAL_X_CARRIAGE)
-
-    if (active_extruder)
-      MENU_ITEM(gcode, MSG_SELECT " " MSG_E1, PSTR("T0"));
-    else
-      MENU_ITEM(gcode, MSG_SELECT " " MSG_E2, PSTR("T1"));
-
-  #endif
-
-  #if ENABLED(SWITCHING_EXTRUDER) || ENABLED(SWITCHING_NOZZLE)
-
-    // Only the current...
-    MENU_ITEM(submenu, MSG_MOVE_E, lcd_move_get_e_amount);
-    // ...and the non-switching
-    #if E_MANUAL == 5
-      MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E5, lcd_move_get_e4_amount);
-    #elif E_MANUAL == 3
-      MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E3, lcd_move_get_e2_amount);
-    #endif
-
-  #else
-
-    // Independent extruders with one E-stepper per hotend
-    MENU_ITEM(submenu, MSG_MOVE_E, lcd_move_get_e_amount);
-    #if E_MANUAL > 1
-      MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E1, lcd_move_get_e0_amount);
-      MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E2, lcd_move_get_e1_amount);
-      #if E_MANUAL > 2
-        MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E3, lcd_move_get_e2_amount);
-        #if E_MANUAL > 3
-          MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E4, lcd_move_get_e3_amount);
-          #if E_MANUAL > 4
-            MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E5, lcd_move_get_e4_amount);
-            #if E_MANUAL > 5
-              MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E6, lcd_move_get_e5_amount);
-            #endif // E_MANUAL > 5
-          #endif // E_MANUAL > 4
-        #endif // E_MANUAL > 3
-      #endif // E_MANUAL > 2
-    #endif // E_MANUAL > 1
-
-  #endif
-
-  END_MENU();
-}
-
 /**
  *
  * "Temperature" submenu

commit 3a9ad9f2b1f56d14c6ff82a96e18319e64bd4016
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Oct 27 15:55:06 2018 -0500

    Move Configuration Menu to its own file

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index c139bf987a..828e0f3209 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -30,7 +30,6 @@
 #include "../../sd/cardreader.h"
 #include "../../module/temperature.h"
 #include "../../module/planner.h"
-#include "../../module/stepper.h"
 #include "../../module/motion.h"
 #include "../../module/probe.h"
 #include "../../module/printcounter.h"
@@ -66,10 +65,6 @@
   #include "../../feature/leds/leds.h"
 #endif
 
-#if ENABLED(FILAMENT_RUNOUT_SENSOR)
-  #include "../../feature/runout.h"
-#endif
-
 ////////////////////////////////////////////
 ///////////// Global Variables /////////////
 ////////////////////////////////////////////
@@ -256,13 +251,6 @@ void menu_action_setting_edit_callback_bool(PGM_P pstr, bool* ptr, screenFunc_t
 ///////////////// Menu Tree ////////////////
 ////////////////////////////////////////////
 
-void menu_advanced_settings();
-
-#if DISABLED(SLIM_LCD_MENUS)
-  void menu_preheat_material1_settings();
-  void menu_preheat_material2_settings();
-#endif
-
 #if DISABLED(NO_VOLUMETRICS) || ENABLED(ADVANCED_PAUSE_FEATURE)
   void menu_advanced_filament();
 #endif
@@ -283,22 +271,6 @@ void menu_advanced_settings();
   #endif
 #endif
 
-#if ENABLED(DAC_STEPPER_CURRENT)
-  void dac_driver_commit();
-  void dac_driver_getValues();
-  void menu_dac();
-  void lcd_dac_write_eeprom();
-#endif
-
-#if ENABLED(FWRETRACT)
-  #include "../../feature/fwretract.h"
-  void menu_config_retract();
-#endif
-
-#if ENABLED(DELTA_CALIBRATION_MENU) || ENABLED(DELTA_AUTO_CALIBRATION)
-  void menu_delta_calibrate();
-#endif
-
 #if ENABLED(MESH_BED_LEVELING) && ENABLED(LCD_BED_LEVELING)
   #include "../../feature/bedlevel/mbl/mesh_bed_leveling.h"
 #endif
@@ -558,127 +530,6 @@ void line_to_z(const float &z) {
 
 #endif // POWER_LOSS_RECOVERY
 
-#if EXTRUDERS > 1
-  void menu_tool_change() {
-    START_MENU();
-    MENU_BACK(MSG_MAIN);
-    #if ENABLED(SINGLENOZZLE)
-      MENU_ITEM_EDIT(float3, MSG_FILAMENT_SWAP_LENGTH, &toolchange_settings.swap_length, 0, 200);
-      MENU_MULTIPLIER_ITEM_EDIT(int4, MSG_SINGLENOZZLE_RETRACT_SPD, &toolchange_settings.retract_speed, 10, 5400);
-      MENU_MULTIPLIER_ITEM_EDIT(int4, MSG_SINGLENOZZLE_PRIME_SPD, &toolchange_settings.prime_speed, 10, 5400);
-    #endif
-    MENU_ITEM_EDIT(float3, MSG_TOOL_CHANGE_ZLIFT, &toolchange_settings.z_raise, 0, 10);
-    END_MENU();
-  }
-#endif
-
-#if ENABLED(MENU_ITEM_CASE_LIGHT)
-
-  #include "../../feature/caselight.h"
-
-  void menu_case_light() {
-    START_MENU();
-    MENU_BACK(MSG_MAIN);
-    MENU_ITEM_EDIT_CALLBACK(int8, MSG_CASE_LIGHT_BRIGHTNESS, &case_light_brightness, 0, 255, update_case_light, true);
-    MENU_ITEM_EDIT_CALLBACK(bool, MSG_CASE_LIGHT, (bool*)&case_light_on, update_case_light);
-    END_MENU();
-  }
-#endif // MENU_ITEM_CASE_LIGHT
-
-#if ENABLED(BLTOUCH)
-
-  /**
-   *
-   * "BLTouch" submenu
-   *
-   */
-  static void menu_bltouch() {
-    START_MENU();
-    MENU_BACK(MSG_MAIN);
-    MENU_ITEM(gcode, MSG_BLTOUCH_RESET, PSTR("M280 P" STRINGIFY(Z_PROBE_SERVO_NR) " S" STRINGIFY(BLTOUCH_RESET)));
-    MENU_ITEM(gcode, MSG_BLTOUCH_SELFTEST, PSTR("M280 P" STRINGIFY(Z_PROBE_SERVO_NR) " S" STRINGIFY(BLTOUCH_SELFTEST)));
-    MENU_ITEM(gcode, MSG_BLTOUCH_DEPLOY, PSTR("M280 P" STRINGIFY(Z_PROBE_SERVO_NR) " S" STRINGIFY(BLTOUCH_DEPLOY)));
-    MENU_ITEM(gcode, MSG_BLTOUCH_STOW, PSTR("M280 P" STRINGIFY(Z_PROBE_SERVO_NR) " S" STRINGIFY(BLTOUCH_STOW)));
-    END_MENU();
-  }
-
-#endif // BLTOUCH
-
-#if ENABLED(LCD_PROGRESS_BAR_TEST)
-
-  static void progress_bar_test() {
-    static int8_t bar_percent = 0;
-    if (use_click()) {
-      lcd_goto_previous_menu();
-      lcd_set_custom_characters(CHARSET_MENU);
-      return;
-    }
-    bar_percent += (int8_t)encoderPosition;
-    bar_percent = constrain(bar_percent, 0, 100);
-    encoderPosition = 0;
-    lcd_implementation_drawmenu_static(0, PSTR(MSG_PROGRESS_BAR_TEST), true, true);
-    lcd_moveto((LCD_WIDTH) / 2 - 2, LCD_HEIGHT - 2);
-    lcd_put_u8str(int(bar_percent)); lcd_put_wchar('%');
-    lcd_moveto(0, LCD_HEIGHT - 1); lcd_draw_progress_bar(bar_percent);
-  }
-
-  void _progress_bar_test() {
-    lcd_goto_screen(progress_bar_test);
-    lcd_set_custom_characters();
-  }
-
-#endif // LCD_PROGRESS_BAR_TEST
-
-#if HAS_DEBUG_MENU
-
-  void menu_debug() {
-    START_MENU();
-
-    MENU_BACK(MSG_MAIN);
-
-    #if ENABLED(LCD_PROGRESS_BAR_TEST)
-      MENU_ITEM(submenu, MSG_PROGRESS_BAR_TEST, _progress_bar_test);
-    #endif
-
-    END_MENU();
-  }
-
-#endif // HAS_DEBUG_MENU
-
-/**
- * IDEX submenu
- */
-#if ENABLED(DUAL_X_CARRIAGE)
-  static void _recalc_IDEX_settings() {
-    if (active_extruder) {                      // For the 2nd extruder re-home so the next tool-change gets the new offsets.
-      enqueue_and_echo_commands_P(PSTR("G28")); // In future, we can babystep the 2nd extruder (if active), making homing unnecessary.
-      active_extruder = 0;
-    }
-  }
-
-  static void menu_IDEX() {
-    START_MENU();
-    MENU_BACK(MSG_MAIN);
-
-    MENU_ITEM(gcode, MSG_IDEX_MODE_AUTOPARK,  PSTR("M605 S1\nG28 X\nG1 X100"));
-    const bool need_g28 = !(TEST(axis_known_position, Y_AXIS) && TEST(axis_known_position, Z_AXIS));
-    MENU_ITEM(gcode, MSG_IDEX_MODE_DUPLICATE, need_g28
-      ? PSTR("M605 S1\nT0\nG28\nM605 S2 X200\nG28 X\nG1 X100")                // If Y or Z is not homed, do a full G28 first
-      : PSTR("M605 S1\nT0\nM605 S2 X200\nG28 X\nG1 X100")
-    );
-    //MENU_ITEM(gcode, MSG_IDEX_MODE_SCALED_COPY, need_g28
-    //  ? PSTR("M605 S1\nT0\nG28\nM605 S2 X200\nG28 X\nG1 X100\nM605 S3 X200")  // If Y or Z is not homed, do a full G28 first
-    //  : PSTR("M605 S1\nT0\nM605 S2 X200\nG28 X\nG1 X100\nM605 S3 X200")
-    //);
-    MENU_ITEM(gcode, MSG_IDEX_MODE_FULL_CTRL, PSTR("M605 S0\nG28 X"));
-    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float52, MSG_IDEX_X_OFFSET , &hotend_offset[X_AXIS][1], MIN(X2_HOME_POS, X2_MAX_POS) - 25.0, MAX(X2_HOME_POS, X2_MAX_POS) + 25.0, _recalc_IDEX_settings);
-    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float52, MSG_IDEX_Y_OFFSET , &hotend_offset[Y_AXIS][1], -10.0, 10.0, _recalc_IDEX_settings);
-    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float52, MSG_IDEX_Z_OFFSET , &hotend_offset[Z_AXIS][1], -10.0, 10.0, _recalc_IDEX_settings);
-    MENU_ITEM(gcode, MSG_IDEX_SAVE_OFFSETS, PSTR("M500"));
-    END_MENU();
-  }
-#endif // DUAL_X_CARRIAGE
-
 #if ENABLED(CUSTOM_USER_MENUS)
 
   #ifdef USER_SCRIPT_DONE
@@ -883,55 +734,6 @@ void watch_temp_callback_bed() {
   #endif
 }
 
-/**
- *
- * "Driver current control" submenu items
- *
- */
-#if ENABLED(DAC_STEPPER_CURRENT)
-
-  #include "../../feature/dac/stepper_dac.h" //was dac_mcp4728.h MarlinMain uses stepper dac for the m-codes
-  uint8_t driverPercent[XYZE];
-
-  void dac_driver_getValues() { LOOP_XYZE(i) driverPercent[i] = dac_current_get_percent((AxisEnum)i); }
-
-  void dac_driver_commit() { dac_current_set_percents(driverPercent); }
-
-  void dac_driver_eeprom_write() { dac_commit_eeprom(); }
-
-  void menu_dac() {
-    dac_driver_getValues();
-    START_MENU();
-    MENU_BACK(MSG_CONTROL);
-    MENU_ITEM_EDIT_CALLBACK(int8, MSG_X " " MSG_DAC_PERCENT, &driverPercent[X_AXIS], 0, 100, dac_driver_commit);
-    MENU_ITEM_EDIT_CALLBACK(int8, MSG_Y " " MSG_DAC_PERCENT, &driverPercent[Y_AXIS], 0, 100, dac_driver_commit);
-    MENU_ITEM_EDIT_CALLBACK(int8, MSG_Z " " MSG_DAC_PERCENT, &driverPercent[Z_AXIS], 0, 100, dac_driver_commit);
-    MENU_ITEM_EDIT_CALLBACK(int8, MSG_E " " MSG_DAC_PERCENT, &driverPercent[E_AXIS], 0, 100, dac_driver_commit);
-    MENU_ITEM(function, MSG_DAC_EEPROM_WRITE, dac_driver_eeprom_write);
-    END_MENU();
-  }
-
-#endif // DAC_STEPPER_CURRENT
-
-#if HAS_MOTOR_CURRENT_PWM
-
-  void menu_pwm() {
-    START_MENU();
-    MENU_BACK(MSG_CONTROL);
-    #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
-      MENU_ITEM_EDIT_CALLBACK(long5, MSG_X MSG_Y, &stepper.motor_current_setting[0], 100, 2000, Stepper::refresh_motor_power);
-    #endif
-    #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
-      MENU_ITEM_EDIT_CALLBACK(long5, MSG_Z, &stepper.motor_current_setting[1], 100, 2000, Stepper::refresh_motor_power);
-    #endif
-    #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
-      MENU_ITEM_EDIT_CALLBACK(long5, MSG_E, &stepper.motor_current_setting[2], 100, 2000, Stepper::refresh_motor_power);
-    #endif
-    END_MENU();
-  }
-
-#endif // HAS_MOTOR_CURRENT_PWM
-
 /**
  *
  * "Temperature" submenu items
@@ -1204,8 +1006,20 @@ void lcd_cooldown() {
 #endif
 
 #if ENABLED(EEPROM_SETTINGS)
-  static void lcd_store_settings()   { lcd_completion_feedback(settings.save()); }
-  static void lcd_load_settings()    { lcd_completion_feedback(settings.load()); }
+  void lcd_store_settings()   { lcd_completion_feedback(settings.save()); }
+  void lcd_load_settings()    { lcd_completion_feedback(settings.load()); }
+  #if DISABLED(SLIM_LCD_MENUS)
+    static void lcd_init_eeprom() {
+      lcd_completion_feedback(settings.init_eeprom());
+      lcd_goto_previous_menu();
+    }
+    static void lcd_init_eeprom_confirm() {
+      START_MENU();
+      MENU_BACK(MSG_ADVANCED_SETTINGS);
+      MENU_ITEM(function, MSG_INIT_EEPROM, lcd_init_eeprom);
+      END_MENU();
+    }
+  #endif
 #endif
 
 void _lcd_draw_homing() {
@@ -2597,120 +2411,6 @@ void menu_move() {
   END_MENU();
 }
 
-/**
- *
- * "Configuration" submenu
- *
- */
-
-#if HAS_LCD_CONTRAST
-  void lcd_callback_set_contrast() { set_lcd_contrast(lcd_contrast); }
-#endif
-
-static void lcd_factory_settings() {
-  settings.reset();
-  lcd_completion_feedback();
-}
-
-#if ENABLED(EEPROM_SETTINGS) && DISABLED(SLIM_LCD_MENUS)
-
-  static void lcd_init_eeprom() {
-    lcd_completion_feedback(settings.init_eeprom());
-    lcd_goto_previous_menu();
-  }
-
-  static void lcd_init_eeprom_confirm() {
-    START_MENU();
-    MENU_BACK(MSG_ADVANCED_SETTINGS);
-    MENU_ITEM(function, MSG_INIT_EEPROM, lcd_init_eeprom);
-    END_MENU();
-  }
-
-#endif
-
-void menu_configuration() {
-  START_MENU();
-  MENU_BACK(MSG_MAIN);
-
-  //
-  // Debug Menu when certain options are enabled
-  //
-  #if HAS_DEBUG_MENU
-    MENU_ITEM(submenu, MSG_DEBUG_MENU, menu_debug);
-  #endif
-
-  MENU_ITEM(submenu, MSG_ADVANCED_SETTINGS, menu_advanced_settings);
-
-  const bool busy = printer_busy();
-  if (!busy) {
-    //
-    // Delta Calibration
-    //
-    #if ENABLED(DELTA_CALIBRATION_MENU) || ENABLED(DELTA_AUTO_CALIBRATION)
-      MENU_ITEM(submenu, MSG_DELTA_CALIBRATE, menu_delta_calibrate);
-    #endif
-
-    #if ENABLED(DUAL_X_CARRIAGE)
-      MENU_ITEM(submenu, MSG_IDEX_MENU, menu_IDEX);
-    #endif
-
-    #if ENABLED(BLTOUCH)
-      MENU_ITEM(submenu, MSG_BLTOUCH, menu_bltouch);
-    #endif
-  }
-
-  //
-  // Set single nozzle filament retract and prime length
-  //
-  #if EXTRUDERS > 1
-    MENU_ITEM(submenu, MSG_TOOL_CHANGE, menu_tool_change);
-  #endif
-
-  //
-  // Set Case light on/off/brightness
-  //
-  #if ENABLED(MENU_ITEM_CASE_LIGHT)
-    if (USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN))
-      MENU_ITEM(submenu, MSG_CASE_LIGHT, menu_case_light);
-    else
-      MENU_ITEM_EDIT_CALLBACK(bool, MSG_CASE_LIGHT, (bool*)&case_light_on, update_case_light);
-  #endif
-
-  #if HAS_LCD_CONTRAST
-    MENU_ITEM_EDIT_CALLBACK(int3, MSG_CONTRAST, &lcd_contrast, LCD_CONTRAST_MIN, LCD_CONTRAST_MAX, lcd_callback_set_contrast, true);
-  #endif
-  #if ENABLED(FWRETRACT)
-    MENU_ITEM(submenu, MSG_RETRACT, menu_config_retract);
-  #endif
-  #if ENABLED(DAC_STEPPER_CURRENT)
-    MENU_ITEM(submenu, MSG_DRIVE_STRENGTH, menu_dac);
-  #endif
-  #if HAS_MOTOR_CURRENT_PWM
-    MENU_ITEM(submenu, MSG_DRIVE_STRENGTH, menu_pwm);
-  #endif
-
-  #if ENABLED(FILAMENT_RUNOUT_SENSOR)
-    MENU_ITEM_EDIT(bool, MSG_RUNOUT_SENSOR_ENABLE, &runout.enabled);
-  #endif
-
-  #if DISABLED(SLIM_LCD_MENUS)
-    // Preheat configurations
-    MENU_ITEM(submenu, MSG_PREHEAT_1_SETTINGS, menu_preheat_material1_settings);
-    MENU_ITEM(submenu, MSG_PREHEAT_2_SETTINGS, menu_preheat_material2_settings);
-  #endif
-
-  #if ENABLED(EEPROM_SETTINGS)
-    MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
-    if (!busy)
-      MENU_ITEM(function, MSG_LOAD_EEPROM, lcd_load_settings);
-  #endif
-
-  if (!busy)
-    MENU_ITEM(function, MSG_RESTORE_FAILSAFE, lcd_factory_settings);
-
-  END_MENU();
-}
-
 /**
  *
  * "Temperature" submenu
@@ -2962,55 +2662,6 @@ void menu_advanced_temperature() {
 
 #if DISABLED(SLIM_LCD_MENUS)
 
-  void _menu_configuration_preheat_settings(const uint8_t material) {
-    #if HOTENDS > 5
-      #define MINTEMP_ALL MIN(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP, HEATER_3_MINTEMP, HEATER_4_MINTEMP, HEATER_5_MINTEMP)
-      #define MAXTEMP_ALL MAX(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP, HEATER_5_MAXTEMP)
-    #elif HOTENDS > 4
-      #define MINTEMP_ALL MIN(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP, HEATER_3_MINTEMP, HEATER_4_MINTEMP)
-      #define MAXTEMP_ALL MAX(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP)
-    #elif HOTENDS > 3
-      #define MINTEMP_ALL MIN(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP, HEATER_3_MINTEMP)
-      #define MAXTEMP_ALL MAX(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP)
-    #elif HOTENDS > 2
-      #define MINTEMP_ALL MIN(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP)
-      #define MAXTEMP_ALL MAX(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP)
-    #elif HOTENDS > 1
-      #define MINTEMP_ALL MIN(HEATER_0_MINTEMP, HEATER_1_MINTEMP)
-      #define MAXTEMP_ALL MAX(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP)
-    #else
-      #define MINTEMP_ALL HEATER_0_MINTEMP
-      #define MAXTEMP_ALL HEATER_0_MAXTEMP
-    #endif
-    START_MENU();
-    MENU_BACK(MSG_CONFIGURATION);
-    MENU_ITEM_EDIT(int8, MSG_FAN_SPEED, &lcd_preheat_fan_speed[material], 0, 255);
-    #if HAS_TEMP_HOTEND
-      MENU_ITEM_EDIT(int3, MSG_NOZZLE, &lcd_preheat_hotend_temp[material], MINTEMP_ALL, MAXTEMP_ALL - 15);
-    #endif
-    #if HAS_HEATED_BED
-      MENU_ITEM_EDIT(int3, MSG_BED, &lcd_preheat_bed_temp[material], BED_MINTEMP, BED_MAXTEMP - 15);
-    #endif
-    #if ENABLED(EEPROM_SETTINGS)
-      MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
-    #endif
-    END_MENU();
-  }
-
-  /**
-   *
-   * "Temperature" > "Preheat Material 1 conf" submenu
-   *
-   */
-  void menu_preheat_material1_settings() { _menu_configuration_preheat_settings(0); }
-
-  /**
-   *
-   * "Temperature" > "Preheat Material 2 conf" submenu
-   *
-   */
-  void menu_preheat_material2_settings() { _menu_configuration_preheat_settings(1); }
-
   void _reset_acceleration_rates() { planner.reset_acceleration_rates(); }
   #if ENABLED(DISTINCT_E_FACTORS)
     void _reset_e_acceleration_rate(const uint8_t e) { if (e == active_extruder) _reset_acceleration_rates(); }
@@ -3423,38 +3074,6 @@ void menu_advanced_settings() {
   }
 #endif // !NO_VOLUMETRICS || ADVANCED_PAUSE_FEATURE
 
-/**
- *
- * "Configuration" > "Retract" submenu
- *
- */
-#if ENABLED(FWRETRACT)
-
-  void menu_config_retract() {
-    START_MENU();
-    MENU_BACK(MSG_CONTROL);
-    #if ENABLED(FWRETRACT_AUTORETRACT)
-      MENU_ITEM_EDIT_CALLBACK(bool, MSG_AUTORETRACT, &fwretract.autoretract_enabled, fwretract.refresh_autoretract);
-    #endif
-    MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT, &fwretract.settings.retract_length, 0, 100);
-    #if EXTRUDERS > 1
-      MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT_SWAP, &fwretract.settings.swap_retract_length, 0, 100);
-    #endif
-    MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACTF, &fwretract.settings.retract_feedrate_mm_s, 1, 999);
-    MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT_ZHOP, &fwretract.settings.retract_zraise, 0, 999);
-    MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT_RECOVER, &fwretract.settings.retract_recover_length, -100, 100);
-    #if EXTRUDERS > 1
-      MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT_RECOVER_SWAP, &fwretract.settings.swap_retract_recover_length, -100, 100);
-    #endif
-    MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACT_RECOVERF, &fwretract.settings.retract_recover_feedrate_mm_s, 1, 999);
-    #if EXTRUDERS > 1
-      MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACT_RECOVER_SWAPF, &fwretract.settings.swap_retract_recover_feedrate_mm_s, 1, 999);
-    #endif
-    END_MENU();
-  }
-
-#endif // FWRETRACT
-
 #if ENABLED(SDSUPPORT)
 
   #if !PIN_EXISTS(SD_DETECT)

commit 143d4ec043a89665f72e4cda3a43a50da61f0317
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Oct 27 14:53:05 2018 -0500

    Move Tune Menu to its own file

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 333c6ef396..c139bf987a 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -308,10 +308,6 @@ void menu_advanced_settings();
   void _lcd_set_z_fade_height() { set_z_fade_height(lcd_z_fade_height); }
 #endif
 
-#if ENABLED(BABYSTEPPING)
-  long babysteps_done = 0;
-#endif
-
 bool printer_busy() { return planner.movesplanned() || IS_SD_PRINTING(); }
 
 float move_menu_scale;
@@ -740,93 +736,57 @@ void line_to_z(const float &z) {
 
 #endif
 
-/**
- *
- * "Tune" submenu items
- *
- */
-
-#if ENABLED(BABYSTEPPING)
+#if ENABLED(BABYSTEP_ZPROBE_OFFSET)
 
-  void _lcd_babystep(const AxisEnum axis, PGM_P msg) {
+  void lcd_babystep_zoffset() {
     if (use_click()) { return lcd_goto_previous_menu_no_defer(); }
+    defer_return_to_status = true;
+    #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
+      const bool do_probe = (active_extruder == 0);
+    #else
+      constexpr bool do_probe = true;
+    #endif
     ENCODER_DIRECTION_NORMAL();
     if (encoderPosition) {
       const int16_t babystep_increment = (int32_t)encoderPosition * (BABYSTEP_MULTIPLICATOR);
       encoderPosition = 0;
-      lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
-      thermalManager.babystep_axis(axis, babystep_increment);
-      babysteps_done += babystep_increment;
-    }
-    if (lcdDrawUpdate)
-      lcd_implementation_drawedit(msg, ftostr43sign(planner.steps_to_mm[axis] * babysteps_done));
-  }
-
-  #if ENABLED(BABYSTEP_XY)
-    void _lcd_babystep_x() { _lcd_babystep(X_AXIS, PSTR(MSG_BABYSTEP_X)); }
-    void _lcd_babystep_y() { _lcd_babystep(Y_AXIS, PSTR(MSG_BABYSTEP_Y)); }
-    void lcd_babystep_x() { lcd_goto_screen(_lcd_babystep_x); babysteps_done = 0; defer_return_to_status = true; }
-    void lcd_babystep_y() { lcd_goto_screen(_lcd_babystep_y); babysteps_done = 0; defer_return_to_status = true; }
-  #endif
 
-  #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
+      const float diff = planner.steps_to_mm[Z_AXIS] * babystep_increment,
+                  new_probe_offset = zprobe_zoffset + diff,
+                  new_offs =
+                    #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
+                      do_probe ? new_probe_offset : hotend_offset[Z_AXIS][active_extruder] - diff
+                    #else
+                      new_probe_offset
+                    #endif
+                  ;
+      if (WITHIN(new_offs, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
 
-    void lcd_babystep_zoffset() {
-      if (use_click()) { return lcd_goto_previous_menu_no_defer(); }
-      defer_return_to_status = true;
-      #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
-        const bool do_probe = (active_extruder == 0);
-      #else
-        constexpr bool do_probe = true;
-      #endif
-      ENCODER_DIRECTION_NORMAL();
-      if (encoderPosition) {
-        const int16_t babystep_increment = (int32_t)encoderPosition * (BABYSTEP_MULTIPLICATOR);
-        encoderPosition = 0;
-
-        const float diff = planner.steps_to_mm[Z_AXIS] * babystep_increment,
-                    new_probe_offset = zprobe_zoffset + diff,
-                    new_offs =
-                      #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
-                        do_probe ? new_probe_offset : hotend_offset[Z_AXIS][active_extruder] - diff
-                      #else
-                        new_probe_offset
-                      #endif
-                    ;
-        if (WITHIN(new_offs, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
-
-          thermalManager.babystep_axis(Z_AXIS, babystep_increment);
-
-          if (do_probe) zprobe_zoffset = new_offs;
-          #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
-            else hotend_offset[Z_AXIS][active_extruder] = new_offs;
-          #endif
+        thermalManager.babystep_axis(Z_AXIS, babystep_increment);
 
-          lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
-        }
-      }
-      if (lcdDrawUpdate) {
+        if (do_probe) zprobe_zoffset = new_offs;
         #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
-          if (!do_probe)
-            lcd_implementation_drawedit(PSTR(MSG_IDEX_Z_OFFSET), ftostr43sign(hotend_offset[Z_AXIS][active_extruder]));
-          else
+          else hotend_offset[Z_AXIS][active_extruder] = new_offs;
         #endif
-            lcd_implementation_drawedit(PSTR(MSG_ZPROBE_ZOFFSET), ftostr43sign(zprobe_zoffset));
 
-        #if ENABLED(BABYSTEP_ZPROBE_GFX_OVERLAY)
-          if (do_probe) _lcd_zoffset_overlay_gfx(zprobe_zoffset);
-        #endif
+        lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
       }
     }
+    if (lcdDrawUpdate) {
+      #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
+        if (!do_probe)
+          lcd_implementation_drawedit(PSTR(MSG_IDEX_Z_OFFSET), ftostr43sign(hotend_offset[Z_AXIS][active_extruder]));
+        else
+      #endif
+          lcd_implementation_drawedit(PSTR(MSG_ZPROBE_ZOFFSET), ftostr43sign(zprobe_zoffset));
 
-  #else // !BABYSTEP_ZPROBE_OFFSET
-
-    void _lcd_babystep_z() { _lcd_babystep(Z_AXIS, PSTR(MSG_BABYSTEP_Z)); }
-    void lcd_babystep_z() { lcd_goto_screen(_lcd_babystep_z); babysteps_done = 0; defer_return_to_status = true; }
-
-  #endif // !BABYSTEP_ZPROBE_OFFSET
+      #if ENABLED(BABYSTEP_ZPROBE_GFX_OVERLAY)
+        if (do_probe) _lcd_zoffset_overlay_gfx(zprobe_zoffset);
+      #endif
+    }
+  }
 
-#endif // BABYSTEPPING
+#endif // BABYSTEP_ZPROBE_OFFSET
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
 
@@ -923,144 +883,6 @@ void watch_temp_callback_bed() {
   #endif
 }
 
-// Refresh the E factor after changing flow
-inline void _lcd_refresh_e_factor_0() { planner.refresh_e_factor(0); }
-#if EXTRUDERS > 1
-  inline void _lcd_refresh_e_factor() { planner.refresh_e_factor(active_extruder); }
-  inline void _lcd_refresh_e_factor_1() { planner.refresh_e_factor(1); }
-  #if EXTRUDERS > 2
-    inline void _lcd_refresh_e_factor_2() { planner.refresh_e_factor(2); }
-    #if EXTRUDERS > 3
-      inline void _lcd_refresh_e_factor_3() { planner.refresh_e_factor(3); }
-      #if EXTRUDERS > 4
-        inline void _lcd_refresh_e_factor_4() { planner.refresh_e_factor(4); }
-        #if EXTRUDERS > 5
-          inline void _lcd_refresh_e_factor_5() { planner.refresh_e_factor(5); }
-        #endif // EXTRUDERS > 5
-      #endif // EXTRUDERS > 4
-    #endif // EXTRUDERS > 3
-  #endif // EXTRUDERS > 2
-#endif // EXTRUDERS > 1
-
-/**
- *
- * "Tune" submenu
- *
- */
-void menu_tune() {
-  START_MENU();
-  MENU_BACK(MSG_MAIN);
-
-  //
-  // Speed:
-  //
-  MENU_ITEM_EDIT(int3, MSG_SPEED, &feedrate_percentage, 10, 999);
-
-  //
-  // Manual bed leveling, Bed Z:
-  //
-  #if ENABLED(MESH_BED_LEVELING) && ENABLED(LCD_BED_LEVELING)
-    MENU_ITEM_EDIT(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
-  #endif
-
-  //
-  // Nozzle:
-  // Nozzle [1-4]:
-  //
-  #if HOTENDS == 1
-    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE, &thermalManager.target_temperature[0], 0, HEATER_0_MAXTEMP - 15, watch_temp_callback_E0);
-  #else // HOTENDS > 1
-    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N1, &thermalManager.target_temperature[0], 0, HEATER_0_MAXTEMP - 15, watch_temp_callback_E0);
-    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N2, &thermalManager.target_temperature[1], 0, HEATER_1_MAXTEMP - 15, watch_temp_callback_E1);
-    #if HOTENDS > 2
-      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N3, &thermalManager.target_temperature[2], 0, HEATER_2_MAXTEMP - 15, watch_temp_callback_E2);
-      #if HOTENDS > 3
-        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N4, &thermalManager.target_temperature[3], 0, HEATER_3_MAXTEMP - 15, watch_temp_callback_E3);
-        #if HOTENDS > 4
-          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N5, &thermalManager.target_temperature[4], 0, HEATER_4_MAXTEMP - 15, watch_temp_callback_E4);
-          #if HOTENDS > 5
-            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N6, &thermalManager.target_temperature[5], 0, HEATER_5_MAXTEMP - 15, watch_temp_callback_E5);
-          #endif // HOTENDS > 5
-        #endif // HOTENDS > 4
-      #endif // HOTENDS > 3
-    #endif // HOTENDS > 2
-  #endif // HOTENDS > 1
-
-  //
-  // Bed:
-  //
-  #if HAS_HEATED_BED
-    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_BED, &thermalManager.target_temperature_bed, 0, BED_MAXTEMP - 15, watch_temp_callback_bed);
-  #endif
-
-  //
-  // Fan Speed:
-  //
-  #if FAN_COUNT > 0
-    #if HAS_FAN0
-      MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_FAN_SPEED FAN_SPEED_1_SUFFIX, &fan_speed[0], 0, 255);
-      #if ENABLED(EXTRA_FAN_SPEED)
-        MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_EXTRA_FAN_SPEED FAN_SPEED_1_SUFFIX, &new_fan_speed[0], 3, 255);
-      #endif
-    #endif
-    #if HAS_FAN1
-      MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_FAN_SPEED " 2", &fan_speed[1], 0, 255);
-      #if ENABLED(EXTRA_FAN_SPEED)
-        MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_EXTRA_FAN_SPEED " 2", &new_fan_speed[1], 3, 255);
-      #endif
-    #endif
-    #if HAS_FAN2
-      MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_FAN_SPEED " 3", &fan_speed[2], 0, 255);
-      #if ENABLED(EXTRA_FAN_SPEED)
-        MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_EXTRA_FAN_SPEED " 3", &new_fan_speed[2], 3, 255);
-      #endif
-    #endif
-  #endif // FAN_COUNT > 0
-
-  //
-  // Flow:
-  // Flow [1-5]:
-  //
-  #if EXTRUDERS == 1
-    MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW, &planner.flow_percentage[0], 10, 999, _lcd_refresh_e_factor_0);
-  #else // EXTRUDERS > 1
-    MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW, &planner.flow_percentage[active_extruder], 10, 999, _lcd_refresh_e_factor);
-    MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW MSG_N1, &planner.flow_percentage[0], 10, 999, _lcd_refresh_e_factor_0);
-    MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW MSG_N2, &planner.flow_percentage[1], 10, 999, _lcd_refresh_e_factor_1);
-    #if EXTRUDERS > 2
-      MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW MSG_N3, &planner.flow_percentage[2], 10, 999, _lcd_refresh_e_factor_2);
-      #if EXTRUDERS > 3
-        MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW MSG_N4, &planner.flow_percentage[3], 10, 999, _lcd_refresh_e_factor_3);
-        #if EXTRUDERS > 4
-          MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW MSG_N5, &planner.flow_percentage[4], 10, 999, _lcd_refresh_e_factor_4);
-          #if EXTRUDERS > 5
-            MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW MSG_N6, &planner.flow_percentage[5], 10, 999, _lcd_refresh_e_factor_5);
-          #endif // EXTRUDERS > 5
-        #endif // EXTRUDERS > 4
-      #endif // EXTRUDERS > 3
-    #endif // EXTRUDERS > 2
-  #endif // EXTRUDERS > 1
-
-  //
-  // Babystep X:
-  // Babystep Y:
-  // Babystep Z:
-  //
-  #if ENABLED(BABYSTEPPING)
-    #if ENABLED(BABYSTEP_XY)
-      MENU_ITEM(submenu, MSG_BABYSTEP_X, lcd_babystep_x);
-      MENU_ITEM(submenu, MSG_BABYSTEP_Y, lcd_babystep_y);
-    #endif
-    #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
-      MENU_ITEM(submenu, MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
-    #else
-      MENU_ITEM(submenu, MSG_BABYSTEP_Z, lcd_babystep_z);
-    #endif
-  #endif
-
-  END_MENU();
-}
-
 /**
  *
  * "Driver current control" submenu items

commit 829effc1fe813b7d622c7790a0a7413f96dfa7fb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Oct 27 13:15:46 2018 -0500

    Move Main Menu to its own file

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index c712325289..333c6ef396 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -256,10 +256,6 @@ void menu_action_setting_edit_callback_bool(PGM_P pstr, bool* ptr, screenFunc_t
 ///////////////// Menu Tree ////////////////
 ////////////////////////////////////////////
 
-void menu_tune();
-void menu_movement();
-void menu_configuration();
-void menu_temperature();
 void menu_advanced_settings();
 
 #if DISABLED(SLIM_LCD_MENUS)
@@ -277,11 +273,6 @@ void menu_advanced_settings();
   #endif
   void menu_info_thermistors();
   void menu_info_board();
-  void menu_info();
-#endif
-
-#if ENABLED(LED_CONTROL_MENU)
-  void menu_led();
 #endif
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
@@ -497,36 +488,6 @@ void line_to_z(const float &z) {
   line_to_current_z();
 }
 
-#if ENABLED(SDSUPPORT)
-
-  void lcd_sdcard_pause() {
-    card.pauseSDPrint();
-    print_job_timer.pause();
-    #if ENABLED(PARK_HEAD_ON_PAUSE)
-      enqueue_and_echo_commands_P(PSTR("M125"));
-    #endif
-    lcd_reset_status();
-  }
-
-  void lcd_sdcard_resume() {
-    #if ENABLED(PARK_HEAD_ON_PAUSE)
-      enqueue_and_echo_commands_P(PSTR("M24"));
-    #else
-      card.startFileprint();
-      print_job_timer.start();
-    #endif
-    lcd_reset_status();
-  }
-
-  void lcd_sdcard_stop() {
-    wait_for_heatup = wait_for_user = false;
-    card.abort_sd_printing = true;
-    lcd_setstatusPGM(PSTR(MSG_PRINT_ABORTED), -1);
-    lcd_return_to_status();
-  }
-
-#endif // SDSUPPORT
-
 #if ENABLED(POWER_LOSS_RECOVERY)
 
   static void lcd_power_loss_recovery_resume() {
@@ -779,100 +740,6 @@ void line_to_z(const float &z) {
 
 #endif
 
-/**
- *
- * "Main" menu
- *
- */
-
-#if ENABLED(SDSUPPORT) && ENABLED(MENU_ADDAUTOSTART)
-
-  void lcd_autostart_sd() { card.beginautostart(); }
-
-#endif
-
-void menu_main() {
-  START_MENU();
-  MENU_BACK(MSG_WATCH);
-
-  #if ENABLED(SDSUPPORT)
-    if (card.cardOK) {
-      if (card.isFileOpen()) {
-        if (card.sdprinting)
-          MENU_ITEM(function, MSG_PAUSE_PRINT, lcd_sdcard_pause);
-        else
-          MENU_ITEM(function, MSG_RESUME_PRINT, lcd_sdcard_resume);
-        MENU_ITEM(function, MSG_STOP_PRINT, lcd_sdcard_stop);
-      }
-      else {
-        MENU_ITEM(submenu, MSG_CARD_MENU, menu_sdcard);
-        #if !PIN_EXISTS(SD_DETECT)
-          MENU_ITEM(gcode, MSG_CNG_SDCARD, PSTR("M21"));  // SD-card changed by user
-        #endif
-      }
-    }
-    else {
-      MENU_ITEM(submenu, MSG_NO_CARD, menu_sdcard);
-      #if !PIN_EXISTS(SD_DETECT)
-        MENU_ITEM(gcode, MSG_INIT_SDCARD, PSTR("M21")); // Manually initialize the SD-card via user interface
-      #endif
-    }
-  #endif // SDSUPPORT
-
-  const bool busy = printer_busy();
-  if (busy)
-    MENU_ITEM(submenu, MSG_TUNE, menu_tune);
-  else {
-    MENU_ITEM(submenu, MSG_MOTION, menu_movement);
-    MENU_ITEM(submenu, MSG_TEMPERATURE, menu_temperature);
-  }
-
-  MENU_ITEM(submenu, MSG_CONFIGURATION, menu_configuration);
-
-  #if ENABLED(CUSTOM_USER_MENUS)
-    MENU_ITEM(submenu, MSG_USER_MENU, _menu_user);
-  #endif
-
-  #if ENABLED(ADVANCED_PAUSE_FEATURE)
-    #if E_STEPPERS == 1 && DISABLED(FILAMENT_LOAD_UNLOAD_GCODES)
-      if (thermalManager.targetHotEnoughToExtrude(active_extruder))
-        MENU_ITEM(gcode, MSG_FILAMENTCHANGE, PSTR("M600 B0"));
-      else
-        MENU_ITEM(submenu, MSG_FILAMENTCHANGE, menu_temp_e0_filament_change);
-    #else
-      MENU_ITEM(submenu, MSG_FILAMENTCHANGE, menu_change_filament);
-    #endif
-  #endif
-
-  #if ENABLED(LCD_INFO_MENU)
-    MENU_ITEM(submenu, MSG_INFO_MENU, menu_info);
-  #endif
-
-  #if ENABLED(LED_CONTROL_MENU)
-    MENU_ITEM(submenu, MSG_LED_CONTROL, menu_led);
-  #endif
-
-  //
-  // Switch power on/off
-  //
-  #if HAS_POWER_SWITCH
-    if (powersupply_on)
-      MENU_ITEM(gcode, MSG_SWITCH_PS_OFF, PSTR("M81"));
-    else
-      MENU_ITEM(gcode, MSG_SWITCH_PS_ON, PSTR("M80"));
-  #endif
-
-  //
-  // Autostart
-  //
-  #if ENABLED(SDSUPPORT) && ENABLED(MENU_ADDAUTOSTART)
-    if (!busy)
-      MENU_ITEM(function, MSG_AUTOSTART, lcd_autostart_sd);
-  #endif
-
-  END_MENU();
-}
-
 /**
  *
  * "Tune" submenu items

commit 774a6e81995b23c383bbc2fdcb5f6f5c014043f2
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Oct 27 13:07:03 2018 -0500

    Drop TALL_FONT_CORRECTION

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index 07f5ff2702..c712325289 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -101,12 +101,7 @@ bool liveEdit;
   float raw_Ki, raw_Kd; // place-holders for Ki and Kd edits
 #endif
 
-#ifndef TALL_FONT_CORRECTION
-  #define TALL_FONT_CORRECTION 0
-#endif
-
 bool no_reentry = false;
-constexpr int8_t menu_bottom = LCD_HEIGHT - (TALL_FONT_CORRECTION);
 
 // Initialized by settings.load()
 int16_t lcd_preheat_hotend_temp[2], lcd_preheat_bed_temp[2];
@@ -478,8 +473,8 @@ void scroll_screen(const uint8_t limit, const bool is_menu) {
   }
   if (is_menu) {
     NOMORE(encoderTopLine, encoderLine);
-    if (encoderLine >= encoderTopLine + menu_bottom)
-      encoderTopLine = encoderLine - menu_bottom + 1;
+    if (encoderLine >= encoderTopLine + LCD_HEIGHT)
+      encoderTopLine = encoderLine - LCD_HEIGHT + 1;
   }
   else
     encoderTopLine = encoderLine;

commit c825c419d4e1d10600148bd7c927bef0fc4c6baa
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Oct 24 02:27:19 2018 -0500

    Convert DOGM / HD44780 impl to CPP files

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
index b75c929880..07f5ff2702 100644
--- a/Marlin/src/lcd/menu/menu.cpp
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -54,10 +54,6 @@
   #include "../../libs/duration_t.h"
 #endif
 
-#if ENABLED(FILAMENT_LCD_DISPLAY)
-  #include "../../feature/filwidth.h"
-#endif
-
 #if ENABLED(BLTOUCH)
   #include "../../module/endstops.h"
 #endif
@@ -74,15 +70,6 @@
   #include "../../feature/runout.h"
 #endif
 
-////////////////////////////////////////////
-///////////////// Externs //////////////////
-////////////////////////////////////////////
-
-// LCD Updates
-#if HAS_GRAPHICAL_LCD
-  extern bool drawing_screen;
-#endif
-
 ////////////////////////////////////////////
 ///////////// Global Variables /////////////
 ////////////////////////////////////////////

commit 2bf18950ab2070e842c91057d5812dcaa1bff9a2
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Oct 23 16:00:34 2018 -0500

    Refactor LCD menus

diff --git a/Marlin/src/lcd/menu/menu.cpp b/Marlin/src/lcd/menu/menu.cpp
new file mode 100644
index 0000000000..b75c929880
--- /dev/null
+++ b/Marlin/src/lcd/menu/menu.cpp
@@ -0,0 +1,4660 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "../../inc/MarlinConfigPre.h"
+
+#if ENABLED(ULTIPANEL)
+
+#include "menu.h"
+
+#include "../ultralcd.h"
+#include "../../sd/cardreader.h"
+#include "../../module/temperature.h"
+#include "../../module/planner.h"
+#include "../../module/stepper.h"
+#include "../../module/motion.h"
+#include "../../module/probe.h"
+#include "../../module/printcounter.h"
+#include "../../gcode/gcode.h"
+#include "../../gcode/queue.h"
+#include "../../module/configuration_store.h"
+#include "../../module/tool_change.h"
+#include "../../Marlin.h"
+
+#include <stdarg.h>
+
+#if ENABLED(ADVANCED_PAUSE_FEATURE)
+  #include "../../feature/pause.h"
+#endif
+
+#if ENABLED(POWER_LOSS_RECOVERY)
+  #include "../../feature/power_loss_recovery.h"
+#endif
+
+#if ENABLED(PRINTCOUNTER) && ENABLED(LCD_INFO_MENU)
+  #include "../../libs/duration_t.h"
+#endif
+
+#if ENABLED(FILAMENT_LCD_DISPLAY)
+  #include "../../feature/filwidth.h"
+#endif
+
+#if ENABLED(BLTOUCH)
+  #include "../../module/endstops.h"
+#endif
+
+#if HAS_LEVELING
+  #include "../../feature/bedlevel/bedlevel.h"
+#endif
+
+#if ENABLED(LED_CONTROL_MENU)
+  #include "../../feature/leds/leds.h"
+#endif
+
+#if ENABLED(FILAMENT_RUNOUT_SENSOR)
+  #include "../../feature/runout.h"
+#endif
+
+////////////////////////////////////////////
+///////////////// Externs //////////////////
+////////////////////////////////////////////
+
+// LCD Updates
+#if HAS_GRAPHICAL_LCD
+  extern bool drawing_screen;
+#endif
+
+////////////////////////////////////////////
+///////////// Global Variables /////////////
+////////////////////////////////////////////
+
+// Buttons
+volatile uint8_t buttons;
+#if ENABLED(REPRAPWORLD_KEYPAD)
+  volatile uint8_t buttons_reprapworld_keypad;
+#endif
+
+// Menu Navigation
+int8_t encoderTopLine;
+typedef struct {
+  screenFunc_t menu_function;
+  uint32_t encoder_position;
+} menuPosition;
+menuPosition screen_history[6];
+uint8_t screen_history_depth = 0;
+bool screen_changed, defer_return_to_status;
+
+// Value Editing
+PGM_P editLabel;
+void *editValue;
+int32_t minEditValue, maxEditValue;
+screenFunc_t callbackFunc;
+bool liveEdit;
+
+#if ENABLED(PIDTEMP)
+  float raw_Ki, raw_Kd; // place-holders for Ki and Kd edits
+#endif
+
+#ifndef TALL_FONT_CORRECTION
+  #define TALL_FONT_CORRECTION 0
+#endif
+
+bool no_reentry = false;
+constexpr int8_t menu_bottom = LCD_HEIGHT - (TALL_FONT_CORRECTION);
+
+// Initialized by settings.load()
+int16_t lcd_preheat_hotend_temp[2], lcd_preheat_bed_temp[2];
+uint8_t lcd_preheat_fan_speed[2];
+
+////////////////////////////////////////////
+//////// Menu Navigation & History /////////
+////////////////////////////////////////////
+
+void lcd_status_screen();
+
+void lcd_return_to_status() { lcd_goto_screen(lcd_status_screen); }
+
+void lcd_save_previous_screen() {
+  if (screen_history_depth < COUNT(screen_history)) {
+    screen_history[screen_history_depth].menu_function = currentScreen;
+    screen_history[screen_history_depth].encoder_position = encoderPosition;
+    ++screen_history_depth;
+  }
+}
+
+void lcd_goto_previous_menu() {
+  if (screen_history_depth > 0) {
+    --screen_history_depth;
+    lcd_goto_screen(
+      screen_history[screen_history_depth].menu_function,
+      screen_history[screen_history_depth].encoder_position
+    );
+  }
+  else
+    lcd_return_to_status();
+}
+
+void lcd_goto_previous_menu_no_defer() {
+  defer_return_to_status = false;
+  lcd_goto_previous_menu();
+}
+
+////////////////////////////////////////////
+/////////////// Menu Actions ///////////////
+////////////////////////////////////////////
+
+void _menu_action_back() { lcd_goto_previous_menu(); }
+void menu_action_submenu(screenFunc_t func) { lcd_save_previous_screen(); lcd_goto_screen(func); }
+void menu_action_gcode(PGM_P pgcode) { enqueue_and_echo_commands_P(pgcode); }
+void menu_action_function(screenFunc_t func) { (*func)(); }
+
+#if ENABLED(SDSUPPORT)
+
+  void menu_action_sdfile(CardReader &theCard) {
+    #if ENABLED(SD_REPRINT_LAST_SELECTED_FILE)
+      last_sdfile_encoderPosition = encoderPosition;  // Save which file was selected for later use
+    #endif
+    card.openAndPrintFile(theCard.filename);
+    lcd_return_to_status();
+    lcd_reset_status();
+  }
+
+  void menu_action_sddirectory(CardReader &theCard) {
+    card.chdir(theCard.filename);
+    encoderTopLine = 0;
+    encoderPosition = 2 * ENCODER_STEPS_PER_MENU_ITEM;
+    screen_changed = true;
+    #if HAS_GRAPHICAL_LCD
+      drawing_screen = false;
+    #endif
+    lcd_refresh();
+  }
+
+#endif // SDSUPPORT
+
+////////////////////////////////////////////
+/////////// Menu Editing Actions ///////////
+////////////////////////////////////////////
+
+/**
+ * Functions for editing single values
+ *
+ * The "DEFINE_MENU_EDIT_TYPE" macro generates the functions needed to edit a numerical value.
+ *
+ * For example, DEFINE_MENU_EDIT_TYPE(int16_t, int3, itostr3, 1) expands into these functions:
+ *
+ *   bool _menu_edit_int3();
+ *   void menu_edit_int3(); // edit int16_t (interactively)
+ *   void menu_edit_callback_int3(); // edit int16_t (interactively) with callback on completion
+ *   void _menu_action_setting_edit_int3(PGM_P const pstr, int16_t * const ptr, const int16_t minValue, const int16_t maxValue);
+ *   void menu_action_setting_edit_int3(PGM_P const pstr, int16_t * const ptr, const int16_t minValue, const int16_t maxValue);
+ *   void menu_action_setting_edit_callback_int3(PGM_P const pstr, int16_t * const ptr, const int16_t minValue, const int16_t maxValue, const screenFunc_t callback, const bool live); // edit int16_t with callback
+ *
+ * You can then use one of the menu macros to present the edit interface:
+ *   MENU_ITEM_EDIT(int3, MSG_SPEED, &feedrate_percentage, 10, 999)
+ *
+ * This expands into a more primitive menu item:
+ *   MENU_ITEM(setting_edit_int3, MSG_SPEED, PSTR(MSG_SPEED), &feedrate_percentage, 10, 999)
+ *
+ * ...which calls:
+ *       menu_action_setting_edit_int3(PSTR(MSG_SPEED), &feedrate_percentage, 10, 999)
+ */
+#define DEFINE_MENU_EDIT_TYPE(TYPE, NAME, STRFUNC, SCALE) \
+  bool _menu_edit_ ## NAME() { \
+    ENCODER_DIRECTION_NORMAL(); \
+    if ((int32_t)encoderPosition < 0) encoderPosition = 0; \
+    if ((int32_t)encoderPosition > maxEditValue) encoderPosition = maxEditValue; \
+    if (lcdDrawUpdate) \
+      lcd_implementation_drawedit(editLabel, STRFUNC(((TYPE)((int32_t)encoderPosition + minEditValue)) * (1.0f / SCALE))); \
+    if (lcd_clicked || (liveEdit && lcdDrawUpdate)) { \
+      TYPE value = ((TYPE)((int32_t)encoderPosition + minEditValue)) * (1.0f / SCALE); \
+      if (editValue != NULL) *((TYPE*)editValue) = value; \
+      if (callbackFunc && (liveEdit || lcd_clicked)) (*callbackFunc)(); \
+      if (lcd_clicked) lcd_goto_previous_menu(); \
+    } \
+    return use_click(); \
+  } \
+  void menu_edit_ ## NAME() { _menu_edit_ ## NAME(); } \
+  void _menu_action_setting_edit_ ## NAME(PGM_P const pstr, TYPE* const ptr, const TYPE minValue, const TYPE maxValue) { \
+    lcd_save_previous_screen(); \
+    lcd_refresh(); \
+    \
+    editLabel = pstr; \
+    editValue = ptr; \
+    minEditValue = minValue * SCALE; \
+    maxEditValue = maxValue * SCALE - minEditValue; \
+    encoderPosition = (*ptr) * SCALE - minEditValue; \
+  } \
+  void menu_action_setting_edit_callback_ ## NAME(PGM_P const pstr, TYPE * const ptr, const TYPE minValue, const TYPE maxValue, const screenFunc_t callback/*=NULL*/, const bool live/*=false*/) { \
+    _menu_action_setting_edit_ ## NAME(pstr, ptr, minValue, maxValue); \
+    currentScreen = menu_edit_ ## NAME; \
+    callbackFunc = callback; \
+    liveEdit = live; \
+  } \
+  typedef void NAME##_void
+
+DEFINE_MENU_EDIT_TYPE(int16_t, int3, itostr3, 1);
+DEFINE_MENU_EDIT_TYPE(int16_t, int4, itostr4sign, 1);
+DEFINE_MENU_EDIT_TYPE(uint8_t, int8, i8tostr3, 1);
+DEFINE_MENU_EDIT_TYPE(float, float3, ftostr3, 1);
+DEFINE_MENU_EDIT_TYPE(float, float52, ftostr52, 100);
+DEFINE_MENU_EDIT_TYPE(float, float43, ftostr43sign, 1000);
+DEFINE_MENU_EDIT_TYPE(float, float5, ftostr5rj, 0.01f);
+DEFINE_MENU_EDIT_TYPE(float, float51, ftostr51sign, 10);
+DEFINE_MENU_EDIT_TYPE(float, float52sign, ftostr52sign, 100);
+DEFINE_MENU_EDIT_TYPE(float, float62, ftostr62rj, 100);
+DEFINE_MENU_EDIT_TYPE(uint32_t, long5, ftostr5rj, 0.01f);
+
+void menu_action_setting_edit_bool(PGM_P pstr, bool* ptr) { UNUSED(pstr); *ptr ^= true; lcd_refresh(); }
+void menu_action_setting_edit_callback_bool(PGM_P pstr, bool* ptr, screenFunc_t callback) {
+  menu_action_setting_edit_bool(pstr, ptr);
+  (*callback)();
+}
+
+////////////////////////////////////////////
+///////////////// Menu Tree ////////////////
+////////////////////////////////////////////
+
+void menu_tune();
+void menu_movement();
+void menu_configuration();
+void menu_temperature();
+void menu_advanced_settings();
+
+#if DISABLED(SLIM_LCD_MENUS)
+  void menu_preheat_material1_settings();
+  void menu_preheat_material2_settings();
+#endif
+
+#if DISABLED(NO_VOLUMETRICS) || ENABLED(ADVANCED_PAUSE_FEATURE)
+  void menu_advanced_filament();
+#endif
+
+#if ENABLED(LCD_INFO_MENU)
+  #if ENABLED(PRINTCOUNTER)
+    void menu_info_stats();
+  #endif
+  void menu_info_thermistors();
+  void menu_info_board();
+  void menu_info();
+#endif
+
+#if ENABLED(LED_CONTROL_MENU)
+  void menu_led();
+#endif
+
+#if ENABLED(ADVANCED_PAUSE_FEATURE)
+  #if E_STEPPERS > 1 || ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
+    void menu_change_filament();
+  #else
+    void menu_temp_e0_filament_change();
+  #endif
+#endif
+
+#if ENABLED(DAC_STEPPER_CURRENT)
+  void dac_driver_commit();
+  void dac_driver_getValues();
+  void menu_dac();
+  void lcd_dac_write_eeprom();
+#endif
+
+#if ENABLED(FWRETRACT)
+  #include "../../feature/fwretract.h"
+  void menu_config_retract();
+#endif
+
+#if ENABLED(DELTA_CALIBRATION_MENU) || ENABLED(DELTA_AUTO_CALIBRATION)
+  void menu_delta_calibrate();
+#endif
+
+#if ENABLED(MESH_BED_LEVELING) && ENABLED(LCD_BED_LEVELING)
+  #include "../../feature/bedlevel/mbl/mesh_bed_leveling.h"
+#endif
+
+#if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+  float lcd_z_fade_height;
+  void _lcd_set_z_fade_height() { set_z_fade_height(lcd_z_fade_height); }
+#endif
+
+#if ENABLED(BABYSTEPPING)
+  long babysteps_done = 0;
+#endif
+
+bool printer_busy() { return planner.movesplanned() || IS_SD_PRINTING(); }
+
+float move_menu_scale;
+
+#if HAS_CHARACTER_LCD && (ENABLED(LCD_PROGRESS_BAR) || ENABLED(LCD_PROGRESS_BAR_TEST) || ENABLED(AUTO_BED_LEVELING_UBL))
+  void lcd_set_custom_characters(
+    #if ENABLED(LCD_PROGRESS_BAR) || ENABLED(SHOW_BOOTSCREEN)
+      const uint8_t screen_charset=CHARSET_INFO
+    #endif
+  );
+#endif
+
+/**
+ * General function to go directly to a screen
+ */
+void lcd_goto_screen(screenFunc_t screen, const uint32_t encoder/*=0*/) {
+  if (currentScreen != screen) {
+
+    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+      // Shadow for editing the fade height
+      lcd_z_fade_height = planner.z_fade_height;
+    #endif
+
+    #if ENABLED(DOUBLECLICK_FOR_Z_BABYSTEPPING) && ENABLED(BABYSTEPPING)
+      static millis_t doubleclick_expire_ms = 0;
+      // Going to menu_main from status screen? Remember first click time.
+      // Going back to status screen within a very short time? Go to Z babystepping.
+      if (screen == menu_main) {
+        if (currentScreen == lcd_status_screen)
+          doubleclick_expire_ms = millis() + DOUBLECLICK_MAX_INTERVAL;
+      }
+      else if (screen == lcd_status_screen && currentScreen == menu_main && PENDING(millis(), doubleclick_expire_ms)) {
+        if (printer_busy()) {
+          screen =
+            #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
+              lcd_babystep_zoffset
+            #else
+              lcd_babystep_z
+            #endif
+          ;
+        }
+        #if ENABLED(MOVE_Z_WHEN_IDLE)
+          else {
+            move_menu_scale = MOVE_Z_IDLE_MULTIPLICATOR;
+            screen = lcd_move_z;
+          }
+        #endif
+      }
+    #endif
+
+    currentScreen = screen;
+    encoderPosition = encoder;
+    if (screen == lcd_status_screen) {
+      defer_return_to_status = false;
+      #if ENABLED(AUTO_BED_LEVELING_UBL)
+        ubl.lcd_map_control = false;
+      #endif
+      screen_history_depth = 0;
+    }
+    lcd_implementation_clear();
+    // Re-initialize custom characters that may be re-used
+    #if HAS_CHARACTER_LCD && ENABLED(AUTO_BED_LEVELING_UBL)
+      if (!ubl.lcd_map_control) {
+        lcd_set_custom_characters(
+          #if ENABLED(LCD_PROGRESS_BAR)
+            screen == lcd_status_screen ? CHARSET_INFO : CHARSET_MENU
+          #endif
+        );
+      }
+    #elif ENABLED(LCD_PROGRESS_BAR)
+      lcd_set_custom_characters(screen == lcd_status_screen ? CHARSET_INFO : CHARSET_MENU);
+    #endif
+    lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
+    screen_changed = true;
+    #if HAS_GRAPHICAL_LCD
+      drawing_screen = false;
+    #endif
+  }
+}
+
+////////////////////////////////////////////
+///////////// Manual Movement //////////////
+////////////////////////////////////////////
+
+extern millis_t manual_move_start_time;
+extern int8_t manual_move_axis;
+
+#if IS_KINEMATIC
+  extern float manual_move_offset;
+#endif
+
+#if ENABLED(DUAL_X_CARRIAGE) || E_MANUAL > 1
+  extern int8_t manual_move_e_index;
+#endif
+
+#if ENABLED(MANUAL_E_MOVES_RELATIVE)
+  float manual_move_e_origin = 0;
+#endif
+
+
+//
+// Display the synchronize screen until moves are
+// finished, and don't return to the caller until
+// done. ** This blocks the command queue! **
+//
+static PGM_P sync_message;
+
+void _lcd_synchronize() {
+  if (lcdDrawUpdate) lcd_implementation_drawmenu_static(LCD_HEIGHT >= 4 ? 1 : 0, sync_message);
+  if (no_reentry) return;
+  // Make this the current handler till all moves are done
+  no_reentry = true;
+  const screenFunc_t old_screen = currentScreen;
+  lcd_goto_screen(_lcd_synchronize);
+  planner.synchronize(); // idle() is called until moves complete
+  no_reentry = false;
+  lcd_goto_screen(old_screen);
+}
+
+// Display the synchronize screen with a custom message
+// ** This blocks the command queue! **
+void lcd_synchronize(PGM_P const msg/*=NULL*/) {
+  static const char moving[] PROGMEM = MSG_MOVING;
+  sync_message = msg ? msg : moving;
+  _lcd_synchronize();
+}
+
+/**
+ * Scrolling for menus and other line-based screens
+ *
+ *   encoderLine is the position based on the encoder
+ *   encoderTopLine is the top menu line to display
+ *   _lcdLineNr is the index of the LCD line (e.g., 0-3)
+ *   _menuLineNr is the menu item to draw and process
+ *   _thisItemNr is the index of each MENU_ITEM or STATIC_ITEM
+ *   screen_items is the total number of items in the menu (after one call)
+ */
+int8_t encoderLine, screen_items;
+void scroll_screen(const uint8_t limit, const bool is_menu) {
+  ENCODER_DIRECTION_MENUS();
+  ENCODER_RATE_MULTIPLY(false);
+  if (encoderPosition > 0x8000) encoderPosition = 0;
+  if (first_page) {
+    encoderLine = encoderPosition / (ENCODER_STEPS_PER_MENU_ITEM);
+    screen_changed = false;
+  }
+  if (screen_items > 0 && encoderLine >= screen_items - limit) {
+    encoderLine = MAX(0, screen_items - limit);
+    encoderPosition = encoderLine * (ENCODER_STEPS_PER_MENU_ITEM);
+  }
+  if (is_menu) {
+    NOMORE(encoderTopLine, encoderLine);
+    if (encoderLine >= encoderTopLine + menu_bottom)
+      encoderTopLine = encoderLine - menu_bottom + 1;
+  }
+  else
+    encoderTopLine = encoderLine;
+}
+
+void lcd_completion_feedback(const bool good/*=true*/) {
+  if (good) {
+    lcd_buzz(100, 659);
+    lcd_buzz(100, 698);
+  }
+  else lcd_buzz(20, 440);
+}
+
+inline void line_to_current_z() {
+  planner.buffer_line(current_position, MMM_TO_MMS(manual_feedrate_mm_m[Z_AXIS]), active_extruder);
+}
+
+void line_to_z(const float &z) {
+  current_position[Z_AXIS] = z;
+  line_to_current_z();
+}
+
+#if ENABLED(SDSUPPORT)
+
+  void lcd_sdcard_pause() {
+    card.pauseSDPrint();
+    print_job_timer.pause();
+    #if ENABLED(PARK_HEAD_ON_PAUSE)
+      enqueue_and_echo_commands_P(PSTR("M125"));
+    #endif
+    lcd_reset_status();
+  }
+
+  void lcd_sdcard_resume() {
+    #if ENABLED(PARK_HEAD_ON_PAUSE)
+      enqueue_and_echo_commands_P(PSTR("M24"));
+    #else
+      card.startFileprint();
+      print_job_timer.start();
+    #endif
+    lcd_reset_status();
+  }
+
+  void lcd_sdcard_stop() {
+    wait_for_heatup = wait_for_user = false;
+    card.abort_sd_printing = true;
+    lcd_setstatusPGM(PSTR(MSG_PRINT_ABORTED), -1);
+    lcd_return_to_status();
+  }
+
+#endif // SDSUPPORT
+
+#if ENABLED(POWER_LOSS_RECOVERY)
+
+  static void lcd_power_loss_recovery_resume() {
+    char cmd[20];
+
+    // Return to status now
+    lcd_return_to_status();
+
+    // Turn leveling off and home
+    enqueue_and_echo_commands_P(PSTR("M420 S0\nG28 R0"
+      #if ENABLED(MARLIN_DEV_MODE)
+        " S"
+      #elif !IS_KINEMATIC
+        " X Y"
+      #endif
+    ));
+
+    #if HAS_HEATED_BED
+      const int16_t bt = job_recovery_info.target_temperature_bed;
+      if (bt) {
+        // Restore the bed temperature
+        sprintf_P(cmd, PSTR("M190 S%i"), bt);
+        enqueue_and_echo_command(cmd);
+      }
+    #endif
+
+    // Restore all hotend temperatures
+    HOTEND_LOOP() {
+      const int16_t et = job_recovery_info.target_temperature[e];
+      if (et) {
+        #if HOTENDS > 1
+          sprintf_P(cmd, PSTR("T%i"), e);
+          enqueue_and_echo_command(cmd);
+        #endif
+        sprintf_P(cmd, PSTR("M109 S%i"), et);
+        enqueue_and_echo_command(cmd);
+      }
+    }
+
+    #if HOTENDS > 1
+      sprintf_P(cmd, PSTR("T%i"), job_recovery_info.active_hotend);
+      enqueue_and_echo_command(cmd);
+    #endif
+
+    // Restore print cooling fan speeds
+    for (uint8_t i = 0; i < FAN_COUNT; i++) {
+      uint8_t f = job_recovery_info.fan_speed[i];
+      if (f) {
+        sprintf_P(cmd, PSTR("M106 P%i S%i"), i, f);
+        enqueue_and_echo_command(cmd);
+      }
+    }
+
+    // Start draining the job recovery command queue
+    job_recovery_phase = JOB_RECOVERY_YES;
+  }
+
+  static void lcd_power_loss_recovery_cancel() {
+    card.removeJobRecoveryFile();
+    card.autostart_index = 0;
+    lcd_return_to_status();
+  }
+
+  void menu_job_recovery() {
+    defer_return_to_status = true;
+    START_MENU();
+    STATIC_ITEM(MSG_POWER_LOSS_RECOVERY);
+    MENU_ITEM(function, MSG_RESUME_PRINT, lcd_power_loss_recovery_resume);
+    MENU_ITEM(function, MSG_STOP_PRINT, lcd_power_loss_recovery_cancel);
+    END_MENU();
+  }
+
+#endif // POWER_LOSS_RECOVERY
+
+#if EXTRUDERS > 1
+  void menu_tool_change() {
+    START_MENU();
+    MENU_BACK(MSG_MAIN);
+    #if ENABLED(SINGLENOZZLE)
+      MENU_ITEM_EDIT(float3, MSG_FILAMENT_SWAP_LENGTH, &toolchange_settings.swap_length, 0, 200);
+      MENU_MULTIPLIER_ITEM_EDIT(int4, MSG_SINGLENOZZLE_RETRACT_SPD, &toolchange_settings.retract_speed, 10, 5400);
+      MENU_MULTIPLIER_ITEM_EDIT(int4, MSG_SINGLENOZZLE_PRIME_SPD, &toolchange_settings.prime_speed, 10, 5400);
+    #endif
+    MENU_ITEM_EDIT(float3, MSG_TOOL_CHANGE_ZLIFT, &toolchange_settings.z_raise, 0, 10);
+    END_MENU();
+  }
+#endif
+
+#if ENABLED(MENU_ITEM_CASE_LIGHT)
+
+  #include "../../feature/caselight.h"
+
+  void menu_case_light() {
+    START_MENU();
+    MENU_BACK(MSG_MAIN);
+    MENU_ITEM_EDIT_CALLBACK(int8, MSG_CASE_LIGHT_BRIGHTNESS, &case_light_brightness, 0, 255, update_case_light, true);
+    MENU_ITEM_EDIT_CALLBACK(bool, MSG_CASE_LIGHT, (bool*)&case_light_on, update_case_light);
+    END_MENU();
+  }
+#endif // MENU_ITEM_CASE_LIGHT
+
+#if ENABLED(BLTOUCH)
+
+  /**
+   *
+   * "BLTouch" submenu
+   *
+   */
+  static void menu_bltouch() {
+    START_MENU();
+    MENU_BACK(MSG_MAIN);
+    MENU_ITEM(gcode, MSG_BLTOUCH_RESET, PSTR("M280 P" STRINGIFY(Z_PROBE_SERVO_NR) " S" STRINGIFY(BLTOUCH_RESET)));
+    MENU_ITEM(gcode, MSG_BLTOUCH_SELFTEST, PSTR("M280 P" STRINGIFY(Z_PROBE_SERVO_NR) " S" STRINGIFY(BLTOUCH_SELFTEST)));
+    MENU_ITEM(gcode, MSG_BLTOUCH_DEPLOY, PSTR("M280 P" STRINGIFY(Z_PROBE_SERVO_NR) " S" STRINGIFY(BLTOUCH_DEPLOY)));
+    MENU_ITEM(gcode, MSG_BLTOUCH_STOW, PSTR("M280 P" STRINGIFY(Z_PROBE_SERVO_NR) " S" STRINGIFY(BLTOUCH_STOW)));
+    END_MENU();
+  }
+
+#endif // BLTOUCH
+
+#if ENABLED(LCD_PROGRESS_BAR_TEST)
+
+  static void progress_bar_test() {
+    static int8_t bar_percent = 0;
+    if (use_click()) {
+      lcd_goto_previous_menu();
+      lcd_set_custom_characters(CHARSET_MENU);
+      return;
+    }
+    bar_percent += (int8_t)encoderPosition;
+    bar_percent = constrain(bar_percent, 0, 100);
+    encoderPosition = 0;
+    lcd_implementation_drawmenu_static(0, PSTR(MSG_PROGRESS_BAR_TEST), true, true);
+    lcd_moveto((LCD_WIDTH) / 2 - 2, LCD_HEIGHT - 2);
+    lcd_put_u8str(int(bar_percent)); lcd_put_wchar('%');
+    lcd_moveto(0, LCD_HEIGHT - 1); lcd_draw_progress_bar(bar_percent);
+  }
+
+  void _progress_bar_test() {
+    lcd_goto_screen(progress_bar_test);
+    lcd_set_custom_characters();
+  }
+
+#endif // LCD_PROGRESS_BAR_TEST
+
+#if HAS_DEBUG_MENU
+
+  void menu_debug() {
+    START_MENU();
+
+    MENU_BACK(MSG_MAIN);
+
+    #if ENABLED(LCD_PROGRESS_BAR_TEST)
+      MENU_ITEM(submenu, MSG_PROGRESS_BAR_TEST, _progress_bar_test);
+    #endif
+
+    END_MENU();
+  }
+
+#endif // HAS_DEBUG_MENU
+
+/**
+ * IDEX submenu
+ */
+#if ENABLED(DUAL_X_CARRIAGE)
+  static void _recalc_IDEX_settings() {
+    if (active_extruder) {                      // For the 2nd extruder re-home so the next tool-change gets the new offsets.
+      enqueue_and_echo_commands_P(PSTR("G28")); // In future, we can babystep the 2nd extruder (if active), making homing unnecessary.
+      active_extruder = 0;
+    }
+  }
+
+  static void menu_IDEX() {
+    START_MENU();
+    MENU_BACK(MSG_MAIN);
+
+    MENU_ITEM(gcode, MSG_IDEX_MODE_AUTOPARK,  PSTR("M605 S1\nG28 X\nG1 X100"));
+    const bool need_g28 = !(TEST(axis_known_position, Y_AXIS) && TEST(axis_known_position, Z_AXIS));
+    MENU_ITEM(gcode, MSG_IDEX_MODE_DUPLICATE, need_g28
+      ? PSTR("M605 S1\nT0\nG28\nM605 S2 X200\nG28 X\nG1 X100")                // If Y or Z is not homed, do a full G28 first
+      : PSTR("M605 S1\nT0\nM605 S2 X200\nG28 X\nG1 X100")
+    );
+    //MENU_ITEM(gcode, MSG_IDEX_MODE_SCALED_COPY, need_g28
+    //  ? PSTR("M605 S1\nT0\nG28\nM605 S2 X200\nG28 X\nG1 X100\nM605 S3 X200")  // If Y or Z is not homed, do a full G28 first
+    //  : PSTR("M605 S1\nT0\nM605 S2 X200\nG28 X\nG1 X100\nM605 S3 X200")
+    //);
+    MENU_ITEM(gcode, MSG_IDEX_MODE_FULL_CTRL, PSTR("M605 S0\nG28 X"));
+    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float52, MSG_IDEX_X_OFFSET , &hotend_offset[X_AXIS][1], MIN(X2_HOME_POS, X2_MAX_POS) - 25.0, MAX(X2_HOME_POS, X2_MAX_POS) + 25.0, _recalc_IDEX_settings);
+    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float52, MSG_IDEX_Y_OFFSET , &hotend_offset[Y_AXIS][1], -10.0, 10.0, _recalc_IDEX_settings);
+    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float52, MSG_IDEX_Z_OFFSET , &hotend_offset[Z_AXIS][1], -10.0, 10.0, _recalc_IDEX_settings);
+    MENU_ITEM(gcode, MSG_IDEX_SAVE_OFFSETS, PSTR("M500"));
+    END_MENU();
+  }
+#endif // DUAL_X_CARRIAGE
+
+#if ENABLED(CUSTOM_USER_MENUS)
+
+  #ifdef USER_SCRIPT_DONE
+    #define _DONE_SCRIPT "\n" USER_SCRIPT_DONE
+  #else
+    #define _DONE_SCRIPT ""
+  #endif
+
+  void _lcd_user_gcode(PGM_P const cmd) {
+    enqueue_and_echo_commands_P(cmd);
+    #if ENABLED(USER_SCRIPT_AUDIBLE_FEEDBACK)
+      lcd_completion_feedback();
+    #endif
+    #if ENABLED(USER_SCRIPT_RETURN)
+      lcd_return_to_status();
+    #endif
+  }
+
+  #if defined(USER_DESC_1) && defined(USER_GCODE_1)
+    void lcd_user_gcode_1() { _lcd_user_gcode(PSTR(USER_GCODE_1 _DONE_SCRIPT)); }
+  #endif
+  #if defined(USER_DESC_2) && defined(USER_GCODE_2)
+    void lcd_user_gcode_2() { _lcd_user_gcode(PSTR(USER_GCODE_2 _DONE_SCRIPT)); }
+  #endif
+  #if defined(USER_DESC_3) && defined(USER_GCODE_3)
+    void lcd_user_gcode_3() { _lcd_user_gcode(PSTR(USER_GCODE_3 _DONE_SCRIPT)); }
+  #endif
+  #if defined(USER_DESC_4) && defined(USER_GCODE_4)
+    void lcd_user_gcode_4() { _lcd_user_gcode(PSTR(USER_GCODE_4 _DONE_SCRIPT)); }
+  #endif
+  #if defined(USER_DESC_5) && defined(USER_GCODE_5)
+    void lcd_user_gcode_5() { _lcd_user_gcode(PSTR(USER_GCODE_5 _DONE_SCRIPT)); }
+  #endif
+
+  void _menu_user() {
+    START_MENU();
+    MENU_BACK(MSG_MAIN);
+    #if defined(USER_DESC_1) && defined(USER_GCODE_1)
+      MENU_ITEM(function, USER_DESC_1, lcd_user_gcode_1);
+    #endif
+    #if defined(USER_DESC_2) && defined(USER_GCODE_2)
+      MENU_ITEM(function, USER_DESC_2, lcd_user_gcode_2);
+    #endif
+    #if defined(USER_DESC_3) && defined(USER_GCODE_3)
+      MENU_ITEM(function, USER_DESC_3, lcd_user_gcode_3);
+    #endif
+    #if defined(USER_DESC_4) && defined(USER_GCODE_4)
+      MENU_ITEM(function, USER_DESC_4, lcd_user_gcode_4);
+    #endif
+    #if defined(USER_DESC_5) && defined(USER_GCODE_5)
+      MENU_ITEM(function, USER_DESC_5, lcd_user_gcode_5);
+    #endif
+    END_MENU();
+  }
+
+#endif
+
+/**
+ *
+ * "Main" menu
+ *
+ */
+
+#if ENABLED(SDSUPPORT) && ENABLED(MENU_ADDAUTOSTART)
+
+  void lcd_autostart_sd() { card.beginautostart(); }
+
+#endif
+
+void menu_main() {
+  START_MENU();
+  MENU_BACK(MSG_WATCH);
+
+  #if ENABLED(SDSUPPORT)
+    if (card.cardOK) {
+      if (card.isFileOpen()) {
+        if (card.sdprinting)
+          MENU_ITEM(function, MSG_PAUSE_PRINT, lcd_sdcard_pause);
+        else
+          MENU_ITEM(function, MSG_RESUME_PRINT, lcd_sdcard_resume);
+        MENU_ITEM(function, MSG_STOP_PRINT, lcd_sdcard_stop);
+      }
+      else {
+        MENU_ITEM(submenu, MSG_CARD_MENU, menu_sdcard);
+        #if !PIN_EXISTS(SD_DETECT)
+          MENU_ITEM(gcode, MSG_CNG_SDCARD, PSTR("M21"));  // SD-card changed by user
+        #endif
+      }
+    }
+    else {
+      MENU_ITEM(submenu, MSG_NO_CARD, menu_sdcard);
+      #if !PIN_EXISTS(SD_DETECT)
+        MENU_ITEM(gcode, MSG_INIT_SDCARD, PSTR("M21")); // Manually initialize the SD-card via user interface
+      #endif
+    }
+  #endif // SDSUPPORT
+
+  const bool busy = printer_busy();
+  if (busy)
+    MENU_ITEM(submenu, MSG_TUNE, menu_tune);
+  else {
+    MENU_ITEM(submenu, MSG_MOTION, menu_movement);
+    MENU_ITEM(submenu, MSG_TEMPERATURE, menu_temperature);
+  }
+
+  MENU_ITEM(submenu, MSG_CONFIGURATION, menu_configuration);
+
+  #if ENABLED(CUSTOM_USER_MENUS)
+    MENU_ITEM(submenu, MSG_USER_MENU, _menu_user);
+  #endif
+
+  #if ENABLED(ADVANCED_PAUSE_FEATURE)
+    #if E_STEPPERS == 1 && DISABLED(FILAMENT_LOAD_UNLOAD_GCODES)
+      if (thermalManager.targetHotEnoughToExtrude(active_extruder))
+        MENU_ITEM(gcode, MSG_FILAMENTCHANGE, PSTR("M600 B0"));
+      else
+        MENU_ITEM(submenu, MSG_FILAMENTCHANGE, menu_temp_e0_filament_change);
+    #else
+      MENU_ITEM(submenu, MSG_FILAMENTCHANGE, menu_change_filament);
+    #endif
+  #endif
+
+  #if ENABLED(LCD_INFO_MENU)
+    MENU_ITEM(submenu, MSG_INFO_MENU, menu_info);
+  #endif
+
+  #if ENABLED(LED_CONTROL_MENU)
+    MENU_ITEM(submenu, MSG_LED_CONTROL, menu_led);
+  #endif
+
+  //
+  // Switch power on/off
+  //
+  #if HAS_POWER_SWITCH
+    if (powersupply_on)
+      MENU_ITEM(gcode, MSG_SWITCH_PS_OFF, PSTR("M81"));
+    else
+      MENU_ITEM(gcode, MSG_SWITCH_PS_ON, PSTR("M80"));
+  #endif
+
+  //
+  // Autostart
+  //
+  #if ENABLED(SDSUPPORT) && ENABLED(MENU_ADDAUTOSTART)
+    if (!busy)
+      MENU_ITEM(function, MSG_AUTOSTART, lcd_autostart_sd);
+  #endif
+
+  END_MENU();
+}
+
+/**
+ *
+ * "Tune" submenu items
+ *
+ */
+
+#if ENABLED(BABYSTEPPING)
+
+  void _lcd_babystep(const AxisEnum axis, PGM_P msg) {
+    if (use_click()) { return lcd_goto_previous_menu_no_defer(); }
+    ENCODER_DIRECTION_NORMAL();
+    if (encoderPosition) {
+      const int16_t babystep_increment = (int32_t)encoderPosition * (BABYSTEP_MULTIPLICATOR);
+      encoderPosition = 0;
+      lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
+      thermalManager.babystep_axis(axis, babystep_increment);
+      babysteps_done += babystep_increment;
+    }
+    if (lcdDrawUpdate)
+      lcd_implementation_drawedit(msg, ftostr43sign(planner.steps_to_mm[axis] * babysteps_done));
+  }
+
+  #if ENABLED(BABYSTEP_XY)
+    void _lcd_babystep_x() { _lcd_babystep(X_AXIS, PSTR(MSG_BABYSTEP_X)); }
+    void _lcd_babystep_y() { _lcd_babystep(Y_AXIS, PSTR(MSG_BABYSTEP_Y)); }
+    void lcd_babystep_x() { lcd_goto_screen(_lcd_babystep_x); babysteps_done = 0; defer_return_to_status = true; }
+    void lcd_babystep_y() { lcd_goto_screen(_lcd_babystep_y); babysteps_done = 0; defer_return_to_status = true; }
+  #endif
+
+  #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
+
+    void lcd_babystep_zoffset() {
+      if (use_click()) { return lcd_goto_previous_menu_no_defer(); }
+      defer_return_to_status = true;
+      #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
+        const bool do_probe = (active_extruder == 0);
+      #else
+        constexpr bool do_probe = true;
+      #endif
+      ENCODER_DIRECTION_NORMAL();
+      if (encoderPosition) {
+        const int16_t babystep_increment = (int32_t)encoderPosition * (BABYSTEP_MULTIPLICATOR);
+        encoderPosition = 0;
+
+        const float diff = planner.steps_to_mm[Z_AXIS] * babystep_increment,
+                    new_probe_offset = zprobe_zoffset + diff,
+                    new_offs =
+                      #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
+                        do_probe ? new_probe_offset : hotend_offset[Z_AXIS][active_extruder] - diff
+                      #else
+                        new_probe_offset
+                      #endif
+                    ;
+        if (WITHIN(new_offs, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
+
+          thermalManager.babystep_axis(Z_AXIS, babystep_increment);
+
+          if (do_probe) zprobe_zoffset = new_offs;
+          #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
+            else hotend_offset[Z_AXIS][active_extruder] = new_offs;
+          #endif
+
+          lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
+        }
+      }
+      if (lcdDrawUpdate) {
+        #if ENABLED(BABYSTEP_HOTEND_Z_OFFSET)
+          if (!do_probe)
+            lcd_implementation_drawedit(PSTR(MSG_IDEX_Z_OFFSET), ftostr43sign(hotend_offset[Z_AXIS][active_extruder]));
+          else
+        #endif
+            lcd_implementation_drawedit(PSTR(MSG_ZPROBE_ZOFFSET), ftostr43sign(zprobe_zoffset));
+
+        #if ENABLED(BABYSTEP_ZPROBE_GFX_OVERLAY)
+          if (do_probe) _lcd_zoffset_overlay_gfx(zprobe_zoffset);
+        #endif
+      }
+    }
+
+  #else // !BABYSTEP_ZPROBE_OFFSET
+
+    void _lcd_babystep_z() { _lcd_babystep(Z_AXIS, PSTR(MSG_BABYSTEP_Z)); }
+    void lcd_babystep_z() { lcd_goto_screen(_lcd_babystep_z); babysteps_done = 0; defer_return_to_status = true; }
+
+  #endif // !BABYSTEP_ZPROBE_OFFSET
+
+#endif // BABYSTEPPING
+
+#if ENABLED(AUTO_BED_LEVELING_UBL)
+
+  float mesh_edit_value, mesh_edit_accumulator; // We round mesh_edit_value to 2.5 decimal places. So we keep a
+                                                // separate value that doesn't lose precision.
+  static int16_t ubl_encoderPosition = 0;
+
+  static void _lcd_mesh_fine_tune(PGM_P msg) {
+    defer_return_to_status = true;
+    if (ubl.encoder_diff) {
+      ubl_encoderPosition = (ubl.encoder_diff > 0) ? 1 : -1;
+      ubl.encoder_diff = 0;
+
+      mesh_edit_accumulator += float(ubl_encoderPosition) * 0.005f * 0.5f;
+      mesh_edit_value = mesh_edit_accumulator;
+      encoderPosition = 0;
+      lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
+
+      const int32_t rounded = (int32_t)(mesh_edit_value * 1000);
+      mesh_edit_value = float(rounded - (rounded % 5L)) / 1000;
+    }
+
+    if (lcdDrawUpdate) {
+      lcd_implementation_drawedit(msg, ftostr43sign(mesh_edit_value));
+      #if ENABLED(MESH_EDIT_GFX_OVERLAY)
+        _lcd_zoffset_overlay_gfx(mesh_edit_value);
+      #endif
+    }
+  }
+
+  void _lcd_mesh_edit_NOP() {
+    defer_return_to_status = true;
+  }
+
+  float lcd_mesh_edit() {
+    lcd_goto_screen(_lcd_mesh_edit_NOP);
+    lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
+    _lcd_mesh_fine_tune(PSTR("Mesh Editor"));
+    return mesh_edit_value;
+  }
+
+  void lcd_mesh_edit_setup(const float &initial) {
+    mesh_edit_value = mesh_edit_accumulator = initial;
+    lcd_goto_screen(_lcd_mesh_edit_NOP);
+  }
+
+  void _lcd_z_offset_edit() {
+    _lcd_mesh_fine_tune(PSTR("Z-Offset: "));
+  }
+
+  float lcd_z_offset_edit() {
+    lcd_goto_screen(_lcd_z_offset_edit);
+    return mesh_edit_value;
+  }
+
+  void lcd_z_offset_edit_setup(const float &initial) {
+    mesh_edit_value = mesh_edit_accumulator = initial;
+    lcd_goto_screen(_lcd_z_offset_edit);
+  }
+
+#endif // AUTO_BED_LEVELING_UBL
+
+
+/**
+ * Watch temperature callbacks
+ */
+#if HAS_TEMP_HOTEND
+  #if WATCH_HOTENDS
+    #define _WATCH_FUNC(N) thermalManager.start_watching_heater(N)
+  #else
+    #define _WATCH_FUNC(N) NOOP
+  #endif
+  void watch_temp_callback_E0() { _WATCH_FUNC(0); }
+  #if HOTENDS > 1
+    void watch_temp_callback_E1() { _WATCH_FUNC(1); }
+    #if HOTENDS > 2
+      void watch_temp_callback_E2() { _WATCH_FUNC(2); }
+      #if HOTENDS > 3
+        void watch_temp_callback_E3() { _WATCH_FUNC(3); }
+        #if HOTENDS > 4
+          void watch_temp_callback_E4() { _WATCH_FUNC(4); }
+          #if HOTENDS > 5
+            void watch_temp_callback_E5() { _WATCH_FUNC(5); }
+          #endif // HOTENDS > 5
+        #endif // HOTENDS > 4
+      #endif // HOTENDS > 3
+    #endif // HOTENDS > 2
+  #endif // HOTENDS > 1
+#endif // HAS_TEMP_HOTEND
+
+void watch_temp_callback_bed() {
+  #if WATCH_THE_BED
+    thermalManager.start_watching_bed();
+  #endif
+}
+
+// Refresh the E factor after changing flow
+inline void _lcd_refresh_e_factor_0() { planner.refresh_e_factor(0); }
+#if EXTRUDERS > 1
+  inline void _lcd_refresh_e_factor() { planner.refresh_e_factor(active_extruder); }
+  inline void _lcd_refresh_e_factor_1() { planner.refresh_e_factor(1); }
+  #if EXTRUDERS > 2
+    inline void _lcd_refresh_e_factor_2() { planner.refresh_e_factor(2); }
+    #if EXTRUDERS > 3
+      inline void _lcd_refresh_e_factor_3() { planner.refresh_e_factor(3); }
+      #if EXTRUDERS > 4
+        inline void _lcd_refresh_e_factor_4() { planner.refresh_e_factor(4); }
+        #if EXTRUDERS > 5
+          inline void _lcd_refresh_e_factor_5() { planner.refresh_e_factor(5); }
+        #endif // EXTRUDERS > 5
+      #endif // EXTRUDERS > 4
+    #endif // EXTRUDERS > 3
+  #endif // EXTRUDERS > 2
+#endif // EXTRUDERS > 1
+
+/**
+ *
+ * "Tune" submenu
+ *
+ */
+void menu_tune() {
+  START_MENU();
+  MENU_BACK(MSG_MAIN);
+
+  //
+  // Speed:
+  //
+  MENU_ITEM_EDIT(int3, MSG_SPEED, &feedrate_percentage, 10, 999);
+
+  //
+  // Manual bed leveling, Bed Z:
+  //
+  #if ENABLED(MESH_BED_LEVELING) && ENABLED(LCD_BED_LEVELING)
+    MENU_ITEM_EDIT(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
+  #endif
+
+  //
+  // Nozzle:
+  // Nozzle [1-4]:
+  //
+  #if HOTENDS == 1
+    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE, &thermalManager.target_temperature[0], 0, HEATER_0_MAXTEMP - 15, watch_temp_callback_E0);
+  #else // HOTENDS > 1
+    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N1, &thermalManager.target_temperature[0], 0, HEATER_0_MAXTEMP - 15, watch_temp_callback_E0);
+    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N2, &thermalManager.target_temperature[1], 0, HEATER_1_MAXTEMP - 15, watch_temp_callback_E1);
+    #if HOTENDS > 2
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N3, &thermalManager.target_temperature[2], 0, HEATER_2_MAXTEMP - 15, watch_temp_callback_E2);
+      #if HOTENDS > 3
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N4, &thermalManager.target_temperature[3], 0, HEATER_3_MAXTEMP - 15, watch_temp_callback_E3);
+        #if HOTENDS > 4
+          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N5, &thermalManager.target_temperature[4], 0, HEATER_4_MAXTEMP - 15, watch_temp_callback_E4);
+          #if HOTENDS > 5
+            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N6, &thermalManager.target_temperature[5], 0, HEATER_5_MAXTEMP - 15, watch_temp_callback_E5);
+          #endif // HOTENDS > 5
+        #endif // HOTENDS > 4
+      #endif // HOTENDS > 3
+    #endif // HOTENDS > 2
+  #endif // HOTENDS > 1
+
+  //
+  // Bed:
+  //
+  #if HAS_HEATED_BED
+    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_BED, &thermalManager.target_temperature_bed, 0, BED_MAXTEMP - 15, watch_temp_callback_bed);
+  #endif
+
+  //
+  // Fan Speed:
+  //
+  #if FAN_COUNT > 0
+    #if HAS_FAN0
+      MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_FAN_SPEED FAN_SPEED_1_SUFFIX, &fan_speed[0], 0, 255);
+      #if ENABLED(EXTRA_FAN_SPEED)
+        MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_EXTRA_FAN_SPEED FAN_SPEED_1_SUFFIX, &new_fan_speed[0], 3, 255);
+      #endif
+    #endif
+    #if HAS_FAN1
+      MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_FAN_SPEED " 2", &fan_speed[1], 0, 255);
+      #if ENABLED(EXTRA_FAN_SPEED)
+        MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_EXTRA_FAN_SPEED " 2", &new_fan_speed[1], 3, 255);
+      #endif
+    #endif
+    #if HAS_FAN2
+      MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_FAN_SPEED " 3", &fan_speed[2], 0, 255);
+      #if ENABLED(EXTRA_FAN_SPEED)
+        MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_EXTRA_FAN_SPEED " 3", &new_fan_speed[2], 3, 255);
+      #endif
+    #endif
+  #endif // FAN_COUNT > 0
+
+  //
+  // Flow:
+  // Flow [1-5]:
+  //
+  #if EXTRUDERS == 1
+    MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW, &planner.flow_percentage[0], 10, 999, _lcd_refresh_e_factor_0);
+  #else // EXTRUDERS > 1
+    MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW, &planner.flow_percentage[active_extruder], 10, 999, _lcd_refresh_e_factor);
+    MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW MSG_N1, &planner.flow_percentage[0], 10, 999, _lcd_refresh_e_factor_0);
+    MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW MSG_N2, &planner.flow_percentage[1], 10, 999, _lcd_refresh_e_factor_1);
+    #if EXTRUDERS > 2
+      MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW MSG_N3, &planner.flow_percentage[2], 10, 999, _lcd_refresh_e_factor_2);
+      #if EXTRUDERS > 3
+        MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW MSG_N4, &planner.flow_percentage[3], 10, 999, _lcd_refresh_e_factor_3);
+        #if EXTRUDERS > 4
+          MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW MSG_N5, &planner.flow_percentage[4], 10, 999, _lcd_refresh_e_factor_4);
+          #if EXTRUDERS > 5
+            MENU_ITEM_EDIT_CALLBACK(int3, MSG_FLOW MSG_N6, &planner.flow_percentage[5], 10, 999, _lcd_refresh_e_factor_5);
+          #endif // EXTRUDERS > 5
+        #endif // EXTRUDERS > 4
+      #endif // EXTRUDERS > 3
+    #endif // EXTRUDERS > 2
+  #endif // EXTRUDERS > 1
+
+  //
+  // Babystep X:
+  // Babystep Y:
+  // Babystep Z:
+  //
+  #if ENABLED(BABYSTEPPING)
+    #if ENABLED(BABYSTEP_XY)
+      MENU_ITEM(submenu, MSG_BABYSTEP_X, lcd_babystep_x);
+      MENU_ITEM(submenu, MSG_BABYSTEP_Y, lcd_babystep_y);
+    #endif
+    #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
+      MENU_ITEM(submenu, MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
+    #else
+      MENU_ITEM(submenu, MSG_BABYSTEP_Z, lcd_babystep_z);
+    #endif
+  #endif
+
+  END_MENU();
+}
+
+/**
+ *
+ * "Driver current control" submenu items
+ *
+ */
+#if ENABLED(DAC_STEPPER_CURRENT)
+
+  #include "../../feature/dac/stepper_dac.h" //was dac_mcp4728.h MarlinMain uses stepper dac for the m-codes
+  uint8_t driverPercent[XYZE];
+
+  void dac_driver_getValues() { LOOP_XYZE(i) driverPercent[i] = dac_current_get_percent((AxisEnum)i); }
+
+  void dac_driver_commit() { dac_current_set_percents(driverPercent); }
+
+  void dac_driver_eeprom_write() { dac_commit_eeprom(); }
+
+  void menu_dac() {
+    dac_driver_getValues();
+    START_MENU();
+    MENU_BACK(MSG_CONTROL);
+    MENU_ITEM_EDIT_CALLBACK(int8, MSG_X " " MSG_DAC_PERCENT, &driverPercent[X_AXIS], 0, 100, dac_driver_commit);
+    MENU_ITEM_EDIT_CALLBACK(int8, MSG_Y " " MSG_DAC_PERCENT, &driverPercent[Y_AXIS], 0, 100, dac_driver_commit);
+    MENU_ITEM_EDIT_CALLBACK(int8, MSG_Z " " MSG_DAC_PERCENT, &driverPercent[Z_AXIS], 0, 100, dac_driver_commit);
+    MENU_ITEM_EDIT_CALLBACK(int8, MSG_E " " MSG_DAC_PERCENT, &driverPercent[E_AXIS], 0, 100, dac_driver_commit);
+    MENU_ITEM(function, MSG_DAC_EEPROM_WRITE, dac_driver_eeprom_write);
+    END_MENU();
+  }
+
+#endif // DAC_STEPPER_CURRENT
+
+#if HAS_MOTOR_CURRENT_PWM
+
+  void menu_pwm() {
+    START_MENU();
+    MENU_BACK(MSG_CONTROL);
+    #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
+      MENU_ITEM_EDIT_CALLBACK(long5, MSG_X MSG_Y, &stepper.motor_current_setting[0], 100, 2000, Stepper::refresh_motor_power);
+    #endif
+    #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
+      MENU_ITEM_EDIT_CALLBACK(long5, MSG_Z, &stepper.motor_current_setting[1], 100, 2000, Stepper::refresh_motor_power);
+    #endif
+    #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
+      MENU_ITEM_EDIT_CALLBACK(long5, MSG_E, &stepper.motor_current_setting[2], 100, 2000, Stepper::refresh_motor_power);
+    #endif
+    END_MENU();
+  }
+
+#endif // HAS_MOTOR_CURRENT_PWM
+
+/**
+ *
+ * "Temperature" submenu items
+ *
+ */
+void _lcd_preheat(const int16_t endnum, const int16_t temph, const int16_t tempb, const uint8_t fan) {
+  if (temph > 0) thermalManager.setTargetHotend(MIN(heater_maxtemp[endnum], temph), endnum);
+  #if HAS_HEATED_BED
+    if (tempb >= 0) thermalManager.setTargetBed(tempb);
+  #else
+    UNUSED(tempb);
+  #endif
+  #if FAN_COUNT > 0
+    #if FAN_COUNT > 1
+      fan_speed[active_extruder < FAN_COUNT ? active_extruder : 0] = fan;
+    #else
+      fan_speed[0] = fan;
+    #endif
+  #else
+    UNUSED(fan);
+  #endif
+  lcd_return_to_status();
+}
+
+#if HAS_TEMP_HOTEND
+  void lcd_preheat_m1_e0_only() { _lcd_preheat(0, lcd_preheat_hotend_temp[0], -1, lcd_preheat_fan_speed[0]); }
+  void lcd_preheat_m2_e0_only() { _lcd_preheat(0, lcd_preheat_hotend_temp[1], -1, lcd_preheat_fan_speed[1]); }
+  #if HAS_HEATED_BED
+    void lcd_preheat_m1_e0() { _lcd_preheat(0, lcd_preheat_hotend_temp[0], lcd_preheat_bed_temp[0], lcd_preheat_fan_speed[0]); }
+    void lcd_preheat_m2_e0() { _lcd_preheat(0, lcd_preheat_hotend_temp[1], lcd_preheat_bed_temp[1], lcd_preheat_fan_speed[1]); }
+  #endif
+#endif
+
+#if HOTENDS > 1
+  void lcd_preheat_m1_e1_only() { _lcd_preheat(1, lcd_preheat_hotend_temp[0], -1, lcd_preheat_fan_speed[0]); }
+  void lcd_preheat_m2_e1_only() { _lcd_preheat(1, lcd_preheat_hotend_temp[1], -1, lcd_preheat_fan_speed[1]); }
+  #if HAS_HEATED_BED
+    void lcd_preheat_m1_e1() { _lcd_preheat(1, lcd_preheat_hotend_temp[0], lcd_preheat_bed_temp[0], lcd_preheat_fan_speed[0]); }
+    void lcd_preheat_m2_e1() { _lcd_preheat(1, lcd_preheat_hotend_temp[1], lcd_preheat_bed_temp[1], lcd_preheat_fan_speed[1]); }
+  #endif
+  #if HOTENDS > 2
+    void lcd_preheat_m1_e2_only() { _lcd_preheat(2, lcd_preheat_hotend_temp[0], -1, lcd_preheat_fan_speed[0]); }
+    void lcd_preheat_m2_e2_only() { _lcd_preheat(2, lcd_preheat_hotend_temp[1], -1, lcd_preheat_fan_speed[1]); }
+    #if HAS_HEATED_BED
+      void lcd_preheat_m1_e2() { _lcd_preheat(2, lcd_preheat_hotend_temp[0], lcd_preheat_bed_temp[0], lcd_preheat_fan_speed[0]); }
+      void lcd_preheat_m2_e2() { _lcd_preheat(2, lcd_preheat_hotend_temp[1], lcd_preheat_bed_temp[1], lcd_preheat_fan_speed[1]); }
+    #endif
+    #if HOTENDS > 3
+      void lcd_preheat_m1_e3_only() { _lcd_preheat(3, lcd_preheat_hotend_temp[0], -1, lcd_preheat_fan_speed[0]); }
+      void lcd_preheat_m2_e3_only() { _lcd_preheat(3, lcd_preheat_hotend_temp[1], -1, lcd_preheat_fan_speed[1]); }
+      #if HAS_HEATED_BED
+        void lcd_preheat_m1_e3() { _lcd_preheat(3, lcd_preheat_hotend_temp[0], lcd_preheat_bed_temp[0], lcd_preheat_fan_speed[0]); }
+        void lcd_preheat_m2_e3() { _lcd_preheat(3, lcd_preheat_hotend_temp[1], lcd_preheat_bed_temp[1], lcd_preheat_fan_speed[1]); }
+      #endif
+      #if HOTENDS > 4
+        void lcd_preheat_m1_e4_only() { _lcd_preheat(4, lcd_preheat_hotend_temp[0], -1, lcd_preheat_fan_speed[0]); }
+        void lcd_preheat_m2_e4_only() { _lcd_preheat(4, lcd_preheat_hotend_temp[1], -1, lcd_preheat_fan_speed[1]); }
+        #if HAS_HEATED_BED
+          void lcd_preheat_m1_e4() { _lcd_preheat(4, lcd_preheat_hotend_temp[0], lcd_preheat_bed_temp[0], lcd_preheat_fan_speed[0]); }
+          void lcd_preheat_m2_e4() { _lcd_preheat(4, lcd_preheat_hotend_temp[1], lcd_preheat_bed_temp[1], lcd_preheat_fan_speed[1]); }
+        #endif
+        #if HOTENDS > 5
+          void lcd_preheat_m1_e5_only() { _lcd_preheat(5, lcd_preheat_hotend_temp[0], -1, lcd_preheat_fan_speed[0]); }
+          void lcd_preheat_m2_e5_only() { _lcd_preheat(5, lcd_preheat_hotend_temp[1], -1, lcd_preheat_fan_speed[1]); }
+          #if HAS_HEATED_BED
+            void lcd_preheat_m1_e5() { _lcd_preheat(5, lcd_preheat_hotend_temp[0], lcd_preheat_bed_temp[0], lcd_preheat_fan_speed[0]); }
+            void lcd_preheat_m2_e5() { _lcd_preheat(5, lcd_preheat_hotend_temp[1], lcd_preheat_bed_temp[1], lcd_preheat_fan_speed[1]); }
+          #endif
+        #endif // HOTENDS > 5
+      #endif // HOTENDS > 4
+    #endif // HOTENDS > 3
+  #endif // HOTENDS > 2
+
+  void lcd_preheat_m1_all() {
+    #if HOTENDS > 1
+      thermalManager.setTargetHotend(lcd_preheat_hotend_temp[0], 1);
+      #if HOTENDS > 2
+        thermalManager.setTargetHotend(lcd_preheat_hotend_temp[0], 2);
+        #if HOTENDS > 3
+          thermalManager.setTargetHotend(lcd_preheat_hotend_temp[0], 3);
+          #if HOTENDS > 4
+            thermalManager.setTargetHotend(lcd_preheat_hotend_temp[0], 4);
+            #if HOTENDS > 5
+              thermalManager.setTargetHotend(lcd_preheat_hotend_temp[0], 5);
+            #endif // HOTENDS > 5
+          #endif // HOTENDS > 4
+        #endif // HOTENDS > 3
+      #endif // HOTENDS > 2
+    #endif // HOTENDS > 1
+    #if HAS_HEATED_BED
+      lcd_preheat_m1_e0();
+    #else
+      lcd_preheat_m1_e0_only();
+    #endif
+  }
+  void lcd_preheat_m2_all() {
+    #if HOTENDS > 1
+      thermalManager.setTargetHotend(lcd_preheat_hotend_temp[1], 1);
+      #if HOTENDS > 2
+        thermalManager.setTargetHotend(lcd_preheat_hotend_temp[1], 2);
+        #if HOTENDS > 3
+          thermalManager.setTargetHotend(lcd_preheat_hotend_temp[1], 3);
+          #if HOTENDS > 4
+            thermalManager.setTargetHotend(lcd_preheat_hotend_temp[1], 4);
+            #if HOTENDS > 5
+              thermalManager.setTargetHotend(lcd_preheat_hotend_temp[1], 5);
+            #endif // HOTENDS > 5
+          #endif // HOTENDS > 4
+        #endif // HOTENDS > 3
+      #endif // HOTENDS > 2
+    #endif // HOTENDS > 1
+    #if HAS_HEATED_BED
+      lcd_preheat_m2_e0();
+    #else
+      lcd_preheat_m2_e0_only();
+    #endif
+  }
+
+#endif // HOTENDS > 1
+
+#if HAS_HEATED_BED
+  void lcd_preheat_m1_bedonly() { _lcd_preheat(0, 0, lcd_preheat_bed_temp[0], lcd_preheat_fan_speed[0]); }
+  void lcd_preheat_m2_bedonly() { _lcd_preheat(0, 0, lcd_preheat_bed_temp[1], lcd_preheat_fan_speed[1]); }
+#endif
+
+#if HAS_TEMP_HOTEND || HAS_HEATED_BED
+
+  void menu_preheat_m1() {
+    START_MENU();
+    MENU_BACK(MSG_TEMPERATURE);
+    #if HOTENDS == 1
+      #if HAS_HEATED_BED
+        MENU_ITEM(function, MSG_PREHEAT_1, lcd_preheat_m1_e0);
+        MENU_ITEM(function, MSG_PREHEAT_1_END, lcd_preheat_m1_e0_only);
+      #else
+        MENU_ITEM(function, MSG_PREHEAT_1, lcd_preheat_m1_e0_only);
+      #endif
+    #elif HOTENDS > 1
+      #if HAS_HEATED_BED
+        MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H1, lcd_preheat_m1_e0);
+        MENU_ITEM(function, MSG_PREHEAT_1_END " " MSG_E1, lcd_preheat_m1_e0_only);
+        MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H2, lcd_preheat_m1_e1);
+        MENU_ITEM(function, MSG_PREHEAT_1_END " " MSG_E2, lcd_preheat_m1_e1_only);
+      #else
+        MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H1, lcd_preheat_m1_e0_only);
+        MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H2, lcd_preheat_m1_e1_only);
+      #endif
+      #if HOTENDS > 2
+        #if HAS_HEATED_BED
+          MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H3, lcd_preheat_m1_e2);
+          MENU_ITEM(function, MSG_PREHEAT_1_END " " MSG_E3, lcd_preheat_m1_e2_only);
+        #else
+          MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H3, lcd_preheat_m1_e2_only);
+        #endif
+        #if HOTENDS > 3
+          #if HAS_HEATED_BED
+            MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H4, lcd_preheat_m1_e3);
+            MENU_ITEM(function, MSG_PREHEAT_1_END " " MSG_E4, lcd_preheat_m1_e3_only);
+          #else
+            MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H4, lcd_preheat_m1_e3_only);
+          #endif
+          #if HOTENDS > 4
+            #if HAS_HEATED_BED
+              MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H5, lcd_preheat_m1_e4);
+              MENU_ITEM(function, MSG_PREHEAT_1_END " " MSG_E5, lcd_preheat_m1_e4_only);
+            #else
+              MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H5, lcd_preheat_m1_e4_only);
+            #endif
+            #if HOTENDS > 5
+              #if HAS_HEATED_BED
+                MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H6, lcd_preheat_m1_e5);
+                MENU_ITEM(function, MSG_PREHEAT_1_END " " MSG_E6, lcd_preheat_m1_e5_only);
+              #else
+                MENU_ITEM(function, MSG_PREHEAT_1_N MSG_H6, lcd_preheat_m1_e5_only);
+              #endif
+            #endif // HOTENDS > 5
+          #endif // HOTENDS > 4
+        #endif // HOTENDS > 3
+      #endif // HOTENDS > 2
+      MENU_ITEM(function, MSG_PREHEAT_1_ALL, lcd_preheat_m1_all);
+    #endif // HOTENDS > 1
+    #if HAS_HEATED_BED
+      MENU_ITEM(function, MSG_PREHEAT_1_BEDONLY, lcd_preheat_m1_bedonly);
+    #endif
+    END_MENU();
+  }
+
+  void menu_preheat_m2() {
+    START_MENU();
+    MENU_BACK(MSG_TEMPERATURE);
+    #if HOTENDS == 1
+      #if HAS_HEATED_BED
+        MENU_ITEM(function, MSG_PREHEAT_2, lcd_preheat_m2_e0);
+        MENU_ITEM(function, MSG_PREHEAT_2_END, lcd_preheat_m2_e0_only);
+      #else
+        MENU_ITEM(function, MSG_PREHEAT_2, lcd_preheat_m2_e0_only);
+      #endif
+    #elif HOTENDS > 1
+      #if HAS_HEATED_BED
+        MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H1, lcd_preheat_m2_e0);
+        MENU_ITEM(function, MSG_PREHEAT_2_END " " MSG_E1, lcd_preheat_m2_e0_only);
+        MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H2, lcd_preheat_m2_e1);
+        MENU_ITEM(function, MSG_PREHEAT_2_END " " MSG_E2, lcd_preheat_m2_e1_only);
+      #else
+        MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H1, lcd_preheat_m2_e0_only);
+        MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H2, lcd_preheat_m2_e1_only);
+      #endif
+      #if HOTENDS > 2
+        #if HAS_HEATED_BED
+          MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H3, lcd_preheat_m2_e2);
+          MENU_ITEM(function, MSG_PREHEAT_2_END " " MSG_E3, lcd_preheat_m2_e2_only);
+        #else
+          MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H3, lcd_preheat_m2_e2_only);
+        #endif
+        #if HOTENDS > 3
+          #if HAS_HEATED_BED
+            MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H4, lcd_preheat_m2_e3);
+            MENU_ITEM(function, MSG_PREHEAT_2_END " " MSG_E4, lcd_preheat_m2_e3_only);
+          #else
+            MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H4, lcd_preheat_m2_e3_only);
+          #endif
+          #if HOTENDS > 4
+            #if HAS_HEATED_BED
+              MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H5, lcd_preheat_m2_e4);
+              MENU_ITEM(function, MSG_PREHEAT_2_END " " MSG_E5, lcd_preheat_m2_e4_only);
+            #else
+              MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H5, lcd_preheat_m2_e4_only);
+            #endif
+            #if HOTENDS > 5
+              #if HAS_HEATED_BED
+                MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H6, lcd_preheat_m2_e5);
+                MENU_ITEM(function, MSG_PREHEAT_2_END " " MSG_E6, lcd_preheat_m2_e5_only);
+              #else
+                MENU_ITEM(function, MSG_PREHEAT_2_N MSG_H6, lcd_preheat_m2_e5_only);
+              #endif
+            #endif // HOTENDS > 5
+          #endif // HOTENDS > 4
+        #endif // HOTENDS > 3
+      #endif // HOTENDS > 2
+      MENU_ITEM(function, MSG_PREHEAT_2_ALL, lcd_preheat_m2_all);
+    #endif // HOTENDS > 1
+    #if HAS_HEATED_BED
+      MENU_ITEM(function, MSG_PREHEAT_2_BEDONLY, lcd_preheat_m2_bedonly);
+    #endif
+    END_MENU();
+  }
+
+#endif // HAS_TEMP_HOTEND || HAS_HEATED_BED
+
+void lcd_cooldown() {
+  zero_fan_speeds();
+  thermalManager.disable_all_heaters();
+  lcd_return_to_status();
+}
+
+#if ENABLED(AUTO_BED_LEVELING_UBL) || ENABLED(PID_AUTOTUNE_MENU) || ENABLED(ADVANCED_PAUSE_FEATURE)
+
+  void lcd_enqueue_command(const char * const cmd) {
+    no_reentry = true;
+    enqueue_and_echo_command_now(cmd);
+    no_reentry = false;
+  }
+
+  void lcd_enqueue_commands_P(PGM_P const cmd) {
+    no_reentry = true;
+    enqueue_and_echo_commands_now_P(cmd);
+    no_reentry = false;
+  }
+
+#endif
+
+#if ENABLED(EEPROM_SETTINGS)
+  static void lcd_store_settings()   { lcd_completion_feedback(settings.save()); }
+  static void lcd_load_settings()    { lcd_completion_feedback(settings.load()); }
+#endif
+
+void _lcd_draw_homing() {
+  constexpr uint8_t line = (LCD_HEIGHT - 1) / 2;
+  if (lcdDrawUpdate) lcd_implementation_drawmenu_static(line, PSTR(MSG_LEVEL_BED_HOMING));
+  lcdDrawUpdate = LCDVIEW_CALL_NO_REDRAW;
+}
+
+#if ENABLED(LEVEL_BED_CORNERS)
+
+  /**
+   * Level corners, starting in the front-left corner.
+   */
+  static int8_t bed_corner;
+  void _lcd_goto_next_corner() {
+    line_to_z(4.0);
+    switch (bed_corner) {
+      case 0:
+        current_position[X_AXIS] = X_MIN_BED + LEVEL_CORNERS_INSET;
+        current_position[Y_AXIS] = Y_MIN_BED + LEVEL_CORNERS_INSET;
+        break;
+      case 1:
+        current_position[X_AXIS] = X_MAX_BED - LEVEL_CORNERS_INSET;
+        break;
+      case 2:
+        current_position[Y_AXIS] = Y_MAX_BED - LEVEL_CORNERS_INSET;
+        break;
+      case 3:
+        current_position[X_AXIS] = X_MIN_BED + LEVEL_CORNERS_INSET;
+        break;
+      #if ENABLED(LEVEL_CENTER_TOO)
+        case 4:
+          current_position[X_AXIS] = X_CENTER;
+          current_position[Y_AXIS] = Y_CENTER;
+          break;
+      #endif
+    }
+    planner.buffer_line(current_position, MMM_TO_MMS(manual_feedrate_mm_m[X_AXIS]), active_extruder);
+    line_to_z(0.0);
+    if (++bed_corner > 3
+      #if ENABLED(LEVEL_CENTER_TOO)
+        + 1
+      #endif
+    ) bed_corner = 0;
+  }
+
+  void _lcd_corner_submenu() {
+    START_MENU();
+    MENU_ITEM(function,
+      #if ENABLED(LEVEL_CENTER_TOO)
+        MSG_LEVEL_BED_NEXT_POINT
+      #else
+        MSG_NEXT_CORNER
+      #endif
+      , _lcd_goto_next_corner);
+    MENU_ITEM(function, MSG_BACK, lcd_goto_previous_menu_no_defer);
+    END_MENU();
+  }
+
+  void _lcd_level_bed_corners_homing() {
+    _lcd_draw_homing();
+    if (all_axes_homed()) {
+      bed_corner = 0;
+      lcd_goto_screen(_lcd_corner_submenu);
+      _lcd_goto_next_corner();
+    }
+  }
+
+  void _lcd_level_bed_corners() {
+    defer_return_to_status = true;
+    if (!all_axes_known()) {
+      axis_homed = 0;
+      enqueue_and_echo_commands_P(PSTR("G28"));
+    }
+    lcd_goto_screen(_lcd_level_bed_corners_homing);
+  }
+
+#endif // LEVEL_BED_CORNERS
+
+#if ENABLED(LCD_BED_LEVELING) && (ENABLED(PROBE_MANUALLY) || ENABLED(MESH_BED_LEVELING))
+
+  /**
+   *
+   * "Motion" > "Level Bed" handlers
+   *
+   */
+
+  static uint8_t manual_probe_index;
+
+  // LCD probed points are from defaults
+  constexpr uint8_t total_probe_points = (
+    #if ENABLED(AUTO_BED_LEVELING_3POINT)
+      3
+    #elif ABL_GRID || ENABLED(MESH_BED_LEVELING)
+      GRID_MAX_POINTS
+    #endif
+  );
+
+  bool lcd_wait_for_move;
+
+  //
+  // Bed leveling is done. Wait for G29 to complete.
+  // A flag is used so that this can release control
+  // and allow the command queue to be processed.
+  //
+  // When G29 finishes the last move:
+  // - Raise Z to the "manual probe height"
+  // - Don't return until done.
+  //
+  // ** This blocks the command queue! **
+  //
+  void _lcd_level_bed_done() {
+    if (!lcd_wait_for_move) {
+      #if MANUAL_PROBE_HEIGHT > 0 && DISABLED(MESH_BED_LEVELING)
+        // Display "Done" screen and wait for moves to complete
+        line_to_z(MANUAL_PROBE_HEIGHT);
+        lcd_synchronize(PSTR(MSG_LEVEL_BED_DONE));
+      #endif
+      lcd_goto_previous_menu_no_defer();
+      lcd_completion_feedback();
+    }
+    if (lcdDrawUpdate) lcd_implementation_drawmenu_static(LCD_HEIGHT >= 4 ? 1 : 0, PSTR(MSG_LEVEL_BED_DONE));
+    lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
+  }
+
+  void _lcd_level_goto_next_point();
+
+  /**
+   * Step 7: Get the Z coordinate, click goes to the next point or exits
+   */
+  void _lcd_level_bed_get_z() {
+    ENCODER_DIRECTION_NORMAL();
+
+    if (use_click()) {
+
+      //
+      // Save the current Z position and move
+      //
+
+      // If done...
+      if (++manual_probe_index >= total_probe_points) {
+        //
+        // The last G29 records the point and enables bed leveling
+        //
+        lcd_wait_for_move = true;
+        lcd_goto_screen(_lcd_level_bed_done);
+        #if ENABLED(MESH_BED_LEVELING)
+          enqueue_and_echo_commands_P(PSTR("G29 S2"));
+        #elif ENABLED(PROBE_MANUALLY)
+          enqueue_and_echo_commands_P(PSTR("G29 V1"));
+        #endif
+      }
+      else
+        _lcd_level_goto_next_point();
+
+      return;
+    }
+
+    //
+    // Encoder knob or keypad buttons adjust the Z position
+    //
+    if (encoderPosition) {
+      const float z = current_position[Z_AXIS] + float((int32_t)encoderPosition) * (MBL_Z_STEP);
+      line_to_z(constrain(z, -(LCD_PROBE_Z_RANGE) * 0.5f, (LCD_PROBE_Z_RANGE) * 0.5f));
+      lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
+      encoderPosition = 0;
+    }
+
+    //
+    // Draw on first display, then only on Z change
+    //
+    if (lcdDrawUpdate) {
+      const float v = current_position[Z_AXIS];
+      lcd_implementation_drawedit(PSTR(MSG_MOVE_Z), ftostr43sign(v + (v < 0 ? -0.0001f : 0.0001f), '+'));
+    }
+  }
+
+  /**
+   * Step 6: Display "Next point: 1 / 9" while waiting for move to finish
+   */
+  void _lcd_level_bed_moving() {
+    if (lcdDrawUpdate) {
+      char msg[10];
+      sprintf_P(msg, PSTR("%i / %u"), (int)(manual_probe_index + 1), total_probe_points);
+      lcd_implementation_drawedit(PSTR(MSG_LEVEL_BED_NEXT_POINT), msg);
+    }
+    lcdDrawUpdate = LCDVIEW_CALL_NO_REDRAW;
+    if (!lcd_wait_for_move) lcd_goto_screen(_lcd_level_bed_get_z);
+  }
+
+  /**
+   * Step 5: Initiate a move to the next point
+   */
+  void _lcd_level_goto_next_point() {
+    lcd_goto_screen(_lcd_level_bed_moving);
+
+    // G29 Records Z, moves, and signals when it pauses
+    lcd_wait_for_move = true;
+    #if ENABLED(MESH_BED_LEVELING)
+      enqueue_and_echo_commands_P(manual_probe_index ? PSTR("G29 S2") : PSTR("G29 S1"));
+    #elif ENABLED(PROBE_MANUALLY)
+      enqueue_and_echo_commands_P(PSTR("G29 V1"));
+    #endif
+  }
+
+  /**
+   * Step 4: Display "Click to Begin", wait for click
+   *         Move to the first probe position
+   */
+  void _lcd_level_bed_homing_done() {
+    if (lcdDrawUpdate) lcd_implementation_drawedit(PSTR(MSG_LEVEL_BED_WAITING));
+    if (use_click()) {
+      manual_probe_index = 0;
+      _lcd_level_goto_next_point();
+    }
+  }
+
+  /**
+   * Step 3: Display "Homing XYZ" - Wait for homing to finish
+   */
+  void _lcd_level_bed_homing() {
+    _lcd_draw_homing();
+    if (all_axes_homed()) lcd_goto_screen(_lcd_level_bed_homing_done);
+  }
+
+  #if ENABLED(PROBE_MANUALLY)
+    extern bool g29_in_progress;
+  #endif
+
+  /**
+   * Step 2: Continue Bed Leveling...
+   */
+  void _lcd_level_bed_continue() {
+    defer_return_to_status = true;
+    axis_homed = 0;
+    lcd_goto_screen(_lcd_level_bed_homing);
+    enqueue_and_echo_commands_P(PSTR("G28"));
+  }
+
+#elif ENABLED(AUTO_BED_LEVELING_UBL)
+
+  void _lcd_ubl_level_bed();
+
+  static int16_t ubl_storage_slot = 0,
+             custom_hotend_temp = 190,
+             side_points = 3,
+             ubl_fillin_amount = 5,
+             ubl_height_amount = 1,
+             n_edit_pts = 1,
+             x_plot = 0,
+             y_plot = 0;
+
+  #if HAS_HEATED_BED
+    static int16_t custom_bed_temp = 50;
+  #endif
+
+  /**
+   * UBL Build Custom Mesh Command
+   */
+  void _lcd_ubl_build_custom_mesh() {
+    char UBL_LCD_GCODE[20];
+    enqueue_and_echo_commands_P(PSTR("G28"));
+    #if HAS_HEATED_BED
+      sprintf_P(UBL_LCD_GCODE, PSTR("M190 S%i"), custom_bed_temp);
+      lcd_enqueue_command(UBL_LCD_GCODE);
+    #endif
+    sprintf_P(UBL_LCD_GCODE, PSTR("M109 S%i"), custom_hotend_temp);
+    lcd_enqueue_command(UBL_LCD_GCODE);
+    enqueue_and_echo_commands_P(PSTR("G29 P1"));
+  }
+
+  /**
+   * UBL Custom Mesh submenu
+   *
+   * << Build Mesh
+   *    Hotend Temp: ---
+   *    Bed Temp: ---
+   *    Build Custom Mesh
+   */
+  void _lcd_ubl_custom_mesh() {
+    START_MENU();
+    MENU_BACK(MSG_UBL_BUILD_MESH_MENU);
+    MENU_ITEM_EDIT(int3, MSG_UBL_HOTEND_TEMP_CUSTOM, &custom_hotend_temp, EXTRUDE_MINTEMP, (HEATER_0_MAXTEMP - 10));
+    #if HAS_HEATED_BED
+      MENU_ITEM_EDIT(int3, MSG_UBL_BED_TEMP_CUSTOM, &custom_bed_temp, BED_MINTEMP, (BED_MAXTEMP - 15));
+    #endif
+    MENU_ITEM(function, MSG_UBL_BUILD_CUSTOM_MESH, _lcd_ubl_build_custom_mesh);
+    END_MENU();
+  }
+
+  /**
+   * UBL Adjust Mesh Height Command
+   */
+  void _lcd_ubl_adjust_height_cmd() {
+    char UBL_LCD_GCODE[16];
+    const int ind = ubl_height_amount > 0 ? 9 : 10;
+    strcpy_P(UBL_LCD_GCODE, PSTR("G29 P6 C -"));
+    sprintf_P(&UBL_LCD_GCODE[ind], PSTR(".%i"), ABS(ubl_height_amount));
+    lcd_enqueue_command(UBL_LCD_GCODE);
+  }
+
+  /**
+   * UBL Adjust Mesh Height submenu
+   *
+   * << Edit Mesh
+   *    Height Amount: ---
+   *    Adjust Mesh Height
+   * << Info Screen
+   */
+  void _menu_ubl_height_adjust() {
+    START_MENU();
+    MENU_BACK(MSG_UBL_EDIT_MESH_MENU);
+    MENU_ITEM_EDIT_CALLBACK(int3, MSG_UBL_MESH_HEIGHT_AMOUNT, &ubl_height_amount, -9, 9, _lcd_ubl_adjust_height_cmd);
+    MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
+    END_MENU();
+  }
+
+  /**
+   * UBL Edit Mesh submenu
+   *
+   * << UBL Tools
+   *    Fine Tune All
+   *    Fine Tune Closest
+   *  - Adjust Mesh Height >>
+   * << Info Screen
+   */
+  void _lcd_ubl_edit_mesh() {
+    START_MENU();
+    MENU_BACK(MSG_UBL_TOOLS);
+    MENU_ITEM(gcode, MSG_UBL_FINE_TUNE_ALL, PSTR("G29 P4 R999 T"));
+    MENU_ITEM(gcode, MSG_UBL_FINE_TUNE_CLOSEST, PSTR("G29 P4 T"));
+    MENU_ITEM(submenu, MSG_UBL_MESH_HEIGHT_ADJUST, _menu_ubl_height_adjust);
+    MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
+    END_MENU();
+  }
+
+  /**
+   * UBL Validate Custom Mesh Command
+   */
+  void _lcd_ubl_validate_custom_mesh() {
+    char UBL_LCD_GCODE[24];
+    const int temp =
+      #if HAS_HEATED_BED
+        custom_bed_temp
+      #else
+        0
+      #endif
+    ;
+    sprintf_P(UBL_LCD_GCODE, PSTR("G26 C B%i H%i P"), temp, custom_hotend_temp);
+    lcd_enqueue_commands_P(PSTR("G28"));
+    lcd_enqueue_command(UBL_LCD_GCODE);
+  }
+
+  /**
+   * UBL Validate Mesh submenu
+   *
+   * << UBL Tools
+   *    Mesh Validation with Material 1
+   *    Mesh Validation with Material 2
+   *    Validate Custom Mesh
+   * << Info Screen
+   */
+  void _lcd_ubl_validate_mesh() {
+    START_MENU();
+    MENU_BACK(MSG_UBL_TOOLS);
+    #if HAS_HEATED_BED
+      MENU_ITEM(gcode, MSG_UBL_VALIDATE_MESH_M1, PSTR("G28\nG26 C B" STRINGIFY(PREHEAT_1_TEMP_BED) " H" STRINGIFY(PREHEAT_1_TEMP_HOTEND) " P"));
+      MENU_ITEM(gcode, MSG_UBL_VALIDATE_MESH_M2, PSTR("G28\nG26 C B" STRINGIFY(PREHEAT_2_TEMP_BED) " H" STRINGIFY(PREHEAT_2_TEMP_HOTEND) " P"));
+    #else
+      MENU_ITEM(gcode, MSG_UBL_VALIDATE_MESH_M1, PSTR("G28\nG26 C B0 H" STRINGIFY(PREHEAT_1_TEMP_HOTEND) " P"));
+      MENU_ITEM(gcode, MSG_UBL_VALIDATE_MESH_M2, PSTR("G28\nG26 C B0 H" STRINGIFY(PREHEAT_2_TEMP_HOTEND) " P"));
+    #endif
+    MENU_ITEM(function, MSG_UBL_VALIDATE_CUSTOM_MESH, _lcd_ubl_validate_custom_mesh);
+    MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
+    END_MENU();
+  }
+
+  /**
+   * UBL Grid Leveling Command
+   */
+  void _lcd_ubl_grid_level_cmd() {
+    char UBL_LCD_GCODE[10];
+    sprintf_P(UBL_LCD_GCODE, PSTR("G29 J%i"), side_points);
+    lcd_enqueue_command(UBL_LCD_GCODE);
+  }
+
+  /**
+   * UBL Grid Leveling submenu
+   *
+   * << UBL Tools
+   *    Side points: ---
+   *    Level Mesh
+   */
+  void _lcd_ubl_grid_level() {
+    START_MENU();
+    MENU_BACK(MSG_UBL_TOOLS);
+    MENU_ITEM_EDIT(int3, MSG_UBL_SIDE_POINTS, &side_points, 2, 6);
+    MENU_ITEM(function, MSG_UBL_MESH_LEVEL, _lcd_ubl_grid_level_cmd);
+    END_MENU();
+  }
+
+  /**
+   * UBL Mesh Leveling submenu
+   *
+   * << UBL Tools
+   *    3-Point Mesh Leveling
+   *  - Grid Mesh Leveling >>
+   * << Info Screen
+   */
+  void _lcd_ubl_mesh_leveling() {
+    START_MENU();
+    MENU_BACK(MSG_UBL_TOOLS);
+    MENU_ITEM(gcode, MSG_UBL_3POINT_MESH_LEVELING, PSTR("G29 J0"));
+    MENU_ITEM(submenu, MSG_UBL_GRID_MESH_LEVELING, _lcd_ubl_grid_level);
+    MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
+    END_MENU();
+  }
+
+  /**
+   * UBL Fill-in Amount Mesh Command
+   */
+  void _lcd_ubl_fillin_amount_cmd() {
+    char UBL_LCD_GCODE[16];
+    sprintf_P(UBL_LCD_GCODE, PSTR("G29 P3 R C.%i"), ubl_fillin_amount);
+    lcd_enqueue_command(UBL_LCD_GCODE);
+  }
+
+  /**
+   * UBL Fill-in Mesh submenu
+   *
+   * << Build Mesh
+   *    Fill-in Amount: ---
+   *    Fill-in Mesh
+   *    Smart Fill-in
+   *    Manual Fill-in
+   * << Info Screen
+   */
+  void _menu_ubl_fillin() {
+    START_MENU();
+    MENU_BACK(MSG_UBL_BUILD_MESH_MENU);
+    MENU_ITEM_EDIT_CALLBACK(int3, MSG_UBL_FILLIN_AMOUNT, &ubl_fillin_amount, 0, 9, _lcd_ubl_fillin_amount_cmd);
+    MENU_ITEM(gcode, MSG_UBL_SMART_FILLIN, PSTR("G29 P3 T0"));
+    MENU_ITEM(gcode, MSG_UBL_MANUAL_FILLIN, PSTR("G29 P2 B T0"));
+    MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
+    END_MENU();
+  }
+
+  void _lcd_ubl_invalidate() {
+    ubl.invalidate();
+    SERIAL_PROTOCOLLNPGM("Mesh invalidated.");
+  }
+
+  /**
+   * UBL Build Mesh submenu
+   *
+   * << UBL Tools
+   *    Build Mesh with Material 1
+   *    Build Mesh with Material 2
+   *  - Build Custom Mesh >>
+   *    Build Cold Mesh
+   *  - Fill-in Mesh >>
+   *    Continue Bed Mesh
+   *    Invalidate All
+   *    Invalidate Closest
+   * << Info Screen
+   */
+  void _lcd_ubl_build_mesh() {
+    START_MENU();
+    MENU_BACK(MSG_UBL_TOOLS);
+    #if HAS_HEATED_BED
+      MENU_ITEM(gcode, MSG_UBL_BUILD_MESH_M1, PSTR(
+        "G28\n"
+        "M190 S" STRINGIFY(PREHEAT_1_TEMP_BED) "\n"
+        "M109 S" STRINGIFY(PREHEAT_1_TEMP_HOTEND) "\n"
+        "G29 P1\n"
+        "M104 S0\n"
+        "M140 S0"
+      ));
+      MENU_ITEM(gcode, MSG_UBL_BUILD_MESH_M2, PSTR(
+        "G28\n"
+        "M190 S" STRINGIFY(PREHEAT_2_TEMP_BED) "\n"
+        "M109 S" STRINGIFY(PREHEAT_2_TEMP_HOTEND) "\n"
+        "G29 P1\n"
+        "M104 S0\n"
+        "M140 S0"
+      ));
+    #else
+      MENU_ITEM(gcode, MSG_UBL_BUILD_MESH_M1, PSTR(
+        "G28\n"
+        "M109 S" STRINGIFY(PREHEAT_1_TEMP_HOTEND) "\n"
+        "G29 P1\n"
+        "M104 S0"
+      ));
+      MENU_ITEM(gcode, MSG_UBL_BUILD_MESH_M2, PSTR(
+        "G28\n"
+        "M109 S" STRINGIFY(PREHEAT_2_TEMP_HOTEND) "\n"
+        "G29 P1\n"
+        "M104 S0"
+      ));
+    #endif
+    MENU_ITEM(submenu, MSG_UBL_BUILD_CUSTOM_MESH, _lcd_ubl_custom_mesh);
+    MENU_ITEM(gcode, MSG_UBL_BUILD_COLD_MESH, PSTR("G28\nG29 P1"));
+    MENU_ITEM(submenu, MSG_UBL_FILLIN_MESH, _menu_ubl_fillin);
+    MENU_ITEM(gcode, MSG_UBL_CONTINUE_MESH, PSTR("G29 P1 C"));
+    MENU_ITEM(function, MSG_UBL_INVALIDATE_ALL, _lcd_ubl_invalidate);
+    MENU_ITEM(gcode, MSG_UBL_INVALIDATE_CLOSEST, PSTR("G29 I"));
+    MENU_ITEM(function, MSG_WATCH, lcd_return_to_status);
+    END_MENU();
+  }
+
+  /**
+   * UBL Load Mesh Command
+   */
+  void _lcd_ubl_load_mesh_cmd() {
+    char UBL_LCD_GCODE[25];
+    sprintf_P(UBL_LCD_GCODE, PSTR("G29 L%i"), ubl_storage_slot);
+    lcd_enqueue_command(UBL_LCD_GCODE);
+    sprintf_P(UBL_LCD_GCODE, PSTR("M117 " MSG_MESH_LOADED), ubl_storage_slot);
+    lcd_enqueue_command(UBL_LCD_GCODE);
+  }
+
+  /**
+   * UBL Save Mesh Command
+   */
+  void _lcd_ubl_save_mesh_cmd() {
+    char UBL_LCD_GCODE[25];
+    sprintf_P(UBL_LCD_GCODE, PSTR("G29 S%i"), ubl_storage_slot);
+    lcd_enqueue_command(UBL_LCD_GCODE);
+    sprintf_P(UBL_LCD_GCODE, PSTR("M117 " MSG_MESH_SAVED), ubl_storage_slot);
+    lcd_enqueue_command(UBL_LCD_GCODE);
+  }
+
+  /**
+   * UBL Mesh Storage submenu
+   *
+   * << Unified Bed Leveling
+   *    Memory Slot: ---
+   *    Load Bed Mesh
+   *    Save Bed Mesh
+   */
+  void _lcd_ubl_storage_mesh() {
+    int16_t a = settings.calc_num_meshes();
+    START_MENU();
+    MENU_BACK(MSG_UBL_LEVEL_BED);
+    if (!WITHIN(ubl_storage_slot, 0, a - 1)) {
+      STATIC_ITEM(MSG_NO_STORAGE);
+    }
+    else {
+      MENU_ITEM_EDIT(int3, MSG_UBL_STORAGE_SLOT, &ubl_storage_slot, 0, a - 1);
+      MENU_ITEM(function, MSG_UBL_LOAD_MESH, _lcd_ubl_load_mesh_cmd);
+      MENU_ITEM(function, MSG_UBL_SAVE_MESH, _lcd_ubl_save_mesh_cmd);
+    }
+    END_MENU();
+  }
+
+  /**
+   * UBL LCD "radar" map homing
+   */
+  void _lcd_ubl_output_map_lcd();
+
+  void _lcd_ubl_map_homing() {
+    defer_return_to_status = true;
+    _lcd_draw_homing();
+    if (all_axes_homed()) {
+      ubl.lcd_map_control = true; // Return to the map screen
+      lcd_goto_screen(_lcd_ubl_output_map_lcd);
+    }
+  }
+
+  /**
+   * UBL LCD "radar" map point editing
+   */
+  void _lcd_ubl_map_lcd_edit_cmd() {
+    char UBL_LCD_GCODE[50], str[10], str2[10];
+    dtostrf(pgm_read_float(&ubl._mesh_index_to_xpos[x_plot]), 0, 2, str);
+    dtostrf(pgm_read_float(&ubl._mesh_index_to_ypos[y_plot]), 0, 2, str2);
+    snprintf_P(UBL_LCD_GCODE, sizeof(UBL_LCD_GCODE), PSTR("G29 P4 X%s Y%s R%i"), str, str2, n_edit_pts);
+    lcd_enqueue_command(UBL_LCD_GCODE);
+  }
+
+  /**
+   * UBL LCD Map Movement
+   */
+  void ubl_map_move_to_xy() {
+    current_position[X_AXIS] = pgm_read_float(&ubl._mesh_index_to_xpos[x_plot]);
+    current_position[Y_AXIS] = pgm_read_float(&ubl._mesh_index_to_ypos[y_plot]);
+    planner.buffer_line(current_position, MMM_TO_MMS(XY_PROBE_SPEED), active_extruder);
+  }
+
+  /**
+   * UBL LCD "radar" map
+   */
+  void set_current_from_steppers_for_axis(const AxisEnum axis);
+  void sync_plan_position();
+
+  void _lcd_do_nothing() {}
+  void _lcd_hard_stop() {
+    const screenFunc_t old_screen = currentScreen;
+    currentScreen = _lcd_do_nothing;
+    planner.quick_stop();
+    currentScreen = old_screen;
+    set_current_from_steppers_for_axis(ALL_AXES);
+    sync_plan_position();
+  }
+
+  void _lcd_ubl_output_map_lcd() {
+    static int16_t step_scaler = 0;
+
+    if (use_click()) return _lcd_ubl_map_lcd_edit_cmd();
+    ENCODER_DIRECTION_NORMAL();
+
+    if (encoderPosition) {
+      step_scaler += (int32_t)encoderPosition;
+      x_plot += step_scaler / (ENCODER_STEPS_PER_MENU_ITEM);
+      if (ABS(step_scaler) >= ENCODER_STEPS_PER_MENU_ITEM) step_scaler = 0;
+      encoderPosition = 0;
+      lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
+    }
+
+    // Encoder to the right (++)
+    if (x_plot >= GRID_MAX_POINTS_X) { x_plot = 0; y_plot++; }
+    if (y_plot >= GRID_MAX_POINTS_Y) y_plot = 0;
+
+    // Encoder to the left (--)
+    if (x_plot <= GRID_MAX_POINTS_X - (GRID_MAX_POINTS_X + 1)) { x_plot = GRID_MAX_POINTS_X - 1; y_plot--; }
+    if (y_plot <= GRID_MAX_POINTS_Y - (GRID_MAX_POINTS_Y + 1)) y_plot = GRID_MAX_POINTS_Y - 1;
+
+    // Prevent underrun/overrun of plot numbers
+    x_plot = constrain(x_plot, GRID_MAX_POINTS_X - (GRID_MAX_POINTS_X + 1), GRID_MAX_POINTS_X + 1);
+    y_plot = constrain(y_plot, GRID_MAX_POINTS_Y - (GRID_MAX_POINTS_Y + 1), GRID_MAX_POINTS_Y + 1);
+
+    // Determine number of points to edit
+    #if IS_KINEMATIC
+      n_edit_pts = 9; //TODO: Delta accessible edit points
+    #else
+      const bool xc = WITHIN(x_plot, 1, GRID_MAX_POINTS_X - 2),
+                 yc = WITHIN(y_plot, 1, GRID_MAX_POINTS_Y - 2);
+      n_edit_pts = yc ? (xc ? 9 : 6) : (xc ? 6 : 4); // Corners
+    #endif
+
+    if (lcdDrawUpdate) {
+      lcd_implementation_ubl_plot(x_plot, y_plot);
+
+      if (planner.movesplanned()) // If the nozzle is already moving, cancel the move.
+        _lcd_hard_stop();
+
+      ubl_map_move_to_xy();       // Move to new location
+    }
+  }
+
+  /**
+   * UBL Homing before LCD map
+   */
+  void _lcd_ubl_output_map_lcd_cmd() {
+    if (!all_axes_known()) {
+      axis_homed = 0;
+      enqueue_and_echo_commands_P(PSTR("G28"));
+    }
+    lcd_goto_screen(_lcd_ubl_map_homing);
+  }
+
+  /**
+   * UBL Output map submenu
+   *
+   * << Unified Bed Leveling
+   *  Output for Host
+   *  Output for CSV
+   *  Off Printer Backup
+   *  Output Mesh Map
+   */
+  void _lcd_ubl_output_map() {
+    START_MENU();
+    MENU_BACK(MSG_UBL_LEVEL_BED);
+    MENU_ITEM(gcode, MSG_UBL_OUTPUT_MAP_HOST, PSTR("G29 T0"));
+    MENU_ITEM(gcode, MSG_UBL_OUTPUT_MAP_CSV, PSTR("G29 T1"));
+    MENU_ITEM(gcode, MSG_UBL_OUTPUT_MAP_BACKUP, PSTR("G29 S-1"));
+    MENU_ITEM(function, MSG_UBL_OUTPUT_MAP, _lcd_ubl_output_map_lcd_cmd);
+    END_MENU();
+  }
+
+  /**
+   * UBL Tools submenu
+   *
+   * << Unified Bed Leveling
+   *  - Build Mesh >>
+   *  - Validate Mesh >>
+   *  - Edit Mesh >>
+   *  - Mesh Leveling >>
+   */
+  void _menu_ubl_tools() {
+    START_MENU();
+    MENU_BACK(MSG_UBL_LEVEL_BED);
+    MENU_ITEM(submenu, MSG_UBL_BUILD_MESH_MENU, _lcd_ubl_build_mesh);
+    MENU_ITEM(gcode, MSG_UBL_MANUAL_MESH, PSTR("G29 I999\nG29 P2 B T0"));
+    MENU_ITEM(submenu, MSG_UBL_VALIDATE_MESH_MENU, _lcd_ubl_validate_mesh);
+    MENU_ITEM(submenu, MSG_UBL_EDIT_MESH_MENU, _lcd_ubl_edit_mesh);
+    MENU_ITEM(submenu, MSG_UBL_MESH_LEVELING, _lcd_ubl_mesh_leveling);
+    END_MENU();
+  }
+
+  /**
+   * UBL Step-By-Step submenu
+   *
+   * << Unified Bed Leveling
+   *    1 Build Cold Mesh
+   *    2 Smart Fill-in
+   *  - 3 Validate Mesh >>
+   *    4 Fine Tune All
+   *  - 5 Validate Mesh >>
+   *    6 Fine Tune All
+   *    7 Save Bed Mesh
+   */
+  void _lcd_ubl_step_by_step() {
+    START_MENU();
+    MENU_BACK(MSG_UBL_LEVEL_BED);
+    MENU_ITEM(gcode, "1 " MSG_UBL_BUILD_COLD_MESH, PSTR("G28\nG29 P1"));
+    MENU_ITEM(gcode, "2 " MSG_UBL_SMART_FILLIN, PSTR("G29 P3 T0"));
+    MENU_ITEM(submenu, "3 " MSG_UBL_VALIDATE_MESH_MENU, _lcd_ubl_validate_mesh);
+    MENU_ITEM(gcode, "4 " MSG_UBL_FINE_TUNE_ALL, PSTR("G29 P4 R999 T"));
+    MENU_ITEM(submenu, "5 " MSG_UBL_VALIDATE_MESH_MENU, _lcd_ubl_validate_mesh);
+    MENU_ITEM(gcode, "6 " MSG_UBL_FINE_TUNE_ALL, PSTR("G29 P4 R999 T"));
+    MENU_ITEM(function, "7 " MSG_UBL_SAVE_MESH, _lcd_ubl_save_mesh_cmd);
+    END_MENU();
+  }
+
+  /**
+   * UBL System submenu
+   *
+   * << Motion
+   *  - Manually Build Mesh >>
+   *  - Activate UBL >>
+   *  - Deactivate UBL >>
+   *  - Step-By-Step UBL >>
+   *  - Mesh Storage >>
+   *  - Output Map >>
+   *  - UBL Tools >>
+   *  - Output UBL Info >>
+   */
+
+  void _lcd_ubl_level_bed() {
+    START_MENU();
+    MENU_BACK(MSG_MOTION);
+    MENU_ITEM(gcode, MSG_UBL_ACTIVATE_MESH, PSTR("G29 A"));
+    MENU_ITEM(gcode, MSG_UBL_DEACTIVATE_MESH, PSTR("G29 D"));
+    MENU_ITEM(submenu, MSG_UBL_STEP_BY_STEP_MENU, _lcd_ubl_step_by_step);
+    MENU_ITEM(function, MSG_UBL_MESH_EDIT, _lcd_ubl_output_map_lcd_cmd);
+    MENU_ITEM(submenu, MSG_UBL_STORAGE_MESH_MENU, _lcd_ubl_storage_mesh);
+    MENU_ITEM(submenu, MSG_UBL_OUTPUT_MAP, _lcd_ubl_output_map);
+    MENU_ITEM(submenu, MSG_UBL_TOOLS, _menu_ubl_tools);
+    MENU_ITEM(gcode, MSG_UBL_INFO_UBL, PSTR("G29 W"));
+    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float3, MSG_Z_FADE_HEIGHT, &lcd_z_fade_height, 0, 100, _lcd_set_z_fade_height);
+    #endif
+    END_MENU();
+  }
+
+#endif // AUTO_BED_LEVELING_UBL
+
+#if ENABLED(LCD_BED_LEVELING) || (HAS_LEVELING && DISABLED(SLIM_LCD_MENUS))
+  void _lcd_toggle_bed_leveling() { set_bed_leveling_enabled(!planner.leveling_active); }
+#endif
+
+#if ENABLED(LCD_BED_LEVELING)
+
+  /**
+   * Step 1: Bed Level entry-point
+   *
+   * << Motion
+   *    Auto Home           (if homing needed)
+   *    Leveling On/Off     (if data exists, and homed)
+   *    Fade Height: ---    (Req: ENABLE_LEVELING_FADE_HEIGHT)
+   *    Mesh Z Offset: ---  (Req: MESH_BED_LEVELING)
+   *    Z Probe Offset: --- (Req: HAS_BED_PROBE, Opt: BABYSTEP_ZPROBE_OFFSET)
+   *    Level Bed >
+   *    Level Corners >     (if homed)
+   *    Load Settings       (Req: EEPROM_SETTINGS)
+   *    Save Settings       (Req: EEPROM_SETTINGS)
+   */
+  void menu_bed_leveling() {
+    START_MENU();
+    MENU_BACK(MSG_MOTION);
+
+    const bool is_homed = all_axes_known();
+
+    // Auto Home if not using manual probing
+    #if DISABLED(PROBE_MANUALLY) && DISABLED(MESH_BED_LEVELING)
+      if (!is_homed) MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
+    #endif
+
+    // Level Bed
+    #if ENABLED(PROBE_MANUALLY) || ENABLED(MESH_BED_LEVELING)
+      // Manual leveling uses a guided procedure
+      MENU_ITEM(submenu, MSG_LEVEL_BED, _lcd_level_bed_continue);
+    #else
+      // Automatic leveling can just run the G-code
+      MENU_ITEM(gcode, MSG_LEVEL_BED, is_homed ? PSTR("G29") : PSTR("G28\nG29"));
+    #endif
+
+    // Homed and leveling is valid? Then leveling can be toggled.
+    if (is_homed && leveling_is_valid()) {
+      bool new_level_state = planner.leveling_active;
+      MENU_ITEM_EDIT_CALLBACK(bool, MSG_BED_LEVELING, &new_level_state, _lcd_toggle_bed_leveling);
+    }
+
+    // Z Fade Height
+    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float3, MSG_Z_FADE_HEIGHT, &lcd_z_fade_height, 0, 100, _lcd_set_z_fade_height);
+    #endif
+
+    //
+    // MBL Z Offset
+    //
+    #if ENABLED(MESH_BED_LEVELING)
+      MENU_ITEM_EDIT(float43, MSG_BED_Z, &mbl.z_offset, -1, 1);
+    #endif
+
+    #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
+      MENU_ITEM(submenu, MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
+    #elif HAS_BED_PROBE
+      MENU_ITEM_EDIT(float52, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
+    #endif
+
+    #if ENABLED(LEVEL_BED_CORNERS)
+      // Move to the next corner for leveling
+      MENU_ITEM(submenu, MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
+    #endif
+
+    #if ENABLED(EEPROM_SETTINGS)
+      MENU_ITEM(function, MSG_LOAD_EEPROM, lcd_load_settings);
+      MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
+    #endif
+    END_MENU();
+  }
+
+#endif // LCD_BED_LEVELING
+
+/**
+ *
+ * "Movement" submenu
+ *
+ */
+
+void menu_movement() {
+  START_MENU();
+
+  //
+  // ^ Main
+  //
+  MENU_BACK(MSG_MAIN);
+
+  //
+  // Move Axis
+  //
+  #if ENABLED(DELTA)
+    if (all_axes_homed())
+  #endif
+      MENU_ITEM(submenu, MSG_MOVE_AXIS, menu_move);
+
+  //
+  // Auto Home
+  //
+  MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
+  #if ENABLED(INDIVIDUAL_AXIS_HOMING_MENU)
+    MENU_ITEM(gcode, MSG_AUTO_HOME_X, PSTR("G28 X"));
+    MENU_ITEM(gcode, MSG_AUTO_HOME_Y, PSTR("G28 Y"));
+    MENU_ITEM(gcode, MSG_AUTO_HOME_Z, PSTR("G28 Z"));
+  #endif
+
+  //
+  // TMC Z Calibration
+  //
+  #if ENABLED(TMC_Z_CALIBRATION)
+    MENU_ITEM(gcode, MSG_TMC_Z_CALIBRATION, PSTR("G28\nM915"));
+  #endif
+
+  //
+  // Level Bed
+  //
+  #if ENABLED(AUTO_BED_LEVELING_UBL)
+
+    MENU_ITEM(submenu, MSG_UBL_LEVEL_BED, _lcd_ubl_level_bed);
+
+  #elif ENABLED(LCD_BED_LEVELING)
+
+    #if ENABLED(PROBE_MANUALLY)
+      if (!g29_in_progress)
+    #endif
+        MENU_ITEM(submenu, MSG_BED_LEVELING, menu_bed_leveling);
+
+  #elif HAS_LEVELING && DISABLED(SLIM_LCD_MENUS)
+
+    #if DISABLED(PROBE_MANUALLY)
+      MENU_ITEM(gcode, MSG_LEVEL_BED, PSTR("G28\nG29"));
+    #endif
+    if (leveling_is_valid()) {
+      bool new_level_state = planner.leveling_active;
+      MENU_ITEM_EDIT_CALLBACK(bool, MSG_BED_LEVELING, &new_level_state, _lcd_toggle_bed_leveling);
+    }
+    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float3, MSG_Z_FADE_HEIGHT, &lcd_z_fade_height, 0, 100, _lcd_set_z_fade_height);
+    #endif
+
+  #endif
+
+  #if ENABLED(LEVEL_BED_CORNERS) && DISABLED(LCD_BED_LEVELING)
+      MENU_ITEM(function, MSG_LEVEL_CORNERS, _lcd_level_bed_corners);
+  #endif
+
+  //
+  // Disable Steppers
+  //
+  MENU_ITEM(gcode, MSG_DISABLE_STEPPERS, PSTR("M84"));
+
+  END_MENU();
+}
+
+#if ENABLED(DELTA_CALIBRATION_MENU) || ENABLED(DELTA_AUTO_CALIBRATION)
+
+  void _man_probe_pt(const float &rx, const float &ry) {
+    do_blocking_move_to_z(Z_CLEARANCE_BETWEEN_PROBES);
+    do_blocking_move_to_xy(rx, ry);
+
+    lcd_synchronize();
+    move_menu_scale = MAX(PROBE_MANUALLY_STEP, MIN_STEPS_PER_SEGMENT / float(DEFAULT_XYZ_STEPS_PER_UNIT));
+    lcd_goto_screen(lcd_move_z);
+  }
+
+#endif // DELTA_CALIBRATION_MENU || DELTA_AUTO_CALIBRATION
+
+#if ENABLED(DELTA_AUTO_CALIBRATION)
+
+  float lcd_probe_pt(const float &rx, const float &ry) {
+    _man_probe_pt(rx, ry);
+    KEEPALIVE_STATE(PAUSED_FOR_USER);
+    defer_return_to_status = true;
+    wait_for_user = true;
+    while (wait_for_user) idle();
+    KEEPALIVE_STATE(IN_HANDLER);
+    lcd_goto_previous_menu_no_defer();
+    return current_position[Z_AXIS];
+  }
+
+#endif // DELTA_AUTO_CALIBRATION
+
+#if ENABLED(DELTA_CALIBRATION_MENU)
+
+  void _lcd_calibrate_homing() {
+    _lcd_draw_homing();
+    if (all_axes_homed()) lcd_goto_previous_menu();
+  }
+
+  void _lcd_delta_calibrate_home() {
+    enqueue_and_echo_commands_P(PSTR("G28"));
+    lcd_goto_screen(_lcd_calibrate_homing);
+  }
+
+  void _goto_tower_x() { _man_probe_pt(cos(RADIANS(210)) * delta_calibration_radius, sin(RADIANS(210)) * delta_calibration_radius); }
+  void _goto_tower_y() { _man_probe_pt(cos(RADIANS(330)) * delta_calibration_radius, sin(RADIANS(330)) * delta_calibration_radius); }
+  void _goto_tower_z() { _man_probe_pt(cos(RADIANS( 90)) * delta_calibration_radius, sin(RADIANS( 90)) * delta_calibration_radius); }
+  void _goto_center()  { _man_probe_pt(0,0); }
+
+#endif // DELTA_CALIBRATION_MENU
+
+#if ENABLED(DELTA_CALIBRATION_MENU) || ENABLED(DELTA_AUTO_CALIBRATION)
+
+  void _recalc_delta_settings() {
+    #if HAS_LEVELING
+      reset_bed_level(); // After changing kinematics bed-level data is no longer valid
+    #endif
+    recalc_delta_settings();
+  }
+
+  void lcd_delta_settings() {
+    START_MENU();
+    MENU_BACK(MSG_DELTA_CALIBRATE);
+    MENU_ITEM_EDIT_CALLBACK(float52sign, MSG_DELTA_HEIGHT, &delta_height, delta_height - 10, delta_height + 10, _recalc_delta_settings);
+    MENU_ITEM_EDIT_CALLBACK(float43, "Ex", &delta_endstop_adj[A_AXIS], -5, 5, _recalc_delta_settings);
+    MENU_ITEM_EDIT_CALLBACK(float43, "Ey", &delta_endstop_adj[B_AXIS], -5, 5, _recalc_delta_settings);
+    MENU_ITEM_EDIT_CALLBACK(float43, "Ez", &delta_endstop_adj[C_AXIS], -5, 5, _recalc_delta_settings);
+    MENU_ITEM_EDIT_CALLBACK(float52sign, MSG_DELTA_RADIUS, &delta_radius, delta_radius - 5, delta_radius + 5, _recalc_delta_settings);
+    MENU_ITEM_EDIT_CALLBACK(float43, "Tx", &delta_tower_angle_trim[A_AXIS], -5, 5, _recalc_delta_settings);
+    MENU_ITEM_EDIT_CALLBACK(float43, "Ty", &delta_tower_angle_trim[B_AXIS], -5, 5, _recalc_delta_settings);
+    MENU_ITEM_EDIT_CALLBACK(float43, "Tz", &delta_tower_angle_trim[C_AXIS], -5, 5, _recalc_delta_settings);
+    MENU_ITEM_EDIT_CALLBACK(float52sign, MSG_DELTA_DIAG_ROD, &delta_diagonal_rod, delta_diagonal_rod - 5, delta_diagonal_rod + 5, _recalc_delta_settings);
+    END_MENU();
+  }
+
+  void menu_delta_calibrate() {
+    START_MENU();
+    MENU_BACK(MSG_MAIN);
+    #if ENABLED(DELTA_AUTO_CALIBRATION)
+      MENU_ITEM(gcode, MSG_DELTA_AUTO_CALIBRATE, PSTR("G33"));
+      MENU_ITEM(gcode, MSG_DELTA_HEIGHT_CALIBRATE, PSTR("G33 S P1"));
+      MENU_ITEM(gcode, MSG_DELTA_Z_OFFSET_CALIBRATE, PSTR("G33 P-1"));
+      #if ENABLED(EEPROM_SETTINGS)
+        MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
+        MENU_ITEM(function, MSG_LOAD_EEPROM, lcd_load_settings);
+      #endif
+    #endif
+    MENU_ITEM(submenu, MSG_DELTA_SETTINGS, lcd_delta_settings);
+    #if ENABLED(DELTA_CALIBRATION_MENU)
+      MENU_ITEM(submenu, MSG_AUTO_HOME, _lcd_delta_calibrate_home);
+      if (all_axes_homed()) {
+        MENU_ITEM(submenu, MSG_DELTA_CALIBRATE_X, _goto_tower_x);
+        MENU_ITEM(submenu, MSG_DELTA_CALIBRATE_Y, _goto_tower_y);
+        MENU_ITEM(submenu, MSG_DELTA_CALIBRATE_Z, _goto_tower_z);
+        MENU_ITEM(submenu, MSG_DELTA_CALIBRATE_CENTER, _goto_center);
+      }
+    #endif
+    END_MENU();
+  }
+
+#endif // DELTA_CALIBRATION_MENU || DELTA_AUTO_CALIBRATION
+
+/**
+ * Set a flag that lcd_update() should start a move
+ * to "current_position" after a short delay.
+ */
+inline void manual_move_to_current(AxisEnum axis
+  #if E_MANUAL > 1
+    , const int8_t eindex=-1
+  #endif
+) {
+  #if ENABLED(DUAL_X_CARRIAGE) || E_MANUAL > 1
+    #if E_MANUAL > 1
+      if (axis == E_AXIS)
+    #endif
+        manual_move_e_index = eindex >= 0 ? eindex : active_extruder;
+  #endif
+  manual_move_start_time = millis() + (move_menu_scale < 0.99f ? 0UL : 250UL); // delay for bigger moves
+  manual_move_axis = (int8_t)axis;
+}
+
+/**
+ *
+ * "Motion" > "Move Axis" submenu
+ *
+ */
+
+void _lcd_move_xyz(PGM_P name, AxisEnum axis) {
+  if (use_click()) { return lcd_goto_previous_menu_no_defer(); }
+  ENCODER_DIRECTION_NORMAL();
+  if (encoderPosition && !processing_manual_move) {
+
+    // Start with no limits to movement
+    float min = current_position[axis] - 1000,
+          max = current_position[axis] + 1000;
+
+    // Limit to software endstops, if enabled
+    #if ENABLED(MIN_SOFTWARE_ENDSTOPS) || ENABLED(MAX_SOFTWARE_ENDSTOPS)
+      if (soft_endstops_enabled) switch (axis) {
+        case X_AXIS:
+          #if ENABLED(MIN_SOFTWARE_ENDSTOP_X)
+            min = soft_endstop_min[X_AXIS];
+          #endif
+          #if ENABLED(MAX_SOFTWARE_ENDSTOP_X)
+            max = soft_endstop_max[X_AXIS];
+          #endif
+          break;
+        case Y_AXIS:
+          #if ENABLED(MIN_SOFTWARE_ENDSTOP_Y)
+            min = soft_endstop_min[Y_AXIS];
+          #endif
+          #if ENABLED(MAX_SOFTWARE_ENDSTOP_Y)
+            max = soft_endstop_max[Y_AXIS];
+          #endif
+          break;
+        case Z_AXIS:
+          #if ENABLED(MIN_SOFTWARE_ENDSTOP_Z)
+            min = soft_endstop_min[Z_AXIS];
+          #endif
+          #if ENABLED(MAX_SOFTWARE_ENDSTOP_Z)
+            max = soft_endstop_max[Z_AXIS];
+          #endif
+        default: break;
+      }
+    #endif // MIN_SOFTWARE_ENDSTOPS || MAX_SOFTWARE_ENDSTOPS
+
+    // Delta limits XY based on the current offset from center
+    // This assumes the center is 0,0
+    #if ENABLED(DELTA)
+      if (axis != Z_AXIS) {
+        max = SQRT(sq((float)(DELTA_PRINTABLE_RADIUS)) - sq(current_position[Y_AXIS - axis])); // (Y_AXIS - axis) == the other axis
+        min = -max;
+      }
+    #endif
+
+    // Get the new position
+    const float diff = float((int32_t)encoderPosition) * move_menu_scale;
+    #if IS_KINEMATIC
+      manual_move_offset += diff;
+      if ((int32_t)encoderPosition < 0)
+        NOLESS(manual_move_offset, min - current_position[axis]);
+      else
+        NOMORE(manual_move_offset, max - current_position[axis]);
+    #else
+      current_position[axis] += diff;
+      if ((int32_t)encoderPosition < 0)
+        NOLESS(current_position[axis], min);
+      else
+        NOMORE(current_position[axis], max);
+    #endif
+
+    manual_move_to_current(axis);
+    lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
+  }
+  encoderPosition = 0;
+  if (lcdDrawUpdate) {
+    const float pos = NATIVE_TO_LOGICAL(processing_manual_move ? destination[axis] : current_position[axis]
+      #if IS_KINEMATIC
+        + manual_move_offset
+      #endif
+    , axis);
+    lcd_implementation_drawedit(name, move_menu_scale >= 0.1f ? ftostr41sign(pos) : ftostr43sign(pos));
+  }
+}
+void lcd_move_x() { _lcd_move_xyz(PSTR(MSG_MOVE_X), X_AXIS); }
+void lcd_move_y() { _lcd_move_xyz(PSTR(MSG_MOVE_Y), Y_AXIS); }
+void lcd_move_z() { _lcd_move_xyz(PSTR(MSG_MOVE_Z), Z_AXIS); }
+void _lcd_move_e(
+  #if E_MANUAL > 1
+    const int8_t eindex=-1
+  #endif
+) {
+  if (use_click()) { return lcd_goto_previous_menu_no_defer(); }
+  ENCODER_DIRECTION_NORMAL();
+  if (encoderPosition) {
+    if (!processing_manual_move) {
+      const float diff = float((int32_t)encoderPosition) * move_menu_scale;
+      #if IS_KINEMATIC
+        manual_move_offset += diff;
+      #else
+        current_position[E_AXIS] += diff;
+      #endif
+      manual_move_to_current(E_AXIS
+        #if E_MANUAL > 1
+          , eindex
+        #endif
+      );
+      lcdDrawUpdate = LCDVIEW_REDRAW_NOW;
+    }
+    encoderPosition = 0;
+  }
+  if (lcdDrawUpdate) {
+    PGM_P pos_label;
+    #if E_MANUAL == 1
+      pos_label = PSTR(MSG_MOVE_E);
+    #else
+      switch (eindex) {
+        default: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E1); break;
+        case 1: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E2); break;
+        #if E_MANUAL > 2
+          case 2: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E3); break;
+          #if E_MANUAL > 3
+            case 3: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E4); break;
+            #if E_MANUAL > 4
+              case 4: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E5); break;
+              #if E_MANUAL > 5
+                case 5: pos_label = PSTR(MSG_MOVE_E MSG_MOVE_E6); break;
+              #endif // E_MANUAL > 5
+            #endif // E_MANUAL > 4
+          #endif // E_MANUAL > 3
+        #endif // E_MANUAL > 2
+      }
+    #endif // E_MANUAL > 1
+
+    lcd_implementation_drawedit(pos_label, ftostr41sign(current_position[E_AXIS]
+      #if IS_KINEMATIC
+        + manual_move_offset
+      #endif
+      #if ENABLED(MANUAL_E_MOVES_RELATIVE)
+        - manual_move_e_origin
+      #endif
+    ));
+  }
+}
+
+void lcd_move_e() { _lcd_move_e(); }
+#if E_MANUAL > 1
+  void lcd_move_e0() { _lcd_move_e(0); }
+  void lcd_move_e1() { _lcd_move_e(1); }
+  #if E_MANUAL > 2
+    void lcd_move_e2() { _lcd_move_e(2); }
+    #if E_MANUAL > 3
+      void lcd_move_e3() { _lcd_move_e(3); }
+      #if E_MANUAL > 4
+        void lcd_move_e4() { _lcd_move_e(4); }
+        #if E_MANUAL > 5
+          void lcd_move_e5() { _lcd_move_e(5); }
+        #endif // E_MANUAL > 5
+      #endif // E_MANUAL > 4
+    #endif // E_MANUAL > 3
+  #endif // E_MANUAL > 2
+#endif // E_MANUAL > 1
+
+/**
+ *
+ * "Motion" > "Move Xmm" > "Move XYZ" submenu
+ *
+ */
+
+screenFunc_t _manual_move_func_ptr;
+
+void _goto_manual_move(const float scale) {
+  defer_return_to_status = true;
+  move_menu_scale = scale;
+  lcd_goto_screen(_manual_move_func_ptr);
+}
+void menu_move_10mm() { _goto_manual_move(10); }
+void menu_move_1mm()  { _goto_manual_move( 1); }
+void menu_move_01mm() { _goto_manual_move( 0.1f); }
+
+void _menu_move_distance(const AxisEnum axis, const screenFunc_t func, const int8_t eindex=-1) {
+  _manual_move_func_ptr = func;
+  START_MENU();
+  if (LCD_HEIGHT >= 4) {
+    switch (axis) {
+      case X_AXIS:
+        STATIC_ITEM(MSG_MOVE_X, true, true); break;
+      case Y_AXIS:
+        STATIC_ITEM(MSG_MOVE_Y, true, true); break;
+      case Z_AXIS:
+        STATIC_ITEM(MSG_MOVE_Z, true, true); break;
+      default:
+        #if ENABLED(MANUAL_E_MOVES_RELATIVE)
+          manual_move_e_origin = current_position[E_AXIS];
+        #endif
+        STATIC_ITEM(MSG_MOVE_E, true, true);
+        break;
+    }
+  }
+  #if ENABLED(PREVENT_COLD_EXTRUSION)
+    if (axis == E_AXIS && thermalManager.tooColdToExtrude(eindex >= 0 ? eindex : active_extruder))
+      MENU_BACK(MSG_HOTEND_TOO_COLD);
+    else
+  #endif
+  {
+    MENU_BACK(MSG_MOVE_AXIS);
+    MENU_ITEM(submenu, MSG_MOVE_10MM, menu_move_10mm);
+    MENU_ITEM(submenu, MSG_MOVE_1MM, menu_move_1mm);
+    MENU_ITEM(submenu, MSG_MOVE_01MM, menu_move_01mm);
+  }
+  END_MENU();
+}
+void lcd_move_get_x_amount()        { _menu_move_distance(X_AXIS, lcd_move_x); }
+void lcd_move_get_y_amount()        { _menu_move_distance(Y_AXIS, lcd_move_y); }
+void lcd_move_get_z_amount()        { _menu_move_distance(Z_AXIS, lcd_move_z); }
+void lcd_move_get_e_amount()        { _menu_move_distance(E_AXIS, lcd_move_e, -1); }
+#if E_MANUAL > 1
+  void lcd_move_get_e0_amount()     { _menu_move_distance(E_AXIS, lcd_move_e0, 0); }
+  void lcd_move_get_e1_amount()     { _menu_move_distance(E_AXIS, lcd_move_e1, 1); }
+  #if E_MANUAL > 2
+    void lcd_move_get_e2_amount()   { _menu_move_distance(E_AXIS, lcd_move_e2, 2); }
+    #if E_MANUAL > 3
+      void lcd_move_get_e3_amount() { _menu_move_distance(E_AXIS, lcd_move_e3, 3); }
+      #if E_MANUAL > 4
+        void lcd_move_get_e4_amount() { _menu_move_distance(E_AXIS, lcd_move_e4, 4); }
+        #if E_MANUAL > 5
+          void lcd_move_get_e5_amount() { _menu_move_distance(E_AXIS, lcd_move_e5, 5); }
+        #endif // E_MANUAL > 5
+      #endif // E_MANUAL > 4
+    #endif // E_MANUAL > 3
+  #endif // E_MANUAL > 2
+#endif // E_MANUAL > 1
+
+/**
+ *
+ * "Motion" > "Move Axis" submenu
+ *
+ */
+
+#if ENABLED(DELTA)
+  void lcd_lower_z_to_clip_height() {
+    line_to_z(delta_clip_start_height);
+    lcd_synchronize();
+  }
+#endif
+
+void menu_move() {
+  START_MENU();
+  MENU_BACK(MSG_MOTION);
+
+  #if HAS_SOFTWARE_ENDSTOPS && ENABLED(SOFT_ENDSTOPS_MENU_ITEM)
+    MENU_ITEM_EDIT(bool, MSG_LCD_SOFT_ENDSTOPS, &soft_endstops_enabled);
+  #endif
+
+  if (
+    #if IS_KINEMATIC || ENABLED(NO_MOTION_BEFORE_HOMING)
+      all_axes_homed()
+    #else
+      true
+    #endif
+  ) {
+    if (
+      #if ENABLED(DELTA)
+        current_position[Z_AXIS] <= delta_clip_start_height
+      #else
+        true
+      #endif
+    ) {
+      MENU_ITEM(submenu, MSG_MOVE_X, lcd_move_get_x_amount);
+      MENU_ITEM(submenu, MSG_MOVE_Y, lcd_move_get_y_amount);
+    }
+    #if ENABLED(DELTA)
+      else
+        MENU_ITEM(function, MSG_FREE_XY, lcd_lower_z_to_clip_height);
+    #endif
+
+    MENU_ITEM(submenu, MSG_MOVE_Z, lcd_move_get_z_amount);
+  }
+  else
+    MENU_ITEM(gcode, MSG_AUTO_HOME, PSTR("G28"));
+
+  #if ENABLED(SWITCHING_EXTRUDER) || ENABLED(SWITCHING_NOZZLE)
+
+    #if EXTRUDERS == 6
+      switch (active_extruder) {
+        case 0: MENU_ITEM(gcode, MSG_SELECT " " MSG_E2, PSTR("T1")); break;
+        case 1: MENU_ITEM(gcode, MSG_SELECT " " MSG_E1, PSTR("T0")); break;
+        case 2: MENU_ITEM(gcode, MSG_SELECT " " MSG_E4, PSTR("T3")); break;
+        case 3: MENU_ITEM(gcode, MSG_SELECT " " MSG_E3, PSTR("T2")); break;
+        case 4: MENU_ITEM(gcode, MSG_SELECT " " MSG_E6, PSTR("T5")); break;
+        case 5: MENU_ITEM(gcode, MSG_SELECT " " MSG_E5, PSTR("T4")); break;
+      }
+    #elif EXTRUDERS == 5 || EXTRUDERS == 4
+      switch (active_extruder) {
+        case 0: MENU_ITEM(gcode, MSG_SELECT " " MSG_E2, PSTR("T1")); break;
+        case 1: MENU_ITEM(gcode, MSG_SELECT " " MSG_E1, PSTR("T0")); break;
+        case 2: MENU_ITEM(gcode, MSG_SELECT " " MSG_E4, PSTR("T3")); break;
+        case 3: MENU_ITEM(gcode, MSG_SELECT " " MSG_E3, PSTR("T2")); break;
+      }
+    #elif EXTRUDERS == 3
+      if (active_extruder < 2) {
+        if (active_extruder)
+          MENU_ITEM(gcode, MSG_SELECT " " MSG_E1, PSTR("T0"));
+        else
+          MENU_ITEM(gcode, MSG_SELECT " " MSG_E2, PSTR("T1"));
+      }
+    #else
+      if (active_extruder)
+        MENU_ITEM(gcode, MSG_SELECT " " MSG_E1, PSTR("T0"));
+      else
+        MENU_ITEM(gcode, MSG_SELECT " " MSG_E2, PSTR("T1"));
+    #endif
+
+  #elif ENABLED(DUAL_X_CARRIAGE)
+
+    if (active_extruder)
+      MENU_ITEM(gcode, MSG_SELECT " " MSG_E1, PSTR("T0"));
+    else
+      MENU_ITEM(gcode, MSG_SELECT " " MSG_E2, PSTR("T1"));
+
+  #endif
+
+  #if ENABLED(SWITCHING_EXTRUDER) || ENABLED(SWITCHING_NOZZLE)
+
+    // Only the current...
+    MENU_ITEM(submenu, MSG_MOVE_E, lcd_move_get_e_amount);
+    // ...and the non-switching
+    #if E_MANUAL == 5
+      MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E5, lcd_move_get_e4_amount);
+    #elif E_MANUAL == 3
+      MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E3, lcd_move_get_e2_amount);
+    #endif
+
+  #else
+
+    // Independent extruders with one E-stepper per hotend
+    MENU_ITEM(submenu, MSG_MOVE_E, lcd_move_get_e_amount);
+    #if E_MANUAL > 1
+      MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E1, lcd_move_get_e0_amount);
+      MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E2, lcd_move_get_e1_amount);
+      #if E_MANUAL > 2
+        MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E3, lcd_move_get_e2_amount);
+        #if E_MANUAL > 3
+          MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E4, lcd_move_get_e3_amount);
+          #if E_MANUAL > 4
+            MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E5, lcd_move_get_e4_amount);
+            #if E_MANUAL > 5
+              MENU_ITEM(submenu, MSG_MOVE_E MSG_MOVE_E6, lcd_move_get_e5_amount);
+            #endif // E_MANUAL > 5
+          #endif // E_MANUAL > 4
+        #endif // E_MANUAL > 3
+      #endif // E_MANUAL > 2
+    #endif // E_MANUAL > 1
+
+  #endif
+
+  END_MENU();
+}
+
+/**
+ *
+ * "Configuration" submenu
+ *
+ */
+
+#if HAS_LCD_CONTRAST
+  void lcd_callback_set_contrast() { set_lcd_contrast(lcd_contrast); }
+#endif
+
+static void lcd_factory_settings() {
+  settings.reset();
+  lcd_completion_feedback();
+}
+
+#if ENABLED(EEPROM_SETTINGS) && DISABLED(SLIM_LCD_MENUS)
+
+  static void lcd_init_eeprom() {
+    lcd_completion_feedback(settings.init_eeprom());
+    lcd_goto_previous_menu();
+  }
+
+  static void lcd_init_eeprom_confirm() {
+    START_MENU();
+    MENU_BACK(MSG_ADVANCED_SETTINGS);
+    MENU_ITEM(function, MSG_INIT_EEPROM, lcd_init_eeprom);
+    END_MENU();
+  }
+
+#endif
+
+void menu_configuration() {
+  START_MENU();
+  MENU_BACK(MSG_MAIN);
+
+  //
+  // Debug Menu when certain options are enabled
+  //
+  #if HAS_DEBUG_MENU
+    MENU_ITEM(submenu, MSG_DEBUG_MENU, menu_debug);
+  #endif
+
+  MENU_ITEM(submenu, MSG_ADVANCED_SETTINGS, menu_advanced_settings);
+
+  const bool busy = printer_busy();
+  if (!busy) {
+    //
+    // Delta Calibration
+    //
+    #if ENABLED(DELTA_CALIBRATION_MENU) || ENABLED(DELTA_AUTO_CALIBRATION)
+      MENU_ITEM(submenu, MSG_DELTA_CALIBRATE, menu_delta_calibrate);
+    #endif
+
+    #if ENABLED(DUAL_X_CARRIAGE)
+      MENU_ITEM(submenu, MSG_IDEX_MENU, menu_IDEX);
+    #endif
+
+    #if ENABLED(BLTOUCH)
+      MENU_ITEM(submenu, MSG_BLTOUCH, menu_bltouch);
+    #endif
+  }
+
+  //
+  // Set single nozzle filament retract and prime length
+  //
+  #if EXTRUDERS > 1
+    MENU_ITEM(submenu, MSG_TOOL_CHANGE, menu_tool_change);
+  #endif
+
+  //
+  // Set Case light on/off/brightness
+  //
+  #if ENABLED(MENU_ITEM_CASE_LIGHT)
+    if (USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN))
+      MENU_ITEM(submenu, MSG_CASE_LIGHT, menu_case_light);
+    else
+      MENU_ITEM_EDIT_CALLBACK(bool, MSG_CASE_LIGHT, (bool*)&case_light_on, update_case_light);
+  #endif
+
+  #if HAS_LCD_CONTRAST
+    MENU_ITEM_EDIT_CALLBACK(int3, MSG_CONTRAST, &lcd_contrast, LCD_CONTRAST_MIN, LCD_CONTRAST_MAX, lcd_callback_set_contrast, true);
+  #endif
+  #if ENABLED(FWRETRACT)
+    MENU_ITEM(submenu, MSG_RETRACT, menu_config_retract);
+  #endif
+  #if ENABLED(DAC_STEPPER_CURRENT)
+    MENU_ITEM(submenu, MSG_DRIVE_STRENGTH, menu_dac);
+  #endif
+  #if HAS_MOTOR_CURRENT_PWM
+    MENU_ITEM(submenu, MSG_DRIVE_STRENGTH, menu_pwm);
+  #endif
+
+  #if ENABLED(FILAMENT_RUNOUT_SENSOR)
+    MENU_ITEM_EDIT(bool, MSG_RUNOUT_SENSOR_ENABLE, &runout.enabled);
+  #endif
+
+  #if DISABLED(SLIM_LCD_MENUS)
+    // Preheat configurations
+    MENU_ITEM(submenu, MSG_PREHEAT_1_SETTINGS, menu_preheat_material1_settings);
+    MENU_ITEM(submenu, MSG_PREHEAT_2_SETTINGS, menu_preheat_material2_settings);
+  #endif
+
+  #if ENABLED(EEPROM_SETTINGS)
+    MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
+    if (!busy)
+      MENU_ITEM(function, MSG_LOAD_EEPROM, lcd_load_settings);
+  #endif
+
+  if (!busy)
+    MENU_ITEM(function, MSG_RESTORE_FAILSAFE, lcd_factory_settings);
+
+  END_MENU();
+}
+
+/**
+ *
+ * "Temperature" submenu
+ *
+ */
+
+#if ENABLED(PID_AUTOTUNE_MENU)
+
+  #if ENABLED(PIDTEMP)
+    int16_t autotune_temp[HOTENDS] = ARRAY_BY_HOTENDS1(150);
+  #endif
+
+  #if ENABLED(PIDTEMPBED)
+    int16_t autotune_temp_bed = 70;
+  #endif
+
+  void _lcd_autotune(int16_t e) {
+    char cmd[30];
+    sprintf_P(cmd, PSTR("M303 U1 E%i S%i"), e,
+      #if HAS_PID_FOR_BOTH
+        e < 0 ? autotune_temp_bed : autotune_temp[e]
+      #elif ENABLED(PIDTEMPBED)
+        autotune_temp_bed
+      #else
+        autotune_temp[e]
+      #endif
+    );
+    lcd_enqueue_command(cmd);
+  }
+
+#endif // PID_AUTOTUNE_MENU
+
+#if ENABLED(PIDTEMP)
+
+  // Helpers for editing PID Ki & Kd values
+  // grab the PID value out of the temp variable; scale it; then update the PID driver
+  void copy_and_scalePID_i(int16_t e) {
+    #if DISABLED(PID_PARAMS_PER_HOTEND) || HOTENDS == 1
+      UNUSED(e);
+    #endif
+    PID_PARAM(Ki, e) = scalePID_i(raw_Ki);
+    thermalManager.updatePID();
+  }
+  void copy_and_scalePID_d(int16_t e) {
+    #if DISABLED(PID_PARAMS_PER_HOTEND) || HOTENDS == 1
+      UNUSED(e);
+    #endif
+    PID_PARAM(Kd, e) = scalePID_d(raw_Kd);
+    thermalManager.updatePID();
+  }
+  #define _DEFINE_PIDTEMP_BASE_FUNCS(N) \
+    void copy_and_scalePID_i_E ## N() { copy_and_scalePID_i(N); } \
+    void copy_and_scalePID_d_E ## N() { copy_and_scalePID_d(N); }
+
+  #if ENABLED(PID_AUTOTUNE_MENU)
+    #define DEFINE_PIDTEMP_FUNCS(N) \
+      _DEFINE_PIDTEMP_BASE_FUNCS(N); \
+      void lcd_autotune_callback_E ## N() { _lcd_autotune(N); } typedef void _pid_##N##_void
+  #else
+    #define DEFINE_PIDTEMP_FUNCS(N) _DEFINE_PIDTEMP_BASE_FUNCS(N) typedef void _pid_##N##_void
+  #endif
+
+  DEFINE_PIDTEMP_FUNCS(0);
+  #if ENABLED(PID_PARAMS_PER_HOTEND)
+    #if HOTENDS > 1
+      DEFINE_PIDTEMP_FUNCS(1);
+      #if HOTENDS > 2
+        DEFINE_PIDTEMP_FUNCS(2);
+        #if HOTENDS > 3
+          DEFINE_PIDTEMP_FUNCS(3);
+          #if HOTENDS > 4
+            DEFINE_PIDTEMP_FUNCS(4);
+            #if HOTENDS > 5
+              DEFINE_PIDTEMP_FUNCS(5);
+            #endif // HOTENDS > 5
+          #endif // HOTENDS > 4
+        #endif // HOTENDS > 3
+      #endif // HOTENDS > 2
+    #endif // HOTENDS > 1
+  #endif // PID_PARAMS_PER_HOTEND
+
+#endif // PIDTEMP
+
+/**
+ *
+ * "Temperature" submenu
+ *
+ */
+void menu_temperature() {
+  START_MENU();
+  MENU_BACK(MSG_MAIN);
+
+  //
+  // Nozzle:
+  // Nozzle [1-5]:
+  //
+  #if HOTENDS == 1
+    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE, &thermalManager.target_temperature[0], 0, HEATER_0_MAXTEMP - 15, watch_temp_callback_E0);
+  #else // HOTENDS > 1
+    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N1, &thermalManager.target_temperature[0], 0, HEATER_0_MAXTEMP - 15, watch_temp_callback_E0);
+    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N2, &thermalManager.target_temperature[1], 0, HEATER_1_MAXTEMP - 15, watch_temp_callback_E1);
+    #if HOTENDS > 2
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N3, &thermalManager.target_temperature[2], 0, HEATER_2_MAXTEMP - 15, watch_temp_callback_E2);
+      #if HOTENDS > 3
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N4, &thermalManager.target_temperature[3], 0, HEATER_3_MAXTEMP - 15, watch_temp_callback_E3);
+        #if HOTENDS > 4
+          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N5, &thermalManager.target_temperature[4], 0, HEATER_4_MAXTEMP - 15, watch_temp_callback_E4);
+          #if HOTENDS > 5
+            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_NOZZLE MSG_N6, &thermalManager.target_temperature[5], 0, HEATER_5_MAXTEMP - 15, watch_temp_callback_E5);
+          #endif // HOTENDS > 5
+        #endif // HOTENDS > 4
+      #endif // HOTENDS > 3
+    #endif // HOTENDS > 2
+  #endif // HOTENDS > 1
+
+  //
+  // Bed:
+  //
+  #if HAS_HEATED_BED
+    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_BED, &thermalManager.target_temperature_bed, 0, BED_MAXTEMP - 15, watch_temp_callback_bed);
+  #endif
+
+  //
+  // Fan Speed:
+  //
+  #if FAN_COUNT > 0
+    #if HAS_FAN0
+      MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_FAN_SPEED FAN_SPEED_1_SUFFIX, &fan_speed[0], 0, 255);
+      #if ENABLED(EXTRA_FAN_SPEED)
+        MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_EXTRA_FAN_SPEED FAN_SPEED_1_SUFFIX, &new_fan_speed[0], 3, 255);
+      #endif
+    #endif
+    #if HAS_FAN1
+      MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_FAN_SPEED " 2", &fan_speed[1], 0, 255);
+      #if ENABLED(EXTRA_FAN_SPEED)
+        MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_EXTRA_FAN_SPEED " 2", &new_fan_speed[1], 3, 255);
+      #endif
+    #endif
+    #if HAS_FAN2
+      MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_FAN_SPEED " 3", &fan_speed[2], 0, 255);
+      #if ENABLED(EXTRA_FAN_SPEED)
+        MENU_MULTIPLIER_ITEM_EDIT(int8, MSG_EXTRA_FAN_SPEED " 3", &new_fan_speed[2], 3, 255);
+      #endif
+    #endif
+  #endif // FAN_COUNT > 0
+
+  #if HAS_TEMP_HOTEND
+
+    //
+    // Cooldown
+    //
+    bool has_heat = false;
+    HOTEND_LOOP() if (thermalManager.target_temperature[HOTEND_INDEX]) { has_heat = true; break; }
+    #if HAS_TEMP_BED
+      if (thermalManager.target_temperature_bed) has_heat = true;
+    #endif
+    if (has_heat) MENU_ITEM(function, MSG_COOLDOWN, lcd_cooldown);
+
+    //
+    // Preheat for Material 1 and 2
+    //
+    #if TEMP_SENSOR_1 != 0 || TEMP_SENSOR_2 != 0 || TEMP_SENSOR_3 != 0 || TEMP_SENSOR_4 != 0 || HAS_HEATED_BED
+      MENU_ITEM(submenu, MSG_PREHEAT_1, menu_preheat_m1);
+      MENU_ITEM(submenu, MSG_PREHEAT_2, menu_preheat_m2);
+    #else
+      MENU_ITEM(function, MSG_PREHEAT_1, lcd_preheat_m1_e0_only);
+      MENU_ITEM(function, MSG_PREHEAT_2, lcd_preheat_m2_e0_only);
+    #endif
+
+  #endif // HAS_TEMP_HOTEND
+
+  END_MENU();
+}
+
+/**
+ *
+ * "Advanced Settings" -> "Temperature" submenu
+ *
+ */
+void menu_advanced_temperature() {
+  START_MENU();
+  MENU_BACK(MSG_ADVANCED_SETTINGS);
+  //
+  // Autotemp, Min, Max, Fact
+  //
+  #if ENABLED(AUTOTEMP) && HAS_TEMP_HOTEND
+    MENU_ITEM_EDIT(bool, MSG_AUTOTEMP, &planner.autotemp_enabled);
+    MENU_ITEM_EDIT(float3, MSG_MIN, &planner.autotemp_min, 0, float(HEATER_0_MAXTEMP) - 15);
+    MENU_ITEM_EDIT(float3, MSG_MAX, &planner.autotemp_max, 0, float(HEATER_0_MAXTEMP) - 15);
+    MENU_ITEM_EDIT(float52, MSG_FACTOR, &planner.autotemp_factor, 0, 1);
+  #endif
+
+  //
+  // PID-P, PID-I, PID-D, PID-C, PID Autotune
+  // PID-P E1, PID-I E1, PID-D E1, PID-C E1, PID Autotune E1
+  // PID-P E2, PID-I E2, PID-D E2, PID-C E2, PID Autotune E2
+  // PID-P E3, PID-I E3, PID-D E3, PID-C E3, PID Autotune E3
+  // PID-P E4, PID-I E4, PID-D E4, PID-C E4, PID Autotune E4
+  // PID-P E5, PID-I E5, PID-D E5, PID-C E5, PID Autotune E5
+  //
+  #if ENABLED(PIDTEMP)
+
+    #define _PID_BASE_MENU_ITEMS(ELABEL, eindex) \
+      raw_Ki = unscalePID_i(PID_PARAM(Ki, eindex)); \
+      raw_Kd = unscalePID_d(PID_PARAM(Kd, eindex)); \
+      MENU_ITEM_EDIT(float52sign, MSG_PID_P ELABEL, &PID_PARAM(Kp, eindex), 1, 9990); \
+      MENU_ITEM_EDIT_CALLBACK(float52sign, MSG_PID_I ELABEL, &raw_Ki, 0.01f, 9990, copy_and_scalePID_i_E ## eindex); \
+      MENU_ITEM_EDIT_CALLBACK(float52sign, MSG_PID_D ELABEL, &raw_Kd, 1, 9990, copy_and_scalePID_d_E ## eindex)
+
+    #if ENABLED(PID_EXTRUSION_SCALING)
+      #define _PID_MENU_ITEMS(ELABEL, eindex) \
+        _PID_BASE_MENU_ITEMS(ELABEL, eindex); \
+        MENU_ITEM_EDIT(float3, MSG_PID_C ELABEL, &PID_PARAM(Kc, eindex), 1, 9990)
+    #else
+      #define _PID_MENU_ITEMS(ELABEL, eindex) _PID_BASE_MENU_ITEMS(ELABEL, eindex)
+    #endif
+
+    #if ENABLED(PID_AUTOTUNE_MENU)
+      #define PID_MENU_ITEMS(ELABEL, eindex) \
+        _PID_MENU_ITEMS(ELABEL, eindex); \
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_PID_AUTOTUNE ELABEL, &autotune_temp[eindex], 150, heater_maxtemp[eindex] - 15, lcd_autotune_callback_E ## eindex)
+    #else
+      #define PID_MENU_ITEMS(ELABEL, eindex) _PID_MENU_ITEMS(ELABEL, eindex)
+    #endif
+
+    #if ENABLED(PID_PARAMS_PER_HOTEND) && HOTENDS > 1
+      PID_MENU_ITEMS(" " MSG_E1, 0);
+      PID_MENU_ITEMS(" " MSG_E2, 1);
+      #if HOTENDS > 2
+        PID_MENU_ITEMS(" " MSG_E3, 2);
+        #if HOTENDS > 3
+          PID_MENU_ITEMS(" " MSG_E4, 3);
+          #if HOTENDS > 4
+            PID_MENU_ITEMS(" " MSG_E5, 4);
+            #if HOTENDS > 5
+              PID_MENU_ITEMS(" " MSG_E6, 5);
+            #endif // HOTENDS > 5
+          #endif // HOTENDS > 4
+        #endif // HOTENDS > 3
+      #endif // HOTENDS > 2
+    #else // !PID_PARAMS_PER_HOTEND || HOTENDS == 1
+      PID_MENU_ITEMS("", 0);
+    #endif // !PID_PARAMS_PER_HOTEND || HOTENDS == 1
+
+  #endif // PIDTEMP
+
+  END_MENU();
+}
+
+#if DISABLED(SLIM_LCD_MENUS)
+
+  void _menu_configuration_preheat_settings(const uint8_t material) {
+    #if HOTENDS > 5
+      #define MINTEMP_ALL MIN(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP, HEATER_3_MINTEMP, HEATER_4_MINTEMP, HEATER_5_MINTEMP)
+      #define MAXTEMP_ALL MAX(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP, HEATER_5_MAXTEMP)
+    #elif HOTENDS > 4
+      #define MINTEMP_ALL MIN(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP, HEATER_3_MINTEMP, HEATER_4_MINTEMP)
+      #define MAXTEMP_ALL MAX(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP, HEATER_4_MAXTEMP)
+    #elif HOTENDS > 3
+      #define MINTEMP_ALL MIN(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP, HEATER_3_MINTEMP)
+      #define MAXTEMP_ALL MAX(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP, HEATER_3_MAXTEMP)
+    #elif HOTENDS > 2
+      #define MINTEMP_ALL MIN(HEATER_0_MINTEMP, HEATER_1_MINTEMP, HEATER_2_MINTEMP)
+      #define MAXTEMP_ALL MAX(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP, HEATER_2_MAXTEMP)
+    #elif HOTENDS > 1
+      #define MINTEMP_ALL MIN(HEATER_0_MINTEMP, HEATER_1_MINTEMP)
+      #define MAXTEMP_ALL MAX(HEATER_0_MAXTEMP, HEATER_1_MAXTEMP)
+    #else
+      #define MINTEMP_ALL HEATER_0_MINTEMP
+      #define MAXTEMP_ALL HEATER_0_MAXTEMP
+    #endif
+    START_MENU();
+    MENU_BACK(MSG_CONFIGURATION);
+    MENU_ITEM_EDIT(int8, MSG_FAN_SPEED, &lcd_preheat_fan_speed[material], 0, 255);
+    #if HAS_TEMP_HOTEND
+      MENU_ITEM_EDIT(int3, MSG_NOZZLE, &lcd_preheat_hotend_temp[material], MINTEMP_ALL, MAXTEMP_ALL - 15);
+    #endif
+    #if HAS_HEATED_BED
+      MENU_ITEM_EDIT(int3, MSG_BED, &lcd_preheat_bed_temp[material], BED_MINTEMP, BED_MAXTEMP - 15);
+    #endif
+    #if ENABLED(EEPROM_SETTINGS)
+      MENU_ITEM(function, MSG_STORE_EEPROM, lcd_store_settings);
+    #endif
+    END_MENU();
+  }
+
+  /**
+   *
+   * "Temperature" > "Preheat Material 1 conf" submenu
+   *
+   */
+  void menu_preheat_material1_settings() { _menu_configuration_preheat_settings(0); }
+
+  /**
+   *
+   * "Temperature" > "Preheat Material 2 conf" submenu
+   *
+   */
+  void menu_preheat_material2_settings() { _menu_configuration_preheat_settings(1); }
+
+  void _reset_acceleration_rates() { planner.reset_acceleration_rates(); }
+  #if ENABLED(DISTINCT_E_FACTORS)
+    void _reset_e_acceleration_rate(const uint8_t e) { if (e == active_extruder) _reset_acceleration_rates(); }
+    void _reset_e0_acceleration_rate() { _reset_e_acceleration_rate(0); }
+    void _reset_e1_acceleration_rate() { _reset_e_acceleration_rate(1); }
+    #if E_STEPPERS > 2
+      void _reset_e2_acceleration_rate() { _reset_e_acceleration_rate(2); }
+      #if E_STEPPERS > 3
+        void _reset_e3_acceleration_rate() { _reset_e_acceleration_rate(3); }
+        #if E_STEPPERS > 4
+          void _reset_e4_acceleration_rate() { _reset_e_acceleration_rate(4); }
+          #if E_STEPPERS > 5
+            void _reset_e5_acceleration_rate() { _reset_e_acceleration_rate(5); }
+          #endif // E_STEPPERS > 5
+        #endif // E_STEPPERS > 4
+      #endif // E_STEPPERS > 3
+    #endif // E_STEPPERS > 2
+  #endif
+
+  void _planner_refresh_positioning() { planner.refresh_positioning(); }
+  #if ENABLED(DISTINCT_E_FACTORS)
+    void _planner_refresh_e_positioning(const uint8_t e) {
+      if (e == active_extruder)
+        _planner_refresh_positioning();
+      else
+        planner.steps_to_mm[E_AXIS + e] = 1.0f / planner.settings.axis_steps_per_mm[E_AXIS + e];
+    }
+    void _planner_refresh_e0_positioning() { _planner_refresh_e_positioning(0); }
+    void _planner_refresh_e1_positioning() { _planner_refresh_e_positioning(1); }
+    #if E_STEPPERS > 2
+      void _planner_refresh_e2_positioning() { _planner_refresh_e_positioning(2); }
+      #if E_STEPPERS > 3
+        void _planner_refresh_e3_positioning() { _planner_refresh_e_positioning(3); }
+        #if E_STEPPERS > 4
+          void _planner_refresh_e4_positioning() { _planner_refresh_e_positioning(4); }
+          #if E_STEPPERS > 5
+            void _planner_refresh_e5_positioning() { _planner_refresh_e_positioning(5); }
+          #endif // E_STEPPERS > 5
+        #endif // E_STEPPERS > 4
+      #endif // E_STEPPERS > 3
+    #endif // E_STEPPERS > 2
+  #endif
+
+  // M203 / M205 Velocity options
+  void menu_advanced_velocity() {
+    START_MENU();
+    MENU_BACK(MSG_ADVANCED_SETTINGS);
+
+    // M203 Max Feedrate
+    MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_A, &planner.settings.max_feedrate_mm_s[A_AXIS], 1, 999);
+    MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_B, &planner.settings.max_feedrate_mm_s[B_AXIS], 1, 999);
+    MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_C, &planner.settings.max_feedrate_mm_s[C_AXIS], 1, 999);
+
+    #if ENABLED(DISTINCT_E_FACTORS)
+      MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E, &planner.settings.max_feedrate_mm_s[E_AXIS + active_extruder], 1, 999);
+      MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E1, &planner.settings.max_feedrate_mm_s[E_AXIS], 1, 999);
+      MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E2, &planner.settings.max_feedrate_mm_s[E_AXIS + 1], 1, 999);
+      #if E_STEPPERS > 2
+        MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E3, &planner.settings.max_feedrate_mm_s[E_AXIS + 2], 1, 999);
+        #if E_STEPPERS > 3
+          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E4, &planner.settings.max_feedrate_mm_s[E_AXIS + 3], 1, 999);
+          #if E_STEPPERS > 4
+            MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E5, &planner.settings.max_feedrate_mm_s[E_AXIS + 4], 1, 999);
+            #if E_STEPPERS > 5
+              MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E6, &planner.settings.max_feedrate_mm_s[E_AXIS + 5], 1, 999);
+            #endif // E_STEPPERS > 5
+          #endif // E_STEPPERS > 4
+        #endif // E_STEPPERS > 3
+      #endif // E_STEPPERS > 2
+    #else
+      MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMAX MSG_E, &planner.settings.max_feedrate_mm_s[E_AXIS], 1, 999);
+    #endif
+
+    // M205 S Min Feedrate
+    MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VMIN, &planner.settings.min_feedrate_mm_s, 0, 999);
+
+    // M205 T Min Travel Feedrate
+    MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VTRAV_MIN, &planner.settings.min_travel_feedrate_mm_s, 0, 999);
+
+    END_MENU();
+  }
+
+  // M201 / M204 Accelerations
+  void menu_advanced_acceleration() {
+    START_MENU();
+    MENU_BACK(MSG_ADVANCED_SETTINGS);
+
+    // M204 P Acceleration
+    MENU_MULTIPLIER_ITEM_EDIT(float5, MSG_ACC, &planner.settings.acceleration, 10, 99000);
+
+    // M204 R Retract Acceleration
+    MENU_MULTIPLIER_ITEM_EDIT(float5, MSG_A_RETRACT, &planner.settings.retract_acceleration, 100, 99000);
+
+    // M204 T Travel Acceleration
+    MENU_MULTIPLIER_ITEM_EDIT(float5, MSG_A_TRAVEL, &planner.settings.travel_acceleration, 100, 99000);
+
+    // M201 settings
+    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_A, &planner.settings.max_acceleration_mm_per_s2[A_AXIS], 100, 99000, _reset_acceleration_rates);
+    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_B, &planner.settings.max_acceleration_mm_per_s2[B_AXIS], 100, 99000, _reset_acceleration_rates);
+    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_C, &planner.settings.max_acceleration_mm_per_s2[C_AXIS], 10, 99000, _reset_acceleration_rates);
+
+    #if ENABLED(DISTINCT_E_FACTORS)
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E, &planner.settings.max_acceleration_mm_per_s2[E_AXIS + active_extruder], 100, 99000, _reset_acceleration_rates);
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E1, &planner.settings.max_acceleration_mm_per_s2[E_AXIS], 100, 99000, _reset_e0_acceleration_rate);
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E2, &planner.settings.max_acceleration_mm_per_s2[E_AXIS + 1], 100, 99000, _reset_e1_acceleration_rate);
+      #if E_STEPPERS > 2
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E3, &planner.settings.max_acceleration_mm_per_s2[E_AXIS + 2], 100, 99000, _reset_e2_acceleration_rate);
+        #if E_STEPPERS > 3
+          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E4, &planner.settings.max_acceleration_mm_per_s2[E_AXIS + 3], 100, 99000, _reset_e3_acceleration_rate);
+          #if E_STEPPERS > 4
+            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E5, &planner.settings.max_acceleration_mm_per_s2[E_AXIS + 4], 100, 99000, _reset_e4_acceleration_rate);
+            #if E_STEPPERS > 5
+              MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E6, &planner.settings.max_acceleration_mm_per_s2[E_AXIS + 5], 100, 99000, _reset_e5_acceleration_rate);
+            #endif // E_STEPPERS > 5
+          #endif // E_STEPPERS > 4
+        #endif // E_STEPPERS > 3
+      #endif // E_STEPPERS > 2
+    #else
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(long5, MSG_AMAX MSG_E, &planner.settings.max_acceleration_mm_per_s2[E_AXIS], 100, 99000, _reset_acceleration_rates);
+    #endif
+
+    END_MENU();
+  }
+
+  // M205 Jerk
+  void menu_advanced_jerk() {
+    START_MENU();
+    MENU_BACK(MSG_ADVANCED_SETTINGS);
+
+    #if ENABLED(JUNCTION_DEVIATION)
+      #if ENABLED(LIN_ADVANCE)
+        MENU_ITEM_EDIT_CALLBACK(float43, MSG_JUNCTION_DEVIATION, &planner.junction_deviation_mm, 0.01f, 0.3f, planner.recalculate_max_e_jerk);
+      #else
+        MENU_ITEM_EDIT(float43, MSG_JUNCTION_DEVIATION, &planner.junction_deviation_mm, 0.01f, 0.3f);
+      #endif
+    #endif
+    #if HAS_CLASSIC_JERK
+      MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VA_JERK, &planner.max_jerk[A_AXIS], 1, 990);
+      MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VB_JERK, &planner.max_jerk[B_AXIS], 1, 990);
+      #if ENABLED(DELTA)
+        MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VC_JERK, &planner.max_jerk[C_AXIS], 1, 990);
+      #else
+        MENU_MULTIPLIER_ITEM_EDIT(float52sign, MSG_VC_JERK, &planner.max_jerk[C_AXIS], 0.1f, 990);
+      #endif
+      #if DISABLED(JUNCTION_DEVIATION) || DISABLED(LIN_ADVANCE)
+        MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_VE_JERK, &planner.max_jerk[E_AXIS], 1, 990);
+      #endif
+    #endif
+
+    END_MENU();
+  }
+
+  // M92 Steps-per-mm
+  void menu_advanced_steps_per_mm() {
+    START_MENU();
+    MENU_BACK(MSG_ADVANCED_SETTINGS);
+
+    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_ASTEPS, &planner.settings.axis_steps_per_mm[A_AXIS], 5, 9999, _planner_refresh_positioning);
+    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_BSTEPS, &planner.settings.axis_steps_per_mm[B_AXIS], 5, 9999, _planner_refresh_positioning);
+    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_CSTEPS, &planner.settings.axis_steps_per_mm[C_AXIS], 5, 9999, _planner_refresh_positioning);
+
+    #if ENABLED(DISTINCT_E_FACTORS)
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_ESTEPS, &planner.settings.axis_steps_per_mm[E_AXIS + active_extruder], 5, 9999, _planner_refresh_positioning);
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E1STEPS, &planner.settings.axis_steps_per_mm[E_AXIS], 5, 9999, _planner_refresh_e0_positioning);
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E2STEPS, &planner.settings.axis_steps_per_mm[E_AXIS + 1], 5, 9999, _planner_refresh_e1_positioning);
+      #if E_STEPPERS > 2
+        MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E3STEPS, &planner.settings.axis_steps_per_mm[E_AXIS + 2], 5, 9999, _planner_refresh_e2_positioning);
+        #if E_STEPPERS > 3
+          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E4STEPS, &planner.settings.axis_steps_per_mm[E_AXIS + 3], 5, 9999, _planner_refresh_e3_positioning);
+          #if E_STEPPERS > 4
+            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E5STEPS, &planner.settings.axis_steps_per_mm[E_AXIS + 4], 5, 9999, _planner_refresh_e4_positioning);
+            #if E_STEPPERS > 5
+              MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_E6STEPS, &planner.settings.axis_steps_per_mm[E_AXIS + 5], 5, 9999, _planner_refresh_e5_positioning);
+            #endif // E_STEPPERS > 5
+          #endif // E_STEPPERS > 4
+        #endif // E_STEPPERS > 3
+      #endif // E_STEPPERS > 2
+    #else
+      MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float62, MSG_ESTEPS, &planner.settings.axis_steps_per_mm[E_AXIS], 5, 9999, _planner_refresh_positioning);
+    #endif
+
+    END_MENU();
+  }
+
+#endif // !SLIM_LCD_MENUS
+
+/**
+ *
+ * "Advanced Settings" submenu
+ *
+ */
+
+#if HAS_M206_COMMAND
+  /**
+   * Set the home offset based on the current_position
+   */
+  void lcd_set_home_offsets() {
+    // M428 Command
+    enqueue_and_echo_commands_P(PSTR("M428"));
+    lcd_return_to_status();
+  }
+#endif
+
+#if ENABLED(SD_FIRMWARE_UPDATE)
+  /**
+   * Toggle the SD Firmware Update state in EEPROM
+   */
+  static void _lcd_toggle_sd_update() {
+    const bool new_state = !settings.sd_update_status();
+    lcd_completion_feedback(settings.set_sd_update_status(new_state));
+    lcd_return_to_status();
+    if (new_state) LCD_MESSAGEPGM(MSG_RESET_PRINTER); else lcd_reset_status();
+  }
+#endif
+
+void menu_advanced_settings() {
+  START_MENU();
+  MENU_BACK(MSG_CONFIGURATION);
+
+  #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
+    MENU_ITEM(submenu, MSG_ZPROBE_ZOFFSET, lcd_babystep_zoffset);
+  #elif HAS_BED_PROBE
+    MENU_ITEM_EDIT(float52, MSG_ZPROBE_ZOFFSET, &zprobe_zoffset, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX);
+  #endif
+
+  #if DISABLED(SLIM_LCD_MENUS)
+
+    #if HAS_M206_COMMAND
+      //
+      // Set Home Offsets
+      //
+      MENU_ITEM(function, MSG_SET_HOME_OFFSETS, lcd_set_home_offsets);
+    #endif
+
+    // M203 / M205 - Feedrate items
+    MENU_ITEM(submenu, MSG_VELOCITY, menu_advanced_velocity);
+
+    // M201 - Acceleration items
+    MENU_ITEM(submenu, MSG_ACCELERATION, menu_advanced_acceleration);
+
+    // M205 - Max Jerk
+    MENU_ITEM(submenu, MSG_JERK, menu_advanced_jerk);
+
+    if (!printer_busy()) {
+      // M92 - Steps Per mm
+      MENU_ITEM(submenu, MSG_STEPS_PER_MM, menu_advanced_steps_per_mm);
+    }
+
+  #endif // !SLIM_LCD_MENUS
+
+  MENU_ITEM(submenu, MSG_TEMPERATURE, menu_advanced_temperature);
+
+  #if DISABLED(NO_VOLUMETRICS) || ENABLED(ADVANCED_PAUSE_FEATURE)
+    MENU_ITEM(submenu, MSG_FILAMENT, menu_advanced_filament);
+  #elif ENABLED(LIN_ADVANCE)
+    #if EXTRUDERS == 1
+      MENU_ITEM_EDIT(float52, MSG_ADVANCE_K, &planner.extruder_advance_K[0], 0, 999);
+    #elif EXTRUDERS > 1
+      MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E1, &planner.extruder_advance_K[0], 0, 999);
+      MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E2, &planner.extruder_advance_K[1], 0, 999);
+      #if EXTRUDERS > 2
+        MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E3, &planner.extruder_advance_K[2], 0, 999);
+        #if EXTRUDERS > 3
+          MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E4, &planner.extruder_advance_K[3], 0, 999);
+          #if EXTRUDERS > 4
+            MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E5, &planner.extruder_advance_K[4], 0, 999);
+            #if EXTRUDERS > 5
+              MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E6, &planner.extruder_advance_K[5], 0, 999);
+            #endif // EXTRUDERS > 5
+          #endif // EXTRUDERS > 4
+        #endif // EXTRUDERS > 3
+      #endif // EXTRUDERS > 2
+    #endif // EXTRUDERS > 1
+  #endif
+
+  // M540 S - Abort on endstop hit when SD printing
+  #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
+    MENU_ITEM_EDIT(bool, MSG_ENDSTOP_ABORT, &planner.abort_on_endstop_hit);
+  #endif
+
+  //
+  // BLTouch Self-Test and Reset
+  //
+  #if ENABLED(BLTOUCH)
+    MENU_ITEM(gcode, MSG_BLTOUCH_SELFTEST, PSTR("M280 P" STRINGIFY(Z_PROBE_SERVO_NR) " S" STRINGIFY(BLTOUCH_SELFTEST)));
+    if (!endstops.z_probe_enabled && TEST_BLTOUCH())
+      MENU_ITEM(gcode, MSG_BLTOUCH_RESET, PSTR("M280 P" STRINGIFY(Z_PROBE_SERVO_NR) " S" STRINGIFY(BLTOUCH_RESET)));
+  #endif
+
+  #if ENABLED(SD_FIRMWARE_UPDATE)
+    bool sd_update_state = settings.sd_update_status();
+    MENU_ITEM_EDIT_CALLBACK(bool, MSG_SD_UPDATE, &sd_update_state, _lcd_toggle_sd_update);
+  #endif
+
+  #if ENABLED(EEPROM_SETTINGS) && DISABLED(SLIM_LCD_MENUS)
+    MENU_ITEM(submenu, MSG_INIT_EEPROM, lcd_init_eeprom_confirm);
+  #endif
+
+  END_MENU();
+}
+
+#if DISABLED(NO_VOLUMETRICS) || ENABLED(ADVANCED_PAUSE_FEATURE)
+  /**
+   *
+   * "Advanced Settings" > "Filament" submenu
+   *
+   */
+  void menu_advanced_filament() {
+    START_MENU();
+    MENU_BACK(MSG_ADVANCED_SETTINGS);
+
+    #if ENABLED(LIN_ADVANCE)
+      #if EXTRUDERS == 1
+        MENU_ITEM_EDIT(float52, MSG_ADVANCE_K, &planner.extruder_advance_K[0], 0, 999);
+      #elif EXTRUDERS > 1
+        MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E1, &planner.extruder_advance_K[0], 0, 999);
+        MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E2, &planner.extruder_advance_K[1], 0, 999);
+        #if EXTRUDERS > 2
+          MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E3, &planner.extruder_advance_K[2], 0, 999);
+          #if EXTRUDERS > 3
+            MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E4, &planner.extruder_advance_K[3], 0, 999);
+            #if EXTRUDERS > 4
+              MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E5, &planner.extruder_advance_K[4], 0, 999);
+              #if EXTRUDERS > 5
+                MENU_ITEM_EDIT(float52, MSG_ADVANCE_K MSG_E6, &planner.extruder_advance_K[5], 0, 999);
+              #endif // EXTRUDERS > 5
+            #endif // EXTRUDERS > 4
+          #endif // EXTRUDERS > 3
+        #endif // EXTRUDERS > 2
+      #endif // EXTRUDERS > 1
+    #endif
+
+    #if DISABLED(NO_VOLUMETRICS)
+      MENU_ITEM_EDIT_CALLBACK(bool, MSG_VOLUMETRIC_ENABLED, &parser.volumetric_enabled, planner.calculate_volumetric_multipliers);
+
+      if (parser.volumetric_enabled) {
+        #if EXTRUDERS == 1
+          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM, &planner.filament_size[0], 1.5f, 3.25f, planner.calculate_volumetric_multipliers);
+        #else // EXTRUDERS > 1
+          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM, &planner.filament_size[active_extruder], 1.5f, 3.25f, planner.calculate_volumetric_multipliers);
+          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E1, &planner.filament_size[0], 1.5f, 3.25f, planner.calculate_volumetric_multipliers);
+          MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E2, &planner.filament_size[1], 1.5f, 3.25f, planner.calculate_volumetric_multipliers);
+          #if EXTRUDERS > 2
+            MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E3, &planner.filament_size[2], 1.5f, 3.25f, planner.calculate_volumetric_multipliers);
+            #if EXTRUDERS > 3
+              MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E4, &planner.filament_size[3], 1.5f, 3.25f, planner.calculate_volumetric_multipliers);
+              #if EXTRUDERS > 4
+                MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E5, &planner.filament_size[4], 1.5f, 3.25f, planner.calculate_volumetric_multipliers);
+                #if EXTRUDERS > 5
+                  MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(float43, MSG_FILAMENT_DIAM MSG_DIAM_E6, &planner.filament_size[5], 1.5f, 3.25f, planner.calculate_volumetric_multipliers);
+                #endif // EXTRUDERS > 5
+              #endif // EXTRUDERS > 4
+            #endif // EXTRUDERS > 3
+          #endif // EXTRUDERS > 2
+        #endif // EXTRUDERS > 1
+      }
+    #endif
+
+    #if ENABLED(ADVANCED_PAUSE_FEATURE)
+      constexpr float extrude_maxlength =
+        #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
+          EXTRUDE_MAXLENGTH
+        #else
+          999
+        #endif
+      ;
+
+      #if EXTRUDERS == 1
+        MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD, &fc_settings[0].unload_length, 0, extrude_maxlength);
+      #else // EXTRUDERS > 1
+        MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD, &fc_settings[active_extruder].unload_length, 0, extrude_maxlength);
+        MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E1, &fc_settings[0].unload_length, 0, extrude_maxlength);
+        MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E2, &fc_settings[1].unload_length, 0, extrude_maxlength);
+        #if EXTRUDERS > 2
+          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E3, &fc_settings[2].unload_length, 0, extrude_maxlength);
+          #if EXTRUDERS > 3
+            MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E4, &fc_settings[3].unload_length, 0, extrude_maxlength);
+            #if EXTRUDERS > 4
+              MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E5, &fc_settings[4].unload_length, 0, extrude_maxlength);
+              #if EXTRUDERS > 5
+                MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_UNLOAD MSG_DIAM_E6, &fc_settings[5].unload_length, 0, extrude_maxlength);
+              #endif // EXTRUDERS > 5
+            #endif // EXTRUDERS > 4
+          #endif // EXTRUDERS > 3
+        #endif // EXTRUDERS > 2
+      #endif // EXTRUDERS > 1
+
+      #if EXTRUDERS == 1
+        MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD, &fc_settings[0].load_length, 0, extrude_maxlength);
+      #else // EXTRUDERS > 1
+        MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD, &fc_settings[active_extruder].load_length, 0, extrude_maxlength);
+        MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E1, &fc_settings[0].load_length, 0, extrude_maxlength);
+        MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E2, &fc_settings[1].load_length, 0, extrude_maxlength);
+        #if EXTRUDERS > 2
+          MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E3, &fc_settings[2].load_length, 0, extrude_maxlength);
+          #if EXTRUDERS > 3
+            MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E4, &fc_settings[3].load_length, 0, extrude_maxlength);
+            #if EXTRUDERS > 4
+              MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E5, &fc_settings[4].load_length, 0, extrude_maxlength);
+              #if EXTRUDERS > 5
+                MENU_MULTIPLIER_ITEM_EDIT(float3, MSG_FILAMENT_LOAD MSG_DIAM_E6, &fc_settings[5].load_length, 0, extrude_maxlength);
+              #endif // EXTRUDERS > 5
+            #endif // EXTRUDERS > 4
+          #endif // EXTRUDERS > 3
+        #endif // EXTRUDERS > 2
+      #endif // EXTRUDERS > 1
+    #endif
+
+    END_MENU();
+  }
+#endif // !NO_VOLUMETRICS || ADVANCED_PAUSE_FEATURE
+
+/**
+ *
+ * "Configuration" > "Retract" submenu
+ *
+ */
+#if ENABLED(FWRETRACT)
+
+  void menu_config_retract() {
+    START_MENU();
+    MENU_BACK(MSG_CONTROL);
+    #if ENABLED(FWRETRACT_AUTORETRACT)
+      MENU_ITEM_EDIT_CALLBACK(bool, MSG_AUTORETRACT, &fwretract.autoretract_enabled, fwretract.refresh_autoretract);
+    #endif
+    MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT, &fwretract.settings.retract_length, 0, 100);
+    #if EXTRUDERS > 1
+      MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT_SWAP, &fwretract.settings.swap_retract_length, 0, 100);
+    #endif
+    MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACTF, &fwretract.settings.retract_feedrate_mm_s, 1, 999);
+    MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT_ZHOP, &fwretract.settings.retract_zraise, 0, 999);
+    MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT_RECOVER, &fwretract.settings.retract_recover_length, -100, 100);
+    #if EXTRUDERS > 1
+      MENU_ITEM_EDIT(float52sign, MSG_CONTROL_RETRACT_RECOVER_SWAP, &fwretract.settings.swap_retract_recover_length, -100, 100);
+    #endif
+    MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACT_RECOVERF, &fwretract.settings.retract_recover_feedrate_mm_s, 1, 999);
+    #if EXTRUDERS > 1
+      MENU_ITEM_EDIT(float3, MSG_CONTROL_RETRACT_RECOVER_SWAPF, &fwretract.settings.swap_retract_recover_feedrate_mm_s, 1, 999);
+    #endif
+    END_MENU();
+  }
+
+#endif // FWRETRACT
+
+#if ENABLED(SDSUPPORT)
+
+  #if !PIN_EXISTS(SD_DETECT)
+    void lcd_sd_refresh() {
+      card.initsd();
+      encoderTopLine = 0;
+    }
+  #endif
+
+  void lcd_sd_updir() {
+    encoderPosition = card.updir() ? ENCODER_STEPS_PER_MENU_ITEM : 0;
+    encoderTopLine = 0;
+    screen_changed = true;
+    lcd_refresh();
+  }
+
+  /**
+   *
+   * "Print from SD" submenu
+   *
+   */
+
+  #if ENABLED(SD_REPRINT_LAST_SELECTED_FILE)
+    uint32_t last_sdfile_encoderPosition = 0xFFFF;
+
+    void lcd_reselect_last_file() {
+      if (last_sdfile_encoderPosition == 0xFFFF) return;
+      #if HAS_GRAPHICAL_LCD
+        // Some of this is a hack to force the screen update to work.
+        // TODO: Fix the real issue that causes this!
+        lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
+        lcd_synchronize();
+        safe_delay(50);
+        lcd_synchronize();
+        lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT;
+        drawing_screen = screen_changed = true;
+      #endif
+
+      lcd_goto_screen(menu_sdcard, last_sdfile_encoderPosition);
+      defer_return_to_status = true;
+      last_sdfile_encoderPosition = 0xFFFF;
+
+      #if HAS_GRAPHICAL_LCD
+        lcd_update();
+      #endif
+    }
+  #endif
+
+  void menu_sdcard() {
+    ENCODER_DIRECTION_MENUS();
+
+    const uint16_t fileCnt = card.get_num_Files();
+
+    START_MENU();
+    MENU_BACK(MSG_MAIN);
+    card.getWorkDirName();
+    if (card.filename[0] == '/') {
+      #if !PIN_EXISTS(SD_DETECT)
+        MENU_ITEM(function, LCD_STR_REFRESH MSG_REFRESH, lcd_sd_refresh);
+      #endif
+    }
+    else {
+      MENU_ITEM(function, LCD_STR_FOLDER "..", lcd_sd_updir);
+    }
+
+    for (uint16_t i = 0; i < fileCnt; i++) {
+      if (_menuLineNr == _thisItemNr) {
+        const uint16_t nr =
+          #if ENABLED(SDCARD_RATHERRECENTFIRST) && DISABLED(SDCARD_SORT_ALPHA)
+            fileCnt - 1 -
+          #endif
+        i;
+
+        #if ENABLED(SDCARD_SORT_ALPHA)
+          card.getfilename_sorted(nr);
+        #else
+          card.getfilename(nr);
+        #endif
+
+        if (card.filenameIsDir)
+          MENU_ITEM(sddirectory, MSG_CARD_MENU, card);
+        else
+          MENU_ITEM(sdfile, MSG_CARD_MENU, card);
+      }
+      else {
+        MENU_ITEM_DUMMY();
+      }
+    }
+    END_MENU();
+  }
+
+#endif // SDSUPPORT
+
+#if ENABLED(LCD_INFO_MENU)
+
+  #if ENABLED(PRINTCOUNTER)
+    /**
+     *
+     * About Printer > Statistics submenu
+     *
+     */
+    void menu_info_stats() {
+      if (use_click()) { return lcd_goto_previous_menu(); }
+
+      char buffer[21];
+      printStatistics stats = print_job_timer.getStats();
+
+      START_SCREEN();                                                                                // 12345678901234567890
+      STATIC_ITEM(MSG_INFO_PRINT_COUNT ": ", false, false, itostr3left(stats.totalPrints));          // Print Count: 999
+      STATIC_ITEM(MSG_INFO_COMPLETED_PRINTS": ", false, false, itostr3left(stats.finishedPrints));   // Completed  : 666
+
+      duration_t elapsed = stats.printTime;
+      elapsed.toString(buffer);
+
+      STATIC_ITEM(MSG_INFO_PRINT_TIME ": ", false, false);                                           // Total print Time:
+      STATIC_ITEM("", false, false, buffer);                                                         // 99y 364d 23h 59m 59s
+
+      elapsed = stats.longestPrint;
+      elapsed.toString(buffer);
+
+      STATIC_ITEM(MSG_INFO_PRINT_LONGEST ": ", false, false);                                        // Longest job time:
+      STATIC_ITEM("", false, false, buffer);                                                         // 99y 364d 23h 59m 59s
+
+      sprintf_P(buffer, PSTR("%ld.%im"), long(stats.filamentUsed / 1000), int16_t(stats.filamentUsed / 100) % 10);
+      STATIC_ITEM(MSG_INFO_PRINT_FILAMENT ": ", false, false);                                       // Extruded total:
+      STATIC_ITEM("", false, false, buffer);                                                         // 125m
+      END_SCREEN();
+    }
+  #endif // PRINTCOUNTER
+
+  /**
+   *
+   * About Printer > Thermistors
+   *
+   */
+  void menu_info_thermistors() {
+    if (use_click()) { return lcd_goto_previous_menu(); }
+    START_SCREEN();
+    #define THERMISTOR_ID TEMP_SENSOR_0
+    #include "../thermistornames.h"
+    STATIC_ITEM("T0: " THERMISTOR_NAME, false, true);
+    STATIC_ITEM(MSG_INFO_MIN_TEMP ": " STRINGIFY(HEATER_0_MINTEMP), false);
+    STATIC_ITEM(MSG_INFO_MAX_TEMP ": " STRINGIFY(HEATER_0_MAXTEMP), false);
+
+    #if TEMP_SENSOR_1 != 0
+      #undef THERMISTOR_ID
+      #define THERMISTOR_ID TEMP_SENSOR_1
+      #include "../thermistornames.h"
+      STATIC_ITEM("T1: " THERMISTOR_NAME, false, true);
+      STATIC_ITEM(MSG_INFO_MIN_TEMP ": " STRINGIFY(HEATER_1_MINTEMP), false);
+      STATIC_ITEM(MSG_INFO_MAX_TEMP ": " STRINGIFY(HEATER_1_MAXTEMP), false);
+    #endif
+
+    #if TEMP_SENSOR_2 != 0
+      #undef THERMISTOR_ID
+      #define THERMISTOR_ID TEMP_SENSOR_2
+      #include "../thermistornames.h"
+      STATIC_ITEM("T2: " THERMISTOR_NAME, false, true);
+      STATIC_ITEM(MSG_INFO_MIN_TEMP ": " STRINGIFY(HEATER_2_MINTEMP), false);
+      STATIC_ITEM(MSG_INFO_MAX_TEMP ": " STRINGIFY(HEATER_2_MAXTEMP), false);
+    #endif
+
+    #if TEMP_SENSOR_3 != 0
+      #undef THERMISTOR_ID
+      #define THERMISTOR_ID TEMP_SENSOR_3
+      #include "../thermistornames.h"
+      STATIC_ITEM("T3: " THERMISTOR_NAME, false, true);
+      STATIC_ITEM(MSG_INFO_MIN_TEMP ": " STRINGIFY(HEATER_3_MINTEMP), false);
+      STATIC_ITEM(MSG_INFO_MAX_TEMP ": " STRINGIFY(HEATER_3_MAXTEMP), false);
+    #endif
+
+    #if TEMP_SENSOR_4 != 0
+      #undef THERMISTOR_ID
+      #define THERMISTOR_ID TEMP_SENSOR_4
+      #include "../thermistornames.h"
+      STATIC_ITEM("T4: " THERMISTOR_NAME, false, true);
+      STATIC_ITEM(MSG_INFO_MIN_TEMP ": " STRINGIFY(HEATER_4_MINTEMP), false);
+      STATIC_ITEM(MSG_INFO_MAX_TEMP ": " STRINGIFY(HEATER_4_MAXTEMP), false);
+    #endif
+
+    #if HAS_HEATED_BED
+      #undef THERMISTOR_ID
+      #define THERMISTOR_ID TEMP_SENSOR_BED
+      #include "../thermistornames.h"
+      STATIC_ITEM("TBed:" THERMISTOR_NAME, false, true);
+      STATIC_ITEM(MSG_INFO_MIN_TEMP ": " STRINGIFY(BED_MINTEMP), false);
+      STATIC_ITEM(MSG_INFO_MAX_TEMP ": " STRINGIFY(BED_MAXTEMP), false);
+    #endif
+    END_SCREEN();
+  }
+
+  /**
+   *
+   * About Printer > Board Info
+   *
+   */
+  void menu_info_board() {
+    if (use_click()) { return lcd_goto_previous_menu(); }
+    START_SCREEN();
+    STATIC_ITEM(BOARD_NAME, true, true);                           // MyPrinterController
+    STATIC_ITEM(MSG_INFO_BAUDRATE ": " STRINGIFY(BAUDRATE), true); // Baud: 250000
+    STATIC_ITEM(MSG_INFO_PROTOCOL ": " PROTOCOL_VERSION, true);    // Protocol: 1.0
+    #if POWER_SUPPLY == 0
+      STATIC_ITEM(MSG_INFO_PSU ": Generic", true);
+    #elif POWER_SUPPLY == 1
+      STATIC_ITEM(MSG_INFO_PSU ": ATX", true);  // Power Supply: ATX
+    #elif POWER_SUPPLY == 2
+      STATIC_ITEM(MSG_INFO_PSU ": XBox", true); // Power Supply: XBox
+    #endif
+    END_SCREEN();
+  }
+
+  /**
+   *
+   * About Printer > Printer Info
+   *
+   */
+  void menu_info_printer() {
+    if (use_click()) { return lcd_goto_previous_menu(); }
+    START_SCREEN();
+    STATIC_ITEM(MSG_MARLIN, true, true);                             // Marlin
+    STATIC_ITEM(SHORT_BUILD_VERSION, true);                          // x.x.x-Branch
+    STATIC_ITEM(STRING_DISTRIBUTION_DATE, true);                     // YYYY-MM-DD HH:MM
+    STATIC_ITEM(MACHINE_NAME, true);                                 // My3DPrinter
+    STATIC_ITEM(WEBSITE_URL, true);                                  // www.my3dprinter.com
+    STATIC_ITEM(MSG_INFO_EXTRUDERS ": " STRINGIFY(EXTRUDERS), true); // Extruders: 2
+    #if ENABLED(AUTO_BED_LEVELING_3POINT)
+      STATIC_ITEM(MSG_3POINT_LEVELING, true);                        // 3-Point Leveling
+    #elif ENABLED(AUTO_BED_LEVELING_LINEAR)
+      STATIC_ITEM(MSG_LINEAR_LEVELING, true);                        // Linear Leveling
+    #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
+      STATIC_ITEM(MSG_BILINEAR_LEVELING, true);                      // Bi-linear Leveling
+    #elif ENABLED(AUTO_BED_LEVELING_UBL)
+      STATIC_ITEM(MSG_UBL_LEVELING, true);                           // Unified Bed Leveling
+    #elif ENABLED(MESH_BED_LEVELING)
+      STATIC_ITEM(MSG_MESH_LEVELING, true);                          // Mesh Leveling
+    #endif
+    END_SCREEN();
+  }
+
+  /**
+   *
+   * "About Printer" submenu
+   *
+   */
+  void menu_info() {
+    START_MENU();
+    MENU_BACK(MSG_MAIN);
+    MENU_ITEM(submenu, MSG_INFO_PRINTER_MENU, menu_info_printer);        // Printer Info >
+    MENU_ITEM(submenu, MSG_INFO_BOARD_MENU, menu_info_board);            // Board Info >
+    MENU_ITEM(submenu, MSG_INFO_THERMISTOR_MENU, menu_info_thermistors); // Thermistors >
+    #if ENABLED(PRINTCOUNTER)
+      MENU_ITEM(submenu, MSG_INFO_STATS_MENU, menu_info_stats);          // Printer Statistics >
+    #endif
+    END_MENU();
+  }
+#endif // LCD_INFO_MENU
+
+/**
+ *
+ * LED Menu
+ *
+ */
+
+#if ENABLED(LED_CONTROL_MENU)
+
+  #if ENABLED(LED_COLOR_PRESETS)
+
+    void menu_led_presets() {
+      START_MENU();
+      #if LCD_HEIGHT > 2
+        STATIC_ITEM(MSG_LED_PRESETS, true, true);
+      #endif
+      MENU_BACK(MSG_LED_CONTROL);
+      MENU_ITEM(function, MSG_SET_LEDS_WHITE, leds.set_white);
+      MENU_ITEM(function, MSG_SET_LEDS_RED, leds.set_red);
+      MENU_ITEM(function, MSG_SET_LEDS_ORANGE, leds.set_orange);
+      MENU_ITEM(function, MSG_SET_LEDS_YELLOW,leds.set_yellow);
+      MENU_ITEM(function, MSG_SET_LEDS_GREEN, leds.set_green);
+      MENU_ITEM(function, MSG_SET_LEDS_BLUE, leds.set_blue);
+      MENU_ITEM(function, MSG_SET_LEDS_INDIGO, leds.set_indigo);
+      MENU_ITEM(function, MSG_SET_LEDS_VIOLET, leds.set_violet);
+      END_MENU();
+    }
+  #endif // LED_COLOR_PRESETS
+
+  void menu_led_custom() {
+    START_MENU();
+    MENU_BACK(MSG_LED_CONTROL);
+    MENU_ITEM_EDIT_CALLBACK(int8, MSG_INTENSITY_R, &leds.color.r, 0, 255, leds.update, true);
+    MENU_ITEM_EDIT_CALLBACK(int8, MSG_INTENSITY_G, &leds.color.g, 0, 255, leds.update, true);
+    MENU_ITEM_EDIT_CALLBACK(int8, MSG_INTENSITY_B, &leds.color.b, 0, 255, leds.update, true);
+    #if ENABLED(RGBW_LED) || ENABLED(NEOPIXEL_LED)
+      MENU_ITEM_EDIT_CALLBACK(int8, MSG_INTENSITY_W, &leds.color.w, 0, 255, leds.update, true);
+      #if ENABLED(NEOPIXEL_LED)
+        MENU_ITEM_EDIT_CALLBACK(int8, MSG_LED_BRIGHTNESS, &leds.color.i, 0, 255, leds.update, true);
+      #endif
+    #endif
+    END_MENU();
+  }
+
+  void menu_led() {
+    START_MENU();
+    MENU_BACK(MSG_MAIN);
+    bool led_on = leds.lights_on;
+    MENU_ITEM_EDIT_CALLBACK(bool, MSG_LEDS, &led_on, leds.toggle);
+    MENU_ITEM(function, MSG_SET_LEDS_DEFAULT, leds.set_default);
+    #if ENABLED(LED_COLOR_PRESETS)
+      MENU_ITEM(submenu, MSG_LED_PRESETS, menu_led_presets);
+    #endif
+    MENU_ITEM(submenu, MSG_CUSTOM_LEDS, menu_led_custom);
+    END_MENU();
+  }
+
+#endif // LED_CONTROL_MENU
+
+/**
+ *
+ * Filament Change Feature Screens
+ *
+ */
+#if ENABLED(ADVANCED_PAUSE_FEATURE)
+
+  /**
+   *
+   * "Change Filament" > "Change/Unload/Load Filament" submenu
+   *
+   */
+  static AdvancedPauseMode _change_filament_temp_mode; // =ADVANCED_PAUSE_MODE_PAUSE_PRINT
+  static int8_t _change_filament_temp_extruder; // =0
+
+  static PGM_P _change_filament_temp_command() {
+    switch (_change_filament_temp_mode) {
+      case ADVANCED_PAUSE_MODE_LOAD_FILAMENT:
+        return PSTR("M701 T%d");
+      case ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT:
+        return _change_filament_temp_extruder >= 0 ? PSTR("M702 T%d") : PSTR("M702 ;%d");
+      case ADVANCED_PAUSE_MODE_PAUSE_PRINT:
+      default:
+        return PSTR("M600 B0 T%d");
+    }
+    return PSTR(MSG_FILAMENTCHANGE);
+  }
+
+  void _change_filament_temp(const uint16_t temperature) {
+    char cmd[11];
+    sprintf_P(cmd, _change_filament_temp_command(), _change_filament_temp_extruder);
+    thermalManager.setTargetHotend(temperature, _change_filament_temp_extruder);
+    lcd_enqueue_command(cmd);
+  }
+  void _menu_change_filament_temp_1() { _change_filament_temp(PREHEAT_1_TEMP_HOTEND); }
+  void _menu_change_filament_temp_2() { _change_filament_temp(PREHEAT_2_TEMP_HOTEND); }
+  void _menu_change_filament_temp_custom() { _change_filament_temp(thermalManager.target_temperature[_change_filament_temp_extruder]); }
+
+  static PGM_P change_filament_header(const AdvancedPauseMode mode) {
+    switch (mode) {
+      case ADVANCED_PAUSE_MODE_LOAD_FILAMENT:
+        return PSTR(MSG_FILAMENTLOAD);
+      case ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT:
+        return PSTR(MSG_FILAMENTUNLOAD);
+      default: break;
+    }
+    return PSTR(MSG_FILAMENTCHANGE);
+  }
+
+  void _menu_temp_filament_op(const AdvancedPauseMode mode, const int8_t extruder) {
+    _change_filament_temp_mode = mode;
+    _change_filament_temp_extruder = extruder;
+    START_MENU();
+    if (LCD_HEIGHT >= 4) STATIC_ITEM_P(change_filament_header(mode), true, true);
+    MENU_BACK(MSG_BACK);
+    MENU_ITEM(submenu, MSG_PREHEAT_1, _menu_change_filament_temp_1);
+    MENU_ITEM(submenu, MSG_PREHEAT_2, _menu_change_filament_temp_2);
+    uint16_t max_temp;
+    switch (extruder) {
+      default: max_temp = HEATER_0_MAXTEMP;
+      #if HOTENDS > 1
+        case 1: max_temp = HEATER_1_MAXTEMP; break;
+        #if HOTENDS > 2
+          case 2: max_temp = HEATER_2_MAXTEMP; break;
+          #if HOTENDS > 3
+            case 3: max_temp = HEATER_3_MAXTEMP; break;
+            #if HOTENDS > 4
+              case 4: max_temp = HEATER_4_MAXTEMP; break;
+              #if HOTENDS > 5
+                case 5: max_temp = HEATER_5_MAXTEMP; break;
+              #endif
+            #endif
+          #endif
+        #endif
+      #endif
+    }
+    MENU_MULTIPLIER_ITEM_EDIT_CALLBACK(int3, MSG_PREHEAT_CUSTOM, &thermalManager.target_temperature[_change_filament_temp_extruder], EXTRUDE_MINTEMP, max_temp - 15, _menu_change_filament_temp_custom);
+    END_MENU();
+  }
+  void menu_temp_e0_filament_change()  { _menu_temp_filament_op(ADVANCED_PAUSE_MODE_PAUSE_PRINT, 0); }
+  void menu_temp_e0_filament_load()    { _menu_temp_filament_op(ADVANCED_PAUSE_MODE_LOAD_FILAMENT, 0); }
+  void menu_temp_e0_filament_unload()  { _menu_temp_filament_op(ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT, 0); }
+  #if E_STEPPERS > 1
+    void menu_temp_e1_filament_change()  { _menu_temp_filament_op(ADVANCED_PAUSE_MODE_PAUSE_PRINT, 1); }
+    void menu_temp_e1_filament_load()    { _menu_temp_filament_op(ADVANCED_PAUSE_MODE_LOAD_FILAMENT, 1); }
+    void menu_temp_e1_filament_unload()  { _menu_temp_filament_op(ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT, 1); }
+    #if ENABLED(FILAMENT_UNLOAD_ALL_EXTRUDERS)
+      void menu_unload_filament_all_temp() { _menu_temp_filament_op(ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT, -1); }
+    #endif
+    #if E_STEPPERS > 2
+      void menu_temp_e2_filament_change()  { _menu_temp_filament_op(ADVANCED_PAUSE_MODE_PAUSE_PRINT, 2); }
+      void menu_temp_e2_filament_load()    { _menu_temp_filament_op(ADVANCED_PAUSE_MODE_LOAD_FILAMENT, 2); }
+      void menu_temp_e2_filament_unload()  { _menu_temp_filament_op(ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT, 2); }
+      #if E_STEPPERS > 3
+        void menu_temp_e3_filament_change()  { _menu_temp_filament_op(ADVANCED_PAUSE_MODE_PAUSE_PRINT, 3); }
+        void menu_temp_e3_filament_load()    { _menu_temp_filament_op(ADVANCED_PAUSE_MODE_LOAD_FILAMENT, 3); }
+        void menu_temp_e3_filament_unload()  { _menu_temp_filament_op(ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT, 3); }
+        #if E_STEPPERS > 4
+          void menu_temp_e4_filament_change()  { _menu_temp_filament_op(ADVANCED_PAUSE_MODE_PAUSE_PRINT, 4); }
+          void menu_temp_e4_filament_load()    { _menu_temp_filament_op(ADVANCED_PAUSE_MODE_LOAD_FILAMENT, 4); }
+          void menu_temp_e4_filament_unload()  { _menu_temp_filament_op(ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT, 4); }
+        #endif // E_STEPPERS > 4
+      #endif // E_STEPPERS > 3
+    #endif // E_STEPPERS > 2
+  #endif // E_STEPPERS > 1
+
+  /**
+   *
+   * "Change Filament" submenu
+   *
+   */
+  #if E_STEPPERS > 1 || ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
+    void menu_change_filament() {
+      START_MENU();
+      MENU_BACK(MSG_MAIN);
+
+      // Change filament
+      #if E_STEPPERS == 1
+        PGM_P msg0 = PSTR(MSG_FILAMENTCHANGE);
+        if (thermalManager.targetTooColdToExtrude(active_extruder))
+          MENU_ITEM_P(submenu, msg0, menu_temp_e0_filament_change);
+        else
+          MENU_ITEM_P(gcode, msg0, PSTR("M600 B0"));
+      #else
+        PGM_P msg0 = PSTR(MSG_FILAMENTCHANGE " " MSG_E1);
+        PGM_P msg1 = PSTR(MSG_FILAMENTCHANGE " " MSG_E2);
+        if (thermalManager.targetTooColdToExtrude(0))
+          MENU_ITEM_P(submenu, msg0, menu_temp_e0_filament_change);
+        else
+          MENU_ITEM_P(gcode, msg0, PSTR("M600 B0 T0"));
+        if (thermalManager.targetTooColdToExtrude(1))
+          MENU_ITEM_P(submenu, msg1, menu_temp_e1_filament_change);
+        else
+          MENU_ITEM_P(gcode, msg1, PSTR("M600 B0 T1"));
+        #if E_STEPPERS > 2
+          PGM_P msg2 = PSTR(MSG_FILAMENTCHANGE " " MSG_E3);
+          if (thermalManager.targetTooColdToExtrude(2))
+            MENU_ITEM_P(submenu, msg2, menu_temp_e2_filament_change);
+          else
+            MENU_ITEM_P(gcode, msg2, PSTR("M600 B0 T2"));
+          #if E_STEPPERS > 3
+            PGM_P msg3 = PSTR(MSG_FILAMENTCHANGE " " MSG_E4);
+            if (thermalManager.targetTooColdToExtrude(3))
+              MENU_ITEM_P(submenu, msg3, menu_temp_e3_filament_change);
+            else
+              MENU_ITEM_P(gcode, msg3, PSTR("M600 B0 T3"));
+            #if E_STEPPERS > 4
+              PGM_P msg4 = PSTR(MSG_FILAMENTCHANGE " " MSG_E5);
+              if (thermalManager.targetTooColdToExtrude(4))
+                MENU_ITEM_P(submenu, msg4, menu_temp_e4_filament_change);
+              else
+                MENU_ITEM_P(gcode, msg4, PSTR("M600 B0 T4"));
+              #if E_STEPPERS > 5
+                PGM_P msg5 = PSTR(MSG_FILAMENTCHANGE " " MSG_E6);
+                if (thermalManager.targetTooColdToExtrude(5))
+                  MENU_ITEM_P(submenu, msg5, menu_temp_e5_filament_change);
+                else
+                  MENU_ITEM_P(gcode, msg5, PSTR("M600 B0 T5"));
+              #endif // E_STEPPERS > 5
+            #endif // E_STEPPERS > 4
+          #endif // E_STEPPERS > 3
+        #endif // E_STEPPERS > 2
+      #endif // E_STEPPERS == 1
+
+      #if ENABLED(FILAMENT_LOAD_UNLOAD_GCODES)
+        if (!printer_busy()) {
+          // Load filament
+          #if E_STEPPERS == 1
+            PGM_P msg0 = PSTR(MSG_FILAMENTLOAD);
+            if (thermalManager.targetTooColdToExtrude(active_extruder))
+              MENU_ITEM_P(submenu, msg0, menu_temp_e0_filament_load);
+            else
+              MENU_ITEM_P(gcode, msg0, PSTR("M701"));
+          #else
+            PGM_P msg0 = PSTR(MSG_FILAMENTLOAD " " MSG_E1);
+            PGM_P msg1 = PSTR(MSG_FILAMENTLOAD " " MSG_E2);
+            if (thermalManager.targetTooColdToExtrude(0))
+              MENU_ITEM_P(submenu, msg0, menu_temp_e0_filament_load);
+            else
+              MENU_ITEM_P(gcode, msg0, PSTR("M701 T0"));
+            if (thermalManager.targetTooColdToExtrude(1))
+              MENU_ITEM_P(submenu, msg1, menu_temp_e1_filament_load);
+            else
+              MENU_ITEM_P(gcode, msg1, PSTR("M701 T1"));
+            #if E_STEPPERS > 2
+              PGM_P msg2 = PSTR(MSG_FILAMENTLOAD " " MSG_E3);
+              if (thermalManager.targetTooColdToExtrude(2))
+                MENU_ITEM_P(submenu, msg2, menu_temp_e2_filament_load);
+              else
+                MENU_ITEM_P(gcode, msg2, PSTR("M701 T2"));
+              #if E_STEPPERS > 3
+                PGM_P msg3 = PSTR(MSG_FILAMENTLOAD " " MSG_E4);
+                if (thermalManager.targetTooColdToExtrude(3))
+                  MENU_ITEM_P(submenu, msg3, menu_temp_e3_filament_load);
+                else
+                  MENU_ITEM_P(gcode, msg3, PSTR("M701 T3"));
+                #if E_STEPPERS > 4
+                  PGM_P msg4 = PSTR(MSG_FILAMENTLOAD " " MSG_E5);
+                  if (thermalManager.targetTooColdToExtrude(4))
+                    MENU_ITEM_P(submenu, msg4, menu_temp_e4_filament_load);
+                  else
+                    MENU_ITEM_P(gcode, msg4, PSTR("M701 T4"));
+                  #if E_STEPPERS > 5
+                    PGM_P msg5 = PSTR(MSG_FILAMENTLOAD " " MSG_E6);
+                    if (thermalManager.targetTooColdToExtrude(5))
+                      MENU_ITEM_P(submenu, msg5, menu_temp_e5_filament_load);
+                    else
+                      MENU_ITEM_P(gcode, msg5, PSTR("M701 T5"));
+                  #endif // E_STEPPERS > 5
+                #endif // E_STEPPERS > 4
+              #endif // E_STEPPERS > 3
+            #endif // E_STEPPERS > 2
+          #endif // E_STEPPERS == 1
+
+          // Unload filament
+          #if E_STEPPERS == 1
+            if (thermalManager.targetHotEnoughToExtrude(active_extruder))
+              MENU_ITEM(gcode, MSG_FILAMENTUNLOAD, PSTR("M702"));
+            else
+              MENU_ITEM(submenu, MSG_FILAMENTUNLOAD, menu_temp_e0_filament_unload);
+          #else
+            #if ENABLED(FILAMENT_UNLOAD_ALL_EXTRUDERS)
+              if (thermalManager.targetHotEnoughToExtrude(0)
+                #if E_STEPPERS > 1
+                  && thermalManager.targetHotEnoughToExtrude(1)
+                  #if E_STEPPERS > 2
+                    && thermalManager.targetHotEnoughToExtrude(2)
+                    #if E_STEPPERS > 3
+                      && thermalManager.targetHotEnoughToExtrude(3)
+                      #if E_STEPPERS > 4
+                        && thermalManager.targetHotEnoughToExtrude(4)
+                        #if E_STEPPERS > 5
+                          && thermalManager.targetHotEnoughToExtrude(5)
+                        #endif // E_STEPPERS > 5
+                      #endif // E_STEPPERS > 4
+                    #endif // E_STEPPERS > 3
+                  #endif // E_STEPPERS > 2
+                #endif // E_STEPPERS > 1
+              )
+                MENU_ITEM(gcode, MSG_FILAMENTUNLOAD_ALL, PSTR("M702"));
+            else
+              MENU_ITEM(submenu, MSG_FILAMENTUNLOAD_ALL, menu_unload_filament_all_temp);
+            #endif
+            if (thermalManager.targetHotEnoughToExtrude(0))
+              MENU_ITEM(gcode, MSG_FILAMENTUNLOAD " " MSG_E1, PSTR("M702 T0"));
+            else
+              MENU_ITEM(submenu, MSG_FILAMENTUNLOAD " " MSG_E1, menu_temp_e0_filament_unload);
+            if (thermalManager.targetHotEnoughToExtrude(1))
+              MENU_ITEM(gcode, MSG_FILAMENTUNLOAD " " MSG_E2, PSTR("M702 T1"));
+            else
+              MENU_ITEM(submenu, MSG_FILAMENTUNLOAD " " MSG_E2, menu_temp_e1_filament_unload);
+            #if E_STEPPERS > 2
+              if (thermalManager.targetHotEnoughToExtrude(2))
+                MENU_ITEM(gcode, MSG_FILAMENTUNLOAD " " MSG_E3, PSTR("M702 T2"));
+              else
+                MENU_ITEM(submenu, MSG_FILAMENTUNLOAD " " MSG_E3, menu_temp_e2_filament_unload);
+              #if E_STEPPERS > 3
+                if (thermalManager.targetHotEnoughToExtrude(3))
+                  MENU_ITEM(gcode, MSG_FILAMENTUNLOAD " " MSG_E4, PSTR("M702 T3"));
+                else
+                  MENU_ITEM(submenu, MSG_FILAMENTUNLOAD " " MSG_E4, menu_temp_e3_filament_unload);
+                #if E_STEPPERS > 4
+                  if (thermalManager.targetHotEnoughToExtrude(4))
+                    MENU_ITEM(gcode, MSG_FILAMENTUNLOAD " " MSG_E5, PSTR("M702 T4"));
+                  else
+                    MENU_ITEM(submenu, MSG_FILAMENTUNLOAD " " MSG_E5, menu_temp_e4_filament_unload);
+                  #if E_STEPPERS > 5
+                    if (thermalManager.targetHotEnoughToExtrude(5))
+                      MENU_ITEM(gcode, MSG_FILAMENTUNLOAD " " MSG_E6, PSTR("M702 T5"));
+                    else
+                      MENU_ITEM(submenu, MSG_FILAMENTUNLOAD " " MSG_E6, menu_temp_e5_filament_unload);
+                  #endif // E_STEPPERS > 5
+                #endif // E_STEPPERS > 4
+              #endif // E_STEPPERS > 3
+            #endif // E_STEPPERS > 2
+          #endif // E_STEPPERS == 1
+        }
+      #endif
+
+      END_MENU();
+    }
+  #endif
+
+  static AdvancedPauseMode advanced_pause_mode = ADVANCED_PAUSE_MODE_PAUSE_PRINT;
+  static uint8_t hotend_status_extruder = 0;
+
+  static PGM_P advanced_pause_header() {
+    switch (advanced_pause_mode) {
+      case ADVANCED_PAUSE_MODE_LOAD_FILAMENT:
+        return PSTR(MSG_FILAMENT_CHANGE_HEADER_LOAD);
+      case ADVANCED_PAUSE_MODE_UNLOAD_FILAMENT:
+        return PSTR(MSG_FILAMENT_CHANGE_HEADER_UNLOAD);
+      default: break;
+    }
+    return PSTR(MSG_FILAMENT_CHANGE_HEADER_PAUSE);
+  }
+
+  // Portions from STATIC_ITEM...
+  #define HOTEND_STATUS_ITEM() do { \
+    if (_menuLineNr == _thisItemNr) { \
+      if (lcdDrawUpdate) { \
+        lcd_implementation_drawmenu_static(_lcdLineNr, PSTR(MSG_FILAMENT_CHANGE_NOZZLE), false, true); \
+        lcd_implementation_hotend_status(_lcdLineNr, hotend_status_extruder); \
+      } \
+      if (_skipStatic && encoderLine <= _thisItemNr) { \
+        encoderPosition += ENCODER_STEPS_PER_MENU_ITEM; \
+        ++encoderLine; \
+      } \
+      lcdDrawUpdate = LCDVIEW_CALL_REDRAW_NEXT; \
+    } \
+    ++_thisItemNr; \
+  }while(0)
+
+  void lcd_advanced_pause_resume_print() {
+    advanced_pause_menu_response = ADVANCED_PAUSE_RESPONSE_RESUME_PRINT;
+  }
+
+  void lcd_advanced_pause_extrude_more() {
+    advanced_pause_menu_response = ADVANCED_PAUSE_RESPONSE_EXTRUDE_MORE;
+  }
+
+  void menu_advanced_pause_option() {
+    START_MENU();
+    #if LCD_HEIGHT > 2
+      STATIC_ITEM(MSG_FILAMENT_CHANGE_OPTION_HEADER, true, false);
+    #endif
+    MENU_ITEM(function, MSG_FILAMENT_CHANGE_OPTION_RESUME, lcd_advanced_pause_resume_print);
+    MENU_ITEM(function, MSG_FILAMENT_CHANGE_OPTION_PURGE, lcd_advanced_pause_extrude_more);
+    END_MENU();
+  }
+
+  void lcd_advanced_pause_init_message() {
+    START_SCREEN();
+    STATIC_ITEM_P(advanced_pause_header(), true, true);
+    STATIC_ITEM(MSG_FILAMENT_CHANGE_INIT_1);
+    #ifdef MSG_FILAMENT_CHANGE_INIT_2
+      STATIC_ITEM(MSG_FILAMENT_CHANGE_INIT_2);
+      #define __FC_LINES_A 3
+    #else
+      #define __FC_LINES_A 2
+    #endif
+    #ifdef MSG_FILAMENT_CHANGE_INIT_3
+      STATIC_ITEM(MSG_FILAMENT_CHANGE_INIT_3);
+      #define _FC_LINES_A (__FC_LINES_A + 1)
+    #else
+      #define _FC_LINES_A __FC_LINES_A
+    #endif
+    #if LCD_HEIGHT > _FC_LINES_A + 1
+      STATIC_ITEM(" ");
+    #endif
+    HOTEND_STATUS_ITEM();
+    END_SCREEN();
+  }
+
+  void lcd_advanced_pause_unload_message() {
+    START_SCREEN();
+    STATIC_ITEM_P(advanced_pause_header(), true, true);
+    STATIC_ITEM(MSG_FILAMENT_CHANGE_UNLOAD_1);
+    #ifdef MSG_FILAMENT_CHANGE_UNLOAD_2
+      STATIC_ITEM(MSG_FILAMENT_CHANGE_UNLOAD_2);
+      #define __FC_LINES_B 3
+    #else
+      #define __FC_LINES_B 2
+    #endif
+    #ifdef MSG_FILAMENT_CHANGE_UNLOAD_3
+      STATIC_ITEM(MSG_FILAMENT_CHANGE_UNLOAD_3);
+      #define _FC_LINES_B (__FC_LINES_B + 1)
+    #else
+      #define _FC_LINES_B __FC_LINES_B
+    #endif
+    #if LCD_HEIGHT > _FC_LINES_B + 1
+      STATIC_ITEM(" ");
+    #endif
+    HOTEND_STATUS_ITEM();
+    END_SCREEN();
+  }
+
+  void lcd_advanced_pause_wait_for_nozzles_to_heat() {
+    START_SCREEN();
+    STATIC_ITEM_P(advanced_pause_header(), true, true);
+    STATIC_ITEM(MSG_FILAMENT_CHANGE_HEATING_1);
+    #ifdef MSG_FILAMENT_CHANGE_HEATING_2
+      STATIC_ITEM(MSG_FILAMENT_CHANGE_HEATING_2);
+      #define _FC_LINES_C 3
+    #else
+      #define _FC_LINES_C 2
+    #endif
+    #if LCD_HEIGHT > _FC_LINES_C + 1
+      STATIC_ITEM(" ");
+    #endif
+    HOTEND_STATUS_ITEM();
+    END_SCREEN();
+  }
+
+  void lcd_advanced_pause_heat_nozzle() {
+    START_SCREEN();
+    STATIC_ITEM_P(advanced_pause_header(), true, true);
+    STATIC_ITEM(MSG_FILAMENT_CHANGE_HEAT_1);
+    #ifdef MSG_FILAMENT_CHANGE_INSERT_2
+      STATIC_ITEM(MSG_FILAMENT_CHANGE_HEAT_2);
+      #define _FC_LINES_D 3
+    #else
+      #define _FC_LINES_D 2
+    #endif
+    #if LCD_HEIGHT > _FC_LINES_D + 1
+      STATIC_ITEM(" ");
+    #endif
+    HOTEND_STATUS_ITEM();
+    END_SCREEN();
+  }
+
+  void lcd_advanced_pause_insert_message() {
+    START_SCREEN();
+    STATIC_ITEM_P(advanced_pause_header(), true, true);
+    STATIC_ITEM(MSG_FILAMENT_CHANGE_INSERT_1);
+    #ifdef MSG_FILAMENT_CHANGE_INSERT_2
+      STATIC_ITEM(MSG_FILAMENT_CHANGE_INSERT_2);
+      #define __FC_LINES_E 3
+    #else
+      #define __FC_LINES_E 2
+    #endif
+    #ifdef MSG_FILAMENT_CHANGE_INSERT_3
+      STATIC_ITEM(MSG_FILAMENT_CHANGE_INSERT_3);
+      #define _FC_LINES_E (__FC_LINES_E + 1)
+    #else
+      #define _FC_LINES_E __FC_LINES_E
+    #endif
+    #if LCD_HEIGHT > _FC_LINES_E + 1
+      STATIC_ITEM(" ");
+    #endif
+    HOTEND_STATUS_ITEM();
+    END_SCREEN();
+  }
+
+  void lcd_advanced_pause_load_message() {
+    START_SCREEN();
+    STATIC_ITEM_P(advanced_pause_header(), true, true);
+    STATIC_ITEM(MSG_FILAMENT_CHANGE_LOAD_1);
+    #ifdef MSG_FILAMENT_CHANGE_LOAD_2
+      STATIC_ITEM(MSG_FILAMENT_CHANGE_LOAD_2);
+      #define __FC_LINES_F 3
+    #else
+      #define __FC_LINES_F 2
+    #endif
+    #ifdef MSG_FILAMENT_CHANGE_LOAD_3
+      STATIC_ITEM(MSG_FILAMENT_CHANGE_LOAD_3);
+      #define _FC_LINES_F (__FC_LINES_F + 1)
+    #else
+      #define _FC_LINES_F __FC_LINES_F
+    #endif
+    #if LCD_HEIGHT > _FC_LINES_F + 1
+      STATIC_ITEM(" ");
+    #endif
+    HOTEND_STATUS_ITEM();
+    END_SCREEN();
+  }
+
+  void lcd_advanced_pause_purge_message() {
+    START_SCREEN();
+    STATIC_ITEM_P(advanced_pause_header(), true, true);
+    STATIC_ITEM(MSG_FILAMENT_CHANGE_PURGE_1);
+    #ifdef MSG_FILAMENT_CHANGE_PURGE_2
+      STATIC_ITEM(MSG_FILAMENT_CHANGE_PURGE_2);
+      #define __FC_LINES_G 3
+    #else
+      #define __FC_LINES_G 2
+    #endif
+    #ifdef MSG_FILAMENT_CHANGE_PURGE_3
+      STATIC_ITEM(MSG_FILAMENT_CHANGE_PURGE_3);
+      #define _FC_LINES_G (__FC_LINES_G + 1)
+    #else
+      #define _FC_LINES_G __FC_LINES_G
+    #endif
+    #if LCD_HEIGHT > _FC_LINES_G + 1
+      STATIC_ITEM(" ");
+    #endif
+    HOTEND_STATUS_ITEM();
+    END_SCREEN();
+  }
+
+  #if ENABLED(ADVANCED_PAUSE_CONTINUOUS_PURGE)
+    void menu_advanced_pause_continuous_purge() {
+      START_SCREEN();
+      STATIC_ITEM(MSG_FILAMENT_CHANGE_PURGE_1);
+      #ifdef MSG_FILAMENT_CHANGE_PURGE_2
+        STATIC_ITEM(MSG_FILAMENT_CHANGE_PURGE_2);
+        #define __FC_LINES_G 3
+      #else
+        #define __FC_LINES_G 2
+      #endif
+      #ifdef MSG_FILAMENT_CHANGE_PURGE_3
+        STATIC_ITEM(MSG_FILAMENT_CHANGE_PURGE_3);
+        #define _FC_LINES_G (__FC_LINES_G + 1)
+      #else
+        #define _FC_LINES_G __FC_LINES_G
+      #endif
+      #if LCD_HEIGHT > _FC_LINES_G + 1
+        STATIC_ITEM(" ");
+      #endif
+      HOTEND_STATUS_ITEM();
+      STATIC_ITEM(MSG_USERWAIT);
+      END_SCREEN();
+    }
+  #endif
+
+  void lcd_advanced_pause_resume_message() {
+    START_SCREEN();
+    STATIC_ITEM_P(advanced_pause_header(), true, true);
+    STATIC_ITEM(MSG_FILAMENT_CHANGE_RESUME_1);
+    #ifdef MSG_FILAMENT_CHANGE_RESUME_2
+      STATIC_ITEM(MSG_FILAMENT_CHANGE_RESUME_2);
+    #endif
+    #ifdef MSG_FILAMENT_CHANGE_RESUME_3
+      STATIC_ITEM(MSG_FILAMENT_CHANGE_RESUME_3);
+    #endif
+    END_SCREEN();
+  }
+
+  FORCE_INLINE screenFunc_t ap_message_screen(const AdvancedPauseMessage message) {
+    switch (message) {
+      case ADVANCED_PAUSE_MESSAGE_INIT: return lcd_advanced_pause_init_message;
+      case ADVANCED_PAUSE_MESSAGE_UNLOAD: return lcd_advanced_pause_unload_message;
+      case ADVANCED_PAUSE_MESSAGE_INSERT: return lcd_advanced_pause_insert_message;
+      case ADVANCED_PAUSE_MESSAGE_LOAD: return lcd_advanced_pause_load_message;
+      case ADVANCED_PAUSE_MESSAGE_PURGE: return lcd_advanced_pause_purge_message;
+      case ADVANCED_PAUSE_MESSAGE_RESUME: return lcd_advanced_pause_resume_message;
+      case ADVANCED_PAUSE_MESSAGE_CLICK_TO_HEAT_NOZZLE: return lcd_advanced_pause_heat_nozzle;
+      case ADVANCED_PAUSE_MESSAGE_WAIT_FOR_NOZZLES_TO_HEAT: return lcd_advanced_pause_wait_for_nozzles_to_heat;
+      case ADVANCED_PAUSE_MESSAGE_OPTION: advanced_pause_menu_response = ADVANCED_PAUSE_RESPONSE_WAIT_FOR;
+                                          return menu_advanced_pause_option;
+      #if ENABLED(ADVANCED_PAUSE_CONTINUOUS_PURGE)
+        case ADVANCED_PAUSE_MESSAGE_CONTINUOUS_PURGE: return menu_advanced_pause_continuous_purge;
+      #endif
+      case ADVANCED_PAUSE_MESSAGE_STATUS:
+      default: break;
+    }
+    return NULL;
+  }
+
+  void lcd_advanced_pause_show_message(
+    const AdvancedPauseMessage message,
+    const AdvancedPauseMode mode/*=ADVANCED_PAUSE_MODE_PAUSE_PRINT*/,
+    const uint8_t extruder/*=active_extruder*/
+  ) {
+    advanced_pause_mode = mode;
+    hotend_status_extruder = extruder;
+    const screenFunc_t next_screen = ap_message_screen(message);
+    if (next_screen) {
+      defer_return_to_status = true;
+      lcd_goto_screen(next_screen);
+    }
+    else
+      lcd_return_to_status();
+  }
+
+#endif // ADVANCED_PAUSE_FEATURE
+
+#endif // ULTIPANEL
