commit 4cddc61eda70d9e78ef7767fc052995855e34a79
Author: Alexander Gavrilenko <jmz52@users.noreply.github.com>
Date:   Mon Jan 8 03:18:18 2024 +0300

    🐛 Fix SPI TFT for STM32F1/F4 (#26052)

diff --git a/Marlin/src/HAL/STM32/tft/tft_spi.cpp b/Marlin/src/HAL/STM32/tft/tft_spi.cpp
index cca247e20d..cda2eb28e3 100644
--- a/Marlin/src/HAL/STM32/tft/tft_spi.cpp
+++ b/Marlin/src/HAL/STM32/tft/tft_spi.cpp
@@ -31,6 +31,10 @@
 #include "tft_spi.h"
 #include "pinconfig.h"
 
+//#define DEBUG_TFT_IO
+#define DEBUG_OUT ENABLED(DEBUG_TFT_IO)
+#include "../../../core/debug_out.h"
+
 SPI_HandleTypeDef TFT_SPI::SPIx;
 DMA_HandleTypeDef TFT_SPI::DMAtx;
 
@@ -43,8 +47,9 @@ void TFT_SPI::init() {
   if ((spiInstance = (SPI_TypeDef *)pinmap_peripheral(digitalPinToPinName(TFT_SCK_PIN),  PinMap_SPI_SCLK)) == NP) return;
   if (spiInstance != (SPI_TypeDef *)pinmap_peripheral(digitalPinToPinName(TFT_MOSI_PIN), PinMap_SPI_MOSI)) return;
 
-  #if PIN_EXISTS(TFT_MISO) && TFT_MISO_PIN != TFT_MOSI_PIN
-    if (spiInstance != (SPI_TypeDef *)pinmap_peripheral(digitalPinToPinName(TFT_MISO_PIN), PinMap_SPI_MISO)) return;
+  #if PIN_EXISTS(TFT_MISO)
+    // Check these pins in code because they are sometimes defined as analog pin references
+    if ((TFT_MISO_PIN != TFT_MOSI_PIN) && (spiInstance != (SPI_TypeDef *)pinmap_peripheral(digitalPinToPinName(TFT_MISO_PIN), PinMap_SPI_MISO))) return;
   #endif
 
   SPIx.Instance                = spiInstance;
@@ -76,10 +81,13 @@ void TFT_SPI::init() {
 
   pinmap_pinout(digitalPinToPinName(TFT_SCK_PIN), PinMap_SPI_SCLK);
   pinmap_pinout(digitalPinToPinName(TFT_MOSI_PIN), PinMap_SPI_MOSI);
-  #if PIN_EXISTS(TFT_MISO) && TFT_MISO_PIN != TFT_MOSI_PIN
-    pinmap_pinout(digitalPinToPinName(TFT_MISO_PIN), PinMap_SPI_MISO);
+  #if PIN_EXISTS(TFT_MISO)
+    // Check these pins in code because they are sometimes defined as analog pin references
+    if (TFT_MISO_PIN != TFT_MOSI_PIN) pinmap_pinout(digitalPinToPinName(TFT_MISO_PIN), PinMap_SPI_MISO);
   #endif
 
+  //pin_PullConfig(get_GPIO_Port(STM_PORT(digitalPinToPinName(TFT_SCK_PIN))), STM_LL_GPIO_PIN(digitalPinToPinName(TFT_SCK_PIN)), GPIO_PULLDOWN);
+
   #ifdef SPI1_BASE
     if (SPIx.Instance == SPI1) {
       __HAL_RCC_SPI1_CLK_ENABLE();
@@ -151,29 +159,47 @@ void TFT_SPI::dataTransferBegin(uint16_t dataSize) {
   WRITE(TFT_CS_PIN, LOW);
 }
 
-#ifdef TFT_DEFAULT_DRIVER
-  #include "../../../lcd/tft_io/tft_ids.h"
-#endif
+#include "../../../lcd/tft_io/tft_ids.h"
 
 uint32_t TFT_SPI::getID() {
-  uint32_t id;
-  id = readID(LCD_READ_ID);
+  DEBUG_ECHOLNPGM("TFT_SPI::getID()");
+
+  uint32_t id = readID(LCD_READ_ID);
+  #if ENABLED(DEBUG_TFT_IO)
+    char debug_register[3], debug_value[5];
+    sprintf_P(debug_register, PSTR("%02X"), LCD_READ_ID);
+    sprintf_P(debug_value, PSTR("%04X"), uint16_t(id));
+    DEBUG_ECHOLNPGM("  readID(0x", debug_register, ") : 0x", debug_value);
+  #endif
+
   if ((id & 0xFFFF) == 0 || (id & 0xFFFF) == 0xFFFF) {
     id = readID(LCD_READ_ID4);
-    #ifdef TFT_DEFAULT_DRIVER
-      if ((id & 0xFFFF) == 0 || (id & 0xFFFF) == 0xFFFF)
-        id = TFT_DEFAULT_DRIVER;
+    #if ENABLED(DEBUG_TFT_IO)
+      sprintf_P(debug_register, PSTR("%02X"), LCD_READ_ID4);
+      sprintf_P(debug_value, PSTR("%04X"), uint16_t(id));
+      DEBUG_ECHOLNPGM("  readID(0x", debug_register, ") : 0x", debug_value);
     #endif
-   }
+  }
+
+  #ifdef TFT_DEFAULT_DRIVER
+    if ((id & 0xFFFF) == 0 || (id & 0xFFFF) == 0xFFFF) {
+      id = TFT_DEFAULT_DRIVER;
+      #if ENABLED(DEBUG_TFT_IO)
+        sprintf_P(debug_value, PSTR("%04X"), uint16_t(id));
+        DEBUG_ECHOLNPGM("  Fallback to TFT_DEFAULT_DRIVER : 0x", debug_value);
+      #endif
+    }
+  #endif
+
   return id;
 }
 
 uint32_t TFT_SPI::readID(const uint16_t inReg) {
   uint32_t data = 0;
   #if PIN_EXISTS(TFT_MISO)
-    const uint32_t oldPrescaler = SPIx.Init.BaudRatePrescaler;
-
+    uint32_t BaudRatePrescaler = SPIx.Init.BaudRatePrescaler;
     SPIx.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_64;
+
     dataTransferBegin(DATASIZE_8BIT);
     writeReg(inReg);
 
@@ -185,10 +211,8 @@ uint32_t TFT_SPI::readID(const uint16_t inReg) {
         __HAL_SPI_ENABLE(&SPIx);
         SET_BIT(SPIx.Instance->CR1, SPI_CR1_CSTART);
 
-        #if TFT_MISO_PIN != TFT_MOSI_PIN
-          SPIx.Instance->TXDR = 0;
-        #endif
-        while (!__HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_EOT)) {}
+        if (SPIx.Init.Direction == SPI_DIRECTION_2LINES) SPIx.Instance->TXDR = 0;
+        while (!__HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_EOT)) { /* nada */ }
         data = (data << 8) | SPIx.Instance->RXDR;
         __HAL_SPI_DISABLE(&SPIx);
         __HAL_SPI_CLEAR_EOTFLAG(&SPIx);
@@ -197,19 +221,22 @@ uint32_t TFT_SPI::readID(const uint16_t inReg) {
     #else
       __HAL_SPI_ENABLE(&SPIx);
       for (uint32_t i = 0; i < 4; i++) {
-        #if TFT_MISO_PIN != TFT_MOSI_PIN
-          while (!__HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_TXE)) {}
+        if (SPIx.Init.Direction == SPI_DIRECTION_2LINES) {
+          while (!__HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_TXE)) { /* nada */ }
           SPIx.Instance->DR = 0;
-        #endif
-        while (!__HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_RXNE)) {}
+        }
+        while (!__HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_RXNE)) { /* nada */ }
         data = (data << 8) | SPIx.Instance->DR;
       }
     #endif
 
     dataTransferEnd();
-    SPIx.Init.BaudRatePrescaler = oldPrescaler;
+    #if DISABLED(DEBUG_TFT_IO)
+      SPIx.Init.BaudRatePrescaler = BaudRatePrescaler;
+    #endif
   #endif
 
+  DEBUG_ECHOLNPGM("  raw data : ", data);
   return data >> 7;
 }
 
@@ -238,13 +265,13 @@ bool TFT_SPI::isBusy() {
       // Check if SPI data transfer is completed
       if (!__HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_EOT)) return true;
     #else
-      // Check if SPI is idle
-      if (__HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_BSY)) return true;
+      // Check if SPI transmit butter is empty and SPI is idle
+      if ((!__HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_TXE)) || (__HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_BSY))) return true;
     #endif
   }
 
   abort();
-  return false;
+  return true;
 }
 
 void TFT_SPI::abort() {
@@ -263,9 +290,7 @@ void TFT_SPI::abort() {
 }
 
 void TFT_SPI::transmit(uint16_t data) {
-  #if TFT_MISO_PIN == TFT_MOSI_PIN
-    SPI_1LINE_TX(&SPIx);
-  #endif
+  if (SPIx.Init.Direction == SPI_DIRECTION_1LINE) SPI_1LINE_TX(&SPIx);
 
   #ifdef STM32H7xx
     MODIFY_REG(SPIx.Instance->CR2, SPI_CR2_TSIZE, 1);
@@ -274,30 +299,26 @@ void TFT_SPI::transmit(uint16_t data) {
 
     SPIx.Instance->TXDR = data;
 
-    while (!__HAL_SPI_GET_FLAG(&SPIx, SPI_SR_EOT)) {}
+    while (!__HAL_SPI_GET_FLAG(&SPIx, SPI_SR_EOT)) { /* nada */ }
 
     __HAL_SPI_CLEAR_EOTFLAG(&SPIx);
     __HAL_SPI_CLEAR_TXTFFLAG(&SPIx);
+    __HAL_SPI_DISABLE(&SPIx);
   #else
     __HAL_SPI_ENABLE(&SPIx);
     SPIx.Instance->DR = data;
-    while (__HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_BSY)) {}
+    while (!__HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_TXE)) { /* nada */ } // Wait for data transfer to actually start
+    while ( __HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_BSY)) { /* nada */ } // Wait until SPI is idle
   #endif
 
-  __HAL_SPI_DISABLE(&SPIx);
-
-  #if TFT_MISO_PIN != TFT_MOSI_PIN
-    __HAL_SPI_CLEAR_OVRFLAG(&SPIx);   // Clear overrun flag in 2 Lines communication mode because received data is not read
-  #endif
+  if (SPIx.Init.Direction == SPI_DIRECTION_2LINES) __HAL_SPI_CLEAR_OVRFLAG(&SPIx);  // Clear overrun flag in 2 Lines communication mode because received data is not read
 }
 
 void TFT_SPI::transmitDMA(uint32_t memoryIncrease, uint16_t *data, uint16_t count) {
   DMAtx.Init.MemInc = memoryIncrease;
   HAL_DMA_Init(&DMAtx);
 
-  #if TFT_MISO_PIN == TFT_MOSI_PIN
-    SPI_1LINE_TX(&SPIx);
-  #endif
+  if (SPIx.Init.Direction == SPI_DIRECTION_1LINE) SPI_1LINE_TX(&SPIx);
 
   dataTransferBegin();
 
@@ -316,7 +337,7 @@ void TFT_SPI::transmitDMA(uint32_t memoryIncrease, uint16_t *data, uint16_t coun
     SET_BIT(SPIx.Instance->CR2, SPI_CR2_TXDMAEN);   // Enable Tx DMA Request
   #endif
 
-  TERN_(TFT_SHARED_IO, while (isBusy()));
+  TERN_(TFT_SHARED_IO, while (isBusy()) { /* nada */ });
 }
 
 void TFT_SPI::transmit(uint32_t memoryIncrease, uint16_t *data, uint16_t count) {
@@ -324,9 +345,10 @@ void TFT_SPI::transmit(uint32_t memoryIncrease, uint16_t *data, uint16_t count)
 
   HAL_DMA_PollForTransfer(&DMAtx, HAL_DMA_FULL_TRANSFER, HAL_MAX_DELAY);
   #ifdef STM32H7xx
-    while (!__HAL_SPI_GET_FLAG(&SPIx, SPI_SR_EOT)) {}
+    while (!__HAL_SPI_GET_FLAG(&SPIx, SPI_SR_EOT)) { /* nada */ }
   #else
-    while (__HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_BSY)) {}
+    while (!__HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_TXE)) { /* nada */ }
+    while (__HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_BSY)) { /* nada */ }
   #endif
   abort();
 }
@@ -337,8 +359,7 @@ void TFT_SPI::transmit(uint32_t memoryIncrease, uint16_t *data, uint16_t count)
     DMAtx.Init.MemInc = memoryIncrease;
     HAL_DMA_Init(&DMAtx);
 
-    if (TFT_MISO_PIN == TFT_MOSI_PIN)
-      SPI_1LINE_TX(&SPIx);
+    if (SPIx.Init.Direction == SPI_DIRECTION_1LINE) SPI_1LINE_TX(&SPIx);
 
     dataTransferBegin();
 

commit 3ea87ad54c1e445a1c8cfef1489809edae5decb3
Author: Alexander Gavrilenko <jmz52@users.noreply.github.com>
Date:   Sun Jul 2 04:16:12 2023 +0300

    ✨ SPI TFT / Touchscreen for STM32H7 (#25784)
    
    Co-authored-by: thisiskeithb <13375512+thisiskeithb@users.noreply.github.com>
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/HAL/STM32/tft/tft_spi.cpp b/Marlin/src/HAL/STM32/tft/tft_spi.cpp
index eb81a27bf1..cca247e20d 100644
--- a/Marlin/src/HAL/STM32/tft/tft_spi.cpp
+++ b/Marlin/src/HAL/STM32/tft/tft_spi.cpp
@@ -52,7 +52,6 @@ void TFT_SPI::init() {
   SPIx.Init.NSS                = SPI_NSS_SOFT;
   SPIx.Init.Mode               = SPI_MODE_MASTER;
   SPIx.Init.Direction          = (TFT_MISO_PIN == TFT_MOSI_PIN) ? SPI_DIRECTION_1LINE : SPI_DIRECTION_2LINES;
-  SPIx.Init.BaudRatePrescaler  = SPI_BAUDRATEPRESCALER_2;
   SPIx.Init.CLKPhase           = SPI_PHASE_1EDGE;
   SPIx.Init.CLKPolarity        = SPI_POLARITY_LOW;
   SPIx.Init.DataSize           = SPI_DATASIZE_8BIT;
@@ -61,12 +60,25 @@ void TFT_SPI::init() {
   SPIx.Init.CRCCalculation     = SPI_CRCCALCULATION_DISABLE;
   SPIx.Init.CRCPolynomial      = 10;
 
+  #ifndef STM32H7xx
+    SPIx.Init.BaudRatePrescaler       = SPI_BAUDRATEPRESCALER_2; // 18 MBit/s for F103, 21 MBit/s for F407, 25 MBit/s for F411
+  #else
+    SPIx.Init.BaudRatePrescaler       = SPI_BAUDRATEPRESCALER_4; // 20 MBit/s for H743
+    SPIx.Init.NSSPMode                = SPI_NSS_PULSE_ENABLE;
+    SPIx.Init.NSSPolarity             = SPI_NSS_POLARITY_LOW;
+    SPIx.Init.FifoThreshold           = SPI_FIFO_THRESHOLD_01DATA;
+    SPIx.Init.MasterSSIdleness        = SPI_MASTER_SS_IDLENESS_00CYCLE;
+    SPIx.Init.MasterInterDataIdleness = SPI_MASTER_INTERDATA_IDLENESS_00CYCLE;
+    SPIx.Init.MasterReceiverAutoSusp  = SPI_MASTER_RX_AUTOSUSP_DISABLE;
+    SPIx.Init.MasterKeepIOState       = SPI_MASTER_KEEP_IO_STATE_ENABLE;
+    SPIx.Init.IOSwap                  = SPI_IO_SWAP_DISABLE;
+  #endif
+
   pinmap_pinout(digitalPinToPinName(TFT_SCK_PIN), PinMap_SPI_SCLK);
   pinmap_pinout(digitalPinToPinName(TFT_MOSI_PIN), PinMap_SPI_MOSI);
   #if PIN_EXISTS(TFT_MISO) && TFT_MISO_PIN != TFT_MOSI_PIN
     pinmap_pinout(digitalPinToPinName(TFT_MISO_PIN), PinMap_SPI_MISO);
   #endif
-  pin_PullConfig(get_GPIO_Port(STM_PORT(digitalPinToPinName(TFT_SCK_PIN))), STM_LL_GPIO_PIN(digitalPinToPinName(TFT_SCK_PIN)), GPIO_PULLDOWN);
 
   #ifdef SPI1_BASE
     if (SPIx.Instance == SPI1) {
@@ -74,12 +86,17 @@ void TFT_SPI::init() {
       #ifdef STM32F1xx
         __HAL_RCC_DMA1_CLK_ENABLE();
         DMAtx.Instance = DMA1_Channel3;
+        SPIx.Init.BaudRatePrescaler  = SPI_BAUDRATEPRESCALER_4; // SPI1 clock on F1 and F4 is two times faster than SPI2 and SPI3 clock
       #elif defined(STM32F4xx)
         __HAL_RCC_DMA2_CLK_ENABLE();
         DMAtx.Instance = DMA2_Stream3;
         DMAtx.Init.Channel = DMA_CHANNEL_3;
+        SPIx.Init.BaudRatePrescaler  = SPI_BAUDRATEPRESCALER_4; // SPI1 clock on F1 and F4 is two times faster than SPI2 and SPI3 clock
+      #elif defined(STM32H7xx)
+        __HAL_RCC_DMA1_CLK_ENABLE();
+        DMAtx.Instance = DMA1_Stream4;
+        DMAtx.Init.Request = DMA_REQUEST_SPI1_TX;
       #endif
-      SPIx.Init.BaudRatePrescaler  = SPI_BAUDRATEPRESCALER_4;
     }
   #endif
   #ifdef SPI2_BASE
@@ -92,6 +109,10 @@ void TFT_SPI::init() {
         __HAL_RCC_DMA1_CLK_ENABLE();
         DMAtx.Instance = DMA1_Stream4;
         DMAtx.Init.Channel = DMA_CHANNEL_0;
+      #elif defined(STM32H7xx)
+        __HAL_RCC_DMA1_CLK_ENABLE();
+        DMAtx.Instance = DMA1_Stream4;
+        DMAtx.Init.Request = DMA_REQUEST_SPI2_TX;
       #endif
     }
   #endif
@@ -105,25 +126,27 @@ void TFT_SPI::init() {
         __HAL_RCC_DMA1_CLK_ENABLE();
         DMAtx.Instance = DMA1_Stream5;
         DMAtx.Init.Channel = DMA_CHANNEL_0;
+      #elif defined(STM32H7xx)
+        __HAL_RCC_DMA1_CLK_ENABLE();
+        DMAtx.Instance = DMA1_Stream4;
+        DMAtx.Init.Request = DMA_REQUEST_SPI3_TX;
       #endif
     }
   #endif
 
-  HAL_SPI_Init(&SPIx);
-
   DMAtx.Init.Direction = DMA_MEMORY_TO_PERIPH;
   DMAtx.Init.PeriphInc = DMA_PINC_DISABLE;
   DMAtx.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
   DMAtx.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
   DMAtx.Init.Mode = DMA_NORMAL;
   DMAtx.Init.Priority = DMA_PRIORITY_LOW;
-  #ifdef STM32F4xx
+  #if ANY(STM32F4xx, STM32H7xx)
     DMAtx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
   #endif
 }
 
 void TFT_SPI::dataTransferBegin(uint16_t dataSize) {
-  SPIx.Init.DataSize = dataSize == DATASIZE_8BIT ?  SPI_DATASIZE_8BIT : SPI_DATASIZE_16BIT;
+  SPIx.Init.DataSize = dataSize;
   HAL_SPI_Init(&SPIx);
   WRITE(TFT_CS_PIN, LOW);
 }
@@ -148,28 +171,43 @@ uint32_t TFT_SPI::getID() {
 uint32_t TFT_SPI::readID(const uint16_t inReg) {
   uint32_t data = 0;
   #if PIN_EXISTS(TFT_MISO)
-    uint32_t BaudRatePrescaler = SPIx.Init.BaudRatePrescaler;
-    uint32_t i;
+    const uint32_t oldPrescaler = SPIx.Init.BaudRatePrescaler;
 
-    SPIx.Init.BaudRatePrescaler = SPIx.Instance == SPI1 ? SPI_BAUDRATEPRESCALER_8 : SPI_BAUDRATEPRESCALER_4;
+    SPIx.Init.BaudRatePrescaler = SPI_BAUDRATEPRESCALER_64;
     dataTransferBegin(DATASIZE_8BIT);
     writeReg(inReg);
 
     if (SPIx.Init.Direction == SPI_DIRECTION_1LINE) SPI_1LINE_RX(&SPIx);
-    __HAL_SPI_ENABLE(&SPIx);
 
-    for (i = 0; i < 4; i++) {
-      #if TFT_MISO_PIN != TFT_MOSI_PIN
-        while (!__HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_TXE)) {}
-        SPIx.Instance->DR = 0;
-      #endif
-      while (!__HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_RXNE)) {}
-      data = (data << 8) | SPIx.Instance->DR;
-    }
+    #ifdef STM32H7xx
+      for (uint32_t i = 0; i < 4; i++) {
+        MODIFY_REG(SPIx.Instance->CR2, SPI_CR2_TSIZE, 1);
+        __HAL_SPI_ENABLE(&SPIx);
+        SET_BIT(SPIx.Instance->CR1, SPI_CR1_CSTART);
+
+        #if TFT_MISO_PIN != TFT_MOSI_PIN
+          SPIx.Instance->TXDR = 0;
+        #endif
+        while (!__HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_EOT)) {}
+        data = (data << 8) | SPIx.Instance->RXDR;
+        __HAL_SPI_DISABLE(&SPIx);
+        __HAL_SPI_CLEAR_EOTFLAG(&SPIx);
+        __HAL_SPI_CLEAR_TXTFFLAG(&SPIx);
+      }
+    #else
+      __HAL_SPI_ENABLE(&SPIx);
+      for (uint32_t i = 0; i < 4; i++) {
+        #if TFT_MISO_PIN != TFT_MOSI_PIN
+          while (!__HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_TXE)) {}
+          SPIx.Instance->DR = 0;
+        #endif
+        while (!__HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_RXNE)) {}
+        data = (data << 8) | SPIx.Instance->DR;
+      }
+    #endif
 
     dataTransferEnd();
-
-    SPIx.Init.BaudRatePrescaler   = BaudRatePrescaler;
+    SPIx.Init.BaudRatePrescaler = oldPrescaler;
   #endif
 
   return data >> 7;
@@ -182,6 +220,9 @@ bool TFT_SPI::isBusy() {
   #elif defined(STM32F4xx)
     #define __IS_DMA_ENABLED(__HANDLE__)      ((__HANDLE__)->Instance->CR & DMA_SxCR_EN)
     #define __IS_DMA_CONFIGURED(__HANDLE__)   ((__HANDLE__)->Instance->PAR != 0)
+  #elif defined(STM32H7xx)
+    #define __IS_DMA_ENABLED(__HANDLE__)      (((DMA_Stream_TypeDef *)((__HANDLE__)->Instance))->CR & DMA_SxCR_EN)
+    #define __IS_DMA_CONFIGURED(__HANDLE__)   (((DMA_Stream_TypeDef *)((__HANDLE__)->Instance))->PAR != 0)
   #endif
 
   if (!__IS_DMA_CONFIGURED(&DMAtx)) return false;
@@ -193,8 +234,13 @@ bool TFT_SPI::isBusy() {
   else {
     // Check if DMA transfer completed flag is set
     if (__HAL_DMA_GET_FLAG(&DMAtx, __HAL_DMA_GET_TC_FLAG_INDEX(&DMAtx)) == 0) return true;
-    // Check if SPI transmit butter is empty and SPI is idle
-    if ((!__HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_TXE)) || (__HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_BSY))) return true;
+    #ifdef STM32H7xx
+      // Check if SPI data transfer is completed
+      if (!__HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_EOT)) return true;
+    #else
+      // Check if SPI is idle
+      if (__HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_BSY)) return true;
+    #endif
   }
 
   abort();
@@ -205,9 +251,15 @@ void TFT_SPI::abort() {
   HAL_DMA_Abort(&DMAtx);  // Abort DMA transfer if any
   HAL_DMA_DeInit(&DMAtx);
 
-  CLEAR_BIT(SPIx.Instance->CR2, SPI_CR2_TXDMAEN);
+  #ifdef STM32H7xx
+    CLEAR_BIT(SPIx.Instance->CFG1, SPI_CFG1_TXDMAEN);
+    __HAL_SPI_CLEAR_EOTFLAG(&SPIx);
+    __HAL_SPI_CLEAR_TXTFFLAG(&SPIx);
+  #else
+    CLEAR_BIT(SPIx.Instance->CR2, SPI_CR2_TXDMAEN);
+  #endif
 
-  dataTransferEnd();      // Stop SPI and deselect CS
+  dataTransferEnd();  // Stop SPI and deselect CS
 }
 
 void TFT_SPI::transmit(uint16_t data) {
@@ -215,12 +267,24 @@ void TFT_SPI::transmit(uint16_t data) {
     SPI_1LINE_TX(&SPIx);
   #endif
 
-  __HAL_SPI_ENABLE(&SPIx);
+  #ifdef STM32H7xx
+    MODIFY_REG(SPIx.Instance->CR2, SPI_CR2_TSIZE, 1);
+    __HAL_SPI_ENABLE(&SPIx);
+    SET_BIT(SPIx.Instance->CR1, SPI_CR1_CSTART);
+
+    SPIx.Instance->TXDR = data;
 
-  SPIx.Instance->DR = data;
+    while (!__HAL_SPI_GET_FLAG(&SPIx, SPI_SR_EOT)) {}
 
-  while (!__HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_TXE)) {}
-  while ( __HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_BSY)) {}
+    __HAL_SPI_CLEAR_EOTFLAG(&SPIx);
+    __HAL_SPI_CLEAR_TXTFFLAG(&SPIx);
+  #else
+    __HAL_SPI_ENABLE(&SPIx);
+    SPIx.Instance->DR = data;
+    while (__HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_BSY)) {}
+  #endif
+
+  __HAL_SPI_DISABLE(&SPIx);
 
   #if TFT_MISO_PIN != TFT_MOSI_PIN
     __HAL_SPI_CLEAR_OVRFLAG(&SPIx);   // Clear overrun flag in 2 Lines communication mode because received data is not read
@@ -237,35 +301,38 @@ void TFT_SPI::transmitDMA(uint32_t memoryIncrease, uint16_t *data, uint16_t coun
 
   dataTransferBegin();
 
-  HAL_DMA_Start(&DMAtx, (uint32_t)data, (uint32_t)&(SPIx.Instance->DR), count);
-  __HAL_SPI_ENABLE(&SPIx);
+  #ifdef STM32H7xx
+    HAL_DMA_Start(&DMAtx, (uint32_t)data, (uint32_t)&(SPIx.Instance->TXDR), count);
 
-  SET_BIT(SPIx.Instance->CR2, SPI_CR2_TXDMAEN);   // Enable Tx DMA Request
+    CLEAR_BIT(SPIx.Instance->CFG1, SPI_CFG1_TXDMAEN);
+    MODIFY_REG(SPIx.Instance->CR2, SPI_CR2_TSIZE, count);
+    SET_BIT(SPIx.Instance->CFG1, SPI_CFG1_TXDMAEN);   // Enable Tx DMA Request
+    __HAL_SPI_ENABLE(&SPIx);
+    SET_BIT(SPIx.Instance->CR1, SPI_CR1_CSTART);
+  #else
+    HAL_DMA_Start(&DMAtx, (uint32_t)data, (uint32_t)&(SPIx.Instance->DR), count);
+
+    __HAL_SPI_ENABLE(&SPIx);
+    SET_BIT(SPIx.Instance->CR2, SPI_CR2_TXDMAEN);   // Enable Tx DMA Request
+  #endif
 
   TERN_(TFT_SHARED_IO, while (isBusy()));
 }
 
 void TFT_SPI::transmit(uint32_t memoryIncrease, uint16_t *data, uint16_t count) {
-  DMAtx.Init.MemInc = memoryIncrease;
-  HAL_DMA_Init(&DMAtx);
-
-  if (TFT_MISO_PIN == TFT_MOSI_PIN)
-    SPI_1LINE_TX(&SPIx);
-
-  dataTransferBegin();
-
-  HAL_DMA_Start(&DMAtx, (uint32_t)data, (uint32_t)&(SPIx.Instance->DR), count);
-  __HAL_SPI_ENABLE(&SPIx);
-
-  SET_BIT(SPIx.Instance->CR2, SPI_CR2_TXDMAEN);   // Enable Tx DMA Request
+  transmitDMA(memoryIncrease, data, count);
 
   HAL_DMA_PollForTransfer(&DMAtx, HAL_DMA_FULL_TRANSFER, HAL_MAX_DELAY);
-  while ( __HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_BSY)) {}
+  #ifdef STM32H7xx
+    while (!__HAL_SPI_GET_FLAG(&SPIx, SPI_SR_EOT)) {}
+  #else
+    while (__HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_BSY)) {}
+  #endif
   abort();
 }
 
 #if ENABLED(USE_SPI_DMA_TC)
-  void TFT_SPI::TransmitDMA_IT(uint32_t memoryIncrease, uint16_t *data, uint16_t count) {
+  void TFT_SPI::transmitDMA_IT(uint32_t memoryIncrease, uint16_t *data, uint16_t count) {
 
     DMAtx.Init.MemInc = memoryIncrease;
     HAL_DMA_Init(&DMAtx);

commit 9bf95418a7fbc0da0a6dc8bfb5024b624b94a51a
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jun 24 02:57:58 2023 -0500

    🐛 Fix TFT_LTDC::writeReg
    
    Followup to #25939

diff --git a/Marlin/src/HAL/STM32/tft/tft_spi.cpp b/Marlin/src/HAL/STM32/tft/tft_spi.cpp
index eebf366b8c..eb81a27bf1 100644
--- a/Marlin/src/HAL/STM32/tft/tft_spi.cpp
+++ b/Marlin/src/HAL/STM32/tft/tft_spi.cpp
@@ -145,7 +145,7 @@ uint32_t TFT_SPI::getID() {
   return id;
 }
 
-uint32_t TFT_SPI::readID(uint16_t reg) {
+uint32_t TFT_SPI::readID(const uint16_t inReg) {
   uint32_t data = 0;
   #if PIN_EXISTS(TFT_MISO)
     uint32_t BaudRatePrescaler = SPIx.Init.BaudRatePrescaler;
@@ -153,7 +153,7 @@ uint32_t TFT_SPI::readID(uint16_t reg) {
 
     SPIx.Init.BaudRatePrescaler = SPIx.Instance == SPI1 ? SPI_BAUDRATEPRESCALER_8 : SPI_BAUDRATEPRESCALER_4;
     dataTransferBegin(DATASIZE_8BIT);
-    writeReg(reg);
+    writeReg(inReg);
 
     if (SPIx.Init.Direction == SPI_DIRECTION_1LINE) SPI_1LINE_RX(&SPIx);
     __HAL_SPI_ENABLE(&SPIx);

commit c3694f1c038fa20ad749118b0a1c7aa88e3dd5f2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jun 14 17:24:50 2023 -0500

    🎨 Lowercase methods, functions, data members (#25939)
    
    For: TFT, DGUS, MarlinUI, Anycubic, JyersUI, CrealityUI

diff --git a/Marlin/src/HAL/STM32/tft/tft_spi.cpp b/Marlin/src/HAL/STM32/tft/tft_spi.cpp
index dbb93c786b..eebf366b8c 100644
--- a/Marlin/src/HAL/STM32/tft/tft_spi.cpp
+++ b/Marlin/src/HAL/STM32/tft/tft_spi.cpp
@@ -34,7 +34,7 @@
 SPI_HandleTypeDef TFT_SPI::SPIx;
 DMA_HandleTypeDef TFT_SPI::DMAtx;
 
-void TFT_SPI::Init() {
+void TFT_SPI::init() {
   SPI_TypeDef *spiInstance;
 
   OUT_WRITE(TFT_A0_PIN, HIGH);
@@ -122,8 +122,8 @@ void TFT_SPI::Init() {
   #endif
 }
 
-void TFT_SPI::DataTransferBegin(uint16_t DataSize) {
-  SPIx.Init.DataSize = DataSize == DATASIZE_8BIT ?  SPI_DATASIZE_8BIT : SPI_DATASIZE_16BIT;
+void TFT_SPI::dataTransferBegin(uint16_t dataSize) {
+  SPIx.Init.DataSize = dataSize == DATASIZE_8BIT ?  SPI_DATASIZE_8BIT : SPI_DATASIZE_16BIT;
   HAL_SPI_Init(&SPIx);
   WRITE(TFT_CS_PIN, LOW);
 }
@@ -132,11 +132,11 @@ void TFT_SPI::DataTransferBegin(uint16_t DataSize) {
   #include "../../../lcd/tft_io/tft_ids.h"
 #endif
 
-uint32_t TFT_SPI::GetID() {
+uint32_t TFT_SPI::getID() {
   uint32_t id;
-  id = ReadID(LCD_READ_ID);
+  id = readID(LCD_READ_ID);
   if ((id & 0xFFFF) == 0 || (id & 0xFFFF) == 0xFFFF) {
-    id = ReadID(LCD_READ_ID4);
+    id = readID(LCD_READ_ID4);
     #ifdef TFT_DEFAULT_DRIVER
       if ((id & 0xFFFF) == 0 || (id & 0xFFFF) == 0xFFFF)
         id = TFT_DEFAULT_DRIVER;
@@ -145,15 +145,15 @@ uint32_t TFT_SPI::GetID() {
   return id;
 }
 
-uint32_t TFT_SPI::ReadID(uint16_t Reg) {
-  uint32_t Data = 0;
+uint32_t TFT_SPI::readID(uint16_t reg) {
+  uint32_t data = 0;
   #if PIN_EXISTS(TFT_MISO)
     uint32_t BaudRatePrescaler = SPIx.Init.BaudRatePrescaler;
     uint32_t i;
 
     SPIx.Init.BaudRatePrescaler = SPIx.Instance == SPI1 ? SPI_BAUDRATEPRESCALER_8 : SPI_BAUDRATEPRESCALER_4;
-    DataTransferBegin(DATASIZE_8BIT);
-    WriteReg(Reg);
+    dataTransferBegin(DATASIZE_8BIT);
+    writeReg(reg);
 
     if (SPIx.Init.Direction == SPI_DIRECTION_1LINE) SPI_1LINE_RX(&SPIx);
     __HAL_SPI_ENABLE(&SPIx);
@@ -164,15 +164,15 @@ uint32_t TFT_SPI::ReadID(uint16_t Reg) {
         SPIx.Instance->DR = 0;
       #endif
       while (!__HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_RXNE)) {}
-      Data = (Data << 8) | SPIx.Instance->DR;
+      data = (data << 8) | SPIx.Instance->DR;
     }
 
-    DataTransferEnd();
+    dataTransferEnd();
 
     SPIx.Init.BaudRatePrescaler   = BaudRatePrescaler;
   #endif
 
-  return Data >> 7;
+  return data >> 7;
 }
 
 bool TFT_SPI::isBusy() {
@@ -197,27 +197,27 @@ bool TFT_SPI::isBusy() {
     if ((!__HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_TXE)) || (__HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_BSY))) return true;
   }
 
-  Abort();
+  abort();
   return false;
 }
 
-void TFT_SPI::Abort() {
+void TFT_SPI::abort() {
   HAL_DMA_Abort(&DMAtx);  // Abort DMA transfer if any
   HAL_DMA_DeInit(&DMAtx);
 
   CLEAR_BIT(SPIx.Instance->CR2, SPI_CR2_TXDMAEN);
 
-  DataTransferEnd();      // Stop SPI and deselect CS
+  dataTransferEnd();      // Stop SPI and deselect CS
 }
 
-void TFT_SPI::Transmit(uint16_t Data) {
+void TFT_SPI::transmit(uint16_t data) {
   #if TFT_MISO_PIN == TFT_MOSI_PIN
     SPI_1LINE_TX(&SPIx);
   #endif
 
   __HAL_SPI_ENABLE(&SPIx);
 
-  SPIx.Instance->DR = Data;
+  SPIx.Instance->DR = data;
 
   while (!__HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_TXE)) {}
   while ( __HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_BSY)) {}
@@ -227,17 +227,17 @@ void TFT_SPI::Transmit(uint16_t Data) {
   #endif
 }
 
-void TFT_SPI::TransmitDMA(uint32_t MemoryIncrease, uint16_t *Data, uint16_t Count) {
-  DMAtx.Init.MemInc = MemoryIncrease;
+void TFT_SPI::transmitDMA(uint32_t memoryIncrease, uint16_t *data, uint16_t count) {
+  DMAtx.Init.MemInc = memoryIncrease;
   HAL_DMA_Init(&DMAtx);
 
   #if TFT_MISO_PIN == TFT_MOSI_PIN
     SPI_1LINE_TX(&SPIx);
   #endif
 
-  DataTransferBegin();
+  dataTransferBegin();
 
-  HAL_DMA_Start(&DMAtx, (uint32_t)Data, (uint32_t)&(SPIx.Instance->DR), Count);
+  HAL_DMA_Start(&DMAtx, (uint32_t)data, (uint32_t)&(SPIx.Instance->DR), count);
   __HAL_SPI_ENABLE(&SPIx);
 
   SET_BIT(SPIx.Instance->CR2, SPI_CR2_TXDMAEN);   // Enable Tx DMA Request
@@ -245,39 +245,39 @@ void TFT_SPI::TransmitDMA(uint32_t MemoryIncrease, uint16_t *Data, uint16_t Coun
   TERN_(TFT_SHARED_IO, while (isBusy()));
 }
 
-void TFT_SPI::Transmit(uint32_t MemoryIncrease, uint16_t *Data, uint16_t Count) {
-  DMAtx.Init.MemInc = MemoryIncrease;
+void TFT_SPI::transmit(uint32_t memoryIncrease, uint16_t *data, uint16_t count) {
+  DMAtx.Init.MemInc = memoryIncrease;
   HAL_DMA_Init(&DMAtx);
 
   if (TFT_MISO_PIN == TFT_MOSI_PIN)
     SPI_1LINE_TX(&SPIx);
 
-  DataTransferBegin();
+  dataTransferBegin();
 
-  HAL_DMA_Start(&DMAtx, (uint32_t)Data, (uint32_t)&(SPIx.Instance->DR), Count);
+  HAL_DMA_Start(&DMAtx, (uint32_t)data, (uint32_t)&(SPIx.Instance->DR), count);
   __HAL_SPI_ENABLE(&SPIx);
 
   SET_BIT(SPIx.Instance->CR2, SPI_CR2_TXDMAEN);   // Enable Tx DMA Request
 
   HAL_DMA_PollForTransfer(&DMAtx, HAL_DMA_FULL_TRANSFER, HAL_MAX_DELAY);
   while ( __HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_BSY)) {}
-  Abort();
+  abort();
 }
 
 #if ENABLED(USE_SPI_DMA_TC)
-  void TFT_SPI::TransmitDMA_IT(uint32_t MemoryIncrease, uint16_t *Data, uint16_t Count) {
+  void TFT_SPI::TransmitDMA_IT(uint32_t memoryIncrease, uint16_t *data, uint16_t count) {
 
-    DMAtx.Init.MemInc = MemoryIncrease;
+    DMAtx.Init.MemInc = memoryIncrease;
     HAL_DMA_Init(&DMAtx);
 
     if (TFT_MISO_PIN == TFT_MOSI_PIN)
       SPI_1LINE_TX(&SPIx);
 
-    DataTransferBegin();
+    dataTransferBegin();
 
     HAL_NVIC_SetPriority(DMA2_Stream3_IRQn, 5, 0);
     HAL_NVIC_EnableIRQ(DMA2_Stream3_IRQn);
-    HAL_DMA_Start_IT(&DMAtx, (uint32_t)Data, (uint32_t)&(SPIx.Instance->DR), Count);
+    HAL_DMA_Start_IT(&DMAtx, (uint32_t)data, (uint32_t)&(SPIx.Instance->DR), count);
     __HAL_SPI_ENABLE(&SPIx);
 
     SET_BIT(SPIx.Instance->CR2, SPI_CR2_TXDMAEN);   // Enable Tx DMA Request

commit 7642bfbf8b997308e691034aa294a061c5fc5426
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Wed May 3 14:19:32 2023 -0700

    🐛 Fix TFT Touch Calibration overrides (#25579)
    
    …and other misc. display-related updates
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/HAL/STM32/tft/tft_spi.cpp b/Marlin/src/HAL/STM32/tft/tft_spi.cpp
index 6ee4dc3364..dbb93c786b 100644
--- a/Marlin/src/HAL/STM32/tft/tft_spi.cpp
+++ b/Marlin/src/HAL/STM32/tft/tft_spi.cpp
@@ -245,7 +245,6 @@ void TFT_SPI::TransmitDMA(uint32_t MemoryIncrease, uint16_t *Data, uint16_t Coun
   TERN_(TFT_SHARED_IO, while (isBusy()));
 }
 
-
 void TFT_SPI::Transmit(uint32_t MemoryIncrease, uint16_t *Data, uint16_t Count) {
   DMAtx.Init.MemInc = MemoryIncrease;
   HAL_DMA_Init(&DMAtx);

commit e0132f7a1ec256ffe07d44c181fe1f2a799fd109
Author: Alexander Gavrilenko <jmz52@users.noreply.github.com>
Date:   Mon Mar 27 21:17:02 2023 +0300

    ⚡️ Improve TFT DMA for STM32 (#25359)

diff --git a/Marlin/src/HAL/STM32/tft/tft_spi.cpp b/Marlin/src/HAL/STM32/tft/tft_spi.cpp
index 5e79f156d2..6ee4dc3364 100644
--- a/Marlin/src/HAL/STM32/tft/tft_spi.cpp
+++ b/Marlin/src/HAL/STM32/tft/tft_spi.cpp
@@ -242,7 +242,7 @@ void TFT_SPI::TransmitDMA(uint32_t MemoryIncrease, uint16_t *Data, uint16_t Coun
 
   SET_BIT(SPIx.Instance->CR2, SPI_CR2_TXDMAEN);   // Enable Tx DMA Request
 
-  TERN_(TFT_SHARED_SPI, while (isBusy()));
+  TERN_(TFT_SHARED_IO, while (isBusy()));
 }
 
 
@@ -261,6 +261,7 @@ void TFT_SPI::Transmit(uint32_t MemoryIncrease, uint16_t *Data, uint16_t Count)
   SET_BIT(SPIx.Instance->CR2, SPI_CR2_TXDMAEN);   // Enable Tx DMA Request
 
   HAL_DMA_PollForTransfer(&DMAtx, HAL_DMA_FULL_TRANSFER, HAL_MAX_DELAY);
+  while ( __HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_BSY)) {}
   Abort();
 }
 

commit aaae56a6501fd617cdc1216e0d1bfec39538da61
Author: Alexander Gavrilenko <jmz52@users.noreply.github.com>
Date:   Tue Dec 13 00:13:31 2022 +0300

    ✨ TFT_COLOR_UI async DMA SPI (#24980)

diff --git a/Marlin/src/HAL/STM32/tft/tft_spi.cpp b/Marlin/src/HAL/STM32/tft/tft_spi.cpp
index e455164c77..5e79f156d2 100644
--- a/Marlin/src/HAL/STM32/tft/tft_spi.cpp
+++ b/Marlin/src/HAL/STM32/tft/tft_spi.cpp
@@ -160,16 +160,13 @@ uint32_t TFT_SPI::ReadID(uint16_t Reg) {
 
     for (i = 0; i < 4; i++) {
       #if TFT_MISO_PIN != TFT_MOSI_PIN
-        //if (hspi->Init.Direction == SPI_DIRECTION_2LINES) {
-          while (!__HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_TXE)) {}
-          SPIx.Instance->DR = 0;
-        //}
+        while (!__HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_TXE)) {}
+        SPIx.Instance->DR = 0;
       #endif
       while (!__HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_RXNE)) {}
       Data = (Data << 8) | SPIx.Instance->DR;
     }
 
-    __HAL_SPI_DISABLE(&SPIx);
     DataTransferEnd();
 
     SPIx.Init.BaudRatePrescaler   = BaudRatePrescaler;
@@ -180,35 +177,43 @@ uint32_t TFT_SPI::ReadID(uint16_t Reg) {
 
 bool TFT_SPI::isBusy() {
   #ifdef STM32F1xx
-    volatile bool dmaEnabled = (DMAtx.Instance->CCR & DMA_CCR_EN) != RESET;
+    #define __IS_DMA_ENABLED(__HANDLE__)      ((__HANDLE__)->Instance->CCR & DMA_CCR_EN)
+    #define __IS_DMA_CONFIGURED(__HANDLE__)   ((__HANDLE__)->Instance->CPAR != 0)
   #elif defined(STM32F4xx)
-    volatile bool dmaEnabled = DMAtx.Instance->CR & DMA_SxCR_EN;
+    #define __IS_DMA_ENABLED(__HANDLE__)      ((__HANDLE__)->Instance->CR & DMA_SxCR_EN)
+    #define __IS_DMA_CONFIGURED(__HANDLE__)   ((__HANDLE__)->Instance->PAR != 0)
   #endif
-  if (dmaEnabled) {
-    if (__HAL_DMA_GET_FLAG(&DMAtx, __HAL_DMA_GET_TC_FLAG_INDEX(&DMAtx)) != 0 || __HAL_DMA_GET_FLAG(&DMAtx, __HAL_DMA_GET_TE_FLAG_INDEX(&DMAtx)) != 0)
-      Abort();
+
+  if (!__IS_DMA_CONFIGURED(&DMAtx)) return false;
+
+  if (__HAL_DMA_GET_FLAG(&DMAtx, __HAL_DMA_GET_TE_FLAG_INDEX(&DMAtx))) {
+    // You should not be here - DMA transfer error flag is set
+    // Abort DMA transfer and release SPI
   }
-  else
-    Abort();
-  return dmaEnabled;
+  else {
+    // Check if DMA transfer completed flag is set
+    if (__HAL_DMA_GET_FLAG(&DMAtx, __HAL_DMA_GET_TC_FLAG_INDEX(&DMAtx)) == 0) return true;
+    // Check if SPI transmit butter is empty and SPI is idle
+    if ((!__HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_TXE)) || (__HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_BSY))) return true;
+  }
+
+  Abort();
+  return false;
 }
 
 void TFT_SPI::Abort() {
-  // Wait for any running spi
-  while (!__HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_TXE)) {}
-  while ( __HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_BSY)) {}
-  // First, abort any running dma
-  HAL_DMA_Abort(&DMAtx);
-  // DeInit objects
+  HAL_DMA_Abort(&DMAtx);  // Abort DMA transfer if any
   HAL_DMA_DeInit(&DMAtx);
-  HAL_SPI_DeInit(&SPIx);
-  // Deselect CS
-  DataTransferEnd();
+
+  CLEAR_BIT(SPIx.Instance->CR2, SPI_CR2_TXDMAEN);
+
+  DataTransferEnd();      // Stop SPI and deselect CS
 }
 
 void TFT_SPI::Transmit(uint16_t Data) {
-  if (TFT_MISO_PIN == TFT_MOSI_PIN)
+  #if TFT_MISO_PIN == TFT_MOSI_PIN
     SPI_1LINE_TX(&SPIx);
+  #endif
 
   __HAL_SPI_ENABLE(&SPIx);
 
@@ -217,14 +222,31 @@ void TFT_SPI::Transmit(uint16_t Data) {
   while (!__HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_TXE)) {}
   while ( __HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_BSY)) {}
 
-  if (TFT_MISO_PIN != TFT_MOSI_PIN)
-    __HAL_SPI_CLEAR_OVRFLAG(&SPIx);   // Clear overrun flag in 2 Lines communication mode because received is not read
+  #if TFT_MISO_PIN != TFT_MOSI_PIN
+    __HAL_SPI_CLEAR_OVRFLAG(&SPIx);   // Clear overrun flag in 2 Lines communication mode because received data is not read
+  #endif
 }
 
 void TFT_SPI::TransmitDMA(uint32_t MemoryIncrease, uint16_t *Data, uint16_t Count) {
-  // Wait last dma finish, to start another
-  while (isBusy()) { /* nada */ }
+  DMAtx.Init.MemInc = MemoryIncrease;
+  HAL_DMA_Init(&DMAtx);
 
+  #if TFT_MISO_PIN == TFT_MOSI_PIN
+    SPI_1LINE_TX(&SPIx);
+  #endif
+
+  DataTransferBegin();
+
+  HAL_DMA_Start(&DMAtx, (uint32_t)Data, (uint32_t)&(SPIx.Instance->DR), Count);
+  __HAL_SPI_ENABLE(&SPIx);
+
+  SET_BIT(SPIx.Instance->CR2, SPI_CR2_TXDMAEN);   // Enable Tx DMA Request
+
+  TERN_(TFT_SHARED_SPI, while (isBusy()));
+}
+
+
+void TFT_SPI::Transmit(uint32_t MemoryIncrease, uint16_t *Data, uint16_t Count) {
   DMAtx.Init.MemInc = MemoryIncrease;
   HAL_DMA_Init(&DMAtx);
 
@@ -243,7 +265,6 @@ void TFT_SPI::TransmitDMA(uint32_t MemoryIncrease, uint16_t *Data, uint16_t Coun
 }
 
 #if ENABLED(USE_SPI_DMA_TC)
-
   void TFT_SPI::TransmitDMA_IT(uint32_t MemoryIncrease, uint16_t *Data, uint16_t Count) {
 
     DMAtx.Init.MemInc = MemoryIncrease;
@@ -262,8 +283,7 @@ void TFT_SPI::TransmitDMA(uint32_t MemoryIncrease, uint16_t *Data, uint16_t Coun
     SET_BIT(SPIx.Instance->CR2, SPI_CR2_TXDMAEN);   // Enable Tx DMA Request
   }
 
-  extern "C" void DMA2_Stream3_IRQHandler(void) { HAL_DMA_IRQHandler(&TFT_SPI::DMAtx); }
-
+  extern "C" void DMA2_Stream3_IRQHandler(void) { TFT_SPI::DMA_IRQHandler(); }
 #endif
 
 #endif // HAS_SPI_TFT

commit 34f3e5bd88246516a1779c194c2996bcf845a499
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Aug 20 06:41:00 2022 -0500

    🎨 Some automated cleanup

diff --git a/Marlin/src/HAL/STM32/tft/tft_spi.cpp b/Marlin/src/HAL/STM32/tft/tft_spi.cpp
index 2e18c8a64c..e455164c77 100644
--- a/Marlin/src/HAL/STM32/tft/tft_spi.cpp
+++ b/Marlin/src/HAL/STM32/tft/tft_spi.cpp
@@ -179,7 +179,7 @@ uint32_t TFT_SPI::ReadID(uint16_t Reg) {
 }
 
 bool TFT_SPI::isBusy() {
-  #if defined(STM32F1xx)
+  #ifdef STM32F1xx
     volatile bool dmaEnabled = (DMAtx.Instance->CCR & DMA_CCR_EN) != RESET;
   #elif defined(STM32F4xx)
     volatile bool dmaEnabled = DMAtx.Instance->CR & DMA_SxCR_EN;

commit c79174e862f30d2a1e808c2cfc40bd8a8e819166
Author: Sola <42537573+solawc@users.noreply.github.com>
Date:   Sun Jan 16 13:07:37 2022 +0800

    ⚡️ SPI+DMA+interrupt method (STM32 / MKS UI) (#23464)

diff --git a/Marlin/src/HAL/STM32/tft/tft_spi.cpp b/Marlin/src/HAL/STM32/tft/tft_spi.cpp
index 4ad35cee8b..2e18c8a64c 100644
--- a/Marlin/src/HAL/STM32/tft/tft_spi.cpp
+++ b/Marlin/src/HAL/STM32/tft/tft_spi.cpp
@@ -242,5 +242,29 @@ void TFT_SPI::TransmitDMA(uint32_t MemoryIncrease, uint16_t *Data, uint16_t Coun
   Abort();
 }
 
+#if ENABLED(USE_SPI_DMA_TC)
+
+  void TFT_SPI::TransmitDMA_IT(uint32_t MemoryIncrease, uint16_t *Data, uint16_t Count) {
+
+    DMAtx.Init.MemInc = MemoryIncrease;
+    HAL_DMA_Init(&DMAtx);
+
+    if (TFT_MISO_PIN == TFT_MOSI_PIN)
+      SPI_1LINE_TX(&SPIx);
+
+    DataTransferBegin();
+
+    HAL_NVIC_SetPriority(DMA2_Stream3_IRQn, 5, 0);
+    HAL_NVIC_EnableIRQ(DMA2_Stream3_IRQn);
+    HAL_DMA_Start_IT(&DMAtx, (uint32_t)Data, (uint32_t)&(SPIx.Instance->DR), Count);
+    __HAL_SPI_ENABLE(&SPIx);
+
+    SET_BIT(SPIx.Instance->CR2, SPI_CR2_TXDMAEN);   // Enable Tx DMA Request
+  }
+
+  extern "C" void DMA2_Stream3_IRQHandler(void) { HAL_DMA_IRQHandler(&TFT_SPI::DMAtx); }
+
+#endif
+
 #endif // HAS_SPI_TFT
 #endif // HAL_STM32

commit 5387ceba74862788d27b62f8624a2c697fe233ee
Author: Mike La Spina <mike.laspina@shaw.ca>
Date:   Tue Nov 23 14:05:50 2021 -0600

    🐛 Fix STM32 set_pwm_duty (#23125)

diff --git a/Marlin/src/HAL/STM32/tft/tft_spi.cpp b/Marlin/src/HAL/STM32/tft/tft_spi.cpp
index 790513e7ed..4ad35cee8b 100644
--- a/Marlin/src/HAL/STM32/tft/tft_spi.cpp
+++ b/Marlin/src/HAL/STM32/tft/tft_spi.cpp
@@ -161,11 +161,11 @@ uint32_t TFT_SPI::ReadID(uint16_t Reg) {
     for (i = 0; i < 4; i++) {
       #if TFT_MISO_PIN != TFT_MOSI_PIN
         //if (hspi->Init.Direction == SPI_DIRECTION_2LINES) {
-          while ((SPIx.Instance->SR & SPI_FLAG_TXE) != SPI_FLAG_TXE) {}
+          while (!__HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_TXE)) {}
           SPIx.Instance->DR = 0;
         //}
       #endif
-      while ((SPIx.Instance->SR & SPI_FLAG_RXNE) != SPI_FLAG_RXNE) {}
+      while (!__HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_RXNE)) {}
       Data = (Data << 8) | SPIx.Instance->DR;
     }
 
@@ -195,8 +195,8 @@ bool TFT_SPI::isBusy() {
 
 void TFT_SPI::Abort() {
   // Wait for any running spi
-  while ((SPIx.Instance->SR & SPI_FLAG_TXE) != SPI_FLAG_TXE) {}
-  while ((SPIx.Instance->SR & SPI_FLAG_BSY) == SPI_FLAG_BSY) {}
+  while (!__HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_TXE)) {}
+  while ( __HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_BSY)) {}
   // First, abort any running dma
   HAL_DMA_Abort(&DMAtx);
   // DeInit objects
@@ -214,8 +214,8 @@ void TFT_SPI::Transmit(uint16_t Data) {
 
   SPIx.Instance->DR = Data;
 
-  while ((SPIx.Instance->SR & SPI_FLAG_TXE) != SPI_FLAG_TXE) {}
-  while ((SPIx.Instance->SR & SPI_FLAG_BSY) == SPI_FLAG_BSY) {}
+  while (!__HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_TXE)) {}
+  while ( __HAL_SPI_GET_FLAG(&SPIx, SPI_FLAG_BSY)) {}
 
   if (TFT_MISO_PIN != TFT_MOSI_PIN)
     __HAL_SPI_CLEAR_OVRFLAG(&SPIx);   // Clear overrun flag in 2 Lines communication mode because received is not read

commit 323b38ee88dbf2a4691a20439dbb95a824822199
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Sep 16 04:36:26 2021 -0500

    💡 Adjust headers, formatting

diff --git a/Marlin/src/HAL/STM32/tft/tft_spi.cpp b/Marlin/src/HAL/STM32/tft/tft_spi.cpp
index 29a309f40e..790513e7ed 100644
--- a/Marlin/src/HAL/STM32/tft/tft_spi.cpp
+++ b/Marlin/src/HAL/STM32/tft/tft_spi.cpp
@@ -19,6 +19,7 @@
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
+
 #include "../../platforms.h"
 
 #ifdef HAL_STM32

commit 76c10b3e02aa5a699ee68a36663337de60fea4e8
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Aug 8 21:31:10 2021 -0500

    🏗️ Define HAL_STM32 for HAL/STM32 (#22537)

diff --git a/Marlin/src/HAL/STM32/tft/tft_spi.cpp b/Marlin/src/HAL/STM32/tft/tft_spi.cpp
index 4e3f894a52..29a309f40e 100644
--- a/Marlin/src/HAL/STM32/tft/tft_spi.cpp
+++ b/Marlin/src/HAL/STM32/tft/tft_spi.cpp
@@ -19,7 +19,9 @@
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
-#if defined(ARDUINO_ARCH_STM32) && !defined(STM32GENERIC) && !defined(MAPLE_STM32F1)
+#include "../../platforms.h"
+
+#ifdef HAL_STM32
 
 #include "../../../inc/MarlinConfig.h"
 
@@ -240,4 +242,4 @@ void TFT_SPI::TransmitDMA(uint32_t MemoryIncrease, uint16_t *Data, uint16_t Coun
 }
 
 #endif // HAS_SPI_TFT
-#endif // ARDUINO_ARCH_STM32 && !STM32GENERIC && !MAPLE_STM32F1
+#endif // HAL_STM32

commit 4febb2352179f3de58db2161572de4050197bd5d
Author: MKS-Sean <56996910+MKS-Sean@users.noreply.github.com>
Date:   Tue Jul 13 08:17:28 2021 +0800

    ✨ MKS Robin Nano v3 + TFT_LVGL_UI + WiFi module (#22109)

diff --git a/Marlin/src/HAL/STM32/tft/tft_spi.cpp b/Marlin/src/HAL/STM32/tft/tft_spi.cpp
index 6bfce81f1a..4e3f894a52 100644
--- a/Marlin/src/HAL/STM32/tft/tft_spi.cpp
+++ b/Marlin/src/HAL/STM32/tft/tft_spi.cpp
@@ -19,7 +19,7 @@
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
-#if defined(ARDUINO_ARCH_STM32) && !defined(STM32GENERIC)
+#if defined(ARDUINO_ARCH_STM32) && !defined(STM32GENERIC) && !defined(MAPLE_STM32F1)
 
 #include "../../../inc/MarlinConfig.h"
 
@@ -240,4 +240,4 @@ void TFT_SPI::TransmitDMA(uint32_t MemoryIncrease, uint16_t *Data, uint16_t Coun
 }
 
 #endif // HAS_SPI_TFT
-#endif // ARDUINO_ARCH_STM32 && !STM32GENERIC
+#endif // ARDUINO_ARCH_STM32 && !STM32GENERIC && !MAPLE_STM32F1

commit 3c522fff31f7e1d4127ab09bb27345b098186cd5
Author: ellensp <ellensp@hotmail.com>
Date:   Sun Jun 6 21:21:14 2021 +1200

    🩹 Fallback ID for MKS TS35 V2.0 (#22031)

diff --git a/Marlin/src/HAL/STM32/tft/tft_spi.cpp b/Marlin/src/HAL/STM32/tft/tft_spi.cpp
index 32af67d158..6bfce81f1a 100644
--- a/Marlin/src/HAL/STM32/tft/tft_spi.cpp
+++ b/Marlin/src/HAL/STM32/tft/tft_spi.cpp
@@ -125,12 +125,20 @@ void TFT_SPI::DataTransferBegin(uint16_t DataSize) {
   WRITE(TFT_CS_PIN, LOW);
 }
 
+#ifdef TFT_DEFAULT_DRIVER
+  #include "../../../lcd/tft_io/tft_ids.h"
+#endif
+
 uint32_t TFT_SPI::GetID() {
   uint32_t id;
   id = ReadID(LCD_READ_ID);
-
-  if ((id & 0xFFFF) == 0 || (id & 0xFFFF) == 0xFFFF)
+  if ((id & 0xFFFF) == 0 || (id & 0xFFFF) == 0xFFFF) {
     id = ReadID(LCD_READ_ID4);
+    #ifdef TFT_DEFAULT_DRIVER
+      if ((id & 0xFFFF) == 0 || (id & 0xFFFF) == 0xFFFF)
+        id = TFT_DEFAULT_DRIVER;
+    #endif
+   }
   return id;
 }
 

commit fd270ddc6c5b4d78437d590ae8066326850555d7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 3 00:11:50 2021 -0600

    misc. cleanup

diff --git a/Marlin/src/HAL/STM32/tft/tft_spi.cpp b/Marlin/src/HAL/STM32/tft/tft_spi.cpp
index 3cb797d5f2..32af67d158 100644
--- a/Marlin/src/HAL/STM32/tft/tft_spi.cpp
+++ b/Marlin/src/HAL/STM32/tft/tft_spi.cpp
@@ -207,12 +207,12 @@ void TFT_SPI::Transmit(uint16_t Data) {
   while ((SPIx.Instance->SR & SPI_FLAG_BSY) == SPI_FLAG_BSY) {}
 
   if (TFT_MISO_PIN != TFT_MOSI_PIN)
-    __HAL_SPI_CLEAR_OVRFLAG(&SPIx);   /* Clear overrun flag in 2 Lines communication mode because received is not read */
+    __HAL_SPI_CLEAR_OVRFLAG(&SPIx);   // Clear overrun flag in 2 Lines communication mode because received is not read
 }
 
 void TFT_SPI::TransmitDMA(uint32_t MemoryIncrease, uint16_t *Data, uint16_t Count) {
   // Wait last dma finish, to start another
-  while(isBusy()) { }
+  while (isBusy()) { /* nada */ }
 
   DMAtx.Init.MemInc = MemoryIncrease;
   HAL_DMA_Init(&DMAtx);
@@ -225,7 +225,7 @@ void TFT_SPI::TransmitDMA(uint32_t MemoryIncrease, uint16_t *Data, uint16_t Coun
   HAL_DMA_Start(&DMAtx, (uint32_t)Data, (uint32_t)&(SPIx.Instance->DR), Count);
   __HAL_SPI_ENABLE(&SPIx);
 
-  SET_BIT(SPIx.Instance->CR2, SPI_CR2_TXDMAEN);   /* Enable Tx DMA Request */
+  SET_BIT(SPIx.Instance->CR2, SPI_CR2_TXDMAEN);   // Enable Tx DMA Request
 
   HAL_DMA_PollForTransfer(&DMAtx, HAL_DMA_FULL_TRANSFER, HAL_MAX_DELAY);
   Abort();

commit 4d6b6bcffc5082de84614aea0bdd2b280f503430
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Wed Dec 23 23:01:21 2020 -0300

    LVGL and Classic UI for STM32 (#20552)

diff --git a/Marlin/src/HAL/STM32/tft/tft_spi.cpp b/Marlin/src/HAL/STM32/tft/tft_spi.cpp
index 1c61d09529..3cb797d5f2 100644
--- a/Marlin/src/HAL/STM32/tft/tft_spi.cpp
+++ b/Marlin/src/HAL/STM32/tft/tft_spi.cpp
@@ -88,7 +88,7 @@ void TFT_SPI::Init() {
       #elif defined(STM32F4xx)
         __HAL_RCC_DMA1_CLK_ENABLE();
         DMAtx.Instance = DMA1_Stream4;
-        DMAtx.Init.Channel = DMA_CHANNEL_4;
+        DMAtx.Init.Channel = DMA_CHANNEL_0;
       #endif
     }
   #endif
@@ -101,7 +101,7 @@ void TFT_SPI::Init() {
       #elif defined(STM32F4xx)
         __HAL_RCC_DMA1_CLK_ENABLE();
         DMAtx.Instance = DMA1_Stream5;
-        DMAtx.Init.Channel = DMA_CHANNEL_5;
+        DMAtx.Init.Channel = DMA_CHANNEL_0;
       #endif
     }
   #endif
@@ -183,6 +183,9 @@ bool TFT_SPI::isBusy() {
 }
 
 void TFT_SPI::Abort() {
+  // Wait for any running spi
+  while ((SPIx.Instance->SR & SPI_FLAG_TXE) != SPI_FLAG_TXE) {}
+  while ((SPIx.Instance->SR & SPI_FLAG_BSY) == SPI_FLAG_BSY) {}
   // First, abort any running dma
   HAL_DMA_Abort(&DMAtx);
   // DeInit objects
@@ -223,6 +226,9 @@ void TFT_SPI::TransmitDMA(uint32_t MemoryIncrease, uint16_t *Data, uint16_t Coun
   __HAL_SPI_ENABLE(&SPIx);
 
   SET_BIT(SPIx.Instance->CR2, SPI_CR2_TXDMAEN);   /* Enable Tx DMA Request */
+
+  HAL_DMA_PollForTransfer(&DMAtx, HAL_DMA_FULL_TRANSFER, HAL_MAX_DELAY);
+  Abort();
 }
 
 #endif // HAS_SPI_TFT

commit 885b0d2ec5f431d07aced632746eec5e7e371b6d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Dec 8 20:17:55 2020 -0600

    Style, spacing, typo cleanup for recent changes

diff --git a/Marlin/src/HAL/STM32/tft/tft_spi.cpp b/Marlin/src/HAL/STM32/tft/tft_spi.cpp
index d64ebcfe4b..1c61d09529 100644
--- a/Marlin/src/HAL/STM32/tft/tft_spi.cpp
+++ b/Marlin/src/HAL/STM32/tft/tft_spi.cpp
@@ -40,19 +40,15 @@ void TFT_SPI::Init() {
   if ((spiInstance = (SPI_TypeDef *)pinmap_peripheral(digitalPinToPinName(TFT_SCK_PIN),  PinMap_SPI_SCLK)) == NP) return;
   if (spiInstance != (SPI_TypeDef *)pinmap_peripheral(digitalPinToPinName(TFT_MOSI_PIN), PinMap_SPI_MOSI)) return;
 
-  #if PIN_EXISTS(TFT_MISO)
-    if (TFT_MISO_PIN != TFT_MOSI_PIN)
-      if (spiInstance != (SPI_TypeDef *)pinmap_peripheral(digitalPinToPinName(TFT_MISO_PIN), PinMap_SPI_MISO)) return;
+  #if PIN_EXISTS(TFT_MISO) && TFT_MISO_PIN != TFT_MOSI_PIN
+    if (spiInstance != (SPI_TypeDef *)pinmap_peripheral(digitalPinToPinName(TFT_MISO_PIN), PinMap_SPI_MISO)) return;
   #endif
 
   SPIx.Instance                = spiInstance;
   SPIx.State                   = HAL_SPI_STATE_RESET;
   SPIx.Init.NSS                = SPI_NSS_SOFT;
   SPIx.Init.Mode               = SPI_MODE_MASTER;
-  if (TFT_MISO_PIN == TFT_MOSI_PIN)
-    SPIx.Init.Direction         = SPI_DIRECTION_1LINE;
-  else
-    SPIx.Init.Direction         = SPI_DIRECTION_2LINES;
+  SPIx.Init.Direction          = (TFT_MISO_PIN == TFT_MOSI_PIN) ? SPI_DIRECTION_1LINE : SPI_DIRECTION_2LINES;
   SPIx.Init.BaudRatePrescaler  = SPI_BAUDRATEPRESCALER_2;
   SPIx.Init.CLKPhase           = SPI_PHASE_1EDGE;
   SPIx.Init.CLKPolarity        = SPI_POLARITY_LOW;
@@ -64,9 +60,8 @@ void TFT_SPI::Init() {
 
   pinmap_pinout(digitalPinToPinName(TFT_SCK_PIN), PinMap_SPI_SCLK);
   pinmap_pinout(digitalPinToPinName(TFT_MOSI_PIN), PinMap_SPI_MOSI);
-  #if PIN_EXISTS(TFT_MISO)
-    if (TFT_MISO_PIN != TFT_MOSI_PIN)
-      pinmap_pinout(digitalPinToPinName(TFT_MISO_PIN), PinMap_SPI_MISO);
+  #if PIN_EXISTS(TFT_MISO) && TFT_MISO_PIN != TFT_MOSI_PIN
+    pinmap_pinout(digitalPinToPinName(TFT_MISO_PIN), PinMap_SPI_MISO);
   #endif
   pin_PullConfig(get_GPIO_Port(STM_PORT(digitalPinToPinName(TFT_SCK_PIN))), STM_LL_GPIO_PIN(digitalPinToPinName(TFT_SCK_PIN)), GPIO_PULLDOWN);
 
@@ -119,7 +114,7 @@ void TFT_SPI::Init() {
   DMAtx.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
   DMAtx.Init.Mode = DMA_NORMAL;
   DMAtx.Init.Priority = DMA_PRIORITY_LOW;
-  #if defined(STM32F4xx)
+  #ifdef STM32F4xx
     DMAtx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
   #endif
 }
@@ -140,11 +135,10 @@ uint32_t TFT_SPI::GetID() {
 }
 
 uint32_t TFT_SPI::ReadID(uint16_t Reg) {
-  #if !PIN_EXISTS(TFT_MISO)
-    return 0;
-  #else
+  uint32_t Data = 0;
+  #if PIN_EXISTS(TFT_MISO)
     uint32_t BaudRatePrescaler = SPIx.Init.BaudRatePrescaler;
-    uint32_t i, Data = 0;
+    uint32_t i;
 
     SPIx.Init.BaudRatePrescaler = SPIx.Instance == SPI1 ? SPI_BAUDRATEPRESCALER_8 : SPI_BAUDRATEPRESCALER_4;
     DataTransferBegin(DATASIZE_8BIT);
@@ -154,12 +148,12 @@ uint32_t TFT_SPI::ReadID(uint16_t Reg) {
     __HAL_SPI_ENABLE(&SPIx);
 
     for (i = 0; i < 4; i++) {
-      if (TFT_MISO_PIN != TFT_MOSI_PIN) {
+      #if TFT_MISO_PIN != TFT_MOSI_PIN
         //if (hspi->Init.Direction == SPI_DIRECTION_2LINES) {
           while ((SPIx.Instance->SR & SPI_FLAG_TXE) != SPI_FLAG_TXE) {}
           SPIx.Instance->DR = 0;
         //}
-      }
+      #endif
       while ((SPIx.Instance->SR & SPI_FLAG_RXNE) != SPI_FLAG_RXNE) {}
       Data = (Data << 8) | SPIx.Instance->DR;
     }
@@ -168,9 +162,9 @@ uint32_t TFT_SPI::ReadID(uint16_t Reg) {
     DataTransferEnd();
 
     SPIx.Init.BaudRatePrescaler   = BaudRatePrescaler;
-
-    return Data >> 7;
   #endif
+
+  return Data >> 7;
 }
 
 bool TFT_SPI::isBusy() {
@@ -183,9 +177,8 @@ bool TFT_SPI::isBusy() {
     if (__HAL_DMA_GET_FLAG(&DMAtx, __HAL_DMA_GET_TC_FLAG_INDEX(&DMAtx)) != 0 || __HAL_DMA_GET_FLAG(&DMAtx, __HAL_DMA_GET_TE_FLAG_INDEX(&DMAtx)) != 0)
       Abort();
   }
-  else {
+  else
     Abort();
-  }
   return dmaEnabled;
 }
 

commit 9ead6a30f2876700413802d2d1445b9a33f05838
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Tue Dec 8 02:26:39 2020 -0300

    SPI TFT for STM32F4 boards (#20384)
    
    * fix pinsDebug for F1 boards
    
    * add MKS Robin PRO V2 board - development board
    
    * tft spi working with F4 boards
    
    * pins formating
    
    * sanity check for TFT on supported cores in STM32
    
    * Fix tabs/spaces in pins file
    
    Co-authored-by: Jason Smith <jason.inet@gmail.com>

diff --git a/Marlin/src/HAL/STM32/tft/tft_spi.cpp b/Marlin/src/HAL/STM32/tft/tft_spi.cpp
index aed15ad66d..d64ebcfe4b 100644
--- a/Marlin/src/HAL/STM32/tft/tft_spi.cpp
+++ b/Marlin/src/HAL/STM32/tft/tft_spi.cpp
@@ -34,35 +34,25 @@ DMA_HandleTypeDef TFT_SPI::DMAtx;
 void TFT_SPI::Init() {
   SPI_TypeDef *spiInstance;
 
-  #if PIN_EXISTS(TFT_RESET)
-    OUT_WRITE(TFT_RESET_PIN, HIGH);
-    HAL_Delay(100);
-  #endif
-
-  #if PIN_EXISTS(TFT_BACKLIGHT)
-    OUT_WRITE(TFT_BACKLIGHT_PIN, HIGH);
-  #endif
-
   OUT_WRITE(TFT_A0_PIN, HIGH);
   OUT_WRITE(TFT_CS_PIN, HIGH);
 
   if ((spiInstance = (SPI_TypeDef *)pinmap_peripheral(digitalPinToPinName(TFT_SCK_PIN),  PinMap_SPI_SCLK)) == NP) return;
   if (spiInstance != (SPI_TypeDef *)pinmap_peripheral(digitalPinToPinName(TFT_MOSI_PIN), PinMap_SPI_MOSI)) return;
 
-  #if PIN_EXISTS(TFT_MISO) && (TFT_MISO_PIN != TFT_MOSI_PIN)
-    if (spiInstance != (SPI_TypeDef *)pinmap_peripheral(digitalPinToPinName(TFT_MISO_PIN), PinMap_SPI_MISO)) return;
+  #if PIN_EXISTS(TFT_MISO)
+    if (TFT_MISO_PIN != TFT_MOSI_PIN)
+      if (spiInstance != (SPI_TypeDef *)pinmap_peripheral(digitalPinToPinName(TFT_MISO_PIN), PinMap_SPI_MISO)) return;
   #endif
 
   SPIx.Instance                = spiInstance;
   SPIx.State                   = HAL_SPI_STATE_RESET;
   SPIx.Init.NSS                = SPI_NSS_SOFT;
   SPIx.Init.Mode               = SPI_MODE_MASTER;
-  SPIx.Init.Direction          =
-  #if TFT_MISO_PIN == TFT_MOSI_PIN
-                                 SPI_DIRECTION_1LINE;
-  #else
-                                 SPI_DIRECTION_2LINES;
-  #endif
+  if (TFT_MISO_PIN == TFT_MOSI_PIN)
+    SPIx.Init.Direction         = SPI_DIRECTION_1LINE;
+  else
+    SPIx.Init.Direction         = SPI_DIRECTION_2LINES;
   SPIx.Init.BaudRatePrescaler  = SPI_BAUDRATEPRESCALER_2;
   SPIx.Init.CLKPhase           = SPI_PHASE_1EDGE;
   SPIx.Init.CLKPolarity        = SPI_POLARITY_LOW;
@@ -74,31 +64,50 @@ void TFT_SPI::Init() {
 
   pinmap_pinout(digitalPinToPinName(TFT_SCK_PIN), PinMap_SPI_SCLK);
   pinmap_pinout(digitalPinToPinName(TFT_MOSI_PIN), PinMap_SPI_MOSI);
-  #if PIN_EXISTS(TFT_MISO) && (TFT_MISO_PIN != TFT_MOSI_PIN)
-    pinmap_pinout(digitalPinToPinName(TFT_MISO_PIN), PinMap_SPI_MISO);
+  #if PIN_EXISTS(TFT_MISO)
+    if (TFT_MISO_PIN != TFT_MOSI_PIN)
+      pinmap_pinout(digitalPinToPinName(TFT_MISO_PIN), PinMap_SPI_MISO);
   #endif
   pin_PullConfig(get_GPIO_Port(STM_PORT(digitalPinToPinName(TFT_SCK_PIN))), STM_LL_GPIO_PIN(digitalPinToPinName(TFT_SCK_PIN)), GPIO_PULLDOWN);
 
   #ifdef SPI1_BASE
     if (SPIx.Instance == SPI1) {
       __HAL_RCC_SPI1_CLK_ENABLE();
-      __HAL_RCC_DMA1_CLK_ENABLE();
+      #ifdef STM32F1xx
+        __HAL_RCC_DMA1_CLK_ENABLE();
+        DMAtx.Instance = DMA1_Channel3;
+      #elif defined(STM32F4xx)
+        __HAL_RCC_DMA2_CLK_ENABLE();
+        DMAtx.Instance = DMA2_Stream3;
+        DMAtx.Init.Channel = DMA_CHANNEL_3;
+      #endif
       SPIx.Init.BaudRatePrescaler  = SPI_BAUDRATEPRESCALER_4;
-      DMAtx.Instance = DMA1_Channel3;
     }
   #endif
   #ifdef SPI2_BASE
     if (SPIx.Instance == SPI2) {
       __HAL_RCC_SPI2_CLK_ENABLE();
-      __HAL_RCC_DMA1_CLK_ENABLE();
-      DMAtx.Instance = DMA1_Channel5;
+      #ifdef STM32F1xx
+        __HAL_RCC_DMA1_CLK_ENABLE();
+        DMAtx.Instance = DMA1_Channel5;
+      #elif defined(STM32F4xx)
+        __HAL_RCC_DMA1_CLK_ENABLE();
+        DMAtx.Instance = DMA1_Stream4;
+        DMAtx.Init.Channel = DMA_CHANNEL_4;
+      #endif
     }
   #endif
   #ifdef SPI3_BASE
     if (SPIx.Instance == SPI3) {
       __HAL_RCC_SPI3_CLK_ENABLE();
-      __HAL_RCC_DMA2_CLK_ENABLE();
-      DMAtx.Instance = DMA2_Channel2;
+      #ifdef STM32F1xx
+        __HAL_RCC_DMA2_CLK_ENABLE();
+        DMAtx.Instance = DMA2_Channel2;
+      #elif defined(STM32F4xx)
+        __HAL_RCC_DMA1_CLK_ENABLE();
+        DMAtx.Instance = DMA1_Stream5;
+        DMAtx.Init.Channel = DMA_CHANNEL_5;
+      #endif
     }
   #endif
 
@@ -110,6 +119,9 @@ void TFT_SPI::Init() {
   DMAtx.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
   DMAtx.Init.Mode = DMA_NORMAL;
   DMAtx.Init.Priority = DMA_PRIORITY_LOW;
+  #if defined(STM32F4xx)
+    DMAtx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
+  #endif
 }
 
 void TFT_SPI::DataTransferBegin(uint16_t DataSize) {
@@ -142,12 +154,12 @@ uint32_t TFT_SPI::ReadID(uint16_t Reg) {
     __HAL_SPI_ENABLE(&SPIx);
 
     for (i = 0; i < 4; i++) {
-      #if TFT_MISO_PIN != TFT_MOSI_PIN
+      if (TFT_MISO_PIN != TFT_MOSI_PIN) {
         //if (hspi->Init.Direction == SPI_DIRECTION_2LINES) {
           while ((SPIx.Instance->SR & SPI_FLAG_TXE) != SPI_FLAG_TXE) {}
           SPIx.Instance->DR = 0;
         //}
-      #endif
+      }
       while ((SPIx.Instance->SR & SPI_FLAG_RXNE) != SPI_FLAG_RXNE) {}
       Data = (Data << 8) | SPIx.Instance->DR;
     }
@@ -162,21 +174,34 @@ uint32_t TFT_SPI::ReadID(uint16_t Reg) {
 }
 
 bool TFT_SPI::isBusy() {
-  if (DMAtx.Instance->CCR & DMA_CCR_EN)
+  #if defined(STM32F1xx)
+    volatile bool dmaEnabled = (DMAtx.Instance->CCR & DMA_CCR_EN) != RESET;
+  #elif defined(STM32F4xx)
+    volatile bool dmaEnabled = DMAtx.Instance->CR & DMA_SxCR_EN;
+  #endif
+  if (dmaEnabled) {
     if (__HAL_DMA_GET_FLAG(&DMAtx, __HAL_DMA_GET_TC_FLAG_INDEX(&DMAtx)) != 0 || __HAL_DMA_GET_FLAG(&DMAtx, __HAL_DMA_GET_TE_FLAG_INDEX(&DMAtx)) != 0)
       Abort();
-  return DMAtx.Instance->CCR & DMA_CCR_EN;
+  }
+  else {
+    Abort();
+  }
+  return dmaEnabled;
 }
 
 void TFT_SPI::Abort() {
-  __HAL_DMA_DISABLE(&DMAtx);
+  // First, abort any running dma
+  HAL_DMA_Abort(&DMAtx);
+  // DeInit objects
+  HAL_DMA_DeInit(&DMAtx);
+  HAL_SPI_DeInit(&SPIx);
+  // Deselect CS
   DataTransferEnd();
 }
 
 void TFT_SPI::Transmit(uint16_t Data) {
-  #if TFT_MISO_PIN == TFT_MOSI_PIN
+  if (TFT_MISO_PIN == TFT_MOSI_PIN)
     SPI_1LINE_TX(&SPIx);
-  #endif
 
   __HAL_SPI_ENABLE(&SPIx);
 
@@ -185,26 +210,23 @@ void TFT_SPI::Transmit(uint16_t Data) {
   while ((SPIx.Instance->SR & SPI_FLAG_TXE) != SPI_FLAG_TXE) {}
   while ((SPIx.Instance->SR & SPI_FLAG_BSY) == SPI_FLAG_BSY) {}
 
-  #if TFT_MISO_PIN != TFT_MOSI_PIN
+  if (TFT_MISO_PIN != TFT_MOSI_PIN)
     __HAL_SPI_CLEAR_OVRFLAG(&SPIx);   /* Clear overrun flag in 2 Lines communication mode because received is not read */
-  #endif
 }
 
 void TFT_SPI::TransmitDMA(uint32_t MemoryIncrease, uint16_t *Data, uint16_t Count) {
+  // Wait last dma finish, to start another
+  while(isBusy()) { }
+
   DMAtx.Init.MemInc = MemoryIncrease;
   HAL_DMA_Init(&DMAtx);
 
-  DataTransferBegin();
-
-  #if TFT_MISO_PIN == TFT_MOSI_PIN
+  if (TFT_MISO_PIN == TFT_MOSI_PIN)
     SPI_1LINE_TX(&SPIx);
-  #endif
 
-  DMAtx.DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << DMAtx.ChannelIndex);
-  DMAtx.Instance->CNDTR = Count;
-  DMAtx.Instance->CPAR = (uint32_t)&(SPIx.Instance->DR);
-  DMAtx.Instance->CMAR = (uint32_t)Data;
-  __HAL_DMA_ENABLE(&DMAtx);
+  DataTransferBegin();
+
+  HAL_DMA_Start(&DMAtx, (uint32_t)Data, (uint32_t)&(SPIx.Instance->DR), Count);
   __HAL_SPI_ENABLE(&SPIx);
 
   SET_BIT(SPIx.Instance->CR2, SPI_CR2_TXDMAEN);   /* Enable Tx DMA Request */

commit aa2ced96e05de394abf34cb5b75046f823aa4954
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Nov 26 03:47:07 2020 -0600

    Finish HAL/STM32 cpp wrappers

diff --git a/Marlin/src/HAL/STM32/tft/tft_spi.cpp b/Marlin/src/HAL/STM32/tft/tft_spi.cpp
index d3eb4ba8db..aed15ad66d 100644
--- a/Marlin/src/HAL/STM32/tft/tft_spi.cpp
+++ b/Marlin/src/HAL/STM32/tft/tft_spi.cpp
@@ -19,6 +19,7 @@
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
+#if defined(ARDUINO_ARCH_STM32) && !defined(STM32GENERIC)
 
 #include "../../../inc/MarlinConfig.h"
 
@@ -210,3 +211,4 @@ void TFT_SPI::TransmitDMA(uint32_t MemoryIncrease, uint16_t *Data, uint16_t Coun
 }
 
 #endif // HAS_SPI_TFT
+#endif // ARDUINO_ARCH_STM32 && !STM32GENERIC

commit 117df87d193994f6fbcd46c45573095adf921784
Author: Alexander Gavrilenko <jmz52@users.noreply.github.com>
Date:   Thu Jul 30 09:43:19 2020 +0300

    Support for TFT & Touch Screens (#18130)

diff --git a/Marlin/src/HAL/STM32/tft/tft_spi.cpp b/Marlin/src/HAL/STM32/tft/tft_spi.cpp
new file mode 100644
index 0000000000..d3eb4ba8db
--- /dev/null
+++ b/Marlin/src/HAL/STM32/tft/tft_spi.cpp
@@ -0,0 +1,212 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "../../../inc/MarlinConfig.h"
+
+#if HAS_SPI_TFT
+
+#include "tft_spi.h"
+#include "pinconfig.h"
+
+SPI_HandleTypeDef TFT_SPI::SPIx;
+DMA_HandleTypeDef TFT_SPI::DMAtx;
+
+void TFT_SPI::Init() {
+  SPI_TypeDef *spiInstance;
+
+  #if PIN_EXISTS(TFT_RESET)
+    OUT_WRITE(TFT_RESET_PIN, HIGH);
+    HAL_Delay(100);
+  #endif
+
+  #if PIN_EXISTS(TFT_BACKLIGHT)
+    OUT_WRITE(TFT_BACKLIGHT_PIN, HIGH);
+  #endif
+
+  OUT_WRITE(TFT_A0_PIN, HIGH);
+  OUT_WRITE(TFT_CS_PIN, HIGH);
+
+  if ((spiInstance = (SPI_TypeDef *)pinmap_peripheral(digitalPinToPinName(TFT_SCK_PIN),  PinMap_SPI_SCLK)) == NP) return;
+  if (spiInstance != (SPI_TypeDef *)pinmap_peripheral(digitalPinToPinName(TFT_MOSI_PIN), PinMap_SPI_MOSI)) return;
+
+  #if PIN_EXISTS(TFT_MISO) && (TFT_MISO_PIN != TFT_MOSI_PIN)
+    if (spiInstance != (SPI_TypeDef *)pinmap_peripheral(digitalPinToPinName(TFT_MISO_PIN), PinMap_SPI_MISO)) return;
+  #endif
+
+  SPIx.Instance                = spiInstance;
+  SPIx.State                   = HAL_SPI_STATE_RESET;
+  SPIx.Init.NSS                = SPI_NSS_SOFT;
+  SPIx.Init.Mode               = SPI_MODE_MASTER;
+  SPIx.Init.Direction          =
+  #if TFT_MISO_PIN == TFT_MOSI_PIN
+                                 SPI_DIRECTION_1LINE;
+  #else
+                                 SPI_DIRECTION_2LINES;
+  #endif
+  SPIx.Init.BaudRatePrescaler  = SPI_BAUDRATEPRESCALER_2;
+  SPIx.Init.CLKPhase           = SPI_PHASE_1EDGE;
+  SPIx.Init.CLKPolarity        = SPI_POLARITY_LOW;
+  SPIx.Init.DataSize           = SPI_DATASIZE_8BIT;
+  SPIx.Init.FirstBit           = SPI_FIRSTBIT_MSB;
+  SPIx.Init.TIMode             = SPI_TIMODE_DISABLE;
+  SPIx.Init.CRCCalculation     = SPI_CRCCALCULATION_DISABLE;
+  SPIx.Init.CRCPolynomial      = 10;
+
+  pinmap_pinout(digitalPinToPinName(TFT_SCK_PIN), PinMap_SPI_SCLK);
+  pinmap_pinout(digitalPinToPinName(TFT_MOSI_PIN), PinMap_SPI_MOSI);
+  #if PIN_EXISTS(TFT_MISO) && (TFT_MISO_PIN != TFT_MOSI_PIN)
+    pinmap_pinout(digitalPinToPinName(TFT_MISO_PIN), PinMap_SPI_MISO);
+  #endif
+  pin_PullConfig(get_GPIO_Port(STM_PORT(digitalPinToPinName(TFT_SCK_PIN))), STM_LL_GPIO_PIN(digitalPinToPinName(TFT_SCK_PIN)), GPIO_PULLDOWN);
+
+  #ifdef SPI1_BASE
+    if (SPIx.Instance == SPI1) {
+      __HAL_RCC_SPI1_CLK_ENABLE();
+      __HAL_RCC_DMA1_CLK_ENABLE();
+      SPIx.Init.BaudRatePrescaler  = SPI_BAUDRATEPRESCALER_4;
+      DMAtx.Instance = DMA1_Channel3;
+    }
+  #endif
+  #ifdef SPI2_BASE
+    if (SPIx.Instance == SPI2) {
+      __HAL_RCC_SPI2_CLK_ENABLE();
+      __HAL_RCC_DMA1_CLK_ENABLE();
+      DMAtx.Instance = DMA1_Channel5;
+    }
+  #endif
+  #ifdef SPI3_BASE
+    if (SPIx.Instance == SPI3) {
+      __HAL_RCC_SPI3_CLK_ENABLE();
+      __HAL_RCC_DMA2_CLK_ENABLE();
+      DMAtx.Instance = DMA2_Channel2;
+    }
+  #endif
+
+  HAL_SPI_Init(&SPIx);
+
+  DMAtx.Init.Direction = DMA_MEMORY_TO_PERIPH;
+  DMAtx.Init.PeriphInc = DMA_PINC_DISABLE;
+  DMAtx.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
+  DMAtx.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
+  DMAtx.Init.Mode = DMA_NORMAL;
+  DMAtx.Init.Priority = DMA_PRIORITY_LOW;
+}
+
+void TFT_SPI::DataTransferBegin(uint16_t DataSize) {
+  SPIx.Init.DataSize = DataSize == DATASIZE_8BIT ?  SPI_DATASIZE_8BIT : SPI_DATASIZE_16BIT;
+  HAL_SPI_Init(&SPIx);
+  WRITE(TFT_CS_PIN, LOW);
+}
+
+uint32_t TFT_SPI::GetID() {
+  uint32_t id;
+  id = ReadID(LCD_READ_ID);
+
+  if ((id & 0xFFFF) == 0 || (id & 0xFFFF) == 0xFFFF)
+    id = ReadID(LCD_READ_ID4);
+  return id;
+}
+
+uint32_t TFT_SPI::ReadID(uint16_t Reg) {
+  #if !PIN_EXISTS(TFT_MISO)
+    return 0;
+  #else
+    uint32_t BaudRatePrescaler = SPIx.Init.BaudRatePrescaler;
+    uint32_t i, Data = 0;
+
+    SPIx.Init.BaudRatePrescaler = SPIx.Instance == SPI1 ? SPI_BAUDRATEPRESCALER_8 : SPI_BAUDRATEPRESCALER_4;
+    DataTransferBegin(DATASIZE_8BIT);
+    WriteReg(Reg);
+
+    if (SPIx.Init.Direction == SPI_DIRECTION_1LINE) SPI_1LINE_RX(&SPIx);
+    __HAL_SPI_ENABLE(&SPIx);
+
+    for (i = 0; i < 4; i++) {
+      #if TFT_MISO_PIN != TFT_MOSI_PIN
+        //if (hspi->Init.Direction == SPI_DIRECTION_2LINES) {
+          while ((SPIx.Instance->SR & SPI_FLAG_TXE) != SPI_FLAG_TXE) {}
+          SPIx.Instance->DR = 0;
+        //}
+      #endif
+      while ((SPIx.Instance->SR & SPI_FLAG_RXNE) != SPI_FLAG_RXNE) {}
+      Data = (Data << 8) | SPIx.Instance->DR;
+    }
+
+    __HAL_SPI_DISABLE(&SPIx);
+    DataTransferEnd();
+
+    SPIx.Init.BaudRatePrescaler   = BaudRatePrescaler;
+
+    return Data >> 7;
+  #endif
+}
+
+bool TFT_SPI::isBusy() {
+  if (DMAtx.Instance->CCR & DMA_CCR_EN)
+    if (__HAL_DMA_GET_FLAG(&DMAtx, __HAL_DMA_GET_TC_FLAG_INDEX(&DMAtx)) != 0 || __HAL_DMA_GET_FLAG(&DMAtx, __HAL_DMA_GET_TE_FLAG_INDEX(&DMAtx)) != 0)
+      Abort();
+  return DMAtx.Instance->CCR & DMA_CCR_EN;
+}
+
+void TFT_SPI::Abort() {
+  __HAL_DMA_DISABLE(&DMAtx);
+  DataTransferEnd();
+}
+
+void TFT_SPI::Transmit(uint16_t Data) {
+  #if TFT_MISO_PIN == TFT_MOSI_PIN
+    SPI_1LINE_TX(&SPIx);
+  #endif
+
+  __HAL_SPI_ENABLE(&SPIx);
+
+  SPIx.Instance->DR = Data;
+
+  while ((SPIx.Instance->SR & SPI_FLAG_TXE) != SPI_FLAG_TXE) {}
+  while ((SPIx.Instance->SR & SPI_FLAG_BSY) == SPI_FLAG_BSY) {}
+
+  #if TFT_MISO_PIN != TFT_MOSI_PIN
+    __HAL_SPI_CLEAR_OVRFLAG(&SPIx);   /* Clear overrun flag in 2 Lines communication mode because received is not read */
+  #endif
+}
+
+void TFT_SPI::TransmitDMA(uint32_t MemoryIncrease, uint16_t *Data, uint16_t Count) {
+  DMAtx.Init.MemInc = MemoryIncrease;
+  HAL_DMA_Init(&DMAtx);
+
+  DataTransferBegin();
+
+  #if TFT_MISO_PIN == TFT_MOSI_PIN
+    SPI_1LINE_TX(&SPIx);
+  #endif
+
+  DMAtx.DmaBaseAddress->IFCR = (DMA_ISR_GIF1 << DMAtx.ChannelIndex);
+  DMAtx.Instance->CNDTR = Count;
+  DMAtx.Instance->CPAR = (uint32_t)&(SPIx.Instance->DR);
+  DMAtx.Instance->CMAR = (uint32_t)Data;
+  __HAL_DMA_ENABLE(&DMAtx);
+  __HAL_SPI_ENABLE(&SPIx);
+
+  SET_BIT(SPIx.Instance->CR2, SPI_CR2_TXDMAEN);   /* Enable Tx DMA Request */
+}
+
+#endif // HAS_SPI_TFT
