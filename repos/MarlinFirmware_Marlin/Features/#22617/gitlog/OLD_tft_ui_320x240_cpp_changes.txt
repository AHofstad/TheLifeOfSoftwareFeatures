commit 244de2458ac6fd48f3031d0179ca1bcad6808583
Author: Alexander Gavrilenko <jmz52@users.noreply.github.com>
Date:   Mon Jul 17 10:53:36 2023 +0300

    üßë‚Äçüíª Improve TFT Color UI layout / theme (#26077)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
deleted file mode 100644
index dcbfa935b4..0000000000
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ /dev/null
@@ -1,1221 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-#include "../../inc/MarlinConfigPre.h"
-
-#if HAS_UI_320x240
-
-#include "ui_common.h"
-
-#include "../marlinui.h"
-#include "../menu/menu.h"
-#include "../../libs/numtostr.h"
-
-#include "../../sd/cardreader.h"
-#include "../../module/temperature.h"
-#include "../../module/printcounter.h"
-#include "../../module/planner.h"
-#include "../../module/motion.h"
-
-#if DISABLED(LCD_PROGRESS_BAR) && ALL(FILAMENT_LCD_DISPLAY, HAS_MEDIA)
-  #include "../../feature/filwidth.h"
-  #include "../../gcode/parser.h"
-#endif
-
-#if ENABLED(AUTO_BED_LEVELING_UBL)
-  #include "../../feature/bedlevel/bedlevel.h"
-#endif
-
-void MarlinUI::tft_idle() {
-  #if ENABLED(TOUCH_SCREEN)
-    if (TERN0(HAS_TOUCH_SLEEP, lcd_sleep_task())) return;
-    if (draw_menu_navigation) {
-      constexpr uint16_t cx = TERN(TFT_COLOR_UI_PORTRAIT,  16,  48),
-                         cy = TERN(TFT_COLOR_UI_PORTRAIT, 286, 206);
-      add_control(cx, cy, PAGE_UP, imgPageUp, encoderTopLine > 0);
-      add_control(cx + 192, cy, PAGE_DOWN, imgPageDown, encoderTopLine + LCD_HEIGHT < screen_items);
-      add_control(cx + 96, cy, BACK, imgBack);
-      draw_menu_navigation = false;
-    }
-  #endif
-
-  tft.queue.async();
-
-  TERN_(TOUCH_SCREEN, if (tft.queue.is_empty()) touch.idle()); // Touch driver is not DMA-aware, so only check for touch controls after screen drawing is completed
-}
-
-#if ENABLED(SHOW_BOOTSCREEN)
-
-  void MarlinUI::show_bootscreen() {
-    tft.queue.reset();
-
-    tft.canvas(0, 0, TFT_WIDTH, TFT_HEIGHT);
-    #if ENABLED(BOOT_MARLIN_LOGO_SMALL)
-      #define BOOT_LOGO_W 195   // MarlinLogo195x59x16
-      #define BOOT_LOGO_H  59
-      #define SITE_URL_Y (TFT_HEIGHT - 48)
-      tft.set_background(COLOR_BACKGROUND);
-    #else
-      #define BOOT_LOGO_W TFT_WIDTH   // MarlinLogo320x240x16
-      #define BOOT_LOGO_H TFT_HEIGHT
-      #define SITE_URL_Y (TFT_HEIGHT - 54)
-    #endif
-    tft.add_image((TFT_WIDTH - BOOT_LOGO_W) / 2, (TFT_HEIGHT - BOOT_LOGO_H) / 2, imgBootScreen);
-    #ifdef WEBSITE_URL
-      tft_string.set(WEBSITE_URL);
-      tft.add_text(tft_string.center(TFT_WIDTH), SITE_URL_Y, COLOR_WEBSITE_URL, tft_string);
-    #endif
-
-    tft.queue.sync();
-  }
-
-  void MarlinUI::bootscreen_completion(const millis_t sofar) {
-    if ((BOOTSCREEN_TIMEOUT) > sofar) safe_delay((BOOTSCREEN_TIMEOUT) - sofar);
-    clear_lcd();
-  }
-
-#endif
-
-void MarlinUI::draw_kill_screen() {
-  tft.queue.reset();
-  tft.fill(0, 0, TFT_WIDTH, TFT_HEIGHT, COLOR_KILL_SCREEN_BG);
-
-  tft.canvas(0, 60, TFT_WIDTH, FONT_LINE_HEIGHT);
-  tft.set_background(COLOR_KILL_SCREEN_BG);
-  tft_string.set(status_message);
-  tft_string.trim();
-  tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_KILL_SCREEN_TEXT, tft_string);
-
-  tft.canvas(0, 120, TFT_WIDTH, FONT_LINE_HEIGHT);
-  tft.set_background(COLOR_KILL_SCREEN_BG);
-  tft_string.set(GET_TEXT(MSG_HALTED));
-  tft_string.trim();
-  tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_KILL_SCREEN_TEXT, tft_string);
-
-  tft.canvas(0, 160, TFT_WIDTH, FONT_LINE_HEIGHT);
-  tft.set_background(COLOR_KILL_SCREEN_BG);
-  tft_string.set(GET_TEXT(MSG_PLEASE_RESET));
-  tft_string.trim();
-  tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_KILL_SCREEN_TEXT, tft_string);
-
-  tft.queue.sync();
-}
-
-void draw_heater_status(uint16_t x, uint16_t y, const int8_t heater) {
-  MarlinImage image = imgHotEnd;
-  celsius_t currentTemperature, targetTemperature;
-
-  if (heater >= 0) { // HotEnd
-    #if HAS_EXTRUDERS
-      currentTemperature = thermalManager.wholeDegHotend(heater);
-      targetTemperature = thermalManager.degTargetHotend(heater);
-    #else
-      return;
-    #endif
-  }
-  #if HAS_HEATED_BED
-    else if (heater == H_BED) {
-      currentTemperature = thermalManager.wholeDegBed();
-      targetTemperature = thermalManager.degTargetBed();
-    }
-  #endif
-  #if HAS_TEMP_CHAMBER
-    else if (heater == H_CHAMBER) {
-      currentTemperature = thermalManager.wholeDegChamber();
-      #if HAS_HEATED_CHAMBER
-        targetTemperature = thermalManager.degTargetChamber();
-      #else
-        targetTemperature = ABSOLUTE_ZERO;
-      #endif
-    }
-  #endif
-  #if HAS_TEMP_COOLER
-    else if (heater == H_COOLER) {
-      currentTemperature = thermalManager.wholeDegCooler();
-      targetTemperature = TERN(HAS_COOLER, thermalManager.degTargetCooler(), ABSOLUTE_ZERO);
-    }
-  #endif
-  else return;
-
-  TERN_(TOUCH_SCREEN, if (targetTemperature >= 0) touch.add_control(HEATER, x, y, 64, 100, heater));
-  tft.canvas(x, y, 64, 100);
-  tft.set_background(COLOR_BACKGROUND);
-
-  uint16_t color = currentTemperature < 0 ? COLOR_INACTIVE : COLOR_COLD;
-
-  if (heater >= 0) { // HotEnd
-    if (currentTemperature >= 50) color = COLOR_HOTEND;
-  }
-  #if HAS_HEATED_BED
-    else if (heater == H_BED) {
-      if (currentTemperature >= 50) color = COLOR_HEATED_BED;
-      image = targetTemperature > 0 ? imgBedHeated : imgBed;
-    }
-  #endif
-  #if HAS_TEMP_CHAMBER
-    else if (heater == H_CHAMBER) {
-      if (currentTemperature >= 50) color = COLOR_CHAMBER;
-      image = targetTemperature > 0 ? imgChamberHeated : imgChamber;
-    }
-  #endif
-  #if HAS_TEMP_COOLER
-    else if (heater == H_COOLER) {
-      if (currentTemperature <= 26) color = COLOR_COLD;
-      if (currentTemperature > 26) color = COLOR_RED;
-      image = targetTemperature > 26 ? imgCoolerHot : imgCooler;
-    }
-  #endif
-
-  tft.add_image(0, 18, image, color);
-
-  tft_string.set(i16tostr3rj(currentTemperature));
-  tft_string.add(LCD_STR_DEGREE);
-  tft_string.trim();
-  tft.add_text(tft_string.center(64) + 2, 69 + tft_string.vcenter(FONT_LINE_HEIGHT), color, tft_string);
-
-  if (targetTemperature >= 0) {
-    tft_string.set(i16tostr3rj(targetTemperature));
-    tft_string.add(LCD_STR_DEGREE);
-    tft_string.trim();
-    tft.add_text(tft_string.center(64) + 2, 5 + tft_string.vcenter(FONT_LINE_HEIGHT), color, tft_string);
-  }
-}
-
-void draw_fan_status(uint16_t x, uint16_t y, const bool blink) {
-  TERN_(TOUCH_SCREEN, touch.add_control(FAN, x, y, 64, 100));
-  tft.canvas(x, y, 64, 100);
-  tft.set_background(COLOR_BACKGROUND);
-
-  uint8_t fanSpeed = thermalManager.fan_speed[0];
-  MarlinImage image;
-
-  if (fanSpeed >= 127)
-    image = blink ? imgFanFast1 : imgFanFast0;
-  else if (fanSpeed > 0)
-    image = blink ? imgFanSlow1 : imgFanSlow0;
-  else
-    image = imgFanIdle;
-
-  tft.add_image(0, 10, image, COLOR_FAN);
-
-  tft_string.set(ui8tostr4pctrj(thermalManager.fan_speed[0]));
-  tft_string.trim();
-  tft.add_text(tft_string.center(64) + 6, 69 + tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_FAN, tft_string);
-}
-
-void MarlinUI::draw_status_screen() {
-  const bool blink = get_blink();
-
-  TERN_(TOUCH_SCREEN, touch.clear());
-
-  // Statuses of heaters and fans
-  constexpr uint16_t y = TFT_STATUS_TOP_Y;
-  for (uint16_t i = 0 ; i < ITEMS_COUNT; i++) {
-    const uint16_t x = (TFT_WIDTH / ITEMS_COUNT - 64) / 2  + (TFT_WIDTH * i / ITEMS_COUNT);
-    switch (i) {
-      #if HAS_EXTRUDERS
-        case ITEM_E0: draw_heater_status(x, y, H_E0); break;
-      #endif
-      #if HAS_MULTI_HOTEND
-        case ITEM_E1: draw_heater_status(x, y, H_E1); break;
-      #endif
-      #if HOTENDS > 2
-        case ITEM_E2: draw_heater_status(x, y, H_E2); break;
-      #endif
-      #if HAS_HEATED_BED
-        case ITEM_BED: draw_heater_status(x, y, H_BED); break;
-      #endif
-      #if HAS_TEMP_CHAMBER
-        case ITEM_CHAMBER: draw_heater_status(x, y, H_CHAMBER); break;
-      #endif
-      #if HAS_TEMP_COOLER
-        case ITEM_COOLER: draw_heater_status(x, y, H_COOLER); break;
-      #endif
-      #if HAS_FAN
-        case ITEM_FAN: draw_fan_status(x, y, blink); break;
-      #endif
-    }
-  }
-
-  // 2nd horizontal group - current coordinates (height = 24, top margin = 3)
-  uint16_t width = TERN(TFT_COLOR_UI_PORTRAIT, 232, 312),
-          height = FONT_LINE_HEIGHT * TERN(TFT_COLOR_UI_PORTRAIT, 2, 1);
-  tft.canvas(4, 103, width, height);
-  tft.set_background(COLOR_BACKGROUND);
-  tft.add_rectangle(0, 0, width, height, COLOR_AXIS_HOMED);
-
-  if (TERN0(LCD_SHOW_E_TOTAL, printingIsActive())) {
-    #if ENABLED(LCD_SHOW_E_TOTAL)
-      tft.add_text(10, tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED, "E");
-      const uint8_t escale = e_move_accumulator >= 100000.0f ? 10 : 1; // After 100m switch to cm
-      tft_string.set(ftostr4sign(e_move_accumulator / escale));
-      tft_string.add(escale == 10 ? 'c' : 'm');
-      tft_string.add('m');
-      tft.add_text(127 - tft_string.width(), tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED, tft_string);
-    #endif
-  }
-  else {
-    #if HAS_X_AXIS
-      tft.add_text(TERN(TFT_COLOR_UI_PORTRAIT, 32, 10), tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED, "X");
-      const bool nhx = axis_should_home(X_AXIS);
-      tft_string.set(blink && nhx ? "?" : ftostr4sign(LOGICAL_X_POSITION(current_position.x)));
-      uint16_t pos_x = TERN(TFT_COLOR_UI_PORTRAIT, 32 - tft_string.width() / 2, 68 - tft_string.width()),
-               pos_y = SUM_TERN(TFT_COLOR_UI_PORTRAIT, tft_string.vcenter(FONT_LINE_HEIGHT), FONT_LINE_HEIGHT);
-      tft.add_text(pos_x, pos_y, nhx ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
-    #endif
-
-    #if HAS_Y_AXIS
-      tft.add_text(TERN(TFT_COLOR_UI_PORTRAIT, 110, 127), tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED, "Y");
-      const bool nhy = axis_should_home(Y_AXIS);
-      tft_string.set(blink && nhy ? "?" : ftostr4sign(LOGICAL_Y_POSITION(current_position.y)));
-      tft.add_text(
-        #if ENABLED(TFT_COLOR_UI_PORTRAIT)
-          110 - tft_string.width() / 2, FONT_LINE_HEIGHT + tft_string.vcenter(FONT_LINE_HEIGHT),
-        #else
-          185 - tft_string.width(), tft_string.vcenter(FONT_LINE_HEIGHT),
-        #endif
-        nhy ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string
-      );
-    #endif
-  }
-
-  #if HAS_Z_AXIS
-    tft.add_text(TERN(TFT_COLOR_UI_PORTRAIT, 192, 219), tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED, "Z");
-    const bool nhz = axis_should_home(Z_AXIS);
-    uint16_t offset = 25;
-    if (blink && nhz)
-      tft_string.set('?');
-    else {
-      const float z = LOGICAL_Z_POSITION(current_position.z);
-      tft_string.set(ftostr52sp((int16_t)z));
-      tft_string.rtrim();
-      offset += tft_string.width();
-
-      tft_string.set(ftostr52sp(z));
-      offset -= tft_string.width();
-    }
-  #endif
-
-  uint16_t pos_x = TERN(TFT_COLOR_UI_PORTRAIT, 192 - tft_string.width() / 2, 301 - tft_string.width() - offset),
-           pos_y = SUM_TERN(TFT_COLOR_UI_PORTRAIT, tft_string.vcenter(FONT_LINE_HEIGHT), FONT_LINE_HEIGHT);
-  tft.add_text(pos_x, pos_y, nhz ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
-
-  // 3rd horizontal group - controls and times (height = 64, top margin = 3)
-  // 3rd group, subgroup A - controls (on the sides)
-  #if ENABLED(TOUCH_SCREEN)
-    width = TERN(TFT_COLOR_UI_PORTRAIT, 232, 312);
-    height = TERN(TFT_COLOR_UI_PORTRAIT, FONT_LINE_HEIGHT * 2, FONT_LINE_HEIGHT);
-    touch.add_control(MOVE_AXIS, 0, 103, width, height);
-    add_control(256, 130, menu_main, imgSettings);
-    TERN_(SDSUPPORT, add_control(0, 130, menu_media, imgSD, !printingIsActive(), COLOR_CONTROL_ENABLED, card.isMounted() && printingIsActive() ? COLOR_BUSY : COLOR_CONTROL_DISABLED));
-  #endif
-
-  // 3rd group, subgroup B - speeds (center, top half)
-
-  // Feed rate
-  tft.canvas(
-    TERN(TFT_COLOR_UI_PORTRAIT,  30,  70),
-    TERN(TFT_COLOR_UI_PORTRAIT, 172, 132),
-    TERN(TFT_COLOR_UI_PORTRAIT,  80,  88),
-    MENU_ITEM_HEIGHT
-  );
-  tft.set_background(COLOR_BACKGROUND);
-  uint16_t color = feedrate_percentage == 100 ? COLOR_RATE_100 : COLOR_RATE_ALTERED;
-  tft.add_image(0, 0, imgFeedRate, color);
-  tft_string.set(i16tostr3rj(feedrate_percentage));
-  tft_string.add('%');
-  tft.add_text(32, tft_string.vcenter(30), color, tft_string);
-  TERN_(TOUCH_SCREEN, touch.add_control(FEEDRATE,
-    TERN(TFT_COLOR_UI_PORTRAIT,  30,  70),
-    TERN(TFT_COLOR_UI_PORTRAIT, 172, 132),
-    80, MENU_ITEM_HEIGHT
-  ));
-
-  // Flow rate
-  tft.canvas(
-    TERN(TFT_COLOR_UI_PORTRAIT, 140, 162),
-    TERN(TFT_COLOR_UI_PORTRAIT, 172, 132),
-    TERN(TFT_COLOR_UI_PORTRAIT,  80,  88),
-    MENU_ITEM_HEIGHT
-  );
-  tft.set_background(COLOR_BACKGROUND);
-  color = planner.flow_percentage[0] == 100 ? COLOR_RATE_100 : COLOR_RATE_ALTERED;
-  tft.add_image(0, 0, imgFlowRate, color);
-  tft_string.set(i16tostr3rj(planner.flow_percentage[active_extruder]));
-  tft_string.add('%');
-  tft.add_text(32, tft_string.vcenter(30), color, tft_string);
-  #if ENABLED(TOUCH_SCREEN)
-    touch.add_control(FLOWRATE,
-      TERN(TFT_COLOR_UI_PORTRAIT, 140, 170),
-      TERN(TFT_COLOR_UI_PORTRAIT, 172, 132),
-      80, MENU_ITEM_HEIGHT, active_extruder
-    );
-  #endif
-
-  // 3rd group, subgroup C - times (center, bottom half)
-  const progress_t progress = TERN(HAS_PRINT_PROGRESS_PERMYRIAD, get_progress_permyriad, get_progress_percent)();
-  const uint16_t time_str_width = 180, image_width = 34;
-  pos_x = (TFT_WIDTH - time_str_width) / 2;
-  pos_y = TERN(TFT_COLOR_UI_PORTRAIT, 256, 164);
-  #if ENABLED(SHOW_ELAPSED_TIME) && DISABLED(SHOW_REMAINING_TIME)
-    // Print duration so far (time elapsed) - centered
-    char elapsed_str[18];
-    duration_t elapsed = print_job_timer.duration();
-    elapsed.toCompactString(elapsed_str);
-
-    tft.canvas(pos_x, pos_y, time_str_width, MENU_ITEM_HEIGHT);
-    tft.set_background(COLOR_BACKGROUND);
-    tft_string.set(elapsed_str);
-    uint16_t text_pos_x = tft_string.center(time_str_width - image_width);
-    tft.add_image(text_pos_x, 0, imgTimeElapsed, COLOR_PRINT_TIME);
-    tft.add_text(text_pos_x + image_width, tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_PRINT_TIME, tft_string);
-
-  #elif DISABLED(SHOW_ELAPSED_TIME) && ENABLED(SHOW_REMAINING_TIME)
-    // Print time remaining estimation - centered
-    char estimate_str[18];
-    duration_t elapsed = print_job_timer.duration();
-
-    // Get the estimate, first from M73
-    uint32_t estimate_remaining = (0
-      #if ALL(SET_PROGRESS_MANUALLY, SET_REMAINING_TIME)
-        + get_remaining_time()
-      #endif
-    );
-    // If no M73 estimate is available but we have progress data, calculate time remaining assuming time elapsed is linear with progress
-    if (!estimate_remaining && progress > 0)
-      estimate_remaining = elapsed.value * (100 * (PROGRESS_SCALE) - progress) / progress;
-
-    // Generate estimate string
-    if (!estimate_remaining)
-      tft_string.set("-");
-    else {
-      duration_t estimation = estimate_remaining;
-      estimation.toCompactString(estimate_str);
-      tft_string.set(estimate_str);
-    }
-
-    tft.canvas(pos_x, pos_y, time_str_width, MENU_ITEM_HEIGHT);
-    tft.set_background(COLOR_BACKGROUND);
-    color = printingIsActive() ? COLOR_PRINT_TIME : COLOR_INACTIVE;
-    uint16_t text_pos_x = tft_string.center(time_str_width - image_width);
-    tft.add_image(text_pos_x, 0, imgTimeRemaining, color);
-    tft.add_text(text_pos_x + image_width, tft_string.vcenter(FONT_LINE_HEIGHT), color, tft_string);
-
-  #elif ALL(SHOW_REMAINING_TIME, SHOW_ELAPSED_TIME)
-    // Print duration so far (time elapsed) - aligned under feed rate
-    char elapsed_str[18];
-    duration_t elapsed = print_job_timer.duration();
-    elapsed.toCompactString(elapsed_str);
-
-    tft.canvas(pos_x, pos_y, time_str_width / 2 - 2, MENU_ITEM_HEIGHT);
-    tft.set_background(COLOR_BACKGROUND);
-    tft.add_image(0, 0, imgTimeElapsed, COLOR_PRINT_TIME);
-    tft_string.set(elapsed_str);
-    tft.add_text(32, tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_PRINT_TIME, tft_string);
-
-    // Print time remaining estimation - aligned under flow rate
-    char estimate_str[18];
-
-    // Get the estimate, first from M73
-    uint32_t estimate_remaining = (0
-      #if ALL(SET_PROGRESS_MANUALLY, SET_REMAINING_TIME)
-        + get_remaining_time()
-      #endif
-    );
-    // If no M73 estimate is available but we have progress data, calculate time remaining assuming time elapsed is linear with progress
-    if (!estimate_remaining && progress > 0)
-      estimate_remaining = elapsed.value * (100 * (PROGRESS_SCALE) - progress) / progress;
-
-    // Generate estimate string
-    if (!estimate_remaining)
-      tft_string.set("-");
-    else {
-      duration_t estimation = estimate_remaining;
-      estimation.toCompactString(estimate_str);
-      tft_string.set(estimate_str);
-    }
-
-    // Push out the estimate to the screen
-    tft.canvas(pos_x + time_str_width / 2 + 2, pos_y, time_str_width / 2 - 2, MENU_ITEM_HEIGHT);
-    tft.set_background(COLOR_BACKGROUND);
-    color = printingIsActive() ? COLOR_PRINT_TIME : COLOR_INACTIVE;
-    tft.add_image(0, 0, imgTimeRemaining, color);
-    tft.add_text(32, tft_string.vcenter(FONT_LINE_HEIGHT), color, tft_string);
-  #endif
-
-  // Fourth horizontal group - progress bar (height = 9, top margin = 4)
-  pos_y = TERN(TFT_COLOR_UI_PORTRAIT, 278, 198);
-  tft.canvas(4, pos_y, TFT_WIDTH - 8, 9);
-  tft.set_background(COLOR_PROGRESS_BG);
-  tft.add_rectangle(0, 0, TFT_WIDTH - 8, 9, COLOR_PROGRESS_FRAME);
-  if (progress)
-    tft.add_bar(1, 1, ((TFT_WIDTH - 10) * progress / (PROGRESS_SCALE)) / 100, 7, COLOR_PROGRESS_BAR);
-
-  // Status message
-  pos_y += 9 + 7;
-  tft.canvas(0, pos_y, TFT_WIDTH, TFT_HEIGHT - pos_y);
-  tft.set_background(COLOR_BACKGROUND);
-  tft_string.set(status_message);
-  tft_string.trim();
-  tft.add_text(tft_string.center(TFT_WIDTH), tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_STATUS_MESSAGE, tft_string);
-
-  #if ENABLED(TOUCH_SCREEN)
-  {
-    add_control(
-      TERN(TFT_COLOR_UI_PORTRAIT, 176, 256),
-      TERN(TFT_COLOR_UI_PORTRAIT, 210, 130),
-      menu_main, imgSettings
-    );
-    #if HAS_MEDIA
-      const bool cm = card.isMounted(), pa = printingIsActive();
-      if (cm && pa)
-        add_control(0, TERN(TFT_COLOR_UI_PORTRAIT, 210, 130), STOP, imgCancel, true, COLOR_CONTROL_CANCEL);
-      else
-        add_control(0, TERN(TFT_COLOR_UI_PORTRAIT, 210, 130), menu_media, imgSD, cm && !pa, COLOR_CONTROL_ENABLED, COLOR_CONTROL_DISABLED);
-    #endif
-  }
-  #endif // TOUCH_SCREEN
-}
-
-// Low-level draw_edit_screen can be used to draw an edit screen from anyplace
-void MenuEditItemBase::draw_edit_screen(FSTR_P const fstr, const char * const value/*=nullptr*/) {
-  ui.encoder_direction_normal();
-  TERN_(TOUCH_SCREEN, touch.clear());
-
-  uint16_t line = 1;
-
-  menu_line(line++);
-  tft_string.set(fstr, itemIndex, itemStringC, itemStringF);
-  tft_string.trim();
-  tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
-
-  TERN_(AUTO_BED_LEVELING_UBL, if (ui.external_control) line++);  // ftostr52() will overwrite *value so *value has to be displayed first
-
-  menu_line(line);
-  tft_string.set(value);
-  tft_string.trim();
-  tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
-
-  #if ENABLED(AUTO_BED_LEVELING_UBL)
-    if (ui.external_control) {
-      menu_line(line - 1);
-
-      tft_string.set(X_LBL);
-      tft.add_text(TFT_WIDTH / 2 - 120, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
-      tft_string.set(ftostr52(LOGICAL_X_POSITION(current_position.x)));
-      tft_string.trim();
-      tft.add_text(TFT_WIDTH / 2 - 16 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
-
-      tft_string.set(Y_LBL);
-      tft.add_text(TFT_WIDTH / 2 + 16, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
-      tft_string.set(ftostr52(LOGICAL_X_POSITION(current_position.y)));
-      tft_string.trim();
-      tft.add_text(TFT_WIDTH / 2 + 120 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
-    }
-  #endif
-
-  if (ui.can_show_slider()) {
-
-    #define SLIDER_LENGTH 224
-    #define SLIDER_Y_POSITION 140
-
-    tft.canvas((TFT_WIDTH - SLIDER_LENGTH) / 2, SLIDER_Y_POSITION, SLIDER_LENGTH, 16);
-    tft.set_background(COLOR_BACKGROUND);
-
-    int16_t position = (SLIDER_LENGTH - 2) * ui.encoderPosition / maxEditValue;
-    tft.add_bar(0, 7, 1, 2, ui.encoderPosition == 0 ? COLOR_SLIDER_INACTIVE : COLOR_SLIDER);
-    tft.add_bar(1, 6, position, 4, COLOR_SLIDER);
-    tft.add_bar(position + 1, 6, SLIDER_LENGTH - 2 - position, 4, COLOR_SLIDER_INACTIVE);
-    tft.add_bar(SLIDER_LENGTH - 1, 7, 1, 2, int32_t(ui.encoderPosition) == maxEditValue ? COLOR_SLIDER : COLOR_SLIDER_INACTIVE);
-
-    #if ENABLED(TOUCH_SCREEN)
-      tft.add_image((SLIDER_LENGTH - 8) * ui.encoderPosition / maxEditValue, 0, imgSlider, COLOR_SLIDER);
-      touch.add_control(SLIDER, (TFT_WIDTH - SLIDER_LENGTH) / 2, SLIDER_Y_POSITION - 8, SLIDER_LENGTH, 32, maxEditValue);
-    #endif
-  }
-
-  tft.draw_edit_screen_buttons();
-}
-
-void TFT::draw_edit_screen_buttons() {
-  #if ENABLED(TOUCH_SCREEN)
-    add_control(TERN(TFT_COLOR_UI_PORTRAIT, 16, 32), TFT_HEIGHT - 64, DECREASE, imgDecrease);
-    add_control(TERN(TFT_COLOR_UI_PORTRAIT, 172, 224), TFT_HEIGHT - 64, INCREASE, imgIncrease);
-    add_control(TERN(TFT_COLOR_UI_PORTRAIT, 96, 128), TFT_HEIGHT - 64, CLICK, imgConfirm);
-  #endif
-}
-
-// The Select Screen presents a prompt and two "buttons"
-void MenuItem_confirm::draw_select_screen(FSTR_P const yes, FSTR_P const no, const bool yesno, FSTR_P const pref, const char * const string/*=nullptr*/, FSTR_P const suff/*=nullptr*/) {
-  uint16_t line = 1;
-
-  if (!string) line++;
-
-  menu_line(line++);
-  tft_string.set(pref);
-  tft_string.trim();
-  tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
-
-  if (string) {
-    menu_line(line++);
-    tft_string.set(string);
-    tft_string.trim();
-    tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
-  }
-
-  if (suff) {
-    menu_line(line);
-    tft_string.set(suff);
-    tft_string.trim();
-    tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
-  }
-  #if ENABLED(TOUCH_SCREEN)
-    if (no)  add_control(TERN(TFT_COLOR_UI_PORTRAIT, 32,48), TFT_HEIGHT - 64, CANCEL, imgCancel, true, yesno ? HALF(COLOR_CONTROL_CANCEL) : COLOR_CONTROL_CANCEL);
-    if (yes) add_control(TERN(TFT_COLOR_UI_PORTRAIT, 172, 208), TFT_HEIGHT - 64, CONFIRM, imgConfirm, true, yesno ? COLOR_CONTROL_CONFIRM : HALF(COLOR_CONTROL_CONFIRM));
-  #endif
-}
-
-#if ENABLED(ADVANCED_PAUSE_FEATURE)
-
-  void MarlinUI::draw_hotend_status(const uint8_t row, const uint8_t extruder) {
-    #if ENABLED(TOUCH_SCREEN)
-      touch.clear();
-      draw_menu_navigation = false;
-      touch.add_control(RESUME_CONTINUE, 0, 0, TFT_WIDTH, TFT_HEIGHT);
-    #endif
-
-    menu_line(row);
-    tft_string.set(GET_TEXT(MSG_FILAMENT_CHANGE_NOZZLE));
-    tft_string.add('E');
-    tft_string.add((char)('1' + extruder));
-    tft_string.add(' ');
-    tft_string.add(i16tostr3rj(thermalManager.wholeDegHotend(extruder)));
-    tft_string.add(LCD_STR_DEGREE);
-    tft_string.add(F(" / "));
-    tft_string.add(i16tostr3rj(thermalManager.degTargetHotend(extruder)));
-    tft_string.add(LCD_STR_DEGREE);
-    tft_string.trim();
-    tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
-  }
-
-#endif // ADVANCED_PAUSE_FEATURE
-
-#if ENABLED(AUTO_BED_LEVELING_UBL)
-  #define GRID_OFFSET_X   8
-  #define GRID_OFFSET_Y   8
-  #define GRID_WIDTH      144
-  #define GRID_HEIGHT     144
-  #define CONTROL_OFFSET  8
-
-  void MarlinUI::ubl_plot(const uint8_t x_plot, const uint8_t y_plot) {
-
-    tft.canvas(GRID_OFFSET_X, GRID_OFFSET_Y, GRID_WIDTH, GRID_HEIGHT);
-    tft.set_background(COLOR_BACKGROUND);
-    tft.add_rectangle(0, 0, GRID_WIDTH, GRID_HEIGHT, COLOR_WHITE);
-
-    for (uint16_t x = 0; x < (GRID_MAX_POINTS_X); x++)
-      for (uint16_t y = 0; y < (GRID_MAX_POINTS_Y); y++)
-        if (position_is_reachable({ bedlevel.get_mesh_x(x), bedlevel.get_mesh_y(y) }))
-          tft.add_bar(1 + (x * 2 + 1) * (GRID_WIDTH - 4) / (GRID_MAX_POINTS_X) / 2, GRID_HEIGHT - 3 - ((y * 2 + 1) * (GRID_HEIGHT - 4) / (GRID_MAX_POINTS_Y) / 2), 2, 2, COLOR_UBL);
-
-    tft.add_rectangle((x_plot * 2 + 1) * (GRID_WIDTH - 4) / (GRID_MAX_POINTS_X) / 2 - 1, GRID_HEIGHT - 5 - ((y_plot * 2 + 1) * (GRID_HEIGHT - 4) / (GRID_MAX_POINTS_Y) / 2), 6, 6, COLOR_UBL);
-
-    const xy_pos_t pos = { bedlevel.get_mesh_x(x_plot), bedlevel.get_mesh_y(y_plot) },
-                   lpos = pos.asLogical();
-
-    tft.canvas(216, GRID_OFFSET_Y + (GRID_HEIGHT - MENU_ITEM_HEIGHT) / 2 - MENU_ITEM_HEIGHT, 96, MENU_ITEM_HEIGHT);
-    tft.set_background(COLOR_BACKGROUND);
-    tft_string.set(X_LBL);
-    tft.add_text(0, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
-    tft_string.set(ftostr52(lpos.x));
-    tft_string.trim();
-    tft.add_text(96 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
-
-    tft.canvas(216, GRID_OFFSET_Y + (GRID_HEIGHT - MENU_ITEM_HEIGHT) / 2, 96, MENU_ITEM_HEIGHT);
-    tft.set_background(COLOR_BACKGROUND);
-    tft_string.set(Y_LBL);
-    tft.add_text(0, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
-    tft_string.set(ftostr52(lpos.y));
-    tft_string.trim();
-    tft.add_text(96 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
-
-    tft.canvas(216, GRID_OFFSET_Y + (GRID_HEIGHT - MENU_ITEM_HEIGHT) / 2 + MENU_ITEM_HEIGHT, 96, MENU_ITEM_HEIGHT);
-    tft.set_background(COLOR_BACKGROUND);
-    tft_string.set(Z_LBL);
-    tft.add_text(0, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
-    tft_string.set(isnan(bedlevel.z_values[x_plot][y_plot]) ? "-----" : ftostr43sign(bedlevel.z_values[x_plot][y_plot]));
-    tft_string.trim();
-    tft.add_text(96 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
-
-    constexpr uint8_t w = (TFT_WIDTH) / 10;
-    tft.canvas(GRID_OFFSET_X + (GRID_WIDTH - w) / 2, GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET - 1, w, MENU_ITEM_HEIGHT);
-    tft.set_background(COLOR_BACKGROUND);
-    tft_string.set(ui8tostr3rj(x_plot));
-    tft_string.trim();
-    tft.add_text(tft_string.center(w), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
-
-    tft.canvas(GRID_OFFSET_X + GRID_WIDTH + CONTROL_OFFSET, GRID_OFFSET_Y + (GRID_HEIGHT - 27) / 2, w, MENU_ITEM_HEIGHT);
-    tft.set_background(COLOR_BACKGROUND);
-    tft_string.set(ui8tostr3rj(y_plot));
-    tft_string.trim();
-    tft.add_text(tft_string.center(w), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
-
-    #if ENABLED(TOUCH_SCREEN)
-      touch.clear();
-      draw_menu_navigation = false;
-      add_control(GRID_OFFSET_X + GRID_WIDTH + CONTROL_OFFSET,      GRID_OFFSET_Y + CONTROL_OFFSET,                    UBL,  (ENCODER_STEPS_PER_MENU_ITEM) * (GRID_MAX_POINTS_X), imgUp);
-      add_control(GRID_OFFSET_X + GRID_WIDTH + CONTROL_OFFSET,      GRID_OFFSET_Y + GRID_HEIGHT - CONTROL_OFFSET - 32, UBL, -(ENCODER_STEPS_PER_MENU_ITEM) * (GRID_MAX_POINTS_X), imgDown);
-      add_control(GRID_OFFSET_X + CONTROL_OFFSET,                   GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET,      UBL, -(ENCODER_STEPS_PER_MENU_ITEM), imgLeft);
-      add_control(GRID_OFFSET_X + GRID_WIDTH - CONTROL_OFFSET - 32, GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET,      UBL,   ENCODER_STEPS_PER_MENU_ITEM, imgRight);
-      add_control(224, GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET, CLICK, imgLeveling);
-      add_control(144, 206, BACK, imgBack);
-    #endif
-  }
-#endif // AUTO_BED_LEVELING_UBL
-
-#if ENABLED(BABYSTEP_ZPROBE_OFFSET)
-  #include "../../feature/babystep.h"
-#endif
-
-#if HAS_BED_PROBE
-  #include "../../module/probe.h"
-#endif
-
-#define Z_SELECTION_Z 1
-#define Z_SELECTION_Z_PROBE -1
-
-struct {
-  #if HAS_X_AXIS
-    xy_int_t xValuePos;
-  #endif
-  #if HAS_Y_AXIS
-    xy_int_t yValuePos;
-  #endif
-  #if HAS_Z_AXIS
-    xy_int_t zValuePos, zTypePos;
-    int z_selection = Z_SELECTION_Z;
-  #endif
-  #if HAS_EXTRUDERS
-    xy_int_t eValuePos, eNamePos;
-    uint8_t e_selection = 0;
-  #endif
-  xy_int_t stepValuePos;
-  float currentStepSize = 10.0;
-  bool blocked = false;
-  char message[32];
-} motionAxisState;
-
-#define BTN_WIDTH 48
-#define BTN_HEIGHT 39
-#define X_MARGIN 15
-#define Y_MARGIN 11
-
-static void quick_feedback() {
-  #if HAS_CHIRP
-    ui.chirp(); // Buzz and wait. Is the delay needed for buttons to settle?
-    #if ALL(HAS_MARLINUI_MENU, HAS_BEEPER)
-      for (int8_t i = 5; i--;) { buzzer.tick(); delay(2); }
-    #elif HAS_MARLINUI_MENU
-      delay(10);
-    #endif
-  #endif
-}
-
-#define CUR_STEP_VALUE_WIDTH 38
-static void drawCurStepValue() {
-  tft_string.set(ftostr52sp(motionAxisState.currentStepSize));
-  tft.canvas(motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y, CUR_STEP_VALUE_WIDTH, 20);
-  tft.set_background(COLOR_BACKGROUND);
-  tft.add_text(CUR_STEP_VALUE_WIDTH - tft_string.width(), 0, COLOR_AXIS_HOMED, tft_string);
-  tft.queue.sync();
-  tft_string.set(F("mm"));
-  tft.canvas(motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y + 20, CUR_STEP_VALUE_WIDTH, 20);
-  tft.set_background(COLOR_BACKGROUND);
-  tft.add_text(CUR_STEP_VALUE_WIDTH - tft_string.width(), 0, COLOR_AXIS_HOMED, tft_string);
-}
-
-#if HAS_Z_AXIS
-  static void drawCurZSelection() {
-    tft_string.set('Z');
-    tft.canvas(motionAxisState.zTypePos.x, motionAxisState.zTypePos.y, tft_string.width(), 20);
-    tft.set_background(COLOR_BACKGROUND);
-    tft.add_text(0, 0, Z_BTN_COLOR, tft_string);
-    tft.queue.sync();
-    tft_string.set(F("Offset"));
-    tft.canvas(motionAxisState.zTypePos.x, motionAxisState.zTypePos.y + 34, tft_string.width(), 20);
-    tft.set_background(COLOR_BACKGROUND);
-    #if HAS_BED_PROBE
-      if (motionAxisState.z_selection == Z_SELECTION_Z_PROBE)
-        tft.add_text(0, 0, Z_BTN_COLOR, tft_string);
-    #endif
-  }
-#endif
-
-#if HAS_EXTRUDERS
-  static void drawCurESelection() {
-    tft.canvas(motionAxisState.eNamePos.x, motionAxisState.eNamePos.y, BTN_WIDTH, BTN_HEIGHT);
-    tft.set_background(COLOR_BACKGROUND);
-    tft_string.set('E');
-    tft.add_text(0, 0, E_BTN_COLOR, tft_string);
-    tft.add_text(tft_string.width(), 0, E_BTN_COLOR, ui8tostr3rj(motionAxisState.e_selection));
-  }
-#endif
-
-static void drawMessage(PGM_P const msg) {
-  tft.canvas(X_MARGIN,
-    #if ENABLED(TFT_COLOR_UI_PORTRAIT)
-      TFT_HEIGHT - 2 * BTN_HEIGHT, TFT_WIDTH - X_MARGIN
-    #else
-      TFT_HEIGHT - Y_MARGIN - 29, (TFT_WIDTH / 2) - (BTN_WIDTH / 2) - X_MARGIN
-    #endif
-    , FONT_LINE_HEIGHT
-  );
-  tft.set_background(COLOR_BACKGROUND);
-  tft.add_text(0, 0, COLOR_STATUS_MESSAGE, msg);
-}
-
-static void drawMessage(FSTR_P const fmsg) { drawMessage(FTOP(fmsg)); }
-
-static void drawAxisValue(const AxisEnum axis) {
-  const float value = (
-    TERN_(HAS_BED_PROBE, axis == Z_AXIS && motionAxisState.z_selection == Z_SELECTION_Z_PROBE ? probe.offset.z :)
-    ui.manual_move.axis_value(axis)
-  );
-  xy_int_t pos;
-  uint16_t color;
-  switch (axis) {
-    #if HAS_X_AXIS
-      case X_AXIS: pos = motionAxisState.xValuePos; color = X_BTN_COLOR; break;
-    #endif
-    #if HAS_Y_AXIS
-      case Y_AXIS: pos = motionAxisState.yValuePos; color = Y_BTN_COLOR; break;
-    #endif
-    #if HAS_Z_AXIS
-      case Z_AXIS: pos = motionAxisState.zValuePos; color = Z_BTN_COLOR; break;
-    #endif
-    #if HAS_EXTRUDERS
-      case E_AXIS: pos = motionAxisState.eValuePos; color = E_BTN_COLOR; break;
-    #endif
-    default: return;
-  }
-  tft.canvas(pos.x, pos.y, BTN_WIDTH + X_MARGIN, FONT_LINE_HEIGHT);
-  tft.set_background(COLOR_BACKGROUND);
-  tft_string.set(ftostr52sp(value));
-  tft.add_text(0, 0, color, tft_string);
-}
-
-static void moveAxis(const AxisEnum axis, const int8_t direction) {
-  quick_feedback();
-
-  #if HAS_EXTRUDERS
-    if (axis == E_AXIS && thermalManager.tooColdToExtrude(motionAxisState.e_selection)) {
-      drawMessage(F("Too cold"));
-      return;
-    }
-  #endif
-
-  const float diff = motionAxisState.currentStepSize * direction;
-
-  #if HAS_BED_PROBE
-
-    if (axis == Z_AXIS && motionAxisState.z_selection == Z_SELECTION_Z_PROBE) {
-      #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
-        const int16_t babystep_increment = direction * BABYSTEP_SIZE_Z;
-        const bool do_probe = DISABLED(BABYSTEP_HOTEND_Z_OFFSET) || active_extruder == 0;
-        const float bsDiff = planner.mm_per_step[Z_AXIS] * babystep_increment,
-                    new_probe_offset = probe.offset.z + bsDiff,
-                    new_offs = TERN(BABYSTEP_HOTEND_Z_OFFSET
-                      , do_probe ? new_probe_offset : hotend_offset[active_extruder].z - bsDiff
-                      , new_probe_offset
-                    );
-        if (WITHIN(new_offs, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
-          babystep.add_steps(Z_AXIS, babystep_increment);
-          if (do_probe)
-            probe.offset.z = new_offs;
-          else
-            TERN(BABYSTEP_HOTEND_Z_OFFSET, hotend_offset[active_extruder].z = new_offs, NOOP);
-          drawMessage(NUL_STR); // Clear the error
-          drawAxisValue(axis);
-        }
-        else
-          drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
-
-      #else
-        // Only change probe.offset.z
-        probe.offset.z += diff;
-        if (direction < 0 && current_position.z < Z_PROBE_OFFSET_RANGE_MIN) {
-          current_position.z = Z_PROBE_OFFSET_RANGE_MIN;
-          drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
-        }
-        else if (direction > 0 && current_position.z > Z_PROBE_OFFSET_RANGE_MAX) {
-          current_position.z = Z_PROBE_OFFSET_RANGE_MAX;
-          drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
-        }
-        else
-          drawMessage(NUL_STR); // Clear the error
-
-        drawAxisValue(axis);
-      #endif
-    }
-
-  #endif // HAS_BED_PROBE
-
-  if (!ui.manual_move.processing) {
-    // Get motion limit from software endstops, if any
-    float min, max;
-    soft_endstop.get_manual_axis_limits(axis, min, max);
-
-    // Delta limits XY based on the current offset from center
-    // This assumes the center is 0,0
-    #if ENABLED(DELTA)
-      if (axis != Z_AXIS && TERN1(HAS_EXTRUDERS, axis != E_AXIS)) {
-        max = SQRT(sq(float(PRINTABLE_RADIUS)) - sq(current_position[Y_AXIS - axis])); // (Y_AXIS - axis) == the other axis
-        min = -max;
-      }
-    #endif
-
-    // Get the new position
-    const bool limited = ui.manual_move.apply_diff(axis, diff, min, max);
-    #if IS_KINEMATIC
-      UNUSED(limited);
-    #else
-      PGM_P const msg = limited ? GET_TEXT(MSG_LCD_SOFT_ENDSTOPS) : NUL_STR;
-      drawMessage(msg);
-    #endif
-
-    ui.manual_move.soon(axis OPTARG(MULTI_E_MANUAL, motionAxisState.e_selection));
-  }
-
-  drawAxisValue(axis);
-}
-
-#if HAS_EXTRUDERS
-  static void e_plus()  { moveAxis(E_AXIS, 1);  }
-  static void e_minus() { moveAxis(E_AXIS, -1); }
-#endif
-#if HAS_X_AXIS
-  static void x_minus() { moveAxis(X_AXIS, -1); }
-  static void x_plus()  { moveAxis(X_AXIS, 1);  }
-#endif
-#if HAS_Y_AXIS
-  static void y_plus()  { moveAxis(Y_AXIS, 1);  }
-  static void y_minus() { moveAxis(Y_AXIS, -1); }
-#endif
-#if HAS_Z_AXIS
-  static void z_plus()  { moveAxis(Z_AXIS, 1);  }
-  static void z_minus() { moveAxis(Z_AXIS, -1); }
-#endif
-
-#if ENABLED(TOUCH_SCREEN)
-  #if HAS_EXTRUDERS
-    static void e_select() {
-      if (++motionAxisState.e_selection >= EXTRUDERS)
-        motionAxisState.e_selection = 0;
-      quick_feedback();
-      drawCurESelection();
-      drawAxisValue(E_AXIS);
-    }
-  #endif
-
-  static void do_home() {
-    quick_feedback();
-    drawMessage(GET_TEXT_F(MSG_LEVEL_BED_HOMING));
-    queue.inject_P(G28_STR);
-    // Disable touch until home is done
-    touch.disable();
-    TERN_(HAS_EXTRUDERS, drawAxisValue(E_AXIS));
-    TERN_(HAS_X_AXIS, drawAxisValue(X_AXIS));
-    TERN_(HAS_Y_AXIS, drawAxisValue(Y_AXIS));
-    TERN_(HAS_Z_AXIS, drawAxisValue(Z_AXIS));
-  }
-
-  static void step_size() {
-    motionAxisState.currentStepSize = motionAxisState.currentStepSize / 10.0;
-    if (motionAxisState.currentStepSize < 0.0015) motionAxisState.currentStepSize = 10.0;
-    quick_feedback();
-    drawCurStepValue();
-  }
-
-  #if HAS_BED_PROBE
-    static void z_select() {
-      motionAxisState.z_selection *= -1;
-      quick_feedback();
-      drawCurZSelection();
-      drawAxisValue(Z_AXIS);
-    }
-  #endif
-
-#endif // TOUCH_SCREEN
-
-static void disable_steppers() {
-  quick_feedback();
-  queue.inject(F("M84"));
-}
-
-static void drawBtn(const int x, const int y, const char *label, intptr_t data, const MarlinImage img, uint16_t bgColor, const bool enabled=true) {
-  const uint16_t width = images[imgBtn39Rounded].width,
-                height = images[imgBtn39Rounded].height;
-
-  if (!enabled) bgColor = COLOR_CONTROL_DISABLED;
-
-  tft.canvas(x, y, width, height);
-  tft.set_background(COLOR_BACKGROUND);
-  tft.add_image(0, 0, imgBtn39Rounded, bgColor, COLOR_BACKGROUND, COLOR_DARKGREY);
-
-  // TODO: Make an add_text() taking a font arg
-  if (label) {
-    tft_string.set(label);
-    tft_string.trim();
-    tft.add_text(tft_string.center(width), height / 2 - tft_string.font_height() / 2, bgColor, tft_string);
-  }
-  else
-    tft.add_image(0, 0, img, bgColor, COLOR_BACKGROUND, COLOR_DARKGREY);
-
-  TERN_(TOUCH_SCREEN, if (enabled) touch.add_control(BUTTON, x, y, width, height, data));
-}
-
-void MarlinUI::move_axis_screen() {
-  // Reset
-  defer_status_screen(true);
-  motionAxisState.blocked = false;
-  TERN_(TOUCH_SCREEN, touch.enable());
-
-  ui.clear_lcd();
-
-  TERN_(TOUCH_SCREEN, touch.clear());
-
-  const bool busy = printingIsActive();
-
-  // Babysteps during printing? Select babystep for Z probe offset
-  #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
-    if (busy) motionAxisState.z_selection = Z_SELECTION_Z_PROBE;
-  #endif
-
-  #if ENABLED(TFT_COLOR_UI_PORTRAIT)
-
-    // ROW 1 -> E+ Y+ Z+
-    int x = X_MARGIN, y = Y_MARGIN, spacing = 0;
-
-    TERN_(HAS_EXTRUDERS, drawBtn(x, y, "E+", (intptr_t)e_plus, imgUp, E_BTN_COLOR, !busy));
-
-    spacing = (TFT_WIDTH - X_MARGIN * 2 - 3 * BTN_WIDTH) / 2;
-    x += BTN_WIDTH + spacing;
-    uint16_t yplus_x = x;
-
-    TERN_(HAS_Y_AXIS, drawBtn(x, y, "Y+", (intptr_t)y_plus, imgUp, Y_BTN_COLOR, !busy));
-
-    x += BTN_WIDTH + spacing;
-    uint16_t zplus_x = x;
-
-    #if HAS_Z_AXIS
-      drawBtn(x, y, "Z+", (intptr_t)z_plus, imgUp, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); // Only enabled when not busy or have baby step
-    #endif
-
-    // ROW 2 -> "Ex" CurY "Z"
-    x = X_MARGIN;
-    y += BTN_HEIGHT + 2;
-
-    #if HAS_EXTRUDERS
-      motionAxisState.eNamePos.set(x, y);
-      drawCurESelection();
-      TERN_(TOUCH_SCREEN, if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, BTN_HEIGHT, (intptr_t)e_select));
-    #endif
-
-    #if HAS_Y_AXIS
-      motionAxisState.yValuePos.set(yplus_x, y);
-      drawAxisValue(Y_AXIS);
-    #endif
-
-    #if HAS_Z_AXIS
-      motionAxisState.zTypePos.set(zplus_x, y);
-      drawCurZSelection();
-    #endif
-
-    // ROW 3 -> X-    HOME    X+
-    y += (TFT_HEIGHT - Y_MARGIN * 2 - 4 * BTN_HEIGHT) / 3 - 2;
-    x = X_MARGIN;
-
-    #if HAS_X_AXIS
-      drawBtn(x, y, "X-", (intptr_t)x_minus, imgLeft, X_BTN_COLOR, !busy);
-      TERN_(TOUCH_SCREEN, add_control(TFT_WIDTH / 2 - images[imgHome].width / 2, y - (images[imgHome].width - BTN_HEIGHT) / 2, BUTTON, (intptr_t)do_home, imgHome, !busy));
-      drawBtn(zplus_x, y, "X+", (intptr_t)x_plus, imgRight, X_BTN_COLOR, !busy);
-    #endif
-
-    #if ALL(HAS_BED_PROBE, TOUCH_SCREEN)
-      if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, 34 * 2, (intptr_t)z_select);
-    #endif
-
-    // ROW 4 -> Cur X
-    y += BTN_HEIGHT + 2;
-
-    #if HAS_X_AXIS
-      motionAxisState.xValuePos.set(x, y);
-      drawAxisValue(X_AXIS);
-    #endif
-
-    // ROW 5 -> E- CurX Y-    Z-
-    y += (TFT_HEIGHT - Y_MARGIN * 2 - 4 * BTN_HEIGHT) / 3 - 2;
-    x = X_MARGIN;
-
-    #if HAS_EXTRUDERS
-      drawBtn(x, y, "E-", (intptr_t)e_minus, imgDown, E_BTN_COLOR, !busy);
-      motionAxisState.eValuePos.set(x, y + BTN_HEIGHT + 2);
-      TERN_(HAS_EXTRUDERS, drawAxisValue(E_AXIS));
-    #endif
-
-    x += BTN_WIDTH + spacing;
-
-    TERN_(HAS_Y_AXIS, drawBtn(x, y, "Y-", (intptr_t)y_minus, imgDown, Y_BTN_COLOR, !busy));
-
-    x += BTN_WIDTH + spacing;
-
-    #if HAS_Z_AXIS
-      drawBtn(x, y, "Z-", (intptr_t)z_minus, imgDown, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); //only enabled when not busy or have baby step
-      motionAxisState.zValuePos.set(x, y + BTN_HEIGHT + 2);
-      drawAxisValue(Z_AXIS);
-    #endif
-
-    // ROW 6 -> step_size    disable steppers back
-    y = TFT_HEIGHT - Y_MARGIN - BTN_HEIGHT;
-    x = zplus_x - CUR_STEP_VALUE_WIDTH - 10;
-    motionAxisState.stepValuePos.set(X_MARGIN + BTN_WIDTH - CUR_STEP_VALUE_WIDTH, y);
-
-    if (!busy) {
-      drawCurStepValue();
-      TERN_(TOUCH_SCREEN, touch.add_control(BUTTON, motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y, CUR_STEP_VALUE_WIDTH, BTN_HEIGHT, (intptr_t)step_size));
-    }
-
-    // Aligned with x+
-    drawBtn(yplus_x, y, "off", (intptr_t)disable_steppers, imgCancel, COLOR_WHITE, !busy);
-
-  #else // !TFT_COLOR_UI_PORTRAIT
-
-    // ROW 1 -> E+ Y+ CurY Z+
-    int x = X_MARGIN, y = Y_MARGIN, spacing = 0;
-
-    TERN_(HAS_EXTRUDERS, drawBtn(x, y, "E+", (intptr_t)e_plus, imgUp, E_BTN_COLOR, !busy));
-
-    spacing = (TFT_WIDTH - X_MARGIN * 2 - 3 * BTN_WIDTH) / 2;
-    x += BTN_WIDTH + spacing;
-    uint16_t yplus_x = x;
-
-    TERN_(HAS_Y_AXIS, drawBtn(x, y, "Y+", (intptr_t)y_plus, imgUp, Y_BTN_COLOR, !busy));
-
-    x += BTN_WIDTH;
-
-    #if HAS_Y_AXIS
-      motionAxisState.yValuePos.set(x + 2, y);
-      drawAxisValue(Y_AXIS);
-    #endif
-
-    x += spacing;
-
-    #if HAS_Z_AXIS
-      drawBtn(x, y, "Z+", (intptr_t)z_plus, imgUp, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); //only enabled when not busy or have baby step
-    #endif
-
-    // ROW 2 -> "Ex"    X-    HOME X+    "Z"
-    y += BTN_HEIGHT + (TFT_HEIGHT - Y_MARGIN * 2 - 4 * BTN_HEIGHT) / 3;
-    x = X_MARGIN;
-    spacing = (TFT_WIDTH - X_MARGIN * 2 - 5 * BTN_WIDTH) / 4;
-
-    #if HAS_EXTRUDERS
-      motionAxisState.eNamePos.set(x, y);
-      drawCurESelection();
-      TERN_(TOUCH_SCREEN, if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, BTN_HEIGHT, (intptr_t)e_select));
-    #endif
-
-    x += BTN_WIDTH + spacing;
-
-    TERN_(HAS_X_AXIS, drawBtn(x, y, "X-", (intptr_t)x_minus, imgLeft, X_BTN_COLOR, !busy));
-
-    x += BTN_WIDTH + spacing; //imgHome is 64x64
-
-    #if ALL(HAS_X_AXIS, TOUCH_SCREEN)
-      add_control(TFT_WIDTH / 2 - images[imgHome].width / 2, y - (images[imgHome].width - BTN_HEIGHT) / 2, BUTTON, (intptr_t)do_home, imgHome, !busy);
-    #endif
-
-    x += BTN_WIDTH + spacing;
-    const uint16_t xplus_x = x;
-
-    TERN_(HAS_X_AXIS, drawBtn(x, y, "X+", (intptr_t)x_plus, imgRight, X_BTN_COLOR, !busy));
-
-    x += BTN_WIDTH + spacing;
-
-    #if HAS_Z_AXIS
-      motionAxisState.zTypePos.set(x, y);
-      drawCurZSelection();
-    #endif
-
-    #if ALL(HAS_BED_PROBE, TOUCH_SCREEN)
-      if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, 34 * 2, (intptr_t)z_select);
-    #endif
-
-    // ROW 3 -> E- CurX Y-    Z-
-    y += BTN_HEIGHT + (TFT_HEIGHT - Y_MARGIN * 2 - 4 * BTN_HEIGHT) / 3;
-    x = X_MARGIN;
-    spacing = (TFT_WIDTH - X_MARGIN * 2 - 3 * BTN_WIDTH) / 2;
-
-    #if HAS_EXTRUDERS
-      drawBtn(x, y, "E-", (intptr_t)e_minus, imgDown, E_BTN_COLOR, !busy);
-      motionAxisState.eValuePos.set(x, y + BTN_HEIGHT + 2);
-      TERN_(HAS_EXTRUDERS, drawAxisValue(E_AXIS));
-    #endif
-
-    // Cur X
-    #if HAS_X_AXIS
-      motionAxisState.xValuePos.set(BTN_WIDTH + (TFT_WIDTH - X_MARGIN * 2 - 5 * BTN_WIDTH) / 4, y - 10);
-      drawAxisValue(X_AXIS);
-    #endif
-
-    x += BTN_WIDTH + spacing;
-
-    // Cur Y
-    TERN_(HAS_Y_AXIS, drawBtn(x, y, "Y-", (intptr_t)y_minus, imgDown, Y_BTN_COLOR, !busy));
-
-    x += BTN_WIDTH + spacing;
-
-    // Cur Z
-    #if HAS_Z_AXIS
-      drawBtn(x, y, "Z-", (intptr_t)z_minus, imgDown, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); //only enabled when not busy or have baby step
-      motionAxisState.zValuePos.set(x, y + BTN_HEIGHT + 2);
-      drawAxisValue(Z_AXIS);
-    #endif
-
-    // ROW 4 -> step_size    disable steppers back
-    y = TFT_HEIGHT - Y_MARGIN - BTN_HEIGHT;
-    x = xplus_x - CUR_STEP_VALUE_WIDTH - 10;
-    motionAxisState.stepValuePos.set(yplus_x + BTN_WIDTH - CUR_STEP_VALUE_WIDTH, y);
-    if (!busy) {
-      drawCurStepValue();
-      TERN_(TOUCH_SCREEN, touch.add_control(BUTTON, motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y, CUR_STEP_VALUE_WIDTH, BTN_HEIGHT, (intptr_t)step_size));
-    }
-
-    // Aligned with x+
-    drawBtn(xplus_x, y, "off", (intptr_t)disable_steppers, imgCancel, COLOR_WHITE, !busy);
-
-  #endif // !TFT_COLOR_UI_PORTRAIT
-
-  TERN_(TOUCH_SCREEN, add_control(TFT_WIDTH - X_MARGIN - BTN_WIDTH, y, BACK, imgBack));
-}
-
-#endif // HAS_UI_320x240

commit 2218bab542c839f4d1d09640f7c7a1444e38a23b
Author: mjbogusz <mjbogusz@users.noreply.github.com>
Date:   Fri Jun 23 11:56:34 2023 +0200

    üö∏ Color UI remaining time (#24843)

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index c39d226517..dcbfa935b4 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -221,21 +221,21 @@ void draw_fan_status(uint16_t x, uint16_t y, const bool blink) {
   tft_string.trim();
   tft.add_text(tft_string.center(64) + 6, 69 + tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_FAN, tft_string);
 }
 
 void MarlinUI::draw_status_screen() {
   const bool blink = get_blink();
 
   TERN_(TOUCH_SCREEN, touch.clear());
 
   // Statuses of heaters and fans
-  const uint16_t y = TFT_STATUS_TOP_Y;
+  constexpr uint16_t y = TFT_STATUS_TOP_Y;
   for (uint16_t i = 0 ; i < ITEMS_COUNT; i++) {
     const uint16_t x = (TFT_WIDTH / ITEMS_COUNT - 64) / 2  + (TFT_WIDTH * i / ITEMS_COUNT);
     switch (i) {
       #if HAS_EXTRUDERS
         case ITEM_E0: draw_heater_status(x, y, H_E0); break;
       #endif
       #if HAS_MULTI_HOTEND
         case ITEM_E1: draw_heater_status(x, y, H_E1); break;
       #endif
       #if HOTENDS > 2
@@ -271,28 +271,23 @@ void MarlinUI::draw_status_screen() {
       tft_string.add(escale == 10 ? 'c' : 'm');
       tft_string.add('m');
       tft.add_text(127 - tft_string.width(), tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED, tft_string);
     #endif
   }
   else {
     #if HAS_X_AXIS
       tft.add_text(TERN(TFT_COLOR_UI_PORTRAIT, 32, 10), tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED, "X");
       const bool nhx = axis_should_home(X_AXIS);
       tft_string.set(blink && nhx ? "?" : ftostr4sign(LOGICAL_X_POSITION(current_position.x)));
-      tft.add_text(
-        #if ENABLED(TFT_COLOR_UI_PORTRAIT)
-          32 - tft_string.width() / 2, FONT_LINE_HEIGHT + tft_string.vcenter(FONT_LINE_HEIGHT),
-        #else
-          68 - tft_string.width(), tft_string.vcenter(FONT_LINE_HEIGHT),
-        #endif
-        nhx ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string
-      );
+      uint16_t pos_x = TERN(TFT_COLOR_UI_PORTRAIT, 32 - tft_string.width() / 2, 68 - tft_string.width()),
+               pos_y = SUM_TERN(TFT_COLOR_UI_PORTRAIT, tft_string.vcenter(FONT_LINE_HEIGHT), FONT_LINE_HEIGHT);
+      tft.add_text(pos_x, pos_y, nhx ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
     #endif
 
     #if HAS_Y_AXIS
       tft.add_text(TERN(TFT_COLOR_UI_PORTRAIT, 110, 127), tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED, "Y");
       const bool nhy = axis_should_home(Y_AXIS);
       tft_string.set(blink && nhy ? "?" : ftostr4sign(LOGICAL_Y_POSITION(current_position.y)));
       tft.add_text(
         #if ENABLED(TFT_COLOR_UI_PORTRAIT)
           110 - tft_string.width() / 2, FONT_LINE_HEIGHT + tft_string.vcenter(FONT_LINE_HEIGHT),
         #else
@@ -311,149 +306,191 @@ void MarlinUI::draw_status_screen() {
       tft_string.set('?');
     else {
       const float z = LOGICAL_Z_POSITION(current_position.z);
       tft_string.set(ftostr52sp((int16_t)z));
       tft_string.rtrim();
       offset += tft_string.width();
 
       tft_string.set(ftostr52sp(z));
       offset -= tft_string.width();
     }
-    tft.add_text(
-      #if ENABLED(TFT_COLOR_UI_PORTRAIT)
-        192 - tft_string.width() / 2, FONT_LINE_HEIGHT + tft_string.vcenter(FONT_LINE_HEIGHT),
-      #else
-        301 - tft_string.width() - offset, tft_string.vcenter(FONT_LINE_HEIGHT),
-      #endif
-    nhz ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
   #endif
 
-  TERN_(TOUCH_SCREEN, touch.add_control(MOVE_AXIS, 0, 103,
-    #if ENABLED(TFT_COLOR_UI_PORTRAIT)
-      232, FONT_LINE_HEIGHT * 2
-    #else
-      312, FONT_LINE_HEIGHT
-    #endif
-  ));
+  uint16_t pos_x = TERN(TFT_COLOR_UI_PORTRAIT, 192 - tft_string.width() / 2, 301 - tft_string.width() - offset),
+           pos_y = SUM_TERN(TFT_COLOR_UI_PORTRAIT, tft_string.vcenter(FONT_LINE_HEIGHT), FONT_LINE_HEIGHT);
+  tft.add_text(pos_x, pos_y, nhz ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
+
+  // 3rd horizontal group - controls and times (height = 64, top margin = 3)
+  // 3rd group, subgroup A - controls (on the sides)
+  #if ENABLED(TOUCH_SCREEN)
+    width = TERN(TFT_COLOR_UI_PORTRAIT, 232, 312);
+    height = TERN(TFT_COLOR_UI_PORTRAIT, FONT_LINE_HEIGHT * 2, FONT_LINE_HEIGHT);
+    touch.add_control(MOVE_AXIS, 0, 103, width, height);
+    add_control(256, 130, menu_main, imgSettings);
+    TERN_(SDSUPPORT, add_control(0, 130, menu_media, imgSD, !printingIsActive(), COLOR_CONTROL_ENABLED, card.isMounted() && printingIsActive() ? COLOR_BUSY : COLOR_CONTROL_DISABLED));
+  #endif
+
+  // 3rd group, subgroup B - speeds (center, top half)
 
   // Feed rate
   tft.canvas(
-    #if ENABLED(TFT_COLOR_UI_PORTRAIT)
-      30, 172, 80
-    #else
-      70, 136, 84
-    #endif
-    , 32
+    TERN(TFT_COLOR_UI_PORTRAIT,  30,  70),
+    TERN(TFT_COLOR_UI_PORTRAIT, 172, 132),
+    TERN(TFT_COLOR_UI_PORTRAIT,  80,  88),
+    MENU_ITEM_HEIGHT
   );
   tft.set_background(COLOR_BACKGROUND);
   uint16_t color = feedrate_percentage == 100 ? COLOR_RATE_100 : COLOR_RATE_ALTERED;
   tft.add_image(0, 0, imgFeedRate, color);
   tft_string.set(i16tostr3rj(feedrate_percentage));
   tft_string.add('%');
   tft.add_text(32, tft_string.vcenter(30), color, tft_string);
   TERN_(TOUCH_SCREEN, touch.add_control(FEEDRATE,
-    #if ENABLED(TFT_COLOR_UI_PORTRAIT)
-      30, 172, 80
-    #else
-      70, 136, 84
-    #endif
-    , 32
+    TERN(TFT_COLOR_UI_PORTRAIT,  30,  70),
+    TERN(TFT_COLOR_UI_PORTRAIT, 172, 132),
+    80, MENU_ITEM_HEIGHT
   ));
 
   // Flow rate
-  #if HAS_EXTRUDERS
-    tft.canvas(
-      #if ENABLED(TFT_COLOR_UI_PORTRAIT)
-        140, 172, 80
-      #else
-        170, 136, 84
+  tft.canvas(
+    TERN(TFT_COLOR_UI_PORTRAIT, 140, 162),
+    TERN(TFT_COLOR_UI_PORTRAIT, 172, 132),
+    TERN(TFT_COLOR_UI_PORTRAIT,  80,  88),
+    MENU_ITEM_HEIGHT
+  );
+  tft.set_background(COLOR_BACKGROUND);
+  color = planner.flow_percentage[0] == 100 ? COLOR_RATE_100 : COLOR_RATE_ALTERED;
+  tft.add_image(0, 0, imgFlowRate, color);
+  tft_string.set(i16tostr3rj(planner.flow_percentage[active_extruder]));
+  tft_string.add('%');
+  tft.add_text(32, tft_string.vcenter(30), color, tft_string);
+  #if ENABLED(TOUCH_SCREEN)
+    touch.add_control(FLOWRATE,
+      TERN(TFT_COLOR_UI_PORTRAIT, 140, 170),
+      TERN(TFT_COLOR_UI_PORTRAIT, 172, 132),
+      80, MENU_ITEM_HEIGHT, active_extruder
+    );
+  #endif
+
+  // 3rd group, subgroup C - times (center, bottom half)
+  const progress_t progress = TERN(HAS_PRINT_PROGRESS_PERMYRIAD, get_progress_permyriad, get_progress_percent)();
+  const uint16_t time_str_width = 180, image_width = 34;
+  pos_x = (TFT_WIDTH - time_str_width) / 2;
+  pos_y = TERN(TFT_COLOR_UI_PORTRAIT, 256, 164);
+  #if ENABLED(SHOW_ELAPSED_TIME) && DISABLED(SHOW_REMAINING_TIME)
+    // Print duration so far (time elapsed) - centered
+    char elapsed_str[18];
+    duration_t elapsed = print_job_timer.duration();
+    elapsed.toCompactString(elapsed_str);
+
+    tft.canvas(pos_x, pos_y, time_str_width, MENU_ITEM_HEIGHT);
+    tft.set_background(COLOR_BACKGROUND);
+    tft_string.set(elapsed_str);
+    uint16_t text_pos_x = tft_string.center(time_str_width - image_width);
+    tft.add_image(text_pos_x, 0, imgTimeElapsed, COLOR_PRINT_TIME);
+    tft.add_text(text_pos_x + image_width, tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_PRINT_TIME, tft_string);
+
+  #elif DISABLED(SHOW_ELAPSED_TIME) && ENABLED(SHOW_REMAINING_TIME)
+    // Print time remaining estimation - centered
+    char estimate_str[18];
+    duration_t elapsed = print_job_timer.duration();
+
+    // Get the estimate, first from M73
+    uint32_t estimate_remaining = (0
+      #if ALL(SET_PROGRESS_MANUALLY, SET_REMAINING_TIME)
+        + get_remaining_time()
       #endif
-      , 32
     );
+    // If no M73 estimate is available but we have progress data, calculate time remaining assuming time elapsed is linear with progress
+    if (!estimate_remaining && progress > 0)
+      estimate_remaining = elapsed.value * (100 * (PROGRESS_SCALE) - progress) / progress;
+
+    // Generate estimate string
+    if (!estimate_remaining)
+      tft_string.set("-");
+    else {
+      duration_t estimation = estimate_remaining;
+      estimation.toCompactString(estimate_str);
+      tft_string.set(estimate_str);
+    }
+
+    tft.canvas(pos_x, pos_y, time_str_width, MENU_ITEM_HEIGHT);
     tft.set_background(COLOR_BACKGROUND);
-    color = planner.flow_percentage[0] == 100 ? COLOR_RATE_100 : COLOR_RATE_ALTERED;
-    tft.add_image(0, 0, imgFlowRate, color);
-    tft_string.set(i16tostr3rj(planner.flow_percentage[active_extruder]));
-    tft_string.add('%');
-    tft.add_text(32, tft_string.vcenter(30), color, tft_string);
-    TERN_(TOUCH_SCREEN, touch.add_control(FLOWRATE,
-      #if ENABLED(TFT_COLOR_UI_PORTRAIT)
-        140, 172, 80
-      #else
-        170, 136, 84
+    color = printingIsActive() ? COLOR_PRINT_TIME : COLOR_INACTIVE;
+    uint16_t text_pos_x = tft_string.center(time_str_width - image_width);
+    tft.add_image(text_pos_x, 0, imgTimeRemaining, color);
+    tft.add_text(text_pos_x + image_width, tft_string.vcenter(FONT_LINE_HEIGHT), color, tft_string);
+
+  #elif ALL(SHOW_REMAINING_TIME, SHOW_ELAPSED_TIME)
+    // Print duration so far (time elapsed) - aligned under feed rate
+    char elapsed_str[18];
+    duration_t elapsed = print_job_timer.duration();
+    elapsed.toCompactString(elapsed_str);
+
+    tft.canvas(pos_x, pos_y, time_str_width / 2 - 2, MENU_ITEM_HEIGHT);
+    tft.set_background(COLOR_BACKGROUND);
+    tft.add_image(0, 0, imgTimeElapsed, COLOR_PRINT_TIME);
+    tft_string.set(elapsed_str);
+    tft.add_text(32, tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_PRINT_TIME, tft_string);
+
+    // Print time remaining estimation - aligned under flow rate
+    char estimate_str[18];
+
+    // Get the estimate, first from M73
+    uint32_t estimate_remaining = (0
+      #if ALL(SET_PROGRESS_MANUALLY, SET_REMAINING_TIME)
+        + get_remaining_time()
       #endif
-      , 32, active_extruder
-    ));
-  #endif // HAS_EXTRUDERS
+    );
+    // If no M73 estimate is available but we have progress data, calculate time remaining assuming time elapsed is linear with progress
+    if (!estimate_remaining && progress > 0)
+      estimate_remaining = elapsed.value * (100 * (PROGRESS_SCALE) - progress) / progress;
 
-  // Print duration
-  char buffer[14];
-  duration_t elapsed = print_job_timer.duration();
-  elapsed.toDigital(buffer);
+    // Generate estimate string
+    if (!estimate_remaining)
+      tft_string.set("-");
+    else {
+      duration_t estimation = estimate_remaining;
+      estimation.toCompactString(estimate_str);
+      tft_string.set(estimate_str);
+    }
 
-  tft.canvas(
-    #if ENABLED(TFT_COLOR_UI_PORTRAIT)
-      56, 256, 128
-    #else
-      96, 173, 128
-    #endif
-    , FONT_LINE_HEIGHT
-  );
-  tft.set_background(COLOR_BACKGROUND);
-  tft_string.set(buffer);
-  tft.add_text(tft_string.center(128), tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_PRINT_TIME, tft_string);
+    // Push out the estimate to the screen
+    tft.canvas(pos_x + time_str_width / 2 + 2, pos_y, time_str_width / 2 - 2, MENU_ITEM_HEIGHT);
+    tft.set_background(COLOR_BACKGROUND);
+    color = printingIsActive() ? COLOR_PRINT_TIME : COLOR_INACTIVE;
+    tft.add_image(0, 0, imgTimeRemaining, color);
+    tft.add_text(32, tft_string.vcenter(FONT_LINE_HEIGHT), color, tft_string);
+  #endif
 
-  // Progress bar
-  const uint8_t progress = ui.get_progress_percent();
-  tft.canvas(
-    #if ENABLED(TFT_COLOR_UI_PORTRAIT)
-      4, 278, 232
-    #else
-      4, 198, 312
-    #endif
-    , 9
-  );
+  // Fourth horizontal group - progress bar (height = 9, top margin = 4)
+  pos_y = TERN(TFT_COLOR_UI_PORTRAIT, 278, 198);
+  tft.canvas(4, pos_y, TFT_WIDTH - 8, 9);
   tft.set_background(COLOR_PROGRESS_BG);
-  tft.add_rectangle(0, 0,
-    #if ENABLED(TFT_COLOR_UI_PORTRAIT)
-      232, 9
-    #else
-      312, 9
-    #endif
-    , COLOR_PROGRESS_FRAME
-  );
+  tft.add_rectangle(0, 0, TFT_WIDTH - 8, 9, COLOR_PROGRESS_FRAME);
   if (progress)
-    tft.add_bar(1, 1, ((TFT_WIDTH - 10) * progress) / 100, 7, COLOR_PROGRESS_BAR);
+    tft.add_bar(1, 1, ((TFT_WIDTH - 10) * progress / (PROGRESS_SCALE)) / 100, 7, COLOR_PROGRESS_BAR);
 
   // Status message
-  tft.canvas(
-    #if ENABLED(TFT_COLOR_UI_PORTRAIT)
-      0, 296, 240
-    #else
-      0, 212, 320
-    #endif
-    , FONT_LINE_HEIGHT
-  );
+  pos_y += 9 + 7;
+  tft.canvas(0, pos_y, TFT_WIDTH, TFT_HEIGHT - pos_y);
   tft.set_background(COLOR_BACKGROUND);
   tft_string.set(status_message);
   tft_string.trim();
   tft.add_text(tft_string.center(TFT_WIDTH), tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_STATUS_MESSAGE, tft_string);
 
   #if ENABLED(TOUCH_SCREEN)
   {
     add_control(
-      #if ENABLED(TFT_COLOR_UI_PORTRAIT)
-        176, 210
-      #else
-        256, 130
-      #endif
-      , menu_main, imgSettings
+      TERN(TFT_COLOR_UI_PORTRAIT, 176, 256),
+      TERN(TFT_COLOR_UI_PORTRAIT, 210, 130),
+      menu_main, imgSettings
     );
     #if HAS_MEDIA
       const bool cm = card.isMounted(), pa = printingIsActive();
       if (cm && pa)
         add_control(0, TERN(TFT_COLOR_UI_PORTRAIT, 210, 130), STOP, imgCancel, true, COLOR_CONTROL_CANCEL);
       else
         add_control(0, TERN(TFT_COLOR_UI_PORTRAIT, 210, 130), menu_media, imgSD, cm && !pa, COLOR_CONTROL_ENABLED, COLOR_CONTROL_DISABLED);
     #endif
   }
   #endif // TOUCH_SCREEN
@@ -545,22 +582,22 @@ void MenuItem_confirm::draw_select_screen(FSTR_P const yes, FSTR_P const no, con
     tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
   }
 
   if (suff) {
     menu_line(line);
     tft_string.set(suff);
     tft_string.trim();
     tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
   }
   #if ENABLED(TOUCH_SCREEN)
-    if (no)  add_control(TERN(TFT_COLOR_UI_PORTRAIT, 16, 48), TFT_HEIGHT - 64, CANCEL,  imgCancel,  true, yesno ? HALF(COLOR_CONTROL_CANCEL) : COLOR_CONTROL_CANCEL);
-    if (yes) add_control(TERN(TFT_COLOR_UI_PORTRAIT, 160, 208), TFT_HEIGHT - 64, CONFIRM, imgConfirm, true, yesno ? COLOR_CONTROL_CONFIRM : HALF(COLOR_CONTROL_CONFIRM));
+    if (no)  add_control(TERN(TFT_COLOR_UI_PORTRAIT, 32,48), TFT_HEIGHT - 64, CANCEL, imgCancel, true, yesno ? HALF(COLOR_CONTROL_CANCEL) : COLOR_CONTROL_CANCEL);
+    if (yes) add_control(TERN(TFT_COLOR_UI_PORTRAIT, 172, 208), TFT_HEIGHT - 64, CONFIRM, imgConfirm, true, yesno ? COLOR_CONTROL_CONFIRM : HALF(COLOR_CONTROL_CONFIRM));
   #endif
 }
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
 
   void MarlinUI::draw_hotend_status(const uint8_t row, const uint8_t extruder) {
     #if ENABLED(TOUCH_SCREEN)
       touch.clear();
       draw_menu_navigation = false;
       touch.add_control(RESUME_CONTINUE, 0, 0, TFT_WIDTH, TFT_HEIGHT);

commit 1fbeac7b5255634bb5aca209a3d3dcb6b5e43193
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 23 00:15:54 2023 -0500

    üé® Adjust TFT code/comments

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index 8409b550a1..c39d226517 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -220,25 +220,24 @@ void draw_fan_status(uint16_t x, uint16_t y, const bool blink) {
   tft_string.set(ui8tostr4pctrj(thermalManager.fan_speed[0]));
   tft_string.trim();
   tft.add_text(tft_string.center(64) + 6, 69 + tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_FAN, tft_string);
 }
 
 void MarlinUI::draw_status_screen() {
   const bool blink = get_blink();
 
   TERN_(TOUCH_SCREEN, touch.clear());
 
-  // heaters and fan
-  uint16_t i, x, y = TFT_STATUS_TOP_Y;
-
-  for (i = 0 ; i < ITEMS_COUNT; i++) {
-    x = (TFT_WIDTH / ITEMS_COUNT - 64) / 2  + (TFT_WIDTH * i / ITEMS_COUNT);
+  // Statuses of heaters and fans
+  const uint16_t y = TFT_STATUS_TOP_Y;
+  for (uint16_t i = 0 ; i < ITEMS_COUNT; i++) {
+    const uint16_t x = (TFT_WIDTH / ITEMS_COUNT - 64) / 2  + (TFT_WIDTH * i / ITEMS_COUNT);
     switch (i) {
       #if HAS_EXTRUDERS
         case ITEM_E0: draw_heater_status(x, y, H_E0); break;
       #endif
       #if HAS_MULTI_HOTEND
         case ITEM_E1: draw_heater_status(x, y, H_E1); break;
       #endif
       #if HOTENDS > 2
         case ITEM_E2: draw_heater_status(x, y, H_E2); break;
       #endif
@@ -250,41 +249,30 @@ void MarlinUI::draw_status_screen() {
       #endif
       #if HAS_TEMP_COOLER
         case ITEM_COOLER: draw_heater_status(x, y, H_COOLER); break;
       #endif
       #if HAS_FAN
         case ITEM_FAN: draw_fan_status(x, y, blink); break;
       #endif
     }
   }
 
-  // coordinates
-  tft.canvas(4, 103,
-    #if ENABLED(TFT_COLOR_UI_PORTRAIT)
-      232, FONT_LINE_HEIGHT * 2
-    #else
-      312, FONT_LINE_HEIGHT
-    #endif
-  );
+  // 2nd horizontal group - current coordinates (height = 24, top margin = 3)
+  uint16_t width = TERN(TFT_COLOR_UI_PORTRAIT, 232, 312),
+          height = FONT_LINE_HEIGHT * TERN(TFT_COLOR_UI_PORTRAIT, 2, 1);
+  tft.canvas(4, 103, width, height);
   tft.set_background(COLOR_BACKGROUND);
-  tft.add_rectangle(0, 0,
-    #if ENABLED(TFT_COLOR_UI_PORTRAIT)
-      232, FONT_LINE_HEIGHT * 2
-    #else
-      312, FONT_LINE_HEIGHT
-    #endif
-    , COLOR_AXIS_HOMED
-  );
+  tft.add_rectangle(0, 0, width, height, COLOR_AXIS_HOMED);
 
   if (TERN0(LCD_SHOW_E_TOTAL, printingIsActive())) {
     #if ENABLED(LCD_SHOW_E_TOTAL)
-      tft.add_text( 10, tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED, "E");
+      tft.add_text(10, tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED, "E");
       const uint8_t escale = e_move_accumulator >= 100000.0f ? 10 : 1; // After 100m switch to cm
       tft_string.set(ftostr4sign(e_move_accumulator / escale));
       tft_string.add(escale == 10 ? 'c' : 'm');
       tft_string.add('m');
       tft.add_text(127 - tft_string.width(), tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED, tft_string);
     #endif
   }
   else {
     #if HAS_X_AXIS
       tft.add_text(TERN(TFT_COLOR_UI_PORTRAIT, 32, 10), tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED, "X");
@@ -340,21 +328,21 @@ void MarlinUI::draw_status_screen() {
   #endif
 
   TERN_(TOUCH_SCREEN, touch.add_control(MOVE_AXIS, 0, 103,
     #if ENABLED(TFT_COLOR_UI_PORTRAIT)
       232, FONT_LINE_HEIGHT * 2
     #else
       312, FONT_LINE_HEIGHT
     #endif
   ));
 
-  // feed rate
+  // Feed rate
   tft.canvas(
     #if ENABLED(TFT_COLOR_UI_PORTRAIT)
       30, 172, 80
     #else
       70, 136, 84
     #endif
     , 32
   );
   tft.set_background(COLOR_BACKGROUND);
   uint16_t color = feedrate_percentage == 100 ? COLOR_RATE_100 : COLOR_RATE_ALTERED;
@@ -390,38 +378,38 @@ void MarlinUI::draw_status_screen() {
     TERN_(TOUCH_SCREEN, touch.add_control(FLOWRATE,
       #if ENABLED(TFT_COLOR_UI_PORTRAIT)
         140, 172, 80
       #else
         170, 136, 84
       #endif
       , 32, active_extruder
     ));
   #endif // HAS_EXTRUDERS
 
-  // print duration
+  // Print duration
   char buffer[14];
   duration_t elapsed = print_job_timer.duration();
   elapsed.toDigital(buffer);
 
   tft.canvas(
     #if ENABLED(TFT_COLOR_UI_PORTRAIT)
       56, 256, 128
     #else
       96, 173, 128
     #endif
     , FONT_LINE_HEIGHT
   );
   tft.set_background(COLOR_BACKGROUND);
   tft_string.set(buffer);
   tft.add_text(tft_string.center(128), tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_PRINT_TIME, tft_string);
 
-  // progress bar
+  // Progress bar
   const uint8_t progress = ui.get_progress_percent();
   tft.canvas(
     #if ENABLED(TFT_COLOR_UI_PORTRAIT)
       4, 278, 232
     #else
       4, 198, 312
     #endif
     , 9
   );
   tft.set_background(COLOR_PROGRESS_BG);
@@ -429,21 +417,21 @@ void MarlinUI::draw_status_screen() {
     #if ENABLED(TFT_COLOR_UI_PORTRAIT)
       232, 9
     #else
       312, 9
     #endif
     , COLOR_PROGRESS_FRAME
   );
   if (progress)
     tft.add_bar(1, 1, ((TFT_WIDTH - 10) * progress) / 100, 7, COLOR_PROGRESS_BAR);
 
-  // status message
+  // Status message
   tft.canvas(
     #if ENABLED(TFT_COLOR_UI_PORTRAIT)
       0, 296, 240
     #else
       0, 212, 320
     #endif
     , FONT_LINE_HEIGHT
   );
   tft.set_background(COLOR_BACKGROUND);
   tft_string.set(status_message);
@@ -821,43 +809,42 @@ static void moveAxis(const AxisEnum axis, const int8_t direction) {
                     new_offs = TERN(BABYSTEP_HOTEND_Z_OFFSET
                       , do_probe ? new_probe_offset : hotend_offset[active_extruder].z - bsDiff
                       , new_probe_offset
                     );
         if (WITHIN(new_offs, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
           babystep.add_steps(Z_AXIS, babystep_increment);
           if (do_probe)
             probe.offset.z = new_offs;
           else
             TERN(BABYSTEP_HOTEND_Z_OFFSET, hotend_offset[active_extruder].z = new_offs, NOOP);
-          drawMessage(NUL_STR); // clear the error
+          drawMessage(NUL_STR); // Clear the error
           drawAxisValue(axis);
         }
         else
           drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
 
       #else
-        // only change probe.offset.z
+        // Only change probe.offset.z
         probe.offset.z += diff;
-        if (direction < 0 && current_position[axis] < Z_PROBE_OFFSET_RANGE_MIN) {
-          current_position[axis] = Z_PROBE_OFFSET_RANGE_MIN;
+        if (direction < 0 && current_position.z < Z_PROBE_OFFSET_RANGE_MIN) {
+          current_position.z = Z_PROBE_OFFSET_RANGE_MIN;
           drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
         }
-        else if (direction > 0 && current_position[axis] > Z_PROBE_OFFSET_RANGE_MAX) {
-          current_position[axis] = Z_PROBE_OFFSET_RANGE_MAX;
+        else if (direction > 0 && current_position.z > Z_PROBE_OFFSET_RANGE_MAX) {
+          current_position.z = Z_PROBE_OFFSET_RANGE_MAX;
           drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
         }
         else
-          drawMessage(NUL_STR); // clear the error
+          drawMessage(NUL_STR); // Clear the error
 
         drawAxisValue(axis);
       #endif
-      return;
     }
 
   #endif // HAS_BED_PROBE
 
   if (!ui.manual_move.processing) {
     // Get motion limit from software endstops, if any
     float min, max;
     soft_endstop.get_manual_axis_limits(axis, min, max);
 
     // Delta limits XY based on the current offset from center
@@ -940,23 +927,23 @@ static void moveAxis(const AxisEnum axis, const int8_t direction) {
     }
   #endif
 
 #endif // TOUCH_SCREEN
 
 static void disable_steppers() {
   quick_feedback();
   queue.inject(F("M84"));
 }
 
-static void drawBtn(int x, int y, const char *label, intptr_t data, MarlinImage img, uint16_t bgColor, bool enabled = true) {
-  const uint16_t width = Images[imgBtn39Rounded].width,
-                height = Images[imgBtn39Rounded].height;
+static void drawBtn(const int x, const int y, const char *label, intptr_t data, const MarlinImage img, uint16_t bgColor, const bool enabled=true) {
+  const uint16_t width = images[imgBtn39Rounded].width,
+                height = images[imgBtn39Rounded].height;
 
   if (!enabled) bgColor = COLOR_CONTROL_DISABLED;
 
   tft.canvas(x, y, width, height);
   tft.set_background(COLOR_BACKGROUND);
   tft.add_image(0, 0, imgBtn39Rounded, bgColor, COLOR_BACKGROUND, COLOR_DARKGREY);
 
   // TODO: Make an add_text() taking a font arg
   if (label) {
     tft_string.set(label);
@@ -996,21 +983,21 @@ void MarlinUI::move_axis_screen() {
     spacing = (TFT_WIDTH - X_MARGIN * 2 - 3 * BTN_WIDTH) / 2;
     x += BTN_WIDTH + spacing;
     uint16_t yplus_x = x;
 
     TERN_(HAS_Y_AXIS, drawBtn(x, y, "Y+", (intptr_t)y_plus, imgUp, Y_BTN_COLOR, !busy));
 
     x += BTN_WIDTH + spacing;
     uint16_t zplus_x = x;
 
     #if HAS_Z_AXIS
-      drawBtn(x, y, "Z+", (intptr_t)z_plus, imgUp, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); //only enabled when not busy or have baby step
+      drawBtn(x, y, "Z+", (intptr_t)z_plus, imgUp, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); // Only enabled when not busy or have baby step
     #endif
 
     // ROW 2 -> "Ex" CurY "Z"
     x = X_MARGIN;
     y += BTN_HEIGHT + 2;
 
     #if HAS_EXTRUDERS
       motionAxisState.eNamePos.set(x, y);
       drawCurESelection();
       TERN_(TOUCH_SCREEN, if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, BTN_HEIGHT, (intptr_t)e_select));
@@ -1025,21 +1012,21 @@ void MarlinUI::move_axis_screen() {
       motionAxisState.zTypePos.set(zplus_x, y);
       drawCurZSelection();
     #endif
 
     // ROW 3 -> X-    HOME    X+
     y += (TFT_HEIGHT - Y_MARGIN * 2 - 4 * BTN_HEIGHT) / 3 - 2;
     x = X_MARGIN;
 
     #if HAS_X_AXIS
       drawBtn(x, y, "X-", (intptr_t)x_minus, imgLeft, X_BTN_COLOR, !busy);
-      TERN_(TOUCH_SCREEN, add_control(TFT_WIDTH / 2 - Images[imgHome].width / 2, y - (Images[imgHome].width - BTN_HEIGHT) / 2, BUTTON, (intptr_t)do_home, imgHome, !busy));
+      TERN_(TOUCH_SCREEN, add_control(TFT_WIDTH / 2 - images[imgHome].width / 2, y - (images[imgHome].width - BTN_HEIGHT) / 2, BUTTON, (intptr_t)do_home, imgHome, !busy));
       drawBtn(zplus_x, y, "X+", (intptr_t)x_plus, imgRight, X_BTN_COLOR, !busy);
     #endif
 
     #if ALL(HAS_BED_PROBE, TOUCH_SCREEN)
       if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, 34 * 2, (intptr_t)z_select);
     #endif
 
     // ROW 4 -> Cur X
     y += BTN_HEIGHT + 2;
 
@@ -1073,21 +1060,21 @@ void MarlinUI::move_axis_screen() {
     // ROW 6 -> step_size    disable steppers back
     y = TFT_HEIGHT - Y_MARGIN - BTN_HEIGHT;
     x = zplus_x - CUR_STEP_VALUE_WIDTH - 10;
     motionAxisState.stepValuePos.set(X_MARGIN + BTN_WIDTH - CUR_STEP_VALUE_WIDTH, y);
 
     if (!busy) {
       drawCurStepValue();
       TERN_(TOUCH_SCREEN, touch.add_control(BUTTON, motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y, CUR_STEP_VALUE_WIDTH, BTN_HEIGHT, (intptr_t)step_size));
     }
 
-    // aligned with x+
+    // Aligned with x+
     drawBtn(yplus_x, y, "off", (intptr_t)disable_steppers, imgCancel, COLOR_WHITE, !busy);
 
   #else // !TFT_COLOR_UI_PORTRAIT
 
     // ROW 1 -> E+ Y+ CurY Z+
     int x = X_MARGIN, y = Y_MARGIN, spacing = 0;
 
     TERN_(HAS_EXTRUDERS, drawBtn(x, y, "E+", (intptr_t)e_plus, imgUp, E_BTN_COLOR, !busy));
 
     spacing = (TFT_WIDTH - X_MARGIN * 2 - 3 * BTN_WIDTH) / 2;
@@ -1120,25 +1107,25 @@ void MarlinUI::move_axis_screen() {
       TERN_(TOUCH_SCREEN, if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, BTN_HEIGHT, (intptr_t)e_select));
     #endif
 
     x += BTN_WIDTH + spacing;
 
     TERN_(HAS_X_AXIS, drawBtn(x, y, "X-", (intptr_t)x_minus, imgLeft, X_BTN_COLOR, !busy));
 
     x += BTN_WIDTH + spacing; //imgHome is 64x64
 
     #if ALL(HAS_X_AXIS, TOUCH_SCREEN)
-      add_control(TFT_WIDTH / 2 - Images[imgHome].width / 2, y - (Images[imgHome].width - BTN_HEIGHT) / 2, BUTTON, (intptr_t)do_home, imgHome, !busy);
+      add_control(TFT_WIDTH / 2 - images[imgHome].width / 2, y - (images[imgHome].width - BTN_HEIGHT) / 2, BUTTON, (intptr_t)do_home, imgHome, !busy);
     #endif
 
     x += BTN_WIDTH + spacing;
-    uint16_t xplus_x = x;
+    const uint16_t xplus_x = x;
 
     TERN_(HAS_X_AXIS, drawBtn(x, y, "X+", (intptr_t)x_plus, imgRight, X_BTN_COLOR, !busy));
 
     x += BTN_WIDTH + spacing;
 
     #if HAS_Z_AXIS
       motionAxisState.zTypePos.set(x, y);
       drawCurZSelection();
     #endif
 
@@ -1150,48 +1137,48 @@ void MarlinUI::move_axis_screen() {
     y += BTN_HEIGHT + (TFT_HEIGHT - Y_MARGIN * 2 - 4 * BTN_HEIGHT) / 3;
     x = X_MARGIN;
     spacing = (TFT_WIDTH - X_MARGIN * 2 - 3 * BTN_WIDTH) / 2;
 
     #if HAS_EXTRUDERS
       drawBtn(x, y, "E-", (intptr_t)e_minus, imgDown, E_BTN_COLOR, !busy);
       motionAxisState.eValuePos.set(x, y + BTN_HEIGHT + 2);
       TERN_(HAS_EXTRUDERS, drawAxisValue(E_AXIS));
     #endif
 
+    // Cur X
     #if HAS_X_AXIS
       motionAxisState.xValuePos.set(BTN_WIDTH + (TFT_WIDTH - X_MARGIN * 2 - 5 * BTN_WIDTH) / 4, y - 10);
       drawAxisValue(X_AXIS);
     #endif
 
     x += BTN_WIDTH + spacing;
 
+    // Cur Y
     TERN_(HAS_Y_AXIS, drawBtn(x, y, "Y-", (intptr_t)y_minus, imgDown, Y_BTN_COLOR, !busy));
 
     x += BTN_WIDTH + spacing;
 
+    // Cur Z
     #if HAS_Z_AXIS
       drawBtn(x, y, "Z-", (intptr_t)z_minus, imgDown, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); //only enabled when not busy or have baby step
-    #endif
-
-    #if HAS_Z_AXIS
       motionAxisState.zValuePos.set(x, y + BTN_HEIGHT + 2);
       drawAxisValue(Z_AXIS);
     #endif
 
     // ROW 4 -> step_size    disable steppers back
     y = TFT_HEIGHT - Y_MARGIN - BTN_HEIGHT;
     x = xplus_x - CUR_STEP_VALUE_WIDTH - 10;
     motionAxisState.stepValuePos.set(yplus_x + BTN_WIDTH - CUR_STEP_VALUE_WIDTH, y);
     if (!busy) {
       drawCurStepValue();
       TERN_(TOUCH_SCREEN, touch.add_control(BUTTON, motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y, CUR_STEP_VALUE_WIDTH, BTN_HEIGHT, (intptr_t)step_size));
     }
 
-    // aligned with x+
+    // Aligned with x+
     drawBtn(xplus_x, y, "off", (intptr_t)disable_steppers, imgCancel, COLOR_WHITE, !busy);
 
   #endif // !TFT_COLOR_UI_PORTRAIT
 
   TERN_(TOUCH_SCREEN, add_control(TFT_WIDTH - X_MARGIN - BTN_WIDTH, y, BACK, imgBack));
 }
 
 #endif // HAS_UI_320x240

commit c3694f1c038fa20ad749118b0a1c7aa88e3dd5f2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jun 14 17:24:50 2023 -0500

    üé® Lowercase methods, functions, data members (#25939)
    
    For: TFT, DGUS, MarlinUI, Anycubic, JyersUI, CrealityUI

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index 772d7d9590..8409b550a1 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -113,98 +113,97 @@ void MarlinUI::draw_kill_screen() {
 
   tft.canvas(0, 160, TFT_WIDTH, FONT_LINE_HEIGHT);
   tft.set_background(COLOR_KILL_SCREEN_BG);
   tft_string.set(GET_TEXT(MSG_PLEASE_RESET));
   tft_string.trim();
   tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_KILL_SCREEN_TEXT, tft_string);
 
   tft.queue.sync();
 }
 
-void draw_heater_status(uint16_t x, uint16_t y, const int8_t Heater) {
+void draw_heater_status(uint16_t x, uint16_t y, const int8_t heater) {
   MarlinImage image = imgHotEnd;
-  uint16_t Color;
   celsius_t currentTemperature, targetTemperature;
 
-  if (Heater >= 0) { // HotEnd
+  if (heater >= 0) { // HotEnd
     #if HAS_EXTRUDERS
-      currentTemperature = thermalManager.wholeDegHotend(Heater);
-      targetTemperature = thermalManager.degTargetHotend(Heater);
+      currentTemperature = thermalManager.wholeDegHotend(heater);
+      targetTemperature = thermalManager.degTargetHotend(heater);
     #else
       return;
     #endif
   }
   #if HAS_HEATED_BED
-    else if (Heater == H_BED) {
+    else if (heater == H_BED) {
       currentTemperature = thermalManager.wholeDegBed();
       targetTemperature = thermalManager.degTargetBed();
     }
   #endif
   #if HAS_TEMP_CHAMBER
-    else if (Heater == H_CHAMBER) {
+    else if (heater == H_CHAMBER) {
       currentTemperature = thermalManager.wholeDegChamber();
       #if HAS_HEATED_CHAMBER
         targetTemperature = thermalManager.degTargetChamber();
       #else
         targetTemperature = ABSOLUTE_ZERO;
       #endif
     }
   #endif
   #if HAS_TEMP_COOLER
-    else if (Heater == H_COOLER) {
+    else if (heater == H_COOLER) {
       currentTemperature = thermalManager.wholeDegCooler();
       targetTemperature = TERN(HAS_COOLER, thermalManager.degTargetCooler(), ABSOLUTE_ZERO);
     }
   #endif
   else return;
 
-  TERN_(TOUCH_SCREEN, if (targetTemperature >= 0) touch.add_control(HEATER, x, y, 64, 100, Heater));
+  TERN_(TOUCH_SCREEN, if (targetTemperature >= 0) touch.add_control(HEATER, x, y, 64, 100, heater));
   tft.canvas(x, y, 64, 100);
   tft.set_background(COLOR_BACKGROUND);
 
-  Color = currentTemperature < 0 ? COLOR_INACTIVE : COLOR_COLD;
+  uint16_t color = currentTemperature < 0 ? COLOR_INACTIVE : COLOR_COLD;
 
-  if (Heater >= 0) { // HotEnd
-    if (currentTemperature >= 50) Color = COLOR_HOTEND;
+  if (heater >= 0) { // HotEnd
+    if (currentTemperature >= 50) color = COLOR_HOTEND;
   }
   #if HAS_HEATED_BED
-    else if (Heater == H_BED) {
-      if (currentTemperature >= 50) Color = COLOR_HEATED_BED;
+    else if (heater == H_BED) {
+      if (currentTemperature >= 50) color = COLOR_HEATED_BED;
       image = targetTemperature > 0 ? imgBedHeated : imgBed;
     }
   #endif
   #if HAS_TEMP_CHAMBER
-    else if (Heater == H_CHAMBER) {
-      if (currentTemperature >= 50) Color = COLOR_CHAMBER;
+    else if (heater == H_CHAMBER) {
+      if (currentTemperature >= 50) color = COLOR_CHAMBER;
       image = targetTemperature > 0 ? imgChamberHeated : imgChamber;
     }
   #endif
   #if HAS_TEMP_COOLER
-    else if (Heater == H_COOLER) {
-      if (currentTemperature <= 26) Color = COLOR_COLD;
-      if (currentTemperature > 26) Color = COLOR_RED;
+    else if (heater == H_COOLER) {
+      if (currentTemperature <= 26) color = COLOR_COLD;
+      if (currentTemperature > 26) color = COLOR_RED;
       image = targetTemperature > 26 ? imgCoolerHot : imgCooler;
     }
   #endif
 
-  tft.add_image(0, 18, image, Color);
+  tft.add_image(0, 18, image, color);
 
   tft_string.set(i16tostr3rj(currentTemperature));
   tft_string.add(LCD_STR_DEGREE);
   tft_string.trim();
-  tft.add_text(tft_string.center(64) + 2, 69 + tft_string.vcenter(FONT_LINE_HEIGHT), Color, tft_string);
+  tft.add_text(tft_string.center(64) + 2, 69 + tft_string.vcenter(FONT_LINE_HEIGHT), color, tft_string);
 
   if (targetTemperature >= 0) {
     tft_string.set(i16tostr3rj(targetTemperature));
     tft_string.add(LCD_STR_DEGREE);
     tft_string.trim();
-    tft.add_text(tft_string.center(64) + 2, 5 + tft_string.vcenter(FONT_LINE_HEIGHT), Color, tft_string);
+    tft.add_text(tft_string.center(64) + 2, 5 + tft_string.vcenter(FONT_LINE_HEIGHT), color, tft_string);
   }
 }
 
 void draw_fan_status(uint16_t x, uint16_t y, const bool blink) {
   TERN_(TOUCH_SCREEN, touch.add_control(FAN, x, y, 64, 100));
   tft.canvas(x, y, 64, 100);
   tft.set_background(COLOR_BACKGROUND);
 
   uint8_t fanSpeed = thermalManager.fan_speed[0];
   MarlinImage image;

commit 9360e13cdd1e21799eb3aedcd23015469da6798d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jun 7 22:37:16 2023 -0500

    üö∏ General TFT cleanup

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index 0d145f10eb..772d7d9590 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -271,60 +271,60 @@ void MarlinUI::draw_status_screen() {
     #if ENABLED(TFT_COLOR_UI_PORTRAIT)
       232, FONT_LINE_HEIGHT * 2
     #else
       312, FONT_LINE_HEIGHT
     #endif
     , COLOR_AXIS_HOMED
   );
 
   if (TERN0(LCD_SHOW_E_TOTAL, printingIsActive())) {
     #if ENABLED(LCD_SHOW_E_TOTAL)
-      tft.add_text( 10, tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED , "E");
+      tft.add_text( 10, tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED, "E");
       const uint8_t escale = e_move_accumulator >= 100000.0f ? 10 : 1; // After 100m switch to cm
       tft_string.set(ftostr4sign(e_move_accumulator / escale));
       tft_string.add(escale == 10 ? 'c' : 'm');
       tft_string.add('m');
       tft.add_text(127 - tft_string.width(), tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED, tft_string);
     #endif
   }
   else {
     #if HAS_X_AXIS
-      tft.add_text(TERN(TFT_COLOR_UI_PORTRAIT, 32, 10), tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED , "X");
+      tft.add_text(TERN(TFT_COLOR_UI_PORTRAIT, 32, 10), tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED, "X");
       const bool nhx = axis_should_home(X_AXIS);
       tft_string.set(blink && nhx ? "?" : ftostr4sign(LOGICAL_X_POSITION(current_position.x)));
       tft.add_text(
         #if ENABLED(TFT_COLOR_UI_PORTRAIT)
           32 - tft_string.width() / 2, FONT_LINE_HEIGHT + tft_string.vcenter(FONT_LINE_HEIGHT),
         #else
           68 - tft_string.width(), tft_string.vcenter(FONT_LINE_HEIGHT),
         #endif
         nhx ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string
       );
     #endif
 
     #if HAS_Y_AXIS
-      tft.add_text(TERN(TFT_COLOR_UI_PORTRAIT, 110, 127), tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED , "Y");
+      tft.add_text(TERN(TFT_COLOR_UI_PORTRAIT, 110, 127), tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED, "Y");
       const bool nhy = axis_should_home(Y_AXIS);
       tft_string.set(blink && nhy ? "?" : ftostr4sign(LOGICAL_Y_POSITION(current_position.y)));
       tft.add_text(
         #if ENABLED(TFT_COLOR_UI_PORTRAIT)
           110 - tft_string.width() / 2, FONT_LINE_HEIGHT + tft_string.vcenter(FONT_LINE_HEIGHT),
         #else
           185 - tft_string.width(), tft_string.vcenter(FONT_LINE_HEIGHT),
         #endif
         nhy ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string
       );
     #endif
   }
 
   #if HAS_Z_AXIS
-    tft.add_text(TERN(TFT_COLOR_UI_PORTRAIT, 192, 219), tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED , "Z");
+    tft.add_text(TERN(TFT_COLOR_UI_PORTRAIT, 192, 219), tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED, "Z");
     const bool nhz = axis_should_home(Z_AXIS);
     uint16_t offset = 25;
     if (blink && nhz)
       tft_string.set('?');
     else {
       const float z = LOGICAL_Z_POSITION(current_position.z);
       tft_string.set(ftostr52sp((int16_t)z));
       tft_string.rtrim();
       offset += tft_string.width();
 
@@ -355,21 +355,21 @@ void MarlinUI::draw_status_screen() {
     #else
       70, 136, 84
     #endif
     , 32
   );
   tft.set_background(COLOR_BACKGROUND);
   uint16_t color = feedrate_percentage == 100 ? COLOR_RATE_100 : COLOR_RATE_ALTERED;
   tft.add_image(0, 0, imgFeedRate, color);
   tft_string.set(i16tostr3rj(feedrate_percentage));
   tft_string.add('%');
-  tft.add_text(32, tft_string.vcenter(30), color , tft_string);
+  tft.add_text(32, tft_string.vcenter(30), color, tft_string);
   TERN_(TOUCH_SCREEN, touch.add_control(FEEDRATE,
     #if ENABLED(TFT_COLOR_UI_PORTRAIT)
       30, 172, 80
     #else
       70, 136, 84
     #endif
     , 32
   ));
 
   // Flow rate
@@ -380,21 +380,21 @@ void MarlinUI::draw_status_screen() {
       #else
         170, 136, 84
       #endif
       , 32
     );
     tft.set_background(COLOR_BACKGROUND);
     color = planner.flow_percentage[0] == 100 ? COLOR_RATE_100 : COLOR_RATE_ALTERED;
     tft.add_image(0, 0, imgFlowRate, color);
     tft_string.set(i16tostr3rj(planner.flow_percentage[active_extruder]));
     tft_string.add('%');
-    tft.add_text(32, tft_string.vcenter(30), color , tft_string);
+    tft.add_text(32, tft_string.vcenter(30), color, tft_string);
     TERN_(TOUCH_SCREEN, touch.add_control(FLOWRATE,
       #if ENABLED(TFT_COLOR_UI_PORTRAIT)
         140, 172, 80
       #else
         170, 136, 84
       #endif
       , 32, active_extruder
     ));
   #endif // HAS_EXTRUDERS
 
@@ -569,21 +569,21 @@ void MenuItem_confirm::draw_select_screen(FSTR_P const yes, FSTR_P const no, con
     if (yes) add_control(TERN(TFT_COLOR_UI_PORTRAIT, 160, 208), TFT_HEIGHT - 64, CONFIRM, imgConfirm, true, yesno ? COLOR_CONTROL_CONFIRM : HALF(COLOR_CONTROL_CONFIRM));
   #endif
 }
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
 
   void MarlinUI::draw_hotend_status(const uint8_t row, const uint8_t extruder) {
     #if ENABLED(TOUCH_SCREEN)
       touch.clear();
       draw_menu_navigation = false;
-      touch.add_control(RESUME_CONTINUE , 0, 0, TFT_WIDTH, TFT_HEIGHT);
+      touch.add_control(RESUME_CONTINUE, 0, 0, TFT_WIDTH, TFT_HEIGHT);
     #endif
 
     menu_line(row);
     tft_string.set(GET_TEXT(MSG_FILAMENT_CHANGE_NOZZLE));
     tft_string.add('E');
     tft_string.add((char)('1' + extruder));
     tft_string.add(' ');
     tft_string.add(i16tostr3rj(thermalManager.wholeDegHotend(extruder)));
     tft_string.add(LCD_STR_DEGREE);
     tft_string.add(F(" / "));
@@ -732,31 +732,33 @@ static void drawCurStepValue() {
 #if HAS_Z_AXIS
   static void drawCurZSelection() {
     tft_string.set('Z');
     tft.canvas(motionAxisState.zTypePos.x, motionAxisState.zTypePos.y, tft_string.width(), 20);
     tft.set_background(COLOR_BACKGROUND);
     tft.add_text(0, 0, Z_BTN_COLOR, tft_string);
     tft.queue.sync();
     tft_string.set(F("Offset"));
     tft.canvas(motionAxisState.zTypePos.x, motionAxisState.zTypePos.y + 34, tft_string.width(), 20);
     tft.set_background(COLOR_BACKGROUND);
-    if (motionAxisState.z_selection == Z_SELECTION_Z_PROBE)
-      tft.add_text(0, 0, Z_BTN_COLOR, tft_string);
+    #if HAS_BED_PROBE
+      if (motionAxisState.z_selection == Z_SELECTION_Z_PROBE)
+        tft.add_text(0, 0, Z_BTN_COLOR, tft_string);
+    #endif
   }
 #endif
 
 #if HAS_EXTRUDERS
   static void drawCurESelection() {
     tft.canvas(motionAxisState.eNamePos.x, motionAxisState.eNamePos.y, BTN_WIDTH, BTN_HEIGHT);
     tft.set_background(COLOR_BACKGROUND);
     tft_string.set('E');
-    tft.add_text(0, 0, E_BTN_COLOR , tft_string);
+    tft.add_text(0, 0, E_BTN_COLOR, tft_string);
     tft.add_text(tft_string.width(), 0, E_BTN_COLOR, ui8tostr3rj(motionAxisState.e_selection));
   }
 #endif
 
 static void drawMessage(PGM_P const msg) {
   tft.canvas(X_MARGIN,
     #if ENABLED(TFT_COLOR_UI_PORTRAIT)
       TFT_HEIGHT - 2 * BTN_HEIGHT, TFT_WIDTH - X_MARGIN
     #else
       TFT_HEIGHT - Y_MARGIN - 29, (TFT_WIDTH / 2) - (BTN_WIDTH / 2) - X_MARGIN
@@ -802,62 +804,64 @@ static void moveAxis(const AxisEnum axis, const int8_t direction) {
 
   #if HAS_EXTRUDERS
     if (axis == E_AXIS && thermalManager.tooColdToExtrude(motionAxisState.e_selection)) {
       drawMessage(F("Too cold"));
       return;
     }
   #endif
 
   const float diff = motionAxisState.currentStepSize * direction;
 
-  #if HAS_Z_AXIS
+  #if HAS_BED_PROBE
+
     if (axis == Z_AXIS && motionAxisState.z_selection == Z_SELECTION_Z_PROBE) {
       #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
         const int16_t babystep_increment = direction * BABYSTEP_SIZE_Z;
         const bool do_probe = DISABLED(BABYSTEP_HOTEND_Z_OFFSET) || active_extruder == 0;
         const float bsDiff = planner.mm_per_step[Z_AXIS] * babystep_increment,
                     new_probe_offset = probe.offset.z + bsDiff,
                     new_offs = TERN(BABYSTEP_HOTEND_Z_OFFSET
                       , do_probe ? new_probe_offset : hotend_offset[active_extruder].z - bsDiff
                       , new_probe_offset
                     );
         if (WITHIN(new_offs, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
           babystep.add_steps(Z_AXIS, babystep_increment);
           if (do_probe)
             probe.offset.z = new_offs;
           else
             TERN(BABYSTEP_HOTEND_Z_OFFSET, hotend_offset[active_extruder].z = new_offs, NOOP);
           drawMessage(NUL_STR); // clear the error
           drawAxisValue(axis);
         }
-        else {
+        else
           drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
-        }
-      #elif HAS_BED_PROBE
+
+      #else
         // only change probe.offset.z
         probe.offset.z += diff;
         if (direction < 0 && current_position[axis] < Z_PROBE_OFFSET_RANGE_MIN) {
           current_position[axis] = Z_PROBE_OFFSET_RANGE_MIN;
           drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
         }
         else if (direction > 0 && current_position[axis] > Z_PROBE_OFFSET_RANGE_MAX) {
           current_position[axis] = Z_PROBE_OFFSET_RANGE_MAX;
           drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
         }
-        else {
+        else
           drawMessage(NUL_STR); // clear the error
-        }
+
         drawAxisValue(axis);
       #endif
       return;
     }
-  #endif // HAS_Z_AXIS
+
+  #endif // HAS_BED_PROBE
 
   if (!ui.manual_move.processing) {
     // Get motion limit from software endstops, if any
     float min, max;
     soft_endstop.get_manual_axis_limits(axis, min, max);
 
     // Delta limits XY based on the current offset from center
     // This assumes the center is 0,0
     #if ENABLED(DELTA)
       if (axis != Z_AXIS && TERN1(HAS_EXTRUDERS, axis != E_AXIS)) {
@@ -938,22 +942,22 @@ static void moveAxis(const AxisEnum axis, const int8_t direction) {
   #endif
 
 #endif // TOUCH_SCREEN
 
 static void disable_steppers() {
   quick_feedback();
   queue.inject(F("M84"));
 }
 
 static void drawBtn(int x, int y, const char *label, intptr_t data, MarlinImage img, uint16_t bgColor, bool enabled = true) {
-  uint16_t width = Images[imgBtn39Rounded].width;
-  uint16_t height = Images[imgBtn39Rounded].height;
+  const uint16_t width = Images[imgBtn39Rounded].width,
+                height = Images[imgBtn39Rounded].height;
 
   if (!enabled) bgColor = COLOR_CONTROL_DISABLED;
 
   tft.canvas(x, y, width, height);
   tft.set_background(COLOR_BACKGROUND);
   tft.add_image(0, 0, imgBtn39Rounded, bgColor, COLOR_BACKGROUND, COLOR_DARKGREY);
 
   // TODO: Make an add_text() taking a font arg
   if (label) {
     tft_string.set(label);
@@ -972,212 +976,222 @@ void MarlinUI::move_axis_screen() {
   motionAxisState.blocked = false;
   TERN_(TOUCH_SCREEN, touch.enable());
 
   ui.clear_lcd();
 
   TERN_(TOUCH_SCREEN, touch.clear());
 
   const bool busy = printingIsActive();
 
   // Babysteps during printing? Select babystep for Z probe offset
-  if (busy && ENABLED(BABYSTEP_ZPROBE_OFFSET))
-    motionAxisState.z_selection = Z_SELECTION_Z_PROBE;
+  #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
+    if (busy) motionAxisState.z_selection = Z_SELECTION_Z_PROBE;
+  #endif
 
   #if ENABLED(TFT_COLOR_UI_PORTRAIT)
 
     // ROW 1 -> E+ Y+ Z+
     int x = X_MARGIN, y = Y_MARGIN, spacing = 0;
 
-    drawBtn(x, y, "E+", (intptr_t)e_plus, imgUp, E_BTN_COLOR, !busy);
+    TERN_(HAS_EXTRUDERS, drawBtn(x, y, "E+", (intptr_t)e_plus, imgUp, E_BTN_COLOR, !busy));
 
     spacing = (TFT_WIDTH - X_MARGIN * 2 - 3 * BTN_WIDTH) / 2;
     x += BTN_WIDTH + spacing;
     uint16_t yplus_x = x;
-    drawBtn(x, y, "Y+", (intptr_t)y_plus, imgUp, Y_BTN_COLOR, !busy);
+
+    TERN_(HAS_Y_AXIS, drawBtn(x, y, "Y+", (intptr_t)y_plus, imgUp, Y_BTN_COLOR, !busy));
 
     x += BTN_WIDTH + spacing;
     uint16_t zplus_x = x;
+
     #if HAS_Z_AXIS
       drawBtn(x, y, "Z+", (intptr_t)z_plus, imgUp, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); //only enabled when not busy or have baby step
     #endif
 
     // ROW 2 -> "Ex" CurY "Z"
     x = X_MARGIN;
     y += BTN_HEIGHT + 2;
 
-    motionAxisState.eNamePos.x = x;
-    motionAxisState.eNamePos.y = y;
     #if HAS_EXTRUDERS
+      motionAxisState.eNamePos.set(x, y);
       drawCurESelection();
       TERN_(TOUCH_SCREEN, if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, BTN_HEIGHT, (intptr_t)e_select));
     #endif
 
-    motionAxisState.yValuePos.x = yplus_x;
-    motionAxisState.yValuePos.y = y;
-    drawAxisValue(Y_AXIS);
+    #if HAS_Y_AXIS
+      motionAxisState.yValuePos.set(yplus_x, y);
+      drawAxisValue(Y_AXIS);
+    #endif
 
-    motionAxisState.zTypePos.x = zplus_x;
-    motionAxisState.zTypePos.y = y;
-    TERN_(HAS_Z_AXIS, drawCurZSelection());
+    #if HAS_Z_AXIS
+      motionAxisState.zTypePos.set(zplus_x, y);
+      drawCurZSelection();
+    #endif
 
     // ROW 3 -> X-    HOME    X+
     y += (TFT_HEIGHT - Y_MARGIN * 2 - 4 * BTN_HEIGHT) / 3 - 2;
     x = X_MARGIN;
 
-    drawBtn(x, y, "X-", (intptr_t)x_minus, imgLeft, X_BTN_COLOR, !busy);
-
-    TERN_(TOUCH_SCREEN, add_control(TFT_WIDTH / 2 - Images[imgHome].width / 2, y - (Images[imgHome].width - BTN_HEIGHT) / 2, BUTTON, (intptr_t)do_home, imgHome, !busy));
-
-    drawBtn(zplus_x, y, "X+", (intptr_t)x_plus, imgRight, X_BTN_COLOR, !busy);
+    #if HAS_X_AXIS
+      drawBtn(x, y, "X-", (intptr_t)x_minus, imgLeft, X_BTN_COLOR, !busy);
+      TERN_(TOUCH_SCREEN, add_control(TFT_WIDTH / 2 - Images[imgHome].width / 2, y - (Images[imgHome].width - BTN_HEIGHT) / 2, BUTTON, (intptr_t)do_home, imgHome, !busy));
+      drawBtn(zplus_x, y, "X+", (intptr_t)x_plus, imgRight, X_BTN_COLOR, !busy);
+    #endif
 
     #if ALL(HAS_BED_PROBE, TOUCH_SCREEN)
       if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, 34 * 2, (intptr_t)z_select);
     #endif
 
     // ROW 4 -> Cur X
     y += BTN_HEIGHT + 2;
 
-    motionAxisState.xValuePos.x = x;
-    motionAxisState.xValuePos.y = y;
-    drawAxisValue(X_AXIS);
+    #if HAS_X_AXIS
+      motionAxisState.xValuePos.set(x, y);
+      drawAxisValue(X_AXIS);
+    #endif
 
     // ROW 5 -> E- CurX Y-    Z-
     y += (TFT_HEIGHT - Y_MARGIN * 2 - 4 * BTN_HEIGHT) / 3 - 2;
     x = X_MARGIN;
 
     #if HAS_EXTRUDERS
       drawBtn(x, y, "E-", (intptr_t)e_minus, imgDown, E_BTN_COLOR, !busy);
+      motionAxisState.eValuePos.set(x, y + BTN_HEIGHT + 2);
+      TERN_(HAS_EXTRUDERS, drawAxisValue(E_AXIS));
     #endif
 
-    // Cur E
-    motionAxisState.eValuePos.x = x;
-    motionAxisState.eValuePos.y = y + BTN_HEIGHT + 2;
-    TERN_(HAS_EXTRUDERS, drawAxisValue(E_AXIS));
-
     x += BTN_WIDTH + spacing;
-    drawBtn(x, y, "Y-", (intptr_t)y_minus, imgDown, Y_BTN_COLOR, !busy);
+
+    TERN_(HAS_Y_AXIS, drawBtn(x, y, "Y-", (intptr_t)y_minus, imgDown, Y_BTN_COLOR, !busy));
 
     x += BTN_WIDTH + spacing;
+
     #if HAS_Z_AXIS
       drawBtn(x, y, "Z-", (intptr_t)z_minus, imgDown, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); //only enabled when not busy or have baby step
+      motionAxisState.zValuePos.set(x, y + BTN_HEIGHT + 2);
+      drawAxisValue(Z_AXIS);
     #endif
 
-    // Cur Z
-    motionAxisState.zValuePos.x = x;
-    motionAxisState.zValuePos.y = y + BTN_HEIGHT + 2;
-    TERN_(HAS_Z_AXIS, drawAxisValue(Z_AXIS));
-
     // ROW 6 -> step_size    disable steppers back
-    y = TFT_HEIGHT - Y_MARGIN - BTN_HEIGHT; //
+    y = TFT_HEIGHT - Y_MARGIN - BTN_HEIGHT;
     x = zplus_x - CUR_STEP_VALUE_WIDTH - 10;
-    motionAxisState.stepValuePos.x = X_MARGIN + BTN_WIDTH - CUR_STEP_VALUE_WIDTH;
-    motionAxisState.stepValuePos.y = TFT_HEIGHT - Y_MARGIN - BTN_HEIGHT;
+    motionAxisState.stepValuePos.set(X_MARGIN + BTN_WIDTH - CUR_STEP_VALUE_WIDTH, y);
 
     if (!busy) {
-        drawCurStepValue();
-        TERN_(TOUCH_SCREEN, touch.add_control(BUTTON, motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y, CUR_STEP_VALUE_WIDTH, BTN_HEIGHT, (intptr_t)step_size));
+      drawCurStepValue();
+      TERN_(TOUCH_SCREEN, touch.add_control(BUTTON, motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y, CUR_STEP_VALUE_WIDTH, BTN_HEIGHT, (intptr_t)step_size));
     }
 
     // aligned with x+
     drawBtn(yplus_x, y, "off", (intptr_t)disable_steppers, imgCancel, COLOR_WHITE, !busy);
 
   #else // !TFT_COLOR_UI_PORTRAIT
 
     // ROW 1 -> E+ Y+ CurY Z+
     int x = X_MARGIN, y = Y_MARGIN, spacing = 0;
 
     TERN_(HAS_EXTRUDERS, drawBtn(x, y, "E+", (intptr_t)e_plus, imgUp, E_BTN_COLOR, !busy));
 
     spacing = (TFT_WIDTH - X_MARGIN * 2 - 3 * BTN_WIDTH) / 2;
     x += BTN_WIDTH + spacing;
     uint16_t yplus_x = x;
-    drawBtn(x, y, "Y+", (intptr_t)y_plus, imgUp, Y_BTN_COLOR, !busy);
 
-    // Cur Y
+    TERN_(HAS_Y_AXIS, drawBtn(x, y, "Y+", (intptr_t)y_plus, imgUp, Y_BTN_COLOR, !busy));
+
     x += BTN_WIDTH;
-    motionAxisState.yValuePos.x = x + 2;
-    motionAxisState.yValuePos.y = y;
-    drawAxisValue(Y_AXIS);
+
+    #if HAS_Y_AXIS
+      motionAxisState.yValuePos.set(x + 2, y);
+      drawAxisValue(Y_AXIS);
+    #endif
 
     x += spacing;
+
     #if HAS_Z_AXIS
       drawBtn(x, y, "Z+", (intptr_t)z_plus, imgUp, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); //only enabled when not busy or have baby step
     #endif
 
     // ROW 2 -> "Ex"    X-    HOME X+    "Z"
     y += BTN_HEIGHT + (TFT_HEIGHT - Y_MARGIN * 2 - 4 * BTN_HEIGHT) / 3;
     x = X_MARGIN;
     spacing = (TFT_WIDTH - X_MARGIN * 2 - 5 * BTN_WIDTH) / 4;
 
-    motionAxisState.eNamePos.x = x;
-    motionAxisState.eNamePos.y = y;
     #if HAS_EXTRUDERS
+      motionAxisState.eNamePos.set(x, y);
       drawCurESelection();
       TERN_(TOUCH_SCREEN, if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, BTN_HEIGHT, (intptr_t)e_select));
     #endif
 
     x += BTN_WIDTH + spacing;
-    drawBtn(x, y, "X-", (intptr_t)x_minus, imgLeft, X_BTN_COLOR, !busy);
+
+    TERN_(HAS_X_AXIS, drawBtn(x, y, "X-", (intptr_t)x_minus, imgLeft, X_BTN_COLOR, !busy));
 
     x += BTN_WIDTH + spacing; //imgHome is 64x64
-    TERN_(TOUCH_SCREEN, add_control(TFT_WIDTH / 2 - Images[imgHome].width / 2, y - (Images[imgHome].width - BTN_HEIGHT) / 2, BUTTON, (intptr_t)do_home, imgHome, !busy));
+
+    #if ALL(HAS_X_AXIS, TOUCH_SCREEN)
+      add_control(TFT_WIDTH / 2 - Images[imgHome].width / 2, y - (Images[imgHome].width - BTN_HEIGHT) / 2, BUTTON, (intptr_t)do_home, imgHome, !busy);
+    #endif
 
     x += BTN_WIDTH + spacing;
     uint16_t xplus_x = x;
-    drawBtn(x, y, "X+", (intptr_t)x_plus, imgRight, X_BTN_COLOR, !busy);
+
+    TERN_(HAS_X_AXIS, drawBtn(x, y, "X+", (intptr_t)x_plus, imgRight, X_BTN_COLOR, !busy));
 
     x += BTN_WIDTH + spacing;
-    motionAxisState.zTypePos.x = x;
-    motionAxisState.zTypePos.y = y;
-    TERN_(HAS_Z_AXIS, drawCurZSelection());
+
+    #if HAS_Z_AXIS
+      motionAxisState.zTypePos.set(x, y);
+      drawCurZSelection();
+    #endif
+
     #if ALL(HAS_BED_PROBE, TOUCH_SCREEN)
       if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, 34 * 2, (intptr_t)z_select);
     #endif
 
     // ROW 3 -> E- CurX Y-    Z-
     y += BTN_HEIGHT + (TFT_HEIGHT - Y_MARGIN * 2 - 4 * BTN_HEIGHT) / 3;
     x = X_MARGIN;
     spacing = (TFT_WIDTH - X_MARGIN * 2 - 3 * BTN_WIDTH) / 2;
 
-    TERN_(HAS_EXTRUDERS, drawBtn(x, y, "E-", (intptr_t)e_minus, imgDown, E_BTN_COLOR, !busy));
-
-    // Cur E
-    motionAxisState.eValuePos.x = x;
-    motionAxisState.eValuePos.y = y + BTN_HEIGHT + 2;
-    TERN_(HAS_EXTRUDERS, drawAxisValue(E_AXIS));
+    #if HAS_EXTRUDERS
+      drawBtn(x, y, "E-", (intptr_t)e_minus, imgDown, E_BTN_COLOR, !busy);
+      motionAxisState.eValuePos.set(x, y + BTN_HEIGHT + 2);
+      TERN_(HAS_EXTRUDERS, drawAxisValue(E_AXIS));
+    #endif
 
-    // Cur X
-    motionAxisState.xValuePos.x = BTN_WIDTH + (TFT_WIDTH - X_MARGIN * 2 - 5 * BTN_WIDTH) / 4; //X- pos
-    motionAxisState.xValuePos.y = y - 10;
-    drawAxisValue(X_AXIS);
+    #if HAS_X_AXIS
+      motionAxisState.xValuePos.set(BTN_WIDTH + (TFT_WIDTH - X_MARGIN * 2 - 5 * BTN_WIDTH) / 4, y - 10);
+      drawAxisValue(X_AXIS);
+    #endif
 
     x += BTN_WIDTH + spacing;
-    drawBtn(x, y, "Y-", (intptr_t)y_minus, imgDown, Y_BTN_COLOR, !busy);
+
+    TERN_(HAS_Y_AXIS, drawBtn(x, y, "Y-", (intptr_t)y_minus, imgDown, Y_BTN_COLOR, !busy));
 
     x += BTN_WIDTH + spacing;
+
     #if HAS_Z_AXIS
       drawBtn(x, y, "Z-", (intptr_t)z_minus, imgDown, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); //only enabled when not busy or have baby step
     #endif
 
-    // Cur Z
-    motionAxisState.zValuePos.x = x;
-    motionAxisState.zValuePos.y = y + BTN_HEIGHT + 2;
-    TERN_(HAS_Z_AXIS, drawAxisValue(Z_AXIS));
+    #if HAS_Z_AXIS
+      motionAxisState.zValuePos.set(x, y + BTN_HEIGHT + 2);
+      drawAxisValue(Z_AXIS);
+    #endif
 
     // ROW 4 -> step_size    disable steppers back
-    y = TFT_HEIGHT - Y_MARGIN - BTN_HEIGHT; //
+    y = TFT_HEIGHT - Y_MARGIN - BTN_HEIGHT;
     x = xplus_x - CUR_STEP_VALUE_WIDTH - 10;
-    motionAxisState.stepValuePos.x = yplus_x + BTN_WIDTH - CUR_STEP_VALUE_WIDTH;
-    motionAxisState.stepValuePos.y = TFT_HEIGHT - Y_MARGIN - BTN_HEIGHT;
+    motionAxisState.stepValuePos.set(yplus_x + BTN_WIDTH - CUR_STEP_VALUE_WIDTH, y);
     if (!busy) {
-        drawCurStepValue();
-        TERN_(TOUCH_SCREEN, touch.add_control(BUTTON, motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y, CUR_STEP_VALUE_WIDTH, BTN_HEIGHT, (intptr_t)step_size));
+      drawCurStepValue();
+      TERN_(TOUCH_SCREEN, touch.add_control(BUTTON, motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y, CUR_STEP_VALUE_WIDTH, BTN_HEIGHT, (intptr_t)step_size));
     }
 
     // aligned with x+
     drawBtn(xplus_x, y, "off", (intptr_t)disable_steppers, imgCancel, COLOR_WHITE, !busy);
 
   #endif // !TFT_COLOR_UI_PORTRAIT
 
   TERN_(TOUCH_SCREEN, add_control(TFT_WIDTH - X_MARGIN - BTN_WIDTH, y, BACK, imgBack));
 }
 

commit 2691167afe02fbbe74b0fdca2c28a49fac635741
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:26:02 2023 -0500

    üßë‚Äçüíª Dump BOTH and EITHER macros (#25908)

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index c2918711f4..0d145f10eb 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -29,21 +29,21 @@
 #include "../marlinui.h"
 #include "../menu/menu.h"
 #include "../../libs/numtostr.h"
 
 #include "../../sd/cardreader.h"
 #include "../../module/temperature.h"
 #include "../../module/printcounter.h"
 #include "../../module/planner.h"
 #include "../../module/motion.h"
 
-#if DISABLED(LCD_PROGRESS_BAR) && BOTH(FILAMENT_LCD_DISPLAY, HAS_MEDIA)
+#if DISABLED(LCD_PROGRESS_BAR) && ALL(FILAMENT_LCD_DISPLAY, HAS_MEDIA)
   #include "../../feature/filwidth.h"
   #include "../../gcode/parser.h"
 #endif
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
   #include "../../feature/bedlevel/bedlevel.h"
 #endif
 
 void MarlinUI::tft_idle() {
   #if ENABLED(TOUCH_SCREEN)
@@ -701,21 +701,21 @@ struct {
 } motionAxisState;
 
 #define BTN_WIDTH 48
 #define BTN_HEIGHT 39
 #define X_MARGIN 15
 #define Y_MARGIN 11
 
 static void quick_feedback() {
   #if HAS_CHIRP
     ui.chirp(); // Buzz and wait. Is the delay needed for buttons to settle?
-    #if BOTH(HAS_MARLINUI_MENU, HAS_BEEPER)
+    #if ALL(HAS_MARLINUI_MENU, HAS_BEEPER)
       for (int8_t i = 5; i--;) { buzzer.tick(); delay(2); }
     #elif HAS_MARLINUI_MENU
       delay(10);
     #endif
   #endif
 }
 
 #define CUR_STEP_VALUE_WIDTH 38
 static void drawCurStepValue() {
   tft_string.set(ftostr52sp(motionAxisState.currentStepSize));
@@ -1022,21 +1022,21 @@ void MarlinUI::move_axis_screen() {
     // ROW 3 -> X-    HOME    X+
     y += (TFT_HEIGHT - Y_MARGIN * 2 - 4 * BTN_HEIGHT) / 3 - 2;
     x = X_MARGIN;
 
     drawBtn(x, y, "X-", (intptr_t)x_minus, imgLeft, X_BTN_COLOR, !busy);
 
     TERN_(TOUCH_SCREEN, add_control(TFT_WIDTH / 2 - Images[imgHome].width / 2, y - (Images[imgHome].width - BTN_HEIGHT) / 2, BUTTON, (intptr_t)do_home, imgHome, !busy));
 
     drawBtn(zplus_x, y, "X+", (intptr_t)x_plus, imgRight, X_BTN_COLOR, !busy);
 
-    #if BOTH(HAS_BED_PROBE, TOUCH_SCREEN)
+    #if ALL(HAS_BED_PROBE, TOUCH_SCREEN)
       if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, 34 * 2, (intptr_t)z_select);
     #endif
 
     // ROW 4 -> Cur X
     y += BTN_HEIGHT + 2;
 
     motionAxisState.xValuePos.x = x;
     motionAxisState.xValuePos.y = y;
     drawAxisValue(X_AXIS);
 
@@ -1122,21 +1122,21 @@ void MarlinUI::move_axis_screen() {
     TERN_(TOUCH_SCREEN, add_control(TFT_WIDTH / 2 - Images[imgHome].width / 2, y - (Images[imgHome].width - BTN_HEIGHT) / 2, BUTTON, (intptr_t)do_home, imgHome, !busy));
 
     x += BTN_WIDTH + spacing;
     uint16_t xplus_x = x;
     drawBtn(x, y, "X+", (intptr_t)x_plus, imgRight, X_BTN_COLOR, !busy);
 
     x += BTN_WIDTH + spacing;
     motionAxisState.zTypePos.x = x;
     motionAxisState.zTypePos.y = y;
     TERN_(HAS_Z_AXIS, drawCurZSelection());
-    #if BOTH(HAS_BED_PROBE, TOUCH_SCREEN)
+    #if ALL(HAS_BED_PROBE, TOUCH_SCREEN)
       if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, 34 * 2, (intptr_t)z_select);
     #endif
 
     // ROW 3 -> E- CurX Y-    Z-
     y += BTN_HEIGHT + (TFT_HEIGHT - Y_MARGIN * 2 - 4 * BTN_HEIGHT) / 3;
     x = X_MARGIN;
     spacing = (TFT_WIDTH - X_MARGIN * 2 - 3 * BTN_WIDTH) / 2;
 
     TERN_(HAS_EXTRUDERS, drawBtn(x, y, "E-", (intptr_t)e_minus, imgDown, E_BTN_COLOR, !busy));
 

commit d5fdbb89ea55a19815c6997d47f1268a96d2cac9
Author: Alexey D. Filimonov <alexey@filimonic.net>
Date:   Sun May 14 00:25:36 2023 +0300

    üö∏ TFT optional axes/extruder (#25624)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index bac7586a25..c2918711f4 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -119,22 +119,26 @@ void MarlinUI::draw_kill_screen() {
 
   tft.queue.sync();
 }
 
 void draw_heater_status(uint16_t x, uint16_t y, const int8_t Heater) {
   MarlinImage image = imgHotEnd;
   uint16_t Color;
   celsius_t currentTemperature, targetTemperature;
 
   if (Heater >= 0) { // HotEnd
-    currentTemperature = thermalManager.wholeDegHotend(Heater);
-    targetTemperature = thermalManager.degTargetHotend(Heater);
+    #if HAS_EXTRUDERS
+      currentTemperature = thermalManager.wholeDegHotend(Heater);
+      targetTemperature = thermalManager.degTargetHotend(Heater);
+    #else
+      return;
+    #endif
   }
   #if HAS_HEATED_BED
     else if (Heater == H_BED) {
       currentTemperature = thermalManager.wholeDegBed();
       targetTemperature = thermalManager.degTargetBed();
     }
   #endif
   #if HAS_TEMP_CHAMBER
     else if (Heater == H_CHAMBER) {
       currentTemperature = thermalManager.wholeDegChamber();
@@ -276,66 +280,73 @@ void MarlinUI::draw_status_screen() {
     #if ENABLED(LCD_SHOW_E_TOTAL)
       tft.add_text( 10, tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED , "E");
       const uint8_t escale = e_move_accumulator >= 100000.0f ? 10 : 1; // After 100m switch to cm
       tft_string.set(ftostr4sign(e_move_accumulator / escale));
       tft_string.add(escale == 10 ? 'c' : 'm');
       tft_string.add('m');
       tft.add_text(127 - tft_string.width(), tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED, tft_string);
     #endif
   }
   else {
-    tft.add_text(TERN(TFT_COLOR_UI_PORTRAIT, 32, 10), tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED , "X");
-    const bool nhx = axis_should_home(X_AXIS);
-    tft_string.set(blink && nhx ? "?" : ftostr4sign(LOGICAL_X_POSITION(current_position.x)));
-    tft.add_text(
-      #if ENABLED(TFT_COLOR_UI_PORTRAIT)
-        32 - tft_string.width() / 2, FONT_LINE_HEIGHT + tft_string.vcenter(FONT_LINE_HEIGHT),
-      #else
-        68 - tft_string.width(), tft_string.vcenter(FONT_LINE_HEIGHT),
-      #endif
-      nhx ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string
-    );
+    #if HAS_X_AXIS
+      tft.add_text(TERN(TFT_COLOR_UI_PORTRAIT, 32, 10), tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED , "X");
+      const bool nhx = axis_should_home(X_AXIS);
+      tft_string.set(blink && nhx ? "?" : ftostr4sign(LOGICAL_X_POSITION(current_position.x)));
+      tft.add_text(
+        #if ENABLED(TFT_COLOR_UI_PORTRAIT)
+          32 - tft_string.width() / 2, FONT_LINE_HEIGHT + tft_string.vcenter(FONT_LINE_HEIGHT),
+        #else
+          68 - tft_string.width(), tft_string.vcenter(FONT_LINE_HEIGHT),
+        #endif
+        nhx ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string
+      );
+    #endif
+
+    #if HAS_Y_AXIS
+      tft.add_text(TERN(TFT_COLOR_UI_PORTRAIT, 110, 127), tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED , "Y");
+      const bool nhy = axis_should_home(Y_AXIS);
+      tft_string.set(blink && nhy ? "?" : ftostr4sign(LOGICAL_Y_POSITION(current_position.y)));
+      tft.add_text(
+        #if ENABLED(TFT_COLOR_UI_PORTRAIT)
+          110 - tft_string.width() / 2, FONT_LINE_HEIGHT + tft_string.vcenter(FONT_LINE_HEIGHT),
+        #else
+          185 - tft_string.width(), tft_string.vcenter(FONT_LINE_HEIGHT),
+        #endif
+        nhy ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string
+      );
+    #endif
+  }
 
-    tft.add_text(TERN(TFT_COLOR_UI_PORTRAIT, 110, 127), tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED , "Y");
-    const bool nhy = axis_should_home(Y_AXIS);
-    tft_string.set(blink && nhy ? "?" : ftostr4sign(LOGICAL_Y_POSITION(current_position.y)));
+  #if HAS_Z_AXIS
+    tft.add_text(TERN(TFT_COLOR_UI_PORTRAIT, 192, 219), tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED , "Z");
+    const bool nhz = axis_should_home(Z_AXIS);
+    uint16_t offset = 25;
+    if (blink && nhz)
+      tft_string.set('?');
+    else {
+      const float z = LOGICAL_Z_POSITION(current_position.z);
+      tft_string.set(ftostr52sp((int16_t)z));
+      tft_string.rtrim();
+      offset += tft_string.width();
+
+      tft_string.set(ftostr52sp(z));
+      offset -= tft_string.width();
+    }
     tft.add_text(
       #if ENABLED(TFT_COLOR_UI_PORTRAIT)
-        110 - tft_string.width() / 2, FONT_LINE_HEIGHT + tft_string.vcenter(FONT_LINE_HEIGHT),
+        192 - tft_string.width() / 2, FONT_LINE_HEIGHT + tft_string.vcenter(FONT_LINE_HEIGHT),
       #else
-        185 - tft_string.width(), tft_string.vcenter(FONT_LINE_HEIGHT),
+        301 - tft_string.width() - offset, tft_string.vcenter(FONT_LINE_HEIGHT),
       #endif
-      nhy ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string
-    );
-  }
-
-  tft.add_text(TERN(TFT_COLOR_UI_PORTRAIT, 192, 219), tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED , "Z");
-  const bool nhz = axis_should_home(Z_AXIS);
-  uint16_t offset = 25;
-  if (blink && nhz)
-    tft_string.set('?');
-  else {
-    const float z = LOGICAL_Z_POSITION(current_position.z);
-    tft_string.set(ftostr52sp((int16_t)z));
-    tft_string.rtrim();
-    offset += tft_string.width();
+    nhz ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
+  #endif
 
-    tft_string.set(ftostr52sp(z));
-    offset -= tft_string.width();
-  }
-  tft.add_text(
-    #if ENABLED(TFT_COLOR_UI_PORTRAIT)
-      192 - tft_string.width() / 2, FONT_LINE_HEIGHT + tft_string.vcenter(FONT_LINE_HEIGHT),
-    #else
-      301 - tft_string.width() - offset, tft_string.vcenter(FONT_LINE_HEIGHT),
-    #endif
-  nhz ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
   TERN_(TOUCH_SCREEN, touch.add_control(MOVE_AXIS, 0, 103,
     #if ENABLED(TFT_COLOR_UI_PORTRAIT)
       232, FONT_LINE_HEIGHT * 2
     #else
       312, FONT_LINE_HEIGHT
     #endif
   ));
 
   // feed rate
   tft.canvas(
@@ -354,43 +365,45 @@ void MarlinUI::draw_status_screen() {
   tft.add_text(32, tft_string.vcenter(30), color , tft_string);
   TERN_(TOUCH_SCREEN, touch.add_control(FEEDRATE,
     #if ENABLED(TFT_COLOR_UI_PORTRAIT)
       30, 172, 80
     #else
       70, 136, 84
     #endif
     , 32
   ));
 
-  // flow rate
-  tft.canvas(
-    #if ENABLED(TFT_COLOR_UI_PORTRAIT)
-      140, 172, 80
-    #else
-      170, 136, 84
-    #endif
-    , 32
-  );
-  tft.set_background(COLOR_BACKGROUND);
-  color = planner.flow_percentage[0] == 100 ? COLOR_RATE_100 : COLOR_RATE_ALTERED;
-  tft.add_image(0, 0, imgFlowRate, color);
-  tft_string.set(i16tostr3rj(planner.flow_percentage[active_extruder]));
-  tft_string.add('%');
-  tft.add_text(32, tft_string.vcenter(30), color , tft_string);
-  TERN_(TOUCH_SCREEN, touch.add_control(FLOWRATE,
-    #if ENABLED(TFT_COLOR_UI_PORTRAIT)
-      140, 172, 80
-    #else
-      170, 136, 84
-    #endif
-    , 32, active_extruder
-  ));
+  // Flow rate
+  #if HAS_EXTRUDERS
+    tft.canvas(
+      #if ENABLED(TFT_COLOR_UI_PORTRAIT)
+        140, 172, 80
+      #else
+        170, 136, 84
+      #endif
+      , 32
+    );
+    tft.set_background(COLOR_BACKGROUND);
+    color = planner.flow_percentage[0] == 100 ? COLOR_RATE_100 : COLOR_RATE_ALTERED;
+    tft.add_image(0, 0, imgFlowRate, color);
+    tft_string.set(i16tostr3rj(planner.flow_percentage[active_extruder]));
+    tft_string.add('%');
+    tft.add_text(32, tft_string.vcenter(30), color , tft_string);
+    TERN_(TOUCH_SCREEN, touch.add_control(FLOWRATE,
+      #if ENABLED(TFT_COLOR_UI_PORTRAIT)
+        140, 172, 80
+      #else
+        170, 136, 84
+      #endif
+      , 32, active_extruder
+    ));
+  #endif // HAS_EXTRUDERS
 
   // print duration
   char buffer[14];
   duration_t elapsed = print_job_timer.duration();
   elapsed.toDigital(buffer);
 
   tft.canvas(
     #if ENABLED(TFT_COLOR_UI_PORTRAIT)
       56, 256, 128
     #else
@@ -659,30 +672,40 @@ void MenuItem_confirm::draw_select_screen(FSTR_P const yes, FSTR_P const no, con
   #include "../../feature/babystep.h"
 #endif
 
 #if HAS_BED_PROBE
   #include "../../module/probe.h"
 #endif
 
 #define Z_SELECTION_Z 1
 #define Z_SELECTION_Z_PROBE -1
 
-struct MotionAxisState {
-  xy_int_t xValuePos, yValuePos, zValuePos, eValuePos, stepValuePos, zTypePos, eNamePos;
+struct {
+  #if HAS_X_AXIS
+    xy_int_t xValuePos;
+  #endif
+  #if HAS_Y_AXIS
+    xy_int_t yValuePos;
+  #endif
+  #if HAS_Z_AXIS
+    xy_int_t zValuePos, zTypePos;
+    int z_selection = Z_SELECTION_Z;
+  #endif
+  #if HAS_EXTRUDERS
+    xy_int_t eValuePos, eNamePos;
+    uint8_t e_selection = 0;
+  #endif
+  xy_int_t stepValuePos;
   float currentStepSize = 10.0;
-  int z_selection = Z_SELECTION_Z;
-  uint8_t e_selection = 0;
   bool blocked = false;
   char message[32];
-};
-
-MotionAxisState motionAxisState;
+} motionAxisState;
 
 #define BTN_WIDTH 48
 #define BTN_HEIGHT 39
 #define X_MARGIN 15
 #define Y_MARGIN 11
 
 static void quick_feedback() {
   #if HAS_CHIRP
     ui.chirp(); // Buzz and wait. Is the delay needed for buttons to settle?
     #if BOTH(HAS_MARLINUI_MENU, HAS_BEEPER)
@@ -699,41 +722,44 @@ static void drawCurStepValue() {
   tft.canvas(motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y, CUR_STEP_VALUE_WIDTH, 20);
   tft.set_background(COLOR_BACKGROUND);
   tft.add_text(CUR_STEP_VALUE_WIDTH - tft_string.width(), 0, COLOR_AXIS_HOMED, tft_string);
   tft.queue.sync();
   tft_string.set(F("mm"));
   tft.canvas(motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y + 20, CUR_STEP_VALUE_WIDTH, 20);
   tft.set_background(COLOR_BACKGROUND);
   tft.add_text(CUR_STEP_VALUE_WIDTH - tft_string.width(), 0, COLOR_AXIS_HOMED, tft_string);
 }
 
-static void drawCurZSelection() {
-  tft_string.set('Z');
-  tft.canvas(motionAxisState.zTypePos.x, motionAxisState.zTypePos.y, tft_string.width(), 20);
-  tft.set_background(COLOR_BACKGROUND);
-  tft.add_text(0, 0, Z_BTN_COLOR, tft_string);
-  tft.queue.sync();
-  tft_string.set(F("Offset"));
-  tft.canvas(motionAxisState.zTypePos.x, motionAxisState.zTypePos.y + 34, tft_string.width(), 20);
-  tft.set_background(COLOR_BACKGROUND);
-  if (motionAxisState.z_selection == Z_SELECTION_Z_PROBE) {
+#if HAS_Z_AXIS
+  static void drawCurZSelection() {
+    tft_string.set('Z');
+    tft.canvas(motionAxisState.zTypePos.x, motionAxisState.zTypePos.y, tft_string.width(), 20);
+    tft.set_background(COLOR_BACKGROUND);
     tft.add_text(0, 0, Z_BTN_COLOR, tft_string);
+    tft.queue.sync();
+    tft_string.set(F("Offset"));
+    tft.canvas(motionAxisState.zTypePos.x, motionAxisState.zTypePos.y + 34, tft_string.width(), 20);
+    tft.set_background(COLOR_BACKGROUND);
+    if (motionAxisState.z_selection == Z_SELECTION_Z_PROBE)
+      tft.add_text(0, 0, Z_BTN_COLOR, tft_string);
   }
-}
+#endif
 
-static void drawCurESelection() {
-  tft.canvas(motionAxisState.eNamePos.x, motionAxisState.eNamePos.y, BTN_WIDTH, BTN_HEIGHT);
-  tft.set_background(COLOR_BACKGROUND);
-  tft_string.set('E');
-  tft.add_text(0, 0, E_BTN_COLOR , tft_string);
-  tft.add_text(tft_string.width(), 0, E_BTN_COLOR, ui8tostr3rj(motionAxisState.e_selection));
-}
+#if HAS_EXTRUDERS
+  static void drawCurESelection() {
+    tft.canvas(motionAxisState.eNamePos.x, motionAxisState.eNamePos.y, BTN_WIDTH, BTN_HEIGHT);
+    tft.set_background(COLOR_BACKGROUND);
+    tft_string.set('E');
+    tft.add_text(0, 0, E_BTN_COLOR , tft_string);
+    tft.add_text(tft_string.width(), 0, E_BTN_COLOR, ui8tostr3rj(motionAxisState.e_selection));
+  }
+#endif
 
 static void drawMessage(PGM_P const msg) {
   tft.canvas(X_MARGIN,
     #if ENABLED(TFT_COLOR_UI_PORTRAIT)
       TFT_HEIGHT - 2 * BTN_HEIGHT, TFT_WIDTH - X_MARGIN
     #else
       TFT_HEIGHT - Y_MARGIN - 29, (TFT_WIDTH / 2) - (BTN_WIDTH / 2) - X_MARGIN
     #endif
     , FONT_LINE_HEIGHT
   );
@@ -744,141 +770,162 @@ static void drawMessage(PGM_P const msg) {
 static void drawMessage(FSTR_P const fmsg) { drawMessage(FTOP(fmsg)); }
 
 static void drawAxisValue(const AxisEnum axis) {
   const float value = (
     TERN_(HAS_BED_PROBE, axis == Z_AXIS && motionAxisState.z_selection == Z_SELECTION_Z_PROBE ? probe.offset.z :)
     ui.manual_move.axis_value(axis)
   );
   xy_int_t pos;
   uint16_t color;
   switch (axis) {
-    case X_AXIS: pos = motionAxisState.xValuePos; color = X_BTN_COLOR; break;
-    case Y_AXIS: pos = motionAxisState.yValuePos; color = Y_BTN_COLOR; break;
-    case Z_AXIS: pos = motionAxisState.zValuePos; color = Z_BTN_COLOR; break;
-    case E_AXIS: pos = motionAxisState.eValuePos; color = E_BTN_COLOR; break;
+    #if HAS_X_AXIS
+      case X_AXIS: pos = motionAxisState.xValuePos; color = X_BTN_COLOR; break;
+    #endif
+    #if HAS_Y_AXIS
+      case Y_AXIS: pos = motionAxisState.yValuePos; color = Y_BTN_COLOR; break;
+    #endif
+    #if HAS_Z_AXIS
+      case Z_AXIS: pos = motionAxisState.zValuePos; color = Z_BTN_COLOR; break;
+    #endif
+    #if HAS_EXTRUDERS
+      case E_AXIS: pos = motionAxisState.eValuePos; color = E_BTN_COLOR; break;
+    #endif
     default: return;
   }
   tft.canvas(pos.x, pos.y, BTN_WIDTH + X_MARGIN, FONT_LINE_HEIGHT);
   tft.set_background(COLOR_BACKGROUND);
   tft_string.set(ftostr52sp(value));
   tft.add_text(0, 0, color, tft_string);
 }
 
 static void moveAxis(const AxisEnum axis, const int8_t direction) {
   quick_feedback();
 
-  if (axis == E_AXIS && thermalManager.tooColdToExtrude(motionAxisState.e_selection)) {
-    drawMessage(F("Too cold"));
-    return;
-  }
+  #if HAS_EXTRUDERS
+    if (axis == E_AXIS && thermalManager.tooColdToExtrude(motionAxisState.e_selection)) {
+      drawMessage(F("Too cold"));
+      return;
+    }
+  #endif
 
   const float diff = motionAxisState.currentStepSize * direction;
 
-  if (axis == Z_AXIS && motionAxisState.z_selection == Z_SELECTION_Z_PROBE) {
-    #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
-      const int16_t babystep_increment = direction * BABYSTEP_SIZE_Z;
-      const bool do_probe = DISABLED(BABYSTEP_HOTEND_Z_OFFSET) || active_extruder == 0;
-      const float bsDiff = planner.mm_per_step[Z_AXIS] * babystep_increment,
-                  new_probe_offset = probe.offset.z + bsDiff,
-                  new_offs = TERN(BABYSTEP_HOTEND_Z_OFFSET
-                    , do_probe ? new_probe_offset : hotend_offset[active_extruder].z - bsDiff
-                    , new_probe_offset
-                  );
-      if (WITHIN(new_offs, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
-        babystep.add_steps(Z_AXIS, babystep_increment);
-        if (do_probe)
-          probe.offset.z = new_offs;
-        else
-          TERN(BABYSTEP_HOTEND_Z_OFFSET, hotend_offset[active_extruder].z = new_offs, NOOP);
-        drawMessage(NUL_STR); // clear the error
+  #if HAS_Z_AXIS
+    if (axis == Z_AXIS && motionAxisState.z_selection == Z_SELECTION_Z_PROBE) {
+      #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
+        const int16_t babystep_increment = direction * BABYSTEP_SIZE_Z;
+        const bool do_probe = DISABLED(BABYSTEP_HOTEND_Z_OFFSET) || active_extruder == 0;
+        const float bsDiff = planner.mm_per_step[Z_AXIS] * babystep_increment,
+                    new_probe_offset = probe.offset.z + bsDiff,
+                    new_offs = TERN(BABYSTEP_HOTEND_Z_OFFSET
+                      , do_probe ? new_probe_offset : hotend_offset[active_extruder].z - bsDiff
+                      , new_probe_offset
+                    );
+        if (WITHIN(new_offs, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
+          babystep.add_steps(Z_AXIS, babystep_increment);
+          if (do_probe)
+            probe.offset.z = new_offs;
+          else
+            TERN(BABYSTEP_HOTEND_Z_OFFSET, hotend_offset[active_extruder].z = new_offs, NOOP);
+          drawMessage(NUL_STR); // clear the error
+          drawAxisValue(axis);
+        }
+        else {
+          drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
+        }
+      #elif HAS_BED_PROBE
+        // only change probe.offset.z
+        probe.offset.z += diff;
+        if (direction < 0 && current_position[axis] < Z_PROBE_OFFSET_RANGE_MIN) {
+          current_position[axis] = Z_PROBE_OFFSET_RANGE_MIN;
+          drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
+        }
+        else if (direction > 0 && current_position[axis] > Z_PROBE_OFFSET_RANGE_MAX) {
+          current_position[axis] = Z_PROBE_OFFSET_RANGE_MAX;
+          drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
+        }
+        else {
+          drawMessage(NUL_STR); // clear the error
+        }
         drawAxisValue(axis);
-      }
-      else {
-        drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
-      }
-    #elif HAS_BED_PROBE
-      // only change probe.offset.z
-      probe.offset.z += diff;
-      if (direction < 0 && current_position[axis] < Z_PROBE_OFFSET_RANGE_MIN) {
-        current_position[axis] = Z_PROBE_OFFSET_RANGE_MIN;
-        drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
-      }
-      else if (direction > 0 && current_position[axis] > Z_PROBE_OFFSET_RANGE_MAX) {
-        current_position[axis] = Z_PROBE_OFFSET_RANGE_MAX;
-        drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
-      }
-      else {
-        drawMessage(NUL_STR); // clear the error
-      }
-      drawAxisValue(axis);
-    #endif
-    return;
-  }
+      #endif
+      return;
+    }
+  #endif // HAS_Z_AXIS
 
   if (!ui.manual_move.processing) {
     // Get motion limit from software endstops, if any
     float min, max;
     soft_endstop.get_manual_axis_limits(axis, min, max);
 
     // Delta limits XY based on the current offset from center
     // This assumes the center is 0,0
     #if ENABLED(DELTA)
-      if (axis != Z_AXIS && axis != E_AXIS) {
+      if (axis != Z_AXIS && TERN1(HAS_EXTRUDERS, axis != E_AXIS)) {
         max = SQRT(sq(float(PRINTABLE_RADIUS)) - sq(current_position[Y_AXIS - axis])); // (Y_AXIS - axis) == the other axis
         min = -max;
       }
     #endif
 
     // Get the new position
     const bool limited = ui.manual_move.apply_diff(axis, diff, min, max);
     #if IS_KINEMATIC
       UNUSED(limited);
     #else
       PGM_P const msg = limited ? GET_TEXT(MSG_LCD_SOFT_ENDSTOPS) : NUL_STR;
       drawMessage(msg);
     #endif
 
     ui.manual_move.soon(axis OPTARG(MULTI_E_MANUAL, motionAxisState.e_selection));
   }
 
   drawAxisValue(axis);
 }
 
-static void e_plus()  { moveAxis(E_AXIS, 1);  }
-static void e_minus() { moveAxis(E_AXIS, -1); }
-static void x_minus() { moveAxis(X_AXIS, -1); }
-static void x_plus()  { moveAxis(X_AXIS, 1);  }
-static void y_plus()  { moveAxis(Y_AXIS, 1);  }
-static void y_minus() { moveAxis(Y_AXIS, -1); }
-static void z_plus()  { moveAxis(Z_AXIS, 1);  }
-static void z_minus() { moveAxis(Z_AXIS, -1); }
+#if HAS_EXTRUDERS
+  static void e_plus()  { moveAxis(E_AXIS, 1);  }
+  static void e_minus() { moveAxis(E_AXIS, -1); }
+#endif
+#if HAS_X_AXIS
+  static void x_minus() { moveAxis(X_AXIS, -1); }
+  static void x_plus()  { moveAxis(X_AXIS, 1);  }
+#endif
+#if HAS_Y_AXIS
+  static void y_plus()  { moveAxis(Y_AXIS, 1);  }
+  static void y_minus() { moveAxis(Y_AXIS, -1); }
+#endif
+#if HAS_Z_AXIS
+  static void z_plus()  { moveAxis(Z_AXIS, 1);  }
+  static void z_minus() { moveAxis(Z_AXIS, -1); }
+#endif
 
 #if ENABLED(TOUCH_SCREEN)
-  static void e_select() {
-    if (++motionAxisState.e_selection >= EXTRUDERS)
-      motionAxisState.e_selection = 0;
-
-    quick_feedback();
-    drawCurESelection();
-    drawAxisValue(E_AXIS);
-  }
+  #if HAS_EXTRUDERS
+    static void e_select() {
+      if (++motionAxisState.e_selection >= EXTRUDERS)
+        motionAxisState.e_selection = 0;
+      quick_feedback();
+      drawCurESelection();
+      drawAxisValue(E_AXIS);
+    }
+  #endif
 
   static void do_home() {
     quick_feedback();
     drawMessage(GET_TEXT_F(MSG_LEVEL_BED_HOMING));
     queue.inject_P(G28_STR);
     // Disable touch until home is done
-    TERN_(HAS_TFT_XPT2046, touch.disable());
-    drawAxisValue(E_AXIS);
-    drawAxisValue(X_AXIS);
-    drawAxisValue(Y_AXIS);
-    drawAxisValue(Z_AXIS);
+    touch.disable();
+    TERN_(HAS_EXTRUDERS, drawAxisValue(E_AXIS));
+    TERN_(HAS_X_AXIS, drawAxisValue(X_AXIS));
+    TERN_(HAS_Y_AXIS, drawAxisValue(Y_AXIS));
+    TERN_(HAS_Z_AXIS, drawAxisValue(Z_AXIS));
   }
 
   static void step_size() {
     motionAxisState.currentStepSize = motionAxisState.currentStepSize / 10.0;
     if (motionAxisState.currentStepSize < 0.0015) motionAxisState.currentStepSize = 10.0;
     quick_feedback();
     drawCurStepValue();
   }
 
   #if HAS_BED_PROBE
@@ -909,28 +956,28 @@ static void drawBtn(int x, int y, const char *label, intptr_t data, MarlinImage
 
   // TODO: Make an add_text() taking a font arg
   if (label) {
     tft_string.set(label);
     tft_string.trim();
     tft.add_text(tft_string.center(width), height / 2 - tft_string.font_height() / 2, bgColor, tft_string);
   }
   else
     tft.add_image(0, 0, img, bgColor, COLOR_BACKGROUND, COLOR_DARKGREY);
 
-  TERN_(HAS_TFT_XPT2046, if (enabled) touch.add_control(BUTTON, x, y, width, height, data));
+  TERN_(TOUCH_SCREEN, if (enabled) touch.add_control(BUTTON, x, y, width, height, data));
 }
 
 void MarlinUI::move_axis_screen() {
   // Reset
   defer_status_screen(true);
   motionAxisState.blocked = false;
-  TERN_(HAS_TFT_XPT2046, touch.enable());
+  TERN_(TOUCH_SCREEN, touch.enable());
 
   ui.clear_lcd();
 
   TERN_(TOUCH_SCREEN, touch.clear());
 
   const bool busy = printingIsActive();
 
   // Babysteps during printing? Select babystep for Z probe offset
   if (busy && ENABLED(BABYSTEP_ZPROBE_OFFSET))
     motionAxisState.z_selection = Z_SELECTION_Z_PROBE;
@@ -942,182 +989,196 @@ void MarlinUI::move_axis_screen() {
 
     drawBtn(x, y, "E+", (intptr_t)e_plus, imgUp, E_BTN_COLOR, !busy);
 
     spacing = (TFT_WIDTH - X_MARGIN * 2 - 3 * BTN_WIDTH) / 2;
     x += BTN_WIDTH + spacing;
     uint16_t yplus_x = x;
     drawBtn(x, y, "Y+", (intptr_t)y_plus, imgUp, Y_BTN_COLOR, !busy);
 
     x += BTN_WIDTH + spacing;
     uint16_t zplus_x = x;
-    drawBtn(x, y, "Z+", (intptr_t)z_plus, imgUp, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); //only enabled when not busy or have baby step
+    #if HAS_Z_AXIS
+      drawBtn(x, y, "Z+", (intptr_t)z_plus, imgUp, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); //only enabled when not busy or have baby step
+    #endif
 
     // ROW 2 -> "Ex" CurY "Z"
     x = X_MARGIN;
     y += BTN_HEIGHT + 2;
 
     motionAxisState.eNamePos.x = x;
     motionAxisState.eNamePos.y = y;
-    drawCurESelection();
-    TERN_(HAS_TFT_XPT2046, if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, BTN_HEIGHT, (intptr_t)e_select));
+    #if HAS_EXTRUDERS
+      drawCurESelection();
+      TERN_(TOUCH_SCREEN, if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, BTN_HEIGHT, (intptr_t)e_select));
+    #endif
 
     motionAxisState.yValuePos.x = yplus_x;
     motionAxisState.yValuePos.y = y;
     drawAxisValue(Y_AXIS);
 
     motionAxisState.zTypePos.x = zplus_x;
     motionAxisState.zTypePos.y = y;
-    drawCurZSelection();
+    TERN_(HAS_Z_AXIS, drawCurZSelection());
 
     // ROW 3 -> X-    HOME    X+
     y += (TFT_HEIGHT - Y_MARGIN * 2 - 4 * BTN_HEIGHT) / 3 - 2;
     x = X_MARGIN;
 
     drawBtn(x, y, "X-", (intptr_t)x_minus, imgLeft, X_BTN_COLOR, !busy);
 
-    TERN_(HAS_TFT_XPT2046, add_control(TFT_WIDTH / 2 - Images[imgHome].width / 2, y - (Images[imgHome].width - BTN_HEIGHT) / 2, BUTTON, (intptr_t)do_home, imgHome, !busy));
+    TERN_(TOUCH_SCREEN, add_control(TFT_WIDTH / 2 - Images[imgHome].width / 2, y - (Images[imgHome].width - BTN_HEIGHT) / 2, BUTTON, (intptr_t)do_home, imgHome, !busy));
 
     drawBtn(zplus_x, y, "X+", (intptr_t)x_plus, imgRight, X_BTN_COLOR, !busy);
 
     #if BOTH(HAS_BED_PROBE, TOUCH_SCREEN)
       if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, 34 * 2, (intptr_t)z_select);
     #endif
 
     // ROW 4 -> Cur X
     y += BTN_HEIGHT + 2;
 
     motionAxisState.xValuePos.x = x;
     motionAxisState.xValuePos.y = y;
     drawAxisValue(X_AXIS);
 
     // ROW 5 -> E- CurX Y-    Z-
     y += (TFT_HEIGHT - Y_MARGIN * 2 - 4 * BTN_HEIGHT) / 3 - 2;
     x = X_MARGIN;
 
-    drawBtn(x, y, "E-", (intptr_t)e_minus, imgDown, E_BTN_COLOR, !busy);
+    #if HAS_EXTRUDERS
+      drawBtn(x, y, "E-", (intptr_t)e_minus, imgDown, E_BTN_COLOR, !busy);
+    #endif
 
     // Cur E
     motionAxisState.eValuePos.x = x;
     motionAxisState.eValuePos.y = y + BTN_HEIGHT + 2;
-    drawAxisValue(E_AXIS);
+    TERN_(HAS_EXTRUDERS, drawAxisValue(E_AXIS));
 
     x += BTN_WIDTH + spacing;
     drawBtn(x, y, "Y-", (intptr_t)y_minus, imgDown, Y_BTN_COLOR, !busy);
 
     x += BTN_WIDTH + spacing;
-    drawBtn(x, y, "Z-", (intptr_t)z_minus, imgDown, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); //only enabled when not busy or have baby step
+    #if HAS_Z_AXIS
+      drawBtn(x, y, "Z-", (intptr_t)z_minus, imgDown, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); //only enabled when not busy or have baby step
+    #endif
 
     // Cur Z
     motionAxisState.zValuePos.x = x;
     motionAxisState.zValuePos.y = y + BTN_HEIGHT + 2;
-    drawAxisValue(Z_AXIS);
+    TERN_(HAS_Z_AXIS, drawAxisValue(Z_AXIS));
 
     // ROW 6 -> step_size    disable steppers back
     y = TFT_HEIGHT - Y_MARGIN - BTN_HEIGHT; //
     x = zplus_x - CUR_STEP_VALUE_WIDTH - 10;
     motionAxisState.stepValuePos.x = X_MARGIN + BTN_WIDTH - CUR_STEP_VALUE_WIDTH;
     motionAxisState.stepValuePos.y = TFT_HEIGHT - Y_MARGIN - BTN_HEIGHT;
 
     if (!busy) {
         drawCurStepValue();
-        TERN_(HAS_TFT_XPT2046, touch.add_control(BUTTON, motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y, CUR_STEP_VALUE_WIDTH, BTN_HEIGHT, (intptr_t)step_size));
+        TERN_(TOUCH_SCREEN, touch.add_control(BUTTON, motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y, CUR_STEP_VALUE_WIDTH, BTN_HEIGHT, (intptr_t)step_size));
     }
 
     // aligned with x+
     drawBtn(yplus_x, y, "off", (intptr_t)disable_steppers, imgCancel, COLOR_WHITE, !busy);
 
   #else // !TFT_COLOR_UI_PORTRAIT
 
     // ROW 1 -> E+ Y+ CurY Z+
     int x = X_MARGIN, y = Y_MARGIN, spacing = 0;
 
-    drawBtn(x, y, "E+", (intptr_t)e_plus, imgUp, E_BTN_COLOR, !busy);
+    TERN_(HAS_EXTRUDERS, drawBtn(x, y, "E+", (intptr_t)e_plus, imgUp, E_BTN_COLOR, !busy));
 
     spacing = (TFT_WIDTH - X_MARGIN * 2 - 3 * BTN_WIDTH) / 2;
     x += BTN_WIDTH + spacing;
     uint16_t yplus_x = x;
     drawBtn(x, y, "Y+", (intptr_t)y_plus, imgUp, Y_BTN_COLOR, !busy);
 
     // Cur Y
     x += BTN_WIDTH;
     motionAxisState.yValuePos.x = x + 2;
     motionAxisState.yValuePos.y = y;
     drawAxisValue(Y_AXIS);
 
     x += spacing;
-    drawBtn(x, y, "Z+", (intptr_t)z_plus, imgUp, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); //only enabled when not busy or have baby step
+    #if HAS_Z_AXIS
+      drawBtn(x, y, "Z+", (intptr_t)z_plus, imgUp, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); //only enabled when not busy or have baby step
+    #endif
 
     // ROW 2 -> "Ex"    X-    HOME X+    "Z"
     y += BTN_HEIGHT + (TFT_HEIGHT - Y_MARGIN * 2 - 4 * BTN_HEIGHT) / 3;
     x = X_MARGIN;
     spacing = (TFT_WIDTH - X_MARGIN * 2 - 5 * BTN_WIDTH) / 4;
 
     motionAxisState.eNamePos.x = x;
     motionAxisState.eNamePos.y = y;
-    drawCurESelection();
-    TERN_(HAS_TFT_XPT2046, if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, BTN_HEIGHT, (intptr_t)e_select));
+    #if HAS_EXTRUDERS
+      drawCurESelection();
+      TERN_(TOUCH_SCREEN, if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, BTN_HEIGHT, (intptr_t)e_select));
+    #endif
 
     x += BTN_WIDTH + spacing;
     drawBtn(x, y, "X-", (intptr_t)x_minus, imgLeft, X_BTN_COLOR, !busy);
 
     x += BTN_WIDTH + spacing; //imgHome is 64x64
-    TERN_(HAS_TFT_XPT2046, add_control(TFT_WIDTH / 2 - Images[imgHome].width / 2, y - (Images[imgHome].width - BTN_HEIGHT) / 2, BUTTON, (intptr_t)do_home, imgHome, !busy));
+    TERN_(TOUCH_SCREEN, add_control(TFT_WIDTH / 2 - Images[imgHome].width / 2, y - (Images[imgHome].width - BTN_HEIGHT) / 2, BUTTON, (intptr_t)do_home, imgHome, !busy));
 
     x += BTN_WIDTH + spacing;
     uint16_t xplus_x = x;
     drawBtn(x, y, "X+", (intptr_t)x_plus, imgRight, X_BTN_COLOR, !busy);
 
     x += BTN_WIDTH + spacing;
     motionAxisState.zTypePos.x = x;
     motionAxisState.zTypePos.y = y;
-    drawCurZSelection();
+    TERN_(HAS_Z_AXIS, drawCurZSelection());
     #if BOTH(HAS_BED_PROBE, TOUCH_SCREEN)
-        if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, 34 * 2, (intptr_t)z_select);
+      if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, 34 * 2, (intptr_t)z_select);
     #endif
 
     // ROW 3 -> E- CurX Y-    Z-
     y += BTN_HEIGHT + (TFT_HEIGHT - Y_MARGIN * 2 - 4 * BTN_HEIGHT) / 3;
     x = X_MARGIN;
     spacing = (TFT_WIDTH - X_MARGIN * 2 - 3 * BTN_WIDTH) / 2;
 
-    drawBtn(x, y, "E-", (intptr_t)e_minus, imgDown, E_BTN_COLOR, !busy);
+    TERN_(HAS_EXTRUDERS, drawBtn(x, y, "E-", (intptr_t)e_minus, imgDown, E_BTN_COLOR, !busy));
 
     // Cur E
     motionAxisState.eValuePos.x = x;
     motionAxisState.eValuePos.y = y + BTN_HEIGHT + 2;
-    drawAxisValue(E_AXIS);
+    TERN_(HAS_EXTRUDERS, drawAxisValue(E_AXIS));
 
     // Cur X
     motionAxisState.xValuePos.x = BTN_WIDTH + (TFT_WIDTH - X_MARGIN * 2 - 5 * BTN_WIDTH) / 4; //X- pos
     motionAxisState.xValuePos.y = y - 10;
     drawAxisValue(X_AXIS);
 
     x += BTN_WIDTH + spacing;
     drawBtn(x, y, "Y-", (intptr_t)y_minus, imgDown, Y_BTN_COLOR, !busy);
 
     x += BTN_WIDTH + spacing;
-    drawBtn(x, y, "Z-", (intptr_t)z_minus, imgDown, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); //only enabled when not busy or have baby step
+    #if HAS_Z_AXIS
+      drawBtn(x, y, "Z-", (intptr_t)z_minus, imgDown, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); //only enabled when not busy or have baby step
+    #endif
 
     // Cur Z
     motionAxisState.zValuePos.x = x;
     motionAxisState.zValuePos.y = y + BTN_HEIGHT + 2;
-    drawAxisValue(Z_AXIS);
+    TERN_(HAS_Z_AXIS, drawAxisValue(Z_AXIS));
 
     // ROW 4 -> step_size    disable steppers back
     y = TFT_HEIGHT - Y_MARGIN - BTN_HEIGHT; //
     x = xplus_x - CUR_STEP_VALUE_WIDTH - 10;
     motionAxisState.stepValuePos.x = yplus_x + BTN_WIDTH - CUR_STEP_VALUE_WIDTH;
     motionAxisState.stepValuePos.y = TFT_HEIGHT - Y_MARGIN - BTN_HEIGHT;
     if (!busy) {
         drawCurStepValue();
-        TERN_(HAS_TFT_XPT2046, touch.add_control(BUTTON, motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y, CUR_STEP_VALUE_WIDTH, BTN_HEIGHT, (intptr_t)step_size));
+        TERN_(TOUCH_SCREEN, touch.add_control(BUTTON, motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y, CUR_STEP_VALUE_WIDTH, BTN_HEIGHT, (intptr_t)step_size));
     }
 
     // aligned with x+
     drawBtn(xplus_x, y, "off", (intptr_t)disable_steppers, imgCancel, COLOR_WHITE, !busy);
 
   #endif // !TFT_COLOR_UI_PORTRAIT
 
-  TERN_(HAS_TFT_XPT2046, add_control(TFT_WIDTH - X_MARGIN - BTN_WIDTH, y, BACK, imgBack));
+  TERN_(TOUCH_SCREEN, add_control(TFT_WIDTH - X_MARGIN - BTN_WIDTH, y, BACK, imgBack));
 }
 
 #endif // HAS_UI_320x240

commit 5664c02d077e028f84a24efd96c2eebe97ce8763
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 22 22:43:09 2023 -0500

    üßë‚Äçüíª Generalize SDSUPPORT as HAS_MEDIA
    
    In preparation for single- and multi-volume refactoring.

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index e606dca7ce..bac7586a25 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -29,21 +29,21 @@
 #include "../marlinui.h"
 #include "../menu/menu.h"
 #include "../../libs/numtostr.h"
 
 #include "../../sd/cardreader.h"
 #include "../../module/temperature.h"
 #include "../../module/printcounter.h"
 #include "../../module/planner.h"
 #include "../../module/motion.h"
 
-#if DISABLED(LCD_PROGRESS_BAR) && BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
+#if DISABLED(LCD_PROGRESS_BAR) && BOTH(FILAMENT_LCD_DISPLAY, HAS_MEDIA)
   #include "../../feature/filwidth.h"
   #include "../../gcode/parser.h"
 #endif
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
   #include "../../feature/bedlevel/bedlevel.h"
 #endif
 
 void MarlinUI::tft_idle() {
   #if ENABLED(TOUCH_SCREEN)
@@ -441,21 +441,21 @@ void MarlinUI::draw_status_screen() {
   #if ENABLED(TOUCH_SCREEN)
   {
     add_control(
       #if ENABLED(TFT_COLOR_UI_PORTRAIT)
         176, 210
       #else
         256, 130
       #endif
       , menu_main, imgSettings
     );
-    #if ENABLED(SDSUPPORT)
+    #if HAS_MEDIA
       const bool cm = card.isMounted(), pa = printingIsActive();
       if (cm && pa)
         add_control(0, TERN(TFT_COLOR_UI_PORTRAIT, 210, 130), STOP, imgCancel, true, COLOR_CONTROL_CANCEL);
       else
         add_control(0, TERN(TFT_COLOR_UI_PORTRAIT, 210, 130), menu_media, imgSD, cm && !pa, COLOR_CONTROL_ENABLED, COLOR_CONTROL_DISABLED);
     #endif
   }
   #endif // TOUCH_SCREEN
 }
 

commit 89ccede139963091768985eeb4ca5a6e3111647c
Author: Alexey D. Filimonov <alexey@filimonic.net>
Date:   Sat Apr 22 12:06:19 2023 +0300

    üé® Clean up TFT Color UI display items (#25712)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index 11e4730239..e606dca7ce 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -223,39 +223,39 @@ void MarlinUI::draw_status_screen() {
   const bool blink = get_blink();
 
   TERN_(TOUCH_SCREEN, touch.clear());
 
   // heaters and fan
   uint16_t i, x, y = TFT_STATUS_TOP_Y;
 
   for (i = 0 ; i < ITEMS_COUNT; i++) {
     x = (TFT_WIDTH / ITEMS_COUNT - 64) / 2  + (TFT_WIDTH * i / ITEMS_COUNT);
     switch (i) {
-      #ifdef ITEM_E0
+      #if HAS_EXTRUDERS
         case ITEM_E0: draw_heater_status(x, y, H_E0); break;
       #endif
-      #ifdef ITEM_E1
+      #if HAS_MULTI_HOTEND
         case ITEM_E1: draw_heater_status(x, y, H_E1); break;
       #endif
-      #ifdef ITEM_E2
+      #if HOTENDS > 2
         case ITEM_E2: draw_heater_status(x, y, H_E2); break;
       #endif
-      #ifdef ITEM_BED
+      #if HAS_HEATED_BED
         case ITEM_BED: draw_heater_status(x, y, H_BED); break;
       #endif
-      #ifdef ITEM_CHAMBER
+      #if HAS_TEMP_CHAMBER
         case ITEM_CHAMBER: draw_heater_status(x, y, H_CHAMBER); break;
       #endif
-      #ifdef ITEM_COOLER
+      #if HAS_TEMP_COOLER
         case ITEM_COOLER: draw_heater_status(x, y, H_COOLER); break;
       #endif
-      #ifdef ITEM_FAN
+      #if HAS_FAN
         case ITEM_FAN: draw_fan_status(x, y, blink); break;
       #endif
     }
   }
 
   // coordinates
   tft.canvas(4, 103,
     #if ENABLED(TFT_COLOR_UI_PORTRAIT)
       232, FONT_LINE_HEIGHT * 2
     #else

commit 0021a58943721a81b1ef23fa5e7366cfd80a3d28
Author: Bob Kuhn <bob.kuhn@att.net>
Date:   Sun Mar 26 04:07:25 2023 -0500

    ‚ú® AnyCubic Vyper / Vyper LCD (#25405)

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index e8bec7e1a7..11e4730239 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -439,21 +439,21 @@ void MarlinUI::draw_status_screen() {
   tft.add_text(tft_string.center(TFT_WIDTH), tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_STATUS_MESSAGE, tft_string);
 
   #if ENABLED(TOUCH_SCREEN)
   {
     add_control(
       #if ENABLED(TFT_COLOR_UI_PORTRAIT)
         176, 210
       #else
         256, 130
       #endif
-	   , menu_main, imgSettings
+      , menu_main, imgSettings
     );
     #if ENABLED(SDSUPPORT)
       const bool cm = card.isMounted(), pa = printingIsActive();
       if (cm && pa)
         add_control(0, TERN(TFT_COLOR_UI_PORTRAIT, 210, 130), STOP, imgCancel, true, COLOR_CONTROL_CANCEL);
       else
         add_control(0, TERN(TFT_COLOR_UI_PORTRAIT, 210, 130), menu_media, imgSD, cm && !pa, COLOR_CONTROL_ENABLED, COLOR_CONTROL_DISABLED);
     #endif
   }
   #endif // TOUCH_SCREEN

commit 196f403dd6be59e1bcfd24f31895a1ebc551caac
Author: alexgrach <gav@bmstu.ru>
Date:   Wed Feb 15 09:40:26 2023 +0300

    üö∏ Stop button for Touch UI (#25379)

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index 76cce4dad1..e8bec7e1a7 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -443,23 +443,26 @@ void MarlinUI::draw_status_screen() {
     add_control(
       #if ENABLED(TFT_COLOR_UI_PORTRAIT)
         176, 210
       #else
         256, 130
       #endif
 	   , menu_main, imgSettings
     );
     #if ENABLED(SDSUPPORT)
       const bool cm = card.isMounted(), pa = printingIsActive();
-      add_control(0, TERN(TFT_COLOR_UI_PORTRAIT, 210, 130), menu_media, imgSD, cm && !pa, COLOR_CONTROL_ENABLED, cm && pa ? COLOR_BUSY : COLOR_CONTROL_DISABLED);
+      if (cm && pa)
+        add_control(0, TERN(TFT_COLOR_UI_PORTRAIT, 210, 130), STOP, imgCancel, true, COLOR_CONTROL_CANCEL);
+      else
+        add_control(0, TERN(TFT_COLOR_UI_PORTRAIT, 210, 130), menu_media, imgSD, cm && !pa, COLOR_CONTROL_ENABLED, COLOR_CONTROL_DISABLED);
     #endif
-  } // (sublime)
+  }
   #endif // TOUCH_SCREEN
 }
 
 // Low-level draw_edit_screen can be used to draw an edit screen from anyplace
 void MenuEditItemBase::draw_edit_screen(FSTR_P const fstr, const char * const value/*=nullptr*/) {
   ui.encoder_direction_normal();
   TERN_(TOUCH_SCREEN, touch.clear());
 
   uint16_t line = 1;
 
@@ -542,22 +545,22 @@ void MenuItem_confirm::draw_select_screen(FSTR_P const yes, FSTR_P const no, con
     tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
   }
 
   if (suff) {
     menu_line(line);
     tft_string.set(suff);
     tft_string.trim();
     tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
   }
   #if ENABLED(TOUCH_SCREEN)
-    if (no)  add_control(TERN(TFT_COLOR_UI_PORTRAIT, 32, 48), TFT_HEIGHT - 64, CANCEL,  imgCancel,  true, yesno ? HALF(COLOR_CONTROL_CANCEL) : COLOR_CONTROL_CANCEL);
-    if (yes) add_control(TERN(TFT_COLOR_UI_PORTRAIT, 172, 208), TFT_HEIGHT - 64, CONFIRM, imgConfirm, true, yesno ? COLOR_CONTROL_CONFIRM : HALF(COLOR_CONTROL_CONFIRM));
+    if (no)  add_control(TERN(TFT_COLOR_UI_PORTRAIT, 16, 48), TFT_HEIGHT - 64, CANCEL,  imgCancel,  true, yesno ? HALF(COLOR_CONTROL_CANCEL) : COLOR_CONTROL_CANCEL);
+    if (yes) add_control(TERN(TFT_COLOR_UI_PORTRAIT, 160, 208), TFT_HEIGHT - 64, CONFIRM, imgConfirm, true, yesno ? COLOR_CONTROL_CONFIRM : HALF(COLOR_CONTROL_CONFIRM));
   #endif
 }
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
 
   void MarlinUI::draw_hotend_status(const uint8_t row, const uint8_t extruder) {
     #if ENABLED(TOUCH_SCREEN)
       touch.clear();
       draw_menu_navigation = false;
       touch.add_control(RESUME_CONTINUE , 0, 0, TFT_WIDTH, TFT_HEIGHT);

commit fbe9237a6c934b8c16e39b879b04973063c3988c
Author: alexgrach <gav@bmstu.ru>
Date:   Wed Feb 1 10:40:13 2023 +0300

    üêõ Fix TFT touch buttons, button colors (#25300)

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index fa433645d7..76cce4dad1 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -667,25 +667,20 @@ struct MotionAxisState {
   xy_int_t xValuePos, yValuePos, zValuePos, eValuePos, stepValuePos, zTypePos, eNamePos;
   float currentStepSize = 10.0;
   int z_selection = Z_SELECTION_Z;
   uint8_t e_selection = 0;
   bool blocked = false;
   char message[32];
 };
 
 MotionAxisState motionAxisState;
 
-#define E_BTN_COLOR COLOR_YELLOW
-#define X_BTN_COLOR COLOR_CORAL_RED
-#define Y_BTN_COLOR COLOR_VIVID_GREEN
-#define Z_BTN_COLOR COLOR_LIGHT_BLUE
-
 #define BTN_WIDTH 48
 #define BTN_HEIGHT 39
 #define X_MARGIN 15
 #define Y_MARGIN 11
 
 static void quick_feedback() {
   #if HAS_CHIRP
     ui.chirp(); // Buzz and wait. Is the delay needed for buttons to settle?
     #if BOTH(HAS_MARLINUI_MENU, HAS_BEEPER)
       for (int8_t i = 5; i--;) { buzzer.tick(); delay(2); }

commit b7c23631c5840e2338cae531b171459e9e9c5301
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Sun Jan 22 15:08:37 2023 +1300

    üêõ Fix misc. UI issues (#25252)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index 07fa957327..fa433645d7 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -761,26 +761,24 @@ static void drawAxisValue(const AxisEnum axis) {
   }
   tft.canvas(pos.x, pos.y, BTN_WIDTH + X_MARGIN, FONT_LINE_HEIGHT);
   tft.set_background(COLOR_BACKGROUND);
   tft_string.set(ftostr52sp(value));
   tft.add_text(0, 0, color, tft_string);
 }
 
 static void moveAxis(const AxisEnum axis, const int8_t direction) {
   quick_feedback();
 
-  #if ENABLED(PREVENT_COLD_EXTRUSION)
-    if (axis == E_AXIS && thermalManager.tooColdToExtrude(motionAxisState.e_selection)) {
-      drawMessage(F("Too cold"));
-      return;
-    }
-  #endif
+  if (axis == E_AXIS && thermalManager.tooColdToExtrude(motionAxisState.e_selection)) {
+    drawMessage(F("Too cold"));
+    return;
+  }
 
   const float diff = motionAxisState.currentStepSize * direction;
 
   if (axis == Z_AXIS && motionAxisState.z_selection == Z_SELECTION_Z_PROBE) {
     #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
       const int16_t babystep_increment = direction * BABYSTEP_SIZE_Z;
       const bool do_probe = DISABLED(BABYSTEP_HOTEND_Z_OFFSET) || active_extruder == 0;
       const float bsDiff = planner.mm_per_step[Z_AXIS] * babystep_increment,
                   new_probe_offset = probe.offset.z + bsDiff,
                   new_offs = TERN(BABYSTEP_HOTEND_Z_OFFSET

commit 99d1b04a1f1d66aef78994fd98189a9ba9acbcb1
Author: alexgrach <gav@bmstu.ru>
Date:   Wed Jan 18 02:37:19 2023 +0300

    ‚ú® TFT 320x240 portrait (#25207)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index 85ed59b2cc..07fa957327 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -42,23 +42,25 @@
 #endif
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
   #include "../../feature/bedlevel/bedlevel.h"
 #endif
 
 void MarlinUI::tft_idle() {
   #if ENABLED(TOUCH_SCREEN)
     if (TERN0(HAS_TOUCH_SLEEP, lcd_sleep_task())) return;
     if (draw_menu_navigation) {
-      add_control(48, 206, PAGE_UP, imgPageUp, encoderTopLine > 0);
-      add_control(240, 206, PAGE_DOWN, imgPageDown, encoderTopLine + LCD_HEIGHT < screen_items);
-      add_control(144, 206, BACK, imgBack);
+      constexpr uint16_t cx = TERN(TFT_COLOR_UI_PORTRAIT,  16,  48),
+                         cy = TERN(TFT_COLOR_UI_PORTRAIT, 286, 206);
+      add_control(cx, cy, PAGE_UP, imgPageUp, encoderTopLine > 0);
+      add_control(cx + 192, cy, PAGE_DOWN, imgPageDown, encoderTopLine + LCD_HEIGHT < screen_items);
+      add_control(cx + 96, cy, BACK, imgBack);
       draw_menu_navigation = false;
     }
   #endif
 
   tft.queue.async();
 
   TERN_(TOUCH_SCREEN, if (tft.queue.is_empty()) touch.idle()); // Touch driver is not DMA-aware, so only check for touch controls after screen drawing is completed
 }
 
 #if ENABLED(SHOW_BOOTSCREEN)
@@ -90,33 +92,33 @@ void MarlinUI::tft_idle() {
     if ((BOOTSCREEN_TIMEOUT) > sofar) safe_delay((BOOTSCREEN_TIMEOUT) - sofar);
     clear_lcd();
   }
 
 #endif
 
 void MarlinUI::draw_kill_screen() {
   tft.queue.reset();
   tft.fill(0, 0, TFT_WIDTH, TFT_HEIGHT, COLOR_KILL_SCREEN_BG);
 
-  tft.canvas(0, 60, TFT_WIDTH, 24);
+  tft.canvas(0, 60, TFT_WIDTH, FONT_LINE_HEIGHT);
   tft.set_background(COLOR_KILL_SCREEN_BG);
   tft_string.set(status_message);
   tft_string.trim();
   tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_KILL_SCREEN_TEXT, tft_string);
 
-  tft.canvas(0, 120, TFT_WIDTH, 24);
+  tft.canvas(0, 120, TFT_WIDTH, FONT_LINE_HEIGHT);
   tft.set_background(COLOR_KILL_SCREEN_BG);
   tft_string.set(GET_TEXT(MSG_HALTED));
   tft_string.trim();
   tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_KILL_SCREEN_TEXT, tft_string);
 
-  tft.canvas(0, 160, TFT_WIDTH, 24);
+  tft.canvas(0, 160, TFT_WIDTH, FONT_LINE_HEIGHT);
   tft.set_background(COLOR_KILL_SCREEN_BG);
   tft_string.set(GET_TEXT(MSG_PLEASE_RESET));
   tft_string.trim();
   tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_KILL_SCREEN_TEXT, tft_string);
 
   tft.queue.sync();
 }
 
 void draw_heater_status(uint16_t x, uint16_t y, const int8_t Heater) {
   MarlinImage image = imgHotEnd;
@@ -178,27 +180,27 @@ void draw_heater_status(uint16_t x, uint16_t y, const int8_t Heater) {
       if (currentTemperature > 26) Color = COLOR_RED;
       image = targetTemperature > 26 ? imgCoolerHot : imgCooler;
     }
   #endif
 
   tft.add_image(0, 18, image, Color);
 
   tft_string.set(i16tostr3rj(currentTemperature));
   tft_string.add(LCD_STR_DEGREE);
   tft_string.trim();
-  tft.add_text(tft_string.center(64) + 2, 69 + tft_string.vcenter(24), Color, tft_string);
+  tft.add_text(tft_string.center(64) + 2, 69 + tft_string.vcenter(FONT_LINE_HEIGHT), Color, tft_string);
 
   if (targetTemperature >= 0) {
     tft_string.set(i16tostr3rj(targetTemperature));
     tft_string.add(LCD_STR_DEGREE);
     tft_string.trim();
-    tft.add_text(tft_string.center(64) + 2, 5 + tft_string.vcenter(24), Color, tft_string);
+    tft.add_text(tft_string.center(64) + 2, 5 + tft_string.vcenter(FONT_LINE_HEIGHT), Color, tft_string);
   }
 }
 
 void draw_fan_status(uint16_t x, uint16_t y, const bool blink) {
   TERN_(TOUCH_SCREEN, touch.add_control(FAN, x, y, 64, 100));
   tft.canvas(x, y, 64, 100);
   tft.set_background(COLOR_BACKGROUND);
 
   uint8_t fanSpeed = thermalManager.fan_speed[0];
   MarlinImage image;
@@ -207,33 +209,33 @@ void draw_fan_status(uint16_t x, uint16_t y, const bool blink) {
     image = blink ? imgFanFast1 : imgFanFast0;
   else if (fanSpeed > 0)
     image = blink ? imgFanSlow1 : imgFanSlow0;
   else
     image = imgFanIdle;
 
   tft.add_image(0, 10, image, COLOR_FAN);
 
   tft_string.set(ui8tostr4pctrj(thermalManager.fan_speed[0]));
   tft_string.trim();
-  tft.add_text(tft_string.center(64) + 6, 69 + tft_string.vcenter(24), COLOR_FAN, tft_string);
+  tft.add_text(tft_string.center(64) + 6, 69 + tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_FAN, tft_string);
 }
 
 void MarlinUI::draw_status_screen() {
   const bool blink = get_blink();
 
   TERN_(TOUCH_SCREEN, touch.clear());
 
   // heaters and fan
   uint16_t i, x, y = TFT_STATUS_TOP_Y;
 
   for (i = 0 ; i < ITEMS_COUNT; i++) {
-    x = (320 / ITEMS_COUNT - 64) / 2  + (320 * i / ITEMS_COUNT);
+    x = (TFT_WIDTH / ITEMS_COUNT - 64) / 2  + (TFT_WIDTH * i / ITEMS_COUNT);
     switch (i) {
       #ifdef ITEM_E0
         case ITEM_E0: draw_heater_status(x, y, H_E0); break;
       #endif
       #ifdef ITEM_E1
         case ITEM_E1: draw_heater_status(x, y, H_E1); break;
       #endif
       #ifdef ITEM_E2
         case ITEM_E2: draw_heater_status(x, y, H_E2); break;
       #endif
@@ -246,115 +248,219 @@ void MarlinUI::draw_status_screen() {
       #ifdef ITEM_COOLER
         case ITEM_COOLER: draw_heater_status(x, y, H_COOLER); break;
       #endif
       #ifdef ITEM_FAN
         case ITEM_FAN: draw_fan_status(x, y, blink); break;
       #endif
     }
   }
 
   // coordinates
-  tft.canvas(4, 103, 312, 24);
+  tft.canvas(4, 103,
+    #if ENABLED(TFT_COLOR_UI_PORTRAIT)
+      232, FONT_LINE_HEIGHT * 2
+    #else
+      312, FONT_LINE_HEIGHT
+    #endif
+  );
   tft.set_background(COLOR_BACKGROUND);
-  tft.add_rectangle(0, 0, 312, 24, COLOR_AXIS_HOMED);
+  tft.add_rectangle(0, 0,
+    #if ENABLED(TFT_COLOR_UI_PORTRAIT)
+      232, FONT_LINE_HEIGHT * 2
+    #else
+      312, FONT_LINE_HEIGHT
+    #endif
+    , COLOR_AXIS_HOMED
+  );
 
   if (TERN0(LCD_SHOW_E_TOTAL, printingIsActive())) {
     #if ENABLED(LCD_SHOW_E_TOTAL)
-      tft.add_text( 10, tft_string.vcenter(24), COLOR_AXIS_HOMED , "E");
+      tft.add_text( 10, tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED , "E");
       const uint8_t escale = e_move_accumulator >= 100000.0f ? 10 : 1; // After 100m switch to cm
       tft_string.set(ftostr4sign(e_move_accumulator / escale));
       tft_string.add(escale == 10 ? 'c' : 'm');
       tft_string.add('m');
-      tft.add_text(127 - tft_string.width(), tft_string.vcenter(24), COLOR_AXIS_HOMED, tft_string);
+      tft.add_text(127 - tft_string.width(), tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED, tft_string);
     #endif
   }
   else {
-    tft.add_text( 10, tft_string.vcenter(24), COLOR_AXIS_HOMED , "X");
+    tft.add_text(TERN(TFT_COLOR_UI_PORTRAIT, 32, 10), tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED , "X");
     const bool nhx = axis_should_home(X_AXIS);
     tft_string.set(blink && nhx ? "?" : ftostr4sign(LOGICAL_X_POSITION(current_position.x)));
-    tft.add_text( 68 - tft_string.width(), tft_string.vcenter(24), nhx ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
+    tft.add_text(
+      #if ENABLED(TFT_COLOR_UI_PORTRAIT)
+        32 - tft_string.width() / 2, FONT_LINE_HEIGHT + tft_string.vcenter(FONT_LINE_HEIGHT),
+      #else
+        68 - tft_string.width(), tft_string.vcenter(FONT_LINE_HEIGHT),
+      #endif
+      nhx ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string
+    );
 
-    tft.add_text(127, tft_string.vcenter(24), COLOR_AXIS_HOMED , "Y");
+    tft.add_text(TERN(TFT_COLOR_UI_PORTRAIT, 110, 127), tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED , "Y");
     const bool nhy = axis_should_home(Y_AXIS);
     tft_string.set(blink && nhy ? "?" : ftostr4sign(LOGICAL_Y_POSITION(current_position.y)));
-    tft.add_text(185 - tft_string.width(), tft_string.vcenter(24), nhy ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
+    tft.add_text(
+      #if ENABLED(TFT_COLOR_UI_PORTRAIT)
+        110 - tft_string.width() / 2, FONT_LINE_HEIGHT + tft_string.vcenter(FONT_LINE_HEIGHT),
+      #else
+        185 - tft_string.width(), tft_string.vcenter(FONT_LINE_HEIGHT),
+      #endif
+      nhy ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string
+    );
   }
 
-  tft.add_text(219, tft_string.vcenter(24), COLOR_AXIS_HOMED , "Z");
+  tft.add_text(TERN(TFT_COLOR_UI_PORTRAIT, 192, 219), tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_AXIS_HOMED , "Z");
   const bool nhz = axis_should_home(Z_AXIS);
   uint16_t offset = 25;
   if (blink && nhz)
     tft_string.set('?');
   else {
     const float z = LOGICAL_Z_POSITION(current_position.z);
     tft_string.set(ftostr52sp((int16_t)z));
     tft_string.rtrim();
     offset += tft_string.width();
 
     tft_string.set(ftostr52sp(z));
     offset -= tft_string.width();
   }
-  tft.add_text(301 - tft_string.width() - offset, tft_string.vcenter(24), nhz ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
-  TERN_(TOUCH_SCREEN, touch.add_control(MOVE_AXIS, 0, 103, 312, 24));
+  tft.add_text(
+    #if ENABLED(TFT_COLOR_UI_PORTRAIT)
+      192 - tft_string.width() / 2, FONT_LINE_HEIGHT + tft_string.vcenter(FONT_LINE_HEIGHT),
+    #else
+      301 - tft_string.width() - offset, tft_string.vcenter(FONT_LINE_HEIGHT),
+    #endif
+  nhz ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
+  TERN_(TOUCH_SCREEN, touch.add_control(MOVE_AXIS, 0, 103,
+    #if ENABLED(TFT_COLOR_UI_PORTRAIT)
+      232, FONT_LINE_HEIGHT * 2
+    #else
+      312, FONT_LINE_HEIGHT
+    #endif
+  ));
 
   // feed rate
-  tft.canvas(70, 136, 84, 32);
+  tft.canvas(
+    #if ENABLED(TFT_COLOR_UI_PORTRAIT)
+      30, 172, 80
+    #else
+      70, 136, 84
+    #endif
+    , 32
+  );
   tft.set_background(COLOR_BACKGROUND);
   uint16_t color = feedrate_percentage == 100 ? COLOR_RATE_100 : COLOR_RATE_ALTERED;
   tft.add_image(0, 0, imgFeedRate, color);
   tft_string.set(i16tostr3rj(feedrate_percentage));
   tft_string.add('%');
   tft.add_text(32, tft_string.vcenter(30), color , tft_string);
-  TERN_(TOUCH_SCREEN, touch.add_control(FEEDRATE, 70, 136, 84, 32));
+  TERN_(TOUCH_SCREEN, touch.add_control(FEEDRATE,
+    #if ENABLED(TFT_COLOR_UI_PORTRAIT)
+      30, 172, 80
+    #else
+      70, 136, 84
+    #endif
+    , 32
+  ));
 
   // flow rate
-  tft.canvas(170, 136, 84, 32);
+  tft.canvas(
+    #if ENABLED(TFT_COLOR_UI_PORTRAIT)
+      140, 172, 80
+    #else
+      170, 136, 84
+    #endif
+    , 32
+  );
   tft.set_background(COLOR_BACKGROUND);
   color = planner.flow_percentage[0] == 100 ? COLOR_RATE_100 : COLOR_RATE_ALTERED;
   tft.add_image(0, 0, imgFlowRate, color);
   tft_string.set(i16tostr3rj(planner.flow_percentage[active_extruder]));
   tft_string.add('%');
   tft.add_text(32, tft_string.vcenter(30), color , tft_string);
-  TERN_(TOUCH_SCREEN, touch.add_control(FLOWRATE, 170, 136, 84, 32, active_extruder));
+  TERN_(TOUCH_SCREEN, touch.add_control(FLOWRATE,
+    #if ENABLED(TFT_COLOR_UI_PORTRAIT)
+      140, 172, 80
+    #else
+      170, 136, 84
+    #endif
+    , 32, active_extruder
+  ));
 
   // print duration
   char buffer[14];
   duration_t elapsed = print_job_timer.duration();
   elapsed.toDigital(buffer);
 
-  tft.canvas(96, 173, 128, 24);
+  tft.canvas(
+    #if ENABLED(TFT_COLOR_UI_PORTRAIT)
+      56, 256, 128
+    #else
+      96, 173, 128
+    #endif
+    , FONT_LINE_HEIGHT
+  );
   tft.set_background(COLOR_BACKGROUND);
   tft_string.set(buffer);
-  tft.add_text(tft_string.center(128), tft_string.vcenter(24), COLOR_PRINT_TIME, tft_string);
+  tft.add_text(tft_string.center(128), tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_PRINT_TIME, tft_string);
 
   // progress bar
   const uint8_t progress = ui.get_progress_percent();
-  tft.canvas(4, 198, 312, 9);
+  tft.canvas(
+    #if ENABLED(TFT_COLOR_UI_PORTRAIT)
+      4, 278, 232
+    #else
+      4, 198, 312
+    #endif
+    , 9
+  );
   tft.set_background(COLOR_PROGRESS_BG);
-  tft.add_rectangle(0, 0, 312, 9, COLOR_PROGRESS_FRAME);
+  tft.add_rectangle(0, 0,
+    #if ENABLED(TFT_COLOR_UI_PORTRAIT)
+      232, 9
+    #else
+      312, 9
+    #endif
+    , COLOR_PROGRESS_FRAME
+  );
   if (progress)
-    tft.add_bar(1, 1, (310 * progress) / 100, 7, COLOR_PROGRESS_BAR);
+    tft.add_bar(1, 1, ((TFT_WIDTH - 10) * progress) / 100, 7, COLOR_PROGRESS_BAR);
 
   // status message
-  tft.canvas(0, 212, 320, 24);
+  tft.canvas(
+    #if ENABLED(TFT_COLOR_UI_PORTRAIT)
+      0, 296, 240
+    #else
+      0, 212, 320
+    #endif
+    , FONT_LINE_HEIGHT
+  );
   tft.set_background(COLOR_BACKGROUND);
   tft_string.set(status_message);
   tft_string.trim();
-  tft.add_text(tft_string.center(TFT_WIDTH), tft_string.vcenter(24), COLOR_STATUS_MESSAGE, tft_string);
+  tft.add_text(tft_string.center(TFT_WIDTH), tft_string.vcenter(FONT_LINE_HEIGHT), COLOR_STATUS_MESSAGE, tft_string);
 
   #if ENABLED(TOUCH_SCREEN)
-    add_control(256, 130, menu_main, imgSettings);
+  {
+    add_control(
+      #if ENABLED(TFT_COLOR_UI_PORTRAIT)
+        176, 210
+      #else
+        256, 130
+      #endif
+	   , menu_main, imgSettings
+    );
     #if ENABLED(SDSUPPORT)
       const bool cm = card.isMounted(), pa = printingIsActive();
-      add_control(0, 130, menu_media, imgSD, cm && !pa, COLOR_CONTROL_ENABLED, cm && pa ? COLOR_BUSY : COLOR_CONTROL_DISABLED);
+      add_control(0, TERN(TFT_COLOR_UI_PORTRAIT, 210, 130), menu_media, imgSD, cm && !pa, COLOR_CONTROL_ENABLED, cm && pa ? COLOR_BUSY : COLOR_CONTROL_DISABLED);
     #endif
-  #endif
+  } // (sublime)
+  #endif // TOUCH_SCREEN
 }
 
 // Low-level draw_edit_screen can be used to draw an edit screen from anyplace
 void MenuEditItemBase::draw_edit_screen(FSTR_P const fstr, const char * const value/*=nullptr*/) {
   ui.encoder_direction_normal();
   TERN_(TOUCH_SCREEN, touch.clear());
 
   uint16_t line = 1;
 
   menu_line(line++);
@@ -405,23 +511,23 @@ void MenuEditItemBase::draw_edit_screen(FSTR_P const fstr, const char * const va
       tft.add_image((SLIDER_LENGTH - 8) * ui.encoderPosition / maxEditValue, 0, imgSlider, COLOR_SLIDER);
       touch.add_control(SLIDER, (TFT_WIDTH - SLIDER_LENGTH) / 2, SLIDER_Y_POSITION - 8, SLIDER_LENGTH, 32, maxEditValue);
     #endif
   }
 
   tft.draw_edit_screen_buttons();
 }
 
 void TFT::draw_edit_screen_buttons() {
   #if ENABLED(TOUCH_SCREEN)
-    add_control(32, TFT_HEIGHT - 64, DECREASE, imgDecrease);
-    add_control(224, TFT_HEIGHT - 64, INCREASE, imgIncrease);
-    add_control(128, TFT_HEIGHT - 64, CLICK, imgConfirm);
+    add_control(TERN(TFT_COLOR_UI_PORTRAIT, 16, 32), TFT_HEIGHT - 64, DECREASE, imgDecrease);
+    add_control(TERN(TFT_COLOR_UI_PORTRAIT, 172, 224), TFT_HEIGHT - 64, INCREASE, imgIncrease);
+    add_control(TERN(TFT_COLOR_UI_PORTRAIT, 96, 128), TFT_HEIGHT - 64, CLICK, imgConfirm);
   #endif
 }
 
 // The Select Screen presents a prompt and two "buttons"
 void MenuItem_confirm::draw_select_screen(FSTR_P const yes, FSTR_P const no, const bool yesno, FSTR_P const pref, const char * const string/*=nullptr*/, FSTR_P const suff/*=nullptr*/) {
   uint16_t line = 1;
 
   if (!string) line++;
 
   menu_line(line++);
@@ -436,22 +542,22 @@ void MenuItem_confirm::draw_select_screen(FSTR_P const yes, FSTR_P const no, con
     tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
   }
 
   if (suff) {
     menu_line(line);
     tft_string.set(suff);
     tft_string.trim();
     tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
   }
   #if ENABLED(TOUCH_SCREEN)
-    if (no)  add_control( 48, TFT_HEIGHT - 64, CANCEL,  imgCancel,  true, yesno ? HALF(COLOR_CONTROL_CANCEL) : COLOR_CONTROL_CANCEL);
-    if (yes) add_control(208, TFT_HEIGHT - 64, CONFIRM, imgConfirm, true, yesno ? COLOR_CONTROL_CONFIRM : HALF(COLOR_CONTROL_CONFIRM));
+    if (no)  add_control(TERN(TFT_COLOR_UI_PORTRAIT, 32, 48), TFT_HEIGHT - 64, CANCEL,  imgCancel,  true, yesno ? HALF(COLOR_CONTROL_CANCEL) : COLOR_CONTROL_CANCEL);
+    if (yes) add_control(TERN(TFT_COLOR_UI_PORTRAIT, 172, 208), TFT_HEIGHT - 64, CONFIRM, imgConfirm, true, yesno ? COLOR_CONTROL_CONFIRM : HALF(COLOR_CONTROL_CONFIRM));
   #endif
 }
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
 
   void MarlinUI::draw_hotend_status(const uint8_t row, const uint8_t extruder) {
     #if ENABLED(TOUCH_SCREEN)
       touch.clear();
       draw_menu_navigation = false;
       touch.add_control(RESUME_CONTINUE , 0, 0, TFT_WIDTH, TFT_HEIGHT);
@@ -618,42 +724,49 @@ static void drawCurZSelection() {
 
 static void drawCurESelection() {
   tft.canvas(motionAxisState.eNamePos.x, motionAxisState.eNamePos.y, BTN_WIDTH, BTN_HEIGHT);
   tft.set_background(COLOR_BACKGROUND);
   tft_string.set('E');
   tft.add_text(0, 0, E_BTN_COLOR , tft_string);
   tft.add_text(tft_string.width(), 0, E_BTN_COLOR, ui8tostr3rj(motionAxisState.e_selection));
 }
 
 static void drawMessage(PGM_P const msg) {
-  tft.canvas(X_MARGIN, TFT_HEIGHT - Y_MARGIN - 29, (TFT_WIDTH / 2) - (BTN_WIDTH / 2) - X_MARGIN, 20);
+  tft.canvas(X_MARGIN,
+    #if ENABLED(TFT_COLOR_UI_PORTRAIT)
+      TFT_HEIGHT - 2 * BTN_HEIGHT, TFT_WIDTH - X_MARGIN
+    #else
+      TFT_HEIGHT - Y_MARGIN - 29, (TFT_WIDTH / 2) - (BTN_WIDTH / 2) - X_MARGIN
+    #endif
+    , FONT_LINE_HEIGHT
+  );
   tft.set_background(COLOR_BACKGROUND);
-  tft.add_text(0, 0, COLOR_YELLOW, msg);
+  tft.add_text(0, 0, COLOR_STATUS_MESSAGE, msg);
 }
 
 static void drawMessage(FSTR_P const fmsg) { drawMessage(FTOP(fmsg)); }
 
 static void drawAxisValue(const AxisEnum axis) {
   const float value = (
     TERN_(HAS_BED_PROBE, axis == Z_AXIS && motionAxisState.z_selection == Z_SELECTION_Z_PROBE ? probe.offset.z :)
     ui.manual_move.axis_value(axis)
   );
   xy_int_t pos;
   uint16_t color;
   switch (axis) {
     case X_AXIS: pos = motionAxisState.xValuePos; color = X_BTN_COLOR; break;
     case Y_AXIS: pos = motionAxisState.yValuePos; color = Y_BTN_COLOR; break;
     case Z_AXIS: pos = motionAxisState.zValuePos; color = Z_BTN_COLOR; break;
     case E_AXIS: pos = motionAxisState.eValuePos; color = E_BTN_COLOR; break;
     default: return;
   }
-  tft.canvas(pos.x, pos.y, BTN_WIDTH + X_MARGIN, 20);
+  tft.canvas(pos.x, pos.y, BTN_WIDTH + X_MARGIN, FONT_LINE_HEIGHT);
   tft.set_background(COLOR_BACKGROUND);
   tft_string.set(ftostr52sp(value));
   tft.add_text(0, 0, color, tft_string);
 }
 
 static void moveAxis(const AxisEnum axis, const int8_t direction) {
   quick_feedback();
 
   #if ENABLED(PREVENT_COLD_EXTRUSION)
     if (axis == E_AXIS && thermalManager.tooColdToExtrude(motionAxisState.e_selection)) {
@@ -738,24 +851,22 @@ static void e_plus()  { moveAxis(E_AXIS, 1);  }
 static void e_minus() { moveAxis(E_AXIS, -1); }
 static void x_minus() { moveAxis(X_AXIS, -1); }
 static void x_plus()  { moveAxis(X_AXIS, 1);  }
 static void y_plus()  { moveAxis(Y_AXIS, 1);  }
 static void y_minus() { moveAxis(Y_AXIS, -1); }
 static void z_plus()  { moveAxis(Z_AXIS, 1);  }
 static void z_minus() { moveAxis(Z_AXIS, -1); }
 
 #if ENABLED(TOUCH_SCREEN)
   static void e_select() {
-    motionAxisState.e_selection++;
-    if (motionAxisState.e_selection >= EXTRUDERS) {
+    if (++motionAxisState.e_selection >= EXTRUDERS)
       motionAxisState.e_selection = 0;
-    }
 
     quick_feedback();
     drawCurESelection();
     drawAxisValue(E_AXIS);
   }
 
   static void do_home() {
     quick_feedback();
     drawMessage(GET_TEXT_F(MSG_LEVEL_BED_HOMING));
     queue.inject_P(G28_STR);
@@ -766,30 +877,31 @@ static void z_minus() { moveAxis(Z_AXIS, -1); }
     drawAxisValue(Y_AXIS);
     drawAxisValue(Z_AXIS);
   }
 
   static void step_size() {
     motionAxisState.currentStepSize = motionAxisState.currentStepSize / 10.0;
     if (motionAxisState.currentStepSize < 0.0015) motionAxisState.currentStepSize = 10.0;
     quick_feedback();
     drawCurStepValue();
   }
-#endif
 
-#if BOTH(HAS_BED_PROBE, TOUCH_SCREEN)
-  static void z_select() {
-    motionAxisState.z_selection *= -1;
-    quick_feedback();
-    drawCurZSelection();
-    drawAxisValue(Z_AXIS);
-  }
-#endif
+  #if HAS_BED_PROBE
+    static void z_select() {
+      motionAxisState.z_selection *= -1;
+      quick_feedback();
+      drawCurZSelection();
+      drawAxisValue(Z_AXIS);
+    }
+  #endif
+
+#endif // TOUCH_SCREEN
 
 static void disable_steppers() {
   quick_feedback();
   queue.inject(F("M84"));
 }
 
 static void drawBtn(int x, int y, const char *label, intptr_t data, MarlinImage img, uint16_t bgColor, bool enabled = true) {
   uint16_t width = Images[imgBtn39Rounded].width;
   uint16_t height = Images[imgBtn39Rounded].height;
 
@@ -798,124 +910,218 @@ static void drawBtn(int x, int y, const char *label, intptr_t data, MarlinImage
   tft.canvas(x, y, width, height);
   tft.set_background(COLOR_BACKGROUND);
   tft.add_image(0, 0, imgBtn39Rounded, bgColor, COLOR_BACKGROUND, COLOR_DARKGREY);
 
   // TODO: Make an add_text() taking a font arg
   if (label) {
     tft_string.set(label);
     tft_string.trim();
     tft.add_text(tft_string.center(width), height / 2 - tft_string.font_height() / 2, bgColor, tft_string);
   }
-  else {
+  else
     tft.add_image(0, 0, img, bgColor, COLOR_BACKGROUND, COLOR_DARKGREY);
-  }
 
   TERN_(HAS_TFT_XPT2046, if (enabled) touch.add_control(BUTTON, x, y, width, height, data));
 }
+
 void MarlinUI::move_axis_screen() {
   // Reset
   defer_status_screen(true);
   motionAxisState.blocked = false;
   TERN_(HAS_TFT_XPT2046, touch.enable());
 
   ui.clear_lcd();
 
   TERN_(TOUCH_SCREEN, touch.clear());
 
   const bool busy = printingIsActive();
 
   // Babysteps during printing? Select babystep for Z probe offset
   if (busy && ENABLED(BABYSTEP_ZPROBE_OFFSET))
     motionAxisState.z_selection = Z_SELECTION_Z_PROBE;
 
-  // ROW 1 -> E- Y- CurY Z+
-  int x = X_MARGIN, y = Y_MARGIN, spacing = 0;
+  #if ENABLED(TFT_COLOR_UI_PORTRAIT)
 
-  drawBtn(x, y, "E+", (intptr_t)e_plus, imgUp, E_BTN_COLOR, !busy);
+    // ROW 1 -> E+ Y+ Z+
+    int x = X_MARGIN, y = Y_MARGIN, spacing = 0;
 
-  spacing = (TFT_WIDTH - X_MARGIN * 2 - 3 * BTN_WIDTH) / 2;
-  x += BTN_WIDTH + spacing;
-  uint16_t yplus_x = x;
-  drawBtn(x, y, "Y+", (intptr_t)y_plus, imgUp, Y_BTN_COLOR, !busy);
+    drawBtn(x, y, "E+", (intptr_t)e_plus, imgUp, E_BTN_COLOR, !busy);
 
-  // Cur Y
-  x += BTN_WIDTH;
-  motionAxisState.yValuePos.x = x + 2;
-  motionAxisState.yValuePos.y = y;
-  drawAxisValue(Y_AXIS);
+    spacing = (TFT_WIDTH - X_MARGIN * 2 - 3 * BTN_WIDTH) / 2;
+    x += BTN_WIDTH + spacing;
+    uint16_t yplus_x = x;
+    drawBtn(x, y, "Y+", (intptr_t)y_plus, imgUp, Y_BTN_COLOR, !busy);
 
-  x += spacing;
-  drawBtn(x, y, "Z+", (intptr_t)z_plus, imgUp, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); //only enabled when not busy or have baby step
+    x += BTN_WIDTH + spacing;
+    uint16_t zplus_x = x;
+    drawBtn(x, y, "Z+", (intptr_t)z_plus, imgUp, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); //only enabled when not busy or have baby step
 
-  // ROW 2 -> "Ex"  X-  HOME X+  "Z"
-  y += BTN_HEIGHT + (TFT_HEIGHT - Y_MARGIN * 2 - 4 * BTN_HEIGHT) / 3;
-  x = X_MARGIN;
-  spacing = (TFT_WIDTH - X_MARGIN * 2 - 5 * BTN_WIDTH) / 4;
+    // ROW 2 -> "Ex" CurY "Z"
+    x = X_MARGIN;
+    y += BTN_HEIGHT + 2;
 
-  motionAxisState.eNamePos.x = x;
-  motionAxisState.eNamePos.y = y;
-  drawCurESelection();
-  TERN_(HAS_TFT_XPT2046, if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, BTN_HEIGHT, (intptr_t)e_select));
+    motionAxisState.eNamePos.x = x;
+    motionAxisState.eNamePos.y = y;
+    drawCurESelection();
+    TERN_(HAS_TFT_XPT2046, if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, BTN_HEIGHT, (intptr_t)e_select));
 
-  x += BTN_WIDTH + spacing;
-  drawBtn(x, y, "X-", (intptr_t)x_minus, imgLeft, X_BTN_COLOR, !busy);
+    motionAxisState.yValuePos.x = yplus_x;
+    motionAxisState.yValuePos.y = y;
+    drawAxisValue(Y_AXIS);
 
-  x += BTN_WIDTH + spacing; //imgHome is 64x64
-  TERN_(HAS_TFT_XPT2046, add_control(TFT_WIDTH / 2 - Images[imgHome].width / 2, y - (Images[imgHome].width - BTN_HEIGHT) / 2, BUTTON, (intptr_t)do_home, imgHome, !busy));
+    motionAxisState.zTypePos.x = zplus_x;
+    motionAxisState.zTypePos.y = y;
+    drawCurZSelection();
 
-  x += BTN_WIDTH + spacing;
-  uint16_t xplus_x = x;
-  drawBtn(x, y, "X+", (intptr_t)x_plus, imgRight, X_BTN_COLOR, !busy);
+    // ROW 3 -> X-    HOME    X+
+    y += (TFT_HEIGHT - Y_MARGIN * 2 - 4 * BTN_HEIGHT) / 3 - 2;
+    x = X_MARGIN;
 
-  x += BTN_WIDTH + spacing;
-  motionAxisState.zTypePos.x = x;
-  motionAxisState.zTypePos.y = y;
-  drawCurZSelection();
-  #if BOTH(HAS_BED_PROBE, TOUCH_SCREEN)
-    if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, 34 * 2, (intptr_t)z_select);
-  #endif
+    drawBtn(x, y, "X-", (intptr_t)x_minus, imgLeft, X_BTN_COLOR, !busy);
 
-  // ROW 3 -> E- CurX Y-  Z-
-  y += BTN_HEIGHT + (TFT_HEIGHT - Y_MARGIN * 2 - 4 * BTN_HEIGHT) / 3;
-  x = X_MARGIN;
-  spacing = (TFT_WIDTH - X_MARGIN * 2 - 3 * BTN_WIDTH) / 2;
+    TERN_(HAS_TFT_XPT2046, add_control(TFT_WIDTH / 2 - Images[imgHome].width / 2, y - (Images[imgHome].width - BTN_HEIGHT) / 2, BUTTON, (intptr_t)do_home, imgHome, !busy));
 
-  drawBtn(x, y, "E-", (intptr_t)e_minus, imgDown, E_BTN_COLOR, !busy);
+    drawBtn(zplus_x, y, "X+", (intptr_t)x_plus, imgRight, X_BTN_COLOR, !busy);
 
-  // Cur E
-  motionAxisState.eValuePos.x = x;
-  motionAxisState.eValuePos.y = y + BTN_HEIGHT + 2;
-  drawAxisValue(E_AXIS);
+    #if BOTH(HAS_BED_PROBE, TOUCH_SCREEN)
+      if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, 34 * 2, (intptr_t)z_select);
+    #endif
 
-  // Cur X
-  motionAxisState.xValuePos.x = BTN_WIDTH + (TFT_WIDTH - X_MARGIN * 2 - 5 * BTN_WIDTH) / 4; //X- pos
-  motionAxisState.xValuePos.y = y - 10;
-  drawAxisValue(X_AXIS);
+    // ROW 4 -> Cur X
+    y += BTN_HEIGHT + 2;
 
-  x += BTN_WIDTH + spacing;
-  drawBtn(x, y, "Y-", (intptr_t)y_minus, imgDown, Y_BTN_COLOR, !busy);
+    motionAxisState.xValuePos.x = x;
+    motionAxisState.xValuePos.y = y;
+    drawAxisValue(X_AXIS);
 
-  x += BTN_WIDTH + spacing;
-  drawBtn(x, y, "Z-", (intptr_t)z_minus, imgDown, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); //only enabled when not busy or have baby step
+    // ROW 5 -> E- CurX Y-    Z-
+    y += (TFT_HEIGHT - Y_MARGIN * 2 - 4 * BTN_HEIGHT) / 3 - 2;
+    x = X_MARGIN;
 
-  // Cur Z
-  motionAxisState.zValuePos.x = x;
-  motionAxisState.zValuePos.y = y + BTN_HEIGHT + 2;
-  drawAxisValue(Z_AXIS);
+    drawBtn(x, y, "E-", (intptr_t)e_minus, imgDown, E_BTN_COLOR, !busy);
 
-  // ROW 4 -> step_size  disable steppers back
-  y = TFT_HEIGHT - Y_MARGIN - BTN_HEIGHT; //
-  x = xplus_x - CUR_STEP_VALUE_WIDTH - 10;
-  motionAxisState.stepValuePos.x = yplus_x + BTN_WIDTH - CUR_STEP_VALUE_WIDTH;
-  motionAxisState.stepValuePos.y = TFT_HEIGHT - Y_MARGIN - BTN_HEIGHT;
-  if (!busy) {
-    drawCurStepValue();
-    TERN_(HAS_TFT_XPT2046, touch.add_control(BUTTON, motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y, CUR_STEP_VALUE_WIDTH, BTN_HEIGHT, (intptr_t)step_size));
-  }
+    // Cur E
+    motionAxisState.eValuePos.x = x;
+    motionAxisState.eValuePos.y = y + BTN_HEIGHT + 2;
+    drawAxisValue(E_AXIS);
+
+    x += BTN_WIDTH + spacing;
+    drawBtn(x, y, "Y-", (intptr_t)y_minus, imgDown, Y_BTN_COLOR, !busy);
+
+    x += BTN_WIDTH + spacing;
+    drawBtn(x, y, "Z-", (intptr_t)z_minus, imgDown, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); //only enabled when not busy or have baby step
+
+    // Cur Z
+    motionAxisState.zValuePos.x = x;
+    motionAxisState.zValuePos.y = y + BTN_HEIGHT + 2;
+    drawAxisValue(Z_AXIS);
+
+    // ROW 6 -> step_size    disable steppers back
+    y = TFT_HEIGHT - Y_MARGIN - BTN_HEIGHT; //
+    x = zplus_x - CUR_STEP_VALUE_WIDTH - 10;
+    motionAxisState.stepValuePos.x = X_MARGIN + BTN_WIDTH - CUR_STEP_VALUE_WIDTH;
+    motionAxisState.stepValuePos.y = TFT_HEIGHT - Y_MARGIN - BTN_HEIGHT;
+
+    if (!busy) {
+        drawCurStepValue();
+        TERN_(HAS_TFT_XPT2046, touch.add_control(BUTTON, motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y, CUR_STEP_VALUE_WIDTH, BTN_HEIGHT, (intptr_t)step_size));
+    }
+
+    // aligned with x+
+    drawBtn(yplus_x, y, "off", (intptr_t)disable_steppers, imgCancel, COLOR_WHITE, !busy);
+
+  #else // !TFT_COLOR_UI_PORTRAIT
+
+    // ROW 1 -> E+ Y+ CurY Z+
+    int x = X_MARGIN, y = Y_MARGIN, spacing = 0;
+
+    drawBtn(x, y, "E+", (intptr_t)e_plus, imgUp, E_BTN_COLOR, !busy);
+
+    spacing = (TFT_WIDTH - X_MARGIN * 2 - 3 * BTN_WIDTH) / 2;
+    x += BTN_WIDTH + spacing;
+    uint16_t yplus_x = x;
+    drawBtn(x, y, "Y+", (intptr_t)y_plus, imgUp, Y_BTN_COLOR, !busy);
+
+    // Cur Y
+    x += BTN_WIDTH;
+    motionAxisState.yValuePos.x = x + 2;
+    motionAxisState.yValuePos.y = y;
+    drawAxisValue(Y_AXIS);
+
+    x += spacing;
+    drawBtn(x, y, "Z+", (intptr_t)z_plus, imgUp, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); //only enabled when not busy or have baby step
+
+    // ROW 2 -> "Ex"    X-    HOME X+    "Z"
+    y += BTN_HEIGHT + (TFT_HEIGHT - Y_MARGIN * 2 - 4 * BTN_HEIGHT) / 3;
+    x = X_MARGIN;
+    spacing = (TFT_WIDTH - X_MARGIN * 2 - 5 * BTN_WIDTH) / 4;
+
+    motionAxisState.eNamePos.x = x;
+    motionAxisState.eNamePos.y = y;
+    drawCurESelection();
+    TERN_(HAS_TFT_XPT2046, if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, BTN_HEIGHT, (intptr_t)e_select));
+
+    x += BTN_WIDTH + spacing;
+    drawBtn(x, y, "X-", (intptr_t)x_minus, imgLeft, X_BTN_COLOR, !busy);
+
+    x += BTN_WIDTH + spacing; //imgHome is 64x64
+    TERN_(HAS_TFT_XPT2046, add_control(TFT_WIDTH / 2 - Images[imgHome].width / 2, y - (Images[imgHome].width - BTN_HEIGHT) / 2, BUTTON, (intptr_t)do_home, imgHome, !busy));
+
+    x += BTN_WIDTH + spacing;
+    uint16_t xplus_x = x;
+    drawBtn(x, y, "X+", (intptr_t)x_plus, imgRight, X_BTN_COLOR, !busy);
+
+    x += BTN_WIDTH + spacing;
+    motionAxisState.zTypePos.x = x;
+    motionAxisState.zTypePos.y = y;
+    drawCurZSelection();
+    #if BOTH(HAS_BED_PROBE, TOUCH_SCREEN)
+        if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, 34 * 2, (intptr_t)z_select);
+    #endif
+
+    // ROW 3 -> E- CurX Y-    Z-
+    y += BTN_HEIGHT + (TFT_HEIGHT - Y_MARGIN * 2 - 4 * BTN_HEIGHT) / 3;
+    x = X_MARGIN;
+    spacing = (TFT_WIDTH - X_MARGIN * 2 - 3 * BTN_WIDTH) / 2;
+
+    drawBtn(x, y, "E-", (intptr_t)e_minus, imgDown, E_BTN_COLOR, !busy);
+
+    // Cur E
+    motionAxisState.eValuePos.x = x;
+    motionAxisState.eValuePos.y = y + BTN_HEIGHT + 2;
+    drawAxisValue(E_AXIS);
+
+    // Cur X
+    motionAxisState.xValuePos.x = BTN_WIDTH + (TFT_WIDTH - X_MARGIN * 2 - 5 * BTN_WIDTH) / 4; //X- pos
+    motionAxisState.xValuePos.y = y - 10;
+    drawAxisValue(X_AXIS);
+
+    x += BTN_WIDTH + spacing;
+    drawBtn(x, y, "Y-", (intptr_t)y_minus, imgDown, Y_BTN_COLOR, !busy);
+
+    x += BTN_WIDTH + spacing;
+    drawBtn(x, y, "Z-", (intptr_t)z_minus, imgDown, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); //only enabled when not busy or have baby step
+
+    // Cur Z
+    motionAxisState.zValuePos.x = x;
+    motionAxisState.zValuePos.y = y + BTN_HEIGHT + 2;
+    drawAxisValue(Z_AXIS);
+
+    // ROW 4 -> step_size    disable steppers back
+    y = TFT_HEIGHT - Y_MARGIN - BTN_HEIGHT; //
+    x = xplus_x - CUR_STEP_VALUE_WIDTH - 10;
+    motionAxisState.stepValuePos.x = yplus_x + BTN_WIDTH - CUR_STEP_VALUE_WIDTH;
+    motionAxisState.stepValuePos.y = TFT_HEIGHT - Y_MARGIN - BTN_HEIGHT;
+    if (!busy) {
+        drawCurStepValue();
+        TERN_(HAS_TFT_XPT2046, touch.add_control(BUTTON, motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y, CUR_STEP_VALUE_WIDTH, BTN_HEIGHT, (intptr_t)step_size));
+    }
+
+    // aligned with x+
+    drawBtn(xplus_x, y, "off", (intptr_t)disable_steppers, imgCancel, COLOR_WHITE, !busy);
 
-  // aligned with x+
-  drawBtn(xplus_x, y, "off", (intptr_t)disable_steppers, imgCancel, COLOR_WHITE, !busy);
+  #endif // !TFT_COLOR_UI_PORTRAIT
 
   TERN_(HAS_TFT_XPT2046, add_control(TFT_WIDTH - X_MARGIN - BTN_WIDTH, y, BACK, imgBack));
 }
 
 #endif // HAS_UI_320x240

commit 7717beb79362522b8239d5af62b32ff3d0e2d748
Author: kadir ilkimen <kadirilkimen@gmail.com>
Date:   Wed Jan 11 06:29:38 2023 +0200

    ‚ú® Polar Kinematics (#25214)

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index a7c49241b4..85ed59b2cc 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -707,21 +707,21 @@ static void moveAxis(const AxisEnum axis, const int8_t direction) {
 
   if (!ui.manual_move.processing) {
     // Get motion limit from software endstops, if any
     float min, max;
     soft_endstop.get_manual_axis_limits(axis, min, max);
 
     // Delta limits XY based on the current offset from center
     // This assumes the center is 0,0
     #if ENABLED(DELTA)
       if (axis != Z_AXIS && axis != E_AXIS) {
-        max = SQRT(sq((float)(DELTA_PRINTABLE_RADIUS)) - sq(current_position[Y_AXIS - axis])); // (Y_AXIS - axis) == the other axis
+        max = SQRT(sq(float(PRINTABLE_RADIUS)) - sq(current_position[Y_AXIS - axis])); // (Y_AXIS - axis) == the other axis
         min = -max;
       }
     #endif
 
     // Get the new position
     const bool limited = ui.manual_move.apply_diff(axis, diff, min, max);
     #if IS_KINEMATIC
       UNUSED(limited);
     #else
       PGM_P const msg = limited ? GET_TEXT(MSG_LCD_SOFT_ENDSTOPS) : NUL_STR;

commit fca1929beb6a5f7dd21d17bdefcbc97511869e27
Author: Alexander Gavrilenko <jmz52@users.noreply.github.com>
Date:   Sat Dec 31 08:44:55 2022 +0300

    ‚ú®‚ö°Ô∏è UTF support for TFT Color UI (#25073)

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index bb48b5e165..a7c49241b4 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -63,26 +63,26 @@ void MarlinUI::tft_idle() {
 
 #if ENABLED(SHOW_BOOTSCREEN)
 
   void MarlinUI::show_bootscreen() {
     tft.queue.reset();
 
     tft.canvas(0, 0, TFT_WIDTH, TFT_HEIGHT);
     #if ENABLED(BOOT_MARLIN_LOGO_SMALL)
       #define BOOT_LOGO_W 195   // MarlinLogo195x59x16
       #define BOOT_LOGO_H  59
-      #define SITE_URL_Y (TFT_HEIGHT - 46)
+      #define SITE_URL_Y (TFT_HEIGHT - 48)
       tft.set_background(COLOR_BACKGROUND);
     #else
       #define BOOT_LOGO_W TFT_WIDTH   // MarlinLogo320x240x16
       #define BOOT_LOGO_H TFT_HEIGHT
-      #define SITE_URL_Y (TFT_HEIGHT - 52)
+      #define SITE_URL_Y (TFT_HEIGHT - 54)
     #endif
     tft.add_image((TFT_WIDTH - BOOT_LOGO_W) / 2, (TFT_HEIGHT - BOOT_LOGO_H) / 2, imgBootScreen);
     #ifdef WEBSITE_URL
       tft_string.set(WEBSITE_URL);
       tft.add_text(tft_string.center(TFT_WIDTH), SITE_URL_Y, COLOR_WEBSITE_URL, tft_string);
     #endif
 
     tft.queue.sync();
   }
 
@@ -90,33 +90,33 @@ void MarlinUI::tft_idle() {
     if ((BOOTSCREEN_TIMEOUT) > sofar) safe_delay((BOOTSCREEN_TIMEOUT) - sofar);
     clear_lcd();
   }
 
 #endif
 
 void MarlinUI::draw_kill_screen() {
   tft.queue.reset();
   tft.fill(0, 0, TFT_WIDTH, TFT_HEIGHT, COLOR_KILL_SCREEN_BG);
 
-  tft.canvas(0, 60, TFT_WIDTH, 20);
+  tft.canvas(0, 60, TFT_WIDTH, 24);
   tft.set_background(COLOR_KILL_SCREEN_BG);
   tft_string.set(status_message);
   tft_string.trim();
   tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_KILL_SCREEN_TEXT, tft_string);
 
-  tft.canvas(0, 120, TFT_WIDTH, 20);
+  tft.canvas(0, 120, TFT_WIDTH, 24);
   tft.set_background(COLOR_KILL_SCREEN_BG);
   tft_string.set(GET_TEXT(MSG_HALTED));
   tft_string.trim();
   tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_KILL_SCREEN_TEXT, tft_string);
 
-  tft.canvas(0, 160, TFT_WIDTH, 20);
+  tft.canvas(0, 160, TFT_WIDTH, 24);
   tft.set_background(COLOR_KILL_SCREEN_BG);
   tft_string.set(GET_TEXT(MSG_PLEASE_RESET));
   tft_string.trim();
   tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_KILL_SCREEN_TEXT, tft_string);
 
   tft.queue.sync();
 }
 
 void draw_heater_status(uint16_t x, uint16_t y, const int8_t Heater) {
   MarlinImage image = imgHotEnd;
@@ -178,27 +178,27 @@ void draw_heater_status(uint16_t x, uint16_t y, const int8_t Heater) {
       if (currentTemperature > 26) Color = COLOR_RED;
       image = targetTemperature > 26 ? imgCoolerHot : imgCooler;
     }
   #endif
 
   tft.add_image(0, 18, image, Color);
 
   tft_string.set(i16tostr3rj(currentTemperature));
   tft_string.add(LCD_STR_DEGREE);
   tft_string.trim();
-  tft.add_text(tft_string.center(64) + 2, 72, Color, tft_string);
+  tft.add_text(tft_string.center(64) + 2, 69 + tft_string.vcenter(24), Color, tft_string);
 
   if (targetTemperature >= 0) {
     tft_string.set(i16tostr3rj(targetTemperature));
     tft_string.add(LCD_STR_DEGREE);
     tft_string.trim();
-    tft.add_text(tft_string.center(64) + 2, 8, Color, tft_string);
+    tft.add_text(tft_string.center(64) + 2, 5 + tft_string.vcenter(24), Color, tft_string);
   }
 }
 
 void draw_fan_status(uint16_t x, uint16_t y, const bool blink) {
   TERN_(TOUCH_SCREEN, touch.add_control(FAN, x, y, 64, 100));
   tft.canvas(x, y, 64, 100);
   tft.set_background(COLOR_BACKGROUND);
 
   uint8_t fanSpeed = thermalManager.fan_speed[0];
   MarlinImage image;
@@ -207,21 +207,21 @@ void draw_fan_status(uint16_t x, uint16_t y, const bool blink) {
     image = blink ? imgFanFast1 : imgFanFast0;
   else if (fanSpeed > 0)
     image = blink ? imgFanSlow1 : imgFanSlow0;
   else
     image = imgFanIdle;
 
   tft.add_image(0, 10, image, COLOR_FAN);
 
   tft_string.set(ui8tostr4pctrj(thermalManager.fan_speed[0]));
   tft_string.trim();
-  tft.add_text(tft_string.center(64) + 6, 72, COLOR_FAN, tft_string);
+  tft.add_text(tft_string.center(64) + 6, 69 + tft_string.vcenter(24), COLOR_FAN, tft_string);
 }
 
 void MarlinUI::draw_status_screen() {
   const bool blink = get_blink();
 
   TERN_(TOUCH_SCREEN, touch.clear());
 
   // heaters and fan
   uint16_t i, x, y = TFT_STATUS_TOP_Y;
 
@@ -252,101 +252,101 @@ void MarlinUI::draw_status_screen() {
     }
   }
 
   // coordinates
   tft.canvas(4, 103, 312, 24);
   tft.set_background(COLOR_BACKGROUND);
   tft.add_rectangle(0, 0, 312, 24, COLOR_AXIS_HOMED);
 
   if (TERN0(LCD_SHOW_E_TOTAL, printingIsActive())) {
     #if ENABLED(LCD_SHOW_E_TOTAL)
-      tft.add_text( 10, 3, COLOR_AXIS_HOMED , "E");
+      tft.add_text( 10, tft_string.vcenter(24), COLOR_AXIS_HOMED , "E");
       const uint8_t escale = e_move_accumulator >= 100000.0f ? 10 : 1; // After 100m switch to cm
       tft_string.set(ftostr4sign(e_move_accumulator / escale));
       tft_string.add(escale == 10 ? 'c' : 'm');
       tft_string.add('m');
-      tft.add_text(127 - tft_string.width(), 3, COLOR_AXIS_HOMED, tft_string);
+      tft.add_text(127 - tft_string.width(), tft_string.vcenter(24), COLOR_AXIS_HOMED, tft_string);
     #endif
   }
   else {
-    tft.add_text( 10, 3, COLOR_AXIS_HOMED , "X");
+    tft.add_text( 10, tft_string.vcenter(24), COLOR_AXIS_HOMED , "X");
     const bool nhx = axis_should_home(X_AXIS);
     tft_string.set(blink && nhx ? "?" : ftostr4sign(LOGICAL_X_POSITION(current_position.x)));
-    tft.add_text( 68 - tft_string.width(), 3, nhx ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
+    tft.add_text( 68 - tft_string.width(), tft_string.vcenter(24), nhx ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
 
-    tft.add_text(127, 3, COLOR_AXIS_HOMED , "Y");
+    tft.add_text(127, tft_string.vcenter(24), COLOR_AXIS_HOMED , "Y");
     const bool nhy = axis_should_home(Y_AXIS);
     tft_string.set(blink && nhy ? "?" : ftostr4sign(LOGICAL_Y_POSITION(current_position.y)));
-    tft.add_text(185 - tft_string.width(), 3, nhy ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
+    tft.add_text(185 - tft_string.width(), tft_string.vcenter(24), nhy ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
   }
 
-  tft.add_text(219, 3, COLOR_AXIS_HOMED , "Z");
+  tft.add_text(219, tft_string.vcenter(24), COLOR_AXIS_HOMED , "Z");
   const bool nhz = axis_should_home(Z_AXIS);
   uint16_t offset = 25;
   if (blink && nhz)
     tft_string.set('?');
   else {
     const float z = LOGICAL_Z_POSITION(current_position.z);
     tft_string.set(ftostr52sp((int16_t)z));
     tft_string.rtrim();
     offset += tft_string.width();
 
     tft_string.set(ftostr52sp(z));
     offset -= tft_string.width();
   }
-  tft.add_text(301 - tft_string.width() - offset, 3, nhz ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
+  tft.add_text(301 - tft_string.width() - offset, tft_string.vcenter(24), nhz ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
   TERN_(TOUCH_SCREEN, touch.add_control(MOVE_AXIS, 0, 103, 312, 24));
 
   // feed rate
-  tft.canvas(70, 136, 80, 32);
+  tft.canvas(70, 136, 84, 32);
   tft.set_background(COLOR_BACKGROUND);
   uint16_t color = feedrate_percentage == 100 ? COLOR_RATE_100 : COLOR_RATE_ALTERED;
   tft.add_image(0, 0, imgFeedRate, color);
   tft_string.set(i16tostr3rj(feedrate_percentage));
   tft_string.add('%');
-  tft.add_text(32, 6, color , tft_string);
-  TERN_(TOUCH_SCREEN, touch.add_control(FEEDRATE, 70, 136, 80, 32));
+  tft.add_text(32, tft_string.vcenter(30), color , tft_string);
+  TERN_(TOUCH_SCREEN, touch.add_control(FEEDRATE, 70, 136, 84, 32));
 
   // flow rate
-  tft.canvas(170, 136, 80, 32);
+  tft.canvas(170, 136, 84, 32);
   tft.set_background(COLOR_BACKGROUND);
   color = planner.flow_percentage[0] == 100 ? COLOR_RATE_100 : COLOR_RATE_ALTERED;
   tft.add_image(0, 0, imgFlowRate, color);
   tft_string.set(i16tostr3rj(planner.flow_percentage[active_extruder]));
   tft_string.add('%');
-  tft.add_text(32, 6, color , tft_string);
-  TERN_(TOUCH_SCREEN, touch.add_control(FLOWRATE, 170, 136, 80, 32, active_extruder));
+  tft.add_text(32, tft_string.vcenter(30), color , tft_string);
+  TERN_(TOUCH_SCREEN, touch.add_control(FLOWRATE, 170, 136, 84, 32, active_extruder));
 
   // print duration
   char buffer[14];
   duration_t elapsed = print_job_timer.duration();
   elapsed.toDigital(buffer);
 
-  tft.canvas(96, 176, 128, 20);
+  tft.canvas(96, 173, 128, 24);
   tft.set_background(COLOR_BACKGROUND);
   tft_string.set(buffer);
-  tft.add_text(tft_string.center(128), 0, COLOR_PRINT_TIME, tft_string);
+  tft.add_text(tft_string.center(128), tft_string.vcenter(24), COLOR_PRINT_TIME, tft_string);
 
   // progress bar
   const uint8_t progress = ui.get_progress_percent();
   tft.canvas(4, 198, 312, 9);
   tft.set_background(COLOR_PROGRESS_BG);
   tft.add_rectangle(0, 0, 312, 9, COLOR_PROGRESS_FRAME);
   if (progress)
     tft.add_bar(1, 1, (310 * progress) / 100, 7, COLOR_PROGRESS_BAR);
 
   // status message
-  tft.canvas(0, 216, 320, 20);
+  tft.canvas(0, 212, 320, 24);
   tft.set_background(COLOR_BACKGROUND);
   tft_string.set(status_message);
   tft_string.trim();
-  tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_STATUS_MESSAGE, tft_string);
+  tft.add_text(tft_string.center(TFT_WIDTH), tft_string.vcenter(24), COLOR_STATUS_MESSAGE, tft_string);
 
   #if ENABLED(TOUCH_SCREEN)
     add_control(256, 130, menu_main, imgSettings);
     #if ENABLED(SDSUPPORT)
       const bool cm = card.isMounted(), pa = printingIsActive();
       add_control(0, 130, menu_media, imgSD, cm && !pa, COLOR_CONTROL_ENABLED, cm && pa ? COLOR_BUSY : COLOR_CONTROL_DISABLED);
     #endif
   #endif
 }
 

commit aaae56a6501fd617cdc1216e0d1bfec39538da61
Author: Alexander Gavrilenko <jmz52@users.noreply.github.com>
Date:   Tue Dec 13 00:13:31 2022 +0300

    ‚ú® TFT_COLOR_UI async DMA SPI (#24980)

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index 19cc4590aa..bb48b5e165 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -50,21 +50,22 @@ void MarlinUI::tft_idle() {
     if (TERN0(HAS_TOUCH_SLEEP, lcd_sleep_task())) return;
     if (draw_menu_navigation) {
       add_control(48, 206, PAGE_UP, imgPageUp, encoderTopLine > 0);
       add_control(240, 206, PAGE_DOWN, imgPageDown, encoderTopLine + LCD_HEIGHT < screen_items);
       add_control(144, 206, BACK, imgBack);
       draw_menu_navigation = false;
     }
   #endif
 
   tft.queue.async();
-  TERN_(TOUCH_SCREEN, touch.idle());
+
+  TERN_(TOUCH_SCREEN, if (tft.queue.is_empty()) touch.idle()); // Touch driver is not DMA-aware, so only check for touch controls after screen drawing is completed
 }
 
 #if ENABLED(SHOW_BOOTSCREEN)
 
   void MarlinUI::show_bootscreen() {
     tft.queue.reset();
 
     tft.canvas(0, 0, TFT_WIDTH, TFT_HEIGHT);
     #if ENABLED(BOOT_MARLIN_LOGO_SMALL)
       #define BOOT_LOGO_W 195   // MarlinLogo195x59x16
@@ -335,21 +336,24 @@ void MarlinUI::draw_status_screen() {
 
   // status message
   tft.canvas(0, 216, 320, 20);
   tft.set_background(COLOR_BACKGROUND);
   tft_string.set(status_message);
   tft_string.trim();
   tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_STATUS_MESSAGE, tft_string);
 
   #if ENABLED(TOUCH_SCREEN)
     add_control(256, 130, menu_main, imgSettings);
-    TERN_(SDSUPPORT, add_control(0, 130, menu_media, imgSD, !printingIsActive(), COLOR_CONTROL_ENABLED, card.isMounted() && printingIsActive() ? COLOR_BUSY : COLOR_CONTROL_DISABLED));
+    #if ENABLED(SDSUPPORT)
+      const bool cm = card.isMounted(), pa = printingIsActive();
+      add_control(0, 130, menu_media, imgSD, cm && !pa, COLOR_CONTROL_ENABLED, cm && pa ? COLOR_BUSY : COLOR_CONTROL_DISABLED);
+    #endif
   #endif
 }
 
 // Low-level draw_edit_screen can be used to draw an edit screen from anyplace
 void MenuEditItemBase::draw_edit_screen(FSTR_P const fstr, const char * const value/*=nullptr*/) {
   ui.encoder_direction_normal();
   TERN_(TOUCH_SCREEN, touch.clear());
 
   uint16_t line = 1;
 

commit 4ffa2e80e4db3413425a575aed14be30bbf2bb24
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Mon Jul 25 12:02:37 2022 -0700

    üì∫ Fix TFT Classic UI non-Touchscreen 1024x600 (#24541)

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index 56887478f0..19cc4590aa 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -764,21 +764,21 @@ static void z_minus() { moveAxis(Z_AXIS, -1); }
   }
 
   static void step_size() {
     motionAxisState.currentStepSize = motionAxisState.currentStepSize / 10.0;
     if (motionAxisState.currentStepSize < 0.0015) motionAxisState.currentStepSize = 10.0;
     quick_feedback();
     drawCurStepValue();
   }
 #endif
 
-#if HAS_BED_PROBE
+#if BOTH(HAS_BED_PROBE, TOUCH_SCREEN)
   static void z_select() {
     motionAxisState.z_selection *= -1;
     quick_feedback();
     drawCurZSelection();
     drawAxisValue(Z_AXIS);
   }
 #endif
 
 static void disable_steppers() {
   quick_feedback();

commit d8545551fed8498f1c420ec3b301d4d77d0de8b5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jun 26 05:47:18 2022 -0500

    üêõ Fix Manual Move axis selection (#24404)

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index a4fcc35bd0..56887478f0 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -376,22 +376,21 @@ void MenuEditItemBase::draw_edit_screen(FSTR_P const fstr, const char * const va
       tft.add_text(TFT_WIDTH / 2 - 16 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
 
       tft_string.set(Y_LBL);
       tft.add_text(TFT_WIDTH / 2 + 16, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
       tft_string.set(ftostr52(LOGICAL_X_POSITION(current_position.y)));
       tft_string.trim();
       tft.add_text(TFT_WIDTH / 2 + 120 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
     }
   #endif
 
-  extern screenFunc_t _manual_move_func_ptr;
-  if (ui.currentScreen != _manual_move_func_ptr && !ui.external_control) {
+  if (ui.can_show_slider()) {
 
     #define SLIDER_LENGTH 224
     #define SLIDER_Y_POSITION 140
 
     tft.canvas((TFT_WIDTH - SLIDER_LENGTH) / 2, SLIDER_Y_POSITION, SLIDER_LENGTH, 16);
     tft.set_background(COLOR_BACKGROUND);
 
     int16_t position = (SLIDER_LENGTH - 2) * ui.encoderPosition / maxEditValue;
     tft.add_bar(0, 7, 1, 2, ui.encoderPosition == 0 ? COLOR_SLIDER_INACTIVE : COLOR_SLIDER);
     tft.add_bar(1, 6, position, 4, COLOR_SLIDER);

commit 640282b8dc5de4ccdfb607b99e795d3eaa1334a7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jun 13 20:43:23 2022 -0500

    üßë‚Äçüíª Apply F() to some LCD / TFT strings
    
    Followup to #24228

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index 15031d0da2..a4fcc35bd0 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -275,21 +275,21 @@ void MarlinUI::draw_status_screen() {
     tft.add_text(127, 3, COLOR_AXIS_HOMED , "Y");
     const bool nhy = axis_should_home(Y_AXIS);
     tft_string.set(blink && nhy ? "?" : ftostr4sign(LOGICAL_Y_POSITION(current_position.y)));
     tft.add_text(185 - tft_string.width(), 3, nhy ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
   }
 
   tft.add_text(219, 3, COLOR_AXIS_HOMED , "Z");
   const bool nhz = axis_should_home(Z_AXIS);
   uint16_t offset = 25;
   if (blink && nhz)
-    tft_string.set("?");
+    tft_string.set('?');
   else {
     const float z = LOGICAL_Z_POSITION(current_position.z);
     tft_string.set(ftostr52sp((int16_t)z));
     tft_string.rtrim();
     offset += tft_string.width();
 
     tft_string.set(ftostr52sp(z));
     offset -= tft_string.width();
   }
   tft.add_text(301 - tft_string.width() - offset, 3, nhz ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
@@ -454,21 +454,21 @@ void MenuItem_confirm::draw_select_screen(FSTR_P const yes, FSTR_P const no, con
       touch.add_control(RESUME_CONTINUE , 0, 0, TFT_WIDTH, TFT_HEIGHT);
     #endif
 
     menu_line(row);
     tft_string.set(GET_TEXT(MSG_FILAMENT_CHANGE_NOZZLE));
     tft_string.add('E');
     tft_string.add((char)('1' + extruder));
     tft_string.add(' ');
     tft_string.add(i16tostr3rj(thermalManager.wholeDegHotend(extruder)));
     tft_string.add(LCD_STR_DEGREE);
-    tft_string.add(" / ");
+    tft_string.add(F(" / "));
     tft_string.add(i16tostr3rj(thermalManager.degTargetHotend(extruder)));
     tft_string.add(LCD_STR_DEGREE);
     tft_string.trim();
     tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
   }
 
 #endif // ADVANCED_PAUSE_FEATURE
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
   #define GRID_OFFSET_X   8
@@ -586,54 +586,56 @@ static void quick_feedback() {
   #endif
 }
 
 #define CUR_STEP_VALUE_WIDTH 38
 static void drawCurStepValue() {
   tft_string.set(ftostr52sp(motionAxisState.currentStepSize));
   tft.canvas(motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y, CUR_STEP_VALUE_WIDTH, 20);
   tft.set_background(COLOR_BACKGROUND);
   tft.add_text(CUR_STEP_VALUE_WIDTH - tft_string.width(), 0, COLOR_AXIS_HOMED, tft_string);
   tft.queue.sync();
-  tft_string.set("mm");
+  tft_string.set(F("mm"));
   tft.canvas(motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y + 20, CUR_STEP_VALUE_WIDTH, 20);
   tft.set_background(COLOR_BACKGROUND);
   tft.add_text(CUR_STEP_VALUE_WIDTH - tft_string.width(), 0, COLOR_AXIS_HOMED, tft_string);
 }
 
 static void drawCurZSelection() {
-  tft_string.set("Z");
+  tft_string.set('Z');
   tft.canvas(motionAxisState.zTypePos.x, motionAxisState.zTypePos.y, tft_string.width(), 20);
   tft.set_background(COLOR_BACKGROUND);
   tft.add_text(0, 0, Z_BTN_COLOR, tft_string);
   tft.queue.sync();
-  tft_string.set("Offset");
+  tft_string.set(F("Offset"));
   tft.canvas(motionAxisState.zTypePos.x, motionAxisState.zTypePos.y + 34, tft_string.width(), 20);
   tft.set_background(COLOR_BACKGROUND);
   if (motionAxisState.z_selection == Z_SELECTION_Z_PROBE) {
     tft.add_text(0, 0, Z_BTN_COLOR, tft_string);
   }
 }
 
 static void drawCurESelection() {
   tft.canvas(motionAxisState.eNamePos.x, motionAxisState.eNamePos.y, BTN_WIDTH, BTN_HEIGHT);
   tft.set_background(COLOR_BACKGROUND);
-  tft_string.set("E");
+  tft_string.set('E');
   tft.add_text(0, 0, E_BTN_COLOR , tft_string);
   tft.add_text(tft_string.width(), 0, E_BTN_COLOR, ui8tostr3rj(motionAxisState.e_selection));
 }
 
 static void drawMessage(PGM_P const msg) {
   tft.canvas(X_MARGIN, TFT_HEIGHT - Y_MARGIN - 29, (TFT_WIDTH / 2) - (BTN_WIDTH / 2) - X_MARGIN, 20);
   tft.set_background(COLOR_BACKGROUND);
   tft.add_text(0, 0, COLOR_YELLOW, msg);
 }
 
+static void drawMessage(FSTR_P const fmsg) { drawMessage(FTOP(fmsg)); }
+
 static void drawAxisValue(const AxisEnum axis) {
   const float value = (
     TERN_(HAS_BED_PROBE, axis == Z_AXIS && motionAxisState.z_selection == Z_SELECTION_Z_PROBE ? probe.offset.z :)
     ui.manual_move.axis_value(axis)
   );
   xy_int_t pos;
   uint16_t color;
   switch (axis) {
     case X_AXIS: pos = motionAxisState.xValuePos; color = X_BTN_COLOR; break;
     case Y_AXIS: pos = motionAxisState.yValuePos; color = Y_BTN_COLOR; break;
@@ -645,21 +647,21 @@ static void drawAxisValue(const AxisEnum axis) {
   tft.set_background(COLOR_BACKGROUND);
   tft_string.set(ftostr52sp(value));
   tft.add_text(0, 0, color, tft_string);
 }
 
 static void moveAxis(const AxisEnum axis, const int8_t direction) {
   quick_feedback();
 
   #if ENABLED(PREVENT_COLD_EXTRUSION)
     if (axis == E_AXIS && thermalManager.tooColdToExtrude(motionAxisState.e_selection)) {
-      drawMessage(PSTR("Too cold"));
+      drawMessage(F("Too cold"));
       return;
     }
   #endif
 
   const float diff = motionAxisState.currentStepSize * direction;
 
   if (axis == Z_AXIS && motionAxisState.z_selection == Z_SELECTION_Z_PROBE) {
     #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
       const int16_t babystep_increment = direction * BABYSTEP_SIZE_Z;
       const bool do_probe = DISABLED(BABYSTEP_HOTEND_Z_OFFSET) || active_extruder == 0;
@@ -672,32 +674,32 @@ static void moveAxis(const AxisEnum axis, const int8_t direction) {
       if (WITHIN(new_offs, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
         babystep.add_steps(Z_AXIS, babystep_increment);
         if (do_probe)
           probe.offset.z = new_offs;
         else
           TERN(BABYSTEP_HOTEND_Z_OFFSET, hotend_offset[active_extruder].z = new_offs, NOOP);
         drawMessage(NUL_STR); // clear the error
         drawAxisValue(axis);
       }
       else {
-        drawMessage(GET_TEXT(MSG_LCD_SOFT_ENDSTOPS));
+        drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
       }
     #elif HAS_BED_PROBE
       // only change probe.offset.z
       probe.offset.z += diff;
       if (direction < 0 && current_position[axis] < Z_PROBE_OFFSET_RANGE_MIN) {
         current_position[axis] = Z_PROBE_OFFSET_RANGE_MIN;
-        drawMessage(GET_TEXT(MSG_LCD_SOFT_ENDSTOPS));
+        drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
       }
       else if (direction > 0 && current_position[axis] > Z_PROBE_OFFSET_RANGE_MAX) {
         current_position[axis] = Z_PROBE_OFFSET_RANGE_MAX;
-        drawMessage(GET_TEXT(MSG_LCD_SOFT_ENDSTOPS));
+        drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
       }
       else {
         drawMessage(NUL_STR); // clear the error
       }
       drawAxisValue(axis);
     #endif
     return;
   }
 
   if (!ui.manual_move.processing) {
@@ -745,21 +747,21 @@ static void z_minus() { moveAxis(Z_AXIS, -1); }
       motionAxisState.e_selection = 0;
     }
 
     quick_feedback();
     drawCurESelection();
     drawAxisValue(E_AXIS);
   }
 
   static void do_home() {
     quick_feedback();
-    drawMessage(GET_TEXT(MSG_LEVEL_BED_HOMING));
+    drawMessage(GET_TEXT_F(MSG_LEVEL_BED_HOMING));
     queue.inject_P(G28_STR);
     // Disable touch until home is done
     TERN_(HAS_TFT_XPT2046, touch.disable());
     drawAxisValue(E_AXIS);
     drawAxisValue(X_AXIS);
     drawAxisValue(Y_AXIS);
     drawAxisValue(Z_AXIS);
   }
 
   static void step_size() {

commit 8aca38351cd6d33a1202bf9a13890dc8e5eadd49
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 3 22:56:38 2022 -0500

    üßë‚Äçüíª Extend LCD string substitution (#24278)

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index 148d5d3964..15031d0da2 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -174,27 +174,27 @@ void draw_heater_status(uint16_t x, uint16_t y, const int8_t Heater) {
   #if HAS_TEMP_COOLER
     else if (Heater == H_COOLER) {
       if (currentTemperature <= 26) Color = COLOR_COLD;
       if (currentTemperature > 26) Color = COLOR_RED;
       image = targetTemperature > 26 ? imgCoolerHot : imgCooler;
     }
   #endif
 
   tft.add_image(0, 18, image, Color);
 
-  tft_string.set((uint8_t *)i16tostr3rj(currentTemperature));
+  tft_string.set(i16tostr3rj(currentTemperature));
   tft_string.add(LCD_STR_DEGREE);
   tft_string.trim();
   tft.add_text(tft_string.center(64) + 2, 72, Color, tft_string);
 
   if (targetTemperature >= 0) {
-    tft_string.set((uint8_t *)i16tostr3rj(targetTemperature));
+    tft_string.set(i16tostr3rj(targetTemperature));
     tft_string.add(LCD_STR_DEGREE);
     tft_string.trim();
     tft.add_text(tft_string.center(64) + 2, 8, Color, tft_string);
   }
 }
 
 void draw_fan_status(uint16_t x, uint16_t y, const bool blink) {
   TERN_(TOUCH_SCREEN, touch.add_control(FAN, x, y, 64, 100));
   tft.canvas(x, y, 64, 100);
   tft.set_background(COLOR_BACKGROUND);
@@ -204,21 +204,21 @@ void draw_fan_status(uint16_t x, uint16_t y, const bool blink) {
 
   if (fanSpeed >= 127)
     image = blink ? imgFanFast1 : imgFanFast0;
   else if (fanSpeed > 0)
     image = blink ? imgFanSlow1 : imgFanSlow0;
   else
     image = imgFanIdle;
 
   tft.add_image(0, 10, image, COLOR_FAN);
 
-  tft_string.set((uint8_t *)ui8tostr4pctrj(thermalManager.fan_speed[0]));
+  tft_string.set(ui8tostr4pctrj(thermalManager.fan_speed[0]));
   tft_string.trim();
   tft.add_text(tft_string.center(64) + 6, 72, COLOR_FAN, tft_string);
 }
 
 void MarlinUI::draw_status_screen() {
   const bool blink = get_blink();
 
   TERN_(TOUCH_SCREEN, touch.clear());
 
   // heaters and fan
@@ -347,21 +347,21 @@ void MarlinUI::draw_status_screen() {
 }
 
 // Low-level draw_edit_screen can be used to draw an edit screen from anyplace
 void MenuEditItemBase::draw_edit_screen(FSTR_P const fstr, const char * const value/*=nullptr*/) {
   ui.encoder_direction_normal();
   TERN_(TOUCH_SCREEN, touch.clear());
 
   uint16_t line = 1;
 
   menu_line(line++);
-  tft_string.set(FTOP(fstr), itemIndex, FTOP(itemString));
+  tft_string.set(fstr, itemIndex, itemStringC, itemStringF);
   tft_string.trim();
   tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
 
   TERN_(AUTO_BED_LEVELING_UBL, if (ui.external_control) line++);  // ftostr52() will overwrite *value so *value has to be displayed first
 
   menu_line(line);
   tft_string.set(value);
   tft_string.trim();
   tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
 
@@ -581,21 +581,21 @@ static void quick_feedback() {
     #if BOTH(HAS_MARLINUI_MENU, HAS_BEEPER)
       for (int8_t i = 5; i--;) { buzzer.tick(); delay(2); }
     #elif HAS_MARLINUI_MENU
       delay(10);
     #endif
   #endif
 }
 
 #define CUR_STEP_VALUE_WIDTH 38
 static void drawCurStepValue() {
-  tft_string.set((uint8_t *)ftostr52sp(motionAxisState.currentStepSize));
+  tft_string.set(ftostr52sp(motionAxisState.currentStepSize));
   tft.canvas(motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y, CUR_STEP_VALUE_WIDTH, 20);
   tft.set_background(COLOR_BACKGROUND);
   tft.add_text(CUR_STEP_VALUE_WIDTH - tft_string.width(), 0, COLOR_AXIS_HOMED, tft_string);
   tft.queue.sync();
   tft_string.set("mm");
   tft.canvas(motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y + 20, CUR_STEP_VALUE_WIDTH, 20);
   tft.set_background(COLOR_BACKGROUND);
   tft.add_text(CUR_STEP_VALUE_WIDTH - tft_string.width(), 0, COLOR_AXIS_HOMED, tft_string);
 }
 

commit a5e1d4c50ae40c8203d8490be83ef86e16ebf1c2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 22 19:56:46 2022 -0500

    ‚ôªÔ∏è Apply F() to more LCD code (#24228)

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index b1a781fad1..148d5d3964 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -340,28 +340,28 @@ void MarlinUI::draw_status_screen() {
   tft_string.trim();
   tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_STATUS_MESSAGE, tft_string);
 
   #if ENABLED(TOUCH_SCREEN)
     add_control(256, 130, menu_main, imgSettings);
     TERN_(SDSUPPORT, add_control(0, 130, menu_media, imgSD, !printingIsActive(), COLOR_CONTROL_ENABLED, card.isMounted() && printingIsActive() ? COLOR_BUSY : COLOR_CONTROL_DISABLED));
   #endif
 }
 
 // Low-level draw_edit_screen can be used to draw an edit screen from anyplace
-void MenuEditItemBase::draw_edit_screen(PGM_P const pstr, const char * const value/*=nullptr*/) {
+void MenuEditItemBase::draw_edit_screen(FSTR_P const fstr, const char * const value/*=nullptr*/) {
   ui.encoder_direction_normal();
   TERN_(TOUCH_SCREEN, touch.clear());
 
   uint16_t line = 1;
 
   menu_line(line++);
-  tft_string.set(pstr, itemIndex, itemString);
+  tft_string.set(FTOP(fstr), itemIndex, FTOP(itemString));
   tft_string.trim();
   tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
 
   TERN_(AUTO_BED_LEVELING_UBL, if (ui.external_control) line++);  // ftostr52() will overwrite *value so *value has to be displayed first
 
   menu_line(line);
   tft_string.set(value);
   tft_string.trim();
   tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
 
@@ -409,21 +409,21 @@ void MenuEditItemBase::draw_edit_screen(PGM_P const pstr, const char * const val
 
 void TFT::draw_edit_screen_buttons() {
   #if ENABLED(TOUCH_SCREEN)
     add_control(32, TFT_HEIGHT - 64, DECREASE, imgDecrease);
     add_control(224, TFT_HEIGHT - 64, INCREASE, imgIncrease);
     add_control(128, TFT_HEIGHT - 64, CLICK, imgConfirm);
   #endif
 }
 
 // The Select Screen presents a prompt and two "buttons"
-void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const bool yesno, PGM_P const pref, const char * const string/*=nullptr*/, PGM_P const suff/*=nullptr*/) {
+void MenuItem_confirm::draw_select_screen(FSTR_P const yes, FSTR_P const no, const bool yesno, FSTR_P const pref, const char * const string/*=nullptr*/, FSTR_P const suff/*=nullptr*/) {
   uint16_t line = 1;
 
   if (!string) line++;
 
   menu_line(line++);
   tft_string.set(pref);
   tft_string.trim();
   tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
 
   if (string) {
@@ -614,21 +614,21 @@ static void drawCurZSelection() {
 }
 
 static void drawCurESelection() {
   tft.canvas(motionAxisState.eNamePos.x, motionAxisState.eNamePos.y, BTN_WIDTH, BTN_HEIGHT);
   tft.set_background(COLOR_BACKGROUND);
   tft_string.set("E");
   tft.add_text(0, 0, E_BTN_COLOR , tft_string);
   tft.add_text(tft_string.width(), 0, E_BTN_COLOR, ui8tostr3rj(motionAxisState.e_selection));
 }
 
-static void drawMessage(const char *msg) {
+static void drawMessage(PGM_P const msg) {
   tft.canvas(X_MARGIN, TFT_HEIGHT - Y_MARGIN - 29, (TFT_WIDTH / 2) - (BTN_WIDTH / 2) - X_MARGIN, 20);
   tft.set_background(COLOR_BACKGROUND);
   tft.add_text(0, 0, COLOR_YELLOW, msg);
 }
 
 static void drawAxisValue(const AxisEnum axis) {
   const float value = (
     TERN_(HAS_BED_PROBE, axis == Z_AXIS && motionAxisState.z_selection == Z_SELECTION_Z_PROBE ? probe.offset.z :)
     ui.manual_move.axis_value(axis)
   );
@@ -645,21 +645,21 @@ static void drawAxisValue(const AxisEnum axis) {
   tft.set_background(COLOR_BACKGROUND);
   tft_string.set(ftostr52sp(value));
   tft.add_text(0, 0, color, tft_string);
 }
 
 static void moveAxis(const AxisEnum axis, const int8_t direction) {
   quick_feedback();
 
   #if ENABLED(PREVENT_COLD_EXTRUSION)
     if (axis == E_AXIS && thermalManager.tooColdToExtrude(motionAxisState.e_selection)) {
-      drawMessage("Too cold");
+      drawMessage(PSTR("Too cold"));
       return;
     }
   #endif
 
   const float diff = motionAxisState.currentStepSize * direction;
 
   if (axis == Z_AXIS && motionAxisState.z_selection == Z_SELECTION_Z_PROBE) {
     #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
       const int16_t babystep_increment = direction * BABYSTEP_SIZE_Z;
       const bool do_probe = DISABLED(BABYSTEP_HOTEND_Z_OFFSET) || active_extruder == 0;
@@ -668,39 +668,39 @@ static void moveAxis(const AxisEnum axis, const int8_t direction) {
                   new_offs = TERN(BABYSTEP_HOTEND_Z_OFFSET
                     , do_probe ? new_probe_offset : hotend_offset[active_extruder].z - bsDiff
                     , new_probe_offset
                   );
       if (WITHIN(new_offs, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
         babystep.add_steps(Z_AXIS, babystep_increment);
         if (do_probe)
           probe.offset.z = new_offs;
         else
           TERN(BABYSTEP_HOTEND_Z_OFFSET, hotend_offset[active_extruder].z = new_offs, NOOP);
-        drawMessage(""); // clear the error
+        drawMessage(NUL_STR); // clear the error
         drawAxisValue(axis);
       }
       else {
         drawMessage(GET_TEXT(MSG_LCD_SOFT_ENDSTOPS));
       }
     #elif HAS_BED_PROBE
       // only change probe.offset.z
       probe.offset.z += diff;
       if (direction < 0 && current_position[axis] < Z_PROBE_OFFSET_RANGE_MIN) {
         current_position[axis] = Z_PROBE_OFFSET_RANGE_MIN;
         drawMessage(GET_TEXT(MSG_LCD_SOFT_ENDSTOPS));
       }
       else if (direction > 0 && current_position[axis] > Z_PROBE_OFFSET_RANGE_MAX) {
         current_position[axis] = Z_PROBE_OFFSET_RANGE_MAX;
         drawMessage(GET_TEXT(MSG_LCD_SOFT_ENDSTOPS));
       }
       else {
-        drawMessage(""); // clear the error
+        drawMessage(NUL_STR); // clear the error
       }
       drawAxisValue(axis);
     #endif
     return;
   }
 
   if (!ui.manual_move.processing) {
     // Get motion limit from software endstops, if any
     float min, max;
     soft_endstop.get_manual_axis_limits(axis, min, max);

commit b523ddf1b2820488c6cc46887ee85e8a781ce726
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 19 06:05:52 2022 -0500

    ‚ôªÔ∏è Common Bed Leveling object name, accessors (#24214)

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index 35f04fae64..b1a781fad1 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -478,26 +478,26 @@ void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const
   #define CONTROL_OFFSET  8
 
   void MarlinUI::ubl_plot(const uint8_t x_plot, const uint8_t y_plot) {
 
     tft.canvas(GRID_OFFSET_X, GRID_OFFSET_Y, GRID_WIDTH, GRID_HEIGHT);
     tft.set_background(COLOR_BACKGROUND);
     tft.add_rectangle(0, 0, GRID_WIDTH, GRID_HEIGHT, COLOR_WHITE);
 
     for (uint16_t x = 0; x < (GRID_MAX_POINTS_X); x++)
       for (uint16_t y = 0; y < (GRID_MAX_POINTS_Y); y++)
-        if (position_is_reachable({ ubl.mesh_index_to_xpos(x), ubl.mesh_index_to_ypos(y) }))
+        if (position_is_reachable({ bedlevel.get_mesh_x(x), bedlevel.get_mesh_y(y) }))
           tft.add_bar(1 + (x * 2 + 1) * (GRID_WIDTH - 4) / (GRID_MAX_POINTS_X) / 2, GRID_HEIGHT - 3 - ((y * 2 + 1) * (GRID_HEIGHT - 4) / (GRID_MAX_POINTS_Y) / 2), 2, 2, COLOR_UBL);
 
     tft.add_rectangle((x_plot * 2 + 1) * (GRID_WIDTH - 4) / (GRID_MAX_POINTS_X) / 2 - 1, GRID_HEIGHT - 5 - ((y_plot * 2 + 1) * (GRID_HEIGHT - 4) / (GRID_MAX_POINTS_Y) / 2), 6, 6, COLOR_UBL);
 
-    const xy_pos_t pos = { ubl.mesh_index_to_xpos(x_plot), ubl.mesh_index_to_ypos(y_plot) },
+    const xy_pos_t pos = { bedlevel.get_mesh_x(x_plot), bedlevel.get_mesh_y(y_plot) },
                    lpos = pos.asLogical();
 
     tft.canvas(216, GRID_OFFSET_Y + (GRID_HEIGHT - MENU_ITEM_HEIGHT) / 2 - MENU_ITEM_HEIGHT, 96, MENU_ITEM_HEIGHT);
     tft.set_background(COLOR_BACKGROUND);
     tft_string.set(X_LBL);
     tft.add_text(0, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
     tft_string.set(ftostr52(lpos.x));
     tft_string.trim();
     tft.add_text(96 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
 
@@ -506,21 +506,21 @@ void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const
     tft_string.set(Y_LBL);
     tft.add_text(0, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
     tft_string.set(ftostr52(lpos.y));
     tft_string.trim();
     tft.add_text(96 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
 
     tft.canvas(216, GRID_OFFSET_Y + (GRID_HEIGHT - MENU_ITEM_HEIGHT) / 2 + MENU_ITEM_HEIGHT, 96, MENU_ITEM_HEIGHT);
     tft.set_background(COLOR_BACKGROUND);
     tft_string.set(Z_LBL);
     tft.add_text(0, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
-    tft_string.set(isnan(ubl.z_values[x_plot][y_plot]) ? "-----" : ftostr43sign(ubl.z_values[x_plot][y_plot]));
+    tft_string.set(isnan(bedlevel.z_values[x_plot][y_plot]) ? "-----" : ftostr43sign(bedlevel.z_values[x_plot][y_plot]));
     tft_string.trim();
     tft.add_text(96 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
 
     constexpr uint8_t w = (TFT_WIDTH) / 10;
     tft.canvas(GRID_OFFSET_X + (GRID_WIDTH - w) / 2, GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET - 1, w, MENU_ITEM_HEIGHT);
     tft.set_background(COLOR_BACKGROUND);
     tft_string.set(ui8tostr3rj(x_plot));
     tft_string.trim();
     tft.add_text(tft_string.center(w), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
 

commit 04fe50936e23a8aca7a400591e700c1220f68b3f
Author: Pauli Jokela <pauli.jokela@didstopia.com>
Date:   Thu May 12 05:23:16 2022 +0300

    ‚ú® SOUND_ON_DEFAULT option (#24102)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index 812a035947..35f04fae64 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -571,21 +571,21 @@ MotionAxisState motionAxisState;
 #define Z_BTN_COLOR COLOR_LIGHT_BLUE
 
 #define BTN_WIDTH 48
 #define BTN_HEIGHT 39
 #define X_MARGIN 15
 #define Y_MARGIN 11
 
 static void quick_feedback() {
   #if HAS_CHIRP
     ui.chirp(); // Buzz and wait. Is the delay needed for buttons to settle?
-    #if BOTH(HAS_MARLINUI_MENU, USE_BEEPER)
+    #if BOTH(HAS_MARLINUI_MENU, HAS_BEEPER)
       for (int8_t i = 5; i--;) { buzzer.tick(); delay(2); }
     #elif HAS_MARLINUI_MENU
       delay(10);
     #endif
   #endif
 }
 
 #define CUR_STEP_VALUE_WIDTH 38
 static void drawCurStepValue() {
   tft_string.set((uint8_t *)ftostr52sp(motionAxisState.currentStepSize));

commit 5b35f3a95582a477e879be5cc7d1406a42d3e740
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Wed Jan 26 10:33:10 2022 -0800

    üö∏ Better "Bed Tramming Done" dialog (#23616)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index 5447e7d33e..812a035947 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -433,22 +433,22 @@ void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const
     tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
   }
 
   if (suff) {
     menu_line(line);
     tft_string.set(suff);
     tft_string.trim();
     tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
   }
   #if ENABLED(TOUCH_SCREEN)
-    add_control(48, TFT_HEIGHT - 64, CANCEL, imgCancel, true, yesno ? HALF(COLOR_CONTROL_CANCEL) : COLOR_CONTROL_CANCEL);
-    add_control(208, TFT_HEIGHT - 64, CONFIRM, imgConfirm, true, yesno ? COLOR_CONTROL_CONFIRM : HALF(COLOR_CONTROL_CONFIRM));
+    if (no)  add_control( 48, TFT_HEIGHT - 64, CANCEL,  imgCancel,  true, yesno ? HALF(COLOR_CONTROL_CANCEL) : COLOR_CONTROL_CANCEL);
+    if (yes) add_control(208, TFT_HEIGHT - 64, CONFIRM, imgConfirm, true, yesno ? COLOR_CONTROL_CONFIRM : HALF(COLOR_CONTROL_CONFIRM));
   #endif
 }
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
 
   void MarlinUI::draw_hotend_status(const uint8_t row, const uint8_t extruder) {
     #if ENABLED(TOUCH_SCREEN)
       touch.clear();
       draw_menu_navigation = false;
       touch.add_control(RESUME_CONTINUE , 0, 0, TFT_WIDTH, TFT_HEIGHT);

commit ab46b7e2f298826a5512569d6e79bb59a7a6b8ea
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jan 25 15:33:03 2022 -0600

    üßë‚Äçüíª HAS_MARLINUI_MENU, HAS_MANUAL_MOVE_MENU

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index d85a917983..5447e7d33e 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -571,23 +571,23 @@ MotionAxisState motionAxisState;
 #define Z_BTN_COLOR COLOR_LIGHT_BLUE
 
 #define BTN_WIDTH 48
 #define BTN_HEIGHT 39
 #define X_MARGIN 15
 #define Y_MARGIN 11
 
 static void quick_feedback() {
   #if HAS_CHIRP
     ui.chirp(); // Buzz and wait. Is the delay needed for buttons to settle?
-    #if BOTH(HAS_LCD_MENU, USE_BEEPER)
+    #if BOTH(HAS_MARLINUI_MENU, USE_BEEPER)
       for (int8_t i = 5; i--;) { buzzer.tick(); delay(2); }
-    #elif HAS_LCD_MENU
+    #elif HAS_MARLINUI_MENU
       delay(10);
     #endif
   #endif
 }
 
 #define CUR_STEP_VALUE_WIDTH 38
 static void drawCurStepValue() {
   tft_string.set((uint8_t *)ftostr52sp(motionAxisState.currentStepSize));
   tft.canvas(motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y, CUR_STEP_VALUE_WIDTH, 20);
   tft.set_background(COLOR_BACKGROUND);

commit 36b2650f65e036ce1b02da568364230201a22b80
Author: Mikhail Basov <github@basov.net>
Date:   Mon Nov 15 07:46:34 2021 +0300

    üö∏ LCD_SHOW_E_TOTAL for TFT_COLOR_UI (#23127)

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index 1ef4c5881c..d85a917983 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -249,46 +249,57 @@ void MarlinUI::draw_status_screen() {
         case ITEM_FAN: draw_fan_status(x, y, blink); break;
       #endif
     }
   }
 
   // coordinates
   tft.canvas(4, 103, 312, 24);
   tft.set_background(COLOR_BACKGROUND);
   tft.add_rectangle(0, 0, 312, 24, COLOR_AXIS_HOMED);
 
-  tft.add_text( 10, 3, COLOR_AXIS_HOMED , "X");
-  tft.add_text(127, 3, COLOR_AXIS_HOMED , "Y");
-  tft.add_text(219, 3, COLOR_AXIS_HOMED , "Z");
-
-  bool not_homed = axis_should_home(X_AXIS);
-  tft_string.set(blink && not_homed ? "?" : ftostr4sign(LOGICAL_X_POSITION(current_position.x)));
-  tft.add_text( 68 - tft_string.width(), 3, not_homed ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
-
-  not_homed = axis_should_home(Y_AXIS);
-  tft_string.set(blink && not_homed ? "?" : ftostr4sign(LOGICAL_Y_POSITION(current_position.y)));
-  tft.add_text(185 - tft_string.width(), 3, not_homed ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
+  if (TERN0(LCD_SHOW_E_TOTAL, printingIsActive())) {
+    #if ENABLED(LCD_SHOW_E_TOTAL)
+      tft.add_text( 10, 3, COLOR_AXIS_HOMED , "E");
+      const uint8_t escale = e_move_accumulator >= 100000.0f ? 10 : 1; // After 100m switch to cm
+      tft_string.set(ftostr4sign(e_move_accumulator / escale));
+      tft_string.add(escale == 10 ? 'c' : 'm');
+      tft_string.add('m');
+      tft.add_text(127 - tft_string.width(), 3, COLOR_AXIS_HOMED, tft_string);
+    #endif
+  }
+  else {
+    tft.add_text( 10, 3, COLOR_AXIS_HOMED , "X");
+    const bool nhx = axis_should_home(X_AXIS);
+    tft_string.set(blink && nhx ? "?" : ftostr4sign(LOGICAL_X_POSITION(current_position.x)));
+    tft.add_text( 68 - tft_string.width(), 3, nhx ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
+
+    tft.add_text(127, 3, COLOR_AXIS_HOMED , "Y");
+    const bool nhy = axis_should_home(Y_AXIS);
+    tft_string.set(blink && nhy ? "?" : ftostr4sign(LOGICAL_Y_POSITION(current_position.y)));
+    tft.add_text(185 - tft_string.width(), 3, nhy ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
+  }
 
-  not_homed = axis_should_home(Z_AXIS);
+  tft.add_text(219, 3, COLOR_AXIS_HOMED , "Z");
+  const bool nhz = axis_should_home(Z_AXIS);
   uint16_t offset = 25;
-  if (blink && not_homed)
+  if (blink && nhz)
     tft_string.set("?");
   else {
     const float z = LOGICAL_Z_POSITION(current_position.z);
     tft_string.set(ftostr52sp((int16_t)z));
     tft_string.rtrim();
     offset += tft_string.width();
 
     tft_string.set(ftostr52sp(z));
     offset -= tft_string.width();
   }
-  tft.add_text(301 - tft_string.width() - offset, 3, not_homed ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
+  tft.add_text(301 - tft_string.width() - offset, 3, nhz ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
   TERN_(TOUCH_SCREEN, touch.add_control(MOVE_AXIS, 0, 103, 312, 24));
 
   // feed rate
   tft.canvas(70, 136, 80, 32);
   tft.set_background(COLOR_BACKGROUND);
   uint16_t color = feedrate_percentage == 100 ? COLOR_RATE_100 : COLOR_RATE_ALTERED;
   tft.add_image(0, 0, imgFeedRate, color);
   tft_string.set(i16tostr3rj(feedrate_percentage));
   tft_string.add('%');
   tft.add_text(32, 6, color , tft_string);

commit 417e2530ebc5b6c74ac34adaba8be552b407383a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 25 21:11:31 2021 -0500

    üé® Apply F() to G-code suite and queue

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index 15d477c485..1ef4c5881c 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -763,21 +763,21 @@ static void z_minus() { moveAxis(Z_AXIS, -1); }
   static void z_select() {
     motionAxisState.z_selection *= -1;
     quick_feedback();
     drawCurZSelection();
     drawAxisValue(Z_AXIS);
   }
 #endif
 
 static void disable_steppers() {
   quick_feedback();
-  queue.inject_P(PSTR("M84"));
+  queue.inject(F("M84"));
 }
 
 static void drawBtn(int x, int y, const char *label, intptr_t data, MarlinImage img, uint16_t bgColor, bool enabled = true) {
   uint16_t width = Images[imgBtn39Rounded].width;
   uint16_t height = Images[imgBtn39Rounded].height;
 
   if (!enabled) bgColor = COLOR_CONTROL_DISABLED;
 
   tft.canvas(x, y, width, height);
   tft.set_background(COLOR_BACKGROUND);

commit 228eb9c404fcbcebb507bbfe781ebe3ca0a1ccdf
Author: espr14 <espr14@gmail.com>
Date:   Mon Sep 27 21:05:52 2021 +0200

    üé® steps_to_mm => mm_per_step (#22847)

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index deffbae94c..15d477c485 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -645,21 +645,21 @@ static void moveAxis(const AxisEnum axis, const int8_t direction) {
       return;
     }
   #endif
 
   const float diff = motionAxisState.currentStepSize * direction;
 
   if (axis == Z_AXIS && motionAxisState.z_selection == Z_SELECTION_Z_PROBE) {
     #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
       const int16_t babystep_increment = direction * BABYSTEP_SIZE_Z;
       const bool do_probe = DISABLED(BABYSTEP_HOTEND_Z_OFFSET) || active_extruder == 0;
-      const float bsDiff = planner.steps_to_mm[Z_AXIS] * babystep_increment,
+      const float bsDiff = planner.mm_per_step[Z_AXIS] * babystep_increment,
                   new_probe_offset = probe.offset.z + bsDiff,
                   new_offs = TERN(BABYSTEP_HOTEND_Z_OFFSET
                     , do_probe ? new_probe_offset : hotend_offset[active_extruder].z - bsDiff
                     , new_probe_offset
                   );
       if (WITHIN(new_offs, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
         babystep.add_steps(Z_AXIS, babystep_increment);
         if (do_probe)
           probe.offset.z = new_offs;
         else

commit c2e4b1626f0cce82a55e8de9dc98ed9381e1d9ad
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Tue Sep 14 04:07:08 2021 +0200

    ‚ú® TFT Screen/Backlight Sleep (#22617)

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index 786dc61f60..deffbae94c 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -40,20 +40,21 @@
   #include "../../feature/filwidth.h"
   #include "../../gcode/parser.h"
 #endif
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
   #include "../../feature/bedlevel/bedlevel.h"
 #endif
 
 void MarlinUI::tft_idle() {
   #if ENABLED(TOUCH_SCREEN)
+    if (TERN0(HAS_TOUCH_SLEEP, lcd_sleep_task())) return;
     if (draw_menu_navigation) {
       add_control(48, 206, PAGE_UP, imgPageUp, encoderTopLine > 0);
       add_control(240, 206, PAGE_DOWN, imgPageDown, encoderTopLine + LCD_HEIGHT < screen_items);
       add_control(144, 206, BACK, imgBack);
       draw_menu_navigation = false;
     }
   #endif
 
   tft.queue.async();
   TERN_(TOUCH_SCREEN, touch.idle());

commit 7726af9c5348c1c7d0fd9a56eca87d00cd75fee6
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Sat Jun 5 09:18:47 2021 +0200

    üèóÔ∏è Support for up to 6 linear axes (#19112)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index f7b6ffc75d..786dc61f60 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -631,24 +631,26 @@ static void drawAxisValue(const AxisEnum axis) {
   }
   tft.canvas(pos.x, pos.y, BTN_WIDTH + X_MARGIN, 20);
   tft.set_background(COLOR_BACKGROUND);
   tft_string.set(ftostr52sp(value));
   tft.add_text(0, 0, color, tft_string);
 }
 
 static void moveAxis(const AxisEnum axis, const int8_t direction) {
   quick_feedback();
 
-  if (axis == E_AXIS && thermalManager.tooColdToExtrude(motionAxisState.e_selection)) {
-    drawMessage("Too cold");
-    return;
-  }
+  #if ENABLED(PREVENT_COLD_EXTRUSION)
+    if (axis == E_AXIS && thermalManager.tooColdToExtrude(motionAxisState.e_selection)) {
+      drawMessage("Too cold");
+      return;
+    }
+  #endif
 
   const float diff = motionAxisState.currentStepSize * direction;
 
   if (axis == Z_AXIS && motionAxisState.z_selection == Z_SELECTION_Z_PROBE) {
     #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
       const int16_t babystep_increment = direction * BABYSTEP_SIZE_Z;
       const bool do_probe = DISABLED(BABYSTEP_HOTEND_Z_OFFSET) || active_extruder == 0;
       const float bsDiff = planner.steps_to_mm[Z_AXIS] * babystep_increment,
                   new_probe_offset = probe.offset.z + bsDiff,
                   new_offs = TERN(BABYSTEP_HOTEND_Z_OFFSET

commit 84fd0eff17d089e3f75f6585d4bba47f15c00ba7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 23 21:33:22 2021 -0500

    üé® Macros for optional arguments (#21969)

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index 89a127b01e..f7b6ffc75d 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -702,25 +702,21 @@ static void moveAxis(const AxisEnum axis, const int8_t direction) {
 
     // Get the new position
     const bool limited = ui.manual_move.apply_diff(axis, diff, min, max);
     #if IS_KINEMATIC
       UNUSED(limited);
     #else
       PGM_P const msg = limited ? GET_TEXT(MSG_LCD_SOFT_ENDSTOPS) : NUL_STR;
       drawMessage(msg);
     #endif
 
-    ui.manual_move.soon(axis
-      #if MULTI_E_MANUAL
-        , motionAxisState.e_selection
-      #endif
-    );
+    ui.manual_move.soon(axis OPTARG(MULTI_E_MANUAL, motionAxisState.e_selection));
   }
 
   drawAxisValue(axis);
 }
 
 static void e_plus()  { moveAxis(E_AXIS, 1);  }
 static void e_minus() { moveAxis(E_AXIS, -1); }
 static void x_minus() { moveAxis(X_AXIS, -1); }
 static void x_plus()  { moveAxis(X_AXIS, 1);  }
 static void y_plus()  { moveAxis(Y_AXIS, 1);  }

commit 000388b1d9e38a2678e8235a5d4dc3163f853c02
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 20 17:12:18 2021 -0500

    üé® MULTI_MANUAL => MULTI_E_MANUAL

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index 31665fdc33..89a127b01e 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -703,21 +703,21 @@ static void moveAxis(const AxisEnum axis, const int8_t direction) {
     // Get the new position
     const bool limited = ui.manual_move.apply_diff(axis, diff, min, max);
     #if IS_KINEMATIC
       UNUSED(limited);
     #else
       PGM_P const msg = limited ? GET_TEXT(MSG_LCD_SOFT_ENDSTOPS) : NUL_STR;
       drawMessage(msg);
     #endif
 
     ui.manual_move.soon(axis
-      #if MULTI_MANUAL
+      #if MULTI_E_MANUAL
         , motionAxisState.e_selection
       #endif
     );
   }
 
   drawAxisValue(axis);
 }
 
 static void e_plus()  { moveAxis(E_AXIS, 1);  }
 static void e_minus() { moveAxis(E_AXIS, -1); }

commit 2e0a1f1afff71a29e5fb5eb99c509d0de5384087
Author: David <davidtgbe@hotmail.com>
Date:   Wed Apr 28 11:08:21 2021 +0200

    Color UI Move Screen for 320x240 TFT (#21708)

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index 8e7365932b..31665fdc33 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -234,20 +234,23 @@ void MarlinUI::draw_status_screen() {
       #endif
       #ifdef ITEM_E2
         case ITEM_E2: draw_heater_status(x, y, H_E2); break;
       #endif
       #ifdef ITEM_BED
         case ITEM_BED: draw_heater_status(x, y, H_BED); break;
       #endif
       #ifdef ITEM_CHAMBER
         case ITEM_CHAMBER: draw_heater_status(x, y, H_CHAMBER); break;
       #endif
+      #ifdef ITEM_COOLER
+        case ITEM_COOLER: draw_heater_status(x, y, H_COOLER); break;
+      #endif
       #ifdef ITEM_FAN
         case ITEM_FAN: draw_fan_status(x, y, blink); break;
       #endif
     }
   }
 
   // coordinates
   tft.canvas(4, 103, 312, 24);
   tft.set_background(COLOR_BACKGROUND);
   tft.add_rectangle(0, 0, 312, 24, COLOR_AXIS_HOMED);
@@ -271,20 +274,21 @@ void MarlinUI::draw_status_screen() {
   else {
     const float z = LOGICAL_Z_POSITION(current_position.z);
     tft_string.set(ftostr52sp((int16_t)z));
     tft_string.rtrim();
     offset += tft_string.width();
 
     tft_string.set(ftostr52sp(z));
     offset -= tft_string.width();
   }
   tft.add_text(301 - tft_string.width() - offset, 3, not_homed ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
+  TERN_(TOUCH_SCREEN, touch.add_control(MOVE_AXIS, 0, 103, 312, 24));
 
   // feed rate
   tft.canvas(70, 136, 80, 32);
   tft.set_background(COLOR_BACKGROUND);
   uint16_t color = feedrate_percentage == 100 ? COLOR_RATE_100 : COLOR_RATE_ALTERED;
   tft.add_image(0, 0, imgFeedRate, color);
   tft_string.set(i16tostr3rj(feedrate_percentage));
   tft_string.add('%');
   tft.add_text(32, 6, color , tft_string);
   TERN_(TOUCH_SCREEN, touch.add_control(FEEDRATE, 70, 136, 80, 32));
@@ -347,30 +351,30 @@ void MenuEditItemBase::draw_edit_screen(PGM_P const pstr, const char * const val
   menu_line(line);
   tft_string.set(value);
   tft_string.trim();
   tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
 
   #if ENABLED(AUTO_BED_LEVELING_UBL)
     if (ui.external_control) {
       menu_line(line - 1);
 
       tft_string.set(X_LBL);
-      tft.add_text(52, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
+      tft.add_text(TFT_WIDTH / 2 - 120, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
       tft_string.set(ftostr52(LOGICAL_X_POSITION(current_position.x)));
       tft_string.trim();
-      tft.add_text(144 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
+      tft.add_text(TFT_WIDTH / 2 - 16 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
 
       tft_string.set(Y_LBL);
-      tft.add_text(176, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
+      tft.add_text(TFT_WIDTH / 2 + 16, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
       tft_string.set(ftostr52(LOGICAL_X_POSITION(current_position.y)));
       tft_string.trim();
-      tft.add_text(268 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
+      tft.add_text(TFT_WIDTH / 2 + 120 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
     }
   #endif
 
   extern screenFunc_t _manual_move_func_ptr;
   if (ui.currentScreen != _manual_move_func_ptr && !ui.external_control) {
 
     #define SLIDER_LENGTH 224
     #define SLIDER_Y_POSITION 140
 
     tft.canvas((TFT_WIDTH - SLIDER_LENGTH) / 2, SLIDER_Y_POSITION, SLIDER_LENGTH, 16);
@@ -386,23 +390,23 @@ void MenuEditItemBase::draw_edit_screen(PGM_P const pstr, const char * const val
       tft.add_image((SLIDER_LENGTH - 8) * ui.encoderPosition / maxEditValue, 0, imgSlider, COLOR_SLIDER);
       touch.add_control(SLIDER, (TFT_WIDTH - SLIDER_LENGTH) / 2, SLIDER_Y_POSITION - 8, SLIDER_LENGTH, 32, maxEditValue);
     #endif
   }
 
   tft.draw_edit_screen_buttons();
 }
 
 void TFT::draw_edit_screen_buttons() {
   #if ENABLED(TOUCH_SCREEN)
-    add_control(32, 176, DECREASE, imgDecrease);
-    add_control(224, 176, INCREASE, imgIncrease);
-    add_control(128, 176, CLICK, imgConfirm);
+    add_control(32, TFT_HEIGHT - 64, DECREASE, imgDecrease);
+    add_control(224, TFT_HEIGHT - 64, INCREASE, imgIncrease);
+    add_control(128, TFT_HEIGHT - 64, CLICK, imgConfirm);
   #endif
 }
 
 // The Select Screen presents a prompt and two "buttons"
 void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const bool yesno, PGM_P const pref, const char * const string/*=nullptr*/, PGM_P const suff/*=nullptr*/) {
   uint16_t line = 1;
 
   if (!string) line++;
 
   menu_line(line++);
@@ -417,32 +421,32 @@ void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const
     tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
   }
 
   if (suff) {
     menu_line(line);
     tft_string.set(suff);
     tft_string.trim();
     tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
   }
   #if ENABLED(TOUCH_SCREEN)
-    add_control(48, 176, CANCEL, imgCancel, true, yesno ? HALF(COLOR_CONTROL_CANCEL) : COLOR_CONTROL_CANCEL);
-    add_control(208, 176, CONFIRM, imgConfirm, true, yesno ? COLOR_CONTROL_CONFIRM : HALF(COLOR_CONTROL_CONFIRM));
+    add_control(48, TFT_HEIGHT - 64, CANCEL, imgCancel, true, yesno ? HALF(COLOR_CONTROL_CANCEL) : COLOR_CONTROL_CANCEL);
+    add_control(208, TFT_HEIGHT - 64, CONFIRM, imgConfirm, true, yesno ? COLOR_CONTROL_CONFIRM : HALF(COLOR_CONTROL_CONFIRM));
   #endif
 }
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
 
   void MarlinUI::draw_hotend_status(const uint8_t row, const uint8_t extruder) {
     #if ENABLED(TOUCH_SCREEN)
       touch.clear();
       draw_menu_navigation = false;
-      touch.add_control(RESUME_CONTINUE , 0, 0, 320, 240);
+      touch.add_control(RESUME_CONTINUE , 0, 0, TFT_WIDTH, TFT_HEIGHT);
     #endif
 
     menu_line(row);
     tft_string.set(GET_TEXT(MSG_FILAMENT_CHANGE_NOZZLE));
     tft_string.add('E');
     tft_string.add((char)('1' + extruder));
     tft_string.add(' ');
     tft_string.add(i16tostr3rj(thermalManager.wholeDegHotend(extruder)));
     tft_string.add(LCD_STR_DEGREE);
     tft_string.add(" / ");
@@ -470,64 +474,433 @@ void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const
     for (uint16_t x = 0; x < (GRID_MAX_POINTS_X); x++)
       for (uint16_t y = 0; y < (GRID_MAX_POINTS_Y); y++)
         if (position_is_reachable({ ubl.mesh_index_to_xpos(x), ubl.mesh_index_to_ypos(y) }))
           tft.add_bar(1 + (x * 2 + 1) * (GRID_WIDTH - 4) / (GRID_MAX_POINTS_X) / 2, GRID_HEIGHT - 3 - ((y * 2 + 1) * (GRID_HEIGHT - 4) / (GRID_MAX_POINTS_Y) / 2), 2, 2, COLOR_UBL);
 
     tft.add_rectangle((x_plot * 2 + 1) * (GRID_WIDTH - 4) / (GRID_MAX_POINTS_X) / 2 - 1, GRID_HEIGHT - 5 - ((y_plot * 2 + 1) * (GRID_HEIGHT - 4) / (GRID_MAX_POINTS_Y) / 2), 6, 6, COLOR_UBL);
 
     const xy_pos_t pos = { ubl.mesh_index_to_xpos(x_plot), ubl.mesh_index_to_ypos(y_plot) },
                    lpos = pos.asLogical();
 
-    tft.canvas(216, GRID_OFFSET_Y + (GRID_HEIGHT - 32) / 2 - 32, 96, 32);
+    tft.canvas(216, GRID_OFFSET_Y + (GRID_HEIGHT - MENU_ITEM_HEIGHT) / 2 - MENU_ITEM_HEIGHT, 96, MENU_ITEM_HEIGHT);
     tft.set_background(COLOR_BACKGROUND);
     tft_string.set(X_LBL);
     tft.add_text(0, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
     tft_string.set(ftostr52(lpos.x));
     tft_string.trim();
     tft.add_text(96 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
 
-    tft.canvas(216, GRID_OFFSET_Y + (GRID_HEIGHT - 32) / 2, 96, 32);
+    tft.canvas(216, GRID_OFFSET_Y + (GRID_HEIGHT - MENU_ITEM_HEIGHT) / 2, 96, MENU_ITEM_HEIGHT);
     tft.set_background(COLOR_BACKGROUND);
     tft_string.set(Y_LBL);
     tft.add_text(0, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
     tft_string.set(ftostr52(lpos.y));
     tft_string.trim();
     tft.add_text(96 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
 
-    tft.canvas(216, GRID_OFFSET_Y + (GRID_HEIGHT - 32) / 2 + 32, 96, 32);
+    tft.canvas(216, GRID_OFFSET_Y + (GRID_HEIGHT - MENU_ITEM_HEIGHT) / 2 + MENU_ITEM_HEIGHT, 96, MENU_ITEM_HEIGHT);
     tft.set_background(COLOR_BACKGROUND);
     tft_string.set(Z_LBL);
     tft.add_text(0, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
     tft_string.set(isnan(ubl.z_values[x_plot][y_plot]) ? "-----" : ftostr43sign(ubl.z_values[x_plot][y_plot]));
     tft_string.trim();
     tft.add_text(96 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
 
     constexpr uint8_t w = (TFT_WIDTH) / 10;
-    tft.canvas(GRID_OFFSET_X + (GRID_WIDTH - w) / 2, GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET - 1, w, 32);
+    tft.canvas(GRID_OFFSET_X + (GRID_WIDTH - w) / 2, GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET - 1, w, MENU_ITEM_HEIGHT);
     tft.set_background(COLOR_BACKGROUND);
     tft_string.set(ui8tostr3rj(x_plot));
     tft_string.trim();
     tft.add_text(tft_string.center(w), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
 
-    tft.canvas(GRID_OFFSET_X + GRID_WIDTH + CONTROL_OFFSET, GRID_OFFSET_Y + (GRID_HEIGHT - 27) / 2, w, 32);
+    tft.canvas(GRID_OFFSET_X + GRID_WIDTH + CONTROL_OFFSET, GRID_OFFSET_Y + (GRID_HEIGHT - 27) / 2, w, MENU_ITEM_HEIGHT);
     tft.set_background(COLOR_BACKGROUND);
     tft_string.set(ui8tostr3rj(y_plot));
     tft_string.trim();
     tft.add_text(tft_string.center(w), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
 
     #if ENABLED(TOUCH_SCREEN)
       touch.clear();
       draw_menu_navigation = false;
       add_control(GRID_OFFSET_X + GRID_WIDTH + CONTROL_OFFSET,      GRID_OFFSET_Y + CONTROL_OFFSET,                    UBL,  (ENCODER_STEPS_PER_MENU_ITEM) * (GRID_MAX_POINTS_X), imgUp);
       add_control(GRID_OFFSET_X + GRID_WIDTH + CONTROL_OFFSET,      GRID_OFFSET_Y + GRID_HEIGHT - CONTROL_OFFSET - 32, UBL, -(ENCODER_STEPS_PER_MENU_ITEM) * (GRID_MAX_POINTS_X), imgDown);
       add_control(GRID_OFFSET_X + CONTROL_OFFSET,                   GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET,      UBL, -(ENCODER_STEPS_PER_MENU_ITEM), imgLeft);
       add_control(GRID_OFFSET_X + GRID_WIDTH - CONTROL_OFFSET - 32, GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET,      UBL,   ENCODER_STEPS_PER_MENU_ITEM, imgRight);
       add_control(224, GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET, CLICK, imgLeveling);
       add_control(144, 206, BACK, imgBack);
     #endif
   }
 #endif // AUTO_BED_LEVELING_UBL
 
+#if ENABLED(BABYSTEP_ZPROBE_OFFSET)
+  #include "../../feature/babystep.h"
+#endif
+
+#if HAS_BED_PROBE
+  #include "../../module/probe.h"
+#endif
+
+#define Z_SELECTION_Z 1
+#define Z_SELECTION_Z_PROBE -1
+
+struct MotionAxisState {
+  xy_int_t xValuePos, yValuePos, zValuePos, eValuePos, stepValuePos, zTypePos, eNamePos;
+  float currentStepSize = 10.0;
+  int z_selection = Z_SELECTION_Z;
+  uint8_t e_selection = 0;
+  bool blocked = false;
+  char message[32];
+};
+
+MotionAxisState motionAxisState;
+
+#define E_BTN_COLOR COLOR_YELLOW
+#define X_BTN_COLOR COLOR_CORAL_RED
+#define Y_BTN_COLOR COLOR_VIVID_GREEN
+#define Z_BTN_COLOR COLOR_LIGHT_BLUE
+
+#define BTN_WIDTH 48
+#define BTN_HEIGHT 39
+#define X_MARGIN 15
+#define Y_MARGIN 11
+
+static void quick_feedback() {
+  #if HAS_CHIRP
+    ui.chirp(); // Buzz and wait. Is the delay needed for buttons to settle?
+    #if BOTH(HAS_LCD_MENU, USE_BEEPER)
+      for (int8_t i = 5; i--;) { buzzer.tick(); delay(2); }
+    #elif HAS_LCD_MENU
+      delay(10);
+    #endif
+  #endif
+}
+
+#define CUR_STEP_VALUE_WIDTH 38
+static void drawCurStepValue() {
+  tft_string.set((uint8_t *)ftostr52sp(motionAxisState.currentStepSize));
+  tft.canvas(motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y, CUR_STEP_VALUE_WIDTH, 20);
+  tft.set_background(COLOR_BACKGROUND);
+  tft.add_text(CUR_STEP_VALUE_WIDTH - tft_string.width(), 0, COLOR_AXIS_HOMED, tft_string);
+  tft.queue.sync();
+  tft_string.set("mm");
+  tft.canvas(motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y + 20, CUR_STEP_VALUE_WIDTH, 20);
+  tft.set_background(COLOR_BACKGROUND);
+  tft.add_text(CUR_STEP_VALUE_WIDTH - tft_string.width(), 0, COLOR_AXIS_HOMED, tft_string);
+}
+
+static void drawCurZSelection() {
+  tft_string.set("Z");
+  tft.canvas(motionAxisState.zTypePos.x, motionAxisState.zTypePos.y, tft_string.width(), 20);
+  tft.set_background(COLOR_BACKGROUND);
+  tft.add_text(0, 0, Z_BTN_COLOR, tft_string);
+  tft.queue.sync();
+  tft_string.set("Offset");
+  tft.canvas(motionAxisState.zTypePos.x, motionAxisState.zTypePos.y + 34, tft_string.width(), 20);
+  tft.set_background(COLOR_BACKGROUND);
+  if (motionAxisState.z_selection == Z_SELECTION_Z_PROBE) {
+    tft.add_text(0, 0, Z_BTN_COLOR, tft_string);
+  }
+}
+
+static void drawCurESelection() {
+  tft.canvas(motionAxisState.eNamePos.x, motionAxisState.eNamePos.y, BTN_WIDTH, BTN_HEIGHT);
+  tft.set_background(COLOR_BACKGROUND);
+  tft_string.set("E");
+  tft.add_text(0, 0, E_BTN_COLOR , tft_string);
+  tft.add_text(tft_string.width(), 0, E_BTN_COLOR, ui8tostr3rj(motionAxisState.e_selection));
+}
+
+static void drawMessage(const char *msg) {
+  tft.canvas(X_MARGIN, TFT_HEIGHT - Y_MARGIN - 29, (TFT_WIDTH / 2) - (BTN_WIDTH / 2) - X_MARGIN, 20);
+  tft.set_background(COLOR_BACKGROUND);
+  tft.add_text(0, 0, COLOR_YELLOW, msg);
+}
+
+static void drawAxisValue(const AxisEnum axis) {
+  const float value = (
+    TERN_(HAS_BED_PROBE, axis == Z_AXIS && motionAxisState.z_selection == Z_SELECTION_Z_PROBE ? probe.offset.z :)
+    ui.manual_move.axis_value(axis)
+  );
+  xy_int_t pos;
+  uint16_t color;
+  switch (axis) {
+    case X_AXIS: pos = motionAxisState.xValuePos; color = X_BTN_COLOR; break;
+    case Y_AXIS: pos = motionAxisState.yValuePos; color = Y_BTN_COLOR; break;
+    case Z_AXIS: pos = motionAxisState.zValuePos; color = Z_BTN_COLOR; break;
+    case E_AXIS: pos = motionAxisState.eValuePos; color = E_BTN_COLOR; break;
+    default: return;
+  }
+  tft.canvas(pos.x, pos.y, BTN_WIDTH + X_MARGIN, 20);
+  tft.set_background(COLOR_BACKGROUND);
+  tft_string.set(ftostr52sp(value));
+  tft.add_text(0, 0, color, tft_string);
+}
+
+static void moveAxis(const AxisEnum axis, const int8_t direction) {
+  quick_feedback();
+
+  if (axis == E_AXIS && thermalManager.tooColdToExtrude(motionAxisState.e_selection)) {
+    drawMessage("Too cold");
+    return;
+  }
+
+  const float diff = motionAxisState.currentStepSize * direction;
+
+  if (axis == Z_AXIS && motionAxisState.z_selection == Z_SELECTION_Z_PROBE) {
+    #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
+      const int16_t babystep_increment = direction * BABYSTEP_SIZE_Z;
+      const bool do_probe = DISABLED(BABYSTEP_HOTEND_Z_OFFSET) || active_extruder == 0;
+      const float bsDiff = planner.steps_to_mm[Z_AXIS] * babystep_increment,
+                  new_probe_offset = probe.offset.z + bsDiff,
+                  new_offs = TERN(BABYSTEP_HOTEND_Z_OFFSET
+                    , do_probe ? new_probe_offset : hotend_offset[active_extruder].z - bsDiff
+                    , new_probe_offset
+                  );
+      if (WITHIN(new_offs, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
+        babystep.add_steps(Z_AXIS, babystep_increment);
+        if (do_probe)
+          probe.offset.z = new_offs;
+        else
+          TERN(BABYSTEP_HOTEND_Z_OFFSET, hotend_offset[active_extruder].z = new_offs, NOOP);
+        drawMessage(""); // clear the error
+        drawAxisValue(axis);
+      }
+      else {
+        drawMessage(GET_TEXT(MSG_LCD_SOFT_ENDSTOPS));
+      }
+    #elif HAS_BED_PROBE
+      // only change probe.offset.z
+      probe.offset.z += diff;
+      if (direction < 0 && current_position[axis] < Z_PROBE_OFFSET_RANGE_MIN) {
+        current_position[axis] = Z_PROBE_OFFSET_RANGE_MIN;
+        drawMessage(GET_TEXT(MSG_LCD_SOFT_ENDSTOPS));
+      }
+      else if (direction > 0 && current_position[axis] > Z_PROBE_OFFSET_RANGE_MAX) {
+        current_position[axis] = Z_PROBE_OFFSET_RANGE_MAX;
+        drawMessage(GET_TEXT(MSG_LCD_SOFT_ENDSTOPS));
+      }
+      else {
+        drawMessage(""); // clear the error
+      }
+      drawAxisValue(axis);
+    #endif
+    return;
+  }
+
+  if (!ui.manual_move.processing) {
+    // Get motion limit from software endstops, if any
+    float min, max;
+    soft_endstop.get_manual_axis_limits(axis, min, max);
+
+    // Delta limits XY based on the current offset from center
+    // This assumes the center is 0,0
+    #if ENABLED(DELTA)
+      if (axis != Z_AXIS && axis != E_AXIS) {
+        max = SQRT(sq((float)(DELTA_PRINTABLE_RADIUS)) - sq(current_position[Y_AXIS - axis])); // (Y_AXIS - axis) == the other axis
+        min = -max;
+      }
+    #endif
+
+    // Get the new position
+    const bool limited = ui.manual_move.apply_diff(axis, diff, min, max);
+    #if IS_KINEMATIC
+      UNUSED(limited);
+    #else
+      PGM_P const msg = limited ? GET_TEXT(MSG_LCD_SOFT_ENDSTOPS) : NUL_STR;
+      drawMessage(msg);
+    #endif
+
+    ui.manual_move.soon(axis
+      #if MULTI_MANUAL
+        , motionAxisState.e_selection
+      #endif
+    );
+  }
+
+  drawAxisValue(axis);
+}
+
+static void e_plus()  { moveAxis(E_AXIS, 1);  }
+static void e_minus() { moveAxis(E_AXIS, -1); }
+static void x_minus() { moveAxis(X_AXIS, -1); }
+static void x_plus()  { moveAxis(X_AXIS, 1);  }
+static void y_plus()  { moveAxis(Y_AXIS, 1);  }
+static void y_minus() { moveAxis(Y_AXIS, -1); }
+static void z_plus()  { moveAxis(Z_AXIS, 1);  }
+static void z_minus() { moveAxis(Z_AXIS, -1); }
+
+#if ENABLED(TOUCH_SCREEN)
+  static void e_select() {
+    motionAxisState.e_selection++;
+    if (motionAxisState.e_selection >= EXTRUDERS) {
+      motionAxisState.e_selection = 0;
+    }
+
+    quick_feedback();
+    drawCurESelection();
+    drawAxisValue(E_AXIS);
+  }
+
+  static void do_home() {
+    quick_feedback();
+    drawMessage(GET_TEXT(MSG_LEVEL_BED_HOMING));
+    queue.inject_P(G28_STR);
+    // Disable touch until home is done
+    TERN_(HAS_TFT_XPT2046, touch.disable());
+    drawAxisValue(E_AXIS);
+    drawAxisValue(X_AXIS);
+    drawAxisValue(Y_AXIS);
+    drawAxisValue(Z_AXIS);
+  }
+
+  static void step_size() {
+    motionAxisState.currentStepSize = motionAxisState.currentStepSize / 10.0;
+    if (motionAxisState.currentStepSize < 0.0015) motionAxisState.currentStepSize = 10.0;
+    quick_feedback();
+    drawCurStepValue();
+  }
+#endif
+
+#if HAS_BED_PROBE
+  static void z_select() {
+    motionAxisState.z_selection *= -1;
+    quick_feedback();
+    drawCurZSelection();
+    drawAxisValue(Z_AXIS);
+  }
+#endif
+
+static void disable_steppers() {
+  quick_feedback();
+  queue.inject_P(PSTR("M84"));
+}
+
+static void drawBtn(int x, int y, const char *label, intptr_t data, MarlinImage img, uint16_t bgColor, bool enabled = true) {
+  uint16_t width = Images[imgBtn39Rounded].width;
+  uint16_t height = Images[imgBtn39Rounded].height;
+
+  if (!enabled) bgColor = COLOR_CONTROL_DISABLED;
+
+  tft.canvas(x, y, width, height);
+  tft.set_background(COLOR_BACKGROUND);
+  tft.add_image(0, 0, imgBtn39Rounded, bgColor, COLOR_BACKGROUND, COLOR_DARKGREY);
+
+  // TODO: Make an add_text() taking a font arg
+  if (label) {
+    tft_string.set(label);
+    tft_string.trim();
+    tft.add_text(tft_string.center(width), height / 2 - tft_string.font_height() / 2, bgColor, tft_string);
+  }
+  else {
+    tft.add_image(0, 0, img, bgColor, COLOR_BACKGROUND, COLOR_DARKGREY);
+  }
+
+  TERN_(HAS_TFT_XPT2046, if (enabled) touch.add_control(BUTTON, x, y, width, height, data));
+}
 void MarlinUI::move_axis_screen() {
+  // Reset
+  defer_status_screen(true);
+  motionAxisState.blocked = false;
+  TERN_(HAS_TFT_XPT2046, touch.enable());
+
+  ui.clear_lcd();
+
+  TERN_(TOUCH_SCREEN, touch.clear());
+
+  const bool busy = printingIsActive();
+
+  // Babysteps during printing? Select babystep for Z probe offset
+  if (busy && ENABLED(BABYSTEP_ZPROBE_OFFSET))
+    motionAxisState.z_selection = Z_SELECTION_Z_PROBE;
+
+  // ROW 1 -> E- Y- CurY Z+
+  int x = X_MARGIN, y = Y_MARGIN, spacing = 0;
+
+  drawBtn(x, y, "E+", (intptr_t)e_plus, imgUp, E_BTN_COLOR, !busy);
+
+  spacing = (TFT_WIDTH - X_MARGIN * 2 - 3 * BTN_WIDTH) / 2;
+  x += BTN_WIDTH + spacing;
+  uint16_t yplus_x = x;
+  drawBtn(x, y, "Y+", (intptr_t)y_plus, imgUp, Y_BTN_COLOR, !busy);
+
+  // Cur Y
+  x += BTN_WIDTH;
+  motionAxisState.yValuePos.x = x + 2;
+  motionAxisState.yValuePos.y = y;
+  drawAxisValue(Y_AXIS);
+
+  x += spacing;
+  drawBtn(x, y, "Z+", (intptr_t)z_plus, imgUp, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); //only enabled when not busy or have baby step
+
+  // ROW 2 -> "Ex"  X-  HOME X+  "Z"
+  y += BTN_HEIGHT + (TFT_HEIGHT - Y_MARGIN * 2 - 4 * BTN_HEIGHT) / 3;
+  x = X_MARGIN;
+  spacing = (TFT_WIDTH - X_MARGIN * 2 - 5 * BTN_WIDTH) / 4;
+
+  motionAxisState.eNamePos.x = x;
+  motionAxisState.eNamePos.y = y;
+  drawCurESelection();
+  TERN_(HAS_TFT_XPT2046, if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, BTN_HEIGHT, (intptr_t)e_select));
+
+  x += BTN_WIDTH + spacing;
+  drawBtn(x, y, "X-", (intptr_t)x_minus, imgLeft, X_BTN_COLOR, !busy);
+
+  x += BTN_WIDTH + spacing; //imgHome is 64x64
+  TERN_(HAS_TFT_XPT2046, add_control(TFT_WIDTH / 2 - Images[imgHome].width / 2, y - (Images[imgHome].width - BTN_HEIGHT) / 2, BUTTON, (intptr_t)do_home, imgHome, !busy));
+
+  x += BTN_WIDTH + spacing;
+  uint16_t xplus_x = x;
+  drawBtn(x, y, "X+", (intptr_t)x_plus, imgRight, X_BTN_COLOR, !busy);
+
+  x += BTN_WIDTH + spacing;
+  motionAxisState.zTypePos.x = x;
+  motionAxisState.zTypePos.y = y;
+  drawCurZSelection();
+  #if BOTH(HAS_BED_PROBE, TOUCH_SCREEN)
+    if (!busy) touch.add_control(BUTTON, x, y, BTN_WIDTH, 34 * 2, (intptr_t)z_select);
+  #endif
+
+  // ROW 3 -> E- CurX Y-  Z-
+  y += BTN_HEIGHT + (TFT_HEIGHT - Y_MARGIN * 2 - 4 * BTN_HEIGHT) / 3;
+  x = X_MARGIN;
+  spacing = (TFT_WIDTH - X_MARGIN * 2 - 3 * BTN_WIDTH) / 2;
+
+  drawBtn(x, y, "E-", (intptr_t)e_minus, imgDown, E_BTN_COLOR, !busy);
+
+  // Cur E
+  motionAxisState.eValuePos.x = x;
+  motionAxisState.eValuePos.y = y + BTN_HEIGHT + 2;
+  drawAxisValue(E_AXIS);
+
+  // Cur X
+  motionAxisState.xValuePos.x = BTN_WIDTH + (TFT_WIDTH - X_MARGIN * 2 - 5 * BTN_WIDTH) / 4; //X- pos
+  motionAxisState.xValuePos.y = y - 10;
+  drawAxisValue(X_AXIS);
+
+  x += BTN_WIDTH + spacing;
+  drawBtn(x, y, "Y-", (intptr_t)y_minus, imgDown, Y_BTN_COLOR, !busy);
+
+  x += BTN_WIDTH + spacing;
+  drawBtn(x, y, "Z-", (intptr_t)z_minus, imgDown, Z_BTN_COLOR, !busy || ENABLED(BABYSTEP_ZPROBE_OFFSET)); //only enabled when not busy or have baby step
+
+  // Cur Z
+  motionAxisState.zValuePos.x = x;
+  motionAxisState.zValuePos.y = y + BTN_HEIGHT + 2;
+  drawAxisValue(Z_AXIS);
+
+  // ROW 4 -> step_size  disable steppers back
+  y = TFT_HEIGHT - Y_MARGIN - BTN_HEIGHT; //
+  x = xplus_x - CUR_STEP_VALUE_WIDTH - 10;
+  motionAxisState.stepValuePos.x = yplus_x + BTN_WIDTH - CUR_STEP_VALUE_WIDTH;
+  motionAxisState.stepValuePos.y = TFT_HEIGHT - Y_MARGIN - BTN_HEIGHT;
+  if (!busy) {
+    drawCurStepValue();
+    TERN_(HAS_TFT_XPT2046, touch.add_control(BUTTON, motionAxisState.stepValuePos.x, motionAxisState.stepValuePos.y, CUR_STEP_VALUE_WIDTH, BTN_HEIGHT, (intptr_t)step_size));
+  }
+
+  // aligned with x+
+  drawBtn(xplus_x, y, "off", (intptr_t)disable_steppers, imgCancel, COLOR_WHITE, !busy);
+
+  TERN_(HAS_TFT_XPT2046, add_control(TFT_WIDTH - X_MARGIN - BTN_WIDTH, y, BACK, imgBack));
 }
 
 #endif // HAS_UI_320x240

commit a29aefc9c0c02c23862fded29e3f950ead339238
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 24 01:29:30 2021 -0500

    Move last bootscreen delay to end of setup (#21665)

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index 68457baa1c..8e7365932b 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -53,20 +53,21 @@ void MarlinUI::tft_idle() {
       add_control(144, 206, BACK, imgBack);
       draw_menu_navigation = false;
     }
   #endif
 
   tft.queue.async();
   TERN_(TOUCH_SCREEN, touch.idle());
 }
 
 #if ENABLED(SHOW_BOOTSCREEN)
+
   void MarlinUI::show_bootscreen() {
     tft.queue.reset();
 
     tft.canvas(0, 0, TFT_WIDTH, TFT_HEIGHT);
     #if ENABLED(BOOT_MARLIN_LOGO_SMALL)
       #define BOOT_LOGO_W 195   // MarlinLogo195x59x16
       #define BOOT_LOGO_H  59
       #define SITE_URL_Y (TFT_HEIGHT - 46)
       tft.set_background(COLOR_BACKGROUND);
     #else
@@ -74,23 +75,27 @@ void MarlinUI::tft_idle() {
       #define BOOT_LOGO_H TFT_HEIGHT
       #define SITE_URL_Y (TFT_HEIGHT - 52)
     #endif
     tft.add_image((TFT_WIDTH - BOOT_LOGO_W) / 2, (TFT_HEIGHT - BOOT_LOGO_H) / 2, imgBootScreen);
     #ifdef WEBSITE_URL
       tft_string.set(WEBSITE_URL);
       tft.add_text(tft_string.center(TFT_WIDTH), SITE_URL_Y, COLOR_WEBSITE_URL, tft_string);
     #endif
 
     tft.queue.sync();
-    safe_delay(BOOTSCREEN_TIMEOUT);
+  }
+
+  void MarlinUI::bootscreen_completion(const millis_t sofar) {
+    if ((BOOTSCREEN_TIMEOUT) > sofar) safe_delay((BOOTSCREEN_TIMEOUT) - sofar);
     clear_lcd();
   }
+
 #endif
 
 void MarlinUI::draw_kill_screen() {
   tft.queue.reset();
   tft.fill(0, 0, TFT_WIDTH, TFT_HEIGHT, COLOR_KILL_SCREEN_BG);
 
   tft.canvas(0, 60, TFT_WIDTH, 20);
   tft.set_background(COLOR_KILL_SCREEN_BG);
   tft_string.set(status_message);
   tft_string.trim();

commit c4620bb5285438e41fa4c39229aa2a39859877ca
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Apr 23 20:19:23 2021 -0500

    Add whole-degree accessors, simplify some temperature-related features (#21685)

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index 5563d3069b..68457baa1c 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -110,42 +110,42 @@ void MarlinUI::draw_kill_screen() {
 
   tft.queue.sync();
 }
 
 void draw_heater_status(uint16_t x, uint16_t y, const int8_t Heater) {
   MarlinImage image = imgHotEnd;
   uint16_t Color;
   celsius_t currentTemperature, targetTemperature;
 
   if (Heater >= 0) { // HotEnd
-    currentTemperature = thermalManager.degHotend(Heater);
+    currentTemperature = thermalManager.wholeDegHotend(Heater);
     targetTemperature = thermalManager.degTargetHotend(Heater);
   }
   #if HAS_HEATED_BED
     else if (Heater == H_BED) {
-      currentTemperature = thermalManager.degBed();
+      currentTemperature = thermalManager.wholeDegBed();
       targetTemperature = thermalManager.degTargetBed();
     }
   #endif
   #if HAS_TEMP_CHAMBER
     else if (Heater == H_CHAMBER) {
-      currentTemperature = thermalManager.degChamber();
+      currentTemperature = thermalManager.wholeDegChamber();
       #if HAS_HEATED_CHAMBER
         targetTemperature = thermalManager.degTargetChamber();
       #else
         targetTemperature = ABSOLUTE_ZERO;
       #endif
     }
   #endif
   #if HAS_TEMP_COOLER
     else if (Heater == H_COOLER) {
-      currentTemperature = thermalManager.degCooler();
+      currentTemperature = thermalManager.wholeDegCooler();
       targetTemperature = TERN(HAS_COOLER, thermalManager.degTargetCooler(), ABSOLUTE_ZERO);
     }
   #endif
   else return;
 
   TERN_(TOUCH_SCREEN, if (targetTemperature >= 0) touch.add_control(HEATER, x, y, 64, 100, Heater));
   tft.canvas(x, y, 64, 100);
   tft.set_background(COLOR_BACKGROUND);
 
   Color = currentTemperature < 0 ? COLOR_INACTIVE : COLOR_COLD;
@@ -431,21 +431,21 @@ void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const
       touch.clear();
       draw_menu_navigation = false;
       touch.add_control(RESUME_CONTINUE , 0, 0, 320, 240);
     #endif
 
     menu_line(row);
     tft_string.set(GET_TEXT(MSG_FILAMENT_CHANGE_NOZZLE));
     tft_string.add('E');
     tft_string.add((char)('1' + extruder));
     tft_string.add(' ');
-    tft_string.add(i16tostr3rj(thermalManager.degHotend(extruder)));
+    tft_string.add(i16tostr3rj(thermalManager.wholeDegHotend(extruder)));
     tft_string.add(LCD_STR_DEGREE);
     tft_string.add(" / ");
     tft_string.add(i16tostr3rj(thermalManager.degTargetHotend(extruder)));
     tft_string.add(LCD_STR_DEGREE);
     tft_string.trim();
     tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
   }
 
 #endif // ADVANCED_PAUSE_FEATURE
 

commit 528b9bd8729656d7ebcd3dc7898ceddc2f377354
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Apr 16 02:43:59 2021 -0500

    Revert experimental NAN patch
    
    Hold changes from #21575 (24a095c) for more testing.

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index 8429907f96..5563d3069b 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -485,21 +485,21 @@ void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const
     tft_string.set(Y_LBL);
     tft.add_text(0, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
     tft_string.set(ftostr52(lpos.y));
     tft_string.trim();
     tft.add_text(96 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
 
     tft.canvas(216, GRID_OFFSET_Y + (GRID_HEIGHT - 32) / 2 + 32, 96, 32);
     tft.set_background(COLOR_BACKGROUND);
     tft_string.set(Z_LBL);
     tft.add_text(0, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
-    tft_string.set(ISNAN(ubl.z_values[x_plot][y_plot]) ? "-----" : ftostr43sign(ubl.z_values[x_plot][y_plot]));
+    tft_string.set(isnan(ubl.z_values[x_plot][y_plot]) ? "-----" : ftostr43sign(ubl.z_values[x_plot][y_plot]));
     tft_string.trim();
     tft.add_text(96 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
 
     constexpr uint8_t w = (TFT_WIDTH) / 10;
     tft.canvas(GRID_OFFSET_X + (GRID_WIDTH - w) / 2, GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET - 1, w, 32);
     tft.set_background(COLOR_BACKGROUND);
     tft_string.set(ui8tostr3rj(x_plot));
     tft_string.trim();
     tft.add_text(tft_string.center(w), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
 

commit 24a095c5c14b60bcbffc2807d2c8cc8e9af46e90
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Apr 12 16:49:53 2021 -0500

    Reduce math library code size by 3.4KB (#21575)

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index 5563d3069b..8429907f96 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -485,21 +485,21 @@ void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const
     tft_string.set(Y_LBL);
     tft.add_text(0, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
     tft_string.set(ftostr52(lpos.y));
     tft_string.trim();
     tft.add_text(96 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
 
     tft.canvas(216, GRID_OFFSET_Y + (GRID_HEIGHT - 32) / 2 + 32, 96, 32);
     tft.set_background(COLOR_BACKGROUND);
     tft_string.set(Z_LBL);
     tft.add_text(0, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
-    tft_string.set(isnan(ubl.z_values[x_plot][y_plot]) ? "-----" : ftostr43sign(ubl.z_values[x_plot][y_plot]));
+    tft_string.set(ISNAN(ubl.z_values[x_plot][y_plot]) ? "-----" : ftostr43sign(ubl.z_values[x_plot][y_plot]));
     tft_string.trim();
     tft.add_text(96 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
 
     constexpr uint8_t w = (TFT_WIDTH) / 10;
     tft.canvas(GRID_OFFSET_X + (GRID_WIDTH - w) / 2, GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET - 1, w, 32);
     tft.set_background(COLOR_BACKGROUND);
     tft_string.set(ui8tostr3rj(x_plot));
     tft_string.trim();
     tft.add_text(tft_string.center(w), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
 

commit 45c1432946547cef4cbe9ac832394ff68526687d
Author: Marcio T <mlt4356-github@yahoo.com>
Date:   Thu Apr 1 18:12:00 2021 -0600

    G26 Hilbert Curve followup (#21480)

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index 793ee60847..5563d3069b 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -455,26 +455,26 @@ void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const
   #define GRID_WIDTH      144
   #define GRID_HEIGHT     144
   #define CONTROL_OFFSET  8
 
   void MarlinUI::ubl_plot(const uint8_t x_plot, const uint8_t y_plot) {
 
     tft.canvas(GRID_OFFSET_X, GRID_OFFSET_Y, GRID_WIDTH, GRID_HEIGHT);
     tft.set_background(COLOR_BACKGROUND);
     tft.add_rectangle(0, 0, GRID_WIDTH, GRID_HEIGHT, COLOR_WHITE);
 
-    for (uint16_t x = 0; x < GRID_MAX_POINTS_X ; x++)
-      for (uint16_t y = 0; y < GRID_MAX_POINTS_Y ; y++)
+    for (uint16_t x = 0; x < (GRID_MAX_POINTS_X); x++)
+      for (uint16_t y = 0; y < (GRID_MAX_POINTS_Y); y++)
         if (position_is_reachable({ ubl.mesh_index_to_xpos(x), ubl.mesh_index_to_ypos(y) }))
-          tft.add_bar(1 + (x * 2 + 1) * (GRID_WIDTH - 4) / GRID_MAX_POINTS_X / 2, GRID_HEIGHT - 3 - ((y * 2 + 1) * (GRID_HEIGHT - 4) / GRID_MAX_POINTS_Y / 2), 2, 2, COLOR_UBL);
+          tft.add_bar(1 + (x * 2 + 1) * (GRID_WIDTH - 4) / (GRID_MAX_POINTS_X) / 2, GRID_HEIGHT - 3 - ((y * 2 + 1) * (GRID_HEIGHT - 4) / (GRID_MAX_POINTS_Y) / 2), 2, 2, COLOR_UBL);
 
-    tft.add_rectangle((x_plot * 2 + 1) * (GRID_WIDTH - 4) / GRID_MAX_POINTS_X / 2 - 1, GRID_HEIGHT - 5 - ((y_plot * 2 + 1) * (GRID_HEIGHT - 4) / GRID_MAX_POINTS_Y / 2), 6, 6, COLOR_UBL);
+    tft.add_rectangle((x_plot * 2 + 1) * (GRID_WIDTH - 4) / (GRID_MAX_POINTS_X) / 2 - 1, GRID_HEIGHT - 5 - ((y_plot * 2 + 1) * (GRID_HEIGHT - 4) / (GRID_MAX_POINTS_Y) / 2), 6, 6, COLOR_UBL);
 
     const xy_pos_t pos = { ubl.mesh_index_to_xpos(x_plot), ubl.mesh_index_to_ypos(y_plot) },
                    lpos = pos.asLogical();
 
     tft.canvas(216, GRID_OFFSET_Y + (GRID_HEIGHT - 32) / 2 - 32, 96, 32);
     tft.set_background(COLOR_BACKGROUND);
     tft_string.set(X_LBL);
     tft.add_text(0, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
     tft_string.set(ftostr52(lpos.x));
     tft_string.trim();
@@ -505,23 +505,23 @@ void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const
 
     tft.canvas(GRID_OFFSET_X + GRID_WIDTH + CONTROL_OFFSET, GRID_OFFSET_Y + (GRID_HEIGHT - 27) / 2, w, 32);
     tft.set_background(COLOR_BACKGROUND);
     tft_string.set(ui8tostr3rj(y_plot));
     tft_string.trim();
     tft.add_text(tft_string.center(w), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
 
     #if ENABLED(TOUCH_SCREEN)
       touch.clear();
       draw_menu_navigation = false;
-      add_control(GRID_OFFSET_X + GRID_WIDTH + CONTROL_OFFSET,      GRID_OFFSET_Y + CONTROL_OFFSET,                    UBL,   ENCODER_STEPS_PER_MENU_ITEM * GRID_MAX_POINTS_X, imgUp);
-      add_control(GRID_OFFSET_X + GRID_WIDTH + CONTROL_OFFSET,      GRID_OFFSET_Y + GRID_HEIGHT - CONTROL_OFFSET - 32, UBL, - ENCODER_STEPS_PER_MENU_ITEM * GRID_MAX_POINTS_X, imgDown);
-      add_control(GRID_OFFSET_X + CONTROL_OFFSET,                   GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET,      UBL, - ENCODER_STEPS_PER_MENU_ITEM, imgLeft);
+      add_control(GRID_OFFSET_X + GRID_WIDTH + CONTROL_OFFSET,      GRID_OFFSET_Y + CONTROL_OFFSET,                    UBL,  (ENCODER_STEPS_PER_MENU_ITEM) * (GRID_MAX_POINTS_X), imgUp);
+      add_control(GRID_OFFSET_X + GRID_WIDTH + CONTROL_OFFSET,      GRID_OFFSET_Y + GRID_HEIGHT - CONTROL_OFFSET - 32, UBL, -(ENCODER_STEPS_PER_MENU_ITEM) * (GRID_MAX_POINTS_X), imgDown);
+      add_control(GRID_OFFSET_X + CONTROL_OFFSET,                   GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET,      UBL, -(ENCODER_STEPS_PER_MENU_ITEM), imgLeft);
       add_control(GRID_OFFSET_X + GRID_WIDTH - CONTROL_OFFSET - 32, GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET,      UBL,   ENCODER_STEPS_PER_MENU_ITEM, imgRight);
       add_control(224, GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET, CLICK, imgLeveling);
       add_control(144, 206, BACK, imgBack);
     #endif
   }
 #endif // AUTO_BED_LEVELING_UBL
 
 void MarlinUI::move_axis_screen() {
 }
 

commit 3b73b115ca9366f0155986b717d4c85c31ed2f80
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 29 20:36:37 2021 -0500

    Apply pointer formatting

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index 37a44f51b4..793ee60847 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -319,21 +319,21 @@ void MarlinUI::draw_status_screen() {
   tft_string.trim();
   tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_STATUS_MESSAGE, tft_string);
 
   #if ENABLED(TOUCH_SCREEN)
     add_control(256, 130, menu_main, imgSettings);
     TERN_(SDSUPPORT, add_control(0, 130, menu_media, imgSD, !printingIsActive(), COLOR_CONTROL_ENABLED, card.isMounted() && printingIsActive() ? COLOR_BUSY : COLOR_CONTROL_DISABLED));
   #endif
 }
 
 // Low-level draw_edit_screen can be used to draw an edit screen from anyplace
-void MenuEditItemBase::draw_edit_screen(PGM_P const pstr, const char* const value/*=nullptr*/) {
+void MenuEditItemBase::draw_edit_screen(PGM_P const pstr, const char * const value/*=nullptr*/) {
   ui.encoder_direction_normal();
   TERN_(TOUCH_SCREEN, touch.clear());
 
   uint16_t line = 1;
 
   menu_line(line++);
   tft_string.set(pstr, itemIndex, itemString);
   tft_string.trim();
   tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
 

commit e5ff55a1be7646b6159e6dedac50bfbe57e6dfa0
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 24 04:11:43 2021 -0500

    Add typedef celsius_t (#21374)

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index fb82188645..37a44f51b4 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -107,21 +107,21 @@ void MarlinUI::draw_kill_screen() {
   tft_string.set(GET_TEXT(MSG_PLEASE_RESET));
   tft_string.trim();
   tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_KILL_SCREEN_TEXT, tft_string);
 
   tft.queue.sync();
 }
 
 void draw_heater_status(uint16_t x, uint16_t y, const int8_t Heater) {
   MarlinImage image = imgHotEnd;
   uint16_t Color;
-  float currentTemperature, targetTemperature;
+  celsius_t currentTemperature, targetTemperature;
 
   if (Heater >= 0) { // HotEnd
     currentTemperature = thermalManager.degHotend(Heater);
     targetTemperature = thermalManager.degTargetHotend(Heater);
   }
   #if HAS_HEATED_BED
     else if (Heater == H_BED) {
       currentTemperature = thermalManager.degBed();
       targetTemperature = thermalManager.degTargetBed();
     }
@@ -168,27 +168,27 @@ void draw_heater_status(uint16_t x, uint16_t y, const int8_t Heater) {
   #if HAS_TEMP_COOLER
     else if (Heater == H_COOLER) {
       if (currentTemperature <= 26) Color = COLOR_COLD;
       if (currentTemperature > 26) Color = COLOR_RED;
       image = targetTemperature > 26 ? imgCoolerHot : imgCooler;
     }
   #endif
 
   tft.add_image(0, 18, image, Color);
 
-  tft_string.set((uint8_t *)i16tostr3rj(currentTemperature + 0.5));
+  tft_string.set((uint8_t *)i16tostr3rj(currentTemperature));
   tft_string.add(LCD_STR_DEGREE);
   tft_string.trim();
   tft.add_text(tft_string.center(64) + 2, 72, Color, tft_string);
 
   if (targetTemperature >= 0) {
-    tft_string.set((uint8_t *)i16tostr3rj(targetTemperature + 0.5));
+    tft_string.set((uint8_t *)i16tostr3rj(targetTemperature));
     tft_string.add(LCD_STR_DEGREE);
     tft_string.trim();
     tft.add_text(tft_string.center(64) + 2, 8, Color, tft_string);
   }
 }
 
 void draw_fan_status(uint16_t x, uint16_t y, const bool blink) {
   TERN_(TOUCH_SCREEN, touch.add_control(FAN, x, y, 64, 100));
   tft.canvas(x, y, 64, 100);
   tft.set_background(COLOR_BACKGROUND);

commit b95e548ddbcbc1c088eabc17992d0a06f82ac167
Author: Mike La Spina <mike.laspina@shaw.ca>
Date:   Sat Mar 6 14:13:28 2021 -0600

    Cooler (for Laser) - M143, M193 (#21255)

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index eadd09ef27..fb82188645 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -129,20 +129,26 @@ void draw_heater_status(uint16_t x, uint16_t y, const int8_t Heater) {
   #if HAS_TEMP_CHAMBER
     else if (Heater == H_CHAMBER) {
       currentTemperature = thermalManager.degChamber();
       #if HAS_HEATED_CHAMBER
         targetTemperature = thermalManager.degTargetChamber();
       #else
         targetTemperature = ABSOLUTE_ZERO;
       #endif
     }
   #endif
+  #if HAS_TEMP_COOLER
+    else if (Heater == H_COOLER) {
+      currentTemperature = thermalManager.degCooler();
+      targetTemperature = TERN(HAS_COOLER, thermalManager.degTargetCooler(), ABSOLUTE_ZERO);
+    }
+  #endif
   else return;
 
   TERN_(TOUCH_SCREEN, if (targetTemperature >= 0) touch.add_control(HEATER, x, y, 64, 100, Heater));
   tft.canvas(x, y, 64, 100);
   tft.set_background(COLOR_BACKGROUND);
 
   Color = currentTemperature < 0 ? COLOR_INACTIVE : COLOR_COLD;
 
   if (Heater >= 0) { // HotEnd
     if (currentTemperature >= 50) Color = COLOR_HOTEND;
@@ -152,20 +158,27 @@ void draw_heater_status(uint16_t x, uint16_t y, const int8_t Heater) {
       if (currentTemperature >= 50) Color = COLOR_HEATED_BED;
       image = targetTemperature > 0 ? imgBedHeated : imgBed;
     }
   #endif
   #if HAS_TEMP_CHAMBER
     else if (Heater == H_CHAMBER) {
       if (currentTemperature >= 50) Color = COLOR_CHAMBER;
       image = targetTemperature > 0 ? imgChamberHeated : imgChamber;
     }
   #endif
+  #if HAS_TEMP_COOLER
+    else if (Heater == H_COOLER) {
+      if (currentTemperature <= 26) Color = COLOR_COLD;
+      if (currentTemperature > 26) Color = COLOR_RED;
+      image = targetTemperature > 26 ? imgCoolerHot : imgCooler;
+    }
+  #endif
 
   tft.add_image(0, 18, image, Color);
 
   tft_string.set((uint8_t *)i16tostr3rj(currentTemperature + 0.5));
   tft_string.add(LCD_STR_DEGREE);
   tft_string.trim();
   tft.add_text(tft_string.center(64) + 2, 72, Color, tft_string);
 
   if (targetTemperature >= 0) {
     tft_string.set((uint8_t *)i16tostr3rj(targetTemperature + 0.5));

commit c12be1f98cf1efdc6fc1e66c528d5975adc6626c
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Mon Jan 25 08:44:39 2021 +0100

    Graphical TFT fixes, cleanup (#20861)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index aea0039698..eadd09ef27 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -17,96 +17,68 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 #include "../../inc/MarlinConfigPre.h"
 
 #if HAS_UI_320x240
 
-#include "ui_320x240.h"
+#include "ui_common.h"
 
 #include "../marlinui.h"
 #include "../menu/menu.h"
 #include "../../libs/numtostr.h"
 
 #include "../../sd/cardreader.h"
 #include "../../module/temperature.h"
 #include "../../module/printcounter.h"
 #include "../../module/planner.h"
 #include "../../module/motion.h"
 
 #if DISABLED(LCD_PROGRESS_BAR) && BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
   #include "../../feature/filwidth.h"
   #include "../../gcode/parser.h"
 #endif
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
   #include "../../feature/bedlevel/bedlevel.h"
 #endif
 
-#if !HAS_LCD_MENU
-  #error "Seriously? High resolution TFT screen without menu?"
-#endif
-
-static bool draw_menu_navigation = false;
-
 void MarlinUI::tft_idle() {
   #if ENABLED(TOUCH_SCREEN)
     if (draw_menu_navigation) {
       add_control(48, 206, PAGE_UP, imgPageUp, encoderTopLine > 0);
       add_control(240, 206, PAGE_DOWN, imgPageDown, encoderTopLine + LCD_HEIGHT < screen_items);
       add_control(144, 206, BACK, imgBack);
       draw_menu_navigation = false;
     }
   #endif
 
   tft.queue.async();
   TERN_(TOUCH_SCREEN, touch.idle());
 }
 
-void MarlinUI::init_lcd() {
-  tft.init();
-  tft.set_font(MENU_FONT_NAME);
-  #ifdef SYMBOLS_FONT_NAME
-    tft.add_glyphs(SYMBOLS_FONT_NAME);
-  #endif
-  TERN_(TOUCH_SCREEN, touch.init());
-  clear_lcd();
-}
-
-bool MarlinUI::detected() { return true; }
-
-void MarlinUI::clear_lcd() {
-  #if ENABLED(TOUCH_SCREEN)
-    touch.reset();
-    draw_menu_navigation = false;
-  #endif
-
-  tft.queue.reset();
-  tft.fill(0, 0, TFT_WIDTH, TFT_HEIGHT, COLOR_BACKGROUND);
-}
-
 #if ENABLED(SHOW_BOOTSCREEN)
   void MarlinUI::show_bootscreen() {
     tft.queue.reset();
 
     tft.canvas(0, 0, TFT_WIDTH, TFT_HEIGHT);
     #if ENABLED(BOOT_MARLIN_LOGO_SMALL)
       #define BOOT_LOGO_W 195   // MarlinLogo195x59x16
       #define BOOT_LOGO_H  59
       #define SITE_URL_Y (TFT_HEIGHT - 46)
       tft.set_background(COLOR_BACKGROUND);
     #else
-      #define BOOT_LOGO_W 320   // MarlinLogo320x240x16
-      #define BOOT_LOGO_H 240
+      #define BOOT_LOGO_W TFT_WIDTH   // MarlinLogo320x240x16
+      #define BOOT_LOGO_H TFT_HEIGHT
       #define SITE_URL_Y (TFT_HEIGHT - 52)
     #endif
     tft.add_image((TFT_WIDTH - BOOT_LOGO_W) / 2, (TFT_HEIGHT - BOOT_LOGO_H) / 2, imgBootScreen);
     #ifdef WEBSITE_URL
       tft_string.set(WEBSITE_URL);
       tft.add_text(tft_string.center(TFT_WIDTH), SITE_URL_Y, COLOR_WEBSITE_URL, tft_string);
     #endif
 
     tft.queue.sync();
     safe_delay(BOOTSCREEN_TIMEOUT);
@@ -141,73 +113,72 @@ void MarlinUI::draw_kill_screen() {
 
 void draw_heater_status(uint16_t x, uint16_t y, const int8_t Heater) {
   MarlinImage image = imgHotEnd;
   uint16_t Color;
   float currentTemperature, targetTemperature;
 
   if (Heater >= 0) { // HotEnd
     currentTemperature = thermalManager.degHotend(Heater);
     targetTemperature = thermalManager.degTargetHotend(Heater);
   }
-#if HAS_HEATED_BED
-  else if (Heater == H_BED) {
-    currentTemperature = thermalManager.degBed();
-    targetTemperature = thermalManager.degTargetBed();
-  }
-#endif // HAS_HEATED_BED
-#if HAS_TEMP_CHAMBER
-  else if (Heater == H_CHAMBER) {
-    currentTemperature = thermalManager.degChamber();
-    #if HAS_HEATED_CHAMBER
-      targetTemperature = thermalManager.degTargetChamber();
-    #else
-      targetTemperature = ABSOLUTE_ZERO;
-    #endif
-  }
-#endif // HAS_TEMP_CHAMBER
+  #if HAS_HEATED_BED
+    else if (Heater == H_BED) {
+      currentTemperature = thermalManager.degBed();
+      targetTemperature = thermalManager.degTargetBed();
+    }
+  #endif
+  #if HAS_TEMP_CHAMBER
+    else if (Heater == H_CHAMBER) {
+      currentTemperature = thermalManager.degChamber();
+      #if HAS_HEATED_CHAMBER
+        targetTemperature = thermalManager.degTargetChamber();
+      #else
+        targetTemperature = ABSOLUTE_ZERO;
+      #endif
+    }
+  #endif
   else return;
 
   TERN_(TOUCH_SCREEN, if (targetTemperature >= 0) touch.add_control(HEATER, x, y, 64, 100, Heater));
   tft.canvas(x, y, 64, 100);
   tft.set_background(COLOR_BACKGROUND);
 
   Color = currentTemperature < 0 ? COLOR_INACTIVE : COLOR_COLD;
 
   if (Heater >= 0) { // HotEnd
     if (currentTemperature >= 50) Color = COLOR_HOTEND;
   }
   #if HAS_HEATED_BED
-  else if (Heater == H_BED) {
-    if (currentTemperature >= 50) Color = COLOR_HEATED_BED;
-    image = targetTemperature > 0 ? imgBedHeated : imgBed;
-  }
-  #endif // HAS_HEATED_BED
+    else if (Heater == H_BED) {
+      if (currentTemperature >= 50) Color = COLOR_HEATED_BED;
+      image = targetTemperature > 0 ? imgBedHeated : imgBed;
+    }
+  #endif
   #if HAS_TEMP_CHAMBER
-  else if (Heater == H_CHAMBER) {
-    if (currentTemperature >= 50) Color = COLOR_CHAMBER;
-    image = targetTemperature > 0 ? imgChamberHeated : imgChamber;
-  }
-  #endif // HAS_TEMP_CHAMBER
+    else if (Heater == H_CHAMBER) {
+      if (currentTemperature >= 50) Color = COLOR_CHAMBER;
+      image = targetTemperature > 0 ? imgChamberHeated : imgChamber;
+    }
+  #endif
 
   tft.add_image(0, 18, image, Color);
 
   tft_string.set((uint8_t *)i16tostr3rj(currentTemperature + 0.5));
   tft_string.add(LCD_STR_DEGREE);
   tft_string.trim();
   tft.add_text(tft_string.center(64) + 2, 72, Color, tft_string);
 
   if (targetTemperature >= 0) {
     tft_string.set((uint8_t *)i16tostr3rj(targetTemperature + 0.5));
     tft_string.add(LCD_STR_DEGREE);
     tft_string.trim();
     tft.add_text(tft_string.center(64) + 2, 8, Color, tft_string);
-
   }
 }
 
 void draw_fan_status(uint16_t x, uint16_t y, const bool blink) {
   TERN_(TOUCH_SCREEN, touch.add_control(FAN, x, y, 64, 100));
   tft.canvas(x, y, 64, 100);
   tft.set_background(COLOR_BACKGROUND);
 
   uint8_t fanSpeed = thermalManager.fan_speed[0];
   MarlinImage image;
@@ -225,21 +196,21 @@ void draw_fan_status(uint16_t x, uint16_t y, const bool blink) {
   tft_string.trim();
   tft.add_text(tft_string.center(64) + 6, 72, COLOR_FAN, tft_string);
 }
 
 void MarlinUI::draw_status_screen() {
   const bool blink = get_blink();
 
   TERN_(TOUCH_SCREEN, touch.clear());
 
   // heaters and fan
-  uint16_t i, x, y = POS_Y;
+  uint16_t i, x, y = TFT_STATUS_TOP_Y;
 
   for (i = 0 ; i < ITEMS_COUNT; i++) {
     x = (320 / ITEMS_COUNT - 64) / 2  + (320 * i / ITEMS_COUNT);
     switch (i) {
       #ifdef ITEM_E0
         case ITEM_E0: draw_heater_status(x, y, H_E0); break;
       #endif
       #ifdef ITEM_E1
         case ITEM_E1: draw_heater_status(x, y, H_E1); break;
       #endif
@@ -334,63 +305,20 @@ void MarlinUI::draw_status_screen() {
   tft_string.set(status_message);
   tft_string.trim();
   tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_STATUS_MESSAGE, tft_string);
 
   #if ENABLED(TOUCH_SCREEN)
     add_control(256, 130, menu_main, imgSettings);
     TERN_(SDSUPPORT, add_control(0, 130, menu_media, imgSD, !printingIsActive(), COLOR_CONTROL_ENABLED, card.isMounted() && printingIsActive() ? COLOR_BUSY : COLOR_CONTROL_DISABLED));
   #endif
 }
 
-// Draw a static item with no left-right margin required. Centered by default.
-void MenuItem_static::draw(const uint8_t row, PGM_P const pstr, const uint8_t style/*=SS_DEFAULT*/, const char * const vstr/*=nullptr*/) {
-  menu_item(row);
-  tft_string.set(pstr, itemIndex, itemString);
-  if (vstr)
-    tft_string.add(vstr);
-  tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_YELLOW, tft_string);
-}
-
-// Draw a generic menu item with pre_char (if selected) and post_char
-void MenuItemBase::_draw(const bool sel, const uint8_t row, PGM_P const pstr, const char pre_char, const char post_char) {
-  menu_item(row, sel);
-
-  uint8_t *string = (uint8_t *)pstr;
-  MarlinImage image = noImage;
-  switch (*string) {
-    case 0x01: image = imgRefresh; break;  // LCD_STR_REFRESH
-    case 0x02: image = imgDirectory; break;  // LCD_STR_FOLDER
-  }
-
-  uint8_t offset = MENU_TEXT_X_OFFSET;
-  if (image != noImage) {
-    string++;
-    offset = 32;
-    tft.add_image(0, 0, image, COLOR_MENU_TEXT, sel ? COLOR_SELECTION_BG : COLOR_BACKGROUND);
-  }
-
-  tft_string.set(string, itemIndex, itemString);
-  tft.add_text(offset, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
-}
-
-// Draw a menu item with a (potentially) editable value
-void MenuEditItemBase::draw(const bool sel, const uint8_t row, PGM_P const pstr, const char* const data, const bool pgm) {
-  menu_item(row, sel);
-
-  tft_string.set(pstr, itemIndex, itemString);
-  tft.add_text(MENU_TEXT_X_OFFSET, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
-  if (data) {
-    tft_string.set(data);
-    tft.add_text(TFT_WIDTH - MENU_TEXT_X_OFFSET - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
-  }
-}
-
 // Low-level draw_edit_screen can be used to draw an edit screen from anyplace
 void MenuEditItemBase::draw_edit_screen(PGM_P const pstr, const char* const value/*=nullptr*/) {
   ui.encoder_direction_normal();
   TERN_(TOUCH_SCREEN, touch.clear());
 
   uint16_t line = 1;
 
   menu_line(line++);
   tft_string.set(pstr, itemIndex, itemString);
   tft_string.trim();
@@ -476,50 +404,43 @@ void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const
     tft_string.set(suff);
     tft_string.trim();
     tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
   }
   #if ENABLED(TOUCH_SCREEN)
     add_control(48, 176, CANCEL, imgCancel, true, yesno ? HALF(COLOR_CONTROL_CANCEL) : COLOR_CONTROL_CANCEL);
     add_control(208, 176, CONFIRM, imgConfirm, true, yesno ? COLOR_CONTROL_CONFIRM : HALF(COLOR_CONTROL_CONFIRM));
   #endif
 }
 
-#if ENABLED(SDSUPPORT)
-  void MenuItem_sdbase::draw(const bool sel, const uint8_t row, PGM_P const, CardReader &theCard, const bool isDir) {
-    menu_item(row, sel);
-    if (isDir)
-      tft.add_image(0, 0, imgDirectory, COLOR_MENU_TEXT, sel ? COLOR_SELECTION_BG : COLOR_BACKGROUND);
-    tft.add_text(32, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, theCard.longest_filename());
-  }
-#endif
-
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
+
   void MarlinUI::draw_hotend_status(const uint8_t row, const uint8_t extruder) {
     #if ENABLED(TOUCH_SCREEN)
       touch.clear();
       draw_menu_navigation = false;
       touch.add_control(RESUME_CONTINUE , 0, 0, 320, 240);
     #endif
 
     menu_line(row);
     tft_string.set(GET_TEXT(MSG_FILAMENT_CHANGE_NOZZLE));
     tft_string.add('E');
     tft_string.add((char)('1' + extruder));
     tft_string.add(' ');
     tft_string.add(i16tostr3rj(thermalManager.degHotend(extruder)));
     tft_string.add(LCD_STR_DEGREE);
     tft_string.add(" / ");
     tft_string.add(i16tostr3rj(thermalManager.degTargetHotend(extruder)));
     tft_string.add(LCD_STR_DEGREE);
     tft_string.trim();
     tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
   }
+
 #endif // ADVANCED_PAUSE_FEATURE
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
   #define GRID_OFFSET_X   8
   #define GRID_OFFSET_Y   8
   #define GRID_WIDTH      144
   #define GRID_HEIGHT     144
   #define CONTROL_OFFSET  8
 
   void MarlinUI::ubl_plot(const uint8_t x_plot, const uint8_t y_plot) {
@@ -555,138 +476,40 @@ void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const
     tft.add_text(96 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
 
     tft.canvas(216, GRID_OFFSET_Y + (GRID_HEIGHT - 32) / 2 + 32, 96, 32);
     tft.set_background(COLOR_BACKGROUND);
     tft_string.set(Z_LBL);
     tft.add_text(0, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
     tft_string.set(isnan(ubl.z_values[x_plot][y_plot]) ? "-----" : ftostr43sign(ubl.z_values[x_plot][y_plot]));
     tft_string.trim();
     tft.add_text(96 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
 
-
-    tft.canvas(GRID_OFFSET_X + (GRID_WIDTH - 32) / 2, GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET - 1, 32, 32);
+    constexpr uint8_t w = (TFT_WIDTH) / 10;
+    tft.canvas(GRID_OFFSET_X + (GRID_WIDTH - w) / 2, GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET - 1, w, 32);
     tft.set_background(COLOR_BACKGROUND);
     tft_string.set(ui8tostr3rj(x_plot));
     tft_string.trim();
-    tft.add_text(tft_string.center(32), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
+    tft.add_text(tft_string.center(w), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
 
-    tft.canvas(GRID_OFFSET_X + GRID_WIDTH + CONTROL_OFFSET, GRID_OFFSET_Y + (GRID_HEIGHT - 27) / 2, 32, 32);
+    tft.canvas(GRID_OFFSET_X + GRID_WIDTH + CONTROL_OFFSET, GRID_OFFSET_Y + (GRID_HEIGHT - 27) / 2, w, 32);
     tft.set_background(COLOR_BACKGROUND);
     tft_string.set(ui8tostr3rj(y_plot));
     tft_string.trim();
-    tft.add_text(tft_string.center(32), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
+    tft.add_text(tft_string.center(w), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
 
     #if ENABLED(TOUCH_SCREEN)
       touch.clear();
       draw_menu_navigation = false;
       add_control(GRID_OFFSET_X + GRID_WIDTH + CONTROL_OFFSET,      GRID_OFFSET_Y + CONTROL_OFFSET,                    UBL,   ENCODER_STEPS_PER_MENU_ITEM * GRID_MAX_POINTS_X, imgUp);
       add_control(GRID_OFFSET_X + GRID_WIDTH + CONTROL_OFFSET,      GRID_OFFSET_Y + GRID_HEIGHT - CONTROL_OFFSET - 32, UBL, - ENCODER_STEPS_PER_MENU_ITEM * GRID_MAX_POINTS_X, imgDown);
       add_control(GRID_OFFSET_X + CONTROL_OFFSET,                   GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET,      UBL, - ENCODER_STEPS_PER_MENU_ITEM, imgLeft);
       add_control(GRID_OFFSET_X + GRID_WIDTH - CONTROL_OFFSET - 32, GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET,      UBL,   ENCODER_STEPS_PER_MENU_ITEM, imgRight);
       add_control(224, GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET, CLICK, imgLeveling);
       add_control(144, 206, BACK, imgBack);
     #endif
   }
 #endif // AUTO_BED_LEVELING_UBL
 
-#if ENABLED(TOUCH_SCREEN_CALIBRATION)
-  void MarlinUI::touch_calibration_screen() {
-    uint16_t x, y;
-
-    calibrationState calibration_stage = touch_calibration.get_calibration_state();
-
-    if (calibration_stage == CALIBRATION_NONE) {
-      defer_status_screen(true);
-      clear_lcd();
-      calibration_stage = touch_calibration.calibration_start();
-    }
-    else {
-      x = touch_calibration.calibration_points[_MIN(calibration_stage - 1, CALIBRATION_BOTTOM_RIGHT)].x;
-      y = touch_calibration.calibration_points[_MIN(calibration_stage - 1, CALIBRATION_BOTTOM_RIGHT)].y;
-      tft.canvas(x - 15, y - 15, 31, 31);
-      tft.set_background(COLOR_BACKGROUND);
-    }
-
-    touch.clear();
-
-    if (calibration_stage < CALIBRATION_SUCCESS) {
-      switch (calibration_stage) {
-        case CALIBRATION_TOP_LEFT: tft_string.set(GET_TEXT(MSG_TOP_LEFT)); break;
-        case CALIBRATION_BOTTOM_LEFT: tft_string.set(GET_TEXT(MSG_BOTTOM_LEFT)); break;
-        case CALIBRATION_TOP_RIGHT: tft_string.set(GET_TEXT(MSG_TOP_RIGHT)); break;
-        case CALIBRATION_BOTTOM_RIGHT: tft_string.set(GET_TEXT(MSG_BOTTOM_RIGHT)); break;
-        default: break;
-      }
-
-      x = touch_calibration.calibration_points[calibration_stage].x;
-      y = touch_calibration.calibration_points[calibration_stage].y;
-
-      tft.canvas(x - 15, y - 15, 31, 31);
-      tft.set_background(COLOR_BACKGROUND);
-      tft.add_bar(0, 15, 31, 1, COLOR_TOUCH_CALIBRATION);
-      tft.add_bar(15, 0, 1, 31, COLOR_TOUCH_CALIBRATION);
-
-      touch.add_control(CALIBRATE, 0, 0, TFT_WIDTH, TFT_HEIGHT, uint32_t(x) << 16 | uint32_t(y));
-    }
-    else {
-      tft_string.set(calibration_stage == CALIBRATION_SUCCESS ? GET_TEXT(MSG_CALIBRATION_COMPLETED) : GET_TEXT(MSG_CALIBRATION_FAILED));
-      defer_status_screen(false);
-      touch_calibration.calibration_end();
-      touch.add_control(BACK, 0, 0, TFT_WIDTH, TFT_HEIGHT);
-    }
-
-    tft.canvas(0, (TFT_HEIGHT - tft_string.font_height()) >> 1, TFT_WIDTH, tft_string.font_height());
-    tft.set_background(COLOR_BACKGROUND);
-    tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_MENU_TEXT, tft_string);
-  }
-#endif // TOUCH_SCREEN_CALIBRATION
-
-void menu_line(const uint8_t row, uint16_t color) {
-  tft.canvas(0, 2 + 34 * row, TFT_WIDTH, 32);
-  tft.set_background(color);
-}
-
-void menu_pause_option();
-
-void menu_item(const uint8_t row, bool sel ) {
-  #if ENABLED(TOUCH_SCREEN)
-    if (row == 0) {
-      touch.clear();
-      draw_menu_navigation = TERN(ADVANCED_PAUSE_FEATURE, ui.currentScreen != menu_pause_option, true);
-    }
-  #endif
-
-  menu_line(row, sel ? COLOR_SELECTION_BG : COLOR_BACKGROUND);
-  #if ENABLED(TOUCH_SCREEN)
-    const TouchControlType tct = TERN(SINGLE_TOUCH_NAVIGATION, true, sel) ? MENU_CLICK : MENU_ITEM;
-    touch.add_control(tct, 0, 2 + 34 * row, TFT_WIDTH, 32, encoderTopLine + row);
-  #endif
-}
-
-void lcd_moveto(const lcd_uint_t col, const lcd_uint_t row) {
-  #define TFT_COL_WIDTH ((TFT_WIDTH) / (LCD_WIDTH))
-  tft.canvas(col * TFT_COL_WIDTH, 4 + 45 * row, TFT_WIDTH - (col * TFT_COL_WIDTH), 43);
-  tft.set_background(COLOR_BACKGROUND);
-}
-
-int lcd_put_wchar_max(wchar_t c, pixel_len_t max_length) {
-  tft_string.set();
-  tft_string.add(c);
-  tft.add_text(MENU_TEXT_X_OFFSET, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
-  return tft_string.width();
-}
-
-int lcd_put_u8str_max_P(PGM_P utf8_str_P, pixel_len_t max_length) {
-  tft_string.set(utf8_str_P);
-  tft_string.trim();
-  tft.add_text(MENU_TEXT_X_OFFSET, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
-  return tft_string.width();
-}
-
-int lcd_put_u8str_max(const char * utf8_str, pixel_len_t max_length) {
-  return lcd_put_u8str_max_P(utf8_str, max_length);
-}
-
 void MarlinUI::move_axis_screen() {
 }
 
 #endif // HAS_UI_320x240

commit 0f612d5021eaef366cee80d4068d8a8f6a081b1b
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Sat Jan 23 06:23:35 2021 +0100

    lcd_put_wchar_max for COLOR_UI (#20838)
    
    Co-Authored-By: Victor Oliveira <github@victormo.com.br>

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index 4c09d9803e..aea0039698 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -661,20 +661,27 @@ void menu_item(const uint8_t row, bool sel ) {
     touch.add_control(tct, 0, 2 + 34 * row, TFT_WIDTH, 32, encoderTopLine + row);
   #endif
 }
 
 void lcd_moveto(const lcd_uint_t col, const lcd_uint_t row) {
   #define TFT_COL_WIDTH ((TFT_WIDTH) / (LCD_WIDTH))
   tft.canvas(col * TFT_COL_WIDTH, 4 + 45 * row, TFT_WIDTH - (col * TFT_COL_WIDTH), 43);
   tft.set_background(COLOR_BACKGROUND);
 }
 
+int lcd_put_wchar_max(wchar_t c, pixel_len_t max_length) {
+  tft_string.set();
+  tft_string.add(c);
+  tft.add_text(MENU_TEXT_X_OFFSET, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
+  return tft_string.width();
+}
+
 int lcd_put_u8str_max_P(PGM_P utf8_str_P, pixel_len_t max_length) {
   tft_string.set(utf8_str_P);
   tft_string.trim();
   tft.add_text(MENU_TEXT_X_OFFSET, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
   return tft_string.width();
 }
 
 int lcd_put_u8str_max(const char * utf8_str, pixel_len_t max_length) {
   return lcd_put_u8str_max_P(utf8_str, max_length);
 }

commit 185e31d322bb699e171d4c6a6fc5d6f34b40cfd3
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Mon Dec 28 02:11:36 2020 -0300

    Fix Menu Mixer for Color UI (#20566)

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index 2cc586a48a..4c09d9803e 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -435,20 +435,24 @@ void MenuEditItemBase::draw_edit_screen(PGM_P const pstr, const char* const valu
     tft.add_bar(1, 6, position, 4, COLOR_SLIDER);
     tft.add_bar(position + 1, 6, SLIDER_LENGTH - 2 - position, 4, COLOR_SLIDER_INACTIVE);
     tft.add_bar(SLIDER_LENGTH - 1, 7, 1, 2, int32_t(ui.encoderPosition) == maxEditValue ? COLOR_SLIDER : COLOR_SLIDER_INACTIVE);
 
     #if ENABLED(TOUCH_SCREEN)
       tft.add_image((SLIDER_LENGTH - 8) * ui.encoderPosition / maxEditValue, 0, imgSlider, COLOR_SLIDER);
       touch.add_control(SLIDER, (TFT_WIDTH - SLIDER_LENGTH) / 2, SLIDER_Y_POSITION - 8, SLIDER_LENGTH, 32, maxEditValue);
     #endif
   }
 
+  tft.draw_edit_screen_buttons();
+}
+
+void TFT::draw_edit_screen_buttons() {
   #if ENABLED(TOUCH_SCREEN)
     add_control(32, 176, DECREASE, imgDecrease);
     add_control(224, 176, INCREASE, imgIncrease);
     add_control(128, 176, CLICK, imgConfirm);
   #endif
 }
 
 // The Select Screen presents a prompt and two "buttons"
 void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const bool yesno, PGM_P const pref, const char * const string/*=nullptr*/, PGM_P const suff/*=nullptr*/) {
   uint16_t line = 1;
@@ -651,14 +655,31 @@ void menu_item(const uint8_t row, bool sel ) {
     }
   #endif
 
   menu_line(row, sel ? COLOR_SELECTION_BG : COLOR_BACKGROUND);
   #if ENABLED(TOUCH_SCREEN)
     const TouchControlType tct = TERN(SINGLE_TOUCH_NAVIGATION, true, sel) ? MENU_CLICK : MENU_ITEM;
     touch.add_control(tct, 0, 2 + 34 * row, TFT_WIDTH, 32, encoderTopLine + row);
   #endif
 }
 
+void lcd_moveto(const lcd_uint_t col, const lcd_uint_t row) {
+  #define TFT_COL_WIDTH ((TFT_WIDTH) / (LCD_WIDTH))
+  tft.canvas(col * TFT_COL_WIDTH, 4 + 45 * row, TFT_WIDTH - (col * TFT_COL_WIDTH), 43);
+  tft.set_background(COLOR_BACKGROUND);
+}
+
+int lcd_put_u8str_max_P(PGM_P utf8_str_P, pixel_len_t max_length) {
+  tft_string.set(utf8_str_P);
+  tft_string.trim();
+  tft.add_text(MENU_TEXT_X_OFFSET, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
+  return tft_string.width();
+}
+
+int lcd_put_u8str_max(const char * utf8_str, pixel_len_t max_length) {
+  return lcd_put_u8str_max_P(utf8_str, max_length);
+}
+
 void MarlinUI::move_axis_screen() {
 }
 
 #endif // HAS_UI_320x240

commit cfcfc8047afb09bd3da8d3e7bb49f066a977e6d6
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Sun Dec 27 19:10:53 2020 -0800

    Small / Large Boot Screen option for TFT_COLOR_UI (#20578)

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index bcd1cb2ab9..2cc586a48a 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -85,24 +85,34 @@ void MarlinUI::clear_lcd() {
 
   tft.queue.reset();
   tft.fill(0, 0, TFT_WIDTH, TFT_HEIGHT, COLOR_BACKGROUND);
 }
 
 #if ENABLED(SHOW_BOOTSCREEN)
   void MarlinUI::show_bootscreen() {
     tft.queue.reset();
 
     tft.canvas(0, 0, TFT_WIDTH, TFT_HEIGHT);
-    tft.add_image(0, 0, imgBootScreen);  // MarlinLogo320x240x16
-
+    #if ENABLED(BOOT_MARLIN_LOGO_SMALL)
+      #define BOOT_LOGO_W 195   // MarlinLogo195x59x16
+      #define BOOT_LOGO_H  59
+      #define SITE_URL_Y (TFT_HEIGHT - 46)
+      tft.set_background(COLOR_BACKGROUND);
+    #else
+      #define BOOT_LOGO_W 320   // MarlinLogo320x240x16
+      #define BOOT_LOGO_H 240
+      #define SITE_URL_Y (TFT_HEIGHT - 52)
+    #endif
+    tft.add_image((TFT_WIDTH - BOOT_LOGO_W) / 2, (TFT_HEIGHT - BOOT_LOGO_H) / 2, imgBootScreen);
     #ifdef WEBSITE_URL
-      tft.add_text(4, 188, COLOR_WEBSITE_URL, WEBSITE_URL);
+      tft_string.set(WEBSITE_URL);
+      tft.add_text(tft_string.center(TFT_WIDTH), SITE_URL_Y, COLOR_WEBSITE_URL, tft_string);
     #endif
 
     tft.queue.sync();
     safe_delay(BOOTSCREEN_TIMEOUT);
     clear_lcd();
   }
 #endif
 
 void MarlinUI::draw_kill_screen() {
   tft.queue.reset();

commit a0c8d348a0baa179a13bc47be6edce4bb652dac9
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Tue Dec 22 04:51:29 2020 -0800

    Anet ET4 / ET4P and Anet TFT28 / TFT35 (#20280)

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index ceea4a428e..bcd1cb2ab9 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -407,35 +407,35 @@ void MenuEditItemBase::draw_edit_screen(PGM_P const pstr, const char* const valu
       tft.add_text(176, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
       tft_string.set(ftostr52(LOGICAL_X_POSITION(current_position.y)));
       tft_string.trim();
       tft.add_text(268 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
     }
   #endif
 
   extern screenFunc_t _manual_move_func_ptr;
   if (ui.currentScreen != _manual_move_func_ptr && !ui.external_control) {
 
-    #define SLIDER_LENGHT 224
+    #define SLIDER_LENGTH 224
     #define SLIDER_Y_POSITION 140
 
-    tft.canvas((TFT_WIDTH - SLIDER_LENGHT) / 2, SLIDER_Y_POSITION, SLIDER_LENGHT, 16);
+    tft.canvas((TFT_WIDTH - SLIDER_LENGTH) / 2, SLIDER_Y_POSITION, SLIDER_LENGTH, 16);
     tft.set_background(COLOR_BACKGROUND);
 
-    int16_t position = (SLIDER_LENGHT - 2) * ui.encoderPosition / maxEditValue;
+    int16_t position = (SLIDER_LENGTH - 2) * ui.encoderPosition / maxEditValue;
     tft.add_bar(0, 7, 1, 2, ui.encoderPosition == 0 ? COLOR_SLIDER_INACTIVE : COLOR_SLIDER);
     tft.add_bar(1, 6, position, 4, COLOR_SLIDER);
-    tft.add_bar(position + 1, 6, SLIDER_LENGHT - 2 - position, 4, COLOR_SLIDER_INACTIVE);
-    tft.add_bar(SLIDER_LENGHT - 1, 7, 1, 2, int32_t(ui.encoderPosition) == maxEditValue ? COLOR_SLIDER : COLOR_SLIDER_INACTIVE);
+    tft.add_bar(position + 1, 6, SLIDER_LENGTH - 2 - position, 4, COLOR_SLIDER_INACTIVE);
+    tft.add_bar(SLIDER_LENGTH - 1, 7, 1, 2, int32_t(ui.encoderPosition) == maxEditValue ? COLOR_SLIDER : COLOR_SLIDER_INACTIVE);
 
     #if ENABLED(TOUCH_SCREEN)
-      tft.add_image((SLIDER_LENGHT - 8) * ui.encoderPosition / maxEditValue, 0, imgSlider, COLOR_SLIDER);
-      touch.add_control(SLIDER, (TFT_WIDTH - SLIDER_LENGHT) / 2, SLIDER_Y_POSITION - 8, SLIDER_LENGHT, 32, maxEditValue);
+      tft.add_image((SLIDER_LENGTH - 8) * ui.encoderPosition / maxEditValue, 0, imgSlider, COLOR_SLIDER);
+      touch.add_control(SLIDER, (TFT_WIDTH - SLIDER_LENGTH) / 2, SLIDER_Y_POSITION - 8, SLIDER_LENGTH, 32, maxEditValue);
     #endif
   }
 
   #if ENABLED(TOUCH_SCREEN)
     add_control(32, 176, DECREASE, imgDecrease);
     add_control(224, 176, INCREASE, imgIncrease);
     add_control(128, 176, CLICK, imgConfirm);
   #endif
 }
 

commit 9c9113e225d746a0391528ee1d1ff4a08a07b28c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Dec 11 18:21:56 2020 -0600

    Better animated boot screen

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index 51f65c59b5..ceea4a428e 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -81,39 +81,35 @@ void MarlinUI::clear_lcd() {
   #if ENABLED(TOUCH_SCREEN)
     touch.reset();
     draw_menu_navigation = false;
   #endif
 
   tft.queue.reset();
   tft.fill(0, 0, TFT_WIDTH, TFT_HEIGHT, COLOR_BACKGROUND);
 }
 
 #if ENABLED(SHOW_BOOTSCREEN)
-  #ifndef BOOTSCREEN_TIMEOUT
-    #define BOOTSCREEN_TIMEOUT 1500
-  #endif
-
   void MarlinUI::show_bootscreen() {
     tft.queue.reset();
 
     tft.canvas(0, 0, TFT_WIDTH, TFT_HEIGHT);
     tft.add_image(0, 0, imgBootScreen);  // MarlinLogo320x240x16
 
     #ifdef WEBSITE_URL
       tft.add_text(4, 188, COLOR_WEBSITE_URL, WEBSITE_URL);
     #endif
 
     tft.queue.sync();
     safe_delay(BOOTSCREEN_TIMEOUT);
     clear_lcd();
   }
-#endif // SHOW_BOOTSCREEN
+#endif
 
 void MarlinUI::draw_kill_screen() {
   tft.queue.reset();
   tft.fill(0, 0, TFT_WIDTH, TFT_HEIGHT, COLOR_KILL_SCREEN_BG);
 
   tft.canvas(0, 60, TFT_WIDTH, 20);
   tft.set_background(COLOR_KILL_SCREEN_BG);
   tft_string.set(status_message);
   tft_string.trim();
   tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_KILL_SCREEN_TEXT, tft_string);

commit 8fd8772a6fffe63d99d0b88aec7a77d283df8584
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Nov 29 19:06:40 2020 -0600

    Adjust axis homed / trusted methods (#20323)

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index 45a91cd5e5..51f65c59b5 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -250,56 +250,51 @@ void MarlinUI::draw_status_screen() {
         case ITEM_FAN: draw_fan_status(x, y, blink); break;
       #endif
     }
   }
 
   // coordinates
   tft.canvas(4, 103, 312, 24);
   tft.set_background(COLOR_BACKGROUND);
   tft.add_rectangle(0, 0, 312, 24, COLOR_AXIS_HOMED);
 
-  uint16_t color;
-  uint16_t offset;
-  bool is_homed;
-
   tft.add_text( 10, 3, COLOR_AXIS_HOMED , "X");
   tft.add_text(127, 3, COLOR_AXIS_HOMED , "Y");
   tft.add_text(219, 3, COLOR_AXIS_HOMED , "Z");
 
-  is_homed = TEST(axis_homed, X_AXIS);
-  tft_string.set(blink & !is_homed ? "?" : ftostr4sign(LOGICAL_X_POSITION(current_position.x)));
-  tft.add_text( 68 - tft_string.width(), 3, is_homed ? COLOR_AXIS_HOMED : COLOR_AXIS_NOT_HOMED, tft_string);
+  bool not_homed = axis_should_home(X_AXIS);
+  tft_string.set(blink && not_homed ? "?" : ftostr4sign(LOGICAL_X_POSITION(current_position.x)));
+  tft.add_text( 68 - tft_string.width(), 3, not_homed ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
 
-  is_homed = TEST(axis_homed, Y_AXIS);
-  tft_string.set(blink & !is_homed ? "?" : ftostr4sign(LOGICAL_Y_POSITION(current_position.y)));
-  tft.add_text(185 - tft_string.width(), 3, is_homed ? COLOR_AXIS_HOMED : COLOR_AXIS_NOT_HOMED, tft_string);
+  not_homed = axis_should_home(Y_AXIS);
+  tft_string.set(blink && not_homed ? "?" : ftostr4sign(LOGICAL_Y_POSITION(current_position.y)));
+  tft.add_text(185 - tft_string.width(), 3, not_homed ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
 
-  is_homed = TEST(axis_homed, Z_AXIS);
-  if (blink & !is_homed) {
+  not_homed = axis_should_home(Z_AXIS);
+  uint16_t offset = 25;
+  if (blink && not_homed)
     tft_string.set("?");
-    offset = 25; // ".00"
-  }
   else {
     const float z = LOGICAL_Z_POSITION(current_position.z);
     tft_string.set(ftostr52sp((int16_t)z));
     tft_string.rtrim();
-    offset = tft_string.width();
+    offset += tft_string.width();
 
     tft_string.set(ftostr52sp(z));
-    offset += 25 - tft_string.width();
+    offset -= tft_string.width();
   }
-  tft.add_text(301 - tft_string.width() - offset, 3, is_homed ? COLOR_AXIS_HOMED : COLOR_AXIS_NOT_HOMED, tft_string);
+  tft.add_text(301 - tft_string.width() - offset, 3, not_homed ? COLOR_AXIS_NOT_HOMED : COLOR_AXIS_HOMED, tft_string);
 
   // feed rate
   tft.canvas(70, 136, 80, 32);
   tft.set_background(COLOR_BACKGROUND);
-  color = feedrate_percentage == 100 ? COLOR_RATE_100 : COLOR_RATE_ALTERED;
+  uint16_t color = feedrate_percentage == 100 ? COLOR_RATE_100 : COLOR_RATE_ALTERED;
   tft.add_image(0, 0, imgFeedRate, color);
   tft_string.set(i16tostr3rj(feedrate_percentage));
   tft_string.add('%');
   tft.add_text(32, 6, color , tft_string);
   TERN_(TOUCH_SCREEN, touch.add_control(FEEDRATE, 70, 136, 80, 32));
 
   // flow rate
   tft.canvas(170, 136, 80, 32);
   tft.set_background(COLOR_BACKGROUND);
   color = planner.flow_percentage[0] == 100 ? COLOR_RATE_100 : COLOR_RATE_ALTERED;

commit 28e315cd69ba3b5c2049f31937b5876abb1a0578
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Fri Nov 20 10:46:18 2020 -0300

    SINGLE_TOUCH_NAVIGATION Follow Up (#20213)

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index 3444cfe12f..45a91cd5e5 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -645,19 +645,19 @@ void menu_pause_option();
 void menu_item(const uint8_t row, bool sel ) {
   #if ENABLED(TOUCH_SCREEN)
     if (row == 0) {
       touch.clear();
       draw_menu_navigation = TERN(ADVANCED_PAUSE_FEATURE, ui.currentScreen != menu_pause_option, true);
     }
   #endif
 
   menu_line(row, sel ? COLOR_SELECTION_BG : COLOR_BACKGROUND);
   #if ENABLED(TOUCH_SCREEN)
-    const TouchControlType tct = TERN(SINGLE_TOUCH_NAVIGATION, true, sel) ? CLICK : MENU_ITEM;
+    const TouchControlType tct = TERN(SINGLE_TOUCH_NAVIGATION, true, sel) ? MENU_CLICK : MENU_ITEM;
     touch.add_control(tct, 0, 2 + 34 * row, TFT_WIDTH, 32, encoderTopLine + row);
   #endif
 }
 
 void MarlinUI::move_axis_screen() {
 }
 
 #endif // HAS_UI_320x240

commit ea371618da71dc43e6aee95a8e479c8797867e04
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Sun Nov 15 19:39:58 2020 -0300

    Add Touch Calibration screen (#20049)

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index 559bc5b222..3444cfe12f 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -577,58 +577,62 @@ void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const
       add_control(GRID_OFFSET_X + GRID_WIDTH + CONTROL_OFFSET,      GRID_OFFSET_Y + GRID_HEIGHT - CONTROL_OFFSET - 32, UBL, - ENCODER_STEPS_PER_MENU_ITEM * GRID_MAX_POINTS_X, imgDown);
       add_control(GRID_OFFSET_X + CONTROL_OFFSET,                   GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET,      UBL, - ENCODER_STEPS_PER_MENU_ITEM, imgLeft);
       add_control(GRID_OFFSET_X + GRID_WIDTH - CONTROL_OFFSET - 32, GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET,      UBL,   ENCODER_STEPS_PER_MENU_ITEM, imgRight);
       add_control(224, GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET, CLICK, imgLeveling);
       add_control(144, 206, BACK, imgBack);
     #endif
   }
 #endif // AUTO_BED_LEVELING_UBL
 
 #if ENABLED(TOUCH_SCREEN_CALIBRATION)
-  void MarlinUI::touch_calibration() {
-    static uint16_t x, y;
+  void MarlinUI::touch_calibration_screen() {
+    uint16_t x, y;
 
-    calibrationState calibration_stage = touch.get_calibration_state();
+    calibrationState calibration_stage = touch_calibration.get_calibration_state();
 
     if (calibration_stage == CALIBRATION_NONE) {
       defer_status_screen(true);
       clear_lcd();
-      calibration_stage = touch.calibration_start();
+      calibration_stage = touch_calibration.calibration_start();
     }
     else {
+      x = touch_calibration.calibration_points[_MIN(calibration_stage - 1, CALIBRATION_BOTTOM_RIGHT)].x;
+      y = touch_calibration.calibration_points[_MIN(calibration_stage - 1, CALIBRATION_BOTTOM_RIGHT)].y;
       tft.canvas(x - 15, y - 15, 31, 31);
       tft.set_background(COLOR_BACKGROUND);
     }
 
-    x = 20; y = 20;
     touch.clear();
 
     if (calibration_stage < CALIBRATION_SUCCESS) {
       switch (calibration_stage) {
-        case CALIBRATION_POINT_1: tft_string.set("Top Left"); break;
-        case CALIBRATION_POINT_2: y = TFT_HEIGHT - 21; tft_string.set("Bottom Left"); break;
-        case CALIBRATION_POINT_3: x = TFT_WIDTH  - 21; tft_string.set("Top Right"); break;
-        case CALIBRATION_POINT_4: x = TFT_WIDTH  - 21; y = TFT_HEIGHT - 21; tft_string.set("Bottom Right"); break;
+        case CALIBRATION_TOP_LEFT: tft_string.set(GET_TEXT(MSG_TOP_LEFT)); break;
+        case CALIBRATION_BOTTOM_LEFT: tft_string.set(GET_TEXT(MSG_BOTTOM_LEFT)); break;
+        case CALIBRATION_TOP_RIGHT: tft_string.set(GET_TEXT(MSG_TOP_RIGHT)); break;
+        case CALIBRATION_BOTTOM_RIGHT: tft_string.set(GET_TEXT(MSG_BOTTOM_RIGHT)); break;
         default: break;
       }
 
+      x = touch_calibration.calibration_points[calibration_stage].x;
+      y = touch_calibration.calibration_points[calibration_stage].y;
+
       tft.canvas(x - 15, y - 15, 31, 31);
       tft.set_background(COLOR_BACKGROUND);
       tft.add_bar(0, 15, 31, 1, COLOR_TOUCH_CALIBRATION);
       tft.add_bar(15, 0, 1, 31, COLOR_TOUCH_CALIBRATION);
 
       touch.add_control(CALIBRATE, 0, 0, TFT_WIDTH, TFT_HEIGHT, uint32_t(x) << 16 | uint32_t(y));
     }
     else {
-      tft_string.set(calibration_stage == CALIBRATION_SUCCESS ? "Calibration Completed" : "Calibration Failed");
+      tft_string.set(calibration_stage == CALIBRATION_SUCCESS ? GET_TEXT(MSG_CALIBRATION_COMPLETED) : GET_TEXT(MSG_CALIBRATION_FAILED));
       defer_status_screen(false);
-      touch.calibration_end();
+      touch_calibration.calibration_end();
       touch.add_control(BACK, 0, 0, TFT_WIDTH, TFT_HEIGHT);
     }
 
     tft.canvas(0, (TFT_HEIGHT - tft_string.font_height()) >> 1, TFT_WIDTH, tft_string.font_height());
     tft.set_background(COLOR_BACKGROUND);
     tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_MENU_TEXT, tft_string);
   }
 #endif // TOUCH_SCREEN_CALIBRATION
 
 void menu_line(const uint8_t row, uint16_t color) {

commit d4ba94479b114df6a6d5220c87dd7bf100942863
Author: ellensp <ellensp@hotmail.com>
Date:   Wed Nov 11 15:06:42 2020 +1300

    BTT driver expansion for SKR 1.3/1.4  (#20088)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index 999cec29ba..559bc5b222 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -642,18 +642,18 @@ void menu_item(const uint8_t row, bool sel ) {
   #if ENABLED(TOUCH_SCREEN)
     if (row == 0) {
       touch.clear();
       draw_menu_navigation = TERN(ADVANCED_PAUSE_FEATURE, ui.currentScreen != menu_pause_option, true);
     }
   #endif
 
   menu_line(row, sel ? COLOR_SELECTION_BG : COLOR_BACKGROUND);
   #if ENABLED(TOUCH_SCREEN)
     const TouchControlType tct = TERN(SINGLE_TOUCH_NAVIGATION, true, sel) ? CLICK : MENU_ITEM;
-    touch.add_control(tct, 0, 2 + 34 * row, 320, 32, encoderTopLine + row);
+    touch.add_control(tct, 0, 2 + 34 * row, TFT_WIDTH, 32, encoderTopLine + row);
   #endif
 }
 
 void MarlinUI::move_axis_screen() {
 }
 
 #endif // HAS_UI_320x240

commit 2fdeceda58808015a93d1cb2a1137c0528668a3e
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Sat Nov 7 06:00:29 2020 -0300

    Color UI single touch menu navigation (#20053)

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index 4e2cd8acc4..999cec29ba 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -640,17 +640,20 @@ void menu_pause_option();
 
 void menu_item(const uint8_t row, bool sel ) {
   #if ENABLED(TOUCH_SCREEN)
     if (row == 0) {
       touch.clear();
       draw_menu_navigation = TERN(ADVANCED_PAUSE_FEATURE, ui.currentScreen != menu_pause_option, true);
     }
   #endif
 
   menu_line(row, sel ? COLOR_SELECTION_BG : COLOR_BACKGROUND);
-  TERN_(TOUCH_SCREEN, touch.add_control(sel ? CLICK : MENU_ITEM, 0, 2 + 34 * row, 320, 32, encoderTopLine + row));
+  #if ENABLED(TOUCH_SCREEN)
+    const TouchControlType tct = TERN(SINGLE_TOUCH_NAVIGATION, true, sel) ? CLICK : MENU_ITEM;
+    touch.add_control(tct, 0, 2 + 34 * row, 320, 32, encoderTopLine + row);
+  #endif
 }
 
 void MarlinUI::move_axis_screen() {
 }
 
 #endif // HAS_UI_320x240

commit 0be276482ebd5545dc11d97fd7a50c7673ad584d
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Tue Nov 3 20:21:15 2020 -0300

    Show un-mounted media slot (#20005)

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index 45eab34665..4e2cd8acc4 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -329,21 +329,21 @@ void MarlinUI::draw_status_screen() {
 
   // status message
   tft.canvas(0, 216, 320, 20);
   tft.set_background(COLOR_BACKGROUND);
   tft_string.set(status_message);
   tft_string.trim();
   tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_STATUS_MESSAGE, tft_string);
 
   #if ENABLED(TOUCH_SCREEN)
     add_control(256, 130, menu_main, imgSettings);
-    TERN_(SDSUPPORT, add_control(0, 130, menu_media, imgSD, card.isMounted() && !printingIsActive(), COLOR_CONTROL_ENABLED, card.isMounted() && printingIsActive() ? COLOR_BUSY : COLOR_CONTROL_DISABLED));
+    TERN_(SDSUPPORT, add_control(0, 130, menu_media, imgSD, !printingIsActive(), COLOR_CONTROL_ENABLED, card.isMounted() && printingIsActive() ? COLOR_BUSY : COLOR_CONTROL_DISABLED));
   #endif
 }
 
 // Draw a static item with no left-right margin required. Centered by default.
 void MenuItem_static::draw(const uint8_t row, PGM_P const pstr, const uint8_t style/*=SS_DEFAULT*/, const char * const vstr/*=nullptr*/) {
   menu_item(row);
   tft_string.set(pstr, itemIndex, itemString);
   if (vstr)
     tft_string.add(vstr);
   tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_YELLOW, tft_string);

commit ec23e37a4a31d12febc06922d3fa68446f58d7fb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Oct 24 17:13:10 2020 -0500

    Clean up comments, USB flash, NULLs

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index 339c26cca2..45eab34665 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -445,21 +445,21 @@ void MenuEditItemBase::draw_edit_screen(PGM_P const pstr, const char* const valu
     add_control(32, 176, DECREASE, imgDecrease);
     add_control(224, 176, INCREASE, imgIncrease);
     add_control(128, 176, CLICK, imgConfirm);
   #endif
 }
 
 // The Select Screen presents a prompt and two "buttons"
 void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const bool yesno, PGM_P const pref, const char * const string/*=nullptr*/, PGM_P const suff/*=nullptr*/) {
   uint16_t line = 1;
 
-  if (string == NULL) line++;
+  if (!string) line++;
 
   menu_line(line++);
   tft_string.set(pref);
   tft_string.trim();
   tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
 
   if (string) {
     menu_line(line++);
     tft_string.set(string);
     tft_string.trim();

commit eaf6777a6643a6fab23ceaaa4699cb2466ea6b83
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Oct 16 19:36:25 2020 -0500

    Rename ultralcd => marlinui

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index de8498c5ff..339c26cca2 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -19,21 +19,21 @@
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 #include "../../inc/MarlinConfigPre.h"
 
 #if HAS_UI_320x240
 
 #include "ui_320x240.h"
 
-#include "../ultralcd.h"
+#include "../marlinui.h"
 #include "../menu/menu.h"
 #include "../../libs/numtostr.h"
 
 #include "../../sd/cardreader.h"
 #include "../../module/temperature.h"
 #include "../../module/printcounter.h"
 #include "../../module/planner.h"
 #include "../../module/motion.h"
 
 #if DISABLED(LCD_PROGRESS_BAR) && BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)

commit 8e0fac897b2ab0352059d5f9bd2d6293ae7d9bbf
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 20 18:24:05 2020 -0500

    Whitespace cleanup

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index 2f4c90e170..de8498c5ff 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -596,21 +596,21 @@ void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const
     }
     else {
       tft.canvas(x - 15, y - 15, 31, 31);
       tft.set_background(COLOR_BACKGROUND);
     }
 
     x = 20; y = 20;
     touch.clear();
 
     if (calibration_stage < CALIBRATION_SUCCESS) {
-      switch(calibration_stage) {
+      switch (calibration_stage) {
         case CALIBRATION_POINT_1: tft_string.set("Top Left"); break;
         case CALIBRATION_POINT_2: y = TFT_HEIGHT - 21; tft_string.set("Bottom Left"); break;
         case CALIBRATION_POINT_3: x = TFT_WIDTH  - 21; tft_string.set("Top Right"); break;
         case CALIBRATION_POINT_4: x = TFT_WIDTH  - 21; y = TFT_HEIGHT - 21; tft_string.set("Bottom Right"); break;
         default: break;
       }
 
       tft.canvas(x - 15, y - 15, 31, 31);
       tft.set_background(COLOR_BACKGROUND);
       tft.add_bar(0, 15, 31, 1, COLOR_TOUCH_CALIBRATION);

commit 5b56d6698a2a9b78a5dd40446bcb606cbfff010d
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Thu Sep 17 08:52:21 2020 -0300

    Move screen for Color UI (#19386)

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index a4ac1465ea..2f4c90e170 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -643,11 +643,14 @@ void menu_item(const uint8_t row, bool sel ) {
     if (row == 0) {
       touch.clear();
       draw_menu_navigation = TERN(ADVANCED_PAUSE_FEATURE, ui.currentScreen != menu_pause_option, true);
     }
   #endif
 
   menu_line(row, sel ? COLOR_SELECTION_BG : COLOR_BACKGROUND);
   TERN_(TOUCH_SCREEN, touch.add_control(sel ? CLICK : MENU_ITEM, 0, 2 + 34 * row, 320, 32, encoderTopLine + row));
 }
 
+void MarlinUI::move_axis_screen() {
+}
+
 #endif // HAS_UI_320x240

commit c2d5b63a9882dc02f41017a5b2f24363a55fef8d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Aug 8 18:21:44 2020 -0500

    Fix up STATIC_ITEM (#18962)

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
index 0b800abc39..a4ac1465ea 100644
--- a/Marlin/src/lcd/tft/ui_320x240.cpp
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -334,25 +334,25 @@ void MarlinUI::draw_status_screen() {
   tft_string.trim();
   tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_STATUS_MESSAGE, tft_string);
 
   #if ENABLED(TOUCH_SCREEN)
     add_control(256, 130, menu_main, imgSettings);
     TERN_(SDSUPPORT, add_control(0, 130, menu_media, imgSD, card.isMounted() && !printingIsActive(), COLOR_CONTROL_ENABLED, card.isMounted() && printingIsActive() ? COLOR_BUSY : COLOR_CONTROL_DISABLED));
   #endif
 }
 
 // Draw a static item with no left-right margin required. Centered by default.
-void MenuItem_static::draw(const uint8_t row, PGM_P const pstr, const uint8_t style/*=SS_DEFAULT*/, const char * const valstr/*=nullptr*/) {
+void MenuItem_static::draw(const uint8_t row, PGM_P const pstr, const uint8_t style/*=SS_DEFAULT*/, const char * const vstr/*=nullptr*/) {
   menu_item(row);
   tft_string.set(pstr, itemIndex, itemString);
-  if (valstr)
-    tft_string.add(valstr);
+  if (vstr)
+    tft_string.add(vstr);
   tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_YELLOW, tft_string);
 }
 
 // Draw a generic menu item with pre_char (if selected) and post_char
 void MenuItemBase::_draw(const bool sel, const uint8_t row, PGM_P const pstr, const char pre_char, const char post_char) {
   menu_item(row, sel);
 
   uint8_t *string = (uint8_t *)pstr;
   MarlinImage image = noImage;
   switch (*string) {

commit 117df87d193994f6fbcd46c45573095adf921784
Author: Alexander Gavrilenko <jmz52@users.noreply.github.com>
Date:   Thu Jul 30 09:43:19 2020 +0300

    Support for TFT & Touch Screens (#18130)

diff --git a/Marlin/src/lcd/tft/ui_320x240.cpp b/Marlin/src/lcd/tft/ui_320x240.cpp
new file mode 100644
index 0000000000..0b800abc39
--- /dev/null
+++ b/Marlin/src/lcd/tft/ui_320x240.cpp
@@ -0,0 +1,653 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "../../inc/MarlinConfigPre.h"
+
+#if HAS_UI_320x240
+
+#include "ui_320x240.h"
+
+#include "../ultralcd.h"
+#include "../menu/menu.h"
+#include "../../libs/numtostr.h"
+
+#include "../../sd/cardreader.h"
+#include "../../module/temperature.h"
+#include "../../module/printcounter.h"
+#include "../../module/planner.h"
+#include "../../module/motion.h"
+
+#if DISABLED(LCD_PROGRESS_BAR) && BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
+  #include "../../feature/filwidth.h"
+  #include "../../gcode/parser.h"
+#endif
+
+#if ENABLED(AUTO_BED_LEVELING_UBL)
+  #include "../../feature/bedlevel/bedlevel.h"
+#endif
+
+#if !HAS_LCD_MENU
+  #error "Seriously? High resolution TFT screen without menu?"
+#endif
+
+static bool draw_menu_navigation = false;
+
+void MarlinUI::tft_idle() {
+  #if ENABLED(TOUCH_SCREEN)
+    if (draw_menu_navigation) {
+      add_control(48, 206, PAGE_UP, imgPageUp, encoderTopLine > 0);
+      add_control(240, 206, PAGE_DOWN, imgPageDown, encoderTopLine + LCD_HEIGHT < screen_items);
+      add_control(144, 206, BACK, imgBack);
+      draw_menu_navigation = false;
+    }
+  #endif
+
+  tft.queue.async();
+  TERN_(TOUCH_SCREEN, touch.idle());
+}
+
+void MarlinUI::init_lcd() {
+  tft.init();
+  tft.set_font(MENU_FONT_NAME);
+  #ifdef SYMBOLS_FONT_NAME
+    tft.add_glyphs(SYMBOLS_FONT_NAME);
+  #endif
+  TERN_(TOUCH_SCREEN, touch.init());
+  clear_lcd();
+}
+
+bool MarlinUI::detected() { return true; }
+
+void MarlinUI::clear_lcd() {
+  #if ENABLED(TOUCH_SCREEN)
+    touch.reset();
+    draw_menu_navigation = false;
+  #endif
+
+  tft.queue.reset();
+  tft.fill(0, 0, TFT_WIDTH, TFT_HEIGHT, COLOR_BACKGROUND);
+}
+
+#if ENABLED(SHOW_BOOTSCREEN)
+  #ifndef BOOTSCREEN_TIMEOUT
+    #define BOOTSCREEN_TIMEOUT 1500
+  #endif
+
+  void MarlinUI::show_bootscreen() {
+    tft.queue.reset();
+
+    tft.canvas(0, 0, TFT_WIDTH, TFT_HEIGHT);
+    tft.add_image(0, 0, imgBootScreen);  // MarlinLogo320x240x16
+
+    #ifdef WEBSITE_URL
+      tft.add_text(4, 188, COLOR_WEBSITE_URL, WEBSITE_URL);
+    #endif
+
+    tft.queue.sync();
+    safe_delay(BOOTSCREEN_TIMEOUT);
+    clear_lcd();
+  }
+#endif // SHOW_BOOTSCREEN
+
+void MarlinUI::draw_kill_screen() {
+  tft.queue.reset();
+  tft.fill(0, 0, TFT_WIDTH, TFT_HEIGHT, COLOR_KILL_SCREEN_BG);
+
+  tft.canvas(0, 60, TFT_WIDTH, 20);
+  tft.set_background(COLOR_KILL_SCREEN_BG);
+  tft_string.set(status_message);
+  tft_string.trim();
+  tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_KILL_SCREEN_TEXT, tft_string);
+
+  tft.canvas(0, 120, TFT_WIDTH, 20);
+  tft.set_background(COLOR_KILL_SCREEN_BG);
+  tft_string.set(GET_TEXT(MSG_HALTED));
+  tft_string.trim();
+  tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_KILL_SCREEN_TEXT, tft_string);
+
+  tft.canvas(0, 160, TFT_WIDTH, 20);
+  tft.set_background(COLOR_KILL_SCREEN_BG);
+  tft_string.set(GET_TEXT(MSG_PLEASE_RESET));
+  tft_string.trim();
+  tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_KILL_SCREEN_TEXT, tft_string);
+
+  tft.queue.sync();
+}
+
+void draw_heater_status(uint16_t x, uint16_t y, const int8_t Heater) {
+  MarlinImage image = imgHotEnd;
+  uint16_t Color;
+  float currentTemperature, targetTemperature;
+
+  if (Heater >= 0) { // HotEnd
+    currentTemperature = thermalManager.degHotend(Heater);
+    targetTemperature = thermalManager.degTargetHotend(Heater);
+  }
+#if HAS_HEATED_BED
+  else if (Heater == H_BED) {
+    currentTemperature = thermalManager.degBed();
+    targetTemperature = thermalManager.degTargetBed();
+  }
+#endif // HAS_HEATED_BED
+#if HAS_TEMP_CHAMBER
+  else if (Heater == H_CHAMBER) {
+    currentTemperature = thermalManager.degChamber();
+    #if HAS_HEATED_CHAMBER
+      targetTemperature = thermalManager.degTargetChamber();
+    #else
+      targetTemperature = ABSOLUTE_ZERO;
+    #endif
+  }
+#endif // HAS_TEMP_CHAMBER
+  else return;
+
+  TERN_(TOUCH_SCREEN, if (targetTemperature >= 0) touch.add_control(HEATER, x, y, 64, 100, Heater));
+  tft.canvas(x, y, 64, 100);
+  tft.set_background(COLOR_BACKGROUND);
+
+  Color = currentTemperature < 0 ? COLOR_INACTIVE : COLOR_COLD;
+
+  if (Heater >= 0) { // HotEnd
+    if (currentTemperature >= 50) Color = COLOR_HOTEND;
+  }
+  #if HAS_HEATED_BED
+  else if (Heater == H_BED) {
+    if (currentTemperature >= 50) Color = COLOR_HEATED_BED;
+    image = targetTemperature > 0 ? imgBedHeated : imgBed;
+  }
+  #endif // HAS_HEATED_BED
+  #if HAS_TEMP_CHAMBER
+  else if (Heater == H_CHAMBER) {
+    if (currentTemperature >= 50) Color = COLOR_CHAMBER;
+    image = targetTemperature > 0 ? imgChamberHeated : imgChamber;
+  }
+  #endif // HAS_TEMP_CHAMBER
+
+  tft.add_image(0, 18, image, Color);
+
+  tft_string.set((uint8_t *)i16tostr3rj(currentTemperature + 0.5));
+  tft_string.add(LCD_STR_DEGREE);
+  tft_string.trim();
+  tft.add_text(tft_string.center(64) + 2, 72, Color, tft_string);
+
+  if (targetTemperature >= 0) {
+    tft_string.set((uint8_t *)i16tostr3rj(targetTemperature + 0.5));
+    tft_string.add(LCD_STR_DEGREE);
+    tft_string.trim();
+    tft.add_text(tft_string.center(64) + 2, 8, Color, tft_string);
+
+  }
+}
+
+void draw_fan_status(uint16_t x, uint16_t y, const bool blink) {
+  TERN_(TOUCH_SCREEN, touch.add_control(FAN, x, y, 64, 100));
+  tft.canvas(x, y, 64, 100);
+  tft.set_background(COLOR_BACKGROUND);
+
+  uint8_t fanSpeed = thermalManager.fan_speed[0];
+  MarlinImage image;
+
+  if (fanSpeed >= 127)
+    image = blink ? imgFanFast1 : imgFanFast0;
+  else if (fanSpeed > 0)
+    image = blink ? imgFanSlow1 : imgFanSlow0;
+  else
+    image = imgFanIdle;
+
+  tft.add_image(0, 10, image, COLOR_FAN);
+
+  tft_string.set((uint8_t *)ui8tostr4pctrj(thermalManager.fan_speed[0]));
+  tft_string.trim();
+  tft.add_text(tft_string.center(64) + 6, 72, COLOR_FAN, tft_string);
+}
+
+void MarlinUI::draw_status_screen() {
+  const bool blink = get_blink();
+
+  TERN_(TOUCH_SCREEN, touch.clear());
+
+  // heaters and fan
+  uint16_t i, x, y = POS_Y;
+
+  for (i = 0 ; i < ITEMS_COUNT; i++) {
+    x = (320 / ITEMS_COUNT - 64) / 2  + (320 * i / ITEMS_COUNT);
+    switch (i) {
+      #ifdef ITEM_E0
+        case ITEM_E0: draw_heater_status(x, y, H_E0); break;
+      #endif
+      #ifdef ITEM_E1
+        case ITEM_E1: draw_heater_status(x, y, H_E1); break;
+      #endif
+      #ifdef ITEM_E2
+        case ITEM_E2: draw_heater_status(x, y, H_E2); break;
+      #endif
+      #ifdef ITEM_BED
+        case ITEM_BED: draw_heater_status(x, y, H_BED); break;
+      #endif
+      #ifdef ITEM_CHAMBER
+        case ITEM_CHAMBER: draw_heater_status(x, y, H_CHAMBER); break;
+      #endif
+      #ifdef ITEM_FAN
+        case ITEM_FAN: draw_fan_status(x, y, blink); break;
+      #endif
+    }
+  }
+
+  // coordinates
+  tft.canvas(4, 103, 312, 24);
+  tft.set_background(COLOR_BACKGROUND);
+  tft.add_rectangle(0, 0, 312, 24, COLOR_AXIS_HOMED);
+
+  uint16_t color;
+  uint16_t offset;
+  bool is_homed;
+
+  tft.add_text( 10, 3, COLOR_AXIS_HOMED , "X");
+  tft.add_text(127, 3, COLOR_AXIS_HOMED , "Y");
+  tft.add_text(219, 3, COLOR_AXIS_HOMED , "Z");
+
+  is_homed = TEST(axis_homed, X_AXIS);
+  tft_string.set(blink & !is_homed ? "?" : ftostr4sign(LOGICAL_X_POSITION(current_position.x)));
+  tft.add_text( 68 - tft_string.width(), 3, is_homed ? COLOR_AXIS_HOMED : COLOR_AXIS_NOT_HOMED, tft_string);
+
+  is_homed = TEST(axis_homed, Y_AXIS);
+  tft_string.set(blink & !is_homed ? "?" : ftostr4sign(LOGICAL_Y_POSITION(current_position.y)));
+  tft.add_text(185 - tft_string.width(), 3, is_homed ? COLOR_AXIS_HOMED : COLOR_AXIS_NOT_HOMED, tft_string);
+
+  is_homed = TEST(axis_homed, Z_AXIS);
+  if (blink & !is_homed) {
+    tft_string.set("?");
+    offset = 25; // ".00"
+  }
+  else {
+    const float z = LOGICAL_Z_POSITION(current_position.z);
+    tft_string.set(ftostr52sp((int16_t)z));
+    tft_string.rtrim();
+    offset = tft_string.width();
+
+    tft_string.set(ftostr52sp(z));
+    offset += 25 - tft_string.width();
+  }
+  tft.add_text(301 - tft_string.width() - offset, 3, is_homed ? COLOR_AXIS_HOMED : COLOR_AXIS_NOT_HOMED, tft_string);
+
+  // feed rate
+  tft.canvas(70, 136, 80, 32);
+  tft.set_background(COLOR_BACKGROUND);
+  color = feedrate_percentage == 100 ? COLOR_RATE_100 : COLOR_RATE_ALTERED;
+  tft.add_image(0, 0, imgFeedRate, color);
+  tft_string.set(i16tostr3rj(feedrate_percentage));
+  tft_string.add('%');
+  tft.add_text(32, 6, color , tft_string);
+  TERN_(TOUCH_SCREEN, touch.add_control(FEEDRATE, 70, 136, 80, 32));
+
+  // flow rate
+  tft.canvas(170, 136, 80, 32);
+  tft.set_background(COLOR_BACKGROUND);
+  color = planner.flow_percentage[0] == 100 ? COLOR_RATE_100 : COLOR_RATE_ALTERED;
+  tft.add_image(0, 0, imgFlowRate, color);
+  tft_string.set(i16tostr3rj(planner.flow_percentage[active_extruder]));
+  tft_string.add('%');
+  tft.add_text(32, 6, color , tft_string);
+  TERN_(TOUCH_SCREEN, touch.add_control(FLOWRATE, 170, 136, 80, 32, active_extruder));
+
+  // print duration
+  char buffer[14];
+  duration_t elapsed = print_job_timer.duration();
+  elapsed.toDigital(buffer);
+
+  tft.canvas(96, 176, 128, 20);
+  tft.set_background(COLOR_BACKGROUND);
+  tft_string.set(buffer);
+  tft.add_text(tft_string.center(128), 0, COLOR_PRINT_TIME, tft_string);
+
+  // progress bar
+  const uint8_t progress = ui.get_progress_percent();
+  tft.canvas(4, 198, 312, 9);
+  tft.set_background(COLOR_PROGRESS_BG);
+  tft.add_rectangle(0, 0, 312, 9, COLOR_PROGRESS_FRAME);
+  if (progress)
+    tft.add_bar(1, 1, (310 * progress) / 100, 7, COLOR_PROGRESS_BAR);
+
+  // status message
+  tft.canvas(0, 216, 320, 20);
+  tft.set_background(COLOR_BACKGROUND);
+  tft_string.set(status_message);
+  tft_string.trim();
+  tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_STATUS_MESSAGE, tft_string);
+
+  #if ENABLED(TOUCH_SCREEN)
+    add_control(256, 130, menu_main, imgSettings);
+    TERN_(SDSUPPORT, add_control(0, 130, menu_media, imgSD, card.isMounted() && !printingIsActive(), COLOR_CONTROL_ENABLED, card.isMounted() && printingIsActive() ? COLOR_BUSY : COLOR_CONTROL_DISABLED));
+  #endif
+}
+
+// Draw a static item with no left-right margin required. Centered by default.
+void MenuItem_static::draw(const uint8_t row, PGM_P const pstr, const uint8_t style/*=SS_DEFAULT*/, const char * const valstr/*=nullptr*/) {
+  menu_item(row);
+  tft_string.set(pstr, itemIndex, itemString);
+  if (valstr)
+    tft_string.add(valstr);
+  tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_YELLOW, tft_string);
+}
+
+// Draw a generic menu item with pre_char (if selected) and post_char
+void MenuItemBase::_draw(const bool sel, const uint8_t row, PGM_P const pstr, const char pre_char, const char post_char) {
+  menu_item(row, sel);
+
+  uint8_t *string = (uint8_t *)pstr;
+  MarlinImage image = noImage;
+  switch (*string) {
+    case 0x01: image = imgRefresh; break;  // LCD_STR_REFRESH
+    case 0x02: image = imgDirectory; break;  // LCD_STR_FOLDER
+  }
+
+  uint8_t offset = MENU_TEXT_X_OFFSET;
+  if (image != noImage) {
+    string++;
+    offset = 32;
+    tft.add_image(0, 0, image, COLOR_MENU_TEXT, sel ? COLOR_SELECTION_BG : COLOR_BACKGROUND);
+  }
+
+  tft_string.set(string, itemIndex, itemString);
+  tft.add_text(offset, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
+}
+
+// Draw a menu item with a (potentially) editable value
+void MenuEditItemBase::draw(const bool sel, const uint8_t row, PGM_P const pstr, const char* const data, const bool pgm) {
+  menu_item(row, sel);
+
+  tft_string.set(pstr, itemIndex, itemString);
+  tft.add_text(MENU_TEXT_X_OFFSET, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
+  if (data) {
+    tft_string.set(data);
+    tft.add_text(TFT_WIDTH - MENU_TEXT_X_OFFSET - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
+  }
+}
+
+// Low-level draw_edit_screen can be used to draw an edit screen from anyplace
+void MenuEditItemBase::draw_edit_screen(PGM_P const pstr, const char* const value/*=nullptr*/) {
+  ui.encoder_direction_normal();
+  TERN_(TOUCH_SCREEN, touch.clear());
+
+  uint16_t line = 1;
+
+  menu_line(line++);
+  tft_string.set(pstr, itemIndex, itemString);
+  tft_string.trim();
+  tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
+
+  TERN_(AUTO_BED_LEVELING_UBL, if (ui.external_control) line++);  // ftostr52() will overwrite *value so *value has to be displayed first
+
+  menu_line(line);
+  tft_string.set(value);
+  tft_string.trim();
+  tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
+
+  #if ENABLED(AUTO_BED_LEVELING_UBL)
+    if (ui.external_control) {
+      menu_line(line - 1);
+
+      tft_string.set(X_LBL);
+      tft.add_text(52, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
+      tft_string.set(ftostr52(LOGICAL_X_POSITION(current_position.x)));
+      tft_string.trim();
+      tft.add_text(144 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
+
+      tft_string.set(Y_LBL);
+      tft.add_text(176, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
+      tft_string.set(ftostr52(LOGICAL_X_POSITION(current_position.y)));
+      tft_string.trim();
+      tft.add_text(268 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
+    }
+  #endif
+
+  extern screenFunc_t _manual_move_func_ptr;
+  if (ui.currentScreen != _manual_move_func_ptr && !ui.external_control) {
+
+    #define SLIDER_LENGHT 224
+    #define SLIDER_Y_POSITION 140
+
+    tft.canvas((TFT_WIDTH - SLIDER_LENGHT) / 2, SLIDER_Y_POSITION, SLIDER_LENGHT, 16);
+    tft.set_background(COLOR_BACKGROUND);
+
+    int16_t position = (SLIDER_LENGHT - 2) * ui.encoderPosition / maxEditValue;
+    tft.add_bar(0, 7, 1, 2, ui.encoderPosition == 0 ? COLOR_SLIDER_INACTIVE : COLOR_SLIDER);
+    tft.add_bar(1, 6, position, 4, COLOR_SLIDER);
+    tft.add_bar(position + 1, 6, SLIDER_LENGHT - 2 - position, 4, COLOR_SLIDER_INACTIVE);
+    tft.add_bar(SLIDER_LENGHT - 1, 7, 1, 2, int32_t(ui.encoderPosition) == maxEditValue ? COLOR_SLIDER : COLOR_SLIDER_INACTIVE);
+
+    #if ENABLED(TOUCH_SCREEN)
+      tft.add_image((SLIDER_LENGHT - 8) * ui.encoderPosition / maxEditValue, 0, imgSlider, COLOR_SLIDER);
+      touch.add_control(SLIDER, (TFT_WIDTH - SLIDER_LENGHT) / 2, SLIDER_Y_POSITION - 8, SLIDER_LENGHT, 32, maxEditValue);
+    #endif
+  }
+
+  #if ENABLED(TOUCH_SCREEN)
+    add_control(32, 176, DECREASE, imgDecrease);
+    add_control(224, 176, INCREASE, imgIncrease);
+    add_control(128, 176, CLICK, imgConfirm);
+  #endif
+}
+
+// The Select Screen presents a prompt and two "buttons"
+void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const bool yesno, PGM_P const pref, const char * const string/*=nullptr*/, PGM_P const suff/*=nullptr*/) {
+  uint16_t line = 1;
+
+  if (string == NULL) line++;
+
+  menu_line(line++);
+  tft_string.set(pref);
+  tft_string.trim();
+  tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
+
+  if (string) {
+    menu_line(line++);
+    tft_string.set(string);
+    tft_string.trim();
+    tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
+  }
+
+  if (suff) {
+    menu_line(line);
+    tft_string.set(suff);
+    tft_string.trim();
+    tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
+  }
+  #if ENABLED(TOUCH_SCREEN)
+    add_control(48, 176, CANCEL, imgCancel, true, yesno ? HALF(COLOR_CONTROL_CANCEL) : COLOR_CONTROL_CANCEL);
+    add_control(208, 176, CONFIRM, imgConfirm, true, yesno ? COLOR_CONTROL_CONFIRM : HALF(COLOR_CONTROL_CONFIRM));
+  #endif
+}
+
+#if ENABLED(SDSUPPORT)
+  void MenuItem_sdbase::draw(const bool sel, const uint8_t row, PGM_P const, CardReader &theCard, const bool isDir) {
+    menu_item(row, sel);
+    if (isDir)
+      tft.add_image(0, 0, imgDirectory, COLOR_MENU_TEXT, sel ? COLOR_SELECTION_BG : COLOR_BACKGROUND);
+    tft.add_text(32, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, theCard.longest_filename());
+  }
+#endif
+
+#if ENABLED(ADVANCED_PAUSE_FEATURE)
+  void MarlinUI::draw_hotend_status(const uint8_t row, const uint8_t extruder) {
+    #if ENABLED(TOUCH_SCREEN)
+      touch.clear();
+      draw_menu_navigation = false;
+      touch.add_control(RESUME_CONTINUE , 0, 0, 320, 240);
+    #endif
+
+    menu_line(row);
+    tft_string.set(GET_TEXT(MSG_FILAMENT_CHANGE_NOZZLE));
+    tft_string.add('E');
+    tft_string.add((char)('1' + extruder));
+    tft_string.add(' ');
+    tft_string.add(i16tostr3rj(thermalManager.degHotend(extruder)));
+    tft_string.add(LCD_STR_DEGREE);
+    tft_string.add(" / ");
+    tft_string.add(i16tostr3rj(thermalManager.degTargetHotend(extruder)));
+    tft_string.add(LCD_STR_DEGREE);
+    tft_string.trim();
+    tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
+  }
+#endif // ADVANCED_PAUSE_FEATURE
+
+#if ENABLED(AUTO_BED_LEVELING_UBL)
+  #define GRID_OFFSET_X   8
+  #define GRID_OFFSET_Y   8
+  #define GRID_WIDTH      144
+  #define GRID_HEIGHT     144
+  #define CONTROL_OFFSET  8
+
+  void MarlinUI::ubl_plot(const uint8_t x_plot, const uint8_t y_plot) {
+
+    tft.canvas(GRID_OFFSET_X, GRID_OFFSET_Y, GRID_WIDTH, GRID_HEIGHT);
+    tft.set_background(COLOR_BACKGROUND);
+    tft.add_rectangle(0, 0, GRID_WIDTH, GRID_HEIGHT, COLOR_WHITE);
+
+    for (uint16_t x = 0; x < GRID_MAX_POINTS_X ; x++)
+      for (uint16_t y = 0; y < GRID_MAX_POINTS_Y ; y++)
+        if (position_is_reachable({ ubl.mesh_index_to_xpos(x), ubl.mesh_index_to_ypos(y) }))
+          tft.add_bar(1 + (x * 2 + 1) * (GRID_WIDTH - 4) / GRID_MAX_POINTS_X / 2, GRID_HEIGHT - 3 - ((y * 2 + 1) * (GRID_HEIGHT - 4) / GRID_MAX_POINTS_Y / 2), 2, 2, COLOR_UBL);
+
+    tft.add_rectangle((x_plot * 2 + 1) * (GRID_WIDTH - 4) / GRID_MAX_POINTS_X / 2 - 1, GRID_HEIGHT - 5 - ((y_plot * 2 + 1) * (GRID_HEIGHT - 4) / GRID_MAX_POINTS_Y / 2), 6, 6, COLOR_UBL);
+
+    const xy_pos_t pos = { ubl.mesh_index_to_xpos(x_plot), ubl.mesh_index_to_ypos(y_plot) },
+                   lpos = pos.asLogical();
+
+    tft.canvas(216, GRID_OFFSET_Y + (GRID_HEIGHT - 32) / 2 - 32, 96, 32);
+    tft.set_background(COLOR_BACKGROUND);
+    tft_string.set(X_LBL);
+    tft.add_text(0, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
+    tft_string.set(ftostr52(lpos.x));
+    tft_string.trim();
+    tft.add_text(96 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
+
+    tft.canvas(216, GRID_OFFSET_Y + (GRID_HEIGHT - 32) / 2, 96, 32);
+    tft.set_background(COLOR_BACKGROUND);
+    tft_string.set(Y_LBL);
+    tft.add_text(0, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
+    tft_string.set(ftostr52(lpos.y));
+    tft_string.trim();
+    tft.add_text(96 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
+
+    tft.canvas(216, GRID_OFFSET_Y + (GRID_HEIGHT - 32) / 2 + 32, 96, 32);
+    tft.set_background(COLOR_BACKGROUND);
+    tft_string.set(Z_LBL);
+    tft.add_text(0, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
+    tft_string.set(isnan(ubl.z_values[x_plot][y_plot]) ? "-----" : ftostr43sign(ubl.z_values[x_plot][y_plot]));
+    tft_string.trim();
+    tft.add_text(96 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
+
+
+    tft.canvas(GRID_OFFSET_X + (GRID_WIDTH - 32) / 2, GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET - 1, 32, 32);
+    tft.set_background(COLOR_BACKGROUND);
+    tft_string.set(ui8tostr3rj(x_plot));
+    tft_string.trim();
+    tft.add_text(tft_string.center(32), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
+
+    tft.canvas(GRID_OFFSET_X + GRID_WIDTH + CONTROL_OFFSET, GRID_OFFSET_Y + (GRID_HEIGHT - 27) / 2, 32, 32);
+    tft.set_background(COLOR_BACKGROUND);
+    tft_string.set(ui8tostr3rj(y_plot));
+    tft_string.trim();
+    tft.add_text(tft_string.center(32), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
+
+    #if ENABLED(TOUCH_SCREEN)
+      touch.clear();
+      draw_menu_navigation = false;
+      add_control(GRID_OFFSET_X + GRID_WIDTH + CONTROL_OFFSET,      GRID_OFFSET_Y + CONTROL_OFFSET,                    UBL,   ENCODER_STEPS_PER_MENU_ITEM * GRID_MAX_POINTS_X, imgUp);
+      add_control(GRID_OFFSET_X + GRID_WIDTH + CONTROL_OFFSET,      GRID_OFFSET_Y + GRID_HEIGHT - CONTROL_OFFSET - 32, UBL, - ENCODER_STEPS_PER_MENU_ITEM * GRID_MAX_POINTS_X, imgDown);
+      add_control(GRID_OFFSET_X + CONTROL_OFFSET,                   GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET,      UBL, - ENCODER_STEPS_PER_MENU_ITEM, imgLeft);
+      add_control(GRID_OFFSET_X + GRID_WIDTH - CONTROL_OFFSET - 32, GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET,      UBL,   ENCODER_STEPS_PER_MENU_ITEM, imgRight);
+      add_control(224, GRID_OFFSET_Y + GRID_HEIGHT + CONTROL_OFFSET, CLICK, imgLeveling);
+      add_control(144, 206, BACK, imgBack);
+    #endif
+  }
+#endif // AUTO_BED_LEVELING_UBL
+
+#if ENABLED(TOUCH_SCREEN_CALIBRATION)
+  void MarlinUI::touch_calibration() {
+    static uint16_t x, y;
+
+    calibrationState calibration_stage = touch.get_calibration_state();
+
+    if (calibration_stage == CALIBRATION_NONE) {
+      defer_status_screen(true);
+      clear_lcd();
+      calibration_stage = touch.calibration_start();
+    }
+    else {
+      tft.canvas(x - 15, y - 15, 31, 31);
+      tft.set_background(COLOR_BACKGROUND);
+    }
+
+    x = 20; y = 20;
+    touch.clear();
+
+    if (calibration_stage < CALIBRATION_SUCCESS) {
+      switch(calibration_stage) {
+        case CALIBRATION_POINT_1: tft_string.set("Top Left"); break;
+        case CALIBRATION_POINT_2: y = TFT_HEIGHT - 21; tft_string.set("Bottom Left"); break;
+        case CALIBRATION_POINT_3: x = TFT_WIDTH  - 21; tft_string.set("Top Right"); break;
+        case CALIBRATION_POINT_4: x = TFT_WIDTH  - 21; y = TFT_HEIGHT - 21; tft_string.set("Bottom Right"); break;
+        default: break;
+      }
+
+      tft.canvas(x - 15, y - 15, 31, 31);
+      tft.set_background(COLOR_BACKGROUND);
+      tft.add_bar(0, 15, 31, 1, COLOR_TOUCH_CALIBRATION);
+      tft.add_bar(15, 0, 1, 31, COLOR_TOUCH_CALIBRATION);
+
+      touch.add_control(CALIBRATE, 0, 0, TFT_WIDTH, TFT_HEIGHT, uint32_t(x) << 16 | uint32_t(y));
+    }
+    else {
+      tft_string.set(calibration_stage == CALIBRATION_SUCCESS ? "Calibration Completed" : "Calibration Failed");
+      defer_status_screen(false);
+      touch.calibration_end();
+      touch.add_control(BACK, 0, 0, TFT_WIDTH, TFT_HEIGHT);
+    }
+
+    tft.canvas(0, (TFT_HEIGHT - tft_string.font_height()) >> 1, TFT_WIDTH, tft_string.font_height());
+    tft.set_background(COLOR_BACKGROUND);
+    tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_MENU_TEXT, tft_string);
+  }
+#endif // TOUCH_SCREEN_CALIBRATION
+
+void menu_line(const uint8_t row, uint16_t color) {
+  tft.canvas(0, 2 + 34 * row, TFT_WIDTH, 32);
+  tft.set_background(color);
+}
+
+void menu_pause_option();
+
+void menu_item(const uint8_t row, bool sel ) {
+  #if ENABLED(TOUCH_SCREEN)
+    if (row == 0) {
+      touch.clear();
+      draw_menu_navigation = TERN(ADVANCED_PAUSE_FEATURE, ui.currentScreen != menu_pause_option, true);
+    }
+  #endif
+
+  menu_line(row, sel ? COLOR_SELECTION_BG : COLOR_BACKGROUND);
+  TERN_(TOUCH_SCREEN, touch.add_control(sel ? CLICK : MENU_ITEM, 0, 2 + 34 * row, 320, 32, encoderTopLine + row));
+}
+
+#endif // HAS_UI_320x240
