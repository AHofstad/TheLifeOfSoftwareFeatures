commit ee99eed3bf9f5d811b596058932b88d8ed5298a1
Author: Mihai <299015+mh-dm@users.noreply.github.com>
Date:   Mon Jul 15 21:57:25 2024 +0300

    üö∏ Improved menu responsiveness with MarlinUI + U8Glib. (#26555)
    
    Co-authored-by: Jason Smith <jason.inet@gmail.com>
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/tft/ui_common.cpp b/Marlin/src/lcd/tft/ui_common.cpp
index e42ca7e689..78eae61062 100644
--- a/Marlin/src/lcd/tft/ui_common.cpp
+++ b/Marlin/src/lcd/tft/ui_common.cpp
@@ -379,21 +379,21 @@ void MenuItem_static::draw(const uint8_t row, FSTR_P const ftpl, const uint8_t s
   tft_string.set(vstr);
   tft.add_text(TFT_WIDTH - 1 - tft_string.width(), MENU_TEXT_Y, COLOR_MENU_TEXT, tft_string);
 }
 
 #if HAS_MEDIA
 
   void MenuItem_sdbase::draw(const bool sel, const uint8_t row, FSTR_P const, CardReader &theCard, const bool isDir) {
     menu_item(row, sel);
     if (isDir) tft.add_image(MENU_ITEM_ICON_X, MENU_ITEM_ICON_Y, imgDirectory, COLOR_MENU_TEXT, sel ? COLOR_SELECTION_BG : COLOR_BACKGROUND);
     uint8_t maxlen = (MENU_ITEM_HEIGHT) - (MENU_TEXT_Y) + 1;
-    tft.add_text(MENU_ITEM_ICON_SPACE, MENU_TEXT_Y, COLOR_MENU_TEXT, ui.scrolled_filename(theCard, maxlen, row, sel));
+    tft.add_text(MENU_ITEM_ICON_SPACE, MENU_TEXT_Y, COLOR_MENU_TEXT, ui.scrolled_filename(theCard, maxlen, sel));
   }
 
 #endif
 
 //
 // MarlinUI methods
 //
 
 bool MarlinUI::detected() { return true; }
 

commit 1f9fc665ec21f95666801aa4fccc4f4f71932018
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jun 26 18:27:05 2024 -0500

    üö∏ MarlinUI:: clear_for_drawing

diff --git a/Marlin/src/lcd/tft/ui_common.cpp b/Marlin/src/lcd/tft/ui_common.cpp
index 23f276349b..e42ca7e689 100644
--- a/Marlin/src/lcd/tft/ui_common.cpp
+++ b/Marlin/src/lcd/tft/ui_common.cpp
@@ -192,21 +192,21 @@ void moveAxis(const AxisEnum axis, const int8_t direction) {
 #endif
 
 #if ALL(TOUCH_SCREEN, HAS_DISPLAY_SLEEP)
 
   bool lcd_sleep_task() {
     static bool sleepCleared;
     if (touch.isSleeping()) {
       tft.queue.reset();
       if (!sleepCleared) {
         sleepCleared = true;
-        ui.clear_lcd();
+        ui.clear_for_drawing();
         tft.queue.async();
       }
       touch.idle();
       return true;
     }
     else
       sleepCleared = false;
     return false;
   }
 
@@ -400,55 +400,57 @@ bool MarlinUI::detected() { return true; }
 void MarlinUI::init_lcd() {
   tft.init();
   tft.set_font(MENU_FONT_NAME);
   #ifdef SYMBOLS_FONT_NAME
     tft.add_glyphs(SYMBOLS_FONT_NAME);
   #endif
   #ifdef EXTRA_FONT_NAME
     tft.add_glyphs(EXTRA_FONT_NAME);
   #endif
   TERN_(TOUCH_SCREEN, touch.init());
-  clear_lcd();
+  clear_for_drawing();
 }
 
 void MarlinUI::clear_lcd() {
   #if ENABLED(TOUCH_SCREEN)
     touch.reset();
     draw_menu_navigation = false;
   #endif
 
   tft.queue.reset();
   tft.fill(0, 0, TFT_WIDTH, TFT_HEIGHT, COLOR_BACKGROUND);
   cursor.set(0, 0);
 }
 
+void MarlinUI::clear_for_drawing() { clear_lcd(); }
+
 #if HAS_LCD_BRIGHTNESS
 
   void MarlinUI::_set_brightness() {
     #if PIN_EXISTS(TFT_BACKLIGHT)
       if (PWM_PIN(TFT_BACKLIGHT_PIN))
         analogWrite(pin_t(TFT_BACKLIGHT_PIN), backlight ? brightness : 0);
     #endif
   }
 
 #endif
 
 #if ENABLED(TOUCH_SCREEN_CALIBRATION)
 
   void MarlinUI::touch_calibration_screen() {
     uint16_t x, y;
 
     calibrationState stage = touch_calibration.get_calibration_state();
 
     if (stage == CALIBRATION_NONE) {
       defer_status_screen(true);
-      clear_lcd();
+      clear_for_drawing();
       stage = touch_calibration.calibration_start();
     }
     else {
       x = touch_calibration.calibration_points[_MIN(stage - 1, CALIBRATION_BOTTOM_LEFT)].x;
       y = touch_calibration.calibration_points[_MIN(stage - 1, CALIBRATION_BOTTOM_LEFT)].y;
       tft.canvas(x - 15, y - 15, 31, 31);
       tft.set_background(COLOR_BACKGROUND);
     }
 
     touch.clear();

commit 5f96dffb9b50baf1e730c21405a573ad45b45e7d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed May 15 15:21:39 2024 -0500

    üßë‚Äçüíª FLOAT_SQ macro

diff --git a/Marlin/src/lcd/tft/ui_common.cpp b/Marlin/src/lcd/tft/ui_common.cpp
index c1c14c3bb5..23f276349b 100644
--- a/Marlin/src/lcd/tft/ui_common.cpp
+++ b/Marlin/src/lcd/tft/ui_common.cpp
@@ -122,21 +122,21 @@ void moveAxis(const AxisEnum axis, const int8_t direction) {
 
   if (diff && !ui.manual_move.processing) {
     // Get motion limit from software endstops, if any
     float min, max;
     soft_endstop.get_manual_axis_limits(axis, min, max);
 
     // Delta limits XY based on the current offset from center
     // This assumes the center is 0,0
     #if ENABLED(DELTA)
       if (axis != Z_AXIS && TERN1(HAS_EXTRUDERS, axis != E_AXIS)) {
-        max = SQRT(sq(float(PRINTABLE_RADIUS)) - sq(current_position[Y_AXIS - axis])); // (Y_AXIS - axis) == the other axis
+        max = SQRT(FLOAT_SQ(PRINTABLE_RADIUS) - sq(current_position[Y_AXIS - axis])); // (Y_AXIS - axis) == the other axis
         min = -max;
       }
     #endif
 
     // Get the new position
     const bool limited = ui.manual_move.apply_diff(axis, diff, min, max);
     #if IS_KINEMATIC
       UNUSED(limited);
     #else
       FSTR_P const msg = limited ? GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS) : FPSTR(NUL_STR);

commit 2270bf41d7529873ec997e8842c44045c10ef9e4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 24 18:09:32 2024 -0500

    ü©π IA-Creality minor cleanup

diff --git a/Marlin/src/lcd/tft/ui_common.cpp b/Marlin/src/lcd/tft/ui_common.cpp
index 21ae78f53e..c1c14c3bb5 100644
--- a/Marlin/src/lcd/tft/ui_common.cpp
+++ b/Marlin/src/lcd/tft/ui_common.cpp
@@ -89,48 +89,45 @@ void moveAxis(const AxisEnum axis, const int8_t direction) {
                       , do_probe ? new_probe_offset : hotend_offset[active_extruder].z - bsDiff
                       , new_probe_offset
                     );
         if (WITHIN(new_offs, PROBE_OFFSET_ZMIN, PROBE_OFFSET_ZMAX)) {
           babystep.add_steps(Z_AXIS, babystep_increment);
           if (do_probe)
             probe.offset.z = new_offs;
           else
             TERN(BABYSTEP_HOTEND_Z_OFFSET, hotend_offset[active_extruder].z = new_offs, NOOP);
           drawMessage_P(NUL_STR); // Clear the error
-          drawAxisValue(axis);
         }
         else
           drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
 
       #else // !BABYSTEP_ZPROBE_OFFSET
 
         // Only change probe.offset.z
         probe.offset.z += diff;
         if (direction < 0 && current_position.z < PROBE_OFFSET_ZMIN) {
           current_position.z = PROBE_OFFSET_ZMIN;
           drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
         }
         else if (direction > 0 && current_position.z > PROBE_OFFSET_ZMAX) {
           current_position.z = PROBE_OFFSET_ZMAX;
           drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
         }
         else
           drawMessage_P(NUL_STR); // Clear the error
 
-        drawAxisValue(axis);
-
       #endif // !BABYSTEP_ZPROBE_OFFSET
     }
 
   #endif // HAS_BED_PROBE
 
-  if (!ui.manual_move.processing) {
+  if (diff && !ui.manual_move.processing) {
     // Get motion limit from software endstops, if any
     float min, max;
     soft_endstop.get_manual_axis_limits(axis, min, max);
 
     // Delta limits XY based on the current offset from center
     // This assumes the center is 0,0
     #if ENABLED(DELTA)
       if (axis != Z_AXIS && TERN1(HAS_EXTRUDERS, axis != E_AXIS)) {
         max = SQRT(sq(float(PRINTABLE_RADIUS)) - sq(current_position[Y_AXIS - axis])); // (Y_AXIS - axis) == the other axis
         min = -max;

commit 489ef6e5e1aaf94e1786c50841143c894efe6c2c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 24 17:46:40 2024 -0500

    ü©π Simple IA-Creality babystep patch
    
    See https://github.com/MarlinFirmware/Marlin/issues/26896#issuecomment-2015630458
    
    Co-Authored-By: ellensp <530024+ellensp@users.noreply.github.com>

diff --git a/Marlin/src/lcd/tft/ui_common.cpp b/Marlin/src/lcd/tft/ui_common.cpp
index 944be77ab5..21ae78f53e 100644
--- a/Marlin/src/lcd/tft/ui_common.cpp
+++ b/Marlin/src/lcd/tft/ui_common.cpp
@@ -64,62 +64,68 @@ void disable_steppers() {
 void moveAxis(const AxisEnum axis, const int8_t direction) {
   quick_feedback();
 
   #if HAS_EXTRUDERS
     if (axis == E_AXIS && thermalManager.tooColdToExtrude(motionAxisState.e_selection)) {
       drawMessage(F("Too cold"));
       return;
     }
   #endif
 
-  const float diff = motionAxisState.currentStepSize * direction;
+  float diff = motionAxisState.currentStepSize * direction;
 
   #if HAS_BED_PROBE
 
     if (axis == Z_AXIS && motionAxisState.z_selection == Z_SELECTION_Z_PROBE) {
+
       #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
+
+        diff = 0;
+
         const int16_t babystep_increment = direction * BABYSTEP_SIZE_Z;
         const bool do_probe = DISABLED(BABYSTEP_HOTEND_Z_OFFSET) || active_extruder == 0;
         const float bsDiff = planner.mm_per_step[Z_AXIS] * babystep_increment,
                     new_probe_offset = probe.offset.z + bsDiff,
                     new_offs = TERN(BABYSTEP_HOTEND_Z_OFFSET
                       , do_probe ? new_probe_offset : hotend_offset[active_extruder].z - bsDiff
                       , new_probe_offset
                     );
         if (WITHIN(new_offs, PROBE_OFFSET_ZMIN, PROBE_OFFSET_ZMAX)) {
           babystep.add_steps(Z_AXIS, babystep_increment);
           if (do_probe)
             probe.offset.z = new_offs;
           else
             TERN(BABYSTEP_HOTEND_Z_OFFSET, hotend_offset[active_extruder].z = new_offs, NOOP);
           drawMessage_P(NUL_STR); // Clear the error
           drawAxisValue(axis);
         }
         else
           drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
 
-      #else
+      #else // !BABYSTEP_ZPROBE_OFFSET
+
         // Only change probe.offset.z
         probe.offset.z += diff;
         if (direction < 0 && current_position.z < PROBE_OFFSET_ZMIN) {
           current_position.z = PROBE_OFFSET_ZMIN;
           drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
         }
         else if (direction > 0 && current_position.z > PROBE_OFFSET_ZMAX) {
           current_position.z = PROBE_OFFSET_ZMAX;
           drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
         }
         else
           drawMessage_P(NUL_STR); // Clear the error
 
         drawAxisValue(axis);
-      #endif
+
+      #endif // !BABYSTEP_ZPROBE_OFFSET
     }
 
   #endif // HAS_BED_PROBE
 
   if (!ui.manual_move.processing) {
     // Get motion limit from software endstops, if any
     float min, max;
     soft_endstop.get_manual_axis_limits(axis, min, max);
 
     // Delta limits XY based on the current offset from center

commit 1dee4d92c61b14458cd394d1f609f0dc80282092
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Feb 4 12:09:08 2024 -0600

    üîß TOUCH_IDLE_SLEEP_MINS => DISPLAY_SLEEP_MINUTES
    
    Follow up to #26517

diff --git a/Marlin/src/lcd/tft/ui_common.cpp b/Marlin/src/lcd/tft/ui_common.cpp
index a1766b0676..944be77ab5 100644
--- a/Marlin/src/lcd/tft/ui_common.cpp
+++ b/Marlin/src/lcd/tft/ui_common.cpp
@@ -181,40 +181,40 @@ void moveAxis(const AxisEnum axis, const int8_t direction) {
     void z_select() {
       motionAxisState.z_selection *= -1;
       quick_feedback();
       drawCurZSelection();
       drawAxisValue(Z_AXIS);
     }
   #endif
 
 #endif
 
-#if HAS_TOUCH_SLEEP
+#if ALL(TOUCH_SCREEN, HAS_DISPLAY_SLEEP)
 
   bool lcd_sleep_task() {
     static bool sleepCleared;
     if (touch.isSleeping()) {
       tft.queue.reset();
       if (!sleepCleared) {
         sleepCleared = true;
         ui.clear_lcd();
         tft.queue.async();
       }
       touch.idle();
       return true;
     }
     else
       sleepCleared = false;
     return false;
   }
 
-#endif // HAS_TOUCH_SLEEP
+#endif
 
 void text_line(const uint16_t y, uint16_t color) {
   tft.canvas(0, y, TFT_WIDTH, MENU_ITEM_HEIGHT);
   tft.set_background(color);
 }
 
 void menu_line(const uint8_t row, uint16_t color) {
   cursor.set(0, row);
   text_line(MENU_TOP_LINE_Y + cursor.y * MENU_LINE_HEIGHT, color);
 }

commit 5639237e2b174715413f9ffc6f6421db9150d9d6
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jan 29 20:38:03 2024 -0600

    üé® Misc. cleanup 29-01

diff --git a/Marlin/src/lcd/tft/ui_common.cpp b/Marlin/src/lcd/tft/ui_common.cpp
index 13c8d60d1c..a1766b0676 100644
--- a/Marlin/src/lcd/tft/ui_common.cpp
+++ b/Marlin/src/lcd/tft/ui_common.cpp
@@ -258,21 +258,20 @@ void drawBtn(const int x, const int y, const char *label, intptr_t data, const M
     tft_string.set(label);
     tft_string.trim();
     tft.add_text(tft_string.center(width), height / 2 - tft_string.font_height() / 2, bgColor, tft_string);
   }
   else
     tft.add_image(0, 0, img, bgColor, COLOR_BACKGROUND, COLOR_DARKGREY);
 
   TERN_(TOUCH_SCREEN, if (enabled) touch.add_control(BUTTON, x, y, width, height, data));
 }
 
-
 //
 // lcdprint.h functions
 //
 
 #define TFT_COL_WIDTH ((TFT_WIDTH) / (LCD_WIDTH))
 
 void lcd_gotopixel(const uint16_t x, const uint16_t y) {
   if (x >= TFT_WIDTH) return;
   cursor.set(x / (TFT_COL_WIDTH), y / MENU_LINE_HEIGHT);
   tft.canvas(x, MENU_TOP_LINE_Y + y, (TFT_WIDTH) - x, MENU_ITEM_HEIGHT);

commit cb044d989c397fcbf6f106502df69a7e5c41d34b
Author: Vladimir Sitnikov <sitnikov.vladimir@gmail.com>
Date:   Sun Nov 5 09:46:57 2023 +0300

    ‚ú® Probe XY Offset value limits (#26267)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/tft/ui_common.cpp b/Marlin/src/lcd/tft/ui_common.cpp
index 3426abab0e..13c8d60d1c 100644
--- a/Marlin/src/lcd/tft/ui_common.cpp
+++ b/Marlin/src/lcd/tft/ui_common.cpp
@@ -78,41 +78,41 @@ void moveAxis(const AxisEnum axis, const int8_t direction) {
     if (axis == Z_AXIS && motionAxisState.z_selection == Z_SELECTION_Z_PROBE) {
       #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
         const int16_t babystep_increment = direction * BABYSTEP_SIZE_Z;
         const bool do_probe = DISABLED(BABYSTEP_HOTEND_Z_OFFSET) || active_extruder == 0;
         const float bsDiff = planner.mm_per_step[Z_AXIS] * babystep_increment,
                     new_probe_offset = probe.offset.z + bsDiff,
                     new_offs = TERN(BABYSTEP_HOTEND_Z_OFFSET
                       , do_probe ? new_probe_offset : hotend_offset[active_extruder].z - bsDiff
                       , new_probe_offset
                     );
-        if (WITHIN(new_offs, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
+        if (WITHIN(new_offs, PROBE_OFFSET_ZMIN, PROBE_OFFSET_ZMAX)) {
           babystep.add_steps(Z_AXIS, babystep_increment);
           if (do_probe)
             probe.offset.z = new_offs;
           else
             TERN(BABYSTEP_HOTEND_Z_OFFSET, hotend_offset[active_extruder].z = new_offs, NOOP);
           drawMessage_P(NUL_STR); // Clear the error
           drawAxisValue(axis);
         }
         else
           drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
 
       #else
         // Only change probe.offset.z
         probe.offset.z += diff;
-        if (direction < 0 && current_position.z < Z_PROBE_OFFSET_RANGE_MIN) {
-          current_position.z = Z_PROBE_OFFSET_RANGE_MIN;
+        if (direction < 0 && current_position.z < PROBE_OFFSET_ZMIN) {
+          current_position.z = PROBE_OFFSET_ZMIN;
           drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
         }
-        else if (direction > 0 && current_position.z > Z_PROBE_OFFSET_RANGE_MAX) {
-          current_position.z = Z_PROBE_OFFSET_RANGE_MAX;
+        else if (direction > 0 && current_position.z > PROBE_OFFSET_ZMAX) {
+          current_position.z = PROBE_OFFSET_ZMAX;
           drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
         }
         else
           drawMessage_P(NUL_STR); // Clear the error
 
         drawAxisValue(axis);
       #endif
     }
 
   #endif // HAS_BED_PROBE

commit 2a88e7600298fef27e8cbbe01b708959515677fb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Oct 25 19:41:32 2023 -0500

    üßë‚Äçüíª Misc. LCD / string updates

diff --git a/Marlin/src/lcd/tft/ui_common.cpp b/Marlin/src/lcd/tft/ui_common.cpp
index d4d398b935..3426abab0e 100644
--- a/Marlin/src/lcd/tft/ui_common.cpp
+++ b/Marlin/src/lcd/tft/ui_common.cpp
@@ -309,28 +309,28 @@ void lcd_put_int(const int i) {
   // 3 digits max for this one...
   const char* str = i16tostr3left(int16_t(i));
   lcd_put_u8str_max(str, 3);
 }
 
 //
 // Menu Item methods
 //
 
 // Draw a generic menu item with pre_char (if selected) and post_char
-void MenuItemBase::_draw(const bool sel, const uint8_t row, FSTR_P const fstr, const char pre_char, const char post_char) {
+void MenuItemBase::_draw(const bool sel, const uint8_t row, FSTR_P const ftpl, const char pre_char, const char post_char) {
   menu_item(row, sel);
 
-  const char *string = FTOP(fstr);
+  const char *string = FTOP(ftpl);
   MarlinImage image = noImage;
   switch (*string) {
-    case 0x01: image = imgRefresh; break;  // LCD_STR_REFRESH
-    case 0x02: image = imgDirectory; break;  // LCD_STR_FOLDER
+    case LCD_STR_REFRESH[0]: image = imgRefresh; break;
+    case LCD_STR_FOLDER[0]: image = imgDirectory; break;
   }
 
   uint8_t offset = MENU_TEXT_X;
   if (image != noImage) {
     string++;
     offset = MENU_ITEM_ICON_SPACE;
     tft.add_image(MENU_ITEM_ICON_X, MENU_ITEM_ICON_Y, image, COLOR_MENU_TEXT, sel ? COLOR_SELECTION_BG : COLOR_BACKGROUND);
   }
 
   tft_string.set(string, itemIndex, itemStringC, itemStringF);
@@ -347,21 +347,24 @@ void MenuEditItemBase::draw(const bool sel, const uint8_t row, FSTR_P const ftpl
   if (inStr) {
     tft_string.set(inStr);
     tft.add_text(TFT_WIDTH - MENU_TEXT_X - tft_string.width(), MENU_TEXT_Y, COLOR_MENU_VALUE, tft_string);
   }
 }
 
 // Draw a static item with no left-right margin required. Centered by default.
 void MenuItem_static::draw(const uint8_t row, FSTR_P const ftpl, const uint8_t style/*=SS_DEFAULT*/, const char *vstr/*=nullptr*/) {
   menu_item(row);
 
-  tft_string.set(ftpl, itemIndex, itemStringC, itemStringF);
+  if (ftpl)
+    tft_string.set(ftpl, itemIndex, itemStringC, itemStringF);
+  else
+    tft_string.set();
 
   const bool center = bool(style & SS_CENTER), full = bool(style & SS_FULL);
   if (!full || !vstr) {
     if (vstr) tft_string.add(vstr);
     tft.add_text(center ? tft_string.center(TFT_WIDTH) : 0, MENU_TEXT_Y, COLOR_MENU_TEXT, tft_string);
     return;
   }
 
   // Move the leading colon from the value to the label
   if (*vstr == ':') { tft_string.add(':'); vstr++; }

commit b0ece8f8df130709f97da6c1474cd20cbd9119ed
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Oct 20 17:21:30 2023 -0500

    üßë‚Äçüíª MarlinUI menu tweaks
    
    Changes in prep for #26339

diff --git a/Marlin/src/lcd/tft/ui_common.cpp b/Marlin/src/lcd/tft/ui_common.cpp
index 5f426294dc..d4d398b935 100644
--- a/Marlin/src/lcd/tft/ui_common.cpp
+++ b/Marlin/src/lcd/tft/ui_common.cpp
@@ -332,36 +332,36 @@ void MenuItemBase::_draw(const bool sel, const uint8_t row, FSTR_P const fstr, c
     offset = MENU_ITEM_ICON_SPACE;
     tft.add_image(MENU_ITEM_ICON_X, MENU_ITEM_ICON_Y, image, COLOR_MENU_TEXT, sel ? COLOR_SELECTION_BG : COLOR_BACKGROUND);
   }
 
   tft_string.set(string, itemIndex, itemStringC, itemStringF);
 
   tft.add_text(offset, MENU_TEXT_Y, COLOR_MENU_TEXT, tft_string);
 }
 
 // Draw a menu item with a (potentially) editable value
-void MenuEditItemBase::draw(const bool sel, const uint8_t row, FSTR_P const fstr, const char * const inStr, const bool pgm) {
+void MenuEditItemBase::draw(const bool sel, const uint8_t row, FSTR_P const ftpl, const char * const inStr, const bool pgm) {
   menu_item(row, sel);
 
-  tft_string.set(fstr, itemIndex, itemStringC, itemStringF);
+  tft_string.set(ftpl, itemIndex, itemStringC, itemStringF);
   tft.add_text(MENU_TEXT_X, MENU_TEXT_Y, COLOR_MENU_TEXT, tft_string);
   if (inStr) {
     tft_string.set(inStr);
     tft.add_text(TFT_WIDTH - MENU_TEXT_X - tft_string.width(), MENU_TEXT_Y, COLOR_MENU_VALUE, tft_string);
   }
 }
 
 // Draw a static item with no left-right margin required. Centered by default.
-void MenuItem_static::draw(const uint8_t row, FSTR_P const fstr, const uint8_t style/*=SS_DEFAULT*/, const char *vstr/*=nullptr*/) {
+void MenuItem_static::draw(const uint8_t row, FSTR_P const ftpl, const uint8_t style/*=SS_DEFAULT*/, const char *vstr/*=nullptr*/) {
   menu_item(row);
 
-  tft_string.set(fstr, itemIndex, itemStringC, itemStringF);
+  tft_string.set(ftpl, itemIndex, itemStringC, itemStringF);
 
   const bool center = bool(style & SS_CENTER), full = bool(style & SS_FULL);
   if (!full || !vstr) {
     if (vstr) tft_string.add(vstr);
     tft.add_text(center ? tft_string.center(TFT_WIDTH) : 0, MENU_TEXT_Y, COLOR_MENU_TEXT, tft_string);
     return;
   }
 
   // Move the leading colon from the value to the label
   if (*vstr == ':') { tft_string.add(':'); vstr++; }

commit a0e3dea8b879aba8e0d2d7e4dc6a6447b3fe76ad
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jul 20 20:25:39 2023 -0500

    üö∏ ColorUI Touch Calibrate in CW order

diff --git a/Marlin/src/lcd/tft/ui_common.cpp b/Marlin/src/lcd/tft/ui_common.cpp
index 09364d846b..5f426294dc 100644
--- a/Marlin/src/lcd/tft/ui_common.cpp
+++ b/Marlin/src/lcd/tft/ui_common.cpp
@@ -433,34 +433,34 @@ void MarlinUI::clear_lcd() {
     uint16_t x, y;
 
     calibrationState stage = touch_calibration.get_calibration_state();
 
     if (stage == CALIBRATION_NONE) {
       defer_status_screen(true);
       clear_lcd();
       stage = touch_calibration.calibration_start();
     }
     else {
-      x = touch_calibration.calibration_points[_MIN(stage - 1, CALIBRATION_BOTTOM_RIGHT)].x;
-      y = touch_calibration.calibration_points[_MIN(stage - 1, CALIBRATION_BOTTOM_RIGHT)].y;
+      x = touch_calibration.calibration_points[_MIN(stage - 1, CALIBRATION_BOTTOM_LEFT)].x;
+      y = touch_calibration.calibration_points[_MIN(stage - 1, CALIBRATION_BOTTOM_LEFT)].y;
       tft.canvas(x - 15, y - 15, 31, 31);
       tft.set_background(COLOR_BACKGROUND);
     }
 
     touch.clear();
 
     if (stage < CALIBRATION_SUCCESS) {
       switch (stage) {
-        case CALIBRATION_TOP_LEFT: tft_string.set(GET_TEXT(MSG_TOP_LEFT)); break;
-        case CALIBRATION_BOTTOM_LEFT: tft_string.set(GET_TEXT(MSG_BOTTOM_LEFT)); break;
-        case CALIBRATION_TOP_RIGHT: tft_string.set(GET_TEXT(MSG_TOP_RIGHT)); break;
+        case CALIBRATION_TOP_LEFT:     tft_string.set(GET_TEXT(MSG_TOP_LEFT));     break;
+        case CALIBRATION_TOP_RIGHT:    tft_string.set(GET_TEXT(MSG_TOP_RIGHT));    break;
         case CALIBRATION_BOTTOM_RIGHT: tft_string.set(GET_TEXT(MSG_BOTTOM_RIGHT)); break;
+        case CALIBRATION_BOTTOM_LEFT:  tft_string.set(GET_TEXT(MSG_BOTTOM_LEFT));  break;
         default: break;
       }
 
       x = touch_calibration.calibration_points[stage].x;
       y = touch_calibration.calibration_points[stage].y;
 
       tft.canvas(x - 15, y - 15, 31, 31);
       tft.set_background(COLOR_BACKGROUND);
       tft.add_bar(0, 15, 31, 1, COLOR_TOUCH_CALIBRATION);
       tft.add_bar(15, 0, 1, 31, COLOR_TOUCH_CALIBRATION);

commit 244de2458ac6fd48f3031d0179ca1bcad6808583
Author: Alexander Gavrilenko <jmz52@users.noreply.github.com>
Date:   Mon Jul 17 10:53:36 2023 +0300

    üßë‚Äçüíª Improve TFT Color UI layout / theme (#26077)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/tft/ui_common.cpp b/Marlin/src/lcd/tft/ui_common.cpp
index 962daadb19..09364d846b 100644
--- a/Marlin/src/lcd/tft/ui_common.cpp
+++ b/Marlin/src/lcd/tft/ui_common.cpp
@@ -21,102 +21,289 @@
  */
 
 #include "../../inc/MarlinConfigPre.h"
 
 #if HAS_GRAPHICAL_TFT
 
 #include "ui_common.h"
 #include "../lcdprint.h"
 #include "../../libs/numtostr.h"
 #include "../menu/menu.h"
+#include "../../gcode/queue.h"
+#include "../../module/temperature.h"
+#include "../../module/planner.h"
+#include "../../module/probe.h"
 
-void menu_pause_option();
+#if ENABLED(BABYSTEP_ZPROBE_OFFSET)
+  #include "../../feature/babystep.h"
+#endif
 
+motionAxisState_t motionAxisState;
 static xy_uint_t cursor;
-
 #if ENABLED(TOUCH_SCREEN)
   bool draw_menu_navigation = false;
 #endif
 
+void menu_pause_option();
+
+void quick_feedback() {
+  #if HAS_CHIRP
+    ui.chirp(); // Buzz and wait. Is the delay needed for buttons to settle?
+    #if ALL(HAS_MARLINUI_MENU, HAS_BEEPER)
+      for (int8_t i = 5; i--;) { buzzer.tick(); delay(2); }
+    #elif HAS_MARLINUI_MENU
+      delay(10);
+    #endif
+  #endif
+}
+
+void disable_steppers() {
+  quick_feedback();
+  queue.inject(F("M84"));
+}
+
+void moveAxis(const AxisEnum axis, const int8_t direction) {
+  quick_feedback();
+
+  #if HAS_EXTRUDERS
+    if (axis == E_AXIS && thermalManager.tooColdToExtrude(motionAxisState.e_selection)) {
+      drawMessage(F("Too cold"));
+      return;
+    }
+  #endif
+
+  const float diff = motionAxisState.currentStepSize * direction;
+
+  #if HAS_BED_PROBE
+
+    if (axis == Z_AXIS && motionAxisState.z_selection == Z_SELECTION_Z_PROBE) {
+      #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
+        const int16_t babystep_increment = direction * BABYSTEP_SIZE_Z;
+        const bool do_probe = DISABLED(BABYSTEP_HOTEND_Z_OFFSET) || active_extruder == 0;
+        const float bsDiff = planner.mm_per_step[Z_AXIS] * babystep_increment,
+                    new_probe_offset = probe.offset.z + bsDiff,
+                    new_offs = TERN(BABYSTEP_HOTEND_Z_OFFSET
+                      , do_probe ? new_probe_offset : hotend_offset[active_extruder].z - bsDiff
+                      , new_probe_offset
+                    );
+        if (WITHIN(new_offs, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
+          babystep.add_steps(Z_AXIS, babystep_increment);
+          if (do_probe)
+            probe.offset.z = new_offs;
+          else
+            TERN(BABYSTEP_HOTEND_Z_OFFSET, hotend_offset[active_extruder].z = new_offs, NOOP);
+          drawMessage_P(NUL_STR); // Clear the error
+          drawAxisValue(axis);
+        }
+        else
+          drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
+
+      #else
+        // Only change probe.offset.z
+        probe.offset.z += diff;
+        if (direction < 0 && current_position.z < Z_PROBE_OFFSET_RANGE_MIN) {
+          current_position.z = Z_PROBE_OFFSET_RANGE_MIN;
+          drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
+        }
+        else if (direction > 0 && current_position.z > Z_PROBE_OFFSET_RANGE_MAX) {
+          current_position.z = Z_PROBE_OFFSET_RANGE_MAX;
+          drawMessage(GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS));
+        }
+        else
+          drawMessage_P(NUL_STR); // Clear the error
+
+        drawAxisValue(axis);
+      #endif
+    }
+
+  #endif // HAS_BED_PROBE
+
+  if (!ui.manual_move.processing) {
+    // Get motion limit from software endstops, if any
+    float min, max;
+    soft_endstop.get_manual_axis_limits(axis, min, max);
+
+    // Delta limits XY based on the current offset from center
+    // This assumes the center is 0,0
+    #if ENABLED(DELTA)
+      if (axis != Z_AXIS && TERN1(HAS_EXTRUDERS, axis != E_AXIS)) {
+        max = SQRT(sq(float(PRINTABLE_RADIUS)) - sq(current_position[Y_AXIS - axis])); // (Y_AXIS - axis) == the other axis
+        min = -max;
+      }
+    #endif
+
+    // Get the new position
+    const bool limited = ui.manual_move.apply_diff(axis, diff, min, max);
+    #if IS_KINEMATIC
+      UNUSED(limited);
+    #else
+      FSTR_P const msg = limited ? GET_TEXT_F(MSG_LCD_SOFT_ENDSTOPS) : FPSTR(NUL_STR);
+      drawMessage(msg);
+    #endif
+
+    ui.manual_move.soon(axis OPTARG(MULTI_E_MANUAL, motionAxisState.e_selection));
+  }
+
+  drawAxisValue(axis);
+}
+
+#if ENABLED(TOUCH_SCREEN)
+
+  void do_home() {
+    quick_feedback();
+    drawMessage(GET_TEXT_F(MSG_LEVEL_BED_HOMING));
+    queue.inject_P(G28_STR);
+    // Disable touch until home is done
+    touch.disable();
+    TERN_(HAS_EXTRUDERS, drawAxisValue(E_AXIS));
+    TERN_(HAS_X_AXIS,    drawAxisValue(X_AXIS));
+    TERN_(HAS_Y_AXIS,    drawAxisValue(Y_AXIS));
+    TERN_(HAS_Z_AXIS,    drawAxisValue(Z_AXIS));
+  }
+
+  void step_size() {
+    motionAxisState.currentStepSize = motionAxisState.currentStepSize / 10.0;
+    if (motionAxisState.currentStepSize < 0.0015) motionAxisState.currentStepSize = 10.0;
+    quick_feedback();
+    drawCurStepValue();
+  }
+
+  #if HAS_EXTRUDERS
+    void e_select() {
+      if (++motionAxisState.e_selection >= EXTRUDERS)
+        motionAxisState.e_selection = 0;
+      quick_feedback();
+      drawCurESelection();
+      drawAxisValue(E_AXIS);
+    }
+  #endif
+
+  #if HAS_BED_PROBE
+    void z_select() {
+      motionAxisState.z_selection *= -1;
+      quick_feedback();
+      drawCurZSelection();
+      drawAxisValue(Z_AXIS);
+    }
+  #endif
+
+#endif
+
 #if HAS_TOUCH_SLEEP
 
   bool lcd_sleep_task() {
     static bool sleepCleared;
     if (touch.isSleeping()) {
       tft.queue.reset();
       if (!sleepCleared) {
         sleepCleared = true;
         ui.clear_lcd();
         tft.queue.async();
       }
       touch.idle();
       return true;
     }
     else
       sleepCleared = false;
     return false;
   }
 
-#endif
+#endif // HAS_TOUCH_SLEEP
+
+void text_line(const uint16_t y, uint16_t color) {
+  tft.canvas(0, y, TFT_WIDTH, MENU_ITEM_HEIGHT);
+  tft.set_background(color);
+}
 
 void menu_line(const uint8_t row, uint16_t color) {
   cursor.set(0, row);
-  tft.canvas(0, TFT_TOP_LINE_Y + cursor.y * MENU_LINE_HEIGHT, TFT_WIDTH, MENU_ITEM_HEIGHT);
-  tft.set_background(color);
+  text_line(MENU_TOP_LINE_Y + cursor.y * MENU_LINE_HEIGHT, color);
 }
 
 void menu_item(const uint8_t row, bool sel ) {
   #if ENABLED(TOUCH_SCREEN)
     if (row == 0) {
       touch.clear();
       draw_menu_navigation = TERN(ADVANCED_PAUSE_FEATURE, ui.currentScreen != menu_pause_option, true);
     }
   #endif
 
   menu_line(row, sel ? COLOR_SELECTION_BG : COLOR_BACKGROUND);
   #if ENABLED(TOUCH_SCREEN)
     const TouchControlType tct = TERN(SINGLE_TOUCH_NAVIGATION, true, sel) ? MENU_CLICK : MENU_ITEM;
-    touch.add_control(tct, 0, TFT_TOP_LINE_Y + row * MENU_LINE_HEIGHT, TFT_WIDTH, MENU_ITEM_HEIGHT, encoderTopLine + row);
+    touch.add_control(tct, 0, MENU_TOP_LINE_Y + row * MENU_LINE_HEIGHT, TFT_WIDTH, MENU_ITEM_HEIGHT, encoderTopLine + row);
+  #endif
+}
+
+void add_control(uint16_t x, uint16_t y, TouchControlType control_type, intptr_t data, MarlinImage image, bool is_enabled, uint16_t color_enabled, uint16_t color_disabled) {
+  const uint16_t width = images[image].width, height = images[image].height;
+  tft.canvas(x, y, width, height);
+  tft.add_image(0, 0, image, is_enabled ? color_enabled : color_disabled);
+  #if ENABLED(TOUCH_SCREEN)
+    if (is_enabled) touch.add_control(control_type, x, y, width, height, data);
   #endif
 }
 
+void drawBtn(const int x, const int y, const char *label, intptr_t data, const MarlinImage btnimg, const MarlinImage img, uint16_t bgColor, const bool enabled) {
+  const uint16_t width = images[btnimg].width,
+                height = images[btnimg].height;
+
+  if (!enabled) bgColor = COLOR_CONTROL_DISABLED;
+
+  tft.canvas(x, y, width, height);
+  tft.set_background(COLOR_BACKGROUND);
+  tft.add_image(0, 0, btnimg, bgColor, COLOR_BACKGROUND, COLOR_DARKGREY);
+
+  // TODO: Make an add_text() taking a font arg
+  if (label) {
+    tft_string.set(label);
+    tft_string.trim();
+    tft.add_text(tft_string.center(width), height / 2 - tft_string.font_height() / 2, bgColor, tft_string);
+  }
+  else
+    tft.add_image(0, 0, img, bgColor, COLOR_BACKGROUND, COLOR_DARKGREY);
+
+  TERN_(TOUCH_SCREEN, if (enabled) touch.add_control(BUTTON, x, y, width, height, data));
+}
+
+
 //
 // lcdprint.h functions
 //
 
 #define TFT_COL_WIDTH ((TFT_WIDTH) / (LCD_WIDTH))
 
 void lcd_gotopixel(const uint16_t x, const uint16_t y) {
   if (x >= TFT_WIDTH) return;
   cursor.set(x / (TFT_COL_WIDTH), y / MENU_LINE_HEIGHT);
-  tft.canvas(x, TFT_TOP_LINE_Y + y, (TFT_WIDTH) - x, MENU_ITEM_HEIGHT);
+  tft.canvas(x, MENU_TOP_LINE_Y + y, (TFT_WIDTH) - x, MENU_ITEM_HEIGHT);
   tft.set_background(COLOR_BACKGROUND);
 }
 
 void lcd_moveto(const lcd_uint_t col, const lcd_uint_t row) {
   lcd_gotopixel(int(col) * (TFT_COL_WIDTH), int(row) * MENU_LINE_HEIGHT);
 }
 
 int lcd_put_lchar_max(const lchar_t &c, const pixel_len_t max_length) {
   if (max_length < 1) return 0;
   tft_string.set(c);
-  tft.add_text(MENU_TEXT_X_OFFSET, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
+  tft.add_text(MENU_TEXT_X, MENU_TEXT_Y, COLOR_MENU_TEXT, tft_string);
   lcd_gotopixel((cursor.x + 1) * (TFT_COL_WIDTH) + tft_string.width(), cursor.y * MENU_LINE_HEIGHT);
   return tft_string.width();
 }
 
 int lcd_put_u8str_max_P(PGM_P utf8_pstr, const pixel_len_t max_length) {
   if (max_length < 1) return 0;
   tft_string.set(utf8_pstr);
   tft_string.trim();
   tft_string.truncate(max_length);
-  tft.add_text(MENU_TEXT_X_OFFSET, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
+  tft.add_text(MENU_TEXT_X, MENU_TEXT_Y, COLOR_MENU_TEXT, tft_string);
   lcd_gotopixel((cursor.x + 1) * (TFT_COL_WIDTH) + tft_string.width(), cursor.y * MENU_LINE_HEIGHT);
   return tft_string.width();
 }
 
 int lcd_put_u8str_max(const char * utf8_str, const pixel_len_t max_length) {
   return lcd_put_u8str_max_P(utf8_str, max_length);
 }
 
 void lcd_put_int(const int i) {
   // 3 digits max for this one...
@@ -132,76 +319,76 @@ void lcd_put_int(const int i) {
 void MenuItemBase::_draw(const bool sel, const uint8_t row, FSTR_P const fstr, const char pre_char, const char post_char) {
   menu_item(row, sel);
 
   const char *string = FTOP(fstr);
   MarlinImage image = noImage;
   switch (*string) {
     case 0x01: image = imgRefresh; break;  // LCD_STR_REFRESH
     case 0x02: image = imgDirectory; break;  // LCD_STR_FOLDER
   }
 
-  uint8_t offset = MENU_TEXT_X_OFFSET;
+  uint8_t offset = MENU_TEXT_X;
   if (image != noImage) {
     string++;
     offset = MENU_ITEM_ICON_SPACE;
     tft.add_image(MENU_ITEM_ICON_X, MENU_ITEM_ICON_Y, image, COLOR_MENU_TEXT, sel ? COLOR_SELECTION_BG : COLOR_BACKGROUND);
   }
 
   tft_string.set(string, itemIndex, itemStringC, itemStringF);
 
-  tft.add_text(offset, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
+  tft.add_text(offset, MENU_TEXT_Y, COLOR_MENU_TEXT, tft_string);
 }
 
 // Draw a menu item with a (potentially) editable value
 void MenuEditItemBase::draw(const bool sel, const uint8_t row, FSTR_P const fstr, const char * const inStr, const bool pgm) {
   menu_item(row, sel);
 
   tft_string.set(fstr, itemIndex, itemStringC, itemStringF);
-  tft.add_text(MENU_TEXT_X_OFFSET, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
+  tft.add_text(MENU_TEXT_X, MENU_TEXT_Y, COLOR_MENU_TEXT, tft_string);
   if (inStr) {
     tft_string.set(inStr);
-    tft.add_text(TFT_WIDTH - MENU_TEXT_X_OFFSET - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
+    tft.add_text(TFT_WIDTH - MENU_TEXT_X - tft_string.width(), MENU_TEXT_Y, COLOR_MENU_VALUE, tft_string);
   }
 }
 
 // Draw a static item with no left-right margin required. Centered by default.
 void MenuItem_static::draw(const uint8_t row, FSTR_P const fstr, const uint8_t style/*=SS_DEFAULT*/, const char *vstr/*=nullptr*/) {
   menu_item(row);
 
   tft_string.set(fstr, itemIndex, itemStringC, itemStringF);
 
   const bool center = bool(style & SS_CENTER), full = bool(style & SS_FULL);
   if (!full || !vstr) {
     if (vstr) tft_string.add(vstr);
-    tft.add_text(center ? tft_string.center(TFT_WIDTH) : 0, MENU_TEXT_Y_OFFSET, COLOR_YELLOW, tft_string);
+    tft.add_text(center ? tft_string.center(TFT_WIDTH) : 0, MENU_TEXT_Y, COLOR_MENU_TEXT, tft_string);
     return;
   }
 
   // Move the leading colon from the value to the label
   if (*vstr == ':') { tft_string.add(':'); vstr++; }
 
   // Left-justified label
-  tft.add_text(0, MENU_TEXT_Y_OFFSET, COLOR_YELLOW, tft_string);
+  tft.add_text(0, MENU_TEXT_Y, COLOR_MENU_TEXT, tft_string);
 
   // Right-justified value, after spaces
   while (*vstr == ' ') vstr++;
   tft_string.set(vstr);
-  tft.add_text(TFT_WIDTH - 1 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_YELLOW, tft_string);
+  tft.add_text(TFT_WIDTH - 1 - tft_string.width(), MENU_TEXT_Y, COLOR_MENU_TEXT, tft_string);
 }
 
 #if HAS_MEDIA
 
   void MenuItem_sdbase::draw(const bool sel, const uint8_t row, FSTR_P const, CardReader &theCard, const bool isDir) {
     menu_item(row, sel);
     if (isDir) tft.add_image(MENU_ITEM_ICON_X, MENU_ITEM_ICON_Y, imgDirectory, COLOR_MENU_TEXT, sel ? COLOR_SELECTION_BG : COLOR_BACKGROUND);
-    uint8_t maxlen = (MENU_ITEM_HEIGHT) - (MENU_TEXT_Y_OFFSET) + 1;
-    tft.add_text(MENU_ITEM_ICON_SPACE, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, ui.scrolled_filename(theCard, maxlen, row, sel));
+    uint8_t maxlen = (MENU_ITEM_HEIGHT) - (MENU_TEXT_Y) + 1;
+    tft.add_text(MENU_ITEM_ICON_SPACE, MENU_TEXT_Y, COLOR_MENU_TEXT, ui.scrolled_filename(theCard, maxlen, row, sel));
   }
 
 #endif
 
 //
 // MarlinUI methods
 //
 
 bool MarlinUI::detected() { return true; }
 

commit 5664c02d077e028f84a24efd96c2eebe97ce8763
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 22 22:43:09 2023 -0500

    üßë‚Äçüíª Generalize SDSUPPORT as HAS_MEDIA
    
    In preparation for single- and multi-volume refactoring.

diff --git a/Marlin/src/lcd/tft/ui_common.cpp b/Marlin/src/lcd/tft/ui_common.cpp
index 6dee62820e..962daadb19 100644
--- a/Marlin/src/lcd/tft/ui_common.cpp
+++ b/Marlin/src/lcd/tft/ui_common.cpp
@@ -181,21 +181,21 @@ void MenuItem_static::draw(const uint8_t row, FSTR_P const fstr, const uint8_t s
 
   // Left-justified label
   tft.add_text(0, MENU_TEXT_Y_OFFSET, COLOR_YELLOW, tft_string);
 
   // Right-justified value, after spaces
   while (*vstr == ' ') vstr++;
   tft_string.set(vstr);
   tft.add_text(TFT_WIDTH - 1 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_YELLOW, tft_string);
 }
 
-#if ENABLED(SDSUPPORT)
+#if HAS_MEDIA
 
   void MenuItem_sdbase::draw(const bool sel, const uint8_t row, FSTR_P const, CardReader &theCard, const bool isDir) {
     menu_item(row, sel);
     if (isDir) tft.add_image(MENU_ITEM_ICON_X, MENU_ITEM_ICON_Y, imgDirectory, COLOR_MENU_TEXT, sel ? COLOR_SELECTION_BG : COLOR_BACKGROUND);
     uint8_t maxlen = (MENU_ITEM_HEIGHT) - (MENU_TEXT_Y_OFFSET) + 1;
     tft.add_text(MENU_ITEM_ICON_SPACE, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, ui.scrolled_filename(theCard, maxlen, row, sel));
   }
 
 #endif
 

commit 4233e4864f0c621612ce35a9b6ca882312e3aa4d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 22 01:56:10 2023 -0500

    üö∏ MarlinUI Endstop Test Screen, and more (#25667)

diff --git a/Marlin/src/lcd/tft/ui_common.cpp b/Marlin/src/lcd/tft/ui_common.cpp
index 6fbde79154..6dee62820e 100644
--- a/Marlin/src/lcd/tft/ui_common.cpp
+++ b/Marlin/src/lcd/tft/ui_common.cpp
@@ -157,25 +157,42 @@ void MenuEditItemBase::draw(const bool sel, const uint8_t row, FSTR_P const fstr
 
   tft_string.set(fstr, itemIndex, itemStringC, itemStringF);
   tft.add_text(MENU_TEXT_X_OFFSET, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
   if (inStr) {
     tft_string.set(inStr);
     tft.add_text(TFT_WIDTH - MENU_TEXT_X_OFFSET - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
   }
 }
 
 // Draw a static item with no left-right margin required. Centered by default.
-void MenuItem_static::draw(const uint8_t row, FSTR_P const fstr, const uint8_t style/*=SS_DEFAULT*/, const char * const vstr/*=nullptr*/) {
+void MenuItem_static::draw(const uint8_t row, FSTR_P const fstr, const uint8_t style/*=SS_DEFAULT*/, const char *vstr/*=nullptr*/) {
   menu_item(row);
+
   tft_string.set(fstr, itemIndex, itemStringC, itemStringF);
-  if (vstr) tft_string.add(vstr);
-  tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_YELLOW, tft_string);
+
+  const bool center = bool(style & SS_CENTER), full = bool(style & SS_FULL);
+  if (!full || !vstr) {
+    if (vstr) tft_string.add(vstr);
+    tft.add_text(center ? tft_string.center(TFT_WIDTH) : 0, MENU_TEXT_Y_OFFSET, COLOR_YELLOW, tft_string);
+    return;
+  }
+
+  // Move the leading colon from the value to the label
+  if (*vstr == ':') { tft_string.add(':'); vstr++; }
+
+  // Left-justified label
+  tft.add_text(0, MENU_TEXT_Y_OFFSET, COLOR_YELLOW, tft_string);
+
+  // Right-justified value, after spaces
+  while (*vstr == ' ') vstr++;
+  tft_string.set(vstr);
+  tft.add_text(TFT_WIDTH - 1 - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_YELLOW, tft_string);
 }
 
 #if ENABLED(SDSUPPORT)
 
   void MenuItem_sdbase::draw(const bool sel, const uint8_t row, FSTR_P const, CardReader &theCard, const bool isDir) {
     menu_item(row, sel);
     if (isDir) tft.add_image(MENU_ITEM_ICON_X, MENU_ITEM_ICON_Y, imgDirectory, COLOR_MENU_TEXT, sel ? COLOR_SELECTION_BG : COLOR_BACKGROUND);
     uint8_t maxlen = (MENU_ITEM_HEIGHT) - (MENU_TEXT_Y_OFFSET) + 1;
     tft.add_text(MENU_ITEM_ICON_SPACE, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, ui.scrolled_filename(theCard, maxlen, row, sel));
   }

commit 17b43d6b3d10a816ba534547d37346888f3897b4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Mar 23 17:19:20 2023 -0500

    üé® calibration_stage => stage

diff --git a/Marlin/src/lcd/tft/ui_common.cpp b/Marlin/src/lcd/tft/ui_common.cpp
index 705438e95b..6fbde79154 100644
--- a/Marlin/src/lcd/tft/ui_common.cpp
+++ b/Marlin/src/lcd/tft/ui_common.cpp
@@ -221,57 +221,57 @@ void MarlinUI::clear_lcd() {
     #endif
   }
 
 #endif
 
 #if ENABLED(TOUCH_SCREEN_CALIBRATION)
 
   void MarlinUI::touch_calibration_screen() {
     uint16_t x, y;
 
-    calibrationState calibration_stage = touch_calibration.get_calibration_state();
+    calibrationState stage = touch_calibration.get_calibration_state();
 
-    if (calibration_stage == CALIBRATION_NONE) {
+    if (stage == CALIBRATION_NONE) {
       defer_status_screen(true);
       clear_lcd();
-      calibration_stage = touch_calibration.calibration_start();
+      stage = touch_calibration.calibration_start();
     }
     else {
-      x = touch_calibration.calibration_points[_MIN(calibration_stage - 1, CALIBRATION_BOTTOM_RIGHT)].x;
-      y = touch_calibration.calibration_points[_MIN(calibration_stage - 1, CALIBRATION_BOTTOM_RIGHT)].y;
+      x = touch_calibration.calibration_points[_MIN(stage - 1, CALIBRATION_BOTTOM_RIGHT)].x;
+      y = touch_calibration.calibration_points[_MIN(stage - 1, CALIBRATION_BOTTOM_RIGHT)].y;
       tft.canvas(x - 15, y - 15, 31, 31);
       tft.set_background(COLOR_BACKGROUND);
     }
 
     touch.clear();
 
-    if (calibration_stage < CALIBRATION_SUCCESS) {
-      switch (calibration_stage) {
+    if (stage < CALIBRATION_SUCCESS) {
+      switch (stage) {
         case CALIBRATION_TOP_LEFT: tft_string.set(GET_TEXT(MSG_TOP_LEFT)); break;
         case CALIBRATION_BOTTOM_LEFT: tft_string.set(GET_TEXT(MSG_BOTTOM_LEFT)); break;
         case CALIBRATION_TOP_RIGHT: tft_string.set(GET_TEXT(MSG_TOP_RIGHT)); break;
         case CALIBRATION_BOTTOM_RIGHT: tft_string.set(GET_TEXT(MSG_BOTTOM_RIGHT)); break;
         default: break;
       }
 
-      x = touch_calibration.calibration_points[calibration_stage].x;
-      y = touch_calibration.calibration_points[calibration_stage].y;
+      x = touch_calibration.calibration_points[stage].x;
+      y = touch_calibration.calibration_points[stage].y;
 
       tft.canvas(x - 15, y - 15, 31, 31);
       tft.set_background(COLOR_BACKGROUND);
       tft.add_bar(0, 15, 31, 1, COLOR_TOUCH_CALIBRATION);
       tft.add_bar(15, 0, 1, 31, COLOR_TOUCH_CALIBRATION);
 
       touch.add_control(CALIBRATE, 0, 0, TFT_WIDTH, TFT_HEIGHT, uint32_t(x) << 16 | uint32_t(y));
     }
     else {
-      tft_string.set(calibration_stage == CALIBRATION_SUCCESS ? GET_TEXT(MSG_CALIBRATION_COMPLETED) : GET_TEXT(MSG_CALIBRATION_FAILED));
+      tft_string.set(stage == CALIBRATION_SUCCESS ? GET_TEXT(MSG_CALIBRATION_COMPLETED) : GET_TEXT(MSG_CALIBRATION_FAILED));
       defer_status_screen(false);
       touch_calibration.calibration_end();
       touch.add_control(BACK, 0, 0, TFT_WIDTH, TFT_HEIGHT);
     }
 
     tft.canvas(0, (TFT_HEIGHT - tft_string.font_height()) >> 1, TFT_WIDTH, tft_string.font_height());
     tft.set_background(COLOR_BACKGROUND);
     tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_MENU_TEXT, tft_string);
   }
 

commit fca1929beb6a5f7dd21d17bdefcbc97511869e27
Author: Alexander Gavrilenko <jmz52@users.noreply.github.com>
Date:   Sat Dec 31 08:44:55 2022 +0300

    ‚ú®‚ö°Ô∏è UTF support for TFT Color UI (#25073)

diff --git a/Marlin/src/lcd/tft/ui_common.cpp b/Marlin/src/lcd/tft/ui_common.cpp
index bb05785766..705438e95b 100644
--- a/Marlin/src/lcd/tft/ui_common.cpp
+++ b/Marlin/src/lcd/tft/ui_common.cpp
@@ -169,38 +169,41 @@ void MenuItem_static::draw(const uint8_t row, FSTR_P const fstr, const uint8_t s
   tft_string.set(fstr, itemIndex, itemStringC, itemStringF);
   if (vstr) tft_string.add(vstr);
   tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_YELLOW, tft_string);
 }
 
 #if ENABLED(SDSUPPORT)
 
   void MenuItem_sdbase::draw(const bool sel, const uint8_t row, FSTR_P const, CardReader &theCard, const bool isDir) {
     menu_item(row, sel);
     if (isDir) tft.add_image(MENU_ITEM_ICON_X, MENU_ITEM_ICON_Y, imgDirectory, COLOR_MENU_TEXT, sel ? COLOR_SELECTION_BG : COLOR_BACKGROUND);
-    constexpr uint8_t maxlen = (MENU_ITEM_HEIGHT) - (MENU_TEXT_Y_OFFSET) + 1;
+    uint8_t maxlen = (MENU_ITEM_HEIGHT) - (MENU_TEXT_Y_OFFSET) + 1;
     tft.add_text(MENU_ITEM_ICON_SPACE, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, ui.scrolled_filename(theCard, maxlen, row, sel));
   }
 
 #endif
 
 //
 // MarlinUI methods
 //
 
 bool MarlinUI::detected() { return true; }
 
 void MarlinUI::init_lcd() {
   tft.init();
   tft.set_font(MENU_FONT_NAME);
   #ifdef SYMBOLS_FONT_NAME
     tft.add_glyphs(SYMBOLS_FONT_NAME);
   #endif
+  #ifdef EXTRA_FONT_NAME
+    tft.add_glyphs(EXTRA_FONT_NAME);
+  #endif
   TERN_(TOUCH_SCREEN, touch.init());
   clear_lcd();
 }
 
 void MarlinUI::clear_lcd() {
   #if ENABLED(TOUCH_SCREEN)
     touch.reset();
     draw_menu_navigation = false;
   #endif
 

commit cb4a79173be3e8ed1ff45e7c346df1c28e744d5a
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jul 1 04:49:37 2022 -0500

    ü©π Remove poison wchar_t macro

diff --git a/Marlin/src/lcd/tft/ui_common.cpp b/Marlin/src/lcd/tft/ui_common.cpp
index c9e069dbbd..bb05785766 100644
--- a/Marlin/src/lcd/tft/ui_common.cpp
+++ b/Marlin/src/lcd/tft/ui_common.cpp
@@ -89,21 +89,21 @@ void lcd_gotopixel(const uint16_t x, const uint16_t y) {
   if (x >= TFT_WIDTH) return;
   cursor.set(x / (TFT_COL_WIDTH), y / MENU_LINE_HEIGHT);
   tft.canvas(x, TFT_TOP_LINE_Y + y, (TFT_WIDTH) - x, MENU_ITEM_HEIGHT);
   tft.set_background(COLOR_BACKGROUND);
 }
 
 void lcd_moveto(const lcd_uint_t col, const lcd_uint_t row) {
   lcd_gotopixel(int(col) * (TFT_COL_WIDTH), int(row) * MENU_LINE_HEIGHT);
 }
 
-int lcd_put_wchar_max(const wchar_t c, const pixel_len_t max_length) {
+int lcd_put_lchar_max(const lchar_t &c, const pixel_len_t max_length) {
   if (max_length < 1) return 0;
   tft_string.set(c);
   tft.add_text(MENU_TEXT_X_OFFSET, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
   lcd_gotopixel((cursor.x + 1) * (TFT_COL_WIDTH) + tft_string.width(), cursor.y * MENU_LINE_HEIGHT);
   return tft_string.width();
 }
 
 int lcd_put_u8str_max_P(PGM_P utf8_pstr, const pixel_len_t max_length) {
   if (max_length < 1) return 0;
   tft_string.set(utf8_pstr);

commit 8aca38351cd6d33a1202bf9a13890dc8e5eadd49
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 3 22:56:38 2022 -0500

    üßë‚Äçüíª Extend LCD string substitution (#24278)

diff --git a/Marlin/src/lcd/tft/ui_common.cpp b/Marlin/src/lcd/tft/ui_common.cpp
index 023ff59ca6..c9e069dbbd 100644
--- a/Marlin/src/lcd/tft/ui_common.cpp
+++ b/Marlin/src/lcd/tft/ui_common.cpp
@@ -89,91 +89,91 @@ void lcd_gotopixel(const uint16_t x, const uint16_t y) {
   if (x >= TFT_WIDTH) return;
   cursor.set(x / (TFT_COL_WIDTH), y / MENU_LINE_HEIGHT);
   tft.canvas(x, TFT_TOP_LINE_Y + y, (TFT_WIDTH) - x, MENU_ITEM_HEIGHT);
   tft.set_background(COLOR_BACKGROUND);
 }
 
 void lcd_moveto(const lcd_uint_t col, const lcd_uint_t row) {
   lcd_gotopixel(int(col) * (TFT_COL_WIDTH), int(row) * MENU_LINE_HEIGHT);
 }
 
-int lcd_put_wchar_max(wchar_t c, pixel_len_t max_length) {
+int lcd_put_wchar_max(const wchar_t c, const pixel_len_t max_length) {
   if (max_length < 1) return 0;
-  tft_string.set();
-  tft_string.add(c);
+  tft_string.set(c);
   tft.add_text(MENU_TEXT_X_OFFSET, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
   lcd_gotopixel((cursor.x + 1) * (TFT_COL_WIDTH) + tft_string.width(), cursor.y * MENU_LINE_HEIGHT);
   return tft_string.width();
 }
 
-int lcd_put_u8str_max_P(PGM_P utf8_pstr, pixel_len_t max_length) {
+int lcd_put_u8str_max_P(PGM_P utf8_pstr, const pixel_len_t max_length) {
   if (max_length < 1) return 0;
   tft_string.set(utf8_pstr);
   tft_string.trim();
   tft_string.truncate(max_length);
   tft.add_text(MENU_TEXT_X_OFFSET, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
   lcd_gotopixel((cursor.x + 1) * (TFT_COL_WIDTH) + tft_string.width(), cursor.y * MENU_LINE_HEIGHT);
   return tft_string.width();
 }
 
-int lcd_put_u8str_max(const char * utf8_str, pixel_len_t max_length) {
+int lcd_put_u8str_max(const char * utf8_str, const pixel_len_t max_length) {
   return lcd_put_u8str_max_P(utf8_str, max_length);
 }
 
 void lcd_put_int(const int i) {
   // 3 digits max for this one...
   const char* str = i16tostr3left(int16_t(i));
   lcd_put_u8str_max(str, 3);
 }
 
 //
 // Menu Item methods
 //
 
 // Draw a generic menu item with pre_char (if selected) and post_char
 void MenuItemBase::_draw(const bool sel, const uint8_t row, FSTR_P const fstr, const char pre_char, const char post_char) {
   menu_item(row, sel);
 
-  uint8_t *string = (uint8_t *)FTOP(fstr);
+  const char *string = FTOP(fstr);
   MarlinImage image = noImage;
   switch (*string) {
     case 0x01: image = imgRefresh; break;  // LCD_STR_REFRESH
     case 0x02: image = imgDirectory; break;  // LCD_STR_FOLDER
   }
 
   uint8_t offset = MENU_TEXT_X_OFFSET;
   if (image != noImage) {
     string++;
     offset = MENU_ITEM_ICON_SPACE;
     tft.add_image(MENU_ITEM_ICON_X, MENU_ITEM_ICON_Y, image, COLOR_MENU_TEXT, sel ? COLOR_SELECTION_BG : COLOR_BACKGROUND);
   }
 
-  tft_string.set(string, itemIndex, FTOP(itemString));
+  tft_string.set(string, itemIndex, itemStringC, itemStringF);
+
   tft.add_text(offset, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
 }
 
 // Draw a menu item with a (potentially) editable value
-void MenuEditItemBase::draw(const bool sel, const uint8_t row, FSTR_P const fstr, const char * const data, const bool pgm) {
+void MenuEditItemBase::draw(const bool sel, const uint8_t row, FSTR_P const fstr, const char * const inStr, const bool pgm) {
   menu_item(row, sel);
 
-  tft_string.set(FTOP(fstr), itemIndex, FTOP(itemString));
+  tft_string.set(fstr, itemIndex, itemStringC, itemStringF);
   tft.add_text(MENU_TEXT_X_OFFSET, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
-  if (data) {
-    tft_string.set(data);
+  if (inStr) {
+    tft_string.set(inStr);
     tft.add_text(TFT_WIDTH - MENU_TEXT_X_OFFSET - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
   }
 }
 
 // Draw a static item with no left-right margin required. Centered by default.
 void MenuItem_static::draw(const uint8_t row, FSTR_P const fstr, const uint8_t style/*=SS_DEFAULT*/, const char * const vstr/*=nullptr*/) {
   menu_item(row);
-  tft_string.set(FTOP(fstr), itemIndex, FTOP(itemString));
+  tft_string.set(fstr, itemIndex, itemStringC, itemStringF);
   if (vstr) tft_string.add(vstr);
   tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_YELLOW, tft_string);
 }
 
 #if ENABLED(SDSUPPORT)
 
   void MenuItem_sdbase::draw(const bool sel, const uint8_t row, FSTR_P const, CardReader &theCard, const bool isDir) {
     menu_item(row, sel);
     if (isDir) tft.add_image(MENU_ITEM_ICON_X, MENU_ITEM_ICON_Y, imgDirectory, COLOR_MENU_TEXT, sel ? COLOR_SELECTION_BG : COLOR_BACKGROUND);
     constexpr uint8_t maxlen = (MENU_ITEM_HEIGHT) - (MENU_TEXT_Y_OFFSET) + 1;

commit a5e1d4c50ae40c8203d8490be83ef86e16ebf1c2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 22 19:56:46 2022 -0500

    ‚ôªÔ∏è Apply F() to more LCD code (#24228)

diff --git a/Marlin/src/lcd/tft/ui_common.cpp b/Marlin/src/lcd/tft/ui_common.cpp
index acc91f51fa..023ff59ca6 100644
--- a/Marlin/src/lcd/tft/ui_common.cpp
+++ b/Marlin/src/lcd/tft/ui_common.cpp
@@ -123,64 +123,64 @@ void lcd_put_int(const int i) {
   // 3 digits max for this one...
   const char* str = i16tostr3left(int16_t(i));
   lcd_put_u8str_max(str, 3);
 }
 
 //
 // Menu Item methods
 //
 
 // Draw a generic menu item with pre_char (if selected) and post_char
-void MenuItemBase::_draw(const bool sel, const uint8_t row, PGM_P const pstr, const char pre_char, const char post_char) {
+void MenuItemBase::_draw(const bool sel, const uint8_t row, FSTR_P const fstr, const char pre_char, const char post_char) {
   menu_item(row, sel);
 
-  uint8_t *string = (uint8_t *)pstr;
+  uint8_t *string = (uint8_t *)FTOP(fstr);
   MarlinImage image = noImage;
   switch (*string) {
     case 0x01: image = imgRefresh; break;  // LCD_STR_REFRESH
     case 0x02: image = imgDirectory; break;  // LCD_STR_FOLDER
   }
 
   uint8_t offset = MENU_TEXT_X_OFFSET;
   if (image != noImage) {
     string++;
     offset = MENU_ITEM_ICON_SPACE;
     tft.add_image(MENU_ITEM_ICON_X, MENU_ITEM_ICON_Y, image, COLOR_MENU_TEXT, sel ? COLOR_SELECTION_BG : COLOR_BACKGROUND);
   }
 
-  tft_string.set(string, itemIndex, itemString);
+  tft_string.set(string, itemIndex, FTOP(itemString));
   tft.add_text(offset, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
 }
 
 // Draw a menu item with a (potentially) editable value
-void MenuEditItemBase::draw(const bool sel, const uint8_t row, PGM_P const pstr, const char * const data, const bool pgm) {
+void MenuEditItemBase::draw(const bool sel, const uint8_t row, FSTR_P const fstr, const char * const data, const bool pgm) {
   menu_item(row, sel);
 
-  tft_string.set(pstr, itemIndex, itemString);
+  tft_string.set(FTOP(fstr), itemIndex, FTOP(itemString));
   tft.add_text(MENU_TEXT_X_OFFSET, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
   if (data) {
     tft_string.set(data);
     tft.add_text(TFT_WIDTH - MENU_TEXT_X_OFFSET - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
   }
 }
 
 // Draw a static item with no left-right margin required. Centered by default.
-void MenuItem_static::draw(const uint8_t row, PGM_P const pstr, const uint8_t style/*=SS_DEFAULT*/, const char * const vstr/*=nullptr*/) {
+void MenuItem_static::draw(const uint8_t row, FSTR_P const fstr, const uint8_t style/*=SS_DEFAULT*/, const char * const vstr/*=nullptr*/) {
   menu_item(row);
-  tft_string.set(pstr, itemIndex, itemString);
+  tft_string.set(FTOP(fstr), itemIndex, FTOP(itemString));
   if (vstr) tft_string.add(vstr);
   tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_YELLOW, tft_string);
 }
 
 #if ENABLED(SDSUPPORT)
 
-  void MenuItem_sdbase::draw(const bool sel, const uint8_t row, PGM_P const, CardReader &theCard, const bool isDir) {
+  void MenuItem_sdbase::draw(const bool sel, const uint8_t row, FSTR_P const, CardReader &theCard, const bool isDir) {
     menu_item(row, sel);
     if (isDir) tft.add_image(MENU_ITEM_ICON_X, MENU_ITEM_ICON_Y, imgDirectory, COLOR_MENU_TEXT, sel ? COLOR_SELECTION_BG : COLOR_BACKGROUND);
     constexpr uint8_t maxlen = (MENU_ITEM_HEIGHT) - (MENU_TEXT_Y_OFFSET) + 1;
     tft.add_text(MENU_ITEM_ICON_SPACE, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, ui.scrolled_filename(theCard, maxlen, row, sel));
   }
 
 #endif
 
 //
 // MarlinUI methods

commit a9dc737624cf45bceff1866ce4807bb2cc36ac44
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Thu Nov 4 18:04:04 2021 +0100

    üêõ Fix TFT backlight [STM32] (#23062)

diff --git a/Marlin/src/lcd/tft/ui_common.cpp b/Marlin/src/lcd/tft/ui_common.cpp
index 85ae21e867..acc91f51fa 100644
--- a/Marlin/src/lcd/tft/ui_common.cpp
+++ b/Marlin/src/lcd/tft/ui_common.cpp
@@ -203,26 +203,28 @@ void MarlinUI::clear_lcd() {
     touch.reset();
     draw_menu_navigation = false;
   #endif
 
   tft.queue.reset();
   tft.fill(0, 0, TFT_WIDTH, TFT_HEIGHT, COLOR_BACKGROUND);
   cursor.set(0, 0);
 }
 
 #if HAS_LCD_BRIGHTNESS
+
   void MarlinUI::_set_brightness() {
     #if PIN_EXISTS(TFT_BACKLIGHT)
       if (PWM_PIN(TFT_BACKLIGHT_PIN))
-        set_pwm_duty(pin_t(TFT_BACKLIGHT_PIN), brightness);
+        analogWrite(pin_t(TFT_BACKLIGHT_PIN), backlight ? brightness : 0);
     #endif
   }
+
 #endif
 
 #if ENABLED(TOUCH_SCREEN_CALIBRATION)
 
   void MarlinUI::touch_calibration_screen() {
     uint16_t x, y;
 
     calibrationState calibration_stage = touch_calibration.get_calibration_state();
 
     if (calibration_stage == CALIBRATION_NONE) {

commit da830e6ced7f7c7e509e748104245064d1c1b265
Author: Andrei M <22990561+andrei-moraru@users.noreply.github.com>
Date:   Tue Nov 2 01:47:16 2021 -0400

    ‚öóÔ∏è Use pwm_set_duty over analogWrite to set PWM (#23048)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/tft/ui_common.cpp b/Marlin/src/lcd/tft/ui_common.cpp
index 8c503d2c9e..85ae21e867 100644
--- a/Marlin/src/lcd/tft/ui_common.cpp
+++ b/Marlin/src/lcd/tft/ui_common.cpp
@@ -206,21 +206,21 @@ void MarlinUI::clear_lcd() {
 
   tft.queue.reset();
   tft.fill(0, 0, TFT_WIDTH, TFT_HEIGHT, COLOR_BACKGROUND);
   cursor.set(0, 0);
 }
 
 #if HAS_LCD_BRIGHTNESS
   void MarlinUI::_set_brightness() {
     #if PIN_EXISTS(TFT_BACKLIGHT)
       if (PWM_PIN(TFT_BACKLIGHT_PIN))
-        analogWrite(pin_t(TFT_BACKLIGHT_PIN), brightness);
+        set_pwm_duty(pin_t(TFT_BACKLIGHT_PIN), brightness);
     #endif
   }
 #endif
 
 #if ENABLED(TOUCH_SCREEN_CALIBRATION)
 
   void MarlinUI::touch_calibration_screen() {
     uint16_t x, y;
 
     calibrationState calibration_stage = touch_calibration.get_calibration_state();

commit c0337da6334923ea7b65bcd4f9c1ea08c8b33cf2
Author: Zlopi <zlopi.ru@gmail.com>
Date:   Wed Oct 27 23:10:46 2021 +0300

    üö∏ Scroll long filename on MKS TFT (#23031)

diff --git a/Marlin/src/lcd/tft/ui_common.cpp b/Marlin/src/lcd/tft/ui_common.cpp
index e152ceab50..8c503d2c9e 100644
--- a/Marlin/src/lcd/tft/ui_common.cpp
+++ b/Marlin/src/lcd/tft/ui_common.cpp
@@ -160,32 +160,31 @@ void MenuEditItemBase::draw(const bool sel, const uint8_t row, PGM_P const pstr,
   if (data) {
     tft_string.set(data);
     tft.add_text(TFT_WIDTH - MENU_TEXT_X_OFFSET - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
   }
 }
 
 // Draw a static item with no left-right margin required. Centered by default.
 void MenuItem_static::draw(const uint8_t row, PGM_P const pstr, const uint8_t style/*=SS_DEFAULT*/, const char * const vstr/*=nullptr*/) {
   menu_item(row);
   tft_string.set(pstr, itemIndex, itemString);
-  if (vstr)
-    tft_string.add(vstr);
+  if (vstr) tft_string.add(vstr);
   tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_YELLOW, tft_string);
 }
 
 #if ENABLED(SDSUPPORT)
 
   void MenuItem_sdbase::draw(const bool sel, const uint8_t row, PGM_P const, CardReader &theCard, const bool isDir) {
     menu_item(row, sel);
-    if (isDir)
-      tft.add_image(MENU_ITEM_ICON_X, MENU_ITEM_ICON_Y, imgDirectory, COLOR_MENU_TEXT, sel ? COLOR_SELECTION_BG : COLOR_BACKGROUND);
-    tft.add_text(MENU_ITEM_ICON_SPACE, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, theCard.longest_filename());
+    if (isDir) tft.add_image(MENU_ITEM_ICON_X, MENU_ITEM_ICON_Y, imgDirectory, COLOR_MENU_TEXT, sel ? COLOR_SELECTION_BG : COLOR_BACKGROUND);
+    constexpr uint8_t maxlen = (MENU_ITEM_HEIGHT) - (MENU_TEXT_Y_OFFSET) + 1;
+    tft.add_text(MENU_ITEM_ICON_SPACE, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, ui.scrolled_filename(theCard, maxlen, row, sel));
   }
 
 #endif
 
 //
 // MarlinUI methods
 //
 
 bool MarlinUI::detected() { return true; }
 

commit eeffac697c5d7b69e01e38ed1602dbd21a366e93
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Sep 25 23:52:41 2021 -0500

    üé® Apply F() to UTF-8/MMU2 string put

diff --git a/Marlin/src/lcd/tft/ui_common.cpp b/Marlin/src/lcd/tft/ui_common.cpp
index 41862b5ad8..e152ceab50 100644
--- a/Marlin/src/lcd/tft/ui_common.cpp
+++ b/Marlin/src/lcd/tft/ui_common.cpp
@@ -98,23 +98,23 @@ void lcd_moveto(const lcd_uint_t col, const lcd_uint_t row) {
 
 int lcd_put_wchar_max(wchar_t c, pixel_len_t max_length) {
   if (max_length < 1) return 0;
   tft_string.set();
   tft_string.add(c);
   tft.add_text(MENU_TEXT_X_OFFSET, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
   lcd_gotopixel((cursor.x + 1) * (TFT_COL_WIDTH) + tft_string.width(), cursor.y * MENU_LINE_HEIGHT);
   return tft_string.width();
 }
 
-int lcd_put_u8str_max_P(PGM_P utf8_str_P, pixel_len_t max_length) {
+int lcd_put_u8str_max_P(PGM_P utf8_pstr, pixel_len_t max_length) {
   if (max_length < 1) return 0;
-  tft_string.set(utf8_str_P);
+  tft_string.set(utf8_pstr);
   tft_string.trim();
   tft_string.truncate(max_length);
   tft.add_text(MENU_TEXT_X_OFFSET, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
   lcd_gotopixel((cursor.x + 1) * (TFT_COL_WIDTH) + tft_string.width(), cursor.y * MENU_LINE_HEIGHT);
   return tft_string.width();
 }
 
 int lcd_put_u8str_max(const char * utf8_str, pixel_len_t max_length) {
   return lcd_put_u8str_max_P(utf8_str, max_length);
 }

commit f73175d8263033d1feb1045af67e7230c844aab0
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Mon Sep 27 21:01:47 2021 +0200

    üö∏ TFT backlight PWM / brightness (#22841)

diff --git a/Marlin/src/lcd/tft/ui_common.cpp b/Marlin/src/lcd/tft/ui_common.cpp
index a5f41874b0..41862b5ad8 100644
--- a/Marlin/src/lcd/tft/ui_common.cpp
+++ b/Marlin/src/lcd/tft/ui_common.cpp
@@ -203,20 +203,29 @@ void MarlinUI::clear_lcd() {
   #if ENABLED(TOUCH_SCREEN)
     touch.reset();
     draw_menu_navigation = false;
   #endif
 
   tft.queue.reset();
   tft.fill(0, 0, TFT_WIDTH, TFT_HEIGHT, COLOR_BACKGROUND);
   cursor.set(0, 0);
 }
 
+#if HAS_LCD_BRIGHTNESS
+  void MarlinUI::_set_brightness() {
+    #if PIN_EXISTS(TFT_BACKLIGHT)
+      if (PWM_PIN(TFT_BACKLIGHT_PIN))
+        analogWrite(pin_t(TFT_BACKLIGHT_PIN), brightness);
+    #endif
+  }
+#endif
+
 #if ENABLED(TOUCH_SCREEN_CALIBRATION)
 
   void MarlinUI::touch_calibration_screen() {
     uint16_t x, y;
 
     calibrationState calibration_stage = touch_calibration.get_calibration_state();
 
     if (calibration_stage == CALIBRATION_NONE) {
       defer_status_screen(true);
       clear_lcd();

commit c2e4b1626f0cce82a55e8de9dc98ed9381e1d9ad
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Tue Sep 14 04:07:08 2021 +0200

    ‚ú® TFT Screen/Backlight Sleep (#22617)

diff --git a/Marlin/src/lcd/tft/ui_common.cpp b/Marlin/src/lcd/tft/ui_common.cpp
index 7c053e7be7..a5f41874b0 100644
--- a/Marlin/src/lcd/tft/ui_common.cpp
+++ b/Marlin/src/lcd/tft/ui_common.cpp
@@ -30,20 +30,41 @@
 #include "../menu/menu.h"
 
 void menu_pause_option();
 
 static xy_uint_t cursor;
 
 #if ENABLED(TOUCH_SCREEN)
   bool draw_menu_navigation = false;
 #endif
 
+#if HAS_TOUCH_SLEEP
+
+  bool lcd_sleep_task() {
+    static bool sleepCleared;
+    if (touch.isSleeping()) {
+      tft.queue.reset();
+      if (!sleepCleared) {
+        sleepCleared = true;
+        ui.clear_lcd();
+        tft.queue.async();
+      }
+      touch.idle();
+      return true;
+    }
+    else
+      sleepCleared = false;
+    return false;
+  }
+
+#endif
+
 void menu_line(const uint8_t row, uint16_t color) {
   cursor.set(0, row);
   tft.canvas(0, TFT_TOP_LINE_Y + cursor.y * MENU_LINE_HEIGHT, TFT_WIDTH, MENU_ITEM_HEIGHT);
   tft.set_background(color);
 }
 
 void menu_item(const uint8_t row, bool sel ) {
   #if ENABLED(TOUCH_SCREEN)
     if (row == 0) {
       touch.clear();

commit 3b73b115ca9366f0155986b717d4c85c31ed2f80
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 29 20:36:37 2021 -0500

    Apply pointer formatting

diff --git a/Marlin/src/lcd/tft/ui_common.cpp b/Marlin/src/lcd/tft/ui_common.cpp
index 842fc3909c..7c053e7be7 100644
--- a/Marlin/src/lcd/tft/ui_common.cpp
+++ b/Marlin/src/lcd/tft/ui_common.cpp
@@ -124,21 +124,21 @@ void MenuItemBase::_draw(const bool sel, const uint8_t row, PGM_P const pstr, co
     string++;
     offset = MENU_ITEM_ICON_SPACE;
     tft.add_image(MENU_ITEM_ICON_X, MENU_ITEM_ICON_Y, image, COLOR_MENU_TEXT, sel ? COLOR_SELECTION_BG : COLOR_BACKGROUND);
   }
 
   tft_string.set(string, itemIndex, itemString);
   tft.add_text(offset, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
 }
 
 // Draw a menu item with a (potentially) editable value
-void MenuEditItemBase::draw(const bool sel, const uint8_t row, PGM_P const pstr, const char* const data, const bool pgm) {
+void MenuEditItemBase::draw(const bool sel, const uint8_t row, PGM_P const pstr, const char * const data, const bool pgm) {
   menu_item(row, sel);
 
   tft_string.set(pstr, itemIndex, itemString);
   tft.add_text(MENU_TEXT_X_OFFSET, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
   if (data) {
     tft_string.set(data);
     tft.add_text(TFT_WIDTH - MENU_TEXT_X_OFFSET - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
   }
 }
 

commit c12be1f98cf1efdc6fc1e66c528d5975adc6626c
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Mon Jan 25 08:44:39 2021 +0100

    Graphical TFT fixes, cleanup (#20861)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/tft/ui_common.cpp b/Marlin/src/lcd/tft/ui_common.cpp
new file mode 100644
index 0000000000..842fc3909c
--- /dev/null
+++ b/Marlin/src/lcd/tft/ui_common.cpp
@@ -0,0 +1,246 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "../../inc/MarlinConfigPre.h"
+
+#if HAS_GRAPHICAL_TFT
+
+#include "ui_common.h"
+#include "../lcdprint.h"
+#include "../../libs/numtostr.h"
+#include "../menu/menu.h"
+
+void menu_pause_option();
+
+static xy_uint_t cursor;
+
+#if ENABLED(TOUCH_SCREEN)
+  bool draw_menu_navigation = false;
+#endif
+
+void menu_line(const uint8_t row, uint16_t color) {
+  cursor.set(0, row);
+  tft.canvas(0, TFT_TOP_LINE_Y + cursor.y * MENU_LINE_HEIGHT, TFT_WIDTH, MENU_ITEM_HEIGHT);
+  tft.set_background(color);
+}
+
+void menu_item(const uint8_t row, bool sel ) {
+  #if ENABLED(TOUCH_SCREEN)
+    if (row == 0) {
+      touch.clear();
+      draw_menu_navigation = TERN(ADVANCED_PAUSE_FEATURE, ui.currentScreen != menu_pause_option, true);
+    }
+  #endif
+
+  menu_line(row, sel ? COLOR_SELECTION_BG : COLOR_BACKGROUND);
+  #if ENABLED(TOUCH_SCREEN)
+    const TouchControlType tct = TERN(SINGLE_TOUCH_NAVIGATION, true, sel) ? MENU_CLICK : MENU_ITEM;
+    touch.add_control(tct, 0, TFT_TOP_LINE_Y + row * MENU_LINE_HEIGHT, TFT_WIDTH, MENU_ITEM_HEIGHT, encoderTopLine + row);
+  #endif
+}
+
+//
+// lcdprint.h functions
+//
+
+#define TFT_COL_WIDTH ((TFT_WIDTH) / (LCD_WIDTH))
+
+void lcd_gotopixel(const uint16_t x, const uint16_t y) {
+  if (x >= TFT_WIDTH) return;
+  cursor.set(x / (TFT_COL_WIDTH), y / MENU_LINE_HEIGHT);
+  tft.canvas(x, TFT_TOP_LINE_Y + y, (TFT_WIDTH) - x, MENU_ITEM_HEIGHT);
+  tft.set_background(COLOR_BACKGROUND);
+}
+
+void lcd_moveto(const lcd_uint_t col, const lcd_uint_t row) {
+  lcd_gotopixel(int(col) * (TFT_COL_WIDTH), int(row) * MENU_LINE_HEIGHT);
+}
+
+int lcd_put_wchar_max(wchar_t c, pixel_len_t max_length) {
+  if (max_length < 1) return 0;
+  tft_string.set();
+  tft_string.add(c);
+  tft.add_text(MENU_TEXT_X_OFFSET, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
+  lcd_gotopixel((cursor.x + 1) * (TFT_COL_WIDTH) + tft_string.width(), cursor.y * MENU_LINE_HEIGHT);
+  return tft_string.width();
+}
+
+int lcd_put_u8str_max_P(PGM_P utf8_str_P, pixel_len_t max_length) {
+  if (max_length < 1) return 0;
+  tft_string.set(utf8_str_P);
+  tft_string.trim();
+  tft_string.truncate(max_length);
+  tft.add_text(MENU_TEXT_X_OFFSET, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
+  lcd_gotopixel((cursor.x + 1) * (TFT_COL_WIDTH) + tft_string.width(), cursor.y * MENU_LINE_HEIGHT);
+  return tft_string.width();
+}
+
+int lcd_put_u8str_max(const char * utf8_str, pixel_len_t max_length) {
+  return lcd_put_u8str_max_P(utf8_str, max_length);
+}
+
+void lcd_put_int(const int i) {
+  // 3 digits max for this one...
+  const char* str = i16tostr3left(int16_t(i));
+  lcd_put_u8str_max(str, 3);
+}
+
+//
+// Menu Item methods
+//
+
+// Draw a generic menu item with pre_char (if selected) and post_char
+void MenuItemBase::_draw(const bool sel, const uint8_t row, PGM_P const pstr, const char pre_char, const char post_char) {
+  menu_item(row, sel);
+
+  uint8_t *string = (uint8_t *)pstr;
+  MarlinImage image = noImage;
+  switch (*string) {
+    case 0x01: image = imgRefresh; break;  // LCD_STR_REFRESH
+    case 0x02: image = imgDirectory; break;  // LCD_STR_FOLDER
+  }
+
+  uint8_t offset = MENU_TEXT_X_OFFSET;
+  if (image != noImage) {
+    string++;
+    offset = MENU_ITEM_ICON_SPACE;
+    tft.add_image(MENU_ITEM_ICON_X, MENU_ITEM_ICON_Y, image, COLOR_MENU_TEXT, sel ? COLOR_SELECTION_BG : COLOR_BACKGROUND);
+  }
+
+  tft_string.set(string, itemIndex, itemString);
+  tft.add_text(offset, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
+}
+
+// Draw a menu item with a (potentially) editable value
+void MenuEditItemBase::draw(const bool sel, const uint8_t row, PGM_P const pstr, const char* const data, const bool pgm) {
+  menu_item(row, sel);
+
+  tft_string.set(pstr, itemIndex, itemString);
+  tft.add_text(MENU_TEXT_X_OFFSET, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, tft_string);
+  if (data) {
+    tft_string.set(data);
+    tft.add_text(TFT_WIDTH - MENU_TEXT_X_OFFSET - tft_string.width(), MENU_TEXT_Y_OFFSET, COLOR_MENU_VALUE, tft_string);
+  }
+}
+
+// Draw a static item with no left-right margin required. Centered by default.
+void MenuItem_static::draw(const uint8_t row, PGM_P const pstr, const uint8_t style/*=SS_DEFAULT*/, const char * const vstr/*=nullptr*/) {
+  menu_item(row);
+  tft_string.set(pstr, itemIndex, itemString);
+  if (vstr)
+    tft_string.add(vstr);
+  tft.add_text(tft_string.center(TFT_WIDTH), MENU_TEXT_Y_OFFSET, COLOR_YELLOW, tft_string);
+}
+
+#if ENABLED(SDSUPPORT)
+
+  void MenuItem_sdbase::draw(const bool sel, const uint8_t row, PGM_P const, CardReader &theCard, const bool isDir) {
+    menu_item(row, sel);
+    if (isDir)
+      tft.add_image(MENU_ITEM_ICON_X, MENU_ITEM_ICON_Y, imgDirectory, COLOR_MENU_TEXT, sel ? COLOR_SELECTION_BG : COLOR_BACKGROUND);
+    tft.add_text(MENU_ITEM_ICON_SPACE, MENU_TEXT_Y_OFFSET, COLOR_MENU_TEXT, theCard.longest_filename());
+  }
+
+#endif
+
+//
+// MarlinUI methods
+//
+
+bool MarlinUI::detected() { return true; }
+
+void MarlinUI::init_lcd() {
+  tft.init();
+  tft.set_font(MENU_FONT_NAME);
+  #ifdef SYMBOLS_FONT_NAME
+    tft.add_glyphs(SYMBOLS_FONT_NAME);
+  #endif
+  TERN_(TOUCH_SCREEN, touch.init());
+  clear_lcd();
+}
+
+void MarlinUI::clear_lcd() {
+  #if ENABLED(TOUCH_SCREEN)
+    touch.reset();
+    draw_menu_navigation = false;
+  #endif
+
+  tft.queue.reset();
+  tft.fill(0, 0, TFT_WIDTH, TFT_HEIGHT, COLOR_BACKGROUND);
+  cursor.set(0, 0);
+}
+
+#if ENABLED(TOUCH_SCREEN_CALIBRATION)
+
+  void MarlinUI::touch_calibration_screen() {
+    uint16_t x, y;
+
+    calibrationState calibration_stage = touch_calibration.get_calibration_state();
+
+    if (calibration_stage == CALIBRATION_NONE) {
+      defer_status_screen(true);
+      clear_lcd();
+      calibration_stage = touch_calibration.calibration_start();
+    }
+    else {
+      x = touch_calibration.calibration_points[_MIN(calibration_stage - 1, CALIBRATION_BOTTOM_RIGHT)].x;
+      y = touch_calibration.calibration_points[_MIN(calibration_stage - 1, CALIBRATION_BOTTOM_RIGHT)].y;
+      tft.canvas(x - 15, y - 15, 31, 31);
+      tft.set_background(COLOR_BACKGROUND);
+    }
+
+    touch.clear();
+
+    if (calibration_stage < CALIBRATION_SUCCESS) {
+      switch (calibration_stage) {
+        case CALIBRATION_TOP_LEFT: tft_string.set(GET_TEXT(MSG_TOP_LEFT)); break;
+        case CALIBRATION_BOTTOM_LEFT: tft_string.set(GET_TEXT(MSG_BOTTOM_LEFT)); break;
+        case CALIBRATION_TOP_RIGHT: tft_string.set(GET_TEXT(MSG_TOP_RIGHT)); break;
+        case CALIBRATION_BOTTOM_RIGHT: tft_string.set(GET_TEXT(MSG_BOTTOM_RIGHT)); break;
+        default: break;
+      }
+
+      x = touch_calibration.calibration_points[calibration_stage].x;
+      y = touch_calibration.calibration_points[calibration_stage].y;
+
+      tft.canvas(x - 15, y - 15, 31, 31);
+      tft.set_background(COLOR_BACKGROUND);
+      tft.add_bar(0, 15, 31, 1, COLOR_TOUCH_CALIBRATION);
+      tft.add_bar(15, 0, 1, 31, COLOR_TOUCH_CALIBRATION);
+
+      touch.add_control(CALIBRATE, 0, 0, TFT_WIDTH, TFT_HEIGHT, uint32_t(x) << 16 | uint32_t(y));
+    }
+    else {
+      tft_string.set(calibration_stage == CALIBRATION_SUCCESS ? GET_TEXT(MSG_CALIBRATION_COMPLETED) : GET_TEXT(MSG_CALIBRATION_FAILED));
+      defer_status_screen(false);
+      touch_calibration.calibration_end();
+      touch.add_control(BACK, 0, 0, TFT_WIDTH, TFT_HEIGHT);
+    }
+
+    tft.canvas(0, (TFT_HEIGHT - tft_string.font_height()) >> 1, TFT_WIDTH, tft_string.font_height());
+    tft.set_background(COLOR_BACKGROUND);
+    tft.add_text(tft_string.center(TFT_WIDTH), 0, COLOR_MENU_TEXT, tft_string);
+  }
+
+#endif // TOUCH_SCREEN_CALIBRATION
+
+#endif // HAS_GRAPHICAL_TFT
