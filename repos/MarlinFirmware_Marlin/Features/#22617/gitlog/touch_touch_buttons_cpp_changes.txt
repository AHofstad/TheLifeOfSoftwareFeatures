commit 1dee4d92c61b14458cd394d1f609f0dc80282092
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Feb 4 12:09:08 2024 -0600

    🔧 TOUCH_IDLE_SLEEP_MINS => DISPLAY_SLEEP_MINUTES
    
    Follow up to #26517

diff --git a/Marlin/src/lcd/touch/touch_buttons.cpp b/Marlin/src/lcd/touch/touch_buttons.cpp
index 652a043714..f6f4c66e77 100644
--- a/Marlin/src/lcd/touch/touch_buttons.cpp
+++ b/Marlin/src/lcd/touch/touch_buttons.cpp
@@ -30,57 +30,59 @@
 #if ENABLED(TFT_TOUCH_DEVICE_GT911)
   #include HAL_PATH(../.., tft/gt911.h)
   GT911 touchIO;
 #elif ENABLED(TFT_TOUCH_DEVICE_XPT2046)
   #include HAL_PATH(../.., tft/xpt2046.h)
   XPT2046 touchIO;
 #else
   #error "Unknown Touch Screen Type."
 #endif
 
-#if HAS_TOUCH_SLEEP
+#if HAS_DISPLAY_SLEEP
   millis_t TouchButtons::next_sleep_ms;
 #endif
 
 #include "../buttons.h" // For EN_C bit mask
 #include "../marlinui.h" // For ui.refresh
 #include "../tft_io/tft_io.h"
 #include "../tft_io/touch_calibration.h"
 
 #define DOGM_AREA_LEFT   TFT_PIXEL_OFFSET_X
 #define DOGM_AREA_TOP    TFT_PIXEL_OFFSET_Y
 #define DOGM_AREA_WIDTH  (GRAPHICAL_TFT_UPSCALE) * (LCD_PIXEL_WIDTH)
 #define DOGM_AREA_HEIGHT (GRAPHICAL_TFT_UPSCALE) * (LCD_PIXEL_HEIGHT)
 
 #define BUTTON_AREA_TOP BUTTON_Y_LO
 #define BUTTON_AREA_BOT BUTTON_Y_HI
 
 TouchButtons touchBt;
 
 void TouchButtons::init() {
   touchIO.init();
-  TERN_(HAS_TOUCH_SLEEP, next_sleep_ms = millis() + SEC_TO_MS(ui.sleep_timeout_minutes * 60));
+  #if HAS_DISPLAY_SLEEP
+    next_sleep_ms = ui.sleep_timeout_minutes ? millis() + MIN_TO_MS(ui.sleep_timeout_minutes) : 0;
+  #endif
 }
 
 uint8_t TouchButtons::read_buttons() {
   #if HAS_WIRED_LCD
     int16_t x, y;
 
     #if ENABLED(TFT_TOUCH_DEVICE_XPT2046)
 
       const bool is_touched = TOUCH_PORTRAIT == _TOUCH_ORIENTATION
                                 ? touchIO.getRawPoint(&y, &x)
                                 : touchIO.getRawPoint(&x, &y);
-      #if HAS_TOUCH_SLEEP
+      #if HAS_DISPLAY_SLEEP
         if (is_touched)
           wakeUp();
-        else if (!isSleeping() && ELAPSED(millis(), next_sleep_ms) && ui.on_status_screen())
+        else if (next_sleep_ms && !isSleeping() && ELAPSED(millis(), next_sleep_ms) && ui.on_status_screen())
           sleepTimeout();
       #endif
 
       #if ENABLED(TOUCH_SCREEN_CALIBRATION)
         static bool no_touch = false;
       #endif
 
       if (!is_touched) {
         TERN_(TOUCH_SCREEN_CALIBRATION, no_touch = false);
         return 0;
@@ -122,34 +124,39 @@ uint8_t TouchButtons::read_buttons() {
     // Column and row above BUTTON_AREA_TOP
     int8_t col = (x - (DOGM_AREA_LEFT)) * (LCD_WIDTH)  / (DOGM_AREA_WIDTH),
            row = (y - (DOGM_AREA_TOP))  * (LCD_HEIGHT) / (DOGM_AREA_HEIGHT);
 
     // Send the touch to the UI (which will simulate the encoder wheel)
     MarlinUI::screen_click(row, col, x, y);
   #endif
   return 0;
 }
 
-#if HAS_TOUCH_SLEEP
+#if HAS_DISPLAY_SLEEP
 
   void TouchButtons::sleepTimeout() {
     #if HAS_LCD_BRIGHTNESS
       ui.set_brightness(0);
     #elif PIN_EXISTS(TFT_BACKLIGHT)
       WRITE(TFT_BACKLIGHT_PIN, LOW);
     #endif
     next_sleep_ms = TSLP_SLEEPING;
   }
+
   void TouchButtons::wakeUp() {
     if (isSleeping()) {
       #if HAS_LCD_BRIGHTNESS
         ui.set_brightness(ui.brightness);
       #elif PIN_EXISTS(TFT_BACKLIGHT)
         WRITE(TFT_BACKLIGHT_PIN, HIGH);
       #endif
     }
-    next_sleep_ms = millis() + MIN_TO_MS(ui.sleep_timeout_minutes);
+    next_sleep_ms = ui.sleep_timeout_minutes ? millis() + MIN_TO_MS(ui.sleep_timeout_minutes) : 0;
+  }
+
+  void MarlinUI::sleep_display(const bool sleep/*=true*/) {
+    if (!sleep) touchBt.wakeUp();
   }
 
-#endif // HAS_TOUCH_SLEEP
+#endif // HAS_DISPLAY_SLEEP
 
 #endif // HAS_TOUCH_BUTTONS

commit 06710e54de8c83af77a4f57d458f6463fbfcad93
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Wed Dec 13 00:33:03 2023 -0500

    ✨ EDITABLE_DISPLAY_TIMEOUT (#26517)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/touch/touch_buttons.cpp b/Marlin/src/lcd/touch/touch_buttons.cpp
index 7d31b21c04..652a043714 100644
--- a/Marlin/src/lcd/touch/touch_buttons.cpp
+++ b/Marlin/src/lcd/touch/touch_buttons.cpp
@@ -140,16 +140,16 @@ uint8_t TouchButtons::read_buttons() {
     next_sleep_ms = TSLP_SLEEPING;
   }
   void TouchButtons::wakeUp() {
     if (isSleeping()) {
       #if HAS_LCD_BRIGHTNESS
         ui.set_brightness(ui.brightness);
       #elif PIN_EXISTS(TFT_BACKLIGHT)
         WRITE(TFT_BACKLIGHT_PIN, HIGH);
       #endif
     }
-    next_sleep_ms = millis() + SEC_TO_MS(ui.sleep_timeout_minutes * 60);
+    next_sleep_ms = millis() + MIN_TO_MS(ui.sleep_timeout_minutes);
   }
 
 #endif // HAS_TOUCH_SLEEP
 
 #endif // HAS_TOUCH_BUTTONS

commit 3d8e3c3c9a2e955b7075783b8a95c3526b2936a5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Nov 30 16:25:11 2023 -0600

    🐛 Touch fixes (#26455)

diff --git a/Marlin/src/lcd/touch/touch_buttons.cpp b/Marlin/src/lcd/touch/touch_buttons.cpp
index 636a31dafa..7d31b21c04 100644
--- a/Marlin/src/lcd/touch/touch_buttons.cpp
+++ b/Marlin/src/lcd/touch/touch_buttons.cpp
@@ -59,20 +59,21 @@ TouchButtons touchBt;
 void TouchButtons::init() {
   touchIO.init();
   TERN_(HAS_TOUCH_SLEEP, next_sleep_ms = millis() + SEC_TO_MS(ui.sleep_timeout_minutes * 60));
 }
 
 uint8_t TouchButtons::read_buttons() {
   #if HAS_WIRED_LCD
     int16_t x, y;
 
     #if ENABLED(TFT_TOUCH_DEVICE_XPT2046)
+
       const bool is_touched = TOUCH_PORTRAIT == _TOUCH_ORIENTATION
                                 ? touchIO.getRawPoint(&y, &x)
                                 : touchIO.getRawPoint(&x, &y);
       #if HAS_TOUCH_SLEEP
         if (is_touched)
           wakeUp();
         else if (!isSleeping() && ELAPSED(millis(), next_sleep_ms) && ui.on_status_screen())
           sleepTimeout();
       #endif
 
@@ -81,27 +82,30 @@ uint8_t TouchButtons::read_buttons() {
       #endif
 
       if (!is_touched) {
         TERN_(TOUCH_SCREEN_CALIBRATION, no_touch = false);
         return 0;
       }
 
       #if ENABLED(TOUCH_SCREEN_CALIBRATION)
         const calibrationState state = touch_calibration.get_calibration_state();
         if (WITHIN(state, CALIBRATION_TOP_LEFT, CALIBRATION_BOTTOM_LEFT)) {
-          if (!no_touch && touch_calibration.handleTouch(xy_int_t({x, y}))) ui.refresh();
+          if (!no_touch && touch_calibration.handleTouch(x, y)) ui.refresh();
           no_touch = true;
           return 0;
         }
+        x = int16_t((int32_t(x) * _TOUCH_CALIBRATION_X) >> 16) + _TOUCH_OFFSET_X;
+        y = int16_t((int32_t(y) * _TOUCH_CALIBRATION_Y) >> 16) + _TOUCH_OFFSET_Y;
+      #else
+        x = uint16_t((uint32_t(x) * _TOUCH_CALIBRATION_X) >> 16) + _TOUCH_OFFSET_X;
+        y = uint16_t((uint32_t(y) * _TOUCH_CALIBRATION_Y) >> 16) + _TOUCH_OFFSET_Y;
       #endif
-      x = uint16_t((uint32_t(x) * _TOUCH_CALIBRATION_X) >> 16) + _TOUCH_OFFSET_X;
-      y = uint16_t((uint32_t(y) * _TOUCH_CALIBRATION_Y) >> 16) + _TOUCH_OFFSET_Y;
 
     #elif ENABLED(TFT_TOUCH_DEVICE_GT911)
 
       const bool is_touched = TOUCH_PORTRAIT == _TOUCH_ORIENTATION ? touchIO.getRawPoint(&y, &x) : touchIO.getRawPoint(&x, &y);
       if (!is_touched) return 0;
 
     #endif
 
     // Touch within the button area simulates an encoder button
     if (y > BUTTON_AREA_TOP && y < BUTTON_AREA_BOT)

commit 376673df284333ed499dd6a1e8ab52c317d2af73
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Nov 20 00:53:35 2023 -0600

    🚸 Minor touch calibration improvement (#26445)

diff --git a/Marlin/src/lcd/touch/touch_buttons.cpp b/Marlin/src/lcd/touch/touch_buttons.cpp
index 1ae5397b2e..636a31dafa 100644
--- a/Marlin/src/lcd/touch/touch_buttons.cpp
+++ b/Marlin/src/lcd/touch/touch_buttons.cpp
@@ -30,31 +30,28 @@
 #if ENABLED(TFT_TOUCH_DEVICE_GT911)
   #include HAL_PATH(../.., tft/gt911.h)
   GT911 touchIO;
 #elif ENABLED(TFT_TOUCH_DEVICE_XPT2046)
   #include HAL_PATH(../.., tft/xpt2046.h)
   XPT2046 touchIO;
 #else
   #error "Unknown Touch Screen Type."
 #endif
 
-#if ENABLED(TOUCH_SCREEN_CALIBRATION)
-  #include "../tft_io/touch_calibration.h"
-#endif
-
 #if HAS_TOUCH_SLEEP
   millis_t TouchButtons::next_sleep_ms;
 #endif
 
 #include "../buttons.h" // For EN_C bit mask
 #include "../marlinui.h" // For ui.refresh
 #include "../tft_io/tft_io.h"
+#include "../tft_io/touch_calibration.h"
 
 #define DOGM_AREA_LEFT   TFT_PIXEL_OFFSET_X
 #define DOGM_AREA_TOP    TFT_PIXEL_OFFSET_Y
 #define DOGM_AREA_WIDTH  (GRAPHICAL_TFT_UPSCALE) * (LCD_PIXEL_WIDTH)
 #define DOGM_AREA_HEIGHT (GRAPHICAL_TFT_UPSCALE) * (LCD_PIXEL_HEIGHT)
 
 #define BUTTON_AREA_TOP BUTTON_Y_LO
 #define BUTTON_AREA_BOT BUTTON_Y_HI
 
 TouchButtons touchBt;
@@ -62,44 +59,55 @@ TouchButtons touchBt;
 void TouchButtons::init() {
   touchIO.init();
   TERN_(HAS_TOUCH_SLEEP, next_sleep_ms = millis() + SEC_TO_MS(ui.sleep_timeout_minutes * 60));
 }
 
 uint8_t TouchButtons::read_buttons() {
   #if HAS_WIRED_LCD
     int16_t x, y;
 
     #if ENABLED(TFT_TOUCH_DEVICE_XPT2046)
-      const bool is_touched = (TERN(TOUCH_SCREEN_CALIBRATION, touch_calibration.calibration.orientation, TOUCH_ORIENTATION) == TOUCH_PORTRAIT ? touchIO.getRawPoint(&y, &x) : touchIO.getRawPoint(&x, &y));
+      const bool is_touched = TOUCH_PORTRAIT == _TOUCH_ORIENTATION
+                                ? touchIO.getRawPoint(&y, &x)
+                                : touchIO.getRawPoint(&x, &y);
       #if HAS_TOUCH_SLEEP
         if (is_touched)
           wakeUp();
         else if (!isSleeping() && ELAPSED(millis(), next_sleep_ms) && ui.on_status_screen())
           sleepTimeout();
       #endif
-      if (!is_touched) return 0;
+
+      #if ENABLED(TOUCH_SCREEN_CALIBRATION)
+        static bool no_touch = false;
+      #endif
+
+      if (!is_touched) {
+        TERN_(TOUCH_SCREEN_CALIBRATION, no_touch = false);
+        return 0;
+      }
 
       #if ENABLED(TOUCH_SCREEN_CALIBRATION)
         const calibrationState state = touch_calibration.get_calibration_state();
         if (WITHIN(state, CALIBRATION_TOP_LEFT, CALIBRATION_BOTTOM_LEFT)) {
-          if (touch_calibration.handleTouch(x, y)) ui.refresh();
+          if (!no_touch && touch_calibration.handleTouch(xy_int_t({x, y}))) ui.refresh();
+          no_touch = true;
           return 0;
         }
-        x = int16_t((int32_t(x) * touch_calibration.calibration.x) >> 16) + touch_calibration.calibration.offset_x;
-        y = int16_t((int32_t(y) * touch_calibration.calibration.y) >> 16) + touch_calibration.calibration.offset_y;
-      #else
-        x = uint16_t((uint32_t(x) * TOUCH_CALIBRATION_X) >> 16) + TOUCH_OFFSET_X;
-        y = uint16_t((uint32_t(y) * TOUCH_CALIBRATION_Y) >> 16) + TOUCH_OFFSET_Y;
       #endif
+      x = uint16_t((uint32_t(x) * _TOUCH_CALIBRATION_X) >> 16) + _TOUCH_OFFSET_X;
+      y = uint16_t((uint32_t(y) * _TOUCH_CALIBRATION_Y) >> 16) + _TOUCH_OFFSET_Y;
+
     #elif ENABLED(TFT_TOUCH_DEVICE_GT911)
-      const bool is_touched = (TOUCH_ORIENTATION == TOUCH_PORTRAIT ? touchIO.getPoint(&y, &x) : touchIO.getPoint(&x, &y));
+
+      const bool is_touched = TOUCH_PORTRAIT == _TOUCH_ORIENTATION ? touchIO.getRawPoint(&y, &x) : touchIO.getRawPoint(&x, &y);
       if (!is_touched) return 0;
+
     #endif
 
     // Touch within the button area simulates an encoder button
     if (y > BUTTON_AREA_TOP && y < BUTTON_AREA_BOT)
       return WITHIN(x, BUTTOND_X_LO, BUTTOND_X_HI) ? EN_D
            : WITHIN(x, BUTTONA_X_LO, BUTTONA_X_HI) ? EN_A
            : WITHIN(x, BUTTONB_X_LO, BUTTONB_X_HI) ? EN_B
            : WITHIN(x, BUTTONC_X_LO, BUTTONC_X_HI) ? EN_C
            : 0;
 

commit a0e3dea8b879aba8e0d2d7e4dc6a6447b3fe76ad
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jul 20 20:25:39 2023 -0500

    🚸 ColorUI Touch Calibrate in CW order

diff --git a/Marlin/src/lcd/touch/touch_buttons.cpp b/Marlin/src/lcd/touch/touch_buttons.cpp
index 856594c31a..1ae5397b2e 100644
--- a/Marlin/src/lcd/touch/touch_buttons.cpp
+++ b/Marlin/src/lcd/touch/touch_buttons.cpp
@@ -73,21 +73,21 @@ uint8_t TouchButtons::read_buttons() {
       #if HAS_TOUCH_SLEEP
         if (is_touched)
           wakeUp();
         else if (!isSleeping() && ELAPSED(millis(), next_sleep_ms) && ui.on_status_screen())
           sleepTimeout();
       #endif
       if (!is_touched) return 0;
 
       #if ENABLED(TOUCH_SCREEN_CALIBRATION)
         const calibrationState state = touch_calibration.get_calibration_state();
-        if (WITHIN(state, CALIBRATION_TOP_LEFT, CALIBRATION_BOTTOM_RIGHT)) {
+        if (WITHIN(state, CALIBRATION_TOP_LEFT, CALIBRATION_BOTTOM_LEFT)) {
           if (touch_calibration.handleTouch(x, y)) ui.refresh();
           return 0;
         }
         x = int16_t((int32_t(x) * touch_calibration.calibration.x) >> 16) + touch_calibration.calibration.offset_x;
         y = int16_t((int32_t(y) * touch_calibration.calibration.y) >> 16) + touch_calibration.calibration.offset_y;
       #else
         x = uint16_t((uint32_t(x) * TOUCH_CALIBRATION_X) >> 16) + TOUCH_OFFSET_X;
         y = uint16_t((uint32_t(y) * TOUCH_CALIBRATION_Y) >> 16) + TOUCH_OFFSET_Y;
       #endif
     #elif ENABLED(TFT_TOUCH_DEVICE_GT911)

commit c3694f1c038fa20ad749118b0a1c7aa88e3dd5f2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jun 14 17:24:50 2023 -0500

    🎨 Lowercase methods, functions, data members (#25939)
    
    For: TFT, DGUS, MarlinUI, Anycubic, JyersUI, CrealityUI

diff --git a/Marlin/src/lcd/touch/touch_buttons.cpp b/Marlin/src/lcd/touch/touch_buttons.cpp
index 2e996f30ce..856594c31a 100644
--- a/Marlin/src/lcd/touch/touch_buttons.cpp
+++ b/Marlin/src/lcd/touch/touch_buttons.cpp
@@ -53,21 +53,21 @@
 #define DOGM_AREA_TOP    TFT_PIXEL_OFFSET_Y
 #define DOGM_AREA_WIDTH  (GRAPHICAL_TFT_UPSCALE) * (LCD_PIXEL_WIDTH)
 #define DOGM_AREA_HEIGHT (GRAPHICAL_TFT_UPSCALE) * (LCD_PIXEL_HEIGHT)
 
 #define BUTTON_AREA_TOP BUTTON_Y_LO
 #define BUTTON_AREA_BOT BUTTON_Y_HI
 
 TouchButtons touchBt;
 
 void TouchButtons::init() {
-  touchIO.Init();
+  touchIO.init();
   TERN_(HAS_TOUCH_SLEEP, next_sleep_ms = millis() + SEC_TO_MS(ui.sleep_timeout_minutes * 60));
 }
 
 uint8_t TouchButtons::read_buttons() {
   #if HAS_WIRED_LCD
     int16_t x, y;
 
     #if ENABLED(TFT_TOUCH_DEVICE_XPT2046)
       const bool is_touched = (TERN(TOUCH_SCREEN_CALIBRATION, touch_calibration.calibration.orientation, TOUCH_ORIENTATION) == TOUCH_PORTRAIT ? touchIO.getRawPoint(&y, &x) : touchIO.getRawPoint(&x, &y));
       #if HAS_TOUCH_SLEEP

commit 7642bfbf8b997308e691034aa294a061c5fc5426
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Wed May 3 14:19:32 2023 -0700

    🐛 Fix TFT Touch Calibration overrides (#25579)
    
    …and other misc. display-related updates
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/touch/touch_buttons.cpp b/Marlin/src/lcd/touch/touch_buttons.cpp
index 032015cdd0..2e996f30ce 100644
--- a/Marlin/src/lcd/touch/touch_buttons.cpp
+++ b/Marlin/src/lcd/touch/touch_buttons.cpp
@@ -58,21 +58,21 @@
 #define BUTTON_AREA_BOT BUTTON_Y_HI
 
 TouchButtons touchBt;
 
 void TouchButtons::init() {
   touchIO.Init();
   TERN_(HAS_TOUCH_SLEEP, next_sleep_ms = millis() + SEC_TO_MS(ui.sleep_timeout_minutes * 60));
 }
 
 uint8_t TouchButtons::read_buttons() {
-  #ifdef HAS_WIRED_LCD
+  #if HAS_WIRED_LCD
     int16_t x, y;
 
     #if ENABLED(TFT_TOUCH_DEVICE_XPT2046)
       const bool is_touched = (TERN(TOUCH_SCREEN_CALIBRATION, touch_calibration.calibration.orientation, TOUCH_ORIENTATION) == TOUCH_PORTRAIT ? touchIO.getRawPoint(&y, &x) : touchIO.getRawPoint(&x, &y));
       #if HAS_TOUCH_SLEEP
         if (is_touched)
           wakeUp();
         else if (!isSleeping() && ELAPSED(millis(), next_sleep_ms) && ui.on_status_screen())
           sleepTimeout();
       #endif

commit d364babbc0cdb73337d86e2c4fd9170b46b7361a
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 26 14:29:21 2023 -0500

    🧑‍💻 Change HAL_PATH macro for easier HAL relocation (#25743)

diff --git a/Marlin/src/lcd/touch/touch_buttons.cpp b/Marlin/src/lcd/touch/touch_buttons.cpp
index 08554de0d3..032015cdd0 100644
--- a/Marlin/src/lcd/touch/touch_buttons.cpp
+++ b/Marlin/src/lcd/touch/touch_buttons.cpp
@@ -21,24 +21,24 @@
  */
 
 #include "../../inc/MarlinConfig.h"
 
 #if HAS_TOUCH_BUTTONS
 
 #include "touch_buttons.h"
 #include "../scaled_tft.h"
 
 #if ENABLED(TFT_TOUCH_DEVICE_GT911)
-  #include HAL_PATH(../../HAL, tft/gt911.h)
+  #include HAL_PATH(../.., tft/gt911.h)
   GT911 touchIO;
 #elif ENABLED(TFT_TOUCH_DEVICE_XPT2046)
-  #include HAL_PATH(../../HAL, tft/xpt2046.h)
+  #include HAL_PATH(../.., tft/xpt2046.h)
   XPT2046 touchIO;
 #else
   #error "Unknown Touch Screen Type."
 #endif
 
 #if ENABLED(TOUCH_SCREEN_CALIBRATION)
   #include "../tft_io/touch_calibration.h"
 #endif
 
 #if HAS_TOUCH_SLEEP

commit 48b7c7911340300905940ad490678514a18492fe
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Sun Mar 26 02:09:27 2023 -0700

    🩹 Fix Touch Calibration first point (#25298)

diff --git a/Marlin/src/lcd/touch/touch_buttons.cpp b/Marlin/src/lcd/touch/touch_buttons.cpp
index d641dd3b1c..08554de0d3 100644
--- a/Marlin/src/lcd/touch/touch_buttons.cpp
+++ b/Marlin/src/lcd/touch/touch_buttons.cpp
@@ -84,21 +84,21 @@ uint8_t TouchButtons::read_buttons() {
           if (touch_calibration.handleTouch(x, y)) ui.refresh();
           return 0;
         }
         x = int16_t((int32_t(x) * touch_calibration.calibration.x) >> 16) + touch_calibration.calibration.offset_x;
         y = int16_t((int32_t(y) * touch_calibration.calibration.y) >> 16) + touch_calibration.calibration.offset_y;
       #else
         x = uint16_t((uint32_t(x) * TOUCH_CALIBRATION_X) >> 16) + TOUCH_OFFSET_X;
         y = uint16_t((uint32_t(y) * TOUCH_CALIBRATION_Y) >> 16) + TOUCH_OFFSET_Y;
       #endif
     #elif ENABLED(TFT_TOUCH_DEVICE_GT911)
-      bool is_touched = (TOUCH_ORIENTATION == TOUCH_PORTRAIT ? touchIO.getPoint(&y, &x) : touchIO.getPoint(&x, &y));
+      const bool is_touched = (TOUCH_ORIENTATION == TOUCH_PORTRAIT ? touchIO.getPoint(&y, &x) : touchIO.getPoint(&x, &y));
       if (!is_touched) return 0;
     #endif
 
     // Touch within the button area simulates an encoder button
     if (y > BUTTON_AREA_TOP && y < BUTTON_AREA_BOT)
       return WITHIN(x, BUTTOND_X_LO, BUTTOND_X_HI) ? EN_D
            : WITHIN(x, BUTTONA_X_LO, BUTTONA_X_HI) ? EN_A
            : WITHIN(x, BUTTONB_X_LO, BUTTONB_X_HI) ? EN_B
            : WITHIN(x, BUTTONC_X_LO, BUTTONC_X_HI) ? EN_C
            : 0;

commit 2f91154cbdcec3b81da9913bdd16556e8c775d06
Author: EvilGremlin <22657714+EvilGremlin@users.noreply.github.com>
Date:   Thu Aug 25 20:16:55 2022 +0300

    ♻️ Display sleep minutes, encoder disable option (#24618)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/touch/touch_buttons.cpp b/Marlin/src/lcd/touch/touch_buttons.cpp
index 604f366ed4..d641dd3b1c 100644
--- a/Marlin/src/lcd/touch/touch_buttons.cpp
+++ b/Marlin/src/lcd/touch/touch_buttons.cpp
@@ -54,21 +54,21 @@
 #define DOGM_AREA_WIDTH  (GRAPHICAL_TFT_UPSCALE) * (LCD_PIXEL_WIDTH)
 #define DOGM_AREA_HEIGHT (GRAPHICAL_TFT_UPSCALE) * (LCD_PIXEL_HEIGHT)
 
 #define BUTTON_AREA_TOP BUTTON_Y_LO
 #define BUTTON_AREA_BOT BUTTON_Y_HI
 
 TouchButtons touchBt;
 
 void TouchButtons::init() {
   touchIO.Init();
-  TERN_(HAS_TOUCH_SLEEP, next_sleep_ms = millis() + SEC_TO_MS(TOUCH_IDLE_SLEEP));
+  TERN_(HAS_TOUCH_SLEEP, next_sleep_ms = millis() + SEC_TO_MS(ui.sleep_timeout_minutes * 60));
 }
 
 uint8_t TouchButtons::read_buttons() {
   #ifdef HAS_WIRED_LCD
     int16_t x, y;
 
     #if ENABLED(TFT_TOUCH_DEVICE_XPT2046)
       const bool is_touched = (TERN(TOUCH_SCREEN_CALIBRATION, touch_calibration.calibration.orientation, TOUCH_ORIENTATION) == TOUCH_PORTRAIT ? touchIO.getRawPoint(&y, &x) : touchIO.getRawPoint(&x, &y));
       #if HAS_TOUCH_SLEEP
         if (is_touched)
@@ -128,16 +128,16 @@ uint8_t TouchButtons::read_buttons() {
     next_sleep_ms = TSLP_SLEEPING;
   }
   void TouchButtons::wakeUp() {
     if (isSleeping()) {
       #if HAS_LCD_BRIGHTNESS
         ui.set_brightness(ui.brightness);
       #elif PIN_EXISTS(TFT_BACKLIGHT)
         WRITE(TFT_BACKLIGHT_PIN, HIGH);
       #endif
     }
-    next_sleep_ms = millis() + SEC_TO_MS(TOUCH_IDLE_SLEEP);
+    next_sleep_ms = millis() + SEC_TO_MS(ui.sleep_timeout_minutes * 60);
   }
 
 #endif // HAS_TOUCH_SLEEP
 
 #endif // HAS_TOUCH_BUTTONS

commit 1a795376451ad4d2ae654f7e7ae1afdb052b6f56
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Thu Jun 23 06:18:36 2022 -0300

    ✨ Classic UI BIQU BX (#24387)

diff --git a/Marlin/src/lcd/touch/touch_buttons.cpp b/Marlin/src/lcd/touch/touch_buttons.cpp
index dcdc7def86..604f366ed4 100644
--- a/Marlin/src/lcd/touch/touch_buttons.cpp
+++ b/Marlin/src/lcd/touch/touch_buttons.cpp
@@ -61,40 +61,45 @@ TouchButtons touchBt;
 
 void TouchButtons::init() {
   touchIO.Init();
   TERN_(HAS_TOUCH_SLEEP, next_sleep_ms = millis() + SEC_TO_MS(TOUCH_IDLE_SLEEP));
 }
 
 uint8_t TouchButtons::read_buttons() {
   #ifdef HAS_WIRED_LCD
     int16_t x, y;
 
-    const bool is_touched = (TERN(TOUCH_SCREEN_CALIBRATION, touch_calibration.calibration.orientation, TOUCH_ORIENTATION) == TOUCH_PORTRAIT ? touchIO.getRawPoint(&y, &x) : touchIO.getRawPoint(&x, &y));
-    #if HAS_TOUCH_SLEEP
-      if (is_touched)
-        wakeUp();
-      else if (!isSleeping() && ELAPSED(millis(), next_sleep_ms) && ui.on_status_screen())
-        sleepTimeout();
-    #endif
-    if (!is_touched) return 0;
-
-    #if ENABLED(TOUCH_SCREEN_CALIBRATION)
-      const calibrationState state = touch_calibration.get_calibration_state();
-      if (WITHIN(state, CALIBRATION_TOP_LEFT, CALIBRATION_BOTTOM_RIGHT)) {
-        if (touch_calibration.handleTouch(x, y)) ui.refresh();
-        return 0;
-      }
-      x = int16_t((int32_t(x) * touch_calibration.calibration.x) >> 16) + touch_calibration.calibration.offset_x;
-      y = int16_t((int32_t(y) * touch_calibration.calibration.y) >> 16) + touch_calibration.calibration.offset_y;
-    #else
-      x = uint16_t((uint32_t(x) * TOUCH_CALIBRATION_X) >> 16) + TOUCH_OFFSET_X;
-      y = uint16_t((uint32_t(y) * TOUCH_CALIBRATION_Y) >> 16) + TOUCH_OFFSET_Y;
+    #if ENABLED(TFT_TOUCH_DEVICE_XPT2046)
+      const bool is_touched = (TERN(TOUCH_SCREEN_CALIBRATION, touch_calibration.calibration.orientation, TOUCH_ORIENTATION) == TOUCH_PORTRAIT ? touchIO.getRawPoint(&y, &x) : touchIO.getRawPoint(&x, &y));
+      #if HAS_TOUCH_SLEEP
+        if (is_touched)
+          wakeUp();
+        else if (!isSleeping() && ELAPSED(millis(), next_sleep_ms) && ui.on_status_screen())
+          sleepTimeout();
+      #endif
+      if (!is_touched) return 0;
+
+      #if ENABLED(TOUCH_SCREEN_CALIBRATION)
+        const calibrationState state = touch_calibration.get_calibration_state();
+        if (WITHIN(state, CALIBRATION_TOP_LEFT, CALIBRATION_BOTTOM_RIGHT)) {
+          if (touch_calibration.handleTouch(x, y)) ui.refresh();
+          return 0;
+        }
+        x = int16_t((int32_t(x) * touch_calibration.calibration.x) >> 16) + touch_calibration.calibration.offset_x;
+        y = int16_t((int32_t(y) * touch_calibration.calibration.y) >> 16) + touch_calibration.calibration.offset_y;
+      #else
+        x = uint16_t((uint32_t(x) * TOUCH_CALIBRATION_X) >> 16) + TOUCH_OFFSET_X;
+        y = uint16_t((uint32_t(y) * TOUCH_CALIBRATION_Y) >> 16) + TOUCH_OFFSET_Y;
+      #endif
+    #elif ENABLED(TFT_TOUCH_DEVICE_GT911)
+      bool is_touched = (TOUCH_ORIENTATION == TOUCH_PORTRAIT ? touchIO.getPoint(&y, &x) : touchIO.getPoint(&x, &y));
+      if (!is_touched) return 0;
     #endif
 
     // Touch within the button area simulates an encoder button
     if (y > BUTTON_AREA_TOP && y < BUTTON_AREA_BOT)
       return WITHIN(x, BUTTOND_X_LO, BUTTOND_X_HI) ? EN_D
            : WITHIN(x, BUTTONA_X_LO, BUTTONA_X_HI) ? EN_A
            : WITHIN(x, BUTTONB_X_LO, BUTTONB_X_HI) ? EN_B
            : WITHIN(x, BUTTONC_X_LO, BUTTONC_X_HI) ? EN_C
            : 0;
 

commit 1bd921d6a69412686fa4b31c4c1e5710de9840cf
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jan 6 05:07:47 2022 -0600

    🎨 Misc. cleanup, comments

diff --git a/Marlin/src/lcd/touch/touch_buttons.cpp b/Marlin/src/lcd/touch/touch_buttons.cpp
index c15bb08281..dcdc7def86 100644
--- a/Marlin/src/lcd/touch/touch_buttons.cpp
+++ b/Marlin/src/lcd/touch/touch_buttons.cpp
@@ -72,21 +72,21 @@ uint8_t TouchButtons::read_buttons() {
     #if HAS_TOUCH_SLEEP
       if (is_touched)
         wakeUp();
       else if (!isSleeping() && ELAPSED(millis(), next_sleep_ms) && ui.on_status_screen())
         sleepTimeout();
     #endif
     if (!is_touched) return 0;
 
     #if ENABLED(TOUCH_SCREEN_CALIBRATION)
       const calibrationState state = touch_calibration.get_calibration_state();
-      if (state >= CALIBRATION_TOP_LEFT && state <= CALIBRATION_BOTTOM_RIGHT) {
+      if (WITHIN(state, CALIBRATION_TOP_LEFT, CALIBRATION_BOTTOM_RIGHT)) {
         if (touch_calibration.handleTouch(x, y)) ui.refresh();
         return 0;
       }
       x = int16_t((int32_t(x) * touch_calibration.calibration.x) >> 16) + touch_calibration.calibration.offset_x;
       y = int16_t((int32_t(y) * touch_calibration.calibration.y) >> 16) + touch_calibration.calibration.offset_y;
     #else
       x = uint16_t((uint32_t(x) * TOUCH_CALIBRATION_X) >> 16) + TOUCH_OFFSET_X;
       y = uint16_t((uint32_t(y) * TOUCH_CALIBRATION_Y) >> 16) + TOUCH_OFFSET_Y;
     #endif
 

commit f33396c2c34be960d81a6a7be1086af90946f262
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Sun Nov 21 20:13:01 2021 +0100

    🐛 Fix TFT backlight sleep/wake (#23153)

diff --git a/Marlin/src/lcd/touch/touch_buttons.cpp b/Marlin/src/lcd/touch/touch_buttons.cpp
index feaba8483b..c15bb08281 100644
--- a/Marlin/src/lcd/touch/touch_buttons.cpp
+++ b/Marlin/src/lcd/touch/touch_buttons.cpp
@@ -108,29 +108,31 @@ uint8_t TouchButtons::read_buttons() {
 
     // Send the touch to the UI (which will simulate the encoder wheel)
     MarlinUI::screen_click(row, col, x, y);
   #endif
   return 0;
 }
 
 #if HAS_TOUCH_SLEEP
 
   void TouchButtons::sleepTimeout() {
-    #if PIN_EXISTS(TFT_BACKLIGHT)
-      OUT_WRITE(TFT_BACKLIGHT_PIN, LOW);
+    #if HAS_LCD_BRIGHTNESS
+      ui.set_brightness(0);
+    #elif PIN_EXISTS(TFT_BACKLIGHT)
+      WRITE(TFT_BACKLIGHT_PIN, LOW);
     #endif
     next_sleep_ms = TSLP_SLEEPING;
   }
   void TouchButtons::wakeUp() {
     if (isSleeping()) {
       #if HAS_LCD_BRIGHTNESS
-        ui._set_brightness();
+        ui.set_brightness(ui.brightness);
       #elif PIN_EXISTS(TFT_BACKLIGHT)
         WRITE(TFT_BACKLIGHT_PIN, HIGH);
       #endif
     }
     next_sleep_ms = millis() + SEC_TO_MS(TOUCH_IDLE_SLEEP);
   }
 
 #endif // HAS_TOUCH_SLEEP
 
 #endif // HAS_TOUCH_BUTTONS

commit f73175d8263033d1feb1045af67e7230c844aab0
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Mon Sep 27 21:01:47 2021 +0200

    🚸 TFT backlight PWM / brightness (#22841)

diff --git a/Marlin/src/lcd/touch/touch_buttons.cpp b/Marlin/src/lcd/touch/touch_buttons.cpp
index 9d9d6efeb2..feaba8483b 100644
--- a/Marlin/src/lcd/touch/touch_buttons.cpp
+++ b/Marlin/src/lcd/touch/touch_buttons.cpp
@@ -115,20 +115,22 @@ uint8_t TouchButtons::read_buttons() {
 #if HAS_TOUCH_SLEEP
 
   void TouchButtons::sleepTimeout() {
     #if PIN_EXISTS(TFT_BACKLIGHT)
       OUT_WRITE(TFT_BACKLIGHT_PIN, LOW);
     #endif
     next_sleep_ms = TSLP_SLEEPING;
   }
   void TouchButtons::wakeUp() {
     if (isSleeping()) {
-      #if PIN_EXISTS(TFT_BACKLIGHT)
+      #if HAS_LCD_BRIGHTNESS
+        ui._set_brightness();
+      #elif PIN_EXISTS(TFT_BACKLIGHT)
         WRITE(TFT_BACKLIGHT_PIN, HIGH);
       #endif
     }
     next_sleep_ms = millis() + SEC_TO_MS(TOUCH_IDLE_SLEEP);
   }
 
 #endif // HAS_TOUCH_SLEEP
 
 #endif // HAS_TOUCH_BUTTONS

commit 323b38ee88dbf2a4691a20439dbb95a824822199
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Sep 16 04:36:26 2021 -0500

    💡 Adjust headers, formatting

diff --git a/Marlin/src/lcd/touch/touch_buttons.cpp b/Marlin/src/lcd/touch/touch_buttons.cpp
index 2d6158961e..9d9d6efeb2 100644
--- a/Marlin/src/lcd/touch/touch_buttons.cpp
+++ b/Marlin/src/lcd/touch/touch_buttons.cpp
@@ -1,14 +1,17 @@
 /**
  * Marlin 3D Printer Firmware
  * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *

commit c2e4b1626f0cce82a55e8de9dc98ed9381e1d9ad
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Tue Sep 14 04:07:08 2021 +0200

    ✨ TFT Screen/Backlight Sleep (#22617)

diff --git a/Marlin/src/lcd/touch/touch_buttons.cpp b/Marlin/src/lcd/touch/touch_buttons.cpp
index c9476bd2bb..2d6158961e 100644
--- a/Marlin/src/lcd/touch/touch_buttons.cpp
+++ b/Marlin/src/lcd/touch/touch_buttons.cpp
@@ -31,41 +31,54 @@
   #include HAL_PATH(../../HAL, tft/xpt2046.h)
   XPT2046 touchIO;
 #else
   #error "Unknown Touch Screen Type."
 #endif
 
 #if ENABLED(TOUCH_SCREEN_CALIBRATION)
   #include "../tft_io/touch_calibration.h"
 #endif
 
+#if HAS_TOUCH_SLEEP
+  millis_t TouchButtons::next_sleep_ms;
+#endif
+
 #include "../buttons.h" // For EN_C bit mask
 #include "../marlinui.h" // For ui.refresh
 #include "../tft_io/tft_io.h"
 
 #define DOGM_AREA_LEFT   TFT_PIXEL_OFFSET_X
 #define DOGM_AREA_TOP    TFT_PIXEL_OFFSET_Y
 #define DOGM_AREA_WIDTH  (GRAPHICAL_TFT_UPSCALE) * (LCD_PIXEL_WIDTH)
 #define DOGM_AREA_HEIGHT (GRAPHICAL_TFT_UPSCALE) * (LCD_PIXEL_HEIGHT)
 
 #define BUTTON_AREA_TOP BUTTON_Y_LO
 #define BUTTON_AREA_BOT BUTTON_Y_HI
 
-TouchButtons touch;
+TouchButtons touchBt;
 
-void TouchButtons::init() { touchIO.Init(); }
+void TouchButtons::init() {
+  touchIO.Init();
+  TERN_(HAS_TOUCH_SLEEP, next_sleep_ms = millis() + SEC_TO_MS(TOUCH_IDLE_SLEEP));
+}
 
 uint8_t TouchButtons::read_buttons() {
   #ifdef HAS_WIRED_LCD
     int16_t x, y;
 
     const bool is_touched = (TERN(TOUCH_SCREEN_CALIBRATION, touch_calibration.calibration.orientation, TOUCH_ORIENTATION) == TOUCH_PORTRAIT ? touchIO.getRawPoint(&y, &x) : touchIO.getRawPoint(&x, &y));
+    #if HAS_TOUCH_SLEEP
+      if (is_touched)
+        wakeUp();
+      else if (!isSleeping() && ELAPSED(millis(), next_sleep_ms) && ui.on_status_screen())
+        sleepTimeout();
+    #endif
     if (!is_touched) return 0;
 
     #if ENABLED(TOUCH_SCREEN_CALIBRATION)
       const calibrationState state = touch_calibration.get_calibration_state();
       if (state >= CALIBRATION_TOP_LEFT && state <= CALIBRATION_BOTTOM_RIGHT) {
         if (touch_calibration.handleTouch(x, y)) ui.refresh();
         return 0;
       }
       x = int16_t((int32_t(x) * touch_calibration.calibration.x) >> 16) + touch_calibration.calibration.offset_x;
       y = int16_t((int32_t(y) * touch_calibration.calibration.y) >> 16) + touch_calibration.calibration.offset_y;
@@ -89,11 +102,30 @@ uint8_t TouchButtons::read_buttons() {
     // Column and row above BUTTON_AREA_TOP
     int8_t col = (x - (DOGM_AREA_LEFT)) * (LCD_WIDTH)  / (DOGM_AREA_WIDTH),
            row = (y - (DOGM_AREA_TOP))  * (LCD_HEIGHT) / (DOGM_AREA_HEIGHT);
 
     // Send the touch to the UI (which will simulate the encoder wheel)
     MarlinUI::screen_click(row, col, x, y);
   #endif
   return 0;
 }
 
+#if HAS_TOUCH_SLEEP
+
+  void TouchButtons::sleepTimeout() {
+    #if PIN_EXISTS(TFT_BACKLIGHT)
+      OUT_WRITE(TFT_BACKLIGHT_PIN, LOW);
+    #endif
+    next_sleep_ms = TSLP_SLEEPING;
+  }
+  void TouchButtons::wakeUp() {
+    if (isSleeping()) {
+      #if PIN_EXISTS(TFT_BACKLIGHT)
+        WRITE(TFT_BACKLIGHT_PIN, HIGH);
+      #endif
+    }
+    next_sleep_ms = millis() + SEC_TO_MS(TOUCH_IDLE_SLEEP);
+  }
+
+#endif // HAS_TOUCH_SLEEP
+
 #endif // HAS_TOUCH_BUTTONS

commit c9de9d4f9b8aee4ac3dfd0f49591b822230f43c7
Author: BigTreeTech <38851044+bigtreetech@users.noreply.github.com>
Date:   Sun May 9 10:02:16 2021 +0800

    Capacitive Touch Screen (GT911) for SKR SE BX (#21843)
    
    Co-authored-by: Msq001 <alansayyeah@gmail.com>
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/lcd/touch/touch_buttons.cpp b/Marlin/src/lcd/touch/touch_buttons.cpp
index 975de58211..c9476bd2bb 100644
--- a/Marlin/src/lcd/touch/touch_buttons.cpp
+++ b/Marlin/src/lcd/touch/touch_buttons.cpp
@@ -17,22 +17,29 @@
  *
  */
 
 #include "../../inc/MarlinConfig.h"
 
 #if HAS_TOUCH_BUTTONS
 
 #include "touch_buttons.h"
 #include "../scaled_tft.h"
 
-#include HAL_PATH(../../HAL, tft/xpt2046.h)
-XPT2046 touchIO;
+#if ENABLED(TFT_TOUCH_DEVICE_GT911)
+  #include HAL_PATH(../../HAL, tft/gt911.h)
+  GT911 touchIO;
+#elif ENABLED(TFT_TOUCH_DEVICE_XPT2046)
+  #include HAL_PATH(../../HAL, tft/xpt2046.h)
+  XPT2046 touchIO;
+#else
+  #error "Unknown Touch Screen Type."
+#endif
 
 #if ENABLED(TOUCH_SCREEN_CALIBRATION)
   #include "../tft_io/touch_calibration.h"
 #endif
 
 #include "../buttons.h" // For EN_C bit mask
 #include "../marlinui.h" // For ui.refresh
 #include "../tft_io/tft_io.h"
 
 #define DOGM_AREA_LEFT   TFT_PIXEL_OFFSET_X

commit 4a897310252341f203371cb2e99f93bf9c035143
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jan 12 20:43:52 2021 -0600

    Rotary encoder cleanup (#20753)

diff --git a/Marlin/src/lcd/touch/touch_buttons.cpp b/Marlin/src/lcd/touch/touch_buttons.cpp
index 3d1cc26cd6..975de58211 100644
--- a/Marlin/src/lcd/touch/touch_buttons.cpp
+++ b/Marlin/src/lcd/touch/touch_buttons.cpp
@@ -24,21 +24,22 @@
 #include "touch_buttons.h"
 #include "../scaled_tft.h"
 
 #include HAL_PATH(../../HAL, tft/xpt2046.h)
 XPT2046 touchIO;
 
 #if ENABLED(TOUCH_SCREEN_CALIBRATION)
   #include "../tft_io/touch_calibration.h"
 #endif
 
-#include "../marlinui.h" // For EN_C bit mask
+#include "../buttons.h" // For EN_C bit mask
+#include "../marlinui.h" // For ui.refresh
 #include "../tft_io/tft_io.h"
 
 #define DOGM_AREA_LEFT   TFT_PIXEL_OFFSET_X
 #define DOGM_AREA_TOP    TFT_PIXEL_OFFSET_Y
 #define DOGM_AREA_WIDTH  (GRAPHICAL_TFT_UPSCALE) * (LCD_PIXEL_WIDTH)
 #define DOGM_AREA_HEIGHT (GRAPHICAL_TFT_UPSCALE) * (LCD_PIXEL_HEIGHT)
 
 #define BUTTON_AREA_TOP BUTTON_Y_LO
 #define BUTTON_AREA_BOT BUTTON_Y_HI
 
@@ -59,21 +60,20 @@ uint8_t TouchButtons::read_buttons() {
         if (touch_calibration.handleTouch(x, y)) ui.refresh();
         return 0;
       }
       x = int16_t((int32_t(x) * touch_calibration.calibration.x) >> 16) + touch_calibration.calibration.offset_x;
       y = int16_t((int32_t(y) * touch_calibration.calibration.y) >> 16) + touch_calibration.calibration.offset_y;
     #else
       x = uint16_t((uint32_t(x) * TOUCH_CALIBRATION_X) >> 16) + TOUCH_OFFSET_X;
       y = uint16_t((uint32_t(y) * TOUCH_CALIBRATION_Y) >> 16) + TOUCH_OFFSET_Y;
     #endif
 
-
     // Touch within the button area simulates an encoder button
     if (y > BUTTON_AREA_TOP && y < BUTTON_AREA_BOT)
       return WITHIN(x, BUTTOND_X_LO, BUTTOND_X_HI) ? EN_D
            : WITHIN(x, BUTTONA_X_LO, BUTTONA_X_HI) ? EN_A
            : WITHIN(x, BUTTONB_X_LO, BUTTONB_X_HI) ? EN_B
            : WITHIN(x, BUTTONC_X_LO, BUTTONC_X_HI) ? EN_C
            : 0;
 
     if ( !WITHIN(x, DOGM_AREA_LEFT, DOGM_AREA_LEFT + DOGM_AREA_WIDTH)
       || !WITHIN(y, DOGM_AREA_TOP,  DOGM_AREA_TOP  + DOGM_AREA_HEIGHT)

commit 4d6b6bcffc5082de84614aea0bdd2b280f503430
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Wed Dec 23 23:01:21 2020 -0300

    LVGL and Classic UI for STM32 (#20552)

diff --git a/Marlin/src/lcd/touch/touch_buttons.cpp b/Marlin/src/lcd/touch/touch_buttons.cpp
index 8e231ca9ab..3d1cc26cd6 100644
--- a/Marlin/src/lcd/touch/touch_buttons.cpp
+++ b/Marlin/src/lcd/touch/touch_buttons.cpp
@@ -25,38 +25,40 @@
 #include "../scaled_tft.h"
 
 #include HAL_PATH(../../HAL, tft/xpt2046.h)
 XPT2046 touchIO;
 
 #if ENABLED(TOUCH_SCREEN_CALIBRATION)
   #include "../tft_io/touch_calibration.h"
 #endif
 
 #include "../marlinui.h" // For EN_C bit mask
+#include "../tft_io/tft_io.h"
 
 #define DOGM_AREA_LEFT   TFT_PIXEL_OFFSET_X
 #define DOGM_AREA_TOP    TFT_PIXEL_OFFSET_Y
 #define DOGM_AREA_WIDTH  (GRAPHICAL_TFT_UPSCALE) * (LCD_PIXEL_WIDTH)
 #define DOGM_AREA_HEIGHT (GRAPHICAL_TFT_UPSCALE) * (LCD_PIXEL_HEIGHT)
 
 #define BUTTON_AREA_TOP BUTTON_Y_LO
 #define BUTTON_AREA_BOT BUTTON_Y_HI
 
 TouchButtons touch;
 
 void TouchButtons::init() { touchIO.Init(); }
 
 uint8_t TouchButtons::read_buttons() {
   #ifdef HAS_WIRED_LCD
     int16_t x, y;
 
-    if (!touchIO.getRawPoint(&x, &y)) return 0;
+    const bool is_touched = (TERN(TOUCH_SCREEN_CALIBRATION, touch_calibration.calibration.orientation, TOUCH_ORIENTATION) == TOUCH_PORTRAIT ? touchIO.getRawPoint(&y, &x) : touchIO.getRawPoint(&x, &y));
+    if (!is_touched) return 0;
 
     #if ENABLED(TOUCH_SCREEN_CALIBRATION)
       const calibrationState state = touch_calibration.get_calibration_state();
       if (state >= CALIBRATION_TOP_LEFT && state <= CALIBRATION_BOTTOM_RIGHT) {
         if (touch_calibration.handleTouch(x, y)) ui.refresh();
         return 0;
       }
       x = int16_t((int32_t(x) * touch_calibration.calibration.x) >> 16) + touch_calibration.calibration.offset_x;
       y = int16_t((int32_t(y) * touch_calibration.calibration.y) >> 16) + touch_calibration.calibration.offset_y;
     #else

commit ea371618da71dc43e6aee95a8e479c8797867e04
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Sun Nov 15 19:39:58 2020 -0300

    Add Touch Calibration screen (#20049)

diff --git a/Marlin/src/lcd/touch/touch_buttons.cpp b/Marlin/src/lcd/touch/touch_buttons.cpp
index 4e98486969..8e231ca9ab 100644
--- a/Marlin/src/lcd/touch/touch_buttons.cpp
+++ b/Marlin/src/lcd/touch/touch_buttons.cpp
@@ -12,56 +12,66 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 #include "../../inc/MarlinConfig.h"
 
-#if HAS_TOUCH_XPT2046
+#if HAS_TOUCH_BUTTONS
 
 #include "touch_buttons.h"
 #include "../scaled_tft.h"
 
 #include HAL_PATH(../../HAL, tft/xpt2046.h)
 XPT2046 touchIO;
 
-#include "../../lcd/marlinui.h" // For EN_C bit mask
+#if ENABLED(TOUCH_SCREEN_CALIBRATION)
+  #include "../tft_io/touch_calibration.h"
+#endif
+
+#include "../marlinui.h" // For EN_C bit mask
 
 #define DOGM_AREA_LEFT   TFT_PIXEL_OFFSET_X
 #define DOGM_AREA_TOP    TFT_PIXEL_OFFSET_Y
 #define DOGM_AREA_WIDTH  (GRAPHICAL_TFT_UPSCALE) * (LCD_PIXEL_WIDTH)
 #define DOGM_AREA_HEIGHT (GRAPHICAL_TFT_UPSCALE) * (LCD_PIXEL_HEIGHT)
 
 #define BUTTON_AREA_TOP BUTTON_Y_LO
 #define BUTTON_AREA_BOT BUTTON_Y_HI
 
 TouchButtons touch;
 
 void TouchButtons::init() { touchIO.Init(); }
 
 uint8_t TouchButtons::read_buttons() {
   #ifdef HAS_WIRED_LCD
     int16_t x, y;
 
     if (!touchIO.getRawPoint(&x, &y)) return 0;
 
-    x = uint16_t((uint32_t(x) * XPT2046_X_CALIBRATION) >> 16) + XPT2046_X_OFFSET;
-    y = uint16_t((uint32_t(y) * XPT2046_Y_CALIBRATION) >> 16) + XPT2046_Y_OFFSET;
-
-    #if (TFT_ROTATION & TFT_ROTATE_180)
-      x = TFT_WIDTH - x;
-      y = TFT_HEIGHT - y;
+    #if ENABLED(TOUCH_SCREEN_CALIBRATION)
+      const calibrationState state = touch_calibration.get_calibration_state();
+      if (state >= CALIBRATION_TOP_LEFT && state <= CALIBRATION_BOTTOM_RIGHT) {
+        if (touch_calibration.handleTouch(x, y)) ui.refresh();
+        return 0;
+      }
+      x = int16_t((int32_t(x) * touch_calibration.calibration.x) >> 16) + touch_calibration.calibration.offset_x;
+      y = int16_t((int32_t(y) * touch_calibration.calibration.y) >> 16) + touch_calibration.calibration.offset_y;
+    #else
+      x = uint16_t((uint32_t(x) * TOUCH_CALIBRATION_X) >> 16) + TOUCH_OFFSET_X;
+      y = uint16_t((uint32_t(y) * TOUCH_CALIBRATION_Y) >> 16) + TOUCH_OFFSET_Y;
     #endif
 
+
     // Touch within the button area simulates an encoder button
     if (y > BUTTON_AREA_TOP && y < BUTTON_AREA_BOT)
       return WITHIN(x, BUTTOND_X_LO, BUTTOND_X_HI) ? EN_D
            : WITHIN(x, BUTTONA_X_LO, BUTTONA_X_HI) ? EN_A
            : WITHIN(x, BUTTONB_X_LO, BUTTONB_X_HI) ? EN_B
            : WITHIN(x, BUTTONC_X_LO, BUTTONC_X_HI) ? EN_C
            : 0;
 
     if ( !WITHIN(x, DOGM_AREA_LEFT, DOGM_AREA_LEFT + DOGM_AREA_WIDTH)
       || !WITHIN(y, DOGM_AREA_TOP,  DOGM_AREA_TOP  + DOGM_AREA_HEIGHT)
@@ -70,11 +80,11 @@ uint8_t TouchButtons::read_buttons() {
     // Column and row above BUTTON_AREA_TOP
     int8_t col = (x - (DOGM_AREA_LEFT)) * (LCD_WIDTH)  / (DOGM_AREA_WIDTH),
            row = (y - (DOGM_AREA_TOP))  * (LCD_HEIGHT) / (DOGM_AREA_HEIGHT);
 
     // Send the touch to the UI (which will simulate the encoder wheel)
     MarlinUI::screen_click(row, col, x, y);
   #endif
   return 0;
 }
 
-#endif // HAS_TOUCH_XPT2046
+#endif // HAS_TOUCH_BUTTONS

commit e9053654a73830bb8d242784bb864b3305633636
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Tue Nov 3 20:25:33 2020 -0300

    Better Classic UI touch resolution (#20004)

diff --git a/Marlin/src/lcd/touch/touch_buttons.cpp b/Marlin/src/lcd/touch/touch_buttons.cpp
index eeb22aae6e..4e98486969 100644
--- a/Marlin/src/lcd/touch/touch_buttons.cpp
+++ b/Marlin/src/lcd/touch/touch_buttons.cpp
@@ -22,91 +22,59 @@
 #if HAS_TOUCH_XPT2046
 
 #include "touch_buttons.h"
 #include "../scaled_tft.h"
 
 #include HAL_PATH(../../HAL, tft/xpt2046.h)
 XPT2046 touchIO;
 
 #include "../../lcd/marlinui.h" // For EN_C bit mask
 
-/**
- * Draw and Touch processing
- *
- *      LCD_PIXEL_WIDTH/HEIGHT (128x64) is the (emulated DOGM) Pixel Drawing resolution.
- *   TOUCH_SENSOR_WIDTH/HEIGHT (320x240) is the Touch Area resolution.
- * TFT_WIDTH/HEIGHT (320x240 or 480x320) is the Actual (FSMC) Display resolution.
- *
- *  - All native (u8g) drawing is done in LCD_PIXEL_* (128x64)
- *  - The DOGM pixels are is upscaled 2-3x (as needed) for display.
- *  - Touch coordinates use TOUCH_SENSOR_* resolution and are converted to
- *    click and scroll-wheel events (emulating of a common DOGM display).
- *
- *  TOUCH_SCREEN resolution exists to fit our calibration values. The original touch code was made
- *  and originally calibrated for 320x240. If you decide to change the resolution of the touch code,
- *  new calibration values will be needed.
- *
- *  The Marlin menus are drawn scaled in the upper region of the screen. The bottom region (in a
- *  fixed location in TOUCH_SCREEN* coordinate space) is used for 4 general-purpose buttons to
- *  navigate and select menu items. Both regions are touchable.
- *
- * The Marlin screen touchable area starts at TFT_PIXEL_OFFSET_X/Y (translated to SCREEN_PCT_LEFT/TOP)
- * and spans LCD_PIXEL_WIDTH/HEIGHT (scaled to SCREEN_PCT_WIDTH/HEIGHT).
- */
-
-// Touch sensor resolution independent of display resolution
-#define TOUCH_SENSOR_WIDTH  320
-#define TOUCH_SENSOR_HEIGHT 240
-
-#define SCREEN_PCT_WIDE(X) ((X) * (TOUCH_SENSOR_WIDTH)  / (TFT_WIDTH))
-#define SCREEN_PCT_HIGH(Y) ((Y) * (TOUCH_SENSOR_HEIGHT) / (TFT_HEIGHT))
-
-#define SCREEN_PCT_LEFT   SCREEN_PCT_WIDE(TFT_PIXEL_OFFSET_X)
-#define SCREEN_PCT_TOP    SCREEN_PCT_HIGH(TFT_PIXEL_OFFSET_Y)
-#define SCREEN_PCT_WIDTH  SCREEN_PCT_WIDE((GRAPHICAL_TFT_UPSCALE) * (LCD_PIXEL_WIDTH))
-#define SCREEN_PCT_HEIGHT SCREEN_PCT_HIGH((GRAPHICAL_TFT_UPSCALE) * (LCD_PIXEL_HEIGHT))
+#define DOGM_AREA_LEFT   TFT_PIXEL_OFFSET_X
+#define DOGM_AREA_TOP    TFT_PIXEL_OFFSET_Y
+#define DOGM_AREA_WIDTH  (GRAPHICAL_TFT_UPSCALE) * (LCD_PIXEL_WIDTH)
+#define DOGM_AREA_HEIGHT (GRAPHICAL_TFT_UPSCALE) * (LCD_PIXEL_HEIGHT)
 
-// Coordinates in terms of 240-unit-tall touch area
-#define BUTTON_AREA_TOP 175
-#define BUTTON_AREA_BOT 234
+#define BUTTON_AREA_TOP BUTTON_Y_LO
+#define BUTTON_AREA_BOT BUTTON_Y_HI
 
 TouchButtons touch;
 
 void TouchButtons::init() { touchIO.Init(); }
 
 uint8_t TouchButtons::read_buttons() {
   #ifdef HAS_WIRED_LCD
     int16_t x, y;
 
     if (!touchIO.getRawPoint(&x, &y)) return 0;
 
     x = uint16_t((uint32_t(x) * XPT2046_X_CALIBRATION) >> 16) + XPT2046_X_OFFSET;
     y = uint16_t((uint32_t(y) * XPT2046_Y_CALIBRATION) >> 16) + XPT2046_Y_OFFSET;
 
     #if (TFT_ROTATION & TFT_ROTATE_180)
-      x = TOUCH_SENSOR_WIDTH - x;
-      y = TOUCH_SENSOR_HEIGHT - y;
+      x = TFT_WIDTH - x;
+      y = TFT_HEIGHT - y;
     #endif
 
     // Touch within the button area simulates an encoder button
     if (y > BUTTON_AREA_TOP && y < BUTTON_AREA_BOT)
-      return WITHIN(x,  14,  77) ? EN_D
-           : WITHIN(x,  90, 153) ? EN_A
-           : WITHIN(x, 166, 229) ? EN_B
-           : WITHIN(x, 242, 305) ? EN_C
+      return WITHIN(x, BUTTOND_X_LO, BUTTOND_X_HI) ? EN_D
+           : WITHIN(x, BUTTONA_X_LO, BUTTONA_X_HI) ? EN_A
+           : WITHIN(x, BUTTONB_X_LO, BUTTONB_X_HI) ? EN_B
+           : WITHIN(x, BUTTONC_X_LO, BUTTONC_X_HI) ? EN_C
            : 0;
 
-    if ( !WITHIN(x, SCREEN_PCT_LEFT, SCREEN_PCT_LEFT + SCREEN_PCT_WIDTH)
-      || !WITHIN(y, SCREEN_PCT_TOP,  SCREEN_PCT_TOP  + SCREEN_PCT_HEIGHT)
+    if ( !WITHIN(x, DOGM_AREA_LEFT, DOGM_AREA_LEFT + DOGM_AREA_WIDTH)
+      || !WITHIN(y, DOGM_AREA_TOP,  DOGM_AREA_TOP  + DOGM_AREA_HEIGHT)
     ) return 0;
 
     // Column and row above BUTTON_AREA_TOP
-    int8_t col = (x - (SCREEN_PCT_LEFT)) * (LCD_WIDTH)  / (SCREEN_PCT_WIDTH),
-           row = (y - (SCREEN_PCT_TOP))  * (LCD_HEIGHT) / (SCREEN_PCT_HEIGHT);
+    int8_t col = (x - (DOGM_AREA_LEFT)) * (LCD_WIDTH)  / (DOGM_AREA_WIDTH),
+           row = (y - (DOGM_AREA_TOP))  * (LCD_HEIGHT) / (DOGM_AREA_HEIGHT);
 
     // Send the touch to the UI (which will simulate the encoder wheel)
     MarlinUI::screen_click(row, col, x, y);
   #endif
   return 0;
 }
 
 #endif // HAS_TOUCH_XPT2046

commit eaf6777a6643a6fab23ceaaa4699cb2466ea6b83
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Oct 16 19:36:25 2020 -0500

    Rename ultralcd => marlinui

diff --git a/Marlin/src/lcd/touch/touch_buttons.cpp b/Marlin/src/lcd/touch/touch_buttons.cpp
index 7d25c0df7e..eeb22aae6e 100644
--- a/Marlin/src/lcd/touch/touch_buttons.cpp
+++ b/Marlin/src/lcd/touch/touch_buttons.cpp
@@ -20,21 +20,21 @@
 #include "../../inc/MarlinConfig.h"
 
 #if HAS_TOUCH_XPT2046
 
 #include "touch_buttons.h"
 #include "../scaled_tft.h"
 
 #include HAL_PATH(../../HAL, tft/xpt2046.h)
 XPT2046 touchIO;
 
-#include "../../lcd/ultralcd.h" // For EN_C bit mask
+#include "../../lcd/marlinui.h" // For EN_C bit mask
 
 /**
  * Draw and Touch processing
  *
  *      LCD_PIXEL_WIDTH/HEIGHT (128x64) is the (emulated DOGM) Pixel Drawing resolution.
  *   TOUCH_SENSOR_WIDTH/HEIGHT (320x240) is the Touch Area resolution.
  * TFT_WIDTH/HEIGHT (320x240 or 480x320) is the Actual (FSMC) Display resolution.
  *
  *  - All native (u8g) drawing is done in LCD_PIXEL_* (128x64)
  *  - The DOGM pixels are is upscaled 2-3x (as needed) for display.

commit c0920bbf6a2490b7ea66d2a9e828c0f527a6c77b
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Mon Oct 12 18:38:07 2020 -0300

    TFT Refactoring (#19192)
    
    * split tft folder in two: tft for color ui; tft_io for shared tft code
    
    * after the files got moved, now the code was moved to the right place
    
    * classic ui using TFT IO init lcd codes
    
    * feature to compile tft_io when enabled
    
    * compiling fix
    
    * lvgl spi tft working with tft io init codes
    
    * there is no need for separeted fsmc and spi class in lvgl anymore, as tft io handle everything
    
    * remove debug
    
    * base for TFT rotation and mirroring API, and ILI9488 support
    
    * ST7796S rotate and mirror support
    
    * ST7789V rotate and mirror support
    
    * ST7735 rotate and mirror support
    
    * ILI9341 rotate and mirror support
    
    * ILI9328 rotate and mirror support
    
    * R61505 rotate and mirror support
    
    * MKS TFT definitions
    
    * more configs for mks tfts
    
    * update config
    
    * naming typo
    
    * to configure the user interface
    
    * ANYCUBIC_TFT35
    
    * tft configs
    
    * support for SSD1963
    
    * tft display types
    
    * updated conditionals lcd; first board fully working with the new code - all 3 ui!
    
    * compatiblity
    
    * changed name
    
    * move classic ui file name
    
    * rename TURN -> ROTATE
    
    * GRAPHICAL_TFT_ROTATE_180 deprecated
    
    * first fsmc board fully working - chitu v5
    
    * mks robin nano v1.2 + tft 35 ok!
    
    * right pin name
    
    * anycubic tft tested in a TRIGORILLA_PRO
    
    * chitu v6
    
    * nano 32 tft orientation
    
    * mks tft43
    
    * mks tft43 rotation
    
    * fixed LONGER LK tft setup
    
    * GRAPHICAL_TFT_UPSCALE defined by the display type
    
    * better offsets defaults
    
    * Update Configuration.h
    
    * Update tft_fsmc.cpp
    
    * Update Conditionals_LCD.h
    
    * Tweak comments
    
    * update nano tests
    
    * Revert "update nano tests"
    
    This reverts commit a071ebbfad30e28855a4a5695ec8a726542a1a65.
    
    * default tft
    
    * outdated comments
    
    * to not break non-vscode builds
    
    * upscale tft 35
    
    * support tft 180 rotation for color ui
    
    * Each TFT Driver is responsible for its default color mode.
    
    * use auto detect in mks displays, because some of them could be shipped with diferent drivers
    
    * extra s
    
    * unused code
    
    * wrong -1
    
    * missing mirror options
    
    * Smaller regex pattern
    
    * Comment updates
    
    * Clean up old defines
    
    * Apply pins formatting
    
    * GRAPHICAL_TFT_ROTATE_180 => TFT_ROTATE_180
    
    * MKS_ROBIN_TFT_V1_1R
    
    * merge fix
    
    * correct resolution
    
    * auto is default, dont need be there, and it will allow the user to configure it even for named displays
    
    * to not use rotation with MKS_ROBIN_TFT_V1_1R
    
    * i like () in macros
    
    * avoid sleepy commits
    
    * default for st7789 is rgb
    
    * nano follow up
    
    * to allow ili9328 rotation
    
    * default is rgb
    
    * boards merge follow up
    
    * to match bootloader orientation
    
    * HAS_TOUCH_XPT2046 is not hal specific anymore
    
    * lets not forget LPC
    
    * 180 rotation for ili9328 and R61505
    
    * Clean up whitespace
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/lcd/touch/touch_buttons.cpp b/Marlin/src/lcd/touch/touch_buttons.cpp
index c97018c379..7d25c0df7e 100644
--- a/Marlin/src/lcd/touch/touch_buttons.cpp
+++ b/Marlin/src/lcd/touch/touch_buttons.cpp
@@ -75,21 +75,21 @@ void TouchButtons::init() { touchIO.Init(); }
 
 uint8_t TouchButtons::read_buttons() {
   #ifdef HAS_WIRED_LCD
     int16_t x, y;
 
     if (!touchIO.getRawPoint(&x, &y)) return 0;
 
     x = uint16_t((uint32_t(x) * XPT2046_X_CALIBRATION) >> 16) + XPT2046_X_OFFSET;
     y = uint16_t((uint32_t(y) * XPT2046_Y_CALIBRATION) >> 16) + XPT2046_Y_OFFSET;
 
-    #if ENABLED(GRAPHICAL_TFT_ROTATE_180)
+    #if (TFT_ROTATION & TFT_ROTATE_180)
       x = TOUCH_SENSOR_WIDTH - x;
       y = TOUCH_SENSOR_HEIGHT - y;
     #endif
 
     // Touch within the button area simulates an encoder button
     if (y > BUTTON_AREA_TOP && y < BUTTON_AREA_BOT)
       return WITHIN(x,  14,  77) ? EN_D
            : WITHIN(x,  90, 153) ? EN_A
            : WITHIN(x, 166, 229) ? EN_B
            : WITHIN(x, 242, 305) ? EN_C

commit c2c6a679ea4bdf48ce1800a8831fcec36c09ce53
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 28 01:13:27 2020 -0500

    Rename LCD conditionals (#19533)

diff --git a/Marlin/src/lcd/touch/touch_buttons.cpp b/Marlin/src/lcd/touch/touch_buttons.cpp
index 8eae73df11..c97018c379 100644
--- a/Marlin/src/lcd/touch/touch_buttons.cpp
+++ b/Marlin/src/lcd/touch/touch_buttons.cpp
@@ -67,21 +67,21 @@ XPT2046 touchIO;
 
 // Coordinates in terms of 240-unit-tall touch area
 #define BUTTON_AREA_TOP 175
 #define BUTTON_AREA_BOT 234
 
 TouchButtons touch;
 
 void TouchButtons::init() { touchIO.Init(); }
 
 uint8_t TouchButtons::read_buttons() {
-  #ifdef HAS_SPI_LCD
+  #ifdef HAS_WIRED_LCD
     int16_t x, y;
 
     if (!touchIO.getRawPoint(&x, &y)) return 0;
 
     x = uint16_t((uint32_t(x) * XPT2046_X_CALIBRATION) >> 16) + XPT2046_X_OFFSET;
     y = uint16_t((uint32_t(y) * XPT2046_Y_CALIBRATION) >> 16) + XPT2046_Y_OFFSET;
 
     #if ENABLED(GRAPHICAL_TFT_ROTATE_180)
       x = TOUCH_SENSOR_WIDTH - x;
       y = TOUCH_SENSOR_HEIGHT - y;

commit a37cf2490054ece3c16f0caca26a02c3d33057c8
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Fri Aug 21 20:54:21 2020 -0300

    Emulated DOGM via HAL TFT, XPT IO (#19017)

diff --git a/Marlin/src/lcd/touch/touch_buttons.cpp b/Marlin/src/lcd/touch/touch_buttons.cpp
new file mode 100644
index 0000000000..8eae73df11
--- /dev/null
+++ b/Marlin/src/lcd/touch/touch_buttons.cpp
@@ -0,0 +1,112 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "../../inc/MarlinConfig.h"
+
+#if HAS_TOUCH_XPT2046
+
+#include "touch_buttons.h"
+#include "../scaled_tft.h"
+
+#include HAL_PATH(../../HAL, tft/xpt2046.h)
+XPT2046 touchIO;
+
+#include "../../lcd/ultralcd.h" // For EN_C bit mask
+
+/**
+ * Draw and Touch processing
+ *
+ *      LCD_PIXEL_WIDTH/HEIGHT (128x64) is the (emulated DOGM) Pixel Drawing resolution.
+ *   TOUCH_SENSOR_WIDTH/HEIGHT (320x240) is the Touch Area resolution.
+ * TFT_WIDTH/HEIGHT (320x240 or 480x320) is the Actual (FSMC) Display resolution.
+ *
+ *  - All native (u8g) drawing is done in LCD_PIXEL_* (128x64)
+ *  - The DOGM pixels are is upscaled 2-3x (as needed) for display.
+ *  - Touch coordinates use TOUCH_SENSOR_* resolution and are converted to
+ *    click and scroll-wheel events (emulating of a common DOGM display).
+ *
+ *  TOUCH_SCREEN resolution exists to fit our calibration values. The original touch code was made
+ *  and originally calibrated for 320x240. If you decide to change the resolution of the touch code,
+ *  new calibration values will be needed.
+ *
+ *  The Marlin menus are drawn scaled in the upper region of the screen. The bottom region (in a
+ *  fixed location in TOUCH_SCREEN* coordinate space) is used for 4 general-purpose buttons to
+ *  navigate and select menu items. Both regions are touchable.
+ *
+ * The Marlin screen touchable area starts at TFT_PIXEL_OFFSET_X/Y (translated to SCREEN_PCT_LEFT/TOP)
+ * and spans LCD_PIXEL_WIDTH/HEIGHT (scaled to SCREEN_PCT_WIDTH/HEIGHT).
+ */
+
+// Touch sensor resolution independent of display resolution
+#define TOUCH_SENSOR_WIDTH  320
+#define TOUCH_SENSOR_HEIGHT 240
+
+#define SCREEN_PCT_WIDE(X) ((X) * (TOUCH_SENSOR_WIDTH)  / (TFT_WIDTH))
+#define SCREEN_PCT_HIGH(Y) ((Y) * (TOUCH_SENSOR_HEIGHT) / (TFT_HEIGHT))
+
+#define SCREEN_PCT_LEFT   SCREEN_PCT_WIDE(TFT_PIXEL_OFFSET_X)
+#define SCREEN_PCT_TOP    SCREEN_PCT_HIGH(TFT_PIXEL_OFFSET_Y)
+#define SCREEN_PCT_WIDTH  SCREEN_PCT_WIDE((GRAPHICAL_TFT_UPSCALE) * (LCD_PIXEL_WIDTH))
+#define SCREEN_PCT_HEIGHT SCREEN_PCT_HIGH((GRAPHICAL_TFT_UPSCALE) * (LCD_PIXEL_HEIGHT))
+
+// Coordinates in terms of 240-unit-tall touch area
+#define BUTTON_AREA_TOP 175
+#define BUTTON_AREA_BOT 234
+
+TouchButtons touch;
+
+void TouchButtons::init() { touchIO.Init(); }
+
+uint8_t TouchButtons::read_buttons() {
+  #ifdef HAS_SPI_LCD
+    int16_t x, y;
+
+    if (!touchIO.getRawPoint(&x, &y)) return 0;
+
+    x = uint16_t((uint32_t(x) * XPT2046_X_CALIBRATION) >> 16) + XPT2046_X_OFFSET;
+    y = uint16_t((uint32_t(y) * XPT2046_Y_CALIBRATION) >> 16) + XPT2046_Y_OFFSET;
+
+    #if ENABLED(GRAPHICAL_TFT_ROTATE_180)
+      x = TOUCH_SENSOR_WIDTH - x;
+      y = TOUCH_SENSOR_HEIGHT - y;
+    #endif
+
+    // Touch within the button area simulates an encoder button
+    if (y > BUTTON_AREA_TOP && y < BUTTON_AREA_BOT)
+      return WITHIN(x,  14,  77) ? EN_D
+           : WITHIN(x,  90, 153) ? EN_A
+           : WITHIN(x, 166, 229) ? EN_B
+           : WITHIN(x, 242, 305) ? EN_C
+           : 0;
+
+    if ( !WITHIN(x, SCREEN_PCT_LEFT, SCREEN_PCT_LEFT + SCREEN_PCT_WIDTH)
+      || !WITHIN(y, SCREEN_PCT_TOP,  SCREEN_PCT_TOP  + SCREEN_PCT_HEIGHT)
+    ) return 0;
+
+    // Column and row above BUTTON_AREA_TOP
+    int8_t col = (x - (SCREEN_PCT_LEFT)) * (LCD_WIDTH)  / (SCREEN_PCT_WIDTH),
+           row = (y - (SCREEN_PCT_TOP))  * (LCD_HEIGHT) / (SCREEN_PCT_HEIGHT);
+
+    // Send the touch to the UI (which will simulate the encoder wheel)
+    MarlinUI::screen_click(row, col, x, y);
+  #endif
+  return 0;
+}
+
+#endif // HAS_TOUCH_XPT2046
