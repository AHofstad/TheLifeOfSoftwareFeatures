commit 466282f322ae4f42a8f3db5e3c9765c38445fdc8
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Mar 31 18:20:37 2024 -0500

    ü©π Misc. changes from ProUI / ExtUI updates (#26928)

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index 4eb031e538..a9e8bb5646 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -886,7 +886,7 @@ void ST7920_Lite_Status_Screen::update_status_or_position(bool forceUpdate) {
    * If STATUS_EXPIRE_SECONDS is zero, only the status is shown.
    */
   if (forceUpdate || status_changed()) {
-    TERN_(STATUS_MESSAGE_SCROLLING, ui.status_scroll_offset = 0);
+    TERN_(STATUS_MESSAGE_SCROLLING, ui.reset_status_scroll());
     #if STATUS_EXPIRE_SECONDS
       countdown = !ui.status_message.empty() ? STATUS_EXPIRE_SECONDS : 0;
     #endif

commit bb557e5195a6177bc7386fce0176274aede60b64
Author: Dennis <16547088+soligen2010@users.noreply.github.com>
Date:   Sun Dec 24 22:40:20 2023 -0500

    ü©π Fix string buffer warning (#26550)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index 2039d99635..4eb031e538 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -662,39 +662,36 @@ bool ST7920_Lite_Status_Screen::indicators_changed() {
 
 // Process progress strings
 #if HAS_PRINT_PROGRESS
-  static char screenstr[8];
+  static MString<8> screenstr;
 
   #if HAS_TIME_DISPLAY
     char * ST7920_Lite_Status_Screen::prepare_time_string(const duration_t &time, char prefix) {
-      static char str[6];
-      memset(&screenstr, ' ', 8); // fill with spaces to avoid artifacts, not doing right-justification to save cycles
-      screenstr[0] = prefix;
-      TERN_(HOTENDS == 1, screenstr[1] = 0x07;)  // add bullet ‚Ä¢ separator when there is space
-      int str_length = time.toDigital(str);
-      memcpy(&screenstr[TERN(HOTENDS == 1, 2, 1)], str, str_length); //memcpy because we can't have terminator
-      return screenstr;
+      static char time_str[6];
+      (void)time.toDigital(time_str);   // Up to 5 chars
+      screenstr = prefix;
+      if (HOTENDS == 1) screenstr += char(0x07);  // Add bullet ‚Ä¢ separator when there is space
+      screenstr += time_str;
+      screenstr += Spaces(3);
+      return &screenstr;
     }
   #endif
 
   void ST7920_Lite_Status_Screen::draw_progress_string(uint8_t addr, const char *str) {
     set_ddram_address(addr);
     begin_data();
-    write_str(str, TERN(HOTENDS == 1, 8, 6));
+    write_str(str, HOTENDS == 1 ? 8 : 6);
   }
 
-  #define PPOS (DDRAM_LINE_3 + TERN(HOTENDS == 1, 4, 5)) // progress string position, in 16-bit words
+  constexpr uint8_t PPOS = (DDRAM_LINE_3 + (HOTENDS == 1 ? 4 : 5)); // Progress string position, in 16-bit words
 
   #if ENABLED(SHOW_PROGRESS_PERCENT)
     void MarlinUI::drawPercent() { lightUI.drawPercent(); }
     void ST7920_Lite_Status_Screen::drawPercent() {
-      #define LSHIFT TERN(HOTENDS == 1, 0, 1)
       const uint8_t progress = ui.get_progress_percent();
-      memset(&screenstr, ' ', 8); // fill with spaces to avoid artifacts
-      if (progress){
-        memcpy(&screenstr[2 - LSHIFT], \
-                  TERN(PRINT_PROGRESS_SHOW_DECIMALS, permyriadtostr4(ui.get_progress_permyriad()), ui8tostr3rj(progress)), \
-                  TERN(PRINT_PROGRESS_SHOW_DECIMALS, 4, 3));
-        screenstr[(TERN(PRINT_PROGRESS_SHOW_DECIMALS, 6, 5) - LSHIFT)] = '%';
+      if (progress) {
+        screenstr += Spaces(1 + (HOTENDS == 1));
+        screenstr += TERN(PRINT_PROGRESS_SHOW_DECIMALS, permyriadtostr4(ui.get_progress_permyriad()), ui8tostr3rj(progress));
+        screenstr += "%   ";
         draw_progress_string(PPOS, screenstr);
       }
     }

commit 473817f2f4758924c56351a3672354a141834929
Author: mikemerryguy <57319047+mikemerryguy@users.noreply.github.com>
Date:   Sat Dec 9 02:38:31 2023 -0500

    üö∏ Adjust Progress / Completion (#26466)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index a6e942b706..2039d99635 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -664,15 +664,17 @@ bool ST7920_Lite_Status_Screen::indicators_changed() {
 #if HAS_PRINT_PROGRESS
   static char screenstr[8];
 
-  char * ST7920_Lite_Status_Screen::prepare_time_string(const duration_t &time, char prefix) {
-    static char str[6];
-    memset(&screenstr, 0x20, 8); // fill with spaces to avoid artifacts, not doing right-justification to save cycles
-    screenstr[0] = prefix;
-    TERN_(HOTENDS == 1, screenstr[1] = 0x07;)  // add bullet ‚Ä¢ separator when there is space
-    int str_length = time.toDigital(str);
-    memcpy(&screenstr[TERN(HOTENDS == 1, 2, 1)], str, str_length); //memcpy because we can't have terminator
-    return screenstr;
-  }
+  #if HAS_TIME_DISPLAY
+    char * ST7920_Lite_Status_Screen::prepare_time_string(const duration_t &time, char prefix) {
+      static char str[6];
+      memset(&screenstr, ' ', 8); // fill with spaces to avoid artifacts, not doing right-justification to save cycles
+      screenstr[0] = prefix;
+      TERN_(HOTENDS == 1, screenstr[1] = 0x07;)  // add bullet ‚Ä¢ separator when there is space
+      int str_length = time.toDigital(str);
+      memcpy(&screenstr[TERN(HOTENDS == 1, 2, 1)], str, str_length); //memcpy because we can't have terminator
+      return screenstr;
+    }
+  #endif
 
   void ST7920_Lite_Status_Screen::draw_progress_string(uint8_t addr, const char *str) {
     set_ddram_address(addr);
@@ -687,7 +689,7 @@ bool ST7920_Lite_Status_Screen::indicators_changed() {
     void ST7920_Lite_Status_Screen::drawPercent() {
       #define LSHIFT TERN(HOTENDS == 1, 0, 1)
       const uint8_t progress = ui.get_progress_percent();
-      memset(&screenstr, 0x20, 8); // fill with spaces to avoid artifacts
+      memset(&screenstr, ' ', 8); // fill with spaces to avoid artifacts
       if (progress){
         memcpy(&screenstr[2 - LSHIFT], \
                   TERN(PRINT_PROGRESS_SHOW_DECIMALS, permyriadtostr4(ui.get_progress_permyriad()), ui8tostr3rj(progress)), \

commit 574dd34c49fde76e1e736b8a7e1ea579d724ff22
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jun 27 13:19:36 2023 -0500

    ‚ôªÔ∏è String helper class (#24390)

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index 8e70941628..a6e942b706 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -568,16 +568,14 @@ void ST7920_Lite_Status_Screen::draw_feedrate_percentage(const uint16_t percenta
 }
 
 void ST7920_Lite_Status_Screen::draw_status_message() {
-  const char *str = ui.status_message;
-
   set_ddram_address(DDRAM_LINE_4);
   begin_data();
   #if ENABLED(STATUS_MESSAGE_SCROLLING)
-    uint8_t slen = utf8_strlen(str);
+    uint8_t slen = ui.status_message.glyphs();
 
     if (slen <= TEXT_MODE_LCD_WIDTH) {
       // String fits the LCD, so just print it
-      write_str(str);
+      write_str(ui.status_message);
       while (slen < TEXT_MODE_LCD_WIDTH) { write_byte(' '); ++slen; }
     }
     else {  // String is larger than the available space in ST7920_Lite_Status_Screen::
@@ -595,7 +593,7 @@ void ST7920_Lite_Status_Screen::draw_status_message() {
           write_byte(' ');
           if (--chars) {                            // Draw a third space if there's room
             write_byte(' ');
-            if (--chars) write_str(str, chars);     // Print a second copy of the message
+            if (--chars) write_str(ui.status_message, chars);  // Print a second copy of the message
           }
         }
       }
@@ -604,8 +602,8 @@ void ST7920_Lite_Status_Screen::draw_status_message() {
 
   #else
 
-    uint8_t slen = utf8_strlen(str);
-    write_str(str, TEXT_MODE_LCD_WIDTH);
+    uint8_t slen = ui.status_message.glyphs();
+    write_str(ui.status_message, TEXT_MODE_LCD_WIDTH);
     for (; slen < TEXT_MODE_LCD_WIDTH; ++slen) write_byte(' ');
 
   #endif
@@ -853,11 +851,10 @@ bool ST7920_Lite_Status_Screen::position_changed() {
 }
 
 bool ST7920_Lite_Status_Screen::status_changed() {
-  uint8_t checksum = 0;
-  for (const char *p = ui.status_message; *p; p++) checksum ^= *p;
-  static uint8_t last_checksum = 0;
-  bool changed = last_checksum != checksum;
-  if (changed) last_checksum = checksum;
+  static MString<>::hash_t last_hash = 0;
+  const MString<>::hash_t hash = ui.status_message.hash();
+  const bool changed = last_hash != hash;
+  if (changed) last_hash = hash;
   return changed;
 }
 
@@ -892,7 +889,7 @@ void ST7920_Lite_Status_Screen::update_status_or_position(bool forceUpdate) {
   if (forceUpdate || status_changed()) {
     TERN_(STATUS_MESSAGE_SCROLLING, ui.status_scroll_offset = 0);
     #if STATUS_EXPIRE_SECONDS
-      countdown = ui.status_message[0] ? STATUS_EXPIRE_SECONDS : 0;
+      countdown = !ui.status_message.empty() ? STATUS_EXPIRE_SECONDS : 0;
     #endif
     draw_status_message();
     blink_changed(); // Clear changed flag

commit 86c811660ebf0b3fcbae2f34273d4c9d0c22abc4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:30:34 2023 -0500

    üßë‚Äçüíª Remove LOOP macros (#25917)

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index bc961dbf15..8e70941628 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -237,7 +237,7 @@ void ST7920_Lite_Status_Screen::clear_ddram() {
 
 /* This fills the entire graphics buffer with zeros */
 void ST7920_Lite_Status_Screen::clear_gdram() {
-  LOOP_L_N(y, BUFFER_HEIGHT) {
+  for (uint8_t y = 0; y < BUFFER_HEIGHT; ++y) {
     set_gdram_address(0, y);
     begin_data();
     for (uint8_t i = (BUFFER_WIDTH) / 16; i--;) write_word(0);
@@ -435,7 +435,7 @@ void ST7920_Lite_Status_Screen::draw_degree_symbol(uint8_t x, uint8_t y, const b
     const uint8_t x_word  = x >> 1,
                   y_top   = degree_symbol_y_top,
                   y_bot   = y_top + COUNT(degree_symbol);
-    LOOP_S_L_N(i, y_top, y_bot) {
+    for (uint8_t i = y_top; i < y_bot; ++i) {
       uint8_t byte = pgm_read_byte(p_bytes++);
       set_gdram_address(x_word, i + y * 16);
       begin_data();
@@ -754,10 +754,10 @@ bool ST7920_Lite_Status_Screen::indicators_changed() {
     // This drawing is a mess and only produce readable result around 25% steps
     // i.e. 74-76% look fine [||||||||||||||||||||||||        ], but 73% look like this: [||||||||||||||||       |        ]
     // meaning partially filled bytes produce only single vertical line, and i bet they're not supposed to!
-    LOOP_S_LE_N(y, top, bottom) {
+    for (uint8_t y = top; y <= bottom; ++y) {
       set_gdram_address(left, y);
       begin_data();
-      LOOP_L_N(x, width) {
+      for (uint8_t x = 0; x < width; ++x) {
         uint16_t gfx_word = 0x0000;
         if ((x + 1) * char_pcnt <= value)
           gfx_word = 0xFFFF;                                              // Draw completely filled bytes

commit 9a7d9e6995f4f66c4b48147ec7876d49d4b3ae77
Author: Martin Turski <turningtides@outlook.de>
Date:   Thu Apr 27 14:05:24 2023 +0200

    üßë‚Äçüíª Optimize PlatformIO source filtering (#25332)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index a4ace1ce8a..bc961dbf15 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -73,7 +73,6 @@
 #if ENABLED(LIGHTWEIGHT_UI)
 
 #include "../marlinui.h"
-#include "../fontutils.h"
 #include "../lcdprint.h"
 #include "../../libs/duration_t.h"
 #include "../../module/motion.h"

commit 5664c02d077e028f84a24efd96c2eebe97ce8763
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 22 22:43:09 2023 -0500

    üßë‚Äçüíª Generalize SDSUPPORT as HAS_MEDIA
    
    In preparation for single- and multi-volume refactoring.

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index 96f2eeae96..a4ace1ce8a 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -81,7 +81,7 @@
 #include "../../module/temperature.h"
 #include "../../libs/numtostr.h"
 
-#if ENABLED(SDSUPPORT)
+#if HAS_MEDIA
   #include "../../sd/cardreader.h"
 #endif
 

commit 6d819eb8d419bad0bea5c9ce33a673eef5ef03eb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Apr 14 18:09:16 2023 -0500

    üßë‚Äçüíª Apply simplified ?:

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index 3d1594aca2..96f2eeae96 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -629,14 +629,14 @@ void ST7920_Lite_Status_Screen::draw_position(const xyze_pos_t &pos, const bool
     #endif
   }
   else {
-    write_byte(alt_label ? alt_label : 'X');
+    write_byte(alt_label ?: 'X');
     write_str(dtostrf(pos.x, -4, 0, str), 4);
 
-    write_byte(alt_label ? alt_label : 'Y');
+    write_byte(alt_label ?: 'Y');
     write_str(dtostrf(pos.y, -4, 0, str), 4);
   }
 
-  write_byte(alt_label ? alt_label : 'Z');
+  write_byte(alt_label ?: 'Z');
   write_str(dtostrf(pos.z, -5, 1, str), 5);
 }
 

commit b7c23631c5840e2338cae531b171459e9e9c5301
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Sun Jan 22 15:08:37 2023 +1300

    üêõ Fix misc. UI issues (#25252)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index 9ed0d8a9d6..3d1594aca2 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -705,7 +705,7 @@ bool ST7920_Lite_Status_Screen::indicators_changed() {
     void ST7920_Lite_Status_Screen::drawRemain() {
       const duration_t remaint = TERN0(SET_REMAINING_TIME, ui.get_remaining_time());
       if (printJobOngoing() && remaint.value) {
-        draw_progress_string( PPOS, prepare_time_string(remaint, 'R'));
+        draw_progress_string(PPOS, prepare_time_string(remaint, 'R'));
       }
     }
   #endif
@@ -714,7 +714,7 @@ bool ST7920_Lite_Status_Screen::indicators_changed() {
     void ST7920_Lite_Status_Screen::drawInter() {
       const duration_t interactt = ui.interaction_time;
       if (printingIsActive() && interactt.value) {
-        draw_progress_string( PPOS, prepare_time_string(interactt, 'C'));
+        draw_progress_string(PPOS, prepare_time_string(interactt, 'C'));
       }
     }
   #endif
@@ -723,7 +723,7 @@ bool ST7920_Lite_Status_Screen::indicators_changed() {
     void ST7920_Lite_Status_Screen::drawElapsed() {
       if (printJobOngoing()) {
         const duration_t elapsedt = print_job_timer.duration();
-        draw_progress_string( PPOS, prepare_time_string(elapsedt, 'E'));
+        draw_progress_string(PPOS, prepare_time_string(elapsedt, 'E'));
       }
     }
   #endif

commit f595e40ceb0c79d7f0d6438636658dfcfa2a75b8
Author: EvilGremlin <22657714+EvilGremlin@users.noreply.github.com>
Date:   Sun Oct 9 18:30:47 2022 +0300

    ‚ôªÔ∏è Set Progress without LCD (#24767)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index 492a79a311..9ed0d8a9d6 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -40,12 +40,38 @@
 // Lightweight Status Screen for Graphical Display
 //
 
+/** One hotend layout
+ *  ------------------
+ *  |‚ü± xxx‚ûúxxx¬∞ ‚ú±xxx%
+ *  |Ôºø xxx‚ûúxxx¬∞ Fxxx%
+ *  ||||||||||R‚Ä¢xxx:xx
+ *  |  status string
+ *  ------------------
+ *
+ *  hotend temp | fan speed
+ *  bed temp    | feedrate
+ *  progress bar| progress time
+ *       status string
+ *
+ * ****************************
+ *  Two hotends layout
+ *  ------------------
+ *  |‚ü± xxx‚ûúxxx¬∞ ‚ú±xxx%
+ *  |‚ü± xxx‚ûúxxx¬∞|||||||
+ *  |Ôºø xxx‚ûúxxx¬∞Rxxx:xx
+ *  |  status string
+ *  ------------------
+ *
+ *  hotend temp | fan speed
+ *  hotend temp | progress bar
+ *  bed temp    | progress time
+ *       status string
+ */
+
 #include "../../inc/MarlinConfigPre.h"
 
 #if ENABLED(LIGHTWEIGHT_UI)
 
-#include "status_screen_lite_ST7920.h"
-
 #include "../marlinui.h"
 #include "../fontutils.h"
 #include "../lcdprint.h"
@@ -53,12 +79,13 @@
 #include "../../module/motion.h"
 #include "../../module/printcounter.h"
 #include "../../module/temperature.h"
+#include "../../libs/numtostr.h"
 
 #if ENABLED(SDSUPPORT)
   #include "../../sd/cardreader.h"
 #endif
 
-#if ENABLED(LCD_SHOW_E_TOTAL)
+#if ENABLED(LCD_SHOW_E_TOTAL) || HAS_PRINT_PROGRESS
   #include "../../MarlinCore.h" // for printingIsActive
 #endif
 
@@ -72,6 +99,9 @@
 #define DDRAM_LINE_3   0x08
 #define DDRAM_LINE_4   0x18
 
+#include "status_screen_lite_ST7920.h"
+extern ST7920_Lite_Status_Screen lightUI;
+
 ST7920_Lite_Status_Screen::st7920_state_t ST7920_Lite_Status_Screen::current_bits;
 
 void ST7920_Lite_Status_Screen::cmd(const uint8_t cmd) {
@@ -442,72 +472,6 @@ void ST7920_Lite_Status_Screen::draw_static_elements() {
   draw_fan_icon(false);
 }
 
-/**
- * Although this is undocumented, the ST7920 allows the character
- * data buffer (DDRAM) to be used in conjunction with the graphics
- * bitmap buffer (CGRAM). The contents of the graphics buffer is
- * XORed with the data from the character generator. This allows
- * us to make the progress bar out of graphical data (the bar) and
- * text data (the percentage).
- */
-void ST7920_Lite_Status_Screen::draw_progress_bar(const uint8_t value) {
-  #if HOTENDS == 1
-    // If we have only one extruder, draw a long progress bar on the third line
-    constexpr uint8_t top     = 1,         // Top in pixels
-                      bottom  = 13,        // Bottom in pixels
-                      left    = 12,        // Left edge, in 16-bit words
-                      width   = 4;         // Width of progress bar, in 16-bit words
-  #else
-    constexpr uint8_t top     = 16 + 1,
-                      bottom  = 16 + 13,
-                      left    = 5,
-                      width   = 3;
-  #endif
-  const uint8_t char_pcnt  = 100 / width; // How many percent does each 16-bit word represent?
-
-  // Draw the progress bar as a bitmap in CGRAM
-  LOOP_S_LE_N(y, top, bottom) {
-    set_gdram_address(left, y);
-    begin_data();
-    LOOP_L_N(x, width) {
-      uint16_t gfx_word = 0x0000;
-      if ((x + 1) * char_pcnt <= value)
-        gfx_word = 0xFFFF;                                              // Draw completely filled bytes
-      else if ((x * char_pcnt) < value)
-        gfx_word = int(0x8000) >> (value % char_pcnt) * 16 / char_pcnt; // Draw partially filled bytes
-
-      // Draw the frame around the progress bar
-      if (y == top || y == bottom)
-        gfx_word = 0xFFFF;        // Draw top/bottom border
-      else if (x == width - 1)
-        gfx_word |= 0x0001;       // Draw right border
-      else if (x == 0)
-        gfx_word |= 0x8000;       // Draw left border
-      write_word(gfx_word);
-    }
-  }
-
-  // Draw the percentage as text in DDRAM
-  #if HOTENDS == 1
-    set_ddram_address(DDRAM_LINE_3 + 4);
-    begin_data();
-    write_byte(' ');
-  #else
-    set_ddram_address(DDRAM_LINE_2 + left);
-    begin_data();
-  #endif
-
-  // Draw centered
-  if (value > 9) {
-    write_number(value, 4);
-    write_str(F("% "));
-  }
-  else {
-    write_number(value, 3);
-    write_str(F("%  "));
-  }
-}
-
 void ST7920_Lite_Status_Screen::draw_fan_icon(const bool whichIcon) {
   set_ddram_address(DDRAM_LINE_1 + 5);
   begin_data();
@@ -592,22 +556,8 @@ void ST7920_Lite_Status_Screen::draw_fan_speed(const uint8_t value) {
   write_byte('%');
 }
 
-void ST7920_Lite_Status_Screen::draw_print_time(const duration_t &elapsed, char suffix) {
-  #if HOTENDS == 1
-    set_ddram_address(DDRAM_LINE_3);
-  #else
-    set_ddram_address(DDRAM_LINE_3 + 5);
-  #endif
-  char str[7];
-  int str_length = elapsed.toDigital(str);
-  str[str_length++] = suffix;
-  begin_data();
-  write_str(str, str_length);
-}
-
 void ST7920_Lite_Status_Screen::draw_feedrate_percentage(const uint16_t percentage) {
-  // We only have enough room for the feedrate when
-  // we have one extruder
+  // We only have enough room for the feedrate when we have one extruder
   #if HOTENDS == 1
     set_ddram_address(DDRAM_LINE_2 + 6);
     begin_data();
@@ -631,11 +581,9 @@ void ST7920_Lite_Status_Screen::draw_status_message() {
       write_str(str);
       while (slen < TEXT_MODE_LCD_WIDTH) { write_byte(' '); ++slen; }
     }
-    else {
-      // String is larger than the available space in screen.
+    else {  // String is larger than the available space in ST7920_Lite_Status_Screen::
 
-      // Get a pointer to the next valid UTF8 character
-      // and the string remaining length
+      // Get a pointer to the next valid UTF8 character and the string remaining length
       uint8_t rlen;
       const char *stat = ui.status_and_len(rlen);
       write_str(stat, TEXT_MODE_LCD_WIDTH);
@@ -643,12 +591,12 @@ void ST7920_Lite_Status_Screen::draw_status_message() {
       // If the remaining string doesn't completely fill the screen
       if (rlen < TEXT_MODE_LCD_WIDTH) {
         uint8_t chars = TEXT_MODE_LCD_WIDTH - rlen; // Amount of space left in characters
-        write_byte(' ');                        // Always at 1+ spaces left, draw a space
-        if (--chars) {                          // Draw a second space if there's room
+        write_byte(' ');                            // Always at 1+ spaces left, draw a space
+        if (--chars) {                              // Draw a second space if there's room
           write_byte(' ');
-          if (--chars) {                        // Draw a third space if there's room
+          if (--chars) {                            // Draw a third space if there's room
             write_byte(' ');
-            if (--chars) write_str(str, chars); // Print a second copy of the message
+            if (--chars) write_str(str, chars);     // Print a second copy of the message
           }
         }
       }
@@ -715,11 +663,155 @@ bool ST7920_Lite_Status_Screen::indicators_changed() {
   return true;
 }
 
+// Process progress strings
+#if HAS_PRINT_PROGRESS
+  static char screenstr[8];
+
+  char * ST7920_Lite_Status_Screen::prepare_time_string(const duration_t &time, char prefix) {
+    static char str[6];
+    memset(&screenstr, 0x20, 8); // fill with spaces to avoid artifacts, not doing right-justification to save cycles
+    screenstr[0] = prefix;
+    TERN_(HOTENDS == 1, screenstr[1] = 0x07;)  // add bullet ‚Ä¢ separator when there is space
+    int str_length = time.toDigital(str);
+    memcpy(&screenstr[TERN(HOTENDS == 1, 2, 1)], str, str_length); //memcpy because we can't have terminator
+    return screenstr;
+  }
+
+  void ST7920_Lite_Status_Screen::draw_progress_string(uint8_t addr, const char *str) {
+    set_ddram_address(addr);
+    begin_data();
+    write_str(str, TERN(HOTENDS == 1, 8, 6));
+  }
+
+  #define PPOS (DDRAM_LINE_3 + TERN(HOTENDS == 1, 4, 5)) // progress string position, in 16-bit words
+
+  #if ENABLED(SHOW_PROGRESS_PERCENT)
+    void MarlinUI::drawPercent() { lightUI.drawPercent(); }
+    void ST7920_Lite_Status_Screen::drawPercent() {
+      #define LSHIFT TERN(HOTENDS == 1, 0, 1)
+      const uint8_t progress = ui.get_progress_percent();
+      memset(&screenstr, 0x20, 8); // fill with spaces to avoid artifacts
+      if (progress){
+        memcpy(&screenstr[2 - LSHIFT], \
+                  TERN(PRINT_PROGRESS_SHOW_DECIMALS, permyriadtostr4(ui.get_progress_permyriad()), ui8tostr3rj(progress)), \
+                  TERN(PRINT_PROGRESS_SHOW_DECIMALS, 4, 3));
+        screenstr[(TERN(PRINT_PROGRESS_SHOW_DECIMALS, 6, 5) - LSHIFT)] = '%';
+        draw_progress_string(PPOS, screenstr);
+      }
+    }
+  #endif
+  #if ENABLED(SHOW_REMAINING_TIME)
+    void MarlinUI::drawRemain() { lightUI.drawRemain(); }
+    void ST7920_Lite_Status_Screen::drawRemain() {
+      const duration_t remaint = TERN0(SET_REMAINING_TIME, ui.get_remaining_time());
+      if (printJobOngoing() && remaint.value) {
+        draw_progress_string( PPOS, prepare_time_string(remaint, 'R'));
+      }
+    }
+  #endif
+  #if ENABLED(SHOW_INTERACTION_TIME)
+    void MarlinUI::drawInter() { lightUI.drawInter(); }
+    void ST7920_Lite_Status_Screen::drawInter() {
+      const duration_t interactt = ui.interaction_time;
+      if (printingIsActive() && interactt.value) {
+        draw_progress_string( PPOS, prepare_time_string(interactt, 'C'));
+      }
+    }
+  #endif
+  #if ENABLED(SHOW_ELAPSED_TIME)
+    void MarlinUI::drawElapsed() { lightUI.drawElapsed(); }
+    void ST7920_Lite_Status_Screen::drawElapsed() {
+      if (printJobOngoing()) {
+        const duration_t elapsedt = print_job_timer.duration();
+        draw_progress_string( PPOS, prepare_time_string(elapsedt, 'E'));
+      }
+    }
+  #endif
+
+  /**
+   * Although this is undocumented, the ST7920 allows the character
+   * data buffer (DDRAM) to be used in conjunction with the graphics
+   * bitmap buffer (CGRAM). The contents of the graphics buffer is
+   * XORed with the data from the character generator. This allows
+   * us to make the progress bar out of graphical data (the bar) and
+   * text data (the percentage).
+   */
+  void ST7920_Lite_Status_Screen::draw_progress_bar(const uint8_t value) {
+    #if HOTENDS == 1
+      // If we have only one extruder, draw a long progress bar on the third line
+      constexpr uint8_t top     = 1,         // Top in pixels
+                        bottom  = 13,        // Bottom in pixels
+                        left    = 8,         // Left edge, in 16-bit words
+                        width   = 4;         // Width of progress bar, in 16-bit words
+    #else
+      constexpr uint8_t top     = 16 + 1,
+                        bottom  = 16 + 13,
+                        left    = 5,
+                        width   = 3;
+    #endif
+    const uint8_t char_pcnt  = 100 / width; // How many percent does each 16-bit word represent?
+
+    // Draw the progress bar as a bitmap in CGRAM
+    // This drawing is a mess and only produce readable result around 25% steps
+    // i.e. 74-76% look fine [||||||||||||||||||||||||        ], but 73% look like this: [||||||||||||||||       |        ]
+    // meaning partially filled bytes produce only single vertical line, and i bet they're not supposed to!
+    LOOP_S_LE_N(y, top, bottom) {
+      set_gdram_address(left, y);
+      begin_data();
+      LOOP_L_N(x, width) {
+        uint16_t gfx_word = 0x0000;
+        if ((x + 1) * char_pcnt <= value)
+          gfx_word = 0xFFFF;                                              // Draw completely filled bytes
+        else if ((x * char_pcnt) < value)
+          gfx_word = int16_t(0x8000) >> (value % char_pcnt) * 16 / char_pcnt; // Draw partially filled bytes
+
+        // Draw the frame around the progress bar
+        if (y == top || y == bottom)
+          gfx_word = 0xFFFF;        // Draw top/bottom border
+        else if (x == width - 1)
+          gfx_word |= 0x0001;       // Draw right border
+        else if (x == 0)
+          gfx_word |= 0x8000;       // Draw left border
+        write_word(gfx_word);
+      }
+    }
+
+    // // Draw the percentage as text in DDRAM
+    // #if HOTENDS == 1
+    //   set_ddram_address(DDRAM_LINE_3 + 4);
+    //   begin_data();
+    //   write_byte(' ');
+    // #else
+    //   set_ddram_address(DDRAM_LINE_2 + left);
+    //   begin_data();
+    // #endif
+
+    // // Draw centered
+    // if (value > 9)
+    //   write_number(value, 4);
+    // else
+    //   write_number(value, 3);
+    // write_str(F("%  "));
+  }
+
+  void ST7920_Lite_Status_Screen::update_progress(const bool forceUpdate) {
+
+    // Since the progress bar involves writing
+    // quite a few bytes to GDRAM, only do this
+    // when an update is actually necessary.
+
+    const uint8_t progress = ui.get_progress_percent();
+    static uint8_t last_progress = 0;
+    if (forceUpdate || last_progress != progress/2) {
+      last_progress = progress/2;     // Because progress bar turns out only 62||46px wide, we only need to redraw it every 2%
+      draw_progress_bar(progress);
+    }
+  }
+#endif // HAS_PRINT_PROGRESS
+
 void ST7920_Lite_Status_Screen::update_indicators(const bool forceUpdate) {
   if (forceUpdate || indicators_changed()) {
     const bool       blink              = ui.get_blink();
-    const duration_t elapsed            = print_job_timer.duration();
-    duration_t       remaining          = TERN0(USE_M73_REMAINING_TIME, ui.get_remaining_time());
     const uint16_t   feedrate_perc      = feedrate_percentage;
     const celsius_t  extruder_1_temp    = thermalManager.wholeDegHotend(0),
                      extruder_1_target  = thermalManager.degTargetHotend(0);
@@ -736,30 +828,20 @@ void ST7920_Lite_Status_Screen::update_indicators(const bool forceUpdate) {
     TERN_(HAS_MULTI_HOTEND, draw_extruder_2_temp(extruder_2_temp, extruder_2_target, forceUpdate));
     TERN_(HAS_HEATED_BED, draw_bed_temp(bed_temp, bed_target, forceUpdate));
 
+    // Update the fan and bed animations
     uint8_t spd = thermalManager.fan_speed[0];
     #if ENABLED(ADAPTIVE_FAN_SLOWING)
       if (!blink && thermalManager.fan_speed_scaler[0] < 128)
         spd = thermalManager.scaledFanSpeed(0, spd);
     #endif
     draw_fan_speed(thermalManager.pwmToPercent(spd));
-
-    // Draw elapsed/remaining time
-    const bool show_remaining = ENABLED(SHOW_REMAINING_TIME) && (DISABLED(ROTATE_PROGRESS_DISPLAY) || blink);
-    if (show_remaining && !remaining.second()) {
-      const auto progress = ui.get_progress_percent();
-      if (progress)
-        remaining = elapsed.second() * (100 - progress) / progress;
-    }
-    if (show_remaining && remaining.second())
-      draw_print_time(remaining, 'R');
-    else
-      draw_print_time(elapsed);
+    if (spd) draw_fan_icon(blink);
+    TERN_(HAS_HEATED_BED, draw_heat_icon(bed_target > 0 && blink, bed_target > 0));
 
     draw_feedrate_percentage(feedrate_perc);
 
-    // Update the fan and bed animations
-    if (spd) draw_fan_icon(blink);
-    TERN_(HAS_HEATED_BED, draw_heat_icon(bed_target > 0 && blink, bed_target > 0));
+    // Update and draw progress strings
+    TERN_(HAS_PRINT_PROGRESS, ui.rotate_progress());
   }
 }
 
@@ -839,27 +921,6 @@ void ST7920_Lite_Status_Screen::update_status_or_position(bool forceUpdate) {
   #endif
 }
 
-void ST7920_Lite_Status_Screen::update_progress(const bool forceUpdate) {
-  #if EITHER(LCD_SET_PROGRESS_MANUALLY, SDSUPPORT)
-
-    // Since the progress bar involves writing
-    // quite a few bytes to GDRAM, only do this
-    // when an update is actually necessary.
-
-    static uint8_t last_progress = 0;
-    const uint8_t progress = ui.get_progress_percent();
-    if (forceUpdate || last_progress != progress) {
-      last_progress = progress;
-      draw_progress_bar(progress);
-    }
-
-  #else
-
-    UNUSED(forceUpdate);
-
-  #endif
-}
-
 void ST7920_Lite_Status_Screen::update(const bool forceUpdate) {
   cs();
   update_indicators(forceUpdate);
@@ -902,7 +963,7 @@ void ST7920_Lite_Status_Screen::clear_text_buffer() {
 }
 
 void MarlinUI::draw_status_screen() {
-  ST7920_Lite_Status_Screen::update(false);
+  lightUI.update(false);
 }
 
 // This method is called before each screen update and
@@ -912,9 +973,9 @@ void MarlinUI::lcd_in_status(const bool inStatus) {
   static bool lastInStatus = false;
   if (lastInStatus == inStatus) return;
   if ((lastInStatus = inStatus))
-    ST7920_Lite_Status_Screen::on_entry();
+    lightUI.on_entry();
   else
-    ST7920_Lite_Status_Screen::on_exit();
+    lightUI.on_exit();
 }
 
 #endif // LIGHTWEIGHT_UI

commit 36b2650f65e036ce1b02da568364230201a22b80
Author: Mikhail Basov <github@basov.net>
Date:   Mon Nov 15 07:46:34 2021 +0300

    üö∏ LCD_SHOW_E_TOTAL for TFT_COLOR_UI (#23127)

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index 2e6d697488..492a79a311 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -672,14 +672,7 @@ void ST7920_Lite_Status_Screen::draw_position(const xyze_pos_t &pos, const bool
   // If position is unknown, flash the labels.
   const unsigned char alt_label = position_trusted ? 0 : (ui.get_blink() ? ' ' : 0);
 
-  if (TERN1(LCD_SHOW_E_TOTAL, !printingIsActive())) {
-    write_byte(alt_label ? alt_label : 'X');
-    write_str(dtostrf(pos.x, -4, 0, str), 4);
-
-    write_byte(alt_label ? alt_label : 'Y');
-    write_str(dtostrf(pos.y, -4, 0, str), 4);
-  }
-  else {
+  if (TERN0(LCD_SHOW_E_TOTAL, printingIsActive())) {
     #if ENABLED(LCD_SHOW_E_TOTAL)
       char tmp[15];
       const uint8_t escale = e_move_accumulator >= 100000.0f ? 10 : 1; // After 100m switch to cm
@@ -687,6 +680,13 @@ void ST7920_Lite_Status_Screen::draw_position(const xyze_pos_t &pos, const bool
       write_str(tmp);
     #endif
   }
+  else {
+    write_byte(alt_label ? alt_label : 'X');
+    write_str(dtostrf(pos.x, -4, 0, str), 4);
+
+    write_byte(alt_label ? alt_label : 'Y');
+    write_str(dtostrf(pos.y, -4, 0, str), 4);
+  }
 
   write_byte(alt_label ? alt_label : 'Z');
   write_str(dtostrf(pos.z, -5, 1, str), 5);

commit eeffac697c5d7b69e01e38ed1602dbd21a366e93
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Sep 25 23:52:41 2021 -0500

    üé® Apply F() to UTF-8/MMU2 string put

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index be112c8d54..2e6d697488 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -99,9 +99,9 @@ void ST7920_Lite_Status_Screen::write_str(const char *str, uint8_t len) {
   while (*str && len--) write_byte(*str++);
 }
 
-void ST7920_Lite_Status_Screen::write_str_P(PGM_P const str) {
-  PGM_P p_str = (PGM_P)str;
-  while (char c = pgm_read_byte(p_str++)) write_byte(c);
+void ST7920_Lite_Status_Screen::write_str(FSTR_P const fstr) {
+  PGM_P pstr = FTOP(fstr);
+  while (char c = pgm_read_byte(pstr++)) write_byte(c);
 }
 
 void ST7920_Lite_Status_Screen::write_number(const int16_t value, const uint8_t digits/*=3*/) {
@@ -500,11 +500,11 @@ void ST7920_Lite_Status_Screen::draw_progress_bar(const uint8_t value) {
   // Draw centered
   if (value > 9) {
     write_number(value, 4);
-    write_str_P(PSTR("% "));
+    write_str(F("% "));
   }
   else {
     write_number(value, 3);
-    write_str_P(PSTR("%  "));
+    write_str(F("%  "));
   }
 }
 
@@ -559,7 +559,7 @@ void ST7920_Lite_Status_Screen::draw_temps(uint8_t line, const int16_t temp, con
   };
 
   if (targetStateChange) {
-    if (!showTarget) write_str_P(PSTR("    "));
+    if (!showTarget) write_str(F("    "));
     draw_degree_symbol(5, line, !showTarget);
     draw_degree_symbol(9, line,  showTarget);
   }

commit afca6e745932d295b88d37fa9bd4274e22705b0b
Author: luzpaz <luzpaz@users.noreply.github.com>
Date:   Tue Aug 3 20:02:34 2021 -0400

    üêõ Spellcheck comments (#22496)
    
    codespell -q 3 --builtin=clear,rare,informal,code -S ./Marlin/src/lcd/language -L alo,amin,endcode,stdio,uint

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index c76857b6bb..be112c8d54 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -447,7 +447,7 @@ void ST7920_Lite_Status_Screen::draw_static_elements() {
  * data buffer (DDRAM) to be used in conjunction with the graphics
  * bitmap buffer (CGRAM). The contents of the graphics buffer is
  * XORed with the data from the character generator. This allows
- * us to make the progess bar out of graphical data (the bar) and
+ * us to make the progress bar out of graphical data (the bar) and
  * text data (the percentage).
  */
 void ST7920_Lite_Status_Screen::draw_progress_bar(const uint8_t value) {

commit 26bfc267977ddc444513c793c18f76847e23310e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jul 9 17:09:58 2021 -0500

    üé® Check flags without ENABLED

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index 2f8b5f67e2..c76857b6bb 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -536,7 +536,7 @@ void ST7920_Lite_Status_Screen::draw_heat_icon(const bool whichIcon, const bool
 static struct {
   bool E1_show_target  : 1;
   bool E2_show_target  : 1;
-  #if ENABLED(HAS_HEATED_BED)
+  #if HAS_HEATED_BED
     bool bed_show_target : 1;
   #endif
 } display_state = {

commit c4620bb5285438e41fa4c39229aa2a39859877ca
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Apr 23 20:19:23 2021 -0500

    Add whole-degree accessors, simplify some temperature-related features (#21685)

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index b8257d32ff..2f8b5f67e2 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -721,14 +721,14 @@ void ST7920_Lite_Status_Screen::update_indicators(const bool forceUpdate) {
     const duration_t elapsed            = print_job_timer.duration();
     duration_t       remaining          = TERN0(USE_M73_REMAINING_TIME, ui.get_remaining_time());
     const uint16_t   feedrate_perc      = feedrate_percentage;
-    const celsius_t  extruder_1_temp    = thermalManager.degHotend(0),
+    const celsius_t  extruder_1_temp    = thermalManager.wholeDegHotend(0),
                      extruder_1_target  = thermalManager.degTargetHotend(0);
     #if HAS_MULTI_HOTEND
-      const celsius_t extruder_2_temp   = thermalManager.degHotend(1),
+      const celsius_t extruder_2_temp   = thermalManager.wholeDegHotend(1),
                       extruder_2_target = thermalManager.degTargetHotend(1);
     #endif
     #if HAS_HEATED_BED
-      const celsius_t bed_temp          = thermalManager.degBed(),
+      const celsius_t bed_temp          = thermalManager.wholeDegBed(),
                       bed_target        = thermalManager.degTargetBed();
     #endif
 

commit cc5297d637d2a0a784e336210c366baf250785d0
Author: XDA-Bam <1209896+XDA-Bam@users.noreply.github.com>
Date:   Wed Apr 14 11:42:04 2021 +0200

    Space-separate scrolling Status Message (#21523)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index b67688cb57..b8257d32ff 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -642,11 +642,14 @@ void ST7920_Lite_Status_Screen::draw_status_message() {
 
       // If the remaining string doesn't completely fill the screen
       if (rlen < TEXT_MODE_LCD_WIDTH) {
-        write_byte('.');                        // Always at 1+ spaces left, draw a dot
-        uint8_t chars = TEXT_MODE_LCD_WIDTH - rlen;       // Amount of space left in characters
-        if (--chars) {                          // Draw a second dot if there's space
-          write_byte('.');
-          if (--chars) write_str(str, chars);   // Print a second copy of the message
+        uint8_t chars = TEXT_MODE_LCD_WIDTH - rlen; // Amount of space left in characters
+        write_byte(' ');                        // Always at 1+ spaces left, draw a space
+        if (--chars) {                          // Draw a second space if there's room
+          write_byte(' ');
+          if (--chars) {                        // Draw a third space if there's room
+            write_byte(' ');
+            if (--chars) write_str(str, chars); // Print a second copy of the message
+          }
         }
       }
       ui.advance_status_scroll();

commit fd99ea09ecb41bc1dfc5e4109e0d6c7de1f87424
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Apr 13 04:00:39 2021 -0500

    Add fan percent accessors

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index a2dfb74a57..b67688cb57 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -733,14 +733,12 @@ void ST7920_Lite_Status_Screen::update_indicators(const bool forceUpdate) {
     TERN_(HAS_MULTI_HOTEND, draw_extruder_2_temp(extruder_2_temp, extruder_2_target, forceUpdate));
     TERN_(HAS_HEATED_BED, draw_bed_temp(bed_temp, bed_target, forceUpdate));
 
-    uint16_t spd = thermalManager.fan_speed[0];
-
+    uint8_t spd = thermalManager.fan_speed[0];
     #if ENABLED(ADAPTIVE_FAN_SLOWING)
       if (!blink && thermalManager.fan_speed_scaler[0] < 128)
         spd = thermalManager.scaledFanSpeed(0, spd);
     #endif
-
-    draw_fan_speed(thermalManager.fanPercent(spd));
+    draw_fan_speed(thermalManager.pwmToPercent(spd));
 
     // Draw elapsed/remaining time
     const bool show_remaining = ENABLED(SHOW_REMAINING_TIME) && (DISABLED(ROTATE_PROGRESS_DISPLAY) || blink);

commit 2d2291d00eab6159de24eb7ff74001b1d6dd29e4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 24 05:40:28 2021 -0500

    More IntelliSense-friendly declarations

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index dcb65f676d..a2dfb74a57 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -536,7 +536,9 @@ void ST7920_Lite_Status_Screen::draw_heat_icon(const bool whichIcon, const bool
 static struct {
   bool E1_show_target  : 1;
   bool E2_show_target  : 1;
-  TERN_(HAS_HEATED_BED, bool bed_show_target : 1);
+  #if ENABLED(HAS_HEATED_BED)
+    bool bed_show_target : 1;
+  #endif
 } display_state = {
   true, true, TERN_(HAS_HEATED_BED, true)
 };

commit e5ff55a1be7646b6159e6dedac50bfbe57e6dfa0
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 24 04:11:43 2021 -0500

    Add typedef celsius_t (#21374)

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index a538121d2c..dcb65f676d 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -691,15 +691,15 @@ bool ST7920_Lite_Status_Screen::indicators_changed() {
   // We only add the target temperatures to the checksum
   // because the actual temps fluctuate so by updating
   // them only during blinks we gain a bit of stability.
-  const bool       blink             = ui.get_blink();
-  const uint16_t   feedrate_perc     = feedrate_percentage;
-  const uint16_t   fs                = thermalManager.scaledFanSpeed(0);
-  const int16_t    extruder_1_target = thermalManager.degTargetHotend(0);
+  const bool blink = ui.get_blink();
+  const uint16_t feedrate_perc = feedrate_percentage;
+  const uint16_t fs = thermalManager.scaledFanSpeed(0);
+  const celsius_t extruder_1_target = thermalManager.degTargetHotend(0);
   #if HAS_MULTI_HOTEND
-    const int16_t  extruder_2_target = thermalManager.degTargetHotend(1);
+    const celsius_t extruder_2_target = thermalManager.degTargetHotend(1);
   #endif
   #if HAS_HEATED_BED
-    const int16_t  bed_target        = thermalManager.degTargetBed();
+    const celsius_t bed_target = thermalManager.degTargetBed();
   #endif
   static uint16_t last_checksum = 0;
   const uint16_t checksum = blink ^ feedrate_perc ^ fs ^ extruder_1_target
@@ -712,19 +712,19 @@ bool ST7920_Lite_Status_Screen::indicators_changed() {
 
 void ST7920_Lite_Status_Screen::update_indicators(const bool forceUpdate) {
   if (forceUpdate || indicators_changed()) {
-    const bool       blink             = ui.get_blink();
-    const duration_t elapsed           = print_job_timer.duration();
-    duration_t       remaining         = TERN0(USE_M73_REMAINING_TIME, ui.get_remaining_time());
-    const uint16_t   feedrate_perc     = feedrate_percentage;
-    const int16_t    extruder_1_temp   = thermalManager.degHotend(0),
-                     extruder_1_target = thermalManager.degTargetHotend(0);
+    const bool       blink              = ui.get_blink();
+    const duration_t elapsed            = print_job_timer.duration();
+    duration_t       remaining          = TERN0(USE_M73_REMAINING_TIME, ui.get_remaining_time());
+    const uint16_t   feedrate_perc      = feedrate_percentage;
+    const celsius_t  extruder_1_temp    = thermalManager.degHotend(0),
+                     extruder_1_target  = thermalManager.degTargetHotend(0);
     #if HAS_MULTI_HOTEND
-      const int16_t  extruder_2_temp   = thermalManager.degHotend(1),
-                     extruder_2_target = thermalManager.degTargetHotend(1);
+      const celsius_t extruder_2_temp   = thermalManager.degHotend(1),
+                      extruder_2_target = thermalManager.degTargetHotend(1);
     #endif
     #if HAS_HEATED_BED
-      const int16_t  bed_temp          = thermalManager.degBed(),
-                     bed_target        = thermalManager.degTargetBed();
+      const celsius_t bed_temp          = thermalManager.degBed(),
+                      bed_target        = thermalManager.degTargetBed();
     #endif
 
     draw_extruder_1_temp(extruder_1_temp, extruder_1_target, forceUpdate);

commit 8fd8772a6fffe63d99d0b88aec7a77d283df8584
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Nov 29 19:06:40 2020 -0600

    Adjust axis homed / trusted methods (#20323)

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index c06080f601..a538121d2c 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -659,13 +659,13 @@ void ST7920_Lite_Status_Screen::draw_status_message() {
   #endif
 }
 
-void ST7920_Lite_Status_Screen::draw_position(const xyze_pos_t &pos, const bool position_known) {
+void ST7920_Lite_Status_Screen::draw_position(const xyze_pos_t &pos, const bool position_trusted) {
   char str[7];
   set_ddram_address(DDRAM_LINE_4);
   begin_data();
 
   // If position is unknown, flash the labels.
-  const unsigned char alt_label = position_known ? 0 : (ui.get_blink() ? ' ' : 0);
+  const unsigned char alt_label = position_trusted ? 0 : (ui.get_blink() ? ' ' : 0);
 
   if (TERN1(LCD_SHOW_E_TOTAL, !printingIsActive())) {
     write_byte(alt_label ? alt_label : 'X');
@@ -831,9 +831,8 @@ void ST7920_Lite_Status_Screen::update_status_or_position(bool forceUpdate) {
       }
     }
 
-    if (countdown == 0 && (forceUpdate || position_changed()
-      || TERN(DISABLE_REDUCED_ACCURACY_WARNING, 0, blink_changed())
-    )) draw_position(current_position, TERN(DISABLE_REDUCED_ACCURACY_WARNING, 1, all_axes_known()));
+    if (countdown == 0 && (forceUpdate || position_changed() || TERN(DISABLE_REDUCED_ACCURACY_WARNING, 0, blink_changed())))
+      draw_position(current_position, TERN(DISABLE_REDUCED_ACCURACY_WARNING, 1, all_axes_trusted()));
   #endif
 }
 
@@ -855,7 +854,7 @@ void ST7920_Lite_Status_Screen::update_progress(const bool forceUpdate) {
 
     UNUSED(forceUpdate);
 
-  #endif // LCD_SET_PROGRESS_MANUALLY || SDSUPPORT
+  #endif
 }
 
 void ST7920_Lite_Status_Screen::update(const bool forceUpdate) {

commit eaf6777a6643a6fab23ceaaa4699cb2466ea6b83
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Oct 16 19:36:25 2020 -0500

    Rename ultralcd => marlinui

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index 806f370db3..c06080f601 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -46,7 +46,7 @@
 
 #include "status_screen_lite_ST7920.h"
 
-#include "../ultralcd.h"
+#include "../marlinui.h"
 #include "../fontutils.h"
 #include "../lcdprint.h"
 #include "../../libs/duration_t.h"

commit 4424645e04c9e75462d36de8f7a82e67cc9c262e
Author: qwewer0 <57561110+qwewer0@users.noreply.github.com>
Date:   Mon Sep 28 21:53:50 2020 +0200

    Multi-line comments cleanup (#19535)

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index 211acc86c6..806f370db3 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -11,7 +11,6 @@
  * any later version.  The code is distributed WITHOUT ANY WARRANTY;
  * without even the implied warranty of MERCHANTABILITY or FITNESS
  * FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.
- *
  */
 
 /**

commit b15c207d0899e838d41bd1dd684917769b93b89d
Author: ftk <ftk@users.noreply.github.com>
Date:   Mon Aug 10 01:19:35 2020 +0300

    Remaining Time for LIGHTWEIGHT_UI (#18875)

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index fba485d706..211acc86c6 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -591,16 +591,17 @@ void ST7920_Lite_Status_Screen::draw_fan_speed(const uint8_t value) {
   write_byte('%');
 }
 
-void ST7920_Lite_Status_Screen::draw_print_time(const duration_t &elapsed) {
+void ST7920_Lite_Status_Screen::draw_print_time(const duration_t &elapsed, char suffix) {
   #if HOTENDS == 1
     set_ddram_address(DDRAM_LINE_3);
   #else
     set_ddram_address(DDRAM_LINE_3 + 5);
   #endif
   char str[7];
-  str[elapsed.toDigital(str)] = ' ';
+  int str_length = elapsed.toDigital(str);
+  str[str_length++] = suffix;
   begin_data();
-  write_str(str, 6);
+  write_str(str, str_length);
 }
 
 void ST7920_Lite_Status_Screen::draw_feedrate_percentage(const uint16_t percentage) {
@@ -714,6 +715,7 @@ void ST7920_Lite_Status_Screen::update_indicators(const bool forceUpdate) {
   if (forceUpdate || indicators_changed()) {
     const bool       blink             = ui.get_blink();
     const duration_t elapsed           = print_job_timer.duration();
+    duration_t       remaining         = TERN0(USE_M73_REMAINING_TIME, ui.get_remaining_time());
     const uint16_t   feedrate_perc     = feedrate_percentage;
     const int16_t    extruder_1_temp   = thermalManager.degHotend(0),
                      extruder_1_target = thermalManager.degTargetHotend(0);
@@ -738,7 +740,19 @@ void ST7920_Lite_Status_Screen::update_indicators(const bool forceUpdate) {
     #endif
 
     draw_fan_speed(thermalManager.fanPercent(spd));
-    draw_print_time(elapsed);
+
+    // Draw elapsed/remaining time
+    const bool show_remaining = ENABLED(SHOW_REMAINING_TIME) && (DISABLED(ROTATE_PROGRESS_DISPLAY) || blink);
+    if (show_remaining && !remaining.second()) {
+      const auto progress = ui.get_progress_percent();
+      if (progress)
+        remaining = elapsed.second() * (100 - progress) / progress;
+    }
+    if (show_remaining && remaining.second())
+      draw_print_time(remaining, 'R');
+    else
+      draw_print_time(elapsed);
+
     draw_feedrate_percentage(feedrate_perc);
 
     // Update the fan and bed animations

commit 3b1f84a9b74888f0cbdde33296f26da64e2288b7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Aug 4 03:21:19 2020 -0500

    Followup to #18906 Z_AFTER_DEACTIVATE

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index 18894db3d6..fba485d706 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -820,8 +820,7 @@ void ST7920_Lite_Status_Screen::update_status_or_position(bool forceUpdate) {
 
     if (countdown == 0 && (forceUpdate || position_changed()
       || TERN(DISABLE_REDUCED_ACCURACY_WARNING, 0, blink_changed())
-    ))
-      draw_position(current_position, TERN(DISABLE_REDUCED_ACCURACY_WARNING, 0, all_axes_known()));
+    )) draw_position(current_position, TERN(DISABLE_REDUCED_ACCURACY_WARNING, 1, all_axes_known()));
   #endif
 }
 

commit 4856ac50281291790405a0fd35be88d035416b7a
Author: swissnorp <67485708+swissnorp@users.noreply.github.com>
Date:   Tue Aug 4 07:31:45 2020 +0200

    Add Z_AFTER_DEACTIVATE to account for gravity (#18906)

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index 9338ab82e8..18894db3d6 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -819,16 +819,9 @@ void ST7920_Lite_Status_Screen::update_status_or_position(bool forceUpdate) {
     }
 
     if (countdown == 0 && (forceUpdate || position_changed()
-      #if DISABLED(DISABLE_REDUCED_ACCURACY_WARNING)
-        || blink_changed()
-      #endif
-    )) {
-      draw_position(current_position, true
-        #if DISABLED(DISABLE_REDUCED_ACCURACY_WARNING)
-          && all_axes_known()
-        #endif
-      );
-    }
+      || TERN(DISABLE_REDUCED_ACCURACY_WARNING, 0, blink_changed())
+    ))
+      draw_position(current_position, TERN(DISABLE_REDUCED_ACCURACY_WARNING, 0, all_axes_known()));
   #endif
 }
 

commit 9b90dfaa482182d964d291ad226e3123f612f266
Author: grauerfuchs <42082416+grauerfuchs@users.noreply.github.com>
Date:   Mon Apr 27 10:26:45 2020 -0400

    Fix draw_temps missing define compile (#17750)

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index 0342d73607..9338ab82e8 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -579,7 +579,7 @@ void ST7920_Lite_Status_Screen::draw_extruder_2_temp(const int16_t temp, const i
 #if HAS_HEATED_BED
   void ST7920_Lite_Status_Screen::draw_bed_temp(const int16_t temp, const int16_t target, bool forceUpdate) {
     const bool show_target = target && FAR(temp, target);
-    draw_temps(HAS_MULTI_HOTEND ? 2 : 1, temp, target, show_target, display_state.bed_show_target != show_target || forceUpdate);
+    draw_temps(TERN(HAS_MULTI_HOTEND, 2, 1), temp, target, show_target, display_state.bed_show_target != show_target || forceUpdate);
     display_state.bed_show_target = show_target;
   }
 #endif

commit 6d90d1e1f552dca5e21bc61b676b8e8ce731b280
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 22 16:35:03 2020 -0500

    Apply TERN to compact code (#17619)

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index 64c6711fe8..0342d73607 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -537,14 +537,9 @@ void ST7920_Lite_Status_Screen::draw_heat_icon(const bool whichIcon, const bool
 static struct {
   bool E1_show_target  : 1;
   bool E2_show_target  : 1;
-  #if HAS_HEATED_BED
-    bool bed_show_target : 1;
-  #endif
+  TERN_(HAS_HEATED_BED, bool bed_show_target : 1);
 } display_state = {
-  true, true
-  #if HAS_HEATED_BED
-    , true
-  #endif
+  true, true, TERN_(HAS_HEATED_BED, true)
 };
 
 void ST7920_Lite_Status_Screen::draw_temps(uint8_t line, const int16_t temp, const int16_t target, bool showTarget, bool targetStateChange) {
@@ -672,11 +667,7 @@ void ST7920_Lite_Status_Screen::draw_position(const xyze_pos_t &pos, const bool
   // If position is unknown, flash the labels.
   const unsigned char alt_label = position_known ? 0 : (ui.get_blink() ? ' ' : 0);
 
-  if (true
-    #if ENABLED(LCD_SHOW_E_TOTAL)
-      && !printingIsActive()
-    #endif
-  ) {
+  if (TERN1(LCD_SHOW_E_TOTAL, !printingIsActive())) {
     write_byte(alt_label ? alt_label : 'X');
     write_str(dtostrf(pos.x, -4, 0, str), 4);
 
@@ -712,13 +703,8 @@ bool ST7920_Lite_Status_Screen::indicators_changed() {
   #endif
   static uint16_t last_checksum = 0;
   const uint16_t checksum = blink ^ feedrate_perc ^ fs ^ extruder_1_target
-    #if HOTENDS > 1
-      ^ extruder_2_target
-    #endif
-    #if HAS_HEATED_BED
-      ^ bed_target
-    #endif
-  ;
+    ^ TERN0(HAS_MULTI_HOTEND, extruder_2_target)
+    ^ TERN0(HAS_HEATED_BED, bed_target);
   if (last_checksum == checksum) return false;
   last_checksum = checksum;
   return true;
@@ -741,12 +727,8 @@ void ST7920_Lite_Status_Screen::update_indicators(const bool forceUpdate) {
     #endif
 
     draw_extruder_1_temp(extruder_1_temp, extruder_1_target, forceUpdate);
-    #if HAS_MULTI_HOTEND
-      draw_extruder_2_temp(extruder_2_temp, extruder_2_target, forceUpdate);
-    #endif
-    #if HAS_HEATED_BED
-      draw_bed_temp(bed_temp, bed_target, forceUpdate);
-    #endif
+    TERN_(HAS_MULTI_HOTEND, draw_extruder_2_temp(extruder_2_temp, extruder_2_target, forceUpdate));
+    TERN_(HAS_HEATED_BED, draw_bed_temp(bed_temp, bed_target, forceUpdate));
 
     uint16_t spd = thermalManager.fan_speed[0];
 
@@ -761,9 +743,7 @@ void ST7920_Lite_Status_Screen::update_indicators(const bool forceUpdate) {
 
     // Update the fan and bed animations
     if (spd) draw_fan_icon(blink);
-    #if HAS_HEATED_BED
-      draw_heat_icon(bed_target > 0 && blink, bed_target > 0);
-    #endif
+    TERN_(HAS_HEATED_BED, draw_heat_icon(bed_target > 0 && blink, bed_target > 0));
   }
 }
 
@@ -813,9 +793,7 @@ void ST7920_Lite_Status_Screen::update_status_or_position(bool forceUpdate) {
    * If STATUS_EXPIRE_SECONDS is zero, only the status is shown.
    */
   if (forceUpdate || status_changed()) {
-    #if ENABLED(STATUS_MESSAGE_SCROLLING)
-      ui.status_scroll_offset = 0;
-    #endif
+    TERN_(STATUS_MESSAGE_SCROLLING, ui.status_scroll_offset = 0);
     #if STATUS_EXPIRE_SECONDS
       countdown = ui.status_message[0] ? STATUS_EXPIRE_SECONDS : 0;
     #endif
@@ -823,26 +801,20 @@ void ST7920_Lite_Status_Screen::update_status_or_position(bool forceUpdate) {
     blink_changed(); // Clear changed flag
   }
   #if !STATUS_EXPIRE_SECONDS
-    #if ENABLED(STATUS_MESSAGE_SCROLLING)
-      else if (blink_changed())
-        draw_status_message();
-    #endif
+    else if (TERN0(STATUS_MESSAGE_SCROLLING, blink_changed()))
+      draw_status_message();
   #else
     else if (blink_changed()) {
       if (countdown > 1) {
         countdown--;
-        #if ENABLED(STATUS_MESSAGE_SCROLLING)
-          draw_status_message();
-        #endif
+        TERN_(STATUS_MESSAGE_SCROLLING, draw_status_message());
       }
       else if (countdown > 0) {
         if (position_changed()) {
           countdown--;
           forceUpdate = true;
         }
-        #if ENABLED(STATUS_MESSAGE_SCROLLING)
-          draw_status_message();
-        #endif
+        TERN_(STATUS_MESSAGE_SCROLLING, draw_status_message());
       }
     }
 

commit 15f6f53638a6778d22a17e1900fb3a9fdc92dade
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Apr 19 23:56:55 2020 -0500

    Add HAS_HOTEND, etc.

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index e623776b31..64c6711fe8 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -431,7 +431,7 @@ void ST7920_Lite_Status_Screen::draw_static_elements() {
 
   // Draw the static icons in GDRAM
   draw_gdram_icon(0, 0, nozzle_icon);
-  #if HOTENDS > 1
+  #if HAS_MULTI_HOTEND
     draw_gdram_icon(0, 1, nozzle_icon);
     draw_gdram_icon(0, 2, bed_icon);
   #else
@@ -584,7 +584,7 @@ void ST7920_Lite_Status_Screen::draw_extruder_2_temp(const int16_t temp, const i
 #if HAS_HEATED_BED
   void ST7920_Lite_Status_Screen::draw_bed_temp(const int16_t temp, const int16_t target, bool forceUpdate) {
     const bool show_target = target && FAR(temp, target);
-    draw_temps(HOTENDS > 1 ? 2 : 1, temp, target, show_target, display_state.bed_show_target != show_target || forceUpdate);
+    draw_temps(HAS_MULTI_HOTEND ? 2 : 1, temp, target, show_target, display_state.bed_show_target != show_target || forceUpdate);
     display_state.bed_show_target = show_target;
   }
 #endif
@@ -704,7 +704,7 @@ bool ST7920_Lite_Status_Screen::indicators_changed() {
   const uint16_t   feedrate_perc     = feedrate_percentage;
   const uint16_t   fs                = thermalManager.scaledFanSpeed(0);
   const int16_t    extruder_1_target = thermalManager.degTargetHotend(0);
-  #if HOTENDS > 1
+  #if HAS_MULTI_HOTEND
     const int16_t  extruder_2_target = thermalManager.degTargetHotend(1);
   #endif
   #if HAS_HEATED_BED
@@ -731,7 +731,7 @@ void ST7920_Lite_Status_Screen::update_indicators(const bool forceUpdate) {
     const uint16_t   feedrate_perc     = feedrate_percentage;
     const int16_t    extruder_1_temp   = thermalManager.degHotend(0),
                      extruder_1_target = thermalManager.degTargetHotend(0);
-    #if HOTENDS > 1
+    #if HAS_MULTI_HOTEND
       const int16_t  extruder_2_temp   = thermalManager.degHotend(1),
                      extruder_2_target = thermalManager.degTargetHotend(1);
     #endif
@@ -741,7 +741,7 @@ void ST7920_Lite_Status_Screen::update_indicators(const bool forceUpdate) {
     #endif
 
     draw_extruder_1_temp(extruder_1_temp, extruder_1_target, forceUpdate);
-    #if HOTENDS > 1
+    #if HAS_MULTI_HOTEND
       draw_extruder_2_temp(extruder_2_temp, extruder_2_target, forceUpdate);
     #endif
     #if HAS_HEATED_BED

commit 118bd2f8b2a1f81884cb55a8fc00b708a51aa15b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 13 23:18:16 2020 -0500

    Apply loop shorthand macros (#17159)

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index f5931917ae..e623776b31 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -209,7 +209,7 @@ void ST7920_Lite_Status_Screen::clear_ddram() {
 
 /* This fills the entire graphics buffer with zeros */
 void ST7920_Lite_Status_Screen::clear_gdram() {
-  for (uint8_t y = 0; y < BUFFER_HEIGHT; y++) {
+  LOOP_L_N(y, BUFFER_HEIGHT) {
     set_gdram_address(0, y);
     begin_data();
     for (uint8_t i = (BUFFER_WIDTH) / 16; i--;) write_word(0);
@@ -407,7 +407,7 @@ void ST7920_Lite_Status_Screen::draw_degree_symbol(uint8_t x, uint8_t y, const b
     const uint8_t x_word  = x >> 1,
                   y_top   = degree_symbol_y_top,
                   y_bot   = y_top + COUNT(degree_symbol);
-    for (uint8_t i = y_top; i < y_bot; i++) {
+    LOOP_S_L_N(i, y_top, y_bot) {
       uint8_t byte = pgm_read_byte(p_bytes++);
       set_gdram_address(x_word, i + y * 16);
       begin_data();
@@ -467,10 +467,10 @@ void ST7920_Lite_Status_Screen::draw_progress_bar(const uint8_t value) {
   const uint8_t char_pcnt  = 100 / width; // How many percent does each 16-bit word represent?
 
   // Draw the progress bar as a bitmap in CGRAM
-  for (uint8_t y = top; y <= bottom; y++) {
+  LOOP_S_LE_N(y, top, bottom) {
     set_gdram_address(left, y);
     begin_data();
-    for (uint8_t x = 0; x < width; x++) {
+    LOOP_L_N(x, width) {
       uint16_t gfx_word = 0x0000;
       if ((x + 1) * char_pcnt <= value)
         gfx_word = 0xFFFF;                                              // Draw completely filled bytes

commit d0e1166cce60381fbdad1105d13765806a525d99
Author: Dirk O. Kaar <19971886+dok-net@users.noreply.github.com>
Date:   Fri Jan 3 02:01:38 2020 +0100

    Fix Visual Micro "Arduino IDE for Visual Studio" support (#16418)

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index 7719a2d1c7..f5931917ae 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -60,7 +60,7 @@
 #endif
 
 #if ENABLED(LCD_SHOW_E_TOTAL)
-  #include "../../Marlin.h" // for printingIsActive
+  #include "../../MarlinCore.h" // for printingIsActive
 #endif
 
 #define TEXT_MODE_LCD_WIDTH 16

commit 5b75a018b761721aa8d818af22137797f9ad544f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jan 2 17:59:06 2020 -0600

    Misc patches preceding DGUS PR

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index 439078b51e..7719a2d1c7 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -912,7 +912,7 @@ void ST7920_Lite_Status_Screen::on_exit() {
   ncs();
 }
 
-// This is called prior to the KILL screen to
+// Called prior to the KILL screen to
 // clear the screen, preventing a garbled display.
 void ST7920_Lite_Status_Screen::clear_text_buffer() {
   cs();

commit 7a342ecb935e421abfef2f8ed9a8d004f4d30a9f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Oct 27 17:49:27 2019 -0500

    Show Total E during print (#15703)

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index 7308201dc5..439078b51e 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -59,6 +59,10 @@
   #include "../../sd/cardreader.h"
 #endif
 
+#if ENABLED(LCD_SHOW_E_TOTAL)
+  #include "../../Marlin.h" // for printingIsActive
+#endif
+
 #define TEXT_MODE_LCD_WIDTH 16
 
 #define BUFFER_WIDTH   256
@@ -660,7 +664,7 @@ void ST7920_Lite_Status_Screen::draw_status_message() {
   #endif
 }
 
-void ST7920_Lite_Status_Screen::draw_position(const xyz_pos_t &pos, const bool position_known) {
+void ST7920_Lite_Status_Screen::draw_position(const xyze_pos_t &pos, const bool position_known) {
   char str[7];
   set_ddram_address(DDRAM_LINE_4);
   begin_data();
@@ -668,11 +672,25 @@ void ST7920_Lite_Status_Screen::draw_position(const xyz_pos_t &pos, const bool p
   // If position is unknown, flash the labels.
   const unsigned char alt_label = position_known ? 0 : (ui.get_blink() ? ' ' : 0);
 
-  write_byte(alt_label ? alt_label : 'X');
-  write_str(dtostrf(pos.x, -4, 0, str), 4);
+  if (true
+    #if ENABLED(LCD_SHOW_E_TOTAL)
+      && !printingIsActive()
+    #endif
+  ) {
+    write_byte(alt_label ? alt_label : 'X');
+    write_str(dtostrf(pos.x, -4, 0, str), 4);
 
-  write_byte(alt_label ? alt_label : 'Y');
-  write_str(dtostrf(pos.y, -4, 0, str), 4);
+    write_byte(alt_label ? alt_label : 'Y');
+    write_str(dtostrf(pos.y, -4, 0, str), 4);
+  }
+  else {
+    #if ENABLED(LCD_SHOW_E_TOTAL)
+      char tmp[15];
+      const uint8_t escale = e_move_accumulator >= 100000.0f ? 10 : 1; // After 100m switch to cm
+      sprintf_P(tmp, PSTR("E%-7ld%cm "), uint32_t(_MAX(e_move_accumulator, 0.0f)) / escale, escale == 10 ? 'c' : 'm'); // 1234567mm
+      write_str(tmp);
+    #endif
+  }
 
   write_byte(alt_label ? alt_label : 'Z');
   write_str(dtostrf(pos.z, -5, 1, str), 5);

commit b20d5a7cc627164877c95859baaa614f8afc7b99
Author: LinFor <linfor@gmail.com>
Date:   Fri Oct 11 05:03:33 2019 +0300

    Estimate Remaining Time (graphical display) (#15497)

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index 5e73ba8bf3..7308201dc5 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -850,7 +850,7 @@ void ST7920_Lite_Status_Screen::update_progress(const bool forceUpdate) {
     // when an update is actually necessary.
 
     static uint8_t last_progress = 0;
-    const uint8_t progress = ui.get_progress();
+    const uint8_t progress = ui.get_progress_percent();
     if (forceUpdate || last_progress != progress) {
       last_progress = progress;
       draw_progress_bar(progress);

commit 50e4545255605eb506c20eb107270038b0fe7bdb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 29 04:25:39 2019 -0500

    Add custom types for position (#15204)

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index 660cf07673..5e73ba8bf3 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -660,7 +660,7 @@ void ST7920_Lite_Status_Screen::draw_status_message() {
   #endif
 }
 
-void ST7920_Lite_Status_Screen::draw_position(const float (&pos)[XYZE], const bool position_known) {
+void ST7920_Lite_Status_Screen::draw_position(const xyz_pos_t &pos, const bool position_known) {
   char str[7];
   set_ddram_address(DDRAM_LINE_4);
   begin_data();
@@ -669,13 +669,13 @@ void ST7920_Lite_Status_Screen::draw_position(const float (&pos)[XYZE], const bo
   const unsigned char alt_label = position_known ? 0 : (ui.get_blink() ? ' ' : 0);
 
   write_byte(alt_label ? alt_label : 'X');
-  write_str(dtostrf(pos[X_AXIS], -4, 0, str), 4);
+  write_str(dtostrf(pos.x, -4, 0, str), 4);
 
   write_byte(alt_label ? alt_label : 'Y');
-  write_str(dtostrf(pos[Y_AXIS], -4, 0, str), 4);
+  write_str(dtostrf(pos.y, -4, 0, str), 4);
 
   write_byte(alt_label ? alt_label : 'Z');
-  write_str(dtostrf(pos[Z_AXIS], -5, 1, str), 5);
+  write_str(dtostrf(pos.z, -5, 1, str), 5);
 }
 
 bool ST7920_Lite_Status_Screen::indicators_changed() {
@@ -750,8 +750,8 @@ void ST7920_Lite_Status_Screen::update_indicators(const bool forceUpdate) {
 }
 
 bool ST7920_Lite_Status_Screen::position_changed() {
-  const float x_pos = current_position[X_AXIS], y_pos = current_position[Y_AXIS], z_pos = current_position[Z_AXIS];
-  const uint8_t checksum = uint8_t(x_pos) ^ uint8_t(y_pos) ^ uint8_t(z_pos);
+  const xyz_pos_t pos = current_position;
+  const uint8_t checksum = uint8_t(pos.x) ^ uint8_t(pos.y) ^ uint8_t(pos.z);
   static uint8_t last_checksum = 0, changed = last_checksum != checksum;
   if (changed) last_checksum = checksum;
   return changed;

commit 7a569ad4d06d2d5541b76f03942cf4d7ab5bc119
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Mon Sep 16 15:49:46 2019 -0600

    LULZBOT_TOUCH_UI fixes. Fix some warnings. (#15276)

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index 287e8d2582..660cf07673 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -612,6 +612,8 @@ void ST7920_Lite_Status_Screen::draw_feedrate_percentage(const uint16_t percenta
     begin_data();
     write_number(percentage, 3);
     write_byte('%');
+  #else
+    UNUSED(percentage);
   #endif
 }
 

commit 465c6d92307ec613d0b2a7355ce67a60ba23fc0c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Sep 14 03:05:10 2019 -0500

    Simpler Allen Key config. Fixes, cleanups from refactor (#15256)

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index f651945beb..287e8d2582 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -658,7 +658,7 @@ void ST7920_Lite_Status_Screen::draw_status_message() {
   #endif
 }
 
-void ST7920_Lite_Status_Screen::draw_position(const float x, const float y, const float z, bool position_known) {
+void ST7920_Lite_Status_Screen::draw_position(const float (&pos)[XYZE], const bool position_known) {
   char str[7];
   set_ddram_address(DDRAM_LINE_4);
   begin_data();
@@ -667,13 +667,13 @@ void ST7920_Lite_Status_Screen::draw_position(const float x, const float y, cons
   const unsigned char alt_label = position_known ? 0 : (ui.get_blink() ? ' ' : 0);
 
   write_byte(alt_label ? alt_label : 'X');
-  write_str(dtostrf(x, -4, 0, str), 4);
+  write_str(dtostrf(pos[X_AXIS], -4, 0, str), 4);
 
   write_byte(alt_label ? alt_label : 'Y');
-  write_str(dtostrf(y, -4, 0, str), 4);
+  write_str(dtostrf(pos[Y_AXIS], -4, 0, str), 4);
 
   write_byte(alt_label ? alt_label : 'Z');
-  write_str(dtostrf(z, -5, 1, str), 5);
+  write_str(dtostrf(pos[Z_AXIS], -5, 1, str), 5);
 }
 
 bool ST7920_Lite_Status_Screen::indicators_changed() {
@@ -826,16 +826,14 @@ void ST7920_Lite_Status_Screen::update_status_or_position(bool forceUpdate) {
       }
     }
 
-    if (countdown == 0 && (forceUpdate || position_changed() ||
+    if (countdown == 0 && (forceUpdate || position_changed()
       #if DISABLED(DISABLE_REDUCED_ACCURACY_WARNING)
-        blink_changed()
+        || blink_changed()
       #endif
     )) {
-      draw_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS],
-        #if ENABLED(DISABLE_REDUCED_ACCURACY_WARNING)
-          true
-        #else
-          all_axes_known()
+      draw_position(current_position, true
+        #if DISABLED(DISABLE_REDUCED_ACCURACY_WARNING)
+          && all_axes_known()
         #endif
       );
     }

commit c8e30b663973be40855b46560616edd916477bb2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Aug 8 01:51:37 2019 -0500

    Fix code attempting to sprintf %f (#14869)
    
    Arduino doesn't (always) support `float` formatting in strings. So either cast to `int` or use `dtostrf()` to fix these usages.

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index a4001f67d1..f651945beb 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -666,17 +666,14 @@ void ST7920_Lite_Status_Screen::draw_position(const float x, const float y, cons
   // If position is unknown, flash the labels.
   const unsigned char alt_label = position_known ? 0 : (ui.get_blink() ? ' ' : 0);
 
-  dtostrf(x, -4, 0, str);
   write_byte(alt_label ? alt_label : 'X');
-  write_str(str, 4);
+  write_str(dtostrf(x, -4, 0, str), 4);
 
-  dtostrf(y, -4, 0, str);
   write_byte(alt_label ? alt_label : 'Y');
-  write_str(str, 4);
+  write_str(dtostrf(y, -4, 0, str), 4);
 
-  dtostrf(z, -5, 1, str);
   write_byte(alt_label ? alt_label : 'Z');
-  write_str(str, 5);
+  write_str(dtostrf(z, -5, 1, str), 5);
 }
 
 bool ST7920_Lite_Status_Screen::indicators_changed() {

commit a49478cefab3aceee97a8ef52ff21616bfc54525
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Sun Jul 14 08:39:03 2019 -0600

    Fix STATUS_MESSAGE_SCROLLING in LIGHTWEIGHT_UI (#14603)

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index 20c360f519..a4001f67d1 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -59,6 +59,8 @@
   #include "../../sd/cardreader.h"
 #endif
 
+#define TEXT_MODE_LCD_WIDTH 16
+
 #define BUFFER_WIDTH   256
 #define BUFFER_HEIGHT  32
 
@@ -619,13 +621,12 @@ void ST7920_Lite_Status_Screen::draw_status_message() {
   set_ddram_address(DDRAM_LINE_4);
   begin_data();
   #if ENABLED(STATUS_MESSAGE_SCROLLING)
-
     uint8_t slen = utf8_strlen(str);
 
-    if (slen <= LCD_WIDTH) {
+    if (slen <= TEXT_MODE_LCD_WIDTH) {
       // String fits the LCD, so just print it
       write_str(str);
-      while (slen < LCD_WIDTH) { write_byte(' '); ++slen; }
+      while (slen < TEXT_MODE_LCD_WIDTH) { write_byte(' '); ++slen; }
     }
     else {
       // String is larger than the available space in screen.
@@ -634,12 +635,12 @@ void ST7920_Lite_Status_Screen::draw_status_message() {
       // and the string remaining length
       uint8_t rlen;
       const char *stat = ui.status_and_len(rlen);
-      write_str(stat, LCD_WIDTH);
+      write_str(stat, TEXT_MODE_LCD_WIDTH);
 
       // If the remaining string doesn't completely fill the screen
-      if (rlen < LCD_WIDTH) {
+      if (rlen < TEXT_MODE_LCD_WIDTH) {
         write_byte('.');                        // Always at 1+ spaces left, draw a dot
-        uint8_t chars = LCD_WIDTH - rlen;       // Amount of space left in characters
+        uint8_t chars = TEXT_MODE_LCD_WIDTH - rlen;       // Amount of space left in characters
         if (--chars) {                          // Draw a second dot if there's space
           write_byte('.');
           if (--chars) write_str(str, chars);   // Print a second copy of the message
@@ -651,8 +652,8 @@ void ST7920_Lite_Status_Screen::draw_status_message() {
   #else
 
     uint8_t slen = utf8_strlen(str);
-    write_str(str, LCD_WIDTH);
-    for (; slen < LCD_WIDTH; ++slen) write_byte(' ');
+    write_str(str, TEXT_MODE_LCD_WIDTH);
+    for (; slen < TEXT_MODE_LCD_WIDTH; ++slen) write_byte(' ');
 
   #endif
 }
@@ -760,7 +761,8 @@ bool ST7920_Lite_Status_Screen::position_changed() {
 bool ST7920_Lite_Status_Screen::status_changed() {
   uint8_t checksum = 0;
   for (const char *p = ui.status_message; *p; p++) checksum ^= *p;
-  static uint8_t last_checksum = 0, changed = last_checksum != checksum;
+  static uint8_t last_checksum = 0;
+  bool changed = last_checksum != checksum;
   if (changed) last_checksum = checksum;
   return changed;
 }
@@ -805,7 +807,7 @@ void ST7920_Lite_Status_Screen::update_status_or_position(bool forceUpdate) {
   }
   #if !STATUS_EXPIRE_SECONDS
     #if ENABLED(STATUS_MESSAGE_SCROLLING)
-      else
+      else if (blink_changed())
         draw_status_message();
     #endif
   #else

commit a8d68b7c8a5ed440b2d12aea077ad05cadbaadfd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jun 28 13:58:40 2019 -0500

    Common method for scaled fan speed

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index 8b12a83570..20c360f519 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -684,7 +684,7 @@ bool ST7920_Lite_Status_Screen::indicators_changed() {
   // them only during blinks we gain a bit of stability.
   const bool       blink             = ui.get_blink();
   const uint16_t   feedrate_perc     = feedrate_percentage;
-  const uint16_t   fs                = (thermalManager.fan_speed[0] * uint16_t(thermalManager.fan_speed_scaler[0])) >> 7;
+  const uint16_t   fs                = thermalManager.scaledFanSpeed(0);
   const int16_t    extruder_1_target = thermalManager.degTargetHotend(0);
   #if HOTENDS > 1
     const int16_t  extruder_2_target = thermalManager.degTargetHotend(1);
@@ -734,7 +734,7 @@ void ST7920_Lite_Status_Screen::update_indicators(const bool forceUpdate) {
 
     #if ENABLED(ADAPTIVE_FAN_SLOWING)
       if (!blink && thermalManager.fan_speed_scaler[0] < 128)
-        spd = (spd * thermalManager.fan_speed_scaler[0]) >> 7;
+        spd = thermalManager.scaledFanSpeed(0, spd);
     #endif
 
     draw_fan_speed(thermalManager.fanPercent(spd));

commit 08f21335a6f7bd977f4b6d29589c721b3c8be3ca
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Thu Apr 18 12:10:58 2019 -0600

    Fix bad opcode in LIGHTWEIGHT_UI; add 32-bit HAL and Due compatibility (#13751)

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index a72b3e4fc8..8b12a83570 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -158,9 +158,7 @@ void ST7920_Lite_Status_Screen::entry_mode_select(const bool ac_increase, const
 // function for scroll_or_addr_select()
 void ST7920_Lite_Status_Screen::_scroll_or_addr_select(const bool sa) {
   extended_function_set(true);
-  cmd(0b00100010 |
-    (sa   ? 0b000001 : 0)
-  );
+  cmd(0b00000010 | (sa ? 0b00000001 : 0));
   current_bits.sa = sa;
 }
 
@@ -907,34 +905,6 @@ void ST7920_Lite_Status_Screen::clear_text_buffer() {
   ncs();
 }
 
-#if ENABLED(U8GLIB_ST7920) && !defined(U8G_HAL_LINKS) && !defined(__SAM3X8E__)
-
-  #include "ultralcd_st7920_u8glib_rrd_AVR.h"
-
-  void ST7920_Lite_Status_Screen::cs() {
-    ST7920_CS();
-    current_bits.synced = false;
-  }
-
-  void ST7920_Lite_Status_Screen::ncs() {
-    ST7920_NCS();
-    current_bits.synced = false;
-  }
-
-  void ST7920_Lite_Status_Screen::sync_cmd() {
-    ST7920_SET_CMD();
-  }
-
-  void ST7920_Lite_Status_Screen::sync_dat() {
-    ST7920_SET_DAT();
-  }
-
-  void ST7920_Lite_Status_Screen::write_byte(const uint8_t data) {
-    ST7920_WRITE_BYTE(data);
-  }
-
-#endif
-
 void MarlinUI::draw_status_screen() {
   ST7920_Lite_Status_Screen::update(false);
 }

commit 58bca6788374e6a0fcd8b3a5c513e1ad520b9a10
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 17 05:32:12 2019 -0500

    Unify status scrolling further

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index 769fb36060..a72b3e4fc8 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -627,43 +627,27 @@ void ST7920_Lite_Status_Screen::draw_status_message() {
     if (slen <= LCD_WIDTH) {
       // String fits the LCD, so just print it
       write_str(str);
-      for (; slen < LCD_WIDTH; ++slen) write_byte(' ');
+      while (slen < LCD_WIDTH) { write_byte(' '); ++slen; }
     }
     else {
       // String is larger than the available space in screen.
 
       // Get a pointer to the next valid UTF8 character
-      const char *stat = str + ui.status_scroll_offset;
-
-      // Get the string remaining length
-      const uint8_t rlen = utf8_strlen(stat);
-
-      // If we have enough characters to display
-      if (rlen >= LCD_WIDTH) {
-        // The remaining string fills the screen - Print it
-        write_str(stat, LCD_WIDTH);
-      }
-      else {
-        // The remaining string does not completely fill the screen
-        write_str(stat);                        // The string leaves space
-        uint8_t chars = LCD_WIDTH - rlen;         // Amount of space left in characters
+      // and the string remaining length
+      uint8_t rlen;
+      const char *stat = ui.status_and_len(rlen);
+      write_str(stat, LCD_WIDTH);
 
+      // If the remaining string doesn't completely fill the screen
+      if (rlen < LCD_WIDTH) {
         write_byte('.');                        // Always at 1+ spaces left, draw a dot
+        uint8_t chars = LCD_WIDTH - rlen;       // Amount of space left in characters
         if (--chars) {                          // Draw a second dot if there's space
           write_byte('.');
-          if (--chars)
-            write_str(str, chars);              // Print a second copy of the message
+          if (--chars) write_str(str, chars);   // Print a second copy of the message
         }
       }
-
-      // Adjust by complete UTF8 characters
-      if (ui.status_scroll_offset < slen) {
-        ui.status_scroll_offset++;
-        while (!START_OF_UTF8_CHAR(str[ui.status_scroll_offset]))
-          ui.status_scroll_offset++;
-      }
-      else
-        ui.status_scroll_offset = 0;
+      ui.advance_status_scroll();
     }
 
   #else

commit 49cf92dc36424cf828436f32e72263eca39a1cc3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 16 23:43:06 2019 -0500

    Extended condition macros (#13419)
    
    Allow `ENABLED`, `DISABLED`, `PIN_EXISTS`, and `BUTTON_EXISTS` to take multiple arguments. Also add:
    - Alias `ANY(...)` for `!DISABLED(...)`
    - Alias `ANY_PIN(...)` for `PIN_EXISTS(a) || PIN_EXISTS(b) ...`
    - Alias `EITHER(A,B)` for `ANY(...)`
    - Alias `ALL(...)` and `BOTH(A,B)` for `ENABLED(...)`
    - `NONE(...)` for `DISABLED(...)`

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index 7a388b60c3..769fb36060 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -862,7 +862,7 @@ void ST7920_Lite_Status_Screen::update_status_or_position(bool forceUpdate) {
 }
 
 void ST7920_Lite_Status_Screen::update_progress(const bool forceUpdate) {
-  #if ENABLED(LCD_SET_PROGRESS_MANUALLY) || ENABLED(SDSUPPORT)
+  #if EITHER(LCD_SET_PROGRESS_MANUALLY, SDSUPPORT)
 
     // Since the progress bar involves writing
     // quite a few bytes to GDRAM, only do this

commit d94e077901e15557e94f64640adf37e10defb7f2
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 11 20:48:49 2019 -0500

    Apply HAS_HOTEND_OFFSET where needed

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index 6375d5cb74..7a388b60c3 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -580,12 +580,7 @@ void ST7920_Lite_Status_Screen::draw_extruder_2_temp(const int16_t temp, const i
 #if HAS_HEATED_BED
   void ST7920_Lite_Status_Screen::draw_bed_temp(const int16_t temp, const int16_t target, bool forceUpdate) {
     const bool show_target = target && FAR(temp, target);
-    draw_temps(1
-      #if HOTENDS > 1
-        + 1
-      #endif
-      , temp, target, show_target, display_state.bed_show_target != show_target || forceUpdate
-    );
+    draw_temps(HOTENDS > 1 ? 2 : 1, temp, target, show_target, display_state.bed_show_target != show_target || forceUpdate);
     display_state.bed_show_target = show_target;
   }
 #endif

commit 6a57d0b381db99d67cccd48135cbdd2d831588a7
Author: revilor <oliver.rossmueller@web.de>
Date:   Fri Feb 1 02:10:52 2019 +0100

    Prusa MMU2 (#12967)

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index af7cc433e1..6375d5cb74 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -402,7 +402,7 @@ void ST7920_Lite_Status_Screen::draw_degree_symbol(uint8_t x, uint8_t y, const b
     const bool    oddChar = x & 1;
     const uint8_t x_word  = x >> 1,
                   y_top   = degree_symbol_y_top,
-                  y_bot   = y_top + sizeof(degree_symbol)/sizeof(degree_symbol[0]);
+                  y_bot   = y_top + COUNT(degree_symbol);
     for (uint8_t i = y_top; i < y_bot; i++) {
       uint8_t byte = pgm_read_byte(p_bytes++);
       set_gdram_address(x_word, i + y * 16);

commit 082f6a27dece8d1883751d3f2af1c2b0f0b6802c
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sat Jan 12 01:41:48 2019 -0500

    ADAPTIVE_FAN_SLOWING extension to hotend thermal protection (#12853)

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index 126ef00b51..af7cc433e1 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -707,7 +707,7 @@ bool ST7920_Lite_Status_Screen::indicators_changed() {
   // them only during blinks we gain a bit of stability.
   const bool       blink             = ui.get_blink();
   const uint16_t   feedrate_perc     = feedrate_percentage;
-  const uint8_t    fs                = (((uint16_t)fan_speed[0] + 1) * 100) / 256;
+  const uint16_t   fs                = (thermalManager.fan_speed[0] * uint16_t(thermalManager.fan_speed_scaler[0])) >> 7;
   const int16_t    extruder_1_target = thermalManager.degTargetHotend(0);
   #if HOTENDS > 1
     const int16_t  extruder_2_target = thermalManager.degTargetHotend(1);
@@ -734,7 +734,6 @@ void ST7920_Lite_Status_Screen::update_indicators(const bool forceUpdate) {
     const bool       blink             = ui.get_blink();
     const duration_t elapsed           = print_job_timer.duration();
     const uint16_t   feedrate_perc     = feedrate_percentage;
-    const uint8_t    fs                = (((uint16_t)fan_speed[0] + 1) * 100) / 256;
     const int16_t    extruder_1_temp   = thermalManager.degHotend(0),
                      extruder_1_target = thermalManager.degTargetHotend(0);
     #if HOTENDS > 1
@@ -753,12 +752,20 @@ void ST7920_Lite_Status_Screen::update_indicators(const bool forceUpdate) {
     #if HAS_HEATED_BED
       draw_bed_temp(bed_temp, bed_target, forceUpdate);
     #endif
-    draw_fan_speed(fs);
+
+    uint16_t spd = thermalManager.fan_speed[0];
+
+    #if ENABLED(ADAPTIVE_FAN_SLOWING)
+      if (!blink && thermalManager.fan_speed_scaler[0] < 128)
+        spd = (spd * thermalManager.fan_speed_scaler[0]) >> 7;
+    #endif
+
+    draw_fan_speed(thermalManager.fanPercent(spd));
     draw_print_time(elapsed);
     draw_feedrate_percentage(feedrate_perc);
 
     // Update the fan and bed animations
-    if (fs) draw_fan_icon(blink);
+    if (spd) draw_fan_icon(blink);
     #if HAS_HEATED_BED
       draw_heat_icon(bed_target > 0 && blink, bed_target > 0);
     #endif

commit c1e17037e55cfb3220a0f3b190d3f2df8fd72724
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Sat Nov 17 21:21:44 2018 -0700

    Various fixes for MarlinUI and ExtUI (#12439)

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index e02423e64b..126ef00b51 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -99,10 +99,6 @@ void ST7920_Lite_Status_Screen::write_str_P(PGM_P const str) {
   while (char c = pgm_read_byte(p_str++)) write_byte(c);
 }
 
-void ST7920_Lite_Status_Screen::write_str(progmem_str str) {
-  write_str_P((PGM_P)str);
-}
-
 void ST7920_Lite_Status_Screen::write_number(const int16_t value, const uint8_t digits/*=3*/) {
   char str[7];
   PGM_P fmt;
@@ -501,11 +497,11 @@ void ST7920_Lite_Status_Screen::draw_progress_bar(const uint8_t value) {
   // Draw centered
   if (value > 9) {
     write_number(value, 4);
-    write_str(F("% "));
+    write_str_P(PSTR("% "));
   }
   else {
     write_number(value, 3);
-    write_str(F("%  "));
+    write_str_P(PSTR("%  "));
   }
 }
 
@@ -558,12 +554,12 @@ void ST7920_Lite_Status_Screen::draw_temps(uint8_t line, const int16_t temp, con
   write_number(temp);
 
   if (showTarget) {
-    write_str(F("\x1A"));
+    write_byte('\x1A');
     write_number(target);
   };
 
   if (targetStateChange) {
-    if (!showTarget) write_str(F("    "));
+    if (!showTarget) write_str_P(PSTR("    "));
     draw_degree_symbol(5, line, !showTarget);
     draw_degree_symbol(9, line,  showTarget);
   }

commit 0ee1a92971bba0fe5ed290e2562bca71cfb5ea46
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Nov 13 01:47:45 2018 -0600

    Group status methods, share reset_status with Extensible UI (#12414)
    
    * Group status methods, share reset_status with Extensible UI
    * Move common DOGM code to headers

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index 40c47868f9..e02423e64b 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -45,7 +45,7 @@
 
 #if ENABLED(LIGHTWEIGHT_UI)
 
-#include "status_screen_lite_ST7920_class.h"
+#include "status_screen_lite_ST7920.h"
 
 #include "../ultralcd.h"
 #include "../fontutils.h"
@@ -916,8 +916,7 @@ void ST7920_Lite_Status_Screen::on_exit() {
 }
 
 // This is called prior to the KILL screen to
-// clear the screen so we don't end up with a
-// garbled display.
+// clear the screen, preventing a garbled display.
 void ST7920_Lite_Status_Screen::clear_text_buffer() {
   cs();
   reset_state_from_unknown();
@@ -926,23 +925,42 @@ void ST7920_Lite_Status_Screen::clear_text_buffer() {
   ncs();
 }
 
+#if ENABLED(U8GLIB_ST7920) && !defined(U8G_HAL_LINKS) && !defined(__SAM3X8E__)
+
+  #include "ultralcd_st7920_u8glib_rrd_AVR.h"
+
+  void ST7920_Lite_Status_Screen::cs() {
+    ST7920_CS();
+    current_bits.synced = false;
+  }
+
+  void ST7920_Lite_Status_Screen::ncs() {
+    ST7920_NCS();
+    current_bits.synced = false;
+  }
+
+  void ST7920_Lite_Status_Screen::sync_cmd() {
+    ST7920_SET_CMD();
+  }
+
+  void ST7920_Lite_Status_Screen::sync_dat() {
+    ST7920_SET_DAT();
+  }
+
+  void ST7920_Lite_Status_Screen::write_byte(const uint8_t data) {
+    ST7920_WRITE_BYTE(data);
+  }
+
+#endif
+
 void MarlinUI::draw_status_screen() {
   ST7920_Lite_Status_Screen::update(false);
 }
 
-/**
- * In order to properly update the lite Status Screen,
- * we must know when we have entered and left the
- * Status Screen. Since the ultralcd code is not
- * set up for doing this, we call this function before
- * each update indicating whether the current screen
- * is the Status Screen.
- *
- * This function keeps track of whether we have left or
- * entered the Status Screen and calls the on_entry()
- * and on_exit() methods for cleanup.
- */
-void lcd_in_status(const bool inStatus) {
+// This method is called before each screen update and
+// fires on_entry() and on_exit() events upon entering
+// or exiting the Status Screen.
+void MarlinUI::lcd_in_status(const bool inStatus) {
   static bool lastInStatus = false;
   if (lastInStatus == inStatus) return;
   if ((lastInStatus = inStatus))

commit a0c795b097a30eff006c8dff178abf5f1f1907fa
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Nov 11 12:16:24 2018 -0600

    Encapsulate common display code in a singleton (#12395)
    
    * Encapsulate common LCD code in a singleton
    * Depend more UBL code on UBL_DEVEL_DEBUGGING
      - Since most users don't need the debugging on at all times, this helps reduce the default build size for UBL by over 2K, a little closer to fitting on 128K boards.

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index 515adb9389..40c47868f9 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -230,12 +230,8 @@ void ST7920_Lite_Status_Screen::load_cgram_icon(const uint16_t addr, const void
  */
 void ST7920_Lite_Status_Screen::draw_gdram_icon(uint8_t x, uint8_t y, const void *data) {
   const uint16_t *p_word = (const uint16_t *)data;
-  if (y > 2) { // Handle display folding
-    y -= 2;
-    x += 8;
-  }
-  --x;
-  --y;
+  // Handle display folding
+  if (y > 1) y -= 2, x += 8;
   for (int i = 0; i < 16; i++) {
     set_gdram_address(x, i + y * 16);
     begin_data();
@@ -398,24 +394,20 @@ const uint16_t feedrate_icon[] PROGMEM = {
 
 /************************** MAIN SCREEN *************************************/
 
-// The ST7920 does not have a degree character, but we
-// can fake it by writing it to GDRAM.
-// This function takes as an argument character positions
-// i.e x is [1-16], while the y position is [1-4]
-void ST7920_Lite_Status_Screen::draw_degree_symbol(uint8_t x, uint8_t y, bool draw) {
+/**
+ * The ST7920 has no degree character, so draw it to GDRAM.
+ * This function takes character position xy
+ * i.e., x is [0-15], while the y position is [0-3]
+ */
+void ST7920_Lite_Status_Screen::draw_degree_symbol(uint8_t x, uint8_t y, const bool draw) {
   const uint8_t *p_bytes = degree_symbol;
-    if (y > 2) {
-      // Handle display folding
-      y -= 2;
-      x += 16;
-    }
-    x -= 1;
-    y -= 1;
+    // Handle display folding
+    if (y > 1) y -= 2, x += 16;
     const bool    oddChar = x & 1;
-    const uint8_t x_word  = x >> 1;
-    const uint8_t y_top   = degree_symbol_y_top;
-    const uint8_t y_bot   = y_top + sizeof(degree_symbol)/sizeof(degree_symbol[0]);
-    for(uint8_t i = y_top; i < y_bot; i++) {
+    const uint8_t x_word  = x >> 1,
+                  y_top   = degree_symbol_y_top,
+                  y_bot   = y_top + sizeof(degree_symbol)/sizeof(degree_symbol[0]);
+    for (uint8_t i = y_top; i < y_bot; i++) {
       uint8_t byte = pgm_read_byte(p_bytes++);
       set_gdram_address(x_word, i + y * 16);
       begin_data();
@@ -438,14 +430,14 @@ void ST7920_Lite_Status_Screen::draw_static_elements() {
   load_cgram_icon(CGRAM_ICON_4_ADDR, fan2_icon);
 
   // Draw the static icons in GDRAM
-  draw_gdram_icon(1, 1, nozzle_icon);
+  draw_gdram_icon(0, 0, nozzle_icon);
   #if HOTENDS > 1
-    draw_gdram_icon(1,2,nozzle_icon);
-    draw_gdram_icon(1,3,bed_icon);
+    draw_gdram_icon(0, 1, nozzle_icon);
+    draw_gdram_icon(0, 2, bed_icon);
   #else
-    draw_gdram_icon(1,2,bed_icon);
+    draw_gdram_icon(0, 1, bed_icon);
   #endif
-  draw_gdram_icon(6,2,feedrate_icon);
+  draw_gdram_icon(5, 1, feedrate_icon);
 
   // Draw the initial fan icon
   draw_fan_icon(false);
@@ -462,15 +454,15 @@ void ST7920_Lite_Status_Screen::draw_static_elements() {
 void ST7920_Lite_Status_Screen::draw_progress_bar(const uint8_t value) {
   #if HOTENDS == 1
     // If we have only one extruder, draw a long progress bar on the third line
-    const uint8_t top     = 1,         // Top in pixels
-                  bottom  = 13,        // Bottom in pixels
-                  left    = 12,        // Left edge, in 16-bit words
-                  width   = 4;         // Width of progress bar, in 16-bit words
+    constexpr uint8_t top     = 1,         // Top in pixels
+                      bottom  = 13,        // Bottom in pixels
+                      left    = 12,        // Left edge, in 16-bit words
+                      width   = 4;         // Width of progress bar, in 16-bit words
   #else
-    const uint8_t top     = 16 + 1,
-                  bottom  = 16 + 13,
-                  left    = 5,
-                  width   = 3;
+    constexpr uint8_t top     = 16 + 1,
+                      bottom  = 16 + 13,
+                      left    = 5,
+                      width   = 3;
   #endif
   const uint8_t char_pcnt  = 100 / width; // How many percent does each 16-bit word represent?
 
@@ -557,10 +549,10 @@ static struct {
 
 void ST7920_Lite_Status_Screen::draw_temps(uint8_t line, const int16_t temp, const int16_t target, bool showTarget, bool targetStateChange) {
   switch (line) {
-    case 1: set_ddram_address(DDRAM_LINE_1 + 1); break;
-    case 2: set_ddram_address(DDRAM_LINE_2 + 1); break;
+    case 0: set_ddram_address(DDRAM_LINE_1 + 1); break;
+    case 1: set_ddram_address(DDRAM_LINE_2 + 1); break;
+    case 2: set_ddram_address(DDRAM_LINE_3 + 1); break;
     case 3: set_ddram_address(DDRAM_LINE_3 + 1); break;
-    case 4: set_ddram_address(DDRAM_LINE_3 + 1); break;
   }
   begin_data();
   write_number(temp);
@@ -572,27 +564,27 @@ void ST7920_Lite_Status_Screen::draw_temps(uint8_t line, const int16_t temp, con
 
   if (targetStateChange) {
     if (!showTarget) write_str(F("    "));
-    draw_degree_symbol(6,  line, !showTarget);
-    draw_degree_symbol(10, line, showTarget);
+    draw_degree_symbol(5, line, !showTarget);
+    draw_degree_symbol(9, line,  showTarget);
   }
 }
 
 void ST7920_Lite_Status_Screen::draw_extruder_1_temp(const int16_t temp, const int16_t target, bool forceUpdate) {
   const bool show_target = target && FAR(temp, target);
-  draw_temps(1, temp, target, show_target, display_state.E1_show_target != show_target || forceUpdate);
+  draw_temps(0, temp, target, show_target, display_state.E1_show_target != show_target || forceUpdate);
   display_state.E1_show_target = show_target;
 }
 
 void ST7920_Lite_Status_Screen::draw_extruder_2_temp(const int16_t temp, const int16_t target, bool forceUpdate) {
   const bool show_target = target && FAR(temp, target);
-  draw_temps(2, temp, target, show_target, display_state.E2_show_target != show_target || forceUpdate);
+  draw_temps(1, temp, target, show_target, display_state.E2_show_target != show_target || forceUpdate);
   display_state.E2_show_target = show_target;
 }
 
 #if HAS_HEATED_BED
   void ST7920_Lite_Status_Screen::draw_bed_temp(const int16_t temp, const int16_t target, bool forceUpdate) {
     const bool show_target = target && FAR(temp, target);
-    draw_temps(2
+    draw_temps(1
       #if HOTENDS > 1
         + 1
       #endif
@@ -632,44 +624,38 @@ void ST7920_Lite_Status_Screen::draw_feedrate_percentage(const uint16_t percenta
   #endif
 }
 
-void ST7920_Lite_Status_Screen::draw_status_message(const char *str) {
+void ST7920_Lite_Status_Screen::draw_status_message() {
+  const char *str = ui.status_message;
+
   set_ddram_address(DDRAM_LINE_4);
   begin_data();
-  const uint8_t lcd_len = 16;
   #if ENABLED(STATUS_MESSAGE_SCROLLING)
 
     uint8_t slen = utf8_strlen(str);
 
-    // If the string fits into the LCD, just print it and do not scroll it
-    if (slen <= lcd_len) {
-
-      // The string isn't scrolling and may not fill the screen
+    if (slen <= LCD_WIDTH) {
+      // String fits the LCD, so just print it
       write_str(str);
-
-      // Fill the rest with spaces
-      while (slen < lcd_len) {
-        write_byte(' ');
-        ++slen;
-      }
+      for (; slen < LCD_WIDTH; ++slen) write_byte(' ');
     }
     else {
       // String is larger than the available space in screen.
 
       // Get a pointer to the next valid UTF8 character
-      const char *stat = str + status_scroll_offset;
+      const char *stat = str + ui.status_scroll_offset;
 
       // Get the string remaining length
       const uint8_t rlen = utf8_strlen(stat);
 
       // If we have enough characters to display
-      if (rlen >= lcd_len) {
+      if (rlen >= LCD_WIDTH) {
         // The remaining string fills the screen - Print it
-        write_str(stat, lcd_len);
+        write_str(stat, LCD_WIDTH);
       }
       else {
         // The remaining string does not completely fill the screen
         write_str(stat);                        // The string leaves space
-        uint8_t chars = lcd_len - rlen;         // Amount of space left in characters
+        uint8_t chars = LCD_WIDTH - rlen;         // Amount of space left in characters
 
         write_byte('.');                        // Always at 1+ spaces left, draw a dot
         if (--chars) {                          // Draw a second dot if there's space
@@ -680,26 +666,21 @@ void ST7920_Lite_Status_Screen::draw_status_message(const char *str) {
       }
 
       // Adjust by complete UTF8 characters
-      if (status_scroll_offset < slen) {
-        status_scroll_offset++;
-        while (!START_OF_UTF8_CHAR(str[status_scroll_offset]))
-          status_scroll_offset++;
+      if (ui.status_scroll_offset < slen) {
+        ui.status_scroll_offset++;
+        while (!START_OF_UTF8_CHAR(str[ui.status_scroll_offset]))
+          ui.status_scroll_offset++;
       }
       else
-        status_scroll_offset = 0;
+        ui.status_scroll_offset = 0;
     }
+
   #else
-    // Get the UTF8 character count of the string
-    uint8_t slen = utf8_strlen(str);
 
-    // Just print the string to the LCD
-    write_str(str, lcd_len);
+    uint8_t slen = utf8_strlen(str);
+    write_str(str, LCD_WIDTH);
+    for (; slen < LCD_WIDTH; ++slen) write_byte(' ');
 
-    // Fill the rest with spaces if there are missing spaces
-    while (slen < lcd_len) {
-      write_byte(' ');
-      ++slen;
-    }
   #endif
 }
 
@@ -709,7 +690,7 @@ void ST7920_Lite_Status_Screen::draw_position(const float x, const float y, cons
   begin_data();
 
   // If position is unknown, flash the labels.
-  const unsigned char alt_label = position_known ? 0 : (lcd_blink() ? ' ' : 0);
+  const unsigned char alt_label = position_known ? 0 : (ui.get_blink() ? ' ' : 0);
 
   dtostrf(x, -4, 0, str);
   write_byte(alt_label ? alt_label : 'X');
@@ -728,7 +709,7 @@ bool ST7920_Lite_Status_Screen::indicators_changed() {
   // We only add the target temperatures to the checksum
   // because the actual temps fluctuate so by updating
   // them only during blinks we gain a bit of stability.
-  const bool       blink             = lcd_blink();
+  const bool       blink             = ui.get_blink();
   const uint16_t   feedrate_perc     = feedrate_percentage;
   const uint8_t    fs                = (((uint16_t)fan_speed[0] + 1) * 100) / 256;
   const int16_t    extruder_1_target = thermalManager.degTargetHotend(0);
@@ -754,7 +735,7 @@ bool ST7920_Lite_Status_Screen::indicators_changed() {
 
 void ST7920_Lite_Status_Screen::update_indicators(const bool forceUpdate) {
   if (forceUpdate || indicators_changed()) {
-    const bool       blink             = lcd_blink();
+    const bool       blink             = ui.get_blink();
     const duration_t elapsed           = print_job_timer.duration();
     const uint16_t   feedrate_perc     = feedrate_percentage;
     const uint8_t    fs                = (((uint16_t)fan_speed[0] + 1) * 100) / 256;
@@ -783,41 +764,32 @@ void ST7920_Lite_Status_Screen::update_indicators(const bool forceUpdate) {
     // Update the fan and bed animations
     if (fs) draw_fan_icon(blink);
     #if HAS_HEATED_BED
-      if (bed_target > 0)
-        draw_heat_icon(blink, true);
-      else
-        draw_heat_icon(false, false);
+      draw_heat_icon(bed_target > 0 && blink, bed_target > 0);
     #endif
   }
 }
 
 bool ST7920_Lite_Status_Screen::position_changed() {
-  const float x_pos = current_position[X_AXIS],
-              y_pos = current_position[Y_AXIS],
-              z_pos = current_position[Z_AXIS];
+  const float x_pos = current_position[X_AXIS], y_pos = current_position[Y_AXIS], z_pos = current_position[Z_AXIS];
   const uint8_t checksum = uint8_t(x_pos) ^ uint8_t(y_pos) ^ uint8_t(z_pos);
-
-  static uint8_t last_checksum = 0;
-  if (last_checksum == checksum) return false;
-  last_checksum = checksum;
-  return true;
+  static uint8_t last_checksum = 0, changed = last_checksum != checksum;
+  if (changed) last_checksum = checksum;
+  return changed;
 }
 
 bool ST7920_Lite_Status_Screen::status_changed() {
   uint8_t checksum = 0;
-  for (const char *p = lcd_status_message; *p; p++) checksum ^= *p;
-  static uint8_t last_checksum = 0;
-  if (last_checksum == checksum) return false;
-  last_checksum = checksum;
-  return true;
+  for (const char *p = ui.status_message; *p; p++) checksum ^= *p;
+  static uint8_t last_checksum = 0, changed = last_checksum != checksum;
+  if (changed) last_checksum = checksum;
+  return changed;
 }
 
 bool ST7920_Lite_Status_Screen::blink_changed() {
   static uint8_t last_blink = 0;
-  const bool blink = lcd_blink();
-  if (last_blink == blink) return false;
-  last_blink = blink;
-  return true;
+  const bool blink = ui.get_blink(), changed = last_blink != blink;
+  if (changed) last_blink = blink;
+  return changed;
 }
 
 #ifndef STATUS_EXPIRE_SECONDS
@@ -831,60 +803,56 @@ void ST7920_Lite_Status_Screen::update_status_or_position(bool forceUpdate) {
   #endif
 
   /**
-   * There is only enough room in the display for either the
-   * status message or the position, not both, so we choose
-   * one or another. Whenever the status message changes,
-   * we show it for a number of consecutive seconds, but
-   * then go back to showing the position as soon as the
-   * head moves, i.e:
+   * There's only enough room for either the status message or the position,
+   * so draw one or the other. When the status message changes, show it for
+   * a few seconds, then return to the position display once the head moves.
    *
-   *    countdown > 1    -- Show status
-   *    countdown = 1    -- Show status, until movement
-   *    countdown = 0    -- Show position
+   *  countdown > 1  -- Show status
+   *  countdown = 1  -- Show status, until movement
+   *  countdown = 0  -- Show position
    *
-   * If STATUS_EXPIRE_SECONDS is zero, the position display
-   * will be disabled and only the status will be shown.
+   * If STATUS_EXPIRE_SECONDS is zero, only the status is shown.
    */
   if (forceUpdate || status_changed()) {
     #if ENABLED(STATUS_MESSAGE_SCROLLING)
-      status_scroll_offset = 0;
+      ui.status_scroll_offset = 0;
     #endif
     #if STATUS_EXPIRE_SECONDS
-      countdown = lcd_status_message[0] ? STATUS_EXPIRE_SECONDS : 0;
+      countdown = ui.status_message[0] ? STATUS_EXPIRE_SECONDS : 0;
     #endif
-    draw_status_message(lcd_status_message);
+    draw_status_message();
     blink_changed(); // Clear changed flag
   }
   #if !STATUS_EXPIRE_SECONDS
     #if ENABLED(STATUS_MESSAGE_SCROLLING)
       else
-        draw_status_message(lcd_status_message);
+        draw_status_message();
     #endif
   #else
-    else if (countdown > 1 && blink_changed()) {
-      countdown--;
-      #if ENABLED(STATUS_MESSAGE_SCROLLING)
-        draw_status_message(lcd_status_message);
-      #endif
-    }
-    else if (countdown > 0 && blink_changed()) {
-      if (position_changed()) {
+    else if (blink_changed()) {
+      if (countdown > 1) {
         countdown--;
-        forceUpdate = true;
+        #if ENABLED(STATUS_MESSAGE_SCROLLING)
+          draw_status_message();
+        #endif
+      }
+      else if (countdown > 0) {
+        if (position_changed()) {
+          countdown--;
+          forceUpdate = true;
+        }
+        #if ENABLED(STATUS_MESSAGE_SCROLLING)
+          draw_status_message();
+        #endif
       }
-      #if ENABLED(STATUS_MESSAGE_SCROLLING)
-        draw_status_message(lcd_status_message);
-      #endif
     }
+
     if (countdown == 0 && (forceUpdate || position_changed() ||
       #if DISABLED(DISABLE_REDUCED_ACCURACY_WARNING)
         blink_changed()
       #endif
     )) {
-      draw_position(
-        current_position[X_AXIS],
-        current_position[Y_AXIS],
-        current_position[Z_AXIS],
+      draw_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS],
         #if ENABLED(DISABLE_REDUCED_ACCURACY_WARNING)
           true
         #else
@@ -898,24 +866,16 @@ void ST7920_Lite_Status_Screen::update_status_or_position(bool forceUpdate) {
 void ST7920_Lite_Status_Screen::update_progress(const bool forceUpdate) {
   #if ENABLED(LCD_SET_PROGRESS_MANUALLY) || ENABLED(SDSUPPORT)
 
-    #if DISABLED(LCD_SET_PROGRESS_MANUALLY)
-      uint8_t progress_bar_percent = 0;
-    #endif
-
-    #if ENABLED(SDSUPPORT)
-      // Progress bar % comes from SD when actively printing
-      if (IS_SD_PRINTING()) progress_bar_percent = card.percentDone();
-    #endif
-
     // Since the progress bar involves writing
     // quite a few bytes to GDRAM, only do this
     // when an update is actually necessary.
 
     static uint8_t last_progress = 0;
-    if (!forceUpdate && last_progress == progress_bar_percent) return;
-    last_progress = progress_bar_percent;
-
-    draw_progress_bar(progress_bar_percent);
+    const uint8_t progress = ui.get_progress();
+    if (forceUpdate || last_progress != progress) {
+      last_progress = progress;
+      draw_progress_bar(progress);
+    }
 
   #else
 
@@ -966,7 +926,7 @@ void ST7920_Lite_Status_Screen::clear_text_buffer() {
   ncs();
 }
 
-void lcd_impl_status_screen_0() {
+void MarlinUI::draw_status_screen() {
   ST7920_Lite_Status_Screen::update(false);
 }
 

commit 31c28d0dd243331adba3debb4801fbd03f7f6ec2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Nov 2 00:42:16 2018 -0500

    Drop pgm_read_*_near and let headers choose (#12301)
    
    - Drop `pgm_read_*_near` and let headers choose.
    - Define `USE_EXECUTE_COMMANDS_IMMEDIATE` as a conditional.
    - Add `process_subcommands_now` for SRAM-based commands.

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
index 73851ecefb..515adb9389 100644
--- a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -96,7 +96,7 @@ void ST7920_Lite_Status_Screen::write_str(const char *str, uint8_t len) {
 
 void ST7920_Lite_Status_Screen::write_str_P(PGM_P const str) {
   PGM_P p_str = (PGM_P)str;
-  while (char c = pgm_read_byte_near(p_str++)) write_byte(c);
+  while (char c = pgm_read_byte(p_str++)) write_byte(c);
 }
 
 void ST7920_Lite_Status_Screen::write_str(progmem_str str) {
@@ -221,7 +221,7 @@ void ST7920_Lite_Status_Screen::load_cgram_icon(const uint16_t addr, const void
   set_cgram_address(addr);
   begin_data();
   for (uint8_t i = 16; i--;)
-    write_word(pgm_read_word_near(p_word++));
+    write_word(pgm_read_word(p_word++));
 }
 
 /**
@@ -239,7 +239,7 @@ void ST7920_Lite_Status_Screen::draw_gdram_icon(uint8_t x, uint8_t y, const void
   for (int i = 0; i < 16; i++) {
     set_gdram_address(x, i + y * 16);
     begin_data();
-    write_word(pgm_read_word_near(p_word++));
+    write_word(pgm_read_word(p_word++));
   }
 }
 
@@ -416,8 +416,8 @@ void ST7920_Lite_Status_Screen::draw_degree_symbol(uint8_t x, uint8_t y, bool dr
     const uint8_t y_top   = degree_symbol_y_top;
     const uint8_t y_bot   = y_top + sizeof(degree_symbol)/sizeof(degree_symbol[0]);
     for(uint8_t i = y_top; i < y_bot; i++) {
-      uint8_t byte = pgm_read_byte_near(p_bytes++);
-      set_gdram_address(x_word,i+y*16);
+      uint8_t byte = pgm_read_byte(p_bytes++);
+      set_gdram_address(x_word, i + y * 16);
       begin_data();
       if (draw) {
         write_byte(oddChar ? 0x00 : byte);

commit 37ff663b0242b3db8f46d13ca26c6ee4be40a833
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Oct 28 00:27:29 2018 -0500

    Convert LIGHTWEIGHT_UI to CPP

diff --git a/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
new file mode 100644
index 0000000000..73851ecefb
--- /dev/null
+++ b/Marlin/src/lcd/dogm/status_screen_lite_ST7920.cpp
@@ -0,0 +1,994 @@
+/**
+ * Lightweight Status Screen for the RepRapDiscount Full
+ * Graphics Smart Controller (ST7920-based 128x64 LCD)
+ *
+ * (c) 2017 Aleph Objects, Inc.
+ *
+ * The code in this page is free software: you can
+ * redistribute it and/or modify it under the terms of the GNU
+ * General Public License (GNU GPL) as published by the Free Software
+ * Foundation, either version 3 of the License, or (at your option)
+ * any later version.  The code is distributed WITHOUT ANY WARRANTY;
+ * without even the implied warranty of MERCHANTABILITY or FITNESS
+ * FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.
+ *
+ */
+
+/**
+ * Implementation of a Status Screen for the RepRapDiscount
+ * Full Graphics Smart Controller using native ST7920 commands
+ * instead of U8Glib.
+ *
+ * This alternative Status Screen makes use of the built-in character
+ * generation capabilities of the ST7920 to update the Status Screen
+ * with less SPI traffic and CPU use. In particular:
+ *
+ *  - The fan and bed animations are handled using custom characters
+ *    that are stored in CGRAM. This allows for the animation to be
+ *    updated by writing a single character to the text-buffer (DDRAM).
+ *
+ *  - All the information in the Status Screen is text that is written
+ *    to DDRAM, so the work of generating the bitmaps is offloaded to
+ *    the ST7920 rather than being render by U8Glib on the MCU.
+ *
+ *  - The graphics buffer (GDRAM) is only used for static graphics
+ *    elements (nozzle and feedrate bitmaps) and for the progress
+ *    bar, so updates are sporadic.
+ */
+
+//
+// status_screen_lite_ST7920.cpp
+// Lightweight Status Screen for Graphical Display
+//
+
+#include "../../inc/MarlinConfigPre.h"
+
+#if ENABLED(LIGHTWEIGHT_UI)
+
+#include "status_screen_lite_ST7920_class.h"
+
+#include "../ultralcd.h"
+#include "../fontutils.h"
+#include "../lcdprint.h"
+#include "../../libs/duration_t.h"
+#include "../../module/motion.h"
+#include "../../module/printcounter.h"
+#include "../../module/temperature.h"
+
+#if ENABLED(SDSUPPORT)
+  #include "../../sd/cardreader.h"
+#endif
+
+#define BUFFER_WIDTH   256
+#define BUFFER_HEIGHT  32
+
+#define DDRAM_LINE_1   0x00
+#define DDRAM_LINE_2   0x10
+#define DDRAM_LINE_3   0x08
+#define DDRAM_LINE_4   0x18
+
+ST7920_Lite_Status_Screen::st7920_state_t ST7920_Lite_Status_Screen::current_bits;
+
+void ST7920_Lite_Status_Screen::cmd(const uint8_t cmd) {
+  if (!current_bits.synced || !current_bits.cmd) {
+    current_bits.synced = true;
+    current_bits.cmd    = true;
+    sync_cmd();
+  }
+  write_byte(cmd);
+}
+
+void ST7920_Lite_Status_Screen::begin_data() {
+  if (!current_bits.synced || current_bits.cmd) {
+    current_bits.synced = true;
+    current_bits.cmd    = false;
+    sync_dat();
+  }
+}
+
+void ST7920_Lite_Status_Screen::write_str(const char *str) {
+  while (*str) write_byte(*str++);
+}
+
+void ST7920_Lite_Status_Screen::write_str(const char *str, uint8_t len) {
+  while (*str && len--) write_byte(*str++);
+}
+
+void ST7920_Lite_Status_Screen::write_str_P(PGM_P const str) {
+  PGM_P p_str = (PGM_P)str;
+  while (char c = pgm_read_byte_near(p_str++)) write_byte(c);
+}
+
+void ST7920_Lite_Status_Screen::write_str(progmem_str str) {
+  write_str_P((PGM_P)str);
+}
+
+void ST7920_Lite_Status_Screen::write_number(const int16_t value, const uint8_t digits/*=3*/) {
+  char str[7];
+  PGM_P fmt;
+  switch (digits) {
+    case 6: fmt = PSTR("%6d"); break;
+    case 5: fmt = PSTR("%5d"); break;
+    case 4: fmt = PSTR("%4d"); break;
+    case 3: fmt = PSTR("%3d"); break;
+    case 2: fmt = PSTR("%2d"); break;
+    case 1: fmt = PSTR("%1d"); break;
+    default: return;
+  }
+  sprintf_P(str, fmt, value);
+  write_str(str);
+}
+
+void ST7920_Lite_Status_Screen::display_status(const bool display_on, const bool cursor_on, const bool blink_on) {
+  extended_function_set(false);
+  cmd(0b00001000 |
+    (display_on ? 0b0100 : 0) |
+    (cursor_on  ? 0b0010 : 0) |
+    (blink_on   ? 0b0001 : 0)
+  );
+}
+
+// Sets the extended and graphics bits simultaneously, regardless of
+// the current state. This is a helper function for extended_function_set()
+// and graphics()
+void ST7920_Lite_Status_Screen::_extended_function_set(const bool extended, const bool graphics) {
+  cmd(  0b00100000 |
+    (extended   ? 0b00000100 : 0) |
+    (graphics   ? 0b00000010 : 0)
+  );
+  current_bits.extended = extended;
+  current_bits.graphics = graphics;
+}
+
+void ST7920_Lite_Status_Screen::extended_function_set(const bool extended) {
+  if (extended != current_bits.extended)
+    _extended_function_set(extended, current_bits.graphics);
+}
+
+void ST7920_Lite_Status_Screen::graphics(const bool graphics) {
+  if (graphics != current_bits.graphics)
+    _extended_function_set(current_bits.extended, graphics);
+}
+
+void ST7920_Lite_Status_Screen::entry_mode_select(const bool ac_increase, const bool shift) {
+  extended_function_set(false);
+  cmd(0b00000100 |
+    (ac_increase ? 0b00000010 : 0) |
+    (shift       ? 0b00000001 : 0)
+  );
+}
+
+// Sets the sa bit regardless of the current state. This is a helper
+// function for scroll_or_addr_select()
+void ST7920_Lite_Status_Screen::_scroll_or_addr_select(const bool sa) {
+  extended_function_set(true);
+  cmd(0b00100010 |
+    (sa   ? 0b000001 : 0)
+  );
+  current_bits.sa = sa;
+}
+
+void ST7920_Lite_Status_Screen::scroll_or_addr_select(const bool sa) {
+  if (sa != current_bits.sa)
+    _scroll_or_addr_select(sa);
+}
+
+void ST7920_Lite_Status_Screen::set_ddram_address(const uint8_t addr) {
+  extended_function_set(false);
+  cmd(0b10000000 | (addr & 0b00111111));
+}
+
+void ST7920_Lite_Status_Screen::set_cgram_address(const uint8_t addr) {
+  extended_function_set(false);
+  cmd(0b01000000 | (addr & 0b00111111));
+}
+
+void ST7920_Lite_Status_Screen::set_gdram_address(const uint8_t x, const uint8_t y) {
+  extended_function_set(true);
+  cmd(0b10000000 | (y & 0b01111111));
+  cmd(0b10000000 | (x & 0b00001111));
+}
+
+void ST7920_Lite_Status_Screen::clear() {
+  extended_function_set(false);
+  cmd(0x00000001);
+  delay(15);                 //delay for CGRAM clear
+}
+
+void ST7920_Lite_Status_Screen::home() {
+  extended_function_set(false);
+  cmd(0x00000010);
+}
+
+/* This fills the entire text buffer with spaces */
+void ST7920_Lite_Status_Screen::clear_ddram() {
+  set_ddram_address(DDRAM_LINE_1);
+  begin_data();
+  for (uint8_t i = 64; i--;) write_byte(' ');
+}
+
+/* This fills the entire graphics buffer with zeros */
+void ST7920_Lite_Status_Screen::clear_gdram() {
+  for (uint8_t y = 0; y < BUFFER_HEIGHT; y++) {
+    set_gdram_address(0, y);
+    begin_data();
+    for (uint8_t i = (BUFFER_WIDTH) / 16; i--;) write_word(0);
+  }
+}
+
+void ST7920_Lite_Status_Screen::load_cgram_icon(const uint16_t addr, const void *data) {
+  const uint16_t *p_word = (const uint16_t *)data;
+  set_cgram_address(addr);
+  begin_data();
+  for (uint8_t i = 16; i--;)
+    write_word(pgm_read_word_near(p_word++));
+}
+
+/**
+ * Draw an icon in GDRAM. Position specified in DDRAM
+ * coordinates. i.e., X from 1 to 8, Y from 1 to 4.
+ */
+void ST7920_Lite_Status_Screen::draw_gdram_icon(uint8_t x, uint8_t y, const void *data) {
+  const uint16_t *p_word = (const uint16_t *)data;
+  if (y > 2) { // Handle display folding
+    y -= 2;
+    x += 8;
+  }
+  --x;
+  --y;
+  for (int i = 0; i < 16; i++) {
+    set_gdram_address(x, i + y * 16);
+    begin_data();
+    write_word(pgm_read_word_near(p_word++));
+  }
+}
+
+/************************** ICON DEFINITIONS *************************************/
+
+#define CGRAM_ICON_1_ADDR 0x00
+#define CGRAM_ICON_2_ADDR 0x10
+#define CGRAM_ICON_3_ADDR 0x20
+#define CGRAM_ICON_4_ADDR 0x30
+
+#define CGRAM_ICON_1_WORD 0x00
+#define CGRAM_ICON_2_WORD 0x02
+#define CGRAM_ICON_3_WORD 0x04
+#define CGRAM_ICON_4_WORD 0x06
+
+const uint8_t degree_symbol_y_top = 1;
+PROGMEM const uint8_t degree_symbol[] = {
+  0b00110000,
+  0b01001000,
+  0b01001000,
+  0b00110000,
+};
+
+const uint16_t nozzle_icon[] PROGMEM = {
+  0b0000000000000000,
+  0b0000000000000000,
+  0b0000111111110000,
+  0b0001111111111000,
+  0b0001111111111000,
+  0b0001111111111000,
+  0b0000111111110000,
+  0b0000111111110000,
+  0b0001111111111000,
+  0b0001111111111000,
+  0b0001111111111000,
+  0b0000011111100000,
+  0b0000001111000000,
+  0b0000000110000000,
+  0b0000000000000000,
+  0b0000000000000000
+};
+
+const uint16_t bed_icon[] PROGMEM = {
+  0b0000000000000000,
+  0b0000000000000000,
+  0b0000000000000000,
+  0b0000000000000000,
+  0b0000000000000000,
+  0b0000000000000000,
+  0b0000000000000000,
+  0b0000000000000000,
+  0b0000000000000000,
+  0b0000000000000000,
+  0b0000000000000000,
+  0b0111111111111110,
+  0b0111111111111110,
+  0b0110000000000110,
+  0b0000000000000000,
+  0b0000000000000000
+};
+
+const uint16_t heat1_icon[] PROGMEM = {
+  0b0000000000000000,
+  0b0010001000100000,
+  0b0001000100010000,
+  0b0000100010001000,
+  0b0000100010001000,
+  0b0001000100010000,
+  0b0010001000100000,
+  0b0010001000100000,
+  0b0001000100010000,
+  0b0000100010001000,
+  0b0000000000000000,
+  0b0000000000000000,
+  0b0000000000000000,
+  0b0000000000000000,
+  0b0000000000000000,
+  0b0000000000000000
+};
+
+const uint16_t heat2_icon[] PROGMEM = {
+  0b0000000000000000,
+  0b0000100010001000,
+  0b0000100010001000,
+  0b0001000100010000,
+  0b0010001000100000,
+  0b0010001000100000,
+  0b0001000100010000,
+  0b0000100010001000,
+  0b0000100010001000,
+  0b0001000100010000,
+  0b0000000000000000,
+  0b0000000000000000,
+  0b0000000000000000,
+  0b0000000000000000,
+  0b0000000000000000,
+  0b0000000000000000
+};
+
+const uint16_t fan1_icon[] PROGMEM = {
+  0b0000000000000000,
+  0b0111111111111110,
+  0b0111000000001110,
+  0b0110001111000110,
+  0b0100001111000010,
+  0b0100000110000010,
+  0b0101100000011010,
+  0b0101110110111010,
+  0b0101100000011010,
+  0b0100000110000010,
+  0b0100001111000010,
+  0b0110001111000110,
+  0b0111000000001110,
+  0b0111111111111110,
+  0b0000000000000000,
+  0b0000000000000000
+};
+
+const uint16_t fan2_icon[] PROGMEM = {
+  0b0000000000000000,
+  0b0111111111111110,
+  0b0111000000001110,
+  0b0110010000100110,
+  0b0100111001110010,
+  0b0101111001111010,
+  0b0100110000110010,
+  0b0100000110000010,
+  0b0100110000110010,
+  0b0101111001111010,
+  0b0100111001110010,
+  0b0110010000100110,
+  0b0111000000001110,
+  0b0111111111111110,
+  0b0000000000000000,
+  0b0000000000000000
+};
+
+const uint16_t feedrate_icon[] PROGMEM = {
+  0b0000000000000000,
+  0b0111111000000000,
+  0b0110000000000000,
+  0b0110000000000000,
+  0b0110000000000000,
+  0b0111111011111000,
+  0b0110000011001100,
+  0b0110000011001100,
+  0b0110000011001100,
+  0b0110000011111000,
+  0b0000000011001100,
+  0b0000000011001100,
+  0b0000000011001100,
+  0b0000000011001100,
+  0b0000000000000000,
+  0b0000000000000000
+};
+
+/************************** MAIN SCREEN *************************************/
+
+// The ST7920 does not have a degree character, but we
+// can fake it by writing it to GDRAM.
+// This function takes as an argument character positions
+// i.e x is [1-16], while the y position is [1-4]
+void ST7920_Lite_Status_Screen::draw_degree_symbol(uint8_t x, uint8_t y, bool draw) {
+  const uint8_t *p_bytes = degree_symbol;
+    if (y > 2) {
+      // Handle display folding
+      y -= 2;
+      x += 16;
+    }
+    x -= 1;
+    y -= 1;
+    const bool    oddChar = x & 1;
+    const uint8_t x_word  = x >> 1;
+    const uint8_t y_top   = degree_symbol_y_top;
+    const uint8_t y_bot   = y_top + sizeof(degree_symbol)/sizeof(degree_symbol[0]);
+    for(uint8_t i = y_top; i < y_bot; i++) {
+      uint8_t byte = pgm_read_byte_near(p_bytes++);
+      set_gdram_address(x_word,i+y*16);
+      begin_data();
+      if (draw) {
+        write_byte(oddChar ? 0x00 : byte);
+        write_byte(oddChar ? byte : 0x00);
+      }
+      else
+        write_word(0x0000);
+    }
+}
+
+void ST7920_Lite_Status_Screen::draw_static_elements() {
+  scroll_or_addr_select(0);
+
+  // Load the animated bed and fan icons
+  load_cgram_icon(CGRAM_ICON_1_ADDR, heat1_icon);
+  load_cgram_icon(CGRAM_ICON_2_ADDR, heat2_icon);
+  load_cgram_icon(CGRAM_ICON_3_ADDR, fan1_icon);
+  load_cgram_icon(CGRAM_ICON_4_ADDR, fan2_icon);
+
+  // Draw the static icons in GDRAM
+  draw_gdram_icon(1, 1, nozzle_icon);
+  #if HOTENDS > 1
+    draw_gdram_icon(1,2,nozzle_icon);
+    draw_gdram_icon(1,3,bed_icon);
+  #else
+    draw_gdram_icon(1,2,bed_icon);
+  #endif
+  draw_gdram_icon(6,2,feedrate_icon);
+
+  // Draw the initial fan icon
+  draw_fan_icon(false);
+}
+
+/**
+ * Although this is undocumented, the ST7920 allows the character
+ * data buffer (DDRAM) to be used in conjunction with the graphics
+ * bitmap buffer (CGRAM). The contents of the graphics buffer is
+ * XORed with the data from the character generator. This allows
+ * us to make the progess bar out of graphical data (the bar) and
+ * text data (the percentage).
+ */
+void ST7920_Lite_Status_Screen::draw_progress_bar(const uint8_t value) {
+  #if HOTENDS == 1
+    // If we have only one extruder, draw a long progress bar on the third line
+    const uint8_t top     = 1,         // Top in pixels
+                  bottom  = 13,        // Bottom in pixels
+                  left    = 12,        // Left edge, in 16-bit words
+                  width   = 4;         // Width of progress bar, in 16-bit words
+  #else
+    const uint8_t top     = 16 + 1,
+                  bottom  = 16 + 13,
+                  left    = 5,
+                  width   = 3;
+  #endif
+  const uint8_t char_pcnt  = 100 / width; // How many percent does each 16-bit word represent?
+
+  // Draw the progress bar as a bitmap in CGRAM
+  for (uint8_t y = top; y <= bottom; y++) {
+    set_gdram_address(left, y);
+    begin_data();
+    for (uint8_t x = 0; x < width; x++) {
+      uint16_t gfx_word = 0x0000;
+      if ((x + 1) * char_pcnt <= value)
+        gfx_word = 0xFFFF;                                              // Draw completely filled bytes
+      else if ((x * char_pcnt) < value)
+        gfx_word = int(0x8000) >> (value % char_pcnt) * 16 / char_pcnt; // Draw partially filled bytes
+
+      // Draw the frame around the progress bar
+      if (y == top || y == bottom)
+        gfx_word = 0xFFFF;        // Draw top/bottom border
+      else if (x == width - 1)
+        gfx_word |= 0x0001;       // Draw right border
+      else if (x == 0)
+        gfx_word |= 0x8000;       // Draw left border
+      write_word(gfx_word);
+    }
+  }
+
+  // Draw the percentage as text in DDRAM
+  #if HOTENDS == 1
+    set_ddram_address(DDRAM_LINE_3 + 4);
+    begin_data();
+    write_byte(' ');
+  #else
+    set_ddram_address(DDRAM_LINE_2 + left);
+    begin_data();
+  #endif
+
+  // Draw centered
+  if (value > 9) {
+    write_number(value, 4);
+    write_str(F("% "));
+  }
+  else {
+    write_number(value, 3);
+    write_str(F("%  "));
+  }
+}
+
+void ST7920_Lite_Status_Screen::draw_fan_icon(const bool whichIcon) {
+  set_ddram_address(DDRAM_LINE_1 + 5);
+  begin_data();
+  write_word(whichIcon ? CGRAM_ICON_3_WORD : CGRAM_ICON_4_WORD);
+}
+
+void ST7920_Lite_Status_Screen::draw_heat_icon(const bool whichIcon, const bool heating) {
+  set_ddram_address(
+    #if HOTENDS == 1
+      DDRAM_LINE_2
+    #else
+      DDRAM_LINE_3
+    #endif
+  );
+  begin_data();
+  if (heating)
+    write_word(whichIcon ? CGRAM_ICON_1_WORD : CGRAM_ICON_2_WORD);
+  else {
+    write_byte(' ');
+    write_byte(' ');
+  }
+}
+
+#define FAR(a,b) (((a > b) ? (a-b) : (b-a)) > 2)
+
+static struct {
+  bool E1_show_target  : 1;
+  bool E2_show_target  : 1;
+  #if HAS_HEATED_BED
+    bool bed_show_target : 1;
+  #endif
+} display_state = {
+  true, true
+  #if HAS_HEATED_BED
+    , true
+  #endif
+};
+
+void ST7920_Lite_Status_Screen::draw_temps(uint8_t line, const int16_t temp, const int16_t target, bool showTarget, bool targetStateChange) {
+  switch (line) {
+    case 1: set_ddram_address(DDRAM_LINE_1 + 1); break;
+    case 2: set_ddram_address(DDRAM_LINE_2 + 1); break;
+    case 3: set_ddram_address(DDRAM_LINE_3 + 1); break;
+    case 4: set_ddram_address(DDRAM_LINE_3 + 1); break;
+  }
+  begin_data();
+  write_number(temp);
+
+  if (showTarget) {
+    write_str(F("\x1A"));
+    write_number(target);
+  };
+
+  if (targetStateChange) {
+    if (!showTarget) write_str(F("    "));
+    draw_degree_symbol(6,  line, !showTarget);
+    draw_degree_symbol(10, line, showTarget);
+  }
+}
+
+void ST7920_Lite_Status_Screen::draw_extruder_1_temp(const int16_t temp, const int16_t target, bool forceUpdate) {
+  const bool show_target = target && FAR(temp, target);
+  draw_temps(1, temp, target, show_target, display_state.E1_show_target != show_target || forceUpdate);
+  display_state.E1_show_target = show_target;
+}
+
+void ST7920_Lite_Status_Screen::draw_extruder_2_temp(const int16_t temp, const int16_t target, bool forceUpdate) {
+  const bool show_target = target && FAR(temp, target);
+  draw_temps(2, temp, target, show_target, display_state.E2_show_target != show_target || forceUpdate);
+  display_state.E2_show_target = show_target;
+}
+
+#if HAS_HEATED_BED
+  void ST7920_Lite_Status_Screen::draw_bed_temp(const int16_t temp, const int16_t target, bool forceUpdate) {
+    const bool show_target = target && FAR(temp, target);
+    draw_temps(2
+      #if HOTENDS > 1
+        + 1
+      #endif
+      , temp, target, show_target, display_state.bed_show_target != show_target || forceUpdate
+    );
+    display_state.bed_show_target = show_target;
+  }
+#endif
+
+void ST7920_Lite_Status_Screen::draw_fan_speed(const uint8_t value) {
+  set_ddram_address(DDRAM_LINE_1 + 6);
+  begin_data();
+  write_number(value, 3);
+  write_byte('%');
+}
+
+void ST7920_Lite_Status_Screen::draw_print_time(const duration_t &elapsed) {
+  #if HOTENDS == 1
+    set_ddram_address(DDRAM_LINE_3);
+  #else
+    set_ddram_address(DDRAM_LINE_3 + 5);
+  #endif
+  char str[7];
+  str[elapsed.toDigital(str)] = ' ';
+  begin_data();
+  write_str(str, 6);
+}
+
+void ST7920_Lite_Status_Screen::draw_feedrate_percentage(const uint16_t percentage) {
+  // We only have enough room for the feedrate when
+  // we have one extruder
+  #if HOTENDS == 1
+    set_ddram_address(DDRAM_LINE_2 + 6);
+    begin_data();
+    write_number(percentage, 3);
+    write_byte('%');
+  #endif
+}
+
+void ST7920_Lite_Status_Screen::draw_status_message(const char *str) {
+  set_ddram_address(DDRAM_LINE_4);
+  begin_data();
+  const uint8_t lcd_len = 16;
+  #if ENABLED(STATUS_MESSAGE_SCROLLING)
+
+    uint8_t slen = utf8_strlen(str);
+
+    // If the string fits into the LCD, just print it and do not scroll it
+    if (slen <= lcd_len) {
+
+      // The string isn't scrolling and may not fill the screen
+      write_str(str);
+
+      // Fill the rest with spaces
+      while (slen < lcd_len) {
+        write_byte(' ');
+        ++slen;
+      }
+    }
+    else {
+      // String is larger than the available space in screen.
+
+      // Get a pointer to the next valid UTF8 character
+      const char *stat = str + status_scroll_offset;
+
+      // Get the string remaining length
+      const uint8_t rlen = utf8_strlen(stat);
+
+      // If we have enough characters to display
+      if (rlen >= lcd_len) {
+        // The remaining string fills the screen - Print it
+        write_str(stat, lcd_len);
+      }
+      else {
+        // The remaining string does not completely fill the screen
+        write_str(stat);                        // The string leaves space
+        uint8_t chars = lcd_len - rlen;         // Amount of space left in characters
+
+        write_byte('.');                        // Always at 1+ spaces left, draw a dot
+        if (--chars) {                          // Draw a second dot if there's space
+          write_byte('.');
+          if (--chars)
+            write_str(str, chars);              // Print a second copy of the message
+        }
+      }
+
+      // Adjust by complete UTF8 characters
+      if (status_scroll_offset < slen) {
+        status_scroll_offset++;
+        while (!START_OF_UTF8_CHAR(str[status_scroll_offset]))
+          status_scroll_offset++;
+      }
+      else
+        status_scroll_offset = 0;
+    }
+  #else
+    // Get the UTF8 character count of the string
+    uint8_t slen = utf8_strlen(str);
+
+    // Just print the string to the LCD
+    write_str(str, lcd_len);
+
+    // Fill the rest with spaces if there are missing spaces
+    while (slen < lcd_len) {
+      write_byte(' ');
+      ++slen;
+    }
+  #endif
+}
+
+void ST7920_Lite_Status_Screen::draw_position(const float x, const float y, const float z, bool position_known) {
+  char str[7];
+  set_ddram_address(DDRAM_LINE_4);
+  begin_data();
+
+  // If position is unknown, flash the labels.
+  const unsigned char alt_label = position_known ? 0 : (lcd_blink() ? ' ' : 0);
+
+  dtostrf(x, -4, 0, str);
+  write_byte(alt_label ? alt_label : 'X');
+  write_str(str, 4);
+
+  dtostrf(y, -4, 0, str);
+  write_byte(alt_label ? alt_label : 'Y');
+  write_str(str, 4);
+
+  dtostrf(z, -5, 1, str);
+  write_byte(alt_label ? alt_label : 'Z');
+  write_str(str, 5);
+}
+
+bool ST7920_Lite_Status_Screen::indicators_changed() {
+  // We only add the target temperatures to the checksum
+  // because the actual temps fluctuate so by updating
+  // them only during blinks we gain a bit of stability.
+  const bool       blink             = lcd_blink();
+  const uint16_t   feedrate_perc     = feedrate_percentage;
+  const uint8_t    fs                = (((uint16_t)fan_speed[0] + 1) * 100) / 256;
+  const int16_t    extruder_1_target = thermalManager.degTargetHotend(0);
+  #if HOTENDS > 1
+    const int16_t  extruder_2_target = thermalManager.degTargetHotend(1);
+  #endif
+  #if HAS_HEATED_BED
+    const int16_t  bed_target        = thermalManager.degTargetBed();
+  #endif
+  static uint16_t last_checksum = 0;
+  const uint16_t checksum = blink ^ feedrate_perc ^ fs ^ extruder_1_target
+    #if HOTENDS > 1
+      ^ extruder_2_target
+    #endif
+    #if HAS_HEATED_BED
+      ^ bed_target
+    #endif
+  ;
+  if (last_checksum == checksum) return false;
+  last_checksum = checksum;
+  return true;
+}
+
+void ST7920_Lite_Status_Screen::update_indicators(const bool forceUpdate) {
+  if (forceUpdate || indicators_changed()) {
+    const bool       blink             = lcd_blink();
+    const duration_t elapsed           = print_job_timer.duration();
+    const uint16_t   feedrate_perc     = feedrate_percentage;
+    const uint8_t    fs                = (((uint16_t)fan_speed[0] + 1) * 100) / 256;
+    const int16_t    extruder_1_temp   = thermalManager.degHotend(0),
+                     extruder_1_target = thermalManager.degTargetHotend(0);
+    #if HOTENDS > 1
+      const int16_t  extruder_2_temp   = thermalManager.degHotend(1),
+                     extruder_2_target = thermalManager.degTargetHotend(1);
+    #endif
+    #if HAS_HEATED_BED
+      const int16_t  bed_temp          = thermalManager.degBed(),
+                     bed_target        = thermalManager.degTargetBed();
+    #endif
+
+    draw_extruder_1_temp(extruder_1_temp, extruder_1_target, forceUpdate);
+    #if HOTENDS > 1
+      draw_extruder_2_temp(extruder_2_temp, extruder_2_target, forceUpdate);
+    #endif
+    #if HAS_HEATED_BED
+      draw_bed_temp(bed_temp, bed_target, forceUpdate);
+    #endif
+    draw_fan_speed(fs);
+    draw_print_time(elapsed);
+    draw_feedrate_percentage(feedrate_perc);
+
+    // Update the fan and bed animations
+    if (fs) draw_fan_icon(blink);
+    #if HAS_HEATED_BED
+      if (bed_target > 0)
+        draw_heat_icon(blink, true);
+      else
+        draw_heat_icon(false, false);
+    #endif
+  }
+}
+
+bool ST7920_Lite_Status_Screen::position_changed() {
+  const float x_pos = current_position[X_AXIS],
+              y_pos = current_position[Y_AXIS],
+              z_pos = current_position[Z_AXIS];
+  const uint8_t checksum = uint8_t(x_pos) ^ uint8_t(y_pos) ^ uint8_t(z_pos);
+
+  static uint8_t last_checksum = 0;
+  if (last_checksum == checksum) return false;
+  last_checksum = checksum;
+  return true;
+}
+
+bool ST7920_Lite_Status_Screen::status_changed() {
+  uint8_t checksum = 0;
+  for (const char *p = lcd_status_message; *p; p++) checksum ^= *p;
+  static uint8_t last_checksum = 0;
+  if (last_checksum == checksum) return false;
+  last_checksum = checksum;
+  return true;
+}
+
+bool ST7920_Lite_Status_Screen::blink_changed() {
+  static uint8_t last_blink = 0;
+  const bool blink = lcd_blink();
+  if (last_blink == blink) return false;
+  last_blink = blink;
+  return true;
+}
+
+#ifndef STATUS_EXPIRE_SECONDS
+  #define STATUS_EXPIRE_SECONDS 20
+#endif
+
+void ST7920_Lite_Status_Screen::update_status_or_position(bool forceUpdate) {
+
+  #if STATUS_EXPIRE_SECONDS
+    static uint8_t countdown = 0;
+  #endif
+
+  /**
+   * There is only enough room in the display for either the
+   * status message or the position, not both, so we choose
+   * one or another. Whenever the status message changes,
+   * we show it for a number of consecutive seconds, but
+   * then go back to showing the position as soon as the
+   * head moves, i.e:
+   *
+   *    countdown > 1    -- Show status
+   *    countdown = 1    -- Show status, until movement
+   *    countdown = 0    -- Show position
+   *
+   * If STATUS_EXPIRE_SECONDS is zero, the position display
+   * will be disabled and only the status will be shown.
+   */
+  if (forceUpdate || status_changed()) {
+    #if ENABLED(STATUS_MESSAGE_SCROLLING)
+      status_scroll_offset = 0;
+    #endif
+    #if STATUS_EXPIRE_SECONDS
+      countdown = lcd_status_message[0] ? STATUS_EXPIRE_SECONDS : 0;
+    #endif
+    draw_status_message(lcd_status_message);
+    blink_changed(); // Clear changed flag
+  }
+  #if !STATUS_EXPIRE_SECONDS
+    #if ENABLED(STATUS_MESSAGE_SCROLLING)
+      else
+        draw_status_message(lcd_status_message);
+    #endif
+  #else
+    else if (countdown > 1 && blink_changed()) {
+      countdown--;
+      #if ENABLED(STATUS_MESSAGE_SCROLLING)
+        draw_status_message(lcd_status_message);
+      #endif
+    }
+    else if (countdown > 0 && blink_changed()) {
+      if (position_changed()) {
+        countdown--;
+        forceUpdate = true;
+      }
+      #if ENABLED(STATUS_MESSAGE_SCROLLING)
+        draw_status_message(lcd_status_message);
+      #endif
+    }
+    if (countdown == 0 && (forceUpdate || position_changed() ||
+      #if DISABLED(DISABLE_REDUCED_ACCURACY_WARNING)
+        blink_changed()
+      #endif
+    )) {
+      draw_position(
+        current_position[X_AXIS],
+        current_position[Y_AXIS],
+        current_position[Z_AXIS],
+        #if ENABLED(DISABLE_REDUCED_ACCURACY_WARNING)
+          true
+        #else
+          all_axes_known()
+        #endif
+      );
+    }
+  #endif
+}
+
+void ST7920_Lite_Status_Screen::update_progress(const bool forceUpdate) {
+  #if ENABLED(LCD_SET_PROGRESS_MANUALLY) || ENABLED(SDSUPPORT)
+
+    #if DISABLED(LCD_SET_PROGRESS_MANUALLY)
+      uint8_t progress_bar_percent = 0;
+    #endif
+
+    #if ENABLED(SDSUPPORT)
+      // Progress bar % comes from SD when actively printing
+      if (IS_SD_PRINTING()) progress_bar_percent = card.percentDone();
+    #endif
+
+    // Since the progress bar involves writing
+    // quite a few bytes to GDRAM, only do this
+    // when an update is actually necessary.
+
+    static uint8_t last_progress = 0;
+    if (!forceUpdate && last_progress == progress_bar_percent) return;
+    last_progress = progress_bar_percent;
+
+    draw_progress_bar(progress_bar_percent);
+
+  #else
+
+    UNUSED(forceUpdate);
+
+  #endif // LCD_SET_PROGRESS_MANUALLY || SDSUPPORT
+}
+
+void ST7920_Lite_Status_Screen::update(const bool forceUpdate) {
+  cs();
+  update_indicators(forceUpdate);
+  update_status_or_position(forceUpdate);
+  update_progress(forceUpdate);
+  ncs();
+}
+
+void ST7920_Lite_Status_Screen::reset_state_from_unknown() {
+  _extended_function_set(true, true); // Do it twice as only one bit
+  _extended_function_set(true, true); // get set at a time.
+  _scroll_or_addr_select(false);
+}
+
+void ST7920_Lite_Status_Screen::on_entry() {
+  cs();
+  reset_state_from_unknown();
+  clear();
+  clear_gdram();
+  draw_static_elements();
+  update(true);
+  ncs();
+}
+
+void ST7920_Lite_Status_Screen::on_exit() {
+  cs();
+  clear();
+  _extended_function_set(true, true); // Restore state to what u8g expects.
+  ncs();
+}
+
+// This is called prior to the KILL screen to
+// clear the screen so we don't end up with a
+// garbled display.
+void ST7920_Lite_Status_Screen::clear_text_buffer() {
+  cs();
+  reset_state_from_unknown();
+  clear();
+  _extended_function_set(true, true); // Restore state to what u8g expects.
+  ncs();
+}
+
+void lcd_impl_status_screen_0() {
+  ST7920_Lite_Status_Screen::update(false);
+}
+
+/**
+ * In order to properly update the lite Status Screen,
+ * we must know when we have entered and left the
+ * Status Screen. Since the ultralcd code is not
+ * set up for doing this, we call this function before
+ * each update indicating whether the current screen
+ * is the Status Screen.
+ *
+ * This function keeps track of whether we have left or
+ * entered the Status Screen and calls the on_entry()
+ * and on_exit() methods for cleanup.
+ */
+void lcd_in_status(const bool inStatus) {
+  static bool lastInStatus = false;
+  if (lastInStatus == inStatus) return;
+  if ((lastInStatus = inStatus))
+    ST7920_Lite_Status_Screen::on_entry();
+  else
+    ST7920_Lite_Status_Screen::on_exit();
+}
+
+#endif // LIGHTWEIGHT_UI
