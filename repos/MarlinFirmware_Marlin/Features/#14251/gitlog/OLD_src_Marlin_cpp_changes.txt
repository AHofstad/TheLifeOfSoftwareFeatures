commit d0e1166cce60381fbdad1105d13765806a525d99
Author: Dirk O. Kaar <19971886+dok-net@users.noreply.github.com>
Date:   Fri Jan 3 02:01:38 2020 +0100

    Fix Visual Micro "Arduino IDE for Visual Studio" support (#16418)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
deleted file mode 100644
index 5dbb914863..0000000000
--- a/Marlin/src/Marlin.cpp
+++ /dev/null
@@ -1,1149 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- *
- */
-
-/**
- * About Marlin
- *
- * This firmware is a mashup between Sprinter and grbl.
- *  - https://github.com/kliment/Sprinter
- *  - https://github.com/grbl/grbl
- */
-
-#include "Marlin.h"
-
-#include "core/utility.h"
-#include "lcd/ultralcd.h"
-#include "module/motion.h"
-#include "module/planner.h"
-#include "module/stepper.h"
-#include "module/endstops.h"
-#include "module/probe.h"
-#include "module/temperature.h"
-#include "sd/cardreader.h"
-#include "module/configuration_store.h"
-#include "module/printcounter.h" // PrintCounter or Stopwatch
-#include "feature/closedloop.h"
-
-#include "HAL/shared/Delay.h"
-
-#include "module/stepper/indirection.h"
-
-#ifdef ARDUINO
-  #include <pins_arduino.h>
-#endif
-#include <math.h>
-#include "libs/nozzle.h"
-
-#include "gcode/gcode.h"
-#include "gcode/parser.h"
-#include "gcode/queue.h"
-
-#if ENABLED(TOUCH_BUTTONS)
-  #include "feature/touch/xpt2046.h"
-#endif
-
-#if ENABLED(HOST_ACTION_COMMANDS)
-  #include "feature/host_actions.h"
-#endif
-
-#if USE_BEEPER
-  #include "libs/buzzer.h"
-#endif
-
-#if ENABLED(DIGIPOT_I2C)
-  #include "feature/digipot/digipot.h"
-#endif
-
-#if ENABLED(MIXING_EXTRUDER)
-  #include "feature/mixing.h"
-#endif
-
-#if ENABLED(MAX7219_DEBUG)
-  #include "feature/Max7219_Debug_LEDs.h"
-#endif
-
-#if HAS_COLOR_LEDS
-  #include "feature/leds/leds.h"
-#endif
-
-#if ENABLED(BLTOUCH)
-  #include "feature/bltouch.h"
-#endif
-
-#if ENABLED(POLL_JOG)
-  #include "feature/joystick.h"
-#endif
-
-#if HAS_SERVOS
-  #include "module/servo.h"
-#endif
-
-#if ENABLED(DAC_STEPPER_CURRENT)
-  #include "feature/dac/stepper_dac.h"
-#endif
-
-#if ENABLED(EXPERIMENTAL_I2CBUS)
-  #include "feature/twibus.h"
-  TWIBus i2c;
-#endif
-
-#if ENABLED(I2C_POSITION_ENCODERS)
-  #include "feature/I2CPositionEncoder.h"
-#endif
-
-#if HAS_TRINAMIC && DISABLED(PSU_DEFAULT_OFF)
-  #include "feature/tmc_util.h"
-#endif
-
-#if HAS_CUTTER
-  #include "feature/spindle_laser.h"
-#endif
-
-#if ENABLED(SDSUPPORT)
-  CardReader card;
-#endif
-
-#if ENABLED(G38_PROBE_TARGET)
-  uint8_t G38_move; // = 0
-  bool G38_did_trigger; // = false
-#endif
-
-#if ENABLED(DELTA)
-  #include "module/delta.h"
-#elif IS_SCARA
-  #include "module/scara.h"
-#endif
-
-#if HAS_LEVELING
-  #include "feature/bedlevel/bedlevel.h"
-#endif
-
-#if BOTH(ADVANCED_PAUSE_FEATURE, PAUSE_PARK_NO_STEPPER_TIMEOUT)
-  #include "feature/pause.h"
-#endif
-
-#if ENABLED(POWER_LOSS_RECOVERY)
-  #include "feature/power_loss_recovery.h"
-#endif
-
-#if ENABLED(CANCEL_OBJECTS)
-  #include "feature/cancel_object.h"
-#endif
-
-#if HAS_FILAMENT_SENSOR
-  #include "feature/runout.h"
-#endif
-
-#if ENABLED(TEMP_STAT_LEDS)
-  #include "feature/leds/tempstat.h"
-#endif
-
-#if HAS_CASE_LIGHT
-  #include "feature/caselight.h"
-#endif
-
-#if HAS_FANMUX
-  #include "feature/fanmux.h"
-#endif
-
-#if DO_SWITCH_EXTRUDER || ANY(SWITCHING_NOZZLE, PARKING_EXTRUDER, MAGNETIC_PARKING_EXTRUDER, ELECTROMAGNETIC_SWITCHING_TOOLHEAD)
-  #include "module/tool_change.h"
-#endif
-
-#if ENABLED(USE_CONTROLLER_FAN)
-  #include "feature/controllerfan.h"
-#endif
-
-#if ENABLED(PRUSA_MMU2)
-  #include "feature/prusa_MMU2/mmu2.h"
-#endif
-
-#if HAS_DRIVER(L6470)
-  #include "libs/L6470/L6470_Marlin.h"
-#endif
-
-const char NUL_STR[] PROGMEM = "",
-           G28_STR[] PROGMEM = "G28",
-           M21_STR[] PROGMEM = "M21",
-           M23_STR[] PROGMEM = "M23 %s",
-           M24_STR[] PROGMEM = "M24",
-           SP_X_STR[] PROGMEM = " X",
-           SP_Y_STR[] PROGMEM = " Y",
-           SP_Z_STR[] PROGMEM = " Z",
-           SP_E_STR[] PROGMEM = " E";
-
-bool Running = true;
-
-// For M109 and M190, this flag may be cleared (by M108) to exit the wait loop
-bool wait_for_heatup = true;
-
-// For M0/M1, this flag may be cleared (by M108) to exit the wait-for-user loop
-#if HAS_RESUME_CONTINUE
-  bool wait_for_user; // = false;
-#endif
-
-#if HAS_AUTO_REPORTING || ENABLED(HOST_KEEPALIVE_FEATURE)
-  bool suspend_auto_report; // = false
-#endif
-
-// Inactivity shutdown
-millis_t max_inactive_time, // = 0
-         stepper_inactive_time = (DEFAULT_STEPPER_DEACTIVE_TIME) * 1000UL;
-
-#if PIN_EXISTS(CHDK)
-  extern millis_t chdk_timeout;
-#endif
-
-#if ENABLED(I2C_POSITION_ENCODERS)
-  I2CPositionEncodersMgr I2CPEM;
-#endif
-
-/**
- * ***************************************************************************
- * ******************************** FUNCTIONS ********************************
- * ***************************************************************************
- */
-
-void setup_killpin() {
-  #if HAS_KILL
-    SET_INPUT_PULLUP(KILL_PIN);
-  #endif
-}
-
-void setup_powerhold() {
-  #if HAS_SUICIDE
-    OUT_WRITE(SUICIDE_PIN, !SUICIDE_PIN_INVERTING);
-  #endif
-  #if ENABLED(PSU_CONTROL)
-    #if ENABLED(PSU_DEFAULT_OFF)
-      powersupply_on = true;  PSU_OFF();
-    #else
-      powersupply_on = false; PSU_ON();
-    #endif
-  #endif
-}
-
-/**
- * Stepper Reset (RigidBoard, et.al.)
- */
-#if HAS_STEPPER_RESET
-  void disableStepperDrivers() { OUT_WRITE(STEPPER_RESET_PIN, LOW); } // Drive down to keep motor driver chips in reset
-  void enableStepperDrivers()  { SET_INPUT(STEPPER_RESET_PIN); }      // Set to input, allowing pullups to pull the pin high
-#endif
-
-#if ENABLED(EXPERIMENTAL_I2CBUS) && I2C_SLAVE_ADDRESS > 0
-
-  void i2c_on_receive(int bytes) { // just echo all bytes received to serial
-    i2c.receive(bytes);
-  }
-
-  void i2c_on_request() {          // just send dummy data for now
-    i2c.reply("Hello World!\n");
-  }
-
-#endif
-
-/**
- * Sensitive pin test for M42, M226
- */
-
-#include "pins/sensitive_pins.h"
-
-bool pin_is_protected(const pin_t pin) {
-  static const pin_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
-  for (uint8_t i = 0; i < COUNT(sensitive_pins); i++) {
-    pin_t sensitive_pin;
-    memcpy_P(&sensitive_pin, &sensitive_pins[i], sizeof(pin_t));
-    if (pin == sensitive_pin) return true;
-  }
-  return false;
-}
-
-void protected_pin_err() {
-  SERIAL_ERROR_MSG(MSG_ERR_PROTECTED_PIN);
-}
-
-void quickstop_stepper() {
-  planner.quick_stop();
-  planner.synchronize();
-  set_current_from_steppers_for_axis(ALL_AXES);
-  sync_plan_position();
-}
-
-void enable_e_steppers() {
-  #define _ENA_E(N) enable_E##N();
-  REPEAT(E_STEPPERS, _ENA_E)
-}
-
-void enable_all_steppers() {
-  #if ENABLED(AUTO_POWER_CONTROL)
-    powerManager.power_on();
-  #endif
-  enable_X();
-  enable_Y();
-  enable_Z();
-  enable_e_steppers();
-}
-
-void disable_e_steppers() {
-  #define _DIS_E(N) disable_E##N();
-  REPEAT(E_STEPPERS, _DIS_E)
-}
-
-void disable_e_stepper(const uint8_t e) {
-  #define _CASE_DIS_E(N) case N: disable_E##N(); break;
-  switch (e) {
-    REPEAT(EXTRUDERS, _CASE_DIS_E)
-  }
-}
-
-void disable_all_steppers() {
-  disable_X();
-  disable_Y();
-  disable_Z();
-  disable_e_steppers();
-}
-
-#if ENABLED(G29_RETRY_AND_RECOVER)
-
-  void event_probe_failure() {
-    #ifdef ACTION_ON_G29_FAILURE
-      host_action(PSTR(ACTION_ON_G29_FAILURE));
-    #endif
-    #ifdef G29_FAILURE_COMMANDS
-      gcode.process_subcommands_now_P(PSTR(G29_FAILURE_COMMANDS));
-    #endif
-    #if ENABLED(G29_HALT_ON_FAILURE)
-      #ifdef ACTION_ON_CANCEL
-        host_action_cancel();
-      #endif
-      kill(GET_TEXT(MSG_LCD_PROBING_FAILED));
-    #endif
-  }
-
-  void event_probe_recover() {
-    #if ENABLED(HOST_PROMPT_SUPPORT)
-      host_prompt_do(PROMPT_INFO, PSTR("G29 Retrying"), PSTR("Dismiss"));
-    #endif
-    #ifdef ACTION_ON_G29_RECOVER
-      host_action(PSTR(ACTION_ON_G29_RECOVER));
-    #endif
-    #ifdef G29_RECOVER_COMMANDS
-      gcode.process_subcommands_now_P(PSTR(G29_RECOVER_COMMANDS));
-    #endif
-  }
-
-#endif
-
-#if ENABLED(ADVANCED_PAUSE_FEATURE)
-  #include "feature/pause.h"
-#else
-  constexpr bool did_pause_print = false;
-#endif
-
-/**
- * Printing is active when the print job timer is running
- */
-bool printingIsActive() {
-  return !did_pause_print && (print_job_timer.isRunning() || IS_SD_PRINTING());
-}
-
-/**
- * Printing is paused according to SD or host indicators
- */
-bool printingIsPaused() {
-  return did_pause_print || print_job_timer.isPaused() || IS_SD_PAUSED();
-}
-
-void startOrResumeJob() {
-  if (!printingIsPaused()) {
-    #if ENABLED(CANCEL_OBJECTS)
-      cancelable.reset();
-    #endif
-    #if ENABLED(LCD_SHOW_E_TOTAL)
-      e_move_accumulator = 0;
-    #endif
-    #if BOTH(LCD_SET_PROGRESS_MANUALLY, USE_M73_REMAINING_TIME)
-      ui.reset_remaining_time();
-    #endif
-  }
-  print_job_timer.start();
-}
-
-#if ENABLED(SDSUPPORT)
-
-  void abortSDPrinting() {
-    card.stopSDPrint(
-      #if SD_RESORT
-        true
-      #endif
-    );
-    queue.clear();
-    quickstop_stepper();
-    print_job_timer.stop();
-    #if DISABLED(SD_ABORT_NO_COOLDOWN)
-      thermalManager.disable_all_heaters();
-    #endif
-    thermalManager.zero_fan_speeds();
-    wait_for_heatup = false;
-    #if ENABLED(POWER_LOSS_RECOVERY)
-      card.removeJobRecoveryFile();
-    #endif
-    #ifdef EVENT_GCODE_SD_STOP
-      queue.inject_P(PSTR(EVENT_GCODE_SD_STOP));
-    #endif
-  }
-
-#endif
-
-/**
- * Manage several activities:
- *  - Check for Filament Runout
- *  - Keep the command buffer full
- *  - Check for maximum inactive time between commands
- *  - Check for maximum inactive time between stepper commands
- *  - Check if CHDK_PIN needs to go LOW
- *  - Check for KILL button held down
- *  - Check for HOME button held down
- *  - Check if cooling fan needs to be switched on
- *  - Check if an idle but hot extruder needs filament extruded (EXTRUDER_RUNOUT_PREVENT)
- *  - Pulse FET_SAFETY_PIN if it exists
- */
-
-void manage_inactivity(const bool ignore_stepper_queue/*=false*/) {
-
-  #if HAS_FILAMENT_SENSOR
-    runout.run();
-  #endif
-
-  if (queue.length < BUFSIZE) queue.get_available_commands();
-
-  const millis_t ms = millis();
-
-  if (max_inactive_time && ELAPSED(ms, gcode.previous_move_ms + max_inactive_time)) {
-    SERIAL_ERROR_START();
-    SERIAL_ECHOLNPAIR(MSG_KILL_INACTIVE_TIME, parser.command_ptr);
-    kill();
-  }
-
-  // Prevent steppers timing-out in the middle of M600
-  #if BOTH(ADVANCED_PAUSE_FEATURE, PAUSE_PARK_NO_STEPPER_TIMEOUT)
-    #define MOVE_AWAY_TEST !did_pause_print
-  #else
-    #define MOVE_AWAY_TEST true
-  #endif
-
-  if (stepper_inactive_time) {
-    static bool already_shutdown_steppers; // = false
-    if (planner.has_blocks_queued())
-      gcode.reset_stepper_timeout();
-    else if (MOVE_AWAY_TEST && !ignore_stepper_queue && ELAPSED(ms, gcode.previous_move_ms + stepper_inactive_time)) {
-      if (!already_shutdown_steppers) {
-        already_shutdown_steppers = true;  // L6470 SPI will consume 99% of free time without this
-        #if ENABLED(DISABLE_INACTIVE_X)
-          disable_X();
-        #endif
-        #if ENABLED(DISABLE_INACTIVE_Y)
-          disable_Y();
-        #endif
-        #if ENABLED(DISABLE_INACTIVE_Z)
-          disable_Z();
-        #endif
-        #if ENABLED(DISABLE_INACTIVE_E)
-          disable_e_steppers();
-        #endif
-        #if HAS_LCD_MENU && ENABLED(AUTO_BED_LEVELING_UBL)
-          if (ubl.lcd_map_control) {
-            ubl.lcd_map_control = false;
-            ui.defer_status_screen(false);
-          }
-        #endif
-      }
-    }
-    else
-      already_shutdown_steppers = false;
-  }
-
-  #if PIN_EXISTS(CHDK) // Check if pin should be set to LOW (after M240 set it HIGH)
-    if (chdk_timeout && ELAPSED(ms, chdk_timeout)) {
-      chdk_timeout = 0;
-      WRITE(CHDK_PIN, LOW);
-    }
-  #endif
-
-  #if HAS_KILL
-
-    // Check if the kill button was pressed and wait just in case it was an accidental
-    // key kill key press
-    // -------------------------------------------------------------------------------
-    static int killCount = 0;   // make the inactivity button a bit less responsive
-    const int KILL_DELAY = 750;
-    if (!READ(KILL_PIN))
-      killCount++;
-    else if (killCount > 0)
-      killCount--;
-
-    // Exceeded threshold and we can confirm that it was not accidental
-    // KILL the machine
-    // ----------------------------------------------------------------
-    if (killCount >= KILL_DELAY) {
-      SERIAL_ERROR_MSG(MSG_KILL_BUTTON);
-      kill();
-    }
-  #endif
-
-  #if HAS_HOME
-    // Handle a standalone HOME button
-    constexpr millis_t HOME_DEBOUNCE_DELAY = 1000UL;
-    static millis_t next_home_key_ms; // = 0
-    if (!IS_SD_PRINTING() && !READ(HOME_PIN)) { // HOME_PIN goes LOW when pressed
-      const millis_t ms = millis();
-      if (ELAPSED(ms, next_home_key_ms)) {
-        next_home_key_ms = ms + HOME_DEBOUNCE_DELAY;
-        LCD_MESSAGEPGM(MSG_AUTO_HOME);
-        queue.enqueue_now_P(G28_STR);
-      }
-    }
-  #endif
-
-  #if ENABLED(USE_CONTROLLER_FAN)
-    controllerfan_update(); // Check if fan should be turned on to cool stepper drivers down
-  #endif
-
-  #if ENABLED(AUTO_POWER_CONTROL)
-    powerManager.check();
-  #endif
-
-  #if ENABLED(EXTRUDER_RUNOUT_PREVENT)
-    if (thermalManager.degHotend(active_extruder) > EXTRUDER_RUNOUT_MINTEMP
-      && ELAPSED(ms, gcode.previous_move_ms + (EXTRUDER_RUNOUT_SECONDS) * 1000UL)
-      && !planner.has_blocks_queued()
-    ) {
-      #if ENABLED(SWITCHING_EXTRUDER)
-        bool oldstatus;
-        switch (active_extruder) {
-          default: oldstatus = E0_ENABLE_READ(); enable_E0(); break;
-          #if E_STEPPERS > 1
-            case 2: case 3: oldstatus = E1_ENABLE_READ(); enable_E1(); break;
-            #if E_STEPPERS > 2
-              case 4: case 5: oldstatus = E2_ENABLE_READ(); enable_E2(); break;
-            #endif // E_STEPPERS > 2
-          #endif // E_STEPPERS > 1
-        }
-      #else // !SWITCHING_EXTRUDER
-        bool oldstatus;
-        switch (active_extruder) {
-          default:
-          #define _CASE_EN(N) case N: oldstatus = E##N##_ENABLE_READ(); enable_E##N(); break;
-          REPEAT(E_STEPPERS, _CASE_EN);
-        }
-      #endif
-
-      const float olde = current_position.e;
-      current_position.e += EXTRUDER_RUNOUT_EXTRUDE;
-      line_to_current_position(MMM_TO_MMS(EXTRUDER_RUNOUT_SPEED));
-      current_position.e = olde;
-      planner.set_e_position_mm(olde);
-      planner.synchronize();
-
-      #if ENABLED(SWITCHING_EXTRUDER)
-        switch (active_extruder) {
-          default: oldstatus = E0_ENABLE_WRITE(oldstatus); break;
-          #if E_STEPPERS > 1
-            case 2: case 3: oldstatus = E1_ENABLE_WRITE(oldstatus); break;
-            #if E_STEPPERS > 2
-              case 4: case 5: oldstatus = E2_ENABLE_WRITE(oldstatus); break;
-            #endif // E_STEPPERS > 2
-          #endif // E_STEPPERS > 1
-        }
-      #else // !SWITCHING_EXTRUDER
-        switch (active_extruder) {
-          #define _CASE_RESTORE(N) case N: E##N##_ENABLE_WRITE(oldstatus); break;
-          REPEAT(E_STEPPERS, _CASE_RESTORE);
-        }
-      #endif // !SWITCHING_EXTRUDER
-
-      gcode.reset_stepper_timeout();
-    }
-  #endif // EXTRUDER_RUNOUT_PREVENT
-
-  #if ENABLED(DUAL_X_CARRIAGE)
-    // handle delayed move timeout
-    if (delayed_move_time && ELAPSED(ms, delayed_move_time + 1000UL) && IsRunning()) {
-      // travel moves have been received so enact them
-      delayed_move_time = 0xFFFFFFFFUL; // force moves to be done
-      destination = current_position;
-      prepare_move_to_destination();
-    }
-  #endif
-
-  #if ENABLED(TEMP_STAT_LEDS)
-    handle_status_leds();
-  #endif
-
-  #if ENABLED(MONITOR_DRIVER_STATUS)
-    monitor_tmc_drivers();
-  #endif
-
-  #if ENABLED(MONITOR_L6470_DRIVER_STATUS)
-    L6470.monitor_driver();
-  #endif
-
-  // Limit check_axes_activity frequency to 10Hz
-  static millis_t next_check_axes_ms = 0;
-  if (ELAPSED(ms, next_check_axes_ms)) {
-    planner.check_axes_activity();
-    next_check_axes_ms = ms + 100UL;
-  }
-
-  #if PIN_EXISTS(FET_SAFETY)
-    static millis_t FET_next;
-    if (ELAPSED(ms, FET_next)) {
-      FET_next = ms + FET_SAFETY_DELAY;  // 2uS pulse every FET_SAFETY_DELAY mS
-      OUT_WRITE(FET_SAFETY_PIN, !FET_SAFETY_INVERTED);
-      DELAY_US(2);
-      WRITE(FET_SAFETY_PIN, FET_SAFETY_INVERTED);
-    }
-  #endif
-}
-
-/**
- * Standard idle routine keeps the machine alive
- */
-void idle(
-  #if ENABLED(ADVANCED_PAUSE_FEATURE)
-    bool no_stepper_sleep/*=false*/
-  #endif
-) {
-  #if ENABLED(POWER_LOSS_RECOVERY) && PIN_EXISTS(POWER_LOSS)
-    recovery.outage();
-  #endif
-
-  #if ENABLED(SPI_ENDSTOPS)
-    if (endstops.tmc_spi_homing.any
-      #if ENABLED(IMPROVE_HOMING_RELIABILITY)
-        && ELAPSED(millis(), sg_guard_period)
-      #endif
-    ) {
-      for (uint8_t i = 4; i--;) // Read SGT 4 times per idle loop
-        if (endstops.tmc_spi_homing_check()) break;
-    }
-  #endif
-
-  #if ENABLED(MAX7219_DEBUG)
-    max7219.idle_tasks();
-  #endif
-
-  ui.update();
-
-  #if ENABLED(HOST_KEEPALIVE_FEATURE)
-    gcode.host_keepalive();
-  #endif
-
-  manage_inactivity(
-    #if ENABLED(ADVANCED_PAUSE_FEATURE)
-      no_stepper_sleep
-    #endif
-  );
-
-  thermalManager.manage_heater();
-
-  #if ENABLED(PRINTCOUNTER)
-    print_job_timer.tick();
-  #endif
-
-  #if USE_BEEPER
-    buzzer.tick();
-  #endif
-
-  #if ENABLED(I2C_POSITION_ENCODERS)
-    static millis_t i2cpem_next_update_ms;
-    if (planner.has_blocks_queued()) {
-      const millis_t ms = millis();
-      if (ELAPSED(ms, i2cpem_next_update_ms)) {
-        I2CPEM.update();
-        i2cpem_next_update_ms = ms + I2CPE_MIN_UPD_TIME_MS;
-      }
-    }
-  #endif
-
-  #ifdef HAL_IDLETASK
-    HAL_idletask();
-  #endif
-
-  #if HAS_AUTO_REPORTING
-    if (!suspend_auto_report) {
-      #if ENABLED(AUTO_REPORT_TEMPERATURES)
-        thermalManager.auto_report_temperatures();
-      #endif
-      #if ENABLED(AUTO_REPORT_SD_STATUS)
-        card.auto_report_sd_status();
-      #endif
-    }
-  #endif
-
-  #if ENABLED(USB_FLASH_DRIVE_SUPPORT)
-    Sd2Card::idle();
-  #endif
-
-  #if ENABLED(PRUSA_MMU2)
-    mmu2.mmu_loop();
-  #endif
-
-  #if ENABLED(POLL_JOG)
-    joystick.inject_jog_moves();
-  #endif
-}
-
-/**
- * Kill all activity and lock the machine.
- * After this the machine will need to be reset.
- */
-void kill(PGM_P const lcd_error/*=nullptr*/, PGM_P const lcd_component/*=nullptr*/, const bool steppers_off/*=false*/) {
-  thermalManager.disable_all_heaters();
-
-  SERIAL_ERROR_MSG(MSG_ERR_KILLED);
-
-  #if HAS_DISPLAY
-    ui.kill_screen(lcd_error ?: GET_TEXT(MSG_KILLED), lcd_component ?: NUL_STR);
-  #else
-    UNUSED(lcd_error);
-    UNUSED(lcd_component);
-  #endif
-
-  #ifdef ACTION_ON_KILL
-    host_action_kill();
-  #endif
-
-  minkill(steppers_off);
-}
-
-void minkill(const bool steppers_off/*=false*/) {
-
-  // Wait a short time (allows messages to get out before shutting down.
-  for (int i = 1000; i--;) DELAY_US(600);
-
-  cli(); // Stop interrupts
-
-  // Wait to ensure all interrupts stopped
-  for (int i = 1000; i--;) DELAY_US(250);
-
-  // Reiterate heaters off
-  thermalManager.disable_all_heaters();
-
-  // Power off all steppers (for M112) or just the E steppers
-  steppers_off ? disable_all_steppers() : disable_e_steppers();
-
-  #if ENABLED(PSU_CONTROL)
-    PSU_OFF();
-  #endif
-
-  #if HAS_SUICIDE
-    suicide();
-  #endif
-
-  #if HAS_KILL
-
-    // Wait for kill to be released
-    while (!READ(KILL_PIN)) watchdog_refresh();
-
-    // Wait for kill to be pressed
-    while (READ(KILL_PIN)) watchdog_refresh();
-
-    void (*resetFunc)() = 0;  // Declare resetFunc() at address 0
-    resetFunc();                  // Jump to address 0
-
-  #else // !HAS_KILL
-
-    for (;;) watchdog_refresh(); // Wait for reset
-
-  #endif // !HAS_KILL
-}
-
-/**
- * Turn off heaters and stop the print in progress
- * After a stop the machine may be resumed with M999
- */
-void stop() {
-  thermalManager.disable_all_heaters(); // 'unpause' taken care of in here
-  print_job_timer.stop();
-
-  #if ENABLED(PROBING_FANS_OFF)
-    if (thermalManager.fans_paused) thermalManager.set_fans_paused(false); // put things back the way they were
-  #endif
-
-  if (IsRunning()) {
-    queue.stop();
-    SERIAL_ERROR_MSG(MSG_ERR_STOPPED);
-    LCD_MESSAGEPGM(MSG_STOPPED);
-    safe_delay(350);       // allow enough time for messages to get out before stopping
-    Running = false;
-  }
-}
-
-/**
- * Marlin entry-point: Set up before the program loop
- *  - Set up the kill pin, filament runout, power hold
- *  - Start the serial port
- *  - Print startup messages and diagnostics
- *  - Get EEPROM or default settings
- *  - Initialize managers for:
- *    • temperature
- *    • planner
- *    • watchdog
- *    • stepper
- *    • photo pin
- *    • servos
- *    • LCD controller
- *    • Digipot I2C
- *    • Z probe sled
- *    • status LEDs
- */
-void setup() {
-
-  HAL_init();
-
-  #if HAS_DRIVER(L6470)
-    L6470.init();         // setup SPI and then init chips
-  #endif
-
-  #if ENABLED(MAX7219_DEBUG)
-    max7219.init();
-  #endif
-
-  #if ENABLED(DISABLE_DEBUG)
-    // Disable any hardware debug to free up pins for IO
-    #ifdef JTAGSWD_DISABLE
-      JTAGSWD_DISABLE();
-    #elif defined(JTAG_DISABLE)
-      JTAG_DISABLE();
-    #else
-      #error "DISABLE_DEBUG is not supported for the selected MCU/Board"
-    #endif
-  #elif ENABLED(DISABLE_JTAG)
-    // Disable JTAG to free up pins for IO
-    #ifdef JTAG_DISABLE
-      JTAG_DISABLE();
-    #else
-      #error "DISABLE_JTAG is not supported for the selected MCU/Board"
-    #endif
-  #endif
-
-  #if HAS_FILAMENT_SENSOR
-    runout.setup();
-  #endif
-
-  #if ENABLED(POWER_LOSS_RECOVERY)
-    recovery.setup();
-  #endif
-
-  setup_killpin();
-
-  #if HAS_TMC220x
-    tmc_serial_begin();
-  #endif
-
-  setup_powerhold();
-
-  #if HAS_STEPPER_RESET
-    disableStepperDrivers();
-  #endif
-
-  #if NUM_SERIAL > 0
-    MYSERIAL0.begin(BAUDRATE);
-    #if NUM_SERIAL > 1
-      MYSERIAL1.begin(BAUDRATE);
-    #endif
-  #endif
-
-  #if NUM_SERIAL > 0
-    uint32_t serial_connect_timeout = millis() + 1000UL;
-    while (!MYSERIAL0 && PENDING(millis(), serial_connect_timeout)) { /*nada*/ }
-    #if NUM_SERIAL > 1
-      serial_connect_timeout = millis() + 1000UL;
-      while (!MYSERIAL1 && PENDING(millis(), serial_connect_timeout)) { /*nada*/ }
-    #endif
-  #endif
-
-  SERIAL_ECHOLNPGM("start");
-  SERIAL_ECHO_START();
-
-  #if TMC_HAS_SPI
-    #if DISABLED(TMC_USE_SW_SPI)
-      SPI.begin();
-    #endif
-    tmc_init_cs_pins();
-  #endif
-
-  #ifdef BOARD_INIT
-    BOARD_INIT();
-  #endif
-
-  // Check startup - does nothing if bootloader sets MCUSR to 0
-  byte mcu = HAL_get_reset_source();
-  if (mcu &  1) SERIAL_ECHOLNPGM(MSG_POWERUP);
-  if (mcu &  2) SERIAL_ECHOLNPGM(MSG_EXTERNAL_RESET);
-  if (mcu &  4) SERIAL_ECHOLNPGM(MSG_BROWNOUT_RESET);
-  if (mcu &  8) SERIAL_ECHOLNPGM(MSG_WATCHDOG_RESET);
-  if (mcu & 32) SERIAL_ECHOLNPGM(MSG_SOFTWARE_RESET);
-  HAL_clear_reset_source();
-
-  SERIAL_ECHOPGM(MSG_MARLIN);
-  SERIAL_CHAR(' ');
-  SERIAL_ECHOLNPGM(SHORT_BUILD_VERSION);
-  SERIAL_EOL();
-
-  #if defined(STRING_DISTRIBUTION_DATE) && defined(STRING_CONFIG_H_AUTHOR)
-    SERIAL_ECHO_MSG(
-      MSG_CONFIGURATION_VER
-      STRING_DISTRIBUTION_DATE
-      MSG_AUTHOR STRING_CONFIG_H_AUTHOR
-    );
-    SERIAL_ECHO_MSG("Compiled: " __DATE__);
-  #endif
-
-  SERIAL_ECHO_START();
-  SERIAL_ECHOLNPAIR(MSG_FREE_MEMORY, freeMemory(), MSG_PLANNER_BUFFER_BYTES, (int)sizeof(block_t) * (BLOCK_BUFFER_SIZE));
-
-  // UI must be initialized before EEPROM
-  // (because EEPROM code calls the UI).
-
-  // Set up LEDs early
-  #if HAS_COLOR_LEDS
-    leds.setup();
-  #endif
-
-  ui.init();
-  #if HAS_SPI_LCD && ENABLED(SHOW_BOOTSCREEN)
-    ui.show_bootscreen();
-  #endif
-
-  #if ENABLED(SDSUPPORT)
-    card.mount(); // Mount the SD card before settings.first_load
-  #endif
-
-  // Load data from EEPROM if available (or use defaults)
-  // This also updates variables in the planner, elsewhere
-  settings.first_load();
-
-  #if ENABLED(TOUCH_BUTTONS)
-    touch.init();
-  #endif
-
-  #if HAS_M206_COMMAND
-    // Initialize current position based on home_offset
-    current_position += home_offset;
-  #endif
-
-  // Vital to init stepper/planner equivalent for current_position
-  sync_plan_position();
-
-  thermalManager.init();    // Initialize temperature loop
-
-  print_job_timer.init();   // Initial setup of print job timer
-
-  ui.reset_status();        // Print startup message after print statistics are loaded
-
-  endstops.init();          // Init endstops and pullups
-
-  stepper.init();           // Init stepper. This enables interrupts!
-
-  #if HAS_SERVOS
-    servo_init();
-  #endif
-
-  #if HAS_Z_SERVO_PROBE
-    servo_probe_init();
-  #endif
-
-  #if HAS_PHOTOGRAPH
-    OUT_WRITE(PHOTOGRAPH_PIN, LOW);
-  #endif
-
-  #if HAS_CUTTER
-    cutter.init();
-  #endif
-
-  #if ENABLED(COOLANT_MIST)
-    OUT_WRITE(COOLANT_MIST_PIN, COOLANT_MIST_INVERT);   // Init Mist Coolant OFF
-  #endif
-  #if ENABLED(COOLANT_FLOOD)
-    OUT_WRITE(COOLANT_FLOOD_PIN, COOLANT_FLOOD_INVERT); // Init Flood Coolant OFF
-  #endif
-
-  #if HAS_BED_PROBE
-    endstops.enable_z_probe(false);
-  #endif
-
-  #if ENABLED(USE_CONTROLLER_FAN)
-    SET_OUTPUT(CONTROLLER_FAN_PIN);
-  #endif
-
-  #if HAS_STEPPER_RESET
-    enableStepperDrivers();
-  #endif
-
-  #if ENABLED(DIGIPOT_I2C)
-    digipot_i2c_init();
-  #endif
-
-  #if ENABLED(DAC_STEPPER_CURRENT)
-    dac_init();
-  #endif
-
-  #if EITHER(Z_PROBE_SLED, SOLENOID_PROBE) && HAS_SOLENOID_1
-    OUT_WRITE(SOL1_PIN, LOW); // OFF
-  #endif
-
-  #if HAS_HOME
-    SET_INPUT_PULLUP(HOME_PIN);
-  #endif
-
-  #if PIN_EXISTS(STAT_LED_RED)
-    OUT_WRITE(STAT_LED_RED_PIN, LOW); // OFF
-  #endif
-
-  #if PIN_EXISTS(STAT_LED_BLUE)
-    OUT_WRITE(STAT_LED_BLUE_PIN, LOW); // OFF
-  #endif
-
-  #if HAS_CASE_LIGHT
-    #if DISABLED(CASE_LIGHT_USE_NEOPIXEL)
-      if (PWM_PIN(CASE_LIGHT_PIN)) SET_PWM(CASE_LIGHT_PIN); else SET_OUTPUT(CASE_LIGHT_PIN);
-    #endif
-    update_case_light();
-  #endif
-
-  #if ENABLED(MK2_MULTIPLEXER)
-    SET_OUTPUT(E_MUX0_PIN);
-    SET_OUTPUT(E_MUX1_PIN);
-    SET_OUTPUT(E_MUX2_PIN);
-  #endif
-
-  #if HAS_FANMUX
-    fanmux_init();
-  #endif
-
-  #if ENABLED(MIXING_EXTRUDER)
-    mixer.init();
-  #endif
-
-  #if ENABLED(BLTOUCH)
-    bltouch.init(/*set_voltage=*/true);
-  #endif
-
-  #if ENABLED(I2C_POSITION_ENCODERS)
-    I2CPEM.init();
-  #endif
-
-  #if ENABLED(EXPERIMENTAL_I2CBUS) && I2C_SLAVE_ADDRESS > 0
-    i2c.onReceive(i2c_on_receive);
-    i2c.onRequest(i2c_on_request);
-  #endif
-
-  #if DO_SWITCH_EXTRUDER
-    move_extruder_servo(0);   // Initialize extruder servo
-  #endif
-
-  #if ENABLED(SWITCHING_NOZZLE)
-    // Initialize nozzle servo(s)
-    #if SWITCHING_NOZZLE_TWO_SERVOS
-      lower_nozzle(0);
-      raise_nozzle(1);
-    #else
-      move_nozzle_servo(0);
-    #endif
-  #endif
-
-  #if ENABLED(MAGNETIC_PARKING_EXTRUDER)
-    mpe_settings_init();
-  #endif
-
-  #if ENABLED(PARKING_EXTRUDER)
-    pe_solenoid_init();
-  #endif
-
-  #if ENABLED(ELECTROMAGNETIC_SWITCHING_TOOLHEAD)
-    est_init();
-  #endif
-
-  #if ENABLED(POWER_LOSS_RECOVERY)
-    recovery.check();
-  #endif
-
-  #if ENABLED(USE_WATCHDOG)
-    watchdog_init();          // Reinit watchdog after HAL_get_reset_source call
-  #endif
-
-  #if ENABLED(EXTERNAL_CLOSED_LOOP_CONTROLLER)
-    init_closedloop();
-  #endif
-
-  #ifdef STARTUP_COMMANDS
-    queue.inject_P(PSTR(STARTUP_COMMANDS));
-  #endif
-
-  #if ENABLED(INIT_SDCARD_ON_BOOT) && !HAS_SPI_LCD
-    card.beginautostart();
-  #endif
-
-  #if ENABLED(HOST_PROMPT_SUPPORT)
-    host_action_prompt_end();
-  #endif
-
-  #if HAS_TRINAMIC && DISABLED(PSU_DEFAULT_OFF)
-    test_tmc_connection(true, true, true, true);
-  #endif
-
-  #if ENABLED(PRUSA_MMU2)
-    mmu2.init();
-  #endif
-}
-
-/**
- * The main Marlin program loop
- *
- *  - Save or log commands to SD
- *  - Process available commands (if not saving)
- *  - Call endstop manager
- *  - Call inactivity manager
- */
-void loop() {
-  do {
-
-    idle();
-
-    #if ENABLED(SDSUPPORT)
-      card.checkautostart();
-      if (card.flag.abort_sd_printing) abortSDPrinting();
-    #endif
-
-    queue.advance();
-
-    endstops.event_handler();
-
-  } while (false        // Return to caller for best compatibility
-    #ifdef __AVR__
-      || true           // Loop forever on slower (AVR) boards
-    #endif
-  );
-}

commit ac32ed74b4529dbd496713e3f2d75315d8aeebaa
Author: Lino Barreca <linobarreca@hotmail.com>
Date:   Thu Jan 2 04:13:43 2020 +0100

    Return from loop() on non-AVR boards (#16390)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index a03d1f3963..5dbb914863 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -1121,25 +1121,29 @@ void setup() {
 
 /**
  * The main Marlin program loop
  *
  *  - Save or log commands to SD
  *  - Process available commands (if not saving)
  *  - Call endstop manager
  *  - Call inactivity manager
  */
 void loop() {
+  do {
 
-  for (;;) {
-
-    idle(); // Do an idle first so boot is slightly faster
+    idle();
 
     #if ENABLED(SDSUPPORT)
       card.checkautostart();
       if (card.flag.abort_sd_printing) abortSDPrinting();
     #endif
 
     queue.advance();
 
     endstops.event_handler();
-  }
+
+  } while (false        // Return to caller for best compatibility
+    #ifdef __AVR__
+      || true           // Loop forever on slower (AVR) boards
+    #endif
+  );
 }

commit 2a7f1091ceee0554f843dfda738af1538dc5ab3f
Author: randellhodges <rhodges@taxfodder.com>
Date:   Thu Dec 12 16:51:35 2019 -0600

    Fix compile error (macro substitution typo) (#16194)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 2198672ff8..a03d1f3963 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -546,21 +546,21 @@ void manage_inactivity(const bool ignore_stepper_queue/*=false*/) {
             case 2: case 3: oldstatus = E1_ENABLE_READ(); enable_E1(); break;
             #if E_STEPPERS > 2
               case 4: case 5: oldstatus = E2_ENABLE_READ(); enable_E2(); break;
             #endif // E_STEPPERS > 2
           #endif // E_STEPPERS > 1
         }
       #else // !SWITCHING_EXTRUDER
         bool oldstatus;
         switch (active_extruder) {
           default:
-          #define _CASE_EN(N) case N: oldstatus = E##N_ENABLE_READ(); enable_E##N(); break;
+          #define _CASE_EN(N) case N: oldstatus = E##N##_ENABLE_READ(); enable_E##N(); break;
           REPEAT(E_STEPPERS, _CASE_EN);
         }
       #endif
 
       const float olde = current_position.e;
       current_position.e += EXTRUDER_RUNOUT_EXTRUDE;
       line_to_current_position(MMM_TO_MMS(EXTRUDER_RUNOUT_SPEED));
       current_position.e = olde;
       planner.set_e_position_mm(olde);
       planner.synchronize();

commit 690ed531b6e404bbc3fe85bdc4653484e5a4f3d0
Author: Felicia Hummel <felicia@drachenkatze.org>
Date:   Sat Nov 30 14:17:24 2019 +0100

    Configurable PSU power-on delay (#16050)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index f45ae9f060..2198672ff8 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -103,21 +103,21 @@
 
 #if ENABLED(EXPERIMENTAL_I2CBUS)
   #include "feature/twibus.h"
   TWIBus i2c;
 #endif
 
 #if ENABLED(I2C_POSITION_ENCODERS)
   #include "feature/I2CPositionEncoder.h"
 #endif
 
-#if HAS_TRINAMIC && DISABLED(PS_DEFAULT_OFF)
+#if HAS_TRINAMIC && DISABLED(PSU_DEFAULT_OFF)
   #include "feature/tmc_util.h"
 #endif
 
 #if HAS_CUTTER
   #include "feature/spindle_laser.h"
 #endif
 
 #if ENABLED(SDSUPPORT)
   CardReader card;
 #endif
@@ -227,21 +227,21 @@ void setup_killpin() {
   #if HAS_KILL
     SET_INPUT_PULLUP(KILL_PIN);
   #endif
 }
 
 void setup_powerhold() {
   #if HAS_SUICIDE
     OUT_WRITE(SUICIDE_PIN, !SUICIDE_PIN_INVERTING);
   #endif
   #if ENABLED(PSU_CONTROL)
-    #if ENABLED(PS_DEFAULT_OFF)
+    #if ENABLED(PSU_DEFAULT_OFF)
       powersupply_on = true;  PSU_OFF();
     #else
       powersupply_on = false; PSU_ON();
     #endif
   #endif
 }
 
 /**
  * Stepper Reset (RigidBoard, et.al.)
  */
@@ -1103,21 +1103,21 @@ void setup() {
   #endif
 
   #if ENABLED(INIT_SDCARD_ON_BOOT) && !HAS_SPI_LCD
     card.beginautostart();
   #endif
 
   #if ENABLED(HOST_PROMPT_SUPPORT)
     host_action_prompt_end();
   #endif
 
-  #if HAS_TRINAMIC && DISABLED(PS_DEFAULT_OFF)
+  #if HAS_TRINAMIC && DISABLED(PSU_DEFAULT_OFF)
     test_tmc_connection(true, true, true, true);
   #endif
 
   #if ENABLED(PRUSA_MMU2)
     mmu2.init();
   #endif
 }
 
 /**
  * The main Marlin program loop

commit 27943f9e31a4c16d981e437447f143972c92f835
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Nov 30 06:59:44 2019 -0600

    Multiple axis TMC OTPW step down (#16044)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 03210f03d0..f45ae9f060 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -594,21 +594,21 @@ void manage_inactivity(const bool ignore_stepper_queue/*=false*/) {
       destination = current_position;
       prepare_move_to_destination();
     }
   #endif
 
   #if ENABLED(TEMP_STAT_LEDS)
     handle_status_leds();
   #endif
 
   #if ENABLED(MONITOR_DRIVER_STATUS)
-    monitor_tmc_driver();
+    monitor_tmc_drivers();
   #endif
 
   #if ENABLED(MONITOR_L6470_DRIVER_STATUS)
     L6470.monitor_driver();
   #endif
 
   // Limit check_axes_activity frequency to 10Hz
   static millis_t next_check_axes_ms = 0;
   if (ELAPSED(ms, next_check_axes_ms)) {
     planner.check_axes_activity();

commit f83bc0aa13e8cf2d92ec138576cc3a620e74a982
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Nov 29 04:45:07 2019 -0600

    Optimize common strings
    
    Saves 128 bytes in testing with `mftest mega 1 -y`

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 1e1199c5bc..03210f03d0 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -174,25 +174,29 @@
 #endif
 
 #if ENABLED(PRUSA_MMU2)
   #include "feature/prusa_MMU2/mmu2.h"
 #endif
 
 #if HAS_DRIVER(L6470)
   #include "libs/L6470/L6470_Marlin.h"
 #endif
 
-const char G28_STR[] PROGMEM = "G28",
+const char NUL_STR[] PROGMEM = "",
+           G28_STR[] PROGMEM = "G28",
            M21_STR[] PROGMEM = "M21",
            M23_STR[] PROGMEM = "M23 %s",
            M24_STR[] PROGMEM = "M24",
-           NUL_STR[] PROGMEM = "";
+           SP_X_STR[] PROGMEM = " X",
+           SP_Y_STR[] PROGMEM = " Y",
+           SP_Z_STR[] PROGMEM = " Z",
+           SP_E_STR[] PROGMEM = " E";
 
 bool Running = true;
 
 // For M109 and M190, this flag may be cleared (by M108) to exit the wait loop
 bool wait_for_heatup = true;
 
 // For M0/M1, this flag may be cleared (by M108) to exit the wait-for-user loop
 #if HAS_RESUME_CONTINUE
   bool wait_for_user; // = false;
 #endif

commit b11551c7675e354d6dfec169f538136708aa9edd
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Nov 24 06:08:05 2019 -0600

    Touch UI updates for Cocoa Press (#15986)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index d7fc9910ce..1e1199c5bc 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -713,21 +713,20 @@ void idle(
 /**
  * Kill all activity and lock the machine.
  * After this the machine will need to be reset.
  */
 void kill(PGM_P const lcd_error/*=nullptr*/, PGM_P const lcd_component/*=nullptr*/, const bool steppers_off/*=false*/) {
   thermalManager.disable_all_heaters();
 
   SERIAL_ERROR_MSG(MSG_ERR_KILLED);
 
   #if HAS_DISPLAY
-    extern const char NUL_STR[];
     ui.kill_screen(lcd_error ?: GET_TEXT(MSG_KILLED), lcd_component ?: NUL_STR);
   #else
     UNUSED(lcd_error);
     UNUSED(lcd_component);
   #endif
 
   #ifdef ACTION_ON_KILL
     host_action_kill();
   #endif
 

commit 602ca5dea6b613af44629023bd438285abd0fe45
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Nov 13 02:07:09 2019 -0600

    No USE_M73_REMAINING_TIME without LCD_SET_PROGRESS_MANUALLY

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 4f8a149ba4..d7fc9910ce 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -371,21 +371,21 @@ bool printingIsPaused() {
 }
 
 void startOrResumeJob() {
   if (!printingIsPaused()) {
     #if ENABLED(CANCEL_OBJECTS)
       cancelable.reset();
     #endif
     #if ENABLED(LCD_SHOW_E_TOTAL)
       e_move_accumulator = 0;
     #endif
-    #if ENABLED(USE_M73_REMAINING_TIME)
+    #if BOTH(LCD_SET_PROGRESS_MANUALLY, USE_M73_REMAINING_TIME)
       ui.reset_remaining_time();
     #endif
   }
   print_job_timer.start();
 }
 
 #if ENABLED(SDSUPPORT)
 
   void abortSDPrinting() {
     card.stopSDPrint(

commit e110f5abce90d139a768242780780832b09aa297
Author: Roman Moravčík <roman.moravcik@gmail.com>
Date:   Wed Nov 13 02:36:54 2019 +0100

    M73 R : Set Remaining Time (#15549)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index f5ecfc9def..4f8a149ba4 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -371,20 +371,23 @@ bool printingIsPaused() {
 }
 
 void startOrResumeJob() {
   if (!printingIsPaused()) {
     #if ENABLED(CANCEL_OBJECTS)
       cancelable.reset();
     #endif
     #if ENABLED(LCD_SHOW_E_TOTAL)
       e_move_accumulator = 0;
     #endif
+    #if ENABLED(USE_M73_REMAINING_TIME)
+      ui.reset_remaining_time();
+    #endif
   }
   print_job_timer.start();
 }
 
 #if ENABLED(SDSUPPORT)
 
   void abortSDPrinting() {
     card.stopSDPrint(
       #if SD_RESORT
         true

commit 5e5045c4eefb020ddaa8aebe06297b4a3e9e8d06
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Nov 9 21:17:18 2019 -0600

    Touch UI finishing touches

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 3d547196fc..f5ecfc9def 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -710,21 +710,22 @@ void idle(
 /**
  * Kill all activity and lock the machine.
  * After this the machine will need to be reset.
  */
 void kill(PGM_P const lcd_error/*=nullptr*/, PGM_P const lcd_component/*=nullptr*/, const bool steppers_off/*=false*/) {
   thermalManager.disable_all_heaters();
 
   SERIAL_ERROR_MSG(MSG_ERR_KILLED);
 
   #if HAS_DISPLAY
-    ui.kill_screen(lcd_error ?: GET_TEXT(MSG_KILLED), lcd_component ?: PSTR(""));
+    extern const char NUL_STR[];
+    ui.kill_screen(lcd_error ?: GET_TEXT(MSG_KILLED), lcd_component ?: NUL_STR);
   #else
     UNUSED(lcd_error);
     UNUSED(lcd_component);
   #endif
 
   #ifdef ACTION_ON_KILL
     host_action_kill();
   #endif
 
   minkill(steppers_off);

commit 776632c503540c3bd2061b1b0812c091b3a4f6b4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Nov 9 17:59:04 2019 -0600

    Add and apply REPEAT macro (#15829)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index e69e4be21b..3d547196fc 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -279,45 +279,43 @@ void protected_pin_err() {
 }
 
 void quickstop_stepper() {
   planner.quick_stop();
   planner.synchronize();
   set_current_from_steppers_for_axis(ALL_AXES);
   sync_plan_position();
 }
 
 void enable_e_steppers() {
-  enable_E0(); enable_E1(); enable_E2(); enable_E3(); enable_E4(); enable_E5();
+  #define _ENA_E(N) enable_E##N();
+  REPEAT(E_STEPPERS, _ENA_E)
 }
 
 void enable_all_steppers() {
   #if ENABLED(AUTO_POWER_CONTROL)
     powerManager.power_on();
   #endif
   enable_X();
   enable_Y();
   enable_Z();
   enable_e_steppers();
 }
 
 void disable_e_steppers() {
-  disable_E0(); disable_E1(); disable_E2(); disable_E3(); disable_E4(); disable_E5();
+  #define _DIS_E(N) disable_E##N();
+  REPEAT(E_STEPPERS, _DIS_E)
 }
 
 void disable_e_stepper(const uint8_t e) {
+  #define _CASE_DIS_E(N) case N: disable_E##N(); break;
   switch (e) {
-    case 0: disable_E0(); break;
-    case 1: disable_E1(); break;
-    case 2: disable_E2(); break;
-    case 3: disable_E3(); break;
-    case 4: disable_E4(); break;
-    case 5: disable_E5(); break;
+    REPEAT(EXTRUDERS, _CASE_DIS_E)
   }
 }
 
 void disable_all_steppers() {
   disable_X();
   disable_Y();
   disable_Z();
   disable_e_steppers();
 }
 
@@ -540,74 +538,47 @@ void manage_inactivity(const bool ignore_stepper_queue/*=false*/) {
           #if E_STEPPERS > 1
             case 2: case 3: oldstatus = E1_ENABLE_READ(); enable_E1(); break;
             #if E_STEPPERS > 2
               case 4: case 5: oldstatus = E2_ENABLE_READ(); enable_E2(); break;
             #endif // E_STEPPERS > 2
           #endif // E_STEPPERS > 1
         }
       #else // !SWITCHING_EXTRUDER
         bool oldstatus;
         switch (active_extruder) {
-          default: oldstatus = E0_ENABLE_READ(); enable_E0(); break;
-          #if E_STEPPERS > 1
-            case 1: oldstatus = E1_ENABLE_READ(); enable_E1(); break;
-            #if E_STEPPERS > 2
-              case 2: oldstatus = E2_ENABLE_READ(); enable_E2(); break;
-              #if E_STEPPERS > 3
-                case 3: oldstatus = E3_ENABLE_READ(); enable_E3(); break;
-                #if E_STEPPERS > 4
-                  case 4: oldstatus = E4_ENABLE_READ(); enable_E4(); break;
-                  #if E_STEPPERS > 5
-                    case 5: oldstatus = E5_ENABLE_READ(); enable_E5(); break;
-                  #endif // E_STEPPERS > 5
-                #endif // E_STEPPERS > 4
-              #endif // E_STEPPERS > 3
-            #endif // E_STEPPERS > 2
-          #endif // E_STEPPERS > 1
+          default:
+          #define _CASE_EN(N) case N: oldstatus = E##N_ENABLE_READ(); enable_E##N(); break;
+          REPEAT(E_STEPPERS, _CASE_EN);
         }
-      #endif // !SWITCHING_EXTRUDER
+      #endif
 
       const float olde = current_position.e;
       current_position.e += EXTRUDER_RUNOUT_EXTRUDE;
       line_to_current_position(MMM_TO_MMS(EXTRUDER_RUNOUT_SPEED));
       current_position.e = olde;
       planner.set_e_position_mm(olde);
       planner.synchronize();
 
       #if ENABLED(SWITCHING_EXTRUDER)
         switch (active_extruder) {
           default: oldstatus = E0_ENABLE_WRITE(oldstatus); break;
           #if E_STEPPERS > 1
             case 2: case 3: oldstatus = E1_ENABLE_WRITE(oldstatus); break;
             #if E_STEPPERS > 2
               case 4: case 5: oldstatus = E2_ENABLE_WRITE(oldstatus); break;
             #endif // E_STEPPERS > 2
           #endif // E_STEPPERS > 1
         }
       #else // !SWITCHING_EXTRUDER
         switch (active_extruder) {
-          case 0: E0_ENABLE_WRITE(oldstatus); break;
-          #if E_STEPPERS > 1
-            case 1: E1_ENABLE_WRITE(oldstatus); break;
-            #if E_STEPPERS > 2
-              case 2: E2_ENABLE_WRITE(oldstatus); break;
-              #if E_STEPPERS > 3
-                case 3: E3_ENABLE_WRITE(oldstatus); break;
-                #if E_STEPPERS > 4
-                  case 4: E4_ENABLE_WRITE(oldstatus); break;
-                  #if E_STEPPERS > 5
-                    case 5: E5_ENABLE_WRITE(oldstatus); break;
-                  #endif // E_STEPPERS > 5
-                #endif // E_STEPPERS > 4
-              #endif // E_STEPPERS > 3
-            #endif // E_STEPPERS > 2
-          #endif // E_STEPPERS > 1
+          #define _CASE_RESTORE(N) case N: E##N##_ENABLE_WRITE(oldstatus); break;
+          REPEAT(E_STEPPERS, _CASE_RESTORE);
         }
       #endif // !SWITCHING_EXTRUDER
 
       gcode.reset_stepper_timeout();
     }
   #endif // EXTRUDER_RUNOUT_PREVENT
 
   #if ENABLED(DUAL_X_CARRIAGE)
     // handle delayed move timeout
     if (delayed_move_time && ELAPSED(ms, delayed_move_time + 1000UL) && IsRunning()) {

commit 15f94e5ee5eb35aab7d8121eeabf2b1b01104f43
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Nov 2 07:09:57 2019 -0500

    Add NUL_STR global

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 7be88a0c7e..e69e4be21b 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -177,21 +177,22 @@
   #include "feature/prusa_MMU2/mmu2.h"
 #endif
 
 #if HAS_DRIVER(L6470)
   #include "libs/L6470/L6470_Marlin.h"
 #endif
 
 const char G28_STR[] PROGMEM = "G28",
            M21_STR[] PROGMEM = "M21",
            M23_STR[] PROGMEM = "M23 %s",
-           M24_STR[] PROGMEM = "M24";
+           M24_STR[] PROGMEM = "M24",
+           NUL_STR[] PROGMEM = "";
 
 bool Running = true;
 
 // For M109 and M190, this flag may be cleared (by M108) to exit the wait loop
 bool wait_for_heatup = true;
 
 // For M0/M1, this flag may be cleared (by M108) to exit the wait-for-user loop
 #if HAS_RESUME_CONTINUE
   bool wait_for_user; // = false;
 #endif

commit 76b861d7599248c5b0c3d0b4b16039dae8be1cb5
Author: ManuelMcLure <manuel@mclure.org>
Date:   Sat Nov 2 05:13:42 2019 -0700

    Fix kill screen with null string (#15747)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 1a25101707..7be88a0c7e 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -738,21 +738,21 @@ void idle(
 /**
  * Kill all activity and lock the machine.
  * After this the machine will need to be reset.
  */
 void kill(PGM_P const lcd_error/*=nullptr*/, PGM_P const lcd_component/*=nullptr*/, const bool steppers_off/*=false*/) {
   thermalManager.disable_all_heaters();
 
   SERIAL_ERROR_MSG(MSG_ERR_KILLED);
 
   #if HAS_DISPLAY
-    ui.kill_screen(lcd_error ?: GET_TEXT(MSG_KILLED), lcd_component);
+    ui.kill_screen(lcd_error ?: GET_TEXT(MSG_KILLED), lcd_component ?: PSTR(""));
   #else
     UNUSED(lcd_error);
     UNUSED(lcd_component);
   #endif
 
   #ifdef ACTION_ON_KILL
     host_action_kill();
   #endif
 
   minkill(steppers_off);

commit ca6d00b862049773135a9ef8d04d042f0af7f9d3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Nov 1 23:51:25 2019 -0500

    Save some string flash

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index ed5c4cbde4..1a25101707 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -174,20 +174,25 @@
 #endif
 
 #if ENABLED(PRUSA_MMU2)
   #include "feature/prusa_MMU2/mmu2.h"
 #endif
 
 #if HAS_DRIVER(L6470)
   #include "libs/L6470/L6470_Marlin.h"
 #endif
 
+const char G28_STR[] PROGMEM = "G28",
+           M21_STR[] PROGMEM = "M21",
+           M23_STR[] PROGMEM = "M23 %s",
+           M24_STR[] PROGMEM = "M24";
+
 bool Running = true;
 
 // For M109 and M190, this flag may be cleared (by M108) to exit the wait loop
 bool wait_for_heatup = true;
 
 // For M0/M1, this flag may be cleared (by M108) to exit the wait-for-user loop
 #if HAS_RESUME_CONTINUE
   bool wait_for_user; // = false;
 #endif
 
@@ -502,21 +507,21 @@ void manage_inactivity(const bool ignore_stepper_queue/*=false*/) {
 
   #if HAS_HOME
     // Handle a standalone HOME button
     constexpr millis_t HOME_DEBOUNCE_DELAY = 1000UL;
     static millis_t next_home_key_ms; // = 0
     if (!IS_SD_PRINTING() && !READ(HOME_PIN)) { // HOME_PIN goes LOW when pressed
       const millis_t ms = millis();
       if (ELAPSED(ms, next_home_key_ms)) {
         next_home_key_ms = ms + HOME_DEBOUNCE_DELAY;
         LCD_MESSAGEPGM(MSG_AUTO_HOME);
-        queue.enqueue_now_P(PSTR("G28"));
+        queue.enqueue_now_P(G28_STR);
       }
     }
   #endif
 
   #if ENABLED(USE_CONTROLLER_FAN)
     controllerfan_update(); // Check if fan should be turned on to cool stepper drivers down
   #endif
 
   #if ENABLED(AUTO_POWER_CONTROL)
     powerManager.check();

commit 61225e685d80b34af582d833646a2498eacec577
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Oct 29 17:04:39 2019 -0500

    Abort SD followup

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index a49fd586d9..ed5c4cbde4 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -371,41 +371,45 @@ void startOrResumeJob() {
     #if ENABLED(CANCEL_OBJECTS)
       cancelable.reset();
     #endif
     #if ENABLED(LCD_SHOW_E_TOTAL)
       e_move_accumulator = 0;
     #endif
   }
   print_job_timer.start();
 }
 
-void abortSDPrinting() {
-  card.stopSDPrint(
-    #if SD_RESORT
-      true
+#if ENABLED(SDSUPPORT)
+
+  void abortSDPrinting() {
+    card.stopSDPrint(
+      #if SD_RESORT
+        true
+      #endif
+    );
+    queue.clear();
+    quickstop_stepper();
+    print_job_timer.stop();
+    #if DISABLED(SD_ABORT_NO_COOLDOWN)
+      thermalManager.disable_all_heaters();
     #endif
-  );
-  queue.clear();
-  quickstop_stepper();
-  print_job_timer.stop();
-  #if DISABLED(SD_ABORT_NO_COOLDOWN)
-    thermalManager.disable_all_heaters();
-  #endif
-  thermalManager.zero_fan_speeds();
-  wait_for_heatup = false;
-  #if ENABLED(POWER_LOSS_RECOVERY)
-    card.removeJobRecoveryFile();
-  #endif
-  #ifdef EVENT_GCODE_SD_STOP
-    queue.inject_P(PSTR(EVENT_GCODE_SD_STOP));
-  #endif
-}
+    thermalManager.zero_fan_speeds();
+    wait_for_heatup = false;
+    #if ENABLED(POWER_LOSS_RECOVERY)
+      card.removeJobRecoveryFile();
+    #endif
+    #ifdef EVENT_GCODE_SD_STOP
+      queue.inject_P(PSTR(EVENT_GCODE_SD_STOP));
+    #endif
+  }
+
+#endif
 
 /**
  * Manage several activities:
  *  - Check for Filament Runout
  *  - Keep the command buffer full
  *  - Check for maximum inactive time between commands
  *  - Check for maximum inactive time between stepper commands
  *  - Check if CHDK_PIN needs to go LOW
  *  - Check for KILL button held down
  *  - Check for HOME button held down

commit 583fc4ee2aa2255fa458571ccd2a7934bb265aa4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Oct 29 16:00:17 2019 -0500

    Move abortSDPrinting with others

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 40ce54fb9b..a49fd586d9 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -371,20 +371,42 @@ void startOrResumeJob() {
     #if ENABLED(CANCEL_OBJECTS)
       cancelable.reset();
     #endif
     #if ENABLED(LCD_SHOW_E_TOTAL)
       e_move_accumulator = 0;
     #endif
   }
   print_job_timer.start();
 }
 
+void abortSDPrinting() {
+  card.stopSDPrint(
+    #if SD_RESORT
+      true
+    #endif
+  );
+  queue.clear();
+  quickstop_stepper();
+  print_job_timer.stop();
+  #if DISABLED(SD_ABORT_NO_COOLDOWN)
+    thermalManager.disable_all_heaters();
+  #endif
+  thermalManager.zero_fan_speeds();
+  wait_for_heatup = false;
+  #if ENABLED(POWER_LOSS_RECOVERY)
+    card.removeJobRecoveryFile();
+  #endif
+  #ifdef EVENT_GCODE_SD_STOP
+    queue.inject_P(PSTR(EVENT_GCODE_SD_STOP));
+  #endif
+}
+
 /**
  * Manage several activities:
  *  - Check for Filament Runout
  *  - Keep the command buffer full
  *  - Check for maximum inactive time between commands
  *  - Check for maximum inactive time between stepper commands
  *  - Check if CHDK_PIN needs to go LOW
  *  - Check for KILL button held down
  *  - Check for HOME button held down
  *  - Check if cooling fan needs to be switched on
@@ -1117,41 +1139,19 @@ void setup() {
  *  - Call endstop manager
  *  - Call inactivity manager
  */
 void loop() {
 
   for (;;) {
 
     idle(); // Do an idle first so boot is slightly faster
 
     #if ENABLED(SDSUPPORT)
-
       card.checkautostart();
-
-      if (card.flag.abort_sd_printing) {
-        card.stopSDPrint(
-          #if SD_RESORT
-            true
-          #endif
-        );
-        queue.clear();
-        quickstop_stepper();
-        print_job_timer.stop();
-        #if DISABLED(SD_ABORT_NO_COOLDOWN)
-          thermalManager.disable_all_heaters();
-        #endif
-        thermalManager.zero_fan_speeds();
-        wait_for_heatup = false;
-        #if ENABLED(POWER_LOSS_RECOVERY)
-          card.removeJobRecoveryFile();
-        #endif
-        #ifdef EVENT_GCODE_SD_STOP
-          queue.inject_P(PSTR(EVENT_GCODE_SD_STOP));
-        #endif
-      }
-
-    #endif // SDSUPPORT
+      if (card.flag.abort_sd_printing) abortSDPrinting();
+    #endif
 
     queue.advance();
+
     endstops.event_handler();
   }
 }

commit 7a342ecb935e421abfef2f8ed9a8d004f4d30a9f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Oct 27 17:49:27 2019 -0500

    Show Total E during print (#15703)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index de7b592ef1..40ce54fb9b 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -360,23 +360,28 @@ bool printingIsActive() {
 }
 
 /**
  * Printing is paused according to SD or host indicators
  */
 bool printingIsPaused() {
   return did_pause_print || print_job_timer.isPaused() || IS_SD_PAUSED();
 }
 
 void startOrResumeJob() {
-  #if ENABLED(CANCEL_OBJECTS)
-    if (!printingIsPaused()) cancelable.reset();
-  #endif
+  if (!printingIsPaused()) {
+    #if ENABLED(CANCEL_OBJECTS)
+      cancelable.reset();
+    #endif
+    #if ENABLED(LCD_SHOW_E_TOTAL)
+      e_move_accumulator = 0;
+    #endif
+  }
   print_job_timer.start();
 }
 
 /**
  * Manage several activities:
  *  - Check for Filament Runout
  *  - Keep the command buffer full
  *  - Check for maximum inactive time between commands
  *  - Check for maximum inactive time between stepper commands
  *  - Check if CHDK_PIN needs to go LOW

commit e6904717396778c9ca5df6a2c4744c3f7993dd64
Author: Roman Moravčík <roman.moravcik@gmail.com>
Date:   Sat Oct 26 02:46:57 2019 +0200

    Print startup message after print statistics are loaded (#15664)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 438c70806a..de7b592ef1 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -911,22 +911,20 @@ void setup() {
 
   // UI must be initialized before EEPROM
   // (because EEPROM code calls the UI).
 
   // Set up LEDs early
   #if HAS_COLOR_LEDS
     leds.setup();
   #endif
 
   ui.init();
-  ui.reset_status();
-
   #if HAS_SPI_LCD && ENABLED(SHOW_BOOTSCREEN)
     ui.show_bootscreen();
   #endif
 
   #if ENABLED(SDSUPPORT)
     card.mount(); // Mount the SD card before settings.first_load
   #endif
 
   // Load data from EEPROM if available (or use defaults)
   // This also updates variables in the planner, elsewhere
@@ -941,20 +939,22 @@ void setup() {
     current_position += home_offset;
   #endif
 
   // Vital to init stepper/planner equivalent for current_position
   sync_plan_position();
 
   thermalManager.init();    // Initialize temperature loop
 
   print_job_timer.init();   // Initial setup of print job timer
 
+  ui.reset_status();        // Print startup message after print statistics are loaded
+
   endstops.init();          // Init endstops and pullups
 
   stepper.init();           // Init stepper. This enables interrupts!
 
   #if HAS_SERVOS
     servo_init();
   #endif
 
   #if HAS_Z_SERVO_PROBE
     servo_probe_init();

commit 408751d5e07dd01aa24d113216165211313ae66f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 25 12:26:41 2019 -0500

    Fix CANCEL_OBJECTS missing include

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 8ccd3f2153..438c70806a 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -138,20 +138,24 @@
 #endif
 
 #if BOTH(ADVANCED_PAUSE_FEATURE, PAUSE_PARK_NO_STEPPER_TIMEOUT)
   #include "feature/pause.h"
 #endif
 
 #if ENABLED(POWER_LOSS_RECOVERY)
   #include "feature/power_loss_recovery.h"
 #endif
 
+#if ENABLED(CANCEL_OBJECTS)
+  #include "feature/cancel_object.h"
+#endif
+
 #if HAS_FILAMENT_SENSOR
   #include "feature/runout.h"
 #endif
 
 #if ENABLED(TEMP_STAT_LEDS)
   #include "feature/leds/tempstat.h"
 #endif
 
 #if HAS_CASE_LIGHT
   #include "feature/caselight.h"

commit 93f001295988a335552d8fea5463a112e3aa64e4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Oct 24 15:35:40 2019 -0500

    Cancel Objects - As seen at ERRF2019 (#15590)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 62bc10ee07..8ccd3f2153 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -335,32 +335,45 @@ void disable_all_steppers() {
     #ifdef ACTION_ON_G29_RECOVER
       host_action(PSTR(ACTION_ON_G29_RECOVER));
     #endif
     #ifdef G29_RECOVER_COMMANDS
       gcode.process_subcommands_now_P(PSTR(G29_RECOVER_COMMANDS));
     #endif
   }
 
 #endif
 
+#if ENABLED(ADVANCED_PAUSE_FEATURE)
+  #include "feature/pause.h"
+#else
+  constexpr bool did_pause_print = false;
+#endif
+
 /**
  * Printing is active when the print job timer is running
  */
 bool printingIsActive() {
-  return print_job_timer.isRunning() || IS_SD_PRINTING();
+  return !did_pause_print && (print_job_timer.isRunning() || IS_SD_PRINTING());
 }
 
 /**
  * Printing is paused according to SD or host indicators
  */
 bool printingIsPaused() {
-  return print_job_timer.isPaused() || IS_SD_PAUSED();
+  return did_pause_print || print_job_timer.isPaused() || IS_SD_PAUSED();
+}
+
+void startOrResumeJob() {
+  #if ENABLED(CANCEL_OBJECTS)
+    if (!printingIsPaused()) cancelable.reset();
+  #endif
+  print_job_timer.start();
 }
 
 /**
  * Manage several activities:
  *  - Check for Filament Runout
  *  - Keep the command buffer full
  *  - Check for maximum inactive time between commands
  *  - Check for maximum inactive time between stepper commands
  *  - Check if CHDK_PIN needs to go LOW
  *  - Check for KILL button held down

commit 82fb0460132a6b42491fb578045e573ef68b6a56
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Thu Oct 24 15:07:28 2019 -0400

    Allow suicide pin inverting (#15586)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 3ef57766e2..62bc10ee07 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -210,21 +210,21 @@ millis_t max_inactive_time, // = 0
  */
 
 void setup_killpin() {
   #if HAS_KILL
     SET_INPUT_PULLUP(KILL_PIN);
   #endif
 }
 
 void setup_powerhold() {
   #if HAS_SUICIDE
-    OUT_WRITE(SUICIDE_PIN, HIGH);
+    OUT_WRITE(SUICIDE_PIN, !SUICIDE_PIN_INVERTING);
   #endif
   #if ENABLED(PSU_CONTROL)
     #if ENABLED(PS_DEFAULT_OFF)
       powersupply_on = true;  PSU_OFF();
     #else
       powersupply_on = false; PSU_ON();
     #endif
   #endif
 }
 

commit af214ff121dd977b002c9a9065f84b7ae1a66247
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Oct 22 15:43:37 2019 -0500

    Fix up PSU_CONTROL checks

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index f130221821..3ef57766e2 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -212,21 +212,21 @@ millis_t max_inactive_time, // = 0
 void setup_killpin() {
   #if HAS_KILL
     SET_INPUT_PULLUP(KILL_PIN);
   #endif
 }
 
 void setup_powerhold() {
   #if HAS_SUICIDE
     OUT_WRITE(SUICIDE_PIN, HIGH);
   #endif
-  #if HAS_POWER_SWITCH
+  #if ENABLED(PSU_CONTROL)
     #if ENABLED(PS_DEFAULT_OFF)
       powersupply_on = true;  PSU_OFF();
     #else
       powersupply_on = false; PSU_ON();
     #endif
   #endif
 }
 
 /**
  * Stepper Reset (RigidBoard, et.al.)
@@ -714,21 +714,21 @@ void minkill(const bool steppers_off/*=false*/) {
 
   // Wait to ensure all interrupts stopped
   for (int i = 1000; i--;) DELAY_US(250);
 
   // Reiterate heaters off
   thermalManager.disable_all_heaters();
 
   // Power off all steppers (for M112) or just the E steppers
   steppers_off ? disable_all_steppers() : disable_e_steppers();
 
-  #if HAS_POWER_SWITCH
+  #if ENABLED(PSU_CONTROL)
     PSU_OFF();
   #endif
 
   #if HAS_SUICIDE
     suicide();
   #endif
 
   #if HAS_KILL
 
     // Wait for kill to be released

commit 6a865a614620d71521bd3dc032adffe0bf82378c
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Wed Oct 9 18:46:10 2019 -0600

    Multi-language support (#15453)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index ef8442e867..f130221821 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -317,21 +317,21 @@ void disable_all_steppers() {
     #ifdef ACTION_ON_G29_FAILURE
       host_action(PSTR(ACTION_ON_G29_FAILURE));
     #endif
     #ifdef G29_FAILURE_COMMANDS
       gcode.process_subcommands_now_P(PSTR(G29_FAILURE_COMMANDS));
     #endif
     #if ENABLED(G29_HALT_ON_FAILURE)
       #ifdef ACTION_ON_CANCEL
         host_action_cancel();
       #endif
-      kill(PSTR(MSG_ERR_PROBING_FAILED));
+      kill(GET_TEXT(MSG_LCD_PROBING_FAILED));
     #endif
   }
 
   void event_probe_recover() {
     #if ENABLED(HOST_PROMPT_SUPPORT)
       host_prompt_do(PROMPT_INFO, PSTR("G29 Retrying"), PSTR("Dismiss"));
     #endif
     #ifdef ACTION_ON_G29_RECOVER
       host_action(PSTR(ACTION_ON_G29_RECOVER));
     #endif
@@ -679,29 +679,30 @@ void idle(
 
   #if ENABLED(POLL_JOG)
     joystick.inject_jog_moves();
   #endif
 }
 
 /**
  * Kill all activity and lock the machine.
  * After this the machine will need to be reset.
  */
-void kill(PGM_P const lcd_msg/*=nullptr*/, const bool steppers_off/*=false*/) {
+void kill(PGM_P const lcd_error/*=nullptr*/, PGM_P const lcd_component/*=nullptr*/, const bool steppers_off/*=false*/) {
   thermalManager.disable_all_heaters();
 
   SERIAL_ERROR_MSG(MSG_ERR_KILLED);
 
   #if HAS_DISPLAY
-    ui.kill_screen(lcd_msg ?: PSTR(MSG_KILLED));
+    ui.kill_screen(lcd_error ?: GET_TEXT(MSG_KILLED), lcd_component);
   #else
-    UNUSED(lcd_msg);
+    UNUSED(lcd_error);
+    UNUSED(lcd_component);
   #endif
 
   #ifdef ACTION_ON_KILL
     host_action_kill();
   #endif
 
   minkill(steppers_off);
 }
 
 void minkill(const bool steppers_off/*=false*/) {

commit cc822c1a0513362e28f1b3aff76d4c4c06446f01
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Oct 7 19:44:33 2019 -0500

    Use lambdas in menus, where possible (#15452)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 5e734795e9..ef8442e867 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -268,51 +268,36 @@ void protected_pin_err() {
   SERIAL_ERROR_MSG(MSG_ERR_PROTECTED_PIN);
 }
 
 void quickstop_stepper() {
   planner.quick_stop();
   planner.synchronize();
   set_current_from_steppers_for_axis(ALL_AXES);
   sync_plan_position();
 }
 
+void enable_e_steppers() {
+  enable_E0(); enable_E1(); enable_E2(); enable_E3(); enable_E4(); enable_E5();
+}
+
 void enable_all_steppers() {
   #if ENABLED(AUTO_POWER_CONTROL)
     powerManager.power_on();
   #endif
   enable_X();
   enable_Y();
   enable_Z();
-  enable_E0();
-  enable_E1();
-  enable_E2();
-  enable_E3();
-  enable_E4();
-  enable_E5();
-}
-
-void enable_e_steppers() {
-  enable_E0();
-  enable_E1();
-  enable_E2();
-  enable_E3();
-  enable_E4();
-  enable_E5();
+  enable_e_steppers();
 }
 
 void disable_e_steppers() {
-  disable_E0();
-  disable_E1();
-  disable_E2();
-  disable_E3();
-  disable_E4();
-  disable_E5();
+  disable_E0(); disable_E1(); disable_E2(); disable_E3(); disable_E4(); disable_E5();
 }
 
 void disable_e_stepper(const uint8_t e) {
   switch (e) {
     case 0: disable_E0(); break;
     case 1: disable_E1(); break;
     case 2: disable_E2(); break;
     case 3: disable_E3(); break;
     case 4: disable_E4(); break;
     case 5: disable_E5(); break;

commit 0322348924cfb186ba9e9597cc3b246eb086229a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Oct 2 18:51:25 2019 -0500

    Handle runout in runout.cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 07970b72fc..5e734795e9 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -166,24 +166,20 @@
 #endif
 
 #if ENABLED(USE_CONTROLLER_FAN)
   #include "feature/controllerfan.h"
 #endif
 
 #if ENABLED(PRUSA_MMU2)
   #include "feature/prusa_MMU2/mmu2.h"
 #endif
 
-#if ENABLED(EXTENSIBLE_UI)
-  #include "lcd/extensible_ui/ui_api.h"
-#endif
-
 #if HAS_DRIVER(L6470)
   #include "libs/L6470/L6470_Marlin.h"
 #endif
 
 bool Running = true;
 
 // For M109 and M190, this flag may be cleared (by M108) to exit the wait loop
 bool wait_for_heatup = true;
 
 // For M0/M1, this flag may be cleared (by M108) to exit the wait-for-user loop
@@ -323,85 +319,20 @@ void disable_e_stepper(const uint8_t e) {
   }
 }
 
 void disable_all_steppers() {
   disable_X();
   disable_Y();
   disable_Z();
   disable_e_steppers();
 }
 
-#if HAS_FILAMENT_SENSOR
-
-  void event_filament_runout() {
-
-    #if ENABLED(ADVANCED_PAUSE_FEATURE)
-      if (did_pause_print) return;  // Action already in progress. Purge triggered repeated runout.
-    #endif
-
-    #if ENABLED(EXTENSIBLE_UI)
-      ExtUI::onFilamentRunout(ExtUI::getActiveTool());
-    #endif
-
-    #if EITHER(HOST_PROMPT_SUPPORT, HOST_ACTION_COMMANDS)
-      const char tool = '0'
-        #if NUM_RUNOUT_SENSORS > 1
-          + active_extruder
-        #endif
-      ;
-    #endif
-
-    //action:out_of_filament
-    #if ENABLED(HOST_PROMPT_SUPPORT)
-      host_prompt_reason = PROMPT_FILAMENT_RUNOUT;
-      host_action_prompt_end();
-      host_action_prompt_begin(PSTR("FilamentRunout T"), false);
-      SERIAL_CHAR(tool);
-      SERIAL_EOL();
-      host_action_prompt_show();
-    #endif
-
-    const bool run_runout_script = !runout.host_handling;
-
-    #if ENABLED(HOST_ACTION_COMMANDS)
-      if (run_runout_script
-        && ( strstr(FILAMENT_RUNOUT_SCRIPT, "M600")
-          || strstr(FILAMENT_RUNOUT_SCRIPT, "M125")
-          #if ENABLED(ADVANCED_PAUSE_FEATURE)
-            || strstr(FILAMENT_RUNOUT_SCRIPT, "M25")
-          #endif
-        )
-      ) {
-        host_action_paused(false);
-      }
-      else {
-        // Legacy Repetier command for use until newer version supports standard dialog
-        // To be removed later when pause command also triggers dialog
-        #ifdef ACTION_ON_FILAMENT_RUNOUT
-          host_action(PSTR(ACTION_ON_FILAMENT_RUNOUT " T"), false);
-          SERIAL_CHAR(tool);
-          SERIAL_EOL();
-        #endif
-
-        host_action_pause(false);
-      }
-      SERIAL_ECHOPGM(" " ACTION_REASON_ON_FILAMENT_RUNOUT " ");
-      SERIAL_CHAR(tool);
-      SERIAL_EOL();
-    #endif // HOST_ACTION_COMMANDS
-
-    if (run_runout_script)
-      queue.inject_P(PSTR(FILAMENT_RUNOUT_SCRIPT));
-  }
-
-#endif // HAS_FILAMENT_SENSOR
-
 #if ENABLED(G29_RETRY_AND_RECOVER)
 
   void event_probe_failure() {
     #ifdef ACTION_ON_G29_FAILURE
       host_action(PSTR(ACTION_ON_G29_FAILURE));
     #endif
     #ifdef G29_FAILURE_COMMANDS
       gcode.process_subcommands_now_P(PSTR(G29_FAILURE_COMMANDS));
     #endif
     #if ENABLED(G29_HALT_ON_FAILURE)

commit 72d791a73682fa676959189c89dbf34e85bbfe61
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Oct 2 18:54:20 2019 -0500

    Standardize active/paused functions

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 59104ecded..07970b72fc 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -419,20 +419,34 @@ void disable_all_steppers() {
     #ifdef ACTION_ON_G29_RECOVER
       host_action(PSTR(ACTION_ON_G29_RECOVER));
     #endif
     #ifdef G29_RECOVER_COMMANDS
       gcode.process_subcommands_now_P(PSTR(G29_RECOVER_COMMANDS));
     #endif
   }
 
 #endif
 
+/**
+ * Printing is active when the print job timer is running
+ */
+bool printingIsActive() {
+  return print_job_timer.isRunning() || IS_SD_PRINTING();
+}
+
+/**
+ * Printing is paused according to SD or host indicators
+ */
+bool printingIsPaused() {
+  return print_job_timer.isPaused() || IS_SD_PAUSED();
+}
+
 /**
  * Manage several activities:
  *  - Check for Filament Runout
  *  - Keep the command buffer full
  *  - Check for maximum inactive time between commands
  *  - Check for maximum inactive time between stepper commands
  *  - Check if CHDK_PIN needs to go LOW
  *  - Check for KILL button held down
  *  - Check for HOME button held down
  *  - Check if cooling fan needs to be switched on

commit 438835f6a52ab23c9b0114a27d35941a34648592
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue Oct 1 20:59:48 2019 -0400

    Configurable Max Accel, Max Feedrate, Max Jerk edit limits (#13929)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index cd8ecb4325..59104ecded 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -755,21 +755,21 @@ void idle(
 /**
  * Kill all activity and lock the machine.
  * After this the machine will need to be reset.
  */
 void kill(PGM_P const lcd_msg/*=nullptr*/, const bool steppers_off/*=false*/) {
   thermalManager.disable_all_heaters();
 
   SERIAL_ERROR_MSG(MSG_ERR_KILLED);
 
   #if HAS_DISPLAY
-    ui.kill_screen(lcd_msg ? lcd_msg : PSTR(MSG_KILLED));
+    ui.kill_screen(lcd_msg ?: PSTR(MSG_KILLED));
   #else
     UNUSED(lcd_msg);
   #endif
 
   #ifdef ACTION_ON_KILL
     host_action_kill();
   #endif
 
   minkill(steppers_off);
 }

commit 139b7196a0eb2cf74763c9879ff5e1e14ac935c3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 29 17:57:29 2019 -0500

    Watchdog cleanup (#15283)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index d215701987..cd8ecb4325 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -794,43 +794,31 @@ void minkill(const bool steppers_off/*=false*/) {
     PSU_OFF();
   #endif
 
   #if HAS_SUICIDE
     suicide();
   #endif
 
   #if HAS_KILL
 
     // Wait for kill to be released
-    while (!READ(KILL_PIN)) {
-      #if ENABLED(USE_WATCHDOG)
-        watchdog_reset();
-      #endif
-    }
+    while (!READ(KILL_PIN)) watchdog_refresh();
 
     // Wait for kill to be pressed
-    while (READ(KILL_PIN)) {
-      #if ENABLED(USE_WATCHDOG)
-        watchdog_reset();
-      #endif
-    }
+    while (READ(KILL_PIN)) watchdog_refresh();
 
     void (*resetFunc)() = 0;  // Declare resetFunc() at address 0
     resetFunc();                  // Jump to address 0
 
   #else // !HAS_KILL
 
-    for (;;) {
-      #if ENABLED(USE_WATCHDOG)
-        watchdog_reset();
-      #endif
-    } // Wait for reset
+    for (;;) watchdog_refresh(); // Wait for reset
 
   #endif // !HAS_KILL
 }
 
 /**
  * Turn off heaters and stop the print in progress
  * After a stop the machine may be resumed with M999
  */
 void stop() {
   thermalManager.disable_all_heaters(); // 'unpause' taken care of in here

commit 50e4545255605eb506c20eb107270038b0fe7bdb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 29 04:25:39 2019 -0500

    Add custom types for position (#15204)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 89501e9bfa..d215701987 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -575,24 +575,24 @@ void manage_inactivity(const bool ignore_stepper_queue/*=false*/) {
                   #if E_STEPPERS > 5
                     case 5: oldstatus = E5_ENABLE_READ(); enable_E5(); break;
                   #endif // E_STEPPERS > 5
                 #endif // E_STEPPERS > 4
               #endif // E_STEPPERS > 3
             #endif // E_STEPPERS > 2
           #endif // E_STEPPERS > 1
         }
       #endif // !SWITCHING_EXTRUDER
 
-      const float olde = current_position[E_AXIS];
-      current_position[E_AXIS] += EXTRUDER_RUNOUT_EXTRUDE;
-      planner.buffer_line(current_position, MMM_TO_MMS(EXTRUDER_RUNOUT_SPEED), active_extruder);
-      current_position[E_AXIS] = olde;
+      const float olde = current_position.e;
+      current_position.e += EXTRUDER_RUNOUT_EXTRUDE;
+      line_to_current_position(MMM_TO_MMS(EXTRUDER_RUNOUT_SPEED));
+      current_position.e = olde;
       planner.set_e_position_mm(olde);
       planner.synchronize();
 
       #if ENABLED(SWITCHING_EXTRUDER)
         switch (active_extruder) {
           default: oldstatus = E0_ENABLE_WRITE(oldstatus); break;
           #if E_STEPPERS > 1
             case 2: case 3: oldstatus = E1_ENABLE_WRITE(oldstatus); break;
             #if E_STEPPERS > 2
               case 4: case 5: oldstatus = E2_ENABLE_WRITE(oldstatus); break;
@@ -622,21 +622,21 @@ void manage_inactivity(const bool ignore_stepper_queue/*=false*/) {
 
       gcode.reset_stepper_timeout();
     }
   #endif // EXTRUDER_RUNOUT_PREVENT
 
   #if ENABLED(DUAL_X_CARRIAGE)
     // handle delayed move timeout
     if (delayed_move_time && ELAPSED(ms, delayed_move_time + 1000UL) && IsRunning()) {
       // travel moves have been received so enact them
       delayed_move_time = 0xFFFFFFFFUL; // force moves to be done
-      set_destination_from_current();
+      destination = current_position;
       prepare_move_to_destination();
     }
   #endif
 
   #if ENABLED(TEMP_STAT_LEDS)
     handle_status_leds();
   #endif
 
   #if ENABLED(MONITOR_DRIVER_STATUS)
     monitor_tmc_driver();
@@ -995,21 +995,21 @@ void setup() {
   // Load data from EEPROM if available (or use defaults)
   // This also updates variables in the planner, elsewhere
   settings.first_load();
 
   #if ENABLED(TOUCH_BUTTONS)
     touch.init();
   #endif
 
   #if HAS_M206_COMMAND
     // Initialize current position based on home_offset
-    LOOP_XYZ(a) current_position[a] += home_offset[a];
+    current_position += home_offset;
   #endif
 
   // Vital to init stepper/planner equivalent for current_position
   sync_plan_position();
 
   thermalManager.init();    // Initialize temperature loop
 
   print_job_timer.init();   // Initial setup of print job timer
 
   endstops.init();          // Init endstops and pullups

commit 5221e2d991ccae7ff4283a60afb240165c8f0199
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Fri Sep 27 18:06:26 2019 -0400

    Restore Host Prompt Info (#15387)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 0dca9879d5..89501e9bfa 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -407,21 +407,21 @@ void disable_all_steppers() {
     #if ENABLED(G29_HALT_ON_FAILURE)
       #ifdef ACTION_ON_CANCEL
         host_action_cancel();
       #endif
       kill(PSTR(MSG_ERR_PROBING_FAILED));
     #endif
   }
 
   void event_probe_recover() {
     #if ENABLED(HOST_PROMPT_SUPPORT)
-      host_prompt_do(PROMPT_INFO, PSTR("G29 Retrying"));
+      host_prompt_do(PROMPT_INFO, PSTR("G29 Retrying"), PSTR("Dismiss"));
     #endif
     #ifdef ACTION_ON_G29_RECOVER
       host_action(PSTR(ACTION_ON_G29_RECOVER));
     #endif
     #ifdef G29_RECOVER_COMMANDS
       gcode.process_subcommands_now_P(PSTR(G29_RECOVER_COMMANDS));
     #endif
   }
 
 #endif
@@ -1148,20 +1148,24 @@ void setup() {
   #endif
 
   #ifdef STARTUP_COMMANDS
     queue.inject_P(PSTR(STARTUP_COMMANDS));
   #endif
 
   #if ENABLED(INIT_SDCARD_ON_BOOT) && !HAS_SPI_LCD
     card.beginautostart();
   #endif
 
+  #if ENABLED(HOST_PROMPT_SUPPORT)
+    host_action_prompt_end();
+  #endif
+
   #if HAS_TRINAMIC && DISABLED(PS_DEFAULT_OFF)
     test_tmc_connection(true, true, true, true);
   #endif
 
   #if ENABLED(PRUSA_MMU2)
     mmu2.init();
   #endif
 }
 
 /**

commit 665e45e0bad4254352330884a846c21aad2a2ff0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Sep 26 03:47:26 2019 -0500

    Reduce string storage, use masking 'seen'

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 8be6a345b0..0dca9879d5 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -955,24 +955,25 @@ void setup() {
   if (mcu &  8) SERIAL_ECHOLNPGM(MSG_WATCHDOG_RESET);
   if (mcu & 32) SERIAL_ECHOLNPGM(MSG_SOFTWARE_RESET);
   HAL_clear_reset_source();
 
   SERIAL_ECHOPGM(MSG_MARLIN);
   SERIAL_CHAR(' ');
   SERIAL_ECHOLNPGM(SHORT_BUILD_VERSION);
   SERIAL_EOL();
 
   #if defined(STRING_DISTRIBUTION_DATE) && defined(STRING_CONFIG_H_AUTHOR)
-    SERIAL_ECHO_START();
-    SERIAL_ECHOPGM(MSG_CONFIGURATION_VER);
-    SERIAL_ECHOPGM(STRING_DISTRIBUTION_DATE);
-    SERIAL_ECHOLNPGM(MSG_AUTHOR STRING_CONFIG_H_AUTHOR);
+    SERIAL_ECHO_MSG(
+      MSG_CONFIGURATION_VER
+      STRING_DISTRIBUTION_DATE
+      MSG_AUTHOR STRING_CONFIG_H_AUTHOR
+    );
     SERIAL_ECHO_MSG("Compiled: " __DATE__);
   #endif
 
   SERIAL_ECHO_START();
   SERIAL_ECHOLNPAIR(MSG_FREE_MEMORY, freeMemory(), MSG_PLANNER_BUFFER_BYTES, (int)sizeof(block_t) * (BLOCK_BUFFER_SIZE));
 
   // UI must be initialized before EEPROM
   // (because EEPROM code calls the UI).
 
   // Set up LEDs early

commit 04e4eb35beb00d8c68d7d909087c051df9d0f62c
Author: DrDitto <DrDitto@users.noreply.github.com>
Date:   Wed Sep 25 17:41:04 2019 -0600

    MKS_MINI, FYSETC RGB, backlight (#15334)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 46a6aa61ce..8be6a345b0 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -967,20 +967,26 @@ void setup() {
     SERIAL_ECHOPGM(STRING_DISTRIBUTION_DATE);
     SERIAL_ECHOLNPGM(MSG_AUTHOR STRING_CONFIG_H_AUTHOR);
     SERIAL_ECHO_MSG("Compiled: " __DATE__);
   #endif
 
   SERIAL_ECHO_START();
   SERIAL_ECHOLNPAIR(MSG_FREE_MEMORY, freeMemory(), MSG_PLANNER_BUFFER_BYTES, (int)sizeof(block_t) * (BLOCK_BUFFER_SIZE));
 
   // UI must be initialized before EEPROM
   // (because EEPROM code calls the UI).
+
+  // Set up LEDs early
+  #if HAS_COLOR_LEDS
+    leds.setup();
+  #endif
+
   ui.init();
   ui.reset_status();
 
   #if HAS_SPI_LCD && ENABLED(SHOW_BOOTSCREEN)
     ui.show_bootscreen();
   #endif
 
   #if ENABLED(SDSUPPORT)
     card.mount(); // Mount the SD card before settings.first_load
   #endif
@@ -1061,24 +1067,20 @@ void setup() {
   #endif
 
   #if PIN_EXISTS(STAT_LED_RED)
     OUT_WRITE(STAT_LED_RED_PIN, LOW); // OFF
   #endif
 
   #if PIN_EXISTS(STAT_LED_BLUE)
     OUT_WRITE(STAT_LED_BLUE_PIN, LOW); // OFF
   #endif
 
-  #if HAS_COLOR_LEDS
-    leds.setup();
-  #endif
-
   #if HAS_CASE_LIGHT
     #if DISABLED(CASE_LIGHT_USE_NEOPIXEL)
       if (PWM_PIN(CASE_LIGHT_PIN)) SET_PWM(CASE_LIGHT_PIN); else SET_OUTPUT(CASE_LIGHT_PIN);
     #endif
     update_case_light();
   #endif
 
   #if ENABLED(MK2_MULTIPLEXER)
     SET_OUTPUT(E_MUX0_PIN);
     SET_OUTPUT(E_MUX1_PIN);

commit f01f0d1956bb5cf0a9efb538b334ed6165a3e20f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 16 20:31:08 2019 -0500

    Drop C-style 'void' argument

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 6082f61d1a..46a6aa61ce 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -807,21 +807,21 @@ void minkill(const bool steppers_off/*=false*/) {
       #endif
     }
 
     // Wait for kill to be pressed
     while (READ(KILL_PIN)) {
       #if ENABLED(USE_WATCHDOG)
         watchdog_reset();
       #endif
     }
 
-    void (*resetFunc)(void) = 0;  // Declare resetFunc() at address 0
+    void (*resetFunc)() = 0;  // Declare resetFunc() at address 0
     resetFunc();                  // Jump to address 0
 
   #else // !HAS_KILL
 
     for (;;) {
       #if ENABLED(USE_WATCHDOG)
         watchdog_reset();
       #endif
     } // Wait for reset
 

commit 7d8c38693ff8e25262013dac607e814d9ee8401b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 16 20:27:04 2019 -0500

    Formatting

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 7d2cb53f0e..6082f61d1a 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -807,22 +807,22 @@ void minkill(const bool steppers_off/*=false*/) {
       #endif
     }
 
     // Wait for kill to be pressed
     while (READ(KILL_PIN)) {
       #if ENABLED(USE_WATCHDOG)
         watchdog_reset();
       #endif
     }
 
-    void(*resetFunc)(void) = 0; // Declare resetFunc() at address 0
-    resetFunc();                // Jump to address 0
+    void (*resetFunc)(void) = 0;  // Declare resetFunc() at address 0
+    resetFunc();                  // Jump to address 0
 
   #else // !HAS_KILL
 
     for (;;) {
       #if ENABLED(USE_WATCHDOG)
         watchdog_reset();
       #endif
     } // Wait for reset
 
   #endif // !HAS_KILL

commit d5f520388077e697209b02f64e5ade61599df970
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 15 03:10:59 2019 -0500

    Use "mount" as card verb

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 662a14a828..7d2cb53f0e 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -975,22 +975,21 @@ void setup() {
   // UI must be initialized before EEPROM
   // (because EEPROM code calls the UI).
   ui.init();
   ui.reset_status();
 
   #if HAS_SPI_LCD && ENABLED(SHOW_BOOTSCREEN)
     ui.show_bootscreen();
   #endif
 
   #if ENABLED(SDSUPPORT)
-    // Auto-mount the SD
-    card.initsd();
+    card.mount(); // Mount the SD card before settings.first_load
   #endif
 
   // Load data from EEPROM if available (or use defaults)
   // This also updates variables in the planner, elsewhere
   settings.first_load();
 
   #if ENABLED(TOUCH_BUTTONS)
     touch.init();
   #endif
 

commit 2386c147adbe22e4c4727632220c289bd79eabfa
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Sun Sep 15 10:05:01 2019 +0200

    Mount the SD card early (#15255)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index fa86ce9abf..662a14a828 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -974,23 +974,23 @@ void setup() {
 
   // UI must be initialized before EEPROM
   // (because EEPROM code calls the UI).
   ui.init();
   ui.reset_status();
 
   #if HAS_SPI_LCD && ENABLED(SHOW_BOOTSCREEN)
     ui.show_bootscreen();
   #endif
 
-  #if ENABLED(SDIO_SUPPORT) && !PIN_EXISTS(SD_DETECT)
-    // Auto-mount the SD for EEPROM.dat emulation
-    if (!card.isDetected()) card.initsd();
+  #if ENABLED(SDSUPPORT)
+    // Auto-mount the SD
+    card.initsd();
   #endif
 
   // Load data from EEPROM if available (or use defaults)
   // This also updates variables in the planner, elsewhere
   settings.first_load();
 
   #if ENABLED(TOUCH_BUTTONS)
     touch.init();
   #endif
 

commit c590e8ac05c3b417aa42ecd1f4967c4f70cfdd71
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 10 18:52:41 2019 -0500

    Improve Power-loss Recovery (#15135)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index e288e4837c..fa86ce9abf 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -665,20 +665,23 @@ void manage_inactivity(const bool ignore_stepper_queue/*=false*/) {
 }
 
 /**
  * Standard idle routine keeps the machine alive
  */
 void idle(
   #if ENABLED(ADVANCED_PAUSE_FEATURE)
     bool no_stepper_sleep/*=false*/
   #endif
 ) {
+  #if ENABLED(POWER_LOSS_RECOVERY) && PIN_EXISTS(POWER_LOSS)
+    recovery.outage();
+  #endif
 
   #if ENABLED(SPI_ENDSTOPS)
     if (endstops.tmc_spi_homing.any
       #if ENABLED(IMPROVE_HOMING_RELIABILITY)
         && ELAPSED(millis(), sg_guard_period)
       #endif
     ) {
       for (uint8_t i = 4; i--;) // Read SGT 4 times per idle loop
         if (endstops.tmc_spi_homing_check()) break;
     }

commit dbee0e9c5424770b9abf8815c0cb8b49de7db77f
Author: Jamie <vector76@users.noreply.github.com>
Date:   Sun Sep 8 00:55:34 2019 -0500

    Analog joystick jogging control (#14648)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 2311301fdc..e288e4837c 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -82,20 +82,24 @@
 #endif
 
 #if HAS_COLOR_LEDS
   #include "feature/leds/leds.h"
 #endif
 
 #if ENABLED(BLTOUCH)
   #include "feature/bltouch.h"
 #endif
 
+#if ENABLED(POLL_JOG)
+  #include "feature/joystick.h"
+#endif
+
 #if HAS_SERVOS
   #include "module/servo.h"
 #endif
 
 #if ENABLED(DAC_STEPPER_CURRENT)
   #include "feature/dac/stepper_dac.h"
 #endif
 
 #if ENABLED(EXPERIMENTAL_I2CBUS)
   #include "feature/twibus.h"
@@ -732,20 +736,24 @@ void idle(
     }
   #endif
 
   #if ENABLED(USB_FLASH_DRIVE_SUPPORT)
     Sd2Card::idle();
   #endif
 
   #if ENABLED(PRUSA_MMU2)
     mmu2.mmu_loop();
   #endif
+
+  #if ENABLED(POLL_JOG)
+    joystick.inject_jog_moves();
+  #endif
 }
 
 /**
  * Kill all activity and lock the machine.
  * After this the machine will need to be reset.
  */
 void kill(PGM_P const lcd_msg/*=nullptr*/, const bool steppers_off/*=false*/) {
   thermalManager.disable_all_heaters();
 
   SERIAL_ERROR_MSG(MSG_ERR_KILLED);

commit 93dcc22aae2c32e91535c4bda56c9f4a67de2870
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 2 01:09:45 2019 -0500

    Drop extra call to get_available_commands

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 376bd6dc91..2311301fdc 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -1186,15 +1186,14 @@ void loop() {
         #if ENABLED(POWER_LOSS_RECOVERY)
           card.removeJobRecoveryFile();
         #endif
         #ifdef EVENT_GCODE_SD_STOP
           queue.inject_P(PSTR(EVENT_GCODE_SD_STOP));
         #endif
       }
 
     #endif // SDSUPPORT
 
-    if (queue.length < BUFSIZE) queue.get_available_commands();
     queue.advance();
     endstops.event_handler();
   }
 }

commit 586b334c2ab61240607e878390ed1d53af86da69
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Aug 31 19:44:45 2019 -0500

    Split up stepper indirection (#15111)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 68f37d2a72..376bd6dc91 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -38,21 +38,21 @@
 #include "module/endstops.h"
 #include "module/probe.h"
 #include "module/temperature.h"
 #include "sd/cardreader.h"
 #include "module/configuration_store.h"
 #include "module/printcounter.h" // PrintCounter or Stopwatch
 #include "feature/closedloop.h"
 
 #include "HAL/shared/Delay.h"
 
-#include "module/stepper_indirection.h"
+#include "module/stepper/indirection.h"
 
 #ifdef ARDUINO
   #include <pins_arduino.h>
 #endif
 #include <math.h>
 #include "libs/nozzle.h"
 
 #include "gcode/gcode.h"
 #include "gcode/parser.h"
 #include "gcode/queue.h"

commit b7796bcce6a1d375b57d72db5fd4dd03d66fcceb
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Wed Aug 28 01:51:01 2019 -0400

    Disable steppers on M112 (#15065)
    
    And change verbiage to not refer to "Emergency Stop."

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index a548fc43a2..68f37d2a72 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -738,49 +738,53 @@ void idle(
 
   #if ENABLED(PRUSA_MMU2)
     mmu2.mmu_loop();
   #endif
 }
 
 /**
  * Kill all activity and lock the machine.
  * After this the machine will need to be reset.
  */
-void kill(PGM_P const lcd_msg/*=nullptr*/) {
+void kill(PGM_P const lcd_msg/*=nullptr*/, const bool steppers_off/*=false*/) {
   thermalManager.disable_all_heaters();
 
   SERIAL_ERROR_MSG(MSG_ERR_KILLED);
 
   #if HAS_DISPLAY
     ui.kill_screen(lcd_msg ? lcd_msg : PSTR(MSG_KILLED));
   #else
     UNUSED(lcd_msg);
   #endif
 
   #ifdef ACTION_ON_KILL
     host_action_kill();
   #endif
 
-  minkill();
+  minkill(steppers_off);
 }
 
-void minkill() {
+void minkill(const bool steppers_off/*=false*/) {
 
   // Wait a short time (allows messages to get out before shutting down.
   for (int i = 1000; i--;) DELAY_US(600);
 
   cli(); // Stop interrupts
 
   // Wait to ensure all interrupts stopped
   for (int i = 1000; i--;) DELAY_US(250);
 
-  thermalManager.disable_all_heaters(); // turn off heaters again
+  // Reiterate heaters off
+  thermalManager.disable_all_heaters();
+
+  // Power off all steppers (for M112) or just the E steppers
+  steppers_off ? disable_all_steppers() : disable_e_steppers();
 
   #if HAS_POWER_SWITCH
     PSU_OFF();
   #endif
 
   #if HAS_SUICIDE
     suicide();
   #endif
 
   #if HAS_KILL

commit 67f8ba6fed7bfb73241c1541f67cc74d9340c923
Author: Tim Moore <tim@youngmoores.com>
Date:   Tue Aug 20 00:40:44 2019 -0700

    Allow pullup/downs on power loss pin (#14986)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 726f67139e..a548fc43a2 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -879,20 +879,24 @@ void setup() {
       JTAG_DISABLE();
     #else
       #error "DISABLE_JTAG is not supported for the selected MCU/Board"
     #endif
   #endif
 
   #if HAS_FILAMENT_SENSOR
     runout.setup();
   #endif
 
+  #if ENABLED(POWER_LOSS_RECOVERY)
+    recovery.setup();
+  #endif
+
   setup_killpin();
 
   #if HAS_TMC220x
     tmc_serial_begin();
   #endif
 
   setup_powerhold();
 
   #if HAS_STEPPER_RESET
     disableStepperDrivers();

commit 05995d1fd6c3b85717d428ff5c0c269f7872857b
Author: Ludy <Ludy87@users.noreply.github.com>
Date:   Tue Aug 20 09:01:37 2019 +0200

    Unify buzz methods as MarlinUI::buzz (#14803)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index ebcb0dda06..726f67139e 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -58,21 +58,21 @@
 #include "gcode/queue.h"
 
 #if ENABLED(TOUCH_BUTTONS)
   #include "feature/touch/xpt2046.h"
 #endif
 
 #if ENABLED(HOST_ACTION_COMMANDS)
   #include "feature/host_actions.h"
 #endif
 
-#if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER)
+#if USE_BEEPER
   #include "libs/buzzer.h"
 #endif
 
 #if ENABLED(DIGIPOT_I2C)
   #include "feature/digipot/digipot.h"
 #endif
 
 #if ENABLED(MIXING_EXTRUDER)
   #include "feature/mixing.h"
 #endif
@@ -695,21 +695,21 @@ void idle(
       no_stepper_sleep
     #endif
   );
 
   thermalManager.manage_heater();
 
   #if ENABLED(PRINTCOUNTER)
     print_job_timer.tick();
   #endif
 
-  #if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER) && DISABLED(PCA9632_BUZZER)
+  #if USE_BEEPER
     buzzer.tick();
   #endif
 
   #if ENABLED(I2C_POSITION_ENCODERS)
     static millis_t i2cpem_next_update_ms;
     if (planner.has_blocks_queued()) {
       const millis_t ms = millis();
       if (ELAPSED(ms, i2cpem_next_update_ms)) {
         I2CPEM.update();
         i2cpem_next_update_ms = ms + I2CPE_MIN_UPD_TIME_MS;

commit 8bdb3d997048fac4dae3ee47b0d7131aa581c644
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Fri Aug 16 20:57:19 2019 -0600

    Add CONTROLLERFAN_SPEED_Z_ONLY (#14956)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index bde5a0850b..ebcb0dda06 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -541,42 +541,42 @@ void manage_inactivity(const bool ignore_stepper_queue/*=false*/) {
   #endif
 
   #if ENABLED(EXTRUDER_RUNOUT_PREVENT)
     if (thermalManager.degHotend(active_extruder) > EXTRUDER_RUNOUT_MINTEMP
       && ELAPSED(ms, gcode.previous_move_ms + (EXTRUDER_RUNOUT_SECONDS) * 1000UL)
       && !planner.has_blocks_queued()
     ) {
       #if ENABLED(SWITCHING_EXTRUDER)
         bool oldstatus;
         switch (active_extruder) {
-          default: oldstatus = E0_ENABLE_READ; enable_E0(); break;
+          default: oldstatus = E0_ENABLE_READ(); enable_E0(); break;
           #if E_STEPPERS > 1
-            case 2: case 3: oldstatus = E1_ENABLE_READ; enable_E1(); break;
+            case 2: case 3: oldstatus = E1_ENABLE_READ(); enable_E1(); break;
             #if E_STEPPERS > 2
-              case 4: case 5: oldstatus = E2_ENABLE_READ; enable_E2(); break;
+              case 4: case 5: oldstatus = E2_ENABLE_READ(); enable_E2(); break;
             #endif // E_STEPPERS > 2
           #endif // E_STEPPERS > 1
         }
       #else // !SWITCHING_EXTRUDER
         bool oldstatus;
         switch (active_extruder) {
-          default: oldstatus = E0_ENABLE_READ; enable_E0(); break;
+          default: oldstatus = E0_ENABLE_READ(); enable_E0(); break;
           #if E_STEPPERS > 1
-            case 1: oldstatus = E1_ENABLE_READ; enable_E1(); break;
+            case 1: oldstatus = E1_ENABLE_READ(); enable_E1(); break;
             #if E_STEPPERS > 2
-              case 2: oldstatus = E2_ENABLE_READ; enable_E2(); break;
+              case 2: oldstatus = E2_ENABLE_READ(); enable_E2(); break;
               #if E_STEPPERS > 3
-                case 3: oldstatus = E3_ENABLE_READ; enable_E3(); break;
+                case 3: oldstatus = E3_ENABLE_READ(); enable_E3(); break;
                 #if E_STEPPERS > 4
-                  case 4: oldstatus = E4_ENABLE_READ; enable_E4(); break;
+                  case 4: oldstatus = E4_ENABLE_READ(); enable_E4(); break;
                   #if E_STEPPERS > 5
-                    case 5: oldstatus = E5_ENABLE_READ; enable_E5(); break;
+                    case 5: oldstatus = E5_ENABLE_READ(); enable_E5(); break;
                   #endif // E_STEPPERS > 5
                 #endif // E_STEPPERS > 4
               #endif // E_STEPPERS > 3
             #endif // E_STEPPERS > 2
           #endif // E_STEPPERS > 1
         }
       #endif // !SWITCHING_EXTRUDER
 
       const float olde = current_position[E_AXIS];
       current_position[E_AXIS] += EXTRUDER_RUNOUT_EXTRUDE;

commit 179d6c4ed115e67ae826b5738e0009c6be2d58ea
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Wed Aug 14 20:05:15 2019 -0600

    Add STARTUP_SCRIPT option. M17 parity with M18. (#14953)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index d6285225c1..bde5a0850b 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -283,20 +283,29 @@ void enable_all_steppers() {
   enable_Y();
   enable_Z();
   enable_E0();
   enable_E1();
   enable_E2();
   enable_E3();
   enable_E4();
   enable_E5();
 }
 
+void enable_e_steppers() {
+  enable_E0();
+  enable_E1();
+  enable_E2();
+  enable_E3();
+  enable_E4();
+  enable_E5();
+}
+
 void disable_e_steppers() {
   disable_E0();
   disable_E1();
   disable_E2();
   disable_E3();
   disable_E4();
   disable_E5();
 }
 
 void disable_e_stepper(const uint8_t e) {
@@ -1110,20 +1119,24 @@ void setup() {
   #endif
 
   #if ENABLED(USE_WATCHDOG)
     watchdog_init();          // Reinit watchdog after HAL_get_reset_source call
   #endif
 
   #if ENABLED(EXTERNAL_CLOSED_LOOP_CONTROLLER)
     init_closedloop();
   #endif
 
+  #ifdef STARTUP_COMMANDS
+    queue.inject_P(PSTR(STARTUP_COMMANDS));
+  #endif
+
   #if ENABLED(INIT_SDCARD_ON_BOOT) && !HAS_SPI_LCD
     card.beginautostart();
   #endif
 
   #if HAS_TRINAMIC && DISABLED(PS_DEFAULT_OFF)
     test_tmc_connection(true, true, true, true);
   #endif
 
   #if ENABLED(PRUSA_MMU2)
     mmu2.init();

commit a7f10212659118201ec3fa97d1fd39db95dc2df4
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Sat Aug 10 00:00:20 2019 +0200

    Fix SPI_ENDSTOPS compile error (#14906)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 993dd26529..d6285225c1 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -654,23 +654,28 @@ void manage_inactivity(const bool ignore_stepper_queue/*=false*/) {
 /**
  * Standard idle routine keeps the machine alive
  */
 void idle(
   #if ENABLED(ADVANCED_PAUSE_FEATURE)
     bool no_stepper_sleep/*=false*/
   #endif
 ) {
 
   #if ENABLED(SPI_ENDSTOPS)
-    if (endstops.tmc_spi_homing.any && ELAPSED(millis(), sg_guard_period))
+    if (endstops.tmc_spi_homing.any
+      #if ENABLED(IMPROVE_HOMING_RELIABILITY)
+        && ELAPSED(millis(), sg_guard_period)
+      #endif
+    ) {
       for (uint8_t i = 4; i--;) // Read SGT 4 times per idle loop
         if (endstops.tmc_spi_homing_check()) break;
+    }
   #endif
 
   #if ENABLED(MAX7219_DEBUG)
     max7219.idle_tasks();
   #endif
 
   ui.update();
 
   #if ENABLED(HOST_KEEPALIVE_FEATURE)
     gcode.host_keepalive();

commit 77f637763cf89a12515c3c29337466ed7d6557cf
Author: Tim Moore <tim@youngmoores.com>
Date:   Tue Aug 6 21:25:47 2019 -0700

    Overlord configs. Fix buzzer, redundant temp. (#14833)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index e526919b4d..993dd26529 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -681,21 +681,21 @@ void idle(
       no_stepper_sleep
     #endif
   );
 
   thermalManager.manage_heater();
 
   #if ENABLED(PRINTCOUNTER)
     print_job_timer.tick();
   #endif
 
-  #if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER)
+  #if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER) && DISABLED(PCA9632_BUZZER)
     buzzer.tick();
   #endif
 
   #if ENABLED(I2C_POSITION_ENCODERS)
     static millis_t i2cpem_next_update_ms;
     if (planner.has_blocks_queued()) {
       const millis_t ms = millis();
       if (ELAPSED(ms, i2cpem_next_update_ms)) {
         I2CPEM.update();
         i2cpem_next_update_ms = ms + I2CPE_MIN_UPD_TIME_MS;

commit 5bc2fb022ca437d7e70f195bdb7d946ceb3a623a
Author: Robby Candra <robbycandra.mail@gmail.com>
Date:   Tue Aug 6 08:33:15 2019 +0700

    THERMAL_PROTECTION_GRACE_PERIOD is obsolete (#14798)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 8e2aa56a8f..e526919b4d 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -1130,20 +1130,22 @@ void setup() {
  *
  *  - Save or log commands to SD
  *  - Process available commands (if not saving)
  *  - Call endstop manager
  *  - Call inactivity manager
  */
 void loop() {
 
   for (;;) {
 
+    idle(); // Do an idle first so boot is slightly faster
+
     #if ENABLED(SDSUPPORT)
 
       card.checkautostart();
 
       if (card.flag.abort_sd_printing) {
         card.stopSDPrint(
           #if SD_RESORT
             true
           #endif
         );
@@ -1161,13 +1163,12 @@ void loop() {
         #ifdef EVENT_GCODE_SD_STOP
           queue.inject_P(PSTR(EVENT_GCODE_SD_STOP));
         #endif
       }
 
     #endif // SDSUPPORT
 
     if (queue.length < BUFSIZE) queue.get_available_commands();
     queue.advance();
     endstops.event_handler();
-    idle();
   }
 }

commit d4974ea719ceba2d76a678f77942d0b92e8fecb8
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Mon Aug 5 06:22:58 2019 +0300

    TMC SPI Endstops and Improved Sensorless Homing (#14044)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index d1f5fe53b6..8e2aa56a8f 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -652,20 +652,27 @@ void manage_inactivity(const bool ignore_stepper_queue/*=false*/) {
 }
 
 /**
  * Standard idle routine keeps the machine alive
  */
 void idle(
   #if ENABLED(ADVANCED_PAUSE_FEATURE)
     bool no_stepper_sleep/*=false*/
   #endif
 ) {
+
+  #if ENABLED(SPI_ENDSTOPS)
+    if (endstops.tmc_spi_homing.any && ELAPSED(millis(), sg_guard_period))
+      for (uint8_t i = 4; i--;) // Read SGT 4 times per idle loop
+        if (endstops.tmc_spi_homing_check()) break;
+  #endif
+
   #if ENABLED(MAX7219_DEBUG)
     max7219.idle_tasks();
   #endif
 
   ui.update();
 
   #if ENABLED(HOST_KEEPALIVE_FEATURE)
     gcode.host_keepalive();
   #endif
 

commit 1088846caef6f660d5af65e1725a6a6deeef16fd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jul 24 01:52:36 2019 -0500

    Cosmetic updates from 14044

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index c248e4814b..d1f5fe53b6 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -680,23 +680,26 @@ void idle(
   #if ENABLED(PRINTCOUNTER)
     print_job_timer.tick();
   #endif
 
   #if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER)
     buzzer.tick();
   #endif
 
   #if ENABLED(I2C_POSITION_ENCODERS)
     static millis_t i2cpem_next_update_ms;
-    if (planner.has_blocks_queued() && ELAPSED(millis(), i2cpem_next_update_ms)) {
-      I2CPEM.update();
-      i2cpem_next_update_ms = millis() + I2CPE_MIN_UPD_TIME_MS;
+    if (planner.has_blocks_queued()) {
+      const millis_t ms = millis();
+      if (ELAPSED(ms, i2cpem_next_update_ms)) {
+        I2CPEM.update();
+        i2cpem_next_update_ms = ms + I2CPE_MIN_UPD_TIME_MS;
+      }
     }
   #endif
 
   #ifdef HAL_IDLETASK
     HAL_idletask();
   #endif
 
   #if HAS_AUTO_REPORTING
     if (!suspend_auto_report) {
       #if ENABLED(AUTO_REPORT_TEMPERATURES)

commit 81d629bc471dcf926337836d1dd76910d9ff4bfe
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Mon Jul 15 01:16:26 2019 +0200

    Robin & Longer3D SPI TFT driver (#14595)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index d94fa51ac4..c248e4814b 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -50,20 +50,24 @@
 #ifdef ARDUINO
   #include <pins_arduino.h>
 #endif
 #include <math.h>
 #include "libs/nozzle.h"
 
 #include "gcode/gcode.h"
 #include "gcode/parser.h"
 #include "gcode/queue.h"
 
+#if ENABLED(TOUCH_BUTTONS)
+  #include "feature/touch/xpt2046.h"
+#endif
+
 #if ENABLED(HOST_ACTION_COMMANDS)
   #include "feature/host_actions.h"
 #endif
 
 #if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER)
   #include "libs/buzzer.h"
 #endif
 
 #if ENABLED(DIGIPOT_I2C)
   #include "feature/digipot/digipot.h"
@@ -936,20 +940,24 @@ void setup() {
 
   #if ENABLED(SDIO_SUPPORT) && !PIN_EXISTS(SD_DETECT)
     // Auto-mount the SD for EEPROM.dat emulation
     if (!card.isDetected()) card.initsd();
   #endif
 
   // Load data from EEPROM if available (or use defaults)
   // This also updates variables in the planner, elsewhere
   settings.first_load();
 
+  #if ENABLED(TOUCH_BUTTONS)
+    touch.init();
+  #endif
+
   #if HAS_M206_COMMAND
     // Initialize current position based on home_offset
     LOOP_XYZ(a) current_position[a] += home_offset[a];
   #endif
 
   // Vital to init stepper/planner equivalent for current_position
   sync_plan_position();
 
   thermalManager.init();    // Initialize temperature loop
 

commit 1a349c75229604c113c83d29c2ff06f61153b44a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jul 8 22:59:51 2019 -0500

    Add HAS_TMC220x

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 12bac48b6c..d94fa51ac4 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -853,21 +853,21 @@ void setup() {
       #error "DISABLE_JTAG is not supported for the selected MCU/Board"
     #endif
   #endif
 
   #if HAS_FILAMENT_SENSOR
     runout.setup();
   #endif
 
   setup_killpin();
 
-  #if HAS_DRIVER(TMC2208) || HAS_DRIVER(TMC2209)
+  #if HAS_TMC220x
     tmc_serial_begin();
   #endif
 
   setup_powerhold();
 
   #if HAS_STEPPER_RESET
     disableStepperDrivers();
   #endif
 
   #if NUM_SERIAL > 0

commit 8873c583d3694c98112e88af26f6d4dd37f5fe64
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Sat Jul 6 05:25:59 2019 +0200

    Prevent extra settings.load on boot (#14499)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index e73066fabf..12bac48b6c 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -934,21 +934,21 @@ void setup() {
     ui.show_bootscreen();
   #endif
 
   #if ENABLED(SDIO_SUPPORT) && !PIN_EXISTS(SD_DETECT)
     // Auto-mount the SD for EEPROM.dat emulation
     if (!card.isDetected()) card.initsd();
   #endif
 
   // Load data from EEPROM if available (or use defaults)
   // This also updates variables in the planner, elsewhere
-  (void)settings.load();
+  settings.first_load();
 
   #if HAS_M206_COMMAND
     // Initialize current position based on home_offset
     LOOP_XYZ(a) current_position[a] += home_offset[a];
   #endif
 
   // Vital to init stepper/planner equivalent for current_position
   sync_plan_position();
 
   thermalManager.init();    // Initialize temperature loop

commit de462f2b8a72716bf6e6558e63a1002658da7907
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jul 3 19:11:30 2019 -0500

    Revert "Sort out settings.load with SD EEPROM emulation (#14458)"
    
    This reverts commit 108d0df56532e4eb30467d36b0fb2aa5bf4f50be.

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index bbc0499425..e73066fabf 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -934,23 +934,21 @@ void setup() {
     ui.show_bootscreen();
   #endif
 
   #if ENABLED(SDIO_SUPPORT) && !PIN_EXISTS(SD_DETECT)
     // Auto-mount the SD for EEPROM.dat emulation
     if (!card.isDetected()) card.initsd();
   #endif
 
   // Load data from EEPROM if available (or use defaults)
   // This also updates variables in the planner, elsewhere
-  #if DISABLED(SD_EEPROM_EMULATION)
-    (void)settings.load();
-  #endif
+  (void)settings.load();
 
   #if HAS_M206_COMMAND
     // Initialize current position based on home_offset
     LOOP_XYZ(a) current_position[a] += home_offset[a];
   #endif
 
   // Vital to init stepper/planner equivalent for current_position
   sync_plan_position();
 
   thermalManager.init();    // Initialize temperature loop
@@ -1089,31 +1087,22 @@ void setup() {
   #endif
 
   #if ENABLED(USE_WATCHDOG)
     watchdog_init();          // Reinit watchdog after HAL_get_reset_source call
   #endif
 
   #if ENABLED(EXTERNAL_CLOSED_LOOP_CONTROLLER)
     init_closedloop();
   #endif
 
-  #if !HAS_SPI_LCD
-
-    #if ENABLED(SD_EEPROM_EMULATION)
-      SERIAL_ECHOLNPGM("Loading settings from SD");
-      (void)settings.load();
-    #endif
-
-    #if ENABLED(INIT_SDCARD_ON_BOOT)
-      card.beginautostart();
-    #endif
-
+  #if ENABLED(INIT_SDCARD_ON_BOOT) && !HAS_SPI_LCD
+    card.beginautostart();
   #endif
 
   #if HAS_TRINAMIC && DISABLED(PS_DEFAULT_OFF)
     test_tmc_connection(true, true, true, true);
   #endif
 
   #if ENABLED(PRUSA_MMU2)
     mmu2.init();
   #endif
 }

commit 108d0df56532e4eb30467d36b0fb2aa5bf4f50be
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Mon Jul 1 16:10:17 2019 +0200

    Sort out settings.load with SD EEPROM emulation (#14458)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index e73066fabf..bbc0499425 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -934,21 +934,23 @@ void setup() {
     ui.show_bootscreen();
   #endif
 
   #if ENABLED(SDIO_SUPPORT) && !PIN_EXISTS(SD_DETECT)
     // Auto-mount the SD for EEPROM.dat emulation
     if (!card.isDetected()) card.initsd();
   #endif
 
   // Load data from EEPROM if available (or use defaults)
   // This also updates variables in the planner, elsewhere
-  (void)settings.load();
+  #if DISABLED(SD_EEPROM_EMULATION)
+    (void)settings.load();
+  #endif
 
   #if HAS_M206_COMMAND
     // Initialize current position based on home_offset
     LOOP_XYZ(a) current_position[a] += home_offset[a];
   #endif
 
   // Vital to init stepper/planner equivalent for current_position
   sync_plan_position();
 
   thermalManager.init();    // Initialize temperature loop
@@ -1087,22 +1089,31 @@ void setup() {
   #endif
 
   #if ENABLED(USE_WATCHDOG)
     watchdog_init();          // Reinit watchdog after HAL_get_reset_source call
   #endif
 
   #if ENABLED(EXTERNAL_CLOSED_LOOP_CONTROLLER)
     init_closedloop();
   #endif
 
-  #if ENABLED(INIT_SDCARD_ON_BOOT) && !HAS_SPI_LCD
-    card.beginautostart();
+  #if !HAS_SPI_LCD
+
+    #if ENABLED(SD_EEPROM_EMULATION)
+      SERIAL_ECHOLNPGM("Loading settings from SD");
+      (void)settings.load();
+    #endif
+
+    #if ENABLED(INIT_SDCARD_ON_BOOT)
+      card.beginautostart();
+    #endif
+
   #endif
 
   #if HAS_TRINAMIC && DISABLED(PS_DEFAULT_OFF)
     test_tmc_connection(true, true, true, true);
   #endif
 
   #if ENABLED(PRUSA_MMU2)
     mmu2.init();
   #endif
 }

commit 2f932a11b3bacb50c520fed0549551e2e363a41a
Author: Aliaksei Kvitsinski <aleksei.wm@gmail.com>
Date:   Mon Jul 1 13:55:23 2019 +0300

    Park heads with electromagnet (#14023)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index a60c62501d..e73066fabf 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -146,21 +146,21 @@
 #endif
 
 #if HAS_CASE_LIGHT
   #include "feature/caselight.h"
 #endif
 
 #if HAS_FANMUX
   #include "feature/fanmux.h"
 #endif
 
-#if DO_SWITCH_EXTRUDER || ANY(SWITCHING_NOZZLE, PARKING_EXTRUDER, MAGNETIC_PARKING_EXTRUDER)
+#if DO_SWITCH_EXTRUDER || ANY(SWITCHING_NOZZLE, PARKING_EXTRUDER, MAGNETIC_PARKING_EXTRUDER, ELECTROMAGNETIC_SWITCHING_TOOLHEAD)
   #include "module/tool_change.h"
 #endif
 
 #if ENABLED(USE_CONTROLLER_FAN)
   #include "feature/controllerfan.h"
 #endif
 
 #if ENABLED(PRUSA_MMU2)
   #include "feature/prusa_MMU2/mmu2.h"
 #endif
@@ -1071,20 +1071,24 @@ void setup() {
   #endif
 
   #if ENABLED(MAGNETIC_PARKING_EXTRUDER)
     mpe_settings_init();
   #endif
 
   #if ENABLED(PARKING_EXTRUDER)
     pe_solenoid_init();
   #endif
 
+  #if ENABLED(ELECTROMAGNETIC_SWITCHING_TOOLHEAD)
+    est_init();
+  #endif
+
   #if ENABLED(POWER_LOSS_RECOVERY)
     recovery.check();
   #endif
 
   #if ENABLED(USE_WATCHDOG)
     watchdog_init();          // Reinit watchdog after HAL_get_reset_source call
   #endif
 
   #if ENABLED(EXTERNAL_CLOSED_LOOP_CONTROLLER)
     init_closedloop();

commit 93cd66ac1146603e8a9911fceb3c63f4351f4d8e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 23:57:50 2019 -0500

    Tweaky change from (C) to (c)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index cd02fc38e9..a60c62501d 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -1,16 +1,16 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

commit d7d80418aedad1c89e27fcba6aab9aa48187b5cc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jun 27 23:06:49 2019 -0500

    Singleton for cutting tools (#14429)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 4ec88d8aef..cd02fc38e9 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -99,20 +99,24 @@
 #endif
 
 #if ENABLED(I2C_POSITION_ENCODERS)
   #include "feature/I2CPositionEncoder.h"
 #endif
 
 #if HAS_TRINAMIC && DISABLED(PS_DEFAULT_OFF)
   #include "feature/tmc_util.h"
 #endif
 
+#if HAS_CUTTER
+  #include "feature/spindle_laser.h"
+#endif
+
 #if ENABLED(SDSUPPORT)
   CardReader card;
 #endif
 
 #if ENABLED(G38_PROBE_TARGET)
   uint8_t G38_move; // = 0
   bool G38_did_trigger; // = false
 #endif
 
 #if ENABLED(DELTA)
@@ -960,29 +964,22 @@ void setup() {
   #endif
 
   #if HAS_Z_SERVO_PROBE
     servo_probe_init();
   #endif
 
   #if HAS_PHOTOGRAPH
     OUT_WRITE(PHOTOGRAPH_PIN, LOW);
   #endif
 
-  #if ENABLED(SPINDLE_LASER_ENABLE)
-    OUT_WRITE(SPINDLE_LASER_ENA_PIN, !SPINDLE_LASER_ENABLE_INVERT);  // init spindle to off
-    #if SPINDLE_DIR_CHANGE
-      OUT_WRITE(SPINDLE_DIR_PIN, SPINDLE_INVERT_DIR ? 255 : 0);  // init rotation to clockwise (M3)
-    #endif
-    #if ENABLED(SPINDLE_LASER_PWM) && defined(SPINDLE_LASER_PWM_PIN) && SPINDLE_LASER_PWM_PIN >= 0
-      SET_PWM(SPINDLE_LASER_PWM_PIN);
-      analogWrite(SPINDLE_LASER_PWM_PIN, SPINDLE_LASER_PWM_INVERT ? 255 : 0);  // set to lowest speed
-    #endif
+  #if HAS_CUTTER
+    cutter.init();
   #endif
 
   #if ENABLED(COOLANT_MIST)
     OUT_WRITE(COOLANT_MIST_PIN, COOLANT_MIST_INVERT);   // Init Mist Coolant OFF
   #endif
   #if ENABLED(COOLANT_FLOOD)
     OUT_WRITE(COOLANT_FLOOD_PIN, COOLANT_FLOOD_INVERT); // Init Flood Coolant OFF
   #endif
 
   #if HAS_BED_PROBE

commit 7e16835c835bc7d0a55f78dd759448f558967478
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jun 27 22:14:43 2019 -0500

    Use LCD conditionals in pins files (#14428)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 6224f95f1b..4ec88d8aef 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -1086,21 +1086,21 @@ void setup() {
   #endif
 
   #if ENABLED(USE_WATCHDOG)
     watchdog_init();          // Reinit watchdog after HAL_get_reset_source call
   #endif
 
   #if ENABLED(EXTERNAL_CLOSED_LOOP_CONTROLLER)
     init_closedloop();
   #endif
 
-  #if ENABLED(INIT_SDCARD_ON_BOOT) && DISABLED(ULTRA_LCD)
+  #if ENABLED(INIT_SDCARD_ON_BOOT) && !HAS_SPI_LCD
     card.beginautostart();
   #endif
 
   #if HAS_TRINAMIC && DISABLED(PS_DEFAULT_OFF)
     test_tmc_connection(true, true, true, true);
   #endif
 
   #if ENABLED(PRUSA_MMU2)
     mmu2.init();
   #endif

commit 6664b90bbbcb164219822df96fc5cc613bb500d1
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jun 27 16:29:17 2019 -0500

    Init servo pins in HAL_init (#14425)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 08042dd5c5..6224f95f1b 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -815,23 +815,21 @@ void stop() {
  *    • stepper
  *    • photo pin
  *    • servos
  *    • LCD controller
  *    • Digipot I2C
  *    • Z probe sled
  *    • status LEDs
  */
 void setup() {
 
-  #ifdef HAL_INIT
-    HAL_init();
-  #endif
+  HAL_init();
 
   #if HAS_DRIVER(L6470)
     L6470.init();         // setup SPI and then init chips
   #endif
 
   #if ENABLED(MAX7219_DEBUG)
     max7219.init();
   #endif
 
   #if ENABLED(DISABLE_DEBUG)

commit ce656e2a268a120ccef77a7d80cc5c1c4fcc7f7e
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Thu Jun 27 16:07:45 2019 -0400

    Update G-code injection, sub-commands (#14418)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index cc4ee1b705..08042dd5c5 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -495,33 +495,30 @@ void manage_inactivity(const bool ignore_stepper_queue/*=false*/) {
     // Exceeded threshold and we can confirm that it was not accidental
     // KILL the machine
     // ----------------------------------------------------------------
     if (killCount >= KILL_DELAY) {
       SERIAL_ERROR_MSG(MSG_KILL_BUTTON);
       kill();
     }
   #endif
 
   #if HAS_HOME
-    // Check to see if we have to home, use poor man's debouncer
-    // ---------------------------------------------------------
-    static int homeDebounceCount = 0;   // poor man's debouncing count
-    const int HOME_DEBOUNCE_DELAY = 2500;
-    if (!IS_SD_PRINTING() && !READ(HOME_PIN)) {
-      if (!homeDebounceCount) {
-        queue.inject_P(PSTR("G28"));
+    // Handle a standalone HOME button
+    constexpr millis_t HOME_DEBOUNCE_DELAY = 1000UL;
+    static millis_t next_home_key_ms; // = 0
+    if (!IS_SD_PRINTING() && !READ(HOME_PIN)) { // HOME_PIN goes LOW when pressed
+      const millis_t ms = millis();
+      if (ELAPSED(ms, next_home_key_ms)) {
+        next_home_key_ms = ms + HOME_DEBOUNCE_DELAY;
         LCD_MESSAGEPGM(MSG_AUTO_HOME);
+        queue.enqueue_now_P(PSTR("G28"));
       }
-      if (homeDebounceCount < HOME_DEBOUNCE_DELAY)
-        homeDebounceCount++;
-      else
-        homeDebounceCount = 0;
     }
   #endif
 
   #if ENABLED(USE_CONTROLLER_FAN)
     controllerfan_update(); // Check if fan should be turned on to cool stepper drivers down
   #endif
 
   #if ENABLED(AUTO_POWER_CONTROL)
     powerManager.check();
   #endif

commit 064177154ce7912293efa67c7e0dfcaa4a7301ec
Author: Andy Shaw <andy-git@gloomy-place.com>
Date:   Wed Jun 26 09:55:57 2019 +0100

    Update SD card connection / sharing options (#14325)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index d94f0d183e..cc4ee1b705 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -1091,21 +1091,21 @@ void setup() {
   #endif
 
   #if ENABLED(USE_WATCHDOG)
     watchdog_init();          // Reinit watchdog after HAL_get_reset_source call
   #endif
 
   #if ENABLED(EXTERNAL_CLOSED_LOOP_CONTROLLER)
     init_closedloop();
   #endif
 
-  #if ENABLED(SDSUPPORT) && DISABLED(ULTRA_LCD)
+  #if ENABLED(INIT_SDCARD_ON_BOOT) && DISABLED(ULTRA_LCD)
     card.beginautostart();
   #endif
 
   #if HAS_TRINAMIC && DISABLED(PS_DEFAULT_OFF)
     test_tmc_connection(true, true, true, true);
   #endif
 
   #if ENABLED(PRUSA_MMU2)
     mmu2.init();
   #endif

commit 4df4c47994f248428ae30218800803e467327b6e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jun 20 15:47:50 2019 -0500

    Add TMC2209 support (#14249)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index ef07116368..d94f0d183e 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -854,22 +854,22 @@ void setup() {
       #error "DISABLE_JTAG is not supported for the selected MCU/Board"
     #endif
   #endif
 
   #if HAS_FILAMENT_SENSOR
     runout.setup();
   #endif
 
   setup_killpin();
 
-  #if HAS_DRIVER(TMC2208)
-    tmc2208_serial_begin();
+  #if HAS_DRIVER(TMC2208) || HAS_DRIVER(TMC2209)
+    tmc_serial_begin();
   #endif
 
   setup_powerhold();
 
   #if HAS_STEPPER_RESET
     disableStepperDrivers();
   #endif
 
   #if NUM_SERIAL > 0
     MYSERIAL0.begin(BAUDRATE);

commit 4c872a01f284cbf181f52c84e2ba6b4618e62556
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jun 19 00:00:19 2019 -0500

    G-code queue singleton, front injection (#14236)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index b21d5593fd..ef07116368 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -362,21 +362,21 @@ void disable_all_steppers() {
         #endif
 
         host_action_pause(false);
       }
       SERIAL_ECHOPGM(" " ACTION_REASON_ON_FILAMENT_RUNOUT " ");
       SERIAL_CHAR(tool);
       SERIAL_EOL();
     #endif // HOST_ACTION_COMMANDS
 
     if (run_runout_script)
-      enqueue_and_echo_commands_front_P(PSTR(FILAMENT_RUNOUT_SCRIPT));
+      queue.inject_P(PSTR(FILAMENT_RUNOUT_SCRIPT));
   }
 
 #endif // HAS_FILAMENT_SENSOR
 
 #if ENABLED(G29_RETRY_AND_RECOVER)
 
   void event_probe_failure() {
     #ifdef ACTION_ON_G29_FAILURE
       host_action(PSTR(ACTION_ON_G29_FAILURE));
     #endif
@@ -418,21 +418,21 @@ void disable_all_steppers() {
  *  - Check if an idle but hot extruder needs filament extruded (EXTRUDER_RUNOUT_PREVENT)
  *  - Pulse FET_SAFETY_PIN if it exists
  */
 
 void manage_inactivity(const bool ignore_stepper_queue/*=false*/) {
 
   #if HAS_FILAMENT_SENSOR
     runout.run();
   #endif
 
-  if (commands_in_queue < BUFSIZE) get_available_commands();
+  if (queue.length < BUFSIZE) queue.get_available_commands();
 
   const millis_t ms = millis();
 
   if (max_inactive_time && ELAPSED(ms, gcode.previous_move_ms + max_inactive_time)) {
     SERIAL_ERROR_START();
     SERIAL_ECHOLNPAIR(MSG_KILL_INACTIVE_TIME, parser.command_ptr);
     kill();
   }
 
   // Prevent steppers timing-out in the middle of M600
@@ -501,21 +501,21 @@ void manage_inactivity(const bool ignore_stepper_queue/*=false*/) {
     }
   #endif
 
   #if HAS_HOME
     // Check to see if we have to home, use poor man's debouncer
     // ---------------------------------------------------------
     static int homeDebounceCount = 0;   // poor man's debouncing count
     const int HOME_DEBOUNCE_DELAY = 2500;
     if (!IS_SD_PRINTING() && !READ(HOME_PIN)) {
       if (!homeDebounceCount) {
-        enqueue_and_echo_commands_P(PSTR("G28"));
+        queue.inject_P(PSTR("G28"));
         LCD_MESSAGEPGM(MSG_AUTO_HOME);
       }
       if (homeDebounceCount < HOME_DEBOUNCE_DELAY)
         homeDebounceCount++;
       else
         homeDebounceCount = 0;
     }
   #endif
 
   #if ENABLED(USE_CONTROLLER_FAN)
@@ -790,21 +790,21 @@ void minkill() {
  */
 void stop() {
   thermalManager.disable_all_heaters(); // 'unpause' taken care of in here
   print_job_timer.stop();
 
   #if ENABLED(PROBING_FANS_OFF)
     if (thermalManager.fans_paused) thermalManager.set_fans_paused(false); // put things back the way they were
   #endif
 
   if (IsRunning()) {
-    Stopped_gcode_LastN = gcode_LastN; // Save last g_code for restart
+    queue.stop();
     SERIAL_ERROR_MSG(MSG_ERR_STOPPED);
     LCD_MESSAGEPGM(MSG_STOPPED);
     safe_delay(350);       // allow enough time for messages to get out before stopping
     Running = false;
   }
 }
 
 /**
  * Marlin entry-point: Set up before the program loop
  *  - Set up the kill pin, filament runout, power hold
@@ -919,22 +919,20 @@ void setup() {
     SERIAL_ECHO_START();
     SERIAL_ECHOPGM(MSG_CONFIGURATION_VER);
     SERIAL_ECHOPGM(STRING_DISTRIBUTION_DATE);
     SERIAL_ECHOLNPGM(MSG_AUTHOR STRING_CONFIG_H_AUTHOR);
     SERIAL_ECHO_MSG("Compiled: " __DATE__);
   #endif
 
   SERIAL_ECHO_START();
   SERIAL_ECHOLNPAIR(MSG_FREE_MEMORY, freeMemory(), MSG_PLANNER_BUFFER_BYTES, (int)sizeof(block_t) * (BLOCK_BUFFER_SIZE));
 
-  queue_setup();
-
   // UI must be initialized before EEPROM
   // (because EEPROM code calls the UI).
   ui.init();
   ui.reset_status();
 
   #if HAS_SPI_LCD && ENABLED(SHOW_BOOTSCREEN)
     ui.show_bootscreen();
   #endif
 
   #if ENABLED(SDIO_SUPPORT) && !PIN_EXISTS(SD_DETECT)
@@ -1128,34 +1126,34 @@ void loop() {
     #if ENABLED(SDSUPPORT)
 
       card.checkautostart();
 
       if (card.flag.abort_sd_printing) {
         card.stopSDPrint(
           #if SD_RESORT
             true
           #endif
         );
-        clear_command_queue();
+        queue.clear();
         quickstop_stepper();
         print_job_timer.stop();
         #if DISABLED(SD_ABORT_NO_COOLDOWN)
           thermalManager.disable_all_heaters();
         #endif
         thermalManager.zero_fan_speeds();
         wait_for_heatup = false;
         #if ENABLED(POWER_LOSS_RECOVERY)
           card.removeJobRecoveryFile();
         #endif
         #ifdef EVENT_GCODE_SD_STOP
-          enqueue_and_echo_commands_P(PSTR(EVENT_GCODE_SD_STOP));
+          queue.inject_P(PSTR(EVENT_GCODE_SD_STOP));
         #endif
       }
 
     #endif // SDSUPPORT
 
-    if (commands_in_queue < BUFSIZE) get_available_commands();
-    advance_command_queue();
+    if (queue.length < BUFSIZE) queue.get_available_commands();
+    queue.advance();
     endstops.event_handler();
     idle();
   }
 }

commit eb1c9113c23869b839abb63b7a43f84d13ed603c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Jun 15 15:32:09 2019 -0500

    Try to init SD with no detect pin

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 52555e1e82..b21d5593fd 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -930,21 +930,21 @@ void setup() {
 
   // UI must be initialized before EEPROM
   // (because EEPROM code calls the UI).
   ui.init();
   ui.reset_status();
 
   #if HAS_SPI_LCD && ENABLED(SHOW_BOOTSCREEN)
     ui.show_bootscreen();
   #endif
 
-  #if ENABLED(SDIO_SUPPORT) && SD_DETECT_PIN == -1
+  #if ENABLED(SDIO_SUPPORT) && !PIN_EXISTS(SD_DETECT)
     // Auto-mount the SD for EEPROM.dat emulation
     if (!card.isDetected()) card.initsd();
   #endif
 
   // Load data from EEPROM if available (or use defaults)
   // This also updates variables in the planner, elsewhere
   (void)settings.load();
 
   #if HAS_M206_COMMAND
     // Initialize current position based on home_offset

commit bf8bfb5c66bd3b2f86e522c441affb832982ec39
Author: mb300sd <mb300sd@mb300sd.net>
Date:   Thu Jun 13 19:43:11 2019 -0400

    Add Coolant Control M7/M8/M9 (#10745)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 5ee886d469..52555e1e82 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -978,20 +978,27 @@ void setup() {
     OUT_WRITE(SPINDLE_LASER_ENA_PIN, !SPINDLE_LASER_ENABLE_INVERT);  // init spindle to off
     #if SPINDLE_DIR_CHANGE
       OUT_WRITE(SPINDLE_DIR_PIN, SPINDLE_INVERT_DIR ? 255 : 0);  // init rotation to clockwise (M3)
     #endif
     #if ENABLED(SPINDLE_LASER_PWM) && defined(SPINDLE_LASER_PWM_PIN) && SPINDLE_LASER_PWM_PIN >= 0
       SET_PWM(SPINDLE_LASER_PWM_PIN);
       analogWrite(SPINDLE_LASER_PWM_PIN, SPINDLE_LASER_PWM_INVERT ? 255 : 0);  // set to lowest speed
     #endif
   #endif
 
+  #if ENABLED(COOLANT_MIST)
+    OUT_WRITE(COOLANT_MIST_PIN, COOLANT_MIST_INVERT);   // Init Mist Coolant OFF
+  #endif
+  #if ENABLED(COOLANT_FLOOD)
+    OUT_WRITE(COOLANT_FLOOD_PIN, COOLANT_FLOOD_INVERT); // Init Flood Coolant OFF
+  #endif
+
   #if HAS_BED_PROBE
     endstops.enable_z_probe(false);
   #endif
 
   #if ENABLED(USE_CONTROLLER_FAN)
     SET_OUTPUT(CONTROLLER_FAN_PIN);
   #endif
 
   #if HAS_STEPPER_RESET
     enableStepperDrivers();

commit 1ef95013f037212bfa6468e96b9b8120c04f6df3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jun 11 07:27:39 2019 -0500

    Update Marlin.cpp includes, defines

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 6f0b1fc3b7..5ee886d469 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -66,58 +66,50 @@
 #endif
 
 #if ENABLED(DIGIPOT_I2C)
   #include "feature/digipot/digipot.h"
 #endif
 
 #if ENABLED(MIXING_EXTRUDER)
   #include "feature/mixing.h"
 #endif
 
-#if ENABLED(BEZIER_CURVE_SUPPORT)
-  #include "module/planner_bezier.h"
-#endif
-
 #if ENABLED(MAX7219_DEBUG)
   #include "feature/Max7219_Debug_LEDs.h"
 #endif
 
 #if HAS_COLOR_LEDS
   #include "feature/leds/leds.h"
 #endif
 
 #if ENABLED(BLTOUCH)
   #include "feature/bltouch.h"
 #endif
 
 #if HAS_SERVOS
   #include "module/servo.h"
 #endif
 
-#if HAS_DIGIPOTSS
-  #include <SPI.h>
-#endif
-
 #if ENABLED(DAC_STEPPER_CURRENT)
   #include "feature/dac/stepper_dac.h"
 #endif
 
 #if ENABLED(EXPERIMENTAL_I2CBUS)
   #include "feature/twibus.h"
   TWIBus i2c;
 #endif
 
 #if ENABLED(I2C_POSITION_ENCODERS)
   #include "feature/I2CPositionEncoder.h"
 #endif
 
-#if HAS_TRINAMIC
+#if HAS_TRINAMIC && DISABLED(PS_DEFAULT_OFF)
   #include "feature/tmc_util.h"
 #endif
 
 #if ENABLED(SDSUPPORT)
   CardReader card;
 #endif
 
 #if ENABLED(G38_PROBE_TARGET)
   uint8_t G38_move; // = 0
   bool G38_did_trigger; // = false
@@ -172,24 +164,20 @@
 #if ENABLED(EXTENSIBLE_UI)
   #include "lcd/extensible_ui/ui_api.h"
 #endif
 
 #if HAS_DRIVER(L6470)
   #include "libs/L6470/L6470_Marlin.h"
 #endif
 
 bool Running = true;
 
-#if ENABLED(TEMPERATURE_UNITS_SUPPORT)
-  TempUnit input_temp_units = TEMPUNIT_C;
-#endif
-
 // For M109 and M190, this flag may be cleared (by M108) to exit the wait loop
 bool wait_for_heatup = true;
 
 // For M0/M1, this flag may be cleared (by M108) to exit the wait-for-user loop
 #if HAS_RESUME_CONTINUE
   bool wait_for_user; // = false;
 #endif
 
 #if HAS_AUTO_REPORTING || ENABLED(HOST_KEEPALIVE_FEATURE)
   bool suspend_auto_report; // = false

commit c88d9ae28212d641e55f0d7413f910a0851fd01e
Author: Kaushik Vemparala <kaushikny13@gmail.com>
Date:   Tue Jun 11 00:57:55 2019 -0400

    Option to leave heaters set on SD abort (#14251)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 4b76253718..6f0b1fc3b7 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -1124,39 +1124,43 @@ void setup() {
  *  - Save or log commands to SD
  *  - Process available commands (if not saving)
  *  - Call endstop manager
  *  - Call inactivity manager
  */
 void loop() {
 
   for (;;) {
 
     #if ENABLED(SDSUPPORT)
+
       card.checkautostart();
 
       if (card.flag.abort_sd_printing) {
         card.stopSDPrint(
           #if SD_RESORT
             true
           #endif
         );
         clear_command_queue();
         quickstop_stepper();
         print_job_timer.stop();
-        thermalManager.disable_all_heaters();
+        #if DISABLED(SD_ABORT_NO_COOLDOWN)
+          thermalManager.disable_all_heaters();
+        #endif
         thermalManager.zero_fan_speeds();
         wait_for_heatup = false;
         #if ENABLED(POWER_LOSS_RECOVERY)
           card.removeJobRecoveryFile();
         #endif
         #ifdef EVENT_GCODE_SD_STOP
           enqueue_and_echo_commands_P(PSTR(EVENT_GCODE_SD_STOP));
         #endif
       }
+
     #endif // SDSUPPORT
 
     if (commands_in_queue < BUFSIZE) get_available_commands();
     advance_command_queue();
     endstops.event_handler();
     idle();
   }
 }

commit 80ce0d2bdb5e21a1eefdcb19747dc8474cfc54e0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jun 4 23:18:51 2019 -0500

    Whitespace cleanup

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index fdc6649799..4b76253718 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -865,25 +865,25 @@ void setup() {
     #else
       #error "DISABLE_JTAG is not supported for the selected MCU/Board"
     #endif
   #endif
 
   #if HAS_FILAMENT_SENSOR
     runout.setup();
   #endif
 
   setup_killpin();
-  
+
   #if HAS_DRIVER(TMC2208)
     tmc2208_serial_begin();
   #endif
-  
+
   setup_powerhold();
 
   #if HAS_STEPPER_RESET
     disableStepperDrivers();
   #endif
 
   #if NUM_SERIAL > 0
     MYSERIAL0.begin(BAUDRATE);
     #if NUM_SERIAL > 1
       MYSERIAL1.begin(BAUDRATE);

commit 5ca8d51e123463004626e853a930e2f88febd66d
Author: Robby Candra <robbycandra.mail@gmail.com>
Date:   Sat Jun 8 17:23:53 2019 +0700

    Ability to insert G-code in front of queue (#14229)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 4d1c66d6f7..fdc6649799 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -374,21 +374,21 @@ void disable_all_steppers() {
         #endif
 
         host_action_pause(false);
       }
       SERIAL_ECHOPGM(" " ACTION_REASON_ON_FILAMENT_RUNOUT " ");
       SERIAL_CHAR(tool);
       SERIAL_EOL();
     #endif // HOST_ACTION_COMMANDS
 
     if (run_runout_script)
-      enqueue_and_echo_commands_P(PSTR(FILAMENT_RUNOUT_SCRIPT));
+      enqueue_and_echo_commands_front_P(PSTR(FILAMENT_RUNOUT_SCRIPT));
   }
 
 #endif // HAS_FILAMENT_SENSOR
 
 #if ENABLED(G29_RETRY_AND_RECOVER)
 
   void event_probe_failure() {
     #ifdef ACTION_ON_G29_FAILURE
       host_action(PSTR(ACTION_ON_G29_FAILURE));
     #endif

commit 36a0376c368222f646d4c60ca153087d378af6a5
Author: Chris <chrish.rn12@gmail.com>
Date:   Sun May 26 13:07:12 2019 +0200

    fix TMC2208 boot loop with SW UART
    
    Need stepper .begin() before calling susbequent .push()

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index c1f87f55dc..4d1c66d6f7 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -865,21 +865,25 @@ void setup() {
     #else
       #error "DISABLE_JTAG is not supported for the selected MCU/Board"
     #endif
   #endif
 
   #if HAS_FILAMENT_SENSOR
     runout.setup();
   #endif
 
   setup_killpin();
-
+  
+  #if HAS_DRIVER(TMC2208)
+    tmc2208_serial_begin();
+  #endif
+  
   setup_powerhold();
 
   #if HAS_STEPPER_RESET
     disableStepperDrivers();
   #endif
 
   #if NUM_SERIAL > 0
     MYSERIAL0.begin(BAUDRATE);
     #if NUM_SERIAL > 1
       MYSERIAL1.begin(BAUDRATE);
@@ -897,23 +901,20 @@ void setup() {
 
   SERIAL_ECHOLNPGM("start");
   SERIAL_ECHO_START();
 
   #if TMC_HAS_SPI
     #if DISABLED(TMC_USE_SW_SPI)
       SPI.begin();
     #endif
     tmc_init_cs_pins();
   #endif
-  #if HAS_DRIVER(TMC2208)
-    tmc2208_serial_begin();
-  #endif
 
   #ifdef BOARD_INIT
     BOARD_INIT();
   #endif
 
   // Check startup - does nothing if bootloader sets MCUSR to 0
   byte mcu = HAL_get_reset_source();
   if (mcu &  1) SERIAL_ECHOLNPGM(MSG_POWERUP);
   if (mcu &  2) SERIAL_ECHOLNPGM(MSG_EXTERNAL_RESET);
   if (mcu &  4) SERIAL_ECHOLNPGM(MSG_BROWNOUT_RESET);

commit 49e83dd7c81cffef7462a0a53a70a125562de83a
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sat May 25 22:56:47 2019 -0400

    BLTouch V3.1 changes (#14104)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 6f9e527832..c1f87f55dc 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -1051,21 +1051,21 @@ void setup() {
 
   #if HAS_FANMUX
     fanmux_init();
   #endif
 
   #if ENABLED(MIXING_EXTRUDER)
     mixer.init();
   #endif
 
   #if ENABLED(BLTOUCH)
-    bltouch.init();
+    bltouch.init(/*set_voltage=*/true);
   #endif
 
   #if ENABLED(I2C_POSITION_ENCODERS)
     I2CPEM.init();
   #endif
 
   #if ENABLED(EXPERIMENTAL_I2CBUS) && I2C_SLAVE_ADDRESS > 0
     i2c.onReceive(i2c_on_receive);
     i2c.onRequest(i2c_on_request);
   #endif

commit 1c86fbc60bad74957c872cbd6bc87900a3f127d8
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Sun May 26 02:22:12 2019 +0300

    TMC updates, capture LCD changes (#14074)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 18cbbaa237..6f9e527832 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -1046,24 +1046,20 @@ void setup() {
   #if ENABLED(MK2_MULTIPLEXER)
     SET_OUTPUT(E_MUX0_PIN);
     SET_OUTPUT(E_MUX1_PIN);
     SET_OUTPUT(E_MUX2_PIN);
   #endif
 
   #if HAS_FANMUX
     fanmux_init();
   #endif
 
-  #if HAS_TRINAMIC && HAS_LCD_MENU
-    init_tmc_section();
-  #endif
-
   #if ENABLED(MIXING_EXTRUDER)
     mixer.init();
   #endif
 
   #if ENABLED(BLTOUCH)
     bltouch.init();
   #endif
 
   #if ENABLED(I2C_POSITION_ENCODERS)
     I2CPEM.init();

commit 7ccbcf2eaad878daf139a5e52715c423229618d9
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Thu May 16 19:38:03 2019 -0600

    Fix TMC EEPROM regression (#14008)
    
    Partially undo 15357af to ensure TMC code is initialized in the proper order.

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 6f9e527832..18cbbaa237 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -1046,20 +1046,24 @@ void setup() {
   #if ENABLED(MK2_MULTIPLEXER)
     SET_OUTPUT(E_MUX0_PIN);
     SET_OUTPUT(E_MUX1_PIN);
     SET_OUTPUT(E_MUX2_PIN);
   #endif
 
   #if HAS_FANMUX
     fanmux_init();
   #endif
 
+  #if HAS_TRINAMIC && HAS_LCD_MENU
+    init_tmc_section();
+  #endif
+
   #if ENABLED(MIXING_EXTRUDER)
     mixer.init();
   #endif
 
   #if ENABLED(BLTOUCH)
     bltouch.init();
   #endif
 
   #if ENABLED(I2C_POSITION_ENCODERS)
     I2CPEM.init();

commit 5108e4b6aaeb0b5143b7b6bf09103e6cdd3be491
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sat May 11 17:54:03 2019 -0400

    Cleaner EEPROM auto init (#13975)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index e82911da47..6f9e527832 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -948,29 +948,21 @@ void setup() {
     ui.show_bootscreen();
   #endif
 
   #if ENABLED(SDIO_SUPPORT) && SD_DETECT_PIN == -1
     // Auto-mount the SD for EEPROM.dat emulation
     if (!card.isDetected()) card.initsd();
   #endif
 
   // Load data from EEPROM if available (or use defaults)
   // This also updates variables in the planner, elsewhere
-  #if ENABLED(EEPROM_AUTO_INIT)
-    if (!settings.load()) {
-      (void)settings.reset();
-      (void)settings.save();
-      SERIAL_ECHO_MSG("EEPROM Initialized");
-    }
-  #else
-    (void)settings.load();
-  #endif
+  (void)settings.load();
 
   #if HAS_M206_COMMAND
     // Initialize current position based on home_offset
     LOOP_XYZ(a) current_position[a] += home_offset[a];
   #endif
 
   // Vital to init stepper/planner equivalent for current_position
   sync_plan_position();
 
   thermalManager.init();    // Initialize temperature loop

commit ad4ffa1d2fbd17ac09c816ba2052cdf714261042
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 9 11:45:55 2019 -0500

    Use C++ language supported 'nullptr' (#13944)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index bb1f68d12b..e82911da47 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -721,21 +721,21 @@ void idle(
 
   #if ENABLED(PRUSA_MMU2)
     mmu2.mmu_loop();
   #endif
 }
 
 /**
  * Kill all activity and lock the machine.
  * After this the machine will need to be reset.
  */
-void kill(PGM_P const lcd_msg/*=NULL*/) {
+void kill(PGM_P const lcd_msg/*=nullptr*/) {
   thermalManager.disable_all_heaters();
 
   SERIAL_ERROR_MSG(MSG_ERR_KILLED);
 
   #if HAS_DISPLAY
     ui.kill_screen(lcd_msg ? lcd_msg : PSTR(MSG_KILLED));
   #else
     UNUSED(lcd_msg);
   #endif
 

commit 23ec6504103a99a0d769346e2a503a1d1764cf7b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 7 20:32:50 2019 -0500

    Consolidate Malyan LCD and ExtUI

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index f9edc472c7..bb1f68d12b 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -726,21 +726,21 @@ void idle(
 
 /**
  * Kill all activity and lock the machine.
  * After this the machine will need to be reset.
  */
 void kill(PGM_P const lcd_msg/*=NULL*/) {
   thermalManager.disable_all_heaters();
 
   SERIAL_ERROR_MSG(MSG_ERR_KILLED);
 
-  #if HAS_SPI_LCD || ENABLED(EXTENSIBLE_UI)
+  #if HAS_DISPLAY
     ui.kill_screen(lcd_msg ? lcd_msg : PSTR(MSG_KILLED));
   #else
     UNUSED(lcd_msg);
   #endif
 
   #ifdef ACTION_ON_KILL
     host_action_kill();
   #endif
 
   minkill();

commit 5dcb25664f829be801e20ab6032e782c1c65b4ba
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue May 7 17:30:31 2019 -0400

    Option to Auto-Initialize EEPROM (#13935)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 5cf65cd305..f9edc472c7 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -948,21 +948,29 @@ void setup() {
     ui.show_bootscreen();
   #endif
 
   #if ENABLED(SDIO_SUPPORT) && SD_DETECT_PIN == -1
     // Auto-mount the SD for EEPROM.dat emulation
     if (!card.isDetected()) card.initsd();
   #endif
 
   // Load data from EEPROM if available (or use defaults)
   // This also updates variables in the planner, elsewhere
-  (void)settings.load();
+  #if ENABLED(EEPROM_AUTO_INIT)
+    if (!settings.load()) {
+      (void)settings.reset();
+      (void)settings.save();
+      SERIAL_ECHO_MSG("EEPROM Initialized");
+    }
+  #else
+    (void)settings.load();
+  #endif
 
   #if HAS_M206_COMMAND
     // Initialize current position based on home_offset
     LOOP_XYZ(a) current_position[a] += home_offset[a];
   #endif
 
   // Vital to init stepper/planner equivalent for current_position
   sync_plan_position();
 
   thermalManager.init();    // Initialize temperature loop

commit 15357af67ceb74b14606eba9fbb75d20914f8909
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Fri May 3 22:53:15 2019 -0600

    Backlash cleanup (#13659)
    
    …And save backlash, fil. sensor, ExtUI userdata to EEPROM.

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index e612b0de93..5cf65cd305 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -932,20 +932,29 @@ void setup() {
     SERIAL_ECHOPGM(STRING_DISTRIBUTION_DATE);
     SERIAL_ECHOLNPGM(MSG_AUTHOR STRING_CONFIG_H_AUTHOR);
     SERIAL_ECHO_MSG("Compiled: " __DATE__);
   #endif
 
   SERIAL_ECHO_START();
   SERIAL_ECHOLNPAIR(MSG_FREE_MEMORY, freeMemory(), MSG_PLANNER_BUFFER_BYTES, (int)sizeof(block_t) * (BLOCK_BUFFER_SIZE));
 
   queue_setup();
 
+  // UI must be initialized before EEPROM
+  // (because EEPROM code calls the UI).
+  ui.init();
+  ui.reset_status();
+
+  #if HAS_SPI_LCD && ENABLED(SHOW_BOOTSCREEN)
+    ui.show_bootscreen();
+  #endif
+
   #if ENABLED(SDIO_SUPPORT) && SD_DETECT_PIN == -1
     // Auto-mount the SD for EEPROM.dat emulation
     if (!card.isDetected()) card.initsd();
   #endif
 
   // Load data from EEPROM if available (or use defaults)
   // This also updates variables in the planner, elsewhere
   (void)settings.load();
 
   #if HAS_M206_COMMAND
@@ -1037,27 +1046,20 @@ void setup() {
   #if ENABLED(MK2_MULTIPLEXER)
     SET_OUTPUT(E_MUX0_PIN);
     SET_OUTPUT(E_MUX1_PIN);
     SET_OUTPUT(E_MUX2_PIN);
   #endif
 
   #if HAS_FANMUX
     fanmux_init();
   #endif
 
-  ui.init();
-  ui.reset_status();
-
-  #if HAS_SPI_LCD && ENABLED(SHOW_BOOTSCREEN)
-    ui.show_bootscreen();
-  #endif
-
   #if ENABLED(MIXING_EXTRUDER)
     mixer.init();
   #endif
 
   #if ENABLED(BLTOUCH)
     bltouch.init();
   #endif
 
   #if ENABLED(I2C_POSITION_ENCODERS)
     I2CPEM.init();

commit 51d1e0f1dd256bc30ea5b301056a247821454258
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Thu May 2 07:45:21 2019 +0200

    Auto-mount the SDIO SD card (#13879)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index c6e25b5a5a..e612b0de93 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -932,20 +932,25 @@ void setup() {
     SERIAL_ECHOPGM(STRING_DISTRIBUTION_DATE);
     SERIAL_ECHOLNPGM(MSG_AUTHOR STRING_CONFIG_H_AUTHOR);
     SERIAL_ECHO_MSG("Compiled: " __DATE__);
   #endif
 
   SERIAL_ECHO_START();
   SERIAL_ECHOLNPAIR(MSG_FREE_MEMORY, freeMemory(), MSG_PLANNER_BUFFER_BYTES, (int)sizeof(block_t) * (BLOCK_BUFFER_SIZE));
 
   queue_setup();
 
+  #if ENABLED(SDIO_SUPPORT) && SD_DETECT_PIN == -1
+    // Auto-mount the SD for EEPROM.dat emulation
+    if (!card.isDetected()) card.initsd();
+  #endif
+
   // Load data from EEPROM if available (or use defaults)
   // This also updates variables in the planner, elsewhere
   (void)settings.load();
 
   #if HAS_M206_COMMAND
     // Initialize current position based on home_offset
     LOOP_XYZ(a) current_position[a] += home_offset[a];
   #endif
 
   // Vital to init stepper/planner equivalent for current_position

commit e6ebd30f60d96de4cf3a8b18cef0a4004f936186
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Wed Apr 10 14:51:48 2019 -0600

    Fix LCD issue on stepper timeout (#13630)
    
    - Remove a re-paint of the status screen on stepper timeout, which would cause a garbled LCD with `LIGHTWEIGHT_UI` and could interrupt whatever else the user might be doing in a submenu (such as playing games!)
    - Use the helper function to reset stepper timeout.

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index e04db30eff..c6e25b5a5a 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -450,44 +450,41 @@ void manage_inactivity(const bool ignore_stepper_queue/*=false*/) {
   // Prevent steppers timing-out in the middle of M600
   #if BOTH(ADVANCED_PAUSE_FEATURE, PAUSE_PARK_NO_STEPPER_TIMEOUT)
     #define MOVE_AWAY_TEST !did_pause_print
   #else
     #define MOVE_AWAY_TEST true
   #endif
 
   if (stepper_inactive_time) {
     static bool already_shutdown_steppers; // = false
     if (planner.has_blocks_queued())
-      gcode.previous_move_ms = ms; // reset_stepper_timeout to keep steppers powered
+      gcode.reset_stepper_timeout();
     else if (MOVE_AWAY_TEST && !ignore_stepper_queue && ELAPSED(ms, gcode.previous_move_ms + stepper_inactive_time)) {
       if (!already_shutdown_steppers) {
         already_shutdown_steppers = true;  // L6470 SPI will consume 99% of free time without this
         #if ENABLED(DISABLE_INACTIVE_X)
           disable_X();
         #endif
         #if ENABLED(DISABLE_INACTIVE_Y)
           disable_Y();
         #endif
         #if ENABLED(DISABLE_INACTIVE_Z)
           disable_Z();
         #endif
         #if ENABLED(DISABLE_INACTIVE_E)
           disable_e_steppers();
         #endif
-        #if HAS_LCD_MENU
-          ui.status_screen();
-          #if ENABLED(AUTO_BED_LEVELING_UBL)
-            if (ubl.lcd_map_control) {
-              ubl.lcd_map_control = false;
-              ui.defer_status_screen(false);
-            }
-          #endif
+        #if HAS_LCD_MENU && ENABLED(AUTO_BED_LEVELING_UBL)
+          if (ubl.lcd_map_control) {
+            ubl.lcd_map_control = false;
+            ui.defer_status_screen(false);
+          }
         #endif
       }
     }
     else
       already_shutdown_steppers = false;
   }
 
   #if PIN_EXISTS(CHDK) // Check if pin should be set to LOW (after M240 set it HIGH)
     if (chdk_timeout && ELAPSED(ms, chdk_timeout)) {
       chdk_timeout = 0;
@@ -610,21 +607,21 @@ void manage_inactivity(const bool ignore_stepper_queue/*=false*/) {
                   #if E_STEPPERS > 5
                     case 5: E5_ENABLE_WRITE(oldstatus); break;
                   #endif // E_STEPPERS > 5
                 #endif // E_STEPPERS > 4
               #endif // E_STEPPERS > 3
             #endif // E_STEPPERS > 2
           #endif // E_STEPPERS > 1
         }
       #endif // !SWITCHING_EXTRUDER
 
-      gcode.previous_move_ms = ms; // reset_stepper_timeout to keep steppers powered
+      gcode.reset_stepper_timeout();
     }
   #endif // EXTRUDER_RUNOUT_PREVENT
 
   #if ENABLED(DUAL_X_CARRIAGE)
     // handle delayed move timeout
     if (delayed_move_time && ELAPSED(ms, delayed_move_time + 1000UL) && IsRunning()) {
       // travel moves have been received so enact them
       delayed_move_time = 0xFFFFFFFFUL; // force moves to be done
       set_destination_from_current();
       prepare_move_to_destination();

commit fae2b7edc38322e69af954f769fa7953d35f5bba
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 8 17:56:40 2019 -0500

    Update MMU2 code style

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 01a686a9e7..e04db30eff 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -716,21 +716,21 @@ void idle(
         card.auto_report_sd_status();
       #endif
     }
   #endif
 
   #if ENABLED(USB_FLASH_DRIVE_SUPPORT)
     Sd2Card::idle();
   #endif
 
   #if ENABLED(PRUSA_MMU2)
-    mmu2.mmuLoop();
+    mmu2.mmu_loop();
   #endif
 }
 
 /**
  * Kill all activity and lock the machine.
  * After this the machine will need to be reset.
  */
 void kill(PGM_P const lcd_msg/*=NULL*/) {
   thermalManager.disable_all_heaters();
 

commit c8a83fb1228d0c263b195b7f3f358345d4893a39
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 8 17:52:33 2019 -0500

    SPINDLE_LASER_ENABLE => SPINDLE_LASER_ENA

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index e11db20bc5..01a686a9e7 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -968,21 +968,21 @@ void setup() {
 
   #if HAS_Z_SERVO_PROBE
     servo_probe_init();
   #endif
 
   #if HAS_PHOTOGRAPH
     OUT_WRITE(PHOTOGRAPH_PIN, LOW);
   #endif
 
   #if ENABLED(SPINDLE_LASER_ENABLE)
-    OUT_WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);  // init spindle to off
+    OUT_WRITE(SPINDLE_LASER_ENA_PIN, !SPINDLE_LASER_ENABLE_INVERT);  // init spindle to off
     #if SPINDLE_DIR_CHANGE
       OUT_WRITE(SPINDLE_DIR_PIN, SPINDLE_INVERT_DIR ? 255 : 0);  // init rotation to clockwise (M3)
     #endif
     #if ENABLED(SPINDLE_LASER_PWM) && defined(SPINDLE_LASER_PWM_PIN) && SPINDLE_LASER_PWM_PIN >= 0
       SET_PWM(SPINDLE_LASER_PWM_PIN);
       analogWrite(SPINDLE_LASER_PWM_PIN, SPINDLE_LASER_PWM_INVERT ? 255 : 0);  // set to lowest speed
     #endif
   #endif
 
   #if HAS_BED_PROBE

commit cacec5764aee0d1fb5b439d550287970e19f1686
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Apr 3 20:21:06 2019 -0500

    Clean up whitespace

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 4bdbe74b57..e11db20bc5 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -1138,20 +1138,20 @@ void loop() {
         quickstop_stepper();
         print_job_timer.stop();
         thermalManager.disable_all_heaters();
         thermalManager.zero_fan_speeds();
         wait_for_heatup = false;
         #if ENABLED(POWER_LOSS_RECOVERY)
           card.removeJobRecoveryFile();
         #endif
         #ifdef EVENT_GCODE_SD_STOP
           enqueue_and_echo_commands_P(PSTR(EVENT_GCODE_SD_STOP));
-        #endif  
+        #endif
       }
     #endif // SDSUPPORT
 
     if (commands_in_queue < BUFSIZE) get_available_commands();
     advance_command_queue();
     endstops.event_handler();
     idle();
   }
 }

commit f1810689ff647edb66cea85a188a4b690defb0ae
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Apr 4 00:19:02 2019 -0500

    Fix bootscreen condition

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 47dc4d1bfa..4bdbe74b57 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -1038,21 +1038,21 @@ void setup() {
     SET_OUTPUT(E_MUX2_PIN);
   #endif
 
   #if HAS_FANMUX
     fanmux_init();
   #endif
 
   ui.init();
   ui.reset_status();
 
-  #if ENABLED(SHOW_BOOTSCREEN)
+  #if HAS_SPI_LCD && ENABLED(SHOW_BOOTSCREEN)
     ui.show_bootscreen();
   #endif
 
   #if ENABLED(MIXING_EXTRUDER)
     mixer.init();
   #endif
 
   #if ENABLED(BLTOUCH)
     bltouch.init();
   #endif

commit 46445a5a168bcfee58bbf0a1f9f56581ad0b6de3
Author: Robby Candra <bytegator@gmail.com>
Date:   Wed Apr 3 10:09:30 2019 +0700

    Event G-code for Stop SD Print (#13547)
    
    Co-Authored-By: 7eggert <7eggert@gmx.de>
    Co-Authored-By: robbycandra <robbycandra.mail@gmail.com>

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 14e61d8460..47dc4d1bfa 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -1136,19 +1136,22 @@ void loop() {
         );
         clear_command_queue();
         quickstop_stepper();
         print_job_timer.stop();
         thermalManager.disable_all_heaters();
         thermalManager.zero_fan_speeds();
         wait_for_heatup = false;
         #if ENABLED(POWER_LOSS_RECOVERY)
           card.removeJobRecoveryFile();
         #endif
+        #ifdef EVENT_GCODE_SD_STOP
+          enqueue_and_echo_commands_P(PSTR(EVENT_GCODE_SD_STOP));
+        #endif  
       }
     #endif // SDSUPPORT
 
     if (commands_in_queue < BUFSIZE) get_available_commands();
     advance_command_queue();
     endstops.event_handler();
     idle();
   }
 }

commit 5679fae11efbc7e8b9de2f0e68dc9a879757ff88
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Fri Mar 29 13:07:43 2019 -0600

    UltraLCD enhancements (lower fan resolution, backlash menu) (#13519)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 6a55b399c1..14e61d8460 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -23,20 +23,21 @@
 /**
  * About Marlin
  *
  * This firmware is a mashup between Sprinter and grbl.
  *  - https://github.com/kliment/Sprinter
  *  - https://github.com/grbl/grbl
  */
 
 #include "Marlin.h"
 
+#include "core/utility.h"
 #include "lcd/ultralcd.h"
 #include "module/motion.h"
 #include "module/planner.h"
 #include "module/stepper.h"
 #include "module/endstops.h"
 #include "module/probe.h"
 #include "module/temperature.h"
 #include "sd/cardreader.h"
 #include "module/configuration_store.h"
 #include "module/printcounter.h" // PrintCounter or Stopwatch

commit 691e5c3bb8d04b0b6690424034d73ade19e91586
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Mar 17 06:57:25 2019 -0400

    BLTouch V3.0 support (#13406)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 5166df1f57..6a55b399c1 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -77,20 +77,24 @@
 #endif
 
 #if ENABLED(MAX7219_DEBUG)
   #include "feature/Max7219_Debug_LEDs.h"
 #endif
 
 #if HAS_COLOR_LEDS
   #include "feature/leds/leds.h"
 #endif
 
+#if ENABLED(BLTOUCH)
+  #include "feature/bltouch.h"
+#endif
+
 #if HAS_SERVOS
   #include "module/servo.h"
 #endif
 
 #if HAS_DIGIPOTSS
   #include <SPI.h>
 #endif
 
 #if ENABLED(DAC_STEPPER_CURRENT)
   #include "feature/dac/stepper_dac.h"
@@ -1042,21 +1046,21 @@ void setup() {
 
   #if ENABLED(SHOW_BOOTSCREEN)
     ui.show_bootscreen();
   #endif
 
   #if ENABLED(MIXING_EXTRUDER)
     mixer.init();
   #endif
 
   #if ENABLED(BLTOUCH)
-    bltouch_init();
+    bltouch.init();
   #endif
 
   #if ENABLED(I2C_POSITION_ENCODERS)
     I2CPEM.init();
   #endif
 
   #if ENABLED(EXPERIMENTAL_I2CBUS) && I2C_SLAVE_ADDRESS > 0
     i2c.onReceive(i2c_on_receive);
     i2c.onRequest(i2c_on_request);
   #endif

commit 49cf92dc36424cf828436f32e72263eca39a1cc3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 16 23:43:06 2019 -0500

    Extended condition macros (#13419)
    
    Allow `ENABLED`, `DISABLED`, `PIN_EXISTS`, and `BUTTON_EXISTS` to take multiple arguments. Also add:
    - Alias `ANY(...)` for `!DISABLED(...)`
    - Alias `ANY_PIN(...)` for `PIN_EXISTS(a) || PIN_EXISTS(b) ...`
    - Alias `EITHER(A,B)` for `ANY(...)`
    - Alias `ALL(...)` and `BOTH(A,B)` for `ENABLED(...)`
    - `NONE(...)` for `DISABLED(...)`

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 5e02abb9e8..5166df1f57 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -121,21 +121,21 @@
 #if ENABLED(DELTA)
   #include "module/delta.h"
 #elif IS_SCARA
   #include "module/scara.h"
 #endif
 
 #if HAS_LEVELING
   #include "feature/bedlevel/bedlevel.h"
 #endif
 
-#if ENABLED(ADVANCED_PAUSE_FEATURE) && ENABLED(PAUSE_PARK_NO_STEPPER_TIMEOUT)
+#if BOTH(ADVANCED_PAUSE_FEATURE, PAUSE_PARK_NO_STEPPER_TIMEOUT)
   #include "feature/pause.h"
 #endif
 
 #if ENABLED(POWER_LOSS_RECOVERY)
   #include "feature/power_loss_recovery.h"
 #endif
 
 #if HAS_FILAMENT_SENSOR
   #include "feature/runout.h"
 #endif
@@ -145,21 +145,21 @@
 #endif
 
 #if HAS_CASE_LIGHT
   #include "feature/caselight.h"
 #endif
 
 #if HAS_FANMUX
   #include "feature/fanmux.h"
 #endif
 
-#if DO_SWITCH_EXTRUDER || ENABLED(SWITCHING_NOZZLE) || ENABLED(PARKING_EXTRUDER) || ENABLED(MAGNETIC_PARKING_EXTRUDER)
+#if DO_SWITCH_EXTRUDER || ANY(SWITCHING_NOZZLE, PARKING_EXTRUDER, MAGNETIC_PARKING_EXTRUDER)
   #include "module/tool_change.h"
 #endif
 
 #if ENABLED(USE_CONTROLLER_FAN)
   #include "feature/controllerfan.h"
 #endif
 
 #if ENABLED(PRUSA_MMU2)
   #include "feature/prusa_MMU2/mmu2.h"
 #endif
@@ -321,21 +321,21 @@ void disable_all_steppers() {
   void event_filament_runout() {
 
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
       if (did_pause_print) return;  // Action already in progress. Purge triggered repeated runout.
     #endif
 
     #if ENABLED(EXTENSIBLE_UI)
       ExtUI::onFilamentRunout(ExtUI::getActiveTool());
     #endif
 
-    #if ENABLED(HOST_PROMPT_SUPPORT) || ENABLED(HOST_ACTION_COMMANDS)
+    #if EITHER(HOST_PROMPT_SUPPORT, HOST_ACTION_COMMANDS)
       const char tool = '0'
         #if NUM_RUNOUT_SENSORS > 1
           + active_extruder
         #endif
       ;
     #endif
 
     //action:out_of_filament
     #if ENABLED(HOST_PROMPT_SUPPORT)
       host_prompt_reason = PROMPT_FILAMENT_RUNOUT;
@@ -436,21 +436,21 @@ void manage_inactivity(const bool ignore_stepper_queue/*=false*/) {
 
   const millis_t ms = millis();
 
   if (max_inactive_time && ELAPSED(ms, gcode.previous_move_ms + max_inactive_time)) {
     SERIAL_ERROR_START();
     SERIAL_ECHOLNPAIR(MSG_KILL_INACTIVE_TIME, parser.command_ptr);
     kill();
   }
 
   // Prevent steppers timing-out in the middle of M600
-  #if ENABLED(ADVANCED_PAUSE_FEATURE) && ENABLED(PAUSE_PARK_NO_STEPPER_TIMEOUT)
+  #if BOTH(ADVANCED_PAUSE_FEATURE, PAUSE_PARK_NO_STEPPER_TIMEOUT)
     #define MOVE_AWAY_TEST !did_pause_print
   #else
     #define MOVE_AWAY_TEST true
   #endif
 
   if (stepper_inactive_time) {
     static bool already_shutdown_steppers; // = false
     if (planner.has_blocks_queued())
       gcode.previous_move_ms = ms; // reset_stepper_timeout to keep steppers powered
     else if (MOVE_AWAY_TEST && !ignore_stepper_queue && ELAPSED(ms, gcode.previous_move_ms + stepper_inactive_time)) {
@@ -993,21 +993,21 @@ void setup() {
   #endif
 
   #if ENABLED(DIGIPOT_I2C)
     digipot_i2c_init();
   #endif
 
   #if ENABLED(DAC_STEPPER_CURRENT)
     dac_init();
   #endif
 
-  #if (ENABLED(Z_PROBE_SLED) || ENABLED(SOLENOID_PROBE)) && HAS_SOLENOID_1
+  #if EITHER(Z_PROBE_SLED, SOLENOID_PROBE) && HAS_SOLENOID_1
     OUT_WRITE(SOL1_PIN, LOW); // OFF
   #endif
 
   #if HAS_HOME
     SET_INPUT_PULLUP(HOME_PIN);
   #endif
 
   #if PIN_EXISTS(STAT_LED_RED)
     OUT_WRITE(STAT_LED_RED_PIN, LOW); // OFF
   #endif

commit 67bee06e4371fca6511aae99125337b6e63560d8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 13 07:21:10 2019 -0500

    No patch needed for non-libmaple analogWrite
    
    See https://github.com/pinchies/Marlin/pull/1#issuecomment-471388743

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 174210687f..5e02abb9e8 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -969,21 +969,21 @@ void setup() {
     OUT_WRITE(PHOTOGRAPH_PIN, LOW);
   #endif
 
   #if ENABLED(SPINDLE_LASER_ENABLE)
     OUT_WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);  // init spindle to off
     #if SPINDLE_DIR_CHANGE
       OUT_WRITE(SPINDLE_DIR_PIN, SPINDLE_INVERT_DIR ? 255 : 0);  // init rotation to clockwise (M3)
     #endif
     #if ENABLED(SPINDLE_LASER_PWM) && defined(SPINDLE_LASER_PWM_PIN) && SPINDLE_LASER_PWM_PIN >= 0
       SET_PWM(SPINDLE_LASER_PWM_PIN);
-      ANALOG_WRITE(SPINDLE_LASER_PWM_PIN, SPINDLE_LASER_PWM_INVERT ? 255 : 0);  // set to lowest speed
+      analogWrite(SPINDLE_LASER_PWM_PIN, SPINDLE_LASER_PWM_INVERT ? 255 : 0);  // set to lowest speed
     #endif
   #endif
 
   #if HAS_BED_PROBE
     endstops.enable_z_probe(false);
   #endif
 
   #if ENABLED(USE_CONTROLLER_FAN)
     SET_OUTPUT(CONTROLLER_FAN_PIN);
   #endif

commit f89b375fb9ca9730a4165ac3bf9f0f9dc100a338
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 13 06:51:15 2019 -0500

    Fixes and improvements for PWM pins (#13383)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index badda0fd23..174210687f 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -968,22 +968,22 @@ void setup() {
   #if HAS_PHOTOGRAPH
     OUT_WRITE(PHOTOGRAPH_PIN, LOW);
   #endif
 
   #if ENABLED(SPINDLE_LASER_ENABLE)
     OUT_WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);  // init spindle to off
     #if SPINDLE_DIR_CHANGE
       OUT_WRITE(SPINDLE_DIR_PIN, SPINDLE_INVERT_DIR ? 255 : 0);  // init rotation to clockwise (M3)
     #endif
     #if ENABLED(SPINDLE_LASER_PWM) && defined(SPINDLE_LASER_PWM_PIN) && SPINDLE_LASER_PWM_PIN >= 0
-      SET_OUTPUT(SPINDLE_LASER_PWM_PIN);
-      analogWrite(SPINDLE_LASER_PWM_PIN, SPINDLE_LASER_PWM_INVERT ? 255 : 0);  // set to lowest speed
+      SET_PWM(SPINDLE_LASER_PWM_PIN);
+      ANALOG_WRITE(SPINDLE_LASER_PWM_PIN, SPINDLE_LASER_PWM_INVERT ? 255 : 0);  // set to lowest speed
     #endif
   #endif
 
   #if HAS_BED_PROBE
     endstops.enable_z_probe(false);
   #endif
 
   #if ENABLED(USE_CONTROLLER_FAN)
     SET_OUTPUT(CONTROLLER_FAN_PIN);
   #endif
@@ -1015,21 +1015,21 @@ void setup() {
   #if PIN_EXISTS(STAT_LED_BLUE)
     OUT_WRITE(STAT_LED_BLUE_PIN, LOW); // OFF
   #endif
 
   #if HAS_COLOR_LEDS
     leds.setup();
   #endif
 
   #if HAS_CASE_LIGHT
     #if DISABLED(CASE_LIGHT_USE_NEOPIXEL)
-      SET_OUTPUT(CASE_LIGHT_PIN);
+      if (PWM_PIN(CASE_LIGHT_PIN)) SET_PWM(CASE_LIGHT_PIN); else SET_OUTPUT(CASE_LIGHT_PIN);
     #endif
     update_case_light();
   #endif
 
   #if ENABLED(MK2_MULTIPLEXER)
     SET_OUTPUT(E_MUX0_PIN);
     SET_OUTPUT(E_MUX1_PIN);
     SET_OUTPUT(E_MUX2_PIN);
   #endif
 

commit b824a517aaad62001cf815e577b2f383f4766402
Author: Michiel Baird <michielbaird@gmail.com>
Date:   Sun Mar 10 15:22:09 2019 -0700

    Add G38.4 and G38.5 (#13348)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 1d825fe811..badda0fd23 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -107,22 +107,22 @@
 
 #if HAS_TRINAMIC
   #include "feature/tmc_util.h"
 #endif
 
 #if ENABLED(SDSUPPORT)
   CardReader card;
 #endif
 
 #if ENABLED(G38_PROBE_TARGET)
-  bool G38_move = false,
-       G38_endstop_hit = false;
+  uint8_t G38_move; // = 0
+  bool G38_did_trigger; // = false
 #endif
 
 #if ENABLED(DELTA)
   #include "module/delta.h"
 #elif IS_SCARA
   #include "module/scara.h"
 #endif
 
 #if HAS_LEVELING
   #include "feature/bedlevel/bedlevel.h"

commit e4d080e63cef6d3c001541a364442cd307743ae4
Author: Bruce j Beare <bruce.j.beare@intel.com>
Date:   Sun Mar 10 07:57:38 2019 -0700

    Reset after kill with a button on the KILL_PIN (#13091)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 2f022ec15f..1d825fe811 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -757,25 +757,48 @@ void minkill() {
   thermalManager.disable_all_heaters(); // turn off heaters again
 
   #if HAS_POWER_SWITCH
     PSU_OFF();
   #endif
 
   #if HAS_SUICIDE
     suicide();
   #endif
 
-  while (1) {
-    #if ENABLED(USE_WATCHDOG)
-      watchdog_reset();
-    #endif
-  } // Wait for reset
+  #if HAS_KILL
+
+    // Wait for kill to be released
+    while (!READ(KILL_PIN)) {
+      #if ENABLED(USE_WATCHDOG)
+        watchdog_reset();
+      #endif
+    }
+
+    // Wait for kill to be pressed
+    while (READ(KILL_PIN)) {
+      #if ENABLED(USE_WATCHDOG)
+        watchdog_reset();
+      #endif
+    }
+
+    void(*resetFunc)(void) = 0; // Declare resetFunc() at address 0
+    resetFunc();                // Jump to address 0
+
+  #else // !HAS_KILL
+
+    for (;;) {
+      #if ENABLED(USE_WATCHDOG)
+        watchdog_reset();
+      #endif
+    } // Wait for reset
+
+  #endif // !HAS_KILL
 }
 
 /**
  * Turn off heaters and stop the print in progress
  * After a stop the machine may be resumed with M999
  */
 void stop() {
   thermalManager.disable_all_heaters(); // 'unpause' taken care of in here
   print_job_timer.stop();
 

commit 12503fce063d968de4316254f91ab1eb39ff8b48
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 10 09:13:54 2019 -0500

    Followup to wait_for_user fix

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 7a3e815068..2f022ec15f 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -172,21 +172,21 @@
   #include "libs/L6470/L6470_Marlin.h"
 #endif
 
 bool Running = true;
 
 #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
   TempUnit input_temp_units = TEMPUNIT_C;
 #endif
 
 // For M109 and M190, this flag may be cleared (by M108) to exit the wait loop
-volatile bool wait_for_heatup = true;
+bool wait_for_heatup = true;
 
 // For M0/M1, this flag may be cleared (by M108) to exit the wait-for-user loop
 #if HAS_RESUME_CONTINUE
   bool wait_for_user; // = false;
 #endif
 
 #if HAS_AUTO_REPORTING || ENABLED(HOST_KEEPALIVE_FEATURE)
   bool suspend_auto_report; // = false
 #endif
 

commit 60e82e3929bfd402384e7dea9d737796c96fa07f
Author: Tobias Frost <coldtobi@users.noreply.github.com>
Date:   Sat Mar 9 21:13:50 2019 +0100

    Send notifications to ExtUI for M0/M1 (#13344)
    
    - Send notifications to ExtUI for M0/M1
    
    - wait_for_user can be non-volatile (not changed by interrupt)
      C / C++ compilers don't optimize away reads of non-volatile variables when a function call is used between accesses, because *any* variable could be changed by the function call. Since `wait_for_user` can't be changed without a function call, it should be non-volatile so the compiler can optimize away cases where it is read more than once without an intervening function call.

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index d6b6b534d7..7a3e815068 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -176,21 +176,21 @@ bool Running = true;
 
 #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
   TempUnit input_temp_units = TEMPUNIT_C;
 #endif
 
 // For M109 and M190, this flag may be cleared (by M108) to exit the wait loop
 volatile bool wait_for_heatup = true;
 
 // For M0/M1, this flag may be cleared (by M108) to exit the wait-for-user loop
 #if HAS_RESUME_CONTINUE
-  volatile bool wait_for_user; // = false;
+  bool wait_for_user; // = false;
 #endif
 
 #if HAS_AUTO_REPORTING || ENABLED(HOST_KEEPALIVE_FEATURE)
   bool suspend_auto_report; // = false
 #endif
 
 // Inactivity shutdown
 millis_t max_inactive_time, // = 0
          stepper_inactive_time = (DEFAULT_STEPPER_DEACTIVE_TIME) * 1000UL;
 

commit cfdb38eda4b4d993bac4a0e8600e776429b42b6e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Mar 5 06:46:19 2019 -0600

    Allow SERIAL_ECHOPAIR to take up to 12 pairs (#13311)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index a848265c12..d6b6b534d7 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -903,22 +903,21 @@ void setup() {
 
   #if defined(STRING_DISTRIBUTION_DATE) && defined(STRING_CONFIG_H_AUTHOR)
     SERIAL_ECHO_START();
     SERIAL_ECHOPGM(MSG_CONFIGURATION_VER);
     SERIAL_ECHOPGM(STRING_DISTRIBUTION_DATE);
     SERIAL_ECHOLNPGM(MSG_AUTHOR STRING_CONFIG_H_AUTHOR);
     SERIAL_ECHO_MSG("Compiled: " __DATE__);
   #endif
 
   SERIAL_ECHO_START();
-  SERIAL_ECHOPAIR(MSG_FREE_MEMORY, freeMemory());
-  SERIAL_ECHOLNPAIR(MSG_PLANNER_BUFFER_BYTES, (int)sizeof(block_t)*BLOCK_BUFFER_SIZE);
+  SERIAL_ECHOLNPAIR(MSG_FREE_MEMORY, freeMemory(), MSG_PLANNER_BUFFER_BYTES, (int)sizeof(block_t) * (BLOCK_BUFFER_SIZE));
 
   queue_setup();
 
   // Load data from EEPROM if available (or use defaults)
   // This also updates variables in the planner, elsewhere
   (void)settings.load();
 
   #if HAS_M206_COMMAND
     // Initialize current position based on home_offset
     LOOP_XYZ(a) current_position[a] += home_offset[a];

commit a2e3226597ee5fea26ad456d0287eeb223d78d86
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Dec 2 18:06:20 2018 -0600

    Init XYZ to configured home position

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 3e29f9ad55..a848265c12 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -914,23 +914,21 @@ void setup() {
   SERIAL_ECHOLNPAIR(MSG_PLANNER_BUFFER_BYTES, (int)sizeof(block_t)*BLOCK_BUFFER_SIZE);
 
   queue_setup();
 
   // Load data from EEPROM if available (or use defaults)
   // This also updates variables in the planner, elsewhere
   (void)settings.load();
 
   #if HAS_M206_COMMAND
     // Initialize current position based on home_offset
-    COPY(current_position, home_offset);
-  #else
-    ZERO(current_position);
+    LOOP_XYZ(a) current_position[a] += home_offset[a];
   #endif
 
   // Vital to init stepper/planner equivalent for current_position
   sync_plan_position();
 
   thermalManager.init();    // Initialize temperature loop
 
   print_job_timer.init();   // Initial setup of print job timer
 
   endstops.init();          // Init endstops and pullups

commit eb4bf93ea42c4c83335ca9cef21e78d0c752213f
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Wed Feb 27 05:38:56 2019 -0500

    Add more Babystep options (#13262)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index d81d96eb64..3e29f9ad55 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -461,25 +461,28 @@ void manage_inactivity(const bool ignore_stepper_queue/*=false*/) {
         #endif
         #if ENABLED(DISABLE_INACTIVE_Y)
           disable_Y();
         #endif
         #if ENABLED(DISABLE_INACTIVE_Z)
           disable_Z();
         #endif
         #if ENABLED(DISABLE_INACTIVE_E)
           disable_e_steppers();
         #endif
-        #if HAS_LCD_MENU && ENABLED(AUTO_BED_LEVELING_UBL)
-          if (ubl.lcd_map_control) {
-            ubl.lcd_map_control = false;
-            ui.defer_status_screen(false);
-          }
+        #if HAS_LCD_MENU
+          ui.status_screen();
+          #if ENABLED(AUTO_BED_LEVELING_UBL)
+            if (ubl.lcd_map_control) {
+              ubl.lcd_map_control = false;
+              ui.defer_status_screen(false);
+            }
+          #endif
         #endif
       }
     }
     else
       already_shutdown_steppers = false;
   }
 
   #if PIN_EXISTS(CHDK) // Check if pin should be set to LOW (after M240 set it HIGH)
     if (chdk_timeout && ELAPSED(ms, chdk_timeout)) {
       chdk_timeout = 0;

commit ddbe4cfa20165b5efcd8fb28078083261136cf72
Author: Bob Kuhn <bob.kuhn@att.net>
Date:   Tue Feb 26 21:03:13 2019 -0600

    Printrboard G2 support (#13116)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index b8aaa4cfb5..d81d96eb64 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -416,21 +416,23 @@ void disable_all_steppers() {
  * Manage several activities:
  *  - Check for Filament Runout
  *  - Keep the command buffer full
  *  - Check for maximum inactive time between commands
  *  - Check for maximum inactive time between stepper commands
  *  - Check if CHDK_PIN needs to go LOW
  *  - Check for KILL button held down
  *  - Check for HOME button held down
  *  - Check if cooling fan needs to be switched on
  *  - Check if an idle but hot extruder needs filament extruded (EXTRUDER_RUNOUT_PREVENT)
+ *  - Pulse FET_SAFETY_PIN if it exists
  */
+
 void manage_inactivity(const bool ignore_stepper_queue/*=false*/) {
 
   #if HAS_FILAMENT_SENSOR
     runout.run();
   #endif
 
   if (commands_in_queue < BUFSIZE) get_available_commands();
 
   const millis_t ms = millis();
 
@@ -632,20 +634,30 @@ void manage_inactivity(const bool ignore_stepper_queue/*=false*/) {
   #if ENABLED(MONITOR_L6470_DRIVER_STATUS)
     L6470.monitor_driver();
   #endif
 
   // Limit check_axes_activity frequency to 10Hz
   static millis_t next_check_axes_ms = 0;
   if (ELAPSED(ms, next_check_axes_ms)) {
     planner.check_axes_activity();
     next_check_axes_ms = ms + 100UL;
   }
+
+  #if PIN_EXISTS(FET_SAFETY)
+    static millis_t FET_next;
+    if (ELAPSED(ms, FET_next)) {
+      FET_next = ms + FET_SAFETY_DELAY;  // 2uS pulse every FET_SAFETY_DELAY mS
+      OUT_WRITE(FET_SAFETY_PIN, !FET_SAFETY_INVERTED);
+      DELAY_US(2);
+      WRITE(FET_SAFETY_PIN, FET_SAFETY_INVERTED);
+    }
+  #endif
 }
 
 /**
  * Standard idle routine keeps the machine alive
  */
 void idle(
   #if ENABLED(ADVANCED_PAUSE_FEATURE)
     bool no_stepper_sleep/*=false*/
   #endif
 ) {

commit 89bbc30a09b854c1fa20f63113a92c33df65e19a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Feb 20 05:28:40 2019 -0600

    Fix init of power supply pin
    
    Fix #13184

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 4ec826f6c1..b8aaa4cfb5 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -213,35 +213,33 @@ void setup_killpin() {
     SET_INPUT_PULLUP(KILL_PIN);
   #endif
 }
 
 void setup_powerhold() {
   #if HAS_SUICIDE
     OUT_WRITE(SUICIDE_PIN, HIGH);
   #endif
   #if HAS_POWER_SWITCH
     #if ENABLED(PS_DEFAULT_OFF)
-      PSU_OFF();
+      powersupply_on = true;  PSU_OFF();
     #else
-      PSU_ON();
+      powersupply_on = false; PSU_ON();
     #endif
   #endif
 }
 
 /**
  * Stepper Reset (RigidBoard, et.al.)
  */
 #if HAS_STEPPER_RESET
-  void disableStepperDrivers() {
-    OUT_WRITE(STEPPER_RESET_PIN, LOW);  // drive it down to hold in reset motor driver chips
-  }
-  void enableStepperDrivers() { SET_INPUT(STEPPER_RESET_PIN); }  // set to input, which allows it to be pulled high by pullups
+  void disableStepperDrivers() { OUT_WRITE(STEPPER_RESET_PIN, LOW); } // Drive down to keep motor driver chips in reset
+  void enableStepperDrivers()  { SET_INPUT(STEPPER_RESET_PIN); }      // Set to input, allowing pullups to pull the pin high
 #endif
 
 #if ENABLED(EXPERIMENTAL_I2CBUS) && I2C_SLAVE_ADDRESS > 0
 
   void i2c_on_receive(int bytes) { // just echo all bytes received to serial
     i2c.receive(bytes);
   }
 
   void i2c_on_request() {          // just send dummy data for now
     i2c.reply("Hello World!\n");

commit 992cdc8d14e589cbc6d5fe5b4b8fca8e2b4e12e9
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Tue Feb 19 13:45:03 2019 -0700

    Fix host action / G-code ordering in event_probe_failure (#13207)
    
    Observing from the console, it makes the most sense to do `//action:probe_retry` before executing commands.

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index f899143d20..4ec826f6c1 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -379,44 +379,44 @@ void disable_all_steppers() {
 
     if (run_runout_script)
       enqueue_and_echo_commands_P(PSTR(FILAMENT_RUNOUT_SCRIPT));
   }
 
 #endif // HAS_FILAMENT_SENSOR
 
 #if ENABLED(G29_RETRY_AND_RECOVER)
 
   void event_probe_failure() {
+    #ifdef ACTION_ON_G29_FAILURE
+      host_action(PSTR(ACTION_ON_G29_FAILURE));
+    #endif
     #ifdef G29_FAILURE_COMMANDS
       gcode.process_subcommands_now_P(PSTR(G29_FAILURE_COMMANDS));
     #endif
-    #ifdef ACTION_ON_G29_FAILURE
-      host_action(PSTR(ACTION_ON_G29_FAILURE)); }
-    #endif
     #if ENABLED(G29_HALT_ON_FAILURE)
       #ifdef ACTION_ON_CANCEL
         host_action_cancel();
       #endif
       kill(PSTR(MSG_ERR_PROBING_FAILED));
     #endif
   }
 
   void event_probe_recover() {
     #if ENABLED(HOST_PROMPT_SUPPORT)
       host_prompt_do(PROMPT_INFO, PSTR("G29 Retrying"));
     #endif
-    #ifdef G29_RECOVER_COMMANDS
-      gcode.process_subcommands_now_P(PSTR(G29_RECOVER_COMMANDS));
-    #endif
     #ifdef ACTION_ON_G29_RECOVER
       host_action(PSTR(ACTION_ON_G29_RECOVER));
     #endif
+    #ifdef G29_RECOVER_COMMANDS
+      gcode.process_subcommands_now_P(PSTR(G29_RECOVER_COMMANDS));
+    #endif
   }
 
 #endif
 
 /**
  * Manage several activities:
  *  - Check for Filament Runout
  *  - Keep the command buffer full
  *  - Check for maximum inactive time between commands
  *  - Check for maximum inactive time between stepper commands

commit d2bdb71c13fa18957638b137395200ba2c28e1b2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Feb 14 15:09:35 2019 -0600

    Add PHOTO_GCODE option, photo trigger physical move (#13168)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index e101e9f2b9..f899143d20 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -188,21 +188,20 @@ volatile bool wait_for_heatup = true;
 
 #if HAS_AUTO_REPORTING || ENABLED(HOST_KEEPALIVE_FEATURE)
   bool suspend_auto_report; // = false
 #endif
 
 // Inactivity shutdown
 millis_t max_inactive_time, // = 0
          stepper_inactive_time = (DEFAULT_STEPPER_DEACTIVE_TIME) * 1000UL;
 
 #if PIN_EXISTS(CHDK)
-  extern bool chdk_active;
   extern millis_t chdk_timeout;
 #endif
 
 #if ENABLED(I2C_POSITION_ENCODERS)
   I2CPositionEncodersMgr I2CPEM;
 #endif
 
 /**
  * ***************************************************************************
  * ******************************** FUNCTIONS ********************************
@@ -475,22 +474,22 @@ void manage_inactivity(const bool ignore_stepper_queue/*=false*/) {
             ui.defer_status_screen(false);
           }
         #endif
       }
     }
     else
       already_shutdown_steppers = false;
   }
 
   #if PIN_EXISTS(CHDK) // Check if pin should be set to LOW (after M240 set it HIGH)
-    if (chdk_active && ELAPSED(ms, chdk_timeout)) {
-      chdk_active = false;
+    if (chdk_timeout && ELAPSED(ms, chdk_timeout)) {
+      chdk_timeout = 0;
       WRITE(CHDK_PIN, LOW);
     }
   #endif
 
   #if HAS_KILL
 
     // Check if the kill button was pressed and wait just in case it was an accidental
     // key kill key press
     // -------------------------------------------------------------------------------
     static int killCount = 0;   // make the inactivity button a bit less responsive

commit bdc2f10b90343b4796e5ecd31537f2c02258248e
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Thu Feb 14 04:05:18 2019 +0100

    Update Italian language, fix unused var warning (#13164)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index ce2a1acfb1..e101e9f2b9 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -324,25 +324,27 @@ void disable_all_steppers() {
   void event_filament_runout() {
 
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
       if (did_pause_print) return;  // Action already in progress. Purge triggered repeated runout.
     #endif
 
     #if ENABLED(EXTENSIBLE_UI)
       ExtUI::onFilamentRunout(ExtUI::getActiveTool());
     #endif
 
-    const char tool = '0'
-      #if NUM_RUNOUT_SENSORS > 1
-        + active_extruder
-      #endif
-    ;
+    #if ENABLED(HOST_PROMPT_SUPPORT) || ENABLED(HOST_ACTION_COMMANDS)
+      const char tool = '0'
+        #if NUM_RUNOUT_SENSORS > 1
+          + active_extruder
+        #endif
+      ;
+    #endif
 
     //action:out_of_filament
     #if ENABLED(HOST_PROMPT_SUPPORT)
       host_prompt_reason = PROMPT_FILAMENT_RUNOUT;
       host_action_prompt_end();
       host_action_prompt_begin(PSTR("FilamentRunout T"), false);
       SERIAL_CHAR(tool);
       SERIAL_EOL();
       host_action_prompt_show();
     #endif

commit 9f0e1834ec7c9b0d5ad56fce0def9d3e5bebba3e
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Wed Feb 13 19:39:38 2019 -0700

    Followup to #13039 (#13163)
    
    - Fix compile error when accessing `process_subcommands_now_P`.
    - Use `const` var eliminating double-negative (to make code more understandable).

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 490c84317c..ce2a1acfb1 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -340,22 +340,24 @@ void disable_all_steppers() {
     //action:out_of_filament
     #if ENABLED(HOST_PROMPT_SUPPORT)
       host_prompt_reason = PROMPT_FILAMENT_RUNOUT;
       host_action_prompt_end();
       host_action_prompt_begin(PSTR("FilamentRunout T"), false);
       SERIAL_CHAR(tool);
       SERIAL_EOL();
       host_action_prompt_show();
     #endif
 
+    const bool run_runout_script = !runout.host_handling;
+
     #if ENABLED(HOST_ACTION_COMMANDS)
-      if (!runout.host_handling
+      if (run_runout_script
         && ( strstr(FILAMENT_RUNOUT_SCRIPT, "M600")
           || strstr(FILAMENT_RUNOUT_SCRIPT, "M125")
           #if ENABLED(ADVANCED_PAUSE_FEATURE)
             || strstr(FILAMENT_RUNOUT_SCRIPT, "M25")
           #endif
         )
       ) {
         host_action_paused(false);
       }
       else {
@@ -365,52 +367,51 @@ void disable_all_steppers() {
           host_action(PSTR(ACTION_ON_FILAMENT_RUNOUT " T"), false);
           SERIAL_CHAR(tool);
           SERIAL_EOL();
         #endif
 
         host_action_pause(false);
       }
       SERIAL_ECHOPGM(" " ACTION_REASON_ON_FILAMENT_RUNOUT " ");
       SERIAL_CHAR(tool);
       SERIAL_EOL();
-
     #endif // HOST_ACTION_COMMANDS
 
-    if (!runout.host_handling)
+    if (run_runout_script)
       enqueue_and_echo_commands_P(PSTR(FILAMENT_RUNOUT_SCRIPT));
   }
 
 #endif // HAS_FILAMENT_SENSOR
 
 #if ENABLED(G29_RETRY_AND_RECOVER)
 
   void event_probe_failure() {
     #ifdef G29_FAILURE_COMMANDS
-      process_subcommands_now_P(PSTR(G29_FAILURE_COMMANDS));
+      gcode.process_subcommands_now_P(PSTR(G29_FAILURE_COMMANDS));
     #endif
     #ifdef ACTION_ON_G29_FAILURE
       host_action(PSTR(ACTION_ON_G29_FAILURE)); }
     #endif
     #if ENABLED(G29_HALT_ON_FAILURE)
       #ifdef ACTION_ON_CANCEL
         host_action_cancel();
       #endif
       kill(PSTR(MSG_ERR_PROBING_FAILED));
     #endif
   }
 
   void event_probe_recover() {
     #if ENABLED(HOST_PROMPT_SUPPORT)
       host_prompt_do(PROMPT_INFO, PSTR("G29 Retrying"));
     #endif
     #ifdef G29_RECOVER_COMMANDS
-      process_subcommands_now_P(PSTR(G29_RECOVER_COMMANDS));
+      gcode.process_subcommands_now_P(PSTR(G29_RECOVER_COMMANDS));
     #endif
     #ifdef ACTION_ON_G29_RECOVER
       host_action(PSTR(ACTION_ON_G29_RECOVER));
     #endif
   }
 
 #endif
 
 /**
  * Manage several activities:

commit 7cf9b93f26f728f0104dc9b930f6b23096639d98
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 20:08:34 2019 -0600

    Add HAS_FILAMENT_SENSOR ahead of 12962

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 34d0a245b8..490c84317c 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -129,21 +129,21 @@
 #endif
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE) && ENABLED(PAUSE_PARK_NO_STEPPER_TIMEOUT)
   #include "feature/pause.h"
 #endif
 
 #if ENABLED(POWER_LOSS_RECOVERY)
   #include "feature/power_loss_recovery.h"
 #endif
 
-#if ENABLED(FILAMENT_RUNOUT_SENSOR)
+#if HAS_FILAMENT_SENSOR
   #include "feature/runout.h"
 #endif
 
 #if ENABLED(TEMP_STAT_LEDS)
   #include "feature/leds/tempstat.h"
 #endif
 
 #if HAS_CASE_LIGHT
   #include "feature/caselight.h"
 #endif
@@ -312,21 +312,21 @@ void disable_e_stepper(const uint8_t e) {
   }
 }
 
 void disable_all_steppers() {
   disable_X();
   disable_Y();
   disable_Z();
   disable_e_steppers();
 }
 
-#if ENABLED(FILAMENT_RUNOUT_SENSOR)
+#if HAS_FILAMENT_SENSOR
 
   void event_filament_runout() {
 
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
       if (did_pause_print) return;  // Action already in progress. Purge triggered repeated runout.
     #endif
 
     #if ENABLED(EXTENSIBLE_UI)
       ExtUI::onFilamentRunout(ExtUI::getActiveTool());
     #endif
@@ -372,21 +372,21 @@ void disable_all_steppers() {
       SERIAL_ECHOPGM(" " ACTION_REASON_ON_FILAMENT_RUNOUT " ");
       SERIAL_CHAR(tool);
       SERIAL_EOL();
 
     #endif // HOST_ACTION_COMMANDS
 
     if (!runout.host_handling)
       enqueue_and_echo_commands_P(PSTR(FILAMENT_RUNOUT_SCRIPT));
   }
 
-#endif // FILAMENT_RUNOUT_SENSOR
+#endif // HAS_FILAMENT_SENSOR
 
 #if ENABLED(G29_RETRY_AND_RECOVER)
 
   void event_probe_failure() {
     #ifdef G29_FAILURE_COMMANDS
       process_subcommands_now_P(PSTR(G29_FAILURE_COMMANDS));
     #endif
     #ifdef ACTION_ON_G29_FAILURE
       host_action(PSTR(ACTION_ON_G29_FAILURE)); }
     #endif
@@ -419,21 +419,21 @@ void disable_all_steppers() {
  *  - Check for maximum inactive time between commands
  *  - Check for maximum inactive time between stepper commands
  *  - Check if CHDK_PIN needs to go LOW
  *  - Check for KILL button held down
  *  - Check for HOME button held down
  *  - Check if cooling fan needs to be switched on
  *  - Check if an idle but hot extruder needs filament extruded (EXTRUDER_RUNOUT_PREVENT)
  */
 void manage_inactivity(const bool ignore_stepper_queue/*=false*/) {
 
-  #if ENABLED(FILAMENT_RUNOUT_SENSOR)
+  #if HAS_FILAMENT_SENSOR
     runout.run();
   #endif
 
   if (commands_in_queue < BUFSIZE) get_available_commands();
 
   const millis_t ms = millis();
 
   if (max_inactive_time && ELAPSED(ms, gcode.previous_move_ms + max_inactive_time)) {
     SERIAL_ERROR_START();
     SERIAL_ECHOLNPAIR(MSG_KILL_INACTIVE_TIME, parser.command_ptr);
@@ -820,21 +820,21 @@ void setup() {
     #endif
   #elif ENABLED(DISABLE_JTAG)
     // Disable JTAG to free up pins for IO
     #ifdef JTAG_DISABLE
       JTAG_DISABLE();
     #else
       #error "DISABLE_JTAG is not supported for the selected MCU/Board"
     #endif
   #endif
 
-  #if ENABLED(FILAMENT_RUNOUT_SENSOR)
+  #if HAS_FILAMENT_SENSOR
     runout.setup();
   #endif
 
   setup_killpin();
 
   setup_powerhold();
 
   #if HAS_STEPPER_RESET
     disableStepperDrivers();
   #endif

commit 7f1b69b0c83ae914ed9ae35fdad9f79814069652
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue Feb 12 16:55:47 2019 -0500

    Add HOST_PROMPT_SUPPORT (#13039)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index b64357a3b1..34d0a245b8 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -49,20 +49,24 @@
 #ifdef ARDUINO
   #include <pins_arduino.h>
 #endif
 #include <math.h>
 #include "libs/nozzle.h"
 
 #include "gcode/gcode.h"
 #include "gcode/parser.h"
 #include "gcode/queue.h"
 
+#if ENABLED(HOST_ACTION_COMMANDS)
+  #include "feature/host_actions.h"
+#endif
+
 #if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER)
   #include "libs/buzzer.h"
 #endif
 
 #if ENABLED(DIGIPOT_I2C)
   #include "feature/digipot/digipot.h"
 #endif
 
 #if ENABLED(MIXING_EXTRUDER)
   #include "feature/mixing.h"
@@ -308,51 +312,112 @@ void disable_e_stepper(const uint8_t e) {
   }
 }
 
 void disable_all_steppers() {
   disable_X();
   disable_Y();
   disable_Z();
   disable_e_steppers();
 }
 
-#if HAS_ACTION_COMMANDS
+#if ENABLED(FILAMENT_RUNOUT_SENSOR)
+
+  void event_filament_runout() {
+
+    #if ENABLED(ADVANCED_PAUSE_FEATURE)
+      if (did_pause_print) return;  // Action already in progress. Purge triggered repeated runout.
+    #endif
+
+    #if ENABLED(EXTENSIBLE_UI)
+      ExtUI::onFilamentRunout(ExtUI::getActiveTool());
+    #endif
+
+    const char tool = '0'
+      #if NUM_RUNOUT_SENSORS > 1
+        + active_extruder
+      #endif
+    ;
+
+    //action:out_of_filament
+    #if ENABLED(HOST_PROMPT_SUPPORT)
+      host_prompt_reason = PROMPT_FILAMENT_RUNOUT;
+      host_action_prompt_end();
+      host_action_prompt_begin(PSTR("FilamentRunout T"), false);
+      SERIAL_CHAR(tool);
+      SERIAL_EOL();
+      host_action_prompt_show();
+    #endif
+
+    #if ENABLED(HOST_ACTION_COMMANDS)
+      if (!runout.host_handling
+        && ( strstr(FILAMENT_RUNOUT_SCRIPT, "M600")
+          || strstr(FILAMENT_RUNOUT_SCRIPT, "M125")
+          #if ENABLED(ADVANCED_PAUSE_FEATURE)
+            || strstr(FILAMENT_RUNOUT_SCRIPT, "M25")
+          #endif
+        )
+      ) {
+        host_action_paused(false);
+      }
+      else {
+        // Legacy Repetier command for use until newer version supports standard dialog
+        // To be removed later when pause command also triggers dialog
+        #ifdef ACTION_ON_FILAMENT_RUNOUT
+          host_action(PSTR(ACTION_ON_FILAMENT_RUNOUT " T"), false);
+          SERIAL_CHAR(tool);
+          SERIAL_EOL();
+        #endif
+
+        host_action_pause(false);
+      }
+      SERIAL_ECHOPGM(" " ACTION_REASON_ON_FILAMENT_RUNOUT " ");
+      SERIAL_CHAR(tool);
+      SERIAL_EOL();
 
-  void host_action(const char * const pstr, const bool eol=true) {
-    SERIAL_ECHOPGM("//action:");
-    serialprintPGM(pstr);
-    if (eol) SERIAL_EOL();
+    #endif // HOST_ACTION_COMMANDS
+
+    if (!runout.host_handling)
+      enqueue_and_echo_commands_P(PSTR(FILAMENT_RUNOUT_SCRIPT));
   }
 
-  #ifdef ACTION_ON_KILL
-    void host_action_kill() { host_action(PSTR(ACTION_ON_KILL)); }
-  #endif
-  #ifdef ACTION_ON_PAUSE
-    void host_action_pause() { host_action(PSTR(ACTION_ON_PAUSE)); }
-  #endif
-  #ifdef ACTION_ON_PAUSED
-    void host_action_paused() { host_action(PSTR(ACTION_ON_PAUSED)); }
-  #endif
-  #ifdef ACTION_ON_RESUME
-    void host_action_resume() { host_action(PSTR(ACTION_ON_RESUME)); }
-  #endif
-  #ifdef ACTION_ON_RESUMED
-    void host_action_resumed() { host_action(PSTR(ACTION_ON_RESUMED)); }
-  #endif
-  #ifdef ACTION_ON_CANCEL
-    void host_action_cancel() { host_action(PSTR(ACTION_ON_CANCEL)); }
-  #endif
-  #ifdef ACTION_ON_FILAMENT_RUNOUT
-    void host_action_filament_runout(const bool eol/*=true*/) { host_action(PSTR(ACTION_ON_FILAMENT_RUNOUT), eol); }
-  #endif
+#endif // FILAMENT_RUNOUT_SENSOR
+
+#if ENABLED(G29_RETRY_AND_RECOVER)
+
+  void event_probe_failure() {
+    #ifdef G29_FAILURE_COMMANDS
+      process_subcommands_now_P(PSTR(G29_FAILURE_COMMANDS));
+    #endif
+    #ifdef ACTION_ON_G29_FAILURE
+      host_action(PSTR(ACTION_ON_G29_FAILURE)); }
+    #endif
+    #if ENABLED(G29_HALT_ON_FAILURE)
+      #ifdef ACTION_ON_CANCEL
+        host_action_cancel();
+      #endif
+      kill(PSTR(MSG_ERR_PROBING_FAILED));
+    #endif
+  }
+
+  void event_probe_recover() {
+    #if ENABLED(HOST_PROMPT_SUPPORT)
+      host_prompt_do(PROMPT_INFO, PSTR("G29 Retrying"));
+    #endif
+    #ifdef G29_RECOVER_COMMANDS
+      process_subcommands_now_P(PSTR(G29_RECOVER_COMMANDS));
+    #endif
+    #ifdef ACTION_ON_G29_RECOVER
+      host_action(PSTR(ACTION_ON_G29_RECOVER));
+    #endif
+  }
 
-#endif // HAS_ACTION_COMMANDS
+#endif
 
 /**
  * Manage several activities:
  *  - Check for Filament Runout
  *  - Keep the command buffer full
  *  - Check for maximum inactive time between commands
  *  - Check for maximum inactive time between stepper commands
  *  - Check if CHDK_PIN needs to go LOW
  *  - Check for KILL button held down
  *  - Check for HOME button held down

commit 0feeef26048883640b37ebe3994730f31ef6e922
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 15:06:53 2019 -0600

    Update copyright in headers

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 13f033233d..b64357a3b1 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2016, 2017 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit 524c6c10bf52b9956ca2f68eb3d3074e5cba0706
Author: Rolf Werum <39219447+Weruminger@users.noreply.github.com>
Date:   Wed Feb 6 13:30:53 2019 +0100

    MAGNETIC_PARKING_EXTRUDER (#12351)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index f504b0b5d1..13f033233d 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -141,21 +141,21 @@
 #endif
 
 #if HAS_CASE_LIGHT
   #include "feature/caselight.h"
 #endif
 
 #if HAS_FANMUX
   #include "feature/fanmux.h"
 #endif
 
-#if DO_SWITCH_EXTRUDER || ENABLED(SWITCHING_NOZZLE) || ENABLED(PARKING_EXTRUDER)
+#if DO_SWITCH_EXTRUDER || ENABLED(SWITCHING_NOZZLE) || ENABLED(PARKING_EXTRUDER) || ENABLED(MAGNETIC_PARKING_EXTRUDER)
   #include "module/tool_change.h"
 #endif
 
 #if ENABLED(USE_CONTROLLER_FAN)
   #include "feature/controllerfan.h"
 #endif
 
 #if ENABLED(PRUSA_MMU2)
   #include "feature/prusa_MMU2/mmu2.h"
 #endif
@@ -968,22 +968,26 @@ void setup() {
   #if ENABLED(SWITCHING_NOZZLE)
     // Initialize nozzle servo(s)
     #if SWITCHING_NOZZLE_TWO_SERVOS
       lower_nozzle(0);
       raise_nozzle(1);
     #else
       move_nozzle_servo(0);
     #endif
   #endif
 
+  #if ENABLED(MAGNETIC_PARKING_EXTRUDER)
+    mpe_settings_init();
+  #endif
+
   #if ENABLED(PARKING_EXTRUDER)
-    pe_magnet_init();
+    pe_solenoid_init();
   #endif
 
   #if ENABLED(POWER_LOSS_RECOVERY)
     recovery.check();
   #endif
 
   #if ENABLED(USE_WATCHDOG)
     watchdog_init();          // Reinit watchdog after HAL_get_reset_source call
   #endif
 

commit 5cfc1cdacc52ca9e09e40872ab2918d0d88ef0f2
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Sun Feb 3 23:19:56 2019 -0700

    Support SWITCHING_NOZZLE with 2 servos (#13054)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 4180787d09..f504b0b5d1 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -959,21 +959,27 @@ void setup() {
   #if ENABLED(EXPERIMENTAL_I2CBUS) && I2C_SLAVE_ADDRESS > 0
     i2c.onReceive(i2c_on_receive);
     i2c.onRequest(i2c_on_request);
   #endif
 
   #if DO_SWITCH_EXTRUDER
     move_extruder_servo(0);   // Initialize extruder servo
   #endif
 
   #if ENABLED(SWITCHING_NOZZLE)
-    move_nozzle_servo(0);     // Initialize nozzle servo
+    // Initialize nozzle servo(s)
+    #if SWITCHING_NOZZLE_TWO_SERVOS
+      lower_nozzle(0);
+      raise_nozzle(1);
+    #else
+      move_nozzle_servo(0);
+    #endif
   #endif
 
   #if ENABLED(PARKING_EXTRUDER)
     pe_magnet_init();
   #endif
 
   #if ENABLED(POWER_LOSS_RECOVERY)
     recovery.check();
   #endif
 

commit 6a57d0b381db99d67cccd48135cbdd2d831588a7
Author: revilor <oliver.rossmueller@web.de>
Date:   Fri Feb 1 02:10:52 2019 +0100

    Prusa MMU2 (#12967)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index b72c0b037c..4180787d09 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -149,20 +149,24 @@
 #endif
 
 #if DO_SWITCH_EXTRUDER || ENABLED(SWITCHING_NOZZLE) || ENABLED(PARKING_EXTRUDER)
   #include "module/tool_change.h"
 #endif
 
 #if ENABLED(USE_CONTROLLER_FAN)
   #include "feature/controllerfan.h"
 #endif
 
+#if ENABLED(PRUSA_MMU2)
+  #include "feature/prusa_MMU2/mmu2.h"
+#endif
+
 #if ENABLED(EXTENSIBLE_UI)
   #include "lcd/extensible_ui/ui_api.h"
 #endif
 
 #if HAS_DRIVER(L6470)
   #include "libs/L6470/L6470_Marlin.h"
 #endif
 
 bool Running = true;
 
@@ -625,20 +629,24 @@ void idle(
       #endif
       #if ENABLED(AUTO_REPORT_SD_STATUS)
         card.auto_report_sd_status();
       #endif
     }
   #endif
 
   #if ENABLED(USB_FLASH_DRIVE_SUPPORT)
     Sd2Card::idle();
   #endif
+
+  #if ENABLED(PRUSA_MMU2)
+    mmu2.mmuLoop();
+  #endif
 }
 
 /**
  * Kill all activity and lock the machine.
  * After this the machine will need to be reset.
  */
 void kill(PGM_P const lcd_msg/*=NULL*/) {
   thermalManager.disable_all_heaters();
 
   SERIAL_ERROR_MSG(MSG_ERR_KILLED);
@@ -977,20 +985,24 @@ void setup() {
     init_closedloop();
   #endif
 
   #if ENABLED(SDSUPPORT) && DISABLED(ULTRA_LCD)
     card.beginautostart();
   #endif
 
   #if HAS_TRINAMIC && DISABLED(PS_DEFAULT_OFF)
     test_tmc_connection(true, true, true, true);
   #endif
+
+  #if ENABLED(PRUSA_MMU2)
+    mmu2.init();
+  #endif
 }
 
 /**
  * The main Marlin program loop
  *
  *  - Save or log commands to SD
  *  - Process available commands (if not saving)
  *  - Call endstop manager
  *  - Call inactivity manager
  */

commit 48a3502656b29439ae7172d24259353dc3183dd9
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sun Jan 27 23:43:13 2019 -0500

    Remote streamer improvements (#12982)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 0f5b4bf37a..b72c0b037c 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -304,20 +304,52 @@ void disable_e_stepper(const uint8_t e) {
   }
 }
 
 void disable_all_steppers() {
   disable_X();
   disable_Y();
   disable_Z();
   disable_e_steppers();
 }
 
+#if HAS_ACTION_COMMANDS
+
+  void host_action(const char * const pstr, const bool eol=true) {
+    SERIAL_ECHOPGM("//action:");
+    serialprintPGM(pstr);
+    if (eol) SERIAL_EOL();
+  }
+
+  #ifdef ACTION_ON_KILL
+    void host_action_kill() { host_action(PSTR(ACTION_ON_KILL)); }
+  #endif
+  #ifdef ACTION_ON_PAUSE
+    void host_action_pause() { host_action(PSTR(ACTION_ON_PAUSE)); }
+  #endif
+  #ifdef ACTION_ON_PAUSED
+    void host_action_paused() { host_action(PSTR(ACTION_ON_PAUSED)); }
+  #endif
+  #ifdef ACTION_ON_RESUME
+    void host_action_resume() { host_action(PSTR(ACTION_ON_RESUME)); }
+  #endif
+  #ifdef ACTION_ON_RESUMED
+    void host_action_resumed() { host_action(PSTR(ACTION_ON_RESUMED)); }
+  #endif
+  #ifdef ACTION_ON_CANCEL
+    void host_action_cancel() { host_action(PSTR(ACTION_ON_CANCEL)); }
+  #endif
+  #ifdef ACTION_ON_FILAMENT_RUNOUT
+    void host_action_filament_runout(const bool eol/*=true*/) { host_action(PSTR(ACTION_ON_FILAMENT_RUNOUT), eol); }
+  #endif
+
+#endif // HAS_ACTION_COMMANDS
+
 /**
  * Manage several activities:
  *  - Check for Filament Runout
  *  - Keep the command buffer full
  *  - Check for maximum inactive time between commands
  *  - Check for maximum inactive time between stepper commands
  *  - Check if CHDK_PIN needs to go LOW
  *  - Check for KILL button held down
  *  - Check for HOME button held down
  *  - Check if cooling fan needs to be switched on
@@ -611,21 +643,21 @@ void kill(PGM_P const lcd_msg/*=NULL*/) {
 
   SERIAL_ERROR_MSG(MSG_ERR_KILLED);
 
   #if HAS_SPI_LCD || ENABLED(EXTENSIBLE_UI)
     ui.kill_screen(lcd_msg ? lcd_msg : PSTR(MSG_KILLED));
   #else
     UNUSED(lcd_msg);
   #endif
 
   #ifdef ACTION_ON_KILL
-    SERIAL_ECHOLNPGM("//action:" ACTION_ON_KILL);
+    host_action_kill();
   #endif
 
   minkill();
 }
 
 void minkill() {
 
   // Wait a short time (allows messages to get out before shutting down.
   for (int i = 1000; i--;) DELAY_US(600);
 

commit 2f35747f294c4b3dc3e6920b34e208f89bd4841d
Author: Bob Kuhn <bob.kuhn@att.net>
Date:   Wed Jan 23 19:06:54 2019 -0600

    L6470 SPI daisy chain support (#12895)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 8a5ac05e8c..0f5b4bf37a 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -37,20 +37,22 @@
 #include "module/endstops.h"
 #include "module/probe.h"
 #include "module/temperature.h"
 #include "sd/cardreader.h"
 #include "module/configuration_store.h"
 #include "module/printcounter.h" // PrintCounter or Stopwatch
 #include "feature/closedloop.h"
 
 #include "HAL/shared/Delay.h"
 
+#include "module/stepper_indirection.h"
+
 #ifdef ARDUINO
   #include <pins_arduino.h>
 #endif
 #include <math.h>
 #include "libs/nozzle.h"
 
 #include "gcode/gcode.h"
 #include "gcode/parser.h"
 #include "gcode/queue.h"
 
@@ -151,20 +153,24 @@
 #endif
 
 #if ENABLED(USE_CONTROLLER_FAN)
   #include "feature/controllerfan.h"
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "lcd/extensible_ui/ui_api.h"
 #endif
 
+#if HAS_DRIVER(L6470)
+  #include "libs/L6470/L6470_Marlin.h"
+#endif
+
 bool Running = true;
 
 #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
   TempUnit input_temp_units = TEMPUNIT_C;
 #endif
 
 // For M109 and M190, this flag may be cleared (by M108) to exit the wait loop
 volatile bool wait_for_heatup = true;
 
 // For M0/M1, this flag may be cleared (by M108) to exit the wait-for-user loop
@@ -334,42 +340,48 @@ void manage_inactivity(const bool ignore_stepper_queue/*=false*/) {
   }
 
   // Prevent steppers timing-out in the middle of M600
   #if ENABLED(ADVANCED_PAUSE_FEATURE) && ENABLED(PAUSE_PARK_NO_STEPPER_TIMEOUT)
     #define MOVE_AWAY_TEST !did_pause_print
   #else
     #define MOVE_AWAY_TEST true
   #endif
 
   if (stepper_inactive_time) {
+    static bool already_shutdown_steppers; // = false
     if (planner.has_blocks_queued())
       gcode.previous_move_ms = ms; // reset_stepper_timeout to keep steppers powered
     else if (MOVE_AWAY_TEST && !ignore_stepper_queue && ELAPSED(ms, gcode.previous_move_ms + stepper_inactive_time)) {
-      #if ENABLED(DISABLE_INACTIVE_X)
-        disable_X();
-      #endif
-      #if ENABLED(DISABLE_INACTIVE_Y)
-        disable_Y();
-      #endif
-      #if ENABLED(DISABLE_INACTIVE_Z)
-        disable_Z();
-      #endif
-      #if ENABLED(DISABLE_INACTIVE_E)
-        disable_e_steppers();
-      #endif
-      #if HAS_LCD_MENU && ENABLED(AUTO_BED_LEVELING_UBL)
-        if (ubl.lcd_map_control) {
-          ubl.lcd_map_control = false;
-          ui.defer_status_screen(false);
-        }
-      #endif
+      if (!already_shutdown_steppers) {
+        already_shutdown_steppers = true;  // L6470 SPI will consume 99% of free time without this
+        #if ENABLED(DISABLE_INACTIVE_X)
+          disable_X();
+        #endif
+        #if ENABLED(DISABLE_INACTIVE_Y)
+          disable_Y();
+        #endif
+        #if ENABLED(DISABLE_INACTIVE_Z)
+          disable_Z();
+        #endif
+        #if ENABLED(DISABLE_INACTIVE_E)
+          disable_e_steppers();
+        #endif
+        #if HAS_LCD_MENU && ENABLED(AUTO_BED_LEVELING_UBL)
+          if (ubl.lcd_map_control) {
+            ubl.lcd_map_control = false;
+            ui.defer_status_screen(false);
+          }
+        #endif
+      }
     }
+    else
+      already_shutdown_steppers = false;
   }
 
   #if PIN_EXISTS(CHDK) // Check if pin should be set to LOW (after M240 set it HIGH)
     if (chdk_active && ELAPSED(ms, chdk_timeout)) {
       chdk_active = false;
       WRITE(CHDK_PIN, LOW);
     }
   #endif
 
   #if HAS_KILL
@@ -509,20 +521,24 @@ void manage_inactivity(const bool ignore_stepper_queue/*=false*/) {
   #endif
 
   #if ENABLED(TEMP_STAT_LEDS)
     handle_status_leds();
   #endif
 
   #if ENABLED(MONITOR_DRIVER_STATUS)
     monitor_tmc_driver();
   #endif
 
+  #if ENABLED(MONITOR_L6470_DRIVER_STATUS)
+    L6470.monitor_driver();
+  #endif
+
   // Limit check_axes_activity frequency to 10Hz
   static millis_t next_check_axes_ms = 0;
   if (ELAPSED(ms, next_check_axes_ms)) {
     planner.check_axes_activity();
     next_check_axes_ms = ms + 100UL;
   }
 }
 
 /**
  * Standard idle routine keeps the machine alive
@@ -673,20 +689,24 @@ void stop() {
  *    • Digipot I2C
  *    • Z probe sled
  *    • status LEDs
  */
 void setup() {
 
   #ifdef HAL_INIT
     HAL_init();
   #endif
 
+  #if HAS_DRIVER(L6470)
+    L6470.init();         // setup SPI and then init chips
+  #endif
+
   #if ENABLED(MAX7219_DEBUG)
     max7219.init();
   #endif
 
   #if ENABLED(DISABLE_DEBUG)
     // Disable any hardware debug to free up pins for IO
     #ifdef JTAGSWD_DISABLE
       JTAGSWD_DISABLE();
     #elif defined(JTAG_DISABLE)
       JTAG_DISABLE();

commit 7bb5d4bfe85ce05563d6620714949fe6821e0b76
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Thu Jan 17 20:20:26 2019 +0100

    Small LED code reorganization (#12929)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index bf98f8527c..8a5ac05e8c 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -853,30 +853,24 @@ void setup() {
   #endif
 
   #if PIN_EXISTS(STAT_LED_BLUE)
     OUT_WRITE(STAT_LED_BLUE_PIN, LOW); // OFF
   #endif
 
   #if HAS_COLOR_LEDS
     leds.setup();
   #endif
 
-  #if ENABLED(RGB_LED) || ENABLED(RGBW_LED)
-    SET_OUTPUT(RGB_LED_R_PIN);
-    SET_OUTPUT(RGB_LED_G_PIN);
-    SET_OUTPUT(RGB_LED_B_PIN);
-    #if ENABLED(RGBW_LED)
-      SET_OUTPUT(RGB_LED_W_PIN);
-    #endif
-  #endif
-
   #if HAS_CASE_LIGHT
+    #if DISABLED(CASE_LIGHT_USE_NEOPIXEL)
+      SET_OUTPUT(CASE_LIGHT_PIN);
+    #endif
     update_case_light();
   #endif
 
   #if ENABLED(MK2_MULTIPLEXER)
     SET_OUTPUT(E_MUX0_PIN);
     SET_OUTPUT(E_MUX1_PIN);
     SET_OUTPUT(E_MUX2_PIN);
   #endif
 
   #if HAS_FANMUX

commit 8f4c6e6d1a271cc0d1d310243941f4b6ce1cc863
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Wed Jan 16 01:50:56 2019 +0100

    Fix case light on boot (#12919)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 72e59c3e45..bf98f8527c 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -802,24 +802,20 @@ void setup() {
   #endif
 
   #if HAS_Z_SERVO_PROBE
     servo_probe_init();
   #endif
 
   #if HAS_PHOTOGRAPH
     OUT_WRITE(PHOTOGRAPH_PIN, LOW);
   #endif
 
-  #if HAS_CASE_LIGHT
-    update_case_light();
-  #endif
-
   #if ENABLED(SPINDLE_LASER_ENABLE)
     OUT_WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);  // init spindle to off
     #if SPINDLE_DIR_CHANGE
       OUT_WRITE(SPINDLE_DIR_PIN, SPINDLE_INVERT_DIR ? 255 : 0);  // init rotation to clockwise (M3)
     #endif
     #if ENABLED(SPINDLE_LASER_PWM) && defined(SPINDLE_LASER_PWM_PIN) && SPINDLE_LASER_PWM_PIN >= 0
       SET_OUTPUT(SPINDLE_LASER_PWM_PIN);
       analogWrite(SPINDLE_LASER_PWM_PIN, SPINDLE_LASER_PWM_INVERT ? 255 : 0);  // set to lowest speed
     #endif
   #endif
@@ -866,20 +862,24 @@ void setup() {
 
   #if ENABLED(RGB_LED) || ENABLED(RGBW_LED)
     SET_OUTPUT(RGB_LED_R_PIN);
     SET_OUTPUT(RGB_LED_G_PIN);
     SET_OUTPUT(RGB_LED_B_PIN);
     #if ENABLED(RGBW_LED)
       SET_OUTPUT(RGB_LED_W_PIN);
     #endif
   #endif
 
+  #if HAS_CASE_LIGHT
+    update_case_light();
+  #endif
+
   #if ENABLED(MK2_MULTIPLEXER)
     SET_OUTPUT(E_MUX0_PIN);
     SET_OUTPUT(E_MUX1_PIN);
     SET_OUTPUT(E_MUX2_PIN);
   #endif
 
   #if HAS_FANMUX
     fanmux_init();
   #endif
 

commit 082f6a27dece8d1883751d3f2af1c2b0f0b6802c
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sat Jan 12 01:41:48 2019 -0500

    ADAPTIVE_FAN_SLOWING extension to hotend thermal protection (#12853)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 4792f24380..72e59c3e45 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -157,31 +157,20 @@
 #if ENABLED(EXTENSIBLE_UI)
   #include "lcd/extensible_ui/ui_api.h"
 #endif
 
 bool Running = true;
 
 #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
   TempUnit input_temp_units = TEMPUNIT_C;
 #endif
 
-#if FAN_COUNT > 0
-  uint8_t fan_speed[FAN_COUNT] = { 0 };
-  #if ENABLED(EXTRA_FAN_SPEED)
-    uint8_t old_fan_speed[FAN_COUNT], new_fan_speed[FAN_COUNT];
-  #endif
-  #if ENABLED(PROBING_FANS_OFF)
-    bool fans_paused; // = false;
-    uint8_t paused_fan_speed[FAN_COUNT] = { 0 };
-  #endif
-#endif
-
 // For M109 and M190, this flag may be cleared (by M108) to exit the wait loop
 volatile bool wait_for_heatup = true;
 
 // For M0/M1, this flag may be cleared (by M108) to exit the wait-for-user loop
 #if HAS_RESUME_CONTINUE
   volatile bool wait_for_user; // = false;
 #endif
 
 #if HAS_AUTO_REPORTING || ENABLED(HOST_KEEPALIVE_FEATURE)
   bool suspend_auto_report; // = false
@@ -648,21 +637,21 @@ void minkill() {
 
 /**
  * Turn off heaters and stop the print in progress
  * After a stop the machine may be resumed with M999
  */
 void stop() {
   thermalManager.disable_all_heaters(); // 'unpause' taken care of in here
   print_job_timer.stop();
 
   #if ENABLED(PROBING_FANS_OFF)
-    if (fans_paused) fans_pause(false); // put things back the way they were
+    if (thermalManager.fans_paused) thermalManager.set_fans_paused(false); // put things back the way they were
   #endif
 
   if (IsRunning()) {
     Stopped_gcode_LastN = gcode_LastN; // Save last g_code for restart
     SERIAL_ERROR_MSG(MSG_ERR_STOPPED);
     LCD_MESSAGEPGM(MSG_STOPPED);
     safe_delay(350);       // allow enough time for messages to get out before stopping
     Running = false;
   }
 }
@@ -969,21 +958,21 @@ void loop() {
       if (card.flag.abort_sd_printing) {
         card.stopSDPrint(
           #if SD_RESORT
             true
           #endif
         );
         clear_command_queue();
         quickstop_stepper();
         print_job_timer.stop();
         thermalManager.disable_all_heaters();
-        zero_fan_speeds();
+        thermalManager.zero_fan_speeds();
         wait_for_heatup = false;
         #if ENABLED(POWER_LOSS_RECOVERY)
           card.removeJobRecoveryFile();
         #endif
       }
     #endif // SDSUPPORT
 
     if (commands_in_queue < BUFSIZE) get_available_commands();
     advance_command_queue();
     endstops.event_handler();

commit 55144284c2578dccca7a6a5fa472a3d927ff09f2
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Mon Dec 10 04:54:48 2018 +0200

    TMC connection test, spreadCycle parameters, improved debugging (#12616)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 290cb06425..4792f24380 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -938,20 +938,24 @@ void setup() {
     watchdog_init();          // Reinit watchdog after HAL_get_reset_source call
   #endif
 
   #if ENABLED(EXTERNAL_CLOSED_LOOP_CONTROLLER)
     init_closedloop();
   #endif
 
   #if ENABLED(SDSUPPORT) && DISABLED(ULTRA_LCD)
     card.beginautostart();
   #endif
+
+  #if HAS_TRINAMIC && DISABLED(PS_DEFAULT_OFF)
+    test_tmc_connection(true, true, true, true);
+  #endif
 }
 
 /**
  * The main Marlin program loop
  *
  *  - Save or log commands to SD
  *  - Process available commands (if not saving)
  *  - Call endstop manager
  *  - Call inactivity manager
  */

commit c98623983774b9773800bc7dcef695c4bad81c0e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Nov 29 16:58:58 2018 -0600

    A single SERIAL_ECHO macro type (#12557)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 50957517b5..290cb06425 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -257,22 +257,21 @@ bool pin_is_protected(const pin_t pin) {
   static const pin_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++) {
     pin_t sensitive_pin;
     memcpy_P(&sensitive_pin, &sensitive_pins[i], sizeof(pin_t));
     if (pin == sensitive_pin) return true;
   }
   return false;
 }
 
 void protected_pin_err() {
-  SERIAL_ERROR_START();
-  SERIAL_ERRORLNPGM(MSG_ERR_PROTECTED_PIN);
+  SERIAL_ERROR_MSG(MSG_ERR_PROTECTED_PIN);
 }
 
 void quickstop_stepper() {
   planner.quick_stop();
   planner.synchronize();
   set_current_from_steppers_for_axis(ALL_AXES);
   sync_plan_position();
 }
 
 void enable_all_steppers() {
@@ -393,22 +392,21 @@ void manage_inactivity(const bool ignore_stepper_queue/*=false*/) {
     const int KILL_DELAY = 750;
     if (!READ(KILL_PIN))
       killCount++;
     else if (killCount > 0)
       killCount--;
 
     // Exceeded threshold and we can confirm that it was not accidental
     // KILL the machine
     // ----------------------------------------------------------------
     if (killCount >= KILL_DELAY) {
-      SERIAL_ERROR_START();
-      SERIAL_ERRORLNPGM(MSG_KILL_BUTTON);
+      SERIAL_ERROR_MSG(MSG_KILL_BUTTON);
       kill();
     }
   #endif
 
   #if HAS_HOME
     // Check to see if we have to home, use poor man's debouncer
     // ---------------------------------------------------------
     static int homeDebounceCount = 0;   // poor man's debouncing count
     const int HOME_DEBOUNCE_DELAY = 2500;
     if (!IS_SD_PRINTING() && !READ(HOME_PIN)) {
@@ -599,22 +597,21 @@ void idle(
   #endif
 }
 
 /**
  * Kill all activity and lock the machine.
  * After this the machine will need to be reset.
  */
 void kill(PGM_P const lcd_msg/*=NULL*/) {
   thermalManager.disable_all_heaters();
 
-  SERIAL_ERROR_START();
-  SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
+  SERIAL_ERROR_MSG(MSG_ERR_KILLED);
 
   #if HAS_SPI_LCD || ENABLED(EXTENSIBLE_UI)
     ui.kill_screen(lcd_msg ? lcd_msg : PSTR(MSG_KILLED));
   #else
     UNUSED(lcd_msg);
   #endif
 
   #ifdef ACTION_ON_KILL
     SERIAL_ECHOLNPGM("//action:" ACTION_ON_KILL);
   #endif
@@ -656,22 +653,21 @@ void minkill() {
 void stop() {
   thermalManager.disable_all_heaters(); // 'unpause' taken care of in here
   print_job_timer.stop();
 
   #if ENABLED(PROBING_FANS_OFF)
     if (fans_paused) fans_pause(false); // put things back the way they were
   #endif
 
   if (IsRunning()) {
     Stopped_gcode_LastN = gcode_LastN; // Save last g_code for restart
-    SERIAL_ERROR_START();
-    SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
+    SERIAL_ERROR_MSG(MSG_ERR_STOPPED);
     LCD_MESSAGEPGM(MSG_STOPPED);
     safe_delay(350);       // allow enough time for messages to get out before stopping
     Running = false;
   }
 }
 
 /**
  * Marlin entry-point: Set up before the program loop
  *  - Set up the kill pin, filament runout, power hold
  *  - Start the serial port
@@ -738,21 +734,21 @@ void setup() {
 
   #if NUM_SERIAL > 0
     uint32_t serial_connect_timeout = millis() + 1000UL;
     while (!MYSERIAL0 && PENDING(millis(), serial_connect_timeout)) { /*nada*/ }
     #if NUM_SERIAL > 1
       serial_connect_timeout = millis() + 1000UL;
       while (!MYSERIAL1 && PENDING(millis(), serial_connect_timeout)) { /*nada*/ }
     #endif
   #endif
 
-  SERIAL_PROTOCOLLNPGM("start");
+  SERIAL_ECHOLNPGM("start");
   SERIAL_ECHO_START();
 
   #if TMC_HAS_SPI
     #if DISABLED(TMC_USE_SW_SPI)
       SPI.begin();
     #endif
     tmc_init_cs_pins();
   #endif
   #if HAS_DRIVER(TMC2208)
     tmc2208_serial_begin();
@@ -774,22 +770,21 @@ void setup() {
   SERIAL_ECHOPGM(MSG_MARLIN);
   SERIAL_CHAR(' ');
   SERIAL_ECHOLNPGM(SHORT_BUILD_VERSION);
   SERIAL_EOL();
 
   #if defined(STRING_DISTRIBUTION_DATE) && defined(STRING_CONFIG_H_AUTHOR)
     SERIAL_ECHO_START();
     SERIAL_ECHOPGM(MSG_CONFIGURATION_VER);
     SERIAL_ECHOPGM(STRING_DISTRIBUTION_DATE);
     SERIAL_ECHOLNPGM(MSG_AUTHOR STRING_CONFIG_H_AUTHOR);
-    SERIAL_ECHO_START();
-    SERIAL_ECHOLNPGM("Compiled: " __DATE__);
+    SERIAL_ECHO_MSG("Compiled: " __DATE__);
   #endif
 
   SERIAL_ECHO_START();
   SERIAL_ECHOPAIR(MSG_FREE_MEMORY, freeMemory());
   SERIAL_ECHOLNPAIR(MSG_PLANNER_BUFFER_BYTES, (int)sizeof(block_t)*BLOCK_BUFFER_SIZE);
 
   queue_setup();
 
   // Load data from EEPROM if available (or use defaults)
   // This also updates variables in the planner, elsewhere

commit 66580f32c2f4d39a82b77e4b6982e7ea6dde0766
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Nov 16 22:39:16 2018 -0600

    Make CardReader class static (#12451)
    
    * Make CardReader a static class
    * Make CardReader flags into bitfields

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index f2522f2ee9..50957517b5 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -960,21 +960,21 @@ void setup() {
  *  - Call endstop manager
  *  - Call inactivity manager
  */
 void loop() {
 
   for (;;) {
 
     #if ENABLED(SDSUPPORT)
       card.checkautostart();
 
-      if (card.abort_sd_printing) {
+      if (card.flag.abort_sd_printing) {
         card.stopSDPrint(
           #if SD_RESORT
             true
           #endif
         );
         clear_command_queue();
         quickstop_stepper();
         print_job_timer.stop();
         thermalManager.disable_all_heaters();
         zero_fan_speeds();

commit d97e31db4c2b8b27ab1c6fbbe05f11aa9d5e94e2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Nov 16 20:47:07 2018 -0600

    Optimize Power-Loss Recovery (#12440)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 3d77548ee2..f2522f2ee9 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -917,37 +917,37 @@ void setup() {
   #if ENABLED(I2C_POSITION_ENCODERS)
     I2CPEM.init();
   #endif
 
   #if ENABLED(EXPERIMENTAL_I2CBUS) && I2C_SLAVE_ADDRESS > 0
     i2c.onReceive(i2c_on_receive);
     i2c.onRequest(i2c_on_request);
   #endif
 
   #if DO_SWITCH_EXTRUDER
-    move_extruder_servo(0);  // Initialize extruder servo
+    move_extruder_servo(0);   // Initialize extruder servo
   #endif
 
   #if ENABLED(SWITCHING_NOZZLE)
-    move_nozzle_servo(0);  // Initialize nozzle servo
+    move_nozzle_servo(0);     // Initialize nozzle servo
   #endif
 
   #if ENABLED(PARKING_EXTRUDER)
     pe_magnet_init();
   #endif
 
   #if ENABLED(POWER_LOSS_RECOVERY)
-    check_print_job_recovery();
+    recovery.check();
   #endif
 
-  #if ENABLED(USE_WATCHDOG) // Reinit watchdog after HAL_get_reset_source call
-    watchdog_init();
+  #if ENABLED(USE_WATCHDOG)
+    watchdog_init();          // Reinit watchdog after HAL_get_reset_source call
   #endif
 
   #if ENABLED(EXTERNAL_CLOSED_LOOP_CONTROLLER)
     init_closedloop();
   #endif
 
   #if ENABLED(SDSUPPORT) && DISABLED(ULTRA_LCD)
     card.beginautostart();
   #endif
 }

commit a0c795b097a30eff006c8dff178abf5f1f1907fa
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Nov 11 12:16:24 2018 -0600

    Encapsulate common display code in a singleton (#12395)
    
    * Encapsulate common LCD code in a singleton
    * Depend more UBL code on UBL_DEVEL_DEBUGGING
      - Since most users don't need the debugging on at all times, this helps reduce the default build size for UBL by over 2K, a little closer to fitting on 128K boards.

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 944c5ec96f..3d77548ee2 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -364,21 +364,21 @@ void manage_inactivity(const bool ignore_stepper_queue/*=false*/) {
       #endif
       #if ENABLED(DISABLE_INACTIVE_Z)
         disable_Z();
       #endif
       #if ENABLED(DISABLE_INACTIVE_E)
         disable_e_steppers();
       #endif
       #if HAS_LCD_MENU && ENABLED(AUTO_BED_LEVELING_UBL)
         if (ubl.lcd_map_control) {
           ubl.lcd_map_control = false;
-          set_defer_return_to_status(false);
+          ui.defer_status_screen(false);
         }
       #endif
     }
   }
 
   #if PIN_EXISTS(CHDK) // Check if pin should be set to LOW (after M240 set it HIGH)
     if (chdk_active && ELAPSED(ms, chdk_timeout)) {
       chdk_active = false;
       WRITE(CHDK_PIN, LOW);
     }
@@ -542,21 +542,21 @@ void manage_inactivity(const bool ignore_stepper_queue/*=false*/) {
  */
 void idle(
   #if ENABLED(ADVANCED_PAUSE_FEATURE)
     bool no_stepper_sleep/*=false*/
   #endif
 ) {
   #if ENABLED(MAX7219_DEBUG)
     max7219.idle_tasks();
   #endif
 
-  lcd_update();
+  ui.update();
 
   #if ENABLED(HOST_KEEPALIVE_FEATURE)
     gcode.host_keepalive();
   #endif
 
   manage_inactivity(
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
       no_stepper_sleep
     #endif
   );
@@ -602,22 +602,22 @@ void idle(
 /**
  * Kill all activity and lock the machine.
  * After this the machine will need to be reset.
  */
 void kill(PGM_P const lcd_msg/*=NULL*/) {
   thermalManager.disable_all_heaters();
 
   SERIAL_ERROR_START();
   SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
 
-  #if ENABLED(ULTRA_LCD) || ENABLED(EXTENSIBLE_UI)
-    kill_screen(lcd_msg ? lcd_msg : PSTR(MSG_KILLED));
+  #if HAS_SPI_LCD || ENABLED(EXTENSIBLE_UI)
+    ui.kill_screen(lcd_msg ? lcd_msg : PSTR(MSG_KILLED));
   #else
     UNUSED(lcd_msg);
   #endif
 
   #ifdef ACTION_ON_KILL
     SERIAL_ECHOLNPGM("//action:" ACTION_ON_KILL);
   #endif
 
   minkill();
 }
@@ -892,25 +892,25 @@ void setup() {
   #if ENABLED(MK2_MULTIPLEXER)
     SET_OUTPUT(E_MUX0_PIN);
     SET_OUTPUT(E_MUX1_PIN);
     SET_OUTPUT(E_MUX2_PIN);
   #endif
 
   #if HAS_FANMUX
     fanmux_init();
   #endif
 
-  lcd_init();
-  lcd_reset_status();
+  ui.init();
+  ui.reset_status();
 
   #if ENABLED(SHOW_BOOTSCREEN)
-    lcd_bootscreen();
+    ui.show_bootscreen();
   #endif
 
   #if ENABLED(MIXING_EXTRUDER)
     mixer.init();
   #endif
 
   #if ENABLED(BLTOUCH)
     bltouch_init();
   #endif
 

commit e574f015680f88137b2ccb0fa159ebd5749c26fb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Nov 6 19:25:57 2018 -0600

    More advanced pause tweaks (#12356)
    
    * Followup to LCD_TIMEOUT_TO_STATUS=0
    * Make continuous purge screen fit 20x4
    * Unify purge message modes
    * Preserve last-set pause header mode

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 0bb089eda1..944c5ec96f 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -362,21 +362,24 @@ void manage_inactivity(const bool ignore_stepper_queue/*=false*/) {
       #if ENABLED(DISABLE_INACTIVE_Y)
         disable_Y();
       #endif
       #if ENABLED(DISABLE_INACTIVE_Z)
         disable_Z();
       #endif
       #if ENABLED(DISABLE_INACTIVE_E)
         disable_e_steppers();
       #endif
       #if HAS_LCD_MENU && ENABLED(AUTO_BED_LEVELING_UBL)
-        if (ubl.lcd_map_control) ubl.lcd_map_control = defer_return_to_status = false;
+        if (ubl.lcd_map_control) {
+          ubl.lcd_map_control = false;
+          set_defer_return_to_status(false);
+        }
       #endif
     }
   }
 
   #if PIN_EXISTS(CHDK) // Check if pin should be set to LOW (after M240 set it HIGH)
     if (chdk_active && ELAPSED(ms, chdk_timeout)) {
       chdk_active = false;
       WRITE(CHDK_PIN, LOW);
     }
   #endif

commit 498dfa291e3e75a9c47fdc2e9fcfe3b0fdea5bc7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Nov 5 01:08:40 2018 -0600

    Update and fix CHDK

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 25d437e8ee..0bb089eda1 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -184,23 +184,23 @@ volatile bool wait_for_heatup = true;
 #endif
 
 #if HAS_AUTO_REPORTING || ENABLED(HOST_KEEPALIVE_FEATURE)
   bool suspend_auto_report; // = false
 #endif
 
 // Inactivity shutdown
 millis_t max_inactive_time, // = 0
          stepper_inactive_time = (DEFAULT_STEPPER_DEACTIVE_TIME) * 1000UL;
 
-#ifdef CHDK
-  millis_t chdkHigh; // = 0;
-  bool chdkActive; // = false;
+#if PIN_EXISTS(CHDK)
+  extern bool chdk_active;
+  extern millis_t chdk_timeout;
 #endif
 
 #if ENABLED(I2C_POSITION_ENCODERS)
   I2CPositionEncodersMgr I2CPEM;
 #endif
 
 /**
  * ***************************************************************************
  * ******************************** FUNCTIONS ********************************
  * ***************************************************************************
@@ -316,21 +316,21 @@ void disable_all_steppers() {
   disable_Z();
   disable_e_steppers();
 }
 
 /**
  * Manage several activities:
  *  - Check for Filament Runout
  *  - Keep the command buffer full
  *  - Check for maximum inactive time between commands
  *  - Check for maximum inactive time between stepper commands
- *  - Check if pin CHDK needs to go LOW
+ *  - Check if CHDK_PIN needs to go LOW
  *  - Check for KILL button held down
  *  - Check for HOME button held down
  *  - Check if cooling fan needs to be switched on
  *  - Check if an idle but hot extruder needs filament extruded (EXTRUDER_RUNOUT_PREVENT)
  */
 void manage_inactivity(const bool ignore_stepper_queue/*=false*/) {
 
   #if ENABLED(FILAMENT_RUNOUT_SENSOR)
     runout.run();
   #endif
@@ -367,24 +367,24 @@ void manage_inactivity(const bool ignore_stepper_queue/*=false*/) {
       #endif
       #if ENABLED(DISABLE_INACTIVE_E)
         disable_e_steppers();
       #endif
       #if HAS_LCD_MENU && ENABLED(AUTO_BED_LEVELING_UBL)
         if (ubl.lcd_map_control) ubl.lcd_map_control = defer_return_to_status = false;
       #endif
     }
   }
 
-  #ifdef CHDK // Check if pin should be set to LOW after M240 set it to HIGH
-    if (chdkActive && ELAPSED(ms, chdkHigh + CHDK_DELAY)) {
-      chdkActive = false;
-      WRITE(CHDK, LOW);
+  #if PIN_EXISTS(CHDK) // Check if pin should be set to LOW (after M240 set it HIGH)
+    if (chdk_active && ELAPSED(ms, chdk_timeout)) {
+      chdk_active = false;
+      WRITE(CHDK_PIN, LOW);
     }
   #endif
 
   #if HAS_KILL
 
     // Check if the kill button was pressed and wait just in case it was an accidental
     // key kill key press
     // -------------------------------------------------------------------------------
     static int killCount = 0;   // make the inactivity button a bit less responsive
     const int KILL_DELAY = 750;

commit 44f2a82a567333312c3d85f72176f437bafc9625
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Oct 31 17:07:52 2018 -0500

    Move axis_homed, axis_known_position to motion.*

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 4c6b3a0b9c..25d437e8ee 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -153,31 +153,20 @@
 #if ENABLED(USE_CONTROLLER_FAN)
   #include "feature/controllerfan.h"
 #endif
 
 #if ENABLED(EXTENSIBLE_UI)
   #include "lcd/extensible_ui/ui_api.h"
 #endif
 
 bool Running = true;
 
-/**
- * axis_homed
- *   Flags that each linear axis was homed.
- *   XYZ on cartesian, ABC on delta, ABZ on SCARA.
- *
- * axis_known_position
- *   Flags that the position is known in each linear axis. Set when homed.
- *   Cleared whenever a stepper powers off, potentially losing its position.
- */
-uint8_t axis_homed, axis_known_position; // = 0
-
 #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
   TempUnit input_temp_units = TEMPUNIT_C;
 #endif
 
 #if FAN_COUNT > 0
   uint8_t fan_speed[FAN_COUNT] = { 0 };
   #if ENABLED(EXTRA_FAN_SPEED)
     uint8_t old_fan_speed[FAN_COUNT], new_fan_speed[FAN_COUNT];
   #endif
   #if ENABLED(PROBING_FANS_OFF)

commit 3583e2b4490e8fd6778d18003641c2fdd333e8a5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Oct 30 16:34:45 2018 -0500

    Followup to Menu Refactor (#12275)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index faf4e6f204..4c6b3a0b9c 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -372,21 +372,21 @@ void manage_inactivity(const bool ignore_stepper_queue/*=false*/) {
       #endif
       #if ENABLED(DISABLE_INACTIVE_Y)
         disable_Y();
       #endif
       #if ENABLED(DISABLE_INACTIVE_Z)
         disable_Z();
       #endif
       #if ENABLED(DISABLE_INACTIVE_E)
         disable_e_steppers();
       #endif
-      #if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(ULTIPANEL)  // Only needed with an LCD
+      #if HAS_LCD_MENU && ENABLED(AUTO_BED_LEVELING_UBL)
         if (ubl.lcd_map_control) ubl.lcd_map_control = defer_return_to_status = false;
       #endif
     }
   }
 
   #ifdef CHDK // Check if pin should be set to LOW after M240 set it to HIGH
     if (chdkActive && ELAPSED(ms, chdkHigh + CHDK_DELAY)) {
       chdkActive = false;
       WRITE(CHDK, LOW);
     }

commit fc31da1114e219cfd573f17d0abb5ffee4e3d244
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Mon Oct 22 18:37:48 2018 -0600

    Implement custom delay/millis for EXTENSIBLE_UI (#12188)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 3c85b7308c..faf4e6f204 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -610,23 +610,21 @@ void idle(
 /**
  * Kill all activity and lock the machine.
  * After this the machine will need to be reset.
  */
 void kill(PGM_P const lcd_msg/*=NULL*/) {
   thermalManager.disable_all_heaters();
 
   SERIAL_ERROR_START();
   SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
 
-  #if ENABLED(EXTENSIBLE_UI)
-    UI::onPrinterKilled(lcd_msg ? lcd_msg : PSTR(MSG_KILLED));
-  #elif ENABLED(ULTRA_LCD)
+  #if ENABLED(ULTRA_LCD) || ENABLED(EXTENSIBLE_UI)
     kill_screen(lcd_msg ? lcd_msg : PSTR(MSG_KILLED));
   #else
     UNUSED(lcd_msg);
   #endif
 
   #ifdef ACTION_ON_KILL
     SERIAL_ECHOLNPGM("//action:" ACTION_ON_KILL);
   #endif
 
   minkill();

commit e5ae7a07d17c0c9e5063bbc73599c278e1bd1674
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Oct 21 13:43:21 2018 -0500

    Suppress compiler warning

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 14cd627027..3c85b7308c 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -628,26 +628,26 @@ void kill(PGM_P const lcd_msg/*=NULL*/) {
   #ifdef ACTION_ON_KILL
     SERIAL_ECHOLNPGM("//action:" ACTION_ON_KILL);
   #endif
 
   minkill();
 }
 
 void minkill() {
 
   // Wait a short time (allows messages to get out before shutting down.
-  for (uint8_t i = 100; i--;) DELAY_US(6000);
+  for (int i = 1000; i--;) DELAY_US(600);
 
   cli(); // Stop interrupts
 
   // Wait to ensure all interrupts stopped
-  for (uint8_t i = 100; i--;) DELAY_US(2500);
+  for (int i = 1000; i--;) DELAY_US(250);
 
   thermalManager.disable_all_heaters(); // turn off heaters again
 
   #if HAS_POWER_SWITCH
     PSU_OFF();
   #endif
 
   #if HAS_SUICIDE
     suicide();
   #endif

commit 9969c06cb578ee7fb96fcd2344c795fb3a72c773
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Oct 20 16:50:47 2018 -0500

    Fix compiler warning

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 065bba596b..14cd627027 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -628,26 +628,26 @@ void kill(PGM_P const lcd_msg/*=NULL*/) {
   #ifdef ACTION_ON_KILL
     SERIAL_ECHOLNPGM("//action:" ACTION_ON_KILL);
   #endif
 
   minkill();
 }
 
 void minkill() {
 
   // Wait a short time (allows messages to get out before shutting down.
-  DELAY_US(600000);
+  for (uint8_t i = 100; i--;) DELAY_US(6000);
 
   cli(); // Stop interrupts
 
   // Wait to ensure all interrupts stopped
-  DELAY_US(250000);
+  for (uint8_t i = 100; i--;) DELAY_US(2500);
 
   thermalManager.disable_all_heaters(); // turn off heaters again
 
   #if HAS_POWER_SWITCH
     PSU_OFF();
   #endif
 
   #if HAS_SUICIDE
     suicide();
   #endif

commit 2e5e689a7f33ce76718d4220045135a782828426
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Sat Oct 20 00:44:46 2018 -0600

    Fix kill() and ExtensibleUI (#12160)
    
    * Fix to isPrintingFromMedia()
    
      - isPrintingFromMedia() will now return true even if SD print is paused.
      - isPrintingFromMediaPaused() allows UI to determine if the print is paused.
    
    * Don't use _delay_us in minkill (#12145)
    
      - In HAL_DUE, _delay_us is simply an alias for delay, which causes the board to hang and subsequently reboot due to the watchdog timer.
    
    * Shorten code with IFSD macro

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 560ba4ba72..065bba596b 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -35,20 +35,22 @@
 #include "module/planner.h"
 #include "module/stepper.h"
 #include "module/endstops.h"
 #include "module/probe.h"
 #include "module/temperature.h"
 #include "sd/cardreader.h"
 #include "module/configuration_store.h"
 #include "module/printcounter.h" // PrintCounter or Stopwatch
 #include "feature/closedloop.h"
 
+#include "HAL/shared/Delay.h"
+
 #ifdef ARDUINO
   #include <pins_arduino.h>
 #endif
 #include <math.h>
 #include "libs/nozzle.h"
 
 #include "gcode/gcode.h"
 #include "gcode/parser.h"
 #include "gcode/queue.h"
 
@@ -603,21 +605,20 @@ void idle(
   #if ENABLED(USB_FLASH_DRIVE_SUPPORT)
     Sd2Card::idle();
   #endif
 }
 
 /**
  * Kill all activity and lock the machine.
  * After this the machine will need to be reset.
  */
 void kill(PGM_P const lcd_msg/*=NULL*/) {
-
   thermalManager.disable_all_heaters();
 
   SERIAL_ERROR_START();
   SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
 
   #if ENABLED(EXTENSIBLE_UI)
     UI::onPrinterKilled(lcd_msg ? lcd_msg : PSTR(MSG_KILLED));
   #elif ENABLED(ULTRA_LCD)
     kill_screen(lcd_msg ? lcd_msg : PSTR(MSG_KILLED));
   #else
@@ -626,25 +627,28 @@ void kill(PGM_P const lcd_msg/*=NULL*/) {
 
   #ifdef ACTION_ON_KILL
     SERIAL_ECHOLNPGM("//action:" ACTION_ON_KILL);
   #endif
 
   minkill();
 }
 
 void minkill() {
 
-  _delay_ms(600);  // Wait a short time (allows messages to get out before shutting down.
-  cli();           // Stop interrupts
-  _delay_ms(250);  // Wait to ensure all interrupts stopped
+  // Wait a short time (allows messages to get out before shutting down.
+  DELAY_US(600000);
+
+  cli(); // Stop interrupts
+
+  // Wait to ensure all interrupts stopped
+  DELAY_US(250000);
 
-  disable_all_steppers();
   thermalManager.disable_all_heaters(); // turn off heaters again
 
   #if HAS_POWER_SWITCH
     PSU_OFF();
   #endif
 
   #if HAS_SUICIDE
     suicide();
   #endif
 

commit b381cad39994fbae79351d1e87368cb98fbe1a8d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 19 15:27:07 2018 -0500

    Clean up trailing whitespace

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 4abdf4f9a2..560ba4ba72 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -965,21 +965,21 @@ void setup() {
  *  - Process available commands (if not saving)
  *  - Call endstop manager
  *  - Call inactivity manager
  */
 void loop() {
 
   for (;;) {
 
     #if ENABLED(SDSUPPORT)
       card.checkautostart();
-    
+
       if (card.abort_sd_printing) {
         card.stopSDPrint(
           #if SD_RESORT
             true
           #endif
         );
         clear_command_queue();
         quickstop_stepper();
         print_job_timer.stop();
         thermalManager.disable_all_heaters();

commit 1fb9b299d4d96276ff1fb6cd2ee5e73e753e2b23
Author: TheSFReader <TheSFReader@gmail.com>
Date:   Fri Oct 19 21:25:07 2018 +0200

    Add M524 to abort SD printing (#12155)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index cc755d4cf0..4abdf4f9a2 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -965,38 +965,35 @@ void setup() {
  *  - Process available commands (if not saving)
  *  - Call endstop manager
  *  - Call inactivity manager
  */
 void loop() {
 
   for (;;) {
 
     #if ENABLED(SDSUPPORT)
       card.checkautostart();
-    #endif
-
-    #if ENABLED(SDSUPPORT) && (ENABLED(ULTIPANEL) || ENABLED(EXTENSIBLE_UI))
-      if (abort_sd_printing) {
-        abort_sd_printing = false;
+    
+      if (card.abort_sd_printing) {
         card.stopSDPrint(
           #if SD_RESORT
             true
           #endif
         );
         clear_command_queue();
         quickstop_stepper();
         print_job_timer.stop();
         thermalManager.disable_all_heaters();
         zero_fan_speeds();
         wait_for_heatup = false;
         #if ENABLED(POWER_LOSS_RECOVERY)
           card.removeJobRecoveryFile();
         #endif
       }
-    #endif // SDSUPPORT && (ENABLED(ULTIPANEL) || ENABLED(EXTENSIBLE_UI))
+    #endif // SDSUPPORT
 
     if (commands_in_queue < BUFSIZE) get_available_commands();
     advance_command_queue();
     endstops.event_handler();
     idle();
   }
 }

commit c6a5c7420895bbb32ac3c70f0382ed5622c3746e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 19 13:52:44 2018 -0500

    Add parentheses to SD macros

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 6560853405..cc755d4cf0 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -410,21 +410,21 @@ void manage_inactivity(const bool ignore_stepper_queue/*=false*/) {
       SERIAL_ERRORLNPGM(MSG_KILL_BUTTON);
       kill();
     }
   #endif
 
   #if HAS_HOME
     // Check to see if we have to home, use poor man's debouncer
     // ---------------------------------------------------------
     static int homeDebounceCount = 0;   // poor man's debouncing count
     const int HOME_DEBOUNCE_DELAY = 2500;
-    if (!IS_SD_PRINTING && !READ(HOME_PIN)) {
+    if (!IS_SD_PRINTING() && !READ(HOME_PIN)) {
       if (!homeDebounceCount) {
         enqueue_and_echo_commands_P(PSTR("G28"));
         LCD_MESSAGEPGM(MSG_AUTO_HOME);
       }
       if (homeDebounceCount < HOME_DEBOUNCE_DELAY)
         homeDebounceCount++;
       else
         homeDebounceCount = 0;
     }
   #endif

commit 8c02dd971bfd8f51e39a0acc9a7c7cf7e8fc71ec
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 19 13:42:04 2018 -0500

    Move disable_all_steppers to minkill

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 5e6c9792c6..6560853405 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -605,21 +605,20 @@ void idle(
   #endif
 }
 
 /**
  * Kill all activity and lock the machine.
  * After this the machine will need to be reset.
  */
 void kill(PGM_P const lcd_msg/*=NULL*/) {
 
   thermalManager.disable_all_heaters();
-  disable_all_steppers();
 
   SERIAL_ERROR_START();
   SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
 
   #if ENABLED(EXTENSIBLE_UI)
     UI::onPrinterKilled(lcd_msg ? lcd_msg : PSTR(MSG_KILLED));
   #elif ENABLED(ULTRA_LCD)
     kill_screen(lcd_msg ? lcd_msg : PSTR(MSG_KILLED));
   #else
     UNUSED(lcd_msg);
@@ -631,20 +630,21 @@ void kill(PGM_P const lcd_msg/*=NULL*/) {
 
   minkill();
 }
 
 void minkill() {
 
   _delay_ms(600);  // Wait a short time (allows messages to get out before shutting down.
   cli();           // Stop interrupts
   _delay_ms(250);  // Wait to ensure all interrupts stopped
 
+  disable_all_steppers();
   thermalManager.disable_all_heaters(); // turn off heaters again
 
   #if HAS_POWER_SWITCH
     PSU_OFF();
   #endif
 
   #if HAS_SUICIDE
     suicide();
   #endif
 

commit 3847c08f7ebeac1822812704ae6868a3e37c1b02
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 19 13:30:37 2018 -0500

    Disable heaters/steppers before message

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index fa1ecc8c34..5e6c9792c6 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -603,46 +603,47 @@ void idle(
   #if ENABLED(USB_FLASH_DRIVE_SUPPORT)
     Sd2Card::idle();
   #endif
 }
 
 /**
  * Kill all activity and lock the machine.
  * After this the machine will need to be reset.
  */
 void kill(PGM_P const lcd_msg/*=NULL*/) {
-  SERIAL_ERROR_START();
-  SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
 
   thermalManager.disable_all_heaters();
   disable_all_steppers();
 
+  SERIAL_ERROR_START();
+  SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
+
   #if ENABLED(EXTENSIBLE_UI)
     UI::onPrinterKilled(lcd_msg ? lcd_msg : PSTR(MSG_KILLED));
   #elif ENABLED(ULTRA_LCD)
     kill_screen(lcd_msg ? lcd_msg : PSTR(MSG_KILLED));
   #else
     UNUSED(lcd_msg);
   #endif
 
   #ifdef ACTION_ON_KILL
     SERIAL_ECHOLNPGM("//action:" ACTION_ON_KILL);
   #endif
 
   minkill();
 }
 
 void minkill() {
 
-  _delay_ms(600); // Wait a short time (allows messages to get out before shutting down.
-  cli(); // Stop interrupts
-  _delay_ms(250); // Wait to ensure all interrupts stopped
+  _delay_ms(600);  // Wait a short time (allows messages to get out before shutting down.
+  cli();           // Stop interrupts
+  _delay_ms(250);  // Wait to ensure all interrupts stopped
 
   thermalManager.disable_all_heaters(); // turn off heaters again
 
   #if HAS_POWER_SWITCH
     PSU_OFF();
   #endif
 
   #if HAS_SUICIDE
     suicide();
   #endif

commit 71e19baf691a5252841cca5871a29d7a65b62e5f
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Thu Oct 18 20:20:56 2018 -0600

    Fix kill => disable_all_heaters => print_job_timer.stop (#12146)
    
    - Remove `print_job_timer.stop()` from `disable_all_heaters`
    - Call `print_job_timer.stop()` for relevant `disable_all_heaters()`.
    - Split up `kill()` for watchdog interrupt safety

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 33b683d739..fa1ecc8c34 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -344,21 +344,21 @@ void manage_inactivity(const bool ignore_stepper_queue/*=false*/) {
     runout.run();
   #endif
 
   if (commands_in_queue < BUFSIZE) get_available_commands();
 
   const millis_t ms = millis();
 
   if (max_inactive_time && ELAPSED(ms, gcode.previous_move_ms + max_inactive_time)) {
     SERIAL_ERROR_START();
     SERIAL_ECHOLNPAIR(MSG_KILL_INACTIVE_TIME, parser.command_ptr);
-    kill(PSTR(MSG_KILLED));
+    kill();
   }
 
   // Prevent steppers timing-out in the middle of M600
   #if ENABLED(ADVANCED_PAUSE_FEATURE) && ENABLED(PAUSE_PARK_NO_STEPPER_TIMEOUT)
     #define MOVE_AWAY_TEST !did_pause_print
   #else
     #define MOVE_AWAY_TEST true
   #endif
 
   if (stepper_inactive_time) {
@@ -401,21 +401,21 @@ void manage_inactivity(const bool ignore_stepper_queue/*=false*/) {
       killCount++;
     else if (killCount > 0)
       killCount--;
 
     // Exceeded threshold and we can confirm that it was not accidental
     // KILL the machine
     // ----------------------------------------------------------------
     if (killCount >= KILL_DELAY) {
       SERIAL_ERROR_START();
       SERIAL_ERRORLNPGM(MSG_KILL_BUTTON);
-      kill(PSTR(MSG_KILLED));
+      kill();
     }
   #endif
 
   #if HAS_HOME
     // Check to see if we have to home, use poor man's debouncer
     // ---------------------------------------------------------
     static int homeDebounceCount = 0;   // poor man's debouncing count
     const int HOME_DEBOUNCE_DELAY = 2500;
     if (!IS_SD_PRINTING && !READ(HOME_PIN)) {
       if (!homeDebounceCount) {
@@ -602,45 +602,50 @@ void idle(
 
   #if ENABLED(USB_FLASH_DRIVE_SUPPORT)
     Sd2Card::idle();
   #endif
 }
 
 /**
  * Kill all activity and lock the machine.
  * After this the machine will need to be reset.
  */
-void kill(PGM_P lcd_msg) {
+void kill(PGM_P const lcd_msg/*=NULL*/) {
   SERIAL_ERROR_START();
   SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
 
   thermalManager.disable_all_heaters();
   disable_all_steppers();
 
   #if ENABLED(EXTENSIBLE_UI)
-    UI::onPrinterKilled(lcd_msg);
+    UI::onPrinterKilled(lcd_msg ? lcd_msg : PSTR(MSG_KILLED));
   #elif ENABLED(ULTRA_LCD)
-    kill_screen(lcd_msg);
+    kill_screen(lcd_msg ? lcd_msg : PSTR(MSG_KILLED));
   #else
     UNUSED(lcd_msg);
   #endif
 
-  _delay_ms(600); // Wait a short time (allows messages to get out before shutting down.
-  cli(); // Stop interrupts
-
-  _delay_ms(250); //Wait to ensure all interrupts routines stopped
-  thermalManager.disable_all_heaters(); //turn off heaters again
-
   #ifdef ACTION_ON_KILL
     SERIAL_ECHOLNPGM("//action:" ACTION_ON_KILL);
   #endif
 
+  minkill();
+}
+
+void minkill() {
+
+  _delay_ms(600); // Wait a short time (allows messages to get out before shutting down.
+  cli(); // Stop interrupts
+  _delay_ms(250); // Wait to ensure all interrupts stopped
+
+  thermalManager.disable_all_heaters(); // turn off heaters again
+
   #if HAS_POWER_SWITCH
     PSU_OFF();
   #endif
 
   #if HAS_SUICIDE
     suicide();
   #endif
 
   while (1) {
     #if ENABLED(USE_WATCHDOG)
@@ -648,20 +653,21 @@ void kill(PGM_P lcd_msg) {
     #endif
   } // Wait for reset
 }
 
 /**
  * Turn off heaters and stop the print in progress
  * After a stop the machine may be resumed with M999
  */
 void stop() {
   thermalManager.disable_all_heaters(); // 'unpause' taken care of in here
+  print_job_timer.stop();
 
   #if ENABLED(PROBING_FANS_OFF)
     if (fans_paused) fans_pause(false); // put things back the way they were
   #endif
 
   if (IsRunning()) {
     Stopped_gcode_LastN = gcode_LastN; // Save last g_code for restart
     SERIAL_ERROR_START();
     SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
     LCD_MESSAGEPGM(MSG_STOPPED);
@@ -972,23 +978,21 @@ void loop() {
         abort_sd_printing = false;
         card.stopSDPrint(
           #if SD_RESORT
             true
           #endif
         );
         clear_command_queue();
         quickstop_stepper();
         print_job_timer.stop();
         thermalManager.disable_all_heaters();
-        #if FAN_COUNT > 0
-          for (uint8_t i = 0; i < FAN_COUNT; i++) fan_speed[i] = 0;
-        #endif
+        zero_fan_speeds();
         wait_for_heatup = false;
         #if ENABLED(POWER_LOSS_RECOVERY)
           card.removeJobRecoveryFile();
         #endif
       }
     #endif // SDSUPPORT && (ENABLED(ULTIPANEL) || ENABLED(EXTENSIBLE_UI))
 
     if (commands_in_queue < BUFSIZE) get_available_commands();
     advance_command_queue();
     endstops.event_handler();

commit f56968ba0b8d4eaccbc9b0c7834cf0cd2f5872d8
Author: AnHardt <github@kitelab.de>
Date:   Tue Oct 16 10:38:57 2018 +0200

    New Continuous Filament Mixer (#12098)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index a78cdf2a6e..33b683d739 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -898,22 +898,22 @@ void setup() {
     fanmux_init();
   #endif
 
   lcd_init();
   lcd_reset_status();
 
   #if ENABLED(SHOW_BOOTSCREEN)
     lcd_bootscreen();
   #endif
 
-  #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
-    mixing_tools_init();
+  #if ENABLED(MIXING_EXTRUDER)
+    mixer.init();
   #endif
 
   #if ENABLED(BLTOUCH)
     bltouch_init();
   #endif
 
   #if ENABLED(I2C_POSITION_ENCODERS)
     I2CPEM.init();
   #endif
 

commit 1407afad738ce64f4cc9f0c2ad9d02ba88f2a925
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Oct 11 00:58:41 2018 -0500

    Move SENSITIVE_PINS to its own file

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index a3646eb128..a78cdf2a6e 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -252,20 +252,23 @@ void setup_powerhold() {
 
   void i2c_on_request() {          // just send dummy data for now
     i2c.reply("Hello World!\n");
   }
 
 #endif
 
 /**
  * Sensitive pin test for M42, M226
  */
+
+#include "pins/sensitive_pins.h"
+
 bool pin_is_protected(const pin_t pin) {
   static const pin_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++) {
     pin_t sensitive_pin;
     memcpy_P(&sensitive_pin, &sensitive_pins[i], sizeof(pin_t));
     if (pin == sensitive_pin) return true;
   }
   return false;
 }
 

commit 906a24fa81586e3d9aeb60e7a3fb179a8b616b9b
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Mon Oct 8 14:44:05 2018 -0600

    Extensible user interface API (#11193)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index dbeb4e2939..a3646eb128 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -145,20 +145,24 @@
 #endif
 
 #if DO_SWITCH_EXTRUDER || ENABLED(SWITCHING_NOZZLE) || ENABLED(PARKING_EXTRUDER)
   #include "module/tool_change.h"
 #endif
 
 #if ENABLED(USE_CONTROLLER_FAN)
   #include "feature/controllerfan.h"
 #endif
 
+#if ENABLED(EXTENSIBLE_UI)
+  #include "lcd/extensible_ui/ui_api.h"
+#endif
+
 bool Running = true;
 
 /**
  * axis_homed
  *   Flags that each linear axis was homed.
  *   XYZ on cartesian, ABC on delta, ABZ on SCARA.
  *
  * axis_known_position
  *   Flags that the position is known in each linear axis. Set when homed.
  *   Cleared whenever a stepper powers off, potentially losing its position.
@@ -602,21 +606,23 @@ void idle(
  * Kill all activity and lock the machine.
  * After this the machine will need to be reset.
  */
 void kill(PGM_P lcd_msg) {
   SERIAL_ERROR_START();
   SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
 
   thermalManager.disable_all_heaters();
   disable_all_steppers();
 
-  #if ENABLED(ULTRA_LCD)
+  #if ENABLED(EXTENSIBLE_UI)
+    UI::onPrinterKilled(lcd_msg);
+  #elif ENABLED(ULTRA_LCD)
     kill_screen(lcd_msg);
   #else
     UNUSED(lcd_msg);
   #endif
 
   _delay_ms(600); // Wait a short time (allows messages to get out before shutting down.
   cli(); // Stop interrupts
 
   _delay_ms(250); //Wait to ensure all interrupts routines stopped
   thermalManager.disable_all_heaters(); //turn off heaters again
@@ -951,38 +957,38 @@ void setup() {
  *  - Call inactivity manager
  */
 void loop() {
 
   for (;;) {
 
     #if ENABLED(SDSUPPORT)
       card.checkautostart();
     #endif
 
-    #if ENABLED(SDSUPPORT) && ENABLED(ULTIPANEL)
+    #if ENABLED(SDSUPPORT) && (ENABLED(ULTIPANEL) || ENABLED(EXTENSIBLE_UI))
       if (abort_sd_printing) {
         abort_sd_printing = false;
         card.stopSDPrint(
           #if SD_RESORT
             true
           #endif
         );
         clear_command_queue();
         quickstop_stepper();
         print_job_timer.stop();
         thermalManager.disable_all_heaters();
         #if FAN_COUNT > 0
           for (uint8_t i = 0; i < FAN_COUNT; i++) fan_speed[i] = 0;
         #endif
         wait_for_heatup = false;
         #if ENABLED(POWER_LOSS_RECOVERY)
           card.removeJobRecoveryFile();
         #endif
       }
-    #endif // SDSUPPORT && ULTIPANEL
+    #endif // SDSUPPORT && (ENABLED(ULTIPANEL) || ENABLED(EXTENSIBLE_UI))
 
     if (commands_in_queue < BUFSIZE) get_available_commands();
     advance_command_queue();
     endstops.event_handler();
     idle();
   }
 }

commit d6b0fbd7715da67a2aaeeeafb0d4dc7c1563ef98
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Oct 7 15:34:41 2018 -0500

    Use uint8_t for all fan speeds (#12032)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 00854ac2c4..dbeb4e2939 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -163,28 +163,27 @@ bool Running = true;
  *   Flags that the position is known in each linear axis. Set when homed.
  *   Cleared whenever a stepper powers off, potentially losing its position.
  */
 uint8_t axis_homed, axis_known_position; // = 0
 
 #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
   TempUnit input_temp_units = TEMPUNIT_C;
 #endif
 
 #if FAN_COUNT > 0
-  int16_t fanSpeeds[FAN_COUNT] = { 0 };
+  uint8_t fan_speed[FAN_COUNT] = { 0 };
   #if ENABLED(EXTRA_FAN_SPEED)
-    int16_t old_fanSpeeds[FAN_COUNT],
-            new_fanSpeeds[FAN_COUNT];
+    uint8_t old_fan_speed[FAN_COUNT], new_fan_speed[FAN_COUNT];
   #endif
   #if ENABLED(PROBING_FANS_OFF)
     bool fans_paused; // = false;
-    int16_t paused_fanSpeeds[FAN_COUNT] = { 0 };
+    uint8_t paused_fan_speed[FAN_COUNT] = { 0 };
   #endif
 #endif
 
 // For M109 and M190, this flag may be cleared (by M108) to exit the wait loop
 volatile bool wait_for_heatup = true;
 
 // For M0/M1, this flag may be cleared (by M108) to exit the wait-for-user loop
 #if HAS_RESUME_CONTINUE
   volatile bool wait_for_user; // = false;
 #endif
@@ -965,21 +964,21 @@ void loop() {
         card.stopSDPrint(
           #if SD_RESORT
             true
           #endif
         );
         clear_command_queue();
         quickstop_stepper();
         print_job_timer.stop();
         thermalManager.disable_all_heaters();
         #if FAN_COUNT > 0
-          for (uint8_t i = 0; i < FAN_COUNT; i++) fanSpeeds[i] = 0;
+          for (uint8_t i = 0; i < FAN_COUNT; i++) fan_speed[i] = 0;
         #endif
         wait_for_heatup = false;
         #if ENABLED(POWER_LOSS_RECOVERY)
           card.removeJobRecoveryFile();
         #endif
       }
     #endif // SDSUPPORT && ULTIPANEL
 
     if (commands_in_queue < BUFSIZE) get_available_commands();
     advance_command_queue();

commit c447d759167bb118c2f26febdae71dd60c64977a
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Sun Oct 7 01:18:10 2018 +0300

    Add support for TMC2660 (#11998)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 02d34951b4..00854ac2c4 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -732,21 +732,21 @@ void setup() {
     while (!MYSERIAL0 && PENDING(millis(), serial_connect_timeout)) { /*nada*/ }
     #if NUM_SERIAL > 1
       serial_connect_timeout = millis() + 1000UL;
       while (!MYSERIAL1 && PENDING(millis(), serial_connect_timeout)) { /*nada*/ }
     #endif
   #endif
 
   SERIAL_PROTOCOLLNPGM("start");
   SERIAL_ECHO_START();
 
-  #if HAS_DRIVER(TMC2130)
+  #if TMC_HAS_SPI
     #if DISABLED(TMC_USE_SW_SPI)
       SPI.begin();
     #endif
     tmc_init_cs_pins();
   #endif
   #if HAS_DRIVER(TMC2208)
     tmc2208_serial_begin();
   #endif
 
   #ifdef BOARD_INIT

commit 2067619a269f2b4a6e52fdcb1f968e48b952a7d1
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Mon Jul 2 09:06:17 2018 -0600

    Add USB_FLASH_DRIVE_SUPPORT

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 931717ff16..02d34951b4 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -586,20 +586,24 @@ void idle(
   #if HAS_AUTO_REPORTING
     if (!suspend_auto_report) {
       #if ENABLED(AUTO_REPORT_TEMPERATURES)
         thermalManager.auto_report_temperatures();
       #endif
       #if ENABLED(AUTO_REPORT_SD_STATUS)
         card.auto_report_sd_status();
       #endif
     }
   #endif
+
+  #if ENABLED(USB_FLASH_DRIVE_SUPPORT)
+    Sd2Card::idle();
+  #endif
 }
 
 /**
  * Kill all activity and lock the machine.
  * After this the machine will need to be reset.
  */
 void kill(PGM_P lcd_msg) {
   SERIAL_ERROR_START();
   SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
 

commit c3229e1b3461b6da8373e7a24a7eeb131912a15b
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Wed Oct 3 10:48:49 2018 +0300

    Migrate to a new TMC library (#11943)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 299adbec35..931717ff16 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -729,20 +729,23 @@ void setup() {
     #if NUM_SERIAL > 1
       serial_connect_timeout = millis() + 1000UL;
       while (!MYSERIAL1 && PENDING(millis(), serial_connect_timeout)) { /*nada*/ }
     #endif
   #endif
 
   SERIAL_PROTOCOLLNPGM("start");
   SERIAL_ECHO_START();
 
   #if HAS_DRIVER(TMC2130)
+    #if DISABLED(TMC_USE_SW_SPI)
+      SPI.begin();
+    #endif
     tmc_init_cs_pins();
   #endif
   #if HAS_DRIVER(TMC2208)
     tmc2208_serial_begin();
   #endif
 
   #ifdef BOARD_INIT
     BOARD_INIT();
   #endif
 

commit c75f5a376b797a839519a7d31f6d3237bb392a6e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Oct 1 18:33:52 2018 -0500

    Tweak some comments

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 2a38e4817c..299adbec35 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -822,49 +822,49 @@ void setup() {
       SET_OUTPUT(SPINDLE_LASER_PWM_PIN);
       analogWrite(SPINDLE_LASER_PWM_PIN, SPINDLE_LASER_PWM_INVERT ? 255 : 0);  // set to lowest speed
     #endif
   #endif
 
   #if HAS_BED_PROBE
     endstops.enable_z_probe(false);
   #endif
 
   #if ENABLED(USE_CONTROLLER_FAN)
-    SET_OUTPUT(CONTROLLER_FAN_PIN); //Set pin used for driver cooling fan
+    SET_OUTPUT(CONTROLLER_FAN_PIN);
   #endif
 
   #if HAS_STEPPER_RESET
     enableStepperDrivers();
   #endif
 
   #if ENABLED(DIGIPOT_I2C)
     digipot_i2c_init();
   #endif
 
   #if ENABLED(DAC_STEPPER_CURRENT)
     dac_init();
   #endif
 
   #if (ENABLED(Z_PROBE_SLED) || ENABLED(SOLENOID_PROBE)) && HAS_SOLENOID_1
-    OUT_WRITE(SOL1_PIN, LOW); // turn it off
+    OUT_WRITE(SOL1_PIN, LOW); // OFF
   #endif
 
   #if HAS_HOME
     SET_INPUT_PULLUP(HOME_PIN);
   #endif
 
   #if PIN_EXISTS(STAT_LED_RED)
-    OUT_WRITE(STAT_LED_RED_PIN, LOW); // turn it off
+    OUT_WRITE(STAT_LED_RED_PIN, LOW); // OFF
   #endif
 
   #if PIN_EXISTS(STAT_LED_BLUE)
-    OUT_WRITE(STAT_LED_BLUE_PIN, LOW); // turn it off
+    OUT_WRITE(STAT_LED_BLUE_PIN, LOW); // OFF
   #endif
 
   #if HAS_COLOR_LEDS
     leds.setup();
   #endif
 
   #if ENABLED(RGB_LED) || ENABLED(RGBW_LED)
     SET_OUTPUT(RGB_LED_R_PIN);
     SET_OUTPUT(RGB_LED_G_PIN);
     SET_OUTPUT(RGB_LED_B_PIN);

commit 11ac75edcb34a2f90b50ca134ff40839f8c29199
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 30 23:44:33 2018 -0500

    Use PGM_P for PSTR pointers (#11977)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 4bb1a1fb92..2a38e4817c 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -592,21 +592,21 @@ void idle(
         card.auto_report_sd_status();
       #endif
     }
   #endif
 }
 
 /**
  * Kill all activity and lock the machine.
  * After this the machine will need to be reset.
  */
-void kill(const char* lcd_msg) {
+void kill(PGM_P lcd_msg) {
   SERIAL_ERROR_START();
   SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
 
   thermalManager.disable_all_heaters();
   disable_all_steppers();
 
   #if ENABLED(ULTRA_LCD)
     kill_screen(lcd_msg);
   #else
     UNUSED(lcd_msg);

commit 2ecfda80aceb76d2ef774393b24c26f54794fa81
Author: Alexander Amelkin <mocbuhtig@amelkin.msk.ru>
Date:   Sun Sep 30 03:00:49 2018 +0300

    Improve support for JTAG/SWD pins reuse (#11963)
    
    STM32 can reuse JTAG and SWD pins separately. Add `DISABLE_DEBUG` option to disable both interfaces and retain `DISABLE_JTAG` to disable JTAG only.

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 6d787fac48..4bb1a1fb92 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -679,21 +679,30 @@ void stop() {
 void setup() {
 
   #ifdef HAL_INIT
     HAL_init();
   #endif
 
   #if ENABLED(MAX7219_DEBUG)
     max7219.init();
   #endif
 
-  #if ENABLED(DISABLE_JTAG)
+  #if ENABLED(DISABLE_DEBUG)
+    // Disable any hardware debug to free up pins for IO
+    #ifdef JTAGSWD_DISABLE
+      JTAGSWD_DISABLE();
+    #elif defined(JTAG_DISABLE)
+      JTAG_DISABLE();
+    #else
+      #error "DISABLE_DEBUG is not supported for the selected MCU/Board"
+    #endif
+  #elif ENABLED(DISABLE_JTAG)
     // Disable JTAG to free up pins for IO
     #ifdef JTAG_DISABLE
       JTAG_DISABLE();
     #else
       #error "DISABLE_JTAG is not supported for the selected MCU/Board"
     #endif
   #endif
 
   #if ENABLED(FILAMENT_RUNOUT_SENSOR)
     runout.setup();

commit 84926b1d5ac9c1f701f35245066e451e2f35b77c
Author: Alexander Amelkin <mocbuhtig@amelkin.msk.ru>
Date:   Fri Sep 28 02:02:50 2018 +0300

    HAL general support for DISABLE_JTAG option (#11211)
    
    Some STM32-based boards may use multiplexed JTAG pins as IO. Up to now the `DISABLE_JTAG` option (defined in pins files) was only supported for AT90-based boards. This commit generalizes the code and adds support for boards based on STM32F1 and STM32F4.

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index ba9a0862da..6d787fac48 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -680,23 +680,26 @@ void setup() {
 
   #ifdef HAL_INIT
     HAL_init();
   #endif
 
   #if ENABLED(MAX7219_DEBUG)
     max7219.init();
   #endif
 
   #if ENABLED(DISABLE_JTAG)
-    // Disable JTAG on AT90USB chips to free up pins for IO
-    MCUCR = 0x80;
-    MCUCR = 0x80;
+    // Disable JTAG to free up pins for IO
+    #ifdef JTAG_DISABLE
+      JTAG_DISABLE();
+    #else
+      #error "DISABLE_JTAG is not supported for the selected MCU/Board"
+    #endif
   #endif
 
   #if ENABLED(FILAMENT_RUNOUT_SENSOR)
     runout.setup();
   #endif
 
   setup_killpin();
 
   setup_powerhold();
 

commit 1718eff54adefc7cc95851f28df0c7e02eae3a36
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Sep 13 01:35:55 2018 -0500

    Code changes supporting up to 6 extruders

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 99502c6557..ba9a0862da 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -283,37 +283,40 @@ void enable_all_steppers() {
     powerManager.power_on();
   #endif
   enable_X();
   enable_Y();
   enable_Z();
   enable_E0();
   enable_E1();
   enable_E2();
   enable_E3();
   enable_E4();
+  enable_E5();
 }
 
 void disable_e_steppers() {
   disable_E0();
   disable_E1();
   disable_E2();
   disable_E3();
   disable_E4();
+  disable_E5();
 }
 
 void disable_e_stepper(const uint8_t e) {
   switch (e) {
     case 0: disable_E0(); break;
     case 1: disable_E1(); break;
     case 2: disable_E2(); break;
     case 3: disable_E3(); break;
     case 4: disable_E4(); break;
+    case 5: disable_E5(); break;
   }
 }
 
 void disable_all_steppers() {
   disable_X();
   disable_Y();
   disable_Z();
   disable_e_steppers();
 }
 
@@ -433,71 +436,77 @@ void manage_inactivity(const bool ignore_stepper_queue/*=false*/) {
       && ELAPSED(ms, gcode.previous_move_ms + (EXTRUDER_RUNOUT_SECONDS) * 1000UL)
       && !planner.has_blocks_queued()
     ) {
       #if ENABLED(SWITCHING_EXTRUDER)
         bool oldstatus;
         switch (active_extruder) {
           default: oldstatus = E0_ENABLE_READ; enable_E0(); break;
           #if E_STEPPERS > 1
             case 2: case 3: oldstatus = E1_ENABLE_READ; enable_E1(); break;
             #if E_STEPPERS > 2
-              case 4: oldstatus = E2_ENABLE_READ; enable_E2(); break;
+              case 4: case 5: oldstatus = E2_ENABLE_READ; enable_E2(); break;
             #endif // E_STEPPERS > 2
           #endif // E_STEPPERS > 1
         }
       #else // !SWITCHING_EXTRUDER
         bool oldstatus;
         switch (active_extruder) {
           default: oldstatus = E0_ENABLE_READ; enable_E0(); break;
           #if E_STEPPERS > 1
             case 1: oldstatus = E1_ENABLE_READ; enable_E1(); break;
             #if E_STEPPERS > 2
               case 2: oldstatus = E2_ENABLE_READ; enable_E2(); break;
               #if E_STEPPERS > 3
                 case 3: oldstatus = E3_ENABLE_READ; enable_E3(); break;
                 #if E_STEPPERS > 4
                   case 4: oldstatus = E4_ENABLE_READ; enable_E4(); break;
+                  #if E_STEPPERS > 5
+                    case 5: oldstatus = E5_ENABLE_READ; enable_E5(); break;
+                  #endif // E_STEPPERS > 5
                 #endif // E_STEPPERS > 4
               #endif // E_STEPPERS > 3
             #endif // E_STEPPERS > 2
           #endif // E_STEPPERS > 1
         }
       #endif // !SWITCHING_EXTRUDER
 
       const float olde = current_position[E_AXIS];
       current_position[E_AXIS] += EXTRUDER_RUNOUT_EXTRUDE;
       planner.buffer_line(current_position, MMM_TO_MMS(EXTRUDER_RUNOUT_SPEED), active_extruder);
       current_position[E_AXIS] = olde;
       planner.set_e_position_mm(olde);
       planner.synchronize();
 
       #if ENABLED(SWITCHING_EXTRUDER)
         switch (active_extruder) {
           default: oldstatus = E0_ENABLE_WRITE(oldstatus); break;
           #if E_STEPPERS > 1
             case 2: case 3: oldstatus = E1_ENABLE_WRITE(oldstatus); break;
             #if E_STEPPERS > 2
-              case 4: oldstatus = E2_ENABLE_WRITE(oldstatus); break;
+              case 4: case 5: oldstatus = E2_ENABLE_WRITE(oldstatus); break;
             #endif // E_STEPPERS > 2
           #endif // E_STEPPERS > 1
         }
       #else // !SWITCHING_EXTRUDER
         switch (active_extruder) {
           case 0: E0_ENABLE_WRITE(oldstatus); break;
           #if E_STEPPERS > 1
             case 1: E1_ENABLE_WRITE(oldstatus); break;
             #if E_STEPPERS > 2
               case 2: E2_ENABLE_WRITE(oldstatus); break;
               #if E_STEPPERS > 3
                 case 3: E3_ENABLE_WRITE(oldstatus); break;
                 #if E_STEPPERS > 4
                   case 4: E4_ENABLE_WRITE(oldstatus); break;
+                  #if E_STEPPERS > 5
+                    case 5: E5_ENABLE_WRITE(oldstatus); break;
+                  #endif // E_STEPPERS > 5
                 #endif // E_STEPPERS > 4
               #endif // E_STEPPERS > 3
             #endif // E_STEPPERS > 2
           #endif // E_STEPPERS > 1
         }
       #endif // !SWITCHING_EXTRUDER
 
       gcode.previous_move_ms = ms; // reset_stepper_timeout to keep steppers powered
     }
   #endif // EXTRUDER_RUNOUT_PREVENT

commit c437bb08f12f1c0535cc78a761b49a18f2dc2a12
Author: Thomas Moore <tcm0116@users.noreply.github.com>
Date:   Sun Sep 16 22:24:15 2018 -0400

    Overhaul of the planner (#11578)
    
    - Move FWRETRACT to the planner
    - Combine leveling, skew, etc. in a single modifier method
    - Have kinematic and non-kinematic moves call one planner method

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index fda6f9279e..99502c6557 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -268,21 +268,21 @@ bool pin_is_protected(const pin_t pin) {
 
 void protected_pin_err() {
   SERIAL_ERROR_START();
   SERIAL_ERRORLNPGM(MSG_ERR_PROTECTED_PIN);
 }
 
 void quickstop_stepper() {
   planner.quick_stop();
   planner.synchronize();
   set_current_from_steppers_for_axis(ALL_AXES);
-  SYNC_PLAN_POSITION_KINEMATIC();
+  sync_plan_position();
 }
 
 void enable_all_steppers() {
   #if ENABLED(AUTO_POWER_CONTROL)
     powerManager.power_on();
   #endif
   enable_X();
   enable_Y();
   enable_Z();
   enable_E0();
@@ -458,21 +458,21 @@ void manage_inactivity(const bool ignore_stepper_queue/*=false*/) {
                   case 4: oldstatus = E4_ENABLE_READ; enable_E4(); break;
                 #endif // E_STEPPERS > 4
               #endif // E_STEPPERS > 3
             #endif // E_STEPPERS > 2
           #endif // E_STEPPERS > 1
         }
       #endif // !SWITCHING_EXTRUDER
 
       const float olde = current_position[E_AXIS];
       current_position[E_AXIS] += EXTRUDER_RUNOUT_EXTRUDE;
-      planner.buffer_line_kinematic(current_position, MMM_TO_MMS(EXTRUDER_RUNOUT_SPEED), active_extruder);
+      planner.buffer_line(current_position, MMM_TO_MMS(EXTRUDER_RUNOUT_SPEED), active_extruder);
       current_position[E_AXIS] = olde;
       planner.set_e_position_mm(olde);
       planner.synchronize();
 
       #if ENABLED(SWITCHING_EXTRUDER)
         switch (active_extruder) {
           default: oldstatus = E0_ENABLE_WRITE(oldstatus); break;
           #if E_STEPPERS > 1
             case 2: case 3: oldstatus = E1_ENABLE_WRITE(oldstatus); break;
             #if E_STEPPERS > 2
@@ -759,21 +759,21 @@ void setup() {
   (void)settings.load();
 
   #if HAS_M206_COMMAND
     // Initialize current position based on home_offset
     COPY(current_position, home_offset);
   #else
     ZERO(current_position);
   #endif
 
   // Vital to init stepper/planner equivalent for current_position
-  SYNC_PLAN_POSITION_KINEMATIC();
+  sync_plan_position();
 
   thermalManager.init();    // Initialize temperature loop
 
   print_job_timer.init();   // Initial setup of print job timer
 
   endstops.init();          // Init endstops and pullups
 
   stepper.init();           // Init stepper. This enables interrupts!
 
   #if HAS_SERVOS

commit 1933d5d6fbd4b5bcd9fa5cc01bd1a6e3c93d865f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 12 03:49:46 2018 -0500

    Fix SD autostart with no LCD

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index e7d4a37fe3..fda6f9279e 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -902,20 +902,24 @@ void setup() {
     check_print_job_recovery();
   #endif
 
   #if ENABLED(USE_WATCHDOG) // Reinit watchdog after HAL_get_reset_source call
     watchdog_init();
   #endif
 
   #if ENABLED(EXTERNAL_CLOSED_LOOP_CONTROLLER)
     init_closedloop();
   #endif
+
+  #if ENABLED(SDSUPPORT) && DISABLED(ULTRA_LCD)
+    card.beginautostart();
+  #endif
 }
 
 /**
  * The main Marlin program loop
  *
  *  - Save or log commands to SD
  *  - Process available commands (if not saving)
  *  - Call endstop manager
  *  - Call inactivity manager
  */

commit 1b6bc194279b24e24df29bdd677a112236deac34
Author: Sam Lane <sl01172@surrey.ac.uk>
Date:   Sat Sep 8 18:08:31 2018 +0100

    Add external closed loop controller support

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 9720d824fa..e7d4a37fe3 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -33,20 +33,22 @@
 #include "lcd/ultralcd.h"
 #include "module/motion.h"
 #include "module/planner.h"
 #include "module/stepper.h"
 #include "module/endstops.h"
 #include "module/probe.h"
 #include "module/temperature.h"
 #include "sd/cardreader.h"
 #include "module/configuration_store.h"
 #include "module/printcounter.h" // PrintCounter or Stopwatch
+#include "feature/closedloop.h"
+
 #ifdef ARDUINO
   #include <pins_arduino.h>
 #endif
 #include <math.h>
 #include "libs/nozzle.h"
 
 #include "gcode/gcode.h"
 #include "gcode/parser.h"
 #include "gcode/queue.h"
 
@@ -896,20 +898,24 @@ void setup() {
     pe_magnet_init();
   #endif
 
   #if ENABLED(POWER_LOSS_RECOVERY)
     check_print_job_recovery();
   #endif
 
   #if ENABLED(USE_WATCHDOG) // Reinit watchdog after HAL_get_reset_source call
     watchdog_init();
   #endif
+
+  #if ENABLED(EXTERNAL_CLOSED_LOOP_CONTROLLER)
+    init_closedloop();
+  #endif
 }
 
 /**
  * The main Marlin program loop
  *
  *  - Save or log commands to SD
  *  - Process available commands (if not saving)
  *  - Call endstop manager
  *  - Call inactivity manager
  */

commit 56f1e17a25c0bb73d57a23b39e382269dfa0eb51
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Aug 18 01:33:13 2018 -0500

    [2.0.x] Max7219 cleanup, simplify, and extend (#11575)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 5e46d86fdc..9720d824fa 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -528,21 +528,21 @@ void manage_inactivity(const bool ignore_stepper_queue/*=false*/) {
 
 /**
  * Standard idle routine keeps the machine alive
  */
 void idle(
   #if ENABLED(ADVANCED_PAUSE_FEATURE)
     bool no_stepper_sleep/*=false*/
   #endif
 ) {
   #if ENABLED(MAX7219_DEBUG)
-    Max7219_idle_tasks();
+    max7219.idle_tasks();
   #endif
 
   lcd_update();
 
   #if ENABLED(HOST_KEEPALIVE_FEATURE)
     gcode.host_keepalive();
   #endif
 
   manage_inactivity(
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
@@ -665,21 +665,21 @@ void stop() {
  *    • Z probe sled
  *    • status LEDs
  */
 void setup() {
 
   #ifdef HAL_INIT
     HAL_init();
   #endif
 
   #if ENABLED(MAX7219_DEBUG)
-    Max7219_init();
+    max7219.init();
   #endif
 
   #if ENABLED(DISABLE_JTAG)
     // Disable JTAG on AT90USB chips to free up pins for IO
     MCUCR = 0x80;
     MCUCR = 0x80;
   #endif
 
   #if ENABLED(FILAMENT_RUNOUT_SENSOR)
     runout.setup();

commit fbcdf5eaeb4f2265fd43097ab6c652a89842d8e7
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Sat Jul 14 14:13:06 2018 +0300

    Simplify stepper driver per-axis selection

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index dde04cca07..5e46d86fdc 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -705,24 +705,24 @@ void setup() {
     while (!MYSERIAL0 && PENDING(millis(), serial_connect_timeout)) { /*nada*/ }
     #if NUM_SERIAL > 1
       serial_connect_timeout = millis() + 1000UL;
       while (!MYSERIAL1 && PENDING(millis(), serial_connect_timeout)) { /*nada*/ }
     #endif
   #endif
 
   SERIAL_PROTOCOLLNPGM("start");
   SERIAL_ECHO_START();
 
-  #if ENABLED(HAVE_TMC2130)
+  #if HAS_DRIVER(TMC2130)
     tmc_init_cs_pins();
   #endif
-  #if ENABLED(HAVE_TMC2208)
+  #if HAS_DRIVER(TMC2208)
     tmc2208_serial_begin();
   #endif
 
   #ifdef BOARD_INIT
     BOARD_INIT();
   #endif
 
   // Check startup - does nothing if bootloader sets MCUSR to 0
   byte mcu = HAL_get_reset_source();
   if (mcu &  1) SERIAL_ECHOLNPGM(MSG_POWERUP);

commit 566d05006da2ef30f0409664bf21b6211e1daf83
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jul 11 17:33:26 2018 -0500

    report_state > event_handler
    
    Make the endstop report method track endstop changes on its own.

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 3c9fbc6667..dde04cca07 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -938,14 +938,14 @@ void loop() {
         #endif
         wait_for_heatup = false;
         #if ENABLED(POWER_LOSS_RECOVERY)
           card.removeJobRecoveryFile();
         #endif
       }
     #endif // SDSUPPORT && ULTIPANEL
 
     if (commands_in_queue < BUFSIZE) get_available_commands();
     advance_command_queue();
-    endstops.report_state();
+    endstops.event_handler();
     idle();
   }
 }

commit 1a0f4dedad5a564800520418ec01448982b9b023
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jul 2 23:21:28 2018 -0500

    Fix and improve POWER_LOSS_RECOVERY (#11187)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 38e5302ea8..3c9fbc6667 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -890,21 +890,21 @@ void setup() {
 
   #if ENABLED(SWITCHING_NOZZLE)
     move_nozzle_servo(0);  // Initialize nozzle servo
   #endif
 
   #if ENABLED(PARKING_EXTRUDER)
     pe_magnet_init();
   #endif
 
   #if ENABLED(POWER_LOSS_RECOVERY)
-    do_print_job_recovery();
+    check_print_job_recovery();
   #endif
 
   #if ENABLED(USE_WATCHDOG) // Reinit watchdog after HAL_get_reset_source call
     watchdog_init();
   #endif
 }
 
 /**
  * The main Marlin program loop
  *
@@ -930,19 +930,22 @@ void loop() {
           #endif
         );
         clear_command_queue();
         quickstop_stepper();
         print_job_timer.stop();
         thermalManager.disable_all_heaters();
         #if FAN_COUNT > 0
           for (uint8_t i = 0; i < FAN_COUNT; i++) fanSpeeds[i] = 0;
         #endif
         wait_for_heatup = false;
+        #if ENABLED(POWER_LOSS_RECOVERY)
+          card.removeJobRecoveryFile();
+        #endif
       }
     #endif // SDSUPPORT && ULTIPANEL
 
     if (commands_in_queue < BUFSIZE) get_available_commands();
     advance_command_queue();
     endstops.report_state();
     idle();
   }
 }

commit cedc1581064212a72bfb82096f7bf242521f2de3
Author: TheLongAndOnly <github@mueller-gelff.de>
Date:   Mon Jul 2 06:11:42 2018 +0200

    [2.0.x] Board specific init macro (#11170)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index b1654cd23b..38e5302ea8 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -712,20 +712,24 @@ void setup() {
   SERIAL_PROTOCOLLNPGM("start");
   SERIAL_ECHO_START();
 
   #if ENABLED(HAVE_TMC2130)
     tmc_init_cs_pins();
   #endif
   #if ENABLED(HAVE_TMC2208)
     tmc2208_serial_begin();
   #endif
 
+  #ifdef BOARD_INIT
+    BOARD_INIT();
+  #endif
+
   // Check startup - does nothing if bootloader sets MCUSR to 0
   byte mcu = HAL_get_reset_source();
   if (mcu &  1) SERIAL_ECHOLNPGM(MSG_POWERUP);
   if (mcu &  2) SERIAL_ECHOLNPGM(MSG_EXTERNAL_RESET);
   if (mcu &  4) SERIAL_ECHOLNPGM(MSG_BROWNOUT_RESET);
   if (mcu &  8) SERIAL_ECHOLNPGM(MSG_WATCHDOG_RESET);
   if (mcu & 32) SERIAL_ECHOLNPGM(MSG_SOFTWARE_RESET);
   HAL_clear_reset_source();
 
   SERIAL_ECHOPGM(MSG_MARLIN);

commit d4795e5b8eff93fcab4a80d16cd7bc5ceb2ebc51
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jun 18 22:04:03 2018 -0500

    [2.0.x] Tweaks and additions for MAX7219 (#11034)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index fe4ceb1263..b1654cd23b 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -529,21 +529,21 @@ void manage_inactivity(const bool ignore_stepper_queue/*=false*/) {
 /**
  * Standard idle routine keeps the machine alive
  */
 void idle(
   #if ENABLED(ADVANCED_PAUSE_FEATURE)
     bool no_stepper_sleep/*=false*/
   #endif
 ) {
   #if ENABLED(MAX7219_DEBUG)
     Max7219_idle_tasks();
-  #endif  // MAX7219_DEBUG
+  #endif
 
   lcd_update();
 
   #if ENABLED(HOST_KEEPALIVE_FEATURE)
     gcode.host_keepalive();
   #endif
 
   manage_inactivity(
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
       no_stepper_sleep

commit e2aeda61edd123997c77c81483b81d0e99bd18f3
Author: Simon Jouet <simon.jouet@gmail.com>
Date:   Sun Oct 8 17:38:10 2017 +0100

    HAL for Espressif ESP32 Wifi

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index c182efc418..fe4ceb1263 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -695,24 +695,24 @@ void setup() {
 
   #if NUM_SERIAL > 0
     MYSERIAL0.begin(BAUDRATE);
     #if NUM_SERIAL > 1
       MYSERIAL1.begin(BAUDRATE);
     #endif
   #endif
 
   #if NUM_SERIAL > 0
     uint32_t serial_connect_timeout = millis() + 1000UL;
-    while(!MYSERIAL0 && PENDING(millis(), serial_connect_timeout)) { /*nada*/ }
+    while (!MYSERIAL0 && PENDING(millis(), serial_connect_timeout)) { /*nada*/ }
     #if NUM_SERIAL > 1
       serial_connect_timeout = millis() + 1000UL;
-      while(!MYSERIAL1 && PENDING(millis(), serial_connect_timeout)) { /*nada*/ }
+      while (!MYSERIAL1 && PENDING(millis(), serial_connect_timeout)) { /*nada*/ }
     #endif
   #endif
 
   SERIAL_PROTOCOLLNPGM("start");
   SERIAL_ECHO_START();
 
   #if ENABLED(HAVE_TMC2130)
     tmc_init_cs_pins();
   #endif
   #if ENABLED(HAVE_TMC2208)

commit f2c3b0d47646c5b56804f2474ae96c0884b783c8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jun 11 21:29:31 2018 -0500

    Use bit flags for homed/known

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index a13d7f19a9..c182efc418 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -154,21 +154,21 @@ bool Running = true;
 
 /**
  * axis_homed
  *   Flags that each linear axis was homed.
  *   XYZ on cartesian, ABC on delta, ABZ on SCARA.
  *
  * axis_known_position
  *   Flags that the position is known in each linear axis. Set when homed.
  *   Cleared whenever a stepper powers off, potentially losing its position.
  */
-bool axis_homed[XYZ] = { false }, axis_known_position[XYZ] = { false };
+uint8_t axis_homed, axis_known_position; // = 0
 
 #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
   TempUnit input_temp_units = TEMPUNIT_C;
 #endif
 
 #if FAN_COUNT > 0
   int16_t fanSpeeds[FAN_COUNT] = { 0 };
   #if ENABLED(EXTRA_FAN_SPEED)
     int16_t old_fanSpeeds[FAN_COUNT],
             new_fanSpeeds[FAN_COUNT];

commit 968a5d2e63dd53fb6a241bd75c0e073539fada71
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Jun 10 17:45:39 2018 -0500

    Protected pin err for M226

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index e089e034c7..a13d7f19a9 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -257,20 +257,25 @@ void setup_powerhold() {
 bool pin_is_protected(const pin_t pin) {
   static const pin_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++) {
     pin_t sensitive_pin;
     memcpy_P(&sensitive_pin, &sensitive_pins[i], sizeof(pin_t));
     if (pin == sensitive_pin) return true;
   }
   return false;
 }
 
+void protected_pin_err() {
+  SERIAL_ERROR_START();
+  SERIAL_ERRORLNPGM(MSG_ERR_PROTECTED_PIN);
+}
+
 void quickstop_stepper() {
   planner.quick_stop();
   planner.synchronize();
   set_current_from_steppers_for_axis(ALL_AXES);
   SYNC_PLAN_POSITION_KINEMATIC();
 }
 
 void enable_all_steppers() {
   #if ENABLED(AUTO_POWER_CONTROL)
     powerManager.power_on();

commit 0ca9db705191d0b36dea513437ec518b0c0211a6
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 27 17:56:21 2018 -0500

    Correct HOTENDS for SWITCHING_EXTRUDER

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 6f7fc4dae6..e089e034c7 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -420,22 +420,30 @@ void manage_inactivity(const bool ignore_stepper_queue/*=false*/) {
   #if ENABLED(AUTO_POWER_CONTROL)
     powerManager.check();
   #endif
 
   #if ENABLED(EXTRUDER_RUNOUT_PREVENT)
     if (thermalManager.degHotend(active_extruder) > EXTRUDER_RUNOUT_MINTEMP
       && ELAPSED(ms, gcode.previous_move_ms + (EXTRUDER_RUNOUT_SECONDS) * 1000UL)
       && !planner.has_blocks_queued()
     ) {
       #if ENABLED(SWITCHING_EXTRUDER)
-        const bool oldstatus = E0_ENABLE_READ;
-        enable_E0();
+        bool oldstatus;
+        switch (active_extruder) {
+          default: oldstatus = E0_ENABLE_READ; enable_E0(); break;
+          #if E_STEPPERS > 1
+            case 2: case 3: oldstatus = E1_ENABLE_READ; enable_E1(); break;
+            #if E_STEPPERS > 2
+              case 4: oldstatus = E2_ENABLE_READ; enable_E2(); break;
+            #endif // E_STEPPERS > 2
+          #endif // E_STEPPERS > 1
+        }
       #else // !SWITCHING_EXTRUDER
         bool oldstatus;
         switch (active_extruder) {
           default: oldstatus = E0_ENABLE_READ; enable_E0(); break;
           #if E_STEPPERS > 1
             case 1: oldstatus = E1_ENABLE_READ; enable_E1(); break;
             #if E_STEPPERS > 2
               case 2: oldstatus = E2_ENABLE_READ; enable_E2(); break;
               #if E_STEPPERS > 3
                 case 3: oldstatus = E3_ENABLE_READ; enable_E3(); break;
@@ -447,23 +455,32 @@ void manage_inactivity(const bool ignore_stepper_queue/*=false*/) {
           #endif // E_STEPPERS > 1
         }
       #endif // !SWITCHING_EXTRUDER
 
       const float olde = current_position[E_AXIS];
       current_position[E_AXIS] += EXTRUDER_RUNOUT_EXTRUDE;
       planner.buffer_line_kinematic(current_position, MMM_TO_MMS(EXTRUDER_RUNOUT_SPEED), active_extruder);
       current_position[E_AXIS] = olde;
       planner.set_e_position_mm(olde);
       planner.synchronize();
+
       #if ENABLED(SWITCHING_EXTRUDER)
-        E0_ENABLE_WRITE(oldstatus);
-      #else
+        switch (active_extruder) {
+          default: oldstatus = E0_ENABLE_WRITE(oldstatus); break;
+          #if E_STEPPERS > 1
+            case 2: case 3: oldstatus = E1_ENABLE_WRITE(oldstatus); break;
+            #if E_STEPPERS > 2
+              case 4: oldstatus = E2_ENABLE_WRITE(oldstatus); break;
+            #endif // E_STEPPERS > 2
+          #endif // E_STEPPERS > 1
+        }
+      #else // !SWITCHING_EXTRUDER
         switch (active_extruder) {
           case 0: E0_ENABLE_WRITE(oldstatus); break;
           #if E_STEPPERS > 1
             case 1: E1_ENABLE_WRITE(oldstatus); break;
             #if E_STEPPERS > 2
               case 2: E2_ENABLE_WRITE(oldstatus); break;
               #if E_STEPPERS > 3
                 case 3: E3_ENABLE_WRITE(oldstatus); break;
                 #if E_STEPPERS > 4
                   case 4: E4_ENABLE_WRITE(oldstatus); break;

commit 569df3fc0ccb8b000cc56dd55e6369008ed3f7a2
Author: etagle <ejtagle@hotmail.com>
Date:   Wed May 16 04:08:43 2018 -0300

    Fix interrupt-based endstop detection
    
    - Also implemented real endstop reading on interrupt.

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 8eb02e427f..6f7fc4dae6 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -88,24 +88,20 @@
 
 #if ENABLED(EXPERIMENTAL_I2CBUS)
   #include "feature/twibus.h"
   TWIBus i2c;
 #endif
 
 #if ENABLED(I2C_POSITION_ENCODERS)
   #include "feature/I2CPositionEncoder.h"
 #endif
 
-#if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-  #include HAL_PATH(HAL, endstop_interrupts.h)
-#endif
-
 #if HAS_TRINAMIC
   #include "feature/tmc_util.h"
 #endif
 
 #if ENABLED(SDSUPPORT)
   CardReader card;
 #endif
 
 #if ENABLED(G38_PROBE_TARGET)
   bool G38_move = false,
@@ -741,21 +737,23 @@ void setup() {
     ZERO(current_position);
   #endif
 
   // Vital to init stepper/planner equivalent for current_position
   SYNC_PLAN_POSITION_KINEMATIC();
 
   thermalManager.init();    // Initialize temperature loop
 
   print_job_timer.init();   // Initial setup of print job timer
 
-  stepper.init();    // Initialize stepper, this enables interrupts!
+  endstops.init();          // Init endstops and pullups
+
+  stepper.init();           // Init stepper. This enables interrupts!
 
   #if HAS_SERVOS
     servo_init();
   #endif
 
   #if HAS_Z_SERVO_PROBE
     servo_probe_init();
   #endif
 
   #if HAS_PHOTOGRAPH
@@ -853,24 +851,20 @@ void setup() {
 
   #if ENABLED(I2C_POSITION_ENCODERS)
     I2CPEM.init();
   #endif
 
   #if ENABLED(EXPERIMENTAL_I2CBUS) && I2C_SLAVE_ADDRESS > 0
     i2c.onReceive(i2c_on_receive);
     i2c.onRequest(i2c_on_request);
   #endif
 
-  #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-    setup_endstop_interrupts();
-  #endif
-
   #if DO_SWITCH_EXTRUDER
     move_extruder_servo(0);  // Initialize extruder servo
   #endif
 
   #if ENABLED(SWITCHING_NOZZLE)
     move_nozzle_servo(0);  // Initialize nozzle servo
   #endif
 
   #if ENABLED(PARKING_EXTRUDER)
     pe_magnet_init();

commit a11eb50a3eab6d58d595a67e526fb51190018db3
Author: etagle <ejtagle@hotmail.com>
Date:   Wed May 9 02:17:53 2018 -0300

    Refactor and optimize Stepper/Planner
    
    Better encapsulation and considerably reduce stepper jitter

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 57a38963f9..8eb02e427f 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -262,21 +262,21 @@ bool pin_is_protected(const pin_t pin) {
   static const pin_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++) {
     pin_t sensitive_pin;
     memcpy_P(&sensitive_pin, &sensitive_pins[i], sizeof(pin_t));
     if (pin == sensitive_pin) return true;
   }
   return false;
 }
 
 void quickstop_stepper() {
-  stepper.quick_stop();
+  planner.quick_stop();
   planner.synchronize();
   set_current_from_steppers_for_axis(ALL_AXES);
   SYNC_PLAN_POSITION_KINEMATIC();
 }
 
 void enable_all_steppers() {
   #if ENABLED(AUTO_POWER_CONTROL)
     powerManager.power_on();
   #endif
   enable_X();

commit 3c76bda2d8d1f198a9e6dcb94aca6e383c9d5392
Author: GMagician <GMagician@users.noreply.github.com>
Date:   Fri May 18 20:16:59 2018 +0200

    Fix switching extruder
    
    `DONT_SWITCH` got lost along the way. Replace it with `DO_SWITCH_EXTRUDER` and adjust the code.

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index a8cc78308d..57a38963f9 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -139,21 +139,21 @@
 #endif
 
 #if HAS_CASE_LIGHT
   #include "feature/caselight.h"
 #endif
 
 #if HAS_FANMUX
   #include "feature/fanmux.h"
 #endif
 
-#if (ENABLED(SWITCHING_EXTRUDER) && !DONT_SWITCH) || ENABLED(SWITCHING_NOZZLE) || ENABLED(PARKING_EXTRUDER)
+#if DO_SWITCH_EXTRUDER || ENABLED(SWITCHING_NOZZLE) || ENABLED(PARKING_EXTRUDER)
   #include "module/tool_change.h"
 #endif
 
 #if ENABLED(USE_CONTROLLER_FAN)
   #include "feature/controllerfan.h"
 #endif
 
 bool Running = true;
 
 /**
@@ -857,21 +857,21 @@ void setup() {
 
   #if ENABLED(EXPERIMENTAL_I2CBUS) && I2C_SLAVE_ADDRESS > 0
     i2c.onReceive(i2c_on_receive);
     i2c.onRequest(i2c_on_request);
   #endif
 
   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
     setup_endstop_interrupts();
   #endif
 
-  #if ENABLED(SWITCHING_EXTRUDER) && !DONT_SWITCH
+  #if DO_SWITCH_EXTRUDER
     move_extruder_servo(0);  // Initialize extruder servo
   #endif
 
   #if ENABLED(SWITCHING_NOZZLE)
     move_nozzle_servo(0);  // Initialize nozzle servo
   #endif
 
   #if ENABLED(PARKING_EXTRUDER)
     pe_magnet_init();
   #endif

commit 35258dd50ba09fe6c3d1c8d476c61201bc743254
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 13 17:18:19 2018 -0500

    Consistent heating status and status reset
    
    Fix #10699

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 5e55386380..a8cc78308d 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -830,21 +830,21 @@ void setup() {
     SET_OUTPUT(E_MUX0_PIN);
     SET_OUTPUT(E_MUX1_PIN);
     SET_OUTPUT(E_MUX2_PIN);
   #endif
 
   #if HAS_FANMUX
     fanmux_init();
   #endif
 
   lcd_init();
-  LCD_MESSAGEPGM(WELCOME_MSG);
+  lcd_reset_status();
 
   #if ENABLED(SHOW_BOOTSCREEN)
     lcd_bootscreen();
   #endif
 
   #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
     mixing_tools_init();
   #endif
 
   #if ENABLED(BLTOUCH)

commit 625035a9cefde67da3f9f5933a2ba9e636cef5bb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 12 02:13:40 2018 -0500

    Fix M301 access to lpq_len (#10714)
    
    Co-Authored-By: Zwaubel

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index b3e3cf082e..5e55386380 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -197,24 +197,20 @@ volatile bool wait_for_heatup = true;
 
 // Inactivity shutdown
 millis_t max_inactive_time, // = 0
          stepper_inactive_time = (DEFAULT_STEPPER_DEACTIVE_TIME) * 1000UL;
 
 #ifdef CHDK
   millis_t chdkHigh; // = 0;
   bool chdkActive; // = false;
 #endif
 
-#if ENABLED(PID_EXTRUSION_SCALING)
-  int lpq_len = 20;
-#endif
-
 #if ENABLED(I2C_POSITION_ENCODERS)
   I2CPositionEncodersMgr I2CPEM;
 #endif
 
 /**
  * ***************************************************************************
  * ******************************** FUNCTIONS ********************************
  * ***************************************************************************
  */
 

commit 306f0f2135e4b2aed749a0d1b870abf17d883e38
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 12 01:38:02 2018 -0500

    Move Stepper::synchronize to Planner (#10713)
    
    Co-Authored-By: ejtagle <ejtagle@hotmail.com>

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 870d133f70..b3e3cf082e 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -267,21 +267,21 @@ bool pin_is_protected(const pin_t pin) {
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++) {
     pin_t sensitive_pin;
     memcpy_P(&sensitive_pin, &sensitive_pins[i], sizeof(pin_t));
     if (pin == sensitive_pin) return true;
   }
   return false;
 }
 
 void quickstop_stepper() {
   stepper.quick_stop();
-  stepper.synchronize();
+  planner.synchronize();
   set_current_from_steppers_for_axis(ALL_AXES);
   SYNC_PLAN_POSITION_KINEMATIC();
 }
 
 void enable_all_steppers() {
   #if ENABLED(AUTO_POWER_CONTROL)
     powerManager.power_on();
   #endif
   enable_X();
   enable_Y();
@@ -454,21 +454,21 @@ void manage_inactivity(const bool ignore_stepper_queue/*=false*/) {
             #endif // E_STEPPERS > 2
           #endif // E_STEPPERS > 1
         }
       #endif // !SWITCHING_EXTRUDER
 
       const float olde = current_position[E_AXIS];
       current_position[E_AXIS] += EXTRUDER_RUNOUT_EXTRUDE;
       planner.buffer_line_kinematic(current_position, MMM_TO_MMS(EXTRUDER_RUNOUT_SPEED), active_extruder);
       current_position[E_AXIS] = olde;
       planner.set_e_position_mm(olde);
-      stepper.synchronize();
+      planner.synchronize();
       #if ENABLED(SWITCHING_EXTRUDER)
         E0_ENABLE_WRITE(oldstatus);
       #else
         switch (active_extruder) {
           case 0: E0_ENABLE_WRITE(oldstatus); break;
           #if E_STEPPERS > 1
             case 1: E1_ENABLE_WRITE(oldstatus); break;
             #if E_STEPPERS > 2
               case 2: E2_ENABLE_WRITE(oldstatus); break;
               #if E_STEPPERS > 3

commit 05fca752d6d7b88b7697dd5273b6f0428655f3d5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 1 01:01:02 2018 -0500

    Clean up autostart handling

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 6c9ded576c..870d133f70 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -887,33 +887,31 @@ void setup() {
   #if ENABLED(USE_WATCHDOG) // Reinit watchdog after HAL_get_reset_source call
     watchdog_init();
   #endif
 }
 
 /**
  * The main Marlin program loop
  *
  *  - Save or log commands to SD
  *  - Process available commands (if not saving)
- *  - Call heater manager
- *  - Call inactivity manager
  *  - Call endstop manager
- *  - Call LCD update
+ *  - Call inactivity manager
  */
 void loop() {
 
-  #if ENABLED(SDSUPPORT)
-    card.checkautostart(false);
-  #endif
-
   for (;;) {
 
+    #if ENABLED(SDSUPPORT)
+      card.checkautostart();
+    #endif
+
     #if ENABLED(SDSUPPORT) && ENABLED(ULTIPANEL)
       if (abort_sd_printing) {
         abort_sd_printing = false;
         card.stopSDPrint(
           #if SD_RESORT
             true
           #endif
         );
         clear_command_queue();
         quickstop_stepper();

commit 11ab017dd06bb9d06435dc03469a799d53893493
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Apr 21 19:41:26 2018 -0500

    Creality3D Power-Loss Recovery

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index ce4ffa0db9..6c9ded576c 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -119,20 +119,24 @@
 #endif
 
 #if HAS_LEVELING
   #include "feature/bedlevel/bedlevel.h"
 #endif
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE) && ENABLED(PAUSE_PARK_NO_STEPPER_TIMEOUT)
   #include "feature/pause.h"
 #endif
 
+#if ENABLED(POWER_LOSS_RECOVERY)
+  #include "feature/power_loss_recovery.h"
+#endif
+
 #if ENABLED(FILAMENT_RUNOUT_SENSOR)
   #include "feature/runout.h"
 #endif
 
 #if ENABLED(TEMP_STAT_LEDS)
   #include "feature/leds/tempstat.h"
 #endif
 
 #if HAS_CASE_LIGHT
   #include "feature/caselight.h"
@@ -869,20 +873,24 @@ void setup() {
   #endif
 
   #if ENABLED(SWITCHING_NOZZLE)
     move_nozzle_servo(0);  // Initialize nozzle servo
   #endif
 
   #if ENABLED(PARKING_EXTRUDER)
     pe_magnet_init();
   #endif
 
+  #if ENABLED(POWER_LOSS_RECOVERY)
+    do_print_job_recovery();
+  #endif
+
   #if ENABLED(USE_WATCHDOG) // Reinit watchdog after HAL_get_reset_source call
     watchdog_init();
   #endif
 }
 
 /**
  * The main Marlin program loop
  *
  *  - Save or log commands to SD
  *  - Process available commands (if not saving)

commit 6c7a17dba6bc5b1912ff301f2e18d544badf504a
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Apr 15 18:27:54 2018 -0500

    Abort SD printing more safely (#10407)
    
    Allow the current command to complete when aborting an SD print, otherwise some commands (G28, G29, etc.) will cause trouble.

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 893a8d968b..ce4ffa0db9 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -891,16 +891,36 @@ void setup() {
  *  - Call endstop manager
  *  - Call LCD update
  */
 void loop() {
 
   #if ENABLED(SDSUPPORT)
     card.checkautostart(false);
   #endif
 
   for (;;) {
+
+    #if ENABLED(SDSUPPORT) && ENABLED(ULTIPANEL)
+      if (abort_sd_printing) {
+        abort_sd_printing = false;
+        card.stopSDPrint(
+          #if SD_RESORT
+            true
+          #endif
+        );
+        clear_command_queue();
+        quickstop_stepper();
+        print_job_timer.stop();
+        thermalManager.disable_all_heaters();
+        #if FAN_COUNT > 0
+          for (uint8_t i = 0; i < FAN_COUNT; i++) fanSpeeds[i] = 0;
+        #endif
+        wait_for_heatup = false;
+      }
+    #endif // SDSUPPORT && ULTIPANEL
+
     if (commands_in_queue < BUFSIZE) get_available_commands();
     advance_command_queue();
     endstops.report_state();
     idle();
   }
 }

commit cc6d41e1d3446b54f219afbcf79ee7785079b6fb
Author: Chris Pepper <p3p@p3psoft.co.uk>
Date:   Fri Apr 13 02:25:08 2018 +0100

    Use a macro for HAL header redirection (#10380)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 7648a1a7b3..893a8d968b 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -89,21 +89,21 @@
 #if ENABLED(EXPERIMENTAL_I2CBUS)
   #include "feature/twibus.h"
   TWIBus i2c;
 #endif
 
 #if ENABLED(I2C_POSITION_ENCODERS)
   #include "feature/I2CPositionEncoder.h"
 #endif
 
 #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-  #include "HAL/HAL_endstop_interrupts.h"
+  #include HAL_PATH(HAL, endstop_interrupts.h)
 #endif
 
 #if HAS_TRINAMIC
   #include "feature/tmc_util.h"
 #endif
 
 #if ENABLED(SDSUPPORT)
   CardReader card;
 #endif
 

commit 56486c5c0eabdb8d44ac47babbde192621ee084a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Apr 8 04:00:26 2018 -0500

    Apply const to manage_inactivity

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 61479a8aad..7648a1a7b3 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -319,21 +319,21 @@ void disable_all_steppers() {
  *  - Check for Filament Runout
  *  - Keep the command buffer full
  *  - Check for maximum inactive time between commands
  *  - Check for maximum inactive time between stepper commands
  *  - Check if pin CHDK needs to go LOW
  *  - Check for KILL button held down
  *  - Check for HOME button held down
  *  - Check if cooling fan needs to be switched on
  *  - Check if an idle but hot extruder needs filament extruded (EXTRUDER_RUNOUT_PREVENT)
  */
-void manage_inactivity(bool ignore_stepper_queue/*=false*/) {
+void manage_inactivity(const bool ignore_stepper_queue/*=false*/) {
 
   #if ENABLED(FILAMENT_RUNOUT_SENSOR)
     runout.run();
   #endif
 
   if (commands_in_queue < BUFSIZE) get_available_commands();
 
   const millis_t ms = millis();
 
   if (max_inactive_time && ELAPSED(ms, gcode.previous_move_ms + max_inactive_time)) {

commit 902c885782d389905d5c34c78a19e2be8d7e6cf5
Author: Bob-the-Kuhn <bob.kuhn@att.net>
Date:   Wed Apr 4 20:13:27 2018 -0500

    Switch to TMC2130 compatible hardware SPI & misc (#10299)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 23b7079057..61479a8aad 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -885,21 +885,22 @@ void setup() {
  * The main Marlin program loop
  *
  *  - Save or log commands to SD
  *  - Process available commands (if not saving)
  *  - Call heater manager
  *  - Call inactivity manager
  *  - Call endstop manager
  *  - Call LCD update
  */
 void loop() {
-  if (commands_in_queue < BUFSIZE) get_available_commands();
 
   #if ENABLED(SDSUPPORT)
     card.checkautostart(false);
   #endif
 
-  advance_command_queue();
-
-  endstops.report_state();
-  idle();
+  for (;;) {
+    if (commands_in_queue < BUFSIZE) get_available_commands();
+    advance_command_queue();
+    endstops.report_state();
+    idle();
+  }
 }

commit adcb87f0db47672c28cfec9fda3354adac81fa99
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Apr 1 23:54:12 2018 -0500

    Z Endstop Servo => Z Probe Servo

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 03ff2bac5c..23b7079057 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -747,21 +747,21 @@ void setup() {
   thermalManager.init();    // Initialize temperature loop
 
   print_job_timer.init();   // Initial setup of print job timer
 
   stepper.init();    // Initialize stepper, this enables interrupts!
 
   #if HAS_SERVOS
     servo_init();
   #endif
 
-  #if HAS_Z_SERVO_ENDSTOP
+  #if HAS_Z_SERVO_PROBE
     servo_probe_init();
   #endif
 
   #if HAS_PHOTOGRAPH
     OUT_WRITE(PHOTOGRAPH_PIN, LOW);
   #endif
 
   #if HAS_CASE_LIGHT
     update_case_light();
   #endif

commit 1cb810ff1c04065daa29182a6c22ecf6b0c0098b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 21 19:30:06 2018 -0500

    [2.0.x] Automatically reset stepper timeout (#10179)
    
    * Automatically reset stepper timeout in manage_inactivity
    
    Any code that adds moves to the planner can skip resetting the stepper timeout. We can let `idle` / `manage_inactivity` reset the timer whenever it detects any moves in the planner.
    
    * blocks_queued => has_blocks_queued

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index c7ee0f407d..03ff2bac5c 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -329,50 +329,53 @@ void disable_all_steppers() {
 void manage_inactivity(bool ignore_stepper_queue/*=false*/) {
 
   #if ENABLED(FILAMENT_RUNOUT_SENSOR)
     runout.run();
   #endif
 
   if (commands_in_queue < BUFSIZE) get_available_commands();
 
   const millis_t ms = millis();
 
-  if (max_inactive_time && ELAPSED(ms, gcode.previous_cmd_ms + max_inactive_time)) {
+  if (max_inactive_time && ELAPSED(ms, gcode.previous_move_ms + max_inactive_time)) {
     SERIAL_ERROR_START();
     SERIAL_ECHOLNPAIR(MSG_KILL_INACTIVE_TIME, parser.command_ptr);
     kill(PSTR(MSG_KILLED));
   }
 
   // Prevent steppers timing-out in the middle of M600
   #if ENABLED(ADVANCED_PAUSE_FEATURE) && ENABLED(PAUSE_PARK_NO_STEPPER_TIMEOUT)
     #define MOVE_AWAY_TEST !did_pause_print
   #else
     #define MOVE_AWAY_TEST true
   #endif
 
-  if (MOVE_AWAY_TEST && stepper_inactive_time && ELAPSED(ms, gcode.previous_cmd_ms + stepper_inactive_time)
-      && !ignore_stepper_queue && !planner.blocks_queued()) {
-    #if ENABLED(DISABLE_INACTIVE_X)
-      disable_X();
-    #endif
-    #if ENABLED(DISABLE_INACTIVE_Y)
-      disable_Y();
-    #endif
-    #if ENABLED(DISABLE_INACTIVE_Z)
-      disable_Z();
-    #endif
-    #if ENABLED(DISABLE_INACTIVE_E)
-      disable_e_steppers();
-    #endif
-    #if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(ULTIPANEL)  // Only needed with an LCD
-      if (ubl.lcd_map_control) ubl.lcd_map_control = defer_return_to_status = false;
-    #endif
+  if (stepper_inactive_time) {
+    if (planner.has_blocks_queued())
+      gcode.previous_move_ms = ms; // reset_stepper_timeout to keep steppers powered
+    else if (MOVE_AWAY_TEST && !ignore_stepper_queue && ELAPSED(ms, gcode.previous_move_ms + stepper_inactive_time)) {
+      #if ENABLED(DISABLE_INACTIVE_X)
+        disable_X();
+      #endif
+      #if ENABLED(DISABLE_INACTIVE_Y)
+        disable_Y();
+      #endif
+      #if ENABLED(DISABLE_INACTIVE_Z)
+        disable_Z();
+      #endif
+      #if ENABLED(DISABLE_INACTIVE_E)
+        disable_e_steppers();
+      #endif
+      #if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(ULTIPANEL)  // Only needed with an LCD
+        if (ubl.lcd_map_control) ubl.lcd_map_control = defer_return_to_status = false;
+      #endif
+    }
   }
 
   #ifdef CHDK // Check if pin should be set to LOW after M240 set it to HIGH
     if (chdkActive && ELAPSED(ms, chdkHigh + CHDK_DELAY)) {
       chdkActive = false;
       WRITE(CHDK, LOW);
     }
   #endif
 
   #if HAS_KILL
@@ -417,22 +420,22 @@ void manage_inactivity(bool ignore_stepper_queue/*=false*/) {
   #if ENABLED(USE_CONTROLLER_FAN)
     controllerfan_update(); // Check if fan should be turned on to cool stepper drivers down
   #endif
 
   #if ENABLED(AUTO_POWER_CONTROL)
     powerManager.check();
   #endif
 
   #if ENABLED(EXTRUDER_RUNOUT_PREVENT)
     if (thermalManager.degHotend(active_extruder) > EXTRUDER_RUNOUT_MINTEMP
-      && ELAPSED(ms, gcode.previous_cmd_ms + (EXTRUDER_RUNOUT_SECONDS) * 1000UL)
-      && !planner.blocks_queued()
+      && ELAPSED(ms, gcode.previous_move_ms + (EXTRUDER_RUNOUT_SECONDS) * 1000UL)
+      && !planner.has_blocks_queued()
     ) {
       #if ENABLED(SWITCHING_EXTRUDER)
         const bool oldstatus = E0_ENABLE_READ;
         enable_E0();
       #else // !SWITCHING_EXTRUDER
         bool oldstatus;
         switch (active_extruder) {
           default: oldstatus = E0_ENABLE_READ; enable_E0(); break;
           #if E_STEPPERS > 1
             case 1: oldstatus = E1_ENABLE_READ; enable_E1(); break;
@@ -442,22 +445,20 @@ void manage_inactivity(bool ignore_stepper_queue/*=false*/) {
                 case 3: oldstatus = E3_ENABLE_READ; enable_E3(); break;
                 #if E_STEPPERS > 4
                   case 4: oldstatus = E4_ENABLE_READ; enable_E4(); break;
                 #endif // E_STEPPERS > 4
               #endif // E_STEPPERS > 3
             #endif // E_STEPPERS > 2
           #endif // E_STEPPERS > 1
         }
       #endif // !SWITCHING_EXTRUDER
 
-      gcode.refresh_cmd_timeout();
-
       const float olde = current_position[E_AXIS];
       current_position[E_AXIS] += EXTRUDER_RUNOUT_EXTRUDE;
       planner.buffer_line_kinematic(current_position, MMM_TO_MMS(EXTRUDER_RUNOUT_SPEED), active_extruder);
       current_position[E_AXIS] = olde;
       planner.set_e_position_mm(olde);
       stepper.synchronize();
       #if ENABLED(SWITCHING_EXTRUDER)
         E0_ENABLE_WRITE(oldstatus);
       #else
         switch (active_extruder) {
@@ -469,20 +470,22 @@ void manage_inactivity(bool ignore_stepper_queue/*=false*/) {
               #if E_STEPPERS > 3
                 case 3: E3_ENABLE_WRITE(oldstatus); break;
                 #if E_STEPPERS > 4
                   case 4: E4_ENABLE_WRITE(oldstatus); break;
                 #endif // E_STEPPERS > 4
               #endif // E_STEPPERS > 3
             #endif // E_STEPPERS > 2
           #endif // E_STEPPERS > 1
         }
       #endif // !SWITCHING_EXTRUDER
+
+      gcode.previous_move_ms = ms; // reset_stepper_timeout to keep steppers powered
     }
   #endif // EXTRUDER_RUNOUT_PREVENT
 
   #if ENABLED(DUAL_X_CARRIAGE)
     // handle delayed move timeout
     if (delayed_move_time && ELAPSED(ms, delayed_move_time + 1000UL) && IsRunning()) {
       // travel moves have been received so enact them
       delayed_move_time = 0xFFFFFFFFUL; // force moves to be done
       set_destination_from_current();
       prepare_move_to_destination();
@@ -534,21 +537,21 @@ void idle(
   #if ENABLED(PRINTCOUNTER)
     print_job_timer.tick();
   #endif
 
   #if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER)
     buzzer.tick();
   #endif
 
   #if ENABLED(I2C_POSITION_ENCODERS)
     static millis_t i2cpem_next_update_ms;
-    if (planner.blocks_queued() && ELAPSED(millis(), i2cpem_next_update_ms)) {
+    if (planner.has_blocks_queued() && ELAPSED(millis(), i2cpem_next_update_ms)) {
       I2CPEM.update();
       i2cpem_next_update_ms = millis() + I2CPE_MIN_UPD_TIME_MS;
     }
   #endif
 
   #ifdef HAL_IDLETASK
     HAL_idletask();
   #endif
 
   #if HAS_AUTO_REPORTING

commit 97e8a6ebd972ce0ad5b4e27aa139b9bb074ff44e
Author: Eduardo José Tagle <ejtagle@hotmail.com>
Date:   Wed Mar 21 21:04:45 2018 -0300

    Various fixes for DUE... (#10152)
    
    - Watchdog reset during SD Card initialization.
    - Move `DebugMonitor` to `DebugMonitor_Due.cpp`.
    - Since the watchdog is enabled on boot do extra resets during init.
    - Have `thermalManager` do watchdog reset before its ISR starts to prevent reset.
    - Ensure that timers are stopped before reprogramming them to address tone issues.
    - Improve SAM3XE reset when reflashed through the native port.

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 41672e9aae..c7ee0f407d 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -641,23 +641,20 @@ void stop() {
  *    • servos
  *    • LCD controller
  *    • Digipot I2C
  *    • Z probe sled
  *    • status LEDs
  */
 void setup() {
 
   #ifdef HAL_INIT
     HAL_init();
-    #if defined(ARDUINO_ARCH_SAM) && PIN_EXISTS(BEEPER) && ENABLED(SPEAKER)
-      toneInit();
-    #endif
   #endif
 
   #if ENABLED(MAX7219_DEBUG)
     Max7219_init();
   #endif
 
   #if ENABLED(DISABLE_JTAG)
     // Disable JTAG on AT90USB chips to free up pins for IO
     MCUCR = 0x80;
     MCUCR = 0x80;

commit 9fd1016bb1ddb21e2c736da9fbdd802708b91b96
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 21 05:45:23 2018 -0500

    Trust the bootloader to clear globals

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 7317fb4b43..41672e9aae 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -167,44 +167,44 @@ bool axis_homed[XYZ] = { false }, axis_known_position[XYZ] = { false };
   TempUnit input_temp_units = TEMPUNIT_C;
 #endif
 
 #if FAN_COUNT > 0
   int16_t fanSpeeds[FAN_COUNT] = { 0 };
   #if ENABLED(EXTRA_FAN_SPEED)
     int16_t old_fanSpeeds[FAN_COUNT],
             new_fanSpeeds[FAN_COUNT];
   #endif
   #if ENABLED(PROBING_FANS_OFF)
-    bool fans_paused = false;
+    bool fans_paused; // = false;
     int16_t paused_fanSpeeds[FAN_COUNT] = { 0 };
   #endif
 #endif
 
 // For M109 and M190, this flag may be cleared (by M108) to exit the wait loop
 volatile bool wait_for_heatup = true;
 
 // For M0/M1, this flag may be cleared (by M108) to exit the wait-for-user loop
 #if HAS_RESUME_CONTINUE
-  volatile bool wait_for_user = false;
+  volatile bool wait_for_user; // = false;
 #endif
 
 #if HAS_AUTO_REPORTING || ENABLED(HOST_KEEPALIVE_FEATURE)
   bool suspend_auto_report; // = false
 #endif
 
 // Inactivity shutdown
-millis_t max_inactive_time = 0,
+millis_t max_inactive_time, // = 0
          stepper_inactive_time = (DEFAULT_STEPPER_DEACTIVE_TIME) * 1000UL;
 
 #ifdef CHDK
-  millis_t chdkHigh = 0;
-  bool chdkActive = false;
+  millis_t chdkHigh; // = 0;
+  bool chdkActive; // = false;
 #endif
 
 #if ENABLED(PID_EXTRUSION_SCALING)
   int lpq_len = 20;
 #endif
 
 #if ENABLED(I2C_POSITION_ENCODERS)
   I2CPositionEncodersMgr I2CPEM;
 #endif
 

commit ae39fbd646829b33f0ec6d181bcdc0bdc61f0b19
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 21 00:29:09 2018 -0500

    Also suppress keepalive with suspend_auto_report

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 5ffd30f539..7317fb4b43 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -180,21 +180,21 @@ bool axis_homed[XYZ] = { false }, axis_known_position[XYZ] = { false };
 #endif
 
 // For M109 and M190, this flag may be cleared (by M108) to exit the wait loop
 volatile bool wait_for_heatup = true;
 
 // For M0/M1, this flag may be cleared (by M108) to exit the wait-for-user loop
 #if HAS_RESUME_CONTINUE
   volatile bool wait_for_user = false;
 #endif
 
-#if HAS_AUTO_REPORTING
+#if HAS_AUTO_REPORTING || ENABLED(HOST_KEEPALIVE_FEATURE)
   bool suspend_auto_report; // = false
 #endif
 
 // Inactivity shutdown
 millis_t max_inactive_time = 0,
          stepper_inactive_time = (DEFAULT_STEPPER_DEACTIVE_TIME) * 1000UL;
 
 #ifdef CHDK
   millis_t chdkHigh = 0;
   bool chdkActive = false;

commit 53362b81cceba396c11c98e71eb96fb5ec77d6fd
Author: Bob-the-Kuhn <bob.kuhn@att.net>
Date:   Mon Mar 19 04:48:06 2018 -0500

    Tone fixes/changes (#10151)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index c70988fadf..5ffd30f539 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -641,21 +641,21 @@ void stop() {
  *    • servos
  *    • LCD controller
  *    • Digipot I2C
  *    • Z probe sled
  *    • status LEDs
  */
 void setup() {
 
   #ifdef HAL_INIT
     HAL_init();
-    #if defined(ARDUINO_ARCH_SAM) && PIN_EXISTS(BEEPER)
+    #if defined(ARDUINO_ARCH_SAM) && PIN_EXISTS(BEEPER) && ENABLED(SPEAKER)
       toneInit();
     #endif
   #endif
 
   #if ENABLED(MAX7219_DEBUG)
     Max7219_init();
   #endif
 
   #if ENABLED(DISABLE_JTAG)
     // Disable JTAG on AT90USB chips to free up pins for IO

commit 72281c4ff968ac6d7edcb1546619baff29247aa5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Mar 18 20:58:10 2018 -0500

    Turn power off in `kill` instead of setting PS_ON to input

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 8c51534bc2..c70988fadf 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -584,21 +584,21 @@ void kill(const char* lcd_msg) {
   cli(); // Stop interrupts
 
   _delay_ms(250); //Wait to ensure all interrupts routines stopped
   thermalManager.disable_all_heaters(); //turn off heaters again
 
   #ifdef ACTION_ON_KILL
     SERIAL_ECHOLNPGM("//action:" ACTION_ON_KILL);
   #endif
 
   #if HAS_POWER_SWITCH
-    SET_INPUT(PS_ON_PIN);
+    PSU_OFF();
   #endif
 
   #if HAS_SUICIDE
     suicide();
   #endif
 
   while (1) {
     #if ENABLED(USE_WATCHDOG)
       watchdog_reset();
     #endif

commit 0543362b34920d87f26078a84d94e1846ff990dd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Mar 17 18:34:16 2018 -0500

    Don't init the tone timer if no BEEPER_PIN

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 46ad0c093f..8c51534bc2 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -641,21 +641,21 @@ void stop() {
  *    • servos
  *    • LCD controller
  *    • Digipot I2C
  *    • Z probe sled
  *    • status LEDs
  */
 void setup() {
 
   #ifdef HAL_INIT
     HAL_init();
-    #ifdef ARDUINO_ARCH_SAM
+    #if defined(ARDUINO_ARCH_SAM) && PIN_EXISTS(BEEPER)
       toneInit();
     #endif
   #endif
 
   #if ENABLED(MAX7219_DEBUG)
     Max7219_init();
   #endif
 
   #if ENABLED(DISABLE_JTAG)
     // Disable JTAG on AT90USB chips to free up pins for IO

commit 317673fec37f89e5e167f0d7a70c0d99e45fed0b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Mar 8 17:34:50 2018 -0600

    Init watchdog last in setup()

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index d1181551bd..46ad0c093f 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -703,24 +703,20 @@ void setup() {
 
   // Check startup - does nothing if bootloader sets MCUSR to 0
   byte mcu = HAL_get_reset_source();
   if (mcu &  1) SERIAL_ECHOLNPGM(MSG_POWERUP);
   if (mcu &  2) SERIAL_ECHOLNPGM(MSG_EXTERNAL_RESET);
   if (mcu &  4) SERIAL_ECHOLNPGM(MSG_BROWNOUT_RESET);
   if (mcu &  8) SERIAL_ECHOLNPGM(MSG_WATCHDOG_RESET);
   if (mcu & 32) SERIAL_ECHOLNPGM(MSG_SOFTWARE_RESET);
   HAL_clear_reset_source();
 
-  #if ENABLED(USE_WATCHDOG) //reinit watchdog after HAL_get_reset_source call
-    watchdog_init();
-  #endif
-
   SERIAL_ECHOPGM(MSG_MARLIN);
   SERIAL_CHAR(' ');
   SERIAL_ECHOLNPGM(SHORT_BUILD_VERSION);
   SERIAL_EOL();
 
   #if defined(STRING_DISTRIBUTION_DATE) && defined(STRING_CONFIG_H_AUTHOR)
     SERIAL_ECHO_START();
     SERIAL_ECHOPGM(MSG_CONFIGURATION_VER);
     SERIAL_ECHOPGM(STRING_DISTRIBUTION_DATE);
     SERIAL_ECHOLNPGM(MSG_AUTHOR STRING_CONFIG_H_AUTHOR);
@@ -872,20 +868,24 @@ void setup() {
     move_extruder_servo(0);  // Initialize extruder servo
   #endif
 
   #if ENABLED(SWITCHING_NOZZLE)
     move_nozzle_servo(0);  // Initialize nozzle servo
   #endif
 
   #if ENABLED(PARKING_EXTRUDER)
     pe_magnet_init();
   #endif
+
+  #if ENABLED(USE_WATCHDOG) // Reinit watchdog after HAL_get_reset_source call
+    watchdog_init();
+  #endif
 }
 
 /**
  * The main Marlin program loop
  *
  *  - Save or log commands to SD
  *  - Process available commands (if not saving)
  *  - Call heater manager
  *  - Call inactivity manager
  *  - Call endstop manager

commit eb212ae073bc0fdcb5723a34b13cf9201ce537dc
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 7 01:57:09 2018 -0600

    Add suspend_auto_report flag to suppress auto-report

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 89a4d47b10..d1181551bd 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -180,20 +180,24 @@ bool axis_homed[XYZ] = { false }, axis_known_position[XYZ] = { false };
 #endif
 
 // For M109 and M190, this flag may be cleared (by M108) to exit the wait loop
 volatile bool wait_for_heatup = true;
 
 // For M0/M1, this flag may be cleared (by M108) to exit the wait-for-user loop
 #if HAS_RESUME_CONTINUE
   volatile bool wait_for_user = false;
 #endif
 
+#if HAS_AUTO_REPORTING
+  bool suspend_auto_report; // = false
+#endif
+
 // Inactivity shutdown
 millis_t max_inactive_time = 0,
          stepper_inactive_time = (DEFAULT_STEPPER_DEACTIVE_TIME) * 1000UL;
 
 #ifdef CHDK
   millis_t chdkHigh = 0;
   bool chdkActive = false;
 #endif
 
 #if ENABLED(PID_EXTRUSION_SCALING)
@@ -512,24 +516,20 @@ void idle(
   #if ENABLED(MAX7219_DEBUG)
     Max7219_idle_tasks();
   #endif  // MAX7219_DEBUG
 
   lcd_update();
 
   #if ENABLED(HOST_KEEPALIVE_FEATURE)
     gcode.host_keepalive();
   #endif
 
-  #if ENABLED(AUTO_REPORT_TEMPERATURES) && HAS_TEMP_SENSOR
-    thermalManager.auto_report_temperatures();
-  #endif
-
   manage_inactivity(
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
       no_stepper_sleep
     #endif
   );
 
   thermalManager.manage_heater();
 
   #if ENABLED(PRINTCOUNTER)
     print_job_timer.tick();
@@ -540,27 +540,34 @@ void idle(
   #endif
 
   #if ENABLED(I2C_POSITION_ENCODERS)
     static millis_t i2cpem_next_update_ms;
     if (planner.blocks_queued() && ELAPSED(millis(), i2cpem_next_update_ms)) {
       I2CPEM.update();
       i2cpem_next_update_ms = millis() + I2CPE_MIN_UPD_TIME_MS;
     }
   #endif
 
-  #if ENABLED(AUTO_REPORT_SD_STATUS)
-    card.auto_report_sd_status();
-  #endif
-
   #ifdef HAL_IDLETASK
     HAL_idletask();
   #endif
+
+  #if HAS_AUTO_REPORTING
+    if (!suspend_auto_report) {
+      #if ENABLED(AUTO_REPORT_TEMPERATURES)
+        thermalManager.auto_report_temperatures();
+      #endif
+      #if ENABLED(AUTO_REPORT_SD_STATUS)
+        card.auto_report_sd_status();
+      #endif
+    }
+  #endif
 }
 
 /**
  * Kill all activity and lock the machine.
  * After this the machine will need to be reset.
  */
 void kill(const char* lcd_msg) {
   SERIAL_ERROR_START();
   SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
 

commit ffbf63e6afb7728849d434ccfda89e3fd8b37094
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 7 01:53:50 2018 -0600

    Add HAS_TEMP_SENSOR conditional

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index b8c0255365..89a4d47b10 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -512,21 +512,21 @@ void idle(
   #if ENABLED(MAX7219_DEBUG)
     Max7219_idle_tasks();
   #endif  // MAX7219_DEBUG
 
   lcd_update();
 
   #if ENABLED(HOST_KEEPALIVE_FEATURE)
     gcode.host_keepalive();
   #endif
 
-  #if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND || HAS_TEMP_BED)
+  #if ENABLED(AUTO_REPORT_TEMPERATURES) && HAS_TEMP_SENSOR
     thermalManager.auto_report_temperatures();
   #endif
 
   manage_inactivity(
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
       no_stepper_sleep
     #endif
   );
 
   thermalManager.manage_heater();

commit 36262a0479df7ee997185d9dddef1b674137ffb1
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Mar 4 21:23:43 2018 -0600

    Use static classes for job timers (#9938)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 167339ec6c..b8c0255365 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -723,37 +723,35 @@ void setup() {
 
   SERIAL_ECHO_START();
   SERIAL_ECHOPAIR(MSG_FREE_MEMORY, freeMemory());
   SERIAL_ECHOLNPAIR(MSG_PLANNER_BUFFER_BYTES, (int)sizeof(block_t)*BLOCK_BUFFER_SIZE);
 
   queue_setup();
 
   // Load data from EEPROM if available (or use defaults)
   // This also updates variables in the planner, elsewhere
   (void)settings.load();
-  
-  #if ENABLED(PRINTCOUNTER)
-    print_job_timer.init();
-  #endif  
-  
+
   #if HAS_M206_COMMAND
     // Initialize current position based on home_offset
     COPY(current_position, home_offset);
   #else
     ZERO(current_position);
   #endif
 
   // Vital to init stepper/planner equivalent for current_position
   SYNC_PLAN_POSITION_KINEMATIC();
 
   thermalManager.init();    // Initialize temperature loop
 
+  print_job_timer.init();   // Initial setup of print job timer
+
   stepper.init();    // Initialize stepper, this enables interrupts!
 
   #if HAS_SERVOS
     servo_init();
   #endif
 
   #if HAS_Z_SERVO_ENDSTOP
     servo_probe_init();
   #endif
 

commit 025118da3ef925df53f2817bf401d3aac1c0f7db
Author: Bob-the-Kuhn <bob.kuhn@att.net>
Date:   Sun Mar 4 16:12:30 2018 -0600

    Init print_job_timer in setup() instead of "early" (#9937)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 49745ed3be..167339ec6c 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -723,21 +723,25 @@ void setup() {
 
   SERIAL_ECHO_START();
   SERIAL_ECHOPAIR(MSG_FREE_MEMORY, freeMemory());
   SERIAL_ECHOLNPAIR(MSG_PLANNER_BUFFER_BYTES, (int)sizeof(block_t)*BLOCK_BUFFER_SIZE);
 
   queue_setup();
 
   // Load data from EEPROM if available (or use defaults)
   // This also updates variables in the planner, elsewhere
   (void)settings.load();
-
+  
+  #if ENABLED(PRINTCOUNTER)
+    print_job_timer.init();
+  #endif  
+  
   #if HAS_M206_COMMAND
     // Initialize current position based on home_offset
     COPY(current_position, home_offset);
   #else
     ZERO(current_position);
   #endif
 
   // Vital to init stepper/planner equivalent for current_position
   SYNC_PLAN_POSITION_KINEMATIC();
 

commit eb079959fb320f99cfa885e576fed23e7aa3354f
Author: TheSFReader <TheSFReader@gmail.com>
Date:   Mon Feb 26 22:38:27 2018 +0100

    Report sd card progress [FR]  #9751 (#9832)
    
    * SD Status auto-report feature
    Feature Request #9751

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 6ec646498b..49745ed3be 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -540,20 +540,24 @@ void idle(
   #endif
 
   #if ENABLED(I2C_POSITION_ENCODERS)
     static millis_t i2cpem_next_update_ms;
     if (planner.blocks_queued() && ELAPSED(millis(), i2cpem_next_update_ms)) {
       I2CPEM.update();
       i2cpem_next_update_ms = millis() + I2CPE_MIN_UPD_TIME_MS;
     }
   #endif
 
+  #if ENABLED(AUTO_REPORT_SD_STATUS)
+    card.auto_report_sd_status();
+  #endif
+
   #ifdef HAL_IDLETASK
     HAL_idletask();
   #endif
 }
 
 /**
  * Kill all activity and lock the machine.
  * After this the machine will need to be reset.
  */
 void kill(const char* lcd_msg) {

commit cfdcf91df5cb36e831eabbc448159cf768243797
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 26 01:49:33 2018 -0600

    Fix compile error with initTone

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index fd2fb26078..6ec646498b 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -630,20 +630,23 @@ void stop() {
  *    • servos
  *    • LCD controller
  *    • Digipot I2C
  *    • Z probe sled
  *    • status LEDs
  */
 void setup() {
 
   #ifdef HAL_INIT
     HAL_init();
+    #ifdef ARDUINO_ARCH_SAM
+      toneInit();
+    #endif
   #endif
 
   #if ENABLED(MAX7219_DEBUG)
     Max7219_init();
   #endif
 
   #if ENABLED(DISABLE_JTAG)
     // Disable JTAG on AT90USB chips to free up pins for IO
     MCUCR = 0x80;
     MCUCR = 0x80;

commit 65519263f4d2f654296c10f380a4a3258a0b0570
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Feb 23 09:13:34 2018 -0600

    Fix broken LEVEL_BED_CORNERS
    
    Fix #8805

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index ddfb0232d9..fd2fb26078 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -353,21 +353,21 @@ void manage_inactivity(bool ignore_stepper_queue/*=false*/) {
     #if ENABLED(DISABLE_INACTIVE_Y)
       disable_Y();
     #endif
     #if ENABLED(DISABLE_INACTIVE_Z)
       disable_Z();
     #endif
     #if ENABLED(DISABLE_INACTIVE_E)
       disable_e_steppers();
     #endif
     #if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(ULTIPANEL)  // Only needed with an LCD
-      ubl.lcd_map_control = defer_return_to_status = false;
+      if (ubl.lcd_map_control) ubl.lcd_map_control = defer_return_to_status = false;
     #endif
   }
 
   #ifdef CHDK // Check if pin should be set to LOW after M240 set it to HIGH
     if (chdkActive && ELAPSED(ms, chdkHigh + CHDK_DELAY)) {
       chdkActive = false;
       WRITE(CHDK, LOW);
     }
   #endif
 

commit 73cd34b121023feb9cff4faec505138013a6b232
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 19 16:12:04 2018 -0600

    Finish AUTO_POWER_CONTROL implementation
    
    Followup to #9503

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 671fd00702..ddfb0232d9 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -265,20 +265,23 @@ bool pin_is_protected(const pin_t pin) {
 }
 
 void quickstop_stepper() {
   stepper.quick_stop();
   stepper.synchronize();
   set_current_from_steppers_for_axis(ALL_AXES);
   SYNC_PLAN_POSITION_KINEMATIC();
 }
 
 void enable_all_steppers() {
+  #if ENABLED(AUTO_POWER_CONTROL)
+    powerManager.power_on();
+  #endif
   enable_X();
   enable_Y();
   enable_Z();
   enable_E0();
   enable_E1();
   enable_E2();
   enable_E3();
   enable_E4();
 }
 
@@ -404,20 +407,24 @@ void manage_inactivity(bool ignore_stepper_queue/*=false*/) {
         homeDebounceCount++;
       else
         homeDebounceCount = 0;
     }
   #endif
 
   #if ENABLED(USE_CONTROLLER_FAN)
     controllerfan_update(); // Check if fan should be turned on to cool stepper drivers down
   #endif
 
+  #if ENABLED(AUTO_POWER_CONTROL)
+    powerManager.check();
+  #endif
+
   #if ENABLED(EXTRUDER_RUNOUT_PREVENT)
     if (thermalManager.degHotend(active_extruder) > EXTRUDER_RUNOUT_MINTEMP
       && ELAPSED(ms, gcode.previous_cmd_ms + (EXTRUDER_RUNOUT_SECONDS) * 1000UL)
       && !planner.blocks_queued()
     ) {
       #if ENABLED(SWITCHING_EXTRUDER)
         const bool oldstatus = E0_ENABLE_READ;
         enable_E0();
       #else // !SWITCHING_EXTRUDER
         bool oldstatus;

commit d3ca82d8c24b94a0073d5839ddca6569a6d013a1
Author: Studiodyne <diabolomix@hotmail.fr>
Date:   Sun Feb 18 09:42:09 2018 +0100

    Support for multiple filament runout sensors

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index a85e3a6fd5..671fd00702 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -209,34 +209,20 @@ millis_t max_inactive_time = 0,
  * ******************************** FUNCTIONS ********************************
  * ***************************************************************************
  */
 
 void setup_killpin() {
   #if HAS_KILL
     SET_INPUT_PULLUP(KILL_PIN);
   #endif
 }
 
-#if ENABLED(FILAMENT_RUNOUT_SENSOR)
-
-  void setup_filrunoutpin() {
-    #if ENABLED(FIL_RUNOUT_PULLUP)
-      SET_INPUT_PULLUP(FIL_RUNOUT_PIN);
-    #elif ENABLED(FIL_RUNOUT_PULLDOWN)
-      SET_INPUT_PULLDOWN(FIL_RUNOUT_PIN);
-    #else
-      SET_INPUT(FIL_RUNOUT_PIN);
-    #endif
-  }
-
-#endif
-
 void setup_powerhold() {
   #if HAS_SUICIDE
     OUT_WRITE(SUICIDE_PIN, HIGH);
   #endif
   #if HAS_POWER_SWITCH
     #if ENABLED(PS_DEFAULT_OFF)
       PSU_OFF();
     #else
       PSU_ON();
     #endif
@@ -329,25 +315,21 @@ void disable_all_steppers() {
  *  - Check for maximum inactive time between stepper commands
  *  - Check if pin CHDK needs to go LOW
  *  - Check for KILL button held down
  *  - Check for HOME button held down
  *  - Check if cooling fan needs to be switched on
  *  - Check if an idle but hot extruder needs filament extruded (EXTRUDER_RUNOUT_PREVENT)
  */
 void manage_inactivity(bool ignore_stepper_queue/*=false*/) {
 
   #if ENABLED(FILAMENT_RUNOUT_SENSOR)
-    if ((IS_SD_PRINTING || print_job_timer.isRunning())
-      && READ(FIL_RUNOUT_PIN) == FIL_RUNOUT_INVERTING
-      && thermalManager.targetHotEnoughToExtrude(active_extruder)
-    )
-      handle_filament_runout();
+    runout.run();
   #endif
 
   if (commands_in_queue < BUFSIZE) get_available_commands();
 
   const millis_t ms = millis();
 
   if (max_inactive_time && ELAPSED(ms, gcode.previous_cmd_ms + max_inactive_time)) {
     SERIAL_ERROR_START();
     SERIAL_ECHOLNPAIR(MSG_KILL_INACTIVE_TIME, parser.command_ptr);
     kill(PSTR(MSG_KILLED));
@@ -654,21 +636,21 @@ void setup() {
     Max7219_init();
   #endif
 
   #if ENABLED(DISABLE_JTAG)
     // Disable JTAG on AT90USB chips to free up pins for IO
     MCUCR = 0x80;
     MCUCR = 0x80;
   #endif
 
   #if ENABLED(FILAMENT_RUNOUT_SENSOR)
-    setup_filrunoutpin();
+    runout.setup();
   #endif
 
   setup_killpin();
 
   setup_powerhold();
 
   #if HAS_STEPPER_RESET
     disableStepperDrivers();
   #endif
 

commit ca55f2927ab7416c6f404cfdeade4c9d5103929c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Feb 18 19:26:23 2018 -0600

    Pulldown pin mode support (#9701)
    
    Implemented for LPC1768.

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index b53c2e35c0..a85e3a6fd5 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -212,22 +212,24 @@ millis_t max_inactive_time = 0,
 
 void setup_killpin() {
   #if HAS_KILL
     SET_INPUT_PULLUP(KILL_PIN);
   #endif
 }
 
 #if ENABLED(FILAMENT_RUNOUT_SENSOR)
 
   void setup_filrunoutpin() {
-    #if ENABLED(ENDSTOPPULLUP_FIL_RUNOUT)
+    #if ENABLED(FIL_RUNOUT_PULLUP)
       SET_INPUT_PULLUP(FIL_RUNOUT_PIN);
+    #elif ENABLED(FIL_RUNOUT_PULLDOWN)
+      SET_INPUT_PULLDOWN(FIL_RUNOUT_PIN);
     #else
       SET_INPUT(FIL_RUNOUT_PIN);
     #endif
   }
 
 #endif
 
 void setup_powerhold() {
   #if HAS_SUICIDE
     OUT_WRITE(SUICIDE_PIN, HIGH);

commit 93c0198b2dec4497c42d20cd01a6dac909416da7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Feb 14 05:09:44 2018 -0600

    Init LCD welcome message programmatically

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 18e3a2c70d..b53c2e35c0 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -827,20 +827,21 @@ void setup() {
     SET_OUTPUT(E_MUX0_PIN);
     SET_OUTPUT(E_MUX1_PIN);
     SET_OUTPUT(E_MUX2_PIN);
   #endif
 
   #if HAS_FANMUX
     fanmux_init();
   #endif
 
   lcd_init();
+  LCD_MESSAGEPGM(WELCOME_MSG);
 
   #if ENABLED(SHOW_BOOTSCREEN)
     lcd_bootscreen();
   #endif
 
   #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
     mixing_tools_init();
   #endif
 
   #if ENABLED(BLTOUCH)

commit 5990266724eb79536cb6d0d72b6130aebba2cbba
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Sat Feb 10 22:08:53 2018 +0200

    Init CS pins before loading settings (#9566)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index d9c5c9b457..18e3a2c70d 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -682,20 +682,27 @@ void setup() {
     while(!MYSERIAL0 && PENDING(millis(), serial_connect_timeout)) { /*nada*/ }
     #if NUM_SERIAL > 1
       serial_connect_timeout = millis() + 1000UL;
       while(!MYSERIAL1 && PENDING(millis(), serial_connect_timeout)) { /*nada*/ }
     #endif
   #endif
 
   SERIAL_PROTOCOLLNPGM("start");
   SERIAL_ECHO_START();
 
+  #if ENABLED(HAVE_TMC2130)
+    tmc_init_cs_pins();
+  #endif
+  #if ENABLED(HAVE_TMC2208)
+    tmc2208_serial_begin();
+  #endif
+
   // Check startup - does nothing if bootloader sets MCUSR to 0
   byte mcu = HAL_get_reset_source();
   if (mcu &  1) SERIAL_ECHOLNPGM(MSG_POWERUP);
   if (mcu &  2) SERIAL_ECHOLNPGM(MSG_EXTERNAL_RESET);
   if (mcu &  4) SERIAL_ECHOLNPGM(MSG_BROWNOUT_RESET);
   if (mcu &  8) SERIAL_ECHOLNPGM(MSG_WATCHDOG_RESET);
   if (mcu & 32) SERIAL_ECHOLNPGM(MSG_SOFTWARE_RESET);
   HAL_clear_reset_source();
 
   #if ENABLED(USE_WATCHDOG) //reinit watchdog after HAL_get_reset_source call

commit 112917cfef8dfff360cb60f930a2c34dae471f95
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Feb 9 03:32:40 2018 -0600

    No EXTRUDER_RUNOUT_PREVENT during print

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 177e424f2d..d9c5c9b457 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -421,22 +421,24 @@ void manage_inactivity(bool ignore_stepper_queue/*=false*/) {
       else
         homeDebounceCount = 0;
     }
   #endif
 
   #if ENABLED(USE_CONTROLLER_FAN)
     controllerfan_update(); // Check if fan should be turned on to cool stepper drivers down
   #endif
 
   #if ENABLED(EXTRUDER_RUNOUT_PREVENT)
-    if (ELAPSED(ms, gcode.previous_cmd_ms + (EXTRUDER_RUNOUT_SECONDS) * 1000UL)
-      && thermalManager.degHotend(active_extruder) > EXTRUDER_RUNOUT_MINTEMP) {
+    if (thermalManager.degHotend(active_extruder) > EXTRUDER_RUNOUT_MINTEMP
+      && ELAPSED(ms, gcode.previous_cmd_ms + (EXTRUDER_RUNOUT_SECONDS) * 1000UL)
+      && !planner.blocks_queued()
+    ) {
       #if ENABLED(SWITCHING_EXTRUDER)
         const bool oldstatus = E0_ENABLE_READ;
         enable_E0();
       #else // !SWITCHING_EXTRUDER
         bool oldstatus;
         switch (active_extruder) {
           default: oldstatus = E0_ENABLE_READ; enable_E0(); break;
           #if E_STEPPERS > 1
             case 1: oldstatus = E1_ENABLE_READ; enable_E1(); break;
             #if E_STEPPERS > 2

commit b2f8b4ada52c26c70550a8162afe3c706ce4663c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Feb 8 03:57:11 2018 -0600

    I2C position encoders update (#9533)
    
    Updating I2C position encoders to enable babystepping and Babystep XY when using the ecm microstep correction method. Also changed default method to ECM microstep.

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index c42ed29810..177e424f2d 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -195,22 +195,20 @@ millis_t max_inactive_time = 0,
   millis_t chdkHigh = 0;
   bool chdkActive = false;
 #endif
 
 #if ENABLED(PID_EXTRUSION_SCALING)
   int lpq_len = 20;
 #endif
 
 #if ENABLED(I2C_POSITION_ENCODERS)
   I2CPositionEncodersMgr I2CPEM;
-  uint8_t blockBufferIndexRef = 0;
-  millis_t lastUpdateMillis;
 #endif
 
 /**
  * ***************************************************************************
  * ******************************** FUNCTIONS ********************************
  * ***************************************************************************
  */
 
 void setup_killpin() {
   #if HAS_KILL
@@ -542,26 +540,24 @@ void idle(
 
   #if ENABLED(PRINTCOUNTER)
     print_job_timer.tick();
   #endif
 
   #if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER)
     buzzer.tick();
   #endif
 
   #if ENABLED(I2C_POSITION_ENCODERS)
-    if (planner.blocks_queued() &&
-        ( (blockBufferIndexRef != planner.block_buffer_head) ||
-          ((lastUpdateMillis + I2CPE_MIN_UPD_TIME_MS) < millis())) ) {
-      blockBufferIndexRef = planner.block_buffer_head;
+    static millis_t i2cpem_next_update_ms;
+    if (planner.blocks_queued() && ELAPSED(millis(), i2cpem_next_update_ms)) {
       I2CPEM.update();
-      lastUpdateMillis = millis();
+      i2cpem_next_update_ms = millis() + I2CPE_MIN_UPD_TIME_MS;
     }
   #endif
 
   #ifdef HAL_IDLETASK
     HAL_idletask();
   #endif
 }
 
 /**
  * Kill all activity and lock the machine.

commit b3f115fa0accda3de34c6a23063c24a263dca922
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Feb 6 02:28:18 2018 -0600

    Marlin.ino needs no content (#9506)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index fd46690aaf..c42ed29810 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -18,21 +18,21 @@
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
 /**
  * About Marlin
  *
  * This firmware is a mashup between Sprinter and grbl.
  *  - https://github.com/kliment/Sprinter
- *  - https://github.com/simen/grbl
+ *  - https://github.com/grbl/grbl
  */
 
 #include "Marlin.h"
 
 #include "lcd/ultralcd.h"
 #include "module/motion.h"
 #include "module/planner.h"
 #include "module/stepper.h"
 #include "module/endstops.h"
 #include "module/probe.h"

commit b5e92f4f908461ca2c78a86eefe069b85af0a2dc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Feb 6 00:22:30 2018 -0600

    [2.0.x] Enable / disable PSU automatically (#9503)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 8e867cad41..fd46690aaf 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -229,23 +229,23 @@ void setup_killpin() {
   }
 
 #endif
 
 void setup_powerhold() {
   #if HAS_SUICIDE
     OUT_WRITE(SUICIDE_PIN, HIGH);
   #endif
   #if HAS_POWER_SWITCH
     #if ENABLED(PS_DEFAULT_OFF)
-      OUT_WRITE(PS_ON_PIN, PS_ON_ASLEEP);
+      PSU_OFF();
     #else
-      OUT_WRITE(PS_ON_PIN, PS_ON_AWAKE);
+      PSU_ON();
     #endif
   #endif
 }
 
 /**
  * Stepper Reset (RigidBoard, et.al.)
  */
 #if HAS_STEPPER_RESET
   void disableStepperDrivers() {
     OUT_WRITE(STEPPER_RESET_PIN, LOW);  // drive it down to hold in reset motor driver chips

commit a718f5bdf383ff723ce5195452dc96884b75289f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jan 22 04:29:58 2018 -0600

    Don't run `M600` on filament runout if the nozzle is cold

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 012839503f..8e867cad41 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -329,21 +329,24 @@ void disable_all_steppers() {
  *  - Check for maximum inactive time between stepper commands
  *  - Check if pin CHDK needs to go LOW
  *  - Check for KILL button held down
  *  - Check for HOME button held down
  *  - Check if cooling fan needs to be switched on
  *  - Check if an idle but hot extruder needs filament extruded (EXTRUDER_RUNOUT_PREVENT)
  */
 void manage_inactivity(bool ignore_stepper_queue/*=false*/) {
 
   #if ENABLED(FILAMENT_RUNOUT_SENSOR)
-    if ((IS_SD_PRINTING || print_job_timer.isRunning()) && (READ(FIL_RUNOUT_PIN) == FIL_RUNOUT_INVERTING))
+    if ((IS_SD_PRINTING || print_job_timer.isRunning())
+      && READ(FIL_RUNOUT_PIN) == FIL_RUNOUT_INVERTING
+      && thermalManager.targetHotEnoughToExtrude(active_extruder)
+    )
       handle_filament_runout();
   #endif
 
   if (commands_in_queue < BUFSIZE) get_available_commands();
 
   const millis_t ms = millis();
 
   if (max_inactive_time && ELAPSED(ms, gcode.previous_cmd_ms + max_inactive_time)) {
     SERIAL_ERROR_START();
     SERIAL_ECHOLNPAIR(MSG_KILL_INACTIVE_TIME, parser.command_ptr);

commit f7efac57b7ac607405529a71b4e36a6545525c89
Author: Thomas Moore <tcm0116@gmail.com>
Date:   Sun Nov 5 08:49:38 2017 -0600

    Multi-host support

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index b801281dd6..012839503f 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -662,23 +662,36 @@ void setup() {
   #endif
 
   setup_killpin();
 
   setup_powerhold();
 
   #if HAS_STEPPER_RESET
     disableStepperDrivers();
   #endif
 
-  MYSERIAL.begin(BAUDRATE);
-  uint32_t serial_connect_timeout = millis() + 1000;
-  while(!MYSERIAL && PENDING(millis(), serial_connect_timeout));
+  #if NUM_SERIAL > 0
+    MYSERIAL0.begin(BAUDRATE);
+    #if NUM_SERIAL > 1
+      MYSERIAL1.begin(BAUDRATE);
+    #endif
+  #endif
+
+  #if NUM_SERIAL > 0
+    uint32_t serial_connect_timeout = millis() + 1000UL;
+    while(!MYSERIAL0 && PENDING(millis(), serial_connect_timeout)) { /*nada*/ }
+    #if NUM_SERIAL > 1
+      serial_connect_timeout = millis() + 1000UL;
+      while(!MYSERIAL1 && PENDING(millis(), serial_connect_timeout)) { /*nada*/ }
+    #endif
+  #endif
+
   SERIAL_PROTOCOLLNPGM("start");
   SERIAL_ECHO_START();
 
   // Check startup - does nothing if bootloader sets MCUSR to 0
   byte mcu = HAL_get_reset_source();
   if (mcu &  1) SERIAL_ECHOLNPGM(MSG_POWERUP);
   if (mcu &  2) SERIAL_ECHOLNPGM(MSG_EXTERNAL_RESET);
   if (mcu &  4) SERIAL_ECHOLNPGM(MSG_BROWNOUT_RESET);
   if (mcu &  8) SERIAL_ECHOLNPGM(MSG_WATCHDOG_RESET);
   if (mcu & 32) SERIAL_ECHOLNPGM(MSG_SOFTWARE_RESET);

commit 7541316bb49303ce97e062da601e26426321c4ba
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jan 4 05:06:34 2018 -0600

    Add M701/M702 Filament Load/Unload, M603

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index a12cbdb25b..b801281dd6 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -184,24 +184,20 @@ volatile bool wait_for_heatup = true;
 
 // For M0/M1, this flag may be cleared (by M108) to exit the wait-for-user loop
 #if HAS_RESUME_CONTINUE
   volatile bool wait_for_user = false;
 #endif
 
 // Inactivity shutdown
 millis_t max_inactive_time = 0,
          stepper_inactive_time = (DEFAULT_STEPPER_DEACTIVE_TIME) * 1000UL;
 
-#if ENABLED(ADVANCED_PAUSE_FEATURE)
-  AdvancedPauseMenuResponse advanced_pause_menu_response;
-#endif
-
 #ifdef CHDK
   millis_t chdkHigh = 0;
   bool chdkActive = false;
 #endif
 
 #if ENABLED(PID_EXTRUSION_SCALING)
   int lpq_len = 20;
 #endif
 
 #if ENABLED(I2C_POSITION_ENCODERS)
@@ -301,20 +297,30 @@ void enable_all_steppers() {
 }
 
 void disable_e_steppers() {
   disable_E0();
   disable_E1();
   disable_E2();
   disable_E3();
   disable_E4();
 }
 
+void disable_e_stepper(const uint8_t e) {
+  switch (e) {
+    case 0: disable_E0(); break;
+    case 1: disable_E1(); break;
+    case 2: disable_E2(); break;
+    case 3: disable_E3(); break;
+    case 4: disable_E4(); break;
+  }
+}
+
 void disable_all_steppers() {
   disable_X();
   disable_Y();
   disable_Z();
   disable_e_steppers();
 }
 
 /**
  * Manage several activities:
  *  - Check for Filament Runout

commit 9686ffedeffa75ef3299512f9f032bcf216ec8b6
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Dec 30 04:03:41 2017 -0600

    Single pause flag also indicates SD print pause

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 7a6c65ffa9..a12cbdb25b 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -339,21 +339,21 @@ void manage_inactivity(bool ignore_stepper_queue/*=false*/) {
   const millis_t ms = millis();
 
   if (max_inactive_time && ELAPSED(ms, gcode.previous_cmd_ms + max_inactive_time)) {
     SERIAL_ERROR_START();
     SERIAL_ECHOLNPAIR(MSG_KILL_INACTIVE_TIME, parser.command_ptr);
     kill(PSTR(MSG_KILLED));
   }
 
   // Prevent steppers timing-out in the middle of M600
   #if ENABLED(ADVANCED_PAUSE_FEATURE) && ENABLED(PAUSE_PARK_NO_STEPPER_TIMEOUT)
-    #define MOVE_AWAY_TEST !move_away_flag
+    #define MOVE_AWAY_TEST !did_pause_print
   #else
     #define MOVE_AWAY_TEST true
   #endif
 
   if (MOVE_AWAY_TEST && stepper_inactive_time && ELAPSED(ms, gcode.previous_cmd_ms + stepper_inactive_time)
       && !ignore_stepper_queue && !planner.blocks_queued()) {
     #if ENABLED(DISABLE_INACTIVE_X)
       disable_X();
     #endif
     #if ENABLED(DISABLE_INACTIVE_Y)

commit 026e3013076a471d0aea78e5517d12d79688f2ce
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Dec 25 07:46:19 2017 -0600

    lcd_map_control deps on ULTIPANEL

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 3568b68ec5..7a6c65ffa9 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -358,21 +358,21 @@ void manage_inactivity(bool ignore_stepper_queue/*=false*/) {
     #endif
     #if ENABLED(DISABLE_INACTIVE_Y)
       disable_Y();
     #endif
     #if ENABLED(DISABLE_INACTIVE_Z)
       disable_Z();
     #endif
     #if ENABLED(DISABLE_INACTIVE_E)
       disable_e_steppers();
     #endif
-    #if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(ULTRA_LCD)  // Only needed with an LCD
+    #if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(ULTIPANEL)  // Only needed with an LCD
       ubl.lcd_map_control = defer_return_to_status = false;
     #endif
   }
 
   #ifdef CHDK // Check if pin should be set to LOW after M240 set it to HIGH
     if (chdkActive && ELAPSED(ms, chdkHigh + CHDK_DELAY)) {
       chdkActive = false;
       WRITE(CHDK, LOW);
     }
   #endif

commit 33a6fc70e4c30978c21011374d93c7c6a5c9906b
Author: etagle <ejtagle@hotmail.com>
Date:   Thu Dec 21 02:42:46 2017 -0300

    Adding USB MSD implementation to the HAL: Now, when you plug the Native USB port of the Arduino DUE to your PC, it will be detected as a composite USB device: One of the devices is a USB CDC (Serial port over USB) with native USB handshake (no more overflows!!) (set SERIAL_PORT to -1 to use it as main serial port) and also, a MSD (USB Mass Storage Device) will be detected, and the SD card present on the socket will be reflected as a Removable disk on your PC)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 05fa8136b8..3568b68ec5 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -630,20 +630,24 @@ void stop() {
  *    • stepper
  *    • photo pin
  *    • servos
  *    • LCD controller
  *    • Digipot I2C
  *    • Z probe sled
  *    • status LEDs
  */
 void setup() {
 
+  #ifdef HAL_INIT
+    HAL_init();
+  #endif
+
   #if ENABLED(MAX7219_DEBUG)
     Max7219_init();
   #endif
 
   #if ENABLED(DISABLE_JTAG)
     // Disable JTAG on AT90USB chips to free up pins for IO
     MCUCR = 0x80;
     MCUCR = 0x80;
   #endif
 

commit b6f9c333d441a1f7ebbd5a62c3bd409644ce8f6a
Author: etagle <ejtagle@hotmail.com>
Date:   Thu Dec 21 02:22:08 2017 -0300

    Adding hooks into the idle loop so HALs can execute 2nd plane tasks, such as serving SD card read/writes requested from the USB MSD layer

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 8afecbc279..05fa8136b8 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -541,20 +541,24 @@ void idle(
 
   #if ENABLED(I2C_POSITION_ENCODERS)
     if (planner.blocks_queued() &&
         ( (blockBufferIndexRef != planner.block_buffer_head) ||
           ((lastUpdateMillis + I2CPE_MIN_UPD_TIME_MS) < millis())) ) {
       blockBufferIndexRef = planner.block_buffer_head;
       I2CPEM.update();
       lastUpdateMillis = millis();
     }
   #endif
+
+  #ifdef HAL_IDLETASK
+    HAL_idletask();
+  #endif
 }
 
 /**
  * Kill all activity and lock the machine.
  * After this the machine will need to be reset.
  */
 void kill(const char* lcd_msg) {
   SERIAL_ERROR_START();
   SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
 

commit 4782acf60ef6ce66c9b2e1a1f8779d232fe5221b
Merge: 0cd1e91056 69efb87d19
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Dec 15 15:25:41 2017 -0600

    Merge pull request #8780 from fiveangle/bf2-typo
    
    [2.0.x] typo in Marlin.cpp

diff --combined Marlin/src/Marlin.cpp
index 6556d94086,07df9947e7..8afecbc279
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@@ -92,22 -92,22 +92,22 @@@
  #endif
  
  #if ENABLED(I2C_POSITION_ENCODERS)
    #include "feature/I2CPositionEncoder.h"
  #endif
  
  #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
    #include "HAL/HAL_endstop_interrupts.h"
  #endif
  
 -#if ENABLED(HAVE_TMC2130)
 -  #include "feature/tmc2130.h"
 +#if HAS_TRINAMIC
 +  #include "feature/tmc_util.h"
  #endif
  
  #if ENABLED(SDSUPPORT)
    CardReader card;
  #endif
  
  #if ENABLED(G38_PROBE_TARGET)
    bool G38_move = false,
         G38_endstop_hit = false;
  #endif
@@@ -438,21 -438,21 +438,21 @@@ void manage_inactivity(bool ignore_step
                  case 3: oldstatus = E3_ENABLE_READ; enable_E3(); break;
                  #if E_STEPPERS > 4
                    case 4: oldstatus = E4_ENABLE_READ; enable_E4(); break;
                  #endif // E_STEPPERS > 4
                #endif // E_STEPPERS > 3
              #endif // E_STEPPERS > 2
            #endif // E_STEPPERS > 1
          }
        #endif // !SWITCHING_EXTRUDER
  
-       gcode.refresh_cmd_timeout()
+       gcode.refresh_cmd_timeout();
  
        const float olde = current_position[E_AXIS];
        current_position[E_AXIS] += EXTRUDER_RUNOUT_EXTRUDE;
        planner.buffer_line_kinematic(current_position, MMM_TO_MMS(EXTRUDER_RUNOUT_SPEED), active_extruder);
        current_position[E_AXIS] = olde;
        planner.set_e_position_mm(olde);
        stepper.synchronize();
        #if ENABLED(SWITCHING_EXTRUDER)
          E0_ENABLE_WRITE(oldstatus);
        #else
@@@ -482,22 -482,22 +482,22 @@@
        delayed_move_time = 0xFFFFFFFFUL; // force moves to be done
        set_destination_from_current();
        prepare_move_to_destination();
      }
    #endif
  
    #if ENABLED(TEMP_STAT_LEDS)
      handle_status_leds();
    #endif
  
 -  #if ENABLED(HAVE_TMC2130)
 -    tmc2130_checkOverTemp();
 +  #if ENABLED(MONITOR_DRIVER_STATUS)
 +    monitor_tmc_driver();
    #endif
  
    // Limit check_axes_activity frequency to 10Hz
    static millis_t next_check_axes_ms = 0;
    if (ELAPSED(ms, next_check_axes_ms)) {
      planner.check_axes_activity();
      next_check_axes_ms = ms + 100UL;
    }
  }
  

commit 0cd1e91056213d6a0bd422848ccff7cd1191d001
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Fri Dec 15 23:03:14 2017 +0200

    [2.0.x] TMC driver update (#8769)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 3513fe7e75..6556d94086 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -92,22 +92,22 @@
 #endif
 
 #if ENABLED(I2C_POSITION_ENCODERS)
   #include "feature/I2CPositionEncoder.h"
 #endif
 
 #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
   #include "HAL/HAL_endstop_interrupts.h"
 #endif
 
-#if ENABLED(HAVE_TMC2130)
-  #include "feature/tmc2130.h"
+#if HAS_TRINAMIC
+  #include "feature/tmc_util.h"
 #endif
 
 #if ENABLED(SDSUPPORT)
   CardReader card;
 #endif
 
 #if ENABLED(G38_PROBE_TARGET)
   bool G38_move = false,
        G38_endstop_hit = false;
 #endif
@@ -482,22 +482,22 @@ void manage_inactivity(bool ignore_stepper_queue/*=false*/) {
       delayed_move_time = 0xFFFFFFFFUL; // force moves to be done
       set_destination_from_current();
       prepare_move_to_destination();
     }
   #endif
 
   #if ENABLED(TEMP_STAT_LEDS)
     handle_status_leds();
   #endif
 
-  #if ENABLED(HAVE_TMC2130)
-    tmc2130_checkOverTemp();
+  #if ENABLED(MONITOR_DRIVER_STATUS)
+    monitor_tmc_driver();
   #endif
 
   // Limit check_axes_activity frequency to 10Hz
   static millis_t next_check_axes_ms = 0;
   if (ELAPSED(ms, next_check_axes_ms)) {
     planner.check_axes_activity();
     next_check_axes_ms = ms + 100UL;
   }
 }
 

commit 69efb87d1943b26483a4cd3d5d15838f81219201
Author: Dave Johnson <davejohnson3000@gmail.com>
Date:   Wed Dec 13 19:54:39 2017 -0800

    typo in Marlin.cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 3513fe7e75..07df9947e7 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -438,21 +438,21 @@ void manage_inactivity(bool ignore_stepper_queue/*=false*/) {
                 case 3: oldstatus = E3_ENABLE_READ; enable_E3(); break;
                 #if E_STEPPERS > 4
                   case 4: oldstatus = E4_ENABLE_READ; enable_E4(); break;
                 #endif // E_STEPPERS > 4
               #endif // E_STEPPERS > 3
             #endif // E_STEPPERS > 2
           #endif // E_STEPPERS > 1
         }
       #endif // !SWITCHING_EXTRUDER
 
-      gcode.refresh_cmd_timeout()
+      gcode.refresh_cmd_timeout();
 
       const float olde = current_position[E_AXIS];
       current_position[E_AXIS] += EXTRUDER_RUNOUT_EXTRUDE;
       planner.buffer_line_kinematic(current_position, MMM_TO_MMS(EXTRUDER_RUNOUT_SPEED), active_extruder);
       current_position[E_AXIS] = olde;
       planner.set_e_position_mm(olde);
       stepper.synchronize();
       #if ENABLED(SWITCHING_EXTRUDER)
         E0_ENABLE_WRITE(oldstatus);
       #else

commit e37dd645488ffc4377b6ec818c1e38e55b5903b7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Nov 28 01:07:10 2017 -0600

    Apply LEDColor, language fixes

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index bc99eb3aa9..3513fe7e75 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -768,22 +768,22 @@ void setup() {
   #endif
 
   #if PIN_EXISTS(STAT_LED_RED)
     OUT_WRITE(STAT_LED_RED_PIN, LOW); // turn it off
   #endif
 
   #if PIN_EXISTS(STAT_LED_BLUE)
     OUT_WRITE(STAT_LED_BLUE_PIN, LOW); // turn it off
   #endif
 
-  #if ENABLED(NEOPIXEL_LED)
-    setup_neopixel();
+  #if HAS_COLOR_LEDS
+    leds.setup();
   #endif
 
   #if ENABLED(RGB_LED) || ENABLED(RGBW_LED)
     SET_OUTPUT(RGB_LED_R_PIN);
     SET_OUTPUT(RGB_LED_G_PIN);
     SET_OUTPUT(RGB_LED_B_PIN);
     #if ENABLED(RGBW_LED)
       SET_OUTPUT(RGB_LED_W_PIN);
     #endif
   #endif

commit 9406c87a9740790b2a3488199854cd1fc816f62d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Nov 22 18:22:55 2017 -0600

    Fix up LCD init / charset

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 882acd23cd..bc99eb3aa9 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -795,23 +795,20 @@ void setup() {
   #endif
 
   #if HAS_FANMUX
     fanmux_init();
   #endif
 
   lcd_init();
 
   #if ENABLED(SHOW_BOOTSCREEN)
     lcd_bootscreen();
-    #if DISABLED(DOGLCD) && ENABLED(ULTRA_LCD) && DISABLED(SDSUPPORT)
-        lcd_init();
-    #endif
   #endif
 
   #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
     mixing_tools_init();
   #endif
 
   #if ENABLED(BLTOUCH)
     bltouch_init();
   #endif
 

commit 4371345cbedef6fd7f4cb23cd7c3ff90206afb4d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Nov 21 18:23:39 2017 -0600

    Don't re-init graphical LCD after boot screen
    
    Followup to https://github.com/MarlinFirmware/Marlin/commit/13a3fb1accec51adb12f7af4f45d6d63f4bc8a3f

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 0045b93a4b..882acd23cd 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -795,21 +795,21 @@ void setup() {
   #endif
 
   #if HAS_FANMUX
     fanmux_init();
   #endif
 
   lcd_init();
 
   #if ENABLED(SHOW_BOOTSCREEN)
     lcd_bootscreen();
-    #if ENABLED(ULTRA_LCD) && DISABLED(SDSUPPORT)
+    #if DISABLED(DOGLCD) && ENABLED(ULTRA_LCD) && DISABLED(SDSUPPORT)
         lcd_init();
     #endif
   #endif
 
   #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
     mixing_tools_init();
   #endif
 
   #if ENABLED(BLTOUCH)
     bltouch_init();

commit c0000a0cdc68dc2c9b49e5fcb1a04275fadd49dd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Nov 19 13:39:46 2017 -0600

    Move servo code to modules/servo.*

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 3f98c565b3..0045b93a4b 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -68,21 +68,21 @@
 
 #if ENABLED(MAX7219_DEBUG)
   #include "feature/Max7219_Debug_LEDs.h"
 #endif
 
 #if HAS_COLOR_LEDS
   #include "feature/leds/leds.h"
 #endif
 
 #if HAS_SERVOS
-  #include "HAL/servo.h"
+  #include "module/servo.h"
 #endif
 
 #if HAS_DIGIPOTSS
   #include <SPI.h>
 #endif
 
 #if ENABLED(DAC_STEPPER_CURRENT)
   #include "feature/dac/stepper_dac.h"
 #endif
 
@@ -240,49 +240,20 @@ void setup_powerhold() {
   #endif
   #if HAS_POWER_SWITCH
     #if ENABLED(PS_DEFAULT_OFF)
       OUT_WRITE(PS_ON_PIN, PS_ON_ASLEEP);
     #else
       OUT_WRITE(PS_ON_PIN, PS_ON_AWAKE);
     #endif
   #endif
 }
 
-#if HAS_SERVOS
-
-  HAL_SERVO_LIB servo[NUM_SERVOS];
-
-  void servo_init() {
-    #if NUM_SERVOS >= 1 && HAS_SERVO_0
-      servo[0].attach(SERVO0_PIN);
-      servo[0].detach(); // Just set up the pin. We don't have a position yet. Don't move to a random position.
-    #endif
-    #if NUM_SERVOS >= 2 && HAS_SERVO_1
-      servo[1].attach(SERVO1_PIN);
-      servo[1].detach();
-    #endif
-    #if NUM_SERVOS >= 3 && HAS_SERVO_2
-      servo[2].attach(SERVO2_PIN);
-      servo[2].detach();
-    #endif
-    #if NUM_SERVOS >= 4 && HAS_SERVO_3
-      servo[3].attach(SERVO3_PIN);
-      servo[3].detach();
-    #endif
-
-    #if HAS_Z_SERVO_ENDSTOP
-      servo_probe_init();
-    #endif
-  }
-
-#endif // HAS_SERVOS
-
 /**
  * Stepper Reset (RigidBoard, et.al.)
  */
 #if HAS_STEPPER_RESET
   void disableStepperDrivers() {
     OUT_WRITE(STEPPER_RESET_PIN, LOW);  // drive it down to hold in reset motor driver chips
   }
   void enableStepperDrivers() { SET_INPUT(STEPPER_RESET_PIN); }  // set to input, which allows it to be pulled high by pullups
 #endif
 
@@ -738,20 +709,24 @@ void setup() {
   SYNC_PLAN_POSITION_KINEMATIC();
 
   thermalManager.init();    // Initialize temperature loop
 
   stepper.init();    // Initialize stepper, this enables interrupts!
 
   #if HAS_SERVOS
     servo_init();
   #endif
 
+  #if HAS_Z_SERVO_ENDSTOP
+    servo_probe_init();
+  #endif
+
   #if HAS_PHOTOGRAPH
     OUT_WRITE(PHOTOGRAPH_PIN, LOW);
   #endif
 
   #if HAS_CASE_LIGHT
     update_case_light();
   #endif
 
   #if ENABLED(SPINDLE_LASER_ENABLE)
     OUT_WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);  // init spindle to off

commit c14000775b1a5e9e8c24e139424bd9f0b4845465
Author: Bob-the-Kuhn <bob.kuhn@att.net>
Date:   Wed Nov 15 19:01:52 2017 -0600

    PWM fixes, slow down fan update
    
    include LPC1768 syntax for M42
    
    couple more pin_t changes
    
    consistency
    
    change M42 to R, P format
    
    Revert "change M42 to R, P format"
    
    This reverts commit 01f12f579ec9ccc1bb9126e68d2c86449e9b7edf.

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 5b5907f85f..3f98c565b3 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -515,21 +515,26 @@ void manage_inactivity(bool ignore_stepper_queue/*=false*/) {
   #endif
 
   #if ENABLED(TEMP_STAT_LEDS)
     handle_status_leds();
   #endif
 
   #if ENABLED(HAVE_TMC2130)
     tmc2130_checkOverTemp();
   #endif
 
-  planner.check_axes_activity();
+  // Limit check_axes_activity frequency to 10Hz
+  static millis_t next_check_axes_ms = 0;
+  if (ELAPSED(ms, next_check_axes_ms)) {
+    planner.check_axes_activity();
+    next_check_axes_ms = ms + 100UL;
+  }
 }
 
 /**
  * Standard idle routine keeps the machine alive
  */
 void idle(
   #if ENABLED(ADVANCED_PAUSE_FEATURE)
     bool no_stepper_sleep/*=false*/
   #endif
 ) {

commit b7feb53e8a8d6f84039778a1ea5b656881e947dd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Nov 13 15:23:30 2017 -0600

    Support for Extrudrboard in Printrboard Rev.F

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index e09bd9d5ea..5b5907f85f 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -654,21 +654,21 @@ void stop() {
  *    • Digipot I2C
  *    • Z probe sled
  *    • status LEDs
  */
 void setup() {
 
   #if ENABLED(MAX7219_DEBUG)
     Max7219_init();
   #endif
 
-  #ifdef DISABLE_JTAG
+  #if ENABLED(DISABLE_JTAG)
     // Disable JTAG on AT90USB chips to free up pins for IO
     MCUCR = 0x80;
     MCUCR = 0x80;
   #endif
 
   #if ENABLED(FILAMENT_RUNOUT_SENSOR)
     setup_filrunoutpin();
   #endif
 
   setup_killpin();

commit 79772219aeb0531cccfa7eb73cea246ceb6dbb6f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Nov 4 21:01:41 2017 -0500

    Fix Fan Multiplexer init

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 47fa92db43..e09bd9d5ea 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -131,20 +131,24 @@
 #endif
 
 #if ENABLED(TEMP_STAT_LEDS)
   #include "feature/leds/tempstat.h"
 #endif
 
 #if HAS_CASE_LIGHT
   #include "feature/caselight.h"
 #endif
 
+#if HAS_FANMUX
+  #include "feature/fanmux.h"
+#endif
+
 #if (ENABLED(SWITCHING_EXTRUDER) && !DONT_SWITCH) || ENABLED(SWITCHING_NOZZLE) || ENABLED(PARKING_EXTRUDER)
   #include "module/tool_change.h"
 #endif
 
 #if ENABLED(USE_CONTROLLER_FAN)
   #include "feature/controllerfan.h"
 #endif
 
 bool Running = true;
 

commit ca0e4b4e963d6f198beab5646bf95721f8a2414b
Author: AnHardt <github@kitelab.de>
Date:   Fri Nov 3 11:58:20 2017 +0100

    Some cleanup around 'lcd_bootscreen()' and 'lcd_kill_screen()'
    
    Move 'lcd_bootscreen()' from `lcd_init()` to 'setup()' where it is cexecute exactly once. Saves 'bool show_bootscreen'.
    Move the call of 'lcd_custom_bootscreen()' to the begin of 'lcd_bootscreen()'.
    Move the delays into the related functions.
    Move the picture loop around 'lcd_kill_screen()' into the function.

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 9f9a2f95b2..47fa92db43 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -809,36 +809,24 @@ void setup() {
     SET_OUTPUT(E_MUX1_PIN);
     SET_OUTPUT(E_MUX2_PIN);
   #endif
 
   #if HAS_FANMUX
     fanmux_init();
   #endif
 
   lcd_init();
 
-  #ifndef CUSTOM_BOOTSCREEN_TIMEOUT
-    #define CUSTOM_BOOTSCREEN_TIMEOUT 2500
-  #endif
-
   #if ENABLED(SHOW_BOOTSCREEN)
-    #if ENABLED(DOGLCD)                           // On DOGM the first bootscreen is already drawn
-      #if ENABLED(SHOW_CUSTOM_BOOTSCREEN)
-        safe_delay(CUSTOM_BOOTSCREEN_TIMEOUT);    // Custom boot screen pause
-        lcd_bootscreen();                         // Show Marlin boot screen
-      #endif
-      safe_delay(BOOTSCREEN_TIMEOUT);             // Pause
-    #elif ENABLED(ULTRA_LCD)
-      lcd_bootscreen();
-      #if DISABLED(SDSUPPORT)
+    lcd_bootscreen();
+    #if ENABLED(ULTRA_LCD) && DISABLED(SDSUPPORT)
         lcd_init();
-      #endif
     #endif
   #endif
 
   #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
     mixing_tools_init();
   #endif
 
   #if ENABLED(BLTOUCH)
     bltouch_init();
   #endif

commit 31e96935f7cc8cbdf6fb6b7b11d3533fca6a585d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Oct 30 00:10:00 2017 -0500

    Fix EXTRA_FAN_SPEED
    
    Addressing #8158

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 80a974d135..9f9a2f95b2 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -158,21 +158,21 @@ bool Running = true;
  *   Cleared whenever a stepper powers off, potentially losing its position.
  */
 bool axis_homed[XYZ] = { false }, axis_known_position[XYZ] = { false };
 
 #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
   TempUnit input_temp_units = TEMPUNIT_C;
 #endif
 
 #if FAN_COUNT > 0
   int16_t fanSpeeds[FAN_COUNT] = { 0 };
-  #if ENABLED(EXTRA_FAN_SPEEDS)
+  #if ENABLED(EXTRA_FAN_SPEED)
     int16_t old_fanSpeeds[FAN_COUNT],
             new_fanSpeeds[FAN_COUNT];
   #endif
   #if ENABLED(PROBING_FANS_OFF)
     bool fans_paused = false;
     int16_t paused_fanSpeeds[FAN_COUNT] = { 0 };
   #endif
 #endif
 
 // For M109 and M190, this flag may be cleared (by M108) to exit the wait loop

commit c45514f811375239b8c5cf4ae1d80f518cb4c49e
Merge: cc72db2636 3ac581eac9
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Oct 26 17:24:38 2017 -0500

    Merge pull request #8094 from thinkyhead/bf2_neopixel_led_parity
    
    [2.0.x] Bring NEOPIXEL_LED into parity with 1.1.x

diff --combined Marlin/src/Marlin.cpp
index dc0fb6c7be,658e2db42d..80a974d135
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@@ -290,27 -290,24 +290,27 @@@ void setup_powerhold() 
  
    void i2c_on_request() {          // just send dummy data for now
      i2c.reply("Hello World!\n");
    }
  
  #endif
  
  /**
   * Sensitive pin test for M42, M226
   */
 -bool pin_is_protected(const int8_t pin) {
 -  static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
 -  for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
 -    if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
 +bool pin_is_protected(const pin_t pin) {
 +  static const pin_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
 +  for (uint8_t i = 0; i < COUNT(sensitive_pins); i++) {
 +    pin_t sensitive_pin;
 +    memcpy_P(&sensitive_pin, &sensitive_pins[i], sizeof(pin_t));
 +    if (pin == sensitive_pin) return true;
 +  }
    return false;
  }
  
  void quickstop_stepper() {
    stepper.quick_stop();
    stepper.synchronize();
    set_current_from_steppers_for_axis(ALL_AXES);
    SYNC_PLAN_POSITION_KINEMATIC();
  }
  
@@@ -785,21 -782,20 +785,20 @@@ void setup() 
  
    #if PIN_EXISTS(STAT_LED_RED)
      OUT_WRITE(STAT_LED_RED_PIN, LOW); // turn it off
    #endif
  
    #if PIN_EXISTS(STAT_LED_BLUE)
      OUT_WRITE(STAT_LED_BLUE_PIN, LOW); // turn it off
    #endif
  
    #if ENABLED(NEOPIXEL_LED)
-     SET_OUTPUT(NEOPIXEL_PIN);
      setup_neopixel();
    #endif
  
    #if ENABLED(RGB_LED) || ENABLED(RGBW_LED)
      SET_OUTPUT(RGB_LED_R_PIN);
      SET_OUTPUT(RGB_LED_G_PIN);
      SET_OUTPUT(RGB_LED_B_PIN);
      #if ENABLED(RGBW_LED)
        SET_OUTPUT(RGB_LED_W_PIN);
      #endif

commit 9e699811d25918fe64793824b2a2fdbccdf3b7bd
Author: Thomas Moore <tcm0116@users.noreply.github.com>
Date:   Thu Oct 26 13:37:26 2017 -0500

    Make LPC1768 pinmapping not specific to Re-ARM (#8063)
    
    * Merging early because of build failures.  See #8105
    
    * Make LPC1768 pinmapping not specific to Re-ARM
    
    * Add HAL_PIN_TYPE and LPC1768 pin features
    
    * M43 Updates
    
    * Move pin map into pinsDebug_LPC1768.h
    
    * Incorporate comments and M226
    
    * Fix persistent store compilation issues
    
    * Update pin features
    
    * Update MKS SBASE pins
    
    * Use native LPC1768 pin numbers in M42, M43, and M226

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 75f10d0b83..dc0fb6c7be 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -290,24 +290,27 @@ void setup_powerhold() {
 
   void i2c_on_request() {          // just send dummy data for now
     i2c.reply("Hello World!\n");
   }
 
 #endif
 
 /**
  * Sensitive pin test for M42, M226
  */
-bool pin_is_protected(const int8_t pin) {
-  static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
-  for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
-    if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
+bool pin_is_protected(const pin_t pin) {
+  static const pin_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
+  for (uint8_t i = 0; i < COUNT(sensitive_pins); i++) {
+    pin_t sensitive_pin;
+    memcpy_P(&sensitive_pin, &sensitive_pins[i], sizeof(pin_t));
+    if (pin == sensitive_pin) return true;
+  }
   return false;
 }
 
 void quickstop_stepper() {
   stepper.quick_stop();
   stepper.synchronize();
   set_current_from_steppers_for_axis(ALL_AXES);
   SYNC_PLAN_POSITION_KINEMATIC();
 }
 

commit 3ac581eac92d31287580ea6da5357f3d6cd82db5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Oct 25 15:50:36 2017 -0500

    Neopixel changes for parity with 1.1.x

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 75f10d0b83..658e2db42d 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -782,21 +782,20 @@ void setup() {
 
   #if PIN_EXISTS(STAT_LED_RED)
     OUT_WRITE(STAT_LED_RED_PIN, LOW); // turn it off
   #endif
 
   #if PIN_EXISTS(STAT_LED_BLUE)
     OUT_WRITE(STAT_LED_BLUE_PIN, LOW); // turn it off
   #endif
 
   #if ENABLED(NEOPIXEL_LED)
-    SET_OUTPUT(NEOPIXEL_PIN);
     setup_neopixel();
   #endif
 
   #if ENABLED(RGB_LED) || ENABLED(RGBW_LED)
     SET_OUTPUT(RGB_LED_R_PIN);
     SET_OUTPUT(RGB_LED_G_PIN);
     SET_OUTPUT(RGB_LED_B_PIN);
     #if ENABLED(RGBW_LED)
       SET_OUTPUT(RGB_LED_W_PIN);
     #endif

commit 72156a2029d329c7dc251f5e576103fda691372d
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Sat Oct 21 11:42:26 2017 -0500

    change to better (more clear) names (#8050)
    
    set_destination_to_current() changed to set_destination_from_current()
    
    set_current_to_destination() changed to set_current_from_destination()

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 94518681cc..75f10d0b83 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -495,21 +495,21 @@ void manage_inactivity(bool ignore_stepper_queue/*=false*/) {
         }
       #endif // !SWITCHING_EXTRUDER
     }
   #endif // EXTRUDER_RUNOUT_PREVENT
 
   #if ENABLED(DUAL_X_CARRIAGE)
     // handle delayed move timeout
     if (delayed_move_time && ELAPSED(ms, delayed_move_time + 1000UL) && IsRunning()) {
       // travel moves have been received so enact them
       delayed_move_time = 0xFFFFFFFFUL; // force moves to be done
-      set_destination_to_current();
+      set_destination_from_current();
       prepare_move_to_destination();
     }
   #endif
 
   #if ENABLED(TEMP_STAT_LEDS)
     handle_status_leds();
   #endif
 
   #if ENABLED(HAVE_TMC2130)
     tmc2130_checkOverTemp();

commit ce48403a0bd39870be32a4795e255fcc3cc917c4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Oct 16 01:41:45 2017 -0500

    Add EXTRA_FAN_SPEED feature
    
    Based on #7883 by @studiodyne

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 7bc4d246ec..94518681cc 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -158,20 +158,24 @@ bool Running = true;
  *   Cleared whenever a stepper powers off, potentially losing its position.
  */
 bool axis_homed[XYZ] = { false }, axis_known_position[XYZ] = { false };
 
 #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
   TempUnit input_temp_units = TEMPUNIT_C;
 #endif
 
 #if FAN_COUNT > 0
   int16_t fanSpeeds[FAN_COUNT] = { 0 };
+  #if ENABLED(EXTRA_FAN_SPEEDS)
+    int16_t old_fanSpeeds[FAN_COUNT],
+            new_fanSpeeds[FAN_COUNT];
+  #endif
   #if ENABLED(PROBING_FANS_OFF)
     bool fans_paused = false;
     int16_t paused_fanSpeeds[FAN_COUNT] = { 0 };
   #endif
 #endif
 
 // For M109 and M190, this flag may be cleared (by M108) to exit the wait loop
 volatile bool wait_for_heatup = true;
 
 // For M0/M1, this flag may be cleared (by M108) to exit the wait-for-user loop

commit f8e8fcb978e3c2eab7eb001566593aefa04c3fab
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Oct 10 02:35:20 2017 -0500

    Move FILAMENT_RUNOUT_SENSOR to a feature

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index aefa4021eb..7bc4d246ec 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -119,20 +119,24 @@
 #endif
 
 #if HAS_LEVELING
   #include "feature/bedlevel/bedlevel.h"
 #endif
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE) && ENABLED(PAUSE_PARK_NO_STEPPER_TIMEOUT)
   #include "feature/pause.h"
 #endif
 
+#if ENABLED(FILAMENT_RUNOUT_SENSOR)
+  #include "feature/runout.h"
+#endif
+
 #if ENABLED(TEMP_STAT_LEDS)
   #include "feature/leds/tempstat.h"
 #endif
 
 #if HAS_CASE_LIGHT
   #include "feature/caselight.h"
 #endif
 
 #if (ENABLED(SWITCHING_EXTRUDER) && !DONT_SWITCH) || ENABLED(SWITCHING_NOZZLE) || ENABLED(PARKING_EXTRUDER)
   #include "module/tool_change.h"
@@ -172,24 +176,20 @@ volatile bool wait_for_heatup = true;
 
 // For M0/M1, this flag may be cleared (by M108) to exit the wait-for-user loop
 #if HAS_RESUME_CONTINUE
   volatile bool wait_for_user = false;
 #endif
 
 // Inactivity shutdown
 millis_t max_inactive_time = 0,
          stepper_inactive_time = (DEFAULT_STEPPER_DEACTIVE_TIME) * 1000UL;
 
-#if ENABLED(FILAMENT_RUNOUT_SENSOR)
-  static bool filament_ran_out = false;
-#endif
-
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   AdvancedPauseMenuResponse advanced_pause_menu_response;
 #endif
 
 #ifdef CHDK
   millis_t chdkHigh = 0;
   bool chdkActive = false;
 #endif
 
 #if ENABLED(PID_EXTRUSION_SCALING)
@@ -300,32 +300,20 @@ bool pin_is_protected(const int8_t pin) {
   return false;
 }
 
 void quickstop_stepper() {
   stepper.quick_stop();
   stepper.synchronize();
   set_current_from_steppers_for_axis(ALL_AXES);
   SYNC_PLAN_POSITION_KINEMATIC();
 }
 
-#if ENABLED(FILAMENT_RUNOUT_SENSOR)
-
-  void handle_filament_runout() {
-    if (!filament_ran_out) {
-      filament_ran_out = true;
-      enqueue_and_echo_commands_P(PSTR(FILAMENT_RUNOUT_SCRIPT));
-      stepper.synchronize();
-    }
-  }
-
-#endif // FILAMENT_RUNOUT_SENSOR
-
 void enable_all_steppers() {
   enable_X();
   enable_Y();
   enable_Z();
   enable_E0();
   enable_E1();
   enable_E2();
   enable_E3();
   enable_E4();
 }

commit a11e6a1022b8f70be237fad82a9b6ba22b2db7b1
Author: Slawomir Ciunczyk <s.ciunczyk@moye.eu>
Date:   Thu Oct 5 13:45:36 2017 +0200

    Different NEOPIXEL types
    
    Same as #7728 but for 2.0.x,
    Lot of cleanup and remove references in whole code to other "LED files" than leds.h. Now will be much easier to add next drivers/libraries. e.g. FastLED. But bad news, currently FastLED is suporting only RGB devices (no RGBW)

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index c95758754a..aefa4021eb 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -789,21 +789,21 @@ void setup() {
   #endif
 
   #if PIN_EXISTS(STAT_LED_RED)
     OUT_WRITE(STAT_LED_RED_PIN, LOW); // turn it off
   #endif
 
   #if PIN_EXISTS(STAT_LED_BLUE)
     OUT_WRITE(STAT_LED_BLUE_PIN, LOW); // turn it off
   #endif
 
-  #if ENABLED(NEOPIXEL_RGBW_LED)
+  #if ENABLED(NEOPIXEL_LED)
     SET_OUTPUT(NEOPIXEL_PIN);
     setup_neopixel();
   #endif
 
   #if ENABLED(RGB_LED) || ENABLED(RGBW_LED)
     SET_OUTPUT(RGB_LED_R_PIN);
     SET_OUTPUT(RGB_LED_G_PIN);
     SET_OUTPUT(RGB_LED_B_PIN);
     #if ENABLED(RGBW_LED)
       SET_OUTPUT(RGB_LED_W_PIN);

commit 46b2773e13ef6a5474f2be57bf57f1d782339df0
Author: Chris Pepper <p3p@p3psoft.co.uk>
Date:   Wed Oct 4 21:40:54 2017 +0100

    General fixes for LPC1768 (#7834)
    
    * fixed some include paths
    
    * LPC1768: Fix Serial API
    
    Add missing serial methods used if TX_BUFFER_SIZE is set
    Change return value of HalSerial:read to match Arduino API
    
    * LPC1768: add filters to ADC
    
    This is to try and compensate for hardware issue and oversensitivity to noise
    
    * LPC1768: remove the polling section of delayMicroseconds
    
    * LPC1768: lock usb mass storage device while device accesses it.
    
    Currently only applicable to persistent store,
    The device always has priority and will unmount the sd card from the host, Windows then tries to automount again so it can look like the explorer window freezes. Linux Mint, by default, just closes the Nemo window.
    
    * Add timeout to make sure if Serial never connects that Marlin still boots
    
    * Remove unneeded ifdef CPU_32_BIT
    
    In general the need for ifdef CPU_32_BIT blocks means that something is missing from the HAL API or a Platform, in this case HAL_TICKS_PER_US was missing from the AVR Platform
    
    * LPC1768: relocate RE-ARM debug_extra_script.py

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 0607242648..c95758754a 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -674,21 +674,22 @@ void setup() {
 
   setup_killpin();
 
   setup_powerhold();
 
   #if HAS_STEPPER_RESET
     disableStepperDrivers();
   #endif
 
   MYSERIAL.begin(BAUDRATE);
-  while(!MYSERIAL);
+  uint32_t serial_connect_timeout = millis() + 1000;
+  while(!MYSERIAL && PENDING(millis(), serial_connect_timeout));
   SERIAL_PROTOCOLLNPGM("start");
   SERIAL_ECHO_START();
 
   // Check startup - does nothing if bootloader sets MCUSR to 0
   byte mcu = HAL_get_reset_source();
   if (mcu &  1) SERIAL_ECHOLNPGM(MSG_POWERUP);
   if (mcu &  2) SERIAL_ECHOLNPGM(MSG_EXTERNAL_RESET);
   if (mcu &  4) SERIAL_ECHOLNPGM(MSG_BROWNOUT_RESET);
   if (mcu &  8) SERIAL_ECHOLNPGM(MSG_WATCHDOG_RESET);
   if (mcu & 32) SERIAL_ECHOLNPGM(MSG_SOFTWARE_RESET);

commit 10c1b442caa1653a925b357ebaf92d1e1c0c4066
Author: Phr3d13 <phr3d13@gmail.com>
Date:   Wed Sep 27 05:40:48 2017 -0400

    Fixes for Anet10 and gt2560
    
    Fixes for 2 "... not declared in this scope" compiler errors.

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 01952606e2..0607242648 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -232,26 +232,20 @@ void setup_powerhold() {
   #endif
   #if HAS_POWER_SWITCH
     #if ENABLED(PS_DEFAULT_OFF)
       OUT_WRITE(PS_ON_PIN, PS_ON_ASLEEP);
     #else
       OUT_WRITE(PS_ON_PIN, PS_ON_AWAKE);
     #endif
   #endif
 }
 
-void suicide() {
-  #if HAS_SUICIDE
-    OUT_WRITE(SUICIDE_PIN, LOW);
-  #endif
-}
-
 #if HAS_SERVOS
 
   HAL_SERVO_LIB servo[NUM_SERVOS];
 
   void servo_init() {
     #if NUM_SERVOS >= 1 && HAS_SERVO_0
       servo[0].attach(SERVO0_PIN);
       servo[0].detach(); // Just set up the pin. We don't have a position yet. Don't move to a random position.
     #endif
     #if NUM_SERVOS >= 2 && HAS_SERVO_1
@@ -605,21 +599,24 @@ void kill(const char* lcd_msg) {
   thermalManager.disable_all_heaters(); //turn off heaters again
 
   #ifdef ACTION_ON_KILL
     SERIAL_ECHOLNPGM("//action:" ACTION_ON_KILL);
   #endif
 
   #if HAS_POWER_SWITCH
     SET_INPUT(PS_ON_PIN);
   #endif
 
-  suicide();
+  #if HAS_SUICIDE
+    suicide();
+  #endif
+
   while (1) {
     #if ENABLED(USE_WATCHDOG)
       watchdog_reset();
     #endif
   } // Wait for reset
 }
 
 /**
  * Turn off heaters and stop the print in progress
  * After a stop the machine may be resumed with M999

commit f9ef446fb5fccac2ca7f337417b697839607ce03
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 18 01:46:45 2017 -0500

    Clean up after refactor

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 946b840527..01952606e2 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -289,24 +289,20 @@ void suicide() {
   void i2c_on_receive(int bytes) { // just echo all bytes received to serial
     i2c.receive(bytes);
   }
 
   void i2c_on_request() {          // just send dummy data for now
     i2c.reply("Hello World!\n");
   }
 
 #endif
 
-/**************************************************
- ***************** GCode Handlers *****************
- **************************************************/
-
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 

commit 64dfb464610e35c3a65748170b5f015ffe1bc9bd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 18 05:56:10 2017 -0500

    Move z_endstop_adj to Endstops

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 873e046bb7..946b840527 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -172,24 +172,20 @@ volatile bool wait_for_heatup = true;
 
 // For M0/M1, this flag may be cleared (by M108) to exit the wait-for-user loop
 #if HAS_RESUME_CONTINUE
   volatile bool wait_for_user = false;
 #endif
 
 // Inactivity shutdown
 millis_t max_inactive_time = 0,
          stepper_inactive_time = (DEFAULT_STEPPER_DEACTIVE_TIME) * 1000UL;
 
-#if ENABLED(Z_DUAL_ENDSTOPS)
-  float z_endstop_adj;
-#endif
-
 #if ENABLED(FILAMENT_RUNOUT_SENSOR)
   static bool filament_ran_out = false;
 #endif
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   AdvancedPauseMenuResponse advanced_pause_menu_response;
 #endif
 
 #ifdef CHDK
   millis_t chdkHigh = 0;

commit a10451ceed61e16a62d5395c27ad4ebe8ed06029
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 18 05:51:45 2017 -0500

    Move Volumetric methods to Planner

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index ccd32a465c..873e046bb7 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -152,23 +152,20 @@ bool Running = true;
  * axis_known_position
  *   Flags that the position is known in each linear axis. Set when homed.
  *   Cleared whenever a stepper powers off, potentially losing its position.
  */
 bool axis_homed[XYZ] = { false }, axis_known_position[XYZ] = { false };
 
 #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
   TempUnit input_temp_units = TEMPUNIT_C;
 #endif
 
-// Initialized by settings.load()
-float filament_size[EXTRUDERS], volumetric_multiplier[EXTRUDERS];
-
 #if FAN_COUNT > 0
   int16_t fanSpeeds[FAN_COUNT] = { 0 };
   #if ENABLED(PROBING_FANS_OFF)
     bool fans_paused = false;
     int16_t paused_fanSpeeds[FAN_COUNT] = { 0 };
   #endif
 #endif
 
 // For M109 and M190, this flag may be cleared (by M108) to exit the wait loop
 volatile bool wait_for_heatup = true;
@@ -329,30 +326,20 @@ void quickstop_stepper() {
   void handle_filament_runout() {
     if (!filament_ran_out) {
       filament_ran_out = true;
       enqueue_and_echo_commands_P(PSTR(FILAMENT_RUNOUT_SCRIPT));
       stepper.synchronize();
     }
   }
 
 #endif // FILAMENT_RUNOUT_SENSOR
 
-float calculate_volumetric_multiplier(const float diameter) {
-  if (!parser.volumetric_enabled || diameter == 0) return 1.0;
-  return 1.0 / (M_PI * sq(diameter * 0.5));
-}
-
-void calculate_volumetric_multipliers() {
-  for (uint8_t i = 0; i < COUNT(filament_size); i++)
-    volumetric_multiplier[i] = calculate_volumetric_multiplier(filament_size[i]);
-}
-
 void enable_all_steppers() {
   enable_X();
   enable_Y();
   enable_Z();
   enable_E0();
   enable_E1();
   enable_E2();
   enable_E3();
   enable_E4();
 }

commit 6f92ab7eed3f2858cd09d96df37dda20a228e9c7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 18 01:44:59 2017 -0500

    Move Controller Fan to feature

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index a5bc0d2433..ccd32a465c 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -131,20 +131,24 @@
 #endif
 
 #if HAS_CASE_LIGHT
   #include "feature/caselight.h"
 #endif
 
 #if (ENABLED(SWITCHING_EXTRUDER) && !DONT_SWITCH) || ENABLED(SWITCHING_NOZZLE) || ENABLED(PARKING_EXTRUDER)
   #include "module/tool_change.h"
 #endif
 
+#if ENABLED(USE_CONTROLLER_FAN)
+  #include "feature/controllerfan.h"
+#endif
+
 bool Running = true;
 
 /**
  * axis_homed
  *   Flags that each linear axis was homed.
  *   XYZ on cartesian, ABC on delta, ABZ on SCARA.
  *
  * axis_known_position
  *   Flags that the position is known in each linear axis. Set when homed.
  *   Cleared whenever a stepper powers off, potentially losing its position.
@@ -313,60 +317,20 @@ bool pin_is_protected(const int8_t pin) {
   return false;
 }
 
 void quickstop_stepper() {
   stepper.quick_stop();
   stepper.synchronize();
   set_current_from_steppers_for_axis(ALL_AXES);
   SYNC_PLAN_POSITION_KINEMATIC();
 }
 
-#if ENABLED(USE_CONTROLLER_FAN)
-
-  void controllerFan() {
-    static millis_t lastMotorOn = 0, // Last time a motor was turned on
-                    nextMotorCheck = 0; // Last time the state was checked
-    const millis_t ms = millis();
-    if (ELAPSED(ms, nextMotorCheck)) {
-      nextMotorCheck = ms + 2500UL; // Not a time critical function, so only check every 2.5s
-      if (X_ENABLE_READ == X_ENABLE_ON || Y_ENABLE_READ == Y_ENABLE_ON || Z_ENABLE_READ == Z_ENABLE_ON || thermalManager.soft_pwm_amount_bed > 0
-          || E0_ENABLE_READ == E_ENABLE_ON // If any of the drivers are enabled...
-          #if E_STEPPERS > 1
-            || E1_ENABLE_READ == E_ENABLE_ON
-            #if HAS_X2_ENABLE
-              || X2_ENABLE_READ == X_ENABLE_ON
-            #endif
-            #if E_STEPPERS > 2
-              || E2_ENABLE_READ == E_ENABLE_ON
-              #if E_STEPPERS > 3
-                || E3_ENABLE_READ == E_ENABLE_ON
-                #if E_STEPPERS > 4
-                  || E4_ENABLE_READ == E_ENABLE_ON
-                #endif // E_STEPPERS > 4
-              #endif // E_STEPPERS > 3
-            #endif // E_STEPPERS > 2
-          #endif // E_STEPPERS > 1
-      ) {
-        lastMotorOn = ms; //... set time to NOW so the fan will turn on
-      }
-
-      // Fan off if no steppers have been enabled for CONTROLLERFAN_SECS seconds
-      uint8_t speed = (!lastMotorOn || ELAPSED(ms, lastMotorOn + (CONTROLLERFAN_SECS) * 1000UL)) ? 0 : CONTROLLERFAN_SPEED;
-
-      // allows digital or PWM fan output to be used (see M42 handling)
-      WRITE(CONTROLLER_FAN_PIN, speed);
-      analogWrite(CONTROLLER_FAN_PIN, speed);
-    }
-  }
-
-#endif // USE_CONTROLLER_FAN
-
 #if ENABLED(FILAMENT_RUNOUT_SENSOR)
 
   void handle_filament_runout() {
     if (!filament_ran_out) {
       filament_ran_out = true;
       enqueue_and_echo_commands_P(PSTR(FILAMENT_RUNOUT_SCRIPT));
       stepper.synchronize();
     }
   }
 
@@ -503,21 +467,21 @@ void manage_inactivity(bool ignore_stepper_queue/*=false*/) {
         LCD_MESSAGEPGM(MSG_AUTO_HOME);
       }
       if (homeDebounceCount < HOME_DEBOUNCE_DELAY)
         homeDebounceCount++;
       else
         homeDebounceCount = 0;
     }
   #endif
 
   #if ENABLED(USE_CONTROLLER_FAN)
-    controllerFan(); // Check if fan should be turned on to cool stepper drivers down
+    controllerfan_update(); // Check if fan should be turned on to cool stepper drivers down
   #endif
 
   #if ENABLED(EXTRUDER_RUNOUT_PREVENT)
     if (ELAPSED(ms, gcode.previous_cmd_ms + (EXTRUDER_RUNOUT_SECONDS) * 1000UL)
       && thermalManager.degHotend(active_extruder) > EXTRUDER_RUNOUT_MINTEMP) {
       #if ENABLED(SWITCHING_EXTRUDER)
         const bool oldstatus = E0_ENABLE_READ;
         enable_E0();
       #else // !SWITCHING_EXTRUDER
         bool oldstatus;

commit 07cf75883f125d569cb2013594a7519074eb34e4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 18 01:05:44 2017 -0500

    Move T (tool change) to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 7d6231423b..a5bc0d2433 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -47,24 +47,20 @@
 #include "libs/nozzle.h"
 
 #include "gcode/gcode.h"
 #include "gcode/parser.h"
 #include "gcode/queue.h"
 
 #if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER)
   #include "libs/buzzer.h"
 #endif
 
-#if (ENABLED(SWITCHING_EXTRUDER) && !DONT_SWITCH) || ENABLED(SWITCHING_NOZZLE)
-  #include "module/tool_change.h"
-#endif
-
 #if ENABLED(DIGIPOT_I2C)
   #include "feature/digipot/digipot.h"
 #endif
 
 #if ENABLED(MIXING_EXTRUDER)
   #include "feature/mixing.h"
 #endif
 
 #if ENABLED(BEZIER_CURVE_SUPPORT)
   #include "module/planner_bezier.h"
@@ -131,20 +127,24 @@
 #endif
 
 #if ENABLED(TEMP_STAT_LEDS)
   #include "feature/leds/tempstat.h"
 #endif
 
 #if HAS_CASE_LIGHT
   #include "feature/caselight.h"
 #endif
 
+#if (ENABLED(SWITCHING_EXTRUDER) && !DONT_SWITCH) || ENABLED(SWITCHING_NOZZLE) || ENABLED(PARKING_EXTRUDER)
+  #include "module/tool_change.h"
+#endif
+
 bool Running = true;
 
 /**
  * axis_homed
  *   Flags that each linear axis was homed.
  *   XYZ on cartesian, ABC on delta, ABZ on SCARA.
  *
  * axis_known_position
  *   Flags that the position is known in each linear axis. Set when homed.
  *   Cleared whenever a stepper powers off, potentially losing its position.
@@ -313,22 +313,20 @@ bool pin_is_protected(const int8_t pin) {
   return false;
 }
 
 void quickstop_stepper() {
   stepper.quick_stop();
   stepper.synchronize();
   set_current_from_steppers_for_axis(ALL_AXES);
   SYNC_PLAN_POSITION_KINEMATIC();
 }
 
-#include "gcode/control/T.h"
-
 #if ENABLED(USE_CONTROLLER_FAN)
 
   void controllerFan() {
     static millis_t lastMotorOn = 0, // Last time a motor was turned on
                     nextMotorCheck = 0; // Last time the state was checked
     const millis_t ms = millis();
     if (ELAPSED(ms, nextMotorCheck)) {
       nextMotorCheck = ms + 2500UL; // Not a time critical function, so only check every 2.5s
       if (X_ENABLE_READ == X_ENABLE_ON || Y_ENABLE_READ == Y_ENABLE_ON || Z_ENABLE_READ == Z_ENABLE_ON || thermalManager.soft_pwm_amount_bed > 0
           || E0_ENABLE_READ == E_ENABLE_ON // If any of the drivers are enabled...
@@ -925,27 +923,21 @@ void setup() {
 
   #if ENABLED(SWITCHING_EXTRUDER) && !DONT_SWITCH
     move_extruder_servo(0);  // Initialize extruder servo
   #endif
 
   #if ENABLED(SWITCHING_NOZZLE)
     move_nozzle_servo(0);  // Initialize nozzle servo
   #endif
 
   #if ENABLED(PARKING_EXTRUDER)
-    #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
-      pe_activate_magnet(0);
-      pe_activate_magnet(1);
-    #else
-      pe_deactivate_magnet(0);
-      pe_deactivate_magnet(1);
-    #endif
+    pe_magnet_init();
   #endif
 }
 
 /**
  * The main Marlin program loop
  *
  *  - Save or log commands to SD
  *  - Process available commands (if not saving)
  *  - Call heater manager
  *  - Call inactivity manager

commit 927524af6bc8e0cd8d88b8768667488841698a5b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 18 00:52:06 2017 -0500

    Move M999 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 4add62ff72..7d6231423b 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -313,22 +313,20 @@ bool pin_is_protected(const int8_t pin) {
   return false;
 }
 
 void quickstop_stepper() {
   stepper.quick_stop();
   stepper.synchronize();
   set_current_from_steppers_for_axis(ALL_AXES);
   SYNC_PLAN_POSITION_KINEMATIC();
 }
 
-#include "gcode/control/M999.h"
-
 #include "gcode/control/T.h"
 
 #if ENABLED(USE_CONTROLLER_FAN)
 
   void controllerFan() {
     static millis_t lastMotorOn = 0, // Last time a motor was turned on
                     nextMotorCheck = 0; // Last time the state was checked
     const millis_t ms = millis();
     if (ELAPSED(ms, nextMotorCheck)) {
       nextMotorCheck = ms + 2500UL; // Not a time critical function, so only check every 2.5s

commit 1a37ebc76dfc2a1e27fcd71590fcea7bc49d980a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 18 00:06:16 2017 -0500

    Move M163-M165 MIXING_EXTRUDER to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index eb05267872..4add62ff72 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -55,20 +55,24 @@
 #endif
 
 #if (ENABLED(SWITCHING_EXTRUDER) && !DONT_SWITCH) || ENABLED(SWITCHING_NOZZLE)
   #include "module/tool_change.h"
 #endif
 
 #if ENABLED(DIGIPOT_I2C)
   #include "feature/digipot/digipot.h"
 #endif
 
+#if ENABLED(MIXING_EXTRUDER)
+  #include "feature/mixing.h"
+#endif
+
 #if ENABLED(BEZIER_CURVE_SUPPORT)
   #include "module/planner_bezier.h"
 #endif
 
 #if ENABLED(MAX7219_DEBUG)
   #include "feature/Max7219_Debug_LEDs.h"
 #endif
 
 #if HAS_COLOR_LEDS
   #include "feature/leds/leds.h"
@@ -179,27 +183,20 @@ millis_t max_inactive_time = 0,
 #endif
 
 #if ENABLED(FILAMENT_RUNOUT_SENSOR)
   static bool filament_ran_out = false;
 #endif
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   AdvancedPauseMenuResponse advanced_pause_menu_response;
 #endif
 
-#if ENABLED(MIXING_EXTRUDER)
-  float mixing_factor[MIXING_STEPPERS]; // Reciprocal of mix proportion. 0.0 = off, otherwise >= 1.0.
-  #if MIXING_VIRTUAL_TOOLS > 1
-    float mixing_virtual_tool_mix[MIXING_VIRTUAL_TOOLS][MIXING_STEPPERS];
-  #endif
-#endif
-
 #ifdef CHDK
   millis_t chdkHigh = 0;
   bool chdkActive = false;
 #endif
 
 #if ENABLED(PID_EXTRUSION_SCALING)
   int lpq_len = 20;
 #endif
 
 #if ENABLED(I2C_POSITION_ENCODERS)
@@ -295,59 +292,20 @@ void suicide() {
   void i2c_on_receive(int bytes) { // just echo all bytes received to serial
     i2c.receive(bytes);
   }
 
   void i2c_on_request() {          // just send dummy data for now
     i2c.reply("Hello World!\n");
   }
 
 #endif
 
-#if ENABLED(MIXING_EXTRUDER)
-
-  void normalize_mix() {
-    float mix_total = 0.0;
-    for (uint8_t i = 0; i < MIXING_STEPPERS; i++) mix_total += RECIPROCAL(mixing_factor[i]);
-    // Scale all values if they don't add up to ~1.0
-    if (!NEAR(mix_total, 1.0)) {
-      SERIAL_PROTOCOLLNPGM("Warning: Mix factors must add up to 1.0. Scaling.");
-      for (uint8_t i = 0; i < MIXING_STEPPERS; i++) mixing_factor[i] *= mix_total;
-    }
-  }
-
-  #if ENABLED(DIRECT_MIXING_IN_G1)
-    // Get mixing parameters from the GCode
-    // The total "must" be 1.0 (but it will be normalized)
-    // If no mix factors are given, the old mix is preserved
-    void gcode_get_mix() {
-      const char* mixing_codes = "ABCDHI";
-      byte mix_bits = 0;
-      for (uint8_t i = 0; i < MIXING_STEPPERS; i++) {
-        if (parser.seenval(mixing_codes[i])) {
-          SBI(mix_bits, i);
-          float v = parser.value_float();
-          NOLESS(v, 0.0);
-          mixing_factor[i] = RECIPROCAL(v);
-        }
-      }
-      // If any mixing factors were included, clear the rest
-      // If none were included, preserve the last mix
-      if (mix_bits) {
-        for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
-          if (!TEST(mix_bits, i)) mixing_factor[i] = 0.0;
-        normalize_mix();
-      }
-    }
-  #endif
-
-#endif
-
 /**************************************************
  ***************** GCode Handlers *****************
  **************************************************/
 
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
@@ -355,30 +313,20 @@ bool pin_is_protected(const int8_t pin) {
   return false;
 }
 
 void quickstop_stepper() {
   stepper.quick_stop();
   stepper.synchronize();
   set_current_from_steppers_for_axis(ALL_AXES);
   SYNC_PLAN_POSITION_KINEMATIC();
 }
 
-#if ENABLED(MIXING_EXTRUDER)
-  #include "gcode/feature/mixing/M163.h"
-  #if MIXING_VIRTUAL_TOOLS > 1
-    #include "gcode/feature/mixing/M164.h"
-  #endif
-  #if ENABLED(DIRECT_MIXING_IN_G1)
-    #include "gcode/feature/mixing/M165.h"
-  #endif
-#endif
-
 #include "gcode/control/M999.h"
 
 #include "gcode/control/T.h"
 
 #if ENABLED(USE_CONTROLLER_FAN)
 
   void controllerFan() {
     static millis_t lastMotorOn = 0, // Last time a motor was turned on
                     nextMotorCheck = 0; // Last time the state was checked
     const millis_t ms = millis();
@@ -950,26 +898,21 @@ void setup() {
       safe_delay(BOOTSCREEN_TIMEOUT);             // Pause
     #elif ENABLED(ULTRA_LCD)
       lcd_bootscreen();
       #if DISABLED(SDSUPPORT)
         lcd_init();
       #endif
     #endif
   #endif
 
   #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
-    // Initialize mixing to 100% color 1
-    for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
-      mixing_factor[i] = (i == 0) ? 1.0 : 0.0;
-    for (uint8_t t = 0; t < MIXING_VIRTUAL_TOOLS; t++)
-      for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
-        mixing_virtual_tool_mix[t][i] = mixing_factor[i];
+    mixing_tools_init();
   #endif
 
   #if ENABLED(BLTOUCH)
     bltouch_init();
   #endif
 
   #if ENABLED(I2C_POSITION_ENCODERS)
     I2CPEM.init();
   #endif
 

commit 8ca0b2fd683e62192821fbe2022f897483294804
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 17 18:56:29 2017 -0500

    Move M355 caselight to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 9ccd57566c..eb05267872 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -123,20 +123,24 @@
 #endif
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE) && ENABLED(PAUSE_PARK_NO_STEPPER_TIMEOUT)
   #include "feature/pause.h"
 #endif
 
 #if ENABLED(TEMP_STAT_LEDS)
   #include "feature/leds/tempstat.h"
 #endif
 
+#if HAS_CASE_LIGHT
+  #include "feature/caselight.h"
+#endif
+
 bool Running = true;
 
 /**
  * axis_homed
  *   Flags that each linear axis was homed.
  *   XYZ on cartesian, ABC on delta, ABZ on SCARA.
  *
  * axis_known_position
  *   Flags that the position is known in each linear axis. Set when homed.
  *   Cleared whenever a stepper powers off, potentially losing its position.
@@ -351,22 +355,20 @@ bool pin_is_protected(const int8_t pin) {
   return false;
 }
 
 void quickstop_stepper() {
   stepper.quick_stop();
   stepper.synchronize();
   set_current_from_steppers_for_axis(ALL_AXES);
   SYNC_PLAN_POSITION_KINEMATIC();
 }
 
-#include "gcode/feature/caselight/M355.h"
-
 #if ENABLED(MIXING_EXTRUDER)
   #include "gcode/feature/mixing/M163.h"
   #if MIXING_VIRTUAL_TOOLS > 1
     #include "gcode/feature/mixing/M164.h"
   #endif
   #if ENABLED(DIRECT_MIXING_IN_G1)
     #include "gcode/feature/mixing/M165.h"
   #endif
 #endif
 
@@ -852,22 +854,20 @@ void setup() {
 
   #if HAS_SERVOS
     servo_init();
   #endif
 
   #if HAS_PHOTOGRAPH
     OUT_WRITE(PHOTOGRAPH_PIN, LOW);
   #endif
 
   #if HAS_CASE_LIGHT
-    case_light_on = CASE_LIGHT_DEFAULT_ON;
-    case_light_brightness = CASE_LIGHT_DEFAULT_BRIGHTNESS;
     update_case_light();
   #endif
 
   #if ENABLED(SPINDLE_LASER_ENABLE)
     OUT_WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);  // init spindle to off
     #if SPINDLE_DIR_CHANGE
       OUT_WRITE(SPINDLE_DIR_PIN, SPINDLE_INVERT_DIR ? 255 : 0);  // init rotation to clockwise (M3)
     #endif
     #if ENABLED(SPINDLE_LASER_PWM) && defined(SPINDLE_LASER_PWM_PIN) && SPINDLE_LASER_PWM_PIN >= 0
       SET_OUTPUT(SPINDLE_LASER_PWM_PIN);

commit 59608086e630c45167209e20d9a924f89e0908c6
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 17 18:48:55 2017 -0500

    Move M350_M351 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index d371bf9b5f..9ccd57566c 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -351,25 +351,20 @@ bool pin_is_protected(const int8_t pin) {
   return false;
 }
 
 void quickstop_stepper() {
   stepper.quick_stop();
   stepper.synchronize();
   set_current_from_steppers_for_axis(ALL_AXES);
   SYNC_PLAN_POSITION_KINEMATIC();
 }
 
-#if HAS_MICROSTEPS
-  #include "gcode/control/M350.h"
-  #include "gcode/control/M351.h"
-#endif
-
 #include "gcode/feature/caselight/M355.h"
 
 #if ENABLED(MIXING_EXTRUDER)
   #include "gcode/feature/mixing/M163.h"
   #if MIXING_VIRTUAL_TOOLS > 1
     #include "gcode/feature/mixing/M164.h"
   #endif
   #if ENABLED(DIRECT_MIXING_IN_G1)
     #include "gcode/feature/mixing/M165.h"
   #endif

commit 6e0503eab2329ee9664a3611b225e55559a97944
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 17 18:45:21 2017 -0500

    Move M907-M910 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 6aaaa73c06..d371bf9b5f 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -51,20 +51,24 @@
 #include "gcode/queue.h"
 
 #if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER)
   #include "libs/buzzer.h"
 #endif
 
 #if (ENABLED(SWITCHING_EXTRUDER) && !DONT_SWITCH) || ENABLED(SWITCHING_NOZZLE)
   #include "module/tool_change.h"
 #endif
 
+#if ENABLED(DIGIPOT_I2C)
+  #include "feature/digipot/digipot.h"
+#endif
+
 #if ENABLED(BEZIER_CURVE_SUPPORT)
   #include "module/planner_bezier.h"
 #endif
 
 #if ENABLED(MAX7219_DEBUG)
   #include "feature/Max7219_Debug_LEDs.h"
 #endif
 
 #if HAS_COLOR_LEDS
   #include "feature/leds/leds.h"
@@ -199,25 +203,20 @@ millis_t max_inactive_time = 0,
   uint8_t blockBufferIndexRef = 0;
   millis_t lastUpdateMillis;
 #endif
 
 /**
  * ***************************************************************************
  * ******************************** FUNCTIONS ********************************
  * ***************************************************************************
  */
 
-#if ENABLED(DIGIPOT_I2C)
-  extern void digipot_i2c_set_current(uint8_t channel, float current);
-  extern void digipot_i2c_init();
-#endif
-
 void setup_killpin() {
   #if HAS_KILL
     SET_INPUT_PULLUP(KILL_PIN);
   #endif
 }
 
 #if ENABLED(FILAMENT_RUNOUT_SENSOR)
 
   void setup_filrunoutpin() {
     #if ENABLED(ENDSTOPPULLUP_FIL_RUNOUT)
@@ -352,30 +351,20 @@ bool pin_is_protected(const int8_t pin) {
   return false;
 }
 
 void quickstop_stepper() {
   stepper.quick_stop();
   stepper.synchronize();
   set_current_from_steppers_for_axis(ALL_AXES);
   SYNC_PLAN_POSITION_KINEMATIC();
 }
 
-#include "gcode/feature/digipot/M907.h"
-
-#if HAS_DIGIPOTSS || ENABLED(DAC_STEPPER_CURRENT)
-  #include "gcode/feature/digipot/M908.h"
-  #if ENABLED(DAC_STEPPER_CURRENT) // As with Printrbot RevF
-    #include "gcode/feature/digipot/M909.h"
-    #include "gcode/feature/digipot/M910.h"
-  #endif
-#endif
-
 #if HAS_MICROSTEPS
   #include "gcode/control/M350.h"
   #include "gcode/control/M351.h"
 #endif
 
 #include "gcode/feature/caselight/M355.h"
 
 #if ENABLED(MIXING_EXTRUDER)
   #include "gcode/feature/mixing/M163.h"
   #if MIXING_VIRTUAL_TOOLS > 1

commit 2e89685154dbae09f97dc4ac95022cad56b40365
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 17 18:34:04 2017 -0500

    Move TMC2130 g-codes to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 1204f944f1..6aaaa73c06 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -88,43 +88,43 @@
 #endif
 
 #if ENABLED(I2C_POSITION_ENCODERS)
   #include "feature/I2CPositionEncoder.h"
 #endif
 
 #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
   #include "HAL/HAL_endstop_interrupts.h"
 #endif
 
+#if ENABLED(HAVE_TMC2130)
+  #include "feature/tmc2130.h"
+#endif
+
 #if ENABLED(SDSUPPORT)
   CardReader card;
 #endif
 
 #if ENABLED(G38_PROBE_TARGET)
   bool G38_move = false,
        G38_endstop_hit = false;
 #endif
 
 #if ENABLED(DELTA)
   #include "module/delta.h"
 #elif IS_SCARA
   #include "module/scara.h"
 #endif
 
 #if HAS_LEVELING
   #include "feature/bedlevel/bedlevel.h"
 #endif
 
-#if ENABLED(SENSORLESS_HOMING)
-  #include "feature/tmc2130.h"
-#endif
-
 #if ENABLED(ADVANCED_PAUSE_FEATURE) && ENABLED(PAUSE_PARK_NO_STEPPER_TIMEOUT)
   #include "feature/pause.h"
 #endif
 
 #if ENABLED(TEMP_STAT_LEDS)
   #include "feature/leds/tempstat.h"
 #endif
 
 bool Running = true;
 
@@ -352,33 +352,20 @@ bool pin_is_protected(const int8_t pin) {
   return false;
 }
 
 void quickstop_stepper() {
   stepper.quick_stop();
   stepper.synchronize();
   set_current_from_steppers_for_axis(ALL_AXES);
   SYNC_PLAN_POSITION_KINEMATIC();
 }
 
-#if ENABLED(HAVE_TMC2130)
-  #include "feature/tmc2130.h"
-  #include "gcode/feature/trinamic/M906.h"
-  #include "gcode/feature/trinamic/M911.h"
-  #include "gcode/feature/trinamic/M912.h"
-  #if ENABLED(HYBRID_THRESHOLD)
-    #include "gcode/feature/trinamic/M913.h"
-  #endif
-  #if ENABLED(SENSORLESS_HOMING)
-    #include "gcode/feature/trinamic/M914.h"
-  #endif
-#endif
-
 #include "gcode/feature/digipot/M907.h"
 
 #if HAS_DIGIPOTSS || ENABLED(DAC_STEPPER_CURRENT)
   #include "gcode/feature/digipot/M908.h"
   #if ENABLED(DAC_STEPPER_CURRENT) // As with Printrbot RevF
     #include "gcode/feature/digipot/M909.h"
     #include "gcode/feature/digipot/M910.h"
   #endif
 #endif
 

commit 19dde5be03e2c532f63860723e74fa4895965c05
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 17 17:42:53 2017 -0500

    Move M900 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 9dcc90b75a..1204f944f1 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -352,24 +352,20 @@ bool pin_is_protected(const int8_t pin) {
   return false;
 }
 
 void quickstop_stepper() {
   stepper.quick_stop();
   stepper.synchronize();
   set_current_from_steppers_for_axis(ALL_AXES);
   SYNC_PLAN_POSITION_KINEMATIC();
 }
 
-#if ENABLED(LIN_ADVANCE)
-  #include "gcode/feature/advance/M900.h"
-#endif
-
 #if ENABLED(HAVE_TMC2130)
   #include "feature/tmc2130.h"
   #include "gcode/feature/trinamic/M906.h"
   #include "gcode/feature/trinamic/M911.h"
   #include "gcode/feature/trinamic/M912.h"
   #if ENABLED(HYBRID_THRESHOLD)
     #include "gcode/feature/trinamic/M913.h"
   #endif
   #if ENABLED(SENSORLESS_HOMING)
     #include "gcode/feature/trinamic/M914.h"

commit 1b0acbff720046cdaa7d24dcbc8dbf5d26b3c1b8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 17 17:24:56 2017 -0500

    Move M605 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 986cf2ae68..9dcc90b75a 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -352,24 +352,20 @@ bool pin_is_protected(const int8_t pin) {
   return false;
 }
 
 void quickstop_stepper() {
   stepper.quick_stop();
   stepper.synchronize();
   set_current_from_steppers_for_axis(ALL_AXES);
   SYNC_PLAN_POSITION_KINEMATIC();
 }
 
-#if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
-  #include "gcode/control/M605.h"
-#endif
-
 #if ENABLED(LIN_ADVANCE)
   #include "gcode/feature/advance/M900.h"
 #endif
 
 #if ENABLED(HAVE_TMC2130)
   #include "feature/tmc2130.h"
   #include "gcode/feature/trinamic/M906.h"
   #include "gcode/feature/trinamic/M911.h"
   #include "gcode/feature/trinamic/M912.h"
   #if ENABLED(HYBRID_THRESHOLD)

commit 75cf17d8165beed9b0392f1edb6e0a8a67b5f874
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 17 16:58:16 2017 -0500

    Move M702 MK2_MULTIPLEXER to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 8e21230022..986cf2ae68 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -352,24 +352,20 @@ bool pin_is_protected(const int8_t pin) {
   return false;
 }
 
 void quickstop_stepper() {
   stepper.quick_stop();
   stepper.synchronize();
   set_current_from_steppers_for_axis(ALL_AXES);
   SYNC_PLAN_POSITION_KINEMATIC();
 }
 
-#if ENABLED(MK2_MULTIPLEXER)
-  #include "gcode/feature/snmm/M702.h"
-#endif
-
 #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
   #include "gcode/control/M605.h"
 #endif
 
 #if ENABLED(LIN_ADVANCE)
   #include "gcode/feature/advance/M900.h"
 #endif
 
 #if ENABLED(HAVE_TMC2130)
   #include "feature/tmc2130.h"

commit 7ba2ab4fb373867371db1ae8c72d7b21545bff80
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 17 15:26:15 2017 -0500

    Move M540 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index f0b5d971a6..8e21230022 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -352,24 +352,20 @@ bool pin_is_protected(const int8_t pin) {
   return false;
 }
 
 void quickstop_stepper() {
   stepper.quick_stop();
   stepper.synchronize();
   set_current_from_steppers_for_axis(ALL_AXES);
   SYNC_PLAN_POSITION_KINEMATIC();
 }
 
-#if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
-  #include "gcode/config/M540.h"
-#endif
-
 #if ENABLED(MK2_MULTIPLEXER)
   #include "gcode/feature/snmm/M702.h"
 #endif
 
 #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
   #include "gcode/control/M605.h"
 #endif
 
 #if ENABLED(LIN_ADVANCE)
   #include "gcode/feature/advance/M900.h"

commit a90c7dbf64eafe10a2f8103420c9e222363b35a7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 17 04:28:25 2017 -0500

    Move M500-M503 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 7cdc595f49..f0b5d971a6 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -352,27 +352,20 @@ bool pin_is_protected(const int8_t pin) {
   return false;
 }
 
 void quickstop_stepper() {
   stepper.quick_stop();
   stepper.synchronize();
   set_current_from_steppers_for_axis(ALL_AXES);
   SYNC_PLAN_POSITION_KINEMATIC();
 }
 
-#include "gcode/eeprom/M500.h"
-#include "gcode/eeprom/M501.h"
-#include "gcode/eeprom/M502.h"
-#if DISABLED(DISABLE_M503)
-  #include "gcode/eeprom/M503.h"
-#endif
-
 #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
   #include "gcode/config/M540.h"
 #endif
 
 #if ENABLED(MK2_MULTIPLEXER)
   #include "gcode/feature/snmm/M702.h"
 #endif
 
 #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
   #include "gcode/control/M605.h"

commit aab548996240a4d4463d34720cc57644c52de522
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 17 04:22:37 2017 -0500

    Move M428 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index c96bdaf096..7cdc595f49 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -352,24 +352,20 @@ bool pin_is_protected(const int8_t pin) {
   return false;
 }
 
 void quickstop_stepper() {
   stepper.quick_stop();
   stepper.synchronize();
   set_current_from_steppers_for_axis(ALL_AXES);
   SYNC_PLAN_POSITION_KINEMATIC();
 }
 
-#if HAS_M206_COMMAND
-  #include "gcode/geometry/M428.h"
-#endif
-
 #include "gcode/eeprom/M500.h"
 #include "gcode/eeprom/M501.h"
 #include "gcode/eeprom/M502.h"
 #if DISABLED(DISABLE_M503)
   #include "gcode/eeprom/M503.h"
 #endif
 
 #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
   #include "gcode/config/M540.h"
 #endif

commit 1fe25271e4a6bfd23f29a34ccedbfc6010d363d6
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 17 04:16:28 2017 -0500

    Move M401_M402 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 08ba0c26e1..c96bdaf096 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -345,24 +345,20 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#if HAS_BED_PROBE
-  #include "gcode/probe/M401_M402.h"
-#endif
-
 void quickstop_stepper() {
   stepper.quick_stop();
   stepper.synchronize();
   set_current_from_steppers_for_axis(ALL_AXES);
   SYNC_PLAN_POSITION_KINEMATIC();
 }
 
 #if HAS_M206_COMMAND
   #include "gcode/geometry/M428.h"
 #endif

commit 0589884d26a73b76455a276de45f5eab0eefb606
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 17 03:53:36 2017 -0500

    Move M400 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 20bb9de54f..08ba0c26e1 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -345,22 +345,20 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#include "gcode/control/M400.h"
-
 #if HAS_BED_PROBE
   #include "gcode/probe/M401_M402.h"
 #endif
 
 void quickstop_stepper() {
   stepper.quick_stop();
   stepper.synchronize();
   set_current_from_steppers_for_axis(ALL_AXES);
   SYNC_PLAN_POSITION_KINEMATIC();
 }

commit 4a220a8b79ec9c355faa2a0ab640d91dad508217
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 17 03:43:45 2017 -0500

    Move M380_M381 to cpp, solenoid feature

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 9d94342790..20bb9de54f 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -345,24 +345,20 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#if ENABLED(EXT_SOLENOID)
-  #include "gcode/control/M380_M381.h"
-#endif
-
 #include "gcode/control/M400.h"
 
 #if HAS_BED_PROBE
   #include "gcode/probe/M401_M402.h"
 #endif
 
 void quickstop_stepper() {
   stepper.quick_stop();
   stepper.synchronize();
   set_current_from_steppers_for_axis(ALL_AXES);

commit 9be8cb0ac9cd6689651a3f3ddc9af0144f782922
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 17 03:34:20 2017 -0500

    Move M360-M364 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 81d7a7e31a..9d94342790 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -345,24 +345,20 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#if ENABLED(MORGAN_SCARA)
-  #include "gcode/scara/M360-M364.h"
-#endif
-
 #if ENABLED(EXT_SOLENOID)
   #include "gcode/control/M380_M381.h"
 #endif
 
 #include "gcode/control/M400.h"
 
 #if HAS_BED_PROBE
   #include "gcode/probe/M401_M402.h"
 #endif
 

commit 828405cac817c13623cc384aee170e6c352f5607
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 17 03:29:29 2017 -0500

    Move M302 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 4948cf3294..81d7a7e31a 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -345,24 +345,20 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#if ENABLED(PREVENT_COLD_EXTRUSION)
-  #include "gcode/config/M302.h"
-#endif
-
 #if ENABLED(MORGAN_SCARA)
   #include "gcode/scara/M360-M364.h"
 #endif
 
 #if ENABLED(EXT_SOLENOID)
   #include "gcode/control/M380_M381.h"
 #endif
 
 #include "gcode/control/M400.h"
 

commit 8584f7e390f22886b9c6c52302ed87ab81ddad06
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 17 03:23:20 2017 -0500

    Move M250 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 826ad85ef2..4948cf3294 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -345,24 +345,20 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#if HAS_LCD_CONTRAST
-  #include "gcode/lcd/M250.h"
-#endif
-
 #if ENABLED(PREVENT_COLD_EXTRUSION)
   #include "gcode/config/M302.h"
 #endif
 
 #if ENABLED(MORGAN_SCARA)
   #include "gcode/scara/M360-M364.h"
 #endif
 
 #if ENABLED(EXT_SOLENOID)
   #include "gcode/control/M380_M381.h"

commit ebb9bd541919c9682e9550aab5dc6052e3ebb729
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 17 03:20:32 2017 -0500

    Move M240 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 464b552dc5..826ad85ef2 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -345,24 +345,20 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#if defined(CHDK) || HAS_PHOTOGRAPH
-  #include "gcode/feature/camera/M240.h"
-#endif
-
 #if HAS_LCD_CONTRAST
   #include "gcode/lcd/M250.h"
 #endif
 
 #if ENABLED(PREVENT_COLD_EXTRUSION)
   #include "gcode/config/M302.h"
 #endif
 
 #if ENABLED(MORGAN_SCARA)
   #include "gcode/scara/M360-M364.h"

commit d4aaa0f1c8ac3cb29c5763972d029f60c5e91dba
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 17 03:09:48 2017 -0500

    Move M304 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 8798e824b0..464b552dc5 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -345,24 +345,20 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#if ENABLED(PIDTEMPBED)
-  #include "gcode/config/M304.h"
-#endif
-
 #if defined(CHDK) || HAS_PHOTOGRAPH
   #include "gcode/feature/camera/M240.h"
 #endif
 
 #if HAS_LCD_CONTRAST
   #include "gcode/lcd/M250.h"
 #endif
 
 #if ENABLED(PREVENT_COLD_EXTRUSION)
   #include "gcode/config/M302.h"

commit 609c4eea3250da58c0dea79117309c7dfa92ad2b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 17 03:07:35 2017 -0500

    Move M301 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 4f2941790d..8798e824b0 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -345,24 +345,20 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#if ENABLED(PIDTEMP)
-  #include "gcode/config/M301.h"
-#endif
-
 #if ENABLED(PIDTEMPBED)
   #include "gcode/config/M304.h"
 #endif
 
 #if defined(CHDK) || HAS_PHOTOGRAPH
   #include "gcode/feature/camera/M240.h"
 #endif
 
 #if HAS_LCD_CONTRAST
   #include "gcode/lcd/M250.h"

commit 4f14849675208d1bd8b69c84a77f2ae7f82297cb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 17 03:04:52 2017 -0500

    Move M300 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 50552c2dc6..4f2941790d 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -345,24 +345,20 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#if HAS_BUZZER
-  #include "gcode/lcd/M300.h"
-#endif
-
 #if ENABLED(PIDTEMP)
   #include "gcode/config/M301.h"
 #endif
 
 #if ENABLED(PIDTEMPBED)
   #include "gcode/config/M304.h"
 #endif
 
 #if defined(CHDK) || HAS_PHOTOGRAPH
   #include "gcode/feature/camera/M240.h"

commit 6ed5252884ed3f7ab9a27537b69371804b940088
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 17 02:58:39 2017 -0500

    Move M280 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 2d42dbaae0..50552c2dc6 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -345,24 +345,20 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#if HAS_SERVOS
-  #include "gcode/control/M280.h"
-#endif
-
 #if HAS_BUZZER
   #include "gcode/lcd/M300.h"
 #endif
 
 #if ENABLED(PIDTEMP)
   #include "gcode/config/M301.h"
 #endif
 
 #if ENABLED(PIDTEMPBED)
   #include "gcode/config/M304.h"

commit d4d3d92f8a60abe4145439332006dd616ccb3dc5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 17 02:49:13 2017 -0500

    Move M260_M261 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 0b22e745bb..2d42dbaae0 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -77,38 +77,35 @@
 #if HAS_DIGIPOTSS
   #include <SPI.h>
 #endif
 
 #if ENABLED(DAC_STEPPER_CURRENT)
   #include "feature/dac/stepper_dac.h"
 #endif
 
 #if ENABLED(EXPERIMENTAL_I2CBUS)
   #include "feature/twibus.h"
+  TWIBus i2c;
 #endif
 
 #if ENABLED(I2C_POSITION_ENCODERS)
   #include "feature/I2CPositionEncoder.h"
 #endif
 
 #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
   #include "HAL/HAL_endstop_interrupts.h"
 #endif
 
 #if ENABLED(SDSUPPORT)
   CardReader card;
 #endif
 
-#if ENABLED(EXPERIMENTAL_I2CBUS)
-  TWIBus i2c;
-#endif
-
 #if ENABLED(G38_PROBE_TARGET)
   bool G38_move = false,
        G38_endstop_hit = false;
 #endif
 
 #if ENABLED(DELTA)
   #include "module/delta.h"
 #elif IS_SCARA
   #include "module/scara.h"
 #endif
@@ -348,24 +345,20 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#if ENABLED(EXPERIMENTAL_I2CBUS)
-  #include "gcode/feature/i2c/M260_M261.h"
-#endif
-
 #if HAS_SERVOS
   #include "gcode/control/M280.h"
 #endif
 
 #if HAS_BUZZER
   #include "gcode/lcd/M300.h"
 #endif
 
 #if ENABLED(PIDTEMP)
   #include "gcode/config/M301.h"

commit 3e761696a04b3671997b3140f907b51e417c78ab
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 17 02:43:36 2017 -0500

    Move M226 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index c1073d4953..0b22e745bb 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -348,22 +348,20 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#include "gcode/control/M226.h"
-
 #if ENABLED(EXPERIMENTAL_I2CBUS)
   #include "gcode/feature/i2c/M260_M261.h"
 #endif
 
 #if HAS_SERVOS
   #include "gcode/control/M280.h"
 #endif
 
 #if HAS_BUZZER
   #include "gcode/lcd/M300.h"

commit 0e319104c2d93ddd4c4d4be5816695b7e00e3344
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 17 02:39:44 2017 -0500

    Move M220 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index f9f94dccc2..c1073d4953 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -348,22 +348,20 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#include "gcode/config/M220.h"
-
 #include "gcode/control/M226.h"
 
 #if ENABLED(EXPERIMENTAL_I2CBUS)
   #include "gcode/feature/i2c/M260_M261.h"
 #endif
 
 #if HAS_SERVOS
   #include "gcode/control/M280.h"
 #endif
 

commit 234de3547c53fd9e4f35f8cfd61ded0a555256a2
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 17 02:36:22 2017 -0500

    Move M211 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index b3f9cf243f..f9f94dccc2 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -348,22 +348,20 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#include "gcode/control/M211.h"
-
 #include "gcode/config/M220.h"
 
 #include "gcode/control/M226.h"
 
 #if ENABLED(EXPERIMENTAL_I2CBUS)
   #include "gcode/feature/i2c/M260_M261.h"
 #endif
 
 #if HAS_SERVOS
   #include "gcode/control/M280.h"

commit 6c7bad8bc334aac0c82ddc0ed818dc6ed0c0a90f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 17 02:25:52 2017 -0500

    Move M666 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index b409ff0909..b3f9cf243f 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -348,24 +348,20 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#if ENABLED(DELTA) || ENABLED(Z_DUAL_ENDSTOPS)
-  #include "gcode/calibrate/M666.h"
-#endif
-
 #include "gcode/control/M211.h"
 
 #include "gcode/config/M220.h"
 
 #include "gcode/control/M226.h"
 
 #if ENABLED(EXPERIMENTAL_I2CBUS)
   #include "gcode/feature/i2c/M260_M261.h"
 #endif
 

commit f5877aa93e6a7e592a4a9b1dd6f1dfcf6803b031
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 17 02:21:21 2017 -0500

    Move M665 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index a3a8d3a046..b409ff0909 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -348,24 +348,20 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#if IS_KINEMATIC
-  #include "gcode/calibrate/M665.h"
-#endif
-
 #if ENABLED(DELTA) || ENABLED(Z_DUAL_ENDSTOPS)
   #include "gcode/calibrate/M666.h"
 #endif
 
 #include "gcode/control/M211.h"
 
 #include "gcode/config/M220.h"
 
 #include "gcode/control/M226.h"
 

commit 33861d4e04cf478a81db0a9ad077ea722f48a07d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 17 01:43:20 2017 -0500

    Move M206 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 9d2772f50e..a3a8d3a046 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -348,24 +348,20 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#if HAS_M206_COMMAND
-  #include "gcode/geometry/M206.h"
-#endif
-
 #if IS_KINEMATIC
   #include "gcode/calibrate/M665.h"
 #endif
 
 #if ENABLED(DELTA) || ENABLED(Z_DUAL_ENDSTOPS)
   #include "gcode/calibrate/M666.h"
 #endif
 
 #include "gcode/control/M211.h"
 

commit 7aca9fe2f7aa2b05998f8db4119e5153184372ba
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 17 01:38:58 2017 -0500

    Move M203-M205 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index cef241e538..9d2772f50e 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -348,24 +348,20 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#include "gcode/config/M203.h"
-#include "gcode/config/M204.h"
-#include "gcode/config/M205.h"
-
 #if HAS_M206_COMMAND
   #include "gcode/geometry/M206.h"
 #endif
 
 #if IS_KINEMATIC
   #include "gcode/calibrate/M665.h"
 #endif
 
 #if ENABLED(DELTA) || ENABLED(Z_DUAL_ENDSTOPS)
   #include "gcode/calibrate/M666.h"

commit b3822b9242bc24924ea75582484a45db22131145
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 17 01:34:59 2017 -0500

    M202 is unused

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 5db1348b1d..cef241e538 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -348,24 +348,20 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#if 0 // Not used for Sprinter/grbl gen6
-  #include "gcode/config/M202.h"
-#endif
-
 #include "gcode/config/M203.h"
 #include "gcode/config/M204.h"
 #include "gcode/config/M205.h"
 
 #if HAS_M206_COMMAND
   #include "gcode/geometry/M206.h"
 #endif
 
 #if IS_KINEMATIC
   #include "gcode/calibrate/M665.h"

commit 5e63efc1d9510ea896089b9a55c54878945a73cd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 17 01:33:25 2017 -0500

    Move M201 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 976ae21da2..5db1348b1d 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -348,22 +348,20 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#include "gcode/config/M201.h"
-
 #if 0 // Not used for Sprinter/grbl gen6
   #include "gcode/config/M202.h"
 #endif
 
 #include "gcode/config/M203.h"
 #include "gcode/config/M204.h"
 #include "gcode/config/M205.h"
 
 #if HAS_M206_COMMAND
   #include "gcode/geometry/M206.h"

commit 92c15f5578aa5c6baa4609399bce7f756310ea97
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 17 00:50:24 2017 -0500

    Move M150 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 988d696add..976ae21da2 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -348,24 +348,20 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#if HAS_COLOR_LEDS
-  #include "gcode/feature/leds/M150.h"
-#endif
-
 #include "gcode/config/M201.h"
 
 #if 0 // Not used for Sprinter/grbl gen6
   #include "gcode/config/M202.h"
 #endif
 
 #include "gcode/config/M203.h"
 #include "gcode/config/M204.h"
 #include "gcode/config/M205.h"
 

commit eef4a5477887996e67947239add9dde2d34550e6
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 17 00:46:24 2017 -0500

    Move M119-M121 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index e7e92242f4..988d696add 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -348,24 +348,20 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#include "gcode/host/M119.h"
-
-#include "gcode/control/M120_M121.h"
-
 #if HAS_COLOR_LEDS
   #include "gcode/feature/leds/M150.h"
 #endif
 
 #include "gcode/config/M201.h"
 
 #if 0 // Not used for Sprinter/grbl gen6
   #include "gcode/config/M202.h"
 #endif
 

commit 379f16558e5ebdfc2c005463e40211ac295fb28b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 17 00:42:42 2017 -0500

    Move M118 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index e20b55ad6f..e7e92242f4 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -348,21 +348,20 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#include "gcode/host/M118.h"
 #include "gcode/host/M119.h"
 
 #include "gcode/control/M120_M121.h"
 
 #if HAS_COLOR_LEDS
   #include "gcode/feature/leds/M150.h"
 #endif
 
 #include "gcode/config/M201.h"
 

commit 811c32b85adfa69fe855de5e6b877b314506388a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 17 00:40:59 2017 -0500

    Move M117 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 01aa52b179..e20b55ad6f 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -348,22 +348,20 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#include "gcode/lcd/M117.h"
-
 #include "gcode/host/M118.h"
 #include "gcode/host/M119.h"
 
 #include "gcode/control/M120_M121.h"
 
 #if HAS_COLOR_LEDS
   #include "gcode/feature/leds/M150.h"
 #endif
 
 #include "gcode/config/M201.h"

commit 1d2061c9353aec7871016b9126185722fef43b97
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 17 00:38:39 2017 -0500

    Move M115 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index afbd07b369..01aa52b179 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -348,22 +348,20 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#include "gcode/host/M115.h"
-
 #include "gcode/lcd/M117.h"
 
 #include "gcode/host/M118.h"
 #include "gcode/host/M119.h"
 
 #include "gcode/control/M120_M121.h"
 
 #if HAS_COLOR_LEDS
   #include "gcode/feature/leds/M150.h"
 #endif

commit 81b8fbf4d6c5336bbb1fb4c686522fbaa145e5a2
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 17 00:36:30 2017 -0500

    Move M114 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 5ba526de85..afbd07b369 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -348,21 +348,20 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#include "gcode/host/M114.h"
 #include "gcode/host/M115.h"
 
 #include "gcode/lcd/M117.h"
 
 #include "gcode/host/M118.h"
 #include "gcode/host/M119.h"
 
 #include "gcode/control/M120_M121.h"
 
 #if HAS_COLOR_LEDS

commit 5d2681a10518c2e279c10976c6efdc46ec2bdae7
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 17 00:33:00 2017 -0500

    Move M100 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 49968cfb43..5ba526de85 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -87,24 +87,20 @@
 #endif
 
 #if ENABLED(I2C_POSITION_ENCODERS)
   #include "feature/I2CPositionEncoder.h"
 #endif
 
 #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
   #include "HAL/HAL_endstop_interrupts.h"
 #endif
 
-#if ENABLED(M100_FREE_MEMORY_WATCHER)
-  void M100_dump_routine(const char * const title, const char *start, const char *end);
-#endif
-
 #if ENABLED(SDSUPPORT)
   CardReader card;
 #endif
 
 #if ENABLED(EXPERIMENTAL_I2CBUS)
   TWIBus i2c;
 #endif
 
 #if ENABLED(G38_PROBE_TARGET)
   bool G38_move = false,
@@ -352,24 +348,20 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#if ENABLED(M100_FREE_MEMORY_WATCHER)
-  #include "gcode/calibrate/M100.h"
-#endif
-
 #include "gcode/host/M114.h"
 #include "gcode/host/M115.h"
 
 #include "gcode/lcd/M117.h"
 
 #include "gcode/host/M118.h"
 #include "gcode/host/M119.h"
 
 #include "gcode/control/M120_M121.h"
 

commit beb346e49f1acbf3b74b5fde8bb9cb7ad080e58b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Sep 17 00:28:10 2017 -0500

    Move M92 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index b3da3af431..49968cfb43 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -352,22 +352,20 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#include "gcode/config/M92.h"
-
 #if ENABLED(M100_FREE_MEMORY_WATCHER)
   #include "gcode/calibrate/M100.h"
 #endif
 
 #include "gcode/host/M114.h"
 #include "gcode/host/M115.h"
 
 #include "gcode/lcd/M117.h"
 
 #include "gcode/host/M118.h"

commit 381b17e6a91783bad1c0eed2ddbb779df2b4b6ef
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 16 23:57:09 2017 -0500

    Move M18_M84, M85 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 79d7ca0bde..b3da3af431 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -163,22 +163,22 @@ float filament_size[EXTRUDERS], volumetric_multiplier[EXTRUDERS];
 
 // For M109 and M190, this flag may be cleared (by M108) to exit the wait loop
 volatile bool wait_for_heatup = true;
 
 // For M0/M1, this flag may be cleared (by M108) to exit the wait-for-user loop
 #if HAS_RESUME_CONTINUE
   volatile bool wait_for_user = false;
 #endif
 
 // Inactivity shutdown
-static millis_t max_inactive_time = 0;
-static millis_t stepper_inactive_time = (DEFAULT_STEPPER_DEACTIVE_TIME) * 1000UL;
+millis_t max_inactive_time = 0,
+         stepper_inactive_time = (DEFAULT_STEPPER_DEACTIVE_TIME) * 1000UL;
 
 #if ENABLED(Z_DUAL_ENDSTOPS)
   float z_endstop_adj;
 #endif
 
 #if ENABLED(FILAMENT_RUNOUT_SENSOR)
   static bool filament_ran_out = false;
 #endif
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
@@ -352,24 +352,20 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#include "gcode/control/M18_M84.h"
-
-#include "gcode/control/M85.h"
-
 #include "gcode/config/M92.h"
 
 #if ENABLED(M100_FREE_MEMORY_WATCHER)
   #include "gcode/calibrate/M100.h"
 #endif
 
 #include "gcode/host/M114.h"
 #include "gcode/host/M115.h"
 
 #include "gcode/lcd/M117.h"

commit a911215b0ef44e721dbc4cc18f833c486009e3e0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 16 23:27:06 2017 -0500

    Move M82_M83 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 4b1ac1df7d..79d7ca0bde 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -352,22 +352,20 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#include "gcode/units/M82_M83.h"
-
 #include "gcode/control/M18_M84.h"
 
 #include "gcode/control/M85.h"
 
 #include "gcode/config/M92.h"
 
 #if ENABLED(M100_FREE_MEMORY_WATCHER)
   #include "gcode/calibrate/M100.h"
 #endif
 

commit 4b9d1b9f260589e5e758bcc90968535cab7bdfa4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 16 23:25:01 2017 -0500

    Move M80-M81 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 5259e33150..4b1ac1df7d 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -170,30 +170,20 @@ volatile bool wait_for_heatup = true;
 #endif
 
 // Inactivity shutdown
 static millis_t max_inactive_time = 0;
 static millis_t stepper_inactive_time = (DEFAULT_STEPPER_DEACTIVE_TIME) * 1000UL;
 
 #if ENABLED(Z_DUAL_ENDSTOPS)
   float z_endstop_adj;
 #endif
 
-#if HAS_POWER_SWITCH
-  bool powersupply_on =
-    #if ENABLED(PS_DEFAULT_OFF)
-      false
-    #else
-      true
-    #endif
-  ;
-#endif
-
 #if ENABLED(FILAMENT_RUNOUT_SENSOR)
   static bool filament_ran_out = false;
 #endif
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   AdvancedPauseMenuResponse advanced_pause_menu_response;
 #endif
 
 #if ENABLED(MIXING_EXTRUDER)
   float mixing_factor[MIXING_STEPPERS]; // Reciprocal of mix proportion. 0.0 = off, otherwise >= 1.0.
@@ -362,26 +352,20 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#if HAS_POWER_SWITCH
-  #include "gcode/control/M80.h"
-#endif
-
-#include "gcode/control/M81.h"
-
 #include "gcode/units/M82_M83.h"
 
 #include "gcode/control/M18_M84.h"
 
 #include "gcode/control/M85.h"
 
 #include "gcode/config/M92.h"
 
 #if ENABLED(M100_FREE_MEMORY_WATCHER)
   #include "gcode/calibrate/M100.h"

commit 0c7ba52451195c9ad5b77a6accb92c8d5aa9b58d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 16 23:15:33 2017 -0500

    Move M149 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index ce77844dae..5259e33150 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -362,24 +362,20 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#if ENABLED(TEMPERATURE_UNITS_SUPPORT)
-  #include "gcode/units/M149.h"
-#endif
-
 #if HAS_POWER_SWITCH
   #include "gcode/control/M80.h"
 #endif
 
 #include "gcode/control/M81.h"
 
 #include "gcode/units/M82_M83.h"
 
 #include "gcode/control/M18_M84.h"
 

commit cbf40f7ee9ea0cbc1192129920df5163deed1f6b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 16 23:11:35 2017 -0500

    Move M145 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 24c61f24a2..ce77844dae 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -362,24 +362,20 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#if ENABLED(ULTIPANEL)
-  #include "gcode/lcd/M145.h"
-#endif
-
 #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
   #include "gcode/units/M149.h"
 #endif
 
 #if HAS_POWER_SWITCH
   #include "gcode/control/M80.h"
 #endif
 
 #include "gcode/control/M81.h"
 

commit b464887ea198d92bb3b5eac07e72decf074861b6
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 16 22:58:13 2017 -0500

    Make BARICUDA a feature

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 613873a37c..24c61f24a2 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -170,25 +170,20 @@ volatile bool wait_for_heatup = true;
 #endif
 
 // Inactivity shutdown
 static millis_t max_inactive_time = 0;
 static millis_t stepper_inactive_time = (DEFAULT_STEPPER_DEACTIVE_TIME) * 1000UL;
 
 #if ENABLED(Z_DUAL_ENDSTOPS)
   float z_endstop_adj;
 #endif
 
-#if ENABLED(BARICUDA)
-  uint8_t baricuda_valve_pressure = 0,
-          baricuda_e_to_p_pressure = 0;
-#endif
-
 #if HAS_POWER_SWITCH
   bool powersupply_on =
     #if ENABLED(PS_DEFAULT_OFF)
       false
     #else
       true
     #endif
   ;
 #endif
 
@@ -367,31 +362,20 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#if ENABLED(BARICUDA)
-  #if HAS_HEATER_1
-    #include "gcode/feature/baricuda/M126.h"
-    #include "gcode/feature/baricuda/M127.h"
-  #endif
-  #if HAS_HEATER_2
-    #include "gcode/feature/baricuda/M128.h"
-    #include "gcode/feature/baricuda/M129.h"
-  #endif
-#endif
-
 #if ENABLED(ULTIPANEL)
   #include "gcode/lcd/M145.h"
 #endif
 
 #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
   #include "gcode/units/M149.h"
 #endif
 
 #if HAS_POWER_SWITCH
   #include "gcode/control/M80.h"

commit 14a5d2a2736c5e699d0b6f7d5526306b2ae47558
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 16 22:45:58 2017 -0500

    Move M113 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 995c6bdd10..613873a37c 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -367,24 +367,20 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#if ENABLED(HOST_KEEPALIVE_FEATURE)
-  #include "gcode/host/M113.h"
-#endif
-
 #if ENABLED(BARICUDA)
   #if HAS_HEATER_1
     #include "gcode/feature/baricuda/M126.h"
     #include "gcode/feature/baricuda/M127.h"
   #endif
   #if HAS_HEATER_2
     #include "gcode/feature/baricuda/M128.h"
     #include "gcode/feature/baricuda/M129.h"
   #endif
 #endif

commit 06f3c8029efff175fb70aa71184be4c1329ca292
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 16 22:40:04 2017 -0500

    Move M111 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 9db7d77c90..995c6bdd10 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -367,22 +367,20 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#include "gcode/control/M111.h"
-
 #if ENABLED(HOST_KEEPALIVE_FEATURE)
   #include "gcode/host/M113.h"
 #endif
 
 #if ENABLED(BARICUDA)
   #if HAS_HEATER_1
     #include "gcode/feature/baricuda/M126.h"
     #include "gcode/feature/baricuda/M127.h"
   #endif
   #if HAS_HEATER_2

commit a831977deeac481c425ff617738a241c61078f63
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 16 22:34:40 2017 -0500

    Move M110 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index fb647284cf..9db7d77c90 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -367,22 +367,20 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#include "gcode/host/M110.h"
-
 #include "gcode/control/M111.h"
 
 #if ENABLED(HOST_KEEPALIVE_FEATURE)
   #include "gcode/host/M113.h"
 #endif
 
 #if ENABLED(BARICUDA)
   #if HAS_HEATER_1
     #include "gcode/feature/baricuda/M126.h"
     #include "gcode/feature/baricuda/M127.h"

commit 7479ff98b7e3c95b4a90176fe62397f77e1a9552
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 16 22:13:32 2017 -0500

    Move M140, M190 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index ede4653aed..fb647284cf 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -367,45 +367,39 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#if HAS_TEMP_BED
-  #include "gcode/temperature/M190.h"
-#endif
-
 #include "gcode/host/M110.h"
 
 #include "gcode/control/M111.h"
 
 #if ENABLED(HOST_KEEPALIVE_FEATURE)
   #include "gcode/host/M113.h"
 #endif
 
 #if ENABLED(BARICUDA)
   #if HAS_HEATER_1
     #include "gcode/feature/baricuda/M126.h"
     #include "gcode/feature/baricuda/M127.h"
   #endif
   #if HAS_HEATER_2
     #include "gcode/feature/baricuda/M128.h"
     #include "gcode/feature/baricuda/M129.h"
   #endif
 #endif
 
-#include "gcode/temperature/M140.h"
-
 #if ENABLED(ULTIPANEL)
   #include "gcode/lcd/M145.h"
 #endif
 
 #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
   #include "gcode/units/M149.h"
 #endif
 
 #if HAS_POWER_SWITCH
   #include "gcode/control/M80.h"

commit 5b3e49babdcf8f90c7f6d2ed1bc4e61d11db9d75
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 16 13:24:32 2017 -0500

    Move M108, M112, M410 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index bf32f7bc82..ede4653aed 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -367,26 +367,20 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#if DISABLED(EMERGENCY_PARSER)
-  #include "gcode/control/M108.h"
-  #include "gcode/control/M112.h"
-  #include "gcode/control/M410.h"
-#endif
-
 #if HAS_TEMP_BED
   #include "gcode/temperature/M190.h"
 #endif
 
 #include "gcode/host/M110.h"
 
 #include "gcode/control/M111.h"
 
 #if ENABLED(HOST_KEEPALIVE_FEATURE)
   #include "gcode/host/M113.h"

commit df0432c7c8abee61e1bc8956cbf8adb8e35c846a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 16 13:05:01 2017 -0500

    Move M155 to cpp, auto-report to Temperature

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index e9f740305c..bf32f7bc82 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -367,37 +367,20 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND || HAS_TEMP_BED)
-
-  static uint8_t auto_report_temp_interval;
-  static millis_t next_temp_report_ms;
-
-  inline void auto_report_temperatures() {
-    if (auto_report_temp_interval && ELAPSED(millis(), next_temp_report_ms)) {
-      next_temp_report_ms = millis() + 1000UL * auto_report_temp_interval;
-      thermalManager.print_heaterstates();
-      SERIAL_EOL();
-    }
-  }
-
-  #include "gcode/temperature/M155.h"
-
-#endif // AUTO_REPORT_TEMPERATURES && (HAS_TEMP_HOTEND || HAS_TEMP_BED)
-
 #if DISABLED(EMERGENCY_PARSER)
   #include "gcode/control/M108.h"
   #include "gcode/control/M112.h"
   #include "gcode/control/M410.h"
 #endif
 
 #if HAS_TEMP_BED
   #include "gcode/temperature/M190.h"
 #endif
 
@@ -895,21 +878,21 @@ void idle(
     Max7219_idle_tasks();
   #endif  // MAX7219_DEBUG
 
   lcd_update();
 
   #if ENABLED(HOST_KEEPALIVE_FEATURE)
     gcode.host_keepalive();
   #endif
 
   #if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND || HAS_TEMP_BED)
-    auto_report_temperatures();
+    thermalManager.auto_report_temperatures();
   #endif
 
   manage_inactivity(
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
       no_stepper_sleep
     #endif
   );
 
   thermalManager.manage_heater();
 

commit df031ab100e666f3c70d358deefac0f87925e571
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 16 13:14:44 2017 -0500

    Move M106_M107 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 3459f36c00..e9f740305c 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -384,25 +384,20 @@ bool pin_is_protected(const int8_t pin) {
       next_temp_report_ms = millis() + 1000UL * auto_report_temp_interval;
       thermalManager.print_heaterstates();
       SERIAL_EOL();
     }
   }
 
   #include "gcode/temperature/M155.h"
 
 #endif // AUTO_REPORT_TEMPERATURES && (HAS_TEMP_HOTEND || HAS_TEMP_BED)
 
-#if FAN_COUNT > 0
-  #include "gcode/temperature/M106.h"
-  #include "gcode/temperature/M107.h"
-#endif
-
 #if DISABLED(EMERGENCY_PARSER)
   #include "gcode/control/M108.h"
   #include "gcode/control/M112.h"
   #include "gcode/control/M410.h"
 #endif
 
 #if HAS_TEMP_BED
   #include "gcode/temperature/M190.h"
 #endif
 

commit 99c4b9050a4fb650dc7cbd0c841728a6a0abf912
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 16 12:25:27 2017 -0500

    Move M105 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index f55673646a..3459f36c00 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -367,22 +367,20 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#include "gcode/temperature/M105.h"
-
 #if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND || HAS_TEMP_BED)
 
   static uint8_t auto_report_temp_interval;
   static millis_t next_temp_report_ms;
 
   inline void auto_report_temperatures() {
     if (auto_report_temp_interval && ELAPSED(millis(), next_temp_report_ms)) {
       next_temp_report_ms = millis() + 1000UL * auto_report_temp_interval;
       thermalManager.print_heaterstates();
       SERIAL_EOL();

commit a41130f8548b478d202e6bee95f1e4561740c2ea
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 16 05:09:34 2017 -0500

    Temp stat LEDs

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index f96ef14d80..f55673646a 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -122,20 +122,24 @@
 #endif
 
 #if ENABLED(SENSORLESS_HOMING)
   #include "feature/tmc2130.h"
 #endif
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE) && ENABLED(PAUSE_PARK_NO_STEPPER_TIMEOUT)
   #include "feature/pause.h"
 #endif
 
+#if ENABLED(TEMP_STAT_LEDS)
+  #include "feature/leds/tempstat.h"
+#endif
+
 bool Running = true;
 
 /**
  * axis_homed
  *   Flags that each linear axis was homed.
  *   XYZ on cartesian, ABC on delta, ABZ on SCARA.
  *
  * axis_known_position
  *   Flags that the position is known in each linear axis. Set when homed.
  *   Cleared whenever a stepper powers off, potentially losing its position.
@@ -650,51 +654,20 @@ void quickstop_stepper() {
       uint8_t speed = (!lastMotorOn || ELAPSED(ms, lastMotorOn + (CONTROLLERFAN_SECS) * 1000UL)) ? 0 : CONTROLLERFAN_SPEED;
 
       // allows digital or PWM fan output to be used (see M42 handling)
       WRITE(CONTROLLER_FAN_PIN, speed);
       analogWrite(CONTROLLER_FAN_PIN, speed);
     }
   }
 
 #endif // USE_CONTROLLER_FAN
 
-#if ENABLED(TEMP_STAT_LEDS)
-
-  static bool red_led = false;
-  static millis_t next_status_led_update_ms = 0;
-
-  void handle_status_leds(void) {
-    if (ELAPSED(millis(), next_status_led_update_ms)) {
-      next_status_led_update_ms += 500; // Update every 0.5s
-      float max_temp = 0.0;
-      #if HAS_TEMP_BED
-        max_temp = MAX3(max_temp, thermalManager.degTargetBed(), thermalManager.degBed());
-      #endif
-      HOTEND_LOOP()
-        max_temp = MAX3(max_temp, thermalManager.degHotend(e), thermalManager.degTargetHotend(e));
-      const bool new_led = (max_temp > 55.0) ? true : (max_temp < 54.0) ? false : red_led;
-      if (new_led != red_led) {
-        red_led = new_led;
-        #if PIN_EXISTS(STAT_LED_RED)
-          WRITE(STAT_LED_RED_PIN, new_led ? HIGH : LOW);
-          #if PIN_EXISTS(STAT_LED_BLUE)
-            WRITE(STAT_LED_BLUE_PIN, new_led ? LOW : HIGH);
-          #endif
-        #else
-          WRITE(STAT_LED_BLUE_PIN, new_led ? HIGH : LOW);
-        #endif
-      }
-    }
-  }
-
-#endif
-
 #if ENABLED(FILAMENT_RUNOUT_SENSOR)
 
   void handle_filament_runout() {
     if (!filament_ran_out) {
       filament_ran_out = true;
       enqueue_and_echo_commands_P(PSTR(FILAMENT_RUNOUT_SCRIPT));
       stepper.synchronize();
     }
   }
 

commit 2c1eda9e00d37ae420df98617a0c5dd90144b32c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 16 04:27:45 2017 -0500

    Move M75-M78 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 4437f9f2bd..f96ef14d80 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -363,28 +363,20 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#include "gcode/stats/M75.h"
-#include "gcode/stats/M76.h"
-#include "gcode/stats/M77.h"
-
-#if ENABLED(PRINTCOUNTER)
-  #include "gcode/stats/M78.h"
-#endif
-
 #include "gcode/temperature/M105.h"
 
 #if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND || HAS_TEMP_BED)
 
   static uint8_t auto_report_temp_interval;
   static millis_t next_temp_report_ms;
 
   inline void auto_report_temperatures() {
     if (auto_report_temp_interval && ELAPSED(millis(), next_temp_report_ms)) {
       next_temp_report_ms = millis() + 1000UL * auto_report_temp_interval;

commit fc52fc72ac4ff1b2a66a0189a45745f36c2bf23e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 16 04:13:55 2017 -0500

    Move M48 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 5dc6866a1c..4437f9f2bd 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -363,24 +363,20 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#if ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)
-  #include "gcode/calibrate/M48.h"
-#endif
-
 #include "gcode/stats/M75.h"
 #include "gcode/stats/M76.h"
 #include "gcode/stats/M77.h"
 
 #if ENABLED(PRINTCOUNTER)
   #include "gcode/stats/M78.h"
 #endif
 
 #include "gcode/temperature/M105.h"
 

commit be8d9134842943ab98c4dbc10f9df421549ecb0b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 16 04:06:28 2017 -0500

    Move M43 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 34a7f9ce12..5dc6866a1c 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -363,24 +363,20 @@ void suicide() {
 /**
  * Sensitive pin test for M42, M226
  */
 bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#if ENABLED(PINS_DEBUGGING)
-  #include "gcode/config/M43.h"
-#endif
-
 #if ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)
   #include "gcode/calibrate/M48.h"
 #endif
 
 #include "gcode/stats/M75.h"
 #include "gcode/stats/M76.h"
 #include "gcode/stats/M77.h"
 
 #if ENABLED(PRINTCOUNTER)
   #include "gcode/stats/M78.h"

commit 10fab24e508147a2e6921f1e2372eca68f8c8e8d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 16 03:42:05 2017 -0500

    Move M42 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 1d25ee8f06..34a7f9ce12 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -356,29 +356,27 @@ void suicide() {
 
 #endif
 
 /**************************************************
  ***************** GCode Handlers *****************
  **************************************************/
 
 /**
  * Sensitive pin test for M42, M226
  */
-static bool pin_is_protected(const int8_t pin) {
+bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 
-#include "gcode/control/M42.h"
-
 #if ENABLED(PINS_DEBUGGING)
   #include "gcode/config/M43.h"
 #endif
 
 #if ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)
   #include "gcode/calibrate/M48.h"
 #endif
 
 #include "gcode/stats/M75.h"
 #include "gcode/stats/M76.h"

commit 69b664b6fe4db25ffe45b1b872373bd64c1ff0c9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 16 03:32:16 2017 -0500

    Move M31 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 65cafbcc30..1d25ee8f06 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -353,22 +353,20 @@ void suicide() {
       }
     }
   #endif
 
 #endif
 
 /**************************************************
  ***************** GCode Handlers *****************
  **************************************************/
 
-#include "gcode/stats/M31.h"              // M31: Get the time since the start of SD Print (or last M109)
-
 /**
  * Sensitive pin test for M42, M226
  */
 static bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 

commit a442c34a1ad1a181238fddfd0a52a922de9a643c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 16 03:24:47 2017 -0500

    Move SD commands to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 493ca94153..65cafbcc30 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -353,47 +353,22 @@ void suicide() {
       }
     }
   #endif
 
 #endif
 
 /**************************************************
  ***************** GCode Handlers *****************
  **************************************************/
 
-#if ENABLED(SDSUPPORT)
-  #include "gcode/sdcard/M20.h"           // M20  - List SD card. (Requires SDSUPPORT)
-  #include "gcode/sdcard/M21.h"           // M21  - Init SD card. (Requires SDSUPPORT)
-  #include "gcode/sdcard/M22.h"           // M22  - Release SD card. (Requires SDSUPPORT)
-  #include "gcode/sdcard/M23.h"           // M23  - Select SD file: "M23 /path/file.gco". (Requires SDSUPPORT)
-  #include "gcode/sdcard/M24.h"           // M24  - Start/resume SD print. (Requires SDSUPPORT)
-  #include "gcode/sdcard/M25.h"           // M25  - Pause SD print. (Requires SDSUPPORT)
-  #include "gcode/sdcard/M26.h"           // M26  - Set SD position in bytes: "M26 S12345". (Requires SDSUPPORT)
-  #include "gcode/sdcard/M27.h"           // M27  - Report SD print status. (Requires SDSUPPORT)
-  #include "gcode/sdcard/M28.h"           // M28  - Start SD write: "M28 /path/file.gco". (Requires SDSUPPORT)
-  #include "gcode/sdcard/M29.h"           // M29  - Stop SD write. (Requires SDSUPPORT)
-  #include "gcode/sdcard/M30.h"           // M30  - Delete file from SD: "M30 /path/file.gco"
-#endif
-
 #include "gcode/stats/M31.h"              // M31: Get the time since the start of SD Print (or last M109)
 
-#if ENABLED(SDSUPPORT)
-  #include "gcode/sdcard/M32.h"
-  #if ENABLED(LONG_FILENAME_HOST_SUPPORT)
-    #include "gcode/sdcard/M33.h"
-  #endif
-  #if ENABLED(SDCARD_SORT_ALPHA) && ENABLED(SDSORT_GCODE)
-    #include "gcode/sdcard/M34.h"
-  #endif
-  #include "gcode/sdcard/M928.h"
-#endif
-
 /**
  * Sensitive pin test for M42, M226
  */
 static bool pin_is_protected(const int8_t pin) {
   static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
   for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
     if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
   return false;
 }
 

commit be0e4a4ad066d20ffb4ede4eb468b43f4a784c62
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 16 02:13:07 2017 -0500

    Consolidate pause, apply to M125, M600, M24

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 3beaecf891..493ca94153 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -118,20 +118,23 @@
 #endif
 
 #if HAS_LEVELING
   #include "feature/bedlevel/bedlevel.h"
 #endif
 
 #if ENABLED(SENSORLESS_HOMING)
   #include "feature/tmc2130.h"
 #endif
 
+#if ENABLED(ADVANCED_PAUSE_FEATURE) && ENABLED(PAUSE_PARK_NO_STEPPER_TIMEOUT)
+  #include "feature/pause.h"
+#endif
 
 bool Running = true;
 
 /**
  * axis_homed
  *   Flags that each linear axis was homed.
  *   XYZ on cartesian, ABC on delta, ABZ on SCARA.
  *
  * axis_known_position
  *   Flags that the position is known in each linear axis. Set when homed.
@@ -350,25 +353,20 @@ void suicide() {
       }
     }
   #endif
 
 #endif
 
 /**************************************************
  ***************** GCode Handlers *****************
  **************************************************/
 
-#if ENABLED(ADVANCED_PAUSE_FEATURE)
-  // For M125, M600, M24
-  #include "gcode/feature/pause/common.h"
-#endif
-
 #if ENABLED(SDSUPPORT)
   #include "gcode/sdcard/M20.h"           // M20  - List SD card. (Requires SDSUPPORT)
   #include "gcode/sdcard/M21.h"           // M21  - Init SD card. (Requires SDSUPPORT)
   #include "gcode/sdcard/M22.h"           // M22  - Release SD card. (Requires SDSUPPORT)
   #include "gcode/sdcard/M23.h"           // M23  - Select SD file: "M23 /path/file.gco". (Requires SDSUPPORT)
   #include "gcode/sdcard/M24.h"           // M24  - Start/resume SD print. (Requires SDSUPPORT)
   #include "gcode/sdcard/M25.h"           // M25  - Pause SD print. (Requires SDSUPPORT)
   #include "gcode/sdcard/M26.h"           // M26  - Set SD position in bytes: "M26 S12345". (Requires SDSUPPORT)
   #include "gcode/sdcard/M27.h"           // M27  - Report SD print status. (Requires SDSUPPORT)
   #include "gcode/sdcard/M28.h"           // M28  - Start SD write: "M28 /path/file.gco". (Requires SDSUPPORT)
@@ -501,24 +499,20 @@ static bool pin_is_protected(const int8_t pin) {
 #include "gcode/host/M114.h"
 #include "gcode/host/M115.h"
 
 #include "gcode/lcd/M117.h"
 
 #include "gcode/host/M118.h"
 #include "gcode/host/M119.h"
 
 #include "gcode/control/M120_M121.h"
 
-#if ENABLED(PARK_HEAD_ON_PAUSE)
-  #include "gcode/feature/pause/M125.h"
-#endif
-
 #if HAS_COLOR_LEDS
   #include "gcode/feature/leds/M150.h"
 #endif
 
 #include "gcode/config/M201.h"
 
 #if 0 // Not used for Sprinter/grbl gen6
   #include "gcode/config/M202.h"
 #endif
 
@@ -605,24 +599,20 @@ void quickstop_stepper() {
 #include "gcode/eeprom/M501.h"
 #include "gcode/eeprom/M502.h"
 #if DISABLED(DISABLE_M503)
   #include "gcode/eeprom/M503.h"
 #endif
 
 #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
   #include "gcode/config/M540.h"
 #endif
 
-#if ENABLED(ADVANCED_PAUSE_FEATURE)
-  #include "gcode/feature/pause/M600.h"
-#endif
-
 #if ENABLED(MK2_MULTIPLEXER)
   #include "gcode/feature/snmm/M702.h"
 #endif
 
 #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
   #include "gcode/control/M605.h"
 #endif
 
 #if ENABLED(LIN_ADVANCE)
   #include "gcode/feature/advance/M900.h"

commit adca4a9b791d9100261b3c3f73efb4cd2dd4a0b8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 16 01:14:21 2017 -0500

    Move M17 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 2493e3fdff..3beaecf891 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -350,22 +350,20 @@ void suicide() {
       }
     }
   #endif
 
 #endif
 
 /**************************************************
  ***************** GCode Handlers *****************
  **************************************************/
 
-#include "gcode/control/M17.h"
-
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   // For M125, M600, M24
   #include "gcode/feature/pause/common.h"
 #endif
 
 #if ENABLED(SDSUPPORT)
   #include "gcode/sdcard/M20.h"           // M20  - List SD card. (Requires SDSUPPORT)
   #include "gcode/sdcard/M21.h"           // M21  - Init SD card. (Requires SDSUPPORT)
   #include "gcode/sdcard/M22.h"           // M22  - Release SD card. (Requires SDSUPPORT)
   #include "gcode/sdcard/M23.h"           // M23  - Select SD file: "M23 /path/file.gco". (Requires SDSUPPORT)

commit 33e00b6cd60248d0399e63aa637eaca0b8f3e112
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 16 01:07:00 2017 -0500

    Move M3-M5 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 6a30cd6d51..2493e3fdff 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -350,24 +350,20 @@ void suicide() {
       }
     }
   #endif
 
 #endif
 
 /**************************************************
  ***************** GCode Handlers *****************
  **************************************************/
 
-#if ENABLED(SPINDLE_LASER_ENABLE)
-  #include "gcode/control/M3-M5.h"
-#endif
-
 #include "gcode/control/M17.h"
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   // For M125, M600, M24
   #include "gcode/feature/pause/common.h"
 #endif
 
 #if ENABLED(SDSUPPORT)
   #include "gcode/sdcard/M20.h"           // M20  - List SD card. (Requires SDSUPPORT)
   #include "gcode/sdcard/M21.h"           // M21  - Init SD card. (Requires SDSUPPORT)

commit 04583d46af0246e12bf29609bd676b40b6096662
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 16 01:00:31 2017 -0500

    Move M0_M1 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 3e2ea77147..6a30cd6d51 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -350,24 +350,20 @@ void suicide() {
       }
     }
   #endif
 
 #endif
 
 /**************************************************
  ***************** GCode Handlers *****************
  **************************************************/
 
-#if HAS_RESUME_CONTINUE
-  #include "gcode/lcd/M0_M1.h"
-#endif
-
 #if ENABLED(SPINDLE_LASER_ENABLE)
   #include "gcode/control/M3-M5.h"
 #endif
 
 #include "gcode/control/M17.h"
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   // For M125, M600, M24
   #include "gcode/feature/pause/common.h"
 #endif

commit 04376975ce3e0ef677890708ddf18e0e5f97b27e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 16 00:37:35 2017 -0500

    Move G92 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index d5fe37c05c..3e2ea77147 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -350,22 +350,20 @@ void suicide() {
       }
     }
   #endif
 
 #endif
 
 /**************************************************
  ***************** GCode Handlers *****************
  **************************************************/
 
-#include "gcode/geometry/G92.h"
-
 #if HAS_RESUME_CONTINUE
   #include "gcode/lcd/M0_M1.h"
 #endif
 
 #if ENABLED(SPINDLE_LASER_ENABLE)
   #include "gcode/control/M3-M5.h"
 #endif
 
 #include "gcode/control/M17.h"
 

commit 931aa79d855ea20fff61fb2213782e11d487cd53
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 16 00:04:21 2017 -0500

    Move G42 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 812f14b62a..d5fe37c05c 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -350,24 +350,20 @@ void suicide() {
       }
     }
   #endif
 
 #endif
 
 /**************************************************
  ***************** GCode Handlers *****************
  **************************************************/
 
-#if HAS_MESH
-  #include "gcode/probe/G42.h"
-#endif
-
 #include "gcode/geometry/G92.h"
 
 #if HAS_RESUME_CONTINUE
   #include "gcode/lcd/M0_M1.h"
 #endif
 
 #if ENABLED(SPINDLE_LASER_ENABLE)
   #include "gcode/control/M3-M5.h"
 #endif
 

commit 84ddae56a8202ba0a9484e914d75e738db754550
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Sep 15 23:44:29 2017 -0500

    Move G38 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index a249f60a45..812f14b62a 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -350,24 +350,20 @@ void suicide() {
       }
     }
   #endif
 
 #endif
 
 /**************************************************
  ***************** GCode Handlers *****************
  **************************************************/
 
-#if ENABLED(G38_PROBE_TARGET)
-  #include "gcode/probe/G38.h"
-#endif
-
 #if HAS_MESH
   #include "gcode/probe/G42.h"
 #endif
 
 #include "gcode/geometry/G92.h"
 
 #if HAS_RESUME_CONTINUE
   #include "gcode/lcd/M0_M1.h"
 #endif
 

commit b8adae07859ffc204908624e0468c50cdb8af7fe
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Sep 15 23:31:06 2017 -0500

    Move G31_G32 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 195a8700c5..a249f60a45 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -350,24 +350,20 @@ void suicide() {
       }
     }
   #endif
 
 #endif
 
 /**************************************************
  ***************** GCode Handlers *****************
  **************************************************/
 
-#if ENABLED(Z_PROBE_SLED)
-  #include "gcode/probe/G31_G32.h"
-#endif
-
 #if ENABLED(G38_PROBE_TARGET)
   #include "gcode/probe/G38.h"
 #endif
 
 #if HAS_MESH
   #include "gcode/probe/G42.h"
 #endif
 
 #include "gcode/geometry/G92.h"
 

commit 9db5d21837c1b867626d62272f959c9d764c9f48
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Sep 15 23:27:30 2017 -0500

    Move G30 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index e2fded4ad5..195a8700c5 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -350,25 +350,22 @@ void suicide() {
       }
     }
   #endif
 
 #endif
 
 /**************************************************
  ***************** GCode Handlers *****************
  **************************************************/
 
-#if HAS_BED_PROBE
-  #include "gcode/probe/G30.h"
-  #if ENABLED(Z_PROBE_SLED)
-    #include "gcode/probe/G31_G32.h"
-  #endif
+#if ENABLED(Z_PROBE_SLED)
+  #include "gcode/probe/G31_G32.h"
 #endif
 
 #if ENABLED(G38_PROBE_TARGET)
   #include "gcode/probe/G38.h"
 #endif
 
 #if HAS_MESH
   #include "gcode/probe/G42.h"
 #endif
 

commit 13136376ee6e39c4fdc393b32b71dfcf61807faf
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Sep 15 23:22:58 2017 -0500

    Move G27 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 9c071c0a57..e2fded4ad5 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -350,24 +350,20 @@ void suicide() {
       }
     }
   #endif
 
 #endif
 
 /**************************************************
  ***************** GCode Handlers *****************
  **************************************************/
 
-#if ENABLED(NOZZLE_PARK_FEATURE)
-  #include "gcode/feature/pause/G27.h"
-#endif
-
 #if HAS_BED_PROBE
   #include "gcode/probe/G30.h"
   #if ENABLED(Z_PROBE_SLED)
     #include "gcode/probe/G31_G32.h"
   #endif
 #endif
 
 #if ENABLED(G38_PROBE_TARGET)
   #include "gcode/probe/G38.h"
 #endif

commit a1ee1628e58cb53d945bc32e8ed5c68f3b1964ce
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Sep 15 23:18:05 2017 -0500

    Move G20_G21 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index f83935698f..9c071c0a57 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -350,24 +350,20 @@ void suicide() {
       }
     }
   #endif
 
 #endif
 
 /**************************************************
  ***************** GCode Handlers *****************
  **************************************************/
 
-#if ENABLED(INCH_MODE_SUPPORT)
-  #include "gcode/units/G20_G21.h"
-#endif
-
 #if ENABLED(NOZZLE_PARK_FEATURE)
   #include "gcode/feature/pause/G27.h"
 #endif
 
 #if HAS_BED_PROBE
   #include "gcode/probe/G30.h"
   #if ENABLED(Z_PROBE_SLED)
     #include "gcode/probe/G31_G32.h"
   #endif
 #endif

commit 9b4aa5ea8bb0baf78a3a2959e4f603fe6e9f14e1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Sep 15 23:08:48 2017 -0500

    Move G17-G19 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 0de54efa78..f83935698f 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -208,24 +208,20 @@ static millis_t stepper_inactive_time = (DEFAULT_STEPPER_DEACTIVE_TIME) * 1000UL
 #if ENABLED(PID_EXTRUSION_SCALING)
   int lpq_len = 20;
 #endif
 
 #if ENABLED(I2C_POSITION_ENCODERS)
   I2CPositionEncodersMgr I2CPEM;
   uint8_t blockBufferIndexRef = 0;
   millis_t lastUpdateMillis;
 #endif
 
-#if ENABLED(CNC_WORKSPACE_PLANES)
-  static WorkspacePlane workspace_plane = PLANE_XY;
-#endif
-
 /**
  * ***************************************************************************
  * ******************************** FUNCTIONS ********************************
  * ***************************************************************************
  */
 
 #if ENABLED(DIGIPOT_I2C)
   extern void digipot_i2c_set_current(uint8_t channel, float current);
   extern void digipot_i2c_init();
 #endif
@@ -354,24 +350,20 @@ void suicide() {
       }
     }
   #endif
 
 #endif
 
 /**************************************************
  ***************** GCode Handlers *****************
  **************************************************/
 
-#if ENABLED(CNC_WORKSPACE_PLANES)
-  #include "gcode/geometry/G17-G19.h"
-#endif
-
 #if ENABLED(INCH_MODE_SUPPORT)
   #include "gcode/units/G20_G21.h"
 #endif
 
 #if ENABLED(NOZZLE_PARK_FEATURE)
   #include "gcode/feature/pause/G27.h"
 #endif
 
 #if HAS_BED_PROBE
   #include "gcode/probe/G30.h"

commit 94d9def81c50ef9b6686d109334ab976ab7e6c40
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Sep 15 22:13:05 2017 -0500

    Move G12 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index a5196ad15c..0de54efa78 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -354,24 +354,20 @@ void suicide() {
       }
     }
   #endif
 
 #endif
 
 /**************************************************
  ***************** GCode Handlers *****************
  **************************************************/
 
-#if ENABLED(NOZZLE_CLEAN_FEATURE)
-  #include "gcode/feature/clean/G12.h"
-#endif
-
 #if ENABLED(CNC_WORKSPACE_PLANES)
   #include "gcode/geometry/G17-G19.h"
 #endif
 
 #if ENABLED(INCH_MODE_SUPPORT)
   #include "gcode/units/G20_G21.h"
 #endif
 
 #if ENABLED(NOZZLE_PARK_FEATURE)
   #include "gcode/feature/pause/G27.h"

commit 56f4a4353535c95d7010a9a40733a590462a1fd1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Sep 15 21:28:54 2017 -0500

    Move G5 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 6e8f1f117a..a5196ad15c 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -218,24 +218,20 @@ static millis_t stepper_inactive_time = (DEFAULT_STEPPER_DEACTIVE_TIME) * 1000UL
 #if ENABLED(CNC_WORKSPACE_PLANES)
   static WorkspacePlane workspace_plane = PLANE_XY;
 #endif
 
 /**
  * ***************************************************************************
  * ******************************** FUNCTIONS ********************************
  * ***************************************************************************
  */
 
-#if ENABLED(BEZIER_CURVE_SUPPORT)
-  void plan_cubic_move(const float offset[4]);
-#endif
-
 #if ENABLED(DIGIPOT_I2C)
   extern void digipot_i2c_set_current(uint8_t channel, float current);
   extern void digipot_i2c_init();
 #endif
 
 void setup_killpin() {
   #if HAS_KILL
     SET_INPUT_PULLUP(KILL_PIN);
   #endif
 }
@@ -358,24 +354,20 @@ void suicide() {
       }
     }
   #endif
 
 #endif
 
 /**************************************************
  ***************** GCode Handlers *****************
  **************************************************/
 
-#if ENABLED(BEZIER_CURVE_SUPPORT)
-  #include "gcode/motion/G5.h"
-#endif
-
 #if ENABLED(NOZZLE_CLEAN_FEATURE)
   #include "gcode/feature/clean/G12.h"
 #endif
 
 #if ENABLED(CNC_WORKSPACE_PLANES)
   #include "gcode/geometry/G17-G19.h"
 #endif
 
 #if ENABLED(INCH_MODE_SUPPORT)
   #include "gcode/units/G20_G21.h"

commit 760f29a88eeef220fee764065036433222fed7eb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Sep 15 21:17:34 2017 -0500

    Move G4 to cpp

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 1bd50e8bea..6e8f1f117a 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -358,22 +358,20 @@ void suicide() {
       }
     }
   #endif
 
 #endif
 
 /**************************************************
  ***************** GCode Handlers *****************
  **************************************************/
 
-#include "gcode/motion/G4.h"
-
 #if ENABLED(BEZIER_CURVE_SUPPORT)
   #include "gcode/motion/G5.h"
 #endif
 
 #if ENABLED(NOZZLE_CLEAN_FEATURE)
   #include "gcode/feature/clean/G12.h"
 #endif
 
 #if ENABLED(CNC_WORKSPACE_PLANES)
   #include "gcode/geometry/G17-G19.h"

commit 51f195e698e2cbdbb8f1a97213f0c9553e8fc470
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Sep 15 20:44:40 2017 -0500

    Move dwell to gcode

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 3cb9136314..1bd50e8bea 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -156,21 +156,20 @@ float filament_size[EXTRUDERS], volumetric_multiplier[EXTRUDERS];
 
 // For M109 and M190, this flag may be cleared (by M108) to exit the wait loop
 volatile bool wait_for_heatup = true;
 
 // For M0/M1, this flag may be cleared (by M108) to exit the wait-for-user loop
 #if HAS_RESUME_CONTINUE
   volatile bool wait_for_user = false;
 #endif
 
 // Inactivity shutdown
-millis_t previous_cmd_ms = 0;
 static millis_t max_inactive_time = 0;
 static millis_t stepper_inactive_time = (DEFAULT_STEPPER_DEACTIVE_TIME) * 1000UL;
 
 #if ENABLED(Z_DUAL_ENDSTOPS)
   float z_endstop_adj;
 #endif
 
 #if ENABLED(BARICUDA)
   uint8_t baricuda_valve_pressure = 0,
           baricuda_e_to_p_pressure = 0;
@@ -359,30 +358,20 @@ void suicide() {
       }
     }
   #endif
 
 #endif
 
 /**************************************************
  ***************** GCode Handlers *****************
  **************************************************/
 
-#if ENABLED(ARC_SUPPORT)
-  #include "gcode/motion/G2_G3.h"
-#endif
-
-void dwell(millis_t time) {
-  gcode.refresh_cmd_timeout();
-  time += previous_cmd_ms;
-  while (PENDING(millis(), time)) idle();
-}
-
 #include "gcode/motion/G4.h"
 
 #if ENABLED(BEZIER_CURVE_SUPPORT)
   #include "gcode/motion/G5.h"
 #endif
 
 #if ENABLED(NOZZLE_CLEAN_FEATURE)
   #include "gcode/feature/clean/G12.h"
 #endif
 
@@ -875,34 +864,34 @@ void manage_inactivity(bool ignore_stepper_queue/*=false*/) {
 
   #if ENABLED(FILAMENT_RUNOUT_SENSOR)
     if ((IS_SD_PRINTING || print_job_timer.isRunning()) && (READ(FIL_RUNOUT_PIN) == FIL_RUNOUT_INVERTING))
       handle_filament_runout();
   #endif
 
   if (commands_in_queue < BUFSIZE) get_available_commands();
 
   const millis_t ms = millis();
 
-  if (max_inactive_time && ELAPSED(ms, previous_cmd_ms + max_inactive_time)) {
+  if (max_inactive_time && ELAPSED(ms, gcode.previous_cmd_ms + max_inactive_time)) {
     SERIAL_ERROR_START();
     SERIAL_ECHOLNPAIR(MSG_KILL_INACTIVE_TIME, parser.command_ptr);
     kill(PSTR(MSG_KILLED));
   }
 
   // Prevent steppers timing-out in the middle of M600
   #if ENABLED(ADVANCED_PAUSE_FEATURE) && ENABLED(PAUSE_PARK_NO_STEPPER_TIMEOUT)
     #define MOVE_AWAY_TEST !move_away_flag
   #else
     #define MOVE_AWAY_TEST true
   #endif
 
-  if (MOVE_AWAY_TEST && stepper_inactive_time && ELAPSED(ms, previous_cmd_ms + stepper_inactive_time)
+  if (MOVE_AWAY_TEST && stepper_inactive_time && ELAPSED(ms, gcode.previous_cmd_ms + stepper_inactive_time)
       && !ignore_stepper_queue && !planner.blocks_queued()) {
     #if ENABLED(DISABLE_INACTIVE_X)
       disable_X();
     #endif
     #if ENABLED(DISABLE_INACTIVE_Y)
       disable_Y();
     #endif
     #if ENABLED(DISABLE_INACTIVE_Z)
       disable_Z();
     #endif
@@ -958,21 +947,21 @@ void manage_inactivity(bool ignore_stepper_queue/*=false*/) {
       else
         homeDebounceCount = 0;
     }
   #endif
 
   #if ENABLED(USE_CONTROLLER_FAN)
     controllerFan(); // Check if fan should be turned on to cool stepper drivers down
   #endif
 
   #if ENABLED(EXTRUDER_RUNOUT_PREVENT)
-    if (ELAPSED(ms, previous_cmd_ms + (EXTRUDER_RUNOUT_SECONDS) * 1000UL)
+    if (ELAPSED(ms, gcode.previous_cmd_ms + (EXTRUDER_RUNOUT_SECONDS) * 1000UL)
       && thermalManager.degHotend(active_extruder) > EXTRUDER_RUNOUT_MINTEMP) {
       #if ENABLED(SWITCHING_EXTRUDER)
         const bool oldstatus = E0_ENABLE_READ;
         enable_E0();
       #else // !SWITCHING_EXTRUDER
         bool oldstatus;
         switch (active_extruder) {
           default: oldstatus = E0_ENABLE_READ; enable_E0(); break;
           #if E_STEPPERS > 1
             case 1: oldstatus = E1_ENABLE_READ; enable_E1(); break;

commit 4f1eadf41f1e2d79f7c62c60a1ead6ae34b63be5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Sep 12 15:02:17 2017 -0500

    FILAMENT_WIDTH_SENSOR feature

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 51de309d3e..3cb9136314 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -179,29 +179,20 @@ static millis_t stepper_inactive_time = (DEFAULT_STEPPER_DEACTIVE_TIME) * 1000UL
 #if HAS_POWER_SWITCH
   bool powersupply_on =
     #if ENABLED(PS_DEFAULT_OFF)
       false
     #else
       true
     #endif
   ;
 #endif
 
-#if ENABLED(FILAMENT_WIDTH_SENSOR)
-  bool filament_sensor = false;                                 // M405 turns on filament sensor control. M406 turns it off.
-  float filament_width_nominal = DEFAULT_NOMINAL_FILAMENT_DIA,  // Nominal filament width. Change with M404.
-        filament_width_meas = DEFAULT_MEASURED_FILAMENT_DIA;    // Measured filament diameter
-  uint8_t meas_delay_cm = MEASUREMENT_DELAY_CM,                 // Distance delay setting
-          measurement_delay[MAX_MEASUREMENT_DELAY + 1];         // Ring buffer to delayed measurement. Store extruder factor after subtracting 100
-  int8_t filwidth_delay_index[2] = { 0, -1 };                   // Indexes into ring buffer
-#endif
-
 #if ENABLED(FILAMENT_RUNOUT_SENSOR)
   static bool filament_ran_out = false;
 #endif
 
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   AdvancedPauseMenuResponse advanced_pause_menu_response;
 #endif
 
 #if ENABLED(MIXING_EXTRUDER)
   float mixing_factor[MIXING_STEPPERS]; // Reciprocal of mix proportion. 0.0 = off, otherwise >= 1.0.
@@ -660,27 +651,20 @@ static bool pin_is_protected(const int8_t pin) {
 #if ENABLED(EXT_SOLENOID)
   #include "gcode/control/M380_M381.h"
 #endif
 
 #include "gcode/control/M400.h"
 
 #if HAS_BED_PROBE
   #include "gcode/probe/M401_M402.h"
 #endif
 
-#if ENABLED(FILAMENT_WIDTH_SENSOR)
-  #include "gcode/sensor/M404.h"
-  #include "gcode/sensor/M405.h"
-  #include "gcode/sensor/M406.h"
-  #include "gcode/sensor/M407.h"
-#endif
-
 void quickstop_stepper() {
   stepper.quick_stop();
   stepper.synchronize();
   set_current_from_steppers_for_axis(ALL_AXES);
   SYNC_PLAN_POSITION_KINEMATIC();
 }
 
 #if HAS_M206_COMMAND
   #include "gcode/geometry/M428.h"
 #endif

commit d5fe0fb02b40311f00c2355df25400f139eb34f4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 9 00:18:43 2017 -0500

    Consolidate PrintCounter

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index edcc9d4a50..51de309d3e 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -32,26 +32,26 @@
 
 #include "lcd/ultralcd.h"
 #include "module/motion.h"
 #include "module/planner.h"
 #include "module/stepper.h"
 #include "module/endstops.h"
 #include "module/probe.h"
 #include "module/temperature.h"
 #include "sd/cardreader.h"
 #include "module/configuration_store.h"
+#include "module/printcounter.h" // PrintCounter or Stopwatch
 #ifdef ARDUINO
   #include <pins_arduino.h>
 #endif
 #include <math.h>
 #include "libs/nozzle.h"
-#include "libs/duration_t.h"
 
 #include "gcode/gcode.h"
 #include "gcode/parser.h"
 #include "gcode/queue.h"
 
 #if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER)
   #include "libs/buzzer.h"
 #endif
 
 #if (ENABLED(SWITCHING_EXTRUDER) && !DONT_SWITCH) || ENABLED(SWITCHING_NOZZLE)
@@ -118,20 +118,21 @@
 #endif
 
 #if HAS_LEVELING
   #include "feature/bedlevel/bedlevel.h"
 #endif
 
 #if ENABLED(SENSORLESS_HOMING)
   #include "feature/tmc2130.h"
 #endif
 
+
 bool Running = true;
 
 /**
  * axis_homed
  *   Flags that each linear axis was homed.
  *   XYZ on cartesian, ABC on delta, ABZ on SCARA.
  *
  * axis_known_position
  *   Flags that the position is known in each linear axis. Set when homed.
  *   Cleared whenever a stepper powers off, potentially losing its position.
@@ -159,27 +160,20 @@ volatile bool wait_for_heatup = true;
 // For M0/M1, this flag may be cleared (by M108) to exit the wait-for-user loop
 #if HAS_RESUME_CONTINUE
   volatile bool wait_for_user = false;
 #endif
 
 // Inactivity shutdown
 millis_t previous_cmd_ms = 0;
 static millis_t max_inactive_time = 0;
 static millis_t stepper_inactive_time = (DEFAULT_STEPPER_DEACTIVE_TIME) * 1000UL;
 
-// Print Job Timer
-#if ENABLED(PRINTCOUNTER)
-  PrintCounter print_job_timer = PrintCounter();
-#else
-  Stopwatch print_job_timer = Stopwatch();
-#endif
-
 #if ENABLED(Z_DUAL_ENDSTOPS)
   float z_endstop_adj;
 #endif
 
 #if ENABLED(BARICUDA)
   uint8_t baricuda_valve_pressure = 0,
           baricuda_e_to_p_pressure = 0;
 #endif
 
 #if HAS_POWER_SWITCH

commit 551752eac73a6f60de45b6465e2f224b2b2dca24
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Sep 8 15:35:25 2017 -0500

    Consolidate "bedlevel" code

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index c9c5505857..edcc9d4a50 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -28,47 +28,39 @@
  *  - https://github.com/simen/grbl
  */
 
 #include "Marlin.h"
 
 #include "lcd/ultralcd.h"
 #include "module/motion.h"
 #include "module/planner.h"
 #include "module/stepper.h"
 #include "module/endstops.h"
+#include "module/probe.h"
 #include "module/temperature.h"
 #include "sd/cardreader.h"
 #include "module/configuration_store.h"
 #ifdef ARDUINO
   #include <pins_arduino.h>
 #endif
 #include <math.h>
 #include "libs/nozzle.h"
 #include "libs/duration_t.h"
 
 #include "gcode/gcode.h"
 #include "gcode/parser.h"
 #include "gcode/queue.h"
 
 #if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER)
   #include "libs/buzzer.h"
 #endif
 
-#if HAS_ABL
-  #include "libs/vector_3.h"
-  #if ENABLED(AUTO_BED_LEVELING_LINEAR)
-    #include "libs/least_squares_fit.h"
-  #endif
-#elif ENABLED(MESH_BED_LEVELING)
-  #include "feature/mbl/mesh_bed_leveling.h"
-#endif
-
 #if (ENABLED(SWITCHING_EXTRUDER) && !DONT_SWITCH) || ENABLED(SWITCHING_NOZZLE)
   #include "module/tool_change.h"
 #endif
 
 #if ENABLED(BEZIER_CURVE_SUPPORT)
   #include "module/planner_bezier.h"
 #endif
 
 #if ENABLED(MAX7219_DEBUG)
   #include "feature/Max7219_Debug_LEDs.h"
@@ -112,29 +104,28 @@
 
 #if ENABLED(EXPERIMENTAL_I2CBUS)
   TWIBus i2c;
 #endif
 
 #if ENABLED(G38_PROBE_TARGET)
   bool G38_move = false,
        G38_endstop_hit = false;
 #endif
 
-#if ENABLED(AUTO_BED_LEVELING_UBL)
-  #include "feature/ubl/ubl.h"
-  extern bool defer_return_to_status;
-  unified_bed_leveling ubl;
-  #define UBL_MESH_VALID !( ( ubl.z_values[0][0] == ubl.z_values[0][1] && ubl.z_values[0][1] == ubl.z_values[0][2] \
-                           && ubl.z_values[1][0] == ubl.z_values[1][1] && ubl.z_values[1][1] == ubl.z_values[1][2] \
-                           && ubl.z_values[2][0] == ubl.z_values[2][1] && ubl.z_values[2][1] == ubl.z_values[2][2] \
-                           && ubl.z_values[0][0] == 0 && ubl.z_values[1][0] == 0 && ubl.z_values[2][0] == 0 )  \
-                           || isnan(ubl.z_values[0][0]))
+#if ENABLED(DELTA)
+  #include "module/delta.h"
+#elif IS_SCARA
+  #include "module/scara.h"
+#endif
+
+#if HAS_LEVELING
+  #include "feature/bedlevel/bedlevel.h"
 #endif
 
 #if ENABLED(SENSORLESS_HOMING)
   #include "feature/tmc2130.h"
 #endif
 
 bool Running = true;
 
 /**
  * axis_homed
@@ -144,56 +135,23 @@ bool Running = true;
  * axis_known_position
  *   Flags that the position is known in each linear axis. Set when homed.
  *   Cleared whenever a stepper powers off, potentially losing its position.
  */
 bool axis_homed[XYZ] = { false }, axis_known_position[XYZ] = { false };
 
 #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
   TempUnit input_temp_units = TEMPUNIT_C;
 #endif
 
-/**
- * Feed rates are often configured with mm/m
- * but the planner and stepper like mm/s units.
- */
-static const float homing_feedrate_mm_s[] PROGMEM = {
-  #if ENABLED(DELTA)
-    MMM_TO_MMS(HOMING_FEEDRATE_Z), MMM_TO_MMS(HOMING_FEEDRATE_Z),
-  #else
-    MMM_TO_MMS(HOMING_FEEDRATE_XY), MMM_TO_MMS(HOMING_FEEDRATE_XY),
-  #endif
-  MMM_TO_MMS(HOMING_FEEDRATE_Z), 0
-};
-FORCE_INLINE float homing_feedrate(const AxisEnum a) { return pgm_read_float(&homing_feedrate_mm_s[a]); }
-
-static float saved_feedrate_mm_s;
-int16_t feedrate_percentage = 100, saved_feedrate_percentage;
-
 // Initialized by settings.load()
 float filament_size[EXTRUDERS], volumetric_multiplier[EXTRUDERS];
 
-#if HAS_WORKSPACE_OFFSET
-  #if HAS_POSITION_SHIFT
-    // The distance that XYZ has been offset by G92. Reset by G28.
-    float position_shift[XYZ] = { 0 };
-  #endif
-  #if HAS_HOME_OFFSET
-    // This offset is added to the configured home position.
-    // Set by M206, M428, or menu item. Saved to EEPROM.
-    float home_offset[XYZ] = { 0 };
-  #endif
-  #if HAS_HOME_OFFSET && HAS_POSITION_SHIFT
-    // The above two are combined to save on computes
-    float workspace_offset[XYZ] = { 0 };
-  #endif
-#endif
-
 #if FAN_COUNT > 0
   int16_t fanSpeeds[FAN_COUNT] = { 0 };
   #if ENABLED(PROBING_FANS_OFF)
     bool fans_paused = false;
     int16_t paused_fanSpeeds[FAN_COUNT] = { 0 };
   #endif
 #endif
 
 // For M109 and M190, this flag may be cleared (by M108) to exit the wait loop
 volatile bool wait_for_heatup = true;
@@ -208,2000 +166,184 @@ millis_t previous_cmd_ms = 0;
 static millis_t max_inactive_time = 0;
 static millis_t stepper_inactive_time = (DEFAULT_STEPPER_DEACTIVE_TIME) * 1000UL;
 
 // Print Job Timer
 #if ENABLED(PRINTCOUNTER)
   PrintCounter print_job_timer = PrintCounter();
 #else
   Stopwatch print_job_timer = Stopwatch();
 #endif
 
-#if HAS_BED_PROBE
-  float zprobe_zoffset; // Initialized by settings.load()
-#endif
-
-#if HAS_ABL
-  float xy_probe_feedrate_mm_s = MMM_TO_MMS(XY_PROBE_SPEED);
-  #define XY_PROBE_FEEDRATE_MM_S xy_probe_feedrate_mm_s
-#elif defined(XY_PROBE_SPEED)
-  #define XY_PROBE_FEEDRATE_MM_S MMM_TO_MMS(XY_PROBE_SPEED)
-#else
-  #define XY_PROBE_FEEDRATE_MM_S PLANNER_XY_FEEDRATE()
-#endif
-
-#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
-  #if ENABLED(DELTA)
-    #define ADJUST_DELTA(V) \
-      if (planner.abl_enabled) { \
-        const float zadj = bilinear_z_offset(V); \
-        delta[A_AXIS] += zadj; \
-        delta[B_AXIS] += zadj; \
-        delta[C_AXIS] += zadj; \
-      }
-  #else
-    #define ADJUST_DELTA(V) if (planner.abl_enabled) { delta[Z_AXIS] += bilinear_z_offset(V); }
-  #endif
-#elif IS_KINEMATIC
-  #define ADJUST_DELTA(V) NOOP
-#endif
-
 #if ENABLED(Z_DUAL_ENDSTOPS)
   float z_endstop_adj;
 #endif
 
-// Extruder offsets
-#if HOTENDS > 1
-  float hotend_offset[XYZ][HOTENDS]; // Initialized by settings.load()
-#endif
-
-#if HAS_Z_SERVO_ENDSTOP
-  const int z_servo_angle[2] = Z_SERVO_ANGLES;
-#endif
-
-#if ENABLED(BARICUDA)
-  uint8_t baricuda_valve_pressure = 0,
-          baricuda_e_to_p_pressure = 0;
-#endif
-
-#if HAS_POWER_SWITCH
-  bool powersupply_on =
-    #if ENABLED(PS_DEFAULT_OFF)
-      false
-    #else
-      true
-    #endif
-  ;
-#endif
-
-#if ENABLED(DELTA)
-
-  float delta[ABC],
-        endstop_adj[ABC] = { 0 };
-
-  // Initialized by settings.load()
-  float delta_radius,
-        delta_tower_angle_trim[2],
-        delta_tower[ABC][2],
-        delta_diagonal_rod,
-        delta_calibration_radius,
-        delta_diagonal_rod_2_tower[ABC],
-        delta_segments_per_second,
-        delta_clip_start_height = Z_MAX_POS;
-
-  float delta_safe_distance_from_top();
-
-#endif
-
-#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
-  int bilinear_grid_spacing[2], bilinear_start[2];
-  float bilinear_grid_factor[2],
-        z_values[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
-#endif
-
-#if IS_SCARA
-  // Float constants for SCARA calculations
-  const float L1 = SCARA_LINKAGE_1, L2 = SCARA_LINKAGE_2,
-              L1_2 = sq(float(L1)), L1_2_2 = 2.0 * L1_2,
-              L2_2 = sq(float(L2));
-
-  float delta_segments_per_second = SCARA_SEGMENTS_PER_SECOND,
-        delta[ABC];
-#endif
-
-float cartes[XYZ] = { 0 };
-
-#if ENABLED(FILAMENT_WIDTH_SENSOR)
-  bool filament_sensor = false;                                 // M405 turns on filament sensor control. M406 turns it off.
-  float filament_width_nominal = DEFAULT_NOMINAL_FILAMENT_DIA,  // Nominal filament width. Change with M404.
-        filament_width_meas = DEFAULT_MEASURED_FILAMENT_DIA;    // Measured filament diameter
-  uint8_t meas_delay_cm = MEASUREMENT_DELAY_CM,                 // Distance delay setting
-          measurement_delay[MAX_MEASUREMENT_DELAY + 1];         // Ring buffer to delayed measurement. Store extruder factor after subtracting 100
-  int8_t filwidth_delay_index[2] = { 0, -1 };                   // Indexes into ring buffer
-#endif
-
-#if ENABLED(FILAMENT_RUNOUT_SENSOR)
-  static bool filament_ran_out = false;
-#endif
-
-#if ENABLED(ADVANCED_PAUSE_FEATURE)
-  AdvancedPauseMenuResponse advanced_pause_menu_response;
-#endif
-
-#if ENABLED(MIXING_EXTRUDER)
-  float mixing_factor[MIXING_STEPPERS]; // Reciprocal of mix proportion. 0.0 = off, otherwise >= 1.0.
-  #if MIXING_VIRTUAL_TOOLS > 1
-    float mixing_virtual_tool_mix[MIXING_VIRTUAL_TOOLS][MIXING_STEPPERS];
-  #endif
-#endif
-
-#if HAS_SERVOS
-  HAL_SERVO_LIB servo[NUM_SERVOS];
-  #define MOVE_SERVO(I, P) servo[I].move(P)
-  #if HAS_Z_SERVO_ENDSTOP
-    #define DEPLOY_Z_SERVO() MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[0])
-    #define STOW_Z_SERVO() MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[1])
-  #endif
-#endif
-
-#ifdef CHDK
-  millis_t chdkHigh = 0;
-  bool chdkActive = false;
-#endif
-
-#if ENABLED(PID_EXTRUSION_SCALING)
-  int lpq_len = 20;
-#endif
-
-#if ENABLED(I2C_POSITION_ENCODERS)
-  I2CPositionEncodersMgr I2CPEM;
-  uint8_t blockBufferIndexRef = 0;
-  millis_t lastUpdateMillis;
-#endif
-
-#if ENABLED(CNC_WORKSPACE_PLANES)
-  static WorkspacePlane workspace_plane = PLANE_XY;
-#endif
-
-/**
- * ***************************************************************************
- * ******************************** FUNCTIONS ********************************
- * ***************************************************************************
- */
-
-void stop();
-
-void get_cartesian_from_steppers();
-void set_current_from_steppers_for_axis(const AxisEnum axis);
-
-#if ENABLED(BEZIER_CURVE_SUPPORT)
-  void plan_cubic_move(const float offset[4]);
-#endif
-
-void report_current_position();
-
-#if ENABLED(DIGIPOT_I2C)
-  extern void digipot_i2c_set_current(uint8_t channel, float current);
-  extern void digipot_i2c_init();
-#endif
-
-void setup_killpin() {
-  #if HAS_KILL
-    SET_INPUT_PULLUP(KILL_PIN);
-  #endif
-}
-
-#if ENABLED(FILAMENT_RUNOUT_SENSOR)
-
-  void setup_filrunoutpin() {
-    #if ENABLED(ENDSTOPPULLUP_FIL_RUNOUT)
-      SET_INPUT_PULLUP(FIL_RUNOUT_PIN);
-    #else
-      SET_INPUT(FIL_RUNOUT_PIN);
-    #endif
-  }
-
-#endif
-
-void setup_powerhold() {
-  #if HAS_SUICIDE
-    OUT_WRITE(SUICIDE_PIN, HIGH);
-  #endif
-  #if HAS_POWER_SWITCH
-    #if ENABLED(PS_DEFAULT_OFF)
-      OUT_WRITE(PS_ON_PIN, PS_ON_ASLEEP);
-    #else
-      OUT_WRITE(PS_ON_PIN, PS_ON_AWAKE);
-    #endif
-  #endif
-}
-
-void suicide() {
-  #if HAS_SUICIDE
-    OUT_WRITE(SUICIDE_PIN, LOW);
-  #endif
-}
-
-void servo_init() {
-  #if NUM_SERVOS >= 1 && HAS_SERVO_0
-    servo[0].attach(SERVO0_PIN);
-    servo[0].detach(); // Just set up the pin. We don't have a position yet. Don't move to a random position.
-  #endif
-  #if NUM_SERVOS >= 2 && HAS_SERVO_1
-    servo[1].attach(SERVO1_PIN);
-    servo[1].detach();
-  #endif
-  #if NUM_SERVOS >= 3 && HAS_SERVO_2
-    servo[2].attach(SERVO2_PIN);
-    servo[2].detach();
-  #endif
-  #if NUM_SERVOS >= 4 && HAS_SERVO_3
-    servo[3].attach(SERVO3_PIN);
-    servo[3].detach();
-  #endif
-
-  #if HAS_Z_SERVO_ENDSTOP
-    /**
-     * Set position of Z Servo Endstop
-     *
-     * The servo might be deployed and positioned too low to stow
-     * when starting up the machine or rebooting the board.
-     * There's no way to know where the nozzle is positioned until
-     * homing has been done - no homing with z-probe without init!
-     *
-     */
-    STOW_Z_SERVO();
-  #endif
-}
-
-/**
- * Stepper Reset (RigidBoard, et.al.)
- */
-#if HAS_STEPPER_RESET
-  void disableStepperDrivers() {
-    OUT_WRITE(STEPPER_RESET_PIN, LOW);  // drive it down to hold in reset motor driver chips
-  }
-  void enableStepperDrivers() { SET_INPUT(STEPPER_RESET_PIN); }  // set to input, which allows it to be pulled high by pullups
-#endif
-
-#if ENABLED(EXPERIMENTAL_I2CBUS) && I2C_SLAVE_ADDRESS > 0
-
-  void i2c_on_receive(int bytes) { // just echo all bytes received to serial
-    i2c.receive(bytes);
-  }
-
-  void i2c_on_request() {          // just send dummy data for now
-    i2c.reply("Hello World!\n");
-  }
-
-#endif
-
-#if HAS_WORKSPACE_OFFSET || ENABLED(DUAL_X_CARRIAGE)
-
-  /**
-   * Software endstops can be used to monitor the open end of
-   * an axis that has a hardware endstop on the other end. Or
-   * they can prevent axes from moving past endstops and grinding.
-   *
-   * To keep doing their job as the coordinate system changes,
-   * the software endstop positions must be refreshed to remain
-   * at the same positions relative to the machine.
-   */
-  void update_software_endstops(const AxisEnum axis) {
-    const float offs = 0.0
-      #if HAS_HOME_OFFSET
-        + home_offset[axis]
-      #endif
-      #if HAS_POSITION_SHIFT
-        + position_shift[axis]
-      #endif
-    ;
-
-    #if HAS_HOME_OFFSET && HAS_POSITION_SHIFT
-      workspace_offset[axis] = offs;
-    #endif
-
-    #if ENABLED(DUAL_X_CARRIAGE)
-      if (axis == X_AXIS) {
-
-        // In Dual X mode hotend_offset[X] is T1's home position
-        float dual_max_x = max(hotend_offset[X_AXIS][1], X2_MAX_POS);
-
-        if (active_extruder != 0) {
-          // T1 can move from X2_MIN_POS to X2_MAX_POS or X2 home position (whichever is larger)
-          soft_endstop_min[X_AXIS] = X2_MIN_POS + offs;
-          soft_endstop_max[X_AXIS] = dual_max_x + offs;
-        }
-        else if (dual_x_carriage_mode == DXC_DUPLICATION_MODE) {
-          // In Duplication Mode, T0 can move as far left as X_MIN_POS
-          // but not so far to the right that T1 would move past the end
-          soft_endstop_min[X_AXIS] = base_min_pos(X_AXIS) + offs;
-          soft_endstop_max[X_AXIS] = min(base_max_pos(X_AXIS), dual_max_x - duplicate_extruder_x_offset) + offs;
-        }
-        else {
-          // In other modes, T0 can move from X_MIN_POS to X_MAX_POS
-          soft_endstop_min[axis] = base_min_pos(axis) + offs;
-          soft_endstop_max[axis] = base_max_pos(axis) + offs;
-        }
-      }
-    #elif ENABLED(DELTA)
-      soft_endstop_min[axis] = base_min_pos(axis) + (axis == Z_AXIS ? 0 : offs);
-      soft_endstop_max[axis] = base_max_pos(axis) + offs;
-    #else
-      soft_endstop_min[axis] = base_min_pos(axis) + offs;
-      soft_endstop_max[axis] = base_max_pos(axis) + offs;
-    #endif
-
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        SERIAL_ECHOPAIR("For ", axis_codes[axis]);
-        #if HAS_HOME_OFFSET
-          SERIAL_ECHOPAIR(" axis:\n home_offset = ", home_offset[axis]);
-        #endif
-        #if HAS_POSITION_SHIFT
-          SERIAL_ECHOPAIR("\n position_shift = ", position_shift[axis]);
-        #endif
-        SERIAL_ECHOPAIR("\n soft_endstop_min = ", soft_endstop_min[axis]);
-        SERIAL_ECHOLNPAIR("\n soft_endstop_max = ", soft_endstop_max[axis]);
-      }
-    #endif
-
-    #if ENABLED(DELTA)
-      if (axis == Z_AXIS)
-        delta_clip_start_height = soft_endstop_max[axis] - delta_safe_distance_from_top();
-    #endif
-  }
-
-#endif // HAS_WORKSPACE_OFFSET || DUAL_X_CARRIAGE
-
-#if HAS_M206_COMMAND
-  /**
-   * Change the home offset for an axis, update the current
-   * position and the software endstops to retain the same
-   * relative distance to the new home.
-   *
-   * Since this changes the current_position, code should
-   * call sync_plan_position soon after this.
-   */
-  static void set_home_offset(const AxisEnum axis, const float v) {
-    current_position[axis] += v - home_offset[axis];
-    home_offset[axis] = v;
-    update_software_endstops(axis);
-  }
-#endif // HAS_M206_COMMAND
-
-/**
- * Set an axis' current position to its home position (after homing).
- *
- * For Core and Cartesian robots this applies one-to-one when an
- * individual axis has been homed.
- *
- * DELTA should wait until all homing is done before setting the XYZ
- * current_position to home, because homing is a single operation.
- * In the case where the axis positions are already known and previously
- * homed, DELTA could home to X or Y individually by moving either one
- * to the center. However, homing Z always homes XY and Z.
- *
- * SCARA should wait until all XY homing is done before setting the XY
- * current_position to home, because neither X nor Y is at home until
- * both are at home. Z can however be homed individually.
- *
- * Callers must sync the planner position after calling this!
- */
-static void set_axis_is_at_home(const AxisEnum axis) {
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) {
-      SERIAL_ECHOPAIR(">>> set_axis_is_at_home(", axis_codes[axis]);
-      SERIAL_CHAR(')');
-      SERIAL_EOL();
-    }
-  #endif
-
-  axis_known_position[axis] = axis_homed[axis] = true;
-
-  #if HAS_POSITION_SHIFT
-    position_shift[axis] = 0;
-    update_software_endstops(axis);
-  #endif
-
-  #if ENABLED(DUAL_X_CARRIAGE)
-    if (axis == X_AXIS && (active_extruder == 1 || dual_x_carriage_mode == DXC_DUPLICATION_MODE)) {
-      current_position[X_AXIS] = x_home_pos(active_extruder);
-      return;
-    }
-  #endif
-
-  #if ENABLED(MORGAN_SCARA)
-
-    /**
-     * Morgan SCARA homes XY at the same time
-     */
-    if (axis == X_AXIS || axis == Y_AXIS) {
-
-      float homeposition[XYZ];
-      LOOP_XYZ(i) homeposition[i] = LOGICAL_POSITION(base_home_pos((AxisEnum)i), i);
-
-      // SERIAL_ECHOPAIR("homeposition X:", homeposition[X_AXIS]);
-      // SERIAL_ECHOLNPAIR(" Y:", homeposition[Y_AXIS]);
-
-      /**
-       * Get Home position SCARA arm angles using inverse kinematics,
-       * and calculate homing offset using forward kinematics
-       */
-      inverse_kinematics(homeposition);
-      forward_kinematics_SCARA(delta[A_AXIS], delta[B_AXIS]);
-
-      // SERIAL_ECHOPAIR("Cartesian X:", cartes[X_AXIS]);
-      // SERIAL_ECHOLNPAIR(" Y:", cartes[Y_AXIS]);
-
-      current_position[axis] = LOGICAL_POSITION(cartes[axis], axis);
-
-      /**
-       * SCARA home positions are based on configuration since the actual
-       * limits are determined by the inverse kinematic transform.
-       */
-      soft_endstop_min[axis] = base_min_pos(axis); // + (cartes[axis] - base_home_pos(axis));
-      soft_endstop_max[axis] = base_max_pos(axis); // + (cartes[axis] - base_home_pos(axis));
-    }
-    else
-  #endif
-  {
-    current_position[axis] = LOGICAL_POSITION(base_home_pos(axis), axis);
-  }
-
-  /**
-   * Z Probe Z Homing? Account for the probe's Z offset.
-   */
-  #if HAS_BED_PROBE && Z_HOME_DIR < 0
-    if (axis == Z_AXIS) {
-      #if HOMING_Z_WITH_PROBE
-
-        current_position[Z_AXIS] -= zprobe_zoffset;
-
-        #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) {
-            SERIAL_ECHOLNPGM("*** Z HOMED WITH PROBE (Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN) ***");
-            SERIAL_ECHOLNPAIR("> zprobe_zoffset = ", zprobe_zoffset);
-          }
-        #endif
-
-      #elif ENABLED(DEBUG_LEVELING_FEATURE)
-
-        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("*** Z HOMED TO ENDSTOP (Z_MIN_PROBE_ENDSTOP) ***");
-
-      #endif
-    }
-  #endif
-
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) {
-      #if HAS_HOME_OFFSET
-        SERIAL_ECHOPAIR("> home_offset[", axis_codes[axis]);
-        SERIAL_ECHOLNPAIR("] = ", home_offset[axis]);
-      #endif
-      DEBUG_POS("", current_position);
-      SERIAL_ECHOPAIR("<<< set_axis_is_at_home(", axis_codes[axis]);
-      SERIAL_CHAR(')');
-      SERIAL_EOL();
-    }
-  #endif
-
-  #if ENABLED(I2C_POSITION_ENCODERS)
-    I2CPEM.homed(axis);
-  #endif
-}
-
-/**
- * Some planner shorthand inline functions
- */
-inline float get_homing_bump_feedrate(const AxisEnum axis) {
-  static const uint8_t homing_bump_divisor[] PROGMEM = HOMING_BUMP_DIVISOR;
-  uint8_t hbd = pgm_read_byte(&homing_bump_divisor[axis]);
-  if (hbd < 1) {
-    hbd = 10;
-    SERIAL_ECHO_START();
-    SERIAL_ECHOLNPGM("Warning: Homing Bump Divisor < 1");
-  }
-  return homing_feedrate(axis) / hbd;
-}
-
-/**
- *  Plan a move to (X, Y, Z) and set the current_position
- *  The final current_position may not be the one that was requested
- */
-void do_blocking_move_to(const float &lx, const float &ly, const float &lz, const float &fr_mm_s/*=0.0*/) {
-  const float old_feedrate_mm_s = feedrate_mm_s;
-
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) print_xyz(PSTR(">>> do_blocking_move_to"), NULL, lx, ly, lz);
-  #endif
-
-  #if ENABLED(DELTA)
-
-    if (!position_is_reachable_xy(lx, ly)) return;
-
-    feedrate_mm_s = fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
-
-    set_destination_to_current();          // sync destination at the start
-
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) DEBUG_POS("set_destination_to_current", destination);
-    #endif
-
-    // when in the danger zone
-    if (current_position[Z_AXIS] > delta_clip_start_height) {
-      if (lz > delta_clip_start_height) {   // staying in the danger zone
-        destination[X_AXIS] = lx;           // move directly (uninterpolated)
-        destination[Y_AXIS] = ly;
-        destination[Z_AXIS] = lz;
-        prepare_uninterpolated_move_to_destination(); // set_current_to_destination
-        #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) DEBUG_POS("danger zone move", current_position);
-        #endif
-        return;
-      }
-      else {
-        destination[Z_AXIS] = delta_clip_start_height;
-        prepare_uninterpolated_move_to_destination(); // set_current_to_destination
-        #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) DEBUG_POS("zone border move", current_position);
-        #endif
-      }
-    }
-
-    if (lz > current_position[Z_AXIS]) {    // raising?
-      destination[Z_AXIS] = lz;
-      prepare_uninterpolated_move_to_destination();   // set_current_to_destination
-      #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) DEBUG_POS("z raise move", current_position);
-      #endif
-    }
-
-    destination[X_AXIS] = lx;
-    destination[Y_AXIS] = ly;
-    prepare_move_to_destination();         // set_current_to_destination
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) DEBUG_POS("xy move", current_position);
-    #endif
-
-    if (lz < current_position[Z_AXIS]) {    // lowering?
-      destination[Z_AXIS] = lz;
-      prepare_uninterpolated_move_to_destination();   // set_current_to_destination
-      #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) DEBUG_POS("z lower move", current_position);
-      #endif
-    }
-
-  #elif IS_SCARA
-
-    if (!position_is_reachable_xy(lx, ly)) return;
-
-    set_destination_to_current();
-
-    // If Z needs to raise, do it before moving XY
-    if (destination[Z_AXIS] < lz) {
-      destination[Z_AXIS] = lz;
-      prepare_uninterpolated_move_to_destination(fr_mm_s ? fr_mm_s : homing_feedrate(Z_AXIS));
-    }
-
-    destination[X_AXIS] = lx;
-    destination[Y_AXIS] = ly;
-    prepare_uninterpolated_move_to_destination(fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S);
-
-    // If Z needs to lower, do it after moving XY
-    if (destination[Z_AXIS] > lz) {
-      destination[Z_AXIS] = lz;
-      prepare_uninterpolated_move_to_destination(fr_mm_s ? fr_mm_s : homing_feedrate(Z_AXIS));
-    }
-
-  #else
-
-    // If Z needs to raise, do it before moving XY
-    if (current_position[Z_AXIS] < lz) {
-      feedrate_mm_s = fr_mm_s ? fr_mm_s : homing_feedrate(Z_AXIS);
-      current_position[Z_AXIS] = lz;
-      line_to_current_position();
-    }
-
-    feedrate_mm_s = fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
-    current_position[X_AXIS] = lx;
-    current_position[Y_AXIS] = ly;
-    line_to_current_position();
-
-    // If Z needs to lower, do it after moving XY
-    if (current_position[Z_AXIS] > lz) {
-      feedrate_mm_s = fr_mm_s ? fr_mm_s : homing_feedrate(Z_AXIS);
-      current_position[Z_AXIS] = lz;
-      line_to_current_position();
-    }
-
-  #endif
-
-  stepper.synchronize();
-
-  feedrate_mm_s = old_feedrate_mm_s;
-
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< do_blocking_move_to");
-  #endif
-}
-void do_blocking_move_to_x(const float &lx, const float &fr_mm_s/*=0.0*/) {
-  do_blocking_move_to(lx, current_position[Y_AXIS], current_position[Z_AXIS], fr_mm_s);
-}
-void do_blocking_move_to_z(const float &lz, const float &fr_mm_s/*=0.0*/) {
-  do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], lz, fr_mm_s);
-}
-void do_blocking_move_to_xy(const float &lx, const float &ly, const float &fr_mm_s/*=0.0*/) {
-  do_blocking_move_to(lx, ly, current_position[Z_AXIS], fr_mm_s);
-}
-
-//
-// Prepare to do endstop or probe moves
-// with custom feedrates.
-//
-//  - Save current feedrates
-//  - Reset the rate multiplier
-//  - Reset the command timeout
-//  - Enable the endstops (for endstop moves)
-//
-static void setup_for_endstop_or_probe_move() {
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) DEBUG_POS("setup_for_endstop_or_probe_move", current_position);
-  #endif
-  saved_feedrate_mm_s = feedrate_mm_s;
-  saved_feedrate_percentage = feedrate_percentage;
-  feedrate_percentage = 100;
-  gcode.refresh_cmd_timeout();
-}
-
-static void clean_up_after_endstop_or_probe_move() {
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) DEBUG_POS("clean_up_after_endstop_or_probe_move", current_position);
-  #endif
-  feedrate_mm_s = saved_feedrate_mm_s;
-  feedrate_percentage = saved_feedrate_percentage;
-  gcode.refresh_cmd_timeout();
-}
-
-#if HAS_BED_PROBE
-  /**
-   * Raise Z to a minimum height to make room for a probe to move
-   */
-  inline void do_probe_raise(const float z_raise) {
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        SERIAL_ECHOPAIR("do_probe_raise(", z_raise);
-        SERIAL_CHAR(')');
-        SERIAL_EOL();
-      }
-    #endif
-
-    float z_dest = z_raise;
-    if (zprobe_zoffset < 0) z_dest -= zprobe_zoffset;
-
-    if (z_dest > current_position[Z_AXIS])
-      do_blocking_move_to_z(z_dest);
-  }
-
-#endif // HAS_BED_PROBE
-
-#if HAS_PROBING_PROCEDURE || HOTENDS > 1 || ENABLED(Z_PROBE_ALLEN_KEY) || ENABLED(Z_PROBE_SLED) || ENABLED(NOZZLE_CLEAN_FEATURE) || ENABLED(NOZZLE_PARK_FEATURE) || ENABLED(DELTA_AUTO_CALIBRATION)
-
-  bool axis_unhomed_error(const bool x/*=true*/, const bool y/*=true*/, const bool z/*=true*/) {
-    #if ENABLED(HOME_AFTER_DEACTIVATE)
-      const bool xx = x && !axis_known_position[X_AXIS],
-                 yy = y && !axis_known_position[Y_AXIS],
-                 zz = z && !axis_known_position[Z_AXIS];
-    #else
-      const bool xx = x && !axis_homed[X_AXIS],
-                 yy = y && !axis_homed[Y_AXIS],
-                 zz = z && !axis_homed[Z_AXIS];
-    #endif
-    if (xx || yy || zz) {
-      SERIAL_ECHO_START();
-      SERIAL_ECHOPGM(MSG_HOME " ");
-      if (xx) SERIAL_ECHOPGM(MSG_X);
-      if (yy) SERIAL_ECHOPGM(MSG_Y);
-      if (zz) SERIAL_ECHOPGM(MSG_Z);
-      SERIAL_ECHOLNPGM(" " MSG_FIRST);
-
-      #if ENABLED(ULTRA_LCD)
-        lcd_status_printf_P(0, PSTR(MSG_HOME " %s%s%s " MSG_FIRST), xx ? MSG_X : "", yy ? MSG_Y : "", zz ? MSG_Z : "");
-      #endif
-      return true;
-    }
-    return false;
-  }
-
-#endif
-
-#if ENABLED(Z_PROBE_SLED)
-
-  #ifndef SLED_DOCKING_OFFSET
-    #define SLED_DOCKING_OFFSET 0
-  #endif
-
-  /**
-   * Method to dock/undock a sled designed by Charles Bell.
-   *
-   * stow[in]     If false, move to MAX_X and engage the solenoid
-   *              If true, move to MAX_X and release the solenoid
-   */
-  static void dock_sled(bool stow) {
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        SERIAL_ECHOPAIR("dock_sled(", stow);
-        SERIAL_CHAR(')');
-        SERIAL_EOL();
-      }
-    #endif
-
-    // Dock sled a bit closer to ensure proper capturing
-    do_blocking_move_to_x(X_MAX_POS + SLED_DOCKING_OFFSET - ((stow) ? 1 : 0));
-
-    #if HAS_SOLENOID_1 && DISABLED(EXT_SOLENOID)
-      WRITE(SOL1_PIN, !stow); // switch solenoid
-    #endif
-  }
-
-#elif ENABLED(Z_PROBE_ALLEN_KEY)
-
-  FORCE_INLINE void do_blocking_move_to(const float logical[XYZ], const float &fr_mm_s) {
-    do_blocking_move_to(logical[X_AXIS], logical[Y_AXIS], logical[Z_AXIS], fr_mm_s);
-  }
-
-  void run_deploy_moves_script() {
-    #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_Z)
-      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_X
-        #define Z_PROBE_ALLEN_KEY_DEPLOY_1_X current_position[X_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_Y
-        #define Z_PROBE_ALLEN_KEY_DEPLOY_1_Y current_position[Y_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_Z
-        #define Z_PROBE_ALLEN_KEY_DEPLOY_1_Z current_position[Z_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE
-        #define Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE 0.0
-      #endif
-      const float deploy_1[] = { Z_PROBE_ALLEN_KEY_DEPLOY_1_X, Z_PROBE_ALLEN_KEY_DEPLOY_1_Y, Z_PROBE_ALLEN_KEY_DEPLOY_1_Z };
-      do_blocking_move_to(deploy_1, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE));
-    #endif
-    #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_2_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_2_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_2_Z)
-      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_X
-        #define Z_PROBE_ALLEN_KEY_DEPLOY_2_X current_position[X_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_Y
-        #define Z_PROBE_ALLEN_KEY_DEPLOY_2_Y current_position[Y_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_Z
-        #define Z_PROBE_ALLEN_KEY_DEPLOY_2_Z current_position[Z_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE
-        #define Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE 0.0
-      #endif
-      const float deploy_2[] = { Z_PROBE_ALLEN_KEY_DEPLOY_2_X, Z_PROBE_ALLEN_KEY_DEPLOY_2_Y, Z_PROBE_ALLEN_KEY_DEPLOY_2_Z };
-      do_blocking_move_to(deploy_2, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE));
-    #endif
-    #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_3_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_3_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_3_Z)
-      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_X
-        #define Z_PROBE_ALLEN_KEY_DEPLOY_3_X current_position[X_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_Y
-        #define Z_PROBE_ALLEN_KEY_DEPLOY_3_Y current_position[Y_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_Z
-        #define Z_PROBE_ALLEN_KEY_DEPLOY_3_Z current_position[Z_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE
-        #define Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE 0.0
-      #endif
-      const float deploy_3[] = { Z_PROBE_ALLEN_KEY_DEPLOY_3_X, Z_PROBE_ALLEN_KEY_DEPLOY_3_Y, Z_PROBE_ALLEN_KEY_DEPLOY_3_Z };
-      do_blocking_move_to(deploy_3, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE));
-    #endif
-    #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_4_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_4_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_4_Z)
-      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_X
-        #define Z_PROBE_ALLEN_KEY_DEPLOY_4_X current_position[X_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_Y
-        #define Z_PROBE_ALLEN_KEY_DEPLOY_4_Y current_position[Y_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_Z
-        #define Z_PROBE_ALLEN_KEY_DEPLOY_4_Z current_position[Z_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE
-        #define Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE 0.0
-      #endif
-      const float deploy_4[] = { Z_PROBE_ALLEN_KEY_DEPLOY_4_X, Z_PROBE_ALLEN_KEY_DEPLOY_4_Y, Z_PROBE_ALLEN_KEY_DEPLOY_4_Z };
-      do_blocking_move_to(deploy_4, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE));
-    #endif
-    #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_5_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_5_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_5_Z)
-      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_X
-        #define Z_PROBE_ALLEN_KEY_DEPLOY_5_X current_position[X_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_Y
-        #define Z_PROBE_ALLEN_KEY_DEPLOY_5_Y current_position[Y_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_Z
-        #define Z_PROBE_ALLEN_KEY_DEPLOY_5_Z current_position[Z_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE
-        #define Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE 0.0
-      #endif
-      const float deploy_5[] = { Z_PROBE_ALLEN_KEY_DEPLOY_5_X, Z_PROBE_ALLEN_KEY_DEPLOY_5_Y, Z_PROBE_ALLEN_KEY_DEPLOY_5_Z };
-      do_blocking_move_to(deploy_5, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE));
-    #endif
-  }
-
-  void run_stow_moves_script() {
-    #if defined(Z_PROBE_ALLEN_KEY_STOW_1_X) || defined(Z_PROBE_ALLEN_KEY_STOW_1_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_1_Z)
-      #ifndef Z_PROBE_ALLEN_KEY_STOW_1_X
-        #define Z_PROBE_ALLEN_KEY_STOW_1_X current_position[X_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_STOW_1_Y
-        #define Z_PROBE_ALLEN_KEY_STOW_1_Y current_position[Y_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_STOW_1_Z
-        #define Z_PROBE_ALLEN_KEY_STOW_1_Z current_position[Z_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE
-        #define Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE 0.0
-      #endif
-      const float stow_1[] = { Z_PROBE_ALLEN_KEY_STOW_1_X, Z_PROBE_ALLEN_KEY_STOW_1_Y, Z_PROBE_ALLEN_KEY_STOW_1_Z };
-      do_blocking_move_to(stow_1, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE));
-    #endif
-    #if defined(Z_PROBE_ALLEN_KEY_STOW_2_X) || defined(Z_PROBE_ALLEN_KEY_STOW_2_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_2_Z)
-      #ifndef Z_PROBE_ALLEN_KEY_STOW_2_X
-        #define Z_PROBE_ALLEN_KEY_STOW_2_X current_position[X_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_STOW_2_Y
-        #define Z_PROBE_ALLEN_KEY_STOW_2_Y current_position[Y_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_STOW_2_Z
-        #define Z_PROBE_ALLEN_KEY_STOW_2_Z current_position[Z_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE
-        #define Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE 0.0
-      #endif
-      const float stow_2[] = { Z_PROBE_ALLEN_KEY_STOW_2_X, Z_PROBE_ALLEN_KEY_STOW_2_Y, Z_PROBE_ALLEN_KEY_STOW_2_Z };
-      do_blocking_move_to(stow_2, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE));
-    #endif
-    #if defined(Z_PROBE_ALLEN_KEY_STOW_3_X) || defined(Z_PROBE_ALLEN_KEY_STOW_3_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_3_Z)
-      #ifndef Z_PROBE_ALLEN_KEY_STOW_3_X
-        #define Z_PROBE_ALLEN_KEY_STOW_3_X current_position[X_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_STOW_3_Y
-        #define Z_PROBE_ALLEN_KEY_STOW_3_Y current_position[Y_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_STOW_3_Z
-        #define Z_PROBE_ALLEN_KEY_STOW_3_Z current_position[Z_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE
-        #define Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE 0.0
-      #endif
-      const float stow_3[] = { Z_PROBE_ALLEN_KEY_STOW_3_X, Z_PROBE_ALLEN_KEY_STOW_3_Y, Z_PROBE_ALLEN_KEY_STOW_3_Z };
-      do_blocking_move_to(stow_3, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE));
-    #endif
-    #if defined(Z_PROBE_ALLEN_KEY_STOW_4_X) || defined(Z_PROBE_ALLEN_KEY_STOW_4_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_4_Z)
-      #ifndef Z_PROBE_ALLEN_KEY_STOW_4_X
-        #define Z_PROBE_ALLEN_KEY_STOW_4_X current_position[X_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_STOW_4_Y
-        #define Z_PROBE_ALLEN_KEY_STOW_4_Y current_position[Y_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_STOW_4_Z
-        #define Z_PROBE_ALLEN_KEY_STOW_4_Z current_position[Z_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE
-        #define Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE 0.0
-      #endif
-      const float stow_4[] = { Z_PROBE_ALLEN_KEY_STOW_4_X, Z_PROBE_ALLEN_KEY_STOW_4_Y, Z_PROBE_ALLEN_KEY_STOW_4_Z };
-      do_blocking_move_to(stow_4, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE));
-    #endif
-    #if defined(Z_PROBE_ALLEN_KEY_STOW_5_X) || defined(Z_PROBE_ALLEN_KEY_STOW_5_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_5_Z)
-      #ifndef Z_PROBE_ALLEN_KEY_STOW_5_X
-        #define Z_PROBE_ALLEN_KEY_STOW_5_X current_position[X_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_STOW_5_Y
-        #define Z_PROBE_ALLEN_KEY_STOW_5_Y current_position[Y_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_STOW_5_Z
-        #define Z_PROBE_ALLEN_KEY_STOW_5_Z current_position[Z_AXIS]
-      #endif
-      #ifndef Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE
-        #define Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE 0.0
-      #endif
-      const float stow_5[] = { Z_PROBE_ALLEN_KEY_STOW_5_X, Z_PROBE_ALLEN_KEY_STOW_5_Y, Z_PROBE_ALLEN_KEY_STOW_5_Z };
-      do_blocking_move_to(stow_5, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE));
-    #endif
-  }
-
-#endif
-
-#if ENABLED(PROBING_FANS_OFF)
-
-  void fans_pause(const bool p) {
-    if (p != fans_paused) {
-      fans_paused = p;
-      if (p)
-        for (uint8_t x = 0; x < FAN_COUNT; x++) {
-          paused_fanSpeeds[x] = fanSpeeds[x];
-          fanSpeeds[x] = 0;
-        }
-      else
-        for (uint8_t x = 0; x < FAN_COUNT; x++)
-          fanSpeeds[x] = paused_fanSpeeds[x];
-    }
-  }
-
-#endif // PROBING_FANS_OFF
-
-#if HAS_BED_PROBE
-
-  // TRIGGERED_WHEN_STOWED_TEST can easily be extended to servo probes, ... if needed.
-  #if ENABLED(PROBE_IS_TRIGGERED_WHEN_STOWED_TEST)
-    #if ENABLED(Z_MIN_PROBE_ENDSTOP)
-      #define _TRIGGERED_WHEN_STOWED_TEST (READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)
-    #else
-      #define _TRIGGERED_WHEN_STOWED_TEST (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)
-    #endif
-  #endif
-
-  #if QUIET_PROBING
-    void probing_pause(const bool p) {
-      #if ENABLED(PROBING_HEATERS_OFF)
-        thermalManager.pause(p);
-      #endif
-      #if ENABLED(PROBING_FANS_OFF)
-        fans_pause(p);
-      #endif
-      if (p) safe_delay(
-        #if DELAY_BEFORE_PROBING > 25
-          DELAY_BEFORE_PROBING
-        #else
-          25
-        #endif
-      );
-    }
-  #endif // QUIET_PROBING
-
-  #if ENABLED(BLTOUCH)
-
-    void bltouch_command(int angle) {
-      MOVE_SERVO(Z_ENDSTOP_SERVO_NR, angle);  // Give the BL-Touch the command and wait
-      safe_delay(BLTOUCH_DELAY);
-    }
-
-    bool set_bltouch_deployed(const bool deploy) {
-      if (deploy && TEST_BLTOUCH()) {      // If BL-Touch says it's triggered
-        bltouch_command(BLTOUCH_RESET);    //  try to reset it.
-        bltouch_command(BLTOUCH_DEPLOY);   // Also needs to deploy and stow to
-        bltouch_command(BLTOUCH_STOW);     //  clear the triggered condition.
-        safe_delay(1500);                  // Wait for internal self-test to complete.
-                                           //  (Measured completion time was 0.65 seconds
-                                           //   after reset, deploy, and stow sequence)
-        if (TEST_BLTOUCH()) {              // If it still claims to be triggered...
-          SERIAL_ERROR_START();
-          SERIAL_ERRORLNPGM(MSG_STOP_BLTOUCH);
-          stop();                          // punt!
-          return true;
-        }
-      }
-
-      bltouch_command(deploy ? BLTOUCH_DEPLOY : BLTOUCH_STOW);
-
-      #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) {
-          SERIAL_ECHOPAIR("set_bltouch_deployed(", deploy);
-          SERIAL_CHAR(')');
-          SERIAL_EOL();
-        }
-      #endif
-
-      return false;
-    }
-
-  #endif // BLTOUCH
-
-  // returns false for ok and true for failure
-  bool set_probe_deployed(bool deploy) {
-
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        DEBUG_POS("set_probe_deployed", current_position);
-        SERIAL_ECHOLNPAIR("deploy: ", deploy);
-      }
-    #endif
-
-    if (endstops.z_probe_enabled == deploy) return false;
-
-    // Make room for probe
-    do_probe_raise(_Z_CLEARANCE_DEPLOY_PROBE);
-
-    #if ENABLED(Z_PROBE_SLED) || ENABLED(Z_PROBE_ALLEN_KEY)
-      #if ENABLED(Z_PROBE_SLED)
-        #define _AUE_ARGS true, false, false
-      #else
-        #define _AUE_ARGS
-      #endif
-      if (axis_unhomed_error(_AUE_ARGS)) {
-        SERIAL_ERROR_START();
-        SERIAL_ERRORLNPGM(MSG_STOP_UNHOMED);
-        stop();
-        return true;
-      }
-    #endif
-
-    const float oldXpos = current_position[X_AXIS],
-                oldYpos = current_position[Y_AXIS];
-
-    #ifdef _TRIGGERED_WHEN_STOWED_TEST
-
-      // If endstop is already false, the Z probe is deployed
-      if (_TRIGGERED_WHEN_STOWED_TEST == deploy) {     // closed after the probe specific actions.
-                                                       // Would a goto be less ugly?
-        //while (!_TRIGGERED_WHEN_STOWED_TEST) idle(); // would offer the opportunity
-                                                       // for a triggered when stowed manual probe.
-
-        if (!deploy) endstops.enable_z_probe(false); // Switch off triggered when stowed probes early
-                                                     // otherwise an Allen-Key probe can't be stowed.
-    #endif
-
-        #if ENABLED(SOLENOID_PROBE)
-
-          #if HAS_SOLENOID_1
-            WRITE(SOL1_PIN, deploy);
-          #endif
-
-        #elif ENABLED(Z_PROBE_SLED)
-
-          dock_sled(!deploy);
-
-        #elif HAS_Z_SERVO_ENDSTOP && DISABLED(BLTOUCH)
-
-          MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[deploy ? 0 : 1]);
-
-        #elif ENABLED(Z_PROBE_ALLEN_KEY)
-
-          deploy ? run_deploy_moves_script() : run_stow_moves_script();
-
-        #endif
-
-    #ifdef _TRIGGERED_WHEN_STOWED_TEST
-      } // _TRIGGERED_WHEN_STOWED_TEST == deploy
-
-      if (_TRIGGERED_WHEN_STOWED_TEST == deploy) { // State hasn't changed?
-
-        if (IsRunning()) {
-          SERIAL_ERROR_START();
-          SERIAL_ERRORLNPGM("Z-Probe failed");
-          LCD_ALERTMESSAGEPGM("Err: ZPROBE");
-        }
-        stop();
-        return true;
-
-      } // _TRIGGERED_WHEN_STOWED_TEST == deploy
-
-    #endif
-
-    do_blocking_move_to(oldXpos, oldYpos, current_position[Z_AXIS]); // return to position before deploy
-    endstops.enable_z_probe(deploy);
-    return false;
-  }
-
-  /**
-   * @brief Used by run_z_probe to do a single Z probe move.
-   *
-   * @param  z        Z destination
-   * @param  fr_mm_s  Feedrate in mm/s
-   * @return true to indicate an error
-   */
-  static bool do_probe_move(const float z, const float fr_mm_m) {
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) DEBUG_POS(">>> do_probe_move", current_position);
-    #endif
-
-    // Deploy BLTouch at the start of any probe
-    #if ENABLED(BLTOUCH)
-      if (set_bltouch_deployed(true)) return true;
-    #endif
-
-    #if QUIET_PROBING
-      probing_pause(true);
-    #endif
-
-    // Move down until probe triggered
-    do_blocking_move_to_z(z, MMM_TO_MMS(fr_mm_m));
-
-    // Check to see if the probe was triggered
-    const bool probe_triggered = TEST(Endstops::endstop_hit_bits,
-      #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
-        Z_MIN
-      #else
-        Z_MIN_PROBE
-      #endif
-    );
-
-    #if QUIET_PROBING
-      probing_pause(false);
-    #endif
-
-    // Retract BLTouch immediately after a probe if it was triggered
-    #if ENABLED(BLTOUCH)
-      if (probe_triggered && set_bltouch_deployed(false)) return true;
-    #endif
-
-    // Clear endstop flags
-    endstops.hit_on_purpose();
-
-    // Get Z where the steppers were interrupted
-    set_current_from_steppers_for_axis(Z_AXIS);
-
-    // Tell the planner where we actually are
-    SYNC_PLAN_POSITION_KINEMATIC();
-
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) DEBUG_POS("<<< do_probe_move", current_position);
-    #endif
-
-    return !probe_triggered;
-  }
-
-  /**
-   * @details Used by probe_pt to do a single Z probe.
-   *          Leaves current_position[Z_AXIS] at the height where the probe triggered.
-   *
-   * @param  short_move Flag for a shorter probe move towards the bed
-   * @return The raw Z position where the probe was triggered
-   */
-  static float run_z_probe(const bool short_move=true) {
-
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) DEBUG_POS(">>> run_z_probe", current_position);
-    #endif
-
-    // Prevent stepper_inactive_time from running out and EXTRUDER_RUNOUT_PREVENT from extruding
-    gcode.refresh_cmd_timeout();
-
-    #if ENABLED(PROBE_DOUBLE_TOUCH)
-
-      // Do a first probe at the fast speed
-      if (do_probe_move(-10, Z_PROBE_SPEED_FAST)) return NAN;
-
-      #if ENABLED(DEBUG_LEVELING_FEATURE)
-        float first_probe_z = current_position[Z_AXIS];
-        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("1st Probe Z:", first_probe_z);
-      #endif
-
-      // move up to make clearance for the probe
-      do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
-
-    #else
-
-      // If the nozzle is above the travel height then
-      // move down quickly before doing the slow probe
-      float z = Z_CLEARANCE_DEPLOY_PROBE;
-      if (zprobe_zoffset < 0) z -= zprobe_zoffset;
-
-      if (z < current_position[Z_AXIS]) {
-
-        // If we don't make it to the z position (i.e. the probe triggered), move up to make clearance for the probe
-        if (!do_probe_move(z, Z_PROBE_SPEED_FAST))
-          do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
-      }
-    #endif
-
-    // move down slowly to find bed
-    if (do_probe_move(-10 + (short_move ? 0 : -(Z_MAX_LENGTH)), Z_PROBE_SPEED_SLOW)) return NAN;
-
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) DEBUG_POS("<<< run_z_probe", current_position);
-    #endif
-
-    // Debug: compare probe heights
-    #if ENABLED(PROBE_DOUBLE_TOUCH) && ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        SERIAL_ECHOPAIR("2nd Probe Z:", current_position[Z_AXIS]);
-        SERIAL_ECHOLNPAIR(" Discrepancy:", first_probe_z - current_position[Z_AXIS]);
-      }
-    #endif
-
-    return RAW_CURRENT_POSITION(Z) + zprobe_zoffset
-      #if ENABLED(DELTA)
-        + home_offset[Z_AXIS] // Account for delta height adjustment
-      #endif
-    ;
-  }
-
-  /**
-   * - Move to the given XY
-   * - Deploy the probe, if not already deployed
-   * - Probe the bed, get the Z position
-   * - Depending on the 'stow' flag
-   *   - Stow the probe, or
-   *   - Raise to the BETWEEN height
-   * - Return the probed Z position
-   */
-  float probe_pt(const float &lx, const float &ly, const bool stow, const uint8_t verbose_level, const bool printable=true) {
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        SERIAL_ECHOPAIR(">>> probe_pt(", lx);
-        SERIAL_ECHOPAIR(", ", ly);
-        SERIAL_ECHOPAIR(", ", stow ? "" : "no ");
-        SERIAL_ECHOLNPGM("stow)");
-        DEBUG_POS("", current_position);
-      }
-    #endif
-
-    const float nx = lx - (X_PROBE_OFFSET_FROM_EXTRUDER), ny = ly - (Y_PROBE_OFFSET_FROM_EXTRUDER);
-
-    if (printable
-      ? !position_is_reachable_xy(nx, ny)
-      : !position_is_reachable_by_probe_xy(lx, ly)
-    ) return NAN;
-
-
-    const float old_feedrate_mm_s = feedrate_mm_s;
-
-    #if ENABLED(DELTA)
-      if (current_position[Z_AXIS] > delta_clip_start_height)
-        do_blocking_move_to_z(delta_clip_start_height);
-    #endif
-
-    #if HAS_SOFTWARE_ENDSTOPS
-      // Store the status of the soft endstops and disable if we're probing a non-printable location
-      static bool enable_soft_endstops = soft_endstops_enabled;
-      if (!printable) soft_endstops_enabled = false;
-    #endif
-
-    feedrate_mm_s = XY_PROBE_FEEDRATE_MM_S;
-
-    // Move the probe to the given XY
-    do_blocking_move_to_xy(nx, ny);
-
-    float measured_z = NAN;
-    if (!DEPLOY_PROBE()) {
-      measured_z = run_z_probe(printable);
-
-      if (!stow)
-        do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
-      else
-        if (STOW_PROBE()) measured_z = NAN;
-    }
-
-    #if HAS_SOFTWARE_ENDSTOPS
-      // Restore the soft endstop status
-      soft_endstops_enabled = enable_soft_endstops;
-    #endif
-
-    if (verbose_level > 2) {
-      SERIAL_PROTOCOLPGM("Bed X: ");
-      SERIAL_PROTOCOL_F(lx, 3);
-      SERIAL_PROTOCOLPGM(" Y: ");
-      SERIAL_PROTOCOL_F(ly, 3);
-      SERIAL_PROTOCOLPGM(" Z: ");
-      SERIAL_PROTOCOL_F(measured_z, 3);
-      SERIAL_EOL();
-    }
-
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< probe_pt");
-    #endif
-
-    feedrate_mm_s = old_feedrate_mm_s;
-
-    if (isnan(measured_z)) {
-      LCD_MESSAGEPGM(MSG_ERR_PROBING_FAILED);
-      SERIAL_ERROR_START();
-      SERIAL_ERRORLNPGM(MSG_ERR_PROBING_FAILED);
-    }
-
-    return measured_z;
-  }
-
-#endif // HAS_BED_PROBE
-
-#if HAS_LEVELING
-
-  bool leveling_is_valid() {
-    return
-      #if ENABLED(MESH_BED_LEVELING)
-        mbl.has_mesh()
-      #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
-        !!bilinear_grid_spacing[X_AXIS]
-      #elif ENABLED(AUTO_BED_LEVELING_UBL)
-        true
-      #else // 3POINT, LINEAR
-        true
-      #endif
-    ;
-  }
-
-  bool leveling_is_active() {
-    return
-      #if ENABLED(MESH_BED_LEVELING)
-        mbl.active()
-      #elif ENABLED(AUTO_BED_LEVELING_UBL)
-        ubl.state.active
-      #else
-        planner.abl_enabled
-      #endif
-    ;
-  }
-
-  /**
-   * Turn bed leveling on or off, fixing the current
-   * position as-needed.
-   *
-   * Disable: Current position = physical position
-   *  Enable: Current position = "unleveled" physical position
-   */
-  void set_bed_leveling_enabled(const bool enable/*=true*/) {
-
-    #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
-      const bool can_change = (!enable || leveling_is_valid());
-    #else
-      constexpr bool can_change = true;
-    #endif
-
-    if (can_change && enable != leveling_is_active()) {
-
-      #if ENABLED(MESH_BED_LEVELING)
-
-        if (!enable)
-          planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS]);
-
-        const bool enabling = enable && leveling_is_valid();
-        mbl.set_active(enabling);
-        if (enabling) planner.unapply_leveling(current_position);
-
-      #elif ENABLED(AUTO_BED_LEVELING_UBL)
-        #if PLANNER_LEVELING
-          if (ubl.state.active) {                       // leveling from on to off
-            // change unleveled current_position to physical current_position without moving steppers.
-            planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS]);
-            ubl.state.active = false;                   // disable only AFTER calling apply_leveling
-          }
-          else {                                        // leveling from off to on
-            ubl.state.active = true;                    // enable BEFORE calling unapply_leveling, otherwise ignored
-            // change physical current_position to unleveled current_position without moving steppers.
-            planner.unapply_leveling(current_position);
-          }
-        #else
-          ubl.state.active = enable;                    // just flip the bit, current_position will be wrong until next move.
-        #endif
-
-      #else // ABL
-
-        #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
-          // Force bilinear_z_offset to re-calculate next time
-          const float reset[XYZ] = { -9999.999, -9999.999, 0 };
-          (void)bilinear_z_offset(reset);
-        #endif
-
-        // Enable or disable leveling compensation in the planner
-        planner.abl_enabled = enable;
-
-        if (!enable)
-          // When disabling just get the current position from the steppers.
-          // This will yield the smallest error when first converted back to steps.
-          set_current_from_steppers_for_axis(
-            #if ABL_PLANAR
-              ALL_AXES
-            #else
-              Z_AXIS
-            #endif
-          );
-        else
-          // When enabling, remove compensation from the current position,
-          // so compensation will give the right stepper counts.
-          planner.unapply_leveling(current_position);
-
-      #endif // ABL
-    }
-  }
-
-  #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-
-    void set_z_fade_height(const float zfh) {
-
-      const bool level_active = leveling_is_active();
-
-      #if ENABLED(AUTO_BED_LEVELING_UBL)
-
-        if (level_active)
-          set_bed_leveling_enabled(false);  // turn off before changing fade height for proper apply/unapply leveling to maintain current_position
-        planner.z_fade_height = zfh;
-        planner.inverse_z_fade_height = RECIPROCAL(zfh);
-        if (level_active)
-          set_bed_leveling_enabled(true);  // turn back on after changing fade height
-
-      #else
-
-        planner.z_fade_height = zfh;
-        planner.inverse_z_fade_height = RECIPROCAL(zfh);
-
-        if (level_active) {
-          set_current_from_steppers_for_axis(
-            #if ABL_PLANAR
-              ALL_AXES
-            #else
-              Z_AXIS
-            #endif
-          );
-        }
-      #endif
-    }
-
-  #endif // LEVELING_FADE_HEIGHT
-
-  /**
-   * Reset calibration results to zero.
-   */
-  void reset_bed_level() {
-    set_bed_leveling_enabled(false);
-    #if ENABLED(MESH_BED_LEVELING)
-      if (leveling_is_valid()) {
-        mbl.reset();
-        mbl.set_has_mesh(false);
-      }
-    #else
-      #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("reset_bed_level");
-      #endif
-      #if ABL_PLANAR
-        planner.bed_level_matrix.set_to_identity();
-      #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
-        bilinear_start[X_AXIS] = bilinear_start[Y_AXIS] =
-        bilinear_grid_spacing[X_AXIS] = bilinear_grid_spacing[Y_AXIS] = 0;
-        for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
-          for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
-            z_values[x][y] = NAN;
-      #elif ENABLED(AUTO_BED_LEVELING_UBL)
-        ubl.reset();
-      #endif
-    #endif
-  }
-
-#endif // HAS_LEVELING
-
-#if ENABLED(AUTO_BED_LEVELING_BILINEAR) || ENABLED(MESH_BED_LEVELING)
-
-  /**
-   * Enable to produce output in JSON format suitable
-   * for SCAD or JavaScript mesh visualizers.
-   *
-   * Visualize meshes in OpenSCAD using the included script.
-   *
-   *   buildroot/shared/scripts/MarlinMesh.scad
-   */
-  //#define SCAD_MESH_OUTPUT
-
-  /**
-   * Print calibration results for plotting or manual frame adjustment.
-   */
-  static void print_2d_array(const uint8_t sx, const uint8_t sy, const uint8_t precision, float (*fn)(const uint8_t, const uint8_t)) {
-    #ifndef SCAD_MESH_OUTPUT
-      for (uint8_t x = 0; x < sx; x++) {
-        for (uint8_t i = 0; i < precision + 2 + (x < 10 ? 1 : 0); i++)
-          SERIAL_PROTOCOLCHAR(' ');
-        SERIAL_PROTOCOL((int)x);
-      }
-      SERIAL_EOL();
-    #endif
-    #ifdef SCAD_MESH_OUTPUT
-      SERIAL_PROTOCOLLNPGM("measured_z = ["); // open 2D array
-    #endif
-    for (uint8_t y = 0; y < sy; y++) {
-      #ifdef SCAD_MESH_OUTPUT
-        SERIAL_PROTOCOLPGM(" [");           // open sub-array
-      #else
-        if (y < 10) SERIAL_PROTOCOLCHAR(' ');
-        SERIAL_PROTOCOL((int)y);
-      #endif
-      for (uint8_t x = 0; x < sx; x++) {
-        SERIAL_PROTOCOLCHAR(' ');
-        const float offset = fn(x, y);
-        if (!isnan(offset)) {
-          if (offset >= 0) SERIAL_PROTOCOLCHAR('+');
-          SERIAL_PROTOCOL_F(offset, precision);
-        }
-        else {
-          #ifdef SCAD_MESH_OUTPUT
-            for (uint8_t i = 3; i < precision + 3; i++)
-              SERIAL_PROTOCOLCHAR(' ');
-            SERIAL_PROTOCOLPGM("NAN");
-          #else
-            for (uint8_t i = 0; i < precision + 3; i++)
-              SERIAL_PROTOCOLCHAR(i ? '=' : ' ');
-          #endif
-        }
-        #ifdef SCAD_MESH_OUTPUT
-          if (x < sx - 1) SERIAL_PROTOCOLCHAR(',');
-        #endif
-      }
-      #ifdef SCAD_MESH_OUTPUT
-        SERIAL_PROTOCOLCHAR(' ');
-        SERIAL_PROTOCOLCHAR(']');                     // close sub-array
-        if (y < sy - 1) SERIAL_PROTOCOLCHAR(',');
-      #endif
-      SERIAL_EOL();
-    }
-    #ifdef SCAD_MESH_OUTPUT
-      SERIAL_PROTOCOLPGM("];");                       // close 2D array
-    #endif
-    SERIAL_EOL();
-  }
-
-#endif
-
-#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
-
-  /**
-   * Extrapolate a single point from its neighbors
-   */
-  static void extrapolate_one_point(const uint8_t x, const uint8_t y, const int8_t xdir, const int8_t ydir) {
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        SERIAL_ECHOPGM("Extrapolate [");
-        if (x < 10) SERIAL_CHAR(' ');
-        SERIAL_ECHO((int)x);
-        SERIAL_CHAR(xdir ? (xdir > 0 ? '+' : '-') : ' ');
-        SERIAL_CHAR(' ');
-        if (y < 10) SERIAL_CHAR(' ');
-        SERIAL_ECHO((int)y);
-        SERIAL_CHAR(ydir ? (ydir > 0 ? '+' : '-') : ' ');
-        SERIAL_CHAR(']');
-      }
-    #endif
-    if (!isnan(z_values[x][y])) {
-      #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM(" (done)");
-      #endif
-      return;  // Don't overwrite good values.
-    }
-    SERIAL_EOL();
-
-    // Get X neighbors, Y neighbors, and XY neighbors
-    const uint8_t x1 = x + xdir, y1 = y + ydir, x2 = x1 + xdir, y2 = y1 + ydir;
-    float a1 = z_values[x1][y ], a2 = z_values[x2][y ],
-          b1 = z_values[x ][y1], b2 = z_values[x ][y2],
-          c1 = z_values[x1][y1], c2 = z_values[x2][y2];
-
-    // Treat far unprobed points as zero, near as equal to far
-    if (isnan(a2)) a2 = 0.0; if (isnan(a1)) a1 = a2;
-    if (isnan(b2)) b2 = 0.0; if (isnan(b1)) b1 = b2;
-    if (isnan(c2)) c2 = 0.0; if (isnan(c1)) c1 = c2;
-
-    const float a = 2 * a1 - a2, b = 2 * b1 - b2, c = 2 * c1 - c2;
-
-    // Take the average instead of the median
-    z_values[x][y] = (a + b + c) / 3.0;
-
-    // Median is robust (ignores outliers).
-    // z_values[x][y] = (a < b) ? ((b < c) ? b : (c < a) ? a : c)
-    //                                : ((c < b) ? b : (a < c) ? a : c);
-  }
-
-  //Enable this if your SCARA uses 180° of total area
-  //#define EXTRAPOLATE_FROM_EDGE
-
-  #if ENABLED(EXTRAPOLATE_FROM_EDGE)
-    #if GRID_MAX_POINTS_X < GRID_MAX_POINTS_Y
-      #define HALF_IN_X
-    #elif GRID_MAX_POINTS_Y < GRID_MAX_POINTS_X
-      #define HALF_IN_Y
-    #endif
-  #endif
-
-  /**
-   * Fill in the unprobed points (corners of circular print surface)
-   * using linear extrapolation, away from the center.
-   */
-  static void extrapolate_unprobed_bed_level() {
-    #ifdef HALF_IN_X
-      constexpr uint8_t ctrx2 = 0, xlen = GRID_MAX_POINTS_X - 1;
-    #else
-      constexpr uint8_t ctrx1 = (GRID_MAX_POINTS_X - 1) / 2, // left-of-center
-                        ctrx2 = (GRID_MAX_POINTS_X) / 2,     // right-of-center
-                        xlen = ctrx1;
-    #endif
-
-    #ifdef HALF_IN_Y
-      constexpr uint8_t ctry2 = 0, ylen = GRID_MAX_POINTS_Y - 1;
-    #else
-      constexpr uint8_t ctry1 = (GRID_MAX_POINTS_Y - 1) / 2, // top-of-center
-                        ctry2 = (GRID_MAX_POINTS_Y) / 2,     // bottom-of-center
-                        ylen = ctry1;
-    #endif
-
-    for (uint8_t xo = 0; xo <= xlen; xo++)
-      for (uint8_t yo = 0; yo <= ylen; yo++) {
-        uint8_t x2 = ctrx2 + xo, y2 = ctry2 + yo;
-        #ifndef HALF_IN_X
-          const uint8_t x1 = ctrx1 - xo;
-        #endif
-        #ifndef HALF_IN_Y
-          const uint8_t y1 = ctry1 - yo;
-          #ifndef HALF_IN_X
-            extrapolate_one_point(x1, y1, +1, +1);   //  left-below + +
-          #endif
-          extrapolate_one_point(x2, y1, -1, +1);     // right-below - +
-        #endif
-        #ifndef HALF_IN_X
-          extrapolate_one_point(x1, y2, +1, -1);     //  left-above + -
-        #endif
-        extrapolate_one_point(x2, y2, -1, -1);       // right-above - -
-      }
-
-  }
-
-  static void print_bilinear_leveling_grid() {
-    SERIAL_ECHOLNPGM("Bilinear Leveling Grid:");
-    print_2d_array(GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y, 3,
-      [](const uint8_t ix, const uint8_t iy) { return z_values[ix][iy]; }
-    );
-  }
-
-  #if ENABLED(ABL_BILINEAR_SUBDIVISION)
-
-    #define ABL_GRID_POINTS_VIRT_X (GRID_MAX_POINTS_X - 1) * (BILINEAR_SUBDIVISIONS) + 1
-    #define ABL_GRID_POINTS_VIRT_Y (GRID_MAX_POINTS_Y - 1) * (BILINEAR_SUBDIVISIONS) + 1
-    #define ABL_TEMP_POINTS_X (GRID_MAX_POINTS_X + 2)
-    #define ABL_TEMP_POINTS_Y (GRID_MAX_POINTS_Y + 2)
-    float z_values_virt[ABL_GRID_POINTS_VIRT_X][ABL_GRID_POINTS_VIRT_Y];
-    int bilinear_grid_spacing_virt[2] = { 0 };
-    float bilinear_grid_factor_virt[2] = { 0 };
-
-    static void print_bilinear_leveling_grid_virt() {
-      SERIAL_ECHOLNPGM("Subdivided with CATMULL ROM Leveling Grid:");
-      print_2d_array(ABL_GRID_POINTS_VIRT_X, ABL_GRID_POINTS_VIRT_Y, 5,
-        [](const uint8_t ix, const uint8_t iy) { return z_values_virt[ix][iy]; }
-      );
-    }
-
-    #define LINEAR_EXTRAPOLATION(E, I) ((E) * 2 - (I))
-    float bed_level_virt_coord(const uint8_t x, const uint8_t y) {
-      uint8_t ep = 0, ip = 1;
-      if (!x || x == ABL_TEMP_POINTS_X - 1) {
-        if (x) {
-          ep = GRID_MAX_POINTS_X - 1;
-          ip = GRID_MAX_POINTS_X - 2;
-        }
-        if (WITHIN(y, 1, ABL_TEMP_POINTS_Y - 2))
-          return LINEAR_EXTRAPOLATION(
-            z_values[ep][y - 1],
-            z_values[ip][y - 1]
-          );
-        else
-          return LINEAR_EXTRAPOLATION(
-            bed_level_virt_coord(ep + 1, y),
-            bed_level_virt_coord(ip + 1, y)
-          );
-      }
-      if (!y || y == ABL_TEMP_POINTS_Y - 1) {
-        if (y) {
-          ep = GRID_MAX_POINTS_Y - 1;
-          ip = GRID_MAX_POINTS_Y - 2;
-        }
-        if (WITHIN(x, 1, ABL_TEMP_POINTS_X - 2))
-          return LINEAR_EXTRAPOLATION(
-            z_values[x - 1][ep],
-            z_values[x - 1][ip]
-          );
-        else
-          return LINEAR_EXTRAPOLATION(
-            bed_level_virt_coord(x, ep + 1),
-            bed_level_virt_coord(x, ip + 1)
-          );
-      }
-      return z_values[x - 1][y - 1];
-    }
-
-    static float bed_level_virt_cmr(const float p[4], const uint8_t i, const float t) {
-      return (
-          p[i-1] * -t * sq(1 - t)
-        + p[i]   * (2 - 5 * sq(t) + 3 * t * sq(t))
-        + p[i+1] * t * (1 + 4 * t - 3 * sq(t))
-        - p[i+2] * sq(t) * (1 - t)
-      ) * 0.5;
-    }
-
-    static float bed_level_virt_2cmr(const uint8_t x, const uint8_t y, const float &tx, const float &ty) {
-      float row[4], column[4];
-      for (uint8_t i = 0; i < 4; i++) {
-        for (uint8_t j = 0; j < 4; j++) {
-          column[j] = bed_level_virt_coord(i + x - 1, j + y - 1);
-        }
-        row[i] = bed_level_virt_cmr(column, 1, ty);
-      }
-      return bed_level_virt_cmr(row, 1, tx);
-    }
-
-    void bed_level_virt_interpolate() {
-      bilinear_grid_spacing_virt[X_AXIS] = bilinear_grid_spacing[X_AXIS] / (BILINEAR_SUBDIVISIONS);
-      bilinear_grid_spacing_virt[Y_AXIS] = bilinear_grid_spacing[Y_AXIS] / (BILINEAR_SUBDIVISIONS);
-      bilinear_grid_factor_virt[X_AXIS] = RECIPROCAL(bilinear_grid_spacing_virt[X_AXIS]);
-      bilinear_grid_factor_virt[Y_AXIS] = RECIPROCAL(bilinear_grid_spacing_virt[Y_AXIS]);
-      for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
-        for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
-          for (uint8_t ty = 0; ty < BILINEAR_SUBDIVISIONS; ty++)
-            for (uint8_t tx = 0; tx < BILINEAR_SUBDIVISIONS; tx++) {
-              if ((ty && y == GRID_MAX_POINTS_Y - 1) || (tx && x == GRID_MAX_POINTS_X - 1))
-                continue;
-              z_values_virt[x * (BILINEAR_SUBDIVISIONS) + tx][y * (BILINEAR_SUBDIVISIONS) + ty] =
-                bed_level_virt_2cmr(
-                  x + 1,
-                  y + 1,
-                  (float)tx / (BILINEAR_SUBDIVISIONS),
-                  (float)ty / (BILINEAR_SUBDIVISIONS)
-                );
-            }
-    }
-  #endif // ABL_BILINEAR_SUBDIVISION
-
-  // Refresh after other values have been updated
-  void refresh_bed_level() {
-    bilinear_grid_factor[X_AXIS] = RECIPROCAL(bilinear_grid_spacing[X_AXIS]);
-    bilinear_grid_factor[Y_AXIS] = RECIPROCAL(bilinear_grid_spacing[Y_AXIS]);
-    #if ENABLED(ABL_BILINEAR_SUBDIVISION)
-      bed_level_virt_interpolate();
-    #endif
-  }
-
-#endif // AUTO_BED_LEVELING_BILINEAR
-
-/**
- * Home an individual linear axis
- */
-static void do_homing_move(const AxisEnum axis, const float distance, const float fr_mm_s=0.0) {
-
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) {
-      SERIAL_ECHOPAIR(">>> do_homing_move(", axis_codes[axis]);
-      SERIAL_ECHOPAIR(", ", distance);
-      SERIAL_ECHOPAIR(", ", fr_mm_s);
-      SERIAL_CHAR(')');
-      SERIAL_EOL();
-    }
-  #endif
-
-  #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
-    const bool deploy_bltouch = (axis == Z_AXIS && distance < 0);
-    if (deploy_bltouch) set_bltouch_deployed(true);
-  #endif
-
-  #if QUIET_PROBING
-    if (axis == Z_AXIS) probing_pause(true);
-  #endif
+#if ENABLED(BARICUDA)
+  uint8_t baricuda_valve_pressure = 0,
+          baricuda_e_to_p_pressure = 0;
+#endif
 
-  // Tell the planner we're at Z=0
-  current_position[axis] = 0;
+#if HAS_POWER_SWITCH
+  bool powersupply_on =
+    #if ENABLED(PS_DEFAULT_OFF)
+      false
+    #else
+      true
+    #endif
+  ;
+#endif
 
-  #if IS_SCARA
-    SYNC_PLAN_POSITION_KINEMATIC();
-    current_position[axis] = distance;
-    inverse_kinematics(current_position);
-    planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], current_position[E_AXIS], fr_mm_s ? fr_mm_s : homing_feedrate(axis), active_extruder);
-  #else
-    sync_plan_position();
-    current_position[axis] = distance;
-    planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], fr_mm_s ? fr_mm_s : homing_feedrate(axis), active_extruder);
-  #endif
+#if ENABLED(FILAMENT_WIDTH_SENSOR)
+  bool filament_sensor = false;                                 // M405 turns on filament sensor control. M406 turns it off.
+  float filament_width_nominal = DEFAULT_NOMINAL_FILAMENT_DIA,  // Nominal filament width. Change with M404.
+        filament_width_meas = DEFAULT_MEASURED_FILAMENT_DIA;    // Measured filament diameter
+  uint8_t meas_delay_cm = MEASUREMENT_DELAY_CM,                 // Distance delay setting
+          measurement_delay[MAX_MEASUREMENT_DELAY + 1];         // Ring buffer to delayed measurement. Store extruder factor after subtracting 100
+  int8_t filwidth_delay_index[2] = { 0, -1 };                   // Indexes into ring buffer
+#endif
 
-  stepper.synchronize();
+#if ENABLED(FILAMENT_RUNOUT_SENSOR)
+  static bool filament_ran_out = false;
+#endif
 
-  #if QUIET_PROBING
-    if (axis == Z_AXIS) probing_pause(false);
-  #endif
+#if ENABLED(ADVANCED_PAUSE_FEATURE)
+  AdvancedPauseMenuResponse advanced_pause_menu_response;
+#endif
 
-  #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
-    if (deploy_bltouch) set_bltouch_deployed(false);
+#if ENABLED(MIXING_EXTRUDER)
+  float mixing_factor[MIXING_STEPPERS]; // Reciprocal of mix proportion. 0.0 = off, otherwise >= 1.0.
+  #if MIXING_VIRTUAL_TOOLS > 1
+    float mixing_virtual_tool_mix[MIXING_VIRTUAL_TOOLS][MIXING_STEPPERS];
   #endif
+#endif
 
-  endstops.hit_on_purpose();
+#ifdef CHDK
+  millis_t chdkHigh = 0;
+  bool chdkActive = false;
+#endif
 
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) {
-      SERIAL_ECHOPAIR("<<< do_homing_move(", axis_codes[axis]);
-      SERIAL_CHAR(')');
-      SERIAL_EOL();
-    }
-  #endif
-}
+#if ENABLED(PID_EXTRUSION_SCALING)
+  int lpq_len = 20;
+#endif
 
-/**
- * TMC2130 specific sensorless homing using stallGuard2.
- * stallGuard2 only works when in spreadCycle mode.
- * spreadCycle and stealthChop are mutually exclusive.
- */
-#if ENABLED(SENSORLESS_HOMING)
-  void tmc2130_sensorless_homing(TMC2130Stepper &st, bool enable=true) {
-    #if ENABLED(STEALTHCHOP)
-      if (enable) {
-        st.coolstep_min_speed(1024UL * 1024UL - 1UL);
-        st.stealthChop(0);
-      }
-      else {
-        st.coolstep_min_speed(0);
-        st.stealthChop(1);
-      }
-    #endif
+#if ENABLED(I2C_POSITION_ENCODERS)
+  I2CPositionEncodersMgr I2CPEM;
+  uint8_t blockBufferIndexRef = 0;
+  millis_t lastUpdateMillis;
+#endif
 
-    st.diag1_stall(enable ? 1 : 0);
-  }
+#if ENABLED(CNC_WORKSPACE_PLANES)
+  static WorkspacePlane workspace_plane = PLANE_XY;
 #endif
 
 /**
- * Home an individual "raw axis" to its endstop.
- * This applies to XYZ on Cartesian and Core robots, and
- * to the individual ABC steppers on DELTA and SCARA.
- *
- * At the end of the procedure the axis is marked as
- * homed and the current position of that axis is updated.
- * Kinematic robots should wait till all axes are homed
- * before updating the current position.
+ * ***************************************************************************
+ * ******************************** FUNCTIONS ********************************
+ * ***************************************************************************
  */
 
-#define HOMEAXIS(LETTER) homeaxis(LETTER##_AXIS)
+#if ENABLED(BEZIER_CURVE_SUPPORT)
+  void plan_cubic_move(const float offset[4]);
+#endif
 
-static void homeaxis(const AxisEnum axis) {
+#if ENABLED(DIGIPOT_I2C)
+  extern void digipot_i2c_set_current(uint8_t channel, float current);
+  extern void digipot_i2c_init();
+#endif
 
-  #if IS_SCARA
-    // Only Z homing (with probe) is permitted
-    if (axis != Z_AXIS) { BUZZ(100, 880); return; }
-  #else
-    #define CAN_HOME(A) \
-      (axis == A##_AXIS && ((A##_MIN_PIN > -1 && A##_HOME_DIR < 0) || (A##_MAX_PIN > -1 && A##_HOME_DIR > 0)))
-    if (!CAN_HOME(X) && !CAN_HOME(Y) && !CAN_HOME(Z)) return;
+void setup_killpin() {
+  #if HAS_KILL
+    SET_INPUT_PULLUP(KILL_PIN);
   #endif
+}
 
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) {
-      SERIAL_ECHOPAIR(">>> homeaxis(", axis_codes[axis]);
-      SERIAL_CHAR(')');
-      SERIAL_EOL();
-    }
-  #endif
+#if ENABLED(FILAMENT_RUNOUT_SENSOR)
 
-  const int axis_home_dir =
-    #if ENABLED(DUAL_X_CARRIAGE)
-      (axis == X_AXIS) ? x_home_dir(active_extruder) :
+  void setup_filrunoutpin() {
+    #if ENABLED(ENDSTOPPULLUP_FIL_RUNOUT)
+      SET_INPUT_PULLUP(FIL_RUNOUT_PIN);
+    #else
+      SET_INPUT(FIL_RUNOUT_PIN);
     #endif
-    home_dir(axis);
+  }
 
-  // Homing Z towards the bed? Deploy the Z probe or endstop.
-  #if HOMING_Z_WITH_PROBE
-    if (axis == Z_AXIS && DEPLOY_PROBE()) return;
-  #endif
+#endif
 
-  // Set a flag for Z motor locking
-  #if ENABLED(Z_DUAL_ENDSTOPS)
-    if (axis == Z_AXIS) stepper.set_homing_flag(true);
+void setup_powerhold() {
+  #if HAS_SUICIDE
+    OUT_WRITE(SUICIDE_PIN, HIGH);
   #endif
-
-  // Disable stealthChop if used. Enable diag1 pin on driver.
-  #if ENABLED(SENSORLESS_HOMING)
-    #if ENABLED(X_IS_TMC2130)
-      if (axis == X_AXIS) tmc2130_sensorless_homing(stepperX);
-    #endif
-    #if ENABLED(Y_IS_TMC2130)
-      if (axis == Y_AXIS) tmc2130_sensorless_homing(stepperY);
+  #if HAS_POWER_SWITCH
+    #if ENABLED(PS_DEFAULT_OFF)
+      OUT_WRITE(PS_ON_PIN, PS_ON_ASLEEP);
+    #else
+      OUT_WRITE(PS_ON_PIN, PS_ON_AWAKE);
     #endif
   #endif
+}
 
-  // Fast move towards endstop until triggered
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 1 Fast:");
+void suicide() {
+  #if HAS_SUICIDE
+    OUT_WRITE(SUICIDE_PIN, LOW);
   #endif
-  do_homing_move(axis, 1.5 * max_length(axis) * axis_home_dir);
+}
 
-  // When homing Z with probe respect probe clearance
-  const float bump = axis_home_dir * (
-    #if HOMING_Z_WITH_PROBE
-      (axis == Z_AXIS) ? max(Z_CLEARANCE_BETWEEN_PROBES, home_bump_mm(Z_AXIS)) :
-    #endif
-    home_bump_mm(axis)
-  );
+#if HAS_SERVOS
+
+  HAL_SERVO_LIB servo[NUM_SERVOS];
 
-  // If a second homing move is configured...
-  if (bump) {
-    // Move away from the endstop by the axis HOME_BUMP_MM
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Move Away:");
+  void servo_init() {
+    #if NUM_SERVOS >= 1 && HAS_SERVO_0
+      servo[0].attach(SERVO0_PIN);
+      servo[0].detach(); // Just set up the pin. We don't have a position yet. Don't move to a random position.
+    #endif
+    #if NUM_SERVOS >= 2 && HAS_SERVO_1
+      servo[1].attach(SERVO1_PIN);
+      servo[1].detach();
+    #endif
+    #if NUM_SERVOS >= 3 && HAS_SERVO_2
+      servo[2].attach(SERVO2_PIN);
+      servo[2].detach();
+    #endif
+    #if NUM_SERVOS >= 4 && HAS_SERVO_3
+      servo[3].attach(SERVO3_PIN);
+      servo[3].detach();
     #endif
-    do_homing_move(axis, -bump);
 
-    // Slow move towards endstop until triggered
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 2 Slow:");
+    #if HAS_Z_SERVO_ENDSTOP
+      servo_probe_init();
     #endif
-    do_homing_move(axis, 2 * bump, get_homing_bump_feedrate(axis));
   }
 
-  #if ENABLED(Z_DUAL_ENDSTOPS)
-    if (axis == Z_AXIS) {
-      float adj = FABS(z_endstop_adj);
-      bool lockZ1;
-      if (axis_home_dir > 0) {
-        adj = -adj;
-        lockZ1 = (z_endstop_adj > 0);
-      }
-      else
-        lockZ1 = (z_endstop_adj < 0);
-
-      if (lockZ1) stepper.set_z_lock(true); else stepper.set_z2_lock(true);
-
-      // Move to the adjusted endstop height
-      do_homing_move(axis, adj);
-
-      if (lockZ1) stepper.set_z_lock(false); else stepper.set_z2_lock(false);
-      stepper.set_homing_flag(false);
-    } // Z_AXIS
-  #endif
-
-  #if IS_SCARA
-
-    set_axis_is_at_home(axis);
-    SYNC_PLAN_POSITION_KINEMATIC();
-
-  #elif ENABLED(DELTA)
-
-    // Delta has already moved all three towers up in G28
-    // so here it re-homes each tower in turn.
-    // Delta homing treats the axes as normal linear axes.
-
-    // retrace by the amount specified in endstop_adj + additional 0.1mm in order to have minimum steps
-    if (endstop_adj[axis] * Z_HOME_DIR <= 0) {
-      #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("endstop_adj:");
-      #endif
-      do_homing_move(axis, endstop_adj[axis] - 0.1);
-    }
-
-  #else
-
-    // For cartesian/core machines,
-    // set the axis to its home position
-    set_axis_is_at_home(axis);
-    sync_plan_position();
+#endif // HAS_SERVOS
 
-    destination[axis] = current_position[axis];
-
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) DEBUG_POS("> AFTER set_axis_is_at_home", current_position);
-    #endif
+/**
+ * Stepper Reset (RigidBoard, et.al.)
+ */
+#if HAS_STEPPER_RESET
+  void disableStepperDrivers() {
+    OUT_WRITE(STEPPER_RESET_PIN, LOW);  // drive it down to hold in reset motor driver chips
+  }
+  void enableStepperDrivers() { SET_INPUT(STEPPER_RESET_PIN); }  // set to input, which allows it to be pulled high by pullups
+#endif
 
-  #endif
+#if ENABLED(EXPERIMENTAL_I2CBUS) && I2C_SLAVE_ADDRESS > 0
 
-  // Re-enable stealthChop if used. Disable diag1 pin on driver.
-  #if ENABLED(SENSORLESS_HOMING)
-    #if ENABLED(X_IS_TMC2130)
-      if (axis == X_AXIS) tmc2130_sensorless_homing(stepperX, false);
-    #endif
-    #if ENABLED(Y_IS_TMC2130)
-      if (axis == Y_AXIS) tmc2130_sensorless_homing(stepperY, false);
-    #endif
-  #endif
+  void i2c_on_receive(int bytes) { // just echo all bytes received to serial
+    i2c.receive(bytes);
+  }
 
-  // Put away the Z probe
-  #if HOMING_Z_WITH_PROBE
-    if (axis == Z_AXIS && STOW_PROBE()) return;
-  #endif
+  void i2c_on_request() {          // just send dummy data for now
+    i2c.reply("Hello World!\n");
+  }
 
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) {
-      SERIAL_ECHOPAIR("<<< homeaxis(", axis_codes[axis]);
-      SERIAL_CHAR(')');
-      SERIAL_EOL();
-    }
-  #endif
-} // homeaxis()
+#endif
 
 #if ENABLED(MIXING_EXTRUDER)
 
   void normalize_mix() {
     float mix_total = 0.0;
     for (uint8_t i = 0; i < MIXING_STEPPERS; i++) mix_total += RECIPROCAL(mixing_factor[i]);
     // Scale all values if they don't add up to ~1.0
     if (!NEAR(mix_total, 1.0)) {
       SERIAL_PROTOCOLLNPGM("Warning: Mix factors must add up to 1.0. Scaling.");
       for (uint8_t i = 0; i < MIXING_STEPPERS; i++) mixing_factor[i] *= mix_total;
@@ -2260,61 +402,31 @@ void dwell(millis_t time) {
 #endif
 
 #if ENABLED(CNC_WORKSPACE_PLANES)
   #include "gcode/geometry/G17-G19.h"
 #endif
 
 #if ENABLED(INCH_MODE_SUPPORT)
   #include "gcode/units/G20_G21.h"
 #endif
 
-#if ENABLED(UBL_G26_MESH_VALIDATION)
-  #include "gcode/calibrate/G26.h"
-#endif
-
 #if ENABLED(NOZZLE_PARK_FEATURE)
   #include "gcode/feature/pause/G27.h"
 #endif
 
-#if ENABLED(PROBE_MANUALLY)
-  bool g29_in_progress = false;
-#else
-  constexpr bool g29_in_progress = false;
-#endif
-
-#include "gcode/calibrate/G28.h"
-
-void home_all_axes() { gcode_G28(true); }
-
-#if HAS_PROBING_PROCEDURE
-
-  void out_of_range_error(const char* p_edge) {
-    SERIAL_PROTOCOLPGM("?Probe ");
-    serialprintPGM(p_edge);
-    SERIAL_PROTOCOLLNPGM(" position out of range.");
-  }
-
-#endif
-
-#include "gcode/calibrate/G29.h"
-
 #if HAS_BED_PROBE
   #include "gcode/probe/G30.h"
   #if ENABLED(Z_PROBE_SLED)
     #include "gcode/probe/G31_G32.h"
   #endif
 #endif
 
-#if PROBE_SELECTED && ENABLED(DELTA_AUTO_CALIBRATION)
-  #include "gcode/calibrate/G33.h"
-#endif
-
 #if ENABLED(G38_PROBE_TARGET)
   #include "gcode/probe/G38.h"
 #endif
 
 #if HAS_MESH
   #include "gcode/probe/G42.h"
 #endif
 
 #include "gcode/geometry/G92.h"
 
@@ -2373,24 +485,20 @@ static bool pin_is_protected(const int8_t pin) {
 #include "gcode/control/M42.h"
 
 #if ENABLED(PINS_DEBUGGING)
   #include "gcode/config/M43.h"
 #endif
 
 #if ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)
   #include "gcode/calibrate/M48.h"
 #endif
 
-#if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(UBL_G26_MESH_VALIDATION)
-  #include "gcode/calibrate/M49.h"
-#endif
-
 #include "gcode/stats/M75.h"
 #include "gcode/stats/M76.h"
 #include "gcode/stats/M77.h"
 
 #if ENABLED(PRINTCOUNTER)
   #include "gcode/stats/M78.h"
 #endif
 
 #include "gcode/temperature/M105.h"
 
@@ -2466,42 +574,20 @@ static bool pin_is_protected(const int8_t pin) {
 #include "gcode/control/M18_M84.h"
 
 #include "gcode/control/M85.h"
 
 #include "gcode/config/M92.h"
 
 #if ENABLED(M100_FREE_MEMORY_WATCHER)
   #include "gcode/calibrate/M100.h"
 #endif
 
-/**
- * Output the current position to serial
- */
-void report_current_position() {
-  SERIAL_PROTOCOLPGM("X:");
-  SERIAL_PROTOCOL(current_position[X_AXIS]);
-  SERIAL_PROTOCOLPGM(" Y:");
-  SERIAL_PROTOCOL(current_position[Y_AXIS]);
-  SERIAL_PROTOCOLPGM(" Z:");
-  SERIAL_PROTOCOL(current_position[Z_AXIS]);
-  SERIAL_PROTOCOLPGM(" E:");
-  SERIAL_PROTOCOL(current_position[E_AXIS]);
-
-  stepper.report_positions();
-
-  #if IS_SCARA
-    SERIAL_PROTOCOLPAIR("SCARA Theta:", stepper.get_axis_position_degrees(A_AXIS));
-    SERIAL_PROTOCOLLNPAIR("   Psi+Theta:", stepper.get_axis_position_degrees(B_AXIS));
-    SERIAL_EOL();
-  #endif
-}
-
 #include "gcode/host/M114.h"
 #include "gcode/host/M115.h"
 
 #include "gcode/lcd/M117.h"
 
 #include "gcode/host/M118.h"
 #include "gcode/host/M119.h"
 
 #include "gcode/control/M120_M121.h"
 
@@ -2594,44 +680,35 @@ void report_current_position() {
   #include "gcode/sensor/M407.h"
 #endif
 
 void quickstop_stepper() {
   stepper.quick_stop();
   stepper.synchronize();
   set_current_from_steppers_for_axis(ALL_AXES);
   SYNC_PLAN_POSITION_KINEMATIC();
 }
 
-#if HAS_LEVELING
-  #include "gcode/calibrate/M420.h"
-  #include "gcode/calibrate/M421.h"
-#endif
-
 #if HAS_M206_COMMAND
   #include "gcode/geometry/M428.h"
 #endif
 
 #include "gcode/eeprom/M500.h"
 #include "gcode/eeprom/M501.h"
 #include "gcode/eeprom/M502.h"
 #if DISABLED(DISABLE_M503)
   #include "gcode/eeprom/M503.h"
 #endif
 
 #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
   #include "gcode/config/M540.h"
 #endif
 
-#if HAS_BED_PROBE
-  #include "gcode/probe/M851.h"
-#endif
-
 #if ENABLED(ADVANCED_PAUSE_FEATURE)
   #include "gcode/feature/pause/M600.h"
 #endif
 
 #if ENABLED(MK2_MULTIPLEXER)
   #include "gcode/feature/snmm/M702.h"
 #endif
 
 #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
   #include "gcode/control/M605.h"
@@ -2678,389 +755,20 @@ void quickstop_stepper() {
   #endif
   #if ENABLED(DIRECT_MIXING_IN_G1)
     #include "gcode/feature/mixing/M165.h"
   #endif
 #endif
 
 #include "gcode/control/M999.h"
 
 #include "gcode/control/T.h"
 
-#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
-
-  #if ENABLED(ABL_BILINEAR_SUBDIVISION)
-    #define ABL_BG_SPACING(A) bilinear_grid_spacing_virt[A]
-    #define ABL_BG_FACTOR(A)  bilinear_grid_factor_virt[A]
-    #define ABL_BG_POINTS_X   ABL_GRID_POINTS_VIRT_X
-    #define ABL_BG_POINTS_Y   ABL_GRID_POINTS_VIRT_Y
-    #define ABL_BG_GRID(X,Y)  z_values_virt[X][Y]
-  #else
-    #define ABL_BG_SPACING(A) bilinear_grid_spacing[A]
-    #define ABL_BG_FACTOR(A)  bilinear_grid_factor[A]
-    #define ABL_BG_POINTS_X   GRID_MAX_POINTS_X
-    #define ABL_BG_POINTS_Y   GRID_MAX_POINTS_Y
-    #define ABL_BG_GRID(X,Y)  z_values[X][Y]
-  #endif
-
-  // Get the Z adjustment for non-linear bed leveling
-  float bilinear_z_offset(const float logical[XYZ]) {
-
-    static float z1, d2, z3, d4, L, D, ratio_x, ratio_y,
-                 last_x = -999.999, last_y = -999.999;
-
-    // Whole units for the grid line indices. Constrained within bounds.
-    static int8_t gridx, gridy, nextx, nexty,
-                  last_gridx = -99, last_gridy = -99;
-
-    // XY relative to the probed area
-    const float x = RAW_X_POSITION(logical[X_AXIS]) - bilinear_start[X_AXIS],
-                y = RAW_Y_POSITION(logical[Y_AXIS]) - bilinear_start[Y_AXIS];
-
-    #if ENABLED(EXTRAPOLATE_BEYOND_GRID)
-      // Keep using the last grid box
-      #define FAR_EDGE_OR_BOX 2
-    #else
-      // Just use the grid far edge
-      #define FAR_EDGE_OR_BOX 1
-    #endif
-
-    if (last_x != x) {
-      last_x = x;
-      ratio_x = x * ABL_BG_FACTOR(X_AXIS);
-      const float gx = constrain(FLOOR(ratio_x), 0, ABL_BG_POINTS_X - FAR_EDGE_OR_BOX);
-      ratio_x -= gx;      // Subtract whole to get the ratio within the grid box
-
-      #if DISABLED(EXTRAPOLATE_BEYOND_GRID)
-        // Beyond the grid maintain height at grid edges
-        NOLESS(ratio_x, 0); // Never < 0.0. (> 1.0 is ok when nextx==gridx.)
-      #endif
-
-      gridx = gx;
-      nextx = min(gridx + 1, ABL_BG_POINTS_X - 1);
-    }
-
-    if (last_y != y || last_gridx != gridx) {
-
-      if (last_y != y) {
-        last_y = y;
-        ratio_y = y * ABL_BG_FACTOR(Y_AXIS);
-        const float gy = constrain(FLOOR(ratio_y), 0, ABL_BG_POINTS_Y - FAR_EDGE_OR_BOX);
-        ratio_y -= gy;
-
-        #if DISABLED(EXTRAPOLATE_BEYOND_GRID)
-          // Beyond the grid maintain height at grid edges
-          NOLESS(ratio_y, 0); // Never < 0.0. (> 1.0 is ok when nexty==gridy.)
-        #endif
-
-        gridy = gy;
-        nexty = min(gridy + 1, ABL_BG_POINTS_Y - 1);
-      }
-
-      if (last_gridx != gridx || last_gridy != gridy) {
-        last_gridx = gridx;
-        last_gridy = gridy;
-        // Z at the box corners
-        z1 = ABL_BG_GRID(gridx, gridy);       // left-front
-        d2 = ABL_BG_GRID(gridx, nexty) - z1;  // left-back (delta)
-        z3 = ABL_BG_GRID(nextx, gridy);       // right-front
-        d4 = ABL_BG_GRID(nextx, nexty) - z3;  // right-back (delta)
-      }
-
-      // Bilinear interpolate. Needed since y or gridx has changed.
-                  L = z1 + d2 * ratio_y;   // Linear interp. LF -> LB
-      const float R = z3 + d4 * ratio_y;   // Linear interp. RF -> RB
-
-      D = R - L;
-    }
-
-    const float offset = L + ratio_x * D;   // the offset almost always changes
-
-    /*
-    static float last_offset = 0;
-    if (FABS(last_offset - offset) > 0.2) {
-      SERIAL_ECHOPGM("Sudden Shift at ");
-      SERIAL_ECHOPAIR("x=", x);
-      SERIAL_ECHOPAIR(" / ", bilinear_grid_spacing[X_AXIS]);
-      SERIAL_ECHOLNPAIR(" -> gridx=", gridx);
-      SERIAL_ECHOPAIR(" y=", y);
-      SERIAL_ECHOPAIR(" / ", bilinear_grid_spacing[Y_AXIS]);
-      SERIAL_ECHOLNPAIR(" -> gridy=", gridy);
-      SERIAL_ECHOPAIR(" ratio_x=", ratio_x);
-      SERIAL_ECHOLNPAIR(" ratio_y=", ratio_y);
-      SERIAL_ECHOPAIR(" z1=", z1);
-      SERIAL_ECHOPAIR(" z2=", z2);
-      SERIAL_ECHOPAIR(" z3=", z3);
-      SERIAL_ECHOLNPAIR(" z4=", z4);
-      SERIAL_ECHOPAIR(" L=", L);
-      SERIAL_ECHOPAIR(" R=", R);
-      SERIAL_ECHOLNPAIR(" offset=", offset);
-    }
-    last_offset = offset;
-    //*/
-
-    return offset;
-  }
-
-#endif // AUTO_BED_LEVELING_BILINEAR
-
-#if ENABLED(DELTA)
-
-  /**
-   * Recalculate factors used for delta kinematics whenever
-   * settings have been changed (e.g., by M665).
-   */
-  void recalc_delta_settings(float radius, float diagonal_rod) {
-    const float trt[ABC] = DELTA_RADIUS_TRIM_TOWER,
-                drt[ABC] = DELTA_DIAGONAL_ROD_TRIM_TOWER;
-    delta_tower[A_AXIS][X_AXIS] = cos(RADIANS(210 + delta_tower_angle_trim[A_AXIS])) * (radius + trt[A_AXIS]); // front left tower
-    delta_tower[A_AXIS][Y_AXIS] = sin(RADIANS(210 + delta_tower_angle_trim[A_AXIS])) * (radius + trt[A_AXIS]);
-    delta_tower[B_AXIS][X_AXIS] = cos(RADIANS(330 + delta_tower_angle_trim[B_AXIS])) * (radius + trt[B_AXIS]); // front right tower
-    delta_tower[B_AXIS][Y_AXIS] = sin(RADIANS(330 + delta_tower_angle_trim[B_AXIS])) * (radius + trt[B_AXIS]);
-    delta_tower[C_AXIS][X_AXIS] = 0.0; // back middle tower
-    delta_tower[C_AXIS][Y_AXIS] = (radius + trt[C_AXIS]);
-    delta_diagonal_rod_2_tower[A_AXIS] = sq(diagonal_rod + drt[A_AXIS]);
-    delta_diagonal_rod_2_tower[B_AXIS] = sq(diagonal_rod + drt[B_AXIS]);
-    delta_diagonal_rod_2_tower[C_AXIS] = sq(diagonal_rod + drt[C_AXIS]);
-  }
-
-  #if ENABLED(DELTA_FAST_SQRT) && defined(ARDUINO_ARCH_AVR)
-    /**
-     * Fast inverse sqrt from Quake III Arena
-     * See: https://en.wikipedia.org/wiki/Fast_inverse_square_root
-     */
-    float Q_rsqrt(float number) {
-      long i;
-      float x2, y;
-      const float threehalfs = 1.5f;
-      x2 = number * 0.5f;
-      y  = number;
-      i  = * ( long * ) &y;                       // evil floating point bit level hacking
-      i  = 0x5F3759DF - ( i >> 1 );               // what the f***?
-      y  = * ( float * ) &i;
-      y  = y * ( threehalfs - ( x2 * y * y ) );   // 1st iteration
-      // y  = y * ( threehalfs - ( x2 * y * y ) );   // 2nd iteration, this can be removed
-      return y;
-    }
-
-    #define _SQRT(n) (1.0f / Q_rsqrt(n))
-
-  #else
-
-    #define _SQRT(n) SQRT(n)
-
-  #endif
-
-  /**
-   * Delta Inverse Kinematics
-   *
-   * Calculate the tower positions for a given logical
-   * position, storing the result in the delta[] array.
-   *
-   * This is an expensive calculation, requiring 3 square
-   * roots per segmented linear move, and strains the limits
-   * of a Mega2560 with a Graphical Display.
-   *
-   * Suggested optimizations include:
-   *
-   * - Disable the home_offset (M206) and/or position_shift (G92)
-   *   features to remove up to 12 float additions.
-   *
-   * - Use a fast-inverse-sqrt function and add the reciprocal.
-   *   (see above)
-   */
-
-  // Macro to obtain the Z position of an individual tower
-  #define DELTA_Z(T) raw[Z_AXIS] + _SQRT(     \
-    delta_diagonal_rod_2_tower[T] - HYPOT2(   \
-        delta_tower[T][X_AXIS] - raw[X_AXIS], \
-        delta_tower[T][Y_AXIS] - raw[Y_AXIS]  \
-      )                                       \
-    )
-
-  #define DELTA_RAW_IK() do {        \
-    delta[A_AXIS] = DELTA_Z(A_AXIS); \
-    delta[B_AXIS] = DELTA_Z(B_AXIS); \
-    delta[C_AXIS] = DELTA_Z(C_AXIS); \
-  }while(0)
-
-  #define DELTA_LOGICAL_IK() do {      \
-    const float raw[XYZ] = {           \
-      RAW_X_POSITION(logical[X_AXIS]), \
-      RAW_Y_POSITION(logical[Y_AXIS]), \
-      RAW_Z_POSITION(logical[Z_AXIS])  \
-    };                                 \
-    DELTA_RAW_IK();                    \
-  }while(0)
-
-  #define DELTA_DEBUG() do { \
-      SERIAL_ECHOPAIR("cartesian X:", raw[X_AXIS]); \
-      SERIAL_ECHOPAIR(" Y:", raw[Y_AXIS]);          \
-      SERIAL_ECHOLNPAIR(" Z:", raw[Z_AXIS]);        \
-      SERIAL_ECHOPAIR("delta A:", delta[A_AXIS]);   \
-      SERIAL_ECHOPAIR(" B:", delta[B_AXIS]);        \
-      SERIAL_ECHOLNPAIR(" C:", delta[C_AXIS]);      \
-    }while(0)
-
-  void inverse_kinematics(const float logical[XYZ]) {
-    DELTA_LOGICAL_IK();
-    // DELTA_DEBUG();
-  }
-
-  /**
-   * Calculate the highest Z position where the
-   * effector has the full range of XY motion.
-   */
-  float delta_safe_distance_from_top() {
-    float cartesian[XYZ] = {
-      LOGICAL_X_POSITION(0),
-      LOGICAL_Y_POSITION(0),
-      LOGICAL_Z_POSITION(0)
-    };
-    inverse_kinematics(cartesian);
-    float distance = delta[A_AXIS];
-    cartesian[Y_AXIS] = LOGICAL_Y_POSITION(DELTA_PRINTABLE_RADIUS);
-    inverse_kinematics(cartesian);
-    return FABS(distance - delta[A_AXIS]);
-  }
-
-  /**
-   * Delta Forward Kinematics
-   *
-   * See the Wikipedia article "Trilateration"
-   * https://en.wikipedia.org/wiki/Trilateration
-   *
-   * Establish a new coordinate system in the plane of the
-   * three carriage points. This system has its origin at
-   * tower1, with tower2 on the X axis. Tower3 is in the X-Y
-   * plane with a Z component of zero.
-   * We will define unit vectors in this coordinate system
-   * in our original coordinate system. Then when we calculate
-   * the Xnew, Ynew and Znew values, we can translate back into
-   * the original system by moving along those unit vectors
-   * by the corresponding values.
-   *
-   * Variable names matched to Marlin, c-version, and avoid the
-   * use of any vector library.
-   *
-   * by Andreas Hardtung 2016-06-07
-   * based on a Java function from "Delta Robot Kinematics V3"
-   * by Steve Graves
-   *
-   * The result is stored in the cartes[] array.
-   */
-  void forward_kinematics_DELTA(float z1, float z2, float z3) {
-    // Create a vector in old coordinates along x axis of new coordinate
-    float p12[3] = { delta_tower[B_AXIS][X_AXIS] - delta_tower[A_AXIS][X_AXIS], delta_tower[B_AXIS][Y_AXIS] - delta_tower[A_AXIS][Y_AXIS], z2 - z1 };
-
-    // Get the Magnitude of vector.
-    float d = SQRT( sq(p12[0]) + sq(p12[1]) + sq(p12[2]) );
-
-    // Create unit vector by dividing by magnitude.
-    float ex[3] = { p12[0] / d, p12[1] / d, p12[2] / d };
-
-    // Get the vector from the origin of the new system to the third point.
-    float p13[3] = { delta_tower[C_AXIS][X_AXIS] - delta_tower[A_AXIS][X_AXIS], delta_tower[C_AXIS][Y_AXIS] - delta_tower[A_AXIS][Y_AXIS], z3 - z1 };
-
-    // Use the dot product to find the component of this vector on the X axis.
-    float i = ex[0] * p13[0] + ex[1] * p13[1] + ex[2] * p13[2];
-
-    // Create a vector along the x axis that represents the x component of p13.
-    float iex[3] = { ex[0] * i, ex[1] * i, ex[2] * i };
-
-    // Subtract the X component from the original vector leaving only Y. We use the
-    // variable that will be the unit vector after we scale it.
-    float ey[3] = { p13[0] - iex[0], p13[1] - iex[1], p13[2] - iex[2] };
-
-    // The magnitude of Y component
-    float j = SQRT( sq(ey[0]) + sq(ey[1]) + sq(ey[2]) );
-
-    // Convert to a unit vector
-    ey[0] /= j; ey[1] /= j;  ey[2] /= j;
-
-    // The cross product of the unit x and y is the unit z
-    // float[] ez = vectorCrossProd(ex, ey);
-    float ez[3] = {
-      ex[1] * ey[2] - ex[2] * ey[1],
-      ex[2] * ey[0] - ex[0] * ey[2],
-      ex[0] * ey[1] - ex[1] * ey[0]
-    };
-
-    // We now have the d, i and j values defined in Wikipedia.
-    // Plug them into the equations defined in Wikipedia for Xnew, Ynew and Znew
-    float Xnew = (delta_diagonal_rod_2_tower[A_AXIS] - delta_diagonal_rod_2_tower[B_AXIS] + sq(d)) / (d * 2),
-          Ynew = ((delta_diagonal_rod_2_tower[A_AXIS] - delta_diagonal_rod_2_tower[C_AXIS] + HYPOT2(i, j)) / 2 - i * Xnew) / j,
-          Znew = SQRT(delta_diagonal_rod_2_tower[A_AXIS] - HYPOT2(Xnew, Ynew));
-
-    // Start from the origin of the old coordinates and add vectors in the
-    // old coords that represent the Xnew, Ynew and Znew to find the point
-    // in the old system.
-    cartes[X_AXIS] = delta_tower[A_AXIS][X_AXIS] + ex[0] * Xnew + ey[0] * Ynew - ez[0] * Znew;
-    cartes[Y_AXIS] = delta_tower[A_AXIS][Y_AXIS] + ex[1] * Xnew + ey[1] * Ynew - ez[1] * Znew;
-    cartes[Z_AXIS] =             z1 + ex[2] * Xnew + ey[2] * Ynew - ez[2] * Znew;
-  }
-
-  void forward_kinematics_DELTA(float point[ABC]) {
-    forward_kinematics_DELTA(point[A_AXIS], point[B_AXIS], point[C_AXIS]);
-  }
-
-#endif // DELTA
-
-/**
- * Get the stepper positions in the cartes[] array.
- * Forward kinematics are applied for DELTA and SCARA.
- *
- * The result is in the current coordinate space with
- * leveling applied. The coordinates need to be run through
- * unapply_leveling to obtain the "ideal" coordinates
- * suitable for current_position, etc.
- */
-void get_cartesian_from_steppers() {
-  #if ENABLED(DELTA)
-    forward_kinematics_DELTA(
-      stepper.get_axis_position_mm(A_AXIS),
-      stepper.get_axis_position_mm(B_AXIS),
-      stepper.get_axis_position_mm(C_AXIS)
-    );
-    cartes[X_AXIS] += LOGICAL_X_POSITION(0);
-    cartes[Y_AXIS] += LOGICAL_Y_POSITION(0);
-    cartes[Z_AXIS] += LOGICAL_Z_POSITION(0);
-  #elif IS_SCARA
-    forward_kinematics_SCARA(
-      stepper.get_axis_position_degrees(A_AXIS),
-      stepper.get_axis_position_degrees(B_AXIS)
-    );
-    cartes[X_AXIS] += LOGICAL_X_POSITION(0);
-    cartes[Y_AXIS] += LOGICAL_Y_POSITION(0);
-    cartes[Z_AXIS] = stepper.get_axis_position_mm(Z_AXIS);
-  #else
-    cartes[X_AXIS] = stepper.get_axis_position_mm(X_AXIS);
-    cartes[Y_AXIS] = stepper.get_axis_position_mm(Y_AXIS);
-    cartes[Z_AXIS] = stepper.get_axis_position_mm(Z_AXIS);
-  #endif
-}
-
-/**
- * Set the current_position for an axis based on
- * the stepper positions, removing any leveling that
- * may have been applied.
- */
-void set_current_from_steppers_for_axis(const AxisEnum axis) {
-  get_cartesian_from_steppers();
-  #if PLANNER_LEVELING
-    planner.unapply_leveling(cartes);
-  #endif
-  if (axis == ALL_AXES)
-    COPY(current_position, cartes);
-  else
-    current_position[axis] = cartes[axis];
-}
-
 #if ENABLED(USE_CONTROLLER_FAN)
 
   void controllerFan() {
     static millis_t lastMotorOn = 0, // Last time a motor was turned on
                     nextMotorCheck = 0; // Last time the state was checked
     const millis_t ms = millis();
     if (ELAPSED(ms, nextMotorCheck)) {
       nextMotorCheck = ms + 2500UL; // Not a time critical function, so only check every 2.5s
       if (X_ENABLE_READ == X_ENABLE_ON || Y_ENABLE_READ == Y_ENABLE_ON || Z_ENABLE_READ == Z_ENABLE_ON || thermalManager.soft_pwm_amount_bed > 0
           || E0_ENABLE_READ == E_ENABLE_ON // If any of the drivers are enabled...
@@ -3087,101 +795,20 @@ void set_current_from_steppers_for_axis(const AxisEnum axis) {
       uint8_t speed = (!lastMotorOn || ELAPSED(ms, lastMotorOn + (CONTROLLERFAN_SECS) * 1000UL)) ? 0 : CONTROLLERFAN_SPEED;
 
       // allows digital or PWM fan output to be used (see M42 handling)
       WRITE(CONTROLLER_FAN_PIN, speed);
       analogWrite(CONTROLLER_FAN_PIN, speed);
     }
   }
 
 #endif // USE_CONTROLLER_FAN
 
-#if ENABLED(MORGAN_SCARA)
-
-  /**
-   * Morgan SCARA Forward Kinematics. Results in cartes[].
-   * Maths and first version by QHARLEY.
-   * Integrated into Marlin and slightly restructured by Joachim Cerny.
-   */
-  void forward_kinematics_SCARA(const float &a, const float &b) {
-
-    float a_sin = sin(RADIANS(a)) * L1,
-          a_cos = cos(RADIANS(a)) * L1,
-          b_sin = sin(RADIANS(b)) * L2,
-          b_cos = cos(RADIANS(b)) * L2;
-
-    cartes[X_AXIS] = a_cos + b_cos + SCARA_OFFSET_X;  //theta
-    cartes[Y_AXIS] = a_sin + b_sin + SCARA_OFFSET_Y;  //theta+phi
-
-    /*
-      SERIAL_ECHOPAIR("SCARA FK Angle a=", a);
-      SERIAL_ECHOPAIR(" b=", b);
-      SERIAL_ECHOPAIR(" a_sin=", a_sin);
-      SERIAL_ECHOPAIR(" a_cos=", a_cos);
-      SERIAL_ECHOPAIR(" b_sin=", b_sin);
-      SERIAL_ECHOLNPAIR(" b_cos=", b_cos);
-      SERIAL_ECHOPAIR(" cartes[X_AXIS]=", cartes[X_AXIS]);
-      SERIAL_ECHOLNPAIR(" cartes[Y_AXIS]=", cartes[Y_AXIS]);
-    //*/
-  }
-
-  /**
-   * Morgan SCARA Inverse Kinematics. Results in delta[].
-   *
-   * See http://forums.reprap.org/read.php?185,283327
-   *
-   * Maths and first version by QHARLEY.
-   * Integrated into Marlin and slightly restructured by Joachim Cerny.
-   */
-  void inverse_kinematics(const float logical[XYZ]) {
-
-    static float C2, S2, SK1, SK2, THETA, PSI;
-
-    float sx = RAW_X_POSITION(logical[X_AXIS]) - SCARA_OFFSET_X,  // Translate SCARA to standard X Y
-          sy = RAW_Y_POSITION(logical[Y_AXIS]) - SCARA_OFFSET_Y;  // With scaling factor.
-
-    if (L1 == L2)
-      C2 = HYPOT2(sx, sy) / L1_2_2 - 1;
-    else
-      C2 = (HYPOT2(sx, sy) - (L1_2 + L2_2)) / (2.0 * L1 * L2);
-
-    S2 = SQRT(1 - sq(C2));
-
-    // Unrotated Arm1 plus rotated Arm2 gives the distance from Center to End
-    SK1 = L1 + L2 * C2;
-
-    // Rotated Arm2 gives the distance from Arm1 to Arm2
-    SK2 = L2 * S2;
-
-    // Angle of Arm1 is the difference between Center-to-End angle and the Center-to-Elbow
-    THETA = ATAN2(SK1, SK2) - ATAN2(sx, sy);
-
-    // Angle of Arm2
-    PSI = ATAN2(S2, C2);
-
-    delta[A_AXIS] = DEGREES(THETA);        // theta is support arm angle
-    delta[B_AXIS] = DEGREES(THETA + PSI);  // equal to sub arm angle (inverted motor)
-    delta[C_AXIS] = logical[Z_AXIS];
-
-    /*
-      DEBUG_POS("SCARA IK", logical);
-      DEBUG_POS("SCARA IK", delta);
-      SERIAL_ECHOPAIR("  SCARA (x,y) ", sx);
-      SERIAL_ECHOPAIR(",", sy);
-      SERIAL_ECHOPAIR(" C2=", C2);
-      SERIAL_ECHOPAIR(" S2=", S2);
-      SERIAL_ECHOPAIR(" Theta=", THETA);
-      SERIAL_ECHOLNPAIR(" Phi=", PHI);
-    //*/
-  }
-
-#endif // MORGAN_SCARA
-
 #if ENABLED(TEMP_STAT_LEDS)
 
   static bool red_led = false;
   static millis_t next_status_led_update_ms = 0;
 
   void handle_status_leds(void) {
     if (ELAPSED(millis(), next_status_led_update_ms)) {
       next_status_led_update_ms += 500; // Update every 0.5s
       float max_temp = 0.0;
       #if HAS_TEMP_BED
@@ -3298,21 +925,21 @@ void manage_inactivity(bool ignore_stepper_queue/*=false*/) {
     #if ENABLED(DISABLE_INACTIVE_Y)
       disable_Y();
     #endif
     #if ENABLED(DISABLE_INACTIVE_Z)
       disable_Z();
     #endif
     #if ENABLED(DISABLE_INACTIVE_E)
       disable_e_steppers();
     #endif
     #if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(ULTRA_LCD)  // Only needed with an LCD
-      ubl_lcd_map_control = defer_return_to_status = false;
+      ubl.lcd_map_control = defer_return_to_status = false;
     #endif
   }
 
   #ifdef CHDK // Check if pin should be set to LOW after M240 set it to HIGH
     if (chdkActive && ELAPSED(ms, chdkHigh + CHDK_DELAY)) {
       chdkActive = false;
       WRITE(CHDK, LOW);
     }
   #endif
 
@@ -3634,21 +1261,24 @@ void setup() {
   #else
     ZERO(current_position);
   #endif
 
   // Vital to init stepper/planner equivalent for current_position
   SYNC_PLAN_POSITION_KINEMATIC();
 
   thermalManager.init();    // Initialize temperature loop
 
   stepper.init();    // Initialize stepper, this enables interrupts!
-  servo_init();
+
+  #if HAS_SERVOS
+    servo_init();
+  #endif
 
   #if HAS_PHOTOGRAPH
     OUT_WRITE(PHOTOGRAPH_PIN, LOW);
   #endif
 
   #if HAS_CASE_LIGHT
     case_light_on = CASE_LIGHT_DEFAULT_ON;
     case_light_brightness = CASE_LIGHT_DEFAULT_BRIGHTNESS;
     update_case_light();
   #endif
@@ -3748,24 +1378,21 @@ void setup() {
   #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
     // Initialize mixing to 100% color 1
     for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
       mixing_factor[i] = (i == 0) ? 1.0 : 0.0;
     for (uint8_t t = 0; t < MIXING_VIRTUAL_TOOLS; t++)
       for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
         mixing_virtual_tool_mix[t][i] = mixing_factor[i];
   #endif
 
   #if ENABLED(BLTOUCH)
-    // Make sure any BLTouch error condition is cleared
-    bltouch_command(BLTOUCH_RESET);
-    set_bltouch_deployed(true);
-    set_bltouch_deployed(false);
+    bltouch_init();
   #endif
 
   #if ENABLED(I2C_POSITION_ENCODERS)
     I2CPEM.init();
   #endif
 
   #if ENABLED(EXPERIMENTAL_I2CBUS) && I2C_SLAVE_ADDRESS > 0
     i2c.onReceive(i2c_on_receive);
     i2c.onRequest(i2c_on_request);
   #endif

commit 71aefc2e2250744b96f351e0b3b57f68c54fe1ab
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 16 04:44:37 2017 -0500

    Move heater output to Temperature class

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 36c5b880d3..c9c5505857 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -2385,106 +2385,31 @@ static bool pin_is_protected(const int8_t pin) {
 #endif
 
 #include "gcode/stats/M75.h"
 #include "gcode/stats/M76.h"
 #include "gcode/stats/M77.h"
 
 #if ENABLED(PRINTCOUNTER)
   #include "gcode/stats/M78.h"
 #endif
 
-#if HAS_TEMP_HOTEND || HAS_TEMP_BED
-
-  void print_heater_state(const float &c, const float &t,
-    #if ENABLED(SHOW_TEMP_ADC_VALUES)
-      const float r,
-    #endif
-    const int8_t e=-2
-  ) {
-    #if !(HAS_TEMP_BED && HAS_TEMP_HOTEND) && HOTENDS <= 1
-      UNUSED(e);
-    #endif
-
-    SERIAL_PROTOCOLCHAR(' ');
-    SERIAL_PROTOCOLCHAR(
-      #if HAS_TEMP_BED && HAS_TEMP_HOTEND
-        e == -1 ? 'B' : 'T'
-      #elif HAS_TEMP_HOTEND
-        'T'
-      #else
-        'B'
-      #endif
-    );
-    #if HOTENDS > 1
-      if (e >= 0) SERIAL_PROTOCOLCHAR('0' + e);
-    #endif
-    SERIAL_PROTOCOLCHAR(':');
-    SERIAL_PROTOCOL(c);
-    SERIAL_PROTOCOLPAIR(" /" , t);
-    #if ENABLED(SHOW_TEMP_ADC_VALUES)
-      SERIAL_PROTOCOLPAIR(" (", r / OVERSAMPLENR);
-      SERIAL_PROTOCOLCHAR(')');
-    #endif
-  }
-
-  void print_heaterstates() {
-    #if HAS_TEMP_HOTEND
-      print_heater_state(thermalManager.degHotend(gcode.target_extruder), thermalManager.degTargetHotend(gcode.target_extruder)
-        #if ENABLED(SHOW_TEMP_ADC_VALUES)
-          , thermalManager.rawHotendTemp(gcode.target_extruder)
-        #endif
-      );
-    #endif
-    #if HAS_TEMP_BED
-      print_heater_state(thermalManager.degBed(), thermalManager.degTargetBed(),
-        #if ENABLED(SHOW_TEMP_ADC_VALUES)
-          thermalManager.rawBedTemp(),
-        #endif
-        -1 // BED
-      );
-    #endif
-    #if HOTENDS > 1
-      HOTEND_LOOP() print_heater_state(thermalManager.degHotend(e), thermalManager.degTargetHotend(e),
-        #if ENABLED(SHOW_TEMP_ADC_VALUES)
-          thermalManager.rawHotendTemp(e),
-        #endif
-        e
-      );
-    #endif
-    SERIAL_PROTOCOLPGM(" @:");
-    SERIAL_PROTOCOL(thermalManager.getHeaterPower(gcode.target_extruder));
-    #if HAS_TEMP_BED
-      SERIAL_PROTOCOLPGM(" B@:");
-      SERIAL_PROTOCOL(thermalManager.getHeaterPower(-1));
-    #endif
-    #if HOTENDS > 1
-      HOTEND_LOOP() {
-        SERIAL_PROTOCOLPAIR(" @", e);
-        SERIAL_PROTOCOLCHAR(':');
-        SERIAL_PROTOCOL(thermalManager.getHeaterPower(e));
-      }
-    #endif
-  }
-
-#endif // HAS_TEMP_HOTEND || HAS_TEMP_BED
-
 #include "gcode/temperature/M105.h"
 
 #if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND || HAS_TEMP_BED)
 
   static uint8_t auto_report_temp_interval;
   static millis_t next_temp_report_ms;
 
   inline void auto_report_temperatures() {
     if (auto_report_temp_interval && ELAPSED(millis(), next_temp_report_ms)) {
       next_temp_report_ms = millis() + 1000UL * auto_report_temp_interval;
-      print_heaterstates();
+      thermalManager.print_heaterstates();
       SERIAL_EOL();
     }
   }
 
   #include "gcode/temperature/M155.h"
 
 #endif // AUTO_REPORT_TEMPERATURES && (HAS_TEMP_HOTEND || HAS_TEMP_BED)
 
 #if FAN_COUNT > 0
   #include "gcode/temperature/M106.h"

commit 63228fc45355232ba2c6a7838666ed76958623f0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 16 11:41:12 2017 -0500

    Move volumetric flag to GCodeParser

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index f93f3115df..36c5b880d3 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -162,21 +162,20 @@ static const float homing_feedrate_mm_s[] PROGMEM = {
     MMM_TO_MMS(HOMING_FEEDRATE_XY), MMM_TO_MMS(HOMING_FEEDRATE_XY),
   #endif
   MMM_TO_MMS(HOMING_FEEDRATE_Z), 0
 };
 FORCE_INLINE float homing_feedrate(const AxisEnum a) { return pgm_read_float(&homing_feedrate_mm_s[a]); }
 
 static float saved_feedrate_mm_s;
 int16_t feedrate_percentage = 100, saved_feedrate_percentage;
 
 // Initialized by settings.load()
-bool volumetric_enabled;
 float filament_size[EXTRUDERS], volumetric_multiplier[EXTRUDERS];
 
 #if HAS_WORKSPACE_OFFSET
   #if HAS_POSITION_SHIFT
     // The distance that XYZ has been offset by G92. Reset by G28.
     float position_shift[XYZ] = { 0 };
   #endif
   #if HAS_HOME_OFFSET
     // This offset is added to the configured home position.
     // Set by M206, M428, or menu item. Saved to EEPROM.
@@ -3288,21 +3287,21 @@ void set_current_from_steppers_for_axis(const AxisEnum axis) {
     if (!filament_ran_out) {
       filament_ran_out = true;
       enqueue_and_echo_commands_P(PSTR(FILAMENT_RUNOUT_SCRIPT));
       stepper.synchronize();
     }
   }
 
 #endif // FILAMENT_RUNOUT_SENSOR
 
 float calculate_volumetric_multiplier(const float diameter) {
-  if (!volumetric_enabled || diameter == 0) return 1.0;
+  if (!parser.volumetric_enabled || diameter == 0) return 1.0;
   return 1.0 / (M_PI * sq(diameter * 0.5));
 }
 
 void calculate_volumetric_multipliers() {
   for (uint8_t i = 0; i < COUNT(filament_size); i++)
     volumetric_multiplier[i] = calculate_volumetric_multiplier(filament_size[i]);
 }
 
 void enable_all_steppers() {
   enable_X();

commit bf7af95db361d57e844894278fcb0a5d5ea4eba5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Sep 8 23:50:46 2017 -0500

    Move flow_percentage to Planner

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 10c223849a..f93f3115df 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -159,22 +159,21 @@ static const float homing_feedrate_mm_s[] PROGMEM = {
   #if ENABLED(DELTA)
     MMM_TO_MMS(HOMING_FEEDRATE_Z), MMM_TO_MMS(HOMING_FEEDRATE_Z),
   #else
     MMM_TO_MMS(HOMING_FEEDRATE_XY), MMM_TO_MMS(HOMING_FEEDRATE_XY),
   #endif
   MMM_TO_MMS(HOMING_FEEDRATE_Z), 0
 };
 FORCE_INLINE float homing_feedrate(const AxisEnum a) { return pgm_read_float(&homing_feedrate_mm_s[a]); }
 
 static float saved_feedrate_mm_s;
-int16_t feedrate_percentage = 100, saved_feedrate_percentage,
-    flow_percentage[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(100);
+int16_t feedrate_percentage = 100, saved_feedrate_percentage;
 
 // Initialized by settings.load()
 bool volumetric_enabled;
 float filament_size[EXTRUDERS], volumetric_multiplier[EXTRUDERS];
 
 #if HAS_WORKSPACE_OFFSET
   #if HAS_POSITION_SHIFT
     // The distance that XYZ has been offset by G92. Reset by G28.
     float position_shift[XYZ] = { 0 };
   #endif

commit 8dc2838d985cabe3a5e53cf989056084f5674043
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Sep 8 23:49:49 2017 -0500

    Move host keepalive to GcodeSuite

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 38801990f6..10c223849a 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -346,28 +346,20 @@ float cartes[XYZ] = { 0 };
 
 #ifdef CHDK
   millis_t chdkHigh = 0;
   bool chdkActive = false;
 #endif
 
 #if ENABLED(PID_EXTRUSION_SCALING)
   int lpq_len = 20;
 #endif
 
-#if ENABLED(HOST_KEEPALIVE_FEATURE)
-  MarlinBusyState busy_state = NOT_BUSY;
-  static millis_t next_busy_signal_ms = 0;
-  uint8_t host_keepalive_interval = DEFAULT_KEEPALIVE_INTERVAL;
-#else
-  #define host_keepalive() NOOP
-#endif
-
 #if ENABLED(I2C_POSITION_ENCODERS)
   I2CPositionEncodersMgr I2CPEM;
   uint8_t blockBufferIndexRef = 0;
   millis_t lastUpdateMillis;
 #endif
 
 #if ENABLED(CNC_WORKSPACE_PLANES)
   static WorkspacePlane workspace_plane = PLANE_XY;
 #endif
 
@@ -2238,60 +2230,20 @@ static void homeaxis(const AxisEnum axis) {
       if (mix_bits) {
         for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
           if (!TEST(mix_bits, i)) mixing_factor[i] = 0.0;
         normalize_mix();
       }
     }
   #endif
 
 #endif
 
-/**
- * ***************************************************************************
- * ***************************** G-CODE HANDLING *****************************
- * ***************************************************************************
- */
-
-#if ENABLED(HOST_KEEPALIVE_FEATURE)
-
-  /**
-   * Output a "busy" message at regular intervals
-   * while the machine is not accepting commands.
-   */
-  void host_keepalive() {
-    const millis_t ms = millis();
-    if (host_keepalive_interval && busy_state != NOT_BUSY) {
-      if (PENDING(ms, next_busy_signal_ms)) return;
-      switch (busy_state) {
-        case IN_HANDLER:
-        case IN_PROCESS:
-          SERIAL_ECHO_START();
-          SERIAL_ECHOLNPGM(MSG_BUSY_PROCESSING);
-          break;
-        case PAUSED_FOR_USER:
-          SERIAL_ECHO_START();
-          SERIAL_ECHOLNPGM(MSG_BUSY_PAUSED_FOR_USER);
-          break;
-        case PAUSED_FOR_INPUT:
-          SERIAL_ECHO_START();
-          SERIAL_ECHOLNPGM(MSG_BUSY_PAUSED_FOR_INPUT);
-          break;
-        default:
-          break;
-      }
-    }
-    next_busy_signal_ms = ms + host_keepalive_interval * 1000UL;
-  }
-
-#endif // HOST_KEEPALIVE_FEATURE
-
-
 /**************************************************
  ***************** GCode Handlers *****************
  **************************************************/
 
 #if ENABLED(ARC_SUPPORT)
   #include "gcode/motion/G2_G3.h"
 #endif
 
 void dwell(millis_t time) {
   gcode.refresh_cmd_timeout();
@@ -3567,21 +3519,23 @@ void idle(
   #if ENABLED(ADVANCED_PAUSE_FEATURE)
     bool no_stepper_sleep/*=false*/
   #endif
 ) {
   #if ENABLED(MAX7219_DEBUG)
     Max7219_idle_tasks();
   #endif  // MAX7219_DEBUG
 
   lcd_update();
 
-  host_keepalive();
+  #if ENABLED(HOST_KEEPALIVE_FEATURE)
+    gcode.host_keepalive();
+  #endif
 
   #if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND || HAS_TEMP_BED)
     auto_report_temperatures();
   #endif
 
   manage_inactivity(
     #if ENABLED(ADVANCED_PAUSE_FEATURE)
       no_stepper_sleep
     #endif
   );

commit 8fbb833de9309c53abb73dba7d33b76f0068c61a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Sep 8 14:47:47 2017 -0500

    Encapsulate RGB(W) LEDs

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 25cb734441..38801990f6 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -64,33 +64,25 @@
 
 #if (ENABLED(SWITCHING_EXTRUDER) && !DONT_SWITCH) || ENABLED(SWITCHING_NOZZLE)
   #include "module/tool_change.h"
 #endif
 
 #if ENABLED(BEZIER_CURVE_SUPPORT)
   #include "module/planner_bezier.h"
 #endif
 
 #if ENABLED(MAX7219_DEBUG)
-  #include "feature/leds/Max7219_Debug_LEDs.h"
+  #include "feature/Max7219_Debug_LEDs.h"
 #endif
 
-#if ENABLED(NEOPIXEL_RGBW_LED)
-  #include <Adafruit_NeoPixel.h>
-#endif
-
-#if ENABLED(BLINKM)
-  #include "feature/leds/blinkm.h"
-#endif
-
-#if ENABLED(PCA9632)
-  #include "feature/leds/pca9632.h"
+#if HAS_COLOR_LEDS
+  #include "feature/leds/leds.h"
 #endif
 
 #if HAS_SERVOS
   #include "HAL/servo.h"
 #endif
 
 #if HAS_DIGIPOTSS
   #include <SPI.h>
 #endif
 
@@ -485,110 +477,20 @@ void servo_init() {
   void i2c_on_receive(int bytes) { // just echo all bytes received to serial
     i2c.receive(bytes);
   }
 
   void i2c_on_request() {          // just send dummy data for now
     i2c.reply("Hello World!\n");
   }
 
 #endif
 
-#if HAS_COLOR_LEDS
-
-  #if ENABLED(NEOPIXEL_RGBW_LED)
-
-    Adafruit_NeoPixel pixels(NEOPIXEL_PIXELS, NEOPIXEL_PIN, NEO_GRBW + NEO_KHZ800);
-
-    void set_neopixel_color(const uint32_t color) {
-      for (uint16_t i = 0; i < pixels.numPixels(); ++i)
-        pixels.setPixelColor(i, color);
-      pixels.show();
-    }
-
-    void setup_neopixel() {
-      pixels.setBrightness(255); // 0 - 255 range
-      pixels.begin();
-      pixels.show(); // initialize to all off
-
-      #if ENABLED(NEOPIXEL_STARTUP_TEST)
-        delay(2000);
-        set_neopixel_color(pixels.Color(255, 0, 0, 0));  // red
-        delay(2000);
-        set_neopixel_color(pixels.Color(0, 255, 0, 0));  // green
-        delay(2000);
-        set_neopixel_color(pixels.Color(0, 0, 255, 0));  // blue
-        delay(2000);
-      #endif
-      set_neopixel_color(pixels.Color(0, 0, 0, 255));    // white
-    }
-
-  #endif // NEOPIXEL_RGBW_LED
-
-  void set_led_color(
-    const uint8_t r, const uint8_t g, const uint8_t b
-      #if ENABLED(RGBW_LED) || ENABLED(NEOPIXEL_RGBW_LED)
-        , const uint8_t w = 0
-        #if ENABLED(NEOPIXEL_RGBW_LED)
-          , bool isSequence = false
-        #endif
-      #endif
-  ) {
-
-    #if ENABLED(NEOPIXEL_RGBW_LED)
-
-      const uint32_t color = pixels.Color(r, g, b, w);
-      static uint16_t nextLed = 0;
-
-      if (!isSequence)
-        set_neopixel_color(color);
-      else {
-        pixels.setPixelColor(nextLed, color);
-        pixels.show();
-        if (++nextLed >= pixels.numPixels()) nextLed = 0;
-        return;
-      }
-
-    #endif
-
-    #if ENABLED(BLINKM)
-
-      // This variant uses i2c to send the RGB components to the device.
-      SendColors(r, g, b);
-
-    #endif
-
-    #if ENABLED(RGB_LED) || ENABLED(RGBW_LED)
-
-      // This variant uses 3 separate pins for the RGB components.
-      // If the pins can do PWM then their intensity will be set.
-      WRITE(RGB_LED_R_PIN, r ? HIGH : LOW);
-      WRITE(RGB_LED_G_PIN, g ? HIGH : LOW);
-      WRITE(RGB_LED_B_PIN, b ? HIGH : LOW);
-      analogWrite(RGB_LED_R_PIN, r);
-      analogWrite(RGB_LED_G_PIN, g);
-      analogWrite(RGB_LED_B_PIN, b);
-
-      #if ENABLED(RGBW_LED)
-        WRITE(RGB_LED_W_PIN, w ? HIGH : LOW);
-        analogWrite(RGB_LED_W_PIN, w);
-      #endif
-
-    #endif
-
-    #if ENABLED(PCA9632)
-      // Update I2C LED driver
-      PCA9632_SetColor(r, g, b);
-    #endif
-  }
-
-#endif // HAS_COLOR_LEDS
-
 #if HAS_WORKSPACE_OFFSET || ENABLED(DUAL_X_CARRIAGE)
 
   /**
    * Software endstops can be used to monitor the open end of
    * an axis that has a hardware endstop on the other end. Or
    * they can prevent axes from moving past endstops and grinding.
    *
    * To keep doing their job as the coordinate system changes,
    * the software endstop positions must be refreshed to remain
    * at the same positions relative to the machine.

commit a98e9874dbf24a73874ecbda86b5fe739a8223d0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Sep 7 22:40:32 2017 -0500

    FWRETRACT as a feature

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index dcd8599af0..25cb734441 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -265,38 +265,20 @@ static millis_t stepper_inactive_time = (DEFAULT_STEPPER_DEACTIVE_TIME) * 1000UL
 
 #if HAS_Z_SERVO_ENDSTOP
   const int z_servo_angle[2] = Z_SERVO_ANGLES;
 #endif
 
 #if ENABLED(BARICUDA)
   uint8_t baricuda_valve_pressure = 0,
           baricuda_e_to_p_pressure = 0;
 #endif
 
-#if ENABLED(FWRETRACT)                      // Initialized by settings.load()...
-  bool autoretract_enabled,                 // M209 S - Autoretract switch
-       retracted[EXTRUDERS] = { false };    // Which extruders are currently retracted
-  float retract_length,                     // M207 S - G10 Retract length
-        retract_feedrate_mm_s,              // M207 F - G10 Retract feedrate
-        retract_zlift,                      // M207 Z - G10 Retract hop size
-        retract_recover_length,             // M208 S - G11 Recover length
-        retract_recover_feedrate_mm_s,      // M208 F - G11 Recover feedrate
-        swap_retract_length,                // M207 W - G10 Swap Retract length
-        swap_retract_recover_length,        // M208 W - G11 Swap Recover length
-        swap_retract_recover_feedrate_mm_s; // M208 R - G11 Swap Recover feedrate
-  #if EXTRUDERS > 1
-    bool retracted_swap[EXTRUDERS] = { false }; // Which extruders are swap-retracted
-  #else
-    constexpr bool retracted_swap[1] = { false };
-  #endif
-#endif // FWRETRACT
-
 #if HAS_POWER_SWITCH
   bool powersupply_on =
     #if ENABLED(PS_DEFAULT_OFF)
       false
     #else
       true
     #endif
   ;
 #endif
 
@@ -2315,146 +2297,20 @@ static void homeaxis(const AxisEnum axis) {
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) {
       SERIAL_ECHOPAIR("<<< homeaxis(", axis_codes[axis]);
       SERIAL_CHAR(')');
       SERIAL_EOL();
     }
   #endif
 } // homeaxis()
 
-#if ENABLED(FWRETRACT)
-
-  /**
-   * Retract or recover according to firmware settings
-   *
-   * This function handles retract/recover moves for G10 and G11,
-   * plus auto-retract moves sent from G0/G1 when E-only moves are done.
-   *
-   * To simplify the logic, doubled retract/recover moves are ignored.
-   *
-   * Note: Z lift is done transparently to the planner. Aborting
-   *       a print between G10 and G11 may corrupt the Z position.
-   *
-   * Note: Auto-retract will apply the set Z hop in addition to any Z hop
-   *       included in the G-code. Use M207 Z0 to to prevent double hop.
-   */
-  void retract(const bool retracting
-    #if EXTRUDERS > 1
-      , bool swapping = false
-    #endif
-  ) {
-
-    static float hop_height,        // Remember where the Z height started
-                 hop_amount = 0.0;  // Total amount lifted, for use in recover
-
-    // Simply never allow two retracts or recovers in a row
-    if (retracted[active_extruder] == retracting) return;
-
-    #if EXTRUDERS < 2
-      bool swapping = false;
-    #endif
-    if (!retracting) swapping = retracted_swap[active_extruder];
-
-    /* // debugging
-      SERIAL_ECHOLNPAIR("retracting ", retracting);
-      SERIAL_ECHOLNPAIR("swapping ", swapping);
-      SERIAL_ECHOLNPAIR("active extruder ", active_extruder);
-      for (uint8_t i = 0; i < EXTRUDERS; ++i) {
-        SERIAL_ECHOPAIR("retracted[", i);
-        SERIAL_ECHOLNPAIR("] ", retracted[i]);
-        SERIAL_ECHOPAIR("retracted_swap[", i);
-        SERIAL_ECHOLNPAIR("] ", retracted_swap[i]);
-      }
-      SERIAL_ECHOLNPAIR("current_position[z] ", current_position[Z_AXIS]);
-      SERIAL_ECHOLNPAIR("hop_amount ", hop_amount);
-    //*/
-
-    const bool has_zhop = retract_zlift > 0.01;     // Is there a hop set?
-
-    const float old_feedrate_mm_s = feedrate_mm_s;
-    const int16_t old_flow = flow_percentage[active_extruder];
-
-    // Don't apply flow multiplication to retract/recover
-    flow_percentage[active_extruder] = 100;
-
-    // The current position will be the destination for E and Z moves
-    set_destination_to_current();
-
-    if (retracting) {
-      // Remember the Z height since G-code may include its own Z-hop
-      // For best results turn off Z hop if G-code already includes it
-      hop_height = destination[Z_AXIS];
-
-      // Retract by moving from a faux E position back to the current E position
-      feedrate_mm_s = retract_feedrate_mm_s;
-      current_position[E_AXIS] += (swapping ? swap_retract_length : retract_length) / volumetric_multiplier[active_extruder];
-      sync_plan_position_e();
-      prepare_move_to_destination();
-
-      // Is a Z hop set, and has the hop not yet been done?
-      if (has_zhop) {
-        hop_amount += retract_zlift;                // Carriage is raised for retraction hop
-        current_position[Z_AXIS] -= retract_zlift;  // Pretend current pos is lower. Next move raises Z.
-        SYNC_PLAN_POSITION_KINEMATIC();             // Set the planner to the new position
-        prepare_move_to_destination();              // Raise up to the old current pos
-      }
-    }
-    else {
-      // If a hop was done and Z hasn't changed, undo the Z hop
-      if (hop_amount && NEAR(hop_height, destination[Z_AXIS])) {
-        current_position[Z_AXIS] += hop_amount;     // Pretend current pos is higher. Next move lowers Z.
-        SYNC_PLAN_POSITION_KINEMATIC();             // Set the planner to the new position
-        prepare_move_to_destination();              // Lower to the old current pos
-        hop_amount = 0.0;
-      }
-
-      // A retract multiplier has been added here to get faster swap recovery
-      feedrate_mm_s = swapping ? swap_retract_recover_feedrate_mm_s : retract_recover_feedrate_mm_s;
-
-      const float move_e = swapping ? swap_retract_length + swap_retract_recover_length : retract_length + retract_recover_length;
-      current_position[E_AXIS] -= move_e / volumetric_multiplier[active_extruder];
-      sync_plan_position_e();
-
-      prepare_move_to_destination();  // Recover E
-    }
-
-    // Restore flow and feedrate
-    flow_percentage[active_extruder] = old_flow;
-    feedrate_mm_s = old_feedrate_mm_s;
-
-    // The active extruder is now retracted or recovered
-    retracted[active_extruder] = retracting;
-
-    // If swap retract/recover then update the retracted_swap flag too
-    #if EXTRUDERS > 1
-      if (swapping) retracted_swap[active_extruder] = retracting;
-    #endif
-
-    /* // debugging
-      SERIAL_ECHOLNPAIR("retracting ", retracting);
-      SERIAL_ECHOLNPAIR("swapping ", swapping);
-      SERIAL_ECHOLNPAIR("active_extruder ", active_extruder);
-      for (uint8_t i = 0; i < EXTRUDERS; ++i) {
-        SERIAL_ECHOPAIR("retracted[", i);
-        SERIAL_ECHOLNPAIR("] ", retracted[i]);
-        SERIAL_ECHOPAIR("retracted_swap[", i);
-        SERIAL_ECHOLNPAIR("] ", retracted_swap[i]);
-      }
-      SERIAL_ECHOLNPAIR("current_position[z] ", current_position[Z_AXIS]);
-      SERIAL_ECHOLNPAIR("hop_amount ", hop_amount);
-    //*/
-
-  } // retract()
-
-#endif // FWRETRACT
-
 #if ENABLED(MIXING_EXTRUDER)
 
   void normalize_mix() {
     float mix_total = 0.0;
     for (uint8_t i = 0; i < MIXING_STEPPERS; i++) mix_total += RECIPROCAL(mixing_factor[i]);
     // Scale all values if they don't add up to ~1.0
     if (!NEAR(mix_total, 1.0)) {
       SERIAL_PROTOCOLLNPGM("Warning: Mix factors must add up to 1.0. Scaling.");
       for (uint8_t i = 0; i < MIXING_STEPPERS; i++) mixing_factor[i] *= mix_total;
     }
@@ -2540,24 +2396,20 @@ void dwell(millis_t time) {
   time += previous_cmd_ms;
   while (PENDING(millis(), time)) idle();
 }
 
 #include "gcode/motion/G4.h"
 
 #if ENABLED(BEZIER_CURVE_SUPPORT)
   #include "gcode/motion/G5.h"
 #endif
 
-#if ENABLED(FWRETRACT)
-  #include "gcode/feature/fwretract/G10_G11.h"
-#endif
-
 #if ENABLED(NOZZLE_CLEAN_FEATURE)
   #include "gcode/feature/clean/G12.h"
 #endif
 
 #if ENABLED(CNC_WORKSPACE_PLANES)
   #include "gcode/geometry/G17-G19.h"
 #endif
 
 #if ENABLED(INCH_MODE_SUPPORT)
   #include "gcode/units/G20_G21.h"

commit 722786966ad284a708502d18ac5daad02012bfc8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Sep 7 22:33:16 2017 -0500

    Add gcode.cpp, motion.*, queue.* - Apply to some G-codes.

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index 6eb0ee164d..dcd8599af0 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -24,47 +24,55 @@
  * About Marlin
  *
  * This firmware is a mashup between Sprinter and grbl.
  *  - https://github.com/kliment/Sprinter
  *  - https://github.com/simen/grbl
  */
 
 #include "Marlin.h"
 
 #include "lcd/ultralcd.h"
+#include "module/motion.h"
 #include "module/planner.h"
 #include "module/stepper.h"
 #include "module/endstops.h"
 #include "module/temperature.h"
 #include "sd/cardreader.h"
 #include "module/configuration_store.h"
 #ifdef ARDUINO
   #include <pins_arduino.h>
 #endif
 #include <math.h>
 #include "libs/nozzle.h"
 #include "libs/duration_t.h"
+
+#include "gcode/gcode.h"
 #include "gcode/parser.h"
+#include "gcode/queue.h"
 
 #if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER)
   #include "libs/buzzer.h"
 #endif
 
 #if HAS_ABL
   #include "libs/vector_3.h"
   #if ENABLED(AUTO_BED_LEVELING_LINEAR)
     #include "libs/least_squares_fit.h"
   #endif
 #elif ENABLED(MESH_BED_LEVELING)
   #include "feature/mbl/mesh_bed_leveling.h"
 #endif
 
+#if (ENABLED(SWITCHING_EXTRUDER) && !DONT_SWITCH) || ENABLED(SWITCHING_NOZZLE)
+  #include "module/tool_change.h"
+#endif
+
 #if ENABLED(BEZIER_CURVE_SUPPORT)
   #include "module/planner_bezier.h"
 #endif
 
 #if ENABLED(MAX7219_DEBUG)
   #include "feature/leds/Max7219_Debug_LEDs.h"
 #endif
 
 #if ENABLED(NEOPIXEL_RGBW_LED)
   #include <Adafruit_NeoPixel.h>
@@ -129,171 +137,101 @@
                            && ubl.z_values[0][0] == 0 && ubl.z_values[1][0] == 0 && ubl.z_values[2][0] == 0 )  \
                            || isnan(ubl.z_values[0][0]))
 #endif
 
 #if ENABLED(SENSORLESS_HOMING)
   #include "feature/tmc2130.h"
 #endif
 
 bool Running = true;
 
-/**
- * Cartesian Current Position
- *   Used to track the logical position as moves are queued.
- *   Used by 'line_to_current_position' to do a move after changing it.
- *   Used by 'SYNC_PLAN_POSITION_KINEMATIC' to update 'planner.position'.
- */
-float current_position[XYZE] = { 0.0 };
-
-/**
- * Cartesian Destination
- *   A temporary position, usually applied to 'current_position'.
- *   Set with 'gcode_get_destination' or 'set_destination_to_current'.
- *   'line_to_destination' sets 'current_position' to 'destination'.
- */
-float destination[XYZE] = { 0.0 };
-
 /**
  * axis_homed
  *   Flags that each linear axis was homed.
  *   XYZ on cartesian, ABC on delta, ABZ on SCARA.
  *
  * axis_known_position
  *   Flags that the position is known in each linear axis. Set when homed.
  *   Cleared whenever a stepper powers off, potentially losing its position.
  */
 bool axis_homed[XYZ] = { false }, axis_known_position[XYZ] = { false };
 
-/**
- * GCode line number handling. Hosts may opt to include line numbers when
- * sending commands to Marlin, and lines will be checked for sequentiality.
- * M110 N<int> sets the current line number.
- */
-static long gcode_N, gcode_LastN, Stopped_gcode_LastN = 0;
-
-/**
- * GCode Command Queue
- * A simple ring buffer of BUFSIZE command strings.
- *
- * Commands are copied into this buffer by the command injectors
- * (immediate, serial, sd card) and they are processed sequentially by
- * the main loop. The process_next_command function parses the next
- * command and hands off execution to individual handler functions.
- */
-uint8_t commands_in_queue = 0; // Count of commands in the queue
-static uint8_t cmd_queue_index_r = 0, // Ring buffer read position
-               cmd_queue_index_w = 0; // Ring buffer write position
-#if ENABLED(M100_FREE_MEMORY_WATCHER)
-  char command_queue[BUFSIZE][MAX_CMD_SIZE];  // Necessary so M100 Free Memory Dumper can show us the commands and any corruption
-#else                                         // This can be collapsed back to the way it was soon.
-static char command_queue[BUFSIZE][MAX_CMD_SIZE];
-#endif
-
-/**
- * Next Injected Command pointer. NULL if no commands are being injected.
- * Used by Marlin internally to ensure that commands initiated from within
- * are enqueued ahead of any pending serial or sd card commands.
- */
-static const char *injected_commands_P = NULL;
-
 #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
   TempUnit input_temp_units = TEMPUNIT_C;
 #endif
 
 /**
  * Feed rates are often configured with mm/m
  * but the planner and stepper like mm/s units.
  */
 static const float homing_feedrate_mm_s[] PROGMEM = {
   #if ENABLED(DELTA)
     MMM_TO_MMS(HOMING_FEEDRATE_Z), MMM_TO_MMS(HOMING_FEEDRATE_Z),
   #else
     MMM_TO_MMS(HOMING_FEEDRATE_XY), MMM_TO_MMS(HOMING_FEEDRATE_XY),
   #endif
   MMM_TO_MMS(HOMING_FEEDRATE_Z), 0
 };
 FORCE_INLINE float homing_feedrate(const AxisEnum a) { return pgm_read_float(&homing_feedrate_mm_s[a]); }
 
-float feedrate_mm_s = MMM_TO_MMS(1500.0);
 static float saved_feedrate_mm_s;
 int16_t feedrate_percentage = 100, saved_feedrate_percentage,
     flow_percentage[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(100);
 
 // Initialized by settings.load()
-bool axis_relative_modes[] = AXIS_RELATIVE_MODES,
-     volumetric_enabled;
+bool volumetric_enabled;
 float filament_size[EXTRUDERS], volumetric_multiplier[EXTRUDERS];
 
 #if HAS_WORKSPACE_OFFSET
   #if HAS_POSITION_SHIFT
     // The distance that XYZ has been offset by G92. Reset by G28.
     float position_shift[XYZ] = { 0 };
   #endif
   #if HAS_HOME_OFFSET
     // This offset is added to the configured home position.
     // Set by M206, M428, or menu item. Saved to EEPROM.
     float home_offset[XYZ] = { 0 };
   #endif
   #if HAS_HOME_OFFSET && HAS_POSITION_SHIFT
     // The above two are combined to save on computes
     float workspace_offset[XYZ] = { 0 };
   #endif
 #endif
 
-// Software Endstops are based on the configured limits.
-#if HAS_SOFTWARE_ENDSTOPS
-  bool soft_endstops_enabled = true;
-#endif
-float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
-      soft_endstop_max[XYZ] = { X_MAX_BED, Y_MAX_BED, Z_MAX_POS };
-
 #if FAN_COUNT > 0
   int16_t fanSpeeds[FAN_COUNT] = { 0 };
   #if ENABLED(PROBING_FANS_OFF)
     bool fans_paused = false;
     int16_t paused_fanSpeeds[FAN_COUNT] = { 0 };
   #endif
 #endif
 
-// The active extruder (tool). Set with T<extruder> command.
-uint8_t active_extruder = 0;
-
-// Relative Mode. Enable with G91, disable with G90.
-static bool relative_mode = false;
-
 // For M109 and M190, this flag may be cleared (by M108) to exit the wait loop
 volatile bool wait_for_heatup = true;
 
 // For M0/M1, this flag may be cleared (by M108) to exit the wait-for-user loop
 #if HAS_RESUME_CONTINUE
   volatile bool wait_for_user = false;
 #endif
 
-const char axis_codes[XYZE] = { 'X', 'Y', 'Z', 'E' };
-
-// Number of characters read in the current line of serial input
-static int serial_count = 0;
-
 // Inactivity shutdown
 millis_t previous_cmd_ms = 0;
 static millis_t max_inactive_time = 0;
 static millis_t stepper_inactive_time = (DEFAULT_STEPPER_DEACTIVE_TIME) * 1000UL;
 
 // Print Job Timer
 #if ENABLED(PRINTCOUNTER)
   PrintCounter print_job_timer = PrintCounter();
 #else
   Stopwatch print_job_timer = Stopwatch();
 #endif
 
-static uint8_t target_extruder;
-
 #if HAS_BED_PROBE
   float zprobe_zoffset; // Initialized by settings.load()
 #endif
 
 #if HAS_ABL
   float xy_probe_feedrate_mm_s = MMM_TO_MMS(XY_PROBE_SPEED);
   #define XY_PROBE_FEEDRATE_MM_S xy_probe_feedrate_mm_s
 #elif defined(XY_PROBE_SPEED)
   #define XY_PROBE_FEEDRATE_MM_S MMM_TO_MMS(XY_PROBE_SPEED)
 #else
@@ -416,22 +354,20 @@ float cartes[XYZ] = { 0 };
   AdvancedPauseMenuResponse advanced_pause_menu_response;
 #endif
 
 #if ENABLED(MIXING_EXTRUDER)
   float mixing_factor[MIXING_STEPPERS]; // Reciprocal of mix proportion. 0.0 = off, otherwise >= 1.0.
   #if MIXING_VIRTUAL_TOOLS > 1
     float mixing_virtual_tool_mix[MIXING_VIRTUAL_TOOLS][MIXING_STEPPERS];
   #endif
 #endif
 
-static bool send_ok[BUFSIZE];
-
 #if HAS_SERVOS
   HAL_SERVO_LIB servo[NUM_SERVOS];
   #define MOVE_SERVO(I, P) servo[I].move(P)
   #if HAS_Z_SERVO_ENDSTOP
     #define DEPLOY_Z_SERVO() MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[0])
     #define STOW_Z_SERVO() MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[1])
   #endif
 #endif
 
 #ifdef CHDK
@@ -454,162 +390,42 @@ static bool send_ok[BUFSIZE];
 #if ENABLED(I2C_POSITION_ENCODERS)
   I2CPositionEncodersMgr I2CPEM;
   uint8_t blockBufferIndexRef = 0;
   millis_t lastUpdateMillis;
 #endif
 
 #if ENABLED(CNC_WORKSPACE_PLANES)
   static WorkspacePlane workspace_plane = PLANE_XY;
 #endif
 
-FORCE_INLINE float pgm_read_any(const float *p) { return pgm_read_float_near(p); }
-FORCE_INLINE signed char pgm_read_any(const signed char *p) { return pgm_read_byte_near(p); }
-
-#define XYZ_CONSTS_FROM_CONFIG(type, array, CONFIG) \
-  static const PROGMEM type array##_P[XYZ] = { X_##CONFIG, Y_##CONFIG, Z_##CONFIG }; \
-  static inline type array(AxisEnum axis) { return pgm_read_any(&array##_P[axis]); } \
-  typedef void __void_##CONFIG##__
-
-XYZ_CONSTS_FROM_CONFIG(float, base_min_pos,   MIN_POS);
-XYZ_CONSTS_FROM_CONFIG(float, base_max_pos,   MAX_POS);
-XYZ_CONSTS_FROM_CONFIG(float, base_home_pos,  HOME_POS);
-XYZ_CONSTS_FROM_CONFIG(float, max_length,     MAX_LENGTH);
-XYZ_CONSTS_FROM_CONFIG(float, home_bump_mm,   HOME_BUMP_MM);
-XYZ_CONSTS_FROM_CONFIG(signed char, home_dir, HOME_DIR);
-
 /**
  * ***************************************************************************
  * ******************************** FUNCTIONS ********************************
  * ***************************************************************************
  */
 
 void stop();
 
-void get_available_commands();
-void process_next_command();
-void prepare_move_to_destination();
-
 void get_cartesian_from_steppers();
 void set_current_from_steppers_for_axis(const AxisEnum axis);
 
 #if ENABLED(BEZIER_CURVE_SUPPORT)
   void plan_cubic_move(const float offset[4]);
 #endif
 
 void report_current_position();
 
-/**
- * sync_plan_position
- *
- * Set the planner/stepper positions directly from current_position with
- * no kinematic translation. Used for homing axes and cartesian/core syncing.
- */
-void sync_plan_position() {
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position", current_position);
-  #endif
-  planner.set_position_mm(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
-}
-inline void sync_plan_position_e() { planner.set_e_position_mm(current_position[E_AXIS]); }
-
-#if IS_KINEMATIC
-
-  inline void sync_plan_position_kinematic() {
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position_kinematic", current_position);
-    #endif
-    planner.set_position_mm_kinematic(current_position);
-  }
-  #define SYNC_PLAN_POSITION_KINEMATIC() sync_plan_position_kinematic()
-
-#else
-
-  #define SYNC_PLAN_POSITION_KINEMATIC() sync_plan_position()
-
-#endif
-
 #if ENABLED(DIGIPOT_I2C)
   extern void digipot_i2c_set_current(uint8_t channel, float current);
   extern void digipot_i2c_init();
 #endif
 
-/**
- * Inject the next "immediate" command, when possible, onto the front of the queue.
- * Return true if any immediate commands remain to inject.
- */
-static bool drain_injected_commands_P() {
-  if (injected_commands_P != NULL) {
-    size_t i = 0;
-    char c, cmd[30];
-    strncpy_P(cmd, injected_commands_P, sizeof(cmd) - 1);
-    cmd[sizeof(cmd) - 1] = '\0';
-    while ((c = cmd[i]) && c != '\n') i++; // find the end of this gcode command
-    cmd[i] = '\0';
-    if (enqueue_and_echo_command(cmd))     // success?
-      injected_commands_P = c ? injected_commands_P + i + 1 : NULL; // next command or done
-  }
-  return (injected_commands_P != NULL);    // return whether any more remain
-}
-
-/**
- * Record one or many commands to run from program memory.
- * Aborts the current queue, if any.
- * Note: drain_injected_commands_P() must be called repeatedly to drain the commands afterwards
- */
-void enqueue_and_echo_commands_P(const char * const pgcode) {
-  injected_commands_P = pgcode;
-  drain_injected_commands_P(); // first command executed asap (when possible)
-}
-
-/**
- * Clear the Marlin command queue
- */
-void clear_command_queue() {
-  cmd_queue_index_r = cmd_queue_index_w;
-  commands_in_queue = 0;
-}
-
-/**
- * Once a new command is in the ring buffer, call this to commit it
- */
-inline void _commit_command(bool say_ok) {
-  send_ok[cmd_queue_index_w] = say_ok;
-  if (++cmd_queue_index_w >= BUFSIZE) cmd_queue_index_w = 0;
-  commands_in_queue++;
-}
-
-/**
- * Copy a command from RAM into the main command buffer.
- * Return true if the command was successfully added.
- * Return false for a full buffer, or if the 'command' is a comment.
- */
-inline bool _enqueuecommand(const char* cmd, bool say_ok=false) {
-  if (*cmd == ';' || commands_in_queue >= BUFSIZE) return false;
-  strcpy(command_queue[cmd_queue_index_w], cmd);
-  _commit_command(say_ok);
-  return true;
-}
-
-/**
- * Enqueue with Serial Echo
- */
-bool enqueue_and_echo_command(const char* cmd, bool say_ok/*=false*/) {
-  if (_enqueuecommand(cmd, say_ok)) {
-    SERIAL_ECHO_START();
-    SERIAL_ECHOPAIR(MSG_ENQUEUEING, cmd);
-    SERIAL_CHAR('"');
-    SERIAL_EOL();
-    return true;
-  }
-  return false;
-}
-
 void setup_killpin() {
   #if HAS_KILL
     SET_INPUT_PULLUP(KILL_PIN);
   #endif
 }
 
 #if ENABLED(FILAMENT_RUNOUT_SENSOR)
 
   void setup_filrunoutpin() {
     #if ENABLED(ENDSTOPPULLUP_FIL_RUNOUT)
@@ -777,319 +593,20 @@ void servo_init() {
     #endif
 
     #if ENABLED(PCA9632)
       // Update I2C LED driver
       PCA9632_SetColor(r, g, b);
     #endif
   }
 
 #endif // HAS_COLOR_LEDS
 
-void gcode_line_error(const char* err, bool doFlush = true) {
-  SERIAL_ERROR_START();
-  serialprintPGM(err);
-  SERIAL_ERRORLN(gcode_LastN);
-  //Serial.println(gcode_N);
-  if (doFlush) FlushSerialRequestResend();
-  serial_count = 0;
-}
-
-/**
- * Get all commands waiting on the serial port and queue them.
- * Exit when the buffer is full or when no more characters are
- * left on the serial port.
- */
-inline void get_serial_commands() {
-  static char serial_line_buffer[MAX_CMD_SIZE];
-  static bool serial_comment_mode = false;
-
-  // If the command buffer is empty for too long,
-  // send "wait" to indicate Marlin is still waiting.
-  #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0
-    static millis_t last_command_time = 0;
-    const millis_t ms = millis();
-    if (commands_in_queue == 0 && !MYSERIAL.available() && ELAPSED(ms, last_command_time + NO_TIMEOUTS)) {
-      SERIAL_ECHOLNPGM(MSG_WAIT);
-      last_command_time = ms;
-    }
-  #endif
-
-  /**
-   * Loop while serial characters are incoming and the queue is not full
-   */
-  while (commands_in_queue < BUFSIZE && MYSERIAL.available() > 0) {
-
-    char serial_char = MYSERIAL.read();
-
-    /**
-     * If the character ends the line
-     */
-    if (serial_char == '\n' || serial_char == '\r') {
-
-      serial_comment_mode = false; // end of line == end of comment
-
-      if (!serial_count) continue; // skip empty lines
-
-      serial_line_buffer[serial_count] = 0; // terminate string
-      serial_count = 0; //reset buffer
-
-      char* command = serial_line_buffer;
-
-      while (*command == ' ') command++; // skip any leading spaces
-      char *npos = (*command == 'N') ? command : NULL, // Require the N parameter to start the line
-           *apos = strchr(command, '*');
-
-      if (npos) {
-
-        bool M110 = strstr_P(command, PSTR("M110")) != NULL;
-
-        if (M110) {
-          char* n2pos = strchr(command + 4, 'N');
-          if (n2pos) npos = n2pos;
-        }
-
-        gcode_N = strtol(npos + 1, NULL, 10);
-
-        if (gcode_N != gcode_LastN + 1 && !M110) {
-          gcode_line_error(PSTR(MSG_ERR_LINE_NO));
-          return;
-        }
-
-        if (apos) {
-          byte checksum = 0, count = 0;
-          while (command[count] != '*') checksum ^= command[count++];
-
-          if (strtol(apos + 1, NULL, 10) != checksum) {
-            gcode_line_error(PSTR(MSG_ERR_CHECKSUM_MISMATCH));
-            return;
-          }
-          // if no errors, continue parsing
-        }
-        else {
-          gcode_line_error(PSTR(MSG_ERR_NO_CHECKSUM));
-          return;
-        }
-
-        gcode_LastN = gcode_N;
-        // if no errors, continue parsing
-      }
-      else if (apos) { // No '*' without 'N'
-        gcode_line_error(PSTR(MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM), false);
-        return;
-      }
-
-      // Movement commands alert when stopped
-      if (IsStopped()) {
-        char* gpos = strchr(command, 'G');
-        if (gpos) {
-          const int codenum = strtol(gpos + 1, NULL, 10);
-          switch (codenum) {
-            case 0:
-            case 1:
-            case 2:
-            case 3:
-              SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
-              LCD_MESSAGEPGM(MSG_STOPPED);
-              break;
-          }
-        }
-      }
-
-      #if DISABLED(EMERGENCY_PARSER)
-        // If command was e-stop process now
-        if (strcmp(command, "M108") == 0) {
-          wait_for_heatup = false;
-          #if ENABLED(ULTIPANEL)
-            wait_for_user = false;
-          #endif
-        }
-        if (strcmp(command, "M112") == 0) kill(PSTR(MSG_KILLED));
-        if (strcmp(command, "M410") == 0) { quickstop_stepper(); }
-      #endif
-
-      #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0
-        last_command_time = ms;
-      #endif
-
-      // Add the command to the queue
-      _enqueuecommand(serial_line_buffer, true);
-    }
-    else if (serial_count >= MAX_CMD_SIZE - 1) {
-      // Keep fetching, but ignore normal characters beyond the max length
-      // The command will be injected when EOL is reached
-    }
-    else if (serial_char == '\\') {  // Handle escapes
-      if (MYSERIAL.available() > 0) {
-        // if we have one more character, copy it over
-        serial_char = MYSERIAL.read();
-        if (!serial_comment_mode) serial_line_buffer[serial_count++] = serial_char;
-      }
-      // otherwise do nothing
-    }
-    else { // it's not a newline, carriage return or escape char
-      if (serial_char == ';') serial_comment_mode = true;
-      if (!serial_comment_mode) serial_line_buffer[serial_count++] = serial_char;
-    }
-
-  } // queue has space, serial has data
-}
-
-#if ENABLED(SDSUPPORT)
-
-  /**
-   * Get commands from the SD Card until the command buffer is full
-   * or until the end of the file is reached. The special character '#'
-   * can also interrupt buffering.
-   */
-  inline void get_sdcard_commands() {
-    static bool stop_buffering = false,
-                sd_comment_mode = false;
-
-    if (!IS_SD_PRINTING) return;
-
-    /**
-     * '#' stops reading from SD to the buffer prematurely, so procedural
-     * macro calls are possible. If it occurs, stop_buffering is triggered
-     * and the buffer is run dry; this character _can_ occur in serial com
-     * due to checksums, however, no checksums are used in SD printing.
-     */
-
-    if (commands_in_queue == 0) stop_buffering = false;
-
-    uint16_t sd_count = 0;
-    bool card_eof = card.eof();
-    while (commands_in_queue < BUFSIZE && !card_eof && !stop_buffering) {
-      const int16_t n = card.get();
-      char sd_char = (char)n;
-      card_eof = card.eof();
-      if (card_eof || n == -1
-          || sd_char == '\n' || sd_char == '\r'
-          || ((sd_char == '#' || sd_char == ':') && !sd_comment_mode)
-      ) {
-        if (card_eof) {
-          SERIAL_PROTOCOLLNPGM(MSG_FILE_PRINTED);
-          card.printingHasFinished();
-          #if ENABLED(PRINTER_EVENT_LEDS)
-            LCD_MESSAGEPGM(MSG_INFO_COMPLETED_PRINTS);
-            set_led_color(0, 255, 0); // Green
-            #if HAS_RESUME_CONTINUE
-              enqueue_and_echo_commands_P(PSTR("M0")); // end of the queue!
-            #else
-              safe_delay(1000);
-            #endif
-            set_led_color(0, 0, 0);   // OFF
-          #endif
-          card.checkautostart(true);
-        }
-        else if (n == -1) {
-          SERIAL_ERROR_START();
-          SERIAL_ECHOLNPGM(MSG_SD_ERR_READ);
-        }
-        if (sd_char == '#') stop_buffering = true;
-
-        sd_comment_mode = false; // for new command
-
-        if (!sd_count) continue; // skip empty lines (and comment lines)
-
-        command_queue[cmd_queue_index_w][sd_count] = '\0'; // terminate string
-        sd_count = 0; // clear sd line buffer
-
-        _commit_command(false);
-      }
-      else if (sd_count >= MAX_CMD_SIZE - 1) {
-        /**
-         * Keep fetching, but ignore normal characters beyond the max length
-         * The command will be injected when EOL is reached
-         */
-      }
-      else {
-        if (sd_char == ';') sd_comment_mode = true;
-        if (!sd_comment_mode) command_queue[cmd_queue_index_w][sd_count++] = sd_char;
-      }
-    }
-  }
-
-#endif // SDSUPPORT
-
-/**
- * Add to the circular command queue the next command from:
- *  - The command-injection queue (injected_commands_P)
- *  - The active serial input (usually USB)
- *  - The SD card file being actively printed
- */
-void get_available_commands() {
-
-  // if any immediate commands remain, don't get other commands yet
-  if (drain_injected_commands_P()) return;
-
-  get_serial_commands();
-
-  #if ENABLED(SDSUPPORT)
-    get_sdcard_commands();
-  #endif
-}
-
-/**
- * Set target_extruder from the T parameter or the active_extruder
- *
- * Returns TRUE if the target is invalid
- */
-bool get_target_extruder_from_command(const uint16_t code) {
-  if (parser.seenval('T')) {
-    const int8_t e = parser.value_byte();
-    if (e >= EXTRUDERS) {
-      SERIAL_ECHO_START();
-      SERIAL_CHAR('M');
-      SERIAL_ECHO(code);
-      SERIAL_ECHOLNPAIR(" " MSG_INVALID_EXTRUDER " ", e);
-      return true;
-    }
-    target_extruder = e;
-  }
-  else
-    target_extruder = active_extruder;
-
-  return false;
-}
-
-#if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
-  bool extruder_duplication_enabled = false; // Used in Dual X mode 2
-#endif
-
-#if ENABLED(DUAL_X_CARRIAGE)
-
-  static DualXMode dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
-
-  static float x_home_pos(const int extruder) {
-    if (extruder == 0)
-      return LOGICAL_X_POSITION(base_home_pos(X_AXIS));
-    else
-      /**
-       * In dual carriage mode the extruder offset provides an override of the
-       * second X-carriage position when homed - otherwise X2_HOME_POS is used.
-       * This allows soft recalibration of the second extruder home position
-       * without firmware reflash (through the M218 command).
-       */
-      return LOGICAL_X_POSITION(hotend_offset[X_AXIS][1] > 0 ? hotend_offset[X_AXIS][1] : X2_HOME_POS);
-  }
-
-  static int x_home_dir(const int extruder) { return extruder ? X2_HOME_DIR : X_HOME_DIR; }
-
-  static float inactive_extruder_x_pos = X2_MAX_POS; // used in mode 0 & 1
-  static bool active_extruder_parked = false;        // used in mode 1 & 2
-  static float raised_parked_position[XYZE];         // used in mode 1
-  static millis_t delayed_move_time = 0;             // used in mode 1
-  static float duplicate_extruder_x_offset = DEFAULT_DUPLICATION_X_OFFSET; // used in mode 2
-  static int16_t duplicate_extruder_temp_offset = 0; // used in mode 2
-
-#endif // DUAL_X_CARRIAGE
-
 #if HAS_WORKSPACE_OFFSET || ENABLED(DUAL_X_CARRIAGE)
 
   /**
    * Software endstops can be used to monitor the open end of
    * an axis that has a hardware endstop on the other end. Or
    * they can prevent axes from moving past endstops and grinding.
    *
    * To keep doing their job as the coordinate system changes,
    * the software endstop positions must be refreshed to remain
    * at the same positions relative to the machine.
@@ -1305,68 +822,20 @@ inline float get_homing_bump_feedrate(const AxisEnum axis) {
   static const uint8_t homing_bump_divisor[] PROGMEM = HOMING_BUMP_DIVISOR;
   uint8_t hbd = pgm_read_byte(&homing_bump_divisor[axis]);
   if (hbd < 1) {
     hbd = 10;
     SERIAL_ECHO_START();
     SERIAL_ECHOLNPGM("Warning: Homing Bump Divisor < 1");
   }
   return homing_feedrate(axis) / hbd;
 }
 
-/**
- * Move the planner to the current position from wherever it last moved
- * (or from wherever it has been told it is located).
- */
-inline void line_to_current_position() {
-  planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], feedrate_mm_s, active_extruder);
-}
-
-/**
- * Move the planner to the position stored in the destination array, which is
- * used by G0/G1/G2/G3/G5 and many other functions to set a destination.
- */
-inline void line_to_destination(const float fr_mm_s) {
-  planner.buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], fr_mm_s, active_extruder);
-}
-inline void line_to_destination() { line_to_destination(feedrate_mm_s); }
-
-inline void set_current_to_destination() { COPY(current_position, destination); }
-inline void set_destination_to_current() { COPY(destination, current_position); }
-
-#if IS_KINEMATIC
-  /**
-   * Calculate delta, start a line, and set current_position to destination
-   */
-  void prepare_uninterpolated_move_to_destination(const float fr_mm_s=0.0) {
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) DEBUG_POS("prepare_uninterpolated_move_to_destination", destination);
-    #endif
-
-    refresh_cmd_timeout();
-
-    #if UBL_DELTA
-      // ubl segmented line will do z-only moves in single segment
-      ubl.prepare_segmented_line_to(destination, MMS_SCALED(fr_mm_s ? fr_mm_s : feedrate_mm_s));
-    #else
-      if ( current_position[X_AXIS] == destination[X_AXIS]
-        && current_position[Y_AXIS] == destination[Y_AXIS]
-        && current_position[Z_AXIS] == destination[Z_AXIS]
-        && current_position[E_AXIS] == destination[E_AXIS]
-      ) return;
-
-      planner.buffer_line_kinematic(destination, MMS_SCALED(fr_mm_s ? fr_mm_s : feedrate_mm_s), active_extruder);
-    #endif
-
-    set_current_to_destination();
-  }
-#endif // IS_KINEMATIC
-
 /**
  *  Plan a move to (X, Y, Z) and set the current_position
  *  The final current_position may not be the one that was requested
  */
 void do_blocking_move_to(const float &lx, const float &ly, const float &lz, const float &fr_mm_s/*=0.0*/) {
   const float old_feedrate_mm_s = feedrate_mm_s;
 
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) print_xyz(PSTR(">>> do_blocking_move_to"), NULL, lx, ly, lz);
   #endif
@@ -1499,30 +968,30 @@ void do_blocking_move_to_xy(const float &lx, const float &ly, const float &fr_mm
 //  - Reset the command timeout
 //  - Enable the endstops (for endstop moves)
 //
 static void setup_for_endstop_or_probe_move() {
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) DEBUG_POS("setup_for_endstop_or_probe_move", current_position);
   #endif
   saved_feedrate_mm_s = feedrate_mm_s;
   saved_feedrate_percentage = feedrate_percentage;
   feedrate_percentage = 100;
-  refresh_cmd_timeout();
+  gcode.refresh_cmd_timeout();
 }
 
 static void clean_up_after_endstop_or_probe_move() {
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) DEBUG_POS("clean_up_after_endstop_or_probe_move", current_position);
   #endif
   feedrate_mm_s = saved_feedrate_mm_s;
   feedrate_percentage = saved_feedrate_percentage;
-  refresh_cmd_timeout();
+  gcode.refresh_cmd_timeout();
 }
 
 #if HAS_BED_PROBE
   /**
    * Raise Z to a minimum height to make room for a probe to move
    */
   inline void do_probe_raise(const float z_raise) {
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) {
         SERIAL_ECHOPAIR("do_probe_raise(", z_raise);
@@ -2009,21 +1478,21 @@ static void clean_up_after_endstop_or_probe_move() {
    * @param  short_move Flag for a shorter probe move towards the bed
    * @return The raw Z position where the probe was triggered
    */
   static float run_z_probe(const bool short_move=true) {
 
     #if ENABLED(DEBUG_LEVELING_FEATURE)
       if (DEBUGGING(LEVELING)) DEBUG_POS(">>> run_z_probe", current_position);
     #endif
 
     // Prevent stepper_inactive_time from running out and EXTRUDER_RUNOUT_PREVENT from extruding
-    refresh_cmd_timeout();
+    gcode.refresh_cmd_timeout();
 
     #if ENABLED(PROBE_DOUBLE_TOUCH)
 
       // Do a first probe at the fast speed
       if (do_probe_move(-10, Z_PROBE_SPEED_FAST)) return NAN;
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         float first_probe_z = current_position[Z_AXIS];
         if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("1st Probe Z:", first_probe_z);
       #endif
@@ -3017,49 +2486,20 @@ static void homeaxis(const AxisEnum axis) {
   #endif
 
 #endif
 
 /**
  * ***************************************************************************
  * ***************************** G-CODE HANDLING *****************************
  * ***************************************************************************
  */
 
-/**
- * Set XYZE destination and feedrate from the current GCode command
- *
- *  - Set destination from included axis codes
- *  - Set to current for missing axis codes
- *  - Set the feedrate, if included
- */
-void gcode_get_destination() {
-  LOOP_XYZE(i) {
-    if (parser.seen(axis_codes[i]))
-      destination[i] = parser.value_axis_units((AxisEnum)i) + (axis_relative_modes[i] || relative_mode ? current_position[i] : 0);
-    else
-      destination[i] = current_position[i];
-  }
-
-  if (parser.linearval('F') > 0.0)
-    feedrate_mm_s = MMM_TO_MMS(parser.value_feedrate());
-
-  #if ENABLED(PRINTCOUNTER)
-    if (!DEBUGGING(DRYRUN))
-      print_job_timer.incFilamentUsed(destination[E_AXIS] - current_position[E_AXIS]);
-  #endif
-
-  // Get ABCDHI mixing factors
-  #if ENABLED(MIXING_EXTRUDER) && ENABLED(DIRECT_MIXING_IN_G1)
-    gcode_get_mix();
-  #endif
-}
-
 #if ENABLED(HOST_KEEPALIVE_FEATURE)
 
   /**
    * Output a "busy" message at regular intervals
    * while the machine is not accepting commands.
    */
   void host_keepalive() {
     const millis_t ms = millis();
     if (host_keepalive_interval && busy_state != NOT_BUSY) {
       if (PENDING(ms, next_busy_signal_ms)) return;
@@ -3084,28 +2524,26 @@ void gcode_get_destination() {
     next_busy_signal_ms = ms + host_keepalive_interval * 1000UL;
   }
 
 #endif // HOST_KEEPALIVE_FEATURE
 
 
 /**************************************************
  ***************** GCode Handlers *****************
  **************************************************/
 
-#include "gcode/motion/G0_G1.h"
-
 #if ENABLED(ARC_SUPPORT)
   #include "gcode/motion/G2_G3.h"
 #endif
 
 void dwell(millis_t time) {
-  refresh_cmd_timeout();
+  gcode.refresh_cmd_timeout();
   time += previous_cmd_ms;
   while (PENDING(millis(), time)) idle();
 }
 
 #include "gcode/motion/G4.h"
 
 #if ENABLED(BEZIER_CURVE_SUPPORT)
   #include "gcode/motion/G5.h"
 #endif
 
@@ -3243,22 +2681,20 @@ static bool pin_is_protected(const int8_t pin) {
 #endif
 
 #include "gcode/stats/M75.h"
 #include "gcode/stats/M76.h"
 #include "gcode/stats/M77.h"
 
 #if ENABLED(PRINTCOUNTER)
   #include "gcode/stats/M78.h"
 #endif
 
-#include "gcode/temperature/M104.h"
-
 #if HAS_TEMP_HOTEND || HAS_TEMP_BED
 
   void print_heater_state(const float &c, const float &t,
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       const float r,
     #endif
     const int8_t e=-2
   ) {
     #if !(HAS_TEMP_BED && HAS_TEMP_HOTEND) && HOTENDS <= 1
       UNUSED(e);
@@ -3281,44 +2717,44 @@ static bool pin_is_protected(const int8_t pin) {
     SERIAL_PROTOCOL(c);
     SERIAL_PROTOCOLPAIR(" /" , t);
     #if ENABLED(SHOW_TEMP_ADC_VALUES)
       SERIAL_PROTOCOLPAIR(" (", r / OVERSAMPLENR);
       SERIAL_PROTOCOLCHAR(')');
     #endif
   }
 
   void print_heaterstates() {
     #if HAS_TEMP_HOTEND
-      print_heater_state(thermalManager.degHotend(target_extruder), thermalManager.degTargetHotend(target_extruder)
+      print_heater_state(thermalManager.degHotend(gcode.target_extruder), thermalManager.degTargetHotend(gcode.target_extruder)
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
-          , thermalManager.rawHotendTemp(target_extruder)
+          , thermalManager.rawHotendTemp(gcode.target_extruder)
         #endif
       );
     #endif
     #if HAS_TEMP_BED
       print_heater_state(thermalManager.degBed(), thermalManager.degTargetBed(),
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
           thermalManager.rawBedTemp(),
         #endif
         -1 // BED
       );
     #endif
     #if HOTENDS > 1
       HOTEND_LOOP() print_heater_state(thermalManager.degHotend(e), thermalManager.degTargetHotend(e),
         #if ENABLED(SHOW_TEMP_ADC_VALUES)
           thermalManager.rawHotendTemp(e),
         #endif
         e
       );
     #endif
     SERIAL_PROTOCOLPGM(" @:");
-    SERIAL_PROTOCOL(thermalManager.getHeaterPower(target_extruder));
+    SERIAL_PROTOCOL(thermalManager.getHeaterPower(gcode.target_extruder));
     #if HAS_TEMP_BED
       SERIAL_PROTOCOLPGM(" B@:");
       SERIAL_PROTOCOL(thermalManager.getHeaterPower(-1));
     #endif
     #if HOTENDS > 1
       HOTEND_LOOP() {
         SERIAL_PROTOCOLPAIR(" @", e);
         SERIAL_PROTOCOLCHAR(':');
         SERIAL_PROTOCOL(thermalManager.getHeaterPower(e));
       }
@@ -3350,22 +2786,20 @@ static bool pin_is_protected(const int8_t pin) {
   #include "gcode/temperature/M106.h"
   #include "gcode/temperature/M107.h"
 #endif
 
 #if DISABLED(EMERGENCY_PARSER)
   #include "gcode/control/M108.h"
   #include "gcode/control/M112.h"
   #include "gcode/control/M410.h"
 #endif
 
-#include "gcode/temperature/M109.h"
-
 #if HAS_TEMP_BED
   #include "gcode/temperature/M190.h"
 #endif
 
 #include "gcode/host/M110.h"
 
 #include "gcode/control/M111.h"
 
 #if ENABLED(HOST_KEEPALIVE_FEATURE)
   #include "gcode/host/M113.h"
@@ -3397,31 +2831,20 @@ static bool pin_is_protected(const int8_t pin) {
 #endif
 
 #include "gcode/control/M81.h"
 
 #include "gcode/units/M82_M83.h"
 
 #include "gcode/control/M18_M84.h"
 
 #include "gcode/control/M85.h"
 
-/**
- * Multi-stepper support for M92, M201, M203
- */
-#if ENABLED(DISTINCT_E_FACTORS)
-  #define GET_TARGET_EXTRUDER(CMD) if (get_target_extruder_from_command(CMD)) return
-  #define TARGET_EXTRUDER target_extruder
-#else
-  #define GET_TARGET_EXTRUDER(CMD) NOOP
-  #define TARGET_EXTRUDER 0
-#endif
-
 #include "gcode/config/M92.h"
 
 #if ENABLED(M100_FREE_MEMORY_WATCHER)
   #include "gcode/calibrate/M100.h"
 #endif
 
 /**
  * Output the current position to serial
  */
 void report_current_position() {
@@ -3454,21 +2877,20 @@ void report_current_position() {
 #include "gcode/control/M120_M121.h"
 
 #if ENABLED(PARK_HEAD_ON_PAUSE)
   #include "gcode/feature/pause/M125.h"
 #endif
 
 #if HAS_COLOR_LEDS
   #include "gcode/feature/leds/M150.h"
 #endif
 
-#include "gcode/config/M200.h"
 #include "gcode/config/M201.h"
 
 #if 0 // Not used for Sprinter/grbl gen6
   #include "gcode/config/M202.h"
 #endif
 
 #include "gcode/config/M203.h"
 #include "gcode/config/M204.h"
 #include "gcode/config/M205.h"
 
@@ -3477,34 +2899,23 @@ void report_current_position() {
 #endif
 
 #if IS_KINEMATIC
   #include "gcode/calibrate/M665.h"
 #endif
 
 #if ENABLED(DELTA) || ENABLED(Z_DUAL_ENDSTOPS)
   #include "gcode/calibrate/M666.h"
 #endif
 
-#if ENABLED(FWRETRACT)
-  #include "gcode/feature/fwretract/M207.h"
-  #include "gcode/feature/fwretract/M208.h"
-  #include "gcode/feature/fwretract/M209.h"
-#endif
-
 #include "gcode/control/M211.h"
 
-#if HOTENDS > 1
-  #include "gcode/config/M218.h"
-#endif
-
 #include "gcode/config/M220.h"
-#include "gcode/config/M221.h"
 
 #include "gcode/control/M226.h"
 
 #if ENABLED(EXPERIMENTAL_I2CBUS)
   #include "gcode/feature/i2c/M260_M261.h"
 #endif
 
 #if HAS_SERVOS
   #include "gcode/control/M280.h"
 #endif
@@ -3526,22 +2937,20 @@ void report_current_position() {
 #endif
 
 #if HAS_LCD_CONTRAST
   #include "gcode/lcd/M250.h"
 #endif
 
 #if ENABLED(PREVENT_COLD_EXTRUSION)
   #include "gcode/config/M302.h"
 #endif
 
-#include "gcode/temperature/M303.h"
-
 #if ENABLED(MORGAN_SCARA)
   #include "gcode/scara/M360-M364.h"
 #endif
 
 #if ENABLED(EXT_SOLENOID)
   #include "gcode/control/M380_M381.h"
 #endif
 
 #include "gcode/control/M400.h"
 
@@ -3640,94 +3049,20 @@ void quickstop_stepper() {
   #endif
   #if ENABLED(DIRECT_MIXING_IN_G1)
     #include "gcode/feature/mixing/M165.h"
   #endif
 #endif
 
 #include "gcode/control/M999.h"
 
 #include "gcode/control/T.h"
 
-#include "gcode/process_next_command.h"
-
-/**
- * Send a "Resend: nnn" message to the host to
- * indicate that a command needs to be re-sent.
- */
-void FlushSerialRequestResend() {
-  //char command_queue[cmd_queue_index_r][100]="Resend:";
-  MYSERIAL.flush();
-  SERIAL_PROTOCOLPGM(MSG_RESEND);
-  SERIAL_PROTOCOLLN(gcode_LastN + 1);
-  ok_to_send();
-}
-
-/**
- * Send an "ok" message to the host, indicating
- * that a command was successfully processed.
- *
- * If ADVANCED_OK is enabled also include:
- *   N<int>  Line number of the command, if any
- *   P<int>  Planner space remaining
- *   B<int>  Block queue space remaining
- */
-void ok_to_send() {
-  refresh_cmd_timeout();
-  if (!send_ok[cmd_queue_index_r]) return;
-  SERIAL_PROTOCOLPGM(MSG_OK);
-  #if ENABLED(ADVANCED_OK)
-    char* p = command_queue[cmd_queue_index_r];
-    if (*p == 'N') {
-      SERIAL_PROTOCOL(' ');
-      SERIAL_ECHO(*p++);
-      while (NUMERIC_SIGNED(*p))
-        SERIAL_ECHO(*p++);
-    }
-    SERIAL_PROTOCOLPGM(" P"); SERIAL_PROTOCOL(int(BLOCK_BUFFER_SIZE - planner.movesplanned() - 1));
-    SERIAL_PROTOCOLPGM(" B"); SERIAL_PROTOCOL(BUFSIZE - commands_in_queue);
-  #endif
-  SERIAL_EOL();
-}
-
-#if HAS_SOFTWARE_ENDSTOPS
-
-  /**
-   * Constrain the given coordinates to the software endstops.
-   */
-
-  // NOTE: This makes no sense for delta beds other than Z-axis.
-  //       For delta the X/Y would need to be clamped at
-  //       DELTA_PRINTABLE_RADIUS from center of bed, but delta
-  //       now enforces is_position_reachable for X/Y regardless
-  //       of HAS_SOFTWARE_ENDSTOPS, so that enforcement would be
-  //       redundant here.
-
-  void clamp_to_software_endstops(float target[XYZ]) {
-    if (!soft_endstops_enabled) return;
-    #if ENABLED(MIN_SOFTWARE_ENDSTOPS)
-      #if DISABLED(DELTA)
-        NOLESS(target[X_AXIS], soft_endstop_min[X_AXIS]);
-        NOLESS(target[Y_AXIS], soft_endstop_min[Y_AXIS]);
-      #endif
-      NOLESS(target[Z_AXIS], soft_endstop_min[Z_AXIS]);
-    #endif
-    #if ENABLED(MAX_SOFTWARE_ENDSTOPS)
-      #if DISABLED(DELTA)
-        NOMORE(target[X_AXIS], soft_endstop_max[X_AXIS]);
-        NOMORE(target[Y_AXIS], soft_endstop_max[Y_AXIS]);
-      #endif
-      NOMORE(target[Z_AXIS], soft_endstop_max[Z_AXIS]);
-    #endif
-  }
-
-#endif
-
 #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
 
   #if ENABLED(ABL_BILINEAR_SUBDIVISION)
     #define ABL_BG_SPACING(A) bilinear_grid_spacing_virt[A]
     #define ABL_BG_FACTOR(A)  bilinear_grid_factor_virt[A]
     #define ABL_BG_POINTS_X   ABL_GRID_POINTS_VIRT_X
     #define ABL_BG_POINTS_Y   ABL_GRID_POINTS_VIRT_Y
     #define ABL_BG_GRID(X,Y)  z_values_virt[X][Y]
   #else
     #define ABL_BG_SPACING(A) bilinear_grid_spacing[A]
@@ -4083,440 +3418,20 @@ void set_current_from_steppers_for_axis(const AxisEnum axis) {
   get_cartesian_from_steppers();
   #if PLANNER_LEVELING
     planner.unapply_leveling(cartes);
   #endif
   if (axis == ALL_AXES)
     COPY(current_position, cartes);
   else
     current_position[axis] = cartes[axis];
 }
 
-#if ENABLED(MESH_BED_LEVELING)
-
-  /**
-   * Prepare a mesh-leveled linear move in a Cartesian setup,
-   * splitting the move where it crosses mesh borders.
-   */
-  void mesh_line_to_destination(float fr_mm_s, uint8_t x_splits = 0xFF, uint8_t y_splits = 0xFF) {
-    int cx1 = mbl.cell_index_x(RAW_CURRENT_POSITION(X)),
-        cy1 = mbl.cell_index_y(RAW_CURRENT_POSITION(Y)),
-        cx2 = mbl.cell_index_x(RAW_X_POSITION(destination[X_AXIS])),
-        cy2 = mbl.cell_index_y(RAW_Y_POSITION(destination[Y_AXIS]));
-    NOMORE(cx1, GRID_MAX_POINTS_X - 2);
-    NOMORE(cy1, GRID_MAX_POINTS_Y - 2);
-    NOMORE(cx2, GRID_MAX_POINTS_X - 2);
-    NOMORE(cy2, GRID_MAX_POINTS_Y - 2);
-
-    if (cx1 == cx2 && cy1 == cy2) {
-      // Start and end on same mesh square
-      line_to_destination(fr_mm_s);
-      set_current_to_destination();
-      return;
-    }
-
-    #define MBL_SEGMENT_END(A) (current_position[A ##_AXIS] + (destination[A ##_AXIS] - current_position[A ##_AXIS]) * normalized_dist)
-
-    float normalized_dist, end[XYZE];
-
-    // Split at the left/front border of the right/top square
-    const int8_t gcx = max(cx1, cx2), gcy = max(cy1, cy2);
-    if (cx2 != cx1 && TEST(x_splits, gcx)) {
-      COPY(end, destination);
-      destination[X_AXIS] = LOGICAL_X_POSITION(mbl.index_to_xpos[gcx]);
-      normalized_dist = (destination[X_AXIS] - current_position[X_AXIS]) / (end[X_AXIS] - current_position[X_AXIS]);
-      destination[Y_AXIS] = MBL_SEGMENT_END(Y);
-      CBI(x_splits, gcx);
-    }
-    else if (cy2 != cy1 && TEST(y_splits, gcy)) {
-      COPY(end, destination);
-      destination[Y_AXIS] = LOGICAL_Y_POSITION(mbl.index_to_ypos[gcy]);
-      normalized_dist = (destination[Y_AXIS] - current_position[Y_AXIS]) / (end[Y_AXIS] - current_position[Y_AXIS]);
-      destination[X_AXIS] = MBL_SEGMENT_END(X);
-      CBI(y_splits, gcy);
-    }
-    else {
-      // Already split on a border
-      line_to_destination(fr_mm_s);
-      set_current_to_destination();
-      return;
-    }
-
-    destination[Z_AXIS] = MBL_SEGMENT_END(Z);
-    destination[E_AXIS] = MBL_SEGMENT_END(E);
-
-    // Do the split and look for more borders
-    mesh_line_to_destination(fr_mm_s, x_splits, y_splits);
-
-    // Restore destination from stack
-    COPY(destination, end);
-    mesh_line_to_destination(fr_mm_s, x_splits, y_splits);
-  }
-
-#elif ENABLED(AUTO_BED_LEVELING_BILINEAR) && !IS_KINEMATIC
-
-  #define CELL_INDEX(A,V) ((RAW_##A##_POSITION(V) - bilinear_start[A##_AXIS]) * ABL_BG_FACTOR(A##_AXIS))
-
-  /**
-   * Prepare a bilinear-leveled linear move on Cartesian,
-   * splitting the move where it crosses grid borders.
-   */
-  void bilinear_line_to_destination(float fr_mm_s, uint16_t x_splits = 0xFFFF, uint16_t y_splits = 0xFFFF) {
-    int cx1 = CELL_INDEX(X, current_position[X_AXIS]),
-        cy1 = CELL_INDEX(Y, current_position[Y_AXIS]),
-        cx2 = CELL_INDEX(X, destination[X_AXIS]),
-        cy2 = CELL_INDEX(Y, destination[Y_AXIS]);
-    cx1 = constrain(cx1, 0, ABL_BG_POINTS_X - 2);
-    cy1 = constrain(cy1, 0, ABL_BG_POINTS_Y - 2);
-    cx2 = constrain(cx2, 0, ABL_BG_POINTS_X - 2);
-    cy2 = constrain(cy2, 0, ABL_BG_POINTS_Y - 2);
-
-    if (cx1 == cx2 && cy1 == cy2) {
-      // Start and end on same mesh square
-      line_to_destination(fr_mm_s);
-      set_current_to_destination();
-      return;
-    }
-
-    #define LINE_SEGMENT_END(A) (current_position[A ##_AXIS] + (destination[A ##_AXIS] - current_position[A ##_AXIS]) * normalized_dist)
-
-    float normalized_dist, end[XYZE];
-
-    // Split at the left/front border of the right/top square
-    const int8_t gcx = max(cx1, cx2), gcy = max(cy1, cy2);
-    if (cx2 != cx1 && TEST(x_splits, gcx)) {
-      COPY(end, destination);
-      destination[X_AXIS] = LOGICAL_X_POSITION(bilinear_start[X_AXIS] + ABL_BG_SPACING(X_AXIS) * gcx);
-      normalized_dist = (destination[X_AXIS] - current_position[X_AXIS]) / (end[X_AXIS] - current_position[X_AXIS]);
-      destination[Y_AXIS] = LINE_SEGMENT_END(Y);
-      CBI(x_splits, gcx);
-    }
-    else if (cy2 != cy1 && TEST(y_splits, gcy)) {
-      COPY(end, destination);
-      destination[Y_AXIS] = LOGICAL_Y_POSITION(bilinear_start[Y_AXIS] + ABL_BG_SPACING(Y_AXIS) * gcy);
-      normalized_dist = (destination[Y_AXIS] - current_position[Y_AXIS]) / (end[Y_AXIS] - current_position[Y_AXIS]);
-      destination[X_AXIS] = LINE_SEGMENT_END(X);
-      CBI(y_splits, gcy);
-    }
-    else {
-      // Already split on a border
-      line_to_destination(fr_mm_s);
-      set_current_to_destination();
-      return;
-    }
-
-    destination[Z_AXIS] = LINE_SEGMENT_END(Z);
-    destination[E_AXIS] = LINE_SEGMENT_END(E);
-
-    // Do the split and look for more borders
-    bilinear_line_to_destination(fr_mm_s, x_splits, y_splits);
-
-    // Restore destination from stack
-    COPY(destination, end);
-    bilinear_line_to_destination(fr_mm_s, x_splits, y_splits);
-  }
-
-#endif // AUTO_BED_LEVELING_BILINEAR
-
-#if IS_KINEMATIC && !UBL_DELTA
-
-  /**
-   * Prepare a linear move in a DELTA or SCARA setup.
-   *
-   * This calls planner.buffer_line several times, adding
-   * small incremental moves for DELTA or SCARA.
-   */
-  inline bool prepare_kinematic_move_to(float ltarget[XYZE]) {
-
-    // Get the top feedrate of the move in the XY plane
-    const float _feedrate_mm_s = MMS_SCALED(feedrate_mm_s);
-
-    // If the move is only in Z/E don't split up the move
-    if (ltarget[X_AXIS] == current_position[X_AXIS] && ltarget[Y_AXIS] == current_position[Y_AXIS]) {
-      planner.buffer_line_kinematic(ltarget, _feedrate_mm_s, active_extruder);
-      return false;
-    }
-
-    // Fail if attempting move outside printable radius
-    if (!position_is_reachable_xy(ltarget[X_AXIS], ltarget[Y_AXIS])) return true;
-
-    // Get the cartesian distances moved in XYZE
-    const float difference[XYZE] = {
-      ltarget[X_AXIS] - current_position[X_AXIS],
-      ltarget[Y_AXIS] - current_position[Y_AXIS],
-      ltarget[Z_AXIS] - current_position[Z_AXIS],
-      ltarget[E_AXIS] - current_position[E_AXIS]
-    };
-
-    // Get the linear distance in XYZ
-    float cartesian_mm = SQRT(sq(difference[X_AXIS]) + sq(difference[Y_AXIS]) + sq(difference[Z_AXIS]));
-
-    // If the move is very short, check the E move distance
-    if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = FABS(difference[E_AXIS]);
-
-    // No E move either? Game over.
-    if (UNEAR_ZERO(cartesian_mm)) return true;
-
-    // Minimum number of seconds to move the given distance
-    const float seconds = cartesian_mm / _feedrate_mm_s;
-
-    // The number of segments-per-second times the duration
-    // gives the number of segments
-    uint16_t segments = delta_segments_per_second * seconds;
-
-    // For SCARA minimum segment size is 0.25mm
-    #if IS_SCARA
-      NOMORE(segments, cartesian_mm * 4);
-    #endif
-
-    // At least one segment is required
-    NOLESS(segments, 1);
-
-    // The approximate length of each segment
-    const float inv_segments = 1.0 / float(segments),
-                segment_distance[XYZE] = {
-                  difference[X_AXIS] * inv_segments,
-                  difference[Y_AXIS] * inv_segments,
-                  difference[Z_AXIS] * inv_segments,
-                  difference[E_AXIS] * inv_segments
-                };
-
-    // SERIAL_ECHOPAIR("mm=", cartesian_mm);
-    // SERIAL_ECHOPAIR(" seconds=", seconds);
-    // SERIAL_ECHOLNPAIR(" segments=", segments);
-
-    #if IS_SCARA && ENABLED(SCARA_FEEDRATE_SCALING)
-      // SCARA needs to scale the feed rate from mm/s to degrees/s
-      const float inv_segment_length = min(10.0, float(segments) / cartesian_mm), // 1/mm/segs
-                  feed_factor = inv_segment_length * _feedrate_mm_s;
-      float oldA = stepper.get_axis_position_degrees(A_AXIS),
-            oldB = stepper.get_axis_position_degrees(B_AXIS);
-    #endif
-
-    // Get the logical current position as starting point
-    float logical[XYZE];
-    COPY(logical, current_position);
-
-    // Drop one segment so the last move is to the exact target.
-    // If there's only 1 segment, loops will be skipped entirely.
-    --segments;
-
-    // Calculate and execute the segments
-    for (uint16_t s = segments + 1; --s;) {
-      LOOP_XYZE(i) logical[i] += segment_distance[i];
-      #if ENABLED(DELTA)
-        DELTA_LOGICAL_IK(); // Delta can inline its kinematics
-      #else
-        inverse_kinematics(logical);
-      #endif
-
-      ADJUST_DELTA(logical); // Adjust Z if bed leveling is enabled
-
-      #if IS_SCARA && ENABLED(SCARA_FEEDRATE_SCALING)
-        // For SCARA scale the feed rate from mm/s to degrees/s
-        // Use ratio between the length of the move and the larger angle change
-        const float adiff = abs(delta[A_AXIS] - oldA),
-                    bdiff = abs(delta[B_AXIS] - oldB);
-        planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], logical[E_AXIS], max(adiff, bdiff) * feed_factor, active_extruder);
-        oldA = delta[A_AXIS];
-        oldB = delta[B_AXIS];
-      #else
-        planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], logical[E_AXIS], _feedrate_mm_s, active_extruder);
-      #endif
-    }
-
-    // Since segment_distance is only approximate,
-    // the final move must be to the exact destination.
-
-    #if IS_SCARA && ENABLED(SCARA_FEEDRATE_SCALING)
-      // For SCARA scale the feed rate from mm/s to degrees/s
-      // With segments > 1 length is 1 segment, otherwise total length
-      inverse_kinematics(ltarget);
-      ADJUST_DELTA(ltarget);
-      const float adiff = abs(delta[A_AXIS] - oldA),
-                  bdiff = abs(delta[B_AXIS] - oldB);
-      planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], logical[E_AXIS], max(adiff, bdiff) * feed_factor, active_extruder);
-    #else
-      planner.buffer_line_kinematic(ltarget, _feedrate_mm_s, active_extruder);
-    #endif
-
-    return false;
-  }
-
-#else // !IS_KINEMATIC || UBL_DELTA
-
-  /**
-   * Prepare a linear move in a Cartesian setup.
-   * If Mesh Bed Leveling is enabled, perform a mesh move.
-   *
-   * Returns true if the caller didn't update current_position.
-   */
-  inline bool prepare_move_to_destination_cartesian() {
-    #if ENABLED(AUTO_BED_LEVELING_UBL)
-      const float fr_scaled = MMS_SCALED(feedrate_mm_s);
-      if (ubl.state.active) { // direct use of ubl.state.active for speed
-        ubl.line_to_destination_cartesian(fr_scaled, active_extruder);
-        return true;
-      }
-      else
-        line_to_destination(fr_scaled);
-    #else
-      // Do not use feedrate_percentage for E or Z only moves
-      if (current_position[X_AXIS] == destination[X_AXIS] && current_position[Y_AXIS] == destination[Y_AXIS])
-        line_to_destination();
-      else {
-        const float fr_scaled = MMS_SCALED(feedrate_mm_s);
-        #if ENABLED(MESH_BED_LEVELING)
-          if (mbl.active()) { // direct used of mbl.active() for speed
-            mesh_line_to_destination(fr_scaled);
-            return true;
-          }
-          else
-        #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
-          if (planner.abl_enabled) { // direct use of abl_enabled for speed
-            bilinear_line_to_destination(fr_scaled);
-            return true;
-          }
-          else
-        #endif
-            line_to_destination(fr_scaled);
-      }
-    #endif
-    return false;
-  }
-
-#endif // !IS_KINEMATIC || UBL_DELTA
-
-#if ENABLED(DUAL_X_CARRIAGE)
-
-  /**
-   * Prepare a linear move in a dual X axis setup
-   */
-  inline bool prepare_move_to_destination_dualx() {
-    if (active_extruder_parked) {
-      switch (dual_x_carriage_mode) {
-        case DXC_FULL_CONTROL_MODE:
-          break;
-        case DXC_AUTO_PARK_MODE:
-          if (current_position[E_AXIS] == destination[E_AXIS]) {
-            // This is a travel move (with no extrusion)
-            // Skip it, but keep track of the current position
-            // (so it can be used as the start of the next non-travel move)
-            if (delayed_move_time != 0xFFFFFFFFUL) {
-              set_current_to_destination();
-              NOLESS(raised_parked_position[Z_AXIS], destination[Z_AXIS]);
-              delayed_move_time = millis();
-              return true;
-            }
-          }
-          // unpark extruder: 1) raise, 2) move into starting XY position, 3) lower
-          for (uint8_t i = 0; i < 3; i++)
-            planner.buffer_line(
-              i == 0 ? raised_parked_position[X_AXIS] : current_position[X_AXIS],
-              i == 0 ? raised_parked_position[Y_AXIS] : current_position[Y_AXIS],
-              i == 2 ? current_position[Z_AXIS] : raised_parked_position[Z_AXIS],
-              current_position[E_AXIS],
-              i == 1 ? PLANNER_XY_FEEDRATE() : planner.max_feedrate_mm_s[Z_AXIS],
-              active_extruder
-            );
-          delayed_move_time = 0;
-          active_extruder_parked = false;
-          #if ENABLED(DEBUG_LEVELING_FEATURE)
-            if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Clear active_extruder_parked");
-          #endif
-          break;
-        case DXC_DUPLICATION_MODE:
-          if (active_extruder == 0) {
-            #if ENABLED(DEBUG_LEVELING_FEATURE)
-              if (DEBUGGING(LEVELING)) {
-                SERIAL_ECHOPAIR("Set planner X", LOGICAL_X_POSITION(inactive_extruder_x_pos));
-                SERIAL_ECHOLNPAIR(" ... Line to X", current_position[X_AXIS] + duplicate_extruder_x_offset);
-              }
-            #endif
-            // move duplicate extruder into correct duplication position.
-            planner.set_position_mm(
-              LOGICAL_X_POSITION(inactive_extruder_x_pos),
-              current_position[Y_AXIS],
-              current_position[Z_AXIS],
-              current_position[E_AXIS]
-            );
-            planner.buffer_line(
-              current_position[X_AXIS] + duplicate_extruder_x_offset,
-              current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS],
-              planner.max_feedrate_mm_s[X_AXIS], 1
-            );
-            SYNC_PLAN_POSITION_KINEMATIC();
-            stepper.synchronize();
-            extruder_duplication_enabled = true;
-            active_extruder_parked = false;
-            #if ENABLED(DEBUG_LEVELING_FEATURE)
-              if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Set extruder_duplication_enabled\nClear active_extruder_parked");
-            #endif
-          }
-          else {
-            #if ENABLED(DEBUG_LEVELING_FEATURE)
-              if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Active extruder not 0");
-            #endif
-          }
-          break;
-      }
-    }
-    return false;
-  }
-
-#endif // DUAL_X_CARRIAGE
-
-/**
- * Prepare a single move and get ready for the next one
- *
- * This may result in several calls to planner.buffer_line to
- * do smaller moves for DELTA, SCARA, mesh moves, etc.
- */
-void prepare_move_to_destination() {
-  clamp_to_software_endstops(destination);
-  refresh_cmd_timeout();
-
-  #if ENABLED(PREVENT_COLD_EXTRUSION)
-
-    if (!DEBUGGING(DRYRUN)) {
-      if (destination[E_AXIS] != current_position[E_AXIS]) {
-        if (thermalManager.tooColdToExtrude(active_extruder)) {
-          current_position[E_AXIS] = destination[E_AXIS]; // Behave as if the move really took place, but ignore E part
-          SERIAL_ECHO_START();
-          SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
-        }
-        #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
-          if (destination[E_AXIS] - current_position[E_AXIS] > EXTRUDE_MAXLENGTH) {
-            current_position[E_AXIS] = destination[E_AXIS]; // Behave as if the move really took place, but ignore E part
-            SERIAL_ECHO_START();
-            SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
-          }
-        #endif
-      }
-    }
-
-  #endif
-
-  if (
-    #if UBL_DELTA // Also works for CARTESIAN (smaller segments follow mesh more closely)
-      ubl.prepare_segmented_line_to(destination, feedrate_mm_s)
-    #elif IS_KINEMATIC
-      prepare_kinematic_move_to(destination)
-    #elif ENABLED(DUAL_X_CARRIAGE)
-      prepare_move_to_destination_dualx() || prepare_move_to_destination_cartesian()
-    #else
-      prepare_move_to_destination_cartesian()
-    #endif
-  ) return;
-
-  set_current_to_destination();
-}
-
 #if ENABLED(USE_CONTROLLER_FAN)
 
   void controllerFan() {
     static millis_t lastMotorOn = 0, // Last time a motor was turned on
                     nextMotorCheck = 0; // Last time the state was checked
     const millis_t ms = millis();
     if (ELAPSED(ms, nextMotorCheck)) {
       nextMotorCheck = ms + 2500UL; // Not a time critical function, so only check every 2.5s
       if (X_ENABLE_READ == X_ENABLE_ON || Y_ENABLE_READ == Y_ENABLE_ON || Z_ENABLE_READ == Z_ENABLE_ON || thermalManager.soft_pwm_amount_bed > 0
           || E0_ENABLE_READ == E_ENABLE_ON // If any of the drivers are enabled...
@@ -4833,21 +3748,21 @@ void manage_inactivity(bool ignore_stepper_queue/*=false*/) {
                 case 3: oldstatus = E3_ENABLE_READ; enable_E3(); break;
                 #if E_STEPPERS > 4
                   case 4: oldstatus = E4_ENABLE_READ; enable_E4(); break;
                 #endif // E_STEPPERS > 4
               #endif // E_STEPPERS > 3
             #endif // E_STEPPERS > 2
           #endif // E_STEPPERS > 1
         }
       #endif // !SWITCHING_EXTRUDER
 
-      previous_cmd_ms = ms; // refresh_cmd_timeout()
+      gcode.refresh_cmd_timeout()
 
       const float olde = current_position[E_AXIS];
       current_position[E_AXIS] += EXTRUDER_RUNOUT_EXTRUDE;
       planner.buffer_line_kinematic(current_position, MMM_TO_MMS(EXTRUDER_RUNOUT_SPEED), active_extruder);
       current_position[E_AXIS] = olde;
       planner.set_e_position_mm(olde);
       stepper.synchronize();
       #if ENABLED(SWITCHING_EXTRUDER)
         E0_ENABLE_WRITE(oldstatus);
       #else
@@ -5069,22 +3984,21 @@ void setup() {
     SERIAL_ECHOPGM(STRING_DISTRIBUTION_DATE);
     SERIAL_ECHOLNPGM(MSG_AUTHOR STRING_CONFIG_H_AUTHOR);
     SERIAL_ECHO_START();
     SERIAL_ECHOLNPGM("Compiled: " __DATE__);
   #endif
 
   SERIAL_ECHO_START();
   SERIAL_ECHOPAIR(MSG_FREE_MEMORY, freeMemory());
   SERIAL_ECHOLNPAIR(MSG_PLANNER_BUFFER_BYTES, (int)sizeof(block_t)*BLOCK_BUFFER_SIZE);
 
-  // Send "ok" after commands by default
-  for (int8_t i = 0; i < BUFSIZE; i++) send_ok[i] = true;
+  queue_setup();
 
   // Load data from EEPROM if available (or use defaults)
   // This also updates variables in the planner, elsewhere
   (void)settings.load();
 
   #if HAS_M206_COMMAND
     // Initialize current position based on home_offset
     COPY(current_position, home_offset);
   #else
     ZERO(current_position);
@@ -5258,49 +4172,15 @@ void setup() {
  *  - Call endstop manager
  *  - Call LCD update
  */
 void loop() {
   if (commands_in_queue < BUFSIZE) get_available_commands();
 
   #if ENABLED(SDSUPPORT)
     card.checkautostart(false);
   #endif
 
-  if (commands_in_queue) {
+  advance_command_queue();
 
-    #if ENABLED(SDSUPPORT)
-
-      if (card.saving) {
-        char* command = command_queue[cmd_queue_index_r];
-        if (strstr_P(command, PSTR("M29"))) {
-          // M29 closes the file
-          card.closefile();
-          SERIAL_PROTOCOLLNPGM(MSG_FILE_SAVED);
-          ok_to_send();
-        }
-        else {
-          // Write the string from the read buffer to SD
-          card.write_command(command);
-          if (card.logging)
-            process_next_command(); // The card is saving because it's logging
-          else
-            ok_to_send();
-        }
-      }
-      else
-        process_next_command();
-
-    #else
-
-      process_next_command();
-
-    #endif // SDSUPPORT
-
-    // The queue may be reset by a command handler or by code invoked by idle() within a handler
-    if (commands_in_queue) {
-      --commands_in_queue;
-      if (++cmd_queue_index_r >= BUFSIZE) cmd_queue_index_r = 0;
-    }
-  }
   endstops.report_state();
   idle();
 }

commit 4231faf7796ca8adb9ca861b014b65e79f67b376
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 6 06:28:31 2017 -0500

    Initial split-up of G-code handlers by category

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index a432eead00..6eb0ee164d 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -18,234 +18,21 @@
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
 /**
  * About Marlin
  *
  * This firmware is a mashup between Sprinter and grbl.
  *  - https://github.com/kliment/Sprinter
- *  - https://github.com/simen/grbl/tree
- */
-
-/**
- * -----------------
- * G-Codes in Marlin
- * -----------------
- *
- * Helpful G-code references:
- *  - http://linuxcnc.org/handbook/gcode/g-code.html
- *  - http://objects.reprap.org/wiki/Mendel_User_Manual:_RepRapGCodes
- *
- * Help to document Marlin's G-codes online:
- *  - http://reprap.org/wiki/G-code
- *  - https://github.com/MarlinFirmware/MarlinDocumentation
- *
- * -----------------
- *
- * "G" Codes
- *
- * G0   -> G1
- * G1   - Coordinated Movement X Y Z E
- * G2   - CW ARC
- * G3   - CCW ARC
- * G4   - Dwell S<seconds> or P<milliseconds>
- * G5   - Cubic B-spline with XYZE destination and IJPQ offsets
- * G10  - Retract filament according to settings of M207 (Requires FWRETRACT)
- * G11  - Retract recover filament according to settings of M208 (Requires FWRETRACT)
- * G12  - Clean tool (Requires NOZZLE_CLEAN_FEATURE)
- * G17  - Select Plane XY (Requires CNC_WORKSPACE_PLANES)
- * G18  - Select Plane ZX (Requires CNC_WORKSPACE_PLANES)
- * G19  - Select Plane YZ (Requires CNC_WORKSPACE_PLANES)
- * G20  - Set input units to inches (Requires INCH_MODE_SUPPORT)
- * G21  - Set input units to millimeters (Requires INCH_MODE_SUPPORT)
- * G26  - Mesh Validation Pattern (Requires UBL_G26_MESH_VALIDATION)
- * G27  - Park Nozzle (Requires NOZZLE_PARK_FEATURE)
- * G28  - Home one or more axes
- * G29  - Start or continue the bed leveling probe procedure (Requires bed leveling)
- * G30  - Single Z probe, probes bed at X Y location (defaults to current XY location)
- * G31  - Dock sled (Z_PROBE_SLED only)
- * G32  - Undock sled (Z_PROBE_SLED only)
- * G33  - Delta Auto-Calibration (Requires DELTA_AUTO_CALIBRATION)
- * G38  - Probe in any direction using the Z_MIN_PROBE (Requires G38_PROBE_TARGET)
- * G42  - Coordinated move to a mesh point (Requires AUTO_BED_LEVELING_UBL)
- * G90  - Use Absolute Coordinates
- * G91  - Use Relative Coordinates
- * G92  - Set current position to coordinates given
- *
- * "M" Codes
- *
- * M0   - Unconditional stop - Wait for user to press a button on the LCD (Only if ULTRA_LCD is enabled)
- * M1   -> M0
- * M3   - Turn laser/spindle on, set spindle/laser speed/power, set rotation to clockwise
- * M4   - Turn laser/spindle on, set spindle/laser speed/power, set rotation to counter-clockwise
- * M5   - Turn laser/spindle off
- * M17  - Enable/Power all stepper motors
- * M18  - Disable all stepper motors; same as M84
- * M20  - List SD card. (Requires SDSUPPORT)
- * M21  - Init SD card. (Requires SDSUPPORT)
- * M22  - Release SD card. (Requires SDSUPPORT)
- * M23  - Select SD file: "M23 /path/file.gco". (Requires SDSUPPORT)
- * M24  - Start/resume SD print. (Requires SDSUPPORT)
- * M25  - Pause SD print. (Requires SDSUPPORT)
- * M26  - Set SD position in bytes: "M26 S12345". (Requires SDSUPPORT)
- * M27  - Report SD print status. (Requires SDSUPPORT)
- * M28  - Start SD write: "M28 /path/file.gco". (Requires SDSUPPORT)
- * M29  - Stop SD write. (Requires SDSUPPORT)
- * M30  - Delete file from SD: "M30 /path/file.gco"
- * M31  - Report time since last M109 or SD card start to serial.
- * M32  - Select file and start SD print: "M32 [S<bytepos>] !/path/file.gco#". (Requires SDSUPPORT)
- *        Use P to run other files as sub-programs: "M32 P !filename#"
- *        The '#' is necessary when calling from within sd files, as it stops buffer prereading
- * M33  - Get the longname version of a path. (Requires LONG_FILENAME_HOST_SUPPORT)
- * M34  - Set SD Card sorting options. (Requires SDCARD_SORT_ALPHA)
- * M42  - Change pin status via gcode: M42 P<pin> S<value>. LED pin assumed if P is omitted.
- * M43  - Display pin status, watch pins for changes, watch endstops & toggle LED, Z servo probe test, toggle pins
- * M48  - Measure Z Probe repeatability: M48 P<points> X<pos> Y<pos> V<level> E<engage> L<legs>. (Requires Z_MIN_PROBE_REPEATABILITY_TEST)
- * M75  - Start the print job timer.
- * M76  - Pause the print job timer.
- * M77  - Stop the print job timer.
- * M78  - Show statistical information about the print jobs. (Requires PRINTCOUNTER)
- * M80  - Turn on Power Supply. (Requires POWER_SUPPLY > 0)
- * M81  - Turn off Power Supply. (Requires POWER_SUPPLY > 0)
- * M82  - Set E codes absolute (default).
- * M83  - Set E codes relative while in Absolute (G90) mode.
- * M84  - Disable steppers until next move, or use S<seconds> to specify an idle
- *        duration after which steppers should turn off. S0 disables the timeout.
- * M85  - Set inactivity shutdown timer with parameter S<seconds>. To disable set zero (default)
- * M92  - Set planner.axis_steps_per_mm for one or more axes.
- * M100 - Watch Free Memory (for debugging) (Requires M100_FREE_MEMORY_WATCHER)
- * M104 - Set extruder target temp.
- * M105 - Report current temperatures.
- * M106 - Fan on.
- * M107 - Fan off.
- * M108 - Break out of heating loops (M109, M190, M303). With no controller, breaks out of M0/M1. (Requires EMERGENCY_PARSER)
- * M109 - Sxxx Wait for extruder current temp to reach target temp. Waits only when heating
- *        Rxxx Wait for extruder current temp to reach target temp. Waits when heating and cooling
- *        If AUTOTEMP is enabled, S<mintemp> B<maxtemp> F<factor>. Exit autotemp by any M109 without F
- * M110 - Set the current line number. (Used by host printing)
- * M111 - Set debug flags: "M111 S<flagbits>". See flag bits defined in enum.h.
- * M112 - Emergency stop.
- * M113 - Get or set the timeout interval for Host Keepalive "busy" messages. (Requires HOST_KEEPALIVE_FEATURE)
- * M114 - Report current position.
- * M115 - Report capabilities. (Extended capabilities requires EXTENDED_CAPABILITIES_REPORT)
- * M117 - Display a message on the controller screen. (Requires an LCD)
- * M118 - Display a message in the host console.
- * M119 - Report endstops status.
- * M120 - Enable endstops detection.
- * M121 - Disable endstops detection.
- * M125 - Save current position and move to filament change position. (Requires PARK_HEAD_ON_PAUSE)
- * M126 - Solenoid Air Valve Open. (Requires BARICUDA)
- * M127 - Solenoid Air Valve Closed. (Requires BARICUDA)
- * M128 - EtoP Open. (Requires BARICUDA)
- * M129 - EtoP Closed. (Requires BARICUDA)
- * M140 - Set bed target temp. S<temp>
- * M145 - Set heatup values for materials on the LCD. H<hotend> B<bed> F<fan speed> for S<material> (0=PLA, 1=ABS)
- * M149 - Set temperature units. (Requires TEMPERATURE_UNITS_SUPPORT)
- * M150 - Set Status LED Color as R<red> U<green> B<blue>. Values 0-255. (Requires BLINKM, RGB_LED, RGBW_LED, or PCA9632)
- * M155 - Auto-report temperatures with interval of S<seconds>. (Requires AUTO_REPORT_TEMPERATURES)
- * M163 - Set a single proportion for a mixing extruder. (Requires MIXING_EXTRUDER)
- * M164 - Save the mix as a virtual extruder. (Requires MIXING_EXTRUDER and MIXING_VIRTUAL_TOOLS)
- * M165 - Set the proportions for a mixing extruder. Use parameters ABCDHI to set the mixing factors. (Requires MIXING_EXTRUDER)
- * M190 - Sxxx Wait for bed current temp to reach target temp. ** Waits only when heating! **
- *        Rxxx Wait for bed current temp to reach target temp. ** Waits for heating or cooling. **
- * M200 - Set filament diameter, D<diameter>, setting E axis units to cubic. (Use S0 to revert to linear units.)
- * M201 - Set max acceleration in units/s^2 for print moves: "M201 X<accel> Y<accel> Z<accel> E<accel>"
- * M202 - Set max acceleration in units/s^2 for travel moves: "M202 X<accel> Y<accel> Z<accel> E<accel>" ** UNUSED IN MARLIN! **
- * M203 - Set maximum feedrate: "M203 X<fr> Y<fr> Z<fr> E<fr>" in units/sec.
- * M204 - Set default acceleration in units/sec^2: P<printing> R<extruder_only> T<travel>
- * M205 - Set advanced settings. Current units apply:
-            S<print> T<travel> minimum speeds
-            B<minimum segment time>
-            X<max X jerk>, Y<max Y jerk>, Z<max Z jerk>, E<max E jerk>
- * M206 - Set additional homing offset. (Disabled by NO_WORKSPACE_OFFSETS or DELTA)
- * M207 - Set Retract Length: S<length>, Feedrate: F<units/min>, and Z lift: Z<distance>. (Requires FWRETRACT)
- * M208 - Set Recover (unretract) Additional (!) Length: S<length> and Feedrate: F<units/min>. (Requires FWRETRACT)
- * M209 - Turn Automatic Retract Detection on/off: S<0|1> (For slicers that don't support G10/11). (Requires FWRETRACT)
-          Every normal extrude-only move will be classified as retract depending on the direction.
- * M211 - Enable, Disable, and/or Report software endstops: S<0|1> (Requires MIN_SOFTWARE_ENDSTOPS or MAX_SOFTWARE_ENDSTOPS)
- * M218 - Set a tool offset: "M218 T<index> X<offset> Y<offset>". (Requires 2 or more extruders)
- * M220 - Set Feedrate Percentage: "M220 S<percent>" (i.e., "FR" on the LCD)
- * M221 - Set Flow Percentage: "M221 S<percent>"
- * M226 - Wait until a pin is in a given state: "M226 P<pin> S<state>"
- * M240 - Trigger a camera to take a photograph. (Requires CHDK or PHOTOGRAPH_PIN)
- * M250 - Set LCD contrast: "M250 C<contrast>" (0-63). (Requires LCD support)
- * M260 - i2c Send Data (Requires EXPERIMENTAL_I2CBUS)
- * M261 - i2c Request Data (Requires EXPERIMENTAL_I2CBUS)
- * M280 - Set servo position absolute: "M280 P<index> S<angle|µs>". (Requires servos)
- * M300 - Play beep sound S<frequency Hz> P<duration ms>
- * M301 - Set PID parameters P I and D. (Requires PIDTEMP)
- * M302 - Allow cold extrudes, or set the minimum extrude S<temperature>. (Requires PREVENT_COLD_EXTRUSION)
- * M303 - PID relay autotune S<temperature> sets the target temperature. Default 150C. (Requires PIDTEMP)
- * M304 - Set bed PID parameters P I and D. (Requires PIDTEMPBED)
- * M350 - Set microstepping mode. (Requires digital microstepping pins.)
- * M351 - Toggle MS1 MS2 pins directly. (Requires digital microstepping pins.)
- * M355 - Set Case Light on/off and set brightness. (Requires CASE_LIGHT_PIN)
- * M380 - Activate solenoid on active extruder. (Requires EXT_SOLENOID)
- * M381 - Disable all solenoids. (Requires EXT_SOLENOID)
- * M400 - Finish all moves.
- * M401 - Lower Z probe. (Requires a probe)
- * M402 - Raise Z probe. (Requires a probe)
- * M404 - Display or set the Nominal Filament Width: "W<diameter>". (Requires FILAMENT_WIDTH_SENSOR)
- * M405 - Enable Filament Sensor flow control. "M405 D<delay_cm>". (Requires FILAMENT_WIDTH_SENSOR)
- * M406 - Disable Filament Sensor flow control. (Requires FILAMENT_WIDTH_SENSOR)
- * M407 - Display measured filament diameter in millimeters. (Requires FILAMENT_WIDTH_SENSOR)
- * M410 - Quickstop. Abort all planned moves.
- * M420 - Enable/Disable Leveling (with current values) S1=enable S0=disable (Requires MESH_BED_LEVELING or ABL)
- * M421 - Set a single Z coordinate in the Mesh Leveling grid. X<units> Y<units> Z<units> (Requires MESH_BED_LEVELING or AUTO_BED_LEVELING_UBL)
- * M428 - Set the home_offset based on the current_position. Nearest edge applies. (Disabled by NO_WORKSPACE_OFFSETS or DELTA)
- * M500 - Store parameters in EEPROM. (Requires EEPROM_SETTINGS)
- * M501 - Restore parameters from EEPROM. (Requires EEPROM_SETTINGS)
- * M502 - Revert to the default "factory settings". ** Does not write them to EEPROM! **
- * M503 - Print the current settings (in memory): "M503 S<verbose>". S0 specifies compact output.
- * M540 - Enable/disable SD card abort on endstop hit: "M540 S<state>". (Requires ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
- * M600 - Pause for filament change: "M600 X<pos> Y<pos> Z<raise> E<first_retract> L<later_retract>". (Requires ADVANCED_PAUSE_FEATURE)
- * M665 - Set delta configurations: "M665 L<diagonal rod> R<delta radius> S<segments/s> A<rod A trim mm> B<rod B trim mm> C<rod C trim mm> I<tower A trim angle> J<tower B trim angle> K<tower C trim angle>" (Requires DELTA)
- * M666 - Set delta endstop adjustment. (Requires DELTA)
- * M605 - Set dual x-carriage movement mode: "M605 S<mode> [X<x_offset>] [R<temp_offset>]". (Requires DUAL_X_CARRIAGE)
- * M851 - Set Z probe's Z offset in current units. (Negative = below the nozzle.)
- * M860 - Report the position of position encoder modules.
- * M861 - Report the status of position encoder modules.
- * M862 - Perform an axis continuity test for position encoder modules.
- * M863 - Perform steps-per-mm calibration for position encoder modules.
- * M864 - Change position encoder module I2C address.
- * M865 - Check position encoder module firmware version.
- * M866 - Report or reset position encoder module error count.
- * M867 - Enable/disable or toggle error correction for position encoder modules.
- * M868 - Report or set position encoder module error correction threshold.
- * M869 - Report position encoder module error.
- * M900 - Get and/or Set advance K factor and WH/D ratio. (Requires LIN_ADVANCE)
- * M906 - Set or get motor current in milliamps using axis codes X, Y, Z, E. Report values if no axis codes given. (Requires HAVE_TMC2130)
- * M907 - Set digital trimpot motor current using axis codes. (Requires a board with digital trimpots)
- * M908 - Control digital trimpot directly. (Requires DAC_STEPPER_CURRENT or DIGIPOTSS_PIN)
- * M909 - Print digipot/DAC current value. (Requires DAC_STEPPER_CURRENT)
- * M910 - Commit digipot/DAC value to external EEPROM via I2C. (Requires DAC_STEPPER_CURRENT)
- * M911 - Report stepper driver overtemperature pre-warn condition. (Requires HAVE_TMC2130)
- * M912 - Clear stepper driver overtemperature pre-warn condition flag. (Requires HAVE_TMC2130)
- * M913 - Set HYBRID_THRESHOLD speed. (Requires HYBRID_THRESHOLD)
- * M914 - Set SENSORLESS_HOMING sensitivity. (Requires SENSORLESS_HOMING)
- *
- * M360 - SCARA calibration: Move to cal-position ThetaA (0 deg calibration)
- * M361 - SCARA calibration: Move to cal-position ThetaB (90 deg calibration - steps per degree)
- * M362 - SCARA calibration: Move to cal-position PsiA (0 deg calibration)
- * M363 - SCARA calibration: Move to cal-position PsiB (90 deg calibration - steps per degree)
- * M364 - SCARA calibration: Move to cal-position PSIC (90 deg to Theta calibration position)
- *
- * ************ Custom codes - This can change to suit future G-code regulations
- * M928 - Start SD logging: "M928 filename.gco". Stop with M29. (Requires SDSUPPORT)
- * M999 - Restart after being stopped by error
- *
- * "T" Codes
- *
- * T0-T3 - Select an extruder (tool) by index: "T<n> F<units/min>"
- *
+ *  - https://github.com/simen/grbl
  */
 
 #include "Marlin.h"
 
 #include "lcd/ultralcd.h"
 #include "module/planner.h"
 #include "module/stepper.h"
 #include "module/endstops.h"
 #include "module/temperature.h"
 #include "sd/cardreader.h"
@@ -309,21 +96,20 @@
 
 #if ENABLED(I2C_POSITION_ENCODERS)
   #include "feature/I2CPositionEncoder.h"
 #endif
 
 #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
   #include "HAL/HAL_endstop_interrupts.h"
 #endif
 
 #if ENABLED(M100_FREE_MEMORY_WATCHER)
-  void gcode_M100();
   void M100_dump_routine(const char * const title, const char *start, const char *end);
 #endif
 
 #if ENABLED(SDSUPPORT)
   CardReader card;
 #endif
 
 #if ENABLED(EXPERIMENTAL_I2CBUS)
   TWIBus i2c;
 #endif
@@ -337,20 +123,24 @@
   #include "feature/ubl/ubl.h"
   extern bool defer_return_to_status;
   unified_bed_leveling ubl;
   #define UBL_MESH_VALID !( ( ubl.z_values[0][0] == ubl.z_values[0][1] && ubl.z_values[0][1] == ubl.z_values[0][2] \
                            && ubl.z_values[1][0] == ubl.z_values[1][1] && ubl.z_values[1][1] == ubl.z_values[1][2] \
                            && ubl.z_values[2][0] == ubl.z_values[2][1] && ubl.z_values[2][1] == ubl.z_values[2][2] \
                            && ubl.z_values[0][0] == 0 && ubl.z_values[1][0] == 0 && ubl.z_values[2][0] == 0 )  \
                            || isnan(ubl.z_values[0][0]))
 #endif
 
+#if ENABLED(SENSORLESS_HOMING)
+  #include "feature/tmc2130.h"
+#endif
+
 bool Running = true;
 
 /**
  * Cartesian Current Position
  *   Used to track the logical position as moves are queued.
  *   Used by 'line_to_current_position' to do a move after changing it.
  *   Used by 'SYNC_PLAN_POSITION_KINEMATIC' to update 'planner.position'.
  */
 float current_position[XYZE] = { 0.0 };
 
@@ -3321,21 +3111,21 @@ void dwell(millis_t time) {
 
 #if ENABLED(FWRETRACT)
   #include "gcode/feature/fwretract/G10_G11.h"
 #endif
 
 #if ENABLED(NOZZLE_CLEAN_FEATURE)
   #include "gcode/feature/clean/G12.h"
 #endif
 
 #if ENABLED(CNC_WORKSPACE_PLANES)
-  #include "gcode/feature/clean/G17-G19.h"
+  #include "gcode/geometry/G17-G19.h"
 #endif
 
 #if ENABLED(INCH_MODE_SUPPORT)
   #include "gcode/units/G20_G21.h"
 #endif
 
 #if ENABLED(UBL_G26_MESH_VALIDATION)
   #include "gcode/calibrate/G26.h"
 #endif
 
@@ -3725,25 +3515,25 @@ void report_current_position() {
 
 #if ENABLED(PIDTEMP)
   #include "gcode/config/M301.h"
 #endif
 
 #if ENABLED(PIDTEMPBED)
   #include "gcode/config/M304.h"
 #endif
 
 #if defined(CHDK) || HAS_PHOTOGRAPH
-  #include "gcode/control/M240.h"
+  #include "gcode/feature/camera/M240.h"
 #endif
 
 #if HAS_LCD_CONTRAST
-  #include "gcode/control/M250.h"
+  #include "gcode/lcd/M250.h"
 #endif
 
 #if ENABLED(PREVENT_COLD_EXTRUSION)
   #include "gcode/config/M302.h"
 #endif
 
 #include "gcode/temperature/M303.h"
 
 #if ENABLED(MORGAN_SCARA)
   #include "gcode/scara/M360-M364.h"

commit e0a189a481b00826d4ded0cc38580fd5726e4c79
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Sep 14 15:33:07 2017 -0500

    Consolidate Buzzer

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index b14cf9eb70..a432eead00 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -251,37 +251,37 @@
 #include "sd/cardreader.h"
 #include "module/configuration_store.h"
 #ifdef ARDUINO
   #include <pins_arduino.h>
 #endif
 #include <math.h>
 #include "libs/nozzle.h"
 #include "libs/duration_t.h"
 #include "gcode/parser.h"
 
+#if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER)
+  #include "libs/buzzer.h"
+#endif
+
 #if HAS_ABL
   #include "libs/vector_3.h"
   #if ENABLED(AUTO_BED_LEVELING_LINEAR)
     #include "libs/least_squares_fit.h"
   #endif
 #elif ENABLED(MESH_BED_LEVELING)
   #include "feature/mbl/mesh_bed_leveling.h"
 #endif
 
 #if ENABLED(BEZIER_CURVE_SUPPORT)
   #include "module/planner_bezier.h"
 #endif
 
-#if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER)
-  #include "libs/buzzer.h"
-#endif
-
 #if ENABLED(MAX7219_DEBUG)
   #include "feature/leds/Max7219_Debug_LEDs.h"
 #endif
 
 #if ENABLED(NEOPIXEL_RGBW_LED)
   #include <Adafruit_NeoPixel.h>
 #endif
 
 #if ENABLED(BLINKM)
   #include "feature/leds/blinkm.h"
@@ -488,30 +488,20 @@ millis_t previous_cmd_ms = 0;
 static millis_t max_inactive_time = 0;
 static millis_t stepper_inactive_time = (DEFAULT_STEPPER_DEACTIVE_TIME) * 1000UL;
 
 // Print Job Timer
 #if ENABLED(PRINTCOUNTER)
   PrintCounter print_job_timer = PrintCounter();
 #else
   Stopwatch print_job_timer = Stopwatch();
 #endif
 
-// Buzzer - I2C on the LCD or a BEEPER_PIN
-#if ENABLED(LCD_USE_I2C_BUZZER)
-  #define BUZZ(d,f) lcd_buzz(d, f)
-#elif PIN_EXISTS(BEEPER)
-  Buzzer buzzer;
-  #define BUZZ(d,f) buzzer.tone(d, f)
-#else
-  #define BUZZ(d,f) NOOP
-#endif
-
 static uint8_t target_extruder;
 
 #if HAS_BED_PROBE
   float zprobe_zoffset; // Initialized by settings.load()
 #endif
 
 #if HAS_ABL
   float xy_probe_feedrate_mm_s = MMM_TO_MMS(XY_PROBE_SPEED);
   #define XY_PROBE_FEEDRATE_MM_S xy_probe_feedrate_mm_s
 #elif defined(XY_PROBE_SPEED)

commit bca67a5b791de775ebcac99f153484f394f568a6
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 6 06:28:33 2017 -0500

    Main controller updates

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index ffe9cdc868..b14cf9eb70 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -236,93 +236,90 @@
  * M999 - Restart after being stopped by error
  *
  * "T" Codes
  *
  * T0-T3 - Select an extruder (tool) by index: "T<n> F<units/min>"
  *
  */
 
 #include "Marlin.h"
 
-#include "ultralcd.h"
-#include "planner.h"
-#include "stepper.h"
-#include "endstops.h"
-#include "temperature.h"
-#include "cardreader.h"
-#include "configuration_store.h"
-#include "language.h"
+#include "lcd/ultralcd.h"
+#include "module/planner.h"
+#include "module/stepper.h"
+#include "module/endstops.h"
+#include "module/temperature.h"
+#include "sd/cardreader.h"
+#include "module/configuration_store.h"
 #ifdef ARDUINO
-  #include "pins_arduino.h"
+  #include <pins_arduino.h>
 #endif
-#include "math.h"
-#include "nozzle.h"
-#include "duration_t.h"
-#include "types.h"
-#include "gcode.h"
+#include <math.h>
+#include "libs/nozzle.h"
+#include "libs/duration_t.h"
+#include "gcode/parser.h"
 
 #if HAS_ABL
-  #include "vector_3.h"
+  #include "libs/vector_3.h"
   #if ENABLED(AUTO_BED_LEVELING_LINEAR)
-    #include "least_squares_fit.h"
+    #include "libs/least_squares_fit.h"
   #endif
 #elif ENABLED(MESH_BED_LEVELING)
-  #include "mesh_bed_leveling.h"
+  #include "feature/mbl/mesh_bed_leveling.h"
 #endif
 
 #if ENABLED(BEZIER_CURVE_SUPPORT)
-  #include "planner_bezier.h"
+  #include "module/planner_bezier.h"
 #endif
 
 #if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER)
-  #include "buzzer.h"
+  #include "libs/buzzer.h"
 #endif
 
 #if ENABLED(MAX7219_DEBUG)
-  #include "Max7219_Debug_LEDs.h"
+  #include "feature/leds/Max7219_Debug_LEDs.h"
 #endif
 
 #if ENABLED(NEOPIXEL_RGBW_LED)
   #include <Adafruit_NeoPixel.h>
 #endif
 
 #if ENABLED(BLINKM)
-  #include "blinkm.h"
-  #include "Wire.h"
+  #include "feature/leds/blinkm.h"
 #endif
 
 #if ENABLED(PCA9632)
-  #include "pca9632.h"
+  #include "feature/leds/pca9632.h"
 #endif
 
 #if HAS_SERVOS
-  #include "src/HAL/servo.h"
+  #include "HAL/servo.h"
 #endif
 
 #if HAS_DIGIPOTSS
   #include <SPI.h>
 #endif
 
 #if ENABLED(DAC_STEPPER_CURRENT)
-  #include "stepper_dac.h"
+  #include "feature/dac/stepper_dac.h"
 #endif
 
 #if ENABLED(EXPERIMENTAL_I2CBUS)
-  #include "twibus.h"
+  #include "feature/twibus.h"
 #endif
 
 #if ENABLED(I2C_POSITION_ENCODERS)
-  #include "I2CPositionEncoder.h"
+  #include "feature/I2CPositionEncoder.h"
 #endif
 
 #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-  #include "src/HAL/HAL_endstop_interrupts.h"
+  #include "HAL/HAL_endstop_interrupts.h"
 #endif
 
 #if ENABLED(M100_FREE_MEMORY_WATCHER)
   void gcode_M100();
   void M100_dump_routine(const char * const title, const char *start, const char *end);
 #endif
 
 #if ENABLED(SDSUPPORT)
   CardReader card;
 #endif
@@ -330,21 +327,21 @@
 #if ENABLED(EXPERIMENTAL_I2CBUS)
   TWIBus i2c;
 #endif
 
 #if ENABLED(G38_PROBE_TARGET)
   bool G38_move = false,
        G38_endstop_hit = false;
 #endif
 
 #if ENABLED(AUTO_BED_LEVELING_UBL)
-  #include "ubl.h"
+  #include "feature/ubl/ubl.h"
   extern bool defer_return_to_status;
   unified_bed_leveling ubl;
   #define UBL_MESH_VALID !( ( ubl.z_values[0][0] == ubl.z_values[0][1] && ubl.z_values[0][1] == ubl.z_values[0][2] \
                            && ubl.z_values[1][0] == ubl.z_values[1][1] && ubl.z_values[1][1] == ubl.z_values[1][2] \
                            && ubl.z_values[2][0] == ubl.z_values[2][1] && ubl.z_values[2][1] == ubl.z_values[2][2] \
                            && ubl.z_values[0][0] == 0 && ubl.z_values[1][0] == 0 && ubl.z_values[2][0] == 0 )  \
                            || isnan(ubl.z_values[0][0]))
 #endif
 
 bool Running = true;
@@ -655,24 +652,20 @@ static bool send_ok[BUFSIZE];
     #define DEPLOY_Z_SERVO() MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[0])
     #define STOW_Z_SERVO() MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[1])
   #endif
 #endif
 
 #ifdef CHDK
   millis_t chdkHigh = 0;
   bool chdkActive = false;
 #endif
 
-#ifdef AUTOMATIC_CURRENT_CONTROL
-  bool auto_current_control = 0;
-#endif
-
 #if ENABLED(PID_EXTRUSION_SCALING)
   int lpq_len = 20;
 #endif
 
 #if ENABLED(HOST_KEEPALIVE_FEATURE)
   MarlinBusyState busy_state = NOT_BUSY;
   static millis_t next_busy_signal_ms = 0;
   uint8_t host_keepalive_interval = DEFAULT_KEEPALIVE_INTERVAL;
 #else
   #define host_keepalive() NOOP
@@ -711,31 +704,25 @@ XYZ_CONSTS_FROM_CONFIG(signed char, home_dir, HOME_DIR);
 
 void stop();
 
 void get_available_commands();
 void process_next_command();
 void prepare_move_to_destination();
 
 void get_cartesian_from_steppers();
 void set_current_from_steppers_for_axis(const AxisEnum axis);
 
-#if ENABLED(ARC_SUPPORT)
-  void plan_arc(float target[XYZE], float* offset, uint8_t clockwise);
-#endif
-
 #if ENABLED(BEZIER_CURVE_SUPPORT)
   void plan_cubic_move(const float offset[4]);
 #endif
 
-void tool_change(const uint8_t tmp_extruder, const float fr_mm_s=0.0, bool no_move=false);
 void report_current_position();
-void report_current_position_detail();
 
 /**
  * sync_plan_position
  *
  * Set the planner/stepper positions directly from current_position with
  * no kinematic translation. Used for homing axes and cartesian/core syncing.
  */
 void sync_plan_position() {
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position", current_position);
@@ -1170,21 +1157,21 @@ inline void get_serial_commands() {
 
   /**
    * Get commands from the SD Card until the command buffer is full
    * or until the end of the file is reached. The special character '#'
    * can also interrupt buffering.
    */
   inline void get_sdcard_commands() {
     static bool stop_buffering = false,
                 sd_comment_mode = false;
 
-    if (!card.sdprinting) return;
+    if (!IS_SD_PRINTING) return;
 
     /**
      * '#' stops reading from SD to the buffer prematurely, so procedural
      * macro calls are possible. If it occurs, stop_buffering is triggered
      * and the buffer is run dry; this character _can_ occur in serial com
      * due to checksums, however, no checksums are used in SD printing.
      */
 
     if (commands_in_queue == 0) stop_buffering = false;
 
@@ -3317,8285 +3304,577 @@ void gcode_get_destination() {
     next_busy_signal_ms = ms + host_keepalive_interval * 1000UL;
   }
 
 #endif // HOST_KEEPALIVE_FEATURE
 
 
 /**************************************************
  ***************** GCode Handlers *****************
  **************************************************/
 
-/**
- * G0, G1: Coordinated movement of X Y Z E axes
- */
-inline void gcode_G0_G1(
-  #if IS_SCARA
-    bool fast_move=false
-  #endif
-) {
-  if (IsRunning()) {
-    gcode_get_destination(); // For X Y Z E F
-
-    #if ENABLED(FWRETRACT)
-      if (MIN_AUTORETRACT <= MAX_AUTORETRACT) {
-        // When M209 Autoretract is enabled, convert E-only moves to firmware retract/recover moves
-        if (autoretract_enabled && parser.seen('E') && !(parser.seen('X') || parser.seen('Y') || parser.seen('Z'))) {
-          const float echange = destination[E_AXIS] - current_position[E_AXIS];
-          // Is this a retract or recover move?
-          if (WITHIN(FABS(echange), MIN_AUTORETRACT, MAX_AUTORETRACT) && retracted[active_extruder] == (echange > 0.0)) {
-            current_position[E_AXIS] = destination[E_AXIS]; // Hide a G1-based retract/recover from calculations
-            sync_plan_position_e();                         // AND from the planner
-            return retract(echange < 0.0);                  // Firmware-based retract/recover (double-retract ignored)
-          }
-        }
-      }
-    #endif // FWRETRACT
-
-    #if IS_SCARA
-      fast_move ? prepare_uninterpolated_move_to_destination() : prepare_move_to_destination();
-    #else
-      prepare_move_to_destination();
-    #endif
-  }
-}
+#include "gcode/motion/G0_G1.h"
 
-/**
- * G2: Clockwise Arc
- * G3: Counterclockwise Arc
- *
- * This command has two forms: IJ-form and R-form.
- *
- *  - I specifies an X offset. J specifies a Y offset.
- *    At least one of the IJ parameters is required.
- *    X and Y can be omitted to do a complete circle.
- *    The given XY is not error-checked. The arc ends
- *     based on the angle of the destination.
- *    Mixing I or J with R will throw an error.
- *
- *  - R specifies the radius. X or Y is required.
- *    Omitting both X and Y will throw an error.
- *    X or Y must differ from the current XY.
- *    Mixing R with I or J will throw an error.
- *
- *  - P specifies the number of full circles to do
- *    before the specified arc move.
- *
- *  Examples:
- *
- *    G2 I10           ; CW circle centered at X+10
- *    G3 X20 Y12 R14   ; CCW circle with r=14 ending at X20 Y12
- */
 #if ENABLED(ARC_SUPPORT)
-
-  inline void gcode_G2_G3(bool clockwise) {
-    if (IsRunning()) {
-
-      #if ENABLED(SF_ARC_FIX)
-        const bool relative_mode_backup = relative_mode;
-        relative_mode = true;
-      #endif
-
-      gcode_get_destination();
-
-      #if ENABLED(SF_ARC_FIX)
-        relative_mode = relative_mode_backup;
-      #endif
-
-      float arc_offset[2] = { 0.0, 0.0 };
-      if (parser.seenval('R')) {
-        const float r = parser.value_linear_units(),
-                    p1 = current_position[X_AXIS], q1 = current_position[Y_AXIS],
-                    p2 = destination[X_AXIS], q2 = destination[Y_AXIS];
-        if (r && (p2 != p1 || q2 != q1)) {
-          const float e = clockwise ^ (r < 0) ? -1 : 1,           // clockwise -1/1, counterclockwise 1/-1
-                      dx = p2 - p1, dy = q2 - q1,                 // X and Y differences
-                      d = HYPOT(dx, dy),                          // Linear distance between the points
-                      h = SQRT(sq(r) - sq(d * 0.5)),              // Distance to the arc pivot-point
-                      mx = (p1 + p2) * 0.5, my = (q1 + q2) * 0.5, // Point between the two points
-                      sx = -dy / d, sy = dx / d,                  // Slope of the perpendicular bisector
-                      cx = mx + e * h * sx, cy = my + e * h * sy; // Pivot-point of the arc
-          arc_offset[0] = cx - p1;
-          arc_offset[1] = cy - q1;
-        }
-      }
-      else {
-        if (parser.seenval('I')) arc_offset[0] = parser.value_linear_units();
-        if (parser.seenval('J')) arc_offset[1] = parser.value_linear_units();
-      }
-
-      if (arc_offset[0] || arc_offset[1]) {
-
-        #if ENABLED(ARC_P_CIRCLES)
-          // P indicates number of circles to do
-          int8_t circles_to_do = parser.byteval('P');
-          if (!WITHIN(circles_to_do, 0, 100)) {
-            SERIAL_ERROR_START();
-            SERIAL_ERRORLNPGM(MSG_ERR_ARC_ARGS);
-          }
-          while (circles_to_do--)
-            plan_arc(current_position, arc_offset, clockwise);
-        #endif
-
-        // Send the arc to the planner
-        plan_arc(destination, arc_offset, clockwise);
-        refresh_cmd_timeout();
-      }
-      else {
-        // Bad arguments
-        SERIAL_ERROR_START();
-        SERIAL_ERRORLNPGM(MSG_ERR_ARC_ARGS);
-      }
-    }
-  }
-
-#endif // ARC_SUPPORT
+  #include "gcode/motion/G2_G3.h"
+#endif
 
 void dwell(millis_t time) {
   refresh_cmd_timeout();
   time += previous_cmd_ms;
   while (PENDING(millis(), time)) idle();
 }
 
-/**
- * G4: Dwell S<seconds> or P<milliseconds>
- */
-inline void gcode_G4() {
-  millis_t dwell_ms = 0;
+#include "gcode/motion/G4.h"
 
-  if (parser.seenval('P')) dwell_ms = parser.value_millis(); // milliseconds to wait
-  if (parser.seenval('S')) dwell_ms = parser.value_millis_from_seconds(); // seconds to wait
+#if ENABLED(BEZIER_CURVE_SUPPORT)
+  #include "gcode/motion/G5.h"
+#endif
 
-  stepper.synchronize();
+#if ENABLED(FWRETRACT)
+  #include "gcode/feature/fwretract/G10_G11.h"
+#endif
 
-  if (!lcd_hasstatus()) LCD_MESSAGEPGM(MSG_DWELL);
+#if ENABLED(NOZZLE_CLEAN_FEATURE)
+  #include "gcode/feature/clean/G12.h"
+#endif
 
-  dwell(dwell_ms);
-}
+#if ENABLED(CNC_WORKSPACE_PLANES)
+  #include "gcode/feature/clean/G17-G19.h"
+#endif
 
-#if ENABLED(BEZIER_CURVE_SUPPORT)
+#if ENABLED(INCH_MODE_SUPPORT)
+  #include "gcode/units/G20_G21.h"
+#endif
 
-  /**
-   * Parameters interpreted according to:
-   * http://linuxcnc.org/docs/2.6/html/gcode/gcode.html#sec:G5-Cubic-Spline
-   * However I, J omission is not supported at this point; all
-   * parameters can be omitted and default to zero.
-   */
+#if ENABLED(UBL_G26_MESH_VALIDATION)
+  #include "gcode/calibrate/G26.h"
+#endif
 
-  /**
-   * G5: Cubic B-spline
-   */
-  inline void gcode_G5() {
-    if (IsRunning()) {
+#if ENABLED(NOZZLE_PARK_FEATURE)
+  #include "gcode/feature/pause/G27.h"
+#endif
 
-      #if ENABLED(CNC_WORKSPACE_PLANES)
-        if (workspace_plane != PLANE_XY) {
-          SERIAL_ERROR_START();
-          SERIAL_ERRORLNPGM(MSG_ERR_BAD_PLANE_MODE);
-          return;
-        }
-      #endif
+#if ENABLED(PROBE_MANUALLY)
+  bool g29_in_progress = false;
+#else
+  constexpr bool g29_in_progress = false;
+#endif
 
-      gcode_get_destination();
+#include "gcode/calibrate/G28.h"
 
-      const float offset[] = {
-        parser.linearval('I'),
-        parser.linearval('J'),
-        parser.linearval('P'),
-        parser.linearval('Q')
-      };
+void home_all_axes() { gcode_G28(true); }
 
-      plan_cubic_move(offset);
-    }
+#if HAS_PROBING_PROCEDURE
+
+  void out_of_range_error(const char* p_edge) {
+    SERIAL_PROTOCOLPGM("?Probe ");
+    serialprintPGM(p_edge);
+    SERIAL_PROTOCOLLNPGM(" position out of range.");
   }
 
-#endif // BEZIER_CURVE_SUPPORT
+#endif
 
-#if ENABLED(FWRETRACT)
+#include "gcode/calibrate/G29.h"
 
-  /**
-   * G10 - Retract filament according to settings of M207
-   */
-  inline void gcode_G10() {
-    #if EXTRUDERS > 1
-      const bool rs = parser.boolval('S');
-      retracted_swap[active_extruder] = rs; // Use 'S' for swap, default to false
-    #endif
-    retract(true
-      #if EXTRUDERS > 1
-        , rs
-      #endif
-    );
-  }
+#if HAS_BED_PROBE
+  #include "gcode/probe/G30.h"
+  #if ENABLED(Z_PROBE_SLED)
+    #include "gcode/probe/G31_G32.h"
+  #endif
+#endif
 
-  /**
-   * G11 - Recover filament according to settings of M208
-   */
-  inline void gcode_G11() { retract(false); }
+#if PROBE_SELECTED && ENABLED(DELTA_AUTO_CALIBRATION)
+  #include "gcode/calibrate/G33.h"
+#endif
 
-#endif // FWRETRACT
+#if ENABLED(G38_PROBE_TARGET)
+  #include "gcode/probe/G38.h"
+#endif
 
-#if ENABLED(NOZZLE_CLEAN_FEATURE)
-  /**
-   * G12: Clean the nozzle
-   */
-  inline void gcode_G12() {
-    // Don't allow nozzle cleaning without homing first
-    if (axis_unhomed_error()) return;
+#if HAS_MESH
+  #include "gcode/probe/G42.h"
+#endif
 
-    const uint8_t pattern = parser.ushortval('P', 0),
-                  strokes = parser.ushortval('S', NOZZLE_CLEAN_STROKES),
-                  objects = parser.ushortval('T', NOZZLE_CLEAN_TRIANGLES);
-    const float radius = parser.floatval('R', NOZZLE_CLEAN_CIRCLE_RADIUS);
+#include "gcode/geometry/G92.h"
 
-    Nozzle::clean(pattern, strokes, radius, objects);
-  }
+#if HAS_RESUME_CONTINUE
+  #include "gcode/lcd/M0_M1.h"
 #endif
 
-#if ENABLED(CNC_WORKSPACE_PLANES)
+#if ENABLED(SPINDLE_LASER_ENABLE)
+  #include "gcode/control/M3-M5.h"
+#endif
 
-  void report_workspace_plane() {
-    SERIAL_ECHO_START();
-    SERIAL_ECHOPGM("Workspace Plane ");
-    serialprintPGM(workspace_plane == PLANE_YZ ? PSTR("YZ\n") : workspace_plane == PLANE_ZX ? PSTR("ZX\n") : PSTR("XY\n"));
-  }
+#include "gcode/control/M17.h"
 
-  /**
-   * G17: Select Plane XY
-   * G18: Select Plane ZX
-   * G19: Select Plane YZ
-   */
-  inline void gcode_G17() { workspace_plane = PLANE_XY; }
-  inline void gcode_G18() { workspace_plane = PLANE_ZX; }
-  inline void gcode_G19() { workspace_plane = PLANE_YZ; }
+#if ENABLED(ADVANCED_PAUSE_FEATURE)
+  // For M125, M600, M24
+  #include "gcode/feature/pause/common.h"
+#endif
 
-#endif // CNC_WORKSPACE_PLANES
+#if ENABLED(SDSUPPORT)
+  #include "gcode/sdcard/M20.h"           // M20  - List SD card. (Requires SDSUPPORT)
+  #include "gcode/sdcard/M21.h"           // M21  - Init SD card. (Requires SDSUPPORT)
+  #include "gcode/sdcard/M22.h"           // M22  - Release SD card. (Requires SDSUPPORT)
+  #include "gcode/sdcard/M23.h"           // M23  - Select SD file: "M23 /path/file.gco". (Requires SDSUPPORT)
+  #include "gcode/sdcard/M24.h"           // M24  - Start/resume SD print. (Requires SDSUPPORT)
+  #include "gcode/sdcard/M25.h"           // M25  - Pause SD print. (Requires SDSUPPORT)
+  #include "gcode/sdcard/M26.h"           // M26  - Set SD position in bytes: "M26 S12345". (Requires SDSUPPORT)
+  #include "gcode/sdcard/M27.h"           // M27  - Report SD print status. (Requires SDSUPPORT)
+  #include "gcode/sdcard/M28.h"           // M28  - Start SD write: "M28 /path/file.gco". (Requires SDSUPPORT)
+  #include "gcode/sdcard/M29.h"           // M29  - Stop SD write. (Requires SDSUPPORT)
+  #include "gcode/sdcard/M30.h"           // M30  - Delete file from SD: "M30 /path/file.gco"
+#endif
 
-#if ENABLED(INCH_MODE_SUPPORT)
-  /**
-   * G20: Set input mode to inches
-   */
-  inline void gcode_G20() { parser.set_input_linear_units(LINEARUNIT_INCH); }
+#include "gcode/stats/M31.h"              // M31: Get the time since the start of SD Print (or last M109)
 
-  /**
-   * G21: Set input mode to millimeters
-   */
-  inline void gcode_G21() { parser.set_input_linear_units(LINEARUNIT_MM); }
+#if ENABLED(SDSUPPORT)
+  #include "gcode/sdcard/M32.h"
+  #if ENABLED(LONG_FILENAME_HOST_SUPPORT)
+    #include "gcode/sdcard/M33.h"
+  #endif
+  #if ENABLED(SDCARD_SORT_ALPHA) && ENABLED(SDSORT_GCODE)
+    #include "gcode/sdcard/M34.h"
+  #endif
+  #include "gcode/sdcard/M928.h"
 #endif
 
-#if ENABLED(NOZZLE_PARK_FEATURE)
-  /**
-   * G27: Park the nozzle
-   */
-  inline void gcode_G27() {
-    // Don't allow nozzle parking without homing first
-    if (axis_unhomed_error()) return;
-    Nozzle::park(parser.ushortval('P'));
-  }
-#endif // NOZZLE_PARK_FEATURE
+/**
+ * Sensitive pin test for M42, M226
+ */
+static bool pin_is_protected(const int8_t pin) {
+  static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
+  for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
+    if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
+  return false;
+}
 
-#if ENABLED(QUICK_HOME)
+#include "gcode/control/M42.h"
 
-  static void quick_home_xy() {
+#if ENABLED(PINS_DEBUGGING)
+  #include "gcode/config/M43.h"
+#endif
 
-    // Pretend the current position is 0,0
-    current_position[X_AXIS] = current_position[Y_AXIS] = 0.0;
-    sync_plan_position();
+#if ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)
+  #include "gcode/calibrate/M48.h"
+#endif
 
-    const int x_axis_home_dir =
-      #if ENABLED(DUAL_X_CARRIAGE)
-        x_home_dir(active_extruder)
-      #else
-        home_dir(X_AXIS)
-      #endif
-    ;
+#if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(UBL_G26_MESH_VALIDATION)
+  #include "gcode/calibrate/M49.h"
+#endif
 
-    const float mlx = max_length(X_AXIS),
-                mly = max_length(Y_AXIS),
-                mlratio = mlx > mly ? mly / mlx : mlx / mly,
-                fr_mm_s = min(homing_feedrate(X_AXIS), homing_feedrate(Y_AXIS)) * SQRT(sq(mlratio) + 1.0);
+#include "gcode/stats/M75.h"
+#include "gcode/stats/M76.h"
+#include "gcode/stats/M77.h"
 
-    do_blocking_move_to_xy(1.5 * mlx * x_axis_home_dir, 1.5 * mly * home_dir(Y_AXIS), fr_mm_s);
-    endstops.hit_on_purpose(); // clear endstop hit flags
-    current_position[X_AXIS] = current_position[Y_AXIS] = 0.0;
-  }
+#if ENABLED(PRINTCOUNTER)
+  #include "gcode/stats/M78.h"
+#endif
 
-#endif // QUICK_HOME
+#include "gcode/temperature/M104.h"
 
-#if ENABLED(DEBUG_LEVELING_FEATURE)
+#if HAS_TEMP_HOTEND || HAS_TEMP_BED
 
-  void log_machine_info() {
-    SERIAL_ECHOPGM("Machine Type: ");
-    #if ENABLED(DELTA)
-      SERIAL_ECHOLNPGM("Delta");
-    #elif IS_SCARA
-      SERIAL_ECHOLNPGM("SCARA");
-    #elif IS_CORE
-      SERIAL_ECHOLNPGM("Core");
-    #else
-      SERIAL_ECHOLNPGM("Cartesian");
+  void print_heater_state(const float &c, const float &t,
+    #if ENABLED(SHOW_TEMP_ADC_VALUES)
+      const float r,
     #endif
-
-    SERIAL_ECHOPGM("Probe: ");
-    #if ENABLED(PROBE_MANUALLY)
-      SERIAL_ECHOLNPGM("PROBE_MANUALLY");
-    #elif ENABLED(FIX_MOUNTED_PROBE)
-      SERIAL_ECHOLNPGM("FIX_MOUNTED_PROBE");
-    #elif ENABLED(BLTOUCH)
-      SERIAL_ECHOLNPGM("BLTOUCH");
-    #elif HAS_Z_SERVO_ENDSTOP
-      SERIAL_ECHOLNPGM("SERVO PROBE");
-    #elif ENABLED(Z_PROBE_SLED)
-      SERIAL_ECHOLNPGM("Z_PROBE_SLED");
-    #elif ENABLED(Z_PROBE_ALLEN_KEY)
-      SERIAL_ECHOLNPGM("Z_PROBE_ALLEN_KEY");
-    #else
-      SERIAL_ECHOLNPGM("NONE");
+    const int8_t e=-2
+  ) {
+    #if !(HAS_TEMP_BED && HAS_TEMP_HOTEND) && HOTENDS <= 1
+      UNUSED(e);
     #endif
 
-    #if HAS_BED_PROBE
-      SERIAL_ECHOPAIR("Probe Offset X:", X_PROBE_OFFSET_FROM_EXTRUDER);
-      SERIAL_ECHOPAIR(" Y:", Y_PROBE_OFFSET_FROM_EXTRUDER);
-      SERIAL_ECHOPAIR(" Z:", zprobe_zoffset);
-      #if X_PROBE_OFFSET_FROM_EXTRUDER > 0
-        SERIAL_ECHOPGM(" (Right");
-      #elif X_PROBE_OFFSET_FROM_EXTRUDER < 0
-        SERIAL_ECHOPGM(" (Left");
-      #elif Y_PROBE_OFFSET_FROM_EXTRUDER != 0
-        SERIAL_ECHOPGM(" (Middle");
+    SERIAL_PROTOCOLCHAR(' ');
+    SERIAL_PROTOCOLCHAR(
+      #if HAS_TEMP_BED && HAS_TEMP_HOTEND
+        e == -1 ? 'B' : 'T'
+      #elif HAS_TEMP_HOTEND
+        'T'
       #else
-        SERIAL_ECHOPGM(" (Aligned With");
-      #endif
-      #if Y_PROBE_OFFSET_FROM_EXTRUDER > 0
-        SERIAL_ECHOPGM("-Back");
-      #elif Y_PROBE_OFFSET_FROM_EXTRUDER < 0
-        SERIAL_ECHOPGM("-Front");
-      #elif X_PROBE_OFFSET_FROM_EXTRUDER != 0
-        SERIAL_ECHOPGM("-Center");
+        'B'
       #endif
-      if (zprobe_zoffset < 0)
-        SERIAL_ECHOPGM(" & Below");
-      else if (zprobe_zoffset > 0)
-        SERIAL_ECHOPGM(" & Above");
-      else
-        SERIAL_ECHOPGM(" & Same Z as");
-      SERIAL_ECHOLNPGM(" Nozzle)");
+    );
+    #if HOTENDS > 1
+      if (e >= 0) SERIAL_PROTOCOLCHAR('0' + e);
+    #endif
+    SERIAL_PROTOCOLCHAR(':');
+    SERIAL_PROTOCOL(c);
+    SERIAL_PROTOCOLPAIR(" /" , t);
+    #if ENABLED(SHOW_TEMP_ADC_VALUES)
+      SERIAL_PROTOCOLPAIR(" (", r / OVERSAMPLENR);
+      SERIAL_PROTOCOLCHAR(')');
     #endif
+  }
 
-    #if HAS_ABL
-      SERIAL_ECHOPGM("Auto Bed Leveling: ");
-      #if ENABLED(AUTO_BED_LEVELING_LINEAR)
-        SERIAL_ECHOPGM("LINEAR");
-      #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
-        SERIAL_ECHOPGM("BILINEAR");
-      #elif ENABLED(AUTO_BED_LEVELING_3POINT)
-        SERIAL_ECHOPGM("3POINT");
-      #elif ENABLED(AUTO_BED_LEVELING_UBL)
-        SERIAL_ECHOPGM("UBL");
-      #endif
-      if (leveling_is_active()) {
-        SERIAL_ECHOLNPGM(" (enabled)");
-        #if ABL_PLANAR
-          const float diff[XYZ] = {
-            stepper.get_axis_position_mm(X_AXIS) - current_position[X_AXIS],
-            stepper.get_axis_position_mm(Y_AXIS) - current_position[Y_AXIS],
-            stepper.get_axis_position_mm(Z_AXIS) - current_position[Z_AXIS]
-          };
-          SERIAL_ECHOPGM("ABL Adjustment X");
-          if (diff[X_AXIS] > 0) SERIAL_CHAR('+');
-          SERIAL_ECHO(diff[X_AXIS]);
-          SERIAL_ECHOPGM(" Y");
-          if (diff[Y_AXIS] > 0) SERIAL_CHAR('+');
-          SERIAL_ECHO(diff[Y_AXIS]);
-          SERIAL_ECHOPGM(" Z");
-          if (diff[Z_AXIS] > 0) SERIAL_CHAR('+');
-          SERIAL_ECHO(diff[Z_AXIS]);
-        #elif ENABLED(AUTO_BED_LEVELING_UBL)
-          SERIAL_ECHOPAIR("UBL Adjustment Z", stepper.get_axis_position_mm(Z_AXIS) - current_position[Z_AXIS]);
-        #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
-          SERIAL_ECHOPAIR("ABL Adjustment Z", bilinear_z_offset(current_position));
+  void print_heaterstates() {
+    #if HAS_TEMP_HOTEND
+      print_heater_state(thermalManager.degHotend(target_extruder), thermalManager.degTargetHotend(target_extruder)
+        #if ENABLED(SHOW_TEMP_ADC_VALUES)
+          , thermalManager.rawHotendTemp(target_extruder)
+        #endif
+      );
+    #endif
+    #if HAS_TEMP_BED
+      print_heater_state(thermalManager.degBed(), thermalManager.degTargetBed(),
+        #if ENABLED(SHOW_TEMP_ADC_VALUES)
+          thermalManager.rawBedTemp(),
+        #endif
+        -1 // BED
+      );
+    #endif
+    #if HOTENDS > 1
+      HOTEND_LOOP() print_heater_state(thermalManager.degHotend(e), thermalManager.degTargetHotend(e),
+        #if ENABLED(SHOW_TEMP_ADC_VALUES)
+          thermalManager.rawHotendTemp(e),
         #endif
+        e
+      );
+    #endif
+    SERIAL_PROTOCOLPGM(" @:");
+    SERIAL_PROTOCOL(thermalManager.getHeaterPower(target_extruder));
+    #if HAS_TEMP_BED
+      SERIAL_PROTOCOLPGM(" B@:");
+      SERIAL_PROTOCOL(thermalManager.getHeaterPower(-1));
+    #endif
+    #if HOTENDS > 1
+      HOTEND_LOOP() {
+        SERIAL_PROTOCOLPAIR(" @", e);
+        SERIAL_PROTOCOLCHAR(':');
+        SERIAL_PROTOCOL(thermalManager.getHeaterPower(e));
       }
-      else
-        SERIAL_ECHOLNPGM(" (disabled)");
+    #endif
+  }
 
-      SERIAL_EOL();
+#endif // HAS_TEMP_HOTEND || HAS_TEMP_BED
 
-    #elif ENABLED(MESH_BED_LEVELING)
+#include "gcode/temperature/M105.h"
 
-      SERIAL_ECHOPGM("Mesh Bed Leveling");
-      if (leveling_is_active()) {
-        float lz = current_position[Z_AXIS];
-        planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], lz);
-        SERIAL_ECHOLNPGM(" (enabled)");
-        SERIAL_ECHOPAIR("MBL Adjustment Z", lz);
-      }
-      else
-        SERIAL_ECHOPGM(" (disabled)");
+#if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND || HAS_TEMP_BED)
 
-      SERIAL_EOL();
+  static uint8_t auto_report_temp_interval;
+  static millis_t next_temp_report_ms;
 
-    #endif // MESH_BED_LEVELING
+  inline void auto_report_temperatures() {
+    if (auto_report_temp_interval && ELAPSED(millis(), next_temp_report_ms)) {
+      next_temp_report_ms = millis() + 1000UL * auto_report_temp_interval;
+      print_heaterstates();
+      SERIAL_EOL();
+    }
   }
 
-#endif // DEBUG_LEVELING_FEATURE
+  #include "gcode/temperature/M155.h"
 
-#if ENABLED(DELTA)
+#endif // AUTO_REPORT_TEMPERATURES && (HAS_TEMP_HOTEND || HAS_TEMP_BED)
 
-  /**
-   * A delta can only safely home all axes at the same time
-   * This is like quick_home_xy() but for 3 towers.
-   */
-  inline bool home_delta() {
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) DEBUG_POS(">>> home_delta", current_position);
-    #endif
-    // Init the current position of all carriages to 0,0,0
-    ZERO(current_position);
-    sync_plan_position();
-
-    // Move all carriages together linearly until an endstop is hit.
-    current_position[X_AXIS] = current_position[Y_AXIS] = current_position[Z_AXIS] = (DELTA_HEIGHT + home_offset[Z_AXIS] + 10);
-    feedrate_mm_s = homing_feedrate(X_AXIS);
-    line_to_current_position();
-    stepper.synchronize();
-
-    // If an endstop was not hit, then damage can occur if homing is continued.
-    // This can occur if the delta height (DELTA_HEIGHT + home_offset[Z_AXIS]) is
-    // not set correctly.
-    if (!(Endstops::endstop_hit_bits & (_BV(X_MAX) | _BV(Y_MAX) | _BV(Z_MAX)))) {
-      LCD_MESSAGEPGM(MSG_ERR_HOMING_FAILED);
-      SERIAL_ERROR_START();
-      SERIAL_ERRORLNPGM(MSG_ERR_HOMING_FAILED);
-      return false;
-    }
-
-    endstops.hit_on_purpose(); // clear endstop hit flags
-
-    // At least one carriage has reached the top.
-    // Now re-home each carriage separately.
-    HOMEAXIS(A);
-    HOMEAXIS(B);
-    HOMEAXIS(C);
-
-    // Set all carriages to their home positions
-    // Do this here all at once for Delta, because
-    // XYZ isn't ABC. Applying this per-tower would
-    // give the impression that they are the same.
-    LOOP_XYZ(i) set_axis_is_at_home((AxisEnum)i);
-
-    SYNC_PLAN_POSITION_KINEMATIC();
-
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) DEBUG_POS("<<< home_delta", current_position);
-    #endif
-
-    return true;
-  }
-
-#endif // DELTA
-
-#if ENABLED(Z_SAFE_HOMING)
-
-  inline void home_z_safely() {
-
-    // Disallow Z homing if X or Y are unknown
-    if (!axis_known_position[X_AXIS] || !axis_known_position[Y_AXIS]) {
-      LCD_MESSAGEPGM(MSG_ERR_Z_HOMING);
-      SERIAL_ECHO_START();
-      SERIAL_ECHOLNPGM(MSG_ERR_Z_HOMING);
-      return;
-    }
-
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Z_SAFE_HOMING >>>");
-    #endif
-
-    SYNC_PLAN_POSITION_KINEMATIC();
-
-    /**
-     * Move the Z probe (or just the nozzle) to the safe homing point
-     */
-    destination[X_AXIS] = LOGICAL_X_POSITION(Z_SAFE_HOMING_X_POINT);
-    destination[Y_AXIS] = LOGICAL_Y_POSITION(Z_SAFE_HOMING_Y_POINT);
-    destination[Z_AXIS] = current_position[Z_AXIS]; // Z is already at the right height
-
-    #if HOMING_Z_WITH_PROBE
-      destination[X_AXIS] -= X_PROBE_OFFSET_FROM_EXTRUDER;
-      destination[Y_AXIS] -= Y_PROBE_OFFSET_FROM_EXTRUDER;
-    #endif
-
-    if (position_is_reachable_xy(destination[X_AXIS], destination[Y_AXIS])) {
-
-      #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) DEBUG_POS("Z_SAFE_HOMING", destination);
-      #endif
-
-      // This causes the carriage on Dual X to unpark
-      #if ENABLED(DUAL_X_CARRIAGE)
-        active_extruder_parked = false;
-      #endif
-
-      do_blocking_move_to_xy(destination[X_AXIS], destination[Y_AXIS]);
-      HOMEAXIS(Z);
-    }
-    else {
-      LCD_MESSAGEPGM(MSG_ZPROBE_OUT);
-      SERIAL_ECHO_START();
-      SERIAL_ECHOLNPGM(MSG_ZPROBE_OUT);
-    }
-
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< Z_SAFE_HOMING");
-    #endif
-  }
-
-#endif // Z_SAFE_HOMING
-
-#if ENABLED(PROBE_MANUALLY)
-  bool g29_in_progress = false;
-#else
-  constexpr bool g29_in_progress = false;
+#if FAN_COUNT > 0
+  #include "gcode/temperature/M106.h"
+  #include "gcode/temperature/M107.h"
 #endif
 
-/**
- * G28: Home all axes according to settings
- *
- * Parameters
- *
- *  None  Home to all axes with no parameters.
- *        With QUICK_HOME enabled XY will home together, then Z.
- *
- * Cartesian parameters
- *
- *  X   Home to the X endstop
- *  Y   Home to the Y endstop
- *  Z   Home to the Z endstop
- *
- */
-inline void gcode_G28(const bool always_home_all) {
-
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) {
-      SERIAL_ECHOLNPGM(">>> gcode_G28");
-      log_machine_info();
-    }
-  #endif
-
-  // Wait for planner moves to finish!
-  stepper.synchronize();
-
-  // Cancel the active G29 session
-  #if ENABLED(PROBE_MANUALLY)
-    g29_in_progress = false;
-  #endif
-
-  // Disable the leveling matrix before homing
-  #if HAS_LEVELING
-    #if ENABLED(AUTO_BED_LEVELING_UBL)
-      const bool ubl_state_at_entry = leveling_is_active();
-    #endif
-    set_bed_leveling_enabled(false);
-  #endif
-
-  #if ENABLED(CNC_WORKSPACE_PLANES)
-    workspace_plane = PLANE_XY;
-  #endif
-
-  // Always home with tool 0 active
-  #if HOTENDS > 1
-    const uint8_t old_tool_index = active_extruder;
-    tool_change(0, 0, true);
-  #endif
-
-  #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
-    extruder_duplication_enabled = false;
-  #endif
-
-  setup_for_endstop_or_probe_move();
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> endstops.enable(true)");
-  #endif
-  endstops.enable(true); // Enable endstops for next homing move
-
-  #if ENABLED(DELTA)
-
-    home_delta();
-    UNUSED(always_home_all);
-
-  #else // NOT DELTA
-
-    const bool homeX = always_home_all || parser.seen('X'),
-               homeY = always_home_all || parser.seen('Y'),
-               homeZ = always_home_all || parser.seen('Z'),
-               home_all = (!homeX && !homeY && !homeZ) || (homeX && homeY && homeZ);
-
-    set_destination_to_current();
-
-    #if Z_HOME_DIR > 0  // If homing away from BED do Z first
-
-      if (home_all || homeZ) {
-        HOMEAXIS(Z);
-        #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) DEBUG_POS("> HOMEAXIS(Z)", current_position);
-        #endif
-      }
-
-    #else
-
-      if (home_all || homeX || homeY) {
-        // Raise Z before homing any other axes and z is not already high enough (never lower z)
-        destination[Z_AXIS] = LOGICAL_Z_POSITION(Z_HOMING_HEIGHT);
-        if (destination[Z_AXIS] > current_position[Z_AXIS]) {
-
-          #if ENABLED(DEBUG_LEVELING_FEATURE)
-            if (DEBUGGING(LEVELING))
-              SERIAL_ECHOLNPAIR("Raise Z (before homing) to ", destination[Z_AXIS]);
-          #endif
-
-          do_blocking_move_to_z(destination[Z_AXIS]);
-        }
-      }
-
-    #endif
-
-    #if ENABLED(QUICK_HOME)
-
-      if (home_all || (homeX && homeY)) quick_home_xy();
-
-    #endif
-
-    #if ENABLED(HOME_Y_BEFORE_X)
-
-      // Home Y
-      if (home_all || homeY) {
-        HOMEAXIS(Y);
-        #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) DEBUG_POS("> homeY", current_position);
-        #endif
-      }
-
-    #endif
-
-    // Home X
-    if (home_all || homeX) {
-
-      #if ENABLED(DUAL_X_CARRIAGE)
-
-        // Always home the 2nd (right) extruder first
-        active_extruder = 1;
-        HOMEAXIS(X);
-
-        // Remember this extruder's position for later tool change
-        inactive_extruder_x_pos = RAW_X_POSITION(current_position[X_AXIS]);
-
-        // Home the 1st (left) extruder
-        active_extruder = 0;
-        HOMEAXIS(X);
-
-        // Consider the active extruder to be parked
-        COPY(raised_parked_position, current_position);
-        delayed_move_time = 0;
-        active_extruder_parked = true;
-
-      #else
-
-        HOMEAXIS(X);
-
-      #endif
-
-      #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(LEVELING)) DEBUG_POS("> homeX", current_position);
-      #endif
-    }
-
-    #if DISABLED(HOME_Y_BEFORE_X)
-      // Home Y
-      if (home_all || homeY) {
-        HOMEAXIS(Y);
-        #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) DEBUG_POS("> homeY", current_position);
-        #endif
-      }
-    #endif
-
-    // Home Z last if homing towards the bed
-    #if Z_HOME_DIR < 0
-      if (home_all || homeZ) {
-        #if ENABLED(Z_SAFE_HOMING)
-          home_z_safely();
-        #else
-          HOMEAXIS(Z);
-        #endif
-        #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) DEBUG_POS("> (home_all || homeZ) > final", current_position);
-        #endif
-      } // home_all || homeZ
-    #endif // Z_HOME_DIR < 0
-
-    SYNC_PLAN_POSITION_KINEMATIC();
+#if DISABLED(EMERGENCY_PARSER)
+  #include "gcode/control/M108.h"
+  #include "gcode/control/M112.h"
+  #include "gcode/control/M410.h"
+#endif
 
-  #endif // !DELTA (gcode_G28)
+#include "gcode/temperature/M109.h"
 
-  endstops.not_homing();
+#if HAS_TEMP_BED
+  #include "gcode/temperature/M190.h"
+#endif
 
-  #if ENABLED(DELTA) && ENABLED(DELTA_HOME_TO_SAFE_ZONE)
-    // move to a height where we can use the full xy-area
-    do_blocking_move_to_z(delta_clip_start_height);
-  #endif
+#include "gcode/host/M110.h"
 
-  #if ENABLED(AUTO_BED_LEVELING_UBL)
-    set_bed_leveling_enabled(ubl_state_at_entry);
-  #endif
+#include "gcode/control/M111.h"
 
-  clean_up_after_endstop_or_probe_move();
+#if ENABLED(HOST_KEEPALIVE_FEATURE)
+  #include "gcode/host/M113.h"
+#endif
 
-  // Restore the active tool after homing
-  #if HOTENDS > 1
-    tool_change(old_tool_index, 0,
-      #if ENABLED(PARKING_EXTRUDER)
-        false // fetch the previous toolhead
-      #else
-        true
-      #endif
-    );
+#if ENABLED(BARICUDA)
+  #if HAS_HEATER_1
+    #include "gcode/feature/baricuda/M126.h"
+    #include "gcode/feature/baricuda/M127.h"
   #endif
-
-  lcd_refresh();
-
-  report_current_position();
-
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< gcode_G28");
+  #if HAS_HEATER_2
+    #include "gcode/feature/baricuda/M128.h"
+    #include "gcode/feature/baricuda/M129.h"
   #endif
-} // G28
-
-void home_all_axes() { gcode_G28(true); }
-
-#if HAS_PROBING_PROCEDURE
-
-  void out_of_range_error(const char* p_edge) {
-    SERIAL_PROTOCOLPGM("?Probe ");
-    serialprintPGM(p_edge);
-    SERIAL_PROTOCOLLNPGM(" position out of range.");
-  }
-
 #endif
 
-#if ENABLED(MESH_BED_LEVELING) || ENABLED(PROBE_MANUALLY)
-
-  #if ENABLED(PROBE_MANUALLY) && ENABLED(LCD_BED_LEVELING)
-    extern bool lcd_wait_for_move;
-  #endif
-
-  inline void _manual_goto_xy(const float &x, const float &y) {
-    const float old_feedrate_mm_s = feedrate_mm_s;
-    #if MANUAL_PROBE_HEIGHT > 0
-      const float prev_z = current_position[Z_AXIS];
-      feedrate_mm_s = homing_feedrate(Z_AXIS);
-      current_position[Z_AXIS] = LOGICAL_Z_POSITION(MANUAL_PROBE_HEIGHT);
-      line_to_current_position();
-    #endif
-
-    feedrate_mm_s = MMM_TO_MMS(XY_PROBE_SPEED);
-    current_position[X_AXIS] = LOGICAL_X_POSITION(x);
-    current_position[Y_AXIS] = LOGICAL_Y_POSITION(y);
-    line_to_current_position();
-
-    #if MANUAL_PROBE_HEIGHT > 0
-      feedrate_mm_s = homing_feedrate(Z_AXIS);
-      current_position[Z_AXIS] = prev_z; // move back to the previous Z.
-      line_to_current_position();
-    #endif
-
-    feedrate_mm_s = old_feedrate_mm_s;
-    stepper.synchronize();
-
-    #if ENABLED(PROBE_MANUALLY) && ENABLED(LCD_BED_LEVELING)
-      lcd_wait_for_move = false;
-    #endif
-  }
+#include "gcode/temperature/M140.h"
 
+#if ENABLED(ULTIPANEL)
+  #include "gcode/lcd/M145.h"
 #endif
 
-#if ENABLED(MESH_BED_LEVELING)
-
-  // Save 130 bytes with non-duplication of PSTR
-  void echo_not_entered() { SERIAL_PROTOCOLLNPGM(" not entered."); }
-
-  void mbl_mesh_report() {
-    SERIAL_PROTOCOLLNPGM("Num X,Y: " STRINGIFY(GRID_MAX_POINTS_X) "," STRINGIFY(GRID_MAX_POINTS_Y));
-    SERIAL_PROTOCOLPGM("Z offset: "); SERIAL_PROTOCOL_F(mbl.z_offset, 5);
-    SERIAL_PROTOCOLLNPGM("\nMeasured points:");
-    print_2d_array(GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y, 5,
-      [](const uint8_t ix, const uint8_t iy) { return mbl.z_values[ix][iy]; }
-    );
-  }
-
-  void mesh_probing_done() {
-    mbl.set_has_mesh(true);
-    home_all_axes();
-    set_bed_leveling_enabled(true);
-    #if ENABLED(MESH_G28_REST_ORIGIN)
-      current_position[Z_AXIS] = LOGICAL_Z_POSITION(Z_MIN_POS);
-      set_destination_to_current();
-      line_to_destination(homing_feedrate(Z_AXIS));
-      stepper.synchronize();
-    #endif
-  }
-
-  /**
-   * G29: Mesh-based Z probe, probes a grid and produces a
-   *      mesh to compensate for variable bed height
-   *
-   * Parameters With MESH_BED_LEVELING:
-   *
-   *  S0              Produce a mesh report
-   *  S1              Start probing mesh points
-   *  S2              Probe the next mesh point
-   *  S3 Xn Yn Zn.nn  Manually modify a single point
-   *  S4 Zn.nn        Set z offset. Positive away from bed, negative closer to bed.
-   *  S5              Reset and disable mesh
-   *
-   * The S0 report the points as below
-   *
-   *  +----> X-axis  1-n
-   *  |
-   *  |
-   *  v Y-axis  1-n
-   *
-   */
-  inline void gcode_G29() {
+#if ENABLED(TEMPERATURE_UNITS_SUPPORT)
+  #include "gcode/units/M149.h"
+#endif
 
-    static int mbl_probe_index = -1;
-    #if HAS_SOFTWARE_ENDSTOPS
-      static bool enable_soft_endstops;
-    #endif
+#if HAS_POWER_SWITCH
+  #include "gcode/control/M80.h"
+#endif
 
-    const MeshLevelingState state = (MeshLevelingState)parser.byteval('S', (int8_t)MeshReport);
-    if (!WITHIN(state, 0, 5)) {
-      SERIAL_PROTOCOLLNPGM("S out of range (0-5).");
-      return;
-    }
+#include "gcode/control/M81.h"
 
-    int8_t px, py;
+#include "gcode/units/M82_M83.h"
 
-    switch (state) {
-      case MeshReport:
-        if (leveling_is_valid()) {
-          SERIAL_PROTOCOLLNPAIR("State: ", leveling_is_active() ? MSG_ON : MSG_OFF);
-          mbl_mesh_report();
-        }
-        else
-          SERIAL_PROTOCOLLNPGM("Mesh bed leveling has no data.");
-        break;
+#include "gcode/control/M18_M84.h"
 
-      case MeshStart:
-        mbl.reset();
-        mbl_probe_index = 0;
-        enqueue_and_echo_commands_P(PSTR("G28\nG29 S2"));
-        break;
+#include "gcode/control/M85.h"
 
-      case MeshNext:
-        if (mbl_probe_index < 0) {
-          SERIAL_PROTOCOLLNPGM("Start mesh probing with \"G29 S1\" first.");
-          return;
-        }
-        // For each G29 S2...
-        if (mbl_probe_index == 0) {
-          #if HAS_SOFTWARE_ENDSTOPS
-            // For the initial G29 S2 save software endstop state
-            enable_soft_endstops = soft_endstops_enabled;
-          #endif
-        }
-        else {
-          // For G29 S2 after adjusting Z.
-          mbl.set_zigzag_z(mbl_probe_index - 1, current_position[Z_AXIS]);
-          #if HAS_SOFTWARE_ENDSTOPS
-            soft_endstops_enabled = enable_soft_endstops;
-          #endif
-        }
-        // If there's another point to sample, move there with optional lift.
-        if (mbl_probe_index < GRID_MAX_POINTS) {
-          mbl.zigzag(mbl_probe_index, px, py);
-          _manual_goto_xy(mbl.index_to_xpos[px], mbl.index_to_ypos[py]);
-
-          #if HAS_SOFTWARE_ENDSTOPS
-            // Disable software endstops to allow manual adjustment
-            // If G29 is not completed, they will not be re-enabled
-            soft_endstops_enabled = false;
-          #endif
+/**
+ * Multi-stepper support for M92, M201, M203
+ */
+#if ENABLED(DISTINCT_E_FACTORS)
+  #define GET_TARGET_EXTRUDER(CMD) if (get_target_extruder_from_command(CMD)) return
+  #define TARGET_EXTRUDER target_extruder
+#else
+  #define GET_TARGET_EXTRUDER(CMD) NOOP
+  #define TARGET_EXTRUDER 0
+#endif
 
-          mbl_probe_index++;
-        }
-        else {
-          // One last "return to the bed" (as originally coded) at completion
-          current_position[Z_AXIS] = LOGICAL_Z_POSITION(Z_MIN_POS) + MANUAL_PROBE_HEIGHT;
-          line_to_current_position();
-          stepper.synchronize();
-
-          // After recording the last point, activate home and activate
-          mbl_probe_index = -1;
-          SERIAL_PROTOCOLLNPGM("Mesh probing done.");
-          BUZZ(100, 659);
-          BUZZ(100, 698);
-          mesh_probing_done();
-        }
-        break;
+#include "gcode/config/M92.h"
 
-      case MeshSet:
-        if (parser.seenval('X')) {
-          px = parser.value_int() - 1;
-          if (!WITHIN(px, 0, GRID_MAX_POINTS_X - 1)) {
-            SERIAL_PROTOCOLLNPGM("X out of range (1-" STRINGIFY(GRID_MAX_POINTS_X) ").");
-            return;
-          }
-        }
-        else {
-          SERIAL_CHAR('X'); echo_not_entered();
-          return;
-        }
-
-        if (parser.seenval('Y')) {
-          py = parser.value_int() - 1;
-          if (!WITHIN(py, 0, GRID_MAX_POINTS_Y - 1)) {
-            SERIAL_PROTOCOLLNPGM("Y out of range (1-" STRINGIFY(GRID_MAX_POINTS_Y) ").");
-            return;
-          }
-        }
-        else {
-          SERIAL_CHAR('Y'); echo_not_entered();
-          return;
-        }
-
-        if (parser.seenval('Z')) {
-          mbl.z_values[px][py] = parser.value_linear_units();
-        }
-        else {
-          SERIAL_CHAR('Z'); echo_not_entered();
-          return;
-        }
-        break;
-
-      case MeshSetZOffset:
-        if (parser.seenval('Z')) {
-          mbl.z_offset = parser.value_linear_units();
-        }
-        else {
-          SERIAL_CHAR('Z'); echo_not_entered();
-          return;
-        }
-        break;
-
-      case MeshReset:
-        reset_bed_level();
-        break;
-
-    } // switch(state)
-
-    report_current_position();
-  }
-
-#elif HAS_ABL && DISABLED(AUTO_BED_LEVELING_UBL)
-
-  #if ABL_GRID
-    #if ENABLED(PROBE_Y_FIRST)
-      #define PR_OUTER_VAR xCount
-      #define PR_OUTER_END abl_grid_points_x
-      #define PR_INNER_VAR yCount
-      #define PR_INNER_END abl_grid_points_y
-    #else
-      #define PR_OUTER_VAR yCount
-      #define PR_OUTER_END abl_grid_points_y
-      #define PR_INNER_VAR xCount
-      #define PR_INNER_END abl_grid_points_x
-    #endif
-  #endif
-
-  /**
-   * G29: Detailed Z probe, probes the bed at 3 or more points.
-   *      Will fail if the printer has not been homed with G28.
-   *
-   * Enhanced G29 Auto Bed Leveling Probe Routine
-   *
-   *  D  Dry-Run mode. Just evaluate the bed Topology - Don't apply
-   *     or alter the bed level data. Useful to check the topology
-   *     after a first run of G29.
-   *
-   *  J  Jettison current bed leveling data
-   *
-   *  V  Set the verbose level (0-4). Example: "G29 V3"
-   *
-   * Parameters With LINEAR leveling only:
-   *
-   *  P  Set the size of the grid that will be probed (P x P points).
-   *     Example: "G29 P4"
-   *
-   *  X  Set the X size of the grid that will be probed (X x Y points).
-   *     Example: "G29 X7 Y5"
-   *
-   *  Y  Set the Y size of the grid that will be probed (X x Y points).
-   *
-   *  T  Generate a Bed Topology Report. Example: "G29 P5 T" for a detailed report.
-   *     This is useful for manual bed leveling and finding flaws in the bed (to
-   *     assist with part placement).
-   *     Not supported by non-linear delta printer bed leveling.
-   *
-   * Parameters With LINEAR and BILINEAR leveling only:
-   *
-   *  S  Set the XY travel speed between probe points (in units/min)
-   *
-   *  F  Set the Front limit of the probing grid
-   *  B  Set the Back limit of the probing grid
-   *  L  Set the Left limit of the probing grid
-   *  R  Set the Right limit of the probing grid
-   *
-   * Parameters with DEBUG_LEVELING_FEATURE only:
-   *
-   *  C  Make a totally fake grid with no actual probing.
-   *     For use in testing when no probing is possible.
-   *
-   * Parameters with BILINEAR leveling only:
-   *
-   *  Z  Supply an additional Z probe offset
-   *
-   * Extra parameters with PROBE_MANUALLY:
-   *
-   *  To do manual probing simply repeat G29 until the procedure is complete.
-   *  The first G29 accepts parameters. 'G29 Q' for status, 'G29 A' to abort.
-   *
-   *  Q  Query leveling and G29 state
-   *
-   *  A  Abort current leveling procedure
-   *
-   * Extra parameters with BILINEAR only:
-   *
-   *  W  Write a mesh point. (If G29 is idle.)
-   *  I  X index for mesh point
-   *  J  Y index for mesh point
-   *  X  X for mesh point, overrides I
-   *  Y  Y for mesh point, overrides J
-   *  Z  Z for mesh point. Otherwise, raw current Z.
-   *
-   * Without PROBE_MANUALLY:
-   *
-   *  E  By default G29 will engage the Z probe, test the bed, then disengage.
-   *     Include "E" to engage/disengage the Z probe for each sample.
-   *     There's no extra effect if you have a fixed Z probe.
-   *
-   */
-  inline void gcode_G29() {
-
-    // G29 Q is also available if debugging
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      const bool query = parser.seen('Q');
-      const uint8_t old_debug_flags = marlin_debug_flags;
-      if (query) marlin_debug_flags |= DEBUG_LEVELING;
-      if (DEBUGGING(LEVELING)) {
-        DEBUG_POS(">>> gcode_G29", current_position);
-        log_machine_info();
-      }
-      marlin_debug_flags = old_debug_flags;
-      #if DISABLED(PROBE_MANUALLY)
-        if (query) return;
-      #endif
-    #endif
-
-    #if ENABLED(PROBE_MANUALLY)
-      const bool seenA = parser.seen('A'), seenQ = parser.seen('Q'), no_action = seenA || seenQ;
-    #endif
-
-    #if ENABLED(DEBUG_LEVELING_FEATURE) && DISABLED(PROBE_MANUALLY)
-      const bool faux = parser.boolval('C');
-    #elif ENABLED(PROBE_MANUALLY)
-      const bool faux = no_action;
-    #else
-      bool constexpr faux = false;
-    #endif
-
-    // Don't allow auto-leveling without homing first
-    if (axis_unhomed_error()) return;
-
-    // Define local vars 'static' for manual probing, 'auto' otherwise
-    #if ENABLED(PROBE_MANUALLY)
-      #define ABL_VAR static
-    #else
-      #define ABL_VAR
-    #endif
-
-    ABL_VAR int verbose_level;
-    ABL_VAR float xProbe, yProbe, measured_z;
-    ABL_VAR bool dryrun, abl_should_enable;
-
-    #if ENABLED(PROBE_MANUALLY) || ENABLED(AUTO_BED_LEVELING_LINEAR)
-      ABL_VAR int abl_probe_index;
-    #endif
-
-    #if HAS_SOFTWARE_ENDSTOPS && ENABLED(PROBE_MANUALLY)
-      ABL_VAR bool enable_soft_endstops = true;
-    #endif
-
-    #if ABL_GRID
-
-      #if ENABLED(PROBE_MANUALLY)
-        ABL_VAR uint8_t PR_OUTER_VAR;
-        ABL_VAR  int8_t PR_INNER_VAR;
-      #endif
-
-      ABL_VAR int left_probe_bed_position, right_probe_bed_position, front_probe_bed_position, back_probe_bed_position;
-      ABL_VAR float xGridSpacing = 0, yGridSpacing = 0;
-
-      #if ENABLED(AUTO_BED_LEVELING_LINEAR)
-        ABL_VAR uint8_t abl_grid_points_x = GRID_MAX_POINTS_X,
-                        abl_grid_points_y = GRID_MAX_POINTS_Y;
-        ABL_VAR bool do_topography_map;
-      #else // Bilinear
-        uint8_t constexpr abl_grid_points_x = GRID_MAX_POINTS_X,
-                          abl_grid_points_y = GRID_MAX_POINTS_Y;
-      #endif
-
-      #if ENABLED(AUTO_BED_LEVELING_LINEAR) || ENABLED(PROBE_MANUALLY)
-        #if ENABLED(AUTO_BED_LEVELING_LINEAR)
-          ABL_VAR int abl2;
-        #else // Bilinear
-          int constexpr abl2 = GRID_MAX_POINTS;
-        #endif
-      #endif
-
-      #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
-
-        ABL_VAR float zoffset;
-
-      #elif ENABLED(AUTO_BED_LEVELING_LINEAR)
-
-        ABL_VAR int indexIntoAB[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
-
-        ABL_VAR float eqnAMatrix[GRID_MAX_POINTS * 3], // "A" matrix of the linear system of equations
-                      eqnBVector[GRID_MAX_POINTS],     // "B" vector of Z points
-                      mean;
-      #endif
-
-    #elif ENABLED(AUTO_BED_LEVELING_3POINT)
-
-      int constexpr abl2 = 3;
-
-      // Probe at 3 arbitrary points
-      ABL_VAR vector_3 points[3] = {
-        vector_3(ABL_PROBE_PT_1_X, ABL_PROBE_PT_1_Y, 0),
-        vector_3(ABL_PROBE_PT_2_X, ABL_PROBE_PT_2_Y, 0),
-        vector_3(ABL_PROBE_PT_3_X, ABL_PROBE_PT_3_Y, 0)
-      };
-
-    #endif // AUTO_BED_LEVELING_3POINT
-
-    #if ENABLED(AUTO_BED_LEVELING_LINEAR)
-      struct linear_fit_data lsf_results;
-      incremental_LSF_reset(&lsf_results);
-    #endif
-
-    /**
-     * On the initial G29 fetch command parameters.
-     */
-    if (!g29_in_progress) {
-
-      #if ENABLED(PROBE_MANUALLY) || ENABLED(AUTO_BED_LEVELING_LINEAR)
-        abl_probe_index = -1;
-      #endif
-
-      abl_should_enable = leveling_is_active();
-
-      #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
-
-        if (parser.seen('W')) {
-          if (!leveling_is_valid()) {
-            SERIAL_ERROR_START();
-            SERIAL_ERRORLNPGM("No bilinear grid");
-            return;
-          }
-
-          const float z = parser.floatval('Z', RAW_CURRENT_POSITION(Z));
-          if (!WITHIN(z, -10, 10)) {
-            SERIAL_ERROR_START();
-            SERIAL_ERRORLNPGM("Bad Z value");
-            return;
-          }
-
-          const float x = parser.floatval('X', NAN),
-                      y = parser.floatval('Y', NAN);
-          int8_t i = parser.byteval('I', -1),
-                 j = parser.byteval('J', -1);
-
-          if (!isnan(x) && !isnan(y)) {
-            // Get nearest i / j from x / y
-            i = (x - LOGICAL_X_POSITION(bilinear_start[X_AXIS]) + 0.5 * xGridSpacing) / xGridSpacing;
-            j = (y - LOGICAL_Y_POSITION(bilinear_start[Y_AXIS]) + 0.5 * yGridSpacing) / yGridSpacing;
-            i = constrain(i, 0, GRID_MAX_POINTS_X - 1);
-            j = constrain(j, 0, GRID_MAX_POINTS_Y - 1);
-          }
-          if (WITHIN(i, 0, GRID_MAX_POINTS_X - 1) && WITHIN(j, 0, GRID_MAX_POINTS_Y)) {
-            set_bed_leveling_enabled(false);
-            z_values[i][j] = z;
-            #if ENABLED(ABL_BILINEAR_SUBDIVISION)
-              bed_level_virt_interpolate();
-            #endif
-            set_bed_leveling_enabled(abl_should_enable);
-          }
-          return;
-        } // parser.seen('W')
-
-      #endif
-
-      #if HAS_LEVELING
-
-        // Jettison bed leveling data
-        if (parser.seen('J')) {
-          reset_bed_level();
-          return;
-        }
-
-      #endif
-
-      verbose_level = parser.intval('V');
-      if (!WITHIN(verbose_level, 0, 4)) {
-        SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-4).");
-        return;
-      }
-
-      dryrun = parser.boolval('D')
-        #if ENABLED(PROBE_MANUALLY)
-          || no_action
-        #endif
-      ;
-
-      #if ENABLED(AUTO_BED_LEVELING_LINEAR)
-
-        do_topography_map = verbose_level > 2 || parser.boolval('T');
-
-        // X and Y specify points in each direction, overriding the default
-        // These values may be saved with the completed mesh
-        abl_grid_points_x = parser.intval('X', GRID_MAX_POINTS_X);
-        abl_grid_points_y = parser.intval('Y', GRID_MAX_POINTS_Y);
-        if (parser.seenval('P')) abl_grid_points_x = abl_grid_points_y = parser.value_int();
-
-        if (abl_grid_points_x < 2 || abl_grid_points_y < 2) {
-          SERIAL_PROTOCOLLNPGM("?Number of probe points is implausible (2 minimum).");
-          return;
-        }
-
-        abl2 = abl_grid_points_x * abl_grid_points_y;
-
-      #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
-
-        zoffset = parser.linearval('Z');
-
-      #endif
-
-      #if ABL_GRID
-
-        xy_probe_feedrate_mm_s = MMM_TO_MMS(parser.linearval('S', XY_PROBE_SPEED));
-
-        left_probe_bed_position = (int)parser.linearval('L', LOGICAL_X_POSITION(LEFT_PROBE_BED_POSITION));
-        right_probe_bed_position = (int)parser.linearval('R', LOGICAL_X_POSITION(RIGHT_PROBE_BED_POSITION));
-        front_probe_bed_position = (int)parser.linearval('F', LOGICAL_Y_POSITION(FRONT_PROBE_BED_POSITION));
-        back_probe_bed_position = (int)parser.linearval('B', LOGICAL_Y_POSITION(BACK_PROBE_BED_POSITION));
-
-        const bool left_out_l = left_probe_bed_position < LOGICAL_X_POSITION(MIN_PROBE_X),
-                   left_out = left_out_l || left_probe_bed_position > right_probe_bed_position - (MIN_PROBE_EDGE),
-                   right_out_r = right_probe_bed_position > LOGICAL_X_POSITION(MAX_PROBE_X),
-                   right_out = right_out_r || right_probe_bed_position < left_probe_bed_position + MIN_PROBE_EDGE,
-                   front_out_f = front_probe_bed_position < LOGICAL_Y_POSITION(MIN_PROBE_Y),
-                   front_out = front_out_f || front_probe_bed_position > back_probe_bed_position - (MIN_PROBE_EDGE),
-                   back_out_b = back_probe_bed_position > LOGICAL_Y_POSITION(MAX_PROBE_Y),
-                   back_out = back_out_b || back_probe_bed_position < front_probe_bed_position + MIN_PROBE_EDGE;
-
-        if (left_out || right_out || front_out || back_out) {
-          if (left_out) {
-            out_of_range_error(PSTR("(L)eft"));
-            left_probe_bed_position = left_out_l ? LOGICAL_X_POSITION(MIN_PROBE_X) : right_probe_bed_position - (MIN_PROBE_EDGE);
-          }
-          if (right_out) {
-            out_of_range_error(PSTR("(R)ight"));
-            right_probe_bed_position = right_out_r ? LOGICAL_Y_POSITION(MAX_PROBE_X) : left_probe_bed_position + MIN_PROBE_EDGE;
-          }
-          if (front_out) {
-            out_of_range_error(PSTR("(F)ront"));
-            front_probe_bed_position = front_out_f ? LOGICAL_Y_POSITION(MIN_PROBE_Y) : back_probe_bed_position - (MIN_PROBE_EDGE);
-          }
-          if (back_out) {
-            out_of_range_error(PSTR("(B)ack"));
-            back_probe_bed_position = back_out_b ? LOGICAL_Y_POSITION(MAX_PROBE_Y) : front_probe_bed_position + MIN_PROBE_EDGE;
-          }
-          return;
-        }
-
-        // probe at the points of a lattice grid
-        xGridSpacing = (right_probe_bed_position - left_probe_bed_position) / (abl_grid_points_x - 1);
-        yGridSpacing = (back_probe_bed_position - front_probe_bed_position) / (abl_grid_points_y - 1);
-
-      #endif // ABL_GRID
-
-      if (verbose_level > 0) {
-        SERIAL_PROTOCOLLNPGM("G29 Auto Bed Leveling");
-        if (dryrun) SERIAL_PROTOCOLLNPGM("Running in DRY-RUN mode");
-      }
-
-      stepper.synchronize();
-
-      // Disable auto bed leveling during G29
-      planner.abl_enabled = false;
-
-      if (!dryrun) {
-        // Re-orient the current position without leveling
-        // based on where the steppers are positioned.
-        set_current_from_steppers_for_axis(ALL_AXES);
-
-        // Sync the planner to where the steppers stopped
-        SYNC_PLAN_POSITION_KINEMATIC();
-      }
-
-      #if HAS_BED_PROBE
-        // Deploy the probe. Probe will raise if needed.
-        if (DEPLOY_PROBE()) {
-          planner.abl_enabled = abl_should_enable;
-          return;
-        }
-      #endif
-
-      if (!faux) setup_for_endstop_or_probe_move();
-
-      #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
-
-        #if ENABLED(PROBE_MANUALLY)
-          if (!no_action)
-        #endif
-        if ( xGridSpacing != bilinear_grid_spacing[X_AXIS]
-          || yGridSpacing != bilinear_grid_spacing[Y_AXIS]
-          || left_probe_bed_position != LOGICAL_X_POSITION(bilinear_start[X_AXIS])
-          || front_probe_bed_position != LOGICAL_Y_POSITION(bilinear_start[Y_AXIS])
-        ) {
-          if (dryrun) {
-            // Before reset bed level, re-enable to correct the position
-            planner.abl_enabled = abl_should_enable;
-          }
-          // Reset grid to 0.0 or "not probed". (Also disables ABL)
-          reset_bed_level();
-
-          // Initialize a grid with the given dimensions
-          bilinear_grid_spacing[X_AXIS] = xGridSpacing;
-          bilinear_grid_spacing[Y_AXIS] = yGridSpacing;
-          bilinear_start[X_AXIS] = RAW_X_POSITION(left_probe_bed_position);
-          bilinear_start[Y_AXIS] = RAW_Y_POSITION(front_probe_bed_position);
-
-          // Can't re-enable (on error) until the new grid is written
-          abl_should_enable = false;
-        }
-
-      #endif // AUTO_BED_LEVELING_BILINEAR
-
-      #if ENABLED(AUTO_BED_LEVELING_3POINT)
-
-        #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> 3-point Leveling");
-        #endif
-
-        // Probe at 3 arbitrary points
-        points[0].z = points[1].z = points[2].z = 0;
-
-      #endif // AUTO_BED_LEVELING_3POINT
-
-    } // !g29_in_progress
-
-    #if ENABLED(PROBE_MANUALLY)
-
-      // For manual probing, get the next index to probe now.
-      // On the first probe this will be incremented to 0.
-      if (!no_action) {
-        ++abl_probe_index;
-        g29_in_progress = true;
-      }
-
-      // Abort current G29 procedure, go back to idle state
-      if (seenA && g29_in_progress) {
-        SERIAL_PROTOCOLLNPGM("Manual G29 aborted");
-        #if HAS_SOFTWARE_ENDSTOPS
-          soft_endstops_enabled = enable_soft_endstops;
-        #endif
-        planner.abl_enabled = abl_should_enable;
-        g29_in_progress = false;
-        #if ENABLED(LCD_BED_LEVELING)
-          lcd_wait_for_move = false;
-        #endif
-      }
-
-      // Query G29 status
-      if (verbose_level || seenQ) {
-        SERIAL_PROTOCOLPGM("Manual G29 ");
-        if (g29_in_progress) {
-          SERIAL_PROTOCOLPAIR("point ", min(abl_probe_index + 1, abl2));
-          SERIAL_PROTOCOLLNPAIR(" of ", abl2);
-        }
-        else
-          SERIAL_PROTOCOLLNPGM("idle");
-      }
-
-      if (no_action) return;
-
-      if (abl_probe_index == 0) {
-        // For the initial G29 save software endstop state
-        #if HAS_SOFTWARE_ENDSTOPS
-          enable_soft_endstops = soft_endstops_enabled;
-        #endif
-      }
-      else {
-        // For G29 after adjusting Z.
-        // Save the previous Z before going to the next point
-        measured_z = current_position[Z_AXIS];
-
-        #if ENABLED(AUTO_BED_LEVELING_LINEAR)
-
-          mean += measured_z;
-          eqnBVector[abl_probe_index] = measured_z;
-          eqnAMatrix[abl_probe_index + 0 * abl2] = xProbe;
-          eqnAMatrix[abl_probe_index + 1 * abl2] = yProbe;
-          eqnAMatrix[abl_probe_index + 2 * abl2] = 1;
-
-          incremental_LSF(&lsf_results, xProbe, yProbe, measured_z);
-
-        #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
-
-          z_values[xCount][yCount] = measured_z + zoffset;
-
-          #if ENABLED(DEBUG_LEVELING_FEATURE)
-            if (DEBUGGING(LEVELING)) {
-              SERIAL_PROTOCOLPAIR("Save X", xCount);
-              SERIAL_PROTOCOLPAIR(" Y", yCount);
-              SERIAL_PROTOCOLLNPAIR(" Z", measured_z + zoffset);
-            }
-          #endif
-
-        #elif ENABLED(AUTO_BED_LEVELING_3POINT)
-
-          points[abl_probe_index].z = measured_z;
-
-        #endif
-      }
-
-      //
-      // If there's another point to sample, move there with optional lift.
-      //
-
-      #if ABL_GRID
-
-        // Skip any unreachable points
-        while (abl_probe_index < abl2) {
-
-          // Set xCount, yCount based on abl_probe_index, with zig-zag
-          PR_OUTER_VAR = abl_probe_index / PR_INNER_END;
-          PR_INNER_VAR = abl_probe_index - (PR_OUTER_VAR * PR_INNER_END);
-
-          // Probe in reverse order for every other row/column
-          bool zig = (PR_OUTER_VAR & 1); // != ((PR_OUTER_END) & 1);
-
-          if (zig) PR_INNER_VAR = (PR_INNER_END - 1) - PR_INNER_VAR;
-
-          const float xBase = xCount * xGridSpacing + left_probe_bed_position,
-                      yBase = yCount * yGridSpacing + front_probe_bed_position;
-
-          xProbe = FLOOR(xBase + (xBase < 0 ? 0 : 0.5));
-          yProbe = FLOOR(yBase + (yBase < 0 ? 0 : 0.5));
-
-          #if ENABLED(AUTO_BED_LEVELING_LINEAR)
-            indexIntoAB[xCount][yCount] = abl_probe_index;
-          #endif
-
-          // Keep looping till a reachable point is found
-          if (position_is_reachable_xy(xProbe, yProbe)) break;
-          ++abl_probe_index;
-        }
-
-        // Is there a next point to move to?
-        if (abl_probe_index < abl2) {
-          _manual_goto_xy(xProbe, yProbe); // Can be used here too!
-          #if HAS_SOFTWARE_ENDSTOPS
-            // Disable software endstops to allow manual adjustment
-            // If G29 is not completed, they will not be re-enabled
-            soft_endstops_enabled = false;
-          #endif
-          return;
-        }
-        else {
-
-          // Leveling done! Fall through to G29 finishing code below
-
-          SERIAL_PROTOCOLLNPGM("Grid probing done.");
-
-          // Re-enable software endstops, if needed
-          #if HAS_SOFTWARE_ENDSTOPS
-            soft_endstops_enabled = enable_soft_endstops;
-          #endif
-        }
-
-      #elif ENABLED(AUTO_BED_LEVELING_3POINT)
-
-        // Probe at 3 arbitrary points
-        if (abl_probe_index < 3) {
-          xProbe = LOGICAL_X_POSITION(points[abl_probe_index].x);
-          yProbe = LOGICAL_Y_POSITION(points[abl_probe_index].y);
-          #if HAS_SOFTWARE_ENDSTOPS
-            // Disable software endstops to allow manual adjustment
-            // If G29 is not completed, they will not be re-enabled
-            soft_endstops_enabled = false;
-          #endif
-          return;
-        }
-        else {
-
-          SERIAL_PROTOCOLLNPGM("3-point probing done.");
-
-          // Re-enable software endstops, if needed
-          #if HAS_SOFTWARE_ENDSTOPS
-            soft_endstops_enabled = enable_soft_endstops;
-          #endif
-
-          if (!dryrun) {
-            vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
-            if (planeNormal.z < 0) {
-              planeNormal.x *= -1;
-              planeNormal.y *= -1;
-              planeNormal.z *= -1;
-            }
-            planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
-
-            // Can't re-enable (on error) until the new grid is written
-            abl_should_enable = false;
-          }
-
-        }
-
-      #endif // AUTO_BED_LEVELING_3POINT
-
-    #else // !PROBE_MANUALLY
-    {
-      const bool stow_probe_after_each = parser.boolval('E');
-
-      #if ABL_GRID
-
-        bool zig = PR_OUTER_END & 1;  // Always end at RIGHT and BACK_PROBE_BED_POSITION
-
-        // Outer loop is Y with PROBE_Y_FIRST disabled
-        for (uint8_t PR_OUTER_VAR = 0; PR_OUTER_VAR < PR_OUTER_END && !isnan(measured_z); PR_OUTER_VAR++) {
-
-          int8_t inStart, inStop, inInc;
-
-          if (zig) { // away from origin
-            inStart = 0;
-            inStop = PR_INNER_END;
-            inInc = 1;
-          }
-          else {     // towards origin
-            inStart = PR_INNER_END - 1;
-            inStop = -1;
-            inInc = -1;
-          }
-
-          zig ^= true; // zag
-
-          // Inner loop is Y with PROBE_Y_FIRST enabled
-          for (int8_t PR_INNER_VAR = inStart; PR_INNER_VAR != inStop; PR_INNER_VAR += inInc) {
-
-            float xBase = left_probe_bed_position + xGridSpacing * xCount,
-                  yBase = front_probe_bed_position + yGridSpacing * yCount;
-
-            xProbe = FLOOR(xBase + (xBase < 0 ? 0 : 0.5));
-            yProbe = FLOOR(yBase + (yBase < 0 ? 0 : 0.5));
-
-            #if ENABLED(AUTO_BED_LEVELING_LINEAR)
-              indexIntoAB[xCount][yCount] = ++abl_probe_index; // 0...
-            #endif
-
-            #if IS_KINEMATIC
-              // Avoid probing outside the round or hexagonal area
-              if (!position_is_reachable_by_probe_xy(xProbe, yProbe)) continue;
-            #endif
-
-            measured_z = faux ? 0.001 * random(-100, 101) : probe_pt(xProbe, yProbe, stow_probe_after_each, verbose_level);
-
-            if (isnan(measured_z)) {
-              planner.abl_enabled = abl_should_enable;
-              break;
-            }
-
-            #if ENABLED(AUTO_BED_LEVELING_LINEAR)
-
-              mean += measured_z;
-              eqnBVector[abl_probe_index] = measured_z;
-              eqnAMatrix[abl_probe_index + 0 * abl2] = xProbe;
-              eqnAMatrix[abl_probe_index + 1 * abl2] = yProbe;
-              eqnAMatrix[abl_probe_index + 2 * abl2] = 1;
-
-              incremental_LSF(&lsf_results, xProbe, yProbe, measured_z);
-
-            #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
-
-              z_values[xCount][yCount] = measured_z + zoffset;
-
-            #endif
-
-            abl_should_enable = false;
-            idle();
-
-          } // inner
-        } // outer
-
-      #elif ENABLED(AUTO_BED_LEVELING_3POINT)
-
-        // Probe at 3 arbitrary points
-
-        for (uint8_t i = 0; i < 3; ++i) {
-          // Retain the last probe position
-          xProbe = LOGICAL_X_POSITION(points[i].x);
-          yProbe = LOGICAL_Y_POSITION(points[i].y);
-          measured_z = faux ? 0.001 * random(-100, 101) : probe_pt(xProbe, yProbe, stow_probe_after_each, verbose_level);
-          if (isnan(measured_z)) {
-            planner.abl_enabled = abl_should_enable;
-            break;
-          }
-          points[i].z = measured_z;
-        }
-
-        if (!dryrun && !isnan(measured_z)) {
-          vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
-          if (planeNormal.z < 0) {
-            planeNormal.x *= -1;
-            planeNormal.y *= -1;
-            planeNormal.z *= -1;
-          }
-          planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
-
-          // Can't re-enable (on error) until the new grid is written
-          abl_should_enable = false;
-        }
-
-      #endif // AUTO_BED_LEVELING_3POINT
-
-      // Raise to _Z_CLEARANCE_DEPLOY_PROBE. Stow the probe.
-      if (STOW_PROBE()) {
-        planner.abl_enabled = abl_should_enable;
-        measured_z = NAN;
-      }
-    }
-    #endif // !PROBE_MANUALLY
-
-    //
-    // G29 Finishing Code
-    //
-    // Unless this is a dry run, auto bed leveling will
-    // definitely be enabled after this point.
-    //
-    // If code above wants to continue leveling, it should
-    // return or loop before this point.
-    //
-
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) DEBUG_POS("> probing complete", current_position);
-    #endif
-
-    #if ENABLED(PROBE_MANUALLY)
-      g29_in_progress = false;
-      #if ENABLED(LCD_BED_LEVELING)
-        lcd_wait_for_move = false;
-      #endif
-    #endif
-
-    // Calculate leveling, print reports, correct the position
-    if (!isnan(measured_z)) {
-      #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
-
-        if (!dryrun) extrapolate_unprobed_bed_level();
-        print_bilinear_leveling_grid();
-
-        refresh_bed_level();
-
-        #if ENABLED(ABL_BILINEAR_SUBDIVISION)
-          print_bilinear_leveling_grid_virt();
-        #endif
-
-      #elif ENABLED(AUTO_BED_LEVELING_LINEAR)
-
-        // For LINEAR leveling calculate matrix, print reports, correct the position
-
-        /**
-         * solve the plane equation ax + by + d = z
-         * A is the matrix with rows [x y 1] for all the probed points
-         * B is the vector of the Z positions
-         * the normal vector to the plane is formed by the coefficients of the
-         * plane equation in the standard form, which is Vx*x+Vy*y+Vz*z+d = 0
-         * so Vx = -a Vy = -b Vz = 1 (we want the vector facing towards positive Z
-         */
-        float plane_equation_coefficients[3];
-
-        finish_incremental_LSF(&lsf_results);
-        plane_equation_coefficients[0] = -lsf_results.A;  // We should be able to eliminate the '-' on these three lines and down below
-        plane_equation_coefficients[1] = -lsf_results.B;  // but that is not yet tested.
-        plane_equation_coefficients[2] = -lsf_results.D;
-
-        mean /= abl2;
-
-        if (verbose_level) {
-          SERIAL_PROTOCOLPGM("Eqn coefficients: a: ");
-          SERIAL_PROTOCOL_F(plane_equation_coefficients[0], 8);
-          SERIAL_PROTOCOLPGM(" b: ");
-          SERIAL_PROTOCOL_F(plane_equation_coefficients[1], 8);
-          SERIAL_PROTOCOLPGM(" d: ");
-          SERIAL_PROTOCOL_F(plane_equation_coefficients[2], 8);
-          SERIAL_EOL();
-          if (verbose_level > 2) {
-            SERIAL_PROTOCOLPGM("Mean of sampled points: ");
-            SERIAL_PROTOCOL_F(mean, 8);
-            SERIAL_EOL();
-          }
-        }
-
-        // Create the matrix but don't correct the position yet
-        if (!dryrun)
-          planner.bed_level_matrix = matrix_3x3::create_look_at(
-            vector_3(-plane_equation_coefficients[0], -plane_equation_coefficients[1], 1)    // We can eliminate the '-' here and up above
-          );
-
-        // Show the Topography map if enabled
-        if (do_topography_map) {
-
-          SERIAL_PROTOCOLLNPGM("\nBed Height Topography:\n"
-                                 "   +--- BACK --+\n"
-                                 "   |           |\n"
-                                 " L |    (+)    | R\n"
-                                 " E |           | I\n"
-                                 " F | (-) N (+) | G\n"
-                                 " T |           | H\n"
-                                 "   |    (-)    | T\n"
-                                 "   |           |\n"
-                                 "   O-- FRONT --+\n"
-                                 " (0,0)");
-
-          float min_diff = 999;
-
-          for (int8_t yy = abl_grid_points_y - 1; yy >= 0; yy--) {
-            for (uint8_t xx = 0; xx < abl_grid_points_x; xx++) {
-              int ind = indexIntoAB[xx][yy];
-              float diff = eqnBVector[ind] - mean,
-                    x_tmp = eqnAMatrix[ind + 0 * abl2],
-                    y_tmp = eqnAMatrix[ind + 1 * abl2],
-                    z_tmp = 0;
-
-              apply_rotation_xyz(planner.bed_level_matrix, x_tmp, y_tmp, z_tmp);
-
-              NOMORE(min_diff, eqnBVector[ind] - z_tmp);
-
-              if (diff >= 0.0)
-                SERIAL_PROTOCOLPGM(" +");   // Include + for column alignment
-              else
-                SERIAL_PROTOCOLCHAR(' ');
-              SERIAL_PROTOCOL_F(diff, 5);
-            } // xx
-            SERIAL_EOL();
-          } // yy
-          SERIAL_EOL();
-
-          if (verbose_level > 3) {
-            SERIAL_PROTOCOLLNPGM("\nCorrected Bed Height vs. Bed Topology:");
-
-            for (int8_t yy = abl_grid_points_y - 1; yy >= 0; yy--) {
-              for (uint8_t xx = 0; xx < abl_grid_points_x; xx++) {
-                int ind = indexIntoAB[xx][yy];
-                float x_tmp = eqnAMatrix[ind + 0 * abl2],
-                      y_tmp = eqnAMatrix[ind + 1 * abl2],
-                      z_tmp = 0;
-
-                apply_rotation_xyz(planner.bed_level_matrix, x_tmp, y_tmp, z_tmp);
-
-                float diff = eqnBVector[ind] - z_tmp - min_diff;
-                if (diff >= 0.0)
-                  SERIAL_PROTOCOLPGM(" +");
-                // Include + for column alignment
-                else
-                  SERIAL_PROTOCOLCHAR(' ');
-                SERIAL_PROTOCOL_F(diff, 5);
-              } // xx
-              SERIAL_EOL();
-            } // yy
-            SERIAL_EOL();
-          }
-        } //do_topography_map
-
-      #endif // AUTO_BED_LEVELING_LINEAR
-
-      #if ABL_PLANAR
-
-        // For LINEAR and 3POINT leveling correct the current position
-
-        if (verbose_level > 0)
-          planner.bed_level_matrix.debug(PSTR("\n\nBed Level Correction Matrix:"));
-
-        if (!dryrun) {
-          //
-          // Correct the current XYZ position based on the tilted plane.
-          //
-
-          #if ENABLED(DEBUG_LEVELING_FEATURE)
-            if (DEBUGGING(LEVELING)) DEBUG_POS("G29 uncorrected XYZ", current_position);
-          #endif
-
-          float converted[XYZ];
-          COPY(converted, current_position);
-
-          planner.abl_enabled = true;
-          planner.unapply_leveling(converted); // use conversion machinery
-          planner.abl_enabled = false;
-
-          // Use the last measured distance to the bed, if possible
-          if ( NEAR(current_position[X_AXIS], xProbe - (X_PROBE_OFFSET_FROM_EXTRUDER))
-            && NEAR(current_position[Y_AXIS], yProbe - (Y_PROBE_OFFSET_FROM_EXTRUDER))
-          ) {
-            const float simple_z = current_position[Z_AXIS] - measured_z;
-            #if ENABLED(DEBUG_LEVELING_FEATURE)
-              if (DEBUGGING(LEVELING)) {
-                SERIAL_ECHOPAIR("Z from Probe:", simple_z);
-                SERIAL_ECHOPAIR("  Matrix:", converted[Z_AXIS]);
-                SERIAL_ECHOLNPAIR("  Discrepancy:", simple_z - converted[Z_AXIS]);
-              }
-            #endif
-            converted[Z_AXIS] = simple_z;
-          }
-
-          // The rotated XY and corrected Z are now current_position
-          COPY(current_position, converted);
-
-          #if ENABLED(DEBUG_LEVELING_FEATURE)
-            if (DEBUGGING(LEVELING)) DEBUG_POS("G29 corrected XYZ", current_position);
-          #endif
-        }
-
-      #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
-
-        if (!dryrun) {
-          #if ENABLED(DEBUG_LEVELING_FEATURE)
-            if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("G29 uncorrected Z:", current_position[Z_AXIS]);
-          #endif
-
-          // Unapply the offset because it is going to be immediately applied
-          // and cause compensation movement in Z
-          current_position[Z_AXIS] -= bilinear_z_offset(current_position);
-
-          #if ENABLED(DEBUG_LEVELING_FEATURE)
-            if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR(" corrected Z:", current_position[Z_AXIS]);
-          #endif
-        }
-
-      #endif // ABL_PLANAR
-
-      #ifdef Z_PROBE_END_SCRIPT
-        #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
-        #endif
-        enqueue_and_echo_commands_P(PSTR(Z_PROBE_END_SCRIPT));
-        stepper.synchronize();
-      #endif
-
-      // Auto Bed Leveling is complete! Enable if possible.
-      planner.abl_enabled = dryrun ? abl_should_enable : true;
-    } // !isnan(measured_z)
-
-    // Restore state after probing
-    if (!faux) clean_up_after_endstop_or_probe_move();
-
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< gcode_G29");
-    #endif
-
-    report_current_position();
-
-    KEEPALIVE_STATE(IN_HANDLER);
-
-    if (planner.abl_enabled)
-      SYNC_PLAN_POSITION_KINEMATIC();
-  }
-
-#endif // HAS_ABL && !AUTO_BED_LEVELING_UBL
-
-#if HAS_BED_PROBE
-
-  /**
-   * G30: Do a single Z probe at the current XY
-   *
-   * Parameters:
-   *
-   *   X   Probe X position (default current X)
-   *   Y   Probe Y position (default current Y)
-   *   S0  Leave the probe deployed
-   */
-  inline void gcode_G30() {
-    const float xpos = parser.linearval('X', current_position[X_AXIS] + X_PROBE_OFFSET_FROM_EXTRUDER),
-                ypos = parser.linearval('Y', current_position[Y_AXIS] + Y_PROBE_OFFSET_FROM_EXTRUDER);
-
-    if (!position_is_reachable_by_probe_xy(xpos, ypos)) return;
-
-    // Disable leveling so the planner won't mess with us
-    #if HAS_LEVELING
-      set_bed_leveling_enabled(false);
-    #endif
-
-    setup_for_endstop_or_probe_move();
-
-    const float measured_z = probe_pt(xpos, ypos, parser.boolval('S', true), 1);
-
-    if (!isnan(measured_z)) {
-      SERIAL_PROTOCOLPAIR("Bed X: ", FIXFLOAT(xpos));
-      SERIAL_PROTOCOLPAIR(" Y: ", FIXFLOAT(ypos));
-      SERIAL_PROTOCOLLNPAIR(" Z: ", FIXFLOAT(measured_z));
-    }
-
-    clean_up_after_endstop_or_probe_move();
-
-    report_current_position();
-  }
-
-  #if ENABLED(Z_PROBE_SLED)
-
-    /**
-     * G31: Deploy the Z probe
-     */
-    inline void gcode_G31() { DEPLOY_PROBE(); }
-
-    /**
-     * G32: Stow the Z probe
-     */
-    inline void gcode_G32() { STOW_PROBE(); }
-
-  #endif // Z_PROBE_SLED
-
-#endif // HAS_BED_PROBE
-
-#if PROBE_SELECTED
-
-  #if ENABLED(DELTA_AUTO_CALIBRATION)
-    /**
-     * G33 - Delta '1-4-7-point' Auto-Calibration
-     *       Calibrate height, endstops, delta radius, and tower angles.
-     *
-     * Parameters:
-     *
-     *   Pn  Number of probe points:
-     *
-     *      P1     Probe center and set height only.
-     *      P2     Probe center and towers. Set height, endstops, and delta radius.
-     *      P3     Probe all positions: center, towers and opposite towers. Set all.
-     *      P4-P7  Probe all positions at different locations and average them.
-     *
-     *   T0  Don't calibrate tower angle corrections
-     *
-     *   Cn.nn Calibration precision; when omitted calibrates to maximum precision
-     *
-     *   Fn  Force to run at least n iterations and takes the best result
-     *
-     *   Vn  Verbose level:
-     *
-     *      V0  Dry-run mode. Report settings and probe results. No calibration.
-     *      V1  Report settings
-     *      V2  Report settings and probe results
-     *
-     *   E   Engage the probe for each point
-     */
-
-    void print_signed_float(const char * const prefix, const float &f) {
-      SERIAL_PROTOCOLPGM("  ");
-      serialprintPGM(prefix);
-      SERIAL_PROTOCOLCHAR(':');
-      if (f >= 0) SERIAL_CHAR('+');
-      SERIAL_PROTOCOL_F(f, 2);
-    }
-
-    inline void print_G33_settings(const bool end_stops, const bool tower_angles){ // TODO echo these to LCD ???
-      SERIAL_PROTOCOLPAIR(".Height:", DELTA_HEIGHT + home_offset[Z_AXIS]);
-      if (end_stops) {
-        print_signed_float(PSTR("  Ex"), endstop_adj[A_AXIS]);
-        print_signed_float(PSTR("Ey"), endstop_adj[B_AXIS]);
-        print_signed_float(PSTR("Ez"), endstop_adj[C_AXIS]);
-        SERIAL_PROTOCOLPAIR("    Radius:", delta_radius);
-      }
-      SERIAL_EOL();
-      if (tower_angles) {
-        SERIAL_PROTOCOLPGM(".Tower angle :  ");
-        print_signed_float(PSTR("Tx"), delta_tower_angle_trim[A_AXIS]);
-        print_signed_float(PSTR("Ty"), delta_tower_angle_trim[B_AXIS]);
-        SERIAL_PROTOCOLLNPGM("  Tz:+0.00");
-      }
-    }
-
-    void G33_cleanup(
-      #if HOTENDS > 1
-        const uint8_t old_tool_index
-      #endif
-    ) {
-      #if ENABLED(DELTA_HOME_TO_SAFE_ZONE)
-        do_blocking_move_to_z(delta_clip_start_height);
-      #endif
-      STOW_PROBE();
-      clean_up_after_endstop_or_probe_move();
-      #if HOTENDS > 1
-        tool_change(old_tool_index, 0, true);
-      #endif
-    }
-
-    inline void gcode_G33() {
-
-      const int8_t probe_points = parser.intval('P', DELTA_CALIBRATION_DEFAULT_POINTS);
-      if (!WITHIN(probe_points, 1, 7)) {
-        SERIAL_PROTOCOLLNPGM("?(P)oints is implausible (1-7).");
-        return;
-      }
-
-      const int8_t verbose_level = parser.byteval('V', 1);
-      if (!WITHIN(verbose_level, 0, 2)) {
-        SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-2).");
-        return;
-      }
-
-      const float calibration_precision = parser.floatval('C');
-      if (calibration_precision < 0) {
-        SERIAL_PROTOCOLLNPGM("?(C)alibration precision is implausible (>0).");
-        return;
-      }
-
-      const int8_t force_iterations = parser.intval('F', 0);
-      if (!WITHIN(force_iterations, 0, 30)) {
-        SERIAL_PROTOCOLLNPGM("?(F)orce iteration is implausible (0-30).");
-        return;
-      }
-
-      const bool towers_set           = parser.boolval('T', true),
-                 stow_after_each      = parser.boolval('E'),
-                 _1p_calibration      = probe_points == 1,
-                 _4p_calibration      = probe_points == 2,
-                 _4p_towers_points    = _4p_calibration && towers_set,
-                 _4p_opposite_points  = _4p_calibration && !towers_set,
-                 _7p_calibration      = probe_points >= 3,
-                 _7p_half_circle      = probe_points == 3,
-                 _7p_double_circle    = probe_points == 5,
-                 _7p_triple_circle    = probe_points == 6,
-                 _7p_quadruple_circle = probe_points == 7,
-                 _7p_multi_circle     = _7p_double_circle || _7p_triple_circle || _7p_quadruple_circle,
-                 _7p_intermed_points  = _7p_calibration && !_7p_half_circle;
-      const static char save_message[] PROGMEM = "Save with M500 and/or copy to Configuration.h";
-      const float dx = (X_PROBE_OFFSET_FROM_EXTRUDER),
-                  dy = (Y_PROBE_OFFSET_FROM_EXTRUDER);
-      int8_t iterations = 0;
-      float test_precision,
-            zero_std_dev = (verbose_level ? 999.0 : 0.0), // 0.0 in dry-run mode : forced end
-            zero_std_dev_old = zero_std_dev,
-            zero_std_dev_min = zero_std_dev,
-            e_old[XYZ] = {
-              endstop_adj[A_AXIS],
-              endstop_adj[B_AXIS],
-              endstop_adj[C_AXIS]
-            },
-            dr_old = delta_radius,
-            zh_old = home_offset[Z_AXIS],
-            alpha_old = delta_tower_angle_trim[A_AXIS],
-            beta_old = delta_tower_angle_trim[B_AXIS];
-
-      if (!_1p_calibration) {  // test if the outer radius is reachable
-        const float circles = (_7p_quadruple_circle ? 1.5 :
-                               _7p_triple_circle    ? 1.0 :
-                               _7p_double_circle    ? 0.5 : 0),
-                    r = (1 + circles * 0.1) * delta_calibration_radius;
-        for (uint8_t axis = 1; axis < 13; ++axis) {
-          const float a = RADIANS(180 + 30 * axis);
-          if (!position_is_reachable_xy(cos(a) * r, sin(a) * r)) {
-            SERIAL_PROTOCOLLNPGM("?(M665 B)ed radius is implausible.");
-            return;
-          }
-        }
-      }
-      SERIAL_PROTOCOLLNPGM("G33 Auto Calibrate");
-
-      stepper.synchronize();
-      #if HAS_LEVELING
-        reset_bed_level(); // After calibration bed-level data is no longer valid
-      #endif
-
-      #if HOTENDS > 1
-        const uint8_t old_tool_index = active_extruder;
-        tool_change(0, 0, true);
-        #define G33_CLEANUP() G33_cleanup(old_tool_index)
-      #else
-        #define G33_CLEANUP() G33_cleanup()
-      #endif
-
-      setup_for_endstop_or_probe_move();
-      endstops.enable(true);
-      if (!home_delta())
-        return;
-      endstops.not_homing();
-
-      // print settings
-
-      const char *checkingac = PSTR("Checking... AC"); // TODO: Make translatable string
-      serialprintPGM(checkingac);
-      if (verbose_level == 0) SERIAL_PROTOCOLPGM(" (DRY-RUN)");
-      SERIAL_EOL();
-      lcd_setstatusPGM(checkingac);
-
-      print_G33_settings(!_1p_calibration, _7p_calibration && towers_set);
-
-      #if DISABLED(PROBE_MANUALLY)
-        const float measured_z = probe_pt(dx, dy, stow_after_each, 1, false); // 1st probe to set height
-        if (isnan(measured_z)) return G33_CLEANUP();
-        home_offset[Z_AXIS] -= measured_z;
-      #endif
-
-      do {
-
-        float z_at_pt[13] = { 0.0 };
-
-        test_precision = zero_std_dev_old != 999.0 ? (zero_std_dev + zero_std_dev_old) / 2 : zero_std_dev;
-
-        iterations++;
-
-        // Probe the points
-
-        if (!_7p_half_circle && !_7p_triple_circle) { // probe the center
-          #if ENABLED(PROBE_MANUALLY)
-            z_at_pt[0] += lcd_probe_pt(0, 0);
-          #else
-            z_at_pt[0] += probe_pt(dx, dy, stow_after_each, 1, false);
-            if (isnan(z_at_pt[0])) return G33_CLEANUP();
-          #endif
-        }
-        if (_7p_calibration) { // probe extra center points
-          for (int8_t axis = _7p_multi_circle ? 11 : 9; axis > 0; axis -= _7p_multi_circle ? 2 : 4) {
-            const float a = RADIANS(180 + 30 * axis), r = delta_calibration_radius * 0.1;
-            #if ENABLED(PROBE_MANUALLY)
-              z_at_pt[0] += lcd_probe_pt(cos(a) * r, sin(a) * r);
-            #else
-              z_at_pt[0] += probe_pt(cos(a) * r + dx, sin(a) * r + dy, stow_after_each, 1);
-              if (isnan(z_at_pt[0])) return G33_CLEANUP();
-            #endif
-          }
-          z_at_pt[0] /= float(_7p_double_circle ? 7 : probe_points);
-        }
-        if (!_1p_calibration) {  // probe the radius
-          bool zig_zag = true;
-          const uint8_t start = _4p_opposite_points ? 3 : 1,
-                         step = _4p_calibration ? 4 : _7p_half_circle ? 2 : 1;
-          for (uint8_t axis = start; axis < 13; axis += step) {
-            const float zigadd = (zig_zag ? 0.5 : 0.0),
-                        offset_circles = _7p_quadruple_circle ? zigadd + 1.0 :
-                                         _7p_triple_circle    ? zigadd + 0.5 :
-                                         _7p_double_circle    ? zigadd : 0;
-            for (float circles = -offset_circles ; circles <= offset_circles; circles++) {
-              const float a = RADIANS(180 + 30 * axis),
-                          r = delta_calibration_radius * (1 + circles * (zig_zag ? 0.1 : -0.1));
-              #if ENABLED(PROBE_MANUALLY)
-                z_at_pt[axis] += lcd_probe_pt(cos(a) * r, sin(a) * r);
-              #else
-                z_at_pt[axis] += probe_pt(cos(a) * r + dx, sin(a) * r + dy, stow_after_each, 1);
-                if (isnan(z_at_pt[axis])) return G33_CLEANUP();
-              #endif
-            }
-            zig_zag = !zig_zag;
-            z_at_pt[axis] /= (2 * offset_circles + 1);
-          }
-        }
-        if (_7p_intermed_points) // average intermediates to tower and opposites
-          for (uint8_t axis = 1; axis < 13; axis += 2)
-            z_at_pt[axis] = (z_at_pt[axis] + (z_at_pt[axis + 1] + z_at_pt[(axis + 10) % 12 + 1]) / 2.0) / 2.0;
-
-        float S1 = z_at_pt[0],
-              S2 = sq(z_at_pt[0]);
-        int16_t N = 1;
-        if (!_1p_calibration) // std dev from zero plane
-          for (uint8_t axis = (_4p_opposite_points ? 3 : 1); axis < 13; axis += (_4p_calibration ? 4 : 2)) {
-            S1 += z_at_pt[axis];
-            S2 += sq(z_at_pt[axis]);
-            N++;
-          }
-        zero_std_dev_old = zero_std_dev;
-        zero_std_dev = round(SQRT(S2 / N) * 1000.0) / 1000.0 + 0.00001;
-
-        // Solve matrices
-
-        if ((zero_std_dev < test_precision && zero_std_dev > calibration_precision) || iterations <= force_iterations) {
-          if (zero_std_dev < zero_std_dev_min) {
-            COPY(e_old, endstop_adj);
-            dr_old = delta_radius;
-            zh_old = home_offset[Z_AXIS];
-            alpha_old = delta_tower_angle_trim[A_AXIS];
-            beta_old = delta_tower_angle_trim[B_AXIS];
-          }
-
-          float e_delta[XYZ] = { 0.0 }, r_delta = 0.0, t_alpha = 0.0, t_beta = 0.0;
-          const float r_diff = delta_radius - delta_calibration_radius,
-                      h_factor = 1.00 + r_diff * 0.001,                          //1.02 for r_diff = 20mm
-                      r_factor = -(1.75 + 0.005 * r_diff + 0.001 * sq(r_diff)),  //2.25 for r_diff = 20mm
-                      a_factor = 100.0 / delta_calibration_radius;               //1.25 for cal_rd = 80mm
-
-          #define ZP(N,I) ((N) * z_at_pt[I])
-          #define Z1000(I) ZP(1.00, I)
-          #define Z1050(I) ZP(h_factor, I)
-          #define Z0700(I) ZP(h_factor * 2.0 / 3.00, I)
-          #define Z0350(I) ZP(h_factor / 3.00, I)
-          #define Z0175(I) ZP(h_factor / 6.00, I)
-          #define Z2250(I) ZP(r_factor, I)
-          #define Z0750(I) ZP(r_factor / 3.00, I)
-          #define Z0375(I) ZP(r_factor / 6.00, I)
-          #define Z0444(I) ZP(a_factor * 4.0 / 9.0, I)
-          #define Z0888(I) ZP(a_factor * 8.0 / 9.0, I)
-
-          #if ENABLED(PROBE_MANUALLY)
-            test_precision = 0.00; // forced end
-          #endif
-
-          switch (probe_points) {
-            case 1:
-              test_precision = 0.00; // forced end
-              LOOP_XYZ(i) e_delta[i] = Z1000(0);
-              break;
-
-            case 2:
-              if (towers_set) {
-                e_delta[X_AXIS] = Z1050(0) + Z0700(1) - Z0350(5) - Z0350(9);
-                e_delta[Y_AXIS] = Z1050(0) - Z0350(1) + Z0700(5) - Z0350(9);
-                e_delta[Z_AXIS] = Z1050(0) - Z0350(1) - Z0350(5) + Z0700(9);
-                r_delta         = Z2250(0) - Z0750(1) - Z0750(5) - Z0750(9);
-              }
-              else {
-                e_delta[X_AXIS] = Z1050(0) - Z0700(7) + Z0350(11) + Z0350(3);
-                e_delta[Y_AXIS] = Z1050(0) + Z0350(7) - Z0700(11) + Z0350(3);
-                e_delta[Z_AXIS] = Z1050(0) + Z0350(7) + Z0350(11) - Z0700(3);
-                r_delta         = Z2250(0) - Z0750(7) - Z0750(11) - Z0750(3);
-              }
-              break;
-
-            default:
-              e_delta[X_AXIS] = Z1050(0) + Z0350(1) - Z0175(5) - Z0175(9) - Z0350(7) + Z0175(11) + Z0175(3);
-              e_delta[Y_AXIS] = Z1050(0) - Z0175(1) + Z0350(5) - Z0175(9) + Z0175(7) - Z0350(11) + Z0175(3);
-              e_delta[Z_AXIS] = Z1050(0) - Z0175(1) - Z0175(5) + Z0350(9) + Z0175(7) + Z0175(11) - Z0350(3);
-              r_delta         = Z2250(0) - Z0375(1) - Z0375(5) - Z0375(9) - Z0375(7) - Z0375(11) - Z0375(3);
-
-              if (towers_set) {
-                t_alpha = Z0444(1) - Z0888(5) + Z0444(9) + Z0444(7) - Z0888(11) + Z0444(3);
-                t_beta  = Z0888(1) - Z0444(5) - Z0444(9) + Z0888(7) - Z0444(11) - Z0444(3);
-              }
-              break;
-          }
-
-          LOOP_XYZ(axis) endstop_adj[axis] += e_delta[axis];
-          delta_radius += r_delta;
-          delta_tower_angle_trim[A_AXIS] += t_alpha;
-          delta_tower_angle_trim[B_AXIS] += t_beta;
-
-          // adjust delta_height and endstops by the max amount
-          const float z_temp = MAX3(endstop_adj[A_AXIS], endstop_adj[B_AXIS], endstop_adj[C_AXIS]);
-          home_offset[Z_AXIS] -= z_temp;
-          LOOP_XYZ(i) endstop_adj[i] -= z_temp;
-
-          recalc_delta_settings(delta_radius, delta_diagonal_rod);
-        }
-        else if (zero_std_dev >= test_precision) {   // step one back
-          COPY(endstop_adj, e_old);
-          delta_radius = dr_old;
-          home_offset[Z_AXIS] = zh_old;
-          delta_tower_angle_trim[A_AXIS] = alpha_old;
-          delta_tower_angle_trim[B_AXIS] = beta_old;
-
-          recalc_delta_settings(delta_radius, delta_diagonal_rod);
-        }
-        NOMORE(zero_std_dev_min, zero_std_dev);
-
-        // print report
-
-        if (verbose_level != 1) {
-          SERIAL_PROTOCOLPGM(".    ");
-          print_signed_float(PSTR("c"), z_at_pt[0]);
-          if (_4p_towers_points || _7p_calibration) {
-            print_signed_float(PSTR("   x"), z_at_pt[1]);
-            print_signed_float(PSTR(" y"), z_at_pt[5]);
-            print_signed_float(PSTR(" z"), z_at_pt[9]);
-          }
-          if (!_4p_opposite_points) SERIAL_EOL();
-          if ((_4p_opposite_points) || _7p_calibration) {
-            if (_7p_calibration) {
-              SERIAL_CHAR('.');
-              SERIAL_PROTOCOL_SP(13);
-            }
-            print_signed_float(PSTR("  yz"), z_at_pt[7]);
-            print_signed_float(PSTR("zx"), z_at_pt[11]);
-            print_signed_float(PSTR("xy"), z_at_pt[3]);
-            SERIAL_EOL();
-          }
-        }
-        if (verbose_level != 0) {                                    // !dry run
-          if ((zero_std_dev >= test_precision || zero_std_dev <= calibration_precision) && iterations > force_iterations) {  // end iterations
-            SERIAL_PROTOCOLPGM("Calibration OK");
-            SERIAL_PROTOCOL_SP(36);
-            #if DISABLED(PROBE_MANUALLY)
-              if (zero_std_dev >= test_precision && !_1p_calibration)
-                SERIAL_PROTOCOLPGM("rolling back.");
-              else
-            #endif
-              {
-                SERIAL_PROTOCOLPGM("std dev:");
-                SERIAL_PROTOCOL_F(zero_std_dev_min, 3);
-              }
-            SERIAL_EOL();
-            char mess[21];
-            sprintf_P(mess, PSTR("Calibration sd:"));
-            if (zero_std_dev_min < 1)
-              sprintf_P(&mess[15], PSTR("0.%03i"), (int)round(zero_std_dev_min * 1000.0));
-            else
-              sprintf_P(&mess[15], PSTR("%03i.x"), (int)round(zero_std_dev_min));
-            lcd_setstatus(mess);
-            print_G33_settings(!_1p_calibration, _7p_calibration && towers_set);
-            serialprintPGM(save_message);
-            SERIAL_EOL();
-          }
-          else {                                                     // !end iterations
-            char mess[15];
-            if (iterations < 31)
-              sprintf_P(mess, PSTR("Iteration : %02i"), (int)iterations);
-            else
-              sprintf_P(mess, PSTR("No convergence"));
-            SERIAL_PROTOCOL(mess);
-            SERIAL_PROTOCOL_SP(36);
-            SERIAL_PROTOCOLPGM("std dev:");
-            SERIAL_PROTOCOL_F(zero_std_dev, 3);
-            SERIAL_EOL();
-            lcd_setstatus(mess);
-            print_G33_settings(!_1p_calibration, _7p_calibration && towers_set);
-          }
-        }
-        else {                                                       // dry run
-          const char *enddryrun = PSTR("End DRY-RUN");
-          serialprintPGM(enddryrun);
-          SERIAL_PROTOCOL_SP(39);
-          SERIAL_PROTOCOLPGM("std dev:");
-          SERIAL_PROTOCOL_F(zero_std_dev, 3);
-          SERIAL_EOL();
-
-          char mess[21];
-          sprintf_P(mess, enddryrun);
-          sprintf_P(&mess[11], PSTR(" sd:"));
-          if (zero_std_dev < 1)
-            sprintf_P(&mess[15], PSTR("0.%03i"), (int)round(zero_std_dev * 1000.0));
-          else
-            sprintf_P(&mess[15], PSTR("%03i.x"), (int)round(zero_std_dev));
-          lcd_setstatus(mess);
-        }
-
-        endstops.enable(true);
-        home_delta();
-        endstops.not_homing();
-
-      }
-      while ((zero_std_dev < test_precision && zero_std_dev > calibration_precision && iterations < 31) || iterations <= force_iterations);
-
-      G33_CLEANUP();
-    }
-
-  #endif // DELTA_AUTO_CALIBRATION
-
-#endif // PROBE_SELECTED
-
-#if ENABLED(G38_PROBE_TARGET)
-
-  static bool G38_run_probe() {
-
-    bool G38_pass_fail = false;
-
-    #if ENABLED(PROBE_DOUBLE_TOUCH)
-      // Get direction of move and retract
-      float retract_mm[XYZ];
-      LOOP_XYZ(i) {
-        float dist = destination[i] - current_position[i];
-        retract_mm[i] = FABS(dist) < G38_MINIMUM_MOVE ? 0 : home_bump_mm((AxisEnum)i) * (dist > 0 ? -1 : 1);
-      }
-    #endif
-
-    stepper.synchronize();  // wait until the machine is idle
-
-    // Move until destination reached or target hit
-    endstops.enable(true);
-    G38_move = true;
-    G38_endstop_hit = false;
-    prepare_move_to_destination();
-    stepper.synchronize();
-    G38_move = false;
-
-    endstops.hit_on_purpose();
-    set_current_from_steppers_for_axis(ALL_AXES);
-    SYNC_PLAN_POSITION_KINEMATIC();
-
-    if (G38_endstop_hit) {
-
-      G38_pass_fail = true;
-
-      #if ENABLED(PROBE_DOUBLE_TOUCH)
-        // Move away by the retract distance
-        set_destination_to_current();
-        LOOP_XYZ(i) destination[i] += retract_mm[i];
-        endstops.enable(false);
-        prepare_move_to_destination();
-        stepper.synchronize();
-
-        feedrate_mm_s /= 4;
-
-        // Bump the target more slowly
-        LOOP_XYZ(i) destination[i] -= retract_mm[i] * 2;
-
-        endstops.enable(true);
-        G38_move = true;
-        prepare_move_to_destination();
-        stepper.synchronize();
-        G38_move = false;
-
-        set_current_from_steppers_for_axis(ALL_AXES);
-        SYNC_PLAN_POSITION_KINEMATIC();
-      #endif
-    }
-
-    endstops.hit_on_purpose();
-    endstops.not_homing();
-    return G38_pass_fail;
-  }
-
-  /**
-   * G38.2 - probe toward workpiece, stop on contact, signal error if failure
-   * G38.3 - probe toward workpiece, stop on contact
-   *
-   * Like G28 except uses Z min probe for all axes
-   */
-  inline void gcode_G38(bool is_38_2) {
-    // Get X Y Z E F
-    gcode_get_destination();
-
-    setup_for_endstop_or_probe_move();
-
-    // If any axis has enough movement, do the move
-    LOOP_XYZ(i)
-      if (FABS(destination[i] - current_position[i]) >= G38_MINIMUM_MOVE) {
-        if (!parser.seenval('F')) feedrate_mm_s = homing_feedrate((AxisEnum)i);
-        // If G38.2 fails throw an error
-        if (!G38_run_probe() && is_38_2) {
-          SERIAL_ERROR_START();
-          SERIAL_ERRORLNPGM("Failed to reach target");
-        }
-        break;
-      }
-
-    clean_up_after_endstop_or_probe_move();
-  }
-
-#endif // G38_PROBE_TARGET
-
-#if ENABLED(AUTO_BED_LEVELING_BILINEAR) || ENABLED(AUTO_BED_LEVELING_UBL) || ENABLED(MESH_BED_LEVELING)
-
-  /**
-   * G42: Move X & Y axes to mesh coordinates (I & J)
-   */
-  inline void gcode_G42() {
-    if (IsRunning()) {
-      const bool hasI = parser.seenval('I');
-      const int8_t ix = hasI ? parser.value_int() : 0;
-      const bool hasJ = parser.seenval('J');
-      const int8_t iy = hasJ ? parser.value_int() : 0;
-
-      if ((hasI && !WITHIN(ix, 0, GRID_MAX_POINTS_X - 1)) || (hasJ && !WITHIN(iy, 0, GRID_MAX_POINTS_Y - 1))) {
-        SERIAL_ECHOLNPGM(MSG_ERR_MESH_XY);
-        return;
-      }
-
-      #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
-        #define _GET_MESH_X(I) bilinear_start[X_AXIS] + I * bilinear_grid_spacing[X_AXIS]
-        #define _GET_MESH_Y(J) bilinear_start[Y_AXIS] + J * bilinear_grid_spacing[Y_AXIS]
-      #elif ENABLED(AUTO_BED_LEVELING_UBL)
-        #define _GET_MESH_X(I) ubl.mesh_index_to_xpos(I)
-        #define _GET_MESH_Y(J) ubl.mesh_index_to_ypos(J)
-      #elif ENABLED(MESH_BED_LEVELING)
-        #define _GET_MESH_X(I) mbl.index_to_xpos[I]
-        #define _GET_MESH_Y(J) mbl.index_to_ypos[J]
-      #endif
-
-      set_destination_to_current();
-      if (hasI) destination[X_AXIS] = LOGICAL_X_POSITION(_GET_MESH_X(ix));
-      if (hasJ) destination[Y_AXIS] = LOGICAL_Y_POSITION(_GET_MESH_Y(iy));
-      if (parser.boolval('P')) {
-        if (hasI) destination[X_AXIS] -= X_PROBE_OFFSET_FROM_EXTRUDER;
-        if (hasJ) destination[Y_AXIS] -= Y_PROBE_OFFSET_FROM_EXTRUDER;
-      }
-
-      const float fval = parser.linearval('F');
-      if (fval > 0.0) feedrate_mm_s = MMM_TO_MMS(fval);
-
-      // SCARA kinematic has "safe" XY raw moves
-      #if IS_SCARA
-        prepare_uninterpolated_move_to_destination();
-      #else
-        prepare_move_to_destination();
-      #endif
-    }
-  }
-
-#endif // AUTO_BED_LEVELING_UBL
-
-/**
- * G92: Set current position to given X Y Z E
- */
-inline void gcode_G92() {
-  bool didXYZ = false,
-       didE = parser.seenval('E');
-
-  if (!didE) stepper.synchronize();
-
-  LOOP_XYZE(i) {
-    if (parser.seenval(axis_codes[i])) {
-      #if IS_SCARA
-        current_position[i] = parser.value_axis_units((AxisEnum)i);
-        if (i != E_AXIS) didXYZ = true;
-      #else
-        #if HAS_POSITION_SHIFT
-          const float p = current_position[i];
-        #endif
-        const float v = parser.value_axis_units((AxisEnum)i);
-
-        current_position[i] = v;
-
-        if (i != E_AXIS) {
-          didXYZ = true;
-          #if HAS_POSITION_SHIFT
-            position_shift[i] += v - p; // Offset the coordinate space
-            update_software_endstops((AxisEnum)i);
-
-            #if ENABLED(I2C_POSITION_ENCODERS)
-              I2CPEM.encoders[I2CPEM.idx_from_axis((AxisEnum)i)].set_axis_offset(position_shift[i]);
-            #endif
-
-          #endif
-        }
-      #endif
-    }
-  }
-  if (didXYZ)
-    SYNC_PLAN_POSITION_KINEMATIC();
-  else if (didE)
-    sync_plan_position_e();
-
-  report_current_position();
-}
-
-#if HAS_RESUME_CONTINUE
-
-  /**
-   * M0: Unconditional stop - Wait for user button press on LCD
-   * M1: Conditional stop   - Wait for user button press on LCD
-   */
-  inline void gcode_M0_M1() {
-    const char * const args = parser.string_arg;
-
-    millis_t ms = 0;
-    bool hasP = false, hasS = false;
-    if (parser.seenval('P')) {
-      ms = parser.value_millis(); // milliseconds to wait
-      hasP = ms > 0;
-    }
-    if (parser.seenval('S')) {
-      ms = parser.value_millis_from_seconds(); // seconds to wait
-      hasS = ms > 0;
-    }
-
-    #if ENABLED(ULTIPANEL)
-
-      if (!hasP && !hasS && args && *args)
-        lcd_setstatus(args, true);
-      else {
-        LCD_MESSAGEPGM(MSG_USERWAIT);
-        #if ENABLED(LCD_PROGRESS_BAR) && PROGRESS_MSG_EXPIRE > 0
-          dontExpireStatus();
-        #endif
-      }
-
-    #else
-
-      if (!hasP && !hasS && args && *args) {
-        SERIAL_ECHO_START();
-        SERIAL_ECHOLN(args);
-      }
-
-    #endif
-
-    KEEPALIVE_STATE(PAUSED_FOR_USER);
-    wait_for_user = true;
-
-    stepper.synchronize();
-    refresh_cmd_timeout();
-
-    if (ms > 0) {
-      ms += previous_cmd_ms;  // wait until this time for a click
-      while (PENDING(millis(), ms) && wait_for_user) idle();
-    }
-    else {
-      #if ENABLED(ULTIPANEL)
-        if (lcd_detected()) {
-          while (wait_for_user) idle();
-          IS_SD_PRINTING ? LCD_MESSAGEPGM(MSG_RESUMING) : LCD_MESSAGEPGM(WELCOME_MSG);
-        }
-      #else
-        while (wait_for_user) idle();
-      #endif
-    }
-
-    wait_for_user = false;
-    KEEPALIVE_STATE(IN_HANDLER);
-  }
-
-#endif // HAS_RESUME_CONTINUE
-
-#if ENABLED(SPINDLE_LASER_ENABLE)
-  /**
-   * M3: Spindle Clockwise
-   * M4: Spindle Counter-clockwise
-   *
-   *  S0 turns off spindle.
-   *
-   *  If no speed PWM output is defined then M3/M4 just turns it on.
-   *
-   *  At least 12.8KHz (50Hz * 256) is needed for spindle PWM.
-   *  Hardware PWM is required. ISRs are too slow.
-   *
-   * NOTE: WGM for timers 3, 4, and 5 must be either Mode 1 or Mode 5.
-   *       No other settings give a PWM signal that goes from 0 to 5 volts.
-   *
-   *       The system automatically sets WGM to Mode 1, so no special
-   *       initialization is needed.
-   *
-   *       WGM bits for timer 2 are automatically set by the system to
-   *       Mode 1. This produces an acceptable 0 to 5 volt signal.
-   *       No special initialization is needed.
-   *
-   * NOTE: A minimum PWM frequency of 50 Hz is needed. All prescaler
-   *       factors for timers 2, 3, 4, and 5 are acceptable.
-   *
-   *  SPINDLE_LASER_ENABLE_PIN needs an external pullup or it may power on
-   *  the spindle/laser during power-up or when connecting to the host
-   *  (usually goes through a reset which sets all I/O pins to tri-state)
-   *
-   *  PWM duty cycle goes from 0 (off) to 255 (always on).
-   */
-
-  // Wait for spindle to come up to speed
-  inline void delay_for_power_up() { dwell(SPINDLE_LASER_POWERUP_DELAY); }
-
-  // Wait for spindle to stop turning
-  inline void delay_for_power_down() { dwell(SPINDLE_LASER_POWERDOWN_DELAY); }
-
-  /**
-   * ocr_val_mode() is used for debugging and to get the points needed to compute the RPM vs ocr_val line
-   *
-   * it accepts inputs of 0-255
-   */
-
-  inline void ocr_val_mode() {
-    uint8_t spindle_laser_power = parser.value_byte();
-    WRITE(SPINDLE_LASER_ENABLE_PIN, SPINDLE_LASER_ENABLE_INVERT); // turn spindle on (active low)
-    if (SPINDLE_LASER_PWM_INVERT) spindle_laser_power = 255 - spindle_laser_power;
-    analogWrite(SPINDLE_LASER_PWM_PIN, spindle_laser_power);
-  }
-
-  inline void gcode_M3_M4(bool is_M3) {
-
-    stepper.synchronize();   // wait until previous movement commands (G0/G0/G2/G3) have completed before playing with the spindle
-    #if SPINDLE_DIR_CHANGE
-      const bool rotation_dir = (is_M3 && !SPINDLE_INVERT_DIR || !is_M3 && SPINDLE_INVERT_DIR) ? HIGH : LOW;
-      if (SPINDLE_STOP_ON_DIR_CHANGE \
-         && READ(SPINDLE_LASER_ENABLE_PIN) == SPINDLE_LASER_ENABLE_INVERT \
-         && READ(SPINDLE_DIR_PIN) != rotation_dir
-      ) {
-        WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);  // turn spindle off
-        delay_for_power_down();
-      }
-      WRITE(SPINDLE_DIR_PIN, rotation_dir);
-    #endif
-
-    /**
-     * Our final value for ocr_val is an unsigned 8 bit value between 0 and 255 which usually means uint8_t.
-     * Went to uint16_t because some of the uint8_t calculations would sometimes give 1000 0000 rather than 1111 1111.
-     * Then needed to AND the uint16_t result with 0x00FF to make sure we only wrote the byte of interest.
-     */
-    #if ENABLED(SPINDLE_LASER_PWM)
-      if (parser.seen('O')) ocr_val_mode();
-      else {
-        const float spindle_laser_power = parser.floatval('S');
-        if (spindle_laser_power == 0) {
-          WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);                                    // turn spindle off (active low)
-          delay_for_power_down();
-        }
-        else {
-          int16_t ocr_val = (spindle_laser_power - (SPEED_POWER_INTERCEPT)) * (1.0 / (SPEED_POWER_SLOPE));  // convert RPM to PWM duty cycle
-          NOMORE(ocr_val, 255);                                                                             // limit to max the Atmel PWM will support
-          if (spindle_laser_power <= SPEED_POWER_MIN)
-            ocr_val = (SPEED_POWER_MIN - (SPEED_POWER_INTERCEPT)) * (1.0 / (SPEED_POWER_SLOPE));            // minimum setting
-          if (spindle_laser_power >= SPEED_POWER_MAX)
-            ocr_val = (SPEED_POWER_MAX - (SPEED_POWER_INTERCEPT)) * (1.0 / (SPEED_POWER_SLOPE));            // limit to max RPM
-          if (SPINDLE_LASER_PWM_INVERT) ocr_val = 255 - ocr_val;
-          WRITE(SPINDLE_LASER_ENABLE_PIN, SPINDLE_LASER_ENABLE_INVERT);                                     // turn spindle on (active low)
-          analogWrite(SPINDLE_LASER_PWM_PIN, ocr_val & 0xFF);                                               // only write low byte
-          delay_for_power_up();
-        }
-      }
-    #else
-      WRITE(SPINDLE_LASER_ENABLE_PIN, SPINDLE_LASER_ENABLE_INVERT); // turn spindle on (active low) if spindle speed option not enabled
-      delay_for_power_up();
-    #endif
-  }
-
- /**
-  * M5 turn off spindle
-  */
-  inline void gcode_M5() {
-    stepper.synchronize();
-    WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);
-    delay_for_power_down();
-  }
-
-#endif // SPINDLE_LASER_ENABLE
-
-/**
- * M17: Enable power on all stepper motors
- */
-inline void gcode_M17() {
-  LCD_MESSAGEPGM(MSG_NO_MOVE);
-  enable_all_steppers();
-}
-
-#if IS_KINEMATIC
-  #define RUNPLAN(RATE_MM_S) planner.buffer_line_kinematic(destination, RATE_MM_S, active_extruder)
-#else
-  #define RUNPLAN(RATE_MM_S) line_to_destination(RATE_MM_S)
-#endif
-
-#if ENABLED(ADVANCED_PAUSE_FEATURE)
-
-  static float resume_position[XYZE];
-  static bool move_away_flag = false;
-  #if ENABLED(SDSUPPORT)
-    static bool sd_print_paused = false;
-  #endif
-
-  static void filament_change_beep(const int8_t max_beep_count, const bool init=false) {
-    static millis_t next_buzz = 0;
-    static int8_t runout_beep = 0;
-
-    if (init) next_buzz = runout_beep = 0;
-
-    const millis_t ms = millis();
-    if (ELAPSED(ms, next_buzz)) {
-      if (max_beep_count < 0 || runout_beep < max_beep_count + 5) { // Only beep as long as we're supposed to
-        next_buzz = ms + ((max_beep_count < 0 || runout_beep < max_beep_count) ? 2500 : 400);
-        BUZZ(300, 2000);
-        runout_beep++;
-      }
-    }
-  }
-
-  static void ensure_safe_temperature() {
-    bool heaters_heating = true;
-
-    wait_for_heatup = true;    // M108 will clear this
-    while (wait_for_heatup && heaters_heating) {
-      idle();
-      heaters_heating = false;
-      HOTEND_LOOP() {
-        if (thermalManager.degTargetHotend(e) && abs(thermalManager.degHotend(e) - thermalManager.degTargetHotend(e)) > TEMP_HYSTERESIS) {
-          heaters_heating = true;
-          #if ENABLED(ULTIPANEL)
-            lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_WAIT_FOR_NOZZLES_TO_HEAT);
-          #endif
-          break;
-        }
-      }
-    }
-  }
-
-  static bool pause_print(const float &retract, const float &z_lift, const float &x_pos, const float &y_pos,
-                          const float &unload_length = 0 , const int8_t max_beep_count = 0, const bool show_lcd = false
-  ) {
-    if (move_away_flag) return false; // already paused
-
-    if (!DEBUGGING(DRYRUN) && (unload_length != 0 || retract != 0)) {
-      #if ENABLED(PREVENT_COLD_EXTRUSION)
-        if (!thermalManager.allow_cold_extrude &&
-            thermalManager.degTargetHotend(active_extruder) < thermalManager.extrude_min_temp) {
-          SERIAL_ERROR_START();
-          SERIAL_ERRORLNPGM(MSG_TOO_COLD_FOR_M600);
-          return false;
-        }
-      #endif
-
-      ensure_safe_temperature(); // wait for extruder to heat up before unloading
-    }
-
-    // Indicate that the printer is paused
-    move_away_flag = true;
-
-    // Pause the print job and timer
-    #if ENABLED(SDSUPPORT)
-      if (card.sdprinting) {
-        card.pauseSDPrint();
-        sd_print_paused = true;
-      }
-    #endif
-    print_job_timer.pause();
-
-    // Show initial message and wait for synchronize steppers
-    if (show_lcd) {
-      #if ENABLED(ULTIPANEL)
-        lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INIT);
-      #endif
-    }
-
-    // Save current position
-    stepper.synchronize();
-    COPY(resume_position, current_position);
-
-    if (retract) {
-      // Initial retract before move to filament change position
-      set_destination_to_current();
-      destination[E_AXIS] += retract;
-      RUNPLAN(PAUSE_PARK_RETRACT_FEEDRATE);
-      stepper.synchronize();
-    }
-
-    // Lift Z axis
-    if (z_lift > 0)
-      do_blocking_move_to_z(current_position[Z_AXIS] + z_lift, PAUSE_PARK_Z_FEEDRATE);
-
-    // Move XY axes to filament exchange position
-    do_blocking_move_to_xy(x_pos, y_pos, PAUSE_PARK_XY_FEEDRATE);
-
-    if (unload_length != 0) {
-      if (show_lcd) {
-        #if ENABLED(ULTIPANEL)
-          lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_UNLOAD);
-          idle();
-        #endif
-      }
-
-      // Unload filament
-      set_destination_to_current();
-      destination[E_AXIS] += unload_length;
-      RUNPLAN(FILAMENT_CHANGE_UNLOAD_FEEDRATE);
-      stepper.synchronize();
-    }
-
-    if (show_lcd) {
-      #if ENABLED(ULTIPANEL)
-        lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INSERT);
-      #endif
-    }
-
-    #if HAS_BUZZER
-      filament_change_beep(max_beep_count, true);
-    #endif
-
-    idle();
-
-    // Disable extruders steppers for manual filament changing (only on boards that have separate ENABLE_PINS)
-    #if E0_ENABLE_PIN != X_ENABLE_PIN && E1_ENABLE_PIN != Y_ENABLE_PIN
-      disable_e_steppers();
-      safe_delay(100);
-    #endif
-
-    // Start the heater idle timers
-    const millis_t nozzle_timeout = (millis_t)(PAUSE_PARK_NOZZLE_TIMEOUT) * 1000UL;
-
-    HOTEND_LOOP()
-      thermalManager.start_heater_idle_timer(e, nozzle_timeout);
-
-    return true;
-  }
-
-  static void wait_for_filament_reload(const int8_t max_beep_count = 0) {
-    bool nozzle_timed_out = false;
-
-    // Wait for filament insert by user and press button
-    KEEPALIVE_STATE(PAUSED_FOR_USER);
-    wait_for_user = true;    // LCD click or M108 will clear this
-    while (wait_for_user) {
-      #if HAS_BUZZER
-        filament_change_beep(max_beep_count);
-      #endif
-
-      // If the nozzle has timed out, wait for the user to press the button to re-heat the nozzle, then
-      // re-heat the nozzle, re-show the insert screen, restart the idle timers, and start over
-      if (!nozzle_timed_out)
-        HOTEND_LOOP()
-          nozzle_timed_out |= thermalManager.is_heater_idle(e);
-
-      if (nozzle_timed_out) {
-        #if ENABLED(ULTIPANEL)
-          lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_CLICK_TO_HEAT_NOZZLE);
-        #endif
-
-        // Wait for LCD click or M108
-        while (wait_for_user) idle(true);
-
-        // Re-enable the heaters if they timed out
-        HOTEND_LOOP() thermalManager.reset_heater_idle_timer(e);
-
-        // Wait for the heaters to reach the target temperatures
-        ensure_safe_temperature();
-
-        #if ENABLED(ULTIPANEL)
-          lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INSERT);
-        #endif
-
-        // Start the heater idle timers
-        const millis_t nozzle_timeout = (millis_t)(PAUSE_PARK_NOZZLE_TIMEOUT) * 1000UL;
-
-        HOTEND_LOOP()
-          thermalManager.start_heater_idle_timer(e, nozzle_timeout);
-
-        wait_for_user = true; /* Wait for user to load filament */
-        nozzle_timed_out = false;
-
-        #if HAS_BUZZER
-          filament_change_beep(max_beep_count, true);
-        #endif
-      }
-
-      idle(true);
-    }
-    KEEPALIVE_STATE(IN_HANDLER);
-  }
-
-  static void resume_print(const float &load_length = 0, const float &initial_extrude_length = 0, const int8_t max_beep_count = 0) {
-    bool nozzle_timed_out = false;
-
-    if (!move_away_flag) return;
-
-    // Re-enable the heaters if they timed out
-    HOTEND_LOOP() {
-      nozzle_timed_out |= thermalManager.is_heater_idle(e);
-      thermalManager.reset_heater_idle_timer(e);
-    }
-
-    if (nozzle_timed_out) ensure_safe_temperature();
-
-    #if HAS_BUZZER
-      filament_change_beep(max_beep_count, true);
-    #endif
-
-    if (load_length != 0) {
-      #if ENABLED(ULTIPANEL)
-        // Show "insert filament"
-        if (nozzle_timed_out)
-          lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INSERT);
-      #endif
-
-      KEEPALIVE_STATE(PAUSED_FOR_USER);
-      wait_for_user = true;    // LCD click or M108 will clear this
-      while (wait_for_user && nozzle_timed_out) {
-        #if HAS_BUZZER
-          filament_change_beep(max_beep_count);
-        #endif
-        idle(true);
-      }
-      KEEPALIVE_STATE(IN_HANDLER);
-
-      #if ENABLED(ULTIPANEL)
-        // Show "load" message
-        lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_LOAD);
-      #endif
-
-      // Load filament
-      destination[E_AXIS] += load_length;
-      RUNPLAN(FILAMENT_CHANGE_LOAD_FEEDRATE);
-      stepper.synchronize();
-    }
-
-    #if ENABLED(ULTIPANEL) && ADVANCED_PAUSE_EXTRUDE_LENGTH > 0
-
-      float extrude_length = initial_extrude_length;
-
-      do {
-        if (extrude_length > 0) {
-          // "Wait for filament extrude"
-          lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_EXTRUDE);
-
-          // Extrude filament to get into hotend
-          destination[E_AXIS] += extrude_length;
-          RUNPLAN(ADVANCED_PAUSE_EXTRUDE_FEEDRATE);
-          stepper.synchronize();
-        }
-
-        // Show "Extrude More" / "Resume" menu and wait for reply
-        KEEPALIVE_STATE(PAUSED_FOR_USER);
-        wait_for_user = false;
-        lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_OPTION);
-        while (advanced_pause_menu_response == ADVANCED_PAUSE_RESPONSE_WAIT_FOR) idle(true);
-        KEEPALIVE_STATE(IN_HANDLER);
-
-        extrude_length = ADVANCED_PAUSE_EXTRUDE_LENGTH;
-
-        // Keep looping if "Extrude More" was selected
-      } while (advanced_pause_menu_response == ADVANCED_PAUSE_RESPONSE_EXTRUDE_MORE);
-
-    #endif
-
-    #if ENABLED(ULTIPANEL)
-      // "Wait for print to resume"
-      lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_RESUME);
-    #endif
-
-    // Set extruder to saved position
-    destination[E_AXIS] = current_position[E_AXIS] = resume_position[E_AXIS];
-    planner.set_e_position_mm(current_position[E_AXIS]);
-
-    // Move XY to starting position, then Z
-    do_blocking_move_to_xy(resume_position[X_AXIS], resume_position[Y_AXIS], PAUSE_PARK_XY_FEEDRATE);
-    do_blocking_move_to_z(resume_position[Z_AXIS], PAUSE_PARK_Z_FEEDRATE);
-
-    #if ENABLED(FILAMENT_RUNOUT_SENSOR)
-      filament_ran_out = false;
-    #endif
-
-    #if ENABLED(ULTIPANEL)
-      // Show status screen
-      lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_STATUS);
-    #endif
-
-    #if ENABLED(SDSUPPORT)
-      if (sd_print_paused) {
-        card.startFileprint();
-        sd_print_paused = false;
-      }
-    #endif
-
-    move_away_flag = false;
-  }
-#endif // ADVANCED_PAUSE_FEATURE
-
-#if ENABLED(SDSUPPORT)
-
-  /**
-   * M20: List SD card to serial output
-   */
-  inline void gcode_M20() {
-    SERIAL_PROTOCOLLNPGM(MSG_BEGIN_FILE_LIST);
-    card.ls();
-    SERIAL_PROTOCOLLNPGM(MSG_END_FILE_LIST);
-  }
-
-  /**
-   * M21: Init SD Card
-   */
-  inline void gcode_M21() { card.initsd(); }
-
-  /**
-   * M22: Release SD Card
-   */
-  inline void gcode_M22() { card.release(); }
-
-  /**
-   * M23: Open a file
-   */
-  inline void gcode_M23() {
-    // Simplify3D includes the size, so zero out all spaces (#7227)
-    for (char *fn = parser.string_arg; *fn; ++fn) if (*fn == ' ') *fn = '\0';
-    card.openFile(parser.string_arg, true);
-  }
-
-  /**
-   * M24: Start or Resume SD Print
-   */
-  inline void gcode_M24() {
-    #if ENABLED(PARK_HEAD_ON_PAUSE)
-      resume_print();
-    #endif
-
-    card.startFileprint();
-    print_job_timer.start();
-  }
-
-  /**
-   * M25: Pause SD Print
-   */
-  inline void gcode_M25() {
-    card.pauseSDPrint();
-    print_job_timer.pause();
-
-    #if ENABLED(PARK_HEAD_ON_PAUSE)
-      enqueue_and_echo_commands_P(PSTR("M125")); // Must be enqueued with pauseSDPrint set to be last in the buffer
-    #endif
-  }
-
-  /**
-   * M26: Set SD Card file index
-   */
-  inline void gcode_M26() {
-    if (card.cardOK && parser.seenval('S'))
-      card.setIndex(parser.value_long());
-  }
-
-  /**
-   * M27: Get SD Card status
-   */
-  inline void gcode_M27() { card.getStatus(); }
-
-  /**
-   * M28: Start SD Write
-   */
-  inline void gcode_M28() { card.openFile(parser.string_arg, false); }
-
-  /**
-   * M29: Stop SD Write
-   * Processed in write to file routine above
-   */
-  inline void gcode_M29() {
-    // card.saving = false;
-  }
-
-  /**
-   * M30 <filename>: Delete SD Card file
-   */
-  inline void gcode_M30() {
-    if (card.cardOK) {
-      card.closefile();
-      card.removeFile(parser.string_arg);
-    }
-  }
-
-#endif // SDSUPPORT
-
-/**
- * M31: Get the time since the start of SD Print (or last M109)
- */
-inline void gcode_M31() {
-  char buffer[21];
-  duration_t elapsed = print_job_timer.duration();
-  elapsed.toString(buffer);
-  lcd_setstatus(buffer);
-
-  SERIAL_ECHO_START();
-  SERIAL_ECHOLNPAIR("Print time: ", buffer);
-}
-
-#if ENABLED(SDSUPPORT)
-
-  /**
-   * M32: Select file and start SD Print
-   */
-  inline void gcode_M32() {
-    if (card.sdprinting)
-      stepper.synchronize();
-
-    char* namestartpos = parser.string_arg;
-    const bool call_procedure = parser.boolval('P');
-
-    if (card.cardOK) {
-      card.openFile(namestartpos, true, call_procedure);
-
-      if (parser.seenval('S'))
-        card.setIndex(parser.value_long());
-
-      card.startFileprint();
-
-      // Procedure calls count as normal print time.
-      if (!call_procedure) print_job_timer.start();
-    }
-  }
-
-  #if ENABLED(LONG_FILENAME_HOST_SUPPORT)
-
-    /**
-     * M33: Get the long full path of a file or folder
-     *
-     * Parameters:
-     *   <dospath> Case-insensitive DOS-style path to a file or folder
-     *
-     * Example:
-     *   M33 miscel~1/armchair/armcha~1.gco
-     *
-     * Output:
-     *   /Miscellaneous/Armchair/Armchair.gcode
-     */
-    inline void gcode_M33() {
-      card.printLongPath(parser.string_arg);
-    }
-
-  #endif
-
-  #if ENABLED(SDCARD_SORT_ALPHA) && ENABLED(SDSORT_GCODE)
-    /**
-     * M34: Set SD Card Sorting Options
-     */
-    inline void gcode_M34() {
-      if (parser.seen('S')) card.setSortOn(parser.value_bool());
-      if (parser.seenval('F')) {
-        const int v = parser.value_long();
-        card.setSortFolders(v < 0 ? -1 : v > 0 ? 1 : 0);
-      }
-      //if (parser.seen('R')) card.setSortReverse(parser.value_bool());
-    }
-  #endif // SDCARD_SORT_ALPHA && SDSORT_GCODE
-
-  /**
-   * M928: Start SD Write
-   */
-  inline void gcode_M928() {
-    card.openLogFile(parser.string_arg);
-  }
-
-#endif // SDSUPPORT
-
-/**
- * Sensitive pin test for M42, M226
- */
-static bool pin_is_protected(const int8_t pin) {
-  static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
-  for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
-    if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
-  return false;
-}
-
-/**
- * M42: Change pin status via GCode
- *
- *  P<pin>  Pin number (LED if omitted)
- *  S<byte> Pin status from 0 - 255
- */
-inline void gcode_M42() {
-  if (!parser.seenval('S')) return;
-  const byte pin_status = parser.value_byte();
-
-  const int pin_number = parser.intval('P', LED_PIN);
-  if (pin_number < 0) return;
-
-  if (pin_is_protected(pin_number)) {
-    SERIAL_ERROR_START();
-    SERIAL_ERRORLNPGM(MSG_ERR_PROTECTED_PIN);
-    return;
-  }
-
-  pinMode(pin_number, OUTPUT);
-  digitalWrite(pin_number, pin_status);
-  analogWrite(pin_number, pin_status);
-
-  #if FAN_COUNT > 0
-    switch (pin_number) {
-      #if HAS_FAN0
-        case FAN_PIN: fanSpeeds[0] = pin_status; break;
-      #endif
-      #if HAS_FAN1
-        case FAN1_PIN: fanSpeeds[1] = pin_status; break;
-      #endif
-      #if HAS_FAN2
-        case FAN2_PIN: fanSpeeds[2] = pin_status; break;
-      #endif
-    }
-  #endif
-}
-
-#if ENABLED(PINS_DEBUGGING)
-
-  #include "pinsDebug.h"
-
-  inline void toggle_pins() {
-    const bool I_flag = parser.boolval('I');
-    const int repeat = parser.intval('R', 1),
-              start = parser.intval('S'),
-              end = parser.intval('E', NUM_DIGITAL_PINS - 1),
-              wait = parser.intval('W', 500);
-
-    for (uint8_t pin = start; pin <= end; pin++) {
-      //report_pin_state_extended(pin, I_flag, false);
-      if (!VALID_PIN(pin)) continue;
-      if (!I_flag && pin_is_protected(pin)) {
-        report_pin_state_extended(pin, I_flag, true, "Untouched ");
-        SERIAL_EOL();
-      }
-      else {
-        report_pin_state_extended(pin, I_flag, true, "Pulsing   ");
-        #if AVR_AT90USB1286_FAMILY // Teensy IDEs don't know about these pins so must use FASTIO
-          if (pin == TEENSY_E2) {
-            SET_OUTPUT(TEENSY_E2);
-            for (int16_t j = 0; j < repeat; j++) {
-              WRITE(TEENSY_E2, LOW);  safe_delay(wait);
-              WRITE(TEENSY_E2, HIGH); safe_delay(wait);
-              WRITE(TEENSY_E2, LOW);  safe_delay(wait);
-            }
-          }
-          else if (pin == TEENSY_E3) {
-            SET_OUTPUT(TEENSY_E3);
-            for (int16_t j = 0; j < repeat; j++) {
-              WRITE(TEENSY_E3, LOW);  safe_delay(wait);
-              WRITE(TEENSY_E3, HIGH); safe_delay(wait);
-              WRITE(TEENSY_E3, LOW);  safe_delay(wait);
-            }
-          }
-          else
-        #endif
-        {
-          pinMode(pin, OUTPUT);
-          for (int16_t j = 0; j < repeat; j++) {
-            digitalWrite(pin, 0); safe_delay(wait);
-            digitalWrite(pin, 1); safe_delay(wait);
-            digitalWrite(pin, 0); safe_delay(wait);
-          }
-        }
-
-      }
-      SERIAL_EOL();
-    }
-    SERIAL_ECHOLNPGM("Done.");
-
-  } // toggle_pins
-
-  inline void servo_probe_test() {
-    #if !(NUM_SERVOS > 0 && HAS_SERVO_0)
-
-      SERIAL_ERROR_START();
-      SERIAL_ERRORLNPGM("SERVO not setup");
-
-    #elif !HAS_Z_SERVO_ENDSTOP
-
-      SERIAL_ERROR_START();
-      SERIAL_ERRORLNPGM("Z_ENDSTOP_SERVO_NR not setup");
-
-    #else // HAS_Z_SERVO_ENDSTOP
-
-      const uint8_t probe_index = parser.byteval('P', Z_ENDSTOP_SERVO_NR);
-
-      SERIAL_PROTOCOLLNPGM("Servo probe test");
-      SERIAL_PROTOCOLLNPAIR(".  using index:  ", probe_index);
-      SERIAL_PROTOCOLLNPAIR(".  deploy angle: ", z_servo_angle[0]);
-      SERIAL_PROTOCOLLNPAIR(".  stow angle:   ", z_servo_angle[1]);
-
-      bool probe_inverting;
-
-      #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
-
-        #define PROBE_TEST_PIN Z_MIN_PIN
-
-        SERIAL_PROTOCOLLNPAIR(". probe uses Z_MIN pin: ", PROBE_TEST_PIN);
-        SERIAL_PROTOCOLLNPGM(". uses Z_MIN_ENDSTOP_INVERTING (ignores Z_MIN_PROBE_ENDSTOP_INVERTING)");
-        SERIAL_PROTOCOLPGM(". Z_MIN_ENDSTOP_INVERTING: ");
-
-        #if Z_MIN_ENDSTOP_INVERTING
-          SERIAL_PROTOCOLLNPGM("true");
-        #else
-          SERIAL_PROTOCOLLNPGM("false");
-        #endif
-
-        probe_inverting = Z_MIN_ENDSTOP_INVERTING;
-
-      #elif ENABLED(Z_MIN_PROBE_ENDSTOP)
-
-        #define PROBE_TEST_PIN Z_MIN_PROBE_PIN
-        SERIAL_PROTOCOLLNPAIR(". probe uses Z_MIN_PROBE_PIN: ", PROBE_TEST_PIN);
-        SERIAL_PROTOCOLLNPGM(". uses Z_MIN_PROBE_ENDSTOP_INVERTING (ignores Z_MIN_ENDSTOP_INVERTING)");
-        SERIAL_PROTOCOLPGM(". Z_MIN_PROBE_ENDSTOP_INVERTING: ");
-
-        #if Z_MIN_PROBE_ENDSTOP_INVERTING
-          SERIAL_PROTOCOLLNPGM("true");
-        #else
-          SERIAL_PROTOCOLLNPGM("false");
-        #endif
-
-        probe_inverting = Z_MIN_PROBE_ENDSTOP_INVERTING;
-
-      #endif
-
-      SERIAL_PROTOCOLLNPGM(". deploy & stow 4 times");
-      SET_INPUT_PULLUP(PROBE_TEST_PIN);
-      bool deploy_state, stow_state;
-      for (uint8_t i = 0; i < 4; i++) {
-        MOVE_SERVO(probe_index, z_servo_angle[0]); //deploy
-        safe_delay(500);
-        deploy_state = READ(PROBE_TEST_PIN);
-        MOVE_SERVO(probe_index, z_servo_angle[1]); //stow
-        safe_delay(500);
-        stow_state = READ(PROBE_TEST_PIN);
-      }
-      if (probe_inverting != deploy_state) SERIAL_PROTOCOLLNPGM("WARNING - INVERTING setting probably backwards");
-
-      refresh_cmd_timeout();
-
-      if (deploy_state != stow_state) {
-        SERIAL_PROTOCOLLNPGM("BLTouch clone detected");
-        if (deploy_state) {
-          SERIAL_PROTOCOLLNPGM(".  DEPLOYED state: HIGH (logic 1)");
-          SERIAL_PROTOCOLLNPGM(".  STOWED (triggered) state: LOW (logic 0)");
-        }
-        else {
-          SERIAL_PROTOCOLLNPGM(".  DEPLOYED state: LOW (logic 0)");
-          SERIAL_PROTOCOLLNPGM(".  STOWED (triggered) state: HIGH (logic 1)");
-        }
-        #if ENABLED(BLTOUCH)
-          SERIAL_PROTOCOLLNPGM("ERROR: BLTOUCH enabled - set this device up as a Z Servo Probe with inverting as true.");
-        #endif
-
-      }
-      else {                                           // measure active signal length
-        MOVE_SERVO(probe_index, z_servo_angle[0]);     // deploy
-        safe_delay(500);
-        SERIAL_PROTOCOLLNPGM("please trigger probe");
-        uint16_t probe_counter = 0;
-
-        // Allow 30 seconds max for operator to trigger probe
-        for (uint16_t j = 0; j < 500 * 30 && probe_counter == 0 ; j++) {
-
-          safe_delay(2);
-
-          if (0 == j % (500 * 1)) // keep cmd_timeout happy
-            refresh_cmd_timeout();
-
-          if (deploy_state != READ(PROBE_TEST_PIN)) { // probe triggered
-
-            for (probe_counter = 1; probe_counter < 50 && deploy_state != READ(PROBE_TEST_PIN); ++probe_counter)
-              safe_delay(2);
-
-            if (probe_counter == 50)
-              SERIAL_PROTOCOLLNPGM("Z Servo Probe detected"); // >= 100mS active time
-            else if (probe_counter >= 2)
-              SERIAL_PROTOCOLLNPAIR("BLTouch compatible probe detected - pulse width (+/- 4mS): ", probe_counter * 2); // allow 4 - 100mS pulse
-            else
-              SERIAL_PROTOCOLLNPGM("noise detected - please re-run test"); // less than 2mS pulse
-
-            MOVE_SERVO(probe_index, z_servo_angle[1]); //stow
-
-          }  // pulse detected
-
-        } // for loop waiting for trigger
-
-        if (probe_counter == 0) SERIAL_PROTOCOLLNPGM("trigger not detected");
-
-      } // measure active signal length
-
-    #endif
-
-  } // servo_probe_test
-
-  /**
-   * M43: Pin debug - report pin state, watch pins, toggle pins and servo probe test/report
-   *
-   *  M43         - report name and state of pin(s)
-   *                  P<pin>  Pin to read or watch. If omitted, reads all pins.
-   *                  I       Flag to ignore Marlin's pin protection.
-   *
-   *  M43 W       - Watch pins -reporting changes- until reset, click, or M108.
-   *                  P<pin>  Pin to read or watch. If omitted, read/watch all pins.
-   *                  I       Flag to ignore Marlin's pin protection.
-   *
-   *  M43 E<bool> - Enable / disable background endstop monitoring
-   *                  - Machine continues to operate
-   *                  - Reports changes to endstops
-   *                  - Toggles LED_PIN when an endstop changes
-   *                  - Can not reliably catch the 5mS pulse from BLTouch type probes
-   *
-   *  M43 T       - Toggle pin(s) and report which pin is being toggled
-   *                  S<pin>  - Start Pin number.   If not given, will default to 0
-   *                  L<pin>  - End Pin number.   If not given, will default to last pin defined for this board
-   *                  I<bool> - Flag to ignore Marlin's pin protection.   Use with caution!!!!
-   *                  R       - Repeat pulses on each pin this number of times before continueing to next pin
-   *                  W       - Wait time (in miliseconds) between pulses.  If not given will default to 500
-   *
-   *  M43 S       - Servo probe test
-   *                  P<index> - Probe index (optional - defaults to 0
-   */
-  inline void gcode_M43() {
-
-    if (parser.seen('T')) {   // must be first or else its "S" and "E" parameters will execute endstop or servo test
-      toggle_pins();
-      return;
-    }
-
-    // Enable or disable endstop monitoring
-    if (parser.seen('E')) {
-      endstop_monitor_flag = parser.value_bool();
-      SERIAL_PROTOCOLPGM("endstop monitor ");
-      serialprintPGM(endstop_monitor_flag ? PSTR("en") : PSTR("dis"));
-      SERIAL_PROTOCOLLNPGM("abled");
-      return;
-    }
-
-    if (parser.seen('S')) {
-      servo_probe_test();
-      return;
-    }
-
-    // Get the range of pins to test or watch
-    const uint8_t first_pin = parser.byteval('P'),
-                  last_pin = parser.seenval('P') ? first_pin : NUM_DIGITAL_PINS - 1;
-
-    if (first_pin > last_pin) return;
-
-    const bool ignore_protection = parser.boolval('I');
-
-    // Watch until click, M108, or reset
-    if (parser.boolval('W')) {
-      SERIAL_PROTOCOLLNPGM("Watching pins");
-      uint8_t pin_state[last_pin - first_pin + 1];
-      for (int8_t pin = first_pin; pin <= last_pin; pin++) {
-        if (!VALID_PIN(pin)) continue;
-        if (pin_is_protected(pin) && !ignore_protection) continue;
-        pinMode(pin, INPUT_PULLUP);
-        delay(1);
-        /*
-          if (IS_ANALOG(pin))
-            pin_state[pin - first_pin] = analogRead(DIGITAL_PIN_TO_ANALOG_PIN(pin)); // int16_t pin_state[...]
-          else
-        //*/
-            pin_state[pin - first_pin] = digitalRead(pin);
-      }
-
-      #if HAS_RESUME_CONTINUE
-        wait_for_user = true;
-        KEEPALIVE_STATE(PAUSED_FOR_USER);
-      #endif
-
-      for (;;) {
-        for (int8_t pin = first_pin; pin <= last_pin; pin++) {
-          if (!VALID_PIN(pin)) continue;
-          if (pin_is_protected(pin) && !ignore_protection) continue;
-          const byte val =
-            /*
-              IS_ANALOG(pin)
-                ? analogRead(DIGITAL_PIN_TO_ANALOG_PIN(pin)) : // int16_t val
-                :
-            //*/
-              digitalRead(pin);
-          if (val != pin_state[pin - first_pin]) {
-            report_pin_state_extended(pin, ignore_protection, false);
-            pin_state[pin - first_pin] = val;
-          }
-        }
-
-        #if HAS_RESUME_CONTINUE
-          if (!wait_for_user) {
-            KEEPALIVE_STATE(IN_HANDLER);
-            break;
-          }
-        #endif
-
-        safe_delay(200);
-      }
-      return;
-    }
-
-    // Report current state of selected pin(s)
-    for (uint8_t pin = first_pin; pin <= last_pin; pin++)
-      if (VALID_PIN(pin)) report_pin_state_extended(pin, ignore_protection, true);
-  }
-
-#endif // PINS_DEBUGGING
-
-#if ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)
-
-  /**
-   * M48: Z probe repeatability measurement function.
-   *
-   * Usage:
-   *   M48 <P#> <X#> <Y#> <V#> <E> <L#>
-   *     P = Number of sampled points (4-50, default 10)
-   *     X = Sample X position
-   *     Y = Sample Y position
-   *     V = Verbose level (0-4, default=1)
-   *     E = Engage Z probe for each reading
-   *     L = Number of legs of movement before probe
-   *     S = Schizoid (Or Star if you prefer)
-   *
-   * This function assumes the bed has been homed.  Specifically, that a G28 command
-   * as been issued prior to invoking the M48 Z probe repeatability measurement function.
-   * Any information generated by a prior G29 Bed leveling command will be lost and need to be
-   * regenerated.
-   */
-  inline void gcode_M48() {
-
-    if (axis_unhomed_error()) return;
-
-    const int8_t verbose_level = parser.byteval('V', 1);
-    if (!WITHIN(verbose_level, 0, 4)) {
-      SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-4).");
-      return;
-    }
-
-    if (verbose_level > 0)
-      SERIAL_PROTOCOLLNPGM("M48 Z-Probe Repeatability Test");
-
-    const int8_t n_samples = parser.byteval('P', 10);
-    if (!WITHIN(n_samples, 4, 50)) {
-      SERIAL_PROTOCOLLNPGM("?Sample size not plausible (4-50).");
-      return;
-    }
-
-    const bool stow_probe_after_each = parser.boolval('E');
-
-    float X_current = current_position[X_AXIS],
-          Y_current = current_position[Y_AXIS];
-
-    const float X_probe_location = parser.linearval('X', X_current + X_PROBE_OFFSET_FROM_EXTRUDER),
-                Y_probe_location = parser.linearval('Y', Y_current + Y_PROBE_OFFSET_FROM_EXTRUDER);
-
-    #if DISABLED(DELTA)
-      if (!WITHIN(X_probe_location, LOGICAL_X_POSITION(MIN_PROBE_X), LOGICAL_X_POSITION(MAX_PROBE_X))) {
-        out_of_range_error(PSTR("X"));
-        return;
-      }
-      if (!WITHIN(Y_probe_location, LOGICAL_Y_POSITION(MIN_PROBE_Y), LOGICAL_Y_POSITION(MAX_PROBE_Y))) {
-        out_of_range_error(PSTR("Y"));
-        return;
-      }
-    #else
-      if (!position_is_reachable_by_probe_xy(X_probe_location, Y_probe_location)) {
-        SERIAL_PROTOCOLLNPGM("? (X,Y) location outside of probeable radius.");
-        return;
-      }
-    #endif
-
-    bool seen_L = parser.seen('L');
-    uint8_t n_legs = seen_L ? parser.value_byte() : 0;
-    if (n_legs > 15) {
-      SERIAL_PROTOCOLLNPGM("?Number of legs in movement not plausible (0-15).");
-      return;
-    }
-    if (n_legs == 1) n_legs = 2;
-
-    const bool schizoid_flag = parser.boolval('S');
-    if (schizoid_flag && !seen_L) n_legs = 7;
-
-    /**
-     * Now get everything to the specified probe point So we can safely do a
-     * probe to get us close to the bed.  If the Z-Axis is far from the bed,
-     * we don't want to use that as a starting point for each probe.
-     */
-    if (verbose_level > 2)
-      SERIAL_PROTOCOLLNPGM("Positioning the probe...");
-
-    // Disable bed level correction in M48 because we want the raw data when we probe
-
-    #if HAS_LEVELING
-      const bool was_enabled = leveling_is_active();
-      set_bed_leveling_enabled(false);
-    #endif
-
-    setup_for_endstop_or_probe_move();
-
-    double mean = 0.0, sigma = 0.0, min = 99999.9, max = -99999.9, sample_set[n_samples];
-
-    // Move to the first point, deploy, and probe
-    const float t = probe_pt(X_probe_location, Y_probe_location, stow_probe_after_each, verbose_level);
-    bool probing_good = !isnan(t);
-
-    if (probing_good) {
-      randomSeed(millis());
-
-      for (uint8_t n = 0; n < n_samples; n++) {
-        if (n_legs) {
-          const int dir = (random(0, 10) > 5.0) ? -1 : 1;  // clockwise or counter clockwise
-          float angle = random(0.0, 360.0);
-          const float radius = random(
-            #if ENABLED(DELTA)
-              0.1250000000 * (DELTA_PROBEABLE_RADIUS),
-              0.3333333333 * (DELTA_PROBEABLE_RADIUS)
-            #else
-              5.0, 0.125 * min(X_BED_SIZE, Y_BED_SIZE)
-            #endif
-          );
-
-          if (verbose_level > 3) {
-            SERIAL_ECHOPAIR("Starting radius: ", radius);
-            SERIAL_ECHOPAIR("   angle: ", angle);
-            SERIAL_ECHOPGM(" Direction: ");
-            if (dir > 0) SERIAL_ECHOPGM("Counter-");
-            SERIAL_ECHOLNPGM("Clockwise");
-          }
-
-          for (uint8_t l = 0; l < n_legs - 1; l++) {
-            double delta_angle;
-
-            if (schizoid_flag)
-              // The points of a 5 point star are 72 degrees apart.  We need to
-              // skip a point and go to the next one on the star.
-              delta_angle = dir * 2.0 * 72.0;
-
-            else
-              // If we do this line, we are just trying to move further
-              // around the circle.
-              delta_angle = dir * (float) random(25, 45);
-
-            angle += delta_angle;
-
-            while (angle > 360.0)   // We probably do not need to keep the angle between 0 and 2*PI, but the
-              angle -= 360.0;       // Arduino documentation says the trig functions should not be given values
-            while (angle < 0.0)     // outside of this range.   It looks like they behave correctly with
-              angle += 360.0;       // numbers outside of the range, but just to be safe we clamp them.
-
-            X_current = X_probe_location - (X_PROBE_OFFSET_FROM_EXTRUDER) + cos(RADIANS(angle)) * radius;
-            Y_current = Y_probe_location - (Y_PROBE_OFFSET_FROM_EXTRUDER) + sin(RADIANS(angle)) * radius;
-
-            #if DISABLED(DELTA)
-              X_current = constrain(X_current, X_MIN_POS, X_MAX_POS);
-              Y_current = constrain(Y_current, Y_MIN_POS, Y_MAX_POS);
-            #else
-              // If we have gone out too far, we can do a simple fix and scale the numbers
-              // back in closer to the origin.
-              while (!position_is_reachable_by_probe_xy(X_current, Y_current)) {
-                X_current *= 0.8;
-                Y_current *= 0.8;
-                if (verbose_level > 3) {
-                  SERIAL_ECHOPAIR("Pulling point towards center:", X_current);
-                  SERIAL_ECHOLNPAIR(", ", Y_current);
-                }
-              }
-            #endif
-            if (verbose_level > 3) {
-              SERIAL_PROTOCOLPGM("Going to:");
-              SERIAL_ECHOPAIR(" X", X_current);
-              SERIAL_ECHOPAIR(" Y", Y_current);
-              SERIAL_ECHOLNPAIR(" Z", current_position[Z_AXIS]);
-            }
-            do_blocking_move_to_xy(X_current, Y_current);
-          } // n_legs loop
-        } // n_legs
-
-        // Probe a single point
-        sample_set[n] = probe_pt(X_probe_location, Y_probe_location, stow_probe_after_each, 0);
-
-        // Break the loop if the probe fails
-        probing_good = !isnan(sample_set[n]);
-        if (!probing_good) break;
-
-        /**
-         * Get the current mean for the data points we have so far
-         */
-        double sum = 0.0;
-        for (uint8_t j = 0; j <= n; j++) sum += sample_set[j];
-        mean = sum / (n + 1);
-
-        NOMORE(min, sample_set[n]);
-        NOLESS(max, sample_set[n]);
-
-        /**
-         * Now, use that mean to calculate the standard deviation for the
-         * data points we have so far
-         */
-        sum = 0.0;
-        for (uint8_t j = 0; j <= n; j++)
-          sum += sq(sample_set[j] - mean);
-
-        sigma = SQRT(sum / (n + 1));
-        if (verbose_level > 0) {
-          if (verbose_level > 1) {
-            SERIAL_PROTOCOL(n + 1);
-            SERIAL_PROTOCOLPGM(" of ");
-            SERIAL_PROTOCOL((int)n_samples);
-            SERIAL_PROTOCOLPGM(": z: ");
-            SERIAL_PROTOCOL_F(sample_set[n], 3);
-            if (verbose_level > 2) {
-              SERIAL_PROTOCOLPGM(" mean: ");
-              SERIAL_PROTOCOL_F(mean, 4);
-              SERIAL_PROTOCOLPGM(" sigma: ");
-              SERIAL_PROTOCOL_F(sigma, 6);
-              SERIAL_PROTOCOLPGM(" min: ");
-              SERIAL_PROTOCOL_F(min, 3);
-              SERIAL_PROTOCOLPGM(" max: ");
-              SERIAL_PROTOCOL_F(max, 3);
-              SERIAL_PROTOCOLPGM(" range: ");
-              SERIAL_PROTOCOL_F(max-min, 3);
-            }
-            SERIAL_EOL();
-          }
-        }
-
-      } // n_samples loop
-    }
-
-    STOW_PROBE();
-
-    if (probing_good) {
-      SERIAL_PROTOCOLLNPGM("Finished!");
-
-      if (verbose_level > 0) {
-        SERIAL_PROTOCOLPGM("Mean: ");
-        SERIAL_PROTOCOL_F(mean, 6);
-        SERIAL_PROTOCOLPGM(" Min: ");
-        SERIAL_PROTOCOL_F(min, 3);
-        SERIAL_PROTOCOLPGM(" Max: ");
-        SERIAL_PROTOCOL_F(max, 3);
-        SERIAL_PROTOCOLPGM(" Range: ");
-        SERIAL_PROTOCOL_F(max-min, 3);
-        SERIAL_EOL();
-      }
-
-      SERIAL_PROTOCOLPGM("Standard Deviation: ");
-      SERIAL_PROTOCOL_F(sigma, 6);
-      SERIAL_EOL();
-      SERIAL_EOL();
-    }
-
-    clean_up_after_endstop_or_probe_move();
-
-    // Re-enable bed level correction if it had been on
-    #if HAS_LEVELING
-      set_bed_leveling_enabled(was_enabled);
-    #endif
-
-    report_current_position();
-  }
-
-#endif // Z_MIN_PROBE_REPEATABILITY_TEST
-
-#if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(UBL_G26_MESH_VALIDATION)
-
-  inline void gcode_M49() {
-    ubl.g26_debug_flag ^= true;
-    SERIAL_PROTOCOLPGM("UBL Debug Flag turned ");
-    serialprintPGM(ubl.g26_debug_flag ? PSTR("on.") : PSTR("off."));
-  }
-
-#endif // AUTO_BED_LEVELING_UBL && UBL_G26_MESH_VALIDATION
-
-/**
- * M75: Start print timer
- */
-inline void gcode_M75() { print_job_timer.start(); }
-
-/**
- * M76: Pause print timer
- */
-inline void gcode_M76() { print_job_timer.pause(); }
-
-/**
- * M77: Stop print timer
- */
-inline void gcode_M77() { print_job_timer.stop(); }
-
-#if ENABLED(PRINTCOUNTER)
-  /**
-   * M78: Show print statistics
-   */
-  inline void gcode_M78() {
-    // "M78 S78" will reset the statistics
-    if (parser.intval('S') == 78)
-      print_job_timer.initStats();
-    else
-      print_job_timer.showStats();
-  }
-#endif
-
-/**
- * M104: Set hot end temperature
- */
-inline void gcode_M104() {
-  if (get_target_extruder_from_command(104)) return;
-  if (DEBUGGING(DRYRUN)) return;
-
-  #if ENABLED(SINGLENOZZLE)
-    if (target_extruder != active_extruder) return;
-  #endif
-
-  if (parser.seenval('S')) {
-    const int16_t temp = parser.value_celsius();
-    thermalManager.setTargetHotend(temp, target_extruder);
-
-    #if ENABLED(DUAL_X_CARRIAGE)
-      if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && target_extruder == 0)
-        thermalManager.setTargetHotend(temp ? temp + duplicate_extruder_temp_offset : 0, 1);
-    #endif
-
-    #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
-      /**
-       * Stop the timer at the end of print. Start is managed by 'heat and wait' M109.
-       * We use half EXTRUDE_MINTEMP here to allow nozzles to be put into hot
-       * standby mode, for instance in a dual extruder setup, without affecting
-       * the running print timer.
-       */
-      if (parser.value_celsius() <= (EXTRUDE_MINTEMP) / 2) {
-        print_job_timer.stop();
-        LCD_MESSAGEPGM(WELCOME_MSG);
-      }
-    #endif
-
-    if (parser.value_celsius() > thermalManager.degHotend(target_extruder))
-      lcd_status_printf_P(0, PSTR("E%i %s"), target_extruder + 1, MSG_HEATING);
-  }
-
-  #if ENABLED(AUTOTEMP)
-    planner.autotemp_M104_M109();
-  #endif
-}
-
-#if HAS_TEMP_HOTEND || HAS_TEMP_BED
-
-  void print_heater_state(const float &c, const float &t,
-    #if ENABLED(SHOW_TEMP_ADC_VALUES)
-      const float r,
-    #endif
-    const int8_t e=-2
-  ) {
-    #if !(HAS_TEMP_BED && HAS_TEMP_HOTEND) && HOTENDS <= 1
-      UNUSED(e);
-    #endif
-
-    SERIAL_PROTOCOLCHAR(' ');
-    SERIAL_PROTOCOLCHAR(
-      #if HAS_TEMP_BED && HAS_TEMP_HOTEND
-        e == -1 ? 'B' : 'T'
-      #elif HAS_TEMP_HOTEND
-        'T'
-      #else
-        'B'
-      #endif
-    );
-    #if HOTENDS > 1
-      if (e >= 0) SERIAL_PROTOCOLCHAR('0' + e);
-    #endif
-    SERIAL_PROTOCOLCHAR(':');
-    SERIAL_PROTOCOL(c);
-    SERIAL_PROTOCOLPAIR(" /" , t);
-    #if ENABLED(SHOW_TEMP_ADC_VALUES)
-      SERIAL_PROTOCOLPAIR(" (", r / OVERSAMPLENR);
-      SERIAL_PROTOCOLCHAR(')');
-    #endif
-  }
-
-  void print_heaterstates() {
-    #if HAS_TEMP_HOTEND
-      print_heater_state(thermalManager.degHotend(target_extruder), thermalManager.degTargetHotend(target_extruder)
-        #if ENABLED(SHOW_TEMP_ADC_VALUES)
-          , thermalManager.rawHotendTemp(target_extruder)
-        #endif
-      );
-    #endif
-    #if HAS_TEMP_BED
-      print_heater_state(thermalManager.degBed(), thermalManager.degTargetBed(),
-        #if ENABLED(SHOW_TEMP_ADC_VALUES)
-          thermalManager.rawBedTemp(),
-        #endif
-        -1 // BED
-      );
-    #endif
-    #if HOTENDS > 1
-      HOTEND_LOOP() print_heater_state(thermalManager.degHotend(e), thermalManager.degTargetHotend(e),
-        #if ENABLED(SHOW_TEMP_ADC_VALUES)
-          thermalManager.rawHotendTemp(e),
-        #endif
-        e
-      );
-    #endif
-    SERIAL_PROTOCOLPGM(" @:");
-    SERIAL_PROTOCOL(thermalManager.getHeaterPower(target_extruder));
-    #if HAS_TEMP_BED
-      SERIAL_PROTOCOLPGM(" B@:");
-      SERIAL_PROTOCOL(thermalManager.getHeaterPower(-1));
-    #endif
-    #if HOTENDS > 1
-      HOTEND_LOOP() {
-        SERIAL_PROTOCOLPAIR(" @", e);
-        SERIAL_PROTOCOLCHAR(':');
-        SERIAL_PROTOCOL(thermalManager.getHeaterPower(e));
-      }
-    #endif
-  }
-#endif
-
-/**
- * M105: Read hot end and bed temperature
- */
-inline void gcode_M105() {
-  if (get_target_extruder_from_command(105)) return;
-
-  #if HAS_TEMP_HOTEND || HAS_TEMP_BED
-    SERIAL_PROTOCOLPGM(MSG_OK);
-    print_heaterstates();
-  #else // !HAS_TEMP_HOTEND && !HAS_TEMP_BED
-    SERIAL_ERROR_START();
-    SERIAL_ERRORLNPGM(MSG_ERR_NO_THERMISTORS);
-  #endif
-
-  SERIAL_EOL();
-}
-
-#if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND || HAS_TEMP_BED)
-
-  static uint8_t auto_report_temp_interval;
-  static millis_t next_temp_report_ms;
-
-  /**
-   * M155: Set temperature auto-report interval. M155 S<seconds>
-   */
-  inline void gcode_M155() {
-    if (parser.seenval('S')) {
-      auto_report_temp_interval = parser.value_byte();
-      NOMORE(auto_report_temp_interval, 60);
-      next_temp_report_ms = millis() + 1000UL * auto_report_temp_interval;
-    }
-  }
-
-  inline void auto_report_temperatures() {
-    if (auto_report_temp_interval && ELAPSED(millis(), next_temp_report_ms)) {
-      next_temp_report_ms = millis() + 1000UL * auto_report_temp_interval;
-      print_heaterstates();
-      SERIAL_EOL();
-    }
-  }
-
-#endif // AUTO_REPORT_TEMPERATURES
-
-#if FAN_COUNT > 0
-
-  /**
-   * M106: Set Fan Speed
-   *
-   *  S<int>   Speed between 0-255
-   *  P<index> Fan index, if more than one fan
-   */
-  inline void gcode_M106() {
-    uint16_t s = parser.ushortval('S', 255);
-    NOMORE(s, 255);
-    const uint8_t p = parser.byteval('P', 0);
-    if (p < FAN_COUNT) fanSpeeds[p] = s;
-  }
-
-  /**
-   * M107: Fan Off
-   */
-  inline void gcode_M107() {
-    const uint16_t p = parser.ushortval('P');
-    if (p < FAN_COUNT) fanSpeeds[p] = 0;
-  }
-
-#endif // FAN_COUNT > 0
-
-#if DISABLED(EMERGENCY_PARSER)
-
-  /**
-   * M108: Stop the waiting for heaters in M109, M190, M303. Does not affect the target temperature.
-   */
-  inline void gcode_M108() { wait_for_heatup = false; }
-
-
-  /**
-   * M112: Emergency Stop
-   */
-  inline void gcode_M112() { kill(PSTR(MSG_KILLED)); }
-
-
-  /**
-   * M410: Quickstop - Abort all planned moves
-   *
-   * This will stop the carriages mid-move, so most likely they
-   * will be out of sync with the stepper position after this.
-   */
-  inline void gcode_M410() { quickstop_stepper(); }
-
-#endif
-
-/**
- * M109: Sxxx Wait for extruder(s) to reach temperature. Waits only when heating.
- *       Rxxx Wait for extruder(s) to reach temperature. Waits when heating and cooling.
- */
-
-#ifndef MIN_COOLING_SLOPE_DEG
-  #define MIN_COOLING_SLOPE_DEG 1.50
-#endif
-#ifndef MIN_COOLING_SLOPE_TIME
-  #define MIN_COOLING_SLOPE_TIME 60
-#endif
-
-inline void gcode_M109() {
-
-  if (get_target_extruder_from_command(109)) return;
-  if (DEBUGGING(DRYRUN)) return;
-
-  #if ENABLED(SINGLENOZZLE)
-    if (target_extruder != active_extruder) return;
-  #endif
-
-  const bool no_wait_for_cooling = parser.seenval('S');
-  if (no_wait_for_cooling || parser.seenval('R')) {
-    const int16_t temp = parser.value_celsius();
-    thermalManager.setTargetHotend(temp, target_extruder);
-
-    #if ENABLED(DUAL_X_CARRIAGE)
-      if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && target_extruder == 0)
-        thermalManager.setTargetHotend(temp ? temp + duplicate_extruder_temp_offset : 0, 1);
-    #endif
-
-    #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
-      /**
-       * Use half EXTRUDE_MINTEMP to allow nozzles to be put into hot
-       * standby mode, (e.g., in a dual extruder setup) without affecting
-       * the running print timer.
-       */
-      if (parser.value_celsius() <= (EXTRUDE_MINTEMP) / 2) {
-        print_job_timer.stop();
-        LCD_MESSAGEPGM(WELCOME_MSG);
-      }
-      else
-        print_job_timer.start();
-    #endif
-
-    if (thermalManager.isHeatingHotend(target_extruder)) lcd_status_printf_P(0, PSTR("E%i %s"), target_extruder + 1, MSG_HEATING);
-  }
-  else return;
-
-  #if ENABLED(AUTOTEMP)
-    planner.autotemp_M104_M109();
-  #endif
-
-  #if TEMP_RESIDENCY_TIME > 0
-    millis_t residency_start_ms = 0;
-    // Loop until the temperature has stabilized
-    #define TEMP_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + (TEMP_RESIDENCY_TIME) * 1000UL))
-  #else
-    // Loop until the temperature is very close target
-    #define TEMP_CONDITIONS (wants_to_cool ? thermalManager.isCoolingHotend(target_extruder) : thermalManager.isHeatingHotend(target_extruder))
-  #endif
-
-  float target_temp = -1.0, old_temp = 9999.0;
-  bool wants_to_cool = false;
-  wait_for_heatup = true;
-  millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
-
-  #if DISABLED(BUSY_WHILE_HEATING)
-    KEEPALIVE_STATE(NOT_BUSY);
-  #endif
-
-  #if ENABLED(PRINTER_EVENT_LEDS)
-    const float start_temp = thermalManager.degHotend(target_extruder);
-    uint8_t old_blue = 0;
-  #endif
-
-  do {
-    // Target temperature might be changed during the loop
-    if (target_temp != thermalManager.degTargetHotend(target_extruder)) {
-      wants_to_cool = thermalManager.isCoolingHotend(target_extruder);
-      target_temp = thermalManager.degTargetHotend(target_extruder);
-
-      // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
-      if (no_wait_for_cooling && wants_to_cool) break;
-    }
-
-    now = millis();
-    if (ELAPSED(now, next_temp_ms)) { //Print temp & remaining time every 1s while waiting
-      next_temp_ms = now + 1000UL;
-      print_heaterstates();
-      #if TEMP_RESIDENCY_TIME > 0
-        SERIAL_PROTOCOLPGM(" W:");
-        if (residency_start_ms)
-          SERIAL_PROTOCOL(long((((TEMP_RESIDENCY_TIME) * 1000UL) - (now - residency_start_ms)) / 1000UL));
-        else
-          SERIAL_PROTOCOLCHAR('?');
-      #endif
-      SERIAL_EOL();
-    }
-
-    idle();
-    refresh_cmd_timeout(); // to prevent stepper_inactive_time from running out
-
-    const float temp = thermalManager.degHotend(target_extruder);
-
-    #if ENABLED(PRINTER_EVENT_LEDS)
-      // Gradually change LED strip from violet to red as nozzle heats up
-      if (!wants_to_cool) {
-        const uint8_t blue = map(constrain(temp, start_temp, target_temp), start_temp, target_temp, 255, 0);
-        if (blue != old_blue) {
-          old_blue = blue;
-          set_led_color(255, 0, blue
-            #if ENABLED(NEOPIXEL_RGBW_LED)
-              , 0, true
-            #endif
-          );
-        }
-      }
-    #endif
-
-    #if TEMP_RESIDENCY_TIME > 0
-
-      const float temp_diff = FABS(target_temp - temp);
-
-      if (!residency_start_ms) {
-        // Start the TEMP_RESIDENCY_TIME timer when we reach target temp for the first time.
-        if (temp_diff < TEMP_WINDOW) residency_start_ms = now;
-      }
-      else if (temp_diff > TEMP_HYSTERESIS) {
-        // Restart the timer whenever the temperature falls outside the hysteresis.
-        residency_start_ms = now;
-      }
-
-    #endif
-
-    // Prevent a wait-forever situation if R is misused i.e. M109 R0
-    if (wants_to_cool) {
-      // break after MIN_COOLING_SLOPE_TIME seconds
-      // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG
-      if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
-        if (old_temp - temp < MIN_COOLING_SLOPE_DEG) break;
-        next_cool_check_ms = now + 1000UL * MIN_COOLING_SLOPE_TIME;
-        old_temp = temp;
-      }
-    }
-
-  } while (wait_for_heatup && TEMP_CONDITIONS);
-
-  if (wait_for_heatup) {
-    LCD_MESSAGEPGM(MSG_HEATING_COMPLETE);
-    #if ENABLED(PRINTER_EVENT_LEDS)
-      #if ENABLED(RGBW_LED) || ENABLED(NEOPIXEL_RGBW_LED)
-        set_led_color(0, 0, 0, 255);  // Turn on the WHITE LED
-      #else
-        set_led_color(255, 255, 255); // Set LEDs All On
-      #endif
-    #endif
-  }
-
-  #if DISABLED(BUSY_WHILE_HEATING)
-    KEEPALIVE_STATE(IN_HANDLER);
-  #endif
-}
-
-#if HAS_TEMP_BED
-
-  #ifndef MIN_COOLING_SLOPE_DEG_BED
-    #define MIN_COOLING_SLOPE_DEG_BED 1.50
-  #endif
-  #ifndef MIN_COOLING_SLOPE_TIME_BED
-    #define MIN_COOLING_SLOPE_TIME_BED 60
-  #endif
-
-  /**
-   * M190: Sxxx Wait for bed current temp to reach target temp. Waits only when heating
-   *       Rxxx Wait for bed current temp to reach target temp. Waits when heating and cooling
-   */
-  inline void gcode_M190() {
-    if (DEBUGGING(DRYRUN)) return;
-
-    LCD_MESSAGEPGM(MSG_BED_HEATING);
-    const bool no_wait_for_cooling = parser.seenval('S');
-    if (no_wait_for_cooling || parser.seenval('R')) {
-      thermalManager.setTargetBed(parser.value_celsius());
-      #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
-        if (parser.value_celsius() > BED_MINTEMP)
-          print_job_timer.start();
-      #endif
-    }
-    else return;
-
-    #if TEMP_BED_RESIDENCY_TIME > 0
-      millis_t residency_start_ms = 0;
-      // Loop until the temperature has stabilized
-      #define TEMP_BED_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + (TEMP_BED_RESIDENCY_TIME) * 1000UL))
-    #else
-      // Loop until the temperature is very close target
-      #define TEMP_BED_CONDITIONS (wants_to_cool ? thermalManager.isCoolingBed() : thermalManager.isHeatingBed())
-    #endif
-
-    float target_temp = -1.0, old_temp = 9999.0;
-    bool wants_to_cool = false;
-    wait_for_heatup = true;
-    millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
-
-    #if DISABLED(BUSY_WHILE_HEATING)
-      KEEPALIVE_STATE(NOT_BUSY);
-    #endif
-
-    target_extruder = active_extruder; // for print_heaterstates
-
-    #if ENABLED(PRINTER_EVENT_LEDS)
-      const float start_temp = thermalManager.degBed();
-      uint8_t old_red = 255;
-    #endif
-
-    do {
-      // Target temperature might be changed during the loop
-      if (target_temp != thermalManager.degTargetBed()) {
-        wants_to_cool = thermalManager.isCoolingBed();
-        target_temp = thermalManager.degTargetBed();
-
-        // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
-        if (no_wait_for_cooling && wants_to_cool) break;
-      }
-
-      now = millis();
-      if (ELAPSED(now, next_temp_ms)) { //Print Temp Reading every 1 second while heating up.
-        next_temp_ms = now + 1000UL;
-        print_heaterstates();
-        #if TEMP_BED_RESIDENCY_TIME > 0
-          SERIAL_PROTOCOLPGM(" W:");
-          if (residency_start_ms)
-            SERIAL_PROTOCOL(long((((TEMP_BED_RESIDENCY_TIME) * 1000UL) - (now - residency_start_ms)) / 1000UL));
-          else
-            SERIAL_PROTOCOLCHAR('?');
-        #endif
-        SERIAL_EOL();
-      }
-
-      idle();
-      refresh_cmd_timeout(); // to prevent stepper_inactive_time from running out
-
-      const float temp = thermalManager.degBed();
-
-      #if ENABLED(PRINTER_EVENT_LEDS)
-        // Gradually change LED strip from blue to violet as bed heats up
-        if (!wants_to_cool) {
-          const uint8_t red = map(constrain(temp, start_temp, target_temp), start_temp, target_temp, 0, 255);
-          if (red != old_red) {
-            old_red = red;
-            set_led_color(red, 0, 255
-              #if ENABLED(NEOPIXEL_RGBW_LED)
-                , 0, true
-              #endif
-            );
-          }
-        }
-      #endif
-
-      #if TEMP_BED_RESIDENCY_TIME > 0
-
-        const float temp_diff = FABS(target_temp - temp);
-
-        if (!residency_start_ms) {
-          // Start the TEMP_BED_RESIDENCY_TIME timer when we reach target temp for the first time.
-          if (temp_diff < TEMP_BED_WINDOW) residency_start_ms = now;
-        }
-        else if (temp_diff > TEMP_BED_HYSTERESIS) {
-          // Restart the timer whenever the temperature falls outside the hysteresis.
-          residency_start_ms = now;
-        }
-
-      #endif // TEMP_BED_RESIDENCY_TIME > 0
-
-      // Prevent a wait-forever situation if R is misused i.e. M190 R0
-      if (wants_to_cool) {
-        // Break after MIN_COOLING_SLOPE_TIME_BED seconds
-        // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG_BED
-        if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
-          if (old_temp - temp < MIN_COOLING_SLOPE_DEG_BED) break;
-          next_cool_check_ms = now + 1000UL * MIN_COOLING_SLOPE_TIME_BED;
-          old_temp = temp;
-        }
-      }
-
-    } while (wait_for_heatup && TEMP_BED_CONDITIONS);
-
-    if (wait_for_heatup) LCD_MESSAGEPGM(MSG_BED_DONE);
-    #if DISABLED(BUSY_WHILE_HEATING)
-      KEEPALIVE_STATE(IN_HANDLER);
-    #endif
-  }
-
-#endif // HAS_TEMP_BED
-
-/**
- * M110: Set Current Line Number
- */
-inline void gcode_M110() {
-  if (parser.seenval('N')) gcode_LastN = parser.value_long();
-}
-
-/**
- * M111: Set the debug level
- */
-inline void gcode_M111() {
-  if (parser.seen('S')) marlin_debug_flags = parser.byteval('S');
-
-  const static char str_debug_1[] PROGMEM = MSG_DEBUG_ECHO,
-                    str_debug_2[] PROGMEM = MSG_DEBUG_INFO,
-                    str_debug_4[] PROGMEM = MSG_DEBUG_ERRORS,
-                    str_debug_8[] PROGMEM = MSG_DEBUG_DRYRUN,
-                    str_debug_16[] PROGMEM = MSG_DEBUG_COMMUNICATION
-                    #if ENABLED(DEBUG_LEVELING_FEATURE)
-                      , str_debug_32[] PROGMEM = MSG_DEBUG_LEVELING
-                    #endif
-                    ;
-
-  const static char* const debug_strings[] PROGMEM = {
-    str_debug_1, str_debug_2, str_debug_4, str_debug_8, str_debug_16
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      , str_debug_32
-    #endif
-  };
-
-  SERIAL_ECHO_START();
-  SERIAL_ECHOPGM(MSG_DEBUG_PREFIX);
-  if (marlin_debug_flags) {
-    uint8_t comma = 0;
-    for (uint8_t i = 0; i < COUNT(debug_strings); i++) {
-      if (TEST(marlin_debug_flags, i)) {
-        if (comma++) SERIAL_CHAR(',');
-        serialprintPGM((char*)pgm_read_word(&debug_strings[i]));
-      }
-    }
-  }
-  else {
-    SERIAL_ECHOPGM(MSG_DEBUG_OFF);
-  }
-  SERIAL_EOL();
-}
-
-#if ENABLED(HOST_KEEPALIVE_FEATURE)
-
-  /**
-   * M113: Get or set Host Keepalive interval (0 to disable)
-   *
-   *   S<seconds> Optional. Set the keepalive interval.
-   */
-  inline void gcode_M113() {
-    if (parser.seenval('S')) {
-      host_keepalive_interval = parser.value_byte();
-      NOMORE(host_keepalive_interval, 60);
-    }
-    else {
-      SERIAL_ECHO_START();
-      SERIAL_ECHOLNPAIR("M113 S", (unsigned long)host_keepalive_interval);
-    }
-  }
-
-#endif
-
-#if ENABLED(BARICUDA)
-
-  #if HAS_HEATER_1
-    /**
-     * M126: Heater 1 valve open
-     */
-    inline void gcode_M126() { baricuda_valve_pressure = parser.byteval('S', 255); }
-    /**
-     * M127: Heater 1 valve close
-     */
-    inline void gcode_M127() { baricuda_valve_pressure = 0; }
-  #endif
-
-  #if HAS_HEATER_2
-    /**
-     * M128: Heater 2 valve open
-     */
-    inline void gcode_M128() { baricuda_e_to_p_pressure = parser.byteval('S', 255); }
-    /**
-     * M129: Heater 2 valve close
-     */
-    inline void gcode_M129() { baricuda_e_to_p_pressure = 0; }
-  #endif
-
-#endif // BARICUDA
-
-/**
- * M140: Set bed temperature
- */
-inline void gcode_M140() {
-  if (DEBUGGING(DRYRUN)) return;
-  if (parser.seenval('S')) thermalManager.setTargetBed(parser.value_celsius());
-}
-
-#if ENABLED(ULTIPANEL)
-
-  /**
-   * M145: Set the heatup state for a material in the LCD menu
-   *
-   *   S<material> (0=PLA, 1=ABS)
-   *   H<hotend temp>
-   *   B<bed temp>
-   *   F<fan speed>
-   */
-  inline void gcode_M145() {
-    const uint8_t material = (uint8_t)parser.intval('S');
-    if (material >= COUNT(lcd_preheat_hotend_temp)) {
-      SERIAL_ERROR_START();
-      SERIAL_ERRORLNPGM(MSG_ERR_MATERIAL_INDEX);
-    }
-    else {
-      int v;
-      if (parser.seenval('H')) {
-        v = parser.value_int();
-        lcd_preheat_hotend_temp[material] = constrain(v, EXTRUDE_MINTEMP, HEATER_0_MAXTEMP - 15);
-      }
-      if (parser.seenval('F')) {
-        v = parser.value_int();
-        lcd_preheat_fan_speed[material] = constrain(v, 0, 255);
-      }
-      #if TEMP_SENSOR_BED != 0
-        if (parser.seenval('B')) {
-          v = parser.value_int();
-          lcd_preheat_bed_temp[material] = constrain(v, BED_MINTEMP, BED_MAXTEMP - 15);
-        }
-      #endif
-    }
-  }
-
-#endif // ULTIPANEL
-
-#if ENABLED(TEMPERATURE_UNITS_SUPPORT)
-  /**
-   * M149: Set temperature units
-   */
-  inline void gcode_M149() {
-         if (parser.seenval('C')) parser.set_input_temp_units(TEMPUNIT_C);
-    else if (parser.seenval('K')) parser.set_input_temp_units(TEMPUNIT_K);
-    else if (parser.seenval('F')) parser.set_input_temp_units(TEMPUNIT_F);
-  }
-#endif
-
-#if HAS_POWER_SWITCH
-
-  /**
-   * M80   : Turn on the Power Supply
-   * M80 S : Report the current state and exit
-   */
-  inline void gcode_M80() {
-
-    // S: Report the current power supply state and exit
-    if (parser.seen('S')) {
-      serialprintPGM(powersupply_on ? PSTR("PS:1\n") : PSTR("PS:0\n"));
-      return;
-    }
-
-    OUT_WRITE(PS_ON_PIN, PS_ON_AWAKE); // GND
-
-    /**
-     * If you have a switch on suicide pin, this is useful
-     * if you want to start another print with suicide feature after
-     * a print without suicide...
-     */
-    #if HAS_SUICIDE
-      OUT_WRITE(SUICIDE_PIN, HIGH);
-    #endif
-
-    #if ENABLED(HAVE_TMC2130)
-      delay(100);
-      tmc2130_init(); // Settings only stick when the driver has power
-    #endif
-
-    powersupply_on = true;
-
-    #if ENABLED(ULTIPANEL)
-      LCD_MESSAGEPGM(WELCOME_MSG);
-    #endif
-  }
-
-#endif // HAS_POWER_SWITCH
-
-/**
- * M81: Turn off Power, including Power Supply, if there is one.
- *
- *      This code should ALWAYS be available for EMERGENCY SHUTDOWN!
- */
-inline void gcode_M81() {
-  thermalManager.disable_all_heaters();
-  stepper.finish_and_disable();
-
-  #if FAN_COUNT > 0
-    for (uint8_t i = 0; i < FAN_COUNT; i++) fanSpeeds[i] = 0;
-    #if ENABLED(PROBING_FANS_OFF)
-      fans_paused = false;
-      ZERO(paused_fanSpeeds);
-    #endif
-  #endif
-
-  safe_delay(1000); // Wait 1 second before switching off
-
-  #if HAS_SUICIDE
-    stepper.synchronize();
-    suicide();
-  #elif HAS_POWER_SWITCH
-    OUT_WRITE(PS_ON_PIN, PS_ON_ASLEEP);
-    powersupply_on = false;
-  #endif
-
-  #if ENABLED(ULTIPANEL)
-    LCD_MESSAGEPGM(MACHINE_NAME " " MSG_OFF ".");
-  #endif
-}
-
-/**
- * M82: Set E codes absolute (default)
- */
-inline void gcode_M82() { axis_relative_modes[E_AXIS] = false; }
-
-/**
- * M83: Set E codes relative while in Absolute Coordinates (G90) mode
- */
-inline void gcode_M83() { axis_relative_modes[E_AXIS] = true; }
-
-/**
- * M18, M84: Disable stepper motors
- */
-inline void gcode_M18_M84() {
-  if (parser.seenval('S')) {
-    stepper_inactive_time = parser.value_millis_from_seconds();
-  }
-  else {
-    bool all_axis = !((parser.seen('X')) || (parser.seen('Y')) || (parser.seen('Z')) || (parser.seen('E')));
-    if (all_axis) {
-      stepper.finish_and_disable();
-    }
-    else {
-      stepper.synchronize();
-      if (parser.seen('X')) disable_X();
-      if (parser.seen('Y')) disable_Y();
-      if (parser.seen('Z')) disable_Z();
-      #if E0_ENABLE_PIN != X_ENABLE_PIN && E1_ENABLE_PIN != Y_ENABLE_PIN // Only enable on boards that have separate ENABLE_PINS
-        if (parser.seen('E')) disable_e_steppers();
-      #endif
-    }
-
-    #if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(ULTRA_LCD)  // Only needed with an LCD
-      ubl_lcd_map_control = defer_return_to_status = false;
-    #endif
-  }
-}
-
-/**
- * M85: Set inactivity shutdown timer with parameter S<seconds>. To disable set zero (default)
- */
-inline void gcode_M85() {
-  if (parser.seen('S')) max_inactive_time = parser.value_millis_from_seconds();
-}
-
-/**
- * Multi-stepper support for M92, M201, M203
- */
-#if ENABLED(DISTINCT_E_FACTORS)
-  #define GET_TARGET_EXTRUDER(CMD) if (get_target_extruder_from_command(CMD)) return
-  #define TARGET_EXTRUDER target_extruder
-#else
-  #define GET_TARGET_EXTRUDER(CMD) NOOP
-  #define TARGET_EXTRUDER 0
-#endif
-
-/**
- * M92: Set axis steps-per-unit for one or more axes, X, Y, Z, and E.
- *      (Follows the same syntax as G92)
- *
- *      With multiple extruders use T to specify which one.
- */
-inline void gcode_M92() {
-
-  GET_TARGET_EXTRUDER(92);
-
-  LOOP_XYZE(i) {
-    if (parser.seen(axis_codes[i])) {
-      if (i == E_AXIS) {
-        const float value = parser.value_per_axis_unit((AxisEnum)(E_AXIS + TARGET_EXTRUDER));
-        if (value < 20.0) {
-          float factor = planner.axis_steps_per_mm[E_AXIS + TARGET_EXTRUDER] / value; // increase e constants if M92 E14 is given for netfab.
-          planner.max_jerk[E_AXIS] *= factor;
-          planner.max_feedrate_mm_s[E_AXIS + TARGET_EXTRUDER] *= factor;
-          planner.max_acceleration_steps_per_s2[E_AXIS + TARGET_EXTRUDER] *= factor;
-        }
-        planner.axis_steps_per_mm[E_AXIS + TARGET_EXTRUDER] = value;
-      }
-      else {
-        planner.axis_steps_per_mm[i] = parser.value_per_axis_unit((AxisEnum)i);
-      }
-    }
-  }
-  planner.refresh_positioning();
-}
-
-/**
- * Output the current position to serial
- */
-void report_current_position() {
-  SERIAL_PROTOCOLPGM("X:");
-  SERIAL_PROTOCOL(current_position[X_AXIS]);
-  SERIAL_PROTOCOLPGM(" Y:");
-  SERIAL_PROTOCOL(current_position[Y_AXIS]);
-  SERIAL_PROTOCOLPGM(" Z:");
-  SERIAL_PROTOCOL(current_position[Z_AXIS]);
-  SERIAL_PROTOCOLPGM(" E:");
-  SERIAL_PROTOCOL(current_position[E_AXIS]);
-
-  stepper.report_positions();
-
-  #if IS_SCARA
-    SERIAL_PROTOCOLPAIR("SCARA Theta:", stepper.get_axis_position_degrees(A_AXIS));
-    SERIAL_PROTOCOLLNPAIR("   Psi+Theta:", stepper.get_axis_position_degrees(B_AXIS));
-    SERIAL_EOL();
-  #endif
-}
-
-#ifdef M114_DETAIL
-
-  void report_xyze(const float pos[XYZE], const uint8_t n = 4, const uint8_t precision = 3) {
-    char str[12];
-    for (uint8_t i = 0; i < n; i++) {
-      SERIAL_CHAR(' ');
-      SERIAL_CHAR(axis_codes[i]);
-      SERIAL_CHAR(':');
-      SERIAL_PROTOCOL(dtostrf(pos[i], 8, precision, str));
-    }
-    SERIAL_EOL();
-  }
-
-  inline void report_xyz(const float pos[XYZ]) { report_xyze(pos, 3); }
-
-  void report_current_position_detail() {
-
-    stepper.synchronize();
-
-    SERIAL_PROTOCOLPGM("\nLogical:");
-    report_xyze(current_position);
-
-    SERIAL_PROTOCOLPGM("Raw:    ");
-    const float raw[XYZ] = { RAW_X_POSITION(current_position[X_AXIS]), RAW_Y_POSITION(current_position[Y_AXIS]), RAW_Z_POSITION(current_position[Z_AXIS]) };
-    report_xyz(raw);
-
-    SERIAL_PROTOCOLPGM("Leveled:");
-    float leveled[XYZ] = { current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] };
-    planner.apply_leveling(leveled);
-    report_xyz(leveled);
-
-    SERIAL_PROTOCOLPGM("UnLevel:");
-    float unleveled[XYZ] = { leveled[X_AXIS], leveled[Y_AXIS], leveled[Z_AXIS] };
-    planner.unapply_leveling(unleveled);
-    report_xyz(unleveled);
-
-    #if IS_KINEMATIC
-      #if IS_SCARA
-        SERIAL_PROTOCOLPGM("ScaraK: ");
-      #else
-        SERIAL_PROTOCOLPGM("DeltaK: ");
-      #endif
-      inverse_kinematics(leveled);  // writes delta[]
-      report_xyz(delta);
-    #endif
-
-    SERIAL_PROTOCOLPGM("Stepper:");
-    const float step_count[XYZE] = { stepper.position(X_AXIS), stepper.position(Y_AXIS), stepper.position(Z_AXIS), stepper.position(E_AXIS) };
-    report_xyze(step_count, 4, 0);
-
-    #if IS_SCARA
-      const float deg[XYZ] = {
-        stepper.get_axis_position_degrees(A_AXIS),
-        stepper.get_axis_position_degrees(B_AXIS)
-      };
-      SERIAL_PROTOCOLPGM("Degrees:");
-      report_xyze(deg, 2);
-    #endif
-
-    SERIAL_PROTOCOLPGM("FromStp:");
-    get_cartesian_from_steppers();  // writes cartes[XYZ] (with forward kinematics)
-    const float from_steppers[XYZE] = { cartes[X_AXIS], cartes[Y_AXIS], cartes[Z_AXIS], stepper.get_axis_position_mm(E_AXIS) };
-    report_xyze(from_steppers);
-
-    const float diff[XYZE] = {
-      from_steppers[X_AXIS] - leveled[X_AXIS],
-      from_steppers[Y_AXIS] - leveled[Y_AXIS],
-      from_steppers[Z_AXIS] - leveled[Z_AXIS],
-      from_steppers[E_AXIS] - current_position[E_AXIS]
-    };
-    SERIAL_PROTOCOLPGM("Differ: ");
-    report_xyze(diff);
-  }
-#endif // M114_DETAIL
-
-/**
- * M114: Report current position to host
- */
-inline void gcode_M114() {
-
-  #ifdef M114_DETAIL
-    if (parser.seen('D')) {
-      report_current_position_detail();
-      return;
-    }
-  #endif
-
-  stepper.synchronize();
-  report_current_position();
-}
-
-/**
- * M115: Capabilities string
- */
-inline void gcode_M115() {
-  SERIAL_PROTOCOLLNPGM(MSG_M115_REPORT);
-
-  #if ENABLED(EXTENDED_CAPABILITIES_REPORT)
-
-    // EEPROM (M500, M501)
-    #if ENABLED(EEPROM_SETTINGS)
-      SERIAL_PROTOCOLLNPGM("Cap:EEPROM:1");
-    #else
-      SERIAL_PROTOCOLLNPGM("Cap:EEPROM:0");
-    #endif
-
-    // AUTOREPORT_TEMP (M155)
-    #if ENABLED(AUTO_REPORT_TEMPERATURES)
-      SERIAL_PROTOCOLLNPGM("Cap:AUTOREPORT_TEMP:1");
-    #else
-      SERIAL_PROTOCOLLNPGM("Cap:AUTOREPORT_TEMP:0");
-    #endif
-
-    // PROGRESS (M530 S L, M531 <file>, M532 X L)
-    SERIAL_PROTOCOLLNPGM("Cap:PROGRESS:0");
-
-    // Print Job timer M75, M76, M77
-    SERIAL_PROTOCOLLNPGM("Cap:PRINT_JOB:1");
-
-    // AUTOLEVEL (G29)
-    #if HAS_ABL
-      SERIAL_PROTOCOLLNPGM("Cap:AUTOLEVEL:1");
-    #else
-      SERIAL_PROTOCOLLNPGM("Cap:AUTOLEVEL:0");
-    #endif
-
-    // Z_PROBE (G30)
-    #if HAS_BED_PROBE
-      SERIAL_PROTOCOLLNPGM("Cap:Z_PROBE:1");
-    #else
-      SERIAL_PROTOCOLLNPGM("Cap:Z_PROBE:0");
-    #endif
-
-    // MESH_REPORT (M420 V)
-    #if HAS_LEVELING
-      SERIAL_PROTOCOLLNPGM("Cap:LEVELING_DATA:1");
-    #else
-      SERIAL_PROTOCOLLNPGM("Cap:LEVELING_DATA:0");
-    #endif
-
-    // SOFTWARE_POWER (M80, M81)
-    #if HAS_POWER_SWITCH
-      SERIAL_PROTOCOLLNPGM("Cap:SOFTWARE_POWER:1");
-    #else
-      SERIAL_PROTOCOLLNPGM("Cap:SOFTWARE_POWER:0");
-    #endif
-
-    // CASE LIGHTS (M355)
-    #if HAS_CASE_LIGHT
-      SERIAL_PROTOCOLLNPGM("Cap:TOGGLE_LIGHTS:1");
-      if (USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN)) {
-        SERIAL_PROTOCOLLNPGM("Cap:CASE_LIGHT_BRIGHTNESS:1");
-      }
-      else
-        SERIAL_PROTOCOLLNPGM("Cap:CASE_LIGHT_BRIGHTNESS:0");
-    #else
-      SERIAL_PROTOCOLLNPGM("Cap:TOGGLE_LIGHTS:0");
-      SERIAL_PROTOCOLLNPGM("Cap:CASE_LIGHT_BRIGHTNESS:0");
-    #endif
-
-    // EMERGENCY_PARSER (M108, M112, M410)
-    #if ENABLED(EMERGENCY_PARSER)
-      SERIAL_PROTOCOLLNPGM("Cap:EMERGENCY_PARSER:1");
-    #else
-      SERIAL_PROTOCOLLNPGM("Cap:EMERGENCY_PARSER:0");
-    #endif
-
-  #endif // EXTENDED_CAPABILITIES_REPORT
-}
-
-/**
- * M117: Set LCD Status Message
- */
-inline void gcode_M117() { lcd_setstatus(parser.string_arg); }
-
-/**
- * M118: Display a message in the host console.
- *
- *  A  Append '// ' for an action command, as in OctoPrint
- *  E  Have the host 'echo:' the text
- */
-inline void gcode_M118() {
-  if (parser.boolval('E')) SERIAL_ECHO_START();
-  if (parser.boolval('A')) SERIAL_ECHOPGM("// ");
-  SERIAL_ECHOLN(parser.string_arg);
-}
-
-/**
- * M119: Output endstop states to serial output
- */
-inline void gcode_M119() { endstops.M119(); }
-
-/**
- * M120: Enable endstops and set non-homing endstop state to "enabled"
- */
-inline void gcode_M120() { endstops.enable_globally(true); }
-
-/**
- * M121: Disable endstops and set non-homing endstop state to "disabled"
- */
-inline void gcode_M121() { endstops.enable_globally(false); }
-
-#if ENABLED(PARK_HEAD_ON_PAUSE)
-
-  /**
-   * M125: Store current position and move to filament change position.
-   *       Called on pause (by M25) to prevent material leaking onto the
-   *       object. On resume (M24) the head will be moved back and the
-   *       print will resume.
-   *
-   *       If Marlin is compiled without SD Card support, M125 can be
-   *       used directly to pause the print and move to park position,
-   *       resuming with a button click or M108.
-   *
-   *    L = override retract length
-   *    X = override X
-   *    Y = override Y
-   *    Z = override Z raise
-   */
-  inline void gcode_M125() {
-
-    // Initial retract before move to filament change position
-    const float retract = parser.seen('L') ? parser.value_axis_units(E_AXIS) : 0
-      #ifdef PAUSE_PARK_RETRACT_LENGTH
-        - (PAUSE_PARK_RETRACT_LENGTH)
-      #endif
-    ;
-
-    // Lift Z axis
-    const float z_lift = parser.linearval('Z')
-      #ifdef PAUSE_PARK_Z_ADD
-        + PAUSE_PARK_Z_ADD
-      #endif
-    ;
-
-    // Move XY axes to filament change position or given position
-    const float x_pos = parser.linearval('X')
-      #ifdef PAUSE_PARK_X_POS
-        + PAUSE_PARK_X_POS
-      #endif
-      #if HOTENDS > 1 && DISABLED(DUAL_X_CARRIAGE)
-        + (active_extruder ? hotend_offset[X_AXIS][active_extruder] : 0)
-      #endif
-    ;
-    const float y_pos = parser.linearval('Y')
-      #ifdef PAUSE_PARK_Y_POS
-        + PAUSE_PARK_Y_POS
-      #endif
-      #if HOTENDS > 1 && DISABLED(DUAL_X_CARRIAGE)
-        + (active_extruder ? hotend_offset[Y_AXIS][active_extruder] : 0)
-      #endif
-    ;
-
-    #if DISABLED(SDSUPPORT)
-      const bool job_running = print_job_timer.isRunning();
-    #endif
-
-    if (pause_print(retract, z_lift, x_pos, y_pos)) {
-      #if DISABLED(SDSUPPORT)
-        // Wait for lcd click or M108
-        wait_for_filament_reload();
-
-        // Return to print position and continue
-        resume_print();
-
-        if (job_running) print_job_timer.start();
-      #endif
-    }
-  }
-
-#endif // PARK_HEAD_ON_PAUSE
-
-#if HAS_COLOR_LEDS
-
-  /**
-   * M150: Set Status LED Color - Use R-U-B-W for R-G-B-W
-   *
-   * Always sets all 3 or 4 components. If a component is left out, set to 0.
-   *
-   * Examples:
-   *
-   *   M150 R255       ; Turn LED red
-   *   M150 R255 U127  ; Turn LED orange (PWM only)
-   *   M150            ; Turn LED off
-   *   M150 R U B      ; Turn LED white
-   *   M150 W          ; Turn LED white using a white LED
-   *
-   */
-  inline void gcode_M150() {
-    set_led_color(
-      parser.seen('R') ? (parser.has_value() ? parser.value_byte() : 255) : 0,
-      parser.seen('U') ? (parser.has_value() ? parser.value_byte() : 255) : 0,
-      parser.seen('B') ? (parser.has_value() ? parser.value_byte() : 255) : 0
-      #if ENABLED(RGBW_LED) || ENABLED(NEOPIXEL_RGBW_LED)
-        , parser.seen('W') ? (parser.has_value() ? parser.value_byte() : 255) : 0
-      #endif
-    );
-  }
-
-#endif // HAS_COLOR_LEDS
-
-/**
- * M200: Set filament diameter and set E axis units to cubic units
- *
- *    T<extruder> - Optional extruder number. Current extruder if omitted.
- *    D<linear> - Diameter of the filament. Use "D0" to switch back to linear units on the E axis.
- */
-inline void gcode_M200() {
-
-  if (get_target_extruder_from_command(200)) return;
-
-  if (parser.seen('D')) {
-    // setting any extruder filament size disables volumetric on the assumption that
-    // slicers either generate in extruder values as cubic mm or as as filament feeds
-    // for all extruders
-    volumetric_enabled = (parser.value_linear_units() != 0.0);
-    if (volumetric_enabled) {
-      filament_size[target_extruder] = parser.value_linear_units();
-      // make sure all extruders have some sane value for the filament size
-      for (uint8_t i = 0; i < COUNT(filament_size); i++)
-        if (! filament_size[i]) filament_size[i] = DEFAULT_NOMINAL_FILAMENT_DIA;
-    }
-  }
-  calculate_volumetric_multipliers();
-}
-
-/**
- * M201: Set max acceleration in units/s^2 for print moves (M201 X1000 Y1000)
- *
- *       With multiple extruders use T to specify which one.
- */
-inline void gcode_M201() {
-
-  GET_TARGET_EXTRUDER(201);
-
-  LOOP_XYZE(i) {
-    if (parser.seen(axis_codes[i])) {
-      const uint8_t a = i + (i == E_AXIS ? TARGET_EXTRUDER : 0);
-      planner.max_acceleration_mm_per_s2[a] = parser.value_axis_units((AxisEnum)a);
-    }
-  }
-  // steps per sq second need to be updated to agree with the units per sq second (as they are what is used in the planner)
-  planner.reset_acceleration_rates();
-}
-
-#if 0 // Not used for Sprinter/grbl gen6
-  inline void gcode_M202() {
-    LOOP_XYZE(i) {
-      if (parser.seen(axis_codes[i])) axis_travel_steps_per_sqr_second[i] = parser.value_axis_units((AxisEnum)i) * planner.axis_steps_per_mm[i];
-    }
-  }
-#endif
-
-
-/**
- * M203: Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in units/sec
- *
- *       With multiple extruders use T to specify which one.
- */
-inline void gcode_M203() {
-
-  GET_TARGET_EXTRUDER(203);
-
-  LOOP_XYZE(i)
-    if (parser.seen(axis_codes[i])) {
-      const uint8_t a = i + (i == E_AXIS ? TARGET_EXTRUDER : 0);
-      planner.max_feedrate_mm_s[a] = parser.value_axis_units((AxisEnum)a);
-    }
-}
-
-/**
- * M204: Set Accelerations in units/sec^2 (M204 P1200 R3000 T3000)
- *
- *    P = Printing moves
- *    R = Retract only (no X, Y, Z) moves
- *    T = Travel (non printing) moves
- *
- *  Also sets minimum segment time in ms (B20000) to prevent buffer under-runs and M20 minimum feedrate
- */
-inline void gcode_M204() {
-  if (parser.seen('S')) {  // Kept for legacy compatibility. Should NOT BE USED for new developments.
-    planner.travel_acceleration = planner.acceleration = parser.value_linear_units();
-    SERIAL_ECHOLNPAIR("Setting Print and Travel Acceleration: ", planner.acceleration);
-  }
-  if (parser.seen('P')) {
-    planner.acceleration = parser.value_linear_units();
-    SERIAL_ECHOLNPAIR("Setting Print Acceleration: ", planner.acceleration);
-  }
-  if (parser.seen('R')) {
-    planner.retract_acceleration = parser.value_linear_units();
-    SERIAL_ECHOLNPAIR("Setting Retract Acceleration: ", planner.retract_acceleration);
-  }
-  if (parser.seen('T')) {
-    planner.travel_acceleration = parser.value_linear_units();
-    SERIAL_ECHOLNPAIR("Setting Travel Acceleration: ", planner.travel_acceleration);
-  }
-}
-
-/**
- * M205: Set Advanced Settings
- *
- *    S = Min Feed Rate (units/s)
- *    T = Min Travel Feed Rate (units/s)
- *    B = Min Segment Time (µs)
- *    X = Max X Jerk (units/sec^2)
- *    Y = Max Y Jerk (units/sec^2)
- *    Z = Max Z Jerk (units/sec^2)
- *    E = Max E Jerk (units/sec^2)
- */
-inline void gcode_M205() {
-  if (parser.seen('S')) planner.min_feedrate_mm_s = parser.value_linear_units();
-  if (parser.seen('T')) planner.min_travel_feedrate_mm_s = parser.value_linear_units();
-  if (parser.seen('B')) planner.min_segment_time = parser.value_millis();
-  if (parser.seen('X')) planner.max_jerk[X_AXIS] = parser.value_linear_units();
-  if (parser.seen('Y')) planner.max_jerk[Y_AXIS] = parser.value_linear_units();
-  if (parser.seen('Z')) planner.max_jerk[Z_AXIS] = parser.value_linear_units();
-  if (parser.seen('E')) planner.max_jerk[E_AXIS] = parser.value_linear_units();
-}
-
-#if HAS_M206_COMMAND
-
-  /**
-   * M206: Set Additional Homing Offset (X Y Z). SCARA aliases T=X, P=Y
-   *
-   * *** @thinkyhead: I recommend deprecating M206 for SCARA in favor of M665.
-   * ***              M206 for SCARA will remain enabled in 1.1.x for compatibility.
-   * ***              In the 2.0 release, it will simply be disabled by default.
-   */
-  inline void gcode_M206() {
-    LOOP_XYZ(i)
-      if (parser.seen(axis_codes[i]))
-        set_home_offset((AxisEnum)i, parser.value_linear_units());
-
-    #if ENABLED(MORGAN_SCARA)
-      if (parser.seen('T')) set_home_offset(A_AXIS, parser.value_linear_units()); // Theta
-      if (parser.seen('P')) set_home_offset(B_AXIS, parser.value_linear_units()); // Psi
-    #endif
-
-    SYNC_PLAN_POSITION_KINEMATIC();
-    report_current_position();
-  }
-
-#endif // HAS_M206_COMMAND
-
-#if ENABLED(DELTA)
-  /**
-   * M665: Set delta configurations
-   *
-   *    H = delta height
-   *    L = diagonal rod
-   *    R = delta radius
-   *    S = segments per second
-   *    B = delta calibration radius
-   *    X = Alpha (Tower 1) angle trim
-   *    Y = Beta (Tower 2) angle trim
-   *    Z = Rotate A and B by this angle
-   */
-  inline void gcode_M665() {
-    if (parser.seen('H')) {
-      home_offset[Z_AXIS] = parser.value_linear_units() - DELTA_HEIGHT;
-      update_software_endstops(Z_AXIS);
-    }
-    if (parser.seen('L')) delta_diagonal_rod             = parser.value_linear_units();
-    if (parser.seen('R')) delta_radius                   = parser.value_linear_units();
-    if (parser.seen('S')) delta_segments_per_second      = parser.value_float();
-    if (parser.seen('B')) delta_calibration_radius       = parser.value_float();
-    if (parser.seen('X')) delta_tower_angle_trim[A_AXIS] = parser.value_float();
-    if (parser.seen('Y')) delta_tower_angle_trim[B_AXIS] = parser.value_float();
-    if (parser.seen('Z')) { // rotate all 3 axis for Z = 0
-      delta_tower_angle_trim[A_AXIS] -= parser.value_float();
-      delta_tower_angle_trim[B_AXIS] -= parser.value_float();
-    }
-    recalc_delta_settings(delta_radius, delta_diagonal_rod);
-  }
-  /**
-   * M666: Set delta endstop adjustment
-   */
-  inline void gcode_M666() {
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        SERIAL_ECHOLNPGM(">>> gcode_M666");
-      }
-    #endif
-    LOOP_XYZ(i) {
-      if (parser.seen(axis_codes[i])) {
-        endstop_adj[i] = parser.value_linear_units();
-        #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) {
-            SERIAL_ECHOPAIR("endstop_adj[", axis_codes[i]);
-            SERIAL_ECHOLNPAIR("] = ", endstop_adj[i]);
-          }
-        #endif
-      }
-    }
-    #if ENABLED(DEBUG_LEVELING_FEATURE)
-      if (DEBUGGING(LEVELING)) {
-        SERIAL_ECHOLNPGM("<<< gcode_M666");
-      }
-    #endif
-    // normalize endstops so all are <=0; set the residue to delta height
-    const float z_temp = MAX3(endstop_adj[A_AXIS], endstop_adj[B_AXIS], endstop_adj[C_AXIS]);
-    home_offset[Z_AXIS] -= z_temp;
-    LOOP_XYZ(i) endstop_adj[i] -= z_temp;
-  }
-
-#elif IS_SCARA
-
-  /**
-   * M665: Set SCARA settings
-   *
-   * Parameters:
-   *
-   *   S[segments-per-second] - Segments-per-second
-   *   P[theta-psi-offset]    - Theta-Psi offset, added to the shoulder (A/X) angle
-   *   T[theta-offset]        - Theta     offset, added to the elbow    (B/Y) angle
-   *
-   *   A, P, and X are all aliases for the shoulder angle
-   *   B, T, and Y are all aliases for the elbow angle
-   */
-  inline void gcode_M665() {
-    if (parser.seen('S')) delta_segments_per_second = parser.value_float();
-
-    const bool hasA = parser.seen('A'), hasP = parser.seen('P'), hasX = parser.seen('X');
-    const uint8_t sumAPX = hasA + hasP + hasX;
-    if (sumAPX == 1)
-      home_offset[A_AXIS] = parser.value_float();
-    else if (sumAPX > 1) {
-      SERIAL_ERROR_START();
-      SERIAL_ERRORLNPGM("Only one of A, P, or X is allowed.");
-      return;
-    }
-
-    const bool hasB = parser.seen('B'), hasT = parser.seen('T'), hasY = parser.seen('Y');
-    const uint8_t sumBTY = hasB + hasT + hasY;
-    if (sumBTY == 1)
-      home_offset[B_AXIS] = parser.value_float();
-    else if (sumBTY > 1) {
-      SERIAL_ERROR_START();
-      SERIAL_ERRORLNPGM("Only one of B, T, or Y is allowed.");
-      return;
-    }
-  }
-
-#elif ENABLED(Z_DUAL_ENDSTOPS) // !DELTA && ENABLED(Z_DUAL_ENDSTOPS)
-
-  /**
-   * M666: For Z Dual Endstop setup, set z axis offset to the z2 axis.
-   */
-  inline void gcode_M666() {
-    if (parser.seen('Z')) z_endstop_adj = parser.value_linear_units();
-    SERIAL_ECHOLNPAIR("Z Endstop Adjustment set to (mm):", z_endstop_adj);
-  }
-
-#endif // !DELTA && Z_DUAL_ENDSTOPS
-
-#if ENABLED(FWRETRACT)
-
-  /**
-   * M207: Set firmware retraction values
-   *
-   *   S[+units]    retract_length
-   *   W[+units]    swap_retract_length (multi-extruder)
-   *   F[units/min] retract_feedrate_mm_s
-   *   Z[units]     retract_zlift
-   */
-  inline void gcode_M207() {
-    if (parser.seen('S')) retract_length = parser.value_axis_units(E_AXIS);
-    if (parser.seen('F')) retract_feedrate_mm_s = MMM_TO_MMS(parser.value_axis_units(E_AXIS));
-    if (parser.seen('Z')) retract_zlift = parser.value_linear_units();
-    if (parser.seen('W')) swap_retract_length = parser.value_axis_units(E_AXIS);
-  }
-
-  /**
-   * M208: Set firmware un-retraction values
-   *
-   *   S[+units]    retract_recover_length (in addition to M207 S*)
-   *   W[+units]    swap_retract_recover_length (multi-extruder)
-   *   F[units/min] retract_recover_feedrate_mm_s
-   *   R[units/min] swap_retract_recover_feedrate_mm_s
-   */
-  inline void gcode_M208() {
-    if (parser.seen('S')) retract_recover_length = parser.value_axis_units(E_AXIS);
-    if (parser.seen('F')) retract_recover_feedrate_mm_s = MMM_TO_MMS(parser.value_axis_units(E_AXIS));
-    if (parser.seen('R')) swap_retract_recover_feedrate_mm_s = MMM_TO_MMS(parser.value_axis_units(E_AXIS));
-    if (parser.seen('W')) swap_retract_recover_length = parser.value_axis_units(E_AXIS);
-  }
-
-  /**
-   * M209: Enable automatic retract (M209 S1)
-   *   For slicers that don't support G10/11, reversed extrude-only
-   *   moves will be classified as retraction.
-   */
-  inline void gcode_M209() {
-    if (MIN_AUTORETRACT <= MAX_AUTORETRACT) {
-      if (parser.seen('S')) {
-        autoretract_enabled = parser.value_bool();
-        for (uint8_t i = 0; i < EXTRUDERS; i++) retracted[i] = false;
-      }
-    }
-  }
-
-#endif // FWRETRACT
-
-/**
- * M211: Enable, Disable, and/or Report software endstops
- *
- * Usage: M211 S1 to enable, M211 S0 to disable, M211 alone for report
- */
-inline void gcode_M211() {
-  SERIAL_ECHO_START();
-  #if HAS_SOFTWARE_ENDSTOPS
-    if (parser.seen('S')) soft_endstops_enabled = parser.value_bool();
-    SERIAL_ECHOPGM(MSG_SOFT_ENDSTOPS);
-    serialprintPGM(soft_endstops_enabled ? PSTR(MSG_ON) : PSTR(MSG_OFF));
-  #else
-    SERIAL_ECHOPGM(MSG_SOFT_ENDSTOPS);
-    SERIAL_ECHOPGM(MSG_OFF);
-  #endif
-  SERIAL_ECHOPGM(MSG_SOFT_MIN);
-  SERIAL_ECHOPAIR(    MSG_X, soft_endstop_min[X_AXIS]);
-  SERIAL_ECHOPAIR(" " MSG_Y, soft_endstop_min[Y_AXIS]);
-  SERIAL_ECHOPAIR(" " MSG_Z, soft_endstop_min[Z_AXIS]);
-  SERIAL_ECHOPGM(MSG_SOFT_MAX);
-  SERIAL_ECHOPAIR(    MSG_X, soft_endstop_max[X_AXIS]);
-  SERIAL_ECHOPAIR(" " MSG_Y, soft_endstop_max[Y_AXIS]);
-  SERIAL_ECHOLNPAIR(" " MSG_Z, soft_endstop_max[Z_AXIS]);
-}
-
-#if HOTENDS > 1
-
-  /**
-   * M218 - set hotend offset (in linear units)
-   *
-   *   T<tool>
-   *   X<xoffset>
-   *   Y<yoffset>
-   *   Z<zoffset> - Available with DUAL_X_CARRIAGE and SWITCHING_NOZZLE
-   */
-  inline void gcode_M218() {
-    if (get_target_extruder_from_command(218) || target_extruder == 0) return;
-
-    if (parser.seenval('X')) hotend_offset[X_AXIS][target_extruder] = parser.value_linear_units();
-    if (parser.seenval('Y')) hotend_offset[Y_AXIS][target_extruder] = parser.value_linear_units();
-
-    #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(SWITCHING_NOZZLE) || ENABLED(PARKING_EXTRUDER)
-      if (parser.seenval('Z')) hotend_offset[Z_AXIS][target_extruder] = parser.value_linear_units();
-    #endif
-
-    SERIAL_ECHO_START();
-    SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);
-    HOTEND_LOOP() {
-      SERIAL_CHAR(' ');
-      SERIAL_ECHO(hotend_offset[X_AXIS][e]);
-      SERIAL_CHAR(',');
-      SERIAL_ECHO(hotend_offset[Y_AXIS][e]);
-      #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(SWITCHING_NOZZLE) || ENABLED(PARKING_EXTRUDER)
-        SERIAL_CHAR(',');
-        SERIAL_ECHO(hotend_offset[Z_AXIS][e]);
-      #endif
-    }
-    SERIAL_EOL();
-  }
-
-#endif // HOTENDS > 1
-
-/**
- * M220: Set speed percentage factor, aka "Feed Rate" (M220 S95)
- */
-inline void gcode_M220() {
-  if (parser.seenval('S')) feedrate_percentage = parser.value_int();
-}
-
-/**
- * M221: Set extrusion percentage (M221 T0 S95)
- */
-inline void gcode_M221() {
-  if (get_target_extruder_from_command(221)) return;
-  if (parser.seenval('S'))
-    flow_percentage[target_extruder] = parser.value_int();
-}
-
-/**
- * M226: Wait until the specified pin reaches the state required (M226 P<pin> S<state>)
- */
-inline void gcode_M226() {
-  if (parser.seen('P')) {
-    const int pin_number = parser.value_int(),
-              pin_state = parser.intval('S', -1); // required pin state - default is inverted
-
-    if (WITHIN(pin_state, -1, 1) && pin_number > -1 && !pin_is_protected(pin_number)) {
-
-      int target = LOW;
-
-      stepper.synchronize();
-
-      pinMode(pin_number, INPUT);
-      switch (pin_state) {
-        case 1:
-          target = HIGH;
-          break;
-        case 0:
-          target = LOW;
-          break;
-        case -1:
-          target = !digitalRead(pin_number);
-          break;
-      }
-
-      while (digitalRead(pin_number) != target) idle();
-
-    } // pin_state -1 0 1 && pin_number > -1
-  } // parser.seen('P')
-}
-
-#if ENABLED(EXPERIMENTAL_I2CBUS)
-
-  /**
-   * M260: Send data to a I2C slave device
-   *
-   * This is a PoC, the formating and arguments for the GCODE will
-   * change to be more compatible, the current proposal is:
-   *
-   *  M260 A<slave device address base 10> ; Sets the I2C slave address the data will be sent to
-   *
-   *  M260 B<byte-1 value in base 10>
-   *  M260 B<byte-2 value in base 10>
-   *  M260 B<byte-3 value in base 10>
-   *
-   *  M260 S1 ; Send the buffered data and reset the buffer
-   *  M260 R1 ; Reset the buffer without sending data
-   *
-   */
-  inline void gcode_M260() {
-    // Set the target address
-    if (parser.seen('A')) i2c.address(parser.value_byte());
-
-    // Add a new byte to the buffer
-    if (parser.seen('B')) i2c.addbyte(parser.value_byte());
-
-    // Flush the buffer to the bus
-    if (parser.seen('S')) i2c.send();
-
-    // Reset and rewind the buffer
-    else if (parser.seen('R')) i2c.reset();
-  }
-
-  /**
-   * M261: Request X bytes from I2C slave device
-   *
-   * Usage: M261 A<slave device address base 10> B<number of bytes>
-   */
-  inline void gcode_M261() {
-    if (parser.seen('A')) i2c.address(parser.value_byte());
-
-    uint8_t bytes = parser.byteval('B', 1);
-
-    if (i2c.addr && bytes && bytes <= TWIBUS_BUFFER_SIZE) {
-      i2c.relay(bytes);
-    }
-    else {
-      SERIAL_ERROR_START();
-      SERIAL_ERRORLN("Bad i2c request");
-    }
-  }
-
-#endif // EXPERIMENTAL_I2CBUS
-
-#if HAS_SERVOS
-
-  /**
-   * M280: Get or set servo position. P<index> [S<angle>]
-   */
-  inline void gcode_M280() {
-    if (!parser.seen('P')) return;
-    const int servo_index = parser.value_int();
-    if (WITHIN(servo_index, 0, NUM_SERVOS - 1)) {
-      if (parser.seen('S'))
-        MOVE_SERVO(servo_index, parser.value_int());
-      else {
-        SERIAL_ECHO_START();
-        SERIAL_ECHOPAIR(" Servo ", servo_index);
-        SERIAL_ECHOLNPAIR(": ", servo[servo_index].read());
-      }
-    }
-    else {
-      SERIAL_ERROR_START();
-      SERIAL_ECHOPAIR("Servo ", servo_index);
-      SERIAL_ECHOLNPGM(" out of range");
-    }
-  }
-
-#endif // HAS_SERVOS
-
-#if HAS_BUZZER
-
-  /**
-   * M300: Play beep sound S<frequency Hz> P<duration ms>
-   */
-  inline void gcode_M300() {
-    uint16_t const frequency = parser.ushortval('S', 260);
-    uint16_t duration = parser.ushortval('P', 1000);
-
-    // Limits the tone duration to 0-5 seconds.
-    NOMORE(duration, 5000);
-
-    BUZZ(duration, frequency);
-  }
-
-#endif // HAS_BUZZER
-
-#if ENABLED(PIDTEMP)
-
-  /**
-   * M301: Set PID parameters P I D (and optionally C, L)
-   *
-   *   P[float] Kp term
-   *   I[float] Ki term (unscaled)
-   *   D[float] Kd term (unscaled)
-   *
-   * With PID_EXTRUSION_SCALING:
-   *
-   *   C[float] Kc term
-   *   L[float] LPQ length
-   */
-  inline void gcode_M301() {
-
-    // multi-extruder PID patch: M301 updates or prints a single extruder's PID values
-    // default behaviour (omitting E parameter) is to update for extruder 0 only
-    const uint8_t e = parser.byteval('E'); // extruder being updated
-
-    if (e < HOTENDS) { // catch bad input value
-      if (parser.seen('P')) PID_PARAM(Kp, e) = parser.value_float();
-      if (parser.seen('I')) PID_PARAM(Ki, e) = scalePID_i(parser.value_float());
-      if (parser.seen('D')) PID_PARAM(Kd, e) = scalePID_d(parser.value_float());
-      #if ENABLED(PID_EXTRUSION_SCALING)
-        if (parser.seen('C')) PID_PARAM(Kc, e) = parser.value_float();
-        if (parser.seen('L')) lpq_len = parser.value_float();
-        NOMORE(lpq_len, LPQ_MAX_LEN);
-      #endif
-
-      thermalManager.updatePID();
-      SERIAL_ECHO_START();
-      #if ENABLED(PID_PARAMS_PER_HOTEND)
-        SERIAL_ECHOPAIR(" e:", e); // specify extruder in serial output
-      #endif // PID_PARAMS_PER_HOTEND
-      SERIAL_ECHOPAIR(" p:", PID_PARAM(Kp, e));
-      SERIAL_ECHOPAIR(" i:", unscalePID_i(PID_PARAM(Ki, e)));
-      SERIAL_ECHOPAIR(" d:", unscalePID_d(PID_PARAM(Kd, e)));
-      #if ENABLED(PID_EXTRUSION_SCALING)
-        //Kc does not have scaling applied above, or in resetting defaults
-        SERIAL_ECHOPAIR(" c:", PID_PARAM(Kc, e));
-      #endif
-      SERIAL_EOL();
-    }
-    else {
-      SERIAL_ERROR_START();
-      SERIAL_ERRORLN(MSG_INVALID_EXTRUDER);
-    }
-  }
-
-#endif // PIDTEMP
-
-#if ENABLED(PIDTEMPBED)
-
-  inline void gcode_M304() {
-    if (parser.seen('P')) thermalManager.bedKp = parser.value_float();
-    if (parser.seen('I')) thermalManager.bedKi = scalePID_i(parser.value_float());
-    if (parser.seen('D')) thermalManager.bedKd = scalePID_d(parser.value_float());
-
-    thermalManager.updatePID();
-
-    SERIAL_ECHO_START();
-    SERIAL_ECHOPAIR(" p:", thermalManager.bedKp);
-    SERIAL_ECHOPAIR(" i:", unscalePID_i(thermalManager.bedKi));
-    SERIAL_ECHOLNPAIR(" d:", unscalePID_d(thermalManager.bedKd));
-  }
-
-#endif // PIDTEMPBED
-
-#if defined(CHDK) || HAS_PHOTOGRAPH
-
-  /**
-   * M240: Trigger a camera by emulating a Canon RC-1
-   *       See http://www.doc-diy.net/photo/rc-1_hacked/
-   */
-  inline void gcode_M240() {
-    #ifdef CHDK
-
-      OUT_WRITE(CHDK, HIGH);
-      chdkHigh = millis();
-      chdkActive = true;
-
-    #elif HAS_PHOTOGRAPH
-
-      const uint8_t NUM_PULSES = 16;
-      const float PULSE_LENGTH = 0.01524;
-      for (int i = 0; i < NUM_PULSES; i++) {
-        WRITE(PHOTOGRAPH_PIN, HIGH);
-        _delay_ms(PULSE_LENGTH);
-        WRITE(PHOTOGRAPH_PIN, LOW);
-        _delay_ms(PULSE_LENGTH);
-      }
-      delay(7.33);
-      for (int i = 0; i < NUM_PULSES; i++) {
-        WRITE(PHOTOGRAPH_PIN, HIGH);
-        _delay_ms(PULSE_LENGTH);
-        WRITE(PHOTOGRAPH_PIN, LOW);
-        _delay_ms(PULSE_LENGTH);
-      }
-
-    #endif // !CHDK && HAS_PHOTOGRAPH
-  }
-
-#endif // CHDK || PHOTOGRAPH_PIN
-
-#if HAS_LCD_CONTRAST
-
-  /**
-   * M250: Read and optionally set the LCD contrast
-   */
-  inline void gcode_M250() {
-    if (parser.seen('C')) set_lcd_contrast(parser.value_int());
-    SERIAL_PROTOCOLPGM("lcd contrast value: ");
-    SERIAL_PROTOCOL(lcd_contrast);
-    SERIAL_EOL();
-  }
-
-#endif // HAS_LCD_CONTRAST
-
-#if ENABLED(PREVENT_COLD_EXTRUSION)
-
-  /**
-   * M302: Allow cold extrudes, or set the minimum extrude temperature
-   *
-   *       S<temperature> sets the minimum extrude temperature
-   *       P<bool> enables (1) or disables (0) cold extrusion
-   *
-   *  Examples:
-   *
-   *       M302         ; report current cold extrusion state
-   *       M302 P0      ; enable cold extrusion checking
-   *       M302 P1      ; disables cold extrusion checking
-   *       M302 S0      ; always allow extrusion (disables checking)
-   *       M302 S170    ; only allow extrusion above 170
-   *       M302 S170 P1 ; set min extrude temp to 170 but leave disabled
-   */
-  inline void gcode_M302() {
-    const bool seen_S = parser.seen('S');
-    if (seen_S) {
-      thermalManager.extrude_min_temp = parser.value_celsius();
-      thermalManager.allow_cold_extrude = (thermalManager.extrude_min_temp == 0);
-    }
-
-    if (parser.seen('P'))
-      thermalManager.allow_cold_extrude = (thermalManager.extrude_min_temp == 0) || parser.value_bool();
-    else if (!seen_S) {
-      // Report current state
-      SERIAL_ECHO_START();
-      SERIAL_ECHOPAIR("Cold extrudes are ", (thermalManager.allow_cold_extrude ? "en" : "dis"));
-      SERIAL_ECHOPAIR("abled (min temp ", thermalManager.extrude_min_temp);
-      SERIAL_ECHOLNPGM("C)");
-    }
-  }
-
-#endif // PREVENT_COLD_EXTRUSION
-
-/**
- * M303: PID relay autotune
- *
- *       S<temperature> sets the target temperature. (default 150C)
- *       E<extruder> (-1 for the bed) (default 0)
- *       C<cycles>
- *       U<bool> with a non-zero value will apply the result to current settings
- */
-inline void gcode_M303() {
-  #if HAS_PID_HEATING
-    const int e = parser.intval('E'), c = parser.intval('C', 5);
-    const bool u = parser.boolval('U');
-
-    int16_t temp = parser.celsiusval('S', e < 0 ? 70 : 150);
-
-    if (WITHIN(e, 0, HOTENDS - 1))
-      target_extruder = e;
-
-    #if DISABLED(BUSY_WHILE_HEATING)
-      KEEPALIVE_STATE(NOT_BUSY);
-    #endif
-
-    thermalManager.PID_autotune(temp, e, c, u);
-
-    #if DISABLED(BUSY_WHILE_HEATING)
-      KEEPALIVE_STATE(IN_HANDLER);
-    #endif
-  #else
-    SERIAL_ERROR_START();
-    SERIAL_ERRORLNPGM(MSG_ERR_M303_DISABLED);
-  #endif
-}
-
-#if ENABLED(MORGAN_SCARA)
-
-  bool SCARA_move_to_cal(uint8_t delta_a, uint8_t delta_b) {
-    if (IsRunning()) {
-      forward_kinematics_SCARA(delta_a, delta_b);
-      destination[X_AXIS] = LOGICAL_X_POSITION(cartes[X_AXIS]);
-      destination[Y_AXIS] = LOGICAL_Y_POSITION(cartes[Y_AXIS]);
-      destination[Z_AXIS] = current_position[Z_AXIS];
-      prepare_move_to_destination();
-      return true;
-    }
-    return false;
-  }
-
-  /**
-   * M360: SCARA calibration: Move to cal-position ThetaA (0 deg calibration)
-   */
-  inline bool gcode_M360() {
-    SERIAL_ECHOLNPGM(" Cal: Theta 0");
-    return SCARA_move_to_cal(0, 120);
-  }
-
-  /**
-   * M361: SCARA calibration: Move to cal-position ThetaB (90 deg calibration - steps per degree)
-   */
-  inline bool gcode_M361() {
-    SERIAL_ECHOLNPGM(" Cal: Theta 90");
-    return SCARA_move_to_cal(90, 130);
-  }
-
-  /**
-   * M362: SCARA calibration: Move to cal-position PsiA (0 deg calibration)
-   */
-  inline bool gcode_M362() {
-    SERIAL_ECHOLNPGM(" Cal: Psi 0");
-    return SCARA_move_to_cal(60, 180);
-  }
-
-  /**
-   * M363: SCARA calibration: Move to cal-position PsiB (90 deg calibration - steps per degree)
-   */
-  inline bool gcode_M363() {
-    SERIAL_ECHOLNPGM(" Cal: Psi 90");
-    return SCARA_move_to_cal(50, 90);
-  }
-
-  /**
-   * M364: SCARA calibration: Move to cal-position PsiC (90 deg to Theta calibration position)
-   */
-  inline bool gcode_M364() {
-    SERIAL_ECHOLNPGM(" Cal: Theta-Psi 90");
-    return SCARA_move_to_cal(45, 135);
-  }
-
-#endif // SCARA
-
-#if ENABLED(EXT_SOLENOID)
-
-  void enable_solenoid(const uint8_t num) {
-    switch (num) {
-      case 0:
-        OUT_WRITE(SOL0_PIN, HIGH);
-        break;
-        #if HAS_SOLENOID_1 && EXTRUDERS > 1
-          case 1:
-            OUT_WRITE(SOL1_PIN, HIGH);
-            break;
-        #endif
-        #if HAS_SOLENOID_2 && EXTRUDERS > 2
-          case 2:
-            OUT_WRITE(SOL2_PIN, HIGH);
-            break;
-        #endif
-        #if HAS_SOLENOID_3 && EXTRUDERS > 3
-          case 3:
-            OUT_WRITE(SOL3_PIN, HIGH);
-            break;
-        #endif
-        #if HAS_SOLENOID_4 && EXTRUDERS > 4
-          case 4:
-            OUT_WRITE(SOL4_PIN, HIGH);
-            break;
-        #endif
-      default:
-        SERIAL_ECHO_START();
-        SERIAL_ECHOLNPGM(MSG_INVALID_SOLENOID);
-        break;
-    }
-  }
-
-  void enable_solenoid_on_active_extruder() { enable_solenoid(active_extruder); }
-
-  void disable_all_solenoids() {
-    OUT_WRITE(SOL0_PIN, LOW);
-    #if HAS_SOLENOID_1 && EXTRUDERS > 1
-      OUT_WRITE(SOL1_PIN, LOW);
-    #endif
-    #if HAS_SOLENOID_2 && EXTRUDERS > 2
-      OUT_WRITE(SOL2_PIN, LOW);
-    #endif
-    #if HAS_SOLENOID_3 && EXTRUDERS > 3
-      OUT_WRITE(SOL3_PIN, LOW);
-    #endif
-    #if HAS_SOLENOID_4 && EXTRUDERS > 4
-      OUT_WRITE(SOL4_PIN, LOW);
-    #endif
-  }
-
-  /**
-   * M380: Enable solenoid on the active extruder
-   */
-  inline void gcode_M380() { enable_solenoid_on_active_extruder(); }
-
-  /**
-   * M381: Disable all solenoids
-   */
-  inline void gcode_M381() { disable_all_solenoids(); }
-
-#endif // EXT_SOLENOID
-
-/**
- * M400: Finish all moves
- */
-inline void gcode_M400() { stepper.synchronize(); }
-
-#if HAS_BED_PROBE
-
-  /**
-   * M401: Engage Z Servo endstop if available
-   */
-  inline void gcode_M401() { DEPLOY_PROBE(); }
-
-  /**
-   * M402: Retract Z Servo endstop if enabled
-   */
-  inline void gcode_M402() { STOW_PROBE(); }
-
-#endif // HAS_BED_PROBE
-
-#if ENABLED(FILAMENT_WIDTH_SENSOR)
-
-  /**
-   * M404: Display or set (in current units) the nominal filament width (3mm, 1.75mm ) W<3.0>
-   */
-  inline void gcode_M404() {
-    if (parser.seen('W')) {
-      filament_width_nominal = parser.value_linear_units();
-    }
-    else {
-      SERIAL_PROTOCOLPGM("Filament dia (nominal mm):");
-      SERIAL_PROTOCOLLN(filament_width_nominal);
-    }
-  }
-
-  /**
-   * M405: Turn on filament sensor for control
-   */
-  inline void gcode_M405() {
-    // This is technically a linear measurement, but since it's quantized to centimeters and is a different
-    // unit than everything else, it uses parser.value_byte() instead of parser.value_linear_units().
-    if (parser.seen('D')) {
-      meas_delay_cm = parser.value_byte();
-      NOMORE(meas_delay_cm, MAX_MEASUREMENT_DELAY);
-    }
-
-    if (filwidth_delay_index[1] == -1) { // Initialize the ring buffer if not done since startup
-      const uint8_t temp_ratio = thermalManager.widthFil_to_size_ratio() - 100; // -100 to scale within a signed byte
-
-      for (uint8_t i = 0; i < COUNT(measurement_delay); ++i)
-        measurement_delay[i] = temp_ratio;
-
-      filwidth_delay_index[0] = filwidth_delay_index[1] = 0;
-    }
-
-    filament_sensor = true;
-
-    //SERIAL_PROTOCOLPGM("Filament dia (measured mm):");
-    //SERIAL_PROTOCOL(filament_width_meas);
-    //SERIAL_PROTOCOLPGM("Extrusion ratio(%):");
-    //SERIAL_PROTOCOL(flow_percentage[active_extruder]);
-  }
-
-  /**
-   * M406: Turn off filament sensor for control
-   */
-  inline void gcode_M406() {
-    filament_sensor = false;
-    calculate_volumetric_multipliers();   // Restore correct 'volumetric_multiplier' value
-  }
-
-  /**
-   * M407: Get measured filament diameter on serial output
-   */
-  inline void gcode_M407() {
-    SERIAL_PROTOCOLPGM("Filament dia (measured mm):");
-    SERIAL_PROTOCOLLN(filament_width_meas);
-  }
-
-#endif // FILAMENT_WIDTH_SENSOR
-
-void quickstop_stepper() {
-  stepper.quick_stop();
-  stepper.synchronize();
-  set_current_from_steppers_for_axis(ALL_AXES);
-  SYNC_PLAN_POSITION_KINEMATIC();
-}
-
-#if HAS_LEVELING
-  /**
-   * M420: Enable/Disable Bed Leveling and/or set the Z fade height.
-   *
-   *   S[bool]   Turns leveling on or off
-   *   Z[height] Sets the Z fade height (0 or none to disable)
-   *   V[bool]   Verbose - Print the leveling grid
-   *
-   * With AUTO_BED_LEVELING_UBL only:
-   *
-   *   L[index]  Load UBL mesh from index (0 is default)
-   */
-  inline void gcode_M420() {
-
-    #if ENABLED(AUTO_BED_LEVELING_UBL)
-
-      // L to load a mesh from the EEPROM
-      if (parser.seen('L')) {
-
-        #if ENABLED(EEPROM_SETTINGS)
-          const int8_t storage_slot = parser.has_value() ? parser.value_int() : ubl.state.storage_slot;
-          const int16_t a = settings.calc_num_meshes();
-
-          if (!a) {
-            SERIAL_PROTOCOLLNPGM("?EEPROM storage not available.");
-            return;
-          }
-
-          if (!WITHIN(storage_slot, 0, a - 1)) {
-            SERIAL_PROTOCOLLNPGM("?Invalid storage slot.");
-            SERIAL_PROTOCOLLNPAIR("?Use 0 to ", a - 1);
-            return;
-          }
-
-          settings.load_mesh(storage_slot);
-          ubl.state.storage_slot = storage_slot;
-
-        #else
-
-          SERIAL_PROTOCOLLNPGM("?EEPROM storage not available.");
-          return;
-
-        #endif
-      }
-
-      // L to load a mesh from the EEPROM
-      if (parser.seen('L') || parser.seen('V')) {
-        ubl.display_map(0);  // Currently only supports one map type
-        SERIAL_ECHOLNPAIR("UBL_MESH_VALID = ", UBL_MESH_VALID);
-        SERIAL_ECHOLNPAIR("ubl.state.storage_slot = ", ubl.state.storage_slot);
-      }
-
-    #endif // AUTO_BED_LEVELING_UBL
-
-    // V to print the matrix or mesh
-    if (parser.seen('V')) {
-      #if ABL_PLANAR
-        planner.bed_level_matrix.debug(PSTR("Bed Level Correction Matrix:"));
-      #else
-        if (leveling_is_valid()) {
-          #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
-            print_bilinear_leveling_grid();
-            #if ENABLED(ABL_BILINEAR_SUBDIVISION)
-              print_bilinear_leveling_grid_virt();
-            #endif
-          #elif ENABLED(MESH_BED_LEVELING)
-            SERIAL_ECHOLNPGM("Mesh Bed Level data:");
-            mbl_mesh_report();
-          #endif
-        }
-      #endif
-    }
-
-    const bool to_enable = parser.boolval('S');
-    if (parser.seen('S'))
-      set_bed_leveling_enabled(to_enable);
-
-    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-      if (parser.seen('Z')) set_z_fade_height(parser.value_linear_units());
-    #endif
-
-    const bool new_status = leveling_is_active();
-
-    if (to_enable && !new_status) {
-      SERIAL_ERROR_START();
-      SERIAL_ERRORLNPGM(MSG_ERR_M420_FAILED);
-    }
-
-    SERIAL_ECHO_START();
-    SERIAL_ECHOLNPAIR("Bed Leveling ", new_status ? MSG_ON : MSG_OFF);
-
-    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-      SERIAL_ECHO_START();
-      SERIAL_ECHOPGM("Fade Height ");
-      if (planner.z_fade_height > 0.0)
-        SERIAL_ECHOLN(planner.z_fade_height);
-      else
-        SERIAL_ECHOLNPGM(MSG_OFF);
-    #endif
-  }
-#endif
-
-#if ENABLED(MESH_BED_LEVELING)
-
-  /**
-   * M421: Set a single Mesh Bed Leveling Z coordinate
-   *
-   * Usage:
-   *   M421 X<linear> Y<linear> Z<linear>
-   *   M421 X<linear> Y<linear> Q<offset>
-   *   M421 I<xindex> J<yindex> Z<linear>
-   *   M421 I<xindex> J<yindex> Q<offset>
-   */
-  inline void gcode_M421() {
-    const bool hasX = parser.seen('X'), hasI = parser.seen('I');
-    const int8_t ix = hasI ? parser.value_int() : hasX ? mbl.probe_index_x(RAW_X_POSITION(parser.value_linear_units())) : -1;
-    const bool hasY = parser.seen('Y'), hasJ = parser.seen('J');
-    const int8_t iy = hasJ ? parser.value_int() : hasY ? mbl.probe_index_y(RAW_Y_POSITION(parser.value_linear_units())) : -1;
-    const bool hasZ = parser.seen('Z'), hasQ = !hasZ && parser.seen('Q');
-
-    if (int(hasI && hasJ) + int(hasX && hasY) != 1 || !(hasZ || hasQ)) {
-      SERIAL_ERROR_START();
-      SERIAL_ERRORLNPGM(MSG_ERR_M421_PARAMETERS);
-    }
-    else if (ix < 0 || iy < 0) {
-      SERIAL_ERROR_START();
-      SERIAL_ERRORLNPGM(MSG_ERR_MESH_XY);
-    }
-    else
-      mbl.set_z(ix, iy, parser.value_linear_units() + (hasQ ? mbl.z_values[ix][iy] : 0));
-  }
-
-#elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
-
-  /**
-   * M421: Set a single Mesh Bed Leveling Z coordinate
-   *
-   * Usage:
-   *   M421 I<xindex> J<yindex> Z<linear>
-   *   M421 I<xindex> J<yindex> Q<offset>
-   */
-  inline void gcode_M421() {
-    int8_t ix = parser.intval('I', -1), iy = parser.intval('J', -1);
-    const bool hasI = ix >= 0,
-               hasJ = iy >= 0,
-               hasZ = parser.seen('Z'),
-               hasQ = !hasZ && parser.seen('Q');
-
-    if (!hasI || !hasJ || !(hasZ || hasQ)) {
-      SERIAL_ERROR_START();
-      SERIAL_ERRORLNPGM(MSG_ERR_M421_PARAMETERS);
-    }
-    else if (!WITHIN(ix, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(iy, 0, GRID_MAX_POINTS_Y - 1)) {
-      SERIAL_ERROR_START();
-      SERIAL_ERRORLNPGM(MSG_ERR_MESH_XY);
-    }
-    else {
-      z_values[ix][iy] = parser.value_linear_units() + (hasQ ? z_values[ix][iy] : 0);
-      #if ENABLED(ABL_BILINEAR_SUBDIVISION)
-        bed_level_virt_interpolate();
-      #endif
-    }
-  }
-
-#elif ENABLED(AUTO_BED_LEVELING_UBL)
-
-  /**
-   * M421: Set a single Mesh Bed Leveling Z coordinate
-   *
-   * Usage:
-   *   M421 I<xindex> J<yindex> Z<linear>
-   *   M421 I<xindex> J<yindex> Q<offset>
-   *   M421 C Z<linear>
-   *   M421 C Q<offset>
-   */
-  inline void gcode_M421() {
-    int8_t ix = parser.intval('I', -1), iy = parser.intval('J', -1);
-    const bool hasI = ix >= 0,
-               hasJ = iy >= 0,
-               hasC = parser.seen('C'),
-               hasZ = parser.seen('Z'),
-               hasQ = !hasZ && parser.seen('Q');
-
-    if (hasC) {
-      const mesh_index_pair location = ubl.find_closest_mesh_point_of_type(REAL, current_position[X_AXIS], current_position[Y_AXIS], USE_NOZZLE_AS_REFERENCE, NULL, false);
-      ix = location.x_index;
-      iy = location.y_index;
-    }
-
-    if (int(hasC) + int(hasI && hasJ) != 1 || !(hasZ || hasQ)) {
-      SERIAL_ERROR_START();
-      SERIAL_ERRORLNPGM(MSG_ERR_M421_PARAMETERS);
-    }
-    else if (!WITHIN(ix, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(iy, 0, GRID_MAX_POINTS_Y - 1)) {
-      SERIAL_ERROR_START();
-      SERIAL_ERRORLNPGM(MSG_ERR_MESH_XY);
-    }
-    else
-      ubl.z_values[ix][iy] = parser.value_linear_units() + (hasQ ? ubl.z_values[ix][iy] : 0);
-  }
-
-#endif // AUTO_BED_LEVELING_UBL
-
-#if HAS_M206_COMMAND
-
-  /**
-   * M428: Set home_offset based on the distance between the
-   *       current_position and the nearest "reference point."
-   *       If an axis is past center its endstop position
-   *       is the reference-point. Otherwise it uses 0. This allows
-   *       the Z offset to be set near the bed when using a max endstop.
-   *
-   *       M428 can't be used more than 2cm away from 0 or an endstop.
-   *
-   *       Use M206 to set these values directly.
-   */
-  inline void gcode_M428() {
-    bool err = false;
-    LOOP_XYZ(i) {
-      if (axis_homed[i]) {
-        const float base = (current_position[i] > (soft_endstop_min[i] + soft_endstop_max[i]) * 0.5) ? base_home_pos((AxisEnum)i) : 0,
-                    diff = base - RAW_POSITION(current_position[i], i);
-        if (WITHIN(diff, -20, 20)) {
-          set_home_offset((AxisEnum)i, diff);
-        }
-        else {
-          SERIAL_ERROR_START();
-          SERIAL_ERRORLNPGM(MSG_ERR_M428_TOO_FAR);
-          LCD_ALERTMESSAGEPGM("Err: Too far!");
-          BUZZ(200, 40);
-          err = true;
-          break;
-        }
-      }
-    }
-
-    if (!err) {
-      SYNC_PLAN_POSITION_KINEMATIC();
-      report_current_position();
-      LCD_MESSAGEPGM(MSG_HOME_OFFSETS_APPLIED);
-      BUZZ(100, 659);
-      BUZZ(100, 698);
-    }
-  }
-
-#endif // HAS_M206_COMMAND
-
-/**
- * M500: Store settings in EEPROM
- */
-inline void gcode_M500() {
-  (void)settings.save();
-}
-
-/**
- * M501: Read settings from EEPROM
- */
-inline void gcode_M501() {
-  (void)settings.load();
-}
-
-/**
- * M502: Revert to default settings
- */
-inline void gcode_M502() {
-  (void)settings.reset();
-}
-
-#if DISABLED(DISABLE_M503)
-  /**
-   * M503: print settings currently in memory
-   */
-  inline void gcode_M503() {
-    (void)settings.report(!parser.boolval('S', true));
-  }
-#endif
-
-#if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
-
-  /**
-   * M540: Set whether SD card print should abort on endstop hit (M540 S<0|1>)
-   */
-  inline void gcode_M540() {
-    if (parser.seen('S')) stepper.abort_on_endstop_hit = parser.value_bool();
-  }
-
-#endif // ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED
-
-#if HAS_BED_PROBE
-
-  void refresh_zprobe_zoffset(const bool no_babystep/*=false*/) {
-    static float last_zoffset = NAN;
-
-    if (!isnan(last_zoffset)) {
-
-      #if ENABLED(AUTO_BED_LEVELING_BILINEAR) || ENABLED(BABYSTEP_ZPROBE_OFFSET) || ENABLED(DELTA)
-        const float diff = zprobe_zoffset - last_zoffset;
-      #endif
-
-      #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
-        // Correct bilinear grid for new probe offset
-        if (diff) {
-          for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
-            for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
-              z_values[x][y] -= diff;
-        }
-        #if ENABLED(ABL_BILINEAR_SUBDIVISION)
-          bed_level_virt_interpolate();
-        #endif
-      #endif
-
-      #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
-        if (!no_babystep && leveling_is_active())
-          thermalManager.babystep_axis(Z_AXIS, -LROUND(diff * planner.axis_steps_per_mm[Z_AXIS]));
-      #else
-        UNUSED(no_babystep);
-      #endif
-
-      #if ENABLED(DELTA) // correct the delta_height
-        home_offset[Z_AXIS] -= diff;
-      #endif
-    }
-
-    last_zoffset = zprobe_zoffset;
-  }
-
-  inline void gcode_M851() {
-    SERIAL_ECHO_START();
-    SERIAL_ECHOPGM(MSG_ZPROBE_ZOFFSET " ");
-    if (parser.seen('Z')) {
-      const float value = parser.value_linear_units();
-      if (WITHIN(value, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
-        zprobe_zoffset = value;
-        refresh_zprobe_zoffset();
-        SERIAL_ECHO(zprobe_zoffset);
-      }
-      else
-        SERIAL_ECHOPGM(MSG_Z_MIN " " STRINGIFY(Z_PROBE_OFFSET_RANGE_MIN) " " MSG_Z_MAX " " STRINGIFY(Z_PROBE_OFFSET_RANGE_MAX));
-    }
-    else
-      SERIAL_ECHOPAIR(": ", zprobe_zoffset);
-
-    SERIAL_EOL();
-  }
-
-#endif // HAS_BED_PROBE
-
-#if ENABLED(ADVANCED_PAUSE_FEATURE)
-
-  /**
-   * M600: Pause for filament change
-   *
-   *  E[distance] - Retract the filament this far (negative value)
-   *  Z[distance] - Move the Z axis by this distance
-   *  X[position] - Move to this X position, with Y
-   *  Y[position] - Move to this Y position, with X
-   *  U[distance] - Retract distance for removal (negative value) (manual reload)
-   *  L[distance] - Extrude distance for insertion (positive value) (manual reload)
-   *  B[count]    - Number of times to beep, -1 for indefinite (if equipped with a buzzer)
-   *
-   *  Default values are used for omitted arguments.
-   *
-   */
-  inline void gcode_M600() {
-
-    #if ENABLED(HOME_BEFORE_FILAMENT_CHANGE)
-      // Don't allow filament change without homing first
-      if (axis_unhomed_error()) home_all_axes();
-    #endif
-
-    // Initial retract before move to filament change position
-    const float retract = parser.seen('E') ? parser.value_axis_units(E_AXIS) : 0
-      #ifdef PAUSE_PARK_RETRACT_LENGTH
-        - (PAUSE_PARK_RETRACT_LENGTH)
-      #endif
-    ;
-
-    // Lift Z axis
-    const float z_lift = parser.linearval('Z', 0
-      #ifdef PAUSE_PARK_Z_ADD
-        + PAUSE_PARK_Z_ADD
-      #endif
-    );
-
-    // Move XY axes to filament exchange position
-    const float x_pos = parser.linearval('X', 0
-      #ifdef PAUSE_PARK_X_POS
-        + PAUSE_PARK_X_POS
-      #endif
-    );
-    const float y_pos = parser.linearval('Y', 0
-      #ifdef PAUSE_PARK_Y_POS
-        + PAUSE_PARK_Y_POS
-      #endif
-    );
-
-    // Unload filament
-    const float unload_length = parser.seen('U') ? parser.value_axis_units(E_AXIS) : 0
-      #if defined(FILAMENT_CHANGE_UNLOAD_LENGTH) && FILAMENT_CHANGE_UNLOAD_LENGTH > 0
-        - (FILAMENT_CHANGE_UNLOAD_LENGTH)
-      #endif
-    ;
-
-    // Load filament
-    const float load_length = parser.seen('L') ? parser.value_axis_units(E_AXIS) : 0
-      #ifdef FILAMENT_CHANGE_LOAD_LENGTH
-        + FILAMENT_CHANGE_LOAD_LENGTH
-      #endif
-    ;
-
-    const int beep_count = parser.intval('B',
-      #ifdef FILAMENT_CHANGE_NUMBER_OF_ALERT_BEEPS
-        FILAMENT_CHANGE_NUMBER_OF_ALERT_BEEPS
-      #else
-        -1
-      #endif
-    );
-
-    const bool job_running = print_job_timer.isRunning();
-
-    if (pause_print(retract, z_lift, x_pos, y_pos, unload_length, beep_count, true)) {
-      wait_for_filament_reload(beep_count);
-      resume_print(load_length, ADVANCED_PAUSE_EXTRUDE_LENGTH, beep_count);
-    }
-
-    // Resume the print job timer if it was running
-    if (job_running) print_job_timer.start();
-  }
-
-#endif // ADVANCED_PAUSE_FEATURE
-
-#if ENABLED(MK2_MULTIPLEXER)
-
-  inline void select_multiplexed_stepper(const uint8_t e) {
-    stepper.synchronize();
-    disable_e_steppers();
-    WRITE(E_MUX0_PIN, TEST(e, 0) ? HIGH : LOW);
-    WRITE(E_MUX1_PIN, TEST(e, 1) ? HIGH : LOW);
-    WRITE(E_MUX2_PIN, TEST(e, 2) ? HIGH : LOW);
-    safe_delay(100);
-  }
-
-  /**
-   * M702: Unload all extruders
-   */
-  inline void gcode_M702() {
-    for (uint8_t s = 0; s < E_STEPPERS; s++) {
-      select_multiplexed_stepper(e);
-      // TODO: standard unload filament function
-      // MK2 firmware behavior:
-      //  - Make sure temperature is high enough
-      //  - Raise Z to at least 15 to make room
-      //  - Extrude 1cm of filament in 1 second
-      //  - Under 230C quickly purge ~12mm, over 230C purge ~10mm
-      //  - Change E max feedrate to 80, eject the filament from the tube. Sync.
-      //  - Restore E max feedrate to 50
-    }
-    // Go back to the last active extruder
-    select_multiplexed_stepper(active_extruder);
-    disable_e_steppers();
-  }
-
-#endif // MK2_MULTIPLEXER
-
-#if ENABLED(DUAL_X_CARRIAGE)
-
-  /**
-   * M605: Set dual x-carriage movement mode
-   *
-   *    M605 S0: Full control mode. The slicer has full control over x-carriage movement
-   *    M605 S1: Auto-park mode. The inactive head will auto park/unpark without slicer involvement
-   *    M605 S2 [Xnnn] [Rmmm]: Duplication mode. The second extruder will duplicate the first with nnn
-   *                         units x-offset and an optional differential hotend temperature of
-   *                         mmm degrees. E.g., with "M605 S2 X100 R2" the second extruder will duplicate
-   *                         the first with a spacing of 100mm in the x direction and 2 degrees hotter.
-   *
-   *    Note: the X axis should be homed after changing dual x-carriage mode.
-   */
-  inline void gcode_M605() {
-    stepper.synchronize();
-    if (parser.seen('S')) dual_x_carriage_mode = (DualXMode)parser.value_byte();
-    switch (dual_x_carriage_mode) {
-      case DXC_FULL_CONTROL_MODE:
-      case DXC_AUTO_PARK_MODE:
-        break;
-      case DXC_DUPLICATION_MODE:
-        if (parser.seen('X')) duplicate_extruder_x_offset = max(parser.value_linear_units(), X2_MIN_POS - x_home_pos(0));
-        if (parser.seen('R')) duplicate_extruder_temp_offset = parser.value_celsius_diff();
-        SERIAL_ECHO_START();
-        SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);
-        SERIAL_CHAR(' ');
-        SERIAL_ECHO(hotend_offset[X_AXIS][0]);
-        SERIAL_CHAR(',');
-        SERIAL_ECHO(hotend_offset[Y_AXIS][0]);
-        SERIAL_CHAR(' ');
-        SERIAL_ECHO(duplicate_extruder_x_offset);
-        SERIAL_CHAR(',');
-        SERIAL_ECHOLN(hotend_offset[Y_AXIS][1]);
-        break;
-      default:
-        dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
-        break;
-    }
-    active_extruder_parked = false;
-    extruder_duplication_enabled = false;
-    delayed_move_time = 0;
-  }
-
-#elif ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
-
-  inline void gcode_M605() {
-    stepper.synchronize();
-    extruder_duplication_enabled = parser.intval('S') == (int)DXC_DUPLICATION_MODE;
-    SERIAL_ECHO_START();
-    SERIAL_ECHOLNPAIR(MSG_DUPLICATION_MODE, extruder_duplication_enabled ? MSG_ON : MSG_OFF);
-  }
-
-#endif // DUAL_NOZZLE_DUPLICATION_MODE
-
-#if ENABLED(LIN_ADVANCE)
-  /**
-   * M900: Set and/or Get advance K factor and WH/D ratio
-   *
-   *  K<factor>                  Set advance K factor
-   *  R<ratio>                   Set ratio directly (overrides WH/D)
-   *  W<width> H<height> D<diam> Set ratio from WH/D
-   */
-  inline void gcode_M900() {
-    stepper.synchronize();
-
-    const float newK = parser.floatval('K', -1);
-    if (newK >= 0) planner.extruder_advance_k = newK;
-
-    float newR = parser.floatval('R', -1);
-    if (newR < 0) {
-      const float newD = parser.floatval('D', -1),
-                  newW = parser.floatval('W', -1),
-                  newH = parser.floatval('H', -1);
-      if (newD >= 0 && newW >= 0 && newH >= 0)
-        newR = newD ? (newW * newH) / (sq(newD * 0.5) * M_PI) : 0;
-    }
-    if (newR >= 0) planner.advance_ed_ratio = newR;
-
-    SERIAL_ECHO_START();
-    SERIAL_ECHOPAIR("Advance K=", planner.extruder_advance_k);
-    SERIAL_ECHOPGM(" E/D=");
-    const float ratio = planner.advance_ed_ratio;
-    if (ratio) SERIAL_ECHO(ratio); else SERIAL_ECHOPGM("Auto");
-    SERIAL_EOL();
-  }
-#endif // LIN_ADVANCE
-
-#if ENABLED(HAVE_TMC2130)
-
-  static void tmc2130_get_current(TMC2130Stepper &st, const char name) {
-    SERIAL_CHAR(name);
-    SERIAL_ECHOPGM(" axis driver current: ");
-    SERIAL_ECHOLN(st.getCurrent());
-  }
-  static void tmc2130_set_current(TMC2130Stepper &st, const char name, const int mA) {
-    st.setCurrent(mA, R_SENSE, HOLD_MULTIPLIER);
-    tmc2130_get_current(st, name);
-  }
-
-  static void tmc2130_report_otpw(TMC2130Stepper &st, const char name) {
-    SERIAL_CHAR(name);
-    SERIAL_ECHOPGM(" axis temperature prewarn triggered: ");
-    serialprintPGM(st.getOTPW() ? PSTR("true") : PSTR("false"));
-    SERIAL_EOL();
-  }
-  static void tmc2130_clear_otpw(TMC2130Stepper &st, const char name) {
-    st.clear_otpw();
-    SERIAL_CHAR(name);
-    SERIAL_ECHOLNPGM(" prewarn flag cleared");
-  }
-
-  static void tmc2130_get_pwmthrs(TMC2130Stepper &st, const char name, const uint16_t spmm) {
-    SERIAL_CHAR(name);
-    SERIAL_ECHOPGM(" stealthChop max speed set to ");
-    SERIAL_ECHOLN(12650000UL * st.microsteps() / (256 * st.stealth_max_speed() * spmm));
-  }
-  static void tmc2130_set_pwmthrs(TMC2130Stepper &st, const char name, const int32_t thrs, const uint32_t spmm) {
-    st.stealth_max_speed(12650000UL * st.microsteps() / (256 * thrs * spmm));
-    tmc2130_get_pwmthrs(st, name, spmm);
-  }
-
-  static void tmc2130_get_sgt(TMC2130Stepper &st, const char name) {
-    SERIAL_CHAR(name);
-    SERIAL_ECHOPGM(" driver homing sensitivity set to ");
-    SERIAL_ECHOLN(st.sgt());
-  }
-  static void tmc2130_set_sgt(TMC2130Stepper &st, const char name, const int8_t sgt_val) {
-    st.sgt(sgt_val);
-    tmc2130_get_sgt(st, name);
-  }
-
-  /**
-   * M906: Set motor current in milliamps using axis codes X, Y, Z, E
-   * Report driver currents when no axis specified
-   *
-   * S1: Enable automatic current control
-   * S0: Disable
-   */
-  inline void gcode_M906() {
-    uint16_t values[XYZE];
-    LOOP_XYZE(i)
-      values[i] = parser.intval(axis_codes[i]);
-
-    #if ENABLED(X_IS_TMC2130)
-      if (values[X_AXIS]) tmc2130_set_current(stepperX, 'X', values[X_AXIS]);
-      else tmc2130_get_current(stepperX, 'X');
-    #endif
-    #if ENABLED(Y_IS_TMC2130)
-      if (values[Y_AXIS]) tmc2130_set_current(stepperY, 'Y', values[Y_AXIS]);
-      else tmc2130_get_current(stepperY, 'Y');
-    #endif
-    #if ENABLED(Z_IS_TMC2130)
-      if (values[Z_AXIS]) tmc2130_set_current(stepperZ, 'Z', values[Z_AXIS]);
-      else tmc2130_get_current(stepperZ, 'Z');
-    #endif
-    #if ENABLED(E0_IS_TMC2130)
-      if (values[E_AXIS]) tmc2130_set_current(stepperE0, 'E', values[E_AXIS]);
-      else tmc2130_get_current(stepperE0, 'E');
-    #endif
-
-    #if ENABLED(AUTOMATIC_CURRENT_CONTROL)
-      if (parser.seen('S')) auto_current_control = parser.value_bool();
-    #endif
-  }
-
-  /**
-   * M911: Report TMC2130 stepper driver overtemperature pre-warn flag
-   * The flag is held by the library and persist until manually cleared by M912
-   */
-  inline void gcode_M911() {
-    const bool reportX = parser.seen('X'), reportY = parser.seen('Y'), reportZ = parser.seen('Z'), reportE = parser.seen('E'),
-             reportAll = (!reportX && !reportY && !reportZ && !reportE) || (reportX && reportY && reportZ && reportE);
-    #if ENABLED(X_IS_TMC2130)
-      if (reportX || reportAll) tmc2130_report_otpw(stepperX, 'X');
-    #endif
-    #if ENABLED(Y_IS_TMC2130)
-      if (reportY || reportAll) tmc2130_report_otpw(stepperY, 'Y');
-    #endif
-    #if ENABLED(Z_IS_TMC2130)
-      if (reportZ || reportAll) tmc2130_report_otpw(stepperZ, 'Z');
-    #endif
-    #if ENABLED(E0_IS_TMC2130)
-      if (reportE || reportAll) tmc2130_report_otpw(stepperE0, 'E');
-    #endif
-  }
-
-  /**
-   * M912: Clear TMC2130 stepper driver overtemperature pre-warn flag held by the library
-   */
-  inline void gcode_M912() {
-    const bool clearX = parser.seen('X'), clearY = parser.seen('Y'), clearZ = parser.seen('Z'), clearE = parser.seen('E'),
-             clearAll = (!clearX && !clearY && !clearZ && !clearE) || (clearX && clearY && clearZ && clearE);
-    #if ENABLED(X_IS_TMC2130)
-      if (clearX || clearAll) tmc2130_clear_otpw(stepperX, 'X');
-    #endif
-    #if ENABLED(Y_IS_TMC2130)
-      if (clearY || clearAll) tmc2130_clear_otpw(stepperY, 'Y');
-    #endif
-    #if ENABLED(Z_IS_TMC2130)
-      if (clearZ || clearAll) tmc2130_clear_otpw(stepperZ, 'Z');
-    #endif
-    #if ENABLED(E0_IS_TMC2130)
-      if (clearE || clearAll) tmc2130_clear_otpw(stepperE0, 'E');
-    #endif
-  }
-
-  /**
-   * M913: Set HYBRID_THRESHOLD speed.
-   */
-  #if ENABLED(HYBRID_THRESHOLD)
-    inline void gcode_M913() {
-      uint16_t values[XYZE];
-      LOOP_XYZE(i)
-        values[i] = parser.intval(axis_codes[i]);
-
-      #if ENABLED(X_IS_TMC2130)
-        if (values[X_AXIS]) tmc2130_set_pwmthrs(stepperX, 'X', values[X_AXIS], planner.axis_steps_per_mm[X_AXIS]);
-        else tmc2130_get_pwmthrs(stepperX, 'X', planner.axis_steps_per_mm[X_AXIS]);
-      #endif
-      #if ENABLED(Y_IS_TMC2130)
-        if (values[Y_AXIS]) tmc2130_set_pwmthrs(stepperY, 'Y', values[Y_AXIS], planner.axis_steps_per_mm[Y_AXIS]);
-        else tmc2130_get_pwmthrs(stepperY, 'Y', planner.axis_steps_per_mm[Y_AXIS]);
-      #endif
-      #if ENABLED(Z_IS_TMC2130)
-        if (values[Z_AXIS]) tmc2130_set_pwmthrs(stepperZ, 'Z', values[Z_AXIS], planner.axis_steps_per_mm[Z_AXIS]);
-        else tmc2130_get_pwmthrs(stepperZ, 'Z', planner.axis_steps_per_mm[Z_AXIS]);
-      #endif
-      #if ENABLED(E0_IS_TMC2130)
-        if (values[E_AXIS]) tmc2130_set_pwmthrs(stepperE0, 'E', values[E_AXIS], planner.axis_steps_per_mm[E_AXIS]);
-        else tmc2130_get_pwmthrs(stepperE0, 'E', planner.axis_steps_per_mm[E_AXIS]);
-      #endif
-    }
-  #endif // HYBRID_THRESHOLD
-
-  /**
-   * M914: Set SENSORLESS_HOMING sensitivity.
-   */
-  #if ENABLED(SENSORLESS_HOMING)
-    inline void gcode_M914() {
-      #if ENABLED(X_IS_TMC2130)
-        if (parser.seen(axis_codes[X_AXIS])) tmc2130_set_sgt(stepperX, 'X', parser.value_int());
-        else tmc2130_get_sgt(stepperX, 'X');
-      #endif
-      #if ENABLED(Y_IS_TMC2130)
-        if (parser.seen(axis_codes[Y_AXIS])) tmc2130_set_sgt(stepperY, 'Y', parser.value_int());
-        else tmc2130_get_sgt(stepperY, 'Y');
-      #endif
-    }
-  #endif // SENSORLESS_HOMING
-
-#endif // HAVE_TMC2130
-
-/**
- * M907: Set digital trimpot motor current using axis codes X, Y, Z, E, B, S
- */
-inline void gcode_M907() {
-  #if HAS_DIGIPOTSS
-
-    LOOP_XYZE(i) if (parser.seen(axis_codes[i])) stepper.digipot_current(i, parser.value_int());
-    if (parser.seen('B')) stepper.digipot_current(4, parser.value_int());
-    if (parser.seen('S')) for (uint8_t i = 0; i <= 4; i++) stepper.digipot_current(i, parser.value_int());
-
-  #elif HAS_MOTOR_CURRENT_PWM
-
-    #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
-      if (parser.seen('X')) stepper.digipot_current(0, parser.value_int());
-    #endif
-    #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
-      if (parser.seen('Z')) stepper.digipot_current(1, parser.value_int());
-    #endif
-    #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
-      if (parser.seen('E')) stepper.digipot_current(2, parser.value_int());
-    #endif
-
-  #endif
-
-  #if ENABLED(DIGIPOT_I2C)
-    // this one uses actual amps in floating point
-    LOOP_XYZE(i) if (parser.seen(axis_codes[i])) digipot_i2c_set_current(i, parser.value_float());
-    // for each additional extruder (named B,C,D,E..., channels 4,5,6,7...)
-    for (uint8_t i = NUM_AXIS; i < DIGIPOT_I2C_NUM_CHANNELS; i++) if (parser.seen('B' + i - (NUM_AXIS))) digipot_i2c_set_current(i, parser.value_float());
-  #endif
-
-  #if ENABLED(DAC_STEPPER_CURRENT)
-    if (parser.seen('S')) {
-      const float dac_percent = parser.value_float();
-      for (uint8_t i = 0; i <= 4; i++) dac_current_percent(i, dac_percent);
-    }
-    LOOP_XYZE(i) if (parser.seen(axis_codes[i])) dac_current_percent(i, parser.value_float());
-  #endif
-}
-
-#if HAS_DIGIPOTSS || ENABLED(DAC_STEPPER_CURRENT)
-
-  /**
-   * M908: Control digital trimpot directly (M908 P<pin> S<current>)
-   */
-  inline void gcode_M908() {
-    #if HAS_DIGIPOTSS
-      stepper.digitalPotWrite(
-        parser.intval('P'),
-        parser.intval('S')
-      );
-    #endif
-    #ifdef DAC_STEPPER_CURRENT
-      dac_current_raw(
-        parser.byteval('P', -1),
-        parser.ushortval('S', 0)
-      );
-    #endif
-  }
-
-  #if ENABLED(DAC_STEPPER_CURRENT) // As with Printrbot RevF
-
-    inline void gcode_M909() { dac_print_values(); }
-
-    inline void gcode_M910() { dac_commit_eeprom(); }
-
-  #endif
-
-#endif // HAS_DIGIPOTSS || DAC_STEPPER_CURRENT
-
-#if HAS_MICROSTEPS
-
-  // M350 Set microstepping mode. Warning: Steps per unit remains unchanged. S code sets stepping mode for all drivers.
-  inline void gcode_M350() {
-    if (parser.seen('S')) for (int i = 0; i <= 4; i++) stepper.microstep_mode(i, parser.value_byte());
-    LOOP_XYZE(i) if (parser.seen(axis_codes[i])) stepper.microstep_mode(i, parser.value_byte());
-    if (parser.seen('B')) stepper.microstep_mode(4, parser.value_byte());
-    stepper.microstep_readings();
-  }
-
-  /**
-   * M351: Toggle MS1 MS2 pins directly with axis codes X Y Z E B
-   *       S# determines MS1 or MS2, X# sets the pin high/low.
-   */
-  inline void gcode_M351() {
-    if (parser.seenval('S')) switch (parser.value_byte()) {
-      case 1:
-        LOOP_XYZE(i) if (parser.seenval(axis_codes[i])) stepper.microstep_ms(i, parser.value_byte(), -1);
-        if (parser.seenval('B')) stepper.microstep_ms(4, parser.value_byte(), -1);
-        break;
-      case 2:
-        LOOP_XYZE(i) if (parser.seenval(axis_codes[i])) stepper.microstep_ms(i, -1, parser.value_byte());
-        if (parser.seenval('B')) stepper.microstep_ms(4, -1, parser.value_byte());
-        break;
-    }
-    stepper.microstep_readings();
-  }
-
-#endif // HAS_MICROSTEPS
-
-#if HAS_CASE_LIGHT
-  #ifndef INVERT_CASE_LIGHT
-    #define INVERT_CASE_LIGHT false
-  #endif
-  int case_light_brightness;  // LCD routine wants INT
-  bool case_light_on;
-
-  void update_case_light() {
-    pinMode(CASE_LIGHT_PIN, OUTPUT); // digitalWrite doesn't set the port mode
-    uint8_t case_light_bright = (uint8_t)case_light_brightness;
-    if (case_light_on) {
-      if (USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN)) {
-        analogWrite(CASE_LIGHT_PIN, INVERT_CASE_LIGHT ? 255 - case_light_brightness : case_light_brightness );
-      }
-      else WRITE(CASE_LIGHT_PIN, INVERT_CASE_LIGHT ? LOW : HIGH);
-    }
-    else WRITE(CASE_LIGHT_PIN, INVERT_CASE_LIGHT ? HIGH : LOW);
-  }
-#endif // HAS_CASE_LIGHT
-
-/**
- * M355: Turn case light on/off and set brightness
- *
- *   P<byte>  Set case light brightness (PWM pin required - ignored otherwise)
- *
- *   S<bool>  Set case light on/off
- *
- *   When S turns on the light on a PWM pin then the current brightness level is used/restored
- *
- *   M355 P200 S0 turns off the light & sets the brightness level
- *   M355 S1 turns on the light with a brightness of 200 (assuming a PWM pin)
- */
-inline void gcode_M355() {
-  #if HAS_CASE_LIGHT
-    uint8_t args = 0;
-    if (parser.seenval('P')) ++args, case_light_brightness = parser.value_byte();
-    if (parser.seenval('S')) ++args, case_light_on = parser.value_bool();
-    if (args) update_case_light();
-
-    // always report case light status
-    SERIAL_ECHO_START();
-    if (!case_light_on) {
-      SERIAL_ECHOLN("Case light: off");
-    }
-    else {
-      if (!USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN)) SERIAL_ECHOLN("Case light: on");
-      else SERIAL_ECHOLNPAIR("Case light: ", case_light_brightness);
-    }
-
-  #else
-    SERIAL_ERROR_START();
-    SERIAL_ERRORLNPGM(MSG_ERR_M355_NONE);
-  #endif // HAS_CASE_LIGHT
-}
-
-#if ENABLED(MIXING_EXTRUDER)
-
-  /**
-   * M163: Set a single mix factor for a mixing extruder
-   *       This is called "weight" by some systems.
-   *
-   *   S[index]   The channel index to set
-   *   P[float]   The mix value
-   *
-   */
-  inline void gcode_M163() {
-    const int mix_index = parser.intval('S');
-    if (mix_index < MIXING_STEPPERS) {
-      float mix_value = parser.floatval('P');
-      NOLESS(mix_value, 0.0);
-      mixing_factor[mix_index] = RECIPROCAL(mix_value);
-    }
-  }
-
-  #if MIXING_VIRTUAL_TOOLS > 1
-
-    /**
-     * M164: Store the current mix factors as a virtual tool.
-     *
-     *   S[index]   The virtual tool to store
-     *
-     */
-    inline void gcode_M164() {
-      const int tool_index = parser.intval('S');
-      if (tool_index < MIXING_VIRTUAL_TOOLS) {
-        normalize_mix();
-        for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
-          mixing_virtual_tool_mix[tool_index][i] = mixing_factor[i];
-      }
-    }
-
-  #endif
-
-  #if ENABLED(DIRECT_MIXING_IN_G1)
-    /**
-     * M165: Set multiple mix factors for a mixing extruder.
-     *       Factors that are left out will be set to 0.
-     *       All factors together must add up to 1.0.
-     *
-     *   A[factor] Mix factor for extruder stepper 1
-     *   B[factor] Mix factor for extruder stepper 2
-     *   C[factor] Mix factor for extruder stepper 3
-     *   D[factor] Mix factor for extruder stepper 4
-     *   H[factor] Mix factor for extruder stepper 5
-     *   I[factor] Mix factor for extruder stepper 6
-     *
-     */
-    inline void gcode_M165() { gcode_get_mix(); }
-  #endif
-
-#endif // MIXING_EXTRUDER
-
-/**
- * M999: Restart after being stopped
- *
- * Default behaviour is to flush the serial buffer and request
- * a resend to the host starting on the last N line received.
- *
- * Sending "M999 S1" will resume printing without flushing the
- * existing command buffer.
- *
- */
-inline void gcode_M999() {
-  Running = true;
-  lcd_reset_alert_level();
-
-  if (parser.boolval('S')) return;
-
-  // gcode_LastN = Stopped_gcode_LastN;
-  FlushSerialRequestResend();
-}
-
-#if ENABLED(SWITCHING_EXTRUDER)
-  #if EXTRUDERS > 3
-    #define REQ_ANGLES 4
-    #define _SERVO_NR (e < 2 ? SWITCHING_EXTRUDER_SERVO_NR : SWITCHING_EXTRUDER_E23_SERVO_NR)
-  #else
-    #define REQ_ANGLES 2
-    #define _SERVO_NR SWITCHING_EXTRUDER_SERVO_NR
-  #endif
-  inline void move_extruder_servo(const uint8_t e) {
-    constexpr int16_t angles[] = SWITCHING_EXTRUDER_SERVO_ANGLES;
-    static_assert(COUNT(angles) == REQ_ANGLES, "SWITCHING_EXTRUDER_SERVO_ANGLES needs " STRINGIFY(REQ_ANGLES) " angles.");
-    stepper.synchronize();
-    #if EXTRUDERS & 1
-      if (e < EXTRUDERS - 1)
-    #endif
-    {
-      MOVE_SERVO(_SERVO_NR, angles[e]);
-      safe_delay(500);
-    }
-  }
-#endif // SWITCHING_EXTRUDER
-
-#if ENABLED(SWITCHING_NOZZLE)
-  inline void move_nozzle_servo(const uint8_t e) {
-    const int16_t angles[2] = SWITCHING_NOZZLE_SERVO_ANGLES;
-    stepper.synchronize();
-    MOVE_SERVO(SWITCHING_NOZZLE_SERVO_NR, angles[e]);
-    safe_delay(500);
-  }
-#endif
-
-inline void invalid_extruder_error(const uint8_t e) {
-  SERIAL_ECHO_START();
-  SERIAL_CHAR('T');
-  SERIAL_ECHO_F(e, DEC);
-  SERIAL_CHAR(' ');
-  SERIAL_ECHOLN(MSG_INVALID_EXTRUDER);
-}
-
-#if ENABLED(PARKING_EXTRUDER)
-
-  #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
-    #define PE_MAGNET_ON_STATE !PARKING_EXTRUDER_SOLENOIDS_PINS_ACTIVE
-  #else
-    #define PE_MAGNET_ON_STATE PARKING_EXTRUDER_SOLENOIDS_PINS_ACTIVE
-  #endif
-
-  void pe_set_magnet(const uint8_t extruder_num, const uint8_t state) {
-    switch (extruder_num) {
-      case 1: OUT_WRITE(SOL1_PIN, state); break;
-      default: OUT_WRITE(SOL0_PIN, state); break;
-    }
-    #if PARKING_EXTRUDER_SOLENOIDS_DELAY > 0
-      dwell(PARKING_EXTRUDER_SOLENOIDS_DELAY);
-    #endif
-  }
-
-  inline void pe_activate_magnet(const uint8_t extruder_num) { pe_set_magnet(extruder_num, PE_MAGNET_ON_STATE); }
-  inline void pe_deactivate_magnet(const uint8_t extruder_num) { pe_set_magnet(extruder_num, !PE_MAGNET_ON_STATE); }
-
-#endif // PARKING_EXTRUDER
-
-#if HAS_FANMUX
-
-  void fanmux_switch(const uint8_t e) {
-    WRITE(FANMUX0_PIN, TEST(e, 0) ? HIGH : LOW);
-    #if PIN_EXISTS(FANMUX1)
-      WRITE(FANMUX1_PIN, TEST(e, 1) ? HIGH : LOW);
-      #if PIN_EXISTS(FANMUX2)
-        WRITE(FANMUX2, TEST(e, 2) ? HIGH : LOW);
-      #endif
-    #endif
-  }
-
-  FORCE_INLINE void fanmux_init(void){
-    SET_OUTPUT(FANMUX0_PIN);
-    #if PIN_EXISTS(FANMUX1)
-      SET_OUTPUT(FANMUX1_PIN);
-      #if PIN_EXISTS(FANMUX2)
-        SET_OUTPUT(FANMUX2_PIN);
-      #endif
-    #endif
-    fanmux_switch(0);
-  }
-
-#endif // HAS_FANMUX
-
-/**
- * Perform a tool-change, which may result in moving the
- * previous tool out of the way and the new tool into place.
- */
-void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
-  #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
-
-    if (tmp_extruder >= MIXING_VIRTUAL_TOOLS)
-      return invalid_extruder_error(tmp_extruder);
-
-    // T0-Tnnn: Switch virtual tool by changing the mix
-    for (uint8_t j = 0; j < MIXING_STEPPERS; j++)
-      mixing_factor[j] = mixing_virtual_tool_mix[tmp_extruder][j];
-
-  #else // !MIXING_EXTRUDER || MIXING_VIRTUAL_TOOLS <= 1
-
-    if (tmp_extruder >= EXTRUDERS)
-      return invalid_extruder_error(tmp_extruder);
-
-    #if HOTENDS > 1
-
-      const float old_feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : feedrate_mm_s;
-
-      feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
-
-      if (tmp_extruder != active_extruder) {
-        if (!no_move && axis_unhomed_error()) {
-          no_move = true;
-          #if ENABLED(DEBUG_LEVELING_FEATURE)
-            if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("No move on toolchange");
-          #endif
-        }
-
-        // Save current position to destination, for use later
-        set_destination_to_current();
-
-        #if ENABLED(DUAL_X_CARRIAGE)
-
-          #if ENABLED(DEBUG_LEVELING_FEATURE)
-            if (DEBUGGING(LEVELING)) {
-              SERIAL_ECHOPGM("Dual X Carriage Mode ");
-              switch (dual_x_carriage_mode) {
-                case DXC_FULL_CONTROL_MODE: SERIAL_ECHOLNPGM("DXC_FULL_CONTROL_MODE"); break;
-                case DXC_AUTO_PARK_MODE: SERIAL_ECHOLNPGM("DXC_AUTO_PARK_MODE"); break;
-                case DXC_DUPLICATION_MODE: SERIAL_ECHOLNPGM("DXC_DUPLICATION_MODE"); break;
-              }
-            }
-          #endif
-
-          const float xhome = x_home_pos(active_extruder);
-          if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE
-              && IsRunning()
-              && (delayed_move_time || current_position[X_AXIS] != xhome)
-          ) {
-            float raised_z = current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT;
-            #if ENABLED(MAX_SOFTWARE_ENDSTOPS)
-              NOMORE(raised_z, soft_endstop_max[Z_AXIS]);
-            #endif
-            #if ENABLED(DEBUG_LEVELING_FEATURE)
-              if (DEBUGGING(LEVELING)) {
-                SERIAL_ECHOLNPAIR("Raise to ", raised_z);
-                SERIAL_ECHOLNPAIR("MoveX to ", xhome);
-                SERIAL_ECHOLNPAIR("Lower to ", current_position[Z_AXIS]);
-              }
-            #endif
-            // Park old head: 1) raise 2) move to park position 3) lower
-            for (uint8_t i = 0; i < 3; i++)
-              planner.buffer_line(
-                i == 0 ? current_position[X_AXIS] : xhome,
-                current_position[Y_AXIS],
-                i == 2 ? current_position[Z_AXIS] : raised_z,
-                current_position[E_AXIS],
-                planner.max_feedrate_mm_s[i == 1 ? X_AXIS : Z_AXIS],
-                active_extruder
-              );
-            stepper.synchronize();
-          }
-
-          // Apply Y & Z extruder offset (X offset is used as home pos with Dual X)
-          current_position[Y_AXIS] -= hotend_offset[Y_AXIS][active_extruder] - hotend_offset[Y_AXIS][tmp_extruder];
-          current_position[Z_AXIS] -= hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
-
-          // Activate the new extruder ahead of calling set_axis_is_at_home!
-          active_extruder = tmp_extruder;
-
-          // This function resets the max/min values - the current position may be overwritten below.
-          set_axis_is_at_home(X_AXIS);
-
-          #if ENABLED(DEBUG_LEVELING_FEATURE)
-            if (DEBUGGING(LEVELING)) DEBUG_POS("New Extruder", current_position);
-          #endif
-
-          // Only when auto-parking are carriages safe to move
-          if (dual_x_carriage_mode != DXC_AUTO_PARK_MODE) no_move = true;
-
-          switch (dual_x_carriage_mode) {
-            case DXC_FULL_CONTROL_MODE:
-              // New current position is the position of the activated extruder
-              current_position[X_AXIS] = LOGICAL_X_POSITION(inactive_extruder_x_pos);
-              // Save the inactive extruder's position (from the old current_position)
-              inactive_extruder_x_pos = RAW_X_POSITION(destination[X_AXIS]);
-              break;
-            case DXC_AUTO_PARK_MODE:
-              // record raised toolhead position for use by unpark
-              COPY(raised_parked_position, current_position);
-              raised_parked_position[Z_AXIS] += TOOLCHANGE_UNPARK_ZLIFT;
-              #if ENABLED(MAX_SOFTWARE_ENDSTOPS)
-                NOMORE(raised_parked_position[Z_AXIS], soft_endstop_max[Z_AXIS]);
-              #endif
-              active_extruder_parked = true;
-              delayed_move_time = 0;
-              break;
-            case DXC_DUPLICATION_MODE:
-              // If the new extruder is the left one, set it "parked"
-              // This triggers the second extruder to move into the duplication position
-              active_extruder_parked = (active_extruder == 0);
-
-              if (active_extruder_parked)
-                current_position[X_AXIS] = LOGICAL_X_POSITION(inactive_extruder_x_pos);
-              else
-                current_position[X_AXIS] = destination[X_AXIS] + duplicate_extruder_x_offset;
-              inactive_extruder_x_pos = RAW_X_POSITION(destination[X_AXIS]);
-              extruder_duplication_enabled = false;
-              #if ENABLED(DEBUG_LEVELING_FEATURE)
-                if (DEBUGGING(LEVELING)) {
-                  SERIAL_ECHOLNPAIR("Set inactive_extruder_x_pos=", inactive_extruder_x_pos);
-                  SERIAL_ECHOLNPGM("Clear extruder_duplication_enabled");
-                }
-              #endif
-              break;
-          }
-
-          #if ENABLED(DEBUG_LEVELING_FEATURE)
-            if (DEBUGGING(LEVELING)) {
-              SERIAL_ECHOLNPAIR("Active extruder parked: ", active_extruder_parked ? "yes" : "no");
-              DEBUG_POS("New extruder (parked)", current_position);
-            }
-          #endif
-
-          // No extra case for HAS_ABL in DUAL_X_CARRIAGE. Does that mean they don't work together?
-
-        #else // !DUAL_X_CARRIAGE
-
-          #if ENABLED(PARKING_EXTRUDER) // Dual Parking extruder
-            const float z_diff = hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
-            float z_raise = 0;
-            if (!no_move) {
-
-              const float parkingposx[] = PARKING_EXTRUDER_PARKING_X,
-                          midpos = ((parkingposx[1] - parkingposx[0])/2) + parkingposx[0] + hotend_offset[X_AXIS][active_extruder],
-                          grabpos = parkingposx[tmp_extruder] + hotend_offset[X_AXIS][active_extruder]
-                                    + (tmp_extruder == 0 ? -(PARKING_EXTRUDER_GRAB_DISTANCE) : PARKING_EXTRUDER_GRAB_DISTANCE);
-              /**
-               *  Steps:
-               *    1. raise Z-Axis to have enough clearance
-               *    2. move to park poition of old extruder
-               *    3. disengage magnetc field, wait for delay
-               *    4. move near new extruder
-               *    5. engage magnetic field for new extruder
-               *    6. move to parking incl. offset of new extruder
-               *    7. lower Z-Axis
-               */
-
-              // STEP 1
-              #if ENABLED(DEBUG_LEVELING_FEATURE)
-                SERIAL_ECHOLNPGM("Starting Autopark");
-                if (DEBUGGING(LEVELING)) DEBUG_POS("current position:", current_position);
-              #endif
-              z_raise = PARKING_EXTRUDER_SECURITY_RAISE;
-              current_position[Z_AXIS] += z_raise;
-              #if ENABLED(DEBUG_LEVELING_FEATURE)
-                SERIAL_ECHOLNPGM("(1) Raise Z-Axis ");
-                if (DEBUGGING(LEVELING)) DEBUG_POS("Moving to Raised Z-Position", current_position);
-              #endif
-              planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
-              stepper.synchronize();
-
-              // STEP 2
-              current_position[X_AXIS] = parkingposx[active_extruder] + hotend_offset[X_AXIS][active_extruder];
-              #if ENABLED(DEBUG_LEVELING_FEATURE)
-                SERIAL_ECHOLNPAIR("(2) Park extruder ", active_extruder);
-                if (DEBUGGING(LEVELING)) DEBUG_POS("Moving ParkPos", current_position);
-              #endif
-              planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
-              stepper.synchronize();
-
-              // STEP 3
-              #if ENABLED(DEBUG_LEVELING_FEATURE)
-                SERIAL_ECHOLNPGM("(3) Disengage magnet ");
-              #endif
-              pe_deactivate_magnet(active_extruder);
-
-              // STEP 4
-              #if ENABLED(DEBUG_LEVELING_FEATURE)
-                SERIAL_ECHOLNPGM("(4) Move to position near new extruder");
-              #endif
-              current_position[X_AXIS] += (active_extruder == 0 ? 10 : -10); // move 10mm away from parked extruder
-
-              #if ENABLED(DEBUG_LEVELING_FEATURE)
-                if (DEBUGGING(LEVELING)) DEBUG_POS("Moving away from parked extruder", current_position);
-              #endif
-              planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
-              stepper.synchronize();
-
-              // STEP 5
-              #if ENABLED(DEBUG_LEVELING_FEATURE)
-                SERIAL_ECHOLNPGM("(5) Engage magnetic field");
-              #endif
-
-              #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
-                pe_activate_magnet(active_extruder); //just save power for inverted magnets
-              #endif
-              pe_activate_magnet(tmp_extruder);
-
-              // STEP 6
-              current_position[X_AXIS] = grabpos + (tmp_extruder == 0 ? (+10) : (-10));
-              planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
-              current_position[X_AXIS] = grabpos;
-              #if ENABLED(DEBUG_LEVELING_FEATURE)
-                SERIAL_ECHOLNPAIR("(6) Unpark extruder ", tmp_extruder);
-                if (DEBUGGING(LEVELING)) DEBUG_POS("Move UnparkPos", current_position);
-              #endif
-              planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS]/2, active_extruder);
-              stepper.synchronize();
-
-              // Step 7
-              current_position[X_AXIS] = midpos - hotend_offset[X_AXIS][tmp_extruder];
-              #if ENABLED(DEBUG_LEVELING_FEATURE)
-                SERIAL_ECHOLNPGM("(7) Move midway between hotends");
-                if (DEBUGGING(LEVELING)) DEBUG_POS("Move midway to new extruder", current_position);
-              #endif
-              planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
-              stepper.synchronize();
-              #if ENABLED(DEBUG_LEVELING_FEATURE)
-                SERIAL_ECHOLNPGM("Autopark done.");
-              #endif
-            }
-            else { // nomove == true
-              // Only engage magnetic field for new extruder
-              pe_activate_magnet(tmp_extruder);
-              #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
-                pe_activate_magnet(active_extruder); // Just save power for inverted magnets
-              #endif
-            }
-            current_position[Z_AXIS] -= hotend_offset[Z_AXIS][tmp_extruder] - hotend_offset[Z_AXIS][active_extruder]; // Apply Zoffset
-
-            #if ENABLED(DEBUG_LEVELING_FEATURE)
-              if (DEBUGGING(LEVELING)) DEBUG_POS("Applying Z-offset", current_position);
-            #endif
-
-          #endif // dualParking extruder
-
-          #if ENABLED(SWITCHING_NOZZLE)
-            #define DONT_SWITCH (SWITCHING_EXTRUDER_SERVO_NR == SWITCHING_NOZZLE_SERVO_NR)
-            // <0 if the new nozzle is higher, >0 if lower. A bigger raise when lower.
-            const float z_diff = hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder],
-                        z_raise = 0.3 + (z_diff > 0.0 ? z_diff : 0.0);
-
-            // Always raise by some amount (destination copied from current_position earlier)
-            current_position[Z_AXIS] += z_raise;
-            planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
-            move_nozzle_servo(tmp_extruder);
-          #endif
-
-          /**
-           * Set current_position to the position of the new nozzle.
-           * Offsets are based on linear distance, so we need to get
-           * the resulting position in coordinate space.
-           *
-           * - With grid or 3-point leveling, offset XYZ by a tilted vector
-           * - With mesh leveling, update Z for the new position
-           * - Otherwise, just use the raw linear distance
-           *
-           * Software endstops are altered here too. Consider a case where:
-           *   E0 at X=0 ... E1 at X=10
-           * When we switch to E1 now X=10, but E1 can't move left.
-           * To express this we apply the change in XY to the software endstops.
-           * E1 can move farther right than E0, so the right limit is extended.
-           *
-           * Note that we don't adjust the Z software endstops. Why not?
-           * Consider a case where Z=0 (here) and switching to E1 makes Z=1
-           * because the bed is 1mm lower at the new position. As long as
-           * the first nozzle is out of the way, the carriage should be
-           * allowed to move 1mm lower. This technically "breaks" the
-           * Z software endstop. But this is technically correct (and
-           * there is no viable alternative).
-           */
-          #if ABL_PLANAR
-            // Offset extruder, make sure to apply the bed level rotation matrix
-            vector_3 tmp_offset_vec = vector_3(hotend_offset[X_AXIS][tmp_extruder],
-                                               hotend_offset[Y_AXIS][tmp_extruder],
-                                               0),
-                     act_offset_vec = vector_3(hotend_offset[X_AXIS][active_extruder],
-                                               hotend_offset[Y_AXIS][active_extruder],
-                                               0),
-                     offset_vec = tmp_offset_vec - act_offset_vec;
-
-            #if ENABLED(DEBUG_LEVELING_FEATURE)
-              if (DEBUGGING(LEVELING)) {
-                tmp_offset_vec.debug(PSTR("tmp_offset_vec"));
-                act_offset_vec.debug(PSTR("act_offset_vec"));
-                offset_vec.debug(PSTR("offset_vec (BEFORE)"));
-              }
-            #endif
-
-            offset_vec.apply_rotation(planner.bed_level_matrix.transpose(planner.bed_level_matrix));
-
-            #if ENABLED(DEBUG_LEVELING_FEATURE)
-              if (DEBUGGING(LEVELING)) offset_vec.debug(PSTR("offset_vec (AFTER)"));
-            #endif
-
-            // Adjustments to the current position
-            const float xydiff[2] = { offset_vec.x, offset_vec.y };
-            current_position[Z_AXIS] += offset_vec.z;
-
-          #else // !ABL_PLANAR
-
-            const float xydiff[2] = {
-              hotend_offset[X_AXIS][tmp_extruder] - hotend_offset[X_AXIS][active_extruder],
-              hotend_offset[Y_AXIS][tmp_extruder] - hotend_offset[Y_AXIS][active_extruder]
-            };
-
-            #if ENABLED(MESH_BED_LEVELING)
-
-              if (leveling_is_active()) {
-                #if ENABLED(DEBUG_LEVELING_FEATURE)
-                  if (DEBUGGING(LEVELING)) SERIAL_ECHOPAIR("Z before MBL: ", current_position[Z_AXIS]);
-                #endif
-                float x2 = current_position[X_AXIS] + xydiff[X_AXIS],
-                      y2 = current_position[Y_AXIS] + xydiff[Y_AXIS],
-                      z1 = current_position[Z_AXIS], z2 = z1;
-                planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], z1);
-                planner.apply_leveling(x2, y2, z2);
-                current_position[Z_AXIS] += z2 - z1;
-                #if ENABLED(DEBUG_LEVELING_FEATURE)
-                  if (DEBUGGING(LEVELING))
-                    SERIAL_ECHOLNPAIR(" after: ", current_position[Z_AXIS]);
-                #endif
-              }
-
-            #endif // MESH_BED_LEVELING
-
-          #endif // !HAS_ABL
-
-          #if ENABLED(DEBUG_LEVELING_FEATURE)
-            if (DEBUGGING(LEVELING)) {
-              SERIAL_ECHOPAIR("Offset Tool XY by { ", xydiff[X_AXIS]);
-              SERIAL_ECHOPAIR(", ", xydiff[Y_AXIS]);
-              SERIAL_ECHOLNPGM(" }");
-            }
-          #endif
-
-          // The newly-selected extruder XY is actually at...
-          current_position[X_AXIS] += xydiff[X_AXIS];
-          current_position[Y_AXIS] += xydiff[Y_AXIS];
-          #if HAS_WORKSPACE_OFFSET || ENABLED(DUAL_X_CARRIAGE) || ENABLED(PARKING_EXTRUDER)
-            for (uint8_t i = X_AXIS; i <= Y_AXIS; i++) {
-              #if HAS_POSITION_SHIFT
-                position_shift[i] += xydiff[i];
-              #endif
-              update_software_endstops((AxisEnum)i);
-            }
-          #endif
-
-          // Set the new active extruder
-          active_extruder = tmp_extruder;
-
-        #endif // !DUAL_X_CARRIAGE
-
-        #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) DEBUG_POS("Sync After Toolchange", current_position);
-        #endif
-
-        // Tell the planner the new "current position"
-        SYNC_PLAN_POSITION_KINEMATIC();
-
-        // Move to the "old position" (move the extruder into place)
-        if (!no_move && IsRunning()) {
-          #if ENABLED(DEBUG_LEVELING_FEATURE)
-            if (DEBUGGING(LEVELING)) DEBUG_POS("Move back", destination);
-          #endif
-          prepare_move_to_destination();
-        }
-
-        #if ENABLED(SWITCHING_NOZZLE)
-          // Move back down, if needed. (Including when the new tool is higher.)
-          if (z_raise != z_diff) {
-            destination[Z_AXIS] += z_diff;
-            feedrate_mm_s = planner.max_feedrate_mm_s[Z_AXIS];
-            prepare_move_to_destination();
-          }
-        #endif
-
-      } // (tmp_extruder != active_extruder)
-
-      stepper.synchronize();
-
-      #if ENABLED(EXT_SOLENOID) && !ENABLED(PARKING_EXTRUDER)
-        disable_all_solenoids();
-        enable_solenoid_on_active_extruder();
-      #endif // EXT_SOLENOID
-
-      feedrate_mm_s = old_feedrate_mm_s;
-
-    #else // HOTENDS <= 1
-
-      UNUSED(fr_mm_s);
-      UNUSED(no_move);
-
-      #if ENABLED(MK2_MULTIPLEXER)
-        if (tmp_extruder >= E_STEPPERS)
-          return invalid_extruder_error(tmp_extruder);
-
-        select_multiplexed_stepper(tmp_extruder);
-      #endif
-
-      // Set the new active extruder
-      active_extruder = tmp_extruder;
-
-    #endif // HOTENDS <= 1
-
-    #if ENABLED(SWITCHING_EXTRUDER) && !DONT_SWITCH
-      stepper.synchronize();
-      move_extruder_servo(active_extruder);
-    #endif
-
-    #if HAS_FANMUX
-      fanmux_switch(active_extruder);
-    #endif
-
-    SERIAL_ECHO_START();
-    SERIAL_ECHOLNPAIR(MSG_ACTIVE_EXTRUDER, (int)active_extruder);
-
-  #endif // !MIXING_EXTRUDER || MIXING_VIRTUAL_TOOLS <= 1
-}
-
-/**
- * T0-T3: Switch tool, usually switching extruders
- *
- *   F[units/min] Set the movement feedrate
- *   S1           Don't move the tool in XY after change
- */
-inline void gcode_T(uint8_t tmp_extruder) {
-
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) {
-      SERIAL_ECHOPAIR(">>> gcode_T(", tmp_extruder);
-      SERIAL_CHAR(')');
-      SERIAL_EOL();
-      DEBUG_POS("BEFORE", current_position);
-    }
-  #endif
-
-  #if HOTENDS == 1 || (ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1)
-
-    tool_change(tmp_extruder);
-
-  #elif HOTENDS > 1
-
-    tool_change(
-      tmp_extruder,
-      MMM_TO_MMS(parser.linearval('F')),
-      (tmp_extruder == active_extruder) || parser.boolval('S')
-    );
-
-  #endif
-
-  #if ENABLED(DEBUG_LEVELING_FEATURE)
-    if (DEBUGGING(LEVELING)) {
-      DEBUG_POS("AFTER", current_position);
-      SERIAL_ECHOLNPGM("<<< gcode_T");
-    }
-  #endif
-}
+#if ENABLED(M100_FREE_MEMORY_WATCHER)
+  #include "gcode/calibrate/M100.h"
+#endif
 
 /**
- * Process a single command and dispatch it to its handler
- * This is called from the main loop()
+ * Output the current position to serial
  */
-void process_next_command() {
-  char * const current_command = command_queue[cmd_queue_index_r];
-
-  if (DEBUGGING(ECHO)) {
-    SERIAL_ECHO_START();
-    SERIAL_ECHOLN(current_command);
-    #if ENABLED(M100_FREE_MEMORY_WATCHER)
-      SERIAL_ECHOPAIR("slot:", cmd_queue_index_r);
-      M100_dump_routine("   Command Queue:", (const char*)command_queue, (const char*)(command_queue + sizeof(command_queue)));
-    #endif
-  }
-
-  KEEPALIVE_STATE(IN_HANDLER);
-
-  // Parse the next command in the queue
-  parser.parse(current_command);
-
-  // Handle a known G, M, or T
-  switch (parser.command_letter) {
-    case 'G': switch (parser.codenum) {
-
-      // G0, G1
-      case 0:
-      case 1:
-        #if IS_SCARA
-          gcode_G0_G1(parser.codenum == 0);
-        #else
-          gcode_G0_G1();
-        #endif
-        break;
-
-      // G2, G3
-      #if ENABLED(ARC_SUPPORT) && DISABLED(SCARA)
-        case 2: // G2: CW ARC
-        case 3: // G3: CCW ARC
-          gcode_G2_G3(parser.codenum == 2);
-          break;
-      #endif
-
-      // G4 Dwell
-      case 4:
-        gcode_G4();
-        break;
-
-      #if ENABLED(BEZIER_CURVE_SUPPORT)
-        case 5: // G5: Cubic B_spline
-          gcode_G5();
-          break;
-      #endif // BEZIER_CURVE_SUPPORT
-
-      #if ENABLED(FWRETRACT)
-        case 10: // G10: retract
-          gcode_G10();
-          break;
-        case 11: // G11: retract_recover
-          gcode_G11();
-          break;
-      #endif // FWRETRACT
-
-      #if ENABLED(NOZZLE_CLEAN_FEATURE)
-        case 12:
-          gcode_G12(); // G12: Nozzle Clean
-          break;
-      #endif // NOZZLE_CLEAN_FEATURE
-
-      #if ENABLED(CNC_WORKSPACE_PLANES)
-        case 17: // G17: Select Plane XY
-          gcode_G17();
-          break;
-        case 18: // G18: Select Plane ZX
-          gcode_G18();
-          break;
-        case 19: // G19: Select Plane YZ
-          gcode_G19();
-          break;
-      #endif // CNC_WORKSPACE_PLANES
-
-      #if ENABLED(INCH_MODE_SUPPORT)
-        case 20: // G20: Inch Mode
-          gcode_G20();
-          break;
-
-        case 21: // G21: MM Mode
-          gcode_G21();
-          break;
-      #endif // INCH_MODE_SUPPORT
-
-      #if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(UBL_G26_MESH_VALIDATION)
-        case 26: // G26: Mesh Validation Pattern generation
-          gcode_G26();
-          break;
-      #endif // AUTO_BED_LEVELING_UBL
-
-      #if ENABLED(NOZZLE_PARK_FEATURE)
-        case 27: // G27: Nozzle Park
-          gcode_G27();
-          break;
-      #endif // NOZZLE_PARK_FEATURE
-
-      case 28: // G28: Home all axes, one at a time
-        gcode_G28(false);
-        break;
-
-      #if HAS_LEVELING
-        case 29: // G29 Detailed Z probe, probes the bed at 3 or more points,
-                 // or provides access to the UBL System if enabled.
-          gcode_G29();
-          break;
-      #endif // HAS_LEVELING
-
-      #if HAS_BED_PROBE
-
-        case 30: // G30 Single Z probe
-          gcode_G30();
-          break;
-
-        #if ENABLED(Z_PROBE_SLED)
-
-            case 31: // G31: dock the sled
-              gcode_G31();
-              break;
-
-            case 32: // G32: undock the sled
-              gcode_G32();
-              break;
-
-        #endif // Z_PROBE_SLED
-
-      #endif // HAS_BED_PROBE
-
-      #if PROBE_SELECTED
-
-        #if ENABLED(DELTA_AUTO_CALIBRATION)
-
-          case 33: // G33: Delta Auto-Calibration
-            gcode_G33();
-            break;
-
-        #endif // DELTA_AUTO_CALIBRATION
-
-      #endif // PROBE_SELECTED
-
-      #if ENABLED(G38_PROBE_TARGET)
-        case 38: // G38.2 & G38.3
-          if (parser.subcode == 2 || parser.subcode == 3)
-            gcode_G38(parser.subcode == 2);
-          break;
-      #endif
-
-      case 90: // G90
-        relative_mode = false;
-        break;
-      case 91: // G91
-        relative_mode = true;
-        break;
-
-      case 92: // G92
-        gcode_G92();
-        break;
-
-      #if ENABLED(AUTO_BED_LEVELING_BILINEAR) || ENABLED(AUTO_BED_LEVELING_UBL) || ENABLED(MESH_BED_LEVELING)
-        case 42:
-          gcode_G42();
-          break;
-      #endif
-
-      #if ENABLED(DEBUG_GCODE_PARSER)
-        case 800:
-          parser.debug(); // GCode Parser Test for G
-          break;
-      #endif
-    }
-    break;
-
-    case 'M': switch (parser.codenum) {
-      #if HAS_RESUME_CONTINUE
-        case 0: // M0: Unconditional stop - Wait for user button press on LCD
-        case 1: // M1: Conditional stop - Wait for user button press on LCD
-          gcode_M0_M1();
-          break;
-      #endif // ULTIPANEL
-
-      #if ENABLED(SPINDLE_LASER_ENABLE)
-        case 3:
-          gcode_M3_M4(true);   // M3: turn spindle/laser on, set laser/spindle power/speed, set rotation direction CW
-          break;               // synchronizes with movement commands
-        case 4:
-          gcode_M3_M4(false);  // M4: turn spindle/laser on, set laser/spindle power/speed, set rotation direction CCW
-          break;               // synchronizes with movement commands
-        case 5:
-          gcode_M5();     // M5 - turn spindle/laser off
-          break;          // synchronizes with movement commands
-      #endif
-      case 17: // M17: Enable all stepper motors
-        gcode_M17();
-        break;
-
-      #if ENABLED(SDSUPPORT)
-        case 20: // M20: list SD card
-          gcode_M20(); break;
-        case 21: // M21: init SD card
-          gcode_M21(); break;
-        case 22: // M22: release SD card
-          gcode_M22(); break;
-        case 23: // M23: Select file
-          gcode_M23(); break;
-        case 24: // M24: Start SD print
-          gcode_M24(); break;
-        case 25: // M25: Pause SD print
-          gcode_M25(); break;
-        case 26: // M26: Set SD index
-          gcode_M26(); break;
-        case 27: // M27: Get SD status
-          gcode_M27(); break;
-        case 28: // M28: Start SD write
-          gcode_M28(); break;
-        case 29: // M29: Stop SD write
-          gcode_M29(); break;
-        case 30: // M30 <filename> Delete File
-          gcode_M30(); break;
-        case 32: // M32: Select file and start SD print
-          gcode_M32(); break;
-
-        #if ENABLED(LONG_FILENAME_HOST_SUPPORT)
-          case 33: // M33: Get the long full path to a file or folder
-            gcode_M33(); break;
-        #endif
-
-        #if ENABLED(SDCARD_SORT_ALPHA) && ENABLED(SDSORT_GCODE)
-          case 34: // M34: Set SD card sorting options
-            gcode_M34(); break;
-        #endif // SDCARD_SORT_ALPHA && SDSORT_GCODE
-
-        case 928: // M928: Start SD write
-          gcode_M928(); break;
-      #endif // SDSUPPORT
-
-      case 31: // M31: Report time since the start of SD print or last M109
-        gcode_M31(); break;
-
-      case 42: // M42: Change pin state
-        gcode_M42(); break;
-
-      #if ENABLED(PINS_DEBUGGING)
-        case 43: // M43: Read pin state
-          gcode_M43(); break;
-      #endif
-
-
-      #if ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)
-        case 48: // M48: Z probe repeatability test
-          gcode_M48();
-          break;
-      #endif // Z_MIN_PROBE_REPEATABILITY_TEST
-
-      #if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(UBL_G26_MESH_VALIDATION)
-        case 49: // M49: Turn on or off G26 debug flag for verbose output
-          gcode_M49();
-          break;
-      #endif // AUTO_BED_LEVELING_UBL && UBL_G26_MESH_VALIDATION
-
-      case 75: // M75: Start print timer
-        gcode_M75(); break;
-      case 76: // M76: Pause print timer
-        gcode_M76(); break;
-      case 77: // M77: Stop print timer
-        gcode_M77(); break;
-
-      #if ENABLED(PRINTCOUNTER)
-        case 78: // M78: Show print statistics
-          gcode_M78(); break;
-      #endif
-
-      #if ENABLED(M100_FREE_MEMORY_WATCHER)
-        case 100: // M100: Free Memory Report
-          gcode_M100();
-          break;
-      #endif
-
-      case 104: // M104: Set hot end temperature
-        gcode_M104();
-        break;
-
-      case 110: // M110: Set Current Line Number
-        gcode_M110();
-        break;
-
-      case 111: // M111: Set debug level
-        gcode_M111();
-        break;
-
-      #if DISABLED(EMERGENCY_PARSER)
-
-        case 108: // M108: Cancel Waiting
-          gcode_M108();
-          break;
-
-        case 112: // M112: Emergency Stop
-          gcode_M112();
-          break;
-
-        case 410: // M410 quickstop - Abort all the planned moves.
-          gcode_M410();
-          break;
-
-      #endif
-
-      #if ENABLED(HOST_KEEPALIVE_FEATURE)
-        case 113: // M113: Set Host Keepalive interval
-          gcode_M113();
-          break;
-      #endif
-
-      case 140: // M140: Set bed temperature
-        gcode_M140();
-        break;
-
-
-      case 105: // M105: Report current temperature
-        gcode_M105();
-        KEEPALIVE_STATE(NOT_BUSY);
-        return; // "ok" already printed
-
-      #if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND || HAS_TEMP_BED)
-        case 155: // M155: Set temperature auto-report interval
-          gcode_M155();
-          break;
-      #endif
-
-      case 109: // M109: Wait for hotend temperature to reach target
-        gcode_M109();
-        break;
-
-      #if HAS_TEMP_BED
-        case 190: // M190: Wait for bed temperature to reach target
-          gcode_M190();
-          break;
-      #endif // HAS_TEMP_BED
-
-      #if FAN_COUNT > 0
-        case 106: // M106: Fan On
-          gcode_M106();
-          break;
-        case 107: // M107: Fan Off
-          gcode_M107();
-          break;
-      #endif // FAN_COUNT > 0
-
-      #if ENABLED(PARK_HEAD_ON_PAUSE)
-        case 125: // M125: Store current position and move to filament change position
-          gcode_M125(); break;
-      #endif
-
-      #if ENABLED(BARICUDA)
-        // PWM for HEATER_1_PIN
-        #if HAS_HEATER_1
-          case 126: // M126: valve open
-            gcode_M126();
-            break;
-          case 127: // M127: valve closed
-            gcode_M127();
-            break;
-        #endif // HAS_HEATER_1
-
-        // PWM for HEATER_2_PIN
-        #if HAS_HEATER_2
-          case 128: // M128: valve open
-            gcode_M128();
-            break;
-          case 129: // M129: valve closed
-            gcode_M129();
-            break;
-        #endif // HAS_HEATER_2
-      #endif // BARICUDA
-
-      #if HAS_POWER_SWITCH
-
-        case 80: // M80: Turn on Power Supply
-          gcode_M80();
-          break;
-
-      #endif // HAS_POWER_SWITCH
-
-      case 81: // M81: Turn off Power, including Power Supply, if possible
-        gcode_M81();
-        break;
-
-      case 82: // M82: Set E axis normal mode (same as other axes)
-        gcode_M82();
-        break;
-      case 83: // M83: Set E axis relative mode
-        gcode_M83();
-        break;
-      case 18: // M18 => M84
-      case 84: // M84: Disable all steppers or set timeout
-        gcode_M18_M84();
-        break;
-      case 85: // M85: Set inactivity stepper shutdown timeout
-        gcode_M85();
-        break;
-      case 92: // M92: Set the steps-per-unit for one or more axes
-        gcode_M92();
-        break;
-      case 114: // M114: Report current position
-        gcode_M114();
-        break;
-      case 115: // M115: Report capabilities
-        gcode_M115();
-        break;
-      case 117: // M117: Set LCD message text, if possible
-        gcode_M117();
-        break;
-      case 118: // M118: Display a message in the host console
-        gcode_M118();
-        break;
-      case 119: // M119: Report endstop states
-        gcode_M119();
-        break;
-      case 120: // M120: Enable endstops
-        gcode_M120();
-        break;
-      case 121: // M121: Disable endstops
-        gcode_M121();
-        break;
-
-      #if ENABLED(ULTIPANEL)
-
-        case 145: // M145: Set material heatup parameters
-          gcode_M145();
-          break;
-
-      #endif
-
-      #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
-        case 149: // M149: Set temperature units
-          gcode_M149();
-          break;
-      #endif
-
-      #if HAS_COLOR_LEDS
-
-        case 150: // M150: Set Status LED Color
-          gcode_M150();
-          break;
-
-      #endif // HAS_COLOR_LEDS
-
-      #if ENABLED(MIXING_EXTRUDER)
-        case 163: // M163: Set a component weight for mixing extruder
-          gcode_M163();
-          break;
-        #if MIXING_VIRTUAL_TOOLS > 1
-          case 164: // M164: Save current mix as a virtual extruder
-            gcode_M164();
-            break;
-        #endif
-        #if ENABLED(DIRECT_MIXING_IN_G1)
-          case 165: // M165: Set multiple mix weights
-            gcode_M165();
-            break;
-        #endif
-      #endif
-
-      case 200: // M200: Set filament diameter, E to cubic units
-        gcode_M200();
-        break;
-      case 201: // M201: Set max acceleration for print moves (units/s^2)
-        gcode_M201();
-        break;
-      #if 0 // Not used for Sprinter/grbl gen6
-        case 202: // M202
-          gcode_M202();
-          break;
-      #endif
-      case 203: // M203: Set max feedrate (units/sec)
-        gcode_M203();
-        break;
-      case 204: // M204: Set acceleration
-        gcode_M204();
-        break;
-      case 205: // M205: Set advanced settings
-        gcode_M205();
-        break;
-
-      #if HAS_M206_COMMAND
-        case 206: // M206: Set home offsets
-          gcode_M206();
-          break;
-      #endif
-
-      #if ENABLED(DELTA)
-        case 665: // M665: Set delta configurations
-          gcode_M665();
-          break;
-      #endif
-
-      #if ENABLED(DELTA) || ENABLED(Z_DUAL_ENDSTOPS)
-        case 666: // M666: Set delta or dual endstop adjustment
-          gcode_M666();
-          break;
-      #endif
-
-      #if ENABLED(FWRETRACT)
-        case 207: // M207: Set Retract Length, Feedrate, and Z lift
-          gcode_M207();
-          break;
-        case 208: // M208: Set Recover (unretract) Additional Length and Feedrate
-          gcode_M208();
-          break;
-        case 209: // M209: Turn Automatic Retract Detection on/off
-          if (MIN_AUTORETRACT <= MAX_AUTORETRACT) gcode_M209();
-          break;
-      #endif // FWRETRACT
-
-      case 211: // M211: Enable, Disable, and/or Report software endstops
-        gcode_M211();
-        break;
-
-      #if HOTENDS > 1
-        case 218: // M218: Set a tool offset
-          gcode_M218();
-          break;
-      #endif
-
-      case 220: // M220: Set Feedrate Percentage: S<percent> ("FR" on your LCD)
-        gcode_M220();
-        break;
-
-      case 221: // M221: Set Flow Percentage
-        gcode_M221();
-        break;
-
-      case 226: // M226: Wait until a pin reaches a state
-        gcode_M226();
-        break;
-
-      #if HAS_SERVOS
-        case 280: // M280: Set servo position absolute
-          gcode_M280();
-          break;
-      #endif // HAS_SERVOS
-
-      #if HAS_BUZZER
-        case 300: // M300: Play beep tone
-          gcode_M300();
-          break;
-      #endif // HAS_BUZZER
-
-      #if ENABLED(PIDTEMP)
-        case 301: // M301: Set hotend PID parameters
-          gcode_M301();
-          break;
-      #endif // PIDTEMP
-
-      #if ENABLED(PIDTEMPBED)
-        case 304: // M304: Set bed PID parameters
-          gcode_M304();
-          break;
-      #endif // PIDTEMPBED
-
-      #if defined(CHDK) || HAS_PHOTOGRAPH
-        case 240: // M240: Trigger a camera by emulating a Canon RC-1 : http://www.doc-diy.net/photo/rc-1_hacked/
-          gcode_M240();
-          break;
-      #endif // CHDK || PHOTOGRAPH_PIN
-
-      #if HAS_LCD_CONTRAST
-        case 250: // M250: Set LCD contrast
-          gcode_M250();
-          break;
-      #endif // HAS_LCD_CONTRAST
-
-      #if ENABLED(EXPERIMENTAL_I2CBUS)
-
-        case 260: // M260: Send data to an i2c slave
-          gcode_M260();
-          break;
-
-        case 261: // M261: Request data from an i2c slave
-          gcode_M261();
-          break;
-
-      #endif // EXPERIMENTAL_I2CBUS
+void report_current_position() {
+  SERIAL_PROTOCOLPGM("X:");
+  SERIAL_PROTOCOL(current_position[X_AXIS]);
+  SERIAL_PROTOCOLPGM(" Y:");
+  SERIAL_PROTOCOL(current_position[Y_AXIS]);
+  SERIAL_PROTOCOLPGM(" Z:");
+  SERIAL_PROTOCOL(current_position[Z_AXIS]);
+  SERIAL_PROTOCOLPGM(" E:");
+  SERIAL_PROTOCOL(current_position[E_AXIS]);
 
-      #if ENABLED(PREVENT_COLD_EXTRUSION)
-        case 302: // M302: Allow cold extrudes (set the minimum extrude temperature)
-          gcode_M302();
-          break;
-      #endif // PREVENT_COLD_EXTRUSION
+  stepper.report_positions();
 
-      case 303: // M303: PID autotune
-        gcode_M303();
-        break;
+  #if IS_SCARA
+    SERIAL_PROTOCOLPAIR("SCARA Theta:", stepper.get_axis_position_degrees(A_AXIS));
+    SERIAL_PROTOCOLLNPAIR("   Psi+Theta:", stepper.get_axis_position_degrees(B_AXIS));
+    SERIAL_EOL();
+  #endif
+}
 
-      #if ENABLED(MORGAN_SCARA)
-        case 360:  // M360: SCARA Theta pos1
-          if (gcode_M360()) return;
-          break;
-        case 361:  // M361: SCARA Theta pos2
-          if (gcode_M361()) return;
-          break;
-        case 362:  // M362: SCARA Psi pos1
-          if (gcode_M362()) return;
-          break;
-        case 363:  // M363: SCARA Psi pos2
-          if (gcode_M363()) return;
-          break;
-        case 364:  // M364: SCARA Psi pos3 (90 deg to Theta)
-          if (gcode_M364()) return;
-          break;
-      #endif // SCARA
+#include "gcode/host/M114.h"
+#include "gcode/host/M115.h"
 
-      case 400: // M400: Finish all moves
-        gcode_M400();
-        break;
+#include "gcode/lcd/M117.h"
 
-      #if HAS_BED_PROBE
-        case 401: // M401: Deploy probe
-          gcode_M401();
-          break;
-        case 402: // M402: Stow probe
-          gcode_M402();
-          break;
-      #endif // HAS_BED_PROBE
+#include "gcode/host/M118.h"
+#include "gcode/host/M119.h"
 
-      #if ENABLED(FILAMENT_WIDTH_SENSOR)
-        case 404:  // M404: Enter the nominal filament width (3mm, 1.75mm ) N<3.0> or display nominal filament width
-          gcode_M404();
-          break;
-        case 405:  // M405: Turn on filament sensor for control
-          gcode_M405();
-          break;
-        case 406:  // M406: Turn off filament sensor for control
-          gcode_M406();
-          break;
-        case 407:   // M407: Display measured filament diameter
-          gcode_M407();
-          break;
-      #endif // FILAMENT_WIDTH_SENSOR
+#include "gcode/control/M120_M121.h"
 
-      #if HAS_LEVELING
-        case 420: // M420: Enable/Disable Bed Leveling
-          gcode_M420();
-          break;
-      #endif
+#if ENABLED(PARK_HEAD_ON_PAUSE)
+  #include "gcode/feature/pause/M125.h"
+#endif
 
-      #if ENABLED(MESH_BED_LEVELING) || ENABLED(AUTO_BED_LEVELING_UBL) || ENABLED(AUTO_BED_LEVELING_BILINEAR)
-        case 421: // M421: Set a Mesh Bed Leveling Z coordinate
-          gcode_M421();
-          break;
-      #endif
+#if HAS_COLOR_LEDS
+  #include "gcode/feature/leds/M150.h"
+#endif
 
-      #if HAS_M206_COMMAND
-        case 428: // M428: Apply current_position to home_offset
-          gcode_M428();
-          break;
-      #endif
+#include "gcode/config/M200.h"
+#include "gcode/config/M201.h"
 
-      case 500: // M500: Store settings in EEPROM
-        gcode_M500();
-        break;
-      case 501: // M501: Read settings from EEPROM
-        gcode_M501();
-        break;
-      case 502: // M502: Revert to default settings
-        gcode_M502();
-        break;
-
-      #if DISABLED(DISABLE_M503)
-        case 503: // M503: print settings currently in memory
-          gcode_M503();
-          break;
-      #endif
+#if 0 // Not used for Sprinter/grbl gen6
+  #include "gcode/config/M202.h"
+#endif
 
-      #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
-        case 540: // M540: Set abort on endstop hit for SD printing
-          gcode_M540();
-          break;
-      #endif
+#include "gcode/config/M203.h"
+#include "gcode/config/M204.h"
+#include "gcode/config/M205.h"
 
-      #if HAS_BED_PROBE
-        case 851: // M851: Set Z Probe Z Offset
-          gcode_M851();
-          break;
-      #endif // HAS_BED_PROBE
+#if HAS_M206_COMMAND
+  #include "gcode/geometry/M206.h"
+#endif
 
-      #if ENABLED(ADVANCED_PAUSE_FEATURE)
-        case 600: // M600: Pause for filament change
-          gcode_M600();
-          break;
-      #endif // ADVANCED_PAUSE_FEATURE
+#if IS_KINEMATIC
+  #include "gcode/calibrate/M665.h"
+#endif
 
-      #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
-        case 605: // M605: Set Dual X Carriage movement mode
-          gcode_M605();
-          break;
-      #endif // DUAL_X_CARRIAGE
+#if ENABLED(DELTA) || ENABLED(Z_DUAL_ENDSTOPS)
+  #include "gcode/calibrate/M666.h"
+#endif
 
-      #if ENABLED(MK2_MULTIPLEXER)
-        case 702: // M702: Unload all extruders
-          gcode_M702();
-          break;
-      #endif
+#if ENABLED(FWRETRACT)
+  #include "gcode/feature/fwretract/M207.h"
+  #include "gcode/feature/fwretract/M208.h"
+  #include "gcode/feature/fwretract/M209.h"
+#endif
 
-      #if ENABLED(LIN_ADVANCE)
-        case 900: // M900: Set advance K factor.
-          gcode_M900();
-          break;
-      #endif
+#include "gcode/control/M211.h"
 
-      #if ENABLED(HAVE_TMC2130)
-        case 906: // M906: Set motor current in milliamps using axis codes X, Y, Z, E
-          gcode_M906();
-          break;
-      #endif
+#if HOTENDS > 1
+  #include "gcode/config/M218.h"
+#endif
 
-      case 907: // M907: Set digital trimpot motor current using axis codes.
-        gcode_M907();
-        break;
+#include "gcode/config/M220.h"
+#include "gcode/config/M221.h"
 
-      #if HAS_DIGIPOTSS || ENABLED(DAC_STEPPER_CURRENT)
+#include "gcode/control/M226.h"
 
-        case 908: // M908: Control digital trimpot directly.
-          gcode_M908();
-          break;
+#if ENABLED(EXPERIMENTAL_I2CBUS)
+  #include "gcode/feature/i2c/M260_M261.h"
+#endif
 
-        #if ENABLED(DAC_STEPPER_CURRENT) // As with Printrbot RevF
+#if HAS_SERVOS
+  #include "gcode/control/M280.h"
+#endif
 
-          case 909: // M909: Print digipot/DAC current value
-            gcode_M909();
-            break;
+#if HAS_BUZZER
+  #include "gcode/lcd/M300.h"
+#endif
 
-          case 910: // M910: Commit digipot/DAC value to external EEPROM
-            gcode_M910();
-            break;
+#if ENABLED(PIDTEMP)
+  #include "gcode/config/M301.h"
+#endif
 
-        #endif
+#if ENABLED(PIDTEMPBED)
+  #include "gcode/config/M304.h"
+#endif
 
-      #endif // HAS_DIGIPOTSS || DAC_STEPPER_CURRENT
+#if defined(CHDK) || HAS_PHOTOGRAPH
+  #include "gcode/control/M240.h"
+#endif
 
-      #if ENABLED(HAVE_TMC2130)
-        case 911: // M911: Report TMC2130 prewarn triggered flags
-          gcode_M911();
-          break;
+#if HAS_LCD_CONTRAST
+  #include "gcode/control/M250.h"
+#endif
 
-        case 912: // M911: Clear TMC2130 prewarn triggered flags
-          gcode_M912();
-          break;
+#if ENABLED(PREVENT_COLD_EXTRUSION)
+  #include "gcode/config/M302.h"
+#endif
 
-        #if ENABLED(HYBRID_THRESHOLD)
-          case 913: // M913: Set HYBRID_THRESHOLD speed.
-            gcode_M913();
-            break;
-        #endif
+#include "gcode/temperature/M303.h"
 
-        #if ENABLED(SENSORLESS_HOMING)
-          case 914: // M914: Set SENSORLESS_HOMING sensitivity.
-            gcode_M914();
-            break;
-        #endif
-      #endif
+#if ENABLED(MORGAN_SCARA)
+  #include "gcode/scara/M360-M364.h"
+#endif
 
-      #if HAS_MICROSTEPS
+#if ENABLED(EXT_SOLENOID)
+  #include "gcode/control/M380_M381.h"
+#endif
 
-        case 350: // M350: Set microstepping mode. Warning: Steps per unit remains unchanged. S code sets stepping mode for all drivers.
-          gcode_M350();
-          break;
+#include "gcode/control/M400.h"
 
-        case 351: // M351: Toggle MS1 MS2 pins directly, S# determines MS1 or MS2, X# sets the pin high/low.
-          gcode_M351();
-          break;
+#if HAS_BED_PROBE
+  #include "gcode/probe/M401_M402.h"
+#endif
 
-      #endif // HAS_MICROSTEPS
+#if ENABLED(FILAMENT_WIDTH_SENSOR)
+  #include "gcode/sensor/M404.h"
+  #include "gcode/sensor/M405.h"
+  #include "gcode/sensor/M406.h"
+  #include "gcode/sensor/M407.h"
+#endif
 
-      case 355: // M355 set case light brightness
-        gcode_M355();
-        break;
+void quickstop_stepper() {
+  stepper.quick_stop();
+  stepper.synchronize();
+  set_current_from_steppers_for_axis(ALL_AXES);
+  SYNC_PLAN_POSITION_KINEMATIC();
+}
 
-      #if ENABLED(DEBUG_GCODE_PARSER)
-        case 800:
-          parser.debug(); // GCode Parser Test for M
-          break;
-      #endif
+#if HAS_LEVELING
+  #include "gcode/calibrate/M420.h"
+  #include "gcode/calibrate/M421.h"
+#endif
 
-      #if ENABLED(I2C_POSITION_ENCODERS)
+#if HAS_M206_COMMAND
+  #include "gcode/geometry/M428.h"
+#endif
 
-        case 860: // M860 Report encoder module position
-          gcode_M860();
-          break;
+#include "gcode/eeprom/M500.h"
+#include "gcode/eeprom/M501.h"
+#include "gcode/eeprom/M502.h"
+#if DISABLED(DISABLE_M503)
+  #include "gcode/eeprom/M503.h"
+#endif
 
-        case 861: // M861 Report encoder module status
-          gcode_M861();
-          break;
+#if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
+  #include "gcode/config/M540.h"
+#endif
 
-        case 862: // M862 Perform axis test
-          gcode_M862();
-          break;
+#if HAS_BED_PROBE
+  #include "gcode/probe/M851.h"
+#endif
 
-        case 863: // M863 Calibrate steps/mm
-          gcode_M863();
-          break;
+#if ENABLED(ADVANCED_PAUSE_FEATURE)
+  #include "gcode/feature/pause/M600.h"
+#endif
 
-        case 864: // M864 Change module address
-          gcode_M864();
-          break;
+#if ENABLED(MK2_MULTIPLEXER)
+  #include "gcode/feature/snmm/M702.h"
+#endif
 
-        case 865: // M865 Check module firmware version
-          gcode_M865();
-          break;
+#if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
+  #include "gcode/control/M605.h"
+#endif
 
-        case 866: // M866 Report axis error count
-          gcode_M866();
-          break;
+#if ENABLED(LIN_ADVANCE)
+  #include "gcode/feature/advance/M900.h"
+#endif
 
-        case 867: // M867 Toggle error correction
-          gcode_M867();
-          break;
+#if ENABLED(HAVE_TMC2130)
+  #include "feature/tmc2130.h"
+  #include "gcode/feature/trinamic/M906.h"
+  #include "gcode/feature/trinamic/M911.h"
+  #include "gcode/feature/trinamic/M912.h"
+  #if ENABLED(HYBRID_THRESHOLD)
+    #include "gcode/feature/trinamic/M913.h"
+  #endif
+  #if ENABLED(SENSORLESS_HOMING)
+    #include "gcode/feature/trinamic/M914.h"
+  #endif
+#endif
 
-        case 868: // M868 Set error correction threshold
-          gcode_M868();
-          break;
+#include "gcode/feature/digipot/M907.h"
 
-        case 869: // M869 Report axis error
-          gcode_M869();
-          break;
+#if HAS_DIGIPOTSS || ENABLED(DAC_STEPPER_CURRENT)
+  #include "gcode/feature/digipot/M908.h"
+  #if ENABLED(DAC_STEPPER_CURRENT) // As with Printrbot RevF
+    #include "gcode/feature/digipot/M909.h"
+    #include "gcode/feature/digipot/M910.h"
+  #endif
+#endif
 
-      #endif // I2C_POSITION_ENCODERS
+#if HAS_MICROSTEPS
+  #include "gcode/control/M350.h"
+  #include "gcode/control/M351.h"
+#endif
 
-      case 999: // M999: Restart after being Stopped
-        gcode_M999();
-        break;
-    }
-    break;
+#include "gcode/feature/caselight/M355.h"
 
-    case 'T':
-      gcode_T(parser.codenum);
-      break;
+#if ENABLED(MIXING_EXTRUDER)
+  #include "gcode/feature/mixing/M163.h"
+  #if MIXING_VIRTUAL_TOOLS > 1
+    #include "gcode/feature/mixing/M164.h"
+  #endif
+  #if ENABLED(DIRECT_MIXING_IN_G1)
+    #include "gcode/feature/mixing/M165.h"
+  #endif
+#endif
 
-    default: parser.unknown_command_error();
-  }
+#include "gcode/control/M999.h"
 
-  KEEPALIVE_STATE(NOT_BUSY);
+#include "gcode/control/T.h"
 
-  ok_to_send();
-}
+#include "gcode/process_next_command.h"
 
 /**
  * Send a "Resend: nnn" message to the host to
  * indicate that a command needs to be re-sent.
  */
 void FlushSerialRequestResend() {
   //char command_queue[cmd_queue_index_r][100]="Resend:";
   MYSERIAL.flush();
   SERIAL_PROTOCOLPGM(MSG_RESEND);
   SERIAL_PROTOCOLLN(gcode_LastN + 1);
@@ -12444,192 +4723,20 @@ void prepare_move_to_destination() {
     #elif ENABLED(DUAL_X_CARRIAGE)
       prepare_move_to_destination_dualx() || prepare_move_to_destination_cartesian()
     #else
       prepare_move_to_destination_cartesian()
     #endif
   ) return;
 
   set_current_to_destination();
 }
 
-#if ENABLED(ARC_SUPPORT)
-
-  #if N_ARC_CORRECTION < 1
-    #undef N_ARC_CORRECTION
-    #define N_ARC_CORRECTION 1
-  #endif
-
-  /**
-   * Plan an arc in 2 dimensions
-   *
-   * The arc is approximated by generating many small linear segments.
-   * The length of each segment is configured in MM_PER_ARC_SEGMENT (Default 1mm)
-   * Arcs should only be made relatively large (over 5mm), as larger arcs with
-   * larger segments will tend to be more efficient. Your slicer should have
-   * options for G2/G3 arc generation. In future these options may be GCode tunable.
-   */
-  void plan_arc(
-    float logical[XYZE], // Destination position
-    float *offset,       // Center of rotation relative to current_position
-    uint8_t clockwise    // Clockwise?
-  ) {
-    #if ENABLED(CNC_WORKSPACE_PLANES)
-      AxisEnum p_axis, q_axis, l_axis;
-      switch (workspace_plane) {
-        case PLANE_XY: p_axis = X_AXIS; q_axis = Y_AXIS; l_axis = Z_AXIS; break;
-        case PLANE_ZX: p_axis = Z_AXIS; q_axis = X_AXIS; l_axis = Y_AXIS; break;
-        case PLANE_YZ: p_axis = Y_AXIS; q_axis = Z_AXIS; l_axis = X_AXIS; break;
-      }
-    #else
-      constexpr AxisEnum p_axis = X_AXIS, q_axis = Y_AXIS, l_axis = Z_AXIS;
-    #endif
-
-    // Radius vector from center to current location
-    float r_P = -offset[0], r_Q = -offset[1];
-
-    const float radius = HYPOT(r_P, r_Q),
-                center_P = current_position[p_axis] - r_P,
-                center_Q = current_position[q_axis] - r_Q,
-                rt_X = logical[p_axis] - center_P,
-                rt_Y = logical[q_axis] - center_Q,
-                linear_travel = logical[l_axis] - current_position[l_axis],
-                extruder_travel = logical[E_AXIS] - current_position[E_AXIS];
-
-    // CCW angle of rotation between position and target from the circle center. Only one atan2() trig computation required.
-    float angular_travel = ATAN2(r_P * rt_Y - r_Q * rt_X, r_P * rt_X + r_Q * rt_Y);
-    if (angular_travel < 0) angular_travel += RADIANS(360);
-    if (clockwise) angular_travel -= RADIANS(360);
-
-    // Make a circle if the angular rotation is 0 and the target is current position
-    if (angular_travel == 0 && current_position[p_axis] == logical[p_axis] && current_position[q_axis] == logical[q_axis])
-      angular_travel = RADIANS(360);
-
-    const float mm_of_travel = HYPOT(angular_travel * radius, FABS(linear_travel));
-    if (mm_of_travel < 0.001) return;
-
-    uint16_t segments = FLOOR(mm_of_travel / (MM_PER_ARC_SEGMENT));
-    if (segments == 0) segments = 1;
-
-    /**
-     * Vector rotation by transformation matrix: r is the original vector, r_T is the rotated vector,
-     * and phi is the angle of rotation. Based on the solution approach by Jens Geisler.
-     *     r_T = [cos(phi) -sin(phi);
-     *            sin(phi)  cos(phi)] * r ;
-     *
-     * For arc generation, the center of the circle is the axis of rotation and the radius vector is
-     * defined from the circle center to the initial position. Each line segment is formed by successive
-     * vector rotations. This requires only two cos() and sin() computations to form the rotation
-     * matrix for the duration of the entire arc. Error may accumulate from numerical round-off, since
-     * all double numbers are single precision on the Arduino. (True double precision will not have
-     * round off issues for CNC applications.) Single precision error can accumulate to be greater than
-     * tool precision in some cases. Therefore, arc path correction is implemented.
-     *
-     * Small angle approximation may be used to reduce computation overhead further. This approximation
-     * holds for everything, but very small circles and large MM_PER_ARC_SEGMENT values. In other words,
-     * theta_per_segment would need to be greater than 0.1 rad and N_ARC_CORRECTION would need to be large
-     * to cause an appreciable drift error. N_ARC_CORRECTION~=25 is more than small enough to correct for
-     * numerical drift error. N_ARC_CORRECTION may be on the order a hundred(s) before error becomes an
-     * issue for CNC machines with the single precision Arduino calculations.
-     *
-     * This approximation also allows plan_arc to immediately insert a line segment into the planner
-     * without the initial overhead of computing cos() or sin(). By the time the arc needs to be applied
-     * a correction, the planner should have caught up to the lag caused by the initial plan_arc overhead.
-     * This is important when there are successive arc motions.
-     */
-    // Vector rotation matrix values
-    float arc_target[XYZE];
-    const float theta_per_segment = angular_travel / segments,
-                linear_per_segment = linear_travel / segments,
-                extruder_per_segment = extruder_travel / segments,
-                sin_T = theta_per_segment,
-                cos_T = 1 - 0.5 * sq(theta_per_segment); // Small angle approximation
-
-    // Initialize the linear axis
-    arc_target[l_axis] = current_position[l_axis];
-
-    // Initialize the extruder axis
-    arc_target[E_AXIS] = current_position[E_AXIS];
-
-    const float fr_mm_s = MMS_SCALED(feedrate_mm_s);
-
-    millis_t next_idle_ms = millis() + 200UL;
-
-    #if N_ARC_CORRECTION > 1
-      int8_t arc_recalc_count = N_ARC_CORRECTION;
-    #endif
-
-    for (uint16_t i = 1; i < segments; i++) { // Iterate (segments-1) times
-
-      thermalManager.manage_heater();
-      if (ELAPSED(millis(), next_idle_ms)) {
-        next_idle_ms = millis() + 200UL;
-        idle();
-      }
-
-      #if N_ARC_CORRECTION > 1
-        if (--arc_recalc_count) {
-          // Apply vector rotation matrix to previous r_P / 1
-          const float r_new_Y = r_P * sin_T + r_Q * cos_T;
-          r_P = r_P * cos_T - r_Q * sin_T;
-          r_Q = r_new_Y;
-        }
-        else
-      #endif
-      {
-        #if N_ARC_CORRECTION > 1
-          arc_recalc_count = N_ARC_CORRECTION;
-        #endif
-
-        // Arc correction to radius vector. Computed only every N_ARC_CORRECTION increments.
-        // Compute exact location by applying transformation matrix from initial radius vector(=-offset).
-        // To reduce stuttering, the sin and cos could be computed at different times.
-        // For now, compute both at the same time.
-        const float cos_Ti = cos(i * theta_per_segment), sin_Ti = sin(i * theta_per_segment);
-        r_P = -offset[0] * cos_Ti + offset[1] * sin_Ti;
-        r_Q = -offset[0] * sin_Ti - offset[1] * cos_Ti;
-      }
-
-      // Update arc_target location
-      arc_target[p_axis] = center_P + r_P;
-      arc_target[q_axis] = center_Q + r_Q;
-      arc_target[l_axis] += linear_per_segment;
-      arc_target[E_AXIS] += extruder_per_segment;
-
-      clamp_to_software_endstops(arc_target);
-
-      planner.buffer_line_kinematic(arc_target, fr_mm_s, active_extruder);
-    }
-
-    // Ensure last segment arrives at target location.
-    planner.buffer_line_kinematic(logical, fr_mm_s, active_extruder);
-
-    // As far as the parser is concerned, the position is now == target. In reality the
-    // motion control system might still be processing the action and the real tool position
-    // in any intermediate location.
-    set_current_to_destination();
-  } // plan_arc
-
-#endif // ARC_SUPPORT
-
-#if ENABLED(BEZIER_CURVE_SUPPORT)
-
-  void plan_cubic_move(const float offset[4]) {
-    cubic_b_spline(current_position, destination, offset, MMS_SCALED(feedrate_mm_s), active_extruder);
-
-    // As far as the parser is concerned, the position is now == destination. In reality the
-    // motion control system might still be processing the action and the real tool position
-    // in any intermediate location.
-    set_current_to_destination();
-  }
-
-#endif // BEZIER_CURVE_SUPPORT
-
 #if ENABLED(USE_CONTROLLER_FAN)
 
   void controllerFan() {
     static millis_t lastMotorOn = 0, // Last time a motor was turned on
                     nextMotorCheck = 0; // Last time the state was checked
     const millis_t ms = millis();
     if (ELAPSED(ms, nextMotorCheck)) {
       nextMotorCheck = ms + 2500UL; // Not a time critical function, so only check every 2.5s
       if (X_ENABLE_READ == X_ENABLE_ON || Y_ENABLE_READ == Y_ENABLE_ON || Z_ENABLE_READ == Z_ENABLE_ON || thermalManager.soft_pwm_amount_bed > 0
           || E0_ENABLE_READ == E_ENABLE_ON // If any of the drivers are enabled...
@@ -12780,77 +4887,20 @@ void prepare_move_to_destination() {
   void handle_filament_runout() {
     if (!filament_ran_out) {
       filament_ran_out = true;
       enqueue_and_echo_commands_P(PSTR(FILAMENT_RUNOUT_SCRIPT));
       stepper.synchronize();
     }
   }
 
 #endif // FILAMENT_RUNOUT_SENSOR
 
-#if ENABLED(FAST_PWM_FAN)
-
-  void setPwmFrequency(uint8_t pin, int val) {
-    val &= 0x07;
-    switch (digitalPinToTimer(pin)) {
-      #ifdef TCCR0A
-        #if !AVR_AT90USB1286_FAMILY
-          case TIMER0A:
-        #endif
-        case TIMER0B:
-          //_SET_CS(0, val);
-          break;
-      #endif
-      #ifdef TCCR1A
-        case TIMER1A:
-        case TIMER1B:
-          //_SET_CS(1, val);
-          break;
-      #endif
-      #ifdef TCCR2
-        case TIMER2:
-        case TIMER2:
-          _SET_CS(2, val);
-          break;
-      #endif
-      #ifdef TCCR2A
-        case TIMER2A:
-        case TIMER2B:
-          _SET_CS(2, val);
-          break;
-      #endif
-      #ifdef TCCR3A
-        case TIMER3A:
-        case TIMER3B:
-        case TIMER3C:
-          _SET_CS(3, val);
-          break;
-      #endif
-      #ifdef TCCR4A
-        case TIMER4A:
-        case TIMER4B:
-        case TIMER4C:
-          _SET_CS(4, val);
-          break;
-      #endif
-      #ifdef TCCR5A
-        case TIMER5A:
-        case TIMER5B:
-        case TIMER5C:
-          _SET_CS(5, val);
-          break;
-      #endif
-    }
-  }
-
-#endif // FAST_PWM_FAN
-
 float calculate_volumetric_multiplier(const float diameter) {
   if (!volumetric_enabled || diameter == 0) return 1.0;
   return 1.0 / (M_PI * sq(diameter * 0.5));
 }
 
 void calculate_volumetric_multipliers() {
   for (uint8_t i = 0; i < COUNT(filament_size); i++)
     volumetric_multiplier[i] = calculate_volumetric_multiplier(filament_size[i]);
 }
 
@@ -12873,120 +4923,20 @@ void disable_e_steppers() {
   disable_E4();
 }
 
 void disable_all_steppers() {
   disable_X();
   disable_Y();
   disable_Z();
   disable_e_steppers();
 }
 
-#if ENABLED(HAVE_TMC2130)
-
-  void automatic_current_control(TMC2130Stepper &st, String axisID) {
-    // Check otpw even if we don't use automatic control. Allows for flag inspection.
-    const bool is_otpw = st.checkOT();
-
-    // Report if a warning was triggered
-    static bool previous_otpw = false;
-    if (is_otpw && !previous_otpw) {
-      char timestamp[10];
-      duration_t elapsed = print_job_timer.duration();
-      const bool has_days = (elapsed.value > 60*60*24L);
-      (void)elapsed.toDigital(timestamp, has_days);
-      SERIAL_ECHO(timestamp);
-      SERIAL_ECHOPGM(": ");
-      SERIAL_ECHO(axisID);
-      SERIAL_ECHOLNPGM(" driver overtemperature warning!");
-    }
-    previous_otpw = is_otpw;
-
-    #if CURRENT_STEP > 0 && ENABLED(AUTOMATIC_CURRENT_CONTROL)
-      // Return if user has not enabled current control start with M906 S1.
-      if (!auto_current_control) return;
-
-      /**
-       * Decrease current if is_otpw is true.
-       * Bail out if driver is disabled.
-       * Increase current if OTPW has not been triggered yet.
-       */
-      uint16_t current = st.getCurrent();
-      if (is_otpw) {
-        st.setCurrent(current - CURRENT_STEP, R_SENSE, HOLD_MULTIPLIER);
-        #if ENABLED(REPORT_CURRENT_CHANGE)
-          SERIAL_ECHO(axisID);
-          SERIAL_ECHOPAIR(" current decreased to ", st.getCurrent());
-        #endif
-      }
-
-      else if (!st.isEnabled())
-        return;
-
-      else if (!is_otpw && !st.getOTPW()) {
-        current += CURRENT_STEP;
-        if (current <= AUTO_ADJUST_MAX) {
-          st.setCurrent(current, R_SENSE, HOLD_MULTIPLIER);
-          #if ENABLED(REPORT_CURRENT_CHANGE)
-            SERIAL_ECHO(axisID);
-            SERIAL_ECHOPAIR(" current increased to ", st.getCurrent());
-          #endif
-        }
-      }
-      SERIAL_EOL();
-    #endif
-  }
-
-  void checkOverTemp() {
-    static millis_t next_cOT = 0;
-    if (ELAPSED(millis(), next_cOT)) {
-      next_cOT = millis() + 5000;
-      #if ENABLED(X_IS_TMC2130)
-        automatic_current_control(stepperX, "X");
-      #endif
-      #if ENABLED(Y_IS_TMC2130)
-        automatic_current_control(stepperY, "Y");
-      #endif
-      #if ENABLED(Z_IS_TMC2130)
-        automatic_current_control(stepperZ, "Z");
-      #endif
-      #if ENABLED(X2_IS_TMC2130)
-        automatic_current_control(stepperX2, "X2");
-      #endif
-      #if ENABLED(Y2_IS_TMC2130)
-        automatic_current_control(stepperY2, "Y2");
-      #endif
-      #if ENABLED(Z2_IS_TMC2130)
-        automatic_current_control(stepperZ2, "Z2");
-      #endif
-      #if ENABLED(E0_IS_TMC2130)
-        automatic_current_control(stepperE0, "E0");
-      #endif
-      #if ENABLED(E1_IS_TMC2130)
-        automatic_current_control(stepperE1, "E1");
-      #endif
-      #if ENABLED(E2_IS_TMC2130)
-        automatic_current_control(stepperE2, "E2");
-      #endif
-      #if ENABLED(E3_IS_TMC2130)
-        automatic_current_control(stepperE3, "E3");
-      #endif
-      #if ENABLED(E4_IS_TMC2130)
-        automatic_current_control(stepperE4, "E4");
-      #endif
-      #if ENABLED(E4_IS_TMC2130)
-        automatic_current_control(stepperE4);
-      #endif
-    }
-  }
-
-#endif // HAVE_TMC2130
-
 /**
  * Manage several activities:
  *  - Check for Filament Runout
  *  - Keep the command buffer full
  *  - Check for maximum inactive time between commands
  *  - Check for maximum inactive time between stepper commands
  *  - Check if pin CHDK needs to go LOW
  *  - Check for KILL button held down
  *  - Check for HOME button held down
  *  - Check if cooling fan needs to be switched on
@@ -13148,21 +5098,21 @@ void manage_inactivity(bool ignore_stepper_queue/*=false*/) {
       set_destination_to_current();
       prepare_move_to_destination();
     }
   #endif
 
   #if ENABLED(TEMP_STAT_LEDS)
     handle_status_leds();
   #endif
 
   #if ENABLED(HAVE_TMC2130)
-    checkOverTemp();
+    tmc2130_checkOverTemp();
   #endif
 
   planner.check_axes_activity();
 }
 
 /**
  * Standard idle routine keeps the machine alive
  */
 void idle(
   #if ENABLED(ADVANCED_PAUSE_FEATURE)
@@ -13376,21 +5326,21 @@ void setup() {
     case_light_on = CASE_LIGHT_DEFAULT_ON;
     case_light_brightness = CASE_LIGHT_DEFAULT_BRIGHTNESS;
     update_case_light();
   #endif
 
   #if ENABLED(SPINDLE_LASER_ENABLE)
     OUT_WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);  // init spindle to off
     #if SPINDLE_DIR_CHANGE
       OUT_WRITE(SPINDLE_DIR_PIN, SPINDLE_INVERT_DIR ? 255 : 0);  // init rotation to clockwise (M3)
     #endif
-    #if ENABLED(SPINDLE_LASER_PWM)
+    #if ENABLED(SPINDLE_LASER_PWM) && defined(SPINDLE_LASER_PWM_PIN) && SPINDLE_LASER_PWM_PIN >= 0
       SET_OUTPUT(SPINDLE_LASER_PWM_PIN);
       analogWrite(SPINDLE_LASER_PWM_PIN, SPINDLE_LASER_PWM_INVERT ? 255 : 0);  // set to lowest speed
     #endif
   #endif
 
   #if HAS_BED_PROBE
     endstops.enable_z_probe(false);
   #endif
 
   #if ENABLED(USE_CONTROLLER_FAN)

commit 142d8aae567d6646c01e6336789a1f6e69db3f43
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Sep 7 22:08:13 2017 -0500

    Move debugging to serial.*

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
index b652b0ff38..ffe9cdc868 100644
--- a/Marlin/src/Marlin.cpp
+++ b/Marlin/src/Marlin.cpp
@@ -342,22 +342,20 @@
   unified_bed_leveling ubl;
   #define UBL_MESH_VALID !( ( ubl.z_values[0][0] == ubl.z_values[0][1] && ubl.z_values[0][1] == ubl.z_values[0][2] \
                            && ubl.z_values[1][0] == ubl.z_values[1][1] && ubl.z_values[1][1] == ubl.z_values[1][2] \
                            && ubl.z_values[2][0] == ubl.z_values[2][1] && ubl.z_values[2][1] == ubl.z_values[2][2] \
                            && ubl.z_values[0][0] == 0 && ubl.z_values[1][0] == 0 && ubl.z_values[2][0] == 0 )  \
                            || isnan(ubl.z_values[0][0]))
 #endif
 
 bool Running = true;
 
-uint8_t marlin_debug_flags = DEBUG_NONE;
-
 /**
  * Cartesian Current Position
  *   Used to track the logical position as moves are queued.
  *   Used by 'line_to_current_position' to do a move after changing it.
  *   Used by 'SYNC_PLAN_POSITION_KINEMATIC' to update 'planner.position'.
  */
 float current_position[XYZE] = { 0.0 };
 
 /**
  * Cartesian Destination
@@ -725,45 +723,20 @@ void set_current_from_steppers_for_axis(const AxisEnum axis);
 #endif
 
 #if ENABLED(BEZIER_CURVE_SUPPORT)
   void plan_cubic_move(const float offset[4]);
 #endif
 
 void tool_change(const uint8_t tmp_extruder, const float fr_mm_s=0.0, bool no_move=false);
 void report_current_position();
 void report_current_position_detail();
 
-#if ENABLED(DEBUG_LEVELING_FEATURE)
-  void print_xyz(const char* prefix, const char* suffix, const float x, const float y, const float z) {
-    serialprintPGM(prefix);
-    SERIAL_CHAR('(');
-    SERIAL_ECHO(x);
-    SERIAL_ECHOPAIR(", ", y);
-    SERIAL_ECHOPAIR(", ", z);
-    SERIAL_CHAR(')');
-    if (suffix) serialprintPGM(suffix); else SERIAL_EOL();
-  }
-
-  void print_xyz(const char* prefix, const char* suffix, const float xyz[]) {
-    print_xyz(prefix, suffix, xyz[X_AXIS], xyz[Y_AXIS], xyz[Z_AXIS]);
-  }
-
-  #if HAS_ABL
-    void print_xyz(const char* prefix, const char* suffix, const vector_3 &xyz) {
-      print_xyz(prefix, suffix, xyz.x, xyz.y, xyz.z);
-    }
-  #endif
-
-  #define DEBUG_POS(SUFFIX,VAR) do { \
-    print_xyz(PSTR("  " STRINGIFY(VAR) "="), PSTR(" : " SUFFIX "\n"), VAR); }while(0)
-#endif
-
 /**
  * sync_plan_position
  *
  * Set the planner/stepper positions directly from current_position with
  * no kinematic translation. Used for homing axes and cartesian/core syncing.
  */
 void sync_plan_position() {
   #if ENABLED(DEBUG_LEVELING_FEATURE)
     if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position", current_position);
   #endif

commit 48351fd6d5163acfbe52953700f7cdbdb3dcecab
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 6 06:28:29 2017 -0500

    Move root sources

diff --git a/Marlin/src/Marlin.cpp b/Marlin/src/Marlin.cpp
new file mode 100644
index 0000000000..b652b0ff38
--- /dev/null
+++ b/Marlin/src/Marlin.cpp
@@ -0,0 +1,13603 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016, 2017 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * About Marlin
+ *
+ * This firmware is a mashup between Sprinter and grbl.
+ *  - https://github.com/kliment/Sprinter
+ *  - https://github.com/simen/grbl/tree
+ */
+
+/**
+ * -----------------
+ * G-Codes in Marlin
+ * -----------------
+ *
+ * Helpful G-code references:
+ *  - http://linuxcnc.org/handbook/gcode/g-code.html
+ *  - http://objects.reprap.org/wiki/Mendel_User_Manual:_RepRapGCodes
+ *
+ * Help to document Marlin's G-codes online:
+ *  - http://reprap.org/wiki/G-code
+ *  - https://github.com/MarlinFirmware/MarlinDocumentation
+ *
+ * -----------------
+ *
+ * "G" Codes
+ *
+ * G0   -> G1
+ * G1   - Coordinated Movement X Y Z E
+ * G2   - CW ARC
+ * G3   - CCW ARC
+ * G4   - Dwell S<seconds> or P<milliseconds>
+ * G5   - Cubic B-spline with XYZE destination and IJPQ offsets
+ * G10  - Retract filament according to settings of M207 (Requires FWRETRACT)
+ * G11  - Retract recover filament according to settings of M208 (Requires FWRETRACT)
+ * G12  - Clean tool (Requires NOZZLE_CLEAN_FEATURE)
+ * G17  - Select Plane XY (Requires CNC_WORKSPACE_PLANES)
+ * G18  - Select Plane ZX (Requires CNC_WORKSPACE_PLANES)
+ * G19  - Select Plane YZ (Requires CNC_WORKSPACE_PLANES)
+ * G20  - Set input units to inches (Requires INCH_MODE_SUPPORT)
+ * G21  - Set input units to millimeters (Requires INCH_MODE_SUPPORT)
+ * G26  - Mesh Validation Pattern (Requires UBL_G26_MESH_VALIDATION)
+ * G27  - Park Nozzle (Requires NOZZLE_PARK_FEATURE)
+ * G28  - Home one or more axes
+ * G29  - Start or continue the bed leveling probe procedure (Requires bed leveling)
+ * G30  - Single Z probe, probes bed at X Y location (defaults to current XY location)
+ * G31  - Dock sled (Z_PROBE_SLED only)
+ * G32  - Undock sled (Z_PROBE_SLED only)
+ * G33  - Delta Auto-Calibration (Requires DELTA_AUTO_CALIBRATION)
+ * G38  - Probe in any direction using the Z_MIN_PROBE (Requires G38_PROBE_TARGET)
+ * G42  - Coordinated move to a mesh point (Requires AUTO_BED_LEVELING_UBL)
+ * G90  - Use Absolute Coordinates
+ * G91  - Use Relative Coordinates
+ * G92  - Set current position to coordinates given
+ *
+ * "M" Codes
+ *
+ * M0   - Unconditional stop - Wait for user to press a button on the LCD (Only if ULTRA_LCD is enabled)
+ * M1   -> M0
+ * M3   - Turn laser/spindle on, set spindle/laser speed/power, set rotation to clockwise
+ * M4   - Turn laser/spindle on, set spindle/laser speed/power, set rotation to counter-clockwise
+ * M5   - Turn laser/spindle off
+ * M17  - Enable/Power all stepper motors
+ * M18  - Disable all stepper motors; same as M84
+ * M20  - List SD card. (Requires SDSUPPORT)
+ * M21  - Init SD card. (Requires SDSUPPORT)
+ * M22  - Release SD card. (Requires SDSUPPORT)
+ * M23  - Select SD file: "M23 /path/file.gco". (Requires SDSUPPORT)
+ * M24  - Start/resume SD print. (Requires SDSUPPORT)
+ * M25  - Pause SD print. (Requires SDSUPPORT)
+ * M26  - Set SD position in bytes: "M26 S12345". (Requires SDSUPPORT)
+ * M27  - Report SD print status. (Requires SDSUPPORT)
+ * M28  - Start SD write: "M28 /path/file.gco". (Requires SDSUPPORT)
+ * M29  - Stop SD write. (Requires SDSUPPORT)
+ * M30  - Delete file from SD: "M30 /path/file.gco"
+ * M31  - Report time since last M109 or SD card start to serial.
+ * M32  - Select file and start SD print: "M32 [S<bytepos>] !/path/file.gco#". (Requires SDSUPPORT)
+ *        Use P to run other files as sub-programs: "M32 P !filename#"
+ *        The '#' is necessary when calling from within sd files, as it stops buffer prereading
+ * M33  - Get the longname version of a path. (Requires LONG_FILENAME_HOST_SUPPORT)
+ * M34  - Set SD Card sorting options. (Requires SDCARD_SORT_ALPHA)
+ * M42  - Change pin status via gcode: M42 P<pin> S<value>. LED pin assumed if P is omitted.
+ * M43  - Display pin status, watch pins for changes, watch endstops & toggle LED, Z servo probe test, toggle pins
+ * M48  - Measure Z Probe repeatability: M48 P<points> X<pos> Y<pos> V<level> E<engage> L<legs>. (Requires Z_MIN_PROBE_REPEATABILITY_TEST)
+ * M75  - Start the print job timer.
+ * M76  - Pause the print job timer.
+ * M77  - Stop the print job timer.
+ * M78  - Show statistical information about the print jobs. (Requires PRINTCOUNTER)
+ * M80  - Turn on Power Supply. (Requires POWER_SUPPLY > 0)
+ * M81  - Turn off Power Supply. (Requires POWER_SUPPLY > 0)
+ * M82  - Set E codes absolute (default).
+ * M83  - Set E codes relative while in Absolute (G90) mode.
+ * M84  - Disable steppers until next move, or use S<seconds> to specify an idle
+ *        duration after which steppers should turn off. S0 disables the timeout.
+ * M85  - Set inactivity shutdown timer with parameter S<seconds>. To disable set zero (default)
+ * M92  - Set planner.axis_steps_per_mm for one or more axes.
+ * M100 - Watch Free Memory (for debugging) (Requires M100_FREE_MEMORY_WATCHER)
+ * M104 - Set extruder target temp.
+ * M105 - Report current temperatures.
+ * M106 - Fan on.
+ * M107 - Fan off.
+ * M108 - Break out of heating loops (M109, M190, M303). With no controller, breaks out of M0/M1. (Requires EMERGENCY_PARSER)
+ * M109 - Sxxx Wait for extruder current temp to reach target temp. Waits only when heating
+ *        Rxxx Wait for extruder current temp to reach target temp. Waits when heating and cooling
+ *        If AUTOTEMP is enabled, S<mintemp> B<maxtemp> F<factor>. Exit autotemp by any M109 without F
+ * M110 - Set the current line number. (Used by host printing)
+ * M111 - Set debug flags: "M111 S<flagbits>". See flag bits defined in enum.h.
+ * M112 - Emergency stop.
+ * M113 - Get or set the timeout interval for Host Keepalive "busy" messages. (Requires HOST_KEEPALIVE_FEATURE)
+ * M114 - Report current position.
+ * M115 - Report capabilities. (Extended capabilities requires EXTENDED_CAPABILITIES_REPORT)
+ * M117 - Display a message on the controller screen. (Requires an LCD)
+ * M118 - Display a message in the host console.
+ * M119 - Report endstops status.
+ * M120 - Enable endstops detection.
+ * M121 - Disable endstops detection.
+ * M125 - Save current position and move to filament change position. (Requires PARK_HEAD_ON_PAUSE)
+ * M126 - Solenoid Air Valve Open. (Requires BARICUDA)
+ * M127 - Solenoid Air Valve Closed. (Requires BARICUDA)
+ * M128 - EtoP Open. (Requires BARICUDA)
+ * M129 - EtoP Closed. (Requires BARICUDA)
+ * M140 - Set bed target temp. S<temp>
+ * M145 - Set heatup values for materials on the LCD. H<hotend> B<bed> F<fan speed> for S<material> (0=PLA, 1=ABS)
+ * M149 - Set temperature units. (Requires TEMPERATURE_UNITS_SUPPORT)
+ * M150 - Set Status LED Color as R<red> U<green> B<blue>. Values 0-255. (Requires BLINKM, RGB_LED, RGBW_LED, or PCA9632)
+ * M155 - Auto-report temperatures with interval of S<seconds>. (Requires AUTO_REPORT_TEMPERATURES)
+ * M163 - Set a single proportion for a mixing extruder. (Requires MIXING_EXTRUDER)
+ * M164 - Save the mix as a virtual extruder. (Requires MIXING_EXTRUDER and MIXING_VIRTUAL_TOOLS)
+ * M165 - Set the proportions for a mixing extruder. Use parameters ABCDHI to set the mixing factors. (Requires MIXING_EXTRUDER)
+ * M190 - Sxxx Wait for bed current temp to reach target temp. ** Waits only when heating! **
+ *        Rxxx Wait for bed current temp to reach target temp. ** Waits for heating or cooling. **
+ * M200 - Set filament diameter, D<diameter>, setting E axis units to cubic. (Use S0 to revert to linear units.)
+ * M201 - Set max acceleration in units/s^2 for print moves: "M201 X<accel> Y<accel> Z<accel> E<accel>"
+ * M202 - Set max acceleration in units/s^2 for travel moves: "M202 X<accel> Y<accel> Z<accel> E<accel>" ** UNUSED IN MARLIN! **
+ * M203 - Set maximum feedrate: "M203 X<fr> Y<fr> Z<fr> E<fr>" in units/sec.
+ * M204 - Set default acceleration in units/sec^2: P<printing> R<extruder_only> T<travel>
+ * M205 - Set advanced settings. Current units apply:
+            S<print> T<travel> minimum speeds
+            B<minimum segment time>
+            X<max X jerk>, Y<max Y jerk>, Z<max Z jerk>, E<max E jerk>
+ * M206 - Set additional homing offset. (Disabled by NO_WORKSPACE_OFFSETS or DELTA)
+ * M207 - Set Retract Length: S<length>, Feedrate: F<units/min>, and Z lift: Z<distance>. (Requires FWRETRACT)
+ * M208 - Set Recover (unretract) Additional (!) Length: S<length> and Feedrate: F<units/min>. (Requires FWRETRACT)
+ * M209 - Turn Automatic Retract Detection on/off: S<0|1> (For slicers that don't support G10/11). (Requires FWRETRACT)
+          Every normal extrude-only move will be classified as retract depending on the direction.
+ * M211 - Enable, Disable, and/or Report software endstops: S<0|1> (Requires MIN_SOFTWARE_ENDSTOPS or MAX_SOFTWARE_ENDSTOPS)
+ * M218 - Set a tool offset: "M218 T<index> X<offset> Y<offset>". (Requires 2 or more extruders)
+ * M220 - Set Feedrate Percentage: "M220 S<percent>" (i.e., "FR" on the LCD)
+ * M221 - Set Flow Percentage: "M221 S<percent>"
+ * M226 - Wait until a pin is in a given state: "M226 P<pin> S<state>"
+ * M240 - Trigger a camera to take a photograph. (Requires CHDK or PHOTOGRAPH_PIN)
+ * M250 - Set LCD contrast: "M250 C<contrast>" (0-63). (Requires LCD support)
+ * M260 - i2c Send Data (Requires EXPERIMENTAL_I2CBUS)
+ * M261 - i2c Request Data (Requires EXPERIMENTAL_I2CBUS)
+ * M280 - Set servo position absolute: "M280 P<index> S<angle|µs>". (Requires servos)
+ * M300 - Play beep sound S<frequency Hz> P<duration ms>
+ * M301 - Set PID parameters P I and D. (Requires PIDTEMP)
+ * M302 - Allow cold extrudes, or set the minimum extrude S<temperature>. (Requires PREVENT_COLD_EXTRUSION)
+ * M303 - PID relay autotune S<temperature> sets the target temperature. Default 150C. (Requires PIDTEMP)
+ * M304 - Set bed PID parameters P I and D. (Requires PIDTEMPBED)
+ * M350 - Set microstepping mode. (Requires digital microstepping pins.)
+ * M351 - Toggle MS1 MS2 pins directly. (Requires digital microstepping pins.)
+ * M355 - Set Case Light on/off and set brightness. (Requires CASE_LIGHT_PIN)
+ * M380 - Activate solenoid on active extruder. (Requires EXT_SOLENOID)
+ * M381 - Disable all solenoids. (Requires EXT_SOLENOID)
+ * M400 - Finish all moves.
+ * M401 - Lower Z probe. (Requires a probe)
+ * M402 - Raise Z probe. (Requires a probe)
+ * M404 - Display or set the Nominal Filament Width: "W<diameter>". (Requires FILAMENT_WIDTH_SENSOR)
+ * M405 - Enable Filament Sensor flow control. "M405 D<delay_cm>". (Requires FILAMENT_WIDTH_SENSOR)
+ * M406 - Disable Filament Sensor flow control. (Requires FILAMENT_WIDTH_SENSOR)
+ * M407 - Display measured filament diameter in millimeters. (Requires FILAMENT_WIDTH_SENSOR)
+ * M410 - Quickstop. Abort all planned moves.
+ * M420 - Enable/Disable Leveling (with current values) S1=enable S0=disable (Requires MESH_BED_LEVELING or ABL)
+ * M421 - Set a single Z coordinate in the Mesh Leveling grid. X<units> Y<units> Z<units> (Requires MESH_BED_LEVELING or AUTO_BED_LEVELING_UBL)
+ * M428 - Set the home_offset based on the current_position. Nearest edge applies. (Disabled by NO_WORKSPACE_OFFSETS or DELTA)
+ * M500 - Store parameters in EEPROM. (Requires EEPROM_SETTINGS)
+ * M501 - Restore parameters from EEPROM. (Requires EEPROM_SETTINGS)
+ * M502 - Revert to the default "factory settings". ** Does not write them to EEPROM! **
+ * M503 - Print the current settings (in memory): "M503 S<verbose>". S0 specifies compact output.
+ * M540 - Enable/disable SD card abort on endstop hit: "M540 S<state>". (Requires ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
+ * M600 - Pause for filament change: "M600 X<pos> Y<pos> Z<raise> E<first_retract> L<later_retract>". (Requires ADVANCED_PAUSE_FEATURE)
+ * M665 - Set delta configurations: "M665 L<diagonal rod> R<delta radius> S<segments/s> A<rod A trim mm> B<rod B trim mm> C<rod C trim mm> I<tower A trim angle> J<tower B trim angle> K<tower C trim angle>" (Requires DELTA)
+ * M666 - Set delta endstop adjustment. (Requires DELTA)
+ * M605 - Set dual x-carriage movement mode: "M605 S<mode> [X<x_offset>] [R<temp_offset>]". (Requires DUAL_X_CARRIAGE)
+ * M851 - Set Z probe's Z offset in current units. (Negative = below the nozzle.)
+ * M860 - Report the position of position encoder modules.
+ * M861 - Report the status of position encoder modules.
+ * M862 - Perform an axis continuity test for position encoder modules.
+ * M863 - Perform steps-per-mm calibration for position encoder modules.
+ * M864 - Change position encoder module I2C address.
+ * M865 - Check position encoder module firmware version.
+ * M866 - Report or reset position encoder module error count.
+ * M867 - Enable/disable or toggle error correction for position encoder modules.
+ * M868 - Report or set position encoder module error correction threshold.
+ * M869 - Report position encoder module error.
+ * M900 - Get and/or Set advance K factor and WH/D ratio. (Requires LIN_ADVANCE)
+ * M906 - Set or get motor current in milliamps using axis codes X, Y, Z, E. Report values if no axis codes given. (Requires HAVE_TMC2130)
+ * M907 - Set digital trimpot motor current using axis codes. (Requires a board with digital trimpots)
+ * M908 - Control digital trimpot directly. (Requires DAC_STEPPER_CURRENT or DIGIPOTSS_PIN)
+ * M909 - Print digipot/DAC current value. (Requires DAC_STEPPER_CURRENT)
+ * M910 - Commit digipot/DAC value to external EEPROM via I2C. (Requires DAC_STEPPER_CURRENT)
+ * M911 - Report stepper driver overtemperature pre-warn condition. (Requires HAVE_TMC2130)
+ * M912 - Clear stepper driver overtemperature pre-warn condition flag. (Requires HAVE_TMC2130)
+ * M913 - Set HYBRID_THRESHOLD speed. (Requires HYBRID_THRESHOLD)
+ * M914 - Set SENSORLESS_HOMING sensitivity. (Requires SENSORLESS_HOMING)
+ *
+ * M360 - SCARA calibration: Move to cal-position ThetaA (0 deg calibration)
+ * M361 - SCARA calibration: Move to cal-position ThetaB (90 deg calibration - steps per degree)
+ * M362 - SCARA calibration: Move to cal-position PsiA (0 deg calibration)
+ * M363 - SCARA calibration: Move to cal-position PsiB (90 deg calibration - steps per degree)
+ * M364 - SCARA calibration: Move to cal-position PSIC (90 deg to Theta calibration position)
+ *
+ * ************ Custom codes - This can change to suit future G-code regulations
+ * M928 - Start SD logging: "M928 filename.gco". Stop with M29. (Requires SDSUPPORT)
+ * M999 - Restart after being stopped by error
+ *
+ * "T" Codes
+ *
+ * T0-T3 - Select an extruder (tool) by index: "T<n> F<units/min>"
+ *
+ */
+
+#include "Marlin.h"
+
+#include "ultralcd.h"
+#include "planner.h"
+#include "stepper.h"
+#include "endstops.h"
+#include "temperature.h"
+#include "cardreader.h"
+#include "configuration_store.h"
+#include "language.h"
+#ifdef ARDUINO
+  #include "pins_arduino.h"
+#endif
+#include "math.h"
+#include "nozzle.h"
+#include "duration_t.h"
+#include "types.h"
+#include "gcode.h"
+
+#if HAS_ABL
+  #include "vector_3.h"
+  #if ENABLED(AUTO_BED_LEVELING_LINEAR)
+    #include "least_squares_fit.h"
+  #endif
+#elif ENABLED(MESH_BED_LEVELING)
+  #include "mesh_bed_leveling.h"
+#endif
+
+#if ENABLED(BEZIER_CURVE_SUPPORT)
+  #include "planner_bezier.h"
+#endif
+
+#if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER)
+  #include "buzzer.h"
+#endif
+
+#if ENABLED(MAX7219_DEBUG)
+  #include "Max7219_Debug_LEDs.h"
+#endif
+
+#if ENABLED(NEOPIXEL_RGBW_LED)
+  #include <Adafruit_NeoPixel.h>
+#endif
+
+#if ENABLED(BLINKM)
+  #include "blinkm.h"
+  #include "Wire.h"
+#endif
+
+#if ENABLED(PCA9632)
+  #include "pca9632.h"
+#endif
+
+#if HAS_SERVOS
+  #include "src/HAL/servo.h"
+#endif
+
+#if HAS_DIGIPOTSS
+  #include <SPI.h>
+#endif
+
+#if ENABLED(DAC_STEPPER_CURRENT)
+  #include "stepper_dac.h"
+#endif
+
+#if ENABLED(EXPERIMENTAL_I2CBUS)
+  #include "twibus.h"
+#endif
+
+#if ENABLED(I2C_POSITION_ENCODERS)
+  #include "I2CPositionEncoder.h"
+#endif
+
+#if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
+  #include "src/HAL/HAL_endstop_interrupts.h"
+#endif
+
+#if ENABLED(M100_FREE_MEMORY_WATCHER)
+  void gcode_M100();
+  void M100_dump_routine(const char * const title, const char *start, const char *end);
+#endif
+
+#if ENABLED(SDSUPPORT)
+  CardReader card;
+#endif
+
+#if ENABLED(EXPERIMENTAL_I2CBUS)
+  TWIBus i2c;
+#endif
+
+#if ENABLED(G38_PROBE_TARGET)
+  bool G38_move = false,
+       G38_endstop_hit = false;
+#endif
+
+#if ENABLED(AUTO_BED_LEVELING_UBL)
+  #include "ubl.h"
+  extern bool defer_return_to_status;
+  unified_bed_leveling ubl;
+  #define UBL_MESH_VALID !( ( ubl.z_values[0][0] == ubl.z_values[0][1] && ubl.z_values[0][1] == ubl.z_values[0][2] \
+                           && ubl.z_values[1][0] == ubl.z_values[1][1] && ubl.z_values[1][1] == ubl.z_values[1][2] \
+                           && ubl.z_values[2][0] == ubl.z_values[2][1] && ubl.z_values[2][1] == ubl.z_values[2][2] \
+                           && ubl.z_values[0][0] == 0 && ubl.z_values[1][0] == 0 && ubl.z_values[2][0] == 0 )  \
+                           || isnan(ubl.z_values[0][0]))
+#endif
+
+bool Running = true;
+
+uint8_t marlin_debug_flags = DEBUG_NONE;
+
+/**
+ * Cartesian Current Position
+ *   Used to track the logical position as moves are queued.
+ *   Used by 'line_to_current_position' to do a move after changing it.
+ *   Used by 'SYNC_PLAN_POSITION_KINEMATIC' to update 'planner.position'.
+ */
+float current_position[XYZE] = { 0.0 };
+
+/**
+ * Cartesian Destination
+ *   A temporary position, usually applied to 'current_position'.
+ *   Set with 'gcode_get_destination' or 'set_destination_to_current'.
+ *   'line_to_destination' sets 'current_position' to 'destination'.
+ */
+float destination[XYZE] = { 0.0 };
+
+/**
+ * axis_homed
+ *   Flags that each linear axis was homed.
+ *   XYZ on cartesian, ABC on delta, ABZ on SCARA.
+ *
+ * axis_known_position
+ *   Flags that the position is known in each linear axis. Set when homed.
+ *   Cleared whenever a stepper powers off, potentially losing its position.
+ */
+bool axis_homed[XYZ] = { false }, axis_known_position[XYZ] = { false };
+
+/**
+ * GCode line number handling. Hosts may opt to include line numbers when
+ * sending commands to Marlin, and lines will be checked for sequentiality.
+ * M110 N<int> sets the current line number.
+ */
+static long gcode_N, gcode_LastN, Stopped_gcode_LastN = 0;
+
+/**
+ * GCode Command Queue
+ * A simple ring buffer of BUFSIZE command strings.
+ *
+ * Commands are copied into this buffer by the command injectors
+ * (immediate, serial, sd card) and they are processed sequentially by
+ * the main loop. The process_next_command function parses the next
+ * command and hands off execution to individual handler functions.
+ */
+uint8_t commands_in_queue = 0; // Count of commands in the queue
+static uint8_t cmd_queue_index_r = 0, // Ring buffer read position
+               cmd_queue_index_w = 0; // Ring buffer write position
+#if ENABLED(M100_FREE_MEMORY_WATCHER)
+  char command_queue[BUFSIZE][MAX_CMD_SIZE];  // Necessary so M100 Free Memory Dumper can show us the commands and any corruption
+#else                                         // This can be collapsed back to the way it was soon.
+static char command_queue[BUFSIZE][MAX_CMD_SIZE];
+#endif
+
+/**
+ * Next Injected Command pointer. NULL if no commands are being injected.
+ * Used by Marlin internally to ensure that commands initiated from within
+ * are enqueued ahead of any pending serial or sd card commands.
+ */
+static const char *injected_commands_P = NULL;
+
+#if ENABLED(TEMPERATURE_UNITS_SUPPORT)
+  TempUnit input_temp_units = TEMPUNIT_C;
+#endif
+
+/**
+ * Feed rates are often configured with mm/m
+ * but the planner and stepper like mm/s units.
+ */
+static const float homing_feedrate_mm_s[] PROGMEM = {
+  #if ENABLED(DELTA)
+    MMM_TO_MMS(HOMING_FEEDRATE_Z), MMM_TO_MMS(HOMING_FEEDRATE_Z),
+  #else
+    MMM_TO_MMS(HOMING_FEEDRATE_XY), MMM_TO_MMS(HOMING_FEEDRATE_XY),
+  #endif
+  MMM_TO_MMS(HOMING_FEEDRATE_Z), 0
+};
+FORCE_INLINE float homing_feedrate(const AxisEnum a) { return pgm_read_float(&homing_feedrate_mm_s[a]); }
+
+float feedrate_mm_s = MMM_TO_MMS(1500.0);
+static float saved_feedrate_mm_s;
+int16_t feedrate_percentage = 100, saved_feedrate_percentage,
+    flow_percentage[EXTRUDERS] = ARRAY_BY_EXTRUDERS1(100);
+
+// Initialized by settings.load()
+bool axis_relative_modes[] = AXIS_RELATIVE_MODES,
+     volumetric_enabled;
+float filament_size[EXTRUDERS], volumetric_multiplier[EXTRUDERS];
+
+#if HAS_WORKSPACE_OFFSET
+  #if HAS_POSITION_SHIFT
+    // The distance that XYZ has been offset by G92. Reset by G28.
+    float position_shift[XYZ] = { 0 };
+  #endif
+  #if HAS_HOME_OFFSET
+    // This offset is added to the configured home position.
+    // Set by M206, M428, or menu item. Saved to EEPROM.
+    float home_offset[XYZ] = { 0 };
+  #endif
+  #if HAS_HOME_OFFSET && HAS_POSITION_SHIFT
+    // The above two are combined to save on computes
+    float workspace_offset[XYZ] = { 0 };
+  #endif
+#endif
+
+// Software Endstops are based on the configured limits.
+#if HAS_SOFTWARE_ENDSTOPS
+  bool soft_endstops_enabled = true;
+#endif
+float soft_endstop_min[XYZ] = { X_MIN_BED, Y_MIN_BED, Z_MIN_POS },
+      soft_endstop_max[XYZ] = { X_MAX_BED, Y_MAX_BED, Z_MAX_POS };
+
+#if FAN_COUNT > 0
+  int16_t fanSpeeds[FAN_COUNT] = { 0 };
+  #if ENABLED(PROBING_FANS_OFF)
+    bool fans_paused = false;
+    int16_t paused_fanSpeeds[FAN_COUNT] = { 0 };
+  #endif
+#endif
+
+// The active extruder (tool). Set with T<extruder> command.
+uint8_t active_extruder = 0;
+
+// Relative Mode. Enable with G91, disable with G90.
+static bool relative_mode = false;
+
+// For M109 and M190, this flag may be cleared (by M108) to exit the wait loop
+volatile bool wait_for_heatup = true;
+
+// For M0/M1, this flag may be cleared (by M108) to exit the wait-for-user loop
+#if HAS_RESUME_CONTINUE
+  volatile bool wait_for_user = false;
+#endif
+
+const char axis_codes[XYZE] = { 'X', 'Y', 'Z', 'E' };
+
+// Number of characters read in the current line of serial input
+static int serial_count = 0;
+
+// Inactivity shutdown
+millis_t previous_cmd_ms = 0;
+static millis_t max_inactive_time = 0;
+static millis_t stepper_inactive_time = (DEFAULT_STEPPER_DEACTIVE_TIME) * 1000UL;
+
+// Print Job Timer
+#if ENABLED(PRINTCOUNTER)
+  PrintCounter print_job_timer = PrintCounter();
+#else
+  Stopwatch print_job_timer = Stopwatch();
+#endif
+
+// Buzzer - I2C on the LCD or a BEEPER_PIN
+#if ENABLED(LCD_USE_I2C_BUZZER)
+  #define BUZZ(d,f) lcd_buzz(d, f)
+#elif PIN_EXISTS(BEEPER)
+  Buzzer buzzer;
+  #define BUZZ(d,f) buzzer.tone(d, f)
+#else
+  #define BUZZ(d,f) NOOP
+#endif
+
+static uint8_t target_extruder;
+
+#if HAS_BED_PROBE
+  float zprobe_zoffset; // Initialized by settings.load()
+#endif
+
+#if HAS_ABL
+  float xy_probe_feedrate_mm_s = MMM_TO_MMS(XY_PROBE_SPEED);
+  #define XY_PROBE_FEEDRATE_MM_S xy_probe_feedrate_mm_s
+#elif defined(XY_PROBE_SPEED)
+  #define XY_PROBE_FEEDRATE_MM_S MMM_TO_MMS(XY_PROBE_SPEED)
+#else
+  #define XY_PROBE_FEEDRATE_MM_S PLANNER_XY_FEEDRATE()
+#endif
+
+#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
+  #if ENABLED(DELTA)
+    #define ADJUST_DELTA(V) \
+      if (planner.abl_enabled) { \
+        const float zadj = bilinear_z_offset(V); \
+        delta[A_AXIS] += zadj; \
+        delta[B_AXIS] += zadj; \
+        delta[C_AXIS] += zadj; \
+      }
+  #else
+    #define ADJUST_DELTA(V) if (planner.abl_enabled) { delta[Z_AXIS] += bilinear_z_offset(V); }
+  #endif
+#elif IS_KINEMATIC
+  #define ADJUST_DELTA(V) NOOP
+#endif
+
+#if ENABLED(Z_DUAL_ENDSTOPS)
+  float z_endstop_adj;
+#endif
+
+// Extruder offsets
+#if HOTENDS > 1
+  float hotend_offset[XYZ][HOTENDS]; // Initialized by settings.load()
+#endif
+
+#if HAS_Z_SERVO_ENDSTOP
+  const int z_servo_angle[2] = Z_SERVO_ANGLES;
+#endif
+
+#if ENABLED(BARICUDA)
+  uint8_t baricuda_valve_pressure = 0,
+          baricuda_e_to_p_pressure = 0;
+#endif
+
+#if ENABLED(FWRETRACT)                      // Initialized by settings.load()...
+  bool autoretract_enabled,                 // M209 S - Autoretract switch
+       retracted[EXTRUDERS] = { false };    // Which extruders are currently retracted
+  float retract_length,                     // M207 S - G10 Retract length
+        retract_feedrate_mm_s,              // M207 F - G10 Retract feedrate
+        retract_zlift,                      // M207 Z - G10 Retract hop size
+        retract_recover_length,             // M208 S - G11 Recover length
+        retract_recover_feedrate_mm_s,      // M208 F - G11 Recover feedrate
+        swap_retract_length,                // M207 W - G10 Swap Retract length
+        swap_retract_recover_length,        // M208 W - G11 Swap Recover length
+        swap_retract_recover_feedrate_mm_s; // M208 R - G11 Swap Recover feedrate
+  #if EXTRUDERS > 1
+    bool retracted_swap[EXTRUDERS] = { false }; // Which extruders are swap-retracted
+  #else
+    constexpr bool retracted_swap[1] = { false };
+  #endif
+#endif // FWRETRACT
+
+#if HAS_POWER_SWITCH
+  bool powersupply_on =
+    #if ENABLED(PS_DEFAULT_OFF)
+      false
+    #else
+      true
+    #endif
+  ;
+#endif
+
+#if ENABLED(DELTA)
+
+  float delta[ABC],
+        endstop_adj[ABC] = { 0 };
+
+  // Initialized by settings.load()
+  float delta_radius,
+        delta_tower_angle_trim[2],
+        delta_tower[ABC][2],
+        delta_diagonal_rod,
+        delta_calibration_radius,
+        delta_diagonal_rod_2_tower[ABC],
+        delta_segments_per_second,
+        delta_clip_start_height = Z_MAX_POS;
+
+  float delta_safe_distance_from_top();
+
+#endif
+
+#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
+  int bilinear_grid_spacing[2], bilinear_start[2];
+  float bilinear_grid_factor[2],
+        z_values[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
+#endif
+
+#if IS_SCARA
+  // Float constants for SCARA calculations
+  const float L1 = SCARA_LINKAGE_1, L2 = SCARA_LINKAGE_2,
+              L1_2 = sq(float(L1)), L1_2_2 = 2.0 * L1_2,
+              L2_2 = sq(float(L2));
+
+  float delta_segments_per_second = SCARA_SEGMENTS_PER_SECOND,
+        delta[ABC];
+#endif
+
+float cartes[XYZ] = { 0 };
+
+#if ENABLED(FILAMENT_WIDTH_SENSOR)
+  bool filament_sensor = false;                                 // M405 turns on filament sensor control. M406 turns it off.
+  float filament_width_nominal = DEFAULT_NOMINAL_FILAMENT_DIA,  // Nominal filament width. Change with M404.
+        filament_width_meas = DEFAULT_MEASURED_FILAMENT_DIA;    // Measured filament diameter
+  uint8_t meas_delay_cm = MEASUREMENT_DELAY_CM,                 // Distance delay setting
+          measurement_delay[MAX_MEASUREMENT_DELAY + 1];         // Ring buffer to delayed measurement. Store extruder factor after subtracting 100
+  int8_t filwidth_delay_index[2] = { 0, -1 };                   // Indexes into ring buffer
+#endif
+
+#if ENABLED(FILAMENT_RUNOUT_SENSOR)
+  static bool filament_ran_out = false;
+#endif
+
+#if ENABLED(ADVANCED_PAUSE_FEATURE)
+  AdvancedPauseMenuResponse advanced_pause_menu_response;
+#endif
+
+#if ENABLED(MIXING_EXTRUDER)
+  float mixing_factor[MIXING_STEPPERS]; // Reciprocal of mix proportion. 0.0 = off, otherwise >= 1.0.
+  #if MIXING_VIRTUAL_TOOLS > 1
+    float mixing_virtual_tool_mix[MIXING_VIRTUAL_TOOLS][MIXING_STEPPERS];
+  #endif
+#endif
+
+static bool send_ok[BUFSIZE];
+
+#if HAS_SERVOS
+  HAL_SERVO_LIB servo[NUM_SERVOS];
+  #define MOVE_SERVO(I, P) servo[I].move(P)
+  #if HAS_Z_SERVO_ENDSTOP
+    #define DEPLOY_Z_SERVO() MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[0])
+    #define STOW_Z_SERVO() MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[1])
+  #endif
+#endif
+
+#ifdef CHDK
+  millis_t chdkHigh = 0;
+  bool chdkActive = false;
+#endif
+
+#ifdef AUTOMATIC_CURRENT_CONTROL
+  bool auto_current_control = 0;
+#endif
+
+#if ENABLED(PID_EXTRUSION_SCALING)
+  int lpq_len = 20;
+#endif
+
+#if ENABLED(HOST_KEEPALIVE_FEATURE)
+  MarlinBusyState busy_state = NOT_BUSY;
+  static millis_t next_busy_signal_ms = 0;
+  uint8_t host_keepalive_interval = DEFAULT_KEEPALIVE_INTERVAL;
+#else
+  #define host_keepalive() NOOP
+#endif
+
+#if ENABLED(I2C_POSITION_ENCODERS)
+  I2CPositionEncodersMgr I2CPEM;
+  uint8_t blockBufferIndexRef = 0;
+  millis_t lastUpdateMillis;
+#endif
+
+#if ENABLED(CNC_WORKSPACE_PLANES)
+  static WorkspacePlane workspace_plane = PLANE_XY;
+#endif
+
+FORCE_INLINE float pgm_read_any(const float *p) { return pgm_read_float_near(p); }
+FORCE_INLINE signed char pgm_read_any(const signed char *p) { return pgm_read_byte_near(p); }
+
+#define XYZ_CONSTS_FROM_CONFIG(type, array, CONFIG) \
+  static const PROGMEM type array##_P[XYZ] = { X_##CONFIG, Y_##CONFIG, Z_##CONFIG }; \
+  static inline type array(AxisEnum axis) { return pgm_read_any(&array##_P[axis]); } \
+  typedef void __void_##CONFIG##__
+
+XYZ_CONSTS_FROM_CONFIG(float, base_min_pos,   MIN_POS);
+XYZ_CONSTS_FROM_CONFIG(float, base_max_pos,   MAX_POS);
+XYZ_CONSTS_FROM_CONFIG(float, base_home_pos,  HOME_POS);
+XYZ_CONSTS_FROM_CONFIG(float, max_length,     MAX_LENGTH);
+XYZ_CONSTS_FROM_CONFIG(float, home_bump_mm,   HOME_BUMP_MM);
+XYZ_CONSTS_FROM_CONFIG(signed char, home_dir, HOME_DIR);
+
+/**
+ * ***************************************************************************
+ * ******************************** FUNCTIONS ********************************
+ * ***************************************************************************
+ */
+
+void stop();
+
+void get_available_commands();
+void process_next_command();
+void prepare_move_to_destination();
+
+void get_cartesian_from_steppers();
+void set_current_from_steppers_for_axis(const AxisEnum axis);
+
+#if ENABLED(ARC_SUPPORT)
+  void plan_arc(float target[XYZE], float* offset, uint8_t clockwise);
+#endif
+
+#if ENABLED(BEZIER_CURVE_SUPPORT)
+  void plan_cubic_move(const float offset[4]);
+#endif
+
+void tool_change(const uint8_t tmp_extruder, const float fr_mm_s=0.0, bool no_move=false);
+void report_current_position();
+void report_current_position_detail();
+
+#if ENABLED(DEBUG_LEVELING_FEATURE)
+  void print_xyz(const char* prefix, const char* suffix, const float x, const float y, const float z) {
+    serialprintPGM(prefix);
+    SERIAL_CHAR('(');
+    SERIAL_ECHO(x);
+    SERIAL_ECHOPAIR(", ", y);
+    SERIAL_ECHOPAIR(", ", z);
+    SERIAL_CHAR(')');
+    if (suffix) serialprintPGM(suffix); else SERIAL_EOL();
+  }
+
+  void print_xyz(const char* prefix, const char* suffix, const float xyz[]) {
+    print_xyz(prefix, suffix, xyz[X_AXIS], xyz[Y_AXIS], xyz[Z_AXIS]);
+  }
+
+  #if HAS_ABL
+    void print_xyz(const char* prefix, const char* suffix, const vector_3 &xyz) {
+      print_xyz(prefix, suffix, xyz.x, xyz.y, xyz.z);
+    }
+  #endif
+
+  #define DEBUG_POS(SUFFIX,VAR) do { \
+    print_xyz(PSTR("  " STRINGIFY(VAR) "="), PSTR(" : " SUFFIX "\n"), VAR); }while(0)
+#endif
+
+/**
+ * sync_plan_position
+ *
+ * Set the planner/stepper positions directly from current_position with
+ * no kinematic translation. Used for homing axes and cartesian/core syncing.
+ */
+void sync_plan_position() {
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position", current_position);
+  #endif
+  planner.set_position_mm(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
+}
+inline void sync_plan_position_e() { planner.set_e_position_mm(current_position[E_AXIS]); }
+
+#if IS_KINEMATIC
+
+  inline void sync_plan_position_kinematic() {
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) DEBUG_POS("sync_plan_position_kinematic", current_position);
+    #endif
+    planner.set_position_mm_kinematic(current_position);
+  }
+  #define SYNC_PLAN_POSITION_KINEMATIC() sync_plan_position_kinematic()
+
+#else
+
+  #define SYNC_PLAN_POSITION_KINEMATIC() sync_plan_position()
+
+#endif
+
+#if ENABLED(DIGIPOT_I2C)
+  extern void digipot_i2c_set_current(uint8_t channel, float current);
+  extern void digipot_i2c_init();
+#endif
+
+/**
+ * Inject the next "immediate" command, when possible, onto the front of the queue.
+ * Return true if any immediate commands remain to inject.
+ */
+static bool drain_injected_commands_P() {
+  if (injected_commands_P != NULL) {
+    size_t i = 0;
+    char c, cmd[30];
+    strncpy_P(cmd, injected_commands_P, sizeof(cmd) - 1);
+    cmd[sizeof(cmd) - 1] = '\0';
+    while ((c = cmd[i]) && c != '\n') i++; // find the end of this gcode command
+    cmd[i] = '\0';
+    if (enqueue_and_echo_command(cmd))     // success?
+      injected_commands_P = c ? injected_commands_P + i + 1 : NULL; // next command or done
+  }
+  return (injected_commands_P != NULL);    // return whether any more remain
+}
+
+/**
+ * Record one or many commands to run from program memory.
+ * Aborts the current queue, if any.
+ * Note: drain_injected_commands_P() must be called repeatedly to drain the commands afterwards
+ */
+void enqueue_and_echo_commands_P(const char * const pgcode) {
+  injected_commands_P = pgcode;
+  drain_injected_commands_P(); // first command executed asap (when possible)
+}
+
+/**
+ * Clear the Marlin command queue
+ */
+void clear_command_queue() {
+  cmd_queue_index_r = cmd_queue_index_w;
+  commands_in_queue = 0;
+}
+
+/**
+ * Once a new command is in the ring buffer, call this to commit it
+ */
+inline void _commit_command(bool say_ok) {
+  send_ok[cmd_queue_index_w] = say_ok;
+  if (++cmd_queue_index_w >= BUFSIZE) cmd_queue_index_w = 0;
+  commands_in_queue++;
+}
+
+/**
+ * Copy a command from RAM into the main command buffer.
+ * Return true if the command was successfully added.
+ * Return false for a full buffer, or if the 'command' is a comment.
+ */
+inline bool _enqueuecommand(const char* cmd, bool say_ok=false) {
+  if (*cmd == ';' || commands_in_queue >= BUFSIZE) return false;
+  strcpy(command_queue[cmd_queue_index_w], cmd);
+  _commit_command(say_ok);
+  return true;
+}
+
+/**
+ * Enqueue with Serial Echo
+ */
+bool enqueue_and_echo_command(const char* cmd, bool say_ok/*=false*/) {
+  if (_enqueuecommand(cmd, say_ok)) {
+    SERIAL_ECHO_START();
+    SERIAL_ECHOPAIR(MSG_ENQUEUEING, cmd);
+    SERIAL_CHAR('"');
+    SERIAL_EOL();
+    return true;
+  }
+  return false;
+}
+
+void setup_killpin() {
+  #if HAS_KILL
+    SET_INPUT_PULLUP(KILL_PIN);
+  #endif
+}
+
+#if ENABLED(FILAMENT_RUNOUT_SENSOR)
+
+  void setup_filrunoutpin() {
+    #if ENABLED(ENDSTOPPULLUP_FIL_RUNOUT)
+      SET_INPUT_PULLUP(FIL_RUNOUT_PIN);
+    #else
+      SET_INPUT(FIL_RUNOUT_PIN);
+    #endif
+  }
+
+#endif
+
+void setup_powerhold() {
+  #if HAS_SUICIDE
+    OUT_WRITE(SUICIDE_PIN, HIGH);
+  #endif
+  #if HAS_POWER_SWITCH
+    #if ENABLED(PS_DEFAULT_OFF)
+      OUT_WRITE(PS_ON_PIN, PS_ON_ASLEEP);
+    #else
+      OUT_WRITE(PS_ON_PIN, PS_ON_AWAKE);
+    #endif
+  #endif
+}
+
+void suicide() {
+  #if HAS_SUICIDE
+    OUT_WRITE(SUICIDE_PIN, LOW);
+  #endif
+}
+
+void servo_init() {
+  #if NUM_SERVOS >= 1 && HAS_SERVO_0
+    servo[0].attach(SERVO0_PIN);
+    servo[0].detach(); // Just set up the pin. We don't have a position yet. Don't move to a random position.
+  #endif
+  #if NUM_SERVOS >= 2 && HAS_SERVO_1
+    servo[1].attach(SERVO1_PIN);
+    servo[1].detach();
+  #endif
+  #if NUM_SERVOS >= 3 && HAS_SERVO_2
+    servo[2].attach(SERVO2_PIN);
+    servo[2].detach();
+  #endif
+  #if NUM_SERVOS >= 4 && HAS_SERVO_3
+    servo[3].attach(SERVO3_PIN);
+    servo[3].detach();
+  #endif
+
+  #if HAS_Z_SERVO_ENDSTOP
+    /**
+     * Set position of Z Servo Endstop
+     *
+     * The servo might be deployed and positioned too low to stow
+     * when starting up the machine or rebooting the board.
+     * There's no way to know where the nozzle is positioned until
+     * homing has been done - no homing with z-probe without init!
+     *
+     */
+    STOW_Z_SERVO();
+  #endif
+}
+
+/**
+ * Stepper Reset (RigidBoard, et.al.)
+ */
+#if HAS_STEPPER_RESET
+  void disableStepperDrivers() {
+    OUT_WRITE(STEPPER_RESET_PIN, LOW);  // drive it down to hold in reset motor driver chips
+  }
+  void enableStepperDrivers() { SET_INPUT(STEPPER_RESET_PIN); }  // set to input, which allows it to be pulled high by pullups
+#endif
+
+#if ENABLED(EXPERIMENTAL_I2CBUS) && I2C_SLAVE_ADDRESS > 0
+
+  void i2c_on_receive(int bytes) { // just echo all bytes received to serial
+    i2c.receive(bytes);
+  }
+
+  void i2c_on_request() {          // just send dummy data for now
+    i2c.reply("Hello World!\n");
+  }
+
+#endif
+
+#if HAS_COLOR_LEDS
+
+  #if ENABLED(NEOPIXEL_RGBW_LED)
+
+    Adafruit_NeoPixel pixels(NEOPIXEL_PIXELS, NEOPIXEL_PIN, NEO_GRBW + NEO_KHZ800);
+
+    void set_neopixel_color(const uint32_t color) {
+      for (uint16_t i = 0; i < pixels.numPixels(); ++i)
+        pixels.setPixelColor(i, color);
+      pixels.show();
+    }
+
+    void setup_neopixel() {
+      pixels.setBrightness(255); // 0 - 255 range
+      pixels.begin();
+      pixels.show(); // initialize to all off
+
+      #if ENABLED(NEOPIXEL_STARTUP_TEST)
+        delay(2000);
+        set_neopixel_color(pixels.Color(255, 0, 0, 0));  // red
+        delay(2000);
+        set_neopixel_color(pixels.Color(0, 255, 0, 0));  // green
+        delay(2000);
+        set_neopixel_color(pixels.Color(0, 0, 255, 0));  // blue
+        delay(2000);
+      #endif
+      set_neopixel_color(pixels.Color(0, 0, 0, 255));    // white
+    }
+
+  #endif // NEOPIXEL_RGBW_LED
+
+  void set_led_color(
+    const uint8_t r, const uint8_t g, const uint8_t b
+      #if ENABLED(RGBW_LED) || ENABLED(NEOPIXEL_RGBW_LED)
+        , const uint8_t w = 0
+        #if ENABLED(NEOPIXEL_RGBW_LED)
+          , bool isSequence = false
+        #endif
+      #endif
+  ) {
+
+    #if ENABLED(NEOPIXEL_RGBW_LED)
+
+      const uint32_t color = pixels.Color(r, g, b, w);
+      static uint16_t nextLed = 0;
+
+      if (!isSequence)
+        set_neopixel_color(color);
+      else {
+        pixels.setPixelColor(nextLed, color);
+        pixels.show();
+        if (++nextLed >= pixels.numPixels()) nextLed = 0;
+        return;
+      }
+
+    #endif
+
+    #if ENABLED(BLINKM)
+
+      // This variant uses i2c to send the RGB components to the device.
+      SendColors(r, g, b);
+
+    #endif
+
+    #if ENABLED(RGB_LED) || ENABLED(RGBW_LED)
+
+      // This variant uses 3 separate pins for the RGB components.
+      // If the pins can do PWM then their intensity will be set.
+      WRITE(RGB_LED_R_PIN, r ? HIGH : LOW);
+      WRITE(RGB_LED_G_PIN, g ? HIGH : LOW);
+      WRITE(RGB_LED_B_PIN, b ? HIGH : LOW);
+      analogWrite(RGB_LED_R_PIN, r);
+      analogWrite(RGB_LED_G_PIN, g);
+      analogWrite(RGB_LED_B_PIN, b);
+
+      #if ENABLED(RGBW_LED)
+        WRITE(RGB_LED_W_PIN, w ? HIGH : LOW);
+        analogWrite(RGB_LED_W_PIN, w);
+      #endif
+
+    #endif
+
+    #if ENABLED(PCA9632)
+      // Update I2C LED driver
+      PCA9632_SetColor(r, g, b);
+    #endif
+  }
+
+#endif // HAS_COLOR_LEDS
+
+void gcode_line_error(const char* err, bool doFlush = true) {
+  SERIAL_ERROR_START();
+  serialprintPGM(err);
+  SERIAL_ERRORLN(gcode_LastN);
+  //Serial.println(gcode_N);
+  if (doFlush) FlushSerialRequestResend();
+  serial_count = 0;
+}
+
+/**
+ * Get all commands waiting on the serial port and queue them.
+ * Exit when the buffer is full or when no more characters are
+ * left on the serial port.
+ */
+inline void get_serial_commands() {
+  static char serial_line_buffer[MAX_CMD_SIZE];
+  static bool serial_comment_mode = false;
+
+  // If the command buffer is empty for too long,
+  // send "wait" to indicate Marlin is still waiting.
+  #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0
+    static millis_t last_command_time = 0;
+    const millis_t ms = millis();
+    if (commands_in_queue == 0 && !MYSERIAL.available() && ELAPSED(ms, last_command_time + NO_TIMEOUTS)) {
+      SERIAL_ECHOLNPGM(MSG_WAIT);
+      last_command_time = ms;
+    }
+  #endif
+
+  /**
+   * Loop while serial characters are incoming and the queue is not full
+   */
+  while (commands_in_queue < BUFSIZE && MYSERIAL.available() > 0) {
+
+    char serial_char = MYSERIAL.read();
+
+    /**
+     * If the character ends the line
+     */
+    if (serial_char == '\n' || serial_char == '\r') {
+
+      serial_comment_mode = false; // end of line == end of comment
+
+      if (!serial_count) continue; // skip empty lines
+
+      serial_line_buffer[serial_count] = 0; // terminate string
+      serial_count = 0; //reset buffer
+
+      char* command = serial_line_buffer;
+
+      while (*command == ' ') command++; // skip any leading spaces
+      char *npos = (*command == 'N') ? command : NULL, // Require the N parameter to start the line
+           *apos = strchr(command, '*');
+
+      if (npos) {
+
+        bool M110 = strstr_P(command, PSTR("M110")) != NULL;
+
+        if (M110) {
+          char* n2pos = strchr(command + 4, 'N');
+          if (n2pos) npos = n2pos;
+        }
+
+        gcode_N = strtol(npos + 1, NULL, 10);
+
+        if (gcode_N != gcode_LastN + 1 && !M110) {
+          gcode_line_error(PSTR(MSG_ERR_LINE_NO));
+          return;
+        }
+
+        if (apos) {
+          byte checksum = 0, count = 0;
+          while (command[count] != '*') checksum ^= command[count++];
+
+          if (strtol(apos + 1, NULL, 10) != checksum) {
+            gcode_line_error(PSTR(MSG_ERR_CHECKSUM_MISMATCH));
+            return;
+          }
+          // if no errors, continue parsing
+        }
+        else {
+          gcode_line_error(PSTR(MSG_ERR_NO_CHECKSUM));
+          return;
+        }
+
+        gcode_LastN = gcode_N;
+        // if no errors, continue parsing
+      }
+      else if (apos) { // No '*' without 'N'
+        gcode_line_error(PSTR(MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM), false);
+        return;
+      }
+
+      // Movement commands alert when stopped
+      if (IsStopped()) {
+        char* gpos = strchr(command, 'G');
+        if (gpos) {
+          const int codenum = strtol(gpos + 1, NULL, 10);
+          switch (codenum) {
+            case 0:
+            case 1:
+            case 2:
+            case 3:
+              SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
+              LCD_MESSAGEPGM(MSG_STOPPED);
+              break;
+          }
+        }
+      }
+
+      #if DISABLED(EMERGENCY_PARSER)
+        // If command was e-stop process now
+        if (strcmp(command, "M108") == 0) {
+          wait_for_heatup = false;
+          #if ENABLED(ULTIPANEL)
+            wait_for_user = false;
+          #endif
+        }
+        if (strcmp(command, "M112") == 0) kill(PSTR(MSG_KILLED));
+        if (strcmp(command, "M410") == 0) { quickstop_stepper(); }
+      #endif
+
+      #if defined(NO_TIMEOUTS) && NO_TIMEOUTS > 0
+        last_command_time = ms;
+      #endif
+
+      // Add the command to the queue
+      _enqueuecommand(serial_line_buffer, true);
+    }
+    else if (serial_count >= MAX_CMD_SIZE - 1) {
+      // Keep fetching, but ignore normal characters beyond the max length
+      // The command will be injected when EOL is reached
+    }
+    else if (serial_char == '\\') {  // Handle escapes
+      if (MYSERIAL.available() > 0) {
+        // if we have one more character, copy it over
+        serial_char = MYSERIAL.read();
+        if (!serial_comment_mode) serial_line_buffer[serial_count++] = serial_char;
+      }
+      // otherwise do nothing
+    }
+    else { // it's not a newline, carriage return or escape char
+      if (serial_char == ';') serial_comment_mode = true;
+      if (!serial_comment_mode) serial_line_buffer[serial_count++] = serial_char;
+    }
+
+  } // queue has space, serial has data
+}
+
+#if ENABLED(SDSUPPORT)
+
+  /**
+   * Get commands from the SD Card until the command buffer is full
+   * or until the end of the file is reached. The special character '#'
+   * can also interrupt buffering.
+   */
+  inline void get_sdcard_commands() {
+    static bool stop_buffering = false,
+                sd_comment_mode = false;
+
+    if (!card.sdprinting) return;
+
+    /**
+     * '#' stops reading from SD to the buffer prematurely, so procedural
+     * macro calls are possible. If it occurs, stop_buffering is triggered
+     * and the buffer is run dry; this character _can_ occur in serial com
+     * due to checksums, however, no checksums are used in SD printing.
+     */
+
+    if (commands_in_queue == 0) stop_buffering = false;
+
+    uint16_t sd_count = 0;
+    bool card_eof = card.eof();
+    while (commands_in_queue < BUFSIZE && !card_eof && !stop_buffering) {
+      const int16_t n = card.get();
+      char sd_char = (char)n;
+      card_eof = card.eof();
+      if (card_eof || n == -1
+          || sd_char == '\n' || sd_char == '\r'
+          || ((sd_char == '#' || sd_char == ':') && !sd_comment_mode)
+      ) {
+        if (card_eof) {
+          SERIAL_PROTOCOLLNPGM(MSG_FILE_PRINTED);
+          card.printingHasFinished();
+          #if ENABLED(PRINTER_EVENT_LEDS)
+            LCD_MESSAGEPGM(MSG_INFO_COMPLETED_PRINTS);
+            set_led_color(0, 255, 0); // Green
+            #if HAS_RESUME_CONTINUE
+              enqueue_and_echo_commands_P(PSTR("M0")); // end of the queue!
+            #else
+              safe_delay(1000);
+            #endif
+            set_led_color(0, 0, 0);   // OFF
+          #endif
+          card.checkautostart(true);
+        }
+        else if (n == -1) {
+          SERIAL_ERROR_START();
+          SERIAL_ECHOLNPGM(MSG_SD_ERR_READ);
+        }
+        if (sd_char == '#') stop_buffering = true;
+
+        sd_comment_mode = false; // for new command
+
+        if (!sd_count) continue; // skip empty lines (and comment lines)
+
+        command_queue[cmd_queue_index_w][sd_count] = '\0'; // terminate string
+        sd_count = 0; // clear sd line buffer
+
+        _commit_command(false);
+      }
+      else if (sd_count >= MAX_CMD_SIZE - 1) {
+        /**
+         * Keep fetching, but ignore normal characters beyond the max length
+         * The command will be injected when EOL is reached
+         */
+      }
+      else {
+        if (sd_char == ';') sd_comment_mode = true;
+        if (!sd_comment_mode) command_queue[cmd_queue_index_w][sd_count++] = sd_char;
+      }
+    }
+  }
+
+#endif // SDSUPPORT
+
+/**
+ * Add to the circular command queue the next command from:
+ *  - The command-injection queue (injected_commands_P)
+ *  - The active serial input (usually USB)
+ *  - The SD card file being actively printed
+ */
+void get_available_commands() {
+
+  // if any immediate commands remain, don't get other commands yet
+  if (drain_injected_commands_P()) return;
+
+  get_serial_commands();
+
+  #if ENABLED(SDSUPPORT)
+    get_sdcard_commands();
+  #endif
+}
+
+/**
+ * Set target_extruder from the T parameter or the active_extruder
+ *
+ * Returns TRUE if the target is invalid
+ */
+bool get_target_extruder_from_command(const uint16_t code) {
+  if (parser.seenval('T')) {
+    const int8_t e = parser.value_byte();
+    if (e >= EXTRUDERS) {
+      SERIAL_ECHO_START();
+      SERIAL_CHAR('M');
+      SERIAL_ECHO(code);
+      SERIAL_ECHOLNPAIR(" " MSG_INVALID_EXTRUDER " ", e);
+      return true;
+    }
+    target_extruder = e;
+  }
+  else
+    target_extruder = active_extruder;
+
+  return false;
+}
+
+#if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
+  bool extruder_duplication_enabled = false; // Used in Dual X mode 2
+#endif
+
+#if ENABLED(DUAL_X_CARRIAGE)
+
+  static DualXMode dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
+
+  static float x_home_pos(const int extruder) {
+    if (extruder == 0)
+      return LOGICAL_X_POSITION(base_home_pos(X_AXIS));
+    else
+      /**
+       * In dual carriage mode the extruder offset provides an override of the
+       * second X-carriage position when homed - otherwise X2_HOME_POS is used.
+       * This allows soft recalibration of the second extruder home position
+       * without firmware reflash (through the M218 command).
+       */
+      return LOGICAL_X_POSITION(hotend_offset[X_AXIS][1] > 0 ? hotend_offset[X_AXIS][1] : X2_HOME_POS);
+  }
+
+  static int x_home_dir(const int extruder) { return extruder ? X2_HOME_DIR : X_HOME_DIR; }
+
+  static float inactive_extruder_x_pos = X2_MAX_POS; // used in mode 0 & 1
+  static bool active_extruder_parked = false;        // used in mode 1 & 2
+  static float raised_parked_position[XYZE];         // used in mode 1
+  static millis_t delayed_move_time = 0;             // used in mode 1
+  static float duplicate_extruder_x_offset = DEFAULT_DUPLICATION_X_OFFSET; // used in mode 2
+  static int16_t duplicate_extruder_temp_offset = 0; // used in mode 2
+
+#endif // DUAL_X_CARRIAGE
+
+#if HAS_WORKSPACE_OFFSET || ENABLED(DUAL_X_CARRIAGE)
+
+  /**
+   * Software endstops can be used to monitor the open end of
+   * an axis that has a hardware endstop on the other end. Or
+   * they can prevent axes from moving past endstops and grinding.
+   *
+   * To keep doing their job as the coordinate system changes,
+   * the software endstop positions must be refreshed to remain
+   * at the same positions relative to the machine.
+   */
+  void update_software_endstops(const AxisEnum axis) {
+    const float offs = 0.0
+      #if HAS_HOME_OFFSET
+        + home_offset[axis]
+      #endif
+      #if HAS_POSITION_SHIFT
+        + position_shift[axis]
+      #endif
+    ;
+
+    #if HAS_HOME_OFFSET && HAS_POSITION_SHIFT
+      workspace_offset[axis] = offs;
+    #endif
+
+    #if ENABLED(DUAL_X_CARRIAGE)
+      if (axis == X_AXIS) {
+
+        // In Dual X mode hotend_offset[X] is T1's home position
+        float dual_max_x = max(hotend_offset[X_AXIS][1], X2_MAX_POS);
+
+        if (active_extruder != 0) {
+          // T1 can move from X2_MIN_POS to X2_MAX_POS or X2 home position (whichever is larger)
+          soft_endstop_min[X_AXIS] = X2_MIN_POS + offs;
+          soft_endstop_max[X_AXIS] = dual_max_x + offs;
+        }
+        else if (dual_x_carriage_mode == DXC_DUPLICATION_MODE) {
+          // In Duplication Mode, T0 can move as far left as X_MIN_POS
+          // but not so far to the right that T1 would move past the end
+          soft_endstop_min[X_AXIS] = base_min_pos(X_AXIS) + offs;
+          soft_endstop_max[X_AXIS] = min(base_max_pos(X_AXIS), dual_max_x - duplicate_extruder_x_offset) + offs;
+        }
+        else {
+          // In other modes, T0 can move from X_MIN_POS to X_MAX_POS
+          soft_endstop_min[axis] = base_min_pos(axis) + offs;
+          soft_endstop_max[axis] = base_max_pos(axis) + offs;
+        }
+      }
+    #elif ENABLED(DELTA)
+      soft_endstop_min[axis] = base_min_pos(axis) + (axis == Z_AXIS ? 0 : offs);
+      soft_endstop_max[axis] = base_max_pos(axis) + offs;
+    #else
+      soft_endstop_min[axis] = base_min_pos(axis) + offs;
+      soft_endstop_max[axis] = base_max_pos(axis) + offs;
+    #endif
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) {
+        SERIAL_ECHOPAIR("For ", axis_codes[axis]);
+        #if HAS_HOME_OFFSET
+          SERIAL_ECHOPAIR(" axis:\n home_offset = ", home_offset[axis]);
+        #endif
+        #if HAS_POSITION_SHIFT
+          SERIAL_ECHOPAIR("\n position_shift = ", position_shift[axis]);
+        #endif
+        SERIAL_ECHOPAIR("\n soft_endstop_min = ", soft_endstop_min[axis]);
+        SERIAL_ECHOLNPAIR("\n soft_endstop_max = ", soft_endstop_max[axis]);
+      }
+    #endif
+
+    #if ENABLED(DELTA)
+      if (axis == Z_AXIS)
+        delta_clip_start_height = soft_endstop_max[axis] - delta_safe_distance_from_top();
+    #endif
+  }
+
+#endif // HAS_WORKSPACE_OFFSET || DUAL_X_CARRIAGE
+
+#if HAS_M206_COMMAND
+  /**
+   * Change the home offset for an axis, update the current
+   * position and the software endstops to retain the same
+   * relative distance to the new home.
+   *
+   * Since this changes the current_position, code should
+   * call sync_plan_position soon after this.
+   */
+  static void set_home_offset(const AxisEnum axis, const float v) {
+    current_position[axis] += v - home_offset[axis];
+    home_offset[axis] = v;
+    update_software_endstops(axis);
+  }
+#endif // HAS_M206_COMMAND
+
+/**
+ * Set an axis' current position to its home position (after homing).
+ *
+ * For Core and Cartesian robots this applies one-to-one when an
+ * individual axis has been homed.
+ *
+ * DELTA should wait until all homing is done before setting the XYZ
+ * current_position to home, because homing is a single operation.
+ * In the case where the axis positions are already known and previously
+ * homed, DELTA could home to X or Y individually by moving either one
+ * to the center. However, homing Z always homes XY and Z.
+ *
+ * SCARA should wait until all XY homing is done before setting the XY
+ * current_position to home, because neither X nor Y is at home until
+ * both are at home. Z can however be homed individually.
+ *
+ * Callers must sync the planner position after calling this!
+ */
+static void set_axis_is_at_home(const AxisEnum axis) {
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) {
+      SERIAL_ECHOPAIR(">>> set_axis_is_at_home(", axis_codes[axis]);
+      SERIAL_CHAR(')');
+      SERIAL_EOL();
+    }
+  #endif
+
+  axis_known_position[axis] = axis_homed[axis] = true;
+
+  #if HAS_POSITION_SHIFT
+    position_shift[axis] = 0;
+    update_software_endstops(axis);
+  #endif
+
+  #if ENABLED(DUAL_X_CARRIAGE)
+    if (axis == X_AXIS && (active_extruder == 1 || dual_x_carriage_mode == DXC_DUPLICATION_MODE)) {
+      current_position[X_AXIS] = x_home_pos(active_extruder);
+      return;
+    }
+  #endif
+
+  #if ENABLED(MORGAN_SCARA)
+
+    /**
+     * Morgan SCARA homes XY at the same time
+     */
+    if (axis == X_AXIS || axis == Y_AXIS) {
+
+      float homeposition[XYZ];
+      LOOP_XYZ(i) homeposition[i] = LOGICAL_POSITION(base_home_pos((AxisEnum)i), i);
+
+      // SERIAL_ECHOPAIR("homeposition X:", homeposition[X_AXIS]);
+      // SERIAL_ECHOLNPAIR(" Y:", homeposition[Y_AXIS]);
+
+      /**
+       * Get Home position SCARA arm angles using inverse kinematics,
+       * and calculate homing offset using forward kinematics
+       */
+      inverse_kinematics(homeposition);
+      forward_kinematics_SCARA(delta[A_AXIS], delta[B_AXIS]);
+
+      // SERIAL_ECHOPAIR("Cartesian X:", cartes[X_AXIS]);
+      // SERIAL_ECHOLNPAIR(" Y:", cartes[Y_AXIS]);
+
+      current_position[axis] = LOGICAL_POSITION(cartes[axis], axis);
+
+      /**
+       * SCARA home positions are based on configuration since the actual
+       * limits are determined by the inverse kinematic transform.
+       */
+      soft_endstop_min[axis] = base_min_pos(axis); // + (cartes[axis] - base_home_pos(axis));
+      soft_endstop_max[axis] = base_max_pos(axis); // + (cartes[axis] - base_home_pos(axis));
+    }
+    else
+  #endif
+  {
+    current_position[axis] = LOGICAL_POSITION(base_home_pos(axis), axis);
+  }
+
+  /**
+   * Z Probe Z Homing? Account for the probe's Z offset.
+   */
+  #if HAS_BED_PROBE && Z_HOME_DIR < 0
+    if (axis == Z_AXIS) {
+      #if HOMING_Z_WITH_PROBE
+
+        current_position[Z_AXIS] -= zprobe_zoffset;
+
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) {
+            SERIAL_ECHOLNPGM("*** Z HOMED WITH PROBE (Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN) ***");
+            SERIAL_ECHOLNPAIR("> zprobe_zoffset = ", zprobe_zoffset);
+          }
+        #endif
+
+      #elif ENABLED(DEBUG_LEVELING_FEATURE)
+
+        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("*** Z HOMED TO ENDSTOP (Z_MIN_PROBE_ENDSTOP) ***");
+
+      #endif
+    }
+  #endif
+
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) {
+      #if HAS_HOME_OFFSET
+        SERIAL_ECHOPAIR("> home_offset[", axis_codes[axis]);
+        SERIAL_ECHOLNPAIR("] = ", home_offset[axis]);
+      #endif
+      DEBUG_POS("", current_position);
+      SERIAL_ECHOPAIR("<<< set_axis_is_at_home(", axis_codes[axis]);
+      SERIAL_CHAR(')');
+      SERIAL_EOL();
+    }
+  #endif
+
+  #if ENABLED(I2C_POSITION_ENCODERS)
+    I2CPEM.homed(axis);
+  #endif
+}
+
+/**
+ * Some planner shorthand inline functions
+ */
+inline float get_homing_bump_feedrate(const AxisEnum axis) {
+  static const uint8_t homing_bump_divisor[] PROGMEM = HOMING_BUMP_DIVISOR;
+  uint8_t hbd = pgm_read_byte(&homing_bump_divisor[axis]);
+  if (hbd < 1) {
+    hbd = 10;
+    SERIAL_ECHO_START();
+    SERIAL_ECHOLNPGM("Warning: Homing Bump Divisor < 1");
+  }
+  return homing_feedrate(axis) / hbd;
+}
+
+/**
+ * Move the planner to the current position from wherever it last moved
+ * (or from wherever it has been told it is located).
+ */
+inline void line_to_current_position() {
+  planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], feedrate_mm_s, active_extruder);
+}
+
+/**
+ * Move the planner to the position stored in the destination array, which is
+ * used by G0/G1/G2/G3/G5 and many other functions to set a destination.
+ */
+inline void line_to_destination(const float fr_mm_s) {
+  planner.buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], fr_mm_s, active_extruder);
+}
+inline void line_to_destination() { line_to_destination(feedrate_mm_s); }
+
+inline void set_current_to_destination() { COPY(current_position, destination); }
+inline void set_destination_to_current() { COPY(destination, current_position); }
+
+#if IS_KINEMATIC
+  /**
+   * Calculate delta, start a line, and set current_position to destination
+   */
+  void prepare_uninterpolated_move_to_destination(const float fr_mm_s=0.0) {
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) DEBUG_POS("prepare_uninterpolated_move_to_destination", destination);
+    #endif
+
+    refresh_cmd_timeout();
+
+    #if UBL_DELTA
+      // ubl segmented line will do z-only moves in single segment
+      ubl.prepare_segmented_line_to(destination, MMS_SCALED(fr_mm_s ? fr_mm_s : feedrate_mm_s));
+    #else
+      if ( current_position[X_AXIS] == destination[X_AXIS]
+        && current_position[Y_AXIS] == destination[Y_AXIS]
+        && current_position[Z_AXIS] == destination[Z_AXIS]
+        && current_position[E_AXIS] == destination[E_AXIS]
+      ) return;
+
+      planner.buffer_line_kinematic(destination, MMS_SCALED(fr_mm_s ? fr_mm_s : feedrate_mm_s), active_extruder);
+    #endif
+
+    set_current_to_destination();
+  }
+#endif // IS_KINEMATIC
+
+/**
+ *  Plan a move to (X, Y, Z) and set the current_position
+ *  The final current_position may not be the one that was requested
+ */
+void do_blocking_move_to(const float &lx, const float &ly, const float &lz, const float &fr_mm_s/*=0.0*/) {
+  const float old_feedrate_mm_s = feedrate_mm_s;
+
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) print_xyz(PSTR(">>> do_blocking_move_to"), NULL, lx, ly, lz);
+  #endif
+
+  #if ENABLED(DELTA)
+
+    if (!position_is_reachable_xy(lx, ly)) return;
+
+    feedrate_mm_s = fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
+
+    set_destination_to_current();          // sync destination at the start
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) DEBUG_POS("set_destination_to_current", destination);
+    #endif
+
+    // when in the danger zone
+    if (current_position[Z_AXIS] > delta_clip_start_height) {
+      if (lz > delta_clip_start_height) {   // staying in the danger zone
+        destination[X_AXIS] = lx;           // move directly (uninterpolated)
+        destination[Y_AXIS] = ly;
+        destination[Z_AXIS] = lz;
+        prepare_uninterpolated_move_to_destination(); // set_current_to_destination
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) DEBUG_POS("danger zone move", current_position);
+        #endif
+        return;
+      }
+      else {
+        destination[Z_AXIS] = delta_clip_start_height;
+        prepare_uninterpolated_move_to_destination(); // set_current_to_destination
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) DEBUG_POS("zone border move", current_position);
+        #endif
+      }
+    }
+
+    if (lz > current_position[Z_AXIS]) {    // raising?
+      destination[Z_AXIS] = lz;
+      prepare_uninterpolated_move_to_destination();   // set_current_to_destination
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        if (DEBUGGING(LEVELING)) DEBUG_POS("z raise move", current_position);
+      #endif
+    }
+
+    destination[X_AXIS] = lx;
+    destination[Y_AXIS] = ly;
+    prepare_move_to_destination();         // set_current_to_destination
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) DEBUG_POS("xy move", current_position);
+    #endif
+
+    if (lz < current_position[Z_AXIS]) {    // lowering?
+      destination[Z_AXIS] = lz;
+      prepare_uninterpolated_move_to_destination();   // set_current_to_destination
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        if (DEBUGGING(LEVELING)) DEBUG_POS("z lower move", current_position);
+      #endif
+    }
+
+  #elif IS_SCARA
+
+    if (!position_is_reachable_xy(lx, ly)) return;
+
+    set_destination_to_current();
+
+    // If Z needs to raise, do it before moving XY
+    if (destination[Z_AXIS] < lz) {
+      destination[Z_AXIS] = lz;
+      prepare_uninterpolated_move_to_destination(fr_mm_s ? fr_mm_s : homing_feedrate(Z_AXIS));
+    }
+
+    destination[X_AXIS] = lx;
+    destination[Y_AXIS] = ly;
+    prepare_uninterpolated_move_to_destination(fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S);
+
+    // If Z needs to lower, do it after moving XY
+    if (destination[Z_AXIS] > lz) {
+      destination[Z_AXIS] = lz;
+      prepare_uninterpolated_move_to_destination(fr_mm_s ? fr_mm_s : homing_feedrate(Z_AXIS));
+    }
+
+  #else
+
+    // If Z needs to raise, do it before moving XY
+    if (current_position[Z_AXIS] < lz) {
+      feedrate_mm_s = fr_mm_s ? fr_mm_s : homing_feedrate(Z_AXIS);
+      current_position[Z_AXIS] = lz;
+      line_to_current_position();
+    }
+
+    feedrate_mm_s = fr_mm_s ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
+    current_position[X_AXIS] = lx;
+    current_position[Y_AXIS] = ly;
+    line_to_current_position();
+
+    // If Z needs to lower, do it after moving XY
+    if (current_position[Z_AXIS] > lz) {
+      feedrate_mm_s = fr_mm_s ? fr_mm_s : homing_feedrate(Z_AXIS);
+      current_position[Z_AXIS] = lz;
+      line_to_current_position();
+    }
+
+  #endif
+
+  stepper.synchronize();
+
+  feedrate_mm_s = old_feedrate_mm_s;
+
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< do_blocking_move_to");
+  #endif
+}
+void do_blocking_move_to_x(const float &lx, const float &fr_mm_s/*=0.0*/) {
+  do_blocking_move_to(lx, current_position[Y_AXIS], current_position[Z_AXIS], fr_mm_s);
+}
+void do_blocking_move_to_z(const float &lz, const float &fr_mm_s/*=0.0*/) {
+  do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], lz, fr_mm_s);
+}
+void do_blocking_move_to_xy(const float &lx, const float &ly, const float &fr_mm_s/*=0.0*/) {
+  do_blocking_move_to(lx, ly, current_position[Z_AXIS], fr_mm_s);
+}
+
+//
+// Prepare to do endstop or probe moves
+// with custom feedrates.
+//
+//  - Save current feedrates
+//  - Reset the rate multiplier
+//  - Reset the command timeout
+//  - Enable the endstops (for endstop moves)
+//
+static void setup_for_endstop_or_probe_move() {
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) DEBUG_POS("setup_for_endstop_or_probe_move", current_position);
+  #endif
+  saved_feedrate_mm_s = feedrate_mm_s;
+  saved_feedrate_percentage = feedrate_percentage;
+  feedrate_percentage = 100;
+  refresh_cmd_timeout();
+}
+
+static void clean_up_after_endstop_or_probe_move() {
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) DEBUG_POS("clean_up_after_endstop_or_probe_move", current_position);
+  #endif
+  feedrate_mm_s = saved_feedrate_mm_s;
+  feedrate_percentage = saved_feedrate_percentage;
+  refresh_cmd_timeout();
+}
+
+#if HAS_BED_PROBE
+  /**
+   * Raise Z to a minimum height to make room for a probe to move
+   */
+  inline void do_probe_raise(const float z_raise) {
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) {
+        SERIAL_ECHOPAIR("do_probe_raise(", z_raise);
+        SERIAL_CHAR(')');
+        SERIAL_EOL();
+      }
+    #endif
+
+    float z_dest = z_raise;
+    if (zprobe_zoffset < 0) z_dest -= zprobe_zoffset;
+
+    if (z_dest > current_position[Z_AXIS])
+      do_blocking_move_to_z(z_dest);
+  }
+
+#endif // HAS_BED_PROBE
+
+#if HAS_PROBING_PROCEDURE || HOTENDS > 1 || ENABLED(Z_PROBE_ALLEN_KEY) || ENABLED(Z_PROBE_SLED) || ENABLED(NOZZLE_CLEAN_FEATURE) || ENABLED(NOZZLE_PARK_FEATURE) || ENABLED(DELTA_AUTO_CALIBRATION)
+
+  bool axis_unhomed_error(const bool x/*=true*/, const bool y/*=true*/, const bool z/*=true*/) {
+    #if ENABLED(HOME_AFTER_DEACTIVATE)
+      const bool xx = x && !axis_known_position[X_AXIS],
+                 yy = y && !axis_known_position[Y_AXIS],
+                 zz = z && !axis_known_position[Z_AXIS];
+    #else
+      const bool xx = x && !axis_homed[X_AXIS],
+                 yy = y && !axis_homed[Y_AXIS],
+                 zz = z && !axis_homed[Z_AXIS];
+    #endif
+    if (xx || yy || zz) {
+      SERIAL_ECHO_START();
+      SERIAL_ECHOPGM(MSG_HOME " ");
+      if (xx) SERIAL_ECHOPGM(MSG_X);
+      if (yy) SERIAL_ECHOPGM(MSG_Y);
+      if (zz) SERIAL_ECHOPGM(MSG_Z);
+      SERIAL_ECHOLNPGM(" " MSG_FIRST);
+
+      #if ENABLED(ULTRA_LCD)
+        lcd_status_printf_P(0, PSTR(MSG_HOME " %s%s%s " MSG_FIRST), xx ? MSG_X : "", yy ? MSG_Y : "", zz ? MSG_Z : "");
+      #endif
+      return true;
+    }
+    return false;
+  }
+
+#endif
+
+#if ENABLED(Z_PROBE_SLED)
+
+  #ifndef SLED_DOCKING_OFFSET
+    #define SLED_DOCKING_OFFSET 0
+  #endif
+
+  /**
+   * Method to dock/undock a sled designed by Charles Bell.
+   *
+   * stow[in]     If false, move to MAX_X and engage the solenoid
+   *              If true, move to MAX_X and release the solenoid
+   */
+  static void dock_sled(bool stow) {
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) {
+        SERIAL_ECHOPAIR("dock_sled(", stow);
+        SERIAL_CHAR(')');
+        SERIAL_EOL();
+      }
+    #endif
+
+    // Dock sled a bit closer to ensure proper capturing
+    do_blocking_move_to_x(X_MAX_POS + SLED_DOCKING_OFFSET - ((stow) ? 1 : 0));
+
+    #if HAS_SOLENOID_1 && DISABLED(EXT_SOLENOID)
+      WRITE(SOL1_PIN, !stow); // switch solenoid
+    #endif
+  }
+
+#elif ENABLED(Z_PROBE_ALLEN_KEY)
+
+  FORCE_INLINE void do_blocking_move_to(const float logical[XYZ], const float &fr_mm_s) {
+    do_blocking_move_to(logical[X_AXIS], logical[Y_AXIS], logical[Z_AXIS], fr_mm_s);
+  }
+
+  void run_deploy_moves_script() {
+    #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_1_Z)
+      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_X
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_1_X current_position[X_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_Y
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_1_Y current_position[Y_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_Z
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_1_Z current_position[Z_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE 0.0
+      #endif
+      const float deploy_1[] = { Z_PROBE_ALLEN_KEY_DEPLOY_1_X, Z_PROBE_ALLEN_KEY_DEPLOY_1_Y, Z_PROBE_ALLEN_KEY_DEPLOY_1_Z };
+      do_blocking_move_to(deploy_1, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE));
+    #endif
+    #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_2_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_2_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_2_Z)
+      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_X
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_2_X current_position[X_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_Y
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_2_Y current_position[Y_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_Z
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_2_Z current_position[Z_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE 0.0
+      #endif
+      const float deploy_2[] = { Z_PROBE_ALLEN_KEY_DEPLOY_2_X, Z_PROBE_ALLEN_KEY_DEPLOY_2_Y, Z_PROBE_ALLEN_KEY_DEPLOY_2_Z };
+      do_blocking_move_to(deploy_2, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE));
+    #endif
+    #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_3_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_3_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_3_Z)
+      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_X
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_3_X current_position[X_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_Y
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_3_Y current_position[Y_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_Z
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_3_Z current_position[Z_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE 0.0
+      #endif
+      const float deploy_3[] = { Z_PROBE_ALLEN_KEY_DEPLOY_3_X, Z_PROBE_ALLEN_KEY_DEPLOY_3_Y, Z_PROBE_ALLEN_KEY_DEPLOY_3_Z };
+      do_blocking_move_to(deploy_3, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE));
+    #endif
+    #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_4_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_4_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_4_Z)
+      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_X
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_4_X current_position[X_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_Y
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_4_Y current_position[Y_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_Z
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_4_Z current_position[Z_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE 0.0
+      #endif
+      const float deploy_4[] = { Z_PROBE_ALLEN_KEY_DEPLOY_4_X, Z_PROBE_ALLEN_KEY_DEPLOY_4_Y, Z_PROBE_ALLEN_KEY_DEPLOY_4_Z };
+      do_blocking_move_to(deploy_4, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_4_FEEDRATE));
+    #endif
+    #if defined(Z_PROBE_ALLEN_KEY_DEPLOY_5_X) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_5_Y) || defined(Z_PROBE_ALLEN_KEY_DEPLOY_5_Z)
+      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_X
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_5_X current_position[X_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_Y
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_5_Y current_position[Y_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_Z
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_5_Z current_position[Z_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE
+        #define Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE 0.0
+      #endif
+      const float deploy_5[] = { Z_PROBE_ALLEN_KEY_DEPLOY_5_X, Z_PROBE_ALLEN_KEY_DEPLOY_5_Y, Z_PROBE_ALLEN_KEY_DEPLOY_5_Z };
+      do_blocking_move_to(deploy_5, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_DEPLOY_5_FEEDRATE));
+    #endif
+  }
+
+  void run_stow_moves_script() {
+    #if defined(Z_PROBE_ALLEN_KEY_STOW_1_X) || defined(Z_PROBE_ALLEN_KEY_STOW_1_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_1_Z)
+      #ifndef Z_PROBE_ALLEN_KEY_STOW_1_X
+        #define Z_PROBE_ALLEN_KEY_STOW_1_X current_position[X_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_STOW_1_Y
+        #define Z_PROBE_ALLEN_KEY_STOW_1_Y current_position[Y_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_STOW_1_Z
+        #define Z_PROBE_ALLEN_KEY_STOW_1_Z current_position[Z_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE
+        #define Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE 0.0
+      #endif
+      const float stow_1[] = { Z_PROBE_ALLEN_KEY_STOW_1_X, Z_PROBE_ALLEN_KEY_STOW_1_Y, Z_PROBE_ALLEN_KEY_STOW_1_Z };
+      do_blocking_move_to(stow_1, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE));
+    #endif
+    #if defined(Z_PROBE_ALLEN_KEY_STOW_2_X) || defined(Z_PROBE_ALLEN_KEY_STOW_2_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_2_Z)
+      #ifndef Z_PROBE_ALLEN_KEY_STOW_2_X
+        #define Z_PROBE_ALLEN_KEY_STOW_2_X current_position[X_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_STOW_2_Y
+        #define Z_PROBE_ALLEN_KEY_STOW_2_Y current_position[Y_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_STOW_2_Z
+        #define Z_PROBE_ALLEN_KEY_STOW_2_Z current_position[Z_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE
+        #define Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE 0.0
+      #endif
+      const float stow_2[] = { Z_PROBE_ALLEN_KEY_STOW_2_X, Z_PROBE_ALLEN_KEY_STOW_2_Y, Z_PROBE_ALLEN_KEY_STOW_2_Z };
+      do_blocking_move_to(stow_2, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE));
+    #endif
+    #if defined(Z_PROBE_ALLEN_KEY_STOW_3_X) || defined(Z_PROBE_ALLEN_KEY_STOW_3_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_3_Z)
+      #ifndef Z_PROBE_ALLEN_KEY_STOW_3_X
+        #define Z_PROBE_ALLEN_KEY_STOW_3_X current_position[X_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_STOW_3_Y
+        #define Z_PROBE_ALLEN_KEY_STOW_3_Y current_position[Y_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_STOW_3_Z
+        #define Z_PROBE_ALLEN_KEY_STOW_3_Z current_position[Z_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE
+        #define Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE 0.0
+      #endif
+      const float stow_3[] = { Z_PROBE_ALLEN_KEY_STOW_3_X, Z_PROBE_ALLEN_KEY_STOW_3_Y, Z_PROBE_ALLEN_KEY_STOW_3_Z };
+      do_blocking_move_to(stow_3, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE));
+    #endif
+    #if defined(Z_PROBE_ALLEN_KEY_STOW_4_X) || defined(Z_PROBE_ALLEN_KEY_STOW_4_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_4_Z)
+      #ifndef Z_PROBE_ALLEN_KEY_STOW_4_X
+        #define Z_PROBE_ALLEN_KEY_STOW_4_X current_position[X_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_STOW_4_Y
+        #define Z_PROBE_ALLEN_KEY_STOW_4_Y current_position[Y_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_STOW_4_Z
+        #define Z_PROBE_ALLEN_KEY_STOW_4_Z current_position[Z_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE
+        #define Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE 0.0
+      #endif
+      const float stow_4[] = { Z_PROBE_ALLEN_KEY_STOW_4_X, Z_PROBE_ALLEN_KEY_STOW_4_Y, Z_PROBE_ALLEN_KEY_STOW_4_Z };
+      do_blocking_move_to(stow_4, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_4_FEEDRATE));
+    #endif
+    #if defined(Z_PROBE_ALLEN_KEY_STOW_5_X) || defined(Z_PROBE_ALLEN_KEY_STOW_5_Y) || defined(Z_PROBE_ALLEN_KEY_STOW_5_Z)
+      #ifndef Z_PROBE_ALLEN_KEY_STOW_5_X
+        #define Z_PROBE_ALLEN_KEY_STOW_5_X current_position[X_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_STOW_5_Y
+        #define Z_PROBE_ALLEN_KEY_STOW_5_Y current_position[Y_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_STOW_5_Z
+        #define Z_PROBE_ALLEN_KEY_STOW_5_Z current_position[Z_AXIS]
+      #endif
+      #ifndef Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE
+        #define Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE 0.0
+      #endif
+      const float stow_5[] = { Z_PROBE_ALLEN_KEY_STOW_5_X, Z_PROBE_ALLEN_KEY_STOW_5_Y, Z_PROBE_ALLEN_KEY_STOW_5_Z };
+      do_blocking_move_to(stow_5, MMM_TO_MMS(Z_PROBE_ALLEN_KEY_STOW_5_FEEDRATE));
+    #endif
+  }
+
+#endif
+
+#if ENABLED(PROBING_FANS_OFF)
+
+  void fans_pause(const bool p) {
+    if (p != fans_paused) {
+      fans_paused = p;
+      if (p)
+        for (uint8_t x = 0; x < FAN_COUNT; x++) {
+          paused_fanSpeeds[x] = fanSpeeds[x];
+          fanSpeeds[x] = 0;
+        }
+      else
+        for (uint8_t x = 0; x < FAN_COUNT; x++)
+          fanSpeeds[x] = paused_fanSpeeds[x];
+    }
+  }
+
+#endif // PROBING_FANS_OFF
+
+#if HAS_BED_PROBE
+
+  // TRIGGERED_WHEN_STOWED_TEST can easily be extended to servo probes, ... if needed.
+  #if ENABLED(PROBE_IS_TRIGGERED_WHEN_STOWED_TEST)
+    #if ENABLED(Z_MIN_PROBE_ENDSTOP)
+      #define _TRIGGERED_WHEN_STOWED_TEST (READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING)
+    #else
+      #define _TRIGGERED_WHEN_STOWED_TEST (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING)
+    #endif
+  #endif
+
+  #if QUIET_PROBING
+    void probing_pause(const bool p) {
+      #if ENABLED(PROBING_HEATERS_OFF)
+        thermalManager.pause(p);
+      #endif
+      #if ENABLED(PROBING_FANS_OFF)
+        fans_pause(p);
+      #endif
+      if (p) safe_delay(
+        #if DELAY_BEFORE_PROBING > 25
+          DELAY_BEFORE_PROBING
+        #else
+          25
+        #endif
+      );
+    }
+  #endif // QUIET_PROBING
+
+  #if ENABLED(BLTOUCH)
+
+    void bltouch_command(int angle) {
+      MOVE_SERVO(Z_ENDSTOP_SERVO_NR, angle);  // Give the BL-Touch the command and wait
+      safe_delay(BLTOUCH_DELAY);
+    }
+
+    bool set_bltouch_deployed(const bool deploy) {
+      if (deploy && TEST_BLTOUCH()) {      // If BL-Touch says it's triggered
+        bltouch_command(BLTOUCH_RESET);    //  try to reset it.
+        bltouch_command(BLTOUCH_DEPLOY);   // Also needs to deploy and stow to
+        bltouch_command(BLTOUCH_STOW);     //  clear the triggered condition.
+        safe_delay(1500);                  // Wait for internal self-test to complete.
+                                           //  (Measured completion time was 0.65 seconds
+                                           //   after reset, deploy, and stow sequence)
+        if (TEST_BLTOUCH()) {              // If it still claims to be triggered...
+          SERIAL_ERROR_START();
+          SERIAL_ERRORLNPGM(MSG_STOP_BLTOUCH);
+          stop();                          // punt!
+          return true;
+        }
+      }
+
+      bltouch_command(deploy ? BLTOUCH_DEPLOY : BLTOUCH_STOW);
+
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        if (DEBUGGING(LEVELING)) {
+          SERIAL_ECHOPAIR("set_bltouch_deployed(", deploy);
+          SERIAL_CHAR(')');
+          SERIAL_EOL();
+        }
+      #endif
+
+      return false;
+    }
+
+  #endif // BLTOUCH
+
+  // returns false for ok and true for failure
+  bool set_probe_deployed(bool deploy) {
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) {
+        DEBUG_POS("set_probe_deployed", current_position);
+        SERIAL_ECHOLNPAIR("deploy: ", deploy);
+      }
+    #endif
+
+    if (endstops.z_probe_enabled == deploy) return false;
+
+    // Make room for probe
+    do_probe_raise(_Z_CLEARANCE_DEPLOY_PROBE);
+
+    #if ENABLED(Z_PROBE_SLED) || ENABLED(Z_PROBE_ALLEN_KEY)
+      #if ENABLED(Z_PROBE_SLED)
+        #define _AUE_ARGS true, false, false
+      #else
+        #define _AUE_ARGS
+      #endif
+      if (axis_unhomed_error(_AUE_ARGS)) {
+        SERIAL_ERROR_START();
+        SERIAL_ERRORLNPGM(MSG_STOP_UNHOMED);
+        stop();
+        return true;
+      }
+    #endif
+
+    const float oldXpos = current_position[X_AXIS],
+                oldYpos = current_position[Y_AXIS];
+
+    #ifdef _TRIGGERED_WHEN_STOWED_TEST
+
+      // If endstop is already false, the Z probe is deployed
+      if (_TRIGGERED_WHEN_STOWED_TEST == deploy) {     // closed after the probe specific actions.
+                                                       // Would a goto be less ugly?
+        //while (!_TRIGGERED_WHEN_STOWED_TEST) idle(); // would offer the opportunity
+                                                       // for a triggered when stowed manual probe.
+
+        if (!deploy) endstops.enable_z_probe(false); // Switch off triggered when stowed probes early
+                                                     // otherwise an Allen-Key probe can't be stowed.
+    #endif
+
+        #if ENABLED(SOLENOID_PROBE)
+
+          #if HAS_SOLENOID_1
+            WRITE(SOL1_PIN, deploy);
+          #endif
+
+        #elif ENABLED(Z_PROBE_SLED)
+
+          dock_sled(!deploy);
+
+        #elif HAS_Z_SERVO_ENDSTOP && DISABLED(BLTOUCH)
+
+          MOVE_SERVO(Z_ENDSTOP_SERVO_NR, z_servo_angle[deploy ? 0 : 1]);
+
+        #elif ENABLED(Z_PROBE_ALLEN_KEY)
+
+          deploy ? run_deploy_moves_script() : run_stow_moves_script();
+
+        #endif
+
+    #ifdef _TRIGGERED_WHEN_STOWED_TEST
+      } // _TRIGGERED_WHEN_STOWED_TEST == deploy
+
+      if (_TRIGGERED_WHEN_STOWED_TEST == deploy) { // State hasn't changed?
+
+        if (IsRunning()) {
+          SERIAL_ERROR_START();
+          SERIAL_ERRORLNPGM("Z-Probe failed");
+          LCD_ALERTMESSAGEPGM("Err: ZPROBE");
+        }
+        stop();
+        return true;
+
+      } // _TRIGGERED_WHEN_STOWED_TEST == deploy
+
+    #endif
+
+    do_blocking_move_to(oldXpos, oldYpos, current_position[Z_AXIS]); // return to position before deploy
+    endstops.enable_z_probe(deploy);
+    return false;
+  }
+
+  /**
+   * @brief Used by run_z_probe to do a single Z probe move.
+   *
+   * @param  z        Z destination
+   * @param  fr_mm_s  Feedrate in mm/s
+   * @return true to indicate an error
+   */
+  static bool do_probe_move(const float z, const float fr_mm_m) {
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) DEBUG_POS(">>> do_probe_move", current_position);
+    #endif
+
+    // Deploy BLTouch at the start of any probe
+    #if ENABLED(BLTOUCH)
+      if (set_bltouch_deployed(true)) return true;
+    #endif
+
+    #if QUIET_PROBING
+      probing_pause(true);
+    #endif
+
+    // Move down until probe triggered
+    do_blocking_move_to_z(z, MMM_TO_MMS(fr_mm_m));
+
+    // Check to see if the probe was triggered
+    const bool probe_triggered = TEST(Endstops::endstop_hit_bits,
+      #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
+        Z_MIN
+      #else
+        Z_MIN_PROBE
+      #endif
+    );
+
+    #if QUIET_PROBING
+      probing_pause(false);
+    #endif
+
+    // Retract BLTouch immediately after a probe if it was triggered
+    #if ENABLED(BLTOUCH)
+      if (probe_triggered && set_bltouch_deployed(false)) return true;
+    #endif
+
+    // Clear endstop flags
+    endstops.hit_on_purpose();
+
+    // Get Z where the steppers were interrupted
+    set_current_from_steppers_for_axis(Z_AXIS);
+
+    // Tell the planner where we actually are
+    SYNC_PLAN_POSITION_KINEMATIC();
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) DEBUG_POS("<<< do_probe_move", current_position);
+    #endif
+
+    return !probe_triggered;
+  }
+
+  /**
+   * @details Used by probe_pt to do a single Z probe.
+   *          Leaves current_position[Z_AXIS] at the height where the probe triggered.
+   *
+   * @param  short_move Flag for a shorter probe move towards the bed
+   * @return The raw Z position where the probe was triggered
+   */
+  static float run_z_probe(const bool short_move=true) {
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) DEBUG_POS(">>> run_z_probe", current_position);
+    #endif
+
+    // Prevent stepper_inactive_time from running out and EXTRUDER_RUNOUT_PREVENT from extruding
+    refresh_cmd_timeout();
+
+    #if ENABLED(PROBE_DOUBLE_TOUCH)
+
+      // Do a first probe at the fast speed
+      if (do_probe_move(-10, Z_PROBE_SPEED_FAST)) return NAN;
+
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        float first_probe_z = current_position[Z_AXIS];
+        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("1st Probe Z:", first_probe_z);
+      #endif
+
+      // move up to make clearance for the probe
+      do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
+
+    #else
+
+      // If the nozzle is above the travel height then
+      // move down quickly before doing the slow probe
+      float z = Z_CLEARANCE_DEPLOY_PROBE;
+      if (zprobe_zoffset < 0) z -= zprobe_zoffset;
+
+      if (z < current_position[Z_AXIS]) {
+
+        // If we don't make it to the z position (i.e. the probe triggered), move up to make clearance for the probe
+        if (!do_probe_move(z, Z_PROBE_SPEED_FAST))
+          do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
+      }
+    #endif
+
+    // move down slowly to find bed
+    if (do_probe_move(-10 + (short_move ? 0 : -(Z_MAX_LENGTH)), Z_PROBE_SPEED_SLOW)) return NAN;
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) DEBUG_POS("<<< run_z_probe", current_position);
+    #endif
+
+    // Debug: compare probe heights
+    #if ENABLED(PROBE_DOUBLE_TOUCH) && ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) {
+        SERIAL_ECHOPAIR("2nd Probe Z:", current_position[Z_AXIS]);
+        SERIAL_ECHOLNPAIR(" Discrepancy:", first_probe_z - current_position[Z_AXIS]);
+      }
+    #endif
+
+    return RAW_CURRENT_POSITION(Z) + zprobe_zoffset
+      #if ENABLED(DELTA)
+        + home_offset[Z_AXIS] // Account for delta height adjustment
+      #endif
+    ;
+  }
+
+  /**
+   * - Move to the given XY
+   * - Deploy the probe, if not already deployed
+   * - Probe the bed, get the Z position
+   * - Depending on the 'stow' flag
+   *   - Stow the probe, or
+   *   - Raise to the BETWEEN height
+   * - Return the probed Z position
+   */
+  float probe_pt(const float &lx, const float &ly, const bool stow, const uint8_t verbose_level, const bool printable=true) {
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) {
+        SERIAL_ECHOPAIR(">>> probe_pt(", lx);
+        SERIAL_ECHOPAIR(", ", ly);
+        SERIAL_ECHOPAIR(", ", stow ? "" : "no ");
+        SERIAL_ECHOLNPGM("stow)");
+        DEBUG_POS("", current_position);
+      }
+    #endif
+
+    const float nx = lx - (X_PROBE_OFFSET_FROM_EXTRUDER), ny = ly - (Y_PROBE_OFFSET_FROM_EXTRUDER);
+
+    if (printable
+      ? !position_is_reachable_xy(nx, ny)
+      : !position_is_reachable_by_probe_xy(lx, ly)
+    ) return NAN;
+
+
+    const float old_feedrate_mm_s = feedrate_mm_s;
+
+    #if ENABLED(DELTA)
+      if (current_position[Z_AXIS] > delta_clip_start_height)
+        do_blocking_move_to_z(delta_clip_start_height);
+    #endif
+
+    #if HAS_SOFTWARE_ENDSTOPS
+      // Store the status of the soft endstops and disable if we're probing a non-printable location
+      static bool enable_soft_endstops = soft_endstops_enabled;
+      if (!printable) soft_endstops_enabled = false;
+    #endif
+
+    feedrate_mm_s = XY_PROBE_FEEDRATE_MM_S;
+
+    // Move the probe to the given XY
+    do_blocking_move_to_xy(nx, ny);
+
+    float measured_z = NAN;
+    if (!DEPLOY_PROBE()) {
+      measured_z = run_z_probe(printable);
+
+      if (!stow)
+        do_blocking_move_to_z(current_position[Z_AXIS] + Z_CLEARANCE_BETWEEN_PROBES, MMM_TO_MMS(Z_PROBE_SPEED_FAST));
+      else
+        if (STOW_PROBE()) measured_z = NAN;
+    }
+
+    #if HAS_SOFTWARE_ENDSTOPS
+      // Restore the soft endstop status
+      soft_endstops_enabled = enable_soft_endstops;
+    #endif
+
+    if (verbose_level > 2) {
+      SERIAL_PROTOCOLPGM("Bed X: ");
+      SERIAL_PROTOCOL_F(lx, 3);
+      SERIAL_PROTOCOLPGM(" Y: ");
+      SERIAL_PROTOCOL_F(ly, 3);
+      SERIAL_PROTOCOLPGM(" Z: ");
+      SERIAL_PROTOCOL_F(measured_z, 3);
+      SERIAL_EOL();
+    }
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< probe_pt");
+    #endif
+
+    feedrate_mm_s = old_feedrate_mm_s;
+
+    if (isnan(measured_z)) {
+      LCD_MESSAGEPGM(MSG_ERR_PROBING_FAILED);
+      SERIAL_ERROR_START();
+      SERIAL_ERRORLNPGM(MSG_ERR_PROBING_FAILED);
+    }
+
+    return measured_z;
+  }
+
+#endif // HAS_BED_PROBE
+
+#if HAS_LEVELING
+
+  bool leveling_is_valid() {
+    return
+      #if ENABLED(MESH_BED_LEVELING)
+        mbl.has_mesh()
+      #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
+        !!bilinear_grid_spacing[X_AXIS]
+      #elif ENABLED(AUTO_BED_LEVELING_UBL)
+        true
+      #else // 3POINT, LINEAR
+        true
+      #endif
+    ;
+  }
+
+  bool leveling_is_active() {
+    return
+      #if ENABLED(MESH_BED_LEVELING)
+        mbl.active()
+      #elif ENABLED(AUTO_BED_LEVELING_UBL)
+        ubl.state.active
+      #else
+        planner.abl_enabled
+      #endif
+    ;
+  }
+
+  /**
+   * Turn bed leveling on or off, fixing the current
+   * position as-needed.
+   *
+   * Disable: Current position = physical position
+   *  Enable: Current position = "unleveled" physical position
+   */
+  void set_bed_leveling_enabled(const bool enable/*=true*/) {
+
+    #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
+      const bool can_change = (!enable || leveling_is_valid());
+    #else
+      constexpr bool can_change = true;
+    #endif
+
+    if (can_change && enable != leveling_is_active()) {
+
+      #if ENABLED(MESH_BED_LEVELING)
+
+        if (!enable)
+          planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS]);
+
+        const bool enabling = enable && leveling_is_valid();
+        mbl.set_active(enabling);
+        if (enabling) planner.unapply_leveling(current_position);
+
+      #elif ENABLED(AUTO_BED_LEVELING_UBL)
+        #if PLANNER_LEVELING
+          if (ubl.state.active) {                       // leveling from on to off
+            // change unleveled current_position to physical current_position without moving steppers.
+            planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS]);
+            ubl.state.active = false;                   // disable only AFTER calling apply_leveling
+          }
+          else {                                        // leveling from off to on
+            ubl.state.active = true;                    // enable BEFORE calling unapply_leveling, otherwise ignored
+            // change physical current_position to unleveled current_position without moving steppers.
+            planner.unapply_leveling(current_position);
+          }
+        #else
+          ubl.state.active = enable;                    // just flip the bit, current_position will be wrong until next move.
+        #endif
+
+      #else // ABL
+
+        #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
+          // Force bilinear_z_offset to re-calculate next time
+          const float reset[XYZ] = { -9999.999, -9999.999, 0 };
+          (void)bilinear_z_offset(reset);
+        #endif
+
+        // Enable or disable leveling compensation in the planner
+        planner.abl_enabled = enable;
+
+        if (!enable)
+          // When disabling just get the current position from the steppers.
+          // This will yield the smallest error when first converted back to steps.
+          set_current_from_steppers_for_axis(
+            #if ABL_PLANAR
+              ALL_AXES
+            #else
+              Z_AXIS
+            #endif
+          );
+        else
+          // When enabling, remove compensation from the current position,
+          // so compensation will give the right stepper counts.
+          planner.unapply_leveling(current_position);
+
+      #endif // ABL
+    }
+  }
+
+  #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+
+    void set_z_fade_height(const float zfh) {
+
+      const bool level_active = leveling_is_active();
+
+      #if ENABLED(AUTO_BED_LEVELING_UBL)
+
+        if (level_active)
+          set_bed_leveling_enabled(false);  // turn off before changing fade height for proper apply/unapply leveling to maintain current_position
+        planner.z_fade_height = zfh;
+        planner.inverse_z_fade_height = RECIPROCAL(zfh);
+        if (level_active)
+          set_bed_leveling_enabled(true);  // turn back on after changing fade height
+
+      #else
+
+        planner.z_fade_height = zfh;
+        planner.inverse_z_fade_height = RECIPROCAL(zfh);
+
+        if (level_active) {
+          set_current_from_steppers_for_axis(
+            #if ABL_PLANAR
+              ALL_AXES
+            #else
+              Z_AXIS
+            #endif
+          );
+        }
+      #endif
+    }
+
+  #endif // LEVELING_FADE_HEIGHT
+
+  /**
+   * Reset calibration results to zero.
+   */
+  void reset_bed_level() {
+    set_bed_leveling_enabled(false);
+    #if ENABLED(MESH_BED_LEVELING)
+      if (leveling_is_valid()) {
+        mbl.reset();
+        mbl.set_has_mesh(false);
+      }
+    #else
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("reset_bed_level");
+      #endif
+      #if ABL_PLANAR
+        planner.bed_level_matrix.set_to_identity();
+      #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
+        bilinear_start[X_AXIS] = bilinear_start[Y_AXIS] =
+        bilinear_grid_spacing[X_AXIS] = bilinear_grid_spacing[Y_AXIS] = 0;
+        for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
+          for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
+            z_values[x][y] = NAN;
+      #elif ENABLED(AUTO_BED_LEVELING_UBL)
+        ubl.reset();
+      #endif
+    #endif
+  }
+
+#endif // HAS_LEVELING
+
+#if ENABLED(AUTO_BED_LEVELING_BILINEAR) || ENABLED(MESH_BED_LEVELING)
+
+  /**
+   * Enable to produce output in JSON format suitable
+   * for SCAD or JavaScript mesh visualizers.
+   *
+   * Visualize meshes in OpenSCAD using the included script.
+   *
+   *   buildroot/shared/scripts/MarlinMesh.scad
+   */
+  //#define SCAD_MESH_OUTPUT
+
+  /**
+   * Print calibration results for plotting or manual frame adjustment.
+   */
+  static void print_2d_array(const uint8_t sx, const uint8_t sy, const uint8_t precision, float (*fn)(const uint8_t, const uint8_t)) {
+    #ifndef SCAD_MESH_OUTPUT
+      for (uint8_t x = 0; x < sx; x++) {
+        for (uint8_t i = 0; i < precision + 2 + (x < 10 ? 1 : 0); i++)
+          SERIAL_PROTOCOLCHAR(' ');
+        SERIAL_PROTOCOL((int)x);
+      }
+      SERIAL_EOL();
+    #endif
+    #ifdef SCAD_MESH_OUTPUT
+      SERIAL_PROTOCOLLNPGM("measured_z = ["); // open 2D array
+    #endif
+    for (uint8_t y = 0; y < sy; y++) {
+      #ifdef SCAD_MESH_OUTPUT
+        SERIAL_PROTOCOLPGM(" [");           // open sub-array
+      #else
+        if (y < 10) SERIAL_PROTOCOLCHAR(' ');
+        SERIAL_PROTOCOL((int)y);
+      #endif
+      for (uint8_t x = 0; x < sx; x++) {
+        SERIAL_PROTOCOLCHAR(' ');
+        const float offset = fn(x, y);
+        if (!isnan(offset)) {
+          if (offset >= 0) SERIAL_PROTOCOLCHAR('+');
+          SERIAL_PROTOCOL_F(offset, precision);
+        }
+        else {
+          #ifdef SCAD_MESH_OUTPUT
+            for (uint8_t i = 3; i < precision + 3; i++)
+              SERIAL_PROTOCOLCHAR(' ');
+            SERIAL_PROTOCOLPGM("NAN");
+          #else
+            for (uint8_t i = 0; i < precision + 3; i++)
+              SERIAL_PROTOCOLCHAR(i ? '=' : ' ');
+          #endif
+        }
+        #ifdef SCAD_MESH_OUTPUT
+          if (x < sx - 1) SERIAL_PROTOCOLCHAR(',');
+        #endif
+      }
+      #ifdef SCAD_MESH_OUTPUT
+        SERIAL_PROTOCOLCHAR(' ');
+        SERIAL_PROTOCOLCHAR(']');                     // close sub-array
+        if (y < sy - 1) SERIAL_PROTOCOLCHAR(',');
+      #endif
+      SERIAL_EOL();
+    }
+    #ifdef SCAD_MESH_OUTPUT
+      SERIAL_PROTOCOLPGM("];");                       // close 2D array
+    #endif
+    SERIAL_EOL();
+  }
+
+#endif
+
+#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
+
+  /**
+   * Extrapolate a single point from its neighbors
+   */
+  static void extrapolate_one_point(const uint8_t x, const uint8_t y, const int8_t xdir, const int8_t ydir) {
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) {
+        SERIAL_ECHOPGM("Extrapolate [");
+        if (x < 10) SERIAL_CHAR(' ');
+        SERIAL_ECHO((int)x);
+        SERIAL_CHAR(xdir ? (xdir > 0 ? '+' : '-') : ' ');
+        SERIAL_CHAR(' ');
+        if (y < 10) SERIAL_CHAR(' ');
+        SERIAL_ECHO((int)y);
+        SERIAL_CHAR(ydir ? (ydir > 0 ? '+' : '-') : ' ');
+        SERIAL_CHAR(']');
+      }
+    #endif
+    if (!isnan(z_values[x][y])) {
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM(" (done)");
+      #endif
+      return;  // Don't overwrite good values.
+    }
+    SERIAL_EOL();
+
+    // Get X neighbors, Y neighbors, and XY neighbors
+    const uint8_t x1 = x + xdir, y1 = y + ydir, x2 = x1 + xdir, y2 = y1 + ydir;
+    float a1 = z_values[x1][y ], a2 = z_values[x2][y ],
+          b1 = z_values[x ][y1], b2 = z_values[x ][y2],
+          c1 = z_values[x1][y1], c2 = z_values[x2][y2];
+
+    // Treat far unprobed points as zero, near as equal to far
+    if (isnan(a2)) a2 = 0.0; if (isnan(a1)) a1 = a2;
+    if (isnan(b2)) b2 = 0.0; if (isnan(b1)) b1 = b2;
+    if (isnan(c2)) c2 = 0.0; if (isnan(c1)) c1 = c2;
+
+    const float a = 2 * a1 - a2, b = 2 * b1 - b2, c = 2 * c1 - c2;
+
+    // Take the average instead of the median
+    z_values[x][y] = (a + b + c) / 3.0;
+
+    // Median is robust (ignores outliers).
+    // z_values[x][y] = (a < b) ? ((b < c) ? b : (c < a) ? a : c)
+    //                                : ((c < b) ? b : (a < c) ? a : c);
+  }
+
+  //Enable this if your SCARA uses 180° of total area
+  //#define EXTRAPOLATE_FROM_EDGE
+
+  #if ENABLED(EXTRAPOLATE_FROM_EDGE)
+    #if GRID_MAX_POINTS_X < GRID_MAX_POINTS_Y
+      #define HALF_IN_X
+    #elif GRID_MAX_POINTS_Y < GRID_MAX_POINTS_X
+      #define HALF_IN_Y
+    #endif
+  #endif
+
+  /**
+   * Fill in the unprobed points (corners of circular print surface)
+   * using linear extrapolation, away from the center.
+   */
+  static void extrapolate_unprobed_bed_level() {
+    #ifdef HALF_IN_X
+      constexpr uint8_t ctrx2 = 0, xlen = GRID_MAX_POINTS_X - 1;
+    #else
+      constexpr uint8_t ctrx1 = (GRID_MAX_POINTS_X - 1) / 2, // left-of-center
+                        ctrx2 = (GRID_MAX_POINTS_X) / 2,     // right-of-center
+                        xlen = ctrx1;
+    #endif
+
+    #ifdef HALF_IN_Y
+      constexpr uint8_t ctry2 = 0, ylen = GRID_MAX_POINTS_Y - 1;
+    #else
+      constexpr uint8_t ctry1 = (GRID_MAX_POINTS_Y - 1) / 2, // top-of-center
+                        ctry2 = (GRID_MAX_POINTS_Y) / 2,     // bottom-of-center
+                        ylen = ctry1;
+    #endif
+
+    for (uint8_t xo = 0; xo <= xlen; xo++)
+      for (uint8_t yo = 0; yo <= ylen; yo++) {
+        uint8_t x2 = ctrx2 + xo, y2 = ctry2 + yo;
+        #ifndef HALF_IN_X
+          const uint8_t x1 = ctrx1 - xo;
+        #endif
+        #ifndef HALF_IN_Y
+          const uint8_t y1 = ctry1 - yo;
+          #ifndef HALF_IN_X
+            extrapolate_one_point(x1, y1, +1, +1);   //  left-below + +
+          #endif
+          extrapolate_one_point(x2, y1, -1, +1);     // right-below - +
+        #endif
+        #ifndef HALF_IN_X
+          extrapolate_one_point(x1, y2, +1, -1);     //  left-above + -
+        #endif
+        extrapolate_one_point(x2, y2, -1, -1);       // right-above - -
+      }
+
+  }
+
+  static void print_bilinear_leveling_grid() {
+    SERIAL_ECHOLNPGM("Bilinear Leveling Grid:");
+    print_2d_array(GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y, 3,
+      [](const uint8_t ix, const uint8_t iy) { return z_values[ix][iy]; }
+    );
+  }
+
+  #if ENABLED(ABL_BILINEAR_SUBDIVISION)
+
+    #define ABL_GRID_POINTS_VIRT_X (GRID_MAX_POINTS_X - 1) * (BILINEAR_SUBDIVISIONS) + 1
+    #define ABL_GRID_POINTS_VIRT_Y (GRID_MAX_POINTS_Y - 1) * (BILINEAR_SUBDIVISIONS) + 1
+    #define ABL_TEMP_POINTS_X (GRID_MAX_POINTS_X + 2)
+    #define ABL_TEMP_POINTS_Y (GRID_MAX_POINTS_Y + 2)
+    float z_values_virt[ABL_GRID_POINTS_VIRT_X][ABL_GRID_POINTS_VIRT_Y];
+    int bilinear_grid_spacing_virt[2] = { 0 };
+    float bilinear_grid_factor_virt[2] = { 0 };
+
+    static void print_bilinear_leveling_grid_virt() {
+      SERIAL_ECHOLNPGM("Subdivided with CATMULL ROM Leveling Grid:");
+      print_2d_array(ABL_GRID_POINTS_VIRT_X, ABL_GRID_POINTS_VIRT_Y, 5,
+        [](const uint8_t ix, const uint8_t iy) { return z_values_virt[ix][iy]; }
+      );
+    }
+
+    #define LINEAR_EXTRAPOLATION(E, I) ((E) * 2 - (I))
+    float bed_level_virt_coord(const uint8_t x, const uint8_t y) {
+      uint8_t ep = 0, ip = 1;
+      if (!x || x == ABL_TEMP_POINTS_X - 1) {
+        if (x) {
+          ep = GRID_MAX_POINTS_X - 1;
+          ip = GRID_MAX_POINTS_X - 2;
+        }
+        if (WITHIN(y, 1, ABL_TEMP_POINTS_Y - 2))
+          return LINEAR_EXTRAPOLATION(
+            z_values[ep][y - 1],
+            z_values[ip][y - 1]
+          );
+        else
+          return LINEAR_EXTRAPOLATION(
+            bed_level_virt_coord(ep + 1, y),
+            bed_level_virt_coord(ip + 1, y)
+          );
+      }
+      if (!y || y == ABL_TEMP_POINTS_Y - 1) {
+        if (y) {
+          ep = GRID_MAX_POINTS_Y - 1;
+          ip = GRID_MAX_POINTS_Y - 2;
+        }
+        if (WITHIN(x, 1, ABL_TEMP_POINTS_X - 2))
+          return LINEAR_EXTRAPOLATION(
+            z_values[x - 1][ep],
+            z_values[x - 1][ip]
+          );
+        else
+          return LINEAR_EXTRAPOLATION(
+            bed_level_virt_coord(x, ep + 1),
+            bed_level_virt_coord(x, ip + 1)
+          );
+      }
+      return z_values[x - 1][y - 1];
+    }
+
+    static float bed_level_virt_cmr(const float p[4], const uint8_t i, const float t) {
+      return (
+          p[i-1] * -t * sq(1 - t)
+        + p[i]   * (2 - 5 * sq(t) + 3 * t * sq(t))
+        + p[i+1] * t * (1 + 4 * t - 3 * sq(t))
+        - p[i+2] * sq(t) * (1 - t)
+      ) * 0.5;
+    }
+
+    static float bed_level_virt_2cmr(const uint8_t x, const uint8_t y, const float &tx, const float &ty) {
+      float row[4], column[4];
+      for (uint8_t i = 0; i < 4; i++) {
+        for (uint8_t j = 0; j < 4; j++) {
+          column[j] = bed_level_virt_coord(i + x - 1, j + y - 1);
+        }
+        row[i] = bed_level_virt_cmr(column, 1, ty);
+      }
+      return bed_level_virt_cmr(row, 1, tx);
+    }
+
+    void bed_level_virt_interpolate() {
+      bilinear_grid_spacing_virt[X_AXIS] = bilinear_grid_spacing[X_AXIS] / (BILINEAR_SUBDIVISIONS);
+      bilinear_grid_spacing_virt[Y_AXIS] = bilinear_grid_spacing[Y_AXIS] / (BILINEAR_SUBDIVISIONS);
+      bilinear_grid_factor_virt[X_AXIS] = RECIPROCAL(bilinear_grid_spacing_virt[X_AXIS]);
+      bilinear_grid_factor_virt[Y_AXIS] = RECIPROCAL(bilinear_grid_spacing_virt[Y_AXIS]);
+      for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
+        for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
+          for (uint8_t ty = 0; ty < BILINEAR_SUBDIVISIONS; ty++)
+            for (uint8_t tx = 0; tx < BILINEAR_SUBDIVISIONS; tx++) {
+              if ((ty && y == GRID_MAX_POINTS_Y - 1) || (tx && x == GRID_MAX_POINTS_X - 1))
+                continue;
+              z_values_virt[x * (BILINEAR_SUBDIVISIONS) + tx][y * (BILINEAR_SUBDIVISIONS) + ty] =
+                bed_level_virt_2cmr(
+                  x + 1,
+                  y + 1,
+                  (float)tx / (BILINEAR_SUBDIVISIONS),
+                  (float)ty / (BILINEAR_SUBDIVISIONS)
+                );
+            }
+    }
+  #endif // ABL_BILINEAR_SUBDIVISION
+
+  // Refresh after other values have been updated
+  void refresh_bed_level() {
+    bilinear_grid_factor[X_AXIS] = RECIPROCAL(bilinear_grid_spacing[X_AXIS]);
+    bilinear_grid_factor[Y_AXIS] = RECIPROCAL(bilinear_grid_spacing[Y_AXIS]);
+    #if ENABLED(ABL_BILINEAR_SUBDIVISION)
+      bed_level_virt_interpolate();
+    #endif
+  }
+
+#endif // AUTO_BED_LEVELING_BILINEAR
+
+/**
+ * Home an individual linear axis
+ */
+static void do_homing_move(const AxisEnum axis, const float distance, const float fr_mm_s=0.0) {
+
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) {
+      SERIAL_ECHOPAIR(">>> do_homing_move(", axis_codes[axis]);
+      SERIAL_ECHOPAIR(", ", distance);
+      SERIAL_ECHOPAIR(", ", fr_mm_s);
+      SERIAL_CHAR(')');
+      SERIAL_EOL();
+    }
+  #endif
+
+  #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
+    const bool deploy_bltouch = (axis == Z_AXIS && distance < 0);
+    if (deploy_bltouch) set_bltouch_deployed(true);
+  #endif
+
+  #if QUIET_PROBING
+    if (axis == Z_AXIS) probing_pause(true);
+  #endif
+
+  // Tell the planner we're at Z=0
+  current_position[axis] = 0;
+
+  #if IS_SCARA
+    SYNC_PLAN_POSITION_KINEMATIC();
+    current_position[axis] = distance;
+    inverse_kinematics(current_position);
+    planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], current_position[E_AXIS], fr_mm_s ? fr_mm_s : homing_feedrate(axis), active_extruder);
+  #else
+    sync_plan_position();
+    current_position[axis] = distance;
+    planner.buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], fr_mm_s ? fr_mm_s : homing_feedrate(axis), active_extruder);
+  #endif
+
+  stepper.synchronize();
+
+  #if QUIET_PROBING
+    if (axis == Z_AXIS) probing_pause(false);
+  #endif
+
+  #if HOMING_Z_WITH_PROBE && ENABLED(BLTOUCH)
+    if (deploy_bltouch) set_bltouch_deployed(false);
+  #endif
+
+  endstops.hit_on_purpose();
+
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) {
+      SERIAL_ECHOPAIR("<<< do_homing_move(", axis_codes[axis]);
+      SERIAL_CHAR(')');
+      SERIAL_EOL();
+    }
+  #endif
+}
+
+/**
+ * TMC2130 specific sensorless homing using stallGuard2.
+ * stallGuard2 only works when in spreadCycle mode.
+ * spreadCycle and stealthChop are mutually exclusive.
+ */
+#if ENABLED(SENSORLESS_HOMING)
+  void tmc2130_sensorless_homing(TMC2130Stepper &st, bool enable=true) {
+    #if ENABLED(STEALTHCHOP)
+      if (enable) {
+        st.coolstep_min_speed(1024UL * 1024UL - 1UL);
+        st.stealthChop(0);
+      }
+      else {
+        st.coolstep_min_speed(0);
+        st.stealthChop(1);
+      }
+    #endif
+
+    st.diag1_stall(enable ? 1 : 0);
+  }
+#endif
+
+/**
+ * Home an individual "raw axis" to its endstop.
+ * This applies to XYZ on Cartesian and Core robots, and
+ * to the individual ABC steppers on DELTA and SCARA.
+ *
+ * At the end of the procedure the axis is marked as
+ * homed and the current position of that axis is updated.
+ * Kinematic robots should wait till all axes are homed
+ * before updating the current position.
+ */
+
+#define HOMEAXIS(LETTER) homeaxis(LETTER##_AXIS)
+
+static void homeaxis(const AxisEnum axis) {
+
+  #if IS_SCARA
+    // Only Z homing (with probe) is permitted
+    if (axis != Z_AXIS) { BUZZ(100, 880); return; }
+  #else
+    #define CAN_HOME(A) \
+      (axis == A##_AXIS && ((A##_MIN_PIN > -1 && A##_HOME_DIR < 0) || (A##_MAX_PIN > -1 && A##_HOME_DIR > 0)))
+    if (!CAN_HOME(X) && !CAN_HOME(Y) && !CAN_HOME(Z)) return;
+  #endif
+
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) {
+      SERIAL_ECHOPAIR(">>> homeaxis(", axis_codes[axis]);
+      SERIAL_CHAR(')');
+      SERIAL_EOL();
+    }
+  #endif
+
+  const int axis_home_dir =
+    #if ENABLED(DUAL_X_CARRIAGE)
+      (axis == X_AXIS) ? x_home_dir(active_extruder) :
+    #endif
+    home_dir(axis);
+
+  // Homing Z towards the bed? Deploy the Z probe or endstop.
+  #if HOMING_Z_WITH_PROBE
+    if (axis == Z_AXIS && DEPLOY_PROBE()) return;
+  #endif
+
+  // Set a flag for Z motor locking
+  #if ENABLED(Z_DUAL_ENDSTOPS)
+    if (axis == Z_AXIS) stepper.set_homing_flag(true);
+  #endif
+
+  // Disable stealthChop if used. Enable diag1 pin on driver.
+  #if ENABLED(SENSORLESS_HOMING)
+    #if ENABLED(X_IS_TMC2130)
+      if (axis == X_AXIS) tmc2130_sensorless_homing(stepperX);
+    #endif
+    #if ENABLED(Y_IS_TMC2130)
+      if (axis == Y_AXIS) tmc2130_sensorless_homing(stepperY);
+    #endif
+  #endif
+
+  // Fast move towards endstop until triggered
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 1 Fast:");
+  #endif
+  do_homing_move(axis, 1.5 * max_length(axis) * axis_home_dir);
+
+  // When homing Z with probe respect probe clearance
+  const float bump = axis_home_dir * (
+    #if HOMING_Z_WITH_PROBE
+      (axis == Z_AXIS) ? max(Z_CLEARANCE_BETWEEN_PROBES, home_bump_mm(Z_AXIS)) :
+    #endif
+    home_bump_mm(axis)
+  );
+
+  // If a second homing move is configured...
+  if (bump) {
+    // Move away from the endstop by the axis HOME_BUMP_MM
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Move Away:");
+    #endif
+    do_homing_move(axis, -bump);
+
+    // Slow move towards endstop until triggered
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Home 2 Slow:");
+    #endif
+    do_homing_move(axis, 2 * bump, get_homing_bump_feedrate(axis));
+  }
+
+  #if ENABLED(Z_DUAL_ENDSTOPS)
+    if (axis == Z_AXIS) {
+      float adj = FABS(z_endstop_adj);
+      bool lockZ1;
+      if (axis_home_dir > 0) {
+        adj = -adj;
+        lockZ1 = (z_endstop_adj > 0);
+      }
+      else
+        lockZ1 = (z_endstop_adj < 0);
+
+      if (lockZ1) stepper.set_z_lock(true); else stepper.set_z2_lock(true);
+
+      // Move to the adjusted endstop height
+      do_homing_move(axis, adj);
+
+      if (lockZ1) stepper.set_z_lock(false); else stepper.set_z2_lock(false);
+      stepper.set_homing_flag(false);
+    } // Z_AXIS
+  #endif
+
+  #if IS_SCARA
+
+    set_axis_is_at_home(axis);
+    SYNC_PLAN_POSITION_KINEMATIC();
+
+  #elif ENABLED(DELTA)
+
+    // Delta has already moved all three towers up in G28
+    // so here it re-homes each tower in turn.
+    // Delta homing treats the axes as normal linear axes.
+
+    // retrace by the amount specified in endstop_adj + additional 0.1mm in order to have minimum steps
+    if (endstop_adj[axis] * Z_HOME_DIR <= 0) {
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("endstop_adj:");
+      #endif
+      do_homing_move(axis, endstop_adj[axis] - 0.1);
+    }
+
+  #else
+
+    // For cartesian/core machines,
+    // set the axis to its home position
+    set_axis_is_at_home(axis);
+    sync_plan_position();
+
+    destination[axis] = current_position[axis];
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) DEBUG_POS("> AFTER set_axis_is_at_home", current_position);
+    #endif
+
+  #endif
+
+  // Re-enable stealthChop if used. Disable diag1 pin on driver.
+  #if ENABLED(SENSORLESS_HOMING)
+    #if ENABLED(X_IS_TMC2130)
+      if (axis == X_AXIS) tmc2130_sensorless_homing(stepperX, false);
+    #endif
+    #if ENABLED(Y_IS_TMC2130)
+      if (axis == Y_AXIS) tmc2130_sensorless_homing(stepperY, false);
+    #endif
+  #endif
+
+  // Put away the Z probe
+  #if HOMING_Z_WITH_PROBE
+    if (axis == Z_AXIS && STOW_PROBE()) return;
+  #endif
+
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) {
+      SERIAL_ECHOPAIR("<<< homeaxis(", axis_codes[axis]);
+      SERIAL_CHAR(')');
+      SERIAL_EOL();
+    }
+  #endif
+} // homeaxis()
+
+#if ENABLED(FWRETRACT)
+
+  /**
+   * Retract or recover according to firmware settings
+   *
+   * This function handles retract/recover moves for G10 and G11,
+   * plus auto-retract moves sent from G0/G1 when E-only moves are done.
+   *
+   * To simplify the logic, doubled retract/recover moves are ignored.
+   *
+   * Note: Z lift is done transparently to the planner. Aborting
+   *       a print between G10 and G11 may corrupt the Z position.
+   *
+   * Note: Auto-retract will apply the set Z hop in addition to any Z hop
+   *       included in the G-code. Use M207 Z0 to to prevent double hop.
+   */
+  void retract(const bool retracting
+    #if EXTRUDERS > 1
+      , bool swapping = false
+    #endif
+  ) {
+
+    static float hop_height,        // Remember where the Z height started
+                 hop_amount = 0.0;  // Total amount lifted, for use in recover
+
+    // Simply never allow two retracts or recovers in a row
+    if (retracted[active_extruder] == retracting) return;
+
+    #if EXTRUDERS < 2
+      bool swapping = false;
+    #endif
+    if (!retracting) swapping = retracted_swap[active_extruder];
+
+    /* // debugging
+      SERIAL_ECHOLNPAIR("retracting ", retracting);
+      SERIAL_ECHOLNPAIR("swapping ", swapping);
+      SERIAL_ECHOLNPAIR("active extruder ", active_extruder);
+      for (uint8_t i = 0; i < EXTRUDERS; ++i) {
+        SERIAL_ECHOPAIR("retracted[", i);
+        SERIAL_ECHOLNPAIR("] ", retracted[i]);
+        SERIAL_ECHOPAIR("retracted_swap[", i);
+        SERIAL_ECHOLNPAIR("] ", retracted_swap[i]);
+      }
+      SERIAL_ECHOLNPAIR("current_position[z] ", current_position[Z_AXIS]);
+      SERIAL_ECHOLNPAIR("hop_amount ", hop_amount);
+    //*/
+
+    const bool has_zhop = retract_zlift > 0.01;     // Is there a hop set?
+
+    const float old_feedrate_mm_s = feedrate_mm_s;
+    const int16_t old_flow = flow_percentage[active_extruder];
+
+    // Don't apply flow multiplication to retract/recover
+    flow_percentage[active_extruder] = 100;
+
+    // The current position will be the destination for E and Z moves
+    set_destination_to_current();
+
+    if (retracting) {
+      // Remember the Z height since G-code may include its own Z-hop
+      // For best results turn off Z hop if G-code already includes it
+      hop_height = destination[Z_AXIS];
+
+      // Retract by moving from a faux E position back to the current E position
+      feedrate_mm_s = retract_feedrate_mm_s;
+      current_position[E_AXIS] += (swapping ? swap_retract_length : retract_length) / volumetric_multiplier[active_extruder];
+      sync_plan_position_e();
+      prepare_move_to_destination();
+
+      // Is a Z hop set, and has the hop not yet been done?
+      if (has_zhop) {
+        hop_amount += retract_zlift;                // Carriage is raised for retraction hop
+        current_position[Z_AXIS] -= retract_zlift;  // Pretend current pos is lower. Next move raises Z.
+        SYNC_PLAN_POSITION_KINEMATIC();             // Set the planner to the new position
+        prepare_move_to_destination();              // Raise up to the old current pos
+      }
+    }
+    else {
+      // If a hop was done and Z hasn't changed, undo the Z hop
+      if (hop_amount && NEAR(hop_height, destination[Z_AXIS])) {
+        current_position[Z_AXIS] += hop_amount;     // Pretend current pos is higher. Next move lowers Z.
+        SYNC_PLAN_POSITION_KINEMATIC();             // Set the planner to the new position
+        prepare_move_to_destination();              // Lower to the old current pos
+        hop_amount = 0.0;
+      }
+
+      // A retract multiplier has been added here to get faster swap recovery
+      feedrate_mm_s = swapping ? swap_retract_recover_feedrate_mm_s : retract_recover_feedrate_mm_s;
+
+      const float move_e = swapping ? swap_retract_length + swap_retract_recover_length : retract_length + retract_recover_length;
+      current_position[E_AXIS] -= move_e / volumetric_multiplier[active_extruder];
+      sync_plan_position_e();
+
+      prepare_move_to_destination();  // Recover E
+    }
+
+    // Restore flow and feedrate
+    flow_percentage[active_extruder] = old_flow;
+    feedrate_mm_s = old_feedrate_mm_s;
+
+    // The active extruder is now retracted or recovered
+    retracted[active_extruder] = retracting;
+
+    // If swap retract/recover then update the retracted_swap flag too
+    #if EXTRUDERS > 1
+      if (swapping) retracted_swap[active_extruder] = retracting;
+    #endif
+
+    /* // debugging
+      SERIAL_ECHOLNPAIR("retracting ", retracting);
+      SERIAL_ECHOLNPAIR("swapping ", swapping);
+      SERIAL_ECHOLNPAIR("active_extruder ", active_extruder);
+      for (uint8_t i = 0; i < EXTRUDERS; ++i) {
+        SERIAL_ECHOPAIR("retracted[", i);
+        SERIAL_ECHOLNPAIR("] ", retracted[i]);
+        SERIAL_ECHOPAIR("retracted_swap[", i);
+        SERIAL_ECHOLNPAIR("] ", retracted_swap[i]);
+      }
+      SERIAL_ECHOLNPAIR("current_position[z] ", current_position[Z_AXIS]);
+      SERIAL_ECHOLNPAIR("hop_amount ", hop_amount);
+    //*/
+
+  } // retract()
+
+#endif // FWRETRACT
+
+#if ENABLED(MIXING_EXTRUDER)
+
+  void normalize_mix() {
+    float mix_total = 0.0;
+    for (uint8_t i = 0; i < MIXING_STEPPERS; i++) mix_total += RECIPROCAL(mixing_factor[i]);
+    // Scale all values if they don't add up to ~1.0
+    if (!NEAR(mix_total, 1.0)) {
+      SERIAL_PROTOCOLLNPGM("Warning: Mix factors must add up to 1.0. Scaling.");
+      for (uint8_t i = 0; i < MIXING_STEPPERS; i++) mixing_factor[i] *= mix_total;
+    }
+  }
+
+  #if ENABLED(DIRECT_MIXING_IN_G1)
+    // Get mixing parameters from the GCode
+    // The total "must" be 1.0 (but it will be normalized)
+    // If no mix factors are given, the old mix is preserved
+    void gcode_get_mix() {
+      const char* mixing_codes = "ABCDHI";
+      byte mix_bits = 0;
+      for (uint8_t i = 0; i < MIXING_STEPPERS; i++) {
+        if (parser.seenval(mixing_codes[i])) {
+          SBI(mix_bits, i);
+          float v = parser.value_float();
+          NOLESS(v, 0.0);
+          mixing_factor[i] = RECIPROCAL(v);
+        }
+      }
+      // If any mixing factors were included, clear the rest
+      // If none were included, preserve the last mix
+      if (mix_bits) {
+        for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
+          if (!TEST(mix_bits, i)) mixing_factor[i] = 0.0;
+        normalize_mix();
+      }
+    }
+  #endif
+
+#endif
+
+/**
+ * ***************************************************************************
+ * ***************************** G-CODE HANDLING *****************************
+ * ***************************************************************************
+ */
+
+/**
+ * Set XYZE destination and feedrate from the current GCode command
+ *
+ *  - Set destination from included axis codes
+ *  - Set to current for missing axis codes
+ *  - Set the feedrate, if included
+ */
+void gcode_get_destination() {
+  LOOP_XYZE(i) {
+    if (parser.seen(axis_codes[i]))
+      destination[i] = parser.value_axis_units((AxisEnum)i) + (axis_relative_modes[i] || relative_mode ? current_position[i] : 0);
+    else
+      destination[i] = current_position[i];
+  }
+
+  if (parser.linearval('F') > 0.0)
+    feedrate_mm_s = MMM_TO_MMS(parser.value_feedrate());
+
+  #if ENABLED(PRINTCOUNTER)
+    if (!DEBUGGING(DRYRUN))
+      print_job_timer.incFilamentUsed(destination[E_AXIS] - current_position[E_AXIS]);
+  #endif
+
+  // Get ABCDHI mixing factors
+  #if ENABLED(MIXING_EXTRUDER) && ENABLED(DIRECT_MIXING_IN_G1)
+    gcode_get_mix();
+  #endif
+}
+
+#if ENABLED(HOST_KEEPALIVE_FEATURE)
+
+  /**
+   * Output a "busy" message at regular intervals
+   * while the machine is not accepting commands.
+   */
+  void host_keepalive() {
+    const millis_t ms = millis();
+    if (host_keepalive_interval && busy_state != NOT_BUSY) {
+      if (PENDING(ms, next_busy_signal_ms)) return;
+      switch (busy_state) {
+        case IN_HANDLER:
+        case IN_PROCESS:
+          SERIAL_ECHO_START();
+          SERIAL_ECHOLNPGM(MSG_BUSY_PROCESSING);
+          break;
+        case PAUSED_FOR_USER:
+          SERIAL_ECHO_START();
+          SERIAL_ECHOLNPGM(MSG_BUSY_PAUSED_FOR_USER);
+          break;
+        case PAUSED_FOR_INPUT:
+          SERIAL_ECHO_START();
+          SERIAL_ECHOLNPGM(MSG_BUSY_PAUSED_FOR_INPUT);
+          break;
+        default:
+          break;
+      }
+    }
+    next_busy_signal_ms = ms + host_keepalive_interval * 1000UL;
+  }
+
+#endif // HOST_KEEPALIVE_FEATURE
+
+
+/**************************************************
+ ***************** GCode Handlers *****************
+ **************************************************/
+
+/**
+ * G0, G1: Coordinated movement of X Y Z E axes
+ */
+inline void gcode_G0_G1(
+  #if IS_SCARA
+    bool fast_move=false
+  #endif
+) {
+  if (IsRunning()) {
+    gcode_get_destination(); // For X Y Z E F
+
+    #if ENABLED(FWRETRACT)
+      if (MIN_AUTORETRACT <= MAX_AUTORETRACT) {
+        // When M209 Autoretract is enabled, convert E-only moves to firmware retract/recover moves
+        if (autoretract_enabled && parser.seen('E') && !(parser.seen('X') || parser.seen('Y') || parser.seen('Z'))) {
+          const float echange = destination[E_AXIS] - current_position[E_AXIS];
+          // Is this a retract or recover move?
+          if (WITHIN(FABS(echange), MIN_AUTORETRACT, MAX_AUTORETRACT) && retracted[active_extruder] == (echange > 0.0)) {
+            current_position[E_AXIS] = destination[E_AXIS]; // Hide a G1-based retract/recover from calculations
+            sync_plan_position_e();                         // AND from the planner
+            return retract(echange < 0.0);                  // Firmware-based retract/recover (double-retract ignored)
+          }
+        }
+      }
+    #endif // FWRETRACT
+
+    #if IS_SCARA
+      fast_move ? prepare_uninterpolated_move_to_destination() : prepare_move_to_destination();
+    #else
+      prepare_move_to_destination();
+    #endif
+  }
+}
+
+/**
+ * G2: Clockwise Arc
+ * G3: Counterclockwise Arc
+ *
+ * This command has two forms: IJ-form and R-form.
+ *
+ *  - I specifies an X offset. J specifies a Y offset.
+ *    At least one of the IJ parameters is required.
+ *    X and Y can be omitted to do a complete circle.
+ *    The given XY is not error-checked. The arc ends
+ *     based on the angle of the destination.
+ *    Mixing I or J with R will throw an error.
+ *
+ *  - R specifies the radius. X or Y is required.
+ *    Omitting both X and Y will throw an error.
+ *    X or Y must differ from the current XY.
+ *    Mixing R with I or J will throw an error.
+ *
+ *  - P specifies the number of full circles to do
+ *    before the specified arc move.
+ *
+ *  Examples:
+ *
+ *    G2 I10           ; CW circle centered at X+10
+ *    G3 X20 Y12 R14   ; CCW circle with r=14 ending at X20 Y12
+ */
+#if ENABLED(ARC_SUPPORT)
+
+  inline void gcode_G2_G3(bool clockwise) {
+    if (IsRunning()) {
+
+      #if ENABLED(SF_ARC_FIX)
+        const bool relative_mode_backup = relative_mode;
+        relative_mode = true;
+      #endif
+
+      gcode_get_destination();
+
+      #if ENABLED(SF_ARC_FIX)
+        relative_mode = relative_mode_backup;
+      #endif
+
+      float arc_offset[2] = { 0.0, 0.0 };
+      if (parser.seenval('R')) {
+        const float r = parser.value_linear_units(),
+                    p1 = current_position[X_AXIS], q1 = current_position[Y_AXIS],
+                    p2 = destination[X_AXIS], q2 = destination[Y_AXIS];
+        if (r && (p2 != p1 || q2 != q1)) {
+          const float e = clockwise ^ (r < 0) ? -1 : 1,           // clockwise -1/1, counterclockwise 1/-1
+                      dx = p2 - p1, dy = q2 - q1,                 // X and Y differences
+                      d = HYPOT(dx, dy),                          // Linear distance between the points
+                      h = SQRT(sq(r) - sq(d * 0.5)),              // Distance to the arc pivot-point
+                      mx = (p1 + p2) * 0.5, my = (q1 + q2) * 0.5, // Point between the two points
+                      sx = -dy / d, sy = dx / d,                  // Slope of the perpendicular bisector
+                      cx = mx + e * h * sx, cy = my + e * h * sy; // Pivot-point of the arc
+          arc_offset[0] = cx - p1;
+          arc_offset[1] = cy - q1;
+        }
+      }
+      else {
+        if (parser.seenval('I')) arc_offset[0] = parser.value_linear_units();
+        if (parser.seenval('J')) arc_offset[1] = parser.value_linear_units();
+      }
+
+      if (arc_offset[0] || arc_offset[1]) {
+
+        #if ENABLED(ARC_P_CIRCLES)
+          // P indicates number of circles to do
+          int8_t circles_to_do = parser.byteval('P');
+          if (!WITHIN(circles_to_do, 0, 100)) {
+            SERIAL_ERROR_START();
+            SERIAL_ERRORLNPGM(MSG_ERR_ARC_ARGS);
+          }
+          while (circles_to_do--)
+            plan_arc(current_position, arc_offset, clockwise);
+        #endif
+
+        // Send the arc to the planner
+        plan_arc(destination, arc_offset, clockwise);
+        refresh_cmd_timeout();
+      }
+      else {
+        // Bad arguments
+        SERIAL_ERROR_START();
+        SERIAL_ERRORLNPGM(MSG_ERR_ARC_ARGS);
+      }
+    }
+  }
+
+#endif // ARC_SUPPORT
+
+void dwell(millis_t time) {
+  refresh_cmd_timeout();
+  time += previous_cmd_ms;
+  while (PENDING(millis(), time)) idle();
+}
+
+/**
+ * G4: Dwell S<seconds> or P<milliseconds>
+ */
+inline void gcode_G4() {
+  millis_t dwell_ms = 0;
+
+  if (parser.seenval('P')) dwell_ms = parser.value_millis(); // milliseconds to wait
+  if (parser.seenval('S')) dwell_ms = parser.value_millis_from_seconds(); // seconds to wait
+
+  stepper.synchronize();
+
+  if (!lcd_hasstatus()) LCD_MESSAGEPGM(MSG_DWELL);
+
+  dwell(dwell_ms);
+}
+
+#if ENABLED(BEZIER_CURVE_SUPPORT)
+
+  /**
+   * Parameters interpreted according to:
+   * http://linuxcnc.org/docs/2.6/html/gcode/gcode.html#sec:G5-Cubic-Spline
+   * However I, J omission is not supported at this point; all
+   * parameters can be omitted and default to zero.
+   */
+
+  /**
+   * G5: Cubic B-spline
+   */
+  inline void gcode_G5() {
+    if (IsRunning()) {
+
+      #if ENABLED(CNC_WORKSPACE_PLANES)
+        if (workspace_plane != PLANE_XY) {
+          SERIAL_ERROR_START();
+          SERIAL_ERRORLNPGM(MSG_ERR_BAD_PLANE_MODE);
+          return;
+        }
+      #endif
+
+      gcode_get_destination();
+
+      const float offset[] = {
+        parser.linearval('I'),
+        parser.linearval('J'),
+        parser.linearval('P'),
+        parser.linearval('Q')
+      };
+
+      plan_cubic_move(offset);
+    }
+  }
+
+#endif // BEZIER_CURVE_SUPPORT
+
+#if ENABLED(FWRETRACT)
+
+  /**
+   * G10 - Retract filament according to settings of M207
+   */
+  inline void gcode_G10() {
+    #if EXTRUDERS > 1
+      const bool rs = parser.boolval('S');
+      retracted_swap[active_extruder] = rs; // Use 'S' for swap, default to false
+    #endif
+    retract(true
+      #if EXTRUDERS > 1
+        , rs
+      #endif
+    );
+  }
+
+  /**
+   * G11 - Recover filament according to settings of M208
+   */
+  inline void gcode_G11() { retract(false); }
+
+#endif // FWRETRACT
+
+#if ENABLED(NOZZLE_CLEAN_FEATURE)
+  /**
+   * G12: Clean the nozzle
+   */
+  inline void gcode_G12() {
+    // Don't allow nozzle cleaning without homing first
+    if (axis_unhomed_error()) return;
+
+    const uint8_t pattern = parser.ushortval('P', 0),
+                  strokes = parser.ushortval('S', NOZZLE_CLEAN_STROKES),
+                  objects = parser.ushortval('T', NOZZLE_CLEAN_TRIANGLES);
+    const float radius = parser.floatval('R', NOZZLE_CLEAN_CIRCLE_RADIUS);
+
+    Nozzle::clean(pattern, strokes, radius, objects);
+  }
+#endif
+
+#if ENABLED(CNC_WORKSPACE_PLANES)
+
+  void report_workspace_plane() {
+    SERIAL_ECHO_START();
+    SERIAL_ECHOPGM("Workspace Plane ");
+    serialprintPGM(workspace_plane == PLANE_YZ ? PSTR("YZ\n") : workspace_plane == PLANE_ZX ? PSTR("ZX\n") : PSTR("XY\n"));
+  }
+
+  /**
+   * G17: Select Plane XY
+   * G18: Select Plane ZX
+   * G19: Select Plane YZ
+   */
+  inline void gcode_G17() { workspace_plane = PLANE_XY; }
+  inline void gcode_G18() { workspace_plane = PLANE_ZX; }
+  inline void gcode_G19() { workspace_plane = PLANE_YZ; }
+
+#endif // CNC_WORKSPACE_PLANES
+
+#if ENABLED(INCH_MODE_SUPPORT)
+  /**
+   * G20: Set input mode to inches
+   */
+  inline void gcode_G20() { parser.set_input_linear_units(LINEARUNIT_INCH); }
+
+  /**
+   * G21: Set input mode to millimeters
+   */
+  inline void gcode_G21() { parser.set_input_linear_units(LINEARUNIT_MM); }
+#endif
+
+#if ENABLED(NOZZLE_PARK_FEATURE)
+  /**
+   * G27: Park the nozzle
+   */
+  inline void gcode_G27() {
+    // Don't allow nozzle parking without homing first
+    if (axis_unhomed_error()) return;
+    Nozzle::park(parser.ushortval('P'));
+  }
+#endif // NOZZLE_PARK_FEATURE
+
+#if ENABLED(QUICK_HOME)
+
+  static void quick_home_xy() {
+
+    // Pretend the current position is 0,0
+    current_position[X_AXIS] = current_position[Y_AXIS] = 0.0;
+    sync_plan_position();
+
+    const int x_axis_home_dir =
+      #if ENABLED(DUAL_X_CARRIAGE)
+        x_home_dir(active_extruder)
+      #else
+        home_dir(X_AXIS)
+      #endif
+    ;
+
+    const float mlx = max_length(X_AXIS),
+                mly = max_length(Y_AXIS),
+                mlratio = mlx > mly ? mly / mlx : mlx / mly,
+                fr_mm_s = min(homing_feedrate(X_AXIS), homing_feedrate(Y_AXIS)) * SQRT(sq(mlratio) + 1.0);
+
+    do_blocking_move_to_xy(1.5 * mlx * x_axis_home_dir, 1.5 * mly * home_dir(Y_AXIS), fr_mm_s);
+    endstops.hit_on_purpose(); // clear endstop hit flags
+    current_position[X_AXIS] = current_position[Y_AXIS] = 0.0;
+  }
+
+#endif // QUICK_HOME
+
+#if ENABLED(DEBUG_LEVELING_FEATURE)
+
+  void log_machine_info() {
+    SERIAL_ECHOPGM("Machine Type: ");
+    #if ENABLED(DELTA)
+      SERIAL_ECHOLNPGM("Delta");
+    #elif IS_SCARA
+      SERIAL_ECHOLNPGM("SCARA");
+    #elif IS_CORE
+      SERIAL_ECHOLNPGM("Core");
+    #else
+      SERIAL_ECHOLNPGM("Cartesian");
+    #endif
+
+    SERIAL_ECHOPGM("Probe: ");
+    #if ENABLED(PROBE_MANUALLY)
+      SERIAL_ECHOLNPGM("PROBE_MANUALLY");
+    #elif ENABLED(FIX_MOUNTED_PROBE)
+      SERIAL_ECHOLNPGM("FIX_MOUNTED_PROBE");
+    #elif ENABLED(BLTOUCH)
+      SERIAL_ECHOLNPGM("BLTOUCH");
+    #elif HAS_Z_SERVO_ENDSTOP
+      SERIAL_ECHOLNPGM("SERVO PROBE");
+    #elif ENABLED(Z_PROBE_SLED)
+      SERIAL_ECHOLNPGM("Z_PROBE_SLED");
+    #elif ENABLED(Z_PROBE_ALLEN_KEY)
+      SERIAL_ECHOLNPGM("Z_PROBE_ALLEN_KEY");
+    #else
+      SERIAL_ECHOLNPGM("NONE");
+    #endif
+
+    #if HAS_BED_PROBE
+      SERIAL_ECHOPAIR("Probe Offset X:", X_PROBE_OFFSET_FROM_EXTRUDER);
+      SERIAL_ECHOPAIR(" Y:", Y_PROBE_OFFSET_FROM_EXTRUDER);
+      SERIAL_ECHOPAIR(" Z:", zprobe_zoffset);
+      #if X_PROBE_OFFSET_FROM_EXTRUDER > 0
+        SERIAL_ECHOPGM(" (Right");
+      #elif X_PROBE_OFFSET_FROM_EXTRUDER < 0
+        SERIAL_ECHOPGM(" (Left");
+      #elif Y_PROBE_OFFSET_FROM_EXTRUDER != 0
+        SERIAL_ECHOPGM(" (Middle");
+      #else
+        SERIAL_ECHOPGM(" (Aligned With");
+      #endif
+      #if Y_PROBE_OFFSET_FROM_EXTRUDER > 0
+        SERIAL_ECHOPGM("-Back");
+      #elif Y_PROBE_OFFSET_FROM_EXTRUDER < 0
+        SERIAL_ECHOPGM("-Front");
+      #elif X_PROBE_OFFSET_FROM_EXTRUDER != 0
+        SERIAL_ECHOPGM("-Center");
+      #endif
+      if (zprobe_zoffset < 0)
+        SERIAL_ECHOPGM(" & Below");
+      else if (zprobe_zoffset > 0)
+        SERIAL_ECHOPGM(" & Above");
+      else
+        SERIAL_ECHOPGM(" & Same Z as");
+      SERIAL_ECHOLNPGM(" Nozzle)");
+    #endif
+
+    #if HAS_ABL
+      SERIAL_ECHOPGM("Auto Bed Leveling: ");
+      #if ENABLED(AUTO_BED_LEVELING_LINEAR)
+        SERIAL_ECHOPGM("LINEAR");
+      #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
+        SERIAL_ECHOPGM("BILINEAR");
+      #elif ENABLED(AUTO_BED_LEVELING_3POINT)
+        SERIAL_ECHOPGM("3POINT");
+      #elif ENABLED(AUTO_BED_LEVELING_UBL)
+        SERIAL_ECHOPGM("UBL");
+      #endif
+      if (leveling_is_active()) {
+        SERIAL_ECHOLNPGM(" (enabled)");
+        #if ABL_PLANAR
+          const float diff[XYZ] = {
+            stepper.get_axis_position_mm(X_AXIS) - current_position[X_AXIS],
+            stepper.get_axis_position_mm(Y_AXIS) - current_position[Y_AXIS],
+            stepper.get_axis_position_mm(Z_AXIS) - current_position[Z_AXIS]
+          };
+          SERIAL_ECHOPGM("ABL Adjustment X");
+          if (diff[X_AXIS] > 0) SERIAL_CHAR('+');
+          SERIAL_ECHO(diff[X_AXIS]);
+          SERIAL_ECHOPGM(" Y");
+          if (diff[Y_AXIS] > 0) SERIAL_CHAR('+');
+          SERIAL_ECHO(diff[Y_AXIS]);
+          SERIAL_ECHOPGM(" Z");
+          if (diff[Z_AXIS] > 0) SERIAL_CHAR('+');
+          SERIAL_ECHO(diff[Z_AXIS]);
+        #elif ENABLED(AUTO_BED_LEVELING_UBL)
+          SERIAL_ECHOPAIR("UBL Adjustment Z", stepper.get_axis_position_mm(Z_AXIS) - current_position[Z_AXIS]);
+        #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
+          SERIAL_ECHOPAIR("ABL Adjustment Z", bilinear_z_offset(current_position));
+        #endif
+      }
+      else
+        SERIAL_ECHOLNPGM(" (disabled)");
+
+      SERIAL_EOL();
+
+    #elif ENABLED(MESH_BED_LEVELING)
+
+      SERIAL_ECHOPGM("Mesh Bed Leveling");
+      if (leveling_is_active()) {
+        float lz = current_position[Z_AXIS];
+        planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], lz);
+        SERIAL_ECHOLNPGM(" (enabled)");
+        SERIAL_ECHOPAIR("MBL Adjustment Z", lz);
+      }
+      else
+        SERIAL_ECHOPGM(" (disabled)");
+
+      SERIAL_EOL();
+
+    #endif // MESH_BED_LEVELING
+  }
+
+#endif // DEBUG_LEVELING_FEATURE
+
+#if ENABLED(DELTA)
+
+  /**
+   * A delta can only safely home all axes at the same time
+   * This is like quick_home_xy() but for 3 towers.
+   */
+  inline bool home_delta() {
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) DEBUG_POS(">>> home_delta", current_position);
+    #endif
+    // Init the current position of all carriages to 0,0,0
+    ZERO(current_position);
+    sync_plan_position();
+
+    // Move all carriages together linearly until an endstop is hit.
+    current_position[X_AXIS] = current_position[Y_AXIS] = current_position[Z_AXIS] = (DELTA_HEIGHT + home_offset[Z_AXIS] + 10);
+    feedrate_mm_s = homing_feedrate(X_AXIS);
+    line_to_current_position();
+    stepper.synchronize();
+
+    // If an endstop was not hit, then damage can occur if homing is continued.
+    // This can occur if the delta height (DELTA_HEIGHT + home_offset[Z_AXIS]) is
+    // not set correctly.
+    if (!(Endstops::endstop_hit_bits & (_BV(X_MAX) | _BV(Y_MAX) | _BV(Z_MAX)))) {
+      LCD_MESSAGEPGM(MSG_ERR_HOMING_FAILED);
+      SERIAL_ERROR_START();
+      SERIAL_ERRORLNPGM(MSG_ERR_HOMING_FAILED);
+      return false;
+    }
+
+    endstops.hit_on_purpose(); // clear endstop hit flags
+
+    // At least one carriage has reached the top.
+    // Now re-home each carriage separately.
+    HOMEAXIS(A);
+    HOMEAXIS(B);
+    HOMEAXIS(C);
+
+    // Set all carriages to their home positions
+    // Do this here all at once for Delta, because
+    // XYZ isn't ABC. Applying this per-tower would
+    // give the impression that they are the same.
+    LOOP_XYZ(i) set_axis_is_at_home((AxisEnum)i);
+
+    SYNC_PLAN_POSITION_KINEMATIC();
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) DEBUG_POS("<<< home_delta", current_position);
+    #endif
+
+    return true;
+  }
+
+#endif // DELTA
+
+#if ENABLED(Z_SAFE_HOMING)
+
+  inline void home_z_safely() {
+
+    // Disallow Z homing if X or Y are unknown
+    if (!axis_known_position[X_AXIS] || !axis_known_position[Y_AXIS]) {
+      LCD_MESSAGEPGM(MSG_ERR_Z_HOMING);
+      SERIAL_ECHO_START();
+      SERIAL_ECHOLNPGM(MSG_ERR_Z_HOMING);
+      return;
+    }
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Z_SAFE_HOMING >>>");
+    #endif
+
+    SYNC_PLAN_POSITION_KINEMATIC();
+
+    /**
+     * Move the Z probe (or just the nozzle) to the safe homing point
+     */
+    destination[X_AXIS] = LOGICAL_X_POSITION(Z_SAFE_HOMING_X_POINT);
+    destination[Y_AXIS] = LOGICAL_Y_POSITION(Z_SAFE_HOMING_Y_POINT);
+    destination[Z_AXIS] = current_position[Z_AXIS]; // Z is already at the right height
+
+    #if HOMING_Z_WITH_PROBE
+      destination[X_AXIS] -= X_PROBE_OFFSET_FROM_EXTRUDER;
+      destination[Y_AXIS] -= Y_PROBE_OFFSET_FROM_EXTRUDER;
+    #endif
+
+    if (position_is_reachable_xy(destination[X_AXIS], destination[Y_AXIS])) {
+
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        if (DEBUGGING(LEVELING)) DEBUG_POS("Z_SAFE_HOMING", destination);
+      #endif
+
+      // This causes the carriage on Dual X to unpark
+      #if ENABLED(DUAL_X_CARRIAGE)
+        active_extruder_parked = false;
+      #endif
+
+      do_blocking_move_to_xy(destination[X_AXIS], destination[Y_AXIS]);
+      HOMEAXIS(Z);
+    }
+    else {
+      LCD_MESSAGEPGM(MSG_ZPROBE_OUT);
+      SERIAL_ECHO_START();
+      SERIAL_ECHOLNPGM(MSG_ZPROBE_OUT);
+    }
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< Z_SAFE_HOMING");
+    #endif
+  }
+
+#endif // Z_SAFE_HOMING
+
+#if ENABLED(PROBE_MANUALLY)
+  bool g29_in_progress = false;
+#else
+  constexpr bool g29_in_progress = false;
+#endif
+
+/**
+ * G28: Home all axes according to settings
+ *
+ * Parameters
+ *
+ *  None  Home to all axes with no parameters.
+ *        With QUICK_HOME enabled XY will home together, then Z.
+ *
+ * Cartesian parameters
+ *
+ *  X   Home to the X endstop
+ *  Y   Home to the Y endstop
+ *  Z   Home to the Z endstop
+ *
+ */
+inline void gcode_G28(const bool always_home_all) {
+
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) {
+      SERIAL_ECHOLNPGM(">>> gcode_G28");
+      log_machine_info();
+    }
+  #endif
+
+  // Wait for planner moves to finish!
+  stepper.synchronize();
+
+  // Cancel the active G29 session
+  #if ENABLED(PROBE_MANUALLY)
+    g29_in_progress = false;
+  #endif
+
+  // Disable the leveling matrix before homing
+  #if HAS_LEVELING
+    #if ENABLED(AUTO_BED_LEVELING_UBL)
+      const bool ubl_state_at_entry = leveling_is_active();
+    #endif
+    set_bed_leveling_enabled(false);
+  #endif
+
+  #if ENABLED(CNC_WORKSPACE_PLANES)
+    workspace_plane = PLANE_XY;
+  #endif
+
+  // Always home with tool 0 active
+  #if HOTENDS > 1
+    const uint8_t old_tool_index = active_extruder;
+    tool_change(0, 0, true);
+  #endif
+
+  #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
+    extruder_duplication_enabled = false;
+  #endif
+
+  setup_for_endstop_or_probe_move();
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> endstops.enable(true)");
+  #endif
+  endstops.enable(true); // Enable endstops for next homing move
+
+  #if ENABLED(DELTA)
+
+    home_delta();
+    UNUSED(always_home_all);
+
+  #else // NOT DELTA
+
+    const bool homeX = always_home_all || parser.seen('X'),
+               homeY = always_home_all || parser.seen('Y'),
+               homeZ = always_home_all || parser.seen('Z'),
+               home_all = (!homeX && !homeY && !homeZ) || (homeX && homeY && homeZ);
+
+    set_destination_to_current();
+
+    #if Z_HOME_DIR > 0  // If homing away from BED do Z first
+
+      if (home_all || homeZ) {
+        HOMEAXIS(Z);
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) DEBUG_POS("> HOMEAXIS(Z)", current_position);
+        #endif
+      }
+
+    #else
+
+      if (home_all || homeX || homeY) {
+        // Raise Z before homing any other axes and z is not already high enough (never lower z)
+        destination[Z_AXIS] = LOGICAL_Z_POSITION(Z_HOMING_HEIGHT);
+        if (destination[Z_AXIS] > current_position[Z_AXIS]) {
+
+          #if ENABLED(DEBUG_LEVELING_FEATURE)
+            if (DEBUGGING(LEVELING))
+              SERIAL_ECHOLNPAIR("Raise Z (before homing) to ", destination[Z_AXIS]);
+          #endif
+
+          do_blocking_move_to_z(destination[Z_AXIS]);
+        }
+      }
+
+    #endif
+
+    #if ENABLED(QUICK_HOME)
+
+      if (home_all || (homeX && homeY)) quick_home_xy();
+
+    #endif
+
+    #if ENABLED(HOME_Y_BEFORE_X)
+
+      // Home Y
+      if (home_all || homeY) {
+        HOMEAXIS(Y);
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) DEBUG_POS("> homeY", current_position);
+        #endif
+      }
+
+    #endif
+
+    // Home X
+    if (home_all || homeX) {
+
+      #if ENABLED(DUAL_X_CARRIAGE)
+
+        // Always home the 2nd (right) extruder first
+        active_extruder = 1;
+        HOMEAXIS(X);
+
+        // Remember this extruder's position for later tool change
+        inactive_extruder_x_pos = RAW_X_POSITION(current_position[X_AXIS]);
+
+        // Home the 1st (left) extruder
+        active_extruder = 0;
+        HOMEAXIS(X);
+
+        // Consider the active extruder to be parked
+        COPY(raised_parked_position, current_position);
+        delayed_move_time = 0;
+        active_extruder_parked = true;
+
+      #else
+
+        HOMEAXIS(X);
+
+      #endif
+
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        if (DEBUGGING(LEVELING)) DEBUG_POS("> homeX", current_position);
+      #endif
+    }
+
+    #if DISABLED(HOME_Y_BEFORE_X)
+      // Home Y
+      if (home_all || homeY) {
+        HOMEAXIS(Y);
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) DEBUG_POS("> homeY", current_position);
+        #endif
+      }
+    #endif
+
+    // Home Z last if homing towards the bed
+    #if Z_HOME_DIR < 0
+      if (home_all || homeZ) {
+        #if ENABLED(Z_SAFE_HOMING)
+          home_z_safely();
+        #else
+          HOMEAXIS(Z);
+        #endif
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) DEBUG_POS("> (home_all || homeZ) > final", current_position);
+        #endif
+      } // home_all || homeZ
+    #endif // Z_HOME_DIR < 0
+
+    SYNC_PLAN_POSITION_KINEMATIC();
+
+  #endif // !DELTA (gcode_G28)
+
+  endstops.not_homing();
+
+  #if ENABLED(DELTA) && ENABLED(DELTA_HOME_TO_SAFE_ZONE)
+    // move to a height where we can use the full xy-area
+    do_blocking_move_to_z(delta_clip_start_height);
+  #endif
+
+  #if ENABLED(AUTO_BED_LEVELING_UBL)
+    set_bed_leveling_enabled(ubl_state_at_entry);
+  #endif
+
+  clean_up_after_endstop_or_probe_move();
+
+  // Restore the active tool after homing
+  #if HOTENDS > 1
+    tool_change(old_tool_index, 0,
+      #if ENABLED(PARKING_EXTRUDER)
+        false // fetch the previous toolhead
+      #else
+        true
+      #endif
+    );
+  #endif
+
+  lcd_refresh();
+
+  report_current_position();
+
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< gcode_G28");
+  #endif
+} // G28
+
+void home_all_axes() { gcode_G28(true); }
+
+#if HAS_PROBING_PROCEDURE
+
+  void out_of_range_error(const char* p_edge) {
+    SERIAL_PROTOCOLPGM("?Probe ");
+    serialprintPGM(p_edge);
+    SERIAL_PROTOCOLLNPGM(" position out of range.");
+  }
+
+#endif
+
+#if ENABLED(MESH_BED_LEVELING) || ENABLED(PROBE_MANUALLY)
+
+  #if ENABLED(PROBE_MANUALLY) && ENABLED(LCD_BED_LEVELING)
+    extern bool lcd_wait_for_move;
+  #endif
+
+  inline void _manual_goto_xy(const float &x, const float &y) {
+    const float old_feedrate_mm_s = feedrate_mm_s;
+    #if MANUAL_PROBE_HEIGHT > 0
+      const float prev_z = current_position[Z_AXIS];
+      feedrate_mm_s = homing_feedrate(Z_AXIS);
+      current_position[Z_AXIS] = LOGICAL_Z_POSITION(MANUAL_PROBE_HEIGHT);
+      line_to_current_position();
+    #endif
+
+    feedrate_mm_s = MMM_TO_MMS(XY_PROBE_SPEED);
+    current_position[X_AXIS] = LOGICAL_X_POSITION(x);
+    current_position[Y_AXIS] = LOGICAL_Y_POSITION(y);
+    line_to_current_position();
+
+    #if MANUAL_PROBE_HEIGHT > 0
+      feedrate_mm_s = homing_feedrate(Z_AXIS);
+      current_position[Z_AXIS] = prev_z; // move back to the previous Z.
+      line_to_current_position();
+    #endif
+
+    feedrate_mm_s = old_feedrate_mm_s;
+    stepper.synchronize();
+
+    #if ENABLED(PROBE_MANUALLY) && ENABLED(LCD_BED_LEVELING)
+      lcd_wait_for_move = false;
+    #endif
+  }
+
+#endif
+
+#if ENABLED(MESH_BED_LEVELING)
+
+  // Save 130 bytes with non-duplication of PSTR
+  void echo_not_entered() { SERIAL_PROTOCOLLNPGM(" not entered."); }
+
+  void mbl_mesh_report() {
+    SERIAL_PROTOCOLLNPGM("Num X,Y: " STRINGIFY(GRID_MAX_POINTS_X) "," STRINGIFY(GRID_MAX_POINTS_Y));
+    SERIAL_PROTOCOLPGM("Z offset: "); SERIAL_PROTOCOL_F(mbl.z_offset, 5);
+    SERIAL_PROTOCOLLNPGM("\nMeasured points:");
+    print_2d_array(GRID_MAX_POINTS_X, GRID_MAX_POINTS_Y, 5,
+      [](const uint8_t ix, const uint8_t iy) { return mbl.z_values[ix][iy]; }
+    );
+  }
+
+  void mesh_probing_done() {
+    mbl.set_has_mesh(true);
+    home_all_axes();
+    set_bed_leveling_enabled(true);
+    #if ENABLED(MESH_G28_REST_ORIGIN)
+      current_position[Z_AXIS] = LOGICAL_Z_POSITION(Z_MIN_POS);
+      set_destination_to_current();
+      line_to_destination(homing_feedrate(Z_AXIS));
+      stepper.synchronize();
+    #endif
+  }
+
+  /**
+   * G29: Mesh-based Z probe, probes a grid and produces a
+   *      mesh to compensate for variable bed height
+   *
+   * Parameters With MESH_BED_LEVELING:
+   *
+   *  S0              Produce a mesh report
+   *  S1              Start probing mesh points
+   *  S2              Probe the next mesh point
+   *  S3 Xn Yn Zn.nn  Manually modify a single point
+   *  S4 Zn.nn        Set z offset. Positive away from bed, negative closer to bed.
+   *  S5              Reset and disable mesh
+   *
+   * The S0 report the points as below
+   *
+   *  +----> X-axis  1-n
+   *  |
+   *  |
+   *  v Y-axis  1-n
+   *
+   */
+  inline void gcode_G29() {
+
+    static int mbl_probe_index = -1;
+    #if HAS_SOFTWARE_ENDSTOPS
+      static bool enable_soft_endstops;
+    #endif
+
+    const MeshLevelingState state = (MeshLevelingState)parser.byteval('S', (int8_t)MeshReport);
+    if (!WITHIN(state, 0, 5)) {
+      SERIAL_PROTOCOLLNPGM("S out of range (0-5).");
+      return;
+    }
+
+    int8_t px, py;
+
+    switch (state) {
+      case MeshReport:
+        if (leveling_is_valid()) {
+          SERIAL_PROTOCOLLNPAIR("State: ", leveling_is_active() ? MSG_ON : MSG_OFF);
+          mbl_mesh_report();
+        }
+        else
+          SERIAL_PROTOCOLLNPGM("Mesh bed leveling has no data.");
+        break;
+
+      case MeshStart:
+        mbl.reset();
+        mbl_probe_index = 0;
+        enqueue_and_echo_commands_P(PSTR("G28\nG29 S2"));
+        break;
+
+      case MeshNext:
+        if (mbl_probe_index < 0) {
+          SERIAL_PROTOCOLLNPGM("Start mesh probing with \"G29 S1\" first.");
+          return;
+        }
+        // For each G29 S2...
+        if (mbl_probe_index == 0) {
+          #if HAS_SOFTWARE_ENDSTOPS
+            // For the initial G29 S2 save software endstop state
+            enable_soft_endstops = soft_endstops_enabled;
+          #endif
+        }
+        else {
+          // For G29 S2 after adjusting Z.
+          mbl.set_zigzag_z(mbl_probe_index - 1, current_position[Z_AXIS]);
+          #if HAS_SOFTWARE_ENDSTOPS
+            soft_endstops_enabled = enable_soft_endstops;
+          #endif
+        }
+        // If there's another point to sample, move there with optional lift.
+        if (mbl_probe_index < GRID_MAX_POINTS) {
+          mbl.zigzag(mbl_probe_index, px, py);
+          _manual_goto_xy(mbl.index_to_xpos[px], mbl.index_to_ypos[py]);
+
+          #if HAS_SOFTWARE_ENDSTOPS
+            // Disable software endstops to allow manual adjustment
+            // If G29 is not completed, they will not be re-enabled
+            soft_endstops_enabled = false;
+          #endif
+
+          mbl_probe_index++;
+        }
+        else {
+          // One last "return to the bed" (as originally coded) at completion
+          current_position[Z_AXIS] = LOGICAL_Z_POSITION(Z_MIN_POS) + MANUAL_PROBE_HEIGHT;
+          line_to_current_position();
+          stepper.synchronize();
+
+          // After recording the last point, activate home and activate
+          mbl_probe_index = -1;
+          SERIAL_PROTOCOLLNPGM("Mesh probing done.");
+          BUZZ(100, 659);
+          BUZZ(100, 698);
+          mesh_probing_done();
+        }
+        break;
+
+      case MeshSet:
+        if (parser.seenval('X')) {
+          px = parser.value_int() - 1;
+          if (!WITHIN(px, 0, GRID_MAX_POINTS_X - 1)) {
+            SERIAL_PROTOCOLLNPGM("X out of range (1-" STRINGIFY(GRID_MAX_POINTS_X) ").");
+            return;
+          }
+        }
+        else {
+          SERIAL_CHAR('X'); echo_not_entered();
+          return;
+        }
+
+        if (parser.seenval('Y')) {
+          py = parser.value_int() - 1;
+          if (!WITHIN(py, 0, GRID_MAX_POINTS_Y - 1)) {
+            SERIAL_PROTOCOLLNPGM("Y out of range (1-" STRINGIFY(GRID_MAX_POINTS_Y) ").");
+            return;
+          }
+        }
+        else {
+          SERIAL_CHAR('Y'); echo_not_entered();
+          return;
+        }
+
+        if (parser.seenval('Z')) {
+          mbl.z_values[px][py] = parser.value_linear_units();
+        }
+        else {
+          SERIAL_CHAR('Z'); echo_not_entered();
+          return;
+        }
+        break;
+
+      case MeshSetZOffset:
+        if (parser.seenval('Z')) {
+          mbl.z_offset = parser.value_linear_units();
+        }
+        else {
+          SERIAL_CHAR('Z'); echo_not_entered();
+          return;
+        }
+        break;
+
+      case MeshReset:
+        reset_bed_level();
+        break;
+
+    } // switch(state)
+
+    report_current_position();
+  }
+
+#elif HAS_ABL && DISABLED(AUTO_BED_LEVELING_UBL)
+
+  #if ABL_GRID
+    #if ENABLED(PROBE_Y_FIRST)
+      #define PR_OUTER_VAR xCount
+      #define PR_OUTER_END abl_grid_points_x
+      #define PR_INNER_VAR yCount
+      #define PR_INNER_END abl_grid_points_y
+    #else
+      #define PR_OUTER_VAR yCount
+      #define PR_OUTER_END abl_grid_points_y
+      #define PR_INNER_VAR xCount
+      #define PR_INNER_END abl_grid_points_x
+    #endif
+  #endif
+
+  /**
+   * G29: Detailed Z probe, probes the bed at 3 or more points.
+   *      Will fail if the printer has not been homed with G28.
+   *
+   * Enhanced G29 Auto Bed Leveling Probe Routine
+   *
+   *  D  Dry-Run mode. Just evaluate the bed Topology - Don't apply
+   *     or alter the bed level data. Useful to check the topology
+   *     after a first run of G29.
+   *
+   *  J  Jettison current bed leveling data
+   *
+   *  V  Set the verbose level (0-4). Example: "G29 V3"
+   *
+   * Parameters With LINEAR leveling only:
+   *
+   *  P  Set the size of the grid that will be probed (P x P points).
+   *     Example: "G29 P4"
+   *
+   *  X  Set the X size of the grid that will be probed (X x Y points).
+   *     Example: "G29 X7 Y5"
+   *
+   *  Y  Set the Y size of the grid that will be probed (X x Y points).
+   *
+   *  T  Generate a Bed Topology Report. Example: "G29 P5 T" for a detailed report.
+   *     This is useful for manual bed leveling and finding flaws in the bed (to
+   *     assist with part placement).
+   *     Not supported by non-linear delta printer bed leveling.
+   *
+   * Parameters With LINEAR and BILINEAR leveling only:
+   *
+   *  S  Set the XY travel speed between probe points (in units/min)
+   *
+   *  F  Set the Front limit of the probing grid
+   *  B  Set the Back limit of the probing grid
+   *  L  Set the Left limit of the probing grid
+   *  R  Set the Right limit of the probing grid
+   *
+   * Parameters with DEBUG_LEVELING_FEATURE only:
+   *
+   *  C  Make a totally fake grid with no actual probing.
+   *     For use in testing when no probing is possible.
+   *
+   * Parameters with BILINEAR leveling only:
+   *
+   *  Z  Supply an additional Z probe offset
+   *
+   * Extra parameters with PROBE_MANUALLY:
+   *
+   *  To do manual probing simply repeat G29 until the procedure is complete.
+   *  The first G29 accepts parameters. 'G29 Q' for status, 'G29 A' to abort.
+   *
+   *  Q  Query leveling and G29 state
+   *
+   *  A  Abort current leveling procedure
+   *
+   * Extra parameters with BILINEAR only:
+   *
+   *  W  Write a mesh point. (If G29 is idle.)
+   *  I  X index for mesh point
+   *  J  Y index for mesh point
+   *  X  X for mesh point, overrides I
+   *  Y  Y for mesh point, overrides J
+   *  Z  Z for mesh point. Otherwise, raw current Z.
+   *
+   * Without PROBE_MANUALLY:
+   *
+   *  E  By default G29 will engage the Z probe, test the bed, then disengage.
+   *     Include "E" to engage/disengage the Z probe for each sample.
+   *     There's no extra effect if you have a fixed Z probe.
+   *
+   */
+  inline void gcode_G29() {
+
+    // G29 Q is also available if debugging
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      const bool query = parser.seen('Q');
+      const uint8_t old_debug_flags = marlin_debug_flags;
+      if (query) marlin_debug_flags |= DEBUG_LEVELING;
+      if (DEBUGGING(LEVELING)) {
+        DEBUG_POS(">>> gcode_G29", current_position);
+        log_machine_info();
+      }
+      marlin_debug_flags = old_debug_flags;
+      #if DISABLED(PROBE_MANUALLY)
+        if (query) return;
+      #endif
+    #endif
+
+    #if ENABLED(PROBE_MANUALLY)
+      const bool seenA = parser.seen('A'), seenQ = parser.seen('Q'), no_action = seenA || seenQ;
+    #endif
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE) && DISABLED(PROBE_MANUALLY)
+      const bool faux = parser.boolval('C');
+    #elif ENABLED(PROBE_MANUALLY)
+      const bool faux = no_action;
+    #else
+      bool constexpr faux = false;
+    #endif
+
+    // Don't allow auto-leveling without homing first
+    if (axis_unhomed_error()) return;
+
+    // Define local vars 'static' for manual probing, 'auto' otherwise
+    #if ENABLED(PROBE_MANUALLY)
+      #define ABL_VAR static
+    #else
+      #define ABL_VAR
+    #endif
+
+    ABL_VAR int verbose_level;
+    ABL_VAR float xProbe, yProbe, measured_z;
+    ABL_VAR bool dryrun, abl_should_enable;
+
+    #if ENABLED(PROBE_MANUALLY) || ENABLED(AUTO_BED_LEVELING_LINEAR)
+      ABL_VAR int abl_probe_index;
+    #endif
+
+    #if HAS_SOFTWARE_ENDSTOPS && ENABLED(PROBE_MANUALLY)
+      ABL_VAR bool enable_soft_endstops = true;
+    #endif
+
+    #if ABL_GRID
+
+      #if ENABLED(PROBE_MANUALLY)
+        ABL_VAR uint8_t PR_OUTER_VAR;
+        ABL_VAR  int8_t PR_INNER_VAR;
+      #endif
+
+      ABL_VAR int left_probe_bed_position, right_probe_bed_position, front_probe_bed_position, back_probe_bed_position;
+      ABL_VAR float xGridSpacing = 0, yGridSpacing = 0;
+
+      #if ENABLED(AUTO_BED_LEVELING_LINEAR)
+        ABL_VAR uint8_t abl_grid_points_x = GRID_MAX_POINTS_X,
+                        abl_grid_points_y = GRID_MAX_POINTS_Y;
+        ABL_VAR bool do_topography_map;
+      #else // Bilinear
+        uint8_t constexpr abl_grid_points_x = GRID_MAX_POINTS_X,
+                          abl_grid_points_y = GRID_MAX_POINTS_Y;
+      #endif
+
+      #if ENABLED(AUTO_BED_LEVELING_LINEAR) || ENABLED(PROBE_MANUALLY)
+        #if ENABLED(AUTO_BED_LEVELING_LINEAR)
+          ABL_VAR int abl2;
+        #else // Bilinear
+          int constexpr abl2 = GRID_MAX_POINTS;
+        #endif
+      #endif
+
+      #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
+
+        ABL_VAR float zoffset;
+
+      #elif ENABLED(AUTO_BED_LEVELING_LINEAR)
+
+        ABL_VAR int indexIntoAB[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
+
+        ABL_VAR float eqnAMatrix[GRID_MAX_POINTS * 3], // "A" matrix of the linear system of equations
+                      eqnBVector[GRID_MAX_POINTS],     // "B" vector of Z points
+                      mean;
+      #endif
+
+    #elif ENABLED(AUTO_BED_LEVELING_3POINT)
+
+      int constexpr abl2 = 3;
+
+      // Probe at 3 arbitrary points
+      ABL_VAR vector_3 points[3] = {
+        vector_3(ABL_PROBE_PT_1_X, ABL_PROBE_PT_1_Y, 0),
+        vector_3(ABL_PROBE_PT_2_X, ABL_PROBE_PT_2_Y, 0),
+        vector_3(ABL_PROBE_PT_3_X, ABL_PROBE_PT_3_Y, 0)
+      };
+
+    #endif // AUTO_BED_LEVELING_3POINT
+
+    #if ENABLED(AUTO_BED_LEVELING_LINEAR)
+      struct linear_fit_data lsf_results;
+      incremental_LSF_reset(&lsf_results);
+    #endif
+
+    /**
+     * On the initial G29 fetch command parameters.
+     */
+    if (!g29_in_progress) {
+
+      #if ENABLED(PROBE_MANUALLY) || ENABLED(AUTO_BED_LEVELING_LINEAR)
+        abl_probe_index = -1;
+      #endif
+
+      abl_should_enable = leveling_is_active();
+
+      #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
+
+        if (parser.seen('W')) {
+          if (!leveling_is_valid()) {
+            SERIAL_ERROR_START();
+            SERIAL_ERRORLNPGM("No bilinear grid");
+            return;
+          }
+
+          const float z = parser.floatval('Z', RAW_CURRENT_POSITION(Z));
+          if (!WITHIN(z, -10, 10)) {
+            SERIAL_ERROR_START();
+            SERIAL_ERRORLNPGM("Bad Z value");
+            return;
+          }
+
+          const float x = parser.floatval('X', NAN),
+                      y = parser.floatval('Y', NAN);
+          int8_t i = parser.byteval('I', -1),
+                 j = parser.byteval('J', -1);
+
+          if (!isnan(x) && !isnan(y)) {
+            // Get nearest i / j from x / y
+            i = (x - LOGICAL_X_POSITION(bilinear_start[X_AXIS]) + 0.5 * xGridSpacing) / xGridSpacing;
+            j = (y - LOGICAL_Y_POSITION(bilinear_start[Y_AXIS]) + 0.5 * yGridSpacing) / yGridSpacing;
+            i = constrain(i, 0, GRID_MAX_POINTS_X - 1);
+            j = constrain(j, 0, GRID_MAX_POINTS_Y - 1);
+          }
+          if (WITHIN(i, 0, GRID_MAX_POINTS_X - 1) && WITHIN(j, 0, GRID_MAX_POINTS_Y)) {
+            set_bed_leveling_enabled(false);
+            z_values[i][j] = z;
+            #if ENABLED(ABL_BILINEAR_SUBDIVISION)
+              bed_level_virt_interpolate();
+            #endif
+            set_bed_leveling_enabled(abl_should_enable);
+          }
+          return;
+        } // parser.seen('W')
+
+      #endif
+
+      #if HAS_LEVELING
+
+        // Jettison bed leveling data
+        if (parser.seen('J')) {
+          reset_bed_level();
+          return;
+        }
+
+      #endif
+
+      verbose_level = parser.intval('V');
+      if (!WITHIN(verbose_level, 0, 4)) {
+        SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-4).");
+        return;
+      }
+
+      dryrun = parser.boolval('D')
+        #if ENABLED(PROBE_MANUALLY)
+          || no_action
+        #endif
+      ;
+
+      #if ENABLED(AUTO_BED_LEVELING_LINEAR)
+
+        do_topography_map = verbose_level > 2 || parser.boolval('T');
+
+        // X and Y specify points in each direction, overriding the default
+        // These values may be saved with the completed mesh
+        abl_grid_points_x = parser.intval('X', GRID_MAX_POINTS_X);
+        abl_grid_points_y = parser.intval('Y', GRID_MAX_POINTS_Y);
+        if (parser.seenval('P')) abl_grid_points_x = abl_grid_points_y = parser.value_int();
+
+        if (abl_grid_points_x < 2 || abl_grid_points_y < 2) {
+          SERIAL_PROTOCOLLNPGM("?Number of probe points is implausible (2 minimum).");
+          return;
+        }
+
+        abl2 = abl_grid_points_x * abl_grid_points_y;
+
+      #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
+
+        zoffset = parser.linearval('Z');
+
+      #endif
+
+      #if ABL_GRID
+
+        xy_probe_feedrate_mm_s = MMM_TO_MMS(parser.linearval('S', XY_PROBE_SPEED));
+
+        left_probe_bed_position = (int)parser.linearval('L', LOGICAL_X_POSITION(LEFT_PROBE_BED_POSITION));
+        right_probe_bed_position = (int)parser.linearval('R', LOGICAL_X_POSITION(RIGHT_PROBE_BED_POSITION));
+        front_probe_bed_position = (int)parser.linearval('F', LOGICAL_Y_POSITION(FRONT_PROBE_BED_POSITION));
+        back_probe_bed_position = (int)parser.linearval('B', LOGICAL_Y_POSITION(BACK_PROBE_BED_POSITION));
+
+        const bool left_out_l = left_probe_bed_position < LOGICAL_X_POSITION(MIN_PROBE_X),
+                   left_out = left_out_l || left_probe_bed_position > right_probe_bed_position - (MIN_PROBE_EDGE),
+                   right_out_r = right_probe_bed_position > LOGICAL_X_POSITION(MAX_PROBE_X),
+                   right_out = right_out_r || right_probe_bed_position < left_probe_bed_position + MIN_PROBE_EDGE,
+                   front_out_f = front_probe_bed_position < LOGICAL_Y_POSITION(MIN_PROBE_Y),
+                   front_out = front_out_f || front_probe_bed_position > back_probe_bed_position - (MIN_PROBE_EDGE),
+                   back_out_b = back_probe_bed_position > LOGICAL_Y_POSITION(MAX_PROBE_Y),
+                   back_out = back_out_b || back_probe_bed_position < front_probe_bed_position + MIN_PROBE_EDGE;
+
+        if (left_out || right_out || front_out || back_out) {
+          if (left_out) {
+            out_of_range_error(PSTR("(L)eft"));
+            left_probe_bed_position = left_out_l ? LOGICAL_X_POSITION(MIN_PROBE_X) : right_probe_bed_position - (MIN_PROBE_EDGE);
+          }
+          if (right_out) {
+            out_of_range_error(PSTR("(R)ight"));
+            right_probe_bed_position = right_out_r ? LOGICAL_Y_POSITION(MAX_PROBE_X) : left_probe_bed_position + MIN_PROBE_EDGE;
+          }
+          if (front_out) {
+            out_of_range_error(PSTR("(F)ront"));
+            front_probe_bed_position = front_out_f ? LOGICAL_Y_POSITION(MIN_PROBE_Y) : back_probe_bed_position - (MIN_PROBE_EDGE);
+          }
+          if (back_out) {
+            out_of_range_error(PSTR("(B)ack"));
+            back_probe_bed_position = back_out_b ? LOGICAL_Y_POSITION(MAX_PROBE_Y) : front_probe_bed_position + MIN_PROBE_EDGE;
+          }
+          return;
+        }
+
+        // probe at the points of a lattice grid
+        xGridSpacing = (right_probe_bed_position - left_probe_bed_position) / (abl_grid_points_x - 1);
+        yGridSpacing = (back_probe_bed_position - front_probe_bed_position) / (abl_grid_points_y - 1);
+
+      #endif // ABL_GRID
+
+      if (verbose_level > 0) {
+        SERIAL_PROTOCOLLNPGM("G29 Auto Bed Leveling");
+        if (dryrun) SERIAL_PROTOCOLLNPGM("Running in DRY-RUN mode");
+      }
+
+      stepper.synchronize();
+
+      // Disable auto bed leveling during G29
+      planner.abl_enabled = false;
+
+      if (!dryrun) {
+        // Re-orient the current position without leveling
+        // based on where the steppers are positioned.
+        set_current_from_steppers_for_axis(ALL_AXES);
+
+        // Sync the planner to where the steppers stopped
+        SYNC_PLAN_POSITION_KINEMATIC();
+      }
+
+      #if HAS_BED_PROBE
+        // Deploy the probe. Probe will raise if needed.
+        if (DEPLOY_PROBE()) {
+          planner.abl_enabled = abl_should_enable;
+          return;
+        }
+      #endif
+
+      if (!faux) setup_for_endstop_or_probe_move();
+
+      #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
+
+        #if ENABLED(PROBE_MANUALLY)
+          if (!no_action)
+        #endif
+        if ( xGridSpacing != bilinear_grid_spacing[X_AXIS]
+          || yGridSpacing != bilinear_grid_spacing[Y_AXIS]
+          || left_probe_bed_position != LOGICAL_X_POSITION(bilinear_start[X_AXIS])
+          || front_probe_bed_position != LOGICAL_Y_POSITION(bilinear_start[Y_AXIS])
+        ) {
+          if (dryrun) {
+            // Before reset bed level, re-enable to correct the position
+            planner.abl_enabled = abl_should_enable;
+          }
+          // Reset grid to 0.0 or "not probed". (Also disables ABL)
+          reset_bed_level();
+
+          // Initialize a grid with the given dimensions
+          bilinear_grid_spacing[X_AXIS] = xGridSpacing;
+          bilinear_grid_spacing[Y_AXIS] = yGridSpacing;
+          bilinear_start[X_AXIS] = RAW_X_POSITION(left_probe_bed_position);
+          bilinear_start[Y_AXIS] = RAW_Y_POSITION(front_probe_bed_position);
+
+          // Can't re-enable (on error) until the new grid is written
+          abl_should_enable = false;
+        }
+
+      #endif // AUTO_BED_LEVELING_BILINEAR
+
+      #if ENABLED(AUTO_BED_LEVELING_3POINT)
+
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("> 3-point Leveling");
+        #endif
+
+        // Probe at 3 arbitrary points
+        points[0].z = points[1].z = points[2].z = 0;
+
+      #endif // AUTO_BED_LEVELING_3POINT
+
+    } // !g29_in_progress
+
+    #if ENABLED(PROBE_MANUALLY)
+
+      // For manual probing, get the next index to probe now.
+      // On the first probe this will be incremented to 0.
+      if (!no_action) {
+        ++abl_probe_index;
+        g29_in_progress = true;
+      }
+
+      // Abort current G29 procedure, go back to idle state
+      if (seenA && g29_in_progress) {
+        SERIAL_PROTOCOLLNPGM("Manual G29 aborted");
+        #if HAS_SOFTWARE_ENDSTOPS
+          soft_endstops_enabled = enable_soft_endstops;
+        #endif
+        planner.abl_enabled = abl_should_enable;
+        g29_in_progress = false;
+        #if ENABLED(LCD_BED_LEVELING)
+          lcd_wait_for_move = false;
+        #endif
+      }
+
+      // Query G29 status
+      if (verbose_level || seenQ) {
+        SERIAL_PROTOCOLPGM("Manual G29 ");
+        if (g29_in_progress) {
+          SERIAL_PROTOCOLPAIR("point ", min(abl_probe_index + 1, abl2));
+          SERIAL_PROTOCOLLNPAIR(" of ", abl2);
+        }
+        else
+          SERIAL_PROTOCOLLNPGM("idle");
+      }
+
+      if (no_action) return;
+
+      if (abl_probe_index == 0) {
+        // For the initial G29 save software endstop state
+        #if HAS_SOFTWARE_ENDSTOPS
+          enable_soft_endstops = soft_endstops_enabled;
+        #endif
+      }
+      else {
+        // For G29 after adjusting Z.
+        // Save the previous Z before going to the next point
+        measured_z = current_position[Z_AXIS];
+
+        #if ENABLED(AUTO_BED_LEVELING_LINEAR)
+
+          mean += measured_z;
+          eqnBVector[abl_probe_index] = measured_z;
+          eqnAMatrix[abl_probe_index + 0 * abl2] = xProbe;
+          eqnAMatrix[abl_probe_index + 1 * abl2] = yProbe;
+          eqnAMatrix[abl_probe_index + 2 * abl2] = 1;
+
+          incremental_LSF(&lsf_results, xProbe, yProbe, measured_z);
+
+        #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
+
+          z_values[xCount][yCount] = measured_z + zoffset;
+
+          #if ENABLED(DEBUG_LEVELING_FEATURE)
+            if (DEBUGGING(LEVELING)) {
+              SERIAL_PROTOCOLPAIR("Save X", xCount);
+              SERIAL_PROTOCOLPAIR(" Y", yCount);
+              SERIAL_PROTOCOLLNPAIR(" Z", measured_z + zoffset);
+            }
+          #endif
+
+        #elif ENABLED(AUTO_BED_LEVELING_3POINT)
+
+          points[abl_probe_index].z = measured_z;
+
+        #endif
+      }
+
+      //
+      // If there's another point to sample, move there with optional lift.
+      //
+
+      #if ABL_GRID
+
+        // Skip any unreachable points
+        while (abl_probe_index < abl2) {
+
+          // Set xCount, yCount based on abl_probe_index, with zig-zag
+          PR_OUTER_VAR = abl_probe_index / PR_INNER_END;
+          PR_INNER_VAR = abl_probe_index - (PR_OUTER_VAR * PR_INNER_END);
+
+          // Probe in reverse order for every other row/column
+          bool zig = (PR_OUTER_VAR & 1); // != ((PR_OUTER_END) & 1);
+
+          if (zig) PR_INNER_VAR = (PR_INNER_END - 1) - PR_INNER_VAR;
+
+          const float xBase = xCount * xGridSpacing + left_probe_bed_position,
+                      yBase = yCount * yGridSpacing + front_probe_bed_position;
+
+          xProbe = FLOOR(xBase + (xBase < 0 ? 0 : 0.5));
+          yProbe = FLOOR(yBase + (yBase < 0 ? 0 : 0.5));
+
+          #if ENABLED(AUTO_BED_LEVELING_LINEAR)
+            indexIntoAB[xCount][yCount] = abl_probe_index;
+          #endif
+
+          // Keep looping till a reachable point is found
+          if (position_is_reachable_xy(xProbe, yProbe)) break;
+          ++abl_probe_index;
+        }
+
+        // Is there a next point to move to?
+        if (abl_probe_index < abl2) {
+          _manual_goto_xy(xProbe, yProbe); // Can be used here too!
+          #if HAS_SOFTWARE_ENDSTOPS
+            // Disable software endstops to allow manual adjustment
+            // If G29 is not completed, they will not be re-enabled
+            soft_endstops_enabled = false;
+          #endif
+          return;
+        }
+        else {
+
+          // Leveling done! Fall through to G29 finishing code below
+
+          SERIAL_PROTOCOLLNPGM("Grid probing done.");
+
+          // Re-enable software endstops, if needed
+          #if HAS_SOFTWARE_ENDSTOPS
+            soft_endstops_enabled = enable_soft_endstops;
+          #endif
+        }
+
+      #elif ENABLED(AUTO_BED_LEVELING_3POINT)
+
+        // Probe at 3 arbitrary points
+        if (abl_probe_index < 3) {
+          xProbe = LOGICAL_X_POSITION(points[abl_probe_index].x);
+          yProbe = LOGICAL_Y_POSITION(points[abl_probe_index].y);
+          #if HAS_SOFTWARE_ENDSTOPS
+            // Disable software endstops to allow manual adjustment
+            // If G29 is not completed, they will not be re-enabled
+            soft_endstops_enabled = false;
+          #endif
+          return;
+        }
+        else {
+
+          SERIAL_PROTOCOLLNPGM("3-point probing done.");
+
+          // Re-enable software endstops, if needed
+          #if HAS_SOFTWARE_ENDSTOPS
+            soft_endstops_enabled = enable_soft_endstops;
+          #endif
+
+          if (!dryrun) {
+            vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
+            if (planeNormal.z < 0) {
+              planeNormal.x *= -1;
+              planeNormal.y *= -1;
+              planeNormal.z *= -1;
+            }
+            planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
+
+            // Can't re-enable (on error) until the new grid is written
+            abl_should_enable = false;
+          }
+
+        }
+
+      #endif // AUTO_BED_LEVELING_3POINT
+
+    #else // !PROBE_MANUALLY
+    {
+      const bool stow_probe_after_each = parser.boolval('E');
+
+      #if ABL_GRID
+
+        bool zig = PR_OUTER_END & 1;  // Always end at RIGHT and BACK_PROBE_BED_POSITION
+
+        // Outer loop is Y with PROBE_Y_FIRST disabled
+        for (uint8_t PR_OUTER_VAR = 0; PR_OUTER_VAR < PR_OUTER_END && !isnan(measured_z); PR_OUTER_VAR++) {
+
+          int8_t inStart, inStop, inInc;
+
+          if (zig) { // away from origin
+            inStart = 0;
+            inStop = PR_INNER_END;
+            inInc = 1;
+          }
+          else {     // towards origin
+            inStart = PR_INNER_END - 1;
+            inStop = -1;
+            inInc = -1;
+          }
+
+          zig ^= true; // zag
+
+          // Inner loop is Y with PROBE_Y_FIRST enabled
+          for (int8_t PR_INNER_VAR = inStart; PR_INNER_VAR != inStop; PR_INNER_VAR += inInc) {
+
+            float xBase = left_probe_bed_position + xGridSpacing * xCount,
+                  yBase = front_probe_bed_position + yGridSpacing * yCount;
+
+            xProbe = FLOOR(xBase + (xBase < 0 ? 0 : 0.5));
+            yProbe = FLOOR(yBase + (yBase < 0 ? 0 : 0.5));
+
+            #if ENABLED(AUTO_BED_LEVELING_LINEAR)
+              indexIntoAB[xCount][yCount] = ++abl_probe_index; // 0...
+            #endif
+
+            #if IS_KINEMATIC
+              // Avoid probing outside the round or hexagonal area
+              if (!position_is_reachable_by_probe_xy(xProbe, yProbe)) continue;
+            #endif
+
+            measured_z = faux ? 0.001 * random(-100, 101) : probe_pt(xProbe, yProbe, stow_probe_after_each, verbose_level);
+
+            if (isnan(measured_z)) {
+              planner.abl_enabled = abl_should_enable;
+              break;
+            }
+
+            #if ENABLED(AUTO_BED_LEVELING_LINEAR)
+
+              mean += measured_z;
+              eqnBVector[abl_probe_index] = measured_z;
+              eqnAMatrix[abl_probe_index + 0 * abl2] = xProbe;
+              eqnAMatrix[abl_probe_index + 1 * abl2] = yProbe;
+              eqnAMatrix[abl_probe_index + 2 * abl2] = 1;
+
+              incremental_LSF(&lsf_results, xProbe, yProbe, measured_z);
+
+            #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
+
+              z_values[xCount][yCount] = measured_z + zoffset;
+
+            #endif
+
+            abl_should_enable = false;
+            idle();
+
+          } // inner
+        } // outer
+
+      #elif ENABLED(AUTO_BED_LEVELING_3POINT)
+
+        // Probe at 3 arbitrary points
+
+        for (uint8_t i = 0; i < 3; ++i) {
+          // Retain the last probe position
+          xProbe = LOGICAL_X_POSITION(points[i].x);
+          yProbe = LOGICAL_Y_POSITION(points[i].y);
+          measured_z = faux ? 0.001 * random(-100, 101) : probe_pt(xProbe, yProbe, stow_probe_after_each, verbose_level);
+          if (isnan(measured_z)) {
+            planner.abl_enabled = abl_should_enable;
+            break;
+          }
+          points[i].z = measured_z;
+        }
+
+        if (!dryrun && !isnan(measured_z)) {
+          vector_3 planeNormal = vector_3::cross(points[0] - points[1], points[2] - points[1]).get_normal();
+          if (planeNormal.z < 0) {
+            planeNormal.x *= -1;
+            planeNormal.y *= -1;
+            planeNormal.z *= -1;
+          }
+          planner.bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
+
+          // Can't re-enable (on error) until the new grid is written
+          abl_should_enable = false;
+        }
+
+      #endif // AUTO_BED_LEVELING_3POINT
+
+      // Raise to _Z_CLEARANCE_DEPLOY_PROBE. Stow the probe.
+      if (STOW_PROBE()) {
+        planner.abl_enabled = abl_should_enable;
+        measured_z = NAN;
+      }
+    }
+    #endif // !PROBE_MANUALLY
+
+    //
+    // G29 Finishing Code
+    //
+    // Unless this is a dry run, auto bed leveling will
+    // definitely be enabled after this point.
+    //
+    // If code above wants to continue leveling, it should
+    // return or loop before this point.
+    //
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) DEBUG_POS("> probing complete", current_position);
+    #endif
+
+    #if ENABLED(PROBE_MANUALLY)
+      g29_in_progress = false;
+      #if ENABLED(LCD_BED_LEVELING)
+        lcd_wait_for_move = false;
+      #endif
+    #endif
+
+    // Calculate leveling, print reports, correct the position
+    if (!isnan(measured_z)) {
+      #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
+
+        if (!dryrun) extrapolate_unprobed_bed_level();
+        print_bilinear_leveling_grid();
+
+        refresh_bed_level();
+
+        #if ENABLED(ABL_BILINEAR_SUBDIVISION)
+          print_bilinear_leveling_grid_virt();
+        #endif
+
+      #elif ENABLED(AUTO_BED_LEVELING_LINEAR)
+
+        // For LINEAR leveling calculate matrix, print reports, correct the position
+
+        /**
+         * solve the plane equation ax + by + d = z
+         * A is the matrix with rows [x y 1] for all the probed points
+         * B is the vector of the Z positions
+         * the normal vector to the plane is formed by the coefficients of the
+         * plane equation in the standard form, which is Vx*x+Vy*y+Vz*z+d = 0
+         * so Vx = -a Vy = -b Vz = 1 (we want the vector facing towards positive Z
+         */
+        float plane_equation_coefficients[3];
+
+        finish_incremental_LSF(&lsf_results);
+        plane_equation_coefficients[0] = -lsf_results.A;  // We should be able to eliminate the '-' on these three lines and down below
+        plane_equation_coefficients[1] = -lsf_results.B;  // but that is not yet tested.
+        plane_equation_coefficients[2] = -lsf_results.D;
+
+        mean /= abl2;
+
+        if (verbose_level) {
+          SERIAL_PROTOCOLPGM("Eqn coefficients: a: ");
+          SERIAL_PROTOCOL_F(plane_equation_coefficients[0], 8);
+          SERIAL_PROTOCOLPGM(" b: ");
+          SERIAL_PROTOCOL_F(plane_equation_coefficients[1], 8);
+          SERIAL_PROTOCOLPGM(" d: ");
+          SERIAL_PROTOCOL_F(plane_equation_coefficients[2], 8);
+          SERIAL_EOL();
+          if (verbose_level > 2) {
+            SERIAL_PROTOCOLPGM("Mean of sampled points: ");
+            SERIAL_PROTOCOL_F(mean, 8);
+            SERIAL_EOL();
+          }
+        }
+
+        // Create the matrix but don't correct the position yet
+        if (!dryrun)
+          planner.bed_level_matrix = matrix_3x3::create_look_at(
+            vector_3(-plane_equation_coefficients[0], -plane_equation_coefficients[1], 1)    // We can eliminate the '-' here and up above
+          );
+
+        // Show the Topography map if enabled
+        if (do_topography_map) {
+
+          SERIAL_PROTOCOLLNPGM("\nBed Height Topography:\n"
+                                 "   +--- BACK --+\n"
+                                 "   |           |\n"
+                                 " L |    (+)    | R\n"
+                                 " E |           | I\n"
+                                 " F | (-) N (+) | G\n"
+                                 " T |           | H\n"
+                                 "   |    (-)    | T\n"
+                                 "   |           |\n"
+                                 "   O-- FRONT --+\n"
+                                 " (0,0)");
+
+          float min_diff = 999;
+
+          for (int8_t yy = abl_grid_points_y - 1; yy >= 0; yy--) {
+            for (uint8_t xx = 0; xx < abl_grid_points_x; xx++) {
+              int ind = indexIntoAB[xx][yy];
+              float diff = eqnBVector[ind] - mean,
+                    x_tmp = eqnAMatrix[ind + 0 * abl2],
+                    y_tmp = eqnAMatrix[ind + 1 * abl2],
+                    z_tmp = 0;
+
+              apply_rotation_xyz(planner.bed_level_matrix, x_tmp, y_tmp, z_tmp);
+
+              NOMORE(min_diff, eqnBVector[ind] - z_tmp);
+
+              if (diff >= 0.0)
+                SERIAL_PROTOCOLPGM(" +");   // Include + for column alignment
+              else
+                SERIAL_PROTOCOLCHAR(' ');
+              SERIAL_PROTOCOL_F(diff, 5);
+            } // xx
+            SERIAL_EOL();
+          } // yy
+          SERIAL_EOL();
+
+          if (verbose_level > 3) {
+            SERIAL_PROTOCOLLNPGM("\nCorrected Bed Height vs. Bed Topology:");
+
+            for (int8_t yy = abl_grid_points_y - 1; yy >= 0; yy--) {
+              for (uint8_t xx = 0; xx < abl_grid_points_x; xx++) {
+                int ind = indexIntoAB[xx][yy];
+                float x_tmp = eqnAMatrix[ind + 0 * abl2],
+                      y_tmp = eqnAMatrix[ind + 1 * abl2],
+                      z_tmp = 0;
+
+                apply_rotation_xyz(planner.bed_level_matrix, x_tmp, y_tmp, z_tmp);
+
+                float diff = eqnBVector[ind] - z_tmp - min_diff;
+                if (diff >= 0.0)
+                  SERIAL_PROTOCOLPGM(" +");
+                // Include + for column alignment
+                else
+                  SERIAL_PROTOCOLCHAR(' ');
+                SERIAL_PROTOCOL_F(diff, 5);
+              } // xx
+              SERIAL_EOL();
+            } // yy
+            SERIAL_EOL();
+          }
+        } //do_topography_map
+
+      #endif // AUTO_BED_LEVELING_LINEAR
+
+      #if ABL_PLANAR
+
+        // For LINEAR and 3POINT leveling correct the current position
+
+        if (verbose_level > 0)
+          planner.bed_level_matrix.debug(PSTR("\n\nBed Level Correction Matrix:"));
+
+        if (!dryrun) {
+          //
+          // Correct the current XYZ position based on the tilted plane.
+          //
+
+          #if ENABLED(DEBUG_LEVELING_FEATURE)
+            if (DEBUGGING(LEVELING)) DEBUG_POS("G29 uncorrected XYZ", current_position);
+          #endif
+
+          float converted[XYZ];
+          COPY(converted, current_position);
+
+          planner.abl_enabled = true;
+          planner.unapply_leveling(converted); // use conversion machinery
+          planner.abl_enabled = false;
+
+          // Use the last measured distance to the bed, if possible
+          if ( NEAR(current_position[X_AXIS], xProbe - (X_PROBE_OFFSET_FROM_EXTRUDER))
+            && NEAR(current_position[Y_AXIS], yProbe - (Y_PROBE_OFFSET_FROM_EXTRUDER))
+          ) {
+            const float simple_z = current_position[Z_AXIS] - measured_z;
+            #if ENABLED(DEBUG_LEVELING_FEATURE)
+              if (DEBUGGING(LEVELING)) {
+                SERIAL_ECHOPAIR("Z from Probe:", simple_z);
+                SERIAL_ECHOPAIR("  Matrix:", converted[Z_AXIS]);
+                SERIAL_ECHOLNPAIR("  Discrepancy:", simple_z - converted[Z_AXIS]);
+              }
+            #endif
+            converted[Z_AXIS] = simple_z;
+          }
+
+          // The rotated XY and corrected Z are now current_position
+          COPY(current_position, converted);
+
+          #if ENABLED(DEBUG_LEVELING_FEATURE)
+            if (DEBUGGING(LEVELING)) DEBUG_POS("G29 corrected XYZ", current_position);
+          #endif
+        }
+
+      #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
+
+        if (!dryrun) {
+          #if ENABLED(DEBUG_LEVELING_FEATURE)
+            if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("G29 uncorrected Z:", current_position[Z_AXIS]);
+          #endif
+
+          // Unapply the offset because it is going to be immediately applied
+          // and cause compensation movement in Z
+          current_position[Z_AXIS] -= bilinear_z_offset(current_position);
+
+          #if ENABLED(DEBUG_LEVELING_FEATURE)
+            if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR(" corrected Z:", current_position[Z_AXIS]);
+          #endif
+        }
+
+      #endif // ABL_PLANAR
+
+      #ifdef Z_PROBE_END_SCRIPT
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPAIR("Z Probe End Script: ", Z_PROBE_END_SCRIPT);
+        #endif
+        enqueue_and_echo_commands_P(PSTR(Z_PROBE_END_SCRIPT));
+        stepper.synchronize();
+      #endif
+
+      // Auto Bed Leveling is complete! Enable if possible.
+      planner.abl_enabled = dryrun ? abl_should_enable : true;
+    } // !isnan(measured_z)
+
+    // Restore state after probing
+    if (!faux) clean_up_after_endstop_or_probe_move();
+
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("<<< gcode_G29");
+    #endif
+
+    report_current_position();
+
+    KEEPALIVE_STATE(IN_HANDLER);
+
+    if (planner.abl_enabled)
+      SYNC_PLAN_POSITION_KINEMATIC();
+  }
+
+#endif // HAS_ABL && !AUTO_BED_LEVELING_UBL
+
+#if HAS_BED_PROBE
+
+  /**
+   * G30: Do a single Z probe at the current XY
+   *
+   * Parameters:
+   *
+   *   X   Probe X position (default current X)
+   *   Y   Probe Y position (default current Y)
+   *   S0  Leave the probe deployed
+   */
+  inline void gcode_G30() {
+    const float xpos = parser.linearval('X', current_position[X_AXIS] + X_PROBE_OFFSET_FROM_EXTRUDER),
+                ypos = parser.linearval('Y', current_position[Y_AXIS] + Y_PROBE_OFFSET_FROM_EXTRUDER);
+
+    if (!position_is_reachable_by_probe_xy(xpos, ypos)) return;
+
+    // Disable leveling so the planner won't mess with us
+    #if HAS_LEVELING
+      set_bed_leveling_enabled(false);
+    #endif
+
+    setup_for_endstop_or_probe_move();
+
+    const float measured_z = probe_pt(xpos, ypos, parser.boolval('S', true), 1);
+
+    if (!isnan(measured_z)) {
+      SERIAL_PROTOCOLPAIR("Bed X: ", FIXFLOAT(xpos));
+      SERIAL_PROTOCOLPAIR(" Y: ", FIXFLOAT(ypos));
+      SERIAL_PROTOCOLLNPAIR(" Z: ", FIXFLOAT(measured_z));
+    }
+
+    clean_up_after_endstop_or_probe_move();
+
+    report_current_position();
+  }
+
+  #if ENABLED(Z_PROBE_SLED)
+
+    /**
+     * G31: Deploy the Z probe
+     */
+    inline void gcode_G31() { DEPLOY_PROBE(); }
+
+    /**
+     * G32: Stow the Z probe
+     */
+    inline void gcode_G32() { STOW_PROBE(); }
+
+  #endif // Z_PROBE_SLED
+
+#endif // HAS_BED_PROBE
+
+#if PROBE_SELECTED
+
+  #if ENABLED(DELTA_AUTO_CALIBRATION)
+    /**
+     * G33 - Delta '1-4-7-point' Auto-Calibration
+     *       Calibrate height, endstops, delta radius, and tower angles.
+     *
+     * Parameters:
+     *
+     *   Pn  Number of probe points:
+     *
+     *      P1     Probe center and set height only.
+     *      P2     Probe center and towers. Set height, endstops, and delta radius.
+     *      P3     Probe all positions: center, towers and opposite towers. Set all.
+     *      P4-P7  Probe all positions at different locations and average them.
+     *
+     *   T0  Don't calibrate tower angle corrections
+     *
+     *   Cn.nn Calibration precision; when omitted calibrates to maximum precision
+     *
+     *   Fn  Force to run at least n iterations and takes the best result
+     *
+     *   Vn  Verbose level:
+     *
+     *      V0  Dry-run mode. Report settings and probe results. No calibration.
+     *      V1  Report settings
+     *      V2  Report settings and probe results
+     *
+     *   E   Engage the probe for each point
+     */
+
+    void print_signed_float(const char * const prefix, const float &f) {
+      SERIAL_PROTOCOLPGM("  ");
+      serialprintPGM(prefix);
+      SERIAL_PROTOCOLCHAR(':');
+      if (f >= 0) SERIAL_CHAR('+');
+      SERIAL_PROTOCOL_F(f, 2);
+    }
+
+    inline void print_G33_settings(const bool end_stops, const bool tower_angles){ // TODO echo these to LCD ???
+      SERIAL_PROTOCOLPAIR(".Height:", DELTA_HEIGHT + home_offset[Z_AXIS]);
+      if (end_stops) {
+        print_signed_float(PSTR("  Ex"), endstop_adj[A_AXIS]);
+        print_signed_float(PSTR("Ey"), endstop_adj[B_AXIS]);
+        print_signed_float(PSTR("Ez"), endstop_adj[C_AXIS]);
+        SERIAL_PROTOCOLPAIR("    Radius:", delta_radius);
+      }
+      SERIAL_EOL();
+      if (tower_angles) {
+        SERIAL_PROTOCOLPGM(".Tower angle :  ");
+        print_signed_float(PSTR("Tx"), delta_tower_angle_trim[A_AXIS]);
+        print_signed_float(PSTR("Ty"), delta_tower_angle_trim[B_AXIS]);
+        SERIAL_PROTOCOLLNPGM("  Tz:+0.00");
+      }
+    }
+
+    void G33_cleanup(
+      #if HOTENDS > 1
+        const uint8_t old_tool_index
+      #endif
+    ) {
+      #if ENABLED(DELTA_HOME_TO_SAFE_ZONE)
+        do_blocking_move_to_z(delta_clip_start_height);
+      #endif
+      STOW_PROBE();
+      clean_up_after_endstop_or_probe_move();
+      #if HOTENDS > 1
+        tool_change(old_tool_index, 0, true);
+      #endif
+    }
+
+    inline void gcode_G33() {
+
+      const int8_t probe_points = parser.intval('P', DELTA_CALIBRATION_DEFAULT_POINTS);
+      if (!WITHIN(probe_points, 1, 7)) {
+        SERIAL_PROTOCOLLNPGM("?(P)oints is implausible (1-7).");
+        return;
+      }
+
+      const int8_t verbose_level = parser.byteval('V', 1);
+      if (!WITHIN(verbose_level, 0, 2)) {
+        SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-2).");
+        return;
+      }
+
+      const float calibration_precision = parser.floatval('C');
+      if (calibration_precision < 0) {
+        SERIAL_PROTOCOLLNPGM("?(C)alibration precision is implausible (>0).");
+        return;
+      }
+
+      const int8_t force_iterations = parser.intval('F', 0);
+      if (!WITHIN(force_iterations, 0, 30)) {
+        SERIAL_PROTOCOLLNPGM("?(F)orce iteration is implausible (0-30).");
+        return;
+      }
+
+      const bool towers_set           = parser.boolval('T', true),
+                 stow_after_each      = parser.boolval('E'),
+                 _1p_calibration      = probe_points == 1,
+                 _4p_calibration      = probe_points == 2,
+                 _4p_towers_points    = _4p_calibration && towers_set,
+                 _4p_opposite_points  = _4p_calibration && !towers_set,
+                 _7p_calibration      = probe_points >= 3,
+                 _7p_half_circle      = probe_points == 3,
+                 _7p_double_circle    = probe_points == 5,
+                 _7p_triple_circle    = probe_points == 6,
+                 _7p_quadruple_circle = probe_points == 7,
+                 _7p_multi_circle     = _7p_double_circle || _7p_triple_circle || _7p_quadruple_circle,
+                 _7p_intermed_points  = _7p_calibration && !_7p_half_circle;
+      const static char save_message[] PROGMEM = "Save with M500 and/or copy to Configuration.h";
+      const float dx = (X_PROBE_OFFSET_FROM_EXTRUDER),
+                  dy = (Y_PROBE_OFFSET_FROM_EXTRUDER);
+      int8_t iterations = 0;
+      float test_precision,
+            zero_std_dev = (verbose_level ? 999.0 : 0.0), // 0.0 in dry-run mode : forced end
+            zero_std_dev_old = zero_std_dev,
+            zero_std_dev_min = zero_std_dev,
+            e_old[XYZ] = {
+              endstop_adj[A_AXIS],
+              endstop_adj[B_AXIS],
+              endstop_adj[C_AXIS]
+            },
+            dr_old = delta_radius,
+            zh_old = home_offset[Z_AXIS],
+            alpha_old = delta_tower_angle_trim[A_AXIS],
+            beta_old = delta_tower_angle_trim[B_AXIS];
+
+      if (!_1p_calibration) {  // test if the outer radius is reachable
+        const float circles = (_7p_quadruple_circle ? 1.5 :
+                               _7p_triple_circle    ? 1.0 :
+                               _7p_double_circle    ? 0.5 : 0),
+                    r = (1 + circles * 0.1) * delta_calibration_radius;
+        for (uint8_t axis = 1; axis < 13; ++axis) {
+          const float a = RADIANS(180 + 30 * axis);
+          if (!position_is_reachable_xy(cos(a) * r, sin(a) * r)) {
+            SERIAL_PROTOCOLLNPGM("?(M665 B)ed radius is implausible.");
+            return;
+          }
+        }
+      }
+      SERIAL_PROTOCOLLNPGM("G33 Auto Calibrate");
+
+      stepper.synchronize();
+      #if HAS_LEVELING
+        reset_bed_level(); // After calibration bed-level data is no longer valid
+      #endif
+
+      #if HOTENDS > 1
+        const uint8_t old_tool_index = active_extruder;
+        tool_change(0, 0, true);
+        #define G33_CLEANUP() G33_cleanup(old_tool_index)
+      #else
+        #define G33_CLEANUP() G33_cleanup()
+      #endif
+
+      setup_for_endstop_or_probe_move();
+      endstops.enable(true);
+      if (!home_delta())
+        return;
+      endstops.not_homing();
+
+      // print settings
+
+      const char *checkingac = PSTR("Checking... AC"); // TODO: Make translatable string
+      serialprintPGM(checkingac);
+      if (verbose_level == 0) SERIAL_PROTOCOLPGM(" (DRY-RUN)");
+      SERIAL_EOL();
+      lcd_setstatusPGM(checkingac);
+
+      print_G33_settings(!_1p_calibration, _7p_calibration && towers_set);
+
+      #if DISABLED(PROBE_MANUALLY)
+        const float measured_z = probe_pt(dx, dy, stow_after_each, 1, false); // 1st probe to set height
+        if (isnan(measured_z)) return G33_CLEANUP();
+        home_offset[Z_AXIS] -= measured_z;
+      #endif
+
+      do {
+
+        float z_at_pt[13] = { 0.0 };
+
+        test_precision = zero_std_dev_old != 999.0 ? (zero_std_dev + zero_std_dev_old) / 2 : zero_std_dev;
+
+        iterations++;
+
+        // Probe the points
+
+        if (!_7p_half_circle && !_7p_triple_circle) { // probe the center
+          #if ENABLED(PROBE_MANUALLY)
+            z_at_pt[0] += lcd_probe_pt(0, 0);
+          #else
+            z_at_pt[0] += probe_pt(dx, dy, stow_after_each, 1, false);
+            if (isnan(z_at_pt[0])) return G33_CLEANUP();
+          #endif
+        }
+        if (_7p_calibration) { // probe extra center points
+          for (int8_t axis = _7p_multi_circle ? 11 : 9; axis > 0; axis -= _7p_multi_circle ? 2 : 4) {
+            const float a = RADIANS(180 + 30 * axis), r = delta_calibration_radius * 0.1;
+            #if ENABLED(PROBE_MANUALLY)
+              z_at_pt[0] += lcd_probe_pt(cos(a) * r, sin(a) * r);
+            #else
+              z_at_pt[0] += probe_pt(cos(a) * r + dx, sin(a) * r + dy, stow_after_each, 1);
+              if (isnan(z_at_pt[0])) return G33_CLEANUP();
+            #endif
+          }
+          z_at_pt[0] /= float(_7p_double_circle ? 7 : probe_points);
+        }
+        if (!_1p_calibration) {  // probe the radius
+          bool zig_zag = true;
+          const uint8_t start = _4p_opposite_points ? 3 : 1,
+                         step = _4p_calibration ? 4 : _7p_half_circle ? 2 : 1;
+          for (uint8_t axis = start; axis < 13; axis += step) {
+            const float zigadd = (zig_zag ? 0.5 : 0.0),
+                        offset_circles = _7p_quadruple_circle ? zigadd + 1.0 :
+                                         _7p_triple_circle    ? zigadd + 0.5 :
+                                         _7p_double_circle    ? zigadd : 0;
+            for (float circles = -offset_circles ; circles <= offset_circles; circles++) {
+              const float a = RADIANS(180 + 30 * axis),
+                          r = delta_calibration_radius * (1 + circles * (zig_zag ? 0.1 : -0.1));
+              #if ENABLED(PROBE_MANUALLY)
+                z_at_pt[axis] += lcd_probe_pt(cos(a) * r, sin(a) * r);
+              #else
+                z_at_pt[axis] += probe_pt(cos(a) * r + dx, sin(a) * r + dy, stow_after_each, 1);
+                if (isnan(z_at_pt[axis])) return G33_CLEANUP();
+              #endif
+            }
+            zig_zag = !zig_zag;
+            z_at_pt[axis] /= (2 * offset_circles + 1);
+          }
+        }
+        if (_7p_intermed_points) // average intermediates to tower and opposites
+          for (uint8_t axis = 1; axis < 13; axis += 2)
+            z_at_pt[axis] = (z_at_pt[axis] + (z_at_pt[axis + 1] + z_at_pt[(axis + 10) % 12 + 1]) / 2.0) / 2.0;
+
+        float S1 = z_at_pt[0],
+              S2 = sq(z_at_pt[0]);
+        int16_t N = 1;
+        if (!_1p_calibration) // std dev from zero plane
+          for (uint8_t axis = (_4p_opposite_points ? 3 : 1); axis < 13; axis += (_4p_calibration ? 4 : 2)) {
+            S1 += z_at_pt[axis];
+            S2 += sq(z_at_pt[axis]);
+            N++;
+          }
+        zero_std_dev_old = zero_std_dev;
+        zero_std_dev = round(SQRT(S2 / N) * 1000.0) / 1000.0 + 0.00001;
+
+        // Solve matrices
+
+        if ((zero_std_dev < test_precision && zero_std_dev > calibration_precision) || iterations <= force_iterations) {
+          if (zero_std_dev < zero_std_dev_min) {
+            COPY(e_old, endstop_adj);
+            dr_old = delta_radius;
+            zh_old = home_offset[Z_AXIS];
+            alpha_old = delta_tower_angle_trim[A_AXIS];
+            beta_old = delta_tower_angle_trim[B_AXIS];
+          }
+
+          float e_delta[XYZ] = { 0.0 }, r_delta = 0.0, t_alpha = 0.0, t_beta = 0.0;
+          const float r_diff = delta_radius - delta_calibration_radius,
+                      h_factor = 1.00 + r_diff * 0.001,                          //1.02 for r_diff = 20mm
+                      r_factor = -(1.75 + 0.005 * r_diff + 0.001 * sq(r_diff)),  //2.25 for r_diff = 20mm
+                      a_factor = 100.0 / delta_calibration_radius;               //1.25 for cal_rd = 80mm
+
+          #define ZP(N,I) ((N) * z_at_pt[I])
+          #define Z1000(I) ZP(1.00, I)
+          #define Z1050(I) ZP(h_factor, I)
+          #define Z0700(I) ZP(h_factor * 2.0 / 3.00, I)
+          #define Z0350(I) ZP(h_factor / 3.00, I)
+          #define Z0175(I) ZP(h_factor / 6.00, I)
+          #define Z2250(I) ZP(r_factor, I)
+          #define Z0750(I) ZP(r_factor / 3.00, I)
+          #define Z0375(I) ZP(r_factor / 6.00, I)
+          #define Z0444(I) ZP(a_factor * 4.0 / 9.0, I)
+          #define Z0888(I) ZP(a_factor * 8.0 / 9.0, I)
+
+          #if ENABLED(PROBE_MANUALLY)
+            test_precision = 0.00; // forced end
+          #endif
+
+          switch (probe_points) {
+            case 1:
+              test_precision = 0.00; // forced end
+              LOOP_XYZ(i) e_delta[i] = Z1000(0);
+              break;
+
+            case 2:
+              if (towers_set) {
+                e_delta[X_AXIS] = Z1050(0) + Z0700(1) - Z0350(5) - Z0350(9);
+                e_delta[Y_AXIS] = Z1050(0) - Z0350(1) + Z0700(5) - Z0350(9);
+                e_delta[Z_AXIS] = Z1050(0) - Z0350(1) - Z0350(5) + Z0700(9);
+                r_delta         = Z2250(0) - Z0750(1) - Z0750(5) - Z0750(9);
+              }
+              else {
+                e_delta[X_AXIS] = Z1050(0) - Z0700(7) + Z0350(11) + Z0350(3);
+                e_delta[Y_AXIS] = Z1050(0) + Z0350(7) - Z0700(11) + Z0350(3);
+                e_delta[Z_AXIS] = Z1050(0) + Z0350(7) + Z0350(11) - Z0700(3);
+                r_delta         = Z2250(0) - Z0750(7) - Z0750(11) - Z0750(3);
+              }
+              break;
+
+            default:
+              e_delta[X_AXIS] = Z1050(0) + Z0350(1) - Z0175(5) - Z0175(9) - Z0350(7) + Z0175(11) + Z0175(3);
+              e_delta[Y_AXIS] = Z1050(0) - Z0175(1) + Z0350(5) - Z0175(9) + Z0175(7) - Z0350(11) + Z0175(3);
+              e_delta[Z_AXIS] = Z1050(0) - Z0175(1) - Z0175(5) + Z0350(9) + Z0175(7) + Z0175(11) - Z0350(3);
+              r_delta         = Z2250(0) - Z0375(1) - Z0375(5) - Z0375(9) - Z0375(7) - Z0375(11) - Z0375(3);
+
+              if (towers_set) {
+                t_alpha = Z0444(1) - Z0888(5) + Z0444(9) + Z0444(7) - Z0888(11) + Z0444(3);
+                t_beta  = Z0888(1) - Z0444(5) - Z0444(9) + Z0888(7) - Z0444(11) - Z0444(3);
+              }
+              break;
+          }
+
+          LOOP_XYZ(axis) endstop_adj[axis] += e_delta[axis];
+          delta_radius += r_delta;
+          delta_tower_angle_trim[A_AXIS] += t_alpha;
+          delta_tower_angle_trim[B_AXIS] += t_beta;
+
+          // adjust delta_height and endstops by the max amount
+          const float z_temp = MAX3(endstop_adj[A_AXIS], endstop_adj[B_AXIS], endstop_adj[C_AXIS]);
+          home_offset[Z_AXIS] -= z_temp;
+          LOOP_XYZ(i) endstop_adj[i] -= z_temp;
+
+          recalc_delta_settings(delta_radius, delta_diagonal_rod);
+        }
+        else if (zero_std_dev >= test_precision) {   // step one back
+          COPY(endstop_adj, e_old);
+          delta_radius = dr_old;
+          home_offset[Z_AXIS] = zh_old;
+          delta_tower_angle_trim[A_AXIS] = alpha_old;
+          delta_tower_angle_trim[B_AXIS] = beta_old;
+
+          recalc_delta_settings(delta_radius, delta_diagonal_rod);
+        }
+        NOMORE(zero_std_dev_min, zero_std_dev);
+
+        // print report
+
+        if (verbose_level != 1) {
+          SERIAL_PROTOCOLPGM(".    ");
+          print_signed_float(PSTR("c"), z_at_pt[0]);
+          if (_4p_towers_points || _7p_calibration) {
+            print_signed_float(PSTR("   x"), z_at_pt[1]);
+            print_signed_float(PSTR(" y"), z_at_pt[5]);
+            print_signed_float(PSTR(" z"), z_at_pt[9]);
+          }
+          if (!_4p_opposite_points) SERIAL_EOL();
+          if ((_4p_opposite_points) || _7p_calibration) {
+            if (_7p_calibration) {
+              SERIAL_CHAR('.');
+              SERIAL_PROTOCOL_SP(13);
+            }
+            print_signed_float(PSTR("  yz"), z_at_pt[7]);
+            print_signed_float(PSTR("zx"), z_at_pt[11]);
+            print_signed_float(PSTR("xy"), z_at_pt[3]);
+            SERIAL_EOL();
+          }
+        }
+        if (verbose_level != 0) {                                    // !dry run
+          if ((zero_std_dev >= test_precision || zero_std_dev <= calibration_precision) && iterations > force_iterations) {  // end iterations
+            SERIAL_PROTOCOLPGM("Calibration OK");
+            SERIAL_PROTOCOL_SP(36);
+            #if DISABLED(PROBE_MANUALLY)
+              if (zero_std_dev >= test_precision && !_1p_calibration)
+                SERIAL_PROTOCOLPGM("rolling back.");
+              else
+            #endif
+              {
+                SERIAL_PROTOCOLPGM("std dev:");
+                SERIAL_PROTOCOL_F(zero_std_dev_min, 3);
+              }
+            SERIAL_EOL();
+            char mess[21];
+            sprintf_P(mess, PSTR("Calibration sd:"));
+            if (zero_std_dev_min < 1)
+              sprintf_P(&mess[15], PSTR("0.%03i"), (int)round(zero_std_dev_min * 1000.0));
+            else
+              sprintf_P(&mess[15], PSTR("%03i.x"), (int)round(zero_std_dev_min));
+            lcd_setstatus(mess);
+            print_G33_settings(!_1p_calibration, _7p_calibration && towers_set);
+            serialprintPGM(save_message);
+            SERIAL_EOL();
+          }
+          else {                                                     // !end iterations
+            char mess[15];
+            if (iterations < 31)
+              sprintf_P(mess, PSTR("Iteration : %02i"), (int)iterations);
+            else
+              sprintf_P(mess, PSTR("No convergence"));
+            SERIAL_PROTOCOL(mess);
+            SERIAL_PROTOCOL_SP(36);
+            SERIAL_PROTOCOLPGM("std dev:");
+            SERIAL_PROTOCOL_F(zero_std_dev, 3);
+            SERIAL_EOL();
+            lcd_setstatus(mess);
+            print_G33_settings(!_1p_calibration, _7p_calibration && towers_set);
+          }
+        }
+        else {                                                       // dry run
+          const char *enddryrun = PSTR("End DRY-RUN");
+          serialprintPGM(enddryrun);
+          SERIAL_PROTOCOL_SP(39);
+          SERIAL_PROTOCOLPGM("std dev:");
+          SERIAL_PROTOCOL_F(zero_std_dev, 3);
+          SERIAL_EOL();
+
+          char mess[21];
+          sprintf_P(mess, enddryrun);
+          sprintf_P(&mess[11], PSTR(" sd:"));
+          if (zero_std_dev < 1)
+            sprintf_P(&mess[15], PSTR("0.%03i"), (int)round(zero_std_dev * 1000.0));
+          else
+            sprintf_P(&mess[15], PSTR("%03i.x"), (int)round(zero_std_dev));
+          lcd_setstatus(mess);
+        }
+
+        endstops.enable(true);
+        home_delta();
+        endstops.not_homing();
+
+      }
+      while ((zero_std_dev < test_precision && zero_std_dev > calibration_precision && iterations < 31) || iterations <= force_iterations);
+
+      G33_CLEANUP();
+    }
+
+  #endif // DELTA_AUTO_CALIBRATION
+
+#endif // PROBE_SELECTED
+
+#if ENABLED(G38_PROBE_TARGET)
+
+  static bool G38_run_probe() {
+
+    bool G38_pass_fail = false;
+
+    #if ENABLED(PROBE_DOUBLE_TOUCH)
+      // Get direction of move and retract
+      float retract_mm[XYZ];
+      LOOP_XYZ(i) {
+        float dist = destination[i] - current_position[i];
+        retract_mm[i] = FABS(dist) < G38_MINIMUM_MOVE ? 0 : home_bump_mm((AxisEnum)i) * (dist > 0 ? -1 : 1);
+      }
+    #endif
+
+    stepper.synchronize();  // wait until the machine is idle
+
+    // Move until destination reached or target hit
+    endstops.enable(true);
+    G38_move = true;
+    G38_endstop_hit = false;
+    prepare_move_to_destination();
+    stepper.synchronize();
+    G38_move = false;
+
+    endstops.hit_on_purpose();
+    set_current_from_steppers_for_axis(ALL_AXES);
+    SYNC_PLAN_POSITION_KINEMATIC();
+
+    if (G38_endstop_hit) {
+
+      G38_pass_fail = true;
+
+      #if ENABLED(PROBE_DOUBLE_TOUCH)
+        // Move away by the retract distance
+        set_destination_to_current();
+        LOOP_XYZ(i) destination[i] += retract_mm[i];
+        endstops.enable(false);
+        prepare_move_to_destination();
+        stepper.synchronize();
+
+        feedrate_mm_s /= 4;
+
+        // Bump the target more slowly
+        LOOP_XYZ(i) destination[i] -= retract_mm[i] * 2;
+
+        endstops.enable(true);
+        G38_move = true;
+        prepare_move_to_destination();
+        stepper.synchronize();
+        G38_move = false;
+
+        set_current_from_steppers_for_axis(ALL_AXES);
+        SYNC_PLAN_POSITION_KINEMATIC();
+      #endif
+    }
+
+    endstops.hit_on_purpose();
+    endstops.not_homing();
+    return G38_pass_fail;
+  }
+
+  /**
+   * G38.2 - probe toward workpiece, stop on contact, signal error if failure
+   * G38.3 - probe toward workpiece, stop on contact
+   *
+   * Like G28 except uses Z min probe for all axes
+   */
+  inline void gcode_G38(bool is_38_2) {
+    // Get X Y Z E F
+    gcode_get_destination();
+
+    setup_for_endstop_or_probe_move();
+
+    // If any axis has enough movement, do the move
+    LOOP_XYZ(i)
+      if (FABS(destination[i] - current_position[i]) >= G38_MINIMUM_MOVE) {
+        if (!parser.seenval('F')) feedrate_mm_s = homing_feedrate((AxisEnum)i);
+        // If G38.2 fails throw an error
+        if (!G38_run_probe() && is_38_2) {
+          SERIAL_ERROR_START();
+          SERIAL_ERRORLNPGM("Failed to reach target");
+        }
+        break;
+      }
+
+    clean_up_after_endstop_or_probe_move();
+  }
+
+#endif // G38_PROBE_TARGET
+
+#if ENABLED(AUTO_BED_LEVELING_BILINEAR) || ENABLED(AUTO_BED_LEVELING_UBL) || ENABLED(MESH_BED_LEVELING)
+
+  /**
+   * G42: Move X & Y axes to mesh coordinates (I & J)
+   */
+  inline void gcode_G42() {
+    if (IsRunning()) {
+      const bool hasI = parser.seenval('I');
+      const int8_t ix = hasI ? parser.value_int() : 0;
+      const bool hasJ = parser.seenval('J');
+      const int8_t iy = hasJ ? parser.value_int() : 0;
+
+      if ((hasI && !WITHIN(ix, 0, GRID_MAX_POINTS_X - 1)) || (hasJ && !WITHIN(iy, 0, GRID_MAX_POINTS_Y - 1))) {
+        SERIAL_ECHOLNPGM(MSG_ERR_MESH_XY);
+        return;
+      }
+
+      #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
+        #define _GET_MESH_X(I) bilinear_start[X_AXIS] + I * bilinear_grid_spacing[X_AXIS]
+        #define _GET_MESH_Y(J) bilinear_start[Y_AXIS] + J * bilinear_grid_spacing[Y_AXIS]
+      #elif ENABLED(AUTO_BED_LEVELING_UBL)
+        #define _GET_MESH_X(I) ubl.mesh_index_to_xpos(I)
+        #define _GET_MESH_Y(J) ubl.mesh_index_to_ypos(J)
+      #elif ENABLED(MESH_BED_LEVELING)
+        #define _GET_MESH_X(I) mbl.index_to_xpos[I]
+        #define _GET_MESH_Y(J) mbl.index_to_ypos[J]
+      #endif
+
+      set_destination_to_current();
+      if (hasI) destination[X_AXIS] = LOGICAL_X_POSITION(_GET_MESH_X(ix));
+      if (hasJ) destination[Y_AXIS] = LOGICAL_Y_POSITION(_GET_MESH_Y(iy));
+      if (parser.boolval('P')) {
+        if (hasI) destination[X_AXIS] -= X_PROBE_OFFSET_FROM_EXTRUDER;
+        if (hasJ) destination[Y_AXIS] -= Y_PROBE_OFFSET_FROM_EXTRUDER;
+      }
+
+      const float fval = parser.linearval('F');
+      if (fval > 0.0) feedrate_mm_s = MMM_TO_MMS(fval);
+
+      // SCARA kinematic has "safe" XY raw moves
+      #if IS_SCARA
+        prepare_uninterpolated_move_to_destination();
+      #else
+        prepare_move_to_destination();
+      #endif
+    }
+  }
+
+#endif // AUTO_BED_LEVELING_UBL
+
+/**
+ * G92: Set current position to given X Y Z E
+ */
+inline void gcode_G92() {
+  bool didXYZ = false,
+       didE = parser.seenval('E');
+
+  if (!didE) stepper.synchronize();
+
+  LOOP_XYZE(i) {
+    if (parser.seenval(axis_codes[i])) {
+      #if IS_SCARA
+        current_position[i] = parser.value_axis_units((AxisEnum)i);
+        if (i != E_AXIS) didXYZ = true;
+      #else
+        #if HAS_POSITION_SHIFT
+          const float p = current_position[i];
+        #endif
+        const float v = parser.value_axis_units((AxisEnum)i);
+
+        current_position[i] = v;
+
+        if (i != E_AXIS) {
+          didXYZ = true;
+          #if HAS_POSITION_SHIFT
+            position_shift[i] += v - p; // Offset the coordinate space
+            update_software_endstops((AxisEnum)i);
+
+            #if ENABLED(I2C_POSITION_ENCODERS)
+              I2CPEM.encoders[I2CPEM.idx_from_axis((AxisEnum)i)].set_axis_offset(position_shift[i]);
+            #endif
+
+          #endif
+        }
+      #endif
+    }
+  }
+  if (didXYZ)
+    SYNC_PLAN_POSITION_KINEMATIC();
+  else if (didE)
+    sync_plan_position_e();
+
+  report_current_position();
+}
+
+#if HAS_RESUME_CONTINUE
+
+  /**
+   * M0: Unconditional stop - Wait for user button press on LCD
+   * M1: Conditional stop   - Wait for user button press on LCD
+   */
+  inline void gcode_M0_M1() {
+    const char * const args = parser.string_arg;
+
+    millis_t ms = 0;
+    bool hasP = false, hasS = false;
+    if (parser.seenval('P')) {
+      ms = parser.value_millis(); // milliseconds to wait
+      hasP = ms > 0;
+    }
+    if (parser.seenval('S')) {
+      ms = parser.value_millis_from_seconds(); // seconds to wait
+      hasS = ms > 0;
+    }
+
+    #if ENABLED(ULTIPANEL)
+
+      if (!hasP && !hasS && args && *args)
+        lcd_setstatus(args, true);
+      else {
+        LCD_MESSAGEPGM(MSG_USERWAIT);
+        #if ENABLED(LCD_PROGRESS_BAR) && PROGRESS_MSG_EXPIRE > 0
+          dontExpireStatus();
+        #endif
+      }
+
+    #else
+
+      if (!hasP && !hasS && args && *args) {
+        SERIAL_ECHO_START();
+        SERIAL_ECHOLN(args);
+      }
+
+    #endif
+
+    KEEPALIVE_STATE(PAUSED_FOR_USER);
+    wait_for_user = true;
+
+    stepper.synchronize();
+    refresh_cmd_timeout();
+
+    if (ms > 0) {
+      ms += previous_cmd_ms;  // wait until this time for a click
+      while (PENDING(millis(), ms) && wait_for_user) idle();
+    }
+    else {
+      #if ENABLED(ULTIPANEL)
+        if (lcd_detected()) {
+          while (wait_for_user) idle();
+          IS_SD_PRINTING ? LCD_MESSAGEPGM(MSG_RESUMING) : LCD_MESSAGEPGM(WELCOME_MSG);
+        }
+      #else
+        while (wait_for_user) idle();
+      #endif
+    }
+
+    wait_for_user = false;
+    KEEPALIVE_STATE(IN_HANDLER);
+  }
+
+#endif // HAS_RESUME_CONTINUE
+
+#if ENABLED(SPINDLE_LASER_ENABLE)
+  /**
+   * M3: Spindle Clockwise
+   * M4: Spindle Counter-clockwise
+   *
+   *  S0 turns off spindle.
+   *
+   *  If no speed PWM output is defined then M3/M4 just turns it on.
+   *
+   *  At least 12.8KHz (50Hz * 256) is needed for spindle PWM.
+   *  Hardware PWM is required. ISRs are too slow.
+   *
+   * NOTE: WGM for timers 3, 4, and 5 must be either Mode 1 or Mode 5.
+   *       No other settings give a PWM signal that goes from 0 to 5 volts.
+   *
+   *       The system automatically sets WGM to Mode 1, so no special
+   *       initialization is needed.
+   *
+   *       WGM bits for timer 2 are automatically set by the system to
+   *       Mode 1. This produces an acceptable 0 to 5 volt signal.
+   *       No special initialization is needed.
+   *
+   * NOTE: A minimum PWM frequency of 50 Hz is needed. All prescaler
+   *       factors for timers 2, 3, 4, and 5 are acceptable.
+   *
+   *  SPINDLE_LASER_ENABLE_PIN needs an external pullup or it may power on
+   *  the spindle/laser during power-up or when connecting to the host
+   *  (usually goes through a reset which sets all I/O pins to tri-state)
+   *
+   *  PWM duty cycle goes from 0 (off) to 255 (always on).
+   */
+
+  // Wait for spindle to come up to speed
+  inline void delay_for_power_up() { dwell(SPINDLE_LASER_POWERUP_DELAY); }
+
+  // Wait for spindle to stop turning
+  inline void delay_for_power_down() { dwell(SPINDLE_LASER_POWERDOWN_DELAY); }
+
+  /**
+   * ocr_val_mode() is used for debugging and to get the points needed to compute the RPM vs ocr_val line
+   *
+   * it accepts inputs of 0-255
+   */
+
+  inline void ocr_val_mode() {
+    uint8_t spindle_laser_power = parser.value_byte();
+    WRITE(SPINDLE_LASER_ENABLE_PIN, SPINDLE_LASER_ENABLE_INVERT); // turn spindle on (active low)
+    if (SPINDLE_LASER_PWM_INVERT) spindle_laser_power = 255 - spindle_laser_power;
+    analogWrite(SPINDLE_LASER_PWM_PIN, spindle_laser_power);
+  }
+
+  inline void gcode_M3_M4(bool is_M3) {
+
+    stepper.synchronize();   // wait until previous movement commands (G0/G0/G2/G3) have completed before playing with the spindle
+    #if SPINDLE_DIR_CHANGE
+      const bool rotation_dir = (is_M3 && !SPINDLE_INVERT_DIR || !is_M3 && SPINDLE_INVERT_DIR) ? HIGH : LOW;
+      if (SPINDLE_STOP_ON_DIR_CHANGE \
+         && READ(SPINDLE_LASER_ENABLE_PIN) == SPINDLE_LASER_ENABLE_INVERT \
+         && READ(SPINDLE_DIR_PIN) != rotation_dir
+      ) {
+        WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);  // turn spindle off
+        delay_for_power_down();
+      }
+      WRITE(SPINDLE_DIR_PIN, rotation_dir);
+    #endif
+
+    /**
+     * Our final value for ocr_val is an unsigned 8 bit value between 0 and 255 which usually means uint8_t.
+     * Went to uint16_t because some of the uint8_t calculations would sometimes give 1000 0000 rather than 1111 1111.
+     * Then needed to AND the uint16_t result with 0x00FF to make sure we only wrote the byte of interest.
+     */
+    #if ENABLED(SPINDLE_LASER_PWM)
+      if (parser.seen('O')) ocr_val_mode();
+      else {
+        const float spindle_laser_power = parser.floatval('S');
+        if (spindle_laser_power == 0) {
+          WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);                                    // turn spindle off (active low)
+          delay_for_power_down();
+        }
+        else {
+          int16_t ocr_val = (spindle_laser_power - (SPEED_POWER_INTERCEPT)) * (1.0 / (SPEED_POWER_SLOPE));  // convert RPM to PWM duty cycle
+          NOMORE(ocr_val, 255);                                                                             // limit to max the Atmel PWM will support
+          if (spindle_laser_power <= SPEED_POWER_MIN)
+            ocr_val = (SPEED_POWER_MIN - (SPEED_POWER_INTERCEPT)) * (1.0 / (SPEED_POWER_SLOPE));            // minimum setting
+          if (spindle_laser_power >= SPEED_POWER_MAX)
+            ocr_val = (SPEED_POWER_MAX - (SPEED_POWER_INTERCEPT)) * (1.0 / (SPEED_POWER_SLOPE));            // limit to max RPM
+          if (SPINDLE_LASER_PWM_INVERT) ocr_val = 255 - ocr_val;
+          WRITE(SPINDLE_LASER_ENABLE_PIN, SPINDLE_LASER_ENABLE_INVERT);                                     // turn spindle on (active low)
+          analogWrite(SPINDLE_LASER_PWM_PIN, ocr_val & 0xFF);                                               // only write low byte
+          delay_for_power_up();
+        }
+      }
+    #else
+      WRITE(SPINDLE_LASER_ENABLE_PIN, SPINDLE_LASER_ENABLE_INVERT); // turn spindle on (active low) if spindle speed option not enabled
+      delay_for_power_up();
+    #endif
+  }
+
+ /**
+  * M5 turn off spindle
+  */
+  inline void gcode_M5() {
+    stepper.synchronize();
+    WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);
+    delay_for_power_down();
+  }
+
+#endif // SPINDLE_LASER_ENABLE
+
+/**
+ * M17: Enable power on all stepper motors
+ */
+inline void gcode_M17() {
+  LCD_MESSAGEPGM(MSG_NO_MOVE);
+  enable_all_steppers();
+}
+
+#if IS_KINEMATIC
+  #define RUNPLAN(RATE_MM_S) planner.buffer_line_kinematic(destination, RATE_MM_S, active_extruder)
+#else
+  #define RUNPLAN(RATE_MM_S) line_to_destination(RATE_MM_S)
+#endif
+
+#if ENABLED(ADVANCED_PAUSE_FEATURE)
+
+  static float resume_position[XYZE];
+  static bool move_away_flag = false;
+  #if ENABLED(SDSUPPORT)
+    static bool sd_print_paused = false;
+  #endif
+
+  static void filament_change_beep(const int8_t max_beep_count, const bool init=false) {
+    static millis_t next_buzz = 0;
+    static int8_t runout_beep = 0;
+
+    if (init) next_buzz = runout_beep = 0;
+
+    const millis_t ms = millis();
+    if (ELAPSED(ms, next_buzz)) {
+      if (max_beep_count < 0 || runout_beep < max_beep_count + 5) { // Only beep as long as we're supposed to
+        next_buzz = ms + ((max_beep_count < 0 || runout_beep < max_beep_count) ? 2500 : 400);
+        BUZZ(300, 2000);
+        runout_beep++;
+      }
+    }
+  }
+
+  static void ensure_safe_temperature() {
+    bool heaters_heating = true;
+
+    wait_for_heatup = true;    // M108 will clear this
+    while (wait_for_heatup && heaters_heating) {
+      idle();
+      heaters_heating = false;
+      HOTEND_LOOP() {
+        if (thermalManager.degTargetHotend(e) && abs(thermalManager.degHotend(e) - thermalManager.degTargetHotend(e)) > TEMP_HYSTERESIS) {
+          heaters_heating = true;
+          #if ENABLED(ULTIPANEL)
+            lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_WAIT_FOR_NOZZLES_TO_HEAT);
+          #endif
+          break;
+        }
+      }
+    }
+  }
+
+  static bool pause_print(const float &retract, const float &z_lift, const float &x_pos, const float &y_pos,
+                          const float &unload_length = 0 , const int8_t max_beep_count = 0, const bool show_lcd = false
+  ) {
+    if (move_away_flag) return false; // already paused
+
+    if (!DEBUGGING(DRYRUN) && (unload_length != 0 || retract != 0)) {
+      #if ENABLED(PREVENT_COLD_EXTRUSION)
+        if (!thermalManager.allow_cold_extrude &&
+            thermalManager.degTargetHotend(active_extruder) < thermalManager.extrude_min_temp) {
+          SERIAL_ERROR_START();
+          SERIAL_ERRORLNPGM(MSG_TOO_COLD_FOR_M600);
+          return false;
+        }
+      #endif
+
+      ensure_safe_temperature(); // wait for extruder to heat up before unloading
+    }
+
+    // Indicate that the printer is paused
+    move_away_flag = true;
+
+    // Pause the print job and timer
+    #if ENABLED(SDSUPPORT)
+      if (card.sdprinting) {
+        card.pauseSDPrint();
+        sd_print_paused = true;
+      }
+    #endif
+    print_job_timer.pause();
+
+    // Show initial message and wait for synchronize steppers
+    if (show_lcd) {
+      #if ENABLED(ULTIPANEL)
+        lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INIT);
+      #endif
+    }
+
+    // Save current position
+    stepper.synchronize();
+    COPY(resume_position, current_position);
+
+    if (retract) {
+      // Initial retract before move to filament change position
+      set_destination_to_current();
+      destination[E_AXIS] += retract;
+      RUNPLAN(PAUSE_PARK_RETRACT_FEEDRATE);
+      stepper.synchronize();
+    }
+
+    // Lift Z axis
+    if (z_lift > 0)
+      do_blocking_move_to_z(current_position[Z_AXIS] + z_lift, PAUSE_PARK_Z_FEEDRATE);
+
+    // Move XY axes to filament exchange position
+    do_blocking_move_to_xy(x_pos, y_pos, PAUSE_PARK_XY_FEEDRATE);
+
+    if (unload_length != 0) {
+      if (show_lcd) {
+        #if ENABLED(ULTIPANEL)
+          lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_UNLOAD);
+          idle();
+        #endif
+      }
+
+      // Unload filament
+      set_destination_to_current();
+      destination[E_AXIS] += unload_length;
+      RUNPLAN(FILAMENT_CHANGE_UNLOAD_FEEDRATE);
+      stepper.synchronize();
+    }
+
+    if (show_lcd) {
+      #if ENABLED(ULTIPANEL)
+        lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INSERT);
+      #endif
+    }
+
+    #if HAS_BUZZER
+      filament_change_beep(max_beep_count, true);
+    #endif
+
+    idle();
+
+    // Disable extruders steppers for manual filament changing (only on boards that have separate ENABLE_PINS)
+    #if E0_ENABLE_PIN != X_ENABLE_PIN && E1_ENABLE_PIN != Y_ENABLE_PIN
+      disable_e_steppers();
+      safe_delay(100);
+    #endif
+
+    // Start the heater idle timers
+    const millis_t nozzle_timeout = (millis_t)(PAUSE_PARK_NOZZLE_TIMEOUT) * 1000UL;
+
+    HOTEND_LOOP()
+      thermalManager.start_heater_idle_timer(e, nozzle_timeout);
+
+    return true;
+  }
+
+  static void wait_for_filament_reload(const int8_t max_beep_count = 0) {
+    bool nozzle_timed_out = false;
+
+    // Wait for filament insert by user and press button
+    KEEPALIVE_STATE(PAUSED_FOR_USER);
+    wait_for_user = true;    // LCD click or M108 will clear this
+    while (wait_for_user) {
+      #if HAS_BUZZER
+        filament_change_beep(max_beep_count);
+      #endif
+
+      // If the nozzle has timed out, wait for the user to press the button to re-heat the nozzle, then
+      // re-heat the nozzle, re-show the insert screen, restart the idle timers, and start over
+      if (!nozzle_timed_out)
+        HOTEND_LOOP()
+          nozzle_timed_out |= thermalManager.is_heater_idle(e);
+
+      if (nozzle_timed_out) {
+        #if ENABLED(ULTIPANEL)
+          lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_CLICK_TO_HEAT_NOZZLE);
+        #endif
+
+        // Wait for LCD click or M108
+        while (wait_for_user) idle(true);
+
+        // Re-enable the heaters if they timed out
+        HOTEND_LOOP() thermalManager.reset_heater_idle_timer(e);
+
+        // Wait for the heaters to reach the target temperatures
+        ensure_safe_temperature();
+
+        #if ENABLED(ULTIPANEL)
+          lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INSERT);
+        #endif
+
+        // Start the heater idle timers
+        const millis_t nozzle_timeout = (millis_t)(PAUSE_PARK_NOZZLE_TIMEOUT) * 1000UL;
+
+        HOTEND_LOOP()
+          thermalManager.start_heater_idle_timer(e, nozzle_timeout);
+
+        wait_for_user = true; /* Wait for user to load filament */
+        nozzle_timed_out = false;
+
+        #if HAS_BUZZER
+          filament_change_beep(max_beep_count, true);
+        #endif
+      }
+
+      idle(true);
+    }
+    KEEPALIVE_STATE(IN_HANDLER);
+  }
+
+  static void resume_print(const float &load_length = 0, const float &initial_extrude_length = 0, const int8_t max_beep_count = 0) {
+    bool nozzle_timed_out = false;
+
+    if (!move_away_flag) return;
+
+    // Re-enable the heaters if they timed out
+    HOTEND_LOOP() {
+      nozzle_timed_out |= thermalManager.is_heater_idle(e);
+      thermalManager.reset_heater_idle_timer(e);
+    }
+
+    if (nozzle_timed_out) ensure_safe_temperature();
+
+    #if HAS_BUZZER
+      filament_change_beep(max_beep_count, true);
+    #endif
+
+    if (load_length != 0) {
+      #if ENABLED(ULTIPANEL)
+        // Show "insert filament"
+        if (nozzle_timed_out)
+          lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_INSERT);
+      #endif
+
+      KEEPALIVE_STATE(PAUSED_FOR_USER);
+      wait_for_user = true;    // LCD click or M108 will clear this
+      while (wait_for_user && nozzle_timed_out) {
+        #if HAS_BUZZER
+          filament_change_beep(max_beep_count);
+        #endif
+        idle(true);
+      }
+      KEEPALIVE_STATE(IN_HANDLER);
+
+      #if ENABLED(ULTIPANEL)
+        // Show "load" message
+        lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_LOAD);
+      #endif
+
+      // Load filament
+      destination[E_AXIS] += load_length;
+      RUNPLAN(FILAMENT_CHANGE_LOAD_FEEDRATE);
+      stepper.synchronize();
+    }
+
+    #if ENABLED(ULTIPANEL) && ADVANCED_PAUSE_EXTRUDE_LENGTH > 0
+
+      float extrude_length = initial_extrude_length;
+
+      do {
+        if (extrude_length > 0) {
+          // "Wait for filament extrude"
+          lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_EXTRUDE);
+
+          // Extrude filament to get into hotend
+          destination[E_AXIS] += extrude_length;
+          RUNPLAN(ADVANCED_PAUSE_EXTRUDE_FEEDRATE);
+          stepper.synchronize();
+        }
+
+        // Show "Extrude More" / "Resume" menu and wait for reply
+        KEEPALIVE_STATE(PAUSED_FOR_USER);
+        wait_for_user = false;
+        lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_OPTION);
+        while (advanced_pause_menu_response == ADVANCED_PAUSE_RESPONSE_WAIT_FOR) idle(true);
+        KEEPALIVE_STATE(IN_HANDLER);
+
+        extrude_length = ADVANCED_PAUSE_EXTRUDE_LENGTH;
+
+        // Keep looping if "Extrude More" was selected
+      } while (advanced_pause_menu_response == ADVANCED_PAUSE_RESPONSE_EXTRUDE_MORE);
+
+    #endif
+
+    #if ENABLED(ULTIPANEL)
+      // "Wait for print to resume"
+      lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_RESUME);
+    #endif
+
+    // Set extruder to saved position
+    destination[E_AXIS] = current_position[E_AXIS] = resume_position[E_AXIS];
+    planner.set_e_position_mm(current_position[E_AXIS]);
+
+    // Move XY to starting position, then Z
+    do_blocking_move_to_xy(resume_position[X_AXIS], resume_position[Y_AXIS], PAUSE_PARK_XY_FEEDRATE);
+    do_blocking_move_to_z(resume_position[Z_AXIS], PAUSE_PARK_Z_FEEDRATE);
+
+    #if ENABLED(FILAMENT_RUNOUT_SENSOR)
+      filament_ran_out = false;
+    #endif
+
+    #if ENABLED(ULTIPANEL)
+      // Show status screen
+      lcd_advanced_pause_show_message(ADVANCED_PAUSE_MESSAGE_STATUS);
+    #endif
+
+    #if ENABLED(SDSUPPORT)
+      if (sd_print_paused) {
+        card.startFileprint();
+        sd_print_paused = false;
+      }
+    #endif
+
+    move_away_flag = false;
+  }
+#endif // ADVANCED_PAUSE_FEATURE
+
+#if ENABLED(SDSUPPORT)
+
+  /**
+   * M20: List SD card to serial output
+   */
+  inline void gcode_M20() {
+    SERIAL_PROTOCOLLNPGM(MSG_BEGIN_FILE_LIST);
+    card.ls();
+    SERIAL_PROTOCOLLNPGM(MSG_END_FILE_LIST);
+  }
+
+  /**
+   * M21: Init SD Card
+   */
+  inline void gcode_M21() { card.initsd(); }
+
+  /**
+   * M22: Release SD Card
+   */
+  inline void gcode_M22() { card.release(); }
+
+  /**
+   * M23: Open a file
+   */
+  inline void gcode_M23() {
+    // Simplify3D includes the size, so zero out all spaces (#7227)
+    for (char *fn = parser.string_arg; *fn; ++fn) if (*fn == ' ') *fn = '\0';
+    card.openFile(parser.string_arg, true);
+  }
+
+  /**
+   * M24: Start or Resume SD Print
+   */
+  inline void gcode_M24() {
+    #if ENABLED(PARK_HEAD_ON_PAUSE)
+      resume_print();
+    #endif
+
+    card.startFileprint();
+    print_job_timer.start();
+  }
+
+  /**
+   * M25: Pause SD Print
+   */
+  inline void gcode_M25() {
+    card.pauseSDPrint();
+    print_job_timer.pause();
+
+    #if ENABLED(PARK_HEAD_ON_PAUSE)
+      enqueue_and_echo_commands_P(PSTR("M125")); // Must be enqueued with pauseSDPrint set to be last in the buffer
+    #endif
+  }
+
+  /**
+   * M26: Set SD Card file index
+   */
+  inline void gcode_M26() {
+    if (card.cardOK && parser.seenval('S'))
+      card.setIndex(parser.value_long());
+  }
+
+  /**
+   * M27: Get SD Card status
+   */
+  inline void gcode_M27() { card.getStatus(); }
+
+  /**
+   * M28: Start SD Write
+   */
+  inline void gcode_M28() { card.openFile(parser.string_arg, false); }
+
+  /**
+   * M29: Stop SD Write
+   * Processed in write to file routine above
+   */
+  inline void gcode_M29() {
+    // card.saving = false;
+  }
+
+  /**
+   * M30 <filename>: Delete SD Card file
+   */
+  inline void gcode_M30() {
+    if (card.cardOK) {
+      card.closefile();
+      card.removeFile(parser.string_arg);
+    }
+  }
+
+#endif // SDSUPPORT
+
+/**
+ * M31: Get the time since the start of SD Print (or last M109)
+ */
+inline void gcode_M31() {
+  char buffer[21];
+  duration_t elapsed = print_job_timer.duration();
+  elapsed.toString(buffer);
+  lcd_setstatus(buffer);
+
+  SERIAL_ECHO_START();
+  SERIAL_ECHOLNPAIR("Print time: ", buffer);
+}
+
+#if ENABLED(SDSUPPORT)
+
+  /**
+   * M32: Select file and start SD Print
+   */
+  inline void gcode_M32() {
+    if (card.sdprinting)
+      stepper.synchronize();
+
+    char* namestartpos = parser.string_arg;
+    const bool call_procedure = parser.boolval('P');
+
+    if (card.cardOK) {
+      card.openFile(namestartpos, true, call_procedure);
+
+      if (parser.seenval('S'))
+        card.setIndex(parser.value_long());
+
+      card.startFileprint();
+
+      // Procedure calls count as normal print time.
+      if (!call_procedure) print_job_timer.start();
+    }
+  }
+
+  #if ENABLED(LONG_FILENAME_HOST_SUPPORT)
+
+    /**
+     * M33: Get the long full path of a file or folder
+     *
+     * Parameters:
+     *   <dospath> Case-insensitive DOS-style path to a file or folder
+     *
+     * Example:
+     *   M33 miscel~1/armchair/armcha~1.gco
+     *
+     * Output:
+     *   /Miscellaneous/Armchair/Armchair.gcode
+     */
+    inline void gcode_M33() {
+      card.printLongPath(parser.string_arg);
+    }
+
+  #endif
+
+  #if ENABLED(SDCARD_SORT_ALPHA) && ENABLED(SDSORT_GCODE)
+    /**
+     * M34: Set SD Card Sorting Options
+     */
+    inline void gcode_M34() {
+      if (parser.seen('S')) card.setSortOn(parser.value_bool());
+      if (parser.seenval('F')) {
+        const int v = parser.value_long();
+        card.setSortFolders(v < 0 ? -1 : v > 0 ? 1 : 0);
+      }
+      //if (parser.seen('R')) card.setSortReverse(parser.value_bool());
+    }
+  #endif // SDCARD_SORT_ALPHA && SDSORT_GCODE
+
+  /**
+   * M928: Start SD Write
+   */
+  inline void gcode_M928() {
+    card.openLogFile(parser.string_arg);
+  }
+
+#endif // SDSUPPORT
+
+/**
+ * Sensitive pin test for M42, M226
+ */
+static bool pin_is_protected(const int8_t pin) {
+  static const int8_t sensitive_pins[] PROGMEM = SENSITIVE_PINS;
+  for (uint8_t i = 0; i < COUNT(sensitive_pins); i++)
+    if (pin == (int8_t)pgm_read_byte(&sensitive_pins[i])) return true;
+  return false;
+}
+
+/**
+ * M42: Change pin status via GCode
+ *
+ *  P<pin>  Pin number (LED if omitted)
+ *  S<byte> Pin status from 0 - 255
+ */
+inline void gcode_M42() {
+  if (!parser.seenval('S')) return;
+  const byte pin_status = parser.value_byte();
+
+  const int pin_number = parser.intval('P', LED_PIN);
+  if (pin_number < 0) return;
+
+  if (pin_is_protected(pin_number)) {
+    SERIAL_ERROR_START();
+    SERIAL_ERRORLNPGM(MSG_ERR_PROTECTED_PIN);
+    return;
+  }
+
+  pinMode(pin_number, OUTPUT);
+  digitalWrite(pin_number, pin_status);
+  analogWrite(pin_number, pin_status);
+
+  #if FAN_COUNT > 0
+    switch (pin_number) {
+      #if HAS_FAN0
+        case FAN_PIN: fanSpeeds[0] = pin_status; break;
+      #endif
+      #if HAS_FAN1
+        case FAN1_PIN: fanSpeeds[1] = pin_status; break;
+      #endif
+      #if HAS_FAN2
+        case FAN2_PIN: fanSpeeds[2] = pin_status; break;
+      #endif
+    }
+  #endif
+}
+
+#if ENABLED(PINS_DEBUGGING)
+
+  #include "pinsDebug.h"
+
+  inline void toggle_pins() {
+    const bool I_flag = parser.boolval('I');
+    const int repeat = parser.intval('R', 1),
+              start = parser.intval('S'),
+              end = parser.intval('E', NUM_DIGITAL_PINS - 1),
+              wait = parser.intval('W', 500);
+
+    for (uint8_t pin = start; pin <= end; pin++) {
+      //report_pin_state_extended(pin, I_flag, false);
+      if (!VALID_PIN(pin)) continue;
+      if (!I_flag && pin_is_protected(pin)) {
+        report_pin_state_extended(pin, I_flag, true, "Untouched ");
+        SERIAL_EOL();
+      }
+      else {
+        report_pin_state_extended(pin, I_flag, true, "Pulsing   ");
+        #if AVR_AT90USB1286_FAMILY // Teensy IDEs don't know about these pins so must use FASTIO
+          if (pin == TEENSY_E2) {
+            SET_OUTPUT(TEENSY_E2);
+            for (int16_t j = 0; j < repeat; j++) {
+              WRITE(TEENSY_E2, LOW);  safe_delay(wait);
+              WRITE(TEENSY_E2, HIGH); safe_delay(wait);
+              WRITE(TEENSY_E2, LOW);  safe_delay(wait);
+            }
+          }
+          else if (pin == TEENSY_E3) {
+            SET_OUTPUT(TEENSY_E3);
+            for (int16_t j = 0; j < repeat; j++) {
+              WRITE(TEENSY_E3, LOW);  safe_delay(wait);
+              WRITE(TEENSY_E3, HIGH); safe_delay(wait);
+              WRITE(TEENSY_E3, LOW);  safe_delay(wait);
+            }
+          }
+          else
+        #endif
+        {
+          pinMode(pin, OUTPUT);
+          for (int16_t j = 0; j < repeat; j++) {
+            digitalWrite(pin, 0); safe_delay(wait);
+            digitalWrite(pin, 1); safe_delay(wait);
+            digitalWrite(pin, 0); safe_delay(wait);
+          }
+        }
+
+      }
+      SERIAL_EOL();
+    }
+    SERIAL_ECHOLNPGM("Done.");
+
+  } // toggle_pins
+
+  inline void servo_probe_test() {
+    #if !(NUM_SERVOS > 0 && HAS_SERVO_0)
+
+      SERIAL_ERROR_START();
+      SERIAL_ERRORLNPGM("SERVO not setup");
+
+    #elif !HAS_Z_SERVO_ENDSTOP
+
+      SERIAL_ERROR_START();
+      SERIAL_ERRORLNPGM("Z_ENDSTOP_SERVO_NR not setup");
+
+    #else // HAS_Z_SERVO_ENDSTOP
+
+      const uint8_t probe_index = parser.byteval('P', Z_ENDSTOP_SERVO_NR);
+
+      SERIAL_PROTOCOLLNPGM("Servo probe test");
+      SERIAL_PROTOCOLLNPAIR(".  using index:  ", probe_index);
+      SERIAL_PROTOCOLLNPAIR(".  deploy angle: ", z_servo_angle[0]);
+      SERIAL_PROTOCOLLNPAIR(".  stow angle:   ", z_servo_angle[1]);
+
+      bool probe_inverting;
+
+      #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
+
+        #define PROBE_TEST_PIN Z_MIN_PIN
+
+        SERIAL_PROTOCOLLNPAIR(". probe uses Z_MIN pin: ", PROBE_TEST_PIN);
+        SERIAL_PROTOCOLLNPGM(". uses Z_MIN_ENDSTOP_INVERTING (ignores Z_MIN_PROBE_ENDSTOP_INVERTING)");
+        SERIAL_PROTOCOLPGM(". Z_MIN_ENDSTOP_INVERTING: ");
+
+        #if Z_MIN_ENDSTOP_INVERTING
+          SERIAL_PROTOCOLLNPGM("true");
+        #else
+          SERIAL_PROTOCOLLNPGM("false");
+        #endif
+
+        probe_inverting = Z_MIN_ENDSTOP_INVERTING;
+
+      #elif ENABLED(Z_MIN_PROBE_ENDSTOP)
+
+        #define PROBE_TEST_PIN Z_MIN_PROBE_PIN
+        SERIAL_PROTOCOLLNPAIR(". probe uses Z_MIN_PROBE_PIN: ", PROBE_TEST_PIN);
+        SERIAL_PROTOCOLLNPGM(". uses Z_MIN_PROBE_ENDSTOP_INVERTING (ignores Z_MIN_ENDSTOP_INVERTING)");
+        SERIAL_PROTOCOLPGM(". Z_MIN_PROBE_ENDSTOP_INVERTING: ");
+
+        #if Z_MIN_PROBE_ENDSTOP_INVERTING
+          SERIAL_PROTOCOLLNPGM("true");
+        #else
+          SERIAL_PROTOCOLLNPGM("false");
+        #endif
+
+        probe_inverting = Z_MIN_PROBE_ENDSTOP_INVERTING;
+
+      #endif
+
+      SERIAL_PROTOCOLLNPGM(". deploy & stow 4 times");
+      SET_INPUT_PULLUP(PROBE_TEST_PIN);
+      bool deploy_state, stow_state;
+      for (uint8_t i = 0; i < 4; i++) {
+        MOVE_SERVO(probe_index, z_servo_angle[0]); //deploy
+        safe_delay(500);
+        deploy_state = READ(PROBE_TEST_PIN);
+        MOVE_SERVO(probe_index, z_servo_angle[1]); //stow
+        safe_delay(500);
+        stow_state = READ(PROBE_TEST_PIN);
+      }
+      if (probe_inverting != deploy_state) SERIAL_PROTOCOLLNPGM("WARNING - INVERTING setting probably backwards");
+
+      refresh_cmd_timeout();
+
+      if (deploy_state != stow_state) {
+        SERIAL_PROTOCOLLNPGM("BLTouch clone detected");
+        if (deploy_state) {
+          SERIAL_PROTOCOLLNPGM(".  DEPLOYED state: HIGH (logic 1)");
+          SERIAL_PROTOCOLLNPGM(".  STOWED (triggered) state: LOW (logic 0)");
+        }
+        else {
+          SERIAL_PROTOCOLLNPGM(".  DEPLOYED state: LOW (logic 0)");
+          SERIAL_PROTOCOLLNPGM(".  STOWED (triggered) state: HIGH (logic 1)");
+        }
+        #if ENABLED(BLTOUCH)
+          SERIAL_PROTOCOLLNPGM("ERROR: BLTOUCH enabled - set this device up as a Z Servo Probe with inverting as true.");
+        #endif
+
+      }
+      else {                                           // measure active signal length
+        MOVE_SERVO(probe_index, z_servo_angle[0]);     // deploy
+        safe_delay(500);
+        SERIAL_PROTOCOLLNPGM("please trigger probe");
+        uint16_t probe_counter = 0;
+
+        // Allow 30 seconds max for operator to trigger probe
+        for (uint16_t j = 0; j < 500 * 30 && probe_counter == 0 ; j++) {
+
+          safe_delay(2);
+
+          if (0 == j % (500 * 1)) // keep cmd_timeout happy
+            refresh_cmd_timeout();
+
+          if (deploy_state != READ(PROBE_TEST_PIN)) { // probe triggered
+
+            for (probe_counter = 1; probe_counter < 50 && deploy_state != READ(PROBE_TEST_PIN); ++probe_counter)
+              safe_delay(2);
+
+            if (probe_counter == 50)
+              SERIAL_PROTOCOLLNPGM("Z Servo Probe detected"); // >= 100mS active time
+            else if (probe_counter >= 2)
+              SERIAL_PROTOCOLLNPAIR("BLTouch compatible probe detected - pulse width (+/- 4mS): ", probe_counter * 2); // allow 4 - 100mS pulse
+            else
+              SERIAL_PROTOCOLLNPGM("noise detected - please re-run test"); // less than 2mS pulse
+
+            MOVE_SERVO(probe_index, z_servo_angle[1]); //stow
+
+          }  // pulse detected
+
+        } // for loop waiting for trigger
+
+        if (probe_counter == 0) SERIAL_PROTOCOLLNPGM("trigger not detected");
+
+      } // measure active signal length
+
+    #endif
+
+  } // servo_probe_test
+
+  /**
+   * M43: Pin debug - report pin state, watch pins, toggle pins and servo probe test/report
+   *
+   *  M43         - report name and state of pin(s)
+   *                  P<pin>  Pin to read or watch. If omitted, reads all pins.
+   *                  I       Flag to ignore Marlin's pin protection.
+   *
+   *  M43 W       - Watch pins -reporting changes- until reset, click, or M108.
+   *                  P<pin>  Pin to read or watch. If omitted, read/watch all pins.
+   *                  I       Flag to ignore Marlin's pin protection.
+   *
+   *  M43 E<bool> - Enable / disable background endstop monitoring
+   *                  - Machine continues to operate
+   *                  - Reports changes to endstops
+   *                  - Toggles LED_PIN when an endstop changes
+   *                  - Can not reliably catch the 5mS pulse from BLTouch type probes
+   *
+   *  M43 T       - Toggle pin(s) and report which pin is being toggled
+   *                  S<pin>  - Start Pin number.   If not given, will default to 0
+   *                  L<pin>  - End Pin number.   If not given, will default to last pin defined for this board
+   *                  I<bool> - Flag to ignore Marlin's pin protection.   Use with caution!!!!
+   *                  R       - Repeat pulses on each pin this number of times before continueing to next pin
+   *                  W       - Wait time (in miliseconds) between pulses.  If not given will default to 500
+   *
+   *  M43 S       - Servo probe test
+   *                  P<index> - Probe index (optional - defaults to 0
+   */
+  inline void gcode_M43() {
+
+    if (parser.seen('T')) {   // must be first or else its "S" and "E" parameters will execute endstop or servo test
+      toggle_pins();
+      return;
+    }
+
+    // Enable or disable endstop monitoring
+    if (parser.seen('E')) {
+      endstop_monitor_flag = parser.value_bool();
+      SERIAL_PROTOCOLPGM("endstop monitor ");
+      serialprintPGM(endstop_monitor_flag ? PSTR("en") : PSTR("dis"));
+      SERIAL_PROTOCOLLNPGM("abled");
+      return;
+    }
+
+    if (parser.seen('S')) {
+      servo_probe_test();
+      return;
+    }
+
+    // Get the range of pins to test or watch
+    const uint8_t first_pin = parser.byteval('P'),
+                  last_pin = parser.seenval('P') ? first_pin : NUM_DIGITAL_PINS - 1;
+
+    if (first_pin > last_pin) return;
+
+    const bool ignore_protection = parser.boolval('I');
+
+    // Watch until click, M108, or reset
+    if (parser.boolval('W')) {
+      SERIAL_PROTOCOLLNPGM("Watching pins");
+      uint8_t pin_state[last_pin - first_pin + 1];
+      for (int8_t pin = first_pin; pin <= last_pin; pin++) {
+        if (!VALID_PIN(pin)) continue;
+        if (pin_is_protected(pin) && !ignore_protection) continue;
+        pinMode(pin, INPUT_PULLUP);
+        delay(1);
+        /*
+          if (IS_ANALOG(pin))
+            pin_state[pin - first_pin] = analogRead(DIGITAL_PIN_TO_ANALOG_PIN(pin)); // int16_t pin_state[...]
+          else
+        //*/
+            pin_state[pin - first_pin] = digitalRead(pin);
+      }
+
+      #if HAS_RESUME_CONTINUE
+        wait_for_user = true;
+        KEEPALIVE_STATE(PAUSED_FOR_USER);
+      #endif
+
+      for (;;) {
+        for (int8_t pin = first_pin; pin <= last_pin; pin++) {
+          if (!VALID_PIN(pin)) continue;
+          if (pin_is_protected(pin) && !ignore_protection) continue;
+          const byte val =
+            /*
+              IS_ANALOG(pin)
+                ? analogRead(DIGITAL_PIN_TO_ANALOG_PIN(pin)) : // int16_t val
+                :
+            //*/
+              digitalRead(pin);
+          if (val != pin_state[pin - first_pin]) {
+            report_pin_state_extended(pin, ignore_protection, false);
+            pin_state[pin - first_pin] = val;
+          }
+        }
+
+        #if HAS_RESUME_CONTINUE
+          if (!wait_for_user) {
+            KEEPALIVE_STATE(IN_HANDLER);
+            break;
+          }
+        #endif
+
+        safe_delay(200);
+      }
+      return;
+    }
+
+    // Report current state of selected pin(s)
+    for (uint8_t pin = first_pin; pin <= last_pin; pin++)
+      if (VALID_PIN(pin)) report_pin_state_extended(pin, ignore_protection, true);
+  }
+
+#endif // PINS_DEBUGGING
+
+#if ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)
+
+  /**
+   * M48: Z probe repeatability measurement function.
+   *
+   * Usage:
+   *   M48 <P#> <X#> <Y#> <V#> <E> <L#>
+   *     P = Number of sampled points (4-50, default 10)
+   *     X = Sample X position
+   *     Y = Sample Y position
+   *     V = Verbose level (0-4, default=1)
+   *     E = Engage Z probe for each reading
+   *     L = Number of legs of movement before probe
+   *     S = Schizoid (Or Star if you prefer)
+   *
+   * This function assumes the bed has been homed.  Specifically, that a G28 command
+   * as been issued prior to invoking the M48 Z probe repeatability measurement function.
+   * Any information generated by a prior G29 Bed leveling command will be lost and need to be
+   * regenerated.
+   */
+  inline void gcode_M48() {
+
+    if (axis_unhomed_error()) return;
+
+    const int8_t verbose_level = parser.byteval('V', 1);
+    if (!WITHIN(verbose_level, 0, 4)) {
+      SERIAL_PROTOCOLLNPGM("?(V)erbose level is implausible (0-4).");
+      return;
+    }
+
+    if (verbose_level > 0)
+      SERIAL_PROTOCOLLNPGM("M48 Z-Probe Repeatability Test");
+
+    const int8_t n_samples = parser.byteval('P', 10);
+    if (!WITHIN(n_samples, 4, 50)) {
+      SERIAL_PROTOCOLLNPGM("?Sample size not plausible (4-50).");
+      return;
+    }
+
+    const bool stow_probe_after_each = parser.boolval('E');
+
+    float X_current = current_position[X_AXIS],
+          Y_current = current_position[Y_AXIS];
+
+    const float X_probe_location = parser.linearval('X', X_current + X_PROBE_OFFSET_FROM_EXTRUDER),
+                Y_probe_location = parser.linearval('Y', Y_current + Y_PROBE_OFFSET_FROM_EXTRUDER);
+
+    #if DISABLED(DELTA)
+      if (!WITHIN(X_probe_location, LOGICAL_X_POSITION(MIN_PROBE_X), LOGICAL_X_POSITION(MAX_PROBE_X))) {
+        out_of_range_error(PSTR("X"));
+        return;
+      }
+      if (!WITHIN(Y_probe_location, LOGICAL_Y_POSITION(MIN_PROBE_Y), LOGICAL_Y_POSITION(MAX_PROBE_Y))) {
+        out_of_range_error(PSTR("Y"));
+        return;
+      }
+    #else
+      if (!position_is_reachable_by_probe_xy(X_probe_location, Y_probe_location)) {
+        SERIAL_PROTOCOLLNPGM("? (X,Y) location outside of probeable radius.");
+        return;
+      }
+    #endif
+
+    bool seen_L = parser.seen('L');
+    uint8_t n_legs = seen_L ? parser.value_byte() : 0;
+    if (n_legs > 15) {
+      SERIAL_PROTOCOLLNPGM("?Number of legs in movement not plausible (0-15).");
+      return;
+    }
+    if (n_legs == 1) n_legs = 2;
+
+    const bool schizoid_flag = parser.boolval('S');
+    if (schizoid_flag && !seen_L) n_legs = 7;
+
+    /**
+     * Now get everything to the specified probe point So we can safely do a
+     * probe to get us close to the bed.  If the Z-Axis is far from the bed,
+     * we don't want to use that as a starting point for each probe.
+     */
+    if (verbose_level > 2)
+      SERIAL_PROTOCOLLNPGM("Positioning the probe...");
+
+    // Disable bed level correction in M48 because we want the raw data when we probe
+
+    #if HAS_LEVELING
+      const bool was_enabled = leveling_is_active();
+      set_bed_leveling_enabled(false);
+    #endif
+
+    setup_for_endstop_or_probe_move();
+
+    double mean = 0.0, sigma = 0.0, min = 99999.9, max = -99999.9, sample_set[n_samples];
+
+    // Move to the first point, deploy, and probe
+    const float t = probe_pt(X_probe_location, Y_probe_location, stow_probe_after_each, verbose_level);
+    bool probing_good = !isnan(t);
+
+    if (probing_good) {
+      randomSeed(millis());
+
+      for (uint8_t n = 0; n < n_samples; n++) {
+        if (n_legs) {
+          const int dir = (random(0, 10) > 5.0) ? -1 : 1;  // clockwise or counter clockwise
+          float angle = random(0.0, 360.0);
+          const float radius = random(
+            #if ENABLED(DELTA)
+              0.1250000000 * (DELTA_PROBEABLE_RADIUS),
+              0.3333333333 * (DELTA_PROBEABLE_RADIUS)
+            #else
+              5.0, 0.125 * min(X_BED_SIZE, Y_BED_SIZE)
+            #endif
+          );
+
+          if (verbose_level > 3) {
+            SERIAL_ECHOPAIR("Starting radius: ", radius);
+            SERIAL_ECHOPAIR("   angle: ", angle);
+            SERIAL_ECHOPGM(" Direction: ");
+            if (dir > 0) SERIAL_ECHOPGM("Counter-");
+            SERIAL_ECHOLNPGM("Clockwise");
+          }
+
+          for (uint8_t l = 0; l < n_legs - 1; l++) {
+            double delta_angle;
+
+            if (schizoid_flag)
+              // The points of a 5 point star are 72 degrees apart.  We need to
+              // skip a point and go to the next one on the star.
+              delta_angle = dir * 2.0 * 72.0;
+
+            else
+              // If we do this line, we are just trying to move further
+              // around the circle.
+              delta_angle = dir * (float) random(25, 45);
+
+            angle += delta_angle;
+
+            while (angle > 360.0)   // We probably do not need to keep the angle between 0 and 2*PI, but the
+              angle -= 360.0;       // Arduino documentation says the trig functions should not be given values
+            while (angle < 0.0)     // outside of this range.   It looks like they behave correctly with
+              angle += 360.0;       // numbers outside of the range, but just to be safe we clamp them.
+
+            X_current = X_probe_location - (X_PROBE_OFFSET_FROM_EXTRUDER) + cos(RADIANS(angle)) * radius;
+            Y_current = Y_probe_location - (Y_PROBE_OFFSET_FROM_EXTRUDER) + sin(RADIANS(angle)) * radius;
+
+            #if DISABLED(DELTA)
+              X_current = constrain(X_current, X_MIN_POS, X_MAX_POS);
+              Y_current = constrain(Y_current, Y_MIN_POS, Y_MAX_POS);
+            #else
+              // If we have gone out too far, we can do a simple fix and scale the numbers
+              // back in closer to the origin.
+              while (!position_is_reachable_by_probe_xy(X_current, Y_current)) {
+                X_current *= 0.8;
+                Y_current *= 0.8;
+                if (verbose_level > 3) {
+                  SERIAL_ECHOPAIR("Pulling point towards center:", X_current);
+                  SERIAL_ECHOLNPAIR(", ", Y_current);
+                }
+              }
+            #endif
+            if (verbose_level > 3) {
+              SERIAL_PROTOCOLPGM("Going to:");
+              SERIAL_ECHOPAIR(" X", X_current);
+              SERIAL_ECHOPAIR(" Y", Y_current);
+              SERIAL_ECHOLNPAIR(" Z", current_position[Z_AXIS]);
+            }
+            do_blocking_move_to_xy(X_current, Y_current);
+          } // n_legs loop
+        } // n_legs
+
+        // Probe a single point
+        sample_set[n] = probe_pt(X_probe_location, Y_probe_location, stow_probe_after_each, 0);
+
+        // Break the loop if the probe fails
+        probing_good = !isnan(sample_set[n]);
+        if (!probing_good) break;
+
+        /**
+         * Get the current mean for the data points we have so far
+         */
+        double sum = 0.0;
+        for (uint8_t j = 0; j <= n; j++) sum += sample_set[j];
+        mean = sum / (n + 1);
+
+        NOMORE(min, sample_set[n]);
+        NOLESS(max, sample_set[n]);
+
+        /**
+         * Now, use that mean to calculate the standard deviation for the
+         * data points we have so far
+         */
+        sum = 0.0;
+        for (uint8_t j = 0; j <= n; j++)
+          sum += sq(sample_set[j] - mean);
+
+        sigma = SQRT(sum / (n + 1));
+        if (verbose_level > 0) {
+          if (verbose_level > 1) {
+            SERIAL_PROTOCOL(n + 1);
+            SERIAL_PROTOCOLPGM(" of ");
+            SERIAL_PROTOCOL((int)n_samples);
+            SERIAL_PROTOCOLPGM(": z: ");
+            SERIAL_PROTOCOL_F(sample_set[n], 3);
+            if (verbose_level > 2) {
+              SERIAL_PROTOCOLPGM(" mean: ");
+              SERIAL_PROTOCOL_F(mean, 4);
+              SERIAL_PROTOCOLPGM(" sigma: ");
+              SERIAL_PROTOCOL_F(sigma, 6);
+              SERIAL_PROTOCOLPGM(" min: ");
+              SERIAL_PROTOCOL_F(min, 3);
+              SERIAL_PROTOCOLPGM(" max: ");
+              SERIAL_PROTOCOL_F(max, 3);
+              SERIAL_PROTOCOLPGM(" range: ");
+              SERIAL_PROTOCOL_F(max-min, 3);
+            }
+            SERIAL_EOL();
+          }
+        }
+
+      } // n_samples loop
+    }
+
+    STOW_PROBE();
+
+    if (probing_good) {
+      SERIAL_PROTOCOLLNPGM("Finished!");
+
+      if (verbose_level > 0) {
+        SERIAL_PROTOCOLPGM("Mean: ");
+        SERIAL_PROTOCOL_F(mean, 6);
+        SERIAL_PROTOCOLPGM(" Min: ");
+        SERIAL_PROTOCOL_F(min, 3);
+        SERIAL_PROTOCOLPGM(" Max: ");
+        SERIAL_PROTOCOL_F(max, 3);
+        SERIAL_PROTOCOLPGM(" Range: ");
+        SERIAL_PROTOCOL_F(max-min, 3);
+        SERIAL_EOL();
+      }
+
+      SERIAL_PROTOCOLPGM("Standard Deviation: ");
+      SERIAL_PROTOCOL_F(sigma, 6);
+      SERIAL_EOL();
+      SERIAL_EOL();
+    }
+
+    clean_up_after_endstop_or_probe_move();
+
+    // Re-enable bed level correction if it had been on
+    #if HAS_LEVELING
+      set_bed_leveling_enabled(was_enabled);
+    #endif
+
+    report_current_position();
+  }
+
+#endif // Z_MIN_PROBE_REPEATABILITY_TEST
+
+#if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(UBL_G26_MESH_VALIDATION)
+
+  inline void gcode_M49() {
+    ubl.g26_debug_flag ^= true;
+    SERIAL_PROTOCOLPGM("UBL Debug Flag turned ");
+    serialprintPGM(ubl.g26_debug_flag ? PSTR("on.") : PSTR("off."));
+  }
+
+#endif // AUTO_BED_LEVELING_UBL && UBL_G26_MESH_VALIDATION
+
+/**
+ * M75: Start print timer
+ */
+inline void gcode_M75() { print_job_timer.start(); }
+
+/**
+ * M76: Pause print timer
+ */
+inline void gcode_M76() { print_job_timer.pause(); }
+
+/**
+ * M77: Stop print timer
+ */
+inline void gcode_M77() { print_job_timer.stop(); }
+
+#if ENABLED(PRINTCOUNTER)
+  /**
+   * M78: Show print statistics
+   */
+  inline void gcode_M78() {
+    // "M78 S78" will reset the statistics
+    if (parser.intval('S') == 78)
+      print_job_timer.initStats();
+    else
+      print_job_timer.showStats();
+  }
+#endif
+
+/**
+ * M104: Set hot end temperature
+ */
+inline void gcode_M104() {
+  if (get_target_extruder_from_command(104)) return;
+  if (DEBUGGING(DRYRUN)) return;
+
+  #if ENABLED(SINGLENOZZLE)
+    if (target_extruder != active_extruder) return;
+  #endif
+
+  if (parser.seenval('S')) {
+    const int16_t temp = parser.value_celsius();
+    thermalManager.setTargetHotend(temp, target_extruder);
+
+    #if ENABLED(DUAL_X_CARRIAGE)
+      if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && target_extruder == 0)
+        thermalManager.setTargetHotend(temp ? temp + duplicate_extruder_temp_offset : 0, 1);
+    #endif
+
+    #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
+      /**
+       * Stop the timer at the end of print. Start is managed by 'heat and wait' M109.
+       * We use half EXTRUDE_MINTEMP here to allow nozzles to be put into hot
+       * standby mode, for instance in a dual extruder setup, without affecting
+       * the running print timer.
+       */
+      if (parser.value_celsius() <= (EXTRUDE_MINTEMP) / 2) {
+        print_job_timer.stop();
+        LCD_MESSAGEPGM(WELCOME_MSG);
+      }
+    #endif
+
+    if (parser.value_celsius() > thermalManager.degHotend(target_extruder))
+      lcd_status_printf_P(0, PSTR("E%i %s"), target_extruder + 1, MSG_HEATING);
+  }
+
+  #if ENABLED(AUTOTEMP)
+    planner.autotemp_M104_M109();
+  #endif
+}
+
+#if HAS_TEMP_HOTEND || HAS_TEMP_BED
+
+  void print_heater_state(const float &c, const float &t,
+    #if ENABLED(SHOW_TEMP_ADC_VALUES)
+      const float r,
+    #endif
+    const int8_t e=-2
+  ) {
+    #if !(HAS_TEMP_BED && HAS_TEMP_HOTEND) && HOTENDS <= 1
+      UNUSED(e);
+    #endif
+
+    SERIAL_PROTOCOLCHAR(' ');
+    SERIAL_PROTOCOLCHAR(
+      #if HAS_TEMP_BED && HAS_TEMP_HOTEND
+        e == -1 ? 'B' : 'T'
+      #elif HAS_TEMP_HOTEND
+        'T'
+      #else
+        'B'
+      #endif
+    );
+    #if HOTENDS > 1
+      if (e >= 0) SERIAL_PROTOCOLCHAR('0' + e);
+    #endif
+    SERIAL_PROTOCOLCHAR(':');
+    SERIAL_PROTOCOL(c);
+    SERIAL_PROTOCOLPAIR(" /" , t);
+    #if ENABLED(SHOW_TEMP_ADC_VALUES)
+      SERIAL_PROTOCOLPAIR(" (", r / OVERSAMPLENR);
+      SERIAL_PROTOCOLCHAR(')');
+    #endif
+  }
+
+  void print_heaterstates() {
+    #if HAS_TEMP_HOTEND
+      print_heater_state(thermalManager.degHotend(target_extruder), thermalManager.degTargetHotend(target_extruder)
+        #if ENABLED(SHOW_TEMP_ADC_VALUES)
+          , thermalManager.rawHotendTemp(target_extruder)
+        #endif
+      );
+    #endif
+    #if HAS_TEMP_BED
+      print_heater_state(thermalManager.degBed(), thermalManager.degTargetBed(),
+        #if ENABLED(SHOW_TEMP_ADC_VALUES)
+          thermalManager.rawBedTemp(),
+        #endif
+        -1 // BED
+      );
+    #endif
+    #if HOTENDS > 1
+      HOTEND_LOOP() print_heater_state(thermalManager.degHotend(e), thermalManager.degTargetHotend(e),
+        #if ENABLED(SHOW_TEMP_ADC_VALUES)
+          thermalManager.rawHotendTemp(e),
+        #endif
+        e
+      );
+    #endif
+    SERIAL_PROTOCOLPGM(" @:");
+    SERIAL_PROTOCOL(thermalManager.getHeaterPower(target_extruder));
+    #if HAS_TEMP_BED
+      SERIAL_PROTOCOLPGM(" B@:");
+      SERIAL_PROTOCOL(thermalManager.getHeaterPower(-1));
+    #endif
+    #if HOTENDS > 1
+      HOTEND_LOOP() {
+        SERIAL_PROTOCOLPAIR(" @", e);
+        SERIAL_PROTOCOLCHAR(':');
+        SERIAL_PROTOCOL(thermalManager.getHeaterPower(e));
+      }
+    #endif
+  }
+#endif
+
+/**
+ * M105: Read hot end and bed temperature
+ */
+inline void gcode_M105() {
+  if (get_target_extruder_from_command(105)) return;
+
+  #if HAS_TEMP_HOTEND || HAS_TEMP_BED
+    SERIAL_PROTOCOLPGM(MSG_OK);
+    print_heaterstates();
+  #else // !HAS_TEMP_HOTEND && !HAS_TEMP_BED
+    SERIAL_ERROR_START();
+    SERIAL_ERRORLNPGM(MSG_ERR_NO_THERMISTORS);
+  #endif
+
+  SERIAL_EOL();
+}
+
+#if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND || HAS_TEMP_BED)
+
+  static uint8_t auto_report_temp_interval;
+  static millis_t next_temp_report_ms;
+
+  /**
+   * M155: Set temperature auto-report interval. M155 S<seconds>
+   */
+  inline void gcode_M155() {
+    if (parser.seenval('S')) {
+      auto_report_temp_interval = parser.value_byte();
+      NOMORE(auto_report_temp_interval, 60);
+      next_temp_report_ms = millis() + 1000UL * auto_report_temp_interval;
+    }
+  }
+
+  inline void auto_report_temperatures() {
+    if (auto_report_temp_interval && ELAPSED(millis(), next_temp_report_ms)) {
+      next_temp_report_ms = millis() + 1000UL * auto_report_temp_interval;
+      print_heaterstates();
+      SERIAL_EOL();
+    }
+  }
+
+#endif // AUTO_REPORT_TEMPERATURES
+
+#if FAN_COUNT > 0
+
+  /**
+   * M106: Set Fan Speed
+   *
+   *  S<int>   Speed between 0-255
+   *  P<index> Fan index, if more than one fan
+   */
+  inline void gcode_M106() {
+    uint16_t s = parser.ushortval('S', 255);
+    NOMORE(s, 255);
+    const uint8_t p = parser.byteval('P', 0);
+    if (p < FAN_COUNT) fanSpeeds[p] = s;
+  }
+
+  /**
+   * M107: Fan Off
+   */
+  inline void gcode_M107() {
+    const uint16_t p = parser.ushortval('P');
+    if (p < FAN_COUNT) fanSpeeds[p] = 0;
+  }
+
+#endif // FAN_COUNT > 0
+
+#if DISABLED(EMERGENCY_PARSER)
+
+  /**
+   * M108: Stop the waiting for heaters in M109, M190, M303. Does not affect the target temperature.
+   */
+  inline void gcode_M108() { wait_for_heatup = false; }
+
+
+  /**
+   * M112: Emergency Stop
+   */
+  inline void gcode_M112() { kill(PSTR(MSG_KILLED)); }
+
+
+  /**
+   * M410: Quickstop - Abort all planned moves
+   *
+   * This will stop the carriages mid-move, so most likely they
+   * will be out of sync with the stepper position after this.
+   */
+  inline void gcode_M410() { quickstop_stepper(); }
+
+#endif
+
+/**
+ * M109: Sxxx Wait for extruder(s) to reach temperature. Waits only when heating.
+ *       Rxxx Wait for extruder(s) to reach temperature. Waits when heating and cooling.
+ */
+
+#ifndef MIN_COOLING_SLOPE_DEG
+  #define MIN_COOLING_SLOPE_DEG 1.50
+#endif
+#ifndef MIN_COOLING_SLOPE_TIME
+  #define MIN_COOLING_SLOPE_TIME 60
+#endif
+
+inline void gcode_M109() {
+
+  if (get_target_extruder_from_command(109)) return;
+  if (DEBUGGING(DRYRUN)) return;
+
+  #if ENABLED(SINGLENOZZLE)
+    if (target_extruder != active_extruder) return;
+  #endif
+
+  const bool no_wait_for_cooling = parser.seenval('S');
+  if (no_wait_for_cooling || parser.seenval('R')) {
+    const int16_t temp = parser.value_celsius();
+    thermalManager.setTargetHotend(temp, target_extruder);
+
+    #if ENABLED(DUAL_X_CARRIAGE)
+      if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && target_extruder == 0)
+        thermalManager.setTargetHotend(temp ? temp + duplicate_extruder_temp_offset : 0, 1);
+    #endif
+
+    #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
+      /**
+       * Use half EXTRUDE_MINTEMP to allow nozzles to be put into hot
+       * standby mode, (e.g., in a dual extruder setup) without affecting
+       * the running print timer.
+       */
+      if (parser.value_celsius() <= (EXTRUDE_MINTEMP) / 2) {
+        print_job_timer.stop();
+        LCD_MESSAGEPGM(WELCOME_MSG);
+      }
+      else
+        print_job_timer.start();
+    #endif
+
+    if (thermalManager.isHeatingHotend(target_extruder)) lcd_status_printf_P(0, PSTR("E%i %s"), target_extruder + 1, MSG_HEATING);
+  }
+  else return;
+
+  #if ENABLED(AUTOTEMP)
+    planner.autotemp_M104_M109();
+  #endif
+
+  #if TEMP_RESIDENCY_TIME > 0
+    millis_t residency_start_ms = 0;
+    // Loop until the temperature has stabilized
+    #define TEMP_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + (TEMP_RESIDENCY_TIME) * 1000UL))
+  #else
+    // Loop until the temperature is very close target
+    #define TEMP_CONDITIONS (wants_to_cool ? thermalManager.isCoolingHotend(target_extruder) : thermalManager.isHeatingHotend(target_extruder))
+  #endif
+
+  float target_temp = -1.0, old_temp = 9999.0;
+  bool wants_to_cool = false;
+  wait_for_heatup = true;
+  millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
+
+  #if DISABLED(BUSY_WHILE_HEATING)
+    KEEPALIVE_STATE(NOT_BUSY);
+  #endif
+
+  #if ENABLED(PRINTER_EVENT_LEDS)
+    const float start_temp = thermalManager.degHotend(target_extruder);
+    uint8_t old_blue = 0;
+  #endif
+
+  do {
+    // Target temperature might be changed during the loop
+    if (target_temp != thermalManager.degTargetHotend(target_extruder)) {
+      wants_to_cool = thermalManager.isCoolingHotend(target_extruder);
+      target_temp = thermalManager.degTargetHotend(target_extruder);
+
+      // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
+      if (no_wait_for_cooling && wants_to_cool) break;
+    }
+
+    now = millis();
+    if (ELAPSED(now, next_temp_ms)) { //Print temp & remaining time every 1s while waiting
+      next_temp_ms = now + 1000UL;
+      print_heaterstates();
+      #if TEMP_RESIDENCY_TIME > 0
+        SERIAL_PROTOCOLPGM(" W:");
+        if (residency_start_ms)
+          SERIAL_PROTOCOL(long((((TEMP_RESIDENCY_TIME) * 1000UL) - (now - residency_start_ms)) / 1000UL));
+        else
+          SERIAL_PROTOCOLCHAR('?');
+      #endif
+      SERIAL_EOL();
+    }
+
+    idle();
+    refresh_cmd_timeout(); // to prevent stepper_inactive_time from running out
+
+    const float temp = thermalManager.degHotend(target_extruder);
+
+    #if ENABLED(PRINTER_EVENT_LEDS)
+      // Gradually change LED strip from violet to red as nozzle heats up
+      if (!wants_to_cool) {
+        const uint8_t blue = map(constrain(temp, start_temp, target_temp), start_temp, target_temp, 255, 0);
+        if (blue != old_blue) {
+          old_blue = blue;
+          set_led_color(255, 0, blue
+            #if ENABLED(NEOPIXEL_RGBW_LED)
+              , 0, true
+            #endif
+          );
+        }
+      }
+    #endif
+
+    #if TEMP_RESIDENCY_TIME > 0
+
+      const float temp_diff = FABS(target_temp - temp);
+
+      if (!residency_start_ms) {
+        // Start the TEMP_RESIDENCY_TIME timer when we reach target temp for the first time.
+        if (temp_diff < TEMP_WINDOW) residency_start_ms = now;
+      }
+      else if (temp_diff > TEMP_HYSTERESIS) {
+        // Restart the timer whenever the temperature falls outside the hysteresis.
+        residency_start_ms = now;
+      }
+
+    #endif
+
+    // Prevent a wait-forever situation if R is misused i.e. M109 R0
+    if (wants_to_cool) {
+      // break after MIN_COOLING_SLOPE_TIME seconds
+      // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG
+      if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
+        if (old_temp - temp < MIN_COOLING_SLOPE_DEG) break;
+        next_cool_check_ms = now + 1000UL * MIN_COOLING_SLOPE_TIME;
+        old_temp = temp;
+      }
+    }
+
+  } while (wait_for_heatup && TEMP_CONDITIONS);
+
+  if (wait_for_heatup) {
+    LCD_MESSAGEPGM(MSG_HEATING_COMPLETE);
+    #if ENABLED(PRINTER_EVENT_LEDS)
+      #if ENABLED(RGBW_LED) || ENABLED(NEOPIXEL_RGBW_LED)
+        set_led_color(0, 0, 0, 255);  // Turn on the WHITE LED
+      #else
+        set_led_color(255, 255, 255); // Set LEDs All On
+      #endif
+    #endif
+  }
+
+  #if DISABLED(BUSY_WHILE_HEATING)
+    KEEPALIVE_STATE(IN_HANDLER);
+  #endif
+}
+
+#if HAS_TEMP_BED
+
+  #ifndef MIN_COOLING_SLOPE_DEG_BED
+    #define MIN_COOLING_SLOPE_DEG_BED 1.50
+  #endif
+  #ifndef MIN_COOLING_SLOPE_TIME_BED
+    #define MIN_COOLING_SLOPE_TIME_BED 60
+  #endif
+
+  /**
+   * M190: Sxxx Wait for bed current temp to reach target temp. Waits only when heating
+   *       Rxxx Wait for bed current temp to reach target temp. Waits when heating and cooling
+   */
+  inline void gcode_M190() {
+    if (DEBUGGING(DRYRUN)) return;
+
+    LCD_MESSAGEPGM(MSG_BED_HEATING);
+    const bool no_wait_for_cooling = parser.seenval('S');
+    if (no_wait_for_cooling || parser.seenval('R')) {
+      thermalManager.setTargetBed(parser.value_celsius());
+      #if ENABLED(PRINTJOB_TIMER_AUTOSTART)
+        if (parser.value_celsius() > BED_MINTEMP)
+          print_job_timer.start();
+      #endif
+    }
+    else return;
+
+    #if TEMP_BED_RESIDENCY_TIME > 0
+      millis_t residency_start_ms = 0;
+      // Loop until the temperature has stabilized
+      #define TEMP_BED_CONDITIONS (!residency_start_ms || PENDING(now, residency_start_ms + (TEMP_BED_RESIDENCY_TIME) * 1000UL))
+    #else
+      // Loop until the temperature is very close target
+      #define TEMP_BED_CONDITIONS (wants_to_cool ? thermalManager.isCoolingBed() : thermalManager.isHeatingBed())
+    #endif
+
+    float target_temp = -1.0, old_temp = 9999.0;
+    bool wants_to_cool = false;
+    wait_for_heatup = true;
+    millis_t now, next_temp_ms = 0, next_cool_check_ms = 0;
+
+    #if DISABLED(BUSY_WHILE_HEATING)
+      KEEPALIVE_STATE(NOT_BUSY);
+    #endif
+
+    target_extruder = active_extruder; // for print_heaterstates
+
+    #if ENABLED(PRINTER_EVENT_LEDS)
+      const float start_temp = thermalManager.degBed();
+      uint8_t old_red = 255;
+    #endif
+
+    do {
+      // Target temperature might be changed during the loop
+      if (target_temp != thermalManager.degTargetBed()) {
+        wants_to_cool = thermalManager.isCoolingBed();
+        target_temp = thermalManager.degTargetBed();
+
+        // Exit if S<lower>, continue if S<higher>, R<lower>, or R<higher>
+        if (no_wait_for_cooling && wants_to_cool) break;
+      }
+
+      now = millis();
+      if (ELAPSED(now, next_temp_ms)) { //Print Temp Reading every 1 second while heating up.
+        next_temp_ms = now + 1000UL;
+        print_heaterstates();
+        #if TEMP_BED_RESIDENCY_TIME > 0
+          SERIAL_PROTOCOLPGM(" W:");
+          if (residency_start_ms)
+            SERIAL_PROTOCOL(long((((TEMP_BED_RESIDENCY_TIME) * 1000UL) - (now - residency_start_ms)) / 1000UL));
+          else
+            SERIAL_PROTOCOLCHAR('?');
+        #endif
+        SERIAL_EOL();
+      }
+
+      idle();
+      refresh_cmd_timeout(); // to prevent stepper_inactive_time from running out
+
+      const float temp = thermalManager.degBed();
+
+      #if ENABLED(PRINTER_EVENT_LEDS)
+        // Gradually change LED strip from blue to violet as bed heats up
+        if (!wants_to_cool) {
+          const uint8_t red = map(constrain(temp, start_temp, target_temp), start_temp, target_temp, 0, 255);
+          if (red != old_red) {
+            old_red = red;
+            set_led_color(red, 0, 255
+              #if ENABLED(NEOPIXEL_RGBW_LED)
+                , 0, true
+              #endif
+            );
+          }
+        }
+      #endif
+
+      #if TEMP_BED_RESIDENCY_TIME > 0
+
+        const float temp_diff = FABS(target_temp - temp);
+
+        if (!residency_start_ms) {
+          // Start the TEMP_BED_RESIDENCY_TIME timer when we reach target temp for the first time.
+          if (temp_diff < TEMP_BED_WINDOW) residency_start_ms = now;
+        }
+        else if (temp_diff > TEMP_BED_HYSTERESIS) {
+          // Restart the timer whenever the temperature falls outside the hysteresis.
+          residency_start_ms = now;
+        }
+
+      #endif // TEMP_BED_RESIDENCY_TIME > 0
+
+      // Prevent a wait-forever situation if R is misused i.e. M190 R0
+      if (wants_to_cool) {
+        // Break after MIN_COOLING_SLOPE_TIME_BED seconds
+        // if the temperature did not drop at least MIN_COOLING_SLOPE_DEG_BED
+        if (!next_cool_check_ms || ELAPSED(now, next_cool_check_ms)) {
+          if (old_temp - temp < MIN_COOLING_SLOPE_DEG_BED) break;
+          next_cool_check_ms = now + 1000UL * MIN_COOLING_SLOPE_TIME_BED;
+          old_temp = temp;
+        }
+      }
+
+    } while (wait_for_heatup && TEMP_BED_CONDITIONS);
+
+    if (wait_for_heatup) LCD_MESSAGEPGM(MSG_BED_DONE);
+    #if DISABLED(BUSY_WHILE_HEATING)
+      KEEPALIVE_STATE(IN_HANDLER);
+    #endif
+  }
+
+#endif // HAS_TEMP_BED
+
+/**
+ * M110: Set Current Line Number
+ */
+inline void gcode_M110() {
+  if (parser.seenval('N')) gcode_LastN = parser.value_long();
+}
+
+/**
+ * M111: Set the debug level
+ */
+inline void gcode_M111() {
+  if (parser.seen('S')) marlin_debug_flags = parser.byteval('S');
+
+  const static char str_debug_1[] PROGMEM = MSG_DEBUG_ECHO,
+                    str_debug_2[] PROGMEM = MSG_DEBUG_INFO,
+                    str_debug_4[] PROGMEM = MSG_DEBUG_ERRORS,
+                    str_debug_8[] PROGMEM = MSG_DEBUG_DRYRUN,
+                    str_debug_16[] PROGMEM = MSG_DEBUG_COMMUNICATION
+                    #if ENABLED(DEBUG_LEVELING_FEATURE)
+                      , str_debug_32[] PROGMEM = MSG_DEBUG_LEVELING
+                    #endif
+                    ;
+
+  const static char* const debug_strings[] PROGMEM = {
+    str_debug_1, str_debug_2, str_debug_4, str_debug_8, str_debug_16
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      , str_debug_32
+    #endif
+  };
+
+  SERIAL_ECHO_START();
+  SERIAL_ECHOPGM(MSG_DEBUG_PREFIX);
+  if (marlin_debug_flags) {
+    uint8_t comma = 0;
+    for (uint8_t i = 0; i < COUNT(debug_strings); i++) {
+      if (TEST(marlin_debug_flags, i)) {
+        if (comma++) SERIAL_CHAR(',');
+        serialprintPGM((char*)pgm_read_word(&debug_strings[i]));
+      }
+    }
+  }
+  else {
+    SERIAL_ECHOPGM(MSG_DEBUG_OFF);
+  }
+  SERIAL_EOL();
+}
+
+#if ENABLED(HOST_KEEPALIVE_FEATURE)
+
+  /**
+   * M113: Get or set Host Keepalive interval (0 to disable)
+   *
+   *   S<seconds> Optional. Set the keepalive interval.
+   */
+  inline void gcode_M113() {
+    if (parser.seenval('S')) {
+      host_keepalive_interval = parser.value_byte();
+      NOMORE(host_keepalive_interval, 60);
+    }
+    else {
+      SERIAL_ECHO_START();
+      SERIAL_ECHOLNPAIR("M113 S", (unsigned long)host_keepalive_interval);
+    }
+  }
+
+#endif
+
+#if ENABLED(BARICUDA)
+
+  #if HAS_HEATER_1
+    /**
+     * M126: Heater 1 valve open
+     */
+    inline void gcode_M126() { baricuda_valve_pressure = parser.byteval('S', 255); }
+    /**
+     * M127: Heater 1 valve close
+     */
+    inline void gcode_M127() { baricuda_valve_pressure = 0; }
+  #endif
+
+  #if HAS_HEATER_2
+    /**
+     * M128: Heater 2 valve open
+     */
+    inline void gcode_M128() { baricuda_e_to_p_pressure = parser.byteval('S', 255); }
+    /**
+     * M129: Heater 2 valve close
+     */
+    inline void gcode_M129() { baricuda_e_to_p_pressure = 0; }
+  #endif
+
+#endif // BARICUDA
+
+/**
+ * M140: Set bed temperature
+ */
+inline void gcode_M140() {
+  if (DEBUGGING(DRYRUN)) return;
+  if (parser.seenval('S')) thermalManager.setTargetBed(parser.value_celsius());
+}
+
+#if ENABLED(ULTIPANEL)
+
+  /**
+   * M145: Set the heatup state for a material in the LCD menu
+   *
+   *   S<material> (0=PLA, 1=ABS)
+   *   H<hotend temp>
+   *   B<bed temp>
+   *   F<fan speed>
+   */
+  inline void gcode_M145() {
+    const uint8_t material = (uint8_t)parser.intval('S');
+    if (material >= COUNT(lcd_preheat_hotend_temp)) {
+      SERIAL_ERROR_START();
+      SERIAL_ERRORLNPGM(MSG_ERR_MATERIAL_INDEX);
+    }
+    else {
+      int v;
+      if (parser.seenval('H')) {
+        v = parser.value_int();
+        lcd_preheat_hotend_temp[material] = constrain(v, EXTRUDE_MINTEMP, HEATER_0_MAXTEMP - 15);
+      }
+      if (parser.seenval('F')) {
+        v = parser.value_int();
+        lcd_preheat_fan_speed[material] = constrain(v, 0, 255);
+      }
+      #if TEMP_SENSOR_BED != 0
+        if (parser.seenval('B')) {
+          v = parser.value_int();
+          lcd_preheat_bed_temp[material] = constrain(v, BED_MINTEMP, BED_MAXTEMP - 15);
+        }
+      #endif
+    }
+  }
+
+#endif // ULTIPANEL
+
+#if ENABLED(TEMPERATURE_UNITS_SUPPORT)
+  /**
+   * M149: Set temperature units
+   */
+  inline void gcode_M149() {
+         if (parser.seenval('C')) parser.set_input_temp_units(TEMPUNIT_C);
+    else if (parser.seenval('K')) parser.set_input_temp_units(TEMPUNIT_K);
+    else if (parser.seenval('F')) parser.set_input_temp_units(TEMPUNIT_F);
+  }
+#endif
+
+#if HAS_POWER_SWITCH
+
+  /**
+   * M80   : Turn on the Power Supply
+   * M80 S : Report the current state and exit
+   */
+  inline void gcode_M80() {
+
+    // S: Report the current power supply state and exit
+    if (parser.seen('S')) {
+      serialprintPGM(powersupply_on ? PSTR("PS:1\n") : PSTR("PS:0\n"));
+      return;
+    }
+
+    OUT_WRITE(PS_ON_PIN, PS_ON_AWAKE); // GND
+
+    /**
+     * If you have a switch on suicide pin, this is useful
+     * if you want to start another print with suicide feature after
+     * a print without suicide...
+     */
+    #if HAS_SUICIDE
+      OUT_WRITE(SUICIDE_PIN, HIGH);
+    #endif
+
+    #if ENABLED(HAVE_TMC2130)
+      delay(100);
+      tmc2130_init(); // Settings only stick when the driver has power
+    #endif
+
+    powersupply_on = true;
+
+    #if ENABLED(ULTIPANEL)
+      LCD_MESSAGEPGM(WELCOME_MSG);
+    #endif
+  }
+
+#endif // HAS_POWER_SWITCH
+
+/**
+ * M81: Turn off Power, including Power Supply, if there is one.
+ *
+ *      This code should ALWAYS be available for EMERGENCY SHUTDOWN!
+ */
+inline void gcode_M81() {
+  thermalManager.disable_all_heaters();
+  stepper.finish_and_disable();
+
+  #if FAN_COUNT > 0
+    for (uint8_t i = 0; i < FAN_COUNT; i++) fanSpeeds[i] = 0;
+    #if ENABLED(PROBING_FANS_OFF)
+      fans_paused = false;
+      ZERO(paused_fanSpeeds);
+    #endif
+  #endif
+
+  safe_delay(1000); // Wait 1 second before switching off
+
+  #if HAS_SUICIDE
+    stepper.synchronize();
+    suicide();
+  #elif HAS_POWER_SWITCH
+    OUT_WRITE(PS_ON_PIN, PS_ON_ASLEEP);
+    powersupply_on = false;
+  #endif
+
+  #if ENABLED(ULTIPANEL)
+    LCD_MESSAGEPGM(MACHINE_NAME " " MSG_OFF ".");
+  #endif
+}
+
+/**
+ * M82: Set E codes absolute (default)
+ */
+inline void gcode_M82() { axis_relative_modes[E_AXIS] = false; }
+
+/**
+ * M83: Set E codes relative while in Absolute Coordinates (G90) mode
+ */
+inline void gcode_M83() { axis_relative_modes[E_AXIS] = true; }
+
+/**
+ * M18, M84: Disable stepper motors
+ */
+inline void gcode_M18_M84() {
+  if (parser.seenval('S')) {
+    stepper_inactive_time = parser.value_millis_from_seconds();
+  }
+  else {
+    bool all_axis = !((parser.seen('X')) || (parser.seen('Y')) || (parser.seen('Z')) || (parser.seen('E')));
+    if (all_axis) {
+      stepper.finish_and_disable();
+    }
+    else {
+      stepper.synchronize();
+      if (parser.seen('X')) disable_X();
+      if (parser.seen('Y')) disable_Y();
+      if (parser.seen('Z')) disable_Z();
+      #if E0_ENABLE_PIN != X_ENABLE_PIN && E1_ENABLE_PIN != Y_ENABLE_PIN // Only enable on boards that have separate ENABLE_PINS
+        if (parser.seen('E')) disable_e_steppers();
+      #endif
+    }
+
+    #if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(ULTRA_LCD)  // Only needed with an LCD
+      ubl_lcd_map_control = defer_return_to_status = false;
+    #endif
+  }
+}
+
+/**
+ * M85: Set inactivity shutdown timer with parameter S<seconds>. To disable set zero (default)
+ */
+inline void gcode_M85() {
+  if (parser.seen('S')) max_inactive_time = parser.value_millis_from_seconds();
+}
+
+/**
+ * Multi-stepper support for M92, M201, M203
+ */
+#if ENABLED(DISTINCT_E_FACTORS)
+  #define GET_TARGET_EXTRUDER(CMD) if (get_target_extruder_from_command(CMD)) return
+  #define TARGET_EXTRUDER target_extruder
+#else
+  #define GET_TARGET_EXTRUDER(CMD) NOOP
+  #define TARGET_EXTRUDER 0
+#endif
+
+/**
+ * M92: Set axis steps-per-unit for one or more axes, X, Y, Z, and E.
+ *      (Follows the same syntax as G92)
+ *
+ *      With multiple extruders use T to specify which one.
+ */
+inline void gcode_M92() {
+
+  GET_TARGET_EXTRUDER(92);
+
+  LOOP_XYZE(i) {
+    if (parser.seen(axis_codes[i])) {
+      if (i == E_AXIS) {
+        const float value = parser.value_per_axis_unit((AxisEnum)(E_AXIS + TARGET_EXTRUDER));
+        if (value < 20.0) {
+          float factor = planner.axis_steps_per_mm[E_AXIS + TARGET_EXTRUDER] / value; // increase e constants if M92 E14 is given for netfab.
+          planner.max_jerk[E_AXIS] *= factor;
+          planner.max_feedrate_mm_s[E_AXIS + TARGET_EXTRUDER] *= factor;
+          planner.max_acceleration_steps_per_s2[E_AXIS + TARGET_EXTRUDER] *= factor;
+        }
+        planner.axis_steps_per_mm[E_AXIS + TARGET_EXTRUDER] = value;
+      }
+      else {
+        planner.axis_steps_per_mm[i] = parser.value_per_axis_unit((AxisEnum)i);
+      }
+    }
+  }
+  planner.refresh_positioning();
+}
+
+/**
+ * Output the current position to serial
+ */
+void report_current_position() {
+  SERIAL_PROTOCOLPGM("X:");
+  SERIAL_PROTOCOL(current_position[X_AXIS]);
+  SERIAL_PROTOCOLPGM(" Y:");
+  SERIAL_PROTOCOL(current_position[Y_AXIS]);
+  SERIAL_PROTOCOLPGM(" Z:");
+  SERIAL_PROTOCOL(current_position[Z_AXIS]);
+  SERIAL_PROTOCOLPGM(" E:");
+  SERIAL_PROTOCOL(current_position[E_AXIS]);
+
+  stepper.report_positions();
+
+  #if IS_SCARA
+    SERIAL_PROTOCOLPAIR("SCARA Theta:", stepper.get_axis_position_degrees(A_AXIS));
+    SERIAL_PROTOCOLLNPAIR("   Psi+Theta:", stepper.get_axis_position_degrees(B_AXIS));
+    SERIAL_EOL();
+  #endif
+}
+
+#ifdef M114_DETAIL
+
+  void report_xyze(const float pos[XYZE], const uint8_t n = 4, const uint8_t precision = 3) {
+    char str[12];
+    for (uint8_t i = 0; i < n; i++) {
+      SERIAL_CHAR(' ');
+      SERIAL_CHAR(axis_codes[i]);
+      SERIAL_CHAR(':');
+      SERIAL_PROTOCOL(dtostrf(pos[i], 8, precision, str));
+    }
+    SERIAL_EOL();
+  }
+
+  inline void report_xyz(const float pos[XYZ]) { report_xyze(pos, 3); }
+
+  void report_current_position_detail() {
+
+    stepper.synchronize();
+
+    SERIAL_PROTOCOLPGM("\nLogical:");
+    report_xyze(current_position);
+
+    SERIAL_PROTOCOLPGM("Raw:    ");
+    const float raw[XYZ] = { RAW_X_POSITION(current_position[X_AXIS]), RAW_Y_POSITION(current_position[Y_AXIS]), RAW_Z_POSITION(current_position[Z_AXIS]) };
+    report_xyz(raw);
+
+    SERIAL_PROTOCOLPGM("Leveled:");
+    float leveled[XYZ] = { current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] };
+    planner.apply_leveling(leveled);
+    report_xyz(leveled);
+
+    SERIAL_PROTOCOLPGM("UnLevel:");
+    float unleveled[XYZ] = { leveled[X_AXIS], leveled[Y_AXIS], leveled[Z_AXIS] };
+    planner.unapply_leveling(unleveled);
+    report_xyz(unleveled);
+
+    #if IS_KINEMATIC
+      #if IS_SCARA
+        SERIAL_PROTOCOLPGM("ScaraK: ");
+      #else
+        SERIAL_PROTOCOLPGM("DeltaK: ");
+      #endif
+      inverse_kinematics(leveled);  // writes delta[]
+      report_xyz(delta);
+    #endif
+
+    SERIAL_PROTOCOLPGM("Stepper:");
+    const float step_count[XYZE] = { stepper.position(X_AXIS), stepper.position(Y_AXIS), stepper.position(Z_AXIS), stepper.position(E_AXIS) };
+    report_xyze(step_count, 4, 0);
+
+    #if IS_SCARA
+      const float deg[XYZ] = {
+        stepper.get_axis_position_degrees(A_AXIS),
+        stepper.get_axis_position_degrees(B_AXIS)
+      };
+      SERIAL_PROTOCOLPGM("Degrees:");
+      report_xyze(deg, 2);
+    #endif
+
+    SERIAL_PROTOCOLPGM("FromStp:");
+    get_cartesian_from_steppers();  // writes cartes[XYZ] (with forward kinematics)
+    const float from_steppers[XYZE] = { cartes[X_AXIS], cartes[Y_AXIS], cartes[Z_AXIS], stepper.get_axis_position_mm(E_AXIS) };
+    report_xyze(from_steppers);
+
+    const float diff[XYZE] = {
+      from_steppers[X_AXIS] - leveled[X_AXIS],
+      from_steppers[Y_AXIS] - leveled[Y_AXIS],
+      from_steppers[Z_AXIS] - leveled[Z_AXIS],
+      from_steppers[E_AXIS] - current_position[E_AXIS]
+    };
+    SERIAL_PROTOCOLPGM("Differ: ");
+    report_xyze(diff);
+  }
+#endif // M114_DETAIL
+
+/**
+ * M114: Report current position to host
+ */
+inline void gcode_M114() {
+
+  #ifdef M114_DETAIL
+    if (parser.seen('D')) {
+      report_current_position_detail();
+      return;
+    }
+  #endif
+
+  stepper.synchronize();
+  report_current_position();
+}
+
+/**
+ * M115: Capabilities string
+ */
+inline void gcode_M115() {
+  SERIAL_PROTOCOLLNPGM(MSG_M115_REPORT);
+
+  #if ENABLED(EXTENDED_CAPABILITIES_REPORT)
+
+    // EEPROM (M500, M501)
+    #if ENABLED(EEPROM_SETTINGS)
+      SERIAL_PROTOCOLLNPGM("Cap:EEPROM:1");
+    #else
+      SERIAL_PROTOCOLLNPGM("Cap:EEPROM:0");
+    #endif
+
+    // AUTOREPORT_TEMP (M155)
+    #if ENABLED(AUTO_REPORT_TEMPERATURES)
+      SERIAL_PROTOCOLLNPGM("Cap:AUTOREPORT_TEMP:1");
+    #else
+      SERIAL_PROTOCOLLNPGM("Cap:AUTOREPORT_TEMP:0");
+    #endif
+
+    // PROGRESS (M530 S L, M531 <file>, M532 X L)
+    SERIAL_PROTOCOLLNPGM("Cap:PROGRESS:0");
+
+    // Print Job timer M75, M76, M77
+    SERIAL_PROTOCOLLNPGM("Cap:PRINT_JOB:1");
+
+    // AUTOLEVEL (G29)
+    #if HAS_ABL
+      SERIAL_PROTOCOLLNPGM("Cap:AUTOLEVEL:1");
+    #else
+      SERIAL_PROTOCOLLNPGM("Cap:AUTOLEVEL:0");
+    #endif
+
+    // Z_PROBE (G30)
+    #if HAS_BED_PROBE
+      SERIAL_PROTOCOLLNPGM("Cap:Z_PROBE:1");
+    #else
+      SERIAL_PROTOCOLLNPGM("Cap:Z_PROBE:0");
+    #endif
+
+    // MESH_REPORT (M420 V)
+    #if HAS_LEVELING
+      SERIAL_PROTOCOLLNPGM("Cap:LEVELING_DATA:1");
+    #else
+      SERIAL_PROTOCOLLNPGM("Cap:LEVELING_DATA:0");
+    #endif
+
+    // SOFTWARE_POWER (M80, M81)
+    #if HAS_POWER_SWITCH
+      SERIAL_PROTOCOLLNPGM("Cap:SOFTWARE_POWER:1");
+    #else
+      SERIAL_PROTOCOLLNPGM("Cap:SOFTWARE_POWER:0");
+    #endif
+
+    // CASE LIGHTS (M355)
+    #if HAS_CASE_LIGHT
+      SERIAL_PROTOCOLLNPGM("Cap:TOGGLE_LIGHTS:1");
+      if (USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN)) {
+        SERIAL_PROTOCOLLNPGM("Cap:CASE_LIGHT_BRIGHTNESS:1");
+      }
+      else
+        SERIAL_PROTOCOLLNPGM("Cap:CASE_LIGHT_BRIGHTNESS:0");
+    #else
+      SERIAL_PROTOCOLLNPGM("Cap:TOGGLE_LIGHTS:0");
+      SERIAL_PROTOCOLLNPGM("Cap:CASE_LIGHT_BRIGHTNESS:0");
+    #endif
+
+    // EMERGENCY_PARSER (M108, M112, M410)
+    #if ENABLED(EMERGENCY_PARSER)
+      SERIAL_PROTOCOLLNPGM("Cap:EMERGENCY_PARSER:1");
+    #else
+      SERIAL_PROTOCOLLNPGM("Cap:EMERGENCY_PARSER:0");
+    #endif
+
+  #endif // EXTENDED_CAPABILITIES_REPORT
+}
+
+/**
+ * M117: Set LCD Status Message
+ */
+inline void gcode_M117() { lcd_setstatus(parser.string_arg); }
+
+/**
+ * M118: Display a message in the host console.
+ *
+ *  A  Append '// ' for an action command, as in OctoPrint
+ *  E  Have the host 'echo:' the text
+ */
+inline void gcode_M118() {
+  if (parser.boolval('E')) SERIAL_ECHO_START();
+  if (parser.boolval('A')) SERIAL_ECHOPGM("// ");
+  SERIAL_ECHOLN(parser.string_arg);
+}
+
+/**
+ * M119: Output endstop states to serial output
+ */
+inline void gcode_M119() { endstops.M119(); }
+
+/**
+ * M120: Enable endstops and set non-homing endstop state to "enabled"
+ */
+inline void gcode_M120() { endstops.enable_globally(true); }
+
+/**
+ * M121: Disable endstops and set non-homing endstop state to "disabled"
+ */
+inline void gcode_M121() { endstops.enable_globally(false); }
+
+#if ENABLED(PARK_HEAD_ON_PAUSE)
+
+  /**
+   * M125: Store current position and move to filament change position.
+   *       Called on pause (by M25) to prevent material leaking onto the
+   *       object. On resume (M24) the head will be moved back and the
+   *       print will resume.
+   *
+   *       If Marlin is compiled without SD Card support, M125 can be
+   *       used directly to pause the print and move to park position,
+   *       resuming with a button click or M108.
+   *
+   *    L = override retract length
+   *    X = override X
+   *    Y = override Y
+   *    Z = override Z raise
+   */
+  inline void gcode_M125() {
+
+    // Initial retract before move to filament change position
+    const float retract = parser.seen('L') ? parser.value_axis_units(E_AXIS) : 0
+      #ifdef PAUSE_PARK_RETRACT_LENGTH
+        - (PAUSE_PARK_RETRACT_LENGTH)
+      #endif
+    ;
+
+    // Lift Z axis
+    const float z_lift = parser.linearval('Z')
+      #ifdef PAUSE_PARK_Z_ADD
+        + PAUSE_PARK_Z_ADD
+      #endif
+    ;
+
+    // Move XY axes to filament change position or given position
+    const float x_pos = parser.linearval('X')
+      #ifdef PAUSE_PARK_X_POS
+        + PAUSE_PARK_X_POS
+      #endif
+      #if HOTENDS > 1 && DISABLED(DUAL_X_CARRIAGE)
+        + (active_extruder ? hotend_offset[X_AXIS][active_extruder] : 0)
+      #endif
+    ;
+    const float y_pos = parser.linearval('Y')
+      #ifdef PAUSE_PARK_Y_POS
+        + PAUSE_PARK_Y_POS
+      #endif
+      #if HOTENDS > 1 && DISABLED(DUAL_X_CARRIAGE)
+        + (active_extruder ? hotend_offset[Y_AXIS][active_extruder] : 0)
+      #endif
+    ;
+
+    #if DISABLED(SDSUPPORT)
+      const bool job_running = print_job_timer.isRunning();
+    #endif
+
+    if (pause_print(retract, z_lift, x_pos, y_pos)) {
+      #if DISABLED(SDSUPPORT)
+        // Wait for lcd click or M108
+        wait_for_filament_reload();
+
+        // Return to print position and continue
+        resume_print();
+
+        if (job_running) print_job_timer.start();
+      #endif
+    }
+  }
+
+#endif // PARK_HEAD_ON_PAUSE
+
+#if HAS_COLOR_LEDS
+
+  /**
+   * M150: Set Status LED Color - Use R-U-B-W for R-G-B-W
+   *
+   * Always sets all 3 or 4 components. If a component is left out, set to 0.
+   *
+   * Examples:
+   *
+   *   M150 R255       ; Turn LED red
+   *   M150 R255 U127  ; Turn LED orange (PWM only)
+   *   M150            ; Turn LED off
+   *   M150 R U B      ; Turn LED white
+   *   M150 W          ; Turn LED white using a white LED
+   *
+   */
+  inline void gcode_M150() {
+    set_led_color(
+      parser.seen('R') ? (parser.has_value() ? parser.value_byte() : 255) : 0,
+      parser.seen('U') ? (parser.has_value() ? parser.value_byte() : 255) : 0,
+      parser.seen('B') ? (parser.has_value() ? parser.value_byte() : 255) : 0
+      #if ENABLED(RGBW_LED) || ENABLED(NEOPIXEL_RGBW_LED)
+        , parser.seen('W') ? (parser.has_value() ? parser.value_byte() : 255) : 0
+      #endif
+    );
+  }
+
+#endif // HAS_COLOR_LEDS
+
+/**
+ * M200: Set filament diameter and set E axis units to cubic units
+ *
+ *    T<extruder> - Optional extruder number. Current extruder if omitted.
+ *    D<linear> - Diameter of the filament. Use "D0" to switch back to linear units on the E axis.
+ */
+inline void gcode_M200() {
+
+  if (get_target_extruder_from_command(200)) return;
+
+  if (parser.seen('D')) {
+    // setting any extruder filament size disables volumetric on the assumption that
+    // slicers either generate in extruder values as cubic mm or as as filament feeds
+    // for all extruders
+    volumetric_enabled = (parser.value_linear_units() != 0.0);
+    if (volumetric_enabled) {
+      filament_size[target_extruder] = parser.value_linear_units();
+      // make sure all extruders have some sane value for the filament size
+      for (uint8_t i = 0; i < COUNT(filament_size); i++)
+        if (! filament_size[i]) filament_size[i] = DEFAULT_NOMINAL_FILAMENT_DIA;
+    }
+  }
+  calculate_volumetric_multipliers();
+}
+
+/**
+ * M201: Set max acceleration in units/s^2 for print moves (M201 X1000 Y1000)
+ *
+ *       With multiple extruders use T to specify which one.
+ */
+inline void gcode_M201() {
+
+  GET_TARGET_EXTRUDER(201);
+
+  LOOP_XYZE(i) {
+    if (parser.seen(axis_codes[i])) {
+      const uint8_t a = i + (i == E_AXIS ? TARGET_EXTRUDER : 0);
+      planner.max_acceleration_mm_per_s2[a] = parser.value_axis_units((AxisEnum)a);
+    }
+  }
+  // steps per sq second need to be updated to agree with the units per sq second (as they are what is used in the planner)
+  planner.reset_acceleration_rates();
+}
+
+#if 0 // Not used for Sprinter/grbl gen6
+  inline void gcode_M202() {
+    LOOP_XYZE(i) {
+      if (parser.seen(axis_codes[i])) axis_travel_steps_per_sqr_second[i] = parser.value_axis_units((AxisEnum)i) * planner.axis_steps_per_mm[i];
+    }
+  }
+#endif
+
+
+/**
+ * M203: Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in units/sec
+ *
+ *       With multiple extruders use T to specify which one.
+ */
+inline void gcode_M203() {
+
+  GET_TARGET_EXTRUDER(203);
+
+  LOOP_XYZE(i)
+    if (parser.seen(axis_codes[i])) {
+      const uint8_t a = i + (i == E_AXIS ? TARGET_EXTRUDER : 0);
+      planner.max_feedrate_mm_s[a] = parser.value_axis_units((AxisEnum)a);
+    }
+}
+
+/**
+ * M204: Set Accelerations in units/sec^2 (M204 P1200 R3000 T3000)
+ *
+ *    P = Printing moves
+ *    R = Retract only (no X, Y, Z) moves
+ *    T = Travel (non printing) moves
+ *
+ *  Also sets minimum segment time in ms (B20000) to prevent buffer under-runs and M20 minimum feedrate
+ */
+inline void gcode_M204() {
+  if (parser.seen('S')) {  // Kept for legacy compatibility. Should NOT BE USED for new developments.
+    planner.travel_acceleration = planner.acceleration = parser.value_linear_units();
+    SERIAL_ECHOLNPAIR("Setting Print and Travel Acceleration: ", planner.acceleration);
+  }
+  if (parser.seen('P')) {
+    planner.acceleration = parser.value_linear_units();
+    SERIAL_ECHOLNPAIR("Setting Print Acceleration: ", planner.acceleration);
+  }
+  if (parser.seen('R')) {
+    planner.retract_acceleration = parser.value_linear_units();
+    SERIAL_ECHOLNPAIR("Setting Retract Acceleration: ", planner.retract_acceleration);
+  }
+  if (parser.seen('T')) {
+    planner.travel_acceleration = parser.value_linear_units();
+    SERIAL_ECHOLNPAIR("Setting Travel Acceleration: ", planner.travel_acceleration);
+  }
+}
+
+/**
+ * M205: Set Advanced Settings
+ *
+ *    S = Min Feed Rate (units/s)
+ *    T = Min Travel Feed Rate (units/s)
+ *    B = Min Segment Time (µs)
+ *    X = Max X Jerk (units/sec^2)
+ *    Y = Max Y Jerk (units/sec^2)
+ *    Z = Max Z Jerk (units/sec^2)
+ *    E = Max E Jerk (units/sec^2)
+ */
+inline void gcode_M205() {
+  if (parser.seen('S')) planner.min_feedrate_mm_s = parser.value_linear_units();
+  if (parser.seen('T')) planner.min_travel_feedrate_mm_s = parser.value_linear_units();
+  if (parser.seen('B')) planner.min_segment_time = parser.value_millis();
+  if (parser.seen('X')) planner.max_jerk[X_AXIS] = parser.value_linear_units();
+  if (parser.seen('Y')) planner.max_jerk[Y_AXIS] = parser.value_linear_units();
+  if (parser.seen('Z')) planner.max_jerk[Z_AXIS] = parser.value_linear_units();
+  if (parser.seen('E')) planner.max_jerk[E_AXIS] = parser.value_linear_units();
+}
+
+#if HAS_M206_COMMAND
+
+  /**
+   * M206: Set Additional Homing Offset (X Y Z). SCARA aliases T=X, P=Y
+   *
+   * *** @thinkyhead: I recommend deprecating M206 for SCARA in favor of M665.
+   * ***              M206 for SCARA will remain enabled in 1.1.x for compatibility.
+   * ***              In the 2.0 release, it will simply be disabled by default.
+   */
+  inline void gcode_M206() {
+    LOOP_XYZ(i)
+      if (parser.seen(axis_codes[i]))
+        set_home_offset((AxisEnum)i, parser.value_linear_units());
+
+    #if ENABLED(MORGAN_SCARA)
+      if (parser.seen('T')) set_home_offset(A_AXIS, parser.value_linear_units()); // Theta
+      if (parser.seen('P')) set_home_offset(B_AXIS, parser.value_linear_units()); // Psi
+    #endif
+
+    SYNC_PLAN_POSITION_KINEMATIC();
+    report_current_position();
+  }
+
+#endif // HAS_M206_COMMAND
+
+#if ENABLED(DELTA)
+  /**
+   * M665: Set delta configurations
+   *
+   *    H = delta height
+   *    L = diagonal rod
+   *    R = delta radius
+   *    S = segments per second
+   *    B = delta calibration radius
+   *    X = Alpha (Tower 1) angle trim
+   *    Y = Beta (Tower 2) angle trim
+   *    Z = Rotate A and B by this angle
+   */
+  inline void gcode_M665() {
+    if (parser.seen('H')) {
+      home_offset[Z_AXIS] = parser.value_linear_units() - DELTA_HEIGHT;
+      update_software_endstops(Z_AXIS);
+    }
+    if (parser.seen('L')) delta_diagonal_rod             = parser.value_linear_units();
+    if (parser.seen('R')) delta_radius                   = parser.value_linear_units();
+    if (parser.seen('S')) delta_segments_per_second      = parser.value_float();
+    if (parser.seen('B')) delta_calibration_radius       = parser.value_float();
+    if (parser.seen('X')) delta_tower_angle_trim[A_AXIS] = parser.value_float();
+    if (parser.seen('Y')) delta_tower_angle_trim[B_AXIS] = parser.value_float();
+    if (parser.seen('Z')) { // rotate all 3 axis for Z = 0
+      delta_tower_angle_trim[A_AXIS] -= parser.value_float();
+      delta_tower_angle_trim[B_AXIS] -= parser.value_float();
+    }
+    recalc_delta_settings(delta_radius, delta_diagonal_rod);
+  }
+  /**
+   * M666: Set delta endstop adjustment
+   */
+  inline void gcode_M666() {
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) {
+        SERIAL_ECHOLNPGM(">>> gcode_M666");
+      }
+    #endif
+    LOOP_XYZ(i) {
+      if (parser.seen(axis_codes[i])) {
+        endstop_adj[i] = parser.value_linear_units();
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) {
+            SERIAL_ECHOPAIR("endstop_adj[", axis_codes[i]);
+            SERIAL_ECHOLNPAIR("] = ", endstop_adj[i]);
+          }
+        #endif
+      }
+    }
+    #if ENABLED(DEBUG_LEVELING_FEATURE)
+      if (DEBUGGING(LEVELING)) {
+        SERIAL_ECHOLNPGM("<<< gcode_M666");
+      }
+    #endif
+    // normalize endstops so all are <=0; set the residue to delta height
+    const float z_temp = MAX3(endstop_adj[A_AXIS], endstop_adj[B_AXIS], endstop_adj[C_AXIS]);
+    home_offset[Z_AXIS] -= z_temp;
+    LOOP_XYZ(i) endstop_adj[i] -= z_temp;
+  }
+
+#elif IS_SCARA
+
+  /**
+   * M665: Set SCARA settings
+   *
+   * Parameters:
+   *
+   *   S[segments-per-second] - Segments-per-second
+   *   P[theta-psi-offset]    - Theta-Psi offset, added to the shoulder (A/X) angle
+   *   T[theta-offset]        - Theta     offset, added to the elbow    (B/Y) angle
+   *
+   *   A, P, and X are all aliases for the shoulder angle
+   *   B, T, and Y are all aliases for the elbow angle
+   */
+  inline void gcode_M665() {
+    if (parser.seen('S')) delta_segments_per_second = parser.value_float();
+
+    const bool hasA = parser.seen('A'), hasP = parser.seen('P'), hasX = parser.seen('X');
+    const uint8_t sumAPX = hasA + hasP + hasX;
+    if (sumAPX == 1)
+      home_offset[A_AXIS] = parser.value_float();
+    else if (sumAPX > 1) {
+      SERIAL_ERROR_START();
+      SERIAL_ERRORLNPGM("Only one of A, P, or X is allowed.");
+      return;
+    }
+
+    const bool hasB = parser.seen('B'), hasT = parser.seen('T'), hasY = parser.seen('Y');
+    const uint8_t sumBTY = hasB + hasT + hasY;
+    if (sumBTY == 1)
+      home_offset[B_AXIS] = parser.value_float();
+    else if (sumBTY > 1) {
+      SERIAL_ERROR_START();
+      SERIAL_ERRORLNPGM("Only one of B, T, or Y is allowed.");
+      return;
+    }
+  }
+
+#elif ENABLED(Z_DUAL_ENDSTOPS) // !DELTA && ENABLED(Z_DUAL_ENDSTOPS)
+
+  /**
+   * M666: For Z Dual Endstop setup, set z axis offset to the z2 axis.
+   */
+  inline void gcode_M666() {
+    if (parser.seen('Z')) z_endstop_adj = parser.value_linear_units();
+    SERIAL_ECHOLNPAIR("Z Endstop Adjustment set to (mm):", z_endstop_adj);
+  }
+
+#endif // !DELTA && Z_DUAL_ENDSTOPS
+
+#if ENABLED(FWRETRACT)
+
+  /**
+   * M207: Set firmware retraction values
+   *
+   *   S[+units]    retract_length
+   *   W[+units]    swap_retract_length (multi-extruder)
+   *   F[units/min] retract_feedrate_mm_s
+   *   Z[units]     retract_zlift
+   */
+  inline void gcode_M207() {
+    if (parser.seen('S')) retract_length = parser.value_axis_units(E_AXIS);
+    if (parser.seen('F')) retract_feedrate_mm_s = MMM_TO_MMS(parser.value_axis_units(E_AXIS));
+    if (parser.seen('Z')) retract_zlift = parser.value_linear_units();
+    if (parser.seen('W')) swap_retract_length = parser.value_axis_units(E_AXIS);
+  }
+
+  /**
+   * M208: Set firmware un-retraction values
+   *
+   *   S[+units]    retract_recover_length (in addition to M207 S*)
+   *   W[+units]    swap_retract_recover_length (multi-extruder)
+   *   F[units/min] retract_recover_feedrate_mm_s
+   *   R[units/min] swap_retract_recover_feedrate_mm_s
+   */
+  inline void gcode_M208() {
+    if (parser.seen('S')) retract_recover_length = parser.value_axis_units(E_AXIS);
+    if (parser.seen('F')) retract_recover_feedrate_mm_s = MMM_TO_MMS(parser.value_axis_units(E_AXIS));
+    if (parser.seen('R')) swap_retract_recover_feedrate_mm_s = MMM_TO_MMS(parser.value_axis_units(E_AXIS));
+    if (parser.seen('W')) swap_retract_recover_length = parser.value_axis_units(E_AXIS);
+  }
+
+  /**
+   * M209: Enable automatic retract (M209 S1)
+   *   For slicers that don't support G10/11, reversed extrude-only
+   *   moves will be classified as retraction.
+   */
+  inline void gcode_M209() {
+    if (MIN_AUTORETRACT <= MAX_AUTORETRACT) {
+      if (parser.seen('S')) {
+        autoretract_enabled = parser.value_bool();
+        for (uint8_t i = 0; i < EXTRUDERS; i++) retracted[i] = false;
+      }
+    }
+  }
+
+#endif // FWRETRACT
+
+/**
+ * M211: Enable, Disable, and/or Report software endstops
+ *
+ * Usage: M211 S1 to enable, M211 S0 to disable, M211 alone for report
+ */
+inline void gcode_M211() {
+  SERIAL_ECHO_START();
+  #if HAS_SOFTWARE_ENDSTOPS
+    if (parser.seen('S')) soft_endstops_enabled = parser.value_bool();
+    SERIAL_ECHOPGM(MSG_SOFT_ENDSTOPS);
+    serialprintPGM(soft_endstops_enabled ? PSTR(MSG_ON) : PSTR(MSG_OFF));
+  #else
+    SERIAL_ECHOPGM(MSG_SOFT_ENDSTOPS);
+    SERIAL_ECHOPGM(MSG_OFF);
+  #endif
+  SERIAL_ECHOPGM(MSG_SOFT_MIN);
+  SERIAL_ECHOPAIR(    MSG_X, soft_endstop_min[X_AXIS]);
+  SERIAL_ECHOPAIR(" " MSG_Y, soft_endstop_min[Y_AXIS]);
+  SERIAL_ECHOPAIR(" " MSG_Z, soft_endstop_min[Z_AXIS]);
+  SERIAL_ECHOPGM(MSG_SOFT_MAX);
+  SERIAL_ECHOPAIR(    MSG_X, soft_endstop_max[X_AXIS]);
+  SERIAL_ECHOPAIR(" " MSG_Y, soft_endstop_max[Y_AXIS]);
+  SERIAL_ECHOLNPAIR(" " MSG_Z, soft_endstop_max[Z_AXIS]);
+}
+
+#if HOTENDS > 1
+
+  /**
+   * M218 - set hotend offset (in linear units)
+   *
+   *   T<tool>
+   *   X<xoffset>
+   *   Y<yoffset>
+   *   Z<zoffset> - Available with DUAL_X_CARRIAGE and SWITCHING_NOZZLE
+   */
+  inline void gcode_M218() {
+    if (get_target_extruder_from_command(218) || target_extruder == 0) return;
+
+    if (parser.seenval('X')) hotend_offset[X_AXIS][target_extruder] = parser.value_linear_units();
+    if (parser.seenval('Y')) hotend_offset[Y_AXIS][target_extruder] = parser.value_linear_units();
+
+    #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(SWITCHING_NOZZLE) || ENABLED(PARKING_EXTRUDER)
+      if (parser.seenval('Z')) hotend_offset[Z_AXIS][target_extruder] = parser.value_linear_units();
+    #endif
+
+    SERIAL_ECHO_START();
+    SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);
+    HOTEND_LOOP() {
+      SERIAL_CHAR(' ');
+      SERIAL_ECHO(hotend_offset[X_AXIS][e]);
+      SERIAL_CHAR(',');
+      SERIAL_ECHO(hotend_offset[Y_AXIS][e]);
+      #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(SWITCHING_NOZZLE) || ENABLED(PARKING_EXTRUDER)
+        SERIAL_CHAR(',');
+        SERIAL_ECHO(hotend_offset[Z_AXIS][e]);
+      #endif
+    }
+    SERIAL_EOL();
+  }
+
+#endif // HOTENDS > 1
+
+/**
+ * M220: Set speed percentage factor, aka "Feed Rate" (M220 S95)
+ */
+inline void gcode_M220() {
+  if (parser.seenval('S')) feedrate_percentage = parser.value_int();
+}
+
+/**
+ * M221: Set extrusion percentage (M221 T0 S95)
+ */
+inline void gcode_M221() {
+  if (get_target_extruder_from_command(221)) return;
+  if (parser.seenval('S'))
+    flow_percentage[target_extruder] = parser.value_int();
+}
+
+/**
+ * M226: Wait until the specified pin reaches the state required (M226 P<pin> S<state>)
+ */
+inline void gcode_M226() {
+  if (parser.seen('P')) {
+    const int pin_number = parser.value_int(),
+              pin_state = parser.intval('S', -1); // required pin state - default is inverted
+
+    if (WITHIN(pin_state, -1, 1) && pin_number > -1 && !pin_is_protected(pin_number)) {
+
+      int target = LOW;
+
+      stepper.synchronize();
+
+      pinMode(pin_number, INPUT);
+      switch (pin_state) {
+        case 1:
+          target = HIGH;
+          break;
+        case 0:
+          target = LOW;
+          break;
+        case -1:
+          target = !digitalRead(pin_number);
+          break;
+      }
+
+      while (digitalRead(pin_number) != target) idle();
+
+    } // pin_state -1 0 1 && pin_number > -1
+  } // parser.seen('P')
+}
+
+#if ENABLED(EXPERIMENTAL_I2CBUS)
+
+  /**
+   * M260: Send data to a I2C slave device
+   *
+   * This is a PoC, the formating and arguments for the GCODE will
+   * change to be more compatible, the current proposal is:
+   *
+   *  M260 A<slave device address base 10> ; Sets the I2C slave address the data will be sent to
+   *
+   *  M260 B<byte-1 value in base 10>
+   *  M260 B<byte-2 value in base 10>
+   *  M260 B<byte-3 value in base 10>
+   *
+   *  M260 S1 ; Send the buffered data and reset the buffer
+   *  M260 R1 ; Reset the buffer without sending data
+   *
+   */
+  inline void gcode_M260() {
+    // Set the target address
+    if (parser.seen('A')) i2c.address(parser.value_byte());
+
+    // Add a new byte to the buffer
+    if (parser.seen('B')) i2c.addbyte(parser.value_byte());
+
+    // Flush the buffer to the bus
+    if (parser.seen('S')) i2c.send();
+
+    // Reset and rewind the buffer
+    else if (parser.seen('R')) i2c.reset();
+  }
+
+  /**
+   * M261: Request X bytes from I2C slave device
+   *
+   * Usage: M261 A<slave device address base 10> B<number of bytes>
+   */
+  inline void gcode_M261() {
+    if (parser.seen('A')) i2c.address(parser.value_byte());
+
+    uint8_t bytes = parser.byteval('B', 1);
+
+    if (i2c.addr && bytes && bytes <= TWIBUS_BUFFER_SIZE) {
+      i2c.relay(bytes);
+    }
+    else {
+      SERIAL_ERROR_START();
+      SERIAL_ERRORLN("Bad i2c request");
+    }
+  }
+
+#endif // EXPERIMENTAL_I2CBUS
+
+#if HAS_SERVOS
+
+  /**
+   * M280: Get or set servo position. P<index> [S<angle>]
+   */
+  inline void gcode_M280() {
+    if (!parser.seen('P')) return;
+    const int servo_index = parser.value_int();
+    if (WITHIN(servo_index, 0, NUM_SERVOS - 1)) {
+      if (parser.seen('S'))
+        MOVE_SERVO(servo_index, parser.value_int());
+      else {
+        SERIAL_ECHO_START();
+        SERIAL_ECHOPAIR(" Servo ", servo_index);
+        SERIAL_ECHOLNPAIR(": ", servo[servo_index].read());
+      }
+    }
+    else {
+      SERIAL_ERROR_START();
+      SERIAL_ECHOPAIR("Servo ", servo_index);
+      SERIAL_ECHOLNPGM(" out of range");
+    }
+  }
+
+#endif // HAS_SERVOS
+
+#if HAS_BUZZER
+
+  /**
+   * M300: Play beep sound S<frequency Hz> P<duration ms>
+   */
+  inline void gcode_M300() {
+    uint16_t const frequency = parser.ushortval('S', 260);
+    uint16_t duration = parser.ushortval('P', 1000);
+
+    // Limits the tone duration to 0-5 seconds.
+    NOMORE(duration, 5000);
+
+    BUZZ(duration, frequency);
+  }
+
+#endif // HAS_BUZZER
+
+#if ENABLED(PIDTEMP)
+
+  /**
+   * M301: Set PID parameters P I D (and optionally C, L)
+   *
+   *   P[float] Kp term
+   *   I[float] Ki term (unscaled)
+   *   D[float] Kd term (unscaled)
+   *
+   * With PID_EXTRUSION_SCALING:
+   *
+   *   C[float] Kc term
+   *   L[float] LPQ length
+   */
+  inline void gcode_M301() {
+
+    // multi-extruder PID patch: M301 updates or prints a single extruder's PID values
+    // default behaviour (omitting E parameter) is to update for extruder 0 only
+    const uint8_t e = parser.byteval('E'); // extruder being updated
+
+    if (e < HOTENDS) { // catch bad input value
+      if (parser.seen('P')) PID_PARAM(Kp, e) = parser.value_float();
+      if (parser.seen('I')) PID_PARAM(Ki, e) = scalePID_i(parser.value_float());
+      if (parser.seen('D')) PID_PARAM(Kd, e) = scalePID_d(parser.value_float());
+      #if ENABLED(PID_EXTRUSION_SCALING)
+        if (parser.seen('C')) PID_PARAM(Kc, e) = parser.value_float();
+        if (parser.seen('L')) lpq_len = parser.value_float();
+        NOMORE(lpq_len, LPQ_MAX_LEN);
+      #endif
+
+      thermalManager.updatePID();
+      SERIAL_ECHO_START();
+      #if ENABLED(PID_PARAMS_PER_HOTEND)
+        SERIAL_ECHOPAIR(" e:", e); // specify extruder in serial output
+      #endif // PID_PARAMS_PER_HOTEND
+      SERIAL_ECHOPAIR(" p:", PID_PARAM(Kp, e));
+      SERIAL_ECHOPAIR(" i:", unscalePID_i(PID_PARAM(Ki, e)));
+      SERIAL_ECHOPAIR(" d:", unscalePID_d(PID_PARAM(Kd, e)));
+      #if ENABLED(PID_EXTRUSION_SCALING)
+        //Kc does not have scaling applied above, or in resetting defaults
+        SERIAL_ECHOPAIR(" c:", PID_PARAM(Kc, e));
+      #endif
+      SERIAL_EOL();
+    }
+    else {
+      SERIAL_ERROR_START();
+      SERIAL_ERRORLN(MSG_INVALID_EXTRUDER);
+    }
+  }
+
+#endif // PIDTEMP
+
+#if ENABLED(PIDTEMPBED)
+
+  inline void gcode_M304() {
+    if (parser.seen('P')) thermalManager.bedKp = parser.value_float();
+    if (parser.seen('I')) thermalManager.bedKi = scalePID_i(parser.value_float());
+    if (parser.seen('D')) thermalManager.bedKd = scalePID_d(parser.value_float());
+
+    thermalManager.updatePID();
+
+    SERIAL_ECHO_START();
+    SERIAL_ECHOPAIR(" p:", thermalManager.bedKp);
+    SERIAL_ECHOPAIR(" i:", unscalePID_i(thermalManager.bedKi));
+    SERIAL_ECHOLNPAIR(" d:", unscalePID_d(thermalManager.bedKd));
+  }
+
+#endif // PIDTEMPBED
+
+#if defined(CHDK) || HAS_PHOTOGRAPH
+
+  /**
+   * M240: Trigger a camera by emulating a Canon RC-1
+   *       See http://www.doc-diy.net/photo/rc-1_hacked/
+   */
+  inline void gcode_M240() {
+    #ifdef CHDK
+
+      OUT_WRITE(CHDK, HIGH);
+      chdkHigh = millis();
+      chdkActive = true;
+
+    #elif HAS_PHOTOGRAPH
+
+      const uint8_t NUM_PULSES = 16;
+      const float PULSE_LENGTH = 0.01524;
+      for (int i = 0; i < NUM_PULSES; i++) {
+        WRITE(PHOTOGRAPH_PIN, HIGH);
+        _delay_ms(PULSE_LENGTH);
+        WRITE(PHOTOGRAPH_PIN, LOW);
+        _delay_ms(PULSE_LENGTH);
+      }
+      delay(7.33);
+      for (int i = 0; i < NUM_PULSES; i++) {
+        WRITE(PHOTOGRAPH_PIN, HIGH);
+        _delay_ms(PULSE_LENGTH);
+        WRITE(PHOTOGRAPH_PIN, LOW);
+        _delay_ms(PULSE_LENGTH);
+      }
+
+    #endif // !CHDK && HAS_PHOTOGRAPH
+  }
+
+#endif // CHDK || PHOTOGRAPH_PIN
+
+#if HAS_LCD_CONTRAST
+
+  /**
+   * M250: Read and optionally set the LCD contrast
+   */
+  inline void gcode_M250() {
+    if (parser.seen('C')) set_lcd_contrast(parser.value_int());
+    SERIAL_PROTOCOLPGM("lcd contrast value: ");
+    SERIAL_PROTOCOL(lcd_contrast);
+    SERIAL_EOL();
+  }
+
+#endif // HAS_LCD_CONTRAST
+
+#if ENABLED(PREVENT_COLD_EXTRUSION)
+
+  /**
+   * M302: Allow cold extrudes, or set the minimum extrude temperature
+   *
+   *       S<temperature> sets the minimum extrude temperature
+   *       P<bool> enables (1) or disables (0) cold extrusion
+   *
+   *  Examples:
+   *
+   *       M302         ; report current cold extrusion state
+   *       M302 P0      ; enable cold extrusion checking
+   *       M302 P1      ; disables cold extrusion checking
+   *       M302 S0      ; always allow extrusion (disables checking)
+   *       M302 S170    ; only allow extrusion above 170
+   *       M302 S170 P1 ; set min extrude temp to 170 but leave disabled
+   */
+  inline void gcode_M302() {
+    const bool seen_S = parser.seen('S');
+    if (seen_S) {
+      thermalManager.extrude_min_temp = parser.value_celsius();
+      thermalManager.allow_cold_extrude = (thermalManager.extrude_min_temp == 0);
+    }
+
+    if (parser.seen('P'))
+      thermalManager.allow_cold_extrude = (thermalManager.extrude_min_temp == 0) || parser.value_bool();
+    else if (!seen_S) {
+      // Report current state
+      SERIAL_ECHO_START();
+      SERIAL_ECHOPAIR("Cold extrudes are ", (thermalManager.allow_cold_extrude ? "en" : "dis"));
+      SERIAL_ECHOPAIR("abled (min temp ", thermalManager.extrude_min_temp);
+      SERIAL_ECHOLNPGM("C)");
+    }
+  }
+
+#endif // PREVENT_COLD_EXTRUSION
+
+/**
+ * M303: PID relay autotune
+ *
+ *       S<temperature> sets the target temperature. (default 150C)
+ *       E<extruder> (-1 for the bed) (default 0)
+ *       C<cycles>
+ *       U<bool> with a non-zero value will apply the result to current settings
+ */
+inline void gcode_M303() {
+  #if HAS_PID_HEATING
+    const int e = parser.intval('E'), c = parser.intval('C', 5);
+    const bool u = parser.boolval('U');
+
+    int16_t temp = parser.celsiusval('S', e < 0 ? 70 : 150);
+
+    if (WITHIN(e, 0, HOTENDS - 1))
+      target_extruder = e;
+
+    #if DISABLED(BUSY_WHILE_HEATING)
+      KEEPALIVE_STATE(NOT_BUSY);
+    #endif
+
+    thermalManager.PID_autotune(temp, e, c, u);
+
+    #if DISABLED(BUSY_WHILE_HEATING)
+      KEEPALIVE_STATE(IN_HANDLER);
+    #endif
+  #else
+    SERIAL_ERROR_START();
+    SERIAL_ERRORLNPGM(MSG_ERR_M303_DISABLED);
+  #endif
+}
+
+#if ENABLED(MORGAN_SCARA)
+
+  bool SCARA_move_to_cal(uint8_t delta_a, uint8_t delta_b) {
+    if (IsRunning()) {
+      forward_kinematics_SCARA(delta_a, delta_b);
+      destination[X_AXIS] = LOGICAL_X_POSITION(cartes[X_AXIS]);
+      destination[Y_AXIS] = LOGICAL_Y_POSITION(cartes[Y_AXIS]);
+      destination[Z_AXIS] = current_position[Z_AXIS];
+      prepare_move_to_destination();
+      return true;
+    }
+    return false;
+  }
+
+  /**
+   * M360: SCARA calibration: Move to cal-position ThetaA (0 deg calibration)
+   */
+  inline bool gcode_M360() {
+    SERIAL_ECHOLNPGM(" Cal: Theta 0");
+    return SCARA_move_to_cal(0, 120);
+  }
+
+  /**
+   * M361: SCARA calibration: Move to cal-position ThetaB (90 deg calibration - steps per degree)
+   */
+  inline bool gcode_M361() {
+    SERIAL_ECHOLNPGM(" Cal: Theta 90");
+    return SCARA_move_to_cal(90, 130);
+  }
+
+  /**
+   * M362: SCARA calibration: Move to cal-position PsiA (0 deg calibration)
+   */
+  inline bool gcode_M362() {
+    SERIAL_ECHOLNPGM(" Cal: Psi 0");
+    return SCARA_move_to_cal(60, 180);
+  }
+
+  /**
+   * M363: SCARA calibration: Move to cal-position PsiB (90 deg calibration - steps per degree)
+   */
+  inline bool gcode_M363() {
+    SERIAL_ECHOLNPGM(" Cal: Psi 90");
+    return SCARA_move_to_cal(50, 90);
+  }
+
+  /**
+   * M364: SCARA calibration: Move to cal-position PsiC (90 deg to Theta calibration position)
+   */
+  inline bool gcode_M364() {
+    SERIAL_ECHOLNPGM(" Cal: Theta-Psi 90");
+    return SCARA_move_to_cal(45, 135);
+  }
+
+#endif // SCARA
+
+#if ENABLED(EXT_SOLENOID)
+
+  void enable_solenoid(const uint8_t num) {
+    switch (num) {
+      case 0:
+        OUT_WRITE(SOL0_PIN, HIGH);
+        break;
+        #if HAS_SOLENOID_1 && EXTRUDERS > 1
+          case 1:
+            OUT_WRITE(SOL1_PIN, HIGH);
+            break;
+        #endif
+        #if HAS_SOLENOID_2 && EXTRUDERS > 2
+          case 2:
+            OUT_WRITE(SOL2_PIN, HIGH);
+            break;
+        #endif
+        #if HAS_SOLENOID_3 && EXTRUDERS > 3
+          case 3:
+            OUT_WRITE(SOL3_PIN, HIGH);
+            break;
+        #endif
+        #if HAS_SOLENOID_4 && EXTRUDERS > 4
+          case 4:
+            OUT_WRITE(SOL4_PIN, HIGH);
+            break;
+        #endif
+      default:
+        SERIAL_ECHO_START();
+        SERIAL_ECHOLNPGM(MSG_INVALID_SOLENOID);
+        break;
+    }
+  }
+
+  void enable_solenoid_on_active_extruder() { enable_solenoid(active_extruder); }
+
+  void disable_all_solenoids() {
+    OUT_WRITE(SOL0_PIN, LOW);
+    #if HAS_SOLENOID_1 && EXTRUDERS > 1
+      OUT_WRITE(SOL1_PIN, LOW);
+    #endif
+    #if HAS_SOLENOID_2 && EXTRUDERS > 2
+      OUT_WRITE(SOL2_PIN, LOW);
+    #endif
+    #if HAS_SOLENOID_3 && EXTRUDERS > 3
+      OUT_WRITE(SOL3_PIN, LOW);
+    #endif
+    #if HAS_SOLENOID_4 && EXTRUDERS > 4
+      OUT_WRITE(SOL4_PIN, LOW);
+    #endif
+  }
+
+  /**
+   * M380: Enable solenoid on the active extruder
+   */
+  inline void gcode_M380() { enable_solenoid_on_active_extruder(); }
+
+  /**
+   * M381: Disable all solenoids
+   */
+  inline void gcode_M381() { disable_all_solenoids(); }
+
+#endif // EXT_SOLENOID
+
+/**
+ * M400: Finish all moves
+ */
+inline void gcode_M400() { stepper.synchronize(); }
+
+#if HAS_BED_PROBE
+
+  /**
+   * M401: Engage Z Servo endstop if available
+   */
+  inline void gcode_M401() { DEPLOY_PROBE(); }
+
+  /**
+   * M402: Retract Z Servo endstop if enabled
+   */
+  inline void gcode_M402() { STOW_PROBE(); }
+
+#endif // HAS_BED_PROBE
+
+#if ENABLED(FILAMENT_WIDTH_SENSOR)
+
+  /**
+   * M404: Display or set (in current units) the nominal filament width (3mm, 1.75mm ) W<3.0>
+   */
+  inline void gcode_M404() {
+    if (parser.seen('W')) {
+      filament_width_nominal = parser.value_linear_units();
+    }
+    else {
+      SERIAL_PROTOCOLPGM("Filament dia (nominal mm):");
+      SERIAL_PROTOCOLLN(filament_width_nominal);
+    }
+  }
+
+  /**
+   * M405: Turn on filament sensor for control
+   */
+  inline void gcode_M405() {
+    // This is technically a linear measurement, but since it's quantized to centimeters and is a different
+    // unit than everything else, it uses parser.value_byte() instead of parser.value_linear_units().
+    if (parser.seen('D')) {
+      meas_delay_cm = parser.value_byte();
+      NOMORE(meas_delay_cm, MAX_MEASUREMENT_DELAY);
+    }
+
+    if (filwidth_delay_index[1] == -1) { // Initialize the ring buffer if not done since startup
+      const uint8_t temp_ratio = thermalManager.widthFil_to_size_ratio() - 100; // -100 to scale within a signed byte
+
+      for (uint8_t i = 0; i < COUNT(measurement_delay); ++i)
+        measurement_delay[i] = temp_ratio;
+
+      filwidth_delay_index[0] = filwidth_delay_index[1] = 0;
+    }
+
+    filament_sensor = true;
+
+    //SERIAL_PROTOCOLPGM("Filament dia (measured mm):");
+    //SERIAL_PROTOCOL(filament_width_meas);
+    //SERIAL_PROTOCOLPGM("Extrusion ratio(%):");
+    //SERIAL_PROTOCOL(flow_percentage[active_extruder]);
+  }
+
+  /**
+   * M406: Turn off filament sensor for control
+   */
+  inline void gcode_M406() {
+    filament_sensor = false;
+    calculate_volumetric_multipliers();   // Restore correct 'volumetric_multiplier' value
+  }
+
+  /**
+   * M407: Get measured filament diameter on serial output
+   */
+  inline void gcode_M407() {
+    SERIAL_PROTOCOLPGM("Filament dia (measured mm):");
+    SERIAL_PROTOCOLLN(filament_width_meas);
+  }
+
+#endif // FILAMENT_WIDTH_SENSOR
+
+void quickstop_stepper() {
+  stepper.quick_stop();
+  stepper.synchronize();
+  set_current_from_steppers_for_axis(ALL_AXES);
+  SYNC_PLAN_POSITION_KINEMATIC();
+}
+
+#if HAS_LEVELING
+  /**
+   * M420: Enable/Disable Bed Leveling and/or set the Z fade height.
+   *
+   *   S[bool]   Turns leveling on or off
+   *   Z[height] Sets the Z fade height (0 or none to disable)
+   *   V[bool]   Verbose - Print the leveling grid
+   *
+   * With AUTO_BED_LEVELING_UBL only:
+   *
+   *   L[index]  Load UBL mesh from index (0 is default)
+   */
+  inline void gcode_M420() {
+
+    #if ENABLED(AUTO_BED_LEVELING_UBL)
+
+      // L to load a mesh from the EEPROM
+      if (parser.seen('L')) {
+
+        #if ENABLED(EEPROM_SETTINGS)
+          const int8_t storage_slot = parser.has_value() ? parser.value_int() : ubl.state.storage_slot;
+          const int16_t a = settings.calc_num_meshes();
+
+          if (!a) {
+            SERIAL_PROTOCOLLNPGM("?EEPROM storage not available.");
+            return;
+          }
+
+          if (!WITHIN(storage_slot, 0, a - 1)) {
+            SERIAL_PROTOCOLLNPGM("?Invalid storage slot.");
+            SERIAL_PROTOCOLLNPAIR("?Use 0 to ", a - 1);
+            return;
+          }
+
+          settings.load_mesh(storage_slot);
+          ubl.state.storage_slot = storage_slot;
+
+        #else
+
+          SERIAL_PROTOCOLLNPGM("?EEPROM storage not available.");
+          return;
+
+        #endif
+      }
+
+      // L to load a mesh from the EEPROM
+      if (parser.seen('L') || parser.seen('V')) {
+        ubl.display_map(0);  // Currently only supports one map type
+        SERIAL_ECHOLNPAIR("UBL_MESH_VALID = ", UBL_MESH_VALID);
+        SERIAL_ECHOLNPAIR("ubl.state.storage_slot = ", ubl.state.storage_slot);
+      }
+
+    #endif // AUTO_BED_LEVELING_UBL
+
+    // V to print the matrix or mesh
+    if (parser.seen('V')) {
+      #if ABL_PLANAR
+        planner.bed_level_matrix.debug(PSTR("Bed Level Correction Matrix:"));
+      #else
+        if (leveling_is_valid()) {
+          #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
+            print_bilinear_leveling_grid();
+            #if ENABLED(ABL_BILINEAR_SUBDIVISION)
+              print_bilinear_leveling_grid_virt();
+            #endif
+          #elif ENABLED(MESH_BED_LEVELING)
+            SERIAL_ECHOLNPGM("Mesh Bed Level data:");
+            mbl_mesh_report();
+          #endif
+        }
+      #endif
+    }
+
+    const bool to_enable = parser.boolval('S');
+    if (parser.seen('S'))
+      set_bed_leveling_enabled(to_enable);
+
+    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+      if (parser.seen('Z')) set_z_fade_height(parser.value_linear_units());
+    #endif
+
+    const bool new_status = leveling_is_active();
+
+    if (to_enable && !new_status) {
+      SERIAL_ERROR_START();
+      SERIAL_ERRORLNPGM(MSG_ERR_M420_FAILED);
+    }
+
+    SERIAL_ECHO_START();
+    SERIAL_ECHOLNPAIR("Bed Leveling ", new_status ? MSG_ON : MSG_OFF);
+
+    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+      SERIAL_ECHO_START();
+      SERIAL_ECHOPGM("Fade Height ");
+      if (planner.z_fade_height > 0.0)
+        SERIAL_ECHOLN(planner.z_fade_height);
+      else
+        SERIAL_ECHOLNPGM(MSG_OFF);
+    #endif
+  }
+#endif
+
+#if ENABLED(MESH_BED_LEVELING)
+
+  /**
+   * M421: Set a single Mesh Bed Leveling Z coordinate
+   *
+   * Usage:
+   *   M421 X<linear> Y<linear> Z<linear>
+   *   M421 X<linear> Y<linear> Q<offset>
+   *   M421 I<xindex> J<yindex> Z<linear>
+   *   M421 I<xindex> J<yindex> Q<offset>
+   */
+  inline void gcode_M421() {
+    const bool hasX = parser.seen('X'), hasI = parser.seen('I');
+    const int8_t ix = hasI ? parser.value_int() : hasX ? mbl.probe_index_x(RAW_X_POSITION(parser.value_linear_units())) : -1;
+    const bool hasY = parser.seen('Y'), hasJ = parser.seen('J');
+    const int8_t iy = hasJ ? parser.value_int() : hasY ? mbl.probe_index_y(RAW_Y_POSITION(parser.value_linear_units())) : -1;
+    const bool hasZ = parser.seen('Z'), hasQ = !hasZ && parser.seen('Q');
+
+    if (int(hasI && hasJ) + int(hasX && hasY) != 1 || !(hasZ || hasQ)) {
+      SERIAL_ERROR_START();
+      SERIAL_ERRORLNPGM(MSG_ERR_M421_PARAMETERS);
+    }
+    else if (ix < 0 || iy < 0) {
+      SERIAL_ERROR_START();
+      SERIAL_ERRORLNPGM(MSG_ERR_MESH_XY);
+    }
+    else
+      mbl.set_z(ix, iy, parser.value_linear_units() + (hasQ ? mbl.z_values[ix][iy] : 0));
+  }
+
+#elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
+
+  /**
+   * M421: Set a single Mesh Bed Leveling Z coordinate
+   *
+   * Usage:
+   *   M421 I<xindex> J<yindex> Z<linear>
+   *   M421 I<xindex> J<yindex> Q<offset>
+   */
+  inline void gcode_M421() {
+    int8_t ix = parser.intval('I', -1), iy = parser.intval('J', -1);
+    const bool hasI = ix >= 0,
+               hasJ = iy >= 0,
+               hasZ = parser.seen('Z'),
+               hasQ = !hasZ && parser.seen('Q');
+
+    if (!hasI || !hasJ || !(hasZ || hasQ)) {
+      SERIAL_ERROR_START();
+      SERIAL_ERRORLNPGM(MSG_ERR_M421_PARAMETERS);
+    }
+    else if (!WITHIN(ix, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(iy, 0, GRID_MAX_POINTS_Y - 1)) {
+      SERIAL_ERROR_START();
+      SERIAL_ERRORLNPGM(MSG_ERR_MESH_XY);
+    }
+    else {
+      z_values[ix][iy] = parser.value_linear_units() + (hasQ ? z_values[ix][iy] : 0);
+      #if ENABLED(ABL_BILINEAR_SUBDIVISION)
+        bed_level_virt_interpolate();
+      #endif
+    }
+  }
+
+#elif ENABLED(AUTO_BED_LEVELING_UBL)
+
+  /**
+   * M421: Set a single Mesh Bed Leveling Z coordinate
+   *
+   * Usage:
+   *   M421 I<xindex> J<yindex> Z<linear>
+   *   M421 I<xindex> J<yindex> Q<offset>
+   *   M421 C Z<linear>
+   *   M421 C Q<offset>
+   */
+  inline void gcode_M421() {
+    int8_t ix = parser.intval('I', -1), iy = parser.intval('J', -1);
+    const bool hasI = ix >= 0,
+               hasJ = iy >= 0,
+               hasC = parser.seen('C'),
+               hasZ = parser.seen('Z'),
+               hasQ = !hasZ && parser.seen('Q');
+
+    if (hasC) {
+      const mesh_index_pair location = ubl.find_closest_mesh_point_of_type(REAL, current_position[X_AXIS], current_position[Y_AXIS], USE_NOZZLE_AS_REFERENCE, NULL, false);
+      ix = location.x_index;
+      iy = location.y_index;
+    }
+
+    if (int(hasC) + int(hasI && hasJ) != 1 || !(hasZ || hasQ)) {
+      SERIAL_ERROR_START();
+      SERIAL_ERRORLNPGM(MSG_ERR_M421_PARAMETERS);
+    }
+    else if (!WITHIN(ix, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(iy, 0, GRID_MAX_POINTS_Y - 1)) {
+      SERIAL_ERROR_START();
+      SERIAL_ERRORLNPGM(MSG_ERR_MESH_XY);
+    }
+    else
+      ubl.z_values[ix][iy] = parser.value_linear_units() + (hasQ ? ubl.z_values[ix][iy] : 0);
+  }
+
+#endif // AUTO_BED_LEVELING_UBL
+
+#if HAS_M206_COMMAND
+
+  /**
+   * M428: Set home_offset based on the distance between the
+   *       current_position and the nearest "reference point."
+   *       If an axis is past center its endstop position
+   *       is the reference-point. Otherwise it uses 0. This allows
+   *       the Z offset to be set near the bed when using a max endstop.
+   *
+   *       M428 can't be used more than 2cm away from 0 or an endstop.
+   *
+   *       Use M206 to set these values directly.
+   */
+  inline void gcode_M428() {
+    bool err = false;
+    LOOP_XYZ(i) {
+      if (axis_homed[i]) {
+        const float base = (current_position[i] > (soft_endstop_min[i] + soft_endstop_max[i]) * 0.5) ? base_home_pos((AxisEnum)i) : 0,
+                    diff = base - RAW_POSITION(current_position[i], i);
+        if (WITHIN(diff, -20, 20)) {
+          set_home_offset((AxisEnum)i, diff);
+        }
+        else {
+          SERIAL_ERROR_START();
+          SERIAL_ERRORLNPGM(MSG_ERR_M428_TOO_FAR);
+          LCD_ALERTMESSAGEPGM("Err: Too far!");
+          BUZZ(200, 40);
+          err = true;
+          break;
+        }
+      }
+    }
+
+    if (!err) {
+      SYNC_PLAN_POSITION_KINEMATIC();
+      report_current_position();
+      LCD_MESSAGEPGM(MSG_HOME_OFFSETS_APPLIED);
+      BUZZ(100, 659);
+      BUZZ(100, 698);
+    }
+  }
+
+#endif // HAS_M206_COMMAND
+
+/**
+ * M500: Store settings in EEPROM
+ */
+inline void gcode_M500() {
+  (void)settings.save();
+}
+
+/**
+ * M501: Read settings from EEPROM
+ */
+inline void gcode_M501() {
+  (void)settings.load();
+}
+
+/**
+ * M502: Revert to default settings
+ */
+inline void gcode_M502() {
+  (void)settings.reset();
+}
+
+#if DISABLED(DISABLE_M503)
+  /**
+   * M503: print settings currently in memory
+   */
+  inline void gcode_M503() {
+    (void)settings.report(!parser.boolval('S', true));
+  }
+#endif
+
+#if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
+
+  /**
+   * M540: Set whether SD card print should abort on endstop hit (M540 S<0|1>)
+   */
+  inline void gcode_M540() {
+    if (parser.seen('S')) stepper.abort_on_endstop_hit = parser.value_bool();
+  }
+
+#endif // ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED
+
+#if HAS_BED_PROBE
+
+  void refresh_zprobe_zoffset(const bool no_babystep/*=false*/) {
+    static float last_zoffset = NAN;
+
+    if (!isnan(last_zoffset)) {
+
+      #if ENABLED(AUTO_BED_LEVELING_BILINEAR) || ENABLED(BABYSTEP_ZPROBE_OFFSET) || ENABLED(DELTA)
+        const float diff = zprobe_zoffset - last_zoffset;
+      #endif
+
+      #if ENABLED(AUTO_BED_LEVELING_BILINEAR)
+        // Correct bilinear grid for new probe offset
+        if (diff) {
+          for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
+            for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
+              z_values[x][y] -= diff;
+        }
+        #if ENABLED(ABL_BILINEAR_SUBDIVISION)
+          bed_level_virt_interpolate();
+        #endif
+      #endif
+
+      #if ENABLED(BABYSTEP_ZPROBE_OFFSET)
+        if (!no_babystep && leveling_is_active())
+          thermalManager.babystep_axis(Z_AXIS, -LROUND(diff * planner.axis_steps_per_mm[Z_AXIS]));
+      #else
+        UNUSED(no_babystep);
+      #endif
+
+      #if ENABLED(DELTA) // correct the delta_height
+        home_offset[Z_AXIS] -= diff;
+      #endif
+    }
+
+    last_zoffset = zprobe_zoffset;
+  }
+
+  inline void gcode_M851() {
+    SERIAL_ECHO_START();
+    SERIAL_ECHOPGM(MSG_ZPROBE_ZOFFSET " ");
+    if (parser.seen('Z')) {
+      const float value = parser.value_linear_units();
+      if (WITHIN(value, Z_PROBE_OFFSET_RANGE_MIN, Z_PROBE_OFFSET_RANGE_MAX)) {
+        zprobe_zoffset = value;
+        refresh_zprobe_zoffset();
+        SERIAL_ECHO(zprobe_zoffset);
+      }
+      else
+        SERIAL_ECHOPGM(MSG_Z_MIN " " STRINGIFY(Z_PROBE_OFFSET_RANGE_MIN) " " MSG_Z_MAX " " STRINGIFY(Z_PROBE_OFFSET_RANGE_MAX));
+    }
+    else
+      SERIAL_ECHOPAIR(": ", zprobe_zoffset);
+
+    SERIAL_EOL();
+  }
+
+#endif // HAS_BED_PROBE
+
+#if ENABLED(ADVANCED_PAUSE_FEATURE)
+
+  /**
+   * M600: Pause for filament change
+   *
+   *  E[distance] - Retract the filament this far (negative value)
+   *  Z[distance] - Move the Z axis by this distance
+   *  X[position] - Move to this X position, with Y
+   *  Y[position] - Move to this Y position, with X
+   *  U[distance] - Retract distance for removal (negative value) (manual reload)
+   *  L[distance] - Extrude distance for insertion (positive value) (manual reload)
+   *  B[count]    - Number of times to beep, -1 for indefinite (if equipped with a buzzer)
+   *
+   *  Default values are used for omitted arguments.
+   *
+   */
+  inline void gcode_M600() {
+
+    #if ENABLED(HOME_BEFORE_FILAMENT_CHANGE)
+      // Don't allow filament change without homing first
+      if (axis_unhomed_error()) home_all_axes();
+    #endif
+
+    // Initial retract before move to filament change position
+    const float retract = parser.seen('E') ? parser.value_axis_units(E_AXIS) : 0
+      #ifdef PAUSE_PARK_RETRACT_LENGTH
+        - (PAUSE_PARK_RETRACT_LENGTH)
+      #endif
+    ;
+
+    // Lift Z axis
+    const float z_lift = parser.linearval('Z', 0
+      #ifdef PAUSE_PARK_Z_ADD
+        + PAUSE_PARK_Z_ADD
+      #endif
+    );
+
+    // Move XY axes to filament exchange position
+    const float x_pos = parser.linearval('X', 0
+      #ifdef PAUSE_PARK_X_POS
+        + PAUSE_PARK_X_POS
+      #endif
+    );
+    const float y_pos = parser.linearval('Y', 0
+      #ifdef PAUSE_PARK_Y_POS
+        + PAUSE_PARK_Y_POS
+      #endif
+    );
+
+    // Unload filament
+    const float unload_length = parser.seen('U') ? parser.value_axis_units(E_AXIS) : 0
+      #if defined(FILAMENT_CHANGE_UNLOAD_LENGTH) && FILAMENT_CHANGE_UNLOAD_LENGTH > 0
+        - (FILAMENT_CHANGE_UNLOAD_LENGTH)
+      #endif
+    ;
+
+    // Load filament
+    const float load_length = parser.seen('L') ? parser.value_axis_units(E_AXIS) : 0
+      #ifdef FILAMENT_CHANGE_LOAD_LENGTH
+        + FILAMENT_CHANGE_LOAD_LENGTH
+      #endif
+    ;
+
+    const int beep_count = parser.intval('B',
+      #ifdef FILAMENT_CHANGE_NUMBER_OF_ALERT_BEEPS
+        FILAMENT_CHANGE_NUMBER_OF_ALERT_BEEPS
+      #else
+        -1
+      #endif
+    );
+
+    const bool job_running = print_job_timer.isRunning();
+
+    if (pause_print(retract, z_lift, x_pos, y_pos, unload_length, beep_count, true)) {
+      wait_for_filament_reload(beep_count);
+      resume_print(load_length, ADVANCED_PAUSE_EXTRUDE_LENGTH, beep_count);
+    }
+
+    // Resume the print job timer if it was running
+    if (job_running) print_job_timer.start();
+  }
+
+#endif // ADVANCED_PAUSE_FEATURE
+
+#if ENABLED(MK2_MULTIPLEXER)
+
+  inline void select_multiplexed_stepper(const uint8_t e) {
+    stepper.synchronize();
+    disable_e_steppers();
+    WRITE(E_MUX0_PIN, TEST(e, 0) ? HIGH : LOW);
+    WRITE(E_MUX1_PIN, TEST(e, 1) ? HIGH : LOW);
+    WRITE(E_MUX2_PIN, TEST(e, 2) ? HIGH : LOW);
+    safe_delay(100);
+  }
+
+  /**
+   * M702: Unload all extruders
+   */
+  inline void gcode_M702() {
+    for (uint8_t s = 0; s < E_STEPPERS; s++) {
+      select_multiplexed_stepper(e);
+      // TODO: standard unload filament function
+      // MK2 firmware behavior:
+      //  - Make sure temperature is high enough
+      //  - Raise Z to at least 15 to make room
+      //  - Extrude 1cm of filament in 1 second
+      //  - Under 230C quickly purge ~12mm, over 230C purge ~10mm
+      //  - Change E max feedrate to 80, eject the filament from the tube. Sync.
+      //  - Restore E max feedrate to 50
+    }
+    // Go back to the last active extruder
+    select_multiplexed_stepper(active_extruder);
+    disable_e_steppers();
+  }
+
+#endif // MK2_MULTIPLEXER
+
+#if ENABLED(DUAL_X_CARRIAGE)
+
+  /**
+   * M605: Set dual x-carriage movement mode
+   *
+   *    M605 S0: Full control mode. The slicer has full control over x-carriage movement
+   *    M605 S1: Auto-park mode. The inactive head will auto park/unpark without slicer involvement
+   *    M605 S2 [Xnnn] [Rmmm]: Duplication mode. The second extruder will duplicate the first with nnn
+   *                         units x-offset and an optional differential hotend temperature of
+   *                         mmm degrees. E.g., with "M605 S2 X100 R2" the second extruder will duplicate
+   *                         the first with a spacing of 100mm in the x direction and 2 degrees hotter.
+   *
+   *    Note: the X axis should be homed after changing dual x-carriage mode.
+   */
+  inline void gcode_M605() {
+    stepper.synchronize();
+    if (parser.seen('S')) dual_x_carriage_mode = (DualXMode)parser.value_byte();
+    switch (dual_x_carriage_mode) {
+      case DXC_FULL_CONTROL_MODE:
+      case DXC_AUTO_PARK_MODE:
+        break;
+      case DXC_DUPLICATION_MODE:
+        if (parser.seen('X')) duplicate_extruder_x_offset = max(parser.value_linear_units(), X2_MIN_POS - x_home_pos(0));
+        if (parser.seen('R')) duplicate_extruder_temp_offset = parser.value_celsius_diff();
+        SERIAL_ECHO_START();
+        SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);
+        SERIAL_CHAR(' ');
+        SERIAL_ECHO(hotend_offset[X_AXIS][0]);
+        SERIAL_CHAR(',');
+        SERIAL_ECHO(hotend_offset[Y_AXIS][0]);
+        SERIAL_CHAR(' ');
+        SERIAL_ECHO(duplicate_extruder_x_offset);
+        SERIAL_CHAR(',');
+        SERIAL_ECHOLN(hotend_offset[Y_AXIS][1]);
+        break;
+      default:
+        dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
+        break;
+    }
+    active_extruder_parked = false;
+    extruder_duplication_enabled = false;
+    delayed_move_time = 0;
+  }
+
+#elif ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
+
+  inline void gcode_M605() {
+    stepper.synchronize();
+    extruder_duplication_enabled = parser.intval('S') == (int)DXC_DUPLICATION_MODE;
+    SERIAL_ECHO_START();
+    SERIAL_ECHOLNPAIR(MSG_DUPLICATION_MODE, extruder_duplication_enabled ? MSG_ON : MSG_OFF);
+  }
+
+#endif // DUAL_NOZZLE_DUPLICATION_MODE
+
+#if ENABLED(LIN_ADVANCE)
+  /**
+   * M900: Set and/or Get advance K factor and WH/D ratio
+   *
+   *  K<factor>                  Set advance K factor
+   *  R<ratio>                   Set ratio directly (overrides WH/D)
+   *  W<width> H<height> D<diam> Set ratio from WH/D
+   */
+  inline void gcode_M900() {
+    stepper.synchronize();
+
+    const float newK = parser.floatval('K', -1);
+    if (newK >= 0) planner.extruder_advance_k = newK;
+
+    float newR = parser.floatval('R', -1);
+    if (newR < 0) {
+      const float newD = parser.floatval('D', -1),
+                  newW = parser.floatval('W', -1),
+                  newH = parser.floatval('H', -1);
+      if (newD >= 0 && newW >= 0 && newH >= 0)
+        newR = newD ? (newW * newH) / (sq(newD * 0.5) * M_PI) : 0;
+    }
+    if (newR >= 0) planner.advance_ed_ratio = newR;
+
+    SERIAL_ECHO_START();
+    SERIAL_ECHOPAIR("Advance K=", planner.extruder_advance_k);
+    SERIAL_ECHOPGM(" E/D=");
+    const float ratio = planner.advance_ed_ratio;
+    if (ratio) SERIAL_ECHO(ratio); else SERIAL_ECHOPGM("Auto");
+    SERIAL_EOL();
+  }
+#endif // LIN_ADVANCE
+
+#if ENABLED(HAVE_TMC2130)
+
+  static void tmc2130_get_current(TMC2130Stepper &st, const char name) {
+    SERIAL_CHAR(name);
+    SERIAL_ECHOPGM(" axis driver current: ");
+    SERIAL_ECHOLN(st.getCurrent());
+  }
+  static void tmc2130_set_current(TMC2130Stepper &st, const char name, const int mA) {
+    st.setCurrent(mA, R_SENSE, HOLD_MULTIPLIER);
+    tmc2130_get_current(st, name);
+  }
+
+  static void tmc2130_report_otpw(TMC2130Stepper &st, const char name) {
+    SERIAL_CHAR(name);
+    SERIAL_ECHOPGM(" axis temperature prewarn triggered: ");
+    serialprintPGM(st.getOTPW() ? PSTR("true") : PSTR("false"));
+    SERIAL_EOL();
+  }
+  static void tmc2130_clear_otpw(TMC2130Stepper &st, const char name) {
+    st.clear_otpw();
+    SERIAL_CHAR(name);
+    SERIAL_ECHOLNPGM(" prewarn flag cleared");
+  }
+
+  static void tmc2130_get_pwmthrs(TMC2130Stepper &st, const char name, const uint16_t spmm) {
+    SERIAL_CHAR(name);
+    SERIAL_ECHOPGM(" stealthChop max speed set to ");
+    SERIAL_ECHOLN(12650000UL * st.microsteps() / (256 * st.stealth_max_speed() * spmm));
+  }
+  static void tmc2130_set_pwmthrs(TMC2130Stepper &st, const char name, const int32_t thrs, const uint32_t spmm) {
+    st.stealth_max_speed(12650000UL * st.microsteps() / (256 * thrs * spmm));
+    tmc2130_get_pwmthrs(st, name, spmm);
+  }
+
+  static void tmc2130_get_sgt(TMC2130Stepper &st, const char name) {
+    SERIAL_CHAR(name);
+    SERIAL_ECHOPGM(" driver homing sensitivity set to ");
+    SERIAL_ECHOLN(st.sgt());
+  }
+  static void tmc2130_set_sgt(TMC2130Stepper &st, const char name, const int8_t sgt_val) {
+    st.sgt(sgt_val);
+    tmc2130_get_sgt(st, name);
+  }
+
+  /**
+   * M906: Set motor current in milliamps using axis codes X, Y, Z, E
+   * Report driver currents when no axis specified
+   *
+   * S1: Enable automatic current control
+   * S0: Disable
+   */
+  inline void gcode_M906() {
+    uint16_t values[XYZE];
+    LOOP_XYZE(i)
+      values[i] = parser.intval(axis_codes[i]);
+
+    #if ENABLED(X_IS_TMC2130)
+      if (values[X_AXIS]) tmc2130_set_current(stepperX, 'X', values[X_AXIS]);
+      else tmc2130_get_current(stepperX, 'X');
+    #endif
+    #if ENABLED(Y_IS_TMC2130)
+      if (values[Y_AXIS]) tmc2130_set_current(stepperY, 'Y', values[Y_AXIS]);
+      else tmc2130_get_current(stepperY, 'Y');
+    #endif
+    #if ENABLED(Z_IS_TMC2130)
+      if (values[Z_AXIS]) tmc2130_set_current(stepperZ, 'Z', values[Z_AXIS]);
+      else tmc2130_get_current(stepperZ, 'Z');
+    #endif
+    #if ENABLED(E0_IS_TMC2130)
+      if (values[E_AXIS]) tmc2130_set_current(stepperE0, 'E', values[E_AXIS]);
+      else tmc2130_get_current(stepperE0, 'E');
+    #endif
+
+    #if ENABLED(AUTOMATIC_CURRENT_CONTROL)
+      if (parser.seen('S')) auto_current_control = parser.value_bool();
+    #endif
+  }
+
+  /**
+   * M911: Report TMC2130 stepper driver overtemperature pre-warn flag
+   * The flag is held by the library and persist until manually cleared by M912
+   */
+  inline void gcode_M911() {
+    const bool reportX = parser.seen('X'), reportY = parser.seen('Y'), reportZ = parser.seen('Z'), reportE = parser.seen('E'),
+             reportAll = (!reportX && !reportY && !reportZ && !reportE) || (reportX && reportY && reportZ && reportE);
+    #if ENABLED(X_IS_TMC2130)
+      if (reportX || reportAll) tmc2130_report_otpw(stepperX, 'X');
+    #endif
+    #if ENABLED(Y_IS_TMC2130)
+      if (reportY || reportAll) tmc2130_report_otpw(stepperY, 'Y');
+    #endif
+    #if ENABLED(Z_IS_TMC2130)
+      if (reportZ || reportAll) tmc2130_report_otpw(stepperZ, 'Z');
+    #endif
+    #if ENABLED(E0_IS_TMC2130)
+      if (reportE || reportAll) tmc2130_report_otpw(stepperE0, 'E');
+    #endif
+  }
+
+  /**
+   * M912: Clear TMC2130 stepper driver overtemperature pre-warn flag held by the library
+   */
+  inline void gcode_M912() {
+    const bool clearX = parser.seen('X'), clearY = parser.seen('Y'), clearZ = parser.seen('Z'), clearE = parser.seen('E'),
+             clearAll = (!clearX && !clearY && !clearZ && !clearE) || (clearX && clearY && clearZ && clearE);
+    #if ENABLED(X_IS_TMC2130)
+      if (clearX || clearAll) tmc2130_clear_otpw(stepperX, 'X');
+    #endif
+    #if ENABLED(Y_IS_TMC2130)
+      if (clearY || clearAll) tmc2130_clear_otpw(stepperY, 'Y');
+    #endif
+    #if ENABLED(Z_IS_TMC2130)
+      if (clearZ || clearAll) tmc2130_clear_otpw(stepperZ, 'Z');
+    #endif
+    #if ENABLED(E0_IS_TMC2130)
+      if (clearE || clearAll) tmc2130_clear_otpw(stepperE0, 'E');
+    #endif
+  }
+
+  /**
+   * M913: Set HYBRID_THRESHOLD speed.
+   */
+  #if ENABLED(HYBRID_THRESHOLD)
+    inline void gcode_M913() {
+      uint16_t values[XYZE];
+      LOOP_XYZE(i)
+        values[i] = parser.intval(axis_codes[i]);
+
+      #if ENABLED(X_IS_TMC2130)
+        if (values[X_AXIS]) tmc2130_set_pwmthrs(stepperX, 'X', values[X_AXIS], planner.axis_steps_per_mm[X_AXIS]);
+        else tmc2130_get_pwmthrs(stepperX, 'X', planner.axis_steps_per_mm[X_AXIS]);
+      #endif
+      #if ENABLED(Y_IS_TMC2130)
+        if (values[Y_AXIS]) tmc2130_set_pwmthrs(stepperY, 'Y', values[Y_AXIS], planner.axis_steps_per_mm[Y_AXIS]);
+        else tmc2130_get_pwmthrs(stepperY, 'Y', planner.axis_steps_per_mm[Y_AXIS]);
+      #endif
+      #if ENABLED(Z_IS_TMC2130)
+        if (values[Z_AXIS]) tmc2130_set_pwmthrs(stepperZ, 'Z', values[Z_AXIS], planner.axis_steps_per_mm[Z_AXIS]);
+        else tmc2130_get_pwmthrs(stepperZ, 'Z', planner.axis_steps_per_mm[Z_AXIS]);
+      #endif
+      #if ENABLED(E0_IS_TMC2130)
+        if (values[E_AXIS]) tmc2130_set_pwmthrs(stepperE0, 'E', values[E_AXIS], planner.axis_steps_per_mm[E_AXIS]);
+        else tmc2130_get_pwmthrs(stepperE0, 'E', planner.axis_steps_per_mm[E_AXIS]);
+      #endif
+    }
+  #endif // HYBRID_THRESHOLD
+
+  /**
+   * M914: Set SENSORLESS_HOMING sensitivity.
+   */
+  #if ENABLED(SENSORLESS_HOMING)
+    inline void gcode_M914() {
+      #if ENABLED(X_IS_TMC2130)
+        if (parser.seen(axis_codes[X_AXIS])) tmc2130_set_sgt(stepperX, 'X', parser.value_int());
+        else tmc2130_get_sgt(stepperX, 'X');
+      #endif
+      #if ENABLED(Y_IS_TMC2130)
+        if (parser.seen(axis_codes[Y_AXIS])) tmc2130_set_sgt(stepperY, 'Y', parser.value_int());
+        else tmc2130_get_sgt(stepperY, 'Y');
+      #endif
+    }
+  #endif // SENSORLESS_HOMING
+
+#endif // HAVE_TMC2130
+
+/**
+ * M907: Set digital trimpot motor current using axis codes X, Y, Z, E, B, S
+ */
+inline void gcode_M907() {
+  #if HAS_DIGIPOTSS
+
+    LOOP_XYZE(i) if (parser.seen(axis_codes[i])) stepper.digipot_current(i, parser.value_int());
+    if (parser.seen('B')) stepper.digipot_current(4, parser.value_int());
+    if (parser.seen('S')) for (uint8_t i = 0; i <= 4; i++) stepper.digipot_current(i, parser.value_int());
+
+  #elif HAS_MOTOR_CURRENT_PWM
+
+    #if PIN_EXISTS(MOTOR_CURRENT_PWM_XY)
+      if (parser.seen('X')) stepper.digipot_current(0, parser.value_int());
+    #endif
+    #if PIN_EXISTS(MOTOR_CURRENT_PWM_Z)
+      if (parser.seen('Z')) stepper.digipot_current(1, parser.value_int());
+    #endif
+    #if PIN_EXISTS(MOTOR_CURRENT_PWM_E)
+      if (parser.seen('E')) stepper.digipot_current(2, parser.value_int());
+    #endif
+
+  #endif
+
+  #if ENABLED(DIGIPOT_I2C)
+    // this one uses actual amps in floating point
+    LOOP_XYZE(i) if (parser.seen(axis_codes[i])) digipot_i2c_set_current(i, parser.value_float());
+    // for each additional extruder (named B,C,D,E..., channels 4,5,6,7...)
+    for (uint8_t i = NUM_AXIS; i < DIGIPOT_I2C_NUM_CHANNELS; i++) if (parser.seen('B' + i - (NUM_AXIS))) digipot_i2c_set_current(i, parser.value_float());
+  #endif
+
+  #if ENABLED(DAC_STEPPER_CURRENT)
+    if (parser.seen('S')) {
+      const float dac_percent = parser.value_float();
+      for (uint8_t i = 0; i <= 4; i++) dac_current_percent(i, dac_percent);
+    }
+    LOOP_XYZE(i) if (parser.seen(axis_codes[i])) dac_current_percent(i, parser.value_float());
+  #endif
+}
+
+#if HAS_DIGIPOTSS || ENABLED(DAC_STEPPER_CURRENT)
+
+  /**
+   * M908: Control digital trimpot directly (M908 P<pin> S<current>)
+   */
+  inline void gcode_M908() {
+    #if HAS_DIGIPOTSS
+      stepper.digitalPotWrite(
+        parser.intval('P'),
+        parser.intval('S')
+      );
+    #endif
+    #ifdef DAC_STEPPER_CURRENT
+      dac_current_raw(
+        parser.byteval('P', -1),
+        parser.ushortval('S', 0)
+      );
+    #endif
+  }
+
+  #if ENABLED(DAC_STEPPER_CURRENT) // As with Printrbot RevF
+
+    inline void gcode_M909() { dac_print_values(); }
+
+    inline void gcode_M910() { dac_commit_eeprom(); }
+
+  #endif
+
+#endif // HAS_DIGIPOTSS || DAC_STEPPER_CURRENT
+
+#if HAS_MICROSTEPS
+
+  // M350 Set microstepping mode. Warning: Steps per unit remains unchanged. S code sets stepping mode for all drivers.
+  inline void gcode_M350() {
+    if (parser.seen('S')) for (int i = 0; i <= 4; i++) stepper.microstep_mode(i, parser.value_byte());
+    LOOP_XYZE(i) if (parser.seen(axis_codes[i])) stepper.microstep_mode(i, parser.value_byte());
+    if (parser.seen('B')) stepper.microstep_mode(4, parser.value_byte());
+    stepper.microstep_readings();
+  }
+
+  /**
+   * M351: Toggle MS1 MS2 pins directly with axis codes X Y Z E B
+   *       S# determines MS1 or MS2, X# sets the pin high/low.
+   */
+  inline void gcode_M351() {
+    if (parser.seenval('S')) switch (parser.value_byte()) {
+      case 1:
+        LOOP_XYZE(i) if (parser.seenval(axis_codes[i])) stepper.microstep_ms(i, parser.value_byte(), -1);
+        if (parser.seenval('B')) stepper.microstep_ms(4, parser.value_byte(), -1);
+        break;
+      case 2:
+        LOOP_XYZE(i) if (parser.seenval(axis_codes[i])) stepper.microstep_ms(i, -1, parser.value_byte());
+        if (parser.seenval('B')) stepper.microstep_ms(4, -1, parser.value_byte());
+        break;
+    }
+    stepper.microstep_readings();
+  }
+
+#endif // HAS_MICROSTEPS
+
+#if HAS_CASE_LIGHT
+  #ifndef INVERT_CASE_LIGHT
+    #define INVERT_CASE_LIGHT false
+  #endif
+  int case_light_brightness;  // LCD routine wants INT
+  bool case_light_on;
+
+  void update_case_light() {
+    pinMode(CASE_LIGHT_PIN, OUTPUT); // digitalWrite doesn't set the port mode
+    uint8_t case_light_bright = (uint8_t)case_light_brightness;
+    if (case_light_on) {
+      if (USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN)) {
+        analogWrite(CASE_LIGHT_PIN, INVERT_CASE_LIGHT ? 255 - case_light_brightness : case_light_brightness );
+      }
+      else WRITE(CASE_LIGHT_PIN, INVERT_CASE_LIGHT ? LOW : HIGH);
+    }
+    else WRITE(CASE_LIGHT_PIN, INVERT_CASE_LIGHT ? HIGH : LOW);
+  }
+#endif // HAS_CASE_LIGHT
+
+/**
+ * M355: Turn case light on/off and set brightness
+ *
+ *   P<byte>  Set case light brightness (PWM pin required - ignored otherwise)
+ *
+ *   S<bool>  Set case light on/off
+ *
+ *   When S turns on the light on a PWM pin then the current brightness level is used/restored
+ *
+ *   M355 P200 S0 turns off the light & sets the brightness level
+ *   M355 S1 turns on the light with a brightness of 200 (assuming a PWM pin)
+ */
+inline void gcode_M355() {
+  #if HAS_CASE_LIGHT
+    uint8_t args = 0;
+    if (parser.seenval('P')) ++args, case_light_brightness = parser.value_byte();
+    if (parser.seenval('S')) ++args, case_light_on = parser.value_bool();
+    if (args) update_case_light();
+
+    // always report case light status
+    SERIAL_ECHO_START();
+    if (!case_light_on) {
+      SERIAL_ECHOLN("Case light: off");
+    }
+    else {
+      if (!USEABLE_HARDWARE_PWM(CASE_LIGHT_PIN)) SERIAL_ECHOLN("Case light: on");
+      else SERIAL_ECHOLNPAIR("Case light: ", case_light_brightness);
+    }
+
+  #else
+    SERIAL_ERROR_START();
+    SERIAL_ERRORLNPGM(MSG_ERR_M355_NONE);
+  #endif // HAS_CASE_LIGHT
+}
+
+#if ENABLED(MIXING_EXTRUDER)
+
+  /**
+   * M163: Set a single mix factor for a mixing extruder
+   *       This is called "weight" by some systems.
+   *
+   *   S[index]   The channel index to set
+   *   P[float]   The mix value
+   *
+   */
+  inline void gcode_M163() {
+    const int mix_index = parser.intval('S');
+    if (mix_index < MIXING_STEPPERS) {
+      float mix_value = parser.floatval('P');
+      NOLESS(mix_value, 0.0);
+      mixing_factor[mix_index] = RECIPROCAL(mix_value);
+    }
+  }
+
+  #if MIXING_VIRTUAL_TOOLS > 1
+
+    /**
+     * M164: Store the current mix factors as a virtual tool.
+     *
+     *   S[index]   The virtual tool to store
+     *
+     */
+    inline void gcode_M164() {
+      const int tool_index = parser.intval('S');
+      if (tool_index < MIXING_VIRTUAL_TOOLS) {
+        normalize_mix();
+        for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
+          mixing_virtual_tool_mix[tool_index][i] = mixing_factor[i];
+      }
+    }
+
+  #endif
+
+  #if ENABLED(DIRECT_MIXING_IN_G1)
+    /**
+     * M165: Set multiple mix factors for a mixing extruder.
+     *       Factors that are left out will be set to 0.
+     *       All factors together must add up to 1.0.
+     *
+     *   A[factor] Mix factor for extruder stepper 1
+     *   B[factor] Mix factor for extruder stepper 2
+     *   C[factor] Mix factor for extruder stepper 3
+     *   D[factor] Mix factor for extruder stepper 4
+     *   H[factor] Mix factor for extruder stepper 5
+     *   I[factor] Mix factor for extruder stepper 6
+     *
+     */
+    inline void gcode_M165() { gcode_get_mix(); }
+  #endif
+
+#endif // MIXING_EXTRUDER
+
+/**
+ * M999: Restart after being stopped
+ *
+ * Default behaviour is to flush the serial buffer and request
+ * a resend to the host starting on the last N line received.
+ *
+ * Sending "M999 S1" will resume printing without flushing the
+ * existing command buffer.
+ *
+ */
+inline void gcode_M999() {
+  Running = true;
+  lcd_reset_alert_level();
+
+  if (parser.boolval('S')) return;
+
+  // gcode_LastN = Stopped_gcode_LastN;
+  FlushSerialRequestResend();
+}
+
+#if ENABLED(SWITCHING_EXTRUDER)
+  #if EXTRUDERS > 3
+    #define REQ_ANGLES 4
+    #define _SERVO_NR (e < 2 ? SWITCHING_EXTRUDER_SERVO_NR : SWITCHING_EXTRUDER_E23_SERVO_NR)
+  #else
+    #define REQ_ANGLES 2
+    #define _SERVO_NR SWITCHING_EXTRUDER_SERVO_NR
+  #endif
+  inline void move_extruder_servo(const uint8_t e) {
+    constexpr int16_t angles[] = SWITCHING_EXTRUDER_SERVO_ANGLES;
+    static_assert(COUNT(angles) == REQ_ANGLES, "SWITCHING_EXTRUDER_SERVO_ANGLES needs " STRINGIFY(REQ_ANGLES) " angles.");
+    stepper.synchronize();
+    #if EXTRUDERS & 1
+      if (e < EXTRUDERS - 1)
+    #endif
+    {
+      MOVE_SERVO(_SERVO_NR, angles[e]);
+      safe_delay(500);
+    }
+  }
+#endif // SWITCHING_EXTRUDER
+
+#if ENABLED(SWITCHING_NOZZLE)
+  inline void move_nozzle_servo(const uint8_t e) {
+    const int16_t angles[2] = SWITCHING_NOZZLE_SERVO_ANGLES;
+    stepper.synchronize();
+    MOVE_SERVO(SWITCHING_NOZZLE_SERVO_NR, angles[e]);
+    safe_delay(500);
+  }
+#endif
+
+inline void invalid_extruder_error(const uint8_t e) {
+  SERIAL_ECHO_START();
+  SERIAL_CHAR('T');
+  SERIAL_ECHO_F(e, DEC);
+  SERIAL_CHAR(' ');
+  SERIAL_ECHOLN(MSG_INVALID_EXTRUDER);
+}
+
+#if ENABLED(PARKING_EXTRUDER)
+
+  #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
+    #define PE_MAGNET_ON_STATE !PARKING_EXTRUDER_SOLENOIDS_PINS_ACTIVE
+  #else
+    #define PE_MAGNET_ON_STATE PARKING_EXTRUDER_SOLENOIDS_PINS_ACTIVE
+  #endif
+
+  void pe_set_magnet(const uint8_t extruder_num, const uint8_t state) {
+    switch (extruder_num) {
+      case 1: OUT_WRITE(SOL1_PIN, state); break;
+      default: OUT_WRITE(SOL0_PIN, state); break;
+    }
+    #if PARKING_EXTRUDER_SOLENOIDS_DELAY > 0
+      dwell(PARKING_EXTRUDER_SOLENOIDS_DELAY);
+    #endif
+  }
+
+  inline void pe_activate_magnet(const uint8_t extruder_num) { pe_set_magnet(extruder_num, PE_MAGNET_ON_STATE); }
+  inline void pe_deactivate_magnet(const uint8_t extruder_num) { pe_set_magnet(extruder_num, !PE_MAGNET_ON_STATE); }
+
+#endif // PARKING_EXTRUDER
+
+#if HAS_FANMUX
+
+  void fanmux_switch(const uint8_t e) {
+    WRITE(FANMUX0_PIN, TEST(e, 0) ? HIGH : LOW);
+    #if PIN_EXISTS(FANMUX1)
+      WRITE(FANMUX1_PIN, TEST(e, 1) ? HIGH : LOW);
+      #if PIN_EXISTS(FANMUX2)
+        WRITE(FANMUX2, TEST(e, 2) ? HIGH : LOW);
+      #endif
+    #endif
+  }
+
+  FORCE_INLINE void fanmux_init(void){
+    SET_OUTPUT(FANMUX0_PIN);
+    #if PIN_EXISTS(FANMUX1)
+      SET_OUTPUT(FANMUX1_PIN);
+      #if PIN_EXISTS(FANMUX2)
+        SET_OUTPUT(FANMUX2_PIN);
+      #endif
+    #endif
+    fanmux_switch(0);
+  }
+
+#endif // HAS_FANMUX
+
+/**
+ * Perform a tool-change, which may result in moving the
+ * previous tool out of the way and the new tool into place.
+ */
+void tool_change(const uint8_t tmp_extruder, const float fr_mm_s/*=0.0*/, bool no_move/*=false*/) {
+  #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
+
+    if (tmp_extruder >= MIXING_VIRTUAL_TOOLS)
+      return invalid_extruder_error(tmp_extruder);
+
+    // T0-Tnnn: Switch virtual tool by changing the mix
+    for (uint8_t j = 0; j < MIXING_STEPPERS; j++)
+      mixing_factor[j] = mixing_virtual_tool_mix[tmp_extruder][j];
+
+  #else // !MIXING_EXTRUDER || MIXING_VIRTUAL_TOOLS <= 1
+
+    if (tmp_extruder >= EXTRUDERS)
+      return invalid_extruder_error(tmp_extruder);
+
+    #if HOTENDS > 1
+
+      const float old_feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : feedrate_mm_s;
+
+      feedrate_mm_s = fr_mm_s > 0.0 ? fr_mm_s : XY_PROBE_FEEDRATE_MM_S;
+
+      if (tmp_extruder != active_extruder) {
+        if (!no_move && axis_unhomed_error()) {
+          no_move = true;
+          #if ENABLED(DEBUG_LEVELING_FEATURE)
+            if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("No move on toolchange");
+          #endif
+        }
+
+        // Save current position to destination, for use later
+        set_destination_to_current();
+
+        #if ENABLED(DUAL_X_CARRIAGE)
+
+          #if ENABLED(DEBUG_LEVELING_FEATURE)
+            if (DEBUGGING(LEVELING)) {
+              SERIAL_ECHOPGM("Dual X Carriage Mode ");
+              switch (dual_x_carriage_mode) {
+                case DXC_FULL_CONTROL_MODE: SERIAL_ECHOLNPGM("DXC_FULL_CONTROL_MODE"); break;
+                case DXC_AUTO_PARK_MODE: SERIAL_ECHOLNPGM("DXC_AUTO_PARK_MODE"); break;
+                case DXC_DUPLICATION_MODE: SERIAL_ECHOLNPGM("DXC_DUPLICATION_MODE"); break;
+              }
+            }
+          #endif
+
+          const float xhome = x_home_pos(active_extruder);
+          if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE
+              && IsRunning()
+              && (delayed_move_time || current_position[X_AXIS] != xhome)
+          ) {
+            float raised_z = current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT;
+            #if ENABLED(MAX_SOFTWARE_ENDSTOPS)
+              NOMORE(raised_z, soft_endstop_max[Z_AXIS]);
+            #endif
+            #if ENABLED(DEBUG_LEVELING_FEATURE)
+              if (DEBUGGING(LEVELING)) {
+                SERIAL_ECHOLNPAIR("Raise to ", raised_z);
+                SERIAL_ECHOLNPAIR("MoveX to ", xhome);
+                SERIAL_ECHOLNPAIR("Lower to ", current_position[Z_AXIS]);
+              }
+            #endif
+            // Park old head: 1) raise 2) move to park position 3) lower
+            for (uint8_t i = 0; i < 3; i++)
+              planner.buffer_line(
+                i == 0 ? current_position[X_AXIS] : xhome,
+                current_position[Y_AXIS],
+                i == 2 ? current_position[Z_AXIS] : raised_z,
+                current_position[E_AXIS],
+                planner.max_feedrate_mm_s[i == 1 ? X_AXIS : Z_AXIS],
+                active_extruder
+              );
+            stepper.synchronize();
+          }
+
+          // Apply Y & Z extruder offset (X offset is used as home pos with Dual X)
+          current_position[Y_AXIS] -= hotend_offset[Y_AXIS][active_extruder] - hotend_offset[Y_AXIS][tmp_extruder];
+          current_position[Z_AXIS] -= hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
+
+          // Activate the new extruder ahead of calling set_axis_is_at_home!
+          active_extruder = tmp_extruder;
+
+          // This function resets the max/min values - the current position may be overwritten below.
+          set_axis_is_at_home(X_AXIS);
+
+          #if ENABLED(DEBUG_LEVELING_FEATURE)
+            if (DEBUGGING(LEVELING)) DEBUG_POS("New Extruder", current_position);
+          #endif
+
+          // Only when auto-parking are carriages safe to move
+          if (dual_x_carriage_mode != DXC_AUTO_PARK_MODE) no_move = true;
+
+          switch (dual_x_carriage_mode) {
+            case DXC_FULL_CONTROL_MODE:
+              // New current position is the position of the activated extruder
+              current_position[X_AXIS] = LOGICAL_X_POSITION(inactive_extruder_x_pos);
+              // Save the inactive extruder's position (from the old current_position)
+              inactive_extruder_x_pos = RAW_X_POSITION(destination[X_AXIS]);
+              break;
+            case DXC_AUTO_PARK_MODE:
+              // record raised toolhead position for use by unpark
+              COPY(raised_parked_position, current_position);
+              raised_parked_position[Z_AXIS] += TOOLCHANGE_UNPARK_ZLIFT;
+              #if ENABLED(MAX_SOFTWARE_ENDSTOPS)
+                NOMORE(raised_parked_position[Z_AXIS], soft_endstop_max[Z_AXIS]);
+              #endif
+              active_extruder_parked = true;
+              delayed_move_time = 0;
+              break;
+            case DXC_DUPLICATION_MODE:
+              // If the new extruder is the left one, set it "parked"
+              // This triggers the second extruder to move into the duplication position
+              active_extruder_parked = (active_extruder == 0);
+
+              if (active_extruder_parked)
+                current_position[X_AXIS] = LOGICAL_X_POSITION(inactive_extruder_x_pos);
+              else
+                current_position[X_AXIS] = destination[X_AXIS] + duplicate_extruder_x_offset;
+              inactive_extruder_x_pos = RAW_X_POSITION(destination[X_AXIS]);
+              extruder_duplication_enabled = false;
+              #if ENABLED(DEBUG_LEVELING_FEATURE)
+                if (DEBUGGING(LEVELING)) {
+                  SERIAL_ECHOLNPAIR("Set inactive_extruder_x_pos=", inactive_extruder_x_pos);
+                  SERIAL_ECHOLNPGM("Clear extruder_duplication_enabled");
+                }
+              #endif
+              break;
+          }
+
+          #if ENABLED(DEBUG_LEVELING_FEATURE)
+            if (DEBUGGING(LEVELING)) {
+              SERIAL_ECHOLNPAIR("Active extruder parked: ", active_extruder_parked ? "yes" : "no");
+              DEBUG_POS("New extruder (parked)", current_position);
+            }
+          #endif
+
+          // No extra case for HAS_ABL in DUAL_X_CARRIAGE. Does that mean they don't work together?
+
+        #else // !DUAL_X_CARRIAGE
+
+          #if ENABLED(PARKING_EXTRUDER) // Dual Parking extruder
+            const float z_diff = hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder];
+            float z_raise = 0;
+            if (!no_move) {
+
+              const float parkingposx[] = PARKING_EXTRUDER_PARKING_X,
+                          midpos = ((parkingposx[1] - parkingposx[0])/2) + parkingposx[0] + hotend_offset[X_AXIS][active_extruder],
+                          grabpos = parkingposx[tmp_extruder] + hotend_offset[X_AXIS][active_extruder]
+                                    + (tmp_extruder == 0 ? -(PARKING_EXTRUDER_GRAB_DISTANCE) : PARKING_EXTRUDER_GRAB_DISTANCE);
+              /**
+               *  Steps:
+               *    1. raise Z-Axis to have enough clearance
+               *    2. move to park poition of old extruder
+               *    3. disengage magnetc field, wait for delay
+               *    4. move near new extruder
+               *    5. engage magnetic field for new extruder
+               *    6. move to parking incl. offset of new extruder
+               *    7. lower Z-Axis
+               */
+
+              // STEP 1
+              #if ENABLED(DEBUG_LEVELING_FEATURE)
+                SERIAL_ECHOLNPGM("Starting Autopark");
+                if (DEBUGGING(LEVELING)) DEBUG_POS("current position:", current_position);
+              #endif
+              z_raise = PARKING_EXTRUDER_SECURITY_RAISE;
+              current_position[Z_AXIS] += z_raise;
+              #if ENABLED(DEBUG_LEVELING_FEATURE)
+                SERIAL_ECHOLNPGM("(1) Raise Z-Axis ");
+                if (DEBUGGING(LEVELING)) DEBUG_POS("Moving to Raised Z-Position", current_position);
+              #endif
+              planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
+              stepper.synchronize();
+
+              // STEP 2
+              current_position[X_AXIS] = parkingposx[active_extruder] + hotend_offset[X_AXIS][active_extruder];
+              #if ENABLED(DEBUG_LEVELING_FEATURE)
+                SERIAL_ECHOLNPAIR("(2) Park extruder ", active_extruder);
+                if (DEBUGGING(LEVELING)) DEBUG_POS("Moving ParkPos", current_position);
+              #endif
+              planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
+              stepper.synchronize();
+
+              // STEP 3
+              #if ENABLED(DEBUG_LEVELING_FEATURE)
+                SERIAL_ECHOLNPGM("(3) Disengage magnet ");
+              #endif
+              pe_deactivate_magnet(active_extruder);
+
+              // STEP 4
+              #if ENABLED(DEBUG_LEVELING_FEATURE)
+                SERIAL_ECHOLNPGM("(4) Move to position near new extruder");
+              #endif
+              current_position[X_AXIS] += (active_extruder == 0 ? 10 : -10); // move 10mm away from parked extruder
+
+              #if ENABLED(DEBUG_LEVELING_FEATURE)
+                if (DEBUGGING(LEVELING)) DEBUG_POS("Moving away from parked extruder", current_position);
+              #endif
+              planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
+              stepper.synchronize();
+
+              // STEP 5
+              #if ENABLED(DEBUG_LEVELING_FEATURE)
+                SERIAL_ECHOLNPGM("(5) Engage magnetic field");
+              #endif
+
+              #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
+                pe_activate_magnet(active_extruder); //just save power for inverted magnets
+              #endif
+              pe_activate_magnet(tmp_extruder);
+
+              // STEP 6
+              current_position[X_AXIS] = grabpos + (tmp_extruder == 0 ? (+10) : (-10));
+              planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
+              current_position[X_AXIS] = grabpos;
+              #if ENABLED(DEBUG_LEVELING_FEATURE)
+                SERIAL_ECHOLNPAIR("(6) Unpark extruder ", tmp_extruder);
+                if (DEBUGGING(LEVELING)) DEBUG_POS("Move UnparkPos", current_position);
+              #endif
+              planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS]/2, active_extruder);
+              stepper.synchronize();
+
+              // Step 7
+              current_position[X_AXIS] = midpos - hotend_offset[X_AXIS][tmp_extruder];
+              #if ENABLED(DEBUG_LEVELING_FEATURE)
+                SERIAL_ECHOLNPGM("(7) Move midway between hotends");
+                if (DEBUGGING(LEVELING)) DEBUG_POS("Move midway to new extruder", current_position);
+              #endif
+              planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[X_AXIS], active_extruder);
+              stepper.synchronize();
+              #if ENABLED(DEBUG_LEVELING_FEATURE)
+                SERIAL_ECHOLNPGM("Autopark done.");
+              #endif
+            }
+            else { // nomove == true
+              // Only engage magnetic field for new extruder
+              pe_activate_magnet(tmp_extruder);
+              #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
+                pe_activate_magnet(active_extruder); // Just save power for inverted magnets
+              #endif
+            }
+            current_position[Z_AXIS] -= hotend_offset[Z_AXIS][tmp_extruder] - hotend_offset[Z_AXIS][active_extruder]; // Apply Zoffset
+
+            #if ENABLED(DEBUG_LEVELING_FEATURE)
+              if (DEBUGGING(LEVELING)) DEBUG_POS("Applying Z-offset", current_position);
+            #endif
+
+          #endif // dualParking extruder
+
+          #if ENABLED(SWITCHING_NOZZLE)
+            #define DONT_SWITCH (SWITCHING_EXTRUDER_SERVO_NR == SWITCHING_NOZZLE_SERVO_NR)
+            // <0 if the new nozzle is higher, >0 if lower. A bigger raise when lower.
+            const float z_diff = hotend_offset[Z_AXIS][active_extruder] - hotend_offset[Z_AXIS][tmp_extruder],
+                        z_raise = 0.3 + (z_diff > 0.0 ? z_diff : 0.0);
+
+            // Always raise by some amount (destination copied from current_position earlier)
+            current_position[Z_AXIS] += z_raise;
+            planner.buffer_line_kinematic(current_position, planner.max_feedrate_mm_s[Z_AXIS], active_extruder);
+            move_nozzle_servo(tmp_extruder);
+          #endif
+
+          /**
+           * Set current_position to the position of the new nozzle.
+           * Offsets are based on linear distance, so we need to get
+           * the resulting position in coordinate space.
+           *
+           * - With grid or 3-point leveling, offset XYZ by a tilted vector
+           * - With mesh leveling, update Z for the new position
+           * - Otherwise, just use the raw linear distance
+           *
+           * Software endstops are altered here too. Consider a case where:
+           *   E0 at X=0 ... E1 at X=10
+           * When we switch to E1 now X=10, but E1 can't move left.
+           * To express this we apply the change in XY to the software endstops.
+           * E1 can move farther right than E0, so the right limit is extended.
+           *
+           * Note that we don't adjust the Z software endstops. Why not?
+           * Consider a case where Z=0 (here) and switching to E1 makes Z=1
+           * because the bed is 1mm lower at the new position. As long as
+           * the first nozzle is out of the way, the carriage should be
+           * allowed to move 1mm lower. This technically "breaks" the
+           * Z software endstop. But this is technically correct (and
+           * there is no viable alternative).
+           */
+          #if ABL_PLANAR
+            // Offset extruder, make sure to apply the bed level rotation matrix
+            vector_3 tmp_offset_vec = vector_3(hotend_offset[X_AXIS][tmp_extruder],
+                                               hotend_offset[Y_AXIS][tmp_extruder],
+                                               0),
+                     act_offset_vec = vector_3(hotend_offset[X_AXIS][active_extruder],
+                                               hotend_offset[Y_AXIS][active_extruder],
+                                               0),
+                     offset_vec = tmp_offset_vec - act_offset_vec;
+
+            #if ENABLED(DEBUG_LEVELING_FEATURE)
+              if (DEBUGGING(LEVELING)) {
+                tmp_offset_vec.debug(PSTR("tmp_offset_vec"));
+                act_offset_vec.debug(PSTR("act_offset_vec"));
+                offset_vec.debug(PSTR("offset_vec (BEFORE)"));
+              }
+            #endif
+
+            offset_vec.apply_rotation(planner.bed_level_matrix.transpose(planner.bed_level_matrix));
+
+            #if ENABLED(DEBUG_LEVELING_FEATURE)
+              if (DEBUGGING(LEVELING)) offset_vec.debug(PSTR("offset_vec (AFTER)"));
+            #endif
+
+            // Adjustments to the current position
+            const float xydiff[2] = { offset_vec.x, offset_vec.y };
+            current_position[Z_AXIS] += offset_vec.z;
+
+          #else // !ABL_PLANAR
+
+            const float xydiff[2] = {
+              hotend_offset[X_AXIS][tmp_extruder] - hotend_offset[X_AXIS][active_extruder],
+              hotend_offset[Y_AXIS][tmp_extruder] - hotend_offset[Y_AXIS][active_extruder]
+            };
+
+            #if ENABLED(MESH_BED_LEVELING)
+
+              if (leveling_is_active()) {
+                #if ENABLED(DEBUG_LEVELING_FEATURE)
+                  if (DEBUGGING(LEVELING)) SERIAL_ECHOPAIR("Z before MBL: ", current_position[Z_AXIS]);
+                #endif
+                float x2 = current_position[X_AXIS] + xydiff[X_AXIS],
+                      y2 = current_position[Y_AXIS] + xydiff[Y_AXIS],
+                      z1 = current_position[Z_AXIS], z2 = z1;
+                planner.apply_leveling(current_position[X_AXIS], current_position[Y_AXIS], z1);
+                planner.apply_leveling(x2, y2, z2);
+                current_position[Z_AXIS] += z2 - z1;
+                #if ENABLED(DEBUG_LEVELING_FEATURE)
+                  if (DEBUGGING(LEVELING))
+                    SERIAL_ECHOLNPAIR(" after: ", current_position[Z_AXIS]);
+                #endif
+              }
+
+            #endif // MESH_BED_LEVELING
+
+          #endif // !HAS_ABL
+
+          #if ENABLED(DEBUG_LEVELING_FEATURE)
+            if (DEBUGGING(LEVELING)) {
+              SERIAL_ECHOPAIR("Offset Tool XY by { ", xydiff[X_AXIS]);
+              SERIAL_ECHOPAIR(", ", xydiff[Y_AXIS]);
+              SERIAL_ECHOLNPGM(" }");
+            }
+          #endif
+
+          // The newly-selected extruder XY is actually at...
+          current_position[X_AXIS] += xydiff[X_AXIS];
+          current_position[Y_AXIS] += xydiff[Y_AXIS];
+          #if HAS_WORKSPACE_OFFSET || ENABLED(DUAL_X_CARRIAGE) || ENABLED(PARKING_EXTRUDER)
+            for (uint8_t i = X_AXIS; i <= Y_AXIS; i++) {
+              #if HAS_POSITION_SHIFT
+                position_shift[i] += xydiff[i];
+              #endif
+              update_software_endstops((AxisEnum)i);
+            }
+          #endif
+
+          // Set the new active extruder
+          active_extruder = tmp_extruder;
+
+        #endif // !DUAL_X_CARRIAGE
+
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) DEBUG_POS("Sync After Toolchange", current_position);
+        #endif
+
+        // Tell the planner the new "current position"
+        SYNC_PLAN_POSITION_KINEMATIC();
+
+        // Move to the "old position" (move the extruder into place)
+        if (!no_move && IsRunning()) {
+          #if ENABLED(DEBUG_LEVELING_FEATURE)
+            if (DEBUGGING(LEVELING)) DEBUG_POS("Move back", destination);
+          #endif
+          prepare_move_to_destination();
+        }
+
+        #if ENABLED(SWITCHING_NOZZLE)
+          // Move back down, if needed. (Including when the new tool is higher.)
+          if (z_raise != z_diff) {
+            destination[Z_AXIS] += z_diff;
+            feedrate_mm_s = planner.max_feedrate_mm_s[Z_AXIS];
+            prepare_move_to_destination();
+          }
+        #endif
+
+      } // (tmp_extruder != active_extruder)
+
+      stepper.synchronize();
+
+      #if ENABLED(EXT_SOLENOID) && !ENABLED(PARKING_EXTRUDER)
+        disable_all_solenoids();
+        enable_solenoid_on_active_extruder();
+      #endif // EXT_SOLENOID
+
+      feedrate_mm_s = old_feedrate_mm_s;
+
+    #else // HOTENDS <= 1
+
+      UNUSED(fr_mm_s);
+      UNUSED(no_move);
+
+      #if ENABLED(MK2_MULTIPLEXER)
+        if (tmp_extruder >= E_STEPPERS)
+          return invalid_extruder_error(tmp_extruder);
+
+        select_multiplexed_stepper(tmp_extruder);
+      #endif
+
+      // Set the new active extruder
+      active_extruder = tmp_extruder;
+
+    #endif // HOTENDS <= 1
+
+    #if ENABLED(SWITCHING_EXTRUDER) && !DONT_SWITCH
+      stepper.synchronize();
+      move_extruder_servo(active_extruder);
+    #endif
+
+    #if HAS_FANMUX
+      fanmux_switch(active_extruder);
+    #endif
+
+    SERIAL_ECHO_START();
+    SERIAL_ECHOLNPAIR(MSG_ACTIVE_EXTRUDER, (int)active_extruder);
+
+  #endif // !MIXING_EXTRUDER || MIXING_VIRTUAL_TOOLS <= 1
+}
+
+/**
+ * T0-T3: Switch tool, usually switching extruders
+ *
+ *   F[units/min] Set the movement feedrate
+ *   S1           Don't move the tool in XY after change
+ */
+inline void gcode_T(uint8_t tmp_extruder) {
+
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) {
+      SERIAL_ECHOPAIR(">>> gcode_T(", tmp_extruder);
+      SERIAL_CHAR(')');
+      SERIAL_EOL();
+      DEBUG_POS("BEFORE", current_position);
+    }
+  #endif
+
+  #if HOTENDS == 1 || (ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1)
+
+    tool_change(tmp_extruder);
+
+  #elif HOTENDS > 1
+
+    tool_change(
+      tmp_extruder,
+      MMM_TO_MMS(parser.linearval('F')),
+      (tmp_extruder == active_extruder) || parser.boolval('S')
+    );
+
+  #endif
+
+  #if ENABLED(DEBUG_LEVELING_FEATURE)
+    if (DEBUGGING(LEVELING)) {
+      DEBUG_POS("AFTER", current_position);
+      SERIAL_ECHOLNPGM("<<< gcode_T");
+    }
+  #endif
+}
+
+/**
+ * Process a single command and dispatch it to its handler
+ * This is called from the main loop()
+ */
+void process_next_command() {
+  char * const current_command = command_queue[cmd_queue_index_r];
+
+  if (DEBUGGING(ECHO)) {
+    SERIAL_ECHO_START();
+    SERIAL_ECHOLN(current_command);
+    #if ENABLED(M100_FREE_MEMORY_WATCHER)
+      SERIAL_ECHOPAIR("slot:", cmd_queue_index_r);
+      M100_dump_routine("   Command Queue:", (const char*)command_queue, (const char*)(command_queue + sizeof(command_queue)));
+    #endif
+  }
+
+  KEEPALIVE_STATE(IN_HANDLER);
+
+  // Parse the next command in the queue
+  parser.parse(current_command);
+
+  // Handle a known G, M, or T
+  switch (parser.command_letter) {
+    case 'G': switch (parser.codenum) {
+
+      // G0, G1
+      case 0:
+      case 1:
+        #if IS_SCARA
+          gcode_G0_G1(parser.codenum == 0);
+        #else
+          gcode_G0_G1();
+        #endif
+        break;
+
+      // G2, G3
+      #if ENABLED(ARC_SUPPORT) && DISABLED(SCARA)
+        case 2: // G2: CW ARC
+        case 3: // G3: CCW ARC
+          gcode_G2_G3(parser.codenum == 2);
+          break;
+      #endif
+
+      // G4 Dwell
+      case 4:
+        gcode_G4();
+        break;
+
+      #if ENABLED(BEZIER_CURVE_SUPPORT)
+        case 5: // G5: Cubic B_spline
+          gcode_G5();
+          break;
+      #endif // BEZIER_CURVE_SUPPORT
+
+      #if ENABLED(FWRETRACT)
+        case 10: // G10: retract
+          gcode_G10();
+          break;
+        case 11: // G11: retract_recover
+          gcode_G11();
+          break;
+      #endif // FWRETRACT
+
+      #if ENABLED(NOZZLE_CLEAN_FEATURE)
+        case 12:
+          gcode_G12(); // G12: Nozzle Clean
+          break;
+      #endif // NOZZLE_CLEAN_FEATURE
+
+      #if ENABLED(CNC_WORKSPACE_PLANES)
+        case 17: // G17: Select Plane XY
+          gcode_G17();
+          break;
+        case 18: // G18: Select Plane ZX
+          gcode_G18();
+          break;
+        case 19: // G19: Select Plane YZ
+          gcode_G19();
+          break;
+      #endif // CNC_WORKSPACE_PLANES
+
+      #if ENABLED(INCH_MODE_SUPPORT)
+        case 20: // G20: Inch Mode
+          gcode_G20();
+          break;
+
+        case 21: // G21: MM Mode
+          gcode_G21();
+          break;
+      #endif // INCH_MODE_SUPPORT
+
+      #if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(UBL_G26_MESH_VALIDATION)
+        case 26: // G26: Mesh Validation Pattern generation
+          gcode_G26();
+          break;
+      #endif // AUTO_BED_LEVELING_UBL
+
+      #if ENABLED(NOZZLE_PARK_FEATURE)
+        case 27: // G27: Nozzle Park
+          gcode_G27();
+          break;
+      #endif // NOZZLE_PARK_FEATURE
+
+      case 28: // G28: Home all axes, one at a time
+        gcode_G28(false);
+        break;
+
+      #if HAS_LEVELING
+        case 29: // G29 Detailed Z probe, probes the bed at 3 or more points,
+                 // or provides access to the UBL System if enabled.
+          gcode_G29();
+          break;
+      #endif // HAS_LEVELING
+
+      #if HAS_BED_PROBE
+
+        case 30: // G30 Single Z probe
+          gcode_G30();
+          break;
+
+        #if ENABLED(Z_PROBE_SLED)
+
+            case 31: // G31: dock the sled
+              gcode_G31();
+              break;
+
+            case 32: // G32: undock the sled
+              gcode_G32();
+              break;
+
+        #endif // Z_PROBE_SLED
+
+      #endif // HAS_BED_PROBE
+
+      #if PROBE_SELECTED
+
+        #if ENABLED(DELTA_AUTO_CALIBRATION)
+
+          case 33: // G33: Delta Auto-Calibration
+            gcode_G33();
+            break;
+
+        #endif // DELTA_AUTO_CALIBRATION
+
+      #endif // PROBE_SELECTED
+
+      #if ENABLED(G38_PROBE_TARGET)
+        case 38: // G38.2 & G38.3
+          if (parser.subcode == 2 || parser.subcode == 3)
+            gcode_G38(parser.subcode == 2);
+          break;
+      #endif
+
+      case 90: // G90
+        relative_mode = false;
+        break;
+      case 91: // G91
+        relative_mode = true;
+        break;
+
+      case 92: // G92
+        gcode_G92();
+        break;
+
+      #if ENABLED(AUTO_BED_LEVELING_BILINEAR) || ENABLED(AUTO_BED_LEVELING_UBL) || ENABLED(MESH_BED_LEVELING)
+        case 42:
+          gcode_G42();
+          break;
+      #endif
+
+      #if ENABLED(DEBUG_GCODE_PARSER)
+        case 800:
+          parser.debug(); // GCode Parser Test for G
+          break;
+      #endif
+    }
+    break;
+
+    case 'M': switch (parser.codenum) {
+      #if HAS_RESUME_CONTINUE
+        case 0: // M0: Unconditional stop - Wait for user button press on LCD
+        case 1: // M1: Conditional stop - Wait for user button press on LCD
+          gcode_M0_M1();
+          break;
+      #endif // ULTIPANEL
+
+      #if ENABLED(SPINDLE_LASER_ENABLE)
+        case 3:
+          gcode_M3_M4(true);   // M3: turn spindle/laser on, set laser/spindle power/speed, set rotation direction CW
+          break;               // synchronizes with movement commands
+        case 4:
+          gcode_M3_M4(false);  // M4: turn spindle/laser on, set laser/spindle power/speed, set rotation direction CCW
+          break;               // synchronizes with movement commands
+        case 5:
+          gcode_M5();     // M5 - turn spindle/laser off
+          break;          // synchronizes with movement commands
+      #endif
+      case 17: // M17: Enable all stepper motors
+        gcode_M17();
+        break;
+
+      #if ENABLED(SDSUPPORT)
+        case 20: // M20: list SD card
+          gcode_M20(); break;
+        case 21: // M21: init SD card
+          gcode_M21(); break;
+        case 22: // M22: release SD card
+          gcode_M22(); break;
+        case 23: // M23: Select file
+          gcode_M23(); break;
+        case 24: // M24: Start SD print
+          gcode_M24(); break;
+        case 25: // M25: Pause SD print
+          gcode_M25(); break;
+        case 26: // M26: Set SD index
+          gcode_M26(); break;
+        case 27: // M27: Get SD status
+          gcode_M27(); break;
+        case 28: // M28: Start SD write
+          gcode_M28(); break;
+        case 29: // M29: Stop SD write
+          gcode_M29(); break;
+        case 30: // M30 <filename> Delete File
+          gcode_M30(); break;
+        case 32: // M32: Select file and start SD print
+          gcode_M32(); break;
+
+        #if ENABLED(LONG_FILENAME_HOST_SUPPORT)
+          case 33: // M33: Get the long full path to a file or folder
+            gcode_M33(); break;
+        #endif
+
+        #if ENABLED(SDCARD_SORT_ALPHA) && ENABLED(SDSORT_GCODE)
+          case 34: // M34: Set SD card sorting options
+            gcode_M34(); break;
+        #endif // SDCARD_SORT_ALPHA && SDSORT_GCODE
+
+        case 928: // M928: Start SD write
+          gcode_M928(); break;
+      #endif // SDSUPPORT
+
+      case 31: // M31: Report time since the start of SD print or last M109
+        gcode_M31(); break;
+
+      case 42: // M42: Change pin state
+        gcode_M42(); break;
+
+      #if ENABLED(PINS_DEBUGGING)
+        case 43: // M43: Read pin state
+          gcode_M43(); break;
+      #endif
+
+
+      #if ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)
+        case 48: // M48: Z probe repeatability test
+          gcode_M48();
+          break;
+      #endif // Z_MIN_PROBE_REPEATABILITY_TEST
+
+      #if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(UBL_G26_MESH_VALIDATION)
+        case 49: // M49: Turn on or off G26 debug flag for verbose output
+          gcode_M49();
+          break;
+      #endif // AUTO_BED_LEVELING_UBL && UBL_G26_MESH_VALIDATION
+
+      case 75: // M75: Start print timer
+        gcode_M75(); break;
+      case 76: // M76: Pause print timer
+        gcode_M76(); break;
+      case 77: // M77: Stop print timer
+        gcode_M77(); break;
+
+      #if ENABLED(PRINTCOUNTER)
+        case 78: // M78: Show print statistics
+          gcode_M78(); break;
+      #endif
+
+      #if ENABLED(M100_FREE_MEMORY_WATCHER)
+        case 100: // M100: Free Memory Report
+          gcode_M100();
+          break;
+      #endif
+
+      case 104: // M104: Set hot end temperature
+        gcode_M104();
+        break;
+
+      case 110: // M110: Set Current Line Number
+        gcode_M110();
+        break;
+
+      case 111: // M111: Set debug level
+        gcode_M111();
+        break;
+
+      #if DISABLED(EMERGENCY_PARSER)
+
+        case 108: // M108: Cancel Waiting
+          gcode_M108();
+          break;
+
+        case 112: // M112: Emergency Stop
+          gcode_M112();
+          break;
+
+        case 410: // M410 quickstop - Abort all the planned moves.
+          gcode_M410();
+          break;
+
+      #endif
+
+      #if ENABLED(HOST_KEEPALIVE_FEATURE)
+        case 113: // M113: Set Host Keepalive interval
+          gcode_M113();
+          break;
+      #endif
+
+      case 140: // M140: Set bed temperature
+        gcode_M140();
+        break;
+
+
+      case 105: // M105: Report current temperature
+        gcode_M105();
+        KEEPALIVE_STATE(NOT_BUSY);
+        return; // "ok" already printed
+
+      #if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND || HAS_TEMP_BED)
+        case 155: // M155: Set temperature auto-report interval
+          gcode_M155();
+          break;
+      #endif
+
+      case 109: // M109: Wait for hotend temperature to reach target
+        gcode_M109();
+        break;
+
+      #if HAS_TEMP_BED
+        case 190: // M190: Wait for bed temperature to reach target
+          gcode_M190();
+          break;
+      #endif // HAS_TEMP_BED
+
+      #if FAN_COUNT > 0
+        case 106: // M106: Fan On
+          gcode_M106();
+          break;
+        case 107: // M107: Fan Off
+          gcode_M107();
+          break;
+      #endif // FAN_COUNT > 0
+
+      #if ENABLED(PARK_HEAD_ON_PAUSE)
+        case 125: // M125: Store current position and move to filament change position
+          gcode_M125(); break;
+      #endif
+
+      #if ENABLED(BARICUDA)
+        // PWM for HEATER_1_PIN
+        #if HAS_HEATER_1
+          case 126: // M126: valve open
+            gcode_M126();
+            break;
+          case 127: // M127: valve closed
+            gcode_M127();
+            break;
+        #endif // HAS_HEATER_1
+
+        // PWM for HEATER_2_PIN
+        #if HAS_HEATER_2
+          case 128: // M128: valve open
+            gcode_M128();
+            break;
+          case 129: // M129: valve closed
+            gcode_M129();
+            break;
+        #endif // HAS_HEATER_2
+      #endif // BARICUDA
+
+      #if HAS_POWER_SWITCH
+
+        case 80: // M80: Turn on Power Supply
+          gcode_M80();
+          break;
+
+      #endif // HAS_POWER_SWITCH
+
+      case 81: // M81: Turn off Power, including Power Supply, if possible
+        gcode_M81();
+        break;
+
+      case 82: // M82: Set E axis normal mode (same as other axes)
+        gcode_M82();
+        break;
+      case 83: // M83: Set E axis relative mode
+        gcode_M83();
+        break;
+      case 18: // M18 => M84
+      case 84: // M84: Disable all steppers or set timeout
+        gcode_M18_M84();
+        break;
+      case 85: // M85: Set inactivity stepper shutdown timeout
+        gcode_M85();
+        break;
+      case 92: // M92: Set the steps-per-unit for one or more axes
+        gcode_M92();
+        break;
+      case 114: // M114: Report current position
+        gcode_M114();
+        break;
+      case 115: // M115: Report capabilities
+        gcode_M115();
+        break;
+      case 117: // M117: Set LCD message text, if possible
+        gcode_M117();
+        break;
+      case 118: // M118: Display a message in the host console
+        gcode_M118();
+        break;
+      case 119: // M119: Report endstop states
+        gcode_M119();
+        break;
+      case 120: // M120: Enable endstops
+        gcode_M120();
+        break;
+      case 121: // M121: Disable endstops
+        gcode_M121();
+        break;
+
+      #if ENABLED(ULTIPANEL)
+
+        case 145: // M145: Set material heatup parameters
+          gcode_M145();
+          break;
+
+      #endif
+
+      #if ENABLED(TEMPERATURE_UNITS_SUPPORT)
+        case 149: // M149: Set temperature units
+          gcode_M149();
+          break;
+      #endif
+
+      #if HAS_COLOR_LEDS
+
+        case 150: // M150: Set Status LED Color
+          gcode_M150();
+          break;
+
+      #endif // HAS_COLOR_LEDS
+
+      #if ENABLED(MIXING_EXTRUDER)
+        case 163: // M163: Set a component weight for mixing extruder
+          gcode_M163();
+          break;
+        #if MIXING_VIRTUAL_TOOLS > 1
+          case 164: // M164: Save current mix as a virtual extruder
+            gcode_M164();
+            break;
+        #endif
+        #if ENABLED(DIRECT_MIXING_IN_G1)
+          case 165: // M165: Set multiple mix weights
+            gcode_M165();
+            break;
+        #endif
+      #endif
+
+      case 200: // M200: Set filament diameter, E to cubic units
+        gcode_M200();
+        break;
+      case 201: // M201: Set max acceleration for print moves (units/s^2)
+        gcode_M201();
+        break;
+      #if 0 // Not used for Sprinter/grbl gen6
+        case 202: // M202
+          gcode_M202();
+          break;
+      #endif
+      case 203: // M203: Set max feedrate (units/sec)
+        gcode_M203();
+        break;
+      case 204: // M204: Set acceleration
+        gcode_M204();
+        break;
+      case 205: // M205: Set advanced settings
+        gcode_M205();
+        break;
+
+      #if HAS_M206_COMMAND
+        case 206: // M206: Set home offsets
+          gcode_M206();
+          break;
+      #endif
+
+      #if ENABLED(DELTA)
+        case 665: // M665: Set delta configurations
+          gcode_M665();
+          break;
+      #endif
+
+      #if ENABLED(DELTA) || ENABLED(Z_DUAL_ENDSTOPS)
+        case 666: // M666: Set delta or dual endstop adjustment
+          gcode_M666();
+          break;
+      #endif
+
+      #if ENABLED(FWRETRACT)
+        case 207: // M207: Set Retract Length, Feedrate, and Z lift
+          gcode_M207();
+          break;
+        case 208: // M208: Set Recover (unretract) Additional Length and Feedrate
+          gcode_M208();
+          break;
+        case 209: // M209: Turn Automatic Retract Detection on/off
+          if (MIN_AUTORETRACT <= MAX_AUTORETRACT) gcode_M209();
+          break;
+      #endif // FWRETRACT
+
+      case 211: // M211: Enable, Disable, and/or Report software endstops
+        gcode_M211();
+        break;
+
+      #if HOTENDS > 1
+        case 218: // M218: Set a tool offset
+          gcode_M218();
+          break;
+      #endif
+
+      case 220: // M220: Set Feedrate Percentage: S<percent> ("FR" on your LCD)
+        gcode_M220();
+        break;
+
+      case 221: // M221: Set Flow Percentage
+        gcode_M221();
+        break;
+
+      case 226: // M226: Wait until a pin reaches a state
+        gcode_M226();
+        break;
+
+      #if HAS_SERVOS
+        case 280: // M280: Set servo position absolute
+          gcode_M280();
+          break;
+      #endif // HAS_SERVOS
+
+      #if HAS_BUZZER
+        case 300: // M300: Play beep tone
+          gcode_M300();
+          break;
+      #endif // HAS_BUZZER
+
+      #if ENABLED(PIDTEMP)
+        case 301: // M301: Set hotend PID parameters
+          gcode_M301();
+          break;
+      #endif // PIDTEMP
+
+      #if ENABLED(PIDTEMPBED)
+        case 304: // M304: Set bed PID parameters
+          gcode_M304();
+          break;
+      #endif // PIDTEMPBED
+
+      #if defined(CHDK) || HAS_PHOTOGRAPH
+        case 240: // M240: Trigger a camera by emulating a Canon RC-1 : http://www.doc-diy.net/photo/rc-1_hacked/
+          gcode_M240();
+          break;
+      #endif // CHDK || PHOTOGRAPH_PIN
+
+      #if HAS_LCD_CONTRAST
+        case 250: // M250: Set LCD contrast
+          gcode_M250();
+          break;
+      #endif // HAS_LCD_CONTRAST
+
+      #if ENABLED(EXPERIMENTAL_I2CBUS)
+
+        case 260: // M260: Send data to an i2c slave
+          gcode_M260();
+          break;
+
+        case 261: // M261: Request data from an i2c slave
+          gcode_M261();
+          break;
+
+      #endif // EXPERIMENTAL_I2CBUS
+
+      #if ENABLED(PREVENT_COLD_EXTRUSION)
+        case 302: // M302: Allow cold extrudes (set the minimum extrude temperature)
+          gcode_M302();
+          break;
+      #endif // PREVENT_COLD_EXTRUSION
+
+      case 303: // M303: PID autotune
+        gcode_M303();
+        break;
+
+      #if ENABLED(MORGAN_SCARA)
+        case 360:  // M360: SCARA Theta pos1
+          if (gcode_M360()) return;
+          break;
+        case 361:  // M361: SCARA Theta pos2
+          if (gcode_M361()) return;
+          break;
+        case 362:  // M362: SCARA Psi pos1
+          if (gcode_M362()) return;
+          break;
+        case 363:  // M363: SCARA Psi pos2
+          if (gcode_M363()) return;
+          break;
+        case 364:  // M364: SCARA Psi pos3 (90 deg to Theta)
+          if (gcode_M364()) return;
+          break;
+      #endif // SCARA
+
+      case 400: // M400: Finish all moves
+        gcode_M400();
+        break;
+
+      #if HAS_BED_PROBE
+        case 401: // M401: Deploy probe
+          gcode_M401();
+          break;
+        case 402: // M402: Stow probe
+          gcode_M402();
+          break;
+      #endif // HAS_BED_PROBE
+
+      #if ENABLED(FILAMENT_WIDTH_SENSOR)
+        case 404:  // M404: Enter the nominal filament width (3mm, 1.75mm ) N<3.0> or display nominal filament width
+          gcode_M404();
+          break;
+        case 405:  // M405: Turn on filament sensor for control
+          gcode_M405();
+          break;
+        case 406:  // M406: Turn off filament sensor for control
+          gcode_M406();
+          break;
+        case 407:   // M407: Display measured filament diameter
+          gcode_M407();
+          break;
+      #endif // FILAMENT_WIDTH_SENSOR
+
+      #if HAS_LEVELING
+        case 420: // M420: Enable/Disable Bed Leveling
+          gcode_M420();
+          break;
+      #endif
+
+      #if ENABLED(MESH_BED_LEVELING) || ENABLED(AUTO_BED_LEVELING_UBL) || ENABLED(AUTO_BED_LEVELING_BILINEAR)
+        case 421: // M421: Set a Mesh Bed Leveling Z coordinate
+          gcode_M421();
+          break;
+      #endif
+
+      #if HAS_M206_COMMAND
+        case 428: // M428: Apply current_position to home_offset
+          gcode_M428();
+          break;
+      #endif
+
+      case 500: // M500: Store settings in EEPROM
+        gcode_M500();
+        break;
+      case 501: // M501: Read settings from EEPROM
+        gcode_M501();
+        break;
+      case 502: // M502: Revert to default settings
+        gcode_M502();
+        break;
+
+      #if DISABLED(DISABLE_M503)
+        case 503: // M503: print settings currently in memory
+          gcode_M503();
+          break;
+      #endif
+
+      #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
+        case 540: // M540: Set abort on endstop hit for SD printing
+          gcode_M540();
+          break;
+      #endif
+
+      #if HAS_BED_PROBE
+        case 851: // M851: Set Z Probe Z Offset
+          gcode_M851();
+          break;
+      #endif // HAS_BED_PROBE
+
+      #if ENABLED(ADVANCED_PAUSE_FEATURE)
+        case 600: // M600: Pause for filament change
+          gcode_M600();
+          break;
+      #endif // ADVANCED_PAUSE_FEATURE
+
+      #if ENABLED(DUAL_X_CARRIAGE) || ENABLED(DUAL_NOZZLE_DUPLICATION_MODE)
+        case 605: // M605: Set Dual X Carriage movement mode
+          gcode_M605();
+          break;
+      #endif // DUAL_X_CARRIAGE
+
+      #if ENABLED(MK2_MULTIPLEXER)
+        case 702: // M702: Unload all extruders
+          gcode_M702();
+          break;
+      #endif
+
+      #if ENABLED(LIN_ADVANCE)
+        case 900: // M900: Set advance K factor.
+          gcode_M900();
+          break;
+      #endif
+
+      #if ENABLED(HAVE_TMC2130)
+        case 906: // M906: Set motor current in milliamps using axis codes X, Y, Z, E
+          gcode_M906();
+          break;
+      #endif
+
+      case 907: // M907: Set digital trimpot motor current using axis codes.
+        gcode_M907();
+        break;
+
+      #if HAS_DIGIPOTSS || ENABLED(DAC_STEPPER_CURRENT)
+
+        case 908: // M908: Control digital trimpot directly.
+          gcode_M908();
+          break;
+
+        #if ENABLED(DAC_STEPPER_CURRENT) // As with Printrbot RevF
+
+          case 909: // M909: Print digipot/DAC current value
+            gcode_M909();
+            break;
+
+          case 910: // M910: Commit digipot/DAC value to external EEPROM
+            gcode_M910();
+            break;
+
+        #endif
+
+      #endif // HAS_DIGIPOTSS || DAC_STEPPER_CURRENT
+
+      #if ENABLED(HAVE_TMC2130)
+        case 911: // M911: Report TMC2130 prewarn triggered flags
+          gcode_M911();
+          break;
+
+        case 912: // M911: Clear TMC2130 prewarn triggered flags
+          gcode_M912();
+          break;
+
+        #if ENABLED(HYBRID_THRESHOLD)
+          case 913: // M913: Set HYBRID_THRESHOLD speed.
+            gcode_M913();
+            break;
+        #endif
+
+        #if ENABLED(SENSORLESS_HOMING)
+          case 914: // M914: Set SENSORLESS_HOMING sensitivity.
+            gcode_M914();
+            break;
+        #endif
+      #endif
+
+      #if HAS_MICROSTEPS
+
+        case 350: // M350: Set microstepping mode. Warning: Steps per unit remains unchanged. S code sets stepping mode for all drivers.
+          gcode_M350();
+          break;
+
+        case 351: // M351: Toggle MS1 MS2 pins directly, S# determines MS1 or MS2, X# sets the pin high/low.
+          gcode_M351();
+          break;
+
+      #endif // HAS_MICROSTEPS
+
+      case 355: // M355 set case light brightness
+        gcode_M355();
+        break;
+
+      #if ENABLED(DEBUG_GCODE_PARSER)
+        case 800:
+          parser.debug(); // GCode Parser Test for M
+          break;
+      #endif
+
+      #if ENABLED(I2C_POSITION_ENCODERS)
+
+        case 860: // M860 Report encoder module position
+          gcode_M860();
+          break;
+
+        case 861: // M861 Report encoder module status
+          gcode_M861();
+          break;
+
+        case 862: // M862 Perform axis test
+          gcode_M862();
+          break;
+
+        case 863: // M863 Calibrate steps/mm
+          gcode_M863();
+          break;
+
+        case 864: // M864 Change module address
+          gcode_M864();
+          break;
+
+        case 865: // M865 Check module firmware version
+          gcode_M865();
+          break;
+
+        case 866: // M866 Report axis error count
+          gcode_M866();
+          break;
+
+        case 867: // M867 Toggle error correction
+          gcode_M867();
+          break;
+
+        case 868: // M868 Set error correction threshold
+          gcode_M868();
+          break;
+
+        case 869: // M869 Report axis error
+          gcode_M869();
+          break;
+
+      #endif // I2C_POSITION_ENCODERS
+
+      case 999: // M999: Restart after being Stopped
+        gcode_M999();
+        break;
+    }
+    break;
+
+    case 'T':
+      gcode_T(parser.codenum);
+      break;
+
+    default: parser.unknown_command_error();
+  }
+
+  KEEPALIVE_STATE(NOT_BUSY);
+
+  ok_to_send();
+}
+
+/**
+ * Send a "Resend: nnn" message to the host to
+ * indicate that a command needs to be re-sent.
+ */
+void FlushSerialRequestResend() {
+  //char command_queue[cmd_queue_index_r][100]="Resend:";
+  MYSERIAL.flush();
+  SERIAL_PROTOCOLPGM(MSG_RESEND);
+  SERIAL_PROTOCOLLN(gcode_LastN + 1);
+  ok_to_send();
+}
+
+/**
+ * Send an "ok" message to the host, indicating
+ * that a command was successfully processed.
+ *
+ * If ADVANCED_OK is enabled also include:
+ *   N<int>  Line number of the command, if any
+ *   P<int>  Planner space remaining
+ *   B<int>  Block queue space remaining
+ */
+void ok_to_send() {
+  refresh_cmd_timeout();
+  if (!send_ok[cmd_queue_index_r]) return;
+  SERIAL_PROTOCOLPGM(MSG_OK);
+  #if ENABLED(ADVANCED_OK)
+    char* p = command_queue[cmd_queue_index_r];
+    if (*p == 'N') {
+      SERIAL_PROTOCOL(' ');
+      SERIAL_ECHO(*p++);
+      while (NUMERIC_SIGNED(*p))
+        SERIAL_ECHO(*p++);
+    }
+    SERIAL_PROTOCOLPGM(" P"); SERIAL_PROTOCOL(int(BLOCK_BUFFER_SIZE - planner.movesplanned() - 1));
+    SERIAL_PROTOCOLPGM(" B"); SERIAL_PROTOCOL(BUFSIZE - commands_in_queue);
+  #endif
+  SERIAL_EOL();
+}
+
+#if HAS_SOFTWARE_ENDSTOPS
+
+  /**
+   * Constrain the given coordinates to the software endstops.
+   */
+
+  // NOTE: This makes no sense for delta beds other than Z-axis.
+  //       For delta the X/Y would need to be clamped at
+  //       DELTA_PRINTABLE_RADIUS from center of bed, but delta
+  //       now enforces is_position_reachable for X/Y regardless
+  //       of HAS_SOFTWARE_ENDSTOPS, so that enforcement would be
+  //       redundant here.
+
+  void clamp_to_software_endstops(float target[XYZ]) {
+    if (!soft_endstops_enabled) return;
+    #if ENABLED(MIN_SOFTWARE_ENDSTOPS)
+      #if DISABLED(DELTA)
+        NOLESS(target[X_AXIS], soft_endstop_min[X_AXIS]);
+        NOLESS(target[Y_AXIS], soft_endstop_min[Y_AXIS]);
+      #endif
+      NOLESS(target[Z_AXIS], soft_endstop_min[Z_AXIS]);
+    #endif
+    #if ENABLED(MAX_SOFTWARE_ENDSTOPS)
+      #if DISABLED(DELTA)
+        NOMORE(target[X_AXIS], soft_endstop_max[X_AXIS]);
+        NOMORE(target[Y_AXIS], soft_endstop_max[Y_AXIS]);
+      #endif
+      NOMORE(target[Z_AXIS], soft_endstop_max[Z_AXIS]);
+    #endif
+  }
+
+#endif
+
+#if ENABLED(AUTO_BED_LEVELING_BILINEAR)
+
+  #if ENABLED(ABL_BILINEAR_SUBDIVISION)
+    #define ABL_BG_SPACING(A) bilinear_grid_spacing_virt[A]
+    #define ABL_BG_FACTOR(A)  bilinear_grid_factor_virt[A]
+    #define ABL_BG_POINTS_X   ABL_GRID_POINTS_VIRT_X
+    #define ABL_BG_POINTS_Y   ABL_GRID_POINTS_VIRT_Y
+    #define ABL_BG_GRID(X,Y)  z_values_virt[X][Y]
+  #else
+    #define ABL_BG_SPACING(A) bilinear_grid_spacing[A]
+    #define ABL_BG_FACTOR(A)  bilinear_grid_factor[A]
+    #define ABL_BG_POINTS_X   GRID_MAX_POINTS_X
+    #define ABL_BG_POINTS_Y   GRID_MAX_POINTS_Y
+    #define ABL_BG_GRID(X,Y)  z_values[X][Y]
+  #endif
+
+  // Get the Z adjustment for non-linear bed leveling
+  float bilinear_z_offset(const float logical[XYZ]) {
+
+    static float z1, d2, z3, d4, L, D, ratio_x, ratio_y,
+                 last_x = -999.999, last_y = -999.999;
+
+    // Whole units for the grid line indices. Constrained within bounds.
+    static int8_t gridx, gridy, nextx, nexty,
+                  last_gridx = -99, last_gridy = -99;
+
+    // XY relative to the probed area
+    const float x = RAW_X_POSITION(logical[X_AXIS]) - bilinear_start[X_AXIS],
+                y = RAW_Y_POSITION(logical[Y_AXIS]) - bilinear_start[Y_AXIS];
+
+    #if ENABLED(EXTRAPOLATE_BEYOND_GRID)
+      // Keep using the last grid box
+      #define FAR_EDGE_OR_BOX 2
+    #else
+      // Just use the grid far edge
+      #define FAR_EDGE_OR_BOX 1
+    #endif
+
+    if (last_x != x) {
+      last_x = x;
+      ratio_x = x * ABL_BG_FACTOR(X_AXIS);
+      const float gx = constrain(FLOOR(ratio_x), 0, ABL_BG_POINTS_X - FAR_EDGE_OR_BOX);
+      ratio_x -= gx;      // Subtract whole to get the ratio within the grid box
+
+      #if DISABLED(EXTRAPOLATE_BEYOND_GRID)
+        // Beyond the grid maintain height at grid edges
+        NOLESS(ratio_x, 0); // Never < 0.0. (> 1.0 is ok when nextx==gridx.)
+      #endif
+
+      gridx = gx;
+      nextx = min(gridx + 1, ABL_BG_POINTS_X - 1);
+    }
+
+    if (last_y != y || last_gridx != gridx) {
+
+      if (last_y != y) {
+        last_y = y;
+        ratio_y = y * ABL_BG_FACTOR(Y_AXIS);
+        const float gy = constrain(FLOOR(ratio_y), 0, ABL_BG_POINTS_Y - FAR_EDGE_OR_BOX);
+        ratio_y -= gy;
+
+        #if DISABLED(EXTRAPOLATE_BEYOND_GRID)
+          // Beyond the grid maintain height at grid edges
+          NOLESS(ratio_y, 0); // Never < 0.0. (> 1.0 is ok when nexty==gridy.)
+        #endif
+
+        gridy = gy;
+        nexty = min(gridy + 1, ABL_BG_POINTS_Y - 1);
+      }
+
+      if (last_gridx != gridx || last_gridy != gridy) {
+        last_gridx = gridx;
+        last_gridy = gridy;
+        // Z at the box corners
+        z1 = ABL_BG_GRID(gridx, gridy);       // left-front
+        d2 = ABL_BG_GRID(gridx, nexty) - z1;  // left-back (delta)
+        z3 = ABL_BG_GRID(nextx, gridy);       // right-front
+        d4 = ABL_BG_GRID(nextx, nexty) - z3;  // right-back (delta)
+      }
+
+      // Bilinear interpolate. Needed since y or gridx has changed.
+                  L = z1 + d2 * ratio_y;   // Linear interp. LF -> LB
+      const float R = z3 + d4 * ratio_y;   // Linear interp. RF -> RB
+
+      D = R - L;
+    }
+
+    const float offset = L + ratio_x * D;   // the offset almost always changes
+
+    /*
+    static float last_offset = 0;
+    if (FABS(last_offset - offset) > 0.2) {
+      SERIAL_ECHOPGM("Sudden Shift at ");
+      SERIAL_ECHOPAIR("x=", x);
+      SERIAL_ECHOPAIR(" / ", bilinear_grid_spacing[X_AXIS]);
+      SERIAL_ECHOLNPAIR(" -> gridx=", gridx);
+      SERIAL_ECHOPAIR(" y=", y);
+      SERIAL_ECHOPAIR(" / ", bilinear_grid_spacing[Y_AXIS]);
+      SERIAL_ECHOLNPAIR(" -> gridy=", gridy);
+      SERIAL_ECHOPAIR(" ratio_x=", ratio_x);
+      SERIAL_ECHOLNPAIR(" ratio_y=", ratio_y);
+      SERIAL_ECHOPAIR(" z1=", z1);
+      SERIAL_ECHOPAIR(" z2=", z2);
+      SERIAL_ECHOPAIR(" z3=", z3);
+      SERIAL_ECHOLNPAIR(" z4=", z4);
+      SERIAL_ECHOPAIR(" L=", L);
+      SERIAL_ECHOPAIR(" R=", R);
+      SERIAL_ECHOLNPAIR(" offset=", offset);
+    }
+    last_offset = offset;
+    //*/
+
+    return offset;
+  }
+
+#endif // AUTO_BED_LEVELING_BILINEAR
+
+#if ENABLED(DELTA)
+
+  /**
+   * Recalculate factors used for delta kinematics whenever
+   * settings have been changed (e.g., by M665).
+   */
+  void recalc_delta_settings(float radius, float diagonal_rod) {
+    const float trt[ABC] = DELTA_RADIUS_TRIM_TOWER,
+                drt[ABC] = DELTA_DIAGONAL_ROD_TRIM_TOWER;
+    delta_tower[A_AXIS][X_AXIS] = cos(RADIANS(210 + delta_tower_angle_trim[A_AXIS])) * (radius + trt[A_AXIS]); // front left tower
+    delta_tower[A_AXIS][Y_AXIS] = sin(RADIANS(210 + delta_tower_angle_trim[A_AXIS])) * (radius + trt[A_AXIS]);
+    delta_tower[B_AXIS][X_AXIS] = cos(RADIANS(330 + delta_tower_angle_trim[B_AXIS])) * (radius + trt[B_AXIS]); // front right tower
+    delta_tower[B_AXIS][Y_AXIS] = sin(RADIANS(330 + delta_tower_angle_trim[B_AXIS])) * (radius + trt[B_AXIS]);
+    delta_tower[C_AXIS][X_AXIS] = 0.0; // back middle tower
+    delta_tower[C_AXIS][Y_AXIS] = (radius + trt[C_AXIS]);
+    delta_diagonal_rod_2_tower[A_AXIS] = sq(diagonal_rod + drt[A_AXIS]);
+    delta_diagonal_rod_2_tower[B_AXIS] = sq(diagonal_rod + drt[B_AXIS]);
+    delta_diagonal_rod_2_tower[C_AXIS] = sq(diagonal_rod + drt[C_AXIS]);
+  }
+
+  #if ENABLED(DELTA_FAST_SQRT) && defined(ARDUINO_ARCH_AVR)
+    /**
+     * Fast inverse sqrt from Quake III Arena
+     * See: https://en.wikipedia.org/wiki/Fast_inverse_square_root
+     */
+    float Q_rsqrt(float number) {
+      long i;
+      float x2, y;
+      const float threehalfs = 1.5f;
+      x2 = number * 0.5f;
+      y  = number;
+      i  = * ( long * ) &y;                       // evil floating point bit level hacking
+      i  = 0x5F3759DF - ( i >> 1 );               // what the f***?
+      y  = * ( float * ) &i;
+      y  = y * ( threehalfs - ( x2 * y * y ) );   // 1st iteration
+      // y  = y * ( threehalfs - ( x2 * y * y ) );   // 2nd iteration, this can be removed
+      return y;
+    }
+
+    #define _SQRT(n) (1.0f / Q_rsqrt(n))
+
+  #else
+
+    #define _SQRT(n) SQRT(n)
+
+  #endif
+
+  /**
+   * Delta Inverse Kinematics
+   *
+   * Calculate the tower positions for a given logical
+   * position, storing the result in the delta[] array.
+   *
+   * This is an expensive calculation, requiring 3 square
+   * roots per segmented linear move, and strains the limits
+   * of a Mega2560 with a Graphical Display.
+   *
+   * Suggested optimizations include:
+   *
+   * - Disable the home_offset (M206) and/or position_shift (G92)
+   *   features to remove up to 12 float additions.
+   *
+   * - Use a fast-inverse-sqrt function and add the reciprocal.
+   *   (see above)
+   */
+
+  // Macro to obtain the Z position of an individual tower
+  #define DELTA_Z(T) raw[Z_AXIS] + _SQRT(     \
+    delta_diagonal_rod_2_tower[T] - HYPOT2(   \
+        delta_tower[T][X_AXIS] - raw[X_AXIS], \
+        delta_tower[T][Y_AXIS] - raw[Y_AXIS]  \
+      )                                       \
+    )
+
+  #define DELTA_RAW_IK() do {        \
+    delta[A_AXIS] = DELTA_Z(A_AXIS); \
+    delta[B_AXIS] = DELTA_Z(B_AXIS); \
+    delta[C_AXIS] = DELTA_Z(C_AXIS); \
+  }while(0)
+
+  #define DELTA_LOGICAL_IK() do {      \
+    const float raw[XYZ] = {           \
+      RAW_X_POSITION(logical[X_AXIS]), \
+      RAW_Y_POSITION(logical[Y_AXIS]), \
+      RAW_Z_POSITION(logical[Z_AXIS])  \
+    };                                 \
+    DELTA_RAW_IK();                    \
+  }while(0)
+
+  #define DELTA_DEBUG() do { \
+      SERIAL_ECHOPAIR("cartesian X:", raw[X_AXIS]); \
+      SERIAL_ECHOPAIR(" Y:", raw[Y_AXIS]);          \
+      SERIAL_ECHOLNPAIR(" Z:", raw[Z_AXIS]);        \
+      SERIAL_ECHOPAIR("delta A:", delta[A_AXIS]);   \
+      SERIAL_ECHOPAIR(" B:", delta[B_AXIS]);        \
+      SERIAL_ECHOLNPAIR(" C:", delta[C_AXIS]);      \
+    }while(0)
+
+  void inverse_kinematics(const float logical[XYZ]) {
+    DELTA_LOGICAL_IK();
+    // DELTA_DEBUG();
+  }
+
+  /**
+   * Calculate the highest Z position where the
+   * effector has the full range of XY motion.
+   */
+  float delta_safe_distance_from_top() {
+    float cartesian[XYZ] = {
+      LOGICAL_X_POSITION(0),
+      LOGICAL_Y_POSITION(0),
+      LOGICAL_Z_POSITION(0)
+    };
+    inverse_kinematics(cartesian);
+    float distance = delta[A_AXIS];
+    cartesian[Y_AXIS] = LOGICAL_Y_POSITION(DELTA_PRINTABLE_RADIUS);
+    inverse_kinematics(cartesian);
+    return FABS(distance - delta[A_AXIS]);
+  }
+
+  /**
+   * Delta Forward Kinematics
+   *
+   * See the Wikipedia article "Trilateration"
+   * https://en.wikipedia.org/wiki/Trilateration
+   *
+   * Establish a new coordinate system in the plane of the
+   * three carriage points. This system has its origin at
+   * tower1, with tower2 on the X axis. Tower3 is in the X-Y
+   * plane with a Z component of zero.
+   * We will define unit vectors in this coordinate system
+   * in our original coordinate system. Then when we calculate
+   * the Xnew, Ynew and Znew values, we can translate back into
+   * the original system by moving along those unit vectors
+   * by the corresponding values.
+   *
+   * Variable names matched to Marlin, c-version, and avoid the
+   * use of any vector library.
+   *
+   * by Andreas Hardtung 2016-06-07
+   * based on a Java function from "Delta Robot Kinematics V3"
+   * by Steve Graves
+   *
+   * The result is stored in the cartes[] array.
+   */
+  void forward_kinematics_DELTA(float z1, float z2, float z3) {
+    // Create a vector in old coordinates along x axis of new coordinate
+    float p12[3] = { delta_tower[B_AXIS][X_AXIS] - delta_tower[A_AXIS][X_AXIS], delta_tower[B_AXIS][Y_AXIS] - delta_tower[A_AXIS][Y_AXIS], z2 - z1 };
+
+    // Get the Magnitude of vector.
+    float d = SQRT( sq(p12[0]) + sq(p12[1]) + sq(p12[2]) );
+
+    // Create unit vector by dividing by magnitude.
+    float ex[3] = { p12[0] / d, p12[1] / d, p12[2] / d };
+
+    // Get the vector from the origin of the new system to the third point.
+    float p13[3] = { delta_tower[C_AXIS][X_AXIS] - delta_tower[A_AXIS][X_AXIS], delta_tower[C_AXIS][Y_AXIS] - delta_tower[A_AXIS][Y_AXIS], z3 - z1 };
+
+    // Use the dot product to find the component of this vector on the X axis.
+    float i = ex[0] * p13[0] + ex[1] * p13[1] + ex[2] * p13[2];
+
+    // Create a vector along the x axis that represents the x component of p13.
+    float iex[3] = { ex[0] * i, ex[1] * i, ex[2] * i };
+
+    // Subtract the X component from the original vector leaving only Y. We use the
+    // variable that will be the unit vector after we scale it.
+    float ey[3] = { p13[0] - iex[0], p13[1] - iex[1], p13[2] - iex[2] };
+
+    // The magnitude of Y component
+    float j = SQRT( sq(ey[0]) + sq(ey[1]) + sq(ey[2]) );
+
+    // Convert to a unit vector
+    ey[0] /= j; ey[1] /= j;  ey[2] /= j;
+
+    // The cross product of the unit x and y is the unit z
+    // float[] ez = vectorCrossProd(ex, ey);
+    float ez[3] = {
+      ex[1] * ey[2] - ex[2] * ey[1],
+      ex[2] * ey[0] - ex[0] * ey[2],
+      ex[0] * ey[1] - ex[1] * ey[0]
+    };
+
+    // We now have the d, i and j values defined in Wikipedia.
+    // Plug them into the equations defined in Wikipedia for Xnew, Ynew and Znew
+    float Xnew = (delta_diagonal_rod_2_tower[A_AXIS] - delta_diagonal_rod_2_tower[B_AXIS] + sq(d)) / (d * 2),
+          Ynew = ((delta_diagonal_rod_2_tower[A_AXIS] - delta_diagonal_rod_2_tower[C_AXIS] + HYPOT2(i, j)) / 2 - i * Xnew) / j,
+          Znew = SQRT(delta_diagonal_rod_2_tower[A_AXIS] - HYPOT2(Xnew, Ynew));
+
+    // Start from the origin of the old coordinates and add vectors in the
+    // old coords that represent the Xnew, Ynew and Znew to find the point
+    // in the old system.
+    cartes[X_AXIS] = delta_tower[A_AXIS][X_AXIS] + ex[0] * Xnew + ey[0] * Ynew - ez[0] * Znew;
+    cartes[Y_AXIS] = delta_tower[A_AXIS][Y_AXIS] + ex[1] * Xnew + ey[1] * Ynew - ez[1] * Znew;
+    cartes[Z_AXIS] =             z1 + ex[2] * Xnew + ey[2] * Ynew - ez[2] * Znew;
+  }
+
+  void forward_kinematics_DELTA(float point[ABC]) {
+    forward_kinematics_DELTA(point[A_AXIS], point[B_AXIS], point[C_AXIS]);
+  }
+
+#endif // DELTA
+
+/**
+ * Get the stepper positions in the cartes[] array.
+ * Forward kinematics are applied for DELTA and SCARA.
+ *
+ * The result is in the current coordinate space with
+ * leveling applied. The coordinates need to be run through
+ * unapply_leveling to obtain the "ideal" coordinates
+ * suitable for current_position, etc.
+ */
+void get_cartesian_from_steppers() {
+  #if ENABLED(DELTA)
+    forward_kinematics_DELTA(
+      stepper.get_axis_position_mm(A_AXIS),
+      stepper.get_axis_position_mm(B_AXIS),
+      stepper.get_axis_position_mm(C_AXIS)
+    );
+    cartes[X_AXIS] += LOGICAL_X_POSITION(0);
+    cartes[Y_AXIS] += LOGICAL_Y_POSITION(0);
+    cartes[Z_AXIS] += LOGICAL_Z_POSITION(0);
+  #elif IS_SCARA
+    forward_kinematics_SCARA(
+      stepper.get_axis_position_degrees(A_AXIS),
+      stepper.get_axis_position_degrees(B_AXIS)
+    );
+    cartes[X_AXIS] += LOGICAL_X_POSITION(0);
+    cartes[Y_AXIS] += LOGICAL_Y_POSITION(0);
+    cartes[Z_AXIS] = stepper.get_axis_position_mm(Z_AXIS);
+  #else
+    cartes[X_AXIS] = stepper.get_axis_position_mm(X_AXIS);
+    cartes[Y_AXIS] = stepper.get_axis_position_mm(Y_AXIS);
+    cartes[Z_AXIS] = stepper.get_axis_position_mm(Z_AXIS);
+  #endif
+}
+
+/**
+ * Set the current_position for an axis based on
+ * the stepper positions, removing any leveling that
+ * may have been applied.
+ */
+void set_current_from_steppers_for_axis(const AxisEnum axis) {
+  get_cartesian_from_steppers();
+  #if PLANNER_LEVELING
+    planner.unapply_leveling(cartes);
+  #endif
+  if (axis == ALL_AXES)
+    COPY(current_position, cartes);
+  else
+    current_position[axis] = cartes[axis];
+}
+
+#if ENABLED(MESH_BED_LEVELING)
+
+  /**
+   * Prepare a mesh-leveled linear move in a Cartesian setup,
+   * splitting the move where it crosses mesh borders.
+   */
+  void mesh_line_to_destination(float fr_mm_s, uint8_t x_splits = 0xFF, uint8_t y_splits = 0xFF) {
+    int cx1 = mbl.cell_index_x(RAW_CURRENT_POSITION(X)),
+        cy1 = mbl.cell_index_y(RAW_CURRENT_POSITION(Y)),
+        cx2 = mbl.cell_index_x(RAW_X_POSITION(destination[X_AXIS])),
+        cy2 = mbl.cell_index_y(RAW_Y_POSITION(destination[Y_AXIS]));
+    NOMORE(cx1, GRID_MAX_POINTS_X - 2);
+    NOMORE(cy1, GRID_MAX_POINTS_Y - 2);
+    NOMORE(cx2, GRID_MAX_POINTS_X - 2);
+    NOMORE(cy2, GRID_MAX_POINTS_Y - 2);
+
+    if (cx1 == cx2 && cy1 == cy2) {
+      // Start and end on same mesh square
+      line_to_destination(fr_mm_s);
+      set_current_to_destination();
+      return;
+    }
+
+    #define MBL_SEGMENT_END(A) (current_position[A ##_AXIS] + (destination[A ##_AXIS] - current_position[A ##_AXIS]) * normalized_dist)
+
+    float normalized_dist, end[XYZE];
+
+    // Split at the left/front border of the right/top square
+    const int8_t gcx = max(cx1, cx2), gcy = max(cy1, cy2);
+    if (cx2 != cx1 && TEST(x_splits, gcx)) {
+      COPY(end, destination);
+      destination[X_AXIS] = LOGICAL_X_POSITION(mbl.index_to_xpos[gcx]);
+      normalized_dist = (destination[X_AXIS] - current_position[X_AXIS]) / (end[X_AXIS] - current_position[X_AXIS]);
+      destination[Y_AXIS] = MBL_SEGMENT_END(Y);
+      CBI(x_splits, gcx);
+    }
+    else if (cy2 != cy1 && TEST(y_splits, gcy)) {
+      COPY(end, destination);
+      destination[Y_AXIS] = LOGICAL_Y_POSITION(mbl.index_to_ypos[gcy]);
+      normalized_dist = (destination[Y_AXIS] - current_position[Y_AXIS]) / (end[Y_AXIS] - current_position[Y_AXIS]);
+      destination[X_AXIS] = MBL_SEGMENT_END(X);
+      CBI(y_splits, gcy);
+    }
+    else {
+      // Already split on a border
+      line_to_destination(fr_mm_s);
+      set_current_to_destination();
+      return;
+    }
+
+    destination[Z_AXIS] = MBL_SEGMENT_END(Z);
+    destination[E_AXIS] = MBL_SEGMENT_END(E);
+
+    // Do the split and look for more borders
+    mesh_line_to_destination(fr_mm_s, x_splits, y_splits);
+
+    // Restore destination from stack
+    COPY(destination, end);
+    mesh_line_to_destination(fr_mm_s, x_splits, y_splits);
+  }
+
+#elif ENABLED(AUTO_BED_LEVELING_BILINEAR) && !IS_KINEMATIC
+
+  #define CELL_INDEX(A,V) ((RAW_##A##_POSITION(V) - bilinear_start[A##_AXIS]) * ABL_BG_FACTOR(A##_AXIS))
+
+  /**
+   * Prepare a bilinear-leveled linear move on Cartesian,
+   * splitting the move where it crosses grid borders.
+   */
+  void bilinear_line_to_destination(float fr_mm_s, uint16_t x_splits = 0xFFFF, uint16_t y_splits = 0xFFFF) {
+    int cx1 = CELL_INDEX(X, current_position[X_AXIS]),
+        cy1 = CELL_INDEX(Y, current_position[Y_AXIS]),
+        cx2 = CELL_INDEX(X, destination[X_AXIS]),
+        cy2 = CELL_INDEX(Y, destination[Y_AXIS]);
+    cx1 = constrain(cx1, 0, ABL_BG_POINTS_X - 2);
+    cy1 = constrain(cy1, 0, ABL_BG_POINTS_Y - 2);
+    cx2 = constrain(cx2, 0, ABL_BG_POINTS_X - 2);
+    cy2 = constrain(cy2, 0, ABL_BG_POINTS_Y - 2);
+
+    if (cx1 == cx2 && cy1 == cy2) {
+      // Start and end on same mesh square
+      line_to_destination(fr_mm_s);
+      set_current_to_destination();
+      return;
+    }
+
+    #define LINE_SEGMENT_END(A) (current_position[A ##_AXIS] + (destination[A ##_AXIS] - current_position[A ##_AXIS]) * normalized_dist)
+
+    float normalized_dist, end[XYZE];
+
+    // Split at the left/front border of the right/top square
+    const int8_t gcx = max(cx1, cx2), gcy = max(cy1, cy2);
+    if (cx2 != cx1 && TEST(x_splits, gcx)) {
+      COPY(end, destination);
+      destination[X_AXIS] = LOGICAL_X_POSITION(bilinear_start[X_AXIS] + ABL_BG_SPACING(X_AXIS) * gcx);
+      normalized_dist = (destination[X_AXIS] - current_position[X_AXIS]) / (end[X_AXIS] - current_position[X_AXIS]);
+      destination[Y_AXIS] = LINE_SEGMENT_END(Y);
+      CBI(x_splits, gcx);
+    }
+    else if (cy2 != cy1 && TEST(y_splits, gcy)) {
+      COPY(end, destination);
+      destination[Y_AXIS] = LOGICAL_Y_POSITION(bilinear_start[Y_AXIS] + ABL_BG_SPACING(Y_AXIS) * gcy);
+      normalized_dist = (destination[Y_AXIS] - current_position[Y_AXIS]) / (end[Y_AXIS] - current_position[Y_AXIS]);
+      destination[X_AXIS] = LINE_SEGMENT_END(X);
+      CBI(y_splits, gcy);
+    }
+    else {
+      // Already split on a border
+      line_to_destination(fr_mm_s);
+      set_current_to_destination();
+      return;
+    }
+
+    destination[Z_AXIS] = LINE_SEGMENT_END(Z);
+    destination[E_AXIS] = LINE_SEGMENT_END(E);
+
+    // Do the split and look for more borders
+    bilinear_line_to_destination(fr_mm_s, x_splits, y_splits);
+
+    // Restore destination from stack
+    COPY(destination, end);
+    bilinear_line_to_destination(fr_mm_s, x_splits, y_splits);
+  }
+
+#endif // AUTO_BED_LEVELING_BILINEAR
+
+#if IS_KINEMATIC && !UBL_DELTA
+
+  /**
+   * Prepare a linear move in a DELTA or SCARA setup.
+   *
+   * This calls planner.buffer_line several times, adding
+   * small incremental moves for DELTA or SCARA.
+   */
+  inline bool prepare_kinematic_move_to(float ltarget[XYZE]) {
+
+    // Get the top feedrate of the move in the XY plane
+    const float _feedrate_mm_s = MMS_SCALED(feedrate_mm_s);
+
+    // If the move is only in Z/E don't split up the move
+    if (ltarget[X_AXIS] == current_position[X_AXIS] && ltarget[Y_AXIS] == current_position[Y_AXIS]) {
+      planner.buffer_line_kinematic(ltarget, _feedrate_mm_s, active_extruder);
+      return false;
+    }
+
+    // Fail if attempting move outside printable radius
+    if (!position_is_reachable_xy(ltarget[X_AXIS], ltarget[Y_AXIS])) return true;
+
+    // Get the cartesian distances moved in XYZE
+    const float difference[XYZE] = {
+      ltarget[X_AXIS] - current_position[X_AXIS],
+      ltarget[Y_AXIS] - current_position[Y_AXIS],
+      ltarget[Z_AXIS] - current_position[Z_AXIS],
+      ltarget[E_AXIS] - current_position[E_AXIS]
+    };
+
+    // Get the linear distance in XYZ
+    float cartesian_mm = SQRT(sq(difference[X_AXIS]) + sq(difference[Y_AXIS]) + sq(difference[Z_AXIS]));
+
+    // If the move is very short, check the E move distance
+    if (UNEAR_ZERO(cartesian_mm)) cartesian_mm = FABS(difference[E_AXIS]);
+
+    // No E move either? Game over.
+    if (UNEAR_ZERO(cartesian_mm)) return true;
+
+    // Minimum number of seconds to move the given distance
+    const float seconds = cartesian_mm / _feedrate_mm_s;
+
+    // The number of segments-per-second times the duration
+    // gives the number of segments
+    uint16_t segments = delta_segments_per_second * seconds;
+
+    // For SCARA minimum segment size is 0.25mm
+    #if IS_SCARA
+      NOMORE(segments, cartesian_mm * 4);
+    #endif
+
+    // At least one segment is required
+    NOLESS(segments, 1);
+
+    // The approximate length of each segment
+    const float inv_segments = 1.0 / float(segments),
+                segment_distance[XYZE] = {
+                  difference[X_AXIS] * inv_segments,
+                  difference[Y_AXIS] * inv_segments,
+                  difference[Z_AXIS] * inv_segments,
+                  difference[E_AXIS] * inv_segments
+                };
+
+    // SERIAL_ECHOPAIR("mm=", cartesian_mm);
+    // SERIAL_ECHOPAIR(" seconds=", seconds);
+    // SERIAL_ECHOLNPAIR(" segments=", segments);
+
+    #if IS_SCARA && ENABLED(SCARA_FEEDRATE_SCALING)
+      // SCARA needs to scale the feed rate from mm/s to degrees/s
+      const float inv_segment_length = min(10.0, float(segments) / cartesian_mm), // 1/mm/segs
+                  feed_factor = inv_segment_length * _feedrate_mm_s;
+      float oldA = stepper.get_axis_position_degrees(A_AXIS),
+            oldB = stepper.get_axis_position_degrees(B_AXIS);
+    #endif
+
+    // Get the logical current position as starting point
+    float logical[XYZE];
+    COPY(logical, current_position);
+
+    // Drop one segment so the last move is to the exact target.
+    // If there's only 1 segment, loops will be skipped entirely.
+    --segments;
+
+    // Calculate and execute the segments
+    for (uint16_t s = segments + 1; --s;) {
+      LOOP_XYZE(i) logical[i] += segment_distance[i];
+      #if ENABLED(DELTA)
+        DELTA_LOGICAL_IK(); // Delta can inline its kinematics
+      #else
+        inverse_kinematics(logical);
+      #endif
+
+      ADJUST_DELTA(logical); // Adjust Z if bed leveling is enabled
+
+      #if IS_SCARA && ENABLED(SCARA_FEEDRATE_SCALING)
+        // For SCARA scale the feed rate from mm/s to degrees/s
+        // Use ratio between the length of the move and the larger angle change
+        const float adiff = abs(delta[A_AXIS] - oldA),
+                    bdiff = abs(delta[B_AXIS] - oldB);
+        planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], logical[E_AXIS], max(adiff, bdiff) * feed_factor, active_extruder);
+        oldA = delta[A_AXIS];
+        oldB = delta[B_AXIS];
+      #else
+        planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], logical[E_AXIS], _feedrate_mm_s, active_extruder);
+      #endif
+    }
+
+    // Since segment_distance is only approximate,
+    // the final move must be to the exact destination.
+
+    #if IS_SCARA && ENABLED(SCARA_FEEDRATE_SCALING)
+      // For SCARA scale the feed rate from mm/s to degrees/s
+      // With segments > 1 length is 1 segment, otherwise total length
+      inverse_kinematics(ltarget);
+      ADJUST_DELTA(ltarget);
+      const float adiff = abs(delta[A_AXIS] - oldA),
+                  bdiff = abs(delta[B_AXIS] - oldB);
+      planner.buffer_line(delta[A_AXIS], delta[B_AXIS], delta[C_AXIS], logical[E_AXIS], max(adiff, bdiff) * feed_factor, active_extruder);
+    #else
+      planner.buffer_line_kinematic(ltarget, _feedrate_mm_s, active_extruder);
+    #endif
+
+    return false;
+  }
+
+#else // !IS_KINEMATIC || UBL_DELTA
+
+  /**
+   * Prepare a linear move in a Cartesian setup.
+   * If Mesh Bed Leveling is enabled, perform a mesh move.
+   *
+   * Returns true if the caller didn't update current_position.
+   */
+  inline bool prepare_move_to_destination_cartesian() {
+    #if ENABLED(AUTO_BED_LEVELING_UBL)
+      const float fr_scaled = MMS_SCALED(feedrate_mm_s);
+      if (ubl.state.active) { // direct use of ubl.state.active for speed
+        ubl.line_to_destination_cartesian(fr_scaled, active_extruder);
+        return true;
+      }
+      else
+        line_to_destination(fr_scaled);
+    #else
+      // Do not use feedrate_percentage for E or Z only moves
+      if (current_position[X_AXIS] == destination[X_AXIS] && current_position[Y_AXIS] == destination[Y_AXIS])
+        line_to_destination();
+      else {
+        const float fr_scaled = MMS_SCALED(feedrate_mm_s);
+        #if ENABLED(MESH_BED_LEVELING)
+          if (mbl.active()) { // direct used of mbl.active() for speed
+            mesh_line_to_destination(fr_scaled);
+            return true;
+          }
+          else
+        #elif ENABLED(AUTO_BED_LEVELING_BILINEAR)
+          if (planner.abl_enabled) { // direct use of abl_enabled for speed
+            bilinear_line_to_destination(fr_scaled);
+            return true;
+          }
+          else
+        #endif
+            line_to_destination(fr_scaled);
+      }
+    #endif
+    return false;
+  }
+
+#endif // !IS_KINEMATIC || UBL_DELTA
+
+#if ENABLED(DUAL_X_CARRIAGE)
+
+  /**
+   * Prepare a linear move in a dual X axis setup
+   */
+  inline bool prepare_move_to_destination_dualx() {
+    if (active_extruder_parked) {
+      switch (dual_x_carriage_mode) {
+        case DXC_FULL_CONTROL_MODE:
+          break;
+        case DXC_AUTO_PARK_MODE:
+          if (current_position[E_AXIS] == destination[E_AXIS]) {
+            // This is a travel move (with no extrusion)
+            // Skip it, but keep track of the current position
+            // (so it can be used as the start of the next non-travel move)
+            if (delayed_move_time != 0xFFFFFFFFUL) {
+              set_current_to_destination();
+              NOLESS(raised_parked_position[Z_AXIS], destination[Z_AXIS]);
+              delayed_move_time = millis();
+              return true;
+            }
+          }
+          // unpark extruder: 1) raise, 2) move into starting XY position, 3) lower
+          for (uint8_t i = 0; i < 3; i++)
+            planner.buffer_line(
+              i == 0 ? raised_parked_position[X_AXIS] : current_position[X_AXIS],
+              i == 0 ? raised_parked_position[Y_AXIS] : current_position[Y_AXIS],
+              i == 2 ? current_position[Z_AXIS] : raised_parked_position[Z_AXIS],
+              current_position[E_AXIS],
+              i == 1 ? PLANNER_XY_FEEDRATE() : planner.max_feedrate_mm_s[Z_AXIS],
+              active_extruder
+            );
+          delayed_move_time = 0;
+          active_extruder_parked = false;
+          #if ENABLED(DEBUG_LEVELING_FEATURE)
+            if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Clear active_extruder_parked");
+          #endif
+          break;
+        case DXC_DUPLICATION_MODE:
+          if (active_extruder == 0) {
+            #if ENABLED(DEBUG_LEVELING_FEATURE)
+              if (DEBUGGING(LEVELING)) {
+                SERIAL_ECHOPAIR("Set planner X", LOGICAL_X_POSITION(inactive_extruder_x_pos));
+                SERIAL_ECHOLNPAIR(" ... Line to X", current_position[X_AXIS] + duplicate_extruder_x_offset);
+              }
+            #endif
+            // move duplicate extruder into correct duplication position.
+            planner.set_position_mm(
+              LOGICAL_X_POSITION(inactive_extruder_x_pos),
+              current_position[Y_AXIS],
+              current_position[Z_AXIS],
+              current_position[E_AXIS]
+            );
+            planner.buffer_line(
+              current_position[X_AXIS] + duplicate_extruder_x_offset,
+              current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS],
+              planner.max_feedrate_mm_s[X_AXIS], 1
+            );
+            SYNC_PLAN_POSITION_KINEMATIC();
+            stepper.synchronize();
+            extruder_duplication_enabled = true;
+            active_extruder_parked = false;
+            #if ENABLED(DEBUG_LEVELING_FEATURE)
+              if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Set extruder_duplication_enabled\nClear active_extruder_parked");
+            #endif
+          }
+          else {
+            #if ENABLED(DEBUG_LEVELING_FEATURE)
+              if (DEBUGGING(LEVELING)) SERIAL_ECHOLNPGM("Active extruder not 0");
+            #endif
+          }
+          break;
+      }
+    }
+    return false;
+  }
+
+#endif // DUAL_X_CARRIAGE
+
+/**
+ * Prepare a single move and get ready for the next one
+ *
+ * This may result in several calls to planner.buffer_line to
+ * do smaller moves for DELTA, SCARA, mesh moves, etc.
+ */
+void prepare_move_to_destination() {
+  clamp_to_software_endstops(destination);
+  refresh_cmd_timeout();
+
+  #if ENABLED(PREVENT_COLD_EXTRUSION)
+
+    if (!DEBUGGING(DRYRUN)) {
+      if (destination[E_AXIS] != current_position[E_AXIS]) {
+        if (thermalManager.tooColdToExtrude(active_extruder)) {
+          current_position[E_AXIS] = destination[E_AXIS]; // Behave as if the move really took place, but ignore E part
+          SERIAL_ECHO_START();
+          SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
+        }
+        #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
+          if (destination[E_AXIS] - current_position[E_AXIS] > EXTRUDE_MAXLENGTH) {
+            current_position[E_AXIS] = destination[E_AXIS]; // Behave as if the move really took place, but ignore E part
+            SERIAL_ECHO_START();
+            SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
+          }
+        #endif
+      }
+    }
+
+  #endif
+
+  if (
+    #if UBL_DELTA // Also works for CARTESIAN (smaller segments follow mesh more closely)
+      ubl.prepare_segmented_line_to(destination, feedrate_mm_s)
+    #elif IS_KINEMATIC
+      prepare_kinematic_move_to(destination)
+    #elif ENABLED(DUAL_X_CARRIAGE)
+      prepare_move_to_destination_dualx() || prepare_move_to_destination_cartesian()
+    #else
+      prepare_move_to_destination_cartesian()
+    #endif
+  ) return;
+
+  set_current_to_destination();
+}
+
+#if ENABLED(ARC_SUPPORT)
+
+  #if N_ARC_CORRECTION < 1
+    #undef N_ARC_CORRECTION
+    #define N_ARC_CORRECTION 1
+  #endif
+
+  /**
+   * Plan an arc in 2 dimensions
+   *
+   * The arc is approximated by generating many small linear segments.
+   * The length of each segment is configured in MM_PER_ARC_SEGMENT (Default 1mm)
+   * Arcs should only be made relatively large (over 5mm), as larger arcs with
+   * larger segments will tend to be more efficient. Your slicer should have
+   * options for G2/G3 arc generation. In future these options may be GCode tunable.
+   */
+  void plan_arc(
+    float logical[XYZE], // Destination position
+    float *offset,       // Center of rotation relative to current_position
+    uint8_t clockwise    // Clockwise?
+  ) {
+    #if ENABLED(CNC_WORKSPACE_PLANES)
+      AxisEnum p_axis, q_axis, l_axis;
+      switch (workspace_plane) {
+        case PLANE_XY: p_axis = X_AXIS; q_axis = Y_AXIS; l_axis = Z_AXIS; break;
+        case PLANE_ZX: p_axis = Z_AXIS; q_axis = X_AXIS; l_axis = Y_AXIS; break;
+        case PLANE_YZ: p_axis = Y_AXIS; q_axis = Z_AXIS; l_axis = X_AXIS; break;
+      }
+    #else
+      constexpr AxisEnum p_axis = X_AXIS, q_axis = Y_AXIS, l_axis = Z_AXIS;
+    #endif
+
+    // Radius vector from center to current location
+    float r_P = -offset[0], r_Q = -offset[1];
+
+    const float radius = HYPOT(r_P, r_Q),
+                center_P = current_position[p_axis] - r_P,
+                center_Q = current_position[q_axis] - r_Q,
+                rt_X = logical[p_axis] - center_P,
+                rt_Y = logical[q_axis] - center_Q,
+                linear_travel = logical[l_axis] - current_position[l_axis],
+                extruder_travel = logical[E_AXIS] - current_position[E_AXIS];
+
+    // CCW angle of rotation between position and target from the circle center. Only one atan2() trig computation required.
+    float angular_travel = ATAN2(r_P * rt_Y - r_Q * rt_X, r_P * rt_X + r_Q * rt_Y);
+    if (angular_travel < 0) angular_travel += RADIANS(360);
+    if (clockwise) angular_travel -= RADIANS(360);
+
+    // Make a circle if the angular rotation is 0 and the target is current position
+    if (angular_travel == 0 && current_position[p_axis] == logical[p_axis] && current_position[q_axis] == logical[q_axis])
+      angular_travel = RADIANS(360);
+
+    const float mm_of_travel = HYPOT(angular_travel * radius, FABS(linear_travel));
+    if (mm_of_travel < 0.001) return;
+
+    uint16_t segments = FLOOR(mm_of_travel / (MM_PER_ARC_SEGMENT));
+    if (segments == 0) segments = 1;
+
+    /**
+     * Vector rotation by transformation matrix: r is the original vector, r_T is the rotated vector,
+     * and phi is the angle of rotation. Based on the solution approach by Jens Geisler.
+     *     r_T = [cos(phi) -sin(phi);
+     *            sin(phi)  cos(phi)] * r ;
+     *
+     * For arc generation, the center of the circle is the axis of rotation and the radius vector is
+     * defined from the circle center to the initial position. Each line segment is formed by successive
+     * vector rotations. This requires only two cos() and sin() computations to form the rotation
+     * matrix for the duration of the entire arc. Error may accumulate from numerical round-off, since
+     * all double numbers are single precision on the Arduino. (True double precision will not have
+     * round off issues for CNC applications.) Single precision error can accumulate to be greater than
+     * tool precision in some cases. Therefore, arc path correction is implemented.
+     *
+     * Small angle approximation may be used to reduce computation overhead further. This approximation
+     * holds for everything, but very small circles and large MM_PER_ARC_SEGMENT values. In other words,
+     * theta_per_segment would need to be greater than 0.1 rad and N_ARC_CORRECTION would need to be large
+     * to cause an appreciable drift error. N_ARC_CORRECTION~=25 is more than small enough to correct for
+     * numerical drift error. N_ARC_CORRECTION may be on the order a hundred(s) before error becomes an
+     * issue for CNC machines with the single precision Arduino calculations.
+     *
+     * This approximation also allows plan_arc to immediately insert a line segment into the planner
+     * without the initial overhead of computing cos() or sin(). By the time the arc needs to be applied
+     * a correction, the planner should have caught up to the lag caused by the initial plan_arc overhead.
+     * This is important when there are successive arc motions.
+     */
+    // Vector rotation matrix values
+    float arc_target[XYZE];
+    const float theta_per_segment = angular_travel / segments,
+                linear_per_segment = linear_travel / segments,
+                extruder_per_segment = extruder_travel / segments,
+                sin_T = theta_per_segment,
+                cos_T = 1 - 0.5 * sq(theta_per_segment); // Small angle approximation
+
+    // Initialize the linear axis
+    arc_target[l_axis] = current_position[l_axis];
+
+    // Initialize the extruder axis
+    arc_target[E_AXIS] = current_position[E_AXIS];
+
+    const float fr_mm_s = MMS_SCALED(feedrate_mm_s);
+
+    millis_t next_idle_ms = millis() + 200UL;
+
+    #if N_ARC_CORRECTION > 1
+      int8_t arc_recalc_count = N_ARC_CORRECTION;
+    #endif
+
+    for (uint16_t i = 1; i < segments; i++) { // Iterate (segments-1) times
+
+      thermalManager.manage_heater();
+      if (ELAPSED(millis(), next_idle_ms)) {
+        next_idle_ms = millis() + 200UL;
+        idle();
+      }
+
+      #if N_ARC_CORRECTION > 1
+        if (--arc_recalc_count) {
+          // Apply vector rotation matrix to previous r_P / 1
+          const float r_new_Y = r_P * sin_T + r_Q * cos_T;
+          r_P = r_P * cos_T - r_Q * sin_T;
+          r_Q = r_new_Y;
+        }
+        else
+      #endif
+      {
+        #if N_ARC_CORRECTION > 1
+          arc_recalc_count = N_ARC_CORRECTION;
+        #endif
+
+        // Arc correction to radius vector. Computed only every N_ARC_CORRECTION increments.
+        // Compute exact location by applying transformation matrix from initial radius vector(=-offset).
+        // To reduce stuttering, the sin and cos could be computed at different times.
+        // For now, compute both at the same time.
+        const float cos_Ti = cos(i * theta_per_segment), sin_Ti = sin(i * theta_per_segment);
+        r_P = -offset[0] * cos_Ti + offset[1] * sin_Ti;
+        r_Q = -offset[0] * sin_Ti - offset[1] * cos_Ti;
+      }
+
+      // Update arc_target location
+      arc_target[p_axis] = center_P + r_P;
+      arc_target[q_axis] = center_Q + r_Q;
+      arc_target[l_axis] += linear_per_segment;
+      arc_target[E_AXIS] += extruder_per_segment;
+
+      clamp_to_software_endstops(arc_target);
+
+      planner.buffer_line_kinematic(arc_target, fr_mm_s, active_extruder);
+    }
+
+    // Ensure last segment arrives at target location.
+    planner.buffer_line_kinematic(logical, fr_mm_s, active_extruder);
+
+    // As far as the parser is concerned, the position is now == target. In reality the
+    // motion control system might still be processing the action and the real tool position
+    // in any intermediate location.
+    set_current_to_destination();
+  } // plan_arc
+
+#endif // ARC_SUPPORT
+
+#if ENABLED(BEZIER_CURVE_SUPPORT)
+
+  void plan_cubic_move(const float offset[4]) {
+    cubic_b_spline(current_position, destination, offset, MMS_SCALED(feedrate_mm_s), active_extruder);
+
+    // As far as the parser is concerned, the position is now == destination. In reality the
+    // motion control system might still be processing the action and the real tool position
+    // in any intermediate location.
+    set_current_to_destination();
+  }
+
+#endif // BEZIER_CURVE_SUPPORT
+
+#if ENABLED(USE_CONTROLLER_FAN)
+
+  void controllerFan() {
+    static millis_t lastMotorOn = 0, // Last time a motor was turned on
+                    nextMotorCheck = 0; // Last time the state was checked
+    const millis_t ms = millis();
+    if (ELAPSED(ms, nextMotorCheck)) {
+      nextMotorCheck = ms + 2500UL; // Not a time critical function, so only check every 2.5s
+      if (X_ENABLE_READ == X_ENABLE_ON || Y_ENABLE_READ == Y_ENABLE_ON || Z_ENABLE_READ == Z_ENABLE_ON || thermalManager.soft_pwm_amount_bed > 0
+          || E0_ENABLE_READ == E_ENABLE_ON // If any of the drivers are enabled...
+          #if E_STEPPERS > 1
+            || E1_ENABLE_READ == E_ENABLE_ON
+            #if HAS_X2_ENABLE
+              || X2_ENABLE_READ == X_ENABLE_ON
+            #endif
+            #if E_STEPPERS > 2
+              || E2_ENABLE_READ == E_ENABLE_ON
+              #if E_STEPPERS > 3
+                || E3_ENABLE_READ == E_ENABLE_ON
+                #if E_STEPPERS > 4
+                  || E4_ENABLE_READ == E_ENABLE_ON
+                #endif // E_STEPPERS > 4
+              #endif // E_STEPPERS > 3
+            #endif // E_STEPPERS > 2
+          #endif // E_STEPPERS > 1
+      ) {
+        lastMotorOn = ms; //... set time to NOW so the fan will turn on
+      }
+
+      // Fan off if no steppers have been enabled for CONTROLLERFAN_SECS seconds
+      uint8_t speed = (!lastMotorOn || ELAPSED(ms, lastMotorOn + (CONTROLLERFAN_SECS) * 1000UL)) ? 0 : CONTROLLERFAN_SPEED;
+
+      // allows digital or PWM fan output to be used (see M42 handling)
+      WRITE(CONTROLLER_FAN_PIN, speed);
+      analogWrite(CONTROLLER_FAN_PIN, speed);
+    }
+  }
+
+#endif // USE_CONTROLLER_FAN
+
+#if ENABLED(MORGAN_SCARA)
+
+  /**
+   * Morgan SCARA Forward Kinematics. Results in cartes[].
+   * Maths and first version by QHARLEY.
+   * Integrated into Marlin and slightly restructured by Joachim Cerny.
+   */
+  void forward_kinematics_SCARA(const float &a, const float &b) {
+
+    float a_sin = sin(RADIANS(a)) * L1,
+          a_cos = cos(RADIANS(a)) * L1,
+          b_sin = sin(RADIANS(b)) * L2,
+          b_cos = cos(RADIANS(b)) * L2;
+
+    cartes[X_AXIS] = a_cos + b_cos + SCARA_OFFSET_X;  //theta
+    cartes[Y_AXIS] = a_sin + b_sin + SCARA_OFFSET_Y;  //theta+phi
+
+    /*
+      SERIAL_ECHOPAIR("SCARA FK Angle a=", a);
+      SERIAL_ECHOPAIR(" b=", b);
+      SERIAL_ECHOPAIR(" a_sin=", a_sin);
+      SERIAL_ECHOPAIR(" a_cos=", a_cos);
+      SERIAL_ECHOPAIR(" b_sin=", b_sin);
+      SERIAL_ECHOLNPAIR(" b_cos=", b_cos);
+      SERIAL_ECHOPAIR(" cartes[X_AXIS]=", cartes[X_AXIS]);
+      SERIAL_ECHOLNPAIR(" cartes[Y_AXIS]=", cartes[Y_AXIS]);
+    //*/
+  }
+
+  /**
+   * Morgan SCARA Inverse Kinematics. Results in delta[].
+   *
+   * See http://forums.reprap.org/read.php?185,283327
+   *
+   * Maths and first version by QHARLEY.
+   * Integrated into Marlin and slightly restructured by Joachim Cerny.
+   */
+  void inverse_kinematics(const float logical[XYZ]) {
+
+    static float C2, S2, SK1, SK2, THETA, PSI;
+
+    float sx = RAW_X_POSITION(logical[X_AXIS]) - SCARA_OFFSET_X,  // Translate SCARA to standard X Y
+          sy = RAW_Y_POSITION(logical[Y_AXIS]) - SCARA_OFFSET_Y;  // With scaling factor.
+
+    if (L1 == L2)
+      C2 = HYPOT2(sx, sy) / L1_2_2 - 1;
+    else
+      C2 = (HYPOT2(sx, sy) - (L1_2 + L2_2)) / (2.0 * L1 * L2);
+
+    S2 = SQRT(1 - sq(C2));
+
+    // Unrotated Arm1 plus rotated Arm2 gives the distance from Center to End
+    SK1 = L1 + L2 * C2;
+
+    // Rotated Arm2 gives the distance from Arm1 to Arm2
+    SK2 = L2 * S2;
+
+    // Angle of Arm1 is the difference between Center-to-End angle and the Center-to-Elbow
+    THETA = ATAN2(SK1, SK2) - ATAN2(sx, sy);
+
+    // Angle of Arm2
+    PSI = ATAN2(S2, C2);
+
+    delta[A_AXIS] = DEGREES(THETA);        // theta is support arm angle
+    delta[B_AXIS] = DEGREES(THETA + PSI);  // equal to sub arm angle (inverted motor)
+    delta[C_AXIS] = logical[Z_AXIS];
+
+    /*
+      DEBUG_POS("SCARA IK", logical);
+      DEBUG_POS("SCARA IK", delta);
+      SERIAL_ECHOPAIR("  SCARA (x,y) ", sx);
+      SERIAL_ECHOPAIR(",", sy);
+      SERIAL_ECHOPAIR(" C2=", C2);
+      SERIAL_ECHOPAIR(" S2=", S2);
+      SERIAL_ECHOPAIR(" Theta=", THETA);
+      SERIAL_ECHOLNPAIR(" Phi=", PHI);
+    //*/
+  }
+
+#endif // MORGAN_SCARA
+
+#if ENABLED(TEMP_STAT_LEDS)
+
+  static bool red_led = false;
+  static millis_t next_status_led_update_ms = 0;
+
+  void handle_status_leds(void) {
+    if (ELAPSED(millis(), next_status_led_update_ms)) {
+      next_status_led_update_ms += 500; // Update every 0.5s
+      float max_temp = 0.0;
+      #if HAS_TEMP_BED
+        max_temp = MAX3(max_temp, thermalManager.degTargetBed(), thermalManager.degBed());
+      #endif
+      HOTEND_LOOP()
+        max_temp = MAX3(max_temp, thermalManager.degHotend(e), thermalManager.degTargetHotend(e));
+      const bool new_led = (max_temp > 55.0) ? true : (max_temp < 54.0) ? false : red_led;
+      if (new_led != red_led) {
+        red_led = new_led;
+        #if PIN_EXISTS(STAT_LED_RED)
+          WRITE(STAT_LED_RED_PIN, new_led ? HIGH : LOW);
+          #if PIN_EXISTS(STAT_LED_BLUE)
+            WRITE(STAT_LED_BLUE_PIN, new_led ? LOW : HIGH);
+          #endif
+        #else
+          WRITE(STAT_LED_BLUE_PIN, new_led ? HIGH : LOW);
+        #endif
+      }
+    }
+  }
+
+#endif
+
+#if ENABLED(FILAMENT_RUNOUT_SENSOR)
+
+  void handle_filament_runout() {
+    if (!filament_ran_out) {
+      filament_ran_out = true;
+      enqueue_and_echo_commands_P(PSTR(FILAMENT_RUNOUT_SCRIPT));
+      stepper.synchronize();
+    }
+  }
+
+#endif // FILAMENT_RUNOUT_SENSOR
+
+#if ENABLED(FAST_PWM_FAN)
+
+  void setPwmFrequency(uint8_t pin, int val) {
+    val &= 0x07;
+    switch (digitalPinToTimer(pin)) {
+      #ifdef TCCR0A
+        #if !AVR_AT90USB1286_FAMILY
+          case TIMER0A:
+        #endif
+        case TIMER0B:
+          //_SET_CS(0, val);
+          break;
+      #endif
+      #ifdef TCCR1A
+        case TIMER1A:
+        case TIMER1B:
+          //_SET_CS(1, val);
+          break;
+      #endif
+      #ifdef TCCR2
+        case TIMER2:
+        case TIMER2:
+          _SET_CS(2, val);
+          break;
+      #endif
+      #ifdef TCCR2A
+        case TIMER2A:
+        case TIMER2B:
+          _SET_CS(2, val);
+          break;
+      #endif
+      #ifdef TCCR3A
+        case TIMER3A:
+        case TIMER3B:
+        case TIMER3C:
+          _SET_CS(3, val);
+          break;
+      #endif
+      #ifdef TCCR4A
+        case TIMER4A:
+        case TIMER4B:
+        case TIMER4C:
+          _SET_CS(4, val);
+          break;
+      #endif
+      #ifdef TCCR5A
+        case TIMER5A:
+        case TIMER5B:
+        case TIMER5C:
+          _SET_CS(5, val);
+          break;
+      #endif
+    }
+  }
+
+#endif // FAST_PWM_FAN
+
+float calculate_volumetric_multiplier(const float diameter) {
+  if (!volumetric_enabled || diameter == 0) return 1.0;
+  return 1.0 / (M_PI * sq(diameter * 0.5));
+}
+
+void calculate_volumetric_multipliers() {
+  for (uint8_t i = 0; i < COUNT(filament_size); i++)
+    volumetric_multiplier[i] = calculate_volumetric_multiplier(filament_size[i]);
+}
+
+void enable_all_steppers() {
+  enable_X();
+  enable_Y();
+  enable_Z();
+  enable_E0();
+  enable_E1();
+  enable_E2();
+  enable_E3();
+  enable_E4();
+}
+
+void disable_e_steppers() {
+  disable_E0();
+  disable_E1();
+  disable_E2();
+  disable_E3();
+  disable_E4();
+}
+
+void disable_all_steppers() {
+  disable_X();
+  disable_Y();
+  disable_Z();
+  disable_e_steppers();
+}
+
+#if ENABLED(HAVE_TMC2130)
+
+  void automatic_current_control(TMC2130Stepper &st, String axisID) {
+    // Check otpw even if we don't use automatic control. Allows for flag inspection.
+    const bool is_otpw = st.checkOT();
+
+    // Report if a warning was triggered
+    static bool previous_otpw = false;
+    if (is_otpw && !previous_otpw) {
+      char timestamp[10];
+      duration_t elapsed = print_job_timer.duration();
+      const bool has_days = (elapsed.value > 60*60*24L);
+      (void)elapsed.toDigital(timestamp, has_days);
+      SERIAL_ECHO(timestamp);
+      SERIAL_ECHOPGM(": ");
+      SERIAL_ECHO(axisID);
+      SERIAL_ECHOLNPGM(" driver overtemperature warning!");
+    }
+    previous_otpw = is_otpw;
+
+    #if CURRENT_STEP > 0 && ENABLED(AUTOMATIC_CURRENT_CONTROL)
+      // Return if user has not enabled current control start with M906 S1.
+      if (!auto_current_control) return;
+
+      /**
+       * Decrease current if is_otpw is true.
+       * Bail out if driver is disabled.
+       * Increase current if OTPW has not been triggered yet.
+       */
+      uint16_t current = st.getCurrent();
+      if (is_otpw) {
+        st.setCurrent(current - CURRENT_STEP, R_SENSE, HOLD_MULTIPLIER);
+        #if ENABLED(REPORT_CURRENT_CHANGE)
+          SERIAL_ECHO(axisID);
+          SERIAL_ECHOPAIR(" current decreased to ", st.getCurrent());
+        #endif
+      }
+
+      else if (!st.isEnabled())
+        return;
+
+      else if (!is_otpw && !st.getOTPW()) {
+        current += CURRENT_STEP;
+        if (current <= AUTO_ADJUST_MAX) {
+          st.setCurrent(current, R_SENSE, HOLD_MULTIPLIER);
+          #if ENABLED(REPORT_CURRENT_CHANGE)
+            SERIAL_ECHO(axisID);
+            SERIAL_ECHOPAIR(" current increased to ", st.getCurrent());
+          #endif
+        }
+      }
+      SERIAL_EOL();
+    #endif
+  }
+
+  void checkOverTemp() {
+    static millis_t next_cOT = 0;
+    if (ELAPSED(millis(), next_cOT)) {
+      next_cOT = millis() + 5000;
+      #if ENABLED(X_IS_TMC2130)
+        automatic_current_control(stepperX, "X");
+      #endif
+      #if ENABLED(Y_IS_TMC2130)
+        automatic_current_control(stepperY, "Y");
+      #endif
+      #if ENABLED(Z_IS_TMC2130)
+        automatic_current_control(stepperZ, "Z");
+      #endif
+      #if ENABLED(X2_IS_TMC2130)
+        automatic_current_control(stepperX2, "X2");
+      #endif
+      #if ENABLED(Y2_IS_TMC2130)
+        automatic_current_control(stepperY2, "Y2");
+      #endif
+      #if ENABLED(Z2_IS_TMC2130)
+        automatic_current_control(stepperZ2, "Z2");
+      #endif
+      #if ENABLED(E0_IS_TMC2130)
+        automatic_current_control(stepperE0, "E0");
+      #endif
+      #if ENABLED(E1_IS_TMC2130)
+        automatic_current_control(stepperE1, "E1");
+      #endif
+      #if ENABLED(E2_IS_TMC2130)
+        automatic_current_control(stepperE2, "E2");
+      #endif
+      #if ENABLED(E3_IS_TMC2130)
+        automatic_current_control(stepperE3, "E3");
+      #endif
+      #if ENABLED(E4_IS_TMC2130)
+        automatic_current_control(stepperE4, "E4");
+      #endif
+      #if ENABLED(E4_IS_TMC2130)
+        automatic_current_control(stepperE4);
+      #endif
+    }
+  }
+
+#endif // HAVE_TMC2130
+
+/**
+ * Manage several activities:
+ *  - Check for Filament Runout
+ *  - Keep the command buffer full
+ *  - Check for maximum inactive time between commands
+ *  - Check for maximum inactive time between stepper commands
+ *  - Check if pin CHDK needs to go LOW
+ *  - Check for KILL button held down
+ *  - Check for HOME button held down
+ *  - Check if cooling fan needs to be switched on
+ *  - Check if an idle but hot extruder needs filament extruded (EXTRUDER_RUNOUT_PREVENT)
+ */
+void manage_inactivity(bool ignore_stepper_queue/*=false*/) {
+
+  #if ENABLED(FILAMENT_RUNOUT_SENSOR)
+    if ((IS_SD_PRINTING || print_job_timer.isRunning()) && (READ(FIL_RUNOUT_PIN) == FIL_RUNOUT_INVERTING))
+      handle_filament_runout();
+  #endif
+
+  if (commands_in_queue < BUFSIZE) get_available_commands();
+
+  const millis_t ms = millis();
+
+  if (max_inactive_time && ELAPSED(ms, previous_cmd_ms + max_inactive_time)) {
+    SERIAL_ERROR_START();
+    SERIAL_ECHOLNPAIR(MSG_KILL_INACTIVE_TIME, parser.command_ptr);
+    kill(PSTR(MSG_KILLED));
+  }
+
+  // Prevent steppers timing-out in the middle of M600
+  #if ENABLED(ADVANCED_PAUSE_FEATURE) && ENABLED(PAUSE_PARK_NO_STEPPER_TIMEOUT)
+    #define MOVE_AWAY_TEST !move_away_flag
+  #else
+    #define MOVE_AWAY_TEST true
+  #endif
+
+  if (MOVE_AWAY_TEST && stepper_inactive_time && ELAPSED(ms, previous_cmd_ms + stepper_inactive_time)
+      && !ignore_stepper_queue && !planner.blocks_queued()) {
+    #if ENABLED(DISABLE_INACTIVE_X)
+      disable_X();
+    #endif
+    #if ENABLED(DISABLE_INACTIVE_Y)
+      disable_Y();
+    #endif
+    #if ENABLED(DISABLE_INACTIVE_Z)
+      disable_Z();
+    #endif
+    #if ENABLED(DISABLE_INACTIVE_E)
+      disable_e_steppers();
+    #endif
+    #if ENABLED(AUTO_BED_LEVELING_UBL) && ENABLED(ULTRA_LCD)  // Only needed with an LCD
+      ubl_lcd_map_control = defer_return_to_status = false;
+    #endif
+  }
+
+  #ifdef CHDK // Check if pin should be set to LOW after M240 set it to HIGH
+    if (chdkActive && ELAPSED(ms, chdkHigh + CHDK_DELAY)) {
+      chdkActive = false;
+      WRITE(CHDK, LOW);
+    }
+  #endif
+
+  #if HAS_KILL
+
+    // Check if the kill button was pressed and wait just in case it was an accidental
+    // key kill key press
+    // -------------------------------------------------------------------------------
+    static int killCount = 0;   // make the inactivity button a bit less responsive
+    const int KILL_DELAY = 750;
+    if (!READ(KILL_PIN))
+      killCount++;
+    else if (killCount > 0)
+      killCount--;
+
+    // Exceeded threshold and we can confirm that it was not accidental
+    // KILL the machine
+    // ----------------------------------------------------------------
+    if (killCount >= KILL_DELAY) {
+      SERIAL_ERROR_START();
+      SERIAL_ERRORLNPGM(MSG_KILL_BUTTON);
+      kill(PSTR(MSG_KILLED));
+    }
+  #endif
+
+  #if HAS_HOME
+    // Check to see if we have to home, use poor man's debouncer
+    // ---------------------------------------------------------
+    static int homeDebounceCount = 0;   // poor man's debouncing count
+    const int HOME_DEBOUNCE_DELAY = 2500;
+    if (!IS_SD_PRINTING && !READ(HOME_PIN)) {
+      if (!homeDebounceCount) {
+        enqueue_and_echo_commands_P(PSTR("G28"));
+        LCD_MESSAGEPGM(MSG_AUTO_HOME);
+      }
+      if (homeDebounceCount < HOME_DEBOUNCE_DELAY)
+        homeDebounceCount++;
+      else
+        homeDebounceCount = 0;
+    }
+  #endif
+
+  #if ENABLED(USE_CONTROLLER_FAN)
+    controllerFan(); // Check if fan should be turned on to cool stepper drivers down
+  #endif
+
+  #if ENABLED(EXTRUDER_RUNOUT_PREVENT)
+    if (ELAPSED(ms, previous_cmd_ms + (EXTRUDER_RUNOUT_SECONDS) * 1000UL)
+      && thermalManager.degHotend(active_extruder) > EXTRUDER_RUNOUT_MINTEMP) {
+      #if ENABLED(SWITCHING_EXTRUDER)
+        const bool oldstatus = E0_ENABLE_READ;
+        enable_E0();
+      #else // !SWITCHING_EXTRUDER
+        bool oldstatus;
+        switch (active_extruder) {
+          default: oldstatus = E0_ENABLE_READ; enable_E0(); break;
+          #if E_STEPPERS > 1
+            case 1: oldstatus = E1_ENABLE_READ; enable_E1(); break;
+            #if E_STEPPERS > 2
+              case 2: oldstatus = E2_ENABLE_READ; enable_E2(); break;
+              #if E_STEPPERS > 3
+                case 3: oldstatus = E3_ENABLE_READ; enable_E3(); break;
+                #if E_STEPPERS > 4
+                  case 4: oldstatus = E4_ENABLE_READ; enable_E4(); break;
+                #endif // E_STEPPERS > 4
+              #endif // E_STEPPERS > 3
+            #endif // E_STEPPERS > 2
+          #endif // E_STEPPERS > 1
+        }
+      #endif // !SWITCHING_EXTRUDER
+
+      previous_cmd_ms = ms; // refresh_cmd_timeout()
+
+      const float olde = current_position[E_AXIS];
+      current_position[E_AXIS] += EXTRUDER_RUNOUT_EXTRUDE;
+      planner.buffer_line_kinematic(current_position, MMM_TO_MMS(EXTRUDER_RUNOUT_SPEED), active_extruder);
+      current_position[E_AXIS] = olde;
+      planner.set_e_position_mm(olde);
+      stepper.synchronize();
+      #if ENABLED(SWITCHING_EXTRUDER)
+        E0_ENABLE_WRITE(oldstatus);
+      #else
+        switch (active_extruder) {
+          case 0: E0_ENABLE_WRITE(oldstatus); break;
+          #if E_STEPPERS > 1
+            case 1: E1_ENABLE_WRITE(oldstatus); break;
+            #if E_STEPPERS > 2
+              case 2: E2_ENABLE_WRITE(oldstatus); break;
+              #if E_STEPPERS > 3
+                case 3: E3_ENABLE_WRITE(oldstatus); break;
+                #if E_STEPPERS > 4
+                  case 4: E4_ENABLE_WRITE(oldstatus); break;
+                #endif // E_STEPPERS > 4
+              #endif // E_STEPPERS > 3
+            #endif // E_STEPPERS > 2
+          #endif // E_STEPPERS > 1
+        }
+      #endif // !SWITCHING_EXTRUDER
+    }
+  #endif // EXTRUDER_RUNOUT_PREVENT
+
+  #if ENABLED(DUAL_X_CARRIAGE)
+    // handle delayed move timeout
+    if (delayed_move_time && ELAPSED(ms, delayed_move_time + 1000UL) && IsRunning()) {
+      // travel moves have been received so enact them
+      delayed_move_time = 0xFFFFFFFFUL; // force moves to be done
+      set_destination_to_current();
+      prepare_move_to_destination();
+    }
+  #endif
+
+  #if ENABLED(TEMP_STAT_LEDS)
+    handle_status_leds();
+  #endif
+
+  #if ENABLED(HAVE_TMC2130)
+    checkOverTemp();
+  #endif
+
+  planner.check_axes_activity();
+}
+
+/**
+ * Standard idle routine keeps the machine alive
+ */
+void idle(
+  #if ENABLED(ADVANCED_PAUSE_FEATURE)
+    bool no_stepper_sleep/*=false*/
+  #endif
+) {
+  #if ENABLED(MAX7219_DEBUG)
+    Max7219_idle_tasks();
+  #endif  // MAX7219_DEBUG
+
+  lcd_update();
+
+  host_keepalive();
+
+  #if ENABLED(AUTO_REPORT_TEMPERATURES) && (HAS_TEMP_HOTEND || HAS_TEMP_BED)
+    auto_report_temperatures();
+  #endif
+
+  manage_inactivity(
+    #if ENABLED(ADVANCED_PAUSE_FEATURE)
+      no_stepper_sleep
+    #endif
+  );
+
+  thermalManager.manage_heater();
+
+  #if ENABLED(PRINTCOUNTER)
+    print_job_timer.tick();
+  #endif
+
+  #if HAS_BUZZER && DISABLED(LCD_USE_I2C_BUZZER)
+    buzzer.tick();
+  #endif
+
+  #if ENABLED(I2C_POSITION_ENCODERS)
+    if (planner.blocks_queued() &&
+        ( (blockBufferIndexRef != planner.block_buffer_head) ||
+          ((lastUpdateMillis + I2CPE_MIN_UPD_TIME_MS) < millis())) ) {
+      blockBufferIndexRef = planner.block_buffer_head;
+      I2CPEM.update();
+      lastUpdateMillis = millis();
+    }
+  #endif
+}
+
+/**
+ * Kill all activity and lock the machine.
+ * After this the machine will need to be reset.
+ */
+void kill(const char* lcd_msg) {
+  SERIAL_ERROR_START();
+  SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
+
+  thermalManager.disable_all_heaters();
+  disable_all_steppers();
+
+  #if ENABLED(ULTRA_LCD)
+    kill_screen(lcd_msg);
+  #else
+    UNUSED(lcd_msg);
+  #endif
+
+  _delay_ms(600); // Wait a short time (allows messages to get out before shutting down.
+  cli(); // Stop interrupts
+
+  _delay_ms(250); //Wait to ensure all interrupts routines stopped
+  thermalManager.disable_all_heaters(); //turn off heaters again
+
+  #ifdef ACTION_ON_KILL
+    SERIAL_ECHOLNPGM("//action:" ACTION_ON_KILL);
+  #endif
+
+  #if HAS_POWER_SWITCH
+    SET_INPUT(PS_ON_PIN);
+  #endif
+
+  suicide();
+  while (1) {
+    #if ENABLED(USE_WATCHDOG)
+      watchdog_reset();
+    #endif
+  } // Wait for reset
+}
+
+/**
+ * Turn off heaters and stop the print in progress
+ * After a stop the machine may be resumed with M999
+ */
+void stop() {
+  thermalManager.disable_all_heaters(); // 'unpause' taken care of in here
+
+  #if ENABLED(PROBING_FANS_OFF)
+    if (fans_paused) fans_pause(false); // put things back the way they were
+  #endif
+
+  if (IsRunning()) {
+    Stopped_gcode_LastN = gcode_LastN; // Save last g_code for restart
+    SERIAL_ERROR_START();
+    SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
+    LCD_MESSAGEPGM(MSG_STOPPED);
+    safe_delay(350);       // allow enough time for messages to get out before stopping
+    Running = false;
+  }
+}
+
+/**
+ * Marlin entry-point: Set up before the program loop
+ *  - Set up the kill pin, filament runout, power hold
+ *  - Start the serial port
+ *  - Print startup messages and diagnostics
+ *  - Get EEPROM or default settings
+ *  - Initialize managers for:
+ *    • temperature
+ *    • planner
+ *    • watchdog
+ *    • stepper
+ *    • photo pin
+ *    • servos
+ *    • LCD controller
+ *    • Digipot I2C
+ *    • Z probe sled
+ *    • status LEDs
+ */
+void setup() {
+
+  #if ENABLED(MAX7219_DEBUG)
+    Max7219_init();
+  #endif
+
+  #ifdef DISABLE_JTAG
+    // Disable JTAG on AT90USB chips to free up pins for IO
+    MCUCR = 0x80;
+    MCUCR = 0x80;
+  #endif
+
+  #if ENABLED(FILAMENT_RUNOUT_SENSOR)
+    setup_filrunoutpin();
+  #endif
+
+  setup_killpin();
+
+  setup_powerhold();
+
+  #if HAS_STEPPER_RESET
+    disableStepperDrivers();
+  #endif
+
+  MYSERIAL.begin(BAUDRATE);
+  while(!MYSERIAL);
+  SERIAL_PROTOCOLLNPGM("start");
+  SERIAL_ECHO_START();
+
+  // Check startup - does nothing if bootloader sets MCUSR to 0
+  byte mcu = HAL_get_reset_source();
+  if (mcu &  1) SERIAL_ECHOLNPGM(MSG_POWERUP);
+  if (mcu &  2) SERIAL_ECHOLNPGM(MSG_EXTERNAL_RESET);
+  if (mcu &  4) SERIAL_ECHOLNPGM(MSG_BROWNOUT_RESET);
+  if (mcu &  8) SERIAL_ECHOLNPGM(MSG_WATCHDOG_RESET);
+  if (mcu & 32) SERIAL_ECHOLNPGM(MSG_SOFTWARE_RESET);
+  HAL_clear_reset_source();
+
+  #if ENABLED(USE_WATCHDOG) //reinit watchdog after HAL_get_reset_source call
+    watchdog_init();
+  #endif
+
+  SERIAL_ECHOPGM(MSG_MARLIN);
+  SERIAL_CHAR(' ');
+  SERIAL_ECHOLNPGM(SHORT_BUILD_VERSION);
+  SERIAL_EOL();
+
+  #if defined(STRING_DISTRIBUTION_DATE) && defined(STRING_CONFIG_H_AUTHOR)
+    SERIAL_ECHO_START();
+    SERIAL_ECHOPGM(MSG_CONFIGURATION_VER);
+    SERIAL_ECHOPGM(STRING_DISTRIBUTION_DATE);
+    SERIAL_ECHOLNPGM(MSG_AUTHOR STRING_CONFIG_H_AUTHOR);
+    SERIAL_ECHO_START();
+    SERIAL_ECHOLNPGM("Compiled: " __DATE__);
+  #endif
+
+  SERIAL_ECHO_START();
+  SERIAL_ECHOPAIR(MSG_FREE_MEMORY, freeMemory());
+  SERIAL_ECHOLNPAIR(MSG_PLANNER_BUFFER_BYTES, (int)sizeof(block_t)*BLOCK_BUFFER_SIZE);
+
+  // Send "ok" after commands by default
+  for (int8_t i = 0; i < BUFSIZE; i++) send_ok[i] = true;
+
+  // Load data from EEPROM if available (or use defaults)
+  // This also updates variables in the planner, elsewhere
+  (void)settings.load();
+
+  #if HAS_M206_COMMAND
+    // Initialize current position based on home_offset
+    COPY(current_position, home_offset);
+  #else
+    ZERO(current_position);
+  #endif
+
+  // Vital to init stepper/planner equivalent for current_position
+  SYNC_PLAN_POSITION_KINEMATIC();
+
+  thermalManager.init();    // Initialize temperature loop
+
+  stepper.init();    // Initialize stepper, this enables interrupts!
+  servo_init();
+
+  #if HAS_PHOTOGRAPH
+    OUT_WRITE(PHOTOGRAPH_PIN, LOW);
+  #endif
+
+  #if HAS_CASE_LIGHT
+    case_light_on = CASE_LIGHT_DEFAULT_ON;
+    case_light_brightness = CASE_LIGHT_DEFAULT_BRIGHTNESS;
+    update_case_light();
+  #endif
+
+  #if ENABLED(SPINDLE_LASER_ENABLE)
+    OUT_WRITE(SPINDLE_LASER_ENABLE_PIN, !SPINDLE_LASER_ENABLE_INVERT);  // init spindle to off
+    #if SPINDLE_DIR_CHANGE
+      OUT_WRITE(SPINDLE_DIR_PIN, SPINDLE_INVERT_DIR ? 255 : 0);  // init rotation to clockwise (M3)
+    #endif
+    #if ENABLED(SPINDLE_LASER_PWM)
+      SET_OUTPUT(SPINDLE_LASER_PWM_PIN);
+      analogWrite(SPINDLE_LASER_PWM_PIN, SPINDLE_LASER_PWM_INVERT ? 255 : 0);  // set to lowest speed
+    #endif
+  #endif
+
+  #if HAS_BED_PROBE
+    endstops.enable_z_probe(false);
+  #endif
+
+  #if ENABLED(USE_CONTROLLER_FAN)
+    SET_OUTPUT(CONTROLLER_FAN_PIN); //Set pin used for driver cooling fan
+  #endif
+
+  #if HAS_STEPPER_RESET
+    enableStepperDrivers();
+  #endif
+
+  #if ENABLED(DIGIPOT_I2C)
+    digipot_i2c_init();
+  #endif
+
+  #if ENABLED(DAC_STEPPER_CURRENT)
+    dac_init();
+  #endif
+
+  #if (ENABLED(Z_PROBE_SLED) || ENABLED(SOLENOID_PROBE)) && HAS_SOLENOID_1
+    OUT_WRITE(SOL1_PIN, LOW); // turn it off
+  #endif
+
+  #if HAS_HOME
+    SET_INPUT_PULLUP(HOME_PIN);
+  #endif
+
+  #if PIN_EXISTS(STAT_LED_RED)
+    OUT_WRITE(STAT_LED_RED_PIN, LOW); // turn it off
+  #endif
+
+  #if PIN_EXISTS(STAT_LED_BLUE)
+    OUT_WRITE(STAT_LED_BLUE_PIN, LOW); // turn it off
+  #endif
+
+  #if ENABLED(NEOPIXEL_RGBW_LED)
+    SET_OUTPUT(NEOPIXEL_PIN);
+    setup_neopixel();
+  #endif
+
+  #if ENABLED(RGB_LED) || ENABLED(RGBW_LED)
+    SET_OUTPUT(RGB_LED_R_PIN);
+    SET_OUTPUT(RGB_LED_G_PIN);
+    SET_OUTPUT(RGB_LED_B_PIN);
+    #if ENABLED(RGBW_LED)
+      SET_OUTPUT(RGB_LED_W_PIN);
+    #endif
+  #endif
+
+  #if ENABLED(MK2_MULTIPLEXER)
+    SET_OUTPUT(E_MUX0_PIN);
+    SET_OUTPUT(E_MUX1_PIN);
+    SET_OUTPUT(E_MUX2_PIN);
+  #endif
+
+  #if HAS_FANMUX
+    fanmux_init();
+  #endif
+
+  lcd_init();
+
+  #ifndef CUSTOM_BOOTSCREEN_TIMEOUT
+    #define CUSTOM_BOOTSCREEN_TIMEOUT 2500
+  #endif
+
+  #if ENABLED(SHOW_BOOTSCREEN)
+    #if ENABLED(DOGLCD)                           // On DOGM the first bootscreen is already drawn
+      #if ENABLED(SHOW_CUSTOM_BOOTSCREEN)
+        safe_delay(CUSTOM_BOOTSCREEN_TIMEOUT);    // Custom boot screen pause
+        lcd_bootscreen();                         // Show Marlin boot screen
+      #endif
+      safe_delay(BOOTSCREEN_TIMEOUT);             // Pause
+    #elif ENABLED(ULTRA_LCD)
+      lcd_bootscreen();
+      #if DISABLED(SDSUPPORT)
+        lcd_init();
+      #endif
+    #endif
+  #endif
+
+  #if ENABLED(MIXING_EXTRUDER) && MIXING_VIRTUAL_TOOLS > 1
+    // Initialize mixing to 100% color 1
+    for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
+      mixing_factor[i] = (i == 0) ? 1.0 : 0.0;
+    for (uint8_t t = 0; t < MIXING_VIRTUAL_TOOLS; t++)
+      for (uint8_t i = 0; i < MIXING_STEPPERS; i++)
+        mixing_virtual_tool_mix[t][i] = mixing_factor[i];
+  #endif
+
+  #if ENABLED(BLTOUCH)
+    // Make sure any BLTouch error condition is cleared
+    bltouch_command(BLTOUCH_RESET);
+    set_bltouch_deployed(true);
+    set_bltouch_deployed(false);
+  #endif
+
+  #if ENABLED(I2C_POSITION_ENCODERS)
+    I2CPEM.init();
+  #endif
+
+  #if ENABLED(EXPERIMENTAL_I2CBUS) && I2C_SLAVE_ADDRESS > 0
+    i2c.onReceive(i2c_on_receive);
+    i2c.onRequest(i2c_on_request);
+  #endif
+
+  #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
+    setup_endstop_interrupts();
+  #endif
+
+  #if ENABLED(SWITCHING_EXTRUDER) && !DONT_SWITCH
+    move_extruder_servo(0);  // Initialize extruder servo
+  #endif
+
+  #if ENABLED(SWITCHING_NOZZLE)
+    move_nozzle_servo(0);  // Initialize nozzle servo
+  #endif
+
+  #if ENABLED(PARKING_EXTRUDER)
+    #if ENABLED(PARKING_EXTRUDER_SOLENOIDS_INVERT)
+      pe_activate_magnet(0);
+      pe_activate_magnet(1);
+    #else
+      pe_deactivate_magnet(0);
+      pe_deactivate_magnet(1);
+    #endif
+  #endif
+}
+
+/**
+ * The main Marlin program loop
+ *
+ *  - Save or log commands to SD
+ *  - Process available commands (if not saving)
+ *  - Call heater manager
+ *  - Call inactivity manager
+ *  - Call endstop manager
+ *  - Call LCD update
+ */
+void loop() {
+  if (commands_in_queue < BUFSIZE) get_available_commands();
+
+  #if ENABLED(SDSUPPORT)
+    card.checkautostart(false);
+  #endif
+
+  if (commands_in_queue) {
+
+    #if ENABLED(SDSUPPORT)
+
+      if (card.saving) {
+        char* command = command_queue[cmd_queue_index_r];
+        if (strstr_P(command, PSTR("M29"))) {
+          // M29 closes the file
+          card.closefile();
+          SERIAL_PROTOCOLLNPGM(MSG_FILE_SAVED);
+          ok_to_send();
+        }
+        else {
+          // Write the string from the read buffer to SD
+          card.write_command(command);
+          if (card.logging)
+            process_next_command(); // The card is saving because it's logging
+          else
+            ok_to_send();
+        }
+      }
+      else
+        process_next_command();
+
+    #else
+
+      process_next_command();
+
+    #endif // SDSUPPORT
+
+    // The queue may be reset by a command handler or by code invoked by idle() within a handler
+    if (commands_in_queue) {
+      --commands_in_queue;
+      if (++cmd_queue_index_r >= BUFSIZE) cmd_queue_index_r = 0;
+    }
+  }
+  endstops.report_state();
+  idle();
+}
