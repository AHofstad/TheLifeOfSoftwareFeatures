commit 87e94f456348e944ba4487aed436c762dd718966
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Mon Apr 1 16:05:11 2024 -0400

    üö∏ Update ProUI Plot graph - part 2 (#26563)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 7377f7dfc0..b08cb812f8 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -95,7 +95,7 @@ public:
   static void report_current_mesh();
   static void report_state();
   static void save_ubl_active_state_and_disable();
-  static void restore_ubl_active_state_and_leave();
+  static void restore_ubl_active_state(const bool is_done=true);
   static void display_map(const uint8_t) __O0;
   static mesh_index_pair find_closest_mesh_point_of_type(const MeshPointType, const xy_pos_t&, const bool=false, MeshFlags *done_flags=nullptr) __O0;
   static mesh_index_pair find_furthest_invalid_mesh_point() __O0;

commit 97e15812fa15cf3ee9f260089282eb5e69915c4e
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Thu Jun 29 13:21:14 2023 -0400

    üî® Makefile + 256K Creality Maple + Heater IDs (#26018)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index f751ce40d0..7377f7dfc0 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -77,7 +77,6 @@ private:
   static bool G29_parse_parameters() __O0;
   static void shift_mesh_height();
   static void probe_entire_mesh(const xy_pos_t &near, const bool do_ubl_mesh_map, const bool stow_probe, const bool do_furthest) __O0;
-  static void tilt_mesh_based_on_3pts(const_float_t z1, const_float_t z2, const_float_t z3);
   static void tilt_mesh_based_on_probed_grid(const bool do_ubl_mesh_map);
   static bool smart_fill_one(const uint8_t x, const uint8_t y, const int8_t xdir, const int8_t ydir);
   static bool smart_fill_one(const xy_uint8_t &pos, const xy_uint8_t &dir) {

commit 2ef71c6ebaa1f1b496eb369879fe22c69cf9adb4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jun 12 16:38:14 2023 -0500

    ‚ôªÔ∏è Simplify SERIAL_ECHO (#25928)
    
    Since this increases AVR code size, try to optimize further.

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index c9bc797429..f751ce40d0 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -279,10 +279,8 @@ public:
       if (DEBUGGING(MESH_ADJUST)) DEBUG_ECHOLNPGM("??? Yikes! NAN in ");
     }
 
-    if (DEBUGGING(MESH_ADJUST)) {
-      DEBUG_ECHOPGM("get_z_correction(", rx0, ", ", ry0);
-      DEBUG_ECHOLNPAIR_F(") => ", z0, 6);
-    }
+    if (DEBUGGING(MESH_ADJUST))
+      DEBUG_ECHOLN(F("get_z_correction("), rx0, F(", "), ry0, F(") => "), p_float_t(z0, 6));
 
     return z0;
   }

commit ba08dcfb76804a912380603b3f69831ea0d1d6eb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jun 3 04:40:07 2023 -0500

    üßë‚Äçüíª Fix narrowing conversions (#25924)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 785cb5d883..c9bc797429 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -141,26 +141,26 @@ public:
     return FLOOR((y - (MESH_MIN_Y)) * RECIPROCAL(MESH_Y_DIST));
   }
 
-  static int8_t cell_index_x_valid(const_float_t x) {
+  static bool cell_index_x_valid(const_float_t x) {
     return WITHIN(cell_index_x_raw(x), 0, GRID_MAX_CELLS_X - 1);
   }
 
-  static int8_t cell_index_y_valid(const_float_t y) {
+  static bool cell_index_y_valid(const_float_t y) {
     return WITHIN(cell_index_y_raw(y), 0, GRID_MAX_CELLS_Y - 1);
   }
 
-  static int8_t cell_index_x(const_float_t x) {
+  static uint8_t cell_index_x(const_float_t x) {
     return constrain(cell_index_x_raw(x), 0, GRID_MAX_CELLS_X - 1);
   }
 
-  static int8_t cell_index_y(const_float_t y) {
+  static uint8_t cell_index_y(const_float_t y) {
     return constrain(cell_index_y_raw(y), 0, GRID_MAX_CELLS_Y - 1);
   }
 
-  static xy_int8_t cell_indexes(const_float_t x, const_float_t y) {
+  static xy_uint8_t cell_indexes(const_float_t x, const_float_t y) {
     return { cell_index_x(x), cell_index_y(y) };
   }
-  static xy_int8_t cell_indexes(const xy_pos_t &xy) { return cell_indexes(xy.x, xy.y); }
+  static xy_uint8_t cell_indexes(const xy_pos_t &xy) { return cell_indexes(xy.x, xy.y); }
 
   static int8_t closest_x_index(const_float_t x) {
     const int8_t px = (x - (MESH_MIN_X) + (MESH_X_DIST) * 0.5) * RECIPROCAL(MESH_X_DIST);

commit 060ddf5e950b104b00f5d20adf858a9ad00ab72e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue May 16 02:52:52 2023 -0500

    üö∏ Support Bed Leveling Mesh > 16x16
    
    Co-Authored-By: raTmole <ratmole@users.noreply.github.com>

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 05a937c985..785cb5d883 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -48,8 +48,8 @@ struct mesh_index_pair;
 typedef struct {
   bool      C_seen;
   int8_t    KLS_storage_slot;
-  uint8_t   R_repetition,
-            V_verbosity,
+  grid_count_t R_repetition;
+  uint8_t   V_verbosity,
             P_phase,
             T_map_type;
   float     B_shim_thickness,

commit 59f30d384cf94202a3bd28ff1b5c1379841f8695
Author: jamespearson04 <jamespearson04@hotmail.co.uk>
Date:   Fri Mar 3 20:26:38 2023 +0000

    üêõ Fix UBL 'G29 J' mesh tilt (#25453)
    
    Fix regression from #24214

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index ae69e3cd92..05a937c985 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -264,9 +264,9 @@ public:
         return UBL_Z_RAISE_WHEN_OFF_MESH;
     #endif
 
-    const uint8_t mx = _MIN(cx, (GRID_MAX_POINTS_X) - 2) + 1, my = _MIN(cy, (GRID_MAX_POINTS_Y) - 2) + 1,
-                  x0 = get_mesh_x(cx), x1 = get_mesh_x(cx + 1);
-    const float z1 = calc_z0(rx0, x0, z_values[cx][cy], x1, z_values[mx][cy]),
+    const uint8_t mx = _MIN(cx, (GRID_MAX_POINTS_X) - 2) + 1, my = _MIN(cy, (GRID_MAX_POINTS_Y) - 2) + 1;
+    const float x0 = get_mesh_x(cx), x1 = get_mesh_x(cx + 1),
+                z1 = calc_z0(rx0, x0, z_values[cx][cy], x1, z_values[mx][cy]),
                 z2 = calc_z0(rx0, x0, z_values[cx][my], x1, z_values[mx][my]);
     float z0 = calc_z0(ry0, get_mesh_y(cy), z1, get_mesh_y(cy + 1), z2);
 

commit f595878b5b12ba87c88e43160b3434e76c782998
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Feb 8 20:28:56 2023 -0600

    ü©π Various simple fixes

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index a7103d6e18..ae69e3cd92 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -38,8 +38,8 @@ enum MeshPointType : char { INVALID, REAL, SET_IN_BITMAP, CLOSEST };
 
 struct mesh_index_pair;
 
-#define MESH_X_DIST (float(MESH_MAX_X - (MESH_MIN_X)) / (GRID_MAX_CELLS_X))
-#define MESH_Y_DIST (float(MESH_MAX_Y - (MESH_MIN_Y)) / (GRID_MAX_CELLS_Y))
+#define MESH_X_DIST (float((MESH_MAX_X) - (MESH_MIN_X)) / (GRID_MAX_CELLS_X))
+#define MESH_Y_DIST (float((MESH_MAX_Y) - (MESH_MIN_Y)) / (GRID_MAX_CELLS_Y))
 
 #if ENABLED(OPTIMIZED_MESH_STORAGE)
   typedef int16_t mesh_store_t[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];

commit b523ddf1b2820488c6cc46887ee85e8a781ce726
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 19 06:05:52 2022 -0500

    ‚ôªÔ∏è Common Bed Leveling object name, accessors (#24214)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 9dd964c46c..a7103d6e18 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -215,7 +215,7 @@ public:
       return _UBL_OUTER_Z_RAISE;
     }
 
-    const float xratio = (rx0 - mesh_index_to_xpos(x1_i)) * RECIPROCAL(MESH_X_DIST),
+    const float xratio = (rx0 - get_mesh_x(x1_i)) * RECIPROCAL(MESH_X_DIST),
                 z1 = z_values[x1_i][yi];
 
     return z1 + xratio * (z_values[_MIN(x1_i, (GRID_MAX_POINTS_X) - 2) + 1][yi] - z1);  // Don't allow x1_i+1 to be past the end of the array
@@ -238,7 +238,7 @@ public:
       return _UBL_OUTER_Z_RAISE;
     }
 
-    const float yratio = (ry0 - mesh_index_to_ypos(y1_i)) * RECIPROCAL(MESH_Y_DIST),
+    const float yratio = (ry0 - get_mesh_y(y1_i)) * RECIPROCAL(MESH_Y_DIST),
                 z1 = z_values[xi][y1_i];
 
     return z1 + yratio * (z_values[xi][_MIN(y1_i, (GRID_MAX_POINTS_Y) - 2) + 1] - z1);  // Don't allow y1_i+1 to be past the end of the array
@@ -264,16 +264,17 @@ public:
         return UBL_Z_RAISE_WHEN_OFF_MESH;
     #endif
 
-    const uint8_t mx = _MIN(cx, (GRID_MAX_POINTS_X) - 2) + 1, my = _MIN(cy, (GRID_MAX_POINTS_Y) - 2) + 1;
-    const float z1 = calc_z0(rx0, mesh_index_to_xpos(cx), z_values[cx][cy], mesh_index_to_xpos(cx + 1), z_values[mx][cy]);
-    const float z2 = calc_z0(rx0, mesh_index_to_xpos(cx), z_values[cx][my], mesh_index_to_xpos(cx + 1), z_values[mx][my]);
-    float z0 = calc_z0(ry0, mesh_index_to_ypos(cy), z1, mesh_index_to_ypos(cy + 1), z2);
+    const uint8_t mx = _MIN(cx, (GRID_MAX_POINTS_X) - 2) + 1, my = _MIN(cy, (GRID_MAX_POINTS_Y) - 2) + 1,
+                  x0 = get_mesh_x(cx), x1 = get_mesh_x(cx + 1);
+    const float z1 = calc_z0(rx0, x0, z_values[cx][cy], x1, z_values[mx][cy]),
+                z2 = calc_z0(rx0, x0, z_values[cx][my], x1, z_values[mx][my]);
+    float z0 = calc_z0(ry0, get_mesh_y(cy), z1, get_mesh_y(cy + 1), z2);
 
-    if (isnan(z0)) { // if part of the Mesh is undefined, it will show up as NAN
-      z0 = 0.0;      // in ubl.z_values[][] and propagate through the
-                     // calculations. If our correction is NAN, we throw it out
-                     // because part of the Mesh is undefined and we don't have the
-                     // information we need to complete the height correction.
+    if (isnan(z0)) { // If part of the Mesh is undefined, it will show up as NAN
+      z0 = 0.0;      // in z_values[][] and propagate through the calculations.
+                     // If our correction is NAN, we throw it out because part of
+                     // the Mesh is undefined and we don't have the information
+                     // needed to complete the height correction.
 
       if (DEBUGGING(MESH_ADJUST)) DEBUG_ECHOLNPGM("??? Yikes! NAN in ");
     }
@@ -287,10 +288,12 @@ public:
   }
   static float get_z_correction(const xy_pos_t &pos) { return get_z_correction(pos.x, pos.y); }
 
-  static float mesh_index_to_xpos(const uint8_t i) {
+  static constexpr float get_z_offset() { return 0.0f; }
+
+  static float get_mesh_x(const uint8_t i) {
     return i < (GRID_MAX_POINTS_X) ? pgm_read_float(&_mesh_index_to_xpos[i]) : MESH_MIN_X + i * (MESH_X_DIST);
   }
-  static float mesh_index_to_ypos(const uint8_t i) {
+  static float get_mesh_y(const uint8_t i) {
     return i < (GRID_MAX_POINTS_Y) ? pgm_read_float(&_mesh_index_to_ypos[i]) : MESH_MIN_Y + i * (MESH_Y_DIST);
   }
 
@@ -307,11 +310,7 @@ public:
 
 }; // class unified_bed_leveling
 
-extern unified_bed_leveling ubl;
-
-#define _GET_MESH_X(I) ubl.mesh_index_to_xpos(I)
-#define _GET_MESH_Y(J) ubl.mesh_index_to_ypos(J)
-#define Z_VALUES_ARR ubl.z_values
+extern unified_bed_leveling bedlevel;
 
 // Prevent debugging propagating to other files
 #include "../../../core/debug_out.h"

commit 1e749e4f48f528179213e736c99371843a90b4fb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu May 12 20:13:59 2022 -0500

    üßë‚Äçüíª Misc. LCD cleanup

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 8dad966acb..9dd964c46c 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -83,7 +83,6 @@ private:
   static bool smart_fill_one(const xy_uint8_t &pos, const xy_uint8_t &dir) {
     return smart_fill_one(pos.x, pos.y, dir.x, dir.y);
   }
-  static void smart_fill_mesh();
 
   #if ENABLED(UBL_DEVEL_DEBUGGING)
     static void g29_what_command();
@@ -106,6 +105,7 @@ public:
   static void set_all_mesh_points_to_value(const_float_t value);
   static void adjust_mesh_to_mean(const bool cflag, const_float_t value);
   static bool sanity_check();
+  static void smart_fill_mesh();
 
   static void G29() __O0;                           // O0 for no optimization
   static void smart_fill_wlsf(const_float_t ) __O2; // O2 gives smaller code than Os on A2560

commit 659b4172aa49d82e54a08b5ed674b3ba4ad51fb0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu May 5 18:55:43 2022 -0500

    üî® Prevent build attribute define conflicts

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index f117c1af65..8dad966acb 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -70,13 +70,13 @@ private:
     static void move_z_with_encoder(const_float_t multiplier);
     static float measure_point_with_encoder();
     static float measure_business_card_thickness();
-    static void manually_probe_remaining_mesh(const xy_pos_t&, const_float_t , const_float_t , const bool) _O0;
-    static void fine_tune_mesh(const xy_pos_t &pos, const bool do_ubl_mesh_map) _O0;
+    static void manually_probe_remaining_mesh(const xy_pos_t&, const_float_t , const_float_t , const bool) __O0;
+    static void fine_tune_mesh(const xy_pos_t &pos, const bool do_ubl_mesh_map) __O0;
   #endif
 
-  static bool G29_parse_parameters() _O0;
+  static bool G29_parse_parameters() __O0;
   static void shift_mesh_height();
-  static void probe_entire_mesh(const xy_pos_t &near, const bool do_ubl_mesh_map, const bool stow_probe, const bool do_furthest) _O0;
+  static void probe_entire_mesh(const xy_pos_t &near, const bool do_ubl_mesh_map, const bool stow_probe, const bool do_furthest) __O0;
   static void tilt_mesh_based_on_3pts(const_float_t z1, const_float_t z2, const_float_t z3);
   static void tilt_mesh_based_on_probed_grid(const bool do_ubl_mesh_map);
   static bool smart_fill_one(const uint8_t x, const uint8_t y, const int8_t xdir, const int8_t ydir);
@@ -98,17 +98,17 @@ public:
   static void report_state();
   static void save_ubl_active_state_and_disable();
   static void restore_ubl_active_state_and_leave();
-  static void display_map(const uint8_t) _O0;
-  static mesh_index_pair find_closest_mesh_point_of_type(const MeshPointType, const xy_pos_t&, const bool=false, MeshFlags *done_flags=nullptr) _O0;
-  static mesh_index_pair find_furthest_invalid_mesh_point() _O0;
+  static void display_map(const uint8_t) __O0;
+  static mesh_index_pair find_closest_mesh_point_of_type(const MeshPointType, const xy_pos_t&, const bool=false, MeshFlags *done_flags=nullptr) __O0;
+  static mesh_index_pair find_furthest_invalid_mesh_point() __O0;
   static void reset();
   static void invalidate();
   static void set_all_mesh_points_to_value(const_float_t value);
   static void adjust_mesh_to_mean(const bool cflag, const_float_t value);
   static bool sanity_check();
 
-  static void G29() _O0;                          // O0 for no optimization
-  static void smart_fill_wlsf(const_float_t ) _O2; // O2 gives smaller code than Os on A2560
+  static void G29() __O0;                           // O0 for no optimization
+  static void smart_fill_wlsf(const_float_t ) __O2; // O2 gives smaller code than Os on A2560
 
   static int8_t storage_slot;
 

commit ab46b7e2f298826a5512569d6e79bb59a7a6b8ea
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jan 25 15:33:03 2022 -0600

    üßë‚Äçüíª HAS_MARLINUI_MENU, HAS_MANUAL_MOVE_MENU

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 73581504b7..f117c1af65 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -120,7 +120,7 @@ public:
   static const float _mesh_index_to_xpos[GRID_MAX_POINTS_X],
                      _mesh_index_to_ypos[GRID_MAX_POINTS_Y];
 
-  #if HAS_LCD_MENU
+  #if HAS_MARLINUI_MENU
     static bool lcd_map_control;
     static void steppers_were_disabled();
   #else

commit 6fb2d8a25f096d084348a6f6930f515d947474d4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Dec 28 02:57:24 2021 -0600

    üßë‚Äçüíª Remove extraneous 'inline' hints

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index ffabadd990..73581504b7 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -80,7 +80,7 @@ private:
   static void tilt_mesh_based_on_3pts(const_float_t z1, const_float_t z2, const_float_t z3);
   static void tilt_mesh_based_on_probed_grid(const bool do_ubl_mesh_map);
   static bool smart_fill_one(const uint8_t x, const uint8_t y, const int8_t xdir, const int8_t ydir);
-  static inline bool smart_fill_one(const xy_uint8_t &pos, const xy_uint8_t &dir) {
+  static bool smart_fill_one(const xy_uint8_t &pos, const xy_uint8_t &dir) {
     return smart_fill_one(pos.x, pos.y, dir.x, dir.y);
   }
   static void smart_fill_mesh();
@@ -124,7 +124,7 @@ public:
     static bool lcd_map_control;
     static void steppers_were_disabled();
   #else
-    static inline void steppers_were_disabled() {}
+    static void steppers_were_disabled() {}
   #endif
 
   static volatile int16_t encoder_diff; // Volatile because buttons may change it at interrupt time
@@ -157,10 +157,10 @@ public:
     return constrain(cell_index_y_raw(y), 0, GRID_MAX_CELLS_Y - 1);
   }
 
-  static inline xy_int8_t cell_indexes(const_float_t x, const_float_t y) {
+  static xy_int8_t cell_indexes(const_float_t x, const_float_t y) {
     return { cell_index_x(x), cell_index_y(y) };
   }
-  static inline xy_int8_t cell_indexes(const xy_pos_t &xy) { return cell_indexes(xy.x, xy.y); }
+  static xy_int8_t cell_indexes(const xy_pos_t &xy) { return cell_indexes(xy.x, xy.y); }
 
   static int8_t closest_x_index(const_float_t x) {
     const int8_t px = (x - (MESH_MIN_X) + (MESH_X_DIST) * 0.5) * RECIPROCAL(MESH_X_DIST);
@@ -170,7 +170,7 @@ public:
     const int8_t py = (y - (MESH_MIN_Y) + (MESH_Y_DIST) * 0.5) * RECIPROCAL(MESH_Y_DIST);
     return WITHIN(py, 0, (GRID_MAX_POINTS_Y) - 1) ? py : -1;
   }
-  static inline xy_int8_t closest_indexes(const xy_pos_t &xy) {
+  static xy_int8_t closest_indexes(const xy_pos_t &xy) {
     return { closest_x_index(xy.x), closest_y_index(xy.y) };
   }
 
@@ -203,7 +203,7 @@ public:
    * z_correction_for_x_on_horizontal_mesh_line is an optimization for
    * the case where the printer is making a vertical line that only crosses horizontal mesh lines.
    */
-  static inline float z_correction_for_x_on_horizontal_mesh_line(const_float_t rx0, const int x1_i, const int yi) {
+  static float z_correction_for_x_on_horizontal_mesh_line(const_float_t rx0, const int x1_i, const int yi) {
     if (!WITHIN(x1_i, 0, (GRID_MAX_POINTS_X) - 1) || !WITHIN(yi, 0, (GRID_MAX_POINTS_Y) - 1)) {
 
       if (DEBUGGING(LEVELING)) {
@@ -226,7 +226,7 @@ public:
   //
   // See comments above for z_correction_for_x_on_horizontal_mesh_line
   //
-  static inline float z_correction_for_y_on_vertical_mesh_line(const_float_t ry0, const int xi, const int y1_i) {
+  static float z_correction_for_y_on_vertical_mesh_line(const_float_t ry0, const int xi, const int y1_i) {
     if (!WITHIN(xi, 0, (GRID_MAX_POINTS_X) - 1) || !WITHIN(y1_i, 0, (GRID_MAX_POINTS_Y) - 1)) {
 
       if (DEBUGGING(LEVELING)) {
@@ -285,12 +285,12 @@ public:
 
     return z0;
   }
-  static inline float get_z_correction(const xy_pos_t &pos) { return get_z_correction(pos.x, pos.y); }
+  static float get_z_correction(const xy_pos_t &pos) { return get_z_correction(pos.x, pos.y); }
 
-  static inline float mesh_index_to_xpos(const uint8_t i) {
+  static float mesh_index_to_xpos(const uint8_t i) {
     return i < (GRID_MAX_POINTS_X) ? pgm_read_float(&_mesh_index_to_xpos[i]) : MESH_MIN_X + i * (MESH_X_DIST);
   }
-  static inline float mesh_index_to_ypos(const uint8_t i) {
+  static float mesh_index_to_ypos(const uint8_t i) {
     return i < (GRID_MAX_POINTS_Y) ? pgm_read_float(&_mesh_index_to_ypos[i]) : MESH_MIN_Y + i * (MESH_Y_DIST);
   }
 
@@ -300,7 +300,7 @@ public:
     static void line_to_destination_cartesian(const_feedRate_t scaled_fr_mm_s, const uint8_t e);
   #endif
 
-  static inline bool mesh_is_valid() {
+  static bool mesh_is_valid() {
     GRID_LOOP(x, y) if (isnan(z_values[x][y])) return false;
     return true;
   }

commit 754b31918a73cb08c322102be5d3926d2ac59c18
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 9 04:57:05 2021 -0500

    üé® Fewer serial macros

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index cf00a282cf..ffabadd990 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -208,7 +208,7 @@ public:
 
       if (DEBUGGING(LEVELING)) {
         if (WITHIN(x1_i, 0, (GRID_MAX_POINTS_X) - 1)) DEBUG_ECHOPGM("yi"); else DEBUG_ECHOPGM("x1_i");
-        DEBUG_ECHOLNPAIR(" out of bounds in z_correction_for_x_on_horizontal_mesh_line(rx0=", rx0, ",x1_i=", x1_i, ",yi=", yi, ")");
+        DEBUG_ECHOLNPGM(" out of bounds in z_correction_for_x_on_horizontal_mesh_line(rx0=", rx0, ",x1_i=", x1_i, ",yi=", yi, ")");
       }
 
       // The requested location is off the mesh. Return UBL_Z_RAISE_WHEN_OFF_MESH or NAN.
@@ -231,7 +231,7 @@ public:
 
       if (DEBUGGING(LEVELING)) {
         if (WITHIN(xi, 0, (GRID_MAX_POINTS_X) - 1)) DEBUG_ECHOPGM("y1_i"); else DEBUG_ECHOPGM("xi");
-        DEBUG_ECHOLNPAIR(" out of bounds in z_correction_for_y_on_vertical_mesh_line(ry0=", ry0, ", xi=", xi, ", y1_i=", y1_i, ")");
+        DEBUG_ECHOLNPGM(" out of bounds in z_correction_for_y_on_vertical_mesh_line(ry0=", ry0, ", xi=", xi, ", y1_i=", y1_i, ")");
       }
 
       // The requested location is off the mesh. Return UBL_Z_RAISE_WHEN_OFF_MESH or NAN.
@@ -275,11 +275,11 @@ public:
                      // because part of the Mesh is undefined and we don't have the
                      // information we need to complete the height correction.
 
-      if (DEBUGGING(MESH_ADJUST)) DEBUG_ECHOLNPAIR("??? Yikes! NAN in ");
+      if (DEBUGGING(MESH_ADJUST)) DEBUG_ECHOLNPGM("??? Yikes! NAN in ");
     }
 
     if (DEBUGGING(MESH_ADJUST)) {
-      DEBUG_ECHOPAIR("get_z_correction(", rx0, ", ", ry0);
+      DEBUG_ECHOPGM("get_z_correction(", rx0, ", ", ry0);
       DEBUG_ECHOLNPAIR_F(") => ", z0, 6);
     }
 

commit 3a03f76f3c82e93800a07dd2b28a34d0c53245e3
Author: Katelyn Schiesser <katelyn.schiesser@gmail.com>
Date:   Sun Jun 13 18:43:43 2021 -0700

    üêõ Fix UBL 'R' parameter and adjust 'P' (#22129)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 562f15f74b..cf00a282cf 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -47,10 +47,10 @@ struct mesh_index_pair;
 
 typedef struct {
   bool      C_seen;
-  int8_t    V_verbosity,
+  int8_t    KLS_storage_slot;
+  uint8_t   R_repetition,
+            V_verbosity,
             P_phase,
-            R_repetition,
-            KLS_storage_slot,
             T_map_type;
   float     B_shim_thickness,
             C_constant;
@@ -98,7 +98,7 @@ public:
   static void report_state();
   static void save_ubl_active_state_and_disable();
   static void restore_ubl_active_state_and_leave();
-  static void display_map(const int) _O0;
+  static void display_map(const uint8_t) _O0;
   static mesh_index_pair find_closest_mesh_point_of_type(const MeshPointType, const xy_pos_t&, const bool=false, MeshFlags *done_flags=nullptr) _O0;
   static mesh_index_pair find_furthest_invalid_mesh_point() _O0;
   static void reset();

commit 4428affc20eb5ab99a4c0855919f26e5dad1fa1f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri May 7 00:55:39 2021 -0500

    Let M421 C select any point
    
    Fixing #21147

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 0a758a57e9..562f15f74b 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -32,7 +32,7 @@
 #define UBL_OK false
 #define UBL_ERR true
 
-enum MeshPointType : char { INVALID, REAL, SET_IN_BITMAP };
+enum MeshPointType : char { INVALID, REAL, SET_IN_BITMAP, CLOSEST };
 
 // External references
 

commit 528b9bd8729656d7ebcd3dc7898ceddc2f377354
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Apr 16 02:43:59 2021 -0500

    Revert experimental NAN patch
    
    Hold changes from #21575 (24a095c) for more testing.

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index a086c20ba8..0a758a57e9 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -196,7 +196,7 @@ public:
   #ifdef UBL_Z_RAISE_WHEN_OFF_MESH
     #define _UBL_OUTER_Z_RAISE UBL_Z_RAISE_WHEN_OFF_MESH
   #else
-    #define _UBL_OUTER_Z_RAISE MFNAN
+    #define _UBL_OUTER_Z_RAISE NAN
   #endif
 
   /**
@@ -269,7 +269,7 @@ public:
     const float z2 = calc_z0(rx0, mesh_index_to_xpos(cx), z_values[cx][my], mesh_index_to_xpos(cx + 1), z_values[mx][my]);
     float z0 = calc_z0(ry0, mesh_index_to_ypos(cy), z1, mesh_index_to_ypos(cy + 1), z2);
 
-    if (ISNAN(z0)) { // if part of the Mesh is undefined, it will show up as MFNAN
+    if (isnan(z0)) { // if part of the Mesh is undefined, it will show up as NAN
       z0 = 0.0;      // in ubl.z_values[][] and propagate through the
                      // calculations. If our correction is NAN, we throw it out
                      // because part of the Mesh is undefined and we don't have the
@@ -301,7 +301,7 @@ public:
   #endif
 
   static inline bool mesh_is_valid() {
-    GRID_LOOP(x, y) if (ISNAN(z_values[x][y])) return false;
+    GRID_LOOP(x, y) if (isnan(z_values[x][y])) return false;
     return true;
   }
 

commit 24a095c5c14b60bcbffc2807d2c8cc8e9af46e90
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Apr 12 16:49:53 2021 -0500

    Reduce math library code size by 3.4KB (#21575)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index dd6c261341..a086c20ba8 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -196,7 +196,7 @@ public:
   #ifdef UBL_Z_RAISE_WHEN_OFF_MESH
     #define _UBL_OUTER_Z_RAISE UBL_Z_RAISE_WHEN_OFF_MESH
   #else
-    #define _UBL_OUTER_Z_RAISE NAN
+    #define _UBL_OUTER_Z_RAISE MFNAN
   #endif
 
   /**
@@ -264,39 +264,25 @@ public:
         return UBL_Z_RAISE_WHEN_OFF_MESH;
     #endif
 
-    const float z1 = calc_z0(rx0,
-                             mesh_index_to_xpos(cx), z_values[cx][cy],
-                             mesh_index_to_xpos(cx + 1), z_values[_MIN(cx, (GRID_MAX_POINTS_X) - 2) + 1][cy]);
+    const uint8_t mx = _MIN(cx, (GRID_MAX_POINTS_X) - 2) + 1, my = _MIN(cy, (GRID_MAX_POINTS_Y) - 2) + 1;
+    const float z1 = calc_z0(rx0, mesh_index_to_xpos(cx), z_values[cx][cy], mesh_index_to_xpos(cx + 1), z_values[mx][cy]);
+    const float z2 = calc_z0(rx0, mesh_index_to_xpos(cx), z_values[cx][my], mesh_index_to_xpos(cx + 1), z_values[mx][my]);
+    float z0 = calc_z0(ry0, mesh_index_to_ypos(cy), z1, mesh_index_to_ypos(cy + 1), z2);
 
-    const float z2 = calc_z0(rx0,
-                             mesh_index_to_xpos(cx), z_values[cx][_MIN(cy, (GRID_MAX_POINTS_Y) - 2) + 1],
-                             mesh_index_to_xpos(cx + 1), z_values[_MIN(cx, (GRID_MAX_POINTS_X) - 2) + 1][_MIN(cy, (GRID_MAX_POINTS_Y) - 2) + 1]);
-
-    float z0 = calc_z0(ry0,
-                       mesh_index_to_ypos(cy), z1,
-                       mesh_index_to_ypos(cy + 1), z2);
-
-    if (DEBUGGING(MESH_ADJUST)) {
-      DEBUG_ECHOPAIR(" raw get_z_correction(", rx0);
-      DEBUG_CHAR(','); DEBUG_ECHO(ry0);
-      DEBUG_ECHOPAIR_F(") = ", z0, 6);
-      DEBUG_ECHOLNPAIR_F(" >>>---> ", z0, 6);
-    }
-
-    if (isnan(z0)) { // if part of the Mesh is undefined, it will show up as NAN
+    if (ISNAN(z0)) { // if part of the Mesh is undefined, it will show up as MFNAN
       z0 = 0.0;      // in ubl.z_values[][] and propagate through the
                      // calculations. If our correction is NAN, we throw it out
                      // because part of the Mesh is undefined and we don't have the
                      // information we need to complete the height correction.
 
-      if (DEBUGGING(MESH_ADJUST)) {
-        DEBUG_ECHOPAIR("??? Yikes!  NAN in get_z_correction(", rx0);
-        DEBUG_CHAR(',');
-        DEBUG_ECHO(ry0);
-        DEBUG_CHAR(')');
-        DEBUG_EOL();
-      }
+      if (DEBUGGING(MESH_ADJUST)) DEBUG_ECHOLNPAIR("??? Yikes! NAN in ");
     }
+
+    if (DEBUGGING(MESH_ADJUST)) {
+      DEBUG_ECHOPAIR("get_z_correction(", rx0, ", ", ry0);
+      DEBUG_ECHOLNPAIR_F(") => ", z0, 6);
+    }
+
     return z0;
   }
   static inline float get_z_correction(const xy_pos_t &pos) { return get_z_correction(pos.x, pos.y); }
@@ -315,7 +301,7 @@ public:
   #endif
 
   static inline bool mesh_is_valid() {
-    GRID_LOOP(x, y) if (isnan(z_values[x][y])) return false;
+    GRID_LOOP(x, y) if (ISNAN(z_values[x][y])) return false;
     return true;
   }
 

commit 45c1432946547cef4cbe9ac832394ff68526687d
Author: Marcio T <mlt4356-github@yahoo.com>
Date:   Thu Apr 1 18:12:00 2021 -0600

    G26 Hilbert Curve followup (#21480)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 222e7b0f20..dd6c261341 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -38,8 +38,8 @@ enum MeshPointType : char { INVALID, REAL, SET_IN_BITMAP };
 
 struct mesh_index_pair;
 
-#define MESH_X_DIST (float(MESH_MAX_X - (MESH_MIN_X)) / float(GRID_MAX_POINTS_X - 1))
-#define MESH_Y_DIST (float(MESH_MAX_Y - (MESH_MIN_Y)) / float(GRID_MAX_POINTS_Y - 1))
+#define MESH_X_DIST (float(MESH_MAX_X - (MESH_MIN_X)) / (GRID_MAX_CELLS_X))
+#define MESH_Y_DIST (float(MESH_MAX_Y - (MESH_MIN_Y)) / (GRID_MAX_CELLS_Y))
 
 #if ENABLED(OPTIMIZED_MESH_STORAGE)
   typedef int16_t mesh_store_t[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
@@ -142,19 +142,19 @@ public:
   }
 
   static int8_t cell_index_x_valid(const_float_t x) {
-    return WITHIN(cell_index_x_raw(x), 0, (GRID_MAX_POINTS_X - 2));
+    return WITHIN(cell_index_x_raw(x), 0, GRID_MAX_CELLS_X - 1);
   }
 
   static int8_t cell_index_y_valid(const_float_t y) {
-    return WITHIN(cell_index_y_raw(y), 0, (GRID_MAX_POINTS_Y - 2));
+    return WITHIN(cell_index_y_raw(y), 0, GRID_MAX_CELLS_Y - 1);
   }
 
   static int8_t cell_index_x(const_float_t x) {
-    return constrain(cell_index_x_raw(x), 0, (GRID_MAX_POINTS_X) - 2);
+    return constrain(cell_index_x_raw(x), 0, GRID_MAX_CELLS_X - 1);
   }
 
   static int8_t cell_index_y(const_float_t y) {
-    return constrain(cell_index_y_raw(y), 0, (GRID_MAX_POINTS_Y) - 2);
+    return constrain(cell_index_y_raw(y), 0, GRID_MAX_CELLS_Y - 1);
   }
 
   static inline xy_int8_t cell_indexes(const_float_t x, const_float_t y) {
@@ -164,11 +164,11 @@ public:
 
   static int8_t closest_x_index(const_float_t x) {
     const int8_t px = (x - (MESH_MIN_X) + (MESH_X_DIST) * 0.5) * RECIPROCAL(MESH_X_DIST);
-    return WITHIN(px, 0, GRID_MAX_POINTS_X - 1) ? px : -1;
+    return WITHIN(px, 0, (GRID_MAX_POINTS_X) - 1) ? px : -1;
   }
   static int8_t closest_y_index(const_float_t y) {
     const int8_t py = (y - (MESH_MIN_Y) + (MESH_Y_DIST) * 0.5) * RECIPROCAL(MESH_Y_DIST);
-    return WITHIN(py, 0, GRID_MAX_POINTS_Y - 1) ? py : -1;
+    return WITHIN(py, 0, (GRID_MAX_POINTS_Y) - 1) ? py : -1;
   }
   static inline xy_int8_t closest_indexes(const xy_pos_t &xy) {
     return { closest_x_index(xy.x), closest_y_index(xy.y) };
@@ -204,10 +204,10 @@ public:
    * the case where the printer is making a vertical line that only crosses horizontal mesh lines.
    */
   static inline float z_correction_for_x_on_horizontal_mesh_line(const_float_t rx0, const int x1_i, const int yi) {
-    if (!WITHIN(x1_i, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(yi, 0, GRID_MAX_POINTS_Y - 1)) {
+    if (!WITHIN(x1_i, 0, (GRID_MAX_POINTS_X) - 1) || !WITHIN(yi, 0, (GRID_MAX_POINTS_Y) - 1)) {
 
       if (DEBUGGING(LEVELING)) {
-        if (WITHIN(x1_i, 0, GRID_MAX_POINTS_X - 1)) DEBUG_ECHOPGM("yi"); else DEBUG_ECHOPGM("x1_i");
+        if (WITHIN(x1_i, 0, (GRID_MAX_POINTS_X) - 1)) DEBUG_ECHOPGM("yi"); else DEBUG_ECHOPGM("x1_i");
         DEBUG_ECHOLNPAIR(" out of bounds in z_correction_for_x_on_horizontal_mesh_line(rx0=", rx0, ",x1_i=", x1_i, ",yi=", yi, ")");
       }
 
@@ -218,19 +218,19 @@ public:
     const float xratio = (rx0 - mesh_index_to_xpos(x1_i)) * RECIPROCAL(MESH_X_DIST),
                 z1 = z_values[x1_i][yi];
 
-    return z1 + xratio * (z_values[_MIN(x1_i, GRID_MAX_POINTS_X - 2) + 1][yi] - z1); // Don't allow x1_i+1 to be past the end of the array
-                                                                                    // If it is, it is clamped to the last element of the
-                                                                                    // z_values[][] array and no correction is applied.
+    return z1 + xratio * (z_values[_MIN(x1_i, (GRID_MAX_POINTS_X) - 2) + 1][yi] - z1);  // Don't allow x1_i+1 to be past the end of the array
+                                                                                        // If it is, it is clamped to the last element of the
+                                                                                        // z_values[][] array and no correction is applied.
   }
 
   //
   // See comments above for z_correction_for_x_on_horizontal_mesh_line
   //
   static inline float z_correction_for_y_on_vertical_mesh_line(const_float_t ry0, const int xi, const int y1_i) {
-    if (!WITHIN(xi, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(y1_i, 0, GRID_MAX_POINTS_Y - 1)) {
+    if (!WITHIN(xi, 0, (GRID_MAX_POINTS_X) - 1) || !WITHIN(y1_i, 0, (GRID_MAX_POINTS_Y) - 1)) {
 
       if (DEBUGGING(LEVELING)) {
-        if (WITHIN(xi, 0, GRID_MAX_POINTS_X - 1)) DEBUG_ECHOPGM("y1_i"); else DEBUG_ECHOPGM("xi");
+        if (WITHIN(xi, 0, (GRID_MAX_POINTS_X) - 1)) DEBUG_ECHOPGM("y1_i"); else DEBUG_ECHOPGM("xi");
         DEBUG_ECHOLNPAIR(" out of bounds in z_correction_for_y_on_vertical_mesh_line(ry0=", ry0, ", xi=", xi, ", y1_i=", y1_i, ")");
       }
 
@@ -241,9 +241,9 @@ public:
     const float yratio = (ry0 - mesh_index_to_ypos(y1_i)) * RECIPROCAL(MESH_Y_DIST),
                 z1 = z_values[xi][y1_i];
 
-    return z1 + yratio * (z_values[xi][_MIN(y1_i, GRID_MAX_POINTS_Y - 2) + 1] - z1); // Don't allow y1_i+1 to be past the end of the array
-                                                                                    // If it is, it is clamped to the last element of the
-                                                                                    // z_values[][] array and no correction is applied.
+    return z1 + yratio * (z_values[xi][_MIN(y1_i, (GRID_MAX_POINTS_Y) - 2) + 1] - z1);  // Don't allow y1_i+1 to be past the end of the array
+                                                                                        // If it is, it is clamped to the last element of the
+                                                                                        // z_values[][] array and no correction is applied.
   }
 
   /**
@@ -266,11 +266,11 @@ public:
 
     const float z1 = calc_z0(rx0,
                              mesh_index_to_xpos(cx), z_values[cx][cy],
-                             mesh_index_to_xpos(cx + 1), z_values[_MIN(cx, GRID_MAX_POINTS_X - 2) + 1][cy]);
+                             mesh_index_to_xpos(cx + 1), z_values[_MIN(cx, (GRID_MAX_POINTS_X) - 2) + 1][cy]);
 
     const float z2 = calc_z0(rx0,
-                             mesh_index_to_xpos(cx), z_values[cx][_MIN(cy, GRID_MAX_POINTS_Y - 2) + 1],
-                             mesh_index_to_xpos(cx + 1), z_values[_MIN(cx, GRID_MAX_POINTS_X - 2) + 1][_MIN(cy, GRID_MAX_POINTS_Y - 2) + 1]);
+                             mesh_index_to_xpos(cx), z_values[cx][_MIN(cy, (GRID_MAX_POINTS_Y) - 2) + 1],
+                             mesh_index_to_xpos(cx + 1), z_values[_MIN(cx, (GRID_MAX_POINTS_X) - 2) + 1][_MIN(cy, (GRID_MAX_POINTS_Y) - 2) + 1]);
 
     float z0 = calc_z0(ry0,
                        mesh_index_to_ypos(cy), z1,
@@ -302,10 +302,10 @@ public:
   static inline float get_z_correction(const xy_pos_t &pos) { return get_z_correction(pos.x, pos.y); }
 
   static inline float mesh_index_to_xpos(const uint8_t i) {
-    return i < GRID_MAX_POINTS_X ? pgm_read_float(&_mesh_index_to_xpos[i]) : MESH_MIN_X + i * (MESH_X_DIST);
+    return i < (GRID_MAX_POINTS_X) ? pgm_read_float(&_mesh_index_to_xpos[i]) : MESH_MIN_X + i * (MESH_X_DIST);
   }
   static inline float mesh_index_to_ypos(const uint8_t i) {
-    return i < GRID_MAX_POINTS_Y ? pgm_read_float(&_mesh_index_to_ypos[i]) : MESH_MIN_Y + i * (MESH_Y_DIST);
+    return i < (GRID_MAX_POINTS_Y) ? pgm_read_float(&_mesh_index_to_ypos[i]) : MESH_MIN_Y + i * (MESH_Y_DIST);
   }
 
   #if UBL_SEGMENTED

commit 62f37669dc506a6e579389ca549ce5993548944d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Apr 1 17:59:57 2021 -0500

    Replace 'const float &' with 'const_float_t' (#21505)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index acc191908c..222e7b0f20 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -67,17 +67,17 @@ private:
   static G29_parameters_t param;
 
   #if IS_NEWPANEL
-    static void move_z_with_encoder(const float &multiplier);
+    static void move_z_with_encoder(const_float_t multiplier);
     static float measure_point_with_encoder();
     static float measure_business_card_thickness();
-    static void manually_probe_remaining_mesh(const xy_pos_t&, const float&, const float&, const bool) _O0;
+    static void manually_probe_remaining_mesh(const xy_pos_t&, const_float_t , const_float_t , const bool) _O0;
     static void fine_tune_mesh(const xy_pos_t &pos, const bool do_ubl_mesh_map) _O0;
   #endif
 
   static bool G29_parse_parameters() _O0;
   static void shift_mesh_height();
   static void probe_entire_mesh(const xy_pos_t &near, const bool do_ubl_mesh_map, const bool stow_probe, const bool do_furthest) _O0;
-  static void tilt_mesh_based_on_3pts(const float &z1, const float &z2, const float &z3);
+  static void tilt_mesh_based_on_3pts(const_float_t z1, const_float_t z2, const_float_t z3);
   static void tilt_mesh_based_on_probed_grid(const bool do_ubl_mesh_map);
   static bool smart_fill_one(const uint8_t x, const uint8_t y, const int8_t xdir, const int8_t ydir);
   static inline bool smart_fill_one(const xy_uint8_t &pos, const xy_uint8_t &dir) {
@@ -103,12 +103,12 @@ public:
   static mesh_index_pair find_furthest_invalid_mesh_point() _O0;
   static void reset();
   static void invalidate();
-  static void set_all_mesh_points_to_value(const float value);
-  static void adjust_mesh_to_mean(const bool cflag, const float value);
+  static void set_all_mesh_points_to_value(const_float_t value);
+  static void adjust_mesh_to_mean(const bool cflag, const_float_t value);
   static bool sanity_check();
 
   static void G29() _O0;                          // O0 for no optimization
-  static void smart_fill_wlsf(const float &) _O2; // O2 gives smaller code than Os on A2560
+  static void smart_fill_wlsf(const_float_t ) _O2; // O2 gives smaller code than Os on A2560
 
   static int8_t storage_slot;
 
@@ -131,42 +131,42 @@ public:
 
   unified_bed_leveling();
 
-  FORCE_INLINE static void set_z(const int8_t px, const int8_t py, const float &z) { z_values[px][py] = z; }
+  FORCE_INLINE static void set_z(const int8_t px, const int8_t py, const_float_t z) { z_values[px][py] = z; }
 
-  static int8_t cell_index_x_raw(const float &x) {
+  static int8_t cell_index_x_raw(const_float_t x) {
     return FLOOR((x - (MESH_MIN_X)) * RECIPROCAL(MESH_X_DIST));
   }
 
-  static int8_t cell_index_y_raw(const float &y) {
+  static int8_t cell_index_y_raw(const_float_t y) {
     return FLOOR((y - (MESH_MIN_Y)) * RECIPROCAL(MESH_Y_DIST));
   }
 
-  static int8_t cell_index_x_valid(const float &x) {
+  static int8_t cell_index_x_valid(const_float_t x) {
     return WITHIN(cell_index_x_raw(x), 0, (GRID_MAX_POINTS_X - 2));
   }
 
-  static int8_t cell_index_y_valid(const float &y) {
+  static int8_t cell_index_y_valid(const_float_t y) {
     return WITHIN(cell_index_y_raw(y), 0, (GRID_MAX_POINTS_Y - 2));
   }
 
-  static int8_t cell_index_x(const float &x) {
+  static int8_t cell_index_x(const_float_t x) {
     return constrain(cell_index_x_raw(x), 0, (GRID_MAX_POINTS_X) - 2);
   }
 
-  static int8_t cell_index_y(const float &y) {
+  static int8_t cell_index_y(const_float_t y) {
     return constrain(cell_index_y_raw(y), 0, (GRID_MAX_POINTS_Y) - 2);
   }
 
-  static inline xy_int8_t cell_indexes(const float &x, const float &y) {
+  static inline xy_int8_t cell_indexes(const_float_t x, const_float_t y) {
     return { cell_index_x(x), cell_index_y(y) };
   }
   static inline xy_int8_t cell_indexes(const xy_pos_t &xy) { return cell_indexes(xy.x, xy.y); }
 
-  static int8_t closest_x_index(const float &x) {
+  static int8_t closest_x_index(const_float_t x) {
     const int8_t px = (x - (MESH_MIN_X) + (MESH_X_DIST) * 0.5) * RECIPROCAL(MESH_X_DIST);
     return WITHIN(px, 0, GRID_MAX_POINTS_X - 1) ? px : -1;
   }
-  static int8_t closest_y_index(const float &y) {
+  static int8_t closest_y_index(const_float_t y) {
     const int8_t py = (y - (MESH_MIN_Y) + (MESH_Y_DIST) * 0.5) * RECIPROCAL(MESH_Y_DIST);
     return WITHIN(py, 0, GRID_MAX_POINTS_Y - 1) ? py : -1;
   }
@@ -189,7 +189,7 @@ public:
    *  It is fairly expensive with its 4 floating point additions and 2 floating point
    *  multiplications.
    */
-  FORCE_INLINE static float calc_z0(const float &a0, const float &a1, const float &z1, const float &a2, const float &z2) {
+  FORCE_INLINE static float calc_z0(const_float_t a0, const_float_t a1, const_float_t z1, const_float_t a2, const_float_t z2) {
     return z1 + (z2 - z1) * (a0 - a1) / (a2 - a1);
   }
 
@@ -203,7 +203,7 @@ public:
    * z_correction_for_x_on_horizontal_mesh_line is an optimization for
    * the case where the printer is making a vertical line that only crosses horizontal mesh lines.
    */
-  static inline float z_correction_for_x_on_horizontal_mesh_line(const float &rx0, const int x1_i, const int yi) {
+  static inline float z_correction_for_x_on_horizontal_mesh_line(const_float_t rx0, const int x1_i, const int yi) {
     if (!WITHIN(x1_i, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(yi, 0, GRID_MAX_POINTS_Y - 1)) {
 
       if (DEBUGGING(LEVELING)) {
@@ -226,7 +226,7 @@ public:
   //
   // See comments above for z_correction_for_x_on_horizontal_mesh_line
   //
-  static inline float z_correction_for_y_on_vertical_mesh_line(const float &ry0, const int xi, const int y1_i) {
+  static inline float z_correction_for_y_on_vertical_mesh_line(const_float_t ry0, const int xi, const int y1_i) {
     if (!WITHIN(xi, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(y1_i, 0, GRID_MAX_POINTS_Y - 1)) {
 
       if (DEBUGGING(LEVELING)) {
@@ -252,7 +252,7 @@ public:
    * Z-Height at both ends. Then it does a linear interpolation of these heights based
    * on the Y position within the cell.
    */
-  static float get_z_correction(const float &rx0, const float &ry0) {
+  static float get_z_correction(const_float_t rx0, const_float_t ry0) {
     const int8_t cx = cell_index_x(rx0), cy = cell_index_y(ry0); // return values are clamped
 
     /**
@@ -309,9 +309,9 @@ public:
   }
 
   #if UBL_SEGMENTED
-    static bool line_to_destination_segmented(const feedRate_t &scaled_fr_mm_s);
+    static bool line_to_destination_segmented(const_feedRate_t scaled_fr_mm_s);
   #else
-    static void line_to_destination_cartesian(const feedRate_t &scaled_fr_mm_s, const uint8_t e);
+    static void line_to_destination_cartesian(const_feedRate_t scaled_fr_mm_s, const uint8_t e);
   #endif
 
   static inline bool mesh_is_valid() {

commit bfdd1f4662f74c9db1cb62cc4f134d4e66a2da4f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Mar 30 23:57:57 2021 -0500

    Update UBL param

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 56de4e45ba..acc191908c 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -57,7 +57,7 @@ typedef struct {
   xy_pos_t  XY_pos;
   xy_bool_t XY_seen;
   #if HAS_BED_PROBE
-    int     grid_size;
+    uint8_t J_grid_size;
   #endif
 } G29_parameters_t;
 

commit c45b91aa94c7008e3fd8ea297df57948af9158a3
Author: Marcio T <mlt4356-github@yahoo.com>
Date:   Sat Mar 27 21:57:12 2021 -0600

    Refactor Hilbert curve. Enhance Touch UI Bed Level Screen. (#21453)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 67a9b0a60e..56de4e45ba 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -101,11 +101,6 @@ public:
   static void display_map(const int) _O0;
   static mesh_index_pair find_closest_mesh_point_of_type(const MeshPointType, const xy_pos_t&, const bool=false, MeshFlags *done_flags=nullptr) _O0;
   static mesh_index_pair find_furthest_invalid_mesh_point() _O0;
-  #if ENABLED(UBL_HILBERT_CURVE)
-    static void check_if_missing(mesh_index_pair &pt, int x, int y);
-    static void hilbert(mesh_index_pair &pt, int8_t x, int8_t y, int8_t xi, int8_t xj, int8_t yi, int8_t yj, uint8_t n);
-    static mesh_index_pair find_next_mesh_point();
-  #endif
   static void reset();
   static void invalidate();
   static void set_all_mesh_points_to_value(const float value);

commit da4b6896f7e4f102d8c2164e7aecf22cf2922fe2
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 24 03:28:48 2021 -0500

    Group UBL parameters, add comments

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 0c4667eed8..67a9b0a60e 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -45,23 +45,26 @@ struct mesh_index_pair;
   typedef int16_t mesh_store_t[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
 #endif
 
+typedef struct {
+  bool      C_seen;
+  int8_t    V_verbosity,
+            P_phase,
+            R_repetition,
+            KLS_storage_slot,
+            T_map_type;
+  float     B_shim_thickness,
+            C_constant;
+  xy_pos_t  XY_pos;
+  xy_bool_t XY_seen;
+  #if HAS_BED_PROBE
+    int     grid_size;
+  #endif
+} G29_parameters_t;
+
 class unified_bed_leveling {
 private:
 
-  static int    g29_verbose_level,
-                g29_phase_value,
-                g29_repetition_cnt,
-                g29_storage_slot,
-                g29_map_type;
-  static bool   g29_c_flag;
-  static float  g29_card_thickness,
-                g29_constant;
-  static xy_pos_t g29_pos;
-  static xy_bool_t xy_seen;
-
-  #if HAS_BED_PROBE
-    static int  g29_grid_size;
-  #endif
+  static G29_parameters_t param;
 
   #if IS_NEWPANEL
     static void move_z_with_encoder(const float &multiplier);
@@ -71,7 +74,7 @@ private:
     static void fine_tune_mesh(const xy_pos_t &pos, const bool do_ubl_mesh_map) _O0;
   #endif
 
-  static bool g29_parameter_parsing() _O0;
+  static bool G29_parse_parameters() _O0;
   static void shift_mesh_height();
   static void probe_entire_mesh(const xy_pos_t &near, const bool do_ubl_mesh_map, const bool stow_probe, const bool do_furthest) _O0;
   static void tilt_mesh_based_on_3pts(const float &z1, const float &z2, const float &z3);
@@ -129,7 +132,7 @@ public:
     static inline void steppers_were_disabled() {}
   #endif
 
-  static volatile int16_t encoder_diff; // Volatile because buttons may changed it at interrupt time
+  static volatile int16_t encoder_diff; // Volatile because buttons may change it at interrupt time
 
   unified_bed_leveling();
 

commit eee726ec7dfa774677e86d84573e04524eff64be
Author: Marcio T <mlt4356-github@yahoo.com>
Date:   Tue Mar 23 00:45:51 2021 -0600

    UBL - Hilbert space-filling curve probing sequence (#21387)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index d5da43a6a2..0c4667eed8 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -98,6 +98,11 @@ public:
   static void display_map(const int) _O0;
   static mesh_index_pair find_closest_mesh_point_of_type(const MeshPointType, const xy_pos_t&, const bool=false, MeshFlags *done_flags=nullptr) _O0;
   static mesh_index_pair find_furthest_invalid_mesh_point() _O0;
+  #if ENABLED(UBL_HILBERT_CURVE)
+    static void check_if_missing(mesh_index_pair &pt, int x, int y);
+    static void hilbert(mesh_index_pair &pt, int8_t x, int8_t y, int8_t xi, int8_t xj, int8_t yi, int8_t yj, uint8_t n);
+    static mesh_index_pair find_next_mesh_point();
+  #endif
   static void reset();
   static void invalidate();
   static void set_all_mesh_points_to_value(const float value);

commit bdb8c07bb22bed1ca78f4b7d14651a8e04828e82
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 23 16:09:54 2021 -0600

    Outdent UBL code

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 876063c878..d5da43a6a2 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -46,275 +46,275 @@ struct mesh_index_pair;
 #endif
 
 class unified_bed_leveling {
-  private:
-
-    static int    g29_verbose_level,
-                  g29_phase_value,
-                  g29_repetition_cnt,
-                  g29_storage_slot,
-                  g29_map_type;
-    static bool   g29_c_flag;
-    static float  g29_card_thickness,
-                  g29_constant;
-    static xy_pos_t g29_pos;
-    static xy_bool_t xy_seen;
-
-    #if HAS_BED_PROBE
-      static int  g29_grid_size;
-    #endif
-
-    #if IS_NEWPANEL
-      static void move_z_with_encoder(const float &multiplier);
-      static float measure_point_with_encoder();
-      static float measure_business_card_thickness();
-      static void manually_probe_remaining_mesh(const xy_pos_t&, const float&, const float&, const bool) _O0;
-      static void fine_tune_mesh(const xy_pos_t &pos, const bool do_ubl_mesh_map) _O0;
-    #endif
+private:
+
+  static int    g29_verbose_level,
+                g29_phase_value,
+                g29_repetition_cnt,
+                g29_storage_slot,
+                g29_map_type;
+  static bool   g29_c_flag;
+  static float  g29_card_thickness,
+                g29_constant;
+  static xy_pos_t g29_pos;
+  static xy_bool_t xy_seen;
+
+  #if HAS_BED_PROBE
+    static int  g29_grid_size;
+  #endif
+
+  #if IS_NEWPANEL
+    static void move_z_with_encoder(const float &multiplier);
+    static float measure_point_with_encoder();
+    static float measure_business_card_thickness();
+    static void manually_probe_remaining_mesh(const xy_pos_t&, const float&, const float&, const bool) _O0;
+    static void fine_tune_mesh(const xy_pos_t &pos, const bool do_ubl_mesh_map) _O0;
+  #endif
+
+  static bool g29_parameter_parsing() _O0;
+  static void shift_mesh_height();
+  static void probe_entire_mesh(const xy_pos_t &near, const bool do_ubl_mesh_map, const bool stow_probe, const bool do_furthest) _O0;
+  static void tilt_mesh_based_on_3pts(const float &z1, const float &z2, const float &z3);
+  static void tilt_mesh_based_on_probed_grid(const bool do_ubl_mesh_map);
+  static bool smart_fill_one(const uint8_t x, const uint8_t y, const int8_t xdir, const int8_t ydir);
+  static inline bool smart_fill_one(const xy_uint8_t &pos, const xy_uint8_t &dir) {
+    return smart_fill_one(pos.x, pos.y, dir.x, dir.y);
+  }
+  static void smart_fill_mesh();
+
+  #if ENABLED(UBL_DEVEL_DEBUGGING)
+    static void g29_what_command();
+    static void g29_eeprom_dump();
+    static void g29_compare_current_mesh_to_stored_mesh();
+  #endif
+
+public:
+
+  static void echo_name();
+  static void report_current_mesh();
+  static void report_state();
+  static void save_ubl_active_state_and_disable();
+  static void restore_ubl_active_state_and_leave();
+  static void display_map(const int) _O0;
+  static mesh_index_pair find_closest_mesh_point_of_type(const MeshPointType, const xy_pos_t&, const bool=false, MeshFlags *done_flags=nullptr) _O0;
+  static mesh_index_pair find_furthest_invalid_mesh_point() _O0;
+  static void reset();
+  static void invalidate();
+  static void set_all_mesh_points_to_value(const float value);
+  static void adjust_mesh_to_mean(const bool cflag, const float value);
+  static bool sanity_check();
+
+  static void G29() _O0;                          // O0 for no optimization
+  static void smart_fill_wlsf(const float &) _O2; // O2 gives smaller code than Os on A2560
+
+  static int8_t storage_slot;
+
+  static bed_mesh_t z_values;
+  #if ENABLED(OPTIMIZED_MESH_STORAGE)
+    static void set_store_from_mesh(const bed_mesh_t &in_values, mesh_store_t &stored_values);
+    static void set_mesh_from_store(const mesh_store_t &stored_values, bed_mesh_t &out_values);
+  #endif
+  static const float _mesh_index_to_xpos[GRID_MAX_POINTS_X],
+                     _mesh_index_to_ypos[GRID_MAX_POINTS_Y];
+
+  #if HAS_LCD_MENU
+    static bool lcd_map_control;
+    static void steppers_were_disabled();
+  #else
+    static inline void steppers_were_disabled() {}
+  #endif
+
+  static volatile int16_t encoder_diff; // Volatile because buttons may changed it at interrupt time
+
+  unified_bed_leveling();
+
+  FORCE_INLINE static void set_z(const int8_t px, const int8_t py, const float &z) { z_values[px][py] = z; }
+
+  static int8_t cell_index_x_raw(const float &x) {
+    return FLOOR((x - (MESH_MIN_X)) * RECIPROCAL(MESH_X_DIST));
+  }
+
+  static int8_t cell_index_y_raw(const float &y) {
+    return FLOOR((y - (MESH_MIN_Y)) * RECIPROCAL(MESH_Y_DIST));
+  }
+
+  static int8_t cell_index_x_valid(const float &x) {
+    return WITHIN(cell_index_x_raw(x), 0, (GRID_MAX_POINTS_X - 2));
+  }
+
+  static int8_t cell_index_y_valid(const float &y) {
+    return WITHIN(cell_index_y_raw(y), 0, (GRID_MAX_POINTS_Y - 2));
+  }
+
+  static int8_t cell_index_x(const float &x) {
+    return constrain(cell_index_x_raw(x), 0, (GRID_MAX_POINTS_X) - 2);
+  }
+
+  static int8_t cell_index_y(const float &y) {
+    return constrain(cell_index_y_raw(y), 0, (GRID_MAX_POINTS_Y) - 2);
+  }
+
+  static inline xy_int8_t cell_indexes(const float &x, const float &y) {
+    return { cell_index_x(x), cell_index_y(y) };
+  }
+  static inline xy_int8_t cell_indexes(const xy_pos_t &xy) { return cell_indexes(xy.x, xy.y); }
+
+  static int8_t closest_x_index(const float &x) {
+    const int8_t px = (x - (MESH_MIN_X) + (MESH_X_DIST) * 0.5) * RECIPROCAL(MESH_X_DIST);
+    return WITHIN(px, 0, GRID_MAX_POINTS_X - 1) ? px : -1;
+  }
+  static int8_t closest_y_index(const float &y) {
+    const int8_t py = (y - (MESH_MIN_Y) + (MESH_Y_DIST) * 0.5) * RECIPROCAL(MESH_Y_DIST);
+    return WITHIN(py, 0, GRID_MAX_POINTS_Y - 1) ? py : -1;
+  }
+  static inline xy_int8_t closest_indexes(const xy_pos_t &xy) {
+    return { closest_x_index(xy.x), closest_y_index(xy.y) };
+  }
+
+  /**
+   *                           z2   --|
+   *                 z0        |      |
+   *                  |        |      + (z2-z1)
+   *   z1             |        |      |
+   * ---+-------------+--------+--  --|
+   *   a1            a0        a2
+   *    |<---delta_a---------->|
+   *
+   *  calc_z0 is the basis for all the Mesh Based correction. It is used to
+   *  find the expected Z Height at a position between two known Z-Height locations.
+   *
+   *  It is fairly expensive with its 4 floating point additions and 2 floating point
+   *  multiplications.
+   */
+  FORCE_INLINE static float calc_z0(const float &a0, const float &a1, const float &z1, const float &a2, const float &z2) {
+    return z1 + (z2 - z1) * (a0 - a1) / (a2 - a1);
+  }
+
+  #ifdef UBL_Z_RAISE_WHEN_OFF_MESH
+    #define _UBL_OUTER_Z_RAISE UBL_Z_RAISE_WHEN_OFF_MESH
+  #else
+    #define _UBL_OUTER_Z_RAISE NAN
+  #endif
+
+  /**
+   * z_correction_for_x_on_horizontal_mesh_line is an optimization for
+   * the case where the printer is making a vertical line that only crosses horizontal mesh lines.
+   */
+  static inline float z_correction_for_x_on_horizontal_mesh_line(const float &rx0, const int x1_i, const int yi) {
+    if (!WITHIN(x1_i, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(yi, 0, GRID_MAX_POINTS_Y - 1)) {
+
+      if (DEBUGGING(LEVELING)) {
+        if (WITHIN(x1_i, 0, GRID_MAX_POINTS_X - 1)) DEBUG_ECHOPGM("yi"); else DEBUG_ECHOPGM("x1_i");
+        DEBUG_ECHOLNPAIR(" out of bounds in z_correction_for_x_on_horizontal_mesh_line(rx0=", rx0, ",x1_i=", x1_i, ",yi=", yi, ")");
+      }
 
-    static bool g29_parameter_parsing() _O0;
-    static void shift_mesh_height();
-    static void probe_entire_mesh(const xy_pos_t &near, const bool do_ubl_mesh_map, const bool stow_probe, const bool do_furthest) _O0;
-    static void tilt_mesh_based_on_3pts(const float &z1, const float &z2, const float &z3);
-    static void tilt_mesh_based_on_probed_grid(const bool do_ubl_mesh_map);
-    static bool smart_fill_one(const uint8_t x, const uint8_t y, const int8_t xdir, const int8_t ydir);
-    static inline bool smart_fill_one(const xy_uint8_t &pos, const xy_uint8_t &dir) {
-      return smart_fill_one(pos.x, pos.y, dir.x, dir.y);
+      // The requested location is off the mesh. Return UBL_Z_RAISE_WHEN_OFF_MESH or NAN.
+      return _UBL_OUTER_Z_RAISE;
     }
-    static void smart_fill_mesh();
-
-    #if ENABLED(UBL_DEVEL_DEBUGGING)
-      static void g29_what_command();
-      static void g29_eeprom_dump();
-      static void g29_compare_current_mesh_to_stored_mesh();
-    #endif
 
-  public:
-
-    static void echo_name();
-    static void report_current_mesh();
-    static void report_state();
-    static void save_ubl_active_state_and_disable();
-    static void restore_ubl_active_state_and_leave();
-    static void display_map(const int) _O0;
-    static mesh_index_pair find_closest_mesh_point_of_type(const MeshPointType, const xy_pos_t&, const bool=false, MeshFlags *done_flags=nullptr) _O0;
-    static mesh_index_pair find_furthest_invalid_mesh_point() _O0;
-    static void reset();
-    static void invalidate();
-    static void set_all_mesh_points_to_value(const float value);
-    static void adjust_mesh_to_mean(const bool cflag, const float value);
-    static bool sanity_check();
-
-    static void G29() _O0;                          // O0 for no optimization
-    static void smart_fill_wlsf(const float &) _O2; // O2 gives smaller code than Os on A2560
-
-    static int8_t storage_slot;
-
-    static bed_mesh_t z_values;
-    #if ENABLED(OPTIMIZED_MESH_STORAGE)
-      static void set_store_from_mesh(const bed_mesh_t &in_values, mesh_store_t &stored_values);
-      static void set_mesh_from_store(const mesh_store_t &stored_values, bed_mesh_t &out_values);
-    #endif
-    static const float _mesh_index_to_xpos[GRID_MAX_POINTS_X],
-                       _mesh_index_to_ypos[GRID_MAX_POINTS_Y];
-
-    #if HAS_LCD_MENU
-      static bool lcd_map_control;
-      static void steppers_were_disabled();
-    #else
-      static inline void steppers_were_disabled() {}
-    #endif
-
-    static volatile int16_t encoder_diff; // Volatile because buttons may changed it at interrupt time
+    const float xratio = (rx0 - mesh_index_to_xpos(x1_i)) * RECIPROCAL(MESH_X_DIST),
+                z1 = z_values[x1_i][yi];
 
-    unified_bed_leveling();
+    return z1 + xratio * (z_values[_MIN(x1_i, GRID_MAX_POINTS_X - 2) + 1][yi] - z1); // Don't allow x1_i+1 to be past the end of the array
+                                                                                    // If it is, it is clamped to the last element of the
+                                                                                    // z_values[][] array and no correction is applied.
+  }
 
-    FORCE_INLINE static void set_z(const int8_t px, const int8_t py, const float &z) { z_values[px][py] = z; }
+  //
+  // See comments above for z_correction_for_x_on_horizontal_mesh_line
+  //
+  static inline float z_correction_for_y_on_vertical_mesh_line(const float &ry0, const int xi, const int y1_i) {
+    if (!WITHIN(xi, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(y1_i, 0, GRID_MAX_POINTS_Y - 1)) {
 
-    static int8_t cell_index_x_raw(const float &x) {
-      return FLOOR((x - (MESH_MIN_X)) * RECIPROCAL(MESH_X_DIST));
-    }
-
-    static int8_t cell_index_y_raw(const float &y) {
-      return FLOOR((y - (MESH_MIN_Y)) * RECIPROCAL(MESH_Y_DIST));
-    }
-
-    static int8_t cell_index_x_valid(const float &x) {
-      return WITHIN(cell_index_x_raw(x), 0, (GRID_MAX_POINTS_X - 2));
-    }
+      if (DEBUGGING(LEVELING)) {
+        if (WITHIN(xi, 0, GRID_MAX_POINTS_X - 1)) DEBUG_ECHOPGM("y1_i"); else DEBUG_ECHOPGM("xi");
+        DEBUG_ECHOLNPAIR(" out of bounds in z_correction_for_y_on_vertical_mesh_line(ry0=", ry0, ", xi=", xi, ", y1_i=", y1_i, ")");
+      }
 
-    static int8_t cell_index_y_valid(const float &y) {
-      return WITHIN(cell_index_y_raw(y), 0, (GRID_MAX_POINTS_Y - 2));
+      // The requested location is off the mesh. Return UBL_Z_RAISE_WHEN_OFF_MESH or NAN.
+      return _UBL_OUTER_Z_RAISE;
     }
 
-    static int8_t cell_index_x(const float &x) {
-      return constrain(cell_index_x_raw(x), 0, (GRID_MAX_POINTS_X) - 2);
-    }
+    const float yratio = (ry0 - mesh_index_to_ypos(y1_i)) * RECIPROCAL(MESH_Y_DIST),
+                z1 = z_values[xi][y1_i];
 
-    static int8_t cell_index_y(const float &y) {
-      return constrain(cell_index_y_raw(y), 0, (GRID_MAX_POINTS_Y) - 2);
-    }
+    return z1 + yratio * (z_values[xi][_MIN(y1_i, GRID_MAX_POINTS_Y - 2) + 1] - z1); // Don't allow y1_i+1 to be past the end of the array
+                                                                                    // If it is, it is clamped to the last element of the
+                                                                                    // z_values[][] array and no correction is applied.
+  }
 
-    static inline xy_int8_t cell_indexes(const float &x, const float &y) {
-      return { cell_index_x(x), cell_index_y(y) };
-    }
-    static inline xy_int8_t cell_indexes(const xy_pos_t &xy) { return cell_indexes(xy.x, xy.y); }
-
-    static int8_t closest_x_index(const float &x) {
-      const int8_t px = (x - (MESH_MIN_X) + (MESH_X_DIST) * 0.5) * RECIPROCAL(MESH_X_DIST);
-      return WITHIN(px, 0, GRID_MAX_POINTS_X - 1) ? px : -1;
-    }
-    static int8_t closest_y_index(const float &y) {
-      const int8_t py = (y - (MESH_MIN_Y) + (MESH_Y_DIST) * 0.5) * RECIPROCAL(MESH_Y_DIST);
-      return WITHIN(py, 0, GRID_MAX_POINTS_Y - 1) ? py : -1;
-    }
-    static inline xy_int8_t closest_indexes(const xy_pos_t &xy) {
-      return { closest_x_index(xy.x), closest_y_index(xy.y) };
-    }
+  /**
+   * This is the generic Z-Correction. It works anywhere within a Mesh Cell. It first
+   * does a linear interpolation along both of the bounding X-Mesh-Lines to find the
+   * Z-Height at both ends. Then it does a linear interpolation of these heights based
+   * on the Y position within the cell.
+   */
+  static float get_z_correction(const float &rx0, const float &ry0) {
+    const int8_t cx = cell_index_x(rx0), cy = cell_index_y(ry0); // return values are clamped
 
     /**
-     *                           z2   --|
-     *                 z0        |      |
-     *                  |        |      + (z2-z1)
-     *   z1             |        |      |
-     * ---+-------------+--------+--  --|
-     *   a1            a0        a2
-     *    |<---delta_a---------->|
-     *
-     *  calc_z0 is the basis for all the Mesh Based correction. It is used to
-     *  find the expected Z Height at a position between two known Z-Height locations.
-     *
-     *  It is fairly expensive with its 4 floating point additions and 2 floating point
-     *  multiplications.
+     * Check if the requested location is off the mesh.  If so, and
+     * UBL_Z_RAISE_WHEN_OFF_MESH is specified, that value is returned.
      */
-    FORCE_INLINE static float calc_z0(const float &a0, const float &a1, const float &z1, const float &a2, const float &z2) {
-      return z1 + (z2 - z1) * (a0 - a1) / (a2 - a1);
-    }
-
     #ifdef UBL_Z_RAISE_WHEN_OFF_MESH
-      #define _UBL_OUTER_Z_RAISE UBL_Z_RAISE_WHEN_OFF_MESH
-    #else
-      #define _UBL_OUTER_Z_RAISE NAN
+      if (!WITHIN(rx0, MESH_MIN_X, MESH_MAX_X) || !WITHIN(ry0, MESH_MIN_Y, MESH_MAX_Y))
+        return UBL_Z_RAISE_WHEN_OFF_MESH;
     #endif
 
-    /**
-     * z_correction_for_x_on_horizontal_mesh_line is an optimization for
-     * the case where the printer is making a vertical line that only crosses horizontal mesh lines.
-     */
-    static inline float z_correction_for_x_on_horizontal_mesh_line(const float &rx0, const int x1_i, const int yi) {
-      if (!WITHIN(x1_i, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(yi, 0, GRID_MAX_POINTS_Y - 1)) {
-
-        if (DEBUGGING(LEVELING)) {
-          if (WITHIN(x1_i, 0, GRID_MAX_POINTS_X - 1)) DEBUG_ECHOPGM("yi"); else DEBUG_ECHOPGM("x1_i");
-          DEBUG_ECHOLNPAIR(" out of bounds in z_correction_for_x_on_horizontal_mesh_line(rx0=", rx0, ",x1_i=", x1_i, ",yi=", yi, ")");
-        }
+    const float z1 = calc_z0(rx0,
+                             mesh_index_to_xpos(cx), z_values[cx][cy],
+                             mesh_index_to_xpos(cx + 1), z_values[_MIN(cx, GRID_MAX_POINTS_X - 2) + 1][cy]);
 
-        // The requested location is off the mesh. Return UBL_Z_RAISE_WHEN_OFF_MESH or NAN.
-        return _UBL_OUTER_Z_RAISE;
-      }
+    const float z2 = calc_z0(rx0,
+                             mesh_index_to_xpos(cx), z_values[cx][_MIN(cy, GRID_MAX_POINTS_Y - 2) + 1],
+                             mesh_index_to_xpos(cx + 1), z_values[_MIN(cx, GRID_MAX_POINTS_X - 2) + 1][_MIN(cy, GRID_MAX_POINTS_Y - 2) + 1]);
 
-      const float xratio = (rx0 - mesh_index_to_xpos(x1_i)) * RECIPROCAL(MESH_X_DIST),
-                  z1 = z_values[x1_i][yi];
+    float z0 = calc_z0(ry0,
+                       mesh_index_to_ypos(cy), z1,
+                       mesh_index_to_ypos(cy + 1), z2);
 
-      return z1 + xratio * (z_values[_MIN(x1_i, GRID_MAX_POINTS_X - 2) + 1][yi] - z1); // Don't allow x1_i+1 to be past the end of the array
-                                                                                      // If it is, it is clamped to the last element of the
-                                                                                      // z_values[][] array and no correction is applied.
+    if (DEBUGGING(MESH_ADJUST)) {
+      DEBUG_ECHOPAIR(" raw get_z_correction(", rx0);
+      DEBUG_CHAR(','); DEBUG_ECHO(ry0);
+      DEBUG_ECHOPAIR_F(") = ", z0, 6);
+      DEBUG_ECHOLNPAIR_F(" >>>---> ", z0, 6);
     }
 
-    //
-    // See comments above for z_correction_for_x_on_horizontal_mesh_line
-    //
-    static inline float z_correction_for_y_on_vertical_mesh_line(const float &ry0, const int xi, const int y1_i) {
-      if (!WITHIN(xi, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(y1_i, 0, GRID_MAX_POINTS_Y - 1)) {
-
-        if (DEBUGGING(LEVELING)) {
-          if (WITHIN(xi, 0, GRID_MAX_POINTS_X - 1)) DEBUG_ECHOPGM("y1_i"); else DEBUG_ECHOPGM("xi");
-          DEBUG_ECHOLNPAIR(" out of bounds in z_correction_for_y_on_vertical_mesh_line(ry0=", ry0, ", xi=", xi, ", y1_i=", y1_i, ")");
-        }
-
-        // The requested location is off the mesh. Return UBL_Z_RAISE_WHEN_OFF_MESH or NAN.
-        return _UBL_OUTER_Z_RAISE;
-      }
-
-      const float yratio = (ry0 - mesh_index_to_ypos(y1_i)) * RECIPROCAL(MESH_Y_DIST),
-                  z1 = z_values[xi][y1_i];
-
-      return z1 + yratio * (z_values[xi][_MIN(y1_i, GRID_MAX_POINTS_Y - 2) + 1] - z1); // Don't allow y1_i+1 to be past the end of the array
-                                                                                      // If it is, it is clamped to the last element of the
-                                                                                      // z_values[][] array and no correction is applied.
-    }
-
-    /**
-     * This is the generic Z-Correction. It works anywhere within a Mesh Cell. It first
-     * does a linear interpolation along both of the bounding X-Mesh-Lines to find the
-     * Z-Height at both ends. Then it does a linear interpolation of these heights based
-     * on the Y position within the cell.
-     */
-    static float get_z_correction(const float &rx0, const float &ry0) {
-      const int8_t cx = cell_index_x(rx0), cy = cell_index_y(ry0); // return values are clamped
-
-      /**
-       * Check if the requested location is off the mesh.  If so, and
-       * UBL_Z_RAISE_WHEN_OFF_MESH is specified, that value is returned.
-       */
-      #ifdef UBL_Z_RAISE_WHEN_OFF_MESH
-        if (!WITHIN(rx0, MESH_MIN_X, MESH_MAX_X) || !WITHIN(ry0, MESH_MIN_Y, MESH_MAX_Y))
-          return UBL_Z_RAISE_WHEN_OFF_MESH;
-      #endif
-
-      const float z1 = calc_z0(rx0,
-                               mesh_index_to_xpos(cx), z_values[cx][cy],
-                               mesh_index_to_xpos(cx + 1), z_values[_MIN(cx, GRID_MAX_POINTS_X - 2) + 1][cy]);
-
-      const float z2 = calc_z0(rx0,
-                               mesh_index_to_xpos(cx), z_values[cx][_MIN(cy, GRID_MAX_POINTS_Y - 2) + 1],
-                               mesh_index_to_xpos(cx + 1), z_values[_MIN(cx, GRID_MAX_POINTS_X - 2) + 1][_MIN(cy, GRID_MAX_POINTS_Y - 2) + 1]);
-
-      float z0 = calc_z0(ry0,
-                         mesh_index_to_ypos(cy), z1,
-                         mesh_index_to_ypos(cy + 1), z2);
+    if (isnan(z0)) { // if part of the Mesh is undefined, it will show up as NAN
+      z0 = 0.0;      // in ubl.z_values[][] and propagate through the
+                     // calculations. If our correction is NAN, we throw it out
+                     // because part of the Mesh is undefined and we don't have the
+                     // information we need to complete the height correction.
 
       if (DEBUGGING(MESH_ADJUST)) {
-        DEBUG_ECHOPAIR(" raw get_z_correction(", rx0);
-        DEBUG_CHAR(','); DEBUG_ECHO(ry0);
-        DEBUG_ECHOPAIR_F(") = ", z0, 6);
-        DEBUG_ECHOLNPAIR_F(" >>>---> ", z0, 6);
-      }
-
-      if (isnan(z0)) { // if part of the Mesh is undefined, it will show up as NAN
-        z0 = 0.0;      // in ubl.z_values[][] and propagate through the
-                       // calculations. If our correction is NAN, we throw it out
-                       // because part of the Mesh is undefined and we don't have the
-                       // information we need to complete the height correction.
-
-        if (DEBUGGING(MESH_ADJUST)) {
-          DEBUG_ECHOPAIR("??? Yikes!  NAN in get_z_correction(", rx0);
-          DEBUG_CHAR(',');
-          DEBUG_ECHO(ry0);
-          DEBUG_CHAR(')');
-          DEBUG_EOL();
-        }
+        DEBUG_ECHOPAIR("??? Yikes!  NAN in get_z_correction(", rx0);
+        DEBUG_CHAR(',');
+        DEBUG_ECHO(ry0);
+        DEBUG_CHAR(')');
+        DEBUG_EOL();
       }
-      return z0;
-    }
-    static inline float get_z_correction(const xy_pos_t &pos) { return get_z_correction(pos.x, pos.y); }
-
-    static inline float mesh_index_to_xpos(const uint8_t i) {
-      return i < GRID_MAX_POINTS_X ? pgm_read_float(&_mesh_index_to_xpos[i]) : MESH_MIN_X + i * (MESH_X_DIST);
-    }
-    static inline float mesh_index_to_ypos(const uint8_t i) {
-      return i < GRID_MAX_POINTS_Y ? pgm_read_float(&_mesh_index_to_ypos[i]) : MESH_MIN_Y + i * (MESH_Y_DIST);
-    }
-
-    #if UBL_SEGMENTED
-      static bool line_to_destination_segmented(const feedRate_t &scaled_fr_mm_s);
-    #else
-      static void line_to_destination_cartesian(const feedRate_t &scaled_fr_mm_s, const uint8_t e);
-    #endif
-
-    static inline bool mesh_is_valid() {
-      GRID_LOOP(x, y) if (isnan(z_values[x][y])) return false;
-      return true;
     }
+    return z0;
+  }
+  static inline float get_z_correction(const xy_pos_t &pos) { return get_z_correction(pos.x, pos.y); }
+
+  static inline float mesh_index_to_xpos(const uint8_t i) {
+    return i < GRID_MAX_POINTS_X ? pgm_read_float(&_mesh_index_to_xpos[i]) : MESH_MIN_X + i * (MESH_X_DIST);
+  }
+  static inline float mesh_index_to_ypos(const uint8_t i) {
+    return i < GRID_MAX_POINTS_Y ? pgm_read_float(&_mesh_index_to_ypos[i]) : MESH_MIN_Y + i * (MESH_Y_DIST);
+  }
+
+  #if UBL_SEGMENTED
+    static bool line_to_destination_segmented(const feedRate_t &scaled_fr_mm_s);
+  #else
+    static void line_to_destination_cartesian(const feedRate_t &scaled_fr_mm_s, const uint8_t e);
+  #endif
+
+  static inline bool mesh_is_valid() {
+    GRID_LOOP(x, y) if (isnan(z_values[x][y])) return false;
+    return true;
+  }
 
 }; // class unified_bed_leveling
 

commit 844a8c7074d555bda31a53ae834cee5fac020ca8
Author: ubik2 <ubik2@users.noreply.github.com>
Date:   Wed Dec 23 16:19:48 2020 -0800

    Add OPTIMIZED_MESH_STORAGE option (for UBL) (#20371)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 762becfb69..876063c878 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -41,6 +41,10 @@ struct mesh_index_pair;
 #define MESH_X_DIST (float(MESH_MAX_X - (MESH_MIN_X)) / float(GRID_MAX_POINTS_X - 1))
 #define MESH_Y_DIST (float(MESH_MAX_Y - (MESH_MIN_Y)) / float(GRID_MAX_POINTS_Y - 1))
 
+#if ENABLED(OPTIMIZED_MESH_STORAGE)
+  typedef int16_t mesh_store_t[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
+#endif
+
 class unified_bed_leveling {
   private:
 
@@ -106,6 +110,10 @@ class unified_bed_leveling {
     static int8_t storage_slot;
 
     static bed_mesh_t z_values;
+    #if ENABLED(OPTIMIZED_MESH_STORAGE)
+      static void set_store_from_mesh(const bed_mesh_t &in_values, mesh_store_t &stored_values);
+      static void set_mesh_from_store(const mesh_store_t &stored_values, bed_mesh_t &out_values);
+    #endif
     static const float _mesh_index_to_xpos[GRID_MAX_POINTS_X],
                        _mesh_index_to_ypos[GRID_MAX_POINTS_Y];
 
@@ -182,6 +190,12 @@ class unified_bed_leveling {
       return z1 + (z2 - z1) * (a0 - a1) / (a2 - a1);
     }
 
+    #ifdef UBL_Z_RAISE_WHEN_OFF_MESH
+      #define _UBL_OUTER_Z_RAISE UBL_Z_RAISE_WHEN_OFF_MESH
+    #else
+      #define _UBL_OUTER_Z_RAISE NAN
+    #endif
+
     /**
      * z_correction_for_x_on_horizontal_mesh_line is an optimization for
      * the case where the printer is making a vertical line that only crosses horizontal mesh lines.
@@ -195,13 +209,7 @@ class unified_bed_leveling {
         }
 
         // The requested location is off the mesh. Return UBL_Z_RAISE_WHEN_OFF_MESH or NAN.
-        return (
-          #ifdef UBL_Z_RAISE_WHEN_OFF_MESH
-            UBL_Z_RAISE_WHEN_OFF_MESH
-          #else
-            NAN
-          #endif
-        );
+        return _UBL_OUTER_Z_RAISE;
       }
 
       const float xratio = (rx0 - mesh_index_to_xpos(x1_i)) * RECIPROCAL(MESH_X_DIST),
@@ -224,13 +232,7 @@ class unified_bed_leveling {
         }
 
         // The requested location is off the mesh. Return UBL_Z_RAISE_WHEN_OFF_MESH or NAN.
-        return (
-          #ifdef UBL_Z_RAISE_WHEN_OFF_MESH
-            UBL_Z_RAISE_WHEN_OFF_MESH
-          #else
-            NAN
-          #endif
-        );
+        return _UBL_OUTER_Z_RAISE;
       }
 
       const float yratio = (ry0 - mesh_index_to_ypos(y1_i)) * RECIPROCAL(MESH_Y_DIST),

commit c1b900aae9d2b57c397d7687cb7ff1ed7edf9518
Author: Chris Pepper <p3p@p3psoft.co.uk>
Date:   Tue Dec 22 11:59:25 2020 +0000

    Fix UBL mesh inset Z position (#20538)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index c90b1f7ac1..762becfb69 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -122,20 +122,29 @@ class unified_bed_leveling {
 
     FORCE_INLINE static void set_z(const int8_t px, const int8_t py, const float &z) { z_values[px][py] = z; }
 
+    static int8_t cell_index_x_raw(const float &x) {
+      return FLOOR((x - (MESH_MIN_X)) * RECIPROCAL(MESH_X_DIST));
+    }
+
+    static int8_t cell_index_y_raw(const float &y) {
+      return FLOOR((y - (MESH_MIN_Y)) * RECIPROCAL(MESH_Y_DIST));
+    }
+
+    static int8_t cell_index_x_valid(const float &x) {
+      return WITHIN(cell_index_x_raw(x), 0, (GRID_MAX_POINTS_X - 2));
+    }
+
+    static int8_t cell_index_y_valid(const float &y) {
+      return WITHIN(cell_index_y_raw(y), 0, (GRID_MAX_POINTS_Y - 2));
+    }
+
     static int8_t cell_index_x(const float &x) {
-      const int8_t cx = (x - (MESH_MIN_X)) * RECIPROCAL(MESH_X_DIST);
-      return constrain(cx, 0, (GRID_MAX_POINTS_X) - 1);   // -1 is appropriate if we want all movement to the X_MAX
-    }                                                     // position. But with this defined this way, it is possible
-                                                          // to extrapolate off of this point even further out. Probably
-                                                          // that is OK because something else should be keeping that from
-                                                          // happening and should not be worried about at this level.
+      return constrain(cell_index_x_raw(x), 0, (GRID_MAX_POINTS_X) - 2);
+    }
+
     static int8_t cell_index_y(const float &y) {
-      const int8_t cy = (y - (MESH_MIN_Y)) * RECIPROCAL(MESH_Y_DIST);
-      return constrain(cy, 0, (GRID_MAX_POINTS_Y) - 1);   // -1 is appropriate if we want all movement to the Y_MAX
-    }                                                     // position. But with this defined this way, it is possible
-                                                          // to extrapolate off of this point even further out. Probably
-                                                          // that is OK because something else should be keeping that from
-                                                          // happening and should not be worried about at this level.
+      return constrain(cell_index_y_raw(y), 0, (GRID_MAX_POINTS_Y) - 2);
+    }
 
     static inline xy_int8_t cell_indexes(const float &x, const float &y) {
       return { cell_index_x(x), cell_index_y(y) };

commit 39305aa47c74822badee716996369b12976ba668
Author: Jason Smith <jason.inet@gmail.com>
Date:   Tue Nov 17 21:59:48 2020 -0800

    Use MANUAL_PROBE_START_Z for UBL manual probing (#20160)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 22ca1f69ec..c90b1f7ac1 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -62,7 +62,7 @@ class unified_bed_leveling {
     #if IS_NEWPANEL
       static void move_z_with_encoder(const float &multiplier);
       static float measure_point_with_encoder();
-      static float measure_business_card_thickness(float in_height);
+      static float measure_business_card_thickness();
       static void manually_probe_remaining_mesh(const xy_pos_t&, const float&, const float&, const bool) _O0;
       static void fine_tune_mesh(const xy_pos_t &pos, const bool do_ubl_mesh_map) _O0;
     #endif

commit f6ffbe548c81abfeecc996c8f2bffd27cabe0014
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Oct 15 03:00:27 2020 -0500

    TFT Presets, Generic options, Sanity checks (#19723)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 9ac9de1806..22ca1f69ec 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -59,7 +59,7 @@ class unified_bed_leveling {
       static int  g29_grid_size;
     #endif
 
-    #if ENABLED(NEWPANEL)
+    #if IS_NEWPANEL
       static void move_z_with_encoder(const float &multiplier);
       static float measure_point_with_encoder();
       static float measure_business_card_thickness(float in_height);

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 3455416a62..9ac9de1806 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -16,7 +16,7 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 #pragma once

commit f6a2b6409192c4e349321f42a5c0ebfd4e278b82
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jul 3 09:53:22 2020 -0500

    Clean up LCD Manual Move / UBL Mesh Edit (#18373)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 9e227f02d9..3455416a62 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -111,9 +111,12 @@ class unified_bed_leveling {
 
     #if HAS_LCD_MENU
       static bool lcd_map_control;
+      static void steppers_were_disabled();
+    #else
+      static inline void steppers_were_disabled() {}
     #endif
 
-    static volatile int encoder_diff; // Volatile because it's changed at interrupt time.
+    static volatile int16_t encoder_diff; // Volatile because buttons may changed it at interrupt time
 
     unified_bed_leveling();
 

commit 118bd2f8b2a1f81884cb55a8fc00b708a51aa15b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 13 23:18:16 2020 -0500

    Apply loop shorthand macros (#17159)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 370d792fc5..9e227f02d9 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -298,9 +298,7 @@ class unified_bed_leveling {
     #endif
 
     static inline bool mesh_is_valid() {
-      for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
-        for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
-          if (isnan(z_values[x][y])) return false;
+      GRID_LOOP(x, y) if (isnan(z_values[x][y])) return false;
       return true;
     }
 

commit bfad23d3e2e590b257ebe4317d7b14cc2dd3435c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 3 08:00:57 2020 -0600

    (c) 2020

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 2202bb6524..370d792fc5 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -1,6 +1,6 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm

commit 50e4545255605eb506c20eb107270038b0fe7bdb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 29 04:25:39 2019 -0500

    Add custom types for position (#15204)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 6897217c38..2202bb6524 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -32,15 +32,12 @@
 #define UBL_OK false
 #define UBL_ERR true
 
-#define USE_NOZZLE_AS_REFERENCE 0
-#define USE_PROBE_AS_REFERENCE 1
-
-// ubl_G29.cpp
-
 enum MeshPointType : char { INVALID, REAL, SET_IN_BITMAP };
 
 // External references
 
+struct mesh_index_pair;
+
 #define MESH_X_DIST (float(MESH_MAX_X - (MESH_MIN_X)) / float(GRID_MAX_POINTS_X - 1))
 #define MESH_Y_DIST (float(MESH_MAX_Y - (MESH_MIN_Y)) / float(GRID_MAX_POINTS_Y - 1))
 
@@ -52,10 +49,11 @@ class unified_bed_leveling {
                   g29_repetition_cnt,
                   g29_storage_slot,
                   g29_map_type;
-    static bool   g29_c_flag, g29_x_flag, g29_y_flag;
-    static float  g29_x_pos, g29_y_pos,
-                  g29_card_thickness,
+    static bool   g29_c_flag;
+    static float  g29_card_thickness,
                   g29_constant;
+    static xy_pos_t g29_pos;
+    static xy_bool_t xy_seen;
 
     #if HAS_BED_PROBE
       static int  g29_grid_size;
@@ -65,16 +63,19 @@ class unified_bed_leveling {
       static void move_z_with_encoder(const float &multiplier);
       static float measure_point_with_encoder();
       static float measure_business_card_thickness(float in_height);
-      static void manually_probe_remaining_mesh(const float&, const float&, const float&, const float&, const bool) _O0;
-      static void fine_tune_mesh(const float &rx, const float &ry, const bool do_ubl_mesh_map) _O0;
+      static void manually_probe_remaining_mesh(const xy_pos_t&, const float&, const float&, const bool) _O0;
+      static void fine_tune_mesh(const xy_pos_t &pos, const bool do_ubl_mesh_map) _O0;
     #endif
 
     static bool g29_parameter_parsing() _O0;
     static void shift_mesh_height();
-    static void probe_entire_mesh(const float &rx, const float &ry, const bool do_ubl_mesh_map, const bool stow_probe, const bool do_furthest) _O0;
+    static void probe_entire_mesh(const xy_pos_t &near, const bool do_ubl_mesh_map, const bool stow_probe, const bool do_furthest) _O0;
     static void tilt_mesh_based_on_3pts(const float &z1, const float &z2, const float &z3);
     static void tilt_mesh_based_on_probed_grid(const bool do_ubl_mesh_map);
     static bool smart_fill_one(const uint8_t x, const uint8_t y, const int8_t xdir, const int8_t ydir);
+    static inline bool smart_fill_one(const xy_uint8_t &pos, const xy_uint8_t &dir) {
+      return smart_fill_one(pos.x, pos.y, dir.x, dir.y);
+    }
     static void smart_fill_mesh();
 
     #if ENABLED(UBL_DEVEL_DEBUGGING)
@@ -91,7 +92,7 @@ class unified_bed_leveling {
     static void save_ubl_active_state_and_disable();
     static void restore_ubl_active_state_and_leave();
     static void display_map(const int) _O0;
-    static mesh_index_pair find_closest_mesh_point_of_type(const MeshPointType, const float&, const float&, const bool, uint16_t[16]) _O0;
+    static mesh_index_pair find_closest_mesh_point_of_type(const MeshPointType, const xy_pos_t&, const bool=false, MeshFlags *done_flags=nullptr) _O0;
     static mesh_index_pair find_furthest_invalid_mesh_point() _O0;
     static void reset();
     static void invalidate();
@@ -118,14 +119,14 @@ class unified_bed_leveling {
 
     FORCE_INLINE static void set_z(const int8_t px, const int8_t py, const float &z) { z_values[px][py] = z; }
 
-    static int8_t get_cell_index_x(const float &x) {
+    static int8_t cell_index_x(const float &x) {
       const int8_t cx = (x - (MESH_MIN_X)) * RECIPROCAL(MESH_X_DIST);
       return constrain(cx, 0, (GRID_MAX_POINTS_X) - 1);   // -1 is appropriate if we want all movement to the X_MAX
     }                                                     // position. But with this defined this way, it is possible
                                                           // to extrapolate off of this point even further out. Probably
                                                           // that is OK because something else should be keeping that from
                                                           // happening and should not be worried about at this level.
-    static int8_t get_cell_index_y(const float &y) {
+    static int8_t cell_index_y(const float &y) {
       const int8_t cy = (y - (MESH_MIN_Y)) * RECIPROCAL(MESH_Y_DIST);
       return constrain(cy, 0, (GRID_MAX_POINTS_Y) - 1);   // -1 is appropriate if we want all movement to the Y_MAX
     }                                                     // position. But with this defined this way, it is possible
@@ -133,15 +134,22 @@ class unified_bed_leveling {
                                                           // that is OK because something else should be keeping that from
                                                           // happening and should not be worried about at this level.
 
-    static int8_t find_closest_x_index(const float &x) {
+    static inline xy_int8_t cell_indexes(const float &x, const float &y) {
+      return { cell_index_x(x), cell_index_y(y) };
+    }
+    static inline xy_int8_t cell_indexes(const xy_pos_t &xy) { return cell_indexes(xy.x, xy.y); }
+
+    static int8_t closest_x_index(const float &x) {
       const int8_t px = (x - (MESH_MIN_X) + (MESH_X_DIST) * 0.5) * RECIPROCAL(MESH_X_DIST);
       return WITHIN(px, 0, GRID_MAX_POINTS_X - 1) ? px : -1;
     }
-
-    static int8_t find_closest_y_index(const float &y) {
+    static int8_t closest_y_index(const float &y) {
       const int8_t py = (y - (MESH_MIN_Y) + (MESH_Y_DIST) * 0.5) * RECIPROCAL(MESH_Y_DIST);
       return WITHIN(py, 0, GRID_MAX_POINTS_Y - 1) ? py : -1;
     }
+    static inline xy_int8_t closest_indexes(const xy_pos_t &xy) {
+      return { closest_x_index(xy.x), closest_y_index(xy.y) };
+    }
 
     /**
      *                           z2   --|
@@ -228,8 +236,7 @@ class unified_bed_leveling {
      * on the Y position within the cell.
      */
     static float get_z_correction(const float &rx0, const float &ry0) {
-      const int8_t cx = get_cell_index_x(rx0),
-                   cy = get_cell_index_y(ry0); // return values are clamped
+      const int8_t cx = cell_index_x(rx0), cy = cell_index_y(ry0); // return values are clamped
 
       /**
        * Check if the requested location is off the mesh.  If so, and
@@ -275,11 +282,11 @@ class unified_bed_leveling {
       }
       return z0;
     }
+    static inline float get_z_correction(const xy_pos_t &pos) { return get_z_correction(pos.x, pos.y); }
 
     static inline float mesh_index_to_xpos(const uint8_t i) {
       return i < GRID_MAX_POINTS_X ? pgm_read_float(&_mesh_index_to_xpos[i]) : MESH_MIN_X + i * (MESH_X_DIST);
     }
-
     static inline float mesh_index_to_ypos(const uint8_t i) {
       return i < GRID_MAX_POINTS_Y ? pgm_read_float(&_mesh_index_to_ypos[i]) : MESH_MIN_Y + i * (MESH_Y_DIST);
     }

commit 455dabb18334c89878a75be62bccebd9f537574d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 26 01:28:09 2019 -0500

    Add a feedRate_t data type (#15349)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 5183dc8485..6897217c38 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -285,9 +285,9 @@ class unified_bed_leveling {
     }
 
     #if UBL_SEGMENTED
-      static bool prepare_segmented_line_to(const float (&rtarget)[XYZE], const float &feedrate);
+      static bool line_to_destination_segmented(const feedRate_t &scaled_fr_mm_s);
     #else
-      static void line_to_destination_cartesian(const float &fr, const uint8_t e);
+      static void line_to_destination_cartesian(const feedRate_t &scaled_fr_mm_s, const uint8_t e);
     #endif
 
     static inline bool mesh_is_valid() {

commit c353eaa14630eb9d74f185e2b6aae1630ca21525
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 17 18:16:28 2019 -0500

    Misc changes from struct refactor (#15289)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index a231f9d438..5183dc8485 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -23,11 +23,7 @@
 
 //#define UBL_DEVEL_DEBUGGING
 
-#include "../bedlevel.h"
-#include "../../../module/planner.h"
 #include "../../../module/motion.h"
-#include "../../../lcd/ultralcd.h"
-#include "../../../Marlin.h"
 
 #define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
 #include "../../../core/debug_out.h"
@@ -108,31 +104,9 @@ class unified_bed_leveling {
 
     static int8_t storage_slot;
 
-    static float z_values[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
-
-    // 15 is the maximum nubmer of grid points supported + 1 safety margin for now,
-    // until determinism prevails
-    static constexpr float _mesh_index_to_xpos[16] PROGMEM = {
-                              MESH_MIN_X +  0 * (MESH_X_DIST), MESH_MIN_X +  1 * (MESH_X_DIST),
-                              MESH_MIN_X +  2 * (MESH_X_DIST), MESH_MIN_X +  3 * (MESH_X_DIST),
-                              MESH_MIN_X +  4 * (MESH_X_DIST), MESH_MIN_X +  5 * (MESH_X_DIST),
-                              MESH_MIN_X +  6 * (MESH_X_DIST), MESH_MIN_X +  7 * (MESH_X_DIST),
-                              MESH_MIN_X +  8 * (MESH_X_DIST), MESH_MIN_X +  9 * (MESH_X_DIST),
-                              MESH_MIN_X + 10 * (MESH_X_DIST), MESH_MIN_X + 11 * (MESH_X_DIST),
-                              MESH_MIN_X + 12 * (MESH_X_DIST), MESH_MIN_X + 13 * (MESH_X_DIST),
-                              MESH_MIN_X + 14 * (MESH_X_DIST), MESH_MIN_X + 15 * (MESH_X_DIST)
-                            };
-
-    static constexpr float _mesh_index_to_ypos[16] PROGMEM = {
-                              MESH_MIN_Y +  0 * (MESH_Y_DIST), MESH_MIN_Y +  1 * (MESH_Y_DIST),
-                              MESH_MIN_Y +  2 * (MESH_Y_DIST), MESH_MIN_Y +  3 * (MESH_Y_DIST),
-                              MESH_MIN_Y +  4 * (MESH_Y_DIST), MESH_MIN_Y +  5 * (MESH_Y_DIST),
-                              MESH_MIN_Y +  6 * (MESH_Y_DIST), MESH_MIN_Y +  7 * (MESH_Y_DIST),
-                              MESH_MIN_Y +  8 * (MESH_Y_DIST), MESH_MIN_Y +  9 * (MESH_Y_DIST),
-                              MESH_MIN_Y + 10 * (MESH_Y_DIST), MESH_MIN_Y + 11 * (MESH_Y_DIST),
-                              MESH_MIN_Y + 12 * (MESH_Y_DIST), MESH_MIN_Y + 13 * (MESH_Y_DIST),
-                              MESH_MIN_Y + 14 * (MESH_Y_DIST), MESH_MIN_Y + 15 * (MESH_Y_DIST)
-                            };
+    static bed_mesh_t z_values;
+    static const float _mesh_index_to_xpos[GRID_MAX_POINTS_X],
+                       _mesh_index_to_ypos[GRID_MAX_POINTS_Y];
 
     #if HAS_LCD_MENU
       static bool lcd_map_control;

commit 465c6d92307ec613d0b2a7355ce67a60ba23fc0c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Sep 14 03:05:10 2019 -0500

    Simpler Allen Key config. Fixes, cleanups from refactor (#15256)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 20ff9b0779..a231f9d438 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -145,14 +145,14 @@ class unified_bed_leveling {
     FORCE_INLINE static void set_z(const int8_t px, const int8_t py, const float &z) { z_values[px][py] = z; }
 
     static int8_t get_cell_index_x(const float &x) {
-      const int8_t cx = (x - (MESH_MIN_X)) * (1.0f / (MESH_X_DIST));
+      const int8_t cx = (x - (MESH_MIN_X)) * RECIPROCAL(MESH_X_DIST);
       return constrain(cx, 0, (GRID_MAX_POINTS_X) - 1);   // -1 is appropriate if we want all movement to the X_MAX
     }                                                     // position. But with this defined this way, it is possible
                                                           // to extrapolate off of this point even further out. Probably
                                                           // that is OK because something else should be keeping that from
                                                           // happening and should not be worried about at this level.
     static int8_t get_cell_index_y(const float &y) {
-      const int8_t cy = (y - (MESH_MIN_Y)) * (1.0f / (MESH_Y_DIST));
+      const int8_t cy = (y - (MESH_MIN_Y)) * RECIPROCAL(MESH_Y_DIST);
       return constrain(cy, 0, (GRID_MAX_POINTS_Y) - 1);   // -1 is appropriate if we want all movement to the Y_MAX
     }                                                     // position. But with this defined this way, it is possible
                                                           // to extrapolate off of this point even further out. Probably
@@ -160,12 +160,12 @@ class unified_bed_leveling {
                                                           // happening and should not be worried about at this level.
 
     static int8_t find_closest_x_index(const float &x) {
-      const int8_t px = (x - (MESH_MIN_X) + (MESH_X_DIST) * 0.5) * (1.0f / (MESH_X_DIST));
+      const int8_t px = (x - (MESH_MIN_X) + (MESH_X_DIST) * 0.5) * RECIPROCAL(MESH_X_DIST);
       return WITHIN(px, 0, GRID_MAX_POINTS_X - 1) ? px : -1;
     }
 
     static int8_t find_closest_y_index(const float &y) {
-      const int8_t py = (y - (MESH_MIN_Y) + (MESH_Y_DIST) * 0.5) * (1.0f / (MESH_Y_DIST));
+      const int8_t py = (y - (MESH_MIN_Y) + (MESH_Y_DIST) * 0.5) * RECIPROCAL(MESH_Y_DIST);
       return WITHIN(py, 0, GRID_MAX_POINTS_Y - 1) ? py : -1;
     }
 
@@ -210,7 +210,7 @@ class unified_bed_leveling {
         );
       }
 
-      const float xratio = (rx0 - mesh_index_to_xpos(x1_i)) * (1.0f / (MESH_X_DIST)),
+      const float xratio = (rx0 - mesh_index_to_xpos(x1_i)) * RECIPROCAL(MESH_X_DIST),
                   z1 = z_values[x1_i][yi];
 
       return z1 + xratio * (z_values[_MIN(x1_i, GRID_MAX_POINTS_X - 2) + 1][yi] - z1); // Don't allow x1_i+1 to be past the end of the array
@@ -239,7 +239,7 @@ class unified_bed_leveling {
         );
       }
 
-      const float yratio = (ry0 - mesh_index_to_ypos(y1_i)) * (1.0f / (MESH_Y_DIST)),
+      const float yratio = (ry0 - mesh_index_to_ypos(y1_i)) * RECIPROCAL(MESH_Y_DIST),
                   z1 = z_values[xi][y1_i];
 
       return z1 + yratio * (z_values[xi][_MIN(y1_i, GRID_MAX_POINTS_Y - 2) + 1] - z1); // Don't allow y1_i+1 to be past the end of the array

commit 750a16ad385dca893d482cb51d8af2ac3f8a1da1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jul 5 18:01:21 2019 -0500

    Fix MIN/MAX function collision with macros

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 927f1fcb79..20ff9b0779 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -213,7 +213,7 @@ class unified_bed_leveling {
       const float xratio = (rx0 - mesh_index_to_xpos(x1_i)) * (1.0f / (MESH_X_DIST)),
                   z1 = z_values[x1_i][yi];
 
-      return z1 + xratio * (z_values[MIN(x1_i, GRID_MAX_POINTS_X - 2) + 1][yi] - z1); // Don't allow x1_i+1 to be past the end of the array
+      return z1 + xratio * (z_values[_MIN(x1_i, GRID_MAX_POINTS_X - 2) + 1][yi] - z1); // Don't allow x1_i+1 to be past the end of the array
                                                                                       // If it is, it is clamped to the last element of the
                                                                                       // z_values[][] array and no correction is applied.
     }
@@ -242,7 +242,7 @@ class unified_bed_leveling {
       const float yratio = (ry0 - mesh_index_to_ypos(y1_i)) * (1.0f / (MESH_Y_DIST)),
                   z1 = z_values[xi][y1_i];
 
-      return z1 + yratio * (z_values[xi][MIN(y1_i, GRID_MAX_POINTS_Y - 2) + 1] - z1); // Don't allow y1_i+1 to be past the end of the array
+      return z1 + yratio * (z_values[xi][_MIN(y1_i, GRID_MAX_POINTS_Y - 2) + 1] - z1); // Don't allow y1_i+1 to be past the end of the array
                                                                                       // If it is, it is clamped to the last element of the
                                                                                       // z_values[][] array and no correction is applied.
     }
@@ -268,11 +268,11 @@ class unified_bed_leveling {
 
       const float z1 = calc_z0(rx0,
                                mesh_index_to_xpos(cx), z_values[cx][cy],
-                               mesh_index_to_xpos(cx + 1), z_values[MIN(cx, GRID_MAX_POINTS_X - 2) + 1][cy]);
+                               mesh_index_to_xpos(cx + 1), z_values[_MIN(cx, GRID_MAX_POINTS_X - 2) + 1][cy]);
 
       const float z2 = calc_z0(rx0,
-                               mesh_index_to_xpos(cx), z_values[cx][MIN(cy, GRID_MAX_POINTS_Y - 2) + 1],
-                               mesh_index_to_xpos(cx + 1), z_values[MIN(cx, GRID_MAX_POINTS_X - 2) + 1][MIN(cy, GRID_MAX_POINTS_Y - 2) + 1]);
+                               mesh_index_to_xpos(cx), z_values[cx][_MIN(cy, GRID_MAX_POINTS_Y - 2) + 1],
+                               mesh_index_to_xpos(cx + 1), z_values[_MIN(cx, GRID_MAX_POINTS_X - 2) + 1][_MIN(cy, GRID_MAX_POINTS_Y - 2) + 1]);
 
       float z0 = calc_z0(ry0,
                          mesh_index_to_ypos(cy), z1,

commit 93cd66ac1146603e8a9911fceb3c63f4351f4d8e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 23:57:50 2019 -0500

    Tweaky change from (C) to (c)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index a7c7f033b3..927f1fcb79 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -1,9 +1,9 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by

commit cf12fc8366f2ffbc3811173769d5428236af0dd9
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Apr 5 20:02:46 2019 -0500

    Expand on serial debugging (#13577)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 969fd209dc..a7c7f033b3 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -39,14 +39,6 @@
 #define USE_NOZZLE_AS_REFERENCE 0
 #define USE_PROBE_AS_REFERENCE 1
 
-// ubl_motion.cpp
-
-#if ENABLED(UBL_DEVEL_DEBUGGING)
-  void debug_current_and_destination(PGM_P const title);
-#else
-  FORCE_INLINE void debug_current_and_destination(PGM_P const title) { UNUSED(title); }
-#endif
-
 // ubl_G29.cpp
 
 enum MeshPointType : char { INVALID, REAL, SET_IN_BITMAP };

commit 5b2c37d6c1318079687eed6e14aecd3a4ef2ce47
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Mon Mar 18 17:31:11 2019 -0400

    Followup to BLTouch (#13422)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index b71ddee982..969fd209dc 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -335,7 +335,9 @@ class unified_bed_leveling {
 
 extern unified_bed_leveling ubl;
 
-#define Z_VALUES(X,Y) ubl.z_values[X][Y]
+#define _GET_MESH_X(I) ubl.mesh_index_to_xpos(I)
+#define _GET_MESH_Y(J) ubl.mesh_index_to_ypos(J)
+#define Z_VALUES_ARR ubl.z_values
 
 // Prevent debugging propagating to other files
 #include "../../../core/debug_out.h"

commit f5bcc00570bd5ae2ba0deaa7af0ba4d3ce7c3b02
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Mar 14 02:25:42 2019 -0500

    Unify debugging output with debug_out.h (#13388)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index face56182a..b71ddee982 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -29,6 +29,9 @@
 #include "../../../lcd/ultralcd.h"
 #include "../../../Marlin.h"
 
+#define DEBUG_OUT ENABLED(DEBUG_LEVELING_FEATURE)
+#include "../../../core/debug_out.h"
+
 #define UBL_VERSION "1.01"
 #define UBL_OK false
 #define UBL_ERR true
@@ -199,12 +202,11 @@ class unified_bed_leveling {
      */
     static inline float z_correction_for_x_on_horizontal_mesh_line(const float &rx0, const int x1_i, const int yi) {
       if (!WITHIN(x1_i, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(yi, 0, GRID_MAX_POINTS_Y - 1)) {
-        #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) {
-            serialprintPGM( !WITHIN(x1_i, 0, GRID_MAX_POINTS_X - 1) ? PSTR("x1_i") : PSTR("yi") );
-            SERIAL_ECHOLNPAIR(" out of bounds in z_correction_for_x_on_horizontal_mesh_line(rx0=", rx0, ",x1_i=", x1_i, ",yi=", yi, ")");
-          }
-        #endif
+
+        if (DEBUGGING(LEVELING)) {
+          if (WITHIN(x1_i, 0, GRID_MAX_POINTS_X - 1)) DEBUG_ECHOPGM("yi"); else DEBUG_ECHOPGM("x1_i");
+          DEBUG_ECHOLNPAIR(" out of bounds in z_correction_for_x_on_horizontal_mesh_line(rx0=", rx0, ",x1_i=", x1_i, ",yi=", yi, ")");
+        }
 
         // The requested location is off the mesh. Return UBL_Z_RAISE_WHEN_OFF_MESH or NAN.
         return (
@@ -229,12 +231,11 @@ class unified_bed_leveling {
     //
     static inline float z_correction_for_y_on_vertical_mesh_line(const float &ry0, const int xi, const int y1_i) {
       if (!WITHIN(xi, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(y1_i, 0, GRID_MAX_POINTS_Y - 1)) {
-        #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(LEVELING)) {
-            serialprintPGM(!WITHIN(xi, 0, GRID_MAX_POINTS_X - 1) ? PSTR("xi") : PSTR("y1_i"));
-            SERIAL_ECHOLNPAIR(" out of bounds in z_correction_for_y_on_vertical_mesh_line(ry0=", ry0, ", xi=", xi, ", y1_i=", y1_i, ")");
-          }
-        #endif
+
+        if (DEBUGGING(LEVELING)) {
+          if (WITHIN(xi, 0, GRID_MAX_POINTS_X - 1)) DEBUG_ECHOPGM("y1_i"); else DEBUG_ECHOPGM("xi");
+          DEBUG_ECHOLNPAIR(" out of bounds in z_correction_for_y_on_vertical_mesh_line(ry0=", ry0, ", xi=", xi, ", y1_i=", y1_i, ")");
+        }
 
         // The requested location is off the mesh. Return UBL_Z_RAISE_WHEN_OFF_MESH or NAN.
         return (
@@ -285,17 +286,12 @@ class unified_bed_leveling {
                          mesh_index_to_ypos(cy), z1,
                          mesh_index_to_ypos(cy + 1), z2);
 
-      #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(MESH_ADJUST)) {
-          SERIAL_ECHOPAIR(" raw get_z_correction(", rx0);
-          SERIAL_CHAR(','); SERIAL_ECHO(ry0);
-          SERIAL_ECHOPAIR_F(") = ", z0, 6);
-        }
-      #endif
-
-      #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(MESH_ADJUST)) SERIAL_ECHOLNPAIR_F(" >>>---> ", z0, 6);
-      #endif
+      if (DEBUGGING(MESH_ADJUST)) {
+        DEBUG_ECHOPAIR(" raw get_z_correction(", rx0);
+        DEBUG_CHAR(','); DEBUG_ECHO(ry0);
+        DEBUG_ECHOPAIR_F(") = ", z0, 6);
+        DEBUG_ECHOLNPAIR_F(" >>>---> ", z0, 6);
+      }
 
       if (isnan(z0)) { // if part of the Mesh is undefined, it will show up as NAN
         z0 = 0.0;      // in ubl.z_values[][] and propagate through the
@@ -303,15 +299,13 @@ class unified_bed_leveling {
                        // because part of the Mesh is undefined and we don't have the
                        // information we need to complete the height correction.
 
-        #if ENABLED(DEBUG_LEVELING_FEATURE)
-          if (DEBUGGING(MESH_ADJUST)) {
-            SERIAL_ECHOPAIR("??? Yikes!  NAN in get_z_correction(", rx0);
-            SERIAL_CHAR(',');
-            SERIAL_ECHO(ry0);
-            SERIAL_CHAR(')');
-            SERIAL_EOL();
-          }
-        #endif
+        if (DEBUGGING(MESH_ADJUST)) {
+          DEBUG_ECHOPAIR("??? Yikes!  NAN in get_z_correction(", rx0);
+          DEBUG_CHAR(',');
+          DEBUG_ECHO(ry0);
+          DEBUG_CHAR(')');
+          DEBUG_EOL();
+        }
       }
       return z0;
     }
@@ -342,3 +336,6 @@ class unified_bed_leveling {
 extern unified_bed_leveling ubl;
 
 #define Z_VALUES(X,Y) ubl.z_values[X][Y]
+
+// Prevent debugging propagating to other files
+#include "../../../core/debug_out.h"

commit cfdb38eda4b4d993bac4a0e8600e776429b42b6e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Mar 5 06:46:19 2019 -0600

    Allow SERIAL_ECHOPAIR to take up to 12 pairs (#13311)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index c647f632a0..face56182a 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -202,11 +202,7 @@ class unified_bed_leveling {
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING)) {
             serialprintPGM( !WITHIN(x1_i, 0, GRID_MAX_POINTS_X - 1) ? PSTR("x1_i") : PSTR("yi") );
-            SERIAL_ECHOPAIR(" out of bounds in z_correction_for_x_on_horizontal_mesh_line(rx0=", rx0);
-            SERIAL_ECHOPAIR(",x1_i=", x1_i);
-            SERIAL_ECHOPAIR(",yi=", yi);
-            SERIAL_CHAR(')');
-            SERIAL_EOL();
+            SERIAL_ECHOLNPAIR(" out of bounds in z_correction_for_x_on_horizontal_mesh_line(rx0=", rx0, ",x1_i=", x1_i, ",yi=", yi, ")");
           }
         #endif
 
@@ -235,12 +231,8 @@ class unified_bed_leveling {
       if (!WITHIN(xi, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(y1_i, 0, GRID_MAX_POINTS_Y - 1)) {
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING)) {
-            serialprintPGM( !WITHIN(xi, 0, GRID_MAX_POINTS_X - 1) ? PSTR("xi") : PSTR("y1_i") );
-            SERIAL_ECHOPAIR(" out of bounds in z_correction_for_y_on_vertical_mesh_line(ry0=", ry0);
-            SERIAL_ECHOPAIR(", xi=", xi);
-            SERIAL_ECHOPAIR(", y1_i=", y1_i);
-            SERIAL_CHAR(')');
-            SERIAL_EOL();
+            serialprintPGM(!WITHIN(xi, 0, GRID_MAX_POINTS_X - 1) ? PSTR("xi") : PSTR("y1_i"));
+            SERIAL_ECHOLNPAIR(" out of bounds in z_correction_for_y_on_vertical_mesh_line(ry0=", ry0, ", xi=", xi, ", y1_i=", y1_i, ")");
           }
         #endif
 

commit e15354e387cc825390fc4eaaf3ae4b784a8fd588
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Feb 23 22:53:01 2019 -0600

    Simplify serial port redirect (#13234)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index db613ddc85..c647f632a0 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -94,21 +94,9 @@ class unified_bed_leveling {
 
   public:
 
-    static void echo_name(
-      #if NUM_SERIAL > 1
-        const int8_t port = -1
-      #endif
-    );
-    static void report_current_mesh(
-      #if NUM_SERIAL > 1
-        const int8_t port = -1
-      #endif
-    );
-    static void report_state(
-      #if NUM_SERIAL > 1
-        const int8_t port = -1
-      #endif
-    );
+    static void echo_name();
+    static void report_current_mesh();
+    static void report_state();
     static void save_ubl_active_state_and_disable();
     static void restore_ubl_active_state_and_leave();
     static void display_map(const int) _O0;

commit 0feeef26048883640b37ebe3994730f31ef6e922
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 15:06:53 2019 -0600

    Update copyright in headers

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index e3b8fab280..db613ddc85 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -1,6 +1,6 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2016, 2017 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm

commit c98623983774b9773800bc7dcef695c4bad81c0e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Nov 29 16:58:58 2018 -0600

    A single SERIAL_ECHO macro type (#12557)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index cd13e081d9..e3b8fab280 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -308,19 +308,13 @@ class unified_bed_leveling {
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(MESH_ADJUST)) {
           SERIAL_ECHOPAIR(" raw get_z_correction(", rx0);
-          SERIAL_CHAR(',');
-          SERIAL_ECHO(ry0);
-          SERIAL_ECHOPGM(") = ");
-          SERIAL_ECHO_F(z0, 6);
+          SERIAL_CHAR(','); SERIAL_ECHO(ry0);
+          SERIAL_ECHOPAIR_F(") = ", z0, 6);
         }
       #endif
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
-        if (DEBUGGING(MESH_ADJUST)) {
-          SERIAL_ECHOPGM(" >>>---> ");
-          SERIAL_ECHO_F(z0, 6);
-          SERIAL_EOL();
-        }
+        if (DEBUGGING(MESH_ADJUST)) SERIAL_ECHOLNPAIR_F(" >>>---> ", z0, 6);
       #endif
 
       if (isnan(z0)) { // if part of the Mesh is undefined, it will show up as NAN

commit a0c795b097a30eff006c8dff178abf5f1f1907fa
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Nov 11 12:16:24 2018 -0600

    Encapsulate common display code in a singleton (#12395)
    
    * Encapsulate common LCD code in a singleton
    * Depend more UBL code on UBL_DEVEL_DEBUGGING
      - Since most users don't need the debugging on at all times, this helps reduce the default build size for UBL by over 2K, a little closer to fitting on 128K boards.

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 809e3827fe..cd13e081d9 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -26,6 +26,7 @@
 #include "../bedlevel.h"
 #include "../../../module/planner.h"
 #include "../../../module/motion.h"
+#include "../../../lcd/ultralcd.h"
 #include "../../../Marlin.h"
 
 #define UBL_VERSION "1.01"
@@ -49,12 +50,6 @@ enum MeshPointType : char { INVALID, REAL, SET_IN_BITMAP };
 
 // External references
 
-extern uint8_t ubl_cnt;
-
-#if ENABLED(ULTRA_LCD)
-  void lcd_quick_feedback(const bool clear_buttons);
-#endif
-
 #define MESH_X_DIST (float(MESH_MAX_X - (MESH_MIN_X)) / float(GRID_MAX_POINTS_X - 1))
 #define MESH_Y_DIST (float(MESH_MAX_Y - (MESH_MIN_Y)) / float(GRID_MAX_POINTS_Y - 1))
 
@@ -88,12 +83,15 @@ class unified_bed_leveling {
     static void probe_entire_mesh(const float &rx, const float &ry, const bool do_ubl_mesh_map, const bool stow_probe, const bool do_furthest) _O0;
     static void tilt_mesh_based_on_3pts(const float &z1, const float &z2, const float &z3);
     static void tilt_mesh_based_on_probed_grid(const bool do_ubl_mesh_map);
-    static void g29_what_command();
-    static void g29_eeprom_dump();
-    static void g29_compare_current_mesh_to_stored_mesh();
     static bool smart_fill_one(const uint8_t x, const uint8_t y, const int8_t xdir, const int8_t ydir);
     static void smart_fill_mesh();
 
+    #if ENABLED(UBL_DEVEL_DEBUGGING)
+      static void g29_what_command();
+      static void g29_eeprom_dump();
+      static void g29_compare_current_mesh_to_stored_mesh();
+    #endif
+
   public:
 
     static void echo_name(

commit 471f403a671e7d095477be9a0cf2ed18d6dcbbd8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Nov 11 07:51:39 2018 -0600

    Reduce code size with plain inlines

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 805469b8d4..809e3827fe 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -51,8 +51,6 @@ enum MeshPointType : char { INVALID, REAL, SET_IN_BITMAP };
 
 extern uint8_t ubl_cnt;
 
-///////////////////////////////////////////////////////////////////////////////////////////////////////
-
 #if ENABLED(ULTRA_LCD)
   void lcd_quick_feedback(const bool clear_buttons);
 #endif
@@ -346,11 +344,11 @@ class unified_bed_leveling {
       return z0;
     }
 
-    FORCE_INLINE static float mesh_index_to_xpos(const uint8_t i) {
+    static inline float mesh_index_to_xpos(const uint8_t i) {
       return i < GRID_MAX_POINTS_X ? pgm_read_float(&_mesh_index_to_xpos[i]) : MESH_MIN_X + i * (MESH_X_DIST);
     }
 
-    FORCE_INLINE static float mesh_index_to_ypos(const uint8_t i) {
+    static inline float mesh_index_to_ypos(const uint8_t i) {
       return i < GRID_MAX_POINTS_Y ? pgm_read_float(&_mesh_index_to_ypos[i]) : MESH_MIN_Y + i * (MESH_Y_DIST);
     }
 

commit 44fa7fb18cf1e72569215d6425ddc43063d9e37e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Nov 3 02:13:10 2018 -0500

    Cleanups for leveling-related code

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 6f2cfb1ac6..805469b8d4 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -370,3 +370,5 @@ class unified_bed_leveling {
 }; // class unified_bed_leveling
 
 extern unified_bed_leveling ubl;
+
+#define Z_VALUES(X,Y) ubl.z_values[X][Y]

commit f5eab912ed6d336f2c37a688a0ec822ed3d42fcc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Nov 4 02:25:55 2018 -0600

    Apply #pragma once, misc cleanup (#12322)
    
    * Apply #pragma once in headers
    * Adjust some thermistors formatting
    * Misc cleanup and formatting

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index f851b2e05c..6f2cfb1ac6 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -19,9 +19,7 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
-
-#ifndef UNIFIED_BED_LEVELING_H
-#define UNIFIED_BED_LEVELING_H
+#pragma once
 
 //#define UBL_DEVEL_DEBUGGING
 
@@ -372,5 +370,3 @@ class unified_bed_leveling {
 }; // class unified_bed_leveling
 
 extern unified_bed_leveling ubl;
-
-#endif // UNIFIED_BED_LEVELING_H

commit 3583e2b4490e8fd6778d18003641c2fdd333e8a5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Oct 30 16:34:45 2018 -0500

    Followup to Menu Refactor (#12275)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 2e8af93141..f851b2e05c 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -157,7 +157,7 @@ class unified_bed_leveling {
                               MESH_MIN_Y + 14 * (MESH_Y_DIST), MESH_MIN_Y + 15 * (MESH_Y_DIST)
                             };
 
-    #if ENABLED(ULTIPANEL)
+    #if HAS_LCD_MENU
       static bool lcd_map_control;
     #endif
 

commit 11ac75edcb34a2f90b50ca134ff40839f8c29199
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 30 23:44:33 2018 -0500

    Use PGM_P for PSTR pointers (#11977)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 2db2b4dd7a..2e8af93141 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -40,9 +40,9 @@
 // ubl_motion.cpp
 
 #if ENABLED(UBL_DEVEL_DEBUGGING)
-  void debug_current_and_destination(const char * const title);
+  void debug_current_and_destination(PGM_P const title);
 #else
-  FORCE_INLINE void debug_current_and_destination(const char * const title) { UNUSED(title); }
+  FORCE_INLINE void debug_current_and_destination(PGM_P const title) { UNUSED(title); }
 #endif
 
 // ubl_G29.cpp

commit a4b01483650ce50e3916d4bc16553429825603ec
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Aug 13 23:55:12 2018 -0500

    Easier to find 'static inline'

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index cbd5ed4bf6..2db2b4dd7a 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -215,7 +215,7 @@ class unified_bed_leveling {
      * z_correction_for_x_on_horizontal_mesh_line is an optimization for
      * the case where the printer is making a vertical line that only crosses horizontal mesh lines.
      */
-    inline static float z_correction_for_x_on_horizontal_mesh_line(const float &rx0, const int x1_i, const int yi) {
+    static inline float z_correction_for_x_on_horizontal_mesh_line(const float &rx0, const int x1_i, const int yi) {
       if (!WITHIN(x1_i, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(yi, 0, GRID_MAX_POINTS_Y - 1)) {
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING)) {
@@ -249,7 +249,7 @@ class unified_bed_leveling {
     //
     // See comments above for z_correction_for_x_on_horizontal_mesh_line
     //
-    inline static float z_correction_for_y_on_vertical_mesh_line(const float &ry0, const int xi, const int y1_i) {
+    static inline float z_correction_for_y_on_vertical_mesh_line(const float &ry0, const int xi, const int y1_i) {
       if (!WITHIN(xi, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(y1_i, 0, GRID_MAX_POINTS_Y - 1)) {
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING)) {
@@ -362,7 +362,7 @@ class unified_bed_leveling {
       static void line_to_destination_cartesian(const float &fr, const uint8_t e);
     #endif
 
-    inline static bool mesh_is_valid() {
+    static inline bool mesh_is_valid() {
       for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
         for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
           if (isnan(z_values[x][y])) return false;

commit 1367df2875b4aff41e9c98824e3f7b56f4403e4d
Author: etagle <ejtagle@hotmail.com>
Date:   Sun Jul 1 17:20:28 2018 -0300

    Replace double with float, optimize calculation

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index eb88234823..cbd5ed4bf6 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -168,14 +168,14 @@ class unified_bed_leveling {
     FORCE_INLINE static void set_z(const int8_t px, const int8_t py, const float &z) { z_values[px][py] = z; }
 
     static int8_t get_cell_index_x(const float &x) {
-      const int8_t cx = (x - (MESH_MIN_X)) * (1.0 / (MESH_X_DIST));
+      const int8_t cx = (x - (MESH_MIN_X)) * (1.0f / (MESH_X_DIST));
       return constrain(cx, 0, (GRID_MAX_POINTS_X) - 1);   // -1 is appropriate if we want all movement to the X_MAX
     }                                                     // position. But with this defined this way, it is possible
                                                           // to extrapolate off of this point even further out. Probably
                                                           // that is OK because something else should be keeping that from
                                                           // happening and should not be worried about at this level.
     static int8_t get_cell_index_y(const float &y) {
-      const int8_t cy = (y - (MESH_MIN_Y)) * (1.0 / (MESH_Y_DIST));
+      const int8_t cy = (y - (MESH_MIN_Y)) * (1.0f / (MESH_Y_DIST));
       return constrain(cy, 0, (GRID_MAX_POINTS_Y) - 1);   // -1 is appropriate if we want all movement to the Y_MAX
     }                                                     // position. But with this defined this way, it is possible
                                                           // to extrapolate off of this point even further out. Probably
@@ -183,12 +183,12 @@ class unified_bed_leveling {
                                                           // happening and should not be worried about at this level.
 
     static int8_t find_closest_x_index(const float &x) {
-      const int8_t px = (x - (MESH_MIN_X) + (MESH_X_DIST) * 0.5) * (1.0 / (MESH_X_DIST));
+      const int8_t px = (x - (MESH_MIN_X) + (MESH_X_DIST) * 0.5) * (1.0f / (MESH_X_DIST));
       return WITHIN(px, 0, GRID_MAX_POINTS_X - 1) ? px : -1;
     }
 
     static int8_t find_closest_y_index(const float &y) {
-      const int8_t py = (y - (MESH_MIN_Y) + (MESH_Y_DIST) * 0.5) * (1.0 / (MESH_Y_DIST));
+      const int8_t py = (y - (MESH_MIN_Y) + (MESH_Y_DIST) * 0.5) * (1.0f / (MESH_Y_DIST));
       return WITHIN(py, 0, GRID_MAX_POINTS_Y - 1) ? py : -1;
     }
 
@@ -238,7 +238,7 @@ class unified_bed_leveling {
         );
       }
 
-      const float xratio = (rx0 - mesh_index_to_xpos(x1_i)) * (1.0 / (MESH_X_DIST)),
+      const float xratio = (rx0 - mesh_index_to_xpos(x1_i)) * (1.0f / (MESH_X_DIST)),
                   z1 = z_values[x1_i][yi];
 
       return z1 + xratio * (z_values[MIN(x1_i, GRID_MAX_POINTS_X - 2) + 1][yi] - z1); // Don't allow x1_i+1 to be past the end of the array
@@ -272,7 +272,7 @@ class unified_bed_leveling {
         );
       }
 
-      const float yratio = (ry0 - mesh_index_to_ypos(y1_i)) * (1.0 / (MESH_Y_DIST)),
+      const float yratio = (ry0 - mesh_index_to_ypos(y1_i)) * (1.0f / (MESH_Y_DIST)),
                   z1 = z_values[xi][y1_i];
 
       return z1 + yratio * (z_values[xi][MIN(y1_i, GRID_MAX_POINTS_Y - 2) + 1] - z1); // Don't allow y1_i+1 to be past the end of the array

commit 6f330f397e58130dcc9871fba33786575ac37f6f
Author: Eduardo Jos√© Tagle <ejtagle@hotmail.com>
Date:   Sat May 26 01:32:37 2018 -0300

    [2.0.x] Buffer overflow and scroll fix, UTF8 cleanup (#10844)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index ae03b4d160..eb88234823 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -56,7 +56,6 @@ extern uint8_t ubl_cnt;
 ///////////////////////////////////////////////////////////////////////////////////////////////////////
 
 #if ENABLED(ULTRA_LCD)
-  extern char lcd_status_message[];
   void lcd_quick_feedback(const bool clear_buttons);
 #endif
 

commit eb2eb727207d574deb0db4aef46621a33f1c7f0b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon May 14 22:36:03 2018 -0500

    Modify UBL mesh_is_valid and use in leveling_is_valid (#10746)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index dcb9a1024d..ae03b4d160 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -363,17 +363,11 @@ class unified_bed_leveling {
       static void line_to_destination_cartesian(const float &fr, const uint8_t e);
     #endif
 
-    #define _CMPZ(a,b) (z_values[a][b] == z_values[a][b+1])
-    #define CMPZ(a) (_CMPZ(a, 0) && _CMPZ(a, 1))
-    #define ZZER(a) (z_values[a][0] == 0)
-
-    FORCE_INLINE bool mesh_is_valid() {
-      return !(
-        (    CMPZ(0) && CMPZ(1) && CMPZ(2) // adjacent z values all equal?
-          && ZZER(0) && ZZER(1) && ZZER(2) // all zero at the edge?
-        )
-        || isnan(z_values[0][0])
-      );
+    inline static bool mesh_is_valid() {
+      for (uint8_t x = 0; x < GRID_MAX_POINTS_X; x++)
+        for (uint8_t y = 0; y < GRID_MAX_POINTS_Y; y++)
+          if (isnan(z_values[x][y])) return false;
+      return true;
     }
 
 }; // class unified_bed_leveling

commit 99ecdf59af907ebb8d2d847863614094bb576e3f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 13 01:10:34 2018 -0500

    Smarter MIN, MAX, ABS macros
    
    Use macros that explicitly avoid double-evaluation and can be used for any datatype, replacing `min`, `max`, `abs`, `fabs`, `labs`, and `FABS`.
    
    Co-Authored-By: ejtagle <ejtagle@hotmail.com>

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index a79d9a67ec..dcb9a1024d 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -242,7 +242,7 @@ class unified_bed_leveling {
       const float xratio = (rx0 - mesh_index_to_xpos(x1_i)) * (1.0 / (MESH_X_DIST)),
                   z1 = z_values[x1_i][yi];
 
-      return z1 + xratio * (z_values[min(x1_i, GRID_MAX_POINTS_X - 2) + 1][yi] - z1); // Don't allow x1_i+1 to be past the end of the array
+      return z1 + xratio * (z_values[MIN(x1_i, GRID_MAX_POINTS_X - 2) + 1][yi] - z1); // Don't allow x1_i+1 to be past the end of the array
                                                                                       // If it is, it is clamped to the last element of the
                                                                                       // z_values[][] array and no correction is applied.
     }
@@ -276,7 +276,7 @@ class unified_bed_leveling {
       const float yratio = (ry0 - mesh_index_to_ypos(y1_i)) * (1.0 / (MESH_Y_DIST)),
                   z1 = z_values[xi][y1_i];
 
-      return z1 + yratio * (z_values[xi][min(y1_i, GRID_MAX_POINTS_Y - 2) + 1] - z1); // Don't allow y1_i+1 to be past the end of the array
+      return z1 + yratio * (z_values[xi][MIN(y1_i, GRID_MAX_POINTS_Y - 2) + 1] - z1); // Don't allow y1_i+1 to be past the end of the array
                                                                                       // If it is, it is clamped to the last element of the
                                                                                       // z_values[][] array and no correction is applied.
     }
@@ -302,11 +302,11 @@ class unified_bed_leveling {
 
       const float z1 = calc_z0(rx0,
                                mesh_index_to_xpos(cx), z_values[cx][cy],
-                               mesh_index_to_xpos(cx + 1), z_values[min(cx, GRID_MAX_POINTS_X - 2) + 1][cy]);
+                               mesh_index_to_xpos(cx + 1), z_values[MIN(cx, GRID_MAX_POINTS_X - 2) + 1][cy]);
 
       const float z2 = calc_z0(rx0,
-                               mesh_index_to_xpos(cx), z_values[cx][min(cy, GRID_MAX_POINTS_Y - 2) + 1],
-                               mesh_index_to_xpos(cx + 1), z_values[min(cx, GRID_MAX_POINTS_X - 2) + 1][min(cy, GRID_MAX_POINTS_Y - 2) + 1]);
+                               mesh_index_to_xpos(cx), z_values[cx][MIN(cy, GRID_MAX_POINTS_Y - 2) + 1],
+                               mesh_index_to_xpos(cx + 1), z_values[MIN(cx, GRID_MAX_POINTS_X - 2) + 1][MIN(cy, GRID_MAX_POINTS_Y - 2) + 1]);
 
       float z0 = calc_z0(ry0,
                          mesh_index_to_ypos(cy), z1,

commit 8db7fb226a515a0b0dd1ca009ea2e27f2a03c5f0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Apr 28 08:14:20 2018 -0500

    Fix M420 C for UBL

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 0d126daf9c..a79d9a67ec 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -124,7 +124,7 @@ class unified_bed_leveling {
     static void reset();
     static void invalidate();
     static void set_all_mesh_points_to_value(const float value);
-    static void adjust_mesh_to_mean(const float value);
+    static void adjust_mesh_to_mean(const bool cflag, const float value);
     static bool sanity_check();
 
     static void G29() _O0;                          // O0 for no optimization

commit eef0248a1c66cf30482253359f8bebe672ef56a9
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 25 06:43:45 2018 -0500

    Add M420 C to adjust the whole mesh (#10522)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 9de087c3bf..0d126daf9c 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -89,7 +89,6 @@ class unified_bed_leveling {
     #endif
 
     static bool g29_parameter_parsing() _O0;
-    static void find_mean_mesh_height();
     static void shift_mesh_height();
     static void probe_entire_mesh(const float &rx, const float &ry, const bool do_ubl_mesh_map, const bool stow_probe, const bool do_furthest) _O0;
     static void tilt_mesh_based_on_3pts(const float &z1, const float &z2, const float &z3);
@@ -124,7 +123,8 @@ class unified_bed_leveling {
     static mesh_index_pair find_furthest_invalid_mesh_point() _O0;
     static void reset();
     static void invalidate();
-    static void set_all_mesh_points_to_value(const float);
+    static void set_all_mesh_points_to_value(const float value);
+    static void adjust_mesh_to_mean(const float value);
     static bool sanity_check();
 
     static void G29() _O0;                          // O0 for no optimization

commit 9515e5aefba9826308607ebb3f497ecfc538ca52
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 7 05:49:10 2018 -0600

    Fix LA_active_extruder (static)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 144a2a707a..9de087c3bf 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -136,7 +136,7 @@ class unified_bed_leveling {
 
     // 15 is the maximum nubmer of grid points supported + 1 safety margin for now,
     // until determinism prevails
-    constexpr static float _mesh_index_to_xpos[16] PROGMEM = {
+    static constexpr float _mesh_index_to_xpos[16] PROGMEM = {
                               MESH_MIN_X +  0 * (MESH_X_DIST), MESH_MIN_X +  1 * (MESH_X_DIST),
                               MESH_MIN_X +  2 * (MESH_X_DIST), MESH_MIN_X +  3 * (MESH_X_DIST),
                               MESH_MIN_X +  4 * (MESH_X_DIST), MESH_MIN_X +  5 * (MESH_X_DIST),
@@ -147,7 +147,7 @@ class unified_bed_leveling {
                               MESH_MIN_X + 14 * (MESH_X_DIST), MESH_MIN_X + 15 * (MESH_X_DIST)
                             };
 
-    constexpr static float _mesh_index_to_ypos[16] PROGMEM = {
+    static constexpr float _mesh_index_to_ypos[16] PROGMEM = {
                               MESH_MIN_Y +  0 * (MESH_Y_DIST), MESH_MIN_Y +  1 * (MESH_Y_DIST),
                               MESH_MIN_Y +  2 * (MESH_Y_DIST), MESH_MIN_Y +  3 * (MESH_Y_DIST),
                               MESH_MIN_Y +  4 * (MESH_Y_DIST), MESH_MIN_Y +  5 * (MESH_Y_DIST),

commit 20571771848e2d8d3bb4f216c25c3d610c7e47cb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Mar 6 22:35:22 2018 -0600

    Make enums into implicit char

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 872ca74812..144a2a707a 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -47,7 +47,7 @@
 
 // ubl_G29.cpp
 
-enum MeshPointType { INVALID, REAL, SET_IN_BITMAP };
+enum MeshPointType : char { INVALID, REAL, SET_IN_BITMAP };
 
 // External references
 

commit 24b9c1923f2c0720fd98a626f95420416a23fdeb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 26 20:45:51 2018 -0600

    ubl G29 tweaks

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index a7a1842fbb..872ca74812 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -91,7 +91,7 @@ class unified_bed_leveling {
     static bool g29_parameter_parsing() _O0;
     static void find_mean_mesh_height();
     static void shift_mesh_height();
-    static void probe_entire_mesh(const float &rx, const float &ry, const bool do_ubl_mesh_map, const bool stow_probe, bool do_furthest) _O0;
+    static void probe_entire_mesh(const float &rx, const float &ry, const bool do_ubl_mesh_map, const bool stow_probe, const bool do_furthest) _O0;
     static void tilt_mesh_based_on_3pts(const float &z1, const float &z2, const float &z3);
     static void tilt_mesh_based_on_probed_grid(const bool do_ubl_mesh_map);
     static void g29_what_command();

commit 966d9af98acdb43cca9f15de7f258565270b9704
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Feb 25 08:07:48 2018 -0600

    Mesh export in Bilinear + UBL M503

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 355b3035f9..a7a1842fbb 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -107,6 +107,11 @@ class unified_bed_leveling {
         const int8_t port = -1
       #endif
     );
+    static void report_current_mesh(
+      #if NUM_SERIAL > 1
+        const int8_t port = -1
+      #endif
+    );
     static void report_state(
       #if NUM_SERIAL > 1
         const int8_t port = -1

commit 2228dff3eaae763b3df177c3f2b053299e1350ba
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Feb 25 23:00:42 2018 -0600

    ubl.h compile flags from 1.1.x

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 78bae71475..355b3035f9 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -84,11 +84,11 @@ class unified_bed_leveling {
       static void move_z_with_encoder(const float &multiplier);
       static float measure_point_with_encoder();
       static float measure_business_card_thickness(float in_height);
-      static void manually_probe_remaining_mesh(const float&, const float&, const float&, const float&, const bool);
-      static void fine_tune_mesh(const float &rx, const float &ry, const bool do_ubl_mesh_map);
+      static void manually_probe_remaining_mesh(const float&, const float&, const float&, const float&, const bool) _O0;
+      static void fine_tune_mesh(const float &rx, const float &ry, const bool do_ubl_mesh_map) _O0;
     #endif
 
-    static bool g29_parameter_parsing();
+    static bool g29_parameter_parsing() _O0;
     static void find_mean_mesh_height();
     static void shift_mesh_height();
     static void probe_entire_mesh(const float &rx, const float &ry, const bool do_ubl_mesh_map, const bool stow_probe, bool do_furthest) _O0;
@@ -114,7 +114,7 @@ class unified_bed_leveling {
     );
     static void save_ubl_active_state_and_disable();
     static void restore_ubl_active_state_and_leave();
-    static void display_map(const int);
+    static void display_map(const int) _O0;
     static mesh_index_pair find_closest_mesh_point_of_type(const MeshPointType, const float&, const float&, const bool, uint16_t[16]) _O0;
     static mesh_index_pair find_furthest_invalid_mesh_point() _O0;
     static void reset();

commit d504bbbfa46bab8f3fed5b18e97ca94911d6b2b5
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Wed Feb 21 13:49:12 2018 -0600

    Fix botched check for being off the mesh...

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index e6832bb2f7..78bae71475 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -291,7 +291,7 @@ class unified_bed_leveling {
        * UBL_Z_RAISE_WHEN_OFF_MESH is specified, that value is returned.
        */
       #ifdef UBL_Z_RAISE_WHEN_OFF_MESH
-        if (!WITHIN(rx0, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(ry0, 0, GRID_MAX_POINTS_Y - 1))
+        if (!WITHIN(rx0, MESH_MIN_X, MESH_MAX_X) || !WITHIN(ry0, MESH_MIN_Y, MESH_MAX_Y))
           return UBL_Z_RAISE_WHEN_OFF_MESH;
       #endif
 

commit 304e0f8945f8a25b9c08b5047dc8530a10f66975
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Feb 15 22:22:06 2018 -0600

    Followup to 21e60fd
    
    `ENABLED` only works for flag-type options. Floats must use `#ifdef`.

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index bc4df7f442..e6832bb2f7 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -224,15 +224,14 @@ class unified_bed_leveling {
           }
         #endif
 
-        /**
-         * The requested location is off the mesh.  Check if UBL_Z_RAISE_WHEN_OFF_MESH
-         * is specified. If so, that value is returned.
-         */
-        #if ENABLED(UBL_Z_RAISE_WHEN_OFF_MESH)
-          return UBL_Z_RAISE_WHEN_OFF_MESH;
-        #else
-          return NAN;
-        #endif
+        // The requested location is off the mesh. Return UBL_Z_RAISE_WHEN_OFF_MESH or NAN.
+        return (
+          #ifdef UBL_Z_RAISE_WHEN_OFF_MESH
+            UBL_Z_RAISE_WHEN_OFF_MESH
+          #else
+            NAN
+          #endif
+        );
       }
 
       const float xratio = (rx0 - mesh_index_to_xpos(x1_i)) * (1.0 / (MESH_X_DIST)),
@@ -259,15 +258,14 @@ class unified_bed_leveling {
           }
         #endif
 
-        /**
-         * The requested location is off the mesh.  Check if UBL_Z_RAISE_WHEN_OFF_MESH
-         * is specified. If so, that value is returned.
-         */
-        #if ENABLED(UBL_Z_RAISE_WHEN_OFF_MESH)
-          return UBL_Z_RAISE_WHEN_OFF_MESH;
-        #else
-          return NAN;
-        #endif
+        // The requested location is off the mesh. Return UBL_Z_RAISE_WHEN_OFF_MESH or NAN.
+        return (
+          #ifdef UBL_Z_RAISE_WHEN_OFF_MESH
+            UBL_Z_RAISE_WHEN_OFF_MESH
+          #else
+            NAN
+          #endif
+        );
       }
 
       const float yratio = (ry0 - mesh_index_to_ypos(y1_i)) * (1.0 / (MESH_Y_DIST)),
@@ -292,9 +290,9 @@ class unified_bed_leveling {
        * Check if the requested location is off the mesh.  If so, and
        * UBL_Z_RAISE_WHEN_OFF_MESH is specified, that value is returned.
        */
-      #if ENABLED(UBL_Z_RAISE_WHEN_OFF_MESH)
+      #ifdef UBL_Z_RAISE_WHEN_OFF_MESH
         if (!WITHIN(rx0, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(ry0, 0, GRID_MAX_POINTS_Y - 1))
-          return UBL_Z_RAISE_WHEN_OFF_MESHH;
+          return UBL_Z_RAISE_WHEN_OFF_MESH;
       #endif
 
       const float z1 = calc_z0(rx0,

commit 21e60fd3edd9ea009f1a86db5c06909d59ff1cd0
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Thu Feb 15 15:07:42 2018 -0600

    Allow user to control Z-Height correction for off mesh movements (#9661)

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 090641a053..bc4df7f442 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -223,7 +223,16 @@ class unified_bed_leveling {
             SERIAL_EOL();
           }
         #endif
-        return NAN;
+
+        /**
+         * The requested location is off the mesh.  Check if UBL_Z_RAISE_WHEN_OFF_MESH
+         * is specified. If so, that value is returned.
+         */
+        #if ENABLED(UBL_Z_RAISE_WHEN_OFF_MESH)
+          return UBL_Z_RAISE_WHEN_OFF_MESH;
+        #else
+          return NAN;
+        #endif
       }
 
       const float xratio = (rx0 - mesh_index_to_xpos(x1_i)) * (1.0 / (MESH_X_DIST)),
@@ -249,7 +258,16 @@ class unified_bed_leveling {
             SERIAL_EOL();
           }
         #endif
-        return NAN;
+
+        /**
+         * The requested location is off the mesh.  Check if UBL_Z_RAISE_WHEN_OFF_MESH
+         * is specified. If so, that value is returned.
+         */
+        #if ENABLED(UBL_Z_RAISE_WHEN_OFF_MESH)
+          return UBL_Z_RAISE_WHEN_OFF_MESH;
+        #else
+          return NAN;
+        #endif
       }
 
       const float yratio = (ry0 - mesh_index_to_ypos(y1_i)) * (1.0 / (MESH_Y_DIST)),
@@ -270,6 +288,15 @@ class unified_bed_leveling {
       const int8_t cx = get_cell_index_x(rx0),
                    cy = get_cell_index_y(ry0); // return values are clamped
 
+      /**
+       * Check if the requested location is off the mesh.  If so, and
+       * UBL_Z_RAISE_WHEN_OFF_MESH is specified, that value is returned.
+       */
+      #if ENABLED(UBL_Z_RAISE_WHEN_OFF_MESH)
+        if (!WITHIN(rx0, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(ry0, 0, GRID_MAX_POINTS_Y - 1))
+          return UBL_Z_RAISE_WHEN_OFF_MESHH;
+      #endif
+
       const float z1 = calc_z0(rx0,
                                mesh_index_to_xpos(cx), z_values[cx][cy],
                                mesh_index_to_xpos(cx + 1), z_values[min(cx, GRID_MAX_POINTS_X - 2) + 1][cy]);

commit 89165326b4bc627ee080cd2acd073c0097d80ddd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Feb 11 05:43:03 2018 -0600

    Cleanup after vim and vigor

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 8e86b181b3..090641a053 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -83,7 +83,7 @@ class unified_bed_leveling {
     #if ENABLED(NEWPANEL)
       static void move_z_with_encoder(const float &multiplier);
       static float measure_point_with_encoder();
-      static float measure_business_card_thickness(float);
+      static float measure_business_card_thickness(float in_height);
       static void manually_probe_remaining_mesh(const float&, const float&, const float&, const float&, const bool);
       static void fine_tune_mesh(const float &rx, const float &ry, const bool do_ubl_mesh_map);
     #endif

commit 8a6feab1c405e975a71219faf052f73e0036906e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 5 19:08:27 2018 -0600

    Num-to-string functions for DEBUG_LEVELING_FEATURE

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 9a0f5caf2f..8e86b181b3 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -51,8 +51,6 @@ enum MeshPointType { INVALID, REAL, SET_IN_BITMAP };
 
 // External references
 
-char *ftostr43sign(const float&, char);
-
 extern uint8_t ubl_cnt;
 
 ///////////////////////////////////////////////////////////////////////////////////////////////////////

commit bfd9728cf4c4adb426c926584f42501949ca74c8
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Thu Jan 18 19:57:18 2018 -0600

    Serial buffer over run work around for v2.0.0 (#9236)
    
    * Work around for serial buffer over run
    
    PronterFace sends a lot of M105 commands.  During long operations such
    as UBL's G29 P1, G29 P2, G29 P4 and G26 this can over run the serial
    buffer.   This results (very often) in a M1 (actually a M1M105) ending
    up in the command queue.
    
    Until we figure out a better way to resolve this issue, this will keep
    the UBL commands from experiencing bogus commands at thier completion.

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index b215165e7a..9a0f5caf2f 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -93,7 +93,7 @@ class unified_bed_leveling {
     static bool g29_parameter_parsing();
     static void find_mean_mesh_height();
     static void shift_mesh_height();
-    static void probe_entire_mesh(const float &rx, const float &ry, const bool do_ubl_mesh_map, const bool stow_probe, bool do_furthest);
+    static void probe_entire_mesh(const float &rx, const float &ry, const bool do_ubl_mesh_map, const bool stow_probe, bool do_furthest) _O0;
     static void tilt_mesh_based_on_3pts(const float &z1, const float &z2, const float &z3);
     static void tilt_mesh_based_on_probed_grid(const bool do_ubl_mesh_map);
     static void g29_what_command();
@@ -117,8 +117,8 @@ class unified_bed_leveling {
     static void save_ubl_active_state_and_disable();
     static void restore_ubl_active_state_and_leave();
     static void display_map(const int);
-    static mesh_index_pair find_closest_mesh_point_of_type(const MeshPointType, const float&, const float&, const bool, uint16_t[16]);
-    static mesh_index_pair find_furthest_invalid_mesh_point();
+    static mesh_index_pair find_closest_mesh_point_of_type(const MeshPointType, const float&, const float&, const bool, uint16_t[16]) _O0;
+    static mesh_index_pair find_furthest_invalid_mesh_point() _O0;
     static void reset();
     static void invalidate();
     static void set_all_mesh_points_to_value(const float);

commit f5f1b069ade516793995870bac4d6707cff43407
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Tue Jan 16 11:08:00 2018 -0600

    Convert UBL mesh tilting to all use the same algorithm  (#9204)
    
    A number of regressions were patched also. The UBL G29 P2 and P4 Press and Hold had stopped working. It is very possible this is broken in the bugfix_v1.1.x branch also.
    
    The main purpose of the Pull Request is to get the 3-Point mesh tilting to use the LSF algorithm just like the grid based mesh tilt. This simplifies the logic and reduces the code size some what. But the real reason to do it is the 3-Point case can be solved exactly. And by feeding these numbers into the LSF algorithm it provides a way to check all that code for 'correctness'.

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 82bdbce870..b215165e7a 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -59,7 +59,7 @@ extern uint8_t ubl_cnt;
 
 #if ENABLED(ULTRA_LCD)
   extern char lcd_status_message[];
-  void lcd_quick_feedback();
+  void lcd_quick_feedback(const bool clear_buttons);
 #endif
 
 #define MESH_X_DIST (float(MESH_MAX_X - (MESH_MIN_X)) / float(GRID_MAX_POINTS_X - 1))
@@ -85,7 +85,7 @@ class unified_bed_leveling {
     #if ENABLED(NEWPANEL)
       static void move_z_with_encoder(const float &multiplier);
       static float measure_point_with_encoder();
-      static float measure_business_card_thickness(const float&);
+      static float measure_business_card_thickness(float);
       static void manually_probe_remaining_mesh(const float&, const float&, const float&, const float&, const bool);
       static void fine_tune_mesh(const float &rx, const float &ry, const bool do_ubl_mesh_map);
     #endif

commit f7efac57b7ac607405529a71b4e36a6545525c89
Author: Thomas Moore <tcm0116@gmail.com>
Date:   Sun Nov 5 08:49:38 2017 -0600

    Multi-host support

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 01e93769d3..82bdbce870 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -104,8 +104,16 @@ class unified_bed_leveling {
 
   public:
 
-    static void echo_name();
-    static void report_state();
+    static void echo_name(
+      #if NUM_SERIAL > 1
+        const int8_t port = -1
+      #endif
+    );
+    static void report_state(
+      #if NUM_SERIAL > 1
+        const int8_t port = -1
+      #endif
+    );
     static void save_ubl_active_state_and_disable();
     static void restore_ubl_active_state_and_leave();
     static void display_map(const int);

commit 6d0678d9633057dfc338b127d55026a4a28e119d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Dec 9 07:55:55 2017 -0600

    Omit unused UBL motion code

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index e7adb083df..01e93769d3 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -321,8 +321,11 @@ class unified_bed_leveling {
       return i < GRID_MAX_POINTS_Y ? pgm_read_float(&_mesh_index_to_ypos[i]) : MESH_MIN_Y + i * (MESH_Y_DIST);
     }
 
-    static void line_to_destination_cartesian(const float &fr, const uint8_t e);
-    static bool prepare_segmented_line_to(const float (&rtarget)[XYZE], const float &feedrate);
+    #if UBL_SEGMENTED
+      static bool prepare_segmented_line_to(const float (&rtarget)[XYZE], const float &feedrate);
+    #else
+      static void line_to_destination_cartesian(const float &fr, const uint8_t e);
+    #endif
 
     #define _CMPZ(a,b) (z_values[a][b] == z_values[a][b+1])
     #define CMPZ(a) (_CMPZ(a, 0) && _CMPZ(a, 1))

commit 3255712343fdc9177cc94c86b2c31bf94ffbb8ca
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Dec 9 07:50:55 2017 -0600

    Skew Correction for UBL
    
    Also remove unused grid slicing function when using UBL segmented.

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 1a294d4f75..e7adb083df 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -321,8 +321,8 @@ class unified_bed_leveling {
       return i < GRID_MAX_POINTS_Y ? pgm_read_float(&_mesh_index_to_ypos[i]) : MESH_MIN_Y + i * (MESH_Y_DIST);
     }
 
-    static bool prepare_segmented_line_to(const float rtarget[XYZE], const float &feedrate);
     static void line_to_destination_cartesian(const float &fr, const uint8_t e);
+    static bool prepare_segmented_line_to(const float (&rtarget)[XYZE], const float &feedrate);
 
     #define _CMPZ(a,b) (z_values[a][b] == z_values[a][b+1])
     #define CMPZ(a) (_CMPZ(a, 0) && _CMPZ(a, 1))

commit 3d796d80404896dde4d1360859b6b2def158547a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Dec 9 07:14:06 2017 -0600

    Move debug code

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index f970b07f5b..1a294d4f75 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -23,6 +23,8 @@
 #ifndef UNIFIED_BED_LEVELING_H
 #define UNIFIED_BED_LEVELING_H
 
+//#define UBL_DEVEL_DEBUGGING
+
 #include "../bedlevel.h"
 #include "../../../module/planner.h"
 #include "../../../module/motion.h"
@@ -37,7 +39,11 @@
 
 // ubl_motion.cpp
 
-void debug_current_and_destination(const char * const title);
+#if ENABLED(UBL_DEVEL_DEBUGGING)
+  void debug_current_and_destination(const char * const title);
+#else
+  FORCE_INLINE void debug_current_and_destination(const char * const title) { UNUSED(title); }
+#endif
 
 // ubl_G29.cpp
 
@@ -217,9 +223,9 @@ class unified_bed_leveling {
       const float xratio = (rx0 - mesh_index_to_xpos(x1_i)) * (1.0 / (MESH_X_DIST)),
                   z1 = z_values[x1_i][yi];
 
-      return z1 + xratio * (z_values[min(x1_i, GRID_MAX_POINTS_X - 2) + 1][yi] - z1);  // Don't allow x1_i+1 to be past the end of the array
-                                                                                       // If it is, it is clamped to the last element of the 
-                                                                                       // z_values[][] array and no correction is applied.
+      return z1 + xratio * (z_values[min(x1_i, GRID_MAX_POINTS_X - 2) + 1][yi] - z1); // Don't allow x1_i+1 to be past the end of the array
+                                                                                      // If it is, it is clamped to the last element of the
+                                                                                      // z_values[][] array and no correction is applied.
     }
 
     //
@@ -243,9 +249,9 @@ class unified_bed_leveling {
       const float yratio = (ry0 - mesh_index_to_ypos(y1_i)) * (1.0 / (MESH_Y_DIST)),
                   z1 = z_values[xi][y1_i];
 
-      return z1 + yratio * (z_values[xi][min(y1_i, GRID_MAX_POINTS_Y - 2) + 1] - z1);  // Don't allow y1_i+1 to be past the end of the array
-                                                                                       // If it is, it is clamped to the last element of the 
-                                                                                       // z_values[][] array and no correction is applied.
+      return z1 + yratio * (z_values[xi][min(y1_i, GRID_MAX_POINTS_Y - 2) + 1] - z1); // Don't allow y1_i+1 to be past the end of the array
+                                                                                      // If it is, it is clamped to the last element of the
+                                                                                      // z_values[][] array and no correction is applied.
     }
 
     /**

commit 73e32925e4b140fe23f62eeb658f807e4477d872
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Dec 9 02:10:54 2017 -0600

    References are better for array args

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index d371c1a64a..f970b07f5b 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -316,7 +316,7 @@ class unified_bed_leveling {
     }
 
     static bool prepare_segmented_line_to(const float rtarget[XYZE], const float &feedrate);
-    static void line_to_destination_cartesian(const float &fr, uint8_t e);
+    static void line_to_destination_cartesian(const float &fr, const uint8_t e);
 
     #define _CMPZ(a,b) (z_values[a][b] == z_values[a][b+1])
     #define CMPZ(a) (_CMPZ(a, 0) && _CMPZ(a, 1))

commit f58eb391aabaaa99199bd7f96cff8ff7e0da95ab
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Fri Dec 8 19:00:59 2017 -0600

    [2.0.0] Better off mesh behavior for UBL (#8714)
    
    * Better off mesh behaviour for UBL
    
    * Suggested ubl.h changes

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 20c469780b..d371c1a64a 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -200,10 +200,10 @@ class unified_bed_leveling {
      * the case where the printer is making a vertical line that only crosses horizontal mesh lines.
      */
     inline static float z_correction_for_x_on_horizontal_mesh_line(const float &rx0, const int x1_i, const int yi) {
-      if (!WITHIN(x1_i, 0, GRID_MAX_POINTS_X - 2) || !WITHIN(yi, 0, GRID_MAX_POINTS_Y - 1)) {
+      if (!WITHIN(x1_i, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(yi, 0, GRID_MAX_POINTS_Y - 1)) {
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING)) {
-            serialprintPGM( !WITHIN(x1_i, 0, GRID_MAX_POINTS_X - 1) ? PSTR("x1l_i") : PSTR("yi") );
+            serialprintPGM( !WITHIN(x1_i, 0, GRID_MAX_POINTS_X - 1) ? PSTR("x1_i") : PSTR("yi") );
             SERIAL_ECHOPAIR(" out of bounds in z_correction_for_x_on_horizontal_mesh_line(rx0=", rx0);
             SERIAL_ECHOPAIR(",x1_i=", x1_i);
             SERIAL_ECHOPAIR(",yi=", yi);
@@ -217,17 +217,19 @@ class unified_bed_leveling {
       const float xratio = (rx0 - mesh_index_to_xpos(x1_i)) * (1.0 / (MESH_X_DIST)),
                   z1 = z_values[x1_i][yi];
 
-      return z1 + xratio * (z_values[x1_i + 1][yi] - z1);
+      return z1 + xratio * (z_values[min(x1_i, GRID_MAX_POINTS_X - 2) + 1][yi] - z1);  // Don't allow x1_i+1 to be past the end of the array
+                                                                                       // If it is, it is clamped to the last element of the 
+                                                                                       // z_values[][] array and no correction is applied.
     }
 
     //
     // See comments above for z_correction_for_x_on_horizontal_mesh_line
     //
     inline static float z_correction_for_y_on_vertical_mesh_line(const float &ry0, const int xi, const int y1_i) {
-      if (!WITHIN(xi, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(y1_i, 0, GRID_MAX_POINTS_Y - 2)) {
+      if (!WITHIN(xi, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(y1_i, 0, GRID_MAX_POINTS_Y - 1)) {
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING)) {
-            serialprintPGM( !WITHIN(xi, 0, GRID_MAX_POINTS_X - 1) ? PSTR("xi") : PSTR("yl_i") );
+            serialprintPGM( !WITHIN(xi, 0, GRID_MAX_POINTS_X - 1) ? PSTR("xi") : PSTR("y1_i") );
             SERIAL_ECHOPAIR(" out of bounds in z_correction_for_y_on_vertical_mesh_line(ry0=", ry0);
             SERIAL_ECHOPAIR(", xi=", xi);
             SERIAL_ECHOPAIR(", y1_i=", y1_i);
@@ -241,7 +243,9 @@ class unified_bed_leveling {
       const float yratio = (ry0 - mesh_index_to_ypos(y1_i)) * (1.0 / (MESH_Y_DIST)),
                   z1 = z_values[xi][y1_i];
 
-      return z1 + yratio * (z_values[xi][y1_i + 1] - z1);
+      return z1 + yratio * (z_values[xi][min(y1_i, GRID_MAX_POINTS_Y - 2) + 1] - z1);  // Don't allow y1_i+1 to be past the end of the array
+                                                                                       // If it is, it is clamped to the last element of the 
+                                                                                       // z_values[][] array and no correction is applied.
     }
 
     /**
@@ -252,29 +256,15 @@ class unified_bed_leveling {
      */
     static float get_z_correction(const float &rx0, const float &ry0) {
       const int8_t cx = get_cell_index_x(rx0),
-                   cy = get_cell_index_y(ry0);
-
-      if (!WITHIN(cx, 0, GRID_MAX_POINTS_X - 2) || !WITHIN(cy, 0, GRID_MAX_POINTS_Y - 2)) {
-
-        SERIAL_ECHOPAIR("? in get_z_correction(rx0=", rx0);
-        SERIAL_ECHOPAIR(", ry0=", ry0);
-        SERIAL_CHAR(')');
-        SERIAL_EOL();
-
-        #if ENABLED(ULTRA_LCD)
-          strcpy(lcd_status_message, "get_z_correction() indexes out of range.");
-          lcd_quick_feedback();
-        #endif
-        return NAN;
-      }
+                   cy = get_cell_index_y(ry0); // return values are clamped
 
       const float z1 = calc_z0(rx0,
                                mesh_index_to_xpos(cx), z_values[cx][cy],
-                               mesh_index_to_xpos(cx + 1), z_values[cx + 1][cy]);
+                               mesh_index_to_xpos(cx + 1), z_values[min(cx, GRID_MAX_POINTS_X - 2) + 1][cy]);
 
       const float z2 = calc_z0(rx0,
-                               mesh_index_to_xpos(cx), z_values[cx][cy + 1],
-                               mesh_index_to_xpos(cx + 1), z_values[cx + 1][cy + 1]);
+                               mesh_index_to_xpos(cx), z_values[cx][min(cy, GRID_MAX_POINTS_Y - 2) + 1],
+                               mesh_index_to_xpos(cx + 1), z_values[min(cx, GRID_MAX_POINTS_X - 2) + 1][min(cy, GRID_MAX_POINTS_Y - 2) + 1]);
 
       float z0 = calc_z0(ry0,
                          mesh_index_to_ypos(cy), z1,

commit 2fde60da124fddb6cf2a8f15479680f3410b53af
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Dec 6 16:56:30 2017 -0600

    Changes for parity with 1.1.x

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index bfebeae967..20c469780b 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -76,19 +76,23 @@ class unified_bed_leveling {
       static int  g29_grid_size;
     #endif
 
-    static float measure_point_with_encoder();
-    static float measure_business_card_thickness(float);
+    #if ENABLED(NEWPANEL)
+      static void move_z_with_encoder(const float &multiplier);
+      static float measure_point_with_encoder();
+      static float measure_business_card_thickness(const float&);
+      static void manually_probe_remaining_mesh(const float&, const float&, const float&, const float&, const bool);
+      static void fine_tune_mesh(const float &rx, const float &ry, const bool do_ubl_mesh_map);
+    #endif
+
     static bool g29_parameter_parsing();
     static void find_mean_mesh_height();
     static void shift_mesh_height();
     static void probe_entire_mesh(const float &rx, const float &ry, const bool do_ubl_mesh_map, const bool stow_probe, bool do_furthest);
-    static void manually_probe_remaining_mesh(const float&, const float&, const float&, const float&, const bool);
     static void tilt_mesh_based_on_3pts(const float &z1, const float &z2, const float &z3);
     static void tilt_mesh_based_on_probed_grid(const bool do_ubl_mesh_map);
     static void g29_what_command();
     static void g29_eeprom_dump();
     static void g29_compare_current_mesh_to_stored_mesh();
-    static void fine_tune_mesh(const float &rx, const float &ry, const bool do_ubl_mesh_map);
     static bool smart_fill_one(const uint8_t x, const uint8_t y, const int8_t xdir, const int8_t ydir);
     static void smart_fill_mesh();
 
@@ -137,7 +141,7 @@ class unified_bed_leveling {
                               MESH_MIN_Y + 14 * (MESH_Y_DIST), MESH_MIN_Y + 15 * (MESH_Y_DIST)
                             };
 
-    #if ENABLED(ULTRA_LCD)
+    #if ENABLED(ULTIPANEL)
       static bool lcd_map_control;
     #endif
 

commit c6b0c104bbab04d4d59c4f3f8fddb728e9b99603
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 23 17:59:43 2017 -0600

    Adapt G26 to work for all meshes

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index fa7aa65a34..bfebeae967 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -23,9 +23,10 @@
 #ifndef UNIFIED_BED_LEVELING_H
 #define UNIFIED_BED_LEVELING_H
 
-#include "../../../Marlin.h"
+#include "../bedlevel.h"
 #include "../../../module/planner.h"
 #include "../../../module/motion.h"
+#include "../../../Marlin.h"
 
 #define UBL_VERSION "1.01"
 #define UBL_OK false
@@ -34,17 +35,6 @@
 #define USE_NOZZLE_AS_REFERENCE 0
 #define USE_PROBE_AS_REFERENCE 1
 
-typedef struct {
-  int8_t x_index, y_index;
-  float distance; // When populated, the distance from the search location
-} mesh_index_pair;
-
-// ubl.cpp
-
-void bit_clear(uint16_t bits[16], const uint8_t x, const uint8_t y);
-void bit_set(uint16_t bits[16], const uint8_t x, const uint8_t y);
-bool is_bit_set(uint16_t bits[16], const uint8_t x, const uint8_t y);
-
 // ubl_motion.cpp
 
 void debug_current_and_destination(const char * const title);
@@ -56,7 +46,6 @@ enum MeshPointType { INVALID, REAL, SET_IN_BITMAP };
 // External references
 
 char *ftostr43sign(const float&, char);
-bool ubl_lcd_clicked();
 
 extern uint8_t ubl_cnt;
 
@@ -87,22 +76,6 @@ class unified_bed_leveling {
       static int  g29_grid_size;
     #endif
 
-    #if ENABLED(UBL_G26_MESH_VALIDATION)
-      static float   g26_extrusion_multiplier,
-                     g26_retraction_multiplier,
-                     g26_nozzle,
-                     g26_filament_diameter,
-                     g26_prime_length,
-                     g26_x_pos, g26_y_pos,
-                     g26_ooze_amount,
-                     g26_layer_height;
-      static int16_t g26_bed_temp,
-                     g26_hotend_temp,
-                     g26_repeats;
-      static int8_t  g26_prime_flag;
-      static bool    g26_continue_with_closest, g26_keep_heaters_on;
-    #endif
-
     static float measure_point_with_encoder();
     static float measure_business_card_thickness(float);
     static bool g29_parameter_parsing();
@@ -119,21 +92,6 @@ class unified_bed_leveling {
     static bool smart_fill_one(const uint8_t x, const uint8_t y, const int8_t xdir, const int8_t ydir);
     static void smart_fill_mesh();
 
-    #if ENABLED(UBL_G26_MESH_VALIDATION)
-      static bool exit_from_g26();
-      static bool parse_G26_parameters();
-      static void G26_line_to_destination(const float &feed_rate);
-      static mesh_index_pair find_closest_circle_to_print(const float&, const float&);
-      static bool look_for_lines_to_connect();
-      static bool turn_on_heaters();
-      static bool prime_nozzle();
-      static void retract_filament(const float where[XYZE]);
-      static void recover_filament(const float where[XYZE]);
-      static void print_line_from_here_to_there(const float&, const float&, const float&, const float&, const float&, const float&);
-      static void move_to(const float&, const float&, const float&, const float&);
-      inline static void move_to(const float where[XYZE], const float &de) { move_to(where[X_AXIS], where[Y_AXIS], where[Z_AXIS], de); }
-    #endif
-
   public:
 
     static void echo_name();
@@ -151,10 +109,6 @@ class unified_bed_leveling {
     static void G29() _O0;                          // O0 for no optimization
     static void smart_fill_wlsf(const float &) _O2; // O2 gives smaller code than Os on A2560
 
-    #if ENABLED(UBL_G26_MESH_VALIDATION)
-      static void G26();
-    #endif
-
     static int8_t storage_slot;
 
     static float z_values[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
@@ -183,8 +137,6 @@ class unified_bed_leveling {
                               MESH_MIN_Y + 14 * (MESH_Y_DIST), MESH_MIN_Y + 15 * (MESH_Y_DIST)
                             };
 
-    static bool g26_debug_flag, has_control_of_lcd_panel;
-
     #if ENABLED(ULTRA_LCD)
       static bool lcd_map_control;
     #endif

commit f8393a09086f01eafbb8563411da3b237c96b982
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 2 23:59:42 2017 -0500

    Operate in Native Machine Space

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 6709a8f1bc..fa7aa65a34 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -108,14 +108,14 @@ class unified_bed_leveling {
     static bool g29_parameter_parsing();
     static void find_mean_mesh_height();
     static void shift_mesh_height();
-    static void probe_entire_mesh(const float &lx, const float &ly, const bool do_ubl_mesh_map, const bool stow_probe, bool do_furthest);
+    static void probe_entire_mesh(const float &rx, const float &ry, const bool do_ubl_mesh_map, const bool stow_probe, bool do_furthest);
     static void manually_probe_remaining_mesh(const float&, const float&, const float&, const float&, const bool);
     static void tilt_mesh_based_on_3pts(const float &z1, const float &z2, const float &z3);
     static void tilt_mesh_based_on_probed_grid(const bool do_ubl_mesh_map);
     static void g29_what_command();
     static void g29_eeprom_dump();
     static void g29_compare_current_mesh_to_stored_mesh();
-    static void fine_tune_mesh(const float &lx, const float &ly, const bool do_ubl_mesh_map);
+    static void fine_tune_mesh(const float &rx, const float &ry, const bool do_ubl_mesh_map);
     static bool smart_fill_one(const uint8_t x, const uint8_t y, const int8_t xdir, const int8_t ydir);
     static void smart_fill_mesh();
 
@@ -243,12 +243,12 @@ class unified_bed_leveling {
      * z_correction_for_x_on_horizontal_mesh_line is an optimization for
      * the case where the printer is making a vertical line that only crosses horizontal mesh lines.
      */
-    inline static float z_correction_for_x_on_horizontal_mesh_line(const float &lx0, const int x1_i, const int yi) {
+    inline static float z_correction_for_x_on_horizontal_mesh_line(const float &rx0, const int x1_i, const int yi) {
       if (!WITHIN(x1_i, 0, GRID_MAX_POINTS_X - 2) || !WITHIN(yi, 0, GRID_MAX_POINTS_Y - 1)) {
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING)) {
             serialprintPGM( !WITHIN(x1_i, 0, GRID_MAX_POINTS_X - 1) ? PSTR("x1l_i") : PSTR("yi") );
-            SERIAL_ECHOPAIR(" out of bounds in z_correction_for_x_on_horizontal_mesh_line(lx0=", lx0);
+            SERIAL_ECHOPAIR(" out of bounds in z_correction_for_x_on_horizontal_mesh_line(rx0=", rx0);
             SERIAL_ECHOPAIR(",x1_i=", x1_i);
             SERIAL_ECHOPAIR(",yi=", yi);
             SERIAL_CHAR(')');
@@ -258,7 +258,7 @@ class unified_bed_leveling {
         return NAN;
       }
 
-      const float xratio = (RAW_X_POSITION(lx0) - mesh_index_to_xpos(x1_i)) * (1.0 / (MESH_X_DIST)),
+      const float xratio = (rx0 - mesh_index_to_xpos(x1_i)) * (1.0 / (MESH_X_DIST)),
                   z1 = z_values[x1_i][yi];
 
       return z1 + xratio * (z_values[x1_i + 1][yi] - z1);
@@ -267,12 +267,12 @@ class unified_bed_leveling {
     //
     // See comments above for z_correction_for_x_on_horizontal_mesh_line
     //
-    inline static float z_correction_for_y_on_vertical_mesh_line(const float &ly0, const int xi, const int y1_i) {
+    inline static float z_correction_for_y_on_vertical_mesh_line(const float &ry0, const int xi, const int y1_i) {
       if (!WITHIN(xi, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(y1_i, 0, GRID_MAX_POINTS_Y - 2)) {
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(LEVELING)) {
             serialprintPGM( !WITHIN(xi, 0, GRID_MAX_POINTS_X - 1) ? PSTR("xi") : PSTR("yl_i") );
-            SERIAL_ECHOPAIR(" out of bounds in z_correction_for_y_on_vertical_mesh_line(ly0=", ly0);
+            SERIAL_ECHOPAIR(" out of bounds in z_correction_for_y_on_vertical_mesh_line(ry0=", ry0);
             SERIAL_ECHOPAIR(", xi=", xi);
             SERIAL_ECHOPAIR(", y1_i=", y1_i);
             SERIAL_CHAR(')');
@@ -282,7 +282,7 @@ class unified_bed_leveling {
         return NAN;
       }
 
-      const float yratio = (RAW_Y_POSITION(ly0) - mesh_index_to_ypos(y1_i)) * (1.0 / (MESH_Y_DIST)),
+      const float yratio = (ry0 - mesh_index_to_ypos(y1_i)) * (1.0 / (MESH_Y_DIST)),
                   z1 = z_values[xi][y1_i];
 
       return z1 + yratio * (z_values[xi][y1_i + 1] - z1);
@@ -294,14 +294,14 @@ class unified_bed_leveling {
      * Z-Height at both ends. Then it does a linear interpolation of these heights based
      * on the Y position within the cell.
      */
-    static float get_z_correction(const float &lx0, const float &ly0) {
-      const int8_t cx = get_cell_index_x(RAW_X_POSITION(lx0)),
-                   cy = get_cell_index_y(RAW_Y_POSITION(ly0));
+    static float get_z_correction(const float &rx0, const float &ry0) {
+      const int8_t cx = get_cell_index_x(rx0),
+                   cy = get_cell_index_y(ry0);
 
       if (!WITHIN(cx, 0, GRID_MAX_POINTS_X - 2) || !WITHIN(cy, 0, GRID_MAX_POINTS_Y - 2)) {
 
-        SERIAL_ECHOPAIR("? in get_z_correction(lx0=", lx0);
-        SERIAL_ECHOPAIR(", ly0=", ly0);
+        SERIAL_ECHOPAIR("? in get_z_correction(rx0=", rx0);
+        SERIAL_ECHOPAIR(", ry0=", ry0);
         SERIAL_CHAR(')');
         SERIAL_EOL();
 
@@ -312,23 +312,23 @@ class unified_bed_leveling {
         return NAN;
       }
 
-      const float z1 = calc_z0(RAW_X_POSITION(lx0),
+      const float z1 = calc_z0(rx0,
                                mesh_index_to_xpos(cx), z_values[cx][cy],
                                mesh_index_to_xpos(cx + 1), z_values[cx + 1][cy]);
 
-      const float z2 = calc_z0(RAW_X_POSITION(lx0),
+      const float z2 = calc_z0(rx0,
                                mesh_index_to_xpos(cx), z_values[cx][cy + 1],
                                mesh_index_to_xpos(cx + 1), z_values[cx + 1][cy + 1]);
 
-      float z0 = calc_z0(RAW_Y_POSITION(ly0),
+      float z0 = calc_z0(ry0,
                          mesh_index_to_ypos(cy), z1,
                          mesh_index_to_ypos(cy + 1), z2);
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         if (DEBUGGING(MESH_ADJUST)) {
-          SERIAL_ECHOPAIR(" raw get_z_correction(", lx0);
+          SERIAL_ECHOPAIR(" raw get_z_correction(", rx0);
           SERIAL_CHAR(',');
-          SERIAL_ECHO(ly0);
+          SERIAL_ECHO(ry0);
           SERIAL_ECHOPGM(") = ");
           SERIAL_ECHO_F(z0, 6);
         }
@@ -350,9 +350,9 @@ class unified_bed_leveling {
 
         #if ENABLED(DEBUG_LEVELING_FEATURE)
           if (DEBUGGING(MESH_ADJUST)) {
-            SERIAL_ECHOPAIR("??? Yikes!  NAN in get_z_correction(", lx0);
+            SERIAL_ECHOPAIR("??? Yikes!  NAN in get_z_correction(", rx0);
             SERIAL_CHAR(',');
-            SERIAL_ECHO(ly0);
+            SERIAL_ECHO(ry0);
             SERIAL_CHAR(')');
             SERIAL_EOL();
           }
@@ -369,7 +369,7 @@ class unified_bed_leveling {
       return i < GRID_MAX_POINTS_Y ? pgm_read_float(&_mesh_index_to_ypos[i]) : MESH_MIN_Y + i * (MESH_Y_DIST);
     }
 
-    static bool prepare_segmented_line_to(const float ltarget[XYZE], const float &feedrate);
+    static bool prepare_segmented_line_to(const float rtarget[XYZE], const float &feedrate);
     static void line_to_destination_cartesian(const float &fr, uint8_t e);
 
     #define _CMPZ(a,b) (z_values[a][b] == z_values[a][b+1])

commit 580b6e9089cefa7cf85c33ef53af4d02a6b59f37
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Oct 19 01:39:39 2017 -0500

    Apply physical limits to mesh bounds

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 20333895f4..6709a8f1bc 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -67,8 +67,8 @@ extern uint8_t ubl_cnt;
   void lcd_quick_feedback();
 #endif
 
-#define MESH_X_DIST (float(UBL_MESH_MAX_X - (UBL_MESH_MIN_X)) / float(GRID_MAX_POINTS_X - 1))
-#define MESH_Y_DIST (float(UBL_MESH_MAX_Y - (UBL_MESH_MIN_Y)) / float(GRID_MAX_POINTS_Y - 1))
+#define MESH_X_DIST (float(MESH_MAX_X - (MESH_MIN_X)) / float(GRID_MAX_POINTS_X - 1))
+#define MESH_Y_DIST (float(MESH_MAX_Y - (MESH_MIN_Y)) / float(GRID_MAX_POINTS_Y - 1))
 
 class unified_bed_leveling {
   private:
@@ -162,25 +162,25 @@ class unified_bed_leveling {
     // 15 is the maximum nubmer of grid points supported + 1 safety margin for now,
     // until determinism prevails
     constexpr static float _mesh_index_to_xpos[16] PROGMEM = {
-                              UBL_MESH_MIN_X +  0 * (MESH_X_DIST), UBL_MESH_MIN_X +  1 * (MESH_X_DIST),
-                              UBL_MESH_MIN_X +  2 * (MESH_X_DIST), UBL_MESH_MIN_X +  3 * (MESH_X_DIST),
-                              UBL_MESH_MIN_X +  4 * (MESH_X_DIST), UBL_MESH_MIN_X +  5 * (MESH_X_DIST),
-                              UBL_MESH_MIN_X +  6 * (MESH_X_DIST), UBL_MESH_MIN_X +  7 * (MESH_X_DIST),
-                              UBL_MESH_MIN_X +  8 * (MESH_X_DIST), UBL_MESH_MIN_X +  9 * (MESH_X_DIST),
-                              UBL_MESH_MIN_X + 10 * (MESH_X_DIST), UBL_MESH_MIN_X + 11 * (MESH_X_DIST),
-                              UBL_MESH_MIN_X + 12 * (MESH_X_DIST), UBL_MESH_MIN_X + 13 * (MESH_X_DIST),
-                              UBL_MESH_MIN_X + 14 * (MESH_X_DIST), UBL_MESH_MIN_X + 15 * (MESH_X_DIST)
+                              MESH_MIN_X +  0 * (MESH_X_DIST), MESH_MIN_X +  1 * (MESH_X_DIST),
+                              MESH_MIN_X +  2 * (MESH_X_DIST), MESH_MIN_X +  3 * (MESH_X_DIST),
+                              MESH_MIN_X +  4 * (MESH_X_DIST), MESH_MIN_X +  5 * (MESH_X_DIST),
+                              MESH_MIN_X +  6 * (MESH_X_DIST), MESH_MIN_X +  7 * (MESH_X_DIST),
+                              MESH_MIN_X +  8 * (MESH_X_DIST), MESH_MIN_X +  9 * (MESH_X_DIST),
+                              MESH_MIN_X + 10 * (MESH_X_DIST), MESH_MIN_X + 11 * (MESH_X_DIST),
+                              MESH_MIN_X + 12 * (MESH_X_DIST), MESH_MIN_X + 13 * (MESH_X_DIST),
+                              MESH_MIN_X + 14 * (MESH_X_DIST), MESH_MIN_X + 15 * (MESH_X_DIST)
                             };
 
     constexpr static float _mesh_index_to_ypos[16] PROGMEM = {
-                              UBL_MESH_MIN_Y +  0 * (MESH_Y_DIST), UBL_MESH_MIN_Y +  1 * (MESH_Y_DIST),
-                              UBL_MESH_MIN_Y +  2 * (MESH_Y_DIST), UBL_MESH_MIN_Y +  3 * (MESH_Y_DIST),
-                              UBL_MESH_MIN_Y +  4 * (MESH_Y_DIST), UBL_MESH_MIN_Y +  5 * (MESH_Y_DIST),
-                              UBL_MESH_MIN_Y +  6 * (MESH_Y_DIST), UBL_MESH_MIN_Y +  7 * (MESH_Y_DIST),
-                              UBL_MESH_MIN_Y +  8 * (MESH_Y_DIST), UBL_MESH_MIN_Y +  9 * (MESH_Y_DIST),
-                              UBL_MESH_MIN_Y + 10 * (MESH_Y_DIST), UBL_MESH_MIN_Y + 11 * (MESH_Y_DIST),
-                              UBL_MESH_MIN_Y + 12 * (MESH_Y_DIST), UBL_MESH_MIN_Y + 13 * (MESH_Y_DIST),
-                              UBL_MESH_MIN_Y + 14 * (MESH_Y_DIST), UBL_MESH_MIN_Y + 15 * (MESH_Y_DIST)
+                              MESH_MIN_Y +  0 * (MESH_Y_DIST), MESH_MIN_Y +  1 * (MESH_Y_DIST),
+                              MESH_MIN_Y +  2 * (MESH_Y_DIST), MESH_MIN_Y +  3 * (MESH_Y_DIST),
+                              MESH_MIN_Y +  4 * (MESH_Y_DIST), MESH_MIN_Y +  5 * (MESH_Y_DIST),
+                              MESH_MIN_Y +  6 * (MESH_Y_DIST), MESH_MIN_Y +  7 * (MESH_Y_DIST),
+                              MESH_MIN_Y +  8 * (MESH_Y_DIST), MESH_MIN_Y +  9 * (MESH_Y_DIST),
+                              MESH_MIN_Y + 10 * (MESH_Y_DIST), MESH_MIN_Y + 11 * (MESH_Y_DIST),
+                              MESH_MIN_Y + 12 * (MESH_Y_DIST), MESH_MIN_Y + 13 * (MESH_Y_DIST),
+                              MESH_MIN_Y + 14 * (MESH_Y_DIST), MESH_MIN_Y + 15 * (MESH_Y_DIST)
                             };
 
     static bool g26_debug_flag, has_control_of_lcd_panel;
@@ -196,14 +196,14 @@ class unified_bed_leveling {
     FORCE_INLINE static void set_z(const int8_t px, const int8_t py, const float &z) { z_values[px][py] = z; }
 
     static int8_t get_cell_index_x(const float &x) {
-      const int8_t cx = (x - (UBL_MESH_MIN_X)) * (1.0 / (MESH_X_DIST));
+      const int8_t cx = (x - (MESH_MIN_X)) * (1.0 / (MESH_X_DIST));
       return constrain(cx, 0, (GRID_MAX_POINTS_X) - 1);   // -1 is appropriate if we want all movement to the X_MAX
     }                                                     // position. But with this defined this way, it is possible
                                                           // to extrapolate off of this point even further out. Probably
                                                           // that is OK because something else should be keeping that from
                                                           // happening and should not be worried about at this level.
     static int8_t get_cell_index_y(const float &y) {
-      const int8_t cy = (y - (UBL_MESH_MIN_Y)) * (1.0 / (MESH_Y_DIST));
+      const int8_t cy = (y - (MESH_MIN_Y)) * (1.0 / (MESH_Y_DIST));
       return constrain(cy, 0, (GRID_MAX_POINTS_Y) - 1);   // -1 is appropriate if we want all movement to the Y_MAX
     }                                                     // position. But with this defined this way, it is possible
                                                           // to extrapolate off of this point even further out. Probably
@@ -211,12 +211,12 @@ class unified_bed_leveling {
                                                           // happening and should not be worried about at this level.
 
     static int8_t find_closest_x_index(const float &x) {
-      const int8_t px = (x - (UBL_MESH_MIN_X) + (MESH_X_DIST) * 0.5) * (1.0 / (MESH_X_DIST));
+      const int8_t px = (x - (MESH_MIN_X) + (MESH_X_DIST) * 0.5) * (1.0 / (MESH_X_DIST));
       return WITHIN(px, 0, GRID_MAX_POINTS_X - 1) ? px : -1;
     }
 
     static int8_t find_closest_y_index(const float &y) {
-      const int8_t py = (y - (UBL_MESH_MIN_Y) + (MESH_Y_DIST) * 0.5) * (1.0 / (MESH_Y_DIST));
+      const int8_t py = (y - (MESH_MIN_Y) + (MESH_Y_DIST) * 0.5) * (1.0 / (MESH_Y_DIST));
       return WITHIN(py, 0, GRID_MAX_POINTS_Y - 1) ? py : -1;
     }
 
@@ -362,11 +362,11 @@ class unified_bed_leveling {
     }
 
     FORCE_INLINE static float mesh_index_to_xpos(const uint8_t i) {
-      return i < GRID_MAX_POINTS_X ? pgm_read_float(&_mesh_index_to_xpos[i]) : UBL_MESH_MIN_X + i * (MESH_X_DIST);
+      return i < GRID_MAX_POINTS_X ? pgm_read_float(&_mesh_index_to_xpos[i]) : MESH_MIN_X + i * (MESH_X_DIST);
     }
 
     FORCE_INLINE static float mesh_index_to_ypos(const uint8_t i) {
-      return i < GRID_MAX_POINTS_Y ? pgm_read_float(&_mesh_index_to_ypos[i]) : UBL_MESH_MIN_Y + i * (MESH_Y_DIST);
+      return i < GRID_MAX_POINTS_Y ? pgm_read_float(&_mesh_index_to_ypos[i]) : MESH_MIN_Y + i * (MESH_Y_DIST);
     }
 
     static bool prepare_segmented_line_to(const float ltarget[XYZE], const float &feedrate);

commit 543935828134831a3129247fcfcf3cb071048011
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Thu Oct 19 10:44:45 2017 -0500

    Basic UBL operations working on 32-bit platforms (#8024)
    
    * 32-bit work for UBL
    
    * Update FT i3-2020 reference file

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 050a2dd664..20333895f4 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -141,7 +141,8 @@ class unified_bed_leveling {
     static void save_ubl_active_state_and_disable();
     static void restore_ubl_active_state_and_leave();
     static void display_map(const int);
-    static mesh_index_pair find_closest_mesh_point_of_type(const MeshPointType, const float&, const float&, const bool, uint16_t[16], bool);
+    static mesh_index_pair find_closest_mesh_point_of_type(const MeshPointType, const float&, const float&, const bool, uint16_t[16]);
+    static mesh_index_pair find_furthest_invalid_mesh_point();
     static void reset();
     static void invalidate();
     static void set_all_mesh_points_to_value(const float);

commit 1344ca4b2fa6c9dea4e6ea257908302add185018
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 13 21:56:27 2017 -0500

    UBL no longer needs ubl_state

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 19bc8633e9..050a2dd664 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -70,16 +70,9 @@ extern uint8_t ubl_cnt;
 #define MESH_X_DIST (float(UBL_MESH_MAX_X - (UBL_MESH_MIN_X)) / float(GRID_MAX_POINTS_X - 1))
 #define MESH_Y_DIST (float(UBL_MESH_MAX_Y - (UBL_MESH_MIN_Y)) / float(GRID_MAX_POINTS_Y - 1))
 
-typedef struct {
-  bool active = false;
-  int8_t storage_slot = -1;
-} ubl_state;
-
 class unified_bed_leveling {
   private:
 
-    static float last_specified_z;
-
     static int    g29_verbose_level,
                   g29_phase_value,
                   g29_repetition_cnt,
@@ -161,7 +154,7 @@ class unified_bed_leveling {
       static void G26();
     #endif
 
-    static ubl_state state;
+    static int8_t storage_slot;
 
     static float z_values[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
 

commit ca1e47375c71e6ddd4973a63a7a8cbf125a439bd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 13 10:39:11 2017 -0500

    Move fade_scaling_factor_for_z to Planner

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 1a83d7f17b..19bc8633e9 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -367,31 +367,6 @@ class unified_bed_leveling {
       return z0;
     }
 
-    /**
-     * This function sets the Z leveling fade factor based on the given Z height,
-     * only re-calculating when necessary.
-     *
-     *  Returns 1.0 if planner.z_fade_height is 0.0.
-     *  Returns 0.0 if Z is past the specified 'Fade Height'.
-     */
-    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
-      static inline float fade_scaling_factor_for_z(const float &lz) {
-        if (planner.z_fade_height == 0.0) return 1.0;
-        static float fade_scaling_factor = 1.0;
-        const float rz = RAW_Z_POSITION(lz);
-        if (last_specified_z != rz) {
-          last_specified_z = rz;
-          fade_scaling_factor =
-            rz < planner.z_fade_height
-              ? 1.0 - (rz * planner.inverse_z_fade_height)
-              : 0.0;
-        }
-        return fade_scaling_factor;
-      }
-    #else
-      FORCE_INLINE static float fade_scaling_factor_for_z(const float &lz) { return 1.0; }
-    #endif
-
     FORCE_INLINE static float mesh_index_to_xpos(const uint8_t i) {
       return i < GRID_MAX_POINTS_X ? pgm_read_float(&_mesh_index_to_xpos[i]) : UBL_MESH_MIN_X + i * (MESH_X_DIST);
     }

commit 1adb5a6a4800e65e04cef5833dc1cf21c7e13c2e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Oct 12 22:20:02 2017 -0500

    Remove obsolete UBL z_offset

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 8791415a46..1a83d7f17b 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -72,7 +72,6 @@ extern uint8_t ubl_cnt;
 
 typedef struct {
   bool active = false;
-  float z_offset = 0.0;
   int8_t storage_slot = -1;
 } ubl_state;
 
@@ -152,7 +151,7 @@ class unified_bed_leveling {
     static mesh_index_pair find_closest_mesh_point_of_type(const MeshPointType, const float&, const float&, const bool, uint16_t[16], bool);
     static void reset();
     static void invalidate();
-    static void set_all_mesh_points_to_value(float);
+    static void set_all_mesh_points_to_value(const float);
     static bool sanity_check();
 
     static void G29() _O0;                          // O0 for no optimization
@@ -316,7 +315,7 @@ class unified_bed_leveling {
           strcpy(lcd_status_message, "get_z_correction() indexes out of range.");
           lcd_quick_feedback();
         #endif
-        return NAN; // this used to return state.z_offset
+        return NAN;
       }
 
       const float z1 = calc_z0(RAW_X_POSITION(lx0),
@@ -365,7 +364,7 @@ class unified_bed_leveling {
           }
         #endif
       }
-      return z0; // there used to be a +state.z_offset on this line
+      return z0;
     }
 
     /**

commit 442669d23ce1116ddc58035615dd2b52a30c67c9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Oct 9 18:26:52 2017 -0500

    Allow UBL to build without a probe

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
index 3082a77b03..8791415a46 100644
--- a/Marlin/src/feature/bedlevel/ubl/ubl.h
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -85,13 +85,16 @@ class unified_bed_leveling {
                   g29_phase_value,
                   g29_repetition_cnt,
                   g29_storage_slot,
-                  g29_map_type,
-                  g29_grid_size;
+                  g29_map_type;
     static bool   g29_c_flag, g29_x_flag, g29_y_flag;
     static float  g29_x_pos, g29_y_pos,
                   g29_card_thickness,
                   g29_constant;
 
+    #if HAS_BED_PROBE
+      static int  g29_grid_size;
+    #endif
+
     #if ENABLED(UBL_G26_MESH_VALIDATION)
       static float   g26_extrusion_multiplier,
                      g26_retraction_multiplier,

commit 551752eac73a6f60de45b6465e2f224b2b2dca24
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Sep 8 15:35:25 2017 -0500

    Consolidate "bedlevel" code

diff --git a/Marlin/src/feature/bedlevel/ubl/ubl.h b/Marlin/src/feature/bedlevel/ubl/ubl.h
new file mode 100644
index 0000000000..3082a77b03
--- /dev/null
+++ b/Marlin/src/feature/bedlevel/ubl/ubl.h
@@ -0,0 +1,421 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016, 2017 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#ifndef UNIFIED_BED_LEVELING_H
+#define UNIFIED_BED_LEVELING_H
+
+#include "../../../Marlin.h"
+#include "../../../module/planner.h"
+#include "../../../module/motion.h"
+
+#define UBL_VERSION "1.01"
+#define UBL_OK false
+#define UBL_ERR true
+
+#define USE_NOZZLE_AS_REFERENCE 0
+#define USE_PROBE_AS_REFERENCE 1
+
+typedef struct {
+  int8_t x_index, y_index;
+  float distance; // When populated, the distance from the search location
+} mesh_index_pair;
+
+// ubl.cpp
+
+void bit_clear(uint16_t bits[16], const uint8_t x, const uint8_t y);
+void bit_set(uint16_t bits[16], const uint8_t x, const uint8_t y);
+bool is_bit_set(uint16_t bits[16], const uint8_t x, const uint8_t y);
+
+// ubl_motion.cpp
+
+void debug_current_and_destination(const char * const title);
+
+// ubl_G29.cpp
+
+enum MeshPointType { INVALID, REAL, SET_IN_BITMAP };
+
+// External references
+
+char *ftostr43sign(const float&, char);
+bool ubl_lcd_clicked();
+
+extern uint8_t ubl_cnt;
+
+///////////////////////////////////////////////////////////////////////////////////////////////////////
+
+#if ENABLED(ULTRA_LCD)
+  extern char lcd_status_message[];
+  void lcd_quick_feedback();
+#endif
+
+#define MESH_X_DIST (float(UBL_MESH_MAX_X - (UBL_MESH_MIN_X)) / float(GRID_MAX_POINTS_X - 1))
+#define MESH_Y_DIST (float(UBL_MESH_MAX_Y - (UBL_MESH_MIN_Y)) / float(GRID_MAX_POINTS_Y - 1))
+
+typedef struct {
+  bool active = false;
+  float z_offset = 0.0;
+  int8_t storage_slot = -1;
+} ubl_state;
+
+class unified_bed_leveling {
+  private:
+
+    static float last_specified_z;
+
+    static int    g29_verbose_level,
+                  g29_phase_value,
+                  g29_repetition_cnt,
+                  g29_storage_slot,
+                  g29_map_type,
+                  g29_grid_size;
+    static bool   g29_c_flag, g29_x_flag, g29_y_flag;
+    static float  g29_x_pos, g29_y_pos,
+                  g29_card_thickness,
+                  g29_constant;
+
+    #if ENABLED(UBL_G26_MESH_VALIDATION)
+      static float   g26_extrusion_multiplier,
+                     g26_retraction_multiplier,
+                     g26_nozzle,
+                     g26_filament_diameter,
+                     g26_prime_length,
+                     g26_x_pos, g26_y_pos,
+                     g26_ooze_amount,
+                     g26_layer_height;
+      static int16_t g26_bed_temp,
+                     g26_hotend_temp,
+                     g26_repeats;
+      static int8_t  g26_prime_flag;
+      static bool    g26_continue_with_closest, g26_keep_heaters_on;
+    #endif
+
+    static float measure_point_with_encoder();
+    static float measure_business_card_thickness(float);
+    static bool g29_parameter_parsing();
+    static void find_mean_mesh_height();
+    static void shift_mesh_height();
+    static void probe_entire_mesh(const float &lx, const float &ly, const bool do_ubl_mesh_map, const bool stow_probe, bool do_furthest);
+    static void manually_probe_remaining_mesh(const float&, const float&, const float&, const float&, const bool);
+    static void tilt_mesh_based_on_3pts(const float &z1, const float &z2, const float &z3);
+    static void tilt_mesh_based_on_probed_grid(const bool do_ubl_mesh_map);
+    static void g29_what_command();
+    static void g29_eeprom_dump();
+    static void g29_compare_current_mesh_to_stored_mesh();
+    static void fine_tune_mesh(const float &lx, const float &ly, const bool do_ubl_mesh_map);
+    static bool smart_fill_one(const uint8_t x, const uint8_t y, const int8_t xdir, const int8_t ydir);
+    static void smart_fill_mesh();
+
+    #if ENABLED(UBL_G26_MESH_VALIDATION)
+      static bool exit_from_g26();
+      static bool parse_G26_parameters();
+      static void G26_line_to_destination(const float &feed_rate);
+      static mesh_index_pair find_closest_circle_to_print(const float&, const float&);
+      static bool look_for_lines_to_connect();
+      static bool turn_on_heaters();
+      static bool prime_nozzle();
+      static void retract_filament(const float where[XYZE]);
+      static void recover_filament(const float where[XYZE]);
+      static void print_line_from_here_to_there(const float&, const float&, const float&, const float&, const float&, const float&);
+      static void move_to(const float&, const float&, const float&, const float&);
+      inline static void move_to(const float where[XYZE], const float &de) { move_to(where[X_AXIS], where[Y_AXIS], where[Z_AXIS], de); }
+    #endif
+
+  public:
+
+    static void echo_name();
+    static void report_state();
+    static void save_ubl_active_state_and_disable();
+    static void restore_ubl_active_state_and_leave();
+    static void display_map(const int);
+    static mesh_index_pair find_closest_mesh_point_of_type(const MeshPointType, const float&, const float&, const bool, uint16_t[16], bool);
+    static void reset();
+    static void invalidate();
+    static void set_all_mesh_points_to_value(float);
+    static bool sanity_check();
+
+    static void G29() _O0;                          // O0 for no optimization
+    static void smart_fill_wlsf(const float &) _O2; // O2 gives smaller code than Os on A2560
+
+    #if ENABLED(UBL_G26_MESH_VALIDATION)
+      static void G26();
+    #endif
+
+    static ubl_state state;
+
+    static float z_values[GRID_MAX_POINTS_X][GRID_MAX_POINTS_Y];
+
+    // 15 is the maximum nubmer of grid points supported + 1 safety margin for now,
+    // until determinism prevails
+    constexpr static float _mesh_index_to_xpos[16] PROGMEM = {
+                              UBL_MESH_MIN_X +  0 * (MESH_X_DIST), UBL_MESH_MIN_X +  1 * (MESH_X_DIST),
+                              UBL_MESH_MIN_X +  2 * (MESH_X_DIST), UBL_MESH_MIN_X +  3 * (MESH_X_DIST),
+                              UBL_MESH_MIN_X +  4 * (MESH_X_DIST), UBL_MESH_MIN_X +  5 * (MESH_X_DIST),
+                              UBL_MESH_MIN_X +  6 * (MESH_X_DIST), UBL_MESH_MIN_X +  7 * (MESH_X_DIST),
+                              UBL_MESH_MIN_X +  8 * (MESH_X_DIST), UBL_MESH_MIN_X +  9 * (MESH_X_DIST),
+                              UBL_MESH_MIN_X + 10 * (MESH_X_DIST), UBL_MESH_MIN_X + 11 * (MESH_X_DIST),
+                              UBL_MESH_MIN_X + 12 * (MESH_X_DIST), UBL_MESH_MIN_X + 13 * (MESH_X_DIST),
+                              UBL_MESH_MIN_X + 14 * (MESH_X_DIST), UBL_MESH_MIN_X + 15 * (MESH_X_DIST)
+                            };
+
+    constexpr static float _mesh_index_to_ypos[16] PROGMEM = {
+                              UBL_MESH_MIN_Y +  0 * (MESH_Y_DIST), UBL_MESH_MIN_Y +  1 * (MESH_Y_DIST),
+                              UBL_MESH_MIN_Y +  2 * (MESH_Y_DIST), UBL_MESH_MIN_Y +  3 * (MESH_Y_DIST),
+                              UBL_MESH_MIN_Y +  4 * (MESH_Y_DIST), UBL_MESH_MIN_Y +  5 * (MESH_Y_DIST),
+                              UBL_MESH_MIN_Y +  6 * (MESH_Y_DIST), UBL_MESH_MIN_Y +  7 * (MESH_Y_DIST),
+                              UBL_MESH_MIN_Y +  8 * (MESH_Y_DIST), UBL_MESH_MIN_Y +  9 * (MESH_Y_DIST),
+                              UBL_MESH_MIN_Y + 10 * (MESH_Y_DIST), UBL_MESH_MIN_Y + 11 * (MESH_Y_DIST),
+                              UBL_MESH_MIN_Y + 12 * (MESH_Y_DIST), UBL_MESH_MIN_Y + 13 * (MESH_Y_DIST),
+                              UBL_MESH_MIN_Y + 14 * (MESH_Y_DIST), UBL_MESH_MIN_Y + 15 * (MESH_Y_DIST)
+                            };
+
+    static bool g26_debug_flag, has_control_of_lcd_panel;
+
+    #if ENABLED(ULTRA_LCD)
+      static bool lcd_map_control;
+    #endif
+
+    static volatile int encoder_diff; // Volatile because it's changed at interrupt time.
+
+    unified_bed_leveling();
+
+    FORCE_INLINE static void set_z(const int8_t px, const int8_t py, const float &z) { z_values[px][py] = z; }
+
+    static int8_t get_cell_index_x(const float &x) {
+      const int8_t cx = (x - (UBL_MESH_MIN_X)) * (1.0 / (MESH_X_DIST));
+      return constrain(cx, 0, (GRID_MAX_POINTS_X) - 1);   // -1 is appropriate if we want all movement to the X_MAX
+    }                                                     // position. But with this defined this way, it is possible
+                                                          // to extrapolate off of this point even further out. Probably
+                                                          // that is OK because something else should be keeping that from
+                                                          // happening and should not be worried about at this level.
+    static int8_t get_cell_index_y(const float &y) {
+      const int8_t cy = (y - (UBL_MESH_MIN_Y)) * (1.0 / (MESH_Y_DIST));
+      return constrain(cy, 0, (GRID_MAX_POINTS_Y) - 1);   // -1 is appropriate if we want all movement to the Y_MAX
+    }                                                     // position. But with this defined this way, it is possible
+                                                          // to extrapolate off of this point even further out. Probably
+                                                          // that is OK because something else should be keeping that from
+                                                          // happening and should not be worried about at this level.
+
+    static int8_t find_closest_x_index(const float &x) {
+      const int8_t px = (x - (UBL_MESH_MIN_X) + (MESH_X_DIST) * 0.5) * (1.0 / (MESH_X_DIST));
+      return WITHIN(px, 0, GRID_MAX_POINTS_X - 1) ? px : -1;
+    }
+
+    static int8_t find_closest_y_index(const float &y) {
+      const int8_t py = (y - (UBL_MESH_MIN_Y) + (MESH_Y_DIST) * 0.5) * (1.0 / (MESH_Y_DIST));
+      return WITHIN(py, 0, GRID_MAX_POINTS_Y - 1) ? py : -1;
+    }
+
+    /**
+     *                           z2   --|
+     *                 z0        |      |
+     *                  |        |      + (z2-z1)
+     *   z1             |        |      |
+     * ---+-------------+--------+--  --|
+     *   a1            a0        a2
+     *    |<---delta_a---------->|
+     *
+     *  calc_z0 is the basis for all the Mesh Based correction. It is used to
+     *  find the expected Z Height at a position between two known Z-Height locations.
+     *
+     *  It is fairly expensive with its 4 floating point additions and 2 floating point
+     *  multiplications.
+     */
+    FORCE_INLINE static float calc_z0(const float &a0, const float &a1, const float &z1, const float &a2, const float &z2) {
+      return z1 + (z2 - z1) * (a0 - a1) / (a2 - a1);
+    }
+
+    /**
+     * z_correction_for_x_on_horizontal_mesh_line is an optimization for
+     * the case where the printer is making a vertical line that only crosses horizontal mesh lines.
+     */
+    inline static float z_correction_for_x_on_horizontal_mesh_line(const float &lx0, const int x1_i, const int yi) {
+      if (!WITHIN(x1_i, 0, GRID_MAX_POINTS_X - 2) || !WITHIN(yi, 0, GRID_MAX_POINTS_Y - 1)) {
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) {
+            serialprintPGM( !WITHIN(x1_i, 0, GRID_MAX_POINTS_X - 1) ? PSTR("x1l_i") : PSTR("yi") );
+            SERIAL_ECHOPAIR(" out of bounds in z_correction_for_x_on_horizontal_mesh_line(lx0=", lx0);
+            SERIAL_ECHOPAIR(",x1_i=", x1_i);
+            SERIAL_ECHOPAIR(",yi=", yi);
+            SERIAL_CHAR(')');
+            SERIAL_EOL();
+          }
+        #endif
+        return NAN;
+      }
+
+      const float xratio = (RAW_X_POSITION(lx0) - mesh_index_to_xpos(x1_i)) * (1.0 / (MESH_X_DIST)),
+                  z1 = z_values[x1_i][yi];
+
+      return z1 + xratio * (z_values[x1_i + 1][yi] - z1);
+    }
+
+    //
+    // See comments above for z_correction_for_x_on_horizontal_mesh_line
+    //
+    inline static float z_correction_for_y_on_vertical_mesh_line(const float &ly0, const int xi, const int y1_i) {
+      if (!WITHIN(xi, 0, GRID_MAX_POINTS_X - 1) || !WITHIN(y1_i, 0, GRID_MAX_POINTS_Y - 2)) {
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(LEVELING)) {
+            serialprintPGM( !WITHIN(xi, 0, GRID_MAX_POINTS_X - 1) ? PSTR("xi") : PSTR("yl_i") );
+            SERIAL_ECHOPAIR(" out of bounds in z_correction_for_y_on_vertical_mesh_line(ly0=", ly0);
+            SERIAL_ECHOPAIR(", xi=", xi);
+            SERIAL_ECHOPAIR(", y1_i=", y1_i);
+            SERIAL_CHAR(')');
+            SERIAL_EOL();
+          }
+        #endif
+        return NAN;
+      }
+
+      const float yratio = (RAW_Y_POSITION(ly0) - mesh_index_to_ypos(y1_i)) * (1.0 / (MESH_Y_DIST)),
+                  z1 = z_values[xi][y1_i];
+
+      return z1 + yratio * (z_values[xi][y1_i + 1] - z1);
+    }
+
+    /**
+     * This is the generic Z-Correction. It works anywhere within a Mesh Cell. It first
+     * does a linear interpolation along both of the bounding X-Mesh-Lines to find the
+     * Z-Height at both ends. Then it does a linear interpolation of these heights based
+     * on the Y position within the cell.
+     */
+    static float get_z_correction(const float &lx0, const float &ly0) {
+      const int8_t cx = get_cell_index_x(RAW_X_POSITION(lx0)),
+                   cy = get_cell_index_y(RAW_Y_POSITION(ly0));
+
+      if (!WITHIN(cx, 0, GRID_MAX_POINTS_X - 2) || !WITHIN(cy, 0, GRID_MAX_POINTS_Y - 2)) {
+
+        SERIAL_ECHOPAIR("? in get_z_correction(lx0=", lx0);
+        SERIAL_ECHOPAIR(", ly0=", ly0);
+        SERIAL_CHAR(')');
+        SERIAL_EOL();
+
+        #if ENABLED(ULTRA_LCD)
+          strcpy(lcd_status_message, "get_z_correction() indexes out of range.");
+          lcd_quick_feedback();
+        #endif
+        return NAN; // this used to return state.z_offset
+      }
+
+      const float z1 = calc_z0(RAW_X_POSITION(lx0),
+                               mesh_index_to_xpos(cx), z_values[cx][cy],
+                               mesh_index_to_xpos(cx + 1), z_values[cx + 1][cy]);
+
+      const float z2 = calc_z0(RAW_X_POSITION(lx0),
+                               mesh_index_to_xpos(cx), z_values[cx][cy + 1],
+                               mesh_index_to_xpos(cx + 1), z_values[cx + 1][cy + 1]);
+
+      float z0 = calc_z0(RAW_Y_POSITION(ly0),
+                         mesh_index_to_ypos(cy), z1,
+                         mesh_index_to_ypos(cy + 1), z2);
+
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        if (DEBUGGING(MESH_ADJUST)) {
+          SERIAL_ECHOPAIR(" raw get_z_correction(", lx0);
+          SERIAL_CHAR(',');
+          SERIAL_ECHO(ly0);
+          SERIAL_ECHOPGM(") = ");
+          SERIAL_ECHO_F(z0, 6);
+        }
+      #endif
+
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        if (DEBUGGING(MESH_ADJUST)) {
+          SERIAL_ECHOPGM(" >>>---> ");
+          SERIAL_ECHO_F(z0, 6);
+          SERIAL_EOL();
+        }
+      #endif
+
+      if (isnan(z0)) { // if part of the Mesh is undefined, it will show up as NAN
+        z0 = 0.0;      // in ubl.z_values[][] and propagate through the
+                       // calculations. If our correction is NAN, we throw it out
+                       // because part of the Mesh is undefined and we don't have the
+                       // information we need to complete the height correction.
+
+        #if ENABLED(DEBUG_LEVELING_FEATURE)
+          if (DEBUGGING(MESH_ADJUST)) {
+            SERIAL_ECHOPAIR("??? Yikes!  NAN in get_z_correction(", lx0);
+            SERIAL_CHAR(',');
+            SERIAL_ECHO(ly0);
+            SERIAL_CHAR(')');
+            SERIAL_EOL();
+          }
+        #endif
+      }
+      return z0; // there used to be a +state.z_offset on this line
+    }
+
+    /**
+     * This function sets the Z leveling fade factor based on the given Z height,
+     * only re-calculating when necessary.
+     *
+     *  Returns 1.0 if planner.z_fade_height is 0.0.
+     *  Returns 0.0 if Z is past the specified 'Fade Height'.
+     */
+    #if ENABLED(ENABLE_LEVELING_FADE_HEIGHT)
+      static inline float fade_scaling_factor_for_z(const float &lz) {
+        if (planner.z_fade_height == 0.0) return 1.0;
+        static float fade_scaling_factor = 1.0;
+        const float rz = RAW_Z_POSITION(lz);
+        if (last_specified_z != rz) {
+          last_specified_z = rz;
+          fade_scaling_factor =
+            rz < planner.z_fade_height
+              ? 1.0 - (rz * planner.inverse_z_fade_height)
+              : 0.0;
+        }
+        return fade_scaling_factor;
+      }
+    #else
+      FORCE_INLINE static float fade_scaling_factor_for_z(const float &lz) { return 1.0; }
+    #endif
+
+    FORCE_INLINE static float mesh_index_to_xpos(const uint8_t i) {
+      return i < GRID_MAX_POINTS_X ? pgm_read_float(&_mesh_index_to_xpos[i]) : UBL_MESH_MIN_X + i * (MESH_X_DIST);
+    }
+
+    FORCE_INLINE static float mesh_index_to_ypos(const uint8_t i) {
+      return i < GRID_MAX_POINTS_Y ? pgm_read_float(&_mesh_index_to_ypos[i]) : UBL_MESH_MIN_Y + i * (MESH_Y_DIST);
+    }
+
+    static bool prepare_segmented_line_to(const float ltarget[XYZE], const float &feedrate);
+    static void line_to_destination_cartesian(const float &fr, uint8_t e);
+
+    #define _CMPZ(a,b) (z_values[a][b] == z_values[a][b+1])
+    #define CMPZ(a) (_CMPZ(a, 0) && _CMPZ(a, 1))
+    #define ZZER(a) (z_values[a][0] == 0)
+
+    FORCE_INLINE bool mesh_is_valid() {
+      return !(
+        (    CMPZ(0) && CMPZ(1) && CMPZ(2) // adjacent z values all equal?
+          && ZZER(0) && ZZER(1) && ZZER(2) // all zero at the edge?
+        )
+        || isnan(z_values[0][0])
+      );
+    }
+
+}; // class unified_bed_leveling
+
+extern unified_bed_leveling ubl;
+
+#endif // UNIFIED_BED_LEVELING_H
