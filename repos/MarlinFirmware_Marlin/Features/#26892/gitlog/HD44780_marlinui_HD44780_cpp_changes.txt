commit ee99eed3bf9f5d811b596058932b88d8ed5298a1
Author: Mihai <299015+mh-dm@users.noreply.github.com>
Date:   Mon Jul 15 21:57:25 2024 +0300

    üö∏ Improved menu responsiveness with MarlinUI + U8Glib. (#26555)
    
    Co-authored-by: Jason Smith <jason.inet@gmail.com>
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index ae92d0a5f8..435f40e3a4 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -1344,7 +1344,7 @@ void MarlinUI::draw_status_screen() {
     void MenuItem_sdbase::draw(const bool sel, const uint8_t row, FSTR_P const, CardReader &theCard, const bool isDir) {
       lcd_put_lchar(0, row, sel ? LCD_STR_ARROW_RIGHT[0] : ' ');
       uint8_t n = LCD_WIDTH - 2;
-      n -= lcd_put_u8str_max(ui.scrolled_filename(theCard, n, row, sel), n);
+      n -= lcd_put_u8str_max(ui.scrolled_filename(theCard, n, sel), n);
       for (; n; --n) lcd_put_u8str(F(" "));
       lcd_put_lchar(isDir ? LCD_STR_FOLDER[0] : ' ');
     }

commit 1f9fc665ec21f95666801aa4fccc4f4f71932018
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jun 26 18:27:05 2024 -0500

    üö∏ MarlinUI:: clear_for_drawing

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index ea73243250..ae92d0a5f8 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -467,6 +467,7 @@ bool MarlinUI::detected() {
 #endif
 
 void MarlinUI::clear_lcd() { lcd.clear(); }
+void MarlinUI::clear_for_drawing() { clear_lcd(); }
 
 #if ENABLED(SHOW_BOOTSCREEN)
 
@@ -1515,7 +1516,7 @@ void MarlinUI::draw_status_screen() {
         lower_right.column = 0;
         lower_right.row    = 0;
 
-        clear_lcd();
+        clear_for_drawing();
 
         x_map_pixels = (HD44780_CHAR_WIDTH) * (MESH_MAP_COLS) - 2;          // Minus 2 because we are drawing a box around the map
         y_map_pixels = (HD44780_CHAR_HEIGHT) * (MESH_MAP_ROWS) - 2;

commit 0e2bd069d4e0ae3cfcc5a15ec86c865d4eeef21c
Author: Dave Gateman <toxicpsion@gmail.com>
Date:   Sun May 19 17:53:38 2024 -0600

    ü©π Fix cutter power extra '%' (#27105)

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index 686d0972b9..ea73243250 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -709,9 +709,6 @@ FORCE_INLINE void _draw_bed_status(const bool blink) {
       lcd_put_u8str(F("K"));
     #else
       lcd_put_u8str(cutter_power2str(cutter.unitPower));
-      #if CUTTER_UNIT_IS(PERCENT)
-        lcd_put_u8str(F("%"));
-      #endif
     #endif
 
     lcd_put_u8str(F(" "));

commit feca9a33d5c9a06aa3c0b878acfbb8a552b70c1b
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Mon May 20 11:51:52 2024 +1200

    ‚ú® SHOW_CUSTOM_BOOTSCREEN for HD44780 (#26793)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index 0ab045bda3..686d0972b9 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -331,15 +331,24 @@ void MarlinUI::set_custom_characters(const HD44780CharSet screen_charset/*=CHARS
 
   #endif // HAS_MEDIA
 
-  #if ENABLED(SHOW_BOOTSCREEN)
-    // Set boot screen corner characters
-    if (screen_charset == CHARSET_BOOT) {
-      for (uint8_t i = 4; i--;)
-        createChar_P(i, corner[i]);
-    }
-    else
-  #endif
-    { // Info Screen uses 5 special characters
+  switch (screen_charset) {
+
+    #if ENABLED(SHOW_BOOTSCREEN)
+      case CHARSET_BOOT: {
+        // Set boot screen corner characters
+        for (uint8_t i = 4; i--;) createChar_P(i, corner[i]);
+      } break;
+    #endif
+
+    #if ENABLED(SHOW_CUSTOM_BOOTSCREEN)
+      case CHARSET_BOOT_CUSTOM: {
+        for (uint8_t i = COUNT(customBootChars); i--;)
+          createChar_P(i, customBootChars[i]);
+      } break;
+    #endif
+
+    default: {
+      // Info Screen uses 5 special characters
       createChar_P(LCD_STR_BEDTEMP[0], bedTemp);
       createChar_P(LCD_STR_DEGREE[0], degree);
       createChar_P(LCD_STR_THERMOMETER[0], thermometer);
@@ -361,7 +370,9 @@ void MarlinUI::set_custom_characters(const HD44780CharSet screen_charset/*=CHARS
             createChar_P(LCD_STR_FOLDER[0], folder);
           #endif
         }
-    }
+    } break;
+
+  }
 
 }
 
@@ -400,6 +411,42 @@ bool MarlinUI::detected() {
   return TERN1(DETECT_I2C_LCD_DEVICE, lcd.LcdDetected() == 1);
 }
 
+#if ENABLED(SHOW_CUSTOM_BOOTSCREEN)
+
+  #ifndef CUSTOM_BOOTSCREEN_X
+    #define CUSTOM_BOOTSCREEN_X -1
+  #endif
+  #ifndef CUSTOM_BOOTSCREEN_Y
+    #define CUSTOM_BOOTSCREEN_Y ((LCD_HEIGHT - COUNT(custom_boot_lines)) / 2)
+  #endif
+  #ifndef CUSTOM_BOOTSCREEN_TIMEOUT
+    #define CUSTOM_BOOTSCREEN_TIMEOUT 2500
+  #endif
+
+  void MarlinUI::draw_custom_bootscreen(const uint8_t/*=0*/) {
+    set_custom_characters(CHARSET_BOOT_CUSTOM);
+    lcd.clear();
+    const int8_t sx = CUSTOM_BOOTSCREEN_X;
+    const uint8_t sy = CUSTOM_BOOTSCREEN_Y;
+    for (lcd_uint_t i = 0; i < COUNT(custom_boot_lines); ++i) {
+      PGM_P const pstr = (PGM_P)pgm_read_ptr(&custom_boot_lines[i]);
+      const uint8_t clen = utf8_strlen_P(pstr);
+      const lcd_uint_t x = sx >= 0 ? sx : (LCD_WIDTH - clen) / 2;
+      for (lcd_uint_t j = 0; j < clen; ++j) {
+        const lchar_t c = pgm_read_byte(&pstr[j]);
+        lcd_put_lchar(x + j, sy + i, c == '\x08' ? '\x00' : c);
+      }
+    }
+  }
+
+  // Shows the custom bootscreen and delays
+  void MarlinUI::show_custom_bootscreen() {
+    draw_custom_bootscreen();
+    safe_delay(CUSTOM_BOOTSCREEN_TIMEOUT);
+  }
+
+#endif // SHOW_CUSTOM_BOOTSCREEN
+
 #if HAS_SLOW_BUTTONS
   uint8_t MarlinUI::read_slow_buttons() {
     #if ENABLED(LCD_I2C_TYPE_MCP23017)
@@ -466,6 +513,8 @@ void MarlinUI::clear_lcd() { lcd.clear(); }
   }
 
   void MarlinUI::show_bootscreen() {
+    TERN_(SHOW_CUSTOM_BOOTSCREEN, show_custom_bootscreen());
+
     set_custom_characters(CHARSET_BOOT);
     lcd.clear();
 

commit 1b091ecb874bb873c12c686746084e6ee71b056f
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Thu Apr 11 02:13:54 2024 -0400

    ‚úèÔ∏èMinor style and typo fixups (#26947)
    
    * tweaks from PR, whitespace, wording in pause.h
    
    * Update Marlin/src/feature/pause.h

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index d36233d73d..0ab045bda3 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -1169,7 +1169,7 @@ void MarlinUI::draw_status_screen() {
 
     lcd_moveto(LCD_WIDTH - 9, 2);
     lcd_put_lchar('S');
-    
+
 
   #endif // LCD_INFO_SCREEN_STYLE
 

commit cd357b027881dc1d3a432127f74d54d3d9ee91db
Author: Holger M√∂√üinger <hm2dev@users.noreply.github.com>
Date:   Wed Mar 27 20:38:08 2024 +0100

    üîßüö∏ Tweaks for (MiniRambo) CNC (#26892)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index 1126b4a4b6..d36233d73d 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -1139,7 +1139,39 @@ void MarlinUI::draw_status_screen() {
       TERN_(SHOW_PROGRESS_PERCENT, setPercentPos(LCD_WIDTH - 9, 2));
       rotate_progress();
     #endif
-  #endif // LCD_INFO_SCREEN_STYLE 1
+
+  #elif LCD_INFO_SCREEN_STYLE == 2
+
+    // ========== Line 1 ==========
+
+    //
+    // X Coordinate
+    //
+    lcd_moveto(0, 0);
+    _draw_axis_value(X_AXIS, ftostr52sp(LOGICAL_X_POSITION(current_position.x)), blink);
+
+    //
+    // Y Coordinate
+    //
+    lcd_moveto(LCD_WIDTH - 9, 0);
+    _draw_axis_value(Y_AXIS, ftostr52sp(LOGICAL_Y_POSITION(current_position.y)), blink);
+
+    // ========== Line 2 ==========
+    lcd_moveto(0, 1);
+    _draw_axis_value(Z_AXIS, ftostr52sp(LOGICAL_Z_POSITION(current_position.z)), blink);
+
+    lcd_moveto(LCD_WIDTH - 9, 1);
+    _draw_axis_value(I_AXIS, ftostr52sp(LOGICAL_I_POSITION(current_position.i)), blink);
+
+    // ========== Line 3 ==========
+    lcd_moveto(0, 2);
+    lcd_put_lchar('F');
+
+    lcd_moveto(LCD_WIDTH - 9, 2);
+    lcd_put_lchar('S');
+    
+
+  #endif // LCD_INFO_SCREEN_STYLE
 
   // ========= Last Line ========
 

commit dd3b5a10a09e2a83918af1cf6f8782fd0c473f98
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jan 21 22:00:37 2024 -0600

    Misc. aesthetic adjustments
    
    Co-Authored-By: Andrew <18502096+classicrocker883@users.noreply.github.com>

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index 155ae581f0..1126b4a4b6 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -793,11 +793,11 @@ void MarlinUI::draw_status_message(const bool blink) {
     static lcd_uint_t pc = 0, pr = 2;
     inline void setPercentPos(const lcd_uint_t c, const lcd_uint_t r) { pc = c; pr = r; }
     void MarlinUI::drawPercent() {
-      const uint8_t progress = ui.get_progress_percent();
+      const uint8_t progress = get_progress_percent();
       if (progress) {
         lcd_moveto(pc, pr);
         lcd_put_u8str(F(TERN(IS_SD_PRINTING, "SD", "P:")));
-        lcd_put_u8str(TERN(PRINT_PROGRESS_SHOW_DECIMALS, permyriadtostr4(ui.get_progress_permyriad()), ui8tostr3rj(progress)));
+        lcd_put_u8str(TERN(PRINT_PROGRESS_SHOW_DECIMALS, permyriadtostr4(get_progress_permyriad()), ui8tostr3rj(progress)));
         lcd_put_u8str(F("%"));
       }
     }
@@ -806,9 +806,9 @@ void MarlinUI::draw_status_message(const bool blink) {
   #if ENABLED(SHOW_REMAINING_TIME)
     void MarlinUI::drawRemain() {
       if (printJobOngoing()) {
-        const duration_t remaint = ui.get_remaining_time();
+        const duration_t remaint = get_remaining_time();
         timepos = TPOFFSET - remaint.toDigital(buffer);
-        TERN_(NOT(LCD_INFO_SCREEN_STYLE), lcd_put_lchar(timepos - 1, 2, 0x20);)
+        IF_DISABLED(LCD_INFO_SCREEN_STYLE, lcd_put_lchar(timepos - 1, 2, 0x20));
         lcd_put_lchar(TERN(LCD_INFO_SCREEN_STYLE, 11, timepos), 2, 'R');
         lcd_put_u8str(buffer);
       }
@@ -817,10 +817,10 @@ void MarlinUI::draw_status_message(const bool blink) {
 
   #if ENABLED(SHOW_INTERACTION_TIME)
     void MarlinUI::drawInter() {
-      const duration_t interactt = ui.interaction_time;
+      const duration_t interactt = interaction_time;
       if (printingIsActive() && interactt.value) {
         timepos = TPOFFSET - interactt.toDigital(buffer);
-        TERN_(NOT(LCD_INFO_SCREEN_STYLE), lcd_put_lchar(timepos - 1, 2, 0x20);)
+        IF_DISABLED(LCD_INFO_SCREEN_STYLE, lcd_put_lchar(timepos - 1, 2, 0x20));
         lcd_put_lchar(TERN(LCD_INFO_SCREEN_STYLE, 11, timepos), 2, 'C');
         lcd_put_u8str(buffer);
       }
@@ -832,7 +832,7 @@ void MarlinUI::draw_status_message(const bool blink) {
       if (printJobOngoing()) {
         const duration_t elapsedt = print_job_timer.duration();
         timepos = TPOFFSET - elapsedt.toDigital(buffer);
-        TERN_(NOT(LCD_INFO_SCREEN_STYLE), lcd_put_lchar(timepos - 1, 2, 0x20);)
+        IF_DISABLED(LCD_INFO_SCREEN_STYLE, lcd_put_lchar(timepos - 1, 2, 0x20));
         lcd_put_lchar(TERN(LCD_INFO_SCREEN_STYLE, 11, timepos), 2, 'E');
         lcd_put_u8str(buffer);
       }

commit 014278383645bdfe50313ffd15a2287f377ac8f0
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Sun Nov 19 23:24:32 2023 -0800

    üö∏ Fix more MarlinUI title centering (#26440)
    
    Followup to #26339

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index 2564d4f96e..155ae581f0 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -1179,7 +1179,7 @@ void MarlinUI::draw_status_screen() {
     int8_t llen = ftpl ? expand_u8str(estr, ftpl, itemIndex, itemStringC, itemStringF, n - vlen) : 0;
 
     bool mv_colon = false;
-    if (vlen) {
+    if (vlen && !center) {
       // Move the leading colon from the value to the label below
       mv_colon = (*vstr == ':');
       // Shorter value, wider label

commit 2a88e7600298fef27e8cbbe01b708959515677fb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Oct 25 19:41:32 2023 -0500

    üßë‚Äçüíª Misc. LCD / string updates

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index ce19cb35ed..2564d4f96e 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -1248,8 +1248,8 @@ void MarlinUI::draw_status_screen() {
   }
 
   // The Select Screen presents a prompt and two "buttons"
-  void MenuItem_confirm::draw_select_screen(FSTR_P const yes, FSTR_P const no, const bool yesno, FSTR_P const pref, const char * const string/*=nullptr*/, FSTR_P const suff/*=nullptr*/) {
-    ui.draw_select_screen_prompt(pref, string, suff);
+  void MenuItem_confirm::draw_select_screen(FSTR_P const yes, FSTR_P const no, const bool yesno, FSTR_P const fpre, const char * const string/*=nullptr*/, FSTR_P const fsuf/*=nullptr*/) {
+    ui.draw_select_screen_prompt(fpre, string, fsuf);
     if (no) {
       SETCURSOR(0, LCD_HEIGHT - 1);
       lcd_put_lchar(yesno ? ' ' : '['); lcd_put_u8str(no); lcd_put_lchar(yesno ? ' ' : ']');

commit 797ea5efa741ef96827870bb44b48fac7a41f1a0
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Sun Oct 22 13:15:38 2023 -0700

    üö∏ Fix MarlinUI expanded label alignment (#26339)
    
    Co-authored-by: ellensp <530024+ellensp@users.noreply.github.com>
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index 716d1341db..ce19cb35ed 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -1170,23 +1170,38 @@ void MarlinUI::draw_status_screen() {
 
     int8_t n = LCD_WIDTH;
     const bool center = bool(style & SS_CENTER), full = bool(style & SS_FULL);
-    const int8_t plen = ftpl ? utf8_strlen(ftpl) : 0,
-                 vlen = vstr ? utf8_strlen(vstr) : 0;
-    int8_t pad = (center || full) ? n - plen - vlen : 0;
+
+    // Value length, if any
+    int8_t vlen = vstr ? utf8_strlen(vstr) : 0;
+
+    // Expanded label string and width in chars
+    char estr[calculateWidth(ftpl) + 3] = "\0";
+    int8_t llen = ftpl ? expand_u8str(estr, ftpl, itemIndex, itemStringC, itemStringF, n - vlen) : 0;
+
+    bool mv_colon = false;
+    if (vlen) {
+      // Move the leading colon from the value to the label below
+      mv_colon = (*vstr == ':');
+      // Shorter value, wider label
+      if (mv_colon) { vstr++; vlen--; llen++; }
+      // Remove leading spaces from the value and shorten
+      while (*vstr == ' ') { vstr++; vlen--; }
+    }
+
+    // Padding for center or full justification
+    int8_t pad = (center || full) ? n - llen - vlen : 0;
 
     // SS_CENTER: Pad with half of the unused space first
-    if (center) for (int8_t lpad = pad / 2; lpad > 0; --lpad) { lcd_put_u8str(F(" ")); n--; }
+    if (center) for (int8_t lpad = pad / 2; lpad > 0; --lpad, --pad, --n) lcd_put_u8str(F(" "));
 
-    // Draw as much of the label as fits
-    if (plen) n -= lcd_put_u8str(ftpl, itemIndex, itemStringC, itemStringF, n - vlen);
+    // Draw as much of the label as fits (without the relocated colon, drawn below)
+    if (llen) n -= lcd_put_u8str_max(estr, n - vlen);
 
     if (vlen && n > 0) {
       // SS_FULL: Pad with enough space to justify the value
       if (full && !center) {
         // Move the leading colon from the value to the label
-        if (*vstr == ':') { n -= lcd_put_u8str(F(":")); vstr++; }
-        // Move spaces to the padding
-        while (*vstr == ' ') { vstr++; pad++; }
+        if (mv_colon) n -= lcd_put_u8str(F(":"));
         // Pad in-between
         for (; pad > 0; --pad) { lcd_put_u8str(F(" ")); n--; }
       }

commit b0ece8f8df130709f97da6c1474cd20cbd9119ed
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Oct 20 17:21:30 2023 -0500

    üßë‚Äçüíª MarlinUI menu tweaks
    
    Changes in prep for #26339

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index 3206cb6334..716d1341db 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -1165,12 +1165,12 @@ void MarlinUI::draw_status_screen() {
   #endif // ADVANCED_PAUSE_FEATURE
 
   // Draw a static item with no left-right margin required. Centered by default.
-  void MenuItem_static::draw(const uint8_t row, FSTR_P const fstr, const uint8_t style/*=SS_DEFAULT*/, const char *vstr/*=nullptr*/) {
+  void MenuItem_static::draw(const uint8_t row, FSTR_P const ftpl, const uint8_t style/*=SS_DEFAULT*/, const char *vstr/*=nullptr*/) {
     lcd_moveto(0, row);
 
     int8_t n = LCD_WIDTH;
     const bool center = bool(style & SS_CENTER), full = bool(style & SS_FULL);
-    const int8_t plen = fstr ? utf8_strlen(fstr) : 0,
+    const int8_t plen = ftpl ? utf8_strlen(ftpl) : 0,
                  vlen = vstr ? utf8_strlen(vstr) : 0;
     int8_t pad = (center || full) ? n - plen - vlen : 0;
 
@@ -1178,7 +1178,7 @@ void MarlinUI::draw_status_screen() {
     if (center) for (int8_t lpad = pad / 2; lpad > 0; --lpad) { lcd_put_u8str(F(" ")); n--; }
 
     // Draw as much of the label as fits
-    if (plen) n -= lcd_put_u8str(fstr, itemIndex, itemStringC, itemStringF, n - vlen);
+    if (plen) n -= lcd_put_u8str(ftpl, itemIndex, itemStringC, itemStringF, n - vlen);
 
     if (vlen && n > 0) {
       // SS_FULL: Pad with enough space to justify the value

commit 20fec98f70208546b90ccc0b8f6766de6f2f8230
Author: lukasradek <lukasradek@users.noreply.github.com>
Date:   Thu Aug 24 19:41:30 2023 +0200

    üßë‚Äçüíª Adjust LCD string draw (#26154)

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index 897070c4dd..3206cb6334 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -1178,11 +1178,7 @@ void MarlinUI::draw_status_screen() {
     if (center) for (int8_t lpad = pad / 2; lpad > 0; --lpad) { lcd_put_u8str(F(" ")); n--; }
 
     // Draw as much of the label as fits
-    if (plen) {
-      const int8_t expl = n;
-      n = lcd_put_u8str(fstr, itemIndex, itemStringC, itemStringF, n);
-      pad -= (expl - n - plen); // Reduce the padding
-    }
+    if (plen) n -= lcd_put_u8str(fstr, itemIndex, itemStringC, itemStringF, n - vlen);
 
     if (vlen && n > 0) {
       // SS_FULL: Pad with enough space to justify the value
@@ -1203,7 +1199,8 @@ void MarlinUI::draw_status_screen() {
   // Draw a generic menu item with pre_char (if selected) and post_char
   void MenuItemBase::_draw(const bool sel, const uint8_t row, FSTR_P const ftpl, const char pre_char, const char post_char) {
     lcd_put_lchar(0, row, sel ? pre_char : ' ');
-    uint8_t n = lcd_put_u8str(ftpl, itemIndex, itemStringC, itemStringF, LCD_WIDTH - 2);
+    uint8_t n = LCD_WIDTH - 2;
+    n -= lcd_put_u8str(ftpl, itemIndex, itemStringC, itemStringF, n);
     for (; n; --n) lcd_put_u8str(F(" "));
     lcd_put_lchar(post_char);
   }
@@ -1224,7 +1221,8 @@ void MarlinUI::draw_status_screen() {
   // Low-level draw_edit_screen can be used to draw an edit screen from anyplace
   void MenuEditItemBase::draw_edit_screen(FSTR_P const ftpl, const char * const value/*=nullptr*/) {
     ui.encoder_direction_normal();
-    uint8_t n = lcd_put_u8str(0, 1, ftpl, itemIndex, itemStringC, itemStringF, LCD_WIDTH - 1);
+    uint8_t n = LCD_WIDTH - 1;
+    n -= lcd_put_u8str(0, 1, ftpl, itemIndex, itemStringC, itemStringF, n);
     if (value) {
       lcd_put_u8str(F(":")); n--;
       const uint8_t len = utf8_strlen(value) + 1;   // Plus one for a leading space
@@ -1251,8 +1249,8 @@ void MarlinUI::draw_status_screen() {
 
     void MenuItem_sdbase::draw(const bool sel, const uint8_t row, FSTR_P const, CardReader &theCard, const bool isDir) {
       lcd_put_lchar(0, row, sel ? LCD_STR_ARROW_RIGHT[0] : ' ');
-      constexpr uint8_t maxlen = LCD_WIDTH - 2;
-      uint8_t n = maxlen - lcd_put_u8str_max(ui.scrolled_filename(theCard, maxlen, row, sel), maxlen);
+      uint8_t n = LCD_WIDTH - 2;
+      n -= lcd_put_u8str_max(ui.scrolled_filename(theCard, n, row, sel), n);
       for (; n; --n) lcd_put_u8str(F(" "));
       lcd_put_lchar(isDir ? LCD_STR_FOLDER[0] : ' ');
     }

commit d036097bca52b128b421342afcdb908cb1d8d5ab
Author: lukasradek <lukasradek@users.noreply.github.com>
Date:   Thu Jul 27 23:08:21 2023 +0200

    üö∏ Fix HD44780 EDIT_ITEM position (#26073)

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index b59ec150a1..897070c4dd 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -1212,7 +1212,8 @@ void MarlinUI::draw_status_screen() {
   void MenuEditItemBase::draw(const bool sel, const uint8_t row, FSTR_P const ftpl, const char * const inStr, const bool pgm) {
     const uint8_t vlen = inStr ? (pgm ? utf8_strlen_P(inStr) : utf8_strlen(inStr)) : 0;
     lcd_put_lchar(0, row, sel ? LCD_STR_ARROW_RIGHT[0] : ' ');
-    uint8_t n = lcd_put_u8str(ftpl, itemIndex, itemStringC, itemStringF, LCD_WIDTH - 2 - vlen);
+    uint8_t n = LCD_WIDTH - 2 - vlen;
+    n -= lcd_put_u8str(ftpl, itemIndex, itemStringC, itemStringF, n);
     if (vlen) {
       lcd_put_u8str(F(":"));
       for (; n; --n) lcd_put_u8str(F(" "));

commit a0e3dea8b879aba8e0d2d7e4dc6a6447b3fe76ad
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jul 20 20:25:39 2023 -0500

    üö∏ ColorUI Touch Calibrate in CW order

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index 148d0877cf..b59ec150a1 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -784,6 +784,7 @@ void MarlinUI::draw_status_message(const bool blink) {
 }
 
 #if HAS_PRINT_PROGRESS
+
   #define TPOFFSET (LCD_WIDTH - 1)
   static uint8_t timepos = TPOFFSET - 6;
   static char buffer[8];
@@ -837,6 +838,7 @@ void MarlinUI::draw_status_message(const bool blink) {
       }
     }
   #endif
+
 #endif // HAS_PRINT_PROGRESS
 
 /**

commit 929497d52762f87243d1b521d9703f75b7501aa4
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Tue Jul 4 14:07:56 2023 -0700

    üìù Update config URLs (#26049)

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index c5b4df46f2..148d0877cf 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -81,7 +81,7 @@
 #elif ENABLED(SR_LCD_2W_NL)
 
   // 2 wire Non-latching LCD SR from:
-  // https://bitbucket.org/fmalpartida/new-liquidcrystal/wiki/schematics#!shiftregister-connection
+  // https://github.com/fmalpartida/New-LiquidCrystal/wiki/schematics#user-content-ShiftRegister_connection
 
   LCD_CLASS lcd(SR_DATA_PIN, SR_CLK_PIN
     #if PIN_EXISTS(SR_STROBE)

commit 574dd34c49fde76e1e736b8a7e1ea579d724ff22
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jun 27 13:19:36 2023 -0500

    ‚ôªÔ∏è String helper class (#24390)

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index 1aa53241ad..c5b4df46f2 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -731,7 +731,7 @@ void MarlinUI::draw_status_message(const bool blink) {
     static bool last_blink = false;
 
     // Get the UTF8 character count of the string
-    uint8_t slen = utf8_strlen(status_message);
+    uint8_t slen = status_message.glyphs();
 
     // If the string fits into the LCD, just print it and do not scroll it
     if (slen <= LCD_WIDTH) {
@@ -773,7 +773,7 @@ void MarlinUI::draw_status_message(const bool blink) {
     UNUSED(blink);
 
     // Get the UTF8 character count of the string
-    uint8_t slen = utf8_strlen(status_message);
+    uint8_t slen = status_message.glyphs();
 
     // Just print the string to the LCD
     lcd_put_u8str_max(status_message, LCD_WIDTH);

commit c3694f1c038fa20ad749118b0a1c7aa88e3dd5f2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jun 14 17:24:50 2023 -0500

    üé® Lowercase methods, functions, data members (#25939)
    
    For: TFT, DGUS, MarlinUI, Anycubic, JyersUI, CrealityUI

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index ba467d1a61..1aa53241ad 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -787,9 +787,10 @@ void MarlinUI::draw_status_message(const bool blink) {
   #define TPOFFSET (LCD_WIDTH - 1)
   static uint8_t timepos = TPOFFSET - 6;
   static char buffer[8];
-  static lcd_uint_t pc, pr;
 
   #if ENABLED(SHOW_PROGRESS_PERCENT)
+    static lcd_uint_t pc = 0, pr = 2;
+    inline void setPercentPos(const lcd_uint_t c, const lcd_uint_t r) { pc = c; pr = r; }
     void MarlinUI::drawPercent() {
       const uint8_t progress = ui.get_progress_percent();
       if (progress) {
@@ -800,6 +801,7 @@ void MarlinUI::draw_status_message(const bool blink) {
       }
     }
   #endif
+
   #if ENABLED(SHOW_REMAINING_TIME)
     void MarlinUI::drawRemain() {
       if (printJobOngoing()) {
@@ -811,6 +813,7 @@ void MarlinUI::draw_status_message(const bool blink) {
       }
     }
   #endif
+
   #if ENABLED(SHOW_INTERACTION_TIME)
     void MarlinUI::drawInter() {
       const duration_t interactt = ui.interaction_time;
@@ -822,6 +825,7 @@ void MarlinUI::draw_status_message(const bool blink) {
       }
     }
   #endif
+
   #if ENABLED(SHOW_ELAPSED_TIME)
     void MarlinUI::drawElapsed() {
       if (printJobOngoing()) {
@@ -947,7 +951,7 @@ void MarlinUI::draw_status_screen() {
       #if LCD_WIDTH < 20
 
         #if HAS_PRINT_PROGRESS
-          pc = 0; pr = 2;
+          TERN_(SHOW_PROGRESS_PERCENT, setPercentPos(0, 2));
           rotate_progress();
         #endif
 
@@ -1039,7 +1043,7 @@ void MarlinUI::draw_status_screen() {
       #if LCD_WIDTH >= 20
 
         #if HAS_PRINT_PROGRESS
-          pc = 6; pr = 2;
+          TERN_(SHOW_PROGRESS_PERCENT, setPercentPos(6, 2));
           rotate_progress();
         #else
           char c;
@@ -1122,7 +1126,7 @@ void MarlinUI::draw_status_screen() {
       _draw_bed_status(blink);
     #elif HAS_PRINT_PROGRESS
       #define DREW_PRINT_PROGRESS 1
-      pc = 0; pr = 2;
+      TERN_(SHOW_PROGRESS_PERCENT, setPercentPos(0, 2));
       rotate_progress();
     #endif
 
@@ -1130,7 +1134,7 @@ void MarlinUI::draw_status_screen() {
     // All progress strings
     //
     #if HAS_PRINT_PROGRESS && !DREW_PRINT_PROGRESS
-      pc = LCD_WIDTH - 9; pr = 2;
+      TERN_(SHOW_PROGRESS_PERCENT, setPercentPos(LCD_WIDTH - 9, 2));
       rotate_progress();
     #endif
   #endif // LCD_INFO_SCREEN_STYLE 1

commit 4b8e4ef38e1f395d394314f54bacff8def9527c8
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jun 5 23:49:09 2023 -0500

    ‚ö°Ô∏è Mixer label in PROGMEM

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index 51b3fbd3c4..ba467d1a61 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -973,20 +973,20 @@ void MarlinUI::draw_status_screen() {
 
             // Two-component mix / gradient instead of XY
 
-            char mixer_messages[12];
-            const char *mix_label;
+            char mixer_messages[15];
+            PGM_P mix_label;
             #if ENABLED(GRADIENT_MIX)
               if (mixer.gradient.enabled) {
                 mixer.update_mix_from_gradient();
-                mix_label = "Gr";
+                mix_label = PSTR("Gr");
               }
               else
             #endif
               {
                 mixer.update_mix_from_vtool();
-                mix_label = "Mx";
+                mix_label = PSTR("Mx");
               }
-            sprintf_P(mixer_messages, PSTR("%s %d;%d%% "), mix_label, int(mixer.mix[0]), int(mixer.mix[1]));
+            sprintf_P(mixer_messages, PSTR(S_FMT " %d;%d%% "), mix_label, int(mixer.mix[0]), int(mixer.mix[1]));
             lcd_put_u8str(mixer_messages);
 
           #else // !HAS_DUAL_MIXING

commit 86c811660ebf0b3fcbae2f34273d4c9d0c22abc4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:30:34 2023 -0500

    üßë‚Äçüíª Remove LOOP macros (#25917)

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index 55e4d156ea..51b3fbd3c4 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -130,7 +130,7 @@
 
 static void createChar_P(const char c, const byte * const ptr) {
   byte temp[8];
-  LOOP_L_N(i, 8)
+  for (uint8_t i = 0; i < 8; ++i)
     temp[i] = pgm_read_byte(&ptr[i]);
   lcd.createChar(c, temp);
 }
@@ -440,7 +440,7 @@ void MarlinUI::clear_lcd() { lcd.clear(); }
     else {
       PGM_P p = FTOP(ftxt);
       int dly = time / _MAX(slen, 1);
-      LOOP_LE_N(i, slen) {
+      for (uint8_t i = 0; i <= slen; ++i) {
 
         // Print the text at the correct place
         lcd_put_u8str_max_P(col, line, p, len);

commit 2691167afe02fbbe74b0fdca2c28a49fac635741
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:26:02 2023 -0500

    üßë‚Äçüíª Dump BOTH and EITHER macros (#25908)

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index b03ff8a9f5..55e4d156ea 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -41,12 +41,12 @@
 #include "../../module/planner.h"
 #include "../../module/motion.h"
 
-#if DISABLED(LCD_PROGRESS_BAR) && BOTH(FILAMENT_LCD_DISPLAY, HAS_MEDIA)
+#if DISABLED(LCD_PROGRESS_BAR) && ALL(FILAMENT_LCD_DISPLAY, HAS_MEDIA)
   #include "../../feature/filwidth.h"
   #include "../../gcode/parser.h"
 #endif
 
-#if EITHER(HAS_COOLER, LASER_COOLANT_FLOW_METER)
+#if ANY(HAS_COOLER, LASER_COOLANT_FLOW_METER)
   #include "../../feature/cooler.h"
 #endif
 
@@ -70,7 +70,7 @@
 
   LCD_CLASS lcd(LCD_I2C_ADDRESS, LCD_I2C_PIN_EN, LCD_I2C_PIN_RW, LCD_I2C_PIN_RS, LCD_I2C_PIN_D4, LCD_I2C_PIN_D5, LCD_I2C_PIN_D6, LCD_I2C_PIN_D7);
 
-#elif EITHER(LCD_I2C_TYPE_MCP23017, LCD_I2C_TYPE_MCP23008)
+#elif ANY(LCD_I2C_TYPE_MCP23017, LCD_I2C_TYPE_MCP23008)
 
   LCD_CLASS lcd(LCD_I2C_ADDRESS OPTARG(DETECT_I2C_LCD_DEVICE, 1));
 
@@ -305,7 +305,7 @@ void MarlinUI::set_custom_characters(const HD44780CharSet screen_charset/*=CHARS
 
   #endif // LCD_PROGRESS_BAR
 
-  #if BOTH(HAS_MEDIA, HAS_MARLINUI_MENU)
+  #if ALL(HAS_MEDIA, HAS_MARLINUI_MENU)
 
     // CHARSET_MENU
     const static PROGMEM byte refresh[8] = {
@@ -355,7 +355,7 @@ void MarlinUI::set_custom_characters(const HD44780CharSet screen_charset/*=CHARS
       #endif
         {
           createChar_P(LCD_STR_UPLEVEL[0], uplevel);
-          #if BOTH(HAS_MEDIA, HAS_MARLINUI_MENU)
+          #if ALL(HAS_MEDIA, HAS_MARLINUI_MENU)
             // SD Card sub-menu special characters
             createChar_P(LCD_STR_REFRESH[0], refresh);
             createChar_P(LCD_STR_FOLDER[0], folder);
@@ -713,7 +713,7 @@ void MarlinUI::draw_status_message(const bool blink) {
       if (progress > 2) return draw_progress_bar(progress);
     }
 
-  #elif BOTH(FILAMENT_LCD_DISPLAY, HAS_MEDIA)
+  #elif ALL(FILAMENT_LCD_DISPLAY, HAS_MEDIA)
 
     // Alternate Status message and Filament display
     if (ELAPSED(millis(), next_filament_display)) {
@@ -1046,7 +1046,7 @@ void MarlinUI::draw_status_screen() {
           uint16_t per;
           #if HAS_FAN0
             if (true
-              #if BOTH(HAS_EXTRUDERS, ADAPTIVE_FAN_SLOWING)
+              #if ALL(HAS_EXTRUDERS, ADAPTIVE_FAN_SLOWING)
                 && (blink || thermalManager.fan_speed_scaler[0] < 128)
               #endif
             ) {

commit ae3b00db74c63e51e6e73e4a452468dda9abab1f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 21 17:35:41 2023 -0500

    üßë‚Äçüíª Fall back to SPI0 with YHCB2004 (#25856)

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index a0cf5fe46b..b03ff8a9f5 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -103,7 +103,23 @@
 
 #elif ENABLED(YHCB2004)
 
-  LCD_CLASS lcd(YHCB2004_CLK, 20, 4, YHCB2004_MOSI, YHCB2004_MISO); // CLK, cols, rows, MOSI, MISO
+  #ifndef YHCB2004_SS_PIN
+    #define YHCB2004_SS_PIN   SS
+  #endif
+  #ifndef YHCB2004_SCK_PIN
+    #define YHCB2004_SCK_PIN  SCK
+  #endif
+  #ifndef YHCB2004_MOSI_PIN
+    #define YHCB2004_MOSI_PIN MOSI
+  #endif
+  #ifndef YHCB2004_MISO_PIN
+    #define YHCB2004_MISO_PIN MISO
+  #endif
+  #if !PINS_EXIST(YHCB2004_SS, YHCB2004_SCK, YHCB2004_MOSI, YHCB2004_MISO)
+    #error "YHCB2004 display requires YHCB2004_SS_PIN, YHCB2004_SCK_PIN, YHCB2004_MOSI_PIN, and YHCB2004_MISO_PIN."
+  #endif
+
+  LCD_CLASS lcd(YHCB2004_SS_PIN, 20, 4, YHCB2004_SCK_PIN, YHCB2004_MOSI_PIN, YHCB2004_MISO_PIN); // SS, cols, rows, SCK, MOSI, MISO
 
 #else
 

commit 1f9bfc5c7491d802d242623f8253b1f52c0917a3
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Wed May 10 06:59:25 2023 +1200

    üö∏ Optional X-Axis (#25418)
    
    Co-authored-by: alextrical <35117191+alextrical@users.noreply.github.com>
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index 36831767f3..a0cf5fe46b 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -975,7 +975,7 @@ void MarlinUI::draw_status_screen() {
 
           #else // !HAS_DUAL_MIXING
 
-            const bool show_e_total = TERN0(LCD_SHOW_E_TOTAL, printingIsActive());
+            const bool show_e_total = TERN1(HAS_X_AXIS, TERN0(LCD_SHOW_E_TOTAL, printingIsActive()));
 
             if (show_e_total) {
               #if ENABLED(LCD_SHOW_E_TOTAL)
@@ -986,10 +986,14 @@ void MarlinUI::draw_status_screen() {
               #endif
             }
             else {
-              const xy_pos_t lpos = current_position.asLogical();
-              _draw_axis_value(X_AXIS, ftostr4sign(lpos.x), blink);
-              lcd_put_u8str(F(" "));
-              _draw_axis_value(Y_AXIS, ftostr4sign(lpos.y), blink);
+              #if HAS_X_AXIS
+                const xy_pos_t lpos = current_position.asLogical();
+                _draw_axis_value(X_AXIS, ftostr4sign(lpos.x), blink);
+              #endif
+              #if HAS_Y_AXIS
+                TERN_(HAS_X_AXIS, lcd_put_u8str(F(" ")));
+                _draw_axis_value(Y_AXIS, ftostr4sign(lpos.y), blink);
+              #endif
             }
 
           #endif // !HAS_DUAL_MIXING
@@ -1065,8 +1069,10 @@ void MarlinUI::draw_status_screen() {
     //
     // Z Coordinate
     //
-    lcd_moveto(LCD_WIDTH - 9, 0);
-    _draw_axis_value(Z_AXIS, ftostr52sp(LOGICAL_Z_POSITION(current_position.z)), blink);
+    #if HAS_Z_AXIS
+      lcd_moveto(LCD_WIDTH - 9, 0);
+      _draw_axis_value(Z_AXIS, ftostr52sp(LOGICAL_Z_POSITION(current_position.z)), blink);
+    #endif
 
     #if HAS_LEVELING && (HAS_MULTI_HOTEND || !HAS_HEATED_BED)
       lcd_put_lchar(LCD_WIDTH - 1, 0, planner.leveling_active || blink ? '_' : ' ');

commit 10ed5ab01c43a09429e1eb885196308fca71f492
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Apr 23 03:17:55 2023 -0500

    üö∏ Improve PAUSE_PROBE_DEPLOY_WHEN_TRIGGERED (#25681)

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index e33814589c..36831767f3 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -125,7 +125,7 @@ static void createChar_P(const char c, const byte * const ptr) {
 
 #if ENABLED(LCD_USE_I2C_BUZZER)
 
-  void MarlinUI::buzz(const long duration, const uint16_t freq) {
+  void MarlinUI::buzz(const long duration, const uint16_t freq/*=0*/) {
     if (sound_on) lcd.buzz(duration, freq);
   }
 

commit 5664c02d077e028f84a24efd96c2eebe97ce8763
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 22 22:43:09 2023 -0500

    üßë‚Äçüíª Generalize SDSUPPORT as HAS_MEDIA
    
    In preparation for single- and multi-volume refactoring.

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index 8a5e5c5ad9..e33814589c 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -41,7 +41,7 @@
 #include "../../module/planner.h"
 #include "../../module/motion.h"
 
-#if DISABLED(LCD_PROGRESS_BAR) && BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
+#if DISABLED(LCD_PROGRESS_BAR) && BOTH(FILAMENT_LCD_DISPLAY, HAS_MEDIA)
   #include "../../feature/filwidth.h"
   #include "../../gcode/parser.h"
 #endif
@@ -289,7 +289,7 @@ void MarlinUI::set_custom_characters(const HD44780CharSet screen_charset/*=CHARS
 
   #endif // LCD_PROGRESS_BAR
 
-  #if BOTH(SDSUPPORT, HAS_MARLINUI_MENU)
+  #if BOTH(HAS_MEDIA, HAS_MARLINUI_MENU)
 
     // CHARSET_MENU
     const static PROGMEM byte refresh[8] = {
@@ -313,7 +313,7 @@ void MarlinUI::set_custom_characters(const HD44780CharSet screen_charset/*=CHARS
       B00000
     };
 
-  #endif // SDSUPPORT
+  #endif // HAS_MEDIA
 
   #if ENABLED(SHOW_BOOTSCREEN)
     // Set boot screen corner characters
@@ -339,7 +339,7 @@ void MarlinUI::set_custom_characters(const HD44780CharSet screen_charset/*=CHARS
       #endif
         {
           createChar_P(LCD_STR_UPLEVEL[0], uplevel);
-          #if BOTH(SDSUPPORT, HAS_MARLINUI_MENU)
+          #if BOTH(HAS_MEDIA, HAS_MARLINUI_MENU)
             // SD Card sub-menu special characters
             createChar_P(LCD_STR_REFRESH[0], refresh);
             createChar_P(LCD_STR_FOLDER[0], folder);
@@ -697,7 +697,7 @@ void MarlinUI::draw_status_message(const bool blink) {
       if (progress > 2) return draw_progress_bar(progress);
     }
 
-  #elif BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
+  #elif BOTH(FILAMENT_LCD_DISPLAY, HAS_MEDIA)
 
     // Alternate Status message and Filament display
     if (ELAPSED(millis(), next_filament_display)) {
@@ -709,7 +709,7 @@ void MarlinUI::draw_status_message(const bool blink) {
       return;
     }
 
-  #endif // FILAMENT_LCD_DISPLAY && SDSUPPORT
+  #endif // FILAMENT_LCD_DISPLAY && HAS_MEDIA
 
   #if ENABLED(STATUS_MESSAGE_SCROLLING)
     static bool last_blink = false;
@@ -1218,7 +1218,7 @@ void MarlinUI::draw_status_screen() {
     }
   }
 
-  #if ENABLED(SDSUPPORT)
+  #if HAS_MEDIA
 
     void MenuItem_sdbase::draw(const bool sel, const uint8_t row, FSTR_P const, CardReader &theCard, const bool isDir) {
       lcd_put_lchar(0, row, sel ? LCD_STR_ARROW_RIGHT[0] : ' ');

commit 4233e4864f0c621612ce35a9b6ca882312e3aa4d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 22 01:56:10 2023 -0500

    üö∏ MarlinUI Endstop Test Screen, and more (#25667)

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index e4c0317d12..8a5e5c5ad9 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -1137,17 +1137,38 @@ void MarlinUI::draw_status_screen() {
   #endif // ADVANCED_PAUSE_FEATURE
 
   // Draw a static item with no left-right margin required. Centered by default.
-  void MenuItem_static::draw(const uint8_t row, FSTR_P const fstr, const uint8_t style/*=SS_DEFAULT*/, const char * const vstr/*=nullptr*/) {
-    int8_t n = LCD_WIDTH;
+  void MenuItem_static::draw(const uint8_t row, FSTR_P const fstr, const uint8_t style/*=SS_DEFAULT*/, const char *vstr/*=nullptr*/) {
     lcd_moveto(0, row);
+
+    int8_t n = LCD_WIDTH;
+    const bool center = bool(style & SS_CENTER), full = bool(style & SS_FULL);
     const int8_t plen = fstr ? utf8_strlen(fstr) : 0,
                  vlen = vstr ? utf8_strlen(vstr) : 0;
-    if (style & SS_CENTER) {
-      int8_t pad = (LCD_WIDTH - plen - vlen) / 2;
-      while (--pad >= 0) { lcd_put_u8str(F(" ")); n--; }
+    int8_t pad = (center || full) ? n - plen - vlen : 0;
+
+    // SS_CENTER: Pad with half of the unused space first
+    if (center) for (int8_t lpad = pad / 2; lpad > 0; --lpad) { lcd_put_u8str(F(" ")); n--; }
+
+    // Draw as much of the label as fits
+    if (plen) {
+      const int8_t expl = n;
+      n = lcd_put_u8str(fstr, itemIndex, itemStringC, itemStringF, n);
+      pad -= (expl - n - plen); // Reduce the padding
     }
-    if (plen) n = lcd_put_u8str(fstr, itemIndex, itemStringC, itemStringF, n);
-    if (vlen) n -= lcd_put_u8str_max(vstr, n);
+
+    if (vlen && n > 0) {
+      // SS_FULL: Pad with enough space to justify the value
+      if (full && !center) {
+        // Move the leading colon from the value to the label
+        if (*vstr == ':') { n -= lcd_put_u8str(F(":")); vstr++; }
+        // Move spaces to the padding
+        while (*vstr == ' ') { vstr++; pad++; }
+        // Pad in-between
+        for (; pad > 0; --pad) { lcd_put_u8str(F(" ")); n--; }
+      }
+      n -= lcd_put_u8str_max(vstr, n);
+    }
+
     for (; n > 0; --n) lcd_put_u8str(F(" "));
   }
 

commit cd5dc7203ca6340017a4f686a456f5d71792f272
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 8 14:02:14 2023 -0500

    ‚ôªÔ∏è LCD_PINS_ENABLE => LCD_PINS_EN

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index 416c07c8f7..e4c0317d12 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -108,7 +108,7 @@
 #else
 
   // Standard direct-connected LCD implementations
-  LCD_CLASS lcd(LCD_PINS_RS, LCD_PINS_ENABLE, LCD_PINS_D4, LCD_PINS_D5, LCD_PINS_D6, LCD_PINS_D7);
+  LCD_CLASS lcd(LCD_PINS_RS, LCD_PINS_EN, LCD_PINS_D4, LCD_PINS_D5, LCD_PINS_D6, LCD_PINS_D7);
 
 #endif
 

commit 3156595078c4d6ecdae5a5976ef0dbba060fa603
Author: jbubik <jbubik@centrum.cz>
Date:   Tue Mar 14 02:19:24 2023 +0100

    üêõ Fix Polargraph without Z (#25514)

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index 9093fa3eab..416c07c8f7 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -521,7 +521,7 @@ FORCE_INLINE void _draw_axis_value(const AxisEnum axis, const char *value, const
   else if (axis_should_home(axis))
     while (const char c = *value++) lcd_put_lchar(c <= '.' ? c : '?');
   else if (NONE(HOME_AFTER_DEACTIVATE, DISABLE_REDUCED_ACCURACY_WARNING) && !axis_is_trusted(axis))
-    lcd_put_u8str(axis == Z_AXIS ? F("       ") : F("    "));
+    lcd_put_u8str(TERN0(HAS_Z_AXIS, axis == Z_AXIS) ? F("       ") : F("    "));
   else
     lcd_put_u8str(value);
 }
@@ -998,11 +998,12 @@ void MarlinUI::draw_status_screen() {
 
       #endif // LCD_WIDTH >= 20
 
-      lcd_moveto(LCD_WIDTH - 8, 1);
-      _draw_axis_value(Z_AXIS, ftostr52sp(LOGICAL_Z_POSITION(current_position.z)), blink);
-
-      #if HAS_LEVELING && !HAS_HEATED_BED
-        lcd_put_lchar(planner.leveling_active || blink ? '_' : ' ');
+      #if HAS_Z_AXIS
+        lcd_moveto(LCD_WIDTH - 8, 1);
+        _draw_axis_value(Z_AXIS, ftostr52sp(LOGICAL_Z_POSITION(current_position.z)), blink);
+        #if HAS_LEVELING && !HAS_HEATED_BED
+          lcd_put_lchar(planner.leveling_active || blink ? '_' : ' ');
+        #endif
       #endif
 
     #endif // LCD_HEIGHT > 2

commit db01960a0e8a7d37173914c601a9bf413f911a86
Author: Trivalik <3148279+trivalik@users.noreply.github.com>
Date:   Sun Feb 12 05:14:53 2023 +0100

    üö∏ Negative temperature display option (#25036)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index 9445198a22..9093fa3eab 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -537,7 +537,7 @@ FORCE_INLINE void _draw_axis_value(const AxisEnum axis, const char *value, const
  */
 FORCE_INLINE void _draw_heater_status(const heater_id_t heater_id, const char prefix, const bool blink) {
   #if HAS_HEATED_BED
-    const bool isBed = TERN(HAS_HEATED_CHAMBER, heater_id == H_BED, heater_id < 0);
+    const bool isBed = heater_id == H_BED;
     const celsius_t t1 = (isBed ? thermalManager.wholeDegBed()  : thermalManager.wholeDegHotend(heater_id)),
                     t2 = (isBed ? thermalManager.degTargetBed() : thermalManager.degTargetHotend(heater_id));
   #else
@@ -546,7 +546,17 @@ FORCE_INLINE void _draw_heater_status(const heater_id_t heater_id, const char pr
 
   if (prefix >= 0) lcd_put_lchar(prefix);
 
-  lcd_put_u8str(t1 < 0 ? "err" : i16tostr3rj(t1));
+  if (t1 >= 0)
+    lcd_put_u8str(ui16tostr3rj(t1));
+  else {
+    #if ENABLED(SHOW_TEMPERATURE_BELOW_ZERO)
+      char * const str = i16tostr3rj(t1);
+      lcd_put_u8str(&str[1]);
+    #else
+      lcd_put_u8str(F("err"));
+    #endif
+  }
+
   lcd_put_u8str(F("/"));
 
   #if !HEATER_IDLE_HANDLER

commit b169d623e3284846bcda9829b12f20ce90e3762c
Author: EvilGremlin <22657714+EvilGremlin@users.noreply.github.com>
Date:   Thu Dec 8 01:08:53 2022 +0300

    üö∏ Progress display followup (#24879)

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index ffbca8def6..9445198a22 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -760,7 +760,7 @@ void MarlinUI::draw_status_message(const bool blink) {
 #if HAS_PRINT_PROGRESS
   #define TPOFFSET (LCD_WIDTH - 1)
   static uint8_t timepos = TPOFFSET - 6;
-  static char buffer[14];
+  static char buffer[8];
   static lcd_uint_t pc, pr;
 
   #if ENABLED(SHOW_PROGRESS_PERCENT)
@@ -776,9 +776,10 @@ void MarlinUI::draw_status_message(const bool blink) {
   #endif
   #if ENABLED(SHOW_REMAINING_TIME)
     void MarlinUI::drawRemain() {
-      const duration_t remaint = ui.get_remaining_time();
       if (printJobOngoing()) {
+        const duration_t remaint = ui.get_remaining_time();
         timepos = TPOFFSET - remaint.toDigital(buffer);
+        TERN_(NOT(LCD_INFO_SCREEN_STYLE), lcd_put_lchar(timepos - 1, 2, 0x20);)
         lcd_put_lchar(TERN(LCD_INFO_SCREEN_STYLE, 11, timepos), 2, 'R');
         lcd_put_u8str(buffer);
       }
@@ -789,6 +790,7 @@ void MarlinUI::draw_status_message(const bool blink) {
       const duration_t interactt = ui.interaction_time;
       if (printingIsActive() && interactt.value) {
         timepos = TPOFFSET - interactt.toDigital(buffer);
+        TERN_(NOT(LCD_INFO_SCREEN_STYLE), lcd_put_lchar(timepos - 1, 2, 0x20);)
         lcd_put_lchar(TERN(LCD_INFO_SCREEN_STYLE, 11, timepos), 2, 'C');
         lcd_put_u8str(buffer);
       }
@@ -796,11 +798,11 @@ void MarlinUI::draw_status_message(const bool blink) {
   #endif
   #if ENABLED(SHOW_ELAPSED_TIME)
     void MarlinUI::drawElapsed() {
-      const duration_t elapsedt = print_job_timer.duration();
       if (printJobOngoing()) {
+        const duration_t elapsedt = print_job_timer.duration();
         timepos = TPOFFSET - elapsedt.toDigital(buffer);
+        TERN_(NOT(LCD_INFO_SCREEN_STYLE), lcd_put_lchar(timepos - 1, 2, 0x20);)
         lcd_put_lchar(TERN(LCD_INFO_SCREEN_STYLE, 11, timepos), 2, 'E');
-        //lcd_put_lchar(timepos, 2, LCD_STR_CLOCK[0]);
         lcd_put_u8str(buffer);
       }
     }
@@ -919,7 +921,7 @@ void MarlinUI::draw_status_screen() {
       #if LCD_WIDTH < 20
 
         #if HAS_PRINT_PROGRESS
-          pc = 0, pr = 2;
+          pc = 0; pr = 2;
           rotate_progress();
         #endif
 
@@ -1006,14 +1008,14 @@ void MarlinUI::draw_status_screen() {
       #if LCD_WIDTH >= 20
 
         #if HAS_PRINT_PROGRESS
-          pc = timepos - 7, pr = 2;
+          pc = 6; pr = 2;
           rotate_progress();
         #else
           char c;
           uint16_t per;
           #if HAS_FAN0
             if (true
-              #if EXTRUDERS && ENABLED(ADAPTIVE_FAN_SLOWING)
+              #if BOTH(HAS_EXTRUDERS, ADAPTIVE_FAN_SLOWING)
                 && (blink || thermalManager.fan_speed_scaler[0] < 128)
               #endif
             ) {
@@ -1087,7 +1089,7 @@ void MarlinUI::draw_status_screen() {
       _draw_bed_status(blink);
     #elif HAS_PRINT_PROGRESS
       #define DREW_PRINT_PROGRESS 1
-      pc = 0, pr = 2;
+      pc = 0; pr = 2;
       rotate_progress();
     #endif
 
@@ -1095,7 +1097,7 @@ void MarlinUI::draw_status_screen() {
     // All progress strings
     //
     #if HAS_PRINT_PROGRESS && !DREW_PRINT_PROGRESS
-      pc = LCD_WIDTH - 9, pr = 2;
+      pc = LCD_WIDTH - 9; pr = 2;
       rotate_progress();
     #endif
   #endif // LCD_INFO_SCREEN_STYLE 1

commit 50e3e4d8628aeb2e2d106e341b9244e272965796
Author: Thomas Buck <taucher.bodensee@googlemail.com>
Date:   Sun Nov 27 01:59:13 2022 +0100

    üö∏ Optional Cutter/Laser status for HD44780 (#25003)

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index ba222897fc..ffbca8def6 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -58,6 +58,10 @@
   #include "../../feature/bedlevel/bedlevel.h"
 #endif
 
+#if HAS_CUTTER
+  #include "../../feature/spindle_laser.h"
+#endif
+
 //
 // Create LCD instance and chipset-specific information
 //
@@ -406,7 +410,7 @@ void MarlinUI::clear_lcd() { lcd.clear(); }
   void lcd_erase_line(const lcd_uint_t line) {
     lcd_moveto(0, line);
     for (uint8_t i = LCD_WIDTH + 1; --i;)
-      lcd_put_lchar(' ');
+      lcd_put_u8str(F(" "));
   }
 
   // Scroll the PSTR 'text' in a 'len' wide field for 'time' milliseconds at position col,line
@@ -414,7 +418,7 @@ void MarlinUI::clear_lcd() { lcd.clear(); }
     uint8_t slen = utf8_strlen(ftxt);
     if (slen < len) {
       lcd_put_u8str_max(col, line, ftxt, len);
-      for (; slen < len; ++slen) lcd_put_lchar(' ');
+      for (; slen < len; ++slen) lcd_put_u8str(F(" "));
       safe_delay(time);
     }
     else {
@@ -426,7 +430,7 @@ void MarlinUI::clear_lcd() { lcd.clear(); }
         lcd_put_u8str_max_P(col, line, p, len);
 
         // Fill with spaces
-        for (uint8_t ix = slen - i; ix < len; ++ix) lcd_put_lchar(' ');
+        for (uint8_t ix = slen - i; ix < len; ++ix) lcd_put_u8str(F(" "));
 
         // Delay
         safe_delay(dly);
@@ -440,9 +444,9 @@ void MarlinUI::clear_lcd() { lcd.clear(); }
 
   static void logo_lines(FSTR_P const extra) {
     int16_t indent = (LCD_WIDTH - 8 - utf8_strlen(extra)) / 2;
-    lcd_put_lchar(indent, 0, '\x00'); lcd_put_u8str(F( "------" ));  lcd_put_lchar('\x01');
+    lcd_put_lchar(indent, 0, '\x00'); lcd_put_u8str(F( "------" )); lcd_put_u8str(F("\x01"));
     lcd_put_u8str(indent, 1, F("|Marlin|")); lcd_put_u8str(extra);
-    lcd_put_lchar(indent, 2, '\x02'); lcd_put_u8str(F( "------" ));  lcd_put_lchar('\x03');
+    lcd_put_lchar(indent, 2, '\x02'); lcd_put_u8str(F( "------" )); lcd_put_u8str(F("\x03"));
   }
 
   void MarlinUI::show_bootscreen() {
@@ -522,7 +526,15 @@ FORCE_INLINE void _draw_axis_value(const AxisEnum axis, const char *value, const
     lcd_put_u8str(value);
 }
 
-
+/**
+ * @brief Draw current and target for a heater/cooler
+ * @details Print at the current LCD position the current/target for a single heater,
+ *          blinking the target temperature of an idle heater has timed out.
+ *
+ * @param heater_id The heater ID, such as 0, 1, ..., H_BED, H_CHAMBER, etc.
+ * @param prefix A char to draw in front (e.g., a thermometer or icon)
+ * @param blink Flag to show the blink state instead of the regular state
+ */
 FORCE_INLINE void _draw_heater_status(const heater_id_t heater_id, const char prefix, const bool blink) {
   #if HAS_HEATED_BED
     const bool isBed = TERN(HAS_HEATED_CHAMBER, heater_id == H_BED, heater_id < 0);
@@ -535,75 +547,74 @@ FORCE_INLINE void _draw_heater_status(const heater_id_t heater_id, const char pr
   if (prefix >= 0) lcd_put_lchar(prefix);
 
   lcd_put_u8str(t1 < 0 ? "err" : i16tostr3rj(t1));
-  lcd_put_lchar('/');
+  lcd_put_u8str(F("/"));
 
   #if !HEATER_IDLE_HANDLER
     UNUSED(blink);
   #else
-    if (!blink && thermalManager.heater_idle[thermalManager.idle_index_for_id(heater_id)].timed_out) {
-      lcd_put_lchar(' ');
-      if (t2 >= 10) lcd_put_lchar(' ');
-      if (t2 >= 100) lcd_put_lchar(' ');
-    }
+    if (!blink && thermalManager.heater_idle[thermalManager.idle_index_for_id(heater_id)].timed_out)
+      lcd_put_u8str(F("   "));
     else
   #endif
       lcd_put_u8str(i16tostr3left(t2));
 
   if (prefix >= 0) {
     lcd_put_lchar(LCD_STR_DEGREE[0]);
-    lcd_put_lchar(' ');
-    if (t2 < 10) lcd_put_lchar(' ');
+    lcd_put_u8str(F(" "));
+    if (t2 < 10) lcd_put_u8str(F(" "));
   }
 }
 
 #if HAS_COOLER
-FORCE_INLINE void _draw_cooler_status(const char prefix, const bool blink) {
-  const celsius_t t2 = thermalManager.degTargetCooler();
 
-  if (prefix >= 0) lcd_put_lchar(prefix);
+  FORCE_INLINE void _draw_cooler_status(const char prefix, const bool blink) {
+    const celsius_t t2 = thermalManager.degTargetCooler();
 
-  lcd_put_u8str(i16tostr3rj(thermalManager.wholeDegCooler()));
-  lcd_put_lchar('/');
+    if (prefix >= 0) lcd_put_lchar(prefix);
 
-  #if !HEATER_IDLE_HANDLER
-    UNUSED(blink);
-  #else
-    if (!blink && thermalManager.heater_idle[thermalManager.idle_index_for_id(heater_id)].timed_out) {
-      lcd_put_lchar(' ');
-      if (t2 >= 10) lcd_put_lchar(' ');
-      if (t2 >= 100) lcd_put_lchar(' ');
-    }
-    else
-  #endif
-      lcd_put_u8str(i16tostr3left(t2));
+    lcd_put_u8str(i16tostr3rj(thermalManager.wholeDegCooler()));
+    lcd_put_u8str(F("/"));
 
-  if (prefix >= 0) {
-    lcd_put_lchar(LCD_STR_DEGREE[0]);
-    lcd_put_lchar(' ');
-    if (t2 < 10) lcd_put_lchar(' ');
+    #if !HEATER_IDLE_HANDLER
+      UNUSED(blink);
+    #else
+      if (!blink && thermalManager.heater_idle[thermalManager.idle_index_for_id(heater_id)].timed_out) {
+        lcd_put_u8str(F(" "));
+        if (t2 >= 10) lcd_put_u8str(F(" "));
+        if (t2 >= 100) lcd_put_u8str(F(" "));
+      }
+      else
+    #endif
+        lcd_put_u8str(i16tostr3left(t2));
+
+    if (prefix >= 0) {
+      lcd_put_lchar(LCD_STR_DEGREE[0]);
+      lcd_put_u8str(F(" "));
+      if (t2 < 10) lcd_put_u8str(F(" "));
+    }
   }
-}
-#endif
+
+#endif // HAS_COOLER
 
 #if ENABLED(LASER_COOLANT_FLOW_METER)
   FORCE_INLINE void _draw_flowmeter_status() {
-    lcd_put_u8str("~");
+    lcd_put_u8str(F("~"));
     lcd_put_u8str(ftostr11ns(cooler.flowrate));
-    lcd_put_lchar('L');
+    lcd_put_u8str(F("L"));
   }
 #endif
 
 #if ENABLED(I2C_AMMETER)
   FORCE_INLINE void _draw_ammeter_status() {
-    lcd_put_u8str(" ");
+    lcd_put_u8str(F(" "));
     ammeter.read();
     if (ammeter.current <= 0.999f) {
       lcd_put_u8str(ui16tostr3rj(uint16_t(ammeter.current * 1000 + 0.5f)));
-      lcd_put_u8str("mA");
+      lcd_put_u8str(F("mA"));
     }
     else {
       lcd_put_u8str(ftostr12ns(ammeter.current));
-      lcd_put_lchar('A');
+      lcd_put_u8str(F("A"));
     }
   }
 #endif
@@ -612,6 +623,36 @@ FORCE_INLINE void _draw_bed_status(const bool blink) {
   _draw_heater_status(H_BED, TERN0(HAS_LEVELING, blink && planner.leveling_active) ? '_' : LCD_STR_BEDTEMP[0], blink);
 }
 
+#if HAS_CUTTER
+
+  FORCE_INLINE void _draw_cutter_status() {
+    lcd_put_u8str(TERN(LASER_FEATURE, GET_TEXT_F(MSG_LASER), GET_TEXT_F(MSG_CUTTER)));
+    lcd_put_u8str(F(": "));
+
+    #if CUTTER_UNIT_IS(RPM)
+      lcd_put_u8str(ftostr61rj(float(cutter.unitPower) / 1000));
+      lcd_put_u8str(F("K"));
+    #else
+      lcd_put_u8str(cutter_power2str(cutter.unitPower));
+      #if CUTTER_UNIT_IS(PERCENT)
+        lcd_put_u8str(F("%"));
+      #endif
+    #endif
+
+    lcd_put_u8str(F(" "));
+    lcd_put_u8str(cutter.enabled() ? GET_TEXT_F(MSG_LCD_ON) : GET_TEXT_F(MSG_LCD_OFF));
+    lcd_put_u8str(F(" "));
+
+    switch (cutter.cutter_mode) {
+      case CUTTER_MODE_STANDARD:   lcd_put_u8str(F("S")); break;
+      case CUTTER_MODE_CONTINUOUS: lcd_put_u8str(F("C")); break;
+      case CUTTER_MODE_DYNAMIC:    lcd_put_u8str(F("D")); break;
+      case CUTTER_MODE_ERROR:      lcd_put_u8str(F("!")); break;
+    }
+  }
+
+#endif // HAS_CUTTER
+
 #if ENABLED(LCD_PROGRESS_BAR)
 
   void MarlinUI::draw_progress_bar(const uint8_t percent) {
@@ -654,7 +695,7 @@ void MarlinUI::draw_status_message(const bool blink) {
       lcd_put_u8str(ftostr12ns(filwidth.measured_mm));
       lcd_put_u8str(F(" V"));
       lcd_put_u8str(i16tostr3rj(planner.volumetric_percent(parser.volumetric_enabled)));
-      lcd_put_lchar('%');
+      lcd_put_u8str(F("%"));
       return;
     }
 
@@ -673,7 +714,7 @@ void MarlinUI::draw_status_message(const bool blink) {
       lcd_put_u8str(status_message);
 
       // Fill the rest with spaces
-      while (slen < LCD_WIDTH) { lcd_put_lchar(' '); ++slen; }
+      while (slen < LCD_WIDTH) { lcd_put_u8str(F(" ")); ++slen; }
     }
     else {
       // String is larger than the available space in screen.
@@ -687,11 +728,11 @@ void MarlinUI::draw_status_message(const bool blink) {
       // If the remaining string doesn't completely fill the screen
       if (rlen < LCD_WIDTH) {
         uint8_t chars = LCD_WIDTH - rlen;     // Amount of space left in characters
-        lcd_put_lchar(' ');                   // Always at 1+ spaces left, draw a space
+        lcd_put_u8str(F(" "));                   // Always at 1+ spaces left, draw a space
         if (--chars) {                        // Draw a second space if there's room
-          lcd_put_lchar(' ');
+          lcd_put_u8str(F(" "));
           if (--chars) {                      // Draw a third space if there's room
-            lcd_put_lchar(' ');
+            lcd_put_u8str(F(" "));
             if (--chars)
               lcd_put_u8str_max(status_message, chars); // Print a second copy of the message
           }
@@ -712,10 +753,7 @@ void MarlinUI::draw_status_message(const bool blink) {
     lcd_put_u8str_max(status_message, LCD_WIDTH);
 
     // Fill the rest with spaces if there are missing spaces
-    while (slen < LCD_WIDTH) {
-      lcd_put_lchar(' ');
-      ++slen;
-    }
+    for (; slen < LCD_WIDTH; ++slen) lcd_put_u8str(F(" "));
   #endif
 }
 
@@ -732,7 +770,7 @@ void MarlinUI::draw_status_message(const bool blink) {
         lcd_moveto(pc, pr);
         lcd_put_u8str(F(TERN(IS_SD_PRINTING, "SD", "P:")));
         lcd_put_u8str(TERN(PRINT_PROGRESS_SHOW_DECIMALS, permyriadtostr4(ui.get_progress_permyriad()), ui8tostr3rj(progress)));
-        lcd_put_lchar('%');
+        lcd_put_u8str(F("%"));
       }
     }
   #endif
@@ -828,6 +866,15 @@ void MarlinUI::draw_status_screen() {
           lcd_moveto(8, 0);
           _draw_bed_status(blink);
         #endif
+
+      #elif HAS_CUTTER
+
+        //
+        // Cutter Status
+        //
+        lcd_moveto(0, 0);
+        _draw_cutter_status();
+
       #endif
 
     #else // LCD_WIDTH >= 20
@@ -848,6 +895,15 @@ void MarlinUI::draw_status_screen() {
           lcd_moveto(10, 0);
           _draw_bed_status(blink);
         #endif
+
+      #elif HAS_CUTTER
+
+        //
+        // Cutter Status
+        //
+        lcd_moveto(0, 0);
+        _draw_cutter_status();
+
       #endif
 
       TERN_(HAS_COOLER, _draw_cooler_status('*', blink));
@@ -920,7 +976,7 @@ void MarlinUI::draw_status_screen() {
             else {
               const xy_pos_t lpos = current_position.asLogical();
               _draw_axis_value(X_AXIS, ftostr4sign(lpos.x), blink);
-              lcd_put_lchar(' ');
+              lcd_put_u8str(F(" "));
               _draw_axis_value(Y_AXIS, ftostr4sign(lpos.y), blink);
             }
 
@@ -945,7 +1001,7 @@ void MarlinUI::draw_status_screen() {
 
       lcd_put_lchar(0, 2, LCD_STR_FEEDRATE[0]);
       lcd_put_u8str(i16tostr3rj(feedrate_percentage));
-      lcd_put_lchar('%');
+      lcd_put_u8str(F("%"));
 
       #if LCD_WIDTH >= 20
 
@@ -978,7 +1034,7 @@ void MarlinUI::draw_status_screen() {
             }
           lcd_put_lchar(c);
           lcd_put_u8str(i16tostr3rj(per));
-          lcd_put_lchar('%');
+          lcd_put_u8str(F("%"));
         #endif
       #endif
 
@@ -1017,7 +1073,7 @@ void MarlinUI::draw_status_screen() {
 
     lcd_put_lchar(LCD_WIDTH - 9, 1, LCD_STR_FEEDRATE[0]);
     lcd_put_u8str(i16tostr3rj(feedrate_percentage));
-    lcd_put_lchar('%');
+    lcd_put_u8str(F("%"));
 
     // ========== Line 3 ==========
 
@@ -1075,18 +1131,18 @@ void MarlinUI::draw_status_screen() {
                  vlen = vstr ? utf8_strlen(vstr) : 0;
     if (style & SS_CENTER) {
       int8_t pad = (LCD_WIDTH - plen - vlen) / 2;
-      while (--pad >= 0) { lcd_put_lchar(' '); n--; }
+      while (--pad >= 0) { lcd_put_u8str(F(" ")); n--; }
     }
     if (plen) n = lcd_put_u8str(fstr, itemIndex, itemStringC, itemStringF, n);
     if (vlen) n -= lcd_put_u8str_max(vstr, n);
-    for (; n > 0; --n) lcd_put_lchar(' ');
+    for (; n > 0; --n) lcd_put_u8str(F(" "));
   }
 
   // Draw a generic menu item with pre_char (if selected) and post_char
   void MenuItemBase::_draw(const bool sel, const uint8_t row, FSTR_P const ftpl, const char pre_char, const char post_char) {
     lcd_put_lchar(0, row, sel ? pre_char : ' ');
     uint8_t n = lcd_put_u8str(ftpl, itemIndex, itemStringC, itemStringF, LCD_WIDTH - 2);
-    for (; n; --n) lcd_put_lchar(' ');
+    for (; n; --n) lcd_put_u8str(F(" "));
     lcd_put_lchar(post_char);
   }
 
@@ -1096,8 +1152,8 @@ void MarlinUI::draw_status_screen() {
     lcd_put_lchar(0, row, sel ? LCD_STR_ARROW_RIGHT[0] : ' ');
     uint8_t n = lcd_put_u8str(ftpl, itemIndex, itemStringC, itemStringF, LCD_WIDTH - 2 - vlen);
     if (vlen) {
-      lcd_put_lchar(':');
-      for (; n; --n) lcd_put_lchar(' ');
+      lcd_put_u8str(F(":"));
+      for (; n; --n) lcd_put_u8str(F(" "));
       if (pgm) lcd_put_u8str_P(inStr); else lcd_put_u8str(inStr);
     }
   }
@@ -1107,7 +1163,7 @@ void MarlinUI::draw_status_screen() {
     ui.encoder_direction_normal();
     uint8_t n = lcd_put_u8str(0, 1, ftpl, itemIndex, itemStringC, itemStringF, LCD_WIDTH - 1);
     if (value) {
-      lcd_put_lchar(':'); n--;
+      lcd_put_u8str(F(":")); n--;
       const uint8_t len = utf8_strlen(value) + 1;   // Plus one for a leading space
       const lcd_uint_t valrow = n < len ? 2 : 1;    // Value on the next row if it won't fit
       lcd_put_lchar(LCD_WIDTH - len, valrow, ' ');  // Right-justified, padded, leading space
@@ -1134,7 +1190,7 @@ void MarlinUI::draw_status_screen() {
       lcd_put_lchar(0, row, sel ? LCD_STR_ARROW_RIGHT[0] : ' ');
       constexpr uint8_t maxlen = LCD_WIDTH - 2;
       uint8_t n = maxlen - lcd_put_u8str_max(ui.scrolled_filename(theCard, maxlen, row, sel), maxlen);
-      for (; n; --n) lcd_put_lchar(' ');
+      for (; n; --n) lcd_put_u8str(F(" "));
       lcd_put_lchar(isDir ? LCD_STR_FOLDER[0] : ' ');
     }
 
@@ -1466,9 +1522,9 @@ void MarlinUI::draw_status_screen() {
        */
       lcd_put_lchar(_LCD_W_POS, 0, '(');
       lcd_put_u8str(ui8tostr3rj(x_plot));
-      lcd_put_lchar(',');
+      lcd_put_u8str(F(","));
       lcd_put_u8str(ui8tostr3rj(y_plot));
-      lcd_put_lchar(')');
+      lcd_put_u8str(F(")"));
 
       #if LCD_HEIGHT <= 3   // 16x2 or 20x2 display
 

commit f595e40ceb0c79d7f0d6438636658dfcfa2a75b8
Author: EvilGremlin <22657714+EvilGremlin@users.noreply.github.com>
Date:   Sun Oct 9 18:30:47 2022 +0300

    ‚ôªÔ∏è Set Progress without LCD (#24767)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index b8dc8db817..ba222897fc 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -612,20 +612,6 @@ FORCE_INLINE void _draw_bed_status(const bool blink) {
   _draw_heater_status(H_BED, TERN0(HAS_LEVELING, blink && planner.leveling_active) ? '_' : LCD_STR_BEDTEMP[0], blink);
 }
 
-#if HAS_PRINT_PROGRESS
-
-  FORCE_INLINE void _draw_print_progress() {
-    const uint8_t progress = ui.get_progress_percent();
-    lcd_put_u8str(F(TERN(SDSUPPORT, "SD", "P:")));
-    if (progress)
-      lcd_put_u8str(ui8tostr3rj(progress));
-    else
-      lcd_put_u8str(F("---"));
-    lcd_put_lchar('%');
-  }
-
-#endif
-
 #if ENABLED(LCD_PROGRESS_BAR)
 
   void MarlinUI::draw_progress_bar(const uint8_t percent) {
@@ -733,6 +719,56 @@ void MarlinUI::draw_status_message(const bool blink) {
   #endif
 }
 
+#if HAS_PRINT_PROGRESS
+  #define TPOFFSET (LCD_WIDTH - 1)
+  static uint8_t timepos = TPOFFSET - 6;
+  static char buffer[14];
+  static lcd_uint_t pc, pr;
+
+  #if ENABLED(SHOW_PROGRESS_PERCENT)
+    void MarlinUI::drawPercent() {
+      const uint8_t progress = ui.get_progress_percent();
+      if (progress) {
+        lcd_moveto(pc, pr);
+        lcd_put_u8str(F(TERN(IS_SD_PRINTING, "SD", "P:")));
+        lcd_put_u8str(TERN(PRINT_PROGRESS_SHOW_DECIMALS, permyriadtostr4(ui.get_progress_permyriad()), ui8tostr3rj(progress)));
+        lcd_put_lchar('%');
+      }
+    }
+  #endif
+  #if ENABLED(SHOW_REMAINING_TIME)
+    void MarlinUI::drawRemain() {
+      const duration_t remaint = ui.get_remaining_time();
+      if (printJobOngoing()) {
+        timepos = TPOFFSET - remaint.toDigital(buffer);
+        lcd_put_lchar(TERN(LCD_INFO_SCREEN_STYLE, 11, timepos), 2, 'R');
+        lcd_put_u8str(buffer);
+      }
+    }
+  #endif
+  #if ENABLED(SHOW_INTERACTION_TIME)
+    void MarlinUI::drawInter() {
+      const duration_t interactt = ui.interaction_time;
+      if (printingIsActive() && interactt.value) {
+        timepos = TPOFFSET - interactt.toDigital(buffer);
+        lcd_put_lchar(TERN(LCD_INFO_SCREEN_STYLE, 11, timepos), 2, 'C');
+        lcd_put_u8str(buffer);
+      }
+    }
+  #endif
+  #if ENABLED(SHOW_ELAPSED_TIME)
+    void MarlinUI::drawElapsed() {
+      const duration_t elapsedt = print_job_timer.duration();
+      if (printJobOngoing()) {
+        timepos = TPOFFSET - elapsedt.toDigital(buffer);
+        lcd_put_lchar(TERN(LCD_INFO_SCREEN_STYLE, 11, timepos), 2, 'E');
+        //lcd_put_lchar(timepos, 2, LCD_STR_CLOCK[0]);
+        lcd_put_u8str(buffer);
+      }
+    }
+  #endif
+#endif // HAS_PRINT_PROGRESS
+
 /**
  *  LCD_INFO_SCREEN_STYLE 0 : Classic Status Screen
  *
@@ -765,35 +801,6 @@ void MarlinUI::draw_status_message(const bool blink) {
  *  |01234567890123456789|
  */
 
-inline uint8_t draw_elapsed_or_remaining_time(uint8_t timepos, const bool blink) {
-  char buffer[14];
-
-  #if ENABLED(SHOW_REMAINING_TIME)
-    const bool show_remain = TERN1(ROTATE_PROGRESS_DISPLAY, blink) && printingIsActive();
-    if (show_remain) {
-      #if ENABLED(USE_M73_REMAINING_TIME)
-        duration_t remaining = ui.get_remaining_time();
-      #else
-        uint8_t progress = ui.get_progress_percent();
-        uint32_t elapsed = print_job_timer.duration();
-        duration_t remaining = (progress > 0) ? ((elapsed * 25600 / progress) >> 8) - elapsed : 0;
-      #endif
-      timepos -= remaining.toDigital(buffer);
-      lcd_put_lchar(timepos, 2, 'R');
-    }
-  #else
-    constexpr bool show_remain = false;
-  #endif
-
-  if (!show_remain) {
-    duration_t elapsed = print_job_timer.duration();
-    timepos -= elapsed.toDigital(buffer);
-    lcd_put_lchar(timepos, 2, LCD_STR_CLOCK[0]);
-  }
-  lcd_put_u8str(buffer);
-  return timepos;
-}
-
 void MarlinUI::draw_status_screen() {
 
   const bool blink = get_blink();
@@ -856,8 +863,8 @@ void MarlinUI::draw_status_screen() {
       #if LCD_WIDTH < 20
 
         #if HAS_PRINT_PROGRESS
-          lcd_moveto(0, 2);
-          _draw_print_progress();
+          pc = 0, pr = 2;
+          rotate_progress();
         #endif
 
       #else // LCD_WIDTH >= 20
@@ -940,12 +947,11 @@ void MarlinUI::draw_status_screen() {
       lcd_put_u8str(i16tostr3rj(feedrate_percentage));
       lcd_put_lchar('%');
 
-      const uint8_t timepos = draw_elapsed_or_remaining_time(LCD_WIDTH - 1, blink);
-
       #if LCD_WIDTH >= 20
-        lcd_moveto(timepos - 7, 2);
+
         #if HAS_PRINT_PROGRESS
-          _draw_print_progress();
+          pc = timepos - 7, pr = 2;
+          rotate_progress();
         #else
           char c;
           uint16_t per;
@@ -1016,7 +1022,7 @@ void MarlinUI::draw_status_screen() {
     // ========== Line 3 ==========
 
     //
-    // SD Percent, Hotend 2, or Bed
+    // Progress percent, Hotend 2, or Bed
     //
     lcd_moveto(0, 2);
     #if HOTENDS > 2
@@ -1025,24 +1031,17 @@ void MarlinUI::draw_status_screen() {
       _draw_bed_status(blink);
     #elif HAS_PRINT_PROGRESS
       #define DREW_PRINT_PROGRESS 1
-      _draw_print_progress();
+      pc = 0, pr = 2;
+      rotate_progress();
     #endif
 
     //
-    // Elapsed Time or SD Percent
+    // All progress strings
     //
-    lcd_moveto(LCD_WIDTH - 9, 2);
-
     #if HAS_PRINT_PROGRESS && !DREW_PRINT_PROGRESS
-
-      _draw_print_progress();
-
-    #else
-
-      (void)draw_elapsed_or_remaining_time(LCD_WIDTH - 4, blink);
-
+      pc = LCD_WIDTH - 9, pr = 2;
+      rotate_progress();
     #endif
-
   #endif // LCD_INFO_SCREEN_STYLE 1
 
   // ========= Last Line ========

commit 5f2908a117ab45cf9e5a03a39e499979a40bf0f3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jul 18 19:53:36 2022 -0500

    ‚ôªÔ∏è Small sound / buzz refactor (#24520)

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index d8306dbf94..b8dc8db817 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -120,10 +120,11 @@ static void createChar_P(const char c, const byte * const ptr) {
 #endif
 
 #if ENABLED(LCD_USE_I2C_BUZZER)
+
   void MarlinUI::buzz(const long duration, const uint16_t freq) {
-    if (!sound_on) return;
-    lcd.buzz(duration, freq);
+    if (sound_on) lcd.buzz(duration, freq);
   }
+
 #endif
 
 void MarlinUI::set_custom_characters(const HD44780CharSet screen_charset/*=CHARSET_INFO*/) {

commit cb4a79173be3e8ed1ff45e7c346df1c28e744d5a
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jul 1 04:49:37 2022 -0500

    ü©π Remove poison wchar_t macro

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index da4db8b2d4..d8306dbf94 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -405,7 +405,7 @@ void MarlinUI::clear_lcd() { lcd.clear(); }
   void lcd_erase_line(const lcd_uint_t line) {
     lcd_moveto(0, line);
     for (uint8_t i = LCD_WIDTH + 1; --i;)
-      lcd_put_wchar(' ');
+      lcd_put_lchar(' ');
   }
 
   // Scroll the PSTR 'text' in a 'len' wide field for 'time' milliseconds at position col,line
@@ -413,7 +413,7 @@ void MarlinUI::clear_lcd() { lcd.clear(); }
     uint8_t slen = utf8_strlen(ftxt);
     if (slen < len) {
       lcd_put_u8str_max(col, line, ftxt, len);
-      for (; slen < len; ++slen) lcd_put_wchar(' ');
+      for (; slen < len; ++slen) lcd_put_lchar(' ');
       safe_delay(time);
     }
     else {
@@ -425,7 +425,7 @@ void MarlinUI::clear_lcd() { lcd.clear(); }
         lcd_put_u8str_max_P(col, line, p, len);
 
         // Fill with spaces
-        for (uint8_t ix = slen - i; ix < len; ++ix) lcd_put_wchar(' ');
+        for (uint8_t ix = slen - i; ix < len; ++ix) lcd_put_lchar(' ');
 
         // Delay
         safe_delay(dly);
@@ -439,9 +439,9 @@ void MarlinUI::clear_lcd() { lcd.clear(); }
 
   static void logo_lines(FSTR_P const extra) {
     int16_t indent = (LCD_WIDTH - 8 - utf8_strlen(extra)) / 2;
-    lcd_put_wchar(indent, 0, '\x00'); lcd_put_u8str(F( "------" ));  lcd_put_wchar('\x01');
+    lcd_put_lchar(indent, 0, '\x00'); lcd_put_u8str(F( "------" ));  lcd_put_lchar('\x01');
     lcd_put_u8str(indent, 1, F("|Marlin|")); lcd_put_u8str(extra);
-    lcd_put_wchar(indent, 2, '\x02'); lcd_put_u8str(F( "------" ));  lcd_put_wchar('\x03');
+    lcd_put_lchar(indent, 2, '\x02'); lcd_put_u8str(F( "------" ));  lcd_put_lchar('\x03');
   }
 
   void MarlinUI::show_bootscreen() {
@@ -510,11 +510,11 @@ void MarlinUI::draw_kill_screen() {
 // Homed and known, display constantly.
 //
 FORCE_INLINE void _draw_axis_value(const AxisEnum axis, const char *value, const bool blink) {
-  lcd_put_wchar('X' + uint8_t(axis));
+  lcd_put_lchar('X' + uint8_t(axis));
   if (blink)
     lcd_put_u8str(value);
   else if (axis_should_home(axis))
-    while (const char c = *value++) lcd_put_wchar(c <= '.' ? c : '?');
+    while (const char c = *value++) lcd_put_lchar(c <= '.' ? c : '?');
   else if (NONE(HOME_AFTER_DEACTIVATE, DISABLE_REDUCED_ACCURACY_WARNING) && !axis_is_trusted(axis))
     lcd_put_u8str(axis == Z_AXIS ? F("       ") : F("    "));
   else
@@ -531,27 +531,27 @@ FORCE_INLINE void _draw_heater_status(const heater_id_t heater_id, const char pr
     const celsius_t t1 = thermalManager.wholeDegHotend(heater_id), t2 = thermalManager.degTargetHotend(heater_id);
   #endif
 
-  if (prefix >= 0) lcd_put_wchar(prefix);
+  if (prefix >= 0) lcd_put_lchar(prefix);
 
   lcd_put_u8str(t1 < 0 ? "err" : i16tostr3rj(t1));
-  lcd_put_wchar('/');
+  lcd_put_lchar('/');
 
   #if !HEATER_IDLE_HANDLER
     UNUSED(blink);
   #else
     if (!blink && thermalManager.heater_idle[thermalManager.idle_index_for_id(heater_id)].timed_out) {
-      lcd_put_wchar(' ');
-      if (t2 >= 10) lcd_put_wchar(' ');
-      if (t2 >= 100) lcd_put_wchar(' ');
+      lcd_put_lchar(' ');
+      if (t2 >= 10) lcd_put_lchar(' ');
+      if (t2 >= 100) lcd_put_lchar(' ');
     }
     else
   #endif
       lcd_put_u8str(i16tostr3left(t2));
 
   if (prefix >= 0) {
-    lcd_put_wchar(LCD_STR_DEGREE[0]);
-    lcd_put_wchar(' ');
-    if (t2 < 10) lcd_put_wchar(' ');
+    lcd_put_lchar(LCD_STR_DEGREE[0]);
+    lcd_put_lchar(' ');
+    if (t2 < 10) lcd_put_lchar(' ');
   }
 }
 
@@ -559,27 +559,27 @@ FORCE_INLINE void _draw_heater_status(const heater_id_t heater_id, const char pr
 FORCE_INLINE void _draw_cooler_status(const char prefix, const bool blink) {
   const celsius_t t2 = thermalManager.degTargetCooler();
 
-  if (prefix >= 0) lcd_put_wchar(prefix);
+  if (prefix >= 0) lcd_put_lchar(prefix);
 
   lcd_put_u8str(i16tostr3rj(thermalManager.wholeDegCooler()));
-  lcd_put_wchar('/');
+  lcd_put_lchar('/');
 
   #if !HEATER_IDLE_HANDLER
     UNUSED(blink);
   #else
     if (!blink && thermalManager.heater_idle[thermalManager.idle_index_for_id(heater_id)].timed_out) {
-      lcd_put_wchar(' ');
-      if (t2 >= 10) lcd_put_wchar(' ');
-      if (t2 >= 100) lcd_put_wchar(' ');
+      lcd_put_lchar(' ');
+      if (t2 >= 10) lcd_put_lchar(' ');
+      if (t2 >= 100) lcd_put_lchar(' ');
     }
     else
   #endif
       lcd_put_u8str(i16tostr3left(t2));
 
   if (prefix >= 0) {
-    lcd_put_wchar(LCD_STR_DEGREE[0]);
-    lcd_put_wchar(' ');
-    if (t2 < 10) lcd_put_wchar(' ');
+    lcd_put_lchar(LCD_STR_DEGREE[0]);
+    lcd_put_lchar(' ');
+    if (t2 < 10) lcd_put_lchar(' ');
   }
 }
 #endif
@@ -588,7 +588,7 @@ FORCE_INLINE void _draw_cooler_status(const char prefix, const bool blink) {
   FORCE_INLINE void _draw_flowmeter_status() {
     lcd_put_u8str("~");
     lcd_put_u8str(ftostr11ns(cooler.flowrate));
-    lcd_put_wchar('L');
+    lcd_put_lchar('L');
   }
 #endif
 
@@ -602,7 +602,7 @@ FORCE_INLINE void _draw_cooler_status(const char prefix, const bool blink) {
     }
     else {
       lcd_put_u8str(ftostr12ns(ammeter.current));
-      lcd_put_wchar('A');
+      lcd_put_lchar('A');
     }
   }
 #endif
@@ -620,7 +620,7 @@ FORCE_INLINE void _draw_bed_status(const bool blink) {
       lcd_put_u8str(ui8tostr3rj(progress));
     else
       lcd_put_u8str(F("---"));
-    lcd_put_wchar('%');
+    lcd_put_lchar('%');
   }
 
 #endif
@@ -667,7 +667,7 @@ void MarlinUI::draw_status_message(const bool blink) {
       lcd_put_u8str(ftostr12ns(filwidth.measured_mm));
       lcd_put_u8str(F(" V"));
       lcd_put_u8str(i16tostr3rj(planner.volumetric_percent(parser.volumetric_enabled)));
-      lcd_put_wchar('%');
+      lcd_put_lchar('%');
       return;
     }
 
@@ -686,7 +686,7 @@ void MarlinUI::draw_status_message(const bool blink) {
       lcd_put_u8str(status_message);
 
       // Fill the rest with spaces
-      while (slen < LCD_WIDTH) { lcd_put_wchar(' '); ++slen; }
+      while (slen < LCD_WIDTH) { lcd_put_lchar(' '); ++slen; }
     }
     else {
       // String is larger than the available space in screen.
@@ -700,11 +700,11 @@ void MarlinUI::draw_status_message(const bool blink) {
       // If the remaining string doesn't completely fill the screen
       if (rlen < LCD_WIDTH) {
         uint8_t chars = LCD_WIDTH - rlen;     // Amount of space left in characters
-        lcd_put_wchar(' ');                   // Always at 1+ spaces left, draw a space
+        lcd_put_lchar(' ');                   // Always at 1+ spaces left, draw a space
         if (--chars) {                        // Draw a second space if there's room
-          lcd_put_wchar(' ');
+          lcd_put_lchar(' ');
           if (--chars) {                      // Draw a third space if there's room
-            lcd_put_wchar(' ');
+            lcd_put_lchar(' ');
             if (--chars)
               lcd_put_u8str_max(status_message, chars); // Print a second copy of the message
           }
@@ -726,7 +726,7 @@ void MarlinUI::draw_status_message(const bool blink) {
 
     // Fill the rest with spaces if there are missing spaces
     while (slen < LCD_WIDTH) {
-      lcd_put_wchar(' ');
+      lcd_put_lchar(' ');
       ++slen;
     }
   #endif
@@ -778,7 +778,7 @@ inline uint8_t draw_elapsed_or_remaining_time(uint8_t timepos, const bool blink)
         duration_t remaining = (progress > 0) ? ((elapsed * 25600 / progress) >> 8) - elapsed : 0;
       #endif
       timepos -= remaining.toDigital(buffer);
-      lcd_put_wchar(timepos, 2, 'R');
+      lcd_put_lchar(timepos, 2, 'R');
     }
   #else
     constexpr bool show_remain = false;
@@ -787,7 +787,7 @@ inline uint8_t draw_elapsed_or_remaining_time(uint8_t timepos, const bool blink)
   if (!show_remain) {
     duration_t elapsed = print_job_timer.duration();
     timepos -= elapsed.toDigital(buffer);
-    lcd_put_wchar(timepos, 2, LCD_STR_CLOCK[0]);
+    lcd_put_lchar(timepos, 2, LCD_STR_CLOCK[0]);
   }
   lcd_put_u8str(buffer);
   return timepos;
@@ -912,7 +912,7 @@ void MarlinUI::draw_status_screen() {
             else {
               const xy_pos_t lpos = current_position.asLogical();
               _draw_axis_value(X_AXIS, ftostr4sign(lpos.x), blink);
-              lcd_put_wchar(' ');
+              lcd_put_lchar(' ');
               _draw_axis_value(Y_AXIS, ftostr4sign(lpos.y), blink);
             }
 
@@ -926,7 +926,7 @@ void MarlinUI::draw_status_screen() {
       _draw_axis_value(Z_AXIS, ftostr52sp(LOGICAL_Z_POSITION(current_position.z)), blink);
 
       #if HAS_LEVELING && !HAS_HEATED_BED
-        lcd_put_wchar(planner.leveling_active || blink ? '_' : ' ');
+        lcd_put_lchar(planner.leveling_active || blink ? '_' : ' ');
       #endif
 
     #endif // LCD_HEIGHT > 2
@@ -935,9 +935,9 @@ void MarlinUI::draw_status_screen() {
 
     #if LCD_HEIGHT > 3
 
-      lcd_put_wchar(0, 2, LCD_STR_FEEDRATE[0]);
+      lcd_put_lchar(0, 2, LCD_STR_FEEDRATE[0]);
       lcd_put_u8str(i16tostr3rj(feedrate_percentage));
-      lcd_put_wchar('%');
+      lcd_put_lchar('%');
 
       const uint8_t timepos = draw_elapsed_or_remaining_time(LCD_WIDTH - 1, blink);
 
@@ -969,9 +969,9 @@ void MarlinUI::draw_status_screen() {
                 per = planner.flow_percentage[0];
               #endif
             }
-          lcd_put_wchar(c);
+          lcd_put_lchar(c);
           lcd_put_u8str(i16tostr3rj(per));
-          lcd_put_wchar('%');
+          lcd_put_lchar('%');
         #endif
       #endif
 
@@ -993,7 +993,7 @@ void MarlinUI::draw_status_screen() {
     _draw_axis_value(Z_AXIS, ftostr52sp(LOGICAL_Z_POSITION(current_position.z)), blink);
 
     #if HAS_LEVELING && (HAS_MULTI_HOTEND || !HAS_HEATED_BED)
-      lcd_put_wchar(LCD_WIDTH - 1, 0, planner.leveling_active || blink ? '_' : ' ');
+      lcd_put_lchar(LCD_WIDTH - 1, 0, planner.leveling_active || blink ? '_' : ' ');
     #endif
 
     // ========== Line 2 ==========
@@ -1008,9 +1008,9 @@ void MarlinUI::draw_status_screen() {
       _draw_bed_status(blink);
     #endif
 
-    lcd_put_wchar(LCD_WIDTH - 9, 1, LCD_STR_FEEDRATE[0]);
+    lcd_put_lchar(LCD_WIDTH - 9, 1, LCD_STR_FEEDRATE[0]);
     lcd_put_u8str(i16tostr3rj(feedrate_percentage));
-    lcd_put_wchar('%');
+    lcd_put_lchar('%');
 
     // ========== Line 3 ==========
 
@@ -1075,29 +1075,29 @@ void MarlinUI::draw_status_screen() {
                  vlen = vstr ? utf8_strlen(vstr) : 0;
     if (style & SS_CENTER) {
       int8_t pad = (LCD_WIDTH - plen - vlen) / 2;
-      while (--pad >= 0) { lcd_put_wchar(' '); n--; }
+      while (--pad >= 0) { lcd_put_lchar(' '); n--; }
     }
     if (plen) n = lcd_put_u8str(fstr, itemIndex, itemStringC, itemStringF, n);
     if (vlen) n -= lcd_put_u8str_max(vstr, n);
-    for (; n > 0; --n) lcd_put_wchar(' ');
+    for (; n > 0; --n) lcd_put_lchar(' ');
   }
 
   // Draw a generic menu item with pre_char (if selected) and post_char
   void MenuItemBase::_draw(const bool sel, const uint8_t row, FSTR_P const ftpl, const char pre_char, const char post_char) {
-    lcd_put_wchar(0, row, sel ? pre_char : ' ');
+    lcd_put_lchar(0, row, sel ? pre_char : ' ');
     uint8_t n = lcd_put_u8str(ftpl, itemIndex, itemStringC, itemStringF, LCD_WIDTH - 2);
-    for (; n; --n) lcd_put_wchar(' ');
-    lcd_put_wchar(post_char);
+    for (; n; --n) lcd_put_lchar(' ');
+    lcd_put_lchar(post_char);
   }
 
   // Draw a menu item with a (potentially) editable value
   void MenuEditItemBase::draw(const bool sel, const uint8_t row, FSTR_P const ftpl, const char * const inStr, const bool pgm) {
     const uint8_t vlen = inStr ? (pgm ? utf8_strlen_P(inStr) : utf8_strlen(inStr)) : 0;
-    lcd_put_wchar(0, row, sel ? LCD_STR_ARROW_RIGHT[0] : ' ');
+    lcd_put_lchar(0, row, sel ? LCD_STR_ARROW_RIGHT[0] : ' ');
     uint8_t n = lcd_put_u8str(ftpl, itemIndex, itemStringC, itemStringF, LCD_WIDTH - 2 - vlen);
     if (vlen) {
-      lcd_put_wchar(':');
-      for (; n; --n) lcd_put_wchar(' ');
+      lcd_put_lchar(':');
+      for (; n; --n) lcd_put_lchar(' ');
       if (pgm) lcd_put_u8str_P(inStr); else lcd_put_u8str(inStr);
     }
   }
@@ -1107,10 +1107,10 @@ void MarlinUI::draw_status_screen() {
     ui.encoder_direction_normal();
     uint8_t n = lcd_put_u8str(0, 1, ftpl, itemIndex, itemStringC, itemStringF, LCD_WIDTH - 1);
     if (value) {
-      lcd_put_wchar(':'); n--;
+      lcd_put_lchar(':'); n--;
       const uint8_t len = utf8_strlen(value) + 1;   // Plus one for a leading space
       const lcd_uint_t valrow = n < len ? 2 : 1;    // Value on the next row if it won't fit
-      lcd_put_wchar(LCD_WIDTH - len, valrow, ' ');  // Right-justified, padded, leading space
+      lcd_put_lchar(LCD_WIDTH - len, valrow, ' ');  // Right-justified, padded, leading space
       lcd_put_u8str(value);
     }
   }
@@ -1120,22 +1120,22 @@ void MarlinUI::draw_status_screen() {
     ui.draw_select_screen_prompt(pref, string, suff);
     if (no) {
       SETCURSOR(0, LCD_HEIGHT - 1);
-      lcd_put_wchar(yesno ? ' ' : '['); lcd_put_u8str(no); lcd_put_wchar(yesno ? ' ' : ']');
+      lcd_put_lchar(yesno ? ' ' : '['); lcd_put_u8str(no); lcd_put_lchar(yesno ? ' ' : ']');
     }
     if (yes) {
       SETCURSOR_RJ(utf8_strlen(yes) + 2, LCD_HEIGHT - 1);
-      lcd_put_wchar(yesno ? '[' : ' '); lcd_put_u8str(yes); lcd_put_wchar(yesno ? ']' : ' ');
+      lcd_put_lchar(yesno ? '[' : ' '); lcd_put_u8str(yes); lcd_put_lchar(yesno ? ']' : ' ');
     }
   }
 
   #if ENABLED(SDSUPPORT)
 
     void MenuItem_sdbase::draw(const bool sel, const uint8_t row, FSTR_P const, CardReader &theCard, const bool isDir) {
-      lcd_put_wchar(0, row, sel ? LCD_STR_ARROW_RIGHT[0] : ' ');
+      lcd_put_lchar(0, row, sel ? LCD_STR_ARROW_RIGHT[0] : ' ');
       constexpr uint8_t maxlen = LCD_WIDTH - 2;
       uint8_t n = maxlen - lcd_put_u8str_max(ui.scrolled_filename(theCard, maxlen, row, sel), maxlen);
-      for (; n; --n) lcd_put_wchar(' ');
-      lcd_put_wchar(isDir ? LCD_STR_FOLDER[0] : ' ');
+      for (; n; --n) lcd_put_lchar(' ');
+      lcd_put_lchar(isDir ? LCD_STR_FOLDER[0] : ' ');
     }
 
   #endif
@@ -1253,7 +1253,7 @@ void MarlinUI::draw_status_screen() {
     void prep_and_put_map_char(custom_char &chrdata, const coordinate &ul, const coordinate &lr, const coordinate &brc, const uint8_t cl, const char c, const lcd_uint_t x, const lcd_uint_t y) {
       add_edges_to_custom_char(chrdata, ul, lr, brc, cl);
       lcd.createChar(c, (uint8_t*)&chrdata);
-      lcd_put_wchar(x, y, c);
+      lcd_put_lchar(x, y, c);
     }
 
     void MarlinUI::ubl_plot(const uint8_t x_plot, const uint8_t y_plot) {
@@ -1270,7 +1270,7 @@ void MarlinUI::draw_status_screen() {
         #define _LCD_W_POS 8
         #define _PLOT_X 0
         #define _MAP_X 1
-        #define _LABEL(X,Y,C) lcd_put_wchar(X, Y, C)
+        #define _LABEL(X,Y,C) lcd_put_lchar(X, Y, C)
         #define _XLABEL(X,Y) _LABEL('X',X,Y)
         #define _YLABEL(X,Y) _LABEL('Y',X,Y)
         #define _ZLABEL(X,Y) _LABEL('Z',X,Y)
@@ -1333,13 +1333,13 @@ void MarlinUI::draw_status_screen() {
         n_cols = right_edge / (HD44780_CHAR_WIDTH) + 1;
 
         for (i = 0; i < n_cols; i++) {
-          lcd_put_wchar(i, 0, CHAR_LINE_TOP);                               // Box Top line
-          lcd_put_wchar(i, n_rows - 1, CHAR_LINE_BOT);                      // Box Bottom line
+          lcd_put_lchar(i, 0, CHAR_LINE_TOP);                               // Box Top line
+          lcd_put_lchar(i, n_rows - 1, CHAR_LINE_BOT);                      // Box Bottom line
         }
 
         for (j = 0; j < n_rows; j++) {
-          lcd_put_wchar(0, j, CHAR_EDGE_L);                                 // Box Left edge
-          lcd_put_wchar(n_cols - 1, j, CHAR_EDGE_R);                        // Box Right edge
+          lcd_put_lchar(0, j, CHAR_EDGE_L);                                 // Box Left edge
+          lcd_put_lchar(n_cols - 1, j, CHAR_EDGE_R);                        // Box Right edge
         }
 
         /**
@@ -1349,8 +1349,8 @@ void MarlinUI::draw_status_screen() {
         k = pixels_per_y_mesh_pnt * (GRID_MAX_POINTS_Y) + 2;
         l = (HD44780_CHAR_HEIGHT) * n_rows;
         if (l > k && l - k >= (HD44780_CHAR_HEIGHT) / 2) {
-          lcd_put_wchar(0, n_rows - 1, ' ');                                // Box Left edge
-          lcd_put_wchar(n_cols - 1, n_rows - 1, ' ');                       // Box Right edge
+          lcd_put_lchar(0, n_rows - 1, ' ');                                // Box Left edge
+          lcd_put_lchar(n_cols - 1, n_rows - 1, ' ');                       // Box Right edge
         }
 
         clear_custom_char(&new_char);
@@ -1464,11 +1464,11 @@ void MarlinUI::draw_status_screen() {
       /**
        * Print plot position
        */
-      lcd_put_wchar(_LCD_W_POS, 0, '(');
+      lcd_put_lchar(_LCD_W_POS, 0, '(');
       lcd_put_u8str(ui8tostr3rj(x_plot));
-      lcd_put_wchar(',');
+      lcd_put_lchar(',');
       lcd_put_u8str(ui8tostr3rj(y_plot));
-      lcd_put_wchar(')');
+      lcd_put_lchar(')');
 
       #if LCD_HEIGHT <= 3   // 16x2 or 20x2 display
 

commit 8aca38351cd6d33a1202bf9a13890dc8e5eadd49
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 3 22:56:38 2022 -0500

    üßë‚Äçüíª Extend LCD string substitution (#24278)

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index f70b5b0174..da4db8b2d4 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -495,12 +495,13 @@ void MarlinUI::clear_lcd() { lcd.clear(); }
 #endif // SHOW_BOOTSCREEN
 
 void MarlinUI::draw_kill_screen() {
-  lcd_put_u8str(0, 0, status_message);
-  lcd_uint_t y = 2;
+  lcd_uint_t x = 0, y = 0;
+  lcd_put_u8str(x, y, status_message);
+  y = 2;
   #if LCD_HEIGHT >= 4
-    lcd_put_u8str(0, y++, GET_TEXT_F(MSG_HALTED));
+    lcd_put_u8str(x, y++, GET_TEXT_F(MSG_HALTED));
   #endif
-  lcd_put_u8str(0, y, GET_TEXT_F(MSG_PLEASE_RESET));
+  lcd_put_u8str(x, y, GET_TEXT_F(MSG_PLEASE_RESET));
 }
 
 //
@@ -1076,24 +1077,24 @@ void MarlinUI::draw_status_screen() {
       int8_t pad = (LCD_WIDTH - plen - vlen) / 2;
       while (--pad >= 0) { lcd_put_wchar(' '); n--; }
     }
-    if (plen) n = lcd_put_u8str_ind(fstr, itemIndex, itemString, n);
+    if (plen) n = lcd_put_u8str(fstr, itemIndex, itemStringC, itemStringF, n);
     if (vlen) n -= lcd_put_u8str_max(vstr, n);
     for (; n > 0; --n) lcd_put_wchar(' ');
   }
 
   // Draw a generic menu item with pre_char (if selected) and post_char
-  void MenuItemBase::_draw(const bool sel, const uint8_t row, FSTR_P const fstr, const char pre_char, const char post_char) {
+  void MenuItemBase::_draw(const bool sel, const uint8_t row, FSTR_P const ftpl, const char pre_char, const char post_char) {
     lcd_put_wchar(0, row, sel ? pre_char : ' ');
-    uint8_t n = lcd_put_u8str_ind(fstr, itemIndex, itemString, LCD_WIDTH - 2);
+    uint8_t n = lcd_put_u8str(ftpl, itemIndex, itemStringC, itemStringF, LCD_WIDTH - 2);
     for (; n; --n) lcd_put_wchar(' ');
     lcd_put_wchar(post_char);
   }
 
   // Draw a menu item with a (potentially) editable value
-  void MenuEditItemBase::draw(const bool sel, const uint8_t row, FSTR_P const fstr, const char * const inStr, const bool pgm) {
+  void MenuEditItemBase::draw(const bool sel, const uint8_t row, FSTR_P const ftpl, const char * const inStr, const bool pgm) {
     const uint8_t vlen = inStr ? (pgm ? utf8_strlen_P(inStr) : utf8_strlen(inStr)) : 0;
     lcd_put_wchar(0, row, sel ? LCD_STR_ARROW_RIGHT[0] : ' ');
-    uint8_t n = lcd_put_u8str_ind(fstr, itemIndex, itemString, LCD_WIDTH - 2 - vlen);
+    uint8_t n = lcd_put_u8str(ftpl, itemIndex, itemStringC, itemStringF, LCD_WIDTH - 2 - vlen);
     if (vlen) {
       lcd_put_wchar(':');
       for (; n; --n) lcd_put_wchar(' ');
@@ -1102,9 +1103,9 @@ void MarlinUI::draw_status_screen() {
   }
 
   // Low-level draw_edit_screen can be used to draw an edit screen from anyplace
-  void MenuEditItemBase::draw_edit_screen(FSTR_P const fstr, const char * const value/*=nullptr*/) {
+  void MenuEditItemBase::draw_edit_screen(FSTR_P const ftpl, const char * const value/*=nullptr*/) {
     ui.encoder_direction_normal();
-    uint8_t n = lcd_put_u8str_ind(0, 1, fstr, itemIndex, itemString, LCD_WIDTH - 1);
+    uint8_t n = lcd_put_u8str(0, 1, ftpl, itemIndex, itemStringC, itemStringF, LCD_WIDTH - 1);
     if (value) {
       lcd_put_wchar(':'); n--;
       const uint8_t len = utf8_strlen(value) + 1;   // Plus one for a leading space

commit a5e1d4c50ae40c8203d8490be83ef86e16ebf1c2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 22 19:56:46 2022 -0500

    ‚ôªÔ∏è Apply F() to more LCD code (#24228)

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index 6c6ff47377..f70b5b0174 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -410,7 +410,7 @@ void MarlinUI::clear_lcd() { lcd.clear(); }
 
   // Scroll the PSTR 'text' in a 'len' wide field for 'time' milliseconds at position col,line
   void lcd_scroll(const lcd_uint_t col, const lcd_uint_t line, FSTR_P const ftxt, const uint8_t len, const int16_t time) {
-    uint8_t slen = utf8_strlen_P(FTOP(ftxt));
+    uint8_t slen = utf8_strlen(ftxt);
     if (slen < len) {
       lcd_put_u8str_max(col, line, ftxt, len);
       for (; slen < len; ++slen) lcd_put_wchar(' ');
@@ -437,10 +437,10 @@ void MarlinUI::clear_lcd() { lcd.clear(); }
     }
   }
 
-  static void logo_lines(PGM_P const extra) {
-    int16_t indent = (LCD_WIDTH - 8 - utf8_strlen_P(extra)) / 2;
+  static void logo_lines(FSTR_P const extra) {
+    int16_t indent = (LCD_WIDTH - 8 - utf8_strlen(extra)) / 2;
     lcd_put_wchar(indent, 0, '\x00'); lcd_put_u8str(F( "------" ));  lcd_put_wchar('\x01');
-    lcd_put_u8str(indent, 1, F("|Marlin|"));  lcd_put_u8str_P(extra);
+    lcd_put_u8str(indent, 1, F("|Marlin|")); lcd_put_u8str(extra);
     lcd_put_wchar(indent, 2, '\x02'); lcd_put_u8str(F( "------" ));  lcd_put_wchar('\x03');
   }
 
@@ -468,7 +468,7 @@ void MarlinUI::clear_lcd() { lcd.clear(); }
       //
       // Show the Marlin logo, splash line1, and splash line 2
       //
-      logo_lines(PSTR(" " SHORT_BUILD_VERSION));
+      logo_lines(F(" " SHORT_BUILD_VERSION));
       CENTER_OR_SCROLL(MARLIN_WEBSITE_URL, 2000);
     }
     else {
@@ -476,7 +476,7 @@ void MarlinUI::clear_lcd() { lcd.clear(); }
       // Show the Marlin logo and short build version
       // After a delay show the website URL
       //
-      logo_lines(NUL_STR);
+      logo_lines(FPSTR(NUL_STR));
       CENTER_OR_SCROLL(SHORT_BUILD_VERSION, 1500);
       CENTER_OR_SCROLL(MARLIN_WEBSITE_URL, 1500);
       #ifdef STRING_SPLASH_LINE3
@@ -1067,33 +1067,33 @@ void MarlinUI::draw_status_screen() {
   #endif // ADVANCED_PAUSE_FEATURE
 
   // Draw a static item with no left-right margin required. Centered by default.
-  void MenuItem_static::draw(const uint8_t row, PGM_P const pstr, const uint8_t style/*=SS_DEFAULT*/, const char * const vstr/*=nullptr*/) {
+  void MenuItem_static::draw(const uint8_t row, FSTR_P const fstr, const uint8_t style/*=SS_DEFAULT*/, const char * const vstr/*=nullptr*/) {
     int8_t n = LCD_WIDTH;
     lcd_moveto(0, row);
-    const int8_t plen = pstr ? utf8_strlen_P(pstr) : 0,
+    const int8_t plen = fstr ? utf8_strlen(fstr) : 0,
                  vlen = vstr ? utf8_strlen(vstr) : 0;
     if (style & SS_CENTER) {
       int8_t pad = (LCD_WIDTH - plen - vlen) / 2;
       while (--pad >= 0) { lcd_put_wchar(' '); n--; }
     }
-    if (plen) n = lcd_put_u8str_ind_P(pstr, itemIndex, itemString, n);
+    if (plen) n = lcd_put_u8str_ind(fstr, itemIndex, itemString, n);
     if (vlen) n -= lcd_put_u8str_max(vstr, n);
     for (; n > 0; --n) lcd_put_wchar(' ');
   }
 
   // Draw a generic menu item with pre_char (if selected) and post_char
-  void MenuItemBase::_draw(const bool sel, const uint8_t row, PGM_P const pstr, const char pre_char, const char post_char) {
+  void MenuItemBase::_draw(const bool sel, const uint8_t row, FSTR_P const fstr, const char pre_char, const char post_char) {
     lcd_put_wchar(0, row, sel ? pre_char : ' ');
-    uint8_t n = lcd_put_u8str_ind_P(pstr, itemIndex, itemString, LCD_WIDTH - 2);
+    uint8_t n = lcd_put_u8str_ind(fstr, itemIndex, itemString, LCD_WIDTH - 2);
     for (; n; --n) lcd_put_wchar(' ');
     lcd_put_wchar(post_char);
   }
 
   // Draw a menu item with a (potentially) editable value
-  void MenuEditItemBase::draw(const bool sel, const uint8_t row, PGM_P const pstr, const char * const inStr, const bool pgm) {
+  void MenuEditItemBase::draw(const bool sel, const uint8_t row, FSTR_P const fstr, const char * const inStr, const bool pgm) {
     const uint8_t vlen = inStr ? (pgm ? utf8_strlen_P(inStr) : utf8_strlen(inStr)) : 0;
     lcd_put_wchar(0, row, sel ? LCD_STR_ARROW_RIGHT[0] : ' ');
-    uint8_t n = lcd_put_u8str_ind_P(pstr, itemIndex, itemString, LCD_WIDTH - 2 - vlen);
+    uint8_t n = lcd_put_u8str_ind(fstr, itemIndex, itemString, LCD_WIDTH - 2 - vlen);
     if (vlen) {
       lcd_put_wchar(':');
       for (; n; --n) lcd_put_wchar(' ');
@@ -1102,9 +1102,9 @@ void MarlinUI::draw_status_screen() {
   }
 
   // Low-level draw_edit_screen can be used to draw an edit screen from anyplace
-  void MenuEditItemBase::draw_edit_screen(PGM_P const pstr, const char * const value/*=nullptr*/) {
+  void MenuEditItemBase::draw_edit_screen(FSTR_P const fstr, const char * const value/*=nullptr*/) {
     ui.encoder_direction_normal();
-    uint8_t n = lcd_put_u8str_ind_P(0, 1, pstr, itemIndex, itemString, LCD_WIDTH - 1);
+    uint8_t n = lcd_put_u8str_ind(0, 1, fstr, itemIndex, itemString, LCD_WIDTH - 1);
     if (value) {
       lcd_put_wchar(':'); n--;
       const uint8_t len = utf8_strlen(value) + 1;   // Plus one for a leading space
@@ -1115,21 +1115,21 @@ void MarlinUI::draw_status_screen() {
   }
 
   // The Select Screen presents a prompt and two "buttons"
-  void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const bool yesno, PGM_P const pref, const char * const string/*=nullptr*/, PGM_P const suff/*=nullptr*/) {
+  void MenuItem_confirm::draw_select_screen(FSTR_P const yes, FSTR_P const no, const bool yesno, FSTR_P const pref, const char * const string/*=nullptr*/, FSTR_P const suff/*=nullptr*/) {
     ui.draw_select_screen_prompt(pref, string, suff);
     if (no) {
       SETCURSOR(0, LCD_HEIGHT - 1);
-      lcd_put_wchar(yesno ? ' ' : '['); lcd_put_u8str_P(no); lcd_put_wchar(yesno ? ' ' : ']');
+      lcd_put_wchar(yesno ? ' ' : '['); lcd_put_u8str(no); lcd_put_wchar(yesno ? ' ' : ']');
     }
     if (yes) {
-      SETCURSOR_RJ(utf8_strlen_P(yes) + 2, LCD_HEIGHT - 1);
-      lcd_put_wchar(yesno ? '[' : ' '); lcd_put_u8str_P(yes); lcd_put_wchar(yesno ? ']' : ' ');
+      SETCURSOR_RJ(utf8_strlen(yes) + 2, LCD_HEIGHT - 1);
+      lcd_put_wchar(yesno ? '[' : ' '); lcd_put_u8str(yes); lcd_put_wchar(yesno ? ']' : ' ');
     }
   }
 
   #if ENABLED(SDSUPPORT)
 
-    void MenuItem_sdbase::draw(const bool sel, const uint8_t row, PGM_P const, CardReader &theCard, const bool isDir) {
+    void MenuItem_sdbase::draw(const bool sel, const uint8_t row, FSTR_P const, CardReader &theCard, const bool isDir) {
       lcd_put_wchar(0, row, sel ? LCD_STR_ARROW_RIGHT[0] : ' ');
       constexpr uint8_t maxlen = LCD_WIDTH - 2;
       uint8_t n = maxlen - lcd_put_u8str_max(ui.scrolled_filename(theCard, maxlen, row, sel), maxlen);

commit b523ddf1b2820488c6cc46887ee85e8a781ce726
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 19 06:05:52 2022 -0500

    ‚ôªÔ∏è Common Bed Leveling object name, accessors (#24214)

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index 8b00b7ccda..6c6ff47377 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -1281,9 +1281,9 @@ void MarlinUI::draw_status_screen() {
          * Show X and Y positions
          */
         _XLABEL(_PLOT_X, 0);
-        lcd_put_u8str(ftostr52(LOGICAL_X_POSITION(ubl.mesh_index_to_xpos(x_plot))));
+        lcd_put_u8str(ftostr52(LOGICAL_X_POSITION(bedlevel.get_mesh_x(x_plot))));
         _YLABEL(_LCD_W_POS, 0);
-        lcd_put_u8str(ftostr52(LOGICAL_Y_POSITION(ubl.mesh_index_to_ypos(y_plot))));
+        lcd_put_u8str(ftostr52(LOGICAL_Y_POSITION(bedlevel.get_mesh_y(y_plot))));
 
         lcd_moveto(_PLOT_X, 0);
 
@@ -1475,8 +1475,8 @@ void MarlinUI::draw_status_screen() {
          * Print Z values
          */
         _ZLABEL(_LCD_W_POS, 1);
-        if (!isnan(ubl.z_values[x_plot][y_plot]))
-          lcd_put_u8str(ftostr43sign(ubl.z_values[x_plot][y_plot]));
+        if (!isnan(bedlevel.z_values[x_plot][y_plot]))
+          lcd_put_u8str(ftostr43sign(bedlevel.z_values[x_plot][y_plot]));
         else
           lcd_put_u8str(F(" -----"));
 
@@ -1486,16 +1486,16 @@ void MarlinUI::draw_status_screen() {
          * Show all values at right of screen
          */
         _XLABEL(_LCD_W_POS, 1);
-        lcd_put_u8str(ftostr52(LOGICAL_X_POSITION(ubl.mesh_index_to_xpos(x_plot))));
+        lcd_put_u8str(ftostr52(LOGICAL_X_POSITION(bedlevel.get_mesh_x(x_plot))));
         _YLABEL(_LCD_W_POS, 2);
-        lcd_put_u8str(ftostr52(LOGICAL_Y_POSITION(ubl.mesh_index_to_ypos(y_plot))));
+        lcd_put_u8str(ftostr52(LOGICAL_Y_POSITION(bedlevel.get_mesh_y(y_plot))));
 
         /**
          * Show the location value
          */
         _ZLABEL(_LCD_W_POS, 3);
-        if (!isnan(ubl.z_values[x_plot][y_plot]))
-          lcd_put_u8str(ftostr43sign(ubl.z_values[x_plot][y_plot]));
+        if (!isnan(bedlevel.z_values[x_plot][y_plot]))
+          lcd_put_u8str(ftostr43sign(bedlevel.z_values[x_plot][y_plot]));
         else
           lcd_put_u8str(F(" -----"));
 

commit 04fe50936e23a8aca7a400591e700c1220f68b3f
Author: Pauli Jokela <pauli.jokela@didstopia.com>
Date:   Thu May 12 05:23:16 2022 +0300

    ‚ú® SOUND_ON_DEFAULT option (#24102)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index db4bd4e19e..8b00b7ccda 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -121,7 +121,7 @@ static void createChar_P(const char c, const byte * const ptr) {
 
 #if ENABLED(LCD_USE_I2C_BUZZER)
   void MarlinUI::buzz(const long duration, const uint16_t freq) {
-    if (!buzzer_enabled) return;
+    if (!sound_on) return;
     lcd.buzz(duration, freq);
   }
 #endif

commit 5b35f3a95582a477e879be5cc7d1406a42d3e740
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Wed Jan 26 10:33:10 2022 -0800

    üö∏ Better "Bed Tramming Done" dialog (#23616)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index 26344da412..db4bd4e19e 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -1117,10 +1117,14 @@ void MarlinUI::draw_status_screen() {
   // The Select Screen presents a prompt and two "buttons"
   void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const bool yesno, PGM_P const pref, const char * const string/*=nullptr*/, PGM_P const suff/*=nullptr*/) {
     ui.draw_select_screen_prompt(pref, string, suff);
-    SETCURSOR(0, LCD_HEIGHT - 1);
-    lcd_put_wchar(yesno ? ' ' : '['); lcd_put_u8str_P(no); lcd_put_wchar(yesno ? ' ' : ']');
-    SETCURSOR_RJ(utf8_strlen_P(yes) + 2, LCD_HEIGHT - 1);
-    lcd_put_wchar(yesno ? '[' : ' '); lcd_put_u8str_P(yes); lcd_put_wchar(yesno ? ']' : ' ');
+    if (no) {
+      SETCURSOR(0, LCD_HEIGHT - 1);
+      lcd_put_wchar(yesno ? ' ' : '['); lcd_put_u8str_P(no); lcd_put_wchar(yesno ? ' ' : ']');
+    }
+    if (yes) {
+      SETCURSOR_RJ(utf8_strlen_P(yes) + 2, LCD_HEIGHT - 1);
+      lcd_put_wchar(yesno ? '[' : ' '); lcd_put_u8str_P(yes); lcd_put_wchar(yesno ? ']' : ' ');
+    }
   }
 
   #if ENABLED(SDSUPPORT)

commit ab46b7e2f298826a5512569d6e79bb59a7a6b8ea
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jan 25 15:33:03 2022 -0600

    üßë‚Äçüíª HAS_MARLINUI_MENU, HAS_MANUAL_MOVE_MENU

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index b450c9c10f..26344da412 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -284,7 +284,7 @@ void MarlinUI::set_custom_characters(const HD44780CharSet screen_charset/*=CHARS
 
   #endif // LCD_PROGRESS_BAR
 
-  #if BOTH(SDSUPPORT, HAS_LCD_MENU)
+  #if BOTH(SDSUPPORT, HAS_MARLINUI_MENU)
 
     // CHARSET_MENU
     const static PROGMEM byte refresh[8] = {
@@ -334,7 +334,7 @@ void MarlinUI::set_custom_characters(const HD44780CharSet screen_charset/*=CHARS
       #endif
         {
           createChar_P(LCD_STR_UPLEVEL[0], uplevel);
-          #if BOTH(SDSUPPORT, HAS_LCD_MENU)
+          #if BOTH(SDSUPPORT, HAS_MARLINUI_MENU)
             // SD Card sub-menu special characters
             createChar_P(LCD_STR_REFRESH[0], refresh);
             createChar_P(LCD_STR_FOLDER[0], folder);
@@ -1051,7 +1051,7 @@ void MarlinUI::draw_status_screen() {
   draw_status_message(blink);
 }
 
-#if HAS_LCD_MENU
+#if HAS_MARLINUI_MENU
 
   #include "../menu/menu.h"
 
@@ -1584,6 +1584,6 @@ void MarlinUI::draw_status_screen() {
 
   #endif // AUTO_BED_LEVELING_UBL
 
-#endif // HAS_LCD_MENU
+#endif // HAS_MARLINUI_MENU
 
 #endif // HAS_MARLINUI_HD44780

commit eeffac697c5d7b69e01e38ed1602dbd21a366e93
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Sep 25 23:52:41 2021 -0500

    üé® Apply F() to UTF-8/MMU2 string put

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index f4d765e2d3..b450c9c10f 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -409,15 +409,15 @@ void MarlinUI::clear_lcd() { lcd.clear(); }
   }
 
   // Scroll the PSTR 'text' in a 'len' wide field for 'time' milliseconds at position col,line
-  void lcd_scroll(const lcd_uint_t col, const lcd_uint_t line, PGM_P const text, const uint8_t len, const int16_t time) {
-    uint8_t slen = utf8_strlen_P(text);
+  void lcd_scroll(const lcd_uint_t col, const lcd_uint_t line, FSTR_P const ftxt, const uint8_t len, const int16_t time) {
+    uint8_t slen = utf8_strlen_P(FTOP(ftxt));
     if (slen < len) {
-      lcd_put_u8str_max_P(col, line, text, len);
+      lcd_put_u8str_max(col, line, ftxt, len);
       for (; slen < len; ++slen) lcd_put_wchar(' ');
       safe_delay(time);
     }
     else {
-      PGM_P p = text;
+      PGM_P p = FTOP(ftxt);
       int dly = time / _MAX(slen, 1);
       LOOP_LE_N(i, slen) {
 
@@ -439,9 +439,9 @@ void MarlinUI::clear_lcd() { lcd.clear(); }
 
   static void logo_lines(PGM_P const extra) {
     int16_t indent = (LCD_WIDTH - 8 - utf8_strlen_P(extra)) / 2;
-    lcd_put_wchar(indent, 0, '\x00'); lcd_put_u8str_P(PSTR( "------" ));  lcd_put_wchar('\x01');
-    lcd_put_u8str_P(indent, 1, PSTR("|Marlin|"));  lcd_put_u8str_P(extra);
-    lcd_put_wchar(indent, 2, '\x02'); lcd_put_u8str_P(PSTR( "------" ));  lcd_put_wchar('\x03');
+    lcd_put_wchar(indent, 0, '\x00'); lcd_put_u8str(F( "------" ));  lcd_put_wchar('\x01');
+    lcd_put_u8str(indent, 1, F("|Marlin|"));  lcd_put_u8str_P(extra);
+    lcd_put_wchar(indent, 2, '\x02'); lcd_put_u8str(F( "------" ));  lcd_put_wchar('\x03');
   }
 
   void MarlinUI::show_bootscreen() {
@@ -450,15 +450,16 @@ void MarlinUI::clear_lcd() { lcd.clear(); }
 
     #define LCD_EXTRA_SPACE (LCD_WIDTH-8)
 
-    #define CENTER_OR_SCROLL(STRING,DELAY) \
+    #define CENTER_OR_SCROLL(STRING,DELAY) { \
       lcd_erase_line(3); \
-      if (utf8_strlen(STRING) <= LCD_WIDTH) { \
-        lcd_put_u8str_P((LCD_WIDTH - utf8_strlen_P(PSTR(STRING))) / 2, 3, PSTR(STRING)); \
+      const int len = utf8_strlen(STRING); \
+      if (len <= LCD_WIDTH) { \
+        lcd_put_u8str((LCD_WIDTH - len) / 2, 3, F(STRING)); \
         safe_delay(DELAY); \
       } \
-      else { \
-        lcd_scroll(0, 3, PSTR(STRING), LCD_WIDTH, DELAY); \
-      }
+      else \
+        lcd_scroll(0, 3, F(STRING), LCD_WIDTH, DELAY); \
+    }
 
     //
     // Show the Marlin logo with splash line 1
@@ -497,9 +498,9 @@ void MarlinUI::draw_kill_screen() {
   lcd_put_u8str(0, 0, status_message);
   lcd_uint_t y = 2;
   #if LCD_HEIGHT >= 4
-    lcd_put_u8str_P(0, y++, GET_TEXT(MSG_HALTED));
+    lcd_put_u8str(0, y++, GET_TEXT_F(MSG_HALTED));
   #endif
-  lcd_put_u8str_P(0, y, GET_TEXT(MSG_PLEASE_RESET));
+  lcd_put_u8str(0, y, GET_TEXT_F(MSG_PLEASE_RESET));
 }
 
 //
@@ -514,7 +515,7 @@ FORCE_INLINE void _draw_axis_value(const AxisEnum axis, const char *value, const
   else if (axis_should_home(axis))
     while (const char c = *value++) lcd_put_wchar(c <= '.' ? c : '?');
   else if (NONE(HOME_AFTER_DEACTIVATE, DISABLE_REDUCED_ACCURACY_WARNING) && !axis_is_trusted(axis))
-    lcd_put_u8str_P(axis == Z_AXIS ? PSTR("       ") : PSTR("    "));
+    lcd_put_u8str(axis == Z_AXIS ? F("       ") : F("    "));
   else
     lcd_put_u8str(value);
 }
@@ -613,11 +614,11 @@ FORCE_INLINE void _draw_bed_status(const bool blink) {
 
   FORCE_INLINE void _draw_print_progress() {
     const uint8_t progress = ui.get_progress_percent();
-    lcd_put_u8str_P(PSTR(TERN(SDSUPPORT, "SD", "P:")));
+    lcd_put_u8str(F(TERN(SDSUPPORT, "SD", "P:")));
     if (progress)
       lcd_put_u8str(ui8tostr3rj(progress));
     else
-      lcd_put_u8str_P(PSTR("---"));
+      lcd_put_u8str(F("---"));
     lcd_put_wchar('%');
   }
 
@@ -661,9 +662,9 @@ void MarlinUI::draw_status_message(const bool blink) {
 
     // Alternate Status message and Filament display
     if (ELAPSED(millis(), next_filament_display)) {
-      lcd_put_u8str_P(PSTR("Dia "));
+      lcd_put_u8str(F("Dia "));
       lcd_put_u8str(ftostr12ns(filwidth.measured_mm));
-      lcd_put_u8str_P(PSTR(" V"));
+      lcd_put_u8str(F(" V"));
       lcd_put_u8str(i16tostr3rj(planner.volumetric_percent(parser.volumetric_enabled)));
       lcd_put_wchar('%');
       return;
@@ -1473,7 +1474,7 @@ void MarlinUI::draw_status_screen() {
         if (!isnan(ubl.z_values[x_plot][y_plot]))
           lcd_put_u8str(ftostr43sign(ubl.z_values[x_plot][y_plot]));
         else
-          lcd_put_u8str_P(PSTR(" -----"));
+          lcd_put_u8str(F(" -----"));
 
       #else                 // 16x4 or 20x4 display
 
@@ -1492,7 +1493,7 @@ void MarlinUI::draw_status_screen() {
         if (!isnan(ubl.z_values[x_plot][y_plot]))
           lcd_put_u8str(ftostr43sign(ubl.z_values[x_plot][y_plot]));
         else
-          lcd_put_u8str_P(PSTR(" -----"));
+          lcd_put_u8str(F(" -----"));
 
       #endif // LCD_HEIGHT > 3
     }

commit afca6e745932d295b88d37fa9bd4274e22705b0b
Author: luzpaz <luzpaz@users.noreply.github.com>
Date:   Tue Aug 3 20:02:34 2021 -0400

    üêõ Spellcheck comments (#22496)
    
    codespell -q 3 --builtin=clear,rare,informal,code -S ./Marlin/src/lcd/language -L alo,amin,endcode,stdio,uint

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index 0c87c3dc3f..f4d765e2d3 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -1321,7 +1321,7 @@ void MarlinUI::draw_status_screen() {
         y_map_pixels = pixels_per_y_mesh_pnt * (GRID_MAX_POINTS_Y);         // Directions fit nicely
 
         right_edge   = pixels_per_x_mesh_pnt * (GRID_MAX_POINTS_X) + 1;     // Find location of right edge within the character cell
-        bottom_line  = pixels_per_y_mesh_pnt * (GRID_MAX_POINTS_Y) + 1;     // Find location of bottome line within the character cell
+        bottom_line  = pixels_per_y_mesh_pnt * (GRID_MAX_POINTS_Y) + 1;     // Find location of bottom line within the character cell
 
         n_rows = bottom_line / (HD44780_CHAR_HEIGHT) + 1;
         n_cols = right_edge / (HD44780_CHAR_WIDTH) + 1;

commit d320545066676338d4a0142268931bb66eedfccc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jun 8 07:51:28 2021 -0500

    üé® Laser Ammeter followup (#22079)
    
    Followup to #21835

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index ab3d415c15..0c87c3dc3f 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -68,11 +68,7 @@
 
 #elif EITHER(LCD_I2C_TYPE_MCP23017, LCD_I2C_TYPE_MCP23008)
 
-  LCD_CLASS lcd(LCD_I2C_ADDRESS
-    #ifdef DETECT_DEVICE
-      , 1
-    #endif
-  );
+  LCD_CLASS lcd(LCD_I2C_ADDRESS OPTARG(DETECT_I2C_LCD_DEVICE, 1));
 
 #elif ENABLED(LCD_I2C_TYPE_PCA8574)
 
@@ -380,11 +376,7 @@ void MarlinUI::init_lcd() {
 }
 
 bool MarlinUI::detected() {
-  return (true
-    #if EITHER(LCD_I2C_TYPE_MCP23017, LCD_I2C_TYPE_MCP23008) && defined(DETECT_DEVICE)
-      && lcd.LcdDetected() == 1
-    #endif
-  );
+  return TERN1(DETECT_I2C_LCD_DEVICE, lcd.LcdDetected() == 1);
 }
 
 #if HAS_SLOW_BUTTONS
@@ -602,10 +594,11 @@ FORCE_INLINE void _draw_cooler_status(const char prefix, const bool blink) {
   FORCE_INLINE void _draw_ammeter_status() {
     lcd_put_u8str(" ");
     ammeter.read();
-    if (ammeter.current <= .999) {
-      lcd_put_u8str(ftostr3ns(ammeter.current));
+    if (ammeter.current <= 0.999f) {
+      lcd_put_u8str(ui16tostr3rj(uint16_t(ammeter.current * 1000 + 0.5f)));
       lcd_put_u8str("mA");
-    } else {
+    }
+    else {
       lcd_put_u8str(ftostr12ns(ammeter.current));
       lcd_put_wchar('A');
     }
@@ -847,15 +840,9 @@ void MarlinUI::draw_status_screen() {
         #endif
       #endif
 
-      #if HAS_COOLER
-        _draw_cooler_status('*', blink);
-      #endif
-      #if ENABLED(LASER_COOLANT_FLOW_METER)
-        _draw_flowmeter_status();
-      #endif
-      #if ENABLED(I2C_AMMETER)
-        _draw_ammeter_status();
-      #endif
+      TERN_(HAS_COOLER, _draw_cooler_status('*', blink));
+      TERN_(LASER_COOLANT_FLOW_METER, _draw_flowmeter_status());
+      TERN_(I2C_AMMETER, _draw_ammeter_status());
 
     #endif // LCD_WIDTH >= 20
 

commit 002e1d49fe7e39ca82730876f0a384bb60ce4190
Author: Mike La Spina <mike.laspina@shaw.ca>
Date:   Mon Jun 7 14:15:09 2021 -0500

    Add Laser Based I2C Ammeter Feature (#21835)

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index 50c80c9fa0..ab3d415c15 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -50,6 +50,10 @@
   #include "../../feature/cooler.h"
 #endif
 
+#if ENABLED(I2C_AMMETER)
+  #include "../../feature/ammeter.h"
+#endif
+
 #if ENABLED(AUTO_BED_LEVELING_UBL)
   #include "../../feature/bedlevel/bedlevel.h"
 #endif
@@ -588,12 +592,26 @@ FORCE_INLINE void _draw_cooler_status(const char prefix, const bool blink) {
 
 #if ENABLED(LASER_COOLANT_FLOW_METER)
   FORCE_INLINE void _draw_flowmeter_status() {
-    lcd_put_u8str("~ ");
+    lcd_put_u8str("~");
     lcd_put_u8str(ftostr11ns(cooler.flowrate));
     lcd_put_wchar('L');
   }
 #endif
 
+#if ENABLED(I2C_AMMETER)
+  FORCE_INLINE void _draw_ammeter_status() {
+    lcd_put_u8str(" ");
+    ammeter.read();
+    if (ammeter.current <= .999) {
+      lcd_put_u8str(ftostr3ns(ammeter.current));
+      lcd_put_u8str("mA");
+    } else {
+      lcd_put_u8str(ftostr12ns(ammeter.current));
+      lcd_put_wchar('A');
+    }
+  }
+#endif
+
 FORCE_INLINE void _draw_bed_status(const bool blink) {
   _draw_heater_status(H_BED, TERN0(HAS_LEVELING, blink && planner.leveling_active) ? '_' : LCD_STR_BEDTEMP[0], blink);
 }
@@ -835,6 +853,9 @@ void MarlinUI::draw_status_screen() {
       #if ENABLED(LASER_COOLANT_FLOW_METER)
         _draw_flowmeter_status();
       #endif
+      #if ENABLED(I2C_AMMETER)
+        _draw_ammeter_status();
+      #endif
 
     #endif // LCD_WIDTH >= 20
 

commit 2de54dab84d82ef69fb9ac3bd9025444f4f84813
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri May 21 08:23:09 2021 -0500

    üé® Move HAS_EXTRUDERS

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index 85430c18b0..50c80c9fa0 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -954,7 +954,7 @@ void MarlinUI::draw_status_screen() {
             else
           #endif
             {
-              #if EXTRUDERS
+              #if HAS_EXTRUDERS
                 c = 'E';
                 per = planner.flow_percentage[0];
               #endif

commit b65cdbed91782c83188706a9c340de9c503cf430
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 8 04:35:35 2021 -0500

    Signal SD completion later (#21840)

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index 2e5f967c2f..85430c18b0 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -755,7 +755,7 @@ inline uint8_t draw_elapsed_or_remaining_time(uint8_t timepos, const bool blink)
   char buffer[14];
 
   #if ENABLED(SHOW_REMAINING_TIME)
-    const bool show_remain = TERN1(ROTATE_PROGRESS_DISPLAY, blink) && (printingIsActive() || marlin_state == MF_SD_COMPLETE);
+    const bool show_remain = TERN1(ROTATE_PROGRESS_DISPLAY, blink) && printingIsActive();
     if (show_remain) {
       #if ENABLED(USE_M73_REMAINING_TIME)
         duration_t remaining = ui.get_remaining_time();
@@ -889,7 +889,7 @@ void MarlinUI::draw_status_screen() {
 
           #else // !HAS_DUAL_MIXING
 
-            const bool show_e_total = TERN0(LCD_SHOW_E_TOTAL, printingIsActive() || marlin_state == MF_SD_COMPLETE);
+            const bool show_e_total = TERN0(LCD_SHOW_E_TOTAL, printingIsActive());
 
             if (show_e_total) {
               #if ENABLED(LCD_SHOW_E_TOTAL)

commit e4f60f82a4cbcac1921b6bf444fa803910e2adf3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Apr 30 03:21:59 2021 -0500

    Heater error status

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index 75ff1f52c2..2e5f967c2f 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -535,7 +535,7 @@ FORCE_INLINE void _draw_heater_status(const heater_id_t heater_id, const char pr
 
   if (prefix >= 0) lcd_put_wchar(prefix);
 
-  lcd_put_u8str(i16tostr3rj(t1));
+  lcd_put_u8str(t1 < 0 ? "err" : i16tostr3rj(t1));
   lcd_put_wchar('/');
 
   #if !HEATER_IDLE_HANDLER

commit a29aefc9c0c02c23862fded29e3f950ead339238
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 24 01:29:30 2021 -0500

    Move last bootscreen delay to end of setup (#21665)

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index e91213b5b7..75ff1f52c2 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -486,7 +486,9 @@ void MarlinUI::clear_lcd() { lcd.clear(); }
         CENTER_OR_SCROLL(STRING_SPLASH_LINE3, 1500);
       #endif
     }
+  }
 
+  void MarlinUI::bootscreen_completion(const millis_t) {
     lcd.clear();
     safe_delay(100);
     set_custom_characters(CHARSET_INFO);

commit c4620bb5285438e41fa4c39229aa2a39859877ca
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Apr 23 20:19:23 2021 -0500

    Add whole-degree accessors, simplify some temperature-related features (#21685)

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index 6ed4d33630..e91213b5b7 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -525,10 +525,10 @@ FORCE_INLINE void _draw_axis_value(const AxisEnum axis, const char *value, const
 FORCE_INLINE void _draw_heater_status(const heater_id_t heater_id, const char prefix, const bool blink) {
   #if HAS_HEATED_BED
     const bool isBed = TERN(HAS_HEATED_CHAMBER, heater_id == H_BED, heater_id < 0);
-    const celsius_t t1 = (isBed ? thermalManager.degBed()       : thermalManager.degHotend(heater_id)),
+    const celsius_t t1 = (isBed ? thermalManager.wholeDegBed()  : thermalManager.wholeDegHotend(heater_id)),
                     t2 = (isBed ? thermalManager.degTargetBed() : thermalManager.degTargetHotend(heater_id));
   #else
-    const celsius_t t1 = thermalManager.degHotend(heater_id), t2 = thermalManager.degTargetHotend(heater_id);
+    const celsius_t t1 = thermalManager.wholeDegHotend(heater_id), t2 = thermalManager.degTargetHotend(heater_id);
   #endif
 
   if (prefix >= 0) lcd_put_wchar(prefix);
@@ -557,11 +557,11 @@ FORCE_INLINE void _draw_heater_status(const heater_id_t heater_id, const char pr
 
 #if HAS_COOLER
 FORCE_INLINE void _draw_cooler_status(const char prefix, const bool blink) {
-  const float t1 = thermalManager.degCooler(), t2 = thermalManager.degTargetCooler();
+  const celsius_t t2 = thermalManager.degTargetCooler();
 
   if (prefix >= 0) lcd_put_wchar(prefix);
 
-  lcd_put_u8str(i16tostr3rj(t1 + 0.5));
+  lcd_put_u8str(i16tostr3rj(thermalManager.wholeDegCooler()));
   lcd_put_wchar('/');
 
   #if !HEATER_IDLE_HANDLER
@@ -574,7 +574,7 @@ FORCE_INLINE void _draw_cooler_status(const char prefix, const bool blink) {
     }
     else
   #endif
-      lcd_put_u8str(i16tostr3left(t2 + 0.5));
+      lcd_put_u8str(i16tostr3left(t2));
 
   if (prefix >= 0) {
     lcd_put_wchar(LCD_STR_DEGREE[0]);

commit 528b9bd8729656d7ebcd3dc7898ceddc2f377354
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Apr 16 02:43:59 2021 -0500

    Revert experimental NAN patch
    
    Hold changes from #21575 (24a095c) for more testing.

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index 0444c9e185..6ed4d33630 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -1460,7 +1460,7 @@ void MarlinUI::draw_status_screen() {
          * Print Z values
          */
         _ZLABEL(_LCD_W_POS, 1);
-        if (!ISNAN(ubl.z_values[x_plot][y_plot]))
+        if (!isnan(ubl.z_values[x_plot][y_plot]))
           lcd_put_u8str(ftostr43sign(ubl.z_values[x_plot][y_plot]));
         else
           lcd_put_u8str_P(PSTR(" -----"));
@@ -1479,7 +1479,7 @@ void MarlinUI::draw_status_screen() {
          * Show the location value
          */
         _ZLABEL(_LCD_W_POS, 3);
-        if (!ISNAN(ubl.z_values[x_plot][y_plot]))
+        if (!isnan(ubl.z_values[x_plot][y_plot]))
           lcd_put_u8str(ftostr43sign(ubl.z_values[x_plot][y_plot]));
         else
           lcd_put_u8str_P(PSTR(" -----"));

commit cc5297d637d2a0a784e336210c366baf250785d0
Author: XDA-Bam <1209896+XDA-Bam@users.noreply.github.com>
Date:   Wed Apr 14 11:42:04 2021 +0200

    Space-separate scrolling Status Message (#21523)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index 57af2b782a..0444c9e185 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -684,12 +684,15 @@ void MarlinUI::draw_status_message(const bool blink) {
 
       // If the remaining string doesn't completely fill the screen
       if (rlen < LCD_WIDTH) {
-        lcd_put_wchar('.');                   // Always at 1+ spaces left, draw a dot
         uint8_t chars = LCD_WIDTH - rlen;     // Amount of space left in characters
-        if (--chars) {                        // Draw a second dot if there's space
-          lcd_put_wchar('.');
-          if (--chars)
-            lcd_put_u8str_max(status_message, chars); // Print a second copy of the message
+        lcd_put_wchar(' ');                   // Always at 1+ spaces left, draw a space
+        if (--chars) {                        // Draw a second space if there's room
+          lcd_put_wchar(' ');
+          if (--chars) {                      // Draw a third space if there's room
+            lcd_put_wchar(' ');
+            if (--chars)
+              lcd_put_u8str_max(status_message, chars); // Print a second copy of the message
+          }
         }
       }
       if (last_blink != blink) {

commit fd99ea09ecb41bc1dfc5e4109e0d6c7de1f87424
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Apr 13 04:00:39 2021 -0500

    Add fan percent accessors

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index 874fcc143d..57af2b782a 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -944,7 +944,7 @@ void MarlinUI::draw_status_screen() {
               #if ENABLED(ADAPTIVE_FAN_SLOWING)
                 else { c = '*'; spd = thermalManager.scaledFanSpeed(0, spd); }
               #endif
-              per = thermalManager.fanPercent(spd);
+              per = thermalManager.pwmToPercent(spd);
             }
             else
           #endif

commit 24a095c5c14b60bcbffc2807d2c8cc8e9af46e90
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Apr 12 16:49:53 2021 -0500

    Reduce math library code size by 3.4KB (#21575)

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index 98ca1c0930..874fcc143d 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -1457,7 +1457,7 @@ void MarlinUI::draw_status_screen() {
          * Print Z values
          */
         _ZLABEL(_LCD_W_POS, 1);
-        if (!isnan(ubl.z_values[x_plot][y_plot]))
+        if (!ISNAN(ubl.z_values[x_plot][y_plot]))
           lcd_put_u8str(ftostr43sign(ubl.z_values[x_plot][y_plot]));
         else
           lcd_put_u8str_P(PSTR(" -----"));
@@ -1476,7 +1476,7 @@ void MarlinUI::draw_status_screen() {
          * Show the location value
          */
         _ZLABEL(_LCD_W_POS, 3);
-        if (!isnan(ubl.z_values[x_plot][y_plot]))
+        if (!ISNAN(ubl.z_values[x_plot][y_plot]))
           lcd_put_u8str(ftostr43sign(ubl.z_values[x_plot][y_plot]));
         else
           lcd_put_u8str_P(PSTR(" -----"));

commit 235ba926021709e293f33b7229690406761298e4
Author: Mike La Spina <mike.laspina@shaw.ca>
Date:   Thu Apr 1 19:29:49 2021 -0500

    Followup to Laser Flow Meter (#21498)

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index 61c7ce18d6..98ca1c0930 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -46,7 +46,7 @@
   #include "../../gcode/parser.h"
 #endif
 
-#if HAS_COOLER || HAS_FLOWMETER
+#if EITHER(HAS_COOLER, LASER_COOLANT_FLOW_METER)
   #include "../../feature/cooler.h"
 #endif
 
@@ -584,7 +584,7 @@ FORCE_INLINE void _draw_cooler_status(const char prefix, const bool blink) {
 }
 #endif
 
-#if HAS_FLOWMETER
+#if ENABLED(LASER_COOLANT_FLOW_METER)
   FORCE_INLINE void _draw_flowmeter_status() {
     lcd_put_u8str("~ ");
     lcd_put_u8str(ftostr11ns(cooler.flowrate));
@@ -827,7 +827,7 @@ void MarlinUI::draw_status_screen() {
       #if HAS_COOLER
         _draw_cooler_status('*', blink);
       #endif
-      #if HAS_FLOWMETER
+      #if ENABLED(LASER_COOLANT_FLOW_METER)
         _draw_flowmeter_status();
       #endif
 

commit 45c1432946547cef4cbe9ac832394ff68526687d
Author: Marcio T <mlt4356-github@yahoo.com>
Date:   Thu Apr 1 18:12:00 2021 -0600

    G26 Hilbert Curve followup (#21480)

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index e18ed7273c..61c7ce18d6 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -1279,7 +1279,7 @@ void MarlinUI::draw_status_screen() {
                    pixels_per_x_mesh_pnt, pixels_per_y_mesh_pnt,
                    suppress_x_offset = 0, suppress_y_offset = 0;
 
-        const uint8_t y_plot_inv = (GRID_MAX_POINTS_Y - 1) - y_plot;
+        const uint8_t y_plot_inv = (GRID_MAX_POINTS_Y) - 1 - y_plot;
 
         upper_left.column  = 0;
         upper_left.row     = 0;

commit 3b73b115ca9366f0155986b717d4c85c31ed2f80
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 29 20:36:37 2021 -0500

    Apply pointer formatting

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index 683c1c0884..e18ed7273c 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -1076,7 +1076,7 @@ void MarlinUI::draw_status_screen() {
   }
 
   // Draw a menu item with a (potentially) editable value
-  void MenuEditItemBase::draw(const bool sel, const uint8_t row, PGM_P const pstr, const char* const inStr, const bool pgm) {
+  void MenuEditItemBase::draw(const bool sel, const uint8_t row, PGM_P const pstr, const char * const inStr, const bool pgm) {
     const uint8_t vlen = inStr ? (pgm ? utf8_strlen_P(inStr) : utf8_strlen(inStr)) : 0;
     lcd_put_wchar(0, row, sel ? LCD_STR_ARROW_RIGHT[0] : ' ');
     uint8_t n = lcd_put_u8str_ind_P(pstr, itemIndex, itemString, LCD_WIDTH - 2 - vlen);
@@ -1088,7 +1088,7 @@ void MarlinUI::draw_status_screen() {
   }
 
   // Low-level draw_edit_screen can be used to draw an edit screen from anyplace
-  void MenuEditItemBase::draw_edit_screen(PGM_P const pstr, const char* const value/*=nullptr*/) {
+  void MenuEditItemBase::draw_edit_screen(PGM_P const pstr, const char * const value/*=nullptr*/) {
     ui.encoder_direction_normal();
     uint8_t n = lcd_put_u8str_ind_P(0, 1, pstr, itemIndex, itemString, LCD_WIDTH - 1);
     if (value) {

commit ccdbffbf3f599f0860c643647ce6c40f1eb5a4cd
Author: Mike La Spina <mike.laspina@shaw.ca>
Date:   Mon Mar 29 01:41:56 2021 -0500

    Laser Coolant Flow Meter / Safety Shutdown (#21431)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index 3f4cc23aba..683c1c0884 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -46,6 +46,10 @@
   #include "../../gcode/parser.h"
 #endif
 
+#if HAS_COOLER || HAS_FLOWMETER
+  #include "../../feature/cooler.h"
+#endif
+
 #if ENABLED(AUTO_BED_LEVELING_UBL)
   #include "../../feature/bedlevel/bedlevel.h"
 #endif
@@ -517,6 +521,7 @@ FORCE_INLINE void _draw_axis_value(const AxisEnum axis, const char *value, const
     lcd_put_u8str(value);
 }
 
+
 FORCE_INLINE void _draw_heater_status(const heater_id_t heater_id, const char prefix, const bool blink) {
   #if HAS_HEATED_BED
     const bool isBed = TERN(HAS_HEATED_CHAMBER, heater_id == H_BED, heater_id < 0);
@@ -550,6 +555,43 @@ FORCE_INLINE void _draw_heater_status(const heater_id_t heater_id, const char pr
   }
 }
 
+#if HAS_COOLER
+FORCE_INLINE void _draw_cooler_status(const char prefix, const bool blink) {
+  const float t1 = thermalManager.degCooler(), t2 = thermalManager.degTargetCooler();
+
+  if (prefix >= 0) lcd_put_wchar(prefix);
+
+  lcd_put_u8str(i16tostr3rj(t1 + 0.5));
+  lcd_put_wchar('/');
+
+  #if !HEATER_IDLE_HANDLER
+    UNUSED(blink);
+  #else
+    if (!blink && thermalManager.heater_idle[thermalManager.idle_index_for_id(heater_id)].timed_out) {
+      lcd_put_wchar(' ');
+      if (t2 >= 10) lcd_put_wchar(' ');
+      if (t2 >= 100) lcd_put_wchar(' ');
+    }
+    else
+  #endif
+      lcd_put_u8str(i16tostr3left(t2 + 0.5));
+
+  if (prefix >= 0) {
+    lcd_put_wchar(LCD_STR_DEGREE[0]);
+    lcd_put_wchar(' ');
+    if (t2 < 10) lcd_put_wchar(' ');
+  }
+}
+#endif
+
+#if HAS_FLOWMETER
+  FORCE_INLINE void _draw_flowmeter_status() {
+    lcd_put_u8str("~ ");
+    lcd_put_u8str(ftostr11ns(cooler.flowrate));
+    lcd_put_wchar('L');
+  }
+#endif
+
 FORCE_INLINE void _draw_bed_status(const bool blink) {
   _draw_heater_status(H_BED, TERN0(HAS_LEVELING, blink && planner.leveling_active) ? '_' : LCD_STR_BEDTEMP[0], blink);
 }
@@ -747,17 +789,19 @@ void MarlinUI::draw_status_screen() {
       //
       // Hotend 0 Temperature
       //
-      _draw_heater_status(H_E0, -1, blink);
-
-      //
-      // Hotend 1 or Bed Temperature
-      //
-      #if HAS_MULTI_HOTEND
-        lcd_moveto(8, 0);
-        _draw_heater_status(H_E1, LCD_STR_THERMOMETER[0], blink);
-      #elif HAS_HEATED_BED
-        lcd_moveto(8, 0);
-        _draw_bed_status(blink);
+      #if HAS_HOTEND
+        _draw_heater_status(H_E0, -1, blink);
+
+        //
+        // Hotend 1 or Bed Temperature
+        //
+        #if HAS_MULTI_HOTEND
+          lcd_moveto(8, 0);
+          _draw_heater_status(H_E1, LCD_STR_THERMOMETER[0], blink);
+        #elif HAS_HEATED_BED
+          lcd_moveto(8, 0);
+          _draw_bed_status(blink);
+        #endif
       #endif
 
     #else // LCD_WIDTH >= 20
@@ -765,17 +809,26 @@ void MarlinUI::draw_status_screen() {
       //
       // Hotend 0 Temperature
       //
-      _draw_heater_status(H_E0, LCD_STR_THERMOMETER[0], blink);
+      #if HAS_HOTEND
+        _draw_heater_status(H_E0, LCD_STR_THERMOMETER[0], blink);
+
+        //
+        // Hotend 1 or Bed Temperature
+        //
+        #if HAS_MULTI_HOTEND
+          lcd_moveto(10, 0);
+          _draw_heater_status(H_E1, LCD_STR_THERMOMETER[0], blink);
+        #elif HAS_HEATED_BED
+          lcd_moveto(10, 0);
+          _draw_bed_status(blink);
+        #endif
+      #endif
 
-      //
-      // Hotend 1 or Bed Temperature
-      //
-      #if HAS_MULTI_HOTEND
-        lcd_moveto(10, 0);
-        _draw_heater_status(H_E1, LCD_STR_THERMOMETER[0], blink);
-      #elif HAS_HEATED_BED
-        lcd_moveto(10, 0);
-        _draw_bed_status(blink);
+      #if HAS_COOLER
+        _draw_cooler_status('*', blink);
+      #endif
+      #if HAS_FLOWMETER
+        _draw_flowmeter_status();
       #endif
 
     #endif // LCD_WIDTH >= 20

commit e5ff55a1be7646b6159e6dedac50bfbe57e6dfa0
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 24 04:11:43 2021 -0500

    Add typedef celsius_t (#21374)

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index 653a384120..3f4cc23aba 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -520,15 +520,15 @@ FORCE_INLINE void _draw_axis_value(const AxisEnum axis, const char *value, const
 FORCE_INLINE void _draw_heater_status(const heater_id_t heater_id, const char prefix, const bool blink) {
   #if HAS_HEATED_BED
     const bool isBed = TERN(HAS_HEATED_CHAMBER, heater_id == H_BED, heater_id < 0);
-    const float t1 = (isBed ? thermalManager.degBed()       : thermalManager.degHotend(heater_id)),
-                t2 = (isBed ? thermalManager.degTargetBed() : thermalManager.degTargetHotend(heater_id));
+    const celsius_t t1 = (isBed ? thermalManager.degBed()       : thermalManager.degHotend(heater_id)),
+                    t2 = (isBed ? thermalManager.degTargetBed() : thermalManager.degTargetHotend(heater_id));
   #else
-    const float t1 = thermalManager.degHotend(heater_id), t2 = thermalManager.degTargetHotend(heater_id);
+    const celsius_t t1 = thermalManager.degHotend(heater_id), t2 = thermalManager.degTargetHotend(heater_id);
   #endif
 
   if (prefix >= 0) lcd_put_wchar(prefix);
 
-  lcd_put_u8str(i16tostr3rj(t1 + 0.5));
+  lcd_put_u8str(i16tostr3rj(t1));
   lcd_put_wchar('/');
 
   #if !HEATER_IDLE_HANDLER
@@ -541,7 +541,7 @@ FORCE_INLINE void _draw_heater_status(const heater_id_t heater_id, const char pr
     }
     else
   #endif
-      lcd_put_u8str(i16tostr3left(t2 + 0.5));
+      lcd_put_u8str(i16tostr3left(t2));
 
   if (prefix >= 0) {
     lcd_put_wchar(LCD_STR_DEGREE[0]);

commit 58f0330d3f51115dbc8cda792105fe66d4c61241
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Mar 19 16:41:47 2021 -0500

    MKS / E3V2 LCD code cleanup

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index 15b3d8bfb3..653a384120 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -571,9 +571,9 @@ FORCE_INLINE void _draw_bed_status(const bool blink) {
 #if ENABLED(LCD_PROGRESS_BAR)
 
   void MarlinUI::draw_progress_bar(const uint8_t percent) {
-    const int16_t tix = (int16_t)(percent * (LCD_WIDTH) * 3) / 100,
-              cel = tix / 3,
-              rem = tix % 3;
+    const int16_t tix = int16_t(percent * (LCD_WIDTH) * 3) / 100,
+                  cel = tix / 3,
+                  rem = tix % 3;
     uint8_t i = LCD_WIDTH;
     char msg[LCD_WIDTH + 1], b = ' ';
     msg[LCD_WIDTH] = '\0';

commit 490d4a504a40a70e1a51c4758d37ec6116272b38
Author: Vert <45634861+Vertabreak@users.noreply.github.com>
Date:   Tue Feb 16 21:29:55 2021 -0500

    GT2560 v4.1B, YHCB2004 SPI character LCD (#21091)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index 635751b3f5..15b3d8bfb3 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -93,6 +93,10 @@
 
   LCD_CLASS lcd(0x27, 2, 1, 0, 4, 5, 6, 7, 3, POSITIVE);
 
+#elif ENABLED(YHCB2004)
+
+  LCD_CLASS lcd(YHCB2004_CLK, 20, 4, YHCB2004_MOSI, YHCB2004_MISO); // CLK, cols, rows, MOSI, MISO
+
 #else
 
   // Standard direct-connected LCD implementations

commit d33fe2378c25d258b02440aef6cc31e36753f98f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jan 22 15:01:19 2021 -0600

    Move common strings (#20846)

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index 84c477fbde..635751b3f5 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -471,7 +471,6 @@ void MarlinUI::clear_lcd() { lcd.clear(); }
       // Show the Marlin logo and short build version
       // After a delay show the website URL
       //
-      extern const char NUL_STR[];
       logo_lines(NUL_STR);
       CENTER_OR_SCROLL(SHORT_BUILD_VERSION, 1500);
       CENTER_OR_SCROLL(MARLIN_WEBSITE_URL, 1500);

commit 8fd8772a6fffe63d99d0b88aec7a77d283df8584
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Nov 29 19:06:40 2020 -0600

    Adjust axis homed / trusted methods (#20323)

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index fabd403c6b..84c477fbde 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -506,18 +506,12 @@ FORCE_INLINE void _draw_axis_value(const AxisEnum axis, const char *value, const
   lcd_put_wchar('X' + uint8_t(axis));
   if (blink)
     lcd_put_u8str(value);
-  else {
-    if (!TEST(axis_homed, axis))
-      while (const char c = *value++) lcd_put_wchar(c <= '.' ? c : '?');
-    else {
-      #if NONE(HOME_AFTER_DEACTIVATE, DISABLE_REDUCED_ACCURACY_WARNING)
-        if (!TEST(axis_known_position, axis))
-          lcd_put_u8str_P(axis == Z_AXIS ? PSTR("       ") : PSTR("    "));
-        else
-      #endif
-          lcd_put_u8str(value);
-    }
-  }
+  else if (axis_should_home(axis))
+    while (const char c = *value++) lcd_put_wchar(c <= '.' ? c : '?');
+  else if (NONE(HOME_AFTER_DEACTIVATE, DISABLE_REDUCED_ACCURACY_WARNING) && !axis_is_trusted(axis))
+    lcd_put_u8str_P(axis == Z_AXIS ? PSTR("       ") : PSTR("    "));
+  else
+    lcd_put_u8str(value);
 }
 
 FORCE_INLINE void _draw_heater_status(const heater_id_t heater_id, const char prefix, const bool blink) {

commit 1c7f53bbb27aae47a2529f907e8bf26f7590de7f
Author: Thomas Niccolo Reyes <niccoreyes@gmail.com>
Date:   Sat Nov 28 05:26:19 2020 +0800

    Fix M73 LCD code typo (#20300)

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index 00968f4ba0..fabd403c6b 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -714,7 +714,7 @@ inline uint8_t draw_elapsed_or_remaining_time(uint8_t timepos, const bool blink)
     const bool show_remain = TERN1(ROTATE_PROGRESS_DISPLAY, blink) && (printingIsActive() || marlin_state == MF_SD_COMPLETE);
     if (show_remain) {
       #if ENABLED(USE_M73_REMAINING_TIME)
-        duration_t remaining = get_remaining_time();
+        duration_t remaining = ui.get_remaining_time();
       #else
         uint8_t progress = ui.get_progress_percent();
         uint32_t elapsed = print_job_timer.duration();

commit c059ea0ea058f7206847e5dc37fe6d6085fd8f4f
Author: ellensp <ellensp@hotmail.com>
Date:   Thu Nov 19 19:09:51 2020 +1300

    Remaining Time followup (#20199)

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index b85d5adf2a..00968f4ba0 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -707,7 +707,7 @@ void MarlinUI::draw_status_message(const bool blink) {
  *  |01234567890123456789|
  */
 
-inline uint8_t draw_elapsed_or_remaining_time(uint8_t timepos) {
+inline uint8_t draw_elapsed_or_remaining_time(uint8_t timepos, const bool blink) {
   char buffer[14];
 
   #if ENABLED(SHOW_REMAINING_TIME)
@@ -716,7 +716,7 @@ inline uint8_t draw_elapsed_or_remaining_time(uint8_t timepos) {
       #if ENABLED(USE_M73_REMAINING_TIME)
         duration_t remaining = get_remaining_time();
       #else
-        uint8_t progress = get_progress_percent();
+        uint8_t progress = ui.get_progress_percent();
         uint32_t elapsed = print_job_timer.duration();
         duration_t remaining = (progress > 0) ? ((elapsed * 25600 / progress) >> 8) - elapsed : 0;
       #endif
@@ -874,7 +874,7 @@ void MarlinUI::draw_status_screen() {
       lcd_put_u8str(i16tostr3rj(feedrate_percentage));
       lcd_put_wchar('%');
 
-      const uint8_t timepos = draw_elapsed_or_remaining_time(LCD_WIDTH - 1);
+      const uint8_t timepos = draw_elapsed_or_remaining_time(LCD_WIDTH - 1, blink);
 
       #if LCD_WIDTH >= 20
         lcd_moveto(timepos - 7, 2);
@@ -973,7 +973,7 @@ void MarlinUI::draw_status_screen() {
 
     #else
 
-      (void)draw_elapsed_or_remaining_time(LCD_WIDTH - 4);
+      (void)draw_elapsed_or_remaining_time(LCD_WIDTH - 4, blink);
 
     #endif
 

commit 04a3ece3e03d0de7d9e34775a0c38cfe2f06b164
Author: Thomas Niccolo Reyes <niccoreyes@gmail.com>
Date:   Wed Nov 18 13:49:56 2020 +0800

    Remaining Time for Prusa-style LCD layout (#20148)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index 81862e1ddf..b85d5adf2a 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -707,6 +707,35 @@ void MarlinUI::draw_status_message(const bool blink) {
  *  |01234567890123456789|
  */
 
+inline uint8_t draw_elapsed_or_remaining_time(uint8_t timepos) {
+  char buffer[14];
+
+  #if ENABLED(SHOW_REMAINING_TIME)
+    const bool show_remain = TERN1(ROTATE_PROGRESS_DISPLAY, blink) && (printingIsActive() || marlin_state == MF_SD_COMPLETE);
+    if (show_remain) {
+      #if ENABLED(USE_M73_REMAINING_TIME)
+        duration_t remaining = get_remaining_time();
+      #else
+        uint8_t progress = get_progress_percent();
+        uint32_t elapsed = print_job_timer.duration();
+        duration_t remaining = (progress > 0) ? ((elapsed * 25600 / progress) >> 8) - elapsed : 0;
+      #endif
+      timepos -= remaining.toDigital(buffer);
+      lcd_put_wchar(timepos, 2, 'R');
+    }
+  #else
+    constexpr bool show_remain = false;
+  #endif
+
+  if (!show_remain) {
+    duration_t elapsed = print_job_timer.duration();
+    timepos -= elapsed.toDigital(buffer);
+    lcd_put_wchar(timepos, 2, LCD_STR_CLOCK[0]);
+  }
+  lcd_put_u8str(buffer);
+  return timepos;
+}
+
 void MarlinUI::draw_status_screen() {
 
   const bool blink = get_blink();
@@ -845,33 +874,7 @@ void MarlinUI::draw_status_screen() {
       lcd_put_u8str(i16tostr3rj(feedrate_percentage));
       lcd_put_wchar('%');
 
-      char buffer[14];
-      uint8_t timepos = 0;
-      #if ENABLED(SHOW_REMAINING_TIME)
-        const bool show_remain = TERN1(ROTATE_PROGRESS_DISPLAY, blink) && (printingIsActive() || marlin_state == MF_SD_COMPLETE);
-        if (show_remain) {
-          #if ENABLED(USE_M73_REMAINING_TIME)
-            duration_t remaining = get_remaining_time();
-          #else
-            uint8_t progress = get_progress_percent();
-            uint32_t elapsed = print_job_timer.duration();
-            duration_t remaining = (progress > 0) ? ((elapsed * 25600 / progress) >> 8) - elapsed : 0;
-          #endif
-          const uint8_t len = remaining.toDigital(buffer);
-          timepos = LCD_WIDTH - 1 - len;
-          lcd_put_wchar(timepos, 2, 'R');
-        }
-      #else
-        constexpr bool show_remain = false;
-      #endif
-
-      if (!show_remain) {
-        duration_t elapsed = print_job_timer.duration();
-        const uint8_t len = elapsed.toDigital(buffer);
-        timepos = LCD_WIDTH - 1 - len;
-        lcd_put_wchar(timepos, 2, LCD_STR_CLOCK[0]);
-      }
-      lcd_put_u8str(buffer);
+      const uint8_t timepos = draw_elapsed_or_remaining_time(LCD_WIDTH - 1);
 
       #if LCD_WIDTH >= 20
         lcd_moveto(timepos - 7, 2);
@@ -955,7 +958,7 @@ void MarlinUI::draw_status_screen() {
     #elif HAS_MULTI_HOTEND && HAS_HEATED_BED
       _draw_bed_status(blink);
     #elif HAS_PRINT_PROGRESS
-      #define DREW_PRINT_PROGRESS
+      #define DREW_PRINT_PROGRESS 1
       _draw_print_progress();
     #endif
 
@@ -963,14 +966,15 @@ void MarlinUI::draw_status_screen() {
     // Elapsed Time or SD Percent
     //
     lcd_moveto(LCD_WIDTH - 9, 2);
-    #if HAS_PRINT_PROGRESS && !defined(DREW_PRINT_PROGRESS)
+
+    #if HAS_PRINT_PROGRESS && !DREW_PRINT_PROGRESS
+
       _draw_print_progress();
+
     #else
-      duration_t elapsed = print_job_timer.duration();
-      char buffer[14];
-      (void)elapsed.toDigital(buffer);
-      lcd_put_wchar(LCD_STR_CLOCK[0]);
-      lcd_put_u8str(buffer);
+
+      (void)draw_elapsed_or_remaining_time(LCD_WIDTH - 4);
+
     #endif
 
   #endif // LCD_INFO_SCREEN_STYLE 1

commit c0b4f4eb47ee9d657581035737383d15b3706b79
Author: Lucas Seiki Oshiro <lucasseikioshiro@gmail.com>
Date:   Tue Oct 27 22:41:12 2020 -0300

    "Sound: ON/OFF" menu item (#19901)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index 4b82458398..81862e1ddf 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -113,6 +113,7 @@ static void createChar_P(const char c, const byte * const ptr) {
 
 #if ENABLED(LCD_USE_I2C_BUZZER)
   void MarlinUI::buzz(const long duration, const uint16_t freq) {
+    if (!buzzer_enabled) return;
     lcd.buzz(duration, freq);
   }
 #endif

commit ec23e37a4a31d12febc06922d3fa68446f58d7fb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Oct 24 17:13:10 2020 -0500

    Clean up comments, USB flash, NULLs

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
index 3c7993e375..4b82458398 100644
--- a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -1036,7 +1036,7 @@ void MarlinUI::draw_status_screen() {
   void MenuEditItemBase::draw_edit_screen(PGM_P const pstr, const char* const value/*=nullptr*/) {
     ui.encoder_direction_normal();
     uint8_t n = lcd_put_u8str_ind_P(0, 1, pstr, itemIndex, itemString, LCD_WIDTH - 1);
-    if (value != nullptr) {
+    if (value) {
       lcd_put_wchar(':'); n--;
       const uint8_t len = utf8_strlen(value) + 1;   // Plus one for a leading space
       const lcd_uint_t valrow = n < len ? 2 : 1;    // Value on the next row if it won't fit

commit eaf6777a6643a6fab23ceaaa4699cb2466ea6b83
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Oct 16 19:36:25 2020 -0500

    Rename ultralcd => marlinui

diff --git a/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
new file mode 100644
index 0000000000..3c7993e375
--- /dev/null
+++ b/Marlin/src/lcd/HD44780/marlinui_HD44780.cpp
@@ -0,0 +1,1520 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "../../inc/MarlinConfigPre.h"
+
+#if HAS_MARLINUI_HD44780
+
+/**
+ * marlinui_HD44780.cpp
+ *
+ * LCD display implementations for Hitachi HD44780.
+ * These are the most common LCD character displays.
+ */
+
+#include "marlinui_HD44780.h"
+#include "../marlinui.h"
+#include "../../libs/numtostr.h"
+
+#include "../../sd/cardreader.h"
+#include "../../module/temperature.h"
+#include "../../module/printcounter.h"
+#include "../../module/planner.h"
+#include "../../module/motion.h"
+
+#if DISABLED(LCD_PROGRESS_BAR) && BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
+  #include "../../feature/filwidth.h"
+  #include "../../gcode/parser.h"
+#endif
+
+#if ENABLED(AUTO_BED_LEVELING_UBL)
+  #include "../../feature/bedlevel/bedlevel.h"
+#endif
+
+//
+// Create LCD instance and chipset-specific information
+//
+
+#if ENABLED(LCD_I2C_TYPE_PCF8575)
+
+  LCD_CLASS lcd(LCD_I2C_ADDRESS, LCD_I2C_PIN_EN, LCD_I2C_PIN_RW, LCD_I2C_PIN_RS, LCD_I2C_PIN_D4, LCD_I2C_PIN_D5, LCD_I2C_PIN_D6, LCD_I2C_PIN_D7);
+
+#elif EITHER(LCD_I2C_TYPE_MCP23017, LCD_I2C_TYPE_MCP23008)
+
+  LCD_CLASS lcd(LCD_I2C_ADDRESS
+    #ifdef DETECT_DEVICE
+      , 1
+    #endif
+  );
+
+#elif ENABLED(LCD_I2C_TYPE_PCA8574)
+
+  LCD_CLASS lcd(LCD_I2C_ADDRESS, LCD_WIDTH, LCD_HEIGHT);
+
+#elif ENABLED(SR_LCD_2W_NL)
+
+  // 2 wire Non-latching LCD SR from:
+  // https://bitbucket.org/fmalpartida/new-liquidcrystal/wiki/schematics#!shiftregister-connection
+
+  LCD_CLASS lcd(SR_DATA_PIN, SR_CLK_PIN
+    #if PIN_EXISTS(SR_STROBE)
+      , SR_STROBE_PIN
+    #endif
+  );
+
+#elif ENABLED(SR_LCD_3W_NL)
+
+  // NewLiquidCrystal was not working
+  // https://github.com/mikeshub/SailfishLCD
+  // uses the code directly from Sailfish
+
+  LCD_CLASS lcd(SR_STROBE_PIN, SR_DATA_PIN, SR_CLK_PIN);
+
+#elif ENABLED(LCM1602)
+
+  LCD_CLASS lcd(0x27, 2, 1, 0, 4, 5, 6, 7, 3, POSITIVE);
+
+#else
+
+  // Standard direct-connected LCD implementations
+  LCD_CLASS lcd(LCD_PINS_RS, LCD_PINS_ENABLE, LCD_PINS_D4, LCD_PINS_D5, LCD_PINS_D6, LCD_PINS_D7);
+
+#endif
+
+static void createChar_P(const char c, const byte * const ptr) {
+  byte temp[8];
+  LOOP_L_N(i, 8)
+    temp[i] = pgm_read_byte(&ptr[i]);
+  lcd.createChar(c, temp);
+}
+
+#if ENABLED(LCD_PROGRESS_BAR)
+  #define LCD_STR_PROGRESS  "\x03\x04\x05"
+#endif
+
+#if ENABLED(LCD_USE_I2C_BUZZER)
+  void MarlinUI::buzz(const long duration, const uint16_t freq) {
+    lcd.buzz(duration, freq);
+  }
+#endif
+
+void MarlinUI::set_custom_characters(const HD44780CharSet screen_charset/*=CHARSET_INFO*/) {
+  #if NONE(LCD_PROGRESS_BAR, SHOW_BOOTSCREEN)
+    UNUSED(screen_charset);
+  #endif
+
+  // CHARSET_BOOT
+  #if ENABLED(SHOW_BOOTSCREEN)
+    const static PROGMEM byte corner[4][8] = { {
+      B00000,
+      B00000,
+      B00000,
+      B00000,
+      B00001,
+      B00010,
+      B00100,
+      B00100
+    }, {
+      B00000,
+      B00000,
+      B00000,
+      B11100,
+      B11100,
+      B01100,
+      B00100,
+      B00100
+    }, {
+      B00100,
+      B00010,
+      B00001,
+      B00000,
+      B00000,
+      B00000,
+      B00000,
+      B00000
+    }, {
+      B00100,
+      B01000,
+      B10000,
+      B00000,
+      B00000,
+      B00000,
+      B00000,
+      B00000
+    } };
+  #endif // SHOW_BOOTSCREEN
+
+  // CHARSET_INFO
+  const static PROGMEM byte bedTemp[8] = {
+    B00000,
+    B11111,
+    B10101,
+    B10001,
+    B10101,
+    B11111,
+    B00000,
+    B00000
+  };
+
+  const static PROGMEM byte degree[8] = {
+    B01100,
+    B10010,
+    B10010,
+    B01100,
+    B00000,
+    B00000,
+    B00000,
+    B00000
+  };
+
+  const static PROGMEM byte thermometer[8] = {
+    B00100,
+    B01010,
+    B01010,
+    B01010,
+    B01010,
+    B10001,
+    B10001,
+    B01110
+  };
+
+  const static PROGMEM byte uplevel[8] = {
+    B00100,
+    B01110,
+    B11111,
+    B00100,
+    B11100,
+    B00000,
+    B00000,
+    B00000
+  };
+
+  const static PROGMEM byte feedrate[8] = {
+    #if LCD_INFO_SCREEN_STYLE == 1
+      B00000,
+      B00100,
+      B10010,
+      B01001,
+      B10010,
+      B00100,
+      B00000,
+      B00000
+    #else
+      B11100,
+      B10000,
+      B11000,
+      B10111,
+      B00101,
+      B00110,
+      B00101,
+      B00000
+    #endif
+  };
+
+  const static PROGMEM byte clock[8] = {
+    B00000,
+    B01110,
+    B10011,
+    B10101,
+    B10001,
+    B01110,
+    B00000,
+    B00000
+  };
+
+  #if ENABLED(LCD_PROGRESS_BAR)
+
+    // CHARSET_INFO
+    const static PROGMEM byte progress[3][8] = { {
+      B00000,
+      B10000,
+      B10000,
+      B10000,
+      B10000,
+      B10000,
+      B10000,
+      B00000
+    }, {
+      B00000,
+      B10100,
+      B10100,
+      B10100,
+      B10100,
+      B10100,
+      B10100,
+      B00000
+    }, {
+      B00000,
+      B10101,
+      B10101,
+      B10101,
+      B10101,
+      B10101,
+      B10101,
+      B00000
+    } };
+
+  #endif // LCD_PROGRESS_BAR
+
+  #if BOTH(SDSUPPORT, HAS_LCD_MENU)
+
+    // CHARSET_MENU
+    const static PROGMEM byte refresh[8] = {
+      B00000,
+      B00110,
+      B11001,
+      B11000,
+      B00011,
+      B10011,
+      B01100,
+      B00000,
+    };
+    const static PROGMEM byte folder[8] = {
+      B00000,
+      B11100,
+      B11111,
+      B10001,
+      B10001,
+      B11111,
+      B00000,
+      B00000
+    };
+
+  #endif // SDSUPPORT
+
+  #if ENABLED(SHOW_BOOTSCREEN)
+    // Set boot screen corner characters
+    if (screen_charset == CHARSET_BOOT) {
+      for (uint8_t i = 4; i--;)
+        createChar_P(i, corner[i]);
+    }
+    else
+  #endif
+    { // Info Screen uses 5 special characters
+      createChar_P(LCD_STR_BEDTEMP[0], bedTemp);
+      createChar_P(LCD_STR_DEGREE[0], degree);
+      createChar_P(LCD_STR_THERMOMETER[0], thermometer);
+      createChar_P(LCD_STR_FEEDRATE[0], feedrate);
+      createChar_P(LCD_STR_CLOCK[0], clock);
+
+      #if ENABLED(LCD_PROGRESS_BAR)
+        if (screen_charset == CHARSET_INFO) { // 3 Progress bar characters for info screen
+          for (int16_t i = 3; i--;)
+            createChar_P(LCD_STR_PROGRESS[i], progress[i]);
+        }
+        else
+      #endif
+        {
+          createChar_P(LCD_STR_UPLEVEL[0], uplevel);
+          #if BOTH(SDSUPPORT, HAS_LCD_MENU)
+            // SD Card sub-menu special characters
+            createChar_P(LCD_STR_REFRESH[0], refresh);
+            createChar_P(LCD_STR_FOLDER[0], folder);
+          #endif
+        }
+    }
+
+}
+
+void MarlinUI::init_lcd() {
+
+  #if ENABLED(LCD_I2C_TYPE_PCF8575)
+    lcd.begin(LCD_WIDTH, LCD_HEIGHT);
+    #ifdef LCD_I2C_PIN_BL
+      lcd.setBacklightPin(LCD_I2C_PIN_BL, POSITIVE);
+      lcd.setBacklight(HIGH);
+    #endif
+
+  #elif ENABLED(LCD_I2C_TYPE_MCP23017)
+    lcd.setMCPType(LTI_TYPE_MCP23017);
+    lcd.begin(LCD_WIDTH, LCD_HEIGHT);
+    update_indicators();
+
+  #elif ENABLED(LCD_I2C_TYPE_MCP23008)
+    lcd.setMCPType(LTI_TYPE_MCP23008);
+    lcd.begin(LCD_WIDTH, LCD_HEIGHT);
+
+  #elif ENABLED(LCD_I2C_TYPE_PCA8574)
+    lcd.init();
+    lcd.backlight();
+
+  #else
+    lcd.begin(LCD_WIDTH, LCD_HEIGHT);
+  #endif
+
+  set_custom_characters(on_status_screen() ? CHARSET_INFO : CHARSET_MENU);
+
+  lcd.clear();
+}
+
+bool MarlinUI::detected() {
+  return (true
+    #if EITHER(LCD_I2C_TYPE_MCP23017, LCD_I2C_TYPE_MCP23008) && defined(DETECT_DEVICE)
+      && lcd.LcdDetected() == 1
+    #endif
+  );
+}
+
+#if HAS_SLOW_BUTTONS
+  uint8_t MarlinUI::read_slow_buttons() {
+    #if ENABLED(LCD_I2C_TYPE_MCP23017)
+      // Reading these buttons is too slow for interrupt context
+      // so they are read during LCD update in the main loop.
+      uint8_t slow_bits = lcd.readButtons()
+        #if !BUTTON_EXISTS(ENC)
+          << B_I2C_BTN_OFFSET
+        #endif
+      ;
+      #if ENABLED(LCD_I2C_VIKI)
+        if ((slow_bits & (B_MI | B_RI)) && PENDING(millis(), next_button_update_ms)) // LCD clicked
+          slow_bits &= ~(B_MI | B_RI); // Disable LCD clicked buttons if screen is updated
+      #endif
+      return slow_bits;
+    #endif // LCD_I2C_TYPE_MCP23017
+  }
+#endif
+
+void MarlinUI::clear_lcd() { lcd.clear(); }
+
+#if ENABLED(SHOW_BOOTSCREEN)
+
+  void lcd_erase_line(const lcd_uint_t line) {
+    lcd_moveto(0, line);
+    for (uint8_t i = LCD_WIDTH + 1; --i;)
+      lcd_put_wchar(' ');
+  }
+
+  // Scroll the PSTR 'text' in a 'len' wide field for 'time' milliseconds at position col,line
+  void lcd_scroll(const lcd_uint_t col, const lcd_uint_t line, PGM_P const text, const uint8_t len, const int16_t time) {
+    uint8_t slen = utf8_strlen_P(text);
+    if (slen < len) {
+      lcd_put_u8str_max_P(col, line, text, len);
+      for (; slen < len; ++slen) lcd_put_wchar(' ');
+      safe_delay(time);
+    }
+    else {
+      PGM_P p = text;
+      int dly = time / _MAX(slen, 1);
+      LOOP_LE_N(i, slen) {
+
+        // Print the text at the correct place
+        lcd_put_u8str_max_P(col, line, p, len);
+
+        // Fill with spaces
+        for (uint8_t ix = slen - i; ix < len; ++ix) lcd_put_wchar(' ');
+
+        // Delay
+        safe_delay(dly);
+
+        // Advance to the next UTF8 valid position
+        p++;
+        while (!START_OF_UTF8_CHAR(pgm_read_byte(p))) p++;
+      }
+    }
+  }
+
+  static void logo_lines(PGM_P const extra) {
+    int16_t indent = (LCD_WIDTH - 8 - utf8_strlen_P(extra)) / 2;
+    lcd_put_wchar(indent, 0, '\x00'); lcd_put_u8str_P(PSTR( "------" ));  lcd_put_wchar('\x01');
+    lcd_put_u8str_P(indent, 1, PSTR("|Marlin|"));  lcd_put_u8str_P(extra);
+    lcd_put_wchar(indent, 2, '\x02'); lcd_put_u8str_P(PSTR( "------" ));  lcd_put_wchar('\x03');
+  }
+
+  void MarlinUI::show_bootscreen() {
+    set_custom_characters(CHARSET_BOOT);
+    lcd.clear();
+
+    #define LCD_EXTRA_SPACE (LCD_WIDTH-8)
+
+    #define CENTER_OR_SCROLL(STRING,DELAY) \
+      lcd_erase_line(3); \
+      if (utf8_strlen(STRING) <= LCD_WIDTH) { \
+        lcd_put_u8str_P((LCD_WIDTH - utf8_strlen_P(PSTR(STRING))) / 2, 3, PSTR(STRING)); \
+        safe_delay(DELAY); \
+      } \
+      else { \
+        lcd_scroll(0, 3, PSTR(STRING), LCD_WIDTH, DELAY); \
+      }
+
+    //
+    // Show the Marlin logo with splash line 1
+    //
+    if (LCD_EXTRA_SPACE >= utf8_strlen(SHORT_BUILD_VERSION) + 1) {
+      //
+      // Show the Marlin logo, splash line1, and splash line 2
+      //
+      logo_lines(PSTR(" " SHORT_BUILD_VERSION));
+      CENTER_OR_SCROLL(MARLIN_WEBSITE_URL, 2000);
+    }
+    else {
+      //
+      // Show the Marlin logo and short build version
+      // After a delay show the website URL
+      //
+      extern const char NUL_STR[];
+      logo_lines(NUL_STR);
+      CENTER_OR_SCROLL(SHORT_BUILD_VERSION, 1500);
+      CENTER_OR_SCROLL(MARLIN_WEBSITE_URL, 1500);
+      #ifdef STRING_SPLASH_LINE3
+        CENTER_OR_SCROLL(STRING_SPLASH_LINE3, 1500);
+      #endif
+    }
+
+    lcd.clear();
+    safe_delay(100);
+    set_custom_characters(CHARSET_INFO);
+    lcd.clear();
+  }
+
+#endif // SHOW_BOOTSCREEN
+
+void MarlinUI::draw_kill_screen() {
+  lcd_put_u8str(0, 0, status_message);
+  lcd_uint_t y = 2;
+  #if LCD_HEIGHT >= 4
+    lcd_put_u8str_P(0, y++, GET_TEXT(MSG_HALTED));
+  #endif
+  lcd_put_u8str_P(0, y, GET_TEXT(MSG_PLEASE_RESET));
+}
+
+//
+// Before homing, blink '123' <-> '???'.
+// Homed but unknown... '123' <-> '   '.
+// Homed and known, display constantly.
+//
+FORCE_INLINE void _draw_axis_value(const AxisEnum axis, const char *value, const bool blink) {
+  lcd_put_wchar('X' + uint8_t(axis));
+  if (blink)
+    lcd_put_u8str(value);
+  else {
+    if (!TEST(axis_homed, axis))
+      while (const char c = *value++) lcd_put_wchar(c <= '.' ? c : '?');
+    else {
+      #if NONE(HOME_AFTER_DEACTIVATE, DISABLE_REDUCED_ACCURACY_WARNING)
+        if (!TEST(axis_known_position, axis))
+          lcd_put_u8str_P(axis == Z_AXIS ? PSTR("       ") : PSTR("    "));
+        else
+      #endif
+          lcd_put_u8str(value);
+    }
+  }
+}
+
+FORCE_INLINE void _draw_heater_status(const heater_id_t heater_id, const char prefix, const bool blink) {
+  #if HAS_HEATED_BED
+    const bool isBed = TERN(HAS_HEATED_CHAMBER, heater_id == H_BED, heater_id < 0);
+    const float t1 = (isBed ? thermalManager.degBed()       : thermalManager.degHotend(heater_id)),
+                t2 = (isBed ? thermalManager.degTargetBed() : thermalManager.degTargetHotend(heater_id));
+  #else
+    const float t1 = thermalManager.degHotend(heater_id), t2 = thermalManager.degTargetHotend(heater_id);
+  #endif
+
+  if (prefix >= 0) lcd_put_wchar(prefix);
+
+  lcd_put_u8str(i16tostr3rj(t1 + 0.5));
+  lcd_put_wchar('/');
+
+  #if !HEATER_IDLE_HANDLER
+    UNUSED(blink);
+  #else
+    if (!blink && thermalManager.heater_idle[thermalManager.idle_index_for_id(heater_id)].timed_out) {
+      lcd_put_wchar(' ');
+      if (t2 >= 10) lcd_put_wchar(' ');
+      if (t2 >= 100) lcd_put_wchar(' ');
+    }
+    else
+  #endif
+      lcd_put_u8str(i16tostr3left(t2 + 0.5));
+
+  if (prefix >= 0) {
+    lcd_put_wchar(LCD_STR_DEGREE[0]);
+    lcd_put_wchar(' ');
+    if (t2 < 10) lcd_put_wchar(' ');
+  }
+}
+
+FORCE_INLINE void _draw_bed_status(const bool blink) {
+  _draw_heater_status(H_BED, TERN0(HAS_LEVELING, blink && planner.leveling_active) ? '_' : LCD_STR_BEDTEMP[0], blink);
+}
+
+#if HAS_PRINT_PROGRESS
+
+  FORCE_INLINE void _draw_print_progress() {
+    const uint8_t progress = ui.get_progress_percent();
+    lcd_put_u8str_P(PSTR(TERN(SDSUPPORT, "SD", "P:")));
+    if (progress)
+      lcd_put_u8str(ui8tostr3rj(progress));
+    else
+      lcd_put_u8str_P(PSTR("---"));
+    lcd_put_wchar('%');
+  }
+
+#endif
+
+#if ENABLED(LCD_PROGRESS_BAR)
+
+  void MarlinUI::draw_progress_bar(const uint8_t percent) {
+    const int16_t tix = (int16_t)(percent * (LCD_WIDTH) * 3) / 100,
+              cel = tix / 3,
+              rem = tix % 3;
+    uint8_t i = LCD_WIDTH;
+    char msg[LCD_WIDTH + 1], b = ' ';
+    msg[LCD_WIDTH] = '\0';
+    while (i--) {
+      if (i == cel - 1)
+        b = LCD_STR_PROGRESS[2];
+      else if (i == cel && rem != 0)
+        b = LCD_STR_PROGRESS[rem - 1];
+      msg[i] = b;
+    }
+    lcd_put_u8str(msg);
+  }
+
+#endif // LCD_PROGRESS_BAR
+
+void MarlinUI::draw_status_message(const bool blink) {
+
+  lcd_moveto(0, LCD_HEIGHT - 1);
+
+  #if ENABLED(LCD_PROGRESS_BAR)
+
+    // Draw the progress bar if the message has shown long enough
+    // or if there is no message set.
+    if (ELAPSED(millis(), progress_bar_ms + PROGRESS_BAR_MSG_TIME) || !has_status()) {
+      const uint8_t progress = get_progress_percent();
+      if (progress > 2) return draw_progress_bar(progress);
+    }
+
+  #elif BOTH(FILAMENT_LCD_DISPLAY, SDSUPPORT)
+
+    // Alternate Status message and Filament display
+    if (ELAPSED(millis(), next_filament_display)) {
+      lcd_put_u8str_P(PSTR("Dia "));
+      lcd_put_u8str(ftostr12ns(filwidth.measured_mm));
+      lcd_put_u8str_P(PSTR(" V"));
+      lcd_put_u8str(i16tostr3rj(planner.volumetric_percent(parser.volumetric_enabled)));
+      lcd_put_wchar('%');
+      return;
+    }
+
+  #endif // FILAMENT_LCD_DISPLAY && SDSUPPORT
+
+  #if ENABLED(STATUS_MESSAGE_SCROLLING)
+    static bool last_blink = false;
+
+    // Get the UTF8 character count of the string
+    uint8_t slen = utf8_strlen(status_message);
+
+    // If the string fits into the LCD, just print it and do not scroll it
+    if (slen <= LCD_WIDTH) {
+
+      // The string isn't scrolling and may not fill the screen
+      lcd_put_u8str(status_message);
+
+      // Fill the rest with spaces
+      while (slen < LCD_WIDTH) { lcd_put_wchar(' '); ++slen; }
+    }
+    else {
+      // String is larger than the available space in screen.
+
+      // Get a pointer to the next valid UTF8 character
+      // and the string remaining length
+      uint8_t rlen;
+      const char *stat = status_and_len(rlen);
+      lcd_put_u8str_max(stat, LCD_WIDTH);     // The string leaves space
+
+      // If the remaining string doesn't completely fill the screen
+      if (rlen < LCD_WIDTH) {
+        lcd_put_wchar('.');                   // Always at 1+ spaces left, draw a dot
+        uint8_t chars = LCD_WIDTH - rlen;     // Amount of space left in characters
+        if (--chars) {                        // Draw a second dot if there's space
+          lcd_put_wchar('.');
+          if (--chars)
+            lcd_put_u8str_max(status_message, chars); // Print a second copy of the message
+        }
+      }
+      if (last_blink != blink) {
+        last_blink = blink;
+        advance_status_scroll();
+      }
+    }
+  #else
+    UNUSED(blink);
+
+    // Get the UTF8 character count of the string
+    uint8_t slen = utf8_strlen(status_message);
+
+    // Just print the string to the LCD
+    lcd_put_u8str_max(status_message, LCD_WIDTH);
+
+    // Fill the rest with spaces if there are missing spaces
+    while (slen < LCD_WIDTH) {
+      lcd_put_wchar(' ');
+      ++slen;
+    }
+  #endif
+}
+
+/**
+ *  LCD_INFO_SCREEN_STYLE 0 : Classic Status Screen
+ *
+ *  16x2   |000/000 B000/000|
+ *         |0123456789012345|
+ *
+ *  16x4   |000/000 B000/000|
+ *         |SD---%  Z 000.00|
+ *         |F---%     T--:--|
+ *         |0123456789012345|
+ *
+ *  20x2   |T000/000¬∞ B000/000¬∞ |
+ *         |01234567890123456789|
+ *
+ *  20x4   |T000/000¬∞ B000/000¬∞ |
+ *         |X 000 Y 000 Z000.000|
+ *         |F---%  SD---% T--:--|
+ *         |01234567890123456789|
+ *
+ *  LCD_INFO_SCREEN_STYLE 1 : Pr≈Ø≈°a-style Status Screen
+ *
+ *  |T000/000¬∞  Z 000.00 |
+ *  |B000/000¬∞  F---%    |
+ *  |SD---%     T--:--   |
+ *  |01234567890123456789|
+ *
+ *  |T000/000¬∞  Z 000.00 |
+ *  |T000/000¬∞  F---%    |
+ *  |B000/000¬∞  SD---%   |
+ *  |01234567890123456789|
+ */
+
+void MarlinUI::draw_status_screen() {
+
+  const bool blink = get_blink();
+  lcd_moveto(0, 0);
+
+  #if LCD_INFO_SCREEN_STYLE == 0
+
+    // ========== Line 1 ==========
+
+    #if LCD_WIDTH < 20
+
+      //
+      // Hotend 0 Temperature
+      //
+      _draw_heater_status(H_E0, -1, blink);
+
+      //
+      // Hotend 1 or Bed Temperature
+      //
+      #if HAS_MULTI_HOTEND
+        lcd_moveto(8, 0);
+        _draw_heater_status(H_E1, LCD_STR_THERMOMETER[0], blink);
+      #elif HAS_HEATED_BED
+        lcd_moveto(8, 0);
+        _draw_bed_status(blink);
+      #endif
+
+    #else // LCD_WIDTH >= 20
+
+      //
+      // Hotend 0 Temperature
+      //
+      _draw_heater_status(H_E0, LCD_STR_THERMOMETER[0], blink);
+
+      //
+      // Hotend 1 or Bed Temperature
+      //
+      #if HAS_MULTI_HOTEND
+        lcd_moveto(10, 0);
+        _draw_heater_status(H_E1, LCD_STR_THERMOMETER[0], blink);
+      #elif HAS_HEATED_BED
+        lcd_moveto(10, 0);
+        _draw_bed_status(blink);
+      #endif
+
+    #endif // LCD_WIDTH >= 20
+
+    // ========== Line 2 ==========
+
+    #if LCD_HEIGHT > 2
+
+      #if LCD_WIDTH < 20
+
+        #if HAS_PRINT_PROGRESS
+          lcd_moveto(0, 2);
+          _draw_print_progress();
+        #endif
+
+      #else // LCD_WIDTH >= 20
+
+        lcd_moveto(0, 1);
+
+        // If the first line has two extruder temps,
+        // show more temperatures on the next line
+
+        #if HOTENDS > 2 || (HAS_MULTI_HOTEND && HAS_HEATED_BED)
+
+          #if HOTENDS > 2
+            _draw_heater_status(H_E2, LCD_STR_THERMOMETER[0], blink);
+            lcd_moveto(10, 1);
+          #endif
+
+          _draw_bed_status(blink);
+
+        #else // HOTENDS <= 2 && (HOTENDS <= 1 || !HAS_HEATED_BED)
+
+          #if HAS_DUAL_MIXING
+
+            // Two-component mix / gradient instead of XY
+
+            char mixer_messages[12];
+            const char *mix_label;
+            #if ENABLED(GRADIENT_MIX)
+              if (mixer.gradient.enabled) {
+                mixer.update_mix_from_gradient();
+                mix_label = "Gr";
+              }
+              else
+            #endif
+              {
+                mixer.update_mix_from_vtool();
+                mix_label = "Mx";
+              }
+            sprintf_P(mixer_messages, PSTR("%s %d;%d%% "), mix_label, int(mixer.mix[0]), int(mixer.mix[1]));
+            lcd_put_u8str(mixer_messages);
+
+          #else // !HAS_DUAL_MIXING
+
+            const bool show_e_total = TERN0(LCD_SHOW_E_TOTAL, printingIsActive() || marlin_state == MF_SD_COMPLETE);
+
+            if (show_e_total) {
+              #if ENABLED(LCD_SHOW_E_TOTAL)
+                char tmp[20];
+                const uint8_t escale = e_move_accumulator >= 100000.0f ? 10 : 1; // After 100m switch to cm
+                sprintf_P(tmp, PSTR("E %ld%cm       "), uint32_t(_MAX(e_move_accumulator, 0.0f)) / escale, escale == 10 ? 'c' : 'm'); // 1234567mm
+                lcd_put_u8str(tmp);
+              #endif
+            }
+            else {
+              const xy_pos_t lpos = current_position.asLogical();
+              _draw_axis_value(X_AXIS, ftostr4sign(lpos.x), blink);
+              lcd_put_wchar(' ');
+              _draw_axis_value(Y_AXIS, ftostr4sign(lpos.y), blink);
+            }
+
+          #endif // !HAS_DUAL_MIXING
+
+        #endif // HOTENDS <= 2 && (HOTENDS <= 1 || !HAS_HEATED_BED)
+
+      #endif // LCD_WIDTH >= 20
+
+      lcd_moveto(LCD_WIDTH - 8, 1);
+      _draw_axis_value(Z_AXIS, ftostr52sp(LOGICAL_Z_POSITION(current_position.z)), blink);
+
+      #if HAS_LEVELING && !HAS_HEATED_BED
+        lcd_put_wchar(planner.leveling_active || blink ? '_' : ' ');
+      #endif
+
+    #endif // LCD_HEIGHT > 2
+
+    // ========== Line 3 ==========
+
+    #if LCD_HEIGHT > 3
+
+      lcd_put_wchar(0, 2, LCD_STR_FEEDRATE[0]);
+      lcd_put_u8str(i16tostr3rj(feedrate_percentage));
+      lcd_put_wchar('%');
+
+      char buffer[14];
+      uint8_t timepos = 0;
+      #if ENABLED(SHOW_REMAINING_TIME)
+        const bool show_remain = TERN1(ROTATE_PROGRESS_DISPLAY, blink) && (printingIsActive() || marlin_state == MF_SD_COMPLETE);
+        if (show_remain) {
+          #if ENABLED(USE_M73_REMAINING_TIME)
+            duration_t remaining = get_remaining_time();
+          #else
+            uint8_t progress = get_progress_percent();
+            uint32_t elapsed = print_job_timer.duration();
+            duration_t remaining = (progress > 0) ? ((elapsed * 25600 / progress) >> 8) - elapsed : 0;
+          #endif
+          const uint8_t len = remaining.toDigital(buffer);
+          timepos = LCD_WIDTH - 1 - len;
+          lcd_put_wchar(timepos, 2, 'R');
+        }
+      #else
+        constexpr bool show_remain = false;
+      #endif
+
+      if (!show_remain) {
+        duration_t elapsed = print_job_timer.duration();
+        const uint8_t len = elapsed.toDigital(buffer);
+        timepos = LCD_WIDTH - 1 - len;
+        lcd_put_wchar(timepos, 2, LCD_STR_CLOCK[0]);
+      }
+      lcd_put_u8str(buffer);
+
+      #if LCD_WIDTH >= 20
+        lcd_moveto(timepos - 7, 2);
+        #if HAS_PRINT_PROGRESS
+          _draw_print_progress();
+        #else
+          char c;
+          uint16_t per;
+          #if HAS_FAN0
+            if (true
+              #if EXTRUDERS && ENABLED(ADAPTIVE_FAN_SLOWING)
+                && (blink || thermalManager.fan_speed_scaler[0] < 128)
+              #endif
+            ) {
+              uint16_t spd = thermalManager.fan_speed[0];
+              if (blink) c = 'F';
+              #if ENABLED(ADAPTIVE_FAN_SLOWING)
+                else { c = '*'; spd = thermalManager.scaledFanSpeed(0, spd); }
+              #endif
+              per = thermalManager.fanPercent(spd);
+            }
+            else
+          #endif
+            {
+              #if EXTRUDERS
+                c = 'E';
+                per = planner.flow_percentage[0];
+              #endif
+            }
+          lcd_put_wchar(c);
+          lcd_put_u8str(i16tostr3rj(per));
+          lcd_put_wchar('%');
+        #endif
+      #endif
+
+    #endif // LCD_HEIGHT > 3
+
+  #elif LCD_INFO_SCREEN_STYLE == 1
+
+    // ========== Line 1 ==========
+
+    //
+    // Hotend 0 Temperature
+    //
+    _draw_heater_status(H_E0, LCD_STR_THERMOMETER[0], blink);
+
+    //
+    // Z Coordinate
+    //
+    lcd_moveto(LCD_WIDTH - 9, 0);
+    _draw_axis_value(Z_AXIS, ftostr52sp(LOGICAL_Z_POSITION(current_position.z)), blink);
+
+    #if HAS_LEVELING && (HAS_MULTI_HOTEND || !HAS_HEATED_BED)
+      lcd_put_wchar(LCD_WIDTH - 1, 0, planner.leveling_active || blink ? '_' : ' ');
+    #endif
+
+    // ========== Line 2 ==========
+
+    //
+    // Hotend 1 or Bed Temperature
+    //
+    lcd_moveto(0, 1);
+    #if HAS_MULTI_HOTEND
+      _draw_heater_status(H_E1, LCD_STR_THERMOMETER[0], blink);
+    #elif HAS_HEATED_BED
+      _draw_bed_status(blink);
+    #endif
+
+    lcd_put_wchar(LCD_WIDTH - 9, 1, LCD_STR_FEEDRATE[0]);
+    lcd_put_u8str(i16tostr3rj(feedrate_percentage));
+    lcd_put_wchar('%');
+
+    // ========== Line 3 ==========
+
+    //
+    // SD Percent, Hotend 2, or Bed
+    //
+    lcd_moveto(0, 2);
+    #if HOTENDS > 2
+      _draw_heater_status(H_E2, LCD_STR_THERMOMETER[0], blink);
+    #elif HAS_MULTI_HOTEND && HAS_HEATED_BED
+      _draw_bed_status(blink);
+    #elif HAS_PRINT_PROGRESS
+      #define DREW_PRINT_PROGRESS
+      _draw_print_progress();
+    #endif
+
+    //
+    // Elapsed Time or SD Percent
+    //
+    lcd_moveto(LCD_WIDTH - 9, 2);
+    #if HAS_PRINT_PROGRESS && !defined(DREW_PRINT_PROGRESS)
+      _draw_print_progress();
+    #else
+      duration_t elapsed = print_job_timer.duration();
+      char buffer[14];
+      (void)elapsed.toDigital(buffer);
+      lcd_put_wchar(LCD_STR_CLOCK[0]);
+      lcd_put_u8str(buffer);
+    #endif
+
+  #endif // LCD_INFO_SCREEN_STYLE 1
+
+  // ========= Last Line ========
+
+  //
+  // Status Message (which may be a Progress Bar or Filament display)
+  //
+  draw_status_message(blink);
+}
+
+#if HAS_LCD_MENU
+
+  #include "../menu/menu.h"
+
+  #if ENABLED(ADVANCED_PAUSE_FEATURE)
+
+    void MarlinUI::draw_hotend_status(const uint8_t row, const uint8_t extruder) {
+      if (row < LCD_HEIGHT) {
+        lcd_moveto(LCD_WIDTH - 9, row);
+        _draw_heater_status((heater_id_t)extruder, LCD_STR_THERMOMETER[0], get_blink());
+      }
+    }
+
+  #endif // ADVANCED_PAUSE_FEATURE
+
+  // Draw a static item with no left-right margin required. Centered by default.
+  void MenuItem_static::draw(const uint8_t row, PGM_P const pstr, const uint8_t style/*=SS_DEFAULT*/, const char * const vstr/*=nullptr*/) {
+    int8_t n = LCD_WIDTH;
+    lcd_moveto(0, row);
+    const int8_t plen = pstr ? utf8_strlen_P(pstr) : 0,
+                 vlen = vstr ? utf8_strlen(vstr) : 0;
+    if (style & SS_CENTER) {
+      int8_t pad = (LCD_WIDTH - plen - vlen) / 2;
+      while (--pad >= 0) { lcd_put_wchar(' '); n--; }
+    }
+    if (plen) n = lcd_put_u8str_ind_P(pstr, itemIndex, itemString, n);
+    if (vlen) n -= lcd_put_u8str_max(vstr, n);
+    for (; n > 0; --n) lcd_put_wchar(' ');
+  }
+
+  // Draw a generic menu item with pre_char (if selected) and post_char
+  void MenuItemBase::_draw(const bool sel, const uint8_t row, PGM_P const pstr, const char pre_char, const char post_char) {
+    lcd_put_wchar(0, row, sel ? pre_char : ' ');
+    uint8_t n = lcd_put_u8str_ind_P(pstr, itemIndex, itemString, LCD_WIDTH - 2);
+    for (; n; --n) lcd_put_wchar(' ');
+    lcd_put_wchar(post_char);
+  }
+
+  // Draw a menu item with a (potentially) editable value
+  void MenuEditItemBase::draw(const bool sel, const uint8_t row, PGM_P const pstr, const char* const inStr, const bool pgm) {
+    const uint8_t vlen = inStr ? (pgm ? utf8_strlen_P(inStr) : utf8_strlen(inStr)) : 0;
+    lcd_put_wchar(0, row, sel ? LCD_STR_ARROW_RIGHT[0] : ' ');
+    uint8_t n = lcd_put_u8str_ind_P(pstr, itemIndex, itemString, LCD_WIDTH - 2 - vlen);
+    if (vlen) {
+      lcd_put_wchar(':');
+      for (; n; --n) lcd_put_wchar(' ');
+      if (pgm) lcd_put_u8str_P(inStr); else lcd_put_u8str(inStr);
+    }
+  }
+
+  // Low-level draw_edit_screen can be used to draw an edit screen from anyplace
+  void MenuEditItemBase::draw_edit_screen(PGM_P const pstr, const char* const value/*=nullptr*/) {
+    ui.encoder_direction_normal();
+    uint8_t n = lcd_put_u8str_ind_P(0, 1, pstr, itemIndex, itemString, LCD_WIDTH - 1);
+    if (value != nullptr) {
+      lcd_put_wchar(':'); n--;
+      const uint8_t len = utf8_strlen(value) + 1;   // Plus one for a leading space
+      const lcd_uint_t valrow = n < len ? 2 : 1;    // Value on the next row if it won't fit
+      lcd_put_wchar(LCD_WIDTH - len, valrow, ' ');  // Right-justified, padded, leading space
+      lcd_put_u8str(value);
+    }
+  }
+
+  // The Select Screen presents a prompt and two "buttons"
+  void MenuItem_confirm::draw_select_screen(PGM_P const yes, PGM_P const no, const bool yesno, PGM_P const pref, const char * const string/*=nullptr*/, PGM_P const suff/*=nullptr*/) {
+    ui.draw_select_screen_prompt(pref, string, suff);
+    SETCURSOR(0, LCD_HEIGHT - 1);
+    lcd_put_wchar(yesno ? ' ' : '['); lcd_put_u8str_P(no); lcd_put_wchar(yesno ? ' ' : ']');
+    SETCURSOR_RJ(utf8_strlen_P(yes) + 2, LCD_HEIGHT - 1);
+    lcd_put_wchar(yesno ? '[' : ' '); lcd_put_u8str_P(yes); lcd_put_wchar(yesno ? ']' : ' ');
+  }
+
+  #if ENABLED(SDSUPPORT)
+
+    void MenuItem_sdbase::draw(const bool sel, const uint8_t row, PGM_P const, CardReader &theCard, const bool isDir) {
+      lcd_put_wchar(0, row, sel ? LCD_STR_ARROW_RIGHT[0] : ' ');
+      constexpr uint8_t maxlen = LCD_WIDTH - 2;
+      uint8_t n = maxlen - lcd_put_u8str_max(ui.scrolled_filename(theCard, maxlen, row, sel), maxlen);
+      for (; n; --n) lcd_put_wchar(' ');
+      lcd_put_wchar(isDir ? LCD_STR_FOLDER[0] : ' ');
+    }
+
+  #endif
+
+  #if ENABLED(LCD_HAS_STATUS_INDICATORS)
+
+    void MarlinUI::update_indicators() {
+      // Set the LEDS - referred to as backlights by the LiquidTWI2 library
+      static uint8_t ledsprev = 0;
+      uint8_t leds = 0;
+
+      if (TERN0(HAS_HEATED_BED, thermalManager.degTargetBed() > 0)) leds |= LED_A;
+      if (TERN0(HAS_HOTEND, thermalManager.degTargetHotend(0) > 0)) leds |= LED_B;
+
+      #if HAS_FAN
+        if ( TERN0(HAS_FAN0, thermalManager.fan_speed[0])
+          || TERN0(HAS_FAN1, thermalManager.fan_speed[1])
+          || TERN0(HAS_FAN2, thermalManager.fan_speed[2])
+          || TERN0(HAS_FAN3, thermalManager.fan_speed[3])
+          || TERN0(HAS_FAN4, thermalManager.fan_speed[4])
+          || TERN0(HAS_FAN5, thermalManager.fan_speed[5])
+          || TERN0(HAS_FAN6, thermalManager.fan_speed[6])
+          || TERN0(HAS_FAN7, thermalManager.fan_speed[7])
+        ) leds |= LED_C;
+      #endif // HAS_FAN
+
+      if (TERN0(HAS_MULTI_HOTEND, thermalManager.degTargetHotend(1) > 0)) leds |= LED_C;
+
+      if (leds != ledsprev) {
+        lcd.setBacklight(leds);
+        ledsprev = leds;
+      }
+    }
+
+  #endif // LCD_HAS_STATUS_INDICATORS
+
+  #if ENABLED(AUTO_BED_LEVELING_UBL)
+
+    #define HD44780_CHAR_WIDTH    5
+    #define HD44780_CHAR_HEIGHT   8
+    #define MESH_MAP_COLS         7
+    #define MESH_MAP_ROWS         4
+
+    #define CHAR_LINE_TOP         0
+    #define CHAR_LINE_BOT         1
+    #define CHAR_EDGE_L           2
+    #define CHAR_EDGE_R           3
+    #define CHAR_UL_UL            4
+    #define CHAR_LR_UL            5
+    #define CHAR_UL_LR            6
+    #define CHAR_LR_LR            7
+
+    #define TOP_LEFT         _BV(0)
+    #define TOP_RIGHT        _BV(1)
+    #define LOWER_LEFT       _BV(2)
+    #define LOWER_RIGHT      _BV(3)
+
+    /**
+     * Possible map screens:
+     *
+     * 16x2   |X000.00  Y000.00|
+     *        |(00,00)  Z00.000|
+     *
+     * 20x2   | X:000.00  Y:000.00 |
+     *        | (00,00)   Z:00.000 |
+     *
+     * 16x4   |+-------+(00,00)|
+     *        ||       |X000.00|
+     *        ||       |Y000.00|
+     *        |+-------+Z00.000|
+     *
+     * 20x4   | +-------+  (00,00) |
+     *        | |       |  X:000.00|
+     *        | |       |  Y:000.00|
+     *        | +-------+  Z:00.000|
+     */
+
+    typedef struct {
+      uint8_t custom_char_bits[HD44780_CHAR_HEIGHT];
+    } custom_char;
+
+    typedef struct {
+      lcd_uint_t column, row,
+                 x_pixel_offset, y_pixel_offset;
+      uint8_t x_pixel_mask;
+    } coordinate;
+
+    void add_edges_to_custom_char(custom_char &custom, const coordinate &ul, const coordinate &lr, const coordinate &brc, const uint8_t cell_location);
+    FORCE_INLINE static void clear_custom_char(custom_char * const cc) { ZERO(cc->custom_char_bits); }
+
+    coordinate pixel_location(int16_t x, int16_t y) {
+      coordinate ret_val;
+      int16_t xp, yp, r, c;
+
+      x++; y++; // +1 because lines on the left and top
+
+      c = x / (HD44780_CHAR_WIDTH);
+      r = y / (HD44780_CHAR_HEIGHT);
+
+      ret_val.column = c;
+      ret_val.row    = r;
+
+      xp = x - c * (HD44780_CHAR_WIDTH);                                    // Get the pixel offsets into the character cell
+      xp = HD44780_CHAR_WIDTH - 1 - xp;                                     // Column within relevant character cell (0 on the right)
+      yp = y - r * (HD44780_CHAR_HEIGHT);
+
+      ret_val.x_pixel_mask   = _BV(xp);
+      ret_val.x_pixel_offset = xp;
+      ret_val.y_pixel_offset = yp;
+      return ret_val;
+    }
+
+    inline coordinate pixel_location(const lcd_uint_t x, const lcd_uint_t y) { return pixel_location((int16_t)x, (int16_t)y); }
+
+    void prep_and_put_map_char(custom_char &chrdata, const coordinate &ul, const coordinate &lr, const coordinate &brc, const uint8_t cl, const char c, const lcd_uint_t x, const lcd_uint_t y) {
+      add_edges_to_custom_char(chrdata, ul, lr, brc, cl);
+      lcd.createChar(c, (uint8_t*)&chrdata);
+      lcd_put_wchar(x, y, c);
+    }
+
+    void MarlinUI::ubl_plot(const uint8_t x_plot, const uint8_t y_plot) {
+
+      #if LCD_WIDTH >= 20
+        #define _LCD_W_POS 12
+        #define _PLOT_X 1
+        #define _MAP_X 3
+        #define _LABEL(C,X,Y) lcd_put_u8str_P(X, Y, C)
+        #define _XLABEL(X,Y) _LABEL(X_LBL,X,Y)
+        #define _YLABEL(X,Y) _LABEL(Y_LBL,X,Y)
+        #define _ZLABEL(X,Y) _LABEL(Z_LBL,X,Y)
+      #else
+        #define _LCD_W_POS 8
+        #define _PLOT_X 0
+        #define _MAP_X 1
+        #define _LABEL(X,Y,C) lcd_put_wchar(X, Y, C)
+        #define _XLABEL(X,Y) _LABEL('X',X,Y)
+        #define _YLABEL(X,Y) _LABEL('Y',X,Y)
+        #define _ZLABEL(X,Y) _LABEL('Z',X,Y)
+      #endif
+
+      #if LCD_HEIGHT <= 3   // 16x2 or 20x2 display
+
+        /**
+         * Show X and Y positions
+         */
+        _XLABEL(_PLOT_X, 0);
+        lcd_put_u8str(ftostr52(LOGICAL_X_POSITION(ubl.mesh_index_to_xpos(x_plot))));
+        _YLABEL(_LCD_W_POS, 0);
+        lcd_put_u8str(ftostr52(LOGICAL_Y_POSITION(ubl.mesh_index_to_ypos(y_plot))));
+
+        lcd_moveto(_PLOT_X, 0);
+
+      #else // 16x4 or 20x4 display
+
+        coordinate upper_left, lower_right, bottom_right_corner;
+        custom_char new_char;
+        uint8_t i, n, n_rows, n_cols;
+        lcd_uint_t j, k, l, m, bottom_line, right_edge,
+                   x_map_pixels, y_map_pixels,
+                   pixels_per_x_mesh_pnt, pixels_per_y_mesh_pnt,
+                   suppress_x_offset = 0, suppress_y_offset = 0;
+
+        const uint8_t y_plot_inv = (GRID_MAX_POINTS_Y - 1) - y_plot;
+
+        upper_left.column  = 0;
+        upper_left.row     = 0;
+        lower_right.column = 0;
+        lower_right.row    = 0;
+
+        clear_lcd();
+
+        x_map_pixels = (HD44780_CHAR_WIDTH) * (MESH_MAP_COLS) - 2;          // Minus 2 because we are drawing a box around the map
+        y_map_pixels = (HD44780_CHAR_HEIGHT) * (MESH_MAP_ROWS) - 2;
+
+        pixels_per_x_mesh_pnt = x_map_pixels / (GRID_MAX_POINTS_X);
+        pixels_per_y_mesh_pnt = y_map_pixels / (GRID_MAX_POINTS_Y);
+
+        if (pixels_per_x_mesh_pnt >= HD44780_CHAR_WIDTH) {                  // There are only 2 custom characters available, so the X
+          pixels_per_x_mesh_pnt = HD44780_CHAR_WIDTH;                       // Size of the mesh point needs to fit within them independent
+          suppress_x_offset = 1;                                            // Of where the starting pixel is located.
+        }
+
+        if (pixels_per_y_mesh_pnt >= HD44780_CHAR_HEIGHT) {                 // There are only 2 custom characters available, so the Y
+          pixels_per_y_mesh_pnt = HD44780_CHAR_HEIGHT;                      // Size of the mesh point needs to fit within them independent
+          suppress_y_offset = 1;                                            // Of where the starting pixel is located.
+        }
+
+        x_map_pixels = pixels_per_x_mesh_pnt * (GRID_MAX_POINTS_X);         // Now we have the right number of pixels to make both
+        y_map_pixels = pixels_per_y_mesh_pnt * (GRID_MAX_POINTS_Y);         // Directions fit nicely
+
+        right_edge   = pixels_per_x_mesh_pnt * (GRID_MAX_POINTS_X) + 1;     // Find location of right edge within the character cell
+        bottom_line  = pixels_per_y_mesh_pnt * (GRID_MAX_POINTS_Y) + 1;     // Find location of bottome line within the character cell
+
+        n_rows = bottom_line / (HD44780_CHAR_HEIGHT) + 1;
+        n_cols = right_edge / (HD44780_CHAR_WIDTH) + 1;
+
+        for (i = 0; i < n_cols; i++) {
+          lcd_put_wchar(i, 0, CHAR_LINE_TOP);                               // Box Top line
+          lcd_put_wchar(i, n_rows - 1, CHAR_LINE_BOT);                      // Box Bottom line
+        }
+
+        for (j = 0; j < n_rows; j++) {
+          lcd_put_wchar(0, j, CHAR_EDGE_L);                                 // Box Left edge
+          lcd_put_wchar(n_cols - 1, j, CHAR_EDGE_R);                        // Box Right edge
+        }
+
+        /**
+         * If the entire 4th row is not in use, do not put vertical bars all the way down to the bottom of the display
+         */
+
+        k = pixels_per_y_mesh_pnt * (GRID_MAX_POINTS_Y) + 2;
+        l = (HD44780_CHAR_HEIGHT) * n_rows;
+        if (l > k && l - k >= (HD44780_CHAR_HEIGHT) / 2) {
+          lcd_put_wchar(0, n_rows - 1, ' ');                                // Box Left edge
+          lcd_put_wchar(n_cols - 1, n_rows - 1, ' ');                       // Box Right edge
+        }
+
+        clear_custom_char(&new_char);
+        new_char.custom_char_bits[0] = 0b11111U;                            // Char #0 is used for the box top line
+        lcd.createChar(CHAR_LINE_TOP, (uint8_t*)&new_char);
+
+        clear_custom_char(&new_char);
+        k = (GRID_MAX_POINTS_Y) * pixels_per_y_mesh_pnt + 1;                // Row of pixels for the bottom box line
+        l = k % (HD44780_CHAR_HEIGHT);                                      // Row within relevant character cell
+        new_char.custom_char_bits[l] = 0b11111U;                            // Char #1 is used for the box bottom line
+        lcd.createChar(CHAR_LINE_BOT, (uint8_t*)&new_char);
+
+        clear_custom_char(&new_char);
+        for (j = 0; j < HD44780_CHAR_HEIGHT; j++)
+          new_char.custom_char_bits[j] = 0b10000U;                          // Char #2 is used for the box left edge
+        lcd.createChar(CHAR_EDGE_L, (uint8_t*)&new_char);
+
+        clear_custom_char(&new_char);
+        m = (GRID_MAX_POINTS_X) * pixels_per_x_mesh_pnt + 1;                // Column of pixels for the right box line
+        n = m % (HD44780_CHAR_WIDTH);                                       // Column within relevant character cell
+        i = HD44780_CHAR_WIDTH - 1 - n;                                     // Column within relevant character cell (0 on the right)
+        for (j = 0; j < HD44780_CHAR_HEIGHT; j++)
+          new_char.custom_char_bits[j] = (uint8_t)_BV(i);                   // Char #3 is used for the box right edge
+        lcd.createChar(CHAR_EDGE_R, (uint8_t*)&new_char);
+
+        i = x_plot * pixels_per_x_mesh_pnt - suppress_x_offset;
+        j = y_plot_inv * pixels_per_y_mesh_pnt - suppress_y_offset;
+        upper_left = pixel_location(i, j);
+
+        k = (x_plot + 1) * pixels_per_x_mesh_pnt - 1 - suppress_x_offset;
+        l = (y_plot_inv + 1) * pixels_per_y_mesh_pnt - 1 - suppress_y_offset;
+        lower_right = pixel_location(k, l);
+
+        bottom_right_corner = pixel_location(x_map_pixels, y_map_pixels);
+
+        /**
+         * First, handle the simple case where everything is within a single character cell.
+         * If part of the Mesh Plot is outside of this character cell, we will follow up
+         * and deal with that next.
+         */
+
+        clear_custom_char(&new_char);
+        const lcd_uint_t ypix = _MIN(upper_left.y_pixel_offset + pixels_per_y_mesh_pnt, HD44780_CHAR_HEIGHT);
+        for (j = upper_left.y_pixel_offset; j < ypix; j++) {
+          i = upper_left.x_pixel_mask;
+          for (k = 0; k < pixels_per_x_mesh_pnt; k++) {
+            new_char.custom_char_bits[j] |= i;
+            i >>= 1;
+          }
+        }
+
+        prep_and_put_map_char(new_char, upper_left, lower_right, bottom_right_corner, TOP_LEFT, CHAR_UL_UL, upper_left.column, upper_left.row);
+
+        /**
+         * Next, check for two side by side character cells being used to display the Mesh Point
+         * If found...  do the right hand character cell next.
+         */
+        if (upper_left.column == lower_right.column - 1) {
+          l = upper_left.x_pixel_offset;
+          clear_custom_char(&new_char);
+          for (j = upper_left.y_pixel_offset; j < ypix; j++) {
+            i = _BV(HD44780_CHAR_WIDTH - 1);                                // Fill in the left side of the right character cell
+            for (k = 0; k < pixels_per_x_mesh_pnt - 1 - l; k++) {
+              new_char.custom_char_bits[j] |= i;
+              i >>= 1;
+            }
+          }
+          prep_and_put_map_char(new_char, upper_left, lower_right, bottom_right_corner, TOP_RIGHT, CHAR_LR_UL, lower_right.column, upper_left.row);
+        }
+
+        /**
+         * Next, check for two character cells stacked on top of each other being used to display the Mesh Point
+         */
+        if (upper_left.row == lower_right.row - 1) {
+          l = HD44780_CHAR_HEIGHT - upper_left.y_pixel_offset;              // Number of pixel rows in top character cell
+          k = pixels_per_y_mesh_pnt - l;                                    // Number of pixel rows in bottom character cell
+          clear_custom_char(&new_char);
+          for (j = 0; j < k; j++) {
+            i = upper_left.x_pixel_mask;
+            for (m = 0; m < pixels_per_x_mesh_pnt; m++) {                   // Fill in the top side of the bottom character cell
+              new_char.custom_char_bits[j] |= i;
+              if (!(i >>= 1)) break;
+            }
+          }
+          prep_and_put_map_char(new_char, upper_left, lower_right, bottom_right_corner, LOWER_LEFT, CHAR_UL_LR, upper_left.column, lower_right.row);
+        }
+
+        /**
+         * Next, check for four character cells being used to display the Mesh Point.  If that is
+         * what is here, we work to fill in the character cell that is down one and to the right one
+         * from the upper_left character cell.
+         */
+
+        if (upper_left.column == lower_right.column - 1 && upper_left.row == lower_right.row - 1) {
+          l = HD44780_CHAR_HEIGHT - upper_left.y_pixel_offset;              // Number of pixel rows in top character cell
+          k = pixels_per_y_mesh_pnt - l;                                    // Number of pixel rows in bottom character cell
+          clear_custom_char(&new_char);
+          for (j = 0; j < k; j++) {
+            l = upper_left.x_pixel_offset;
+            i = _BV(HD44780_CHAR_WIDTH - 1);                                // Fill in the left side of the right character cell
+            for (m = 0; m < pixels_per_x_mesh_pnt - 1 - l; m++) {           // Fill in the top side of the bottom character cell
+              new_char.custom_char_bits[j] |= i;
+              i >>= 1;
+            }
+          }
+          prep_and_put_map_char(new_char, upper_left, lower_right, bottom_right_corner, LOWER_RIGHT, CHAR_LR_LR, lower_right.column, lower_right.row);
+        }
+
+      #endif
+
+      /**
+       * Print plot position
+       */
+      lcd_put_wchar(_LCD_W_POS, 0, '(');
+      lcd_put_u8str(ui8tostr3rj(x_plot));
+      lcd_put_wchar(',');
+      lcd_put_u8str(ui8tostr3rj(y_plot));
+      lcd_put_wchar(')');
+
+      #if LCD_HEIGHT <= 3   // 16x2 or 20x2 display
+
+        /**
+         * Print Z values
+         */
+        _ZLABEL(_LCD_W_POS, 1);
+        if (!isnan(ubl.z_values[x_plot][y_plot]))
+          lcd_put_u8str(ftostr43sign(ubl.z_values[x_plot][y_plot]));
+        else
+          lcd_put_u8str_P(PSTR(" -----"));
+
+      #else                 // 16x4 or 20x4 display
+
+        /**
+         * Show all values at right of screen
+         */
+        _XLABEL(_LCD_W_POS, 1);
+        lcd_put_u8str(ftostr52(LOGICAL_X_POSITION(ubl.mesh_index_to_xpos(x_plot))));
+        _YLABEL(_LCD_W_POS, 2);
+        lcd_put_u8str(ftostr52(LOGICAL_Y_POSITION(ubl.mesh_index_to_ypos(y_plot))));
+
+        /**
+         * Show the location value
+         */
+        _ZLABEL(_LCD_W_POS, 3);
+        if (!isnan(ubl.z_values[x_plot][y_plot]))
+          lcd_put_u8str(ftostr43sign(ubl.z_values[x_plot][y_plot]));
+        else
+          lcd_put_u8str_P(PSTR(" -----"));
+
+      #endif // LCD_HEIGHT > 3
+    }
+
+    void add_edges_to_custom_char(custom_char &custom, const coordinate &ul, const coordinate &lr, const coordinate &brc, const uint8_t cell_location) {
+      uint8_t i, k;
+      int16_t n_rows = lr.row    - ul.row    + 1,
+              n_cols = lr.column - ul.column + 1;
+
+      /**
+       * Check if Top line of box needs to be filled in
+       */
+
+      if (ul.row == 0 && (cell_location & (TOP_LEFT|TOP_RIGHT))) {   // Only fill in the top line for the top character cells
+
+        if (n_cols == 1) {
+          if (ul.column != brc.column)
+            custom.custom_char_bits[0] = 0xFF;                              // Single column in middle
+          else
+            for (i = brc.x_pixel_offset; i < HD44780_CHAR_WIDTH; i++)       // Single column on right side
+              SBI(custom.custom_char_bits[0], i);
+        }
+        else if ((cell_location & TOP_LEFT) || lr.column != brc.column)     // Multiple column in the middle or with right cell in middle
+          custom.custom_char_bits[0] = 0xFF;
+        else
+          for (i = brc.x_pixel_offset; i < HD44780_CHAR_WIDTH; i++)
+            SBI(custom.custom_char_bits[0], i);
+      }
+
+      /**
+       * Check if left line of box needs to be filled in
+       */
+      if (cell_location & (TOP_LEFT|LOWER_LEFT)) {
+        if (ul.column == 0) {                                               // Left column of characters on LCD Display
+          k = ul.row == brc.row ? brc.y_pixel_offset : HD44780_CHAR_HEIGHT; // If it isn't the last row... do the full character cell
+          for (i = 0; i < k; i++)
+            SBI(custom.custom_char_bits[i], HD44780_CHAR_WIDTH - 1);
+        }
+      }
+
+      /**
+       * Check if bottom line of box needs to be filled in
+       */
+
+      // Single row of mesh plot cells
+      if (n_rows == 1 /* && (cell_location & (TOP_LEFT|TOP_RIGHT)) */ && ul.row == brc.row) {
+        if (n_cols == 1)                                                    // Single row, single column case
+          k = ul.column == brc.column ? brc.x_pixel_mask : 0x01;
+        else if (cell_location & TOP_RIGHT)                                 // Single row, multiple column case
+          k = lr.column == brc.column ? brc.x_pixel_mask : 0x01;
+        else                                                                // Single row, left of multiple columns
+          k = 0x01;
+        while (k < _BV(HD44780_CHAR_WIDTH)) {
+          custom.custom_char_bits[brc.y_pixel_offset] |= k;
+          k <<= 1;
+        }
+      }
+
+      // Double row of characters on LCD Display
+      // And this is a bottom custom character
+      if (n_rows == 2 && (cell_location & (LOWER_LEFT|LOWER_RIGHT)) && lr.row == brc.row) {
+        if (n_cols == 1)                                                    // Double row, single column case
+          k = ul.column == brc.column ? brc.x_pixel_mask : 0x01;
+        else if (cell_location & LOWER_RIGHT)                               // Double row, multiple column case
+          k = lr.column == brc.column ? brc.x_pixel_mask : 0x01;
+        else                                                                // Double row, left of multiple columns
+          k = 0x01;
+        while (k < _BV(HD44780_CHAR_WIDTH)) {
+          custom.custom_char_bits[brc.y_pixel_offset] |= k;
+          k <<= 1;
+        }
+      }
+
+      /**
+       * Check if right line of box needs to be filled in
+       */
+
+      // Nothing to do if the lower right part of the mesh pnt isn't in the same column as the box line
+      if (lr.column == brc.column) {
+        // This mesh point is in the same character cell as the right box line
+        if (ul.column == brc.column || (cell_location & (TOP_RIGHT|LOWER_RIGHT))) {
+          // If not the last row... do the full character cell
+          k = ul.row == brc.row ? brc.y_pixel_offset : HD44780_CHAR_HEIGHT;
+          for (i = 0; i < k; i++) custom.custom_char_bits[i] |= brc.x_pixel_mask;
+        }
+      }
+    }
+
+  #endif // AUTO_BED_LEVELING_UBL
+
+#endif // HAS_LCD_MENU
+
+#endif // HAS_MARLINUI_HD44780
