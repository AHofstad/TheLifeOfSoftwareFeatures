commit c0920bbf6a2490b7ea66d2a9e828c0f527a6c77b
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Mon Oct 12 18:38:07 2020 -0300

    TFT Refactoring (#19192)
    
    * split tft folder in two: tft for color ui; tft_io for shared tft code
    
    * after the files got moved, now the code was moved to the right place
    
    * classic ui using TFT IO init lcd codes
    
    * feature to compile tft_io when enabled
    
    * compiling fix
    
    * lvgl spi tft working with tft io init codes
    
    * there is no need for separeted fsmc and spi class in lvgl anymore, as tft io handle everything
    
    * remove debug
    
    * base for TFT rotation and mirroring API, and ILI9488 support
    
    * ST7796S rotate and mirror support
    
    * ST7789V rotate and mirror support
    
    * ST7735 rotate and mirror support
    
    * ILI9341 rotate and mirror support
    
    * ILI9328 rotate and mirror support
    
    * R61505 rotate and mirror support
    
    * MKS TFT definitions
    
    * more configs for mks tfts
    
    * update config
    
    * naming typo
    
    * to configure the user interface
    
    * ANYCUBIC_TFT35
    
    * tft configs
    
    * support for SSD1963
    
    * tft display types
    
    * updated conditionals lcd; first board fully working with the new code - all 3 ui!
    
    * compatiblity
    
    * changed name
    
    * move classic ui file name
    
    * rename TURN -> ROTATE
    
    * GRAPHICAL_TFT_ROTATE_180 deprecated
    
    * first fsmc board fully working - chitu v5
    
    * mks robin nano v1.2 + tft 35 ok!
    
    * right pin name
    
    * anycubic tft tested in a TRIGORILLA_PRO
    
    * chitu v6
    
    * nano 32 tft orientation
    
    * mks tft43
    
    * mks tft43 rotation
    
    * fixed LONGER LK tft setup
    
    * GRAPHICAL_TFT_UPSCALE defined by the display type
    
    * better offsets defaults
    
    * Update Configuration.h
    
    * Update tft_fsmc.cpp
    
    * Update Conditionals_LCD.h
    
    * Tweak comments
    
    * update nano tests
    
    * Revert "update nano tests"
    
    This reverts commit a071ebbfad30e28855a4a5695ec8a726542a1a65.
    
    * default tft
    
    * outdated comments
    
    * to not break non-vscode builds
    
    * upscale tft 35
    
    * support tft 180 rotation for color ui
    
    * Each TFT Driver is responsible for its default color mode.
    
    * use auto detect in mks displays, because some of them could be shipped with diferent drivers
    
    * extra s
    
    * unused code
    
    * wrong -1
    
    * missing mirror options
    
    * Smaller regex pattern
    
    * Comment updates
    
    * Clean up old defines
    
    * Apply pins formatting
    
    * GRAPHICAL_TFT_ROTATE_180 => TFT_ROTATE_180
    
    * MKS_ROBIN_TFT_V1_1R
    
    * merge fix
    
    * correct resolution
    
    * auto is default, dont need be there, and it will allow the user to configure it even for named displays
    
    * to not use rotation with MKS_ROBIN_TFT_V1_1R
    
    * i like () in macros
    
    * avoid sleepy commits
    
    * default for st7789 is rgb
    
    * nano follow up
    
    * to allow ili9328 rotation
    
    * default is rgb
    
    * boards merge follow up
    
    * to match bootloader orientation
    
    * HAS_TOUCH_XPT2046 is not hal specific anymore
    
    * lets not forget LPC
    
    * 180 rotation for ili9328 and R61505
    
    * Clean up whitespace
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/tft_fsmc.cpp b/Marlin/src/lcd/extui/lib/mks_ui/tft_fsmc.cpp
deleted file mode 100644
index 62967b9d80..0000000000
--- a/Marlin/src/lcd/extui/lib/mks_ui/tft_fsmc.cpp
+++ /dev/null
@@ -1,60 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-#include "../../../../inc/MarlinConfig.h"
-
-#if ENABLED(TFT_LVGL_UI_FSMC)
-
-#include HAL_PATH(../../HAL, tft/tft_fsmc.h)
-TFT_IO tftio;
-
-void LCD_IO_Init(uint8_t cs, uint8_t rs);
-void LCD_IO_WriteData(uint16_t RegValue);
-void LCD_IO_WriteReg(uint16_t Reg);
-#ifdef LCD_USE_DMA_FSMC
-  void LCD_IO_WriteMultiple(uint16_t data, uint32_t count);
-  void LCD_IO_WriteSequence(uint16_t *data, uint16_t length);
-#endif
-
-void LCD_IO_Init(uint8_t cs, uint8_t rs) {
-  tftio.Init();
-}
-
-void LCD_IO_WriteData(uint16_t RegValue) {
-  tftio.WriteData(RegValue);
-}
-
-void LCD_IO_WriteReg(uint16_t Reg) {
-  tftio.WriteReg(Reg);
-}
-
-#ifdef LCD_USE_DMA_FSMC
-  void LCD_IO_WriteMultiple(uint16_t color, uint32_t count) {
-    tftio.WriteMultiple(color, count);
-  }
-
-  void LCD_IO_WriteSequence(uint16_t *data, uint16_t length) {
-    tftio.WriteSequence(data, length);
-  }
-#endif // LCD_USE_DMA_FSMC
-
-#endif // HAS_TFT_LVGL_UI

commit ff5c8d35705df99f385a6b27163380a249c2e646
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Thu Aug 13 20:31:59 2020 -0300

    Optimize LVGL with HAL TFT IO (SPI and FSMC) (#18974)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/tft_fsmc.cpp b/Marlin/src/lcd/extui/lib/mks_ui/tft_fsmc.cpp
index a257d03489..62967b9d80 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/tft_fsmc.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/tft_fsmc.cpp
@@ -15,256 +15,46 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 #include "../../../../inc/MarlinConfig.h"
 
-#if HAS_TFT_LVGL_UI
-
-#if defined(ARDUINO_ARCH_STM32F1) && PIN_EXISTS(FSMC_CS) // FSMC on 100/144 pins SoCs
-
-  #include <libmaple/fsmc.h>
-  #include <libmaple/gpio.h>
-  #include <libmaple/dma.h>
-  #include <boards.h>
-
-  /* Timing configuration */
-  #define FSMC_ADDRESS_SETUP_TIME   15// AddressSetupTime
-  #define FSMC_DATA_SETUP_TIME      15// DataSetupTime
-
-  void LCD_IO_Init(uint8_t cs, uint8_t rs);
-  void LCD_IO_WriteData(uint16_t RegValue);
-  void LCD_IO_WriteReg(uint16_t Reg);
-  uint16_t LCD_IO_ReadData(uint16_t RegValue);
-  uint32_t LCD_IO_ReadData(uint16_t RegValue, uint8_t ReadSize);
-  uint16_t ILI9488_ReadRAM();
-  #ifdef LCD_USE_DMA_FSMC
-    void LCD_IO_WriteMultiple(uint16_t data, uint32_t count);
-    void LCD_IO_WriteSequence(uint16_t *data, uint16_t length);
-  #endif
-
-  /**
-   * FSMC LCD IO
-   */
-  #define __ASM __asm
-  #define __STATIC_INLINE static inline
-
-  __attribute__((always_inline)) __STATIC_INLINE void __DSB() {__ASM volatile ("dsb 0xF" ::: "memory");}
-
-  #define FSMC_CS_NE1   PD7
-
-  #if ENABLED(STM32_XL_DENSITY)
-    #define FSMC_CS_NE2 PG9
-    #define FSMC_CS_NE3 PG10
-    #define FSMC_CS_NE4 PG12
-
-    #define FSMC_RS_A0  PF0
-    #define FSMC_RS_A1  PF1
-    #define FSMC_RS_A2  PF2
-    #define FSMC_RS_A3  PF3
-    #define FSMC_RS_A4  PF4
-    #define FSMC_RS_A5  PF5
-    #define FSMC_RS_A6  PF12
-    #define FSMC_RS_A7  PF13
-    #define FSMC_RS_A8  PF14
-    #define FSMC_RS_A9  PF15
-    #define FSMC_RS_A10 PG0
-    #define FSMC_RS_A11 PG1
-    #define FSMC_RS_A12 PG2
-    #define FSMC_RS_A13 PG3
-    #define FSMC_RS_A14 PG4
-    #define FSMC_RS_A15 PG5
-  #endif
-
-  #define FSMC_RS_A16   PD11
-  #define FSMC_RS_A17   PD12
-  #define FSMC_RS_A18   PD13
-  #define FSMC_RS_A19   PE3
-  #define FSMC_RS_A20   PE4
-  #define FSMC_RS_A21   PE5
-  #define FSMC_RS_A22   PE6
-  #define FSMC_RS_A23   PE2
-
-  #if ENABLED(STM32_XL_DENSITY)
-    #define FSMC_RS_A24 PG13
-    #define FSMC_RS_A25 PG14
-  #endif
-
-  static uint8_t fsmcInit = 0;
-
-  typedef struct {
-    __IO uint16_t REG;
-    __IO uint16_t RAM;
-  } LCD_CONTROLLER_TypeDef;
-
-  LCD_CONTROLLER_TypeDef *LCD;
-
-  void LCD_IO_Init(uint8_t cs, uint8_t rs) {
-    uint32_t controllerAddress;
-    struct fsmc_nor_psram_reg_map* fsmcPsramRegion;
-
-    if (fsmcInit) return;
-    fsmcInit = 1;
-
-    switch (cs) {
-      case FSMC_CS_NE1: controllerAddress = (uint32_t)FSMC_NOR_PSRAM_REGION1; fsmcPsramRegion = FSMC_NOR_PSRAM1_BASE; break;
-      #if ENABLED(STM32_XL_DENSITY)
-        case FSMC_CS_NE2: controllerAddress = (uint32_t)FSMC_NOR_PSRAM_REGION2; fsmcPsramRegion = FSMC_NOR_PSRAM2_BASE; break;
-        case FSMC_CS_NE3: controllerAddress = (uint32_t)FSMC_NOR_PSRAM_REGION3; fsmcPsramRegion = FSMC_NOR_PSRAM3_BASE; break;
-        case FSMC_CS_NE4: controllerAddress = (uint32_t)FSMC_NOR_PSRAM_REGION4; fsmcPsramRegion = FSMC_NOR_PSRAM4_BASE; break;
-      #endif
-      default: return;
-    }
-
-    #define _ORADDR(N) controllerAddress |= (_BV32(N) - 2)
-
-    switch (rs) {
-      #if ENABLED(STM32_XL_DENSITY)
-        case FSMC_RS_A0:  _ORADDR( 1); break;
-        case FSMC_RS_A1:  _ORADDR( 2); break;
-        case FSMC_RS_A2:  _ORADDR( 3); break;
-        case FSMC_RS_A3:  _ORADDR( 4); break;
-        case FSMC_RS_A4:  _ORADDR( 5); break;
-        case FSMC_RS_A5:  _ORADDR( 6); break;
-        case FSMC_RS_A6:  _ORADDR( 7); break;
-        case FSMC_RS_A7:  _ORADDR( 8); break;
-        case FSMC_RS_A8:  _ORADDR( 9); break;
-        case FSMC_RS_A9:  _ORADDR(10); break;
-        case FSMC_RS_A10: _ORADDR(11); break;
-        case FSMC_RS_A11: _ORADDR(12); break;
-        case FSMC_RS_A12: _ORADDR(13); break;
-        case FSMC_RS_A13: _ORADDR(14); break;
-        case FSMC_RS_A14: _ORADDR(15); break;
-        case FSMC_RS_A15: _ORADDR(16); break;
-      #endif
-      case FSMC_RS_A16: _ORADDR(17); break;
-      case FSMC_RS_A17: _ORADDR(18); break;
-      case FSMC_RS_A18: _ORADDR(19); break;
-      case FSMC_RS_A19: _ORADDR(20); break;
-      case FSMC_RS_A20: _ORADDR(21); break;
-      case FSMC_RS_A21: _ORADDR(22); break;
-      case FSMC_RS_A22: _ORADDR(23); break;
-      case FSMC_RS_A23: _ORADDR(24); break;
-      #if ENABLED(STM32_XL_DENSITY)
-        case FSMC_RS_A24: _ORADDR(25); break;
-        case FSMC_RS_A25: _ORADDR(26); break;
-      #endif
-      default: return;
-    }
-
-    rcc_clk_enable(RCC_FSMC);
-
-    gpio_set_mode(GPIOD, 14, GPIO_AF_OUTPUT_PP); // FSMC_D00
-    gpio_set_mode(GPIOD, 15, GPIO_AF_OUTPUT_PP); // FSMC_D01
-    gpio_set_mode(GPIOD,  0, GPIO_AF_OUTPUT_PP);// FSMC_D02
-    gpio_set_mode(GPIOD,  1, GPIO_AF_OUTPUT_PP);// FSMC_D03
-    gpio_set_mode(GPIOE,  7, GPIO_AF_OUTPUT_PP);// FSMC_D04
-    gpio_set_mode(GPIOE,  8, GPIO_AF_OUTPUT_PP);// FSMC_D05
-    gpio_set_mode(GPIOE,  9, GPIO_AF_OUTPUT_PP);// FSMC_D06
-    gpio_set_mode(GPIOE, 10, GPIO_AF_OUTPUT_PP); // FSMC_D07
-    gpio_set_mode(GPIOE, 11, GPIO_AF_OUTPUT_PP); // FSMC_D08
-    gpio_set_mode(GPIOE, 12, GPIO_AF_OUTPUT_PP); // FSMC_D09
-    gpio_set_mode(GPIOE, 13, GPIO_AF_OUTPUT_PP); // FSMC_D10
-    gpio_set_mode(GPIOE, 14, GPIO_AF_OUTPUT_PP); // FSMC_D11
-    gpio_set_mode(GPIOE, 15, GPIO_AF_OUTPUT_PP); // FSMC_D12
-    gpio_set_mode(GPIOD,  8, GPIO_AF_OUTPUT_PP);// FSMC_D13
-    gpio_set_mode(GPIOD,  9, GPIO_AF_OUTPUT_PP);// FSMC_D14
-    gpio_set_mode(GPIOD, 10, GPIO_AF_OUTPUT_PP); // FSMC_D15
-
-    gpio_set_mode(GPIOD,  4, GPIO_AF_OUTPUT_PP);// FSMC_NOE
-    gpio_set_mode(GPIOD,  5, GPIO_AF_OUTPUT_PP);// FSMC_NWE
-
-    gpio_set_mode(PIN_MAP[cs].gpio_device, PIN_MAP[cs].gpio_bit, GPIO_AF_OUTPUT_PP); //FSMC_CS_NEx
-    gpio_set_mode(PIN_MAP[rs].gpio_device, PIN_MAP[rs].gpio_bit, GPIO_AF_OUTPUT_PP); //FSMC_RS_Ax
-
-    fsmcPsramRegion->BCR = FSMC_BCR_WREN | FSMC_BCR_MTYP_SRAM | FSMC_BCR_MWID_16BITS | FSMC_BCR_MBKEN;
-    fsmcPsramRegion->BTR = (FSMC_DATA_SETUP_TIME << 8) | FSMC_ADDRESS_SETUP_TIME;
-
-    afio_remap(AFIO_REMAP_FSMC_NADV);
-
-    LCD = (LCD_CONTROLLER_TypeDef*)controllerAddress;
-  }
-
-  void LCD_IO_WriteData(uint16_t RegValue) {
-    LCD->RAM = RegValue;
-    __DSB();
-  }
-
-  void LCD_IO_WriteReg(uint16_t Reg) {
-    LCD->REG = Reg;
-    __DSB();
-  }
-
-  uint16_t LCD_IO_ReadData(uint16_t RegValue) {
-    LCD->REG = RegValue;
-    __DSB();
-
-    return LCD->RAM;
+#if ENABLED(TFT_LVGL_UI_FSMC)
+
+#include HAL_PATH(../../HAL, tft/tft_fsmc.h)
+TFT_IO tftio;
+
+void LCD_IO_Init(uint8_t cs, uint8_t rs);
+void LCD_IO_WriteData(uint16_t RegValue);
+void LCD_IO_WriteReg(uint16_t Reg);
+#ifdef LCD_USE_DMA_FSMC
+  void LCD_IO_WriteMultiple(uint16_t data, uint32_t count);
+  void LCD_IO_WriteSequence(uint16_t *data, uint16_t length);
+#endif
+
+void LCD_IO_Init(uint8_t cs, uint8_t rs) {
+  tftio.Init();
+}
+
+void LCD_IO_WriteData(uint16_t RegValue) {
+  tftio.WriteData(RegValue);
+}
+
+void LCD_IO_WriteReg(uint16_t Reg) {
+  tftio.WriteReg(Reg);
+}
+
+#ifdef LCD_USE_DMA_FSMC
+  void LCD_IO_WriteMultiple(uint16_t color, uint32_t count) {
+    tftio.WriteMultiple(color, count);
   }
 
-  uint16_t ILI9488_ReadRAM() {
-    uint16_t data;
-    data = LCD->RAM;
-    return data;
+  void LCD_IO_WriteSequence(uint16_t *data, uint16_t length) {
+    tftio.WriteSequence(data, length);
   }
+#endif // LCD_USE_DMA_FSMC
 
-  uint32_t LCD_IO_ReadData(uint16_t RegValue, uint8_t ReadSize) {
-    volatile uint32_t data;
-    LCD->REG = RegValue;
-    __DSB();
-
-    data = LCD->RAM; // dummy read
-    data = LCD->RAM & 0x00FF;
-
-    while (--ReadSize) {
-      data <<= 8;
-      data |= (LCD->RAM & 0x00FF);
-    }
-    return uint32_t(data);
-  }
-
-  #ifdef LCD_USE_DMA_FSMC
-
-    void LCD_IO_WriteMultiple(uint16_t color, uint32_t count) {
-      while (count > 0) {
-        dma_setup_transfer(FSMC_DMA_DEV, FSMC_DMA_CHANNEL, &color, DMA_SIZE_16BITS, &LCD->RAM, DMA_SIZE_16BITS, DMA_MEM_2_MEM);
-        dma_set_num_transfers(FSMC_DMA_DEV, FSMC_DMA_CHANNEL, count > 65535 ? 65535 : count);
-        dma_clear_isr_bits(FSMC_DMA_DEV, FSMC_DMA_CHANNEL);
-        dma_enable(FSMC_DMA_DEV, FSMC_DMA_CHANNEL);
-
-        while ((dma_get_isr_bits(FSMC_DMA_DEV, FSMC_DMA_CHANNEL) & 0x0A) == 0) {}
-        dma_disable(FSMC_DMA_DEV, FSMC_DMA_CHANNEL);
-
-        count = count > 65535 ? count - 65535 : 0;
-      }
-    }
-
-    void LCD_IO_WriteSequence(uint16_t *data, uint16_t length) {
-      dma_setup_transfer(FSMC_DMA_DEV, FSMC_DMA_CHANNEL, data, DMA_SIZE_16BITS, &LCD->RAM, DMA_SIZE_16BITS, DMA_MEM_2_MEM | DMA_PINC_MODE);
-      dma_set_num_transfers(FSMC_DMA_DEV, FSMC_DMA_CHANNEL, length);
-      dma_clear_isr_bits(FSMC_DMA_DEV, FSMC_DMA_CHANNEL);
-      dma_enable(FSMC_DMA_DEV, FSMC_DMA_CHANNEL);
-
-      while ((dma_get_isr_bits(FSMC_DMA_DEV, FSMC_DMA_CHANNEL) & 0x0A) == 0) {}
-      dma_disable(FSMC_DMA_DEV, FSMC_DMA_CHANNEL);
-    }
-
-    void LCD_IO_WriteSequence_Async(uint16_t *data, uint16_t length) {
-      dma_setup_transfer(FSMC_DMA_DEV, FSMC_DMA_CHANNEL, data, DMA_SIZE_16BITS, &LCD->RAM, DMA_SIZE_16BITS, DMA_MEM_2_MEM | DMA_PINC_MODE);
-      dma_set_num_transfers(FSMC_DMA_DEV, FSMC_DMA_CHANNEL, length);
-      dma_clear_isr_bits(FSMC_DMA_DEV, FSMC_DMA_CHANNEL);
-      dma_enable(FSMC_DMA_DEV, FSMC_DMA_CHANNEL);
-    }
-
-    void LCD_IO_WaitSequence_Async() {
-      while ((dma_get_isr_bits(FSMC_DMA_DEV, FSMC_DMA_CHANNEL) & 0x0A) == 0) {}
-      dma_disable(FSMC_DMA_DEV, FSMC_DMA_CHANNEL);
-    }
-
-  #endif // LCD_USE_DMA_FSMC
-
-#endif // ARDUINO_ARCH_STM32F1 && FSMC_CS_PIN
 #endif // HAS_TFT_LVGL_UI

commit cec035688df8e3c072476404f7b4cdb6fafce087
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Fri Aug 7 03:55:15 2020 -0300

    Fix / optimize FSMC init (#18941)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/tft_fsmc.cpp b/Marlin/src/lcd/extui/lib/mks_ui/tft_fsmc.cpp
index a039cbe0cb..a257d03489 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/tft_fsmc.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/tft_fsmc.cpp
@@ -97,30 +97,31 @@
 
   typedef struct {
     __IO uint16_t REG;
     __IO uint16_t RAM;
   } LCD_CONTROLLER_TypeDef;
 
   LCD_CONTROLLER_TypeDef *LCD;
 
   void LCD_IO_Init(uint8_t cs, uint8_t rs) {
     uint32_t controllerAddress;
+    struct fsmc_nor_psram_reg_map* fsmcPsramRegion;
 
     if (fsmcInit) return;
     fsmcInit = 1;
 
     switch (cs) {
-      case FSMC_CS_NE1: controllerAddress = (uint32_t)FSMC_NOR_PSRAM_REGION1; break;
+      case FSMC_CS_NE1: controllerAddress = (uint32_t)FSMC_NOR_PSRAM_REGION1; fsmcPsramRegion = FSMC_NOR_PSRAM1_BASE; break;
       #if ENABLED(STM32_XL_DENSITY)
-        case FSMC_CS_NE2: controllerAddress = (uint32_t)FSMC_NOR_PSRAM_REGION2; break;
-        case FSMC_CS_NE3: controllerAddress = (uint32_t)FSMC_NOR_PSRAM_REGION3; break;
-        case FSMC_CS_NE4: controllerAddress = (uint32_t)FSMC_NOR_PSRAM_REGION4; break;
+        case FSMC_CS_NE2: controllerAddress = (uint32_t)FSMC_NOR_PSRAM_REGION2; fsmcPsramRegion = FSMC_NOR_PSRAM2_BASE; break;
+        case FSMC_CS_NE3: controllerAddress = (uint32_t)FSMC_NOR_PSRAM_REGION3; fsmcPsramRegion = FSMC_NOR_PSRAM3_BASE; break;
+        case FSMC_CS_NE4: controllerAddress = (uint32_t)FSMC_NOR_PSRAM_REGION4; fsmcPsramRegion = FSMC_NOR_PSRAM4_BASE; break;
       #endif
       default: return;
     }
 
     #define _ORADDR(N) controllerAddress |= (_BV32(N) - 2)
 
     switch (rs) {
       #if ENABLED(STM32_XL_DENSITY)
         case FSMC_RS_A0:  _ORADDR( 1); break;
         case FSMC_RS_A1:  _ORADDR( 2); break;
@@ -172,27 +173,22 @@
     gpio_set_mode(GPIOD,  8, GPIO_AF_OUTPUT_PP);// FSMC_D13
     gpio_set_mode(GPIOD,  9, GPIO_AF_OUTPUT_PP);// FSMC_D14
     gpio_set_mode(GPIOD, 10, GPIO_AF_OUTPUT_PP); // FSMC_D15
 
     gpio_set_mode(GPIOD,  4, GPIO_AF_OUTPUT_PP);// FSMC_NOE
     gpio_set_mode(GPIOD,  5, GPIO_AF_OUTPUT_PP);// FSMC_NWE
 
     gpio_set_mode(PIN_MAP[cs].gpio_device, PIN_MAP[cs].gpio_bit, GPIO_AF_OUTPUT_PP); //FSMC_CS_NEx
     gpio_set_mode(PIN_MAP[rs].gpio_device, PIN_MAP[rs].gpio_bit, GPIO_AF_OUTPUT_PP); //FSMC_RS_Ax
 
-    #if ENABLED(STM32_XL_DENSITY)
-      FSMC_NOR_PSRAM4_BASE->BCR = FSMC_BCR_WREN | FSMC_BCR_MTYP_SRAM | FSMC_BCR_MWID_16BITS | FSMC_BCR_MBKEN;
-      FSMC_NOR_PSRAM4_BASE->BTR = (FSMC_DATA_SETUP_TIME << 8) | FSMC_ADDRESS_SETUP_TIME;
-    #else // PSRAM1 for STM32F103V (high density)
-      FSMC_NOR_PSRAM1_BASE->BCR = FSMC_BCR_WREN | FSMC_BCR_MTYP_SRAM | FSMC_BCR_MWID_16BITS | FSMC_BCR_MBKEN;
-      FSMC_NOR_PSRAM1_BASE->BTR = (FSMC_DATA_SETUP_TIME << 8) | FSMC_ADDRESS_SETUP_TIME;
-    #endif
+    fsmcPsramRegion->BCR = FSMC_BCR_WREN | FSMC_BCR_MTYP_SRAM | FSMC_BCR_MWID_16BITS | FSMC_BCR_MBKEN;
+    fsmcPsramRegion->BTR = (FSMC_DATA_SETUP_TIME << 8) | FSMC_ADDRESS_SETUP_TIME;
 
     afio_remap(AFIO_REMAP_FSMC_NADV);
 
     LCD = (LCD_CONTROLLER_TypeDef*)controllerAddress;
   }
 
   void LCD_IO_WriteData(uint16_t RegValue) {
     LCD->RAM = RegValue;
     __DSB();
   }

commit 117df87d193994f6fbcd46c45573095adf921784
Author: Alexander Gavrilenko <jmz52@users.noreply.github.com>
Date:   Thu Jul 30 09:43:19 2020 +0300

    Support for TFT & Touch Screens (#18130)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/tft_fsmc.cpp b/Marlin/src/lcd/extui/lib/mks_ui/tft_fsmc.cpp
index e8ac3f3519..a039cbe0cb 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/tft_fsmc.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/tft_fsmc.cpp
@@ -17,227 +17,227 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 #include "../../../../inc/MarlinConfig.h"
 
 #if HAS_TFT_LVGL_UI
 
-  #if defined(ARDUINO_ARCH_STM32F1) && PIN_EXISTS(FSMC_CS) // FSMC on 100/144 pins SoCs
-
-    #include <libmaple/fsmc.h>
-    #include <libmaple/gpio.h>
-    #include <libmaple/dma.h>
-    #include <boards.h>
-
-/* Timing configuration */
-    #define FSMC_ADDRESS_SETUP_TIME   15// AddressSetupTime
-    #define FSMC_DATA_SETUP_TIME      15// DataSetupTime
-
-    void LCD_IO_Init(uint8_t cs, uint8_t rs);
-    void LCD_IO_WriteData(uint16_t RegValue);
-    void LCD_IO_WriteReg(uint16_t Reg);
-    uint16_t LCD_IO_ReadData(uint16_t RegValue);
-    uint32_t LCD_IO_ReadData(uint16_t RegValue, uint8_t ReadSize);
-    uint16_t ILI9488_ReadRAM();
-    #ifdef LCD_USE_DMA_FSMC
-      void LCD_IO_WriteMultiple(uint16_t data, uint32_t count);
-      void LCD_IO_WriteSequence(uint16_t *data, uint16_t length);
-    #endif
-
-/**
- * FSMC LCD IO
- */
-    #define __ASM __asm
-    #define __STATIC_INLINE static inline
-
-    __attribute__((always_inline)) __STATIC_INLINE void __DSB() {__ASM volatile ("dsb 0xF" ::: "memory");}
-
-    #define FSMC_CS_NE1   PD7
-
-    #if ENABLED(STM32_XL_DENSITY)
-      #define FSMC_CS_NE2 PG9
-      #define FSMC_CS_NE3 PG10
-      #define FSMC_CS_NE4 PG12
-
-      #define FSMC_RS_A0  PF0
-      #define FSMC_RS_A1  PF1
-      #define FSMC_RS_A2  PF2
-      #define FSMC_RS_A3  PF3
-      #define FSMC_RS_A4  PF4
-      #define FSMC_RS_A5  PF5
-      #define FSMC_RS_A6  PF12
-      #define FSMC_RS_A7  PF13
-      #define FSMC_RS_A8  PF14
-      #define FSMC_RS_A9  PF15
-      #define FSMC_RS_A10 PG0
-      #define FSMC_RS_A11 PG1
-      #define FSMC_RS_A12 PG2
-      #define FSMC_RS_A13 PG3
-      #define FSMC_RS_A14 PG4
-      #define FSMC_RS_A15 PG5
-    #endif
-
-    #define FSMC_RS_A16   PD11
-    #define FSMC_RS_A17   PD12
-    #define FSMC_RS_A18   PD13
-    #define FSMC_RS_A19   PE3
-    #define FSMC_RS_A20   PE4
-    #define FSMC_RS_A21   PE5
-    #define FSMC_RS_A22   PE6
-    #define FSMC_RS_A23   PE2
-
-    #if ENABLED(STM32_XL_DENSITY)
-      #define FSMC_RS_A24 PG13
-      #define FSMC_RS_A25 PG14
-    #endif
-
-    static uint8_t fsmcInit = 0;
-
-    typedef struct {
-      __IO uint16_t REG;
-      __IO uint16_t RAM;
-    } LCD_CONTROLLER_TypeDef;
-
-    LCD_CONTROLLER_TypeDef *LCD;
-
-    void LCD_IO_Init(uint8_t cs, uint8_t rs) {
-      uint32_t controllerAddress;
-
-      if (fsmcInit) return;
-      fsmcInit = 1;
-
-      switch (cs) {
-        case FSMC_CS_NE1: controllerAddress = (uint32_t)FSMC_NOR_PSRAM_REGION1; break;
-          #if ENABLED(STM32_XL_DENSITY)
+#if defined(ARDUINO_ARCH_STM32F1) && PIN_EXISTS(FSMC_CS) // FSMC on 100/144 pins SoCs
+
+  #include <libmaple/fsmc.h>
+  #include <libmaple/gpio.h>
+  #include <libmaple/dma.h>
+  #include <boards.h>
+
+  /* Timing configuration */
+  #define FSMC_ADDRESS_SETUP_TIME   15// AddressSetupTime
+  #define FSMC_DATA_SETUP_TIME      15// DataSetupTime
+
+  void LCD_IO_Init(uint8_t cs, uint8_t rs);
+  void LCD_IO_WriteData(uint16_t RegValue);
+  void LCD_IO_WriteReg(uint16_t Reg);
+  uint16_t LCD_IO_ReadData(uint16_t RegValue);
+  uint32_t LCD_IO_ReadData(uint16_t RegValue, uint8_t ReadSize);
+  uint16_t ILI9488_ReadRAM();
+  #ifdef LCD_USE_DMA_FSMC
+    void LCD_IO_WriteMultiple(uint16_t data, uint32_t count);
+    void LCD_IO_WriteSequence(uint16_t *data, uint16_t length);
+  #endif
+
+  /**
+   * FSMC LCD IO
+   */
+  #define __ASM __asm
+  #define __STATIC_INLINE static inline
+
+  __attribute__((always_inline)) __STATIC_INLINE void __DSB() {__ASM volatile ("dsb 0xF" ::: "memory");}
+
+  #define FSMC_CS_NE1   PD7
+
+  #if ENABLED(STM32_XL_DENSITY)
+    #define FSMC_CS_NE2 PG9
+    #define FSMC_CS_NE3 PG10
+    #define FSMC_CS_NE4 PG12
+
+    #define FSMC_RS_A0  PF0
+    #define FSMC_RS_A1  PF1
+    #define FSMC_RS_A2  PF2
+    #define FSMC_RS_A3  PF3
+    #define FSMC_RS_A4  PF4
+    #define FSMC_RS_A5  PF5
+    #define FSMC_RS_A6  PF12
+    #define FSMC_RS_A7  PF13
+    #define FSMC_RS_A8  PF14
+    #define FSMC_RS_A9  PF15
+    #define FSMC_RS_A10 PG0
+    #define FSMC_RS_A11 PG1
+    #define FSMC_RS_A12 PG2
+    #define FSMC_RS_A13 PG3
+    #define FSMC_RS_A14 PG4
+    #define FSMC_RS_A15 PG5
+  #endif
+
+  #define FSMC_RS_A16   PD11
+  #define FSMC_RS_A17   PD12
+  #define FSMC_RS_A18   PD13
+  #define FSMC_RS_A19   PE3
+  #define FSMC_RS_A20   PE4
+  #define FSMC_RS_A21   PE5
+  #define FSMC_RS_A22   PE6
+  #define FSMC_RS_A23   PE2
+
+  #if ENABLED(STM32_XL_DENSITY)
+    #define FSMC_RS_A24 PG13
+    #define FSMC_RS_A25 PG14
+  #endif
+
+  static uint8_t fsmcInit = 0;
+
+  typedef struct {
+    __IO uint16_t REG;
+    __IO uint16_t RAM;
+  } LCD_CONTROLLER_TypeDef;
+
+  LCD_CONTROLLER_TypeDef *LCD;
+
+  void LCD_IO_Init(uint8_t cs, uint8_t rs) {
+    uint32_t controllerAddress;
+
+    if (fsmcInit) return;
+    fsmcInit = 1;
+
+    switch (cs) {
+      case FSMC_CS_NE1: controllerAddress = (uint32_t)FSMC_NOR_PSRAM_REGION1; break;
+      #if ENABLED(STM32_XL_DENSITY)
         case FSMC_CS_NE2: controllerAddress = (uint32_t)FSMC_NOR_PSRAM_REGION2; break;
         case FSMC_CS_NE3: controllerAddress = (uint32_t)FSMC_NOR_PSRAM_REGION3; break;
         case FSMC_CS_NE4: controllerAddress = (uint32_t)FSMC_NOR_PSRAM_REGION4; break;
-          #endif
-        default: return;
-      }
+      #endif
+      default: return;
+    }
 
-      #define _ORADDR(N) controllerAddress |= (_BV32(N) - 2)
+    #define _ORADDR(N) controllerAddress |= (_BV32(N) - 2)
 
-      switch (rs) {
-        #if ENABLED(STM32_XL_DENSITY)
+    switch (rs) {
+      #if ENABLED(STM32_XL_DENSITY)
         case FSMC_RS_A0:  _ORADDR( 1); break;
         case FSMC_RS_A1:  _ORADDR( 2); break;
         case FSMC_RS_A2:  _ORADDR( 3); break;
         case FSMC_RS_A3:  _ORADDR( 4); break;
         case FSMC_RS_A4:  _ORADDR( 5); break;
         case FSMC_RS_A5:  _ORADDR( 6); break;
         case FSMC_RS_A6:  _ORADDR( 7); break;
         case FSMC_RS_A7:  _ORADDR( 8); break;
         case FSMC_RS_A8:  _ORADDR( 9); break;
         case FSMC_RS_A9:  _ORADDR(10); break;
         case FSMC_RS_A10: _ORADDR(11); break;
         case FSMC_RS_A11: _ORADDR(12); break;
         case FSMC_RS_A12: _ORADDR(13); break;
         case FSMC_RS_A13: _ORADDR(14); break;
         case FSMC_RS_A14: _ORADDR(15); break;
         case FSMC_RS_A15: _ORADDR(16); break;
-        #endif
-        case FSMC_RS_A16: _ORADDR(17); break;
-        case FSMC_RS_A17: _ORADDR(18); break;
-        case FSMC_RS_A18: _ORADDR(19); break;
-        case FSMC_RS_A19: _ORADDR(20); break;
-        case FSMC_RS_A20: _ORADDR(21); break;
-        case FSMC_RS_A21: _ORADDR(22); break;
-        case FSMC_RS_A22: _ORADDR(23); break;
-        case FSMC_RS_A23: _ORADDR(24); break;
-          #if ENABLED(STM32_XL_DENSITY)
+      #endif
+      case FSMC_RS_A16: _ORADDR(17); break;
+      case FSMC_RS_A17: _ORADDR(18); break;
+      case FSMC_RS_A18: _ORADDR(19); break;
+      case FSMC_RS_A19: _ORADDR(20); break;
+      case FSMC_RS_A20: _ORADDR(21); break;
+      case FSMC_RS_A21: _ORADDR(22); break;
+      case FSMC_RS_A22: _ORADDR(23); break;
+      case FSMC_RS_A23: _ORADDR(24); break;
+      #if ENABLED(STM32_XL_DENSITY)
         case FSMC_RS_A24: _ORADDR(25); break;
         case FSMC_RS_A25: _ORADDR(26); break;
-          #endif
-        default: return;
-      }
+      #endif
+      default: return;
+    }
 
-      rcc_clk_enable(RCC_FSMC);
-
-      gpio_set_mode(GPIOD, 14, GPIO_AF_OUTPUT_PP); // FSMC_D00
-      gpio_set_mode(GPIOD, 15, GPIO_AF_OUTPUT_PP); // FSMC_D01
-      gpio_set_mode(GPIOD,  0, GPIO_AF_OUTPUT_PP);// FSMC_D02
-      gpio_set_mode(GPIOD,  1, GPIO_AF_OUTPUT_PP);// FSMC_D03
-      gpio_set_mode(GPIOE,  7, GPIO_AF_OUTPUT_PP);// FSMC_D04
-      gpio_set_mode(GPIOE,  8, GPIO_AF_OUTPUT_PP);// FSMC_D05
-      gpio_set_mode(GPIOE,  9, GPIO_AF_OUTPUT_PP);// FSMC_D06
-      gpio_set_mode(GPIOE, 10, GPIO_AF_OUTPUT_PP); // FSMC_D07
-      gpio_set_mode(GPIOE, 11, GPIO_AF_OUTPUT_PP); // FSMC_D08
-      gpio_set_mode(GPIOE, 12, GPIO_AF_OUTPUT_PP); // FSMC_D09
-      gpio_set_mode(GPIOE, 13, GPIO_AF_OUTPUT_PP); // FSMC_D10
-      gpio_set_mode(GPIOE, 14, GPIO_AF_OUTPUT_PP); // FSMC_D11
-      gpio_set_mode(GPIOE, 15, GPIO_AF_OUTPUT_PP); // FSMC_D12
-      gpio_set_mode(GPIOD,  8, GPIO_AF_OUTPUT_PP);// FSMC_D13
-      gpio_set_mode(GPIOD,  9, GPIO_AF_OUTPUT_PP);// FSMC_D14
-      gpio_set_mode(GPIOD, 10, GPIO_AF_OUTPUT_PP); // FSMC_D15
-
-      gpio_set_mode(GPIOD,  4, GPIO_AF_OUTPUT_PP);// FSMC_NOE
-      gpio_set_mode(GPIOD,  5, GPIO_AF_OUTPUT_PP);// FSMC_NWE
-
-      gpio_set_mode(PIN_MAP[cs].gpio_device, PIN_MAP[cs].gpio_bit, GPIO_AF_OUTPUT_PP); //FSMC_CS_NEx
-      gpio_set_mode(PIN_MAP[rs].gpio_device, PIN_MAP[rs].gpio_bit, GPIO_AF_OUTPUT_PP); //FSMC_RS_Ax
+    rcc_clk_enable(RCC_FSMC);
+
+    gpio_set_mode(GPIOD, 14, GPIO_AF_OUTPUT_PP); // FSMC_D00
+    gpio_set_mode(GPIOD, 15, GPIO_AF_OUTPUT_PP); // FSMC_D01
+    gpio_set_mode(GPIOD,  0, GPIO_AF_OUTPUT_PP);// FSMC_D02
+    gpio_set_mode(GPIOD,  1, GPIO_AF_OUTPUT_PP);// FSMC_D03
+    gpio_set_mode(GPIOE,  7, GPIO_AF_OUTPUT_PP);// FSMC_D04
+    gpio_set_mode(GPIOE,  8, GPIO_AF_OUTPUT_PP);// FSMC_D05
+    gpio_set_mode(GPIOE,  9, GPIO_AF_OUTPUT_PP);// FSMC_D06
+    gpio_set_mode(GPIOE, 10, GPIO_AF_OUTPUT_PP); // FSMC_D07
+    gpio_set_mode(GPIOE, 11, GPIO_AF_OUTPUT_PP); // FSMC_D08
+    gpio_set_mode(GPIOE, 12, GPIO_AF_OUTPUT_PP); // FSMC_D09
+    gpio_set_mode(GPIOE, 13, GPIO_AF_OUTPUT_PP); // FSMC_D10
+    gpio_set_mode(GPIOE, 14, GPIO_AF_OUTPUT_PP); // FSMC_D11
+    gpio_set_mode(GPIOE, 15, GPIO_AF_OUTPUT_PP); // FSMC_D12
+    gpio_set_mode(GPIOD,  8, GPIO_AF_OUTPUT_PP);// FSMC_D13
+    gpio_set_mode(GPIOD,  9, GPIO_AF_OUTPUT_PP);// FSMC_D14
+    gpio_set_mode(GPIOD, 10, GPIO_AF_OUTPUT_PP); // FSMC_D15
+
+    gpio_set_mode(GPIOD,  4, GPIO_AF_OUTPUT_PP);// FSMC_NOE
+    gpio_set_mode(GPIOD,  5, GPIO_AF_OUTPUT_PP);// FSMC_NWE
+
+    gpio_set_mode(PIN_MAP[cs].gpio_device, PIN_MAP[cs].gpio_bit, GPIO_AF_OUTPUT_PP); //FSMC_CS_NEx
+    gpio_set_mode(PIN_MAP[rs].gpio_device, PIN_MAP[rs].gpio_bit, GPIO_AF_OUTPUT_PP); //FSMC_RS_Ax
 
-      #if ENABLED(STM32_XL_DENSITY)
-        FSMC_NOR_PSRAM4_BASE->BCR = FSMC_BCR_WREN | FSMC_BCR_MTYP_SRAM | FSMC_BCR_MWID_16BITS | FSMC_BCR_MBKEN;
-        FSMC_NOR_PSRAM4_BASE->BTR = (FSMC_DATA_SETUP_TIME << 8) | FSMC_ADDRESS_SETUP_TIME;
-      #else // PSRAM1 for STM32F103V (high density)
-        FSMC_NOR_PSRAM1_BASE->BCR = FSMC_BCR_WREN | FSMC_BCR_MTYP_SRAM | FSMC_BCR_MWID_16BITS | FSMC_BCR_MBKEN;
-        FSMC_NOR_PSRAM1_BASE->BTR = (FSMC_DATA_SETUP_TIME << 8) | FSMC_ADDRESS_SETUP_TIME;
-      #endif
+    #if ENABLED(STM32_XL_DENSITY)
+      FSMC_NOR_PSRAM4_BASE->BCR = FSMC_BCR_WREN | FSMC_BCR_MTYP_SRAM | FSMC_BCR_MWID_16BITS | FSMC_BCR_MBKEN;
+      FSMC_NOR_PSRAM4_BASE->BTR = (FSMC_DATA_SETUP_TIME << 8) | FSMC_ADDRESS_SETUP_TIME;
+    #else // PSRAM1 for STM32F103V (high density)
+      FSMC_NOR_PSRAM1_BASE->BCR = FSMC_BCR_WREN | FSMC_BCR_MTYP_SRAM | FSMC_BCR_MWID_16BITS | FSMC_BCR_MBKEN;
+      FSMC_NOR_PSRAM1_BASE->BTR = (FSMC_DATA_SETUP_TIME << 8) | FSMC_ADDRESS_SETUP_TIME;
+    #endif
 
-      afio_remap(AFIO_REMAP_FSMC_NADV);
+    afio_remap(AFIO_REMAP_FSMC_NADV);
 
-      LCD = (LCD_CONTROLLER_TypeDef*)controllerAddress;
-    }
+    LCD = (LCD_CONTROLLER_TypeDef*)controllerAddress;
+  }
 
-    void LCD_IO_WriteData(uint16_t RegValue) {
-      LCD->RAM = RegValue;
-      __DSB();
-    }
+  void LCD_IO_WriteData(uint16_t RegValue) {
+    LCD->RAM = RegValue;
+    __DSB();
+  }
 
-    void LCD_IO_WriteReg(uint16_t Reg) {
-      LCD->REG = Reg;
-      __DSB();
-    }
+  void LCD_IO_WriteReg(uint16_t Reg) {
+    LCD->REG = Reg;
+    __DSB();
+  }
 
-    uint16_t LCD_IO_ReadData(uint16_t RegValue) {
-      LCD->REG = RegValue;
-      __DSB();
+  uint16_t LCD_IO_ReadData(uint16_t RegValue) {
+    LCD->REG = RegValue;
+    __DSB();
 
-      return LCD->RAM;
-    }
+    return LCD->RAM;
+  }
 
-    uint16_t ILI9488_ReadRAM() {
-      uint16_t data;
-      data = LCD->RAM;
-      return data;
-    }
+  uint16_t ILI9488_ReadRAM() {
+    uint16_t data;
+    data = LCD->RAM;
+    return data;
+  }
 
-    uint32_t LCD_IO_ReadData(uint16_t RegValue, uint8_t ReadSize) {
-      volatile uint32_t data;
-      LCD->REG = RegValue;
-      __DSB();
+  uint32_t LCD_IO_ReadData(uint16_t RegValue, uint8_t ReadSize) {
+    volatile uint32_t data;
+    LCD->REG = RegValue;
+    __DSB();
 
-      data = LCD->RAM; // dummy read
-      data = LCD->RAM & 0x00FF;
+    data = LCD->RAM; // dummy read
+    data = LCD->RAM & 0x00FF;
 
-      while (--ReadSize) {
-        data <<= 8;
-        data |= (LCD->RAM & 0x00FF);
-      }
-      return uint32_t(data);
+    while (--ReadSize) {
+      data <<= 8;
+      data |= (LCD->RAM & 0x00FF);
     }
+    return uint32_t(data);
+  }
 
-    #ifdef LCD_USE_DMA_FSMC
+  #ifdef LCD_USE_DMA_FSMC
 
     void LCD_IO_WriteMultiple(uint16_t color, uint32_t count) {
       while (count > 0) {
         dma_setup_transfer(FSMC_DMA_DEV, FSMC_DMA_CHANNEL, &color, DMA_SIZE_16BITS, &LCD->RAM, DMA_SIZE_16BITS, DMA_MEM_2_MEM);
         dma_set_num_transfers(FSMC_DMA_DEV, FSMC_DMA_CHANNEL, count > 65535 ? 65535 : count);
         dma_clear_isr_bits(FSMC_DMA_DEV, FSMC_DMA_CHANNEL);
         dma_enable(FSMC_DMA_DEV, FSMC_DMA_CHANNEL);
 
         while ((dma_get_isr_bits(FSMC_DMA_DEV, FSMC_DMA_CHANNEL) & 0x0A) == 0) {}
         dma_disable(FSMC_DMA_DEV, FSMC_DMA_CHANNEL);
@@ -261,13 +261,14 @@
       dma_set_num_transfers(FSMC_DMA_DEV, FSMC_DMA_CHANNEL, length);
       dma_clear_isr_bits(FSMC_DMA_DEV, FSMC_DMA_CHANNEL);
       dma_enable(FSMC_DMA_DEV, FSMC_DMA_CHANNEL);
     }
 
     void LCD_IO_WaitSequence_Async() {
       while ((dma_get_isr_bits(FSMC_DMA_DEV, FSMC_DMA_CHANNEL) & 0x0A) == 0) {}
       dma_disable(FSMC_DMA_DEV, FSMC_DMA_CHANNEL);
     }
 
-    #endif // LCD_USE_DMA_FSMC
-  #endif // ARDUINO_ARCH_STM32F1 && FSMC_CS_PIN
+  #endif // LCD_USE_DMA_FSMC
+
+#endif // ARDUINO_ARCH_STM32F1 && FSMC_CS_PIN
 #endif // HAS_TFT_LVGL_UI

commit d20d4591321aa467c062f0050355d2aca84e03ad
Author: MKS-Sean <56996910+MKS-Sean@users.noreply.github.com>
Date:   Sat Jul 25 13:52:07 2020 +0800

    Robin nano V2, TFT LVGL UI parameters, and more (#18500)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/tft_fsmc.cpp b/Marlin/src/lcd/extui/lib/mks_ui/tft_fsmc.cpp
index 5da3dd1681..e8ac3f3519 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/tft_fsmc.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/tft_fsmc.cpp
@@ -15,21 +15,21 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 #include "../../../../inc/MarlinConfig.h"
 
-#if ENABLED(TFT_LVGL_UI)
+#if HAS_TFT_LVGL_UI
 
   #if defined(ARDUINO_ARCH_STM32F1) && PIN_EXISTS(FSMC_CS) // FSMC on 100/144 pins SoCs
 
     #include <libmaple/fsmc.h>
     #include <libmaple/gpio.h>
     #include <libmaple/dma.h>
     #include <boards.h>
 
 /* Timing configuration */
     #define FSMC_ADDRESS_SETUP_TIME   15// AddressSetupTime
@@ -263,11 +263,11 @@
       dma_enable(FSMC_DMA_DEV, FSMC_DMA_CHANNEL);
     }
 
     void LCD_IO_WaitSequence_Async() {
       while ((dma_get_isr_bits(FSMC_DMA_DEV, FSMC_DMA_CHANNEL) & 0x0A) == 0) {}
       dma_disable(FSMC_DMA_DEV, FSMC_DMA_CHANNEL);
     }
 
     #endif // LCD_USE_DMA_FSMC
   #endif // ARDUINO_ARCH_STM32F1 && FSMC_CS_PIN
-#endif // TFT_LVGL_UI
+#endif // HAS_TFT_LVGL_UI

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/tft_fsmc.cpp b/Marlin/src/lcd/extui/lib/mks_ui/tft_fsmc.cpp
index 7e782c3fef..5da3dd1681 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/tft_fsmc.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/tft_fsmc.cpp
@@ -9,21 +9,21 @@
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 #include "../../../../inc/MarlinConfig.h"
 
 #if ENABLED(TFT_LVGL_UI)
 
   #if defined(ARDUINO_ARCH_STM32F1) && PIN_EXISTS(FSMC_CS) // FSMC on 100/144 pins SoCs
 
     #include <libmaple/fsmc.h>

commit e5bc9d31cc87be5c7ef2bd3cd70c2599f76d2bd7
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Wed Jul 1 03:30:24 2020 -0300

    Add TFT_LVGL_UI support (#18438)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/tft_fsmc.cpp b/Marlin/src/lcd/extui/lib/mks_ui/tft_fsmc.cpp
index 25fd7082d9..7e782c3fef 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/tft_fsmc.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/tft_fsmc.cpp
@@ -15,21 +15,21 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
 #include "../../../../inc/MarlinConfig.h"
 
-#if ENABLED(TFT_LITTLE_VGL_UI)
+#if ENABLED(TFT_LVGL_UI)
 
   #if defined(ARDUINO_ARCH_STM32F1) && PIN_EXISTS(FSMC_CS) // FSMC on 100/144 pins SoCs
 
     #include <libmaple/fsmc.h>
     #include <libmaple/gpio.h>
     #include <libmaple/dma.h>
     #include <boards.h>
 
 /* Timing configuration */
     #define FSMC_ADDRESS_SETUP_TIME   15// AddressSetupTime
@@ -223,21 +223,21 @@
       data = LCD->RAM; // dummy read
       data = LCD->RAM & 0x00FF;
 
       while (--ReadSize) {
         data <<= 8;
         data |= (LCD->RAM & 0x00FF);
       }
       return uint32_t(data);
     }
 
-    #if ENABLED(LCD_USE_DMA_FSMC)
+    #ifdef LCD_USE_DMA_FSMC
 
     void LCD_IO_WriteMultiple(uint16_t color, uint32_t count) {
       while (count > 0) {
         dma_setup_transfer(FSMC_DMA_DEV, FSMC_DMA_CHANNEL, &color, DMA_SIZE_16BITS, &LCD->RAM, DMA_SIZE_16BITS, DMA_MEM_2_MEM);
         dma_set_num_transfers(FSMC_DMA_DEV, FSMC_DMA_CHANNEL, count > 65535 ? 65535 : count);
         dma_clear_isr_bits(FSMC_DMA_DEV, FSMC_DMA_CHANNEL);
         dma_enable(FSMC_DMA_DEV, FSMC_DMA_CHANNEL);
 
         while ((dma_get_isr_bits(FSMC_DMA_DEV, FSMC_DMA_CHANNEL) & 0x0A) == 0) {}
         dma_disable(FSMC_DMA_DEV, FSMC_DMA_CHANNEL);
@@ -263,11 +263,11 @@
       dma_enable(FSMC_DMA_DEV, FSMC_DMA_CHANNEL);
     }
 
     void LCD_IO_WaitSequence_Async() {
       while ((dma_get_isr_bits(FSMC_DMA_DEV, FSMC_DMA_CHANNEL) & 0x0A) == 0) {}
       dma_disable(FSMC_DMA_DEV, FSMC_DMA_CHANNEL);
     }
 
     #endif // LCD_USE_DMA_FSMC
   #endif // ARDUINO_ARCH_STM32F1 && FSMC_CS_PIN
-#endif // TFT_LITTLE_VGL_UI
+#endif // TFT_LVGL_UI

commit 642112d3eb7c1af9a52feec8134c85ed3e34891c
Author: makerbase <4164049@qq.com>
Date:   Tue Jun 16 10:05:33 2020 +0800

    Add MKS UI (TFT_LITTLE_VGL_UI) (#18071)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/tft_fsmc.cpp b/Marlin/src/lcd/extui/lib/mks_ui/tft_fsmc.cpp
new file mode 100644
index 0000000000..25fd7082d9
--- /dev/null
+++ b/Marlin/src/lcd/extui/lib/mks_ui/tft_fsmc.cpp
@@ -0,0 +1,273 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "../../../../inc/MarlinConfig.h"
+
+#if ENABLED(TFT_LITTLE_VGL_UI)
+
+  #if defined(ARDUINO_ARCH_STM32F1) && PIN_EXISTS(FSMC_CS) // FSMC on 100/144 pins SoCs
+
+    #include <libmaple/fsmc.h>
+    #include <libmaple/gpio.h>
+    #include <libmaple/dma.h>
+    #include <boards.h>
+
+/* Timing configuration */
+    #define FSMC_ADDRESS_SETUP_TIME   15// AddressSetupTime
+    #define FSMC_DATA_SETUP_TIME      15// DataSetupTime
+
+    void LCD_IO_Init(uint8_t cs, uint8_t rs);
+    void LCD_IO_WriteData(uint16_t RegValue);
+    void LCD_IO_WriteReg(uint16_t Reg);
+    uint16_t LCD_IO_ReadData(uint16_t RegValue);
+    uint32_t LCD_IO_ReadData(uint16_t RegValue, uint8_t ReadSize);
+    uint16_t ILI9488_ReadRAM();
+    #ifdef LCD_USE_DMA_FSMC
+      void LCD_IO_WriteMultiple(uint16_t data, uint32_t count);
+      void LCD_IO_WriteSequence(uint16_t *data, uint16_t length);
+    #endif
+
+/**
+ * FSMC LCD IO
+ */
+    #define __ASM __asm
+    #define __STATIC_INLINE static inline
+
+    __attribute__((always_inline)) __STATIC_INLINE void __DSB() {__ASM volatile ("dsb 0xF" ::: "memory");}
+
+    #define FSMC_CS_NE1   PD7
+
+    #if ENABLED(STM32_XL_DENSITY)
+      #define FSMC_CS_NE2 PG9
+      #define FSMC_CS_NE3 PG10
+      #define FSMC_CS_NE4 PG12
+
+      #define FSMC_RS_A0  PF0
+      #define FSMC_RS_A1  PF1
+      #define FSMC_RS_A2  PF2
+      #define FSMC_RS_A3  PF3
+      #define FSMC_RS_A4  PF4
+      #define FSMC_RS_A5  PF5
+      #define FSMC_RS_A6  PF12
+      #define FSMC_RS_A7  PF13
+      #define FSMC_RS_A8  PF14
+      #define FSMC_RS_A9  PF15
+      #define FSMC_RS_A10 PG0
+      #define FSMC_RS_A11 PG1
+      #define FSMC_RS_A12 PG2
+      #define FSMC_RS_A13 PG3
+      #define FSMC_RS_A14 PG4
+      #define FSMC_RS_A15 PG5
+    #endif
+
+    #define FSMC_RS_A16   PD11
+    #define FSMC_RS_A17   PD12
+    #define FSMC_RS_A18   PD13
+    #define FSMC_RS_A19   PE3
+    #define FSMC_RS_A20   PE4
+    #define FSMC_RS_A21   PE5
+    #define FSMC_RS_A22   PE6
+    #define FSMC_RS_A23   PE2
+
+    #if ENABLED(STM32_XL_DENSITY)
+      #define FSMC_RS_A24 PG13
+      #define FSMC_RS_A25 PG14
+    #endif
+
+    static uint8_t fsmcInit = 0;
+
+    typedef struct {
+      __IO uint16_t REG;
+      __IO uint16_t RAM;
+    } LCD_CONTROLLER_TypeDef;
+
+    LCD_CONTROLLER_TypeDef *LCD;
+
+    void LCD_IO_Init(uint8_t cs, uint8_t rs) {
+      uint32_t controllerAddress;
+
+      if (fsmcInit) return;
+      fsmcInit = 1;
+
+      switch (cs) {
+        case FSMC_CS_NE1: controllerAddress = (uint32_t)FSMC_NOR_PSRAM_REGION1; break;
+          #if ENABLED(STM32_XL_DENSITY)
+        case FSMC_CS_NE2: controllerAddress = (uint32_t)FSMC_NOR_PSRAM_REGION2; break;
+        case FSMC_CS_NE3: controllerAddress = (uint32_t)FSMC_NOR_PSRAM_REGION3; break;
+        case FSMC_CS_NE4: controllerAddress = (uint32_t)FSMC_NOR_PSRAM_REGION4; break;
+          #endif
+        default: return;
+      }
+
+      #define _ORADDR(N) controllerAddress |= (_BV32(N) - 2)
+
+      switch (rs) {
+        #if ENABLED(STM32_XL_DENSITY)
+        case FSMC_RS_A0:  _ORADDR( 1); break;
+        case FSMC_RS_A1:  _ORADDR( 2); break;
+        case FSMC_RS_A2:  _ORADDR( 3); break;
+        case FSMC_RS_A3:  _ORADDR( 4); break;
+        case FSMC_RS_A4:  _ORADDR( 5); break;
+        case FSMC_RS_A5:  _ORADDR( 6); break;
+        case FSMC_RS_A6:  _ORADDR( 7); break;
+        case FSMC_RS_A7:  _ORADDR( 8); break;
+        case FSMC_RS_A8:  _ORADDR( 9); break;
+        case FSMC_RS_A9:  _ORADDR(10); break;
+        case FSMC_RS_A10: _ORADDR(11); break;
+        case FSMC_RS_A11: _ORADDR(12); break;
+        case FSMC_RS_A12: _ORADDR(13); break;
+        case FSMC_RS_A13: _ORADDR(14); break;
+        case FSMC_RS_A14: _ORADDR(15); break;
+        case FSMC_RS_A15: _ORADDR(16); break;
+        #endif
+        case FSMC_RS_A16: _ORADDR(17); break;
+        case FSMC_RS_A17: _ORADDR(18); break;
+        case FSMC_RS_A18: _ORADDR(19); break;
+        case FSMC_RS_A19: _ORADDR(20); break;
+        case FSMC_RS_A20: _ORADDR(21); break;
+        case FSMC_RS_A21: _ORADDR(22); break;
+        case FSMC_RS_A22: _ORADDR(23); break;
+        case FSMC_RS_A23: _ORADDR(24); break;
+          #if ENABLED(STM32_XL_DENSITY)
+        case FSMC_RS_A24: _ORADDR(25); break;
+        case FSMC_RS_A25: _ORADDR(26); break;
+          #endif
+        default: return;
+      }
+
+      rcc_clk_enable(RCC_FSMC);
+
+      gpio_set_mode(GPIOD, 14, GPIO_AF_OUTPUT_PP); // FSMC_D00
+      gpio_set_mode(GPIOD, 15, GPIO_AF_OUTPUT_PP); // FSMC_D01
+      gpio_set_mode(GPIOD,  0, GPIO_AF_OUTPUT_PP);// FSMC_D02
+      gpio_set_mode(GPIOD,  1, GPIO_AF_OUTPUT_PP);// FSMC_D03
+      gpio_set_mode(GPIOE,  7, GPIO_AF_OUTPUT_PP);// FSMC_D04
+      gpio_set_mode(GPIOE,  8, GPIO_AF_OUTPUT_PP);// FSMC_D05
+      gpio_set_mode(GPIOE,  9, GPIO_AF_OUTPUT_PP);// FSMC_D06
+      gpio_set_mode(GPIOE, 10, GPIO_AF_OUTPUT_PP); // FSMC_D07
+      gpio_set_mode(GPIOE, 11, GPIO_AF_OUTPUT_PP); // FSMC_D08
+      gpio_set_mode(GPIOE, 12, GPIO_AF_OUTPUT_PP); // FSMC_D09
+      gpio_set_mode(GPIOE, 13, GPIO_AF_OUTPUT_PP); // FSMC_D10
+      gpio_set_mode(GPIOE, 14, GPIO_AF_OUTPUT_PP); // FSMC_D11
+      gpio_set_mode(GPIOE, 15, GPIO_AF_OUTPUT_PP); // FSMC_D12
+      gpio_set_mode(GPIOD,  8, GPIO_AF_OUTPUT_PP);// FSMC_D13
+      gpio_set_mode(GPIOD,  9, GPIO_AF_OUTPUT_PP);// FSMC_D14
+      gpio_set_mode(GPIOD, 10, GPIO_AF_OUTPUT_PP); // FSMC_D15
+
+      gpio_set_mode(GPIOD,  4, GPIO_AF_OUTPUT_PP);// FSMC_NOE
+      gpio_set_mode(GPIOD,  5, GPIO_AF_OUTPUT_PP);// FSMC_NWE
+
+      gpio_set_mode(PIN_MAP[cs].gpio_device, PIN_MAP[cs].gpio_bit, GPIO_AF_OUTPUT_PP); //FSMC_CS_NEx
+      gpio_set_mode(PIN_MAP[rs].gpio_device, PIN_MAP[rs].gpio_bit, GPIO_AF_OUTPUT_PP); //FSMC_RS_Ax
+
+      #if ENABLED(STM32_XL_DENSITY)
+        FSMC_NOR_PSRAM4_BASE->BCR = FSMC_BCR_WREN | FSMC_BCR_MTYP_SRAM | FSMC_BCR_MWID_16BITS | FSMC_BCR_MBKEN;
+        FSMC_NOR_PSRAM4_BASE->BTR = (FSMC_DATA_SETUP_TIME << 8) | FSMC_ADDRESS_SETUP_TIME;
+      #else // PSRAM1 for STM32F103V (high density)
+        FSMC_NOR_PSRAM1_BASE->BCR = FSMC_BCR_WREN | FSMC_BCR_MTYP_SRAM | FSMC_BCR_MWID_16BITS | FSMC_BCR_MBKEN;
+        FSMC_NOR_PSRAM1_BASE->BTR = (FSMC_DATA_SETUP_TIME << 8) | FSMC_ADDRESS_SETUP_TIME;
+      #endif
+
+      afio_remap(AFIO_REMAP_FSMC_NADV);
+
+      LCD = (LCD_CONTROLLER_TypeDef*)controllerAddress;
+    }
+
+    void LCD_IO_WriteData(uint16_t RegValue) {
+      LCD->RAM = RegValue;
+      __DSB();
+    }
+
+    void LCD_IO_WriteReg(uint16_t Reg) {
+      LCD->REG = Reg;
+      __DSB();
+    }
+
+    uint16_t LCD_IO_ReadData(uint16_t RegValue) {
+      LCD->REG = RegValue;
+      __DSB();
+
+      return LCD->RAM;
+    }
+
+    uint16_t ILI9488_ReadRAM() {
+      uint16_t data;
+      data = LCD->RAM;
+      return data;
+    }
+
+    uint32_t LCD_IO_ReadData(uint16_t RegValue, uint8_t ReadSize) {
+      volatile uint32_t data;
+      LCD->REG = RegValue;
+      __DSB();
+
+      data = LCD->RAM; // dummy read
+      data = LCD->RAM & 0x00FF;
+
+      while (--ReadSize) {
+        data <<= 8;
+        data |= (LCD->RAM & 0x00FF);
+      }
+      return uint32_t(data);
+    }
+
+    #if ENABLED(LCD_USE_DMA_FSMC)
+
+    void LCD_IO_WriteMultiple(uint16_t color, uint32_t count) {
+      while (count > 0) {
+        dma_setup_transfer(FSMC_DMA_DEV, FSMC_DMA_CHANNEL, &color, DMA_SIZE_16BITS, &LCD->RAM, DMA_SIZE_16BITS, DMA_MEM_2_MEM);
+        dma_set_num_transfers(FSMC_DMA_DEV, FSMC_DMA_CHANNEL, count > 65535 ? 65535 : count);
+        dma_clear_isr_bits(FSMC_DMA_DEV, FSMC_DMA_CHANNEL);
+        dma_enable(FSMC_DMA_DEV, FSMC_DMA_CHANNEL);
+
+        while ((dma_get_isr_bits(FSMC_DMA_DEV, FSMC_DMA_CHANNEL) & 0x0A) == 0) {}
+        dma_disable(FSMC_DMA_DEV, FSMC_DMA_CHANNEL);
+
+        count = count > 65535 ? count - 65535 : 0;
+      }
+    }
+
+    void LCD_IO_WriteSequence(uint16_t *data, uint16_t length) {
+      dma_setup_transfer(FSMC_DMA_DEV, FSMC_DMA_CHANNEL, data, DMA_SIZE_16BITS, &LCD->RAM, DMA_SIZE_16BITS, DMA_MEM_2_MEM | DMA_PINC_MODE);
+      dma_set_num_transfers(FSMC_DMA_DEV, FSMC_DMA_CHANNEL, length);
+      dma_clear_isr_bits(FSMC_DMA_DEV, FSMC_DMA_CHANNEL);
+      dma_enable(FSMC_DMA_DEV, FSMC_DMA_CHANNEL);
+
+      while ((dma_get_isr_bits(FSMC_DMA_DEV, FSMC_DMA_CHANNEL) & 0x0A) == 0) {}
+      dma_disable(FSMC_DMA_DEV, FSMC_DMA_CHANNEL);
+    }
+
+    void LCD_IO_WriteSequence_Async(uint16_t *data, uint16_t length) {
+      dma_setup_transfer(FSMC_DMA_DEV, FSMC_DMA_CHANNEL, data, DMA_SIZE_16BITS, &LCD->RAM, DMA_SIZE_16BITS, DMA_MEM_2_MEM | DMA_PINC_MODE);
+      dma_set_num_transfers(FSMC_DMA_DEV, FSMC_DMA_CHANNEL, length);
+      dma_clear_isr_bits(FSMC_DMA_DEV, FSMC_DMA_CHANNEL);
+      dma_enable(FSMC_DMA_DEV, FSMC_DMA_CHANNEL);
+    }
+
+    void LCD_IO_WaitSequence_Async() {
+      while ((dma_get_isr_bits(FSMC_DMA_DEV, FSMC_DMA_CHANNEL) & 0x0A) == 0) {}
+      dma_disable(FSMC_DMA_DEV, FSMC_DMA_CHANNEL);
+    }
+
+    #endif // LCD_USE_DMA_FSMC
+  #endif // ARDUINO_ARCH_STM32F1 && FSMC_CS_PIN
+#endif // TFT_LITTLE_VGL_UI
