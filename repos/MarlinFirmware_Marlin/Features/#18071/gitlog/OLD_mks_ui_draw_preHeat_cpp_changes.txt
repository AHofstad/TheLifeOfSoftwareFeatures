commit 8d9021e8069c0550e9a31107adf44b9112b87471
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 6 04:17:59 2021 -0500

    Move ExtUI subfolders up a level (#21820)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
deleted file mode 100644
index 5fcfec1534..0000000000
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
+++ /dev/null
@@ -1,267 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#include "../../../../inc/MarlinConfigPre.h"
-
-#if HAS_TFT_LVGL_UI
-
-#include "draw_ui.h"
-#include <lv_conf.h>
-
-#include "../../../../module/temperature.h"
-#include "../../../../inc/MarlinConfig.h"
-
-static lv_obj_t *scr;
-extern lv_group_t*  g;
-static lv_obj_t *buttonType, *buttonStep;
-static lv_obj_t *labelType;
-static lv_obj_t *labelStep;
-static lv_obj_t *tempText1;
-
-enum {
-  ID_P_ADD = 1,
-  ID_P_DEC,
-  ID_P_TYPE,
-  ID_P_STEP,
-  ID_P_OFF,
-  ID_P_RETURN
-};
-
-static void event_handler(lv_obj_t *obj, lv_event_t event) {
-  if (event != LV_EVENT_RELEASED) return;
-  switch (obj->mks_obj_id) {
-    case ID_P_ADD: {
-      if (uiCfg.curTempType == 0) {
-        int16_t max_target;
-        thermalManager.temp_hotend[uiCfg.extruderIndex].target += uiCfg.stepHeat;
-        if (uiCfg.extruderIndex == 0)
-          max_target = HEATER_0_MAXTEMP - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1);
-        #if HAS_MULTI_HOTEND
-          else
-            max_target = HEATER_1_MAXTEMP - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1);
-        #endif
-        if (thermalManager.degTargetHotend(uiCfg.extruderIndex) > max_target)
-          thermalManager.setTargetHotend(max_target, uiCfg.extruderIndex);
-        thermalManager.start_watching_hotend(uiCfg.extruderIndex);
-      }
-      else {
-        #if HAS_HEATED_BED
-          constexpr int16_t max_target = BED_MAXTEMP - (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1);
-          thermalManager.temp_bed.target += uiCfg.stepHeat;
-          if (thermalManager.degTargetBed() > max_target)
-            thermalManager.setTargetBed(max_target);
-          thermalManager.start_watching_bed();
-        #endif
-      }
-      disp_desire_temp();
-    } break;
-
-    case ID_P_DEC:
-      if (uiCfg.curTempType == 0) {
-        if (thermalManager.degTargetHotend(uiCfg.extruderIndex) > uiCfg.stepHeat)
-          thermalManager.temp_hotend[uiCfg.extruderIndex].target -= uiCfg.stepHeat;
-        else
-          thermalManager.setTargetHotend(0, uiCfg.extruderIndex);
-        thermalManager.start_watching_hotend(uiCfg.extruderIndex);
-      }
-      #if HAS_HEATED_BED
-        else {
-          if (thermalManager.degTargetBed() > uiCfg.stepHeat)
-            thermalManager.temp_bed.target -= uiCfg.stepHeat;
-          else
-            thermalManager.setTargetBed(0);
-
-          thermalManager.start_watching_bed();
-        }
-      #endif
-      disp_desire_temp();
-      break;
-    case ID_P_TYPE:
-      if (uiCfg.curTempType == 0) {
-        if (ENABLED(HAS_MULTI_EXTRUDER)) {
-          if (uiCfg.extruderIndex == 0) {
-            uiCfg.extruderIndex = 1;
-          }
-          else if (uiCfg.extruderIndex == 1) {
-            if (TEMP_SENSOR_BED != 0) {
-              uiCfg.curTempType = 1;
-            }
-            else {
-              uiCfg.curTempType      = 0;
-              uiCfg.extruderIndex = 0;
-            }
-          }
-        }
-        else if (uiCfg.extruderIndex == 0) {
-          if (TEMP_SENSOR_BED != 0)
-            uiCfg.curTempType = 1;
-          else
-            uiCfg.curTempType = 0;
-        }
-      }
-      else if (uiCfg.curTempType == 1) {
-        uiCfg.extruderIndex = 0;
-        uiCfg.curTempType      = 0;
-      }
-      disp_temp_type();
-      break;
-    case ID_P_STEP:
-      switch (uiCfg.stepHeat) {
-        case  1: uiCfg.stepHeat =  5; break;
-        case  5: uiCfg.stepHeat = 10; break;
-        case 10: uiCfg.stepHeat =  1; break;
-        default: break;
-      }
-      disp_step_heat();
-      break;
-    case ID_P_OFF:
-      if (uiCfg.curTempType == 0) {
-        thermalManager.setTargetHotend(0, uiCfg.extruderIndex);
-        thermalManager.start_watching_hotend(uiCfg.extruderIndex);
-      }
-      #if HAS_HEATED_BED
-        else {
-          thermalManager.temp_bed.target = 0;
-          thermalManager.start_watching_bed();
-        }
-      #endif
-      disp_desire_temp();
-      break;
-    case ID_P_RETURN:
-      clear_cur_ui();
-      draw_return_ui();
-      break;
-  }
-}
-
-void lv_draw_preHeat() {
-  scr = lv_screen_create(PRE_HEAT_UI);
-
-  // Create image buttons
-  lv_big_button_create(scr, "F:/bmp_Add.bin", preheat_menu.add, INTERVAL_V, titleHeight, event_handler, ID_P_ADD);
-  lv_big_button_create(scr, "F:/bmp_Dec.bin", preheat_menu.dec, BTN_X_PIXEL * 3 + INTERVAL_V * 4, titleHeight, event_handler, ID_P_DEC);
-
-  buttonType = lv_imgbtn_create(scr, nullptr, INTERVAL_V, BTN_Y_PIXEL + INTERVAL_H + titleHeight, event_handler, ID_P_TYPE);
-  buttonStep = lv_imgbtn_create(scr, nullptr, BTN_X_PIXEL + INTERVAL_V * 2, BTN_Y_PIXEL + INTERVAL_H + titleHeight, event_handler, ID_P_STEP);
-  #if HAS_ROTARY_ENCODER
-    if (gCfgItems.encoder_enable) {
-      lv_group_add_obj(g, buttonType);
-      lv_group_add_obj(g, buttonStep);
-    }
-  #endif
-
-  lv_big_button_create(scr, "F:/bmp_speed0.bin", preheat_menu.off, BTN_X_PIXEL * 2 + INTERVAL_V * 3, BTN_Y_PIXEL + INTERVAL_H + titleHeight, event_handler, ID_P_OFF);
-  lv_big_button_create(scr, "F:/bmp_return.bin", common_menu.text_back, BTN_X_PIXEL * 3 + INTERVAL_V * 4, BTN_Y_PIXEL + INTERVAL_H + titleHeight, event_handler, ID_P_RETURN);
-
-  // Create labels on the image buttons
-  labelType = lv_label_create_empty(buttonType);
-  labelStep = lv_label_create_empty(buttonStep);
-
-  disp_temp_type();
-  disp_step_heat();
-
-  tempText1 = lv_label_create_empty(scr);
-  lv_obj_set_style(tempText1, &tft_style_label_rel);
-  disp_desire_temp();
-}
-
-void disp_temp_type() {
-  if (uiCfg.curTempType == 0) {
-    if (uiCfg.extruderIndex == 1) {
-    lv_imgbtn_set_src_both(buttonType, "F:/bmp_extru2.bin");
-      if (gCfgItems.multiple_language) {
-        lv_label_set_text(labelType, preheat_menu.ext2);
-        lv_obj_align(labelType, buttonType, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
-      }
-    }
-    else {
-    lv_imgbtn_set_src_both(buttonType, "F:/bmp_extru1.bin");
-      if (gCfgItems.multiple_language) {
-        lv_label_set_text(labelType, preheat_menu.ext1);
-        lv_obj_align(labelType, buttonType, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
-      }
-    }
-
-  }
-  else {
-  lv_imgbtn_set_src_both(buttonType, "F:/bmp_bed.bin");
-    if (gCfgItems.multiple_language) {
-      lv_label_set_text(labelType, preheat_menu.hotbed);
-      lv_obj_align(labelType, buttonType, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
-    }
-  }
-}
-
-void disp_desire_temp() {
-  char buf[20] = { 0 };
-  public_buf_l[0] = '\0';
-
-  if (uiCfg.curTempType == 0) {
-    strcat(public_buf_l, uiCfg.extruderIndex < 1 ? preheat_menu.ext1 : preheat_menu.ext2);
-    sprintf(buf, preheat_menu.value_state, thermalManager.wholeDegHotend(uiCfg.extruderIndex), thermalManager.degTargetHotend(uiCfg.extruderIndex));
-  }
-  else {
-    #if HAS_HEATED_BED
-      strcat(public_buf_l, preheat_menu.hotbed);
-      sprintf(buf, preheat_menu.value_state, thermalManager.wholeDegBed(), thermalManager.degTargetBed());
-    #endif
-  }
-  strcat_P(public_buf_l, PSTR(": "));
-  strcat(public_buf_l, buf);
-  lv_label_set_text(tempText1, public_buf_l);
-  lv_obj_align(tempText1, nullptr, LV_ALIGN_CENTER, 0, -50);
-}
-
-void disp_step_heat() {
-  if (uiCfg.stepHeat == 1) {
-    lv_imgbtn_set_src_both(buttonStep, "F:/bmp_step1_degree.bin");
-  }
-  else if (uiCfg.stepHeat == 5) {
-    lv_imgbtn_set_src_both(buttonStep, "F:/bmp_step5_degree.bin");
-  }
-  else if (uiCfg.stepHeat == 10) {
-    lv_imgbtn_set_src_both(buttonStep, "F:/bmp_step10_degree.bin");
-  }
-
-  if (gCfgItems.multiple_language) {
-    if (uiCfg.stepHeat == 1) {
-      lv_label_set_text(labelStep, preheat_menu.step_1c);
-      lv_obj_align(labelStep, buttonStep, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
-    }
-    else if (uiCfg.stepHeat == 5) {
-      lv_label_set_text(labelStep, preheat_menu.step_5c);
-      lv_obj_align(labelStep, buttonStep, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
-    }
-    else if (uiCfg.stepHeat == 10) {
-      lv_label_set_text(labelStep, preheat_menu.step_10c);
-      lv_obj_align(labelStep, buttonStep, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
-    }
-  }
-}
-
-void lv_clear_preHeat() {
-  #if HAS_ROTARY_ENCODER
-    if (gCfgItems.encoder_enable) lv_group_remove_all_objs(g);
-  #endif
-  lv_obj_del(scr);
-}
-
-#endif // HAS_TFT_LVGL_UI

commit c4620bb5285438e41fa4c39229aa2a39859877ca
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Apr 23 20:19:23 2021 -0500

    Add whole-degree accessors, simplify some temperature-related features (#21685)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
index 0395ccde52..5fcfec1534 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
@@ -209,26 +209,26 @@ void disp_temp_type() {
     }
   }
 }
 
 void disp_desire_temp() {
   char buf[20] = { 0 };
   public_buf_l[0] = '\0';
 
   if (uiCfg.curTempType == 0) {
     strcat(public_buf_l, uiCfg.extruderIndex < 1 ? preheat_menu.ext1 : preheat_menu.ext2);
-    sprintf(buf, preheat_menu.value_state, (int)thermalManager.degHotend(uiCfg.extruderIndex), (int)thermalManager.degTargetHotend(uiCfg.extruderIndex));
+    sprintf(buf, preheat_menu.value_state, thermalManager.wholeDegHotend(uiCfg.extruderIndex), thermalManager.degTargetHotend(uiCfg.extruderIndex));
   }
   else {
     #if HAS_HEATED_BED
       strcat(public_buf_l, preheat_menu.hotbed);
-      sprintf(buf, preheat_menu.value_state, (int)thermalManager.degBed(), (int)thermalManager.degTargetBed());
+      sprintf(buf, preheat_menu.value_state, thermalManager.wholeDegBed(), thermalManager.degTargetBed());
     #endif
   }
   strcat_P(public_buf_l, PSTR(": "));
   strcat(public_buf_l, buf);
   lv_label_set_text(tempText1, public_buf_l);
   lv_obj_align(tempText1, nullptr, LV_ALIGN_CENTER, 0, -50);
 }
 
 void disp_step_heat() {
   if (uiCfg.stepHeat == 1) {

commit 746eae15f36e4211a22d53b8e12e82edb55a13e5
Author: Malderin <52313714+Malderin@users.noreply.github.com>
Date:   Tue Apr 6 04:55:00 2021 +0300

    Cast celsius to int for MKS LVGL UI (#21502)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
index d23ed0b05f..0395ccde52 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
@@ -55,29 +55,29 @@ static void event_handler(lv_obj_t *obj, lv_event_t event) {
         if (uiCfg.extruderIndex == 0)
           max_target = HEATER_0_MAXTEMP - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1);
         #if HAS_MULTI_HOTEND
           else
             max_target = HEATER_1_MAXTEMP - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1);
         #endif
         if (thermalManager.degTargetHotend(uiCfg.extruderIndex) > max_target)
           thermalManager.setTargetHotend(max_target, uiCfg.extruderIndex);
         thermalManager.start_watching_hotend(uiCfg.extruderIndex);
       }
-      #if HAS_HEATED_BED
-        else {
+      else {
+        #if HAS_HEATED_BED
           constexpr int16_t max_target = BED_MAXTEMP - (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1);
           thermalManager.temp_bed.target += uiCfg.stepHeat;
           if (thermalManager.degTargetBed() > max_target)
             thermalManager.setTargetBed(max_target);
           thermalManager.start_watching_bed();
-        }
-      #endif
+        #endif
+      }
       disp_desire_temp();
     } break;
 
     case ID_P_DEC:
       if (uiCfg.curTempType == 0) {
         if (thermalManager.degTargetHotend(uiCfg.extruderIndex) > uiCfg.stepHeat)
           thermalManager.temp_hotend[uiCfg.extruderIndex].target -= uiCfg.stepHeat;
         else
           thermalManager.setTargetHotend(0, uiCfg.extruderIndex);
         thermalManager.start_watching_hotend(uiCfg.extruderIndex);
@@ -204,34 +204,33 @@ void disp_temp_type() {
   else {
   lv_imgbtn_set_src_both(buttonType, "F:/bmp_bed.bin");
     if (gCfgItems.multiple_language) {
       lv_label_set_text(labelType, preheat_menu.hotbed);
       lv_obj_align(labelType, buttonType, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
     }
   }
 }
 
 void disp_desire_temp() {
-  char buf[20] = {0};
-
+  char buf[20] = { 0 };
   public_buf_l[0] = '\0';
 
   if (uiCfg.curTempType == 0) {
     strcat(public_buf_l, uiCfg.extruderIndex < 1 ? preheat_menu.ext1 : preheat_menu.ext2);
-    sprintf(buf, preheat_menu.value_state, thermalManager.degHotend(uiCfg.extruderIndex), thermalManager.degTargetHotend(uiCfg.extruderIndex));
+    sprintf(buf, preheat_menu.value_state, (int)thermalManager.degHotend(uiCfg.extruderIndex), (int)thermalManager.degTargetHotend(uiCfg.extruderIndex));
   }
-  #if HAS_HEATED_BED
-    else {
+  else {
+    #if HAS_HEATED_BED
       strcat(public_buf_l, preheat_menu.hotbed);
-      sprintf(buf, preheat_menu.value_state, thermalManager.degBed(), thermalManager.degTargetBed());
-    }
-  #endif
+      sprintf(buf, preheat_menu.value_state, (int)thermalManager.degBed(), (int)thermalManager.degTargetBed());
+    #endif
+  }
   strcat_P(public_buf_l, PSTR(": "));
   strcat(public_buf_l, buf);
   lv_label_set_text(tempText1, public_buf_l);
   lv_obj_align(tempText1, nullptr, LV_ALIGN_CENTER, 0, -50);
 }
 
 void disp_step_heat() {
   if (uiCfg.stepHeat == 1) {
     lv_imgbtn_set_src_both(buttonStep, "F:/bmp_step1_degree.bin");
   }

commit a335cf2edf66db08ab12d3800784b58ad992f6a9
Author: Malderin <52313714+Malderin@users.noreply.github.com>
Date:   Mon Mar 29 11:19:38 2021 +0300

    Fix MKS LVGL UI Main screen / print buttons (#21468)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
index 73a0808e9c..d23ed0b05f 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
@@ -69,29 +69,29 @@ static void event_handler(lv_obj_t *obj, lv_event_t event) {
           if (thermalManager.degTargetBed() > max_target)
             thermalManager.setTargetBed(max_target);
           thermalManager.start_watching_bed();
         }
       #endif
       disp_desire_temp();
     } break;
 
     case ID_P_DEC:
       if (uiCfg.curTempType == 0) {
-        if ((int)thermalManager.degTargetHotend(uiCfg.extruderIndex) > uiCfg.stepHeat)
+        if (thermalManager.degTargetHotend(uiCfg.extruderIndex) > uiCfg.stepHeat)
           thermalManager.temp_hotend[uiCfg.extruderIndex].target -= uiCfg.stepHeat;
         else
           thermalManager.setTargetHotend(0, uiCfg.extruderIndex);
         thermalManager.start_watching_hotend(uiCfg.extruderIndex);
       }
       #if HAS_HEATED_BED
         else {
-          if ((int)thermalManager.temp_bed.target > uiCfg.stepHeat)
+          if (thermalManager.degTargetBed() > uiCfg.stepHeat)
             thermalManager.temp_bed.target -= uiCfg.stepHeat;
           else
             thermalManager.setTargetBed(0);
 
           thermalManager.start_watching_bed();
         }
       #endif
       disp_desire_temp();
       break;
     case ID_P_TYPE:
@@ -210,26 +210,26 @@ void disp_temp_type() {
   }
 }
 
 void disp_desire_temp() {
   char buf[20] = {0};
 
   public_buf_l[0] = '\0';
 
   if (uiCfg.curTempType == 0) {
     strcat(public_buf_l, uiCfg.extruderIndex < 1 ? preheat_menu.ext1 : preheat_menu.ext2);
-    sprintf(buf, preheat_menu.value_state, (int)thermalManager.degHotend(uiCfg.extruderIndex), (int)thermalManager.degTargetHotend(uiCfg.extruderIndex));
+    sprintf(buf, preheat_menu.value_state, thermalManager.degHotend(uiCfg.extruderIndex), thermalManager.degTargetHotend(uiCfg.extruderIndex));
   }
   #if HAS_HEATED_BED
     else {
       strcat(public_buf_l, preheat_menu.hotbed);
-      sprintf(buf, preheat_menu.value_state, (int)thermalManager.temp_bed.celsius, (int)thermalManager.temp_bed.target);
+      sprintf(buf, preheat_menu.value_state, thermalManager.degBed(), thermalManager.degTargetBed());
     }
   #endif
   strcat_P(public_buf_l, PSTR(": "));
   strcat(public_buf_l, buf);
   lv_label_set_text(tempText1, public_buf_l);
   lv_obj_align(tempText1, nullptr, LV_ALIGN_CENTER, 0, -50);
 }
 
 void disp_step_heat() {
   if (uiCfg.stepHeat == 1) {

commit 72cc5a49e6fdcf7246b6bded66a4b4fc043054a3
Author: Sola <42537573+solawc@users.noreply.github.com>
Date:   Sat Mar 6 23:04:05 2021 +0800

    MKS H43 fixup (#21267)
    
    Co-authored-by: makerbase <4164049@qq.com>
    Co-authored-by: MKS-Sean <56996910+MKS-Sean@users.noreply.github.com>
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
index f2fda3a286..73a0808e9c 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
@@ -41,109 +41,108 @@ enum {
   ID_P_DEC,
   ID_P_TYPE,
   ID_P_STEP,
   ID_P_OFF,
   ID_P_RETURN
 };
 
 static void event_handler(lv_obj_t *obj, lv_event_t event) {
   if (event != LV_EVENT_RELEASED) return;
   switch (obj->mks_obj_id) {
-    case ID_P_ADD:
+    case ID_P_ADD: {
       if (uiCfg.curTempType == 0) {
-        thermalManager.temp_hotend[uiCfg.curSprayerChoose].target += uiCfg.stepHeat;
-        if (uiCfg.curSprayerChoose == 0) {
-          if ((int)thermalManager.temp_hotend[uiCfg.curSprayerChoose].target > (HEATER_0_MAXTEMP - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1))) {
-            thermalManager.temp_hotend[uiCfg.curSprayerChoose].target = (float)HEATER_0_MAXTEMP - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1);
-          }
-        }
+        int16_t max_target;
+        thermalManager.temp_hotend[uiCfg.extruderIndex].target += uiCfg.stepHeat;
+        if (uiCfg.extruderIndex == 0)
+          max_target = HEATER_0_MAXTEMP - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1);
         #if HAS_MULTI_HOTEND
-          else if ((int)thermalManager.temp_hotend[uiCfg.curSprayerChoose].target > (HEATER_1_MAXTEMP - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1))) {
-            thermalManager.temp_hotend[uiCfg.curSprayerChoose].target = (float)HEATER_1_MAXTEMP - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1);
-          }
+          else
+            max_target = HEATER_1_MAXTEMP - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1);
         #endif
-        thermalManager.start_watching_hotend(uiCfg.curSprayerChoose);
+        if (thermalManager.degTargetHotend(uiCfg.extruderIndex) > max_target)
+          thermalManager.setTargetHotend(max_target, uiCfg.extruderIndex);
+        thermalManager.start_watching_hotend(uiCfg.extruderIndex);
       }
       #if HAS_HEATED_BED
         else {
+          constexpr int16_t max_target = BED_MAXTEMP - (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1);
           thermalManager.temp_bed.target += uiCfg.stepHeat;
-          if ((int)thermalManager.temp_bed.target > BED_MAXTEMP - (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1)) {
-            thermalManager.temp_bed.target = (float)BED_MAXTEMP - (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1);
-          }
+          if (thermalManager.degTargetBed() > max_target)
+            thermalManager.setTargetBed(max_target);
           thermalManager.start_watching_bed();
         }
       #endif
       disp_desire_temp();
-      break;
+    } break;
+
     case ID_P_DEC:
       if (uiCfg.curTempType == 0) {
-        if ((int)thermalManager.temp_hotend[uiCfg.curSprayerChoose].target > uiCfg.stepHeat)
-          thermalManager.temp_hotend[uiCfg.curSprayerChoose].target -= uiCfg.stepHeat;
+        if ((int)thermalManager.degTargetHotend(uiCfg.extruderIndex) > uiCfg.stepHeat)
+          thermalManager.temp_hotend[uiCfg.extruderIndex].target -= uiCfg.stepHeat;
         else
-          thermalManager.temp_hotend[uiCfg.curSprayerChoose].target = 0;
-
-        thermalManager.start_watching_hotend(uiCfg.curSprayerChoose);
+          thermalManager.setTargetHotend(0, uiCfg.extruderIndex);
+        thermalManager.start_watching_hotend(uiCfg.extruderIndex);
       }
       #if HAS_HEATED_BED
         else {
           if ((int)thermalManager.temp_bed.target > uiCfg.stepHeat)
             thermalManager.temp_bed.target -= uiCfg.stepHeat;
           else
-            thermalManager.temp_bed.target = 0;
+            thermalManager.setTargetBed(0);
 
           thermalManager.start_watching_bed();
         }
       #endif
       disp_desire_temp();
       break;
     case ID_P_TYPE:
       if (uiCfg.curTempType == 0) {
         if (ENABLED(HAS_MULTI_EXTRUDER)) {
-          if (uiCfg.curSprayerChoose == 0) {
-            uiCfg.curSprayerChoose = 1;
+          if (uiCfg.extruderIndex == 0) {
+            uiCfg.extruderIndex = 1;
           }
-          else if (uiCfg.curSprayerChoose == 1) {
+          else if (uiCfg.extruderIndex == 1) {
             if (TEMP_SENSOR_BED != 0) {
               uiCfg.curTempType = 1;
             }
             else {
               uiCfg.curTempType      = 0;
-              uiCfg.curSprayerChoose = 0;
+              uiCfg.extruderIndex = 0;
             }
           }
         }
-        else if (uiCfg.curSprayerChoose == 0) {
+        else if (uiCfg.extruderIndex == 0) {
           if (TEMP_SENSOR_BED != 0)
             uiCfg.curTempType = 1;
           else
             uiCfg.curTempType = 0;
         }
       }
       else if (uiCfg.curTempType == 1) {
-        uiCfg.curSprayerChoose = 0;
+        uiCfg.extruderIndex = 0;
         uiCfg.curTempType      = 0;
       }
       disp_temp_type();
       break;
     case ID_P_STEP:
       switch (uiCfg.stepHeat) {
         case  1: uiCfg.stepHeat =  5; break;
         case  5: uiCfg.stepHeat = 10; break;
         case 10: uiCfg.stepHeat =  1; break;
         default: break;
       }
       disp_step_heat();
       break;
     case ID_P_OFF:
       if (uiCfg.curTempType == 0) {
-        thermalManager.temp_hotend[uiCfg.curSprayerChoose].target = 0;
-        thermalManager.start_watching_hotend(uiCfg.curSprayerChoose);
+        thermalManager.setTargetHotend(0, uiCfg.extruderIndex);
+        thermalManager.start_watching_hotend(uiCfg.extruderIndex);
       }
       #if HAS_HEATED_BED
         else {
           thermalManager.temp_bed.target = 0;
           thermalManager.start_watching_bed();
         }
       #endif
       disp_desire_temp();
       break;
     case ID_P_RETURN:
@@ -179,21 +178,21 @@ void lv_draw_preHeat() {
   disp_temp_type();
   disp_step_heat();
 
   tempText1 = lv_label_create_empty(scr);
   lv_obj_set_style(tempText1, &tft_style_label_rel);
   disp_desire_temp();
 }
 
 void disp_temp_type() {
   if (uiCfg.curTempType == 0) {
-    if (uiCfg.curSprayerChoose == 1) {
+    if (uiCfg.extruderIndex == 1) {
     lv_imgbtn_set_src_both(buttonType, "F:/bmp_extru2.bin");
       if (gCfgItems.multiple_language) {
         lv_label_set_text(labelType, preheat_menu.ext2);
         lv_obj_align(labelType, buttonType, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
       }
     }
     else {
     lv_imgbtn_set_src_both(buttonType, "F:/bmp_extru1.bin");
       if (gCfgItems.multiple_language) {
         lv_label_set_text(labelType, preheat_menu.ext1);
@@ -210,27 +209,27 @@ void disp_temp_type() {
     }
   }
 }
 
 void disp_desire_temp() {
   char buf[20] = {0};
 
   public_buf_l[0] = '\0';
 
   if (uiCfg.curTempType == 0) {
-    strcat(public_buf_l, uiCfg.curSprayerChoose < 1 ? preheat_menu.ext1 : preheat_menu.ext2);
-    sprintf(buf, preheat_menu.value_state, (int)thermalManager.temp_hotend[uiCfg.curSprayerChoose].celsius,  (int)thermalManager.temp_hotend[uiCfg.curSprayerChoose].target);
+    strcat(public_buf_l, uiCfg.extruderIndex < 1 ? preheat_menu.ext1 : preheat_menu.ext2);
+    sprintf(buf, preheat_menu.value_state, (int)thermalManager.degHotend(uiCfg.extruderIndex), (int)thermalManager.degTargetHotend(uiCfg.extruderIndex));
   }
   #if HAS_HEATED_BED
     else {
       strcat(public_buf_l, preheat_menu.hotbed);
-      sprintf(buf, preheat_menu.value_state, (int)thermalManager.temp_bed.celsius,  (int)thermalManager.temp_bed.target);
+      sprintf(buf, preheat_menu.value_state, (int)thermalManager.temp_bed.celsius, (int)thermalManager.temp_bed.target);
     }
   #endif
   strcat_P(public_buf_l, PSTR(": "));
   strcat(public_buf_l, buf);
   lv_label_set_text(tempText1, public_buf_l);
   lv_obj_align(tempText1, nullptr, LV_ALIGN_CENTER, 0, -50);
 }
 
 void disp_step_heat() {
   if (uiCfg.stepHeat == 1) {

commit 57e4b82b66e0d98a370e1928a64840d2a9d5f501
Author: MKS-Sean <56996910+MKS-Sean@users.noreply.github.com>
Date:   Mon Feb 8 10:36:57 2021 +0800

    Fix: Unsupported use of %f in printf (#21001)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
index 273462ac90..f2fda3a286 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
@@ -49,21 +49,21 @@ static void event_handler(lv_obj_t *obj, lv_event_t event) {
   if (event != LV_EVENT_RELEASED) return;
   switch (obj->mks_obj_id) {
     case ID_P_ADD:
       if (uiCfg.curTempType == 0) {
         thermalManager.temp_hotend[uiCfg.curSprayerChoose].target += uiCfg.stepHeat;
         if (uiCfg.curSprayerChoose == 0) {
           if ((int)thermalManager.temp_hotend[uiCfg.curSprayerChoose].target > (HEATER_0_MAXTEMP - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1))) {
             thermalManager.temp_hotend[uiCfg.curSprayerChoose].target = (float)HEATER_0_MAXTEMP - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1);
           }
         }
-        #if DISABLED(SINGLENOZZLE) && HAS_MULTI_EXTRUDER
+        #if HAS_MULTI_HOTEND
           else if ((int)thermalManager.temp_hotend[uiCfg.curSprayerChoose].target > (HEATER_1_MAXTEMP - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1))) {
             thermalManager.temp_hotend[uiCfg.curSprayerChoose].target = (float)HEATER_1_MAXTEMP - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1);
           }
         #endif
         thermalManager.start_watching_hotend(uiCfg.curSprayerChoose);
       }
       #if HAS_HEATED_BED
         else {
           thermalManager.temp_bed.target += uiCfg.stepHeat;
           if ((int)thermalManager.temp_bed.target > BED_MAXTEMP - (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1)) {

commit b41f41589a1c9bbc1adc1ceffc42c0c87c805526
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jan 16 19:03:06 2021 -0600

    General cleanup, use _BV

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
index 43f82bca24..273462ac90 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
@@ -49,21 +49,21 @@ static void event_handler(lv_obj_t *obj, lv_event_t event) {
   if (event != LV_EVENT_RELEASED) return;
   switch (obj->mks_obj_id) {
     case ID_P_ADD:
       if (uiCfg.curTempType == 0) {
         thermalManager.temp_hotend[uiCfg.curSprayerChoose].target += uiCfg.stepHeat;
         if (uiCfg.curSprayerChoose == 0) {
           if ((int)thermalManager.temp_hotend[uiCfg.curSprayerChoose].target > (HEATER_0_MAXTEMP - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1))) {
             thermalManager.temp_hotend[uiCfg.curSprayerChoose].target = (float)HEATER_0_MAXTEMP - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1);
           }
         }
-        #if !defined(SINGLENOZZLE) && HAS_MULTI_EXTRUDER
+        #if DISABLED(SINGLENOZZLE) && HAS_MULTI_EXTRUDER
           else if ((int)thermalManager.temp_hotend[uiCfg.curSprayerChoose].target > (HEATER_1_MAXTEMP - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1))) {
             thermalManager.temp_hotend[uiCfg.curSprayerChoose].target = (float)HEATER_1_MAXTEMP - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1);
           }
         #endif
         thermalManager.start_watching_hotend(uiCfg.curSprayerChoose);
       }
       #if HAS_HEATED_BED
         else {
           thermalManager.temp_bed.target += uiCfg.stepHeat;
           if ((int)thermalManager.temp_bed.target > BED_MAXTEMP - (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1)) {

commit c753fc690f6cdd181213304224eee029988ffd34
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jan 14 00:23:56 2021 -0600

    More MKS UI prelim. cleanup

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
index e1d2aecbe0..43f82bca24 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
@@ -146,21 +146,21 @@ static void event_handler(lv_obj_t *obj, lv_event_t event) {
       #endif
       disp_desire_temp();
       break;
     case ID_P_RETURN:
       clear_cur_ui();
       draw_return_ui();
       break;
   }
 }
 
-void lv_draw_preHeat(void) {
+void lv_draw_preHeat() {
   scr = lv_screen_create(PRE_HEAT_UI);
 
   // Create image buttons
   lv_big_button_create(scr, "F:/bmp_Add.bin", preheat_menu.add, INTERVAL_V, titleHeight, event_handler, ID_P_ADD);
   lv_big_button_create(scr, "F:/bmp_Dec.bin", preheat_menu.dec, BTN_X_PIXEL * 3 + INTERVAL_V * 4, titleHeight, event_handler, ID_P_DEC);
 
   buttonType = lv_imgbtn_create(scr, nullptr, INTERVAL_V, BTN_Y_PIXEL + INTERVAL_H + titleHeight, event_handler, ID_P_TYPE);
   buttonStep = lv_imgbtn_create(scr, nullptr, BTN_X_PIXEL + INTERVAL_V * 2, BTN_Y_PIXEL + INTERVAL_H + titleHeight, event_handler, ID_P_STEP);
   #if HAS_ROTARY_ENCODER
     if (gCfgItems.encoder_enable) {

commit 44c57ab05a8f909b85f51e08c90316b41e50c455
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jan 12 21:02:35 2021 -0600

    MKS UI prelim. cleanup (#20763)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
index 0e869e67c4..e1d2aecbe0 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
@@ -18,24 +18,20 @@
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 #include "../../../../inc/MarlinConfigPre.h"
 
 #if HAS_TFT_LVGL_UI
 
 #include "draw_ui.h"
 #include <lv_conf.h>
-//#include "../lvgl/src/lv_objx/lv_imgbtn.h"
-//#include "../lvgl/src/lv_objx/lv_img.h"
-//#include "../lvgl/src/lv_core/lv_disp.h"
-//#include "../lvgl/src/lv_core/lv_refr.h"
 
 #include "../../../../module/temperature.h"
 #include "../../../../inc/MarlinConfig.h"
 
 static lv_obj_t *scr;
 extern lv_group_t*  g;
 static lv_obj_t *buttonType, *buttonStep;
 static lv_obj_t *labelType;
 static lv_obj_t *labelStep;
 static lv_obj_t *tempText1;

commit 853d01de683ab3efcbb15ef95db869e279053ee0
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Sat Oct 24 19:28:31 2020 -0300

    More LVGL UI code reduction (#19879)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
index a222c7adbf..0e869e67c4 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
@@ -151,31 +151,21 @@ static void event_handler(lv_obj_t *obj, lv_event_t event) {
       disp_desire_temp();
       break;
     case ID_P_RETURN:
       clear_cur_ui();
       draw_return_ui();
       break;
   }
 }
 
 void lv_draw_preHeat(void) {
-  if (disp_state_stack._disp_state[disp_state_stack._disp_index] != PRE_HEAT_UI) {
-    disp_state_stack._disp_index++;
-    disp_state_stack._disp_state[disp_state_stack._disp_index] = PRE_HEAT_UI;
-  }
-  disp_state = PRE_HEAT_UI;
-
-  scr = lv_screen_create();
-
-  (void)lv_label_create(scr, TITLE_XPOS, TITLE_YPOS, creat_title_text());
-
-  lv_refr_now(lv_refr_get_disp_refreshing());
+  scr = lv_screen_create(PRE_HEAT_UI);
 
   // Create image buttons
   lv_big_button_create(scr, "F:/bmp_Add.bin", preheat_menu.add, INTERVAL_V, titleHeight, event_handler, ID_P_ADD);
   lv_big_button_create(scr, "F:/bmp_Dec.bin", preheat_menu.dec, BTN_X_PIXEL * 3 + INTERVAL_V * 4, titleHeight, event_handler, ID_P_DEC);
 
   buttonType = lv_imgbtn_create(scr, nullptr, INTERVAL_V, BTN_Y_PIXEL + INTERVAL_H + titleHeight, event_handler, ID_P_TYPE);
   buttonStep = lv_imgbtn_create(scr, nullptr, BTN_X_PIXEL + INTERVAL_V * 2, BTN_Y_PIXEL + INTERVAL_H + titleHeight, event_handler, ID_P_STEP);
   #if HAS_ROTARY_ENCODER
     if (gCfgItems.encoder_enable) {
       lv_group_add_obj(g, buttonType);

commit 9630c2683c39468bf885c560a1768d8b377d9462
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Sat Oct 24 01:37:45 2020 -0300

    More MKS UI cleanup, optimization (#19869)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
index 966d85b6de..a222c7adbf 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
@@ -26,235 +26,177 @@
 #include "draw_ui.h"
 #include <lv_conf.h>
 //#include "../lvgl/src/lv_objx/lv_imgbtn.h"
 //#include "../lvgl/src/lv_objx/lv_img.h"
 //#include "../lvgl/src/lv_core/lv_disp.h"
 //#include "../lvgl/src/lv_core/lv_refr.h"
 
 #include "../../../../module/temperature.h"
 #include "../../../../inc/MarlinConfig.h"
 
-static lv_obj_t * scr;
+static lv_obj_t *scr;
 extern lv_group_t*  g;
 static lv_obj_t *buttonType, *buttonStep;
 static lv_obj_t *labelType;
 static lv_obj_t *labelStep;
-static lv_obj_t * tempText1;
+static lv_obj_t *tempText1;
 
-#define ID_P_ADD    1
-#define ID_P_DEC    2
-#define ID_P_TYPE   3
-#define ID_P_STEP   4
-#define ID_P_OFF    5
-#define ID_P_RETURN 6
+enum {
+  ID_P_ADD = 1,
+  ID_P_DEC,
+  ID_P_TYPE,
+  ID_P_STEP,
+  ID_P_OFF,
+  ID_P_RETURN
+};
 
-static void event_handler(lv_obj_t * obj, lv_event_t event) {
+static void event_handler(lv_obj_t *obj, lv_event_t event) {
+  if (event != LV_EVENT_RELEASED) return;
   switch (obj->mks_obj_id) {
     case ID_P_ADD:
-      if (event == LV_EVENT_CLICKED) {
-        // nothing to do
-      }
-      else if (event == LV_EVENT_RELEASED) {
-        if (uiCfg.curTempType == 0) {
-          thermalManager.temp_hotend[uiCfg.curSprayerChoose].target += uiCfg.stepHeat;
-          if (uiCfg.curSprayerChoose == 0) {
-            if ((int)thermalManager.temp_hotend[uiCfg.curSprayerChoose].target > (HEATER_0_MAXTEMP - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1))) {
-              thermalManager.temp_hotend[uiCfg.curSprayerChoose].target = (float)HEATER_0_MAXTEMP - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1);
-            }
+      if (uiCfg.curTempType == 0) {
+        thermalManager.temp_hotend[uiCfg.curSprayerChoose].target += uiCfg.stepHeat;
+        if (uiCfg.curSprayerChoose == 0) {
+          if ((int)thermalManager.temp_hotend[uiCfg.curSprayerChoose].target > (HEATER_0_MAXTEMP - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1))) {
+            thermalManager.temp_hotend[uiCfg.curSprayerChoose].target = (float)HEATER_0_MAXTEMP - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1);
           }
-          #if !defined(SINGLENOZZLE) && HAS_MULTI_EXTRUDER
-            else if ((int)thermalManager.temp_hotend[uiCfg.curSprayerChoose].target > (HEATER_1_MAXTEMP - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1))) {
-              thermalManager.temp_hotend[uiCfg.curSprayerChoose].target = (float)HEATER_1_MAXTEMP - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1);
-            }
-          #endif
-          thermalManager.start_watching_hotend(uiCfg.curSprayerChoose);
         }
-        #if HAS_HEATED_BED
-          else {
-            thermalManager.temp_bed.target += uiCfg.stepHeat;
-            if ((int)thermalManager.temp_bed.target > BED_MAXTEMP - (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1)) {
-              thermalManager.temp_bed.target = (float)BED_MAXTEMP - (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1);
-            }
-            thermalManager.start_watching_bed();
+        #if !defined(SINGLENOZZLE) && HAS_MULTI_EXTRUDER
+          else if ((int)thermalManager.temp_hotend[uiCfg.curSprayerChoose].target > (HEATER_1_MAXTEMP - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1))) {
+            thermalManager.temp_hotend[uiCfg.curSprayerChoose].target = (float)HEATER_1_MAXTEMP - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1);
           }
         #endif
-        disp_desire_temp();
+        thermalManager.start_watching_hotend(uiCfg.curSprayerChoose);
       }
-      break;
-    case ID_P_DEC:
-      if (event == LV_EVENT_CLICKED) {
-        // nothing to do
-      }
-      else if (event == LV_EVENT_RELEASED) {
-        if (uiCfg.curTempType == 0) {
-          if ((int)thermalManager.temp_hotend[uiCfg.curSprayerChoose].target > uiCfg.stepHeat) {
-            thermalManager.temp_hotend[uiCfg.curSprayerChoose].target -= uiCfg.stepHeat;
-          }
-          else {
-            thermalManager.temp_hotend[uiCfg.curSprayerChoose].target = (float)0;
+      #if HAS_HEATED_BED
+        else {
+          thermalManager.temp_bed.target += uiCfg.stepHeat;
+          if ((int)thermalManager.temp_bed.target > BED_MAXTEMP - (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1)) {
+            thermalManager.temp_bed.target = (float)BED_MAXTEMP - (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1);
           }
-          thermalManager.start_watching_hotend(uiCfg.curSprayerChoose);
+          thermalManager.start_watching_bed();
         }
-        #if HAS_HEATED_BED
-          else {
-            if ((int)thermalManager.temp_bed.target > uiCfg.stepHeat) {
-              thermalManager.temp_bed.target -= uiCfg.stepHeat;
-            }
-            else {
-              thermalManager.temp_bed.target = (float)0;
-            }
-            thermalManager.start_watching_bed();
-          }
-        #endif
-        disp_desire_temp();
+      #endif
+      disp_desire_temp();
+      break;
+    case ID_P_DEC:
+      if (uiCfg.curTempType == 0) {
+        if ((int)thermalManager.temp_hotend[uiCfg.curSprayerChoose].target > uiCfg.stepHeat)
+          thermalManager.temp_hotend[uiCfg.curSprayerChoose].target -= uiCfg.stepHeat;
+        else
+          thermalManager.temp_hotend[uiCfg.curSprayerChoose].target = 0;
+
+        thermalManager.start_watching_hotend(uiCfg.curSprayerChoose);
       }
+      #if HAS_HEATED_BED
+        else {
+          if ((int)thermalManager.temp_bed.target > uiCfg.stepHeat)
+            thermalManager.temp_bed.target -= uiCfg.stepHeat;
+          else
+            thermalManager.temp_bed.target = 0;
 
+          thermalManager.start_watching_bed();
+        }
+      #endif
+      disp_desire_temp();
       break;
     case ID_P_TYPE:
-      if (event == LV_EVENT_CLICKED) {
-        // nothing to do
-      }
-      else if (event == LV_EVENT_RELEASED) {
-        if (uiCfg.curTempType == 0) {
-          if (ENABLED(HAS_MULTI_EXTRUDER)) {
-            if (uiCfg.curSprayerChoose == 0) {
-              uiCfg.curSprayerChoose = 1;
-            }
-            else if (uiCfg.curSprayerChoose == 1) {
-              if (TEMP_SENSOR_BED != 0) {
-                uiCfg.curTempType = 1;
-              }
-              else {
-                uiCfg.curTempType      = 0;
-                uiCfg.curSprayerChoose = 0;
-              }
-            }
+      if (uiCfg.curTempType == 0) {
+        if (ENABLED(HAS_MULTI_EXTRUDER)) {
+          if (uiCfg.curSprayerChoose == 0) {
+            uiCfg.curSprayerChoose = 1;
           }
-          else if (uiCfg.curSprayerChoose == 0) {
-            if (TEMP_SENSOR_BED != 0)
+          else if (uiCfg.curSprayerChoose == 1) {
+            if (TEMP_SENSOR_BED != 0) {
               uiCfg.curTempType = 1;
-            else
-              uiCfg.curTempType = 0;
+            }
+            else {
+              uiCfg.curTempType      = 0;
+              uiCfg.curSprayerChoose = 0;
+            }
           }
         }
-        else if (uiCfg.curTempType == 1) {
-          uiCfg.curSprayerChoose = 0;
-          uiCfg.curTempType      = 0;
+        else if (uiCfg.curSprayerChoose == 0) {
+          if (TEMP_SENSOR_BED != 0)
+            uiCfg.curTempType = 1;
+          else
+            uiCfg.curTempType = 0;
         }
-        disp_temp_type();
       }
+      else if (uiCfg.curTempType == 1) {
+        uiCfg.curSprayerChoose = 0;
+        uiCfg.curTempType      = 0;
+      }
+      disp_temp_type();
       break;
     case ID_P_STEP:
-      if (event == LV_EVENT_CLICKED) {
-        // nothing to do
-      }
-      else if (event == LV_EVENT_RELEASED) {
-        switch (uiCfg.stepHeat) {
-          case  1: uiCfg.stepHeat =  5; break;
-          case  5: uiCfg.stepHeat = 10; break;
-          case 10: uiCfg.stepHeat =  1; break;
-          default: break;
-        }
-        disp_step_heat();
+      switch (uiCfg.stepHeat) {
+        case  1: uiCfg.stepHeat =  5; break;
+        case  5: uiCfg.stepHeat = 10; break;
+        case 10: uiCfg.stepHeat =  1; break;
+        default: break;
       }
+      disp_step_heat();
       break;
     case ID_P_OFF:
-      if (event == LV_EVENT_CLICKED) {
-        // nothing to do
+      if (uiCfg.curTempType == 0) {
+        thermalManager.temp_hotend[uiCfg.curSprayerChoose].target = 0;
+        thermalManager.start_watching_hotend(uiCfg.curSprayerChoose);
       }
-      else if (event == LV_EVENT_RELEASED) {
-        if (uiCfg.curTempType == 0) {
-          thermalManager.temp_hotend[uiCfg.curSprayerChoose].target = (float)0;
-          thermalManager.start_watching_hotend(uiCfg.curSprayerChoose);
+      #if HAS_HEATED_BED
+        else {
+          thermalManager.temp_bed.target = 0;
+          thermalManager.start_watching_bed();
         }
-        #if HAS_HEATED_BED
-          else {
-            thermalManager.temp_bed.target = (float)0;
-            thermalManager.start_watching_bed();
-          }
-        #endif
-        disp_desire_temp();
-      }
+      #endif
+      disp_desire_temp();
       break;
     case ID_P_RETURN:
-      if (event == LV_EVENT_CLICKED) {
-        // nothing to do
-      }
-      else if (event == LV_EVENT_RELEASED) {
-        clear_cur_ui();
-        draw_return_ui();
-      }
+      clear_cur_ui();
+      draw_return_ui();
       break;
   }
 }
 
 void lv_draw_preHeat(void) {
-  lv_obj_t *buttonAdd, *buttonDec;
-  lv_obj_t *buttonOff, *buttonBack;
-
   if (disp_state_stack._disp_state[disp_state_stack._disp_index] != PRE_HEAT_UI) {
     disp_state_stack._disp_index++;
     disp_state_stack._disp_state[disp_state_stack._disp_index] = PRE_HEAT_UI;
   }
   disp_state = PRE_HEAT_UI;
 
-  scr = lv_obj_create(NULL, NULL);
-
-  lv_obj_set_style(scr, &tft_style_scr);
-  lv_scr_load(scr);
-  lv_obj_clean(scr);
+  scr = lv_screen_create();
 
   (void)lv_label_create(scr, TITLE_XPOS, TITLE_YPOS, creat_title_text());
 
   lv_refr_now(lv_refr_get_disp_refreshing());
 
   // Create image buttons
-  buttonAdd = lv_imgbtn_create(scr, "F:/bmp_Add.bin", INTERVAL_V, titleHeight, event_handler, ID_P_ADD);
-  lv_obj_clear_protect(buttonAdd, LV_PROTECT_FOLLOW);
-  buttonDec = lv_imgbtn_create(scr, "F:/bmp_Dec.bin", BTN_X_PIXEL * 3 + INTERVAL_V * 4, titleHeight, event_handler, ID_P_DEC);
-  buttonType = lv_imgbtn_create(scr, NULL, INTERVAL_V, BTN_Y_PIXEL + INTERVAL_H + titleHeight, event_handler, ID_P_TYPE);
-  buttonStep = lv_imgbtn_create(scr, NULL, BTN_X_PIXEL + INTERVAL_V * 2, BTN_Y_PIXEL + INTERVAL_H + titleHeight, event_handler, ID_P_STEP);
-  buttonOff = lv_imgbtn_create(scr, "F:/bmp_speed0.bin", BTN_X_PIXEL * 2 + INTERVAL_V * 3, BTN_Y_PIXEL + INTERVAL_H + titleHeight, event_handler, ID_P_OFF);
-  buttonBack = lv_imgbtn_create(scr, "F:/bmp_return.bin", BTN_X_PIXEL * 3 + INTERVAL_V * 4, BTN_Y_PIXEL + INTERVAL_H + titleHeight, event_handler, ID_P_RETURN);
-
-  // Create labels on the image buttons
-  lv_obj_t *labelAdd = lv_label_create_empty(buttonAdd);
-  lv_obj_t *labelDec = lv_label_create_empty(buttonDec);
-  labelType = lv_label_create_empty(buttonType);
-  labelStep = lv_label_create_empty(buttonStep);
-  lv_obj_t *labelOff   = lv_label_create_empty(buttonOff);
-  lv_obj_t *label_Back = lv_label_create_empty(buttonBack);
-
-  if (gCfgItems.multiple_language) {
-    lv_label_set_text(labelAdd, preheat_menu.add);
-    lv_obj_align(labelAdd, buttonAdd, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
-
-    lv_label_set_text(labelDec, preheat_menu.dec);
-    lv_obj_align(labelDec, buttonDec, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
-
-    lv_label_set_text(labelOff, preheat_menu.off);
-    lv_obj_align(labelOff, buttonOff, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
+  lv_big_button_create(scr, "F:/bmp_Add.bin", preheat_menu.add, INTERVAL_V, titleHeight, event_handler, ID_P_ADD);
+  lv_big_button_create(scr, "F:/bmp_Dec.bin", preheat_menu.dec, BTN_X_PIXEL * 3 + INTERVAL_V * 4, titleHeight, event_handler, ID_P_DEC);
 
-    lv_label_set_text(label_Back, common_menu.text_back);
-    lv_obj_align(label_Back, buttonBack, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
-  }
+  buttonType = lv_imgbtn_create(scr, nullptr, INTERVAL_V, BTN_Y_PIXEL + INTERVAL_H + titleHeight, event_handler, ID_P_TYPE);
+  buttonStep = lv_imgbtn_create(scr, nullptr, BTN_X_PIXEL + INTERVAL_V * 2, BTN_Y_PIXEL + INTERVAL_H + titleHeight, event_handler, ID_P_STEP);
   #if HAS_ROTARY_ENCODER
     if (gCfgItems.encoder_enable) {
-      lv_group_add_obj(g, buttonAdd);
-      lv_group_add_obj(g, buttonDec);
       lv_group_add_obj(g, buttonType);
       lv_group_add_obj(g, buttonStep);
-      lv_group_add_obj(g, buttonOff);
-      lv_group_add_obj(g, buttonBack);
     }
   #endif
 
+  lv_big_button_create(scr, "F:/bmp_speed0.bin", preheat_menu.off, BTN_X_PIXEL * 2 + INTERVAL_V * 3, BTN_Y_PIXEL + INTERVAL_H + titleHeight, event_handler, ID_P_OFF);
+  lv_big_button_create(scr, "F:/bmp_return.bin", common_menu.text_back, BTN_X_PIXEL * 3 + INTERVAL_V * 4, BTN_Y_PIXEL + INTERVAL_H + titleHeight, event_handler, ID_P_RETURN);
+
+  // Create labels on the image buttons
+  labelType = lv_label_create_empty(buttonType);
+  labelStep = lv_label_create_empty(buttonStep);
+
   disp_temp_type();
   disp_step_heat();
 
   tempText1 = lv_label_create_empty(scr);
   lv_obj_set_style(tempText1, &tft_style_label_rel);
   disp_desire_temp();
 }
 
 void disp_temp_type() {
   if (uiCfg.curTempType == 0) {
@@ -282,36 +224,33 @@ void disp_temp_type() {
     }
   }
 }
 
 void disp_desire_temp() {
   char buf[20] = {0};
 
   public_buf_l[0] = '\0';
 
   if (uiCfg.curTempType == 0) {
-    if (uiCfg.curSprayerChoose < 1)
-      strcat(public_buf_l, preheat_menu.ext1);
-    else
-      strcat(public_buf_l, preheat_menu.ext2);
+    strcat(public_buf_l, uiCfg.curSprayerChoose < 1 ? preheat_menu.ext1 : preheat_menu.ext2);
     sprintf(buf, preheat_menu.value_state, (int)thermalManager.temp_hotend[uiCfg.curSprayerChoose].celsius,  (int)thermalManager.temp_hotend[uiCfg.curSprayerChoose].target);
   }
   #if HAS_HEATED_BED
     else {
       strcat(public_buf_l, preheat_menu.hotbed);
       sprintf(buf, preheat_menu.value_state, (int)thermalManager.temp_bed.celsius,  (int)thermalManager.temp_bed.target);
     }
   #endif
   strcat_P(public_buf_l, PSTR(": "));
   strcat(public_buf_l, buf);
   lv_label_set_text(tempText1, public_buf_l);
-  lv_obj_align(tempText1, NULL, LV_ALIGN_CENTER, 0, -50);
+  lv_obj_align(tempText1, nullptr, LV_ALIGN_CENTER, 0, -50);
 }
 
 void disp_step_heat() {
   if (uiCfg.stepHeat == 1) {
     lv_imgbtn_set_src_both(buttonStep, "F:/bmp_step1_degree.bin");
   }
   else if (uiCfg.stepHeat == 5) {
     lv_imgbtn_set_src_both(buttonStep, "F:/bmp_step5_degree.bin");
   }
   else if (uiCfg.stepHeat == 10) {

commit 4533a197d59ffcaccc4d476f06df7754b11b9b0c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Oct 22 20:22:17 2020 -0500

    Slim down MKS UI code (#19843)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
index b08c9bd947..966d85b6de 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
@@ -28,21 +28,21 @@
 //#include "../lvgl/src/lv_objx/lv_imgbtn.h"
 //#include "../lvgl/src/lv_objx/lv_img.h"
 //#include "../lvgl/src/lv_core/lv_disp.h"
 //#include "../lvgl/src/lv_core/lv_refr.h"
 
 #include "../../../../module/temperature.h"
 #include "../../../../inc/MarlinConfig.h"
 
 static lv_obj_t * scr;
 extern lv_group_t*  g;
-static lv_obj_t *buttoType, *buttonStep;
+static lv_obj_t *buttonType, *buttonStep;
 static lv_obj_t *labelType;
 static lv_obj_t *labelStep;
 static lv_obj_t * tempText1;
 
 #define ID_P_ADD    1
 #define ID_P_DEC    2
 #define ID_P_TYPE   3
 #define ID_P_STEP   4
 #define ID_P_OFF    5
 #define ID_P_RETURN 6
@@ -196,150 +196,96 @@ void lv_draw_preHeat(void) {
     disp_state_stack._disp_state[disp_state_stack._disp_index] = PRE_HEAT_UI;
   }
   disp_state = PRE_HEAT_UI;
 
   scr = lv_obj_create(NULL, NULL);
 
   lv_obj_set_style(scr, &tft_style_scr);
   lv_scr_load(scr);
   lv_obj_clean(scr);
 
-  lv_obj_t * title = lv_label_create(scr, NULL);
-  lv_obj_set_style(title, &tft_style_label_rel);
-  lv_obj_set_pos(title, TITLE_XPOS, TITLE_YPOS);
-  lv_label_set_text(title, creat_title_text());
+  (void)lv_label_create(scr, TITLE_XPOS, TITLE_YPOS, creat_title_text());
 
   lv_refr_now(lv_refr_get_disp_refreshing());
 
   // Create image buttons
-  buttonAdd  = lv_imgbtn_create(scr, NULL);
-  buttonDec  = lv_imgbtn_create(scr, NULL);
-  buttoType  = lv_imgbtn_create(scr, NULL);
-  buttonStep = lv_imgbtn_create(scr, NULL);
-  buttonOff  = lv_imgbtn_create(scr, NULL);
-  buttonBack = lv_imgbtn_create(scr, NULL);
-
-  lv_obj_set_event_cb_mks(buttonAdd, event_handler, ID_P_ADD, NULL, 0);
-  lv_imgbtn_set_src(buttonAdd, LV_BTN_STATE_REL, "F:/bmp_Add.bin");
-  lv_imgbtn_set_src(buttonAdd, LV_BTN_STATE_PR, "F:/bmp_Add.bin");
-  lv_imgbtn_set_style(buttonAdd, LV_BTN_STATE_PR, &tft_style_label_pre);
-  lv_imgbtn_set_style(buttonAdd, LV_BTN_STATE_REL, &tft_style_label_rel);
+  buttonAdd = lv_imgbtn_create(scr, "F:/bmp_Add.bin", INTERVAL_V, titleHeight, event_handler, ID_P_ADD);
   lv_obj_clear_protect(buttonAdd, LV_PROTECT_FOLLOW);
-
-  #if 1
-    lv_obj_set_event_cb_mks(buttonDec, event_handler, ID_P_DEC, NULL, 0);
-    lv_imgbtn_set_src(buttonDec, LV_BTN_STATE_REL, "F:/bmp_Dec.bin");
-    lv_imgbtn_set_src(buttonDec, LV_BTN_STATE_PR, "F:/bmp_Dec.bin");
-    lv_imgbtn_set_style(buttonDec, LV_BTN_STATE_PR, &tft_style_label_pre);
-    lv_imgbtn_set_style(buttonDec, LV_BTN_STATE_REL, &tft_style_label_rel);
-
-    lv_obj_set_event_cb_mks(buttoType, event_handler, ID_P_TYPE, NULL, 0);
-    lv_imgbtn_set_style(buttoType, LV_BTN_STATE_PR, &tft_style_label_pre);
-    lv_imgbtn_set_style(buttoType, LV_BTN_STATE_REL, &tft_style_label_rel);
-
-    lv_obj_set_event_cb_mks(buttonStep, event_handler, ID_P_STEP, NULL, 0);
-    lv_imgbtn_set_style(buttonStep, LV_BTN_STATE_PR, &tft_style_label_pre);
-    lv_imgbtn_set_style(buttonStep, LV_BTN_STATE_REL, &tft_style_label_rel);
-
-    lv_obj_set_event_cb_mks(buttonOff, event_handler, ID_P_OFF, NULL, 0);
-    lv_imgbtn_set_src(buttonOff, LV_BTN_STATE_REL, "F:/bmp_speed0.bin");
-    lv_imgbtn_set_src(buttonOff, LV_BTN_STATE_PR, "F:/bmp_speed0.bin");
-    lv_imgbtn_set_style(buttonOff, LV_BTN_STATE_PR, &tft_style_label_pre);
-    lv_imgbtn_set_style(buttonOff, LV_BTN_STATE_REL, &tft_style_label_rel);
-
-    lv_obj_set_event_cb_mks(buttonBack, event_handler, ID_P_RETURN, NULL, 0);
-    lv_imgbtn_set_src(buttonBack, LV_BTN_STATE_REL, "F:/bmp_return.bin");
-    lv_imgbtn_set_src(buttonBack, LV_BTN_STATE_PR, "F:/bmp_return.bin");
-    lv_imgbtn_set_style(buttonBack, LV_BTN_STATE_PR, &tft_style_label_pre);
-    lv_imgbtn_set_style(buttonBack, LV_BTN_STATE_REL, &tft_style_label_rel);
-  #endif
-
-  lv_obj_set_pos(buttonAdd, INTERVAL_V, titleHeight);
-  lv_obj_set_pos(buttonDec, BTN_X_PIXEL * 3 + INTERVAL_V * 4, titleHeight);
-  lv_obj_set_pos(buttoType, INTERVAL_V, BTN_Y_PIXEL + INTERVAL_H + titleHeight);
-  lv_obj_set_pos(buttonStep, BTN_X_PIXEL + INTERVAL_V * 2, BTN_Y_PIXEL + INTERVAL_H + titleHeight);
-  lv_obj_set_pos(buttonOff, BTN_X_PIXEL * 2 + INTERVAL_V * 3, BTN_Y_PIXEL + INTERVAL_H + titleHeight);
-  lv_obj_set_pos(buttonBack, BTN_X_PIXEL * 3 + INTERVAL_V * 4, BTN_Y_PIXEL + INTERVAL_H + titleHeight);
+  buttonDec = lv_imgbtn_create(scr, "F:/bmp_Dec.bin", BTN_X_PIXEL * 3 + INTERVAL_V * 4, titleHeight, event_handler, ID_P_DEC);
+  buttonType = lv_imgbtn_create(scr, NULL, INTERVAL_V, BTN_Y_PIXEL + INTERVAL_H + titleHeight, event_handler, ID_P_TYPE);
+  buttonStep = lv_imgbtn_create(scr, NULL, BTN_X_PIXEL + INTERVAL_V * 2, BTN_Y_PIXEL + INTERVAL_H + titleHeight, event_handler, ID_P_STEP);
+  buttonOff = lv_imgbtn_create(scr, "F:/bmp_speed0.bin", BTN_X_PIXEL * 2 + INTERVAL_V * 3, BTN_Y_PIXEL + INTERVAL_H + titleHeight, event_handler, ID_P_OFF);
+  buttonBack = lv_imgbtn_create(scr, "F:/bmp_return.bin", BTN_X_PIXEL * 3 + INTERVAL_V * 4, BTN_Y_PIXEL + INTERVAL_H + titleHeight, event_handler, ID_P_RETURN);
 
   // Create labels on the image buttons
-  lv_btn_set_layout(buttonAdd, LV_LAYOUT_OFF);
-  lv_btn_set_layout(buttonDec, LV_LAYOUT_OFF);
-  lv_btn_set_layout(buttoType, LV_LAYOUT_OFF);
-  lv_btn_set_layout(buttonStep, LV_LAYOUT_OFF);
-  lv_btn_set_layout(buttonOff, LV_LAYOUT_OFF);
-  lv_btn_set_layout(buttonBack, LV_LAYOUT_OFF);
-
-  lv_obj_t *labelAdd = lv_label_create(buttonAdd, NULL);
-  lv_obj_t *labelDec = lv_label_create(buttonDec, NULL);
-  labelType = lv_label_create(buttoType, NULL);
-  labelStep = lv_label_create(buttonStep, NULL);
-  lv_obj_t *labelOff   = lv_label_create(buttonOff, NULL);
-  lv_obj_t *label_Back = lv_label_create(buttonBack, NULL);
+  lv_obj_t *labelAdd = lv_label_create_empty(buttonAdd);
+  lv_obj_t *labelDec = lv_label_create_empty(buttonDec);
+  labelType = lv_label_create_empty(buttonType);
+  labelStep = lv_label_create_empty(buttonStep);
+  lv_obj_t *labelOff   = lv_label_create_empty(buttonOff);
+  lv_obj_t *label_Back = lv_label_create_empty(buttonBack);
 
   if (gCfgItems.multiple_language) {
     lv_label_set_text(labelAdd, preheat_menu.add);
     lv_obj_align(labelAdd, buttonAdd, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
 
     lv_label_set_text(labelDec, preheat_menu.dec);
     lv_obj_align(labelDec, buttonDec, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
 
     lv_label_set_text(labelOff, preheat_menu.off);
     lv_obj_align(labelOff, buttonOff, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
 
     lv_label_set_text(label_Back, common_menu.text_back);
     lv_obj_align(label_Back, buttonBack, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
   }
   #if HAS_ROTARY_ENCODER
     if (gCfgItems.encoder_enable) {
       lv_group_add_obj(g, buttonAdd);
       lv_group_add_obj(g, buttonDec);
-      lv_group_add_obj(g, buttoType);
+      lv_group_add_obj(g, buttonType);
       lv_group_add_obj(g, buttonStep);
       lv_group_add_obj(g, buttonOff);
       lv_group_add_obj(g, buttonBack);
     }
   #endif
 
   disp_temp_type();
   disp_step_heat();
 
-  tempText1 = lv_label_create(scr, NULL);
+  tempText1 = lv_label_create_empty(scr);
   lv_obj_set_style(tempText1, &tft_style_label_rel);
   disp_desire_temp();
 }
 
 void disp_temp_type() {
   if (uiCfg.curTempType == 0) {
     if (uiCfg.curSprayerChoose == 1) {
-    lv_imgbtn_set_src(buttoType, LV_BTN_STATE_REL, "F:/bmp_extru2.bin");
-      lv_imgbtn_set_src(buttoType, LV_BTN_STATE_PR, "F:/bmp_extru2.bin");
+    lv_imgbtn_set_src_both(buttonType, "F:/bmp_extru2.bin");
       if (gCfgItems.multiple_language) {
         lv_label_set_text(labelType, preheat_menu.ext2);
-        lv_obj_align(labelType, buttoType, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
+        lv_obj_align(labelType, buttonType, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
       }
     }
     else {
-    lv_imgbtn_set_src(buttoType, LV_BTN_STATE_REL, "F:/bmp_extru1.bin");
-      lv_imgbtn_set_src(buttoType, LV_BTN_STATE_PR, "F:/bmp_extru1.bin");
+    lv_imgbtn_set_src_both(buttonType, "F:/bmp_extru1.bin");
       if (gCfgItems.multiple_language) {
         lv_label_set_text(labelType, preheat_menu.ext1);
-        lv_obj_align(labelType, buttoType, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
+        lv_obj_align(labelType, buttonType, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
       }
     }
 
   }
   else {
-  lv_imgbtn_set_src(buttoType, LV_BTN_STATE_REL, "F:/bmp_bed.bin");
-      lv_imgbtn_set_src(buttoType, LV_BTN_STATE_PR, "F:/bmp_bed.bin");
+  lv_imgbtn_set_src_both(buttonType, "F:/bmp_bed.bin");
     if (gCfgItems.multiple_language) {
       lv_label_set_text(labelType, preheat_menu.hotbed);
-      lv_obj_align(labelType, buttoType, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
+      lv_obj_align(labelType, buttonType, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
     }
   }
 }
 
 void disp_desire_temp() {
   char buf[20] = {0};
 
   public_buf_l[0] = '\0';
 
   if (uiCfg.curTempType == 0) {
@@ -356,30 +302,27 @@ void disp_desire_temp() {
     }
   #endif
   strcat_P(public_buf_l, PSTR(": "));
   strcat(public_buf_l, buf);
   lv_label_set_text(tempText1, public_buf_l);
   lv_obj_align(tempText1, NULL, LV_ALIGN_CENTER, 0, -50);
 }
 
 void disp_step_heat() {
   if (uiCfg.stepHeat == 1) {
-    lv_imgbtn_set_src(buttonStep, LV_BTN_STATE_REL, "F:/bmp_step1_degree.bin");
-    lv_imgbtn_set_src(buttonStep, LV_BTN_STATE_PR, "F:/bmp_step1_degree.bin");
+    lv_imgbtn_set_src_both(buttonStep, "F:/bmp_step1_degree.bin");
   }
   else if (uiCfg.stepHeat == 5) {
-    lv_imgbtn_set_src(buttonStep, LV_BTN_STATE_REL, "F:/bmp_step5_degree.bin");
-    lv_imgbtn_set_src(buttonStep, LV_BTN_STATE_PR, "F:/bmp_step5_degree.bin");
+    lv_imgbtn_set_src_both(buttonStep, "F:/bmp_step5_degree.bin");
   }
   else if (uiCfg.stepHeat == 10) {
-    lv_imgbtn_set_src(buttonStep, LV_BTN_STATE_REL, "F:/bmp_step10_degree.bin");
-    lv_imgbtn_set_src(buttonStep, LV_BTN_STATE_PR, "F:/bmp_step10_degree.bin");
+    lv_imgbtn_set_src_both(buttonStep, "F:/bmp_step10_degree.bin");
   }
 
   if (gCfgItems.multiple_language) {
     if (uiCfg.stepHeat == 1) {
       lv_label_set_text(labelStep, preheat_menu.step_1c);
       lv_obj_align(labelStep, buttonStep, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
     }
     else if (uiCfg.stepHeat == 5) {
       lv_label_set_text(labelStep, preheat_menu.step_5c);
       lv_obj_align(labelStep, buttonStep, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);

commit 072f996af70b5ac635893eca2d4bd4bbb4f00acc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Oct 21 12:45:27 2020 -0500

    General cleanup, mostly MKS UI (#19825)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
index f58a47b341..b08c9bd947 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
@@ -16,29 +16,29 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 #include "../../../../inc/MarlinConfigPre.h"
 
 #if HAS_TFT_LVGL_UI
 
-#include "lv_conf.h"
 #include "draw_ui.h"
+#include <lv_conf.h>
 //#include "../lvgl/src/lv_objx/lv_imgbtn.h"
 //#include "../lvgl/src/lv_objx/lv_img.h"
 //#include "../lvgl/src/lv_core/lv_disp.h"
 //#include "../lvgl/src/lv_core/lv_refr.h"
 
-#include "../../../../MarlinCore.h"
 #include "../../../../module/temperature.h"
+#include "../../../../inc/MarlinConfig.h"
 
 static lv_obj_t * scr;
 extern lv_group_t*  g;
 static lv_obj_t *buttoType, *buttonStep;
 static lv_obj_t *labelType;
 static lv_obj_t *labelStep;
 static lv_obj_t * tempText1;
 
 #define ID_P_ADD    1
 #define ID_P_DEC    2
@@ -268,21 +268,21 @@ void lv_draw_preHeat(void) {
   lv_btn_set_layout(buttonOff, LV_LAYOUT_OFF);
   lv_btn_set_layout(buttonBack, LV_LAYOUT_OFF);
 
   lv_obj_t *labelAdd = lv_label_create(buttonAdd, NULL);
   lv_obj_t *labelDec = lv_label_create(buttonDec, NULL);
   labelType = lv_label_create(buttoType, NULL);
   labelStep = lv_label_create(buttonStep, NULL);
   lv_obj_t *labelOff   = lv_label_create(buttonOff, NULL);
   lv_obj_t *label_Back = lv_label_create(buttonBack, NULL);
 
-  if (gCfgItems.multiple_language != 0) {
+  if (gCfgItems.multiple_language) {
     lv_label_set_text(labelAdd, preheat_menu.add);
     lv_obj_align(labelAdd, buttonAdd, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
 
     lv_label_set_text(labelDec, preheat_menu.dec);
     lv_obj_align(labelDec, buttonDec, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
 
     lv_label_set_text(labelOff, preheat_menu.off);
     lv_obj_align(labelOff, buttonOff, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
 
     lv_label_set_text(label_Back, common_menu.text_back);
@@ -305,39 +305,39 @@ void lv_draw_preHeat(void) {
   tempText1 = lv_label_create(scr, NULL);
   lv_obj_set_style(tempText1, &tft_style_label_rel);
   disp_desire_temp();
 }
 
 void disp_temp_type() {
   if (uiCfg.curTempType == 0) {
     if (uiCfg.curSprayerChoose == 1) {
     lv_imgbtn_set_src(buttoType, LV_BTN_STATE_REL, "F:/bmp_extru2.bin");
       lv_imgbtn_set_src(buttoType, LV_BTN_STATE_PR, "F:/bmp_extru2.bin");
-      if (gCfgItems.multiple_language != 0) {
+      if (gCfgItems.multiple_language) {
         lv_label_set_text(labelType, preheat_menu.ext2);
         lv_obj_align(labelType, buttoType, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
       }
     }
     else {
     lv_imgbtn_set_src(buttoType, LV_BTN_STATE_REL, "F:/bmp_extru1.bin");
       lv_imgbtn_set_src(buttoType, LV_BTN_STATE_PR, "F:/bmp_extru1.bin");
-      if (gCfgItems.multiple_language != 0) {
+      if (gCfgItems.multiple_language) {
         lv_label_set_text(labelType, preheat_menu.ext1);
         lv_obj_align(labelType, buttoType, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
       }
     }
 
   }
   else {
   lv_imgbtn_set_src(buttoType, LV_BTN_STATE_REL, "F:/bmp_bed.bin");
       lv_imgbtn_set_src(buttoType, LV_BTN_STATE_PR, "F:/bmp_bed.bin");
-    if (gCfgItems.multiple_language != 0) {
+    if (gCfgItems.multiple_language) {
       lv_label_set_text(labelType, preheat_menu.hotbed);
       lv_obj_align(labelType, buttoType, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
     }
   }
 }
 
 void disp_desire_temp() {
   char buf[20] = {0};
 
   public_buf_l[0] = '\0';
@@ -368,21 +368,21 @@ void disp_step_heat() {
   }
   else if (uiCfg.stepHeat == 5) {
     lv_imgbtn_set_src(buttonStep, LV_BTN_STATE_REL, "F:/bmp_step5_degree.bin");
     lv_imgbtn_set_src(buttonStep, LV_BTN_STATE_PR, "F:/bmp_step5_degree.bin");
   }
   else if (uiCfg.stepHeat == 10) {
     lv_imgbtn_set_src(buttonStep, LV_BTN_STATE_REL, "F:/bmp_step10_degree.bin");
     lv_imgbtn_set_src(buttonStep, LV_BTN_STATE_PR, "F:/bmp_step10_degree.bin");
   }
 
-  if (gCfgItems.multiple_language != 0) {
+  if (gCfgItems.multiple_language) {
     if (uiCfg.stepHeat == 1) {
       lv_label_set_text(labelStep, preheat_menu.step_1c);
       lv_obj_align(labelStep, buttonStep, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
     }
     else if (uiCfg.stepHeat == 5) {
       lv_label_set_text(labelStep, preheat_menu.step_5c);
       lv_obj_align(labelStep, buttonStep, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
     }
     else if (uiCfg.stepHeat == 10) {
       lv_label_set_text(labelStep, preheat_menu.step_10c);

commit d8ed74904559aa8bdccc8b68acbccfbf1bf779d3
Author: makerbase <4164049@qq.com>
Date:   Mon Sep 21 09:55:02 2020 +0800

    Add MKS Robin E3P, improve LVGL UI (#19442)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
index ff7641ddfd..f58a47b341 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
@@ -27,23 +27,24 @@
 #include "draw_ui.h"
 //#include "../lvgl/src/lv_objx/lv_imgbtn.h"
 //#include "../lvgl/src/lv_objx/lv_img.h"
 //#include "../lvgl/src/lv_core/lv_disp.h"
 //#include "../lvgl/src/lv_core/lv_refr.h"
 
 #include "../../../../MarlinCore.h"
 #include "../../../../module/temperature.h"
 
 static lv_obj_t * scr;
+extern lv_group_t*  g;
 static lv_obj_t *buttoType, *buttonStep;
-static lv_obj_t * labelType;
-static lv_obj_t * labelStep;
+static lv_obj_t *labelType;
+static lv_obj_t *labelStep;
 static lv_obj_t * tempText1;
 
 #define ID_P_ADD    1
 #define ID_P_DEC    2
 #define ID_P_TYPE   3
 #define ID_P_STEP   4
 #define ID_P_OFF    5
 #define ID_P_RETURN 6
 
 static void event_handler(lv_obj_t * obj, lv_event_t event) {
@@ -51,67 +52,64 @@ static void event_handler(lv_obj_t * obj, lv_event_t event) {
     case ID_P_ADD:
       if (event == LV_EVENT_CLICKED) {
         // nothing to do
       }
       else if (event == LV_EVENT_RELEASED) {
         if (uiCfg.curTempType == 0) {
           thermalManager.temp_hotend[uiCfg.curSprayerChoose].target += uiCfg.stepHeat;
           if (uiCfg.curSprayerChoose == 0) {
             if ((int)thermalManager.temp_hotend[uiCfg.curSprayerChoose].target > (HEATER_0_MAXTEMP - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1))) {
               thermalManager.temp_hotend[uiCfg.curSprayerChoose].target = (float)HEATER_0_MAXTEMP - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1);
-              thermalManager.start_watching_hotend(uiCfg.curSprayerChoose);
             }
           }
           #if !defined(SINGLENOZZLE) && HAS_MULTI_EXTRUDER
             else if ((int)thermalManager.temp_hotend[uiCfg.curSprayerChoose].target > (HEATER_1_MAXTEMP - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1))) {
               thermalManager.temp_hotend[uiCfg.curSprayerChoose].target = (float)HEATER_1_MAXTEMP - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1);
-              thermalManager.start_watching_hotend(uiCfg.curSprayerChoose);
             }
           #endif
+          thermalManager.start_watching_hotend(uiCfg.curSprayerChoose);
         }
         #if HAS_HEATED_BED
           else {
             thermalManager.temp_bed.target += uiCfg.stepHeat;
             if ((int)thermalManager.temp_bed.target > BED_MAXTEMP - (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1)) {
               thermalManager.temp_bed.target = (float)BED_MAXTEMP - (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1);
-              thermalManager.start_watching_bed();
             }
+            thermalManager.start_watching_bed();
           }
         #endif
         disp_desire_temp();
       }
       break;
     case ID_P_DEC:
       if (event == LV_EVENT_CLICKED) {
         // nothing to do
       }
       else if (event == LV_EVENT_RELEASED) {
         if (uiCfg.curTempType == 0) {
           if ((int)thermalManager.temp_hotend[uiCfg.curSprayerChoose].target > uiCfg.stepHeat) {
             thermalManager.temp_hotend[uiCfg.curSprayerChoose].target -= uiCfg.stepHeat;
-            thermalManager.start_watching_hotend(uiCfg.curSprayerChoose);
           }
           else {
             thermalManager.temp_hotend[uiCfg.curSprayerChoose].target = (float)0;
-            thermalManager.start_watching_hotend(uiCfg.curSprayerChoose);
           }
+          thermalManager.start_watching_hotend(uiCfg.curSprayerChoose);
         }
         #if HAS_HEATED_BED
           else {
             if ((int)thermalManager.temp_bed.target > uiCfg.stepHeat) {
               thermalManager.temp_bed.target -= uiCfg.stepHeat;
-              thermalManager.start_watching_bed();
             }
             else {
               thermalManager.temp_bed.target = (float)0;
-              thermalManager.start_watching_bed();
             }
+            thermalManager.start_watching_bed();
           }
         #endif
         disp_desire_temp();
       }
 
       break;
     case ID_P_TYPE:
       if (event == LV_EVENT_CLICKED) {
         // nothing to do
       }
@@ -205,64 +203,59 @@ void lv_draw_preHeat(void) {
   lv_scr_load(scr);
   lv_obj_clean(scr);
 
   lv_obj_t * title = lv_label_create(scr, NULL);
   lv_obj_set_style(title, &tft_style_label_rel);
   lv_obj_set_pos(title, TITLE_XPOS, TITLE_YPOS);
   lv_label_set_text(title, creat_title_text());
 
   lv_refr_now(lv_refr_get_disp_refreshing());
 
-  LV_IMG_DECLARE(bmp_pic);
-
-  /*Create an Image button*/
+  // Create image buttons
   buttonAdd  = lv_imgbtn_create(scr, NULL);
   buttonDec  = lv_imgbtn_create(scr, NULL);
   buttoType  = lv_imgbtn_create(scr, NULL);
   buttonStep = lv_imgbtn_create(scr, NULL);
   buttonOff  = lv_imgbtn_create(scr, NULL);
   buttonBack = lv_imgbtn_create(scr, NULL);
 
-  lv_obj_set_event_cb_mks(buttonAdd, event_handler, ID_P_ADD, "bmp_Add.bin", 0);
-  lv_imgbtn_set_src(buttonAdd, LV_BTN_STATE_REL, &bmp_pic);
-  lv_imgbtn_set_src(buttonAdd, LV_BTN_STATE_PR, &bmp_pic);
+  lv_obj_set_event_cb_mks(buttonAdd, event_handler, ID_P_ADD, NULL, 0);
+  lv_imgbtn_set_src(buttonAdd, LV_BTN_STATE_REL, "F:/bmp_Add.bin");
+  lv_imgbtn_set_src(buttonAdd, LV_BTN_STATE_PR, "F:/bmp_Add.bin");
   lv_imgbtn_set_style(buttonAdd, LV_BTN_STATE_PR, &tft_style_label_pre);
   lv_imgbtn_set_style(buttonAdd, LV_BTN_STATE_REL, &tft_style_label_rel);
   lv_obj_clear_protect(buttonAdd, LV_PROTECT_FOLLOW);
+
   #if 1
-    lv_obj_set_event_cb_mks(buttonDec, event_handler, ID_P_DEC, "bmp_Dec.bin", 0);
-    lv_imgbtn_set_src(buttonDec, LV_BTN_STATE_REL, &bmp_pic);
-    lv_imgbtn_set_src(buttonDec, LV_BTN_STATE_PR, &bmp_pic);
+    lv_obj_set_event_cb_mks(buttonDec, event_handler, ID_P_DEC, NULL, 0);
+    lv_imgbtn_set_src(buttonDec, LV_BTN_STATE_REL, "F:/bmp_Dec.bin");
+    lv_imgbtn_set_src(buttonDec, LV_BTN_STATE_PR, "F:/bmp_Dec.bin");
     lv_imgbtn_set_style(buttonDec, LV_BTN_STATE_PR, &tft_style_label_pre);
     lv_imgbtn_set_style(buttonDec, LV_BTN_STATE_REL, &tft_style_label_rel);
 
-
-    lv_imgbtn_set_src(buttoType, LV_BTN_STATE_REL, &bmp_pic);
-    lv_imgbtn_set_src(buttoType, LV_BTN_STATE_PR, &bmp_pic);
+    lv_obj_set_event_cb_mks(buttoType, event_handler, ID_P_TYPE, NULL, 0);
     lv_imgbtn_set_style(buttoType, LV_BTN_STATE_PR, &tft_style_label_pre);
     lv_imgbtn_set_style(buttoType, LV_BTN_STATE_REL, &tft_style_label_rel);
 
-
-    lv_imgbtn_set_src(buttonStep, LV_BTN_STATE_REL, &bmp_pic);
-    lv_imgbtn_set_src(buttonStep, LV_BTN_STATE_PR, &bmp_pic);
+    lv_obj_set_event_cb_mks(buttonStep, event_handler, ID_P_STEP, NULL, 0);
     lv_imgbtn_set_style(buttonStep, LV_BTN_STATE_PR, &tft_style_label_pre);
     lv_imgbtn_set_style(buttonStep, LV_BTN_STATE_REL, &tft_style_label_rel);
 
-    lv_obj_set_event_cb_mks(buttonOff, event_handler, ID_P_OFF, "bmp_speed0.bin", 0);
-    lv_imgbtn_set_src(buttonOff, LV_BTN_STATE_REL, &bmp_pic);
-    lv_imgbtn_set_src(buttonOff, LV_BTN_STATE_PR, &bmp_pic);
+    lv_obj_set_event_cb_mks(buttonOff, event_handler, ID_P_OFF, NULL, 0);
+    lv_imgbtn_set_src(buttonOff, LV_BTN_STATE_REL, "F:/bmp_speed0.bin");
+    lv_imgbtn_set_src(buttonOff, LV_BTN_STATE_PR, "F:/bmp_speed0.bin");
     lv_imgbtn_set_style(buttonOff, LV_BTN_STATE_PR, &tft_style_label_pre);
     lv_imgbtn_set_style(buttonOff, LV_BTN_STATE_REL, &tft_style_label_rel);
 
-    lv_obj_set_event_cb_mks(buttonBack, event_handler, ID_P_RETURN, "bmp_return.bin", 0);
-    lv_imgbtn_set_src(buttonBack, LV_BTN_STATE_REL, &bmp_pic);
-    lv_imgbtn_set_src(buttonBack, LV_BTN_STATE_PR, &bmp_pic);
+    lv_obj_set_event_cb_mks(buttonBack, event_handler, ID_P_RETURN, NULL, 0);
+    lv_imgbtn_set_src(buttonBack, LV_BTN_STATE_REL, "F:/bmp_return.bin");
+    lv_imgbtn_set_src(buttonBack, LV_BTN_STATE_PR, "F:/bmp_return.bin");
     lv_imgbtn_set_style(buttonBack, LV_BTN_STATE_PR, &tft_style_label_pre);
     lv_imgbtn_set_style(buttonBack, LV_BTN_STATE_REL, &tft_style_label_rel);
   #endif
 
   lv_obj_set_pos(buttonAdd, INTERVAL_V, titleHeight);
   lv_obj_set_pos(buttonDec, BTN_X_PIXEL * 3 + INTERVAL_V * 4, titleHeight);
   lv_obj_set_pos(buttoType, INTERVAL_V, BTN_Y_PIXEL + INTERVAL_H + titleHeight);
   lv_obj_set_pos(buttonStep, BTN_X_PIXEL + INTERVAL_V * 2, BTN_Y_PIXEL + INTERVAL_H + titleHeight);
   lv_obj_set_pos(buttonOff, BTN_X_PIXEL * 2 + INTERVAL_V * 3, BTN_Y_PIXEL + INTERVAL_H + titleHeight);
   lv_obj_set_pos(buttonBack, BTN_X_PIXEL * 3 + INTERVAL_V * 4, BTN_Y_PIXEL + INTERVAL_H + titleHeight);
@@ -288,49 +281,62 @@ void lv_draw_preHeat(void) {
 
     lv_label_set_text(labelDec, preheat_menu.dec);
     lv_obj_align(labelDec, buttonDec, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
 
     lv_label_set_text(labelOff, preheat_menu.off);
     lv_obj_align(labelOff, buttonOff, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
 
     lv_label_set_text(label_Back, common_menu.text_back);
     lv_obj_align(label_Back, buttonBack, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
   }
+  #if HAS_ROTARY_ENCODER
+    if (gCfgItems.encoder_enable) {
+      lv_group_add_obj(g, buttonAdd);
+      lv_group_add_obj(g, buttonDec);
+      lv_group_add_obj(g, buttoType);
+      lv_group_add_obj(g, buttonStep);
+      lv_group_add_obj(g, buttonOff);
+      lv_group_add_obj(g, buttonBack);
+    }
+  #endif
 
   disp_temp_type();
   disp_step_heat();
 
   tempText1 = lv_label_create(scr, NULL);
   lv_obj_set_style(tempText1, &tft_style_label_rel);
   disp_desire_temp();
 }
 
 void disp_temp_type() {
   if (uiCfg.curTempType == 0) {
     if (uiCfg.curSprayerChoose == 1) {
-      lv_obj_set_event_cb_mks(buttoType, event_handler, ID_P_TYPE, "bmp_extru2.bin", 0);
+    lv_imgbtn_set_src(buttoType, LV_BTN_STATE_REL, "F:/bmp_extru2.bin");
+      lv_imgbtn_set_src(buttoType, LV_BTN_STATE_PR, "F:/bmp_extru2.bin");
       if (gCfgItems.multiple_language != 0) {
         lv_label_set_text(labelType, preheat_menu.ext2);
         lv_obj_align(labelType, buttoType, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
       }
     }
     else {
-      lv_obj_set_event_cb_mks(buttoType, event_handler, ID_P_TYPE, "bmp_extru1.bin", 0);
+    lv_imgbtn_set_src(buttoType, LV_BTN_STATE_REL, "F:/bmp_extru1.bin");
+      lv_imgbtn_set_src(buttoType, LV_BTN_STATE_PR, "F:/bmp_extru1.bin");
       if (gCfgItems.multiple_language != 0) {
         lv_label_set_text(labelType, preheat_menu.ext1);
         lv_obj_align(labelType, buttoType, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
       }
     }
 
   }
   else {
-    lv_obj_set_event_cb_mks(buttoType, event_handler, ID_P_TYPE, "bmp_bed.bin", 0);
+  lv_imgbtn_set_src(buttoType, LV_BTN_STATE_REL, "F:/bmp_bed.bin");
+      lv_imgbtn_set_src(buttoType, LV_BTN_STATE_PR, "F:/bmp_bed.bin");
     if (gCfgItems.multiple_language != 0) {
       lv_label_set_text(labelType, preheat_menu.hotbed);
       lv_obj_align(labelType, buttoType, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
     }
   }
 }
 
 void disp_desire_temp() {
   char buf[20] = {0};
 
@@ -349,36 +355,47 @@ void disp_desire_temp() {
       sprintf(buf, preheat_menu.value_state, (int)thermalManager.temp_bed.celsius,  (int)thermalManager.temp_bed.target);
     }
   #endif
   strcat_P(public_buf_l, PSTR(": "));
   strcat(public_buf_l, buf);
   lv_label_set_text(tempText1, public_buf_l);
   lv_obj_align(tempText1, NULL, LV_ALIGN_CENTER, 0, -50);
 }
 
 void disp_step_heat() {
-  if (uiCfg.stepHeat == 1)
-    lv_obj_set_event_cb_mks(buttonStep, event_handler, ID_P_STEP, "bmp_step1_degree.bin", 0);
-  else if (uiCfg.stepHeat == 5)
-    lv_obj_set_event_cb_mks(buttonStep, event_handler, ID_P_STEP, "bmp_step5_degree.bin", 0);
-  else if (uiCfg.stepHeat == 10)
-    lv_obj_set_event_cb_mks(buttonStep, event_handler, ID_P_STEP, "bmp_step10_degree.bin", 0);
+  if (uiCfg.stepHeat == 1) {
+    lv_imgbtn_set_src(buttonStep, LV_BTN_STATE_REL, "F:/bmp_step1_degree.bin");
+    lv_imgbtn_set_src(buttonStep, LV_BTN_STATE_PR, "F:/bmp_step1_degree.bin");
+  }
+  else if (uiCfg.stepHeat == 5) {
+    lv_imgbtn_set_src(buttonStep, LV_BTN_STATE_REL, "F:/bmp_step5_degree.bin");
+    lv_imgbtn_set_src(buttonStep, LV_BTN_STATE_PR, "F:/bmp_step5_degree.bin");
+  }
+  else if (uiCfg.stepHeat == 10) {
+    lv_imgbtn_set_src(buttonStep, LV_BTN_STATE_REL, "F:/bmp_step10_degree.bin");
+    lv_imgbtn_set_src(buttonStep, LV_BTN_STATE_PR, "F:/bmp_step10_degree.bin");
+  }
 
   if (gCfgItems.multiple_language != 0) {
     if (uiCfg.stepHeat == 1) {
       lv_label_set_text(labelStep, preheat_menu.step_1c);
       lv_obj_align(labelStep, buttonStep, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
     }
     else if (uiCfg.stepHeat == 5) {
       lv_label_set_text(labelStep, preheat_menu.step_5c);
       lv_obj_align(labelStep, buttonStep, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
     }
     else if (uiCfg.stepHeat == 10) {
       lv_label_set_text(labelStep, preheat_menu.step_10c);
       lv_obj_align(labelStep, buttonStep, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
     }
   }
 }
 
-void lv_clear_preHeat() { lv_obj_del(scr); }
+void lv_clear_preHeat() {
+  #if HAS_ROTARY_ENCODER
+    if (gCfgItems.encoder_enable) lv_group_remove_all_objs(g);
+  #endif
+  lv_obj_del(scr);
+}
 
 #endif // HAS_TFT_LVGL_UI

commit 60ab7a1ddbda1b1a6d20cbeb5c574ce775f57a4b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 20 19:07:59 2020 -0500

    Cleanup before MKS changes

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
index 196522b8d4..ff7641ddfd 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
@@ -260,35 +260,34 @@ void lv_draw_preHeat(void) {
     lv_imgbtn_set_style(buttonBack, LV_BTN_STATE_REL, &tft_style_label_rel);
   #endif
 
   lv_obj_set_pos(buttonAdd, INTERVAL_V, titleHeight);
   lv_obj_set_pos(buttonDec, BTN_X_PIXEL * 3 + INTERVAL_V * 4, titleHeight);
   lv_obj_set_pos(buttoType, INTERVAL_V, BTN_Y_PIXEL + INTERVAL_H + titleHeight);
   lv_obj_set_pos(buttonStep, BTN_X_PIXEL + INTERVAL_V * 2, BTN_Y_PIXEL + INTERVAL_H + titleHeight);
   lv_obj_set_pos(buttonOff, BTN_X_PIXEL * 2 + INTERVAL_V * 3, BTN_Y_PIXEL + INTERVAL_H + titleHeight);
   lv_obj_set_pos(buttonBack, BTN_X_PIXEL * 3 + INTERVAL_V * 4, BTN_Y_PIXEL + INTERVAL_H + titleHeight);
 
-  /*Create a label on the Image button*/
+  // Create labels on the image buttons
   lv_btn_set_layout(buttonAdd, LV_LAYOUT_OFF);
   lv_btn_set_layout(buttonDec, LV_LAYOUT_OFF);
   lv_btn_set_layout(buttoType, LV_LAYOUT_OFF);
   lv_btn_set_layout(buttonStep, LV_LAYOUT_OFF);
   lv_btn_set_layout(buttonOff, LV_LAYOUT_OFF);
   lv_btn_set_layout(buttonBack, LV_LAYOUT_OFF);
 
-  lv_obj_t * labelAdd = lv_label_create(buttonAdd, NULL);
-  lv_obj_t * labelDec = lv_label_create(buttonDec, NULL);
+  lv_obj_t *labelAdd = lv_label_create(buttonAdd, NULL);
+  lv_obj_t *labelDec = lv_label_create(buttonDec, NULL);
   labelType = lv_label_create(buttoType, NULL);
   labelStep = lv_label_create(buttonStep, NULL);
-  lv_obj_t * labelOff   = lv_label_create(buttonOff, NULL);
-  lv_obj_t * label_Back = lv_label_create(buttonBack, NULL);
-
+  lv_obj_t *labelOff   = lv_label_create(buttonOff, NULL);
+  lv_obj_t *label_Back = lv_label_create(buttonBack, NULL);
 
   if (gCfgItems.multiple_language != 0) {
     lv_label_set_text(labelAdd, preheat_menu.add);
     lv_obj_align(labelAdd, buttonAdd, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
 
     lv_label_set_text(labelDec, preheat_menu.dec);
     lv_obj_align(labelDec, buttonDec, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
 
     lv_label_set_text(labelOff, preheat_menu.off);
     lv_obj_align(labelOff, buttonOff, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
@@ -299,21 +298,20 @@ void lv_draw_preHeat(void) {
 
   disp_temp_type();
   disp_step_heat();
 
   tempText1 = lv_label_create(scr, NULL);
   lv_obj_set_style(tempText1, &tft_style_label_rel);
   disp_desire_temp();
 }
 
 void disp_temp_type() {
-
   if (uiCfg.curTempType == 0) {
     if (uiCfg.curSprayerChoose == 1) {
       lv_obj_set_event_cb_mks(buttoType, event_handler, ID_P_TYPE, "bmp_extru2.bin", 0);
       if (gCfgItems.multiple_language != 0) {
         lv_label_set_text(labelType, preheat_menu.ext2);
         lv_obj_align(labelType, buttoType, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
       }
     }
     else {
       lv_obj_set_event_cb_mks(buttoType, event_handler, ID_P_TYPE, "bmp_extru1.bin", 0);
@@ -324,21 +322,20 @@ void disp_temp_type() {
     }
 
   }
   else {
     lv_obj_set_event_cb_mks(buttoType, event_handler, ID_P_TYPE, "bmp_bed.bin", 0);
     if (gCfgItems.multiple_language != 0) {
       lv_label_set_text(labelType, preheat_menu.hotbed);
       lv_obj_align(labelType, buttoType, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
     }
   }
-
 }
 
 void disp_desire_temp() {
   char buf[20] = {0};
 
   public_buf_l[0] = '\0';
 
   if (uiCfg.curTempType == 0) {
     if (uiCfg.curSprayerChoose < 1)
       strcat(public_buf_l, preheat_menu.ext1);

commit 76d8d1742c1d4a1efe0fd6c0645d3fc656bfd0b2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 20 18:29:08 2020 -0500

    Add multi-extruder condition

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
index 801114e6b2..196522b8d4 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
@@ -54,21 +54,21 @@ static void event_handler(lv_obj_t * obj, lv_event_t event) {
       }
       else if (event == LV_EVENT_RELEASED) {
         if (uiCfg.curTempType == 0) {
           thermalManager.temp_hotend[uiCfg.curSprayerChoose].target += uiCfg.stepHeat;
           if (uiCfg.curSprayerChoose == 0) {
             if ((int)thermalManager.temp_hotend[uiCfg.curSprayerChoose].target > (HEATER_0_MAXTEMP - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1))) {
               thermalManager.temp_hotend[uiCfg.curSprayerChoose].target = (float)HEATER_0_MAXTEMP - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1);
               thermalManager.start_watching_hotend(uiCfg.curSprayerChoose);
             }
           }
-          #if !defined(SINGLENOZZLE) && EXTRUDERS >= 2
+          #if !defined(SINGLENOZZLE) && HAS_MULTI_EXTRUDER
             else if ((int)thermalManager.temp_hotend[uiCfg.curSprayerChoose].target > (HEATER_1_MAXTEMP - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1))) {
               thermalManager.temp_hotend[uiCfg.curSprayerChoose].target = (float)HEATER_1_MAXTEMP - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1);
               thermalManager.start_watching_hotend(uiCfg.curSprayerChoose);
             }
           #endif
         }
         #if HAS_HEATED_BED
           else {
             thermalManager.temp_bed.target += uiCfg.stepHeat;
             if ((int)thermalManager.temp_bed.target > BED_MAXTEMP - (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1)) {
@@ -110,21 +110,21 @@ static void event_handler(lv_obj_t * obj, lv_event_t event) {
         disp_desire_temp();
       }
 
       break;
     case ID_P_TYPE:
       if (event == LV_EVENT_CLICKED) {
         // nothing to do
       }
       else if (event == LV_EVENT_RELEASED) {
         if (uiCfg.curTempType == 0) {
-          if (EXTRUDERS == 2) {
+          if (ENABLED(HAS_MULTI_EXTRUDER)) {
             if (uiCfg.curSprayerChoose == 0) {
               uiCfg.curSprayerChoose = 1;
             }
             else if (uiCfg.curSprayerChoose == 1) {
               if (TEMP_SENSOR_BED != 0) {
                 uiCfg.curTempType = 1;
               }
               else {
                 uiCfg.curTempType      = 0;
                 uiCfg.curSprayerChoose = 0;

commit d20d4591321aa467c062f0050355d2aca84e03ad
Author: MKS-Sean <56996910+MKS-Sean@users.noreply.github.com>
Date:   Sat Jul 25 13:52:07 2020 +0800

    Robin nano V2, TFT LVGL UI parameters, and more (#18500)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
index 82defbebde..801114e6b2 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
@@ -14,21 +14,21 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 #include "../../../../inc/MarlinConfigPre.h"
 
-#if ENABLED(TFT_LVGL_UI)
+#if HAS_TFT_LVGL_UI
 
 #include "lv_conf.h"
 #include "draw_ui.h"
 //#include "../lvgl/src/lv_objx/lv_imgbtn.h"
 //#include "../lvgl/src/lv_objx/lv_img.h"
 //#include "../lvgl/src/lv_core/lv_disp.h"
 //#include "../lvgl/src/lv_core/lv_refr.h"
 
 #include "../../../../MarlinCore.h"
 #include "../../../../module/temperature.h"
@@ -51,108 +51,103 @@ static void event_handler(lv_obj_t * obj, lv_event_t event) {
     case ID_P_ADD:
       if (event == LV_EVENT_CLICKED) {
         // nothing to do
       }
       else if (event == LV_EVENT_RELEASED) {
         if (uiCfg.curTempType == 0) {
           thermalManager.temp_hotend[uiCfg.curSprayerChoose].target += uiCfg.stepHeat;
           if (uiCfg.curSprayerChoose == 0) {
             if ((int)thermalManager.temp_hotend[uiCfg.curSprayerChoose].target > (HEATER_0_MAXTEMP - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1))) {
               thermalManager.temp_hotend[uiCfg.curSprayerChoose].target = (float)HEATER_0_MAXTEMP - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1);
-
               thermalManager.start_watching_hotend(uiCfg.curSprayerChoose);
             }
           }
           #if !defined(SINGLENOZZLE) && EXTRUDERS >= 2
-          else    if ((int)thermalManager.temp_hotend[uiCfg.curSprayerChoose].target > (HEATER_1_MAXTEMP - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1))) {
-            thermalManager.temp_hotend[uiCfg.curSprayerChoose].target = (float)HEATER_1_MAXTEMP - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1);
-
-            thermalManager.start_watching_hotend(uiCfg.curSprayerChoose);
-          }
+            else if ((int)thermalManager.temp_hotend[uiCfg.curSprayerChoose].target > (HEATER_1_MAXTEMP - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1))) {
+              thermalManager.temp_hotend[uiCfg.curSprayerChoose].target = (float)HEATER_1_MAXTEMP - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1);
+              thermalManager.start_watching_hotend(uiCfg.curSprayerChoose);
+            }
           #endif
         }
         #if HAS_HEATED_BED
-        else {
-
-          thermalManager.temp_bed.target += uiCfg.stepHeat;
-
-          if ((int)thermalManager.temp_bed.target > BED_MAXTEMP - (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1)) {
-            thermalManager.temp_bed.target = (float)BED_MAXTEMP - (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1);
-            thermalManager.start_watching_bed();
+          else {
+            thermalManager.temp_bed.target += uiCfg.stepHeat;
+            if ((int)thermalManager.temp_bed.target > BED_MAXTEMP - (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1)) {
+              thermalManager.temp_bed.target = (float)BED_MAXTEMP - (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1);
+              thermalManager.start_watching_bed();
+            }
           }
-
-        }
         #endif
         disp_desire_temp();
       }
       break;
     case ID_P_DEC:
       if (event == LV_EVENT_CLICKED) {
         // nothing to do
       }
       else if (event == LV_EVENT_RELEASED) {
         if (uiCfg.curTempType == 0) {
           if ((int)thermalManager.temp_hotend[uiCfg.curSprayerChoose].target > uiCfg.stepHeat) {
             thermalManager.temp_hotend[uiCfg.curSprayerChoose].target -= uiCfg.stepHeat;
             thermalManager.start_watching_hotend(uiCfg.curSprayerChoose);
           }
           else {
             thermalManager.temp_hotend[uiCfg.curSprayerChoose].target = (float)0;
             thermalManager.start_watching_hotend(uiCfg.curSprayerChoose);
           }
         }
         #if HAS_HEATED_BED
-        else {
-          if ((int)thermalManager.temp_bed.target > uiCfg.stepHeat) {
-            thermalManager.temp_bed.target -= uiCfg.stepHeat;
-            thermalManager.start_watching_bed();
-          }
           else {
-            thermalManager.temp_bed.target = (float)0;
-            thermalManager.start_watching_bed();
+            if ((int)thermalManager.temp_bed.target > uiCfg.stepHeat) {
+              thermalManager.temp_bed.target -= uiCfg.stepHeat;
+              thermalManager.start_watching_bed();
+            }
+            else {
+              thermalManager.temp_bed.target = (float)0;
+              thermalManager.start_watching_bed();
+            }
           }
-        }
         #endif
         disp_desire_temp();
       }
 
       break;
     case ID_P_TYPE:
       if (event == LV_EVENT_CLICKED) {
         // nothing to do
       }
       else if (event == LV_EVENT_RELEASED) {
         if (uiCfg.curTempType == 0) {
           if (EXTRUDERS == 2) {
             if (uiCfg.curSprayerChoose == 0) {
               uiCfg.curSprayerChoose = 1;
             }
             else if (uiCfg.curSprayerChoose == 1) {
               if (TEMP_SENSOR_BED != 0) {
                 uiCfg.curTempType = 1;
               }
               else {
-                uiCfg.curTempType = 0;
+                uiCfg.curTempType      = 0;
                 uiCfg.curSprayerChoose = 0;
               }
             }
           }
-          else    if (uiCfg.curSprayerChoose == 0) {
+          else if (uiCfg.curSprayerChoose == 0) {
             if (TEMP_SENSOR_BED != 0)
               uiCfg.curTempType = 1;
             else
               uiCfg.curTempType = 0;
           }
         }
         else if (uiCfg.curTempType == 1) {
           uiCfg.curSprayerChoose = 0;
-          uiCfg.curTempType = 0;
+          uiCfg.curTempType      = 0;
         }
         disp_temp_type();
       }
       break;
     case ID_P_STEP:
       if (event == LV_EVENT_CLICKED) {
         // nothing to do
       }
       else if (event == LV_EVENT_RELEASED) {
         switch (uiCfg.stepHeat) {
@@ -167,24 +162,24 @@ static void event_handler(lv_obj_t * obj, lv_event_t event) {
     case ID_P_OFF:
       if (event == LV_EVENT_CLICKED) {
         // nothing to do
       }
       else if (event == LV_EVENT_RELEASED) {
         if (uiCfg.curTempType == 0) {
           thermalManager.temp_hotend[uiCfg.curSprayerChoose].target = (float)0;
           thermalManager.start_watching_hotend(uiCfg.curSprayerChoose);
         }
         #if HAS_HEATED_BED
-        else {
-          thermalManager.temp_bed.target = (float)0;
-          thermalManager.start_watching_bed();
-        }
+          else {
+            thermalManager.temp_bed.target = (float)0;
+            thermalManager.start_watching_bed();
+          }
         #endif
         disp_desire_temp();
       }
       break;
     case ID_P_RETURN:
       if (event == LV_EVENT_CLICKED) {
         // nothing to do
       }
       else if (event == LV_EVENT_RELEASED) {
         clear_cur_ui();
@@ -204,94 +199,94 @@ void lv_draw_preHeat(void) {
   }
   disp_state = PRE_HEAT_UI;
 
   scr = lv_obj_create(NULL, NULL);
 
   lv_obj_set_style(scr, &tft_style_scr);
   lv_scr_load(scr);
   lv_obj_clean(scr);
 
   lv_obj_t * title = lv_label_create(scr, NULL);
-  lv_obj_set_style(title, &tft_style_lable_rel);
+  lv_obj_set_style(title, &tft_style_label_rel);
   lv_obj_set_pos(title, TITLE_XPOS, TITLE_YPOS);
   lv_label_set_text(title, creat_title_text());
 
   lv_refr_now(lv_refr_get_disp_refreshing());
 
   LV_IMG_DECLARE(bmp_pic);
 
   /*Create an Image button*/
-  buttonAdd = lv_imgbtn_create(scr, NULL);
-  buttonDec = lv_imgbtn_create(scr, NULL);
-  buttoType = lv_imgbtn_create(scr, NULL);
+  buttonAdd  = lv_imgbtn_create(scr, NULL);
+  buttonDec  = lv_imgbtn_create(scr, NULL);
+  buttoType  = lv_imgbtn_create(scr, NULL);
   buttonStep = lv_imgbtn_create(scr, NULL);
-  buttonOff = lv_imgbtn_create(scr, NULL);
+  buttonOff  = lv_imgbtn_create(scr, NULL);
   buttonBack = lv_imgbtn_create(scr, NULL);
 
   lv_obj_set_event_cb_mks(buttonAdd, event_handler, ID_P_ADD, "bmp_Add.bin", 0);
   lv_imgbtn_set_src(buttonAdd, LV_BTN_STATE_REL, &bmp_pic);
   lv_imgbtn_set_src(buttonAdd, LV_BTN_STATE_PR, &bmp_pic);
-  lv_imgbtn_set_style(buttonAdd, LV_BTN_STATE_PR, &tft_style_lable_pre);
-  lv_imgbtn_set_style(buttonAdd, LV_BTN_STATE_REL, &tft_style_lable_rel);
+  lv_imgbtn_set_style(buttonAdd, LV_BTN_STATE_PR, &tft_style_label_pre);
+  lv_imgbtn_set_style(buttonAdd, LV_BTN_STATE_REL, &tft_style_label_rel);
   lv_obj_clear_protect(buttonAdd, LV_PROTECT_FOLLOW);
   #if 1
     lv_obj_set_event_cb_mks(buttonDec, event_handler, ID_P_DEC, "bmp_Dec.bin", 0);
     lv_imgbtn_set_src(buttonDec, LV_BTN_STATE_REL, &bmp_pic);
     lv_imgbtn_set_src(buttonDec, LV_BTN_STATE_PR, &bmp_pic);
-    lv_imgbtn_set_style(buttonDec, LV_BTN_STATE_PR, &tft_style_lable_pre);
-    lv_imgbtn_set_style(buttonDec, LV_BTN_STATE_REL, &tft_style_lable_rel);
+    lv_imgbtn_set_style(buttonDec, LV_BTN_STATE_PR, &tft_style_label_pre);
+    lv_imgbtn_set_style(buttonDec, LV_BTN_STATE_REL, &tft_style_label_rel);
 
 
     lv_imgbtn_set_src(buttoType, LV_BTN_STATE_REL, &bmp_pic);
     lv_imgbtn_set_src(buttoType, LV_BTN_STATE_PR, &bmp_pic);
-    lv_imgbtn_set_style(buttoType, LV_BTN_STATE_PR, &tft_style_lable_pre);
-    lv_imgbtn_set_style(buttoType, LV_BTN_STATE_REL, &tft_style_lable_rel);
+    lv_imgbtn_set_style(buttoType, LV_BTN_STATE_PR, &tft_style_label_pre);
+    lv_imgbtn_set_style(buttoType, LV_BTN_STATE_REL, &tft_style_label_rel);
 
 
     lv_imgbtn_set_src(buttonStep, LV_BTN_STATE_REL, &bmp_pic);
     lv_imgbtn_set_src(buttonStep, LV_BTN_STATE_PR, &bmp_pic);
-    lv_imgbtn_set_style(buttonStep, LV_BTN_STATE_PR, &tft_style_lable_pre);
-    lv_imgbtn_set_style(buttonStep, LV_BTN_STATE_REL, &tft_style_lable_rel);
+    lv_imgbtn_set_style(buttonStep, LV_BTN_STATE_PR, &tft_style_label_pre);
+    lv_imgbtn_set_style(buttonStep, LV_BTN_STATE_REL, &tft_style_label_rel);
 
-    lv_obj_set_event_cb_mks(buttonOff, event_handler, ID_P_OFF, "bmp_Speed0.bin", 0);
+    lv_obj_set_event_cb_mks(buttonOff, event_handler, ID_P_OFF, "bmp_speed0.bin", 0);
     lv_imgbtn_set_src(buttonOff, LV_BTN_STATE_REL, &bmp_pic);
     lv_imgbtn_set_src(buttonOff, LV_BTN_STATE_PR, &bmp_pic);
-    lv_imgbtn_set_style(buttonOff, LV_BTN_STATE_PR, &tft_style_lable_pre);
-    lv_imgbtn_set_style(buttonOff, LV_BTN_STATE_REL, &tft_style_lable_rel);
+    lv_imgbtn_set_style(buttonOff, LV_BTN_STATE_PR, &tft_style_label_pre);
+    lv_imgbtn_set_style(buttonOff, LV_BTN_STATE_REL, &tft_style_label_rel);
 
-    lv_obj_set_event_cb_mks(buttonBack, event_handler, ID_P_RETURN, "bmp_Return.bin", 0);
+    lv_obj_set_event_cb_mks(buttonBack, event_handler, ID_P_RETURN, "bmp_return.bin", 0);
     lv_imgbtn_set_src(buttonBack, LV_BTN_STATE_REL, &bmp_pic);
     lv_imgbtn_set_src(buttonBack, LV_BTN_STATE_PR, &bmp_pic);
-    lv_imgbtn_set_style(buttonBack, LV_BTN_STATE_PR, &tft_style_lable_pre);
-    lv_imgbtn_set_style(buttonBack, LV_BTN_STATE_REL, &tft_style_lable_rel);
+    lv_imgbtn_set_style(buttonBack, LV_BTN_STATE_PR, &tft_style_label_pre);
+    lv_imgbtn_set_style(buttonBack, LV_BTN_STATE_REL, &tft_style_label_rel);
   #endif
 
   lv_obj_set_pos(buttonAdd, INTERVAL_V, titleHeight);
   lv_obj_set_pos(buttonDec, BTN_X_PIXEL * 3 + INTERVAL_V * 4, titleHeight);
-  lv_obj_set_pos(buttoType, INTERVAL_V,  BTN_Y_PIXEL + INTERVAL_H + titleHeight);
+  lv_obj_set_pos(buttoType, INTERVAL_V, BTN_Y_PIXEL + INTERVAL_H + titleHeight);
   lv_obj_set_pos(buttonStep, BTN_X_PIXEL + INTERVAL_V * 2, BTN_Y_PIXEL + INTERVAL_H + titleHeight);
-  lv_obj_set_pos(buttonOff, BTN_X_PIXEL * 2 + INTERVAL_V * 3,  BTN_Y_PIXEL + INTERVAL_H + titleHeight);
-  lv_obj_set_pos(buttonBack, BTN_X_PIXEL * 3 + INTERVAL_V * 4,  BTN_Y_PIXEL + INTERVAL_H + titleHeight);
+  lv_obj_set_pos(buttonOff, BTN_X_PIXEL * 2 + INTERVAL_V * 3, BTN_Y_PIXEL + INTERVAL_H + titleHeight);
+  lv_obj_set_pos(buttonBack, BTN_X_PIXEL * 3 + INTERVAL_V * 4, BTN_Y_PIXEL + INTERVAL_H + titleHeight);
 
   /*Create a label on the Image button*/
   lv_btn_set_layout(buttonAdd, LV_LAYOUT_OFF);
   lv_btn_set_layout(buttonDec, LV_LAYOUT_OFF);
   lv_btn_set_layout(buttoType, LV_LAYOUT_OFF);
   lv_btn_set_layout(buttonStep, LV_LAYOUT_OFF);
   lv_btn_set_layout(buttonOff, LV_LAYOUT_OFF);
   lv_btn_set_layout(buttonBack, LV_LAYOUT_OFF);
 
   lv_obj_t * labelAdd = lv_label_create(buttonAdd, NULL);
   lv_obj_t * labelDec = lv_label_create(buttonDec, NULL);
   labelType = lv_label_create(buttoType, NULL);
   labelStep = lv_label_create(buttonStep, NULL);
-  lv_obj_t * labelOff = lv_label_create(buttonOff, NULL);
+  lv_obj_t * labelOff   = lv_label_create(buttonOff, NULL);
   lv_obj_t * label_Back = lv_label_create(buttonBack, NULL);
 
 
   if (gCfgItems.multiple_language != 0) {
     lv_label_set_text(labelAdd, preheat_menu.add);
     lv_obj_align(labelAdd, buttonAdd, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
 
     lv_label_set_text(labelDec, preheat_menu.dec);
     lv_obj_align(labelDec, buttonDec, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
 
@@ -299,45 +294,45 @@ void lv_draw_preHeat(void) {
     lv_obj_align(labelOff, buttonOff, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
 
     lv_label_set_text(label_Back, common_menu.text_back);
     lv_obj_align(label_Back, buttonBack, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
   }
 
   disp_temp_type();
   disp_step_heat();
 
   tempText1 = lv_label_create(scr, NULL);
-  lv_obj_set_style(tempText1, &tft_style_lable_rel);
+  lv_obj_set_style(tempText1, &tft_style_label_rel);
   disp_desire_temp();
 }
 
 void disp_temp_type() {
 
   if (uiCfg.curTempType == 0) {
     if (uiCfg.curSprayerChoose == 1) {
-      lv_obj_set_event_cb_mks(buttoType, event_handler, ID_P_TYPE, "bmp_Extru2.bin", 0);
+      lv_obj_set_event_cb_mks(buttoType, event_handler, ID_P_TYPE, "bmp_extru2.bin", 0);
       if (gCfgItems.multiple_language != 0) {
         lv_label_set_text(labelType, preheat_menu.ext2);
         lv_obj_align(labelType, buttoType, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
       }
     }
     else {
-      lv_obj_set_event_cb_mks(buttoType, event_handler, ID_P_TYPE, "bmp_Extru1.bin", 0);
+      lv_obj_set_event_cb_mks(buttoType, event_handler, ID_P_TYPE, "bmp_extru1.bin", 0);
       if (gCfgItems.multiple_language != 0) {
         lv_label_set_text(labelType, preheat_menu.ext1);
         lv_obj_align(labelType, buttoType, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
       }
     }
 
   }
   else {
-    lv_obj_set_event_cb_mks(buttoType, event_handler, ID_P_TYPE, "bmp_Bed.bin", 0);
+    lv_obj_set_event_cb_mks(buttoType, event_handler, ID_P_TYPE, "bmp_bed.bin", 0);
     if (gCfgItems.multiple_language != 0) {
       lv_label_set_text(labelType, preheat_menu.hotbed);
       lv_obj_align(labelType, buttoType, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
     }
   }
 
 }
 
 void disp_desire_temp() {
   char buf[20] = {0};
@@ -345,48 +340,48 @@ void disp_desire_temp() {
   public_buf_l[0] = '\0';
 
   if (uiCfg.curTempType == 0) {
     if (uiCfg.curSprayerChoose < 1)
       strcat(public_buf_l, preheat_menu.ext1);
     else
       strcat(public_buf_l, preheat_menu.ext2);
     sprintf(buf, preheat_menu.value_state, (int)thermalManager.temp_hotend[uiCfg.curSprayerChoose].celsius,  (int)thermalManager.temp_hotend[uiCfg.curSprayerChoose].target);
   }
   #if HAS_HEATED_BED
-  else {
-    strcat(public_buf_l, preheat_menu.hotbed);
-    sprintf(buf, preheat_menu.value_state, (int)thermalManager.temp_bed.celsius,  (int)thermalManager.temp_bed.target);
-  }
+    else {
+      strcat(public_buf_l, preheat_menu.hotbed);
+      sprintf(buf, preheat_menu.value_state, (int)thermalManager.temp_bed.celsius,  (int)thermalManager.temp_bed.target);
+    }
   #endif
-  strcat(public_buf_l, ": ");
+  strcat_P(public_buf_l, PSTR(": "));
   strcat(public_buf_l, buf);
   lv_label_set_text(tempText1, public_buf_l);
   lv_obj_align(tempText1, NULL, LV_ALIGN_CENTER, 0, -50);
 }
 
 void disp_step_heat() {
   if (uiCfg.stepHeat == 1)
-    lv_obj_set_event_cb_mks(buttonStep, event_handler, ID_P_STEP, "bmp_Step1_degree.bin", 0);
+    lv_obj_set_event_cb_mks(buttonStep, event_handler, ID_P_STEP, "bmp_step1_degree.bin", 0);
   else if (uiCfg.stepHeat == 5)
-    lv_obj_set_event_cb_mks(buttonStep, event_handler, ID_P_STEP, "bmp_Step5_degree.bin", 0);
+    lv_obj_set_event_cb_mks(buttonStep, event_handler, ID_P_STEP, "bmp_step5_degree.bin", 0);
   else if (uiCfg.stepHeat == 10)
-    lv_obj_set_event_cb_mks(buttonStep, event_handler, ID_P_STEP, "bmp_Step10_degree.bin", 0);
+    lv_obj_set_event_cb_mks(buttonStep, event_handler, ID_P_STEP, "bmp_step10_degree.bin", 0);
 
   if (gCfgItems.multiple_language != 0) {
     if (uiCfg.stepHeat == 1) {
       lv_label_set_text(labelStep, preheat_menu.step_1c);
       lv_obj_align(labelStep, buttonStep, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
     }
     else if (uiCfg.stepHeat == 5) {
       lv_label_set_text(labelStep, preheat_menu.step_5c);
       lv_obj_align(labelStep, buttonStep, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
     }
     else if (uiCfg.stepHeat == 10) {
       lv_label_set_text(labelStep, preheat_menu.step_10c);
       lv_obj_align(labelStep, buttonStep, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
     }
   }
 }
 
 void lv_clear_preHeat() { lv_obj_del(scr); }
 
-#endif // TFT_LVGL_UI
+#endif // HAS_TFT_LVGL_UI

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
index 27d011e000..82defbebde 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
@@ -9,21 +9,21 @@
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 #include "../../../../inc/MarlinConfigPre.h"
 
 #if ENABLED(TFT_LVGL_UI)
 
 #include "lv_conf.h"
 #include "draw_ui.h"
 //#include "../lvgl/src/lv_objx/lv_imgbtn.h"
 //#include "../lvgl/src/lv_objx/lv_img.h"

commit e5bc9d31cc87be5c7ef2bd3cd70c2599f76d2bd7
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Wed Jul 1 03:30:24 2020 -0300

    Add TFT_LVGL_UI support (#18438)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
index beea30018c..27d011e000 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
@@ -14,21 +14,21 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 #include "../../../../inc/MarlinConfigPre.h"
 
-#if ENABLED(TFT_LITTLE_VGL_UI)
+#if ENABLED(TFT_LVGL_UI)
 
 #include "lv_conf.h"
 #include "draw_ui.h"
 //#include "../lvgl/src/lv_objx/lv_imgbtn.h"
 //#include "../lvgl/src/lv_objx/lv_img.h"
 //#include "../lvgl/src/lv_core/lv_disp.h"
 //#include "../lvgl/src/lv_core/lv_refr.h"
 
 #include "../../../../MarlinCore.h"
 #include "../../../../module/temperature.h"
@@ -382,11 +382,11 @@ void disp_step_heat() {
     }
     else if (uiCfg.stepHeat == 10) {
       lv_label_set_text(labelStep, preheat_menu.step_10c);
       lv_obj_align(labelStep, buttonStep, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
     }
   }
 }
 
 void lv_clear_preHeat() { lv_obj_del(scr); }
 
-#endif // TFT_LITTLE_VGL_UI
+#endif // TFT_LVGL_UI

commit 642112d3eb7c1af9a52feec8134c85ed3e34891c
Author: makerbase <4164049@qq.com>
Date:   Tue Jun 16 10:05:33 2020 +0800

    Add MKS UI (TFT_LITTLE_VGL_UI) (#18071)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp b/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
new file mode 100644
index 0000000000..beea30018c
--- /dev/null
+++ b/Marlin/src/lcd/extui/lib/mks_ui/draw_preHeat.cpp
@@ -0,0 +1,392 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+#include "../../../../inc/MarlinConfigPre.h"
+
+#if ENABLED(TFT_LITTLE_VGL_UI)
+
+#include "lv_conf.h"
+#include "draw_ui.h"
+//#include "../lvgl/src/lv_objx/lv_imgbtn.h"
+//#include "../lvgl/src/lv_objx/lv_img.h"
+//#include "../lvgl/src/lv_core/lv_disp.h"
+//#include "../lvgl/src/lv_core/lv_refr.h"
+
+#include "../../../../MarlinCore.h"
+#include "../../../../module/temperature.h"
+
+static lv_obj_t * scr;
+static lv_obj_t *buttoType, *buttonStep;
+static lv_obj_t * labelType;
+static lv_obj_t * labelStep;
+static lv_obj_t * tempText1;
+
+#define ID_P_ADD    1
+#define ID_P_DEC    2
+#define ID_P_TYPE   3
+#define ID_P_STEP   4
+#define ID_P_OFF    5
+#define ID_P_RETURN 6
+
+static void event_handler(lv_obj_t * obj, lv_event_t event) {
+  switch (obj->mks_obj_id) {
+    case ID_P_ADD:
+      if (event == LV_EVENT_CLICKED) {
+        // nothing to do
+      }
+      else if (event == LV_EVENT_RELEASED) {
+        if (uiCfg.curTempType == 0) {
+          thermalManager.temp_hotend[uiCfg.curSprayerChoose].target += uiCfg.stepHeat;
+          if (uiCfg.curSprayerChoose == 0) {
+            if ((int)thermalManager.temp_hotend[uiCfg.curSprayerChoose].target > (HEATER_0_MAXTEMP - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1))) {
+              thermalManager.temp_hotend[uiCfg.curSprayerChoose].target = (float)HEATER_0_MAXTEMP - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1);
+
+              thermalManager.start_watching_hotend(uiCfg.curSprayerChoose);
+            }
+          }
+          #if !defined(SINGLENOZZLE) && EXTRUDERS >= 2
+          else    if ((int)thermalManager.temp_hotend[uiCfg.curSprayerChoose].target > (HEATER_1_MAXTEMP - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1))) {
+            thermalManager.temp_hotend[uiCfg.curSprayerChoose].target = (float)HEATER_1_MAXTEMP - (WATCH_TEMP_INCREASE + TEMP_HYSTERESIS + 1);
+
+            thermalManager.start_watching_hotend(uiCfg.curSprayerChoose);
+          }
+          #endif
+        }
+        #if HAS_HEATED_BED
+        else {
+
+          thermalManager.temp_bed.target += uiCfg.stepHeat;
+
+          if ((int)thermalManager.temp_bed.target > BED_MAXTEMP - (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1)) {
+            thermalManager.temp_bed.target = (float)BED_MAXTEMP - (WATCH_BED_TEMP_INCREASE + TEMP_BED_HYSTERESIS + 1);
+            thermalManager.start_watching_bed();
+          }
+
+        }
+        #endif
+        disp_desire_temp();
+      }
+      break;
+    case ID_P_DEC:
+      if (event == LV_EVENT_CLICKED) {
+        // nothing to do
+      }
+      else if (event == LV_EVENT_RELEASED) {
+        if (uiCfg.curTempType == 0) {
+          if ((int)thermalManager.temp_hotend[uiCfg.curSprayerChoose].target > uiCfg.stepHeat) {
+            thermalManager.temp_hotend[uiCfg.curSprayerChoose].target -= uiCfg.stepHeat;
+            thermalManager.start_watching_hotend(uiCfg.curSprayerChoose);
+          }
+          else {
+            thermalManager.temp_hotend[uiCfg.curSprayerChoose].target = (float)0;
+            thermalManager.start_watching_hotend(uiCfg.curSprayerChoose);
+          }
+        }
+        #if HAS_HEATED_BED
+        else {
+          if ((int)thermalManager.temp_bed.target > uiCfg.stepHeat) {
+            thermalManager.temp_bed.target -= uiCfg.stepHeat;
+            thermalManager.start_watching_bed();
+          }
+          else {
+            thermalManager.temp_bed.target = (float)0;
+            thermalManager.start_watching_bed();
+          }
+        }
+        #endif
+        disp_desire_temp();
+      }
+
+      break;
+    case ID_P_TYPE:
+      if (event == LV_EVENT_CLICKED) {
+        // nothing to do
+      }
+      else if (event == LV_EVENT_RELEASED) {
+        if (uiCfg.curTempType == 0) {
+          if (EXTRUDERS == 2) {
+            if (uiCfg.curSprayerChoose == 0) {
+              uiCfg.curSprayerChoose = 1;
+            }
+            else if (uiCfg.curSprayerChoose == 1) {
+              if (TEMP_SENSOR_BED != 0) {
+                uiCfg.curTempType = 1;
+              }
+              else {
+                uiCfg.curTempType = 0;
+                uiCfg.curSprayerChoose = 0;
+              }
+            }
+          }
+          else    if (uiCfg.curSprayerChoose == 0) {
+            if (TEMP_SENSOR_BED != 0)
+              uiCfg.curTempType = 1;
+            else
+              uiCfg.curTempType = 0;
+          }
+        }
+        else if (uiCfg.curTempType == 1) {
+          uiCfg.curSprayerChoose = 0;
+          uiCfg.curTempType = 0;
+        }
+        disp_temp_type();
+      }
+      break;
+    case ID_P_STEP:
+      if (event == LV_EVENT_CLICKED) {
+        // nothing to do
+      }
+      else if (event == LV_EVENT_RELEASED) {
+        switch (uiCfg.stepHeat) {
+          case  1: uiCfg.stepHeat =  5; break;
+          case  5: uiCfg.stepHeat = 10; break;
+          case 10: uiCfg.stepHeat =  1; break;
+          default: break;
+        }
+        disp_step_heat();
+      }
+      break;
+    case ID_P_OFF:
+      if (event == LV_EVENT_CLICKED) {
+        // nothing to do
+      }
+      else if (event == LV_EVENT_RELEASED) {
+        if (uiCfg.curTempType == 0) {
+          thermalManager.temp_hotend[uiCfg.curSprayerChoose].target = (float)0;
+          thermalManager.start_watching_hotend(uiCfg.curSprayerChoose);
+        }
+        #if HAS_HEATED_BED
+        else {
+          thermalManager.temp_bed.target = (float)0;
+          thermalManager.start_watching_bed();
+        }
+        #endif
+        disp_desire_temp();
+      }
+      break;
+    case ID_P_RETURN:
+      if (event == LV_EVENT_CLICKED) {
+        // nothing to do
+      }
+      else if (event == LV_EVENT_RELEASED) {
+        clear_cur_ui();
+        draw_return_ui();
+      }
+      break;
+  }
+}
+
+void lv_draw_preHeat(void) {
+  lv_obj_t *buttonAdd, *buttonDec;
+  lv_obj_t *buttonOff, *buttonBack;
+
+  if (disp_state_stack._disp_state[disp_state_stack._disp_index] != PRE_HEAT_UI) {
+    disp_state_stack._disp_index++;
+    disp_state_stack._disp_state[disp_state_stack._disp_index] = PRE_HEAT_UI;
+  }
+  disp_state = PRE_HEAT_UI;
+
+  scr = lv_obj_create(NULL, NULL);
+
+  lv_obj_set_style(scr, &tft_style_scr);
+  lv_scr_load(scr);
+  lv_obj_clean(scr);
+
+  lv_obj_t * title = lv_label_create(scr, NULL);
+  lv_obj_set_style(title, &tft_style_lable_rel);
+  lv_obj_set_pos(title, TITLE_XPOS, TITLE_YPOS);
+  lv_label_set_text(title, creat_title_text());
+
+  lv_refr_now(lv_refr_get_disp_refreshing());
+
+  LV_IMG_DECLARE(bmp_pic);
+
+  /*Create an Image button*/
+  buttonAdd = lv_imgbtn_create(scr, NULL);
+  buttonDec = lv_imgbtn_create(scr, NULL);
+  buttoType = lv_imgbtn_create(scr, NULL);
+  buttonStep = lv_imgbtn_create(scr, NULL);
+  buttonOff = lv_imgbtn_create(scr, NULL);
+  buttonBack = lv_imgbtn_create(scr, NULL);
+
+  lv_obj_set_event_cb_mks(buttonAdd, event_handler, ID_P_ADD, "bmp_Add.bin", 0);
+  lv_imgbtn_set_src(buttonAdd, LV_BTN_STATE_REL, &bmp_pic);
+  lv_imgbtn_set_src(buttonAdd, LV_BTN_STATE_PR, &bmp_pic);
+  lv_imgbtn_set_style(buttonAdd, LV_BTN_STATE_PR, &tft_style_lable_pre);
+  lv_imgbtn_set_style(buttonAdd, LV_BTN_STATE_REL, &tft_style_lable_rel);
+  lv_obj_clear_protect(buttonAdd, LV_PROTECT_FOLLOW);
+  #if 1
+    lv_obj_set_event_cb_mks(buttonDec, event_handler, ID_P_DEC, "bmp_Dec.bin", 0);
+    lv_imgbtn_set_src(buttonDec, LV_BTN_STATE_REL, &bmp_pic);
+    lv_imgbtn_set_src(buttonDec, LV_BTN_STATE_PR, &bmp_pic);
+    lv_imgbtn_set_style(buttonDec, LV_BTN_STATE_PR, &tft_style_lable_pre);
+    lv_imgbtn_set_style(buttonDec, LV_BTN_STATE_REL, &tft_style_lable_rel);
+
+
+    lv_imgbtn_set_src(buttoType, LV_BTN_STATE_REL, &bmp_pic);
+    lv_imgbtn_set_src(buttoType, LV_BTN_STATE_PR, &bmp_pic);
+    lv_imgbtn_set_style(buttoType, LV_BTN_STATE_PR, &tft_style_lable_pre);
+    lv_imgbtn_set_style(buttoType, LV_BTN_STATE_REL, &tft_style_lable_rel);
+
+
+    lv_imgbtn_set_src(buttonStep, LV_BTN_STATE_REL, &bmp_pic);
+    lv_imgbtn_set_src(buttonStep, LV_BTN_STATE_PR, &bmp_pic);
+    lv_imgbtn_set_style(buttonStep, LV_BTN_STATE_PR, &tft_style_lable_pre);
+    lv_imgbtn_set_style(buttonStep, LV_BTN_STATE_REL, &tft_style_lable_rel);
+
+    lv_obj_set_event_cb_mks(buttonOff, event_handler, ID_P_OFF, "bmp_Speed0.bin", 0);
+    lv_imgbtn_set_src(buttonOff, LV_BTN_STATE_REL, &bmp_pic);
+    lv_imgbtn_set_src(buttonOff, LV_BTN_STATE_PR, &bmp_pic);
+    lv_imgbtn_set_style(buttonOff, LV_BTN_STATE_PR, &tft_style_lable_pre);
+    lv_imgbtn_set_style(buttonOff, LV_BTN_STATE_REL, &tft_style_lable_rel);
+
+    lv_obj_set_event_cb_mks(buttonBack, event_handler, ID_P_RETURN, "bmp_Return.bin", 0);
+    lv_imgbtn_set_src(buttonBack, LV_BTN_STATE_REL, &bmp_pic);
+    lv_imgbtn_set_src(buttonBack, LV_BTN_STATE_PR, &bmp_pic);
+    lv_imgbtn_set_style(buttonBack, LV_BTN_STATE_PR, &tft_style_lable_pre);
+    lv_imgbtn_set_style(buttonBack, LV_BTN_STATE_REL, &tft_style_lable_rel);
+  #endif
+
+  lv_obj_set_pos(buttonAdd, INTERVAL_V, titleHeight);
+  lv_obj_set_pos(buttonDec, BTN_X_PIXEL * 3 + INTERVAL_V * 4, titleHeight);
+  lv_obj_set_pos(buttoType, INTERVAL_V,  BTN_Y_PIXEL + INTERVAL_H + titleHeight);
+  lv_obj_set_pos(buttonStep, BTN_X_PIXEL + INTERVAL_V * 2, BTN_Y_PIXEL + INTERVAL_H + titleHeight);
+  lv_obj_set_pos(buttonOff, BTN_X_PIXEL * 2 + INTERVAL_V * 3,  BTN_Y_PIXEL + INTERVAL_H + titleHeight);
+  lv_obj_set_pos(buttonBack, BTN_X_PIXEL * 3 + INTERVAL_V * 4,  BTN_Y_PIXEL + INTERVAL_H + titleHeight);
+
+  /*Create a label on the Image button*/
+  lv_btn_set_layout(buttonAdd, LV_LAYOUT_OFF);
+  lv_btn_set_layout(buttonDec, LV_LAYOUT_OFF);
+  lv_btn_set_layout(buttoType, LV_LAYOUT_OFF);
+  lv_btn_set_layout(buttonStep, LV_LAYOUT_OFF);
+  lv_btn_set_layout(buttonOff, LV_LAYOUT_OFF);
+  lv_btn_set_layout(buttonBack, LV_LAYOUT_OFF);
+
+  lv_obj_t * labelAdd = lv_label_create(buttonAdd, NULL);
+  lv_obj_t * labelDec = lv_label_create(buttonDec, NULL);
+  labelType = lv_label_create(buttoType, NULL);
+  labelStep = lv_label_create(buttonStep, NULL);
+  lv_obj_t * labelOff = lv_label_create(buttonOff, NULL);
+  lv_obj_t * label_Back = lv_label_create(buttonBack, NULL);
+
+
+  if (gCfgItems.multiple_language != 0) {
+    lv_label_set_text(labelAdd, preheat_menu.add);
+    lv_obj_align(labelAdd, buttonAdd, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
+
+    lv_label_set_text(labelDec, preheat_menu.dec);
+    lv_obj_align(labelDec, buttonDec, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
+
+    lv_label_set_text(labelOff, preheat_menu.off);
+    lv_obj_align(labelOff, buttonOff, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
+
+    lv_label_set_text(label_Back, common_menu.text_back);
+    lv_obj_align(label_Back, buttonBack, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
+  }
+
+  disp_temp_type();
+  disp_step_heat();
+
+  tempText1 = lv_label_create(scr, NULL);
+  lv_obj_set_style(tempText1, &tft_style_lable_rel);
+  disp_desire_temp();
+}
+
+void disp_temp_type() {
+
+  if (uiCfg.curTempType == 0) {
+    if (uiCfg.curSprayerChoose == 1) {
+      lv_obj_set_event_cb_mks(buttoType, event_handler, ID_P_TYPE, "bmp_Extru2.bin", 0);
+      if (gCfgItems.multiple_language != 0) {
+        lv_label_set_text(labelType, preheat_menu.ext2);
+        lv_obj_align(labelType, buttoType, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
+      }
+    }
+    else {
+      lv_obj_set_event_cb_mks(buttoType, event_handler, ID_P_TYPE, "bmp_Extru1.bin", 0);
+      if (gCfgItems.multiple_language != 0) {
+        lv_label_set_text(labelType, preheat_menu.ext1);
+        lv_obj_align(labelType, buttoType, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
+      }
+    }
+
+  }
+  else {
+    lv_obj_set_event_cb_mks(buttoType, event_handler, ID_P_TYPE, "bmp_Bed.bin", 0);
+    if (gCfgItems.multiple_language != 0) {
+      lv_label_set_text(labelType, preheat_menu.hotbed);
+      lv_obj_align(labelType, buttoType, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
+    }
+  }
+
+}
+
+void disp_desire_temp() {
+  char buf[20] = {0};
+
+  public_buf_l[0] = '\0';
+
+  if (uiCfg.curTempType == 0) {
+    if (uiCfg.curSprayerChoose < 1)
+      strcat(public_buf_l, preheat_menu.ext1);
+    else
+      strcat(public_buf_l, preheat_menu.ext2);
+    sprintf(buf, preheat_menu.value_state, (int)thermalManager.temp_hotend[uiCfg.curSprayerChoose].celsius,  (int)thermalManager.temp_hotend[uiCfg.curSprayerChoose].target);
+  }
+  #if HAS_HEATED_BED
+  else {
+    strcat(public_buf_l, preheat_menu.hotbed);
+    sprintf(buf, preheat_menu.value_state, (int)thermalManager.temp_bed.celsius,  (int)thermalManager.temp_bed.target);
+  }
+  #endif
+  strcat(public_buf_l, ": ");
+  strcat(public_buf_l, buf);
+  lv_label_set_text(tempText1, public_buf_l);
+  lv_obj_align(tempText1, NULL, LV_ALIGN_CENTER, 0, -50);
+}
+
+void disp_step_heat() {
+  if (uiCfg.stepHeat == 1)
+    lv_obj_set_event_cb_mks(buttonStep, event_handler, ID_P_STEP, "bmp_Step1_degree.bin", 0);
+  else if (uiCfg.stepHeat == 5)
+    lv_obj_set_event_cb_mks(buttonStep, event_handler, ID_P_STEP, "bmp_Step5_degree.bin", 0);
+  else if (uiCfg.stepHeat == 10)
+    lv_obj_set_event_cb_mks(buttonStep, event_handler, ID_P_STEP, "bmp_Step10_degree.bin", 0);
+
+  if (gCfgItems.multiple_language != 0) {
+    if (uiCfg.stepHeat == 1) {
+      lv_label_set_text(labelStep, preheat_menu.step_1c);
+      lv_obj_align(labelStep, buttonStep, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
+    }
+    else if (uiCfg.stepHeat == 5) {
+      lv_label_set_text(labelStep, preheat_menu.step_5c);
+      lv_obj_align(labelStep, buttonStep, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
+    }
+    else if (uiCfg.stepHeat == 10) {
+      lv_label_set_text(labelStep, preheat_menu.step_10c);
+      lv_obj_align(labelStep, buttonStep, LV_ALIGN_IN_BOTTOM_MID, 0, BUTTON_TEXT_Y_OFFSET);
+    }
+  }
+}
+
+void lv_clear_preHeat() { lv_obj_del(scr); }
+
+#endif // TFT_LITTLE_VGL_UI
