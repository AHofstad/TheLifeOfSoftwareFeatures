commit 8d9021e8069c0550e9a31107adf44b9112b87471
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 6 04:17:59 2021 -0500

    Move ExtUI subfolders up a level (#21820)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/SPI_TFT.cpp b/Marlin/src/lcd/extui/lib/mks_ui/SPI_TFT.cpp
deleted file mode 100644
index 76a4de3561..0000000000
--- a/Marlin/src/lcd/extui/lib/mks_ui/SPI_TFT.cpp
+++ /dev/null
@@ -1,86 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-#include "../../../../inc/MarlinConfigPre.h"
-
-#if HAS_TFT_LVGL_UI
-
-#include "SPI_TFT.h"
-#include "pic_manager.h"
-#include "tft_lvgl_configuration.h"
-
-#include "../../../../inc/MarlinConfig.h"
-
-#include <SPI.h>
-
-#include "draw_ui.h"
-
-TFT SPI_TFT;
-
-// use SPI1 for the spi tft.
-void TFT::spi_init(uint8_t spiRate) {
-  tftio.Init();
-}
-
-void TFT::SetPoint(uint16_t x, uint16_t y, uint16_t point) {
-  if ((x > 480) || (y > 320)) return;
-
-  setWindow(x, y, 1, 1);
-  tftio.WriteMultiple(point, (uint16_t)1);
-}
-
-void TFT::setWindow(uint16_t x, uint16_t y, uint16_t with, uint16_t height) {
-  tftio.set_window(x, y, (x + with - 1), (y + height - 1));
-}
-
-void TFT::LCD_init() {
-  tftio.InitTFT();
-  #if PIN_EXISTS(TFT_BACKLIGHT)
-    OUT_WRITE(TFT_BACKLIGHT_PIN, LOW);
-  #endif
-  delay(100);
-  LCD_clear(0x0000);
-  LCD_Draw_Logo();
-  #if PIN_EXISTS(TFT_BACKLIGHT)
-    OUT_WRITE(TFT_BACKLIGHT_PIN, HIGH);
-  #endif
-  #if HAS_LOGO_IN_FLASH
-    delay(2000);
-  #endif
-}
-
-void TFT::LCD_clear(uint16_t color) {
-  setWindow(0, 0, (TFT_WIDTH), (TFT_HEIGHT));
-  tftio.WriteMultiple(color, (uint32_t)(TFT_WIDTH) * (TFT_HEIGHT));
-}
-
-void TFT::LCD_Draw_Logo() {
-  #if HAS_LOGO_IN_FLASH
-    setWindow(0, 0, TFT_WIDTH, TFT_HEIGHT);
-    for (uint16_t i = 0; i < (TFT_HEIGHT); i ++) {
-      Pic_Logo_Read((uint8_t *)"", (uint8_t *)bmp_public_buf, (TFT_WIDTH) * 2);
-      tftio.WriteSequence((uint16_t *)bmp_public_buf, TFT_WIDTH);
-    }
-  #endif
-}
-
-#endif // HAS_TFT_LVGL_UI

commit 44c57ab05a8f909b85f51e08c90316b41e50c455
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jan 12 21:02:35 2021 -0600

    MKS UI prelim. cleanup (#20763)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/SPI_TFT.cpp b/Marlin/src/lcd/extui/lib/mks_ui/SPI_TFT.cpp
index 394ce48075..76a4de3561 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/SPI_TFT.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/SPI_TFT.cpp
@@ -66,22 +66,20 @@ void TFT::LCD_init() {
   #if HAS_LOGO_IN_FLASH
     delay(2000);
   #endif
 }
 
 void TFT::LCD_clear(uint16_t color) {
   setWindow(0, 0, (TFT_WIDTH), (TFT_HEIGHT));
   tftio.WriteMultiple(color, (uint32_t)(TFT_WIDTH) * (TFT_HEIGHT));
 }
 
-extern unsigned char bmp_public_buf[17 * 1024];
-
 void TFT::LCD_Draw_Logo() {
   #if HAS_LOGO_IN_FLASH
     setWindow(0, 0, TFT_WIDTH, TFT_HEIGHT);
     for (uint16_t i = 0; i < (TFT_HEIGHT); i ++) {
       Pic_Logo_Read((uint8_t *)"", (uint8_t *)bmp_public_buf, (TFT_WIDTH) * 2);
       tftio.WriteSequence((uint16_t *)bmp_public_buf, TFT_WIDTH);
     }
   #endif
 }
 

commit c0920bbf6a2490b7ea66d2a9e828c0f527a6c77b
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Mon Oct 12 18:38:07 2020 -0300

    TFT Refactoring (#19192)
    
    * split tft folder in two: tft for color ui; tft_io for shared tft code
    
    * after the files got moved, now the code was moved to the right place
    
    * classic ui using TFT IO init lcd codes
    
    * feature to compile tft_io when enabled
    
    * compiling fix
    
    * lvgl spi tft working with tft io init codes
    
    * there is no need for separeted fsmc and spi class in lvgl anymore, as tft io handle everything
    
    * remove debug
    
    * base for TFT rotation and mirroring API, and ILI9488 support
    
    * ST7796S rotate and mirror support
    
    * ST7789V rotate and mirror support
    
    * ST7735 rotate and mirror support
    
    * ILI9341 rotate and mirror support
    
    * ILI9328 rotate and mirror support
    
    * R61505 rotate and mirror support
    
    * MKS TFT definitions
    
    * more configs for mks tfts
    
    * update config
    
    * naming typo
    
    * to configure the user interface
    
    * ANYCUBIC_TFT35
    
    * tft configs
    
    * support for SSD1963
    
    * tft display types
    
    * updated conditionals lcd; first board fully working with the new code - all 3 ui!
    
    * compatiblity
    
    * changed name
    
    * move classic ui file name
    
    * rename TURN -> ROTATE
    
    * GRAPHICAL_TFT_ROTATE_180 deprecated
    
    * first fsmc board fully working - chitu v5
    
    * mks robin nano v1.2 + tft 35 ok!
    
    * right pin name
    
    * anycubic tft tested in a TRIGORILLA_PRO
    
    * chitu v6
    
    * nano 32 tft orientation
    
    * mks tft43
    
    * mks tft43 rotation
    
    * fixed LONGER LK tft setup
    
    * GRAPHICAL_TFT_UPSCALE defined by the display type
    
    * better offsets defaults
    
    * Update Configuration.h
    
    * Update tft_fsmc.cpp
    
    * Update Conditionals_LCD.h
    
    * Tweak comments
    
    * update nano tests
    
    * Revert "update nano tests"
    
    This reverts commit a071ebbfad30e28855a4a5695ec8a726542a1a65.
    
    * default tft
    
    * outdated comments
    
    * to not break non-vscode builds
    
    * upscale tft 35
    
    * support tft 180 rotation for color ui
    
    * Each TFT Driver is responsible for its default color mode.
    
    * use auto detect in mks displays, because some of them could be shipped with diferent drivers
    
    * extra s
    
    * unused code
    
    * wrong -1
    
    * missing mirror options
    
    * Smaller regex pattern
    
    * Comment updates
    
    * Clean up old defines
    
    * Apply pins formatting
    
    * GRAPHICAL_TFT_ROTATE_180 => TFT_ROTATE_180
    
    * MKS_ROBIN_TFT_V1_1R
    
    * merge fix
    
    * correct resolution
    
    * auto is default, dont need be there, and it will allow the user to configure it even for named displays
    
    * to not use rotation with MKS_ROBIN_TFT_V1_1R
    
    * i like () in macros
    
    * avoid sleepy commits
    
    * default for st7789 is rgb
    
    * nano follow up
    
    * to allow ili9328 rotation
    
    * default is rgb
    
    * boards merge follow up
    
    * to match bootloader orientation
    
    * HAS_TOUCH_XPT2046 is not hal specific anymore
    
    * lets not forget LPC
    
    * 180 rotation for ili9328 and R61505
    
    * Clean up whitespace
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/SPI_TFT.cpp b/Marlin/src/lcd/extui/lib/mks_ui/SPI_TFT.cpp
index 351d033d01..394ce48075 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/SPI_TFT.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/SPI_TFT.cpp
@@ -15,166 +15,74 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 #include "../../../../inc/MarlinConfigPre.h"
 
-#if ENABLED(TFT_LVGL_UI_SPI)
+#if HAS_TFT_LVGL_UI
 
 #include "SPI_TFT.h"
 #include "pic_manager.h"
 #include "tft_lvgl_configuration.h"
 
 #include "../../../../inc/MarlinConfig.h"
 
 #include <SPI.h>
 
+#include "draw_ui.h"
+
 TFT SPI_TFT;
 
 // use SPI1 for the spi tft.
 void TFT::spi_init(uint8_t spiRate) {
   tftio.Init();
 }
 
-void TFT::LCD_WR_REG(uint8_t cmd) {
-  tftio.WriteReg(cmd);
-}
-
-void TFT::LCD_WR_DATA(uint8_t data) {
-  tftio.WriteData(data);
-}
-
 void TFT::SetPoint(uint16_t x, uint16_t y, uint16_t point) {
   if ((x > 480) || (y > 320)) return;
 
-  SetWindows(x, y, 1, 1);
+  setWindow(x, y, 1, 1);
   tftio.WriteMultiple(point, (uint16_t)1);
 }
 
-void TFT::SetWindows(uint16_t x, uint16_t y, uint16_t with, uint16_t height) {
-  tftio.DataTransferBegin(DATASIZE_8BIT);
-
-  LCD_WR_REG(0x2A);
-  LCD_WR_DATA(x >> 8);
-  LCD_WR_DATA(x);
-  LCD_WR_DATA((x + with - 1) >> 8);
-  LCD_WR_DATA((x + with - 1));
-
-  LCD_WR_REG(0x2B);
-  LCD_WR_DATA(y >> 8);
-  LCD_WR_DATA(y);
-  LCD_WR_DATA((y + height - 1) >> 8);
-  LCD_WR_DATA(y + height - 1);
-
-  LCD_WR_REG(0X2C);
-
-  tftio.DataTransferEnd();
+void TFT::setWindow(uint16_t x, uint16_t y, uint16_t with, uint16_t height) {
+  tftio.set_window(x, y, (x + with - 1), (y + height - 1));
 }
 
 void TFT::LCD_init() {
-  TFT_BLK_L;
-  TFT_RST_H;
-  delay(150);
-  TFT_RST_L;
-  delay(150);
-  TFT_RST_H;
-
-  tftio.DataTransferBegin(DATASIZE_8BIT);
-
-  delay(120);
-  LCD_WR_REG(0x11);
-  delay(120);
-
-  LCD_WR_REG(0xF0);
-  LCD_WR_DATA(0xC3);
-  LCD_WR_REG(0xF0);
-  LCD_WR_DATA(0x96);
-
-  LCD_WR_REG(0x36);
-  LCD_WR_DATA(0x28 + TERN0(GRAPHICAL_TFT_ROTATE_180, 0x80));
-  LCD_WR_REG(0x3A);
-  LCD_WR_DATA(0x55);
-
-  LCD_WR_REG(0xB4);
-  LCD_WR_DATA(0x01);
-  LCD_WR_REG(0xB7);
-  LCD_WR_DATA(0xC6);
-  LCD_WR_REG(0xE8);
-  LCD_WR_DATA(0x40);
-  LCD_WR_DATA(0x8A);
-  LCD_WR_DATA(0x00);
-  LCD_WR_DATA(0x00);
-  LCD_WR_DATA(0x29);
-  LCD_WR_DATA(0x19);
-  LCD_WR_DATA(0xA5);
-  LCD_WR_DATA(0x33);
-  LCD_WR_REG(0xC1);
-  LCD_WR_DATA(0x06);
-  LCD_WR_REG(0xC2);
-  LCD_WR_DATA(0xA7);
-  LCD_WR_REG(0xC5);
-  LCD_WR_DATA(0x18);
-  LCD_WR_REG(0xE0);     // Positive Voltage Gamma Control
-  LCD_WR_DATA(0xF0);
-  LCD_WR_DATA(0x09);
-  LCD_WR_DATA(0x0B);
-  LCD_WR_DATA(0x06);
-  LCD_WR_DATA(0x04);
-  LCD_WR_DATA(0x15);
-  LCD_WR_DATA(0x2F);
-  LCD_WR_DATA(0x54);
-  LCD_WR_DATA(0x42);
-  LCD_WR_DATA(0x3C);
-  LCD_WR_DATA(0x17);
-  LCD_WR_DATA(0x14);
-  LCD_WR_DATA(0x18);
-  LCD_WR_DATA(0x1B);
-  LCD_WR_REG(0xE1);     // Negative Voltage Gamma Control
-  LCD_WR_DATA(0xF0);
-  LCD_WR_DATA(0x09);
-  LCD_WR_DATA(0x0B);
-  LCD_WR_DATA(0x06);
-  LCD_WR_DATA(0x04);
-  LCD_WR_DATA(0x03);
-  LCD_WR_DATA(0x2D);
-  LCD_WR_DATA(0x43);
-  LCD_WR_DATA(0x42);
-  LCD_WR_DATA(0x3B);
-  LCD_WR_DATA(0x16);
-  LCD_WR_DATA(0x14);
-  LCD_WR_DATA(0x17);
-  LCD_WR_DATA(0x1B);
-  LCD_WR_REG(0xF0);
-  LCD_WR_DATA(0x3C);
-  LCD_WR_REG(0xF0);
-  LCD_WR_DATA(0x69);
-  delay(120);     // Delay 120ms
-  LCD_WR_REG(0x29);     // Display ON
-
-  tftio.DataTransferEnd();
-
-  LCD_clear(0x0000);    //
+  tftio.InitTFT();
+  #if PIN_EXISTS(TFT_BACKLIGHT)
+    OUT_WRITE(TFT_BACKLIGHT_PIN, LOW);
+  #endif
+  delay(100);
+  LCD_clear(0x0000);
   LCD_Draw_Logo();
-  TFT_BLK_H;
-  delay(2000);
+  #if PIN_EXISTS(TFT_BACKLIGHT)
+    OUT_WRITE(TFT_BACKLIGHT_PIN, HIGH);
+  #endif
+  #if HAS_LOGO_IN_FLASH
+    delay(2000);
+  #endif
 }
 
 void TFT::LCD_clear(uint16_t color) {
-  SetWindows(0, 0, (TFT_WIDTH) - 1, (TFT_HEIGHT) - 1);
+  setWindow(0, 0, (TFT_WIDTH), (TFT_HEIGHT));
   tftio.WriteMultiple(color, (uint32_t)(TFT_WIDTH) * (TFT_HEIGHT));
 }
 
 extern unsigned char bmp_public_buf[17 * 1024];
 
 void TFT::LCD_Draw_Logo() {
-  SetWindows(0, 0, TFT_WIDTH, TFT_HEIGHT);
-  for (uint16_t i = 0; i < (TFT_HEIGHT); i ++) {
-    Pic_Logo_Read((uint8_t *)"", (uint8_t *)bmp_public_buf, (TFT_WIDTH) * 2);
-    tftio.WriteSequence((uint16_t *)bmp_public_buf, TFT_WIDTH);
-  }
+  #if HAS_LOGO_IN_FLASH
+    setWindow(0, 0, TFT_WIDTH, TFT_HEIGHT);
+    for (uint16_t i = 0; i < (TFT_HEIGHT); i ++) {
+      Pic_Logo_Read((uint8_t *)"", (uint8_t *)bmp_public_buf, (TFT_WIDTH) * 2);
+      tftio.WriteSequence((uint16_t *)bmp_public_buf, TFT_WIDTH);
+    }
+  #endif
 }
 
-#endif // HAS_TFT_LVGL_UI_SPI
+#endif // HAS_TFT_LVGL_UI

commit d8ed74904559aa8bdccc8b68acbccfbf1bf779d3
Author: makerbase <4164049@qq.com>
Date:   Mon Sep 21 09:55:02 2020 +0800

    Add MKS Robin E3P, improve LVGL UI (#19442)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/SPI_TFT.cpp b/Marlin/src/lcd/extui/lib/mks_ui/SPI_TFT.cpp
index ea94d6c1a5..351d033d01 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/SPI_TFT.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/SPI_TFT.cpp
@@ -19,20 +19,21 @@
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 #include "../../../../inc/MarlinConfigPre.h"
 
 #if ENABLED(TFT_LVGL_UI_SPI)
 
 #include "SPI_TFT.h"
 #include "pic_manager.h"
+#include "tft_lvgl_configuration.h"
 
 #include "../../../../inc/MarlinConfig.h"
 
 #include <SPI.h>
 
 TFT SPI_TFT;
 
 // use SPI1 for the spi tft.
 void TFT::spi_init(uint8_t spiRate) {
   tftio.Init();
@@ -67,40 +68,40 @@ void TFT::SetWindows(uint16_t x, uint16_t y, uint16_t with, uint16_t height) {
   LCD_WR_DATA(y);
   LCD_WR_DATA((y + height - 1) >> 8);
   LCD_WR_DATA(y + height - 1);
 
   LCD_WR_REG(0X2C);
 
   tftio.DataTransferEnd();
 }
 
 void TFT::LCD_init() {
+  TFT_BLK_L;
   TFT_RST_H;
   delay(150);
   TFT_RST_L;
   delay(150);
   TFT_RST_H;
 
   tftio.DataTransferBegin(DATASIZE_8BIT);
 
   delay(120);
   LCD_WR_REG(0x11);
   delay(120);
 
   LCD_WR_REG(0xF0);
   LCD_WR_DATA(0xC3);
   LCD_WR_REG(0xF0);
   LCD_WR_DATA(0x96);
 
   LCD_WR_REG(0x36);
-  LCD_WR_DATA(0x28);
-
+  LCD_WR_DATA(0x28 + TERN0(GRAPHICAL_TFT_ROTATE_180, 0x80));
   LCD_WR_REG(0x3A);
   LCD_WR_DATA(0x55);
 
   LCD_WR_REG(0xB4);
   LCD_WR_DATA(0x01);
   LCD_WR_REG(0xB7);
   LCD_WR_DATA(0xC6);
   LCD_WR_REG(0xE8);
   LCD_WR_DATA(0x40);
   LCD_WR_DATA(0x8A);

commit a37cf2490054ece3c16f0caca26a02c3d33057c8
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Fri Aug 21 20:54:21 2020 -0300

    Emulated DOGM via HAL TFT, XPT IO (#19017)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/SPI_TFT.cpp b/Marlin/src/lcd/extui/lib/mks_ui/SPI_TFT.cpp
index 607090ba39..ea94d6c1a5 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/SPI_TFT.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/SPI_TFT.cpp
@@ -26,39 +26,20 @@
 
 #include "SPI_TFT.h"
 #include "pic_manager.h"
 
 #include "../../../../inc/MarlinConfig.h"
 
 #include <SPI.h>
 
 TFT SPI_TFT;
 
-#ifndef SPI_TFT_MISO_PIN
-  #define SPI_TFT_MISO_PIN PA6
-#endif
-#ifndef SPI_TFT_MOSI_PIN
-  #define SPI_TFT_MOSI_PIN PA7
-#endif
-#ifndef SPI_TFT_SCK_PIN
-  #define SPI_TFT_SCK_PIN  PA5
-#endif
-#ifndef SPI_TFT_CS_PIN
-  #define SPI_TFT_CS_PIN   PD11
-#endif
-#ifndef SPI_TFT_DC_PIN
-  #define SPI_TFT_DC_PIN   PD10
-#endif
-#ifndef SPI_TFT_RST_PIN
-  #define SPI_TFT_RST_PIN  PC6
-#endif
-
 // use SPI1 for the spi tft.
 void TFT::spi_init(uint8_t spiRate) {
   tftio.Init();
 }
 
 void TFT::LCD_WR_REG(uint8_t cmd) {
   tftio.WriteReg(cmd);
 }
 
 void TFT::LCD_WR_DATA(uint8_t data) {
@@ -86,25 +67,25 @@ void TFT::SetWindows(uint16_t x, uint16_t y, uint16_t with, uint16_t height) {
   LCD_WR_DATA(y);
   LCD_WR_DATA((y + height - 1) >> 8);
   LCD_WR_DATA(y + height - 1);
 
   LCD_WR_REG(0X2C);
 
   tftio.DataTransferEnd();
 }
 
 void TFT::LCD_init() {
-  SPI_TFT_RST_H;
+  TFT_RST_H;
   delay(150);
-  SPI_TFT_RST_L;
+  TFT_RST_L;
   delay(150);
-  SPI_TFT_RST_H;
+  TFT_RST_H;
 
   tftio.DataTransferBegin(DATASIZE_8BIT);
 
   delay(120);
   LCD_WR_REG(0x11);
   delay(120);
 
   LCD_WR_REG(0xF0);
   LCD_WR_DATA(0xC3);
   LCD_WR_REG(0xF0);
@@ -169,30 +150,30 @@ void TFT::LCD_init() {
   LCD_WR_DATA(0x3C);
   LCD_WR_REG(0xF0);
   LCD_WR_DATA(0x69);
   delay(120);     // Delay 120ms
   LCD_WR_REG(0x29);     // Display ON
 
   tftio.DataTransferEnd();
 
   LCD_clear(0x0000);    //
   LCD_Draw_Logo();
-  SPI_TFT_BLK_H;
+  TFT_BLK_H;
   delay(2000);
 }
 
 void TFT::LCD_clear(uint16_t color) {
-  SetWindows(0, 0, (LCD_FULL_PIXEL_WIDTH) - 1, (LCD_FULL_PIXEL_HEIGHT) - 1);
-  tftio.WriteMultiple(color, (uint32_t)(LCD_FULL_PIXEL_WIDTH) * (LCD_FULL_PIXEL_HEIGHT));
+  SetWindows(0, 0, (TFT_WIDTH) - 1, (TFT_HEIGHT) - 1);
+  tftio.WriteMultiple(color, (uint32_t)(TFT_WIDTH) * (TFT_HEIGHT));
 }
 
 extern unsigned char bmp_public_buf[17 * 1024];
 
 void TFT::LCD_Draw_Logo() {
-  SetWindows(0, 0, LCD_FULL_PIXEL_WIDTH, LCD_FULL_PIXEL_HEIGHT);
-  for (uint16_t i = 0; i < (LCD_FULL_PIXEL_HEIGHT); i ++) {
-    Pic_Logo_Read((uint8_t *)"", (uint8_t *)bmp_public_buf, (LCD_FULL_PIXEL_WIDTH) * 2);
-    tftio.WriteSequence((uint16_t *)bmp_public_buf, LCD_FULL_PIXEL_WIDTH);
+  SetWindows(0, 0, TFT_WIDTH, TFT_HEIGHT);
+  for (uint16_t i = 0; i < (TFT_HEIGHT); i ++) {
+    Pic_Logo_Read((uint8_t *)"", (uint8_t *)bmp_public_buf, (TFT_WIDTH) * 2);
+    tftio.WriteSequence((uint16_t *)bmp_public_buf, TFT_WIDTH);
   }
 }
 
 #endif // HAS_TFT_LVGL_UI_SPI

commit ff5c8d35705df99f385a6b27163380a249c2e646
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Thu Aug 13 20:31:59 2020 -0300

    Optimize LVGL with HAL TFT IO (SPI and FSMC) (#18974)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/SPI_TFT.cpp b/Marlin/src/lcd/extui/lib/mks_ui/SPI_TFT.cpp
index 0febc4edbd..607090ba39 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/SPI_TFT.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/SPI_TFT.cpp
@@ -47,146 +47,67 @@ TFT SPI_TFT;
 #endif
 #ifndef SPI_TFT_DC_PIN
   #define SPI_TFT_DC_PIN   PD10
 #endif
 #ifndef SPI_TFT_RST_PIN
   #define SPI_TFT_RST_PIN  PC6
 #endif
 
 // use SPI1 for the spi tft.
 void TFT::spi_init(uint8_t spiRate) {
-
-  SPI_TFT_CS_H;
-
-  /**
-   * STM32F1 APB2 = 72MHz, APB1 = 36MHz, max SPI speed of this MCU if 18Mhz
-   * STM32F1 has 3 SPI ports, SPI1 in APB2, SPI2/SPI3 in APB1
-   * so the minimum prescale of SPI1 is DIV4, SPI2/SPI3 is DIV2
-   */
-  uint8_t clock;
-  switch (spiRate) {
-    case SPI_FULL_SPEED:    clock = SPI_CLOCK_DIV4;  break;
-    case SPI_HALF_SPEED:    clock = SPI_CLOCK_DIV4; break;
-    case SPI_QUARTER_SPEED: clock = SPI_CLOCK_DIV8; break;
-    case SPI_EIGHTH_SPEED:  clock = SPI_CLOCK_DIV16; break;
-    case SPI_SPEED_5:       clock = SPI_CLOCK_DIV32; break;
-    case SPI_SPEED_6:       clock = SPI_CLOCK_DIV64; break;
-    default:                clock = SPI_CLOCK_DIV2;        // Default from the SPI library
-  }
-  SPI.setModule(1);
-  SPI.begin();
-  SPI.setClockDivider(clock);
-  SPI.setBitOrder(MSBFIRST);
-  SPI.setDataMode(SPI_MODE0);
-}
-
-uint8_t TFT::spi_Rec() {
-  uint8_t returnByte = SPI.transfer(ff);
-  return returnByte;
-}
-
-uint8_t TFT::spi_read_write_byte(uint8_t data) {
-  uint8_t returnByte = SPI.transfer(data);
-  return returnByte;
-}
-
-/**
- * @brief  Receive a number of bytes from the SPI port to a buffer
- *
- * @param  buf   Pointer to starting address of buffer to write to.
- * @param  nbyte Number of bytes to receive.
- * @return Nothing
- *
- * @details Uses DMA
- */
-void TFT::spi_Read(uint8_t* buf, uint16_t nbyte) {SPI.dmaTransfer(0, const_cast<uint8_t*>(buf), nbyte);}
-
-/**
- * @brief  Send a single byte on SPI port
- *
- * @param  b Byte to send
- *
- * @details
- */
-void TFT::spi_Send(uint8_t b) {SPI.send(b);}
-
-/**
- * @brief  Write token and then write from 512 byte buffer to SPI (for SD card)
- *
- * @param  buf   Pointer with buffer start address
- * @return Nothing
- *
- * @details Use DMA
- */
-void TFT::spi_SendBlock(uint8_t token, const uint8_t* buf) {
-  SPI.send(token);
-  SPI.dmaSend(const_cast<uint8_t*>(buf), 512);
+  tftio.Init();
 }
 
 void TFT::LCD_WR_REG(uint8_t cmd) {
-  SPI_TFT_CS_L;
-  SPI_TFT_DC_L;
-  spi_Send(cmd);
-  SPI_TFT_CS_H;
+  tftio.WriteReg(cmd);
 }
-void TFT::LCD_WR_DATA(uint8_t data) {
-  SPI_TFT_CS_L;
-  SPI_TFT_DC_H;
-  spi_Send(data);
-  SPI_TFT_CS_H;
-}
-void TFT::LCD_WriteRAM_Prepare() {LCD_WR_REG(0X2C);}
-void TFT::SetCursor(uint16_t x, uint16_t y) {
-  LCD_WR_REG(0x2A);
-  LCD_WR_DATA(x >> 8);
-  LCD_WR_DATA(x);
-  LCD_WR_DATA(x >> 8);
-  LCD_WR_DATA(x);
 
-  LCD_WR_REG(0x2B);
-  LCD_WR_DATA(y >> 8);
-  LCD_WR_DATA(y);
-  LCD_WR_DATA(y >> 8);
-  LCD_WR_DATA(y);
+void TFT::LCD_WR_DATA(uint8_t data) {
+  tftio.WriteData(data);
 }
 
 void TFT::SetPoint(uint16_t x, uint16_t y, uint16_t point) {
   if ((x > 480) || (y > 320)) return;
 
-  SetCursor(x, y);
-
-  LCD_WriteRAM_Prepare();
-  LCD_WR_DATA((uint8_t)(point >> 8));
-  LCD_WR_DATA((uint8_t)point);
+  SetWindows(x, y, 1, 1);
+  tftio.WriteMultiple(point, (uint16_t)1);
 }
 
 void TFT::SetWindows(uint16_t x, uint16_t y, uint16_t with, uint16_t height) {
+  tftio.DataTransferBegin(DATASIZE_8BIT);
+
   LCD_WR_REG(0x2A);
   LCD_WR_DATA(x >> 8);
   LCD_WR_DATA(x);
   LCD_WR_DATA((x + with - 1) >> 8);
   LCD_WR_DATA((x + with - 1));
 
   LCD_WR_REG(0x2B);
   LCD_WR_DATA(y >> 8);
   LCD_WR_DATA(y);
   LCD_WR_DATA((y + height - 1) >> 8);
   LCD_WR_DATA(y + height - 1);
+
+  LCD_WR_REG(0X2C);
+
+  tftio.DataTransferEnd();
 }
 
 void TFT::LCD_init() {
   SPI_TFT_RST_H;
   delay(150);
   SPI_TFT_RST_L;
   delay(150);
   SPI_TFT_RST_H;
 
+  tftio.DataTransferBegin(DATASIZE_8BIT);
+
   delay(120);
   LCD_WR_REG(0x11);
   delay(120);
 
   LCD_WR_REG(0xF0);
   LCD_WR_DATA(0xC3);
   LCD_WR_REG(0xF0);
   LCD_WR_DATA(0x96);
 
   LCD_WR_REG(0x36);
@@ -244,95 +165,34 @@ void TFT::LCD_init() {
   LCD_WR_DATA(0x14);
   LCD_WR_DATA(0x17);
   LCD_WR_DATA(0x1B);
   LCD_WR_REG(0xF0);
   LCD_WR_DATA(0x3C);
   LCD_WR_REG(0xF0);
   LCD_WR_DATA(0x69);
   delay(120);     // Delay 120ms
   LCD_WR_REG(0x29);     // Display ON
 
+  tftio.DataTransferEnd();
+
   LCD_clear(0x0000);    //
   LCD_Draw_Logo();
   SPI_TFT_BLK_H;
   delay(2000);
 }
 
 void TFT::LCD_clear(uint16_t color) {
-  unsigned int i;
-  uint8_t tbuf[960];
-
-  SetCursor(0, 0);
-  SetWindows(0, 0, 480 - 1, 320 - 1);
-  LCD_WriteRAM_Prepare();
-  SPI_TFT_CS_L;
-  SPI_TFT_DC_H;
-  for (i = 0; i < 960;) {
-    tbuf[i]     = color >> 8;
-    tbuf[i + 1] = color;
-    i += 2;
-  }
-  for (i = 0; i < 320; i++) {
-    // for (m=0;m<480;m++)
-    // {
-    // LCD_WR_DATA(color>>8);
-    // LCD_WR_DATA(color);
-    SPI.dmaSend(tbuf, 960, true);
-    // SPI_TFT_CS_H;
-    // }
-  }
-  SPI_TFT_CS_H;
+  SetWindows(0, 0, (LCD_FULL_PIXEL_WIDTH) - 1, (LCD_FULL_PIXEL_HEIGHT) - 1);
+  tftio.WriteMultiple(color, (uint32_t)(LCD_FULL_PIXEL_WIDTH) * (LCD_FULL_PIXEL_HEIGHT));
 }
 
 extern unsigned char bmp_public_buf[17 * 1024];
 
 void TFT::LCD_Draw_Logo() {
-  uint16_t i,y_off = 0;
-  uint16_t *p_index;
-  uint16_t Color;
-
-  #if 1
-    for (y_off = 0; y_off < 320; y_off ++) {
-      Pic_Logo_Read((uint8_t *)"", (uint8_t *)bmp_public_buf, 960);
-
-      SPI_TFT.spi_init(SPI_FULL_SPEED);
-      SetWindows(0, y_off, 480, 1);
-      LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
-      for (i = 0; i < 960;) {
-        p_index = (uint16_t *)(&bmp_public_buf[i]);
-        Color = (*p_index >> 8);
-        *p_index = Color | ((*p_index & 0xFF) << 8);
-        i+=2;
-      }
-      SPI_TFT_CS_L;
-      SPI_TFT_DC_H;
-      SPI.dmaSend(bmp_public_buf,960,true);
-      SPI_TFT_CS_H;
-    }
-
-  #else
-
-    for (index = 0; index < 40; index ++) {
-      Pic_Logo_Read((uint8_t *)"", bmp_public_buf, 480*8*2);
-      i = 0;
-      SetCursor(0,0);
-      SetWindows(0, y_off * 8, 480, 8);
-      LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
-      for (i = 0; i < 480 * 8 * 2;) {
-        p_index = (uint16_t *)(&bmp_public_buf[i]);
-        Color = (*p_index >> 8);
-        *p_index = Color | ((*p_index & 0xFF) << 8);
-        i += 2;
-      }
-      SPI_TFT_CS_L;
-      SPI_TFT_DC_H;
-      SPI.dmaSend(bmp_public_buf,480*8*2,true);
-      SPI_TFT_CS_H;
-
-      y_off++;
-    }
-  #endif
-
-  SetWindows(0, 0, 479, 319);
+  SetWindows(0, 0, LCD_FULL_PIXEL_WIDTH, LCD_FULL_PIXEL_HEIGHT);
+  for (uint16_t i = 0; i < (LCD_FULL_PIXEL_HEIGHT); i ++) {
+    Pic_Logo_Read((uint8_t *)"", (uint8_t *)bmp_public_buf, (LCD_FULL_PIXEL_WIDTH) * 2);
+    tftio.WriteSequence((uint16_t *)bmp_public_buf, LCD_FULL_PIXEL_WIDTH);
+  }
 }
 
 #endif // HAS_TFT_LVGL_UI_SPI

commit d20d4591321aa467c062f0050355d2aca84e03ad
Author: MKS-Sean <56996910+MKS-Sean@users.noreply.github.com>
Date:   Sat Jul 25 13:52:07 2020 +0800

    Robin nano V2, TFT LVGL UI parameters, and more (#18500)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/SPI_TFT.cpp b/Marlin/src/lcd/extui/lib/mks_ui/SPI_TFT.cpp
index 3c6cffb20d..0febc4edbd 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/SPI_TFT.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/SPI_TFT.cpp
@@ -15,257 +15,324 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 #include "../../../../inc/MarlinConfigPre.h"
 
-#if ENABLED(SPI_GRAPHICAL_TFT)
+#if ENABLED(TFT_LVGL_UI_SPI)
 
-  #include <SPI.h>
-  #include "../../../../inc/MarlinConfig.h"
-  #include "SPI_TFT.h"
+#include "SPI_TFT.h"
+#include "pic_manager.h"
 
-  TFT SPI_TFT;
+#include "../../../../inc/MarlinConfig.h"
 
-  #ifndef SPI_TFT_MISO_PIN
-    #define SPI_TFT_MISO_PIN PA6
-  #endif
-  #ifndef SPI_TFT_MOSI_PIN
-    #define SPI_TFT_MOSI_PIN PA7
-  #endif
-  #ifndef SPI_TFT_SCK_PIN
-    #define SPI_TFT_SCK_PIN  PA5
-  #endif
-  #ifndef SPI_TFT_CS_PIN
-    #define SPI_TFT_CS_PIN   PD11
-  #endif
-  #ifndef SPI_TFT_DC_PIN
-    #define SPI_TFT_DC_PIN   PD10
-  #endif
-  #ifndef SPI_TFT_RST_PIN
-    #define SPI_TFT_RST_PIN   PC6
-  #endif
+#include <SPI.h>
+
+TFT SPI_TFT;
+
+#ifndef SPI_TFT_MISO_PIN
+  #define SPI_TFT_MISO_PIN PA6
+#endif
+#ifndef SPI_TFT_MOSI_PIN
+  #define SPI_TFT_MOSI_PIN PA7
+#endif
+#ifndef SPI_TFT_SCK_PIN
+  #define SPI_TFT_SCK_PIN  PA5
+#endif
+#ifndef SPI_TFT_CS_PIN
+  #define SPI_TFT_CS_PIN   PD11
+#endif
+#ifndef SPI_TFT_DC_PIN
+  #define SPI_TFT_DC_PIN   PD10
+#endif
+#ifndef SPI_TFT_RST_PIN
+  #define SPI_TFT_RST_PIN  PC6
+#endif
 
 // use SPI1 for the spi tft.
-  void TFT::spi_init(uint8_t spiRate) {
-
-    SPI_TFT_CS_H;
-
-    /**
-     * STM32F1 APB2 = 72MHz, APB1 = 36MHz, max SPI speed of this MCU if 18Mhz
-     * STM32F1 has 3 SPI ports, SPI1 in APB2, SPI2/SPI3 in APB1
-     * so the minimum prescale of SPI1 is DIV4, SPI2/SPI3 is DIV2
-     */
-    uint8_t clock;
-    switch (spiRate) {
-      case SPI_FULL_SPEED:    clock = SPI_CLOCK_DIV4;  break;
-      case SPI_HALF_SPEED:    clock = SPI_CLOCK_DIV4; break;
-      case SPI_QUARTER_SPEED: clock = SPI_CLOCK_DIV8; break;
-      case SPI_EIGHTH_SPEED:  clock = SPI_CLOCK_DIV16; break;
-      case SPI_SPEED_5:       clock = SPI_CLOCK_DIV32; break;
-      case SPI_SPEED_6:       clock = SPI_CLOCK_DIV64; break;
-      default:                clock = SPI_CLOCK_DIV2;        // Default from the SPI library
-    }
-    SPI.setModule(1);
-    SPI.begin();
-    SPI.setClockDivider(clock);
-    SPI.setBitOrder(MSBFIRST);
-    SPI.setDataMode(SPI_MODE0);
-  }
+void TFT::spi_init(uint8_t spiRate) {
 
-  uint8_t TFT::spi_Rec() {
-    uint8_t returnByte = SPI.transfer(ff);
-    return returnByte;
-  }
+  SPI_TFT_CS_H;
 
-  uint8_t TFT::spi_read_write_byte(uint8_t data) {
-    uint8_t returnByte = SPI.transfer(data);
-    return returnByte;
+  /**
+   * STM32F1 APB2 = 72MHz, APB1 = 36MHz, max SPI speed of this MCU if 18Mhz
+   * STM32F1 has 3 SPI ports, SPI1 in APB2, SPI2/SPI3 in APB1
+   * so the minimum prescale of SPI1 is DIV4, SPI2/SPI3 is DIV2
+   */
+  uint8_t clock;
+  switch (spiRate) {
+    case SPI_FULL_SPEED:    clock = SPI_CLOCK_DIV4;  break;
+    case SPI_HALF_SPEED:    clock = SPI_CLOCK_DIV4; break;
+    case SPI_QUARTER_SPEED: clock = SPI_CLOCK_DIV8; break;
+    case SPI_EIGHTH_SPEED:  clock = SPI_CLOCK_DIV16; break;
+    case SPI_SPEED_5:       clock = SPI_CLOCK_DIV32; break;
+    case SPI_SPEED_6:       clock = SPI_CLOCK_DIV64; break;
+    default:                clock = SPI_CLOCK_DIV2;        // Default from the SPI library
   }
+  SPI.setModule(1);
+  SPI.begin();
+  SPI.setClockDivider(clock);
+  SPI.setBitOrder(MSBFIRST);
+  SPI.setDataMode(SPI_MODE0);
+}
+
+uint8_t TFT::spi_Rec() {
+  uint8_t returnByte = SPI.transfer(ff);
+  return returnByte;
+}
+
+uint8_t TFT::spi_read_write_byte(uint8_t data) {
+  uint8_t returnByte = SPI.transfer(data);
+  return returnByte;
+}
 
 /**
  * @brief  Receive a number of bytes from the SPI port to a buffer
  *
  * @param  buf   Pointer to starting address of buffer to write to.
  * @param  nbyte Number of bytes to receive.
  * @return Nothing
  *
  * @details Uses DMA
  */
-  void TFT::spi_Read(uint8_t* buf, uint16_t nbyte) {SPI.dmaTransfer(0, const_cast<uint8_t*>(buf), nbyte);}
+void TFT::spi_Read(uint8_t* buf, uint16_t nbyte) {SPI.dmaTransfer(0, const_cast<uint8_t*>(buf), nbyte);}
 
 /**
  * @brief  Send a single byte on SPI port
  *
  * @param  b Byte to send
  *
  * @details
  */
-  void TFT::spi_Send(uint8_t b) {SPI.send(b);}
+void TFT::spi_Send(uint8_t b) {SPI.send(b);}
 
 /**
  * @brief  Write token and then write from 512 byte buffer to SPI (for SD card)
  *
  * @param  buf   Pointer with buffer start address
  * @return Nothing
  *
  * @details Use DMA
  */
-  void TFT::spi_SendBlock(uint8_t token, const uint8_t* buf) {
-    SPI.send(token);
-    SPI.dmaSend(const_cast<uint8_t*>(buf), 512);
-  }
+void TFT::spi_SendBlock(uint8_t token, const uint8_t* buf) {
+  SPI.send(token);
+  SPI.dmaSend(const_cast<uint8_t*>(buf), 512);
+}
 
-  void TFT::LCD_WR_REG(uint8_t cmd) {
-    SPI_TFT_CS_L;
-    SPI_TFT_DC_L;
-    spi_Send(cmd);
-    SPI_TFT_CS_H;
-  }
-  void TFT::LCD_WR_DATA(uint8_t data) {
-    SPI_TFT_CS_L;
-    SPI_TFT_DC_H;
-    spi_Send(data);
-    SPI_TFT_CS_H;
-  }
-  void TFT::LCD_WriteRAM_Prepare() {LCD_WR_REG(0X2C);}
-  void TFT::SetCursor(uint16_t x, uint16_t y) {
-    LCD_WR_REG(0x2a);
-    LCD_WR_DATA(x >> 8);
-    LCD_WR_DATA(x);
-    LCD_WR_DATA(x >> 8);
-    LCD_WR_DATA(x);
-
-    LCD_WR_REG(0x2b);
-    LCD_WR_DATA(y >> 8);
-    LCD_WR_DATA(y);
-    LCD_WR_DATA(y >> 8);
-    LCD_WR_DATA(y);
+void TFT::LCD_WR_REG(uint8_t cmd) {
+  SPI_TFT_CS_L;
+  SPI_TFT_DC_L;
+  spi_Send(cmd);
+  SPI_TFT_CS_H;
+}
+void TFT::LCD_WR_DATA(uint8_t data) {
+  SPI_TFT_CS_L;
+  SPI_TFT_DC_H;
+  spi_Send(data);
+  SPI_TFT_CS_H;
+}
+void TFT::LCD_WriteRAM_Prepare() {LCD_WR_REG(0X2C);}
+void TFT::SetCursor(uint16_t x, uint16_t y) {
+  LCD_WR_REG(0x2A);
+  LCD_WR_DATA(x >> 8);
+  LCD_WR_DATA(x);
+  LCD_WR_DATA(x >> 8);
+  LCD_WR_DATA(x);
+
+  LCD_WR_REG(0x2B);
+  LCD_WR_DATA(y >> 8);
+  LCD_WR_DATA(y);
+  LCD_WR_DATA(y >> 8);
+  LCD_WR_DATA(y);
+}
+
+void TFT::SetPoint(uint16_t x, uint16_t y, uint16_t point) {
+  if ((x > 480) || (y > 320)) return;
+
+  SetCursor(x, y);
+
+  LCD_WriteRAM_Prepare();
+  LCD_WR_DATA((uint8_t)(point >> 8));
+  LCD_WR_DATA((uint8_t)point);
+}
+
+void TFT::SetWindows(uint16_t x, uint16_t y, uint16_t with, uint16_t height) {
+  LCD_WR_REG(0x2A);
+  LCD_WR_DATA(x >> 8);
+  LCD_WR_DATA(x);
+  LCD_WR_DATA((x + with - 1) >> 8);
+  LCD_WR_DATA((x + with - 1));
+
+  LCD_WR_REG(0x2B);
+  LCD_WR_DATA(y >> 8);
+  LCD_WR_DATA(y);
+  LCD_WR_DATA((y + height - 1) >> 8);
+  LCD_WR_DATA(y + height - 1);
+}
+
+void TFT::LCD_init() {
+  SPI_TFT_RST_H;
+  delay(150);
+  SPI_TFT_RST_L;
+  delay(150);
+  SPI_TFT_RST_H;
+
+  delay(120);
+  LCD_WR_REG(0x11);
+  delay(120);
+
+  LCD_WR_REG(0xF0);
+  LCD_WR_DATA(0xC3);
+  LCD_WR_REG(0xF0);
+  LCD_WR_DATA(0x96);
+
+  LCD_WR_REG(0x36);
+  LCD_WR_DATA(0x28);
+
+  LCD_WR_REG(0x3A);
+  LCD_WR_DATA(0x55);
+
+  LCD_WR_REG(0xB4);
+  LCD_WR_DATA(0x01);
+  LCD_WR_REG(0xB7);
+  LCD_WR_DATA(0xC6);
+  LCD_WR_REG(0xE8);
+  LCD_WR_DATA(0x40);
+  LCD_WR_DATA(0x8A);
+  LCD_WR_DATA(0x00);
+  LCD_WR_DATA(0x00);
+  LCD_WR_DATA(0x29);
+  LCD_WR_DATA(0x19);
+  LCD_WR_DATA(0xA5);
+  LCD_WR_DATA(0x33);
+  LCD_WR_REG(0xC1);
+  LCD_WR_DATA(0x06);
+  LCD_WR_REG(0xC2);
+  LCD_WR_DATA(0xA7);
+  LCD_WR_REG(0xC5);
+  LCD_WR_DATA(0x18);
+  LCD_WR_REG(0xE0);     // Positive Voltage Gamma Control
+  LCD_WR_DATA(0xF0);
+  LCD_WR_DATA(0x09);
+  LCD_WR_DATA(0x0B);
+  LCD_WR_DATA(0x06);
+  LCD_WR_DATA(0x04);
+  LCD_WR_DATA(0x15);
+  LCD_WR_DATA(0x2F);
+  LCD_WR_DATA(0x54);
+  LCD_WR_DATA(0x42);
+  LCD_WR_DATA(0x3C);
+  LCD_WR_DATA(0x17);
+  LCD_WR_DATA(0x14);
+  LCD_WR_DATA(0x18);
+  LCD_WR_DATA(0x1B);
+  LCD_WR_REG(0xE1);     // Negative Voltage Gamma Control
+  LCD_WR_DATA(0xF0);
+  LCD_WR_DATA(0x09);
+  LCD_WR_DATA(0x0B);
+  LCD_WR_DATA(0x06);
+  LCD_WR_DATA(0x04);
+  LCD_WR_DATA(0x03);
+  LCD_WR_DATA(0x2D);
+  LCD_WR_DATA(0x43);
+  LCD_WR_DATA(0x42);
+  LCD_WR_DATA(0x3B);
+  LCD_WR_DATA(0x16);
+  LCD_WR_DATA(0x14);
+  LCD_WR_DATA(0x17);
+  LCD_WR_DATA(0x1B);
+  LCD_WR_REG(0xF0);
+  LCD_WR_DATA(0x3C);
+  LCD_WR_REG(0xF0);
+  LCD_WR_DATA(0x69);
+  delay(120);     // Delay 120ms
+  LCD_WR_REG(0x29);     // Display ON
+
+  LCD_clear(0x0000);    //
+  LCD_Draw_Logo();
+  SPI_TFT_BLK_H;
+  delay(2000);
+}
+
+void TFT::LCD_clear(uint16_t color) {
+  unsigned int i;
+  uint8_t tbuf[960];
+
+  SetCursor(0, 0);
+  SetWindows(0, 0, 480 - 1, 320 - 1);
+  LCD_WriteRAM_Prepare();
+  SPI_TFT_CS_L;
+  SPI_TFT_DC_H;
+  for (i = 0; i < 960;) {
+    tbuf[i]     = color >> 8;
+    tbuf[i + 1] = color;
+    i += 2;
   }
-  void TFT::SetWindows(uint16_t x, uint16_t y, uint16_t with, uint16_t height) {
-    LCD_WR_REG(0x2a);
-    LCD_WR_DATA(x >> 8);
-    LCD_WR_DATA(x);
-    LCD_WR_DATA((x + with) >> 8);
-    LCD_WR_DATA((x + with));
-
-    LCD_WR_REG(0x2b);
-    LCD_WR_DATA(y >> 8);
-    LCD_WR_DATA(y);
-    LCD_WR_DATA((y + height) >> 8);
-    LCD_WR_DATA(y + height);
+  for (i = 0; i < 320; i++) {
+    // for (m=0;m<480;m++)
+    // {
+    // LCD_WR_DATA(color>>8);
+    // LCD_WR_DATA(color);
+    SPI.dmaSend(tbuf, 960, true);
+    // SPI_TFT_CS_H;
+    // }
   }
-  void TFT::LCD_init() {
-    SPI_TFT_RST_H;
-    delay(150);
-    SPI_TFT_RST_L;
-    delay(150);
-    SPI_TFT_RST_H;
-
-    delay(120);
-    LCD_WR_REG(0x11);
-    delay(120);
-
-    LCD_WR_REG(0xf0);
-    LCD_WR_DATA(0xc3);
-    LCD_WR_REG(0xf0);
-    LCD_WR_DATA(0x96);
-
-    LCD_WR_REG(0x36);
-    LCD_WR_DATA(0x28);
-
-    LCD_WR_REG(0x3A);
-    LCD_WR_DATA(0x55);
-
-    LCD_WR_REG(0xB4);
-    LCD_WR_DATA(0x01);
-    LCD_WR_REG(0xB7);
-    LCD_WR_DATA(0xC6);
-    LCD_WR_REG(0xe8);
-    LCD_WR_DATA(0x40);
-    LCD_WR_DATA(0x8a);
-    LCD_WR_DATA(0x00);
-    LCD_WR_DATA(0x00);
-    LCD_WR_DATA(0x29);
-    LCD_WR_DATA(0x19);
-    LCD_WR_DATA(0xa5);
-    LCD_WR_DATA(0x33);
-    LCD_WR_REG(0xc1);
-    LCD_WR_DATA(0x06);
-    LCD_WR_REG(0xc2);
-    LCD_WR_DATA(0xa7);
-    LCD_WR_REG(0xc5);
-    LCD_WR_DATA(0x18);
-    LCD_WR_REG(0xe0);     // Positive Voltage Gamma Control
-    LCD_WR_DATA(0xf0);
-    LCD_WR_DATA(0x09);
-    LCD_WR_DATA(0x0b);
-    LCD_WR_DATA(0x06);
-    LCD_WR_DATA(0x04);
-    LCD_WR_DATA(0x15);
-    LCD_WR_DATA(0x2f);
-    LCD_WR_DATA(0x54);
-    LCD_WR_DATA(0x42);
-    LCD_WR_DATA(0x3c);
-    LCD_WR_DATA(0x17);
-    LCD_WR_DATA(0x14);
-    LCD_WR_DATA(0x18);
-    LCD_WR_DATA(0x1b);
-    LCD_WR_REG(0xe1);     // Negative Voltage Gamma Control
-    LCD_WR_DATA(0xf0);
-    LCD_WR_DATA(0x09);
-    LCD_WR_DATA(0x0b);
-    LCD_WR_DATA(0x06);
-    LCD_WR_DATA(0x04);
-    LCD_WR_DATA(0x03);
-    LCD_WR_DATA(0x2d);
-    LCD_WR_DATA(0x43);
-    LCD_WR_DATA(0x42);
-    LCD_WR_DATA(0x3b);
-    LCD_WR_DATA(0x16);
-    LCD_WR_DATA(0x14);
-    LCD_WR_DATA(0x17);
-    LCD_WR_DATA(0x1b);
-    LCD_WR_REG(0xf0);
-    LCD_WR_DATA(0x3c);
-    LCD_WR_REG(0xf0);
-    LCD_WR_DATA(0x69);
-    delay(120);     // Delay 120ms
-    LCD_WR_REG(0x29);     // Display ON
-
-    LCD_clear(0x0000);    //
-    SPI_TFT_BLK_H;
+  SPI_TFT_CS_H;
+}
 
-  }
-  void TFT::LCD_clear(uint16_t color) {
-    unsigned int i, m;
-    uint32_t count;
-    uint8_t tbuf[960];
-
-    SetCursor(0, 0);
-    SetWindows(0, 0, 480 - 1, 320 - 1);
-    LCD_WriteRAM_Prepare();
-    SPI_TFT_CS_L;
-    SPI_TFT_DC_H;
-    for (i = 0; i < 960;) {
-      tbuf[i]     = color >> 8;
-      tbuf[i + 1] = color;
-      i += 2;
+extern unsigned char bmp_public_buf[17 * 1024];
+
+void TFT::LCD_Draw_Logo() {
+  uint16_t i,y_off = 0;
+  uint16_t *p_index;
+  uint16_t Color;
+
+  #if 1
+    for (y_off = 0; y_off < 320; y_off ++) {
+      Pic_Logo_Read((uint8_t *)"", (uint8_t *)bmp_public_buf, 960);
+
+      SPI_TFT.spi_init(SPI_FULL_SPEED);
+      SetWindows(0, y_off, 480, 1);
+      LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
+      for (i = 0; i < 960;) {
+        p_index = (uint16_t *)(&bmp_public_buf[i]);
+        Color = (*p_index >> 8);
+        *p_index = Color | ((*p_index & 0xFF) << 8);
+        i+=2;
+      }
+      SPI_TFT_CS_L;
+      SPI_TFT_DC_H;
+      SPI.dmaSend(bmp_public_buf,960,true);
+      SPI_TFT_CS_H;
     }
-    for (i = 0; i < 320; i++) {
-      // for(m=0;m<480;m++)
-      // {
-      // LCD_WR_DATA(color>>8);
-      // LCD_WR_DATA(color);
-
-      SPI.dmaSend(tbuf, 960, true);
-      // SPI_TFT_CS_H;
-      // }
+
+  #else
+
+    for (index = 0; index < 40; index ++) {
+      Pic_Logo_Read((uint8_t *)"", bmp_public_buf, 480*8*2);
+      i = 0;
+      SetCursor(0,0);
+      SetWindows(0, y_off * 8, 480, 8);
+      LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
+      for (i = 0; i < 480 * 8 * 2;) {
+        p_index = (uint16_t *)(&bmp_public_buf[i]);
+        Color = (*p_index >> 8);
+        *p_index = Color | ((*p_index & 0xFF) << 8);
+        i += 2;
+      }
+      SPI_TFT_CS_L;
+      SPI_TFT_DC_H;
+      SPI.dmaSend(bmp_public_buf,480*8*2,true);
+      SPI_TFT_CS_H;
+
+      y_off++;
     }
-    SPI_TFT_CS_H;
-  }
+  #endif
+
+  SetWindows(0, 0, 479, 319);
+}
 
-#endif // SPI_GRAPHICAL_TFT
+#endif // HAS_TFT_LVGL_UI_SPI

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/SPI_TFT.cpp b/Marlin/src/lcd/extui/lib/mks_ui/SPI_TFT.cpp
index 804bc6548c..3c6cffb20d 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/SPI_TFT.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/SPI_TFT.cpp
@@ -9,21 +9,21 @@
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 #include "../../../../inc/MarlinConfigPre.h"
 
 #if ENABLED(SPI_GRAPHICAL_TFT)
 
   #include <SPI.h>
   #include "../../../../inc/MarlinConfig.h"
   #include "SPI_TFT.h"

commit 642112d3eb7c1af9a52feec8134c85ed3e34891c
Author: makerbase <4164049@qq.com>
Date:   Tue Jun 16 10:05:33 2020 +0800

    Add MKS UI (TFT_LITTLE_VGL_UI) (#18071)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/SPI_TFT.cpp b/Marlin/src/lcd/extui/lib/mks_ui/SPI_TFT.cpp
new file mode 100644
index 0000000000..804bc6548c
--- /dev/null
+++ b/Marlin/src/lcd/extui/lib/mks_ui/SPI_TFT.cpp
@@ -0,0 +1,271 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "../../../../inc/MarlinConfigPre.h"
+
+#if ENABLED(SPI_GRAPHICAL_TFT)
+
+  #include <SPI.h>
+  #include "../../../../inc/MarlinConfig.h"
+  #include "SPI_TFT.h"
+
+  TFT SPI_TFT;
+
+  #ifndef SPI_TFT_MISO_PIN
+    #define SPI_TFT_MISO_PIN PA6
+  #endif
+  #ifndef SPI_TFT_MOSI_PIN
+    #define SPI_TFT_MOSI_PIN PA7
+  #endif
+  #ifndef SPI_TFT_SCK_PIN
+    #define SPI_TFT_SCK_PIN  PA5
+  #endif
+  #ifndef SPI_TFT_CS_PIN
+    #define SPI_TFT_CS_PIN   PD11
+  #endif
+  #ifndef SPI_TFT_DC_PIN
+    #define SPI_TFT_DC_PIN   PD10
+  #endif
+  #ifndef SPI_TFT_RST_PIN
+    #define SPI_TFT_RST_PIN   PC6
+  #endif
+
+// use SPI1 for the spi tft.
+  void TFT::spi_init(uint8_t spiRate) {
+
+    SPI_TFT_CS_H;
+
+    /**
+     * STM32F1 APB2 = 72MHz, APB1 = 36MHz, max SPI speed of this MCU if 18Mhz
+     * STM32F1 has 3 SPI ports, SPI1 in APB2, SPI2/SPI3 in APB1
+     * so the minimum prescale of SPI1 is DIV4, SPI2/SPI3 is DIV2
+     */
+    uint8_t clock;
+    switch (spiRate) {
+      case SPI_FULL_SPEED:    clock = SPI_CLOCK_DIV4;  break;
+      case SPI_HALF_SPEED:    clock = SPI_CLOCK_DIV4; break;
+      case SPI_QUARTER_SPEED: clock = SPI_CLOCK_DIV8; break;
+      case SPI_EIGHTH_SPEED:  clock = SPI_CLOCK_DIV16; break;
+      case SPI_SPEED_5:       clock = SPI_CLOCK_DIV32; break;
+      case SPI_SPEED_6:       clock = SPI_CLOCK_DIV64; break;
+      default:                clock = SPI_CLOCK_DIV2;        // Default from the SPI library
+    }
+    SPI.setModule(1);
+    SPI.begin();
+    SPI.setClockDivider(clock);
+    SPI.setBitOrder(MSBFIRST);
+    SPI.setDataMode(SPI_MODE0);
+  }
+
+  uint8_t TFT::spi_Rec() {
+    uint8_t returnByte = SPI.transfer(ff);
+    return returnByte;
+  }
+
+  uint8_t TFT::spi_read_write_byte(uint8_t data) {
+    uint8_t returnByte = SPI.transfer(data);
+    return returnByte;
+  }
+
+/**
+ * @brief  Receive a number of bytes from the SPI port to a buffer
+ *
+ * @param  buf   Pointer to starting address of buffer to write to.
+ * @param  nbyte Number of bytes to receive.
+ * @return Nothing
+ *
+ * @details Uses DMA
+ */
+  void TFT::spi_Read(uint8_t* buf, uint16_t nbyte) {SPI.dmaTransfer(0, const_cast<uint8_t*>(buf), nbyte);}
+
+/**
+ * @brief  Send a single byte on SPI port
+ *
+ * @param  b Byte to send
+ *
+ * @details
+ */
+  void TFT::spi_Send(uint8_t b) {SPI.send(b);}
+
+/**
+ * @brief  Write token and then write from 512 byte buffer to SPI (for SD card)
+ *
+ * @param  buf   Pointer with buffer start address
+ * @return Nothing
+ *
+ * @details Use DMA
+ */
+  void TFT::spi_SendBlock(uint8_t token, const uint8_t* buf) {
+    SPI.send(token);
+    SPI.dmaSend(const_cast<uint8_t*>(buf), 512);
+  }
+
+  void TFT::LCD_WR_REG(uint8_t cmd) {
+    SPI_TFT_CS_L;
+    SPI_TFT_DC_L;
+    spi_Send(cmd);
+    SPI_TFT_CS_H;
+  }
+  void TFT::LCD_WR_DATA(uint8_t data) {
+    SPI_TFT_CS_L;
+    SPI_TFT_DC_H;
+    spi_Send(data);
+    SPI_TFT_CS_H;
+  }
+  void TFT::LCD_WriteRAM_Prepare() {LCD_WR_REG(0X2C);}
+  void TFT::SetCursor(uint16_t x, uint16_t y) {
+    LCD_WR_REG(0x2a);
+    LCD_WR_DATA(x >> 8);
+    LCD_WR_DATA(x);
+    LCD_WR_DATA(x >> 8);
+    LCD_WR_DATA(x);
+
+    LCD_WR_REG(0x2b);
+    LCD_WR_DATA(y >> 8);
+    LCD_WR_DATA(y);
+    LCD_WR_DATA(y >> 8);
+    LCD_WR_DATA(y);
+  }
+  void TFT::SetWindows(uint16_t x, uint16_t y, uint16_t with, uint16_t height) {
+    LCD_WR_REG(0x2a);
+    LCD_WR_DATA(x >> 8);
+    LCD_WR_DATA(x);
+    LCD_WR_DATA((x + with) >> 8);
+    LCD_WR_DATA((x + with));
+
+    LCD_WR_REG(0x2b);
+    LCD_WR_DATA(y >> 8);
+    LCD_WR_DATA(y);
+    LCD_WR_DATA((y + height) >> 8);
+    LCD_WR_DATA(y + height);
+  }
+  void TFT::LCD_init() {
+    SPI_TFT_RST_H;
+    delay(150);
+    SPI_TFT_RST_L;
+    delay(150);
+    SPI_TFT_RST_H;
+
+    delay(120);
+    LCD_WR_REG(0x11);
+    delay(120);
+
+    LCD_WR_REG(0xf0);
+    LCD_WR_DATA(0xc3);
+    LCD_WR_REG(0xf0);
+    LCD_WR_DATA(0x96);
+
+    LCD_WR_REG(0x36);
+    LCD_WR_DATA(0x28);
+
+    LCD_WR_REG(0x3A);
+    LCD_WR_DATA(0x55);
+
+    LCD_WR_REG(0xB4);
+    LCD_WR_DATA(0x01);
+    LCD_WR_REG(0xB7);
+    LCD_WR_DATA(0xC6);
+    LCD_WR_REG(0xe8);
+    LCD_WR_DATA(0x40);
+    LCD_WR_DATA(0x8a);
+    LCD_WR_DATA(0x00);
+    LCD_WR_DATA(0x00);
+    LCD_WR_DATA(0x29);
+    LCD_WR_DATA(0x19);
+    LCD_WR_DATA(0xa5);
+    LCD_WR_DATA(0x33);
+    LCD_WR_REG(0xc1);
+    LCD_WR_DATA(0x06);
+    LCD_WR_REG(0xc2);
+    LCD_WR_DATA(0xa7);
+    LCD_WR_REG(0xc5);
+    LCD_WR_DATA(0x18);
+    LCD_WR_REG(0xe0);     // Positive Voltage Gamma Control
+    LCD_WR_DATA(0xf0);
+    LCD_WR_DATA(0x09);
+    LCD_WR_DATA(0x0b);
+    LCD_WR_DATA(0x06);
+    LCD_WR_DATA(0x04);
+    LCD_WR_DATA(0x15);
+    LCD_WR_DATA(0x2f);
+    LCD_WR_DATA(0x54);
+    LCD_WR_DATA(0x42);
+    LCD_WR_DATA(0x3c);
+    LCD_WR_DATA(0x17);
+    LCD_WR_DATA(0x14);
+    LCD_WR_DATA(0x18);
+    LCD_WR_DATA(0x1b);
+    LCD_WR_REG(0xe1);     // Negative Voltage Gamma Control
+    LCD_WR_DATA(0xf0);
+    LCD_WR_DATA(0x09);
+    LCD_WR_DATA(0x0b);
+    LCD_WR_DATA(0x06);
+    LCD_WR_DATA(0x04);
+    LCD_WR_DATA(0x03);
+    LCD_WR_DATA(0x2d);
+    LCD_WR_DATA(0x43);
+    LCD_WR_DATA(0x42);
+    LCD_WR_DATA(0x3b);
+    LCD_WR_DATA(0x16);
+    LCD_WR_DATA(0x14);
+    LCD_WR_DATA(0x17);
+    LCD_WR_DATA(0x1b);
+    LCD_WR_REG(0xf0);
+    LCD_WR_DATA(0x3c);
+    LCD_WR_REG(0xf0);
+    LCD_WR_DATA(0x69);
+    delay(120);     // Delay 120ms
+    LCD_WR_REG(0x29);     // Display ON
+
+    LCD_clear(0x0000);    //
+    SPI_TFT_BLK_H;
+
+  }
+  void TFT::LCD_clear(uint16_t color) {
+    unsigned int i, m;
+    uint32_t count;
+    uint8_t tbuf[960];
+
+    SetCursor(0, 0);
+    SetWindows(0, 0, 480 - 1, 320 - 1);
+    LCD_WriteRAM_Prepare();
+    SPI_TFT_CS_L;
+    SPI_TFT_DC_H;
+    for (i = 0; i < 960;) {
+      tbuf[i]     = color >> 8;
+      tbuf[i + 1] = color;
+      i += 2;
+    }
+    for (i = 0; i < 320; i++) {
+      // for(m=0;m<480;m++)
+      // {
+      // LCD_WR_DATA(color>>8);
+      // LCD_WR_DATA(color);
+
+      SPI.dmaSend(tbuf, 960, true);
+      // SPI_TFT_CS_H;
+      // }
+    }
+    SPI_TFT_CS_H;
+  }
+
+#endif // SPI_GRAPHICAL_TFT
