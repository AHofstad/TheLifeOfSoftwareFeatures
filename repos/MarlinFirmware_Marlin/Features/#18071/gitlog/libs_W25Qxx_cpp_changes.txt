commit a0e3dea8b879aba8e0d2d7e4dc6a6447b3fe76ad
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jul 20 20:25:39 2023 -0500

    üö∏ ColorUI Touch Calibrate in CW order

diff --git a/Marlin/src/libs/W25Qxx.cpp b/Marlin/src/libs/W25Qxx.cpp
index 591d0d0693..558d604ea5 100644
--- a/Marlin/src/libs/W25Qxx.cpp
+++ b/Marlin/src/libs/W25Qxx.cpp
@@ -41,24 +41,26 @@ bool flash_dma_mode = true;
 
 void W25QXXFlash::init(uint8_t spiRate) {
 
   OUT_WRITE(SPI_FLASH_CS_PIN, HIGH);
 
   /**
    * STM32F1 APB2 = 72MHz, APB1 = 36MHz, max SPI speed of this MCU if 18Mhz
    * STM32F1 has 3 SPI ports, SPI1 in APB2, SPI2/SPI3 in APB1
    * so the minimum prescale of SPI1 is DIV4, SPI2/SPI3 is DIV2
    */
-  #if SPI_DEVICE == 1
-    #define SPI_CLOCK_MAX SPI_CLOCK_DIV4
-  #else
-    #define SPI_CLOCK_MAX SPI_CLOCK_DIV2
+  #ifndef SPI_CLOCK_MAX
+    #if SPI_DEVICE == 1
+      #define SPI_CLOCK_MAX SPI_CLOCK_DIV4
+    #else
+      #define SPI_CLOCK_MAX SPI_CLOCK_DIV2
+    #endif
   #endif
   uint8_t clock;
   switch (spiRate) {
     case SPI_FULL_SPEED:    clock = SPI_CLOCK_MAX;  break;
     case SPI_HALF_SPEED:    clock = SPI_CLOCK_DIV4; break;
     case SPI_QUARTER_SPEED: clock = SPI_CLOCK_DIV8; break;
     case SPI_EIGHTH_SPEED:  clock = SPI_CLOCK_DIV16; break;
     case SPI_SPEED_5:       clock = SPI_CLOCK_DIV32; break;
     case SPI_SPEED_6:       clock = SPI_CLOCK_DIV64; break;
     default:                clock = SPI_CLOCK_DIV2;// Default from the SPI library

commit dd3b65bb1ff41deda223562b24ed230bfa0e0c2a
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Oct 17 13:01:45 2022 -0500

    üé® HAS_SPI_FLASH => SPI_FLASH

diff --git a/Marlin/src/libs/W25Qxx.cpp b/Marlin/src/libs/W25Qxx.cpp
index 033402d04a..591d0d0693 100644
--- a/Marlin/src/libs/W25Qxx.cpp
+++ b/Marlin/src/libs/W25Qxx.cpp
@@ -15,21 +15,21 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 #include "../inc/MarlinConfig.h"
 
-#if HAS_SPI_FLASH
+#if ENABLED(SPI_FLASH)
 
 #include "W25Qxx.h"
 
 W25QXXFlash W25QXX;
 
 #ifndef NC
   #define NC -1
 #endif
 
 MarlinSPI W25QXXFlash::mySPI(SPI_FLASH_MOSI_PIN, SPI_FLASH_MISO_PIN, SPI_FLASH_SCK_PIN, NC);
@@ -373,11 +373,11 @@ void W25QXXFlash::SPI_FLASH_BufferRead(uint8_t *pBuffer, uint32_t ReadAddr, uint
       // Point to the next location where the byte read will be saved
       pBuffer++;
     }
   }
   else
     spi_flash_Read(pBuffer, NumByteToRead);
 
   SPI_FLASH_CS_H();
 }
 
-#endif // HAS_SPI_FLASH
+#endif // SPI_FLASH

commit 24d1d3eb5cc4e7415e77393d35e40fb4124bc672
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jan 12 09:47:22 2022 -0600

    üí° Misc. cleanup, comments

diff --git a/Marlin/src/libs/W25Qxx.cpp b/Marlin/src/libs/W25Qxx.cpp
index b458a7c965..033402d04a 100644
--- a/Marlin/src/libs/W25Qxx.cpp
+++ b/Marlin/src/libs/W25Qxx.cpp
@@ -126,39 +126,39 @@ uint16_t W25QXXFlash::W25QXX_ReadID(void) {
   spi_flash_Send(0x90);
   spi_flash_Send(0x00);
   spi_flash_Send(0x00);
   spi_flash_Send(0x00);
   Temp |= spi_flash_Rec() << 8;
   Temp |= spi_flash_Rec();
   SPI_FLASH_CS_H();
   return Temp;
 }
 
-void W25QXXFlash::SPI_FLASH_WriteEnable(void) {
+void W25QXXFlash::SPI_FLASH_WriteEnable() {
   // Select the FLASH: Chip Select low
   SPI_FLASH_CS_L();
   // Send "Write Enable" instruction
   spi_flash_Send(W25X_WriteEnable);
   // Deselect the FLASH: Chip Select high
   SPI_FLASH_CS_H();
 }
 
 /*******************************************************************************
 * Function Name  : SPI_FLASH_WaitForWriteEnd
 * Description    : Polls the status of the Write In Progress (WIP) flag in the
 *                  FLASH's status register and loop until write operation has
 *                  completed.
 * Input          : None
 * Output         : None
 * Return         : None
 *******************************************************************************/
-void W25QXXFlash::SPI_FLASH_WaitForWriteEnd(void) {
+void W25QXXFlash::SPI_FLASH_WaitForWriteEnd() {
   uint8_t FLASH_Status = 0;
 
   // Select the FLASH: Chip Select low
   SPI_FLASH_CS_L();
   // Send "Read Status Register" instruction
   spi_flash_Send(W25X_ReadStatusReg);
 
   // Loop as long as the memory is busy with a write cycle
   do
     /* Send a dummy byte to generate the clock needed by the FLASH
@@ -209,21 +209,21 @@ void W25QXXFlash::SPI_FLASH_BlockErase(uint32_t BlockAddr) {
   SPI_FLASH_WaitForWriteEnd();
 }
 
 /*******************************************************************************
 * Function Name  : SPI_FLASH_BulkErase
 * Description    : Erases the entire FLASH.
 * Input          : None
 * Output         : None
 * Return         : None
 *******************************************************************************/
-void W25QXXFlash::SPI_FLASH_BulkErase(void) {
+void W25QXXFlash::SPI_FLASH_BulkErase() {
   // Send write enable instruction
   SPI_FLASH_WriteEnable();
 
   // Bulk Erase
   // Select the FLASH: Chip Select low
   SPI_FLASH_CS_L();
 
   // Send Bulk Erase instruction
   spi_flash_Send(W25X_ChipErase);
   // Deselect the FLASH: Chip Select high

commit c161a46112debd280dc1ed6945d50f971ff505e6
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Aug 13 16:32:25 2021 -0500

    üé® Update MKSPWC, some other pins (#22557)

diff --git a/Marlin/src/libs/W25Qxx.cpp b/Marlin/src/libs/W25Qxx.cpp
index 56581ed46e..b458a7c965 100644
--- a/Marlin/src/libs/W25Qxx.cpp
+++ b/Marlin/src/libs/W25Qxx.cpp
@@ -21,40 +21,28 @@
  */
 
 #include "../inc/MarlinConfig.h"
 
 #if HAS_SPI_FLASH
 
 #include "W25Qxx.h"
 
 W25QXXFlash W25QXX;
 
-#ifndef SPI_FLASH_MISO_PIN
-  #define SPI_FLASH_MISO_PIN W25QXX_MISO_PIN
-#endif
-#ifndef SPI_FLASH_MOSI_PIN
-  #define SPI_FLASH_MOSI_PIN W25QXX_MOSI_PIN
-#endif
-#ifndef SPI_FLASH_SCK_PIN
-  #define SPI_FLASH_SCK_PIN  W25QXX_SCK_PIN
-#endif
-#ifndef SPI_FLASH_CS_PIN
-  #define SPI_FLASH_CS_PIN   W25QXX_CS_PIN
-#endif
 #ifndef NC
   #define NC -1
 #endif
 
 MarlinSPI W25QXXFlash::mySPI(SPI_FLASH_MOSI_PIN, SPI_FLASH_MISO_PIN, SPI_FLASH_SCK_PIN, NC);
 
-#define W25QXX_CS_H OUT_WRITE(SPI_FLASH_CS_PIN, HIGH)
-#define W25QXX_CS_L OUT_WRITE(SPI_FLASH_CS_PIN, LOW)
+#define SPI_FLASH_CS_H() OUT_WRITE(SPI_FLASH_CS_PIN, HIGH)
+#define SPI_FLASH_CS_L() OUT_WRITE(SPI_FLASH_CS_PIN, LOW)
 
 bool flash_dma_mode = true;
 
 void W25QXXFlash::init(uint8_t spiRate) {
 
   OUT_WRITE(SPI_FLASH_CS_PIN, HIGH);
 
   /**
    * STM32F1 APB2 = 72MHz, APB1 = 36MHz, max SPI speed of this MCU if 18Mhz
    * STM32F1 has 3 SPI ports, SPI1 in APB2, SPI2/SPI3 in APB1
@@ -127,126 +115,126 @@ void W25QXXFlash::spi_flash_Send(uint8_t b) { mySPI.transfer(b); }
  *
  * @details Use DMA
  */
 void W25QXXFlash::spi_flash_SendBlock(uint8_t token, const uint8_t *buf) {
   mySPI.transfer(token);
   mySPI.dmaSend(const_cast<uint8_t*>(buf), 512);
 }
 
 uint16_t W25QXXFlash::W25QXX_ReadID(void) {
   uint16_t Temp = 0;
-  W25QXX_CS_L;
+  SPI_FLASH_CS_L();
   spi_flash_Send(0x90);
   spi_flash_Send(0x00);
   spi_flash_Send(0x00);
   spi_flash_Send(0x00);
   Temp |= spi_flash_Rec() << 8;
   Temp |= spi_flash_Rec();
-  W25QXX_CS_H;
+  SPI_FLASH_CS_H();
   return Temp;
 }
 
 void W25QXXFlash::SPI_FLASH_WriteEnable(void) {
   // Select the FLASH: Chip Select low
-  W25QXX_CS_L;
+  SPI_FLASH_CS_L();
   // Send "Write Enable" instruction
   spi_flash_Send(W25X_WriteEnable);
   // Deselect the FLASH: Chip Select high
-  W25QXX_CS_H;
+  SPI_FLASH_CS_H();
 }
 
 /*******************************************************************************
 * Function Name  : SPI_FLASH_WaitForWriteEnd
 * Description    : Polls the status of the Write In Progress (WIP) flag in the
 *                  FLASH's status register and loop until write operation has
 *                  completed.
 * Input          : None
 * Output         : None
 * Return         : None
 *******************************************************************************/
 void W25QXXFlash::SPI_FLASH_WaitForWriteEnd(void) {
   uint8_t FLASH_Status = 0;
 
   // Select the FLASH: Chip Select low
-  W25QXX_CS_L;
+  SPI_FLASH_CS_L();
   // Send "Read Status Register" instruction
   spi_flash_Send(W25X_ReadStatusReg);
 
   // Loop as long as the memory is busy with a write cycle
   do
     /* Send a dummy byte to generate the clock needed by the FLASH
     and put the value of the status register in FLASH_Status variable */
     FLASH_Status = spi_flash_Rec();
   while ((FLASH_Status & WIP_Flag) == 0x01); // Write in progress
 
   // Deselect the FLASH: Chip Select high
-  W25QXX_CS_H;
+  SPI_FLASH_CS_H();
 }
 
 void W25QXXFlash::SPI_FLASH_SectorErase(uint32_t SectorAddr) {
   // Send write enable instruction
   SPI_FLASH_WriteEnable();
 
   // Sector Erase
   // Select the FLASH: Chip Select low
-  W25QXX_CS_L;
+  SPI_FLASH_CS_L();
   // Send Sector Erase instruction
   spi_flash_Send(W25X_SectorErase);
   // Send SectorAddr high nybble address byte
   spi_flash_Send((SectorAddr & 0xFF0000) >> 16);
   // Send SectorAddr medium nybble address byte
   spi_flash_Send((SectorAddr & 0xFF00) >> 8);
   // Send SectorAddr low nybble address byte
   spi_flash_Send(SectorAddr & 0xFF);
   // Deselect the FLASH: Chip Select high
 
-  W25QXX_CS_H;
+  SPI_FLASH_CS_H();
   // Wait the end of Flash writing
   SPI_FLASH_WaitForWriteEnd();
 }
 
 void W25QXXFlash::SPI_FLASH_BlockErase(uint32_t BlockAddr) {
   SPI_FLASH_WriteEnable();
-  W25QXX_CS_L;
+  SPI_FLASH_CS_L();
   // Send Sector Erase instruction
   spi_flash_Send(W25X_BlockErase);
   // Send SectorAddr high nybble address byte
   spi_flash_Send((BlockAddr & 0xFF0000) >> 16);
   // Send SectorAddr medium nybble address byte
   spi_flash_Send((BlockAddr & 0xFF00) >> 8);
   // Send SectorAddr low nybble address byte
   spi_flash_Send(BlockAddr & 0xFF);
 
-  W25QXX_CS_H;
+  SPI_FLASH_CS_H();
 
   SPI_FLASH_WaitForWriteEnd();
 }
 
 /*******************************************************************************
 * Function Name  : SPI_FLASH_BulkErase
 * Description    : Erases the entire FLASH.
 * Input          : None
 * Output         : None
 * Return         : None
 *******************************************************************************/
 void W25QXXFlash::SPI_FLASH_BulkErase(void) {
   // Send write enable instruction
   SPI_FLASH_WriteEnable();
 
   // Bulk Erase
   // Select the FLASH: Chip Select low
-  W25QXX_CS_L;
+  SPI_FLASH_CS_L();
 
   // Send Bulk Erase instruction
   spi_flash_Send(W25X_ChipErase);
   // Deselect the FLASH: Chip Select high
-  W25QXX_CS_H;
+  SPI_FLASH_CS_H();
   // Wait the end of Flash writing
   SPI_FLASH_WaitForWriteEnd();
 }
 
 /*******************************************************************************
 * Function Name  : SPI_FLASH_PageWrite
 * Description    : Writes more than one byte to the FLASH with a single WRITE
 *                  cycle(Page WRITE sequence). The number of byte can't exceed
 *                  the FLASH page size.
 * Input          : - pBuffer : pointer to the buffer  containing the data to be
@@ -255,42 +243,42 @@ void W25QXXFlash::SPI_FLASH_BulkErase(void) {
 *                  - NumByteToWrite : number of bytes to write to the FLASH,
 *                    must be equal or less than "SPI_FLASH_PageSize" value.
 * Output         : None
 * Return         : None
 *******************************************************************************/
 void W25QXXFlash::SPI_FLASH_PageWrite(uint8_t *pBuffer, uint32_t WriteAddr, uint16_t NumByteToWrite) {
   // Enable the write access to the FLASH
   SPI_FLASH_WriteEnable();
 
   // Select the FLASH: Chip Select low
-  W25QXX_CS_L;
+  SPI_FLASH_CS_L();
   // Send "Write to Memory " instruction
   spi_flash_Send(W25X_PageProgram);
   // Send WriteAddr high nybble address byte to write to
   spi_flash_Send((WriteAddr & 0xFF0000) >> 16);
   // Send WriteAddr medium nybble address byte to write to
   spi_flash_Send((WriteAddr & 0xFF00) >> 8);
   // Send WriteAddr low nybble address byte to write to
   spi_flash_Send(WriteAddr & 0xFF);
 
   NOMORE(NumByteToWrite, SPI_FLASH_PerWritePageSize);
 
   // While there is data to be written on the FLASH
   while (NumByteToWrite--) {
     // Send the current byte
     spi_flash_Send(*pBuffer);
     // Point on the next byte to be written
     pBuffer++;
   }
 
   // Deselect the FLASH: Chip Select high
-  W25QXX_CS_H;
+  SPI_FLASH_CS_H();
 
   // Wait the end of Flash writing
   SPI_FLASH_WaitForWriteEnd();
 }
 
 /*******************************************************************************
 * Function Name  : SPI_FLASH_BufferWrite
 * Description    : Writes block of data to the FLASH. In this function, the
 *                  number of WRITE cycles are reduced, using Page WRITE sequence.
 * Input          : - pBuffer : pointer to the buffer  containing the data to be
@@ -359,21 +347,21 @@ void W25QXXFlash::SPI_FLASH_BufferWrite(uint8_t *pBuffer, uint32_t WriteAddr, ui
 * Description    : Reads a block of data from the FLASH.
 * Input          : - pBuffer : pointer to the buffer that receives the data read
 *                    from the FLASH.
 *                  - ReadAddr : FLASH's internal address to read from.
 *                  - NumByteToRead : number of bytes to read from the FLASH.
 * Output         : None
 * Return         : None
 *******************************************************************************/
 void W25QXXFlash::SPI_FLASH_BufferRead(uint8_t *pBuffer, uint32_t ReadAddr, uint16_t NumByteToRead) {
   // Select the FLASH: Chip Select low
-  W25QXX_CS_L;
+  SPI_FLASH_CS_L();
 
   // Send "Read from Memory " instruction
   spi_flash_Send(W25X_ReadData);
 
   // Send ReadAddr high nybble address byte to read from
   spi_flash_Send((ReadAddr & 0xFF0000) >> 16);
   // Send ReadAddr medium nybble address byte to read from
   spi_flash_Send((ReadAddr & 0xFF00) >> 8);
   // Send ReadAddr low nybble address byte to read from
   spi_flash_Send(ReadAddr & 0xFF);
@@ -382,14 +370,14 @@ void W25QXXFlash::SPI_FLASH_BufferRead(uint8_t *pBuffer, uint32_t ReadAddr, uint
     while (NumByteToRead--) { // While there is data to be read
       // Read a byte from the FLASH
       *pBuffer = spi_flash_Rec();
       // Point to the next location where the byte read will be saved
       pBuffer++;
     }
   }
   else
     spi_flash_Read(pBuffer, NumByteToRead);
 
-  W25QXX_CS_H;
+  SPI_FLASH_CS_H();
 }
 
 #endif // HAS_SPI_FLASH

commit afca6e745932d295b88d37fa9bd4274e22705b0b
Author: luzpaz <luzpaz@users.noreply.github.com>
Date:   Tue Aug 3 20:02:34 2021 -0400

    üêõ Spellcheck comments (#22496)
    
    codespell -q 3 --builtin=clear,rare,informal,code -S ./Marlin/src/lcd/language -L alo,amin,endcode,stdio,uint

diff --git a/Marlin/src/libs/W25Qxx.cpp b/Marlin/src/libs/W25Qxx.cpp
index fd7804cb27..56581ed46e 100644
--- a/Marlin/src/libs/W25Qxx.cpp
+++ b/Marlin/src/libs/W25Qxx.cpp
@@ -150,22 +150,22 @@ void W25QXXFlash::SPI_FLASH_WriteEnable(void) {
   W25QXX_CS_L;
   // Send "Write Enable" instruction
   spi_flash_Send(W25X_WriteEnable);
   // Deselect the FLASH: Chip Select high
   W25QXX_CS_H;
 }
 
 /*******************************************************************************
 * Function Name  : SPI_FLASH_WaitForWriteEnd
 * Description    : Polls the status of the Write In Progress (WIP) flag in the
-*                  FLASH's status  register  and  loop  until write  opertaion
-*                  has completed.
+*                  FLASH's status register and loop until write operation has
+*                  completed.
 * Input          : None
 * Output         : None
 * Return         : None
 *******************************************************************************/
 void W25QXXFlash::SPI_FLASH_WaitForWriteEnd(void) {
   uint8_t FLASH_Status = 0;
 
   // Select the FLASH: Chip Select low
   W25QXX_CS_L;
   // Send "Read Status Register" instruction

commit 3b73b115ca9366f0155986b717d4c85c31ed2f80
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 29 20:36:37 2021 -0500

    Apply pointer formatting

diff --git a/Marlin/src/libs/W25Qxx.cpp b/Marlin/src/libs/W25Qxx.cpp
index 0eb40a1441..fd7804cb27 100644
--- a/Marlin/src/libs/W25Qxx.cpp
+++ b/Marlin/src/libs/W25Qxx.cpp
@@ -99,42 +99,42 @@ uint8_t W25QXXFlash::spi_flash_read_write_byte(uint8_t data) {
 
 /**
  * @brief  Receive a number of bytes from the SPI port to a buffer
  *
  * @param  buf   Pointer to starting address of buffer to write to.
  * @param  nbyte Number of bytes to receive.
  * @return Nothing
  *
  * @details Uses DMA
  */
-void W25QXXFlash::spi_flash_Read(uint8_t* buf, uint16_t nbyte) {
+void W25QXXFlash::spi_flash_Read(uint8_t *buf, uint16_t nbyte) {
   mySPI.dmaTransfer(0, const_cast<uint8_t*>(buf), nbyte);
 }
 
 /**
  * @brief  Send a single byte on SPI port
  *
  * @param  b Byte to send
  *
  * @details
  */
 void W25QXXFlash::spi_flash_Send(uint8_t b) { mySPI.transfer(b); }
 
 /**
  * @brief  Write token and then write from 512 byte buffer to SPI (for SD card)
  *
  * @param  buf   Pointer with buffer start address
  * @return Nothing
  *
  * @details Use DMA
  */
-void W25QXXFlash::spi_flash_SendBlock(uint8_t token, const uint8_t* buf) {
+void W25QXXFlash::spi_flash_SendBlock(uint8_t token, const uint8_t *buf) {
   mySPI.transfer(token);
   mySPI.dmaSend(const_cast<uint8_t*>(buf), 512);
 }
 
 uint16_t W25QXXFlash::W25QXX_ReadID(void) {
   uint16_t Temp = 0;
   W25QXX_CS_L;
   spi_flash_Send(0x90);
   spi_flash_Send(0x00);
   spi_flash_Send(0x00);
@@ -250,21 +250,21 @@ void W25QXXFlash::SPI_FLASH_BulkErase(void) {
 *                  cycle(Page WRITE sequence). The number of byte can't exceed
 *                  the FLASH page size.
 * Input          : - pBuffer : pointer to the buffer  containing the data to be
 *                    written to the FLASH.
 *                  - WriteAddr : FLASH's internal address to write to.
 *                  - NumByteToWrite : number of bytes to write to the FLASH,
 *                    must be equal or less than "SPI_FLASH_PageSize" value.
 * Output         : None
 * Return         : None
 *******************************************************************************/
-void W25QXXFlash::SPI_FLASH_PageWrite(uint8_t* pBuffer, uint32_t WriteAddr, uint16_t NumByteToWrite) {
+void W25QXXFlash::SPI_FLASH_PageWrite(uint8_t *pBuffer, uint32_t WriteAddr, uint16_t NumByteToWrite) {
   // Enable the write access to the FLASH
   SPI_FLASH_WriteEnable();
 
   // Select the FLASH: Chip Select low
   W25QXX_CS_L;
   // Send "Write to Memory " instruction
   spi_flash_Send(W25X_PageProgram);
   // Send WriteAddr high nybble address byte to write to
   spi_flash_Send((WriteAddr & 0xFF0000) >> 16);
   // Send WriteAddr medium nybble address byte to write to
@@ -293,21 +293,21 @@ void W25QXXFlash::SPI_FLASH_PageWrite(uint8_t* pBuffer, uint32_t WriteAddr, uint
 * Function Name  : SPI_FLASH_BufferWrite
 * Description    : Writes block of data to the FLASH. In this function, the
 *                  number of WRITE cycles are reduced, using Page WRITE sequence.
 * Input          : - pBuffer : pointer to the buffer  containing the data to be
 *                    written to the FLASH.
 *                  - WriteAddr : FLASH's internal address to write to.
 *                  - NumByteToWrite : number of bytes to write to the FLASH.
 * Output         : None
 * Return         : None
 *******************************************************************************/
-void W25QXXFlash::SPI_FLASH_BufferWrite(uint8_t* pBuffer, uint32_t WriteAddr, uint16_t NumByteToWrite) {
+void W25QXXFlash::SPI_FLASH_BufferWrite(uint8_t *pBuffer, uint32_t WriteAddr, uint16_t NumByteToWrite) {
   uint8_t NumOfPage = 0, NumOfSingle = 0, Addr = 0, count = 0, temp = 0;
 
   Addr = WriteAddr % SPI_FLASH_PageSize;
   count = SPI_FLASH_PageSize - Addr;
   NumOfPage = NumByteToWrite / SPI_FLASH_PageSize;
   NumOfSingle = NumByteToWrite % SPI_FLASH_PageSize;
 
   if (Addr == 0) { // WriteAddr is SPI_FLASH_PageSize aligned
     if (NumOfPage == 0) { // NumByteToWrite < SPI_FLASH_PageSize
       SPI_FLASH_PageWrite(pBuffer, WriteAddr, NumByteToWrite);
@@ -357,21 +357,21 @@ void W25QXXFlash::SPI_FLASH_BufferWrite(uint8_t* pBuffer, uint32_t WriteAddr, ui
 /*******************************************************************************
 * Function Name  : SPI_FLASH_BufferRead
 * Description    : Reads a block of data from the FLASH.
 * Input          : - pBuffer : pointer to the buffer that receives the data read
 *                    from the FLASH.
 *                  - ReadAddr : FLASH's internal address to read from.
 *                  - NumByteToRead : number of bytes to read from the FLASH.
 * Output         : None
 * Return         : None
 *******************************************************************************/
-void W25QXXFlash::SPI_FLASH_BufferRead(uint8_t* pBuffer, uint32_t ReadAddr, uint16_t NumByteToRead) {
+void W25QXXFlash::SPI_FLASH_BufferRead(uint8_t *pBuffer, uint32_t ReadAddr, uint16_t NumByteToRead) {
   // Select the FLASH: Chip Select low
   W25QXX_CS_L;
 
   // Send "Read from Memory " instruction
   spi_flash_Send(W25X_ReadData);
 
   // Send ReadAddr high nybble address byte to read from
   spi_flash_Send((ReadAddr & 0xFF0000) >> 16);
   // Send ReadAddr medium nybble address byte to read from
   spi_flash_Send((ReadAddr & 0xFF00) >> 8);

commit 49564e5310184079c53ff322cd27e35e22877017
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Feb 4 19:37:59 2021 -0600

    Nybbles & Bits

diff --git a/Marlin/src/libs/W25Qxx.cpp b/Marlin/src/libs/W25Qxx.cpp
index be5b4290dd..0eb40a1441 100644
--- a/Marlin/src/libs/W25Qxx.cpp
+++ b/Marlin/src/libs/W25Qxx.cpp
@@ -184,43 +184,43 @@ void W25QXXFlash::SPI_FLASH_WaitForWriteEnd(void) {
 
 void W25QXXFlash::SPI_FLASH_SectorErase(uint32_t SectorAddr) {
   // Send write enable instruction
   SPI_FLASH_WriteEnable();
 
   // Sector Erase
   // Select the FLASH: Chip Select low
   W25QXX_CS_L;
   // Send Sector Erase instruction
   spi_flash_Send(W25X_SectorErase);
-  // Send SectorAddr high nibble address byte
+  // Send SectorAddr high nybble address byte
   spi_flash_Send((SectorAddr & 0xFF0000) >> 16);
-  // Send SectorAddr medium nibble address byte
+  // Send SectorAddr medium nybble address byte
   spi_flash_Send((SectorAddr & 0xFF00) >> 8);
-  // Send SectorAddr low nibble address byte
+  // Send SectorAddr low nybble address byte
   spi_flash_Send(SectorAddr & 0xFF);
   // Deselect the FLASH: Chip Select high
 
   W25QXX_CS_H;
   // Wait the end of Flash writing
   SPI_FLASH_WaitForWriteEnd();
 }
 
 void W25QXXFlash::SPI_FLASH_BlockErase(uint32_t BlockAddr) {
   SPI_FLASH_WriteEnable();
   W25QXX_CS_L;
   // Send Sector Erase instruction
   spi_flash_Send(W25X_BlockErase);
-  // Send SectorAddr high nibble address byte
+  // Send SectorAddr high nybble address byte
   spi_flash_Send((BlockAddr & 0xFF0000) >> 16);
-  // Send SectorAddr medium nibble address byte
+  // Send SectorAddr medium nybble address byte
   spi_flash_Send((BlockAddr & 0xFF00) >> 8);
-  // Send SectorAddr low nibble address byte
+  // Send SectorAddr low nybble address byte
   spi_flash_Send(BlockAddr & 0xFF);
 
   W25QXX_CS_H;
 
   SPI_FLASH_WaitForWriteEnd();
 }
 
 /*******************************************************************************
 * Function Name  : SPI_FLASH_BulkErase
 * Description    : Erases the entire FLASH.
@@ -258,25 +258,25 @@ void W25QXXFlash::SPI_FLASH_BulkErase(void) {
 * Return         : None
 *******************************************************************************/
 void W25QXXFlash::SPI_FLASH_PageWrite(uint8_t* pBuffer, uint32_t WriteAddr, uint16_t NumByteToWrite) {
   // Enable the write access to the FLASH
   SPI_FLASH_WriteEnable();
 
   // Select the FLASH: Chip Select low
   W25QXX_CS_L;
   // Send "Write to Memory " instruction
   spi_flash_Send(W25X_PageProgram);
-  // Send WriteAddr high nibble address byte to write to
+  // Send WriteAddr high nybble address byte to write to
   spi_flash_Send((WriteAddr & 0xFF0000) >> 16);
-  // Send WriteAddr medium nibble address byte to write to
+  // Send WriteAddr medium nybble address byte to write to
   spi_flash_Send((WriteAddr & 0xFF00) >> 8);
-  // Send WriteAddr low nibble address byte to write to
+  // Send WriteAddr low nybble address byte to write to
   spi_flash_Send(WriteAddr & 0xFF);
 
   NOMORE(NumByteToWrite, SPI_FLASH_PerWritePageSize);
 
   // While there is data to be written on the FLASH
   while (NumByteToWrite--) {
     // Send the current byte
     spi_flash_Send(*pBuffer);
     // Point on the next byte to be written
     pBuffer++;
@@ -364,25 +364,25 @@ void W25QXXFlash::SPI_FLASH_BufferWrite(uint8_t* pBuffer, uint32_t WriteAddr, ui
 * Output         : None
 * Return         : None
 *******************************************************************************/
 void W25QXXFlash::SPI_FLASH_BufferRead(uint8_t* pBuffer, uint32_t ReadAddr, uint16_t NumByteToRead) {
   // Select the FLASH: Chip Select low
   W25QXX_CS_L;
 
   // Send "Read from Memory " instruction
   spi_flash_Send(W25X_ReadData);
 
-  // Send ReadAddr high nibble address byte to read from
+  // Send ReadAddr high nybble address byte to read from
   spi_flash_Send((ReadAddr & 0xFF0000) >> 16);
-  // Send ReadAddr medium nibble address byte to read from
+  // Send ReadAddr medium nybble address byte to read from
   spi_flash_Send((ReadAddr & 0xFF00) >> 8);
-  // Send ReadAddr low nibble address byte to read from
+  // Send ReadAddr low nybble address byte to read from
   spi_flash_Send(ReadAddr & 0xFF);
 
   if (NumByteToRead <= 32 || !flash_dma_mode) {
     while (NumByteToRead--) { // While there is data to be read
       // Read a byte from the FLASH
       *pBuffer = spi_flash_Rec();
       // Point to the next location where the byte read will be saved
       pBuffer++;
     }
   }

commit c753fc690f6cdd181213304224eee029988ffd34
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jan 14 00:23:56 2021 -0600

    More MKS UI prelim. cleanup

diff --git a/Marlin/src/libs/W25Qxx.cpp b/Marlin/src/libs/W25Qxx.cpp
index dc96758e6d..be5b4290dd 100644
--- a/Marlin/src/libs/W25Qxx.cpp
+++ b/Marlin/src/libs/W25Qxx.cpp
@@ -323,23 +323,22 @@ void W25QXXFlash::SPI_FLASH_BufferWrite(uint8_t* pBuffer, uint32_t WriteAddr, ui
   }
   else { // WriteAddr is not SPI_FLASH_PageSize aligned
     if (NumOfPage == 0) { // NumByteToWrite < SPI_FLASH_PageSize
       if (NumOfSingle > count) { // (NumByteToWrite + WriteAddr) > SPI_FLASH_PageSize
         temp = NumOfSingle - count;
         SPI_FLASH_PageWrite(pBuffer, WriteAddr, count);
         WriteAddr += count;
         pBuffer += count;
         SPI_FLASH_PageWrite(pBuffer, WriteAddr, temp);
       }
-      else {
+      else
         SPI_FLASH_PageWrite(pBuffer, WriteAddr, NumByteToWrite);
-      }
     }
     else { // NumByteToWrite > SPI_FLASH_PageSize
       NumByteToWrite -= count;
       NumOfPage = NumByteToWrite / SPI_FLASH_PageSize;
       NumOfSingle = NumByteToWrite % SPI_FLASH_PageSize;
 
       SPI_FLASH_PageWrite(pBuffer, WriteAddr, count);
       WriteAddr += count;
       pBuffer += count;
 
@@ -380,17 +379,17 @@ void W25QXXFlash::SPI_FLASH_BufferRead(uint8_t* pBuffer, uint32_t ReadAddr, uint
   spi_flash_Send(ReadAddr & 0xFF);
 
   if (NumByteToRead <= 32 || !flash_dma_mode) {
     while (NumByteToRead--) { // While there is data to be read
       // Read a byte from the FLASH
       *pBuffer = spi_flash_Rec();
       // Point to the next location where the byte read will be saved
       pBuffer++;
     }
   }
-  else {
+  else
     spi_flash_Read(pBuffer, NumByteToRead);
-  }
+
   W25QXX_CS_H;
 }
 
 #endif // HAS_SPI_FLASH

commit 35c1b330ec62e698a455176330e7d75600af461d
Author: MKS-Sean <56996910+MKS-Sean@users.noreply.github.com>
Date:   Thu Jan 14 12:41:09 2021 +0800

    MKS WiFi for TFT_LVGL_UI (#20191)

diff --git a/Marlin/src/libs/W25Qxx.cpp b/Marlin/src/libs/W25Qxx.cpp
index ebf326f2e5..dc96758e6d 100644
--- a/Marlin/src/libs/W25Qxx.cpp
+++ b/Marlin/src/libs/W25Qxx.cpp
@@ -42,20 +42,22 @@ W25QXXFlash W25QXX;
 #endif
 #ifndef NC
   #define NC -1
 #endif
 
 MarlinSPI W25QXXFlash::mySPI(SPI_FLASH_MOSI_PIN, SPI_FLASH_MISO_PIN, SPI_FLASH_SCK_PIN, NC);
 
 #define W25QXX_CS_H OUT_WRITE(SPI_FLASH_CS_PIN, HIGH)
 #define W25QXX_CS_L OUT_WRITE(SPI_FLASH_CS_PIN, LOW)
 
+bool flash_dma_mode = true;
+
 void W25QXXFlash::init(uint8_t spiRate) {
 
   OUT_WRITE(SPI_FLASH_CS_PIN, HIGH);
 
   /**
    * STM32F1 APB2 = 72MHz, APB1 = 36MHz, max SPI speed of this MCU if 18Mhz
    * STM32F1 has 3 SPI ports, SPI1 in APB2, SPI2/SPI3 in APB1
    * so the minimum prescale of SPI1 is DIV4, SPI2/SPI3 is DIV2
    */
   #if SPI_DEVICE == 1
@@ -137,160 +139,160 @@ uint16_t W25QXXFlash::W25QXX_ReadID(void) {
   spi_flash_Send(0x00);
   spi_flash_Send(0x00);
   spi_flash_Send(0x00);
   Temp |= spi_flash_Rec() << 8;
   Temp |= spi_flash_Rec();
   W25QXX_CS_H;
   return Temp;
 }
 
 void W25QXXFlash::SPI_FLASH_WriteEnable(void) {
-  /* Select the FLASH: Chip Select low */
+  // Select the FLASH: Chip Select low
   W25QXX_CS_L;
-  /* Send "Write Enable" instruction */
+  // Send "Write Enable" instruction
   spi_flash_Send(W25X_WriteEnable);
-  /* Deselect the FLASH: Chip Select high */
+  // Deselect the FLASH: Chip Select high
   W25QXX_CS_H;
 }
 
 /*******************************************************************************
 * Function Name  : SPI_FLASH_WaitForWriteEnd
 * Description    : Polls the status of the Write In Progress (WIP) flag in the
 *                  FLASH's status  register  and  loop  until write  opertaion
 *                  has completed.
 * Input          : None
 * Output         : None
 * Return         : None
 *******************************************************************************/
 void W25QXXFlash::SPI_FLASH_WaitForWriteEnd(void) {
   uint8_t FLASH_Status = 0;
 
-  /* Select the FLASH: Chip Select low */
+  // Select the FLASH: Chip Select low
   W25QXX_CS_L;
-  /* Send "Read Status Register" instruction */
+  // Send "Read Status Register" instruction
   spi_flash_Send(W25X_ReadStatusReg);
 
-  /* Loop as long as the memory is busy with a write cycle */
+  // Loop as long as the memory is busy with a write cycle
   do
     /* Send a dummy byte to generate the clock needed by the FLASH
     and put the value of the status register in FLASH_Status variable */
     FLASH_Status = spi_flash_Rec();
-  while ((FLASH_Status & WIP_Flag) == 0x01); /* Write in progress */
+  while ((FLASH_Status & WIP_Flag) == 0x01); // Write in progress
 
-  /* Deselect the FLASH: Chip Select high */
+  // Deselect the FLASH: Chip Select high
   W25QXX_CS_H;
 }
 
 void W25QXXFlash::SPI_FLASH_SectorErase(uint32_t SectorAddr) {
-  /* Send write enable instruction */
+  // Send write enable instruction
   SPI_FLASH_WriteEnable();
 
-  /* Sector Erase */
-  /* Select the FLASH: Chip Select low */
+  // Sector Erase
+  // Select the FLASH: Chip Select low
   W25QXX_CS_L;
-  /* Send Sector Erase instruction */
+  // Send Sector Erase instruction
   spi_flash_Send(W25X_SectorErase);
-  /* Send SectorAddr high nibble address byte */
+  // Send SectorAddr high nibble address byte
   spi_flash_Send((SectorAddr & 0xFF0000) >> 16);
-  /* Send SectorAddr medium nibble address byte */
+  // Send SectorAddr medium nibble address byte
   spi_flash_Send((SectorAddr & 0xFF00) >> 8);
-  /* Send SectorAddr low nibble address byte */
+  // Send SectorAddr low nibble address byte
   spi_flash_Send(SectorAddr & 0xFF);
-  /* Deselect the FLASH: Chip Select high */
+  // Deselect the FLASH: Chip Select high
 
   W25QXX_CS_H;
-  /* Wait the end of Flash writing */
+  // Wait the end of Flash writing
   SPI_FLASH_WaitForWriteEnd();
 }
 
 void W25QXXFlash::SPI_FLASH_BlockErase(uint32_t BlockAddr) {
   SPI_FLASH_WriteEnable();
   W25QXX_CS_L;
-  /* Send Sector Erase instruction */
+  // Send Sector Erase instruction
   spi_flash_Send(W25X_BlockErase);
-  /* Send SectorAddr high nibble address byte */
+  // Send SectorAddr high nibble address byte
   spi_flash_Send((BlockAddr & 0xFF0000) >> 16);
-  /* Send SectorAddr medium nibble address byte */
+  // Send SectorAddr medium nibble address byte
   spi_flash_Send((BlockAddr & 0xFF00) >> 8);
-  /* Send SectorAddr low nibble address byte */
+  // Send SectorAddr low nibble address byte
   spi_flash_Send(BlockAddr & 0xFF);
 
   W25QXX_CS_H;
 
   SPI_FLASH_WaitForWriteEnd();
 }
 
 /*******************************************************************************
 * Function Name  : SPI_FLASH_BulkErase
 * Description    : Erases the entire FLASH.
 * Input          : None
 * Output         : None
 * Return         : None
 *******************************************************************************/
 void W25QXXFlash::SPI_FLASH_BulkErase(void) {
-  /* Send write enable instruction */
+  // Send write enable instruction
   SPI_FLASH_WriteEnable();
 
-  /* Bulk Erase */
-  /* Select the FLASH: Chip Select low */
+  // Bulk Erase
+  // Select the FLASH: Chip Select low
   W25QXX_CS_L;
 
-  /* Send Bulk Erase instruction  */
+  // Send Bulk Erase instruction
   spi_flash_Send(W25X_ChipErase);
-  /* Deselect the FLASH: Chip Select high */
+  // Deselect the FLASH: Chip Select high
   W25QXX_CS_H;
-  /* Wait the end of Flash writing */
+  // Wait the end of Flash writing
   SPI_FLASH_WaitForWriteEnd();
 }
 
 /*******************************************************************************
 * Function Name  : SPI_FLASH_PageWrite
 * Description    : Writes more than one byte to the FLASH with a single WRITE
 *                  cycle(Page WRITE sequence). The number of byte can't exceed
 *                  the FLASH page size.
 * Input          : - pBuffer : pointer to the buffer  containing the data to be
 *                    written to the FLASH.
 *                  - WriteAddr : FLASH's internal address to write to.
 *                  - NumByteToWrite : number of bytes to write to the FLASH,
 *                    must be equal or less than "SPI_FLASH_PageSize" value.
 * Output         : None
 * Return         : None
 *******************************************************************************/
 void W25QXXFlash::SPI_FLASH_PageWrite(uint8_t* pBuffer, uint32_t WriteAddr, uint16_t NumByteToWrite) {
-  /* Enable the write access to the FLASH */
+  // Enable the write access to the FLASH
   SPI_FLASH_WriteEnable();
 
-  /* Select the FLASH: Chip Select low */
+  // Select the FLASH: Chip Select low
   W25QXX_CS_L;
-  /* Send "Write to Memory " instruction */
+  // Send "Write to Memory " instruction
   spi_flash_Send(W25X_PageProgram);
-  /* Send WriteAddr high nibble address byte to write to */
+  // Send WriteAddr high nibble address byte to write to
   spi_flash_Send((WriteAddr & 0xFF0000) >> 16);
-  /* Send WriteAddr medium nibble address byte to write to */
+  // Send WriteAddr medium nibble address byte to write to
   spi_flash_Send((WriteAddr & 0xFF00) >> 8);
-  /* Send WriteAddr low nibble address byte to write to */
+  // Send WriteAddr low nibble address byte to write to
   spi_flash_Send(WriteAddr & 0xFF);
 
   NOMORE(NumByteToWrite, SPI_FLASH_PerWritePageSize);
 
-  /* while there is data to be written on the FLASH */
+  // While there is data to be written on the FLASH
   while (NumByteToWrite--) {
-    /* Send the current byte */
+    // Send the current byte
     spi_flash_Send(*pBuffer);
-    /* Point on the next byte to be written */
+    // Point on the next byte to be written
     pBuffer++;
   }
 
-  /* Deselect the FLASH: Chip Select high */
+  // Deselect the FLASH: Chip Select high
   W25QXX_CS_H;
 
-  /* Wait the end of Flash writing */
+  // Wait the end of Flash writing
   SPI_FLASH_WaitForWriteEnd();
 }
 
 /*******************************************************************************
 * Function Name  : SPI_FLASH_BufferWrite
 * Description    : Writes block of data to the FLASH. In this function, the
 *                  number of WRITE cycles are reduced, using Page WRITE sequence.
 * Input          : - pBuffer : pointer to the buffer  containing the data to be
 *                    written to the FLASH.
 *                  - WriteAddr : FLASH's internal address to write to.
@@ -299,47 +301,47 @@ void W25QXXFlash::SPI_FLASH_PageWrite(uint8_t* pBuffer, uint32_t WriteAddr, uint
 * Return         : None
 *******************************************************************************/
 void W25QXXFlash::SPI_FLASH_BufferWrite(uint8_t* pBuffer, uint32_t WriteAddr, uint16_t NumByteToWrite) {
   uint8_t NumOfPage = 0, NumOfSingle = 0, Addr = 0, count = 0, temp = 0;
 
   Addr = WriteAddr % SPI_FLASH_PageSize;
   count = SPI_FLASH_PageSize - Addr;
   NumOfPage = NumByteToWrite / SPI_FLASH_PageSize;
   NumOfSingle = NumByteToWrite % SPI_FLASH_PageSize;
 
-  if (Addr == 0) { /* WriteAddr is SPI_FLASH_PageSize aligned  */
-    if (NumOfPage == 0) { /* NumByteToWrite < SPI_FLASH_PageSize */
+  if (Addr == 0) { // WriteAddr is SPI_FLASH_PageSize aligned
+    if (NumOfPage == 0) { // NumByteToWrite < SPI_FLASH_PageSize
       SPI_FLASH_PageWrite(pBuffer, WriteAddr, NumByteToWrite);
     }
-    else { /* NumByteToWrite > SPI_FLASH_PageSize */
+    else { // NumByteToWrite > SPI_FLASH_PageSize
       while (NumOfPage--) {
         SPI_FLASH_PageWrite(pBuffer, WriteAddr, SPI_FLASH_PageSize);
         WriteAddr += SPI_FLASH_PageSize;
         pBuffer += SPI_FLASH_PageSize;
       }
       SPI_FLASH_PageWrite(pBuffer, WriteAddr, NumOfSingle);
     }
   }
-  else { /* WriteAddr is not SPI_FLASH_PageSize aligned  */
-    if (NumOfPage == 0) { /* NumByteToWrite < SPI_FLASH_PageSize */
-      if (NumOfSingle > count) { /* (NumByteToWrite + WriteAddr) > SPI_FLASH_PageSize */
+  else { // WriteAddr is not SPI_FLASH_PageSize aligned
+    if (NumOfPage == 0) { // NumByteToWrite < SPI_FLASH_PageSize
+      if (NumOfSingle > count) { // (NumByteToWrite + WriteAddr) > SPI_FLASH_PageSize
         temp = NumOfSingle - count;
         SPI_FLASH_PageWrite(pBuffer, WriteAddr, count);
         WriteAddr += count;
         pBuffer += count;
         SPI_FLASH_PageWrite(pBuffer, WriteAddr, temp);
       }
       else {
         SPI_FLASH_PageWrite(pBuffer, WriteAddr, NumByteToWrite);
       }
     }
-    else { /* NumByteToWrite > SPI_FLASH_PageSize */
+    else { // NumByteToWrite > SPI_FLASH_PageSize
       NumByteToWrite -= count;
       NumOfPage = NumByteToWrite / SPI_FLASH_PageSize;
       NumOfSingle = NumByteToWrite % SPI_FLASH_PageSize;
 
       SPI_FLASH_PageWrite(pBuffer, WriteAddr, count);
       WriteAddr += count;
       pBuffer += count;
 
       while (NumOfPage--) {
         SPI_FLASH_PageWrite(pBuffer, WriteAddr, SPI_FLASH_PageSize);
@@ -357,38 +359,38 @@ void W25QXXFlash::SPI_FLASH_BufferWrite(uint8_t* pBuffer, uint32_t WriteAddr, ui
 * Function Name  : SPI_FLASH_BufferRead
 * Description    : Reads a block of data from the FLASH.
 * Input          : - pBuffer : pointer to the buffer that receives the data read
 *                    from the FLASH.
 *                  - ReadAddr : FLASH's internal address to read from.
 *                  - NumByteToRead : number of bytes to read from the FLASH.
 * Output         : None
 * Return         : None
 *******************************************************************************/
 void W25QXXFlash::SPI_FLASH_BufferRead(uint8_t* pBuffer, uint32_t ReadAddr, uint16_t NumByteToRead) {
-  /* Select the FLASH: Chip Select low */
+  // Select the FLASH: Chip Select low
   W25QXX_CS_L;
 
-  /* Send "Read from Memory " instruction */
+  // Send "Read from Memory " instruction
   spi_flash_Send(W25X_ReadData);
 
-  /* Send ReadAddr high nibble address byte to read from */
+  // Send ReadAddr high nibble address byte to read from
   spi_flash_Send((ReadAddr & 0xFF0000) >> 16);
-  /* Send ReadAddr medium nibble address byte to read from */
+  // Send ReadAddr medium nibble address byte to read from
   spi_flash_Send((ReadAddr & 0xFF00) >> 8);
-  /* Send ReadAddr low nibble address byte to read from */
+  // Send ReadAddr low nibble address byte to read from
   spi_flash_Send(ReadAddr & 0xFF);
 
-  if (NumByteToRead < 33) {
-    while (NumByteToRead--) { /* while there is data to be read */
-      /* Read a byte from the FLASH */
+  if (NumByteToRead <= 32 || !flash_dma_mode) {
+    while (NumByteToRead--) { // While there is data to be read
+      // Read a byte from the FLASH
       *pBuffer = spi_flash_Rec();
-      /* Point to the next location where the byte read will be saved */
+      // Point to the next location where the byte read will be saved
       pBuffer++;
     }
   }
   else {
     spi_flash_Read(pBuffer, NumByteToRead);
   }
   W25QXX_CS_H;
 }
 
 #endif // HAS_SPI_FLASH

commit 85d094bbb4cb6200057403be3d208a29920ecf12
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Sat Nov 7 00:07:15 2020 -0300

    Standardize Marlin SPI (part 1) (#19989)

diff --git a/Marlin/src/libs/W25Qxx.cpp b/Marlin/src/libs/W25Qxx.cpp
index 03e002f66f..ebf326f2e5 100644
--- a/Marlin/src/libs/W25Qxx.cpp
+++ b/Marlin/src/libs/W25Qxx.cpp
@@ -18,36 +18,40 @@
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 #include "../inc/MarlinConfig.h"
 
 #if HAS_SPI_FLASH
 
 #include "W25Qxx.h"
-#include <SPI.h>
 
 W25QXXFlash W25QXX;
 
 #ifndef SPI_FLASH_MISO_PIN
   #define SPI_FLASH_MISO_PIN W25QXX_MISO_PIN
 #endif
 #ifndef SPI_FLASH_MOSI_PIN
   #define SPI_FLASH_MOSI_PIN W25QXX_MOSI_PIN
 #endif
 #ifndef SPI_FLASH_SCK_PIN
   #define SPI_FLASH_SCK_PIN  W25QXX_SCK_PIN
 #endif
 #ifndef SPI_FLASH_CS_PIN
   #define SPI_FLASH_CS_PIN   W25QXX_CS_PIN
 #endif
+#ifndef NC
+  #define NC -1
+#endif
+
+MarlinSPI W25QXXFlash::mySPI(SPI_FLASH_MOSI_PIN, SPI_FLASH_MISO_PIN, SPI_FLASH_SCK_PIN, NC);
 
 #define W25QXX_CS_H OUT_WRITE(SPI_FLASH_CS_PIN, HIGH)
 #define W25QXX_CS_L OUT_WRITE(SPI_FLASH_CS_PIN, LOW)
 
 void W25QXXFlash::init(uint8_t spiRate) {
 
   OUT_WRITE(SPI_FLASH_CS_PIN, HIGH);
 
   /**
    * STM32F1 APB2 = 72MHz, APB1 = 36MHz, max SPI speed of this MCU if 18Mhz
@@ -62,73 +66,75 @@ void W25QXXFlash::init(uint8_t spiRate) {
   uint8_t clock;
   switch (spiRate) {
     case SPI_FULL_SPEED:    clock = SPI_CLOCK_MAX;  break;
     case SPI_HALF_SPEED:    clock = SPI_CLOCK_DIV4; break;
     case SPI_QUARTER_SPEED: clock = SPI_CLOCK_DIV8; break;
     case SPI_EIGHTH_SPEED:  clock = SPI_CLOCK_DIV16; break;
     case SPI_SPEED_5:       clock = SPI_CLOCK_DIV32; break;
     case SPI_SPEED_6:       clock = SPI_CLOCK_DIV64; break;
     default:                clock = SPI_CLOCK_DIV2;// Default from the SPI library
   }
-  SPI.setModule(SPI_DEVICE);
-  SPI.begin();
-  SPI.setClockDivider(clock);
-  SPI.setBitOrder(MSBFIRST);
-  SPI.setDataMode(SPI_MODE0);
+
+  mySPI.setClockDivider(clock);
+  mySPI.setBitOrder(MSBFIRST);
+  mySPI.setDataMode(SPI_MODE0);
+  mySPI.begin();
 }
 
 /**
  * @brief  Receive a single byte from the SPI port.
  *
  * @return Byte received
  */
 uint8_t W25QXXFlash::spi_flash_Rec() {
-  const uint8_t returnByte = SPI.transfer(0xFF);
+  const uint8_t returnByte = mySPI.transfer(0xFF);
   return returnByte;
 }
 
 uint8_t W25QXXFlash::spi_flash_read_write_byte(uint8_t data) {
-  const uint8_t returnByte = SPI.transfer(data);
+  const uint8_t returnByte = mySPI.transfer(data);
   return returnByte;
 }
 
 /**
  * @brief  Receive a number of bytes from the SPI port to a buffer
  *
  * @param  buf   Pointer to starting address of buffer to write to.
  * @param  nbyte Number of bytes to receive.
  * @return Nothing
  *
  * @details Uses DMA
  */
-void W25QXXFlash::spi_flash_Read(uint8_t* buf, uint16_t nbyte) { SPI.dmaTransfer(0, const_cast<uint8_t*>(buf), nbyte); }
+void W25QXXFlash::spi_flash_Read(uint8_t* buf, uint16_t nbyte) {
+  mySPI.dmaTransfer(0, const_cast<uint8_t*>(buf), nbyte);
+}
 
 /**
  * @brief  Send a single byte on SPI port
  *
  * @param  b Byte to send
  *
  * @details
  */
-void W25QXXFlash::spi_flash_Send(uint8_t b) { SPI.send(b); }
+void W25QXXFlash::spi_flash_Send(uint8_t b) { mySPI.transfer(b); }
 
 /**
  * @brief  Write token and then write from 512 byte buffer to SPI (for SD card)
  *
  * @param  buf   Pointer with buffer start address
  * @return Nothing
  *
  * @details Use DMA
  */
 void W25QXXFlash::spi_flash_SendBlock(uint8_t token, const uint8_t* buf) {
-  SPI.send(token);
-  SPI.dmaSend(const_cast<uint8_t*>(buf), 512);
+  mySPI.transfer(token);
+  mySPI.dmaSend(const_cast<uint8_t*>(buf), 512);
 }
 
 uint16_t W25QXXFlash::W25QXX_ReadID(void) {
   uint16_t Temp = 0;
   W25QXX_CS_L;
   spi_flash_Send(0x90);
   spi_flash_Send(0x00);
   spi_flash_Send(0x00);
   spi_flash_Send(0x00);
   Temp |= spi_flash_Rec() << 8;

commit f72c559824dca5d59a92040ebe951405e3b3d429
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Oct 8 15:17:19 2020 -0500

    Use 0xFF (not 'ff') for byte transfer

diff --git a/Marlin/src/libs/W25Qxx.cpp b/Marlin/src/libs/W25Qxx.cpp
index 9abe45fbaf..03e002f66f 100644
--- a/Marlin/src/libs/W25Qxx.cpp
+++ b/Marlin/src/libs/W25Qxx.cpp
@@ -73,30 +73,28 @@ void W25QXXFlash::init(uint8_t spiRate) {
   SPI.begin();
   SPI.setClockDivider(clock);
   SPI.setBitOrder(MSBFIRST);
   SPI.setDataMode(SPI_MODE0);
 }
 
 /**
  * @brief  Receive a single byte from the SPI port.
  *
  * @return Byte received
- *
- * @details
  */
 uint8_t W25QXXFlash::spi_flash_Rec() {
-  uint8_t returnByte = SPI.transfer(ff);
+  const uint8_t returnByte = SPI.transfer(0xFF);
   return returnByte;
 }
 
 uint8_t W25QXXFlash::spi_flash_read_write_byte(uint8_t data) {
-  uint8_t returnByte = SPI.transfer(data);
+  const uint8_t returnByte = SPI.transfer(data);
   return returnByte;
 }
 
 /**
  * @brief  Receive a number of bytes from the SPI port to a buffer
  *
  * @param  buf   Pointer to starting address of buffer to write to.
  * @param  nbyte Number of bytes to receive.
  * @return Nothing
  *

commit 6759aff22036a9fd4ae9f9398cd6e142a31ebd3b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 10 17:34:41 2020 -0500

    Clean up W25QXXFlash class

diff --git a/Marlin/src/libs/W25Qxx.cpp b/Marlin/src/libs/W25Qxx.cpp
index d51dfb819d..9abe45fbaf 100644
--- a/Marlin/src/libs/W25Qxx.cpp
+++ b/Marlin/src/libs/W25Qxx.cpp
@@ -17,23 +17,24 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 #include "../inc/MarlinConfig.h"
 
 #if HAS_SPI_FLASH
 
+#include "W25Qxx.h"
 #include <SPI.h>
 
-#include "W25Qxx.h"
+W25QXXFlash W25QXX;
 
 #ifndef SPI_FLASH_MISO_PIN
   #define SPI_FLASH_MISO_PIN W25QXX_MISO_PIN
 #endif
 #ifndef SPI_FLASH_MOSI_PIN
   #define SPI_FLASH_MOSI_PIN W25QXX_MOSI_PIN
 #endif
 #ifndef SPI_FLASH_SCK_PIN
   #define SPI_FLASH_SCK_PIN  W25QXX_SCK_PIN
 #endif

commit 0a1b8659871f681464f24c40b16aa64cd2f7ca8e
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Sat Aug 8 21:24:31 2020 -0300

    W25QXX SPI Flash support (#18897)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/libs/W25Qxx.cpp b/Marlin/src/libs/W25Qxx.cpp
new file mode 100644
index 0000000000..d51dfb819d
--- /dev/null
+++ b/Marlin/src/libs/W25Qxx.cpp
@@ -0,0 +1,389 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "../inc/MarlinConfig.h"
+
+#if HAS_SPI_FLASH
+
+#include <SPI.h>
+
+#include "W25Qxx.h"
+
+#ifndef SPI_FLASH_MISO_PIN
+  #define SPI_FLASH_MISO_PIN W25QXX_MISO_PIN
+#endif
+#ifndef SPI_FLASH_MOSI_PIN
+  #define SPI_FLASH_MOSI_PIN W25QXX_MOSI_PIN
+#endif
+#ifndef SPI_FLASH_SCK_PIN
+  #define SPI_FLASH_SCK_PIN  W25QXX_SCK_PIN
+#endif
+#ifndef SPI_FLASH_CS_PIN
+  #define SPI_FLASH_CS_PIN   W25QXX_CS_PIN
+#endif
+
+#define W25QXX_CS_H OUT_WRITE(SPI_FLASH_CS_PIN, HIGH)
+#define W25QXX_CS_L OUT_WRITE(SPI_FLASH_CS_PIN, LOW)
+
+void W25QXXFlash::init(uint8_t spiRate) {
+
+  OUT_WRITE(SPI_FLASH_CS_PIN, HIGH);
+
+  /**
+   * STM32F1 APB2 = 72MHz, APB1 = 36MHz, max SPI speed of this MCU if 18Mhz
+   * STM32F1 has 3 SPI ports, SPI1 in APB2, SPI2/SPI3 in APB1
+   * so the minimum prescale of SPI1 is DIV4, SPI2/SPI3 is DIV2
+   */
+  #if SPI_DEVICE == 1
+    #define SPI_CLOCK_MAX SPI_CLOCK_DIV4
+  #else
+    #define SPI_CLOCK_MAX SPI_CLOCK_DIV2
+  #endif
+  uint8_t clock;
+  switch (spiRate) {
+    case SPI_FULL_SPEED:    clock = SPI_CLOCK_MAX;  break;
+    case SPI_HALF_SPEED:    clock = SPI_CLOCK_DIV4; break;
+    case SPI_QUARTER_SPEED: clock = SPI_CLOCK_DIV8; break;
+    case SPI_EIGHTH_SPEED:  clock = SPI_CLOCK_DIV16; break;
+    case SPI_SPEED_5:       clock = SPI_CLOCK_DIV32; break;
+    case SPI_SPEED_6:       clock = SPI_CLOCK_DIV64; break;
+    default:                clock = SPI_CLOCK_DIV2;// Default from the SPI library
+  }
+  SPI.setModule(SPI_DEVICE);
+  SPI.begin();
+  SPI.setClockDivider(clock);
+  SPI.setBitOrder(MSBFIRST);
+  SPI.setDataMode(SPI_MODE0);
+}
+
+/**
+ * @brief  Receive a single byte from the SPI port.
+ *
+ * @return Byte received
+ *
+ * @details
+ */
+uint8_t W25QXXFlash::spi_flash_Rec() {
+  uint8_t returnByte = SPI.transfer(ff);
+  return returnByte;
+}
+
+uint8_t W25QXXFlash::spi_flash_read_write_byte(uint8_t data) {
+  uint8_t returnByte = SPI.transfer(data);
+  return returnByte;
+}
+
+/**
+ * @brief  Receive a number of bytes from the SPI port to a buffer
+ *
+ * @param  buf   Pointer to starting address of buffer to write to.
+ * @param  nbyte Number of bytes to receive.
+ * @return Nothing
+ *
+ * @details Uses DMA
+ */
+void W25QXXFlash::spi_flash_Read(uint8_t* buf, uint16_t nbyte) { SPI.dmaTransfer(0, const_cast<uint8_t*>(buf), nbyte); }
+
+/**
+ * @brief  Send a single byte on SPI port
+ *
+ * @param  b Byte to send
+ *
+ * @details
+ */
+void W25QXXFlash::spi_flash_Send(uint8_t b) { SPI.send(b); }
+
+/**
+ * @brief  Write token and then write from 512 byte buffer to SPI (for SD card)
+ *
+ * @param  buf   Pointer with buffer start address
+ * @return Nothing
+ *
+ * @details Use DMA
+ */
+void W25QXXFlash::spi_flash_SendBlock(uint8_t token, const uint8_t* buf) {
+  SPI.send(token);
+  SPI.dmaSend(const_cast<uint8_t*>(buf), 512);
+}
+
+uint16_t W25QXXFlash::W25QXX_ReadID(void) {
+  uint16_t Temp = 0;
+  W25QXX_CS_L;
+  spi_flash_Send(0x90);
+  spi_flash_Send(0x00);
+  spi_flash_Send(0x00);
+  spi_flash_Send(0x00);
+  Temp |= spi_flash_Rec() << 8;
+  Temp |= spi_flash_Rec();
+  W25QXX_CS_H;
+  return Temp;
+}
+
+void W25QXXFlash::SPI_FLASH_WriteEnable(void) {
+  /* Select the FLASH: Chip Select low */
+  W25QXX_CS_L;
+  /* Send "Write Enable" instruction */
+  spi_flash_Send(W25X_WriteEnable);
+  /* Deselect the FLASH: Chip Select high */
+  W25QXX_CS_H;
+}
+
+/*******************************************************************************
+* Function Name  : SPI_FLASH_WaitForWriteEnd
+* Description    : Polls the status of the Write In Progress (WIP) flag in the
+*                  FLASH's status  register  and  loop  until write  opertaion
+*                  has completed.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void W25QXXFlash::SPI_FLASH_WaitForWriteEnd(void) {
+  uint8_t FLASH_Status = 0;
+
+  /* Select the FLASH: Chip Select low */
+  W25QXX_CS_L;
+  /* Send "Read Status Register" instruction */
+  spi_flash_Send(W25X_ReadStatusReg);
+
+  /* Loop as long as the memory is busy with a write cycle */
+  do
+    /* Send a dummy byte to generate the clock needed by the FLASH
+    and put the value of the status register in FLASH_Status variable */
+    FLASH_Status = spi_flash_Rec();
+  while ((FLASH_Status & WIP_Flag) == 0x01); /* Write in progress */
+
+  /* Deselect the FLASH: Chip Select high */
+  W25QXX_CS_H;
+}
+
+void W25QXXFlash::SPI_FLASH_SectorErase(uint32_t SectorAddr) {
+  /* Send write enable instruction */
+  SPI_FLASH_WriteEnable();
+
+  /* Sector Erase */
+  /* Select the FLASH: Chip Select low */
+  W25QXX_CS_L;
+  /* Send Sector Erase instruction */
+  spi_flash_Send(W25X_SectorErase);
+  /* Send SectorAddr high nibble address byte */
+  spi_flash_Send((SectorAddr & 0xFF0000) >> 16);
+  /* Send SectorAddr medium nibble address byte */
+  spi_flash_Send((SectorAddr & 0xFF00) >> 8);
+  /* Send SectorAddr low nibble address byte */
+  spi_flash_Send(SectorAddr & 0xFF);
+  /* Deselect the FLASH: Chip Select high */
+
+  W25QXX_CS_H;
+  /* Wait the end of Flash writing */
+  SPI_FLASH_WaitForWriteEnd();
+}
+
+void W25QXXFlash::SPI_FLASH_BlockErase(uint32_t BlockAddr) {
+  SPI_FLASH_WriteEnable();
+  W25QXX_CS_L;
+  /* Send Sector Erase instruction */
+  spi_flash_Send(W25X_BlockErase);
+  /* Send SectorAddr high nibble address byte */
+  spi_flash_Send((BlockAddr & 0xFF0000) >> 16);
+  /* Send SectorAddr medium nibble address byte */
+  spi_flash_Send((BlockAddr & 0xFF00) >> 8);
+  /* Send SectorAddr low nibble address byte */
+  spi_flash_Send(BlockAddr & 0xFF);
+
+  W25QXX_CS_H;
+
+  SPI_FLASH_WaitForWriteEnd();
+}
+
+/*******************************************************************************
+* Function Name  : SPI_FLASH_BulkErase
+* Description    : Erases the entire FLASH.
+* Input          : None
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void W25QXXFlash::SPI_FLASH_BulkErase(void) {
+  /* Send write enable instruction */
+  SPI_FLASH_WriteEnable();
+
+  /* Bulk Erase */
+  /* Select the FLASH: Chip Select low */
+  W25QXX_CS_L;
+
+  /* Send Bulk Erase instruction  */
+  spi_flash_Send(W25X_ChipErase);
+  /* Deselect the FLASH: Chip Select high */
+  W25QXX_CS_H;
+  /* Wait the end of Flash writing */
+  SPI_FLASH_WaitForWriteEnd();
+}
+
+/*******************************************************************************
+* Function Name  : SPI_FLASH_PageWrite
+* Description    : Writes more than one byte to the FLASH with a single WRITE
+*                  cycle(Page WRITE sequence). The number of byte can't exceed
+*                  the FLASH page size.
+* Input          : - pBuffer : pointer to the buffer  containing the data to be
+*                    written to the FLASH.
+*                  - WriteAddr : FLASH's internal address to write to.
+*                  - NumByteToWrite : number of bytes to write to the FLASH,
+*                    must be equal or less than "SPI_FLASH_PageSize" value.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void W25QXXFlash::SPI_FLASH_PageWrite(uint8_t* pBuffer, uint32_t WriteAddr, uint16_t NumByteToWrite) {
+  /* Enable the write access to the FLASH */
+  SPI_FLASH_WriteEnable();
+
+  /* Select the FLASH: Chip Select low */
+  W25QXX_CS_L;
+  /* Send "Write to Memory " instruction */
+  spi_flash_Send(W25X_PageProgram);
+  /* Send WriteAddr high nibble address byte to write to */
+  spi_flash_Send((WriteAddr & 0xFF0000) >> 16);
+  /* Send WriteAddr medium nibble address byte to write to */
+  spi_flash_Send((WriteAddr & 0xFF00) >> 8);
+  /* Send WriteAddr low nibble address byte to write to */
+  spi_flash_Send(WriteAddr & 0xFF);
+
+  NOMORE(NumByteToWrite, SPI_FLASH_PerWritePageSize);
+
+  /* while there is data to be written on the FLASH */
+  while (NumByteToWrite--) {
+    /* Send the current byte */
+    spi_flash_Send(*pBuffer);
+    /* Point on the next byte to be written */
+    pBuffer++;
+  }
+
+  /* Deselect the FLASH: Chip Select high */
+  W25QXX_CS_H;
+
+  /* Wait the end of Flash writing */
+  SPI_FLASH_WaitForWriteEnd();
+}
+
+/*******************************************************************************
+* Function Name  : SPI_FLASH_BufferWrite
+* Description    : Writes block of data to the FLASH. In this function, the
+*                  number of WRITE cycles are reduced, using Page WRITE sequence.
+* Input          : - pBuffer : pointer to the buffer  containing the data to be
+*                    written to the FLASH.
+*                  - WriteAddr : FLASH's internal address to write to.
+*                  - NumByteToWrite : number of bytes to write to the FLASH.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void W25QXXFlash::SPI_FLASH_BufferWrite(uint8_t* pBuffer, uint32_t WriteAddr, uint16_t NumByteToWrite) {
+  uint8_t NumOfPage = 0, NumOfSingle = 0, Addr = 0, count = 0, temp = 0;
+
+  Addr = WriteAddr % SPI_FLASH_PageSize;
+  count = SPI_FLASH_PageSize - Addr;
+  NumOfPage = NumByteToWrite / SPI_FLASH_PageSize;
+  NumOfSingle = NumByteToWrite % SPI_FLASH_PageSize;
+
+  if (Addr == 0) { /* WriteAddr is SPI_FLASH_PageSize aligned  */
+    if (NumOfPage == 0) { /* NumByteToWrite < SPI_FLASH_PageSize */
+      SPI_FLASH_PageWrite(pBuffer, WriteAddr, NumByteToWrite);
+    }
+    else { /* NumByteToWrite > SPI_FLASH_PageSize */
+      while (NumOfPage--) {
+        SPI_FLASH_PageWrite(pBuffer, WriteAddr, SPI_FLASH_PageSize);
+        WriteAddr += SPI_FLASH_PageSize;
+        pBuffer += SPI_FLASH_PageSize;
+      }
+      SPI_FLASH_PageWrite(pBuffer, WriteAddr, NumOfSingle);
+    }
+  }
+  else { /* WriteAddr is not SPI_FLASH_PageSize aligned  */
+    if (NumOfPage == 0) { /* NumByteToWrite < SPI_FLASH_PageSize */
+      if (NumOfSingle > count) { /* (NumByteToWrite + WriteAddr) > SPI_FLASH_PageSize */
+        temp = NumOfSingle - count;
+        SPI_FLASH_PageWrite(pBuffer, WriteAddr, count);
+        WriteAddr += count;
+        pBuffer += count;
+        SPI_FLASH_PageWrite(pBuffer, WriteAddr, temp);
+      }
+      else {
+        SPI_FLASH_PageWrite(pBuffer, WriteAddr, NumByteToWrite);
+      }
+    }
+    else { /* NumByteToWrite > SPI_FLASH_PageSize */
+      NumByteToWrite -= count;
+      NumOfPage = NumByteToWrite / SPI_FLASH_PageSize;
+      NumOfSingle = NumByteToWrite % SPI_FLASH_PageSize;
+
+      SPI_FLASH_PageWrite(pBuffer, WriteAddr, count);
+      WriteAddr += count;
+      pBuffer += count;
+
+      while (NumOfPage--) {
+        SPI_FLASH_PageWrite(pBuffer, WriteAddr, SPI_FLASH_PageSize);
+        WriteAddr += SPI_FLASH_PageSize;
+        pBuffer += SPI_FLASH_PageSize;
+      }
+
+      if (NumOfSingle != 0)
+        SPI_FLASH_PageWrite(pBuffer, WriteAddr, NumOfSingle);
+    }
+  }
+}
+
+/*******************************************************************************
+* Function Name  : SPI_FLASH_BufferRead
+* Description    : Reads a block of data from the FLASH.
+* Input          : - pBuffer : pointer to the buffer that receives the data read
+*                    from the FLASH.
+*                  - ReadAddr : FLASH's internal address to read from.
+*                  - NumByteToRead : number of bytes to read from the FLASH.
+* Output         : None
+* Return         : None
+*******************************************************************************/
+void W25QXXFlash::SPI_FLASH_BufferRead(uint8_t* pBuffer, uint32_t ReadAddr, uint16_t NumByteToRead) {
+  /* Select the FLASH: Chip Select low */
+  W25QXX_CS_L;
+
+  /* Send "Read from Memory " instruction */
+  spi_flash_Send(W25X_ReadData);
+
+  /* Send ReadAddr high nibble address byte to read from */
+  spi_flash_Send((ReadAddr & 0xFF0000) >> 16);
+  /* Send ReadAddr medium nibble address byte to read from */
+  spi_flash_Send((ReadAddr & 0xFF00) >> 8);
+  /* Send ReadAddr low nibble address byte to read from */
+  spi_flash_Send(ReadAddr & 0xFF);
+
+  if (NumByteToRead < 33) {
+    while (NumByteToRead--) { /* while there is data to be read */
+      /* Read a byte from the FLASH */
+      *pBuffer = spi_flash_Rec();
+      /* Point to the next location where the byte read will be saved */
+      pBuffer++;
+    }
+  }
+  else {
+    spi_flash_Read(pBuffer, NumByteToRead);
+  }
+  W25QXX_CS_H;
+}
+
+#endif // HAS_SPI_FLASH
