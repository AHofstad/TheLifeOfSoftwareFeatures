commit c3694f1c038fa20ad749118b0a1c7aa88e3dd5f2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jun 14 17:24:50 2023 -0500

    üé® Lowercase methods, functions, data members (#25939)
    
    For: TFT, DGUS, MarlinUI, Anycubic, JyersUI, CrealityUI

diff --git a/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp b/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp
index 7c0ec802c3..06d47d949b 100644
--- a/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp
+++ b/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp
@@ -284,102 +284,102 @@ void spiFlashErase_PIC() {
     W25QXX.init(SPI_QUARTER_SPEED);
     for (Font_sectorcnt = 0; Font_sectorcnt < 32 - 1; Font_sectorcnt++) {
       hal.watchdog_refresh();
       W25QXX.SPI_FLASH_BlockErase(FONTINFOADDR + Font_sectorcnt * 64 * 1024);
     }
   }
 #endif
 
 uint32_t LogoWrite_Addroffset = 0;
 
-uint8_t Pic_Logo_Write(uint8_t *LogoName, uint8_t *Logo_Wbuff, uint32_t LogoWriteSize) {
+uint8_t picLogoWrite(uint8_t *LogoName, uint8_t *Logo_Wbuff, uint32_t LogoWriteSize) {
   if (LogoWriteSize <= 0) return 0;
 
   W25QXX.SPI_FLASH_BufferWrite(Logo_Wbuff, PIC_LOGO_ADDR + LogoWrite_Addroffset, LogoWriteSize);
 
   for (uint32_t i = 0; i < LogoWriteSize; i++) {
     uint8_t temp1;
     W25QXX.SPI_FLASH_BufferRead(&temp1, PIC_LOGO_ADDR + LogoWrite_Addroffset + i, 1);
     if (*(Logo_Wbuff + i) != temp1) return 0;
   }
   LogoWrite_Addroffset += LogoWriteSize;
   const uint32_t logo_maxsize = DeviceCode == 0x9488 || DeviceCode == 0x5761 ? LOGO_MAX_SIZE_TFT35 : LOGO_MAX_SIZE_TFT32;
   if (LogoWrite_Addroffset >= logo_maxsize) LogoWrite_Addroffset = 0;
   return 1;
 }
 
 uint32_t TitleLogoWrite_Addroffset = 0;
-uint8_t Pic_TitleLogo_Write(uint8_t *TitleLogoName, uint8_t *TitleLogo_Wbuff, uint32_t TitleLogoWriteSize) {
+uint8_t picTitleLogoWrite(uint8_t *TitleLogoName, uint8_t *TitleLogo_Wbuff, uint32_t TitleLogoWriteSize) {
   if (TitleLogoWriteSize <= 0)
     return 0;
   if ((DeviceCode == 0x9488) || (DeviceCode == 0x5761))
     W25QXX.SPI_FLASH_BufferWrite(TitleLogo_Wbuff, PIC_ICON_LOGO_ADDR_TFT35 + TitleLogoWrite_Addroffset, TitleLogoWriteSize);
   else
     W25QXX.SPI_FLASH_BufferWrite(TitleLogo_Wbuff, PIC_ICON_LOGO_ADDR_TFT32 + TitleLogoWrite_Addroffset, TitleLogoWriteSize);
   TitleLogoWrite_Addroffset += TitleLogoWriteSize;
   if (TitleLogoWrite_Addroffset >= TITLELOGO_MAX_SIZE)
     TitleLogoWrite_Addroffset = 0;
   return 1;
 }
 
 uint32_t default_view_addroffset_r = 0;
 void default_view_Write(uint8_t *default_view__Rbuff, uint32_t default_view_Writesize) {
   W25QXX.SPI_FLASH_BufferWrite(default_view__Rbuff, DEFAULT_VIEW_ADDR_TFT35 + default_view_addroffset_r, default_view_Writesize);
   default_view_addroffset_r += default_view_Writesize;
   if (default_view_addroffset_r >= DEFAULT_VIEW_MAX_SIZE)
     default_view_addroffset_r = 0;
 }
 
-uint32_t Pic_Info_Write(uint8_t *P_name, uint32_t P_size) {
+uint32_t picInfoWrite(uint8_t *P_name, uint32_t P_size) {
   uint8_t pic_counter = 0;
-  uint32_t Pic_SaveAddr;
+  uint32_t picSaveAddr;
   uint32_t Pic_SizeSaveAddr;
-  uint32_t Pic_NameSaveAddr;
-  uint8_t Pname_temp;
+  uint32_t picNameSaveAddr;
+  uint8_t pNameTemp;
   uint32_t i, j;
   uint32_t name_len = 0;
-  uint32_t SaveName_len = 0;
+  uint32_t saveNameLen = 0;
   union union32 size_tmp;
 
   W25QXX.SPI_FLASH_BufferRead(&pic_counter, PIC_COUNTER_ADDR, 1);
 
   if (pic_counter == 0xFF)
     pic_counter = 0;
 
   if ((DeviceCode == 0x9488) || (DeviceCode == 0x5761))
-    Pic_SaveAddr = PIC_DATA_ADDR_TFT35 + pic_counter * PER_PIC_MAX_SPACE_TFT35;
+    picSaveAddr = PIC_DATA_ADDR_TFT35 + pic_counter * PER_PIC_MAX_SPACE_TFT35;
   else
-    Pic_SaveAddr = PIC_DATA_ADDR_TFT32 + pic_counter * PER_PIC_MAX_SPACE_TFT32;
+    picSaveAddr = PIC_DATA_ADDR_TFT32 + pic_counter * PER_PIC_MAX_SPACE_TFT32;
 
   for (j = 0; j < pic_counter; j++) {
     do {
-      W25QXX.SPI_FLASH_BufferRead(&Pname_temp, PIC_NAME_ADDR + SaveName_len, 1);
-      SaveName_len++;
-    } while (Pname_temp != '\0');
+      W25QXX.SPI_FLASH_BufferRead(&pNameTemp, PIC_NAME_ADDR + saveNameLen, 1);
+      saveNameLen++;
+    } while (pNameTemp != '\0');
   }
   i = 0;
   while ((*(P_name + i) != '\0')) {
     i++;
     name_len++;
   }
 
-  Pic_NameSaveAddr = PIC_NAME_ADDR + SaveName_len;
-  W25QXX.SPI_FLASH_BufferWrite(P_name, Pic_NameSaveAddr, name_len + 1);
+  picNameSaveAddr = PIC_NAME_ADDR + saveNameLen;
+  W25QXX.SPI_FLASH_BufferWrite(P_name, picNameSaveAddr, name_len + 1);
   Pic_SizeSaveAddr = PIC_SIZE_ADDR + 4 * pic_counter;
   size_tmp.dwords = P_size;
   W25QXX.SPI_FLASH_BufferWrite(size_tmp.bytes, Pic_SizeSaveAddr, 4);
 
   pic_counter++;
   W25QXX.SPI_FLASH_SectorErase(PIC_COUNTER_ADDR);
   W25QXX.SPI_FLASH_BufferWrite(&pic_counter, PIC_COUNTER_ADDR, 1);
 
-  return Pic_SaveAddr;
+  return picSaveAddr;
 }
 
 #if HAS_MEDIA
 
   static void dosName2LongName(const char dosName[11], char *longName) {
     uint8_t j = 0;
     for (uint8_t i = 0; i < 11; ++i) {
       if (i == 8) longName[j++] = '.';
       if (dosName[i] == '\0' || dosName[i] == ' ') continue;
       longName[j++] = dosName[i];
@@ -423,39 +423,39 @@ uint32_t Pic_Info_Write(uint8_t *P_name, uint32_t P_size) {
     uint16_t pbr;
     uint32_t pfileSize;
     uint32_t totalSizeLoaded = 0;
     uint32_t Pic_Write_Addr;
     pfileSize = file.fileSize();
     totalSizeLoaded += pfileSize;
     if (assetType == ASSET_TYPE_LOGO) {
       do {
         hal.watchdog_refresh();
         pbr = file.read(public_buf, BMP_WRITE_BUF_LEN);
-        Pic_Logo_Write((uint8_t*)fn, public_buf, pbr);
+        picLogoWrite((uint8_t*)fn, public_buf, pbr);
       } while (pbr >= BMP_WRITE_BUF_LEN);
     }
     else if (assetType == ASSET_TYPE_TITLE_LOGO) {
       do {
         hal.watchdog_refresh();
         pbr = file.read(public_buf, BMP_WRITE_BUF_LEN);
-        Pic_TitleLogo_Write((uint8_t*)fn, public_buf, pbr);
+        picTitleLogoWrite((uint8_t*)fn, public_buf, pbr);
       } while (pbr >= BMP_WRITE_BUF_LEN);
     }
     else if (assetType == ASSET_TYPE_G_PREVIEW) {
       do {
         hal.watchdog_refresh();
         pbr = file.read(public_buf, BMP_WRITE_BUF_LEN);
         default_view_Write(public_buf, pbr);
       } while (pbr >= BMP_WRITE_BUF_LEN);
     }
     else if (assetType == ASSET_TYPE_ICON) {
-      Pic_Write_Addr = Pic_Info_Write((uint8_t*)fn, pfileSize);
+      Pic_Write_Addr = picInfoWrite((uint8_t*)fn, pfileSize);
       SPIFlash.beginWrite(Pic_Write_Addr);
       #if HAS_SPI_FLASH_COMPRESSION
         do {
           hal.watchdog_refresh();
           pbr = file.read(public_buf, SPI_FLASH_PageSize);
           TERN_(MARLIN_DEV_MODE, totalSizes += pbr);
           SPIFlash.writeData(public_buf, SPI_FLASH_PageSize);
         } while (pbr >= SPI_FLASH_PageSize);
       #else
         do {
@@ -543,21 +543,21 @@ uint32_t Pic_Info_Write(uint8_t *P_name, uint32_t P_size) {
       SERIAL_ECHOLNPGM("Total Uncompressed: ", totalSizes, ", Compressed: ", totalCompressed);
     #endif
   }
 
   #if HAS_SPI_FLASH_FONT
     void spi_flash_read_test() { W25QXX.SPI_FLASH_BufferRead(public_buf, UNIGBK_FLASH_ADDR, BMP_WRITE_BUF_LEN); }
   #endif
 
 #endif // HAS_MEDIA
 
-void Pic_Read(uint8_t *Pname, uint8_t *P_Rbuff) {
+void picRead(uint8_t *Pname, uint8_t *P_Rbuff) {
   uint8_t i, j;
   uint8_t Pic_cnt;
   uint32_t tmp_cnt = 0;
   PIC_MSG PIC;
 
   W25QXX.SPI_FLASH_BufferRead(&Pic_cnt, PIC_COUNTER_ADDR, 1);
   if (Pic_cnt == 0xFF)
     Pic_cnt = 0;
 
   for (i = 0; i < Pic_cnt; i++) {
@@ -589,21 +589,21 @@ void lv_pic_test(uint8_t *P_Rbuff, uint32_t addr, uint32_t size) {
 }
 
 #if HAS_SPI_FLASH_FONT
   void get_spi_flash_data(const char *rec_buf, int addr, int size) {
     W25QXX.init(SPI_QUARTER_SPEED);
     W25QXX.SPI_FLASH_BufferRead((uint8_t *)rec_buf, UNIGBK_FLASH_ADDR + addr, size);
   }
 #endif
 
 uint32_t logo_addroffset = 0;
-void Pic_Logo_Read(uint8_t *LogoName, uint8_t *Logo_Rbuff, uint32_t LogoReadsize) {
+void picLogoRead(uint8_t *LogoName, uint8_t *Logo_Rbuff, uint32_t LogoReadsize) {
   W25QXX.init(SPI_QUARTER_SPEED);
   W25QXX.SPI_FLASH_BufferRead(Logo_Rbuff, PIC_LOGO_ADDR + logo_addroffset, LogoReadsize);
   logo_addroffset += LogoReadsize;
   if (logo_addroffset >= LOGO_MAX_SIZE_TFT35)
     logo_addroffset = 0;
 }
 
 uint32_t default_view_addroffset = 0;
 void default_view_Read(uint8_t *default_view_Rbuff, uint32_t default_view_Readsize) {
   W25QXX.init(SPI_QUARTER_SPEED);

commit 86c811660ebf0b3fcbae2f34273d4c9d0c22abc4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:30:34 2023 -0500

    üßë‚Äçüíª Remove LOOP macros (#25917)

diff --git a/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp b/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp
index 6e39c9a36e..7c0ec802c3 100644
--- a/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp
+++ b/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp
@@ -372,21 +372,21 @@ uint32_t Pic_Info_Write(uint8_t *P_name, uint32_t P_size) {
   W25QXX.SPI_FLASH_SectorErase(PIC_COUNTER_ADDR);
   W25QXX.SPI_FLASH_BufferWrite(&pic_counter, PIC_COUNTER_ADDR, 1);
 
   return Pic_SaveAddr;
 }
 
 #if HAS_MEDIA
 
   static void dosName2LongName(const char dosName[11], char *longName) {
     uint8_t j = 0;
-    LOOP_L_N(i, 11) {
+    for (uint8_t i = 0; i < 11; ++i) {
       if (i == 8) longName[j++] = '.';
       if (dosName[i] == '\0' || dosName[i] == ' ') continue;
       longName[j++] = dosName[i];
     }
     longName[j] = '\0';
   }
 
   static int8_t arrayFindStr(FSTR_P const arr[], uint8_t arraySize, const char *str) {
     for (uint8_t a = 0; a < arraySize; a++) {
       if (strcasecmp(FTOP(arr[a]), str) == 0)

commit 4812ed5053983212c9ec8a6229a150a1af7822f1
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon May 1 18:45:42 2023 -0500

    üé® Misc. code cleanup

diff --git a/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp b/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp
index 6570176a29..6e39c9a36e 100644
--- a/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp
+++ b/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp
@@ -17,30 +17,31 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 #include "../../../inc/MarlinConfigPre.h"
 
 #if HAS_TFT_LVGL_UI
 
-#include "string.h"
 #include "draw_ui.h"
 #include "pic_manager.h"
 #include "draw_ready_print.h"
 #include "mks_hardware.h"
 #include "SPIFlashStorage.h"
 #include "../../../libs/W25Qxx.h"
 #include "../../../sd/cardreader.h"
 #include "../../../MarlinCore.h"
 
+#include <string.h>
+
 extern uint16_t DeviceCode;
 
 #if HAS_MEDIA
   extern char *createFilename(char * const buffer, const dir_t &p);
 #endif
 
 static FSTR_P const assets[] = {
   // Homing screen
   F("bmp_zeroAll.bin"),
   F("bmp_zero.bin"),

commit 5664c02d077e028f84a24efd96c2eebe97ce8763
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 22 22:43:09 2023 -0500

    üßë‚Äçüíª Generalize SDSUPPORT as HAS_MEDIA
    
    In preparation for single- and multi-volume refactoring.

diff --git a/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp b/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp
index d642d81f6b..6570176a29 100644
--- a/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp
+++ b/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp
@@ -29,21 +29,21 @@
 #include "pic_manager.h"
 #include "draw_ready_print.h"
 #include "mks_hardware.h"
 #include "SPIFlashStorage.h"
 #include "../../../libs/W25Qxx.h"
 #include "../../../sd/cardreader.h"
 #include "../../../MarlinCore.h"
 
 extern uint16_t DeviceCode;
 
-#if ENABLED(SDSUPPORT)
+#if HAS_MEDIA
   extern char *createFilename(char * const buffer, const dir_t &p);
 #endif
 
 static FSTR_P const assets[] = {
   // Homing screen
   F("bmp_zeroAll.bin"),
   F("bmp_zero.bin"),
   F("bmp_zeroX.bin"),
   F("bmp_zeroY.bin"),
   F("bmp_zeroZ.bin"),
@@ -367,21 +367,21 @@ uint32_t Pic_Info_Write(uint8_t *P_name, uint32_t P_size) {
   size_tmp.dwords = P_size;
   W25QXX.SPI_FLASH_BufferWrite(size_tmp.bytes, Pic_SizeSaveAddr, 4);
 
   pic_counter++;
   W25QXX.SPI_FLASH_SectorErase(PIC_COUNTER_ADDR);
   W25QXX.SPI_FLASH_BufferWrite(&pic_counter, PIC_COUNTER_ADDR, 1);
 
   return Pic_SaveAddr;
 }
 
-#if ENABLED(SDSUPPORT)
+#if HAS_MEDIA
 
   static void dosName2LongName(const char dosName[11], char *longName) {
     uint8_t j = 0;
     LOOP_L_N(i, 11) {
       if (i == 8) longName[j++] = '.';
       if (dosName[i] == '\0' || dosName[i] == ' ') continue;
       longName[j++] = dosName[i];
     }
     longName[j] = '\0';
   }
@@ -540,21 +540,21 @@ uint32_t Pic_Info_Write(uint8_t *P_name, uint32_t P_size) {
       W25QXX.SPI_FLASH_BufferRead(&pic_counter, PIC_COUNTER_ADDR, 1);
       SERIAL_ECHOLNPGM("Total assets loaded: ", pic_counter);
       SERIAL_ECHOLNPGM("Total Uncompressed: ", totalSizes, ", Compressed: ", totalCompressed);
     #endif
   }
 
   #if HAS_SPI_FLASH_FONT
     void spi_flash_read_test() { W25QXX.SPI_FLASH_BufferRead(public_buf, UNIGBK_FLASH_ADDR, BMP_WRITE_BUF_LEN); }
   #endif
 
-#endif // SDSUPPORT
+#endif // HAS_MEDIA
 
 void Pic_Read(uint8_t *Pname, uint8_t *P_Rbuff) {
   uint8_t i, j;
   uint8_t Pic_cnt;
   uint32_t tmp_cnt = 0;
   PIC_MSG PIC;
 
   W25QXX.SPI_FLASH_BufferRead(&Pic_cnt, PIC_COUNTER_ADDR, 1);
   if (Pic_cnt == 0xFF)
     Pic_cnt = 0;

commit 218ca0530432d6b1194ccac5fc32a72bbc9a7c96
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Sat Feb 4 05:10:26 2023 -0300

    üßë‚Äçüíª General 'MediaFile' type alias (#24424)

diff --git a/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp b/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp
index c618127980..d642d81f6b 100644
--- a/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp
+++ b/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp
@@ -396,22 +396,22 @@ uint32_t Pic_Info_Write(uint8_t *P_name, uint32_t P_size) {
 
   #if ENABLED(MARLIN_DEV_MODE)
     static uint32_t totalSizes = 0, totalCompressed = 0;
   #endif
 
   #define ASSET_TYPE_ICON       0
   #define ASSET_TYPE_LOGO       1
   #define ASSET_TYPE_TITLE_LOGO 2
   #define ASSET_TYPE_G_PREVIEW  3
   #define ASSET_TYPE_FONT       4
-  static void loadAsset(SdFile &dir, dir_t& entry, FSTR_P const fn, int8_t assetType) {
-    SdFile file;
+  static void loadAsset(MediaFile &dir, dir_t& entry, FSTR_P const fn, int8_t assetType) {
+    MediaFile file;
     char dosFilename[FILENAME_LENGTH];
     createFilename(dosFilename, entry);
     if (!file.open(&dir, dosFilename, O_READ)) {
       #if ENABLED(MARLIN_DEV_MODE)
         SERIAL_ECHOLNPGM("Error opening Asset: ", fn);
       #endif
       return;
     }
 
     hal.watchdog_refresh();
@@ -481,21 +481,21 @@ uint32_t Pic_Info_Write(uint8_t *P_name, uint32_t P_size) {
 
     file.close();
 
     #if ENABLED(MARLIN_DEV_MODE)
       SERIAL_ECHOLNPGM("Asset added: ", fn);
     #endif
   }
 
   void UpdateAssets() {
     if (!card.isMounted()) return;
-    SdFile dir, root = card.getroot();
+    MediaFile dir, root = card.getroot();
     if (dir.open(&root, assetsPath, O_RDONLY)) {
 
       disp_assets_update();
       disp_assets_update_progress(F("Erasing pics..."));
       hal.watchdog_refresh();
       spiFlashErase_PIC();
       #if HAS_SPI_FLASH_FONT
         disp_assets_update_progress(F("Erasing fonts..."));
         hal.watchdog_refresh();
         spiFlashErase_FONT();

commit 52eefa90e1c18616f127cdf43798907880e05ee5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 19 11:36:13 2022 -0500

    ‚ôªÔ∏è Move watchdog to MarlinHAL

diff --git a/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp b/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp
index ba2df10ecb..c618127980 100644
--- a/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp
+++ b/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp
@@ -260,36 +260,36 @@ uint32_t lv_get_pic_addr(uint8_t *Pname) {
 }
 
 const char *assetsPath = "assets";
 const char *bakPath = "_assets";
 
 void spiFlashErase_PIC() {
   volatile uint32_t pic_sectorcnt = 0;
   W25QXX.init(SPI_QUARTER_SPEED);
   // erase 0x001000 -64K
   for (pic_sectorcnt = 0; pic_sectorcnt < (64 - 4) / 4; pic_sectorcnt++) {
-    watchdog_refresh();
+    hal.watchdog_refresh();
     W25QXX.SPI_FLASH_SectorErase(PICINFOADDR + pic_sectorcnt * 4 * 1024);
   }
   // erase 64K -- 6M
   for (pic_sectorcnt = 0; pic_sectorcnt < (PIC_SIZE_xM * 1024 / 64 - 1); pic_sectorcnt++) {
-    watchdog_refresh();
+    hal.watchdog_refresh();
     W25QXX.SPI_FLASH_BlockErase((pic_sectorcnt + 1) * 64 * 1024);
   }
 }
 
 #if HAS_SPI_FLASH_FONT
   void spiFlashErase_FONT() {
     volatile uint32_t Font_sectorcnt = 0;
     W25QXX.init(SPI_QUARTER_SPEED);
     for (Font_sectorcnt = 0; Font_sectorcnt < 32 - 1; Font_sectorcnt++) {
-      watchdog_refresh();
+      hal.watchdog_refresh();
       W25QXX.SPI_FLASH_BlockErase(FONTINFOADDR + Font_sectorcnt * 64 * 1024);
     }
   }
 #endif
 
 uint32_t LogoWrite_Addroffset = 0;
 
 uint8_t Pic_Logo_Write(uint8_t *LogoName, uint8_t *Logo_Wbuff, uint32_t LogoWriteSize) {
   if (LogoWriteSize <= 0) return 0;
 
@@ -407,104 +407,104 @@ uint32_t Pic_Info_Write(uint8_t *P_name, uint32_t P_size) {
     SdFile file;
     char dosFilename[FILENAME_LENGTH];
     createFilename(dosFilename, entry);
     if (!file.open(&dir, dosFilename, O_READ)) {
       #if ENABLED(MARLIN_DEV_MODE)
         SERIAL_ECHOLNPGM("Error opening Asset: ", fn);
       #endif
       return;
     }
 
-    watchdog_refresh();
+    hal.watchdog_refresh();
     disp_assets_update_progress(fn);
 
     W25QXX.init(SPI_QUARTER_SPEED);
 
     uint16_t pbr;
     uint32_t pfileSize;
     uint32_t totalSizeLoaded = 0;
     uint32_t Pic_Write_Addr;
     pfileSize = file.fileSize();
     totalSizeLoaded += pfileSize;
     if (assetType == ASSET_TYPE_LOGO) {
       do {
-        watchdog_refresh();
+        hal.watchdog_refresh();
         pbr = file.read(public_buf, BMP_WRITE_BUF_LEN);
         Pic_Logo_Write((uint8_t*)fn, public_buf, pbr);
       } while (pbr >= BMP_WRITE_BUF_LEN);
     }
     else if (assetType == ASSET_TYPE_TITLE_LOGO) {
       do {
-        watchdog_refresh();
+        hal.watchdog_refresh();
         pbr = file.read(public_buf, BMP_WRITE_BUF_LEN);
         Pic_TitleLogo_Write((uint8_t*)fn, public_buf, pbr);
       } while (pbr >= BMP_WRITE_BUF_LEN);
     }
     else if (assetType == ASSET_TYPE_G_PREVIEW) {
       do {
-        watchdog_refresh();
+        hal.watchdog_refresh();
         pbr = file.read(public_buf, BMP_WRITE_BUF_LEN);
         default_view_Write(public_buf, pbr);
       } while (pbr >= BMP_WRITE_BUF_LEN);
     }
     else if (assetType == ASSET_TYPE_ICON) {
       Pic_Write_Addr = Pic_Info_Write((uint8_t*)fn, pfileSize);
       SPIFlash.beginWrite(Pic_Write_Addr);
       #if HAS_SPI_FLASH_COMPRESSION
         do {
-          watchdog_refresh();
+          hal.watchdog_refresh();
           pbr = file.read(public_buf, SPI_FLASH_PageSize);
           TERN_(MARLIN_DEV_MODE, totalSizes += pbr);
           SPIFlash.writeData(public_buf, SPI_FLASH_PageSize);
         } while (pbr >= SPI_FLASH_PageSize);
       #else
         do {
           pbr = file.read(public_buf, BMP_WRITE_BUF_LEN);
           W25QXX.SPI_FLASH_BufferWrite(public_buf, Pic_Write_Addr, pbr);
           Pic_Write_Addr += pbr;
         } while (pbr >= BMP_WRITE_BUF_LEN);
       #endif
       #if ENABLED(MARLIN_DEV_MODE)
         SERIAL_ECHOLNPGM("Space used: ", fn, " - ", (SPIFlash.getCurrentPage() + 1) * SPI_FLASH_PageSize / 1024, "KB");
         totalCompressed += (SPIFlash.getCurrentPage() + 1) * SPI_FLASH_PageSize;
       #endif
       SPIFlash.endWrite();
     }
     else if (assetType == ASSET_TYPE_FONT) {
       Pic_Write_Addr = UNIGBK_FLASH_ADDR;
       do {
-        watchdog_refresh();
+        hal.watchdog_refresh();
         pbr = file.read(public_buf, BMP_WRITE_BUF_LEN);
         W25QXX.SPI_FLASH_BufferWrite(public_buf, Pic_Write_Addr, pbr);
         Pic_Write_Addr += pbr;
       } while (pbr >= BMP_WRITE_BUF_LEN);
     }
 
     file.close();
 
     #if ENABLED(MARLIN_DEV_MODE)
       SERIAL_ECHOLNPGM("Asset added: ", fn);
     #endif
   }
 
   void UpdateAssets() {
     if (!card.isMounted()) return;
     SdFile dir, root = card.getroot();
     if (dir.open(&root, assetsPath, O_RDONLY)) {
 
       disp_assets_update();
       disp_assets_update_progress(F("Erasing pics..."));
-      watchdog_refresh();
+      hal.watchdog_refresh();
       spiFlashErase_PIC();
       #if HAS_SPI_FLASH_FONT
         disp_assets_update_progress(F("Erasing fonts..."));
-        watchdog_refresh();
+        hal.watchdog_refresh();
         spiFlashErase_FONT();
       #endif
 
       disp_assets_update_progress(F("Reading files..."));
       dir_t d;
       while (dir.readDir(&d, card.longFilename) > 0) {
         // If we don't get a long name, but gets a short one, try it
         if (card.longFilename[0] == 0 && d.name[0] != 0)
           dosName2LongName((const char*)d.name, card.longFilename);
         if (card.longFilename[0] == 0) continue;

commit d1938d54ed5e42d766d97d898cd117893ea24083
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 28 19:28:29 2021 -0500

    üé® Apply F() to MKS UI errors, assets

diff --git a/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp b/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp
index 8333709074..ba2df10ecb 100644
--- a/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp
+++ b/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp
@@ -33,200 +33,200 @@
 #include "../../../libs/W25Qxx.h"
 #include "../../../sd/cardreader.h"
 #include "../../../MarlinCore.h"
 
 extern uint16_t DeviceCode;
 
 #if ENABLED(SDSUPPORT)
   extern char *createFilename(char * const buffer, const dir_t &p);
 #endif
 
-static const char assets[][LONG_FILENAME_LENGTH] = {
+static FSTR_P const assets[] = {
   // Homing screen
-  "bmp_zeroAll.bin",
-  "bmp_zero.bin",
-  "bmp_zeroX.bin",
-  "bmp_zeroY.bin",
-  "bmp_zeroZ.bin",
-  "bmp_manual_off.bin",
+  F("bmp_zeroAll.bin"),
+  F("bmp_zero.bin"),
+  F("bmp_zeroX.bin"),
+  F("bmp_zeroY.bin"),
+  F("bmp_zeroZ.bin"),
+  F("bmp_manual_off.bin"),
 
   // Tool screen
-  "bmp_preHeat.bin",
-  "bmp_extruct.bin",
-  "bmp_mov.bin",
-  "bmp_leveling.bin",
-  "bmp_filamentchange.bin",
-  "bmp_more.bin",
+  F("bmp_preHeat.bin"),
+  F("bmp_extruct.bin"),
+  F("bmp_mov.bin"),
+  F("bmp_leveling.bin"),
+  F("bmp_filamentchange.bin"),
+  F("bmp_more.bin"),
 
   // Fan screen
-  "bmp_Add.bin",
-  "bmp_Dec.bin",
-  "bmp_speed255.bin",
-  "bmp_speed127.bin",
-  "bmp_speed0.bin",
+  F("bmp_Add.bin"),
+  F("bmp_Dec.bin"),
+  F("bmp_speed255.bin"),
+  F("bmp_speed127.bin"),
+  F("bmp_speed0.bin"),
 
-  "bmp_bed.bin",
-  "bmp_step1_degree.bin",
-  "bmp_step5_degree.bin",
-  "bmp_step10_degree.bin",
+  F("bmp_bed.bin"),
+  F("bmp_step1_degree.bin"),
+  F("bmp_step5_degree.bin"),
+  F("bmp_step10_degree.bin"),
 
   // Extrusion screen
-  "bmp_in.bin",
-  "bmp_out.bin",
-  "bmp_extru1.bin",
+  F("bmp_in.bin"),
+  F("bmp_out.bin"),
+  F("bmp_extru1.bin"),
   #if HAS_MULTI_EXTRUDER
-    "bmp_extru2.bin",
+    F("bmp_extru2.bin"),
   #endif
-  "bmp_speed_high.bin",
-  "bmp_speed_slow.bin",
-  "bmp_speed_normal.bin",
-  "bmp_step1_mm.bin",
-  "bmp_step5_mm.bin",
-  "bmp_step10_mm.bin",
+  F("bmp_speed_high.bin"),
+  F("bmp_speed_slow.bin"),
+  F("bmp_speed_normal.bin"),
+  F("bmp_step1_mm.bin"),
+  F("bmp_step5_mm.bin"),
+  F("bmp_step10_mm.bin"),
 
   // Select file screen
-  "bmp_pageUp.bin",
-  "bmp_pageDown.bin",
-  "bmp_back.bin", //TODO: why two back buttons? Why not just one? (return / back)
-  "bmp_dir.bin",
-  "bmp_file.bin",
+  F("bmp_pageUp.bin"),
+  F("bmp_pageDown.bin"),
+  F("bmp_back.bin"), // TODO: why two back buttons? Why not just one? (return / back)
+  F("bmp_dir.bin"),
+  F("bmp_file.bin"),
 
   // Move motor screen
   // TODO: 6 equal icons, just in diffenct rotation... it may be optimized too
-  "bmp_xAdd.bin",
-  "bmp_xDec.bin",
-  "bmp_yAdd.bin",
-  "bmp_yDec.bin",
-  "bmp_zAdd.bin",
-  "bmp_zDec.bin",
-  "bmp_step_move0_1.bin",
-  "bmp_step_move1.bin",
-  "bmp_step_move10.bin",
+  F("bmp_xAdd.bin"),
+  F("bmp_xDec.bin"),
+  F("bmp_yAdd.bin"),
+  F("bmp_yDec.bin"),
+  F("bmp_zAdd.bin"),
+  F("bmp_zDec.bin"),
+  F("bmp_step_move0_1.bin"),
+  F("bmp_step_move1.bin"),
+  F("bmp_step_move10.bin"),
 
   // Operation screen
-  "bmp_auto_off.bin",
-  "bmp_speed.bin",
-  "bmp_fan.bin",
-  "bmp_temp.bin",
-  "bmp_extrude_opr.bin",
-  "bmp_move_opr.bin",
+  F("bmp_auto_off.bin"),
+  F("bmp_speed.bin"),
+  F("bmp_fan.bin"),
+  F("bmp_temp.bin"),
+  F("bmp_extrude_opr.bin"),
+  F("bmp_move_opr.bin"),
 
   // Change speed screen
-  "bmp_step1_percent.bin",
-  "bmp_step5_percent.bin",
-  "bmp_step10_percent.bin",
-  "bmp_extruct_sel.bin",
-  "bmp_mov_changespeed.bin",
-  "bmp_mov_sel.bin",
-  "bmp_speed_extruct.bin",
+  F("bmp_step1_percent.bin"),
+  F("bmp_step5_percent.bin"),
+  F("bmp_step10_percent.bin"),
+  F("bmp_extruct_sel.bin"),
+  F("bmp_mov_changespeed.bin"),
+  F("bmp_mov_sel.bin"),
+  F("bmp_speed_extruct.bin"),
 
   // Printing screen
-  "bmp_pause.bin",
-  "bmp_resume.bin",
-  "bmp_stop.bin",
-  "bmp_ext1_state.bin",
+  F("bmp_pause.bin"),
+  F("bmp_resume.bin"),
+  F("bmp_stop.bin"),
+  F("bmp_ext1_state.bin"),
   #if HAS_MULTI_EXTRUDER
-    "bmp_ext2_state.bin",
+    F("bmp_ext2_state.bin"),
   #endif
-  "bmp_bed_state.bin",
-  "bmp_fan_state.bin",
-  "bmp_time_state.bin",
-  "bmp_zpos_state.bin",
-  "bmp_operate.bin",
+  F("bmp_bed_state.bin"),
+  F("bmp_fan_state.bin"),
+  F("bmp_time_state.bin"),
+  F("bmp_zpos_state.bin"),
+  F("bmp_operate.bin"),
 
   // Manual Level screen (only if auto level is disabled)
   #if DISABLED(AUTO_BED_LEVELING_BILINEAR)
-    "bmp_leveling1.bin",
-    "bmp_leveling2.bin",
-    "bmp_leveling3.bin",
-    "bmp_leveling4.bin",
-    "bmp_leveling5.bin",
+    F("bmp_leveling1.bin"),
+    F("bmp_leveling2.bin"),
+    F("bmp_leveling3.bin"),
+    F("bmp_leveling4.bin"),
+    F("bmp_leveling5.bin"),
   #endif
 
   // Language Select screen
   #if HAS_LANG_SELECT_SCREEN
-    "bmp_language.bin",
-    "bmp_simplified_cn.bin",
-    "bmp_simplified_cn_sel.bin",
-    "bmp_traditional_cn.bin",
-    "bmp_traditional_cn_sel.bin",
-    "bmp_english.bin",
-    "bmp_english_sel.bin",
-    "bmp_russian.bin",
-    "bmp_russian_sel.bin",
-    "bmp_spanish.bin",
-    "bmp_spanish_sel.bin",
-    "bmp_french.bin",
-    "bmp_french_sel.bin",
-    "bmp_italy.bin",
-    "bmp_italy_sel.bin",
+    F("bmp_language.bin"),
+    F("bmp_simplified_cn.bin"),
+    F("bmp_simplified_cn_sel.bin"),
+    F("bmp_traditional_cn.bin"),
+    F("bmp_traditional_cn_sel.bin"),
+    F("bmp_english.bin"),
+    F("bmp_english_sel.bin"),
+    F("bmp_russian.bin"),
+    F("bmp_russian_sel.bin"),
+    F("bmp_spanish.bin"),
+    F("bmp_spanish_sel.bin"),
+    F("bmp_french.bin"),
+    F("bmp_french_sel.bin"),
+    F("bmp_italy.bin"),
+    F("bmp_italy_sel.bin"),
   #endif // HAS_LANG_SELECT_SCREEN
 
   // G-code preview
   #if HAS_GCODE_DEFAULT_VIEW_IN_FLASH
-    "bmp_preview.bin",
+    F("bmp_preview.bin"),
   #endif
 
   #if HAS_LOGO_IN_FLASH
-    "bmp_logo.bin",
+    F("bmp_logo.bin"),
   #endif
 
   // Settings screen
-  "bmp_about.bin",
-  "bmp_eeprom_settings.bin",
-  "bmp_machine_para.bin",
-  "bmp_function1.bin",
+  F("bmp_about.bin"),
+  F("bmp_eeprom_settings.bin"),
+  F("bmp_machine_para.bin"),
+  F("bmp_function1.bin"),
 
   // Start screen
-  "bmp_printing.bin",
-  "bmp_set.bin",
-  "bmp_tool.bin",
+  F("bmp_printing.bin"),
+  F("bmp_set.bin"),
+  F("bmp_tool.bin"),
 
   // Base icons
-  "bmp_arrow.bin",
-  "bmp_back70x40.bin",
-  "bmp_value_blank.bin",
-  "bmp_blank_sel.bin",
-  "bmp_disable.bin",
-  "bmp_enable.bin",
-  "bmp_return.bin",
+  F("bmp_arrow.bin"),
+  F("bmp_back70x40.bin"),
+  F("bmp_value_blank.bin"),
+  F("bmp_blank_sel.bin"),
+  F("bmp_disable.bin"),
+  F("bmp_enable.bin"),
+  F("bmp_return.bin"),
 
   #if ENABLED(MKS_WIFI_MODULE)
     // Wifi screen
-    "bmp_wifi.bin",
-    "bmp_cloud.bin",
+    F("bmp_wifi.bin"),
+    F("bmp_cloud.bin"),
   #endif
 
   #if ENABLED(MULTI_VOLUME)
-    "bmp_usb_disk.bin",
-    // "bmp_usb_disk_sel.bin",
-    "bmp_sd.bin",
-    // "bmp_sd_sel.bin",
+    F("bmp_usb_disk.bin"),
+    //F("bmp_usb_disk_sel.bin"),
+    F("bmp_sd.bin"),
+    //F("bmp_sd_sel.bin"),
   #endif
 
   // Babystep screen
-  "bmp_baby_move0_01.bin",
-  "bmp_baby_move0_05.bin",
-  "bmp_baby_move0_1.bin",
+  F("bmp_baby_move0_01.bin"),
+  F("bmp_baby_move0_05.bin"),
+  F("bmp_baby_move0_1.bin"),
 
   // More screen
-  "bmp_custom1.bin",
-  "bmp_custom2.bin",
-  "bmp_custom3.bin",
-  "bmp_custom4.bin",
-  "bmp_custom5.bin",
-  "bmp_custom6.bin",
-  "bmp_custom7.bin"
+  F("bmp_custom1.bin"),
+  F("bmp_custom2.bin"),
+  F("bmp_custom3.bin"),
+  F("bmp_custom4.bin"),
+  F("bmp_custom5.bin"),
+  F("bmp_custom6.bin"),
+  F("bmp_custom7.bin")
 };
 
 #if HAS_SPI_FLASH_FONT
-  static char fonts[][LONG_FILENAME_LENGTH] = { "FontUNIGBK.bin" };
+  static FSTR_P const fonts[] = { F("FontUNIGBK.bin") };
 #endif
 
 uint8_t currentFlashPage = 0;
 
 uint32_t lv_get_pic_addr(uint8_t *Pname) {
   uint8_t Pic_cnt;
   uint8_t i, j;
   PIC_MSG PIC;
   uint32_t tmp_cnt = 0;
   uint32_t addr = 0;
@@ -379,38 +379,38 @@ uint32_t Pic_Info_Write(uint8_t *P_name, uint32_t P_size) {
   static void dosName2LongName(const char dosName[11], char *longName) {
     uint8_t j = 0;
     LOOP_L_N(i, 11) {
       if (i == 8) longName[j++] = '.';
       if (dosName[i] == '\0' || dosName[i] == ' ') continue;
       longName[j++] = dosName[i];
     }
     longName[j] = '\0';
   }
 
-  static int8_t arrayFindStr(const char arr[][LONG_FILENAME_LENGTH], uint8_t arraySize, const char *str) {
+  static int8_t arrayFindStr(FSTR_P const arr[], uint8_t arraySize, const char *str) {
     for (uint8_t a = 0; a < arraySize; a++) {
-      if (strcasecmp(arr[a], str) == 0)
+      if (strcasecmp(FTOP(arr[a]), str) == 0)
         return a;
     }
     return -1;
   }
 
   #if ENABLED(MARLIN_DEV_MODE)
     static uint32_t totalSizes = 0, totalCompressed = 0;
   #endif
 
   #define ASSET_TYPE_ICON       0
   #define ASSET_TYPE_LOGO       1
   #define ASSET_TYPE_TITLE_LOGO 2
   #define ASSET_TYPE_G_PREVIEW  3
   #define ASSET_TYPE_FONT       4
-  static void loadAsset(SdFile &dir, dir_t& entry, const char *fn, int8_t assetType) {
+  static void loadAsset(SdFile &dir, dir_t& entry, FSTR_P const fn, int8_t assetType) {
     SdFile file;
     char dosFilename[FILENAME_LENGTH];
     createFilename(dosFilename, entry);
     if (!file.open(&dir, dosFilename, O_READ)) {
       #if ENABLED(MARLIN_DEV_MODE)
         SERIAL_ECHOLNPGM("Error opening Asset: ", fn);
       #endif
       return;
     }
 
@@ -422,39 +422,39 @@ uint32_t Pic_Info_Write(uint8_t *P_name, uint32_t P_size) {
     uint16_t pbr;
     uint32_t pfileSize;
     uint32_t totalSizeLoaded = 0;
     uint32_t Pic_Write_Addr;
     pfileSize = file.fileSize();
     totalSizeLoaded += pfileSize;
     if (assetType == ASSET_TYPE_LOGO) {
       do {
         watchdog_refresh();
         pbr = file.read(public_buf, BMP_WRITE_BUF_LEN);
-        Pic_Logo_Write((uint8_t *)fn, public_buf, pbr);
+        Pic_Logo_Write((uint8_t*)fn, public_buf, pbr);
       } while (pbr >= BMP_WRITE_BUF_LEN);
     }
     else if (assetType == ASSET_TYPE_TITLE_LOGO) {
       do {
         watchdog_refresh();
         pbr = file.read(public_buf, BMP_WRITE_BUF_LEN);
-        Pic_TitleLogo_Write((uint8_t *)fn, public_buf, pbr);
+        Pic_TitleLogo_Write((uint8_t*)fn, public_buf, pbr);
       } while (pbr >= BMP_WRITE_BUF_LEN);
     }
     else if (assetType == ASSET_TYPE_G_PREVIEW) {
       do {
         watchdog_refresh();
         pbr = file.read(public_buf, BMP_WRITE_BUF_LEN);
         default_view_Write(public_buf, pbr);
       } while (pbr >= BMP_WRITE_BUF_LEN);
     }
     else if (assetType == ASSET_TYPE_ICON) {
-      Pic_Write_Addr = Pic_Info_Write((uint8_t *)fn, pfileSize);
+      Pic_Write_Addr = Pic_Info_Write((uint8_t*)fn, pfileSize);
       SPIFlash.beginWrite(Pic_Write_Addr);
       #if HAS_SPI_FLASH_COMPRESSION
         do {
           watchdog_refresh();
           pbr = file.read(public_buf, SPI_FLASH_PageSize);
           TERN_(MARLIN_DEV_MODE, totalSizes += pbr);
           SPIFlash.writeData(public_buf, SPI_FLASH_PageSize);
         } while (pbr >= SPI_FLASH_PageSize);
       #else
         do {
@@ -485,46 +485,46 @@ uint32_t Pic_Info_Write(uint8_t *P_name, uint32_t P_size) {
       SERIAL_ECHOLNPGM("Asset added: ", fn);
     #endif
   }
 
   void UpdateAssets() {
     if (!card.isMounted()) return;
     SdFile dir, root = card.getroot();
     if (dir.open(&root, assetsPath, O_RDONLY)) {
 
       disp_assets_update();
-      disp_assets_update_progress("Erasing pics...");
+      disp_assets_update_progress(F("Erasing pics..."));
       watchdog_refresh();
       spiFlashErase_PIC();
       #if HAS_SPI_FLASH_FONT
-        disp_assets_update_progress("Erasing fonts...");
+        disp_assets_update_progress(F("Erasing fonts..."));
         watchdog_refresh();
         spiFlashErase_FONT();
       #endif
 
-      disp_assets_update_progress("Reading files...");
+      disp_assets_update_progress(F("Reading files..."));
       dir_t d;
       while (dir.readDir(&d, card.longFilename) > 0) {
         // If we don't get a long name, but gets a short one, try it
         if (card.longFilename[0] == 0 && d.name[0] != 0)
           dosName2LongName((const char*)d.name, card.longFilename);
         if (card.longFilename[0] == 0) continue;
         if (card.longFilename[0] == '.') continue;
 
         int8_t a = arrayFindStr(assets, COUNT(assets), card.longFilename);
         if (a >= 0 && a < (int8_t)COUNT(assets)) {
           uint8_t assetType = ASSET_TYPE_ICON;
-          if (strstr(assets[a], "_logo"))
+          if (strstr_P(FTOP(assets[a]), PSTR("_logo")))
             assetType = ASSET_TYPE_LOGO;
-          else if (strstr(assets[a], "_titlelogo"))
+          else if (strstr_P(FTOP(assets[a]), PSTR("_titlelogo")))
             assetType = ASSET_TYPE_TITLE_LOGO;
-          else if (strstr(assets[a], "_preview"))
+          else if (strstr_P(FTOP(assets[a]), PSTR("_preview")))
             assetType = ASSET_TYPE_G_PREVIEW;
 
           loadAsset(dir, d, assets[a], assetType);
 
           continue;
         }
 
         #if HAS_SPI_FLASH_FONT
           a = arrayFindStr(fonts, COUNT(fonts), card.longFilename);
           if (a >= 0 && a < (int8_t)COUNT(fonts))

commit 8df3e62c89f94f68465ac30e276333940e069ff7
Author: Sola <42537573+solawc@users.noreply.github.com>
Date:   Thu Sep 16 19:48:24 2021 +0800

    üö∏ Fix and improve MKS LVGL UI (#22783)
    
    Co-authored-by: makerbase <4164049@qq.com>
    Co-authored-by: MKS-Sean <56996910+MKS-Sean@users.noreply.github.com>
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp b/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp
index 2e24d6a2c0..8333709074 100644
--- a/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp
+++ b/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp
@@ -258,37 +258,37 @@ uint32_t lv_get_pic_addr(uint8_t *Pname) {
   }
   return addr;
 }
 
 const char *assetsPath = "assets";
 const char *bakPath = "_assets";
 
 void spiFlashErase_PIC() {
   volatile uint32_t pic_sectorcnt = 0;
   W25QXX.init(SPI_QUARTER_SPEED);
-  //erase 0x001000 -64K
+  // erase 0x001000 -64K
   for (pic_sectorcnt = 0; pic_sectorcnt < (64 - 4) / 4; pic_sectorcnt++) {
     watchdog_refresh();
     W25QXX.SPI_FLASH_SectorErase(PICINFOADDR + pic_sectorcnt * 4 * 1024);
   }
-  //erase 64K -- 6M
+  // erase 64K -- 6M
   for (pic_sectorcnt = 0; pic_sectorcnt < (PIC_SIZE_xM * 1024 / 64 - 1); pic_sectorcnt++) {
     watchdog_refresh();
     W25QXX.SPI_FLASH_BlockErase((pic_sectorcnt + 1) * 64 * 1024);
   }
 }
 
 #if HAS_SPI_FLASH_FONT
   void spiFlashErase_FONT() {
     volatile uint32_t Font_sectorcnt = 0;
     W25QXX.init(SPI_QUARTER_SPEED);
-    for (Font_sectorcnt = 0; Font_sectorcnt < 32-1; Font_sectorcnt++) {
+    for (Font_sectorcnt = 0; Font_sectorcnt < 32 - 1; Font_sectorcnt++) {
       watchdog_refresh();
       W25QXX.SPI_FLASH_BlockErase(FONTINFOADDR + Font_sectorcnt * 64 * 1024);
     }
   }
 #endif
 
 uint32_t LogoWrite_Addroffset = 0;
 
 uint8_t Pic_Logo_Write(uint8_t *LogoName, uint8_t *Logo_Wbuff, uint32_t LogoWriteSize) {
   if (LogoWriteSize <= 0) return 0;
@@ -558,21 +558,21 @@ void Pic_Read(uint8_t *Pname, uint8_t *P_Rbuff) {
   W25QXX.SPI_FLASH_BufferRead(&Pic_cnt, PIC_COUNTER_ADDR, 1);
   if (Pic_cnt == 0xFF)
     Pic_cnt = 0;
 
   for (i = 0; i < Pic_cnt; i++) {
     j = 0;
     do {
       W25QXX.SPI_FLASH_BufferRead(&PIC.name[j], PIC_NAME_ADDR + tmp_cnt, 1);
       tmp_cnt++;
     } while (PIC.name[j++] != '\0');
-    //pic size
+    // pic size
     W25QXX.SPI_FLASH_BufferRead(PIC.size.bytes, PIC_SIZE_ADDR + i * 4, 4);
 
     if ((strcmp((char*)Pname, (char*)PIC.name)) == 0) {
       W25QXX.SPI_FLASH_BufferRead((uint8_t *)P_Rbuff, PIC_DATA_ADDR_TFT35 + i * PER_PIC_MAX_SPACE_TFT35, PIC.size.dwords);
       break;
     }
   }
 }
 
 void lv_pic_test(uint8_t *P_Rbuff, uint32_t addr, uint32_t size) {

commit 323b38ee88dbf2a4691a20439dbb95a824822199
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Sep 16 04:36:26 2021 -0500

    üí° Adjust headers, formatting

diff --git a/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp b/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp
index 624626a322..2e24d6a2c0 100644
--- a/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp
+++ b/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp
@@ -12,20 +12,21 @@
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
+
 #include "../../../inc/MarlinConfigPre.h"
 
 #if HAS_TFT_LVGL_UI
 
 #include "string.h"
 #include "draw_ui.h"
 #include "pic_manager.h"
 #include "draw_ready_print.h"
 #include "mks_hardware.h"
 #include "SPIFlashStorage.h"

commit 754b31918a73cb08c322102be5d3926d2ac59c18
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 9 04:57:05 2021 -0500

    üé® Fewer serial macros

diff --git a/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp b/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp
index 0a5f5cd550..624626a322 100644
--- a/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp
+++ b/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp
@@ -226,21 +226,21 @@ uint8_t currentFlashPage = 0;
 uint32_t lv_get_pic_addr(uint8_t *Pname) {
   uint8_t Pic_cnt;
   uint8_t i, j;
   PIC_MSG PIC;
   uint32_t tmp_cnt = 0;
   uint32_t addr = 0;
 
   currentFlashPage = 0;
 
   #if ENABLED(MARLIN_DEV_MODE)
-    SERIAL_ECHOLNPAIR("Getting picture SPI Flash Address: ", (const char*)Pname);
+    SERIAL_ECHOLNPGM("Getting picture SPI Flash Address: ", (const char*)Pname);
   #endif
 
   W25QXX.init(SPI_QUARTER_SPEED);
 
   W25QXX.SPI_FLASH_BufferRead(&Pic_cnt, PIC_COUNTER_ADDR, 1);
   if (Pic_cnt == 0xFF) Pic_cnt = 0;
   for (i = 0; i < Pic_cnt; i++) {
     j = 0;
     do {
       W25QXX.SPI_FLASH_BufferRead(&PIC.name[j], PIC_NAME_ADDR + tmp_cnt, 1);
@@ -401,21 +401,21 @@ uint32_t Pic_Info_Write(uint8_t *P_name, uint32_t P_size) {
   #define ASSET_TYPE_LOGO       1
   #define ASSET_TYPE_TITLE_LOGO 2
   #define ASSET_TYPE_G_PREVIEW  3
   #define ASSET_TYPE_FONT       4
   static void loadAsset(SdFile &dir, dir_t& entry, const char *fn, int8_t assetType) {
     SdFile file;
     char dosFilename[FILENAME_LENGTH];
     createFilename(dosFilename, entry);
     if (!file.open(&dir, dosFilename, O_READ)) {
       #if ENABLED(MARLIN_DEV_MODE)
-        SERIAL_ECHOLNPAIR("Error opening Asset: ", fn);
+        SERIAL_ECHOLNPGM("Error opening Asset: ", fn);
       #endif
       return;
     }
 
     watchdog_refresh();
     disp_assets_update_progress(fn);
 
     W25QXX.init(SPI_QUARTER_SPEED);
 
     uint16_t pbr;
@@ -456,39 +456,39 @@ uint32_t Pic_Info_Write(uint8_t *P_name, uint32_t P_size) {
           SPIFlash.writeData(public_buf, SPI_FLASH_PageSize);
         } while (pbr >= SPI_FLASH_PageSize);
       #else
         do {
           pbr = file.read(public_buf, BMP_WRITE_BUF_LEN);
           W25QXX.SPI_FLASH_BufferWrite(public_buf, Pic_Write_Addr, pbr);
           Pic_Write_Addr += pbr;
         } while (pbr >= BMP_WRITE_BUF_LEN);
       #endif
       #if ENABLED(MARLIN_DEV_MODE)
-        SERIAL_ECHOLNPAIR("Space used: ", fn, " - ", (SPIFlash.getCurrentPage() + 1) * SPI_FLASH_PageSize / 1024, "KB");
+        SERIAL_ECHOLNPGM("Space used: ", fn, " - ", (SPIFlash.getCurrentPage() + 1) * SPI_FLASH_PageSize / 1024, "KB");
         totalCompressed += (SPIFlash.getCurrentPage() + 1) * SPI_FLASH_PageSize;
       #endif
       SPIFlash.endWrite();
     }
     else if (assetType == ASSET_TYPE_FONT) {
       Pic_Write_Addr = UNIGBK_FLASH_ADDR;
       do {
         watchdog_refresh();
         pbr = file.read(public_buf, BMP_WRITE_BUF_LEN);
         W25QXX.SPI_FLASH_BufferWrite(public_buf, Pic_Write_Addr, pbr);
         Pic_Write_Addr += pbr;
       } while (pbr >= BMP_WRITE_BUF_LEN);
     }
 
     file.close();
 
     #if ENABLED(MARLIN_DEV_MODE)
-      SERIAL_ECHOLNPAIR("Asset added: ", fn);
+      SERIAL_ECHOLNPGM("Asset added: ", fn);
     #endif
   }
 
   void UpdateAssets() {
     if (!card.isMounted()) return;
     SdFile dir, root = card.getroot();
     if (dir.open(&root, assetsPath, O_RDONLY)) {
 
       disp_assets_update();
       disp_assets_update_progress("Erasing pics...");
@@ -530,22 +530,22 @@ uint32_t Pic_Info_Write(uint8_t *P_name, uint32_t P_size) {
             loadAsset(dir, d, fonts[a], ASSET_TYPE_FONT);
         #endif
       }
       dir.rename(&root, bakPath);
     }
     dir.close();
 
     #if ENABLED(MARLIN_DEV_MODE)
       uint8_t pic_counter = 0;
       W25QXX.SPI_FLASH_BufferRead(&pic_counter, PIC_COUNTER_ADDR, 1);
-      SERIAL_ECHOLNPAIR("Total assets loaded: ", pic_counter);
-      SERIAL_ECHOLNPAIR("Total Uncompressed: ", totalSizes, ", Compressed: ", totalCompressed);
+      SERIAL_ECHOLNPGM("Total assets loaded: ", pic_counter);
+      SERIAL_ECHOLNPGM("Total Uncompressed: ", totalSizes, ", Compressed: ", totalCompressed);
     #endif
   }
 
   #if HAS_SPI_FLASH_FONT
     void spi_flash_read_test() { W25QXX.SPI_FLASH_BufferRead(public_buf, UNIGBK_FLASH_ADDR, BMP_WRITE_BUF_LEN); }
   #endif
 
 #endif // SDSUPPORT
 
 void Pic_Read(uint8_t *Pname, uint8_t *P_Rbuff) {

commit afca6e745932d295b88d37fa9bd4274e22705b0b
Author: luzpaz <luzpaz@users.noreply.github.com>
Date:   Tue Aug 3 20:02:34 2021 -0400

    üêõ Spellcheck comments (#22496)
    
    codespell -q 3 --builtin=clear,rare,informal,code -S ./Marlin/src/lcd/language -L alo,amin,endcode,stdio,uint

diff --git a/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp b/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp
index 68344e770c..0a5f5cd550 100644
--- a/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp
+++ b/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp
@@ -496,21 +496,21 @@ uint32_t Pic_Info_Write(uint8_t *P_name, uint32_t P_size) {
       spiFlashErase_PIC();
       #if HAS_SPI_FLASH_FONT
         disp_assets_update_progress("Erasing fonts...");
         watchdog_refresh();
         spiFlashErase_FONT();
       #endif
 
       disp_assets_update_progress("Reading files...");
       dir_t d;
       while (dir.readDir(&d, card.longFilename) > 0) {
-        // If we dont get a long name, but gets a short one, try it
+        // If we don't get a long name, but gets a short one, try it
         if (card.longFilename[0] == 0 && d.name[0] != 0)
           dosName2LongName((const char*)d.name, card.longFilename);
         if (card.longFilename[0] == 0) continue;
         if (card.longFilename[0] == '.') continue;
 
         int8_t a = arrayFindStr(assets, COUNT(assets), card.longFilename);
         if (a >= 0 && a < (int8_t)COUNT(assets)) {
           uint8_t assetType = ASSET_TYPE_ICON;
           if (strstr(assets[a], "_logo"))
             assetType = ASSET_TYPE_LOGO;

commit 67019bc2778c00ec0ba80519078ad5ecc57f06ff
Author: Malderin <52313714+Malderin@users.noreply.github.com>
Date:   Mon Jul 19 05:21:51 2021 +0300

    Fix MKS UI compile (#22388)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp b/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp
index 03e408e32a..68344e770c 100644
--- a/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp
+++ b/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp
@@ -20,28 +20,23 @@
  *
  */
 #include "../../../inc/MarlinConfigPre.h"
 
 #if HAS_TFT_LVGL_UI
 
 #include "string.h"
 #include "draw_ui.h"
 #include "pic_manager.h"
 #include "draw_ready_print.h"
-
-#if ENABLED(MKS_TEST)
-  #include "mks_hardware_test.h"
-#endif
-
+#include "mks_hardware.h"
 #include "SPIFlashStorage.h"
 #include "../../../libs/W25Qxx.h"
-
 #include "../../../sd/cardreader.h"
 #include "../../../MarlinCore.h"
 
 extern uint16_t DeviceCode;
 
 #if ENABLED(SDSUPPORT)
   extern char *createFilename(char * const buffer, const dir_t &p);
 #endif
 
 static const char assets[][LONG_FILENAME_LENGTH] = {

commit 4febb2352179f3de58db2161572de4050197bd5d
Author: MKS-Sean <56996910+MKS-Sean@users.noreply.github.com>
Date:   Tue Jul 13 08:17:28 2021 +0800

    ‚ú® MKS Robin Nano v3 + TFT_LVGL_UI + WiFi module (#22109)

diff --git a/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp b/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp
index da7b1929ce..03e408e32a 100644
--- a/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp
+++ b/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp
@@ -20,21 +20,24 @@
  *
  */
 #include "../../../inc/MarlinConfigPre.h"
 
 #if HAS_TFT_LVGL_UI
 
 #include "string.h"
 #include "draw_ui.h"
 #include "pic_manager.h"
 #include "draw_ready_print.h"
-#include "mks_hardware_test.h"
+
+#if ENABLED(MKS_TEST)
+  #include "mks_hardware_test.h"
+#endif
 
 #include "SPIFlashStorage.h"
 #include "../../../libs/W25Qxx.h"
 
 #include "../../../sd/cardreader.h"
 #include "../../../MarlinCore.h"
 
 extern uint16_t DeviceCode;
 
 #if ENABLED(SDSUPPORT)

commit 8d9021e8069c0550e9a31107adf44b9112b87471
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 6 04:17:59 2021 -0500

    Move ExtUI subfolders up a level (#21820)

diff --git a/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp b/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp
new file mode 100644
index 0000000000..da7b1929ce
--- /dev/null
+++ b/Marlin/src/lcd/extui/mks_ui/pic_manager.cpp
@@ -0,0 +1,627 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ *
+ */
+#include "../../../inc/MarlinConfigPre.h"
+
+#if HAS_TFT_LVGL_UI
+
+#include "string.h"
+#include "draw_ui.h"
+#include "pic_manager.h"
+#include "draw_ready_print.h"
+#include "mks_hardware_test.h"
+
+#include "SPIFlashStorage.h"
+#include "../../../libs/W25Qxx.h"
+
+#include "../../../sd/cardreader.h"
+#include "../../../MarlinCore.h"
+
+extern uint16_t DeviceCode;
+
+#if ENABLED(SDSUPPORT)
+  extern char *createFilename(char * const buffer, const dir_t &p);
+#endif
+
+static const char assets[][LONG_FILENAME_LENGTH] = {
+  // Homing screen
+  "bmp_zeroAll.bin",
+  "bmp_zero.bin",
+  "bmp_zeroX.bin",
+  "bmp_zeroY.bin",
+  "bmp_zeroZ.bin",
+  "bmp_manual_off.bin",
+
+  // Tool screen
+  "bmp_preHeat.bin",
+  "bmp_extruct.bin",
+  "bmp_mov.bin",
+  "bmp_leveling.bin",
+  "bmp_filamentchange.bin",
+  "bmp_more.bin",
+
+  // Fan screen
+  "bmp_Add.bin",
+  "bmp_Dec.bin",
+  "bmp_speed255.bin",
+  "bmp_speed127.bin",
+  "bmp_speed0.bin",
+
+  "bmp_bed.bin",
+  "bmp_step1_degree.bin",
+  "bmp_step5_degree.bin",
+  "bmp_step10_degree.bin",
+
+  // Extrusion screen
+  "bmp_in.bin",
+  "bmp_out.bin",
+  "bmp_extru1.bin",
+  #if HAS_MULTI_EXTRUDER
+    "bmp_extru2.bin",
+  #endif
+  "bmp_speed_high.bin",
+  "bmp_speed_slow.bin",
+  "bmp_speed_normal.bin",
+  "bmp_step1_mm.bin",
+  "bmp_step5_mm.bin",
+  "bmp_step10_mm.bin",
+
+  // Select file screen
+  "bmp_pageUp.bin",
+  "bmp_pageDown.bin",
+  "bmp_back.bin", //TODO: why two back buttons? Why not just one? (return / back)
+  "bmp_dir.bin",
+  "bmp_file.bin",
+
+  // Move motor screen
+  // TODO: 6 equal icons, just in diffenct rotation... it may be optimized too
+  "bmp_xAdd.bin",
+  "bmp_xDec.bin",
+  "bmp_yAdd.bin",
+  "bmp_yDec.bin",
+  "bmp_zAdd.bin",
+  "bmp_zDec.bin",
+  "bmp_step_move0_1.bin",
+  "bmp_step_move1.bin",
+  "bmp_step_move10.bin",
+
+  // Operation screen
+  "bmp_auto_off.bin",
+  "bmp_speed.bin",
+  "bmp_fan.bin",
+  "bmp_temp.bin",
+  "bmp_extrude_opr.bin",
+  "bmp_move_opr.bin",
+
+  // Change speed screen
+  "bmp_step1_percent.bin",
+  "bmp_step5_percent.bin",
+  "bmp_step10_percent.bin",
+  "bmp_extruct_sel.bin",
+  "bmp_mov_changespeed.bin",
+  "bmp_mov_sel.bin",
+  "bmp_speed_extruct.bin",
+
+  // Printing screen
+  "bmp_pause.bin",
+  "bmp_resume.bin",
+  "bmp_stop.bin",
+  "bmp_ext1_state.bin",
+  #if HAS_MULTI_EXTRUDER
+    "bmp_ext2_state.bin",
+  #endif
+  "bmp_bed_state.bin",
+  "bmp_fan_state.bin",
+  "bmp_time_state.bin",
+  "bmp_zpos_state.bin",
+  "bmp_operate.bin",
+
+  // Manual Level screen (only if auto level is disabled)
+  #if DISABLED(AUTO_BED_LEVELING_BILINEAR)
+    "bmp_leveling1.bin",
+    "bmp_leveling2.bin",
+    "bmp_leveling3.bin",
+    "bmp_leveling4.bin",
+    "bmp_leveling5.bin",
+  #endif
+
+  // Language Select screen
+  #if HAS_LANG_SELECT_SCREEN
+    "bmp_language.bin",
+    "bmp_simplified_cn.bin",
+    "bmp_simplified_cn_sel.bin",
+    "bmp_traditional_cn.bin",
+    "bmp_traditional_cn_sel.bin",
+    "bmp_english.bin",
+    "bmp_english_sel.bin",
+    "bmp_russian.bin",
+    "bmp_russian_sel.bin",
+    "bmp_spanish.bin",
+    "bmp_spanish_sel.bin",
+    "bmp_french.bin",
+    "bmp_french_sel.bin",
+    "bmp_italy.bin",
+    "bmp_italy_sel.bin",
+  #endif // HAS_LANG_SELECT_SCREEN
+
+  // G-code preview
+  #if HAS_GCODE_DEFAULT_VIEW_IN_FLASH
+    "bmp_preview.bin",
+  #endif
+
+  #if HAS_LOGO_IN_FLASH
+    "bmp_logo.bin",
+  #endif
+
+  // Settings screen
+  "bmp_about.bin",
+  "bmp_eeprom_settings.bin",
+  "bmp_machine_para.bin",
+  "bmp_function1.bin",
+
+  // Start screen
+  "bmp_printing.bin",
+  "bmp_set.bin",
+  "bmp_tool.bin",
+
+  // Base icons
+  "bmp_arrow.bin",
+  "bmp_back70x40.bin",
+  "bmp_value_blank.bin",
+  "bmp_blank_sel.bin",
+  "bmp_disable.bin",
+  "bmp_enable.bin",
+  "bmp_return.bin",
+
+  #if ENABLED(MKS_WIFI_MODULE)
+    // Wifi screen
+    "bmp_wifi.bin",
+    "bmp_cloud.bin",
+  #endif
+
+  #if ENABLED(MULTI_VOLUME)
+    "bmp_usb_disk.bin",
+    // "bmp_usb_disk_sel.bin",
+    "bmp_sd.bin",
+    // "bmp_sd_sel.bin",
+  #endif
+
+  // Babystep screen
+  "bmp_baby_move0_01.bin",
+  "bmp_baby_move0_05.bin",
+  "bmp_baby_move0_1.bin",
+
+  // More screen
+  "bmp_custom1.bin",
+  "bmp_custom2.bin",
+  "bmp_custom3.bin",
+  "bmp_custom4.bin",
+  "bmp_custom5.bin",
+  "bmp_custom6.bin",
+  "bmp_custom7.bin"
+};
+
+#if HAS_SPI_FLASH_FONT
+  static char fonts[][LONG_FILENAME_LENGTH] = { "FontUNIGBK.bin" };
+#endif
+
+uint8_t currentFlashPage = 0;
+
+uint32_t lv_get_pic_addr(uint8_t *Pname) {
+  uint8_t Pic_cnt;
+  uint8_t i, j;
+  PIC_MSG PIC;
+  uint32_t tmp_cnt = 0;
+  uint32_t addr = 0;
+
+  currentFlashPage = 0;
+
+  #if ENABLED(MARLIN_DEV_MODE)
+    SERIAL_ECHOLNPAIR("Getting picture SPI Flash Address: ", (const char*)Pname);
+  #endif
+
+  W25QXX.init(SPI_QUARTER_SPEED);
+
+  W25QXX.SPI_FLASH_BufferRead(&Pic_cnt, PIC_COUNTER_ADDR, 1);
+  if (Pic_cnt == 0xFF) Pic_cnt = 0;
+  for (i = 0; i < Pic_cnt; i++) {
+    j = 0;
+    do {
+      W25QXX.SPI_FLASH_BufferRead(&PIC.name[j], PIC_NAME_ADDR + tmp_cnt, 1);
+      tmp_cnt++;
+    } while (PIC.name[j++] != '\0');
+
+    if ((strcasecmp((char*)Pname, (char*)PIC.name)) == 0) {
+      if (DeviceCode == 0x9488 || DeviceCode == 0x5761)
+        addr = PIC_DATA_ADDR_TFT35 + i * PER_PIC_MAX_SPACE_TFT35;
+      else
+        addr = PIC_DATA_ADDR_TFT32 + i * PER_PIC_MAX_SPACE_TFT32;
+      return addr;
+    }
+  }
+  return addr;
+}
+
+const char *assetsPath = "assets";
+const char *bakPath = "_assets";
+
+void spiFlashErase_PIC() {
+  volatile uint32_t pic_sectorcnt = 0;
+  W25QXX.init(SPI_QUARTER_SPEED);
+  //erase 0x001000 -64K
+  for (pic_sectorcnt = 0; pic_sectorcnt < (64 - 4) / 4; pic_sectorcnt++) {
+    watchdog_refresh();
+    W25QXX.SPI_FLASH_SectorErase(PICINFOADDR + pic_sectorcnt * 4 * 1024);
+  }
+  //erase 64K -- 6M
+  for (pic_sectorcnt = 0; pic_sectorcnt < (PIC_SIZE_xM * 1024 / 64 - 1); pic_sectorcnt++) {
+    watchdog_refresh();
+    W25QXX.SPI_FLASH_BlockErase((pic_sectorcnt + 1) * 64 * 1024);
+  }
+}
+
+#if HAS_SPI_FLASH_FONT
+  void spiFlashErase_FONT() {
+    volatile uint32_t Font_sectorcnt = 0;
+    W25QXX.init(SPI_QUARTER_SPEED);
+    for (Font_sectorcnt = 0; Font_sectorcnt < 32-1; Font_sectorcnt++) {
+      watchdog_refresh();
+      W25QXX.SPI_FLASH_BlockErase(FONTINFOADDR + Font_sectorcnt * 64 * 1024);
+    }
+  }
+#endif
+
+uint32_t LogoWrite_Addroffset = 0;
+
+uint8_t Pic_Logo_Write(uint8_t *LogoName, uint8_t *Logo_Wbuff, uint32_t LogoWriteSize) {
+  if (LogoWriteSize <= 0) return 0;
+
+  W25QXX.SPI_FLASH_BufferWrite(Logo_Wbuff, PIC_LOGO_ADDR + LogoWrite_Addroffset, LogoWriteSize);
+
+  for (uint32_t i = 0; i < LogoWriteSize; i++) {
+    uint8_t temp1;
+    W25QXX.SPI_FLASH_BufferRead(&temp1, PIC_LOGO_ADDR + LogoWrite_Addroffset + i, 1);
+    if (*(Logo_Wbuff + i) != temp1) return 0;
+  }
+  LogoWrite_Addroffset += LogoWriteSize;
+  const uint32_t logo_maxsize = DeviceCode == 0x9488 || DeviceCode == 0x5761 ? LOGO_MAX_SIZE_TFT35 : LOGO_MAX_SIZE_TFT32;
+  if (LogoWrite_Addroffset >= logo_maxsize) LogoWrite_Addroffset = 0;
+  return 1;
+}
+
+uint32_t TitleLogoWrite_Addroffset = 0;
+uint8_t Pic_TitleLogo_Write(uint8_t *TitleLogoName, uint8_t *TitleLogo_Wbuff, uint32_t TitleLogoWriteSize) {
+  if (TitleLogoWriteSize <= 0)
+    return 0;
+  if ((DeviceCode == 0x9488) || (DeviceCode == 0x5761))
+    W25QXX.SPI_FLASH_BufferWrite(TitleLogo_Wbuff, PIC_ICON_LOGO_ADDR_TFT35 + TitleLogoWrite_Addroffset, TitleLogoWriteSize);
+  else
+    W25QXX.SPI_FLASH_BufferWrite(TitleLogo_Wbuff, PIC_ICON_LOGO_ADDR_TFT32 + TitleLogoWrite_Addroffset, TitleLogoWriteSize);
+  TitleLogoWrite_Addroffset += TitleLogoWriteSize;
+  if (TitleLogoWrite_Addroffset >= TITLELOGO_MAX_SIZE)
+    TitleLogoWrite_Addroffset = 0;
+  return 1;
+}
+
+uint32_t default_view_addroffset_r = 0;
+void default_view_Write(uint8_t *default_view__Rbuff, uint32_t default_view_Writesize) {
+  W25QXX.SPI_FLASH_BufferWrite(default_view__Rbuff, DEFAULT_VIEW_ADDR_TFT35 + default_view_addroffset_r, default_view_Writesize);
+  default_view_addroffset_r += default_view_Writesize;
+  if (default_view_addroffset_r >= DEFAULT_VIEW_MAX_SIZE)
+    default_view_addroffset_r = 0;
+}
+
+uint32_t Pic_Info_Write(uint8_t *P_name, uint32_t P_size) {
+  uint8_t pic_counter = 0;
+  uint32_t Pic_SaveAddr;
+  uint32_t Pic_SizeSaveAddr;
+  uint32_t Pic_NameSaveAddr;
+  uint8_t Pname_temp;
+  uint32_t i, j;
+  uint32_t name_len = 0;
+  uint32_t SaveName_len = 0;
+  union union32 size_tmp;
+
+  W25QXX.SPI_FLASH_BufferRead(&pic_counter, PIC_COUNTER_ADDR, 1);
+
+  if (pic_counter == 0xFF)
+    pic_counter = 0;
+
+  if ((DeviceCode == 0x9488) || (DeviceCode == 0x5761))
+    Pic_SaveAddr = PIC_DATA_ADDR_TFT35 + pic_counter * PER_PIC_MAX_SPACE_TFT35;
+  else
+    Pic_SaveAddr = PIC_DATA_ADDR_TFT32 + pic_counter * PER_PIC_MAX_SPACE_TFT32;
+
+  for (j = 0; j < pic_counter; j++) {
+    do {
+      W25QXX.SPI_FLASH_BufferRead(&Pname_temp, PIC_NAME_ADDR + SaveName_len, 1);
+      SaveName_len++;
+    } while (Pname_temp != '\0');
+  }
+  i = 0;
+  while ((*(P_name + i) != '\0')) {
+    i++;
+    name_len++;
+  }
+
+  Pic_NameSaveAddr = PIC_NAME_ADDR + SaveName_len;
+  W25QXX.SPI_FLASH_BufferWrite(P_name, Pic_NameSaveAddr, name_len + 1);
+  Pic_SizeSaveAddr = PIC_SIZE_ADDR + 4 * pic_counter;
+  size_tmp.dwords = P_size;
+  W25QXX.SPI_FLASH_BufferWrite(size_tmp.bytes, Pic_SizeSaveAddr, 4);
+
+  pic_counter++;
+  W25QXX.SPI_FLASH_SectorErase(PIC_COUNTER_ADDR);
+  W25QXX.SPI_FLASH_BufferWrite(&pic_counter, PIC_COUNTER_ADDR, 1);
+
+  return Pic_SaveAddr;
+}
+
+#if ENABLED(SDSUPPORT)
+
+  static void dosName2LongName(const char dosName[11], char *longName) {
+    uint8_t j = 0;
+    LOOP_L_N(i, 11) {
+      if (i == 8) longName[j++] = '.';
+      if (dosName[i] == '\0' || dosName[i] == ' ') continue;
+      longName[j++] = dosName[i];
+    }
+    longName[j] = '\0';
+  }
+
+  static int8_t arrayFindStr(const char arr[][LONG_FILENAME_LENGTH], uint8_t arraySize, const char *str) {
+    for (uint8_t a = 0; a < arraySize; a++) {
+      if (strcasecmp(arr[a], str) == 0)
+        return a;
+    }
+    return -1;
+  }
+
+  #if ENABLED(MARLIN_DEV_MODE)
+    static uint32_t totalSizes = 0, totalCompressed = 0;
+  #endif
+
+  #define ASSET_TYPE_ICON       0
+  #define ASSET_TYPE_LOGO       1
+  #define ASSET_TYPE_TITLE_LOGO 2
+  #define ASSET_TYPE_G_PREVIEW  3
+  #define ASSET_TYPE_FONT       4
+  static void loadAsset(SdFile &dir, dir_t& entry, const char *fn, int8_t assetType) {
+    SdFile file;
+    char dosFilename[FILENAME_LENGTH];
+    createFilename(dosFilename, entry);
+    if (!file.open(&dir, dosFilename, O_READ)) {
+      #if ENABLED(MARLIN_DEV_MODE)
+        SERIAL_ECHOLNPAIR("Error opening Asset: ", fn);
+      #endif
+      return;
+    }
+
+    watchdog_refresh();
+    disp_assets_update_progress(fn);
+
+    W25QXX.init(SPI_QUARTER_SPEED);
+
+    uint16_t pbr;
+    uint32_t pfileSize;
+    uint32_t totalSizeLoaded = 0;
+    uint32_t Pic_Write_Addr;
+    pfileSize = file.fileSize();
+    totalSizeLoaded += pfileSize;
+    if (assetType == ASSET_TYPE_LOGO) {
+      do {
+        watchdog_refresh();
+        pbr = file.read(public_buf, BMP_WRITE_BUF_LEN);
+        Pic_Logo_Write((uint8_t *)fn, public_buf, pbr);
+      } while (pbr >= BMP_WRITE_BUF_LEN);
+    }
+    else if (assetType == ASSET_TYPE_TITLE_LOGO) {
+      do {
+        watchdog_refresh();
+        pbr = file.read(public_buf, BMP_WRITE_BUF_LEN);
+        Pic_TitleLogo_Write((uint8_t *)fn, public_buf, pbr);
+      } while (pbr >= BMP_WRITE_BUF_LEN);
+    }
+    else if (assetType == ASSET_TYPE_G_PREVIEW) {
+      do {
+        watchdog_refresh();
+        pbr = file.read(public_buf, BMP_WRITE_BUF_LEN);
+        default_view_Write(public_buf, pbr);
+      } while (pbr >= BMP_WRITE_BUF_LEN);
+    }
+    else if (assetType == ASSET_TYPE_ICON) {
+      Pic_Write_Addr = Pic_Info_Write((uint8_t *)fn, pfileSize);
+      SPIFlash.beginWrite(Pic_Write_Addr);
+      #if HAS_SPI_FLASH_COMPRESSION
+        do {
+          watchdog_refresh();
+          pbr = file.read(public_buf, SPI_FLASH_PageSize);
+          TERN_(MARLIN_DEV_MODE, totalSizes += pbr);
+          SPIFlash.writeData(public_buf, SPI_FLASH_PageSize);
+        } while (pbr >= SPI_FLASH_PageSize);
+      #else
+        do {
+          pbr = file.read(public_buf, BMP_WRITE_BUF_LEN);
+          W25QXX.SPI_FLASH_BufferWrite(public_buf, Pic_Write_Addr, pbr);
+          Pic_Write_Addr += pbr;
+        } while (pbr >= BMP_WRITE_BUF_LEN);
+      #endif
+      #if ENABLED(MARLIN_DEV_MODE)
+        SERIAL_ECHOLNPAIR("Space used: ", fn, " - ", (SPIFlash.getCurrentPage() + 1) * SPI_FLASH_PageSize / 1024, "KB");
+        totalCompressed += (SPIFlash.getCurrentPage() + 1) * SPI_FLASH_PageSize;
+      #endif
+      SPIFlash.endWrite();
+    }
+    else if (assetType == ASSET_TYPE_FONT) {
+      Pic_Write_Addr = UNIGBK_FLASH_ADDR;
+      do {
+        watchdog_refresh();
+        pbr = file.read(public_buf, BMP_WRITE_BUF_LEN);
+        W25QXX.SPI_FLASH_BufferWrite(public_buf, Pic_Write_Addr, pbr);
+        Pic_Write_Addr += pbr;
+      } while (pbr >= BMP_WRITE_BUF_LEN);
+    }
+
+    file.close();
+
+    #if ENABLED(MARLIN_DEV_MODE)
+      SERIAL_ECHOLNPAIR("Asset added: ", fn);
+    #endif
+  }
+
+  void UpdateAssets() {
+    if (!card.isMounted()) return;
+    SdFile dir, root = card.getroot();
+    if (dir.open(&root, assetsPath, O_RDONLY)) {
+
+      disp_assets_update();
+      disp_assets_update_progress("Erasing pics...");
+      watchdog_refresh();
+      spiFlashErase_PIC();
+      #if HAS_SPI_FLASH_FONT
+        disp_assets_update_progress("Erasing fonts...");
+        watchdog_refresh();
+        spiFlashErase_FONT();
+      #endif
+
+      disp_assets_update_progress("Reading files...");
+      dir_t d;
+      while (dir.readDir(&d, card.longFilename) > 0) {
+        // If we dont get a long name, but gets a short one, try it
+        if (card.longFilename[0] == 0 && d.name[0] != 0)
+          dosName2LongName((const char*)d.name, card.longFilename);
+        if (card.longFilename[0] == 0) continue;
+        if (card.longFilename[0] == '.') continue;
+
+        int8_t a = arrayFindStr(assets, COUNT(assets), card.longFilename);
+        if (a >= 0 && a < (int8_t)COUNT(assets)) {
+          uint8_t assetType = ASSET_TYPE_ICON;
+          if (strstr(assets[a], "_logo"))
+            assetType = ASSET_TYPE_LOGO;
+          else if (strstr(assets[a], "_titlelogo"))
+            assetType = ASSET_TYPE_TITLE_LOGO;
+          else if (strstr(assets[a], "_preview"))
+            assetType = ASSET_TYPE_G_PREVIEW;
+
+          loadAsset(dir, d, assets[a], assetType);
+
+          continue;
+        }
+
+        #if HAS_SPI_FLASH_FONT
+          a = arrayFindStr(fonts, COUNT(fonts), card.longFilename);
+          if (a >= 0 && a < (int8_t)COUNT(fonts))
+            loadAsset(dir, d, fonts[a], ASSET_TYPE_FONT);
+        #endif
+      }
+      dir.rename(&root, bakPath);
+    }
+    dir.close();
+
+    #if ENABLED(MARLIN_DEV_MODE)
+      uint8_t pic_counter = 0;
+      W25QXX.SPI_FLASH_BufferRead(&pic_counter, PIC_COUNTER_ADDR, 1);
+      SERIAL_ECHOLNPAIR("Total assets loaded: ", pic_counter);
+      SERIAL_ECHOLNPAIR("Total Uncompressed: ", totalSizes, ", Compressed: ", totalCompressed);
+    #endif
+  }
+
+  #if HAS_SPI_FLASH_FONT
+    void spi_flash_read_test() { W25QXX.SPI_FLASH_BufferRead(public_buf, UNIGBK_FLASH_ADDR, BMP_WRITE_BUF_LEN); }
+  #endif
+
+#endif // SDSUPPORT
+
+void Pic_Read(uint8_t *Pname, uint8_t *P_Rbuff) {
+  uint8_t i, j;
+  uint8_t Pic_cnt;
+  uint32_t tmp_cnt = 0;
+  PIC_MSG PIC;
+
+  W25QXX.SPI_FLASH_BufferRead(&Pic_cnt, PIC_COUNTER_ADDR, 1);
+  if (Pic_cnt == 0xFF)
+    Pic_cnt = 0;
+
+  for (i = 0; i < Pic_cnt; i++) {
+    j = 0;
+    do {
+      W25QXX.SPI_FLASH_BufferRead(&PIC.name[j], PIC_NAME_ADDR + tmp_cnt, 1);
+      tmp_cnt++;
+    } while (PIC.name[j++] != '\0');
+    //pic size
+    W25QXX.SPI_FLASH_BufferRead(PIC.size.bytes, PIC_SIZE_ADDR + i * 4, 4);
+
+    if ((strcmp((char*)Pname, (char*)PIC.name)) == 0) {
+      W25QXX.SPI_FLASH_BufferRead((uint8_t *)P_Rbuff, PIC_DATA_ADDR_TFT35 + i * PER_PIC_MAX_SPACE_TFT35, PIC.size.dwords);
+      break;
+    }
+  }
+}
+
+void lv_pic_test(uint8_t *P_Rbuff, uint32_t addr, uint32_t size) {
+  #if HAS_SPI_FLASH_COMPRESSION
+    if (currentFlashPage == 0)
+      SPIFlash.beginRead(addr);
+    SPIFlash.readData(P_Rbuff, size);
+    currentFlashPage++;
+  #else
+    W25QXX.init(SPI_QUARTER_SPEED);
+    W25QXX.SPI_FLASH_BufferRead((uint8_t *)P_Rbuff, addr, size);
+  #endif
+}
+
+#if HAS_SPI_FLASH_FONT
+  void get_spi_flash_data(const char *rec_buf, int addr, int size) {
+    W25QXX.init(SPI_QUARTER_SPEED);
+    W25QXX.SPI_FLASH_BufferRead((uint8_t *)rec_buf, UNIGBK_FLASH_ADDR + addr, size);
+  }
+#endif
+
+uint32_t logo_addroffset = 0;
+void Pic_Logo_Read(uint8_t *LogoName, uint8_t *Logo_Rbuff, uint32_t LogoReadsize) {
+  W25QXX.init(SPI_QUARTER_SPEED);
+  W25QXX.SPI_FLASH_BufferRead(Logo_Rbuff, PIC_LOGO_ADDR + logo_addroffset, LogoReadsize);
+  logo_addroffset += LogoReadsize;
+  if (logo_addroffset >= LOGO_MAX_SIZE_TFT35)
+    logo_addroffset = 0;
+}
+
+uint32_t default_view_addroffset = 0;
+void default_view_Read(uint8_t *default_view_Rbuff, uint32_t default_view_Readsize) {
+  W25QXX.init(SPI_QUARTER_SPEED);
+  W25QXX.SPI_FLASH_BufferRead(default_view_Rbuff, DEFAULT_VIEW_ADDR_TFT35 + default_view_addroffset, default_view_Readsize);
+  default_view_addroffset += default_view_Readsize;
+  if (default_view_addroffset >= DEFAULT_VIEW_MAX_SIZE)
+    default_view_addroffset = 0;
+}
+
+#if HAS_BAK_VIEW_IN_FLASH
+  uint32_t flash_view_addroffset = 0;
+  void flash_view_Read(uint8_t *flash_view_Rbuff, uint32_t flash_view_Readsize) {
+    W25QXX.init(SPI_QUARTER_SPEED);
+    W25QXX.SPI_FLASH_BufferRead(flash_view_Rbuff, BAK_VIEW_ADDR_TFT35 + flash_view_addroffset, flash_view_Readsize);
+    flash_view_addroffset += flash_view_Readsize;
+    if (flash_view_addroffset >= FLASH_VIEW_MAX_SIZE)
+      flash_view_addroffset = 0;
+  }
+#endif
+
+#endif // HAS_TFT_LVGL_UI
