commit 8d9021e8069c0550e9a31107adf44b9112b87471
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 6 04:17:59 2021 -0500

    Move ExtUI subfolders up a level (#21820)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
deleted file mode 100644
index f54b290c13..0000000000
--- a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
+++ /dev/null
@@ -1,516 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-#include "../../../../inc/MarlinConfigPre.h"
-
-#if HAS_TFT_LVGL_UI
-
-#include "SPI_TFT.h"
-
-#include "tft_lvgl_configuration.h"
-#include "draw_ready_print.h"
-
-#include "pic_manager.h"
-#include "mks_hardware_test.h"
-#include "draw_ui.h"
-#include "SPIFlashStorage.h"
-#include <lvgl.h>
-
-#include "../../../../MarlinCore.h"
-#include "../../../../inc/MarlinConfig.h"
-
-#include HAL_PATH(../../../../HAL, tft/xpt2046.h)
-#include "../../../marlinui.h"
-XPT2046 touch;
-
-#if ENABLED(POWER_LOSS_RECOVERY)
-  #include "../../../../feature/powerloss.h"
-#endif
-
-#if ENABLED(TOUCH_SCREEN_CALIBRATION)
-  #include "../../../tft_io/touch_calibration.h"
-  #include "draw_touch_calibration.h"
-#endif
-
-#if ENABLED(MKS_WIFI_MODULE)
-  #include "wifi_module.h"
-#endif
-
-#include <SPI.h>
-
-#ifndef TFT_WIDTH
-  #define TFT_WIDTH  480
-#endif
-#ifndef TFT_HEIGHT
-  #define TFT_HEIGHT 320
-#endif
-
-#if HAS_SPI_FLASH_FONT
-  void init_gb2312_font();
-#endif
-
-static lv_disp_buf_t disp_buf;
-lv_group_t*  g;
-#if ENABLED(SDSUPPORT)
-  void UpdateAssets();
-#endif
-uint16_t DeviceCode = 0x9488;
-extern uint8_t sel_id;
-
-uint8_t bmp_public_buf[14 * 1024];
-uint8_t public_buf[513];
-
-extern bool flash_preview_begin, default_preview_flg, gcode_preview_over;
-
-void SysTick_Callback() {
-  lv_tick_inc(1);
-  print_time_count();
-  #if ENABLED(MKS_WIFI_MODULE)
-    if (tips_disp.timer == TIPS_TIMER_START)
-      tips_disp.timer_count++;
-  #endif
-  if (uiCfg.filament_loading_time_flg) {
-    uiCfg.filament_loading_time_cnt++;
-    uiCfg.filament_rate = uint32_t(100.0f * uiCfg.filament_loading_time_cnt / SEC_TO_MS(uiCfg.filament_loading_time) + 0.5f);
-    if (uiCfg.filament_loading_time_cnt >= SEC_TO_MS(uiCfg.filament_loading_time)) {
-      uiCfg.filament_loading_time_cnt  = 0;
-      uiCfg.filament_loading_time_flg  = false;
-      uiCfg.filament_loading_completed = true;
-    }
-  }
-  if (uiCfg.filament_unloading_time_flg) {
-    uiCfg.filament_unloading_time_cnt++;
-    uiCfg.filament_rate = uint32_t(100.0f * uiCfg.filament_unloading_time_cnt / SEC_TO_MS(uiCfg.filament_unloading_time) + 0.5f);
-    if (uiCfg.filament_unloading_time_cnt >= SEC_TO_MS(uiCfg.filament_unloading_time)) {
-      uiCfg.filament_unloading_time_cnt  = 0;
-      uiCfg.filament_unloading_time_flg  = false;
-      uiCfg.filament_unloading_completed = true;
-      uiCfg.filament_rate = 100;
-    }
-  }
-}
-
-void tft_lvgl_init() {
-
-  W25QXX.init(SPI_QUARTER_SPEED);
-
-  gCfgItems_init();
-  ui_cfg_init();
-  disp_language_init();
-
-  watchdog_refresh();     // LVGL init takes time
-
-  #if MB(MKS_ROBIN_NANO)
-    OUT_WRITE(PB0, LOW);  // HE1
-  #endif
-
-  // Init TFT first!
-  SPI_TFT.spi_init(SPI_FULL_SPEED);
-  SPI_TFT.LCD_init();
-
-  watchdog_refresh();     // LVGL init takes time
-
-  #if ENABLED(SDSUPPORT)
-    UpdateAssets();
-    watchdog_refresh();   // LVGL init takes time
-  #endif
-
-  mks_test_get();
-
-  touch.Init();
-
-  lv_init();
-
-  lv_disp_buf_init(&disp_buf, bmp_public_buf, nullptr, LV_HOR_RES_MAX * 14); // Initialize the display buffer
-
-  lv_disp_drv_t disp_drv;     // Descriptor of a display driver
-  lv_disp_drv_init(&disp_drv);    // Basic initialization
-  disp_drv.flush_cb = my_disp_flush; // Set your driver function
-  disp_drv.buffer = &disp_buf;    // Assign the buffer to the display
-  lv_disp_drv_register(&disp_drv);  // Finally register the driver
-
-  lv_indev_drv_t indev_drv;
-  lv_indev_drv_init(&indev_drv);     // Descriptor of a input device driver
-  indev_drv.type = LV_INDEV_TYPE_POINTER; // Touch pad is a pointer-like device
-  indev_drv.read_cb = my_touchpad_read;  // Set your driver function
-  lv_indev_drv_register(&indev_drv);   // Finally register the driver
-
-  #if HAS_ROTARY_ENCODER
-    g = lv_group_create();
-    lv_indev_drv_t enc_drv;
-    lv_indev_drv_init(&enc_drv);
-    enc_drv.type = LV_INDEV_TYPE_ENCODER;
-    enc_drv.read_cb = my_mousewheel_read;
-    lv_indev_t * enc_indev = lv_indev_drv_register(&enc_drv);
-    lv_indev_set_group(enc_indev, g);
-  #endif
-
-  lv_fs_drv_t spi_flash_drv;
-  lv_fs_drv_init(&spi_flash_drv);
-  spi_flash_drv.letter = 'F';
-  spi_flash_drv.open_cb = spi_flash_open_cb;
-  spi_flash_drv.close_cb = spi_flash_close_cb;
-  spi_flash_drv.read_cb = spi_flash_read_cb;
-  spi_flash_drv.seek_cb = spi_flash_seek_cb;
-  spi_flash_drv.tell_cb = spi_flash_tell_cb;
-  lv_fs_drv_register(&spi_flash_drv);
-
-  lv_fs_drv_t sd_drv;
-  lv_fs_drv_init(&sd_drv);
-  sd_drv.letter = 'S';
-  sd_drv.open_cb = sd_open_cb;
-  sd_drv.close_cb = sd_close_cb;
-  sd_drv.read_cb = sd_read_cb;
-  sd_drv.seek_cb = sd_seek_cb;
-  sd_drv.tell_cb = sd_tell_cb;
-  lv_fs_drv_register(&sd_drv);
-
-  systick_attach_callback(SysTick_Callback);
-
-  #if HAS_SPI_FLASH_FONT
-    init_gb2312_font();
-  #endif
-
-  tft_style_init();
-  filament_pin_setup();
-  lv_encoder_pin_init();
-
-  TERN_(MKS_WIFI_MODULE, mks_wifi_firmware_update());
-
-  bool ready = true;
-  #if ENABLED(POWER_LOSS_RECOVERY)
-    recovery.load();
-    if (recovery.valid()) {
-      ready = false;
-      if (gCfgItems.from_flash_pic)
-        flash_preview_begin = true;
-      else
-        default_preview_flg = true;
-
-      uiCfg.print_state = REPRINTING;
-
-      strncpy(public_buf_m, recovery.info.sd_filename, sizeof(public_buf_m));
-      card.printLongPath(public_buf_m);
-      strncpy(list_file.long_name[sel_id], card.longFilename, sizeof(list_file.long_name[0]));
-      lv_draw_printing();
-    }
-  #endif
-
-  if (ready) lv_draw_ready_print();
-
-  if (mks_test_flag == 0x1E) mks_gpio_test();
-}
-
-void my_disp_flush(lv_disp_drv_t * disp, const lv_area_t * area, lv_color_t * color_p) {
-  uint16_t width = area->x2 - area->x1 + 1,
-          height = area->y2 - area->y1 + 1;
-
-  SPI_TFT.setWindow((uint16_t)area->x1, (uint16_t)area->y1, width, height);
-
-  for (uint16_t i = 0; i < height; i++)
-    SPI_TFT.tftio.WriteSequence((uint16_t*)(color_p + width * i), width);
-
-  lv_disp_flush_ready(disp); // Indicate you are ready with the flushing
-
-  W25QXX.init(SPI_QUARTER_SPEED);
-}
-
-void lv_fill_rect(lv_coord_t x1, lv_coord_t y1, lv_coord_t x2, lv_coord_t y2, lv_color_t bk_color) {
-  uint16_t width, height;
-  width = x2 - x1 + 1;
-  height = y2 - y1 + 1;
-  SPI_TFT.setWindow((uint16_t)x1, (uint16_t)y1, width, height);
-  SPI_TFT.tftio.WriteMultiple(bk_color.full, width * height);
-  W25QXX.init(SPI_QUARTER_SPEED);
-}
-
-#define TICK_CYCLE 1
-
-unsigned int getTickDiff(unsigned int curTick, unsigned int lastTick) {
-  return TICK_CYCLE * (lastTick <= curTick ? (curTick - lastTick) : (0xFFFFFFFF - lastTick + curTick));
-}
-
-static bool get_point(int16_t *x, int16_t *y) {
-  bool is_touched = touch.getRawPoint(x, y);
-
-  if (!is_touched) return false;
-
-  #if ENABLED(TOUCH_SCREEN_CALIBRATION)
-    const calibrationState state = touch_calibration.get_calibration_state();
-    if (state >= CALIBRATION_TOP_LEFT && state <= CALIBRATION_BOTTOM_RIGHT) {
-      if (touch_calibration.handleTouch(*x, *y)) lv_update_touch_calibration_screen();
-      return false;
-    }
-    *x = int16_t((int32_t(*x) * touch_calibration.calibration.x) >> 16) + touch_calibration.calibration.offset_x;
-    *y = int16_t((int32_t(*y) * touch_calibration.calibration.y) >> 16) + touch_calibration.calibration.offset_y;
-  #else
-    *x = int16_t((int32_t(*x) * TOUCH_CALIBRATION_X) >> 16) + TOUCH_OFFSET_X;
-    *y = int16_t((int32_t(*y) * TOUCH_CALIBRATION_Y) >> 16) + TOUCH_OFFSET_Y;
-  #endif
-
-  return true;
-}
-
-bool my_touchpad_read(lv_indev_drv_t * indev_driver, lv_indev_data_t * data) {
-  static int16_t last_x = 0, last_y = 0;
-  static uint8_t last_touch_state = LV_INDEV_STATE_REL;
-  static int32_t touch_time1 = 0;
-  uint32_t tmpTime, diffTime = 0;
-
-  tmpTime = millis();
-  diffTime = getTickDiff(tmpTime, touch_time1);
-  if (diffTime > 20) {
-    if (get_point(&last_x, &last_y)) {
-
-      if (last_touch_state == LV_INDEV_STATE_PR) return false;
-      data->state = LV_INDEV_STATE_PR;
-
-      // Set the coordinates (if released use the last-pressed coordinates)
-      data->point.x = last_x;
-      data->point.y = last_y;
-
-      last_x = last_y = 0;
-      last_touch_state = LV_INDEV_STATE_PR;
-    }
-    else {
-      if (last_touch_state == LV_INDEV_STATE_PR)
-        data->state = LV_INDEV_STATE_REL;
-      last_touch_state = LV_INDEV_STATE_REL;
-    }
-
-    touch_time1 = tmpTime;
-  }
-
-  return false; // Return `false` since no data is buffering or left to read
-}
-
-int16_t enc_diff = 0;
-lv_indev_state_t state = LV_INDEV_STATE_REL;
-
-bool my_mousewheel_read(lv_indev_drv_t * indev_drv, lv_indev_data_t * data) {
-  (void) indev_drv;   // Unused
-
-  data->state = state;
-  data->enc_diff = enc_diff;
-  enc_diff = 0;
-
-  return false;       // No more data to read so return false
-}
-
-extern uint8_t currentFlashPage;
-
-//spi_flash
-uint32_t pic_read_base_addr = 0, pic_read_addr_offset = 0;
-lv_fs_res_t spi_flash_open_cb (lv_fs_drv_t * drv, void * file_p, const char * path, lv_fs_mode_t mode) {
-  static char last_path_name[30];
-  if (strcasecmp(last_path_name, path) != 0) {
-    pic_read_base_addr = lv_get_pic_addr((uint8_t *)path);
-    strcpy(last_path_name, path);
-  }
-  else {
-    W25QXX.init(SPI_QUARTER_SPEED);
-    currentFlashPage = 0;
-  }
-  pic_read_addr_offset = pic_read_base_addr;
-  return LV_FS_RES_OK;
-}
-
-lv_fs_res_t spi_flash_close_cb (lv_fs_drv_t * drv, void * file_p) {
-  lv_fs_res_t res = LV_FS_RES_OK;
-  /* Add your code here */
-  pic_read_addr_offset = pic_read_base_addr;
-  return res;
-}
-
-lv_fs_res_t spi_flash_read_cb (lv_fs_drv_t * drv, void * file_p, void * buf, uint32_t btr, uint32_t * br) {
-  lv_pic_test((uint8_t *)buf, pic_read_addr_offset, btr);
-  *br = btr;
-  return LV_FS_RES_OK;
-}
-
-lv_fs_res_t spi_flash_seek_cb(lv_fs_drv_t * drv, void * file_p, uint32_t pos) {
-  #if HAS_SPI_FLASH_COMPRESSION
-    if (pos == 4) {
-      uint8_t bmp_header[4];
-      SPIFlash.beginRead(pic_read_base_addr);
-      SPIFlash.readData(bmp_header, 4);
-      currentFlashPage = 1;
-    }
-    pic_read_addr_offset = pic_read_base_addr;
-  #else
-    pic_read_addr_offset = pic_read_base_addr + pos;
-  #endif
-  return LV_FS_RES_OK;
-}
-
-lv_fs_res_t spi_flash_tell_cb(lv_fs_drv_t * drv, void * file_p, uint32_t * pos_p) {
-  *pos_p = pic_read_addr_offset - pic_read_base_addr;
-  return LV_FS_RES_OK;
-}
-
-//sd
-char *cur_namefff;
-uint32_t sd_read_base_addr = 0, sd_read_addr_offset = 0, small_image_size = 409;
-lv_fs_res_t sd_open_cb (lv_fs_drv_t * drv, void * file_p, const char * path, lv_fs_mode_t mode) {
-  char name_buf[100];
-  *name_buf = '/';
-  strcpy(name_buf + 1, path);
-  char *temp = strstr(name_buf, ".bin");
-  if (temp) strcpy(temp, ".GCO");
-  sd_read_base_addr = lv_open_gcode_file((char *)name_buf);
-  sd_read_addr_offset = sd_read_base_addr;
-  if (sd_read_addr_offset == UINT32_MAX) return LV_FS_RES_NOT_EX;
-  // find small image size
-  card.read(public_buf, 512);
-  public_buf[511] = '\0';
-  char* eol = strpbrk((const char*)public_buf, "\n\r");
-  small_image_size = (uintptr_t)eol - (uintptr_t)((uint32_t *)(&public_buf[0])) + 1;
-  return LV_FS_RES_OK;
-}
-
-lv_fs_res_t sd_close_cb (lv_fs_drv_t * drv, void * file_p) {
-  /* Add your code here */
-  lv_close_gcode_file();
-  return LV_FS_RES_OK;
-}
-
-lv_fs_res_t sd_read_cb (lv_fs_drv_t * drv, void * file_p, void * buf, uint32_t btr, uint32_t * br) {
-  if (btr == 200) {
-    lv_gcode_file_read((uint8_t *)buf);
-    //pic_read_addr_offset += 208;
-    *br = 200;
-  }
-  else if (btr == 4) {
-    uint8_t header_pic[4] = { 0x04, 0x90, 0x81, 0x0C };
-    memcpy(buf, header_pic, 4);
-    *br = 4;
-  }
-  return LV_FS_RES_OK;
-}
-
-lv_fs_res_t sd_seek_cb(lv_fs_drv_t * drv, void * file_p, uint32_t pos) {
-  sd_read_addr_offset = sd_read_base_addr + (pos - 4) / 200 * small_image_size;
-  lv_gcode_file_seek(sd_read_addr_offset);
-  return LV_FS_RES_OK;
-}
-
-lv_fs_res_t sd_tell_cb(lv_fs_drv_t * drv, void * file_p, uint32_t * pos_p) {
-  if (sd_read_addr_offset) *pos_p = 0;
-  else *pos_p = (sd_read_addr_offset - sd_read_base_addr) / small_image_size * 200 + 4;
-  return LV_FS_RES_OK;
-}
-
-void lv_encoder_pin_init() {
-  #if BUTTON_EXISTS(EN1)
-    SET_INPUT_PULLUP(BTN_EN1);
-  #endif
-  #if BUTTON_EXISTS(EN2)
-    SET_INPUT_PULLUP(BTN_EN2);
-  #endif
-  #if BUTTON_EXISTS(ENC)
-    SET_INPUT_PULLUP(BTN_ENC);
-  #endif
-
-  #if BUTTON_EXISTS(BACK)
-    SET_INPUT_PULLUP(BTN_BACK);
-  #endif
-
-  #if BUTTON_EXISTS(UP)
-    SET_INPUT(BTN_UP);
-  #endif
-  #if BUTTON_EXISTS(DWN)
-    SET_INPUT(BTN_DWN);
-  #endif
-  #if BUTTON_EXISTS(LFT)
-    SET_INPUT(BTN_LFT);
-  #endif
-  #if BUTTON_EXISTS(RT)
-    SET_INPUT(BTN_RT);
-  #endif
-}
-
-#if 1 // HAS_ENCODER_ACTION
-  void lv_update_encoder() {
-    static uint32_t encoder_time1;
-    uint32_t tmpTime, diffTime = 0;
-    tmpTime = millis();
-    diffTime = getTickDiff(tmpTime, encoder_time1);
-    if (diffTime > 50) {
-
-      #if HAS_ENCODER_WHEEL
-
-        #if ANY_BUTTON(EN1, EN2, ENC, BACK)
-
-          uint8_t newbutton = 0;
-          if (BUTTON_PRESSED(EN1)) newbutton |= EN_A;
-          if (BUTTON_PRESSED(EN2)) newbutton |= EN_B;
-          if (BUTTON_PRESSED(ENC)) newbutton |= EN_C;
-          if (BUTTON_PRESSED(BACK)) newbutton |= EN_D;
-
-        #else
-
-          constexpr uint8_t newbutton = 0;
-
-        #endif
-
-        static uint8_t buttons = 0;
-        buttons = newbutton;
-        static uint8_t lastEncoderBits;
-
-        #define encrot0 0
-        #define encrot1 1
-        #define encrot2 2
-
-        uint8_t enc = 0;
-        if (buttons & EN_A) enc |= B01;
-        if (buttons & EN_B) enc |= B10;
-        if (enc != lastEncoderBits) {
-          switch (enc) {
-            case encrot1:
-              if (lastEncoderBits == encrot0) {
-                enc_diff--;
-                encoder_time1 = tmpTime;
-              }
-              break;
-            case encrot2:
-              if (lastEncoderBits == encrot0) {
-                enc_diff++;
-                encoder_time1 = tmpTime;
-              }
-              break;
-          }
-          lastEncoderBits = enc;
-        }
-        static uint8_t last_button_state = LV_INDEV_STATE_REL;
-        const uint8_t enc_c = (buttons & EN_C) ? LV_INDEV_STATE_PR : LV_INDEV_STATE_REL;
-        if (enc_c != last_button_state) {
-          state = enc_c ? LV_INDEV_STATE_PR : LV_INDEV_STATE_REL;
-          last_button_state = enc_c;
-        }
-
-      #endif // HAS_ENCODER_WHEEL
-
-    } // next_button_update_ms
-  }
-
-#endif // HAS_ENCODER_ACTION
-
-#endif // HAS_TFT_LVGL_UI

commit c2b72c0e73a59c7b0915253c775eb6253032f0b0
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Apr 2 14:22:43 2021 -0500

    Remove extraneous 'extern' hints (#21516)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
index b7441f71f4..f54b290c13 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
@@ -57,27 +57,27 @@ XPT2046 touch;
 #include <SPI.h>
 
 #ifndef TFT_WIDTH
   #define TFT_WIDTH  480
 #endif
 #ifndef TFT_HEIGHT
   #define TFT_HEIGHT 320
 #endif
 
 #if HAS_SPI_FLASH_FONT
-  extern void init_gb2312_font();
+  void init_gb2312_font();
 #endif
 
 static lv_disp_buf_t disp_buf;
 lv_group_t*  g;
 #if ENABLED(SDSUPPORT)
-  extern void UpdateAssets();
+  void UpdateAssets();
 #endif
 uint16_t DeviceCode = 0x9488;
 extern uint8_t sel_id;
 
 uint8_t bmp_public_buf[14 * 1024];
 uint8_t public_buf[513];
 
 extern bool flash_preview_begin, default_preview_flg, gcode_preview_over;
 
 void SysTick_Callback() {
@@ -183,42 +183,40 @@ void tft_lvgl_init() {
   sd_drv.tell_cb = sd_tell_cb;
   lv_fs_drv_register(&sd_drv);
 
   systick_attach_callback(SysTick_Callback);
 
   #if HAS_SPI_FLASH_FONT
     init_gb2312_font();
   #endif
 
   tft_style_init();
-
   filament_pin_setup();
-
   lv_encoder_pin_init();
 
   TERN_(MKS_WIFI_MODULE, mks_wifi_firmware_update());
 
   bool ready = true;
   #if ENABLED(POWER_LOSS_RECOVERY)
     recovery.load();
     if (recovery.valid()) {
       ready = false;
       if (gCfgItems.from_flash_pic)
         flash_preview_begin = true;
       else
         default_preview_flg = true;
 
       uiCfg.print_state = REPRINTING;
 
       strncpy(public_buf_m, recovery.info.sd_filename, sizeof(public_buf_m));
       card.printLongPath(public_buf_m);
-      strncpy(list_file.long_name[sel_id], card.longFilename, sizeof(list_file.long_name[sel_id]));
+      strncpy(list_file.long_name[sel_id], card.longFilename, sizeof(list_file.long_name[0]));
       lv_draw_printing();
     }
   #endif
 
   if (ready) lv_draw_ready_print();
 
   if (mks_test_flag == 0x1E) mks_gpio_test();
 }
 
 void my_disp_flush(lv_disp_drv_t * disp, const lv_area_t * area, lv_color_t * color_p) {

commit 9d0e64a725290233d6002017147c578ffd32c504
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jan 28 20:40:20 2021 -0600

    AutoReport class (Temperature, Cardreader) (#20913)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
index 65b7538b71..b7441f71f4 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
@@ -82,31 +82,31 @@ extern bool flash_preview_begin, default_preview_flg, gcode_preview_over;
 
 void SysTick_Callback() {
   lv_tick_inc(1);
   print_time_count();
   #if ENABLED(MKS_WIFI_MODULE)
     if (tips_disp.timer == TIPS_TIMER_START)
       tips_disp.timer_count++;
   #endif
   if (uiCfg.filament_loading_time_flg) {
     uiCfg.filament_loading_time_cnt++;
-    uiCfg.filament_rate = (uint32_t)(((uiCfg.filament_loading_time_cnt / (uiCfg.filament_loading_time * 1000.0)) * 100.0) + 0.5);
-    if (uiCfg.filament_loading_time_cnt >= (uiCfg.filament_loading_time * 1000)) {
+    uiCfg.filament_rate = uint32_t(100.0f * uiCfg.filament_loading_time_cnt / SEC_TO_MS(uiCfg.filament_loading_time) + 0.5f);
+    if (uiCfg.filament_loading_time_cnt >= SEC_TO_MS(uiCfg.filament_loading_time)) {
       uiCfg.filament_loading_time_cnt  = 0;
       uiCfg.filament_loading_time_flg  = false;
       uiCfg.filament_loading_completed = true;
     }
   }
   if (uiCfg.filament_unloading_time_flg) {
     uiCfg.filament_unloading_time_cnt++;
-    uiCfg.filament_rate = (uint32_t)(((uiCfg.filament_unloading_time_cnt / (uiCfg.filament_unloading_time * 1000.0)) * 100.0) + 0.5);
-    if (uiCfg.filament_unloading_time_cnt >= (uiCfg.filament_unloading_time * 1000)) {
+    uiCfg.filament_rate = uint32_t(100.0f * uiCfg.filament_unloading_time_cnt / SEC_TO_MS(uiCfg.filament_unloading_time) + 0.5f);
+    if (uiCfg.filament_unloading_time_cnt >= SEC_TO_MS(uiCfg.filament_unloading_time)) {
       uiCfg.filament_unloading_time_cnt  = 0;
       uiCfg.filament_unloading_time_flg  = false;
       uiCfg.filament_unloading_completed = true;
       uiCfg.filament_rate = 100;
     }
   }
 }
 
 void tft_lvgl_init() {
 

commit 40c8f2001d2274dd34868d2e83ba65a09bcfba17
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jan 16 20:43:46 2021 -0600

    Apply bool to some MKS UI

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
index d005a9b103..65b7538b71 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
@@ -80,36 +80,36 @@ uint8_t public_buf[513];
 
 extern bool flash_preview_begin, default_preview_flg, gcode_preview_over;
 
 void SysTick_Callback() {
   lv_tick_inc(1);
   print_time_count();
   #if ENABLED(MKS_WIFI_MODULE)
     if (tips_disp.timer == TIPS_TIMER_START)
       tips_disp.timer_count++;
   #endif
-  if (uiCfg.filament_loading_time_flg == 1) {
+  if (uiCfg.filament_loading_time_flg) {
     uiCfg.filament_loading_time_cnt++;
     uiCfg.filament_rate = (uint32_t)(((uiCfg.filament_loading_time_cnt / (uiCfg.filament_loading_time * 1000.0)) * 100.0) + 0.5);
     if (uiCfg.filament_loading_time_cnt >= (uiCfg.filament_loading_time * 1000)) {
       uiCfg.filament_loading_time_cnt  = 0;
-      uiCfg.filament_loading_time_flg  = 0;
-      uiCfg.filament_loading_completed = 1;
+      uiCfg.filament_loading_time_flg  = false;
+      uiCfg.filament_loading_completed = true;
     }
   }
-  if (uiCfg.filament_unloading_time_flg == 1) {
+  if (uiCfg.filament_unloading_time_flg) {
     uiCfg.filament_unloading_time_cnt++;
     uiCfg.filament_rate = (uint32_t)(((uiCfg.filament_unloading_time_cnt / (uiCfg.filament_unloading_time * 1000.0)) * 100.0) + 0.5);
     if (uiCfg.filament_unloading_time_cnt >= (uiCfg.filament_unloading_time * 1000)) {
       uiCfg.filament_unloading_time_cnt  = 0;
-      uiCfg.filament_unloading_time_flg  = 0;
-      uiCfg.filament_unloading_completed = 1;
+      uiCfg.filament_unloading_time_flg  = false;
+      uiCfg.filament_unloading_completed = true;
       uiCfg.filament_rate = 100;
     }
   }
 }
 
 void tft_lvgl_init() {
 
   W25QXX.init(SPI_QUARTER_SPEED);
 
   gCfgItems_init();

commit 35c1b330ec62e698a455176330e7d75600af461d
Author: MKS-Sean <56996910+MKS-Sean@users.noreply.github.com>
Date:   Thu Jan 14 12:41:09 2021 +0800

    MKS WiFi for TFT_LVGL_UI (#20191)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
index 5350ddb377..d005a9b103 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
@@ -12,26 +12,20 @@
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
-
-/**
- * @file tft_lvgl_configuration.cpp
- * @date    2020-02-21
- */
-
 #include "../../../../inc/MarlinConfigPre.h"
 
 #if HAS_TFT_LVGL_UI
 
 #include "SPI_TFT.h"
 
 #include "tft_lvgl_configuration.h"
 #include "draw_ready_print.h"
 
 #include "pic_manager.h"
@@ -49,20 +43,24 @@ XPT2046 touch;
 
 #if ENABLED(POWER_LOSS_RECOVERY)
   #include "../../../../feature/powerloss.h"
 #endif
 
 #if ENABLED(TOUCH_SCREEN_CALIBRATION)
   #include "../../../tft_io/touch_calibration.h"
   #include "draw_touch_calibration.h"
 #endif
 
+#if ENABLED(MKS_WIFI_MODULE)
+  #include "wifi_module.h"
+#endif
+
 #include <SPI.h>
 
 #ifndef TFT_WIDTH
   #define TFT_WIDTH  480
 #endif
 #ifndef TFT_HEIGHT
   #define TFT_HEIGHT 320
 #endif
 
 #if HAS_SPI_FLASH_FONT
@@ -113,50 +111,54 @@ void SysTick_Callback() {
 void tft_lvgl_init() {
 
   W25QXX.init(SPI_QUARTER_SPEED);
 
   gCfgItems_init();
   ui_cfg_init();
   disp_language_init();
 
   watchdog_refresh();     // LVGL init takes time
 
+  #if MB(MKS_ROBIN_NANO)
+    OUT_WRITE(PB0, LOW);  // HE1
+  #endif
+
   // Init TFT first!
   SPI_TFT.spi_init(SPI_FULL_SPEED);
   SPI_TFT.LCD_init();
 
   watchdog_refresh();     // LVGL init takes time
 
   #if ENABLED(SDSUPPORT)
     UpdateAssets();
     watchdog_refresh();   // LVGL init takes time
   #endif
 
   mks_test_get();
 
   touch.Init();
 
   lv_init();
 
-  lv_disp_buf_init(&disp_buf, bmp_public_buf, nullptr, LV_HOR_RES_MAX * 14); /*Initialize the display buffer*/
+  lv_disp_buf_init(&disp_buf, bmp_public_buf, nullptr, LV_HOR_RES_MAX * 14); // Initialize the display buffer
 
-  lv_disp_drv_t disp_drv;     /*Descriptor of a display driver*/
-  lv_disp_drv_init(&disp_drv);    /*Basic initialization*/
-  disp_drv.flush_cb = my_disp_flush; /*Set your driver function*/
-  disp_drv.buffer = &disp_buf;    /*Assign the buffer to the display*/
-  lv_disp_drv_register(&disp_drv);  /*Finally register the driver*/
+  lv_disp_drv_t disp_drv;     // Descriptor of a display driver
+  lv_disp_drv_init(&disp_drv);    // Basic initialization
+  disp_drv.flush_cb = my_disp_flush; // Set your driver function
+  disp_drv.buffer = &disp_buf;    // Assign the buffer to the display
+  lv_disp_drv_register(&disp_drv);  // Finally register the driver
 
   lv_indev_drv_t indev_drv;
-  lv_indev_drv_init(&indev_drv);     /*Descriptor of a input device driver*/
-  indev_drv.type = LV_INDEV_TYPE_POINTER; /*Touch pad is a pointer-like device*/
-  indev_drv.read_cb = my_touchpad_read;  /*Set your driver function*/
-  lv_indev_drv_register(&indev_drv);   /*Finally register the driver*/
+  lv_indev_drv_init(&indev_drv);     // Descriptor of a input device driver
+  indev_drv.type = LV_INDEV_TYPE_POINTER; // Touch pad is a pointer-like device
+  indev_drv.read_cb = my_touchpad_read;  // Set your driver function
+  lv_indev_drv_register(&indev_drv);   // Finally register the driver
 
   #if HAS_ROTARY_ENCODER
     g = lv_group_create();
     lv_indev_drv_t enc_drv;
     lv_indev_drv_init(&enc_drv);
     enc_drv.type = LV_INDEV_TYPE_ENCODER;
     enc_drv.read_cb = my_mousewheel_read;
     lv_indev_t * enc_indev = lv_indev_drv_register(&enc_drv);
     lv_indev_set_group(enc_indev, g);
   #endif
@@ -186,58 +188,66 @@ void tft_lvgl_init() {
   #if HAS_SPI_FLASH_FONT
     init_gb2312_font();
   #endif
 
   tft_style_init();
 
   filament_pin_setup();
 
   lv_encoder_pin_init();
 
+  TERN_(MKS_WIFI_MODULE, mks_wifi_firmware_update());
+
   bool ready = true;
   #if ENABLED(POWER_LOSS_RECOVERY)
     recovery.load();
     if (recovery.valid()) {
       ready = false;
       if (gCfgItems.from_flash_pic)
         flash_preview_begin = true;
       else
         default_preview_flg = true;
 
       uiCfg.print_state = REPRINTING;
 
       strncpy(public_buf_m, recovery.info.sd_filename, sizeof(public_buf_m));
       card.printLongPath(public_buf_m);
       strncpy(list_file.long_name[sel_id], card.longFilename, sizeof(list_file.long_name[sel_id]));
       lv_draw_printing();
     }
   #endif
 
-  if (ready) {
-    lv_draw_ready_print();
-  }
+  if (ready) lv_draw_ready_print();
 
-  if (mks_test_flag == 0x1E)
-    mks_gpio_test();
+  if (mks_test_flag == 0x1E) mks_gpio_test();
 }
 
 void my_disp_flush(lv_disp_drv_t * disp, const lv_area_t * area, lv_color_t * color_p) {
   uint16_t width = area->x2 - area->x1 + 1,
           height = area->y2 - area->y1 + 1;
 
   SPI_TFT.setWindow((uint16_t)area->x1, (uint16_t)area->y1, width, height);
 
   for (uint16_t i = 0; i < height; i++)
     SPI_TFT.tftio.WriteSequence((uint16_t*)(color_p + width * i), width);
 
-  lv_disp_flush_ready(disp);       /* Indicate you are ready with the flushing*/
+  lv_disp_flush_ready(disp); // Indicate you are ready with the flushing
+
+  W25QXX.init(SPI_QUARTER_SPEED);
+}
 
+void lv_fill_rect(lv_coord_t x1, lv_coord_t y1, lv_coord_t x2, lv_coord_t y2, lv_color_t bk_color) {
+  uint16_t width, height;
+  width = x2 - x1 + 1;
+  height = y2 - y1 + 1;
+  SPI_TFT.setWindow((uint16_t)x1, (uint16_t)y1, width, height);
+  SPI_TFT.tftio.WriteMultiple(bk_color.full, width * height);
   W25QXX.init(SPI_QUARTER_SPEED);
 }
 
 #define TICK_CYCLE 1
 
 unsigned int getTickDiff(unsigned int curTick, unsigned int lastTick) {
   return TICK_CYCLE * (lastTick <= curTick ? (curTick - lastTick) : (0xFFFFFFFF - lastTick + curTick));
 }
 
 static bool get_point(int16_t *x, int16_t *y) {
@@ -291,27 +301,27 @@ bool my_touchpad_read(lv_indev_drv_t * indev_driver, lv_indev_data_t * data) {
     touch_time1 = tmpTime;
   }
 
   return false; // Return `false` since no data is buffering or left to read
 }
 
 int16_t enc_diff = 0;
 lv_indev_state_t state = LV_INDEV_STATE_REL;
 
 bool my_mousewheel_read(lv_indev_drv_t * indev_drv, lv_indev_data_t * data) {
-  (void) indev_drv;   /*Unused*/
+  (void) indev_drv;   // Unused
 
   data->state = state;
   data->enc_diff = enc_diff;
   enc_diff = 0;
 
-  return false;       /*No more data to read so return false*/
+  return false;       // No more data to read so return false
 }
 
 extern uint8_t currentFlashPage;
 
 //spi_flash
 uint32_t pic_read_base_addr = 0, pic_read_addr_offset = 0;
 lv_fs_res_t spi_flash_open_cb (lv_fs_drv_t * drv, void * file_p, const char * path, lv_fs_mode_t mode) {
   static char last_path_name[30];
   if (strcasecmp(last_path_name, path) != 0) {
     pic_read_base_addr = lv_get_pic_addr((uint8_t *)path);
@@ -320,21 +330,21 @@ lv_fs_res_t spi_flash_open_cb (lv_fs_drv_t * drv, void * file_p, const char * pa
   else {
     W25QXX.init(SPI_QUARTER_SPEED);
     currentFlashPage = 0;
   }
   pic_read_addr_offset = pic_read_base_addr;
   return LV_FS_RES_OK;
 }
 
 lv_fs_res_t spi_flash_close_cb (lv_fs_drv_t * drv, void * file_p) {
   lv_fs_res_t res = LV_FS_RES_OK;
-  /* Add your code here*/
+  /* Add your code here */
   pic_read_addr_offset = pic_read_base_addr;
   return res;
 }
 
 lv_fs_res_t spi_flash_read_cb (lv_fs_drv_t * drv, void * file_p, void * buf, uint32_t btr, uint32_t * br) {
   lv_pic_test((uint8_t *)buf, pic_read_addr_offset, btr);
   *br = btr;
   return LV_FS_RES_OK;
 }
 
@@ -372,21 +382,21 @@ lv_fs_res_t sd_open_cb (lv_fs_drv_t * drv, void * file_p, const char * path, lv_
   if (sd_read_addr_offset == UINT32_MAX) return LV_FS_RES_NOT_EX;
   // find small image size
   card.read(public_buf, 512);
   public_buf[511] = '\0';
   char* eol = strpbrk((const char*)public_buf, "\n\r");
   small_image_size = (uintptr_t)eol - (uintptr_t)((uint32_t *)(&public_buf[0])) + 1;
   return LV_FS_RES_OK;
 }
 
 lv_fs_res_t sd_close_cb (lv_fs_drv_t * drv, void * file_p) {
-  /* Add your code here*/
+  /* Add your code here */
   lv_close_gcode_file();
   return LV_FS_RES_OK;
 }
 
 lv_fs_res_t sd_read_cb (lv_fs_drv_t * drv, void * file_p, void * buf, uint32_t btr, uint32_t * br) {
   if (btr == 200) {
     lv_gcode_file_read((uint8_t *)buf);
     //pic_read_addr_offset += 208;
     *br = 200;
   }

commit 44c57ab05a8f909b85f51e08c90316b41e50c455
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jan 12 21:02:35 2021 -0600

    MKS UI prelim. cleanup (#20763)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
index 097c1aeadc..5350ddb377 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
@@ -70,23 +70,24 @@ XPT2046 touch;
 #endif
 
 static lv_disp_buf_t disp_buf;
 lv_group_t*  g;
 #if ENABLED(SDSUPPORT)
   extern void UpdateAssets();
 #endif
 uint16_t DeviceCode = 0x9488;
 extern uint8_t sel_id;
 
-extern bool flash_preview_begin, default_preview_flg, gcode_preview_over;
+uint8_t bmp_public_buf[14 * 1024];
+uint8_t public_buf[513];
 
-uint8_t bmp_public_buf[17 * 1024];
+extern bool flash_preview_begin, default_preview_flg, gcode_preview_over;
 
 void SysTick_Callback() {
   lv_tick_inc(1);
   print_time_count();
   #if ENABLED(MKS_WIFI_MODULE)
     if (tips_disp.timer == TIPS_TIMER_START)
       tips_disp.timer_count++;
   #endif
   if (uiCfg.filament_loading_time_flg == 1) {
     uiCfg.filament_loading_time_cnt++;
@@ -102,53 +103,48 @@ void SysTick_Callback() {
     uiCfg.filament_rate = (uint32_t)(((uiCfg.filament_unloading_time_cnt / (uiCfg.filament_unloading_time * 1000.0)) * 100.0) + 0.5);
     if (uiCfg.filament_unloading_time_cnt >= (uiCfg.filament_unloading_time * 1000)) {
       uiCfg.filament_unloading_time_cnt  = 0;
       uiCfg.filament_unloading_time_flg  = 0;
       uiCfg.filament_unloading_completed = 1;
       uiCfg.filament_rate = 100;
     }
   }
 }
 
-extern uint8_t bmp_public_buf[17 * 1024];
-
 void tft_lvgl_init() {
 
-  //uint16_t test_id=0;
   W25QXX.init(SPI_QUARTER_SPEED);
-  //test_id=W25QXX.W25QXX_ReadID();
 
   gCfgItems_init();
   ui_cfg_init();
   disp_language_init();
 
   watchdog_refresh();     // LVGL init takes time
 
   // Init TFT first!
   SPI_TFT.spi_init(SPI_FULL_SPEED);
   SPI_TFT.LCD_init();
 
   watchdog_refresh();     // LVGL init takes time
 
-  //spi_flash_read_test();
   #if ENABLED(SDSUPPORT)
     UpdateAssets();
     watchdog_refresh();   // LVGL init takes time
   #endif
 
   mks_test_get();
 
   touch.Init();
 
   lv_init();
 
-  lv_disp_buf_init(&disp_buf, bmp_public_buf, nullptr, LV_HOR_RES_MAX * 18); /*Initialize the display buffer*/
+  lv_disp_buf_init(&disp_buf, bmp_public_buf, nullptr, LV_HOR_RES_MAX * 14); /*Initialize the display buffer*/
 
   lv_disp_drv_t disp_drv;     /*Descriptor of a display driver*/
   lv_disp_drv_init(&disp_drv);    /*Basic initialization*/
   disp_drv.flush_cb = my_disp_flush; /*Set your driver function*/
   disp_drv.buffer = &disp_buf;    /*Assign the buffer to the display*/
   lv_disp_drv_register(&disp_drv);  /*Finally register the driver*/
 
   lv_indev_drv_t indev_drv;
   lv_indev_drv_init(&indev_drv);     /*Descriptor of a input device driver*/
   indev_drv.type = LV_INDEV_TYPE_POINTER; /*Touch pad is a pointer-like device*/
@@ -266,33 +262,27 @@ static bool get_point(int16_t *x, int16_t *y) {
 }
 
 bool my_touchpad_read(lv_indev_drv_t * indev_driver, lv_indev_data_t * data) {
   static int16_t last_x = 0, last_y = 0;
   static uint8_t last_touch_state = LV_INDEV_STATE_REL;
   static int32_t touch_time1 = 0;
   uint32_t tmpTime, diffTime = 0;
 
   tmpTime = millis();
   diffTime = getTickDiff(tmpTime, touch_time1);
-  /*Save the state and save the pressed coordinate*/
-  //data->state = TOUCH_PressValid(last_x, last_y) ? LV_INDEV_STATE_PR : LV_INDEV_STATE_REL;
-  //if (data->state == LV_INDEV_STATE_PR)  ADS7843_Rd_Addata((u16 *)&last_x, (u16 *)&last_y);
-  //touchpad_get_xy(&last_x, &last_y);
-  /*Save the pressed coordinates and the state*/
   if (diffTime > 20) {
     if (get_point(&last_x, &last_y)) {
 
       if (last_touch_state == LV_INDEV_STATE_PR) return false;
       data->state = LV_INDEV_STATE_PR;
 
       // Set the coordinates (if released use the last-pressed coordinates)
-
       data->point.x = last_x;
       data->point.y = last_y;
 
       last_x = last_y = 0;
       last_touch_state = LV_INDEV_STATE_PR;
     }
     else {
       if (last_touch_state == LV_INDEV_STATE_PR)
         data->state = LV_INDEV_STATE_REL;
       last_touch_state = LV_INDEV_STATE_REL;
@@ -362,25 +352,23 @@ lv_fs_res_t spi_flash_seek_cb(lv_fs_drv_t * drv, void * file_p, uint32_t pos) {
   #endif
   return LV_FS_RES_OK;
 }
 
 lv_fs_res_t spi_flash_tell_cb(lv_fs_drv_t * drv, void * file_p, uint32_t * pos_p) {
   *pos_p = pic_read_addr_offset - pic_read_base_addr;
   return LV_FS_RES_OK;
 }
 
 //sd
-extern uint8_t public_buf[512];
 char *cur_namefff;
 uint32_t sd_read_base_addr = 0, sd_read_addr_offset = 0, small_image_size = 409;
 lv_fs_res_t sd_open_cb (lv_fs_drv_t * drv, void * file_p, const char * path, lv_fs_mode_t mode) {
-  //cur_namefff = strrchr(path, '/');
   char name_buf[100];
   *name_buf = '/';
   strcpy(name_buf + 1, path);
   char *temp = strstr(name_buf, ".bin");
   if (temp) strcpy(temp, ".GCO");
   sd_read_base_addr = lv_open_gcode_file((char *)name_buf);
   sd_read_addr_offset = sd_read_base_addr;
   if (sd_read_addr_offset == UINT32_MAX) return LV_FS_RES_NOT_EX;
   // find small image size
   card.read(public_buf, 512);
@@ -398,21 +386,20 @@ lv_fs_res_t sd_close_cb (lv_fs_drv_t * drv, void * file_p) {
 
 lv_fs_res_t sd_read_cb (lv_fs_drv_t * drv, void * file_p, void * buf, uint32_t btr, uint32_t * br) {
   if (btr == 200) {
     lv_gcode_file_read((uint8_t *)buf);
     //pic_read_addr_offset += 208;
     *br = 200;
   }
   else if (btr == 4) {
     uint8_t header_pic[4] = { 0x04, 0x90, 0x81, 0x0C };
     memcpy(buf, header_pic, 4);
-    //pic_read_addr_offset += 4;
     *br = 4;
   }
   return LV_FS_RES_OK;
 }
 
 lv_fs_res_t sd_seek_cb(lv_fs_drv_t * drv, void * file_p, uint32_t pos) {
   sd_read_addr_offset = sd_read_base_addr + (pos - 4) / 200 * small_image_size;
   lv_gcode_file_seek(sd_read_addr_offset);
   return LV_FS_RES_OK;
 }
@@ -446,23 +433,20 @@ void lv_encoder_pin_init() {
   #endif
   #if BUTTON_EXISTS(LFT)
     SET_INPUT(BTN_LFT);
   #endif
   #if BUTTON_EXISTS(RT)
     SET_INPUT(BTN_RT);
   #endif
 }
 
 #if 1 // HAS_ENCODER_ACTION
-
-  //static const int8_t encoderDirection = 1;
-  //static int16_t enc_Direction;
   void lv_update_encoder() {
     static uint32_t encoder_time1;
     uint32_t tmpTime, diffTime = 0;
     tmpTime = millis();
     diffTime = getTickDiff(tmpTime, encoder_time1);
     if (diffTime > 50) {
 
       #if HAS_ENCODER_WHEEL
 
         #if ANY_BUTTON(EN1, EN2, ENC, BACK)
@@ -480,23 +464,20 @@ void lv_encoder_pin_init() {
         #endif
 
         static uint8_t buttons = 0;
         buttons = newbutton;
         static uint8_t lastEncoderBits;
 
         #define encrot0 0
         #define encrot1 1
         #define encrot2 2
 
-        // Manage encoder rotation
-        //#define ENCODER_SPIN(_E1, _E2) switch (lastEncoderBits) { case _E1: enc_Direction += encoderDirection; break; case _E2: enc_Direction -= encoderDirection; }
-
         uint8_t enc = 0;
         if (buttons & EN_A) enc |= B01;
         if (buttons & EN_B) enc |= B10;
         if (enc != lastEncoderBits) {
           switch (enc) {
             case encrot1:
               if (lastEncoderBits == encrot0) {
                 enc_diff--;
                 encoder_time1 = tmpTime;
               }

commit 4a897310252341f203371cb2e99f93bf9c035143
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Jan 12 20:43:52 2021 -0600

    Rotary encoder cleanup (#20753)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
index f13a4b36cf..097c1aeadc 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
@@ -461,41 +461,31 @@ void lv_encoder_pin_init() {
     uint32_t tmpTime, diffTime = 0;
     tmpTime = millis();
     diffTime = getTickDiff(tmpTime, encoder_time1);
     if (diffTime > 50) {
 
       #if HAS_ENCODER_WHEEL
 
         #if ANY_BUTTON(EN1, EN2, ENC, BACK)
 
           uint8_t newbutton = 0;
-
-          #if BUTTON_EXISTS(EN1)
-            if (BUTTON_PRESSED(EN1)) newbutton |= EN_A;
-          #endif
-          #if BUTTON_EXISTS(EN2)
-            if (BUTTON_PRESSED(EN2)) newbutton |= EN_B;
-          #endif
-          #if BUTTON_EXISTS(ENC)
-            if (BUTTON_PRESSED(ENC)) newbutton |= EN_C;
-          #endif
-          #if BUTTON_EXISTS(BACK)
-            if (BUTTON_PRESSED(BACK)) newbutton |= EN_D;
-          #endif
+          if (BUTTON_PRESSED(EN1)) newbutton |= EN_A;
+          if (BUTTON_PRESSED(EN2)) newbutton |= EN_B;
+          if (BUTTON_PRESSED(ENC)) newbutton |= EN_C;
+          if (BUTTON_PRESSED(BACK)) newbutton |= EN_D;
 
         #else
 
           constexpr uint8_t newbutton = 0;
 
         #endif
 
-
         static uint8_t buttons = 0;
         buttons = newbutton;
         static uint8_t lastEncoderBits;
 
         #define encrot0 0
         #define encrot1 1
         #define encrot2 2
 
         // Manage encoder rotation
         //#define ENCODER_SPIN(_E1, _E2) switch (lastEncoderBits) { case _E1: enc_Direction += encoderDirection; break; case _E2: enc_Direction -= encoderDirection; }

commit 90a2b482e6e59079d7cad1bc04b87a82fe99816c
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Tue Dec 29 01:07:11 2020 -0300

    LVGL G-code preview. Legacy MKS WiFi Cura plugin compatibility (#20589)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
index 8ce317c571..f13a4b36cf 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
@@ -362,32 +362,38 @@ lv_fs_res_t spi_flash_seek_cb(lv_fs_drv_t * drv, void * file_p, uint32_t pos) {
   #endif
   return LV_FS_RES_OK;
 }
 
 lv_fs_res_t spi_flash_tell_cb(lv_fs_drv_t * drv, void * file_p, uint32_t * pos_p) {
   *pos_p = pic_read_addr_offset - pic_read_base_addr;
   return LV_FS_RES_OK;
 }
 
 //sd
+extern uint8_t public_buf[512];
 char *cur_namefff;
-uint32_t sd_read_base_addr = 0,sd_read_addr_offset = 0;
+uint32_t sd_read_base_addr = 0, sd_read_addr_offset = 0, small_image_size = 409;
 lv_fs_res_t sd_open_cb (lv_fs_drv_t * drv, void * file_p, const char * path, lv_fs_mode_t mode) {
   //cur_namefff = strrchr(path, '/');
   char name_buf[100];
   *name_buf = '/';
   strcpy(name_buf + 1, path);
   char *temp = strstr(name_buf, ".bin");
   if (temp) strcpy(temp, ".GCO");
   sd_read_base_addr = lv_open_gcode_file((char *)name_buf);
   sd_read_addr_offset = sd_read_base_addr;
   if (sd_read_addr_offset == UINT32_MAX) return LV_FS_RES_NOT_EX;
+  // find small image size
+  card.read(public_buf, 512);
+  public_buf[511] = '\0';
+  char* eol = strpbrk((const char*)public_buf, "\n\r");
+  small_image_size = (uintptr_t)eol - (uintptr_t)((uint32_t *)(&public_buf[0])) + 1;
   return LV_FS_RES_OK;
 }
 
 lv_fs_res_t sd_close_cb (lv_fs_drv_t * drv, void * file_p) {
   /* Add your code here*/
   lv_close_gcode_file();
   return LV_FS_RES_OK;
 }
 
 lv_fs_res_t sd_read_cb (lv_fs_drv_t * drv, void * file_p, void * buf, uint32_t btr, uint32_t * br) {
@@ -399,28 +405,28 @@ lv_fs_res_t sd_read_cb (lv_fs_drv_t * drv, void * file_p, void * buf, uint32_t b
   else if (btr == 4) {
     uint8_t header_pic[4] = { 0x04, 0x90, 0x81, 0x0C };
     memcpy(buf, header_pic, 4);
     //pic_read_addr_offset += 4;
     *br = 4;
   }
   return LV_FS_RES_OK;
 }
 
 lv_fs_res_t sd_seek_cb(lv_fs_drv_t * drv, void * file_p, uint32_t pos) {
-  sd_read_addr_offset = sd_read_base_addr + (pos - 4) / 200 * 409;
+  sd_read_addr_offset = sd_read_base_addr + (pos - 4) / 200 * small_image_size;
   lv_gcode_file_seek(sd_read_addr_offset);
   return LV_FS_RES_OK;
 }
 
 lv_fs_res_t sd_tell_cb(lv_fs_drv_t * drv, void * file_p, uint32_t * pos_p) {
   if (sd_read_addr_offset) *pos_p = 0;
-  else *pos_p = (sd_read_addr_offset - sd_read_base_addr) / 409 * 200 + 4;
+  else *pos_p = (sd_read_addr_offset - sd_read_base_addr) / small_image_size * 200 + 4;
   return LV_FS_RES_OK;
 }
 
 void lv_encoder_pin_init() {
   #if BUTTON_EXISTS(EN1)
     SET_INPUT_PULLUP(BTN_EN1);
   #endif
   #if BUTTON_EXISTS(EN2)
     SET_INPUT_PULLUP(BTN_EN2);
   #endif

commit 9eaa69874a6dedb2a2becd90bf0b3a34734dc72b
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Mon Dec 28 02:15:01 2020 -0300

    Fix LVGL_UI G-code preview (#20564)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
index f943c1d6f9..8ce317c571 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
@@ -373,21 +373,21 @@ char *cur_namefff;
 uint32_t sd_read_base_addr = 0,sd_read_addr_offset = 0;
 lv_fs_res_t sd_open_cb (lv_fs_drv_t * drv, void * file_p, const char * path, lv_fs_mode_t mode) {
   //cur_namefff = strrchr(path, '/');
   char name_buf[100];
   *name_buf = '/';
   strcpy(name_buf + 1, path);
   char *temp = strstr(name_buf, ".bin");
   if (temp) strcpy(temp, ".GCO");
   sd_read_base_addr = lv_open_gcode_file((char *)name_buf);
   sd_read_addr_offset = sd_read_base_addr;
-  if (sd_read_addr_offset == 0) return LV_FS_RES_NOT_EX;
+  if (sd_read_addr_offset == UINT32_MAX) return LV_FS_RES_NOT_EX;
   return LV_FS_RES_OK;
 }
 
 lv_fs_res_t sd_close_cb (lv_fs_drv_t * drv, void * file_p) {
   /* Add your code here*/
   lv_close_gcode_file();
   return LV_FS_RES_OK;
 }
 
 lv_fs_res_t sd_read_cb (lv_fs_drv_t * drv, void * file_p, void * buf, uint32_t btr, uint32_t * br) {

commit 91730d71ffb448728a8187eeebf205138e846b69
Author: X-Ryl669 <boite.pour.spam@gmail.com>
Date:   Tue Dec 22 13:17:06 2020 +0100

    Improve Touch Calibration screen (#20524)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
index 9e383a6abd..f943c1d6f9 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
@@ -210,26 +210,21 @@ void tft_lvgl_init() {
       uiCfg.print_state = REPRINTING;
 
       strncpy(public_buf_m, recovery.info.sd_filename, sizeof(public_buf_m));
       card.printLongPath(public_buf_m);
       strncpy(list_file.long_name[sel_id], card.longFilename, sizeof(list_file.long_name[sel_id]));
       lv_draw_printing();
     }
   #endif
 
   if (ready) {
-    #if ENABLED(TOUCH_SCREEN_CALIBRATION)
-      if (touch_calibration.need_calibration()) lv_draw_touch_calibration_screen();
-      else lv_draw_ready_print();
-    #else
-      lv_draw_ready_print();
-    #endif
+    lv_draw_ready_print();
   }
 
   if (mks_test_flag == 0x1E)
     mks_gpio_test();
 }
 
 void my_disp_flush(lv_disp_drv_t * disp, const lv_area_t * area, lv_color_t * color_p) {
   uint16_t width = area->x2 - area->x1 + 1,
           height = area->y2 - area->y1 + 1;
 

commit 3893114c86c195d227e023c9e702197b54b2636f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Nov 19 15:51:53 2020 -0600

    MKS WiFi preliminary changes

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
index 9b8e3e1589..9e383a6abd 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
@@ -77,21 +77,21 @@ lv_group_t*  g;
 uint16_t DeviceCode = 0x9488;
 extern uint8_t sel_id;
 
 extern bool flash_preview_begin, default_preview_flg, gcode_preview_over;
 
 uint8_t bmp_public_buf[17 * 1024];
 
 void SysTick_Callback() {
   lv_tick_inc(1);
   print_time_count();
-  #if ENABLED(USE_WIFI_FUNCTION)
+  #if ENABLED(MKS_WIFI_MODULE)
     if (tips_disp.timer == TIPS_TIMER_START)
       tips_disp.timer_count++;
   #endif
   if (uiCfg.filament_loading_time_flg == 1) {
     uiCfg.filament_loading_time_cnt++;
     uiCfg.filament_rate = (uint32_t)(((uiCfg.filament_loading_time_cnt / (uiCfg.filament_loading_time * 1000.0)) * 100.0) + 0.5);
     if (uiCfg.filament_loading_time_cnt >= (uiCfg.filament_loading_time * 1000)) {
       uiCfg.filament_loading_time_cnt  = 0;
       uiCfg.filament_loading_time_flg  = 0;
       uiCfg.filament_loading_completed = 1;
@@ -516,21 +516,20 @@ void lv_encoder_pin_init() {
                 encoder_time1 = tmpTime;
               }
               break;
           }
           lastEncoderBits = enc;
         }
         static uint8_t last_button_state = LV_INDEV_STATE_REL;
         const uint8_t enc_c = (buttons & EN_C) ? LV_INDEV_STATE_PR : LV_INDEV_STATE_REL;
         if (enc_c != last_button_state) {
           state = enc_c ? LV_INDEV_STATE_PR : LV_INDEV_STATE_REL;
-
           last_button_state = enc_c;
         }
 
       #endif // HAS_ENCODER_WHEEL
 
     } // next_button_update_ms
   }
 
 #endif // HAS_ENCODER_ACTION
 

commit ea371618da71dc43e6aee95a8e479c8797867e04
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Sun Nov 15 19:39:58 2020 -0300

    Add Touch Calibration screen (#20049)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
index 21e3040c2e..9b8e3e1589 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
@@ -44,20 +44,25 @@
 #include "../../../../inc/MarlinConfig.h"
 
 #include HAL_PATH(../../../../HAL, tft/xpt2046.h)
 #include "../../../marlinui.h"
 XPT2046 touch;
 
 #if ENABLED(POWER_LOSS_RECOVERY)
   #include "../../../../feature/powerloss.h"
 #endif
 
+#if ENABLED(TOUCH_SCREEN_CALIBRATION)
+  #include "../../../tft_io/touch_calibration.h"
+  #include "draw_touch_calibration.h"
+#endif
+
 #include <SPI.h>
 
 #ifndef TFT_WIDTH
   #define TFT_WIDTH  480
 #endif
 #ifndef TFT_HEIGHT
   #define TFT_HEIGHT 320
 #endif
 
 #if HAS_SPI_FLASH_FONT
@@ -204,21 +209,28 @@ void tft_lvgl_init() {
 
       uiCfg.print_state = REPRINTING;
 
       strncpy(public_buf_m, recovery.info.sd_filename, sizeof(public_buf_m));
       card.printLongPath(public_buf_m);
       strncpy(list_file.long_name[sel_id], card.longFilename, sizeof(list_file.long_name[sel_id]));
       lv_draw_printing();
     }
   #endif
 
-  if (ready) lv_draw_ready_print();
+  if (ready) {
+    #if ENABLED(TOUCH_SCREEN_CALIBRATION)
+      if (touch_calibration.need_calibration()) lv_draw_touch_calibration_screen();
+      else lv_draw_ready_print();
+    #else
+      lv_draw_ready_print();
+    #endif
+  }
 
   if (mks_test_flag == 0x1E)
     mks_gpio_test();
 }
 
 void my_disp_flush(lv_disp_drv_t * disp, const lv_area_t * area, lv_color_t * color_p) {
   uint16_t width = area->x2 - area->x1 + 1,
           height = area->y2 - area->y1 + 1;
 
   SPI_TFT.setWindow((uint16_t)area->x1, (uint16_t)area->y1, width, height);
@@ -233,31 +245,36 @@ void my_disp_flush(lv_disp_drv_t * disp, const lv_area_t * area, lv_color_t * co
 
 #define TICK_CYCLE 1
 
 unsigned int getTickDiff(unsigned int curTick, unsigned int lastTick) {
   return TICK_CYCLE * (lastTick <= curTick ? (curTick - lastTick) : (0xFFFFFFFF - lastTick + curTick));
 }
 
 static bool get_point(int16_t *x, int16_t *y) {
   bool is_touched = touch.getRawPoint(x, y);
 
-  if (is_touched) {
-    *x = int16_t((int32_t(*x) * XPT2046_X_CALIBRATION) >> 16) + XPT2046_X_OFFSET;
-    *y = int16_t((int32_t(*y) * XPT2046_Y_CALIBRATION) >> 16) + XPT2046_Y_OFFSET;
-  }
+  if (!is_touched) return false;
 
-  #if (TFT_ROTATION & TFT_ROTATE_180)
-    *x = int16_t((TFT_WIDTH) - (int)(*x));
-    *y = int16_t((TFT_HEIGHT) - (int)(*y));
+  #if ENABLED(TOUCH_SCREEN_CALIBRATION)
+    const calibrationState state = touch_calibration.get_calibration_state();
+    if (state >= CALIBRATION_TOP_LEFT && state <= CALIBRATION_BOTTOM_RIGHT) {
+      if (touch_calibration.handleTouch(*x, *y)) lv_update_touch_calibration_screen();
+      return false;
+    }
+    *x = int16_t((int32_t(*x) * touch_calibration.calibration.x) >> 16) + touch_calibration.calibration.offset_x;
+    *y = int16_t((int32_t(*y) * touch_calibration.calibration.y) >> 16) + touch_calibration.calibration.offset_y;
+  #else
+    *x = int16_t((int32_t(*x) * TOUCH_CALIBRATION_X) >> 16) + TOUCH_OFFSET_X;
+    *y = int16_t((int32_t(*y) * TOUCH_CALIBRATION_Y) >> 16) + TOUCH_OFFSET_Y;
   #endif
 
-  return is_touched;
+  return true;
 }
 
 bool my_touchpad_read(lv_indev_drv_t * indev_driver, lv_indev_data_t * data) {
   static int16_t last_x = 0, last_y = 0;
   static uint8_t last_touch_state = LV_INDEV_STATE_REL;
   static int32_t touch_time1 = 0;
   uint32_t tmpTime, diffTime = 0;
 
   tmpTime = millis();
   diffTime = getTickDiff(tmpTime, touch_time1);

commit c60696dbae3696006cb24bfe1d51254977f4f65b
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Tue Oct 27 17:16:35 2020 -0300

    Keep watchdog refreshed in LVGL init (#19900)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
index 26f6301763..21e3040c2e 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
@@ -109,31 +109,34 @@ extern uint8_t bmp_public_buf[17 * 1024];
 void tft_lvgl_init() {
 
   //uint16_t test_id=0;
   W25QXX.init(SPI_QUARTER_SPEED);
   //test_id=W25QXX.W25QXX_ReadID();
 
   gCfgItems_init();
   ui_cfg_init();
   disp_language_init();
 
-  //init tft first!
+  watchdog_refresh();     // LVGL init takes time
+
+  // Init TFT first!
   SPI_TFT.spi_init(SPI_FULL_SPEED);
   SPI_TFT.LCD_init();
 
+  watchdog_refresh();     // LVGL init takes time
+
   //spi_flash_read_test();
   #if ENABLED(SDSUPPORT)
-    watchdog_refresh();
     UpdateAssets();
+    watchdog_refresh();   // LVGL init takes time
   #endif
 
-  watchdog_refresh();
   mks_test_get();
 
   touch.Init();
 
   lv_init();
 
   lv_disp_buf_init(&disp_buf, bmp_public_buf, nullptr, LV_HOR_RES_MAX * 18); /*Initialize the display buffer*/
 
   lv_disp_drv_t disp_drv;     /*Descriptor of a display driver*/
   lv_disp_drv_init(&disp_drv);    /*Basic initialization*/
@@ -182,40 +185,40 @@ void tft_lvgl_init() {
   #if HAS_SPI_FLASH_FONT
     init_gb2312_font();
   #endif
 
   tft_style_init();
 
   filament_pin_setup();
 
   lv_encoder_pin_init();
 
+  bool ready = true;
   #if ENABLED(POWER_LOSS_RECOVERY)
     recovery.load();
     if (recovery.valid()) {
+      ready = false;
       if (gCfgItems.from_flash_pic)
         flash_preview_begin = true;
       else
         default_preview_flg = true;
 
       uiCfg.print_state = REPRINTING;
 
       strncpy(public_buf_m, recovery.info.sd_filename, sizeof(public_buf_m));
       card.printLongPath(public_buf_m);
-
       strncpy(list_file.long_name[sel_id], card.longFilename, sizeof(list_file.long_name[sel_id]));
-
       lv_draw_printing();
     }
-    else
   #endif
-    lv_draw_ready_print();
+
+  if (ready) lv_draw_ready_print();
 
   if (mks_test_flag == 0x1E)
     mks_gpio_test();
 }
 
 void my_disp_flush(lv_disp_drv_t * disp, const lv_area_t * area, lv_color_t * color_p) {
   uint16_t width = area->x2 - area->x1 + 1,
           height = area->y2 - area->y1 + 1;
 
   SPI_TFT.setWindow((uint16_t)area->x1, (uint16_t)area->y1, width, height);

commit 75b0e3246a00c04c5bf04607d030775f1d8d1e0c
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Tue Oct 27 17:09:19 2020 -0300

    Fix some LVGL bugs (#19904)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
index 2f1ec48b44..26f6301763 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
@@ -36,21 +36,21 @@
 
 #include "pic_manager.h"
 #include "mks_hardware_test.h"
 #include "draw_ui.h"
 #include "SPIFlashStorage.h"
 #include <lvgl.h>
 
 #include "../../../../MarlinCore.h"
 #include "../../../../inc/MarlinConfig.h"
 
-#include HAL_PATH(../../HAL, tft/xpt2046.h)
+#include HAL_PATH(../../../../HAL, tft/xpt2046.h)
 #include "../../../marlinui.h"
 XPT2046 touch;
 
 #if ENABLED(POWER_LOSS_RECOVERY)
   #include "../../../../feature/powerloss.h"
 #endif
 
 #include <SPI.h>
 
 #ifndef TFT_WIDTH

commit 9630c2683c39468bf885c560a1768d8b377d9462
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Sat Oct 24 01:37:45 2020 -0300

    More MKS UI cleanup, optimization (#19869)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
index 6143037c2b..2f1ec48b44 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
@@ -92,21 +92,21 @@ void SysTick_Callback() {
       uiCfg.filament_loading_completed = 1;
     }
   }
   if (uiCfg.filament_unloading_time_flg == 1) {
     uiCfg.filament_unloading_time_cnt++;
     uiCfg.filament_rate = (uint32_t)(((uiCfg.filament_unloading_time_cnt / (uiCfg.filament_unloading_time * 1000.0)) * 100.0) + 0.5);
     if (uiCfg.filament_unloading_time_cnt >= (uiCfg.filament_unloading_time * 1000)) {
       uiCfg.filament_unloading_time_cnt  = 0;
       uiCfg.filament_unloading_time_flg  = 0;
       uiCfg.filament_unloading_completed = 1;
-      uiCfg.filament_rate                = 100;
+      uiCfg.filament_rate = 100;
     }
   }
 }
 
 extern uint8_t bmp_public_buf[17 * 1024];
 
 void tft_lvgl_init() {
 
   //uint16_t test_id=0;
   W25QXX.init(SPI_QUARTER_SPEED);
@@ -126,21 +126,21 @@ void tft_lvgl_init() {
     UpdateAssets();
   #endif
 
   watchdog_refresh();
   mks_test_get();
 
   touch.Init();
 
   lv_init();
 
-  lv_disp_buf_init(&disp_buf, bmp_public_buf, NULL, LV_HOR_RES_MAX * 18); /*Initialize the display buffer*/
+  lv_disp_buf_init(&disp_buf, bmp_public_buf, nullptr, LV_HOR_RES_MAX * 18); /*Initialize the display buffer*/
 
   lv_disp_drv_t disp_drv;     /*Descriptor of a display driver*/
   lv_disp_drv_init(&disp_drv);    /*Basic initialization*/
   disp_drv.flush_cb = my_disp_flush; /*Set your driver function*/
   disp_drv.buffer = &disp_buf;    /*Assign the buffer to the display*/
   lv_disp_drv_register(&disp_drv);  /*Finally register the driver*/
 
   lv_indev_drv_t indev_drv;
   lv_indev_drv_init(&indev_drv);     /*Descriptor of a input device driver*/
   indev_drv.type = LV_INDEV_TYPE_POINTER; /*Touch pad is a pointer-like device*/
@@ -192,46 +192,44 @@ void tft_lvgl_init() {
   #if ENABLED(POWER_LOSS_RECOVERY)
     recovery.load();
     if (recovery.valid()) {
       if (gCfgItems.from_flash_pic)
         flash_preview_begin = true;
       else
         default_preview_flg = true;
 
       uiCfg.print_state = REPRINTING;
 
-      ZERO(public_buf_m);
       strncpy(public_buf_m, recovery.info.sd_filename, sizeof(public_buf_m));
       card.printLongPath(public_buf_m);
 
       strncpy(list_file.long_name[sel_id], card.longFilename, sizeof(list_file.long_name[sel_id]));
 
       lv_draw_printing();
     }
     else
   #endif
     lv_draw_ready_print();
 
   if (mks_test_flag == 0x1E)
     mks_gpio_test();
 }
 
 void my_disp_flush(lv_disp_drv_t * disp, const lv_area_t * area, lv_color_t * color_p) {
-  uint16_t i, width, height;
-
-  width = area->x2 - area->x1 + 1;
-  height = area->y2 - area->y1 + 1;
+  uint16_t width = area->x2 - area->x1 + 1,
+          height = area->y2 - area->y1 + 1;
 
   SPI_TFT.setWindow((uint16_t)area->x1, (uint16_t)area->y1, width, height);
-  for (i = 0; i < height; i++) {
+
+  for (uint16_t i = 0; i < height; i++)
     SPI_TFT.tftio.WriteSequence((uint16_t*)(color_p + width * i), width);
-  }
+
   lv_disp_flush_ready(disp);       /* Indicate you are ready with the flushing*/
 
   W25QXX.init(SPI_QUARTER_SPEED);
 }
 
 #define TICK_CYCLE 1
 
 unsigned int getTickDiff(unsigned int curTick, unsigned int lastTick) {
   return TICK_CYCLE * (lastTick <= curTick ? (curTick - lastTick) : (0xFFFFFFFF - lastTick + curTick));
 }
@@ -303,24 +301,23 @@ bool my_mousewheel_read(lv_indev_drv_t * indev_drv, lv_indev_data_t * data) {
 
   return false;       /*No more data to read so return false*/
 }
 
 extern uint8_t currentFlashPage;
 
 //spi_flash
 uint32_t pic_read_base_addr = 0, pic_read_addr_offset = 0;
 lv_fs_res_t spi_flash_open_cb (lv_fs_drv_t * drv, void * file_p, const char * path, lv_fs_mode_t mode) {
   static char last_path_name[30];
-  if (strcasecmp(last_path_name,path) != 0) {
+  if (strcasecmp(last_path_name, path) != 0) {
     pic_read_base_addr = lv_get_pic_addr((uint8_t *)path);
-    ZERO(last_path_name);
-    strcpy(last_path_name,path);
+    strcpy(last_path_name, path);
   }
   else {
     W25QXX.init(SPI_QUARTER_SPEED);
     currentFlashPage = 0;
   }
   pic_read_addr_offset = pic_read_base_addr;
   return LV_FS_RES_OK;
 }
 
 lv_fs_res_t spi_flash_close_cb (lv_fs_drv_t * drv, void * file_p) {
@@ -355,25 +352,24 @@ lv_fs_res_t spi_flash_tell_cb(lv_fs_drv_t * drv, void * file_p, uint32_t * pos_p
   *pos_p = pic_read_addr_offset - pic_read_base_addr;
   return LV_FS_RES_OK;
 }
 
 //sd
 char *cur_namefff;
 uint32_t sd_read_base_addr = 0,sd_read_addr_offset = 0;
 lv_fs_res_t sd_open_cb (lv_fs_drv_t * drv, void * file_p, const char * path, lv_fs_mode_t mode) {
   //cur_namefff = strrchr(path, '/');
   char name_buf[100];
-  ZERO(name_buf);
-  strcat(name_buf,"/");
-  strcat(name_buf,path);
-  char *temp = strstr(name_buf,".bin");
-  if (temp) { strcpy(temp,".GCO"); }
+  *name_buf = '/';
+  strcpy(name_buf + 1, path);
+  char *temp = strstr(name_buf, ".bin");
+  if (temp) strcpy(temp, ".GCO");
   sd_read_base_addr = lv_open_gcode_file((char *)name_buf);
   sd_read_addr_offset = sd_read_base_addr;
   if (sd_read_addr_offset == 0) return LV_FS_RES_NOT_EX;
   return LV_FS_RES_OK;
 }
 
 lv_fs_res_t sd_close_cb (lv_fs_drv_t * drv, void * file_p) {
   /* Add your code here*/
   lv_close_gcode_file();
   return LV_FS_RES_OK;

commit 072f996af70b5ac635893eca2d4bd4bbb4f00acc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Oct 21 12:45:27 2020 -0500

    General cleanup, mostly MKS UI (#19825)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
index f74ed3c798..6143037c2b 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
@@ -65,31 +65,30 @@ XPT2046 touch;
 #endif
 
 static lv_disp_buf_t disp_buf;
 lv_group_t*  g;
 #if ENABLED(SDSUPPORT)
   extern void UpdateAssets();
 #endif
 uint16_t DeviceCode = 0x9488;
 extern uint8_t sel_id;
 
-extern uint8_t gcode_preview_over, flash_preview_begin, default_preview_flg;
+extern bool flash_preview_begin, default_preview_flg, gcode_preview_over;
 
 uint8_t bmp_public_buf[17 * 1024];
 
 void SysTick_Callback() {
   lv_tick_inc(1);
   print_time_count();
   #if ENABLED(USE_WIFI_FUNCTION)
-    if (tips_disp.timer == TIPS_TIMER_START) {
+    if (tips_disp.timer == TIPS_TIMER_START)
       tips_disp.timer_count++;
-    }
   #endif
   if (uiCfg.filament_loading_time_flg == 1) {
     uiCfg.filament_loading_time_cnt++;
     uiCfg.filament_rate = (uint32_t)(((uiCfg.filament_loading_time_cnt / (uiCfg.filament_loading_time * 1000.0)) * 100.0) + 0.5);
     if (uiCfg.filament_loading_time_cnt >= (uiCfg.filament_loading_time * 1000)) {
       uiCfg.filament_loading_time_cnt  = 0;
       uiCfg.filament_loading_time_flg  = 0;
       uiCfg.filament_loading_completed = 1;
     }
   }
@@ -186,24 +185,24 @@ void tft_lvgl_init() {
 
   tft_style_init();
 
   filament_pin_setup();
 
   lv_encoder_pin_init();
 
   #if ENABLED(POWER_LOSS_RECOVERY)
     recovery.load();
     if (recovery.valid()) {
-      if (gCfgItems.from_flash_pic == 1)
-        flash_preview_begin = 1;
+      if (gCfgItems.from_flash_pic)
+        flash_preview_begin = true;
       else
-        default_preview_flg = 1;
+        default_preview_flg = true;
 
       uiCfg.print_state = REPRINTING;
 
       ZERO(public_buf_m);
       strncpy(public_buf_m, recovery.info.sd_filename, sizeof(public_buf_m));
       card.printLongPath(public_buf_m);
 
       strncpy(list_file.long_name[sel_id], card.longFilename, sizeof(list_file.long_name[sel_id]));
 
       lv_draw_printing();
@@ -401,50 +400,46 @@ lv_fs_res_t sd_seek_cb(lv_fs_drv_t * drv, void * file_p, uint32_t pos) {
   return LV_FS_RES_OK;
 }
 
 lv_fs_res_t sd_tell_cb(lv_fs_drv_t * drv, void * file_p, uint32_t * pos_p) {
   if (sd_read_addr_offset) *pos_p = 0;
   else *pos_p = (sd_read_addr_offset - sd_read_base_addr) / 409 * 200 + 4;
   return LV_FS_RES_OK;
 }
 
 void lv_encoder_pin_init() {
-  #if 1 // HAS_DIGITAL_BUTTONS
-
-    #if BUTTON_EXISTS(EN1)
-      SET_INPUT_PULLUP(BTN_EN1);
-    #endif
-    #if BUTTON_EXISTS(EN2)
-      SET_INPUT_PULLUP(BTN_EN2);
-    #endif
-    #if BUTTON_EXISTS(ENC)
-      SET_INPUT_PULLUP(BTN_ENC);
-    #endif
-
-    #if BUTTON_EXISTS(BACK)
-      SET_INPUT_PULLUP(BTN_BACK);
-    #endif
-
-    #if BUTTON_EXISTS(UP)
-      SET_INPUT(BTN_UP);
-    #endif
-    #if BUTTON_EXISTS(DWN)
-      SET_INPUT(BTN_DWN);
-    #endif
-    #if BUTTON_EXISTS(LFT)
-      SET_INPUT(BTN_LFT);
-    #endif
-    #if BUTTON_EXISTS(RT)
-      SET_INPUT(BTN_RT);
-    #endif
-
-  #endif // HAS_DIGITAL_BUTTONS
+  #if BUTTON_EXISTS(EN1)
+    SET_INPUT_PULLUP(BTN_EN1);
+  #endif
+  #if BUTTON_EXISTS(EN2)
+    SET_INPUT_PULLUP(BTN_EN2);
+  #endif
+  #if BUTTON_EXISTS(ENC)
+    SET_INPUT_PULLUP(BTN_ENC);
+  #endif
+
+  #if BUTTON_EXISTS(BACK)
+    SET_INPUT_PULLUP(BTN_BACK);
+  #endif
+
+  #if BUTTON_EXISTS(UP)
+    SET_INPUT(BTN_UP);
+  #endif
+  #if BUTTON_EXISTS(DWN)
+    SET_INPUT(BTN_DWN);
+  #endif
+  #if BUTTON_EXISTS(LFT)
+    SET_INPUT(BTN_LFT);
+  #endif
+  #if BUTTON_EXISTS(RT)
+    SET_INPUT(BTN_RT);
+  #endif
 }
 
 #if 1 // HAS_ENCODER_ACTION
 
   //static const int8_t encoderDirection = 1;
   //static int16_t enc_Direction;
   void lv_update_encoder() {
     static uint32_t encoder_time1;
     uint32_t tmpTime, diffTime = 0;
     tmpTime = millis();

commit eaf6777a6643a6fab23ceaaa4699cb2466ea6b83
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Oct 16 19:36:25 2020 -0500

    Rename ultralcd => marlinui

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
index c0cd14d70d..f74ed3c798 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
@@ -37,21 +37,21 @@
 #include "pic_manager.h"
 #include "mks_hardware_test.h"
 #include "draw_ui.h"
 #include "SPIFlashStorage.h"
 #include <lvgl.h>
 
 #include "../../../../MarlinCore.h"
 #include "../../../../inc/MarlinConfig.h"
 
 #include HAL_PATH(../../HAL, tft/xpt2046.h)
-#include "../../../ultralcd.h"
+#include "../../../marlinui.h"
 XPT2046 touch;
 
 #if ENABLED(POWER_LOSS_RECOVERY)
   #include "../../../../feature/powerloss.h"
 #endif
 
 #include <SPI.h>
 
 #ifndef TFT_WIDTH
   #define TFT_WIDTH  480

commit bf33b2f862a0141e1eabc7d864f80de2d97bf9d2
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Tue Oct 13 20:12:34 2020 -0300

    Watchdog Refresh for LVGL Asset Load (#19724)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
index ccb6a8e4dc..c0cd14d70d 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
@@ -116,22 +116,25 @@ void tft_lvgl_init() {
   gCfgItems_init();
   ui_cfg_init();
   disp_language_init();
 
   //init tft first!
   SPI_TFT.spi_init(SPI_FULL_SPEED);
   SPI_TFT.LCD_init();
 
   //spi_flash_read_test();
   #if ENABLED(SDSUPPORT)
+    watchdog_refresh();
     UpdateAssets();
   #endif
+
+  watchdog_refresh();
   mks_test_get();
 
   touch.Init();
 
   lv_init();
 
   lv_disp_buf_init(&disp_buf, bmp_public_buf, NULL, LV_HOR_RES_MAX * 18); /*Initialize the display buffer*/
 
   lv_disp_drv_t disp_drv;     /*Descriptor of a display driver*/
   lv_disp_drv_init(&disp_drv);    /*Basic initialization*/

commit 2132efa9817fa1ee5d4e0773c2b8dcfac4da161a
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Tue Oct 13 13:58:50 2020 -0300

    TFT followup fixes (#19710)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
index ecd4eb482a..ccb6a8e4dc 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
@@ -467,21 +467,22 @@ void lv_encoder_pin_init() {
             if (BUTTON_PRESSED(BACK)) newbutton |= EN_D;
           #endif
 
         #else
 
           constexpr uint8_t newbutton = 0;
 
         #endif
 
 
-        static uint8_t buttons = newbutton;
+        static uint8_t buttons = 0;
+        buttons = newbutton;
         static uint8_t lastEncoderBits;
 
         #define encrot0 0
         #define encrot1 1
         #define encrot2 2
 
         // Manage encoder rotation
         //#define ENCODER_SPIN(_E1, _E2) switch (lastEncoderBits) { case _E1: enc_Direction += encoderDirection; break; case _E2: enc_Direction -= encoderDirection; }
 
         uint8_t enc = 0;

commit c0920bbf6a2490b7ea66d2a9e828c0f527a6c77b
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Mon Oct 12 18:38:07 2020 -0300

    TFT Refactoring (#19192)
    
    * split tft folder in two: tft for color ui; tft_io for shared tft code
    
    * after the files got moved, now the code was moved to the right place
    
    * classic ui using TFT IO init lcd codes
    
    * feature to compile tft_io when enabled
    
    * compiling fix
    
    * lvgl spi tft working with tft io init codes
    
    * there is no need for separeted fsmc and spi class in lvgl anymore, as tft io handle everything
    
    * remove debug
    
    * base for TFT rotation and mirroring API, and ILI9488 support
    
    * ST7796S rotate and mirror support
    
    * ST7789V rotate and mirror support
    
    * ST7735 rotate and mirror support
    
    * ILI9341 rotate and mirror support
    
    * ILI9328 rotate and mirror support
    
    * R61505 rotate and mirror support
    
    * MKS TFT definitions
    
    * more configs for mks tfts
    
    * update config
    
    * naming typo
    
    * to configure the user interface
    
    * ANYCUBIC_TFT35
    
    * tft configs
    
    * support for SSD1963
    
    * tft display types
    
    * updated conditionals lcd; first board fully working with the new code - all 3 ui!
    
    * compatiblity
    
    * changed name
    
    * move classic ui file name
    
    * rename TURN -> ROTATE
    
    * GRAPHICAL_TFT_ROTATE_180 deprecated
    
    * first fsmc board fully working - chitu v5
    
    * mks robin nano v1.2 + tft 35 ok!
    
    * right pin name
    
    * anycubic tft tested in a TRIGORILLA_PRO
    
    * chitu v6
    
    * nano 32 tft orientation
    
    * mks tft43
    
    * mks tft43 rotation
    
    * fixed LONGER LK tft setup
    
    * GRAPHICAL_TFT_UPSCALE defined by the display type
    
    * better offsets defaults
    
    * Update Configuration.h
    
    * Update tft_fsmc.cpp
    
    * Update Conditionals_LCD.h
    
    * Tweak comments
    
    * update nano tests
    
    * Revert "update nano tests"
    
    This reverts commit a071ebbfad30e28855a4a5695ec8a726542a1a65.
    
    * default tft
    
    * outdated comments
    
    * to not break non-vscode builds
    
    * upscale tft 35
    
    * support tft 180 rotation for color ui
    
    * Each TFT Driver is responsible for its default color mode.
    
    * use auto detect in mks displays, because some of them could be shipped with diferent drivers
    
    * extra s
    
    * unused code
    
    * wrong -1
    
    * missing mirror options
    
    * Smaller regex pattern
    
    * Comment updates
    
    * Clean up old defines
    
    * Apply pins formatting
    
    * GRAPHICAL_TFT_ROTATE_180 => TFT_ROTATE_180
    
    * MKS_ROBIN_TFT_V1_1R
    
    * merge fix
    
    * correct resolution
    
    * auto is default, dont need be there, and it will allow the user to configure it even for named displays
    
    * to not use rotation with MKS_ROBIN_TFT_V1_1R
    
    * i like () in macros
    
    * avoid sleepy commits
    
    * default for st7789 is rgb
    
    * nano follow up
    
    * to allow ili9328 rotation
    
    * default is rgb
    
    * boards merge follow up
    
    * to match bootloader orientation
    
    * HAS_TOUCH_XPT2046 is not hal specific anymore
    
    * lets not forget LPC
    
    * 180 rotation for ili9328 and R61505
    
    * Clean up whitespace
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
index 3f8110feb4..ecd4eb482a 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
@@ -22,23 +22,21 @@
 
 /**
  * @file tft_lvgl_configuration.cpp
  * @date    2020-02-21
  */
 
 #include "../../../../inc/MarlinConfigPre.h"
 
 #if HAS_TFT_LVGL_UI
 
-#if ENABLED(TFT_LVGL_UI_SPI)
-  #include "SPI_TFT.h"
-#endif
+#include "SPI_TFT.h"
 
 #include "tft_lvgl_configuration.h"
 #include "draw_ready_print.h"
 
 #include "pic_manager.h"
 #include "mks_hardware_test.h"
 #include "draw_ui.h"
 #include "SPIFlashStorage.h"
 #include <lvgl.h>
 
@@ -67,38 +65,20 @@ XPT2046 touch;
 #endif
 
 static lv_disp_buf_t disp_buf;
 lv_group_t*  g;
 #if ENABLED(SDSUPPORT)
   extern void UpdateAssets();
 #endif
 uint16_t DeviceCode = 0x9488;
 extern uint8_t sel_id;
 
-#define SetCs
-#define ClrCs
-
-#define HDP  799 // Horizontal Display Period
-#define HT  1000 // Horizontal Total
-#define HPS   51 // LLINE Pulse Start Position
-#define LPS    3 // Horizontal Display Period Start Position
-#define HPW    8 // LLINE Pulse Width
-
-#define VDP  479 // Vertical Display Period
-#define VT   530 // Vertical Total
-#define VPS   24 // LFRAME Pulse Start Position
-#define FPS   23 // Vertical Display Period Start Positio
-#define VPW    3 // LFRAME Pulse Width
-
-#define MAX_HZ_POSX HDP+1
-#define MAX_HZ_POSY VDP+1
-
 extern uint8_t gcode_preview_over, flash_preview_begin, default_preview_flg;
 
 uint8_t bmp_public_buf[17 * 1024];
 
 void SysTick_Callback() {
   lv_tick_inc(1);
   print_time_count();
   #if ENABLED(USE_WIFI_FUNCTION)
     if (tips_disp.timer == TIPS_TIMER_START) {
       tips_disp.timer_count++;
@@ -118,349 +98,35 @@ void SysTick_Callback() {
     uiCfg.filament_rate = (uint32_t)(((uiCfg.filament_unloading_time_cnt / (uiCfg.filament_unloading_time * 1000.0)) * 100.0) + 0.5);
     if (uiCfg.filament_unloading_time_cnt >= (uiCfg.filament_unloading_time * 1000)) {
       uiCfg.filament_unloading_time_cnt  = 0;
       uiCfg.filament_unloading_time_flg  = 0;
       uiCfg.filament_unloading_completed = 1;
       uiCfg.filament_rate                = 100;
     }
   }
 }
 
-#if DISABLED(TFT_LVGL_UI_SPI)
-
-  extern void LCD_IO_Init(uint8_t cs, uint8_t rs);
-  extern void LCD_IO_WriteData(uint16_t RegValue);
-  extern void LCD_IO_WriteReg(uint16_t Reg);
-
-  extern void LCD_IO_WriteMultiple(uint16_t color, uint32_t count);
-  void tft_set_cursor(uint16_t x, uint16_t y) {
-    LCD_IO_WriteReg(0x002A);
-    LCD_IO_WriteData(x >> 8);
-    LCD_IO_WriteData(x & 0x00FF);
-    LCD_IO_WriteData(x >> 8);
-    LCD_IO_WriteData(x & 0x00FF);
-    //ILI9488_WriteData(0x01);
-    //ILI9488_WriteData(0xDF);
-    LCD_IO_WriteReg(0x002B);
-    LCD_IO_WriteData(y >> 8);
-    LCD_IO_WriteData(y & 0x00FF);
-    LCD_IO_WriteData(y >> 8);
-    LCD_IO_WriteData(y & 0x00FF);
-    //ILI9488_WriteData(0x01);
-    //ILI9488_WriteData(0x3F);
-  }
-
-  void LCD_WriteRAM_Prepare(void) {
-    #if 0
-      switch (DeviceCode) {
-        case 0x9325: case 0x9328: case 0x8989: {
-          ClrCs
-          LCD->LCD_REG = R34;
-          SetCs
-        } break;
-        default: LCD_WrtReg(0x002C);
-      }
-    #else
-      LCD_IO_WriteReg(0x002C);
-    #endif
-  }
-
-  void tft_set_point(uint16_t x, uint16_t y, uint16_t point) {
-    //if (DeviceCode == 0x9488) {
-    if (x > (TFT_WIDTH) || y > (TFT_HEIGHT)) return;
-    //}
-    tft_set_cursor(x, y);
-
-    LCD_WriteRAM_Prepare();
-    //LCD_WriteRAM(point);
-    LCD_IO_WriteData(point);
-  }
-
-  void LCD_WriteReg(uint16_t LCD_Reg, uint16_t LCD_RegValue) {
-    /* Write 16-bit Index, then Write Reg */
-    ClrCs
-    LCD_IO_WriteReg(LCD_Reg);
-    /* Write 16-bit Reg */
-    LCD_IO_WriteData(LCD_RegValue);
-    SetCs
-  }
-
-  void LCD_setWindowArea(uint16_t StartX, uint16_t StartY, uint16_t width, uint16_t heigh) {
-    uint16_t s_h, s_l, e_h, e_l;
-    uint16_t xEnd, yEnd;
-    xEnd = StartX + width;
-    yEnd = StartY + heigh - 1;
-    if (DeviceCode == 0x8989) {
-      /*LCD_WriteReg(0x0044, (StartX & 0xFF) | (xEnd << 8));
-      LCD_WriteReg(0x0045, StartY);
-      LCD_WriteReg(0x0046, yEnd);*/
-      LCD_WriteReg(0x0044, (StartY & 0xFF) | (yEnd << 8));
-      LCD_WriteReg(0x0045, StartX);
-      LCD_WriteReg(0x0046, xEnd);
-    }
-    else if (DeviceCode == 0x9488) {
-      s_h = (StartX >> 8) & 0x00FF;
-      s_l = StartX & 0x00FF;
-      e_h = ((StartX + width - 1) >> 8) & 0x00FF;
-      e_l = (StartX + width - 1) & 0x00FF;
-
-      LCD_IO_WriteReg(0x002A);
-      LCD_IO_WriteData(s_h);
-      LCD_IO_WriteData(s_l);
-      LCD_IO_WriteData(e_h);
-      LCD_IO_WriteData(e_l);
-
-      s_h = (StartY >> 8) & 0x00FF;
-      s_l = StartY & 0x00FF;
-      e_h = ((StartY + heigh - 1) >> 8) & 0x00FF;
-      e_l = (StartY + heigh - 1) & 0x00FF;
-
-      LCD_IO_WriteReg(0x002B);
-      LCD_IO_WriteData(s_h);
-      LCD_IO_WriteData(s_l);
-      LCD_IO_WriteData(e_h);
-      LCD_IO_WriteData(e_l);
-    }
-    else if ((DeviceCode == 0x9325) || (DeviceCode == 0x9328) || (DeviceCode == 0x1505)) {
-      /* LCD_WriteReg(0x0050, StartX);
-       LCD_WriteReg(0x0052, StartY);
-       LCD_WriteReg(0x0051, xEnd);
-       LCD_WriteReg(0x0053, yEnd);*/
-      LCD_WriteReg(0x0050, StartY);   // Specify the start/end positions of the window address in the horizontal direction by an address unit
-      LCD_WriteReg(0x0051, yEnd);     // Specify the start positions of the window address in the vertical direction by an address unit
-      LCD_WriteReg(0x0052, (TFT_HEIGHT) - xEnd);
-      LCD_WriteReg(0x0053, (TFT_HEIGHT) - StartX - 1); // Specify the end positions of the window address in the vertical direction by an address unit
-
-    }
-    else {
-      s_h = (StartX >> 8) & 0xFF;
-      s_l = StartX & 0xFF;
-      e_h = ((StartX + width - 1) >> 8) & 0xFF;
-      e_l = (StartX + width - 1) & 0xFF;
-
-      LCD_IO_WriteReg(0x2A);
-      LCD_IO_WriteData(s_h);
-      LCD_IO_WriteData(s_l);
-      LCD_IO_WriteData(e_h);
-      LCD_IO_WriteData(e_l);
-
-      s_h = (StartY >> 8) & 0xFF;
-      s_l = StartY & 0xFF;
-      e_h = ((StartY + heigh - 1) >> 8) & 0xFF;
-      e_l = (StartY + heigh - 1) & 0xFF;
-
-      LCD_IO_WriteReg(0x2B);
-      LCD_IO_WriteData(s_h);
-      LCD_IO_WriteData(s_l);
-      LCD_IO_WriteData(e_h);
-      LCD_IO_WriteData(e_l);
-    }
-  }
-
-  void LCD_Clear(uint16_t Color) {
-    uint32_t index = 0;
-    unsigned int count;
-
-    if (DeviceCode == 0x9488) {
-      tft_set_cursor(0, 0);
-      LCD_setWindowArea(0, 0, TFT_WIDTH, TFT_HEIGHT);
-      LCD_WriteRAM_Prepare();
-      #ifdef LCD_USE_DMA_FSMC
-        LCD_IO_WriteMultiple(Color, (TFT_WIDTH) * (TFT_HEIGHT));
-      #else
-        //index = (TFT_HEIGHT) / 2 * (TFT_WIDTH);
-        for (index = 0; index < (TFT_HEIGHT) * (TFT_WIDTH); index++)
-          LCD_IO_WriteData(Color);
-      #endif
-      //LCD_IO_WriteMultiple(Color, (TFT_WIDTH) * (TFT_HEIGHT));
-      //while(index --) LCD_IO_WriteData(Color);
-    }
-    else if (DeviceCode == 0x5761) {
-      LCD_IO_WriteReg(0x002A);
-      LCD_IO_WriteData(0);
-      LCD_IO_WriteData(0);
-      LCD_IO_WriteData(HDP >> 8);
-      LCD_IO_WriteData(HDP & 0x00FF);
-      LCD_IO_WriteReg(0x002B);
-      LCD_IO_WriteData(0);
-      LCD_IO_WriteData(0);
-      LCD_IO_WriteData(VDP >> 8);
-      LCD_IO_WriteData(VDP & 0x00FF);
-      LCD_IO_WriteReg(0x002C);
-      LCD_IO_WriteReg(0x002C);
-      for (count = 0; count < (HDP + 1) * (VDP + 1); count++)
-        LCD_IO_WriteData(Color);
-    }
-    else {
-      tft_set_cursor(0, 0);
-      LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
-      for (index = 0; index < 76800; index++)
-        LCD_IO_WriteData(Color);
-    }
-  }
-
-  #include HAL_PATH(../../HAL, tft/tft_fsmc.h)
-  extern TFT_IO tftio;
-  void fsmc_tft_init() {
-    uint16_t i;
-
-    TERN_(HAS_LCD_CONTRAST, refresh_contrast());
-
-    #ifdef LCD_USE_DMA_FSMC
-      dma_init(FSMC_DMA_DEV);
-      dma_disable(FSMC_DMA_DEV, FSMC_DMA_CHANNEL);
-      dma_set_priority(FSMC_DMA_DEV, FSMC_DMA_CHANNEL, DMA_PRIORITY_MEDIUM);
-    #endif
-
-    LCD_IO_Init(FSMC_CS_PIN, FSMC_RS_PIN);
-
-    _delay_ms(5);
-
-    DeviceCode = tftio.GetID() & 0xFFFF;
-    // Chitu and others
-    if (DeviceCode == 0x8066) DeviceCode = 0x9488;
-
-    if (DeviceCode == 0x9488) {
-      LCD_IO_WriteReg(0x00E0);
-      LCD_IO_WriteData(0x0000);
-      LCD_IO_WriteData(0x0007);
-      LCD_IO_WriteData(0x000F);
-      LCD_IO_WriteData(0x000D);
-      LCD_IO_WriteData(0x001B);
-      LCD_IO_WriteData(0x000A);
-      LCD_IO_WriteData(0x003C);
-      LCD_IO_WriteData(0x0078);
-      LCD_IO_WriteData(0x004A);
-      LCD_IO_WriteData(0x0007);
-      LCD_IO_WriteData(0x000E);
-      LCD_IO_WriteData(0x0009);
-      LCD_IO_WriteData(0x001B);
-      LCD_IO_WriteData(0x001E);
-      LCD_IO_WriteData(0x000F);
-
-      LCD_IO_WriteReg(0x00E1);
-      LCD_IO_WriteData(0x0000);
-      LCD_IO_WriteData(0x0022);
-      LCD_IO_WriteData(0x0024);
-      LCD_IO_WriteData(0x0006);
-      LCD_IO_WriteData(0x0012);
-      LCD_IO_WriteData(0x0007);
-      LCD_IO_WriteData(0x0036);
-      LCD_IO_WriteData(0x0047);
-      LCD_IO_WriteData(0x0047);
-      LCD_IO_WriteData(0x0006);
-      LCD_IO_WriteData(0x000A);
-      LCD_IO_WriteData(0x0007);
-      LCD_IO_WriteData(0x0030);
-      LCD_IO_WriteData(0x0037);
-      LCD_IO_WriteData(0x000F);
-
-      LCD_IO_WriteReg(0x00C0);
-      LCD_IO_WriteData(0x0010);
-      LCD_IO_WriteData(0x0010);
-
-      LCD_IO_WriteReg(0x00C1);
-      LCD_IO_WriteData(0x0041);
-
-      LCD_IO_WriteReg(0x00C5);
-      LCD_IO_WriteData(0x0000);
-      LCD_IO_WriteData(0x0022);
-      LCD_IO_WriteData(0x0080);
-
-      LCD_IO_WriteReg(0x0036);
-      LCD_IO_WriteData(TERN(GRAPHICAL_TFT_ROTATE_180, 0xE8, 0x0068));
-
-      LCD_IO_WriteReg(0x003A); //Interface Mode Control
-      LCD_IO_WriteData(0x0055);
-
-      LCD_IO_WriteReg(0x00B0);  //Interface Mode Control
-      LCD_IO_WriteData(0x0000);
-      LCD_IO_WriteReg(0x00B1);   //Frame rate 70HZ
-      LCD_IO_WriteData(0x00B0);
-      LCD_IO_WriteData(0x0011);
-      LCD_IO_WriteReg(0x00B4);
-      LCD_IO_WriteData(0x0002);
-      LCD_IO_WriteReg(0x00B6); //RGB/MCU Interface Control
-      LCD_IO_WriteData(0x0002);
-      LCD_IO_WriteData(0x0042);
-
-      LCD_IO_WriteReg(0x00B7);
-      LCD_IO_WriteData(0x00C6);
-
-      //WriteComm(0xBE);
-      //WriteData(0x00);
-      //WriteData(0x04);
-
-      LCD_IO_WriteReg(0x00E9);
-      LCD_IO_WriteData(0x0000);
-
-      LCD_IO_WriteReg(0x00F7);
-      LCD_IO_WriteData(0x00A9);
-      LCD_IO_WriteData(0x0051);
-      LCD_IO_WriteData(0x002C);
-      LCD_IO_WriteData(0x0082);
-
-      LCD_IO_WriteReg(0x0011);
-      for (i = 0; i < 65535; i++) { /* do nothing */ }
-      LCD_IO_WriteReg(0x0029);
-
-      LCD_setWindowArea(0, 0, TFT_WIDTH, TFT_HEIGHT);
-
-      OUT_WRITE(LCD_BACKLIGHT_PIN, LOW);
-      LCD_Clear(0x0000);
-
-      TERN_(HAS_LOGO_IN_FLASH, lcd_draw_logo());
-
-      OUT_WRITE(LCD_BACKLIGHT_PIN, HIGH);
-      delay(2000);
-    }
-  }
-
-  extern void LCD_IO_WriteSequence(uint16_t *data, uint16_t length);
-
-  void lcd_draw_logo() {
-    LCD_setWindowArea(0, 0, TFT_WIDTH, TFT_HEIGHT);
-    LCD_WriteRAM_Prepare();
-
-    for (uint16_t i = 0; i < (TFT_HEIGHT); i ++) {
-      Pic_Logo_Read((uint8_t *)"", (uint8_t *)bmp_public_buf, (TFT_WIDTH) * 2);
-      #ifdef LCD_USE_DMA_FSMC
-        LCD_IO_WriteSequence((uint16_t *)bmp_public_buf, TFT_WIDTH);
-      #else
-        int index = 0;,x_off = 0;
-        for (x_off = 0; x_off < TFT_WIDTH; x_off++) {
-          LCD_IO_WriteData((uint16_t)bmp_public_buf[index]);
-          index += 2;
-        }
-      #endif
-    }
-  }
-
-#endif // !TFT_LVGL_UI_SPI
+extern uint8_t bmp_public_buf[17 * 1024];
 
 void tft_lvgl_init() {
 
   //uint16_t test_id=0;
   W25QXX.init(SPI_QUARTER_SPEED);
   //test_id=W25QXX.W25QXX_ReadID();
 
   gCfgItems_init();
   ui_cfg_init();
   disp_language_init();
 
   //init tft first!
-  #if ENABLED(TFT_LVGL_UI_SPI)
-    SPI_TFT.spi_init(SPI_FULL_SPEED);
-    SPI_TFT.LCD_init();
-  #else
-    fsmc_tft_init();
-  #endif
+  SPI_TFT.spi_init(SPI_FULL_SPEED);
+  SPI_TFT.LCD_init();
 
   //spi_flash_read_test();
   #if ENABLED(SDSUPPORT)
     UpdateAssets();
   #endif
   mks_test_get();
 
   touch.Init();
 
   lv_init();
@@ -541,72 +207,49 @@ void tft_lvgl_init() {
     }
     else
   #endif
     lv_draw_ready_print();
 
   if (mks_test_flag == 0x1E)
     mks_gpio_test();
 }
 
 void my_disp_flush(lv_disp_drv_t * disp, const lv_area_t * area, lv_color_t * color_p) {
-  #if ENABLED(TFT_LVGL_UI_SPI)
-    uint16_t i, width, height;
-
-    width = area->x2 - area->x1 + 1;
-    height = area->y2 - area->y1 + 1;
+  uint16_t i, width, height;
 
-    SPI_TFT.SetWindows((uint16_t)area->x1, (uint16_t)area->y1, width, height);
-    for (i = 0; i < height; i++) {
-      SPI_TFT.tftio.WriteSequence((uint16_t*)(color_p + width * i), width);
-    }
-    lv_disp_flush_ready(disp);       /* Indicate you are ready with the flushing*/
-
-    W25QXX.init(SPI_QUARTER_SPEED);
+  width = area->x2 - area->x1 + 1;
+  height = area->y2 - area->y1 + 1;
 
-  #else // !TFT_LVGL_UI_SPI
-
-    #if 1
-      uint16_t i, width, height;
-      //uint16_t clr_temp;
-      width = area->x2 - area->x1 + 1;
-      height = area->y2 - area->y1 + 1;
-      LCD_setWindowArea((uint16_t)area->x1, (uint16_t)area->y1, width, height);
-      LCD_WriteRAM_Prepare();
-      for (i = 0; i < width * height - 2; i++) {
-        //clr_temp = (uint16_t)(((uint16_t)color_p->ch.red << 11)
-                              //| ((uint16_t)color_p->ch.green << 5)
-                              //| ((uint16_t)color_p->ch.blue));
-        LCD_IO_WriteData(color_p->full);
-        color_p++;
-      }
-
-      lv_disp_flush_ready(disp);       /* Indicate you are ready with the flushing*/
-    #endif
+  SPI_TFT.setWindow((uint16_t)area->x1, (uint16_t)area->y1, width, height);
+  for (i = 0; i < height; i++) {
+    SPI_TFT.tftio.WriteSequence((uint16_t*)(color_p + width * i), width);
+  }
+  lv_disp_flush_ready(disp);       /* Indicate you are ready with the flushing*/
 
-  #endif // !TFT_LVGL_UI_SPI
+  W25QXX.init(SPI_QUARTER_SPEED);
 }
 
 #define TICK_CYCLE 1
 
 unsigned int getTickDiff(unsigned int curTick, unsigned int lastTick) {
   return TICK_CYCLE * (lastTick <= curTick ? (curTick - lastTick) : (0xFFFFFFFF - lastTick + curTick));
 }
 
 static bool get_point(int16_t *x, int16_t *y) {
   bool is_touched = touch.getRawPoint(x, y);
 
   if (is_touched) {
     *x = int16_t((int32_t(*x) * XPT2046_X_CALIBRATION) >> 16) + XPT2046_X_OFFSET;
     *y = int16_t((int32_t(*y) * XPT2046_Y_CALIBRATION) >> 16) + XPT2046_Y_OFFSET;
   }
 
-  #if ENABLED(GRAPHICAL_TFT_ROTATE_180)
+  #if (TFT_ROTATION & TFT_ROTATE_180)
     *x = int16_t((TFT_WIDTH) - (int)(*x));
     *y = int16_t((TFT_HEIGHT) - (int)(*y));
   #endif
 
   return is_touched;
 }
 
 bool my_touchpad_read(lv_indev_drv_t * indev_driver, lv_indev_data_t * data) {
   static int16_t last_x = 0, last_y = 0;
   static uint8_t last_touch_state = LV_INDEV_STATE_REL;

commit c762b7c91b03415d37bbb96c5b2b6b8308ee3ba8
Author: Jason Smith <jason.inet@gmail.com>
Date:   Sun Oct 11 17:06:57 2020 -0700

    Fix various errors, warnings in example config builds (#19686)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
index 49b44799a6..3f8110feb4 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
@@ -792,53 +792,53 @@ void lv_encoder_pin_init() {
     #endif
 
   #endif // HAS_DIGITAL_BUTTONS
 }
 
 #if 1 // HAS_ENCODER_ACTION
 
   //static const int8_t encoderDirection = 1;
   //static int16_t enc_Direction;
   void lv_update_encoder() {
-    static uint8_t buttons;
     static uint32_t encoder_time1;
     uint32_t tmpTime, diffTime = 0;
     tmpTime = millis();
     diffTime = getTickDiff(tmpTime, encoder_time1);
     if (diffTime > 50) {
 
-      #if ANY_BUTTON(EN1, EN2, ENC, BACK)
+      #if HAS_ENCODER_WHEEL
 
-        uint8_t newbutton = 0;
+        #if ANY_BUTTON(EN1, EN2, ENC, BACK)
 
-        #if BUTTON_EXISTS(EN1)
-          if (BUTTON_PRESSED(EN1)) newbutton |= EN_A;
-        #endif
-        #if BUTTON_EXISTS(EN2)
-          if (BUTTON_PRESSED(EN2)) newbutton |= EN_B;
-        #endif
-        #if BUTTON_EXISTS(ENC)
-          if (BUTTON_PRESSED(ENC)) newbutton |= EN_C;
-        #endif
-        #if BUTTON_EXISTS(BACK)
-          if (BUTTON_PRESSED(BACK)) newbutton |= EN_D;
-        #endif
+          uint8_t newbutton = 0;
 
-      #else
+          #if BUTTON_EXISTS(EN1)
+            if (BUTTON_PRESSED(EN1)) newbutton |= EN_A;
+          #endif
+          #if BUTTON_EXISTS(EN2)
+            if (BUTTON_PRESSED(EN2)) newbutton |= EN_B;
+          #endif
+          #if BUTTON_EXISTS(ENC)
+            if (BUTTON_PRESSED(ENC)) newbutton |= EN_C;
+          #endif
+          #if BUTTON_EXISTS(BACK)
+            if (BUTTON_PRESSED(BACK)) newbutton |= EN_D;
+          #endif
 
-        constexpr uint8_t newbutton = 0;
+        #else
 
-      #endif
+          constexpr uint8_t newbutton = 0;
 
-      buttons = newbutton;
+        #endif
 
-      #if HAS_ENCODER_WHEEL
+
+        static uint8_t buttons = newbutton;
         static uint8_t lastEncoderBits;
 
         #define encrot0 0
         #define encrot1 1
         #define encrot2 2
 
         // Manage encoder rotation
         //#define ENCODER_SPIN(_E1, _E2) switch (lastEncoderBits) { case _E1: enc_Direction += encoderDirection; break; case _E2: enc_Direction -= encoderDirection; }
 
         uint8_t enc = 0;

commit 6831341ab483a49d7daad4c704bb684d3cbbf075
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Oct 9 16:50:17 2020 -0500

    Batch appercase hex values

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
index c2ff2c4362..49b44799a6 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
@@ -191,35 +191,35 @@ void SysTick_Callback() {
     yEnd = StartY + heigh - 1;
     if (DeviceCode == 0x8989) {
       /*LCD_WriteReg(0x0044, (StartX & 0xFF) | (xEnd << 8));
       LCD_WriteReg(0x0045, StartY);
       LCD_WriteReg(0x0046, yEnd);*/
       LCD_WriteReg(0x0044, (StartY & 0xFF) | (yEnd << 8));
       LCD_WriteReg(0x0045, StartX);
       LCD_WriteReg(0x0046, xEnd);
     }
     else if (DeviceCode == 0x9488) {
-      s_h = (StartX >> 8) & 0x00ff;
-      s_l = StartX & 0x00ff;
-      e_h = ((StartX + width - 1) >> 8) & 0x00ff;
-      e_l = (StartX + width - 1) & 0x00ff;
+      s_h = (StartX >> 8) & 0x00FF;
+      s_l = StartX & 0x00FF;
+      e_h = ((StartX + width - 1) >> 8) & 0x00FF;
+      e_l = (StartX + width - 1) & 0x00FF;
 
       LCD_IO_WriteReg(0x002A);
       LCD_IO_WriteData(s_h);
       LCD_IO_WriteData(s_l);
       LCD_IO_WriteData(e_h);
       LCD_IO_WriteData(e_l);
 
-      s_h = (StartY >> 8) & 0x00ff;
-      s_l = StartY & 0x00ff;
-      e_h = ((StartY + heigh - 1) >> 8) & 0x00ff;
-      e_l = (StartY + heigh - 1) & 0x00ff;
+      s_h = (StartY >> 8) & 0x00FF;
+      s_l = StartY & 0x00FF;
+      e_h = ((StartY + heigh - 1) >> 8) & 0x00FF;
+      e_l = (StartY + heigh - 1) & 0x00FF;
 
       LCD_IO_WriteReg(0x002B);
       LCD_IO_WriteData(s_h);
       LCD_IO_WriteData(s_l);
       LCD_IO_WriteData(e_h);
       LCD_IO_WriteData(e_l);
     }
     else if ((DeviceCode == 0x9325) || (DeviceCode == 0x9328) || (DeviceCode == 0x1505)) {
       /* LCD_WriteReg(0x0050, StartX);
        LCD_WriteReg(0x0052, StartY);
@@ -268,32 +268,32 @@ void SysTick_Callback() {
         LCD_IO_WriteMultiple(Color, (TFT_WIDTH) * (TFT_HEIGHT));
       #else
         //index = (TFT_HEIGHT) / 2 * (TFT_WIDTH);
         for (index = 0; index < (TFT_HEIGHT) * (TFT_WIDTH); index++)
           LCD_IO_WriteData(Color);
       #endif
       //LCD_IO_WriteMultiple(Color, (TFT_WIDTH) * (TFT_HEIGHT));
       //while(index --) LCD_IO_WriteData(Color);
     }
     else if (DeviceCode == 0x5761) {
-      LCD_IO_WriteReg(0x002a);
+      LCD_IO_WriteReg(0x002A);
       LCD_IO_WriteData(0);
       LCD_IO_WriteData(0);
       LCD_IO_WriteData(HDP >> 8);
-      LCD_IO_WriteData(HDP & 0x00ff);
-      LCD_IO_WriteReg(0x002b);
+      LCD_IO_WriteData(HDP & 0x00FF);
+      LCD_IO_WriteReg(0x002B);
       LCD_IO_WriteData(0);
       LCD_IO_WriteData(0);
       LCD_IO_WriteData(VDP >> 8);
-      LCD_IO_WriteData(VDP & 0x00ff);
-      LCD_IO_WriteReg(0x002c);
-      LCD_IO_WriteReg(0x002c);
+      LCD_IO_WriteData(VDP & 0x00FF);
+      LCD_IO_WriteReg(0x002C);
+      LCD_IO_WriteReg(0x002C);
       for (count = 0; count < (HDP + 1) * (VDP + 1); count++)
         LCD_IO_WriteData(Color);
     }
     else {
       tft_set_cursor(0, 0);
       LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
       for (index = 0; index < 76800; index++)
         LCD_IO_WriteData(Color);
     }
   }
@@ -316,50 +316,50 @@ void SysTick_Callback() {
     _delay_ms(5);
 
     DeviceCode = tftio.GetID() & 0xFFFF;
     // Chitu and others
     if (DeviceCode == 0x8066) DeviceCode = 0x9488;
 
     if (DeviceCode == 0x9488) {
       LCD_IO_WriteReg(0x00E0);
       LCD_IO_WriteData(0x0000);
       LCD_IO_WriteData(0x0007);
-      LCD_IO_WriteData(0x000f);
+      LCD_IO_WriteData(0x000F);
       LCD_IO_WriteData(0x000D);
       LCD_IO_WriteData(0x001B);
       LCD_IO_WriteData(0x000A);
-      LCD_IO_WriteData(0x003c);
+      LCD_IO_WriteData(0x003C);
       LCD_IO_WriteData(0x0078);
       LCD_IO_WriteData(0x004A);
       LCD_IO_WriteData(0x0007);
       LCD_IO_WriteData(0x000E);
       LCD_IO_WriteData(0x0009);
       LCD_IO_WriteData(0x001B);
-      LCD_IO_WriteData(0x001e);
-      LCD_IO_WriteData(0x000f);
+      LCD_IO_WriteData(0x001E);
+      LCD_IO_WriteData(0x000F);
 
       LCD_IO_WriteReg(0x00E1);
       LCD_IO_WriteData(0x0000);
       LCD_IO_WriteData(0x0022);
       LCD_IO_WriteData(0x0024);
       LCD_IO_WriteData(0x0006);
       LCD_IO_WriteData(0x0012);
       LCD_IO_WriteData(0x0007);
       LCD_IO_WriteData(0x0036);
       LCD_IO_WriteData(0x0047);
       LCD_IO_WriteData(0x0047);
       LCD_IO_WriteData(0x0006);
-      LCD_IO_WriteData(0x000a);
+      LCD_IO_WriteData(0x000A);
       LCD_IO_WriteData(0x0007);
       LCD_IO_WriteData(0x0030);
       LCD_IO_WriteData(0x0037);
-      LCD_IO_WriteData(0x000f);
+      LCD_IO_WriteData(0x000F);
 
       LCD_IO_WriteReg(0x00C0);
       LCD_IO_WriteData(0x0010);
       LCD_IO_WriteData(0x0010);
 
       LCD_IO_WriteReg(0x00C1);
       LCD_IO_WriteData(0x0041);
 
       LCD_IO_WriteReg(0x00C5);
       LCD_IO_WriteData(0x0000);

commit 6572d7131f61811d3507d0dfb1b76a38c770e95f
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Sun Sep 27 23:22:08 2020 -0300

    LVGL followup fixing "C", etc. (#19517)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
index af292db7d5..c2ff2c4362 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
@@ -401,21 +401,21 @@ void SysTick_Callback() {
 
       LCD_IO_WriteReg(0x0011);
       for (i = 0; i < 65535; i++) { /* do nothing */ }
       LCD_IO_WriteReg(0x0029);
 
       LCD_setWindowArea(0, 0, TFT_WIDTH, TFT_HEIGHT);
 
       OUT_WRITE(LCD_BACKLIGHT_PIN, LOW);
       LCD_Clear(0x0000);
 
-      lcd_draw_logo();
+      TERN_(HAS_LOGO_IN_FLASH, lcd_draw_logo());
 
       OUT_WRITE(LCD_BACKLIGHT_PIN, HIGH);
       delay(2000);
     }
   }
 
   extern void LCD_IO_WriteSequence(uint16_t *data, uint16_t length);
 
   void lcd_draw_logo() {
     LCD_setWindowArea(0, 0, TFT_WIDTH, TFT_HEIGHT);
@@ -717,20 +717,21 @@ uint32_t sd_read_base_addr = 0,sd_read_addr_offset = 0;
 lv_fs_res_t sd_open_cb (lv_fs_drv_t * drv, void * file_p, const char * path, lv_fs_mode_t mode) {
   //cur_namefff = strrchr(path, '/');
   char name_buf[100];
   ZERO(name_buf);
   strcat(name_buf,"/");
   strcat(name_buf,path);
   char *temp = strstr(name_buf,".bin");
   if (temp) { strcpy(temp,".GCO"); }
   sd_read_base_addr = lv_open_gcode_file((char *)name_buf);
   sd_read_addr_offset = sd_read_base_addr;
+  if (sd_read_addr_offset == 0) return LV_FS_RES_NOT_EX;
   return LV_FS_RES_OK;
 }
 
 lv_fs_res_t sd_close_cb (lv_fs_drv_t * drv, void * file_p) {
   /* Add your code here*/
   lv_close_gcode_file();
   return LV_FS_RES_OK;
 }
 
 lv_fs_res_t sd_read_cb (lv_fs_drv_t * drv, void * file_p, void * buf, uint32_t btr, uint32_t * br) {

commit d8ed74904559aa8bdccc8b68acbccfbf1bf779d3
Author: makerbase <4164049@qq.com>
Date:   Mon Sep 21 09:55:02 2020 +0800

    Add MKS Robin E3P, improve LVGL UI (#19442)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
index 23072d27c7..af292db7d5 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
@@ -28,48 +28,53 @@
 #include "../../../../inc/MarlinConfigPre.h"
 
 #if HAS_TFT_LVGL_UI
 
 #if ENABLED(TFT_LVGL_UI_SPI)
   #include "SPI_TFT.h"
 #endif
 
 #include "tft_lvgl_configuration.h"
 #include "draw_ready_print.h"
+
 #include "pic_manager.h"
 #include "mks_hardware_test.h"
 #include "draw_ui.h"
+#include "SPIFlashStorage.h"
 #include <lvgl.h>
 
+#include "../../../../MarlinCore.h"
 #include "../../../../inc/MarlinConfig.h"
 
 #include HAL_PATH(../../HAL, tft/xpt2046.h)
+#include "../../../ultralcd.h"
 XPT2046 touch;
 
 #if ENABLED(POWER_LOSS_RECOVERY)
   #include "../../../../feature/powerloss.h"
 #endif
 
 #include <SPI.h>
 
 #ifndef TFT_WIDTH
   #define TFT_WIDTH  480
 #endif
 #ifndef TFT_HEIGHT
   #define TFT_HEIGHT 320
 #endif
 
 #if HAS_SPI_FLASH_FONT
   extern void init_gb2312_font();
 #endif
 
 static lv_disp_buf_t disp_buf;
+lv_group_t*  g;
 #if ENABLED(SDSUPPORT)
   extern void UpdateAssets();
 #endif
 uint16_t DeviceCode = 0x9488;
 extern uint8_t sel_id;
 
 #define SetCs
 #define ClrCs
 
 #define HDP  799 // Horizontal Display Period
@@ -82,374 +87,449 @@ extern uint8_t sel_id;
 #define VT   530 // Vertical Total
 #define VPS   24 // LFRAME Pulse Start Position
 #define FPS   23 // Vertical Display Period Start Positio
 #define VPW    3 // LFRAME Pulse Width
 
 #define MAX_HZ_POSX HDP+1
 #define MAX_HZ_POSY VDP+1
 
 extern uint8_t gcode_preview_over, flash_preview_begin, default_preview_flg;
 
+uint8_t bmp_public_buf[17 * 1024];
+
 void SysTick_Callback() {
   lv_tick_inc(1);
   print_time_count();
-}
-
-#if DISABLED(TFT_LVGL_UI_SPI)
-
-extern void LCD_IO_Init(uint8_t cs, uint8_t rs);
-extern void LCD_IO_WriteData(uint16_t RegValue);
-extern void LCD_IO_WriteReg(uint16_t Reg);
-
-extern void LCD_IO_WriteMultiple(uint16_t color, uint32_t count);
-void tft_set_cursor(uint16_t x, uint16_t y) {
-  LCD_IO_WriteReg(0x002A);
-  LCD_IO_WriteData(x >> 8);
-  LCD_IO_WriteData(x & 0x00FF);
-  LCD_IO_WriteData(x >> 8);
-  LCD_IO_WriteData(x & 0x00FF);
-  //ILI9488_WriteData(0x01);
-  //ILI9488_WriteData(0xDF);
-  LCD_IO_WriteReg(0x002B);
-  LCD_IO_WriteData(y >> 8);
-  LCD_IO_WriteData(y & 0x00FF);
-  LCD_IO_WriteData(y >> 8);
-  LCD_IO_WriteData(y & 0x00FF);
-  //ILI9488_WriteData(0x01);
-  //ILI9488_WriteData(0x3F);
-}
-
-void LCD_WriteRAM_Prepare(void) {
-  #if 0
-    switch (DeviceCode) {
-      case 0x9325: case 0x9328: case 0x8989: {
-        ClrCs
-        LCD->LCD_REG = R34;
-        SetCs
-      } break;
-      default: LCD_WrtReg(0x002C);
+  #if ENABLED(USE_WIFI_FUNCTION)
+    if (tips_disp.timer == TIPS_TIMER_START) {
+      tips_disp.timer_count++;
     }
-  #else
-    LCD_IO_WriteReg(0x002C);
   #endif
+  if (uiCfg.filament_loading_time_flg == 1) {
+    uiCfg.filament_loading_time_cnt++;
+    uiCfg.filament_rate = (uint32_t)(((uiCfg.filament_loading_time_cnt / (uiCfg.filament_loading_time * 1000.0)) * 100.0) + 0.5);
+    if (uiCfg.filament_loading_time_cnt >= (uiCfg.filament_loading_time * 1000)) {
+      uiCfg.filament_loading_time_cnt  = 0;
+      uiCfg.filament_loading_time_flg  = 0;
+      uiCfg.filament_loading_completed = 1;
+    }
+  }
+  if (uiCfg.filament_unloading_time_flg == 1) {
+    uiCfg.filament_unloading_time_cnt++;
+    uiCfg.filament_rate = (uint32_t)(((uiCfg.filament_unloading_time_cnt / (uiCfg.filament_unloading_time * 1000.0)) * 100.0) + 0.5);
+    if (uiCfg.filament_unloading_time_cnt >= (uiCfg.filament_unloading_time * 1000)) {
+      uiCfg.filament_unloading_time_cnt  = 0;
+      uiCfg.filament_unloading_time_flg  = 0;
+      uiCfg.filament_unloading_completed = 1;
+      uiCfg.filament_rate                = 100;
+    }
+  }
 }
 
-void tft_set_point(uint16_t x, uint16_t y, uint16_t point) {
-  //if (DeviceCode == 0x9488) {
-  if (x > (TFT_WIDTH) || y > (TFT_HEIGHT)) return;
-  //}
-  tft_set_cursor(x, y);
-
-  LCD_WriteRAM_Prepare();
-  //LCD_WriteRAM(point);
-  LCD_IO_WriteData(point);
-}
-
-void LCD_WriteReg(uint16_t LCD_Reg, uint16_t LCD_RegValue) {
-  /* Write 16-bit Index, then Write Reg */
-  ClrCs
-  LCD_IO_WriteReg(LCD_Reg);
-  /* Write 16-bit Reg */
-  LCD_IO_WriteData(LCD_RegValue);
-  SetCs
-}
+#if DISABLED(TFT_LVGL_UI_SPI)
 
-void ili9320_SetWindows(uint16_t StartX, uint16_t StartY, uint16_t width, uint16_t heigh) {
-  uint16_t s_h, s_l, e_h, e_l;
-  uint16_t xEnd, yEnd;
-  xEnd = StartX + width;
-  yEnd = StartY + heigh - 1;
-  if (DeviceCode == 0x8989) {
-    /*LCD_WriteReg(0x0044, (StartX & 0xFF) | (xEnd << 8));
-    LCD_WriteReg(0x0045, StartY);
-    LCD_WriteReg(0x0046, yEnd);*/
-    LCD_WriteReg(0x0044, (StartY & 0xFF) | (yEnd << 8));
-    LCD_WriteReg(0x0045, StartX);
-    LCD_WriteReg(0x0046, xEnd);
-  }
-  else if (DeviceCode == 0x9488) {
-    s_h = (StartX >> 8) & 0x00ff;
-    s_l = StartX & 0x00ff;
-    e_h = ((StartX + width - 1) >> 8) & 0x00ff;
-    e_l = (StartX + width - 1) & 0x00ff;
+  extern void LCD_IO_Init(uint8_t cs, uint8_t rs);
+  extern void LCD_IO_WriteData(uint16_t RegValue);
+  extern void LCD_IO_WriteReg(uint16_t Reg);
 
+  extern void LCD_IO_WriteMultiple(uint16_t color, uint32_t count);
+  void tft_set_cursor(uint16_t x, uint16_t y) {
     LCD_IO_WriteReg(0x002A);
-    LCD_IO_WriteData(s_h);
-    LCD_IO_WriteData(s_l);
-    LCD_IO_WriteData(e_h);
-    LCD_IO_WriteData(e_l);
-
-    s_h = (StartY >> 8) & 0x00ff;
-    s_l = StartY & 0x00ff;
-    e_h = ((StartY + heigh - 1) >> 8) & 0x00ff;
-    e_l = (StartY + heigh - 1) & 0x00ff;
-
+    LCD_IO_WriteData(x >> 8);
+    LCD_IO_WriteData(x & 0x00FF);
+    LCD_IO_WriteData(x >> 8);
+    LCD_IO_WriteData(x & 0x00FF);
+    //ILI9488_WriteData(0x01);
+    //ILI9488_WriteData(0xDF);
     LCD_IO_WriteReg(0x002B);
-    LCD_IO_WriteData(s_h);
-    LCD_IO_WriteData(s_l);
-    LCD_IO_WriteData(e_h);
-    LCD_IO_WriteData(e_l);
+    LCD_IO_WriteData(y >> 8);
+    LCD_IO_WriteData(y & 0x00FF);
+    LCD_IO_WriteData(y >> 8);
+    LCD_IO_WriteData(y & 0x00FF);
+    //ILI9488_WriteData(0x01);
+    //ILI9488_WriteData(0x3F);
   }
-  else if ((DeviceCode == 0x9325) || (DeviceCode == 0x9328) || (DeviceCode == 0x1505)) {
-    /* LCD_WriteReg(0x0050, StartX);
-     LCD_WriteReg(0x0052, StartY);
-     LCD_WriteReg(0x0051, xEnd);
-     LCD_WriteReg(0x0053, yEnd);*/
-    LCD_WriteReg(0x0050, StartY);   // Specify the start/end positions of the window address in the horizontal direction by an address unit
-    LCD_WriteReg(0x0051, yEnd);     // Specify the start positions of the window address in the vertical direction by an address unit
-    LCD_WriteReg(0x0052, (TFT_HEIGHT) - xEnd);
-    LCD_WriteReg(0x0053, (TFT_HEIGHT) - StartX - 1); // Specify the end positions of the window address in the vertical direction by an address unit
 
+  void LCD_WriteRAM_Prepare(void) {
+    #if 0
+      switch (DeviceCode) {
+        case 0x9325: case 0x9328: case 0x8989: {
+          ClrCs
+          LCD->LCD_REG = R34;
+          SetCs
+        } break;
+        default: LCD_WrtReg(0x002C);
+      }
+    #else
+      LCD_IO_WriteReg(0x002C);
+    #endif
   }
-  else {
-    s_h = (StartX >> 8) & 0xFF;
-    s_l = StartX & 0xFF;
-    e_h = ((StartX + width - 1) >> 8) & 0xFF;
-    e_l = (StartX + width - 1) & 0xFF;
-
-    LCD_IO_WriteReg(0x2A);
-    LCD_IO_WriteData(s_h);
-    LCD_IO_WriteData(s_l);
-    LCD_IO_WriteData(e_h);
-    LCD_IO_WriteData(e_l);
-
-    s_h = (StartY >> 8) & 0xFF;
-    s_l = StartY & 0xFF;
-    e_h = ((StartY + heigh - 1) >> 8) & 0xFF;
-    e_l = (StartY + heigh - 1) & 0xFF;
-
-    LCD_IO_WriteReg(0x2B);
-    LCD_IO_WriteData(s_h);
-    LCD_IO_WriteData(s_l);
-    LCD_IO_WriteData(e_h);
-    LCD_IO_WriteData(e_l);
-  }
-}
 
-void LCD_Clear(uint16_t Color) {
-  uint32_t index = 0;
-  unsigned int count;
+  void tft_set_point(uint16_t x, uint16_t y, uint16_t point) {
+    //if (DeviceCode == 0x9488) {
+    if (x > (TFT_WIDTH) || y > (TFT_HEIGHT)) return;
+    //}
+    tft_set_cursor(x, y);
 
-  if (DeviceCode == 0x9488) {
-    tft_set_cursor(0, 0);
-    ili9320_SetWindows(0, 0, TFT_WIDTH, TFT_HEIGHT);
     LCD_WriteRAM_Prepare();
-    #ifdef LCD_USE_DMA_FSMC
-      LCD_IO_WriteMultiple(Color, (TFT_WIDTH) * (TFT_HEIGHT));
-    #else
-      //index = (TFT_HEIGHT) / 2 * (TFT_WIDTH);
-      for (index = 0; index < (TFT_HEIGHT) * (TFT_WIDTH); index++)
-        LCD_IO_WriteData(Color);
-    #endif
-    //LCD_IO_WriteMultiple(Color, (TFT_WIDTH) * (TFT_HEIGHT));
-    //while(index --) LCD_IO_WriteData(Color);
-  }
-  else if (DeviceCode == 0x5761) {
-    LCD_IO_WriteReg(0x002a);
-    LCD_IO_WriteData(0);
-    LCD_IO_WriteData(0);
-    LCD_IO_WriteData(HDP >> 8);
-    LCD_IO_WriteData(HDP & 0x00ff);
-    LCD_IO_WriteReg(0x002b);
-    LCD_IO_WriteData(0);
-    LCD_IO_WriteData(0);
-    LCD_IO_WriteData(VDP >> 8);
-    LCD_IO_WriteData(VDP & 0x00ff);
-    LCD_IO_WriteReg(0x002c);
-    LCD_IO_WriteReg(0x002c);
-    for (count = 0; count < (HDP + 1) * (VDP + 1); count++)
-      LCD_IO_WriteData(Color);
-  }
-  else {
-    tft_set_cursor(0, 0);
-    LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
-    for (index = 0; index < 76800; index++)
-      LCD_IO_WriteData(Color);
+    //LCD_WriteRAM(point);
+    LCD_IO_WriteData(point);
   }
-}
-
-#include HAL_PATH(../../HAL, tft/tft_fsmc.h)
-extern TFT_IO tftio;
-void init_tft() {
-  uint16_t i;
 
-  TERN_(HAS_LCD_CONTRAST, refresh_contrast());
+  void LCD_WriteReg(uint16_t LCD_Reg, uint16_t LCD_RegValue) {
+    /* Write 16-bit Index, then Write Reg */
+    ClrCs
+    LCD_IO_WriteReg(LCD_Reg);
+    /* Write 16-bit Reg */
+    LCD_IO_WriteData(LCD_RegValue);
+    SetCs
+  }
 
-  #ifdef LCD_USE_DMA_FSMC
-    dma_init(FSMC_DMA_DEV);
-    dma_disable(FSMC_DMA_DEV, FSMC_DMA_CHANNEL);
-    dma_set_priority(FSMC_DMA_DEV, FSMC_DMA_CHANNEL, DMA_PRIORITY_MEDIUM);
-  #endif
+  void LCD_setWindowArea(uint16_t StartX, uint16_t StartY, uint16_t width, uint16_t heigh) {
+    uint16_t s_h, s_l, e_h, e_l;
+    uint16_t xEnd, yEnd;
+    xEnd = StartX + width;
+    yEnd = StartY + heigh - 1;
+    if (DeviceCode == 0x8989) {
+      /*LCD_WriteReg(0x0044, (StartX & 0xFF) | (xEnd << 8));
+      LCD_WriteReg(0x0045, StartY);
+      LCD_WriteReg(0x0046, yEnd);*/
+      LCD_WriteReg(0x0044, (StartY & 0xFF) | (yEnd << 8));
+      LCD_WriteReg(0x0045, StartX);
+      LCD_WriteReg(0x0046, xEnd);
+    }
+    else if (DeviceCode == 0x9488) {
+      s_h = (StartX >> 8) & 0x00ff;
+      s_l = StartX & 0x00ff;
+      e_h = ((StartX + width - 1) >> 8) & 0x00ff;
+      e_l = (StartX + width - 1) & 0x00ff;
+
+      LCD_IO_WriteReg(0x002A);
+      LCD_IO_WriteData(s_h);
+      LCD_IO_WriteData(s_l);
+      LCD_IO_WriteData(e_h);
+      LCD_IO_WriteData(e_l);
+
+      s_h = (StartY >> 8) & 0x00ff;
+      s_l = StartY & 0x00ff;
+      e_h = ((StartY + heigh - 1) >> 8) & 0x00ff;
+      e_l = (StartY + heigh - 1) & 0x00ff;
+
+      LCD_IO_WriteReg(0x002B);
+      LCD_IO_WriteData(s_h);
+      LCD_IO_WriteData(s_l);
+      LCD_IO_WriteData(e_h);
+      LCD_IO_WriteData(e_l);
+    }
+    else if ((DeviceCode == 0x9325) || (DeviceCode == 0x9328) || (DeviceCode == 0x1505)) {
+      /* LCD_WriteReg(0x0050, StartX);
+       LCD_WriteReg(0x0052, StartY);
+       LCD_WriteReg(0x0051, xEnd);
+       LCD_WriteReg(0x0053, yEnd);*/
+      LCD_WriteReg(0x0050, StartY);   // Specify the start/end positions of the window address in the horizontal direction by an address unit
+      LCD_WriteReg(0x0051, yEnd);     // Specify the start positions of the window address in the vertical direction by an address unit
+      LCD_WriteReg(0x0052, (TFT_HEIGHT) - xEnd);
+      LCD_WriteReg(0x0053, (TFT_HEIGHT) - StartX - 1); // Specify the end positions of the window address in the vertical direction by an address unit
 
-  LCD_IO_Init(FSMC_CS_PIN, FSMC_RS_PIN);
-
-  _delay_ms(5);
-
-  DeviceCode = tftio.GetID() & 0xFFFF;
-  // Chitu and others
-  if (DeviceCode == 0x8066) DeviceCode = 0x9488;
-
-  if (DeviceCode == 0x9488) {
-    LCD_IO_WriteReg(0x00E0);
-    LCD_IO_WriteData(0x0000);
-    LCD_IO_WriteData(0x0007);
-    LCD_IO_WriteData(0x000f);
-    LCD_IO_WriteData(0x000D);
-    LCD_IO_WriteData(0x001B);
-    LCD_IO_WriteData(0x000A);
-    LCD_IO_WriteData(0x003c);
-    LCD_IO_WriteData(0x0078);
-    LCD_IO_WriteData(0x004A);
-    LCD_IO_WriteData(0x0007);
-    LCD_IO_WriteData(0x000E);
-    LCD_IO_WriteData(0x0009);
-    LCD_IO_WriteData(0x001B);
-    LCD_IO_WriteData(0x001e);
-    LCD_IO_WriteData(0x000f);
-
-    LCD_IO_WriteReg(0x00E1);
-    LCD_IO_WriteData(0x0000);
-    LCD_IO_WriteData(0x0022);
-    LCD_IO_WriteData(0x0024);
-    LCD_IO_WriteData(0x0006);
-    LCD_IO_WriteData(0x0012);
-    LCD_IO_WriteData(0x0007);
-    LCD_IO_WriteData(0x0036);
-    LCD_IO_WriteData(0x0047);
-    LCD_IO_WriteData(0x0047);
-    LCD_IO_WriteData(0x0006);
-    LCD_IO_WriteData(0x000a);
-    LCD_IO_WriteData(0x0007);
-    LCD_IO_WriteData(0x0030);
-    LCD_IO_WriteData(0x0037);
-    LCD_IO_WriteData(0x000f);
-
-    LCD_IO_WriteReg(0x00C0);
-    LCD_IO_WriteData(0x0010);
-    LCD_IO_WriteData(0x0010);
-
-    LCD_IO_WriteReg(0x00C1);
-    LCD_IO_WriteData(0x0041);
-
-    LCD_IO_WriteReg(0x00C5);
-    LCD_IO_WriteData(0x0000);
-    LCD_IO_WriteData(0x0022);
-    LCD_IO_WriteData(0x0080);
-
-    LCD_IO_WriteReg(0x0036);
-    //ILI9488_WriteData(0x0068);
-    //if (gCfgItems.overturn_180 != 0xEE) {
-    LCD_IO_WriteData(0x0068);
-    //}
-    //else {
-    //ILI9488_WriteData(0x00A8);
-    //}
+    }
+    else {
+      s_h = (StartX >> 8) & 0xFF;
+      s_l = StartX & 0xFF;
+      e_h = ((StartX + width - 1) >> 8) & 0xFF;
+      e_l = (StartX + width - 1) & 0xFF;
+
+      LCD_IO_WriteReg(0x2A);
+      LCD_IO_WriteData(s_h);
+      LCD_IO_WriteData(s_l);
+      LCD_IO_WriteData(e_h);
+      LCD_IO_WriteData(e_l);
+
+      s_h = (StartY >> 8) & 0xFF;
+      s_l = StartY & 0xFF;
+      e_h = ((StartY + heigh - 1) >> 8) & 0xFF;
+      e_l = (StartY + heigh - 1) & 0xFF;
+
+      LCD_IO_WriteReg(0x2B);
+      LCD_IO_WriteData(s_h);
+      LCD_IO_WriteData(s_l);
+      LCD_IO_WriteData(e_h);
+      LCD_IO_WriteData(e_l);
+    }
+  }
 
-    LCD_IO_WriteReg(0x003A); //Interface Mode Control
-    LCD_IO_WriteData(0x0055);
+  void LCD_Clear(uint16_t Color) {
+    uint32_t index = 0;
+    unsigned int count;
 
-    LCD_IO_WriteReg(0x00B0);  //Interface Mode Control
-    LCD_IO_WriteData(0x0000);
-    LCD_IO_WriteReg(0x00B1);   //Frame rate 70HZ
-    LCD_IO_WriteData(0x00B0);
-    LCD_IO_WriteData(0x0011);
-    LCD_IO_WriteReg(0x00B4);
-    LCD_IO_WriteData(0x0002);
-    LCD_IO_WriteReg(0x00B6); //RGB/MCU Interface Control
-    LCD_IO_WriteData(0x0002);
-    LCD_IO_WriteData(0x0042);
+    if (DeviceCode == 0x9488) {
+      tft_set_cursor(0, 0);
+      LCD_setWindowArea(0, 0, TFT_WIDTH, TFT_HEIGHT);
+      LCD_WriteRAM_Prepare();
+      #ifdef LCD_USE_DMA_FSMC
+        LCD_IO_WriteMultiple(Color, (TFT_WIDTH) * (TFT_HEIGHT));
+      #else
+        //index = (TFT_HEIGHT) / 2 * (TFT_WIDTH);
+        for (index = 0; index < (TFT_HEIGHT) * (TFT_WIDTH); index++)
+          LCD_IO_WriteData(Color);
+      #endif
+      //LCD_IO_WriteMultiple(Color, (TFT_WIDTH) * (TFT_HEIGHT));
+      //while(index --) LCD_IO_WriteData(Color);
+    }
+    else if (DeviceCode == 0x5761) {
+      LCD_IO_WriteReg(0x002a);
+      LCD_IO_WriteData(0);
+      LCD_IO_WriteData(0);
+      LCD_IO_WriteData(HDP >> 8);
+      LCD_IO_WriteData(HDP & 0x00ff);
+      LCD_IO_WriteReg(0x002b);
+      LCD_IO_WriteData(0);
+      LCD_IO_WriteData(0);
+      LCD_IO_WriteData(VDP >> 8);
+      LCD_IO_WriteData(VDP & 0x00ff);
+      LCD_IO_WriteReg(0x002c);
+      LCD_IO_WriteReg(0x002c);
+      for (count = 0; count < (HDP + 1) * (VDP + 1); count++)
+        LCD_IO_WriteData(Color);
+    }
+    else {
+      tft_set_cursor(0, 0);
+      LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
+      for (index = 0; index < 76800; index++)
+        LCD_IO_WriteData(Color);
+    }
+  }
 
-    LCD_IO_WriteReg(0x00B7);
-    LCD_IO_WriteData(0x00C6);
+  #include HAL_PATH(../../HAL, tft/tft_fsmc.h)
+  extern TFT_IO tftio;
+  void fsmc_tft_init() {
+    uint16_t i;
 
-    //WriteComm(0xBE);
-    //WriteData(0x00);
-    //WriteData(0x04);
+    TERN_(HAS_LCD_CONTRAST, refresh_contrast());
 
-    LCD_IO_WriteReg(0x00E9);
-    LCD_IO_WriteData(0x0000);
+    #ifdef LCD_USE_DMA_FSMC
+      dma_init(FSMC_DMA_DEV);
+      dma_disable(FSMC_DMA_DEV, FSMC_DMA_CHANNEL);
+      dma_set_priority(FSMC_DMA_DEV, FSMC_DMA_CHANNEL, DMA_PRIORITY_MEDIUM);
+    #endif
 
-    LCD_IO_WriteReg(0x00F7);
-    LCD_IO_WriteData(0x00A9);
-    LCD_IO_WriteData(0x0051);
-    LCD_IO_WriteData(0x002C);
-    LCD_IO_WriteData(0x0082);
+    LCD_IO_Init(FSMC_CS_PIN, FSMC_RS_PIN);
+
+    _delay_ms(5);
+
+    DeviceCode = tftio.GetID() & 0xFFFF;
+    // Chitu and others
+    if (DeviceCode == 0x8066) DeviceCode = 0x9488;
+
+    if (DeviceCode == 0x9488) {
+      LCD_IO_WriteReg(0x00E0);
+      LCD_IO_WriteData(0x0000);
+      LCD_IO_WriteData(0x0007);
+      LCD_IO_WriteData(0x000f);
+      LCD_IO_WriteData(0x000D);
+      LCD_IO_WriteData(0x001B);
+      LCD_IO_WriteData(0x000A);
+      LCD_IO_WriteData(0x003c);
+      LCD_IO_WriteData(0x0078);
+      LCD_IO_WriteData(0x004A);
+      LCD_IO_WriteData(0x0007);
+      LCD_IO_WriteData(0x000E);
+      LCD_IO_WriteData(0x0009);
+      LCD_IO_WriteData(0x001B);
+      LCD_IO_WriteData(0x001e);
+      LCD_IO_WriteData(0x000f);
+
+      LCD_IO_WriteReg(0x00E1);
+      LCD_IO_WriteData(0x0000);
+      LCD_IO_WriteData(0x0022);
+      LCD_IO_WriteData(0x0024);
+      LCD_IO_WriteData(0x0006);
+      LCD_IO_WriteData(0x0012);
+      LCD_IO_WriteData(0x0007);
+      LCD_IO_WriteData(0x0036);
+      LCD_IO_WriteData(0x0047);
+      LCD_IO_WriteData(0x0047);
+      LCD_IO_WriteData(0x0006);
+      LCD_IO_WriteData(0x000a);
+      LCD_IO_WriteData(0x0007);
+      LCD_IO_WriteData(0x0030);
+      LCD_IO_WriteData(0x0037);
+      LCD_IO_WriteData(0x000f);
+
+      LCD_IO_WriteReg(0x00C0);
+      LCD_IO_WriteData(0x0010);
+      LCD_IO_WriteData(0x0010);
+
+      LCD_IO_WriteReg(0x00C1);
+      LCD_IO_WriteData(0x0041);
+
+      LCD_IO_WriteReg(0x00C5);
+      LCD_IO_WriteData(0x0000);
+      LCD_IO_WriteData(0x0022);
+      LCD_IO_WriteData(0x0080);
+
+      LCD_IO_WriteReg(0x0036);
+      LCD_IO_WriteData(TERN(GRAPHICAL_TFT_ROTATE_180, 0xE8, 0x0068));
+
+      LCD_IO_WriteReg(0x003A); //Interface Mode Control
+      LCD_IO_WriteData(0x0055);
+
+      LCD_IO_WriteReg(0x00B0);  //Interface Mode Control
+      LCD_IO_WriteData(0x0000);
+      LCD_IO_WriteReg(0x00B1);   //Frame rate 70HZ
+      LCD_IO_WriteData(0x00B0);
+      LCD_IO_WriteData(0x0011);
+      LCD_IO_WriteReg(0x00B4);
+      LCD_IO_WriteData(0x0002);
+      LCD_IO_WriteReg(0x00B6); //RGB/MCU Interface Control
+      LCD_IO_WriteData(0x0002);
+      LCD_IO_WriteData(0x0042);
+
+      LCD_IO_WriteReg(0x00B7);
+      LCD_IO_WriteData(0x00C6);
+
+      //WriteComm(0xBE);
+      //WriteData(0x00);
+      //WriteData(0x04);
+
+      LCD_IO_WriteReg(0x00E9);
+      LCD_IO_WriteData(0x0000);
+
+      LCD_IO_WriteReg(0x00F7);
+      LCD_IO_WriteData(0x00A9);
+      LCD_IO_WriteData(0x0051);
+      LCD_IO_WriteData(0x002C);
+      LCD_IO_WriteData(0x0082);
+
+      LCD_IO_WriteReg(0x0011);
+      for (i = 0; i < 65535; i++) { /* do nothing */ }
+      LCD_IO_WriteReg(0x0029);
+
+      LCD_setWindowArea(0, 0, TFT_WIDTH, TFT_HEIGHT);
+
+      OUT_WRITE(LCD_BACKLIGHT_PIN, LOW);
+      LCD_Clear(0x0000);
+
+      lcd_draw_logo();
+
+      OUT_WRITE(LCD_BACKLIGHT_PIN, HIGH);
+      delay(2000);
+    }
+  }
 
-    LCD_IO_WriteReg(0x0011);
-    for (i = 0; i < 65535; i++);
-    LCD_IO_WriteReg(0x0029);
+  extern void LCD_IO_WriteSequence(uint16_t *data, uint16_t length);
 
-    ili9320_SetWindows(0, 0, TFT_WIDTH, TFT_HEIGHT);
-    LCD_Clear(0x0000);
+  void lcd_draw_logo() {
+    LCD_setWindowArea(0, 0, TFT_WIDTH, TFT_HEIGHT);
+    LCD_WriteRAM_Prepare();
 
-    OUT_WRITE(LCD_BACKLIGHT_PIN, HIGH);
+    for (uint16_t i = 0; i < (TFT_HEIGHT); i ++) {
+      Pic_Logo_Read((uint8_t *)"", (uint8_t *)bmp_public_buf, (TFT_WIDTH) * 2);
+      #ifdef LCD_USE_DMA_FSMC
+        LCD_IO_WriteSequence((uint16_t *)bmp_public_buf, TFT_WIDTH);
+      #else
+        int index = 0;,x_off = 0;
+        for (x_off = 0; x_off < TFT_WIDTH; x_off++) {
+          LCD_IO_WriteData((uint16_t)bmp_public_buf[index]);
+          index += 2;
+        }
+      #endif
+    }
   }
-}
 
 #endif // !TFT_LVGL_UI_SPI
 
-extern uint8_t bmp_public_buf[17 * 1024];
-
 void tft_lvgl_init() {
 
   //uint16_t test_id=0;
   W25QXX.init(SPI_QUARTER_SPEED);
   //test_id=W25QXX.W25QXX_ReadID();
 
   gCfgItems_init();
   ui_cfg_init();
   disp_language_init();
 
   //init tft first!
   #if ENABLED(TFT_LVGL_UI_SPI)
     SPI_TFT.spi_init(SPI_FULL_SPEED);
     SPI_TFT.LCD_init();
   #else
-    init_tft();
+    fsmc_tft_init();
   #endif
 
+  //spi_flash_read_test();
   #if ENABLED(SDSUPPORT)
     UpdateAssets();
   #endif
   mks_test_get();
 
-  //spi_flash_read_test();
-
   touch.Init();
 
   lv_init();
 
   lv_disp_buf_init(&disp_buf, bmp_public_buf, NULL, LV_HOR_RES_MAX * 18); /*Initialize the display buffer*/
 
   lv_disp_drv_t disp_drv;     /*Descriptor of a display driver*/
   lv_disp_drv_init(&disp_drv);    /*Basic initialization*/
   disp_drv.flush_cb = my_disp_flush; /*Set your driver function*/
   disp_drv.buffer = &disp_buf;    /*Assign the buffer to the display*/
   lv_disp_drv_register(&disp_drv);  /*Finally register the driver*/
 
   lv_indev_drv_t indev_drv;
   lv_indev_drv_init(&indev_drv);     /*Descriptor of a input device driver*/
   indev_drv.type = LV_INDEV_TYPE_POINTER; /*Touch pad is a pointer-like device*/
   indev_drv.read_cb = my_touchpad_read;  /*Set your driver function*/
   lv_indev_drv_register(&indev_drv);   /*Finally register the driver*/
 
+  #if HAS_ROTARY_ENCODER
+    g = lv_group_create();
+    lv_indev_drv_t enc_drv;
+    lv_indev_drv_init(&enc_drv);
+    enc_drv.type = LV_INDEV_TYPE_ENCODER;
+    enc_drv.read_cb = my_mousewheel_read;
+    lv_indev_t * enc_indev = lv_indev_drv_register(&enc_drv);
+    lv_indev_set_group(enc_indev, g);
+  #endif
+
+  lv_fs_drv_t spi_flash_drv;
+  lv_fs_drv_init(&spi_flash_drv);
+  spi_flash_drv.letter = 'F';
+  spi_flash_drv.open_cb = spi_flash_open_cb;
+  spi_flash_drv.close_cb = spi_flash_close_cb;
+  spi_flash_drv.read_cb = spi_flash_read_cb;
+  spi_flash_drv.seek_cb = spi_flash_seek_cb;
+  spi_flash_drv.tell_cb = spi_flash_tell_cb;
+  lv_fs_drv_register(&spi_flash_drv);
+
+  lv_fs_drv_t sd_drv;
+  lv_fs_drv_init(&sd_drv);
+  sd_drv.letter = 'S';
+  sd_drv.open_cb = sd_open_cb;
+  sd_drv.close_cb = sd_close_cb;
+  sd_drv.read_cb = sd_read_cb;
+  sd_drv.seek_cb = sd_seek_cb;
+  sd_drv.tell_cb = sd_tell_cb;
+  lv_fs_drv_register(&sd_drv);
+
   systick_attach_callback(SysTick_Callback);
 
   #if HAS_SPI_FLASH_FONT
     init_gb2312_font();
   #endif
 
   tft_style_init();
 
   filament_pin_setup();
 
+  lv_encoder_pin_init();
+
   #if ENABLED(POWER_LOSS_RECOVERY)
+    recovery.load();
     if (recovery.valid()) {
       if (gCfgItems.from_flash_pic == 1)
         flash_preview_begin = 1;
       else
         default_preview_flg = 1;
 
       uiCfg.print_state = REPRINTING;
 
       ZERO(public_buf_m);
       strncpy(public_buf_m, recovery.info.sd_filename, sizeof(public_buf_m));
@@ -479,86 +559,320 @@ void my_disp_flush(lv_disp_drv_t * disp, const lv_area_t * area, lv_color_t * co
       SPI_TFT.tftio.WriteSequence((uint16_t*)(color_p + width * i), width);
     }
     lv_disp_flush_ready(disp);       /* Indicate you are ready with the flushing*/
 
     W25QXX.init(SPI_QUARTER_SPEED);
 
   #else // !TFT_LVGL_UI_SPI
 
     #if 1
       uint16_t i, width, height;
-      uint16_t clr_temp;
+      //uint16_t clr_temp;
       width = area->x2 - area->x1 + 1;
       height = area->y2 - area->y1 + 1;
-      ili9320_SetWindows((uint16_t)area->x1, (uint16_t)area->y1, width, height);
+      LCD_setWindowArea((uint16_t)area->x1, (uint16_t)area->y1, width, height);
       LCD_WriteRAM_Prepare();
       for (i = 0; i < width * height - 2; i++) {
-        clr_temp = (uint16_t)(((uint16_t)color_p->ch.red << 11)
-                              | ((uint16_t)color_p->ch.green << 5)
-                              | ((uint16_t)color_p->ch.blue));
-        LCD_IO_WriteData(clr_temp);
+        //clr_temp = (uint16_t)(((uint16_t)color_p->ch.red << 11)
+                              //| ((uint16_t)color_p->ch.green << 5)
+                              //| ((uint16_t)color_p->ch.blue));
+        LCD_IO_WriteData(color_p->full);
         color_p++;
       }
 
       lv_disp_flush_ready(disp);       /* Indicate you are ready with the flushing*/
     #endif
 
   #endif // !TFT_LVGL_UI_SPI
 }
 
 #define TICK_CYCLE 1
 
-static int32_t touch_time1 = 0;
-
 unsigned int getTickDiff(unsigned int curTick, unsigned int lastTick) {
   return TICK_CYCLE * (lastTick <= curTick ? (curTick - lastTick) : (0xFFFFFFFF - lastTick + curTick));
 }
 
 static bool get_point(int16_t *x, int16_t *y) {
   bool is_touched = touch.getRawPoint(x, y);
 
   if (is_touched) {
     *x = int16_t((int32_t(*x) * XPT2046_X_CALIBRATION) >> 16) + XPT2046_X_OFFSET;
     *y = int16_t((int32_t(*y) * XPT2046_Y_CALIBRATION) >> 16) + XPT2046_Y_OFFSET;
   }
 
   #if ENABLED(GRAPHICAL_TFT_ROTATE_180)
-    x = (TFT_WIDTH) - x;
-    y = (TFT_HEIGHT) - y;
+    *x = int16_t((TFT_WIDTH) - (int)(*x));
+    *y = int16_t((TFT_HEIGHT) - (int)(*y));
   #endif
 
   return is_touched;
 }
 
-static int16_t last_x = 0, last_y = 0;
 bool my_touchpad_read(lv_indev_drv_t * indev_driver, lv_indev_data_t * data) {
+  static int16_t last_x = 0, last_y = 0;
+  static uint8_t last_touch_state = LV_INDEV_STATE_REL;
+  static int32_t touch_time1 = 0;
   uint32_t tmpTime, diffTime = 0;
 
   tmpTime = millis();
   diffTime = getTickDiff(tmpTime, touch_time1);
   /*Save the state and save the pressed coordinate*/
   //data->state = TOUCH_PressValid(last_x, last_y) ? LV_INDEV_STATE_PR : LV_INDEV_STATE_REL;
   //if (data->state == LV_INDEV_STATE_PR)  ADS7843_Rd_Addata((u16 *)&last_x, (u16 *)&last_y);
   //touchpad_get_xy(&last_x, &last_y);
   /*Save the pressed coordinates and the state*/
-  if (diffTime > 10) {
+  if (diffTime > 20) {
     if (get_point(&last_x, &last_y)) {
 
+      if (last_touch_state == LV_INDEV_STATE_PR) return false;
       data->state = LV_INDEV_STATE_PR;
 
       // Set the coordinates (if released use the last-pressed coordinates)
 
       data->point.x = last_x;
       data->point.y = last_y;
 
       last_x = last_y = 0;
+      last_touch_state = LV_INDEV_STATE_PR;
+    }
+    else {
+      if (last_touch_state == LV_INDEV_STATE_PR)
+        data->state = LV_INDEV_STATE_REL;
+      last_touch_state = LV_INDEV_STATE_REL;
     }
-    else
-      data->state = LV_INDEV_STATE_REL;
 
     touch_time1 = tmpTime;
   }
 
   return false; // Return `false` since no data is buffering or left to read
 }
 
+int16_t enc_diff = 0;
+lv_indev_state_t state = LV_INDEV_STATE_REL;
+
+bool my_mousewheel_read(lv_indev_drv_t * indev_drv, lv_indev_data_t * data) {
+  (void) indev_drv;   /*Unused*/
+
+  data->state = state;
+  data->enc_diff = enc_diff;
+  enc_diff = 0;
+
+  return false;       /*No more data to read so return false*/
+}
+
+extern uint8_t currentFlashPage;
+
+//spi_flash
+uint32_t pic_read_base_addr = 0, pic_read_addr_offset = 0;
+lv_fs_res_t spi_flash_open_cb (lv_fs_drv_t * drv, void * file_p, const char * path, lv_fs_mode_t mode) {
+  static char last_path_name[30];
+  if (strcasecmp(last_path_name,path) != 0) {
+    pic_read_base_addr = lv_get_pic_addr((uint8_t *)path);
+    ZERO(last_path_name);
+    strcpy(last_path_name,path);
+  }
+  else {
+    W25QXX.init(SPI_QUARTER_SPEED);
+    currentFlashPage = 0;
+  }
+  pic_read_addr_offset = pic_read_base_addr;
+  return LV_FS_RES_OK;
+}
+
+lv_fs_res_t spi_flash_close_cb (lv_fs_drv_t * drv, void * file_p) {
+  lv_fs_res_t res = LV_FS_RES_OK;
+  /* Add your code here*/
+  pic_read_addr_offset = pic_read_base_addr;
+  return res;
+}
+
+lv_fs_res_t spi_flash_read_cb (lv_fs_drv_t * drv, void * file_p, void * buf, uint32_t btr, uint32_t * br) {
+  lv_pic_test((uint8_t *)buf, pic_read_addr_offset, btr);
+  *br = btr;
+  return LV_FS_RES_OK;
+}
+
+lv_fs_res_t spi_flash_seek_cb(lv_fs_drv_t * drv, void * file_p, uint32_t pos) {
+  #if HAS_SPI_FLASH_COMPRESSION
+    if (pos == 4) {
+      uint8_t bmp_header[4];
+      SPIFlash.beginRead(pic_read_base_addr);
+      SPIFlash.readData(bmp_header, 4);
+      currentFlashPage = 1;
+    }
+    pic_read_addr_offset = pic_read_base_addr;
+  #else
+    pic_read_addr_offset = pic_read_base_addr + pos;
+  #endif
+  return LV_FS_RES_OK;
+}
+
+lv_fs_res_t spi_flash_tell_cb(lv_fs_drv_t * drv, void * file_p, uint32_t * pos_p) {
+  *pos_p = pic_read_addr_offset - pic_read_base_addr;
+  return LV_FS_RES_OK;
+}
+
+//sd
+char *cur_namefff;
+uint32_t sd_read_base_addr = 0,sd_read_addr_offset = 0;
+lv_fs_res_t sd_open_cb (lv_fs_drv_t * drv, void * file_p, const char * path, lv_fs_mode_t mode) {
+  //cur_namefff = strrchr(path, '/');
+  char name_buf[100];
+  ZERO(name_buf);
+  strcat(name_buf,"/");
+  strcat(name_buf,path);
+  char *temp = strstr(name_buf,".bin");
+  if (temp) { strcpy(temp,".GCO"); }
+  sd_read_base_addr = lv_open_gcode_file((char *)name_buf);
+  sd_read_addr_offset = sd_read_base_addr;
+  return LV_FS_RES_OK;
+}
+
+lv_fs_res_t sd_close_cb (lv_fs_drv_t * drv, void * file_p) {
+  /* Add your code here*/
+  lv_close_gcode_file();
+  return LV_FS_RES_OK;
+}
+
+lv_fs_res_t sd_read_cb (lv_fs_drv_t * drv, void * file_p, void * buf, uint32_t btr, uint32_t * br) {
+  if (btr == 200) {
+    lv_gcode_file_read((uint8_t *)buf);
+    //pic_read_addr_offset += 208;
+    *br = 200;
+  }
+  else if (btr == 4) {
+    uint8_t header_pic[4] = { 0x04, 0x90, 0x81, 0x0C };
+    memcpy(buf, header_pic, 4);
+    //pic_read_addr_offset += 4;
+    *br = 4;
+  }
+  return LV_FS_RES_OK;
+}
+
+lv_fs_res_t sd_seek_cb(lv_fs_drv_t * drv, void * file_p, uint32_t pos) {
+  sd_read_addr_offset = sd_read_base_addr + (pos - 4) / 200 * 409;
+  lv_gcode_file_seek(sd_read_addr_offset);
+  return LV_FS_RES_OK;
+}
+
+lv_fs_res_t sd_tell_cb(lv_fs_drv_t * drv, void * file_p, uint32_t * pos_p) {
+  if (sd_read_addr_offset) *pos_p = 0;
+  else *pos_p = (sd_read_addr_offset - sd_read_base_addr) / 409 * 200 + 4;
+  return LV_FS_RES_OK;
+}
+
+void lv_encoder_pin_init() {
+  #if 1 // HAS_DIGITAL_BUTTONS
+
+    #if BUTTON_EXISTS(EN1)
+      SET_INPUT_PULLUP(BTN_EN1);
+    #endif
+    #if BUTTON_EXISTS(EN2)
+      SET_INPUT_PULLUP(BTN_EN2);
+    #endif
+    #if BUTTON_EXISTS(ENC)
+      SET_INPUT_PULLUP(BTN_ENC);
+    #endif
+
+    #if BUTTON_EXISTS(BACK)
+      SET_INPUT_PULLUP(BTN_BACK);
+    #endif
+
+    #if BUTTON_EXISTS(UP)
+      SET_INPUT(BTN_UP);
+    #endif
+    #if BUTTON_EXISTS(DWN)
+      SET_INPUT(BTN_DWN);
+    #endif
+    #if BUTTON_EXISTS(LFT)
+      SET_INPUT(BTN_LFT);
+    #endif
+    #if BUTTON_EXISTS(RT)
+      SET_INPUT(BTN_RT);
+    #endif
+
+  #endif // HAS_DIGITAL_BUTTONS
+}
+
+#if 1 // HAS_ENCODER_ACTION
+
+  //static const int8_t encoderDirection = 1;
+  //static int16_t enc_Direction;
+  void lv_update_encoder() {
+    static uint8_t buttons;
+    static uint32_t encoder_time1;
+    uint32_t tmpTime, diffTime = 0;
+    tmpTime = millis();
+    diffTime = getTickDiff(tmpTime, encoder_time1);
+    if (diffTime > 50) {
+
+      #if ANY_BUTTON(EN1, EN2, ENC, BACK)
+
+        uint8_t newbutton = 0;
+
+        #if BUTTON_EXISTS(EN1)
+          if (BUTTON_PRESSED(EN1)) newbutton |= EN_A;
+        #endif
+        #if BUTTON_EXISTS(EN2)
+          if (BUTTON_PRESSED(EN2)) newbutton |= EN_B;
+        #endif
+        #if BUTTON_EXISTS(ENC)
+          if (BUTTON_PRESSED(ENC)) newbutton |= EN_C;
+        #endif
+        #if BUTTON_EXISTS(BACK)
+          if (BUTTON_PRESSED(BACK)) newbutton |= EN_D;
+        #endif
+
+      #else
+
+        constexpr uint8_t newbutton = 0;
+
+      #endif
+
+      buttons = newbutton;
+
+      #if HAS_ENCODER_WHEEL
+        static uint8_t lastEncoderBits;
+
+        #define encrot0 0
+        #define encrot1 1
+        #define encrot2 2
+
+        // Manage encoder rotation
+        //#define ENCODER_SPIN(_E1, _E2) switch (lastEncoderBits) { case _E1: enc_Direction += encoderDirection; break; case _E2: enc_Direction -= encoderDirection; }
+
+        uint8_t enc = 0;
+        if (buttons & EN_A) enc |= B01;
+        if (buttons & EN_B) enc |= B10;
+        if (enc != lastEncoderBits) {
+          switch (enc) {
+            case encrot1:
+              if (lastEncoderBits == encrot0) {
+                enc_diff--;
+                encoder_time1 = tmpTime;
+              }
+              break;
+            case encrot2:
+              if (lastEncoderBits == encrot0) {
+                enc_diff++;
+                encoder_time1 = tmpTime;
+              }
+              break;
+          }
+          lastEncoderBits = enc;
+        }
+        static uint8_t last_button_state = LV_INDEV_STATE_REL;
+        const uint8_t enc_c = (buttons & EN_C) ? LV_INDEV_STATE_PR : LV_INDEV_STATE_REL;
+        if (enc_c != last_button_state) {
+          state = enc_c ? LV_INDEV_STATE_PR : LV_INDEV_STATE_REL;
+
+          last_button_state = enc_c;
+        }
+
+      #endif // HAS_ENCODER_WHEEL
+
+    } // next_button_update_ms
+  }
+
+#endif // HAS_ENCODER_ACTION
+
 #endif // HAS_TFT_LVGL_UI

commit a37cf2490054ece3c16f0caca26a02c3d33057c8
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Fri Aug 21 20:54:21 2020 -0300

    Emulated DOGM via HAL TFT, XPT IO (#19017)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
index 391e12ba3f..23072d27c7 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
@@ -44,25 +44,25 @@
 
 #include HAL_PATH(../../HAL, tft/xpt2046.h)
 XPT2046 touch;
 
 #if ENABLED(POWER_LOSS_RECOVERY)
   #include "../../../../feature/powerloss.h"
 #endif
 
 #include <SPI.h>
 
-#ifndef LCD_FULL_PIXEL_WIDTH
-  #define LCD_FULL_PIXEL_WIDTH  480
+#ifndef TFT_WIDTH
+  #define TFT_WIDTH  480
 #endif
-#ifndef LCD_FULL_PIXEL_HEIGHT
-  #define LCD_FULL_PIXEL_HEIGHT 320
+#ifndef TFT_HEIGHT
+  #define TFT_HEIGHT 320
 #endif
 
 #if HAS_SPI_FLASH_FONT
   extern void init_gb2312_font();
 #endif
 
 static lv_disp_buf_t disp_buf;
 #if ENABLED(SDSUPPORT)
   extern void UpdateAssets();
 #endif
@@ -128,21 +128,21 @@ void LCD_WriteRAM_Prepare(void) {
       } break;
       default: LCD_WrtReg(0x002C);
     }
   #else
     LCD_IO_WriteReg(0x002C);
   #endif
 }
 
 void tft_set_point(uint16_t x, uint16_t y, uint16_t point) {
   //if (DeviceCode == 0x9488) {
-  if (x > (LCD_FULL_PIXEL_WIDTH) || y > (LCD_FULL_PIXEL_HEIGHT)) return;
+  if (x > (TFT_WIDTH) || y > (TFT_HEIGHT)) return;
   //}
   tft_set_cursor(x, y);
 
   LCD_WriteRAM_Prepare();
   //LCD_WriteRAM(point);
   LCD_IO_WriteData(point);
 }
 
 void LCD_WriteReg(uint16_t LCD_Reg, uint16_t LCD_RegValue) {
   /* Write 16-bit Index, then Write Reg */
@@ -189,22 +189,22 @@ void ili9320_SetWindows(uint16_t StartX, uint16_t StartY, uint16_t width, uint16
     LCD_IO_WriteData(e_h);
     LCD_IO_WriteData(e_l);
   }
   else if ((DeviceCode == 0x9325) || (DeviceCode == 0x9328) || (DeviceCode == 0x1505)) {
     /* LCD_WriteReg(0x0050, StartX);
      LCD_WriteReg(0x0052, StartY);
      LCD_WriteReg(0x0051, xEnd);
      LCD_WriteReg(0x0053, yEnd);*/
     LCD_WriteReg(0x0050, StartY);   // Specify the start/end positions of the window address in the horizontal direction by an address unit
     LCD_WriteReg(0x0051, yEnd);     // Specify the start positions of the window address in the vertical direction by an address unit
-    LCD_WriteReg(0x0052, (LCD_FULL_PIXEL_HEIGHT) - xEnd);
-    LCD_WriteReg(0x0053, (LCD_FULL_PIXEL_HEIGHT) - StartX - 1); // Specify the end positions of the window address in the vertical direction by an address unit
+    LCD_WriteReg(0x0052, (TFT_HEIGHT) - xEnd);
+    LCD_WriteReg(0x0053, (TFT_HEIGHT) - StartX - 1); // Specify the end positions of the window address in the vertical direction by an address unit
 
   }
   else {
     s_h = (StartX >> 8) & 0xFF;
     s_l = StartX & 0xFF;
     e_h = ((StartX + width - 1) >> 8) & 0xFF;
     e_l = (StartX + width - 1) & 0xFF;
 
     LCD_IO_WriteReg(0x2A);
     LCD_IO_WriteData(s_h);
@@ -224,30 +224,30 @@ void ili9320_SetWindows(uint16_t StartX, uint16_t StartY, uint16_t width, uint16
     LCD_IO_WriteData(e_l);
   }
 }
 
 void LCD_Clear(uint16_t Color) {
   uint32_t index = 0;
   unsigned int count;
 
   if (DeviceCode == 0x9488) {
     tft_set_cursor(0, 0);
-    ili9320_SetWindows(0, 0, LCD_FULL_PIXEL_WIDTH, LCD_FULL_PIXEL_HEIGHT);
+    ili9320_SetWindows(0, 0, TFT_WIDTH, TFT_HEIGHT);
     LCD_WriteRAM_Prepare();
     #ifdef LCD_USE_DMA_FSMC
-      LCD_IO_WriteMultiple(Color, (LCD_FULL_PIXEL_WIDTH) * (LCD_FULL_PIXEL_HEIGHT));
+      LCD_IO_WriteMultiple(Color, (TFT_WIDTH) * (TFT_HEIGHT));
     #else
-      //index = (LCD_FULL_PIXEL_HEIGHT) / 2 * (LCD_FULL_PIXEL_WIDTH);
-      for (index = 0; index < (LCD_FULL_PIXEL_HEIGHT) * (LCD_FULL_PIXEL_WIDTH); index++)
+      //index = (TFT_HEIGHT) / 2 * (TFT_WIDTH);
+      for (index = 0; index < (TFT_HEIGHT) * (TFT_WIDTH); index++)
         LCD_IO_WriteData(Color);
     #endif
-    //LCD_IO_WriteMultiple(Color, (LCD_FULL_PIXEL_WIDTH) * (LCD_FULL_PIXEL_HEIGHT));
+    //LCD_IO_WriteMultiple(Color, (TFT_WIDTH) * (TFT_HEIGHT));
     //while(index --) LCD_IO_WriteData(Color);
   }
   else if (DeviceCode == 0x5761) {
     LCD_IO_WriteReg(0x002a);
     LCD_IO_WriteData(0);
     LCD_IO_WriteData(0);
     LCD_IO_WriteData(HDP >> 8);
     LCD_IO_WriteData(HDP & 0x00ff);
     LCD_IO_WriteReg(0x002b);
     LCD_IO_WriteData(0);
@@ -371,21 +371,21 @@ void init_tft() {
     LCD_IO_WriteReg(0x00F7);
     LCD_IO_WriteData(0x00A9);
     LCD_IO_WriteData(0x0051);
     LCD_IO_WriteData(0x002C);
     LCD_IO_WriteData(0x0082);
 
     LCD_IO_WriteReg(0x0011);
     for (i = 0; i < 65535; i++);
     LCD_IO_WriteReg(0x0029);
 
-    ili9320_SetWindows(0, 0, LCD_FULL_PIXEL_WIDTH, LCD_FULL_PIXEL_HEIGHT);
+    ili9320_SetWindows(0, 0, TFT_WIDTH, TFT_HEIGHT);
     LCD_Clear(0x0000);
 
     OUT_WRITE(LCD_BACKLIGHT_PIN, HIGH);
   }
 }
 
 #endif // !TFT_LVGL_UI_SPI
 
 extern uint8_t bmp_public_buf[17 * 1024];
 
@@ -515,22 +515,22 @@ unsigned int getTickDiff(unsigned int curTick, unsigned int lastTick) {
 
 static bool get_point(int16_t *x, int16_t *y) {
   bool is_touched = touch.getRawPoint(x, y);
 
   if (is_touched) {
     *x = int16_t((int32_t(*x) * XPT2046_X_CALIBRATION) >> 16) + XPT2046_X_OFFSET;
     *y = int16_t((int32_t(*y) * XPT2046_Y_CALIBRATION) >> 16) + XPT2046_Y_OFFSET;
   }
 
   #if ENABLED(GRAPHICAL_TFT_ROTATE_180)
-    x = (LCD_FULL_PIXEL_WIDTH) - x;
-    y = (LCD_FULL_PIXEL_HEIGHT) - y;
+    x = (TFT_WIDTH) - x;
+    y = (TFT_HEIGHT) - y;
   #endif
 
   return is_touched;
 }
 
 static int16_t last_x = 0, last_y = 0;
 bool my_touchpad_read(lv_indev_drv_t * indev_driver, lv_indev_data_t * data) {
   uint32_t tmpTime, diffTime = 0;
 
   tmpTime = millis();

commit ff5c8d35705df99f385a6b27163380a249c2e646
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Thu Aug 13 20:31:59 2020 -0300

    Optimize LVGL with HAL TFT IO (SPI and FSMC) (#18974)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
index 81b50a1018..391e12ba3f 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
@@ -35,23 +35,22 @@
 
 #include "tft_lvgl_configuration.h"
 #include "draw_ready_print.h"
 #include "pic_manager.h"
 #include "mks_hardware_test.h"
 #include "draw_ui.h"
 #include <lvgl.h>
 
 #include "../../../../inc/MarlinConfig.h"
 
-#if HAS_TOUCH_XPT2046
-  #include "../../../touch/xpt2046.h"
-#endif
+#include HAL_PATH(../../HAL, tft/xpt2046.h)
+XPT2046 touch;
 
 #if ENABLED(POWER_LOSS_RECOVERY)
   #include "../../../../feature/powerloss.h"
 #endif
 
 #include <SPI.h>
 
 #ifndef LCD_FULL_PIXEL_WIDTH
   #define LCD_FULL_PIXEL_WIDTH  480
 #endif
@@ -114,28 +113,28 @@ void tft_set_cursor(uint16_t x, uint16_t y) {
   LCD_IO_WriteData(y >> 8);
   LCD_IO_WriteData(y & 0x00FF);
   LCD_IO_WriteData(y >> 8);
   LCD_IO_WriteData(y & 0x00FF);
   //ILI9488_WriteData(0x01);
   //ILI9488_WriteData(0x3F);
 }
 
 void LCD_WriteRAM_Prepare(void) {
   #if 0
-  if ((DeviceCode == 0x9325) || (DeviceCode == 0x9328) || (DeviceCode == 0x8989)) {
-    ClrCs
-    LCD->LCD_REG = R34;
-    SetCs
-  }
-  else {
-    LCD_WrtReg(0x002C);
-  }
+    switch (DeviceCode) {
+      case 0x9325: case 0x9328: case 0x8989: {
+        ClrCs
+        LCD->LCD_REG = R34;
+        SetCs
+      } break;
+      default: LCD_WrtReg(0x002C);
+    }
   #else
     LCD_IO_WriteReg(0x002C);
   #endif
 }
 
 void tft_set_point(uint16_t x, uint16_t y, uint16_t point) {
   //if (DeviceCode == 0x9488) {
   if (x > (LCD_FULL_PIXEL_WIDTH) || y > (LCD_FULL_PIXEL_HEIGHT)) return;
   //}
   tft_set_cursor(x, y);
@@ -190,22 +189,22 @@ void ili9320_SetWindows(uint16_t StartX, uint16_t StartY, uint16_t width, uint16
     LCD_IO_WriteData(e_h);
     LCD_IO_WriteData(e_l);
   }
   else if ((DeviceCode == 0x9325) || (DeviceCode == 0x9328) || (DeviceCode == 0x1505)) {
     /* LCD_WriteReg(0x0050, StartX);
      LCD_WriteReg(0x0052, StartY);
      LCD_WriteReg(0x0051, xEnd);
      LCD_WriteReg(0x0053, yEnd);*/
     LCD_WriteReg(0x0050, StartY);   // Specify the start/end positions of the window address in the horizontal direction by an address unit
     LCD_WriteReg(0x0051, yEnd);     // Specify the start positions of the window address in the vertical direction by an address unit
-    LCD_WriteReg(0x0052, 320 - xEnd);
-    LCD_WriteReg(0x0053, 320 - StartX - 1); // Specify the end positions of the window address in the vertical direction by an address unit
+    LCD_WriteReg(0x0052, (LCD_FULL_PIXEL_HEIGHT) - xEnd);
+    LCD_WriteReg(0x0053, (LCD_FULL_PIXEL_HEIGHT) - StartX - 1); // Specify the end positions of the window address in the vertical direction by an address unit
 
   }
   else {
     s_h = (StartX >> 8) & 0xFF;
     s_l = StartX & 0xFF;
     e_h = ((StartX + width - 1) >> 8) & 0xFF;
     e_l = (StartX + width - 1) & 0xFF;
 
     LCD_IO_WriteReg(0x2A);
     LCD_IO_WriteData(s_h);
@@ -261,61 +260,40 @@ void LCD_Clear(uint16_t Color) {
       LCD_IO_WriteData(Color);
   }
   else {
     tft_set_cursor(0, 0);
     LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
     for (index = 0; index < 76800; index++)
       LCD_IO_WriteData(Color);
   }
 }
 
-extern uint16_t ILI9488_ReadRAM();
-
+#include HAL_PATH(../../HAL, tft/tft_fsmc.h)
+extern TFT_IO tftio;
 void init_tft() {
   uint16_t i;
-  //************* Start Initial Sequence **********//
-
-  //start lcd pins and dma
-  #if PIN_EXISTS(LCD_BACKLIGHT)
-    OUT_WRITE(LCD_BACKLIGHT_PIN, DISABLED(DELAYED_BACKLIGHT_INIT)); // Illuminate after reset or right away
-  #endif
-
-  #if PIN_EXISTS(LCD_RESET)
-    // Perform a clean hardware reset with needed delays
-    OUT_WRITE(LCD_RESET_PIN, LOW);
-    _delay_ms(5);
-    WRITE(LCD_RESET_PIN, HIGH);
-    _delay_ms(5);
-  #endif
-
-  #if PIN_EXISTS(LCD_BACKLIGHT) && ENABLED(DELAYED_BACKLIGHT_INIT)
-    WRITE(LCD_BACKLIGHT_PIN, HIGH);
-  #endif
 
   TERN_(HAS_LCD_CONTRAST, refresh_contrast());
 
   #ifdef LCD_USE_DMA_FSMC
     dma_init(FSMC_DMA_DEV);
     dma_disable(FSMC_DMA_DEV, FSMC_DMA_CHANNEL);
     dma_set_priority(FSMC_DMA_DEV, FSMC_DMA_CHANNEL, DMA_PRIORITY_MEDIUM);
   #endif
 
   LCD_IO_Init(FSMC_CS_PIN, FSMC_RS_PIN);
 
   _delay_ms(5);
 
-  LCD_IO_WriteReg(0x00D3);
-  DeviceCode = ILI9488_ReadRAM(); //dummy read
-  DeviceCode = ILI9488_ReadRAM();
-  DeviceCode = ILI9488_ReadRAM();
-  DeviceCode <<= 8;
-  DeviceCode |= ILI9488_ReadRAM();
+  DeviceCode = tftio.GetID() & 0xFFFF;
+  // Chitu and others
+  if (DeviceCode == 0x8066) DeviceCode = 0x9488;
 
   if (DeviceCode == 0x9488) {
     LCD_IO_WriteReg(0x00E0);
     LCD_IO_WriteData(0x0000);
     LCD_IO_WriteData(0x0007);
     LCD_IO_WriteData(0x000f);
     LCD_IO_WriteData(0x000D);
     LCD_IO_WriteData(0x001B);
     LCD_IO_WriteData(0x000A);
     LCD_IO_WriteData(0x003c);
@@ -429,21 +407,21 @@ void tft_lvgl_init() {
     init_tft();
   #endif
 
   #if ENABLED(SDSUPPORT)
     UpdateAssets();
   #endif
   mks_test_get();
 
   //spi_flash_read_test();
 
-  TERN_(HAS_TOUCH_XPT2046, touch.init());
+  touch.Init();
 
   lv_init();
 
   lv_disp_buf_init(&disp_buf, bmp_public_buf, NULL, LV_HOR_RES_MAX * 18); /*Initialize the display buffer*/
 
   lv_disp_drv_t disp_drv;     /*Descriptor of a display driver*/
   lv_disp_drv_init(&disp_drv);    /*Basic initialization*/
   disp_drv.flush_cb = my_disp_flush; /*Set your driver function*/
   disp_drv.buffer = &disp_buf;    /*Assign the buffer to the display*/
   lv_disp_drv_register(&disp_drv);  /*Finally register the driver*/
@@ -485,49 +463,28 @@ void tft_lvgl_init() {
   #endif
     lv_draw_ready_print();
 
   if (mks_test_flag == 0x1E)
     mks_gpio_test();
 }
 
 void my_disp_flush(lv_disp_drv_t * disp, const lv_area_t * area, lv_color_t * color_p) {
   #if ENABLED(TFT_LVGL_UI_SPI)
     uint16_t i, width, height;
-    uint16_t clr_temp;
-    uint8_t tbuf[(LCD_FULL_PIXEL_WIDTH) * 2];
-
-    SPI_TFT.spi_init(SPI_FULL_SPEED);
 
     width = area->x2 - area->x1 + 1;
     height = area->y2 - area->y1 + 1;
 
-    for (int j = 0; j < height; j++) {
-      SPI_TFT.SetCursor(0, 0);
-      SPI_TFT.SetWindows((uint16_t)area->x1, (uint16_t)area->y1 + j, width, 1);
-      SPI_TFT.LCD_WriteRAM_Prepare();
-
-      for (i = 0; i < width * 2;) {
-        clr_temp = (uint16_t)(((uint16_t)color_p->ch.red << 11)
-                              | ((uint16_t)color_p->ch.green << 5)
-                              | ((uint16_t)color_p->ch.blue));
-
-        tbuf[i] = clr_temp >> 8;
-        tbuf[i + 1] = clr_temp;
-        i += 2;
-        color_p++;
-      }
-      SPI_TFT_CS_L;
-      SPI_TFT_DC_H;
-      SPI.dmaSend(tbuf, width * 2, true);
-      SPI_TFT_CS_H;
+    SPI_TFT.SetWindows((uint16_t)area->x1, (uint16_t)area->y1, width, height);
+    for (i = 0; i < height; i++) {
+      SPI_TFT.tftio.WriteSequence((uint16_t*)(color_p + width * i), width);
     }
-
     lv_disp_flush_ready(disp);       /* Indicate you are ready with the flushing*/
 
     W25QXX.init(SPI_QUARTER_SPEED);
 
   #else // !TFT_LVGL_UI_SPI
 
     #if 1
       uint16_t i, width, height;
       uint16_t clr_temp;
       width = area->x2 - area->x1 + 1;
@@ -549,220 +506,59 @@ void my_disp_flush(lv_disp_drv_t * disp, const lv_area_t * area, lv_color_t * co
 }
 
 #define TICK_CYCLE 1
 
 static int32_t touch_time1 = 0;
 
 unsigned int getTickDiff(unsigned int curTick, unsigned int lastTick) {
   return TICK_CYCLE * (lastTick <= curTick ? (curTick - lastTick) : (0xFFFFFFFF - lastTick + curTick));
 }
 
-#if ENABLED(TFT_LVGL_UI_SPI)
-
-  #ifndef USE_XPT2046
-    #define USE_XPT2046       1
-    #define XPT2046_XY_SWAP   1
-    #define XPT2046_X_INV     1
-    #define XPT2046_Y_INV     0
-  #endif
-
-  #if USE_XPT2046
-    #define XPT2046_HOR_RES 480
-    #define XPT2046_VER_RES 320
-    #define XPT2046_X_MIN   201
-    #define XPT2046_Y_MIN   164
-    #define XPT2046_X_MAX  3919
-    #define XPT2046_Y_MAX  3776
-    #define XPT2046_AVG       4
-    #define XPT2046_INV       1
-  #endif
-
-#else
-
-  #ifndef USE_XPT2046
-    #define USE_XPT2046       1
-    #ifndef XPT2046_XY_SWAP
-      #define XPT2046_XY_SWAP 1
-    #endif
-    #ifndef XPT2046_X_INV
-      #define XPT2046_X_INV   0
-    #endif
-    #ifndef XPT2046_Y_INV
-      #define XPT2046_Y_INV   1
-    #endif
-  #endif
-
-  #if USE_XPT2046
-    #ifndef XPT2046_HOR_RES
-      #define XPT2046_HOR_RES 480
-    #endif
-    #ifndef XPT2046_VER_RES
-      #define XPT2046_VER_RES 320
-    #endif
-    #ifndef XPT2046_X_MIN
-      #define XPT2046_X_MIN   201
-    #endif
-    #ifndef XPT2046_Y_MIN
-      #define XPT2046_Y_MIN   164
-    #endif
-    #ifndef XPT2046_X_MAX
-      #define XPT2046_X_MAX  3919
-    #endif
-    #ifndef XPT2046_Y_MAX
-      #define XPT2046_Y_MAX  3776
-    #endif
-    #ifndef XPT2046_AVG
-      #define XPT2046_AVG       4
-    #endif
-    #ifndef XPT2046_INV
-      #define XPT2046_INV       0
-    #endif
-  #endif
-
-#endif
-
-static void xpt2046_corr(uint16_t *x, uint16_t *y) {
-  #if XPT2046_XY_SWAP
-    int16_t swap_tmp;
-    swap_tmp = *x;
-    *x = *y;
-    *y = swap_tmp;
-  #endif
-  if ((*x) > XPT2046_X_MIN) (*x) -= XPT2046_X_MIN; else (*x) = 0;
-  if ((*y) > XPT2046_Y_MIN) (*y) -= XPT2046_Y_MIN; else (*y) = 0;
-  (*x) = uint32_t(uint32_t(*x) * XPT2046_HOR_RES) / (XPT2046_X_MAX - XPT2046_X_MIN);
-  (*y) = uint32_t(uint32_t(*y) * XPT2046_VER_RES) / (XPT2046_Y_MAX - XPT2046_Y_MIN);
-  #if XPT2046_X_INV
-    (*x) = XPT2046_HOR_RES - (*x);
-  #endif
-  #if XPT2046_Y_INV
-    (*y) = XPT2046_VER_RES - (*y);
-  #endif
-}
-
-#define times 4
-#define CHX   0x90
-#define CHY   0xD0
-
-int SPI2_ReadWrite2Bytes(void) {
-  #define SPI_READ_WRITE_BYTE(B) TERN(TFT_LVGL_UI_SPI, SPI_TFT.spi_read_write_byte, W25QXX.spi_flash_read_write_byte)(B)
-  const uint16_t t1 = SPI_READ_WRITE_BYTE(0xFF),
-                 t2 = SPI_READ_WRITE_BYTE(0xFF);
-  return (((t1 << 8) | t2) >> 3) & 0x0FFF;
-}
+static bool get_point(int16_t *x, int16_t *y) {
+  bool is_touched = touch.getRawPoint(x, y);
 
-uint16_t x_addata[times], y_addata[times];
-void XPT2046_Rd_Addata(uint16_t *X_Addata, uint16_t *Y_Addata) {
-  uint16_t i, j, k;
-
-  TERN(TFT_LVGL_UI_SPI, SPI_TFT.spi_init, W25QXX.init)(SPI_SPEED_6);
-
-  for (i = 0; i < times; i++) {
-    #if ENABLED(TFT_LVGL_UI_SPI)
-      OUT_WRITE(TOUCH_CS_PIN, LOW);
-      SPI_TFT.spi_read_write_byte(CHX);
-      y_addata[i] = SPI2_ReadWrite2Bytes();
-      WRITE(TOUCH_CS_PIN, HIGH);
-
-      OUT_WRITE(TOUCH_CS_PIN, LOW);
-      SPI_TFT.spi_read_write_byte(CHY);
-      x_addata[i] = SPI2_ReadWrite2Bytes();
-      WRITE(TOUCH_CS_PIN, HIGH);
-    #else // #if HAS_TOUCH_XPT2046
-      OUT_WRITE(TOUCH_CS_PIN, LOW);
-      W25QXX.spi_flash_read_write_byte(CHX);
-      y_addata[i] = SPI2_ReadWrite2Bytes();
-      WRITE(TOUCH_CS_PIN, HIGH);
-
-      OUT_WRITE(TOUCH_CS_PIN, LOW);
-      W25QXX.spi_flash_read_write_byte(CHY);
-      x_addata[i] = SPI2_ReadWrite2Bytes();
-      WRITE(TOUCH_CS_PIN, HIGH);
-    #endif
-
-  }
-  TERN(TFT_LVGL_UI_SPI,,W25QXX.init(SPI_QUARTER_SPEED));
-
-  for (i = 0; i < times; i++)
-    for (j = i + 1; j < times; j++)
-      if (x_addata[j] > x_addata[i]) {
-        k = x_addata[j];
-        x_addata[j] = x_addata[i];
-        x_addata[i] = k;
-      }
-  if (x_addata[times / 2 - 1] - x_addata[times / 2] > 50) {
-    *X_Addata = *Y_Addata = 0;
-    return;
-  }
-
-  *X_Addata = (x_addata[times / 2 - 1] + x_addata[times / 2]) / 2;
-
-  for (i = 0; i < times; i++)
-    for (j = i + 1; j < times; j++)
-      if (y_addata[j] > y_addata[i]) {
-        k = y_addata[j];
-        y_addata[j] = y_addata[i];
-        y_addata[i] = k;
-      }
-
-  if (y_addata[times / 2 - 1] - y_addata[times / 2] > 50) {
-    *X_Addata = *Y_Addata = 0;
-    return;
+  if (is_touched) {
+    *x = int16_t((int32_t(*x) * XPT2046_X_CALIBRATION) >> 16) + XPT2046_X_OFFSET;
+    *y = int16_t((int32_t(*y) * XPT2046_Y_CALIBRATION) >> 16) + XPT2046_Y_OFFSET;
   }
 
-  *Y_Addata = (y_addata[times / 2 - 1] + y_addata[times / 2]) / 2;
-}
-
-#define ADC_VALID_OFFSET  10
+  #if ENABLED(GRAPHICAL_TFT_ROTATE_180)
+    x = (LCD_FULL_PIXEL_WIDTH) - x;
+    y = (LCD_FULL_PIXEL_HEIGHT) - y;
+  #endif
 
-uint8_t TOUCH_PressValid(uint16_t _usX, uint16_t _usY) {
-  if ( (_usX <= ADC_VALID_OFFSET)
-    || (_usY <= ADC_VALID_OFFSET)
-    || (_usX >= 4095 - ADC_VALID_OFFSET)
-    || (_usY >= 4095 - ADC_VALID_OFFSET)
-  ) return 0;
-  return 1;
+  return is_touched;
 }
 
-static lv_coord_t last_x = 0, last_y = 0;
+static int16_t last_x = 0, last_y = 0;
 bool my_touchpad_read(lv_indev_drv_t * indev_driver, lv_indev_data_t * data) {
   uint32_t tmpTime, diffTime = 0;
 
   tmpTime = millis();
   diffTime = getTickDiff(tmpTime, touch_time1);
   /*Save the state and save the pressed coordinate*/
   //data->state = TOUCH_PressValid(last_x, last_y) ? LV_INDEV_STATE_PR : LV_INDEV_STATE_REL;
   //if (data->state == LV_INDEV_STATE_PR)  ADS7843_Rd_Addata((u16 *)&last_x, (u16 *)&last_y);
   //touchpad_get_xy(&last_x, &last_y);
   /*Save the pressed coordinates and the state*/
   if (diffTime > 10) {
-    //use marlin touch code if enabled
-    #if HAS_TOUCH_XPT2046
-      touch.getTouchPoint(reinterpret_cast<uint16_t&>(last_x), reinterpret_cast<uint16_t&>(last_y));
-    #else
-      XPT2046_Rd_Addata((uint16_t *)&last_x, (uint16_t *)&last_y);
-    #endif
-    if (TOUCH_PressValid(last_x, last_y)) {
+    if (get_point(&last_x, &last_y)) {
 
       data->state = LV_INDEV_STATE_PR;
 
-      /* Set the coordinates (if released use the last pressed coordinates) */
+      // Set the coordinates (if released use the last-pressed coordinates)
 
-      // SERIAL_ECHOLNPAIR("antes X: ", last_x, ", y: ", last_y);
-      xpt2046_corr((uint16_t *)&last_x, (uint16_t *)&last_y);
-      // SERIAL_ECHOLNPAIR("X: ", last_x, ", y: ", last_y);
       data->point.x = last_x;
       data->point.y = last_y;
 
-      last_x = 0;
-      last_y = 0;
+      last_x = last_y = 0;
     }
-    else {
+    else
       data->state = LV_INDEV_STATE_REL;
-    }
+
     touch_time1 = tmpTime;
   }
 
-  return false; /*Return `false` because we are not buffering and no more data to read*/
+  return false; // Return `false` since no data is buffering or left to read
 }
 
 #endif // HAS_TFT_LVGL_UI

commit 0a1b8659871f681464f24c40b16aa64cd2f7ca8e
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Sat Aug 8 21:24:31 2020 -0300

    W25QXX SPI Flash support (#18897)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
index fc5b8c1bf2..81b50a1018 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
@@ -28,21 +28,20 @@
 #include "../../../../inc/MarlinConfigPre.h"
 
 #if HAS_TFT_LVGL_UI
 
 #if ENABLED(TFT_LVGL_UI_SPI)
   #include "SPI_TFT.h"
 #endif
 
 #include "tft_lvgl_configuration.h"
 #include "draw_ready_print.h"
-#include "W25Qxx.h"
 #include "pic_manager.h"
 #include "mks_hardware_test.h"
 #include "draw_ui.h"
 #include <lvgl.h>
 
 #include "../../../../inc/MarlinConfig.h"
 
 #if HAS_TOUCH_XPT2046
   #include "../../../touch/xpt2046.h"
 #endif

commit ca0ebf10d10d3c8e99c83c123c5ff2a678cda900
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Aug 3 21:55:37 2020 -0500

    Move scaled TFT / touch defines (#18915)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
index 96eedd3296..fc5b8c1bf2 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
@@ -34,29 +34,39 @@
 #endif
 
 #include "tft_lvgl_configuration.h"
 #include "draw_ready_print.h"
 #include "W25Qxx.h"
 #include "pic_manager.h"
 #include "mks_hardware_test.h"
 #include "draw_ui.h"
 #include <lvgl.h>
 
-#include "../../../../MarlinCore.h"
-#include "../../../../feature/touch/xpt2046.h"
+#include "../../../../inc/MarlinConfig.h"
+
+#if HAS_TOUCH_XPT2046
+  #include "../../../touch/xpt2046.h"
+#endif
 
 #if ENABLED(POWER_LOSS_RECOVERY)
   #include "../../../../feature/powerloss.h"
 #endif
 
 #include <SPI.h>
 
+#ifndef LCD_FULL_PIXEL_WIDTH
+  #define LCD_FULL_PIXEL_WIDTH  480
+#endif
+#ifndef LCD_FULL_PIXEL_HEIGHT
+  #define LCD_FULL_PIXEL_HEIGHT 320
+#endif
+
 #if HAS_SPI_FLASH_FONT
   extern void init_gb2312_font();
 #endif
 
 static lv_disp_buf_t disp_buf;
 #if ENABLED(SDSUPPORT)
   extern void UpdateAssets();
 #endif
 uint16_t DeviceCode = 0x9488;
 extern uint8_t sel_id;
@@ -120,23 +130,22 @@ void LCD_WriteRAM_Prepare(void) {
   else {
     LCD_WrtReg(0x002C);
   }
   #else
     LCD_IO_WriteReg(0x002C);
   #endif
 }
 
 void tft_set_point(uint16_t x, uint16_t y, uint16_t point) {
   //if (DeviceCode == 0x9488) {
-  if ((x > 480) || (y > 320)) return;
+  if (x > (LCD_FULL_PIXEL_WIDTH) || y > (LCD_FULL_PIXEL_HEIGHT)) return;
   //}
-  //**if ( (x>320)||(y>240) ) return;
   tft_set_cursor(x, y);
 
   LCD_WriteRAM_Prepare();
   //LCD_WriteRAM(point);
   LCD_IO_WriteData(point);
 }
 
 void LCD_WriteReg(uint16_t LCD_Reg, uint16_t LCD_RegValue) {
   /* Write 16-bit Index, then Write Reg */
   ClrCs
@@ -180,24 +189,24 @@ void ili9320_SetWindows(uint16_t StartX, uint16_t StartY, uint16_t width, uint16
     LCD_IO_WriteData(s_h);
     LCD_IO_WriteData(s_l);
     LCD_IO_WriteData(e_h);
     LCD_IO_WriteData(e_l);
   }
   else if ((DeviceCode == 0x9325) || (DeviceCode == 0x9328) || (DeviceCode == 0x1505)) {
     /* LCD_WriteReg(0x0050, StartX);
      LCD_WriteReg(0x0052, StartY);
      LCD_WriteReg(0x0051, xEnd);
      LCD_WriteReg(0x0053, yEnd);*/
-    LCD_WriteReg(0x0050, StartY);      //Specify the start/end positions of the window address in the horizontal direction by an address unit
-    LCD_WriteReg(0x0051, yEnd);      //Specify the start positions of the window address in the vertical direction by an address unit
+    LCD_WriteReg(0x0050, StartY);   // Specify the start/end positions of the window address in the horizontal direction by an address unit
+    LCD_WriteReg(0x0051, yEnd);     // Specify the start positions of the window address in the vertical direction by an address unit
     LCD_WriteReg(0x0052, 320 - xEnd);
-    LCD_WriteReg(0x0053, 320 - StartX - 1);      //Specify the end positions of the window address in the vertical direction by an address unit
+    LCD_WriteReg(0x0053, 320 - StartX - 1); // Specify the end positions of the window address in the vertical direction by an address unit
 
   }
   else {
     s_h = (StartX >> 8) & 0xFF;
     s_l = StartX & 0xFF;
     e_h = ((StartX + width - 1) >> 8) & 0xFF;
     e_l = (StartX + width - 1) & 0xFF;
 
     LCD_IO_WriteReg(0x2A);
     LCD_IO_WriteData(s_h);
@@ -217,30 +226,30 @@ void ili9320_SetWindows(uint16_t StartX, uint16_t StartY, uint16_t width, uint16
     LCD_IO_WriteData(e_l);
   }
 }
 
 void LCD_Clear(uint16_t Color) {
   uint32_t index = 0;
   unsigned int count;
 
   if (DeviceCode == 0x9488) {
     tft_set_cursor(0, 0);
-    ili9320_SetWindows(0, 0, 480, 320);
+    ili9320_SetWindows(0, 0, LCD_FULL_PIXEL_WIDTH, LCD_FULL_PIXEL_HEIGHT);
     LCD_WriteRAM_Prepare();
     #ifdef LCD_USE_DMA_FSMC
-      LCD_IO_WriteMultiple(Color, LCD_FULL_PIXEL_WIDTH * LCD_FULL_PIXEL_HEIGHT);
+      LCD_IO_WriteMultiple(Color, (LCD_FULL_PIXEL_WIDTH) * (LCD_FULL_PIXEL_HEIGHT));
     #else
-    //index = (160*480);
-    for (index = 0; index < 320 * 480; index++)
-      LCD_IO_WriteData(Color);
+      //index = (LCD_FULL_PIXEL_HEIGHT) / 2 * (LCD_FULL_PIXEL_WIDTH);
+      for (index = 0; index < (LCD_FULL_PIXEL_HEIGHT) * (LCD_FULL_PIXEL_WIDTH); index++)
+        LCD_IO_WriteData(Color);
     #endif
-    //LCD_IO_WriteMultiple(Color, (480*320));
+    //LCD_IO_WriteMultiple(Color, (LCD_FULL_PIXEL_WIDTH) * (LCD_FULL_PIXEL_HEIGHT));
     //while(index --) LCD_IO_WriteData(Color);
   }
   else if (DeviceCode == 0x5761) {
     LCD_IO_WriteReg(0x002a);
     LCD_IO_WriteData(0);
     LCD_IO_WriteData(0);
     LCD_IO_WriteData(HDP >> 8);
     LCD_IO_WriteData(HDP & 0x00ff);
     LCD_IO_WriteReg(0x002b);
     LCD_IO_WriteData(0);
@@ -255,21 +264,20 @@ void LCD_Clear(uint16_t Color) {
   else {
     tft_set_cursor(0, 0);
     LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
     for (index = 0; index < 76800; index++)
       LCD_IO_WriteData(Color);
   }
 }
 
 extern uint16_t ILI9488_ReadRAM();
 
-
 void init_tft() {
   uint16_t i;
   //************* Start Initial Sequence **********//
 
   //start lcd pins and dma
   #if PIN_EXISTS(LCD_BACKLIGHT)
     OUT_WRITE(LCD_BACKLIGHT_PIN, DISABLED(DELAYED_BACKLIGHT_INIT)); // Illuminate after reset or right away
   #endif
 
   #if PIN_EXISTS(LCD_RESET)
@@ -386,21 +394,21 @@ void init_tft() {
     LCD_IO_WriteReg(0x00F7);
     LCD_IO_WriteData(0x00A9);
     LCD_IO_WriteData(0x0051);
     LCD_IO_WriteData(0x002C);
     LCD_IO_WriteData(0x0082);
 
     LCD_IO_WriteReg(0x0011);
     for (i = 0; i < 65535; i++);
     LCD_IO_WriteReg(0x0029);
 
-    ili9320_SetWindows(0, 0, 480, 320);
+    ili9320_SetWindows(0, 0, LCD_FULL_PIXEL_WIDTH, LCD_FULL_PIXEL_HEIGHT);
     LCD_Clear(0x0000);
 
     OUT_WRITE(LCD_BACKLIGHT_PIN, HIGH);
   }
 }
 
 #endif // !TFT_LVGL_UI_SPI
 
 extern uint8_t bmp_public_buf[17 * 1024];
 
@@ -479,21 +487,21 @@ void tft_lvgl_init() {
     lv_draw_ready_print();
 
   if (mks_test_flag == 0x1E)
     mks_gpio_test();
 }
 
 void my_disp_flush(lv_disp_drv_t * disp, const lv_area_t * area, lv_color_t * color_p) {
   #if ENABLED(TFT_LVGL_UI_SPI)
     uint16_t i, width, height;
     uint16_t clr_temp;
-    uint8_t tbuf[480 * 2];
+    uint8_t tbuf[(LCD_FULL_PIXEL_WIDTH) * 2];
 
     SPI_TFT.spi_init(SPI_FULL_SPEED);
 
     width = area->x2 - area->x1 + 1;
     height = area->y2 - area->y1 + 1;
 
     for (int j = 0; j < height; j++) {
       SPI_TFT.SetCursor(0, 0);
       SPI_TFT.SetWindows((uint16_t)area->x1, (uint16_t)area->y1 + j, width, 1);
       SPI_TFT.LCD_WriteRAM_Prepare();

commit 117df87d193994f6fbcd46c45573095adf921784
Author: Alexander Gavrilenko <jmz52@users.noreply.github.com>
Date:   Thu Jul 30 09:43:19 2020 +0300

    Support for TFT & Touch Screens (#18130)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
index f24f08e98e..96eedd3296 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
@@ -422,21 +422,21 @@ void tft_lvgl_init() {
     init_tft();
   #endif
 
   #if ENABLED(SDSUPPORT)
     UpdateAssets();
   #endif
   mks_test_get();
 
   //spi_flash_read_test();
 
-  TERN_(TOUCH_BUTTONS, touch.init());
+  TERN_(HAS_TOUCH_XPT2046, touch.init());
 
   lv_init();
 
   lv_disp_buf_init(&disp_buf, bmp_public_buf, NULL, LV_HOR_RES_MAX * 18); /*Initialize the display buffer*/
 
   lv_disp_drv_t disp_drv;     /*Descriptor of a display driver*/
   lv_disp_drv_init(&disp_drv);    /*Basic initialization*/
   disp_drv.flush_cb = my_disp_flush; /*Set your driver function*/
   disp_drv.buffer = &disp_buf;    /*Assign the buffer to the display*/
   lv_disp_drv_register(&disp_drv);  /*Finally register the driver*/
@@ -653,21 +653,21 @@ void XPT2046_Rd_Addata(uint16_t *X_Addata, uint16_t *Y_Addata) {
     #if ENABLED(TFT_LVGL_UI_SPI)
       OUT_WRITE(TOUCH_CS_PIN, LOW);
       SPI_TFT.spi_read_write_byte(CHX);
       y_addata[i] = SPI2_ReadWrite2Bytes();
       WRITE(TOUCH_CS_PIN, HIGH);
 
       OUT_WRITE(TOUCH_CS_PIN, LOW);
       SPI_TFT.spi_read_write_byte(CHY);
       x_addata[i] = SPI2_ReadWrite2Bytes();
       WRITE(TOUCH_CS_PIN, HIGH);
-    #else // #if ENABLED(TOUCH_BUTTONS)
+    #else // #if HAS_TOUCH_XPT2046
       OUT_WRITE(TOUCH_CS_PIN, LOW);
       W25QXX.spi_flash_read_write_byte(CHX);
       y_addata[i] = SPI2_ReadWrite2Bytes();
       WRITE(TOUCH_CS_PIN, HIGH);
 
       OUT_WRITE(TOUCH_CS_PIN, LOW);
       W25QXX.spi_flash_read_write_byte(CHY);
       x_addata[i] = SPI2_ReadWrite2Bytes();
       WRITE(TOUCH_CS_PIN, HIGH);
     #endif
@@ -722,21 +722,21 @@ bool my_touchpad_read(lv_indev_drv_t * indev_driver, lv_indev_data_t * data) {
 
   tmpTime = millis();
   diffTime = getTickDiff(tmpTime, touch_time1);
   /*Save the state and save the pressed coordinate*/
   //data->state = TOUCH_PressValid(last_x, last_y) ? LV_INDEV_STATE_PR : LV_INDEV_STATE_REL;
   //if (data->state == LV_INDEV_STATE_PR)  ADS7843_Rd_Addata((u16 *)&last_x, (u16 *)&last_y);
   //touchpad_get_xy(&last_x, &last_y);
   /*Save the pressed coordinates and the state*/
   if (diffTime > 10) {
     //use marlin touch code if enabled
-    #if ENABLED(TOUCH_BUTTONS)
+    #if HAS_TOUCH_XPT2046
       touch.getTouchPoint(reinterpret_cast<uint16_t&>(last_x), reinterpret_cast<uint16_t&>(last_y));
     #else
       XPT2046_Rd_Addata((uint16_t *)&last_x, (uint16_t *)&last_y);
     #endif
     if (TOUCH_PressValid(last_x, last_y)) {
 
       data->state = LV_INDEV_STATE_PR;
 
       /* Set the coordinates (if released use the last pressed coordinates) */
 

commit d20d4591321aa467c062f0050355d2aca84e03ad
Author: MKS-Sean <56996910+MKS-Sean@users.noreply.github.com>
Date:   Sat Jul 25 13:52:07 2020 +0800

    Robin nano V2, TFT LVGL UI parameters, and more (#18500)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
index ac69bf0669..f24f08e98e 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
@@ -14,66 +14,56 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 /**
- * @file lcd_lvgl_configuration.c
+ * @file tft_lvgl_configuration.cpp
  * @date    2020-02-21
  */
 
 #include "../../../../inc/MarlinConfigPre.h"
 
-#if ENABLED(TFT_LVGL_UI)
+#if HAS_TFT_LVGL_UI
 
-#include "../../../../MarlinCore.h"
+#if ENABLED(TFT_LVGL_UI_SPI)
+  #include "SPI_TFT.h"
+#endif
 
 #include "tft_lvgl_configuration.h"
-#include "lvgl.h"
-#include "../../../../feature/touch/xpt2046.h"
 #include "draw_ready_print.h"
 #include "W25Qxx.h"
 #include "pic_manager.h"
-
 #include "mks_hardware_test.h"
 #include "draw_ui.h"
+#include <lvgl.h>
+
+#include "../../../../MarlinCore.h"
+#include "../../../../feature/touch/xpt2046.h"
 
 #if ENABLED(POWER_LOSS_RECOVERY)
   #include "../../../../feature/powerloss.h"
 #endif
 
 #include <SPI.h>
 
-#if ENABLED(SPI_GRAPHICAL_TFT)
-  #include "SPI_TFT.h"
-#endif
-
-extern void LCD_IO_Init(uint8_t cs, uint8_t rs);
-extern void LCD_IO_WriteData(uint16_t RegValue);
-extern void LCD_IO_WriteReg(uint16_t Reg);
-extern void LCD_IO_WriteSequence(uint16_t *data, uint16_t length);
-extern void LCD_IO_WriteMultiple(uint16_t color, uint32_t count);
-
 #if HAS_SPI_FLASH_FONT
   extern void init_gb2312_font();
 #endif
 
 static lv_disp_buf_t disp_buf;
 #if ENABLED(SDSUPPORT)
-  extern void UpdatePic();
-  #if HAS_SPI_FLASH_FONT
-    extern void UpdateFont();
-  #endif
+  extern void UpdateAssets();
 #endif
 uint16_t DeviceCode = 0x9488;
 extern uint8_t sel_id;
 
 #define SetCs
 #define ClrCs
 
 #define HDP  799 // Horizontal Display Period
 #define HT  1000 // Horizontal Total
 #define HPS   51 // LLINE Pulse Start Position
@@ -89,20 +79,27 @@ extern uint8_t sel_id;
 #define MAX_HZ_POSX HDP+1
 #define MAX_HZ_POSY VDP+1
 
 extern uint8_t gcode_preview_over, flash_preview_begin, default_preview_flg;
 
 void SysTick_Callback() {
   lv_tick_inc(1);
   print_time_count();
 }
 
+#if DISABLED(TFT_LVGL_UI_SPI)
+
+extern void LCD_IO_Init(uint8_t cs, uint8_t rs);
+extern void LCD_IO_WriteData(uint16_t RegValue);
+extern void LCD_IO_WriteReg(uint16_t Reg);
+
+extern void LCD_IO_WriteMultiple(uint16_t color, uint32_t count);
 void tft_set_cursor(uint16_t x, uint16_t y) {
   LCD_IO_WriteReg(0x002A);
   LCD_IO_WriteData(x >> 8);
   LCD_IO_WriteData(x & 0x00FF);
   LCD_IO_WriteData(x >> 8);
   LCD_IO_WriteData(x & 0x00FF);
   //ILI9488_WriteData(0x01);
   //ILI9488_WriteData(0xDF);
   LCD_IO_WriteReg(0x002B);
   LCD_IO_WriteData(y >> 8);
@@ -126,31 +123,31 @@ void LCD_WriteRAM_Prepare(void) {
   #else
     LCD_IO_WriteReg(0x002C);
   #endif
 }
 
 void tft_set_point(uint16_t x, uint16_t y, uint16_t point) {
   //if (DeviceCode == 0x9488) {
   if ((x > 480) || (y > 320)) return;
   //}
   //**if ( (x>320)||(y>240) ) return;
-  tft_set_cursor(x, y); /*设置光标位置*/
+  tft_set_cursor(x, y);
 
-  LCD_WriteRAM_Prepare();   /* 开始写入GRAM*/
+  LCD_WriteRAM_Prepare();
   //LCD_WriteRAM(point);
   LCD_IO_WriteData(point);
 }
 
 void LCD_WriteReg(uint16_t LCD_Reg, uint16_t LCD_RegValue) {
   /* Write 16-bit Index, then Write Reg */
   ClrCs
-    LCD_IO_WriteReg(LCD_Reg);
+  LCD_IO_WriteReg(LCD_Reg);
   /* Write 16-bit Reg */
   LCD_IO_WriteData(LCD_RegValue);
   SetCs
 }
 
 void ili9320_SetWindows(uint16_t StartX, uint16_t StartY, uint16_t width, uint16_t heigh) {
   uint16_t s_h, s_l, e_h, e_l;
   uint16_t xEnd, yEnd;
   xEnd = StartX + width;
   yEnd = StartY + heigh - 1;
@@ -258,21 +255,20 @@ void LCD_Clear(uint16_t Color) {
   else {
     tft_set_cursor(0, 0);
     LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
     for (index = 0; index < 76800; index++)
       LCD_IO_WriteData(Color);
   }
 }
 
 extern uint16_t ILI9488_ReadRAM();
 
-#if DISABLED(SPI_GRAPHICAL_TFT)
 
 void init_tft() {
   uint16_t i;
   //************* Start Initial Sequence **********//
 
   //start lcd pins and dma
   #if PIN_EXISTS(LCD_BACKLIGHT)
     OUT_WRITE(LCD_BACKLIGHT_PIN, DISABLED(DELAYED_BACKLIGHT_INIT)); // Illuminate after reset or right away
   #endif
 
@@ -349,26 +345,24 @@ void init_tft() {
     LCD_IO_WriteReg(0x00C1);
     LCD_IO_WriteData(0x0041);
 
     LCD_IO_WriteReg(0x00C5);
     LCD_IO_WriteData(0x0000);
     LCD_IO_WriteData(0x0022);
     LCD_IO_WriteData(0x0080);
 
     LCD_IO_WriteReg(0x0036);
     //ILI9488_WriteData(0x0068);
-    //if (gCfgItems.overturn_180 != 0xEE)
-    //{
+    //if (gCfgItems.overturn_180 != 0xEE) {
     LCD_IO_WriteData(0x0068);
     //}
-    //else
-    //{
+    //else {
     //ILI9488_WriteData(0x00A8);
     //}
 
     LCD_IO_WriteReg(0x003A); //Interface Mode Control
     LCD_IO_WriteData(0x0055);
 
     LCD_IO_WriteReg(0x00B0);  //Interface Mode Control
     LCD_IO_WriteData(0x0000);
     LCD_IO_WriteReg(0x00B1);   //Frame rate 70HZ
     LCD_IO_WriteData(0x00B0);
@@ -399,51 +393,50 @@ void init_tft() {
     for (i = 0; i < 65535; i++);
     LCD_IO_WriteReg(0x0029);
 
     ili9320_SetWindows(0, 0, 480, 320);
     LCD_Clear(0x0000);
 
     OUT_WRITE(LCD_BACKLIGHT_PIN, HIGH);
   }
 }
 
-#endif // if DISABLED(SPI_GRAPHICAL_TFT)
+#endif // !TFT_LVGL_UI_SPI
 
 extern uint8_t bmp_public_buf[17 * 1024];
+
 void tft_lvgl_init() {
+
   //uint16_t test_id=0;
   W25QXX.init(SPI_QUARTER_SPEED);
   //test_id=W25QXX.W25QXX_ReadID();
 
+  gCfgItems_init();
+  ui_cfg_init();
+  disp_language_init();
+
   //init tft first!
-  #if ENABLED(SPI_GRAPHICAL_TFT)
+  #if ENABLED(TFT_LVGL_UI_SPI)
     SPI_TFT.spi_init(SPI_FULL_SPEED);
     SPI_TFT.LCD_init();
   #else
     init_tft();
   #endif
 
   #if ENABLED(SDSUPPORT)
-    UpdatePic();
-    #if HAS_SPI_FLASH_FONT
-      UpdateFont();
-    #endif
+    UpdateAssets();
   #endif
+  mks_test_get();
 
-  gCfgItems_init();
-  ui_cfg_init();
-  disp_language_init();
   //spi_flash_read_test();
 
-  #if ENABLED(TOUCH_BUTTONS)
-    touch.init();
-  #endif
+  TERN_(TOUCH_BUTTONS, touch.init());
 
   lv_init();
 
   lv_disp_buf_init(&disp_buf, bmp_public_buf, NULL, LV_HOR_RES_MAX * 18); /*Initialize the display buffer*/
 
   lv_disp_drv_t disp_drv;     /*Descriptor of a display driver*/
   lv_disp_drv_init(&disp_drv);    /*Basic initialization*/
   disp_drv.flush_cb = my_disp_flush; /*Set your driver function*/
   disp_drv.buffer = &disp_buf;    /*Assign the buffer to the display*/
   lv_disp_drv_register(&disp_drv);  /*Finally register the driver*/
@@ -458,47 +451,46 @@ void tft_lvgl_init() {
 
   #if HAS_SPI_FLASH_FONT
     init_gb2312_font();
   #endif
 
   tft_style_init();
 
   filament_pin_setup();
 
   #if ENABLED(POWER_LOSS_RECOVERY)
-  if (recovery.valid()) {
-    if (gCfgItems.from_flash_pic == 1)
-      flash_preview_begin = 1;
-    else
-      default_preview_flg = 1;
+    if (recovery.valid()) {
+      if (gCfgItems.from_flash_pic == 1)
+        flash_preview_begin = 1;
+      else
+        default_preview_flg = 1;
 
-    uiCfg.print_state = REPRINTING;
+      uiCfg.print_state = REPRINTING;
 
-    memset(public_buf_m, 0, sizeof(public_buf_m));
-    strncpy(public_buf_m, recovery.info.sd_filename, sizeof(public_buf_m));
-    card.printLongPath(public_buf_m);
+      ZERO(public_buf_m);
+      strncpy(public_buf_m, recovery.info.sd_filename, sizeof(public_buf_m));
+      card.printLongPath(public_buf_m);
 
-    strncpy(list_file.long_name[sel_id], card.longFilename, sizeof(list_file.long_name[sel_id]));
+      strncpy(list_file.long_name[sel_id], card.longFilename, sizeof(list_file.long_name[sel_id]));
 
-    lv_draw_printing();
-  }
-  else
+      lv_draw_printing();
+    }
+    else
   #endif
-  lv_draw_ready_print();
+    lv_draw_ready_print();
 
-  #if ENABLED(MKS_TEST)
-    Test_GPIO();
-  #endif
+  if (mks_test_flag == 0x1E)
+    mks_gpio_test();
 }
 
 void my_disp_flush(lv_disp_drv_t * disp, const lv_area_t * area, lv_color_t * color_p) {
-  #if ENABLED(SPI_GRAPHICAL_TFT)
+  #if ENABLED(TFT_LVGL_UI_SPI)
     uint16_t i, width, height;
     uint16_t clr_temp;
     uint8_t tbuf[480 * 2];
 
     SPI_TFT.spi_init(SPI_FULL_SPEED);
 
     width = area->x2 - area->x1 + 1;
     height = area->y2 - area->y1 + 1;
 
     for (int j = 0; j < height; j++) {
@@ -518,102 +510,105 @@ void my_disp_flush(lv_disp_drv_t * disp, const lv_area_t * area, lv_color_t * co
       }
       SPI_TFT_CS_L;
       SPI_TFT_DC_H;
       SPI.dmaSend(tbuf, width * 2, true);
       SPI_TFT_CS_H;
     }
 
     lv_disp_flush_ready(disp);       /* Indicate you are ready with the flushing*/
 
     W25QXX.init(SPI_QUARTER_SPEED);
-  #else
+
+  #else // !TFT_LVGL_UI_SPI
+
     #if 1
       uint16_t i, width, height;
       uint16_t clr_temp;
       width = area->x2 - area->x1 + 1;
       height = area->y2 - area->y1 + 1;
       ili9320_SetWindows((uint16_t)area->x1, (uint16_t)area->y1, width, height);
       LCD_WriteRAM_Prepare();
       for (i = 0; i < width * height - 2; i++) {
         clr_temp = (uint16_t)(((uint16_t)color_p->ch.red << 11)
                               | ((uint16_t)color_p->ch.green << 5)
                               | ((uint16_t)color_p->ch.blue));
         LCD_IO_WriteData(clr_temp);
         color_p++;
       }
 
       lv_disp_flush_ready(disp);       /* Indicate you are ready with the flushing*/
     #endif
-  #endif // SPI_GRAPHICAL_TFT
+
+  #endif // !TFT_LVGL_UI_SPI
 }
 
 #define TICK_CYCLE 1
 
 static int32_t touch_time1 = 0;
 
 unsigned int getTickDiff(unsigned int curTick, unsigned int lastTick) {
   return TICK_CYCLE * (lastTick <= curTick ? (curTick - lastTick) : (0xFFFFFFFF - lastTick + curTick));
 }
 
-#if ENABLED(SPI_GRAPHICAL_TFT)
+#if ENABLED(TFT_LVGL_UI_SPI)
 
   #ifndef USE_XPT2046
     #define USE_XPT2046       1
     #define XPT2046_XY_SWAP   1
     #define XPT2046_X_INV     1
     #define XPT2046_Y_INV     0
   #endif
 
   #if USE_XPT2046
-    #define XPT2046_HOR_RES   480
-    #define XPT2046_VER_RES   320
-    #define XPT2046_X_MIN     201
-    #define XPT2046_Y_MIN     164
-    #define XPT2046_X_MAX     3919
-    #define XPT2046_Y_MAX     3776
+    #define XPT2046_HOR_RES 480
+    #define XPT2046_VER_RES 320
+    #define XPT2046_X_MIN   201
+    #define XPT2046_Y_MIN   164
+    #define XPT2046_X_MAX  3919
+    #define XPT2046_Y_MAX  3776
     #define XPT2046_AVG       4
     #define XPT2046_INV       1
   #endif
 
 #else
 
   #ifndef USE_XPT2046
     #define USE_XPT2046       1
     #ifndef XPT2046_XY_SWAP
-      #define XPT2046_XY_SWAP   1
+      #define XPT2046_XY_SWAP 1
     #endif
     #ifndef XPT2046_X_INV
-      #define XPT2046_X_INV     0
+      #define XPT2046_X_INV   0
     #endif
     #ifndef XPT2046_Y_INV
-      #define XPT2046_Y_INV     1
+      #define XPT2046_Y_INV   1
     #endif
   #endif
 
   #if USE_XPT2046
     #ifndef XPT2046_HOR_RES
-      #define XPT2046_HOR_RES   480
+      #define XPT2046_HOR_RES 480
     #endif
     #ifndef XPT2046_VER_RES
-      #define XPT2046_VER_RES   320
+      #define XPT2046_VER_RES 320
     #endif
     #ifndef XPT2046_X_MIN
-      #define XPT2046_X_MIN     201
+      #define XPT2046_X_MIN   201
     #endif
     #ifndef XPT2046_Y_MIN
-      #define XPT2046_Y_MIN     164
+      #define XPT2046_Y_MIN   164
     #endif
     #ifndef XPT2046_X_MAX
-      #define XPT2046_X_MAX     3919
+      #define XPT2046_X_MAX  3919
     #endif
     #ifndef XPT2046_Y_MAX
-      #define XPT2046_Y_MAX     3776
+      #define XPT2046_Y_MAX  3776
     #endif
     #ifndef XPT2046_AVG
       #define XPT2046_AVG       4
     #endif
     #ifndef XPT2046_INV
       #define XPT2046_INV       0
     #endif
   #endif
 
 #endif
@@ -630,53 +625,39 @@ static void xpt2046_corr(uint16_t *x, uint16_t *y) {
   (*x) = uint32_t(uint32_t(*x) * XPT2046_HOR_RES) / (XPT2046_X_MAX - XPT2046_X_MIN);
   (*y) = uint32_t(uint32_t(*y) * XPT2046_VER_RES) / (XPT2046_Y_MAX - XPT2046_Y_MIN);
   #if XPT2046_X_INV
     (*x) = XPT2046_HOR_RES - (*x);
   #endif
   #if XPT2046_Y_INV
     (*y) = XPT2046_VER_RES - (*y);
   #endif
 }
 
-#define  times  4
+#define times 4
 #define CHX   0x90
 #define CHY   0xD0
 
 int SPI2_ReadWrite2Bytes(void) {
-  volatile uint16_t ans = 0;
-  uint16_t temp = 0;
-  #if ENABLED(SPI_GRAPHICAL_TFT)
-    temp = SPI_TFT.spi_read_write_byte(0xFF);
-    ans = temp << 8;
-    temp = SPI_TFT.spi_read_write_byte(0xFF);
-    ans |= temp;
-    ans >>= 3;
-  #else
-    temp = W25QXX.spi_flash_read_write_byte(0xFF);
-    ans = temp << 8;
-    temp = W25QXX.spi_flash_read_write_byte(0xFF);
-    ans |= temp;
-    ans >>= 3;
-  #endif
-  return ans & 0x0FFF;
+  #define SPI_READ_WRITE_BYTE(B) TERN(TFT_LVGL_UI_SPI, SPI_TFT.spi_read_write_byte, W25QXX.spi_flash_read_write_byte)(B)
+  const uint16_t t1 = SPI_READ_WRITE_BYTE(0xFF),
+                 t2 = SPI_READ_WRITE_BYTE(0xFF);
+  return (((t1 << 8) | t2) >> 3) & 0x0FFF;
 }
 
 uint16_t x_addata[times], y_addata[times];
 void XPT2046_Rd_Addata(uint16_t *X_Addata, uint16_t *Y_Addata) {
   uint16_t i, j, k;
 
-  #if ENABLED(SPI_GRAPHICAL_TFT)
-    SPI_TFT.spi_init(SPI_QUARTER_SPEED);
-  #endif
+  TERN(TFT_LVGL_UI_SPI, SPI_TFT.spi_init, W25QXX.init)(SPI_SPEED_6);
 
   for (i = 0; i < times; i++) {
-    #if ENABLED(SPI_GRAPHICAL_TFT)
+    #if ENABLED(TFT_LVGL_UI_SPI)
       OUT_WRITE(TOUCH_CS_PIN, LOW);
       SPI_TFT.spi_read_write_byte(CHX);
       y_addata[i] = SPI2_ReadWrite2Bytes();
       WRITE(TOUCH_CS_PIN, HIGH);
 
       OUT_WRITE(TOUCH_CS_PIN, LOW);
       SPI_TFT.spi_read_write_byte(CHY);
       x_addata[i] = SPI2_ReadWrite2Bytes();
       WRITE(TOUCH_CS_PIN, HIGH);
     #else // #if ENABLED(TOUCH_BUTTONS)
@@ -685,20 +666,21 @@ void XPT2046_Rd_Addata(uint16_t *X_Addata, uint16_t *Y_Addata) {
       y_addata[i] = SPI2_ReadWrite2Bytes();
       WRITE(TOUCH_CS_PIN, HIGH);
 
       OUT_WRITE(TOUCH_CS_PIN, LOW);
       W25QXX.spi_flash_read_write_byte(CHY);
       x_addata[i] = SPI2_ReadWrite2Bytes();
       WRITE(TOUCH_CS_PIN, HIGH);
     #endif
 
   }
+  TERN(TFT_LVGL_UI_SPI,,W25QXX.init(SPI_QUARTER_SPEED));
 
   for (i = 0; i < times; i++)
     for (j = i + 1; j < times; j++)
       if (x_addata[j] > x_addata[i]) {
         k = x_addata[j];
         x_addata[j] = x_addata[i];
         x_addata[i] = k;
       }
   if (x_addata[times / 2 - 1] - x_addata[times / 2] > 50) {
     *X_Addata = *Y_Addata = 0;
@@ -719,22 +701,24 @@ void XPT2046_Rd_Addata(uint16_t *X_Addata, uint16_t *Y_Addata) {
     *X_Addata = *Y_Addata = 0;
     return;
   }
 
   *Y_Addata = (y_addata[times / 2 - 1] + y_addata[times / 2]) / 2;
 }
 
 #define ADC_VALID_OFFSET  10
 
 uint8_t TOUCH_PressValid(uint16_t _usX, uint16_t _usY) {
-  if (   (_usX <= ADC_VALID_OFFSET) || (_usY <= ADC_VALID_OFFSET)
-      || (_usX >= 4095 - ADC_VALID_OFFSET) || (_usY >= 4095 - ADC_VALID_OFFSET)
+  if ( (_usX <= ADC_VALID_OFFSET)
+    || (_usY <= ADC_VALID_OFFSET)
+    || (_usX >= 4095 - ADC_VALID_OFFSET)
+    || (_usY >= 4095 - ADC_VALID_OFFSET)
   ) return 0;
   return 1;
 }
 
 static lv_coord_t last_x = 0, last_y = 0;
 bool my_touchpad_read(lv_indev_drv_t * indev_driver, lv_indev_data_t * data) {
   uint32_t tmpTime, diffTime = 0;
 
   tmpTime = millis();
   diffTime = getTickDiff(tmpTime, touch_time1);
@@ -747,31 +731,31 @@ bool my_touchpad_read(lv_indev_drv_t * indev_driver, lv_indev_data_t * data) {
     //use marlin touch code if enabled
     #if ENABLED(TOUCH_BUTTONS)
       touch.getTouchPoint(reinterpret_cast<uint16_t&>(last_x), reinterpret_cast<uint16_t&>(last_y));
     #else
       XPT2046_Rd_Addata((uint16_t *)&last_x, (uint16_t *)&last_y);
     #endif
     if (TOUCH_PressValid(last_x, last_y)) {
 
       data->state = LV_INDEV_STATE_PR;
 
-      /*Set the coordinates (if released use the last pressed coordinates)*/
+      /* Set the coordinates (if released use the last pressed coordinates) */
 
       // SERIAL_ECHOLNPAIR("antes X: ", last_x, ", y: ", last_y);
       xpt2046_corr((uint16_t *)&last_x, (uint16_t *)&last_y);
       // SERIAL_ECHOLNPAIR("X: ", last_x, ", y: ", last_y);
       data->point.x = last_x;
       data->point.y = last_y;
 
       last_x = 0;
       last_y = 0;
     }
     else {
       data->state = LV_INDEV_STATE_REL;
     }
     touch_time1 = tmpTime;
   }
 
   return false; /*Return `false` because we are not buffering and no more data to read*/
 }
 
-#endif // TFT_LVGL_UI
+#endif // HAS_TFT_LVGL_UI

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
index 3fa6267625..ac69bf0669 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
@@ -9,21 +9,21 @@
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 /**
  * @file lcd_lvgl_configuration.c
  * @date    2020-02-21
  */
 
 #include "../../../../inc/MarlinConfigPre.h"
 

commit 0a86291e66f0c33d399b8698dd0e7d41e628181b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Jul 19 22:06:45 2020 -0500

    Fix some LVGL warnings

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
index 54c030f967..3fa6267625 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
@@ -583,21 +583,21 @@ unsigned int getTickDiff(unsigned int curTick, unsigned int lastTick) {
     #endif
     #ifndef XPT2046_X_INV
       #define XPT2046_X_INV     0
     #endif
     #ifndef XPT2046_Y_INV
       #define XPT2046_Y_INV     1
     #endif
   #endif
 
   #if USE_XPT2046
-    #ifndef XPT2046_HOR_RES   480
+    #ifndef XPT2046_HOR_RES
       #define XPT2046_HOR_RES   480
     #endif
     #ifndef XPT2046_VER_RES
       #define XPT2046_VER_RES   320
     #endif
     #ifndef XPT2046_X_MIN
       #define XPT2046_X_MIN     201
     #endif
     #ifndef XPT2046_Y_MIN
       #define XPT2046_Y_MIN     164

commit e5bc9d31cc87be5c7ef2bd3cd70c2599f76d2bd7
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Wed Jul 1 03:30:24 2020 -0300

    Add TFT_LVGL_UI support (#18438)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
index a34b1ff470..54c030f967 100644
--- a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
+++ b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
@@ -20,772 +20,758 @@
  *
  */
 
 /**
  * @file lcd_lvgl_configuration.c
  * @date    2020-02-21
  */
 
 #include "../../../../inc/MarlinConfigPre.h"
 
-#if ENABLED(TFT_LITTLE_VGL_UI)
+#if ENABLED(TFT_LVGL_UI)
 
-  #include "../../../../MarlinCore.h"
+#include "../../../../MarlinCore.h"
 
-  #include "tft_lvgl_configuration.h"
-  #include "lvgl.h"
-  #include "../../../../feature/touch/xpt2046.h"
-  #include "draw_ready_print.h"
-  #include "W25Qxx.h"
-  #include "pic_manager.h"
+#include "tft_lvgl_configuration.h"
+#include "lvgl.h"
+#include "../../../../feature/touch/xpt2046.h"
+#include "draw_ready_print.h"
+#include "W25Qxx.h"
+#include "pic_manager.h"
 
-  #include "mks_hardware_test.h"
-  #include "draw_ui.h"
+#include "mks_hardware_test.h"
+#include "draw_ui.h"
 
-  #if ENABLED(POWER_LOSS_RECOVERY)
-    #include "../../../../feature/powerloss.h"
-  #endif
-
-  #include <SPI.h>
-
-  #if ENABLED(SPI_GRAPHICAL_TFT)
-    #include "SPI_TFT.h"
-  #endif
+#if ENABLED(POWER_LOSS_RECOVERY)
+  #include "../../../../feature/powerloss.h"
+#endif
 
-//#include "../../Configuration.h"
-//#include "../../src/core/macros.h"
+#include <SPI.h>
 
-  extern void LCD_IO_Init(uint8_t cs, uint8_t rs);
-  extern void LCD_IO_WriteData(uint16_t RegValue);
-  extern void LCD_IO_WriteReg(uint16_t Reg);
+#if ENABLED(SPI_GRAPHICAL_TFT)
+  #include "SPI_TFT.h"
+#endif
 
-  extern void LCD_IO_WriteMultiple(uint16_t color, uint32_t count);
+extern void LCD_IO_Init(uint8_t cs, uint8_t rs);
+extern void LCD_IO_WriteData(uint16_t RegValue);
+extern void LCD_IO_WriteReg(uint16_t Reg);
+extern void LCD_IO_WriteSequence(uint16_t *data, uint16_t length);
+extern void LCD_IO_WriteMultiple(uint16_t color, uint32_t count);
 
+#if HAS_SPI_FLASH_FONT
   extern void init_gb2312_font();
+#endif
 
-  static lv_disp_buf_t disp_buf;
-//static lv_color_t buf[LV_HOR_RES_MAX * 18];
-//static lv_color_t buf[10*5];
-//extern lv_obj_t * scr;
-  #if ENABLED(SDSUPPORT)
-    extern void UpdatePic();
+static lv_disp_buf_t disp_buf;
+#if ENABLED(SDSUPPORT)
+  extern void UpdatePic();
+  #if HAS_SPI_FLASH_FONT
     extern void UpdateFont();
   #endif
-  uint16_t DeviceCode = 0x9488;
-  extern uint8_t sel_id;
+#endif
+uint16_t DeviceCode = 0x9488;
+extern uint8_t sel_id;
+
+#define SetCs
+#define ClrCs
+
+#define HDP  799 // Horizontal Display Period
+#define HT  1000 // Horizontal Total
+#define HPS   51 // LLINE Pulse Start Position
+#define LPS    3 // Horizontal Display Period Start Position
+#define HPW    8 // LLINE Pulse Width
+
+#define VDP  479 // Vertical Display Period
+#define VT   530 // Vertical Total
+#define VPS   24 // LFRAME Pulse Start Position
+#define FPS   23 // Vertical Display Period Start Positio
+#define VPW    3 // LFRAME Pulse Width
+
+#define MAX_HZ_POSX HDP+1
+#define MAX_HZ_POSY VDP+1
+
+extern uint8_t gcode_preview_over, flash_preview_begin, default_preview_flg;
+
+void SysTick_Callback() {
+  lv_tick_inc(1);
+  print_time_count();
+}
+
+void tft_set_cursor(uint16_t x, uint16_t y) {
+  LCD_IO_WriteReg(0x002A);
+  LCD_IO_WriteData(x >> 8);
+  LCD_IO_WriteData(x & 0x00FF);
+  LCD_IO_WriteData(x >> 8);
+  LCD_IO_WriteData(x & 0x00FF);
+  //ILI9488_WriteData(0x01);
+  //ILI9488_WriteData(0xDF);
+  LCD_IO_WriteReg(0x002B);
+  LCD_IO_WriteData(y >> 8);
+  LCD_IO_WriteData(y & 0x00FF);
+  LCD_IO_WriteData(y >> 8);
+  LCD_IO_WriteData(y & 0x00FF);
+  //ILI9488_WriteData(0x01);
+  //ILI9488_WriteData(0x3F);
+}
+
+void LCD_WriteRAM_Prepare(void) {
+  #if 0
+  if ((DeviceCode == 0x9325) || (DeviceCode == 0x9328) || (DeviceCode == 0x8989)) {
+    ClrCs
+    LCD->LCD_REG = R34;
+    SetCs
+  }
+  else {
+    LCD_WrtReg(0x002C);
+  }
+  #else
+    LCD_IO_WriteReg(0x002C);
+  #endif
+}
+
+void tft_set_point(uint16_t x, uint16_t y, uint16_t point) {
+  //if (DeviceCode == 0x9488) {
+  if ((x > 480) || (y > 320)) return;
+  //}
+  //**if ( (x>320)||(y>240) ) return;
+  tft_set_cursor(x, y); /*设置光标位置*/
+
+  LCD_WriteRAM_Prepare();   /* 开始写入GRAM*/
+  //LCD_WriteRAM(point);
+  LCD_IO_WriteData(point);
+}
+
+void LCD_WriteReg(uint16_t LCD_Reg, uint16_t LCD_RegValue) {
+  /* Write 16-bit Index, then Write Reg */
+  ClrCs
+    LCD_IO_WriteReg(LCD_Reg);
+  /* Write 16-bit Reg */
+  LCD_IO_WriteData(LCD_RegValue);
+  SetCs
+}
+
+void ili9320_SetWindows(uint16_t StartX, uint16_t StartY, uint16_t width, uint16_t heigh) {
+  uint16_t s_h, s_l, e_h, e_l;
+  uint16_t xEnd, yEnd;
+  xEnd = StartX + width;
+  yEnd = StartY + heigh - 1;
+  if (DeviceCode == 0x8989) {
+    /*LCD_WriteReg(0x0044, (StartX & 0xFF) | (xEnd << 8));
+    LCD_WriteReg(0x0045, StartY);
+    LCD_WriteReg(0x0046, yEnd);*/
+    LCD_WriteReg(0x0044, (StartY & 0xFF) | (yEnd << 8));
+    LCD_WriteReg(0x0045, StartX);
+    LCD_WriteReg(0x0046, xEnd);
+  }
+  else if (DeviceCode == 0x9488) {
+    s_h = (StartX >> 8) & 0x00ff;
+    s_l = StartX & 0x00ff;
+    e_h = ((StartX + width - 1) >> 8) & 0x00ff;
+    e_l = (StartX + width - 1) & 0x00ff;
+
+    LCD_IO_WriteReg(0x002A);
+    LCD_IO_WriteData(s_h);
+    LCD_IO_WriteData(s_l);
+    LCD_IO_WriteData(e_h);
+    LCD_IO_WriteData(e_l);
+
+    s_h = (StartY >> 8) & 0x00ff;
+    s_l = StartY & 0x00ff;
+    e_h = ((StartY + heigh - 1) >> 8) & 0x00ff;
+    e_l = (StartY + heigh - 1) & 0x00ff;
+
+    LCD_IO_WriteReg(0x002B);
+    LCD_IO_WriteData(s_h);
+    LCD_IO_WriteData(s_l);
+    LCD_IO_WriteData(e_h);
+    LCD_IO_WriteData(e_l);
+  }
+  else if ((DeviceCode == 0x9325) || (DeviceCode == 0x9328) || (DeviceCode == 0x1505)) {
+    /* LCD_WriteReg(0x0050, StartX);
+     LCD_WriteReg(0x0052, StartY);
+     LCD_WriteReg(0x0051, xEnd);
+     LCD_WriteReg(0x0053, yEnd);*/
+    LCD_WriteReg(0x0050, StartY);      //Specify the start/end positions of the window address in the horizontal direction by an address unit
+    LCD_WriteReg(0x0051, yEnd);      //Specify the start positions of the window address in the vertical direction by an address unit
+    LCD_WriteReg(0x0052, 320 - xEnd);
+    LCD_WriteReg(0x0053, 320 - StartX - 1);      //Specify the end positions of the window address in the vertical direction by an address unit
 
-  #define SetCs
-  #define ClrCs
+  }
+  else {
+    s_h = (StartX >> 8) & 0xFF;
+    s_l = StartX & 0xFF;
+    e_h = ((StartX + width - 1) >> 8) & 0xFF;
+    e_l = (StartX + width - 1) & 0xFF;
+
+    LCD_IO_WriteReg(0x2A);
+    LCD_IO_WriteData(s_h);
+    LCD_IO_WriteData(s_l);
+    LCD_IO_WriteData(e_h);
+    LCD_IO_WriteData(e_l);
+
+    s_h = (StartY >> 8) & 0xFF;
+    s_l = StartY & 0xFF;
+    e_h = ((StartY + heigh - 1) >> 8) & 0xFF;
+    e_l = (StartY + heigh - 1) & 0xFF;
+
+    LCD_IO_WriteReg(0x2B);
+    LCD_IO_WriteData(s_h);
+    LCD_IO_WriteData(s_l);
+    LCD_IO_WriteData(e_h);
+    LCD_IO_WriteData(e_l);
+  }
+}
+
+void LCD_Clear(uint16_t Color) {
+  uint32_t index = 0;
+  unsigned int count;
+
+  if (DeviceCode == 0x9488) {
+    tft_set_cursor(0, 0);
+    ili9320_SetWindows(0, 0, 480, 320);
+    LCD_WriteRAM_Prepare();
+    #ifdef LCD_USE_DMA_FSMC
+      LCD_IO_WriteMultiple(Color, LCD_FULL_PIXEL_WIDTH * LCD_FULL_PIXEL_HEIGHT);
+    #else
+    //index = (160*480);
+    for (index = 0; index < 320 * 480; index++)
+      LCD_IO_WriteData(Color);
+    #endif
+    //LCD_IO_WriteMultiple(Color, (480*320));
+    //while(index --) LCD_IO_WriteData(Color);
+  }
+  else if (DeviceCode == 0x5761) {
+    LCD_IO_WriteReg(0x002a);
+    LCD_IO_WriteData(0);
+    LCD_IO_WriteData(0);
+    LCD_IO_WriteData(HDP >> 8);
+    LCD_IO_WriteData(HDP & 0x00ff);
+    LCD_IO_WriteReg(0x002b);
+    LCD_IO_WriteData(0);
+    LCD_IO_WriteData(0);
+    LCD_IO_WriteData(VDP >> 8);
+    LCD_IO_WriteData(VDP & 0x00ff);
+    LCD_IO_WriteReg(0x002c);
+    LCD_IO_WriteReg(0x002c);
+    for (count = 0; count < (HDP + 1) * (VDP + 1); count++)
+      LCD_IO_WriteData(Color);
+  }
+  else {
+    tft_set_cursor(0, 0);
+    LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
+    for (index = 0; index < 76800; index++)
+      LCD_IO_WriteData(Color);
+  }
+}
 
-  #define  HDP  799//Horizontal Display Period     //**
-  #define  HT   1000//Horizontal Total
-  #define  HPS  51//LLINE Pulse Start Position
-  #define  LPS  3 //  Horizontal Display Period Start Position
-  #define  HPW  8 //  LLINE Pulse Width
+extern uint16_t ILI9488_ReadRAM();
 
-  #define  VDP  479//Vertical Display Period
-  #define  VT   530//Vertical Total
-  #define  VPS  24//  LFRAME Pulse Start Position
-  #define  FPS  23//Vertical Display Period Start Positio
-  #define  VPW  3 // LFRAME Pulse Width     //**
+#if DISABLED(SPI_GRAPHICAL_TFT)
 
-  #define MAX_HZ_POSX HDP+1
-  #define MAX_HZ_POSY VDP+1
+void init_tft() {
+  uint16_t i;
+  //************* Start Initial Sequence **********//
 
-  extern uint8_t gcode_preview_over, flash_preview_begin, default_preview_flg;
+  //start lcd pins and dma
+  #if PIN_EXISTS(LCD_BACKLIGHT)
+    OUT_WRITE(LCD_BACKLIGHT_PIN, DISABLED(DELAYED_BACKLIGHT_INIT)); // Illuminate after reset or right away
+  #endif
 
-  void SysTick_Callback() {
-    lv_tick_inc(1);
-    print_time_count();
-  }
+  #if PIN_EXISTS(LCD_RESET)
+    // Perform a clean hardware reset with needed delays
+    OUT_WRITE(LCD_RESET_PIN, LOW);
+    _delay_ms(5);
+    WRITE(LCD_RESET_PIN, HIGH);
+    _delay_ms(5);
+  #endif
 
-  void tft_set_cursor(uint16_t x, uint16_t y) {
-    #if 0
-    if (DeviceCode == 0x8989) {
-      LCD_WriteReg(0x004E, y);        //行
-      LCD_WriteReg(0x004F, x);  //列
-    }
-    else if ((DeviceCode == 0x9919)) {
-      LCD_WriteReg(0x004E, x); // 行
-      LCD_WriteReg(0x004F, y); // 列
-    }
-    else if ((DeviceCode == 0x5761)) {    //SSD1963
-      LCD_WrtReg(0x002A);
-      LCD_WrtRAM(x >> 8);
-      LCD_WrtRAM(x & 0x00FF);
-      LCD_WrtRAM(HDP >> 8);
-      LCD_WrtRAM(HDP & 0x00FF);
-      LCD_WrtReg(0x002B);
-      LCD_WrtRAM(y >> 8);
-      LCD_WrtRAM(y & 0x00FF);
-      LCD_WrtRAM(VDP >> 8);
-      LCD_WrtRAM(VDP & 0x00FF);
-    }
-    else if (DeviceCode == 0x9488) {
-      ILI9488_WriteCmd(0x002A);
-      ILI9488_WriteData(x >> 8);
-      ILI9488_WriteData(x & 0x00FF);
-      ILI9488_WriteData(x >> 8);
-      ILI9488_WriteData(x & 0x00FF);
-      //ILI9488_WriteData(0x01);
-      //ILI9488_WriteData(0xDF);
-      ILI9488_WriteCmd(0x002B);
-      ILI9488_WriteData(y >> 8);
-      ILI9488_WriteData(y & 0x00FF);
-      ILI9488_WriteData(y >> 8);
-      ILI9488_WriteData(y & 0x00FF);
-      //ILI9488_WriteData(0x01);
-      //ILI9488_WriteData(0x3F);
-    }
-    else {
-      LCD_WriteReg(0x0020, y); // 行
-      LCD_WriteReg(0x0021, 0x13f - x); // 列
-    }
-    #else // if 0
-      LCD_IO_WriteReg(0x002A);
-      LCD_IO_WriteData(x >> 8);
-      LCD_IO_WriteData(x & 0x00FF);
-      LCD_IO_WriteData(x >> 8);
-      LCD_IO_WriteData(x & 0x00FF);
-      //ILI9488_WriteData(0x01);
-      //ILI9488_WriteData(0xDF);
-      LCD_IO_WriteReg(0x002B);
-      LCD_IO_WriteData(y >> 8);
-      LCD_IO_WriteData(y & 0x00FF);
-      LCD_IO_WriteData(y >> 8);
-      LCD_IO_WriteData(y & 0x00FF);
-      //ILI9488_WriteData(0x01);
-      //ILI9488_WriteData(0x3F);
-    #endif // if 0
-  }
+  #if PIN_EXISTS(LCD_BACKLIGHT) && ENABLED(DELAYED_BACKLIGHT_INIT)
+    WRITE(LCD_BACKLIGHT_PIN, HIGH);
+  #endif
 
-  void LCD_WriteRAM_Prepare(void) {
-    #if 0
-    if ((DeviceCode == 0x9325) || (DeviceCode == 0x9328) || (DeviceCode == 0x8989)) {
-      ClrCs
-      LCD->LCD_REG = R34;
-      SetCs
-    }
-    else {
-      LCD_WrtReg(0x002C);
-    }
-    #else
-      LCD_IO_WriteReg(0x002C);
-    #endif
-  }
+  TERN_(HAS_LCD_CONTRAST, refresh_contrast());
 
-  void tft_set_point(uint16_t x, uint16_t y, uint16_t point) {
-    //if (DeviceCode == 0x9488) {
-    if ((x > 480) || (y > 320)) return;
-    //}
-    //**if ( (x>320)||(y>240) ) return;
-    tft_set_cursor(x, y); /*设置光标位置*/
+  #ifdef LCD_USE_DMA_FSMC
+    dma_init(FSMC_DMA_DEV);
+    dma_disable(FSMC_DMA_DEV, FSMC_DMA_CHANNEL);
+    dma_set_priority(FSMC_DMA_DEV, FSMC_DMA_CHANNEL, DMA_PRIORITY_MEDIUM);
+  #endif
 
-    LCD_WriteRAM_Prepare();   /* 开始写入GRAM*/
-    //LCD_WriteRAM(point);
-    LCD_IO_WriteData(point);
-  }
+  LCD_IO_Init(FSMC_CS_PIN, FSMC_RS_PIN);
+
+  _delay_ms(5);
+
+  LCD_IO_WriteReg(0x00D3);
+  DeviceCode = ILI9488_ReadRAM(); //dummy read
+  DeviceCode = ILI9488_ReadRAM();
+  DeviceCode = ILI9488_ReadRAM();
+  DeviceCode <<= 8;
+  DeviceCode |= ILI9488_ReadRAM();
+
+  if (DeviceCode == 0x9488) {
+    LCD_IO_WriteReg(0x00E0);
+    LCD_IO_WriteData(0x0000);
+    LCD_IO_WriteData(0x0007);
+    LCD_IO_WriteData(0x000f);
+    LCD_IO_WriteData(0x000D);
+    LCD_IO_WriteData(0x001B);
+    LCD_IO_WriteData(0x000A);
+    LCD_IO_WriteData(0x003c);
+    LCD_IO_WriteData(0x0078);
+    LCD_IO_WriteData(0x004A);
+    LCD_IO_WriteData(0x0007);
+    LCD_IO_WriteData(0x000E);
+    LCD_IO_WriteData(0x0009);
+    LCD_IO_WriteData(0x001B);
+    LCD_IO_WriteData(0x001e);
+    LCD_IO_WriteData(0x000f);
+
+    LCD_IO_WriteReg(0x00E1);
+    LCD_IO_WriteData(0x0000);
+    LCD_IO_WriteData(0x0022);
+    LCD_IO_WriteData(0x0024);
+    LCD_IO_WriteData(0x0006);
+    LCD_IO_WriteData(0x0012);
+    LCD_IO_WriteData(0x0007);
+    LCD_IO_WriteData(0x0036);
+    LCD_IO_WriteData(0x0047);
+    LCD_IO_WriteData(0x0047);
+    LCD_IO_WriteData(0x0006);
+    LCD_IO_WriteData(0x000a);
+    LCD_IO_WriteData(0x0007);
+    LCD_IO_WriteData(0x0030);
+    LCD_IO_WriteData(0x0037);
+    LCD_IO_WriteData(0x000f);
+
+    LCD_IO_WriteReg(0x00C0);
+    LCD_IO_WriteData(0x0010);
+    LCD_IO_WriteData(0x0010);
+
+    LCD_IO_WriteReg(0x00C1);
+    LCD_IO_WriteData(0x0041);
+
+    LCD_IO_WriteReg(0x00C5);
+    LCD_IO_WriteData(0x0000);
+    LCD_IO_WriteData(0x0022);
+    LCD_IO_WriteData(0x0080);
+
+    LCD_IO_WriteReg(0x0036);
+    //ILI9488_WriteData(0x0068);
+    //if (gCfgItems.overturn_180 != 0xEE)
+    //{
+    LCD_IO_WriteData(0x0068);
+    //}
+    //else
+    //{
+    //ILI9488_WriteData(0x00A8);
+    //}
 
-  void LCD_WriteReg(uint16_t LCD_Reg, uint16_t LCD_RegValue) {
-    /* Write 16-bit Index, then Write Reg */
-    ClrCs
-      LCD_IO_WriteReg(LCD_Reg);
-    /* Write 16-bit Reg */
-    LCD_IO_WriteData(LCD_RegValue);
-    SetCs
-  }
+    LCD_IO_WriteReg(0x003A); //Interface Mode Control
+    LCD_IO_WriteData(0x0055);
 
-  void ili9320_SetWindows(uint16_t StartX, uint16_t StartY, uint16_t width, uint16_t heigh) {
-    uint16_t s_h, s_l, e_h, e_l;
-
-    uint16_t xEnd, yEnd;
-    xEnd = StartX + width;
-    yEnd = StartY + heigh - 1;
-    if (DeviceCode == 0x8989) {
-      /*LCD_WriteReg(0x0044, (StartX & 0xFF) | (xEnd << 8));
-      LCD_WriteReg(0x0045, StartY);
-      LCD_WriteReg(0x0046, yEnd);*/
-      LCD_WriteReg(0x0044, (StartY & 0xFF) | (yEnd << 8));
-      LCD_WriteReg(0x0045, StartX);
-      LCD_WriteReg(0x0046, xEnd);
-    }
-    else if (DeviceCode == 0x9488) {
-      s_h = (StartX >> 8) & 0x00ff;
-      s_l = StartX & 0x00ff;
-      e_h = ((StartX + width - 1) >> 8) & 0x00ff;
-      e_l = (StartX + width - 1) & 0x00ff;
-
-      LCD_IO_WriteReg(0x002A);
-      LCD_IO_WriteData(s_h);
-      LCD_IO_WriteData(s_l);
-      LCD_IO_WriteData(e_h);
-      LCD_IO_WriteData(e_l);
-
-      s_h = (StartY >> 8) & 0x00ff;
-      s_l = StartY & 0x00ff;
-      e_h = ((StartY + heigh - 1) >> 8) & 0x00ff;
-      e_l = (StartY + heigh - 1) & 0x00ff;
-
-      LCD_IO_WriteReg(0x002B);
-      LCD_IO_WriteData(s_h);
-      LCD_IO_WriteData(s_l);
-      LCD_IO_WriteData(e_h);
-      LCD_IO_WriteData(e_l);
-    }
-    else if ((DeviceCode == 0x9325) || (DeviceCode == 0x9328) || (DeviceCode == 0x1505)) {
-      /* LCD_WriteReg(0x0050, StartX);
-       LCD_WriteReg(0x0052, StartY);
-       LCD_WriteReg(0x0051, xEnd);
-       LCD_WriteReg(0x0053, yEnd);*/
-      LCD_WriteReg(0x0050, StartY);      //Specify the start/end positions of the window address in the horizontal direction by an address unit
-      LCD_WriteReg(0x0051, yEnd);      //Specify the start positions of the window address in the vertical direction by an address unit
-      LCD_WriteReg(0x0052, 320 - xEnd);
-      LCD_WriteReg(0x0053, 320 - StartX - 1);      //Specify the end positions of the window address in the vertical direction by an address unit
+    LCD_IO_WriteReg(0x00B0);  //Interface Mode Control
+    LCD_IO_WriteData(0x0000);
+    LCD_IO_WriteReg(0x00B1);   //Frame rate 70HZ
+    LCD_IO_WriteData(0x00B0);
+    LCD_IO_WriteData(0x0011);
+    LCD_IO_WriteReg(0x00B4);
+    LCD_IO_WriteData(0x0002);
+    LCD_IO_WriteReg(0x00B6); //RGB/MCU Interface Control
+    LCD_IO_WriteData(0x0002);
+    LCD_IO_WriteData(0x0042);
 
-    }
-    else {
-      s_h = (StartX >> 8) & 0xFF;
-      s_l = StartX & 0xFF;
-      e_h = ((StartX + width - 1) >> 8) & 0xFF;
-      e_l = (StartX + width - 1) & 0xFF;
-
-      LCD_IO_WriteReg(0x2A);
-      LCD_IO_WriteData(s_h);
-      LCD_IO_WriteData(s_l);
-      LCD_IO_WriteData(e_h);
-      LCD_IO_WriteData(e_l);
-
-      s_h = (StartY >> 8) & 0xFF;
-      s_l = StartY & 0xFF;
-      e_h = ((StartY + heigh - 1) >> 8) & 0xFF;
-      e_l = (StartY + heigh - 1) & 0xFF;
-
-      LCD_IO_WriteReg(0x2B);
-      LCD_IO_WriteData(s_h);
-      LCD_IO_WriteData(s_l);
-      LCD_IO_WriteData(e_h);
-      LCD_IO_WriteData(e_l);
-    }
-  }
+    LCD_IO_WriteReg(0x00B7);
+    LCD_IO_WriteData(0x00C6);
 
-  void LCD_Clear(uint16_t Color) {
-    uint32_t index = 0;
-    unsigned int count;
+    //WriteComm(0xBE);
+    //WriteData(0x00);
+    //WriteData(0x04);
 
-    if (DeviceCode == 0x9488) {
-      tft_set_cursor(0, 0);
-      ili9320_SetWindows(0, 0, 480, 320);
-      LCD_WriteRAM_Prepare();
-      //index = (160*480);
-      for (index = 0; index < 320 * 480; index++)
-        LCD_IO_WriteData(Color);
-      //LCD_IO_WriteMultiple(Color, (480*320));
-      //while(index --) LCD_IO_WriteData(Color);
-    }
-    else if (DeviceCode == 0x5761) {
-      LCD_IO_WriteReg(0x002a);
-      LCD_IO_WriteData(0);
-      LCD_IO_WriteData(0);
-      LCD_IO_WriteData(HDP >> 8);
-      LCD_IO_WriteData(HDP & 0x00ff);
-      LCD_IO_WriteReg(0x002b);
-      LCD_IO_WriteData(0);
-      LCD_IO_WriteData(0);
-      LCD_IO_WriteData(VDP >> 8);
-      LCD_IO_WriteData(VDP & 0x00ff);
-      LCD_IO_WriteReg(0x002c);
-      LCD_IO_WriteReg(0x002c);
-      for (count = 0; count < (HDP + 1) * (VDP + 1); count++)
-        LCD_IO_WriteData(Color);
-    }
-    else {
-      tft_set_cursor(0, 0);
-      LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
-      for (index = 0; index < 76800; index++)
-        LCD_IO_WriteData(Color);
-    }
-  }
+    LCD_IO_WriteReg(0x00E9);
+    LCD_IO_WriteData(0x0000);
 
-  extern uint16_t ILI9488_ReadRAM();
+    LCD_IO_WriteReg(0x00F7);
+    LCD_IO_WriteData(0x00A9);
+    LCD_IO_WriteData(0x0051);
+    LCD_IO_WriteData(0x002C);
+    LCD_IO_WriteData(0x0082);
 
-  #if DISABLED(SPI_GRAPHICAL_TFT)
+    LCD_IO_WriteReg(0x0011);
+    for (i = 0; i < 65535; i++);
+    LCD_IO_WriteReg(0x0029);
 
-  void init_tft() {
-    uint16_t i;
-    //************* Start Initial Sequence **********//
+    ili9320_SetWindows(0, 0, 480, 320);
+    LCD_Clear(0x0000);
 
-    LCD_IO_Init(FSMC_CS_PIN, FSMC_RS_PIN);
+    OUT_WRITE(LCD_BACKLIGHT_PIN, HIGH);
+  }
+}
 
-    _delay_ms(5);
+#endif // if DISABLED(SPI_GRAPHICAL_TFT)
 
-    LCD_IO_WriteReg(0x00D3);
-    DeviceCode = ILI9488_ReadRAM(); //dummy read
-    DeviceCode = ILI9488_ReadRAM();
-    DeviceCode = ILI9488_ReadRAM();
-    DeviceCode <<= 8;
-    DeviceCode |= ILI9488_ReadRAM();
-
-    if (DeviceCode == 0x9488) {
-      LCD_IO_WriteReg(0x00E0);
-      LCD_IO_WriteData(0x0000);
-      LCD_IO_WriteData(0x0007);
-      LCD_IO_WriteData(0x000f);
-      LCD_IO_WriteData(0x000D);
-      LCD_IO_WriteData(0x001B);
-      LCD_IO_WriteData(0x000A);
-      LCD_IO_WriteData(0x003c);
-      LCD_IO_WriteData(0x0078);
-      LCD_IO_WriteData(0x004A);
-      LCD_IO_WriteData(0x0007);
-      LCD_IO_WriteData(0x000E);
-      LCD_IO_WriteData(0x0009);
-      LCD_IO_WriteData(0x001B);
-      LCD_IO_WriteData(0x001e);
-      LCD_IO_WriteData(0x000f);
-
-      LCD_IO_WriteReg(0x00E1);
-      LCD_IO_WriteData(0x0000);
-      LCD_IO_WriteData(0x0022);
-      LCD_IO_WriteData(0x0024);
-      LCD_IO_WriteData(0x0006);
-      LCD_IO_WriteData(0x0012);
-      LCD_IO_WriteData(0x0007);
-      LCD_IO_WriteData(0x0036);
-      LCD_IO_WriteData(0x0047);
-      LCD_IO_WriteData(0x0047);
-      LCD_IO_WriteData(0x0006);
-      LCD_IO_WriteData(0x000a);
-      LCD_IO_WriteData(0x0007);
-      LCD_IO_WriteData(0x0030);
-      LCD_IO_WriteData(0x0037);
-      LCD_IO_WriteData(0x000f);
-
-      LCD_IO_WriteReg(0x00C0);
-      LCD_IO_WriteData(0x0010);
-      LCD_IO_WriteData(0x0010);
-
-      LCD_IO_WriteReg(0x00C1);
-      LCD_IO_WriteData(0x0041);
-
-      LCD_IO_WriteReg(0x00C5);
-      LCD_IO_WriteData(0x0000);
-      LCD_IO_WriteData(0x0022);
-      LCD_IO_WriteData(0x0080);
-
-      LCD_IO_WriteReg(0x0036);
-      //ILI9488_WriteData(0x0068);
-      //if (gCfgItems.overturn_180 != 0xEE)
-      //{
-      LCD_IO_WriteData(0x0068);
-      //}
-      //else
-      //{
-      //ILI9488_WriteData(0x00A8);
-      //}
-
-      LCD_IO_WriteReg(0x003A); //Interface Mode Control
-      LCD_IO_WriteData(0x0055);
-
-      LCD_IO_WriteReg(0x00B0);  //Interface Mode Control
-      LCD_IO_WriteData(0x0000);
-      LCD_IO_WriteReg(0x00B1);   //Frame rate 70HZ
-      LCD_IO_WriteData(0x00B0);
-      LCD_IO_WriteData(0x0011);
-      LCD_IO_WriteReg(0x00B4);
-      LCD_IO_WriteData(0x0002);
-      LCD_IO_WriteReg(0x00B6); //RGB/MCU Interface Control
-      LCD_IO_WriteData(0x0002);
-      LCD_IO_WriteData(0x0042);
-
-      LCD_IO_WriteReg(0x00B7);
-      LCD_IO_WriteData(0x00C6);
-
-      //WriteComm(0xBE);
-      //WriteData(0x00);
-      //WriteData(0x04);
-
-      LCD_IO_WriteReg(0x00E9);
-      LCD_IO_WriteData(0x0000);
-
-      LCD_IO_WriteReg(0x00F7);
-      LCD_IO_WriteData(0x00A9);
-      LCD_IO_WriteData(0x0051);
-      LCD_IO_WriteData(0x002C);
-      LCD_IO_WriteData(0x0082);
-
-      LCD_IO_WriteReg(0x0011);
-      for (i = 0; i < 65535; i++);
-      LCD_IO_WriteReg(0x0029);
-
-      ili9320_SetWindows(0, 0, 480, 320);
-      LCD_Clear(0x0000);
-
-      OUT_WRITE(LCD_BACKLIGHT_PIN, HIGH);
-    }
-  }
+extern uint8_t bmp_public_buf[17 * 1024];
+void tft_lvgl_init() {
+  //uint16_t test_id=0;
+  W25QXX.init(SPI_QUARTER_SPEED);
+  //test_id=W25QXX.W25QXX_ReadID();
 
-  #endif // if DISABLED(SPI_GRAPHICAL_TFT)
+  //init tft first!
+  #if ENABLED(SPI_GRAPHICAL_TFT)
+    SPI_TFT.spi_init(SPI_FULL_SPEED);
+    SPI_TFT.LCD_init();
+  #else
+    init_tft();
+  #endif
 
-  extern uint8_t bmp_public_buf[17 * 1024];
-  void tft_lvgl_init() {
-    //uint16_t test_id=0;
-    W25QXX.init(SPI_QUARTER_SPEED);
-    //test_id=W25QXX.W25QXX_ReadID();
-    #if ENABLED(SDSUPPORT)
-      UpdatePic();
+  #if ENABLED(SDSUPPORT)
+    UpdatePic();
+    #if HAS_SPI_FLASH_FONT
       UpdateFont();
     #endif
+  #endif
 
-    gCfgItems_init();
-    ui_cfg_init();
-    disp_language_init();
-    //spi_flash_read_test();
+  gCfgItems_init();
+  ui_cfg_init();
+  disp_language_init();
+  //spi_flash_read_test();
 
-    #if ENABLED(SPI_GRAPHICAL_TFT)
-      SPI_TFT.spi_init(SPI_FULL_SPEED);
-      SPI_TFT.LCD_init();
-    #else
-      init_tft();
-    #endif
+  #if ENABLED(TOUCH_BUTTONS)
+    touch.init();
+  #endif
 
-    lv_init();
+  lv_init();
 
-    lv_disp_buf_init(&disp_buf, bmp_public_buf, NULL, LV_HOR_RES_MAX * 18); /*Initialize the display buffer*/
+  lv_disp_buf_init(&disp_buf, bmp_public_buf, NULL, LV_HOR_RES_MAX * 18); /*Initialize the display buffer*/
 
-    lv_disp_drv_t disp_drv;     /*Descriptor of a display driver*/
-    lv_disp_drv_init(&disp_drv);    /*Basic initialization*/
-    disp_drv.flush_cb = my_disp_flush; /*Set your driver function*/
-    disp_drv.buffer = &disp_buf;    /*Assign the buffer to the display*/
-    lv_disp_drv_register(&disp_drv);  /*Finally register the driver*/
+  lv_disp_drv_t disp_drv;     /*Descriptor of a display driver*/
+  lv_disp_drv_init(&disp_drv);    /*Basic initialization*/
+  disp_drv.flush_cb = my_disp_flush; /*Set your driver function*/
+  disp_drv.buffer = &disp_buf;    /*Assign the buffer to the display*/
+  lv_disp_drv_register(&disp_drv);  /*Finally register the driver*/
 
-    lv_indev_drv_t indev_drv;
-    lv_indev_drv_init(&indev_drv);     /*Descriptor of a input device driver*/
-    indev_drv.type = LV_INDEV_TYPE_POINTER; /*Touch pad is a pointer-like device*/
-    indev_drv.read_cb = my_touchpad_read;  /*Set your driver function*/
-    lv_indev_drv_register(&indev_drv);   /*Finally register the driver*/
+  lv_indev_drv_t indev_drv;
+  lv_indev_drv_init(&indev_drv);     /*Descriptor of a input device driver*/
+  indev_drv.type = LV_INDEV_TYPE_POINTER; /*Touch pad is a pointer-like device*/
+  indev_drv.read_cb = my_touchpad_read;  /*Set your driver function*/
+  lv_indev_drv_register(&indev_drv);   /*Finally register the driver*/
 
-    systick_attach_callback(SysTick_Callback);
+  systick_attach_callback(SysTick_Callback);
 
+  #if HAS_SPI_FLASH_FONT
     init_gb2312_font();
+  #endif
 
-    tft_style_init();
-
-    filament_pin_setup();
+  tft_style_init();
 
-    #if ENABLED(POWER_LOSS_RECOVERY)
-    if (recovery.valid()) {
-      if (gCfgItems.from_flash_pic == 1)
-        flash_preview_begin = 1;
-      else
-        default_preview_flg = 1;
+  filament_pin_setup();
 
-      uiCfg.print_state = REPRINTING;
+  #if ENABLED(POWER_LOSS_RECOVERY)
+  if (recovery.valid()) {
+    if (gCfgItems.from_flash_pic == 1)
+      flash_preview_begin = 1;
+    else
+      default_preview_flg = 1;
 
-      memset(public_buf_m, 0, sizeof(public_buf_m));
-      strncpy(public_buf_m, recovery.info.sd_filename, sizeof(public_buf_m));
-      card.printLongPath(public_buf_m);
+    uiCfg.print_state = REPRINTING;
 
-      strncpy(list_file.long_name[sel_id], card.longFilename, sizeof(list_file.long_name[sel_id]));
+    memset(public_buf_m, 0, sizeof(public_buf_m));
+    strncpy(public_buf_m, recovery.info.sd_filename, sizeof(public_buf_m));
+    card.printLongPath(public_buf_m);
 
-      lv_draw_printing();
-    }
-    else
-    #endif
-    lv_draw_ready_print();
+    strncpy(list_file.long_name[sel_id], card.longFilename, sizeof(list_file.long_name[sel_id]));
 
-    #if ENABLED(MKS_TEST)
-      Test_GPIO();
-    #endif
+    lv_draw_printing();
   }
+  else
+  #endif
+  lv_draw_ready_print();
 
-  #if 0
-  void LCD_WriteRAM(uint16_t RGB_Code) {
-    #if 0
-      ClrCs
-      /* Write 16-bit GRAM Reg */
-      LCD->LCD_RAM = RGB_Code;
-      SetCs
-    #else
-      LCD_IO_WriteData(RGB_Code);
-    #endif
-  }
+  #if ENABLED(MKS_TEST)
+    Test_GPIO();
   #endif
+}
 
-  void my_disp_flush(lv_disp_drv_t * disp, const lv_area_t * area, lv_color_t * color_p) {
-    #if ENABLED(SPI_GRAPHICAL_TFT)
-      uint16_t i, width, height;
-      uint16_t clr_temp;
-      uint8_t tbuf[480 * 2];
+void my_disp_flush(lv_disp_drv_t * disp, const lv_area_t * area, lv_color_t * color_p) {
+  #if ENABLED(SPI_GRAPHICAL_TFT)
+    uint16_t i, width, height;
+    uint16_t clr_temp;
+    uint8_t tbuf[480 * 2];
+
+    SPI_TFT.spi_init(SPI_FULL_SPEED);
+
+    width = area->x2 - area->x1 + 1;
+    height = area->y2 - area->y1 + 1;
+
+    for (int j = 0; j < height; j++) {
+      SPI_TFT.SetCursor(0, 0);
+      SPI_TFT.SetWindows((uint16_t)area->x1, (uint16_t)area->y1 + j, width, 1);
+      SPI_TFT.LCD_WriteRAM_Prepare();
+
+      for (i = 0; i < width * 2;) {
+        clr_temp = (uint16_t)(((uint16_t)color_p->ch.red << 11)
+                              | ((uint16_t)color_p->ch.green << 5)
+                              | ((uint16_t)color_p->ch.blue));
 
-      SPI_TFT.spi_init(SPI_FULL_SPEED);
+        tbuf[i] = clr_temp >> 8;
+        tbuf[i + 1] = clr_temp;
+        i += 2;
+        color_p++;
+      }
+      SPI_TFT_CS_L;
+      SPI_TFT_DC_H;
+      SPI.dmaSend(tbuf, width * 2, true);
+      SPI_TFT_CS_H;
+    }
+
+    lv_disp_flush_ready(disp);       /* Indicate you are ready with the flushing*/
 
+    W25QXX.init(SPI_QUARTER_SPEED);
+  #else
+    #if 1
+      uint16_t i, width, height;
+      uint16_t clr_temp;
       width = area->x2 - area->x1 + 1;
       height = area->y2 - area->y1 + 1;
-
-      for (int j = 0; j < height; j++) {
-        SPI_TFT.SetCursor(0, 0);
-        SPI_TFT.SetWindows((uint16_t)area->x1, (uint16_t)area->y1 + j, width, 1);
-        SPI_TFT.LCD_WriteRAM_Prepare();
-
-        for (i = 0; i < width * 2;) {
-          clr_temp = (uint16_t)(((uint16_t)color_p->ch.red << 11)
-                                | ((uint16_t)color_p->ch.green << 5)
-                                | ((uint16_t)color_p->ch.blue));
-
-          tbuf[i] = clr_temp >> 8;
-          tbuf[i + 1] = clr_temp;
-          i += 2;
-          color_p++;
-        }
-        SPI_TFT_CS_L;
-        SPI_TFT_DC_H;
-        SPI.dmaSend(tbuf, width * 2, true);
-        SPI_TFT_CS_H;
+      ili9320_SetWindows((uint16_t)area->x1, (uint16_t)area->y1, width, height);
+      LCD_WriteRAM_Prepare();
+      for (i = 0; i < width * height - 2; i++) {
+        clr_temp = (uint16_t)(((uint16_t)color_p->ch.red << 11)
+                              | ((uint16_t)color_p->ch.green << 5)
+                              | ((uint16_t)color_p->ch.blue));
+        LCD_IO_WriteData(clr_temp);
+        color_p++;
       }
 
       lv_disp_flush_ready(disp);       /* Indicate you are ready with the flushing*/
+    #endif
+  #endif // SPI_GRAPHICAL_TFT
+}
 
-      W25QXX.init(SPI_QUARTER_SPEED);
-    #else
-      #if 1
-        uint16_t i, width, height;
-        uint16_t clr_temp;
-        #if 0
-          int32_t x, y;
-          for (y = area->y1; y <= area->y2; y++)
-            for (x = area->x1; x <= area->x2; x++) {
-              //set_pixel(x, y, *color_p);  /* Put a pixel to the display.*/
-              clr_temp = (uint16_t)(((uint16_t)color_p->ch.red << 11)
-                                    | ((uint16_t)color_p->ch.green << 5)
-                                    | ((uint16_t)color_p->ch.blue));
-              tft_set_point(x, y, clr_temp);
-              color_p++;
-            }
-
-        #else
-          width = area->x2 - area->x1 + 1;
-          height = area->y2 - area->y1 + 1;
-          //tft_set_cursor((uint16_t)area->x1,(uint16_t)area->y1);
-          ili9320_SetWindows((uint16_t)area->x1, (uint16_t)area->y1, width, height);
-          LCD_WriteRAM_Prepare();
-          for (i = 0; i < width * height; i++) {
-            clr_temp = (uint16_t)(((uint16_t)color_p->ch.red << 11)
-                                  | ((uint16_t)color_p->ch.green << 5)
-                                  | ((uint16_t)color_p->ch.blue));
-            LCD_IO_WriteData(clr_temp);
-            color_p++;
-          }
-        #endif
-
-        lv_disp_flush_ready(disp);       /* Indicate you are ready with the flushing*/
-      #endif
-    #endif // SPI_GRAPHICAL_TFT
-  }
-
-  #define TICK_CYCLE 1
+#define TICK_CYCLE 1
 
-  static int32_t touch_time1 = 0;
+static int32_t touch_time1 = 0;
 
-  unsigned int  getTickDiff(unsigned int curTick, unsigned int lastTick) {
-    if (lastTick <= curTick)
-      return (curTick - lastTick) * TICK_CYCLE;
-    else
-      return (0xFFFFFFFF - lastTick + curTick) * TICK_CYCLE;
-  }
+unsigned int getTickDiff(unsigned int curTick, unsigned int lastTick) {
+  return TICK_CYCLE * (lastTick <= curTick ? (curTick - lastTick) : (0xFFFFFFFF - lastTick + curTick));
+}
 
-  #if ENABLED(SPI_GRAPHICAL_TFT)
+#if ENABLED(SPI_GRAPHICAL_TFT)
 
-    #ifndef USE_XPT2046
-      #define USE_XPT2046       1
-      #define XPT2046_XY_SWAP   1
-      #define XPT2046_X_INV     1
-      #define XPT2046_Y_INV     0
-    #endif
+  #ifndef USE_XPT2046
+    #define USE_XPT2046       1
+    #define XPT2046_XY_SWAP   1
+    #define XPT2046_X_INV     1
+    #define XPT2046_Y_INV     0
+  #endif
 
-    #if USE_XPT2046
-      #define XPT2046_HOR_RES   480
-      #define XPT2046_VER_RES   320
-      #define XPT2046_X_MIN     201
-      #define XPT2046_Y_MIN     164
-      #define XPT2046_X_MAX     3919
-      #define XPT2046_Y_MAX     3776
-      #define XPT2046_AVG       4
-      #define XPT2046_INV       1
-    #endif
+  #if USE_XPT2046
+    #define XPT2046_HOR_RES   480
+    #define XPT2046_VER_RES   320
+    #define XPT2046_X_MIN     201
+    #define XPT2046_Y_MIN     164
+    #define XPT2046_X_MAX     3919
+    #define XPT2046_Y_MAX     3776
+    #define XPT2046_AVG       4
+    #define XPT2046_INV       1
+  #endif
 
-  #else
+#else
 
-    #ifndef USE_XPT2046
-      #define USE_XPT2046       1
+  #ifndef USE_XPT2046
+    #define USE_XPT2046       1
+    #ifndef XPT2046_XY_SWAP
       #define XPT2046_XY_SWAP   1
+    #endif
+    #ifndef XPT2046_X_INV
       #define XPT2046_X_INV     0
+    #endif
+    #ifndef XPT2046_Y_INV
       #define XPT2046_Y_INV     1
     #endif
+  #endif
 
-    #if USE_XPT2046
+  #if USE_XPT2046
+    #ifndef XPT2046_HOR_RES   480
       #define XPT2046_HOR_RES   480
+    #endif
+    #ifndef XPT2046_VER_RES
       #define XPT2046_VER_RES   320
+    #endif
+    #ifndef XPT2046_X_MIN
       #define XPT2046_X_MIN     201
+    #endif
+    #ifndef XPT2046_Y_MIN
       #define XPT2046_Y_MIN     164
+    #endif
+    #ifndef XPT2046_X_MAX
       #define XPT2046_X_MAX     3919
+    #endif
+    #ifndef XPT2046_Y_MAX
       #define XPT2046_Y_MAX     3776
+    #endif
+    #ifndef XPT2046_AVG
       #define XPT2046_AVG       4
+    #endif
+    #ifndef XPT2046_INV
       #define XPT2046_INV       0
     #endif
+  #endif
 
+#endif
+
+static void xpt2046_corr(uint16_t *x, uint16_t *y) {
+  #if XPT2046_XY_SWAP
+    int16_t swap_tmp;
+    swap_tmp = *x;
+    *x = *y;
+    *y = swap_tmp;
+  #endif
+  if ((*x) > XPT2046_X_MIN) (*x) -= XPT2046_X_MIN; else (*x) = 0;
+  if ((*y) > XPT2046_Y_MIN) (*y) -= XPT2046_Y_MIN; else (*y) = 0;
+  (*x) = uint32_t(uint32_t(*x) * XPT2046_HOR_RES) / (XPT2046_X_MAX - XPT2046_X_MIN);
+  (*y) = uint32_t(uint32_t(*y) * XPT2046_VER_RES) / (XPT2046_Y_MAX - XPT2046_Y_MIN);
+  #if XPT2046_X_INV
+    (*x) = XPT2046_HOR_RES - (*x);
   #endif
+  #if XPT2046_Y_INV
+    (*y) = XPT2046_VER_RES - (*y);
+  #endif
+}
 
-  static void xpt2046_corr(uint16_t *x, uint16_t *y) {
-    #if XPT2046_XY_SWAP
-      int16_t swap_tmp;
-      swap_tmp = *x;
-      *x = *y;
-      *y = swap_tmp;
-    #endif
-    if ((*x) > XPT2046_X_MIN) (*x) -= XPT2046_X_MIN; else (*x) = 0;
-    if ((*y) > XPT2046_Y_MIN) (*y) -= XPT2046_Y_MIN; else (*y) = 0;
-    (*x) = uint32_t(uint32_t(*x) * XPT2046_HOR_RES) / (XPT2046_X_MAX - XPT2046_X_MIN);
-    (*y) = uint32_t(uint32_t(*y) * XPT2046_VER_RES) / (XPT2046_Y_MAX - XPT2046_Y_MIN);
-    #if XPT2046_X_INV
-      (*x) = XPT2046_HOR_RES - (*x);
-    #endif
-    #if XPT2046_Y_INV
-      (*y) = XPT2046_VER_RES - (*y);
-    #endif
-  }
+#define  times  4
+#define CHX   0x90
+#define CHY   0xD0
 
-  #define  times  4
-  #define CHX   0x90// 0x90
-  #define CHY   0xD0// 0xD0
+int SPI2_ReadWrite2Bytes(void) {
+  volatile uint16_t ans = 0;
+  uint16_t temp = 0;
+  #if ENABLED(SPI_GRAPHICAL_TFT)
+    temp = SPI_TFT.spi_read_write_byte(0xFF);
+    ans = temp << 8;
+    temp = SPI_TFT.spi_read_write_byte(0xFF);
+    ans |= temp;
+    ans >>= 3;
+  #else
+    temp = W25QXX.spi_flash_read_write_byte(0xFF);
+    ans = temp << 8;
+    temp = W25QXX.spi_flash_read_write_byte(0xFF);
+    ans |= temp;
+    ans >>= 3;
+  #endif
+  return ans & 0x0FFF;
+}
 
-  int SPI2_ReadWrite2Bytes(void) {
-    volatile uint16_t ans = 0;
-    uint16_t temp = 0;
-    #if ENABLED(SPI_GRAPHICAL_TFT)
-      temp = SPI_TFT.spi_read_write_byte(0xFF);
-      ans = temp << 8;
-      temp = SPI_TFT.spi_read_write_byte(0xFF);
-      ans |= temp;
-      ans >>= 3;
-    #else
-      temp = W25QXX.spi_flash_read_write_byte(0xFF);
-      ans = temp << 8;
-      temp = W25QXX.spi_flash_read_write_byte(0xFF);
-      ans |= temp;
-      ans >>= 3;
-    #endif
-    return ans & 0x0FFF;
-  }
+uint16_t x_addata[times], y_addata[times];
+void XPT2046_Rd_Addata(uint16_t *X_Addata, uint16_t *Y_Addata) {
+  uint16_t i, j, k;
 
-  uint16_t x_addata[times], y_addata[times];
-  void XPT2046_Rd_Addata(uint16_t *X_Addata, uint16_t *Y_Addata) {
-    uint16_t i, j, k;
-    //int result;
-    //#if ENABLED(TOUCH_BUTTONS)
+  #if ENABLED(SPI_GRAPHICAL_TFT)
+    SPI_TFT.spi_init(SPI_QUARTER_SPEED);
+  #endif
 
+  for (i = 0; i < times; i++) {
     #if ENABLED(SPI_GRAPHICAL_TFT)
-      SPI_TFT.spi_init(SPI_QUARTER_SPEED);
+      OUT_WRITE(TOUCH_CS_PIN, LOW);
+      SPI_TFT.spi_read_write_byte(CHX);
+      y_addata[i] = SPI2_ReadWrite2Bytes();
+      WRITE(TOUCH_CS_PIN, HIGH);
+
+      OUT_WRITE(TOUCH_CS_PIN, LOW);
+      SPI_TFT.spi_read_write_byte(CHY);
+      x_addata[i] = SPI2_ReadWrite2Bytes();
+      WRITE(TOUCH_CS_PIN, HIGH);
+    #else // #if ENABLED(TOUCH_BUTTONS)
+      OUT_WRITE(TOUCH_CS_PIN, LOW);
+      W25QXX.spi_flash_read_write_byte(CHX);
+      y_addata[i] = SPI2_ReadWrite2Bytes();
+      WRITE(TOUCH_CS_PIN, HIGH);
+
+      OUT_WRITE(TOUCH_CS_PIN, LOW);
+      W25QXX.spi_flash_read_write_byte(CHY);
+      x_addata[i] = SPI2_ReadWrite2Bytes();
+      WRITE(TOUCH_CS_PIN, HIGH);
     #endif
 
-    for (i = 0; i < times; i++) {
-      #if ENABLED(SPI_GRAPHICAL_TFT)
-        OUT_WRITE(TOUCH_CS_PIN, LOW);
-        SPI_TFT.spi_read_write_byte(CHX);
-        y_addata[i] = SPI2_ReadWrite2Bytes();
-        WRITE(TOUCH_CS_PIN, HIGH);
-
-        OUT_WRITE(TOUCH_CS_PIN, LOW);
-        SPI_TFT.spi_read_write_byte(CHY);
-        x_addata[i] = SPI2_ReadWrite2Bytes();
-        WRITE(TOUCH_CS_PIN, HIGH);
-      #else // #if ENABLED(TOUCH_BUTTONS)
-        OUT_WRITE(TOUCH_CS_PIN, LOW);
-        W25QXX.spi_flash_read_write_byte(CHX);
-        y_addata[i] = SPI2_ReadWrite2Bytes();
-        WRITE(TOUCH_CS_PIN, HIGH);
-
-        OUT_WRITE(TOUCH_CS_PIN, LOW);
-        W25QXX.spi_flash_read_write_byte(CHY);
-        x_addata[i] = SPI2_ReadWrite2Bytes();
-        WRITE(TOUCH_CS_PIN, HIGH);
-      #endif
-
-    }
-    //#endif
-    //result = x_addata[0];
-    for (i = 0; i < times; i++)
-      for (j = i + 1; j < times; j++)
-        if (x_addata[j] > x_addata[i]) {
-          k = x_addata[j];
-          x_addata[j] = x_addata[i];
-          x_addata[i] = k;
-        }
-    if (x_addata[times / 2 - 1] - x_addata[times / 2] > 50) {
-      *X_Addata = *Y_Addata = 0;
-      return;
-    }
+  }
 
-    *X_Addata = (x_addata[times / 2 - 1] + x_addata[times / 2]) / 2;
+  for (i = 0; i < times; i++)
+    for (j = i + 1; j < times; j++)
+      if (x_addata[j] > x_addata[i]) {
+        k = x_addata[j];
+        x_addata[j] = x_addata[i];
+        x_addata[i] = k;
+      }
+  if (x_addata[times / 2 - 1] - x_addata[times / 2] > 50) {
+    *X_Addata = *Y_Addata = 0;
+    return;
+  }
 
-    //result = y_addata[0];
-    for (i = 0; i < times; i++)
-      for (j = i + 1; j < times; j++)
-        if (y_addata[j] > y_addata[i]) {
-          k = y_addata[j];
-          y_addata[j] = y_addata[i];
-          y_addata[i] = k;
-        }
+  *X_Addata = (x_addata[times / 2 - 1] + x_addata[times / 2]) / 2;
 
-    if (y_addata[times / 2 - 1] - y_addata[times / 2] > 50) {
-      *X_Addata = *Y_Addata = 0;
-      return;
-    }
+  for (i = 0; i < times; i++)
+    for (j = i + 1; j < times; j++)
+      if (y_addata[j] > y_addata[i]) {
+        k = y_addata[j];
+        y_addata[j] = y_addata[i];
+        y_addata[i] = k;
+      }
 
-    *Y_Addata = (y_addata[times / 2 - 1] + y_addata[times / 2]) / 2;
+  if (y_addata[times / 2 - 1] - y_addata[times / 2] > 50) {
+    *X_Addata = *Y_Addata = 0;
+    return;
   }
 
-  #define ADC_VALID_OFFSET  10
+  *Y_Addata = (y_addata[times / 2 - 1] + y_addata[times / 2]) / 2;
+}
+
+#define ADC_VALID_OFFSET  10
+
+uint8_t TOUCH_PressValid(uint16_t _usX, uint16_t _usY) {
+  if (   (_usX <= ADC_VALID_OFFSET) || (_usY <= ADC_VALID_OFFSET)
+      || (_usX >= 4095 - ADC_VALID_OFFSET) || (_usY >= 4095 - ADC_VALID_OFFSET)
+  ) return 0;
+  return 1;
+}
+
+static lv_coord_t last_x = 0, last_y = 0;
+bool my_touchpad_read(lv_indev_drv_t * indev_driver, lv_indev_data_t * data) {
+  uint32_t tmpTime, diffTime = 0;
+
+  tmpTime = millis();
+  diffTime = getTickDiff(tmpTime, touch_time1);
+  /*Save the state and save the pressed coordinate*/
+  //data->state = TOUCH_PressValid(last_x, last_y) ? LV_INDEV_STATE_PR : LV_INDEV_STATE_REL;
+  //if (data->state == LV_INDEV_STATE_PR)  ADS7843_Rd_Addata((u16 *)&last_x, (u16 *)&last_y);
+  //touchpad_get_xy(&last_x, &last_y);
+  /*Save the pressed coordinates and the state*/
+  if (diffTime > 10) {
+    //use marlin touch code if enabled
+    #if ENABLED(TOUCH_BUTTONS)
+      touch.getTouchPoint(reinterpret_cast<uint16_t&>(last_x), reinterpret_cast<uint16_t&>(last_y));
+    #else
+      XPT2046_Rd_Addata((uint16_t *)&last_x, (uint16_t *)&last_y);
+    #endif
+    if (TOUCH_PressValid(last_x, last_y)) {
 
-  uint8_t TOUCH_PressValid(uint16_t _usX, uint16_t _usY) {
-    if ((_usX <= ADC_VALID_OFFSET) || (_usY <= ADC_VALID_OFFSET)
-        || (_usX >= 4095 - ADC_VALID_OFFSET) || (_usY >= 4095 - ADC_VALID_OFFSET)
-        ) return 0;
+      data->state = LV_INDEV_STATE_PR;
 
-    return 1;
-  }
+      /*Set the coordinates (if released use the last pressed coordinates)*/
 
-  static lv_coord_t last_x = 0, last_y = 0;
-  bool my_touchpad_read(lv_indev_drv_t * indev_driver, lv_indev_data_t * data) {
-    #if 1
-      uint32_t tmpTime, diffTime = 0;
-
-      tmpTime = millis();
-      diffTime = getTickDiff(tmpTime, touch_time1);
-      /*Save the state and save the pressed coordinate*/
-      //data->state = TOUCH_PressValid(last_x, last_y) ? LV_INDEV_STATE_PR : LV_INDEV_STATE_REL;
-      //if (data->state == LV_INDEV_STATE_PR)  ADS7843_Rd_Addata((u16 *)&last_x, (u16 *)&last_y);
-      //touchpad_get_xy(&last_x, &last_y);
-      /*Save the pressed coordinates and the state*/
-      if (diffTime > 10) {
-        XPT2046_Rd_Addata((uint16_t *)&last_x, (uint16_t *)&last_y);
-        if (TOUCH_PressValid(last_x, last_y)) {
-
-          data->state = LV_INDEV_STATE_PR;
-
-          /*Set the coordinates (if released use the last pressed coordinates)*/
-
-          xpt2046_corr((uint16_t *)&last_x, (uint16_t *)&last_y);
-          data->point.x = last_x;
-          data->point.y = last_y;
-
-        }
-        else {
-          data->state = LV_INDEV_STATE_REL;
-        }
-        touch_time1 = tmpTime;
-      }
+      // SERIAL_ECHOLNPAIR("antes X: ", last_x, ", y: ", last_y);
+      xpt2046_corr((uint16_t *)&last_x, (uint16_t *)&last_y);
+      // SERIAL_ECHOLNPAIR("X: ", last_x, ", y: ", last_y);
+      data->point.x = last_x;
+      data->point.y = last_y;
 
-      return false; /*Return `false` because we are not buffering and no more data to read*/
-    #endif
+      last_x = 0;
+      last_y = 0;
+    }
+    else {
+      data->state = LV_INDEV_STATE_REL;
+    }
+    touch_time1 = tmpTime;
   }
 
-#endif // TFT_LITTLE_VGL_UI
+  return false; /*Return `false` because we are not buffering and no more data to read*/
+}
+
+#endif // TFT_LVGL_UI

commit 642112d3eb7c1af9a52feec8134c85ed3e34891c
Author: makerbase <4164049@qq.com>
Date:   Tue Jun 16 10:05:33 2020 +0800

    Add MKS UI (TFT_LITTLE_VGL_UI) (#18071)

diff --git a/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
new file mode 100644
index 0000000000..a34b1ff470
--- /dev/null
+++ b/Marlin/src/lcd/extui/lib/mks_ui/tft_lvgl_configuration.cpp
@@ -0,0 +1,791 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * @file lcd_lvgl_configuration.c
+ * @date    2020-02-21
+ */
+
+#include "../../../../inc/MarlinConfigPre.h"
+
+#if ENABLED(TFT_LITTLE_VGL_UI)
+
+  #include "../../../../MarlinCore.h"
+
+  #include "tft_lvgl_configuration.h"
+  #include "lvgl.h"
+  #include "../../../../feature/touch/xpt2046.h"
+  #include "draw_ready_print.h"
+  #include "W25Qxx.h"
+  #include "pic_manager.h"
+
+  #include "mks_hardware_test.h"
+  #include "draw_ui.h"
+
+  #if ENABLED(POWER_LOSS_RECOVERY)
+    #include "../../../../feature/powerloss.h"
+  #endif
+
+  #include <SPI.h>
+
+  #if ENABLED(SPI_GRAPHICAL_TFT)
+    #include "SPI_TFT.h"
+  #endif
+
+//#include "../../Configuration.h"
+//#include "../../src/core/macros.h"
+
+  extern void LCD_IO_Init(uint8_t cs, uint8_t rs);
+  extern void LCD_IO_WriteData(uint16_t RegValue);
+  extern void LCD_IO_WriteReg(uint16_t Reg);
+
+  extern void LCD_IO_WriteMultiple(uint16_t color, uint32_t count);
+
+  extern void init_gb2312_font();
+
+  static lv_disp_buf_t disp_buf;
+//static lv_color_t buf[LV_HOR_RES_MAX * 18];
+//static lv_color_t buf[10*5];
+//extern lv_obj_t * scr;
+  #if ENABLED(SDSUPPORT)
+    extern void UpdatePic();
+    extern void UpdateFont();
+  #endif
+  uint16_t DeviceCode = 0x9488;
+  extern uint8_t sel_id;
+
+  #define SetCs
+  #define ClrCs
+
+  #define  HDP  799//Horizontal Display Period     //**
+  #define  HT   1000//Horizontal Total
+  #define  HPS  51//LLINE Pulse Start Position
+  #define  LPS  3 //  Horizontal Display Period Start Position
+  #define  HPW  8 //  LLINE Pulse Width
+
+  #define  VDP  479//Vertical Display Period
+  #define  VT   530//Vertical Total
+  #define  VPS  24//  LFRAME Pulse Start Position
+  #define  FPS  23//Vertical Display Period Start Positio
+  #define  VPW  3 // LFRAME Pulse Width     //**
+
+  #define MAX_HZ_POSX HDP+1
+  #define MAX_HZ_POSY VDP+1
+
+  extern uint8_t gcode_preview_over, flash_preview_begin, default_preview_flg;
+
+  void SysTick_Callback() {
+    lv_tick_inc(1);
+    print_time_count();
+  }
+
+  void tft_set_cursor(uint16_t x, uint16_t y) {
+    #if 0
+    if (DeviceCode == 0x8989) {
+      LCD_WriteReg(0x004E, y);        //行
+      LCD_WriteReg(0x004F, x);  //列
+    }
+    else if ((DeviceCode == 0x9919)) {
+      LCD_WriteReg(0x004E, x); // 行
+      LCD_WriteReg(0x004F, y); // 列
+    }
+    else if ((DeviceCode == 0x5761)) {    //SSD1963
+      LCD_WrtReg(0x002A);
+      LCD_WrtRAM(x >> 8);
+      LCD_WrtRAM(x & 0x00FF);
+      LCD_WrtRAM(HDP >> 8);
+      LCD_WrtRAM(HDP & 0x00FF);
+      LCD_WrtReg(0x002B);
+      LCD_WrtRAM(y >> 8);
+      LCD_WrtRAM(y & 0x00FF);
+      LCD_WrtRAM(VDP >> 8);
+      LCD_WrtRAM(VDP & 0x00FF);
+    }
+    else if (DeviceCode == 0x9488) {
+      ILI9488_WriteCmd(0x002A);
+      ILI9488_WriteData(x >> 8);
+      ILI9488_WriteData(x & 0x00FF);
+      ILI9488_WriteData(x >> 8);
+      ILI9488_WriteData(x & 0x00FF);
+      //ILI9488_WriteData(0x01);
+      //ILI9488_WriteData(0xDF);
+      ILI9488_WriteCmd(0x002B);
+      ILI9488_WriteData(y >> 8);
+      ILI9488_WriteData(y & 0x00FF);
+      ILI9488_WriteData(y >> 8);
+      ILI9488_WriteData(y & 0x00FF);
+      //ILI9488_WriteData(0x01);
+      //ILI9488_WriteData(0x3F);
+    }
+    else {
+      LCD_WriteReg(0x0020, y); // 行
+      LCD_WriteReg(0x0021, 0x13f - x); // 列
+    }
+    #else // if 0
+      LCD_IO_WriteReg(0x002A);
+      LCD_IO_WriteData(x >> 8);
+      LCD_IO_WriteData(x & 0x00FF);
+      LCD_IO_WriteData(x >> 8);
+      LCD_IO_WriteData(x & 0x00FF);
+      //ILI9488_WriteData(0x01);
+      //ILI9488_WriteData(0xDF);
+      LCD_IO_WriteReg(0x002B);
+      LCD_IO_WriteData(y >> 8);
+      LCD_IO_WriteData(y & 0x00FF);
+      LCD_IO_WriteData(y >> 8);
+      LCD_IO_WriteData(y & 0x00FF);
+      //ILI9488_WriteData(0x01);
+      //ILI9488_WriteData(0x3F);
+    #endif // if 0
+  }
+
+  void LCD_WriteRAM_Prepare(void) {
+    #if 0
+    if ((DeviceCode == 0x9325) || (DeviceCode == 0x9328) || (DeviceCode == 0x8989)) {
+      ClrCs
+      LCD->LCD_REG = R34;
+      SetCs
+    }
+    else {
+      LCD_WrtReg(0x002C);
+    }
+    #else
+      LCD_IO_WriteReg(0x002C);
+    #endif
+  }
+
+  void tft_set_point(uint16_t x, uint16_t y, uint16_t point) {
+    //if (DeviceCode == 0x9488) {
+    if ((x > 480) || (y > 320)) return;
+    //}
+    //**if ( (x>320)||(y>240) ) return;
+    tft_set_cursor(x, y); /*设置光标位置*/
+
+    LCD_WriteRAM_Prepare();   /* 开始写入GRAM*/
+    //LCD_WriteRAM(point);
+    LCD_IO_WriteData(point);
+  }
+
+  void LCD_WriteReg(uint16_t LCD_Reg, uint16_t LCD_RegValue) {
+    /* Write 16-bit Index, then Write Reg */
+    ClrCs
+      LCD_IO_WriteReg(LCD_Reg);
+    /* Write 16-bit Reg */
+    LCD_IO_WriteData(LCD_RegValue);
+    SetCs
+  }
+
+  void ili9320_SetWindows(uint16_t StartX, uint16_t StartY, uint16_t width, uint16_t heigh) {
+    uint16_t s_h, s_l, e_h, e_l;
+
+    uint16_t xEnd, yEnd;
+    xEnd = StartX + width;
+    yEnd = StartY + heigh - 1;
+    if (DeviceCode == 0x8989) {
+      /*LCD_WriteReg(0x0044, (StartX & 0xFF) | (xEnd << 8));
+      LCD_WriteReg(0x0045, StartY);
+      LCD_WriteReg(0x0046, yEnd);*/
+      LCD_WriteReg(0x0044, (StartY & 0xFF) | (yEnd << 8));
+      LCD_WriteReg(0x0045, StartX);
+      LCD_WriteReg(0x0046, xEnd);
+    }
+    else if (DeviceCode == 0x9488) {
+      s_h = (StartX >> 8) & 0x00ff;
+      s_l = StartX & 0x00ff;
+      e_h = ((StartX + width - 1) >> 8) & 0x00ff;
+      e_l = (StartX + width - 1) & 0x00ff;
+
+      LCD_IO_WriteReg(0x002A);
+      LCD_IO_WriteData(s_h);
+      LCD_IO_WriteData(s_l);
+      LCD_IO_WriteData(e_h);
+      LCD_IO_WriteData(e_l);
+
+      s_h = (StartY >> 8) & 0x00ff;
+      s_l = StartY & 0x00ff;
+      e_h = ((StartY + heigh - 1) >> 8) & 0x00ff;
+      e_l = (StartY + heigh - 1) & 0x00ff;
+
+      LCD_IO_WriteReg(0x002B);
+      LCD_IO_WriteData(s_h);
+      LCD_IO_WriteData(s_l);
+      LCD_IO_WriteData(e_h);
+      LCD_IO_WriteData(e_l);
+    }
+    else if ((DeviceCode == 0x9325) || (DeviceCode == 0x9328) || (DeviceCode == 0x1505)) {
+      /* LCD_WriteReg(0x0050, StartX);
+       LCD_WriteReg(0x0052, StartY);
+       LCD_WriteReg(0x0051, xEnd);
+       LCD_WriteReg(0x0053, yEnd);*/
+      LCD_WriteReg(0x0050, StartY);      //Specify the start/end positions of the window address in the horizontal direction by an address unit
+      LCD_WriteReg(0x0051, yEnd);      //Specify the start positions of the window address in the vertical direction by an address unit
+      LCD_WriteReg(0x0052, 320 - xEnd);
+      LCD_WriteReg(0x0053, 320 - StartX - 1);      //Specify the end positions of the window address in the vertical direction by an address unit
+
+    }
+    else {
+      s_h = (StartX >> 8) & 0xFF;
+      s_l = StartX & 0xFF;
+      e_h = ((StartX + width - 1) >> 8) & 0xFF;
+      e_l = (StartX + width - 1) & 0xFF;
+
+      LCD_IO_WriteReg(0x2A);
+      LCD_IO_WriteData(s_h);
+      LCD_IO_WriteData(s_l);
+      LCD_IO_WriteData(e_h);
+      LCD_IO_WriteData(e_l);
+
+      s_h = (StartY >> 8) & 0xFF;
+      s_l = StartY & 0xFF;
+      e_h = ((StartY + heigh - 1) >> 8) & 0xFF;
+      e_l = (StartY + heigh - 1) & 0xFF;
+
+      LCD_IO_WriteReg(0x2B);
+      LCD_IO_WriteData(s_h);
+      LCD_IO_WriteData(s_l);
+      LCD_IO_WriteData(e_h);
+      LCD_IO_WriteData(e_l);
+    }
+  }
+
+  void LCD_Clear(uint16_t Color) {
+    uint32_t index = 0;
+    unsigned int count;
+
+    if (DeviceCode == 0x9488) {
+      tft_set_cursor(0, 0);
+      ili9320_SetWindows(0, 0, 480, 320);
+      LCD_WriteRAM_Prepare();
+      //index = (160*480);
+      for (index = 0; index < 320 * 480; index++)
+        LCD_IO_WriteData(Color);
+      //LCD_IO_WriteMultiple(Color, (480*320));
+      //while(index --) LCD_IO_WriteData(Color);
+    }
+    else if (DeviceCode == 0x5761) {
+      LCD_IO_WriteReg(0x002a);
+      LCD_IO_WriteData(0);
+      LCD_IO_WriteData(0);
+      LCD_IO_WriteData(HDP >> 8);
+      LCD_IO_WriteData(HDP & 0x00ff);
+      LCD_IO_WriteReg(0x002b);
+      LCD_IO_WriteData(0);
+      LCD_IO_WriteData(0);
+      LCD_IO_WriteData(VDP >> 8);
+      LCD_IO_WriteData(VDP & 0x00ff);
+      LCD_IO_WriteReg(0x002c);
+      LCD_IO_WriteReg(0x002c);
+      for (count = 0; count < (HDP + 1) * (VDP + 1); count++)
+        LCD_IO_WriteData(Color);
+    }
+    else {
+      tft_set_cursor(0, 0);
+      LCD_WriteRAM_Prepare(); /* Prepare to write GRAM */
+      for (index = 0; index < 76800; index++)
+        LCD_IO_WriteData(Color);
+    }
+  }
+
+  extern uint16_t ILI9488_ReadRAM();
+
+  #if DISABLED(SPI_GRAPHICAL_TFT)
+
+  void init_tft() {
+    uint16_t i;
+    //************* Start Initial Sequence **********//
+
+    LCD_IO_Init(FSMC_CS_PIN, FSMC_RS_PIN);
+
+    _delay_ms(5);
+
+    LCD_IO_WriteReg(0x00D3);
+    DeviceCode = ILI9488_ReadRAM(); //dummy read
+    DeviceCode = ILI9488_ReadRAM();
+    DeviceCode = ILI9488_ReadRAM();
+    DeviceCode <<= 8;
+    DeviceCode |= ILI9488_ReadRAM();
+
+    if (DeviceCode == 0x9488) {
+      LCD_IO_WriteReg(0x00E0);
+      LCD_IO_WriteData(0x0000);
+      LCD_IO_WriteData(0x0007);
+      LCD_IO_WriteData(0x000f);
+      LCD_IO_WriteData(0x000D);
+      LCD_IO_WriteData(0x001B);
+      LCD_IO_WriteData(0x000A);
+      LCD_IO_WriteData(0x003c);
+      LCD_IO_WriteData(0x0078);
+      LCD_IO_WriteData(0x004A);
+      LCD_IO_WriteData(0x0007);
+      LCD_IO_WriteData(0x000E);
+      LCD_IO_WriteData(0x0009);
+      LCD_IO_WriteData(0x001B);
+      LCD_IO_WriteData(0x001e);
+      LCD_IO_WriteData(0x000f);
+
+      LCD_IO_WriteReg(0x00E1);
+      LCD_IO_WriteData(0x0000);
+      LCD_IO_WriteData(0x0022);
+      LCD_IO_WriteData(0x0024);
+      LCD_IO_WriteData(0x0006);
+      LCD_IO_WriteData(0x0012);
+      LCD_IO_WriteData(0x0007);
+      LCD_IO_WriteData(0x0036);
+      LCD_IO_WriteData(0x0047);
+      LCD_IO_WriteData(0x0047);
+      LCD_IO_WriteData(0x0006);
+      LCD_IO_WriteData(0x000a);
+      LCD_IO_WriteData(0x0007);
+      LCD_IO_WriteData(0x0030);
+      LCD_IO_WriteData(0x0037);
+      LCD_IO_WriteData(0x000f);
+
+      LCD_IO_WriteReg(0x00C0);
+      LCD_IO_WriteData(0x0010);
+      LCD_IO_WriteData(0x0010);
+
+      LCD_IO_WriteReg(0x00C1);
+      LCD_IO_WriteData(0x0041);
+
+      LCD_IO_WriteReg(0x00C5);
+      LCD_IO_WriteData(0x0000);
+      LCD_IO_WriteData(0x0022);
+      LCD_IO_WriteData(0x0080);
+
+      LCD_IO_WriteReg(0x0036);
+      //ILI9488_WriteData(0x0068);
+      //if (gCfgItems.overturn_180 != 0xEE)
+      //{
+      LCD_IO_WriteData(0x0068);
+      //}
+      //else
+      //{
+      //ILI9488_WriteData(0x00A8);
+      //}
+
+      LCD_IO_WriteReg(0x003A); //Interface Mode Control
+      LCD_IO_WriteData(0x0055);
+
+      LCD_IO_WriteReg(0x00B0);  //Interface Mode Control
+      LCD_IO_WriteData(0x0000);
+      LCD_IO_WriteReg(0x00B1);   //Frame rate 70HZ
+      LCD_IO_WriteData(0x00B0);
+      LCD_IO_WriteData(0x0011);
+      LCD_IO_WriteReg(0x00B4);
+      LCD_IO_WriteData(0x0002);
+      LCD_IO_WriteReg(0x00B6); //RGB/MCU Interface Control
+      LCD_IO_WriteData(0x0002);
+      LCD_IO_WriteData(0x0042);
+
+      LCD_IO_WriteReg(0x00B7);
+      LCD_IO_WriteData(0x00C6);
+
+      //WriteComm(0xBE);
+      //WriteData(0x00);
+      //WriteData(0x04);
+
+      LCD_IO_WriteReg(0x00E9);
+      LCD_IO_WriteData(0x0000);
+
+      LCD_IO_WriteReg(0x00F7);
+      LCD_IO_WriteData(0x00A9);
+      LCD_IO_WriteData(0x0051);
+      LCD_IO_WriteData(0x002C);
+      LCD_IO_WriteData(0x0082);
+
+      LCD_IO_WriteReg(0x0011);
+      for (i = 0; i < 65535; i++);
+      LCD_IO_WriteReg(0x0029);
+
+      ili9320_SetWindows(0, 0, 480, 320);
+      LCD_Clear(0x0000);
+
+      OUT_WRITE(LCD_BACKLIGHT_PIN, HIGH);
+    }
+  }
+
+  #endif // if DISABLED(SPI_GRAPHICAL_TFT)
+
+  extern uint8_t bmp_public_buf[17 * 1024];
+  void tft_lvgl_init() {
+    //uint16_t test_id=0;
+    W25QXX.init(SPI_QUARTER_SPEED);
+    //test_id=W25QXX.W25QXX_ReadID();
+    #if ENABLED(SDSUPPORT)
+      UpdatePic();
+      UpdateFont();
+    #endif
+
+    gCfgItems_init();
+    ui_cfg_init();
+    disp_language_init();
+    //spi_flash_read_test();
+
+    #if ENABLED(SPI_GRAPHICAL_TFT)
+      SPI_TFT.spi_init(SPI_FULL_SPEED);
+      SPI_TFT.LCD_init();
+    #else
+      init_tft();
+    #endif
+
+    lv_init();
+
+    lv_disp_buf_init(&disp_buf, bmp_public_buf, NULL, LV_HOR_RES_MAX * 18); /*Initialize the display buffer*/
+
+    lv_disp_drv_t disp_drv;     /*Descriptor of a display driver*/
+    lv_disp_drv_init(&disp_drv);    /*Basic initialization*/
+    disp_drv.flush_cb = my_disp_flush; /*Set your driver function*/
+    disp_drv.buffer = &disp_buf;    /*Assign the buffer to the display*/
+    lv_disp_drv_register(&disp_drv);  /*Finally register the driver*/
+
+    lv_indev_drv_t indev_drv;
+    lv_indev_drv_init(&indev_drv);     /*Descriptor of a input device driver*/
+    indev_drv.type = LV_INDEV_TYPE_POINTER; /*Touch pad is a pointer-like device*/
+    indev_drv.read_cb = my_touchpad_read;  /*Set your driver function*/
+    lv_indev_drv_register(&indev_drv);   /*Finally register the driver*/
+
+    systick_attach_callback(SysTick_Callback);
+
+    init_gb2312_font();
+
+    tft_style_init();
+
+    filament_pin_setup();
+
+    #if ENABLED(POWER_LOSS_RECOVERY)
+    if (recovery.valid()) {
+      if (gCfgItems.from_flash_pic == 1)
+        flash_preview_begin = 1;
+      else
+        default_preview_flg = 1;
+
+      uiCfg.print_state = REPRINTING;
+
+      memset(public_buf_m, 0, sizeof(public_buf_m));
+      strncpy(public_buf_m, recovery.info.sd_filename, sizeof(public_buf_m));
+      card.printLongPath(public_buf_m);
+
+      strncpy(list_file.long_name[sel_id], card.longFilename, sizeof(list_file.long_name[sel_id]));
+
+      lv_draw_printing();
+    }
+    else
+    #endif
+    lv_draw_ready_print();
+
+    #if ENABLED(MKS_TEST)
+      Test_GPIO();
+    #endif
+  }
+
+  #if 0
+  void LCD_WriteRAM(uint16_t RGB_Code) {
+    #if 0
+      ClrCs
+      /* Write 16-bit GRAM Reg */
+      LCD->LCD_RAM = RGB_Code;
+      SetCs
+    #else
+      LCD_IO_WriteData(RGB_Code);
+    #endif
+  }
+  #endif
+
+  void my_disp_flush(lv_disp_drv_t * disp, const lv_area_t * area, lv_color_t * color_p) {
+    #if ENABLED(SPI_GRAPHICAL_TFT)
+      uint16_t i, width, height;
+      uint16_t clr_temp;
+      uint8_t tbuf[480 * 2];
+
+      SPI_TFT.spi_init(SPI_FULL_SPEED);
+
+      width = area->x2 - area->x1 + 1;
+      height = area->y2 - area->y1 + 1;
+
+      for (int j = 0; j < height; j++) {
+        SPI_TFT.SetCursor(0, 0);
+        SPI_TFT.SetWindows((uint16_t)area->x1, (uint16_t)area->y1 + j, width, 1);
+        SPI_TFT.LCD_WriteRAM_Prepare();
+
+        for (i = 0; i < width * 2;) {
+          clr_temp = (uint16_t)(((uint16_t)color_p->ch.red << 11)
+                                | ((uint16_t)color_p->ch.green << 5)
+                                | ((uint16_t)color_p->ch.blue));
+
+          tbuf[i] = clr_temp >> 8;
+          tbuf[i + 1] = clr_temp;
+          i += 2;
+          color_p++;
+        }
+        SPI_TFT_CS_L;
+        SPI_TFT_DC_H;
+        SPI.dmaSend(tbuf, width * 2, true);
+        SPI_TFT_CS_H;
+      }
+
+      lv_disp_flush_ready(disp);       /* Indicate you are ready with the flushing*/
+
+      W25QXX.init(SPI_QUARTER_SPEED);
+    #else
+      #if 1
+        uint16_t i, width, height;
+        uint16_t clr_temp;
+        #if 0
+          int32_t x, y;
+          for (y = area->y1; y <= area->y2; y++)
+            for (x = area->x1; x <= area->x2; x++) {
+              //set_pixel(x, y, *color_p);  /* Put a pixel to the display.*/
+              clr_temp = (uint16_t)(((uint16_t)color_p->ch.red << 11)
+                                    | ((uint16_t)color_p->ch.green << 5)
+                                    | ((uint16_t)color_p->ch.blue));
+              tft_set_point(x, y, clr_temp);
+              color_p++;
+            }
+
+        #else
+          width = area->x2 - area->x1 + 1;
+          height = area->y2 - area->y1 + 1;
+          //tft_set_cursor((uint16_t)area->x1,(uint16_t)area->y1);
+          ili9320_SetWindows((uint16_t)area->x1, (uint16_t)area->y1, width, height);
+          LCD_WriteRAM_Prepare();
+          for (i = 0; i < width * height; i++) {
+            clr_temp = (uint16_t)(((uint16_t)color_p->ch.red << 11)
+                                  | ((uint16_t)color_p->ch.green << 5)
+                                  | ((uint16_t)color_p->ch.blue));
+            LCD_IO_WriteData(clr_temp);
+            color_p++;
+          }
+        #endif
+
+        lv_disp_flush_ready(disp);       /* Indicate you are ready with the flushing*/
+      #endif
+    #endif // SPI_GRAPHICAL_TFT
+  }
+
+  #define TICK_CYCLE 1
+
+  static int32_t touch_time1 = 0;
+
+  unsigned int  getTickDiff(unsigned int curTick, unsigned int lastTick) {
+    if (lastTick <= curTick)
+      return (curTick - lastTick) * TICK_CYCLE;
+    else
+      return (0xFFFFFFFF - lastTick + curTick) * TICK_CYCLE;
+  }
+
+  #if ENABLED(SPI_GRAPHICAL_TFT)
+
+    #ifndef USE_XPT2046
+      #define USE_XPT2046       1
+      #define XPT2046_XY_SWAP   1
+      #define XPT2046_X_INV     1
+      #define XPT2046_Y_INV     0
+    #endif
+
+    #if USE_XPT2046
+      #define XPT2046_HOR_RES   480
+      #define XPT2046_VER_RES   320
+      #define XPT2046_X_MIN     201
+      #define XPT2046_Y_MIN     164
+      #define XPT2046_X_MAX     3919
+      #define XPT2046_Y_MAX     3776
+      #define XPT2046_AVG       4
+      #define XPT2046_INV       1
+    #endif
+
+  #else
+
+    #ifndef USE_XPT2046
+      #define USE_XPT2046       1
+      #define XPT2046_XY_SWAP   1
+      #define XPT2046_X_INV     0
+      #define XPT2046_Y_INV     1
+    #endif
+
+    #if USE_XPT2046
+      #define XPT2046_HOR_RES   480
+      #define XPT2046_VER_RES   320
+      #define XPT2046_X_MIN     201
+      #define XPT2046_Y_MIN     164
+      #define XPT2046_X_MAX     3919
+      #define XPT2046_Y_MAX     3776
+      #define XPT2046_AVG       4
+      #define XPT2046_INV       0
+    #endif
+
+  #endif
+
+  static void xpt2046_corr(uint16_t *x, uint16_t *y) {
+    #if XPT2046_XY_SWAP
+      int16_t swap_tmp;
+      swap_tmp = *x;
+      *x = *y;
+      *y = swap_tmp;
+    #endif
+    if ((*x) > XPT2046_X_MIN) (*x) -= XPT2046_X_MIN; else (*x) = 0;
+    if ((*y) > XPT2046_Y_MIN) (*y) -= XPT2046_Y_MIN; else (*y) = 0;
+    (*x) = uint32_t(uint32_t(*x) * XPT2046_HOR_RES) / (XPT2046_X_MAX - XPT2046_X_MIN);
+    (*y) = uint32_t(uint32_t(*y) * XPT2046_VER_RES) / (XPT2046_Y_MAX - XPT2046_Y_MIN);
+    #if XPT2046_X_INV
+      (*x) = XPT2046_HOR_RES - (*x);
+    #endif
+    #if XPT2046_Y_INV
+      (*y) = XPT2046_VER_RES - (*y);
+    #endif
+  }
+
+  #define  times  4
+  #define CHX   0x90// 0x90
+  #define CHY   0xD0// 0xD0
+
+  int SPI2_ReadWrite2Bytes(void) {
+    volatile uint16_t ans = 0;
+    uint16_t temp = 0;
+    #if ENABLED(SPI_GRAPHICAL_TFT)
+      temp = SPI_TFT.spi_read_write_byte(0xFF);
+      ans = temp << 8;
+      temp = SPI_TFT.spi_read_write_byte(0xFF);
+      ans |= temp;
+      ans >>= 3;
+    #else
+      temp = W25QXX.spi_flash_read_write_byte(0xFF);
+      ans = temp << 8;
+      temp = W25QXX.spi_flash_read_write_byte(0xFF);
+      ans |= temp;
+      ans >>= 3;
+    #endif
+    return ans & 0x0FFF;
+  }
+
+  uint16_t x_addata[times], y_addata[times];
+  void XPT2046_Rd_Addata(uint16_t *X_Addata, uint16_t *Y_Addata) {
+    uint16_t i, j, k;
+    //int result;
+    //#if ENABLED(TOUCH_BUTTONS)
+
+    #if ENABLED(SPI_GRAPHICAL_TFT)
+      SPI_TFT.spi_init(SPI_QUARTER_SPEED);
+    #endif
+
+    for (i = 0; i < times; i++) {
+      #if ENABLED(SPI_GRAPHICAL_TFT)
+        OUT_WRITE(TOUCH_CS_PIN, LOW);
+        SPI_TFT.spi_read_write_byte(CHX);
+        y_addata[i] = SPI2_ReadWrite2Bytes();
+        WRITE(TOUCH_CS_PIN, HIGH);
+
+        OUT_WRITE(TOUCH_CS_PIN, LOW);
+        SPI_TFT.spi_read_write_byte(CHY);
+        x_addata[i] = SPI2_ReadWrite2Bytes();
+        WRITE(TOUCH_CS_PIN, HIGH);
+      #else // #if ENABLED(TOUCH_BUTTONS)
+        OUT_WRITE(TOUCH_CS_PIN, LOW);
+        W25QXX.spi_flash_read_write_byte(CHX);
+        y_addata[i] = SPI2_ReadWrite2Bytes();
+        WRITE(TOUCH_CS_PIN, HIGH);
+
+        OUT_WRITE(TOUCH_CS_PIN, LOW);
+        W25QXX.spi_flash_read_write_byte(CHY);
+        x_addata[i] = SPI2_ReadWrite2Bytes();
+        WRITE(TOUCH_CS_PIN, HIGH);
+      #endif
+
+    }
+    //#endif
+    //result = x_addata[0];
+    for (i = 0; i < times; i++)
+      for (j = i + 1; j < times; j++)
+        if (x_addata[j] > x_addata[i]) {
+          k = x_addata[j];
+          x_addata[j] = x_addata[i];
+          x_addata[i] = k;
+        }
+    if (x_addata[times / 2 - 1] - x_addata[times / 2] > 50) {
+      *X_Addata = *Y_Addata = 0;
+      return;
+    }
+
+    *X_Addata = (x_addata[times / 2 - 1] + x_addata[times / 2]) / 2;
+
+    //result = y_addata[0];
+    for (i = 0; i < times; i++)
+      for (j = i + 1; j < times; j++)
+        if (y_addata[j] > y_addata[i]) {
+          k = y_addata[j];
+          y_addata[j] = y_addata[i];
+          y_addata[i] = k;
+        }
+
+    if (y_addata[times / 2 - 1] - y_addata[times / 2] > 50) {
+      *X_Addata = *Y_Addata = 0;
+      return;
+    }
+
+    *Y_Addata = (y_addata[times / 2 - 1] + y_addata[times / 2]) / 2;
+  }
+
+  #define ADC_VALID_OFFSET  10
+
+  uint8_t TOUCH_PressValid(uint16_t _usX, uint16_t _usY) {
+    if ((_usX <= ADC_VALID_OFFSET) || (_usY <= ADC_VALID_OFFSET)
+        || (_usX >= 4095 - ADC_VALID_OFFSET) || (_usY >= 4095 - ADC_VALID_OFFSET)
+        ) return 0;
+
+    return 1;
+  }
+
+  static lv_coord_t last_x = 0, last_y = 0;
+  bool my_touchpad_read(lv_indev_drv_t * indev_driver, lv_indev_data_t * data) {
+    #if 1
+      uint32_t tmpTime, diffTime = 0;
+
+      tmpTime = millis();
+      diffTime = getTickDiff(tmpTime, touch_time1);
+      /*Save the state and save the pressed coordinate*/
+      //data->state = TOUCH_PressValid(last_x, last_y) ? LV_INDEV_STATE_PR : LV_INDEV_STATE_REL;
+      //if (data->state == LV_INDEV_STATE_PR)  ADS7843_Rd_Addata((u16 *)&last_x, (u16 *)&last_y);
+      //touchpad_get_xy(&last_x, &last_y);
+      /*Save the pressed coordinates and the state*/
+      if (diffTime > 10) {
+        XPT2046_Rd_Addata((uint16_t *)&last_x, (uint16_t *)&last_y);
+        if (TOUCH_PressValid(last_x, last_y)) {
+
+          data->state = LV_INDEV_STATE_PR;
+
+          /*Set the coordinates (if released use the last pressed coordinates)*/
+
+          xpt2046_corr((uint16_t *)&last_x, (uint16_t *)&last_y);
+          data->point.x = last_x;
+          data->point.y = last_y;
+
+        }
+        else {
+          data->state = LV_INDEV_STATE_REL;
+        }
+        touch_time1 = tmpTime;
+      }
+
+      return false; /*Return `false` because we are not buffering and no more data to read*/
+    #endif
+  }
+
+#endif // TFT_LITTLE_VGL_UI
