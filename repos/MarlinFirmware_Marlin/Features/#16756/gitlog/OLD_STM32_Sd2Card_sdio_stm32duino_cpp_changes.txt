commit 56ac68172796d03c15235738fcb234c48167d807
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Dec 26 03:20:29 2021 -0600

    🎨 Pins and SDIO cleanup

diff --git a/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp b/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
deleted file mode 100644
index 54e1820c78..0000000000
--- a/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
+++ /dev/null
@@ -1,326 +0,0 @@
-/**
- * Marlin 3D Printer Firmware
- * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
- *
- * Based on Sprinter and grbl.
- * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- *
- */
-
-#include "../platforms.h"
-
-#ifdef HAL_STM32
-
-#include "../../inc/MarlinConfig.h"
-
-#if ENABLED(SDIO_SUPPORT)
-
-#include <stdint.h>
-#include <stdbool.h>
-
-// use local drivers
-#if defined(STM32F103xE) || defined(STM32F103xG)
-  #include <stm32f1xx_hal_rcc_ex.h>
-  #include <stm32f1xx_hal_sd.h>
-#elif defined(STM32F4xx)
-  #include <stm32f4xx_hal_rcc.h>
-  #include <stm32f4xx_hal_dma.h>
-  #include <stm32f4xx_hal_gpio.h>
-  #include <stm32f4xx_hal_sd.h>
-#elif defined(STM32F7xx)
-  #include <stm32f7xx_hal_rcc.h>
-  #include <stm32f7xx_hal_dma.h>
-  #include <stm32f7xx_hal_gpio.h>
-  #include <stm32f7xx_hal_sd.h>
-#else
-  #error "SDIO only supported with STM32F103xE, STM32F103xG, STM32F4xx, or STM32F7xx."
-#endif
-
-// Fixed
-#define SDIO_D0_PIN   PC8
-#define SDIO_D1_PIN   PC9
-#define SDIO_D2_PIN   PC10
-#define SDIO_D3_PIN   PC11
-#define SDIO_CK_PIN   PC12
-#define SDIO_CMD_PIN  PD2
-
-SD_HandleTypeDef hsd;  // create SDIO structure
-// F4 supports one DMA for RX and another for TX, but Marlin will never
-// do read and write at same time, so we use the same DMA for both.
-DMA_HandleTypeDef hdma_sdio;
-
-/*
-  SDIO_INIT_CLK_DIV is 118
-  SDIO clock frequency is 48MHz / (TRANSFER_CLOCK_DIV + 2)
-  SDIO init clock frequency should not exceed 400KHz = 48MHz / (118 + 2)
-
-  Default TRANSFER_CLOCK_DIV is 2 (118 / 40)
-  Default SDIO clock frequency is 48MHz / (2 + 2) = 12 MHz
-  This might be too fast for stable SDIO operations
-
-  MKS Robin board seems to have stable SDIO with BusWide 1bit and ClockDiv 8 i.e. 4.8MHz SDIO clock frequency
-  Additional testing is required as there are clearly some 4bit initialization problems
-*/
-
-#ifndef USBD_OK
-  #define USBD_OK 0
-#endif
-
-// Target Clock, configurable. Default is 18MHz, from STM32F1
-#ifndef SDIO_CLOCK
-  #define SDIO_CLOCK 18000000 // 18 MHz
-#endif
-
-// SDIO retries, configurable. Default is 3, from STM32F1
-#ifndef SDIO_READ_RETRIES
-  #define SDIO_READ_RETRIES 3
-#endif
-
-// SDIO Max Clock (naming from STM Manual, don't change)
-#define SDIOCLK 48000000
-
-static uint32_t clock_to_divider(uint32_t clk) {
-  // limit the SDIO master clock to 8/3 of PCLK2. See STM32 Manuals
-  // Also limited to no more than 48Mhz (SDIOCLK).
-  const uint32_t pclk2 = HAL_RCC_GetPCLK2Freq();
-  clk = min(clk, (uint32_t)(pclk2 * 8 / 3));
-  clk = min(clk, (uint32_t)SDIOCLK);
-  // Round up divider, so we don't run the card over the speed supported,
-  // and subtract by 2, because STM32 will add 2, as written in the manual:
-  // SDIO_CK frequency = SDIOCLK / [CLKDIV + 2]
-  return pclk2 / clk + (pclk2 % clk != 0) - 2;
-}
-
-void go_to_transfer_speed() {
-  /* Default SDIO peripheral configuration for SD card initialization */
-  hsd.Init.ClockEdge           = hsd.Init.ClockEdge;
-  hsd.Init.ClockBypass         = hsd.Init.ClockBypass;
-  hsd.Init.ClockPowerSave      = hsd.Init.ClockPowerSave;
-  hsd.Init.BusWide             = hsd.Init.BusWide;
-  hsd.Init.HardwareFlowControl = hsd.Init.HardwareFlowControl;
-  hsd.Init.ClockDiv            = clock_to_divider(SDIO_CLOCK);
-
-  /* Initialize SDIO peripheral interface with default configuration */
-  SDIO_Init(hsd.Instance, hsd.Init);
-}
-
-void SD_LowLevel_Init(void) {
-  uint32_t tempreg;
-
-  __HAL_RCC_GPIOC_CLK_ENABLE(); //enable GPIO clocks
-  __HAL_RCC_GPIOD_CLK_ENABLE(); //enable GPIO clocks
-
-  GPIO_InitTypeDef  GPIO_InitStruct;
-
-  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
-  GPIO_InitStruct.Pull = 1;  //GPIO_NOPULL;
-  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
-
-  #if DISABLED(STM32F1xx)
-    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
-  #endif
-
-  GPIO_InitStruct.Pin = GPIO_PIN_8 | GPIO_PIN_12;  // D0 & SCK
-  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
-
-  #if PINS_EXIST(SDIO_D1, SDIO_D2, SDIO_D3)  // define D1-D3 only if have a four bit wide SDIO bus
-    GPIO_InitStruct.Pin = GPIO_PIN_9 | GPIO_PIN_10 | GPIO_PIN_11;  // D1-D3
-    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
-  #endif
-
-  // Configure PD.02 CMD line
-  GPIO_InitStruct.Pin = GPIO_PIN_2;
-  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
-
-  // Setup DMA
-  #if defined(STM32F1xx)
-    hdma_sdio.Init.Mode = DMA_NORMAL;
-    hdma_sdio.Instance = DMA2_Channel4;
-    HAL_NVIC_EnableIRQ(DMA2_Channel4_5_IRQn);
-  #elif defined(STM32F4xx)
-    hdma_sdio.Init.Mode = DMA_PFCTRL;
-    hdma_sdio.Instance = DMA2_Stream3;
-    hdma_sdio.Init.Channel = DMA_CHANNEL_4;
-    hdma_sdio.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
-    hdma_sdio.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
-    hdma_sdio.Init.MemBurst = DMA_MBURST_INC4;
-    hdma_sdio.Init.PeriphBurst = DMA_PBURST_INC4;
-    HAL_NVIC_EnableIRQ(DMA2_Stream3_IRQn);
-  #endif
-  HAL_NVIC_EnableIRQ(SDIO_IRQn);
-  hdma_sdio.Init.PeriphInc = DMA_PINC_DISABLE;
-  hdma_sdio.Init.MemInc = DMA_MINC_ENABLE;
-  hdma_sdio.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
-  hdma_sdio.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
-  hdma_sdio.Init.Priority = DMA_PRIORITY_LOW;
-  __HAL_LINKDMA(&hsd, hdmarx, hdma_sdio);
-  __HAL_LINKDMA(&hsd, hdmatx, hdma_sdio);
-
-  #if defined(STM32F1xx)
-    __HAL_RCC_SDIO_CLK_ENABLE();
-    __HAL_RCC_DMA2_CLK_ENABLE();
-  #else
-    __HAL_RCC_SDIO_FORCE_RESET();
-    delay(2);
-    __HAL_RCC_SDIO_RELEASE_RESET();
-    delay(2);
-    __HAL_RCC_SDIO_CLK_ENABLE();
-
-    __HAL_RCC_DMA2_FORCE_RESET();
-    delay(2);
-    __HAL_RCC_DMA2_RELEASE_RESET();
-    delay(2);
-    __HAL_RCC_DMA2_CLK_ENABLE();
-  #endif
-
-  //Initialize the SDIO (with initial <400Khz Clock)
-  tempreg = 0;  //Reset value
-  tempreg |= SDIO_CLKCR_CLKEN;  // Clock enabled
-  tempreg |= SDIO_INIT_CLK_DIV; // Clock Divider. Clock = 48000 / (118 + 2) = 400Khz
-  // Keep the rest at 0 => HW_Flow Disabled, Rising Clock Edge, Disable CLK ByPass, Bus Width = 0, Power save Disable
-  SDIO->CLKCR = tempreg;
-
-  // Power up the SDIO
-  SDIO_PowerState_ON(SDIO);
-  hsd.Instance = SDIO;
-}
-
-void HAL_SD_MspInit(SD_HandleTypeDef *hsd) { // application specific init
-  UNUSED(hsd);   // Prevent unused argument(s) compilation warning
-  __HAL_RCC_SDIO_CLK_ENABLE();  // turn on SDIO clock
-}
-
-bool SDIO_Init() {
-  uint8_t retryCnt = SDIO_READ_RETRIES;
-
-  bool status;
-  hsd.Instance = SDIO;
-  hsd.State = HAL_SD_STATE_RESET;
-
-  SD_LowLevel_Init();
-
-  uint8_t retry_Cnt = retryCnt;
-  for (;;) {
-    TERN_(USE_WATCHDOG, HAL_watchdog_refresh());
-    status = (bool) HAL_SD_Init(&hsd);
-    if (!status) break;
-    if (!--retry_Cnt) return false;   // return failing status if retries are exhausted
-  }
-
-  go_to_transfer_speed();
-
-  #if PINS_EXIST(SDIO_D1, SDIO_D2, SDIO_D3) // go to 4 bit wide mode if pins are defined
-    retry_Cnt = retryCnt;
-    for (;;) {
-      TERN_(USE_WATCHDOG, HAL_watchdog_refresh());
-      if (!HAL_SD_ConfigWideBusOperation(&hsd, SDIO_BUS_WIDE_4B)) break;  // some cards are only 1 bit wide so a pass here is not required
-      if (!--retry_Cnt) break;
-    }
-    if (!retry_Cnt) {  // wide bus failed, go back to one bit wide mode
-      hsd.State = (HAL_SD_StateTypeDef) 0;  // HAL_SD_STATE_RESET
-      SD_LowLevel_Init();
-      retry_Cnt = retryCnt;
-      for (;;) {
-        TERN_(USE_WATCHDOG, HAL_watchdog_refresh());
-        status = (bool) HAL_SD_Init(&hsd);
-        if (!status) break;
-        if (!--retry_Cnt) return false;   // return failing status if retries are exhausted
-      }
-      go_to_transfer_speed();
-    }
-  #endif
-
-  return true;
-}
-
-static bool SDIO_ReadWriteBlock_DMA(uint32_t block, const uint8_t *src, uint8_t *dst) {
-  if (HAL_SD_GetCardState(&hsd) != HAL_SD_CARD_TRANSFER) return false;
-
-  TERN_(USE_WATCHDOG, HAL_watchdog_refresh());
-
-  HAL_StatusTypeDef ret;
-  if (src) {
-    hdma_sdio.Init.Direction = DMA_MEMORY_TO_PERIPH;
-    HAL_DMA_Init(&hdma_sdio);
-    ret = HAL_SD_WriteBlocks_DMA(&hsd, (uint8_t *)src, block, 1);
-  }
-  else {
-    hdma_sdio.Init.Direction = DMA_PERIPH_TO_MEMORY;
-    HAL_DMA_Init(&hdma_sdio);
-    ret = HAL_SD_ReadBlocks_DMA(&hsd, (uint8_t *)dst, block, 1);
-  }
-
-  if (ret != HAL_OK) {
-    HAL_DMA_Abort_IT(&hdma_sdio);
-    HAL_DMA_DeInit(&hdma_sdio);
-    return false;
-  }
-
-  millis_t timeout = millis() + 500;
-  // Wait the transfer
-  while (hsd.State != HAL_SD_STATE_READY) {
-    if (ELAPSED(millis(), timeout)) {
-      HAL_DMA_Abort_IT(&hdma_sdio);
-      HAL_DMA_DeInit(&hdma_sdio);
-      return false;
-    }
-  }
-
-  while (__HAL_DMA_GET_FLAG(&hdma_sdio, __HAL_DMA_GET_TC_FLAG_INDEX(&hdma_sdio)) != 0
-      || __HAL_DMA_GET_FLAG(&hdma_sdio, __HAL_DMA_GET_TE_FLAG_INDEX(&hdma_sdio)) != 0) { /* nada */ }
-
-  HAL_DMA_Abort_IT(&hdma_sdio);
-  HAL_DMA_DeInit(&hdma_sdio);
-
-  timeout = millis() + 500;
-  while (HAL_SD_GetCardState(&hsd) != HAL_SD_CARD_TRANSFER) if (ELAPSED(millis(), timeout)) return false;
-
-  return true;
-}
-
-bool SDIO_ReadBlock(uint32_t block, uint8_t *dst) {
-  uint8_t retries = SDIO_READ_RETRIES;
-  while (retries--) if (SDIO_ReadWriteBlock_DMA(block, nullptr, dst)) return true;
-  return false;
-}
-
-bool SDIO_WriteBlock(uint32_t block, const uint8_t *src) {
-  uint8_t retries = SDIO_READ_RETRIES;
-  while (retries--) if (SDIO_ReadWriteBlock_DMA(block, src, nullptr)) return true;
-  return false;
-}
-
-bool SDIO_IsReady() {
-  return hsd.State == HAL_SD_STATE_READY;
-}
-
-uint32_t SDIO_GetCardSize() {
-  return (uint32_t)(hsd.SdCard.BlockNbr) * (hsd.SdCard.BlockSize);
-}
-
-#if defined(STM32F1xx)
-  #define DMA_IRQ_HANDLER DMA2_Channel4_5_IRQHandler
-#elif defined(STM32F4xx)
-  #define DMA_IRQ_HANDLER DMA2_Stream3_IRQHandler
-#else
-  #error "Unknown STM32 architecture."
-#endif
-
-extern "C" void SDIO_IRQHandler(void) { HAL_SD_IRQHandler(&hsd); }
-extern "C" void DMA_IRQ_HANDLER(void) { HAL_DMA_IRQHandler(&hdma_sdio); }
-
-#endif // SDIO_SUPPORT
-#endif // HAL_STM32

commit 323b38ee88dbf2a4691a20439dbb95a824822199
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Sep 16 04:36:26 2021 -0500

    💡 Adjust headers, formatting

diff --git a/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp b/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
index 914969f10c..54e1820c78 100644
--- a/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
+++ b/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
@@ -19,6 +19,7 @@
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
+
 #include "../platforms.h"
 
 #ifdef HAL_STM32

commit 76c10b3e02aa5a699ee68a36663337de60fea4e8
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Aug 8 21:31:10 2021 -0500

    🏗️ Define HAL_STM32 for HAL/STM32 (#22537)

diff --git a/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp b/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
index 55e807f94e..914969f10c 100644
--- a/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
+++ b/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
@@ -19,7 +19,9 @@
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
-#if defined(ARDUINO_ARCH_STM32) && !defined(STM32GENERIC) && !defined(MAPLE_STM32F1)
+#include "../platforms.h"
+
+#ifdef HAL_STM32
 
 #include "../../inc/MarlinConfig.h"
 
@@ -320,4 +322,4 @@ extern "C" void SDIO_IRQHandler(void) { HAL_SD_IRQHandler(&hsd); }
 extern "C" void DMA_IRQ_HANDLER(void) { HAL_DMA_IRQHandler(&hdma_sdio); }
 
 #endif // SDIO_SUPPORT
-#endif // ARDUINO_ARCH_STM32 && !STM32GENERIC && !MAPLE_STM32F1
+#endif // HAL_STM32

commit 27f5e64acf0a8b087c899db677618785028bb06f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Jul 24 15:55:45 2021 -0500

    🎨 NULL => nullptr

diff --git a/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp b/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
index 05f859a4af..55e807f94e 100644
--- a/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
+++ b/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
@@ -290,13 +290,13 @@ static bool SDIO_ReadWriteBlock_DMA(uint32_t block, const uint8_t *src, uint8_t
 
 bool SDIO_ReadBlock(uint32_t block, uint8_t *dst) {
   uint8_t retries = SDIO_READ_RETRIES;
-  while (retries--) if (SDIO_ReadWriteBlock_DMA(block, NULL, dst)) return true;
+  while (retries--) if (SDIO_ReadWriteBlock_DMA(block, nullptr, dst)) return true;
   return false;
 }
 
 bool SDIO_WriteBlock(uint32_t block, const uint8_t *src) {
   uint8_t retries = SDIO_READ_RETRIES;
-  while (retries--) if (SDIO_ReadWriteBlock_DMA(block, src, NULL)) return true;
+  while (retries--) if (SDIO_ReadWriteBlock_DMA(block, src, nullptr)) return true;
   return false;
 }
 

commit 65cfbc074104c6b1ae4ef58251e516e3c4bad659
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Wed Jul 14 02:34:18 2021 -0300

    ✨ MSC Support for STM32 + SDIO boards -> SKR 2 (#22354)

diff --git a/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp b/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
index 2ba0359cac..05f859a4af 100644
--- a/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
+++ b/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
@@ -28,319 +28,296 @@
 #include <stdint.h>
 #include <stdbool.h>
 
-#if NONE(STM32F103xE, STM32F103xG, STM32F4xx, STM32F7xx)
-  #error "ERROR - Only STM32F103xE, STM32F103xG, STM32F4xx or STM32F7xx CPUs supported"
+// use local drivers
+#if defined(STM32F103xE) || defined(STM32F103xG)
+  #include <stm32f1xx_hal_rcc_ex.h>
+  #include <stm32f1xx_hal_sd.h>
+#elif defined(STM32F4xx)
+  #include <stm32f4xx_hal_rcc.h>
+  #include <stm32f4xx_hal_dma.h>
+  #include <stm32f4xx_hal_gpio.h>
+  #include <stm32f4xx_hal_sd.h>
+#elif defined(STM32F7xx)
+  #include <stm32f7xx_hal_rcc.h>
+  #include <stm32f7xx_hal_dma.h>
+  #include <stm32f7xx_hal_gpio.h>
+  #include <stm32f7xx_hal_sd.h>
+#else
+  #error "SDIO only supported with STM32F103xE, STM32F103xG, STM32F4xx, or STM32F7xx."
 #endif
 
-#if HAS_SD_HOST_DRIVE
-
-  // use USB drivers
-
-  extern "C" {
-    int8_t SD_MSC_Read(uint8_t lun, uint8_t *buf, uint32_t blk_addr, uint16_t blk_len);
-    int8_t SD_MSC_Write(uint8_t lun, uint8_t *buf, uint32_t blk_addr, uint16_t blk_len);
-    extern SD_HandleTypeDef hsd;
-  }
+// Fixed
+#define SDIO_D0_PIN   PC8
+#define SDIO_D1_PIN   PC9
+#define SDIO_D2_PIN   PC10
+#define SDIO_D3_PIN   PC11
+#define SDIO_CK_PIN   PC12
+#define SDIO_CMD_PIN  PD2
+
+SD_HandleTypeDef hsd;  // create SDIO structure
+// F4 supports one DMA for RX and another for TX, but Marlin will never
+// do read and write at same time, so we use the same DMA for both.
+DMA_HandleTypeDef hdma_sdio;
+
+/*
+  SDIO_INIT_CLK_DIV is 118
+  SDIO clock frequency is 48MHz / (TRANSFER_CLOCK_DIV + 2)
+  SDIO init clock frequency should not exceed 400KHz = 48MHz / (118 + 2)
+
+  Default TRANSFER_CLOCK_DIV is 2 (118 / 40)
+  Default SDIO clock frequency is 48MHz / (2 + 2) = 12 MHz
+  This might be too fast for stable SDIO operations
+
+  MKS Robin board seems to have stable SDIO with BusWide 1bit and ClockDiv 8 i.e. 4.8MHz SDIO clock frequency
+  Additional testing is required as there are clearly some 4bit initialization problems
+*/
+
+#ifndef USBD_OK
+  #define USBD_OK 0
+#endif
 
-  bool SDIO_Init() {
-    return hsd.State == HAL_SD_STATE_READY;  // return pass/fail status
-  }
+// Target Clock, configurable. Default is 18MHz, from STM32F1
+#ifndef SDIO_CLOCK
+  #define SDIO_CLOCK 18000000 // 18 MHz
+#endif
 
-  bool SDIO_ReadBlock(uint32_t block, uint8_t *src) {
-    int8_t status = SD_MSC_Read(0, (uint8_t*)src, block, 1); // read one 512 byte block
-    return (bool) status;
-  }
+// SDIO retries, configurable. Default is 3, from STM32F1
+#ifndef SDIO_READ_RETRIES
+  #define SDIO_READ_RETRIES 3
+#endif
 
-  bool SDIO_WriteBlock(uint32_t block, const uint8_t *src) {
-    int8_t status = SD_MSC_Write(0, (uint8_t*)src, block, 1); // write one 512 byte block
-    return (bool) status;
-  }
+// SDIO Max Clock (naming from STM Manual, don't change)
+#define SDIOCLK 48000000
+
+static uint32_t clock_to_divider(uint32_t clk) {
+  // limit the SDIO master clock to 8/3 of PCLK2. See STM32 Manuals
+  // Also limited to no more than 48Mhz (SDIOCLK).
+  const uint32_t pclk2 = HAL_RCC_GetPCLK2Freq();
+  clk = min(clk, (uint32_t)(pclk2 * 8 / 3));
+  clk = min(clk, (uint32_t)SDIOCLK);
+  // Round up divider, so we don't run the card over the speed supported,
+  // and subtract by 2, because STM32 will add 2, as written in the manual:
+  // SDIO_CK frequency = SDIOCLK / [CLKDIV + 2]
+  return pclk2 / clk + (pclk2 % clk != 0) - 2;
+}
+
+void go_to_transfer_speed() {
+  /* Default SDIO peripheral configuration for SD card initialization */
+  hsd.Init.ClockEdge           = hsd.Init.ClockEdge;
+  hsd.Init.ClockBypass         = hsd.Init.ClockBypass;
+  hsd.Init.ClockPowerSave      = hsd.Init.ClockPowerSave;
+  hsd.Init.BusWide             = hsd.Init.BusWide;
+  hsd.Init.HardwareFlowControl = hsd.Init.HardwareFlowControl;
+  hsd.Init.ClockDiv            = clock_to_divider(SDIO_CLOCK);
+
+  /* Initialize SDIO peripheral interface with default configuration */
+  SDIO_Init(hsd.Instance, hsd.Init);
+}
+
+void SD_LowLevel_Init(void) {
+  uint32_t tempreg;
+
+  __HAL_RCC_GPIOC_CLK_ENABLE(); //enable GPIO clocks
+  __HAL_RCC_GPIOD_CLK_ENABLE(); //enable GPIO clocks
+
+  GPIO_InitTypeDef  GPIO_InitStruct;
+
+  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
+  GPIO_InitStruct.Pull = 1;  //GPIO_NOPULL;
+  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
+
+  #if DISABLED(STM32F1xx)
+    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
+  #endif
 
-#else // !USBD_USE_CDC_COMPOSITE
+  GPIO_InitStruct.Pin = GPIO_PIN_8 | GPIO_PIN_12;  // D0 & SCK
+  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 
-  // use local drivers
-  #if defined(STM32F103xE) || defined(STM32F103xG)
-    #include <stm32f1xx_hal_rcc_ex.h>
-    #include <stm32f1xx_hal_sd.h>
-  #elif defined(STM32F4xx)
-    #include <stm32f4xx_hal_rcc.h>
-    #include <stm32f4xx_hal_dma.h>
-    #include <stm32f4xx_hal_gpio.h>
-    #include <stm32f4xx_hal_sd.h>
-  #elif defined(STM32F7xx)
-    #include <stm32f7xx_hal_rcc.h>
-    #include <stm32f7xx_hal_dma.h>
-    #include <stm32f7xx_hal_gpio.h>
-    #include <stm32f7xx_hal_sd.h>
-  #else
-    #error "ERROR - Only STM32F103xE, STM32F103xG, STM32F4xx or STM32F7xx CPUs supported"
+  #if PINS_EXIST(SDIO_D1, SDIO_D2, SDIO_D3)  // define D1-D3 only if have a four bit wide SDIO bus
+    GPIO_InitStruct.Pin = GPIO_PIN_9 | GPIO_PIN_10 | GPIO_PIN_11;  // D1-D3
+    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
   #endif
 
-  // Fixed
-  #define SDIO_D0_PIN   PC8
-  #define SDIO_D1_PIN   PC9
-  #define SDIO_D2_PIN   PC10
-  #define SDIO_D3_PIN   PC11
-  #define SDIO_CK_PIN   PC12
-  #define SDIO_CMD_PIN  PD2
-
-  SD_HandleTypeDef hsd;  // create SDIO structure
-  // F4 supports one DMA for RX and another for TX, but Marlin will never
-  // do read and write at same time, so we use the same DMA for both.
-  DMA_HandleTypeDef hdma_sdio;
-
-  /*
-    SDIO_INIT_CLK_DIV is 118
-    SDIO clock frequency is 48MHz / (TRANSFER_CLOCK_DIV + 2)
-    SDIO init clock frequency should not exceed 400KHz = 48MHz / (118 + 2)
-
-    Default TRANSFER_CLOCK_DIV is 2 (118 / 40)
-    Default SDIO clock frequency is 48MHz / (2 + 2) = 12 MHz
-    This might be too fast for stable SDIO operations
-
-    MKS Robin board seems to have stable SDIO with BusWide 1bit and ClockDiv 8 i.e. 4.8MHz SDIO clock frequency
-    Additional testing is required as there are clearly some 4bit initialization problems
-  */
-
-  #ifndef USBD_OK
-    #define USBD_OK 0
-  #endif
+  // Configure PD.02 CMD line
+  GPIO_InitStruct.Pin = GPIO_PIN_2;
+  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 
-  // Target Clock, configurable. Default is 18MHz, from STM32F1
-  #ifndef SDIO_CLOCK
-    #define SDIO_CLOCK 18000000 // 18 MHz
+  // Setup DMA
+  #if defined(STM32F1xx)
+    hdma_sdio.Init.Mode = DMA_NORMAL;
+    hdma_sdio.Instance = DMA2_Channel4;
+    HAL_NVIC_EnableIRQ(DMA2_Channel4_5_IRQn);
+  #elif defined(STM32F4xx)
+    hdma_sdio.Init.Mode = DMA_PFCTRL;
+    hdma_sdio.Instance = DMA2_Stream3;
+    hdma_sdio.Init.Channel = DMA_CHANNEL_4;
+    hdma_sdio.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
+    hdma_sdio.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
+    hdma_sdio.Init.MemBurst = DMA_MBURST_INC4;
+    hdma_sdio.Init.PeriphBurst = DMA_PBURST_INC4;
+    HAL_NVIC_EnableIRQ(DMA2_Stream3_IRQn);
   #endif
+  HAL_NVIC_EnableIRQ(SDIO_IRQn);
+  hdma_sdio.Init.PeriphInc = DMA_PINC_DISABLE;
+  hdma_sdio.Init.MemInc = DMA_MINC_ENABLE;
+  hdma_sdio.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
+  hdma_sdio.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
+  hdma_sdio.Init.Priority = DMA_PRIORITY_LOW;
+  __HAL_LINKDMA(&hsd, hdmarx, hdma_sdio);
+  __HAL_LINKDMA(&hsd, hdmatx, hdma_sdio);
 
-  // SDIO retries, configurable. Default is 3, from STM32F1
-  #ifndef SDIO_READ_RETRIES
-    #define SDIO_READ_RETRIES 3
+  #if defined(STM32F1xx)
+    __HAL_RCC_SDIO_CLK_ENABLE();
+    __HAL_RCC_DMA2_CLK_ENABLE();
+  #else
+    __HAL_RCC_SDIO_FORCE_RESET();
+    delay(2);
+    __HAL_RCC_SDIO_RELEASE_RESET();
+    delay(2);
+    __HAL_RCC_SDIO_CLK_ENABLE();
+
+    __HAL_RCC_DMA2_FORCE_RESET();
+    delay(2);
+    __HAL_RCC_DMA2_RELEASE_RESET();
+    delay(2);
+    __HAL_RCC_DMA2_CLK_ENABLE();
   #endif
 
-  // SDIO Max Clock (naming from STM Manual, don't change)
-  #define SDIOCLK 48000000
-
-  static uint32_t clock_to_divider(uint32_t clk) {
-    // limit the SDIO master clock to 8/3 of PCLK2. See STM32 Manuals
-    // Also limited to no more than 48Mhz (SDIOCLK).
-    const uint32_t pclk2 = HAL_RCC_GetPCLK2Freq();
-    clk = min(clk, (uint32_t)(pclk2 * 8 / 3));
-    clk = min(clk, (uint32_t)SDIOCLK);
-    // Round up divider, so we don't run the card over the speed supported,
-    // and subtract by 2, because STM32 will add 2, as written in the manual:
-    // SDIO_CK frequency = SDIOCLK / [CLKDIV + 2]
-    return pclk2 / clk + (pclk2 % clk != 0) - 2;
-  }
-
-  void go_to_transfer_speed() {
-    /* Default SDIO peripheral configuration for SD card initialization */
-    hsd.Init.ClockEdge           = hsd.Init.ClockEdge;
-    hsd.Init.ClockBypass         = hsd.Init.ClockBypass;
-    hsd.Init.ClockPowerSave      = hsd.Init.ClockPowerSave;
-    hsd.Init.BusWide             = hsd.Init.BusWide;
-    hsd.Init.HardwareFlowControl = hsd.Init.HardwareFlowControl;
-    hsd.Init.ClockDiv            = clock_to_divider(SDIO_CLOCK);
-
-    /* Initialize SDIO peripheral interface with default configuration */
-    SDIO_Init(hsd.Instance, hsd.Init);
-  }
-
-  void SD_LowLevel_Init(void) {
-    uint32_t tempreg;
+  //Initialize the SDIO (with initial <400Khz Clock)
+  tempreg = 0;  //Reset value
+  tempreg |= SDIO_CLKCR_CLKEN;  // Clock enabled
+  tempreg |= SDIO_INIT_CLK_DIV; // Clock Divider. Clock = 48000 / (118 + 2) = 400Khz
+  // Keep the rest at 0 => HW_Flow Disabled, Rising Clock Edge, Disable CLK ByPass, Bus Width = 0, Power save Disable
+  SDIO->CLKCR = tempreg;
 
-    __HAL_RCC_GPIOC_CLK_ENABLE(); //enable GPIO clocks
-    __HAL_RCC_GPIOD_CLK_ENABLE(); //enable GPIO clocks
+  // Power up the SDIO
+  SDIO_PowerState_ON(SDIO);
+  hsd.Instance = SDIO;
+}
 
-    GPIO_InitTypeDef  GPIO_InitStruct;
+void HAL_SD_MspInit(SD_HandleTypeDef *hsd) { // application specific init
+  UNUSED(hsd);   // Prevent unused argument(s) compilation warning
+  __HAL_RCC_SDIO_CLK_ENABLE();  // turn on SDIO clock
+}
 
-    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
-    GPIO_InitStruct.Pull = 1;  //GPIO_NOPULL;
-    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
+bool SDIO_Init() {
+  uint8_t retryCnt = SDIO_READ_RETRIES;
 
-    #if DISABLED(STM32F1xx)
-      GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
-    #endif
+  bool status;
+  hsd.Instance = SDIO;
+  hsd.State = HAL_SD_STATE_RESET;
 
-    GPIO_InitStruct.Pin = GPIO_PIN_8 | GPIO_PIN_12;  // D0 & SCK
-    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
+  SD_LowLevel_Init();
 
-    #if PINS_EXIST(SDIO_D1, SDIO_D2, SDIO_D3)  // define D1-D3 only if have a four bit wide SDIO bus
-      GPIO_InitStruct.Pin = GPIO_PIN_9 | GPIO_PIN_10 | GPIO_PIN_11;  // D1-D3
-      HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
-    #endif
-
-    // Configure PD.02 CMD line
-    GPIO_InitStruct.Pin = GPIO_PIN_2;
-    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
-
-    // Setup DMA
-    #if defined(STM32F1xx)
-      hdma_sdio.Init.Mode = DMA_NORMAL;
-      hdma_sdio.Instance = DMA2_Channel4;
-      HAL_NVIC_EnableIRQ(DMA2_Channel4_5_IRQn);
-    #elif defined(STM32F4xx)
-      hdma_sdio.Init.Mode = DMA_PFCTRL;
-      hdma_sdio.Instance = DMA2_Stream3;
-      hdma_sdio.Init.Channel = DMA_CHANNEL_4;
-      hdma_sdio.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
-      hdma_sdio.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
-      hdma_sdio.Init.MemBurst = DMA_MBURST_INC4;
-      hdma_sdio.Init.PeriphBurst = DMA_PBURST_INC4;
-      HAL_NVIC_EnableIRQ(DMA2_Stream3_IRQn);
-    #endif
-    HAL_NVIC_EnableIRQ(SDIO_IRQn);
-    hdma_sdio.Init.PeriphInc = DMA_PINC_DISABLE;
-    hdma_sdio.Init.MemInc = DMA_MINC_ENABLE;
-    hdma_sdio.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
-    hdma_sdio.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
-    hdma_sdio.Init.Priority = DMA_PRIORITY_LOW;
-    __HAL_LINKDMA(&hsd, hdmarx, hdma_sdio);
-    __HAL_LINKDMA(&hsd, hdmatx, hdma_sdio);
-
-    #if defined(STM32F1xx)
-      __HAL_RCC_SDIO_CLK_ENABLE();
-      __HAL_RCC_DMA2_CLK_ENABLE();
-    #else
-      __HAL_RCC_SDIO_FORCE_RESET();
-      delay(2);
-      __HAL_RCC_SDIO_RELEASE_RESET();
-      delay(2);
-      __HAL_RCC_SDIO_CLK_ENABLE();
-
-      __HAL_RCC_DMA2_FORCE_RESET();
-      delay(2);
-      __HAL_RCC_DMA2_RELEASE_RESET();
-      delay(2);
-      __HAL_RCC_DMA2_CLK_ENABLE();
-    #endif
-
-    //Initialize the SDIO (with initial <400Khz Clock)
-    tempreg = 0;  //Reset value
-    tempreg |= SDIO_CLKCR_CLKEN;  // Clock enabled
-    tempreg |= SDIO_INIT_CLK_DIV; // Clock Divider. Clock = 48000 / (118 + 2) = 400Khz
-    // Keep the rest at 0 => HW_Flow Disabled, Rising Clock Edge, Disable CLK ByPass, Bus Width = 0, Power save Disable
-    SDIO->CLKCR = tempreg;
-
-    // Power up the SDIO
-    SDIO_PowerState_ON(SDIO);
-    hsd.Instance = SDIO;
-  }
-
-  void HAL_SD_MspInit(SD_HandleTypeDef *hsd) { // application specific init
-    UNUSED(hsd);   // Prevent unused argument(s) compilation warning
-    __HAL_RCC_SDIO_CLK_ENABLE();  // turn on SDIO clock
+  uint8_t retry_Cnt = retryCnt;
+  for (;;) {
+    TERN_(USE_WATCHDOG, HAL_watchdog_refresh());
+    status = (bool) HAL_SD_Init(&hsd);
+    if (!status) break;
+    if (!--retry_Cnt) return false;   // return failing status if retries are exhausted
   }
 
-  bool SDIO_Init() {
-    uint8_t retryCnt = SDIO_READ_RETRIES;
-
-    bool status;
-    hsd.Instance = SDIO;
-    hsd.State = HAL_SD_STATE_RESET;
+  go_to_transfer_speed();
 
-    SD_LowLevel_Init();
-
-    uint8_t retry_Cnt = retryCnt;
+  #if PINS_EXIST(SDIO_D1, SDIO_D2, SDIO_D3) // go to 4 bit wide mode if pins are defined
+    retry_Cnt = retryCnt;
     for (;;) {
       TERN_(USE_WATCHDOG, HAL_watchdog_refresh());
-      status = (bool) HAL_SD_Init(&hsd);
-      if (!status) break;
-      if (!--retry_Cnt) return false;   // return failing status if retries are exhausted
+      if (!HAL_SD_ConfigWideBusOperation(&hsd, SDIO_BUS_WIDE_4B)) break;  // some cards are only 1 bit wide so a pass here is not required
+      if (!--retry_Cnt) break;
     }
-
-    go_to_transfer_speed();
-
-    #if PINS_EXIST(SDIO_D1, SDIO_D2, SDIO_D3) // go to 4 bit wide mode if pins are defined
+    if (!retry_Cnt) {  // wide bus failed, go back to one bit wide mode
+      hsd.State = (HAL_SD_StateTypeDef) 0;  // HAL_SD_STATE_RESET
+      SD_LowLevel_Init();
       retry_Cnt = retryCnt;
       for (;;) {
         TERN_(USE_WATCHDOG, HAL_watchdog_refresh());
-        if (!HAL_SD_ConfigWideBusOperation(&hsd, SDIO_BUS_WIDE_4B)) break;  // some cards are only 1 bit wide so a pass here is not required
-        if (!--retry_Cnt) break;
+        status = (bool) HAL_SD_Init(&hsd);
+        if (!status) break;
+        if (!--retry_Cnt) return false;   // return failing status if retries are exhausted
       }
-      if (!retry_Cnt) {  // wide bus failed, go back to one bit wide mode
-        hsd.State = (HAL_SD_StateTypeDef) 0;  // HAL_SD_STATE_RESET
-        SD_LowLevel_Init();
-        retry_Cnt = retryCnt;
-        for (;;) {
-          TERN_(USE_WATCHDOG, HAL_watchdog_refresh());
-          status = (bool) HAL_SD_Init(&hsd);
-          if (!status) break;
-          if (!--retry_Cnt) return false;   // return failing status if retries are exhausted
-        }
-        go_to_transfer_speed();
-      }
-    #endif
+      go_to_transfer_speed();
+    }
+  #endif
 
-    return true;
-  }
+  return true;
+}
 
-  static bool SDIO_ReadWriteBlock_DMA(uint32_t block, const uint8_t *src, uint8_t *dst) {
-    if (HAL_SD_GetCardState(&hsd) != HAL_SD_CARD_TRANSFER) return false;
+static bool SDIO_ReadWriteBlock_DMA(uint32_t block, const uint8_t *src, uint8_t *dst) {
+  if (HAL_SD_GetCardState(&hsd) != HAL_SD_CARD_TRANSFER) return false;
 
-    TERN_(USE_WATCHDOG, HAL_watchdog_refresh());
+  TERN_(USE_WATCHDOG, HAL_watchdog_refresh());
 
-    HAL_StatusTypeDef ret;
-    if (src) {
-      hdma_sdio.Init.Direction = DMA_MEMORY_TO_PERIPH;
-      HAL_DMA_Init(&hdma_sdio);
-      ret = HAL_SD_WriteBlocks_DMA(&hsd, (uint8_t *)src, block, 1);
-    }
-    else {
-      hdma_sdio.Init.Direction = DMA_PERIPH_TO_MEMORY;
-      HAL_DMA_Init(&hdma_sdio);
-      ret = HAL_SD_ReadBlocks_DMA(&hsd, (uint8_t *)dst, block, 1);
-    }
+  HAL_StatusTypeDef ret;
+  if (src) {
+    hdma_sdio.Init.Direction = DMA_MEMORY_TO_PERIPH;
+    HAL_DMA_Init(&hdma_sdio);
+    ret = HAL_SD_WriteBlocks_DMA(&hsd, (uint8_t *)src, block, 1);
+  }
+  else {
+    hdma_sdio.Init.Direction = DMA_PERIPH_TO_MEMORY;
+    HAL_DMA_Init(&hdma_sdio);
+    ret = HAL_SD_ReadBlocks_DMA(&hsd, (uint8_t *)dst, block, 1);
+  }
 
-    if (ret != HAL_OK) {
+  if (ret != HAL_OK) {
+    HAL_DMA_Abort_IT(&hdma_sdio);
+    HAL_DMA_DeInit(&hdma_sdio);
+    return false;
+  }
+
+  millis_t timeout = millis() + 500;
+  // Wait the transfer
+  while (hsd.State != HAL_SD_STATE_READY) {
+    if (ELAPSED(millis(), timeout)) {
       HAL_DMA_Abort_IT(&hdma_sdio);
       HAL_DMA_DeInit(&hdma_sdio);
       return false;
     }
+  }
 
-    millis_t timeout = millis() + 500;
-    // Wait the transfer
-    while (hsd.State != HAL_SD_STATE_READY) {
-      if (ELAPSED(millis(), timeout)) {
-        HAL_DMA_Abort_IT(&hdma_sdio);
-        HAL_DMA_DeInit(&hdma_sdio);
-        return false;
-      }
-    }
+  while (__HAL_DMA_GET_FLAG(&hdma_sdio, __HAL_DMA_GET_TC_FLAG_INDEX(&hdma_sdio)) != 0
+      || __HAL_DMA_GET_FLAG(&hdma_sdio, __HAL_DMA_GET_TE_FLAG_INDEX(&hdma_sdio)) != 0) { /* nada */ }
 
-    while (__HAL_DMA_GET_FLAG(&hdma_sdio, __HAL_DMA_GET_TC_FLAG_INDEX(&hdma_sdio)) != 0
-        || __HAL_DMA_GET_FLAG(&hdma_sdio, __HAL_DMA_GET_TE_FLAG_INDEX(&hdma_sdio)) != 0) { /* nada */ }
+  HAL_DMA_Abort_IT(&hdma_sdio);
+  HAL_DMA_DeInit(&hdma_sdio);
 
-    HAL_DMA_Abort_IT(&hdma_sdio);
-    HAL_DMA_DeInit(&hdma_sdio);
+  timeout = millis() + 500;
+  while (HAL_SD_GetCardState(&hsd) != HAL_SD_CARD_TRANSFER) if (ELAPSED(millis(), timeout)) return false;
 
-    timeout = millis() + 500;
-    while (HAL_SD_GetCardState(&hsd) != HAL_SD_CARD_TRANSFER) if (ELAPSED(millis(), timeout)) return false;
+  return true;
+}
 
-    return true;
-  }
+bool SDIO_ReadBlock(uint32_t block, uint8_t *dst) {
+  uint8_t retries = SDIO_READ_RETRIES;
+  while (retries--) if (SDIO_ReadWriteBlock_DMA(block, NULL, dst)) return true;
+  return false;
+}
 
-  bool SDIO_ReadBlock(uint32_t block, uint8_t *dst) {
-    uint8_t retries = SDIO_READ_RETRIES;
-    while (retries--) if (SDIO_ReadWriteBlock_DMA(block, NULL, dst)) return true;
-    return false;
-  }
+bool SDIO_WriteBlock(uint32_t block, const uint8_t *src) {
+  uint8_t retries = SDIO_READ_RETRIES;
+  while (retries--) if (SDIO_ReadWriteBlock_DMA(block, src, NULL)) return true;
+  return false;
+}
 
-  bool SDIO_WriteBlock(uint32_t block, const uint8_t *src) {
-    uint8_t retries = SDIO_READ_RETRIES;
-    while (retries--) if (SDIO_ReadWriteBlock_DMA(block, src, NULL)) return true;
-    return false;
-  }
+bool SDIO_IsReady() {
+  return hsd.State == HAL_SD_STATE_READY;
+}
 
-  #if defined(STM32F1xx)
-    #define DMA_IRQ_HANDLER DMA2_Channel4_5_IRQHandler
-  #elif defined(STM32F4xx)
-    #define DMA_IRQ_HANDLER DMA2_Stream3_IRQHandler
-  #else
-    #error "Unknown STM32 architecture."
-  #endif
+uint32_t SDIO_GetCardSize() {
+  return (uint32_t)(hsd.SdCard.BlockNbr) * (hsd.SdCard.BlockSize);
+}
+
+#if defined(STM32F1xx)
+  #define DMA_IRQ_HANDLER DMA2_Channel4_5_IRQHandler
+#elif defined(STM32F4xx)
+  #define DMA_IRQ_HANDLER DMA2_Stream3_IRQHandler
+#else
+  #error "Unknown STM32 architecture."
+#endif
 
-  extern "C" void SDIO_IRQHandler(void) { HAL_SD_IRQHandler(&hsd); }
-  extern "C" void DMA_IRQ_HANDLER(void) { HAL_DMA_IRQHandler(&hdma_sdio); }
+extern "C" void SDIO_IRQHandler(void) { HAL_SD_IRQHandler(&hsd); }
+extern "C" void DMA_IRQ_HANDLER(void) { HAL_DMA_IRQHandler(&hdma_sdio); }
 
-#endif // !USBD_USE_CDC_COMPOSITE
 #endif // SDIO_SUPPORT
 #endif // ARDUINO_ARCH_STM32 && !STM32GENERIC && !MAPLE_STM32F1

commit 4febb2352179f3de58db2161572de4050197bd5d
Author: MKS-Sean <56996910+MKS-Sean@users.noreply.github.com>
Date:   Tue Jul 13 08:17:28 2021 +0800

    ✨ MKS Robin Nano v3 + TFT_LVGL_UI + WiFi module (#22109)

diff --git a/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp b/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
index 3353f8c36b..2ba0359cac 100644
--- a/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
+++ b/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
@@ -19,7 +19,7 @@
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
-#if defined(ARDUINO_ARCH_STM32) && !defined(STM32GENERIC)
+#if defined(ARDUINO_ARCH_STM32) && !defined(STM32GENERIC) && !defined(MAPLE_STM32F1)
 
 #include "../../inc/MarlinConfig.h"
 
@@ -343,4 +343,4 @@
 
 #endif // !USBD_USE_CDC_COMPOSITE
 #endif // SDIO_SUPPORT
-#endif // ARDUINO_ARCH_STM32 && !STM32GENERIC
+#endif // ARDUINO_ARCH_STM32 && !STM32GENERIC && !MAPLE_STM32F1

commit c6c6c5618669665669e3040821d0b662701bcf3a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Apr 16 02:50:45 2021 -0500

    SDIO cleanup

diff --git a/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp b/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
index 824142b889..3353f8c36b 100644
--- a/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
+++ b/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
@@ -85,8 +85,8 @@
   #define SDIO_CMD_PIN  PD2
 
   SD_HandleTypeDef hsd;  // create SDIO structure
-  // F4 support one dma for RX and another for TX.
-  // But Marlin will never do read and write at same time, so we use always one dma for both.
+  // F4 supports one DMA for RX and another for TX, but Marlin will never
+  // do read and write at same time, so we use the same DMA for both.
   DMA_HandleTypeDef hdma_sdio;
 
   /*
@@ -274,7 +274,7 @@
   }
 
   static bool SDIO_ReadWriteBlock_DMA(uint32_t block, const uint8_t *src, uint8_t *dst) {
-    if(HAL_SD_GetCardState(&hsd) != HAL_SD_CARD_TRANSFER) return false;
+    if (HAL_SD_GetCardState(&hsd) != HAL_SD_CARD_TRANSFER) return false;
 
     TERN_(USE_WATCHDOG, HAL_watchdog_refresh());
 
@@ -296,10 +296,10 @@
       return false;
     }
 
-    uint32_t timeout = millis() + 500;
+    millis_t timeout = millis() + 500;
     // Wait the transfer
     while (hsd.State != HAL_SD_STATE_READY) {
-      if (millis() > timeout) {
+      if (ELAPSED(millis(), timeout)) {
         HAL_DMA_Abort_IT(&hdma_sdio);
         HAL_DMA_DeInit(&hdma_sdio);
         return false;
@@ -313,8 +313,7 @@
     HAL_DMA_DeInit(&hdma_sdio);
 
     timeout = millis() + 500;
-    while (HAL_SD_GetCardState(&hsd) != HAL_SD_CARD_TRANSFER)
-      if (millis() > timeout) return false;
+    while (HAL_SD_GetCardState(&hsd) != HAL_SD_CARD_TRANSFER) if (ELAPSED(millis(), timeout)) return false;
 
     return true;
   }

commit 6e0b79a33b7e6d5405be6d0ae5b16e5f3fd62fac
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Mon Mar 29 23:52:30 2021 -0300

    Fix and add STM32 SDIO DMA (#21476)

diff --git a/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp b/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
index fc9b960c1c..824142b889 100644
--- a/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
+++ b/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
@@ -36,9 +36,10 @@
 
   // use USB drivers
 
-  extern "C" { int8_t SD_MSC_Read(uint8_t lun, uint8_t *buf, uint32_t blk_addr, uint16_t blk_len);
-               int8_t SD_MSC_Write(uint8_t lun, uint8_t *buf, uint32_t blk_addr, uint16_t blk_len);
-               extern SD_HandleTypeDef hsd;
+  extern "C" {
+    int8_t SD_MSC_Read(uint8_t lun, uint8_t *buf, uint32_t blk_addr, uint16_t blk_len);
+    int8_t SD_MSC_Write(uint8_t lun, uint8_t *buf, uint32_t blk_addr, uint16_t blk_len);
+    extern SD_HandleTypeDef hsd;
   }
 
   bool SDIO_Init() {
@@ -75,7 +76,18 @@
     #error "ERROR - Only STM32F103xE, STM32F103xG, STM32F4xx or STM32F7xx CPUs supported"
   #endif
 
+  // Fixed
+  #define SDIO_D0_PIN   PC8
+  #define SDIO_D1_PIN   PC9
+  #define SDIO_D2_PIN   PC10
+  #define SDIO_D3_PIN   PC11
+  #define SDIO_CK_PIN   PC12
+  #define SDIO_CMD_PIN  PD2
+
   SD_HandleTypeDef hsd;  // create SDIO structure
+  // F4 support one dma for RX and another for TX.
+  // But Marlin will never do read and write at same time, so we use always one dma for both.
+  DMA_HandleTypeDef hdma_sdio;
 
   /*
     SDIO_INIT_CLK_DIV is 118
@@ -96,12 +108,12 @@
 
   // Target Clock, configurable. Default is 18MHz, from STM32F1
   #ifndef SDIO_CLOCK
-    #define SDIO_CLOCK                         18000000       /* 18 MHz */
+    #define SDIO_CLOCK 18000000 // 18 MHz
   #endif
 
   // SDIO retries, configurable. Default is 3, from STM32F1
   #ifndef SDIO_READ_RETRIES
-    #define SDIO_READ_RETRIES                  3
+    #define SDIO_READ_RETRIES 3
   #endif
 
   // SDIO Max Clock (naming from STM Manual, don't change)
@@ -120,24 +132,21 @@
   }
 
   void go_to_transfer_speed() {
-    SD_InitTypeDef Init;
-
     /* Default SDIO peripheral configuration for SD card initialization */
-    Init.ClockEdge           = hsd.Init.ClockEdge;
-    Init.ClockBypass         = hsd.Init.ClockBypass;
-    Init.ClockPowerSave      = hsd.Init.ClockPowerSave;
-    Init.BusWide             = hsd.Init.BusWide;
-    Init.HardwareFlowControl = hsd.Init.HardwareFlowControl;
-    Init.ClockDiv            = clock_to_divider(SDIO_CLOCK);
+    hsd.Init.ClockEdge           = hsd.Init.ClockEdge;
+    hsd.Init.ClockBypass         = hsd.Init.ClockBypass;
+    hsd.Init.ClockPowerSave      = hsd.Init.ClockPowerSave;
+    hsd.Init.BusWide             = hsd.Init.BusWide;
+    hsd.Init.HardwareFlowControl = hsd.Init.HardwareFlowControl;
+    hsd.Init.ClockDiv            = clock_to_divider(SDIO_CLOCK);
 
     /* Initialize SDIO peripheral interface with default configuration */
-    SDIO_Init(hsd.Instance, Init);
+    SDIO_Init(hsd.Instance, hsd.Init);
   }
 
   void SD_LowLevel_Init(void) {
     uint32_t tempreg;
 
-    __HAL_RCC_SDIO_CLK_ENABLE();
     __HAL_RCC_GPIOC_CLK_ENABLE(); //enable GPIO clocks
     __HAL_RCC_GPIOD_CLK_ENABLE(); //enable GPIO clocks
 
@@ -163,11 +172,45 @@
     GPIO_InitStruct.Pin = GPIO_PIN_2;
     HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 
-    #if DISABLED(STM32F1xx)
-      // TODO: use __HAL_RCC_SDIO_RELEASE_RESET() and __HAL_RCC_SDIO_CLK_ENABLE();
-      RCC->APB2RSTR &= ~RCC_APB2RSTR_SDIORST_Msk;  // take SDIO out of reset
-      RCC->APB2ENR  |=  RCC_APB2RSTR_SDIORST_Msk;  // enable SDIO clock
-      // Enable the DMA2 Clock
+    // Setup DMA
+    #if defined(STM32F1xx)
+      hdma_sdio.Init.Mode = DMA_NORMAL;
+      hdma_sdio.Instance = DMA2_Channel4;
+      HAL_NVIC_EnableIRQ(DMA2_Channel4_5_IRQn);
+    #elif defined(STM32F4xx)
+      hdma_sdio.Init.Mode = DMA_PFCTRL;
+      hdma_sdio.Instance = DMA2_Stream3;
+      hdma_sdio.Init.Channel = DMA_CHANNEL_4;
+      hdma_sdio.Init.FIFOMode = DMA_FIFOMODE_ENABLE;
+      hdma_sdio.Init.FIFOThreshold = DMA_FIFO_THRESHOLD_FULL;
+      hdma_sdio.Init.MemBurst = DMA_MBURST_INC4;
+      hdma_sdio.Init.PeriphBurst = DMA_PBURST_INC4;
+      HAL_NVIC_EnableIRQ(DMA2_Stream3_IRQn);
+    #endif
+    HAL_NVIC_EnableIRQ(SDIO_IRQn);
+    hdma_sdio.Init.PeriphInc = DMA_PINC_DISABLE;
+    hdma_sdio.Init.MemInc = DMA_MINC_ENABLE;
+    hdma_sdio.Init.PeriphDataAlignment = DMA_PDATAALIGN_WORD;
+    hdma_sdio.Init.MemDataAlignment = DMA_MDATAALIGN_WORD;
+    hdma_sdio.Init.Priority = DMA_PRIORITY_LOW;
+    __HAL_LINKDMA(&hsd, hdmarx, hdma_sdio);
+    __HAL_LINKDMA(&hsd, hdmatx, hdma_sdio);
+
+    #if defined(STM32F1xx)
+      __HAL_RCC_SDIO_CLK_ENABLE();
+      __HAL_RCC_DMA2_CLK_ENABLE();
+    #else
+      __HAL_RCC_SDIO_FORCE_RESET();
+      delay(2);
+      __HAL_RCC_SDIO_RELEASE_RESET();
+      delay(2);
+      __HAL_RCC_SDIO_CLK_ENABLE();
+
+      __HAL_RCC_DMA2_FORCE_RESET();
+      delay(2);
+      __HAL_RCC_DMA2_RELEASE_RESET();
+      delay(2);
+      __HAL_RCC_DMA2_CLK_ENABLE();
     #endif
 
     //Initialize the SDIO (with initial <400Khz Clock)
@@ -179,6 +222,7 @@
 
     // Power up the SDIO
     SDIO_PowerState_ON(SDIO);
+    hsd.Instance = SDIO;
   }
 
   void HAL_SD_MspInit(SD_HandleTypeDef *hsd) { // application specific init
@@ -222,107 +266,82 @@
           if (!status) break;
           if (!--retry_Cnt) return false;   // return failing status if retries are exhausted
         }
+        go_to_transfer_speed();
       }
     #endif
 
     return true;
   }
-  /*
-  void init_SDIO_pins(void) {
-    GPIO_InitTypeDef GPIO_InitStruct = {0};
-
-    // SDIO GPIO Configuration
-    // PC8     ------> SDIO_D0
-    // PC12    ------> SDIO_CK
-    // PD2     ------> SDIO_CMD
-
-    GPIO_InitStruct.Pin = GPIO_PIN_8;
-    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
-    GPIO_InitStruct.Pull = GPIO_NOPULL;
-    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
-    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
-    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
-
-    GPIO_InitStruct.Pin = GPIO_PIN_12;
-    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
-    GPIO_InitStruct.Pull = GPIO_NOPULL;
-    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
-    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
-    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 
-    GPIO_InitStruct.Pin = GPIO_PIN_2;
-    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
-    GPIO_InitStruct.Pull = GPIO_NOPULL;
-    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
-    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
-    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
-  }
-  */
-  //bool SDIO_init() { return (bool) (SD_SDIO_Init() ? 1 : 0);}
-  //bool SDIO_Init_C() { return (bool) (SD_SDIO_Init() ? 1 : 0);}
+  static bool SDIO_ReadWriteBlock_DMA(uint32_t block, const uint8_t *src, uint8_t *dst) {
+    if(HAL_SD_GetCardState(&hsd) != HAL_SD_CARD_TRANSFER) return false;
 
-  bool SDIO_ReadBlock(uint32_t block, uint8_t *dst) {
-    hsd.Instance = SDIO;
-    uint8_t retryCnt = SDIO_READ_RETRIES;
+    TERN_(USE_WATCHDOG, HAL_watchdog_refresh());
 
-    bool status;
-    for (;;) {
-      TERN_(USE_WATCHDOG, HAL_watchdog_refresh());
-      status = (bool) HAL_SD_ReadBlocks(&hsd, (uint8_t*)dst, block, 1, 1000);  // read one 512 byte block with 500mS timeout
-      status |= (bool) HAL_SD_GetCardState(&hsd);     // make sure all is OK
-      if (!status) break;       // return passing status
-      if (!--retryCnt) break;   // return failing status if retries are exhausted
+    HAL_StatusTypeDef ret;
+    if (src) {
+      hdma_sdio.Init.Direction = DMA_MEMORY_TO_PERIPH;
+      HAL_DMA_Init(&hdma_sdio);
+      ret = HAL_SD_WriteBlocks_DMA(&hsd, (uint8_t *)src, block, 1);
+    }
+    else {
+      hdma_sdio.Init.Direction = DMA_PERIPH_TO_MEMORY;
+      HAL_DMA_Init(&hdma_sdio);
+      ret = HAL_SD_ReadBlocks_DMA(&hsd, (uint8_t *)dst, block, 1);
     }
-    return status;
-
-    /*
-    return (bool) ((status_read | status_card) ? 1 : 0);
-
-    if (SDIO_GetCardState() != SDIO_CARD_TRANSFER) return false;
-    if (blockAddress >= SdCard.LogBlockNbr) return false;
-    if ((0x03 & (uint32_t)data)) return false; // misaligned data
-
-    if (SdCard.CardType != CARD_SDHC_SDXC) { blockAddress *= 512U; }
 
-    if (!SDIO_CmdReadSingleBlock(blockAddress)) {
-      SDIO_CLEAR_FLAG(SDIO_ICR_CMD_FLAGS);
-      dma_disable(SDIO_DMA_DEV, SDIO_DMA_CHANNEL);
+    if (ret != HAL_OK) {
+      HAL_DMA_Abort_IT(&hdma_sdio);
+      HAL_DMA_DeInit(&hdma_sdio);
       return false;
     }
 
-    while (!SDIO_GET_FLAG(SDIO_STA_DATAEND | SDIO_STA_TRX_ERROR_FLAGS)) {}
+    uint32_t timeout = millis() + 500;
+    // Wait the transfer
+    while (hsd.State != HAL_SD_STATE_READY) {
+      if (millis() > timeout) {
+        HAL_DMA_Abort_IT(&hdma_sdio);
+        HAL_DMA_DeInit(&hdma_sdio);
+        return false;
+      }
+    }
 
-    dma_disable(SDIO_DMA_DEV, SDIO_DMA_CHANNEL);
+    while (__HAL_DMA_GET_FLAG(&hdma_sdio, __HAL_DMA_GET_TC_FLAG_INDEX(&hdma_sdio)) != 0
+        || __HAL_DMA_GET_FLAG(&hdma_sdio, __HAL_DMA_GET_TE_FLAG_INDEX(&hdma_sdio)) != 0) { /* nada */ }
 
-    if (SDIO->STA & SDIO_STA_RXDAVL) {
-      while (SDIO->STA & SDIO_STA_RXDAVL) (void)SDIO->FIFO;
-      SDIO_CLEAR_FLAG(SDIO_ICR_CMD_FLAGS | SDIO_ICR_DATA_FLAGS);
-      return false;
-    }
+    HAL_DMA_Abort_IT(&hdma_sdio);
+    HAL_DMA_DeInit(&hdma_sdio);
 
-    if (SDIO_GET_FLAG(SDIO_STA_TRX_ERROR_FLAGS)) {
-      SDIO_CLEAR_FLAG(SDIO_ICR_CMD_FLAGS | SDIO_ICR_DATA_FLAGS);
-      return false;
-    }
-    SDIO_CLEAR_FLAG(SDIO_ICR_CMD_FLAGS | SDIO_ICR_DATA_FLAGS);
-    */
+    timeout = millis() + 500;
+    while (HAL_SD_GetCardState(&hsd) != HAL_SD_CARD_TRANSFER)
+      if (millis() > timeout) return false;
 
     return true;
   }
 
+  bool SDIO_ReadBlock(uint32_t block, uint8_t *dst) {
+    uint8_t retries = SDIO_READ_RETRIES;
+    while (retries--) if (SDIO_ReadWriteBlock_DMA(block, NULL, dst)) return true;
+    return false;
+  }
+
   bool SDIO_WriteBlock(uint32_t block, const uint8_t *src) {
-    hsd.Instance = SDIO;
-    uint8_t retryCnt = SDIO_READ_RETRIES;
-    bool status;
-    for (;;) {
-      status = (bool) HAL_SD_WriteBlocks(&hsd, (uint8_t*)src, block, 1, 500);  // write one 512 byte block with 500mS timeout
-      status |= (bool) HAL_SD_GetCardState(&hsd);     // make sure all is OK
-      if (!status) break;       // return passing status
-      if (!--retryCnt) break;   // return failing status if retries are exhausted
-    }
-    return status;
+    uint8_t retries = SDIO_READ_RETRIES;
+    while (retries--) if (SDIO_ReadWriteBlock_DMA(block, src, NULL)) return true;
+    return false;
   }
 
+  #if defined(STM32F1xx)
+    #define DMA_IRQ_HANDLER DMA2_Channel4_5_IRQHandler
+  #elif defined(STM32F4xx)
+    #define DMA_IRQ_HANDLER DMA2_Stream3_IRQHandler
+  #else
+    #error "Unknown STM32 architecture."
+  #endif
+
+  extern "C" void SDIO_IRQHandler(void) { HAL_SD_IRQHandler(&hsd); }
+  extern "C" void DMA_IRQ_HANDLER(void) { HAL_DMA_IRQHandler(&hdma_sdio); }
+
 #endif // !USBD_USE_CDC_COMPOSITE
 #endif // SDIO_SUPPORT
 #endif // ARDUINO_ARCH_STM32 && !STM32GENERIC

commit c74f972627ab8dcf69a637268cf86682959bd18e
Author: X-Ryl669 <boite.pour.spam@gmail.com>
Date:   Mon Feb 1 01:18:39 2021 +0100

    LVGL UI G-code console (#20755)

diff --git a/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp b/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
index e00fb9b16f..fc9b960c1c 100644
--- a/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
+++ b/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
@@ -163,7 +163,6 @@
     GPIO_InitStruct.Pin = GPIO_PIN_2;
     HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 
-
     #if DISABLED(STM32F1xx)
       // TODO: use __HAL_RCC_SDIO_RELEASE_RESET() and __HAL_RCC_SDIO_CLK_ENABLE();
       RCC->APB2RSTR &= ~RCC_APB2RSTR_SDIORST_Msk;  // take SDIO out of reset

commit 2ce9fa4b9c960fef703dc0d5cf31b0d312737a74
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Mon Dec 28 02:08:06 2020 -0300

    Better defaults, compatibility for SDIO + STM32 (#20570)

diff --git a/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp b/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
index a7b1e8006f..e00fb9b16f 100644
--- a/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
+++ b/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
@@ -88,18 +88,37 @@
 
     MKS Robin board seems to have stable SDIO with BusWide 1bit and ClockDiv 8 i.e. 4.8MHz SDIO clock frequency
     Additional testing is required as there are clearly some 4bit initialization problems
-
-    Add -DTRANSFER_CLOCK_DIV=8 to build parameters to improve SDIO stability
   */
 
-  #ifndef TRANSFER_CLOCK_DIV
-    #define TRANSFER_CLOCK_DIV (uint8_t(SDIO_INIT_CLK_DIV) / 40)
-  #endif
-
   #ifndef USBD_OK
     #define USBD_OK 0
   #endif
 
+  // Target Clock, configurable. Default is 18MHz, from STM32F1
+  #ifndef SDIO_CLOCK
+    #define SDIO_CLOCK                         18000000       /* 18 MHz */
+  #endif
+
+  // SDIO retries, configurable. Default is 3, from STM32F1
+  #ifndef SDIO_READ_RETRIES
+    #define SDIO_READ_RETRIES                  3
+  #endif
+
+  // SDIO Max Clock (naming from STM Manual, don't change)
+  #define SDIOCLK 48000000
+
+  static uint32_t clock_to_divider(uint32_t clk) {
+    // limit the SDIO master clock to 8/3 of PCLK2. See STM32 Manuals
+    // Also limited to no more than 48Mhz (SDIOCLK).
+    const uint32_t pclk2 = HAL_RCC_GetPCLK2Freq();
+    clk = min(clk, (uint32_t)(pclk2 * 8 / 3));
+    clk = min(clk, (uint32_t)SDIOCLK);
+    // Round up divider, so we don't run the card over the speed supported,
+    // and subtract by 2, because STM32 will add 2, as written in the manual:
+    // SDIO_CK frequency = SDIOCLK / [CLKDIV + 2]
+    return pclk2 / clk + (pclk2 % clk != 0) - 2;
+  }
+
   void go_to_transfer_speed() {
     SD_InitTypeDef Init;
 
@@ -109,7 +128,7 @@
     Init.ClockPowerSave      = hsd.Init.ClockPowerSave;
     Init.BusWide             = hsd.Init.BusWide;
     Init.HardwareFlowControl = hsd.Init.HardwareFlowControl;
-    Init.ClockDiv            = TRANSFER_CLOCK_DIV;
+    Init.ClockDiv            = clock_to_divider(SDIO_CLOCK);
 
     /* Initialize SDIO peripheral interface with default configuration */
     SDIO_Init(hsd.Instance, Init);
@@ -155,38 +174,25 @@
     //Initialize the SDIO (with initial <400Khz Clock)
     tempreg = 0;  //Reset value
     tempreg |= SDIO_CLKCR_CLKEN;  // Clock enabled
-    tempreg |= (uint32_t)0x76;    // Clock Divider. Clock = 48000 / (118 + 2) = 400Khz
+    tempreg |= SDIO_INIT_CLK_DIV; // Clock Divider. Clock = 48000 / (118 + 2) = 400Khz
     // Keep the rest at 0 => HW_Flow Disabled, Rising Clock Edge, Disable CLK ByPass, Bus Width = 0, Power save Disable
     SDIO->CLKCR = tempreg;
 
     // Power up the SDIO
-    SDIO->POWER = 0x03;
+    SDIO_PowerState_ON(SDIO);
   }
 
   void HAL_SD_MspInit(SD_HandleTypeDef *hsd) { // application specific init
-    UNUSED(hsd);   /* Prevent unused argument(s) compilation warning */
+    UNUSED(hsd);   // Prevent unused argument(s) compilation warning
     __HAL_RCC_SDIO_CLK_ENABLE();  // turn on SDIO clock
   }
 
-  constexpr uint8_t SD_RETRY_COUNT = TERN(SD_CHECK_AND_RETRY, 3, 1);
-
   bool SDIO_Init() {
-    //init SDIO and get SD card info
-
-    uint8_t retryCnt = SD_RETRY_COUNT;
+    uint8_t retryCnt = SDIO_READ_RETRIES;
 
     bool status;
     hsd.Instance = SDIO;
-    hsd.State = (HAL_SD_StateTypeDef) 0;  // HAL_SD_STATE_RESET
-
-    /*
-    hsd.Init.ClockEdge = SDIO_CLOCK_EDGE_RISING;
-    hsd.Init.ClockBypass = SDIO_CLOCK_BYPASS_DISABLE;
-    hsd.Init.ClockPowerSave = SDIO_CLOCK_POWER_SAVE_DISABLE;
-    hsd.Init.BusWide = SDIO_BUS_WIDE_1B;
-    hsd.Init.HardwareFlowControl = SDIO_HARDWARE_FLOW_CONTROL_DISABLE;
-    hsd.Init.ClockDiv = 8;
-    */
+    hsd.State = HAL_SD_STATE_RESET;
 
     SD_LowLevel_Init();
 
@@ -258,7 +264,7 @@
 
   bool SDIO_ReadBlock(uint32_t block, uint8_t *dst) {
     hsd.Instance = SDIO;
-    uint8_t retryCnt = SD_RETRY_COUNT;
+    uint8_t retryCnt = SDIO_READ_RETRIES;
 
     bool status;
     for (;;) {
@@ -307,7 +313,7 @@
 
   bool SDIO_WriteBlock(uint32_t block, const uint8_t *src) {
     hsd.Instance = SDIO;
-    uint8_t retryCnt = SD_RETRY_COUNT;
+    uint8_t retryCnt = SDIO_READ_RETRIES;
     bool status;
     for (;;) {
       status = (bool) HAL_SD_WriteBlocks(&hsd, (uint8_t*)src, block, 1, 500);  // write one 512 byte block with 500mS timeout

commit aa2ced96e05de394abf34cb5b75046f823aa4954
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Nov 26 03:47:07 2020 -0600

    Finish HAL/STM32 cpp wrappers

diff --git a/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp b/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
index 9c2666ed26..a7b1e8006f 100644
--- a/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
+++ b/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
@@ -19,10 +19,11 @@
  * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
+#if defined(ARDUINO_ARCH_STM32) && !defined(STM32GENERIC)
 
 #include "../../inc/MarlinConfig.h"
 
-#if ENABLED(SDIO_SUPPORT) && !defined(STM32GENERIC)
+#if ENABLED(SDIO_SUPPORT)
 
 #include <stdint.h>
 #include <stdbool.h>
@@ -319,3 +320,4 @@
 
 #endif // !USBD_USE_CDC_COMPOSITE
 #endif // SDIO_SUPPORT
+#endif // ARDUINO_ARCH_STM32 && !STM32GENERIC

commit f1cdd02d4cf616da632bf2b7735e1ef7546a936a
Author: Victor Oliveira <rhapsodyv@gmail.com>
Date:   Wed Nov 18 02:48:14 2020 -0300

    Improve USB Media Host conditions (#20176)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp b/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
index 6e73e87c21..9c2666ed26 100644
--- a/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
+++ b/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
@@ -31,7 +31,7 @@
   #error "ERROR - Only STM32F103xE, STM32F103xG, STM32F4xx or STM32F7xx CPUs supported"
 #endif
 
-#ifdef USBD_USE_CDC_COMPOSITE
+#if HAS_SD_HOST_DRIVE
 
   // use USB drivers
 

commit 117df87d193994f6fbcd46c45573095adf921784
Author: Alexander Gavrilenko <jmz52@users.noreply.github.com>
Date:   Thu Jul 30 09:43:19 2020 +0300

    Support for TFT & Touch Screens (#18130)

diff --git a/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp b/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
index 9d32b342e4..6e73e87c21 100644
--- a/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
+++ b/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
@@ -76,7 +76,24 @@
 
   SD_HandleTypeDef hsd;  // create SDIO structure
 
-  #define TRANSFER_CLOCK_DIV (uint8_t(SDIO_INIT_CLK_DIV) / 40)
+  /*
+    SDIO_INIT_CLK_DIV is 118
+    SDIO clock frequency is 48MHz / (TRANSFER_CLOCK_DIV + 2)
+    SDIO init clock frequency should not exceed 400KHz = 48MHz / (118 + 2)
+
+    Default TRANSFER_CLOCK_DIV is 2 (118 / 40)
+    Default SDIO clock frequency is 48MHz / (2 + 2) = 12 MHz
+    This might be too fast for stable SDIO operations
+
+    MKS Robin board seems to have stable SDIO with BusWide 1bit and ClockDiv 8 i.e. 4.8MHz SDIO clock frequency
+    Additional testing is required as there are clearly some 4bit initialization problems
+
+    Add -DTRANSFER_CLOCK_DIV=8 to build parameters to improve SDIO stability
+  */
+
+  #ifndef TRANSFER_CLOCK_DIV
+    #define TRANSFER_CLOCK_DIV (uint8_t(SDIO_INIT_CLK_DIV) / 40)
+  #endif
 
   #ifndef USBD_OK
     #define USBD_OK 0
@@ -100,24 +117,25 @@
   void SD_LowLevel_Init(void) {
     uint32_t tempreg;
 
-    GPIO_InitTypeDef  GPIO_InitStruct;
-
+    __HAL_RCC_SDIO_CLK_ENABLE();
     __HAL_RCC_GPIOC_CLK_ENABLE(); //enable GPIO clocks
     __HAL_RCC_GPIOD_CLK_ENABLE(); //enable GPIO clocks
 
-    GPIO_InitStruct.Pin = GPIO_PIN_8 | GPIO_PIN_12;  // D0 & SCK
+    GPIO_InitTypeDef  GPIO_InitStruct;
+
     GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
     GPIO_InitStruct.Pull = 1;  //GPIO_NOPULL;
     GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
-    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
+
+    #if DISABLED(STM32F1xx)
+      GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
+    #endif
+
+    GPIO_InitStruct.Pin = GPIO_PIN_8 | GPIO_PIN_12;  // D0 & SCK
     HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 
     #if PINS_EXIST(SDIO_D1, SDIO_D2, SDIO_D3)  // define D1-D3 only if have a four bit wide SDIO bus
       GPIO_InitStruct.Pin = GPIO_PIN_9 | GPIO_PIN_10 | GPIO_PIN_11;  // D1-D3
-      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
-      GPIO_InitStruct.Pull = 1;  // GPIO_NOPULL;
-      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
-      GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
       HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
     #endif
 
@@ -125,10 +143,13 @@
     GPIO_InitStruct.Pin = GPIO_PIN_2;
     HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
 
-    RCC->APB2RSTR &= ~RCC_APB2RSTR_SDIORST_Msk;  // take SDIO out of reset
-    RCC->APB2ENR  |=  RCC_APB2RSTR_SDIORST_Msk;  // enable SDIO clock
 
-    // Enable the DMA2 Clock
+    #if DISABLED(STM32F1xx)
+      // TODO: use __HAL_RCC_SDIO_RELEASE_RESET() and __HAL_RCC_SDIO_CLK_ENABLE();
+      RCC->APB2RSTR &= ~RCC_APB2RSTR_SDIORST_Msk;  // take SDIO out of reset
+      RCC->APB2ENR  |=  RCC_APB2RSTR_SDIORST_Msk;  // enable SDIO clock
+      // Enable the DMA2 Clock
+    #endif
 
     //Initialize the SDIO (with initial <400Khz Clock)
     tempreg = 0;  //Reset value
@@ -156,10 +177,21 @@
     bool status;
     hsd.Instance = SDIO;
     hsd.State = (HAL_SD_StateTypeDef) 0;  // HAL_SD_STATE_RESET
+
+    /*
+    hsd.Init.ClockEdge = SDIO_CLOCK_EDGE_RISING;
+    hsd.Init.ClockBypass = SDIO_CLOCK_BYPASS_DISABLE;
+    hsd.Init.ClockPowerSave = SDIO_CLOCK_POWER_SAVE_DISABLE;
+    hsd.Init.BusWide = SDIO_BUS_WIDE_1B;
+    hsd.Init.HardwareFlowControl = SDIO_HARDWARE_FLOW_CONTROL_DISABLE;
+    hsd.Init.ClockDiv = 8;
+    */
+
     SD_LowLevel_Init();
 
     uint8_t retry_Cnt = retryCnt;
     for (;;) {
+      TERN_(USE_WATCHDOG, HAL_watchdog_refresh());
       status = (bool) HAL_SD_Init(&hsd);
       if (!status) break;
       if (!--retry_Cnt) return false;   // return failing status if retries are exhausted
@@ -170,6 +202,7 @@
     #if PINS_EXIST(SDIO_D1, SDIO_D2, SDIO_D3) // go to 4 bit wide mode if pins are defined
       retry_Cnt = retryCnt;
       for (;;) {
+        TERN_(USE_WATCHDOG, HAL_watchdog_refresh());
         if (!HAL_SD_ConfigWideBusOperation(&hsd, SDIO_BUS_WIDE_4B)) break;  // some cards are only 1 bit wide so a pass here is not required
         if (!--retry_Cnt) break;
       }
@@ -178,6 +211,7 @@
         SD_LowLevel_Init();
         retry_Cnt = retryCnt;
         for (;;) {
+          TERN_(USE_WATCHDOG, HAL_watchdog_refresh());
           status = (bool) HAL_SD_Init(&hsd);
           if (!status) break;
           if (!--retry_Cnt) return false;   // return failing status if retries are exhausted
@@ -187,15 +221,15 @@
 
     return true;
   }
-
+  /*
   void init_SDIO_pins(void) {
     GPIO_InitTypeDef GPIO_InitStruct = {0};
 
-    /**SDIO GPIO Configuration
-    PC8     ------> SDIO_D0
-    PC12    ------> SDIO_CK
-    PD2     ------> SDIO_CMD
-    */
+    // SDIO GPIO Configuration
+    // PC8     ------> SDIO_D0
+    // PC12    ------> SDIO_CK
+    // PD2     ------> SDIO_CMD
+
     GPIO_InitStruct.Pin = GPIO_PIN_8;
     GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
     GPIO_InitStruct.Pull = GPIO_NOPULL;
@@ -217,7 +251,7 @@
     GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
     HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
   }
-
+  */
   //bool SDIO_init() { return (bool) (SD_SDIO_Init() ? 1 : 0);}
   //bool SDIO_Init_C() { return (bool) (SD_SDIO_Init() ? 1 : 0);}
 
@@ -227,6 +261,7 @@
 
     bool status;
     for (;;) {
+      TERN_(USE_WATCHDOG, HAL_watchdog_refresh());
       status = (bool) HAL_SD_ReadBlocks(&hsd, (uint8_t*)dst, block, 1, 1000);  // read one 512 byte block with 500mS timeout
       status |= (bool) HAL_SD_GetCardState(&hsd);     // make sure all is OK
       if (!status) break;       // return passing status

commit bc688f27dc6db76021da584bc529f29ddb6f6cce
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Jul 25 01:53:07 2020 -0500

    Clean up after changes

diff --git a/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp b/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
index bab77b55da..9d32b342e4 100644
--- a/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
+++ b/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
@@ -41,8 +41,7 @@
   }
 
   bool SDIO_Init() {
-    if (hsd.State == HAL_SD_STATE_READY) return 1;  // return passing status
-    return 0;                                       // return failing status
+    return hsd.State == HAL_SD_STATE_READY;  // return pass/fail status
   }
 
   bool SDIO_ReadBlock(uint32_t block, uint8_t *src) {
@@ -58,7 +57,6 @@
 #else // !USBD_USE_CDC_COMPOSITE
 
   // use local drivers
-
   #if defined(STM32F103xE) || defined(STM32F103xG)
     #include <stm32f1xx_hal_rcc_ex.h>
     #include <stm32f1xx_hal_sd.h>
@@ -274,7 +272,6 @@
   bool SDIO_WriteBlock(uint32_t block, const uint8_t *src) {
     hsd.Instance = SDIO;
     uint8_t retryCnt = SD_RETRY_COUNT;
-
     bool status;
     for (;;) {
       status = (bool) HAL_SD_WriteBlocks(&hsd, (uint8_t*)src, block, 1, 500);  // write one 512 byte block with 500mS timeout

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp b/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
index 90d6108303..bab77b55da 100644
--- a/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
+++ b/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
@@ -16,7 +16,7 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 

commit 6d90d1e1f552dca5e21bc61b676b8e8ce731b280
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 22 16:35:03 2020 -0500

    Apply TERN to compact code (#17619)

diff --git a/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp b/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
index 3d8e560196..90d6108303 100644
--- a/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
+++ b/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
@@ -148,7 +148,7 @@
     __HAL_RCC_SDIO_CLK_ENABLE();  // turn on SDIO clock
   }
 
-  constexpr uint8_t SD_RETRY_COUNT = 1 + 2 * ENABLED(SD_CHECK_AND_RETRY);
+  constexpr uint8_t SD_RETRY_COUNT = TERN(SD_CHECK_AND_RETRY, 3, 1);
 
   bool SDIO_Init() {
     //init SDIO and get SD card info

commit 33bb7859d446a42d699761f6b5c0a449b40a7d35
Author: Bob Kuhn <bob.kuhn@att.net>
Date:   Wed Apr 22 15:00:10 2020 -0500

    Composite USB for STM32 SDIO (experimental) (#17222)

diff --git a/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp b/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
index ebe15f9391..3d8e560196 100644
--- a/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
+++ b/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
@@ -27,248 +27,263 @@
 #include <stdint.h>
 #include <stdbool.h>
 
-//#include "SdMscDriver.h"
-
-//#include "usbd_msc_bot.h"
-//#include "usbd_msc_scsi.h"
-//#include "usbd_msc_composite.h"
-//#include "usbd_msc_cdc_composite.h"
-
-//#include "usbd_msc_data.h"
-
-#if defined(STM32F103xE) || defined(STM32F103xG)
-  #include <stm32f1xx_hal_rcc_ex.h>
-  #include <stm32f1xx_hal_sd.h>
-#elif defined(STM32F4xx)
-  #include <stm32f4xx_hal_rcc.h>
-  #include <stm32f4xx_hal_dma.h>
-  #include <stm32f4xx_hal_gpio.h>
-  #include <stm32f4xx_hal_sd.h>
-#elif defined(STM32F7xx)
-  #include <stm32f7xx_hal_rcc.h>
-  #include <stm32f7xx_hal_dma.h>
-  #include <stm32f7xx_hal_gpio.h>
-  #include <stm32f7xx_hal_sd.h>
-#else
+#if NONE(STM32F103xE, STM32F103xG, STM32F4xx, STM32F7xx)
   #error "ERROR - Only STM32F103xE, STM32F103xG, STM32F4xx or STM32F7xx CPUs supported"
 #endif
 
-SD_HandleTypeDef hsd;  // create SDIO structure
+#ifdef USBD_USE_CDC_COMPOSITE
 
-#define TRANSFER_CLOCK_DIV ((uint8_t)SDIO_INIT_CLK_DIV/40)
+  // use USB drivers
 
-#ifndef USBD_OK
-  #define USBD_OK 0
-#endif
+  extern "C" { int8_t SD_MSC_Read(uint8_t lun, uint8_t *buf, uint32_t blk_addr, uint16_t blk_len);
+               int8_t SD_MSC_Write(uint8_t lun, uint8_t *buf, uint32_t blk_addr, uint16_t blk_len);
+               extern SD_HandleTypeDef hsd;
+  }
+
+  bool SDIO_Init() {
+    if (hsd.State == HAL_SD_STATE_READY) return 1;  // return passing status
+    return 0;                                       // return failing status
+  }
+
+  bool SDIO_ReadBlock(uint32_t block, uint8_t *src) {
+    int8_t status = SD_MSC_Read(0, (uint8_t*)src, block, 1); // read one 512 byte block
+    return (bool) status;
+  }
+
+  bool SDIO_WriteBlock(uint32_t block, const uint8_t *src) {
+    int8_t status = SD_MSC_Write(0, (uint8_t*)src, block, 1); // write one 512 byte block
+    return (bool) status;
+  }
 
-void go_to_transfer_speed() {
+#else // !USBD_USE_CDC_COMPOSITE
+
+  // use local drivers
+
+  #if defined(STM32F103xE) || defined(STM32F103xG)
+    #include <stm32f1xx_hal_rcc_ex.h>
+    #include <stm32f1xx_hal_sd.h>
+  #elif defined(STM32F4xx)
+    #include <stm32f4xx_hal_rcc.h>
+    #include <stm32f4xx_hal_dma.h>
+    #include <stm32f4xx_hal_gpio.h>
+    #include <stm32f4xx_hal_sd.h>
+  #elif defined(STM32F7xx)
+    #include <stm32f7xx_hal_rcc.h>
+    #include <stm32f7xx_hal_dma.h>
+    #include <stm32f7xx_hal_gpio.h>
+    #include <stm32f7xx_hal_sd.h>
+  #else
+    #error "ERROR - Only STM32F103xE, STM32F103xG, STM32F4xx or STM32F7xx CPUs supported"
+  #endif
 
-  SD_InitTypeDef Init;
+  SD_HandleTypeDef hsd;  // create SDIO structure
 
-  /* Default SDIO peripheral configuration for SD card initialization */
-  Init.ClockEdge           = hsd.Init.ClockEdge;
-  Init.ClockBypass         = hsd.Init.ClockBypass;
-  Init.ClockPowerSave      = hsd.Init.ClockPowerSave;
-  Init.BusWide             = hsd.Init.BusWide;
-  Init.HardwareFlowControl = hsd.Init.HardwareFlowControl;
-  Init.ClockDiv            = TRANSFER_CLOCK_DIV;
+  #define TRANSFER_CLOCK_DIV (uint8_t(SDIO_INIT_CLK_DIV) / 40)
 
-  /* Initialize SDIO peripheral interface with default configuration */
-  SDIO_Init(hsd.Instance, Init);
-}
+  #ifndef USBD_OK
+    #define USBD_OK 0
+  #endif
 
-void SD_LowLevel_Init(void) {
+  void go_to_transfer_speed() {
+    SD_InitTypeDef Init;
 
-  uint32_t tempreg;
+    /* Default SDIO peripheral configuration for SD card initialization */
+    Init.ClockEdge           = hsd.Init.ClockEdge;
+    Init.ClockBypass         = hsd.Init.ClockBypass;
+    Init.ClockPowerSave      = hsd.Init.ClockPowerSave;
+    Init.BusWide             = hsd.Init.BusWide;
+    Init.HardwareFlowControl = hsd.Init.HardwareFlowControl;
+    Init.ClockDiv            = TRANSFER_CLOCK_DIV;
 
-  GPIO_InitTypeDef  GPIO_InitStruct;
+    /* Initialize SDIO peripheral interface with default configuration */
+    SDIO_Init(hsd.Instance, Init);
+  }
 
-  __HAL_RCC_GPIOC_CLK_ENABLE(); //enable GPIO clocks
-  __HAL_RCC_GPIOD_CLK_ENABLE(); //enable GPIO clocks
+  void SD_LowLevel_Init(void) {
+    uint32_t tempreg;
 
-  GPIO_InitStruct.Pin = GPIO_PIN_8 | GPIO_PIN_12;  // D0 & SCK
-  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
-  GPIO_InitStruct.Pull = 1;  //GPIO_NOPULL;
-  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
-  GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
-  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
+    GPIO_InitTypeDef  GPIO_InitStruct;
 
-  #if defined(SDIO_D1_PIN) && defined(SDIO_D2_PIN) && defined(SDIO_D3_PIN)  // define D1-D3 only if have a four bit wide SDIO bus
-    GPIO_InitStruct.Pin = GPIO_PIN_9 | GPIO_PIN_10 | GPIO_PIN_11;  // D1-D3
+    __HAL_RCC_GPIOC_CLK_ENABLE(); //enable GPIO clocks
+    __HAL_RCC_GPIOD_CLK_ENABLE(); //enable GPIO clocks
+
+    GPIO_InitStruct.Pin = GPIO_PIN_8 | GPIO_PIN_12;  // D0 & SCK
     GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
     GPIO_InitStruct.Pull = 1;  //GPIO_NOPULL;
     GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
     GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
     HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
-  #endif
 
-  // Configure PD.02 CMD line
-  GPIO_InitStruct.Pin = GPIO_PIN_2;
-  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
+    #if PINS_EXIST(SDIO_D1, SDIO_D2, SDIO_D3)  // define D1-D3 only if have a four bit wide SDIO bus
+      GPIO_InitStruct.Pin = GPIO_PIN_9 | GPIO_PIN_10 | GPIO_PIN_11;  // D1-D3
+      GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
+      GPIO_InitStruct.Pull = 1;  // GPIO_NOPULL;
+      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
+      GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
+      HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
+    #endif
+
+    // Configure PD.02 CMD line
+    GPIO_InitStruct.Pin = GPIO_PIN_2;
+    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
+
+    RCC->APB2RSTR &= ~RCC_APB2RSTR_SDIORST_Msk;  // take SDIO out of reset
+    RCC->APB2ENR  |=  RCC_APB2RSTR_SDIORST_Msk;  // enable SDIO clock
+
+    // Enable the DMA2 Clock
+
+    //Initialize the SDIO (with initial <400Khz Clock)
+    tempreg = 0;  //Reset value
+    tempreg |= SDIO_CLKCR_CLKEN;  // Clock enabled
+    tempreg |= (uint32_t)0x76;    // Clock Divider. Clock = 48000 / (118 + 2) = 400Khz
+    // Keep the rest at 0 => HW_Flow Disabled, Rising Clock Edge, Disable CLK ByPass, Bus Width = 0, Power save Disable
+    SDIO->CLKCR = tempreg;
+
+    // Power up the SDIO
+    SDIO->POWER = 0x03;
+  }
 
-  RCC->APB2RSTR  &= ~RCC_APB2RSTR_SDIORST_Msk;  // take SDIO out of reset
-  RCC->APB2ENR |= RCC_APB2RSTR_SDIORST_Msk;  // enable SDIO clock
+  void HAL_SD_MspInit(SD_HandleTypeDef *hsd) { // application specific init
+    UNUSED(hsd);   /* Prevent unused argument(s) compilation warning */
+    __HAL_RCC_SDIO_CLK_ENABLE();  // turn on SDIO clock
+  }
 
-  // Enable the DMA2 Clock
+  constexpr uint8_t SD_RETRY_COUNT = 1 + 2 * ENABLED(SD_CHECK_AND_RETRY);
 
-  //Initialize the SDIO (with initial <400Khz Clock)
-  tempreg = 0;  //Reset value
-  tempreg |= SDIO_CLKCR_CLKEN;  //Clock is enabled
-  tempreg |= (uint32_t)0x76;  //Clock Divider. Clock = 48000/(118+2) = 400Khz
-  //Keep the rest at 0 => HW_Flow Disabled, Rising Clock Edge, Disable CLK ByPass, Bus Width = 0, Power save Disable
-  SDIO->CLKCR = tempreg;
+  bool SDIO_Init() {
+    //init SDIO and get SD card info
 
-  //Power up the SDIO
-  SDIO->POWER = 0x03;
-}
+    uint8_t retryCnt = SD_RETRY_COUNT;
 
+    bool status;
+    hsd.Instance = SDIO;
+    hsd.State = (HAL_SD_StateTypeDef) 0;  // HAL_SD_STATE_RESET
+    SD_LowLevel_Init();
 
-void HAL_SD_MspInit(SD_HandleTypeDef *hsd) { // application specific init
-  UNUSED(hsd);   /* Prevent unused argument(s) compilation warning */
-  __HAL_RCC_SDIO_CLK_ENABLE();  // turn on SDIO clock
-}
+    uint8_t retry_Cnt = retryCnt;
+    for (;;) {
+      status = (bool) HAL_SD_Init(&hsd);
+      if (!status) break;
+      if (!--retry_Cnt) return false;   // return failing status if retries are exhausted
+    }
 
-constexpr uint8_t SD_RETRY_COUNT = (1
-  #if ENABLED(SD_CHECK_AND_RETRY)
-    + 2
-  #endif
-);
+    go_to_transfer_speed();
 
-bool SDIO_Init() {
-  //init SDIO and get SD card info
+    #if PINS_EXIST(SDIO_D1, SDIO_D2, SDIO_D3) // go to 4 bit wide mode if pins are defined
+      retry_Cnt = retryCnt;
+      for (;;) {
+        if (!HAL_SD_ConfigWideBusOperation(&hsd, SDIO_BUS_WIDE_4B)) break;  // some cards are only 1 bit wide so a pass here is not required
+        if (!--retry_Cnt) break;
+      }
+      if (!retry_Cnt) {  // wide bus failed, go back to one bit wide mode
+        hsd.State = (HAL_SD_StateTypeDef) 0;  // HAL_SD_STATE_RESET
+        SD_LowLevel_Init();
+        retry_Cnt = retryCnt;
+        for (;;) {
+          status = (bool) HAL_SD_Init(&hsd);
+          if (!status) break;
+          if (!--retry_Cnt) return false;   // return failing status if retries are exhausted
+        }
+      }
+    #endif
+
+    return true;
+  }
 
-  uint8_t retryCnt = SD_RETRY_COUNT;
+  void init_SDIO_pins(void) {
+    GPIO_InitTypeDef GPIO_InitStruct = {0};
 
-  bool status;
-  hsd.Instance = SDIO;
-  hsd.State = (HAL_SD_StateTypeDef) 0;  // HAL_SD_STATE_RESET
-  SD_LowLevel_Init();
+    /**SDIO GPIO Configuration
+    PC8     ------> SDIO_D0
+    PC12    ------> SDIO_CK
+    PD2     ------> SDIO_CMD
+    */
+    GPIO_InitStruct.Pin = GPIO_PIN_8;
+    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
+    GPIO_InitStruct.Pull = GPIO_NOPULL;
+    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
+    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
+    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
 
-  uint8_t retry_Cnt = retryCnt;
-  for (;;) {
-    status = (bool) HAL_SD_Init(&hsd);
-    if (!status) break;
-    if (!--retry_Cnt) return false;   // return failing status if retries are exhausted
+    GPIO_InitStruct.Pin = GPIO_PIN_12;
+    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
+    GPIO_InitStruct.Pull = GPIO_NOPULL;
+    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
+    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
+    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
+
+    GPIO_InitStruct.Pin = GPIO_PIN_2;
+    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
+    GPIO_InitStruct.Pull = GPIO_NOPULL;
+    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
+    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
+    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
   }
 
-  go_to_transfer_speed();
+  //bool SDIO_init() { return (bool) (SD_SDIO_Init() ? 1 : 0);}
+  //bool SDIO_Init_C() { return (bool) (SD_SDIO_Init() ? 1 : 0);}
+
+  bool SDIO_ReadBlock(uint32_t block, uint8_t *dst) {
+    hsd.Instance = SDIO;
+    uint8_t retryCnt = SD_RETRY_COUNT;
 
-  #if defined(SDIO_D1_PIN) && defined(SDIO_D2_PIN) && defined(SDIO_D3_PIN) // go to 4 bit wide mode if pins are defined
-    retry_Cnt = retryCnt;
+    bool status;
     for (;;) {
-      if (!HAL_SD_ConfigWideBusOperation(&hsd, SDIO_BUS_WIDE_4B)) break;  // some cards are only 1 bit wide so a pass here is not required
-      if (!--retry_Cnt) break;
+      status = (bool) HAL_SD_ReadBlocks(&hsd, (uint8_t*)dst, block, 1, 1000);  // read one 512 byte block with 500mS timeout
+      status |= (bool) HAL_SD_GetCardState(&hsd);     // make sure all is OK
+      if (!status) break;       // return passing status
+      if (!--retryCnt) break;   // return failing status if retries are exhausted
     }
-    if (!retry_Cnt) {  // wide bus failed, go back to one bit wide mode
-      hsd.State = (HAL_SD_StateTypeDef) 0;  // HAL_SD_STATE_RESET
-      SD_LowLevel_Init();
-      retry_Cnt = retryCnt;
-      for (;;) {
-        status = (bool) HAL_SD_Init(&hsd);
-        if (!status) break;
-        if (!--retry_Cnt) return false;   // return failing status if retries are exhausted
-      }
-    }
-  #endif
+    return status;
 
-  return true;
-}
-
-void init_SDIO_pins(void) {
-  GPIO_InitTypeDef GPIO_InitStruct = {0};
-
-  /**SDIO GPIO Configuration
-  PC8     ------> SDIO_D0
-  PC12    ------> SDIO_CK
-  PD2     ------> SDIO_CMD
-  */
-  GPIO_InitStruct.Pin = GPIO_PIN_8;
-  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
-  GPIO_InitStruct.Pull = GPIO_NOPULL;
-  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
-  GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
-  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
-
-  GPIO_InitStruct.Pin = GPIO_PIN_12;
-  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
-  GPIO_InitStruct.Pull = GPIO_NOPULL;
-  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
-  GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
-  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
-
-  GPIO_InitStruct.Pin = GPIO_PIN_2;
-  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
-  GPIO_InitStruct.Pull = GPIO_NOPULL;
-  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
-  GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
-  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
-}
-
-//bool SDIO_init() { return (bool) (SD_SDIO_Init() ? 1 : 0);}
-//bool SDIO_Init_C() { return (bool) (SD_SDIO_Init() ? 1 : 0);}
-
-bool SDIO_ReadBlock(uint32_t block, uint8_t *dst) {
-  bool status;
-
-  hsd.Instance = SDIO;
-
-  uint8_t retryCnt = SD_RETRY_COUNT;
-
-  for (;;) {
-    bool status = (bool) HAL_SD_ReadBlocks(&hsd, (uint8_t*)dst, block, 1, 1000);  // read one 512 byte block with 500mS timeout
-    status |= (bool) HAL_SD_GetCardState(&hsd);     // make sure all is OK
-    if (!status)     return false;                  // return passing status
-    if (!--retryCnt) return true;                   // return failing status if retries are exhausted
-  }
+    /*
+    return (bool) ((status_read | status_card) ? 1 : 0);
 
-  /*
-  return (bool) ((status_read | status_card) ? 1 : 0);
+    if (SDIO_GetCardState() != SDIO_CARD_TRANSFER) return false;
+    if (blockAddress >= SdCard.LogBlockNbr) return false;
+    if ((0x03 & (uint32_t)data)) return false; // misaligned data
 
-  if (SDIO_GetCardState() != SDIO_CARD_TRANSFER) return false;
-  if (blockAddress >= SdCard.LogBlockNbr) return false;
-  if ((0x03 & (uint32_t)data)) return false; // misaligned data
+    if (SdCard.CardType != CARD_SDHC_SDXC) { blockAddress *= 512U; }
 
-  if (SdCard.CardType != CARD_SDHC_SDXC) { blockAddress *= 512U; }
+    if (!SDIO_CmdReadSingleBlock(blockAddress)) {
+      SDIO_CLEAR_FLAG(SDIO_ICR_CMD_FLAGS);
+      dma_disable(SDIO_DMA_DEV, SDIO_DMA_CHANNEL);
+      return false;
+    }
 
-  if (!SDIO_CmdReadSingleBlock(blockAddress)) {
-    SDIO_CLEAR_FLAG(SDIO_ICR_CMD_FLAGS);
-    dma_disable(SDIO_DMA_DEV, SDIO_DMA_CHANNEL);
-    return false;
-  }
+    while (!SDIO_GET_FLAG(SDIO_STA_DATAEND | SDIO_STA_TRX_ERROR_FLAGS)) {}
 
-  while (!SDIO_GET_FLAG(SDIO_STA_DATAEND | SDIO_STA_TRX_ERROR_FLAGS)) {}
+    dma_disable(SDIO_DMA_DEV, SDIO_DMA_CHANNEL);
 
-  dma_disable(SDIO_DMA_DEV, SDIO_DMA_CHANNEL);
+    if (SDIO->STA & SDIO_STA_RXDAVL) {
+      while (SDIO->STA & SDIO_STA_RXDAVL) (void)SDIO->FIFO;
+      SDIO_CLEAR_FLAG(SDIO_ICR_CMD_FLAGS | SDIO_ICR_DATA_FLAGS);
+      return false;
+    }
 
-  if (SDIO->STA & SDIO_STA_RXDAVL) {
-    while (SDIO->STA & SDIO_STA_RXDAVL) (void)SDIO->FIFO;
+    if (SDIO_GET_FLAG(SDIO_STA_TRX_ERROR_FLAGS)) {
+      SDIO_CLEAR_FLAG(SDIO_ICR_CMD_FLAGS | SDIO_ICR_DATA_FLAGS);
+      return false;
+    }
     SDIO_CLEAR_FLAG(SDIO_ICR_CMD_FLAGS | SDIO_ICR_DATA_FLAGS);
-    return false;
-  }
+    */
 
-  if (SDIO_GET_FLAG(SDIO_STA_TRX_ERROR_FLAGS)) {
-    SDIO_CLEAR_FLAG(SDIO_ICR_CMD_FLAGS | SDIO_ICR_DATA_FLAGS);
-    return false;
+    return true;
   }
-  SDIO_CLEAR_FLAG(SDIO_ICR_CMD_FLAGS | SDIO_ICR_DATA_FLAGS);
-  */
-
-  return true;
-}
-
-bool SDIO_WriteBlock(uint32_t block, const uint8_t *src) {
-  bool status;
 
-  hsd.Instance = SDIO;
+  bool SDIO_WriteBlock(uint32_t block, const uint8_t *src) {
+    hsd.Instance = SDIO;
+    uint8_t retryCnt = SD_RETRY_COUNT;
 
-  uint8_t retryCnt = SD_RETRY_COUNT;
-
-  for (;;) {
-    status = (bool) HAL_SD_WriteBlocks(&hsd, (uint8_t*)src, block, 1, 500);  // write one 512 byte block with 500mS timeout
-    status |= (bool) HAL_SD_GetCardState(&hsd);     // make sure all is OK
-    if (!status) return (bool) status;              // return passing status
-    if (!--retryCnt) return (bool) status;          // return failing status if retries are exhausted
+    bool status;
+    for (;;) {
+      status = (bool) HAL_SD_WriteBlocks(&hsd, (uint8_t*)src, block, 1, 500);  // write one 512 byte block with 500mS timeout
+      status |= (bool) HAL_SD_GetCardState(&hsd);     // make sure all is OK
+      if (!status) break;       // return passing status
+      if (!--retryCnt) break;   // return failing status if retries are exhausted
+    }
+    return status;
   }
-}
 
+#endif // !USBD_USE_CDC_COMPOSITE
 #endif // SDIO_SUPPORT

commit 6bead0c1b04152f6a291d851f6cd4029fe0fc616
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 13 16:29:29 2020 -0500

    Shorter paths to HAL, ExtUI (#17156)

diff --git a/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp b/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
new file mode 100644
index 0000000000..ebe15f9391
--- /dev/null
+++ b/Marlin/src/HAL/STM32/Sd2Card_sdio_stm32duino.cpp
@@ -0,0 +1,274 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "../../inc/MarlinConfig.h"
+
+#if ENABLED(SDIO_SUPPORT) && !defined(STM32GENERIC)
+
+#include <stdint.h>
+#include <stdbool.h>
+
+//#include "SdMscDriver.h"
+
+//#include "usbd_msc_bot.h"
+//#include "usbd_msc_scsi.h"
+//#include "usbd_msc_composite.h"
+//#include "usbd_msc_cdc_composite.h"
+
+//#include "usbd_msc_data.h"
+
+#if defined(STM32F103xE) || defined(STM32F103xG)
+  #include <stm32f1xx_hal_rcc_ex.h>
+  #include <stm32f1xx_hal_sd.h>
+#elif defined(STM32F4xx)
+  #include <stm32f4xx_hal_rcc.h>
+  #include <stm32f4xx_hal_dma.h>
+  #include <stm32f4xx_hal_gpio.h>
+  #include <stm32f4xx_hal_sd.h>
+#elif defined(STM32F7xx)
+  #include <stm32f7xx_hal_rcc.h>
+  #include <stm32f7xx_hal_dma.h>
+  #include <stm32f7xx_hal_gpio.h>
+  #include <stm32f7xx_hal_sd.h>
+#else
+  #error "ERROR - Only STM32F103xE, STM32F103xG, STM32F4xx or STM32F7xx CPUs supported"
+#endif
+
+SD_HandleTypeDef hsd;  // create SDIO structure
+
+#define TRANSFER_CLOCK_DIV ((uint8_t)SDIO_INIT_CLK_DIV/40)
+
+#ifndef USBD_OK
+  #define USBD_OK 0
+#endif
+
+void go_to_transfer_speed() {
+
+  SD_InitTypeDef Init;
+
+  /* Default SDIO peripheral configuration for SD card initialization */
+  Init.ClockEdge           = hsd.Init.ClockEdge;
+  Init.ClockBypass         = hsd.Init.ClockBypass;
+  Init.ClockPowerSave      = hsd.Init.ClockPowerSave;
+  Init.BusWide             = hsd.Init.BusWide;
+  Init.HardwareFlowControl = hsd.Init.HardwareFlowControl;
+  Init.ClockDiv            = TRANSFER_CLOCK_DIV;
+
+  /* Initialize SDIO peripheral interface with default configuration */
+  SDIO_Init(hsd.Instance, Init);
+}
+
+void SD_LowLevel_Init(void) {
+
+  uint32_t tempreg;
+
+  GPIO_InitTypeDef  GPIO_InitStruct;
+
+  __HAL_RCC_GPIOC_CLK_ENABLE(); //enable GPIO clocks
+  __HAL_RCC_GPIOD_CLK_ENABLE(); //enable GPIO clocks
+
+  GPIO_InitStruct.Pin = GPIO_PIN_8 | GPIO_PIN_12;  // D0 & SCK
+  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
+  GPIO_InitStruct.Pull = 1;  //GPIO_NOPULL;
+  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
+  GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
+  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
+
+  #if defined(SDIO_D1_PIN) && defined(SDIO_D2_PIN) && defined(SDIO_D3_PIN)  // define D1-D3 only if have a four bit wide SDIO bus
+    GPIO_InitStruct.Pin = GPIO_PIN_9 | GPIO_PIN_10 | GPIO_PIN_11;  // D1-D3
+    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
+    GPIO_InitStruct.Pull = 1;  //GPIO_NOPULL;
+    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
+    GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
+    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
+  #endif
+
+  // Configure PD.02 CMD line
+  GPIO_InitStruct.Pin = GPIO_PIN_2;
+  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
+
+  RCC->APB2RSTR  &= ~RCC_APB2RSTR_SDIORST_Msk;  // take SDIO out of reset
+  RCC->APB2ENR |= RCC_APB2RSTR_SDIORST_Msk;  // enable SDIO clock
+
+  // Enable the DMA2 Clock
+
+  //Initialize the SDIO (with initial <400Khz Clock)
+  tempreg = 0;  //Reset value
+  tempreg |= SDIO_CLKCR_CLKEN;  //Clock is enabled
+  tempreg |= (uint32_t)0x76;  //Clock Divider. Clock = 48000/(118+2) = 400Khz
+  //Keep the rest at 0 => HW_Flow Disabled, Rising Clock Edge, Disable CLK ByPass, Bus Width = 0, Power save Disable
+  SDIO->CLKCR = tempreg;
+
+  //Power up the SDIO
+  SDIO->POWER = 0x03;
+}
+
+
+void HAL_SD_MspInit(SD_HandleTypeDef *hsd) { // application specific init
+  UNUSED(hsd);   /* Prevent unused argument(s) compilation warning */
+  __HAL_RCC_SDIO_CLK_ENABLE();  // turn on SDIO clock
+}
+
+constexpr uint8_t SD_RETRY_COUNT = (1
+  #if ENABLED(SD_CHECK_AND_RETRY)
+    + 2
+  #endif
+);
+
+bool SDIO_Init() {
+  //init SDIO and get SD card info
+
+  uint8_t retryCnt = SD_RETRY_COUNT;
+
+  bool status;
+  hsd.Instance = SDIO;
+  hsd.State = (HAL_SD_StateTypeDef) 0;  // HAL_SD_STATE_RESET
+  SD_LowLevel_Init();
+
+  uint8_t retry_Cnt = retryCnt;
+  for (;;) {
+    status = (bool) HAL_SD_Init(&hsd);
+    if (!status) break;
+    if (!--retry_Cnt) return false;   // return failing status if retries are exhausted
+  }
+
+  go_to_transfer_speed();
+
+  #if defined(SDIO_D1_PIN) && defined(SDIO_D2_PIN) && defined(SDIO_D3_PIN) // go to 4 bit wide mode if pins are defined
+    retry_Cnt = retryCnt;
+    for (;;) {
+      if (!HAL_SD_ConfigWideBusOperation(&hsd, SDIO_BUS_WIDE_4B)) break;  // some cards are only 1 bit wide so a pass here is not required
+      if (!--retry_Cnt) break;
+    }
+    if (!retry_Cnt) {  // wide bus failed, go back to one bit wide mode
+      hsd.State = (HAL_SD_StateTypeDef) 0;  // HAL_SD_STATE_RESET
+      SD_LowLevel_Init();
+      retry_Cnt = retryCnt;
+      for (;;) {
+        status = (bool) HAL_SD_Init(&hsd);
+        if (!status) break;
+        if (!--retry_Cnt) return false;   // return failing status if retries are exhausted
+      }
+    }
+  #endif
+
+  return true;
+}
+
+void init_SDIO_pins(void) {
+  GPIO_InitTypeDef GPIO_InitStruct = {0};
+
+  /**SDIO GPIO Configuration
+  PC8     ------> SDIO_D0
+  PC12    ------> SDIO_CK
+  PD2     ------> SDIO_CMD
+  */
+  GPIO_InitStruct.Pin = GPIO_PIN_8;
+  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
+  GPIO_InitStruct.Pull = GPIO_NOPULL;
+  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
+  GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
+  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
+
+  GPIO_InitStruct.Pin = GPIO_PIN_12;
+  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
+  GPIO_InitStruct.Pull = GPIO_NOPULL;
+  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
+  GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
+  HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
+
+  GPIO_InitStruct.Pin = GPIO_PIN_2;
+  GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
+  GPIO_InitStruct.Pull = GPIO_NOPULL;
+  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
+  GPIO_InitStruct.Alternate = GPIO_AF12_SDIO;
+  HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
+}
+
+//bool SDIO_init() { return (bool) (SD_SDIO_Init() ? 1 : 0);}
+//bool SDIO_Init_C() { return (bool) (SD_SDIO_Init() ? 1 : 0);}
+
+bool SDIO_ReadBlock(uint32_t block, uint8_t *dst) {
+  bool status;
+
+  hsd.Instance = SDIO;
+
+  uint8_t retryCnt = SD_RETRY_COUNT;
+
+  for (;;) {
+    bool status = (bool) HAL_SD_ReadBlocks(&hsd, (uint8_t*)dst, block, 1, 1000);  // read one 512 byte block with 500mS timeout
+    status |= (bool) HAL_SD_GetCardState(&hsd);     // make sure all is OK
+    if (!status)     return false;                  // return passing status
+    if (!--retryCnt) return true;                   // return failing status if retries are exhausted
+  }
+
+  /*
+  return (bool) ((status_read | status_card) ? 1 : 0);
+
+  if (SDIO_GetCardState() != SDIO_CARD_TRANSFER) return false;
+  if (blockAddress >= SdCard.LogBlockNbr) return false;
+  if ((0x03 & (uint32_t)data)) return false; // misaligned data
+
+  if (SdCard.CardType != CARD_SDHC_SDXC) { blockAddress *= 512U; }
+
+  if (!SDIO_CmdReadSingleBlock(blockAddress)) {
+    SDIO_CLEAR_FLAG(SDIO_ICR_CMD_FLAGS);
+    dma_disable(SDIO_DMA_DEV, SDIO_DMA_CHANNEL);
+    return false;
+  }
+
+  while (!SDIO_GET_FLAG(SDIO_STA_DATAEND | SDIO_STA_TRX_ERROR_FLAGS)) {}
+
+  dma_disable(SDIO_DMA_DEV, SDIO_DMA_CHANNEL);
+
+  if (SDIO->STA & SDIO_STA_RXDAVL) {
+    while (SDIO->STA & SDIO_STA_RXDAVL) (void)SDIO->FIFO;
+    SDIO_CLEAR_FLAG(SDIO_ICR_CMD_FLAGS | SDIO_ICR_DATA_FLAGS);
+    return false;
+  }
+
+  if (SDIO_GET_FLAG(SDIO_STA_TRX_ERROR_FLAGS)) {
+    SDIO_CLEAR_FLAG(SDIO_ICR_CMD_FLAGS | SDIO_ICR_DATA_FLAGS);
+    return false;
+  }
+  SDIO_CLEAR_FLAG(SDIO_ICR_CMD_FLAGS | SDIO_ICR_DATA_FLAGS);
+  */
+
+  return true;
+}
+
+bool SDIO_WriteBlock(uint32_t block, const uint8_t *src) {
+  bool status;
+
+  hsd.Instance = SDIO;
+
+  uint8_t retryCnt = SD_RETRY_COUNT;
+
+  for (;;) {
+    status = (bool) HAL_SD_WriteBlocks(&hsd, (uint8_t*)src, block, 1, 500);  // write one 512 byte block with 500mS timeout
+    status |= (bool) HAL_SD_GetCardState(&hsd);     // make sure all is OK
+    if (!status) return (bool) status;              // return passing status
+    if (!--retryCnt) return (bool) status;          // return failing status if retries are exhausted
+  }
+}
+
+#endif // SDIO_SUPPORT
