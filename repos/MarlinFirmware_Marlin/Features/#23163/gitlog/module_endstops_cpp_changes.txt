commit f0bc4274f817166fcce82949d94330bd1c441c15
Author: narno2202 <130909513+narno2202@users.noreply.github.com>
Date:   Mon Jul 15 20:13:00 2024 +0200

    üßë‚Äçüíª FT Motion: Individual axis shaping, new buffer management (#26848)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index e9aafa49c8..03f5ab6d8e 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -43,24 +43,20 @@
 #endif
 
 #if ENABLED(BLTOUCH)
   #include "../feature/bltouch.h"
 #endif
 
 #if ENABLED(JOYSTICK)
   #include "../feature/joystick.h"
 #endif
 
-#if ENABLED(FT_MOTION)
-  #include "ft_motion.h"
-#endif
-
 #if HAS_BED_PROBE
   #include "probe.h"
 #endif
 
 Endstops endstops;
 
 // private:
 
 bool Endstops::enabled, Endstops::enabled_globally; // Initialized by settings.load()
 
@@ -830,33 +826,23 @@ void Endstops::update() {
     if (calibration_probe_enabled) {
       #if HAS_CALIBRATION_STATE
         if (TEST(live_state, CALIBRATION) == calibration_stop_state) stepper.quick_stop();
       #else
         if (TEST(live_state, Z_MIN_PROBE) == calibration_stop_state) stepper.quick_stop();
       #endif
     }
   #endif
   // Signal, after validation, if an endstop limit is pressed or not
 
-  bool moving_neg;
-  auto axis_moving_info = [](const AxisEnum axis, const AxisEnum head, bool &neg) -> bool {
-    #if ENABLED(FT_MOTION)
-      if (ftMotion.cfg.mode != ftMotionMode_DISABLED)
-        return (neg = ftMotion.axis_moving_neg(head)) || ftMotion.axis_moving_pos(head);
-    #endif
-    neg = !stepper.motor_direction(head);
-    return stepper.axis_is_moving(axis);
-  };
-
   #if HAS_X_AXIS
-    if (axis_moving_info(X_AXIS, X_AXIS_HEAD, moving_neg)) {
-      if (moving_neg) { // -direction
+    if (stepper.axis_is_moving(X_AXIS)) {
+      if (!stepper.motor_direction(X_AXIS_HEAD)) { // -direction
         #if HAS_X_MIN_STATE
           PROCESS_ENDSTOP_X(MIN);
           #if   CORE_DIAG(XY, Y, MIN)
             PROCESS_CORE_ENDSTOP(Y,MIN,X,MIN);
           #elif CORE_DIAG(XY, Y, MAX)
             PROCESS_CORE_ENDSTOP(Y,MAX,X,MIN);
           #elif CORE_DIAG(XZ, Z, MIN)
             PROCESS_CORE_ENDSTOP(Z,MIN,X,MIN);
           #elif CORE_DIAG(XZ, Z, MAX)
             PROCESS_CORE_ENDSTOP(Z,MAX,X,MIN);
@@ -874,22 +860,22 @@ void Endstops::update() {
             PROCESS_CORE_ENDSTOP(Z,MIN,X,MAX);
           #elif CORE_DIAG(XZ, Z, MAX)
             PROCESS_CORE_ENDSTOP(Z,MAX,X,MAX);
           #endif
         #endif
       }
     }
   #endif // HAS_X_AXIS
 
   #if HAS_Y_AXIS
-    if (axis_moving_info(Y_AXIS, Y_AXIS_HEAD, moving_neg)) {
-      if (moving_neg) { // -direction
+    if (stepper.axis_is_moving(Y_AXIS)) {
+      if (!stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
         #if HAS_Y_MIN_STATE
           PROCESS_ENDSTOP_Y(MIN);
           #if   CORE_DIAG(XY, X, MIN)
             PROCESS_CORE_ENDSTOP(X,MIN,Y,MIN);
           #elif CORE_DIAG(XY, X, MAX)
             PROCESS_CORE_ENDSTOP(X,MAX,Y,MIN);
           #elif CORE_DIAG(YZ, Z, MIN)
             PROCESS_CORE_ENDSTOP(Z,MIN,Y,MIN);
           #elif CORE_DIAG(YZ, Z, MAX)
             PROCESS_CORE_ENDSTOP(Z,MAX,Y,MIN);
@@ -907,22 +893,22 @@ void Endstops::update() {
             PROCESS_CORE_ENDSTOP(Z,MIN,Y,MAX);
           #elif CORE_DIAG(YZ, Z, MAX)
             PROCESS_CORE_ENDSTOP(Z,MAX,Y,MAX);
           #endif
         #endif
       }
     }
   #endif // HAS_Y_AXIS
 
   #if HAS_Z_AXIS
-    if (axis_moving_info(Z_AXIS, Z_AXIS_HEAD, moving_neg)) {
-      if (moving_neg) { // Z -direction. Gantry down, bed up.
+    if (stepper.axis_is_moving(Z_AXIS)) {
+      if (!stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
         #if HAS_Z_MIN_STATE
           // If the Z_MIN_PIN is being used for the probe there's no
           // separate Z_MIN endstop. But a Z endstop could be wired
           // in series, so someone might find this useful.
           if ( TERN1(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN, z_probe_enabled) // When Z_MIN is the probe, the probe must be enabled
             && TERN1(USE_Z_MIN_PROBE, !z_probe_enabled)                   // When Z_MIN isn't the probe, Z MIN is ignored while probing
           ) {
             PROCESS_ENDSTOP_Z(MIN);
             #if   CORE_DIAG(XZ, X, MIN)
               PROCESS_CORE_ENDSTOP(X,MIN,Z,MIN);
@@ -952,97 +938,97 @@ void Endstops::update() {
             PROCESS_CORE_ENDSTOP(Y,MIN,Z,MAX);
           #elif CORE_DIAG(YZ, Y, MAX)
             PROCESS_CORE_ENDSTOP(Y,MAX,Z,MAX);
           #endif
         #endif
       }
     }
   #endif // HAS_Z_AXIS
 
   #if HAS_I_AXIS
-    if (axis_moving_info(I_AXIS, I_AXIS_HEAD, moving_neg)) {
-      if (moving_neg) { // -direction
+    if (stepper.axis_is_moving(I_AXIS)) {
+      if (!stepper.motor_direction(I_AXIS_HEAD)) { // -direction
         #if HAS_I_MIN_STATE
           PROCESS_ENDSTOP(I, MIN);
         #endif
       }
       else { // +direction
         #if HAS_I_MAX_STATE
           PROCESS_ENDSTOP(I, MAX);
         #endif
       }
     }
   #endif // HAS_I_AXIS
 
   #if HAS_J_AXIS
-    if (axis_moving_info(J_AXIS, J_AXIS_HEAD, moving_neg)) {
-      if (moving_neg) { // -direction
+    if (stepper.axis_is_moving(J_AXIS)) {
+      if (!stepper.motor_direction(J_AXIS_HEAD)) { // -direction
         #if HAS_J_MIN_STATE
           PROCESS_ENDSTOP(J, MIN);
         #endif
       }
       else { // +direction
         #if HAS_J_MAX_STATE
           PROCESS_ENDSTOP(J, MAX);
         #endif
       }
     }
   #endif // HAS_J_AXIS
 
   #if HAS_K_AXIS
-    if (axis_moving_info(K_AXIS, K_AXIS_HEAD, moving_neg)) {
-      if (moving_neg) { // -direction
+    if (stepper.axis_is_moving(K_AXIS)) {
+      if (!stepper.motor_direction(K_AXIS_HEAD)) { // -direction
         #if HAS_K_MIN_STATE
           PROCESS_ENDSTOP(K, MIN);
         #endif
       }
       else { // +direction
         #if HAS_K_MAX_STATE
           PROCESS_ENDSTOP(K, MAX);
         #endif
       }
     }
   #endif // HAS_K_AXIS
 
   #if HAS_U_AXIS
-    if (axis_moving_info(U_AXIS, U_AXIS_HEAD, moving_neg)) {
-      if (moving_neg) { // -direction
+    if (stepper.axis_is_moving(U_AXIS)) {
+      if (!stepper.motor_direction(U_AXIS_HEAD)) { // -direction
         #if HAS_U_MIN_STATE
           PROCESS_ENDSTOP(U, MIN);
         #endif
       }
       else { // +direction
         #if HAS_U_MAX_STATE
           PROCESS_ENDSTOP(U, MAX);
         #endif
       }
     }
   #endif // HAS_U_AXIS
 
   #if HAS_V_AXIS
-    if (axis_moving_info(V_AXIS, V_AXIS_HEAD, moving_neg)) {
-      if (moving_neg) { // -direction
+    if (stepper.axis_is_moving(V_AXIS)) {
+      if (!stepper.motor_direction(V_AXIS_HEAD)) { // -direction
         #if HAS_V_MIN_STATE
           PROCESS_ENDSTOP(V, MIN);
         #endif
       }
       else { // +direction
         #if HAS_V_MAX_STATE
           PROCESS_ENDSTOP(V, MAX);
         #endif
       }
     }
   #endif // HAS_V_AXIS
 
   #if HAS_W_AXIS
-    if (axis_moving_info(W_AXIS, W_AXIS_HEAD, moving_neg)) {
-      if (moving_neg) { // -direction
+    if (stepper.axis_is_moving(W_AXIS)) {
+      if (!stepper.motor_direction(W_AXIS_HEAD)) { // -direction
         #if HAS_W_MIN_STATE
           PROCESS_ENDSTOP(W, MIN);
         #endif
       }
       else { // +direction
         #if HAS_W_MAX_STATE
           PROCESS_ENDSTOP(W, MAX);
         #endif
       }
     }

commit 3c601457929ad1656e9dec49250479e0d1f9d89e
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Fri Jul 5 02:31:25 2024 +0100

    ü©π Fix "calibration" endstop report (#27207)
    
    Followup to #27204

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index e7786749b5..e9aafa49c8 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -1300,21 +1300,21 @@ void Endstops::update() {
       #if USE_Z_MIN
         ES_REPORT_CHANGE(Z_MIN);
       #endif
       #if USE_Z_MAX
         ES_REPORT_CHANGE(Z_MAX);
       #endif
       #if USE_Z_MIN_PROBE
         ES_REPORT_CHANGE(Z_MIN_PROBE);
       #endif
       #if USE_CALIBRATION
-        ES_REPORT_STATE(CALIBRATION);
+        ES_REPORT_CHANGE(CALIBRATION);
       #endif
       #if USE_X2_MIN
         ES_REPORT_CHANGE(X2_MIN);
       #endif
       #if USE_X2_MAX
         ES_REPORT_CHANGE(X2_MAX);
       #endif
       #if USE_Y2_MIN
         ES_REPORT_CHANGE(Y2_MIN);
       #endif

commit f2248f79d3c4a3649bd9a4b9d6abab0f94e4af94
Author: Jonathan Brazier <66009857+JonBr306@users.noreply.github.com>
Date:   Mon Jun 24 20:52:49 2024 +0100

    ‚ö°Ô∏è Implement CALIBRATION_GCODE as endstop (#27204)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 33565f7f5d..e7786749b5 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -80,20 +80,25 @@ Endstops::endstop_mask_t Endstops::live_state = 0;
 
 #if ENDSTOP_NOISE_THRESHOLD
   Endstops::endstop_mask_t Endstops::validated_live_state;
   uint8_t Endstops::endstop_poll_count;
 #endif
 
 #if HAS_BED_PROBE
   volatile bool Endstops::z_probe_enabled = false;
 #endif
 
+#if ENABLED(CALIBRATION_GCODE)
+  volatile bool Endstops::calibration_probe_enabled = false;
+  volatile bool Endstops::calibration_stop_state;
+#endif
+
 // Initialized by settings.load()
 #if ENABLED(X_DUAL_ENDSTOPS)
   float Endstops::x2_endstop_adj;
 #endif
 #if ENABLED(Y_DUAL_ENDSTOPS)
   float Endstops::y2_endstop_adj;
 #endif
 #if ENABLED(Z_MULTI_ENDSTOPS)
   float Endstops::z2_endstop_adj;
   #if NUM_Z_STEPPERS >= 3
@@ -196,21 +201,21 @@ void Endstops::init() {
   #if USE_V_MAX
     _INIT_ENDSTOP(MAX,V,);
   #endif
   #if USE_W_MIN
     _INIT_ENDSTOP(MIN,W,);
   #endif
   #if USE_W_MAX
     _INIT_ENDSTOP(MAX,W,);
   #endif
 
-  #if PIN_EXISTS(CALIBRATION)
+  #if USE_CALIBRATION
     #if ENABLED(CALIBRATION_PIN_PULLUP)
       SET_INPUT_PULLUP(CALIBRATION_PIN);
     #elif ENABLED(CALIBRATION_PIN_PULLDOWN)
       SET_INPUT_PULLDOWN(CALIBRATION_PIN);
     #else
       SET_INPUT(CALIBRATION_PIN);
     #endif
   #endif
 
   #if USE_Z_MIN_PROBE
@@ -276,20 +281,31 @@ void Endstops::not_homing() {
 #if HAS_BED_PROBE
   void Endstops::enable_z_probe(const bool onoff) {
     z_probe_enabled = onoff;
     #if PIN_EXISTS(PROBE_ENABLE)
       WRITE(PROBE_ENABLE_PIN, onoff);
     #endif
     resync();
   }
 #endif
 
+// Enable / disable calibration probe checking
+#if ENABLED(CALIBRATION_GCODE)
+  void Endstops::enable_calibration_probe(const bool onoff, const bool stop_state) {
+    // Avoid race condition by setting stop state first
+    if (onoff) calibration_stop_state = stop_state;
+    calibration_probe_enabled = onoff;
+
+    resync();
+  }
+#endif
+
 // Get the stable endstop states when enabled
 void Endstops::resync() {
   if (!abort_enabled()) return;     // If endstops/probes are disabled the loop below can hang
 
   // Wait for Temperature ISR to run at least once (runs at 1kHz)
   TERN(ENDSTOP_INTERRUPTS_FEATURE, update(), safe_delay(2));
   while (TERN0(ENDSTOP_NOISE_THRESHOLD, endstop_poll_count)) safe_delay(1);
 }
 
 #if ENABLED(PINS_DEBUGGING)
@@ -478,20 +494,23 @@ void __O2 Endstops::report_states() {
   #endif
   #if USE_W_MAX
     ES_REPORT(W_MAX);
   #endif
   #if ENABLED(PROBE_ACTIVATION_SWITCH)
     print_es_state(probe_switch_activated(), F(STR_PROBE_EN));
   #endif
   #if USE_Z_MIN_PROBE
     print_es_state(PROBE_TRIGGERED(), F(STR_Z_PROBE));
   #endif
+  #if USE_CALIBRATION
+    print_es_state(READ(CALIBRATION_PIN) != CALIBRATION_PIN_INVERTING, F(STR_CALIBRATION));
+  #endif
   #if MULTI_FILAMENT_SENSOR
     #define _CASE_RUNOUT(N) case N: pin = FIL_RUNOUT##N##_PIN; state = FIL_RUNOUT##N##_STATE; break;
     for (uint8_t i = 1; i <= NUM_RUNOUT_SENSORS; ++i) {
       pin_t pin;
       uint8_t state;
       switch (i) {
         default: continue;
         REPEAT_1(NUM_RUNOUT_SENSORS, _CASE_RUNOUT)
       }
       SERIAL_ECHOPGM(STR_FILAMENT);
@@ -523,20 +542,30 @@ void Endstops::update() {
   #define _ES_PIN(A,M) A##_##M##_PIN
   #define _ES_HIT(A,M) A##_##M##_ENDSTOP_HIT_STATE
   #define UPDATE_LIVE_STATE(AXIS, MINMAX) SET_BIT_TO(live_state, ES_ENUM(AXIS, MINMAX), (READ_ENDSTOP(_ES_PIN(AXIS, MINMAX)) == _ES_HIT(AXIS, MINMAX)))
   #define COPY_LIVE_STATE(SRC_BIT, DST_BIT) SET_BIT_TO(live_state, DST_BIT, TEST(live_state, SRC_BIT))
 
   #if ENABLED(G38_PROBE_TARGET)
     // For G38 moves check the probe's pin for ALL movement
     if (G38_move) UPDATE_LIVE_STATE(Z, TERN(USE_Z_MIN_PROBE, MIN_PROBE, MIN));
   #endif
 
+  #if ENABLED(CALIBRATION_GCODE)
+    if (calibration_probe_enabled) {
+      #if HAS_CALIBRATION_STATE
+        SET_BIT_TO(live_state, CALIBRATION, READ(CALIBRATION_PIN) != CALIBRATION_PIN_INVERTING);
+      #else
+        UPDATE_LIVE_STATE(Z, TERN(USE_Z_MIN_PROBE, MIN_PROBE, MIN));
+      #endif
+    }
+  #endif
+
   // With Dual X, endstops are only checked in the homing direction for the active extruder
   #define X_MIN_TEST() TERN1(DUAL_X_CARRIAGE, stepper.last_moved_extruder == 0) // Check min for the left carriage
   #define X_MAX_TEST() TERN1(DUAL_X_CARRIAGE, stepper.last_moved_extruder != 0) // Check max for the right carriage
 
   // Use HEAD for core axes, AXIS for others
   #if ANY(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY, MARKFORGED_YX)
     #define X_AXIS_HEAD X_HEAD
   #else
     #define X_AXIS_HEAD X_AXIS
   #endif
@@ -790,20 +819,29 @@ void Endstops::update() {
     // For G38 moves check the probe's pin for ALL movement
     if (G38_move && TEST_ENDSTOP(Z_MIN_PROBE) == TERN1(G38_PROBE_AWAY, (G38_move < 4))) {
       G38_did_trigger = true;
       #define _G38_SET(Q) | (stepper.axis_is_moving(_AXIS(Q)) << _AXIS(Q))
       #define _G38_RESP(Q) if (moving[_AXIS(Q)]) { _ENDSTOP_HIT(Q, ENDSTOP); planner.endstop_triggered(_AXIS(Q)); }
       const Flags<NUM_AXES> moving = { uvalue_t(NUM_AXES)(0 MAIN_AXIS_MAP(_G38_SET)) };
       MAIN_AXIS_MAP(_G38_RESP);
     }
   #endif
 
+  #if ENABLED(CALIBRATION_GCODE)
+    if (calibration_probe_enabled) {
+      #if HAS_CALIBRATION_STATE
+        if (TEST(live_state, CALIBRATION) == calibration_stop_state) stepper.quick_stop();
+      #else
+        if (TEST(live_state, Z_MIN_PROBE) == calibration_stop_state) stepper.quick_stop();
+      #endif
+    }
+  #endif
   // Signal, after validation, if an endstop limit is pressed or not
 
   bool moving_neg;
   auto axis_moving_info = [](const AxisEnum axis, const AxisEnum head, bool &neg) -> bool {
     #if ENABLED(FT_MOTION)
       if (ftMotion.cfg.mode != ftMotionMode_DISABLED)
         return (neg = ftMotion.axis_moving_neg(head)) || ftMotion.axis_moving_pos(head);
     #endif
     neg = !stepper.motor_direction(head);
     return stepper.axis_is_moving(axis);
@@ -1166,20 +1204,23 @@ void Endstops::update() {
     #endif
     #if USE_Z_MIN
       ES_GET_STATE(Z_MIN);
     #endif
     #if USE_Z_MAX
       ES_GET_STATE(Z_MAX);
     #endif
     #if USE_Z_MIN_PROBE
       ES_GET_STATE(Z_MIN_PROBE);
     #endif
+    #if USE_CALIBRATION
+      ES_GET_STATE(CALIBRATION);
+    #endif
     #if USE_X2_MIN
       ES_GET_STATE(X2_MIN);
     #endif
     #if USE_X2_MAX
       ES_GET_STATE(X2_MAX);
     #endif
     #if USE_Y2_MIN
       ES_GET_STATE(Y2_MIN);
     #endif
     #if USE_Y2_MAX
@@ -1258,20 +1299,23 @@ void Endstops::update() {
       #endif
       #if USE_Z_MIN
         ES_REPORT_CHANGE(Z_MIN);
       #endif
       #if USE_Z_MAX
         ES_REPORT_CHANGE(Z_MAX);
       #endif
       #if USE_Z_MIN_PROBE
         ES_REPORT_CHANGE(Z_MIN_PROBE);
       #endif
+      #if USE_CALIBRATION
+        ES_REPORT_STATE(CALIBRATION);
+      #endif
       #if USE_X2_MIN
         ES_REPORT_CHANGE(X2_MIN);
       #endif
       #if USE_X2_MAX
         ES_REPORT_CHANGE(X2_MAX);
       #endif
       #if USE_Y2_MIN
         ES_REPORT_CHANGE(Y2_MIN);
       #endif
       #if USE_Y2_MAX

commit 2fc86ad836b20570280f805396d05d4d636e4157
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jun 15 19:11:19 2024 -0500

    üêõ Fix homing when FT Motion exists (#27179)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index d0ad234a7f..33565f7f5d 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -779,46 +779,46 @@ void Endstops::update() {
   #if DISABLED(Z_MULTI_ENDSTOPS)
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_ENDSTOP(Z, MINMAX)
   #elif NUM_Z_STEPPERS == 4
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_QUAD_ENDSTOP(Z, MINMAX)
   #elif NUM_Z_STEPPERS == 3
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_TRIPLE_ENDSTOP(Z, MINMAX)
   #else
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_DUAL_ENDSTOP(Z, MINMAX)
   #endif
 
-
   #if ENABLED(G38_PROBE_TARGET)
     // For G38 moves check the probe's pin for ALL movement
     if (G38_move && TEST_ENDSTOP(Z_MIN_PROBE) == TERN1(G38_PROBE_AWAY, (G38_move < 4))) {
       G38_did_trigger = true;
       #define _G38_SET(Q) | (stepper.axis_is_moving(_AXIS(Q)) << _AXIS(Q))
       #define _G38_RESP(Q) if (moving[_AXIS(Q)]) { _ENDSTOP_HIT(Q, ENDSTOP); planner.endstop_triggered(_AXIS(Q)); }
       const Flags<NUM_AXES> moving = { uvalue_t(NUM_AXES)(0 MAIN_AXIS_MAP(_G38_SET)) };
       MAIN_AXIS_MAP(_G38_RESP);
     }
   #endif
 
   // Signal, after validation, if an endstop limit is pressed or not
 
-  #if HAS_X_AXIS
+  bool moving_neg;
+  auto axis_moving_info = [](const AxisEnum axis, const AxisEnum head, bool &neg) -> bool {
     #if ENABLED(FT_MOTION)
-      const bool x_moving_pos = ftMotion.axis_moving_pos(X_AXIS_HEAD),
-                 x_moving_neg = ftMotion.axis_moving_neg(X_AXIS_HEAD);
-      #define X_MOVE_TEST x_moving_pos || x_moving_neg
-      #define X_NEG_DIR_TEST x_moving_neg
-    #else
-      #define X_MOVE_TEST stepper.axis_is_moving(X_AXIS)
-      #define X_NEG_DIR_TEST !stepper.motor_direction(X_AXIS_HEAD)
+      if (ftMotion.cfg.mode != ftMotionMode_DISABLED)
+        return (neg = ftMotion.axis_moving_neg(head)) || ftMotion.axis_moving_pos(head);
     #endif
-    if (X_MOVE_TEST) {
-      if (X_NEG_DIR_TEST) { // -direction
+    neg = !stepper.motor_direction(head);
+    return stepper.axis_is_moving(axis);
+  };
+
+  #if HAS_X_AXIS
+    if (axis_moving_info(X_AXIS, X_AXIS_HEAD, moving_neg)) {
+      if (moving_neg) { // -direction
         #if HAS_X_MIN_STATE
           PROCESS_ENDSTOP_X(MIN);
           #if   CORE_DIAG(XY, Y, MIN)
             PROCESS_CORE_ENDSTOP(Y,MIN,X,MIN);
           #elif CORE_DIAG(XY, Y, MAX)
             PROCESS_CORE_ENDSTOP(Y,MAX,X,MIN);
           #elif CORE_DIAG(XZ, Z, MIN)
             PROCESS_CORE_ENDSTOP(Z,MIN,X,MIN);
           #elif CORE_DIAG(XZ, Z, MAX)
             PROCESS_CORE_ENDSTOP(Z,MAX,X,MIN);
@@ -836,31 +836,22 @@ void Endstops::update() {
             PROCESS_CORE_ENDSTOP(Z,MIN,X,MAX);
           #elif CORE_DIAG(XZ, Z, MAX)
             PROCESS_CORE_ENDSTOP(Z,MAX,X,MAX);
           #endif
         #endif
       }
     }
   #endif // HAS_X_AXIS
 
   #if HAS_Y_AXIS
-    #if ENABLED(FT_MOTION)
-      const bool y_moving_pos = ftMotion.axis_moving_pos(Y_AXIS_HEAD),
-                 y_moving_neg = ftMotion.axis_moving_neg(Y_AXIS_HEAD);
-      #define Y_MOVE_TEST y_moving_pos || y_moving_neg
-      #define Y_NEG_DIR_TEST y_moving_neg
-    #else
-      #define Y_MOVE_TEST stepper.axis_is_moving(Y_AXIS)
-      #define Y_NEG_DIR_TEST !stepper.motor_direction(Y_AXIS_HEAD)
-    #endif
-    if (Y_MOVE_TEST) {
-      if (Y_NEG_DIR_TEST) { // -direction
+    if (axis_moving_info(Y_AXIS, Y_AXIS_HEAD, moving_neg)) {
+      if (moving_neg) { // -direction
         #if HAS_Y_MIN_STATE
           PROCESS_ENDSTOP_Y(MIN);
           #if   CORE_DIAG(XY, X, MIN)
             PROCESS_CORE_ENDSTOP(X,MIN,Y,MIN);
           #elif CORE_DIAG(XY, X, MAX)
             PROCESS_CORE_ENDSTOP(X,MAX,Y,MIN);
           #elif CORE_DIAG(YZ, Z, MIN)
             PROCESS_CORE_ENDSTOP(Z,MIN,Y,MIN);
           #elif CORE_DIAG(YZ, Z, MAX)
             PROCESS_CORE_ENDSTOP(Z,MAX,Y,MIN);
@@ -878,31 +869,22 @@ void Endstops::update() {
             PROCESS_CORE_ENDSTOP(Z,MIN,Y,MAX);
           #elif CORE_DIAG(YZ, Z, MAX)
             PROCESS_CORE_ENDSTOP(Z,MAX,Y,MAX);
           #endif
         #endif
       }
     }
   #endif // HAS_Y_AXIS
 
   #if HAS_Z_AXIS
-    #if ENABLED(FT_MOTION)
-      const bool z_moving_pos = ftMotion.axis_moving_pos(Z_AXIS_HEAD),
-                 z_moving_neg = ftMotion.axis_moving_neg(Z_AXIS_HEAD);
-      #define Z_MOVE_TEST z_moving_pos || z_moving_neg
-      #define Z_NEG_DIR_TEST z_moving_neg
-    #else
-      #define Z_MOVE_TEST stepper.axis_is_moving(Z_AXIS)
-      #define Z_NEG_DIR_TEST !stepper.motor_direction(Z_AXIS_HEAD)
-    #endif
-    if (Z_MOVE_TEST) {
-      if (Z_NEG_DIR_TEST) { // Z -direction. Gantry down, bed up.
+    if (axis_moving_info(Z_AXIS, Z_AXIS_HEAD, moving_neg)) {
+      if (moving_neg) { // Z -direction. Gantry down, bed up.
         #if HAS_Z_MIN_STATE
           // If the Z_MIN_PIN is being used for the probe there's no
           // separate Z_MIN endstop. But a Z endstop could be wired
           // in series, so someone might find this useful.
           if ( TERN1(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN, z_probe_enabled) // When Z_MIN is the probe, the probe must be enabled
             && TERN1(USE_Z_MIN_PROBE, !z_probe_enabled)                   // When Z_MIN isn't the probe, Z MIN is ignored while probing
           ) {
             PROCESS_ENDSTOP_Z(MIN);
             #if   CORE_DIAG(XZ, X, MIN)
               PROCESS_CORE_ENDSTOP(X,MIN,Z,MIN);
@@ -932,98 +914,97 @@ void Endstops::update() {
             PROCESS_CORE_ENDSTOP(Y,MIN,Z,MAX);
           #elif CORE_DIAG(YZ, Y, MAX)
             PROCESS_CORE_ENDSTOP(Y,MAX,Z,MAX);
           #endif
         #endif
       }
     }
   #endif // HAS_Z_AXIS
 
   #if HAS_I_AXIS
-  // TODO: FT_Motion logic.
-    if (stepper.axis_is_moving(I_AXIS)) {
-      if (!stepper.motor_direction(I_AXIS_HEAD)) { // -direction
+    if (axis_moving_info(I_AXIS, I_AXIS_HEAD, moving_neg)) {
+      if (moving_neg) { // -direction
         #if HAS_I_MIN_STATE
           PROCESS_ENDSTOP(I, MIN);
         #endif
       }
       else { // +direction
         #if HAS_I_MAX_STATE
           PROCESS_ENDSTOP(I, MAX);
         #endif
       }
     }
   #endif // HAS_I_AXIS
 
   #if HAS_J_AXIS
-    if (stepper.axis_is_moving(J_AXIS)) {
-      if (!stepper.motor_direction(J_AXIS_HEAD)) { // -direction
+    if (axis_moving_info(J_AXIS, J_AXIS_HEAD, moving_neg)) {
+      if (moving_neg) { // -direction
         #if HAS_J_MIN_STATE
           PROCESS_ENDSTOP(J, MIN);
         #endif
       }
       else { // +direction
         #if HAS_J_MAX_STATE
           PROCESS_ENDSTOP(J, MAX);
         #endif
       }
     }
   #endif // HAS_J_AXIS
 
   #if HAS_K_AXIS
-    if (stepper.axis_is_moving(K_AXIS)) {
-      if (!stepper.motor_direction(K_AXIS_HEAD)) { // -direction
+    if (axis_moving_info(K_AXIS, K_AXIS_HEAD, moving_neg)) {
+      if (moving_neg) { // -direction
         #if HAS_K_MIN_STATE
           PROCESS_ENDSTOP(K, MIN);
         #endif
       }
       else { // +direction
         #if HAS_K_MAX_STATE
           PROCESS_ENDSTOP(K, MAX);
         #endif
       }
     }
   #endif // HAS_K_AXIS
 
   #if HAS_U_AXIS
-    if (stepper.axis_is_moving(U_AXIS)) {
-      if (!stepper.motor_direction(U_AXIS_HEAD)) { // -direction
+    if (axis_moving_info(U_AXIS, U_AXIS_HEAD, moving_neg)) {
+      if (moving_neg) { // -direction
         #if HAS_U_MIN_STATE
           PROCESS_ENDSTOP(U, MIN);
         #endif
       }
       else { // +direction
         #if HAS_U_MAX_STATE
           PROCESS_ENDSTOP(U, MAX);
         #endif
       }
     }
   #endif // HAS_U_AXIS
 
   #if HAS_V_AXIS
-    if (stepper.axis_is_moving(V_AXIS)) {
-      if (!stepper.motor_direction(V_AXIS_HEAD)) { // -direction
+    if (axis_moving_info(V_AXIS, V_AXIS_HEAD, moving_neg)) {
+      if (moving_neg) { // -direction
         #if HAS_V_MIN_STATE
           PROCESS_ENDSTOP(V, MIN);
         #endif
       }
       else { // +direction
         #if HAS_V_MAX_STATE
           PROCESS_ENDSTOP(V, MAX);
         #endif
       }
     }
   #endif // HAS_V_AXIS
 
   #if HAS_W_AXIS
-    if (stepper.axis_is_moving(W_AXIS)) {
-      if (!stepper.motor_direction(W_AXIS_HEAD)) { // -direction
+    if (axis_moving_info(W_AXIS, W_AXIS_HEAD, moving_neg)) {
+      if (moving_neg) { // -direction
         #if HAS_W_MIN_STATE
           PROCESS_ENDSTOP(W, MIN);
         #endif
       }
       else { // +direction
         #if HAS_W_MAX_STATE
           PROCESS_ENDSTOP(W, MAX);
         #endif
       }
     }

commit 1da947f54806437fdff84adfdc06f48d2e3d60a3
Author: narno2202 <130909513+narno2202@users.noreply.github.com>
Date:   Thu May 9 23:57:23 2024 +0200

    ‚ö°Ô∏è FT_MOTION : Core and other refinements (#26720)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>
    Co-authored-by: Ulendo Alex <alex@ulendo.io>

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 09154b65a2..d0ad234a7f 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -43,20 +43,24 @@
 #endif
 
 #if ENABLED(BLTOUCH)
   #include "../feature/bltouch.h"
 #endif
 
 #if ENABLED(JOYSTICK)
   #include "../feature/joystick.h"
 #endif
 
+#if ENABLED(FT_MOTION)
+  #include "ft_motion.h"
+#endif
+
 #if HAS_BED_PROBE
   #include "probe.h"
 #endif
 
 Endstops endstops;
 
 // private:
 
 bool Endstops::enabled, Endstops::enabled_globally; // Initialized by settings.load()
 
@@ -775,36 +779,46 @@ void Endstops::update() {
   #if DISABLED(Z_MULTI_ENDSTOPS)
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_ENDSTOP(Z, MINMAX)
   #elif NUM_Z_STEPPERS == 4
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_QUAD_ENDSTOP(Z, MINMAX)
   #elif NUM_Z_STEPPERS == 3
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_TRIPLE_ENDSTOP(Z, MINMAX)
   #else
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_DUAL_ENDSTOP(Z, MINMAX)
   #endif
 
+
   #if ENABLED(G38_PROBE_TARGET)
     // For G38 moves check the probe's pin for ALL movement
     if (G38_move && TEST_ENDSTOP(Z_MIN_PROBE) == TERN1(G38_PROBE_AWAY, (G38_move < 4))) {
       G38_did_trigger = true;
       #define _G38_SET(Q) | (stepper.axis_is_moving(_AXIS(Q)) << _AXIS(Q))
       #define _G38_RESP(Q) if (moving[_AXIS(Q)]) { _ENDSTOP_HIT(Q, ENDSTOP); planner.endstop_triggered(_AXIS(Q)); }
       const Flags<NUM_AXES> moving = { uvalue_t(NUM_AXES)(0 MAIN_AXIS_MAP(_G38_SET)) };
       MAIN_AXIS_MAP(_G38_RESP);
     }
   #endif
 
   // Signal, after validation, if an endstop limit is pressed or not
 
   #if HAS_X_AXIS
-    if (stepper.axis_is_moving(X_AXIS)) {
-      if (!stepper.motor_direction(X_AXIS_HEAD)) { // -direction
+    #if ENABLED(FT_MOTION)
+      const bool x_moving_pos = ftMotion.axis_moving_pos(X_AXIS_HEAD),
+                 x_moving_neg = ftMotion.axis_moving_neg(X_AXIS_HEAD);
+      #define X_MOVE_TEST x_moving_pos || x_moving_neg
+      #define X_NEG_DIR_TEST x_moving_neg
+    #else
+      #define X_MOVE_TEST stepper.axis_is_moving(X_AXIS)
+      #define X_NEG_DIR_TEST !stepper.motor_direction(X_AXIS_HEAD)
+    #endif
+    if (X_MOVE_TEST) {
+      if (X_NEG_DIR_TEST) { // -direction
         #if HAS_X_MIN_STATE
           PROCESS_ENDSTOP_X(MIN);
           #if   CORE_DIAG(XY, Y, MIN)
             PROCESS_CORE_ENDSTOP(Y,MIN,X,MIN);
           #elif CORE_DIAG(XY, Y, MAX)
             PROCESS_CORE_ENDSTOP(Y,MAX,X,MIN);
           #elif CORE_DIAG(XZ, Z, MIN)
             PROCESS_CORE_ENDSTOP(Z,MIN,X,MIN);
           #elif CORE_DIAG(XZ, Z, MAX)
             PROCESS_CORE_ENDSTOP(Z,MAX,X,MIN);
@@ -822,22 +836,31 @@ void Endstops::update() {
             PROCESS_CORE_ENDSTOP(Z,MIN,X,MAX);
           #elif CORE_DIAG(XZ, Z, MAX)
             PROCESS_CORE_ENDSTOP(Z,MAX,X,MAX);
           #endif
         #endif
       }
     }
   #endif // HAS_X_AXIS
 
   #if HAS_Y_AXIS
-    if (stepper.axis_is_moving(Y_AXIS)) {
-      if (!stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
+    #if ENABLED(FT_MOTION)
+      const bool y_moving_pos = ftMotion.axis_moving_pos(Y_AXIS_HEAD),
+                 y_moving_neg = ftMotion.axis_moving_neg(Y_AXIS_HEAD);
+      #define Y_MOVE_TEST y_moving_pos || y_moving_neg
+      #define Y_NEG_DIR_TEST y_moving_neg
+    #else
+      #define Y_MOVE_TEST stepper.axis_is_moving(Y_AXIS)
+      #define Y_NEG_DIR_TEST !stepper.motor_direction(Y_AXIS_HEAD)
+    #endif
+    if (Y_MOVE_TEST) {
+      if (Y_NEG_DIR_TEST) { // -direction
         #if HAS_Y_MIN_STATE
           PROCESS_ENDSTOP_Y(MIN);
           #if   CORE_DIAG(XY, X, MIN)
             PROCESS_CORE_ENDSTOP(X,MIN,Y,MIN);
           #elif CORE_DIAG(XY, X, MAX)
             PROCESS_CORE_ENDSTOP(X,MAX,Y,MIN);
           #elif CORE_DIAG(YZ, Z, MIN)
             PROCESS_CORE_ENDSTOP(Z,MIN,Y,MIN);
           #elif CORE_DIAG(YZ, Z, MAX)
             PROCESS_CORE_ENDSTOP(Z,MAX,Y,MIN);
@@ -855,22 +878,31 @@ void Endstops::update() {
             PROCESS_CORE_ENDSTOP(Z,MIN,Y,MAX);
           #elif CORE_DIAG(YZ, Z, MAX)
             PROCESS_CORE_ENDSTOP(Z,MAX,Y,MAX);
           #endif
         #endif
       }
     }
   #endif // HAS_Y_AXIS
 
   #if HAS_Z_AXIS
-    if (stepper.axis_is_moving(Z_AXIS)) {
-      if (!stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
+    #if ENABLED(FT_MOTION)
+      const bool z_moving_pos = ftMotion.axis_moving_pos(Z_AXIS_HEAD),
+                 z_moving_neg = ftMotion.axis_moving_neg(Z_AXIS_HEAD);
+      #define Z_MOVE_TEST z_moving_pos || z_moving_neg
+      #define Z_NEG_DIR_TEST z_moving_neg
+    #else
+      #define Z_MOVE_TEST stepper.axis_is_moving(Z_AXIS)
+      #define Z_NEG_DIR_TEST !stepper.motor_direction(Z_AXIS_HEAD)
+    #endif
+    if (Z_MOVE_TEST) {
+      if (Z_NEG_DIR_TEST) { // Z -direction. Gantry down, bed up.
         #if HAS_Z_MIN_STATE
           // If the Z_MIN_PIN is being used for the probe there's no
           // separate Z_MIN endstop. But a Z endstop could be wired
           // in series, so someone might find this useful.
           if ( TERN1(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN, z_probe_enabled) // When Z_MIN is the probe, the probe must be enabled
             && TERN1(USE_Z_MIN_PROBE, !z_probe_enabled)                   // When Z_MIN isn't the probe, Z MIN is ignored while probing
           ) {
             PROCESS_ENDSTOP_Z(MIN);
             #if   CORE_DIAG(XZ, X, MIN)
               PROCESS_CORE_ENDSTOP(X,MIN,Z,MIN);
@@ -900,20 +932,21 @@ void Endstops::update() {
             PROCESS_CORE_ENDSTOP(Y,MIN,Z,MAX);
           #elif CORE_DIAG(YZ, Y, MAX)
             PROCESS_CORE_ENDSTOP(Y,MAX,Z,MAX);
           #endif
         #endif
       }
     }
   #endif // HAS_Z_AXIS
 
   #if HAS_I_AXIS
+  // TODO: FT_Motion logic.
     if (stepper.axis_is_moving(I_AXIS)) {
       if (!stepper.motor_direction(I_AXIS_HEAD)) { // -direction
         #if HAS_I_MIN_STATE
           PROCESS_ENDSTOP(I, MIN);
         #endif
       }
       else { // +direction
         #if HAS_I_MAX_STATE
           PROCESS_ENDSTOP(I, MAX);
         #endif

commit 49348716f538a16f7232efb0eed5d4e01d5a1494
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Mon May 6 19:58:00 2024 -0400

    ü©π Fix printf et.al. expecting F-strings (#27032)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 490d6bc2ce..09154b65a2 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -344,21 +344,21 @@ void Endstops::event_handler() {
 
     #if USE_Z_MIN_PROBE
       #define P_AXIS Z_AXIS
       if (TEST(hit_state, Z_MIN_PROBE)) _ENDSTOP_HIT_ECHO(P, 'P');
     #endif
     SERIAL_EOL();
 
     TERN_(HAS_STATUS_MESSAGE,
       ui.status_printf(0,
         F(S_FMT GANG_N_1(NUM_AXES, " %c") " %c"),
-        GET_TEXT(MSG_LCD_ENDSTOPS),
+        GET_TEXT_F(MSG_LCD_ENDSTOPS),
         NUM_AXIS_LIST_(chrX, chrY, chrZ, chrI, chrJ, chrK, chrU, chrV, chrW) chrP
       )
     );
 
     #if ENABLED(SD_ABORT_ON_ENDSTOP_HIT)
       if (planner.abort_on_endstop_hit) {
         card.abortFilePrintNow();
         quickstop_stepper();
         thermalManager.disable_all_heaters();
         #ifdef SD_ABORT_ON_ENDSTOP_HIT_GCODE

commit ce8535f01ca4b85ca1f7cae3908d3174ac11fff6
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jan 26 15:18:38 2024 -0600

    üßë‚Äçüíª Fix warning, adjust tests

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 9c6a3c011c..490d6bc2ce 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -781,21 +781,21 @@ void Endstops::update() {
   #else
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_DUAL_ENDSTOP(Z, MINMAX)
   #endif
 
   #if ENABLED(G38_PROBE_TARGET)
     // For G38 moves check the probe's pin for ALL movement
     if (G38_move && TEST_ENDSTOP(Z_MIN_PROBE) == TERN1(G38_PROBE_AWAY, (G38_move < 4))) {
       G38_did_trigger = true;
       #define _G38_SET(Q) | (stepper.axis_is_moving(_AXIS(Q)) << _AXIS(Q))
       #define _G38_RESP(Q) if (moving[_AXIS(Q)]) { _ENDSTOP_HIT(Q, ENDSTOP); planner.endstop_triggered(_AXIS(Q)); }
-      const Flags<NUM_AXES> moving = { value_t(NUM_AXES)(0 MAIN_AXIS_MAP(_G38_SET)) };
+      const Flags<NUM_AXES> moving = { uvalue_t(NUM_AXES)(0 MAIN_AXIS_MAP(_G38_SET)) };
       MAIN_AXIS_MAP(_G38_RESP);
     }
   #endif
 
   // Signal, after validation, if an endstop limit is pressed or not
 
   #if HAS_X_AXIS
     if (stepper.axis_is_moving(X_AXIS)) {
       if (!stepper.motor_direction(X_AXIS_HEAD)) { // -direction
         #if HAS_X_MIN_STATE

commit 1a42c38e0eefdf62976bf7a5a35224d3c675f9ff
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Sat Dec 2 22:03:46 2023 -0800

    ü©π Replace more DEBUG_ECHOF (#26495)
    
    Followup to #25928

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 0f060f5720..9c6a3c011c 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -1353,21 +1353,21 @@ void Endstops::update() {
       #endif
       #if HAS_CURRENT_HOME(Z3)
         static int16_t saved_current_Z3;
       #endif
       #if HAS_CURRENT_HOME(Z4)
         static int16_t saved_current_Z4;
       #endif
 
       #if ENABLED(DEBUG_LEVELING_FEATURE)
         auto debug_current = [](FSTR_P const s, const int16_t a, const int16_t b) {
-          if (DEBUGGING(LEVELING)) { DEBUG_ECHOF(s); DEBUG_ECHOLNPGM(" current: ", a, " -> ", b); }
+          if (DEBUGGING(LEVELING)) { DEBUG_ECHOLN(s, F(" current: "), a, F(" -> "), b); }
         };
       #else
         #define debug_current(...)
       #endif
 
       #define _SAVE_SET_CURRENT(A) \
         saved_current_##A = stepper##A.getMilliamps(); \
         stepper##A.rms_current(A##_CURRENT_HOME); \
         debug_current(F(STR_##A), saved_current_##A, A##_CURRENT_HOME)
 

commit bed26734a28175f7ef9669d5190bf7ebc6227223
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Aug 1 23:03:06 2023 -0500

    üîß More endstops refactoring (#25758)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 3c1fcc72a9..0f060f5720 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -131,21 +131,21 @@ void Endstops::init() {
   #endif
   #if USE_Y_MAX
     _INIT_ENDSTOP(MAX,Y,);
   #endif
   #if USE_Y2_MIN
     _INIT_ENDSTOP(MIN,Y,2);
   #endif
   #if USE_Y2_MAX
     _INIT_ENDSTOP(MAX,Y,2);
   #endif
-  #if HAS_Z_MIN_PIN
+  #if USE_Z_MIN
     _INIT_ENDSTOP(MIN,Z,);
   #endif
   #if USE_Z_MAX
     _INIT_ENDSTOP(MAX,Z,);
   #endif
   #if USE_Z2_MIN
     _INIT_ENDSTOP(MIN,Z,2);
   #endif
   #if USE_Z2_MAX
     _INIT_ENDSTOP(MAX,Z,2);
@@ -308,21 +308,21 @@ void Endstops::event_handler() {
            chrP = ' ';
       #define _SET_STOP_CHAR(A,C) (chr## A = C)
     #else
       #define _SET_STOP_CHAR(A,C) NOOP
     #endif
 
     #define _ENDSTOP_HIT_ECHO(A,C) do{ \
       SERIAL_ECHOPGM(" " STRINGIFY(A) ":", planner.triggered_position_mm(_AXIS(A))); _SET_STOP_CHAR(A,C); }while(0)
 
     #define _ENDSTOP_HIT_TEST(A,C) \
-      if (TERN0(USE_##A##_MIN, TEST(hit_state, ES_ENUM(A,MIN))) || TERN0(USE_##A##_MAX, TEST(hit_state, ES_ENUM(A,MAX)))) \
+      if (TERN0(HAS_##A##_MIN_STATE, TEST(hit_state, ES_ENUM(A,MIN))) || TERN0(HAS_##A##_MAX_STATE, TEST(hit_state, ES_ENUM(A,MAX)))) \
         _ENDSTOP_HIT_ECHO(A,C)
 
     #define ENDSTOP_HIT_TEST_X() _ENDSTOP_HIT_TEST(X,'X')
     #define ENDSTOP_HIT_TEST_Y() _ENDSTOP_HIT_TEST(Y,'Y')
     #define ENDSTOP_HIT_TEST_Z() _ENDSTOP_HIT_TEST(Z,'Z')
     #define ENDSTOP_HIT_TEST_I() _ENDSTOP_HIT_TEST(I,'I')
     #define ENDSTOP_HIT_TEST_J() _ENDSTOP_HIT_TEST(J,'J')
     #define ENDSTOP_HIT_TEST_K() _ENDSTOP_HIT_TEST(K,'K')
     #define ENDSTOP_HIT_TEST_U() _ENDSTOP_HIT_TEST(U,'U')
     #define ENDSTOP_HIT_TEST_V() _ENDSTOP_HIT_TEST(V,'V')
@@ -497,38 +497,35 @@ void __O2 Endstops::report_states() {
     #undef _CASE_RUNOUT
   #elif HAS_FILAMENT_SENSOR
     print_es_state(READ(FIL_RUNOUT1_PIN) != FIL_RUNOUT1_STATE, F(STR_FILAMENT));
   #endif
 
   TERN_(BLTOUCH, bltouch._reset_SW_mode());
   TERN_(JOYSTICK_DEBUG, joystick.report());
 
 } // Endstops::report_states
 
-#define __ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
-#define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN
-#define _ENDSTOP_HIT_STATE(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_HIT_STATE
-#define _ENDSTOP(AXIS, MINMAX) __ENDSTOP(AXIS, MINMAX)
-
 /**
  * Called from interrupt context by the Endstop ISR or Stepper ISR!
  * Read endstops to get their current states, register hits for all
  * axes moving in the direction of their endstops, and abort moves.
  */
 void Endstops::update() {
 
   #if !ENDSTOP_NOISE_THRESHOLD      // If not debouncing...
     if (!abort_enabled()) return;   // ...and not enabled, exit.
   #endif
 
   // Macros to update / copy the live_state
-  #define UPDATE_LIVE_STATE(AXIS, MINMAX) SET_BIT_TO(live_state, _ENDSTOP(AXIS, MINMAX), (READ_ENDSTOP(_ENDSTOP_PIN(AXIS, MINMAX)) == _ENDSTOP_HIT_STATE(AXIS, MINMAX)))
+  #define _ES_PIN(A,M) A##_##M##_PIN
+  #define _ES_HIT(A,M) A##_##M##_ENDSTOP_HIT_STATE
+  #define UPDATE_LIVE_STATE(AXIS, MINMAX) SET_BIT_TO(live_state, ES_ENUM(AXIS, MINMAX), (READ_ENDSTOP(_ES_PIN(AXIS, MINMAX)) == _ES_HIT(AXIS, MINMAX)))
   #define COPY_LIVE_STATE(SRC_BIT, DST_BIT) SET_BIT_TO(live_state, DST_BIT, TEST(live_state, SRC_BIT))
 
   #if ENABLED(G38_PROBE_TARGET)
     // For G38 moves check the probe's pin for ALL movement
     if (G38_move) UPDATE_LIVE_STATE(Z, TERN(USE_Z_MIN_PROBE, MIN_PROBE, MIN));
   #endif
 
   // With Dual X, endstops are only checked in the homing direction for the active extruder
   #define X_MIN_TEST() TERN1(DUAL_X_CARRIAGE, stepper.last_moved_extruder == 0) // Check min for the left carriage
   #define X_MAX_TEST() TERN1(DUAL_X_CARRIAGE, stepper.last_moved_extruder != 0) // Check max for the right carriage
@@ -553,218 +550,143 @@ void Endstops::update() {
   #define I_AXIS_HEAD I_AXIS
   #define J_AXIS_HEAD J_AXIS
   #define K_AXIS_HEAD K_AXIS
   #define U_AXIS_HEAD U_AXIS
   #define V_AXIS_HEAD V_AXIS
   #define W_AXIS_HEAD W_AXIS
 
   /**
    * Check and update endstops
    */
-  #if USE_X_MIN && !X_SPI_SENSORLESS
+  #if USE_X_MIN
     UPDATE_LIVE_STATE(X, MIN);
     #if ENABLED(X_DUAL_ENDSTOPS)
       #if USE_X2_MIN
         UPDATE_LIVE_STATE(X2, MIN);
       #else
         COPY_LIVE_STATE(X_MIN, X2_MIN);
       #endif
     #endif
   #endif
 
-  #if USE_X_MAX && !X_SPI_SENSORLESS
+  #if USE_X_MAX
     UPDATE_LIVE_STATE(X, MAX);
     #if ENABLED(X_DUAL_ENDSTOPS)
       #if USE_X2_MAX
         UPDATE_LIVE_STATE(X2, MAX);
       #else
         COPY_LIVE_STATE(X_MAX, X2_MAX);
       #endif
     #endif
   #endif
 
-  #if USE_Y_MIN && !Y_SPI_SENSORLESS
+  #if USE_Y_MIN
     UPDATE_LIVE_STATE(Y, MIN);
     #if ENABLED(Y_DUAL_ENDSTOPS)
       #if USE_Y2_MIN
         UPDATE_LIVE_STATE(Y2, MIN);
       #else
         COPY_LIVE_STATE(Y_MIN, Y2_MIN);
       #endif
     #endif
   #endif
 
-  #if USE_Y_MAX && !Y_SPI_SENSORLESS
+  #if USE_Y_MAX
     UPDATE_LIVE_STATE(Y, MAX);
     #if ENABLED(Y_DUAL_ENDSTOPS)
       #if USE_Y2_MAX
         UPDATE_LIVE_STATE(Y2, MAX);
       #else
         COPY_LIVE_STATE(Y_MAX, Y2_MAX);
       #endif
     #endif
   #endif
 
   #if USE_Z_MIN && NONE(Z_SPI_SENSORLESS, Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
-    #if HAS_Z_MIN_PIN
-      UPDATE_LIVE_STATE(Z, MIN);
-    #endif
-    #if ENABLED(Z_MULTI_ENDSTOPS)
-      #if USE_Z2_MIN
-        UPDATE_LIVE_STATE(Z2, MIN);
-      #else
-        COPY_LIVE_STATE(Z_MIN, Z2_MIN);
-      #endif
-      #if NUM_Z_STEPPERS >= 3
-        #if USE_Z3_MIN
-          UPDATE_LIVE_STATE(Z3, MIN);
-        #else
-          COPY_LIVE_STATE(Z_MIN, Z3_MIN);
-        #endif
-      #endif
-      #if NUM_Z_STEPPERS >= 4
-        #if USE_Z4_MIN
-          UPDATE_LIVE_STATE(Z4, MIN);
-        #else
-          COPY_LIVE_STATE(Z_MIN, Z4_MIN);
-        #endif
-      #endif
-    #endif
+    UPDATE_LIVE_STATE(Z, MIN);
+  #endif
+  #if USE_Z2_MIN
+    UPDATE_LIVE_STATE(Z2, MIN);
+  #elif HAS_Z2_MIN_STATE
+    COPY_LIVE_STATE(Z_MIN, Z2_MIN);
+  #endif
+  #if USE_Z3_MIN
+    UPDATE_LIVE_STATE(Z3, MIN);
+  #elif HAS_Z3_MIN_STATE
+    COPY_LIVE_STATE(Z_MIN, Z3_MIN);
+  #endif
+  #if USE_Z4_MIN
+    UPDATE_LIVE_STATE(Z4, MIN);
+  #elif HAS_Z4_MIN_STATE
+    COPY_LIVE_STATE(Z_MIN, Z4_MIN);
   #endif
 
-  #if HAS_BED_PROBE
+  #if HAS_REAL_BED_PROBE
     // When closing the gap check the enabled probe
     if (probe_switch_activated())
       UPDATE_LIVE_STATE(Z, TERN(USE_Z_MIN_PROBE, MIN_PROBE, MIN));
   #endif
 
-  #if USE_Z_MAX && !Z_SPI_SENSORLESS
-    // Check both Z dual endstops
-    #if ENABLED(Z_MULTI_ENDSTOPS)
-      UPDATE_LIVE_STATE(Z, MAX);
-      #if USE_Z2_MAX
-        UPDATE_LIVE_STATE(Z2, MAX);
-      #else
-        COPY_LIVE_STATE(Z_MAX, Z2_MAX);
-      #endif
-      #if NUM_Z_STEPPERS >= 3
-        #if USE_Z3_MAX
-          UPDATE_LIVE_STATE(Z3, MAX);
-        #else
-          COPY_LIVE_STATE(Z_MAX, Z3_MAX);
-        #endif
-      #endif
-      #if NUM_Z_STEPPERS >= 4
-        #if USE_Z4_MAX
-          UPDATE_LIVE_STATE(Z4, MAX);
-        #else
-          COPY_LIVE_STATE(Z_MAX, Z4_MAX);
-        #endif
-      #endif
-    #elif TERN1(USE_Z_MIN_PROBE, Z_MAX_PIN != Z_MIN_PROBE_PIN)
-      // If this pin isn't the bed probe it's the Z endstop
-      UPDATE_LIVE_STATE(Z, MAX);
-    #endif
+  #if USE_Z_MAX
+    UPDATE_LIVE_STATE(Z, MAX);
   #endif
-
-  #if USE_I_MIN && !I_SPI_SENSORLESS
-    #if ENABLED(I_DUAL_ENDSTOPS)
-      UPDATE_LIVE_STATE(I, MIN);
-    #else
-      UPDATE_LIVE_STATE(I, MIN);
-    #endif
+  #if USE_Z2_MAX
+    UPDATE_LIVE_STATE(Z2, MAX);
+  #elif HAS_Z2_MAX_STATE
+    COPY_LIVE_STATE(Z_MAX, Z2_MAX);
   #endif
-
-  #if USE_I_MAX && !I_SPI_SENSORLESS
-    #if ENABLED(I_DUAL_ENDSTOPS)
-      UPDATE_LIVE_STATE(I, MAX);
-    #else
-      UPDATE_LIVE_STATE(I, MAX);
-    #endif
+  #if USE_Z3_MAX
+    UPDATE_LIVE_STATE(Z3, MAX);
+  #elif HAS_Z3_MAX_STATE
+    COPY_LIVE_STATE(Z_MAX, Z3_MAX);
   #endif
-
-  #if USE_J_MIN && !J_SPI_SENSORLESS
-    #if ENABLED(J_DUAL_ENDSTOPS)
-      UPDATE_LIVE_STATE(J, MIN);
-    #else
-      UPDATE_LIVE_STATE(J, MIN);
-    #endif
+  #if USE_Z4_MAX
+    UPDATE_LIVE_STATE(Z4, MAX);
+  #elif HAS_Z4_MAX_STATE
+    COPY_LIVE_STATE(Z_MAX, Z4_MAX);
   #endif
 
-  #if USE_J_MAX && !J_SPI_SENSORLESS
-    #if ENABLED(J_DUAL_ENDSTOPS)
-      UPDATE_LIVE_STATE(J, MAX);
-    #else
-      UPDATE_LIVE_STATE(J, MAX);
-    #endif
+  #if USE_I_MIN
+    UPDATE_LIVE_STATE(I, MIN);
   #endif
-
-  #if USE_K_MIN && !K_SPI_SENSORLESS
-    #if ENABLED(K_DUAL_ENDSTOPS)
-      UPDATE_LIVE_STATE(K, MIN);
-    #else
-      UPDATE_LIVE_STATE(K, MIN);
-    #endif
+  #if USE_I_MAX
+    UPDATE_LIVE_STATE(I, MAX);
   #endif
-
-  #if USE_K_MAX && !K_SPI_SENSORLESS
-    #if ENABLED(K_DUAL_ENDSTOPS)
-      UPDATE_LIVE_STATE(K, MAX);
-    #else
-      UPDATE_LIVE_STATE(K, MAX);
-    #endif
+  #if USE_J_MIN
+    UPDATE_LIVE_STATE(J, MIN);
   #endif
-
-  #if USE_U_MIN && !U_SPI_SENSORLESS
-    #if ENABLED(U_DUAL_ENDSTOPS)
-      UPDATE_LIVE_STATE(U, MIN);
-    #else
-      UPDATE_LIVE_STATE(U, MIN);
-    #endif
+  #if USE_J_MAX
+    UPDATE_LIVE_STATE(J, MAX);
   #endif
-
-  #if USE_U_MAX && !U_SPI_SENSORLESS
-    #if ENABLED(U_DUAL_ENDSTOPS)
-      UPDATE_LIVE_STATE(U, MAX);
-    #else
-      UPDATE_LIVE_STATE(U, MAX);
-    #endif
+  #if USE_K_MIN
+    UPDATE_LIVE_STATE(K, MIN);
   #endif
-
-  #if USE_V_MIN && !V_SPI_SENSORLESS
-    #if ENABLED(V_DUAL_ENDSTOPS)
-      UPDATE_LIVE_STATE(V, MIN);
-    #else
-      UPDATE_LIVE_STATE(V, MIN);
-    #endif
+  #if USE_K_MAX
+    UPDATE_LIVE_STATE(K, MAX);
   #endif
-  #if USE_V_MAX && !V_SPI_SENSORLESS
-    #if ENABLED(O_DUAL_ENDSTOPS)
-      UPDATE_LIVE_STATE(V, MAX);
-    #else
-      UPDATE_LIVE_STATE(V, MAX);
-    #endif
+  #if USE_U_MIN
+    UPDATE_LIVE_STATE(U, MIN);
   #endif
-
-  #if USE_W_MIN && !W_SPI_SENSORLESS
-    #if ENABLED(W_DUAL_ENDSTOPS)
-      UPDATE_LIVE_STATE(W, MIN);
-    #else
-      UPDATE_LIVE_STATE(W, MIN);
-    #endif
+  #if USE_U_MAX
+    UPDATE_LIVE_STATE(U, MAX);
   #endif
-  #if USE_W_MAX && !W_SPI_SENSORLESS
-    #if ENABLED(W_DUAL_ENDSTOPS)
-      UPDATE_LIVE_STATE(W, MAX);
-    #else
-      UPDATE_LIVE_STATE(W, MAX);
-    #endif
+  #if USE_V_MIN
+    UPDATE_LIVE_STATE(V, MIN);
+  #endif
+  #if USE_V_MAX
+    UPDATE_LIVE_STATE(V, MAX);
+  #endif
+  #if USE_W_MIN
+    UPDATE_LIVE_STATE(W, MIN);
+  #endif
+  #if USE_W_MAX
+    UPDATE_LIVE_STATE(W, MAX);
   #endif
 
   #if ENDSTOP_NOISE_THRESHOLD
 
     /**
      * Filtering out noise on endstops requires a delayed decision. Let's assume, due to noise,
      * that 50% of endstop signal samples are good and 50% are bad (assuming normal distribution
      * of random noise). Then the first sample has a 50% chance to be good or bad. The 2nd sample
      * also has a 50% chance to be good or bad. The chances of 2 samples both being bad becomes
      * 50% of 50%, or 25%. That was the previous implementation of Marlin endstop handling. It
@@ -781,62 +703,62 @@ void Endstops::update() {
       validated_live_state = live_state;
 
     if (!abort_enabled()) return;
 
   #endif
 
   // Test the current status of an endstop
   #define TEST_ENDSTOP(ENDSTOP) (TEST(state(), ENDSTOP))
 
   // Record endstop was hit
-  #define _ENDSTOP_HIT(AXIS, MINMAX) SBI(hit_state, _ENDSTOP(AXIS, MINMAX))
+  #define _ENDSTOP_HIT(AXIS, MINMAX) SBI(hit_state, ES_ENUM(AXIS, MINMAX))
 
   // Call the endstop triggered routine for single endstops
   #define PROCESS_ENDSTOP(AXIS, MINMAX) do { \
-    if (TEST_ENDSTOP(_ENDSTOP(AXIS, MINMAX))) { \
+    if (TEST_ENDSTOP(ES_ENUM(AXIS, MINMAX))) { \
       _ENDSTOP_HIT(AXIS, MINMAX); \
       planner.endstop_triggered(_AXIS(AXIS)); \
     } \
   }while(0)
 
   // Core Sensorless Homing needs to test an Extra Pin
   #define CORE_DIAG(QQ,A,MM) (CORE_IS_##QQ && A##_SENSORLESS && !A##_SPI_SENSORLESS && USE_##A##_##MM)
   #define PROCESS_CORE_ENDSTOP(A1,M1,A2,M2) do { \
-    if (TEST_ENDSTOP(_ENDSTOP(A1,M1))) { \
+    if (TEST_ENDSTOP(ES_ENUM(A1,M1))) { \
       _ENDSTOP_HIT(A2,M2); \
       planner.endstop_triggered(_AXIS(A2)); \
     } \
   }while(0)
 
   // Call the endstop triggered routine for dual endstops
   #define PROCESS_DUAL_ENDSTOP(A, MINMAX) do { \
-    const byte dual_hit = TEST_ENDSTOP(_ENDSTOP(A, MINMAX)) | (TEST_ENDSTOP(_ENDSTOP(A##2, MINMAX)) << 1); \
+    const byte dual_hit = TEST_ENDSTOP(ES_ENUM(A, MINMAX)) | (TEST_ENDSTOP(ES_ENUM(A##2, MINMAX)) << 1); \
     if (dual_hit) { \
       _ENDSTOP_HIT(A, MINMAX); \
       /* if not performing home or if both endstops were triggered during homing... */ \
       if (!stepper.separate_multi_axis || dual_hit == 0b11) \
         planner.endstop_triggered(_AXIS(A)); \
     } \
   }while(0)
 
   #define PROCESS_TRIPLE_ENDSTOP(A, MINMAX) do { \
-    const byte triple_hit = TEST_ENDSTOP(_ENDSTOP(A, MINMAX)) | (TEST_ENDSTOP(_ENDSTOP(A##2, MINMAX)) << 1) | (TEST_ENDSTOP(_ENDSTOP(A##3, MINMAX)) << 2); \
+    const byte triple_hit = TEST_ENDSTOP(ES_ENUM(A, MINMAX)) | (TEST_ENDSTOP(ES_ENUM(A##2, MINMAX)) << 1) | (TEST_ENDSTOP(ES_ENUM(A##3, MINMAX)) << 2); \
     if (triple_hit) { \
       _ENDSTOP_HIT(A, MINMAX); \
       /* if not performing home or if both endstops were triggered during homing... */ \
       if (!stepper.separate_multi_axis || triple_hit == 0b111) \
         planner.endstop_triggered(_AXIS(A)); \
     } \
   }while(0)
 
   #define PROCESS_QUAD_ENDSTOP(A, MINMAX) do { \
-    const byte quad_hit = TEST_ENDSTOP(_ENDSTOP(A, MINMAX)) | (TEST_ENDSTOP(_ENDSTOP(A##2, MINMAX)) << 1) | (TEST_ENDSTOP(_ENDSTOP(A##3, MINMAX)) << 2) | (TEST_ENDSTOP(_ENDSTOP(A##4, MINMAX)) << 3); \
+    const byte quad_hit = TEST_ENDSTOP(ES_ENUM(A, MINMAX)) | (TEST_ENDSTOP(ES_ENUM(A##2, MINMAX)) << 1) | (TEST_ENDSTOP(ES_ENUM(A##3, MINMAX)) << 2) | (TEST_ENDSTOP(ES_ENUM(A##4, MINMAX)) << 3); \
     if (quad_hit) { \
       _ENDSTOP_HIT(A, MINMAX); \
       /* if not performing home or if both endstops were triggered during homing... */ \
       if (!stepper.separate_multi_axis || quad_hit == 0b1111) \
         planner.endstop_triggered(_AXIS(A)); \
     } \
   }while(0)
 
   #if ENABLED(X_DUAL_ENDSTOPS)
     #define PROCESS_ENDSTOP_X(MINMAX) PROCESS_DUAL_ENDSTOP(X, MINMAX)
@@ -869,257 +791,286 @@ void Endstops::update() {
       const Flags<NUM_AXES> moving = { value_t(NUM_AXES)(0 MAIN_AXIS_MAP(_G38_SET)) };
       MAIN_AXIS_MAP(_G38_RESP);
     }
   #endif
 
   // Signal, after validation, if an endstop limit is pressed or not
 
   #if HAS_X_AXIS
     if (stepper.axis_is_moving(X_AXIS)) {
       if (!stepper.motor_direction(X_AXIS_HEAD)) { // -direction
-        #if USE_X_MIN || (X_SPI_SENSORLESS && X_HOME_TO_MIN)
+        #if HAS_X_MIN_STATE
           PROCESS_ENDSTOP_X(MIN);
           #if   CORE_DIAG(XY, Y, MIN)
             PROCESS_CORE_ENDSTOP(Y,MIN,X,MIN);
           #elif CORE_DIAG(XY, Y, MAX)
             PROCESS_CORE_ENDSTOP(Y,MAX,X,MIN);
           #elif CORE_DIAG(XZ, Z, MIN)
             PROCESS_CORE_ENDSTOP(Z,MIN,X,MIN);
           #elif CORE_DIAG(XZ, Z, MAX)
             PROCESS_CORE_ENDSTOP(Z,MAX,X,MIN);
           #endif
         #endif
       }
       else { // +direction
-        #if USE_X_MAX || (X_SPI_SENSORLESS && X_HOME_TO_MAX)
+        #if HAS_X_MAX_STATE
           PROCESS_ENDSTOP_X(MAX);
           #if   CORE_DIAG(XY, Y, MIN)
             PROCESS_CORE_ENDSTOP(Y,MIN,X,MAX);
           #elif CORE_DIAG(XY, Y, MAX)
             PROCESS_CORE_ENDSTOP(Y,MAX,X,MAX);
           #elif CORE_DIAG(XZ, Z, MIN)
             PROCESS_CORE_ENDSTOP(Z,MIN,X,MAX);
           #elif CORE_DIAG(XZ, Z, MAX)
             PROCESS_CORE_ENDSTOP(Z,MAX,X,MAX);
           #endif
         #endif
       }
     }
   #endif // HAS_X_AXIS
 
   #if HAS_Y_AXIS
     if (stepper.axis_is_moving(Y_AXIS)) {
       if (!stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
-        #if USE_Y_MIN || (Y_SPI_SENSORLESS && Y_HOME_TO_MIN)
+        #if HAS_Y_MIN_STATE
           PROCESS_ENDSTOP_Y(MIN);
           #if   CORE_DIAG(XY, X, MIN)
             PROCESS_CORE_ENDSTOP(X,MIN,Y,MIN);
           #elif CORE_DIAG(XY, X, MAX)
             PROCESS_CORE_ENDSTOP(X,MAX,Y,MIN);
           #elif CORE_DIAG(YZ, Z, MIN)
             PROCESS_CORE_ENDSTOP(Z,MIN,Y,MIN);
           #elif CORE_DIAG(YZ, Z, MAX)
             PROCESS_CORE_ENDSTOP(Z,MAX,Y,MIN);
           #endif
         #endif
       }
       else { // +direction
-        #if USE_Y_MAX || (Y_SPI_SENSORLESS && Y_HOME_TO_MAX)
+        #if HAS_Y_MAX_STATE
           PROCESS_ENDSTOP_Y(MAX);
           #if   CORE_DIAG(XY, X, MIN)
             PROCESS_CORE_ENDSTOP(X,MIN,Y,MAX);
           #elif CORE_DIAG(XY, X, MAX)
             PROCESS_CORE_ENDSTOP(X,MAX,Y,MAX);
           #elif CORE_DIAG(YZ, Z, MIN)
             PROCESS_CORE_ENDSTOP(Z,MIN,Y,MAX);
           #elif CORE_DIAG(YZ, Z, MAX)
             PROCESS_CORE_ENDSTOP(Z,MAX,Y,MAX);
           #endif
         #endif
       }
     }
   #endif // HAS_Y_AXIS
 
   #if HAS_Z_AXIS
     if (stepper.axis_is_moving(Z_AXIS)) {
       if (!stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
-
-        #if USE_Z_MIN || (Z_SPI_SENSORLESS && Z_HOME_TO_MIN)
-          if ( TERN1(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN, z_probe_enabled)
-            && TERN1(USE_Z_MIN_PROBE, !z_probe_enabled)
-          ) PROCESS_ENDSTOP_Z(MIN);
-          #if   CORE_DIAG(XZ, X, MIN)
-            PROCESS_CORE_ENDSTOP(X,MIN,Z,MIN);
-          #elif CORE_DIAG(XZ, X, MAX)
-            PROCESS_CORE_ENDSTOP(X,MAX,Z,MIN);
-          #elif CORE_DIAG(YZ, Y, MIN)
-            PROCESS_CORE_ENDSTOP(Y,MIN,Z,MIN);
-          #elif CORE_DIAG(YZ, Y, MAX)
-            PROCESS_CORE_ENDSTOP(Y,MAX,Z,MIN);
-          #endif
+        #if HAS_Z_MIN_STATE
+          // If the Z_MIN_PIN is being used for the probe there's no
+          // separate Z_MIN endstop. But a Z endstop could be wired
+          // in series, so someone might find this useful.
+          if ( TERN1(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN, z_probe_enabled) // When Z_MIN is the probe, the probe must be enabled
+            && TERN1(USE_Z_MIN_PROBE, !z_probe_enabled)                   // When Z_MIN isn't the probe, Z MIN is ignored while probing
+          ) {
+            PROCESS_ENDSTOP_Z(MIN);
+            #if   CORE_DIAG(XZ, X, MIN)
+              PROCESS_CORE_ENDSTOP(X,MIN,Z,MIN);
+            #elif CORE_DIAG(XZ, X, MAX)
+              PROCESS_CORE_ENDSTOP(X,MAX,Z,MIN);
+            #elif CORE_DIAG(YZ, Y, MIN)
+              PROCESS_CORE_ENDSTOP(Y,MIN,Z,MIN);
+            #elif CORE_DIAG(YZ, Y, MAX)
+              PROCESS_CORE_ENDSTOP(Y,MAX,Z,MIN);
+            #endif
+          }
         #endif
 
-        // When closing the gap check the enabled probe
+        // When closing the gap use the probe trigger state
         #if USE_Z_MIN_PROBE
           if (z_probe_enabled) PROCESS_ENDSTOP(Z, MIN_PROBE);
         #endif
       }
       else { // Z +direction. Gantry up, bed down.
-        #if USE_Z_MAX || (Z_SPI_SENSORLESS && Z_HOME_TO_MAX)
-          #if ENABLED(Z_MULTI_ENDSTOPS)
-            PROCESS_ENDSTOP_Z(MAX);
-          #elif TERN1(USE_Z_MIN_PROBE, Z_MAX_PIN != Z_MIN_PROBE_PIN)  // No probe or probe is Z_MIN || Probe is not Z_MAX
-            PROCESS_ENDSTOP(Z, MAX);
-          #endif
+        #if HAS_Z_MAX_STATE
+          PROCESS_ENDSTOP_Z(MAX);
           #if   CORE_DIAG(XZ, X, MIN)
             PROCESS_CORE_ENDSTOP(X,MIN,Z,MAX);
           #elif CORE_DIAG(XZ, X, MAX)
             PROCESS_CORE_ENDSTOP(X,MAX,Z,MAX);
           #elif CORE_DIAG(YZ, Y, MIN)
             PROCESS_CORE_ENDSTOP(Y,MIN,Z,MAX);
           #elif CORE_DIAG(YZ, Y, MAX)
             PROCESS_CORE_ENDSTOP(Y,MAX,Z,MAX);
           #endif
         #endif
       }
     }
   #endif // HAS_Z_AXIS
 
   #if HAS_I_AXIS
     if (stepper.axis_is_moving(I_AXIS)) {
       if (!stepper.motor_direction(I_AXIS_HEAD)) { // -direction
-        #if USE_I_MIN || (I_SPI_SENSORLESS && I_HOME_TO_MIN)
+        #if HAS_I_MIN_STATE
           PROCESS_ENDSTOP(I, MIN);
         #endif
       }
       else { // +direction
-        #if USE_I_MAX || (I_SPI_SENSORLESS && I_HOME_TO_MAX)
+        #if HAS_I_MAX_STATE
           PROCESS_ENDSTOP(I, MAX);
         #endif
       }
     }
   #endif // HAS_I_AXIS
 
   #if HAS_J_AXIS
     if (stepper.axis_is_moving(J_AXIS)) {
       if (!stepper.motor_direction(J_AXIS_HEAD)) { // -direction
-        #if USE_J_MIN || (J_SPI_SENSORLESS && J_HOME_TO_MIN)
+        #if HAS_J_MIN_STATE
           PROCESS_ENDSTOP(J, MIN);
         #endif
       }
       else { // +direction
-        #if USE_J_MAX || (J_SPI_SENSORLESS && J_HOME_TO_MAX)
+        #if HAS_J_MAX_STATE
           PROCESS_ENDSTOP(J, MAX);
         #endif
       }
     }
   #endif // HAS_J_AXIS
 
   #if HAS_K_AXIS
     if (stepper.axis_is_moving(K_AXIS)) {
       if (!stepper.motor_direction(K_AXIS_HEAD)) { // -direction
-        #if USE_K_MIN || (K_SPI_SENSORLESS && K_HOME_TO_MIN)
+        #if HAS_K_MIN_STATE
           PROCESS_ENDSTOP(K, MIN);
         #endif
       }
       else { // +direction
-        #if USE_K_MAX || (K_SPI_SENSORLESS && K_HOME_TO_MAX)
+        #if HAS_K_MAX_STATE
           PROCESS_ENDSTOP(K, MAX);
         #endif
       }
     }
   #endif // HAS_K_AXIS
 
   #if HAS_U_AXIS
     if (stepper.axis_is_moving(U_AXIS)) {
       if (!stepper.motor_direction(U_AXIS_HEAD)) { // -direction
-        #if USE_U_MIN || (U_SPI_SENSORLESS && U_HOME_TO_MIN)
+        #if HAS_U_MIN_STATE
           PROCESS_ENDSTOP(U, MIN);
         #endif
       }
       else { // +direction
-        #if USE_U_MAX || (U_SPI_SENSORLESS && U_HOME_TO_MAX)
+        #if HAS_U_MAX_STATE
           PROCESS_ENDSTOP(U, MAX);
         #endif
       }
     }
   #endif // HAS_U_AXIS
 
   #if HAS_V_AXIS
     if (stepper.axis_is_moving(V_AXIS)) {
       if (!stepper.motor_direction(V_AXIS_HEAD)) { // -direction
-        #if USE_V_MIN || (V_SPI_SENSORLESS && V_HOME_TO_MIN)
+        #if HAS_V_MIN_STATE
           PROCESS_ENDSTOP(V, MIN);
         #endif
       }
       else { // +direction
-        #if USE_V_MAX || (V_SPI_SENSORLESS && V_HOME_TO_MAX)
+        #if HAS_V_MAX_STATE
           PROCESS_ENDSTOP(V, MAX);
         #endif
       }
     }
   #endif // HAS_V_AXIS
 
   #if HAS_W_AXIS
     if (stepper.axis_is_moving(W_AXIS)) {
       if (!stepper.motor_direction(W_AXIS_HEAD)) { // -direction
-        #if USE_W_MIN || (W_SPI_SENSORLESS && W_HOME_TO_MIN)
+        #if HAS_W_MIN_STATE
           PROCESS_ENDSTOP(W, MIN);
         #endif
       }
       else { // +direction
-        #if USE_W_MAX || (W_SPI_SENSORLESS && W_HOME_TO_MAX)
+        #if HAS_W_MAX_STATE
           PROCESS_ENDSTOP(W, MAX);
         #endif
       }
     }
   #endif // HAS_W_AXIS
+
 } // Endstops::update()
 
 #if ENABLED(SPI_ENDSTOPS)
 
   // Called from idle() to read Trinamic stall states
   bool Endstops::tmc_spi_homing_check() {
     bool hit = false;
+
     #if X_SPI_SENSORLESS
-      if (tmc_spi_homing.x && (stepperX.test_stall_status()
-        #if Y_SPI_SENSORLESS && ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
-          || stepperY.test_stall_status()
-        #elif Z_SPI_SENSORLESS && CORE_IS_XZ
-          || stepperZ.test_stall_status()
+      if (tmc_spi_homing.x) {
+        #if ENABLED(DUAL_X_CARRIAGE)
+          const bool ismin = X_MIN_TEST();
         #endif
-      )) { SBI(live_state, X_ENDSTOP); hit = true; }
-      #if ENABLED(X_DUAL_ENDSTOPS)
-        if (tmc_spi_homing.x && stepperX2.test_stall_status()) { SBI(live_state, X2_ENDSTOP); hit = true; }
-      #endif
+        const bool xhit = (
+          #if ENABLED(DUAL_X_CARRIAGE)
+            ismin ? stepperX.test_stall_status() : stepperX2.test_stall_status()
+          #else
+            stepperX.test_stall_status()
+            #if Y_SPI_SENSORLESS && ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
+              || stepperY.test_stall_status()
+            #elif Z_SPI_SENSORLESS && CORE_IS_XZ
+              || stepperZ.test_stall_status()
+            #endif
+          #endif
+        );
+        if (xhit) { SBI(live_state, TERN(DUAL_X_CARRIAGE, ismin ? X_MIN : X_MAX, X_ENDSTOP)); hit = true; }
+        #if ENABLED(X_DUAL_ENDSTOPS)
+          if (stepperX2.test_stall_status()) { SBI(live_state, X2_ENDSTOP); hit = true; }
+        #endif
+      }
     #endif
+
     #if Y_SPI_SENSORLESS
-      if (tmc_spi_homing.y && (stepperY.test_stall_status()
-        #if X_SPI_SENSORLESS && ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
-          || stepperX.test_stall_status()
-        #elif Z_SPI_SENSORLESS && CORE_IS_YZ
-          || stepperZ.test_stall_status()
+      if (tmc_spi_homing.y) {
+        if (stepperY.test_stall_status()
+          #if X_SPI_SENSORLESS && ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
+            || stepperX.test_stall_status()
+          #elif Z_SPI_SENSORLESS && CORE_IS_YZ
+            || stepperZ.test_stall_status()
+          #endif
+        ) { SBI(live_state, Y_ENDSTOP); hit = true; }
+        #if ENABLED(Y_DUAL_ENDSTOPS)
+          if (stepperY2.test_stall_status()) { SBI(live_state, Y2_ENDSTOP); hit = true; }
         #endif
-      )) { SBI(live_state, Y_ENDSTOP); hit = true; }
-      #if ENABLED(Y_DUAL_ENDSTOPS)
-        if (tmc_spi_homing.y && stepperY2.test_stall_status()) { SBI(live_state, Y2_ENDSTOP); hit = true; }
-      #endif
+      }
     #endif
+
     #if Z_SPI_SENSORLESS
-      if (tmc_spi_homing.z && (stepperZ.test_stall_status()
-        #if X_SPI_SENSORLESS && CORE_IS_XZ
-          || stepperX.test_stall_status()
-        #elif Y_SPI_SENSORLESS && CORE_IS_YZ
-          || stepperY.test_stall_status()
+      if (tmc_spi_homing.z) {
+        if (stepperZ.test_stall_status()
+          #if X_SPI_SENSORLESS && CORE_IS_XZ
+            || stepperX.test_stall_status()
+          #elif Y_SPI_SENSORLESS && CORE_IS_YZ
+            || stepperY.test_stall_status()
+          #endif
+        ) { SBI(live_state, Z_ENDSTOP); hit = true; }
+        #if ENABLED(Z_MULTI_ENDSTOPS)
+          if (stepperZ2.test_stall_status()) { SBI(live_state, Z2_ENDSTOP); hit = true; }
+          #if NUM_Z_STEPPERS >= 3
+            if (stepperZ3.test_stall_status()) { SBI(live_state, Z3_ENDSTOP); hit = true; }
+            #if NUM_Z_STEPPERS >= 4
+              if (stepperZ4.test_stall_status()) { SBI(live_state, Z4_ENDSTOP); hit = true; }
+            #endif
+          #endif
         #endif
-      )) { SBI(live_state, Z_ENDSTOP); hit = true; }
+      }
     #endif
+
     #if I_SPI_SENSORLESS
       if (tmc_spi_homing.i && stepperI.test_stall_status()) { SBI(live_state, I_ENDSTOP); hit = true; }
     #endif
     #if J_SPI_SENSORLESS
       if (tmc_spi_homing.j && stepperJ.test_stall_status()) { SBI(live_state, J_ENDSTOP); hit = true; }
     #endif
     #if K_SPI_SENSORLESS
       if (tmc_spi_homing.k && stepperK.test_stall_status()) { SBI(live_state, K_ENDSTOP); hit = true; }
     #endif
     #if U_SPI_SENSORLESS
@@ -1140,20 +1091,29 @@ void Endstops::update() {
   void Endstops::clear_endstop_state() {
     TERN_(X_SPI_SENSORLESS, CBI(live_state, X_ENDSTOP));
     #if ALL(X_SPI_SENSORLESS, X_DUAL_ENDSTOPS)
       CBI(live_state, X2_ENDSTOP);
     #endif
     TERN_(Y_SPI_SENSORLESS, CBI(live_state, Y_ENDSTOP));
     #if ALL(Y_SPI_SENSORLESS, Y_DUAL_ENDSTOPS)
       CBI(live_state, Y2_ENDSTOP);
     #endif
     TERN_(Z_SPI_SENSORLESS, CBI(live_state, Z_ENDSTOP));
+    #if ALL(Z_SPI_SENSORLESS, Z_MULTI_ENDSTOPS)
+      CBI(live_state, Z2_ENDSTOP);
+      #if NUM_Z_STEPPERS >= 3
+        CBI(live_state, Z3_ENDSTOP);
+        #if NUM_Z_STEPPERS >= 4
+          CBI(live_state, Z4_ENDSTOP);
+        #endif
+      #endif
+    #endif
     TERN_(I_SPI_SENSORLESS, CBI(live_state, I_ENDSTOP));
     TERN_(J_SPI_SENSORLESS, CBI(live_state, J_ENDSTOP));
     TERN_(K_SPI_SENSORLESS, CBI(live_state, K_ENDSTOP));
     TERN_(U_SPI_SENSORLESS, CBI(live_state, U_ENDSTOP));
     TERN_(V_SPI_SENSORLESS, CBI(live_state, V_ENDSTOP));
     TERN_(W_SPI_SENSORLESS, CBI(live_state, W_ENDSTOP));
   }
 
 #endif // SPI_ENDSTOPS
 
@@ -1183,21 +1143,21 @@ void Endstops::update() {
     #endif
     #if USE_X_MAX
       ES_GET_STATE(X_MAX);
     #endif
     #if USE_Y_MIN
       ES_GET_STATE(Y_MIN);
     #endif
     #if USE_Y_MAX
       ES_GET_STATE(Y_MAX);
     #endif
-    #if HAS_Z_MIN_PIN
+    #if USE_Z_MIN
       ES_GET_STATE(Z_MIN);
     #endif
     #if USE_Z_MAX
       ES_GET_STATE(Z_MAX);
     #endif
     #if USE_Z_MIN_PROBE
       ES_GET_STATE(Z_MIN_PROBE);
     #endif
     #if USE_X2_MIN
       ES_GET_STATE(X2_MIN);
@@ -1259,21 +1219,21 @@ void Endstops::update() {
     #if USE_V_MIN
       ES_GET_STATE(V_MIN);
     #endif
     #if USE_W_MAX
       ES_GET_STATE(W_MAX);
     #endif
     #if USE_W_MIN
       ES_GET_STATE(W_MIN);
     #endif
 
-    uint16_t endstop_change = live_state_local ^ old_live_state_local;
+    const uint16_t endstop_change = live_state_local ^ old_live_state_local;
     #define ES_REPORT_CHANGE(S) if (TEST(endstop_change, S)) SERIAL_ECHOPGM("  " STRINGIFY(S) ":", TEST(live_state_local, S))
 
     if (endstop_change) {
       #if USE_X_MIN
         ES_REPORT_CHANGE(X_MIN);
       #endif
       #if USE_X_MAX
         ES_REPORT_CHANGE(X_MAX);
       #endif
       #if USE_Y_MIN
@@ -1364,66 +1324,94 @@ void Endstops::update() {
       old_live_state_local = live_state_local;
     }
   }
 
 #endif // PINS_DEBUGGING
 
 #if USE_SENSORLESS
   /**
    * Change TMC driver currents to N##_CURRENT_HOME, saving the current configuration of each.
    */
-  void Endstops::set_homing_current(const bool onoff) {
-    #define HAS_CURRENT_HOME(N) (defined(N##_CURRENT_HOME) && N##_CURRENT_HOME != N##_CURRENT)
-    #define HAS_DELTA_X_CURRENT (ENABLED(DELTA) && HAS_CURRENT_HOME(X))
-    #define HAS_DELTA_Y_CURRENT (ENABLED(DELTA) && HAS_CURRENT_HOME(Y))
-    #if HAS_DELTA_X_CURRENT || HAS_DELTA_Y_CURRENT || HAS_CURRENT_HOME(Z)
+  void Endstops::set_z_sensorless_current(const bool onoff) {
+    #if ENABLED(DELTA) && HAS_CURRENT_HOME(X)
+      #define HAS_DELTA_X_CURRENT 1
+    #endif
+    #if ENABLED(DELTA) && HAS_CURRENT_HOME(Y)
+      #define HAS_DELTA_Y_CURRENT 1
+    #endif
+    #if HAS_DELTA_X_CURRENT || HAS_DELTA_Y_CURRENT || HAS_CURRENT_HOME(Z) || HAS_CURRENT_HOME(Z2) || HAS_CURRENT_HOME(Z3) || HAS_CURRENT_HOME(Z4)
       #if HAS_DELTA_X_CURRENT
-        static int16_t saved_current_x;
+        static int16_t saved_current_X;
       #endif
       #if HAS_DELTA_Y_CURRENT
-        static int16_t saved_current_y;
+        static int16_t saved_current_Y;
       #endif
       #if HAS_CURRENT_HOME(Z)
-        static int16_t saved_current_z;
+        static int16_t saved_current_Z;
       #endif
-      auto debug_current_on = [](PGM_P const s, const int16_t a, const int16_t b) {
-        if (DEBUGGING(LEVELING)) { DEBUG_ECHOPGM_P(s); DEBUG_ECHOLNPGM(" current: ", a, " -> ", b); }
-      };
+      #if HAS_CURRENT_HOME(Z2)
+        static int16_t saved_current_Z2;
+      #endif
+      #if HAS_CURRENT_HOME(Z3)
+        static int16_t saved_current_Z3;
+      #endif
+      #if HAS_CURRENT_HOME(Z4)
+        static int16_t saved_current_Z4;
+      #endif
+
+      #if ENABLED(DEBUG_LEVELING_FEATURE)
+        auto debug_current = [](FSTR_P const s, const int16_t a, const int16_t b) {
+          if (DEBUGGING(LEVELING)) { DEBUG_ECHOF(s); DEBUG_ECHOLNPGM(" current: ", a, " -> ", b); }
+        };
+      #else
+        #define debug_current(...)
+      #endif
+
+      #define _SAVE_SET_CURRENT(A) \
+        saved_current_##A = stepper##A.getMilliamps(); \
+        stepper##A.rms_current(A##_CURRENT_HOME); \
+        debug_current(F(STR_##A), saved_current_##A, A##_CURRENT_HOME)
+
+      #define _RESTORE_CURRENT(A) \
+        stepper##A.rms_current(saved_current_##A); \
+        debug_current(F(STR_##A), saved_current_##A, A##_CURRENT_HOME)
+
       if (onoff) {
-        #if HAS_DELTA_X_CURRENT
-          saved_current_x = stepperX.getMilliamps();
-          stepperX.rms_current(X_CURRENT_HOME);
-          debug_current_on(PSTR("X"), saved_current_x, X_CURRENT_HOME);
+        TERN_(HAS_DELTA_X_CURRENT, _SAVE_SET_CURRENT(X));
+        TERN_(HAS_DELTA_Y_CURRENT, _SAVE_SET_CURRENT(Y));
+        #if HAS_CURRENT_HOME(Z)
+          _SAVE_SET_CURRENT(Z);
         #endif
-        #if HAS_DELTA_Y_CURRENT
-          saved_current_y = stepperY.getMilliamps();
-          stepperY.rms_current(Y_CURRENT_HOME);
-          debug_current_on(PSTR("Y"), saved_current_y, Y_CURRENT_HOME);
+        #if HAS_CURRENT_HOME(Z2)
+          _SAVE_SET_CURRENT(Z2);
         #endif
-        #if HAS_CURRENT_HOME(Z)
-          saved_current_z = stepperZ.getMilliamps();
-          stepperZ.rms_current(Z_CURRENT_HOME);
-          debug_current_on(PSTR("Z"), saved_current_z, Z_CURRENT_HOME);
+        #if HAS_CURRENT_HOME(Z3)
+          _SAVE_SET_CURRENT(Z3);
+        #endif
+        #if HAS_CURRENT_HOME(Z4)
+          _SAVE_SET_CURRENT(Z4);
         #endif
       }
       else {
-        #if HAS_DELTA_X_CURRENT
-          stepperX.rms_current(saved_current_x);
-          debug_current_on(PSTR("X"), X_CURRENT_HOME, saved_current_x);
+        TERN_(HAS_DELTA_X_CURRENT, _RESTORE_CURRENT(X));
+        TERN_(HAS_DELTA_Y_CURRENT, _RESTORE_CURRENT(Y));
+        #if HAS_CURRENT_HOME(Z)
+          _RESTORE_CURRENT(Z);
         #endif
-        #if HAS_DELTA_Y_CURRENT
-          stepperY.rms_current(saved_current_y);
-          debug_current_on(PSTR("Y"), Y_CURRENT_HOME, saved_current_y);
+        #if HAS_CURRENT_HOME(Z2)
+          _RESTORE_CURRENT(Z2);
         #endif
-        #if HAS_CURRENT_HOME(Z)
-          stepperZ.rms_current(saved_current_z);
-          debug_current_on(PSTR("Z"), Z_CURRENT_HOME, saved_current_z);
+        #if HAS_CURRENT_HOME(Z3)
+          _RESTORE_CURRENT(Z3);
+        #endif
+        #if HAS_CURRENT_HOME(Z4)
+          _RESTORE_CURRENT(Z4);
         #endif
       }
 
       TERN_(IMPROVE_HOMING_RELIABILITY, planner.enable_stall_prevention(onoff));
 
       #if SENSORLESS_STALLGUARD_DELAY
         safe_delay(SENSORLESS_STALLGUARD_DELAY); // Short delay needed to settle
       #endif
 
     #endif

commit 441416728cd7f0e9b6ebf94f895d1d27fe59d25a
Author: Mark <niujl123@sina.com>
Date:   Sun Jun 18 17:18:08 2023 +0800

    üö∏ Bed distance sensor improvements (#25847)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 63689bf7ca..3c1fcc72a9 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -58,21 +58,25 @@ Endstops endstops;
 
 // private:
 
 bool Endstops::enabled, Endstops::enabled_globally; // Initialized by settings.load()
 
 volatile Endstops::endstop_mask_t Endstops::hit_state;
 Endstops::endstop_mask_t Endstops::live_state = 0;
 
 #if ENABLED(BD_SENSOR)
   bool Endstops::bdp_state; // = false
-  #define READ_ENDSTOP(P) ((P == Z_MIN_PIN) ? bdp_state : READ(P))
+  #if HOMING_Z_WITH_PROBE
+    #define READ_ENDSTOP(P) ((P == TERN(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN, Z_MIN_PIN, Z_MIN_PROBE_PIN)) ? bdp_state : READ(P))
+  #else
+    #define READ_ENDSTOP(P) READ(P)
+  #endif
 #else
   #define READ_ENDSTOP(P) READ(P)
 #endif
 
 #if ENDSTOP_NOISE_THRESHOLD
   Endstops::endstop_mask_t Endstops::validated_live_state;
   uint8_t Endstops::endstop_poll_count;
 #endif
 
 #if HAS_BED_PROBE

commit 2ef71c6ebaa1f1b496eb369879fe22c69cf9adb4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jun 12 16:38:14 2023 -0500

    ‚ôªÔ∏è Simplify SERIAL_ECHO (#25928)
    
    Since this increases AVR code size, try to optimize further.

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 3031e7d694..63689bf7ca 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -368,23 +368,22 @@ void Endstops::event_handler() {
 }
 
 #if NUM_AXES
 
   #pragma GCC diagnostic push
   #if GCC_VERSION <= 50000
     #pragma GCC diagnostic ignored "-Wunused-function"
   #endif
 
   static void print_es_state(const bool is_hit, FSTR_P const flabel=nullptr) {
-    if (flabel) SERIAL_ECHOF(flabel);
-    SERIAL_ECHOPGM(": ");
-    SERIAL_ECHOLNF(is_hit ? F(STR_ENDSTOP_HIT) : F(STR_ENDSTOP_OPEN));
+    if (flabel) SERIAL_ECHO(flabel);
+    SERIAL_ECHOLN(F(": "), is_hit ? F(STR_ENDSTOP_HIT) : F(STR_ENDSTOP_OPEN));
   }
 
   #pragma GCC diagnostic pop
 
 #endif
 
 void __O2 Endstops::report_states() {
   TERN_(BLTOUCH, bltouch._set_SW_mode());
   SERIAL_ECHOLNPGM(STR_M119_REPORT);
   #define ES_REPORT(S) print_es_state(READ_ENDSTOP(S##_PIN) == S##_ENDSTOP_HIT_STATE, F(STR_##S))

commit 86c811660ebf0b3fcbae2f34273d4c9d0c22abc4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:30:34 2023 -0500

    üßë‚Äçüíª Remove LOOP macros (#25917)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index f73d0f1e6b..3031e7d694 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -473,21 +473,21 @@ void __O2 Endstops::report_states() {
     ES_REPORT(W_MAX);
   #endif
   #if ENABLED(PROBE_ACTIVATION_SWITCH)
     print_es_state(probe_switch_activated(), F(STR_PROBE_EN));
   #endif
   #if USE_Z_MIN_PROBE
     print_es_state(PROBE_TRIGGERED(), F(STR_Z_PROBE));
   #endif
   #if MULTI_FILAMENT_SENSOR
     #define _CASE_RUNOUT(N) case N: pin = FIL_RUNOUT##N##_PIN; state = FIL_RUNOUT##N##_STATE; break;
-    LOOP_S_LE_N(i, 1, NUM_RUNOUT_SENSORS) {
+    for (uint8_t i = 1; i <= NUM_RUNOUT_SENSORS; ++i) {
       pin_t pin;
       uint8_t state;
       switch (i) {
         default: continue;
         REPEAT_1(NUM_RUNOUT_SENSORS, _CASE_RUNOUT)
       }
       SERIAL_ECHOPGM(STR_FILAMENT);
       if (i > 1) SERIAL_CHAR(' ', '0' + i);
       print_es_state(extDigitalRead(pin) != state);
     }

commit 2691167afe02fbbe74b0fdca2c28a49fac635741
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:26:02 2023 -0500

    üßë‚Äçüíª Dump BOTH and EITHER macros (#25908)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index a22c4f0381..f73d0f1e6b 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -24,21 +24,21 @@
  * endstops.cpp - A singleton object to manage endstops
  */
 
 #include "endstops.h"
 #include "stepper.h"
 
 #include "../sd/cardreader.h"
 #include "temperature.h"
 #include "../lcd/marlinui.h"
 
-#define DEBUG_OUT BOTH(USE_SENSORLESS, DEBUG_LEVELING_FEATURE)
+#define DEBUG_OUT ALL(USE_SENSORLESS, DEBUG_LEVELING_FEATURE)
 #include "../core/debug_out.h"
 
 #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
   #include HAL_PATH(.., endstop_interrupts.h)
 #endif
 
 #if ENABLED(SD_ABORT_ON_ENDSTOP_HIT)
   #include "printcounter.h" // for print_job_timer
 #endif
 
@@ -1129,25 +1129,25 @@ void Endstops::update() {
       if (tmc_spi_homing.w && stepperW.test_stall_status()) { SBI(live_state, W_ENDSTOP); hit = true; }
     #endif
 
     if (TERN0(ENDSTOP_INTERRUPTS_FEATURE, hit)) update();
 
     return hit;
   }
 
   void Endstops::clear_endstop_state() {
     TERN_(X_SPI_SENSORLESS, CBI(live_state, X_ENDSTOP));
-    #if BOTH(X_SPI_SENSORLESS, X_DUAL_ENDSTOPS)
+    #if ALL(X_SPI_SENSORLESS, X_DUAL_ENDSTOPS)
       CBI(live_state, X2_ENDSTOP);
     #endif
     TERN_(Y_SPI_SENSORLESS, CBI(live_state, Y_ENDSTOP));
-    #if BOTH(Y_SPI_SENSORLESS, Y_DUAL_ENDSTOPS)
+    #if ALL(Y_SPI_SENSORLESS, Y_DUAL_ENDSTOPS)
       CBI(live_state, Y2_ENDSTOP);
     #endif
     TERN_(Z_SPI_SENSORLESS, CBI(live_state, Z_ENDSTOP));
     TERN_(I_SPI_SENSORLESS, CBI(live_state, I_ENDSTOP));
     TERN_(J_SPI_SENSORLESS, CBI(live_state, J_ENDSTOP));
     TERN_(K_SPI_SENSORLESS, CBI(live_state, K_ENDSTOP));
     TERN_(U_SPI_SENSORLESS, CBI(live_state, U_ENDSTOP));
     TERN_(V_SPI_SENSORLESS, CBI(live_state, V_ENDSTOP));
     TERN_(W_SPI_SENSORLESS, CBI(live_state, W_ENDSTOP));
   }

commit 25ddde0394361c23194c0f4a8f9777d389040af3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon May 15 22:00:15 2023 -0500

    üßë‚Äçüíª Change Marlin DIR bits: 1=Forward, 0=Reverse (#25791)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 0a12e1041d..a22c4f0381 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -865,21 +865,21 @@ void Endstops::update() {
       #define _G38_RESP(Q) if (moving[_AXIS(Q)]) { _ENDSTOP_HIT(Q, ENDSTOP); planner.endstop_triggered(_AXIS(Q)); }
       const Flags<NUM_AXES> moving = { value_t(NUM_AXES)(0 MAIN_AXIS_MAP(_G38_SET)) };
       MAIN_AXIS_MAP(_G38_RESP);
     }
   #endif
 
   // Signal, after validation, if an endstop limit is pressed or not
 
   #if HAS_X_AXIS
     if (stepper.axis_is_moving(X_AXIS)) {
-      if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
+      if (!stepper.motor_direction(X_AXIS_HEAD)) { // -direction
         #if USE_X_MIN || (X_SPI_SENSORLESS && X_HOME_TO_MIN)
           PROCESS_ENDSTOP_X(MIN);
           #if   CORE_DIAG(XY, Y, MIN)
             PROCESS_CORE_ENDSTOP(Y,MIN,X,MIN);
           #elif CORE_DIAG(XY, Y, MAX)
             PROCESS_CORE_ENDSTOP(Y,MAX,X,MIN);
           #elif CORE_DIAG(XZ, Z, MIN)
             PROCESS_CORE_ENDSTOP(Z,MIN,X,MIN);
           #elif CORE_DIAG(XZ, Z, MAX)
             PROCESS_CORE_ENDSTOP(Z,MAX,X,MIN);
@@ -898,21 +898,21 @@ void Endstops::update() {
           #elif CORE_DIAG(XZ, Z, MAX)
             PROCESS_CORE_ENDSTOP(Z,MAX,X,MAX);
           #endif
         #endif
       }
     }
   #endif // HAS_X_AXIS
 
   #if HAS_Y_AXIS
     if (stepper.axis_is_moving(Y_AXIS)) {
-      if (stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
+      if (!stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
         #if USE_Y_MIN || (Y_SPI_SENSORLESS && Y_HOME_TO_MIN)
           PROCESS_ENDSTOP_Y(MIN);
           #if   CORE_DIAG(XY, X, MIN)
             PROCESS_CORE_ENDSTOP(X,MIN,Y,MIN);
           #elif CORE_DIAG(XY, X, MAX)
             PROCESS_CORE_ENDSTOP(X,MAX,Y,MIN);
           #elif CORE_DIAG(YZ, Z, MIN)
             PROCESS_CORE_ENDSTOP(Z,MIN,Y,MIN);
           #elif CORE_DIAG(YZ, Z, MAX)
             PROCESS_CORE_ENDSTOP(Z,MAX,Y,MIN);
@@ -931,21 +931,21 @@ void Endstops::update() {
           #elif CORE_DIAG(YZ, Z, MAX)
             PROCESS_CORE_ENDSTOP(Z,MAX,Y,MAX);
           #endif
         #endif
       }
     }
   #endif // HAS_Y_AXIS
 
   #if HAS_Z_AXIS
     if (stepper.axis_is_moving(Z_AXIS)) {
-      if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
+      if (!stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
 
         #if USE_Z_MIN || (Z_SPI_SENSORLESS && Z_HOME_TO_MIN)
           if ( TERN1(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN, z_probe_enabled)
             && TERN1(USE_Z_MIN_PROBE, !z_probe_enabled)
           ) PROCESS_ENDSTOP_Z(MIN);
           #if   CORE_DIAG(XZ, X, MIN)
             PROCESS_CORE_ENDSTOP(X,MIN,Z,MIN);
           #elif CORE_DIAG(XZ, X, MAX)
             PROCESS_CORE_ENDSTOP(X,MAX,Z,MIN);
           #elif CORE_DIAG(YZ, Y, MIN)
@@ -976,96 +976,96 @@ void Endstops::update() {
           #elif CORE_DIAG(YZ, Y, MAX)
             PROCESS_CORE_ENDSTOP(Y,MAX,Z,MAX);
           #endif
         #endif
       }
     }
   #endif // HAS_Z_AXIS
 
   #if HAS_I_AXIS
     if (stepper.axis_is_moving(I_AXIS)) {
-      if (stepper.motor_direction(I_AXIS_HEAD)) { // -direction
+      if (!stepper.motor_direction(I_AXIS_HEAD)) { // -direction
         #if USE_I_MIN || (I_SPI_SENSORLESS && I_HOME_TO_MIN)
           PROCESS_ENDSTOP(I, MIN);
         #endif
       }
       else { // +direction
         #if USE_I_MAX || (I_SPI_SENSORLESS && I_HOME_TO_MAX)
           PROCESS_ENDSTOP(I, MAX);
         #endif
       }
     }
   #endif // HAS_I_AXIS
 
   #if HAS_J_AXIS
     if (stepper.axis_is_moving(J_AXIS)) {
-      if (stepper.motor_direction(J_AXIS_HEAD)) { // -direction
+      if (!stepper.motor_direction(J_AXIS_HEAD)) { // -direction
         #if USE_J_MIN || (J_SPI_SENSORLESS && J_HOME_TO_MIN)
           PROCESS_ENDSTOP(J, MIN);
         #endif
       }
       else { // +direction
         #if USE_J_MAX || (J_SPI_SENSORLESS && J_HOME_TO_MAX)
           PROCESS_ENDSTOP(J, MAX);
         #endif
       }
     }
   #endif // HAS_J_AXIS
 
   #if HAS_K_AXIS
     if (stepper.axis_is_moving(K_AXIS)) {
-      if (stepper.motor_direction(K_AXIS_HEAD)) { // -direction
+      if (!stepper.motor_direction(K_AXIS_HEAD)) { // -direction
         #if USE_K_MIN || (K_SPI_SENSORLESS && K_HOME_TO_MIN)
           PROCESS_ENDSTOP(K, MIN);
         #endif
       }
       else { // +direction
         #if USE_K_MAX || (K_SPI_SENSORLESS && K_HOME_TO_MAX)
           PROCESS_ENDSTOP(K, MAX);
         #endif
       }
     }
   #endif // HAS_K_AXIS
 
   #if HAS_U_AXIS
     if (stepper.axis_is_moving(U_AXIS)) {
-      if (stepper.motor_direction(U_AXIS_HEAD)) { // -direction
+      if (!stepper.motor_direction(U_AXIS_HEAD)) { // -direction
         #if USE_U_MIN || (U_SPI_SENSORLESS && U_HOME_TO_MIN)
           PROCESS_ENDSTOP(U, MIN);
         #endif
       }
       else { // +direction
         #if USE_U_MAX || (U_SPI_SENSORLESS && U_HOME_TO_MAX)
           PROCESS_ENDSTOP(U, MAX);
         #endif
       }
     }
   #endif // HAS_U_AXIS
 
   #if HAS_V_AXIS
     if (stepper.axis_is_moving(V_AXIS)) {
-      if (stepper.motor_direction(V_AXIS_HEAD)) { // -direction
+      if (!stepper.motor_direction(V_AXIS_HEAD)) { // -direction
         #if USE_V_MIN || (V_SPI_SENSORLESS && V_HOME_TO_MIN)
           PROCESS_ENDSTOP(V, MIN);
         #endif
       }
       else { // +direction
         #if USE_V_MAX || (V_SPI_SENSORLESS && V_HOME_TO_MAX)
           PROCESS_ENDSTOP(V, MAX);
         #endif
       }
     }
   #endif // HAS_V_AXIS
 
   #if HAS_W_AXIS
     if (stepper.axis_is_moving(W_AXIS)) {
-      if (stepper.motor_direction(W_AXIS_HEAD)) { // -direction
+      if (!stepper.motor_direction(W_AXIS_HEAD)) { // -direction
         #if USE_W_MIN || (W_SPI_SENSORLESS && W_HOME_TO_MIN)
           PROCESS_ENDSTOP(W, MIN);
         #endif
       }
       else { // +direction
         #if USE_W_MAX || (W_SPI_SENSORLESS && W_HOME_TO_MAX)
           PROCESS_ENDSTOP(W, MAX);
         #endif
       }
     }

commit 1f9bfc5c7491d802d242623f8253b1f52c0917a3
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Wed May 10 06:59:25 2023 +1200

    üö∏ Optional X-Axis (#25418)
    
    Co-authored-by: alextrical <35117191+alextrical@users.noreply.github.com>
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index bf493023d8..0a12e1041d 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -293,21 +293,21 @@ void Endstops::resync() {
     if (!monitor_count) monitor();      // report changes in endstop status
   }
 #endif
 
 void Endstops::event_handler() {
   static endstop_mask_t prev_hit_state; // = 0
   if (hit_state == prev_hit_state) return;
   prev_hit_state = hit_state;
   if (hit_state) {
     #if HAS_STATUS_MESSAGE
-      char NUM_AXIS_LIST(chrX = ' ', chrY = ' ', chrZ = ' ', chrI = ' ', chrJ = ' ', chrK = ' ', chrU = ' ', chrV = ' ', chrW = ' '),
+      char NUM_AXIS_LIST_(chrX = ' ', chrY = ' ', chrZ = ' ', chrI = ' ', chrJ = ' ', chrK = ' ', chrU = ' ', chrV = ' ', chrW = ' ')
            chrP = ' ';
       #define _SET_STOP_CHAR(A,C) (chr## A = C)
     #else
       #define _SET_STOP_CHAR(A,C) NOOP
     #endif
 
     #define _ENDSTOP_HIT_ECHO(A,C) do{ \
       SERIAL_ECHOPGM(" " STRINGIFY(A) ":", planner.triggered_position_mm(_AXIS(A))); _SET_STOP_CHAR(A,C); }while(0)
 
     #define _ENDSTOP_HIT_TEST(A,C) \
@@ -341,51 +341,55 @@ void Endstops::event_handler() {
     #if USE_Z_MIN_PROBE
       #define P_AXIS Z_AXIS
       if (TEST(hit_state, Z_MIN_PROBE)) _ENDSTOP_HIT_ECHO(P, 'P');
     #endif
     SERIAL_EOL();
 
     TERN_(HAS_STATUS_MESSAGE,
       ui.status_printf(0,
         F(S_FMT GANG_N_1(NUM_AXES, " %c") " %c"),
         GET_TEXT(MSG_LCD_ENDSTOPS),
-        NUM_AXIS_LIST(chrX, chrY, chrZ, chrI, chrJ, chrK, chrU, chrV, chrW), chrP
+        NUM_AXIS_LIST_(chrX, chrY, chrZ, chrI, chrJ, chrK, chrU, chrV, chrW) chrP
       )
     );
 
     #if ENABLED(SD_ABORT_ON_ENDSTOP_HIT)
       if (planner.abort_on_endstop_hit) {
         card.abortFilePrintNow();
         quickstop_stepper();
         thermalManager.disable_all_heaters();
         #ifdef SD_ABORT_ON_ENDSTOP_HIT_GCODE
           queue.clear();
           queue.inject(F(SD_ABORT_ON_ENDSTOP_HIT_GCODE));
         #endif
         print_job_timer.stop();
       }
     #endif
   }
 }
 
-#pragma GCC diagnostic push
-#if GCC_VERSION <= 50000
-  #pragma GCC diagnostic ignored "-Wunused-function"
-#endif
+#if NUM_AXES
 
-static void print_es_state(const bool is_hit, FSTR_P const flabel=nullptr) {
-  if (flabel) SERIAL_ECHOF(flabel);
-  SERIAL_ECHOPGM(": ");
-  SERIAL_ECHOLNF(is_hit ? F(STR_ENDSTOP_HIT) : F(STR_ENDSTOP_OPEN));
-}
+  #pragma GCC diagnostic push
+  #if GCC_VERSION <= 50000
+    #pragma GCC diagnostic ignored "-Wunused-function"
+  #endif
 
-#pragma GCC diagnostic pop
+  static void print_es_state(const bool is_hit, FSTR_P const flabel=nullptr) {
+    if (flabel) SERIAL_ECHOF(flabel);
+    SERIAL_ECHOPGM(": ");
+    SERIAL_ECHOLNF(is_hit ? F(STR_ENDSTOP_HIT) : F(STR_ENDSTOP_OPEN));
+  }
+
+  #pragma GCC diagnostic pop
+
+#endif
 
 void __O2 Endstops::report_states() {
   TERN_(BLTOUCH, bltouch._set_SW_mode());
   SERIAL_ECHOLNPGM(STR_M119_REPORT);
   #define ES_REPORT(S) print_es_state(READ_ENDSTOP(S##_PIN) == S##_ENDSTOP_HIT_STATE, F(STR_##S))
   #if USE_X_MIN
     ES_REPORT(X_MIN);
   #endif
   #if USE_X2_MIN
     ES_REPORT(X2_MIN);

commit 99a9e265b0b7356b4d3bc5fdef88e2afe1ab0623
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 6 19:07:07 2023 -0500

    ü©π Endstops prelim. followup

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 0a01dd2d04..bf493023d8 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -304,21 +304,21 @@ void Endstops::event_handler() {
            chrP = ' ';
       #define _SET_STOP_CHAR(A,C) (chr## A = C)
     #else
       #define _SET_STOP_CHAR(A,C) NOOP
     #endif
 
     #define _ENDSTOP_HIT_ECHO(A,C) do{ \
       SERIAL_ECHOPGM(" " STRINGIFY(A) ":", planner.triggered_position_mm(_AXIS(A))); _SET_STOP_CHAR(A,C); }while(0)
 
     #define _ENDSTOP_HIT_TEST(A,C) \
-      if (TERN0(HAS_##A##_MIN, TEST(hit_state, A##_MIN)) || TERN0(HAS_##A##_MAX, TEST(hit_state, A##_MAX))) \
+      if (TERN0(USE_##A##_MIN, TEST(hit_state, ES_ENUM(A,MIN))) || TERN0(USE_##A##_MAX, TEST(hit_state, ES_ENUM(A,MAX)))) \
         _ENDSTOP_HIT_ECHO(A,C)
 
     #define ENDSTOP_HIT_TEST_X() _ENDSTOP_HIT_TEST(X,'X')
     #define ENDSTOP_HIT_TEST_Y() _ENDSTOP_HIT_TEST(Y,'Y')
     #define ENDSTOP_HIT_TEST_Z() _ENDSTOP_HIT_TEST(Z,'Z')
     #define ENDSTOP_HIT_TEST_I() _ENDSTOP_HIT_TEST(I,'I')
     #define ENDSTOP_HIT_TEST_J() _ENDSTOP_HIT_TEST(J,'J')
     #define ENDSTOP_HIT_TEST_K() _ENDSTOP_HIT_TEST(K,'K')
     #define ENDSTOP_HIT_TEST_U() _ENDSTOP_HIT_TEST(U,'U')
     #define ENDSTOP_HIT_TEST_V() _ENDSTOP_HIT_TEST(V,'V')
@@ -785,21 +785,21 @@ void Endstops::update() {
 
   // Call the endstop triggered routine for single endstops
   #define PROCESS_ENDSTOP(AXIS, MINMAX) do { \
     if (TEST_ENDSTOP(_ENDSTOP(AXIS, MINMAX))) { \
       _ENDSTOP_HIT(AXIS, MINMAX); \
       planner.endstop_triggered(_AXIS(AXIS)); \
     } \
   }while(0)
 
   // Core Sensorless Homing needs to test an Extra Pin
-  #define CORE_DIAG(QQ,A,MM) (CORE_IS_##QQ && A##_SENSORLESS && !A##_SPI_SENSORLESS && HAS_##A##_##MM)
+  #define CORE_DIAG(QQ,A,MM) (CORE_IS_##QQ && A##_SENSORLESS && !A##_SPI_SENSORLESS && USE_##A##_##MM)
   #define PROCESS_CORE_ENDSTOP(A1,M1,A2,M2) do { \
     if (TEST_ENDSTOP(_ENDSTOP(A1,M1))) { \
       _ENDSTOP_HIT(A2,M2); \
       planner.endstop_triggered(_AXIS(A2)); \
     } \
   }while(0)
 
   // Call the endstop triggered routine for dual endstops
   #define PROCESS_DUAL_ENDSTOP(A, MINMAX) do { \
     const byte dual_hit = TEST_ENDSTOP(_ENDSTOP(A, MINMAX)) | (TEST_ENDSTOP(_ENDSTOP(A##2, MINMAX)) << 1); \

commit 53d06be226a175a5a7950356746941a5319b06c5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 6 02:26:54 2023 -0500

    üßë‚Äçüíª Endstops preliminary followup
    
    Followup to #25780

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index ebe0a64bac..0a01dd2d04 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -862,35 +862,35 @@ void Endstops::update() {
       const Flags<NUM_AXES> moving = { value_t(NUM_AXES)(0 MAIN_AXIS_MAP(_G38_SET)) };
       MAIN_AXIS_MAP(_G38_RESP);
     }
   #endif
 
   // Signal, after validation, if an endstop limit is pressed or not
 
   #if HAS_X_AXIS
     if (stepper.axis_is_moving(X_AXIS)) {
       if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
-        #if HAS_X_MIN || (X_SPI_SENSORLESS && X_HOME_TO_MIN)
+        #if USE_X_MIN || (X_SPI_SENSORLESS && X_HOME_TO_MIN)
           PROCESS_ENDSTOP_X(MIN);
           #if   CORE_DIAG(XY, Y, MIN)
             PROCESS_CORE_ENDSTOP(Y,MIN,X,MIN);
           #elif CORE_DIAG(XY, Y, MAX)
             PROCESS_CORE_ENDSTOP(Y,MAX,X,MIN);
           #elif CORE_DIAG(XZ, Z, MIN)
             PROCESS_CORE_ENDSTOP(Z,MIN,X,MIN);
           #elif CORE_DIAG(XZ, Z, MAX)
             PROCESS_CORE_ENDSTOP(Z,MAX,X,MIN);
           #endif
         #endif
       }
       else { // +direction
-        #if HAS_X_MAX || (X_SPI_SENSORLESS && X_HOME_TO_MAX)
+        #if USE_X_MAX || (X_SPI_SENSORLESS && X_HOME_TO_MAX)
           PROCESS_ENDSTOP_X(MAX);
           #if   CORE_DIAG(XY, Y, MIN)
             PROCESS_CORE_ENDSTOP(Y,MIN,X,MAX);
           #elif CORE_DIAG(XY, Y, MAX)
             PROCESS_CORE_ENDSTOP(Y,MAX,X,MAX);
           #elif CORE_DIAG(XZ, Z, MIN)
             PROCESS_CORE_ENDSTOP(Z,MIN,X,MAX);
           #elif CORE_DIAG(XZ, Z, MAX)
             PROCESS_CORE_ENDSTOP(Z,MAX,X,MAX);
           #endif

commit 85325f585ac4a9bb667423561540b5d58bdc3b6e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri May 5 19:37:13 2023 -0500

    üßë‚Äçüíª Endstops preliminary work (#25780)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 668be5f1f4..ebe0a64bac 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -31,21 +31,21 @@
 #include "temperature.h"
 #include "../lcd/marlinui.h"
 
 #define DEBUG_OUT BOTH(USE_SENSORLESS, DEBUG_LEVELING_FEATURE)
 #include "../core/debug_out.h"
 
 #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
   #include HAL_PATH(.., endstop_interrupts.h)
 #endif
 
-#if BOTH(SD_ABORT_ON_ENDSTOP_HIT, HAS_MEDIA)
+#if ENABLED(SD_ABORT_ON_ENDSTOP_HIT)
   #include "printcounter.h" // for print_job_timer
 #endif
 
 #if ENABLED(BLTOUCH)
   #include "../feature/bltouch.h"
 #endif
 
 #if ENABLED(JOYSTICK)
   #include "../feature/joystick.h"
 #endif
@@ -103,116 +103,116 @@ Endstops::endstop_mask_t Endstops::live_state = 0;
   millis_t sg_guard_period; // = 0
 #endif
 
 /**
  * Class and Instance Methods
  */
 
 void Endstops::init() {
 
   #define _INIT_ENDSTOP(T,A,N) TERN(ENDSTOPPULLUP_##A##T, SET_INPUT_PULLUP, TERN(ENDSTOPPULLDOWN_##A##T, SET_INPUT_PULLDOWN, SET_INPUT))(A##N##_##T##_PIN)
-  #if HAS_X_MIN
+  #if USE_X_MIN
     _INIT_ENDSTOP(MIN,X,);
   #endif
-  #if HAS_X_MAX
+  #if USE_X_MAX
     _INIT_ENDSTOP(MAX,X,);
   #endif
-  #if HAS_X2_MIN
+  #if USE_X2_MIN
     _INIT_ENDSTOP(MIN,X,2);
   #endif
-  #if HAS_X2_MAX
+  #if USE_X2_MAX
     _INIT_ENDSTOP(MAX,X,2);
   #endif
-  #if HAS_Y_MIN
+  #if USE_Y_MIN
     _INIT_ENDSTOP(MIN,Y,);
   #endif
-  #if HAS_Y_MAX
+  #if USE_Y_MAX
     _INIT_ENDSTOP(MAX,Y,);
   #endif
-  #if HAS_Y2_MIN
+  #if USE_Y2_MIN
     _INIT_ENDSTOP(MIN,Y,2);
   #endif
-  #if HAS_Y2_MAX
+  #if USE_Y2_MAX
     _INIT_ENDSTOP(MAX,Y,2);
   #endif
   #if HAS_Z_MIN_PIN
     _INIT_ENDSTOP(MIN,Z,);
   #endif
-  #if HAS_Z_MAX
+  #if USE_Z_MAX
     _INIT_ENDSTOP(MAX,Z,);
   #endif
-  #if HAS_Z2_MIN
+  #if USE_Z2_MIN
     _INIT_ENDSTOP(MIN,Z,2);
   #endif
-  #if HAS_Z2_MAX
+  #if USE_Z2_MAX
     _INIT_ENDSTOP(MAX,Z,2);
   #endif
-  #if HAS_Z3_MIN
+  #if USE_Z3_MIN
     _INIT_ENDSTOP(MIN,Z,3);
   #endif
-  #if HAS_Z3_MAX
+  #if USE_Z3_MAX
     _INIT_ENDSTOP(MAX,Z,3);
   #endif
-  #if HAS_Z4_MIN
+  #if USE_Z4_MIN
     _INIT_ENDSTOP(MIN,Z,4);
   #endif
-  #if HAS_Z4_MAX
+  #if USE_Z4_MAX
     _INIT_ENDSTOP(MAX,Z,4);
   #endif
-  #if HAS_I_MIN
+  #if USE_I_MIN
     _INIT_ENDSTOP(MIN,I,);
   #endif
-  #if HAS_I_MAX
+  #if USE_I_MAX
     _INIT_ENDSTOP(MAX,I,);
   #endif
-  #if HAS_J_MIN
+  #if USE_J_MIN
     _INIT_ENDSTOP(MIN,J,);
   #endif
-  #if HAS_J_MAX
+  #if USE_J_MAX
     _INIT_ENDSTOP(MAX,J,);
   #endif
-  #if HAS_K_MIN
+  #if USE_K_MIN
     _INIT_ENDSTOP(MIN,K,);
   #endif
-  #if HAS_K_MAX
+  #if USE_K_MAX
     _INIT_ENDSTOP(MAX,K,);
   #endif
-  #if HAS_U_MIN
+  #if USE_U_MIN
     _INIT_ENDSTOP(MIN,U,);
   #endif
-  #if HAS_U_MAX
+  #if USE_U_MAX
     _INIT_ENDSTOP(MAX,U,);
   #endif
-  #if HAS_V_MIN
+  #if USE_V_MIN
     _INIT_ENDSTOP(MIN,V,);
   #endif
-  #if HAS_V_MAX
+  #if USE_V_MAX
     _INIT_ENDSTOP(MAX,V,);
   #endif
-  #if HAS_W_MIN
+  #if USE_W_MIN
     _INIT_ENDSTOP(MIN,W,);
   #endif
-  #if HAS_W_MAX
+  #if USE_W_MAX
     _INIT_ENDSTOP(MAX,W,);
   #endif
 
   #if PIN_EXISTS(CALIBRATION)
     #if ENABLED(CALIBRATION_PIN_PULLUP)
       SET_INPUT_PULLUP(CALIBRATION_PIN);
     #elif ENABLED(CALIBRATION_PIN_PULLDOWN)
       SET_INPUT_PULLDOWN(CALIBRATION_PIN);
     #else
       SET_INPUT(CALIBRATION_PIN);
     #endif
   #endif
 
-  #if USES_Z_MIN_PROBE_PIN
+  #if USE_Z_MIN_PROBE
     #if ENABLED(ENDSTOPPULLUP_ZMIN_PROBE)
       SET_INPUT_PULLUP(Z_MIN_PROBE_PIN);
     #elif ENABLED(ENDSTOPPULLDOWN_ZMIN_PROBE)
       SET_INPUT_PULLDOWN(Z_MIN_PROBE_PIN);
     #else
       SET_INPUT(Z_MIN_PROBE_PIN);
     #endif
   #endif
 
   #if ENABLED(PROBE_ACTIVATION_SWITCH)
@@ -331,35 +331,35 @@ void Endstops::event_handler() {
        ENDSTOP_HIT_TEST_Y(),
        ENDSTOP_HIT_TEST_Z(),
       _ENDSTOP_HIT_TEST(I,'I'),
       _ENDSTOP_HIT_TEST(J,'J'),
       _ENDSTOP_HIT_TEST(K,'K'),
       _ENDSTOP_HIT_TEST(U,'U'),
       _ENDSTOP_HIT_TEST(V,'V'),
       _ENDSTOP_HIT_TEST(W,'W')
     );
 
-    #if USES_Z_MIN_PROBE_PIN
+    #if USE_Z_MIN_PROBE
       #define P_AXIS Z_AXIS
       if (TEST(hit_state, Z_MIN_PROBE)) _ENDSTOP_HIT_ECHO(P, 'P');
     #endif
     SERIAL_EOL();
 
     TERN_(HAS_STATUS_MESSAGE,
       ui.status_printf(0,
         F(S_FMT GANG_N_1(NUM_AXES, " %c") " %c"),
         GET_TEXT(MSG_LCD_ENDSTOPS),
         NUM_AXIS_LIST(chrX, chrY, chrZ, chrI, chrJ, chrK, chrU, chrV, chrW), chrP
       )
     );
 
-    #if BOTH(SD_ABORT_ON_ENDSTOP_HIT, HAS_MEDIA)
+    #if ENABLED(SD_ABORT_ON_ENDSTOP_HIT)
       if (planner.abort_on_endstop_hit) {
         card.abortFilePrintNow();
         quickstop_stepper();
         thermalManager.disable_all_heaters();
         #ifdef SD_ABORT_ON_ENDSTOP_HIT_GCODE
           queue.clear();
           queue.inject(F(SD_ABORT_ON_ENDSTOP_HIT_GCODE));
         #endif
         print_job_timer.stop();
       }
@@ -377,108 +377,108 @@ static void print_es_state(const bool is_hit, FSTR_P const flabel=nullptr) {
   SERIAL_ECHOPGM(": ");
   SERIAL_ECHOLNF(is_hit ? F(STR_ENDSTOP_HIT) : F(STR_ENDSTOP_OPEN));
 }
 
 #pragma GCC diagnostic pop
 
 void __O2 Endstops::report_states() {
   TERN_(BLTOUCH, bltouch._set_SW_mode());
   SERIAL_ECHOLNPGM(STR_M119_REPORT);
   #define ES_REPORT(S) print_es_state(READ_ENDSTOP(S##_PIN) == S##_ENDSTOP_HIT_STATE, F(STR_##S))
-  #if HAS_X_MIN
+  #if USE_X_MIN
     ES_REPORT(X_MIN);
   #endif
-  #if HAS_X2_MIN
+  #if USE_X2_MIN
     ES_REPORT(X2_MIN);
   #endif
-  #if HAS_X_MAX
+  #if USE_X_MAX
     ES_REPORT(X_MAX);
   #endif
-  #if HAS_X2_MAX
+  #if USE_X2_MAX
     ES_REPORT(X2_MAX);
   #endif
-  #if HAS_Y_MIN
+  #if USE_Y_MIN
     ES_REPORT(Y_MIN);
   #endif
-  #if HAS_Y2_MIN
+  #if USE_Y2_MIN
     ES_REPORT(Y2_MIN);
   #endif
-  #if HAS_Y_MAX
+  #if USE_Y_MAX
     ES_REPORT(Y_MAX);
   #endif
-  #if HAS_Y2_MAX
+  #if USE_Y2_MAX
     ES_REPORT(Y2_MAX);
   #endif
-  #if HAS_Z_MIN
+  #if USE_Z_MIN
     ES_REPORT(Z_MIN);
   #endif
-  #if HAS_Z2_MIN
+  #if USE_Z2_MIN
     ES_REPORT(Z2_MIN);
   #endif
-  #if HAS_Z3_MIN
+  #if USE_Z3_MIN
     ES_REPORT(Z3_MIN);
   #endif
-  #if HAS_Z4_MIN
+  #if USE_Z4_MIN
     ES_REPORT(Z4_MIN);
   #endif
-  #if HAS_Z_MAX
+  #if USE_Z_MAX
     ES_REPORT(Z_MAX);
   #endif
-  #if HAS_Z2_MAX
+  #if USE_Z2_MAX
     ES_REPORT(Z2_MAX);
   #endif
-  #if HAS_Z3_MAX
+  #if USE_Z3_MAX
     ES_REPORT(Z3_MAX);
   #endif
-  #if HAS_Z4_MAX
+  #if USE_Z4_MAX
     ES_REPORT(Z4_MAX);
   #endif
-  #if HAS_I_MIN
+  #if USE_I_MIN
     ES_REPORT(I_MIN);
   #endif
-  #if HAS_I_MAX
+  #if USE_I_MAX
     ES_REPORT(I_MAX);
   #endif
-  #if HAS_J_MIN
+  #if USE_J_MIN
     ES_REPORT(J_MIN);
   #endif
-  #if HAS_J_MAX
+  #if USE_J_MAX
     ES_REPORT(J_MAX);
   #endif
-  #if HAS_K_MIN
+  #if USE_K_MIN
     ES_REPORT(K_MIN);
   #endif
-  #if HAS_K_MAX
+  #if USE_K_MAX
     ES_REPORT(K_MAX);
   #endif
-  #if HAS_U_MIN
+  #if USE_U_MIN
     ES_REPORT(U_MIN);
   #endif
-  #if HAS_U_MAX
+  #if USE_U_MAX
     ES_REPORT(U_MAX);
   #endif
-  #if HAS_V_MIN
+  #if USE_V_MIN
     ES_REPORT(V_MIN);
   #endif
-  #if HAS_V_MAX
+  #if USE_V_MAX
     ES_REPORT(V_MAX);
   #endif
-  #if HAS_W_MIN
+  #if USE_W_MIN
     ES_REPORT(W_MIN);
   #endif
-  #if HAS_W_MAX
+  #if USE_W_MAX
     ES_REPORT(W_MAX);
   #endif
   #if ENABLED(PROBE_ACTIVATION_SWITCH)
     print_es_state(probe_switch_activated(), F(STR_PROBE_EN));
   #endif
-  #if USES_Z_MIN_PROBE_PIN
+  #if USE_Z_MIN_PROBE
     print_es_state(PROBE_TRIGGERED(), F(STR_Z_PROBE));
   #endif
   #if MULTI_FILAMENT_SENSOR
     #define _CASE_RUNOUT(N) case N: pin = FIL_RUNOUT##N##_PIN; state = FIL_RUNOUT##N##_STATE; break;
     LOOP_S_LE_N(i, 1, NUM_RUNOUT_SENSORS) {
       pin_t pin;
       uint8_t state;
       switch (i) {
         default: continue;
         REPEAT_1(NUM_RUNOUT_SENSORS, _CASE_RUNOUT)
@@ -512,26 +512,26 @@ void Endstops::update() {
   #if !ENDSTOP_NOISE_THRESHOLD      // If not debouncing...
     if (!abort_enabled()) return;   // ...and not enabled, exit.
   #endif
 
   // Macros to update / copy the live_state
   #define UPDATE_LIVE_STATE(AXIS, MINMAX) SET_BIT_TO(live_state, _ENDSTOP(AXIS, MINMAX), (READ_ENDSTOP(_ENDSTOP_PIN(AXIS, MINMAX)) == _ENDSTOP_HIT_STATE(AXIS, MINMAX)))
   #define COPY_LIVE_STATE(SRC_BIT, DST_BIT) SET_BIT_TO(live_state, DST_BIT, TEST(live_state, SRC_BIT))
 
   #if ENABLED(G38_PROBE_TARGET)
     // For G38 moves check the probe's pin for ALL movement
-    if (G38_move) UPDATE_LIVE_STATE(Z, TERN(USES_Z_MIN_PROBE_PIN, MIN_PROBE, MIN));
+    if (G38_move) UPDATE_LIVE_STATE(Z, TERN(USE_Z_MIN_PROBE, MIN_PROBE, MIN));
   #endif
 
   // With Dual X, endstops are only checked in the homing direction for the active extruder
-  #define X_MIN_TEST() TERN1(DUAL_X_CARRIAGE, TERN0(X_HOME_TO_MIN, stepper.last_moved_extruder == 0) || TERN0(X2_HOME_TO_MIN, stepper.last_moved_extruder != 0))
-  #define X_MAX_TEST() TERN1(DUAL_X_CARRIAGE, TERN0(X_HOME_TO_MAX, stepper.last_moved_extruder == 0) || TERN0(X2_HOME_TO_MAX, stepper.last_moved_extruder != 0))
+  #define X_MIN_TEST() TERN1(DUAL_X_CARRIAGE, stepper.last_moved_extruder == 0) // Check min for the left carriage
+  #define X_MAX_TEST() TERN1(DUAL_X_CARRIAGE, stepper.last_moved_extruder != 0) // Check max for the right carriage
 
   // Use HEAD for core axes, AXIS for others
   #if ANY(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY, MARKFORGED_YX)
     #define X_AXIS_HEAD X_HEAD
   #else
     #define X_AXIS_HEAD X_AXIS
   #endif
   #if ANY(CORE_IS_XY, CORE_IS_YZ, MARKFORGED_XY, MARKFORGED_YX)
     #define Y_AXIS_HEAD Y_HEAD
   #else
@@ -546,213 +546,213 @@ void Endstops::update() {
   #define I_AXIS_HEAD I_AXIS
   #define J_AXIS_HEAD J_AXIS
   #define K_AXIS_HEAD K_AXIS
   #define U_AXIS_HEAD U_AXIS
   #define V_AXIS_HEAD V_AXIS
   #define W_AXIS_HEAD W_AXIS
 
   /**
    * Check and update endstops
    */
-  #if HAS_X_MIN && !X_SPI_SENSORLESS
+  #if USE_X_MIN && !X_SPI_SENSORLESS
     UPDATE_LIVE_STATE(X, MIN);
     #if ENABLED(X_DUAL_ENDSTOPS)
-      #if HAS_X2_MIN
+      #if USE_X2_MIN
         UPDATE_LIVE_STATE(X2, MIN);
       #else
         COPY_LIVE_STATE(X_MIN, X2_MIN);
       #endif
     #endif
   #endif
 
-  #if HAS_X_MAX && !X_SPI_SENSORLESS
+  #if USE_X_MAX && !X_SPI_SENSORLESS
     UPDATE_LIVE_STATE(X, MAX);
     #if ENABLED(X_DUAL_ENDSTOPS)
-      #if HAS_X2_MAX
+      #if USE_X2_MAX
         UPDATE_LIVE_STATE(X2, MAX);
       #else
         COPY_LIVE_STATE(X_MAX, X2_MAX);
       #endif
     #endif
   #endif
 
-  #if HAS_Y_MIN && !Y_SPI_SENSORLESS
+  #if USE_Y_MIN && !Y_SPI_SENSORLESS
     UPDATE_LIVE_STATE(Y, MIN);
     #if ENABLED(Y_DUAL_ENDSTOPS)
-      #if HAS_Y2_MIN
+      #if USE_Y2_MIN
         UPDATE_LIVE_STATE(Y2, MIN);
       #else
         COPY_LIVE_STATE(Y_MIN, Y2_MIN);
       #endif
     #endif
   #endif
 
-  #if HAS_Y_MAX && !Y_SPI_SENSORLESS
+  #if USE_Y_MAX && !Y_SPI_SENSORLESS
     UPDATE_LIVE_STATE(Y, MAX);
     #if ENABLED(Y_DUAL_ENDSTOPS)
-      #if HAS_Y2_MAX
+      #if USE_Y2_MAX
         UPDATE_LIVE_STATE(Y2, MAX);
       #else
         COPY_LIVE_STATE(Y_MAX, Y2_MAX);
       #endif
     #endif
   #endif
 
-  #if HAS_Z_MIN && NONE(Z_SPI_SENSORLESS, Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
+  #if USE_Z_MIN && NONE(Z_SPI_SENSORLESS, Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
     #if HAS_Z_MIN_PIN
       UPDATE_LIVE_STATE(Z, MIN);
     #endif
     #if ENABLED(Z_MULTI_ENDSTOPS)
-      #if HAS_Z2_MIN
+      #if USE_Z2_MIN
         UPDATE_LIVE_STATE(Z2, MIN);
       #else
         COPY_LIVE_STATE(Z_MIN, Z2_MIN);
       #endif
       #if NUM_Z_STEPPERS >= 3
-        #if HAS_Z3_MIN
+        #if USE_Z3_MIN
           UPDATE_LIVE_STATE(Z3, MIN);
         #else
           COPY_LIVE_STATE(Z_MIN, Z3_MIN);
         #endif
       #endif
       #if NUM_Z_STEPPERS >= 4
-        #if HAS_Z4_MIN
+        #if USE_Z4_MIN
           UPDATE_LIVE_STATE(Z4, MIN);
         #else
           COPY_LIVE_STATE(Z_MIN, Z4_MIN);
         #endif
       #endif
     #endif
   #endif
 
   #if HAS_BED_PROBE
     // When closing the gap check the enabled probe
     if (probe_switch_activated())
-      UPDATE_LIVE_STATE(Z, TERN(USES_Z_MIN_PROBE_PIN, MIN_PROBE, MIN));
+      UPDATE_LIVE_STATE(Z, TERN(USE_Z_MIN_PROBE, MIN_PROBE, MIN));
   #endif
 
-  #if HAS_Z_MAX && !Z_SPI_SENSORLESS
+  #if USE_Z_MAX && !Z_SPI_SENSORLESS
     // Check both Z dual endstops
     #if ENABLED(Z_MULTI_ENDSTOPS)
       UPDATE_LIVE_STATE(Z, MAX);
-      #if HAS_Z2_MAX
+      #if USE_Z2_MAX
         UPDATE_LIVE_STATE(Z2, MAX);
       #else
         COPY_LIVE_STATE(Z_MAX, Z2_MAX);
       #endif
       #if NUM_Z_STEPPERS >= 3
-        #if HAS_Z3_MAX
+        #if USE_Z3_MAX
           UPDATE_LIVE_STATE(Z3, MAX);
         #else
           COPY_LIVE_STATE(Z_MAX, Z3_MAX);
         #endif
       #endif
       #if NUM_Z_STEPPERS >= 4
-        #if HAS_Z4_MAX
+        #if USE_Z4_MAX
           UPDATE_LIVE_STATE(Z4, MAX);
         #else
           COPY_LIVE_STATE(Z_MAX, Z4_MAX);
         #endif
       #endif
-    #elif TERN1(USES_Z_MIN_PROBE_PIN, Z_MAX_PIN != Z_MIN_PROBE_PIN)
+    #elif TERN1(USE_Z_MIN_PROBE, Z_MAX_PIN != Z_MIN_PROBE_PIN)
       // If this pin isn't the bed probe it's the Z endstop
       UPDATE_LIVE_STATE(Z, MAX);
     #endif
   #endif
 
-  #if HAS_I_MIN && !I_SPI_SENSORLESS
+  #if USE_I_MIN && !I_SPI_SENSORLESS
     #if ENABLED(I_DUAL_ENDSTOPS)
       UPDATE_LIVE_STATE(I, MIN);
     #else
       UPDATE_LIVE_STATE(I, MIN);
     #endif
   #endif
 
-  #if HAS_I_MAX && !I_SPI_SENSORLESS
+  #if USE_I_MAX && !I_SPI_SENSORLESS
     #if ENABLED(I_DUAL_ENDSTOPS)
       UPDATE_LIVE_STATE(I, MAX);
     #else
       UPDATE_LIVE_STATE(I, MAX);
     #endif
   #endif
 
-  #if HAS_J_MIN && !J_SPI_SENSORLESS
+  #if USE_J_MIN && !J_SPI_SENSORLESS
     #if ENABLED(J_DUAL_ENDSTOPS)
       UPDATE_LIVE_STATE(J, MIN);
     #else
       UPDATE_LIVE_STATE(J, MIN);
     #endif
   #endif
 
-  #if HAS_J_MAX && !J_SPI_SENSORLESS
+  #if USE_J_MAX && !J_SPI_SENSORLESS
     #if ENABLED(J_DUAL_ENDSTOPS)
       UPDATE_LIVE_STATE(J, MAX);
     #else
       UPDATE_LIVE_STATE(J, MAX);
     #endif
   #endif
 
-  #if HAS_K_MIN && !K_SPI_SENSORLESS
+  #if USE_K_MIN && !K_SPI_SENSORLESS
     #if ENABLED(K_DUAL_ENDSTOPS)
       UPDATE_LIVE_STATE(K, MIN);
     #else
       UPDATE_LIVE_STATE(K, MIN);
     #endif
   #endif
 
-  #if HAS_K_MAX && !K_SPI_SENSORLESS
+  #if USE_K_MAX && !K_SPI_SENSORLESS
     #if ENABLED(K_DUAL_ENDSTOPS)
       UPDATE_LIVE_STATE(K, MAX);
     #else
       UPDATE_LIVE_STATE(K, MAX);
     #endif
   #endif
 
-  #if HAS_U_MIN && !U_SPI_SENSORLESS
+  #if USE_U_MIN && !U_SPI_SENSORLESS
     #if ENABLED(U_DUAL_ENDSTOPS)
       UPDATE_LIVE_STATE(U, MIN);
     #else
       UPDATE_LIVE_STATE(U, MIN);
     #endif
   #endif
 
-  #if HAS_U_MAX && !U_SPI_SENSORLESS
+  #if USE_U_MAX && !U_SPI_SENSORLESS
     #if ENABLED(U_DUAL_ENDSTOPS)
       UPDATE_LIVE_STATE(U, MAX);
     #else
       UPDATE_LIVE_STATE(U, MAX);
     #endif
   #endif
 
-  #if HAS_V_MIN && !V_SPI_SENSORLESS
+  #if USE_V_MIN && !V_SPI_SENSORLESS
     #if ENABLED(V_DUAL_ENDSTOPS)
       UPDATE_LIVE_STATE(V, MIN);
     #else
       UPDATE_LIVE_STATE(V, MIN);
     #endif
   #endif
-  #if HAS_V_MAX && !V_SPI_SENSORLESS
+  #if USE_V_MAX && !V_SPI_SENSORLESS
     #if ENABLED(O_DUAL_ENDSTOPS)
       UPDATE_LIVE_STATE(V, MAX);
     #else
       UPDATE_LIVE_STATE(V, MAX);
     #endif
   #endif
 
-  #if HAS_W_MIN && !W_SPI_SENSORLESS
+  #if USE_W_MIN && !W_SPI_SENSORLESS
     #if ENABLED(W_DUAL_ENDSTOPS)
       UPDATE_LIVE_STATE(W, MIN);
     #else
       UPDATE_LIVE_STATE(W, MIN);
     #endif
   #endif
-  #if HAS_W_MAX && !W_SPI_SENSORLESS
+  #if USE_W_MAX && !W_SPI_SENSORLESS
     #if ENABLED(W_DUAL_ENDSTOPS)
       UPDATE_LIVE_STATE(W, MAX);
     #else
       UPDATE_LIVE_STATE(W, MAX);
     #endif
   #endif
 
   #if ENDSTOP_NOISE_THRESHOLD
 
     /**
@@ -895,179 +895,179 @@ void Endstops::update() {
             PROCESS_CORE_ENDSTOP(Z,MAX,X,MAX);
           #endif
         #endif
       }
     }
   #endif // HAS_X_AXIS
 
   #if HAS_Y_AXIS
     if (stepper.axis_is_moving(Y_AXIS)) {
       if (stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
-        #if HAS_Y_MIN || (Y_SPI_SENSORLESS && Y_HOME_TO_MIN)
+        #if USE_Y_MIN || (Y_SPI_SENSORLESS && Y_HOME_TO_MIN)
           PROCESS_ENDSTOP_Y(MIN);
           #if   CORE_DIAG(XY, X, MIN)
             PROCESS_CORE_ENDSTOP(X,MIN,Y,MIN);
           #elif CORE_DIAG(XY, X, MAX)
             PROCESS_CORE_ENDSTOP(X,MAX,Y,MIN);
           #elif CORE_DIAG(YZ, Z, MIN)
             PROCESS_CORE_ENDSTOP(Z,MIN,Y,MIN);
           #elif CORE_DIAG(YZ, Z, MAX)
             PROCESS_CORE_ENDSTOP(Z,MAX,Y,MIN);
           #endif
         #endif
       }
       else { // +direction
-        #if HAS_Y_MAX || (Y_SPI_SENSORLESS && Y_HOME_TO_MAX)
+        #if USE_Y_MAX || (Y_SPI_SENSORLESS && Y_HOME_TO_MAX)
           PROCESS_ENDSTOP_Y(MAX);
           #if   CORE_DIAG(XY, X, MIN)
             PROCESS_CORE_ENDSTOP(X,MIN,Y,MAX);
           #elif CORE_DIAG(XY, X, MAX)
             PROCESS_CORE_ENDSTOP(X,MAX,Y,MAX);
           #elif CORE_DIAG(YZ, Z, MIN)
             PROCESS_CORE_ENDSTOP(Z,MIN,Y,MAX);
           #elif CORE_DIAG(YZ, Z, MAX)
             PROCESS_CORE_ENDSTOP(Z,MAX,Y,MAX);
           #endif
         #endif
       }
     }
   #endif // HAS_Y_AXIS
 
   #if HAS_Z_AXIS
     if (stepper.axis_is_moving(Z_AXIS)) {
       if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
 
-        #if HAS_Z_MIN || (Z_SPI_SENSORLESS && Z_HOME_TO_MIN)
+        #if USE_Z_MIN || (Z_SPI_SENSORLESS && Z_HOME_TO_MIN)
           if ( TERN1(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN, z_probe_enabled)
-            && TERN1(USES_Z_MIN_PROBE_PIN, !z_probe_enabled)
+            && TERN1(USE_Z_MIN_PROBE, !z_probe_enabled)
           ) PROCESS_ENDSTOP_Z(MIN);
           #if   CORE_DIAG(XZ, X, MIN)
             PROCESS_CORE_ENDSTOP(X,MIN,Z,MIN);
           #elif CORE_DIAG(XZ, X, MAX)
             PROCESS_CORE_ENDSTOP(X,MAX,Z,MIN);
           #elif CORE_DIAG(YZ, Y, MIN)
             PROCESS_CORE_ENDSTOP(Y,MIN,Z,MIN);
           #elif CORE_DIAG(YZ, Y, MAX)
             PROCESS_CORE_ENDSTOP(Y,MAX,Z,MIN);
           #endif
         #endif
 
         // When closing the gap check the enabled probe
-        #if USES_Z_MIN_PROBE_PIN
+        #if USE_Z_MIN_PROBE
           if (z_probe_enabled) PROCESS_ENDSTOP(Z, MIN_PROBE);
         #endif
       }
       else { // Z +direction. Gantry up, bed down.
-        #if HAS_Z_MAX || (Z_SPI_SENSORLESS && Z_HOME_TO_MAX)
+        #if USE_Z_MAX || (Z_SPI_SENSORLESS && Z_HOME_TO_MAX)
           #if ENABLED(Z_MULTI_ENDSTOPS)
             PROCESS_ENDSTOP_Z(MAX);
-          #elif TERN1(USES_Z_MIN_PROBE_PIN, Z_MAX_PIN != Z_MIN_PROBE_PIN)  // No probe or probe is Z_MIN || Probe is not Z_MAX
+          #elif TERN1(USE_Z_MIN_PROBE, Z_MAX_PIN != Z_MIN_PROBE_PIN)  // No probe or probe is Z_MIN || Probe is not Z_MAX
             PROCESS_ENDSTOP(Z, MAX);
           #endif
           #if   CORE_DIAG(XZ, X, MIN)
             PROCESS_CORE_ENDSTOP(X,MIN,Z,MAX);
           #elif CORE_DIAG(XZ, X, MAX)
             PROCESS_CORE_ENDSTOP(X,MAX,Z,MAX);
           #elif CORE_DIAG(YZ, Y, MIN)
             PROCESS_CORE_ENDSTOP(Y,MIN,Z,MAX);
           #elif CORE_DIAG(YZ, Y, MAX)
             PROCESS_CORE_ENDSTOP(Y,MAX,Z,MAX);
           #endif
         #endif
       }
     }
   #endif // HAS_Z_AXIS
 
   #if HAS_I_AXIS
     if (stepper.axis_is_moving(I_AXIS)) {
       if (stepper.motor_direction(I_AXIS_HEAD)) { // -direction
-        #if HAS_I_MIN || (I_SPI_SENSORLESS && I_HOME_TO_MIN)
+        #if USE_I_MIN || (I_SPI_SENSORLESS && I_HOME_TO_MIN)
           PROCESS_ENDSTOP(I, MIN);
         #endif
       }
       else { // +direction
-        #if HAS_I_MAX || (I_SPI_SENSORLESS && I_HOME_TO_MAX)
+        #if USE_I_MAX || (I_SPI_SENSORLESS && I_HOME_TO_MAX)
           PROCESS_ENDSTOP(I, MAX);
         #endif
       }
     }
   #endif // HAS_I_AXIS
 
   #if HAS_J_AXIS
     if (stepper.axis_is_moving(J_AXIS)) {
       if (stepper.motor_direction(J_AXIS_HEAD)) { // -direction
-        #if HAS_J_MIN || (J_SPI_SENSORLESS && J_HOME_TO_MIN)
+        #if USE_J_MIN || (J_SPI_SENSORLESS && J_HOME_TO_MIN)
           PROCESS_ENDSTOP(J, MIN);
         #endif
       }
       else { // +direction
-        #if HAS_J_MAX || (J_SPI_SENSORLESS && J_HOME_TO_MAX)
+        #if USE_J_MAX || (J_SPI_SENSORLESS && J_HOME_TO_MAX)
           PROCESS_ENDSTOP(J, MAX);
         #endif
       }
     }
   #endif // HAS_J_AXIS
 
   #if HAS_K_AXIS
     if (stepper.axis_is_moving(K_AXIS)) {
       if (stepper.motor_direction(K_AXIS_HEAD)) { // -direction
-        #if HAS_K_MIN || (K_SPI_SENSORLESS && K_HOME_TO_MIN)
+        #if USE_K_MIN || (K_SPI_SENSORLESS && K_HOME_TO_MIN)
           PROCESS_ENDSTOP(K, MIN);
         #endif
       }
       else { // +direction
-        #if HAS_K_MAX || (K_SPI_SENSORLESS && K_HOME_TO_MAX)
+        #if USE_K_MAX || (K_SPI_SENSORLESS && K_HOME_TO_MAX)
           PROCESS_ENDSTOP(K, MAX);
         #endif
       }
     }
   #endif // HAS_K_AXIS
 
   #if HAS_U_AXIS
     if (stepper.axis_is_moving(U_AXIS)) {
       if (stepper.motor_direction(U_AXIS_HEAD)) { // -direction
-        #if HAS_U_MIN || (U_SPI_SENSORLESS && U_HOME_TO_MIN)
+        #if USE_U_MIN || (U_SPI_SENSORLESS && U_HOME_TO_MIN)
           PROCESS_ENDSTOP(U, MIN);
         #endif
       }
       else { // +direction
-        #if HAS_U_MAX || (U_SPI_SENSORLESS && U_HOME_TO_MAX)
+        #if USE_U_MAX || (U_SPI_SENSORLESS && U_HOME_TO_MAX)
           PROCESS_ENDSTOP(U, MAX);
         #endif
       }
     }
   #endif // HAS_U_AXIS
 
   #if HAS_V_AXIS
     if (stepper.axis_is_moving(V_AXIS)) {
       if (stepper.motor_direction(V_AXIS_HEAD)) { // -direction
-        #if HAS_V_MIN || (V_SPI_SENSORLESS && V_HOME_TO_MIN)
+        #if USE_V_MIN || (V_SPI_SENSORLESS && V_HOME_TO_MIN)
           PROCESS_ENDSTOP(V, MIN);
         #endif
       }
       else { // +direction
-        #if HAS_V_MAX || (V_SPI_SENSORLESS && V_HOME_TO_MAX)
+        #if USE_V_MAX || (V_SPI_SENSORLESS && V_HOME_TO_MAX)
           PROCESS_ENDSTOP(V, MAX);
         #endif
       }
     }
   #endif // HAS_V_AXIS
 
   #if HAS_W_AXIS
     if (stepper.axis_is_moving(W_AXIS)) {
       if (stepper.motor_direction(W_AXIS_HEAD)) { // -direction
-        #if HAS_W_MIN || (W_SPI_SENSORLESS && W_HOME_TO_MIN)
+        #if USE_W_MIN || (W_SPI_SENSORLESS && W_HOME_TO_MIN)
           PROCESS_ENDSTOP(W, MIN);
         #endif
       }
       else { // +direction
-        #if HAS_W_MAX || (W_SPI_SENSORLESS && W_HOME_TO_MAX)
+        #if USE_W_MAX || (W_SPI_SENSORLESS && W_HOME_TO_MAX)
           PROCESS_ENDSTOP(W, MAX);
         #endif
       }
     }
   #endif // HAS_W_AXIS
 } // Endstops::update()
 
 #if ENABLED(SPI_ENDSTOPS)
 
   // Called from idle() to read Trinamic stall states
@@ -1164,197 +1164,197 @@ void Endstops::update() {
    * that won't matter because this is all manual.
    */
   void Endstops::monitor() {
 
     static uint16_t old_live_state_local = 0;
     static uint8_t local_LED_status = 0;
     uint16_t live_state_local = 0;
 
     #define ES_GET_STATE(S) if (READ_ENDSTOP(S##_PIN)) SBI(live_state_local, S)
 
-    #if HAS_X_MIN
+    #if USE_X_MIN
       ES_GET_STATE(X_MIN);
     #endif
-    #if HAS_X_MAX
+    #if USE_X_MAX
       ES_GET_STATE(X_MAX);
     #endif
-    #if HAS_Y_MIN
+    #if USE_Y_MIN
       ES_GET_STATE(Y_MIN);
     #endif
-    #if HAS_Y_MAX
+    #if USE_Y_MAX
       ES_GET_STATE(Y_MAX);
     #endif
     #if HAS_Z_MIN_PIN
       ES_GET_STATE(Z_MIN);
     #endif
-    #if HAS_Z_MAX
+    #if USE_Z_MAX
       ES_GET_STATE(Z_MAX);
     #endif
-    #if HAS_Z_MIN_PROBE_PIN
+    #if USE_Z_MIN_PROBE
       ES_GET_STATE(Z_MIN_PROBE);
     #endif
-    #if HAS_X2_MIN
+    #if USE_X2_MIN
       ES_GET_STATE(X2_MIN);
     #endif
-    #if HAS_X2_MAX
+    #if USE_X2_MAX
       ES_GET_STATE(X2_MAX);
     #endif
-    #if HAS_Y2_MIN
+    #if USE_Y2_MIN
       ES_GET_STATE(Y2_MIN);
     #endif
-    #if HAS_Y2_MAX
+    #if USE_Y2_MAX
       ES_GET_STATE(Y2_MAX);
     #endif
-    #if HAS_Z2_MIN
+    #if USE_Z2_MIN
       ES_GET_STATE(Z2_MIN);
     #endif
-    #if HAS_Z2_MAX
+    #if USE_Z2_MAX
       ES_GET_STATE(Z2_MAX);
     #endif
-    #if HAS_Z3_MIN
+    #if USE_Z3_MIN
       ES_GET_STATE(Z3_MIN);
     #endif
-    #if HAS_Z3_MAX
+    #if USE_Z3_MAX
       ES_GET_STATE(Z3_MAX);
     #endif
-    #if HAS_Z4_MIN
+    #if USE_Z4_MIN
       ES_GET_STATE(Z4_MIN);
     #endif
-    #if HAS_Z4_MAX
+    #if USE_Z4_MAX
       ES_GET_STATE(Z4_MAX);
     #endif
-    #if HAS_I_MAX
+    #if USE_I_MAX
       ES_GET_STATE(I_MAX);
     #endif
-    #if HAS_I_MIN
+    #if USE_I_MIN
       ES_GET_STATE(I_MIN);
     #endif
-    #if HAS_J_MAX
+    #if USE_J_MAX
       ES_GET_STATE(J_MAX);
     #endif
-    #if HAS_J_MIN
+    #if USE_J_MIN
       ES_GET_STATE(J_MIN);
     #endif
-    #if HAS_K_MAX
+    #if USE_K_MAX
       ES_GET_STATE(K_MAX);
     #endif
-    #if HAS_K_MIN
+    #if USE_K_MIN
       ES_GET_STATE(K_MIN);
     #endif
-    #if HAS_U_MAX
+    #if USE_U_MAX
       ES_GET_STATE(U_MAX);
     #endif
-    #if HAS_U_MIN
+    #if USE_U_MIN
       ES_GET_STATE(U_MIN);
     #endif
-    #if HAS_V_MAX
+    #if USE_V_MAX
       ES_GET_STATE(V_MAX);
     #endif
-    #if HAS_V_MIN
+    #if USE_V_MIN
       ES_GET_STATE(V_MIN);
     #endif
-    #if HAS_W_MAX
+    #if USE_W_MAX
       ES_GET_STATE(W_MAX);
     #endif
-    #if HAS_W_MIN
+    #if USE_W_MIN
       ES_GET_STATE(W_MIN);
     #endif
 
     uint16_t endstop_change = live_state_local ^ old_live_state_local;
     #define ES_REPORT_CHANGE(S) if (TEST(endstop_change, S)) SERIAL_ECHOPGM("  " STRINGIFY(S) ":", TEST(live_state_local, S))
 
     if (endstop_change) {
-      #if HAS_X_MIN
+      #if USE_X_MIN
         ES_REPORT_CHANGE(X_MIN);
       #endif
-      #if HAS_X_MAX
+      #if USE_X_MAX
         ES_REPORT_CHANGE(X_MAX);
       #endif
-      #if HAS_Y_MIN
+      #if USE_Y_MIN
         ES_REPORT_CHANGE(Y_MIN);
       #endif
-      #if HAS_Y_MAX
+      #if USE_Y_MAX
         ES_REPORT_CHANGE(Y_MAX);
       #endif
-      #if HAS_Z_MIN
+      #if USE_Z_MIN
         ES_REPORT_CHANGE(Z_MIN);
       #endif
-      #if HAS_Z_MAX
+      #if USE_Z_MAX
         ES_REPORT_CHANGE(Z_MAX);
       #endif
-      #if HAS_Z_MIN_PROBE_PIN
+      #if USE_Z_MIN_PROBE
         ES_REPORT_CHANGE(Z_MIN_PROBE);
       #endif
-      #if HAS_X2_MIN
+      #if USE_X2_MIN
         ES_REPORT_CHANGE(X2_MIN);
       #endif
-      #if HAS_X2_MAX
+      #if USE_X2_MAX
         ES_REPORT_CHANGE(X2_MAX);
       #endif
-      #if HAS_Y2_MIN
+      #if USE_Y2_MIN
         ES_REPORT_CHANGE(Y2_MIN);
       #endif
-      #if HAS_Y2_MAX
+      #if USE_Y2_MAX
         ES_REPORT_CHANGE(Y2_MAX);
       #endif
-      #if HAS_Z2_MIN
+      #if USE_Z2_MIN
         ES_REPORT_CHANGE(Z2_MIN);
       #endif
-      #if HAS_Z2_MAX
+      #if USE_Z2_MAX
         ES_REPORT_CHANGE(Z2_MAX);
       #endif
-      #if HAS_Z3_MIN
+      #if USE_Z3_MIN
         ES_REPORT_CHANGE(Z3_MIN);
       #endif
-      #if HAS_Z3_MAX
+      #if USE_Z3_MAX
         ES_REPORT_CHANGE(Z3_MAX);
       #endif
-      #if HAS_Z4_MIN
+      #if USE_Z4_MIN
         ES_REPORT_CHANGE(Z4_MIN);
       #endif
-      #if HAS_Z4_MAX
+      #if USE_Z4_MAX
         ES_REPORT_CHANGE(Z4_MAX);
       #endif
-      #if HAS_I_MIN
+      #if USE_I_MIN
         ES_REPORT_CHANGE(I_MIN);
       #endif
-      #if HAS_I_MAX
+      #if USE_I_MAX
         ES_REPORT_CHANGE(I_MAX);
       #endif
-      #if HAS_J_MIN
+      #if USE_J_MIN
         ES_REPORT_CHANGE(J_MIN);
       #endif
-      #if HAS_J_MAX
+      #if USE_J_MAX
         ES_REPORT_CHANGE(J_MAX);
       #endif
-      #if HAS_K_MIN
+      #if USE_K_MIN
         ES_REPORT_CHANGE(K_MIN);
       #endif
-      #if HAS_K_MAX
+      #if USE_K_MAX
         ES_REPORT_CHANGE(K_MAX);
       #endif
-      #if HAS_U_MIN
+      #if USE_U_MIN
         ES_REPORT_CHANGE(U_MIN);
       #endif
-      #if HAS_U_MAX
+      #if USE_U_MAX
         ES_REPORT_CHANGE(U_MAX);
       #endif
-      #if HAS_V_MIN
+      #if USE_V_MIN
         ES_REPORT_CHANGE(V_MIN);
       #endif
-      #if HAS_V_MAX
+      #if USE_V_MAX
         ES_REPORT_CHANGE(V_MAX);
       #endif
-      #if HAS_W_MIN
+      #if USE_W_MIN
         ES_REPORT_CHANGE(W_MIN);
       #endif
-      #if HAS_W_MAX
+      #if USE_W_MAX
         ES_REPORT_CHANGE(W_MAX);
       #endif
 
       SERIAL_ECHOLNPGM("\n");
       hal.set_pwm_duty(pin_t(LED_PIN), local_LED_status);
       local_LED_status ^= 255;
       old_live_state_local = live_state_local;
     }
   }
 
@@ -1412,13 +1412,13 @@ void Endstops::update() {
           debug_current_on(PSTR("Z"), Z_CURRENT_HOME, saved_current_z);
         #endif
       }
 
       TERN_(IMPROVE_HOMING_RELIABILITY, planner.enable_stall_prevention(onoff));
 
       #if SENSORLESS_STALLGUARD_DELAY
         safe_delay(SENSORLESS_STALLGUARD_DELAY); // Short delay needed to settle
       #endif
 
-    #endif // XYZ
+    #endif
   }
-#endif
+#endif // USE_SENSORLESS

commit 573bc7344bcd66c08bf8cccbc90a29faa4d55030
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 29 20:20:49 2023 -0500

    üé® NORM_E_DIR => FWD_E_DIR

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index ca231f1cb2..668be5f1f4 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -859,50 +859,52 @@ void Endstops::update() {
       G38_did_trigger = true;
       #define _G38_SET(Q) | (stepper.axis_is_moving(_AXIS(Q)) << _AXIS(Q))
       #define _G38_RESP(Q) if (moving[_AXIS(Q)]) { _ENDSTOP_HIT(Q, ENDSTOP); planner.endstop_triggered(_AXIS(Q)); }
       const Flags<NUM_AXES> moving = { value_t(NUM_AXES)(0 MAIN_AXIS_MAP(_G38_SET)) };
       MAIN_AXIS_MAP(_G38_RESP);
     }
   #endif
 
   // Signal, after validation, if an endstop limit is pressed or not
 
-  if (stepper.axis_is_moving(X_AXIS)) {
-    if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
-      #if HAS_X_MIN || (X_SPI_SENSORLESS && X_HOME_TO_MIN)
-        PROCESS_ENDSTOP_X(MIN);
-        #if   CORE_DIAG(XY, Y, MIN)
-          PROCESS_CORE_ENDSTOP(Y,MIN,X,MIN);
-        #elif CORE_DIAG(XY, Y, MAX)
-          PROCESS_CORE_ENDSTOP(Y,MAX,X,MIN);
-        #elif CORE_DIAG(XZ, Z, MIN)
-          PROCESS_CORE_ENDSTOP(Z,MIN,X,MIN);
-        #elif CORE_DIAG(XZ, Z, MAX)
-          PROCESS_CORE_ENDSTOP(Z,MAX,X,MIN);
+  #if HAS_X_AXIS
+    if (stepper.axis_is_moving(X_AXIS)) {
+      if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
+        #if HAS_X_MIN || (X_SPI_SENSORLESS && X_HOME_TO_MIN)
+          PROCESS_ENDSTOP_X(MIN);
+          #if   CORE_DIAG(XY, Y, MIN)
+            PROCESS_CORE_ENDSTOP(Y,MIN,X,MIN);
+          #elif CORE_DIAG(XY, Y, MAX)
+            PROCESS_CORE_ENDSTOP(Y,MAX,X,MIN);
+          #elif CORE_DIAG(XZ, Z, MIN)
+            PROCESS_CORE_ENDSTOP(Z,MIN,X,MIN);
+          #elif CORE_DIAG(XZ, Z, MAX)
+            PROCESS_CORE_ENDSTOP(Z,MAX,X,MIN);
+          #endif
         #endif
-      #endif
-    }
-    else { // +direction
-      #if HAS_X_MAX || (X_SPI_SENSORLESS && X_HOME_TO_MAX)
-        PROCESS_ENDSTOP_X(MAX);
-        #if   CORE_DIAG(XY, Y, MIN)
-          PROCESS_CORE_ENDSTOP(Y,MIN,X,MAX);
-        #elif CORE_DIAG(XY, Y, MAX)
-          PROCESS_CORE_ENDSTOP(Y,MAX,X,MAX);
-        #elif CORE_DIAG(XZ, Z, MIN)
-          PROCESS_CORE_ENDSTOP(Z,MIN,X,MAX);
-        #elif CORE_DIAG(XZ, Z, MAX)
-          PROCESS_CORE_ENDSTOP(Z,MAX,X,MAX);
+      }
+      else { // +direction
+        #if HAS_X_MAX || (X_SPI_SENSORLESS && X_HOME_TO_MAX)
+          PROCESS_ENDSTOP_X(MAX);
+          #if   CORE_DIAG(XY, Y, MIN)
+            PROCESS_CORE_ENDSTOP(Y,MIN,X,MAX);
+          #elif CORE_DIAG(XY, Y, MAX)
+            PROCESS_CORE_ENDSTOP(Y,MAX,X,MAX);
+          #elif CORE_DIAG(XZ, Z, MIN)
+            PROCESS_CORE_ENDSTOP(Z,MIN,X,MAX);
+          #elif CORE_DIAG(XZ, Z, MAX)
+            PROCESS_CORE_ENDSTOP(Z,MAX,X,MAX);
+          #endif
         #endif
-      #endif
+      }
     }
-  }
+  #endif // HAS_X_AXIS
 
   #if HAS_Y_AXIS
     if (stepper.axis_is_moving(Y_AXIS)) {
       if (stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
         #if HAS_Y_MIN || (Y_SPI_SENSORLESS && Y_HOME_TO_MIN)
           PROCESS_ENDSTOP_Y(MIN);
           #if   CORE_DIAG(XY, X, MIN)
             PROCESS_CORE_ENDSTOP(X,MIN,Y,MIN);
           #elif CORE_DIAG(XY, X, MAX)
             PROCESS_CORE_ENDSTOP(X,MAX,Y,MIN);
@@ -921,21 +923,21 @@ void Endstops::update() {
           #elif CORE_DIAG(XY, X, MAX)
             PROCESS_CORE_ENDSTOP(X,MAX,Y,MAX);
           #elif CORE_DIAG(YZ, Z, MIN)
             PROCESS_CORE_ENDSTOP(Z,MIN,Y,MAX);
           #elif CORE_DIAG(YZ, Z, MAX)
             PROCESS_CORE_ENDSTOP(Z,MAX,Y,MAX);
           #endif
         #endif
       }
     }
-  #endif
+  #endif // HAS_Y_AXIS
 
   #if HAS_Z_AXIS
     if (stepper.axis_is_moving(Z_AXIS)) {
       if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
 
         #if HAS_Z_MIN || (Z_SPI_SENSORLESS && Z_HOME_TO_MIN)
           if ( TERN1(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN, z_probe_enabled)
             && TERN1(USES_Z_MIN_PROBE_PIN, !z_probe_enabled)
           ) PROCESS_ENDSTOP_Z(MIN);
           #if   CORE_DIAG(XZ, X, MIN)
@@ -966,111 +968,111 @@ void Endstops::update() {
           #elif CORE_DIAG(XZ, X, MAX)
             PROCESS_CORE_ENDSTOP(X,MAX,Z,MAX);
           #elif CORE_DIAG(YZ, Y, MIN)
             PROCESS_CORE_ENDSTOP(Y,MIN,Z,MAX);
           #elif CORE_DIAG(YZ, Y, MAX)
             PROCESS_CORE_ENDSTOP(Y,MAX,Z,MAX);
           #endif
         #endif
       }
     }
-  #endif
+  #endif // HAS_Z_AXIS
 
   #if HAS_I_AXIS
     if (stepper.axis_is_moving(I_AXIS)) {
       if (stepper.motor_direction(I_AXIS_HEAD)) { // -direction
         #if HAS_I_MIN || (I_SPI_SENSORLESS && I_HOME_TO_MIN)
           PROCESS_ENDSTOP(I, MIN);
         #endif
       }
       else { // +direction
         #if HAS_I_MAX || (I_SPI_SENSORLESS && I_HOME_TO_MAX)
           PROCESS_ENDSTOP(I, MAX);
         #endif
       }
     }
-  #endif
+  #endif // HAS_I_AXIS
 
   #if HAS_J_AXIS
     if (stepper.axis_is_moving(J_AXIS)) {
       if (stepper.motor_direction(J_AXIS_HEAD)) { // -direction
         #if HAS_J_MIN || (J_SPI_SENSORLESS && J_HOME_TO_MIN)
           PROCESS_ENDSTOP(J, MIN);
         #endif
       }
       else { // +direction
         #if HAS_J_MAX || (J_SPI_SENSORLESS && J_HOME_TO_MAX)
           PROCESS_ENDSTOP(J, MAX);
         #endif
       }
     }
-  #endif
+  #endif // HAS_J_AXIS
 
   #if HAS_K_AXIS
     if (stepper.axis_is_moving(K_AXIS)) {
       if (stepper.motor_direction(K_AXIS_HEAD)) { // -direction
         #if HAS_K_MIN || (K_SPI_SENSORLESS && K_HOME_TO_MIN)
           PROCESS_ENDSTOP(K, MIN);
         #endif
       }
       else { // +direction
         #if HAS_K_MAX || (K_SPI_SENSORLESS && K_HOME_TO_MAX)
           PROCESS_ENDSTOP(K, MAX);
         #endif
       }
     }
-  #endif
+  #endif // HAS_K_AXIS
 
   #if HAS_U_AXIS
     if (stepper.axis_is_moving(U_AXIS)) {
       if (stepper.motor_direction(U_AXIS_HEAD)) { // -direction
         #if HAS_U_MIN || (U_SPI_SENSORLESS && U_HOME_TO_MIN)
           PROCESS_ENDSTOP(U, MIN);
         #endif
       }
       else { // +direction
         #if HAS_U_MAX || (U_SPI_SENSORLESS && U_HOME_TO_MAX)
           PROCESS_ENDSTOP(U, MAX);
         #endif
       }
     }
-  #endif
+  #endif // HAS_U_AXIS
 
   #if HAS_V_AXIS
     if (stepper.axis_is_moving(V_AXIS)) {
       if (stepper.motor_direction(V_AXIS_HEAD)) { // -direction
         #if HAS_V_MIN || (V_SPI_SENSORLESS && V_HOME_TO_MIN)
           PROCESS_ENDSTOP(V, MIN);
         #endif
       }
       else { // +direction
         #if HAS_V_MAX || (V_SPI_SENSORLESS && V_HOME_TO_MAX)
           PROCESS_ENDSTOP(V, MAX);
         #endif
       }
     }
-  #endif
+  #endif // HAS_V_AXIS
 
   #if HAS_W_AXIS
     if (stepper.axis_is_moving(W_AXIS)) {
       if (stepper.motor_direction(W_AXIS_HEAD)) { // -direction
         #if HAS_W_MIN || (W_SPI_SENSORLESS && W_HOME_TO_MIN)
           PROCESS_ENDSTOP(W, MIN);
         #endif
       }
       else { // +direction
         #if HAS_W_MAX || (W_SPI_SENSORLESS && W_HOME_TO_MAX)
           PROCESS_ENDSTOP(W, MAX);
         #endif
       }
     }
-  #endif
+  #endif // HAS_W_AXIS
 } // Endstops::update()
 
 #if ENABLED(SPI_ENDSTOPS)
 
   // Called from idle() to read Trinamic stall states
   bool Endstops::tmc_spi_homing_check() {
     bool hit = false;
     #if X_SPI_SENSORLESS
       if (tmc_spi_homing.x && (stepperX.test_stall_status()
         #if Y_SPI_SENSORLESS && ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)

commit 467ab74523087a852ab50939d86a0ca0b78f17ad
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 26 14:56:23 2023 -0500

    üßë‚Äçüíª Simplify endstops config (#25748)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 233d848425..ca231f1cb2 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -127,21 +127,21 @@ void Endstops::init() {
   #endif
   #if HAS_Y_MAX
     _INIT_ENDSTOP(MAX,Y,);
   #endif
   #if HAS_Y2_MIN
     _INIT_ENDSTOP(MIN,Y,2);
   #endif
   #if HAS_Y2_MAX
     _INIT_ENDSTOP(MAX,Y,2);
   #endif
-  #if HAS_Z_MIN
+  #if HAS_Z_MIN_PIN
     _INIT_ENDSTOP(MIN,Z,);
   #endif
   #if HAS_Z_MAX
     _INIT_ENDSTOP(MAX,Z,);
   #endif
   #if HAS_Z2_MIN
     _INIT_ENDSTOP(MIN,Z,2);
   #endif
   #if HAS_Z2_MAX
     _INIT_ENDSTOP(MAX,Z,2);
@@ -591,21 +591,23 @@ void Endstops::update() {
     #if ENABLED(Y_DUAL_ENDSTOPS)
       #if HAS_Y2_MAX
         UPDATE_LIVE_STATE(Y2, MAX);
       #else
         COPY_LIVE_STATE(Y_MAX, Y2_MAX);
       #endif
     #endif
   #endif
 
   #if HAS_Z_MIN && NONE(Z_SPI_SENSORLESS, Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
-    UPDATE_LIVE_STATE(Z, MIN);
+    #if HAS_Z_MIN_PIN
+      UPDATE_LIVE_STATE(Z, MIN);
+    #endif
     #if ENABLED(Z_MULTI_ENDSTOPS)
       #if HAS_Z2_MIN
         UPDATE_LIVE_STATE(Z2, MIN);
       #else
         COPY_LIVE_STATE(Z_MIN, Z2_MIN);
       #endif
       #if NUM_Z_STEPPERS >= 3
         #if HAS_Z3_MIN
           UPDATE_LIVE_STATE(Z3, MIN);
         #else
@@ -1172,21 +1174,21 @@ void Endstops::update() {
     #endif
     #if HAS_X_MAX
       ES_GET_STATE(X_MAX);
     #endif
     #if HAS_Y_MIN
       ES_GET_STATE(Y_MIN);
     #endif
     #if HAS_Y_MAX
       ES_GET_STATE(Y_MAX);
     #endif
-    #if HAS_Z_MIN
+    #if HAS_Z_MIN_PIN
       ES_GET_STATE(Z_MIN);
     #endif
     #if HAS_Z_MAX
       ES_GET_STATE(Z_MAX);
     #endif
     #if HAS_Z_MIN_PROBE_PIN
       ES_GET_STATE(Z_MIN_PROBE);
     #endif
     #if HAS_X2_MIN
       ES_GET_STATE(X2_MIN);

commit d364babbc0cdb73337d86e2c4fd9170b46b7361a
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 26 14:29:21 2023 -0500

    üßë‚Äçüíª Change HAL_PATH macro for easier HAL relocation (#25743)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 25553a98ac..233d848425 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -28,21 +28,21 @@
 #include "stepper.h"
 
 #include "../sd/cardreader.h"
 #include "temperature.h"
 #include "../lcd/marlinui.h"
 
 #define DEBUG_OUT BOTH(USE_SENSORLESS, DEBUG_LEVELING_FEATURE)
 #include "../core/debug_out.h"
 
 #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-  #include HAL_PATH(../HAL, endstop_interrupts.h)
+  #include HAL_PATH(.., endstop_interrupts.h)
 #endif
 
 #if BOTH(SD_ABORT_ON_ENDSTOP_HIT, HAS_MEDIA)
   #include "printcounter.h" // for print_job_timer
 #endif
 
 #if ENABLED(BLTOUCH)
   #include "../feature/bltouch.h"
 #endif
 

commit 68f74784a3a41c643984ee62a507b25903430591
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 26 13:50:45 2023 -0500

    üé® Misc. fixes, cleanup

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 56444d1aee..25553a98ac 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -507,26 +507,26 @@ void __O2 Endstops::report_states() {
  * Read endstops to get their current states, register hits for all
  * axes moving in the direction of their endstops, and abort moves.
  */
 void Endstops::update() {
 
   #if !ENDSTOP_NOISE_THRESHOLD      // If not debouncing...
     if (!abort_enabled()) return;   // ...and not enabled, exit.
   #endif
 
   // Macros to update / copy the live_state
-  #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT_TO(live_state, _ENDSTOP(AXIS, MINMAX), (READ_ENDSTOP(_ENDSTOP_PIN(AXIS, MINMAX)) == _ENDSTOP_HIT_STATE(AXIS, MINMAX)))
+  #define UPDATE_LIVE_STATE(AXIS, MINMAX) SET_BIT_TO(live_state, _ENDSTOP(AXIS, MINMAX), (READ_ENDSTOP(_ENDSTOP_PIN(AXIS, MINMAX)) == _ENDSTOP_HIT_STATE(AXIS, MINMAX)))
   #define COPY_LIVE_STATE(SRC_BIT, DST_BIT) SET_BIT_TO(live_state, DST_BIT, TEST(live_state, SRC_BIT))
 
   #if ENABLED(G38_PROBE_TARGET)
     // For G38 moves check the probe's pin for ALL movement
-    if (G38_move) UPDATE_ENDSTOP_BIT(Z, TERN(USES_Z_MIN_PROBE_PIN, MIN_PROBE, MIN));
+    if (G38_move) UPDATE_LIVE_STATE(Z, TERN(USES_Z_MIN_PROBE_PIN, MIN_PROBE, MIN));
   #endif
 
   // With Dual X, endstops are only checked in the homing direction for the active extruder
   #define X_MIN_TEST() TERN1(DUAL_X_CARRIAGE, TERN0(X_HOME_TO_MIN, stepper.last_moved_extruder == 0) || TERN0(X2_HOME_TO_MIN, stepper.last_moved_extruder != 0))
   #define X_MAX_TEST() TERN1(DUAL_X_CARRIAGE, TERN0(X_HOME_TO_MAX, stepper.last_moved_extruder == 0) || TERN0(X2_HOME_TO_MAX, stepper.last_moved_extruder != 0))
 
   // Use HEAD for core axes, AXIS for others
   #if ANY(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY, MARKFORGED_YX)
     #define X_AXIS_HEAD X_HEAD
   #else
@@ -547,274 +547,214 @@ void Endstops::update() {
   #define J_AXIS_HEAD J_AXIS
   #define K_AXIS_HEAD K_AXIS
   #define U_AXIS_HEAD U_AXIS
   #define V_AXIS_HEAD V_AXIS
   #define W_AXIS_HEAD W_AXIS
 
   /**
    * Check and update endstops
    */
   #if HAS_X_MIN && !X_SPI_SENSORLESS
-    UPDATE_ENDSTOP_BIT(X, MIN);
+    UPDATE_LIVE_STATE(X, MIN);
     #if ENABLED(X_DUAL_ENDSTOPS)
       #if HAS_X2_MIN
-        UPDATE_ENDSTOP_BIT(X2, MIN);
+        UPDATE_LIVE_STATE(X2, MIN);
       #else
         COPY_LIVE_STATE(X_MIN, X2_MIN);
       #endif
     #endif
   #endif
 
   #if HAS_X_MAX && !X_SPI_SENSORLESS
-    UPDATE_ENDSTOP_BIT(X, MAX);
+    UPDATE_LIVE_STATE(X, MAX);
     #if ENABLED(X_DUAL_ENDSTOPS)
       #if HAS_X2_MAX
-        UPDATE_ENDSTOP_BIT(X2, MAX);
+        UPDATE_LIVE_STATE(X2, MAX);
       #else
         COPY_LIVE_STATE(X_MAX, X2_MAX);
       #endif
     #endif
   #endif
 
   #if HAS_Y_MIN && !Y_SPI_SENSORLESS
-    UPDATE_ENDSTOP_BIT(Y, MIN);
+    UPDATE_LIVE_STATE(Y, MIN);
     #if ENABLED(Y_DUAL_ENDSTOPS)
       #if HAS_Y2_MIN
-        UPDATE_ENDSTOP_BIT(Y2, MIN);
+        UPDATE_LIVE_STATE(Y2, MIN);
       #else
         COPY_LIVE_STATE(Y_MIN, Y2_MIN);
       #endif
     #endif
   #endif
 
   #if HAS_Y_MAX && !Y_SPI_SENSORLESS
-    UPDATE_ENDSTOP_BIT(Y, MAX);
+    UPDATE_LIVE_STATE(Y, MAX);
     #if ENABLED(Y_DUAL_ENDSTOPS)
       #if HAS_Y2_MAX
-        UPDATE_ENDSTOP_BIT(Y2, MAX);
+        UPDATE_LIVE_STATE(Y2, MAX);
       #else
         COPY_LIVE_STATE(Y_MAX, Y2_MAX);
       #endif
     #endif
   #endif
 
   #if HAS_Z_MIN && NONE(Z_SPI_SENSORLESS, Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
-    UPDATE_ENDSTOP_BIT(Z, MIN);
+    UPDATE_LIVE_STATE(Z, MIN);
     #if ENABLED(Z_MULTI_ENDSTOPS)
       #if HAS_Z2_MIN
-        UPDATE_ENDSTOP_BIT(Z2, MIN);
+        UPDATE_LIVE_STATE(Z2, MIN);
       #else
         COPY_LIVE_STATE(Z_MIN, Z2_MIN);
       #endif
       #if NUM_Z_STEPPERS >= 3
         #if HAS_Z3_MIN
-          UPDATE_ENDSTOP_BIT(Z3, MIN);
+          UPDATE_LIVE_STATE(Z3, MIN);
         #else
           COPY_LIVE_STATE(Z_MIN, Z3_MIN);
         #endif
       #endif
       #if NUM_Z_STEPPERS >= 4
         #if HAS_Z4_MIN
-          UPDATE_ENDSTOP_BIT(Z4, MIN);
+          UPDATE_LIVE_STATE(Z4, MIN);
         #else
           COPY_LIVE_STATE(Z_MIN, Z4_MIN);
         #endif
       #endif
     #endif
   #endif
 
   #if HAS_BED_PROBE
     // When closing the gap check the enabled probe
     if (probe_switch_activated())
-      UPDATE_ENDSTOP_BIT(Z, TERN(USES_Z_MIN_PROBE_PIN, MIN_PROBE, MIN));
+      UPDATE_LIVE_STATE(Z, TERN(USES_Z_MIN_PROBE_PIN, MIN_PROBE, MIN));
   #endif
 
   #if HAS_Z_MAX && !Z_SPI_SENSORLESS
     // Check both Z dual endstops
     #if ENABLED(Z_MULTI_ENDSTOPS)
-      UPDATE_ENDSTOP_BIT(Z, MAX);
+      UPDATE_LIVE_STATE(Z, MAX);
       #if HAS_Z2_MAX
-        UPDATE_ENDSTOP_BIT(Z2, MAX);
+        UPDATE_LIVE_STATE(Z2, MAX);
       #else
         COPY_LIVE_STATE(Z_MAX, Z2_MAX);
       #endif
       #if NUM_Z_STEPPERS >= 3
         #if HAS_Z3_MAX
-          UPDATE_ENDSTOP_BIT(Z3, MAX);
+          UPDATE_LIVE_STATE(Z3, MAX);
         #else
           COPY_LIVE_STATE(Z_MAX, Z3_MAX);
         #endif
       #endif
       #if NUM_Z_STEPPERS >= 4
         #if HAS_Z4_MAX
-          UPDATE_ENDSTOP_BIT(Z4, MAX);
+          UPDATE_LIVE_STATE(Z4, MAX);
         #else
           COPY_LIVE_STATE(Z_MAX, Z4_MAX);
         #endif
       #endif
     #elif TERN1(USES_Z_MIN_PROBE_PIN, Z_MAX_PIN != Z_MIN_PROBE_PIN)
       // If this pin isn't the bed probe it's the Z endstop
-      UPDATE_ENDSTOP_BIT(Z, MAX);
+      UPDATE_LIVE_STATE(Z, MAX);
     #endif
   #endif
 
   #if HAS_I_MIN && !I_SPI_SENSORLESS
     #if ENABLED(I_DUAL_ENDSTOPS)
-      UPDATE_ENDSTOP_BIT(I, MIN);
-      #if HAS_I2_MIN
-        UPDATE_ENDSTOP_BIT(I2, MAX);
-      #else
-        COPY_LIVE_STATE(I_MIN, I2_MIN);
-      #endif
+      UPDATE_LIVE_STATE(I, MIN);
     #else
-      UPDATE_ENDSTOP_BIT(I, MIN);
+      UPDATE_LIVE_STATE(I, MIN);
     #endif
   #endif
 
   #if HAS_I_MAX && !I_SPI_SENSORLESS
     #if ENABLED(I_DUAL_ENDSTOPS)
-      UPDATE_ENDSTOP_BIT(I, MAX);
-      #if HAS_I2_MAX
-        UPDATE_ENDSTOP_BIT(I2, MAX);
-      #else
-        COPY_LIVE_STATE(I_MAX, I2_MAX);
-      #endif
+      UPDATE_LIVE_STATE(I, MAX);
     #else
-      UPDATE_ENDSTOP_BIT(I, MAX);
+      UPDATE_LIVE_STATE(I, MAX);
     #endif
   #endif
 
   #if HAS_J_MIN && !J_SPI_SENSORLESS
     #if ENABLED(J_DUAL_ENDSTOPS)
-      UPDATE_ENDSTOP_BIT(J, MIN);
-      #if HAS_J2_MIN
-        UPDATE_ENDSTOP_BIT(J2, MIN);
-      #else
-        COPY_LIVE_STATE(J_MIN, J2_MIN);
-      #endif
+      UPDATE_LIVE_STATE(J, MIN);
     #else
-      UPDATE_ENDSTOP_BIT(J, MIN);
+      UPDATE_LIVE_STATE(J, MIN);
     #endif
   #endif
 
   #if HAS_J_MAX && !J_SPI_SENSORLESS
     #if ENABLED(J_DUAL_ENDSTOPS)
-      UPDATE_ENDSTOP_BIT(J, MAX);
-      #if HAS_J2_MAX
-        UPDATE_ENDSTOP_BIT(J2, MAX);
-      #else
-        COPY_LIVE_STATE(J_MAX, J2_MAX);
-      #endif
+      UPDATE_LIVE_STATE(J, MAX);
     #else
-      UPDATE_ENDSTOP_BIT(J, MAX);
+      UPDATE_LIVE_STATE(J, MAX);
     #endif
   #endif
 
   #if HAS_K_MIN && !K_SPI_SENSORLESS
     #if ENABLED(K_DUAL_ENDSTOPS)
-      UPDATE_ENDSTOP_BIT(K, MIN);
-      #if HAS_K2_MIN
-        UPDATE_ENDSTOP_BIT(K2, MIN);
-      #else
-        COPY_LIVE_STATE(K_MIN, K2_MIN);
-      #endif
+      UPDATE_LIVE_STATE(K, MIN);
     #else
-      UPDATE_ENDSTOP_BIT(K, MIN);
+      UPDATE_LIVE_STATE(K, MIN);
     #endif
   #endif
 
   #if HAS_K_MAX && !K_SPI_SENSORLESS
     #if ENABLED(K_DUAL_ENDSTOPS)
-      UPDATE_ENDSTOP_BIT(K, MAX);
-      #if HAS_K2_MAX
-        UPDATE_ENDSTOP_BIT(K2, MAX);
-      #else
-        COPY_LIVE_STATE(K_MAX, K2_MAX);
-      #endif
+      UPDATE_LIVE_STATE(K, MAX);
     #else
-      UPDATE_ENDSTOP_BIT(K, MAX);
+      UPDATE_LIVE_STATE(K, MAX);
     #endif
   #endif
 
   #if HAS_U_MIN && !U_SPI_SENSORLESS
     #if ENABLED(U_DUAL_ENDSTOPS)
-      UPDATE_ENDSTOP_BIT(U, MIN);
-      #if HAS_U2_MIN
-        UPDATE_ENDSTOP_BIT(U2, MIN);
-      #else
-        COPY_LIVE_STATE(U_MIN, U2_MIN);
-      #endif
+      UPDATE_LIVE_STATE(U, MIN);
     #else
-      UPDATE_ENDSTOP_BIT(U, MIN);
+      UPDATE_LIVE_STATE(U, MIN);
     #endif
   #endif
 
   #if HAS_U_MAX && !U_SPI_SENSORLESS
     #if ENABLED(U_DUAL_ENDSTOPS)
-      UPDATE_ENDSTOP_BIT(U, MAX);
-      #if HAS_U2_MAX
-        UPDATE_ENDSTOP_BIT(U2, MAX);
-      #else
-        COPY_LIVE_STATE(U_MAX, U2_MAX);
-      #endif
+      UPDATE_LIVE_STATE(U, MAX);
     #else
-      UPDATE_ENDSTOP_BIT(U, MAX);
+      UPDATE_LIVE_STATE(U, MAX);
     #endif
   #endif
 
   #if HAS_V_MIN && !V_SPI_SENSORLESS
     #if ENABLED(V_DUAL_ENDSTOPS)
-      UPDATE_ENDSTOP_BIT(V, MIN);
-      #if HAS_V2_MIN
-        UPDATE_ENDSTOP_BIT(V2, MIN);
-      #else
-        COPY_LIVE_STATE(V_MIN, V2_MIN);
-      #endif
+      UPDATE_LIVE_STATE(V, MIN);
     #else
-      UPDATE_ENDSTOP_BIT(V, MIN);
+      UPDATE_LIVE_STATE(V, MIN);
     #endif
   #endif
   #if HAS_V_MAX && !V_SPI_SENSORLESS
     #if ENABLED(O_DUAL_ENDSTOPS)
-      UPDATE_ENDSTOP_BIT(V, MAX);
-      #if HAS_V2_MAX
-        UPDATE_ENDSTOP_BIT(V2, MAX);
-      #else
-        COPY_LIVE_STATE(V_MAX, V2_MAX);
-      #endif
+      UPDATE_LIVE_STATE(V, MAX);
     #else
-      UPDATE_ENDSTOP_BIT(V, MAX);
+      UPDATE_LIVE_STATE(V, MAX);
     #endif
   #endif
 
   #if HAS_W_MIN && !W_SPI_SENSORLESS
     #if ENABLED(W_DUAL_ENDSTOPS)
-      UPDATE_ENDSTOP_BIT(W, MIN);
-      #if HAS_W2_MIN
-        UPDATE_ENDSTOP_BIT(W2, MIN);
-      #else
-        COPY_LIVE_STATE(W_MIN, W2_MIN);
-      #endif
+      UPDATE_LIVE_STATE(W, MIN);
     #else
-      UPDATE_ENDSTOP_BIT(W, MIN);
+      UPDATE_LIVE_STATE(W, MIN);
     #endif
   #endif
   #if HAS_W_MAX && !W_SPI_SENSORLESS
     #if ENABLED(W_DUAL_ENDSTOPS)
-      UPDATE_ENDSTOP_BIT(W, MAX);
-      #if HAS_W2_MAX
-        UPDATE_ENDSTOP_BIT(W2, MAX);
-      #else
-        COPY_LIVE_STATE(W_MAX, W2_MAX);
-      #endif
+      UPDATE_LIVE_STATE(W, MAX);
     #else
-      UPDATE_ENDSTOP_BIT(W, MAX);
+      UPDATE_LIVE_STATE(W, MAX);
     #endif
   #endif
 
   #if ENDSTOP_NOISE_THRESHOLD
 
     /**
      * Filtering out noise on endstops requires a delayed decision. Let's assume, due to noise,
      * that 50% of endstop signal samples are good and 50% are bad (assuming normal distribution
      * of random noise). Then the first sample has a 50% chance to be good or bad. The 2nd sample
      * also has a 50% chance to be good or bad. The chances of 2 samples both being bad becomes

commit 5664c02d077e028f84a24efd96c2eebe97ce8763
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 22 22:43:09 2023 -0500

    üßë‚Äçüíª Generalize SDSUPPORT as HAS_MEDIA
    
    In preparation for single- and multi-volume refactoring.

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 02af062eca..56444d1aee 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -31,21 +31,21 @@
 #include "temperature.h"
 #include "../lcd/marlinui.h"
 
 #define DEBUG_OUT BOTH(USE_SENSORLESS, DEBUG_LEVELING_FEATURE)
 #include "../core/debug_out.h"
 
 #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
   #include HAL_PATH(../HAL, endstop_interrupts.h)
 #endif
 
-#if BOTH(SD_ABORT_ON_ENDSTOP_HIT, SDSUPPORT)
+#if BOTH(SD_ABORT_ON_ENDSTOP_HIT, HAS_MEDIA)
   #include "printcounter.h" // for print_job_timer
 #endif
 
 #if ENABLED(BLTOUCH)
   #include "../feature/bltouch.h"
 #endif
 
 #if ENABLED(JOYSTICK)
   #include "../feature/joystick.h"
 #endif
@@ -345,21 +345,21 @@ void Endstops::event_handler() {
     SERIAL_EOL();
 
     TERN_(HAS_STATUS_MESSAGE,
       ui.status_printf(0,
         F(S_FMT GANG_N_1(NUM_AXES, " %c") " %c"),
         GET_TEXT(MSG_LCD_ENDSTOPS),
         NUM_AXIS_LIST(chrX, chrY, chrZ, chrI, chrJ, chrK, chrU, chrV, chrW), chrP
       )
     );
 
-    #if BOTH(SD_ABORT_ON_ENDSTOP_HIT, SDSUPPORT)
+    #if BOTH(SD_ABORT_ON_ENDSTOP_HIT, HAS_MEDIA)
       if (planner.abort_on_endstop_hit) {
         card.abortFilePrintNow();
         quickstop_stepper();
         thermalManager.disable_all_heaters();
         #ifdef SD_ABORT_ON_ENDSTOP_HIT_GCODE
           queue.clear();
           queue.inject(F(SD_ABORT_ON_ENDSTOP_HIT_GCODE));
         #endif
         print_job_timer.stop();
       }

commit de7726ca019461d029f9fe2a14a85b8ecf8723fe
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Wed Apr 19 17:21:53 2023 -0700

    üö∏ Permit G38 with Core (#25713)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index ccad00062e..02af062eca 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -510,22 +510,21 @@ void __O2 Endstops::report_states() {
 void Endstops::update() {
 
   #if !ENDSTOP_NOISE_THRESHOLD      // If not debouncing...
     if (!abort_enabled()) return;   // ...and not enabled, exit.
   #endif
 
   // Macros to update / copy the live_state
   #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT_TO(live_state, _ENDSTOP(AXIS, MINMAX), (READ_ENDSTOP(_ENDSTOP_PIN(AXIS, MINMAX)) == _ENDSTOP_HIT_STATE(AXIS, MINMAX)))
   #define COPY_LIVE_STATE(SRC_BIT, DST_BIT) SET_BIT_TO(live_state, DST_BIT, TEST(live_state, SRC_BIT))
 
-  #if ENABLED(G38_PROBE_TARGET) && NONE(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY, MARKFORGED_YX)
-    #define HAS_G38_PROBE 1
+  #if ENABLED(G38_PROBE_TARGET)
     // For G38 moves check the probe's pin for ALL movement
     if (G38_move) UPDATE_ENDSTOP_BIT(Z, TERN(USES_Z_MIN_PROBE_PIN, MIN_PROBE, MIN));
   #endif
 
   // With Dual X, endstops are only checked in the homing direction for the active extruder
   #define X_MIN_TEST() TERN1(DUAL_X_CARRIAGE, TERN0(X_HOME_TO_MIN, stepper.last_moved_extruder == 0) || TERN0(X2_HOME_TO_MIN, stepper.last_moved_extruder != 0))
   #define X_MAX_TEST() TERN1(DUAL_X_CARRIAGE, TERN0(X_HOME_TO_MAX, stepper.last_moved_extruder == 0) || TERN0(X2_HOME_TO_MAX, stepper.last_moved_extruder != 0))
 
   // Use HEAD for core axes, AXIS for others
   #if ANY(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY, MARKFORGED_YX)
@@ -905,23 +904,23 @@ void Endstops::update() {
   #if DISABLED(Z_MULTI_ENDSTOPS)
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_ENDSTOP(Z, MINMAX)
   #elif NUM_Z_STEPPERS == 4
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_QUAD_ENDSTOP(Z, MINMAX)
   #elif NUM_Z_STEPPERS == 3
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_TRIPLE_ENDSTOP(Z, MINMAX)
   #else
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_DUAL_ENDSTOP(Z, MINMAX)
   #endif
 
-  #if HAS_G38_PROBE // TODO (DerAndere): Add support for HAS_I_AXIS
+  #if ENABLED(G38_PROBE_TARGET)
     // For G38 moves check the probe's pin for ALL movement
-    if (G38_move && TEST_ENDSTOP(_ENDSTOP(Z, TERN(USES_Z_MIN_PROBE_PIN, MIN_PROBE, MIN))) == TERN1(G38_PROBE_AWAY, (G38_move < 4))) {
+    if (G38_move && TEST_ENDSTOP(Z_MIN_PROBE) == TERN1(G38_PROBE_AWAY, (G38_move < 4))) {
       G38_did_trigger = true;
       #define _G38_SET(Q) | (stepper.axis_is_moving(_AXIS(Q)) << _AXIS(Q))
       #define _G38_RESP(Q) if (moving[_AXIS(Q)]) { _ENDSTOP_HIT(Q, ENDSTOP); planner.endstop_triggered(_AXIS(Q)); }
       const Flags<NUM_AXES> moving = { value_t(NUM_AXES)(0 MAIN_AXIS_MAP(_G38_SET)) };
       MAIN_AXIS_MAP(_G38_RESP);
     }
   #endif
 
   // Signal, after validation, if an endstop limit is pressed or not
 

commit fad1dcefbcd300128b474783f1183ea8a6d18496
Author: Jay Robson <45777442+jsrobson10@users.noreply.github.com>
Date:   Thu Apr 20 06:58:42 2023 +1000

    üêõ Fix G38 with Z, support 9 axes (#25691)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 6719925f15..ccad00062e 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -906,31 +906,27 @@ void Endstops::update() {
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_ENDSTOP(Z, MINMAX)
   #elif NUM_Z_STEPPERS == 4
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_QUAD_ENDSTOP(Z, MINMAX)
   #elif NUM_Z_STEPPERS == 3
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_TRIPLE_ENDSTOP(Z, MINMAX)
   #else
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_DUAL_ENDSTOP(Z, MINMAX)
   #endif
 
   #if HAS_G38_PROBE // TODO (DerAndere): Add support for HAS_I_AXIS
-    #define _G38_OPEN_STATE TERN(G38_PROBE_AWAY, (G38_move >= 4), LOW)
     // For G38 moves check the probe's pin for ALL movement
-    if (G38_move && TEST_ENDSTOP(_ENDSTOP(Z, TERN(USES_Z_MIN_PROBE_PIN, MIN_PROBE, MIN))) != _G38_OPEN_STATE) {
-             if (stepper.axis_is_moving(X_AXIS)) { _ENDSTOP_HIT(X, TERN(X_HOME_TO_MIN, MIN, MAX)); planner.endstop_triggered(X_AXIS); }
-      #if HAS_Y_AXIS
-        else if (stepper.axis_is_moving(Y_AXIS)) { _ENDSTOP_HIT(Y, TERN(Y_HOME_TO_MIN, MIN, MAX)); planner.endstop_triggered(Y_AXIS); }
-      #endif
-      #if HAS_Z_AXIS
-        else if (stepper.axis_is_moving(Z_AXIS)) { _ENDSTOP_HIT(Z, TERN(Z_HOME_TO_MIN, MIN, MAX)); planner.endstop_triggered(Z_AXIS); }
-      #endif
+    if (G38_move && TEST_ENDSTOP(_ENDSTOP(Z, TERN(USES_Z_MIN_PROBE_PIN, MIN_PROBE, MIN))) == TERN1(G38_PROBE_AWAY, (G38_move < 4))) {
       G38_did_trigger = true;
+      #define _G38_SET(Q) | (stepper.axis_is_moving(_AXIS(Q)) << _AXIS(Q))
+      #define _G38_RESP(Q) if (moving[_AXIS(Q)]) { _ENDSTOP_HIT(Q, ENDSTOP); planner.endstop_triggered(_AXIS(Q)); }
+      const Flags<NUM_AXES> moving = { value_t(NUM_AXES)(0 MAIN_AXIS_MAP(_G38_SET)) };
+      MAIN_AXIS_MAP(_G38_RESP);
     }
   #endif
 
   // Signal, after validation, if an endstop limit is pressed or not
 
   if (stepper.axis_is_moving(X_AXIS)) {
     if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
       #if HAS_X_MIN || (X_SPI_SENSORLESS && X_HOME_TO_MIN)
         PROCESS_ENDSTOP_X(MIN);
         #if   CORE_DIAG(XY, Y, MIN)

commit de0cd660705668f2e9f1e0cb8fff80b40be0f4e6
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Mar 28 05:39:35 2023 -0500

    üé® Misc. cleanup

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 9d73210025..6719925f15 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -1136,33 +1136,33 @@ void Endstops::update() {
     bool hit = false;
     #if X_SPI_SENSORLESS
       if (tmc_spi_homing.x && (stepperX.test_stall_status()
         #if Y_SPI_SENSORLESS && ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
           || stepperY.test_stall_status()
         #elif Z_SPI_SENSORLESS && CORE_IS_XZ
           || stepperZ.test_stall_status()
         #endif
       )) { SBI(live_state, X_ENDSTOP); hit = true; }
       #if ENABLED(X_DUAL_ENDSTOPS)
-	      if (tmc_spi_homing.x && stepperX2.test_stall_status()) { SBI(live_state, X2_ENDSTOP); hit = true; }
+        if (tmc_spi_homing.x && stepperX2.test_stall_status()) { SBI(live_state, X2_ENDSTOP); hit = true; }
       #endif
     #endif
     #if Y_SPI_SENSORLESS
       if (tmc_spi_homing.y && (stepperY.test_stall_status()
         #if X_SPI_SENSORLESS && ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
           || stepperX.test_stall_status()
         #elif Z_SPI_SENSORLESS && CORE_IS_YZ
           || stepperZ.test_stall_status()
         #endif
       )) { SBI(live_state, Y_ENDSTOP); hit = true; }
       #if ENABLED(Y_DUAL_ENDSTOPS)
-	      if (tmc_spi_homing.y && stepperY2.test_stall_status()) { SBI(live_state, Y2_ENDSTOP); hit = true; }
+        if (tmc_spi_homing.y && stepperY2.test_stall_status()) { SBI(live_state, Y2_ENDSTOP); hit = true; }
       #endif
     #endif
     #if Z_SPI_SENSORLESS
       if (tmc_spi_homing.z && (stepperZ.test_stall_status()
         #if X_SPI_SENSORLESS && CORE_IS_XZ
           || stepperX.test_stall_status()
         #elif Y_SPI_SENSORLESS && CORE_IS_YZ
           || stepperY.test_stall_status()
         #endif
       )) { SBI(live_state, Z_ENDSTOP); hit = true; }

commit ea5d7e2eee641122ddf56705f6c9060d84a20df3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Mar 26 04:00:12 2023 -0500

    üîß Refactor endstop state config (#25574)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index ef5f5d06e1..9d73210025 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -102,298 +102,104 @@ Endstops::endstop_mask_t Endstops::live_state = 0;
 #if ENABLED(IMPROVE_HOMING_RELIABILITY)
   millis_t sg_guard_period; // = 0
 #endif
 
 /**
  * Class and Instance Methods
  */
 
 void Endstops::init() {
 
+  #define _INIT_ENDSTOP(T,A,N) TERN(ENDSTOPPULLUP_##A##T, SET_INPUT_PULLUP, TERN(ENDSTOPPULLDOWN_##A##T, SET_INPUT_PULLDOWN, SET_INPUT))(A##N##_##T##_PIN)
   #if HAS_X_MIN
-    #if ENABLED(ENDSTOPPULLUP_XMIN)
-      SET_INPUT_PULLUP(X_MIN_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_XMIN)
-      SET_INPUT_PULLDOWN(X_MIN_PIN);
-    #else
-      SET_INPUT(X_MIN_PIN);
-    #endif
-  #endif
-
-  #if HAS_X2_MIN
-    #if ENABLED(ENDSTOPPULLUP_XMIN)
-      SET_INPUT_PULLUP(X2_MIN_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_XMIN)
-      SET_INPUT_PULLDOWN(X2_MIN_PIN);
-    #else
-      SET_INPUT(X2_MIN_PIN);
-    #endif
-  #endif
-
-  #if HAS_Y_MIN
-    #if ENABLED(ENDSTOPPULLUP_YMIN)
-      SET_INPUT_PULLUP(Y_MIN_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_YMIN)
-      SET_INPUT_PULLDOWN(Y_MIN_PIN);
-    #else
-      SET_INPUT(Y_MIN_PIN);
-    #endif
-  #endif
-
-  #if HAS_Y2_MIN
-    #if ENABLED(ENDSTOPPULLUP_YMIN)
-      SET_INPUT_PULLUP(Y2_MIN_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_YMIN)
-      SET_INPUT_PULLDOWN(Y2_MIN_PIN);
-    #else
-      SET_INPUT(Y2_MIN_PIN);
-    #endif
-  #endif
-
-  #if HAS_Z_MIN
-    #if ENABLED(ENDSTOPPULLUP_ZMIN)
-      SET_INPUT_PULLUP(Z_MIN_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_ZMIN)
-      SET_INPUT_PULLDOWN(Z_MIN_PIN);
-    #else
-      SET_INPUT(Z_MIN_PIN);
-    #endif
-  #endif
-
-  #if HAS_Z2_MIN
-    #if ENABLED(ENDSTOPPULLUP_ZMIN)
-      SET_INPUT_PULLUP(Z2_MIN_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_ZMIN)
-      SET_INPUT_PULLDOWN(Z2_MIN_PIN);
-    #else
-      SET_INPUT(Z2_MIN_PIN);
-    #endif
-  #endif
-
-  #if HAS_Z3_MIN
-    #if ENABLED(ENDSTOPPULLUP_ZMIN)
-      SET_INPUT_PULLUP(Z3_MIN_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_ZMIN)
-      SET_INPUT_PULLDOWN(Z3_MIN_PIN);
-    #else
-      SET_INPUT(Z3_MIN_PIN);
-    #endif
-  #endif
-
-  #if HAS_Z4_MIN
-    #if ENABLED(ENDSTOPPULLUP_ZMIN)
-      SET_INPUT_PULLUP(Z4_MIN_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_ZMIN)
-      SET_INPUT_PULLDOWN(Z4_MIN_PIN);
-    #else
-      SET_INPUT(Z4_MIN_PIN);
-    #endif
+    _INIT_ENDSTOP(MIN,X,);
   #endif
-
   #if HAS_X_MAX
-    #if ENABLED(ENDSTOPPULLUP_XMAX)
-      SET_INPUT_PULLUP(X_MAX_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_XMAX)
-      SET_INPUT_PULLDOWN(X_MAX_PIN);
-    #else
-      SET_INPUT(X_MAX_PIN);
-    #endif
+    _INIT_ENDSTOP(MAX,X,);
+  #endif
+  #if HAS_X2_MIN
+    _INIT_ENDSTOP(MIN,X,2);
   #endif
-
   #if HAS_X2_MAX
-    #if ENABLED(ENDSTOPPULLUP_XMAX)
-      SET_INPUT_PULLUP(X2_MAX_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_XMAX)
-      SET_INPUT_PULLDOWN(X2_MAX_PIN);
-    #else
-      SET_INPUT(X2_MAX_PIN);
-    #endif
+    _INIT_ENDSTOP(MAX,X,2);
+  #endif
+  #if HAS_Y_MIN
+    _INIT_ENDSTOP(MIN,Y,);
   #endif
-
   #if HAS_Y_MAX
-    #if ENABLED(ENDSTOPPULLUP_YMAX)
-      SET_INPUT_PULLUP(Y_MAX_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_YMAX)
-      SET_INPUT_PULLDOWN(Y_MAX_PIN);
-    #else
-      SET_INPUT(Y_MAX_PIN);
-    #endif
+    _INIT_ENDSTOP(MAX,Y,);
+  #endif
+  #if HAS_Y2_MIN
+    _INIT_ENDSTOP(MIN,Y,2);
   #endif
-
   #if HAS_Y2_MAX
-    #if ENABLED(ENDSTOPPULLUP_YMAX)
-      SET_INPUT_PULLUP(Y2_MAX_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_YMAX)
-      SET_INPUT_PULLDOWN(Y2_MAX_PIN);
-    #else
-      SET_INPUT(Y2_MAX_PIN);
-    #endif
+    _INIT_ENDSTOP(MAX,Y,2);
+  #endif
+  #if HAS_Z_MIN
+    _INIT_ENDSTOP(MIN,Z,);
   #endif
-
   #if HAS_Z_MAX
-    #if ENABLED(ENDSTOPPULLUP_ZMAX)
-      SET_INPUT_PULLUP(Z_MAX_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_ZMAX)
-      SET_INPUT_PULLDOWN(Z_MAX_PIN);
-    #else
-      SET_INPUT(Z_MAX_PIN);
-    #endif
+    _INIT_ENDSTOP(MAX,Z,);
+  #endif
+  #if HAS_Z2_MIN
+    _INIT_ENDSTOP(MIN,Z,2);
   #endif
-
   #if HAS_Z2_MAX
-    #if ENABLED(ENDSTOPPULLUP_ZMAX)
-      SET_INPUT_PULLUP(Z2_MAX_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_ZMAX)
-      SET_INPUT_PULLDOWN(Z2_MAX_PIN);
-    #else
-      SET_INPUT(Z2_MAX_PIN);
-    #endif
+    _INIT_ENDSTOP(MAX,Z,2);
+  #endif
+  #if HAS_Z3_MIN
+    _INIT_ENDSTOP(MIN,Z,3);
   #endif
-
   #if HAS_Z3_MAX
-    #if ENABLED(ENDSTOPPULLUP_ZMAX)
-      SET_INPUT_PULLUP(Z3_MAX_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_ZMAX)
-      SET_INPUT_PULLDOWN(Z3_MAX_PIN);
-    #else
-      SET_INPUT(Z3_MAX_PIN);
-    #endif
+    _INIT_ENDSTOP(MAX,Z,3);
+  #endif
+  #if HAS_Z4_MIN
+    _INIT_ENDSTOP(MIN,Z,4);
   #endif
-
   #if HAS_Z4_MAX
-    #if ENABLED(ENDSTOPPULLUP_ZMAX)
-      SET_INPUT_PULLUP(Z4_MAX_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_ZMAX)
-      SET_INPUT_PULLDOWN(Z4_MAX_PIN);
-    #else
-      SET_INPUT(Z4_MAX_PIN);
-    #endif
+    _INIT_ENDSTOP(MAX,Z,4);
   #endif
-
   #if HAS_I_MIN
-    #if ENABLED(ENDSTOPPULLUP_IMIN)
-      SET_INPUT_PULLUP(I_MIN_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_IMIN)
-      SET_INPUT_PULLDOWN(I_MIN_PIN);
-    #else
-      SET_INPUT(I_MIN_PIN);
-    #endif
+    _INIT_ENDSTOP(MIN,I,);
   #endif
-
   #if HAS_I_MAX
-    #if ENABLED(ENDSTOPPULLUP_IMAX)
-      SET_INPUT_PULLUP(I_MAX_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_IMAX)
-      SET_INPUT_PULLDOWN(I_MAX_PIN);
-    #else
-      SET_INPUT(I_MAX_PIN);
-    #endif
+    _INIT_ENDSTOP(MAX,I,);
   #endif
-
   #if HAS_J_MIN
-    #if ENABLED(ENDSTOPPULLUP_JMIN)
-      SET_INPUT_PULLUP(J_MIN_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_IMIN)
-      SET_INPUT_PULLDOWN(J_MIN_PIN);
-    #else
-      SET_INPUT(J_MIN_PIN);
-    #endif
+    _INIT_ENDSTOP(MIN,J,);
   #endif
-
   #if HAS_J_MAX
-    #if ENABLED(ENDSTOPPULLUP_JMAX)
-      SET_INPUT_PULLUP(J_MAX_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_JMAX)
-      SET_INPUT_PULLDOWN(J_MAX_PIN);
-    #else
-      SET_INPUT(J_MAX_PIN);
-    #endif
+    _INIT_ENDSTOP(MAX,J,);
   #endif
-
   #if HAS_K_MIN
-    #if ENABLED(ENDSTOPPULLUP_KMIN)
-      SET_INPUT_PULLUP(K_MIN_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_KMIN)
-      SET_INPUT_PULLDOWN(K_MIN_PIN);
-    #else
-      SET_INPUT(K_MIN_PIN);
-    #endif
+    _INIT_ENDSTOP(MIN,K,);
   #endif
-
   #if HAS_K_MAX
-    #if ENABLED(ENDSTOPPULLUP_KMAX)
-      SET_INPUT_PULLUP(K_MAX_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_KMIN)
-      SET_INPUT_PULLDOWN(K_MAX_PIN);
-    #else
-      SET_INPUT(K_MAX_PIN);
-    #endif
+    _INIT_ENDSTOP(MAX,K,);
   #endif
-
   #if HAS_U_MIN
-    #if ENABLED(ENDSTOPPULLUP_UMIN)
-      SET_INPUT_PULLUP(U_MIN_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_UMIN)
-      SET_INPUT_PULLDOWN(U_MIN_PIN);
-    #else
-      SET_INPUT(U_MIN_PIN);
-    #endif
+    _INIT_ENDSTOP(MIN,U,);
   #endif
-
   #if HAS_U_MAX
-    #if ENABLED(ENDSTOPPULLUP_UMAX)
-      SET_INPUT_PULLUP(U_MAX_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_UMIN)
-      SET_INPUT_PULLDOWN(U_MAX_PIN);
-    #else
-      SET_INPUT(U_MAX_PIN);
-    #endif
+    _INIT_ENDSTOP(MAX,U,);
   #endif
-
   #if HAS_V_MIN
-    #if ENABLED(ENDSTOPPULLUP_VMIN)
-      SET_INPUT_PULLUP(V_MIN_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_VMIN)
-      SET_INPUT_PULLDOWN(V_MIN_PIN);
-    #else
-      SET_INPUT(V_MIN_PIN);
-    #endif
+    _INIT_ENDSTOP(MIN,V,);
   #endif
-
   #if HAS_V_MAX
-    #if ENABLED(ENDSTOPPULLUP_VMAX)
-      SET_INPUT_PULLUP(V_MAX_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_VMIN)
-      SET_INPUT_PULLDOWN(V_MAX_PIN);
-    #else
-      SET_INPUT(V_MAX_PIN);
-    #endif
+    _INIT_ENDSTOP(MAX,V,);
   #endif
-
   #if HAS_W_MIN
-    #if ENABLED(ENDSTOPPULLUP_WMIN)
-      SET_INPUT_PULLUP(W_MIN_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_WMIN)
-      SET_INPUT_PULLDOWN(W_MIN_PIN);
-    #else
-      SET_INPUT(W_MIN_PIN);
-    #endif
+    _INIT_ENDSTOP(MIN,W,);
   #endif
-
   #if HAS_W_MAX
-    #if ENABLED(ENDSTOPPULLUP_WMAX)
-      SET_INPUT_PULLUP(W_MAX_PIN);
-    #elif ENABLED(ENDSTOPPULLDOWN_WMIN)
-      SET_INPUT_PULLDOWN(W_MAX_PIN);
-    #else
-      SET_INPUT(W_MAX_PIN);
-    #endif
+    _INIT_ENDSTOP(MAX,W,);
   #endif
 
   #if PIN_EXISTS(CALIBRATION)
     #if ENABLED(CALIBRATION_PIN_PULLUP)
       SET_INPUT_PULLUP(CALIBRATION_PIN);
     #elif ENABLED(CALIBRATION_PIN_PULLDOWN)
       SET_INPUT_PULLDOWN(CALIBRATION_PIN);
     #else
       SET_INPUT(CALIBRATION_PIN);
     #endif
@@ -570,21 +376,21 @@ static void print_es_state(const bool is_hit, FSTR_P const flabel=nullptr) {
   if (flabel) SERIAL_ECHOF(flabel);
   SERIAL_ECHOPGM(": ");
   SERIAL_ECHOLNF(is_hit ? F(STR_ENDSTOP_HIT) : F(STR_ENDSTOP_OPEN));
 }
 
 #pragma GCC diagnostic pop
 
 void __O2 Endstops::report_states() {
   TERN_(BLTOUCH, bltouch._set_SW_mode());
   SERIAL_ECHOLNPGM(STR_M119_REPORT);
-  #define ES_REPORT(S) print_es_state(READ_ENDSTOP(S##_PIN) != S##_ENDSTOP_INVERTING, F(STR_##S))
+  #define ES_REPORT(S) print_es_state(READ_ENDSTOP(S##_PIN) == S##_ENDSTOP_HIT_STATE, F(STR_##S))
   #if HAS_X_MIN
     ES_REPORT(X_MIN);
   #endif
   #if HAS_X2_MIN
     ES_REPORT(X2_MIN);
   #endif
   #if HAS_X_MAX
     ES_REPORT(X_MAX);
   #endif
   #if HAS_X2_MAX
@@ -686,36 +492,36 @@ void __O2 Endstops::report_states() {
     print_es_state(READ(FIL_RUNOUT1_PIN) != FIL_RUNOUT1_STATE, F(STR_FILAMENT));
   #endif
 
   TERN_(BLTOUCH, bltouch._reset_SW_mode());
   TERN_(JOYSTICK_DEBUG, joystick.report());
 
 } // Endstops::report_states
 
 #define __ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
 #define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN
-#define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_INVERTING
+#define _ENDSTOP_HIT_STATE(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_HIT_STATE
 #define _ENDSTOP(AXIS, MINMAX) __ENDSTOP(AXIS, MINMAX)
 
 /**
  * Called from interrupt context by the Endstop ISR or Stepper ISR!
  * Read endstops to get their current states, register hits for all
  * axes moving in the direction of their endstops, and abort moves.
  */
 void Endstops::update() {
 
   #if !ENDSTOP_NOISE_THRESHOLD      // If not debouncing...
     if (!abort_enabled()) return;   // ...and not enabled, exit.
   #endif
 
   // Macros to update / copy the live_state
-  #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT_TO(live_state, _ENDSTOP(AXIS, MINMAX), (READ_ENDSTOP(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
+  #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT_TO(live_state, _ENDSTOP(AXIS, MINMAX), (READ_ENDSTOP(_ENDSTOP_PIN(AXIS, MINMAX)) == _ENDSTOP_HIT_STATE(AXIS, MINMAX)))
   #define COPY_LIVE_STATE(SRC_BIT, DST_BIT) SET_BIT_TO(live_state, DST_BIT, TEST(live_state, SRC_BIT))
 
   #if ENABLED(G38_PROBE_TARGET) && NONE(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY, MARKFORGED_YX)
     #define HAS_G38_PROBE 1
     // For G38 moves check the probe's pin for ALL movement
     if (G38_move) UPDATE_ENDSTOP_BIT(Z, TERN(USES_Z_MIN_PROBE_PIN, MIN_PROBE, MIN));
   #endif
 
   // With Dual X, endstops are only checked in the homing direction for the active extruder
   #define X_MIN_TEST() TERN1(DUAL_X_CARRIAGE, TERN0(X_HOME_TO_MIN, stepper.last_moved_extruder == 0) || TERN0(X2_HOME_TO_MIN, stepper.last_moved_extruder != 0))

commit aa8afe90b023b0ef1c4bc766566e81b894f66885
Author: Frederik Kemner <stuff+github@fredo.org>
Date:   Wed Feb 15 05:25:47 2023 +0100

    üö∏ SPI endstops for X/Y Dual and Core (#25371)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index cabb0fbf19..ef5f5d06e1 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -1323,99 +1323,84 @@ void Endstops::update() {
   #endif
 } // Endstops::update()
 
 #if ENABLED(SPI_ENDSTOPS)
 
   // Called from idle() to read Trinamic stall states
   bool Endstops::tmc_spi_homing_check() {
     bool hit = false;
     #if X_SPI_SENSORLESS
       if (tmc_spi_homing.x && (stepperX.test_stall_status()
-        #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX) && Y_SPI_SENSORLESS
+        #if Y_SPI_SENSORLESS && ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
           || stepperY.test_stall_status()
-        #elif CORE_IS_XZ && Z_SPI_SENSORLESS
+        #elif Z_SPI_SENSORLESS && CORE_IS_XZ
           || stepperZ.test_stall_status()
         #endif
-      )) {
-        SBI(live_state, X_ENDSTOP);
-        hit = true;
-      }
+      )) { SBI(live_state, X_ENDSTOP); hit = true; }
+      #if ENABLED(X_DUAL_ENDSTOPS)
+	      if (tmc_spi_homing.x && stepperX2.test_stall_status()) { SBI(live_state, X2_ENDSTOP); hit = true; }
+      #endif
     #endif
     #if Y_SPI_SENSORLESS
       if (tmc_spi_homing.y && (stepperY.test_stall_status()
-        #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX) && X_SPI_SENSORLESS
+        #if X_SPI_SENSORLESS && ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX)
           || stepperX.test_stall_status()
-        #elif CORE_IS_YZ && Z_SPI_SENSORLESS
+        #elif Z_SPI_SENSORLESS && CORE_IS_YZ
           || stepperZ.test_stall_status()
         #endif
-      )) {
-        SBI(live_state, Y_ENDSTOP);
-        hit = true;
-      }
+      )) { SBI(live_state, Y_ENDSTOP); hit = true; }
+      #if ENABLED(Y_DUAL_ENDSTOPS)
+	      if (tmc_spi_homing.y && stepperY2.test_stall_status()) { SBI(live_state, Y2_ENDSTOP); hit = true; }
+      #endif
     #endif
     #if Z_SPI_SENSORLESS
       if (tmc_spi_homing.z && (stepperZ.test_stall_status()
-        #if CORE_IS_XZ && X_SPI_SENSORLESS
+        #if X_SPI_SENSORLESS && CORE_IS_XZ
           || stepperX.test_stall_status()
-        #elif CORE_IS_YZ && Y_SPI_SENSORLESS
+        #elif Y_SPI_SENSORLESS && CORE_IS_YZ
           || stepperY.test_stall_status()
         #endif
-      )) {
-        SBI(live_state, Z_ENDSTOP);
-        hit = true;
-      }
+      )) { SBI(live_state, Z_ENDSTOP); hit = true; }
     #endif
     #if I_SPI_SENSORLESS
-      if (tmc_spi_homing.i && stepperI.test_stall_status()) {
-        SBI(live_state, I_ENDSTOP);
-        hit = true;
-      }
+      if (tmc_spi_homing.i && stepperI.test_stall_status()) { SBI(live_state, I_ENDSTOP); hit = true; }
     #endif
     #if J_SPI_SENSORLESS
-      if (tmc_spi_homing.j && stepperJ.test_stall_status()) {
-        SBI(live_state, J_ENDSTOP);
-        hit = true;
-      }
+      if (tmc_spi_homing.j && stepperJ.test_stall_status()) { SBI(live_state, J_ENDSTOP); hit = true; }
     #endif
     #if K_SPI_SENSORLESS
-      if (tmc_spi_homing.k && stepperK.test_stall_status()) {
-        SBI(live_state, K_ENDSTOP);
-        hit = true;
-      }
+      if (tmc_spi_homing.k && stepperK.test_stall_status()) { SBI(live_state, K_ENDSTOP); hit = true; }
     #endif
     #if U_SPI_SENSORLESS
-      if (tmc_spi_homing.u && stepperU.test_stall_status()) {
-        SBI(live_state, U_ENDSTOP);
-        hit = true;
-      }
+      if (tmc_spi_homing.u && stepperU.test_stall_status()) { SBI(live_state, U_ENDSTOP); hit = true; }
     #endif
     #if V_SPI_SENSORLESS
-      if (tmc_spi_homing.v && stepperV.test_stall_status()) {
-        SBI(live_state, V_ENDSTOP);
-        hit = true;
-      }
+      if (tmc_spi_homing.v && stepperV.test_stall_status()) { SBI(live_state, V_ENDSTOP); hit = true; }
     #endif
     #if W_SPI_SENSORLESS
-      if (tmc_spi_homing.w && stepperW.test_stall_status()) {
-        SBI(live_state, W_ENDSTOP);
-        hit = true;
-      }
+      if (tmc_spi_homing.w && stepperW.test_stall_status()) { SBI(live_state, W_ENDSTOP); hit = true; }
     #endif
 
     if (TERN0(ENDSTOP_INTERRUPTS_FEATURE, hit)) update();
 
     return hit;
   }
 
   void Endstops::clear_endstop_state() {
     TERN_(X_SPI_SENSORLESS, CBI(live_state, X_ENDSTOP));
+    #if BOTH(X_SPI_SENSORLESS, X_DUAL_ENDSTOPS)
+      CBI(live_state, X2_ENDSTOP);
+    #endif
     TERN_(Y_SPI_SENSORLESS, CBI(live_state, Y_ENDSTOP));
+    #if BOTH(Y_SPI_SENSORLESS, Y_DUAL_ENDSTOPS)
+      CBI(live_state, Y2_ENDSTOP);
+    #endif
     TERN_(Z_SPI_SENSORLESS, CBI(live_state, Z_ENDSTOP));
     TERN_(I_SPI_SENSORLESS, CBI(live_state, I_ENDSTOP));
     TERN_(J_SPI_SENSORLESS, CBI(live_state, J_ENDSTOP));
     TERN_(K_SPI_SENSORLESS, CBI(live_state, K_ENDSTOP));
     TERN_(U_SPI_SENSORLESS, CBI(live_state, U_ENDSTOP));
     TERN_(V_SPI_SENSORLESS, CBI(live_state, V_ENDSTOP));
     TERN_(W_SPI_SENSORLESS, CBI(live_state, W_ENDSTOP));
   }
 
 #endif // SPI_ENDSTOPS

commit 339773dcb5e8912e3bad2d916ff8c8ebb617694a
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Feb 8 20:31:02 2023 -0600

    ü©π Extra axis min home with Delta Sensorless Probe

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index f4fbda747b..cabb0fbf19 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -684,29 +684,23 @@ void __O2 Endstops::report_states() {
     #undef _CASE_RUNOUT
   #elif HAS_FILAMENT_SENSOR
     print_es_state(READ(FIL_RUNOUT1_PIN) != FIL_RUNOUT1_STATE, F(STR_FILAMENT));
   #endif
 
   TERN_(BLTOUCH, bltouch._reset_SW_mode());
   TERN_(JOYSTICK_DEBUG, joystick.report());
 
 } // Endstops::report_states
 
-#if HAS_DELTA_SENSORLESS_PROBING
-  #define __ENDSTOP(AXIS, ...) AXIS ##_MAX
-  #define _ENDSTOP_PIN(AXIS, ...) AXIS ##_MAX_PIN
-  #define _ENDSTOP_INVERTING(AXIS, ...) AXIS ##_MAX_ENDSTOP_INVERTING
-#else
-  #define __ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
-  #define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN
-  #define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_INVERTING
-#endif
+#define __ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
+#define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN
+#define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_INVERTING
 #define _ENDSTOP(AXIS, MINMAX) __ENDSTOP(AXIS, MINMAX)
 
 /**
  * Called from interrupt context by the Endstop ISR or Stepper ISR!
  * Read endstops to get their current states, register hits for all
  * axes moving in the direction of their endstops, and abort moves.
  */
 void Endstops::update() {
 
   #if !ENDSTOP_NOISE_THRESHOLD      // If not debouncing...

commit 53b202cf9de385b039a4c929f4aa590cc0888865
Author: ExtNeon <33217029+ExtNeon@users.noreply.github.com>
Date:   Sat Aug 6 23:37:03 2022 +0000

    ‚ú® SD Endstop Abort G-Code (#24461)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 33c94ae357..f4fbda747b 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -544,20 +544,24 @@ void Endstops::event_handler() {
         GET_TEXT(MSG_LCD_ENDSTOPS),
         NUM_AXIS_LIST(chrX, chrY, chrZ, chrI, chrJ, chrK, chrU, chrV, chrW), chrP
       )
     );
 
     #if BOTH(SD_ABORT_ON_ENDSTOP_HIT, SDSUPPORT)
       if (planner.abort_on_endstop_hit) {
         card.abortFilePrintNow();
         quickstop_stepper();
         thermalManager.disable_all_heaters();
+        #ifdef SD_ABORT_ON_ENDSTOP_HIT_GCODE
+          queue.clear();
+          queue.inject(F(SD_ABORT_ON_ENDSTOP_HIT_GCODE));
+        #endif
         print_job_timer.stop();
       }
     #endif
   }
 }
 
 #pragma GCC diagnostic push
 #if GCC_VERSION <= 50000
   #pragma GCC diagnostic ignored "-Wunused-function"
 #endif

commit 83320f1052dd09bff7aae789372e7bffccbced97
Author: Mark <niujl123@sina.com>
Date:   Sat Aug 6 14:14:58 2022 +0800

    ‚ú® Bed Distance Sensor (#24554)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 1ee4b92b5f..33c94ae357 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -56,20 +56,27 @@
 
 Endstops endstops;
 
 // private:
 
 bool Endstops::enabled, Endstops::enabled_globally; // Initialized by settings.load()
 
 volatile Endstops::endstop_mask_t Endstops::hit_state;
 Endstops::endstop_mask_t Endstops::live_state = 0;
 
+#if ENABLED(BD_SENSOR)
+  bool Endstops::bdp_state; // = false
+  #define READ_ENDSTOP(P) ((P == Z_MIN_PIN) ? bdp_state : READ(P))
+#else
+  #define READ_ENDSTOP(P) READ(P)
+#endif
+
 #if ENDSTOP_NOISE_THRESHOLD
   Endstops::endstop_mask_t Endstops::validated_live_state;
   uint8_t Endstops::endstop_poll_count;
 #endif
 
 #if HAS_BED_PROBE
   volatile bool Endstops::z_probe_enabled = false;
 #endif
 
 // Initialized by settings.load()
@@ -559,21 +566,21 @@ static void print_es_state(const bool is_hit, FSTR_P const flabel=nullptr) {
   if (flabel) SERIAL_ECHOF(flabel);
   SERIAL_ECHOPGM(": ");
   SERIAL_ECHOLNF(is_hit ? F(STR_ENDSTOP_HIT) : F(STR_ENDSTOP_OPEN));
 }
 
 #pragma GCC diagnostic pop
 
 void __O2 Endstops::report_states() {
   TERN_(BLTOUCH, bltouch._set_SW_mode());
   SERIAL_ECHOLNPGM(STR_M119_REPORT);
-  #define ES_REPORT(S) print_es_state(READ(S##_PIN) != S##_ENDSTOP_INVERTING, F(STR_##S))
+  #define ES_REPORT(S) print_es_state(READ_ENDSTOP(S##_PIN) != S##_ENDSTOP_INVERTING, F(STR_##S))
   #if HAS_X_MIN
     ES_REPORT(X_MIN);
   #endif
   #if HAS_X2_MIN
     ES_REPORT(X2_MIN);
   #endif
   #if HAS_X_MAX
     ES_REPORT(X_MAX);
   #endif
   #if HAS_X2_MAX
@@ -696,21 +703,21 @@ void __O2 Endstops::report_states() {
  * Read endstops to get their current states, register hits for all
  * axes moving in the direction of their endstops, and abort moves.
  */
 void Endstops::update() {
 
   #if !ENDSTOP_NOISE_THRESHOLD      // If not debouncing...
     if (!abort_enabled()) return;   // ...and not enabled, exit.
   #endif
 
   // Macros to update / copy the live_state
-  #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT_TO(live_state, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
+  #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT_TO(live_state, _ENDSTOP(AXIS, MINMAX), (READ_ENDSTOP(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
   #define COPY_LIVE_STATE(SRC_BIT, DST_BIT) SET_BIT_TO(live_state, DST_BIT, TEST(live_state, SRC_BIT))
 
   #if ENABLED(G38_PROBE_TARGET) && NONE(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY, MARKFORGED_YX)
     #define HAS_G38_PROBE 1
     // For G38 moves check the probe's pin for ALL movement
     if (G38_move) UPDATE_ENDSTOP_BIT(Z, TERN(USES_Z_MIN_PROBE_PIN, MIN_PROBE, MIN));
   #endif
 
   // With Dual X, endstops are only checked in the homing direction for the active extruder
   #define X_MIN_TEST() TERN1(DUAL_X_CARRIAGE, TERN0(X_HOME_TO_MIN, stepper.last_moved_extruder == 0) || TERN0(X2_HOME_TO_MIN, stepper.last_moved_extruder != 0))
@@ -1427,21 +1434,21 @@ void Endstops::update() {
    *
    * Yes, we could miss a rapid back & forth change but
    * that won't matter because this is all manual.
    */
   void Endstops::monitor() {
 
     static uint16_t old_live_state_local = 0;
     static uint8_t local_LED_status = 0;
     uint16_t live_state_local = 0;
 
-    #define ES_GET_STATE(S) if (READ(S##_PIN)) SBI(live_state_local, S)
+    #define ES_GET_STATE(S) if (READ_ENDSTOP(S##_PIN)) SBI(live_state_local, S)
 
     #if HAS_X_MIN
       ES_GET_STATE(X_MIN);
     #endif
     #if HAS_X_MAX
       ES_GET_STATE(X_MAX);
     #endif
     #if HAS_Y_MIN
       ES_GET_STATE(Y_MIN);
     #endif

commit 3522d5376cbf03658b71ddaf8c341e35f59b369b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jun 3 20:55:15 2022 -0500

    ü©π Wrap SENSORLESS_STALLGUARD_DELAY

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 261ab80217..1ee4b92b5f 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -1672,15 +1672,18 @@ void Endstops::update() {
           stepperY.rms_current(saved_current_y);
           debug_current_on(PSTR("Y"), Y_CURRENT_HOME, saved_current_y);
         #endif
         #if HAS_CURRENT_HOME(Z)
           stepperZ.rms_current(saved_current_z);
           debug_current_on(PSTR("Z"), Z_CURRENT_HOME, saved_current_z);
         #endif
       }
 
       TERN_(IMPROVE_HOMING_RELIABILITY, planner.enable_stall_prevention(onoff));
-      safe_delay(SENSORLESS_STALLGUARD_DELAY); // Short delay needed to settle
+
+      #if SENSORLESS_STALLGUARD_DELAY
+        safe_delay(SENSORLESS_STALLGUARD_DELAY); // Short delay needed to settle
+      #endif
 
     #endif // XYZ
   }
 #endif

commit 41f73cb457116ed9646932eb505b5e9fbe29e77d
Author: lujios <83166168+lujios@users.noreply.github.com>
Date:   Fri Jun 3 07:19:25 2022 +0200

    ‚ö°Ô∏è Improve Sensorless homing/probing accuracy for G28, G33, M48 (#24220)
    
    Co-authored-by: Robby Candra <robbycandra.mail@gmail.com>
    Co-authored-by: ellensp <530024+ellensp@users.noreply.github.com>

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index bebe09c99c..261ab80217 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -24,20 +24,23 @@
  * endstops.cpp - A singleton object to manage endstops
  */
 
 #include "endstops.h"
 #include "stepper.h"
 
 #include "../sd/cardreader.h"
 #include "temperature.h"
 #include "../lcd/marlinui.h"
 
+#define DEBUG_OUT BOTH(USE_SENSORLESS, DEBUG_LEVELING_FEATURE)
+#include "../core/debug_out.h"
+
 #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
   #include HAL_PATH(../HAL, endstop_interrupts.h)
 #endif
 
 #if BOTH(SD_ABORT_ON_ENDSTOP_HIT, SDSUPPORT)
   #include "printcounter.h" // for print_job_timer
 #endif
 
 #if ENABLED(BLTOUCH)
   #include "../feature/bltouch.h"
@@ -1614,10 +1617,70 @@ void Endstops::update() {
       #endif
 
       SERIAL_ECHOLNPGM("\n");
       hal.set_pwm_duty(pin_t(LED_PIN), local_LED_status);
       local_LED_status ^= 255;
       old_live_state_local = live_state_local;
     }
   }
 
 #endif // PINS_DEBUGGING
+
+#if USE_SENSORLESS
+  /**
+   * Change TMC driver currents to N##_CURRENT_HOME, saving the current configuration of each.
+   */
+  void Endstops::set_homing_current(const bool onoff) {
+    #define HAS_CURRENT_HOME(N) (defined(N##_CURRENT_HOME) && N##_CURRENT_HOME != N##_CURRENT)
+    #define HAS_DELTA_X_CURRENT (ENABLED(DELTA) && HAS_CURRENT_HOME(X))
+    #define HAS_DELTA_Y_CURRENT (ENABLED(DELTA) && HAS_CURRENT_HOME(Y))
+    #if HAS_DELTA_X_CURRENT || HAS_DELTA_Y_CURRENT || HAS_CURRENT_HOME(Z)
+      #if HAS_DELTA_X_CURRENT
+        static int16_t saved_current_x;
+      #endif
+      #if HAS_DELTA_Y_CURRENT
+        static int16_t saved_current_y;
+      #endif
+      #if HAS_CURRENT_HOME(Z)
+        static int16_t saved_current_z;
+      #endif
+      auto debug_current_on = [](PGM_P const s, const int16_t a, const int16_t b) {
+        if (DEBUGGING(LEVELING)) { DEBUG_ECHOPGM_P(s); DEBUG_ECHOLNPGM(" current: ", a, " -> ", b); }
+      };
+      if (onoff) {
+        #if HAS_DELTA_X_CURRENT
+          saved_current_x = stepperX.getMilliamps();
+          stepperX.rms_current(X_CURRENT_HOME);
+          debug_current_on(PSTR("X"), saved_current_x, X_CURRENT_HOME);
+        #endif
+        #if HAS_DELTA_Y_CURRENT
+          saved_current_y = stepperY.getMilliamps();
+          stepperY.rms_current(Y_CURRENT_HOME);
+          debug_current_on(PSTR("Y"), saved_current_y, Y_CURRENT_HOME);
+        #endif
+        #if HAS_CURRENT_HOME(Z)
+          saved_current_z = stepperZ.getMilliamps();
+          stepperZ.rms_current(Z_CURRENT_HOME);
+          debug_current_on(PSTR("Z"), saved_current_z, Z_CURRENT_HOME);
+        #endif
+      }
+      else {
+        #if HAS_DELTA_X_CURRENT
+          stepperX.rms_current(saved_current_x);
+          debug_current_on(PSTR("X"), X_CURRENT_HOME, saved_current_x);
+        #endif
+        #if HAS_DELTA_Y_CURRENT
+          stepperY.rms_current(saved_current_y);
+          debug_current_on(PSTR("Y"), Y_CURRENT_HOME, saved_current_y);
+        #endif
+        #if HAS_CURRENT_HOME(Z)
+          stepperZ.rms_current(saved_current_z);
+          debug_current_on(PSTR("Z"), Z_CURRENT_HOME, saved_current_z);
+        #endif
+      }
+
+      TERN_(IMPROVE_HOMING_RELIABILITY, planner.enable_stall_prevention(onoff));
+      safe_delay(SENSORLESS_STALLGUARD_DELAY); // Short delay needed to settle
+
+    #endif // XYZ
+  }
+#endif

commit 5f4ec825448cd5c9a7a03d3292b3d4a74377bba2
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Sun May 8 14:56:09 2022 +1200

    ‚úèÔ∏èFix Markforged endstops/G38 (#24141)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 3f7b47a98b..bebe09c99c 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -696,32 +696,32 @@ void __O2 Endstops::report_states() {
 void Endstops::update() {
 
   #if !ENDSTOP_NOISE_THRESHOLD      // If not debouncing...
     if (!abort_enabled()) return;   // ...and not enabled, exit.
   #endif
 
   // Macros to update / copy the live_state
   #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT_TO(live_state, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
   #define COPY_LIVE_STATE(SRC_BIT, DST_BIT) SET_BIT_TO(live_state, DST_BIT, TEST(live_state, SRC_BIT))
 
-  #if ENABLED(G38_PROBE_TARGET) && NONE(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY, MARKFORGED_XY)
+  #if ENABLED(G38_PROBE_TARGET) && NONE(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY, MARKFORGED_YX)
     #define HAS_G38_PROBE 1
     // For G38 moves check the probe's pin for ALL movement
     if (G38_move) UPDATE_ENDSTOP_BIT(Z, TERN(USES_Z_MIN_PROBE_PIN, MIN_PROBE, MIN));
   #endif
 
   // With Dual X, endstops are only checked in the homing direction for the active extruder
   #define X_MIN_TEST() TERN1(DUAL_X_CARRIAGE, TERN0(X_HOME_TO_MIN, stepper.last_moved_extruder == 0) || TERN0(X2_HOME_TO_MIN, stepper.last_moved_extruder != 0))
   #define X_MAX_TEST() TERN1(DUAL_X_CARRIAGE, TERN0(X_HOME_TO_MAX, stepper.last_moved_extruder == 0) || TERN0(X2_HOME_TO_MAX, stepper.last_moved_extruder != 0))
 
   // Use HEAD for core axes, AXIS for others
-  #if ANY(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY, MARKFORGED_XY)
+  #if ANY(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY, MARKFORGED_YX)
     #define X_AXIS_HEAD X_HEAD
   #else
     #define X_AXIS_HEAD X_AXIS
   #endif
   #if ANY(CORE_IS_XY, CORE_IS_YZ, MARKFORGED_XY, MARKFORGED_YX)
     #define Y_AXIS_HEAD Y_HEAD
   #else
     #define Y_AXIS_HEAD Y_AXIS
   #endif
   #if CORE_IS_XZ || CORE_IS_YZ

commit 659b4172aa49d82e54a08b5ed674b3ba4ad51fb0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu May 5 18:55:43 2022 -0500

    üî® Prevent build attribute define conflicts

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 656018a48c..3f7b47a98b 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -553,21 +553,21 @@ void Endstops::event_handler() {
 #endif
 
 static void print_es_state(const bool is_hit, FSTR_P const flabel=nullptr) {
   if (flabel) SERIAL_ECHOF(flabel);
   SERIAL_ECHOPGM(": ");
   SERIAL_ECHOLNF(is_hit ? F(STR_ENDSTOP_HIT) : F(STR_ENDSTOP_OPEN));
 }
 
 #pragma GCC diagnostic pop
 
-void _O2 Endstops::report_states() {
+void __O2 Endstops::report_states() {
   TERN_(BLTOUCH, bltouch._set_SW_mode());
   SERIAL_ECHOLNPGM(STR_M119_REPORT);
   #define ES_REPORT(S) print_es_state(READ(S##_PIN) != S##_ENDSTOP_INVERTING, F(STR_##S))
   #if HAS_X_MIN
     ES_REPORT(X_MIN);
   #endif
   #if HAS_X2_MIN
     ES_REPORT(X2_MIN);
   #endif
   #if HAS_X_MAX

commit df40181357b08761766067ef5012b2b3d0e34d3e
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Wed May 4 17:25:02 2022 -0700

    üí• Num Axes and Multi-Stepper based on Driver Types (#24120)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 7381e98b01..656018a48c 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -71,23 +71,23 @@ Endstops::endstop_mask_t Endstops::live_state = 0;
 
 // Initialized by settings.load()
 #if ENABLED(X_DUAL_ENDSTOPS)
   float Endstops::x2_endstop_adj;
 #endif
 #if ENABLED(Y_DUAL_ENDSTOPS)
   float Endstops::y2_endstop_adj;
 #endif
 #if ENABLED(Z_MULTI_ENDSTOPS)
   float Endstops::z2_endstop_adj;
-  #if NUM_Z_STEPPER_DRIVERS >= 3
+  #if NUM_Z_STEPPERS >= 3
     float Endstops::z3_endstop_adj;
-    #if NUM_Z_STEPPER_DRIVERS >= 4
+    #if NUM_Z_STEPPERS >= 4
       float Endstops::z4_endstop_adj;
     #endif
   #endif
 #endif
 
 #if ENABLED(SPI_ENDSTOPS)
   Endstops::tmc_spi_homing_t Endstops::tmc_spi_homing; // = 0
 #endif
 #if ENABLED(IMPROVE_HOMING_RELIABILITY)
   millis_t sg_guard_period; // = 0
@@ -785,28 +785,28 @@ void Endstops::update() {
   #endif
 
   #if HAS_Z_MIN && NONE(Z_SPI_SENSORLESS, Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
     UPDATE_ENDSTOP_BIT(Z, MIN);
     #if ENABLED(Z_MULTI_ENDSTOPS)
       #if HAS_Z2_MIN
         UPDATE_ENDSTOP_BIT(Z2, MIN);
       #else
         COPY_LIVE_STATE(Z_MIN, Z2_MIN);
       #endif
-      #if NUM_Z_STEPPER_DRIVERS >= 3
+      #if NUM_Z_STEPPERS >= 3
         #if HAS_Z3_MIN
           UPDATE_ENDSTOP_BIT(Z3, MIN);
         #else
           COPY_LIVE_STATE(Z_MIN, Z3_MIN);
         #endif
       #endif
-      #if NUM_Z_STEPPER_DRIVERS >= 4
+      #if NUM_Z_STEPPERS >= 4
         #if HAS_Z4_MIN
           UPDATE_ENDSTOP_BIT(Z4, MIN);
         #else
           COPY_LIVE_STATE(Z_MIN, Z4_MIN);
         #endif
       #endif
     #endif
   #endif
 
   #if HAS_BED_PROBE
@@ -817,28 +817,28 @@ void Endstops::update() {
 
   #if HAS_Z_MAX && !Z_SPI_SENSORLESS
     // Check both Z dual endstops
     #if ENABLED(Z_MULTI_ENDSTOPS)
       UPDATE_ENDSTOP_BIT(Z, MAX);
       #if HAS_Z2_MAX
         UPDATE_ENDSTOP_BIT(Z2, MAX);
       #else
         COPY_LIVE_STATE(Z_MAX, Z2_MAX);
       #endif
-      #if NUM_Z_STEPPER_DRIVERS >= 3
+      #if NUM_Z_STEPPERS >= 3
         #if HAS_Z3_MAX
           UPDATE_ENDSTOP_BIT(Z3, MAX);
         #else
           COPY_LIVE_STATE(Z_MAX, Z3_MAX);
         #endif
       #endif
-      #if NUM_Z_STEPPER_DRIVERS >= 4
+      #if NUM_Z_STEPPERS >= 4
         #if HAS_Z4_MAX
           UPDATE_ENDSTOP_BIT(Z4, MAX);
         #else
           COPY_LIVE_STATE(Z_MAX, Z4_MAX);
         #endif
       #endif
     #elif TERN1(USES_Z_MIN_PROBE_PIN, Z_MAX_PIN != Z_MIN_PROBE_PIN)
       // If this pin isn't the bed probe it's the Z endstop
       UPDATE_ENDSTOP_BIT(Z, MAX);
     #endif
@@ -1083,23 +1083,23 @@ void Endstops::update() {
   #endif
 
   #if ENABLED(Y_DUAL_ENDSTOPS)
     #define PROCESS_ENDSTOP_Y(MINMAX) PROCESS_DUAL_ENDSTOP(Y, MINMAX)
   #else
     #define PROCESS_ENDSTOP_Y(MINMAX) PROCESS_ENDSTOP(Y, MINMAX)
   #endif
 
   #if DISABLED(Z_MULTI_ENDSTOPS)
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_ENDSTOP(Z, MINMAX)
-  #elif NUM_Z_STEPPER_DRIVERS == 4
+  #elif NUM_Z_STEPPERS == 4
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_QUAD_ENDSTOP(Z, MINMAX)
-  #elif NUM_Z_STEPPER_DRIVERS == 3
+  #elif NUM_Z_STEPPERS == 3
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_TRIPLE_ENDSTOP(Z, MINMAX)
   #else
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_DUAL_ENDSTOP(Z, MINMAX)
   #endif
 
   #if HAS_G38_PROBE // TODO (DerAndere): Add support for HAS_I_AXIS
     #define _G38_OPEN_STATE TERN(G38_PROBE_AWAY, (G38_move >= 4), LOW)
     // For G38 moves check the probe's pin for ALL movement
     if (G38_move && TEST_ENDSTOP(_ENDSTOP(Z, TERN(USES_Z_MIN_PROBE_PIN, MIN_PROBE, MIN))) != _G38_OPEN_STATE) {
              if (stepper.axis_is_moving(X_AXIS)) { _ENDSTOP_HIT(X, TERN(X_HOME_TO_MIN, MIN, MAX)); planner.endstop_triggered(X_AXIS); }

commit e5b651f407fcb743e2d00c45b0d361fb98230efb
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Fri Apr 1 07:10:38 2022 +0200

    ‚ú® Support for up to 9 axes (linear, rotary) (#23112)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 3dd6d8aeb6..7381e98b01 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -312,20 +312,80 @@ void Endstops::init() {
   #if HAS_K_MAX
     #if ENABLED(ENDSTOPPULLUP_KMAX)
       SET_INPUT_PULLUP(K_MAX_PIN);
     #elif ENABLED(ENDSTOPPULLDOWN_KMIN)
       SET_INPUT_PULLDOWN(K_MAX_PIN);
     #else
       SET_INPUT(K_MAX_PIN);
     #endif
   #endif
 
+  #if HAS_U_MIN
+    #if ENABLED(ENDSTOPPULLUP_UMIN)
+      SET_INPUT_PULLUP(U_MIN_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_UMIN)
+      SET_INPUT_PULLDOWN(U_MIN_PIN);
+    #else
+      SET_INPUT(U_MIN_PIN);
+    #endif
+  #endif
+
+  #if HAS_U_MAX
+    #if ENABLED(ENDSTOPPULLUP_UMAX)
+      SET_INPUT_PULLUP(U_MAX_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_UMIN)
+      SET_INPUT_PULLDOWN(U_MAX_PIN);
+    #else
+      SET_INPUT(U_MAX_PIN);
+    #endif
+  #endif
+
+  #if HAS_V_MIN
+    #if ENABLED(ENDSTOPPULLUP_VMIN)
+      SET_INPUT_PULLUP(V_MIN_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_VMIN)
+      SET_INPUT_PULLDOWN(V_MIN_PIN);
+    #else
+      SET_INPUT(V_MIN_PIN);
+    #endif
+  #endif
+
+  #if HAS_V_MAX
+    #if ENABLED(ENDSTOPPULLUP_VMAX)
+      SET_INPUT_PULLUP(V_MAX_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_VMIN)
+      SET_INPUT_PULLDOWN(V_MAX_PIN);
+    #else
+      SET_INPUT(V_MAX_PIN);
+    #endif
+  #endif
+
+  #if HAS_W_MIN
+    #if ENABLED(ENDSTOPPULLUP_WMIN)
+      SET_INPUT_PULLUP(W_MIN_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_WMIN)
+      SET_INPUT_PULLDOWN(W_MIN_PIN);
+    #else
+      SET_INPUT(W_MIN_PIN);
+    #endif
+  #endif
+
+  #if HAS_W_MAX
+    #if ENABLED(ENDSTOPPULLUP_WMAX)
+      SET_INPUT_PULLUP(W_MAX_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_WMIN)
+      SET_INPUT_PULLDOWN(W_MAX_PIN);
+    #else
+      SET_INPUT(W_MAX_PIN);
+    #endif
+  #endif
+
   #if PIN_EXISTS(CALIBRATION)
     #if ENABLED(CALIBRATION_PIN_PULLUP)
       SET_INPUT_PULLUP(CALIBRATION_PIN);
     #elif ENABLED(CALIBRATION_PIN_PULLDOWN)
       SET_INPUT_PULLDOWN(CALIBRATION_PIN);
     #else
       SET_INPUT(CALIBRATION_PIN);
     #endif
   #endif
 
@@ -417,63 +477,69 @@ void Endstops::resync() {
     if (!monitor_count) monitor();      // report changes in endstop status
   }
 #endif
 
 void Endstops::event_handler() {
   static endstop_mask_t prev_hit_state; // = 0
   if (hit_state == prev_hit_state) return;
   prev_hit_state = hit_state;
   if (hit_state) {
     #if HAS_STATUS_MESSAGE
-      char LINEAR_AXIS_LIST(chrX = ' ', chrY = ' ', chrZ = ' ', chrI = ' ', chrJ = ' ', chrK = ' '),
+      char NUM_AXIS_LIST(chrX = ' ', chrY = ' ', chrZ = ' ', chrI = ' ', chrJ = ' ', chrK = ' ', chrU = ' ', chrV = ' ', chrW = ' '),
            chrP = ' ';
       #define _SET_STOP_CHAR(A,C) (chr## A = C)
     #else
       #define _SET_STOP_CHAR(A,C) NOOP
     #endif
 
     #define _ENDSTOP_HIT_ECHO(A,C) do{ \
       SERIAL_ECHOPGM(" " STRINGIFY(A) ":", planner.triggered_position_mm(_AXIS(A))); _SET_STOP_CHAR(A,C); }while(0)
 
     #define _ENDSTOP_HIT_TEST(A,C) \
       if (TERN0(HAS_##A##_MIN, TEST(hit_state, A##_MIN)) || TERN0(HAS_##A##_MAX, TEST(hit_state, A##_MAX))) \
         _ENDSTOP_HIT_ECHO(A,C)
 
     #define ENDSTOP_HIT_TEST_X() _ENDSTOP_HIT_TEST(X,'X')
     #define ENDSTOP_HIT_TEST_Y() _ENDSTOP_HIT_TEST(Y,'Y')
     #define ENDSTOP_HIT_TEST_Z() _ENDSTOP_HIT_TEST(Z,'Z')
     #define ENDSTOP_HIT_TEST_I() _ENDSTOP_HIT_TEST(I,'I')
     #define ENDSTOP_HIT_TEST_J() _ENDSTOP_HIT_TEST(J,'J')
     #define ENDSTOP_HIT_TEST_K() _ENDSTOP_HIT_TEST(K,'K')
+    #define ENDSTOP_HIT_TEST_U() _ENDSTOP_HIT_TEST(U,'U')
+    #define ENDSTOP_HIT_TEST_V() _ENDSTOP_HIT_TEST(V,'V')
+    #define ENDSTOP_HIT_TEST_W() _ENDSTOP_HIT_TEST(W,'W')
 
     SERIAL_ECHO_START();
     SERIAL_ECHOPGM(STR_ENDSTOPS_HIT);
-    LINEAR_AXIS_CODE(
+    NUM_AXIS_CODE(
        ENDSTOP_HIT_TEST_X(),
        ENDSTOP_HIT_TEST_Y(),
        ENDSTOP_HIT_TEST_Z(),
       _ENDSTOP_HIT_TEST(I,'I'),
       _ENDSTOP_HIT_TEST(J,'J'),
-      _ENDSTOP_HIT_TEST(K,'K')
+      _ENDSTOP_HIT_TEST(K,'K'),
+      _ENDSTOP_HIT_TEST(U,'U'),
+      _ENDSTOP_HIT_TEST(V,'V'),
+      _ENDSTOP_HIT_TEST(W,'W')
     );
 
     #if USES_Z_MIN_PROBE_PIN
       #define P_AXIS Z_AXIS
       if (TEST(hit_state, Z_MIN_PROBE)) _ENDSTOP_HIT_ECHO(P, 'P');
     #endif
     SERIAL_EOL();
 
     TERN_(HAS_STATUS_MESSAGE,
       ui.status_printf(0,
-        F(S_FMT GANG_N_1(LINEAR_AXES, " %c") " %c"),
+        F(S_FMT GANG_N_1(NUM_AXES, " %c") " %c"),
         GET_TEXT(MSG_LCD_ENDSTOPS),
-        LINEAR_AXIS_LIST(chrX, chrY, chrZ, chrI, chrJ, chrK), chrP
+        NUM_AXIS_LIST(chrX, chrY, chrZ, chrI, chrJ, chrK, chrU, chrV, chrW), chrP
       )
     );
 
     #if BOTH(SD_ABORT_ON_ENDSTOP_HIT, SDSUPPORT)
       if (planner.abort_on_endstop_hit) {
         card.abortFilePrintNow();
         quickstop_stepper();
         thermalManager.disable_all_heaters();
         print_job_timer.stop();
       }
@@ -557,20 +623,38 @@ void _O2 Endstops::report_states() {
   #endif
   #if HAS_J_MAX
     ES_REPORT(J_MAX);
   #endif
   #if HAS_K_MIN
     ES_REPORT(K_MIN);
   #endif
   #if HAS_K_MAX
     ES_REPORT(K_MAX);
   #endif
+  #if HAS_U_MIN
+    ES_REPORT(U_MIN);
+  #endif
+  #if HAS_U_MAX
+    ES_REPORT(U_MAX);
+  #endif
+  #if HAS_V_MIN
+    ES_REPORT(V_MIN);
+  #endif
+  #if HAS_V_MAX
+    ES_REPORT(V_MAX);
+  #endif
+  #if HAS_W_MIN
+    ES_REPORT(W_MIN);
+  #endif
+  #if HAS_W_MAX
+    ES_REPORT(W_MAX);
+  #endif
   #if ENABLED(PROBE_ACTIVATION_SWITCH)
     print_es_state(probe_switch_activated(), F(STR_PROBE_EN));
   #endif
   #if USES_Z_MIN_PROBE_PIN
     print_es_state(PROBE_TRIGGERED(), F(STR_Z_PROBE));
   #endif
   #if MULTI_FILAMENT_SENSOR
     #define _CASE_RUNOUT(N) case N: pin = FIL_RUNOUT##N##_PIN; state = FIL_RUNOUT##N##_STATE; break;
     LOOP_S_LE_N(i, 1, NUM_RUNOUT_SENSORS) {
       pin_t pin;
@@ -642,20 +726,23 @@ void Endstops::update() {
   #endif
   #if CORE_IS_XZ || CORE_IS_YZ
     #define Z_AXIS_HEAD Z_HEAD
   #else
     #define Z_AXIS_HEAD Z_AXIS
   #endif
 
   #define I_AXIS_HEAD I_AXIS
   #define J_AXIS_HEAD J_AXIS
   #define K_AXIS_HEAD K_AXIS
+  #define U_AXIS_HEAD U_AXIS
+  #define V_AXIS_HEAD V_AXIS
+  #define W_AXIS_HEAD W_AXIS
 
   /**
    * Check and update endstops
    */
   #if HAS_X_MIN && !X_SPI_SENSORLESS
     UPDATE_ENDSTOP_BIT(X, MIN);
     #if ENABLED(X_DUAL_ENDSTOPS)
       #if HAS_X2_MIN
         UPDATE_ENDSTOP_BIT(X2, MIN);
       #else
@@ -828,20 +915,96 @@ void Endstops::update() {
       #if HAS_K2_MAX
         UPDATE_ENDSTOP_BIT(K2, MAX);
       #else
         COPY_LIVE_STATE(K_MAX, K2_MAX);
       #endif
     #else
       UPDATE_ENDSTOP_BIT(K, MAX);
     #endif
   #endif
 
+  #if HAS_U_MIN && !U_SPI_SENSORLESS
+    #if ENABLED(U_DUAL_ENDSTOPS)
+      UPDATE_ENDSTOP_BIT(U, MIN);
+      #if HAS_U2_MIN
+        UPDATE_ENDSTOP_BIT(U2, MIN);
+      #else
+        COPY_LIVE_STATE(U_MIN, U2_MIN);
+      #endif
+    #else
+      UPDATE_ENDSTOP_BIT(U, MIN);
+    #endif
+  #endif
+
+  #if HAS_U_MAX && !U_SPI_SENSORLESS
+    #if ENABLED(U_DUAL_ENDSTOPS)
+      UPDATE_ENDSTOP_BIT(U, MAX);
+      #if HAS_U2_MAX
+        UPDATE_ENDSTOP_BIT(U2, MAX);
+      #else
+        COPY_LIVE_STATE(U_MAX, U2_MAX);
+      #endif
+    #else
+      UPDATE_ENDSTOP_BIT(U, MAX);
+    #endif
+  #endif
+
+  #if HAS_V_MIN && !V_SPI_SENSORLESS
+    #if ENABLED(V_DUAL_ENDSTOPS)
+      UPDATE_ENDSTOP_BIT(V, MIN);
+      #if HAS_V2_MIN
+        UPDATE_ENDSTOP_BIT(V2, MIN);
+      #else
+        COPY_LIVE_STATE(V_MIN, V2_MIN);
+      #endif
+    #else
+      UPDATE_ENDSTOP_BIT(V, MIN);
+    #endif
+  #endif
+  #if HAS_V_MAX && !V_SPI_SENSORLESS
+    #if ENABLED(O_DUAL_ENDSTOPS)
+      UPDATE_ENDSTOP_BIT(V, MAX);
+      #if HAS_V2_MAX
+        UPDATE_ENDSTOP_BIT(V2, MAX);
+      #else
+        COPY_LIVE_STATE(V_MAX, V2_MAX);
+      #endif
+    #else
+      UPDATE_ENDSTOP_BIT(V, MAX);
+    #endif
+  #endif
+
+  #if HAS_W_MIN && !W_SPI_SENSORLESS
+    #if ENABLED(W_DUAL_ENDSTOPS)
+      UPDATE_ENDSTOP_BIT(W, MIN);
+      #if HAS_W2_MIN
+        UPDATE_ENDSTOP_BIT(W2, MIN);
+      #else
+        COPY_LIVE_STATE(W_MIN, W2_MIN);
+      #endif
+    #else
+      UPDATE_ENDSTOP_BIT(W, MIN);
+    #endif
+  #endif
+  #if HAS_W_MAX && !W_SPI_SENSORLESS
+    #if ENABLED(W_DUAL_ENDSTOPS)
+      UPDATE_ENDSTOP_BIT(W, MAX);
+      #if HAS_W2_MAX
+        UPDATE_ENDSTOP_BIT(W2, MAX);
+      #else
+        COPY_LIVE_STATE(W_MAX, W2_MAX);
+      #endif
+    #else
+      UPDATE_ENDSTOP_BIT(W, MAX);
+    #endif
+  #endif
+
   #if ENDSTOP_NOISE_THRESHOLD
 
     /**
      * Filtering out noise on endstops requires a delayed decision. Let's assume, due to noise,
      * that 50% of endstop signal samples are good and 50% are bad (assuming normal distribution
      * of random noise). Then the first sample has a 50% chance to be good or bad. The 2nd sample
      * also has a 50% chance to be good or bad. The chances of 2 samples both being bad becomes
      * 50% of 50%, or 25%. That was the previous implementation of Marlin endstop handling. It
      * reduces chances of bad readings in half, at the cost of 1 extra sample period, but chances
      * still exist. The only way to reduce them further is to increase the number of samples.
@@ -928,21 +1091,21 @@ void Endstops::update() {
   #if DISABLED(Z_MULTI_ENDSTOPS)
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_ENDSTOP(Z, MINMAX)
   #elif NUM_Z_STEPPER_DRIVERS == 4
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_QUAD_ENDSTOP(Z, MINMAX)
   #elif NUM_Z_STEPPER_DRIVERS == 3
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_TRIPLE_ENDSTOP(Z, MINMAX)
   #else
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_DUAL_ENDSTOP(Z, MINMAX)
   #endif
 
-  #if HAS_G38_PROBE
+  #if HAS_G38_PROBE // TODO (DerAndere): Add support for HAS_I_AXIS
     #define _G38_OPEN_STATE TERN(G38_PROBE_AWAY, (G38_move >= 4), LOW)
     // For G38 moves check the probe's pin for ALL movement
     if (G38_move && TEST_ENDSTOP(_ENDSTOP(Z, TERN(USES_Z_MIN_PROBE_PIN, MIN_PROBE, MIN))) != _G38_OPEN_STATE) {
              if (stepper.axis_is_moving(X_AXIS)) { _ENDSTOP_HIT(X, TERN(X_HOME_TO_MIN, MIN, MAX)); planner.endstop_triggered(X_AXIS); }
       #if HAS_Y_AXIS
         else if (stepper.axis_is_moving(Y_AXIS)) { _ENDSTOP_HIT(Y, TERN(Y_HOME_TO_MIN, MIN, MAX)); planner.endstop_triggered(Y_AXIS); }
       #endif
       #if HAS_Z_AXIS
         else if (stepper.axis_is_moving(Z_AXIS)) { _ENDSTOP_HIT(Z, TERN(Z_HOME_TO_MIN, MIN, MAX)); planner.endstop_triggered(Z_AXIS); }
       #endif
@@ -1098,20 +1261,65 @@ void Endstops::update() {
           PROCESS_ENDSTOP(K, MIN);
         #endif
       }
       else { // +direction
         #if HAS_K_MAX || (K_SPI_SENSORLESS && K_HOME_TO_MAX)
           PROCESS_ENDSTOP(K, MAX);
         #endif
       }
     }
   #endif
+
+  #if HAS_U_AXIS
+    if (stepper.axis_is_moving(U_AXIS)) {
+      if (stepper.motor_direction(U_AXIS_HEAD)) { // -direction
+        #if HAS_U_MIN || (U_SPI_SENSORLESS && U_HOME_TO_MIN)
+          PROCESS_ENDSTOP(U, MIN);
+        #endif
+      }
+      else { // +direction
+        #if HAS_U_MAX || (U_SPI_SENSORLESS && U_HOME_TO_MAX)
+          PROCESS_ENDSTOP(U, MAX);
+        #endif
+      }
+    }
+  #endif
+
+  #if HAS_V_AXIS
+    if (stepper.axis_is_moving(V_AXIS)) {
+      if (stepper.motor_direction(V_AXIS_HEAD)) { // -direction
+        #if HAS_V_MIN || (V_SPI_SENSORLESS && V_HOME_TO_MIN)
+          PROCESS_ENDSTOP(V, MIN);
+        #endif
+      }
+      else { // +direction
+        #if HAS_V_MAX || (V_SPI_SENSORLESS && V_HOME_TO_MAX)
+          PROCESS_ENDSTOP(V, MAX);
+        #endif
+      }
+    }
+  #endif
+
+  #if HAS_W_AXIS
+    if (stepper.axis_is_moving(W_AXIS)) {
+      if (stepper.motor_direction(W_AXIS_HEAD)) { // -direction
+        #if HAS_W_MIN || (W_SPI_SENSORLESS && W_HOME_TO_MIN)
+          PROCESS_ENDSTOP(W, MIN);
+        #endif
+      }
+      else { // +direction
+        #if HAS_W_MAX || (W_SPI_SENSORLESS && W_HOME_TO_MAX)
+          PROCESS_ENDSTOP(W, MAX);
+        #endif
+      }
+    }
+  #endif
 } // Endstops::update()
 
 #if ENABLED(SPI_ENDSTOPS)
 
   // Called from idle() to read Trinamic stall states
   bool Endstops::tmc_spi_homing_check() {
     bool hit = false;
     #if X_SPI_SENSORLESS
       if (tmc_spi_homing.x && (stepperX.test_stall_status()
         #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX) && Y_SPI_SENSORLESS
@@ -1159,33 +1367,54 @@ void Endstops::update() {
         SBI(live_state, J_ENDSTOP);
         hit = true;
       }
     #endif
     #if K_SPI_SENSORLESS
       if (tmc_spi_homing.k && stepperK.test_stall_status()) {
         SBI(live_state, K_ENDSTOP);
         hit = true;
       }
     #endif
+    #if U_SPI_SENSORLESS
+      if (tmc_spi_homing.u && stepperU.test_stall_status()) {
+        SBI(live_state, U_ENDSTOP);
+        hit = true;
+      }
+    #endif
+    #if V_SPI_SENSORLESS
+      if (tmc_spi_homing.v && stepperV.test_stall_status()) {
+        SBI(live_state, V_ENDSTOP);
+        hit = true;
+      }
+    #endif
+    #if W_SPI_SENSORLESS
+      if (tmc_spi_homing.w && stepperW.test_stall_status()) {
+        SBI(live_state, W_ENDSTOP);
+        hit = true;
+      }
+    #endif
 
     if (TERN0(ENDSTOP_INTERRUPTS_FEATURE, hit)) update();
 
     return hit;
   }
 
   void Endstops::clear_endstop_state() {
     TERN_(X_SPI_SENSORLESS, CBI(live_state, X_ENDSTOP));
     TERN_(Y_SPI_SENSORLESS, CBI(live_state, Y_ENDSTOP));
     TERN_(Z_SPI_SENSORLESS, CBI(live_state, Z_ENDSTOP));
     TERN_(I_SPI_SENSORLESS, CBI(live_state, I_ENDSTOP));
     TERN_(J_SPI_SENSORLESS, CBI(live_state, J_ENDSTOP));
     TERN_(K_SPI_SENSORLESS, CBI(live_state, K_ENDSTOP));
+    TERN_(U_SPI_SENSORLESS, CBI(live_state, U_ENDSTOP));
+    TERN_(V_SPI_SENSORLESS, CBI(live_state, V_ENDSTOP));
+    TERN_(W_SPI_SENSORLESS, CBI(live_state, W_ENDSTOP));
   }
 
 #endif // SPI_ENDSTOPS
 
 #if ENABLED(PINS_DEBUGGING)
 
   bool Endstops::monitor_flag = false;
 
   /**
    * Monitor Endstops and Z Probe for changes
@@ -1266,20 +1495,38 @@ void Endstops::update() {
     #endif
     #if HAS_J_MIN
       ES_GET_STATE(J_MIN);
     #endif
     #if HAS_K_MAX
       ES_GET_STATE(K_MAX);
     #endif
     #if HAS_K_MIN
       ES_GET_STATE(K_MIN);
     #endif
+    #if HAS_U_MAX
+      ES_GET_STATE(U_MAX);
+    #endif
+    #if HAS_U_MIN
+      ES_GET_STATE(U_MIN);
+    #endif
+    #if HAS_V_MAX
+      ES_GET_STATE(V_MAX);
+    #endif
+    #if HAS_V_MIN
+      ES_GET_STATE(V_MIN);
+    #endif
+    #if HAS_W_MAX
+      ES_GET_STATE(W_MAX);
+    #endif
+    #if HAS_W_MIN
+      ES_GET_STATE(W_MIN);
+    #endif
 
     uint16_t endstop_change = live_state_local ^ old_live_state_local;
     #define ES_REPORT_CHANGE(S) if (TEST(endstop_change, S)) SERIAL_ECHOPGM("  " STRINGIFY(S) ":", TEST(live_state_local, S))
 
     if (endstop_change) {
       #if HAS_X_MIN
         ES_REPORT_CHANGE(X_MIN);
       #endif
       #if HAS_X_MAX
         ES_REPORT_CHANGE(X_MAX);
@@ -1340,18 +1587,37 @@ void Endstops::update() {
       #endif
       #if HAS_J_MAX
         ES_REPORT_CHANGE(J_MAX);
       #endif
       #if HAS_K_MIN
         ES_REPORT_CHANGE(K_MIN);
       #endif
       #if HAS_K_MAX
         ES_REPORT_CHANGE(K_MAX);
       #endif
+      #if HAS_U_MIN
+        ES_REPORT_CHANGE(U_MIN);
+      #endif
+      #if HAS_U_MAX
+        ES_REPORT_CHANGE(U_MAX);
+      #endif
+      #if HAS_V_MIN
+        ES_REPORT_CHANGE(V_MIN);
+      #endif
+      #if HAS_V_MAX
+        ES_REPORT_CHANGE(V_MAX);
+      #endif
+      #if HAS_W_MIN
+        ES_REPORT_CHANGE(W_MIN);
+      #endif
+      #if HAS_W_MAX
+        ES_REPORT_CHANGE(W_MAX);
+      #endif
+
       SERIAL_ECHOLNPGM("\n");
       hal.set_pwm_duty(pin_t(LED_PIN), local_LED_status);
       local_LED_status ^= 255;
       old_live_state_local = live_state_local;
     }
   }
 
 #endif // PINS_DEBUGGING

commit 44eff9a23348dcc117fd1ea9b4b1ef0b54061808
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Feb 17 18:50:31 2022 -0600

    ‚ôªÔ∏è Refactor HAL as singleton (#23357)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index bce27dc88a..3dd6d8aeb6 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -1341,17 +1341,17 @@ void Endstops::update() {
       #if HAS_J_MAX
         ES_REPORT_CHANGE(J_MAX);
       #endif
       #if HAS_K_MIN
         ES_REPORT_CHANGE(K_MIN);
       #endif
       #if HAS_K_MAX
         ES_REPORT_CHANGE(K_MAX);
       #endif
       SERIAL_ECHOLNPGM("\n");
-      set_pwm_duty(pin_t(LED_PIN), local_LED_status);
+      hal.set_pwm_duty(pin_t(LED_PIN), local_LED_status);
       local_LED_status ^= 255;
       old_live_state_local = live_state_local;
     }
   }
 
 #endif // PINS_DEBUGGING

commit 40481947fc1f11a01235c5c55333a4437fc45c5f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jan 14 03:14:13 2022 -0600

    üßë‚Äçüíª Misc. updates for extra axes (#23521)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 939dd6d537..bce27dc88a 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -551,21 +551,21 @@ void _O2 Endstops::report_states() {
   #endif
   #if HAS_I_MAX
     ES_REPORT(I_MAX);
   #endif
   #if HAS_J_MIN
     ES_REPORT(J_MIN);
   #endif
   #if HAS_J_MAX
     ES_REPORT(J_MAX);
   #endif
-    #if HAS_K_MIN
+  #if HAS_K_MIN
     ES_REPORT(K_MIN);
   #endif
   #if HAS_K_MAX
     ES_REPORT(K_MAX);
   #endif
   #if ENABLED(PROBE_ACTIVATION_SWITCH)
     print_es_state(probe_switch_activated(), F(STR_PROBE_EN));
   #endif
   #if USES_Z_MIN_PROBE_PIN
     print_es_state(PROBE_TRIGGERED(), F(STR_Z_PROBE));

commit 3e2a38b653b1d8479b7b38447d5fdff51ea9947f
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Wed Jan 12 08:24:56 2022 -0800

    üìù KHz => kHz (#23512)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index b9c5aebf39..939dd6d537 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -345,21 +345,21 @@ void Endstops::init() {
 
   TERN_(PROBE_TARE, probe.tare());
 
   TERN_(ENDSTOP_INTERRUPTS_FEATURE, setup_endstop_interrupts());
 
   // Enable endstops
   enable_globally(ENABLED(ENDSTOPS_ALWAYS_ON_DEFAULT));
 
 } // Endstops::init
 
-// Called at ~1KHz from Temperature ISR: Poll endstop state if required
+// Called at ~1kHz from Temperature ISR: Poll endstop state if required
 void Endstops::poll() {
 
   TERN_(PINS_DEBUGGING, run_monitor()); // Report changes in endstop status
 
   #if DISABLED(ENDSTOP_INTERRUPTS_FEATURE)
     update();
   #elif ENDSTOP_NOISE_THRESHOLD
     if (endstop_poll_count) update();
   #endif
 }
@@ -396,21 +396,21 @@ void Endstops::not_homing() {
       WRITE(PROBE_ENABLE_PIN, onoff);
     #endif
     resync();
   }
 #endif
 
 // Get the stable endstop states when enabled
 void Endstops::resync() {
   if (!abort_enabled()) return;     // If endstops/probes are disabled the loop below can hang
 
-  // Wait for Temperature ISR to run at least once (runs at 1KHz)
+  // Wait for Temperature ISR to run at least once (runs at 1kHz)
   TERN(ENDSTOP_INTERRUPTS_FEATURE, update(), safe_delay(2));
   while (TERN0(ENDSTOP_NOISE_THRESHOLD, endstop_poll_count)) safe_delay(1);
 }
 
 #if ENABLED(PINS_DEBUGGING)
   void Endstops::run_monitor() {
     if (!monitor_flag) return;
     static uint8_t monitor_count = 16;  // offset this check from the others
     monitor_count += _BV(1);            //  15 Hz
     monitor_count &= 0x7F;

commit 1bd921d6a69412686fa4b31c4c1e5710de9840cf
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jan 6 05:07:47 2022 -0600

    üé® Misc. cleanup, comments

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 50ee33b3c0..b9c5aebf39 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -586,41 +586,43 @@ void _O2 Endstops::report_states() {
     #undef _CASE_RUNOUT
   #elif HAS_FILAMENT_SENSOR
     print_es_state(READ(FIL_RUNOUT1_PIN) != FIL_RUNOUT1_STATE, F(STR_FILAMENT));
   #endif
 
   TERN_(BLTOUCH, bltouch._reset_SW_mode());
   TERN_(JOYSTICK_DEBUG, joystick.report());
 
 } // Endstops::report_states
 
-// The following routines are called from an ISR context. It could be the temperature ISR, the
-// endstop ISR or the Stepper ISR.
-
 #if HAS_DELTA_SENSORLESS_PROBING
   #define __ENDSTOP(AXIS, ...) AXIS ##_MAX
   #define _ENDSTOP_PIN(AXIS, ...) AXIS ##_MAX_PIN
   #define _ENDSTOP_INVERTING(AXIS, ...) AXIS ##_MAX_ENDSTOP_INVERTING
 #else
   #define __ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
   #define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN
   #define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_INVERTING
 #endif
 #define _ENDSTOP(AXIS, MINMAX) __ENDSTOP(AXIS, MINMAX)
 
-// Check endstops - Could be called from Temperature ISR!
+/**
+ * Called from interrupt context by the Endstop ISR or Stepper ISR!
+ * Read endstops to get their current states, register hits for all
+ * axes moving in the direction of their endstops, and abort moves.
+ */
 void Endstops::update() {
 
-  #if !ENDSTOP_NOISE_THRESHOLD
-    if (!abort_enabled()) return;
+  #if !ENDSTOP_NOISE_THRESHOLD      // If not debouncing...
+    if (!abort_enabled()) return;   // ...and not enabled, exit.
   #endif
 
+  // Macros to update / copy the live_state
   #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT_TO(live_state, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
   #define COPY_LIVE_STATE(SRC_BIT, DST_BIT) SET_BIT_TO(live_state, DST_BIT, TEST(live_state, SRC_BIT))
 
   #if ENABLED(G38_PROBE_TARGET) && NONE(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY, MARKFORGED_XY)
     #define HAS_G38_PROBE 1
     // For G38 moves check the probe's pin for ALL movement
     if (G38_move) UPDATE_ENDSTOP_BIT(Z, TERN(USES_Z_MIN_PROBE_PIN, MIN_PROBE, MIN));
   #endif
 
   // With Dual X, endstops are only checked in the homing direction for the active extruder
@@ -1100,20 +1102,21 @@ void Endstops::update() {
         #if HAS_K_MAX || (K_SPI_SENSORLESS && K_HOME_TO_MAX)
           PROCESS_ENDSTOP(K, MAX);
         #endif
       }
     }
   #endif
 } // Endstops::update()
 
 #if ENABLED(SPI_ENDSTOPS)
 
+  // Called from idle() to read Trinamic stall states
   bool Endstops::tmc_spi_homing_check() {
     bool hit = false;
     #if X_SPI_SENSORLESS
       if (tmc_spi_homing.x && (stepperX.test_stall_status()
         #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX) && Y_SPI_SENSORLESS
           || stepperY.test_stall_status()
         #elif CORE_IS_XZ && Z_SPI_SENSORLESS
           || stepperZ.test_stall_status()
         #endif
       )) {

commit e65c12cf96a226019a7456099078ee5cb03f9a49
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jan 2 09:22:36 2022 -0600

    üßë‚Äçüíª Apply axis conditionals

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 7a2cefdd4c..50ee33b3c0 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -1052,51 +1052,51 @@ void Endstops::update() {
           #elif CORE_DIAG(YZ, Y, MIN)
             PROCESS_CORE_ENDSTOP(Y,MIN,Z,MAX);
           #elif CORE_DIAG(YZ, Y, MAX)
             PROCESS_CORE_ENDSTOP(Y,MAX,Z,MAX);
           #endif
         #endif
       }
     }
   #endif
 
-  #if LINEAR_AXES >= 4
+  #if HAS_I_AXIS
     if (stepper.axis_is_moving(I_AXIS)) {
       if (stepper.motor_direction(I_AXIS_HEAD)) { // -direction
         #if HAS_I_MIN || (I_SPI_SENSORLESS && I_HOME_TO_MIN)
           PROCESS_ENDSTOP(I, MIN);
         #endif
       }
       else { // +direction
         #if HAS_I_MAX || (I_SPI_SENSORLESS && I_HOME_TO_MAX)
           PROCESS_ENDSTOP(I, MAX);
         #endif
       }
     }
   #endif
 
-  #if LINEAR_AXES >= 5
+  #if HAS_J_AXIS
     if (stepper.axis_is_moving(J_AXIS)) {
       if (stepper.motor_direction(J_AXIS_HEAD)) { // -direction
         #if HAS_J_MIN || (J_SPI_SENSORLESS && J_HOME_TO_MIN)
           PROCESS_ENDSTOP(J, MIN);
         #endif
       }
       else { // +direction
         #if HAS_J_MAX || (J_SPI_SENSORLESS && J_HOME_TO_MAX)
           PROCESS_ENDSTOP(J, MAX);
         #endif
       }
     }
   #endif
 
-  #if LINEAR_AXES >= 6
+  #if HAS_K_AXIS
     if (stepper.axis_is_moving(K_AXIS)) {
       if (stepper.motor_direction(K_AXIS_HEAD)) { // -direction
         #if HAS_K_MIN || (K_SPI_SENSORLESS && K_HOME_TO_MIN)
           PROCESS_ENDSTOP(K, MIN);
         #endif
       }
       else { // +direction
         #if HAS_K_MAX || (K_SPI_SENSORLESS && K_HOME_TO_MAX)
           PROCESS_ENDSTOP(K, MAX);
         #endif

commit 6a8b9274a31d11c396ce1bc44b3a0b872a4606dc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Dec 25 23:15:17 2021 -0600

    ‚è™Ô∏è Refactor still needs work
    
    Reverting #23295

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index df6a857803..7a2cefdd4c 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -1338,17 +1338,17 @@ void Endstops::update() {
       #if HAS_J_MAX
         ES_REPORT_CHANGE(J_MAX);
       #endif
       #if HAS_K_MIN
         ES_REPORT_CHANGE(K_MIN);
       #endif
       #if HAS_K_MAX
         ES_REPORT_CHANGE(K_MAX);
       #endif
       SERIAL_ECHOLNPGM("\n");
-      hal.set_pwm_duty(pin_t(LED_PIN), local_LED_status);
+      set_pwm_duty(pin_t(LED_PIN), local_LED_status);
       local_LED_status ^= 255;
       old_live_state_local = live_state_local;
     }
   }
 
 #endif // PINS_DEBUGGING

commit e211ff148c39bf5dace72de7cffbb83f19d3f1bf
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Dec 24 21:33:59 2021 -0600

    ‚ôªÔ∏è Refactor HAL as singleton (#23295)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 7a2cefdd4c..df6a857803 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -1338,17 +1338,17 @@ void Endstops::update() {
       #if HAS_J_MAX
         ES_REPORT_CHANGE(J_MAX);
       #endif
       #if HAS_K_MIN
         ES_REPORT_CHANGE(K_MIN);
       #endif
       #if HAS_K_MAX
         ES_REPORT_CHANGE(K_MAX);
       #endif
       SERIAL_ECHOLNPGM("\n");
-      set_pwm_duty(pin_t(LED_PIN), local_LED_status);
+      hal.set_pwm_duty(pin_t(LED_PIN), local_LED_status);
       local_LED_status ^= 255;
       old_live_state_local = live_state_local;
     }
   }
 
 #endif // PINS_DEBUGGING

commit c3af6bd8ce731737d0812a0e554e37dc0779127f
Author: Scott Alfter <scott@alfter.us>
Date:   Wed Dec 8 23:18:04 2021 -0800

    Fix Endstops::report_states (#23280)
    
    Fix regression 4d45fdf0eb

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 7c08456fa5..7a2cefdd4c 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -557,21 +557,21 @@ void _O2 Endstops::report_states() {
   #endif
   #if HAS_J_MAX
     ES_REPORT(J_MAX);
   #endif
     #if HAS_K_MIN
     ES_REPORT(K_MIN);
   #endif
   #if HAS_K_MAX
     ES_REPORT(K_MAX);
   #endif
-  #if BOTH(PROBE_ACTIVATION_SWITCH)
+  #if ENABLED(PROBE_ACTIVATION_SWITCH)
     print_es_state(probe_switch_activated(), F(STR_PROBE_EN));
   #endif
   #if USES_Z_MIN_PROBE_PIN
     print_es_state(PROBE_TRIGGERED(), F(STR_Z_PROBE));
   #endif
   #if MULTI_FILAMENT_SENSOR
     #define _CASE_RUNOUT(N) case N: pin = FIL_RUNOUT##N##_PIN; state = FIL_RUNOUT##N##_STATE; break;
     LOOP_S_LE_N(i, 1, NUM_RUNOUT_SENSORS) {
       pin_t pin;
       uint8_t state;

commit 4d45fdf0eb605629960d06abb86704cfbd62db49
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Dec 8 18:36:08 2021 -0600

    üé® Misc. probe / endstop cleanup

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 06cbb839cd..7c08456fa5 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -557,21 +557,21 @@ void _O2 Endstops::report_states() {
   #endif
   #if HAS_J_MAX
     ES_REPORT(J_MAX);
   #endif
     #if HAS_K_MIN
     ES_REPORT(K_MIN);
   #endif
   #if HAS_K_MAX
     ES_REPORT(K_MAX);
   #endif
-  #if BOTH(MARLIN_DEV_MODE, PROBE_ACTIVATION_SWITCH)
+  #if BOTH(PROBE_ACTIVATION_SWITCH)
     print_es_state(probe_switch_activated(), F(STR_PROBE_EN));
   #endif
   #if USES_Z_MIN_PROBE_PIN
     print_es_state(PROBE_TRIGGERED(), F(STR_Z_PROBE));
   #endif
   #if MULTI_FILAMENT_SENSOR
     #define _CASE_RUNOUT(N) case N: pin = FIL_RUNOUT##N##_PIN; state = FIL_RUNOUT##N##_STATE; break;
     LOOP_S_LE_N(i, 1, NUM_RUNOUT_SENSORS) {
       pin_t pin;
       uint8_t state;

commit e5154ec28179c7dc7b58a830412e7cb09c2f878c
Author: John Robertson <john@cirtech.co.uk>
Date:   Tue Nov 23 21:24:24 2021 +0000

    ‚ú® MarkForged YX kinematics (#23163)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index aa5907477e..06cbb839cd 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -610,37 +610,37 @@ void _O2 Endstops::report_states() {
 // Check endstops - Could be called from Temperature ISR!
 void Endstops::update() {
 
   #if !ENDSTOP_NOISE_THRESHOLD
     if (!abort_enabled()) return;
   #endif
 
   #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT_TO(live_state, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
   #define COPY_LIVE_STATE(SRC_BIT, DST_BIT) SET_BIT_TO(live_state, DST_BIT, TEST(live_state, SRC_BIT))
 
-  #if ENABLED(G38_PROBE_TARGET) && NONE(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY)
+  #if ENABLED(G38_PROBE_TARGET) && NONE(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY, MARKFORGED_XY)
     #define HAS_G38_PROBE 1
     // For G38 moves check the probe's pin for ALL movement
     if (G38_move) UPDATE_ENDSTOP_BIT(Z, TERN(USES_Z_MIN_PROBE_PIN, MIN_PROBE, MIN));
   #endif
 
   // With Dual X, endstops are only checked in the homing direction for the active extruder
   #define X_MIN_TEST() TERN1(DUAL_X_CARRIAGE, TERN0(X_HOME_TO_MIN, stepper.last_moved_extruder == 0) || TERN0(X2_HOME_TO_MIN, stepper.last_moved_extruder != 0))
   #define X_MAX_TEST() TERN1(DUAL_X_CARRIAGE, TERN0(X_HOME_TO_MAX, stepper.last_moved_extruder == 0) || TERN0(X2_HOME_TO_MAX, stepper.last_moved_extruder != 0))
 
   // Use HEAD for core axes, AXIS for others
-  #if ANY(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY)
+  #if ANY(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY, MARKFORGED_XY)
     #define X_AXIS_HEAD X_HEAD
   #else
     #define X_AXIS_HEAD X_AXIS
   #endif
-  #if ANY(CORE_IS_XY, CORE_IS_YZ, MARKFORGED_XY)
+  #if ANY(CORE_IS_XY, CORE_IS_YZ, MARKFORGED_XY, MARKFORGED_YX)
     #define Y_AXIS_HEAD Y_HEAD
   #else
     #define Y_AXIS_HEAD Y_AXIS
   #endif
   #if CORE_IS_XZ || CORE_IS_YZ
     #define Z_AXIS_HEAD Z_HEAD
   #else
     #define Z_AXIS_HEAD Z_AXIS
   #endif
 
@@ -1104,33 +1104,33 @@ void Endstops::update() {
     }
   #endif
 } // Endstops::update()
 
 #if ENABLED(SPI_ENDSTOPS)
 
   bool Endstops::tmc_spi_homing_check() {
     bool hit = false;
     #if X_SPI_SENSORLESS
       if (tmc_spi_homing.x && (stepperX.test_stall_status()
-        #if ANY(CORE_IS_XY, MARKFORGED_XY) && Y_SPI_SENSORLESS
+        #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX) && Y_SPI_SENSORLESS
           || stepperY.test_stall_status()
         #elif CORE_IS_XZ && Z_SPI_SENSORLESS
           || stepperZ.test_stall_status()
         #endif
       )) {
         SBI(live_state, X_ENDSTOP);
         hit = true;
       }
     #endif
     #if Y_SPI_SENSORLESS
       if (tmc_spi_homing.y && (stepperY.test_stall_status()
-        #if ANY(CORE_IS_XY, MARKFORGED_XY) && X_SPI_SENSORLESS
+        #if ANY(CORE_IS_XY, MARKFORGED_XY, MARKFORGED_YX) && X_SPI_SENSORLESS
           || stepperX.test_stall_status()
         #elif CORE_IS_YZ && Z_SPI_SENSORLESS
           || stepperZ.test_stall_status()
         #endif
       )) {
         SBI(live_state, Y_ENDSTOP);
         hit = true;
       }
     #endif
     #if Z_SPI_SENSORLESS

commit 07befb545b2bc6ea284d444637a039127af6b4d1
Author: BigTreeTech <38851044+bigtreetech@users.noreply.github.com>
Date:   Wed Nov 10 23:56:10 2021 +0800

    ‚ú® Support for BIQU B1-SE-Plus strain gauge probe (#23101)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 04f20ca3a4..aa5907477e 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -385,20 +385,23 @@ void Endstops::not_homing() {
   void Endstops::validate_homing_move() {
     if (trigger_state()) hit_on_purpose();
     else kill(GET_TEXT_F(MSG_KILL_HOMING_FAILED));
   }
 #endif
 
 // Enable / disable endstop z-probe checking
 #if HAS_BED_PROBE
   void Endstops::enable_z_probe(const bool onoff) {
     z_probe_enabled = onoff;
+    #if PIN_EXISTS(PROBE_ENABLE)
+      WRITE(PROBE_ENABLE_PIN, onoff);
+    #endif
     resync();
   }
 #endif
 
 // Get the stable endstop states when enabled
 void Endstops::resync() {
   if (!abort_enabled()) return;     // If endstops/probes are disabled the loop below can hang
 
   // Wait for Temperature ISR to run at least once (runs at 1KHz)
   TERN(ENDSTOP_INTERRUPTS_FEATURE, update(), safe_delay(2));

commit da830e6ced7f7c7e509e748104245064d1c1b265
Author: Andrei M <22990561+andrei-moraru@users.noreply.github.com>
Date:   Tue Nov 2 01:47:16 2021 -0400

    ‚öóÔ∏è Use pwm_set_duty over analogWrite to set PWM (#23048)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 332becfb73..04f20ca3a4 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -1335,17 +1335,17 @@ void Endstops::update() {
       #if HAS_J_MAX
         ES_REPORT_CHANGE(J_MAX);
       #endif
       #if HAS_K_MIN
         ES_REPORT_CHANGE(K_MIN);
       #endif
       #if HAS_K_MAX
         ES_REPORT_CHANGE(K_MAX);
       #endif
       SERIAL_ECHOLNPGM("\n");
-      analogWrite(pin_t(LED_PIN), local_LED_status);
+      set_pwm_duty(pin_t(LED_PIN), local_LED_status);
       local_LED_status ^= 255;
       old_live_state_local = live_state_local;
     }
   }
 
 #endif // PINS_DEBUGGING

commit 1f3f9cb68ce9c9adad55a98ccea07e491d7b9785
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Oct 19 05:52:41 2021 -0500

    üé® Pragma GCC cleanup

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index da5a0073cf..332becfb73 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -471,34 +471,32 @@ void Endstops::event_handler() {
       if (planner.abort_on_endstop_hit) {
         card.abortFilePrintNow();
         quickstop_stepper();
         thermalManager.disable_all_heaters();
         print_job_timer.stop();
       }
     #endif
   }
 }
 
+#pragma GCC diagnostic push
 #if GCC_VERSION <= 50000
-  #pragma GCC diagnostic push
   #pragma GCC diagnostic ignored "-Wunused-function"
 #endif
 
 static void print_es_state(const bool is_hit, FSTR_P const flabel=nullptr) {
   if (flabel) SERIAL_ECHOF(flabel);
   SERIAL_ECHOPGM(": ");
   SERIAL_ECHOLNF(is_hit ? F(STR_ENDSTOP_HIT) : F(STR_ENDSTOP_OPEN));
 }
 
-#if GCC_VERSION <= 50000
-  #pragma GCC diagnostic pop
-#endif
+#pragma GCC diagnostic pop
 
 void _O2 Endstops::report_states() {
   TERN_(BLTOUCH, bltouch._set_SW_mode());
   SERIAL_ECHOLNPGM(STR_M119_REPORT);
   #define ES_REPORT(S) print_es_state(READ(S##_PIN) != S##_ENDSTOP_INVERTING, F(STR_##S))
   #if HAS_X_MIN
     ES_REPORT(X_MIN);
   #endif
   #if HAS_X2_MIN
     ES_REPORT(X2_MIN);

commit 65b950a489c35b1d5547da3a504af4dad8cde3d7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 28 20:15:52 2021 -0500

    üé® Apply F() to kill / sendinfoscreen

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 80e20a0778..da5a0073cf 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -377,21 +377,21 @@ void Endstops::enable(const bool onoff) {
 
 // Disable / Enable endstops based on ENSTOPS_ONLY_FOR_HOMING and global enable
 void Endstops::not_homing() {
   enabled = enabled_globally;
 }
 
 #if ENABLED(VALIDATE_HOMING_ENDSTOPS)
   // If the last move failed to trigger an endstop, call kill
   void Endstops::validate_homing_move() {
     if (trigger_state()) hit_on_purpose();
-    else kill(GET_TEXT(MSG_KILL_HOMING_FAILED));
+    else kill(GET_TEXT_F(MSG_KILL_HOMING_FAILED));
   }
 #endif
 
 // Enable / disable endstop z-probe checking
 #if HAS_BED_PROBE
   void Endstops::enable_z_probe(const bool onoff) {
     z_probe_enabled = onoff;
     resync();
   }
 #endif

commit 1dafd1887e40399faf16e3455e3670ed3acfac52
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 27 13:46:42 2021 -0500

    üé® Apply F() to various reports

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index b5f270ee63..80e20a0778 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -476,34 +476,34 @@ void Endstops::event_handler() {
       }
     #endif
   }
 }
 
 #if GCC_VERSION <= 50000
   #pragma GCC diagnostic push
   #pragma GCC diagnostic ignored "-Wunused-function"
 #endif
 
-static void print_es_state(const bool is_hit, PGM_P const label=nullptr) {
-  if (label) SERIAL_ECHOPGM_P(label);
+static void print_es_state(const bool is_hit, FSTR_P const flabel=nullptr) {
+  if (flabel) SERIAL_ECHOF(flabel);
   SERIAL_ECHOPGM(": ");
-  SERIAL_ECHOLNPGM_P(is_hit ? PSTR(STR_ENDSTOP_HIT) : PSTR(STR_ENDSTOP_OPEN));
+  SERIAL_ECHOLNF(is_hit ? F(STR_ENDSTOP_HIT) : F(STR_ENDSTOP_OPEN));
 }
 
 #if GCC_VERSION <= 50000
   #pragma GCC diagnostic pop
 #endif
 
 void _O2 Endstops::report_states() {
   TERN_(BLTOUCH, bltouch._set_SW_mode());
   SERIAL_ECHOLNPGM(STR_M119_REPORT);
-  #define ES_REPORT(S) print_es_state(READ(S##_PIN) != S##_ENDSTOP_INVERTING, PSTR(STR_##S))
+  #define ES_REPORT(S) print_es_state(READ(S##_PIN) != S##_ENDSTOP_INVERTING, F(STR_##S))
   #if HAS_X_MIN
     ES_REPORT(X_MIN);
   #endif
   #if HAS_X2_MIN
     ES_REPORT(X2_MIN);
   #endif
   #if HAS_X_MAX
     ES_REPORT(X_MAX);
   #endif
   #if HAS_X2_MAX
@@ -557,41 +557,41 @@ void _O2 Endstops::report_states() {
   #if HAS_J_MAX
     ES_REPORT(J_MAX);
   #endif
     #if HAS_K_MIN
     ES_REPORT(K_MIN);
   #endif
   #if HAS_K_MAX
     ES_REPORT(K_MAX);
   #endif
   #if BOTH(MARLIN_DEV_MODE, PROBE_ACTIVATION_SWITCH)
-    print_es_state(probe_switch_activated(), PSTR(STR_PROBE_EN));
+    print_es_state(probe_switch_activated(), F(STR_PROBE_EN));
   #endif
   #if USES_Z_MIN_PROBE_PIN
-    print_es_state(PROBE_TRIGGERED(), PSTR(STR_Z_PROBE));
+    print_es_state(PROBE_TRIGGERED(), F(STR_Z_PROBE));
   #endif
   #if MULTI_FILAMENT_SENSOR
     #define _CASE_RUNOUT(N) case N: pin = FIL_RUNOUT##N##_PIN; state = FIL_RUNOUT##N##_STATE; break;
     LOOP_S_LE_N(i, 1, NUM_RUNOUT_SENSORS) {
       pin_t pin;
       uint8_t state;
       switch (i) {
         default: continue;
         REPEAT_1(NUM_RUNOUT_SENSORS, _CASE_RUNOUT)
       }
       SERIAL_ECHOPGM(STR_FILAMENT);
       if (i > 1) SERIAL_CHAR(' ', '0' + i);
       print_es_state(extDigitalRead(pin) != state);
     }
     #undef _CASE_RUNOUT
   #elif HAS_FILAMENT_SENSOR
-    print_es_state(READ(FIL_RUNOUT1_PIN) != FIL_RUNOUT1_STATE, PSTR(STR_FILAMENT));
+    print_es_state(READ(FIL_RUNOUT1_PIN) != FIL_RUNOUT1_STATE, F(STR_FILAMENT));
   #endif
 
   TERN_(BLTOUCH, bltouch._reset_SW_mode());
   TERN_(JOYSTICK_DEBUG, joystick.report());
 
 } // Endstops::report_states
 
 // The following routines are called from an ISR context. It could be the temperature ISR, the
 // endstop ISR or the Stepper ISR.
 

commit 7f1286a11f87065c4e666985e679cf9c77d668bf
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 25 17:05:11 2021 -0500

    üé® Apply F() to status message

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index d29fd3ecb3..b5f270ee63 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -453,22 +453,22 @@ void Endstops::event_handler() {
       _ENDSTOP_HIT_TEST(K,'K')
     );
 
     #if USES_Z_MIN_PROBE_PIN
       #define P_AXIS Z_AXIS
       if (TEST(hit_state, Z_MIN_PROBE)) _ENDSTOP_HIT_ECHO(P, 'P');
     #endif
     SERIAL_EOL();
 
     TERN_(HAS_STATUS_MESSAGE,
-      ui.status_printf_P(0,
-        PSTR(S_FMT GANG_N_1(LINEAR_AXES, " %c") " %c"),
+      ui.status_printf(0,
+        F(S_FMT GANG_N_1(LINEAR_AXES, " %c") " %c"),
         GET_TEXT(MSG_LCD_ENDSTOPS),
         LINEAR_AXIS_LIST(chrX, chrY, chrZ, chrI, chrJ, chrK), chrP
       )
     );
 
     #if BOTH(SD_ABORT_ON_ENDSTOP_HIT, SDSUPPORT)
       if (planner.abort_on_endstop_hit) {
         card.abortFilePrintNow();
         quickstop_stepper();
         thermalManager.disable_all_heaters();

commit 08e581d5d7c6cfcedf400862fcfcd146c6ce837f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 11 15:41:42 2021 -0500

    üé® Apply more HAS_DELTA_SENSORLESS_PROBING

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index b5315f2f01..d29fd3ecb3 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -588,21 +588,21 @@ void _O2 Endstops::report_states() {
   #endif
 
   TERN_(BLTOUCH, bltouch._reset_SW_mode());
   TERN_(JOYSTICK_DEBUG, joystick.report());
 
 } // Endstops::report_states
 
 // The following routines are called from an ISR context. It could be the temperature ISR, the
 // endstop ISR or the Stepper ISR.
 
-#if BOTH(DELTA, SENSORLESS_PROBING)
+#if HAS_DELTA_SENSORLESS_PROBING
   #define __ENDSTOP(AXIS, ...) AXIS ##_MAX
   #define _ENDSTOP_PIN(AXIS, ...) AXIS ##_MAX_PIN
   #define _ENDSTOP_INVERTING(AXIS, ...) AXIS ##_MAX_ENDSTOP_INVERTING
 #else
   #define __ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
   #define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN
   #define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_INVERTING
 #endif
 #define _ENDSTOP(AXIS, MINMAX) __ENDSTOP(AXIS, MINMAX)
 

commit 754b31918a73cb08c322102be5d3926d2ac59c18
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 9 04:57:05 2021 -0500

    üé® Fewer serial macros

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 8ca19e4361..b5315f2f01 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -422,21 +422,21 @@ void Endstops::event_handler() {
   if (hit_state) {
     #if HAS_STATUS_MESSAGE
       char LINEAR_AXIS_LIST(chrX = ' ', chrY = ' ', chrZ = ' ', chrI = ' ', chrJ = ' ', chrK = ' '),
            chrP = ' ';
       #define _SET_STOP_CHAR(A,C) (chr## A = C)
     #else
       #define _SET_STOP_CHAR(A,C) NOOP
     #endif
 
     #define _ENDSTOP_HIT_ECHO(A,C) do{ \
-      SERIAL_ECHOPAIR(" " STRINGIFY(A) ":", planner.triggered_position_mm(_AXIS(A))); _SET_STOP_CHAR(A,C); }while(0)
+      SERIAL_ECHOPGM(" " STRINGIFY(A) ":", planner.triggered_position_mm(_AXIS(A))); _SET_STOP_CHAR(A,C); }while(0)
 
     #define _ENDSTOP_HIT_TEST(A,C) \
       if (TERN0(HAS_##A##_MIN, TEST(hit_state, A##_MIN)) || TERN0(HAS_##A##_MAX, TEST(hit_state, A##_MAX))) \
         _ENDSTOP_HIT_ECHO(A,C)
 
     #define ENDSTOP_HIT_TEST_X() _ENDSTOP_HIT_TEST(X,'X')
     #define ENDSTOP_HIT_TEST_Y() _ENDSTOP_HIT_TEST(Y,'Y')
     #define ENDSTOP_HIT_TEST_Z() _ENDSTOP_HIT_TEST(Z,'Z')
     #define ENDSTOP_HIT_TEST_I() _ENDSTOP_HIT_TEST(I,'I')
     #define ENDSTOP_HIT_TEST_J() _ENDSTOP_HIT_TEST(J,'J')
@@ -1264,21 +1264,21 @@ void Endstops::update() {
       ES_GET_STATE(J_MIN);
     #endif
     #if HAS_K_MAX
       ES_GET_STATE(K_MAX);
     #endif
     #if HAS_K_MIN
       ES_GET_STATE(K_MIN);
     #endif
 
     uint16_t endstop_change = live_state_local ^ old_live_state_local;
-    #define ES_REPORT_CHANGE(S) if (TEST(endstop_change, S)) SERIAL_ECHOPAIR("  " STRINGIFY(S) ":", TEST(live_state_local, S))
+    #define ES_REPORT_CHANGE(S) if (TEST(endstop_change, S)) SERIAL_ECHOPGM("  " STRINGIFY(S) ":", TEST(live_state_local, S))
 
     if (endstop_change) {
       #if HAS_X_MIN
         ES_REPORT_CHANGE(X_MIN);
       #endif
       #if HAS_X_MAX
         ES_REPORT_CHANGE(X_MAX);
       #endif
       #if HAS_Y_MIN
         ES_REPORT_CHANGE(Y_MIN);

commit 79c72ed821564507b0ef46cbb26f9577585e2ccc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 7 18:06:10 2021 -0500

    üé® Standardize G-code reporting

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 0f4716ed87..8ca19e4361 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -571,27 +571,27 @@ void _O2 Endstops::report_states() {
   #endif
   #if MULTI_FILAMENT_SENSOR
     #define _CASE_RUNOUT(N) case N: pin = FIL_RUNOUT##N##_PIN; state = FIL_RUNOUT##N##_STATE; break;
     LOOP_S_LE_N(i, 1, NUM_RUNOUT_SENSORS) {
       pin_t pin;
       uint8_t state;
       switch (i) {
         default: continue;
         REPEAT_1(NUM_RUNOUT_SENSORS, _CASE_RUNOUT)
       }
-      SERIAL_ECHOPGM(STR_FILAMENT_RUNOUT_SENSOR);
+      SERIAL_ECHOPGM(STR_FILAMENT);
       if (i > 1) SERIAL_CHAR(' ', '0' + i);
       print_es_state(extDigitalRead(pin) != state);
     }
     #undef _CASE_RUNOUT
   #elif HAS_FILAMENT_SENSOR
-    print_es_state(READ(FIL_RUNOUT1_PIN) != FIL_RUNOUT1_STATE, PSTR(STR_FILAMENT_RUNOUT_SENSOR));
+    print_es_state(READ(FIL_RUNOUT1_PIN) != FIL_RUNOUT1_STATE, PSTR(STR_FILAMENT));
   #endif
 
   TERN_(BLTOUCH, bltouch._reset_SW_mode());
   TERN_(JOYSTICK_DEBUG, joystick.report());
 
 } // Endstops::report_states
 
 // The following routines are called from an ISR context. It could be the temperature ISR, the
 // endstop ISR or the Stepper ISR.
 

commit afca6e745932d295b88d37fa9bd4274e22705b0b
Author: luzpaz <luzpaz@users.noreply.github.com>
Date:   Tue Aug 3 20:02:34 2021 -0400

    üêõ Spellcheck comments (#22496)
    
    codespell -q 3 --builtin=clear,rare,informal,code -S ./Marlin/src/lcd/language -L alo,amin,endcode,stdio,uint

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 523e133713..0f4716ed87 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -877,41 +877,41 @@ void Endstops::update() {
       _ENDSTOP_HIT(A2,M2); \
       planner.endstop_triggered(_AXIS(A2)); \
     } \
   }while(0)
 
   // Call the endstop triggered routine for dual endstops
   #define PROCESS_DUAL_ENDSTOP(A, MINMAX) do { \
     const byte dual_hit = TEST_ENDSTOP(_ENDSTOP(A, MINMAX)) | (TEST_ENDSTOP(_ENDSTOP(A##2, MINMAX)) << 1); \
     if (dual_hit) { \
       _ENDSTOP_HIT(A, MINMAX); \
-      /* if not performing home or if both endstops were trigged during homing... */ \
+      /* if not performing home or if both endstops were triggered during homing... */ \
       if (!stepper.separate_multi_axis || dual_hit == 0b11) \
         planner.endstop_triggered(_AXIS(A)); \
     } \
   }while(0)
 
   #define PROCESS_TRIPLE_ENDSTOP(A, MINMAX) do { \
     const byte triple_hit = TEST_ENDSTOP(_ENDSTOP(A, MINMAX)) | (TEST_ENDSTOP(_ENDSTOP(A##2, MINMAX)) << 1) | (TEST_ENDSTOP(_ENDSTOP(A##3, MINMAX)) << 2); \
     if (triple_hit) { \
       _ENDSTOP_HIT(A, MINMAX); \
-      /* if not performing home or if both endstops were trigged during homing... */ \
+      /* if not performing home or if both endstops were triggered during homing... */ \
       if (!stepper.separate_multi_axis || triple_hit == 0b111) \
         planner.endstop_triggered(_AXIS(A)); \
     } \
   }while(0)
 
   #define PROCESS_QUAD_ENDSTOP(A, MINMAX) do { \
     const byte quad_hit = TEST_ENDSTOP(_ENDSTOP(A, MINMAX)) | (TEST_ENDSTOP(_ENDSTOP(A##2, MINMAX)) << 1) | (TEST_ENDSTOP(_ENDSTOP(A##3, MINMAX)) << 2) | (TEST_ENDSTOP(_ENDSTOP(A##4, MINMAX)) << 3); \
     if (quad_hit) { \
       _ENDSTOP_HIT(A, MINMAX); \
-      /* if not performing home or if both endstops were trigged during homing... */ \
+      /* if not performing home or if both endstops were triggered during homing... */ \
       if (!stepper.separate_multi_axis || quad_hit == 0b1111) \
         planner.endstop_triggered(_AXIS(A)); \
     } \
   }while(0)
 
   #if ENABLED(X_DUAL_ENDSTOPS)
     #define PROCESS_ENDSTOP_X(MINMAX) PROCESS_DUAL_ENDSTOP(X, MINMAX)
   #else
     #define PROCESS_ENDSTOP_X(MINMAX) if (X_##MINMAX##_TEST()) PROCESS_ENDSTOP(X, MINMAX)
   #endif

commit 0eda34e07d6b15ac889d21d84457401683c0345f
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Mon Aug 2 07:13:57 2021 +0200

    üêõ Followup to 6 linear axes (#22482)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 25c26aa7b5..523e133713 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -747,86 +747,86 @@ void Endstops::update() {
         #else
           COPY_LIVE_STATE(Z_MAX, Z4_MAX);
         #endif
       #endif
     #elif TERN1(USES_Z_MIN_PROBE_PIN, Z_MAX_PIN != Z_MIN_PROBE_PIN)
       // If this pin isn't the bed probe it's the Z endstop
       UPDATE_ENDSTOP_BIT(Z, MAX);
     #endif
   #endif
 
-  #if HAS_I_MIN
+  #if HAS_I_MIN && !I_SPI_SENSORLESS
     #if ENABLED(I_DUAL_ENDSTOPS)
       UPDATE_ENDSTOP_BIT(I, MIN);
       #if HAS_I2_MIN
         UPDATE_ENDSTOP_BIT(I2, MAX);
       #else
         COPY_LIVE_STATE(I_MIN, I2_MIN);
       #endif
     #else
       UPDATE_ENDSTOP_BIT(I, MIN);
     #endif
   #endif
 
-  #if HAS_I_MAX
+  #if HAS_I_MAX && !I_SPI_SENSORLESS
     #if ENABLED(I_DUAL_ENDSTOPS)
       UPDATE_ENDSTOP_BIT(I, MAX);
       #if HAS_I2_MAX
         UPDATE_ENDSTOP_BIT(I2, MAX);
       #else
         COPY_LIVE_STATE(I_MAX, I2_MAX);
       #endif
     #else
       UPDATE_ENDSTOP_BIT(I, MAX);
     #endif
   #endif
 
-  #if HAS_J_MIN
+  #if HAS_J_MIN && !J_SPI_SENSORLESS
     #if ENABLED(J_DUAL_ENDSTOPS)
       UPDATE_ENDSTOP_BIT(J, MIN);
       #if HAS_J2_MIN
         UPDATE_ENDSTOP_BIT(J2, MIN);
       #else
         COPY_LIVE_STATE(J_MIN, J2_MIN);
       #endif
     #else
       UPDATE_ENDSTOP_BIT(J, MIN);
     #endif
   #endif
 
-  #if HAS_J_MAX
+  #if HAS_J_MAX && !J_SPI_SENSORLESS
     #if ENABLED(J_DUAL_ENDSTOPS)
       UPDATE_ENDSTOP_BIT(J, MAX);
       #if HAS_J2_MAX
         UPDATE_ENDSTOP_BIT(J2, MAX);
       #else
         COPY_LIVE_STATE(J_MAX, J2_MAX);
       #endif
     #else
       UPDATE_ENDSTOP_BIT(J, MAX);
     #endif
   #endif
 
-  #if HAS_K_MIN
+  #if HAS_K_MIN && !K_SPI_SENSORLESS
     #if ENABLED(K_DUAL_ENDSTOPS)
       UPDATE_ENDSTOP_BIT(K, MIN);
       #if HAS_K2_MIN
         UPDATE_ENDSTOP_BIT(K2, MIN);
       #else
         COPY_LIVE_STATE(K_MIN, K2_MIN);
       #endif
     #else
       UPDATE_ENDSTOP_BIT(K, MIN);
     #endif
   #endif
 
-  #if HAS_K_MAX
+  #if HAS_K_MAX && !K_SPI_SENSORLESS
     #if ENABLED(K_DUAL_ENDSTOPS)
       UPDATE_ENDSTOP_BIT(K, MAX);
       #if HAS_K2_MAX
         UPDATE_ENDSTOP_BIT(K2, MAX);
       #else
         COPY_LIVE_STATE(K_MAX, K2_MAX);
       #endif
     #else
       UPDATE_ENDSTOP_BIT(K, MAX);
     #endif

commit a90c8b762c8b8ca06093d6e62f4355e8a5726115
Author: Grayson <mxpklx@gmail.com>
Date:   Sat Jul 31 22:55:22 2021 -0500

    üêõ Fix G38 with probe on Z_MIN (#22452)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 39aefd21d8..25c26aa7b5 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -589,42 +589,44 @@ void _O2 Endstops::report_states() {
 
   TERN_(BLTOUCH, bltouch._reset_SW_mode());
   TERN_(JOYSTICK_DEBUG, joystick.report());
 
 } // Endstops::report_states
 
 // The following routines are called from an ISR context. It could be the temperature ISR, the
 // endstop ISR or the Stepper ISR.
 
 #if BOTH(DELTA, SENSORLESS_PROBING)
-  #define _ENDSTOP(AXIS, MINMAX) AXIS ##_MAX
-  #define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_MAX_PIN
-  #define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_MAX_ENDSTOP_INVERTING
+  #define __ENDSTOP(AXIS, ...) AXIS ##_MAX
+  #define _ENDSTOP_PIN(AXIS, ...) AXIS ##_MAX_PIN
+  #define _ENDSTOP_INVERTING(AXIS, ...) AXIS ##_MAX_ENDSTOP_INVERTING
 #else
-  #define _ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
+  #define __ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
   #define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN
   #define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_INVERTING
 #endif
+#define _ENDSTOP(AXIS, MINMAX) __ENDSTOP(AXIS, MINMAX)
 
 // Check endstops - Could be called from Temperature ISR!
 void Endstops::update() {
 
   #if !ENDSTOP_NOISE_THRESHOLD
     if (!abort_enabled()) return;
   #endif
 
   #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT_TO(live_state, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
   #define COPY_LIVE_STATE(SRC_BIT, DST_BIT) SET_BIT_TO(live_state, DST_BIT, TEST(live_state, SRC_BIT))
 
-  #if BOTH(G38_PROBE_TARGET, HAS_Z_MIN_PROBE_PIN) && NONE(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY)
-    // If G38 command is active check Z_MIN_PROBE for ALL movement
-    if (G38_move) UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
+  #if ENABLED(G38_PROBE_TARGET) && NONE(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY)
+    #define HAS_G38_PROBE 1
+    // For G38 moves check the probe's pin for ALL movement
+    if (G38_move) UPDATE_ENDSTOP_BIT(Z, TERN(USES_Z_MIN_PROBE_PIN, MIN_PROBE, MIN));
   #endif
 
   // With Dual X, endstops are only checked in the homing direction for the active extruder
   #define X_MIN_TEST() TERN1(DUAL_X_CARRIAGE, TERN0(X_HOME_TO_MIN, stepper.last_moved_extruder == 0) || TERN0(X2_HOME_TO_MIN, stepper.last_moved_extruder != 0))
   #define X_MAX_TEST() TERN1(DUAL_X_CARRIAGE, TERN0(X_HOME_TO_MAX, stepper.last_moved_extruder == 0) || TERN0(X2_HOME_TO_MAX, stepper.last_moved_extruder != 0))
 
   // Use HEAD for core axes, AXIS for others
   #if ANY(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY)
     #define X_AXIS_HEAD X_HEAD
   #else
@@ -739,21 +741,21 @@ void Endstops::update() {
           COPY_LIVE_STATE(Z_MAX, Z3_MAX);
         #endif
       #endif
       #if NUM_Z_STEPPER_DRIVERS >= 4
         #if HAS_Z4_MAX
           UPDATE_ENDSTOP_BIT(Z4, MAX);
         #else
           COPY_LIVE_STATE(Z_MAX, Z4_MAX);
         #endif
       #endif
-    #elif !USES_Z_MIN_PROBE_PIN || Z_MAX_PIN != Z_MIN_PROBE_PIN
+    #elif TERN1(USES_Z_MIN_PROBE_PIN, Z_MAX_PIN != Z_MIN_PROBE_PIN)
       // If this pin isn't the bed probe it's the Z endstop
       UPDATE_ENDSTOP_BIT(Z, MAX);
     #endif
   #endif
 
   #if HAS_I_MIN
     #if ENABLED(I_DUAL_ENDSTOPS)
       UPDATE_ENDSTOP_BIT(I, MIN);
       #if HAS_I2_MIN
         UPDATE_ENDSTOP_BIT(I2, MAX);
@@ -923,29 +925,25 @@ void Endstops::update() {
   #if DISABLED(Z_MULTI_ENDSTOPS)
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_ENDSTOP(Z, MINMAX)
   #elif NUM_Z_STEPPER_DRIVERS == 4
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_QUAD_ENDSTOP(Z, MINMAX)
   #elif NUM_Z_STEPPER_DRIVERS == 3
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_TRIPLE_ENDSTOP(Z, MINMAX)
   #else
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_DUAL_ENDSTOP(Z, MINMAX)
   #endif
 
-  #if BOTH(G38_PROBE_TARGET, HAS_Z_MIN_PROBE_PIN) && NONE(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY)
-    #if ENABLED(G38_PROBE_AWAY)
-      #define _G38_OPEN_STATE (G38_move >= 4)
-    #else
-      #define _G38_OPEN_STATE LOW
-    #endif
-    // If G38 command is active check Z_MIN_PROBE for ALL movement
-    if (G38_move && TEST_ENDSTOP(_ENDSTOP(Z, MIN_PROBE)) != _G38_OPEN_STATE) {
-           if (stepper.axis_is_moving(X_AXIS)) { _ENDSTOP_HIT(X, TERN(X_HOME_TO_MIN, MIN, MAX)); planner.endstop_triggered(X_AXIS); }
+  #if HAS_G38_PROBE
+    #define _G38_OPEN_STATE TERN(G38_PROBE_AWAY, (G38_move >= 4), LOW)
+    // For G38 moves check the probe's pin for ALL movement
+    if (G38_move && TEST_ENDSTOP(_ENDSTOP(Z, TERN(USES_Z_MIN_PROBE_PIN, MIN_PROBE, MIN))) != _G38_OPEN_STATE) {
+             if (stepper.axis_is_moving(X_AXIS)) { _ENDSTOP_HIT(X, TERN(X_HOME_TO_MIN, MIN, MAX)); planner.endstop_triggered(X_AXIS); }
       #if HAS_Y_AXIS
         else if (stepper.axis_is_moving(Y_AXIS)) { _ENDSTOP_HIT(Y, TERN(Y_HOME_TO_MIN, MIN, MAX)); planner.endstop_triggered(Y_AXIS); }
       #endif
       #if HAS_Z_AXIS
         else if (stepper.axis_is_moving(Z_AXIS)) { _ENDSTOP_HIT(Z, TERN(Z_HOME_TO_MIN, MIN, MAX)); planner.endstop_triggered(Z_AXIS); }
       #endif
       G38_did_trigger = true;
     }
   #endif
 
@@ -1036,21 +1034,21 @@ void Endstops::update() {
 
         // When closing the gap check the enabled probe
         #if USES_Z_MIN_PROBE_PIN
           if (z_probe_enabled) PROCESS_ENDSTOP(Z, MIN_PROBE);
         #endif
       }
       else { // Z +direction. Gantry up, bed down.
         #if HAS_Z_MAX || (Z_SPI_SENSORLESS && Z_HOME_TO_MAX)
           #if ENABLED(Z_MULTI_ENDSTOPS)
             PROCESS_ENDSTOP_Z(MAX);
-          #elif !USES_Z_MIN_PROBE_PIN || Z_MAX_PIN != Z_MIN_PROBE_PIN  // No probe or probe is Z_MIN || Probe is not Z_MAX
+          #elif TERN1(USES_Z_MIN_PROBE_PIN, Z_MAX_PIN != Z_MIN_PROBE_PIN)  // No probe or probe is Z_MIN || Probe is not Z_MAX
             PROCESS_ENDSTOP(Z, MAX);
           #endif
           #if   CORE_DIAG(XZ, X, MIN)
             PROCESS_CORE_ENDSTOP(X,MIN,Z,MAX);
           #elif CORE_DIAG(XZ, X, MAX)
             PROCESS_CORE_ENDSTOP(X,MAX,Z,MAX);
           #elif CORE_DIAG(YZ, Y, MIN)
             PROCESS_CORE_ENDSTOP(Y,MIN,Z,MAX);
           #elif CORE_DIAG(YZ, Y, MAX)
             PROCESS_CORE_ENDSTOP(Y,MAX,Z,MAX);

commit 363e83731f7b045d7b3e9842882b1f53e032ca89
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jul 28 23:24:30 2021 -0500

    üîß HAS_CUSTOM_PROBE_PIN => USES_Z_MIN_PROBE_PIN

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 420acccb58..39aefd21d8 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -322,21 +322,21 @@ void Endstops::init() {
   #if PIN_EXISTS(CALIBRATION)
     #if ENABLED(CALIBRATION_PIN_PULLUP)
       SET_INPUT_PULLUP(CALIBRATION_PIN);
     #elif ENABLED(CALIBRATION_PIN_PULLDOWN)
       SET_INPUT_PULLDOWN(CALIBRATION_PIN);
     #else
       SET_INPUT(CALIBRATION_PIN);
     #endif
   #endif
 
-  #if HAS_CUSTOM_PROBE_PIN
+  #if USES_Z_MIN_PROBE_PIN
     #if ENABLED(ENDSTOPPULLUP_ZMIN_PROBE)
       SET_INPUT_PULLUP(Z_MIN_PROBE_PIN);
     #elif ENABLED(ENDSTOPPULLDOWN_ZMIN_PROBE)
       SET_INPUT_PULLDOWN(Z_MIN_PROBE_PIN);
     #else
       SET_INPUT(Z_MIN_PROBE_PIN);
     #endif
   #endif
 
   #if ENABLED(PROBE_ACTIVATION_SWITCH)
@@ -446,21 +446,21 @@ void Endstops::event_handler() {
     SERIAL_ECHOPGM(STR_ENDSTOPS_HIT);
     LINEAR_AXIS_CODE(
        ENDSTOP_HIT_TEST_X(),
        ENDSTOP_HIT_TEST_Y(),
        ENDSTOP_HIT_TEST_Z(),
       _ENDSTOP_HIT_TEST(I,'I'),
       _ENDSTOP_HIT_TEST(J,'J'),
       _ENDSTOP_HIT_TEST(K,'K')
     );
 
-    #if HAS_CUSTOM_PROBE_PIN
+    #if USES_Z_MIN_PROBE_PIN
       #define P_AXIS Z_AXIS
       if (TEST(hit_state, Z_MIN_PROBE)) _ENDSTOP_HIT_ECHO(P, 'P');
     #endif
     SERIAL_EOL();
 
     TERN_(HAS_STATUS_MESSAGE,
       ui.status_printf_P(0,
         PSTR(S_FMT GANG_N_1(LINEAR_AXES, " %c") " %c"),
         GET_TEXT(MSG_LCD_ENDSTOPS),
         LINEAR_AXIS_LIST(chrX, chrY, chrZ, chrI, chrJ, chrK), chrP
@@ -559,21 +559,21 @@ void _O2 Endstops::report_states() {
   #endif
     #if HAS_K_MIN
     ES_REPORT(K_MIN);
   #endif
   #if HAS_K_MAX
     ES_REPORT(K_MAX);
   #endif
   #if BOTH(MARLIN_DEV_MODE, PROBE_ACTIVATION_SWITCH)
     print_es_state(probe_switch_activated(), PSTR(STR_PROBE_EN));
   #endif
-  #if HAS_CUSTOM_PROBE_PIN
+  #if USES_Z_MIN_PROBE_PIN
     print_es_state(PROBE_TRIGGERED(), PSTR(STR_Z_PROBE));
   #endif
   #if MULTI_FILAMENT_SENSOR
     #define _CASE_RUNOUT(N) case N: pin = FIL_RUNOUT##N##_PIN; state = FIL_RUNOUT##N##_STATE; break;
     LOOP_S_LE_N(i, 1, NUM_RUNOUT_SENSORS) {
       pin_t pin;
       uint8_t state;
       switch (i) {
         default: continue;
         REPEAT_1(NUM_RUNOUT_SENSORS, _CASE_RUNOUT)
@@ -713,21 +713,21 @@ void Endstops::update() {
         #else
           COPY_LIVE_STATE(Z_MIN, Z4_MIN);
         #endif
       #endif
     #endif
   #endif
 
   #if HAS_BED_PROBE
     // When closing the gap check the enabled probe
     if (probe_switch_activated())
-      UPDATE_ENDSTOP_BIT(Z, TERN(HAS_CUSTOM_PROBE_PIN, MIN_PROBE, MIN));
+      UPDATE_ENDSTOP_BIT(Z, TERN(USES_Z_MIN_PROBE_PIN, MIN_PROBE, MIN));
   #endif
 
   #if HAS_Z_MAX && !Z_SPI_SENSORLESS
     // Check both Z dual endstops
     #if ENABLED(Z_MULTI_ENDSTOPS)
       UPDATE_ENDSTOP_BIT(Z, MAX);
       #if HAS_Z2_MAX
         UPDATE_ENDSTOP_BIT(Z2, MAX);
       #else
         COPY_LIVE_STATE(Z_MAX, Z2_MAX);
@@ -739,21 +739,21 @@ void Endstops::update() {
           COPY_LIVE_STATE(Z_MAX, Z3_MAX);
         #endif
       #endif
       #if NUM_Z_STEPPER_DRIVERS >= 4
         #if HAS_Z4_MAX
           UPDATE_ENDSTOP_BIT(Z4, MAX);
         #else
           COPY_LIVE_STATE(Z_MAX, Z4_MAX);
         #endif
       #endif
-    #elif !HAS_CUSTOM_PROBE_PIN || Z_MAX_PIN != Z_MIN_PROBE_PIN
+    #elif !USES_Z_MIN_PROBE_PIN || Z_MAX_PIN != Z_MIN_PROBE_PIN
       // If this pin isn't the bed probe it's the Z endstop
       UPDATE_ENDSTOP_BIT(Z, MAX);
     #endif
   #endif
 
   #if HAS_I_MIN
     #if ENABLED(I_DUAL_ENDSTOPS)
       UPDATE_ENDSTOP_BIT(I, MIN);
       #if HAS_I2_MIN
         UPDATE_ENDSTOP_BIT(I2, MAX);
@@ -1014,43 +1014,43 @@ void Endstops::update() {
       }
     }
   #endif
 
   #if HAS_Z_AXIS
     if (stepper.axis_is_moving(Z_AXIS)) {
       if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
 
         #if HAS_Z_MIN || (Z_SPI_SENSORLESS && Z_HOME_TO_MIN)
           if ( TERN1(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN, z_probe_enabled)
-            && TERN1(HAS_CUSTOM_PROBE_PIN, !z_probe_enabled)
+            && TERN1(USES_Z_MIN_PROBE_PIN, !z_probe_enabled)
           ) PROCESS_ENDSTOP_Z(MIN);
           #if   CORE_DIAG(XZ, X, MIN)
             PROCESS_CORE_ENDSTOP(X,MIN,Z,MIN);
           #elif CORE_DIAG(XZ, X, MAX)
             PROCESS_CORE_ENDSTOP(X,MAX,Z,MIN);
           #elif CORE_DIAG(YZ, Y, MIN)
             PROCESS_CORE_ENDSTOP(Y,MIN,Z,MIN);
           #elif CORE_DIAG(YZ, Y, MAX)
             PROCESS_CORE_ENDSTOP(Y,MAX,Z,MIN);
           #endif
         #endif
 
         // When closing the gap check the enabled probe
-        #if HAS_CUSTOM_PROBE_PIN
+        #if USES_Z_MIN_PROBE_PIN
           if (z_probe_enabled) PROCESS_ENDSTOP(Z, MIN_PROBE);
         #endif
       }
       else { // Z +direction. Gantry up, bed down.
         #if HAS_Z_MAX || (Z_SPI_SENSORLESS && Z_HOME_TO_MAX)
           #if ENABLED(Z_MULTI_ENDSTOPS)
             PROCESS_ENDSTOP_Z(MAX);
-          #elif !HAS_CUSTOM_PROBE_PIN || Z_MAX_PIN != Z_MIN_PROBE_PIN  // No probe or probe is Z_MIN || Probe is not Z_MAX
+          #elif !USES_Z_MIN_PROBE_PIN || Z_MAX_PIN != Z_MIN_PROBE_PIN  // No probe or probe is Z_MIN || Probe is not Z_MAX
             PROCESS_ENDSTOP(Z, MAX);
           #endif
           #if   CORE_DIAG(XZ, X, MIN)
             PROCESS_CORE_ENDSTOP(X,MIN,Z,MAX);
           #elif CORE_DIAG(XZ, X, MAX)
             PROCESS_CORE_ENDSTOP(X,MAX,Z,MAX);
           #elif CORE_DIAG(YZ, Y, MIN)
             PROCESS_CORE_ENDSTOP(Y,MIN,Z,MAX);
           #elif CORE_DIAG(YZ, Y, MAX)
             PROCESS_CORE_ENDSTOP(Y,MAX,Z,MAX);

commit 05ebde38127ca6c3bc056cb4068a414bade766b4
Author: lujios <83166168+lujios@users.noreply.github.com>
Date:   Tue Jul 13 02:19:29 2021 +0200

    ‚ö°Ô∏è Improve Sensorless homing/probing for G28, G33 (#21899)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 8f6827de27..420acccb58 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -588,23 +588,29 @@ void _O2 Endstops::report_states() {
   #endif
 
   TERN_(BLTOUCH, bltouch._reset_SW_mode());
   TERN_(JOYSTICK_DEBUG, joystick.report());
 
 } // Endstops::report_states
 
 // The following routines are called from an ISR context. It could be the temperature ISR, the
 // endstop ISR or the Stepper ISR.
 
-#define _ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
-#define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN
-#define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_INVERTING
+#if BOTH(DELTA, SENSORLESS_PROBING)
+  #define _ENDSTOP(AXIS, MINMAX) AXIS ##_MAX
+  #define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_MAX_PIN
+  #define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_MAX_ENDSTOP_INVERTING
+#else
+  #define _ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
+  #define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN
+  #define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_INVERTING
+#endif
 
 // Check endstops - Could be called from Temperature ISR!
 void Endstops::update() {
 
   #if !ENDSTOP_NOISE_THRESHOLD
     if (!abort_enabled()) return;
   #endif
 
   #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT_TO(live_state, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
   #define COPY_LIVE_STATE(SRC_BIT, DST_BIT) SET_BIT_TO(live_state, DST_BIT, TEST(live_state, SRC_BIT))

commit 500b7872fb92d35dd0d1a690f4e5cf1aadea2f46
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 25 14:44:51 2021 -0500

    üêõ Trigger existing endstops on G38 hit

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index c750d56713..8f6827de27 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -925,23 +925,27 @@ void Endstops::update() {
   #endif
 
   #if BOTH(G38_PROBE_TARGET, HAS_Z_MIN_PROBE_PIN) && NONE(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY)
     #if ENABLED(G38_PROBE_AWAY)
       #define _G38_OPEN_STATE (G38_move >= 4)
     #else
       #define _G38_OPEN_STATE LOW
     #endif
     // If G38 command is active check Z_MIN_PROBE for ALL movement
     if (G38_move && TEST_ENDSTOP(_ENDSTOP(Z, MIN_PROBE)) != _G38_OPEN_STATE) {
-           if (stepper.axis_is_moving(X_AXIS)) { _ENDSTOP_HIT(X, MIN); planner.endstop_triggered(X_AXIS); }
-      else if (stepper.axis_is_moving(Y_AXIS)) { _ENDSTOP_HIT(Y, MIN); planner.endstop_triggered(Y_AXIS); }
-      else if (stepper.axis_is_moving(Z_AXIS)) { _ENDSTOP_HIT(Z, MIN); planner.endstop_triggered(Z_AXIS); }
+           if (stepper.axis_is_moving(X_AXIS)) { _ENDSTOP_HIT(X, TERN(X_HOME_TO_MIN, MIN, MAX)); planner.endstop_triggered(X_AXIS); }
+      #if HAS_Y_AXIS
+        else if (stepper.axis_is_moving(Y_AXIS)) { _ENDSTOP_HIT(Y, TERN(Y_HOME_TO_MIN, MIN, MAX)); planner.endstop_triggered(Y_AXIS); }
+      #endif
+      #if HAS_Z_AXIS
+        else if (stepper.axis_is_moving(Z_AXIS)) { _ENDSTOP_HIT(Z, TERN(Z_HOME_TO_MIN, MIN, MAX)); planner.endstop_triggered(Z_AXIS); }
+      #endif
       G38_did_trigger = true;
     }
   #endif
 
   // Signal, after validation, if an endstop limit is pressed or not
 
   if (stepper.axis_is_moving(X_AXIS)) {
     if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
       #if HAS_X_MIN || (X_SPI_SENSORLESS && X_HOME_TO_MIN)
         PROCESS_ENDSTOP_X(MIN);

commit 7726af9c5348c1c7d0fd9a56eca87d00cd75fee6
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Sat Jun 5 09:18:47 2021 +0200

    üèóÔ∏è Support for up to 6 linear axes (#19112)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index cf152ff028..c750d56713 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -252,20 +252,80 @@ void Endstops::init() {
   #if HAS_Z4_MAX
     #if ENABLED(ENDSTOPPULLUP_ZMAX)
       SET_INPUT_PULLUP(Z4_MAX_PIN);
     #elif ENABLED(ENDSTOPPULLDOWN_ZMAX)
       SET_INPUT_PULLDOWN(Z4_MAX_PIN);
     #else
       SET_INPUT(Z4_MAX_PIN);
     #endif
   #endif
 
+  #if HAS_I_MIN
+    #if ENABLED(ENDSTOPPULLUP_IMIN)
+      SET_INPUT_PULLUP(I_MIN_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_IMIN)
+      SET_INPUT_PULLDOWN(I_MIN_PIN);
+    #else
+      SET_INPUT(I_MIN_PIN);
+    #endif
+  #endif
+
+  #if HAS_I_MAX
+    #if ENABLED(ENDSTOPPULLUP_IMAX)
+      SET_INPUT_PULLUP(I_MAX_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_IMAX)
+      SET_INPUT_PULLDOWN(I_MAX_PIN);
+    #else
+      SET_INPUT(I_MAX_PIN);
+    #endif
+  #endif
+
+  #if HAS_J_MIN
+    #if ENABLED(ENDSTOPPULLUP_JMIN)
+      SET_INPUT_PULLUP(J_MIN_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_IMIN)
+      SET_INPUT_PULLDOWN(J_MIN_PIN);
+    #else
+      SET_INPUT(J_MIN_PIN);
+    #endif
+  #endif
+
+  #if HAS_J_MAX
+    #if ENABLED(ENDSTOPPULLUP_JMAX)
+      SET_INPUT_PULLUP(J_MAX_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_JMAX)
+      SET_INPUT_PULLDOWN(J_MAX_PIN);
+    #else
+      SET_INPUT(J_MAX_PIN);
+    #endif
+  #endif
+
+  #if HAS_K_MIN
+    #if ENABLED(ENDSTOPPULLUP_KMIN)
+      SET_INPUT_PULLUP(K_MIN_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_KMIN)
+      SET_INPUT_PULLDOWN(K_MIN_PIN);
+    #else
+      SET_INPUT(K_MIN_PIN);
+    #endif
+  #endif
+
+  #if HAS_K_MAX
+    #if ENABLED(ENDSTOPPULLUP_KMAX)
+      SET_INPUT_PULLUP(K_MAX_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_KMIN)
+      SET_INPUT_PULLDOWN(K_MAX_PIN);
+    #else
+      SET_INPUT(K_MAX_PIN);
+    #endif
+  #endif
+
   #if PIN_EXISTS(CALIBRATION)
     #if ENABLED(CALIBRATION_PIN_PULLUP)
       SET_INPUT_PULLUP(CALIBRATION_PIN);
     #elif ENABLED(CALIBRATION_PIN_PULLDOWN)
       SET_INPUT_PULLDOWN(CALIBRATION_PIN);
     #else
       SET_INPUT(CALIBRATION_PIN);
     #endif
   #endif
 
@@ -354,55 +414,63 @@ void Endstops::resync() {
     if (!monitor_count) monitor();      // report changes in endstop status
   }
 #endif
 
 void Endstops::event_handler() {
   static endstop_mask_t prev_hit_state; // = 0
   if (hit_state == prev_hit_state) return;
   prev_hit_state = hit_state;
   if (hit_state) {
     #if HAS_STATUS_MESSAGE
-      char LINEAR_AXIS_LIST(chrX = ' ', chrY = ' ', chrZ = ' '),
+      char LINEAR_AXIS_LIST(chrX = ' ', chrY = ' ', chrZ = ' ', chrI = ' ', chrJ = ' ', chrK = ' '),
            chrP = ' ';
       #define _SET_STOP_CHAR(A,C) (chr## A = C)
     #else
       #define _SET_STOP_CHAR(A,C) NOOP
     #endif
 
     #define _ENDSTOP_HIT_ECHO(A,C) do{ \
       SERIAL_ECHOPAIR(" " STRINGIFY(A) ":", planner.triggered_position_mm(_AXIS(A))); _SET_STOP_CHAR(A,C); }while(0)
 
     #define _ENDSTOP_HIT_TEST(A,C) \
       if (TERN0(HAS_##A##_MIN, TEST(hit_state, A##_MIN)) || TERN0(HAS_##A##_MAX, TEST(hit_state, A##_MAX))) \
         _ENDSTOP_HIT_ECHO(A,C)
 
     #define ENDSTOP_HIT_TEST_X() _ENDSTOP_HIT_TEST(X,'X')
     #define ENDSTOP_HIT_TEST_Y() _ENDSTOP_HIT_TEST(Y,'Y')
     #define ENDSTOP_HIT_TEST_Z() _ENDSTOP_HIT_TEST(Z,'Z')
+    #define ENDSTOP_HIT_TEST_I() _ENDSTOP_HIT_TEST(I,'I')
+    #define ENDSTOP_HIT_TEST_J() _ENDSTOP_HIT_TEST(J,'J')
+    #define ENDSTOP_HIT_TEST_K() _ENDSTOP_HIT_TEST(K,'K')
 
     SERIAL_ECHO_START();
     SERIAL_ECHOPGM(STR_ENDSTOPS_HIT);
-    ENDSTOP_HIT_TEST_X();
-    ENDSTOP_HIT_TEST_Y();
-    ENDSTOP_HIT_TEST_Z();
+    LINEAR_AXIS_CODE(
+       ENDSTOP_HIT_TEST_X(),
+       ENDSTOP_HIT_TEST_Y(),
+       ENDSTOP_HIT_TEST_Z(),
+      _ENDSTOP_HIT_TEST(I,'I'),
+      _ENDSTOP_HIT_TEST(J,'J'),
+      _ENDSTOP_HIT_TEST(K,'K')
+    );
 
     #if HAS_CUSTOM_PROBE_PIN
       #define P_AXIS Z_AXIS
       if (TEST(hit_state, Z_MIN_PROBE)) _ENDSTOP_HIT_ECHO(P, 'P');
     #endif
     SERIAL_EOL();
 
     TERN_(HAS_STATUS_MESSAGE,
       ui.status_printf_P(0,
         PSTR(S_FMT GANG_N_1(LINEAR_AXES, " %c") " %c"),
         GET_TEXT(MSG_LCD_ENDSTOPS),
-        LINEAR_AXIS_LIST(chrX, chrY, chrZ), chrP
+        LINEAR_AXIS_LIST(chrX, chrY, chrZ, chrI, chrJ, chrK), chrP
       )
     );
 
     #if BOTH(SD_ABORT_ON_ENDSTOP_HIT, SDSUPPORT)
       if (planner.abort_on_endstop_hit) {
         card.abortFilePrintNow();
         quickstop_stepper();
         thermalManager.disable_all_heaters();
         print_job_timer.stop();
       }
@@ -470,20 +538,38 @@ void _O2 Endstops::report_states() {
   #endif
   #if HAS_Z2_MAX
     ES_REPORT(Z2_MAX);
   #endif
   #if HAS_Z3_MAX
     ES_REPORT(Z3_MAX);
   #endif
   #if HAS_Z4_MAX
     ES_REPORT(Z4_MAX);
   #endif
+  #if HAS_I_MIN
+    ES_REPORT(I_MIN);
+  #endif
+  #if HAS_I_MAX
+    ES_REPORT(I_MAX);
+  #endif
+  #if HAS_J_MIN
+    ES_REPORT(J_MIN);
+  #endif
+  #if HAS_J_MAX
+    ES_REPORT(J_MAX);
+  #endif
+    #if HAS_K_MIN
+    ES_REPORT(K_MIN);
+  #endif
+  #if HAS_K_MAX
+    ES_REPORT(K_MAX);
+  #endif
   #if BOTH(MARLIN_DEV_MODE, PROBE_ACTIVATION_SWITCH)
     print_es_state(probe_switch_activated(), PSTR(STR_PROBE_EN));
   #endif
   #if HAS_CUSTOM_PROBE_PIN
     print_es_state(PROBE_TRIGGERED(), PSTR(STR_Z_PROBE));
   #endif
   #if MULTI_FILAMENT_SENSOR
     #define _CASE_RUNOUT(N) case N: pin = FIL_RUNOUT##N##_PIN; state = FIL_RUNOUT##N##_STATE; break;
     LOOP_S_LE_N(i, 1, NUM_RUNOUT_SENSORS) {
       pin_t pin;
@@ -542,20 +628,24 @@ void Endstops::update() {
     #define Y_AXIS_HEAD Y_HEAD
   #else
     #define Y_AXIS_HEAD Y_AXIS
   #endif
   #if CORE_IS_XZ || CORE_IS_YZ
     #define Z_AXIS_HEAD Z_HEAD
   #else
     #define Z_AXIS_HEAD Z_AXIS
   #endif
 
+  #define I_AXIS_HEAD I_AXIS
+  #define J_AXIS_HEAD J_AXIS
+  #define K_AXIS_HEAD K_AXIS
+
   /**
    * Check and update endstops
    */
   #if HAS_X_MIN && !X_SPI_SENSORLESS
     UPDATE_ENDSTOP_BIT(X, MIN);
     #if ENABLED(X_DUAL_ENDSTOPS)
       #if HAS_X2_MIN
         UPDATE_ENDSTOP_BIT(X2, MIN);
       #else
         COPY_LIVE_STATE(X_MIN, X2_MIN);
@@ -649,20 +739,98 @@ void Endstops::update() {
         #else
           COPY_LIVE_STATE(Z_MAX, Z4_MAX);
         #endif
       #endif
     #elif !HAS_CUSTOM_PROBE_PIN || Z_MAX_PIN != Z_MIN_PROBE_PIN
       // If this pin isn't the bed probe it's the Z endstop
       UPDATE_ENDSTOP_BIT(Z, MAX);
     #endif
   #endif
 
+  #if HAS_I_MIN
+    #if ENABLED(I_DUAL_ENDSTOPS)
+      UPDATE_ENDSTOP_BIT(I, MIN);
+      #if HAS_I2_MIN
+        UPDATE_ENDSTOP_BIT(I2, MAX);
+      #else
+        COPY_LIVE_STATE(I_MIN, I2_MIN);
+      #endif
+    #else
+      UPDATE_ENDSTOP_BIT(I, MIN);
+    #endif
+  #endif
+
+  #if HAS_I_MAX
+    #if ENABLED(I_DUAL_ENDSTOPS)
+      UPDATE_ENDSTOP_BIT(I, MAX);
+      #if HAS_I2_MAX
+        UPDATE_ENDSTOP_BIT(I2, MAX);
+      #else
+        COPY_LIVE_STATE(I_MAX, I2_MAX);
+      #endif
+    #else
+      UPDATE_ENDSTOP_BIT(I, MAX);
+    #endif
+  #endif
+
+  #if HAS_J_MIN
+    #if ENABLED(J_DUAL_ENDSTOPS)
+      UPDATE_ENDSTOP_BIT(J, MIN);
+      #if HAS_J2_MIN
+        UPDATE_ENDSTOP_BIT(J2, MIN);
+      #else
+        COPY_LIVE_STATE(J_MIN, J2_MIN);
+      #endif
+    #else
+      UPDATE_ENDSTOP_BIT(J, MIN);
+    #endif
+  #endif
+
+  #if HAS_J_MAX
+    #if ENABLED(J_DUAL_ENDSTOPS)
+      UPDATE_ENDSTOP_BIT(J, MAX);
+      #if HAS_J2_MAX
+        UPDATE_ENDSTOP_BIT(J2, MAX);
+      #else
+        COPY_LIVE_STATE(J_MAX, J2_MAX);
+      #endif
+    #else
+      UPDATE_ENDSTOP_BIT(J, MAX);
+    #endif
+  #endif
+
+  #if HAS_K_MIN
+    #if ENABLED(K_DUAL_ENDSTOPS)
+      UPDATE_ENDSTOP_BIT(K, MIN);
+      #if HAS_K2_MIN
+        UPDATE_ENDSTOP_BIT(K2, MIN);
+      #else
+        COPY_LIVE_STATE(K_MIN, K2_MIN);
+      #endif
+    #else
+      UPDATE_ENDSTOP_BIT(K, MIN);
+    #endif
+  #endif
+
+  #if HAS_K_MAX
+    #if ENABLED(K_DUAL_ENDSTOPS)
+      UPDATE_ENDSTOP_BIT(K, MAX);
+      #if HAS_K2_MAX
+        UPDATE_ENDSTOP_BIT(K2, MAX);
+      #else
+        COPY_LIVE_STATE(K_MAX, K2_MAX);
+      #endif
+    #else
+      UPDATE_ENDSTOP_BIT(K, MAX);
+    #endif
+  #endif
+
   #if ENDSTOP_NOISE_THRESHOLD
 
     /**
      * Filtering out noise on endstops requires a delayed decision. Let's assume, due to noise,
      * that 50% of endstop signal samples are good and 50% are bad (assuming normal distribution
      * of random noise). Then the first sample has a 50% chance to be good or bad. The 2nd sample
      * also has a 50% chance to be good or bad. The chances of 2 samples both being bad becomes
      * 50% of 50%, or 25%. That was the previous implementation of Marlin endstop handling. It
      * reduces chances of bad readings in half, at the cost of 1 extra sample period, but chances
      * still exist. The only way to reduce them further is to increase the number of samples.
@@ -797,93 +965,142 @@ void Endstops::update() {
           PROCESS_CORE_ENDSTOP(Y,MAX,X,MAX);
         #elif CORE_DIAG(XZ, Z, MIN)
           PROCESS_CORE_ENDSTOP(Z,MIN,X,MAX);
         #elif CORE_DIAG(XZ, Z, MAX)
           PROCESS_CORE_ENDSTOP(Z,MAX,X,MAX);
         #endif
       #endif
     }
   }
 
-  if (stepper.axis_is_moving(Y_AXIS)) {
-    if (stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
-      #if HAS_Y_MIN || (Y_SPI_SENSORLESS && Y_HOME_TO_MIN)
-        PROCESS_ENDSTOP_Y(MIN);
-        #if   CORE_DIAG(XY, X, MIN)
-          PROCESS_CORE_ENDSTOP(X,MIN,Y,MIN);
-        #elif CORE_DIAG(XY, X, MAX)
-          PROCESS_CORE_ENDSTOP(X,MAX,Y,MIN);
-        #elif CORE_DIAG(YZ, Z, MIN)
-          PROCESS_CORE_ENDSTOP(Z,MIN,Y,MIN);
-        #elif CORE_DIAG(YZ, Z, MAX)
-          PROCESS_CORE_ENDSTOP(Z,MAX,Y,MIN);
+  #if HAS_Y_AXIS
+    if (stepper.axis_is_moving(Y_AXIS)) {
+      if (stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
+        #if HAS_Y_MIN || (Y_SPI_SENSORLESS && Y_HOME_TO_MIN)
+          PROCESS_ENDSTOP_Y(MIN);
+          #if   CORE_DIAG(XY, X, MIN)
+            PROCESS_CORE_ENDSTOP(X,MIN,Y,MIN);
+          #elif CORE_DIAG(XY, X, MAX)
+            PROCESS_CORE_ENDSTOP(X,MAX,Y,MIN);
+          #elif CORE_DIAG(YZ, Z, MIN)
+            PROCESS_CORE_ENDSTOP(Z,MIN,Y,MIN);
+          #elif CORE_DIAG(YZ, Z, MAX)
+            PROCESS_CORE_ENDSTOP(Z,MAX,Y,MIN);
+          #endif
         #endif
-      #endif
+      }
+      else { // +direction
+        #if HAS_Y_MAX || (Y_SPI_SENSORLESS && Y_HOME_TO_MAX)
+          PROCESS_ENDSTOP_Y(MAX);
+          #if   CORE_DIAG(XY, X, MIN)
+            PROCESS_CORE_ENDSTOP(X,MIN,Y,MAX);
+          #elif CORE_DIAG(XY, X, MAX)
+            PROCESS_CORE_ENDSTOP(X,MAX,Y,MAX);
+          #elif CORE_DIAG(YZ, Z, MIN)
+            PROCESS_CORE_ENDSTOP(Z,MIN,Y,MAX);
+          #elif CORE_DIAG(YZ, Z, MAX)
+            PROCESS_CORE_ENDSTOP(Z,MAX,Y,MAX);
+          #endif
+        #endif
+      }
     }
-    else { // +direction
-      #if HAS_Y_MAX || (Y_SPI_SENSORLESS && Y_HOME_TO_MAX)
-        PROCESS_ENDSTOP_Y(MAX);
-        #if   CORE_DIAG(XY, X, MIN)
-          PROCESS_CORE_ENDSTOP(X,MIN,Y,MAX);
-        #elif CORE_DIAG(XY, X, MAX)
-          PROCESS_CORE_ENDSTOP(X,MAX,Y,MAX);
-        #elif CORE_DIAG(YZ, Z, MIN)
-          PROCESS_CORE_ENDSTOP(Z,MIN,Y,MAX);
-        #elif CORE_DIAG(YZ, Z, MAX)
-          PROCESS_CORE_ENDSTOP(Z,MAX,Y,MAX);
+  #endif
+
+  #if HAS_Z_AXIS
+    if (stepper.axis_is_moving(Z_AXIS)) {
+      if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
+
+        #if HAS_Z_MIN || (Z_SPI_SENSORLESS && Z_HOME_TO_MIN)
+          if ( TERN1(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN, z_probe_enabled)
+            && TERN1(HAS_CUSTOM_PROBE_PIN, !z_probe_enabled)
+          ) PROCESS_ENDSTOP_Z(MIN);
+          #if   CORE_DIAG(XZ, X, MIN)
+            PROCESS_CORE_ENDSTOP(X,MIN,Z,MIN);
+          #elif CORE_DIAG(XZ, X, MAX)
+            PROCESS_CORE_ENDSTOP(X,MAX,Z,MIN);
+          #elif CORE_DIAG(YZ, Y, MIN)
+            PROCESS_CORE_ENDSTOP(Y,MIN,Z,MIN);
+          #elif CORE_DIAG(YZ, Y, MAX)
+            PROCESS_CORE_ENDSTOP(Y,MAX,Z,MIN);
+          #endif
         #endif
-      #endif
+
+        // When closing the gap check the enabled probe
+        #if HAS_CUSTOM_PROBE_PIN
+          if (z_probe_enabled) PROCESS_ENDSTOP(Z, MIN_PROBE);
+        #endif
+      }
+      else { // Z +direction. Gantry up, bed down.
+        #if HAS_Z_MAX || (Z_SPI_SENSORLESS && Z_HOME_TO_MAX)
+          #if ENABLED(Z_MULTI_ENDSTOPS)
+            PROCESS_ENDSTOP_Z(MAX);
+          #elif !HAS_CUSTOM_PROBE_PIN || Z_MAX_PIN != Z_MIN_PROBE_PIN  // No probe or probe is Z_MIN || Probe is not Z_MAX
+            PROCESS_ENDSTOP(Z, MAX);
+          #endif
+          #if   CORE_DIAG(XZ, X, MIN)
+            PROCESS_CORE_ENDSTOP(X,MIN,Z,MAX);
+          #elif CORE_DIAG(XZ, X, MAX)
+            PROCESS_CORE_ENDSTOP(X,MAX,Z,MAX);
+          #elif CORE_DIAG(YZ, Y, MIN)
+            PROCESS_CORE_ENDSTOP(Y,MIN,Z,MAX);
+          #elif CORE_DIAG(YZ, Y, MAX)
+            PROCESS_CORE_ENDSTOP(Y,MAX,Z,MAX);
+          #endif
+        #endif
+      }
     }
-  }
+  #endif
 
-  if (stepper.axis_is_moving(Z_AXIS)) {
-    if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
-
-      #if HAS_Z_MIN || (Z_SPI_SENSORLESS && Z_HOME_TO_MIN)
-        if ( TERN1(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN, z_probe_enabled)
-          && TERN1(HAS_CUSTOM_PROBE_PIN, !z_probe_enabled)
-        ) PROCESS_ENDSTOP_Z(MIN);
-        #if   CORE_DIAG(XZ, X, MIN)
-          PROCESS_CORE_ENDSTOP(X,MIN,Z,MIN);
-        #elif CORE_DIAG(XZ, X, MAX)
-          PROCESS_CORE_ENDSTOP(X,MAX,Z,MIN);
-        #elif CORE_DIAG(YZ, Y, MIN)
-          PROCESS_CORE_ENDSTOP(Y,MIN,Z,MIN);
-        #elif CORE_DIAG(YZ, Y, MAX)
-          PROCESS_CORE_ENDSTOP(Y,MAX,Z,MIN);
+  #if LINEAR_AXES >= 4
+    if (stepper.axis_is_moving(I_AXIS)) {
+      if (stepper.motor_direction(I_AXIS_HEAD)) { // -direction
+        #if HAS_I_MIN || (I_SPI_SENSORLESS && I_HOME_TO_MIN)
+          PROCESS_ENDSTOP(I, MIN);
         #endif
-      #endif
+      }
+      else { // +direction
+        #if HAS_I_MAX || (I_SPI_SENSORLESS && I_HOME_TO_MAX)
+          PROCESS_ENDSTOP(I, MAX);
+        #endif
+      }
+    }
+  #endif
 
-      // When closing the gap check the enabled probe
-      #if HAS_CUSTOM_PROBE_PIN
-        if (z_probe_enabled) PROCESS_ENDSTOP(Z, MIN_PROBE);
-      #endif
+  #if LINEAR_AXES >= 5
+    if (stepper.axis_is_moving(J_AXIS)) {
+      if (stepper.motor_direction(J_AXIS_HEAD)) { // -direction
+        #if HAS_J_MIN || (J_SPI_SENSORLESS && J_HOME_TO_MIN)
+          PROCESS_ENDSTOP(J, MIN);
+        #endif
+      }
+      else { // +direction
+        #if HAS_J_MAX || (J_SPI_SENSORLESS && J_HOME_TO_MAX)
+          PROCESS_ENDSTOP(J, MAX);
+        #endif
+      }
     }
-    else { // Z +direction. Gantry up, bed down.
-      #if HAS_Z_MAX || (Z_SPI_SENSORLESS && Z_HOME_TO_MAX)
-        #if ENABLED(Z_MULTI_ENDSTOPS)
-          PROCESS_ENDSTOP_Z(MAX);
-        #elif !HAS_CUSTOM_PROBE_PIN || Z_MAX_PIN != Z_MIN_PROBE_PIN  // No probe or probe is Z_MIN || Probe is not Z_MAX
-          PROCESS_ENDSTOP(Z, MAX);
+  #endif
+
+  #if LINEAR_AXES >= 6
+    if (stepper.axis_is_moving(K_AXIS)) {
+      if (stepper.motor_direction(K_AXIS_HEAD)) { // -direction
+        #if HAS_K_MIN || (K_SPI_SENSORLESS && K_HOME_TO_MIN)
+          PROCESS_ENDSTOP(K, MIN);
         #endif
-        #if   CORE_DIAG(XZ, X, MIN)
-          PROCESS_CORE_ENDSTOP(X,MIN,Z,MAX);
-        #elif CORE_DIAG(XZ, X, MAX)
-          PROCESS_CORE_ENDSTOP(X,MAX,Z,MAX);
-        #elif CORE_DIAG(YZ, Y, MIN)
-          PROCESS_CORE_ENDSTOP(Y,MIN,Z,MAX);
-        #elif CORE_DIAG(YZ, Y, MAX)
-          PROCESS_CORE_ENDSTOP(Y,MAX,Z,MAX);
+      }
+      else { // +direction
+        #if HAS_K_MAX || (K_SPI_SENSORLESS && K_HOME_TO_MAX)
+          PROCESS_ENDSTOP(K, MAX);
         #endif
-      #endif
+      }
     }
-  }
+  #endif
 } // Endstops::update()
 
 #if ENABLED(SPI_ENDSTOPS)
 
   bool Endstops::tmc_spi_homing_check() {
     bool hit = false;
     #if X_SPI_SENSORLESS
       if (tmc_spi_homing.x && (stepperX.test_stall_status()
         #if ANY(CORE_IS_XY, MARKFORGED_XY) && Y_SPI_SENSORLESS
           || stepperY.test_stall_status()
@@ -912,30 +1129,51 @@ void Endstops::update() {
         #if CORE_IS_XZ && X_SPI_SENSORLESS
           || stepperX.test_stall_status()
         #elif CORE_IS_YZ && Y_SPI_SENSORLESS
           || stepperY.test_stall_status()
         #endif
       )) {
         SBI(live_state, Z_ENDSTOP);
         hit = true;
       }
     #endif
+    #if I_SPI_SENSORLESS
+      if (tmc_spi_homing.i && stepperI.test_stall_status()) {
+        SBI(live_state, I_ENDSTOP);
+        hit = true;
+      }
+    #endif
+    #if J_SPI_SENSORLESS
+      if (tmc_spi_homing.j && stepperJ.test_stall_status()) {
+        SBI(live_state, J_ENDSTOP);
+        hit = true;
+      }
+    #endif
+    #if K_SPI_SENSORLESS
+      if (tmc_spi_homing.k && stepperK.test_stall_status()) {
+        SBI(live_state, K_ENDSTOP);
+        hit = true;
+      }
+    #endif
 
     if (TERN0(ENDSTOP_INTERRUPTS_FEATURE, hit)) update();
 
     return hit;
   }
 
   void Endstops::clear_endstop_state() {
     TERN_(X_SPI_SENSORLESS, CBI(live_state, X_ENDSTOP));
     TERN_(Y_SPI_SENSORLESS, CBI(live_state, Y_ENDSTOP));
     TERN_(Z_SPI_SENSORLESS, CBI(live_state, Z_ENDSTOP));
+    TERN_(I_SPI_SENSORLESS, CBI(live_state, I_ENDSTOP));
+    TERN_(J_SPI_SENSORLESS, CBI(live_state, J_ENDSTOP));
+    TERN_(K_SPI_SENSORLESS, CBI(live_state, K_ENDSTOP));
   }
 
 #endif // SPI_ENDSTOPS
 
 #if ENABLED(PINS_DEBUGGING)
 
   bool Endstops::monitor_flag = false;
 
   /**
    * Monitor Endstops and Z Probe for changes
@@ -998,20 +1236,38 @@ void Endstops::update() {
     #endif
     #if HAS_Z3_MAX
       ES_GET_STATE(Z3_MAX);
     #endif
     #if HAS_Z4_MIN
       ES_GET_STATE(Z4_MIN);
     #endif
     #if HAS_Z4_MAX
       ES_GET_STATE(Z4_MAX);
     #endif
+    #if HAS_I_MAX
+      ES_GET_STATE(I_MAX);
+    #endif
+    #if HAS_I_MIN
+      ES_GET_STATE(I_MIN);
+    #endif
+    #if HAS_J_MAX
+      ES_GET_STATE(J_MAX);
+    #endif
+    #if HAS_J_MIN
+      ES_GET_STATE(J_MIN);
+    #endif
+    #if HAS_K_MAX
+      ES_GET_STATE(K_MAX);
+    #endif
+    #if HAS_K_MIN
+      ES_GET_STATE(K_MIN);
+    #endif
 
     uint16_t endstop_change = live_state_local ^ old_live_state_local;
     #define ES_REPORT_CHANGE(S) if (TEST(endstop_change, S)) SERIAL_ECHOPAIR("  " STRINGIFY(S) ":", TEST(live_state_local, S))
 
     if (endstop_change) {
       #if HAS_X_MIN
         ES_REPORT_CHANGE(X_MIN);
       #endif
       #if HAS_X_MAX
         ES_REPORT_CHANGE(X_MAX);
@@ -1054,18 +1310,36 @@ void Endstops::update() {
       #endif
       #if HAS_Z3_MAX
         ES_REPORT_CHANGE(Z3_MAX);
       #endif
       #if HAS_Z4_MIN
         ES_REPORT_CHANGE(Z4_MIN);
       #endif
       #if HAS_Z4_MAX
         ES_REPORT_CHANGE(Z4_MAX);
       #endif
+      #if HAS_I_MIN
+        ES_REPORT_CHANGE(I_MIN);
+      #endif
+      #if HAS_I_MAX
+        ES_REPORT_CHANGE(I_MAX);
+      #endif
+      #if HAS_J_MIN
+        ES_REPORT_CHANGE(J_MIN);
+      #endif
+      #if HAS_J_MAX
+        ES_REPORT_CHANGE(J_MAX);
+      #endif
+      #if HAS_K_MIN
+        ES_REPORT_CHANGE(K_MIN);
+      #endif
+      #if HAS_K_MAX
+        ES_REPORT_CHANGE(K_MAX);
+      #endif
       SERIAL_ECHOLNPGM("\n");
       analogWrite(pin_t(LED_PIN), local_LED_status);
       local_LED_status ^= 255;
       old_live_state_local = live_state_local;
     }
   }
 
 #endif // PINS_DEBUGGING

commit dd4990252e891cdfe56cb7d6e3bbe1e6289be649
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon May 24 16:38:57 2021 -0500

    ‚ôªÔ∏è Refactor Linear / Logical / Distinct Axes (#21953)
    
    * More patches supporting EXTRUDERS 0
    * Extend types in prep for more axes

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index dff0b6832a..cf152ff028 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -354,21 +354,22 @@ void Endstops::resync() {
     if (!monitor_count) monitor();      // report changes in endstop status
   }
 #endif
 
 void Endstops::event_handler() {
   static endstop_mask_t prev_hit_state; // = 0
   if (hit_state == prev_hit_state) return;
   prev_hit_state = hit_state;
   if (hit_state) {
     #if HAS_STATUS_MESSAGE
-      char chrX = ' ', chrY = ' ', chrZ = ' ', chrP = ' ';
+      char LINEAR_AXIS_LIST(chrX = ' ', chrY = ' ', chrZ = ' '),
+           chrP = ' ';
       #define _SET_STOP_CHAR(A,C) (chr## A = C)
     #else
       #define _SET_STOP_CHAR(A,C) NOOP
     #endif
 
     #define _ENDSTOP_HIT_ECHO(A,C) do{ \
       SERIAL_ECHOPAIR(" " STRINGIFY(A) ":", planner.triggered_position_mm(_AXIS(A))); _SET_STOP_CHAR(A,C); }while(0)
 
     #define _ENDSTOP_HIT_TEST(A,C) \
       if (TERN0(HAS_##A##_MIN, TEST(hit_state, A##_MIN)) || TERN0(HAS_##A##_MAX, TEST(hit_state, A##_MAX))) \
@@ -383,21 +384,27 @@ void Endstops::event_handler() {
     ENDSTOP_HIT_TEST_X();
     ENDSTOP_HIT_TEST_Y();
     ENDSTOP_HIT_TEST_Z();
 
     #if HAS_CUSTOM_PROBE_PIN
       #define P_AXIS Z_AXIS
       if (TEST(hit_state, Z_MIN_PROBE)) _ENDSTOP_HIT_ECHO(P, 'P');
     #endif
     SERIAL_EOL();
 
-    TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " %c %c %c %c"), GET_TEXT(MSG_LCD_ENDSTOPS), chrX, chrY, chrZ, chrP));
+    TERN_(HAS_STATUS_MESSAGE,
+      ui.status_printf_P(0,
+        PSTR(S_FMT GANG_N_1(LINEAR_AXES, " %c") " %c"),
+        GET_TEXT(MSG_LCD_ENDSTOPS),
+        LINEAR_AXIS_LIST(chrX, chrY, chrZ), chrP
+      )
+    );
 
     #if BOTH(SD_ABORT_ON_ENDSTOP_HIT, SDSUPPORT)
       if (planner.abort_on_endstop_hit) {
         card.abortFilePrintNow();
         quickstop_stepper();
         thermalManager.disable_all_heaters();
         print_job_timer.stop();
       }
     #endif
   }

commit 92dea8e6ccd26950eed817fce6f574fcfe866489
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 23 01:09:46 2021 -0500

    ‚ôªÔ∏è Refactor, comment endstop/probe enums

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 7a452f1fdd..dff0b6832a 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -396,26 +396,35 @@ void Endstops::event_handler() {
       if (planner.abort_on_endstop_hit) {
         card.abortFilePrintNow();
         quickstop_stepper();
         thermalManager.disable_all_heaters();
         print_job_timer.stop();
       }
     #endif
   }
 }
 
+#if GCC_VERSION <= 50000
+  #pragma GCC diagnostic push
+  #pragma GCC diagnostic ignored "-Wunused-function"
+#endif
+
 static void print_es_state(const bool is_hit, PGM_P const label=nullptr) {
   if (label) SERIAL_ECHOPGM_P(label);
   SERIAL_ECHOPGM(": ");
   SERIAL_ECHOLNPGM_P(is_hit ? PSTR(STR_ENDSTOP_HIT) : PSTR(STR_ENDSTOP_OPEN));
 }
 
+#if GCC_VERSION <= 50000
+  #pragma GCC diagnostic pop
+#endif
+
 void _O2 Endstops::report_states() {
   TERN_(BLTOUCH, bltouch._set_SW_mode());
   SERIAL_ECHOLNPGM(STR_M119_REPORT);
   #define ES_REPORT(S) print_es_state(READ(S##_PIN) != S##_ENDSTOP_INVERTING, PSTR(STR_##S))
   #if HAS_X_MIN
     ES_REPORT(X_MIN);
   #endif
   #if HAS_X2_MIN
     ES_REPORT(X2_MIN);
   #endif

commit 49771c4a9ed2afa1e572f82a24b5edb3de120f78
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed May 19 00:21:34 2021 -0500

    üé® Flags for homing directions

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index d0befe71fb..7a452f1fdd 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -506,28 +506,22 @@ void Endstops::update() {
 
   #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT_TO(live_state, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
   #define COPY_LIVE_STATE(SRC_BIT, DST_BIT) SET_BIT_TO(live_state, DST_BIT, TEST(live_state, SRC_BIT))
 
   #if BOTH(G38_PROBE_TARGET, HAS_Z_MIN_PROBE_PIN) && NONE(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY)
     // If G38 command is active check Z_MIN_PROBE for ALL movement
     if (G38_move) UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
   #endif
 
   // With Dual X, endstops are only checked in the homing direction for the active extruder
-  #if ENABLED(DUAL_X_CARRIAGE)
-    #define E0_ACTIVE stepper.last_moved_extruder == 0
-    #define X_MIN_TEST() ((X_HOME_DIR < 0 && E0_ACTIVE) || (X2_HOME_DIR < 0 && !E0_ACTIVE))
-    #define X_MAX_TEST() ((X_HOME_DIR > 0 && E0_ACTIVE) || (X2_HOME_DIR > 0 && !E0_ACTIVE))
-  #else
-    #define X_MIN_TEST() true
-    #define X_MAX_TEST() true
-  #endif
+  #define X_MIN_TEST() TERN1(DUAL_X_CARRIAGE, TERN0(X_HOME_TO_MIN, stepper.last_moved_extruder == 0) || TERN0(X2_HOME_TO_MIN, stepper.last_moved_extruder != 0))
+  #define X_MAX_TEST() TERN1(DUAL_X_CARRIAGE, TERN0(X_HOME_TO_MAX, stepper.last_moved_extruder == 0) || TERN0(X2_HOME_TO_MAX, stepper.last_moved_extruder != 0))
 
   // Use HEAD for core axes, AXIS for others
   #if ANY(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY)
     #define X_AXIS_HEAD X_HEAD
   #else
     #define X_AXIS_HEAD X_AXIS
   #endif
   #if ANY(CORE_IS_XY, CORE_IS_YZ, MARKFORGED_XY)
     #define Y_AXIS_HEAD Y_HEAD
   #else
@@ -758,105 +752,105 @@ void Endstops::update() {
       else if (stepper.axis_is_moving(Y_AXIS)) { _ENDSTOP_HIT(Y, MIN); planner.endstop_triggered(Y_AXIS); }
       else if (stepper.axis_is_moving(Z_AXIS)) { _ENDSTOP_HIT(Z, MIN); planner.endstop_triggered(Z_AXIS); }
       G38_did_trigger = true;
     }
   #endif
 
   // Signal, after validation, if an endstop limit is pressed or not
 
   if (stepper.axis_is_moving(X_AXIS)) {
     if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
-      #if HAS_X_MIN || (X_SPI_SENSORLESS && X_HOME_DIR < 0)
+      #if HAS_X_MIN || (X_SPI_SENSORLESS && X_HOME_TO_MIN)
         PROCESS_ENDSTOP_X(MIN);
         #if   CORE_DIAG(XY, Y, MIN)
           PROCESS_CORE_ENDSTOP(Y,MIN,X,MIN);
         #elif CORE_DIAG(XY, Y, MAX)
           PROCESS_CORE_ENDSTOP(Y,MAX,X,MIN);
         #elif CORE_DIAG(XZ, Z, MIN)
           PROCESS_CORE_ENDSTOP(Z,MIN,X,MIN);
         #elif CORE_DIAG(XZ, Z, MAX)
           PROCESS_CORE_ENDSTOP(Z,MAX,X,MIN);
         #endif
       #endif
     }
     else { // +direction
-      #if HAS_X_MAX || (X_SPI_SENSORLESS && X_HOME_DIR > 0)
+      #if HAS_X_MAX || (X_SPI_SENSORLESS && X_HOME_TO_MAX)
         PROCESS_ENDSTOP_X(MAX);
         #if   CORE_DIAG(XY, Y, MIN)
           PROCESS_CORE_ENDSTOP(Y,MIN,X,MAX);
         #elif CORE_DIAG(XY, Y, MAX)
           PROCESS_CORE_ENDSTOP(Y,MAX,X,MAX);
         #elif CORE_DIAG(XZ, Z, MIN)
           PROCESS_CORE_ENDSTOP(Z,MIN,X,MAX);
         #elif CORE_DIAG(XZ, Z, MAX)
           PROCESS_CORE_ENDSTOP(Z,MAX,X,MAX);
         #endif
       #endif
     }
   }
 
   if (stepper.axis_is_moving(Y_AXIS)) {
     if (stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
-      #if HAS_Y_MIN || (Y_SPI_SENSORLESS && Y_HOME_DIR < 0)
+      #if HAS_Y_MIN || (Y_SPI_SENSORLESS && Y_HOME_TO_MIN)
         PROCESS_ENDSTOP_Y(MIN);
         #if   CORE_DIAG(XY, X, MIN)
           PROCESS_CORE_ENDSTOP(X,MIN,Y,MIN);
         #elif CORE_DIAG(XY, X, MAX)
           PROCESS_CORE_ENDSTOP(X,MAX,Y,MIN);
         #elif CORE_DIAG(YZ, Z, MIN)
           PROCESS_CORE_ENDSTOP(Z,MIN,Y,MIN);
         #elif CORE_DIAG(YZ, Z, MAX)
           PROCESS_CORE_ENDSTOP(Z,MAX,Y,MIN);
         #endif
       #endif
     }
     else { // +direction
-      #if HAS_Y_MAX || (Y_SPI_SENSORLESS && Y_HOME_DIR > 0)
+      #if HAS_Y_MAX || (Y_SPI_SENSORLESS && Y_HOME_TO_MAX)
         PROCESS_ENDSTOP_Y(MAX);
         #if   CORE_DIAG(XY, X, MIN)
           PROCESS_CORE_ENDSTOP(X,MIN,Y,MAX);
         #elif CORE_DIAG(XY, X, MAX)
           PROCESS_CORE_ENDSTOP(X,MAX,Y,MAX);
         #elif CORE_DIAG(YZ, Z, MIN)
           PROCESS_CORE_ENDSTOP(Z,MIN,Y,MAX);
         #elif CORE_DIAG(YZ, Z, MAX)
           PROCESS_CORE_ENDSTOP(Z,MAX,Y,MAX);
         #endif
       #endif
     }
   }
 
   if (stepper.axis_is_moving(Z_AXIS)) {
     if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
 
-      #if HAS_Z_MIN || (Z_SPI_SENSORLESS && Z_HOME_DIR < 0)
+      #if HAS_Z_MIN || (Z_SPI_SENSORLESS && Z_HOME_TO_MIN)
         if ( TERN1(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN, z_probe_enabled)
           && TERN1(HAS_CUSTOM_PROBE_PIN, !z_probe_enabled)
         ) PROCESS_ENDSTOP_Z(MIN);
         #if   CORE_DIAG(XZ, X, MIN)
           PROCESS_CORE_ENDSTOP(X,MIN,Z,MIN);
         #elif CORE_DIAG(XZ, X, MAX)
           PROCESS_CORE_ENDSTOP(X,MAX,Z,MIN);
         #elif CORE_DIAG(YZ, Y, MIN)
           PROCESS_CORE_ENDSTOP(Y,MIN,Z,MIN);
         #elif CORE_DIAG(YZ, Y, MAX)
           PROCESS_CORE_ENDSTOP(Y,MAX,Z,MIN);
         #endif
       #endif
 
       // When closing the gap check the enabled probe
       #if HAS_CUSTOM_PROBE_PIN
         if (z_probe_enabled) PROCESS_ENDSTOP(Z, MIN_PROBE);
       #endif
     }
     else { // Z +direction. Gantry up, bed down.
-      #if HAS_Z_MAX || (Z_SPI_SENSORLESS && Z_HOME_DIR > 0)
+      #if HAS_Z_MAX || (Z_SPI_SENSORLESS && Z_HOME_TO_MAX)
         #if ENABLED(Z_MULTI_ENDSTOPS)
           PROCESS_ENDSTOP_Z(MAX);
         #elif !HAS_CUSTOM_PROBE_PIN || Z_MAX_PIN != Z_MIN_PROBE_PIN  // No probe or probe is Z_MIN || Probe is not Z_MAX
           PROCESS_ENDSTOP(Z, MAX);
         #endif
         #if   CORE_DIAG(XZ, X, MIN)
           PROCESS_CORE_ENDSTOP(X,MIN,Z,MAX);
         #elif CORE_DIAG(XZ, X, MAX)
           PROCESS_CORE_ENDSTOP(X,MAX,Z,MAX);
         #elif CORE_DIAG(YZ, Y, MIN)

commit 02f904dbf9df999264099a26c563b07b1d163df4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 18 22:53:52 2021 -0500

    ‚ôªÔ∏è Minimize endstop bits

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 2ac20c92ef..d0befe71fb 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -49,26 +49,26 @@
 
 #if HAS_BED_PROBE
   #include "probe.h"
 #endif
 
 Endstops endstops;
 
 // private:
 
 bool Endstops::enabled, Endstops::enabled_globally; // Initialized by settings.load()
-volatile uint8_t Endstops::hit_state;
 
-Endstops::esbits_t Endstops::live_state = 0;
+volatile Endstops::endstop_mask_t Endstops::hit_state;
+Endstops::endstop_mask_t Endstops::live_state = 0;
 
 #if ENDSTOP_NOISE_THRESHOLD
-  Endstops::esbits_t Endstops::validated_live_state;
+  Endstops::endstop_mask_t Endstops::validated_live_state;
   uint8_t Endstops::endstop_poll_count;
 #endif
 
 #if HAS_BED_PROBE
   volatile bool Endstops::z_probe_enabled = false;
 #endif
 
 // Initialized by settings.load()
 #if ENABLED(X_DUAL_ENDSTOPS)
   float Endstops::x2_endstop_adj;
@@ -349,37 +349,36 @@ void Endstops::resync() {
   void Endstops::run_monitor() {
     if (!monitor_flag) return;
     static uint8_t monitor_count = 16;  // offset this check from the others
     monitor_count += _BV(1);            //  15 Hz
     monitor_count &= 0x7F;
     if (!monitor_count) monitor();      // report changes in endstop status
   }
 #endif
 
 void Endstops::event_handler() {
-  static uint8_t prev_hit_state; // = 0
+  static endstop_mask_t prev_hit_state; // = 0
   if (hit_state == prev_hit_state) return;
   prev_hit_state = hit_state;
   if (hit_state) {
     #if HAS_STATUS_MESSAGE
       char chrX = ' ', chrY = ' ', chrZ = ' ', chrP = ' ';
       #define _SET_STOP_CHAR(A,C) (chr## A = C)
     #else
-      #define _SET_STOP_CHAR(A,C) ;
+      #define _SET_STOP_CHAR(A,C) NOOP
     #endif
 
     #define _ENDSTOP_HIT_ECHO(A,C) do{ \
-      SERIAL_ECHOPAIR(" " STRINGIFY(A) ":", planner.triggered_position_mm(_AXIS(A))); \
-      _SET_STOP_CHAR(A,C); }while(0)
+      SERIAL_ECHOPAIR(" " STRINGIFY(A) ":", planner.triggered_position_mm(_AXIS(A))); _SET_STOP_CHAR(A,C); }while(0)
 
     #define _ENDSTOP_HIT_TEST(A,C) \
-      if (TEST(hit_state, A ##_MIN) || TEST(hit_state, A ##_MAX)) \
+      if (TERN0(HAS_##A##_MIN, TEST(hit_state, A##_MIN)) || TERN0(HAS_##A##_MAX, TEST(hit_state, A##_MAX))) \
         _ENDSTOP_HIT_ECHO(A,C)
 
     #define ENDSTOP_HIT_TEST_X() _ENDSTOP_HIT_TEST(X,'X')
     #define ENDSTOP_HIT_TEST_Y() _ENDSTOP_HIT_TEST(Y,'Y')
     #define ENDSTOP_HIT_TEST_Z() _ENDSTOP_HIT_TEST(Z,'Z')
 
     SERIAL_ECHO_START();
     SERIAL_ECHOPGM(STR_ENDSTOPS_HIT);
     ENDSTOP_HIT_TEST_X();
     ENDSTOP_HIT_TEST_Y();
@@ -652,21 +651,21 @@ void Endstops::update() {
     /**
      * Filtering out noise on endstops requires a delayed decision. Let's assume, due to noise,
      * that 50% of endstop signal samples are good and 50% are bad (assuming normal distribution
      * of random noise). Then the first sample has a 50% chance to be good or bad. The 2nd sample
      * also has a 50% chance to be good or bad. The chances of 2 samples both being bad becomes
      * 50% of 50%, or 25%. That was the previous implementation of Marlin endstop handling. It
      * reduces chances of bad readings in half, at the cost of 1 extra sample period, but chances
      * still exist. The only way to reduce them further is to increase the number of samples.
      * To reduce the chance to 1% (1/128th) requires 7 samples (adding 7ms of delay).
      */
-    static esbits_t old_live_state;
+    static endstop_mask_t old_live_state;
     if (old_live_state != live_state) {
       endstop_poll_count = ENDSTOP_NOISE_THRESHOLD;
       old_live_state = live_state;
     }
     else if (endstop_poll_count && !--endstop_poll_count)
       validated_live_state = live_state;
 
     if (!abort_enabled()) return;
 
   #endif

commit abbe3f0dc7aa23bae4aa26f6d6b09a4a0665a1a0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 18 22:46:59 2021 -0500

    üé® Misc cleanup and fixes

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index d7f728ad4b..2ac20c92ef 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -501,21 +501,21 @@ void _O2 Endstops::report_states() {
 // Check endstops - Could be called from Temperature ISR!
 void Endstops::update() {
 
   #if !ENDSTOP_NOISE_THRESHOLD
     if (!abort_enabled()) return;
   #endif
 
   #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT_TO(live_state, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
   #define COPY_LIVE_STATE(SRC_BIT, DST_BIT) SET_BIT_TO(live_state, DST_BIT, TEST(live_state, SRC_BIT))
 
-  #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && NONE(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY)
+  #if BOTH(G38_PROBE_TARGET, HAS_Z_MIN_PROBE_PIN) && NONE(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY)
     // If G38 command is active check Z_MIN_PROBE for ALL movement
     if (G38_move) UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
   #endif
 
   // With Dual X, endstops are only checked in the homing direction for the active extruder
   #if ENABLED(DUAL_X_CARRIAGE)
     #define E0_ACTIVE stepper.last_moved_extruder == 0
     #define X_MIN_TEST() ((X_HOME_DIR < 0 && E0_ACTIVE) || (X2_HOME_DIR < 0 && !E0_ACTIVE))
     #define X_MAX_TEST() ((X_HOME_DIR > 0 && E0_ACTIVE) || (X2_HOME_DIR > 0 && !E0_ACTIVE))
   #else
@@ -740,21 +740,21 @@ void Endstops::update() {
   #if DISABLED(Z_MULTI_ENDSTOPS)
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_ENDSTOP(Z, MINMAX)
   #elif NUM_Z_STEPPER_DRIVERS == 4
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_QUAD_ENDSTOP(Z, MINMAX)
   #elif NUM_Z_STEPPER_DRIVERS == 3
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_TRIPLE_ENDSTOP(Z, MINMAX)
   #else
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_DUAL_ENDSTOP(Z, MINMAX)
   #endif
 
-  #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && NONE(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY)
+  #if BOTH(G38_PROBE_TARGET, HAS_Z_MIN_PROBE_PIN) && NONE(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY)
     #if ENABLED(G38_PROBE_AWAY)
       #define _G38_OPEN_STATE (G38_move >= 4)
     #else
       #define _G38_OPEN_STATE LOW
     #endif
     // If G38 command is active check Z_MIN_PROBE for ALL movement
     if (G38_move && TEST_ENDSTOP(_ENDSTOP(Z, MIN_PROBE)) != _G38_OPEN_STATE) {
            if (stepper.axis_is_moving(X_AXIS)) { _ENDSTOP_HIT(X, MIN); planner.endstop_triggered(X_AXIS); }
       else if (stepper.axis_is_moving(Y_AXIS)) { _ENDSTOP_HIT(Y, MIN); planner.endstop_triggered(Y_AXIS); }
       else if (stepper.axis_is_moving(Z_AXIS)) { _ENDSTOP_HIT(Z, MIN); planner.endstop_triggered(Z_AXIS); }

commit b65cdbed91782c83188706a9c340de9c503cf430
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 8 04:35:35 2021 -0500

    Signal SD completion later (#21840)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 14c5f13367..d7f728ad4b 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -388,21 +388,21 @@ void Endstops::event_handler() {
     #if HAS_CUSTOM_PROBE_PIN
       #define P_AXIS Z_AXIS
       if (TEST(hit_state, Z_MIN_PROBE)) _ENDSTOP_HIT_ECHO(P, 'P');
     #endif
     SERIAL_EOL();
 
     TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " %c %c %c %c"), GET_TEXT(MSG_LCD_ENDSTOPS), chrX, chrY, chrZ, chrP));
 
     #if BOTH(SD_ABORT_ON_ENDSTOP_HIT, SDSUPPORT)
       if (planner.abort_on_endstop_hit) {
-        card.endFilePrint();
+        card.abortFilePrintNow();
         quickstop_stepper();
         thermalManager.disable_all_heaters();
         print_job_timer.stop();
       }
     #endif
   }
 }
 
 static void print_es_state(const bool is_hit, PGM_P const label=nullptr) {
   if (label) SERIAL_ECHOPGM_P(label);

commit f09fa69e867d1cfb18cbad720a5c1e566cb1bab4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat May 8 01:41:40 2021 -0500

    Add and apply REPEAT_1 macro

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index e11c4605e4..14c5f13367 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -468,21 +468,21 @@ void _O2 Endstops::report_states() {
   #if HAS_CUSTOM_PROBE_PIN
     print_es_state(PROBE_TRIGGERED(), PSTR(STR_Z_PROBE));
   #endif
   #if MULTI_FILAMENT_SENSOR
     #define _CASE_RUNOUT(N) case N: pin = FIL_RUNOUT##N##_PIN; state = FIL_RUNOUT##N##_STATE; break;
     LOOP_S_LE_N(i, 1, NUM_RUNOUT_SENSORS) {
       pin_t pin;
       uint8_t state;
       switch (i) {
         default: continue;
-        REPEAT_S(1, INCREMENT(NUM_RUNOUT_SENSORS), _CASE_RUNOUT)
+        REPEAT_1(NUM_RUNOUT_SENSORS, _CASE_RUNOUT)
       }
       SERIAL_ECHOPGM(STR_FILAMENT_RUNOUT_SENSOR);
       if (i > 1) SERIAL_CHAR(' ', '0' + i);
       print_es_state(extDigitalRead(pin) != state);
     }
     #undef _CASE_RUNOUT
   #elif HAS_FILAMENT_SENSOR
     print_es_state(READ(FIL_RUNOUT1_PIN) != FIL_RUNOUT1_STATE, PSTR(STR_FILAMENT_RUNOUT_SENSOR));
   #endif
 

commit 930752d46e6aacb484ea89dacae6baf823d78d62
Author: Miguel Risco-Castillo <mriscoc@users.noreply.github.com>
Date:   Wed Mar 24 10:12:57 2021 -0500

    Ender 3 V2 Status Line (#21369)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 4192b444bb..e11c4605e4 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -353,21 +353,21 @@ void Endstops::resync() {
     monitor_count &= 0x7F;
     if (!monitor_count) monitor();      // report changes in endstop status
   }
 #endif
 
 void Endstops::event_handler() {
   static uint8_t prev_hit_state; // = 0
   if (hit_state == prev_hit_state) return;
   prev_hit_state = hit_state;
   if (hit_state) {
-    #if HAS_WIRED_LCD
+    #if HAS_STATUS_MESSAGE
       char chrX = ' ', chrY = ' ', chrZ = ' ', chrP = ' ';
       #define _SET_STOP_CHAR(A,C) (chr## A = C)
     #else
       #define _SET_STOP_CHAR(A,C) ;
     #endif
 
     #define _ENDSTOP_HIT_ECHO(A,C) do{ \
       SERIAL_ECHOPAIR(" " STRINGIFY(A) ":", planner.triggered_position_mm(_AXIS(A))); \
       _SET_STOP_CHAR(A,C); }while(0)
 
@@ -384,21 +384,21 @@ void Endstops::event_handler() {
     ENDSTOP_HIT_TEST_X();
     ENDSTOP_HIT_TEST_Y();
     ENDSTOP_HIT_TEST_Z();
 
     #if HAS_CUSTOM_PROBE_PIN
       #define P_AXIS Z_AXIS
       if (TEST(hit_state, Z_MIN_PROBE)) _ENDSTOP_HIT_ECHO(P, 'P');
     #endif
     SERIAL_EOL();
 
-    TERN_(HAS_WIRED_LCD, ui.status_printf_P(0, PSTR(S_FMT " %c %c %c %c"), GET_TEXT(MSG_LCD_ENDSTOPS), chrX, chrY, chrZ, chrP));
+    TERN_(HAS_STATUS_MESSAGE, ui.status_printf_P(0, PSTR(S_FMT " %c %c %c %c"), GET_TEXT(MSG_LCD_ENDSTOPS), chrX, chrY, chrZ, chrP));
 
     #if BOTH(SD_ABORT_ON_ENDSTOP_HIT, SDSUPPORT)
       if (planner.abort_on_endstop_hit) {
         card.endFilePrint();
         quickstop_stepper();
         thermalManager.disable_all_heaters();
         print_job_timer.stop();
       }
     #endif
   }

commit 713de872ce055bd10bd59b4f811136b0ec0cfbae
Author: Stephan <veigl@gmx.net>
Date:   Mon Mar 1 03:16:22 2021 +0100

    Filament Runout handling for Mixing Extruder (#20327)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 9550799a2d..4192b444bb 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -461,38 +461,36 @@ void _O2 Endstops::report_states() {
   #endif
   #if HAS_Z4_MAX
     ES_REPORT(Z4_MAX);
   #endif
   #if BOTH(MARLIN_DEV_MODE, PROBE_ACTIVATION_SWITCH)
     print_es_state(probe_switch_activated(), PSTR(STR_PROBE_EN));
   #endif
   #if HAS_CUSTOM_PROBE_PIN
     print_es_state(PROBE_TRIGGERED(), PSTR(STR_Z_PROBE));
   #endif
-  #if HAS_FILAMENT_SENSOR
-    #if NUM_RUNOUT_SENSORS == 1
-      print_es_state(READ(FIL_RUNOUT1_PIN) != FIL_RUNOUT1_STATE, PSTR(STR_FILAMENT_RUNOUT_SENSOR));
-    #else
-      #define _CASE_RUNOUT(N) case N: pin = FIL_RUNOUT##N##_PIN; state = FIL_RUNOUT##N##_STATE; break;
-      LOOP_S_LE_N(i, 1, NUM_RUNOUT_SENSORS) {
-        pin_t pin;
-        uint8_t state;
-        switch (i) {
-          default: continue;
-          REPEAT_S(1, INCREMENT(NUM_RUNOUT_SENSORS), _CASE_RUNOUT)
-        }
-        SERIAL_ECHOPGM(STR_FILAMENT_RUNOUT_SENSOR);
-        if (i > 1) SERIAL_CHAR(' ', '0' + i);
-        print_es_state(extDigitalRead(pin) != state);
+  #if MULTI_FILAMENT_SENSOR
+    #define _CASE_RUNOUT(N) case N: pin = FIL_RUNOUT##N##_PIN; state = FIL_RUNOUT##N##_STATE; break;
+    LOOP_S_LE_N(i, 1, NUM_RUNOUT_SENSORS) {
+      pin_t pin;
+      uint8_t state;
+      switch (i) {
+        default: continue;
+        REPEAT_S(1, INCREMENT(NUM_RUNOUT_SENSORS), _CASE_RUNOUT)
       }
-      #undef _CASE_RUNOUT
-    #endif
+      SERIAL_ECHOPGM(STR_FILAMENT_RUNOUT_SENSOR);
+      if (i > 1) SERIAL_CHAR(' ', '0' + i);
+      print_es_state(extDigitalRead(pin) != state);
+    }
+    #undef _CASE_RUNOUT
+  #elif HAS_FILAMENT_SENSOR
+    print_es_state(READ(FIL_RUNOUT1_PIN) != FIL_RUNOUT1_STATE, PSTR(STR_FILAMENT_RUNOUT_SENSOR));
   #endif
 
   TERN_(BLTOUCH, bltouch._reset_SW_mode());
   TERN_(JOYSTICK_DEBUG, joystick.report());
 
 } // Endstops::report_states
 
 // The following routines are called from an ISR context. It could be the temperature ISR, the
 // endstop ISR or the Stepper ISR.
 

commit dd42831cba7334c5d106ba435bdb41b6135971bb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Feb 28 19:43:46 2021 -0600

    Serial macros cleanup

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index b9d2c1cdf5..9550799a2d 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -398,24 +398,23 @@ void Endstops::event_handler() {
         card.endFilePrint();
         quickstop_stepper();
         thermalManager.disable_all_heaters();
         print_job_timer.stop();
       }
     #endif
   }
 }
 
 static void print_es_state(const bool is_hit, PGM_P const label=nullptr) {
-  if (label) serialprintPGM(label);
+  if (label) SERIAL_ECHOPGM_P(label);
   SERIAL_ECHOPGM(": ");
-  serialprintPGM(is_hit ? PSTR(STR_ENDSTOP_HIT) : PSTR(STR_ENDSTOP_OPEN));
-  SERIAL_EOL();
+  SERIAL_ECHOLNPGM_P(is_hit ? PSTR(STR_ENDSTOP_HIT) : PSTR(STR_ENDSTOP_OPEN));
 }
 
 void _O2 Endstops::report_states() {
   TERN_(BLTOUCH, bltouch._set_SW_mode());
   SERIAL_ECHOLNPGM(STR_M119_REPORT);
   #define ES_REPORT(S) print_es_state(READ(S##_PIN) != S##_ENDSTOP_INVERTING, PSTR(STR_##S))
   #if HAS_X_MIN
     ES_REPORT(X_MIN);
   #endif
   #if HAS_X2_MIN

commit c0870d417a68ff4303100f165282d41be9129a5c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jan 21 03:40:07 2021 -0600

    Move some MarlinCore and MarlinUI code (#20832)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index b1c7c1c585..b9d2c1cdf5 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -20,21 +20,20 @@
  *
  */
 
 /**
  * endstops.cpp - A singleton object to manage endstops
  */
 
 #include "endstops.h"
 #include "stepper.h"
 
-#include "../MarlinCore.h"
 #include "../sd/cardreader.h"
 #include "temperature.h"
 #include "../lcd/marlinui.h"
 
 #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
   #include HAL_PATH(../HAL, endstop_interrupts.h)
 #endif
 
 #if BOTH(SD_ABORT_ON_ENDSTOP_HIT, SDSUPPORT)
   #include "printcounter.h" // for print_job_timer

commit f423edd938dcb593b58844cd7dc3b9164d792686
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Dec 27 16:21:01 2020 -0600

    Add probe_switch_activated

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 1467e1b70d..b1c7c1c585 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -458,21 +458,21 @@ void _O2 Endstops::report_states() {
   #if HAS_Z2_MAX
     ES_REPORT(Z2_MAX);
   #endif
   #if HAS_Z3_MAX
     ES_REPORT(Z3_MAX);
   #endif
   #if HAS_Z4_MAX
     ES_REPORT(Z4_MAX);
   #endif
   #if BOTH(MARLIN_DEV_MODE, PROBE_ACTIVATION_SWITCH)
-    print_es_state(READ(PROBE_ACTIVATION_SWITCH_PIN) == PROBE_ACTIVATION_SWITCH_STATE, PSTR(STR_PROBE_EN));
+    print_es_state(probe_switch_activated(), PSTR(STR_PROBE_EN));
   #endif
   #if HAS_CUSTOM_PROBE_PIN
     print_es_state(PROBE_TRIGGERED(), PSTR(STR_Z_PROBE));
   #endif
   #if HAS_FILAMENT_SENSOR
     #if NUM_RUNOUT_SENSORS == 1
       print_es_state(READ(FIL_RUNOUT1_PIN) != FIL_RUNOUT1_STATE, PSTR(STR_FILAMENT_RUNOUT_SENSOR));
     #else
       #define _CASE_RUNOUT(N) case N: pin = FIL_RUNOUT##N##_PIN; state = FIL_RUNOUT##N##_STATE; break;
       LOOP_S_LE_N(i, 1, NUM_RUNOUT_SENSORS) {
@@ -611,25 +611,22 @@ void Endstops::update() {
           UPDATE_ENDSTOP_BIT(Z4, MIN);
         #else
           COPY_LIVE_STATE(Z_MIN, Z4_MIN);
         #endif
       #endif
     #endif
   #endif
 
   #if HAS_BED_PROBE
     // When closing the gap check the enabled probe
-    if (true
-      #if ENABLED(PROBE_ACTIVATION_SWITCH)
-        || READ(PROBE_ACTIVATION_SWITCH_PIN) == PROBE_ACTIVATION_SWITCH_STATE
-      #endif
-    ) UPDATE_ENDSTOP_BIT(Z, TERN(HAS_CUSTOM_PROBE_PIN, MIN_PROBE, MIN));
+    if (probe_switch_activated())
+      UPDATE_ENDSTOP_BIT(Z, TERN(HAS_CUSTOM_PROBE_PIN, MIN_PROBE, MIN));
   #endif
 
   #if HAS_Z_MAX && !Z_SPI_SENSORLESS
     // Check both Z dual endstops
     #if ENABLED(Z_MULTI_ENDSTOPS)
       UPDATE_ENDSTOP_BIT(Z, MAX);
       #if HAS_Z2_MAX
         UPDATE_ENDSTOP_BIT(Z2, MAX);
       #else
         COPY_LIVE_STATE(Z_MAX, Z2_MAX);

commit 2963229dfa6648246951de90e4a86bf537cc876a
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Sat Dec 19 23:11:43 2020 -0500

    Probe Tare, Probe Activation Switch (#20379)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>
    Co-authored-by: Victor Mateus Oliveira <rhapsodyv@gmail.com>
    Co-authored-by: Jason Smith <jason.inet@gmail.com>

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index ef0b92a7ee..1467e1b70d 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -273,20 +273,26 @@ void Endstops::init() {
   #if HAS_CUSTOM_PROBE_PIN
     #if ENABLED(ENDSTOPPULLUP_ZMIN_PROBE)
       SET_INPUT_PULLUP(Z_MIN_PROBE_PIN);
     #elif ENABLED(ENDSTOPPULLDOWN_ZMIN_PROBE)
       SET_INPUT_PULLDOWN(Z_MIN_PROBE_PIN);
     #else
       SET_INPUT(Z_MIN_PROBE_PIN);
     #endif
   #endif
 
+  #if ENABLED(PROBE_ACTIVATION_SWITCH)
+    SET_INPUT(PROBE_ACTIVATION_SWITCH_PIN);
+  #endif
+
+  TERN_(PROBE_TARE, probe.tare());
+
   TERN_(ENDSTOP_INTERRUPTS_FEATURE, setup_endstop_interrupts());
 
   // Enable endstops
   enable_globally(ENABLED(ENDSTOPS_ALWAYS_ON_DEFAULT));
 
 } // Endstops::init
 
 // Called at ~1KHz from Temperature ISR: Poll endstop state if required
 void Endstops::poll() {
 
@@ -451,20 +457,23 @@ void _O2 Endstops::report_states() {
   #endif
   #if HAS_Z2_MAX
     ES_REPORT(Z2_MAX);
   #endif
   #if HAS_Z3_MAX
     ES_REPORT(Z3_MAX);
   #endif
   #if HAS_Z4_MAX
     ES_REPORT(Z4_MAX);
   #endif
+  #if BOTH(MARLIN_DEV_MODE, PROBE_ACTIVATION_SWITCH)
+    print_es_state(READ(PROBE_ACTIVATION_SWITCH_PIN) == PROBE_ACTIVATION_SWITCH_STATE, PSTR(STR_PROBE_EN));
+  #endif
   #if HAS_CUSTOM_PROBE_PIN
     print_es_state(PROBE_TRIGGERED(), PSTR(STR_Z_PROBE));
   #endif
   #if HAS_FILAMENT_SENSOR
     #if NUM_RUNOUT_SENSORS == 1
       print_es_state(READ(FIL_RUNOUT1_PIN) != FIL_RUNOUT1_STATE, PSTR(STR_FILAMENT_RUNOUT_SENSOR));
     #else
       #define _CASE_RUNOUT(N) case N: pin = FIL_RUNOUT##N##_PIN; state = FIL_RUNOUT##N##_STATE; break;
       LOOP_S_LE_N(i, 1, NUM_RUNOUT_SENSORS) {
         pin_t pin;
@@ -575,21 +584,21 @@ void Endstops::update() {
     UPDATE_ENDSTOP_BIT(Y, MAX);
     #if ENABLED(Y_DUAL_ENDSTOPS)
       #if HAS_Y2_MAX
         UPDATE_ENDSTOP_BIT(Y2, MAX);
       #else
         COPY_LIVE_STATE(Y_MAX, Y2_MAX);
       #endif
     #endif
   #endif
 
-  #if HAS_Z_MIN && !Z_SPI_SENSORLESS
+  #if HAS_Z_MIN && NONE(Z_SPI_SENSORLESS, Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
     UPDATE_ENDSTOP_BIT(Z, MIN);
     #if ENABLED(Z_MULTI_ENDSTOPS)
       #if HAS_Z2_MIN
         UPDATE_ENDSTOP_BIT(Z2, MIN);
       #else
         COPY_LIVE_STATE(Z_MIN, Z2_MIN);
       #endif
       #if NUM_Z_STEPPER_DRIVERS >= 3
         #if HAS_Z3_MIN
           UPDATE_ENDSTOP_BIT(Z3, MIN);
@@ -600,23 +609,27 @@ void Endstops::update() {
       #if NUM_Z_STEPPER_DRIVERS >= 4
         #if HAS_Z4_MIN
           UPDATE_ENDSTOP_BIT(Z4, MIN);
         #else
           COPY_LIVE_STATE(Z_MIN, Z4_MIN);
         #endif
       #endif
     #endif
   #endif
 
-  // When closing the gap check the enabled probe
-  #if HAS_CUSTOM_PROBE_PIN
-    UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
+  #if HAS_BED_PROBE
+    // When closing the gap check the enabled probe
+    if (true
+      #if ENABLED(PROBE_ACTIVATION_SWITCH)
+        || READ(PROBE_ACTIVATION_SWITCH_PIN) == PROBE_ACTIVATION_SWITCH_STATE
+      #endif
+    ) UPDATE_ENDSTOP_BIT(Z, TERN(HAS_CUSTOM_PROBE_PIN, MIN_PROBE, MIN));
   #endif
 
   #if HAS_Z_MAX && !Z_SPI_SENSORLESS
     // Check both Z dual endstops
     #if ENABLED(Z_MULTI_ENDSTOPS)
       UPDATE_ENDSTOP_BIT(Z, MAX);
       #if HAS_Z2_MAX
         UPDATE_ENDSTOP_BIT(Z2, MAX);
       #else
         COPY_LIVE_STATE(Z_MAX, Z2_MAX);

commit 58ac815822b4c04f29b66ddf076156e6b4994749
Author: wmariz <11435639+wmariz@users.noreply.github.com>
Date:   Thu Nov 26 10:58:19 2020 -0300

    Level Corners with Probe option (#20241)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 697ced7833..ef0b92a7ee 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -41,20 +41,24 @@
 #endif
 
 #if ENABLED(BLTOUCH)
   #include "../feature/bltouch.h"
 #endif
 
 #if ENABLED(JOYSTICK)
   #include "../feature/joystick.h"
 #endif
 
+#if HAS_BED_PROBE
+  #include "probe.h"
+#endif
+
 Endstops endstops;
 
 // private:
 
 bool Endstops::enabled, Endstops::enabled_globally; // Initialized by settings.load()
 volatile uint8_t Endstops::hit_state;
 
 Endstops::esbits_t Endstops::live_state = 0;
 
 #if ENDSTOP_NOISE_THRESHOLD
@@ -448,21 +452,21 @@ void _O2 Endstops::report_states() {
   #if HAS_Z2_MAX
     ES_REPORT(Z2_MAX);
   #endif
   #if HAS_Z3_MAX
     ES_REPORT(Z3_MAX);
   #endif
   #if HAS_Z4_MAX
     ES_REPORT(Z4_MAX);
   #endif
   #if HAS_CUSTOM_PROBE_PIN
-    print_es_state(READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING, PSTR(STR_Z_PROBE));
+    print_es_state(PROBE_TRIGGERED(), PSTR(STR_Z_PROBE));
   #endif
   #if HAS_FILAMENT_SENSOR
     #if NUM_RUNOUT_SENSORS == 1
       print_es_state(READ(FIL_RUNOUT1_PIN) != FIL_RUNOUT1_STATE, PSTR(STR_FILAMENT_RUNOUT_SENSOR));
     #else
       #define _CASE_RUNOUT(N) case N: pin = FIL_RUNOUT##N##_PIN; state = FIL_RUNOUT##N##_STATE; break;
       LOOP_S_LE_N(i, 1, NUM_RUNOUT_SENSORS) {
         pin_t pin;
         uint8_t state;
         switch (i) {

commit 0465e0ae3aaec257618d095f7e2b28ef677dbe4a
Author: Costas Basdekis <costas.basdekis@gmail.com>
Date:   Wed Nov 11 06:39:23 2020 +0000

    Distinct runout states (#19965)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 825194cf45..697ced7833 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -452,32 +452,33 @@ void _O2 Endstops::report_states() {
     ES_REPORT(Z3_MAX);
   #endif
   #if HAS_Z4_MAX
     ES_REPORT(Z4_MAX);
   #endif
   #if HAS_CUSTOM_PROBE_PIN
     print_es_state(READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING, PSTR(STR_Z_PROBE));
   #endif
   #if HAS_FILAMENT_SENSOR
     #if NUM_RUNOUT_SENSORS == 1
-      print_es_state(READ(FIL_RUNOUT_PIN) != FIL_RUNOUT_STATE, PSTR(STR_FILAMENT_RUNOUT_SENSOR));
+      print_es_state(READ(FIL_RUNOUT1_PIN) != FIL_RUNOUT1_STATE, PSTR(STR_FILAMENT_RUNOUT_SENSOR));
     #else
-      #define _CASE_RUNOUT(N) case N: pin = FIL_RUNOUT##N##_PIN; break;
+      #define _CASE_RUNOUT(N) case N: pin = FIL_RUNOUT##N##_PIN; state = FIL_RUNOUT##N##_STATE; break;
       LOOP_S_LE_N(i, 1, NUM_RUNOUT_SENSORS) {
         pin_t pin;
+        uint8_t state;
         switch (i) {
           default: continue;
           REPEAT_S(1, INCREMENT(NUM_RUNOUT_SENSORS), _CASE_RUNOUT)
         }
         SERIAL_ECHOPGM(STR_FILAMENT_RUNOUT_SENSOR);
         if (i > 1) SERIAL_CHAR(' ', '0' + i);
-        print_es_state(extDigitalRead(pin) != FIL_RUNOUT_STATE);
+        print_es_state(extDigitalRead(pin) != state);
       }
       #undef _CASE_RUNOUT
     #endif
   #endif
 
   TERN_(BLTOUCH, bltouch._reset_SW_mode());
   TERN_(JOYSTICK_DEBUG, joystick.report());
 
 } // Endstops::report_states
 

commit 2da25d67e155fa0bbf07a6e3767a2a15abb75726
Author: LinFor <linfor@gmail.com>
Date:   Sat Nov 7 12:37:45 2020 +0300

    Fix Endstop Interrupts with SPI endstops, sanity checks (#20051)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 928c9ad8b9..825194cf45 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -892,20 +892,23 @@ void Endstops::update() {
         #if CORE_IS_XZ && X_SPI_SENSORLESS
           || stepperX.test_stall_status()
         #elif CORE_IS_YZ && Y_SPI_SENSORLESS
           || stepperY.test_stall_status()
         #endif
       )) {
         SBI(live_state, Z_ENDSTOP);
         hit = true;
       }
     #endif
+
+    if (TERN0(ENDSTOP_INTERRUPTS_FEATURE, hit)) update();
+
     return hit;
   }
 
   void Endstops::clear_endstop_state() {
     TERN_(X_SPI_SENSORLESS, CBI(live_state, X_ENDSTOP));
     TERN_(Y_SPI_SENSORLESS, CBI(live_state, Y_ENDSTOP));
     TERN_(Z_SPI_SENSORLESS, CBI(live_state, Z_ENDSTOP));
   }
 
 #endif // SPI_ENDSTOPS

commit eaf6777a6643a6fab23ceaaa4699cb2466ea6b83
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Oct 16 19:36:25 2020 -0500

    Rename ultralcd => marlinui

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 712182a0ea..928c9ad8b9 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -23,21 +23,21 @@
 /**
  * endstops.cpp - A singleton object to manage endstops
  */
 
 #include "endstops.h"
 #include "stepper.h"
 
 #include "../MarlinCore.h"
 #include "../sd/cardreader.h"
 #include "temperature.h"
-#include "../lcd/ultralcd.h"
+#include "../lcd/marlinui.h"
 
 #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
   #include HAL_PATH(../HAL, endstop_interrupts.h)
 #endif
 
 #if BOTH(SD_ABORT_ON_ENDSTOP_HIT, SDSUPPORT)
   #include "printcounter.h" // for print_job_timer
 #endif
 
 #if ENABLED(BLTOUCH)

commit c2c6a679ea4bdf48ce1800a8831fcec36c09ce53
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 28 01:13:27 2020 -0500

    Rename LCD conditionals (#19533)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index a3a89736e5..712182a0ea 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -344,21 +344,21 @@ void Endstops::resync() {
     monitor_count &= 0x7F;
     if (!monitor_count) monitor();      // report changes in endstop status
   }
 #endif
 
 void Endstops::event_handler() {
   static uint8_t prev_hit_state; // = 0
   if (hit_state == prev_hit_state) return;
   prev_hit_state = hit_state;
   if (hit_state) {
-    #if HAS_SPI_LCD
+    #if HAS_WIRED_LCD
       char chrX = ' ', chrY = ' ', chrZ = ' ', chrP = ' ';
       #define _SET_STOP_CHAR(A,C) (chr## A = C)
     #else
       #define _SET_STOP_CHAR(A,C) ;
     #endif
 
     #define _ENDSTOP_HIT_ECHO(A,C) do{ \
       SERIAL_ECHOPAIR(" " STRINGIFY(A) ":", planner.triggered_position_mm(_AXIS(A))); \
       _SET_STOP_CHAR(A,C); }while(0)
 
@@ -375,21 +375,21 @@ void Endstops::event_handler() {
     ENDSTOP_HIT_TEST_X();
     ENDSTOP_HIT_TEST_Y();
     ENDSTOP_HIT_TEST_Z();
 
     #if HAS_CUSTOM_PROBE_PIN
       #define P_AXIS Z_AXIS
       if (TEST(hit_state, Z_MIN_PROBE)) _ENDSTOP_HIT_ECHO(P, 'P');
     #endif
     SERIAL_EOL();
 
-    TERN_(HAS_SPI_LCD, ui.status_printf_P(0, PSTR(S_FMT " %c %c %c %c"), GET_TEXT(MSG_LCD_ENDSTOPS), chrX, chrY, chrZ, chrP));
+    TERN_(HAS_WIRED_LCD, ui.status_printf_P(0, PSTR(S_FMT " %c %c %c %c"), GET_TEXT(MSG_LCD_ENDSTOPS), chrX, chrY, chrZ, chrP));
 
     #if BOTH(SD_ABORT_ON_ENDSTOP_HIT, SDSUPPORT)
       if (planner.abort_on_endstop_hit) {
         card.endFilePrint();
         quickstop_stepper();
         thermalManager.disable_all_heaters();
         print_job_timer.stop();
       }
     #endif
   }

commit 76d8d1742c1d4a1efe0fd6c0645d3fc656bfd0b2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 20 18:29:08 2020 -0500

    Add multi-extruder condition

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 1169ede2dc..a3a89736e5 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -498,21 +498,21 @@ void Endstops::update() {
   #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT_TO(live_state, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
   #define COPY_LIVE_STATE(SRC_BIT, DST_BIT) SET_BIT_TO(live_state, DST_BIT, TEST(live_state, SRC_BIT))
 
   #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && NONE(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY)
     // If G38 command is active check Z_MIN_PROBE for ALL movement
     if (G38_move) UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
   #endif
 
   // With Dual X, endstops are only checked in the homing direction for the active extruder
   #if ENABLED(DUAL_X_CARRIAGE)
-    #define E0_ACTIVE stepper.movement_extruder() == 0
+    #define E0_ACTIVE stepper.last_moved_extruder == 0
     #define X_MIN_TEST() ((X_HOME_DIR < 0 && E0_ACTIVE) || (X2_HOME_DIR < 0 && !E0_ACTIVE))
     #define X_MAX_TEST() ((X_HOME_DIR > 0 && E0_ACTIVE) || (X2_HOME_DIR > 0 && !E0_ACTIVE))
   #else
     #define X_MIN_TEST() true
     #define X_MAX_TEST() true
   #endif
 
   // Use HEAD for core axes, AXIS for others
   #if ANY(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY)
     #define X_AXIS_HEAD X_HEAD

commit e97e6865c3e587a04ae2878e72a8dfb137534b7e
Author: Victor Sokolov <gzigzigzeo@gmail.com>
Date:   Fri Sep 4 05:12:53 2020 +0400

    MarkForged kinematics (#19235)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 289270072d..1169ede2dc 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -491,42 +491,42 @@ void _O2 Endstops::report_states() {
 // Check endstops - Could be called from Temperature ISR!
 void Endstops::update() {
 
   #if !ENDSTOP_NOISE_THRESHOLD
     if (!abort_enabled()) return;
   #endif
 
   #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT_TO(live_state, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
   #define COPY_LIVE_STATE(SRC_BIT, DST_BIT) SET_BIT_TO(live_state, DST_BIT, TEST(live_state, SRC_BIT))
 
-  #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && !(CORE_IS_XY || CORE_IS_XZ)
+  #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && NONE(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY)
     // If G38 command is active check Z_MIN_PROBE for ALL movement
     if (G38_move) UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
   #endif
 
   // With Dual X, endstops are only checked in the homing direction for the active extruder
   #if ENABLED(DUAL_X_CARRIAGE)
     #define E0_ACTIVE stepper.movement_extruder() == 0
     #define X_MIN_TEST() ((X_HOME_DIR < 0 && E0_ACTIVE) || (X2_HOME_DIR < 0 && !E0_ACTIVE))
     #define X_MAX_TEST() ((X_HOME_DIR > 0 && E0_ACTIVE) || (X2_HOME_DIR > 0 && !E0_ACTIVE))
   #else
     #define X_MIN_TEST() true
     #define X_MAX_TEST() true
   #endif
 
   // Use HEAD for core axes, AXIS for others
-  #if CORE_IS_XY || CORE_IS_XZ
+  #if ANY(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY)
     #define X_AXIS_HEAD X_HEAD
   #else
     #define X_AXIS_HEAD X_AXIS
   #endif
-  #if CORE_IS_XY || CORE_IS_YZ
+  #if ANY(CORE_IS_XY, CORE_IS_YZ, MARKFORGED_XY)
     #define Y_AXIS_HEAD Y_HEAD
   #else
     #define Y_AXIS_HEAD Y_AXIS
   #endif
   #if CORE_IS_XZ || CORE_IS_YZ
     #define Z_AXIS_HEAD Z_HEAD
   #else
     #define Z_AXIS_HEAD Z_AXIS
   #endif
 
@@ -729,21 +729,21 @@ void Endstops::update() {
   #if DISABLED(Z_MULTI_ENDSTOPS)
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_ENDSTOP(Z, MINMAX)
   #elif NUM_Z_STEPPER_DRIVERS == 4
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_QUAD_ENDSTOP(Z, MINMAX)
   #elif NUM_Z_STEPPER_DRIVERS == 3
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_TRIPLE_ENDSTOP(Z, MINMAX)
   #else
     #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_DUAL_ENDSTOP(Z, MINMAX)
   #endif
 
-  #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && !(CORE_IS_XY || CORE_IS_XZ)
+  #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && NONE(CORE_IS_XY, CORE_IS_XZ, MARKFORGED_XY)
     #if ENABLED(G38_PROBE_AWAY)
       #define _G38_OPEN_STATE (G38_move >= 4)
     #else
       #define _G38_OPEN_STATE LOW
     #endif
     // If G38 command is active check Z_MIN_PROBE for ALL movement
     if (G38_move && TEST_ENDSTOP(_ENDSTOP(Z, MIN_PROBE)) != _G38_OPEN_STATE) {
            if (stepper.axis_is_moving(X_AXIS)) { _ENDSTOP_HIT(X, MIN); planner.endstop_triggered(X_AXIS); }
       else if (stepper.axis_is_moving(Y_AXIS)) { _ENDSTOP_HIT(Y, MIN); planner.endstop_triggered(Y_AXIS); }
       else if (stepper.axis_is_moving(Z_AXIS)) { _ENDSTOP_HIT(Z, MIN); planner.endstop_triggered(Z_AXIS); }
@@ -858,33 +858,33 @@ void Endstops::update() {
     }
   }
 } // Endstops::update()
 
 #if ENABLED(SPI_ENDSTOPS)
 
   bool Endstops::tmc_spi_homing_check() {
     bool hit = false;
     #if X_SPI_SENSORLESS
       if (tmc_spi_homing.x && (stepperX.test_stall_status()
-        #if CORE_IS_XY && Y_SPI_SENSORLESS
+        #if ANY(CORE_IS_XY, MARKFORGED_XY) && Y_SPI_SENSORLESS
           || stepperY.test_stall_status()
         #elif CORE_IS_XZ && Z_SPI_SENSORLESS
           || stepperZ.test_stall_status()
         #endif
       )) {
         SBI(live_state, X_ENDSTOP);
         hit = true;
       }
     #endif
     #if Y_SPI_SENSORLESS
       if (tmc_spi_homing.y && (stepperY.test_stall_status()
-        #if CORE_IS_XY && X_SPI_SENSORLESS
+        #if ANY(CORE_IS_XY, MARKFORGED_XY) && X_SPI_SENSORLESS
           || stepperX.test_stall_status()
         #elif CORE_IS_YZ && Z_SPI_SENSORLESS
           || stepperZ.test_stall_status()
         #endif
       )) {
         SBI(live_state, Y_ENDSTOP);
         hit = true;
       }
     #endif
     #if Z_SPI_SENSORLESS

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index a9a0a7e9bf..289270072d 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -9,21 +9,21 @@
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 
 /**
  * endstops.cpp - A singleton object to manage endstops
  */
 
 #include "endstops.h"
 #include "stepper.h"
 

commit 2c238e4fc2f18da08d7cb171bb7236beccdd6f83
Author: Speaka <48431623+Speaka@users.noreply.github.com>
Date:   Sun Jul 12 20:16:56 2020 +0200

    Option for extra endstop check (#18424)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 9cf283ccba..a9a0a7e9bf 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -854,69 +854,65 @@ void Endstops::update() {
         #elif CORE_DIAG(YZ, Y, MAX)
           PROCESS_CORE_ENDSTOP(Y,MAX,Z,MAX);
         #endif
       #endif
     }
   }
 } // Endstops::update()
 
 #if ENABLED(SPI_ENDSTOPS)
 
-  #define X_STOP (X_HOME_DIR < 0 ? X_MIN : X_MAX)
-  #define Y_STOP (Y_HOME_DIR < 0 ? Y_MIN : Y_MAX)
-  #define Z_STOP (Z_HOME_DIR < 0 ? Z_MIN : Z_MAX)
-
   bool Endstops::tmc_spi_homing_check() {
     bool hit = false;
     #if X_SPI_SENSORLESS
       if (tmc_spi_homing.x && (stepperX.test_stall_status()
         #if CORE_IS_XY && Y_SPI_SENSORLESS
           || stepperY.test_stall_status()
         #elif CORE_IS_XZ && Z_SPI_SENSORLESS
           || stepperZ.test_stall_status()
         #endif
       )) {
-        SBI(live_state, X_STOP);
+        SBI(live_state, X_ENDSTOP);
         hit = true;
       }
     #endif
     #if Y_SPI_SENSORLESS
       if (tmc_spi_homing.y && (stepperY.test_stall_status()
         #if CORE_IS_XY && X_SPI_SENSORLESS
           || stepperX.test_stall_status()
         #elif CORE_IS_YZ && Z_SPI_SENSORLESS
           || stepperZ.test_stall_status()
         #endif
       )) {
-        SBI(live_state, Y_STOP);
+        SBI(live_state, Y_ENDSTOP);
         hit = true;
       }
     #endif
     #if Z_SPI_SENSORLESS
       if (tmc_spi_homing.z && (stepperZ.test_stall_status()
         #if CORE_IS_XZ && X_SPI_SENSORLESS
           || stepperX.test_stall_status()
         #elif CORE_IS_YZ && Y_SPI_SENSORLESS
           || stepperY.test_stall_status()
         #endif
       )) {
-        SBI(live_state, Z_STOP);
+        SBI(live_state, Z_ENDSTOP);
         hit = true;
       }
     #endif
     return hit;
   }
 
   void Endstops::clear_endstop_state() {
-    TERN_(X_SPI_SENSORLESS, CBI(live_state, X_STOP));
-    TERN_(Y_SPI_SENSORLESS, CBI(live_state, Y_STOP));
-    TERN_(Z_SPI_SENSORLESS, CBI(live_state, Z_STOP));
+    TERN_(X_SPI_SENSORLESS, CBI(live_state, X_ENDSTOP));
+    TERN_(Y_SPI_SENSORLESS, CBI(live_state, Y_ENDSTOP));
+    TERN_(Z_SPI_SENSORLESS, CBI(live_state, Z_ENDSTOP));
   }
 
 #endif // SPI_ENDSTOPS
 
 #if ENABLED(PINS_DEBUGGING)
 
   bool Endstops::monitor_flag = false;
 
   /**
    * Monitor Endstops and Z Probe for changes

commit c02451b602d6ee24d09f4f41269c85c0972a2279
Author: Robby Candra <robbycandra.mail@gmail.com>
Date:   Mon Jul 6 05:42:19 2020 +0700

    Filament Runout Inverting => State (#18537)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 47d63df64b..9cf283ccba 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -452,32 +452,32 @@ void _O2 Endstops::report_states() {
     ES_REPORT(Z3_MAX);
   #endif
   #if HAS_Z4_MAX
     ES_REPORT(Z4_MAX);
   #endif
   #if HAS_CUSTOM_PROBE_PIN
     print_es_state(READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING, PSTR(STR_Z_PROBE));
   #endif
   #if HAS_FILAMENT_SENSOR
     #if NUM_RUNOUT_SENSORS == 1
-      print_es_state(READ(FIL_RUNOUT_PIN) != FIL_RUNOUT_INVERTING, PSTR(STR_FILAMENT_RUNOUT_SENSOR));
+      print_es_state(READ(FIL_RUNOUT_PIN) != FIL_RUNOUT_STATE, PSTR(STR_FILAMENT_RUNOUT_SENSOR));
     #else
       #define _CASE_RUNOUT(N) case N: pin = FIL_RUNOUT##N##_PIN; break;
       LOOP_S_LE_N(i, 1, NUM_RUNOUT_SENSORS) {
         pin_t pin;
         switch (i) {
           default: continue;
           REPEAT_S(1, INCREMENT(NUM_RUNOUT_SENSORS), _CASE_RUNOUT)
         }
         SERIAL_ECHOPGM(STR_FILAMENT_RUNOUT_SENSOR);
         if (i > 1) SERIAL_CHAR(' ', '0' + i);
-        print_es_state(extDigitalRead(pin) != FIL_RUNOUT_INVERTING);
+        print_es_state(extDigitalRead(pin) != FIL_RUNOUT_STATE);
       }
       #undef _CASE_RUNOUT
     #endif
   #endif
 
   TERN_(BLTOUCH, bltouch._reset_SW_mode());
   TERN_(JOYSTICK_DEBUG, joystick.report());
 
 } // Endstops::report_states
 

commit 45a01a3ecab5247826c8d1cb3d7b531724d774e7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 16 01:06:18 2020 -0500

    Non-SPI core homing pin tests (#17996)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 5cfd7771a0..47d63df64b 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -667,20 +667,29 @@ void Endstops::update() {
   #define _ENDSTOP_HIT(AXIS, MINMAX) SBI(hit_state, _ENDSTOP(AXIS, MINMAX))
 
   // Call the endstop triggered routine for single endstops
   #define PROCESS_ENDSTOP(AXIS, MINMAX) do { \
     if (TEST_ENDSTOP(_ENDSTOP(AXIS, MINMAX))) { \
       _ENDSTOP_HIT(AXIS, MINMAX); \
       planner.endstop_triggered(_AXIS(AXIS)); \
     } \
   }while(0)
 
+  // Core Sensorless Homing needs to test an Extra Pin
+  #define CORE_DIAG(QQ,A,MM) (CORE_IS_##QQ && A##_SENSORLESS && !A##_SPI_SENSORLESS && HAS_##A##_##MM)
+  #define PROCESS_CORE_ENDSTOP(A1,M1,A2,M2) do { \
+    if (TEST_ENDSTOP(_ENDSTOP(A1,M1))) { \
+      _ENDSTOP_HIT(A2,M2); \
+      planner.endstop_triggered(_AXIS(A2)); \
+    } \
+  }while(0)
+
   // Call the endstop triggered routine for dual endstops
   #define PROCESS_DUAL_ENDSTOP(A, MINMAX) do { \
     const byte dual_hit = TEST_ENDSTOP(_ENDSTOP(A, MINMAX)) | (TEST_ENDSTOP(_ENDSTOP(A##2, MINMAX)) << 1); \
     if (dual_hit) { \
       _ENDSTOP_HIT(A, MINMAX); \
       /* if not performing home or if both endstops were trigged during homing... */ \
       if (!stepper.separate_multi_axis || dual_hit == 0b11) \
         planner.endstop_triggered(_AXIS(A)); \
     } \
   }while(0)
@@ -741,63 +750,117 @@ void Endstops::update() {
       G38_did_trigger = true;
     }
   #endif
 
   // Signal, after validation, if an endstop limit is pressed or not
 
   if (stepper.axis_is_moving(X_AXIS)) {
     if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
       #if HAS_X_MIN || (X_SPI_SENSORLESS && X_HOME_DIR < 0)
         PROCESS_ENDSTOP_X(MIN);
+        #if   CORE_DIAG(XY, Y, MIN)
+          PROCESS_CORE_ENDSTOP(Y,MIN,X,MIN);
+        #elif CORE_DIAG(XY, Y, MAX)
+          PROCESS_CORE_ENDSTOP(Y,MAX,X,MIN);
+        #elif CORE_DIAG(XZ, Z, MIN)
+          PROCESS_CORE_ENDSTOP(Z,MIN,X,MIN);
+        #elif CORE_DIAG(XZ, Z, MAX)
+          PROCESS_CORE_ENDSTOP(Z,MAX,X,MIN);
+        #endif
       #endif
     }
     else { // +direction
       #if HAS_X_MAX || (X_SPI_SENSORLESS && X_HOME_DIR > 0)
         PROCESS_ENDSTOP_X(MAX);
+        #if   CORE_DIAG(XY, Y, MIN)
+          PROCESS_CORE_ENDSTOP(Y,MIN,X,MAX);
+        #elif CORE_DIAG(XY, Y, MAX)
+          PROCESS_CORE_ENDSTOP(Y,MAX,X,MAX);
+        #elif CORE_DIAG(XZ, Z, MIN)
+          PROCESS_CORE_ENDSTOP(Z,MIN,X,MAX);
+        #elif CORE_DIAG(XZ, Z, MAX)
+          PROCESS_CORE_ENDSTOP(Z,MAX,X,MAX);
+        #endif
       #endif
     }
   }
 
   if (stepper.axis_is_moving(Y_AXIS)) {
     if (stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
       #if HAS_Y_MIN || (Y_SPI_SENSORLESS && Y_HOME_DIR < 0)
         PROCESS_ENDSTOP_Y(MIN);
+        #if   CORE_DIAG(XY, X, MIN)
+          PROCESS_CORE_ENDSTOP(X,MIN,Y,MIN);
+        #elif CORE_DIAG(XY, X, MAX)
+          PROCESS_CORE_ENDSTOP(X,MAX,Y,MIN);
+        #elif CORE_DIAG(YZ, Z, MIN)
+          PROCESS_CORE_ENDSTOP(Z,MIN,Y,MIN);
+        #elif CORE_DIAG(YZ, Z, MAX)
+          PROCESS_CORE_ENDSTOP(Z,MAX,Y,MIN);
+        #endif
       #endif
     }
     else { // +direction
       #if HAS_Y_MAX || (Y_SPI_SENSORLESS && Y_HOME_DIR > 0)
         PROCESS_ENDSTOP_Y(MAX);
+        #if   CORE_DIAG(XY, X, MIN)
+          PROCESS_CORE_ENDSTOP(X,MIN,Y,MAX);
+        #elif CORE_DIAG(XY, X, MAX)
+          PROCESS_CORE_ENDSTOP(X,MAX,Y,MAX);
+        #elif CORE_DIAG(YZ, Z, MIN)
+          PROCESS_CORE_ENDSTOP(Z,MIN,Y,MAX);
+        #elif CORE_DIAG(YZ, Z, MAX)
+          PROCESS_CORE_ENDSTOP(Z,MAX,Y,MAX);
+        #endif
       #endif
     }
   }
 
   if (stepper.axis_is_moving(Z_AXIS)) {
     if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
 
       #if HAS_Z_MIN || (Z_SPI_SENSORLESS && Z_HOME_DIR < 0)
         if ( TERN1(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN, z_probe_enabled)
           && TERN1(HAS_CUSTOM_PROBE_PIN, !z_probe_enabled)
         ) PROCESS_ENDSTOP_Z(MIN);
+        #if   CORE_DIAG(XZ, X, MIN)
+          PROCESS_CORE_ENDSTOP(X,MIN,Z,MIN);
+        #elif CORE_DIAG(XZ, X, MAX)
+          PROCESS_CORE_ENDSTOP(X,MAX,Z,MIN);
+        #elif CORE_DIAG(YZ, Y, MIN)
+          PROCESS_CORE_ENDSTOP(Y,MIN,Z,MIN);
+        #elif CORE_DIAG(YZ, Y, MAX)
+          PROCESS_CORE_ENDSTOP(Y,MAX,Z,MIN);
+        #endif
       #endif
 
       // When closing the gap check the enabled probe
       #if HAS_CUSTOM_PROBE_PIN
         if (z_probe_enabled) PROCESS_ENDSTOP(Z, MIN_PROBE);
       #endif
     }
     else { // Z +direction. Gantry up, bed down.
       #if HAS_Z_MAX || (Z_SPI_SENSORLESS && Z_HOME_DIR > 0)
         #if ENABLED(Z_MULTI_ENDSTOPS)
           PROCESS_ENDSTOP_Z(MAX);
         #elif !HAS_CUSTOM_PROBE_PIN || Z_MAX_PIN != Z_MIN_PROBE_PIN  // No probe or probe is Z_MIN || Probe is not Z_MAX
           PROCESS_ENDSTOP(Z, MAX);
         #endif
+        #if   CORE_DIAG(XZ, X, MIN)
+          PROCESS_CORE_ENDSTOP(X,MIN,Z,MAX);
+        #elif CORE_DIAG(XZ, X, MAX)
+          PROCESS_CORE_ENDSTOP(X,MAX,Z,MAX);
+        #elif CORE_DIAG(YZ, Y, MIN)
+          PROCESS_CORE_ENDSTOP(Y,MIN,Z,MAX);
+        #elif CORE_DIAG(YZ, Y, MAX)
+          PROCESS_CORE_ENDSTOP(Y,MAX,Z,MAX);
+        #endif
       #endif
     }
   }
 } // Endstops::update()
 
 #if ENABLED(SPI_ENDSTOPS)
 
   #define X_STOP (X_HOME_DIR < 0 ? X_MIN : X_MAX)
   #define Y_STOP (Y_HOME_DIR < 0 ? Y_MIN : Y_MAX)
   #define Z_STOP (Z_HOME_DIR < 0 ? Z_MIN : Z_MAX)

commit 6ae7a40f994ffb2d2be10a041bdfe89f4585db91
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 14 13:00:47 2020 -0500

    CoreXY sensorless homing (#17972)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 092043b59c..5cfd7771a0 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -735,21 +735,22 @@ void Endstops::update() {
     #endif
     // If G38 command is active check Z_MIN_PROBE for ALL movement
     if (G38_move && TEST_ENDSTOP(_ENDSTOP(Z, MIN_PROBE)) != _G38_OPEN_STATE) {
            if (stepper.axis_is_moving(X_AXIS)) { _ENDSTOP_HIT(X, MIN); planner.endstop_triggered(X_AXIS); }
       else if (stepper.axis_is_moving(Y_AXIS)) { _ENDSTOP_HIT(Y, MIN); planner.endstop_triggered(Y_AXIS); }
       else if (stepper.axis_is_moving(Z_AXIS)) { _ENDSTOP_HIT(Z, MIN); planner.endstop_triggered(Z_AXIS); }
       G38_did_trigger = true;
     }
   #endif
 
-  // Now, we must signal, after validation, if an endstop limit is pressed or not
+  // Signal, after validation, if an endstop limit is pressed or not
+
   if (stepper.axis_is_moving(X_AXIS)) {
     if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
       #if HAS_X_MIN || (X_SPI_SENSORLESS && X_HOME_DIR < 0)
         PROCESS_ENDSTOP_X(MIN);
       #endif
     }
     else { // +direction
       #if HAS_X_MAX || (X_SPI_SENSORLESS && X_HOME_DIR > 0)
         PROCESS_ENDSTOP_X(MAX);
       #endif
@@ -797,33 +798,51 @@ void Endstops::update() {
 
 #if ENABLED(SPI_ENDSTOPS)
 
   #define X_STOP (X_HOME_DIR < 0 ? X_MIN : X_MAX)
   #define Y_STOP (Y_HOME_DIR < 0 ? Y_MIN : Y_MAX)
   #define Z_STOP (Z_HOME_DIR < 0 ? Z_MIN : Z_MAX)
 
   bool Endstops::tmc_spi_homing_check() {
     bool hit = false;
     #if X_SPI_SENSORLESS
-      if (tmc_spi_homing.x && stepperX.test_stall_status()) {
+      if (tmc_spi_homing.x && (stepperX.test_stall_status()
+        #if CORE_IS_XY && Y_SPI_SENSORLESS
+          || stepperY.test_stall_status()
+        #elif CORE_IS_XZ && Z_SPI_SENSORLESS
+          || stepperZ.test_stall_status()
+        #endif
+      )) {
         SBI(live_state, X_STOP);
         hit = true;
       }
     #endif
     #if Y_SPI_SENSORLESS
-      if (tmc_spi_homing.y && stepperY.test_stall_status()) {
+      if (tmc_spi_homing.y && (stepperY.test_stall_status()
+        #if CORE_IS_XY && X_SPI_SENSORLESS
+          || stepperX.test_stall_status()
+        #elif CORE_IS_YZ && Z_SPI_SENSORLESS
+          || stepperZ.test_stall_status()
+        #endif
+      )) {
         SBI(live_state, Y_STOP);
         hit = true;
       }
     #endif
     #if Z_SPI_SENSORLESS
-      if (tmc_spi_homing.z && stepperZ.test_stall_status()) {
+      if (tmc_spi_homing.z && (stepperZ.test_stall_status()
+        #if CORE_IS_XZ && X_SPI_SENSORLESS
+          || stepperX.test_stall_status()
+        #elif CORE_IS_YZ && Y_SPI_SENSORLESS
+          || stepperY.test_stall_status()
+        #endif
+      )) {
         SBI(live_state, Z_STOP);
         hit = true;
       }
     #endif
     return hit;
   }
 
   void Endstops::clear_endstop_state() {
     TERN_(X_SPI_SENSORLESS, CBI(live_state, X_STOP));
     TERN_(Y_SPI_SENSORLESS, CBI(live_state, Y_STOP));

commit 6d90d1e1f552dca5e21bc61b676b8e8ce731b280
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Apr 22 16:35:03 2020 -0500

    Apply TERN to compact code (#17619)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index f55d56b959..092043b59c 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -269,41 +269,31 @@ void Endstops::init() {
   #if HAS_CUSTOM_PROBE_PIN
     #if ENABLED(ENDSTOPPULLUP_ZMIN_PROBE)
       SET_INPUT_PULLUP(Z_MIN_PROBE_PIN);
     #elif ENABLED(ENDSTOPPULLDOWN_ZMIN_PROBE)
       SET_INPUT_PULLDOWN(Z_MIN_PROBE_PIN);
     #else
       SET_INPUT(Z_MIN_PROBE_PIN);
     #endif
   #endif
 
-  #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-    setup_endstop_interrupts();
-  #endif
+  TERN_(ENDSTOP_INTERRUPTS_FEATURE, setup_endstop_interrupts());
 
   // Enable endstops
-  enable_globally(
-    #if ENABLED(ENDSTOPS_ALWAYS_ON_DEFAULT)
-      true
-    #else
-      false
-    #endif
-  );
+  enable_globally(ENABLED(ENDSTOPS_ALWAYS_ON_DEFAULT));
 
 } // Endstops::init
 
 // Called at ~1KHz from Temperature ISR: Poll endstop state if required
 void Endstops::poll() {
 
-  #if ENABLED(PINS_DEBUGGING)
-    run_monitor();  // report changes in endstop status
-  #endif
+  TERN_(PINS_DEBUGGING, run_monitor()); // Report changes in endstop status
 
   #if DISABLED(ENDSTOP_INTERRUPTS_FEATURE)
     update();
   #elif ENDSTOP_NOISE_THRESHOLD
     if (endstop_poll_count) update();
   #endif
 }
 
 void Endstops::enable_globally(const bool onoff) {
   enabled_globally = enabled = onoff;
@@ -334,28 +324,23 @@ void Endstops::not_homing() {
   void Endstops::enable_z_probe(const bool onoff) {
     z_probe_enabled = onoff;
     resync();
   }
 #endif
 
 // Get the stable endstop states when enabled
 void Endstops::resync() {
   if (!abort_enabled()) return;     // If endstops/probes are disabled the loop below can hang
 
-  #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-    update();
-  #else
-    safe_delay(2);  // Wait for Temperature ISR to run at least once (runs at 1KHz)
-  #endif
-  #if ENDSTOP_NOISE_THRESHOLD
-    while (endstop_poll_count) safe_delay(1);
-  #endif
+  // Wait for Temperature ISR to run at least once (runs at 1KHz)
+  TERN(ENDSTOP_INTERRUPTS_FEATURE, update(), safe_delay(2));
+  while (TERN0(ENDSTOP_NOISE_THRESHOLD, endstop_poll_count)) safe_delay(1);
 }
 
 #if ENABLED(PINS_DEBUGGING)
   void Endstops::run_monitor() {
     if (!monitor_flag) return;
     static uint8_t monitor_count = 16;  // offset this check from the others
     monitor_count += _BV(1);            //  15 Hz
     monitor_count &= 0x7F;
     if (!monitor_count) monitor();      // report changes in endstop status
   }
@@ -390,46 +375,42 @@ void Endstops::event_handler() {
     ENDSTOP_HIT_TEST_X();
     ENDSTOP_HIT_TEST_Y();
     ENDSTOP_HIT_TEST_Z();
 
     #if HAS_CUSTOM_PROBE_PIN
       #define P_AXIS Z_AXIS
       if (TEST(hit_state, Z_MIN_PROBE)) _ENDSTOP_HIT_ECHO(P, 'P');
     #endif
     SERIAL_EOL();
 
-    #if HAS_SPI_LCD
-      ui.status_printf_P(0, PSTR(S_FMT " %c %c %c %c"), GET_TEXT(MSG_LCD_ENDSTOPS), chrX, chrY, chrZ, chrP);
-    #endif
+    TERN_(HAS_SPI_LCD, ui.status_printf_P(0, PSTR(S_FMT " %c %c %c %c"), GET_TEXT(MSG_LCD_ENDSTOPS), chrX, chrY, chrZ, chrP));
 
     #if BOTH(SD_ABORT_ON_ENDSTOP_HIT, SDSUPPORT)
       if (planner.abort_on_endstop_hit) {
         card.endFilePrint();
         quickstop_stepper();
         thermalManager.disable_all_heaters();
         print_job_timer.stop();
       }
     #endif
   }
 }
 
 static void print_es_state(const bool is_hit, PGM_P const label=nullptr) {
   if (label) serialprintPGM(label);
   SERIAL_ECHOPGM(": ");
   serialprintPGM(is_hit ? PSTR(STR_ENDSTOP_HIT) : PSTR(STR_ENDSTOP_OPEN));
   SERIAL_EOL();
 }
 
 void _O2 Endstops::report_states() {
-  #if ENABLED(BLTOUCH)
-    bltouch._set_SW_mode();
-  #endif
+  TERN_(BLTOUCH, bltouch._set_SW_mode());
   SERIAL_ECHOLNPGM(STR_M119_REPORT);
   #define ES_REPORT(S) print_es_state(READ(S##_PIN) != S##_ENDSTOP_INVERTING, PSTR(STR_##S))
   #if HAS_X_MIN
     ES_REPORT(X_MIN);
   #endif
   #if HAS_X2_MIN
     ES_REPORT(X2_MIN);
   #endif
   #if HAS_X_MAX
     ES_REPORT(X_MAX);
@@ -487,27 +468,23 @@ void _O2 Endstops::report_states() {
           default: continue;
           REPEAT_S(1, INCREMENT(NUM_RUNOUT_SENSORS), _CASE_RUNOUT)
         }
         SERIAL_ECHOPGM(STR_FILAMENT_RUNOUT_SENSOR);
         if (i > 1) SERIAL_CHAR(' ', '0' + i);
         print_es_state(extDigitalRead(pin) != FIL_RUNOUT_INVERTING);
       }
       #undef _CASE_RUNOUT
     #endif
   #endif
-  #if ENABLED(BLTOUCH)
-    bltouch._reset_SW_mode();
-  #endif
 
-  #if ENABLED(JOYSTICK_DEBUG)
-    joystick.report();
-  #endif
+  TERN_(BLTOUCH, bltouch._reset_SW_mode());
+  TERN_(JOYSTICK_DEBUG, joystick.report());
 
 } // Endstops::report_states
 
 // The following routines are called from an ISR context. It could be the temperature ISR, the
 // endstop ISR or the Stepper ISR.
 
 #define _ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
 #define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN
 #define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_INVERTING
 
@@ -789,26 +766,22 @@ void Endstops::update() {
       #if HAS_Y_MAX || (Y_SPI_SENSORLESS && Y_HOME_DIR > 0)
         PROCESS_ENDSTOP_Y(MAX);
       #endif
     }
   }
 
   if (stepper.axis_is_moving(Z_AXIS)) {
     if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
 
       #if HAS_Z_MIN || (Z_SPI_SENSORLESS && Z_HOME_DIR < 0)
-        if (true
-          #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
-            && z_probe_enabled
-          #elif HAS_CUSTOM_PROBE_PIN
-            && !z_probe_enabled
-          #endif
+        if ( TERN1(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN, z_probe_enabled)
+          && TERN1(HAS_CUSTOM_PROBE_PIN, !z_probe_enabled)
         ) PROCESS_ENDSTOP_Z(MIN);
       #endif
 
       // When closing the gap check the enabled probe
       #if HAS_CUSTOM_PROBE_PIN
         if (z_probe_enabled) PROCESS_ENDSTOP(Z, MIN_PROBE);
       #endif
     }
     else { // Z +direction. Gantry up, bed down.
       #if HAS_Z_MAX || (Z_SPI_SENSORLESS && Z_HOME_DIR > 0)
@@ -845,29 +818,23 @@ void Endstops::update() {
     #if Z_SPI_SENSORLESS
       if (tmc_spi_homing.z && stepperZ.test_stall_status()) {
         SBI(live_state, Z_STOP);
         hit = true;
       }
     #endif
     return hit;
   }
 
   void Endstops::clear_endstop_state() {
-    #if X_SPI_SENSORLESS
-      CBI(live_state, X_STOP);
-    #endif
-    #if Y_SPI_SENSORLESS
-      CBI(live_state, Y_STOP);
-    #endif
-    #if Z_SPI_SENSORLESS
-      CBI(live_state, Z_STOP);
-    #endif
+    TERN_(X_SPI_SENSORLESS, CBI(live_state, X_STOP));
+    TERN_(Y_SPI_SENSORLESS, CBI(live_state, Y_STOP));
+    TERN_(Z_SPI_SENSORLESS, CBI(live_state, Z_STOP));
   }
 
 #endif // SPI_ENDSTOPS
 
 #if ENABLED(PINS_DEBUGGING)
 
   bool Endstops::monitor_flag = false;
 
   /**
    * Monitor Endstops and Z Probe for changes

commit 22da1b2b310158ae3362c54f2534f5f5af30fa83
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Apr 13 14:53:21 2020 -0500

    Rename some "kill" messages

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 1c8384cc53..f55d56b959 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -318,21 +318,21 @@ void Endstops::enable(const bool onoff) {
 
 // Disable / Enable endstops based on ENSTOPS_ONLY_FOR_HOMING and global enable
 void Endstops::not_homing() {
   enabled = enabled_globally;
 }
 
 #if ENABLED(VALIDATE_HOMING_ENDSTOPS)
   // If the last move failed to trigger an endstop, call kill
   void Endstops::validate_homing_move() {
     if (trigger_state()) hit_on_purpose();
-    else kill(GET_TEXT(MSG_LCD_HOMING_FAILED));
+    else kill(GET_TEXT(MSG_KILL_HOMING_FAILED));
   }
 #endif
 
 // Enable / disable endstop z-probe checking
 #if HAS_BED_PROBE
   void Endstops::enable_z_probe(const bool onoff) {
     z_probe_enabled = onoff;
     resync();
   }
 #endif

commit 118bd2f8b2a1f81884cb55a8fc00b708a51aa15b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 13 23:18:16 2020 -0500

    Apply loop shorthand macros (#17159)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 58de4a8d05..1c8384cc53 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -474,21 +474,21 @@ void _O2 Endstops::report_states() {
     ES_REPORT(Z4_MAX);
   #endif
   #if HAS_CUSTOM_PROBE_PIN
     print_es_state(READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING, PSTR(STR_Z_PROBE));
   #endif
   #if HAS_FILAMENT_SENSOR
     #if NUM_RUNOUT_SENSORS == 1
       print_es_state(READ(FIL_RUNOUT_PIN) != FIL_RUNOUT_INVERTING, PSTR(STR_FILAMENT_RUNOUT_SENSOR));
     #else
       #define _CASE_RUNOUT(N) case N: pin = FIL_RUNOUT##N##_PIN; break;
-      for (uint8_t i = 1; i <= NUM_RUNOUT_SENSORS; i++) {
+      LOOP_S_LE_N(i, 1, NUM_RUNOUT_SENSORS) {
         pin_t pin;
         switch (i) {
           default: continue;
           REPEAT_S(1, INCREMENT(NUM_RUNOUT_SENSORS), _CASE_RUNOUT)
         }
         SERIAL_ECHOPGM(STR_FILAMENT_RUNOUT_SENSOR);
         if (i > 1) SERIAL_CHAR(' ', '0' + i);
         print_es_state(extDigitalRead(pin) != FIL_RUNOUT_INVERTING);
       }
       #undef _CASE_RUNOUT

commit 5ebba4b19fbfc4126e092cc382d0f878e3234f77
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Feb 26 04:11:03 2020 -0600

    More serial strings

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 018f471c34..58de4a8d05 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -417,21 +417,21 @@ static void print_es_state(const bool is_hit, PGM_P const label=nullptr) {
   SERIAL_ECHOPGM(": ");
   serialprintPGM(is_hit ? PSTR(STR_ENDSTOP_HIT) : PSTR(STR_ENDSTOP_OPEN));
   SERIAL_EOL();
 }
 
 void _O2 Endstops::report_states() {
   #if ENABLED(BLTOUCH)
     bltouch._set_SW_mode();
   #endif
   SERIAL_ECHOLNPGM(STR_M119_REPORT);
-  #define ES_REPORT(S) print_es_state(READ(S##_PIN) != S##_ENDSTOP_INVERTING, PSTR(MSG_##S))
+  #define ES_REPORT(S) print_es_state(READ(S##_PIN) != S##_ENDSTOP_INVERTING, PSTR(STR_##S))
   #if HAS_X_MIN
     ES_REPORT(X_MIN);
   #endif
   #if HAS_X2_MIN
     ES_REPORT(X2_MIN);
   #endif
   #if HAS_X_MAX
     ES_REPORT(X_MAX);
   #endif
   #if HAS_X2_MAX

commit e78f607ef33044eecde744e77beea87532817c47
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Feb 26 03:02:03 2020 -0600

    Use a STR_ prefix for non-translated strings

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index d291f972d3..018f471c34 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -379,21 +379,21 @@ void Endstops::event_handler() {
 
     #define _ENDSTOP_HIT_TEST(A,C) \
       if (TEST(hit_state, A ##_MIN) || TEST(hit_state, A ##_MAX)) \
         _ENDSTOP_HIT_ECHO(A,C)
 
     #define ENDSTOP_HIT_TEST_X() _ENDSTOP_HIT_TEST(X,'X')
     #define ENDSTOP_HIT_TEST_Y() _ENDSTOP_HIT_TEST(Y,'Y')
     #define ENDSTOP_HIT_TEST_Z() _ENDSTOP_HIT_TEST(Z,'Z')
 
     SERIAL_ECHO_START();
-    SERIAL_ECHOPGM(MSG_ENDSTOPS_HIT);
+    SERIAL_ECHOPGM(STR_ENDSTOPS_HIT);
     ENDSTOP_HIT_TEST_X();
     ENDSTOP_HIT_TEST_Y();
     ENDSTOP_HIT_TEST_Z();
 
     #if HAS_CUSTOM_PROBE_PIN
       #define P_AXIS Z_AXIS
       if (TEST(hit_state, Z_MIN_PROBE)) _ENDSTOP_HIT_ECHO(P, 'P');
     #endif
     SERIAL_EOL();
 
@@ -408,29 +408,29 @@ void Endstops::event_handler() {
         thermalManager.disable_all_heaters();
         print_job_timer.stop();
       }
     #endif
   }
 }
 
 static void print_es_state(const bool is_hit, PGM_P const label=nullptr) {
   if (label) serialprintPGM(label);
   SERIAL_ECHOPGM(": ");
-  serialprintPGM(is_hit ? PSTR(MSG_ENDSTOP_HIT) : PSTR(MSG_ENDSTOP_OPEN));
+  serialprintPGM(is_hit ? PSTR(STR_ENDSTOP_HIT) : PSTR(STR_ENDSTOP_OPEN));
   SERIAL_EOL();
 }
 
 void _O2 Endstops::report_states() {
   #if ENABLED(BLTOUCH)
     bltouch._set_SW_mode();
   #endif
-  SERIAL_ECHOLNPGM(MSG_M119_REPORT);
+  SERIAL_ECHOLNPGM(STR_M119_REPORT);
   #define ES_REPORT(S) print_es_state(READ(S##_PIN) != S##_ENDSTOP_INVERTING, PSTR(MSG_##S))
   #if HAS_X_MIN
     ES_REPORT(X_MIN);
   #endif
   #if HAS_X2_MIN
     ES_REPORT(X2_MIN);
   #endif
   #if HAS_X_MAX
     ES_REPORT(X_MAX);
   #endif
@@ -467,34 +467,34 @@ void _O2 Endstops::report_states() {
   #if HAS_Z2_MAX
     ES_REPORT(Z2_MAX);
   #endif
   #if HAS_Z3_MAX
     ES_REPORT(Z3_MAX);
   #endif
   #if HAS_Z4_MAX
     ES_REPORT(Z4_MAX);
   #endif
   #if HAS_CUSTOM_PROBE_PIN
-    print_es_state(READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING, PSTR(MSG_Z_PROBE));
+    print_es_state(READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING, PSTR(STR_Z_PROBE));
   #endif
   #if HAS_FILAMENT_SENSOR
     #if NUM_RUNOUT_SENSORS == 1
-      print_es_state(READ(FIL_RUNOUT_PIN) != FIL_RUNOUT_INVERTING, PSTR(MSG_FILAMENT_RUNOUT_SENSOR));
+      print_es_state(READ(FIL_RUNOUT_PIN) != FIL_RUNOUT_INVERTING, PSTR(STR_FILAMENT_RUNOUT_SENSOR));
     #else
       #define _CASE_RUNOUT(N) case N: pin = FIL_RUNOUT##N##_PIN; break;
       for (uint8_t i = 1; i <= NUM_RUNOUT_SENSORS; i++) {
         pin_t pin;
         switch (i) {
           default: continue;
           REPEAT_S(1, INCREMENT(NUM_RUNOUT_SENSORS), _CASE_RUNOUT)
         }
-        SERIAL_ECHOPGM(MSG_FILAMENT_RUNOUT_SENSOR);
+        SERIAL_ECHOPGM(STR_FILAMENT_RUNOUT_SENSOR);
         if (i > 1) SERIAL_CHAR(' ', '0' + i);
         print_es_state(extDigitalRead(pin) != FIL_RUNOUT_INVERTING);
       }
       #undef _CASE_RUNOUT
     #endif
   #endif
   #if ENABLED(BLTOUCH)
     bltouch._reset_SW_mode();
   #endif
 

commit 5071fe82ab221627ef10cf4125896e3d2585993a
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Feb 25 22:18:14 2020 -0600

    Ensure proper SD print completion (#16967)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 1491d881d5..d291f972d3 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -396,21 +396,21 @@ void Endstops::event_handler() {
       if (TEST(hit_state, Z_MIN_PROBE)) _ENDSTOP_HIT_ECHO(P, 'P');
     #endif
     SERIAL_EOL();
 
     #if HAS_SPI_LCD
       ui.status_printf_P(0, PSTR(S_FMT " %c %c %c %c"), GET_TEXT(MSG_LCD_ENDSTOPS), chrX, chrY, chrZ, chrP);
     #endif
 
     #if BOTH(SD_ABORT_ON_ENDSTOP_HIT, SDSUPPORT)
       if (planner.abort_on_endstop_hit) {
-        card.stopSDPrint();
+        card.endFilePrint();
         quickstop_stepper();
         thermalManager.disable_all_heaters();
         print_job_timer.stop();
       }
     #endif
   }
 }
 
 static void print_es_state(const bool is_hit, PGM_P const label=nullptr) {
   if (label) serialprintPGM(label);

commit 3a3429b1ef2fdaf1e793fff17a89b069e3384fbc
Author: Robert Stein <robert.stein@requisis.com>
Date:   Thu Feb 6 22:28:46 2020 +0100

    Fix probe with multi-endstops (#16793)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index f3f73f3da1..1491d881d5 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -522,25 +522,25 @@ void Endstops::update() {
   #define COPY_LIVE_STATE(SRC_BIT, DST_BIT) SET_BIT_TO(live_state, DST_BIT, TEST(live_state, SRC_BIT))
 
   #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && !(CORE_IS_XY || CORE_IS_XZ)
     // If G38 command is active check Z_MIN_PROBE for ALL movement
     if (G38_move) UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
   #endif
 
   // With Dual X, endstops are only checked in the homing direction for the active extruder
   #if ENABLED(DUAL_X_CARRIAGE)
     #define E0_ACTIVE stepper.movement_extruder() == 0
-    #define X_MIN_TEST ((X_HOME_DIR < 0 && E0_ACTIVE) || (X2_HOME_DIR < 0 && !E0_ACTIVE))
-    #define X_MAX_TEST ((X_HOME_DIR > 0 && E0_ACTIVE) || (X2_HOME_DIR > 0 && !E0_ACTIVE))
+    #define X_MIN_TEST() ((X_HOME_DIR < 0 && E0_ACTIVE) || (X2_HOME_DIR < 0 && !E0_ACTIVE))
+    #define X_MAX_TEST() ((X_HOME_DIR > 0 && E0_ACTIVE) || (X2_HOME_DIR > 0 && !E0_ACTIVE))
   #else
-    #define X_MIN_TEST true
-    #define X_MAX_TEST true
+    #define X_MIN_TEST() true
+    #define X_MAX_TEST() true
   #endif
 
   // Use HEAD for core axes, AXIS for others
   #if CORE_IS_XY || CORE_IS_XZ
     #define X_AXIS_HEAD X_HEAD
   #else
     #define X_AXIS_HEAD X_AXIS
   #endif
   #if CORE_IS_XY || CORE_IS_YZ
     #define Y_AXIS_HEAD Y_HEAD
@@ -683,156 +683,145 @@ void Endstops::update() {
 
   #endif
 
   // Test the current status of an endstop
   #define TEST_ENDSTOP(ENDSTOP) (TEST(state(), ENDSTOP))
 
   // Record endstop was hit
   #define _ENDSTOP_HIT(AXIS, MINMAX) SBI(hit_state, _ENDSTOP(AXIS, MINMAX))
 
   // Call the endstop triggered routine for single endstops
-  #define PROCESS_ENDSTOP(AXIS,MINMAX) do { \
+  #define PROCESS_ENDSTOP(AXIS, MINMAX) do { \
     if (TEST_ENDSTOP(_ENDSTOP(AXIS, MINMAX))) { \
       _ENDSTOP_HIT(AXIS, MINMAX); \
       planner.endstop_triggered(_AXIS(AXIS)); \
     } \
   }while(0)
 
   // Call the endstop triggered routine for dual endstops
-  #define PROCESS_DUAL_ENDSTOP(AXIS1, AXIS2, MINMAX) do { \
-    const byte dual_hit = TEST_ENDSTOP(_ENDSTOP(AXIS1, MINMAX)) | (TEST_ENDSTOP(_ENDSTOP(AXIS2, MINMAX)) << 1); \
+  #define PROCESS_DUAL_ENDSTOP(A, MINMAX) do { \
+    const byte dual_hit = TEST_ENDSTOP(_ENDSTOP(A, MINMAX)) | (TEST_ENDSTOP(_ENDSTOP(A##2, MINMAX)) << 1); \
     if (dual_hit) { \
-      _ENDSTOP_HIT(AXIS1, MINMAX); \
+      _ENDSTOP_HIT(A, MINMAX); \
       /* if not performing home or if both endstops were trigged during homing... */ \
       if (!stepper.separate_multi_axis || dual_hit == 0b11) \
-        planner.endstop_triggered(_AXIS(AXIS1)); \
+        planner.endstop_triggered(_AXIS(A)); \
     } \
   }while(0)
 
-  #define PROCESS_TRIPLE_ENDSTOP(AXIS1, AXIS2, AXIS3, MINMAX) do { \
-    const byte triple_hit = TEST_ENDSTOP(_ENDSTOP(AXIS1, MINMAX)) | (TEST_ENDSTOP(_ENDSTOP(AXIS2, MINMAX)) << 1) | (TEST_ENDSTOP(_ENDSTOP(AXIS3, MINMAX)) << 2); \
+  #define PROCESS_TRIPLE_ENDSTOP(A, MINMAX) do { \
+    const byte triple_hit = TEST_ENDSTOP(_ENDSTOP(A, MINMAX)) | (TEST_ENDSTOP(_ENDSTOP(A##2, MINMAX)) << 1) | (TEST_ENDSTOP(_ENDSTOP(A##3, MINMAX)) << 2); \
     if (triple_hit) { \
-      _ENDSTOP_HIT(AXIS1, MINMAX); \
+      _ENDSTOP_HIT(A, MINMAX); \
       /* if not performing home or if both endstops were trigged during homing... */ \
       if (!stepper.separate_multi_axis || triple_hit == 0b111) \
-        planner.endstop_triggered(_AXIS(AXIS1)); \
+        planner.endstop_triggered(_AXIS(A)); \
     } \
   }while(0)
 
-  #define PROCESS_QUAD_ENDSTOP(AXIS1, AXIS2, AXIS3, AXIS4, MINMAX) do { \
-    const byte quad_hit = TEST_ENDSTOP(_ENDSTOP(AXIS1, MINMAX)) | (TEST_ENDSTOP(_ENDSTOP(AXIS2, MINMAX)) << 1) | (TEST_ENDSTOP(_ENDSTOP(AXIS3, MINMAX)) << 2) | (TEST_ENDSTOP(_ENDSTOP(AXIS4, MINMAX)) << 3); \
+  #define PROCESS_QUAD_ENDSTOP(A, MINMAX) do { \
+    const byte quad_hit = TEST_ENDSTOP(_ENDSTOP(A, MINMAX)) | (TEST_ENDSTOP(_ENDSTOP(A##2, MINMAX)) << 1) | (TEST_ENDSTOP(_ENDSTOP(A##3, MINMAX)) << 2) | (TEST_ENDSTOP(_ENDSTOP(A##4, MINMAX)) << 3); \
     if (quad_hit) { \
-      _ENDSTOP_HIT(AXIS1, MINMAX); \
+      _ENDSTOP_HIT(A, MINMAX); \
       /* if not performing home or if both endstops were trigged during homing... */ \
       if (!stepper.separate_multi_axis || quad_hit == 0b1111) \
-        planner.endstop_triggered(_AXIS(AXIS1)); \
+        planner.endstop_triggered(_AXIS(A)); \
     } \
   }while(0)
 
+  #if ENABLED(X_DUAL_ENDSTOPS)
+    #define PROCESS_ENDSTOP_X(MINMAX) PROCESS_DUAL_ENDSTOP(X, MINMAX)
+  #else
+    #define PROCESS_ENDSTOP_X(MINMAX) if (X_##MINMAX##_TEST()) PROCESS_ENDSTOP(X, MINMAX)
+  #endif
+
+  #if ENABLED(Y_DUAL_ENDSTOPS)
+    #define PROCESS_ENDSTOP_Y(MINMAX) PROCESS_DUAL_ENDSTOP(Y, MINMAX)
+  #else
+    #define PROCESS_ENDSTOP_Y(MINMAX) PROCESS_ENDSTOP(Y, MINMAX)
+  #endif
+
+  #if DISABLED(Z_MULTI_ENDSTOPS)
+    #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_ENDSTOP(Z, MINMAX)
+  #elif NUM_Z_STEPPER_DRIVERS == 4
+    #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_QUAD_ENDSTOP(Z, MINMAX)
+  #elif NUM_Z_STEPPER_DRIVERS == 3
+    #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_TRIPLE_ENDSTOP(Z, MINMAX)
+  #else
+    #define PROCESS_ENDSTOP_Z(MINMAX) PROCESS_DUAL_ENDSTOP(Z, MINMAX)
+  #endif
+
   #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && !(CORE_IS_XY || CORE_IS_XZ)
     #if ENABLED(G38_PROBE_AWAY)
       #define _G38_OPEN_STATE (G38_move >= 4)
     #else
       #define _G38_OPEN_STATE LOW
     #endif
     // If G38 command is active check Z_MIN_PROBE for ALL movement
     if (G38_move && TEST_ENDSTOP(_ENDSTOP(Z, MIN_PROBE)) != _G38_OPEN_STATE) {
            if (stepper.axis_is_moving(X_AXIS)) { _ENDSTOP_HIT(X, MIN); planner.endstop_triggered(X_AXIS); }
       else if (stepper.axis_is_moving(Y_AXIS)) { _ENDSTOP_HIT(Y, MIN); planner.endstop_triggered(Y_AXIS); }
       else if (stepper.axis_is_moving(Z_AXIS)) { _ENDSTOP_HIT(Z, MIN); planner.endstop_triggered(Z_AXIS); }
       G38_did_trigger = true;
     }
   #endif
 
   // Now, we must signal, after validation, if an endstop limit is pressed or not
   if (stepper.axis_is_moving(X_AXIS)) {
     if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
       #if HAS_X_MIN || (X_SPI_SENSORLESS && X_HOME_DIR < 0)
-        #if ENABLED(X_DUAL_ENDSTOPS)
-          PROCESS_DUAL_ENDSTOP(X, X2, MIN);
-        #else
-          if (X_MIN_TEST) PROCESS_ENDSTOP(X, MIN);
-        #endif
+        PROCESS_ENDSTOP_X(MIN);
       #endif
     }
     else { // +direction
       #if HAS_X_MAX || (X_SPI_SENSORLESS && X_HOME_DIR > 0)
-        #if ENABLED(X_DUAL_ENDSTOPS)
-          PROCESS_DUAL_ENDSTOP(X, X2, MAX);
-        #else
-          if (X_MAX_TEST) PROCESS_ENDSTOP(X, MAX);
-        #endif
+        PROCESS_ENDSTOP_X(MAX);
       #endif
     }
   }
 
   if (stepper.axis_is_moving(Y_AXIS)) {
     if (stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
       #if HAS_Y_MIN || (Y_SPI_SENSORLESS && Y_HOME_DIR < 0)
-        #if ENABLED(Y_DUAL_ENDSTOPS)
-          PROCESS_DUAL_ENDSTOP(Y, Y2, MIN);
-        #else
-          PROCESS_ENDSTOP(Y, MIN);
-        #endif
+        PROCESS_ENDSTOP_Y(MIN);
       #endif
     }
     else { // +direction
       #if HAS_Y_MAX || (Y_SPI_SENSORLESS && Y_HOME_DIR > 0)
-        #if ENABLED(Y_DUAL_ENDSTOPS)
-          PROCESS_DUAL_ENDSTOP(Y, Y2, MAX);
-        #else
-          PROCESS_ENDSTOP(Y, MAX);
-        #endif
+        PROCESS_ENDSTOP_Y(MAX);
       #endif
     }
   }
 
   if (stepper.axis_is_moving(Z_AXIS)) {
     if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
+
       #if HAS_Z_MIN || (Z_SPI_SENSORLESS && Z_HOME_DIR < 0)
-        #if ENABLED(Z_MULTI_ENDSTOPS)
-          #if NUM_Z_STEPPER_DRIVERS == 4
-            PROCESS_QUAD_ENDSTOP(Z, Z2, Z3, Z4, MIN);
-          #elif NUM_Z_STEPPER_DRIVERS == 3
-            PROCESS_TRIPLE_ENDSTOP(Z, Z2, Z3, MIN);
-          #else
-            PROCESS_DUAL_ENDSTOP(Z, Z2, MIN);
-          #endif
-        #else
+        if (true
           #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
-            if (z_probe_enabled) PROCESS_ENDSTOP(Z, MIN);
+            && z_probe_enabled
           #elif HAS_CUSTOM_PROBE_PIN
-            if (!z_probe_enabled) PROCESS_ENDSTOP(Z, MIN);
-          #else
-            PROCESS_ENDSTOP(Z, MIN);
+            && !z_probe_enabled
           #endif
-        #endif
+        ) PROCESS_ENDSTOP_Z(MIN);
       #endif
 
       // When closing the gap check the enabled probe
       #if HAS_CUSTOM_PROBE_PIN
         if (z_probe_enabled) PROCESS_ENDSTOP(Z, MIN_PROBE);
       #endif
     }
     else { // Z +direction. Gantry up, bed down.
       #if HAS_Z_MAX || (Z_SPI_SENSORLESS && Z_HOME_DIR > 0)
         #if ENABLED(Z_MULTI_ENDSTOPS)
-          #if NUM_Z_STEPPER_DRIVERS == 4
-            PROCESS_QUAD_ENDSTOP(Z, Z2, Z3, Z4, MAX);
-          #elif NUM_Z_STEPPER_DRIVERS == 3
-            PROCESS_TRIPLE_ENDSTOP(Z, Z2, Z3, MAX);
-          #else
-            PROCESS_DUAL_ENDSTOP(Z, Z2, MAX);
-          #endif
-        #elif !HAS_CUSTOM_PROBE_PIN || Z_MAX_PIN != Z_MIN_PROBE_PIN
-          // If this pin is not hijacked for the bed probe
-          // then it belongs to the Z endstop
+          PROCESS_ENDSTOP_Z(MAX);
+        #elif !HAS_CUSTOM_PROBE_PIN || Z_MAX_PIN != Z_MIN_PROBE_PIN  // No probe or probe is Z_MIN || Probe is not Z_MAX
           PROCESS_ENDSTOP(Z, MAX);
         #endif
       #endif
     }
   }
 } // Endstops::update()
 
 #if ENABLED(SPI_ENDSTOPS)
 
   #define X_STOP (X_HOME_DIR < 0 ? X_MIN : X_MAX)

commit 7bf2190f03228666fdec3e1f8f0d8548a1ab2e95
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 4 08:32:43 2020 -0600

    Fix CALIBRATION_GCODE pin handling

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 47ccc5d567..f3f73f3da1 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -249,21 +249,21 @@ void Endstops::init() {
   #if HAS_Z4_MAX
     #if ENABLED(ENDSTOPPULLUP_ZMAX)
       SET_INPUT_PULLUP(Z4_MAX_PIN);
     #elif ENABLED(ENDSTOPPULLDOWN_ZMAX)
       SET_INPUT_PULLDOWN(Z4_MAX_PIN);
     #else
       SET_INPUT(Z4_MAX_PIN);
     #endif
   #endif
 
-  #if HAS_CALIBRATION_PIN
+  #if PIN_EXISTS(CALIBRATION)
     #if ENABLED(CALIBRATION_PIN_PULLUP)
       SET_INPUT_PULLUP(CALIBRATION_PIN);
     #elif ENABLED(CALIBRATION_PIN_PULLDOWN)
       SET_INPUT_PULLDOWN(CALIBRATION_PIN);
     #else
       SET_INPUT(CALIBRATION_PIN);
     #endif
   #endif
 
   #if HAS_CUSTOM_PROBE_PIN

commit bfad23d3e2e590b257ebe4317d7b14cc2dd3435c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 3 08:00:57 2020 -0600

    (c) 2020

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 8eaab9bd55..47ccc5d567 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit 4716dac8742e536dde12773b579407fb1ae1cb66
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Feb 1 21:00:53 2020 -0600

    Apply REPEAT, RREPEAT, and loop macros (#16757)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 7d8e270fed..8eaab9bd55 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -473,49 +473,32 @@ void _O2 Endstops::report_states() {
   #if HAS_Z4_MAX
     ES_REPORT(Z4_MAX);
   #endif
   #if HAS_CUSTOM_PROBE_PIN
     print_es_state(READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING, PSTR(MSG_Z_PROBE));
   #endif
   #if HAS_FILAMENT_SENSOR
     #if NUM_RUNOUT_SENSORS == 1
       print_es_state(READ(FIL_RUNOUT_PIN) != FIL_RUNOUT_INVERTING, PSTR(MSG_FILAMENT_RUNOUT_SENSOR));
     #else
+      #define _CASE_RUNOUT(N) case N: pin = FIL_RUNOUT##N##_PIN; break;
       for (uint8_t i = 1; i <= NUM_RUNOUT_SENSORS; i++) {
         pin_t pin;
         switch (i) {
           default: continue;
-          case 1: pin = FIL_RUNOUT_PIN; break;
-          case 2: pin = FIL_RUNOUT2_PIN; break;
-          #if NUM_RUNOUT_SENSORS >= 3
-            case 3: pin = FIL_RUNOUT3_PIN; break;
-            #if NUM_RUNOUT_SENSORS >= 4
-              case 4: pin = FIL_RUNOUT4_PIN; break;
-              #if NUM_RUNOUT_SENSORS >= 5
-                case 5: pin = FIL_RUNOUT5_PIN; break;
-                #if NUM_RUNOUT_SENSORS >= 6
-                  case 6: pin = FIL_RUNOUT6_PIN; break;
-                  #if NUM_RUNOUT_SENSORS >= 7
-                    case 7: pin = FIL_RUNOUT7_PIN; break;
-                    #if NUM_RUNOUT_SENSORS >= 8
-                      case 8: pin = FIL_RUNOUT8_PIN; break;
-                    #endif
-                  #endif
-                #endif
-              #endif
-            #endif
-          #endif
+          REPEAT_S(1, INCREMENT(NUM_RUNOUT_SENSORS), _CASE_RUNOUT)
         }
         SERIAL_ECHOPGM(MSG_FILAMENT_RUNOUT_SENSOR);
         if (i > 1) SERIAL_CHAR(' ', '0' + i);
         print_es_state(extDigitalRead(pin) != FIL_RUNOUT_INVERTING);
       }
+      #undef _CASE_RUNOUT
     #endif
   #endif
   #if ENABLED(BLTOUCH)
     bltouch._reset_SW_mode();
   #endif
 
   #if ENABLED(JOYSTICK_DEBUG)
     joystick.report();
   #endif
 

commit 248b7dfa591a34a8aa1c6960944e1a3a468ad1de
Author: yangwenxiong <46896566+yangwenxiong@users.noreply.github.com>
Date:   Sat Jan 25 16:13:39 2020 +0800

    BigTreeTech GTR V1.0 / Support 8 extruders, heaters, temp sensors, fans (#16595)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 27d5fb6fc7..7d8e270fed 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -479,28 +479,34 @@ void _O2 Endstops::report_states() {
   #if HAS_FILAMENT_SENSOR
     #if NUM_RUNOUT_SENSORS == 1
       print_es_state(READ(FIL_RUNOUT_PIN) != FIL_RUNOUT_INVERTING, PSTR(MSG_FILAMENT_RUNOUT_SENSOR));
     #else
       for (uint8_t i = 1; i <= NUM_RUNOUT_SENSORS; i++) {
         pin_t pin;
         switch (i) {
           default: continue;
           case 1: pin = FIL_RUNOUT_PIN; break;
           case 2: pin = FIL_RUNOUT2_PIN; break;
-          #if NUM_RUNOUT_SENSORS > 2
+          #if NUM_RUNOUT_SENSORS >= 3
             case 3: pin = FIL_RUNOUT3_PIN; break;
-            #if NUM_RUNOUT_SENSORS > 3
+            #if NUM_RUNOUT_SENSORS >= 4
               case 4: pin = FIL_RUNOUT4_PIN; break;
-              #if NUM_RUNOUT_SENSORS > 4
+              #if NUM_RUNOUT_SENSORS >= 5
                 case 5: pin = FIL_RUNOUT5_PIN; break;
-                #if NUM_RUNOUT_SENSORS > 5
+                #if NUM_RUNOUT_SENSORS >= 6
                   case 6: pin = FIL_RUNOUT6_PIN; break;
+                  #if NUM_RUNOUT_SENSORS >= 7
+                    case 7: pin = FIL_RUNOUT7_PIN; break;
+                    #if NUM_RUNOUT_SENSORS >= 8
+                      case 8: pin = FIL_RUNOUT8_PIN; break;
+                    #endif
+                  #endif
                 #endif
               #endif
             #endif
           #endif
         }
         SERIAL_ECHOPGM(MSG_FILAMENT_RUNOUT_SENSOR);
         if (i > 1) SERIAL_CHAR(' ', '0' + i);
         print_es_state(extDigitalRead(pin) != FIL_RUNOUT_INVERTING);
       }
     #endif

commit 0fcf2b1110d9f0d362e5aab9cc73d963710e9865
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Mon Jan 20 00:35:07 2020 -0500

    Quad Z stepper support (#16277)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index a9b5cca227..27d5fb6fc7 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -66,25 +66,28 @@ Endstops::esbits_t Endstops::live_state = 0;
   volatile bool Endstops::z_probe_enabled = false;
 #endif
 
 // Initialized by settings.load()
 #if ENABLED(X_DUAL_ENDSTOPS)
   float Endstops::x2_endstop_adj;
 #endif
 #if ENABLED(Y_DUAL_ENDSTOPS)
   float Endstops::y2_endstop_adj;
 #endif
-#if Z_MULTI_ENDSTOPS
+#if ENABLED(Z_MULTI_ENDSTOPS)
   float Endstops::z2_endstop_adj;
-#endif
-#if ENABLED(Z_TRIPLE_ENDSTOPS)
-  float Endstops::z3_endstop_adj;
+  #if NUM_Z_STEPPER_DRIVERS >= 3
+    float Endstops::z3_endstop_adj;
+    #if NUM_Z_STEPPER_DRIVERS >= 4
+      float Endstops::z4_endstop_adj;
+    #endif
+  #endif
 #endif
 
 #if ENABLED(SPI_ENDSTOPS)
   Endstops::tmc_spi_homing_t Endstops::tmc_spi_homing; // = 0
 #endif
 #if ENABLED(IMPROVE_HOMING_RELIABILITY)
   millis_t sg_guard_period; // = 0
 #endif
 
 /**
@@ -156,20 +159,30 @@ void Endstops::init() {
   #if HAS_Z3_MIN
     #if ENABLED(ENDSTOPPULLUP_ZMIN)
       SET_INPUT_PULLUP(Z3_MIN_PIN);
     #elif ENABLED(ENDSTOPPULLDOWN_ZMIN)
       SET_INPUT_PULLDOWN(Z3_MIN_PIN);
     #else
       SET_INPUT(Z3_MIN_PIN);
     #endif
   #endif
 
+  #if HAS_Z4_MIN
+    #if ENABLED(ENDSTOPPULLUP_ZMIN)
+      SET_INPUT_PULLUP(Z4_MIN_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_ZMIN)
+      SET_INPUT_PULLDOWN(Z4_MIN_PIN);
+    #else
+      SET_INPUT(Z4_MIN_PIN);
+    #endif
+  #endif
+
   #if HAS_X_MAX
     #if ENABLED(ENDSTOPPULLUP_XMAX)
       SET_INPUT_PULLUP(X_MAX_PIN);
     #elif ENABLED(ENDSTOPPULLDOWN_XMAX)
       SET_INPUT_PULLDOWN(X_MAX_PIN);
     #else
       SET_INPUT(X_MAX_PIN);
     #endif
   #endif
 
@@ -226,20 +239,30 @@ void Endstops::init() {
   #if HAS_Z3_MAX
     #if ENABLED(ENDSTOPPULLUP_ZMAX)
       SET_INPUT_PULLUP(Z3_MAX_PIN);
     #elif ENABLED(ENDSTOPPULLDOWN_ZMAX)
       SET_INPUT_PULLDOWN(Z3_MAX_PIN);
     #else
       SET_INPUT(Z3_MAX_PIN);
     #endif
   #endif
 
+  #if HAS_Z4_MAX
+    #if ENABLED(ENDSTOPPULLUP_ZMAX)
+      SET_INPUT_PULLUP(Z4_MAX_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_ZMAX)
+      SET_INPUT_PULLDOWN(Z4_MAX_PIN);
+    #else
+      SET_INPUT(Z4_MAX_PIN);
+    #endif
+  #endif
+
   #if HAS_CALIBRATION_PIN
     #if ENABLED(CALIBRATION_PIN_PULLUP)
       SET_INPUT_PULLUP(CALIBRATION_PIN);
     #elif ENABLED(CALIBRATION_PIN_PULLDOWN)
       SET_INPUT_PULLDOWN(CALIBRATION_PIN);
     #else
       SET_INPUT(CALIBRATION_PIN);
     #endif
   #endif
 
@@ -428,29 +451,35 @@ void _O2 Endstops::report_states() {
   #endif
   #if HAS_Z_MIN
     ES_REPORT(Z_MIN);
   #endif
   #if HAS_Z2_MIN
     ES_REPORT(Z2_MIN);
   #endif
   #if HAS_Z3_MIN
     ES_REPORT(Z3_MIN);
   #endif
+  #if HAS_Z4_MIN
+    ES_REPORT(Z4_MIN);
+  #endif
   #if HAS_Z_MAX
     ES_REPORT(Z_MAX);
   #endif
   #if HAS_Z2_MAX
     ES_REPORT(Z2_MAX);
   #endif
   #if HAS_Z3_MAX
     ES_REPORT(Z3_MAX);
   #endif
+  #if HAS_Z4_MAX
+    ES_REPORT(Z4_MAX);
+  #endif
   #if HAS_CUSTOM_PROBE_PIN
     print_es_state(READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING, PSTR(MSG_Z_PROBE));
   #endif
   #if HAS_FILAMENT_SENSOR
     #if NUM_RUNOUT_SENSORS == 1
       print_es_state(READ(FIL_RUNOUT_PIN) != FIL_RUNOUT_INVERTING, PSTR(MSG_FILAMENT_RUNOUT_SENSOR));
     #else
       for (uint8_t i = 1; i <= NUM_RUNOUT_SENSORS; i++) {
         pin_t pin;
         switch (i) {
@@ -577,57 +606,71 @@ void Endstops::update() {
       #if HAS_Y2_MAX
         UPDATE_ENDSTOP_BIT(Y2, MAX);
       #else
         COPY_LIVE_STATE(Y_MAX, Y2_MAX);
       #endif
     #endif
   #endif
 
   #if HAS_Z_MIN && !Z_SPI_SENSORLESS
     UPDATE_ENDSTOP_BIT(Z, MIN);
-    #if Z_MULTI_ENDSTOPS
+    #if ENABLED(Z_MULTI_ENDSTOPS)
       #if HAS_Z2_MIN
         UPDATE_ENDSTOP_BIT(Z2, MIN);
       #else
         COPY_LIVE_STATE(Z_MIN, Z2_MIN);
       #endif
-      #if ENABLED(Z_TRIPLE_ENDSTOPS)
+      #if NUM_Z_STEPPER_DRIVERS >= 3
         #if HAS_Z3_MIN
           UPDATE_ENDSTOP_BIT(Z3, MIN);
         #else
           COPY_LIVE_STATE(Z_MIN, Z3_MIN);
         #endif
       #endif
+      #if NUM_Z_STEPPER_DRIVERS >= 4
+        #if HAS_Z4_MIN
+          UPDATE_ENDSTOP_BIT(Z4, MIN);
+        #else
+          COPY_LIVE_STATE(Z_MIN, Z4_MIN);
+        #endif
+      #endif
     #endif
   #endif
 
   // When closing the gap check the enabled probe
   #if HAS_CUSTOM_PROBE_PIN
     UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
   #endif
 
   #if HAS_Z_MAX && !Z_SPI_SENSORLESS
     // Check both Z dual endstops
-    #if Z_MULTI_ENDSTOPS
+    #if ENABLED(Z_MULTI_ENDSTOPS)
       UPDATE_ENDSTOP_BIT(Z, MAX);
       #if HAS_Z2_MAX
         UPDATE_ENDSTOP_BIT(Z2, MAX);
       #else
         COPY_LIVE_STATE(Z_MAX, Z2_MAX);
       #endif
-      #if ENABLED(Z_TRIPLE_ENDSTOPS)
+      #if NUM_Z_STEPPER_DRIVERS >= 3
         #if HAS_Z3_MAX
           UPDATE_ENDSTOP_BIT(Z3, MAX);
         #else
           COPY_LIVE_STATE(Z_MAX, Z3_MAX);
         #endif
       #endif
+      #if NUM_Z_STEPPER_DRIVERS >= 4
+        #if HAS_Z4_MAX
+          UPDATE_ENDSTOP_BIT(Z4, MAX);
+        #else
+          COPY_LIVE_STATE(Z_MAX, Z4_MAX);
+        #endif
+      #endif
     #elif !HAS_CUSTOM_PROBE_PIN || Z_MAX_PIN != Z_MIN_PROBE_PIN
       // If this pin isn't the bed probe it's the Z endstop
       UPDATE_ENDSTOP_BIT(Z, MAX);
     #endif
   #endif
 
   #if ENDSTOP_NOISE_THRESHOLD
 
     /**
      * Filtering out noise on endstops requires a delayed decision. Let's assume, due to noise,
@@ -679,20 +722,30 @@ void Endstops::update() {
   #define PROCESS_TRIPLE_ENDSTOP(AXIS1, AXIS2, AXIS3, MINMAX) do { \
     const byte triple_hit = TEST_ENDSTOP(_ENDSTOP(AXIS1, MINMAX)) | (TEST_ENDSTOP(_ENDSTOP(AXIS2, MINMAX)) << 1) | (TEST_ENDSTOP(_ENDSTOP(AXIS3, MINMAX)) << 2); \
     if (triple_hit) { \
       _ENDSTOP_HIT(AXIS1, MINMAX); \
       /* if not performing home or if both endstops were trigged during homing... */ \
       if (!stepper.separate_multi_axis || triple_hit == 0b111) \
         planner.endstop_triggered(_AXIS(AXIS1)); \
     } \
   }while(0)
 
+  #define PROCESS_QUAD_ENDSTOP(AXIS1, AXIS2, AXIS3, AXIS4, MINMAX) do { \
+    const byte quad_hit = TEST_ENDSTOP(_ENDSTOP(AXIS1, MINMAX)) | (TEST_ENDSTOP(_ENDSTOP(AXIS2, MINMAX)) << 1) | (TEST_ENDSTOP(_ENDSTOP(AXIS3, MINMAX)) << 2) | (TEST_ENDSTOP(_ENDSTOP(AXIS4, MINMAX)) << 3); \
+    if (quad_hit) { \
+      _ENDSTOP_HIT(AXIS1, MINMAX); \
+      /* if not performing home or if both endstops were trigged during homing... */ \
+      if (!stepper.separate_multi_axis || quad_hit == 0b1111) \
+        planner.endstop_triggered(_AXIS(AXIS1)); \
+    } \
+  }while(0)
+
   #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && !(CORE_IS_XY || CORE_IS_XZ)
     #if ENABLED(G38_PROBE_AWAY)
       #define _G38_OPEN_STATE (G38_move >= 4)
     #else
       #define _G38_OPEN_STATE LOW
     #endif
     // If G38 command is active check Z_MIN_PROBE for ALL movement
     if (G38_move && TEST_ENDSTOP(_ENDSTOP(Z, MIN_PROBE)) != _G38_OPEN_STATE) {
            if (stepper.axis_is_moving(X_AXIS)) { _ENDSTOP_HIT(X, MIN); planner.endstop_triggered(X_AXIS); }
       else if (stepper.axis_is_moving(Y_AXIS)) { _ENDSTOP_HIT(Y, MIN); planner.endstop_triggered(Y_AXIS); }
@@ -740,46 +793,54 @@ void Endstops::update() {
         #else
           PROCESS_ENDSTOP(Y, MAX);
         #endif
       #endif
     }
   }
 
   if (stepper.axis_is_moving(Z_AXIS)) {
     if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
       #if HAS_Z_MIN || (Z_SPI_SENSORLESS && Z_HOME_DIR < 0)
-        #if ENABLED(Z_TRIPLE_ENDSTOPS)
-          PROCESS_TRIPLE_ENDSTOP(Z, Z2, Z3, MIN);
-        #elif ENABLED(Z_DUAL_ENDSTOPS)
-          PROCESS_DUAL_ENDSTOP(Z, Z2, MIN);
+        #if ENABLED(Z_MULTI_ENDSTOPS)
+          #if NUM_Z_STEPPER_DRIVERS == 4
+            PROCESS_QUAD_ENDSTOP(Z, Z2, Z3, Z4, MIN);
+          #elif NUM_Z_STEPPER_DRIVERS == 3
+            PROCESS_TRIPLE_ENDSTOP(Z, Z2, Z3, MIN);
+          #else
+            PROCESS_DUAL_ENDSTOP(Z, Z2, MIN);
+          #endif
         #else
           #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
             if (z_probe_enabled) PROCESS_ENDSTOP(Z, MIN);
           #elif HAS_CUSTOM_PROBE_PIN
             if (!z_probe_enabled) PROCESS_ENDSTOP(Z, MIN);
           #else
             PROCESS_ENDSTOP(Z, MIN);
           #endif
         #endif
       #endif
 
       // When closing the gap check the enabled probe
       #if HAS_CUSTOM_PROBE_PIN
         if (z_probe_enabled) PROCESS_ENDSTOP(Z, MIN_PROBE);
       #endif
     }
     else { // Z +direction. Gantry up, bed down.
       #if HAS_Z_MAX || (Z_SPI_SENSORLESS && Z_HOME_DIR > 0)
-        #if ENABLED(Z_TRIPLE_ENDSTOPS)
-          PROCESS_TRIPLE_ENDSTOP(Z, Z2, Z3, MAX);
-        #elif ENABLED(Z_DUAL_ENDSTOPS)
-          PROCESS_DUAL_ENDSTOP(Z, Z2, MAX);
+        #if ENABLED(Z_MULTI_ENDSTOPS)
+          #if NUM_Z_STEPPER_DRIVERS == 4
+            PROCESS_QUAD_ENDSTOP(Z, Z2, Z3, Z4, MAX);
+          #elif NUM_Z_STEPPER_DRIVERS == 3
+            PROCESS_TRIPLE_ENDSTOP(Z, Z2, Z3, MAX);
+          #else
+            PROCESS_DUAL_ENDSTOP(Z, Z2, MAX);
+          #endif
         #elif !HAS_CUSTOM_PROBE_PIN || Z_MAX_PIN != Z_MIN_PROBE_PIN
           // If this pin is not hijacked for the bed probe
           // then it belongs to the Z endstop
           PROCESS_ENDSTOP(Z, MAX);
         #endif
       #endif
     }
   }
 } // Endstops::update()
 
@@ -885,20 +946,26 @@ void Endstops::update() {
     #endif
     #if HAS_Z2_MAX
       ES_GET_STATE(Z2_MAX);
     #endif
     #if HAS_Z3_MIN
       ES_GET_STATE(Z3_MIN);
     #endif
     #if HAS_Z3_MAX
       ES_GET_STATE(Z3_MAX);
     #endif
+    #if HAS_Z4_MIN
+      ES_GET_STATE(Z4_MIN);
+    #endif
+    #if HAS_Z4_MAX
+      ES_GET_STATE(Z4_MAX);
+    #endif
 
     uint16_t endstop_change = live_state_local ^ old_live_state_local;
     #define ES_REPORT_CHANGE(S) if (TEST(endstop_change, S)) SERIAL_ECHOPAIR("  " STRINGIFY(S) ":", TEST(live_state_local, S))
 
     if (endstop_change) {
       #if HAS_X_MIN
         ES_REPORT_CHANGE(X_MIN);
       #endif
       #if HAS_X_MAX
         ES_REPORT_CHANGE(X_MAX);
@@ -935,18 +1002,24 @@ void Endstops::update() {
       #endif
       #if HAS_Z2_MAX
         ES_REPORT_CHANGE(Z2_MAX);
       #endif
       #if HAS_Z3_MIN
         ES_REPORT_CHANGE(Z3_MIN);
       #endif
       #if HAS_Z3_MAX
         ES_REPORT_CHANGE(Z3_MAX);
       #endif
+      #if HAS_Z4_MIN
+        ES_REPORT_CHANGE(Z4_MIN);
+      #endif
+      #if HAS_Z4_MAX
+        ES_REPORT_CHANGE(Z4_MAX);
+      #endif
       SERIAL_ECHOLNPGM("\n");
       analogWrite(pin_t(LED_PIN), local_LED_status);
       local_LED_status ^= 255;
       old_live_state_local = live_state_local;
     }
   }
 
 #endif // PINS_DEBUGGING

commit 95046c90478c14d2c43bd41d30c4170dcbcdf53a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jan 8 18:31:57 2020 -0600

    Extend SERIAL_CHAR to take multiple arguments

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index f35493e86d..a9b5cca227 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -464,21 +464,21 @@ void _O2 Endstops::report_states() {
               #if NUM_RUNOUT_SENSORS > 4
                 case 5: pin = FIL_RUNOUT5_PIN; break;
                 #if NUM_RUNOUT_SENSORS > 5
                   case 6: pin = FIL_RUNOUT6_PIN; break;
                 #endif
               #endif
             #endif
           #endif
         }
         SERIAL_ECHOPGM(MSG_FILAMENT_RUNOUT_SENSOR);
-        if (i > 1) { SERIAL_CHAR(' '); SERIAL_CHAR('0' + i); }
+        if (i > 1) SERIAL_CHAR(' ', '0' + i);
         print_es_state(extDigitalRead(pin) != FIL_RUNOUT_INVERTING);
       }
     #endif
   #endif
   #if ENABLED(BLTOUCH)
     bltouch._reset_SW_mode();
   #endif
 
   #if ENABLED(JOYSTICK_DEBUG)
     joystick.report();

commit d0e1166cce60381fbdad1105d13765806a525d99
Author: Dirk O. Kaar <19971886+dok-net@users.noreply.github.com>
Date:   Fri Jan 3 02:01:38 2020 +0100

    Fix Visual Micro "Arduino IDE for Visual Studio" support (#16418)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index cbe274a692..f35493e86d 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -20,21 +20,21 @@
  *
  */
 
 /**
  * endstops.cpp - A singleton object to manage endstops
  */
 
 #include "endstops.h"
 #include "stepper.h"
 
-#include "../Marlin.h"
+#include "../MarlinCore.h"
 #include "../sd/cardreader.h"
 #include "temperature.h"
 #include "../lcd/ultralcd.h"
 
 #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
   #include HAL_PATH(../HAL, endstop_interrupts.h)
 #endif
 
 #if BOTH(SD_ABORT_ON_ENDSTOP_HIT, SDSUPPORT)
   #include "printcounter.h" // for print_job_timer

commit c80eda073f572705e7505a072b8229d93e400fe1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Oct 30 15:07:24 2019 -0500

    M119 => report_states

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index a5235ea058..cbe274a692 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -389,21 +389,21 @@ void Endstops::event_handler() {
   }
 }
 
 static void print_es_state(const bool is_hit, PGM_P const label=nullptr) {
   if (label) serialprintPGM(label);
   SERIAL_ECHOPGM(": ");
   serialprintPGM(is_hit ? PSTR(MSG_ENDSTOP_HIT) : PSTR(MSG_ENDSTOP_OPEN));
   SERIAL_EOL();
 }
 
-void _O2 Endstops::M119() {
+void _O2 Endstops::report_states() {
   #if ENABLED(BLTOUCH)
     bltouch._set_SW_mode();
   #endif
   SERIAL_ECHOLNPGM(MSG_M119_REPORT);
   #define ES_REPORT(S) print_es_state(READ(S##_PIN) != S##_ENDSTOP_INVERTING, PSTR(MSG_##S))
   #if HAS_X_MIN
     ES_REPORT(X_MIN);
   #endif
   #if HAS_X2_MIN
     ES_REPORT(X2_MIN);
@@ -477,21 +477,21 @@ void _O2 Endstops::M119() {
     #endif
   #endif
   #if ENABLED(BLTOUCH)
     bltouch._reset_SW_mode();
   #endif
 
   #if ENABLED(JOYSTICK_DEBUG)
     joystick.report();
   #endif
 
-} // Endstops::M119
+} // Endstops::report_states
 
 // The following routines are called from an ISR context. It could be the temperature ISR, the
 // endstop ISR or the Stepper ISR.
 
 #define _ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
 #define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN
 #define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_INVERTING
 
 // Check endstops - Could be called from Temperature ISR!
 void Endstops::update() {

commit c5713b5e981e0dc3646a10082cc061afd8e7406f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Oct 29 15:58:00 2019 -0500

    Clean Endstops::event_handler

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 24c357e2b7..a5235ea058 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -333,21 +333,23 @@ void Endstops::resync() {
     if (!monitor_flag) return;
     static uint8_t monitor_count = 16;  // offset this check from the others
     monitor_count += _BV(1);            //  15 Hz
     monitor_count &= 0x7F;
     if (!monitor_count) monitor();      // report changes in endstop status
   }
 #endif
 
 void Endstops::event_handler() {
   static uint8_t prev_hit_state; // = 0
-  if (hit_state && hit_state != prev_hit_state) {
+  if (hit_state == prev_hit_state) return;
+  prev_hit_state = hit_state;
+  if (hit_state) {
     #if HAS_SPI_LCD
       char chrX = ' ', chrY = ' ', chrZ = ' ', chrP = ' ';
       #define _SET_STOP_CHAR(A,C) (chr## A = C)
     #else
       #define _SET_STOP_CHAR(A,C) ;
     #endif
 
     #define _ENDSTOP_HIT_ECHO(A,C) do{ \
       SERIAL_ECHOPAIR(" " STRINGIFY(A) ":", planner.triggered_position_mm(_AXIS(A))); \
       _SET_STOP_CHAR(A,C); }while(0)
@@ -378,21 +380,20 @@ void Endstops::event_handler() {
 
     #if BOTH(SD_ABORT_ON_ENDSTOP_HIT, SDSUPPORT)
       if (planner.abort_on_endstop_hit) {
         card.stopSDPrint();
         quickstop_stepper();
         thermalManager.disable_all_heaters();
         print_job_timer.stop();
       }
     #endif
   }
-  prev_hit_state = hit_state;
 }
 
 static void print_es_state(const bool is_hit, PGM_P const label=nullptr) {
   if (label) serialprintPGM(label);
   SERIAL_ECHOPGM(": ");
   serialprintPGM(is_hit ? PSTR(MSG_ENDSTOP_HIT) : PSTR(MSG_ENDSTOP_OPEN));
   SERIAL_EOL();
 }
 
 void _O2 Endstops::M119() {

commit fe4c69b64abc74bc1ee1eb16d3d3771e3afbf25d
Author: Piotr <peter_k@tut.by>
Date:   Tue Oct 15 21:28:04 2019 +0300

    Poll *all* enabled endstop pins (#15525)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index e5d07cbc65..24c357e2b7 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -236,21 +236,21 @@ void Endstops::init() {
   #if HAS_CALIBRATION_PIN
     #if ENABLED(CALIBRATION_PIN_PULLUP)
       SET_INPUT_PULLUP(CALIBRATION_PIN);
     #elif ENABLED(CALIBRATION_PIN_PULLDOWN)
       SET_INPUT_PULLDOWN(CALIBRATION_PIN);
     #else
       SET_INPUT(CALIBRATION_PIN);
     #endif
   #endif
 
-  #if USES_Z_MIN_PROBE_ENDSTOP
+  #if HAS_CUSTOM_PROBE_PIN
     #if ENABLED(ENDSTOPPULLUP_ZMIN_PROBE)
       SET_INPUT_PULLUP(Z_MIN_PROBE_PIN);
     #elif ENABLED(ENDSTOPPULLDOWN_ZMIN_PROBE)
       SET_INPUT_PULLDOWN(Z_MIN_PROBE_PIN);
     #else
       SET_INPUT(Z_MIN_PROBE_PIN);
     #endif
   #endif
 
   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
@@ -359,21 +359,21 @@ void Endstops::event_handler() {
     #define ENDSTOP_HIT_TEST_X() _ENDSTOP_HIT_TEST(X,'X')
     #define ENDSTOP_HIT_TEST_Y() _ENDSTOP_HIT_TEST(Y,'Y')
     #define ENDSTOP_HIT_TEST_Z() _ENDSTOP_HIT_TEST(Z,'Z')
 
     SERIAL_ECHO_START();
     SERIAL_ECHOPGM(MSG_ENDSTOPS_HIT);
     ENDSTOP_HIT_TEST_X();
     ENDSTOP_HIT_TEST_Y();
     ENDSTOP_HIT_TEST_Z();
 
-    #if USES_Z_MIN_PROBE_ENDSTOP
+    #if HAS_CUSTOM_PROBE_PIN
       #define P_AXIS Z_AXIS
       if (TEST(hit_state, Z_MIN_PROBE)) _ENDSTOP_HIT_ECHO(P, 'P');
     #endif
     SERIAL_EOL();
 
     #if HAS_SPI_LCD
       ui.status_printf_P(0, PSTR(S_FMT " %c %c %c %c"), GET_TEXT(MSG_LCD_ENDSTOPS), chrX, chrY, chrZ, chrP);
     #endif
 
     #if BOTH(SD_ABORT_ON_ENDSTOP_HIT, SDSUPPORT)
@@ -436,21 +436,21 @@ void _O2 Endstops::M119() {
   #endif
   #if HAS_Z_MAX
     ES_REPORT(Z_MAX);
   #endif
   #if HAS_Z2_MAX
     ES_REPORT(Z2_MAX);
   #endif
   #if HAS_Z3_MAX
     ES_REPORT(Z3_MAX);
   #endif
-  #if USES_Z_MIN_PROBE_ENDSTOP
+  #if HAS_CUSTOM_PROBE_PIN
     print_es_state(READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING, PSTR(MSG_Z_PROBE));
   #endif
   #if HAS_FILAMENT_SENSOR
     #if NUM_RUNOUT_SENSORS == 1
       print_es_state(READ(FIL_RUNOUT_PIN) != FIL_RUNOUT_INVERTING, PSTR(MSG_FILAMENT_RUNOUT_SENSOR));
     #else
       for (uint8_t i = 1; i <= NUM_RUNOUT_SENSORS; i++) {
         pin_t pin;
         switch (i) {
           default: continue;
@@ -531,115 +531,103 @@ void Endstops::update() {
   #if CORE_IS_XZ || CORE_IS_YZ
     #define Z_AXIS_HEAD Z_HEAD
   #else
     #define Z_AXIS_HEAD Z_AXIS
   #endif
 
   /**
    * Check and update endstops
    */
   #if HAS_X_MIN && !X_SPI_SENSORLESS
+    UPDATE_ENDSTOP_BIT(X, MIN);
     #if ENABLED(X_DUAL_ENDSTOPS)
-      UPDATE_ENDSTOP_BIT(X, MIN);
       #if HAS_X2_MIN
         UPDATE_ENDSTOP_BIT(X2, MIN);
       #else
         COPY_LIVE_STATE(X_MIN, X2_MIN);
       #endif
-    #else
-      UPDATE_ENDSTOP_BIT(X, MIN);
     #endif
   #endif
 
   #if HAS_X_MAX && !X_SPI_SENSORLESS
+    UPDATE_ENDSTOP_BIT(X, MAX);
     #if ENABLED(X_DUAL_ENDSTOPS)
-      UPDATE_ENDSTOP_BIT(X, MAX);
       #if HAS_X2_MAX
         UPDATE_ENDSTOP_BIT(X2, MAX);
       #else
         COPY_LIVE_STATE(X_MAX, X2_MAX);
       #endif
-    #else
-      UPDATE_ENDSTOP_BIT(X, MAX);
     #endif
   #endif
 
   #if HAS_Y_MIN && !Y_SPI_SENSORLESS
+    UPDATE_ENDSTOP_BIT(Y, MIN);
     #if ENABLED(Y_DUAL_ENDSTOPS)
-      UPDATE_ENDSTOP_BIT(Y, MIN);
       #if HAS_Y2_MIN
         UPDATE_ENDSTOP_BIT(Y2, MIN);
       #else
         COPY_LIVE_STATE(Y_MIN, Y2_MIN);
       #endif
-    #else
-      UPDATE_ENDSTOP_BIT(Y, MIN);
     #endif
   #endif
 
   #if HAS_Y_MAX && !Y_SPI_SENSORLESS
+    UPDATE_ENDSTOP_BIT(Y, MAX);
     #if ENABLED(Y_DUAL_ENDSTOPS)
-      UPDATE_ENDSTOP_BIT(Y, MAX);
       #if HAS_Y2_MAX
         UPDATE_ENDSTOP_BIT(Y2, MAX);
       #else
         COPY_LIVE_STATE(Y_MAX, Y2_MAX);
       #endif
-    #else
-      UPDATE_ENDSTOP_BIT(Y, MAX);
     #endif
   #endif
 
   #if HAS_Z_MIN && !Z_SPI_SENSORLESS
+    UPDATE_ENDSTOP_BIT(Z, MIN);
     #if Z_MULTI_ENDSTOPS
-      UPDATE_ENDSTOP_BIT(Z, MIN);
       #if HAS_Z2_MIN
         UPDATE_ENDSTOP_BIT(Z2, MIN);
       #else
         COPY_LIVE_STATE(Z_MIN, Z2_MIN);
       #endif
       #if ENABLED(Z_TRIPLE_ENDSTOPS)
         #if HAS_Z3_MIN
           UPDATE_ENDSTOP_BIT(Z3, MIN);
         #else
           COPY_LIVE_STATE(Z_MIN, Z3_MIN);
         #endif
       #endif
-    #elif ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
-      UPDATE_ENDSTOP_BIT(Z, MIN);
-    #elif Z_HOME_DIR < 0
-      UPDATE_ENDSTOP_BIT(Z, MIN);
     #endif
   #endif
 
   // When closing the gap check the enabled probe
-  #if USES_Z_MIN_PROBE_ENDSTOP
+  #if HAS_CUSTOM_PROBE_PIN
     UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
   #endif
 
   #if HAS_Z_MAX && !Z_SPI_SENSORLESS
     // Check both Z dual endstops
     #if Z_MULTI_ENDSTOPS
       UPDATE_ENDSTOP_BIT(Z, MAX);
       #if HAS_Z2_MAX
         UPDATE_ENDSTOP_BIT(Z2, MAX);
       #else
         COPY_LIVE_STATE(Z_MAX, Z2_MAX);
       #endif
       #if ENABLED(Z_TRIPLE_ENDSTOPS)
         #if HAS_Z3_MAX
           UPDATE_ENDSTOP_BIT(Z3, MAX);
         #else
           COPY_LIVE_STATE(Z_MAX, Z3_MAX);
         #endif
       #endif
-    #elif !USES_Z_MIN_PROBE_ENDSTOP || Z_MAX_PIN != Z_MIN_PROBE_PIN
+    #elif !HAS_CUSTOM_PROBE_PIN || Z_MAX_PIN != Z_MIN_PROBE_PIN
       // If this pin isn't the bed probe it's the Z endstop
       UPDATE_ENDSTOP_BIT(Z, MAX);
     #endif
   #endif
 
   #if ENDSTOP_NOISE_THRESHOLD
 
     /**
      * Filtering out noise on endstops requires a delayed decision. Let's assume, due to noise,
      * that 50% of endstop signal samples are good and 50% are bad (assuming normal distribution
@@ -758,40 +746,40 @@ void Endstops::update() {
   if (stepper.axis_is_moving(Z_AXIS)) {
     if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
       #if HAS_Z_MIN || (Z_SPI_SENSORLESS && Z_HOME_DIR < 0)
         #if ENABLED(Z_TRIPLE_ENDSTOPS)
           PROCESS_TRIPLE_ENDSTOP(Z, Z2, Z3, MIN);
         #elif ENABLED(Z_DUAL_ENDSTOPS)
           PROCESS_DUAL_ENDSTOP(Z, Z2, MIN);
         #else
           #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
             if (z_probe_enabled) PROCESS_ENDSTOP(Z, MIN);
-          #elif USES_Z_MIN_PROBE_ENDSTOP
+          #elif HAS_CUSTOM_PROBE_PIN
             if (!z_probe_enabled) PROCESS_ENDSTOP(Z, MIN);
           #else
             PROCESS_ENDSTOP(Z, MIN);
           #endif
         #endif
       #endif
 
       // When closing the gap check the enabled probe
-      #if USES_Z_MIN_PROBE_ENDSTOP
+      #if HAS_CUSTOM_PROBE_PIN
         if (z_probe_enabled) PROCESS_ENDSTOP(Z, MIN_PROBE);
       #endif
     }
     else { // Z +direction. Gantry up, bed down.
       #if HAS_Z_MAX || (Z_SPI_SENSORLESS && Z_HOME_DIR > 0)
         #if ENABLED(Z_TRIPLE_ENDSTOPS)
           PROCESS_TRIPLE_ENDSTOP(Z, Z2, Z3, MAX);
         #elif ENABLED(Z_DUAL_ENDSTOPS)
           PROCESS_DUAL_ENDSTOP(Z, Z2, MAX);
-        #elif !USES_Z_MIN_PROBE_ENDSTOP || Z_MAX_PIN != Z_MIN_PROBE_PIN
+        #elif !HAS_CUSTOM_PROBE_PIN || Z_MAX_PIN != Z_MIN_PROBE_PIN
           // If this pin is not hijacked for the bed probe
           // then it belongs to the Z endstop
           PROCESS_ENDSTOP(Z, MAX);
         #endif
       #endif
     }
   }
 } // Endstops::update()
 
 #if ENABLED(SPI_ENDSTOPS)

commit 437978d349d48a575b923eb4a6e020e5b42dadd5
Author: Markus Towara <towara@stce.rwth-aachen.de>
Date:   Tue Oct 15 18:34:45 2019 +0200

    Bring SPI_SENSORLESS code up to date (#15560)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 0cb7c603d4..e5d07cbc65 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -530,73 +530,73 @@ void Endstops::update() {
   #endif
   #if CORE_IS_XZ || CORE_IS_YZ
     #define Z_AXIS_HEAD Z_HEAD
   #else
     #define Z_AXIS_HEAD Z_AXIS
   #endif
 
   /**
    * Check and update endstops
    */
-  #if HAS_X_MIN
+  #if HAS_X_MIN && !X_SPI_SENSORLESS
     #if ENABLED(X_DUAL_ENDSTOPS)
       UPDATE_ENDSTOP_BIT(X, MIN);
       #if HAS_X2_MIN
         UPDATE_ENDSTOP_BIT(X2, MIN);
       #else
         COPY_LIVE_STATE(X_MIN, X2_MIN);
       #endif
     #else
       UPDATE_ENDSTOP_BIT(X, MIN);
     #endif
   #endif
 
-  #if HAS_X_MAX
+  #if HAS_X_MAX && !X_SPI_SENSORLESS
     #if ENABLED(X_DUAL_ENDSTOPS)
       UPDATE_ENDSTOP_BIT(X, MAX);
       #if HAS_X2_MAX
         UPDATE_ENDSTOP_BIT(X2, MAX);
       #else
         COPY_LIVE_STATE(X_MAX, X2_MAX);
       #endif
     #else
       UPDATE_ENDSTOP_BIT(X, MAX);
     #endif
   #endif
 
-  #if HAS_Y_MIN
+  #if HAS_Y_MIN && !Y_SPI_SENSORLESS
     #if ENABLED(Y_DUAL_ENDSTOPS)
       UPDATE_ENDSTOP_BIT(Y, MIN);
       #if HAS_Y2_MIN
         UPDATE_ENDSTOP_BIT(Y2, MIN);
       #else
         COPY_LIVE_STATE(Y_MIN, Y2_MIN);
       #endif
     #else
       UPDATE_ENDSTOP_BIT(Y, MIN);
     #endif
   #endif
 
-  #if HAS_Y_MAX
+  #if HAS_Y_MAX && !Y_SPI_SENSORLESS
     #if ENABLED(Y_DUAL_ENDSTOPS)
       UPDATE_ENDSTOP_BIT(Y, MAX);
       #if HAS_Y2_MAX
         UPDATE_ENDSTOP_BIT(Y2, MAX);
       #else
         COPY_LIVE_STATE(Y_MAX, Y2_MAX);
       #endif
     #else
       UPDATE_ENDSTOP_BIT(Y, MAX);
     #endif
   #endif
 
-  #if HAS_Z_MIN
+  #if HAS_Z_MIN && !Z_SPI_SENSORLESS
     #if Z_MULTI_ENDSTOPS
       UPDATE_ENDSTOP_BIT(Z, MIN);
       #if HAS_Z2_MIN
         UPDATE_ENDSTOP_BIT(Z2, MIN);
       #else
         COPY_LIVE_STATE(Z_MIN, Z2_MIN);
       #endif
       #if ENABLED(Z_TRIPLE_ENDSTOPS)
         #if HAS_Z3_MIN
           UPDATE_ENDSTOP_BIT(Z3, MIN);
@@ -609,21 +609,21 @@ void Endstops::update() {
     #elif Z_HOME_DIR < 0
       UPDATE_ENDSTOP_BIT(Z, MIN);
     #endif
   #endif
 
   // When closing the gap check the enabled probe
   #if USES_Z_MIN_PROBE_ENDSTOP
     UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
   #endif
 
-  #if HAS_Z_MAX
+  #if HAS_Z_MAX && !Z_SPI_SENSORLESS
     // Check both Z dual endstops
     #if Z_MULTI_ENDSTOPS
       UPDATE_ENDSTOP_BIT(Z, MAX);
       #if HAS_Z2_MAX
         UPDATE_ENDSTOP_BIT(Z2, MAX);
       #else
         COPY_LIVE_STATE(Z_MAX, Z2_MAX);
       #endif
       #if ENABLED(Z_TRIPLE_ENDSTOPS)
         #if HAS_Z3_MAX

commit 6a865a614620d71521bd3dc032adffe0bf82378c
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Wed Oct 9 18:46:10 2019 -0600

    Multi-language support (#15453)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 6970a051b3..0cb7c603d4 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -295,21 +295,21 @@ void Endstops::enable(const bool onoff) {
 
 // Disable / Enable endstops based on ENSTOPS_ONLY_FOR_HOMING and global enable
 void Endstops::not_homing() {
   enabled = enabled_globally;
 }
 
 #if ENABLED(VALIDATE_HOMING_ENDSTOPS)
   // If the last move failed to trigger an endstop, call kill
   void Endstops::validate_homing_move() {
     if (trigger_state()) hit_on_purpose();
-    else kill(PSTR(MSG_ERR_HOMING_FAILED));
+    else kill(GET_TEXT(MSG_LCD_HOMING_FAILED));
   }
 #endif
 
 // Enable / disable endstop z-probe checking
 #if HAS_BED_PROBE
   void Endstops::enable_z_probe(const bool onoff) {
     z_probe_enabled = onoff;
     resync();
   }
 #endif
@@ -366,21 +366,21 @@ void Endstops::event_handler() {
     ENDSTOP_HIT_TEST_Y();
     ENDSTOP_HIT_TEST_Z();
 
     #if USES_Z_MIN_PROBE_ENDSTOP
       #define P_AXIS Z_AXIS
       if (TEST(hit_state, Z_MIN_PROBE)) _ENDSTOP_HIT_ECHO(P, 'P');
     #endif
     SERIAL_EOL();
 
     #if HAS_SPI_LCD
-      ui.status_printf_P(0, PSTR(S_FMT " %c %c %c %c"), PSTR(MSG_LCD_ENDSTOPS), chrX, chrY, chrZ, chrP);
+      ui.status_printf_P(0, PSTR(S_FMT " %c %c %c %c"), GET_TEXT(MSG_LCD_ENDSTOPS), chrX, chrY, chrZ, chrP);
     #endif
 
     #if BOTH(SD_ABORT_ON_ENDSTOP_HIT, SDSUPPORT)
       if (planner.abort_on_endstop_hit) {
         card.stopSDPrint();
         quickstop_stepper();
         thermalManager.disable_all_heaters();
         print_job_timer.stop();
       }
     #endif

commit a18d16fb8b92c78093e25f8bb88cd0a49074678e
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Fri Sep 27 03:38:43 2019 -0600

    Do not implicitly concatenate localized strings (#15383)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 04f1ab6b17..6970a051b3 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -366,21 +366,21 @@ void Endstops::event_handler() {
     ENDSTOP_HIT_TEST_Y();
     ENDSTOP_HIT_TEST_Z();
 
     #if USES_Z_MIN_PROBE_ENDSTOP
       #define P_AXIS Z_AXIS
       if (TEST(hit_state, Z_MIN_PROBE)) _ENDSTOP_HIT_ECHO(P, 'P');
     #endif
     SERIAL_EOL();
 
     #if HAS_SPI_LCD
-      ui.status_printf_P(0, PSTR(MSG_LCD_ENDSTOPS " %c %c %c %c"), chrX, chrY, chrZ, chrP);
+      ui.status_printf_P(0, PSTR(S_FMT " %c %c %c %c"), PSTR(MSG_LCD_ENDSTOPS), chrX, chrY, chrZ, chrP);
     #endif
 
     #if BOTH(SD_ABORT_ON_ENDSTOP_HIT, SDSUPPORT)
       if (planner.abort_on_endstop_hit) {
         card.stopSDPrint();
         quickstop_stepper();
         thermalManager.disable_all_heaters();
         print_job_timer.stop();
       }
     #endif

commit dbee0e9c5424770b9abf8815c0cb8b49de7db77f
Author: Jamie <vector76@users.noreply.github.com>
Date:   Sun Sep 8 00:55:34 2019 -0500

    Analog joystick jogging control (#14648)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index b1a4f9e57f..04f1ab6b17 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -37,20 +37,24 @@
 #endif
 
 #if BOTH(SD_ABORT_ON_ENDSTOP_HIT, SDSUPPORT)
   #include "printcounter.h" // for print_job_timer
 #endif
 
 #if ENABLED(BLTOUCH)
   #include "../feature/bltouch.h"
 #endif
 
+#if ENABLED(JOYSTICK)
+  #include "../feature/joystick.h"
+#endif
+
 Endstops endstops;
 
 // private:
 
 bool Endstops::enabled, Endstops::enabled_globally; // Initialized by settings.load()
 volatile uint8_t Endstops::hit_state;
 
 Endstops::esbits_t Endstops::live_state = 0;
 
 #if ENDSTOP_NOISE_THRESHOLD
@@ -467,20 +471,25 @@ void _O2 Endstops::M119() {
         }
         SERIAL_ECHOPGM(MSG_FILAMENT_RUNOUT_SENSOR);
         if (i > 1) { SERIAL_CHAR(' '); SERIAL_CHAR('0' + i); }
         print_es_state(extDigitalRead(pin) != FIL_RUNOUT_INVERTING);
       }
     #endif
   #endif
   #if ENABLED(BLTOUCH)
     bltouch._reset_SW_mode();
   #endif
+
+  #if ENABLED(JOYSTICK_DEBUG)
+    joystick.report();
+  #endif
+
 } // Endstops::M119
 
 // The following routines are called from an ISR context. It could be the temperature ISR, the
 // endstop ISR or the Stepper ISR.
 
 #define _ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
 #define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN
 #define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_INVERTING
 
 // Check endstops - Could be called from Temperature ISR!

commit d4974ea719ceba2d76a678f77942d0b92e8fecb8
Author: teemuatlut <teemu.mantykallio@live.fi>
Date:   Mon Aug 5 06:22:58 2019 +0300

    TMC SPI Endstops and Improved Sensorless Homing (#14044)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 9aaab38dd2..b1a4f9e57f 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -69,20 +69,27 @@ Endstops::esbits_t Endstops::live_state = 0;
 #if ENABLED(Y_DUAL_ENDSTOPS)
   float Endstops::y2_endstop_adj;
 #endif
 #if Z_MULTI_ENDSTOPS
   float Endstops::z2_endstop_adj;
 #endif
 #if ENABLED(Z_TRIPLE_ENDSTOPS)
   float Endstops::z3_endstop_adj;
 #endif
 
+#if ENABLED(SPI_ENDSTOPS)
+  Endstops::tmc_spi_homing_t Endstops::tmc_spi_homing; // = 0
+#endif
+#if ENABLED(IMPROVE_HOMING_RELIABILITY)
+  millis_t sg_guard_period; // = 0
+#endif
+
 /**
  * Class and Instance Methods
  */
 
 void Endstops::init() {
 
   #if HAS_X_MIN
     #if ENABLED(ENDSTOPPULLUP_XMIN)
       SET_INPUT_PULLUP(X_MIN_PIN);
     #elif ENABLED(ENDSTOPPULLDOWN_XMIN)
@@ -692,63 +699,63 @@ void Endstops::update() {
            if (stepper.axis_is_moving(X_AXIS)) { _ENDSTOP_HIT(X, MIN); planner.endstop_triggered(X_AXIS); }
       else if (stepper.axis_is_moving(Y_AXIS)) { _ENDSTOP_HIT(Y, MIN); planner.endstop_triggered(Y_AXIS); }
       else if (stepper.axis_is_moving(Z_AXIS)) { _ENDSTOP_HIT(Z, MIN); planner.endstop_triggered(Z_AXIS); }
       G38_did_trigger = true;
     }
   #endif
 
   // Now, we must signal, after validation, if an endstop limit is pressed or not
   if (stepper.axis_is_moving(X_AXIS)) {
     if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
-      #if HAS_X_MIN
+      #if HAS_X_MIN || (X_SPI_SENSORLESS && X_HOME_DIR < 0)
         #if ENABLED(X_DUAL_ENDSTOPS)
           PROCESS_DUAL_ENDSTOP(X, X2, MIN);
         #else
           if (X_MIN_TEST) PROCESS_ENDSTOP(X, MIN);
         #endif
       #endif
     }
     else { // +direction
-      #if HAS_X_MAX
+      #if HAS_X_MAX || (X_SPI_SENSORLESS && X_HOME_DIR > 0)
         #if ENABLED(X_DUAL_ENDSTOPS)
           PROCESS_DUAL_ENDSTOP(X, X2, MAX);
         #else
           if (X_MAX_TEST) PROCESS_ENDSTOP(X, MAX);
         #endif
       #endif
     }
   }
 
   if (stepper.axis_is_moving(Y_AXIS)) {
     if (stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
-      #if HAS_Y_MIN
+      #if HAS_Y_MIN || (Y_SPI_SENSORLESS && Y_HOME_DIR < 0)
         #if ENABLED(Y_DUAL_ENDSTOPS)
           PROCESS_DUAL_ENDSTOP(Y, Y2, MIN);
         #else
           PROCESS_ENDSTOP(Y, MIN);
         #endif
       #endif
     }
     else { // +direction
-      #if HAS_Y_MAX
+      #if HAS_Y_MAX || (Y_SPI_SENSORLESS && Y_HOME_DIR > 0)
         #if ENABLED(Y_DUAL_ENDSTOPS)
           PROCESS_DUAL_ENDSTOP(Y, Y2, MAX);
         #else
           PROCESS_ENDSTOP(Y, MAX);
         #endif
       #endif
     }
   }
 
   if (stepper.axis_is_moving(Z_AXIS)) {
     if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
-      #if HAS_Z_MIN
+      #if HAS_Z_MIN || (Z_SPI_SENSORLESS && Z_HOME_DIR < 0)
         #if ENABLED(Z_TRIPLE_ENDSTOPS)
           PROCESS_TRIPLE_ENDSTOP(Z, Z2, Z3, MIN);
         #elif ENABLED(Z_DUAL_ENDSTOPS)
           PROCESS_DUAL_ENDSTOP(Z, Z2, MIN);
         #else
           #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
             if (z_probe_enabled) PROCESS_ENDSTOP(Z, MIN);
           #elif USES_Z_MIN_PROBE_ENDSTOP
             if (!z_probe_enabled) PROCESS_ENDSTOP(Z, MIN);
           #else
@@ -756,35 +763,78 @@ void Endstops::update() {
           #endif
         #endif
       #endif
 
       // When closing the gap check the enabled probe
       #if USES_Z_MIN_PROBE_ENDSTOP
         if (z_probe_enabled) PROCESS_ENDSTOP(Z, MIN_PROBE);
       #endif
     }
     else { // Z +direction. Gantry up, bed down.
-      #if HAS_Z_MAX
+      #if HAS_Z_MAX || (Z_SPI_SENSORLESS && Z_HOME_DIR > 0)
         #if ENABLED(Z_TRIPLE_ENDSTOPS)
           PROCESS_TRIPLE_ENDSTOP(Z, Z2, Z3, MAX);
         #elif ENABLED(Z_DUAL_ENDSTOPS)
           PROCESS_DUAL_ENDSTOP(Z, Z2, MAX);
         #elif !USES_Z_MIN_PROBE_ENDSTOP || Z_MAX_PIN != Z_MIN_PROBE_PIN
           // If this pin is not hijacked for the bed probe
           // then it belongs to the Z endstop
           PROCESS_ENDSTOP(Z, MAX);
         #endif
       #endif
     }
   }
 } // Endstops::update()
 
+#if ENABLED(SPI_ENDSTOPS)
+
+  #define X_STOP (X_HOME_DIR < 0 ? X_MIN : X_MAX)
+  #define Y_STOP (Y_HOME_DIR < 0 ? Y_MIN : Y_MAX)
+  #define Z_STOP (Z_HOME_DIR < 0 ? Z_MIN : Z_MAX)
+
+  bool Endstops::tmc_spi_homing_check() {
+    bool hit = false;
+    #if X_SPI_SENSORLESS
+      if (tmc_spi_homing.x && stepperX.test_stall_status()) {
+        SBI(live_state, X_STOP);
+        hit = true;
+      }
+    #endif
+    #if Y_SPI_SENSORLESS
+      if (tmc_spi_homing.y && stepperY.test_stall_status()) {
+        SBI(live_state, Y_STOP);
+        hit = true;
+      }
+    #endif
+    #if Z_SPI_SENSORLESS
+      if (tmc_spi_homing.z && stepperZ.test_stall_status()) {
+        SBI(live_state, Z_STOP);
+        hit = true;
+      }
+    #endif
+    return hit;
+  }
+
+  void Endstops::clear_endstop_state() {
+    #if X_SPI_SENSORLESS
+      CBI(live_state, X_STOP);
+    #endif
+    #if Y_SPI_SENSORLESS
+      CBI(live_state, Y_STOP);
+    #endif
+    #if Z_SPI_SENSORLESS
+      CBI(live_state, Z_STOP);
+    #endif
+  }
+
+#endif // SPI_ENDSTOPS
+
 #if ENABLED(PINS_DEBUGGING)
 
   bool Endstops::monitor_flag = false;
 
   /**
    * Monitor Endstops and Z Probe for changes
    *
    * If a change is detected then the LED is toggled and
    * a message is sent out the serial port.
    *

commit eae543adf34268505f9321b7576495db20293c09
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jul 29 18:45:01 2019 -0500

    Apply HAS_SPI_LCD as needed

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index abc93e9f1d..9aaab38dd2 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -323,21 +323,21 @@ void Endstops::resync() {
     static uint8_t monitor_count = 16;  // offset this check from the others
     monitor_count += _BV(1);            //  15 Hz
     monitor_count &= 0x7F;
     if (!monitor_count) monitor();      // report changes in endstop status
   }
 #endif
 
 void Endstops::event_handler() {
   static uint8_t prev_hit_state; // = 0
   if (hit_state && hit_state != prev_hit_state) {
-    #if ENABLED(ULTRA_LCD)
+    #if HAS_SPI_LCD
       char chrX = ' ', chrY = ' ', chrZ = ' ', chrP = ' ';
       #define _SET_STOP_CHAR(A,C) (chr## A = C)
     #else
       #define _SET_STOP_CHAR(A,C) ;
     #endif
 
     #define _ENDSTOP_HIT_ECHO(A,C) do{ \
       SERIAL_ECHOPAIR(" " STRINGIFY(A) ":", planner.triggered_position_mm(_AXIS(A))); \
       _SET_STOP_CHAR(A,C); }while(0)
 
@@ -354,21 +354,21 @@ void Endstops::event_handler() {
     ENDSTOP_HIT_TEST_X();
     ENDSTOP_HIT_TEST_Y();
     ENDSTOP_HIT_TEST_Z();
 
     #if USES_Z_MIN_PROBE_ENDSTOP
       #define P_AXIS Z_AXIS
       if (TEST(hit_state, Z_MIN_PROBE)) _ENDSTOP_HIT_ECHO(P, 'P');
     #endif
     SERIAL_EOL();
 
-    #if ENABLED(ULTRA_LCD)
+    #if HAS_SPI_LCD
       ui.status_printf_P(0, PSTR(MSG_LCD_ENDSTOPS " %c %c %c %c"), chrX, chrY, chrZ, chrP);
     #endif
 
     #if BOTH(SD_ABORT_ON_ENDSTOP_HIT, SDSUPPORT)
       if (planner.abort_on_endstop_hit) {
         card.stopSDPrint();
         quickstop_stepper();
         thermalManager.disable_all_heaters();
         print_job_timer.stop();
       }

commit 1088846caef6f660d5af65e1725a6a6deeef16fd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jul 24 01:52:36 2019 -0500

    Cosmetic updates from 14044

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 7234bf4769..abc93e9f1d 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -776,28 +776,27 @@ void Endstops::update() {
       #endif
     }
   }
 } // Endstops::update()
 
 #if ENABLED(PINS_DEBUGGING)
 
   bool Endstops::monitor_flag = false;
 
   /**
-   * monitors endstops & Z probe for changes
+   * Monitor Endstops and Z Probe for changes
    *
    * If a change is detected then the LED is toggled and
-   * a message is sent out the serial port
+   * a message is sent out the serial port.
    *
    * Yes, we could miss a rapid back & forth change but
    * that won't matter because this is all manual.
-   *
    */
   void Endstops::monitor() {
 
     static uint16_t old_live_state_local = 0;
     static uint8_t local_LED_status = 0;
     uint16_t live_state_local = 0;
 
     #define ES_GET_STATE(S) if (READ(S##_PIN)) SBI(live_state_local, S)
 
     #if HAS_X_MIN

commit 93cd66ac1146603e8a9911fceb3c63f4351f4d8e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 23:57:50 2019 -0500

    Tweaky change from (C) to (c)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index a70ef19da9..7234bf4769 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -1,16 +1,16 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

commit 52383633e7062bf5ffd72d9c41c4cf7df05c544c
Author: Tanguy Pruvot <tpruvot@users.noreply.github.com>
Date:   Fri Jun 21 08:20:17 2019 +0200

    STM32F1: M43 PINS_DEBUGGING (#14072)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 30bc3375d5..a70ef19da9 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -889,17 +889,17 @@ void Endstops::update() {
       #if HAS_Z2_MAX
         ES_REPORT_CHANGE(Z2_MAX);
       #endif
       #if HAS_Z3_MIN
         ES_REPORT_CHANGE(Z3_MIN);
       #endif
       #if HAS_Z3_MAX
         ES_REPORT_CHANGE(Z3_MAX);
       #endif
       SERIAL_ECHOLNPGM("\n");
-      analogWrite(LED_PIN, local_LED_status);
+      analogWrite(pin_t(LED_PIN), local_LED_status);
       local_LED_status ^= 255;
       old_live_state_local = live_state_local;
     }
   }
 
 #endif // PINS_DEBUGGING

commit 0ca2073625fcf1eb35de8c37d49960bf20bed4b6
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jun 10 17:25:43 2019 -0500

    ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED => SD_ABORT_ON_ENDSTOP_HIT

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index deba8b33a4..30bc3375d5 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -29,21 +29,21 @@
 
 #include "../Marlin.h"
 #include "../sd/cardreader.h"
 #include "temperature.h"
 #include "../lcd/ultralcd.h"
 
 #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
   #include HAL_PATH(../HAL, endstop_interrupts.h)
 #endif
 
-#if BOTH(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED, SDSUPPORT)
+#if BOTH(SD_ABORT_ON_ENDSTOP_HIT, SDSUPPORT)
   #include "printcounter.h" // for print_job_timer
 #endif
 
 #if ENABLED(BLTOUCH)
   #include "../feature/bltouch.h"
 #endif
 
 Endstops endstops;
 
 // private:
@@ -358,21 +358,21 @@ void Endstops::event_handler() {
     #if USES_Z_MIN_PROBE_ENDSTOP
       #define P_AXIS Z_AXIS
       if (TEST(hit_state, Z_MIN_PROBE)) _ENDSTOP_HIT_ECHO(P, 'P');
     #endif
     SERIAL_EOL();
 
     #if ENABLED(ULTRA_LCD)
       ui.status_printf_P(0, PSTR(MSG_LCD_ENDSTOPS " %c %c %c %c"), chrX, chrY, chrZ, chrP);
     #endif
 
-    #if BOTH(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED, SDSUPPORT)
+    #if BOTH(SD_ABORT_ON_ENDSTOP_HIT, SDSUPPORT)
       if (planner.abort_on_endstop_hit) {
         card.stopSDPrint();
         quickstop_stepper();
         thermalManager.disable_all_heaters();
         print_job_timer.stop();
       }
     #endif
   }
   prev_hit_state = hit_state;
 }

commit 85fb33a060354a70348f220085405ae7bfb939c5
Author: FanDjango <FanDjango@users.noreply.github.com>
Date:   Sat May 18 02:10:18 2019 +0200

    BLTOUCH tweaks, new v3.1 command (#14015)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index bfb89fb7b5..deba8b33a4 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -458,22 +458,21 @@ void _O2 Endstops::M119() {
             #endif
           #endif
         }
         SERIAL_ECHOPGM(MSG_FILAMENT_RUNOUT_SENSOR);
         if (i > 1) { SERIAL_CHAR(' '); SERIAL_CHAR('0' + i); }
         print_es_state(extDigitalRead(pin) != FIL_RUNOUT_INVERTING);
       }
     #endif
   #endif
   #if ENABLED(BLTOUCH)
-    bltouch._reset();
-    if (enabled_globally) bltouch._stow();
+    bltouch._reset_SW_mode();
   #endif
 } // Endstops::M119
 
 // The following routines are called from an ISR context. It could be the temperature ISR, the
 // endstop ISR or the Stepper ISR.
 
 #define _ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
 #define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN
 #define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_INVERTING
 

commit ad4ffa1d2fbd17ac09c816ba2052cdf714261042
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 9 11:45:55 2019 -0500

    Use C++ language supported 'nullptr' (#13944)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index fdcc076db5..bfb89fb7b5 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -370,21 +370,21 @@ void Endstops::event_handler() {
         card.stopSDPrint();
         quickstop_stepper();
         thermalManager.disable_all_heaters();
         print_job_timer.stop();
       }
     #endif
   }
   prev_hit_state = hit_state;
 }
 
-static void print_es_state(const bool is_hit, PGM_P const label=NULL) {
+static void print_es_state(const bool is_hit, PGM_P const label=nullptr) {
   if (label) serialprintPGM(label);
   SERIAL_ECHOPGM(": ");
   serialprintPGM(is_hit ? PSTR(MSG_ENDSTOP_HIT) : PSTR(MSG_ENDSTOP_OPEN));
   SERIAL_EOL();
 }
 
 void _O2 Endstops::M119() {
   #if ENABLED(BLTOUCH)
     bltouch._set_SW_mode();
   #endif

commit 6811e2921bcd272e7487e4f379b42a5a403a07c2
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Tue May 7 22:25:54 2019 -0400

    BLTouch v3 / 3DTouch Interoperability & performance (#13814)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index e077045ef5..fdcc076db5 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -33,20 +33,24 @@
 #include "../lcd/ultralcd.h"
 
 #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
   #include HAL_PATH(../HAL, endstop_interrupts.h)
 #endif
 
 #if BOTH(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED, SDSUPPORT)
   #include "printcounter.h" // for print_job_timer
 #endif
 
+#if ENABLED(BLTOUCH)
+  #include "../feature/bltouch.h"
+#endif
+
 Endstops endstops;
 
 // private:
 
 bool Endstops::enabled, Endstops::enabled_globally; // Initialized by settings.load()
 volatile uint8_t Endstops::hit_state;
 
 Endstops::esbits_t Endstops::live_state = 0;
 
 #if ENDSTOP_NOISE_THRESHOLD
@@ -374,20 +378,23 @@ void Endstops::event_handler() {
 }
 
 static void print_es_state(const bool is_hit, PGM_P const label=NULL) {
   if (label) serialprintPGM(label);
   SERIAL_ECHOPGM(": ");
   serialprintPGM(is_hit ? PSTR(MSG_ENDSTOP_HIT) : PSTR(MSG_ENDSTOP_OPEN));
   SERIAL_EOL();
 }
 
 void _O2 Endstops::M119() {
+  #if ENABLED(BLTOUCH)
+    bltouch._set_SW_mode();
+  #endif
   SERIAL_ECHOLNPGM(MSG_M119_REPORT);
   #define ES_REPORT(S) print_es_state(READ(S##_PIN) != S##_ENDSTOP_INVERTING, PSTR(MSG_##S))
   #if HAS_X_MIN
     ES_REPORT(X_MIN);
   #endif
   #if HAS_X2_MIN
     ES_REPORT(X2_MIN);
   #endif
   #if HAS_X_MAX
     ES_REPORT(X_MAX);
@@ -450,20 +457,24 @@ void _O2 Endstops::M119() {
               #endif
             #endif
           #endif
         }
         SERIAL_ECHOPGM(MSG_FILAMENT_RUNOUT_SENSOR);
         if (i > 1) { SERIAL_CHAR(' '); SERIAL_CHAR('0' + i); }
         print_es_state(extDigitalRead(pin) != FIL_RUNOUT_INVERTING);
       }
     #endif
   #endif
+  #if ENABLED(BLTOUCH)
+    bltouch._reset();
+    if (enabled_globally) bltouch._stow();
+  #endif
 } // Endstops::M119
 
 // The following routines are called from an ISR context. It could be the temperature ISR, the
 // endstop ISR or the Stepper ISR.
 
 #define _ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
 #define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN
 #define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_INVERTING
 
 // Check endstops - Could be called from Temperature ISR!

commit 49cf92dc36424cf828436f32e72263eca39a1cc3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 16 23:43:06 2019 -0500

    Extended condition macros (#13419)
    
    Allow `ENABLED`, `DISABLED`, `PIN_EXISTS`, and `BUTTON_EXISTS` to take multiple arguments. Also add:
    - Alias `ANY(...)` for `!DISABLED(...)`
    - Alias `ANY_PIN(...)` for `PIN_EXISTS(a) || PIN_EXISTS(b) ...`
    - Alias `EITHER(A,B)` for `ANY(...)`
    - Alias `ALL(...)` and `BOTH(A,B)` for `ENABLED(...)`
    - `NONE(...)` for `DISABLED(...)`

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index c5185f1834..e077045ef5 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -29,21 +29,21 @@
 
 #include "../Marlin.h"
 #include "../sd/cardreader.h"
 #include "temperature.h"
 #include "../lcd/ultralcd.h"
 
 #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
   #include HAL_PATH(../HAL, endstop_interrupts.h)
 #endif
 
-#if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED) && ENABLED(SDSUPPORT)
+#if BOTH(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED, SDSUPPORT)
   #include "printcounter.h" // for print_job_timer
 #endif
 
 Endstops endstops;
 
 // private:
 
 bool Endstops::enabled, Endstops::enabled_globally; // Initialized by settings.load()
 volatile uint8_t Endstops::hit_state;
 
@@ -354,21 +354,21 @@ void Endstops::event_handler() {
     #if USES_Z_MIN_PROBE_ENDSTOP
       #define P_AXIS Z_AXIS
       if (TEST(hit_state, Z_MIN_PROBE)) _ENDSTOP_HIT_ECHO(P, 'P');
     #endif
     SERIAL_EOL();
 
     #if ENABLED(ULTRA_LCD)
       ui.status_printf_P(0, PSTR(MSG_LCD_ENDSTOPS " %c %c %c %c"), chrX, chrY, chrZ, chrP);
     #endif
 
-    #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED) && ENABLED(SDSUPPORT)
+    #if BOTH(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED, SDSUPPORT)
       if (planner.abort_on_endstop_hit) {
         card.stopSDPrint();
         quickstop_stepper();
         thermalManager.disable_all_heaters();
         print_job_timer.stop();
       }
     #endif
   }
   prev_hit_state = hit_state;
 }

commit 67bee06e4371fca6511aae99125337b6e63560d8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 13 07:21:10 2019 -0500

    No patch needed for non-libmaple analogWrite
    
    See https://github.com/pinchies/Marlin/pull/1#issuecomment-471388743

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index fe076b6d38..c5185f1834 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -879,17 +879,17 @@ void Endstops::update() {
       #if HAS_Z2_MAX
         ES_REPORT_CHANGE(Z2_MAX);
       #endif
       #if HAS_Z3_MIN
         ES_REPORT_CHANGE(Z3_MIN);
       #endif
       #if HAS_Z3_MAX
         ES_REPORT_CHANGE(Z3_MAX);
       #endif
       SERIAL_ECHOLNPGM("\n");
-      ANALOG_WRITE(LED_PIN, local_LED_status);
+      analogWrite(LED_PIN, local_LED_status);
       local_LED_status ^= 255;
       old_live_state_local = live_state_local;
     }
   }
 
 #endif // PINS_DEBUGGING

commit f89b375fb9ca9730a4165ac3bf9f0f9dc100a338
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Mar 13 06:51:15 2019 -0500

    Fixes and improvements for PWM pins (#13383)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index c5185f1834..fe076b6d38 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -879,17 +879,17 @@ void Endstops::update() {
       #if HAS_Z2_MAX
         ES_REPORT_CHANGE(Z2_MAX);
       #endif
       #if HAS_Z3_MIN
         ES_REPORT_CHANGE(Z3_MIN);
       #endif
       #if HAS_Z3_MAX
         ES_REPORT_CHANGE(Z3_MAX);
       #endif
       SERIAL_ECHOLNPGM("\n");
-      analogWrite(LED_PIN, local_LED_status);
+      ANALOG_WRITE(LED_PIN, local_LED_status);
       local_LED_status ^= 255;
       old_live_state_local = live_state_local;
     }
   }
 
 #endif // PINS_DEBUGGING

commit b824a517aaad62001cf815e577b2f383f4766402
Author: Michiel Baird <michielbaird@gmail.com>
Date:   Sun Mar 10 15:22:09 2019 -0700

    Add G38.4 and G38.5 (#13348)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 46c6db8998..c5185f1834 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -665,28 +665,31 @@ void Endstops::update() {
     const byte triple_hit = TEST_ENDSTOP(_ENDSTOP(AXIS1, MINMAX)) | (TEST_ENDSTOP(_ENDSTOP(AXIS2, MINMAX)) << 1) | (TEST_ENDSTOP(_ENDSTOP(AXIS3, MINMAX)) << 2); \
     if (triple_hit) { \
       _ENDSTOP_HIT(AXIS1, MINMAX); \
       /* if not performing home or if both endstops were trigged during homing... */ \
       if (!stepper.separate_multi_axis || triple_hit == 0b111) \
         planner.endstop_triggered(_AXIS(AXIS1)); \
     } \
   }while(0)
 
   #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && !(CORE_IS_XY || CORE_IS_XZ)
+    #if ENABLED(G38_PROBE_AWAY)
+      #define _G38_OPEN_STATE (G38_move >= 4)
+    #else
+      #define _G38_OPEN_STATE LOW
+    #endif
     // If G38 command is active check Z_MIN_PROBE for ALL movement
-    if (G38_move) {
-      if (TEST_ENDSTOP(_ENDSTOP(Z, MIN_PROBE))) {
-        if      (stepper.axis_is_moving(X_AXIS)) { _ENDSTOP_HIT(X, MIN); planner.endstop_triggered(X_AXIS); }
-        else if (stepper.axis_is_moving(Y_AXIS)) { _ENDSTOP_HIT(Y, MIN); planner.endstop_triggered(Y_AXIS); }
-        else if (stepper.axis_is_moving(Z_AXIS)) { _ENDSTOP_HIT(Z, MIN); planner.endstop_triggered(Z_AXIS); }
-        G38_endstop_hit = true;
-      }
+    if (G38_move && TEST_ENDSTOP(_ENDSTOP(Z, MIN_PROBE)) != _G38_OPEN_STATE) {
+           if (stepper.axis_is_moving(X_AXIS)) { _ENDSTOP_HIT(X, MIN); planner.endstop_triggered(X_AXIS); }
+      else if (stepper.axis_is_moving(Y_AXIS)) { _ENDSTOP_HIT(Y, MIN); planner.endstop_triggered(Y_AXIS); }
+      else if (stepper.axis_is_moving(Z_AXIS)) { _ENDSTOP_HIT(Z, MIN); planner.endstop_triggered(Z_AXIS); }
+      G38_did_trigger = true;
     }
   #endif
 
   // Now, we must signal, after validation, if an endstop limit is pressed or not
   if (stepper.axis_is_moving(X_AXIS)) {
     if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
       #if HAS_X_MIN
         #if ENABLED(X_DUAL_ENDSTOPS)
           PROCESS_DUAL_ENDSTOP(X, X2, MIN);
         #else

commit 2212da453aa8a575df529cd4333b5248d9bae5b5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Mar 5 00:41:31 2019 -0600

    Distinguish between analog/digital auto fans (#13298)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index d79c63c77d..46c6db8998 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -446,21 +446,21 @@ void _O2 Endstops::M119() {
                 case 5: pin = FIL_RUNOUT5_PIN; break;
                 #if NUM_RUNOUT_SENSORS > 5
                   case 6: pin = FIL_RUNOUT6_PIN; break;
                 #endif
               #endif
             #endif
           #endif
         }
         SERIAL_ECHOPGM(MSG_FILAMENT_RUNOUT_SENSOR);
         if (i > 1) { SERIAL_CHAR(' '); SERIAL_CHAR('0' + i); }
-        print_es_state(digitalRead(pin) != FIL_RUNOUT_INVERTING);
+        print_es_state(extDigitalRead(pin) != FIL_RUNOUT_INVERTING);
       }
     #endif
   #endif
 } // Endstops::M119
 
 // The following routines are called from an ISR context. It could be the temperature ISR, the
 // endstop ISR or the Stepper ISR.
 
 #define _ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
 #define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN

commit 99d0022fae0efd9164946062bf641f7294597675
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 1 00:27:45 2019 -0600

    Drop the Z_MIN_PROBE_ENDSTOP option (#13276)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index addc6699af..d79c63c77d 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -221,21 +221,21 @@ void Endstops::init() {
   #if HAS_CALIBRATION_PIN
     #if ENABLED(CALIBRATION_PIN_PULLUP)
       SET_INPUT_PULLUP(CALIBRATION_PIN);
     #elif ENABLED(CALIBRATION_PIN_PULLDOWN)
       SET_INPUT_PULLDOWN(CALIBRATION_PIN);
     #else
       SET_INPUT(CALIBRATION_PIN);
     #endif
   #endif
 
-  #if ENABLED(Z_MIN_PROBE_ENDSTOP)
+  #if USES_Z_MIN_PROBE_ENDSTOP
     #if ENABLED(ENDSTOPPULLUP_ZMIN_PROBE)
       SET_INPUT_PULLUP(Z_MIN_PROBE_PIN);
     #elif ENABLED(ENDSTOPPULLDOWN_ZMIN_PROBE)
       SET_INPUT_PULLDOWN(Z_MIN_PROBE_PIN);
     #else
       SET_INPUT(Z_MIN_PROBE_PIN);
     #endif
   #endif
 
   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
@@ -344,21 +344,21 @@ void Endstops::event_handler() {
     #define ENDSTOP_HIT_TEST_X() _ENDSTOP_HIT_TEST(X,'X')
     #define ENDSTOP_HIT_TEST_Y() _ENDSTOP_HIT_TEST(Y,'Y')
     #define ENDSTOP_HIT_TEST_Z() _ENDSTOP_HIT_TEST(Z,'Z')
 
     SERIAL_ECHO_START();
     SERIAL_ECHOPGM(MSG_ENDSTOPS_HIT);
     ENDSTOP_HIT_TEST_X();
     ENDSTOP_HIT_TEST_Y();
     ENDSTOP_HIT_TEST_Z();
 
-    #if ENABLED(Z_MIN_PROBE_ENDSTOP)
+    #if USES_Z_MIN_PROBE_ENDSTOP
       #define P_AXIS Z_AXIS
       if (TEST(hit_state, Z_MIN_PROBE)) _ENDSTOP_HIT_ECHO(P, 'P');
     #endif
     SERIAL_EOL();
 
     #if ENABLED(ULTRA_LCD)
       ui.status_printf_P(0, PSTR(MSG_LCD_ENDSTOPS " %c %c %c %c"), chrX, chrY, chrZ, chrP);
     #endif
 
     #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED) && ENABLED(SDSUPPORT)
@@ -418,21 +418,21 @@ void _O2 Endstops::M119() {
   #endif
   #if HAS_Z_MAX
     ES_REPORT(Z_MAX);
   #endif
   #if HAS_Z2_MAX
     ES_REPORT(Z2_MAX);
   #endif
   #if HAS_Z3_MAX
     ES_REPORT(Z3_MAX);
   #endif
-  #if ENABLED(Z_MIN_PROBE_ENDSTOP)
+  #if USES_Z_MIN_PROBE_ENDSTOP
     print_es_state(READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING, PSTR(MSG_Z_PROBE));
   #endif
   #if HAS_FILAMENT_SENSOR
     #if NUM_RUNOUT_SENSORS == 1
       print_es_state(READ(FIL_RUNOUT_PIN) != FIL_RUNOUT_INVERTING, PSTR(MSG_FILAMENT_RUNOUT_SENSOR));
     #else
       for (uint8_t i = 1; i <= NUM_RUNOUT_SENSORS; i++) {
         pin_t pin;
         switch (i) {
           default: continue;
@@ -579,41 +579,41 @@ void Endstops::update() {
         #endif
       #endif
     #elif ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
       UPDATE_ENDSTOP_BIT(Z, MIN);
     #elif Z_HOME_DIR < 0
       UPDATE_ENDSTOP_BIT(Z, MIN);
     #endif
   #endif
 
   // When closing the gap check the enabled probe
-  #if ENABLED(Z_MIN_PROBE_ENDSTOP)
+  #if USES_Z_MIN_PROBE_ENDSTOP
     UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
   #endif
 
   #if HAS_Z_MAX
     // Check both Z dual endstops
     #if Z_MULTI_ENDSTOPS
       UPDATE_ENDSTOP_BIT(Z, MAX);
       #if HAS_Z2_MAX
         UPDATE_ENDSTOP_BIT(Z2, MAX);
       #else
         COPY_LIVE_STATE(Z_MAX, Z2_MAX);
       #endif
       #if ENABLED(Z_TRIPLE_ENDSTOPS)
         #if HAS_Z3_MAX
           UPDATE_ENDSTOP_BIT(Z3, MAX);
         #else
           COPY_LIVE_STATE(Z_MAX, Z3_MAX);
         #endif
       #endif
-    #elif DISABLED(Z_MIN_PROBE_ENDSTOP) || Z_MAX_PIN != Z_MIN_PROBE_PIN
+    #elif !USES_Z_MIN_PROBE_ENDSTOP || Z_MAX_PIN != Z_MIN_PROBE_PIN
       // If this pin isn't the bed probe it's the Z endstop
       UPDATE_ENDSTOP_BIT(Z, MAX);
     #endif
   #endif
 
   #if ENDSTOP_NOISE_THRESHOLD
 
     /**
      * Filtering out noise on endstops requires a delayed decision. Let's assume, due to noise,
      * that 50% of endstop signal samples are good and 50% are bad (assuming normal distribution
@@ -729,40 +729,40 @@ void Endstops::update() {
   if (stepper.axis_is_moving(Z_AXIS)) {
     if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
       #if HAS_Z_MIN
         #if ENABLED(Z_TRIPLE_ENDSTOPS)
           PROCESS_TRIPLE_ENDSTOP(Z, Z2, Z3, MIN);
         #elif ENABLED(Z_DUAL_ENDSTOPS)
           PROCESS_DUAL_ENDSTOP(Z, Z2, MIN);
         #else
           #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
             if (z_probe_enabled) PROCESS_ENDSTOP(Z, MIN);
-          #elif ENABLED(Z_MIN_PROBE_ENDSTOP)
+          #elif USES_Z_MIN_PROBE_ENDSTOP
             if (!z_probe_enabled) PROCESS_ENDSTOP(Z, MIN);
           #else
             PROCESS_ENDSTOP(Z, MIN);
           #endif
         #endif
       #endif
 
       // When closing the gap check the enabled probe
-      #if ENABLED(Z_MIN_PROBE_ENDSTOP)
+      #if USES_Z_MIN_PROBE_ENDSTOP
         if (z_probe_enabled) PROCESS_ENDSTOP(Z, MIN_PROBE);
       #endif
     }
     else { // Z +direction. Gantry up, bed down.
       #if HAS_Z_MAX
         #if ENABLED(Z_TRIPLE_ENDSTOPS)
           PROCESS_TRIPLE_ENDSTOP(Z, Z2, Z3, MAX);
         #elif ENABLED(Z_DUAL_ENDSTOPS)
           PROCESS_DUAL_ENDSTOP(Z, Z2, MAX);
-        #elif DISABLED(Z_MIN_PROBE_ENDSTOP) || Z_MAX_PIN != Z_MIN_PROBE_PIN
+        #elif !USES_Z_MIN_PROBE_ENDSTOP || Z_MAX_PIN != Z_MIN_PROBE_PIN
           // If this pin is not hijacked for the bed probe
           // then it belongs to the Z endstop
           PROCESS_ENDSTOP(Z, MAX);
         #endif
       #endif
     }
   }
 } // Endstops::update()
 
 #if ENABLED(PINS_DEBUGGING)

commit 7cf9b93f26f728f0104dc9b930f6b23096639d98
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 20:08:34 2019 -0600

    Add HAS_FILAMENT_SENSOR ahead of 12962

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 7d6b04f99c..addc6699af 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -421,21 +421,21 @@ void _O2 Endstops::M119() {
   #endif
   #if HAS_Z2_MAX
     ES_REPORT(Z2_MAX);
   #endif
   #if HAS_Z3_MAX
     ES_REPORT(Z3_MAX);
   #endif
   #if ENABLED(Z_MIN_PROBE_ENDSTOP)
     print_es_state(READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING, PSTR(MSG_Z_PROBE));
   #endif
-  #if ENABLED(FILAMENT_RUNOUT_SENSOR)
+  #if HAS_FILAMENT_SENSOR
     #if NUM_RUNOUT_SENSORS == 1
       print_es_state(READ(FIL_RUNOUT_PIN) != FIL_RUNOUT_INVERTING, PSTR(MSG_FILAMENT_RUNOUT_SENSOR));
     #else
       for (uint8_t i = 1; i <= NUM_RUNOUT_SENSORS; i++) {
         pin_t pin;
         switch (i) {
           default: continue;
           case 1: pin = FIL_RUNOUT_PIN; break;
           case 2: pin = FIL_RUNOUT2_PIN; break;
           #if NUM_RUNOUT_SENSORS > 2

commit 0feeef26048883640b37ebe3994730f31ef6e922
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 15:06:53 2019 -0600

    Update copyright in headers

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 119bea1242..7d6b04f99c 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit e1604198ffa550f1eed2b8f5d39d51fdc0c2762f
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Wed Feb 6 16:20:17 2019 -0700

    G425 ‚Äî Auto-calibrate Backlash and Nozzle Offsets (#13050)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index cd543bcb7a..119bea1242 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -211,20 +211,30 @@ void Endstops::init() {
   #if HAS_Z3_MAX
     #if ENABLED(ENDSTOPPULLUP_ZMAX)
       SET_INPUT_PULLUP(Z3_MAX_PIN);
     #elif ENABLED(ENDSTOPPULLDOWN_ZMAX)
       SET_INPUT_PULLDOWN(Z3_MAX_PIN);
     #else
       SET_INPUT(Z3_MAX_PIN);
     #endif
   #endif
 
+  #if HAS_CALIBRATION_PIN
+    #if ENABLED(CALIBRATION_PIN_PULLUP)
+      SET_INPUT_PULLUP(CALIBRATION_PIN);
+    #elif ENABLED(CALIBRATION_PIN_PULLDOWN)
+      SET_INPUT_PULLDOWN(CALIBRATION_PIN);
+    #else
+      SET_INPUT(CALIBRATION_PIN);
+    #endif
+  #endif
+
   #if ENABLED(Z_MIN_PROBE_ENDSTOP)
     #if ENABLED(ENDSTOPPULLUP_ZMIN_PROBE)
       SET_INPUT_PULLUP(Z_MIN_PROBE_PIN);
     #elif ENABLED(ENDSTOPPULLDOWN_ZMIN_PROBE)
       SET_INPUT_PULLDOWN(Z_MIN_PROBE_PIN);
     #else
       SET_INPUT(Z_MIN_PROBE_PIN);
     #endif
   #endif
 

commit d4d1b28a06caa57d26e300c1b814b2b8b62120cd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 4 03:41:55 2019 -0600

    Fix some include paths

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 1875782465..cd543bcb7a 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -22,29 +22,29 @@
 
 /**
  * endstops.cpp - A singleton object to manage endstops
  */
 
 #include "endstops.h"
 #include "stepper.h"
 
 #include "../Marlin.h"
 #include "../sd/cardreader.h"
-#include "../module/temperature.h"
+#include "temperature.h"
 #include "../lcd/ultralcd.h"
 
 #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
   #include HAL_PATH(../HAL, endstop_interrupts.h)
 #endif
 
 #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED) && ENABLED(SDSUPPORT)
-  #include "../module/printcounter.h" // for print_job_timer
+  #include "printcounter.h" // for print_job_timer
 #endif
 
 Endstops endstops;
 
 // private:
 
 bool Endstops::enabled, Endstops::enabled_globally; // Initialized by settings.load()
 volatile uint8_t Endstops::hit_state;
 
 Endstops::esbits_t Endstops::live_state = 0;

commit 4fa1c52688917b139f1a2a68dd9028a592d4567a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Feb 2 23:32:48 2019 -0600

    Tweak serial output code

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 41ac8a37d9..1875782465 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -865,18 +865,18 @@ void Endstops::update() {
       #endif
       #if HAS_Z2_MAX
         ES_REPORT_CHANGE(Z2_MAX);
       #endif
       #if HAS_Z3_MIN
         ES_REPORT_CHANGE(Z3_MIN);
       #endif
       #if HAS_Z3_MAX
         ES_REPORT_CHANGE(Z3_MAX);
       #endif
-      SERIAL_ECHOPGM("\n\n");
+      SERIAL_ECHOLNPGM("\n");
       analogWrite(LED_PIN, local_LED_status);
       local_LED_status ^= 255;
       old_live_state_local = live_state_local;
     }
   }
 
 #endif // PINS_DEBUGGING

commit e874f9664c541b5a9f0d24149fba2b5956b623ec
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Nov 30 14:25:43 2018 -0600

    Tweaks to endstops code

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index ff5311781c..41ac8a37d9 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -768,112 +768,115 @@ void Endstops::update() {
    * Yes, we could miss a rapid back & forth change but
    * that won't matter because this is all manual.
    *
    */
   void Endstops::monitor() {
 
     static uint16_t old_live_state_local = 0;
     static uint8_t local_LED_status = 0;
     uint16_t live_state_local = 0;
 
+    #define ES_GET_STATE(S) if (READ(S##_PIN)) SBI(live_state_local, S)
+
     #if HAS_X_MIN
-      if (READ(X_MIN_PIN)) SBI(live_state_local, X_MIN);
+      ES_GET_STATE(X_MIN);
     #endif
     #if HAS_X_MAX
-      if (READ(X_MAX_PIN)) SBI(live_state_local, X_MAX);
+      ES_GET_STATE(X_MAX);
     #endif
     #if HAS_Y_MIN
-      if (READ(Y_MIN_PIN)) SBI(live_state_local, Y_MIN);
+      ES_GET_STATE(Y_MIN);
     #endif
     #if HAS_Y_MAX
-      if (READ(Y_MAX_PIN)) SBI(live_state_local, Y_MAX);
+      ES_GET_STATE(Y_MAX);
     #endif
     #if HAS_Z_MIN
-      if (READ(Z_MIN_PIN)) SBI(live_state_local, Z_MIN);
+      ES_GET_STATE(Z_MIN);
     #endif
     #if HAS_Z_MAX
-      if (READ(Z_MAX_PIN)) SBI(live_state_local, Z_MAX);
+      ES_GET_STATE(Z_MAX);
     #endif
     #if HAS_Z_MIN_PROBE_PIN
-      if (READ(Z_MIN_PROBE_PIN)) SBI(live_state_local, Z_MIN_PROBE);
+      ES_GET_STATE(Z_MIN_PROBE);
     #endif
     #if HAS_X2_MIN
-      if (READ(X2_MIN_PIN)) SBI(live_state_local, X2_MIN);
+      ES_GET_STATE(X2_MIN);
     #endif
     #if HAS_X2_MAX
-      if (READ(X2_MAX_PIN)) SBI(live_state_local, X2_MAX);
+      ES_GET_STATE(X2_MAX);
     #endif
     #if HAS_Y2_MIN
-      if (READ(Y2_MIN_PIN)) SBI(live_state_local, Y2_MIN);
+      ES_GET_STATE(Y2_MIN);
     #endif
     #if HAS_Y2_MAX
-      if (READ(Y2_MAX_PIN)) SBI(live_state_local, Y2_MAX);
+      ES_GET_STATE(Y2_MAX);
     #endif
     #if HAS_Z2_MIN
-      if (READ(Z2_MIN_PIN)) SBI(live_state_local, Z2_MIN);
+      ES_GET_STATE(Z2_MIN);
     #endif
     #if HAS_Z2_MAX
-      if (READ(Z2_MAX_PIN)) SBI(live_state_local, Z2_MAX);
+      ES_GET_STATE(Z2_MAX);
     #endif
     #if HAS_Z3_MIN
-      if (READ(Z3_MIN_PIN)) SBI(live_state_local, Z3_MIN);
+      ES_GET_STATE(Z3_MIN);
     #endif
     #if HAS_Z3_MAX
-      if (READ(Z3_MAX_PIN)) SBI(live_state_local, Z3_MAX);
+      ES_GET_STATE(Z3_MAX);
     #endif
 
     uint16_t endstop_change = live_state_local ^ old_live_state_local;
+    #define ES_REPORT_CHANGE(S) if (TEST(endstop_change, S)) SERIAL_ECHOPAIR("  " STRINGIFY(S) ":", TEST(live_state_local, S))
 
     if (endstop_change) {
       #if HAS_X_MIN
-        if (TEST(endstop_change, X_MIN)) SERIAL_ECHOPAIR("  X_MIN:", TEST(live_state_local, X_MIN));
+        ES_REPORT_CHANGE(X_MIN);
       #endif
       #if HAS_X_MAX
-        if (TEST(endstop_change, X_MAX)) SERIAL_ECHOPAIR("  X_MAX:", TEST(live_state_local, X_MAX));
+        ES_REPORT_CHANGE(X_MAX);
       #endif
       #if HAS_Y_MIN
-        if (TEST(endstop_change, Y_MIN)) SERIAL_ECHOPAIR("  Y_MIN:", TEST(live_state_local, Y_MIN));
+        ES_REPORT_CHANGE(Y_MIN);
       #endif
       #if HAS_Y_MAX
-        if (TEST(endstop_change, Y_MAX)) SERIAL_ECHOPAIR("  Y_MAX:", TEST(live_state_local, Y_MAX));
+        ES_REPORT_CHANGE(Y_MAX);
       #endif
       #if HAS_Z_MIN
-        if (TEST(endstop_change, Z_MIN)) SERIAL_ECHOPAIR("  Z_MIN:", TEST(live_state_local, Z_MIN));
+        ES_REPORT_CHANGE(Z_MIN);
       #endif
       #if HAS_Z_MAX
-        if (TEST(endstop_change, Z_MAX)) SERIAL_ECHOPAIR("  Z_MAX:", TEST(live_state_local, Z_MAX));
+        ES_REPORT_CHANGE(Z_MAX);
       #endif
       #if HAS_Z_MIN_PROBE_PIN
-        if (TEST(endstop_change, Z_MIN_PROBE)) SERIAL_ECHOPAIR("  PROBE:", TEST(live_state_local, Z_MIN_PROBE));
+        ES_REPORT_CHANGE(Z_MIN_PROBE);
       #endif
       #if HAS_X2_MIN
-        if (TEST(endstop_change, X2_MIN)) SERIAL_ECHOPAIR("  X2_MIN:", TEST(live_state_local, X2_MIN));
+        ES_REPORT_CHANGE(X2_MIN);
       #endif
       #if HAS_X2_MAX
-        if (TEST(endstop_change, X2_MAX)) SERIAL_ECHOPAIR("  X2_MAX:", TEST(live_state_local, X2_MAX));
+        ES_REPORT_CHANGE(X2_MAX);
       #endif
       #if HAS_Y2_MIN
-        if (TEST(endstop_change, Y2_MIN)) SERIAL_ECHOPAIR("  Y2_MIN:", TEST(live_state_local, Y2_MIN));
+        ES_REPORT_CHANGE(Y2_MIN);
       #endif
       #if HAS_Y2_MAX
-        if (TEST(endstop_change, Y2_MAX)) SERIAL_ECHOPAIR("  Y2_MAX:", TEST(live_state_local, Y2_MAX));
+        ES_REPORT_CHANGE(Y2_MAX);
       #endif
       #if HAS_Z2_MIN
-        if (TEST(endstop_change, Z2_MIN)) SERIAL_ECHOPAIR("  Z2_MIN:", TEST(live_state_local, Z2_MIN));
+        ES_REPORT_CHANGE(Z2_MIN);
       #endif
       #if HAS_Z2_MAX
-        if (TEST(endstop_change, Z2_MAX)) SERIAL_ECHOPAIR("  Z2_MAX:", TEST(live_state_local, Z2_MAX));
+        ES_REPORT_CHANGE(Z2_MAX);
       #endif
       #if HAS_Z3_MIN
-        if (TEST(endstop_change, Z3_MIN)) SERIAL_ECHOPAIR("  Z3_MIN:", TEST(live_state_local, Z3_MIN));
+        ES_REPORT_CHANGE(Z3_MIN);
       #endif
       #if HAS_Z3_MAX
-        if (TEST(endstop_change, Z3_MAX)) SERIAL_ECHOPAIR("  Z3_MAX:", TEST(live_state_local, Z3_MAX));
+        ES_REPORT_CHANGE(Z3_MAX);
       #endif
       SERIAL_ECHOPGM("\n\n");
       analogWrite(LED_PIN, local_LED_status);
       local_LED_status ^= 255;
       old_live_state_local = live_state_local;
     }
   }
 
 #endif // PINS_DEBUGGING

commit c98623983774b9773800bc7dcef695c4bad81c0e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Nov 29 16:58:58 2018 -0600

    A single SERIAL_ECHO macro type (#12557)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 988bc21b17..ff5311781c 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -358,27 +358,27 @@ void Endstops::event_handler() {
         thermalManager.disable_all_heaters();
         print_job_timer.stop();
       }
     #endif
   }
   prev_hit_state = hit_state;
 }
 
 static void print_es_state(const bool is_hit, PGM_P const label=NULL) {
   if (label) serialprintPGM(label);
-  SERIAL_PROTOCOLPGM(": ");
+  SERIAL_ECHOPGM(": ");
   serialprintPGM(is_hit ? PSTR(MSG_ENDSTOP_HIT) : PSTR(MSG_ENDSTOP_OPEN));
   SERIAL_EOL();
 }
 
 void _O2 Endstops::M119() {
-  SERIAL_PROTOCOLLNPGM(MSG_M119_REPORT);
+  SERIAL_ECHOLNPGM(MSG_M119_REPORT);
   #define ES_REPORT(S) print_es_state(READ(S##_PIN) != S##_ENDSTOP_INVERTING, PSTR(MSG_##S))
   #if HAS_X_MIN
     ES_REPORT(X_MIN);
   #endif
   #if HAS_X2_MIN
     ES_REPORT(X2_MIN);
   #endif
   #if HAS_X_MAX
     ES_REPORT(X_MAX);
   #endif
@@ -434,21 +434,21 @@ void _O2 Endstops::M119() {
               case 4: pin = FIL_RUNOUT4_PIN; break;
               #if NUM_RUNOUT_SENSORS > 4
                 case 5: pin = FIL_RUNOUT5_PIN; break;
                 #if NUM_RUNOUT_SENSORS > 5
                   case 6: pin = FIL_RUNOUT6_PIN; break;
                 #endif
               #endif
             #endif
           #endif
         }
-        SERIAL_PROTOCOLPGM(MSG_FILAMENT_RUNOUT_SENSOR);
+        SERIAL_ECHOPGM(MSG_FILAMENT_RUNOUT_SENSOR);
         if (i > 1) { SERIAL_CHAR(' '); SERIAL_CHAR('0' + i); }
         print_es_state(digitalRead(pin) != FIL_RUNOUT_INVERTING);
       }
     #endif
   #endif
 } // Endstops::M119
 
 // The following routines are called from an ISR context. It could be the temperature ISR, the
 // endstop ISR or the Stepper ISR.
 
@@ -818,62 +818,62 @@ void Endstops::update() {
       if (READ(Z3_MIN_PIN)) SBI(live_state_local, Z3_MIN);
     #endif
     #if HAS_Z3_MAX
       if (READ(Z3_MAX_PIN)) SBI(live_state_local, Z3_MAX);
     #endif
 
     uint16_t endstop_change = live_state_local ^ old_live_state_local;
 
     if (endstop_change) {
       #if HAS_X_MIN
-        if (TEST(endstop_change, X_MIN)) SERIAL_PROTOCOLPAIR("  X_MIN:", TEST(live_state_local, X_MIN));
+        if (TEST(endstop_change, X_MIN)) SERIAL_ECHOPAIR("  X_MIN:", TEST(live_state_local, X_MIN));
       #endif
       #if HAS_X_MAX
-        if (TEST(endstop_change, X_MAX)) SERIAL_PROTOCOLPAIR("  X_MAX:", TEST(live_state_local, X_MAX));
+        if (TEST(endstop_change, X_MAX)) SERIAL_ECHOPAIR("  X_MAX:", TEST(live_state_local, X_MAX));
       #endif
       #if HAS_Y_MIN
-        if (TEST(endstop_change, Y_MIN)) SERIAL_PROTOCOLPAIR("  Y_MIN:", TEST(live_state_local, Y_MIN));
+        if (TEST(endstop_change, Y_MIN)) SERIAL_ECHOPAIR("  Y_MIN:", TEST(live_state_local, Y_MIN));
       #endif
       #if HAS_Y_MAX
-        if (TEST(endstop_change, Y_MAX)) SERIAL_PROTOCOLPAIR("  Y_MAX:", TEST(live_state_local, Y_MAX));
+        if (TEST(endstop_change, Y_MAX)) SERIAL_ECHOPAIR("  Y_MAX:", TEST(live_state_local, Y_MAX));
       #endif
       #if HAS_Z_MIN
-        if (TEST(endstop_change, Z_MIN)) SERIAL_PROTOCOLPAIR("  Z_MIN:", TEST(live_state_local, Z_MIN));
+        if (TEST(endstop_change, Z_MIN)) SERIAL_ECHOPAIR("  Z_MIN:", TEST(live_state_local, Z_MIN));
       #endif
       #if HAS_Z_MAX
-        if (TEST(endstop_change, Z_MAX)) SERIAL_PROTOCOLPAIR("  Z_MAX:", TEST(live_state_local, Z_MAX));
+        if (TEST(endstop_change, Z_MAX)) SERIAL_ECHOPAIR("  Z_MAX:", TEST(live_state_local, Z_MAX));
       #endif
       #if HAS_Z_MIN_PROBE_PIN
-        if (TEST(endstop_change, Z_MIN_PROBE)) SERIAL_PROTOCOLPAIR("  PROBE:", TEST(live_state_local, Z_MIN_PROBE));
+        if (TEST(endstop_change, Z_MIN_PROBE)) SERIAL_ECHOPAIR("  PROBE:", TEST(live_state_local, Z_MIN_PROBE));
       #endif
       #if HAS_X2_MIN
-        if (TEST(endstop_change, X2_MIN)) SERIAL_PROTOCOLPAIR("  X2_MIN:", TEST(live_state_local, X2_MIN));
+        if (TEST(endstop_change, X2_MIN)) SERIAL_ECHOPAIR("  X2_MIN:", TEST(live_state_local, X2_MIN));
       #endif
       #if HAS_X2_MAX
-        if (TEST(endstop_change, X2_MAX)) SERIAL_PROTOCOLPAIR("  X2_MAX:", TEST(live_state_local, X2_MAX));
+        if (TEST(endstop_change, X2_MAX)) SERIAL_ECHOPAIR("  X2_MAX:", TEST(live_state_local, X2_MAX));
       #endif
       #if HAS_Y2_MIN
-        if (TEST(endstop_change, Y2_MIN)) SERIAL_PROTOCOLPAIR("  Y2_MIN:", TEST(live_state_local, Y2_MIN));
+        if (TEST(endstop_change, Y2_MIN)) SERIAL_ECHOPAIR("  Y2_MIN:", TEST(live_state_local, Y2_MIN));
       #endif
       #if HAS_Y2_MAX
-        if (TEST(endstop_change, Y2_MAX)) SERIAL_PROTOCOLPAIR("  Y2_MAX:", TEST(live_state_local, Y2_MAX));
+        if (TEST(endstop_change, Y2_MAX)) SERIAL_ECHOPAIR("  Y2_MAX:", TEST(live_state_local, Y2_MAX));
       #endif
       #if HAS_Z2_MIN
-        if (TEST(endstop_change, Z2_MIN)) SERIAL_PROTOCOLPAIR("  Z2_MIN:", TEST(live_state_local, Z2_MIN));
+        if (TEST(endstop_change, Z2_MIN)) SERIAL_ECHOPAIR("  Z2_MIN:", TEST(live_state_local, Z2_MIN));
       #endif
       #if HAS_Z2_MAX
-        if (TEST(endstop_change, Z2_MAX)) SERIAL_PROTOCOLPAIR("  Z2_MAX:", TEST(live_state_local, Z2_MAX));
+        if (TEST(endstop_change, Z2_MAX)) SERIAL_ECHOPAIR("  Z2_MAX:", TEST(live_state_local, Z2_MAX));
       #endif
       #if HAS_Z3_MIN
-        if (TEST(endstop_change, Z3_MIN)) SERIAL_PROTOCOLPAIR("  Z3_MIN:", TEST(live_state_local, Z3_MIN));
+        if (TEST(endstop_change, Z3_MIN)) SERIAL_ECHOPAIR("  Z3_MIN:", TEST(live_state_local, Z3_MIN));
       #endif
       #if HAS_Z3_MAX
-        if (TEST(endstop_change, Z3_MAX)) SERIAL_PROTOCOLPAIR("  Z3_MAX:", TEST(live_state_local, Z3_MAX));
+        if (TEST(endstop_change, Z3_MAX)) SERIAL_ECHOPAIR("  Z3_MAX:", TEST(live_state_local, Z3_MAX));
       #endif
-      SERIAL_PROTOCOLPGM("\n\n");
+      SERIAL_ECHOPGM("\n\n");
       analogWrite(LED_PIN, local_LED_status);
       local_LED_status ^= 255;
       old_live_state_local = live_state_local;
     }
   }
 
 #endif // PINS_DEBUGGING

commit 98c2fc4e42eb3f0a1b2a40f2cab785f7a9f59517
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Wed Nov 14 00:10:07 2018 +0100

    Endstops fix followup (#12423)
    
    Followup to #12413

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 221783e211..988bc21b17 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -286,24 +286,24 @@ void Endstops::not_homing() {
   void Endstops::enable_z_probe(const bool onoff) {
     z_probe_enabled = onoff;
     resync();
   }
 #endif
 
 // Get the stable endstop states when enabled
 void Endstops::resync() {
   if (!abort_enabled()) return;     // If endstops/probes are disabled the loop below can hang
 
-  #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE) && !ENDSTOP_NOISE_THRESHOLD
+  #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
     update();
   #else
-    safe_delay(2);  // Wait for Temperature ISR (runs at 1KHz)
+    safe_delay(2);  // Wait for Temperature ISR to run at least once (runs at 1KHz)
   #endif
   #if ENDSTOP_NOISE_THRESHOLD
     while (endstop_poll_count) safe_delay(1);
   #endif
 }
 
 #if ENABLED(PINS_DEBUGGING)
   void Endstops::run_monitor() {
     if (!monitor_flag) return;
     static uint8_t monitor_count = 16;  // offset this check from the others

commit d631267548fdcc8eee3a4d909e0ebc2c0de59d17
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Tue Nov 13 11:31:58 2018 +0100

    Refine endstops fixes (#12413)
    
    When endstops/probe are enabled `ENDSTOP_NOISE_THRESHOLD` calls to `update` are required to properly re-sync endstops/probe status.

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 1e2d805b6e..221783e211 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -35,21 +35,21 @@
 #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
   #include HAL_PATH(../HAL, endstop_interrupts.h)
 #endif
 
 #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED) && ENABLED(SDSUPPORT)
   #include "../module/printcounter.h" // for print_job_timer
 #endif
 
 Endstops endstops;
 
-// public:
+// private:
 
 bool Endstops::enabled, Endstops::enabled_globally; // Initialized by settings.load()
 volatile uint8_t Endstops::hit_state;
 
 Endstops::esbits_t Endstops::live_state = 0;
 
 #if ENDSTOP_NOISE_THRESHOLD
   Endstops::esbits_t Endstops::validated_live_state;
   uint8_t Endstops::endstop_poll_count;
 #endif
@@ -252,53 +252,64 @@ void Endstops::poll() {
 
   #if DISABLED(ENDSTOP_INTERRUPTS_FEATURE)
     update();
   #elif ENDSTOP_NOISE_THRESHOLD
     if (endstop_poll_count) update();
   #endif
 }
 
 void Endstops::enable_globally(const bool onoff) {
   enabled_globally = enabled = onoff;
-
-  update();
+  resync();
 }
 
 // Enable / disable endstop checking
 void Endstops::enable(const bool onoff) {
   enabled = onoff;
-
-  update();
+  resync();
 }
 
 // Disable / Enable endstops based on ENSTOPS_ONLY_FOR_HOMING and global enable
 void Endstops::not_homing() {
   enabled = enabled_globally;
 }
 
 #if ENABLED(VALIDATE_HOMING_ENDSTOPS)
   // If the last move failed to trigger an endstop, call kill
   void Endstops::validate_homing_move() {
     if (trigger_state()) hit_on_purpose();
     else kill(PSTR(MSG_ERR_HOMING_FAILED));
   }
 #endif
 
 // Enable / disable endstop z-probe checking
 #if HAS_BED_PROBE
   void Endstops::enable_z_probe(const bool onoff) {
     z_probe_enabled = onoff;
-
-    update();
+    resync();
   }
 #endif
 
+// Get the stable endstop states when enabled
+void Endstops::resync() {
+  if (!abort_enabled()) return;     // If endstops/probes are disabled the loop below can hang
+
+  #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE) && !ENDSTOP_NOISE_THRESHOLD
+    update();
+  #else
+    safe_delay(2);  // Wait for Temperature ISR (runs at 1KHz)
+  #endif
+  #if ENDSTOP_NOISE_THRESHOLD
+    while (endstop_poll_count) safe_delay(1);
+  #endif
+}
+
 #if ENABLED(PINS_DEBUGGING)
   void Endstops::run_monitor() {
     if (!monitor_flag) return;
     static uint8_t monitor_count = 16;  // offset this check from the others
     monitor_count += _BV(1);            //  15 Hz
     monitor_count &= 0x7F;
     if (!monitor_count) monitor();      // report changes in endstop status
   }
 #endif
 

commit a0c795b097a30eff006c8dff178abf5f1f1907fa
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Nov 11 12:16:24 2018 -0600

    Encapsulate common display code in a singleton (#12395)
    
    * Encapsulate common LCD code in a singleton
    * Depend more UBL code on UBL_DEVEL_DEBUGGING
      - Since most users don't need the debugging on at all times, this helps reduce the default build size for UBL by over 2K, a little closer to fitting on 128K boards.

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 28e0d92f69..1e2d805b6e 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -330,21 +330,21 @@ void Endstops::event_handler() {
     ENDSTOP_HIT_TEST_Y();
     ENDSTOP_HIT_TEST_Z();
 
     #if ENABLED(Z_MIN_PROBE_ENDSTOP)
       #define P_AXIS Z_AXIS
       if (TEST(hit_state, Z_MIN_PROBE)) _ENDSTOP_HIT_ECHO(P, 'P');
     #endif
     SERIAL_EOL();
 
     #if ENABLED(ULTRA_LCD)
-      lcd_status_printf_P(0, PSTR(MSG_LCD_ENDSTOPS " %c %c %c %c"), chrX, chrY, chrZ, chrP);
+      ui.status_printf_P(0, PSTR(MSG_LCD_ENDSTOPS " %c %c %c %c"), chrX, chrY, chrZ, chrP);
     #endif
 
     #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED) && ENABLED(SDSUPPORT)
       if (planner.abort_on_endstop_hit) {
         card.stopSDPrint();
         quickstop_stepper();
         thermalManager.disable_all_heaters();
         print_job_timer.stop();
       }
     #endif

commit fd7fd55662f380c9015789e4af939d4a23894553
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Fri Nov 9 21:58:04 2018 +0100

    Solve endstops issues (#12382)
    
    - Partially reverts #11900 and tries to solve #12336

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index e3324d0c19..28e0d92f69 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -253,65 +253,49 @@ void Endstops::poll() {
   #if DISABLED(ENDSTOP_INTERRUPTS_FEATURE)
     update();
   #elif ENDSTOP_NOISE_THRESHOLD
     if (endstop_poll_count) update();
   #endif
 }
 
 void Endstops::enable_globally(const bool onoff) {
   enabled_globally = enabled = onoff;
 
-  #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-    update();
-  #endif
+  update();
 }
 
 // Enable / disable endstop checking
 void Endstops::enable(const bool onoff) {
   enabled = onoff;
 
-  #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-    update();
-  #endif
+  update();
 }
 
 // Disable / Enable endstops based on ENSTOPS_ONLY_FOR_HOMING and global enable
 void Endstops::not_homing() {
   enabled = enabled_globally;
-
-  // Still 'enabled'? Then endstops are always on and kept in sync.
-  // Otherwise reset 'live's variables to let axes move in both directions.
-  if (!enabled) {
-    #if ENDSTOP_NOISE_THRESHOLD
-      endstop_poll_count = 0;   // Stop filtering (MUST be done first to prevent race condition)
-      validated_live_state = 0;
-    #endif
-    live_state = 0;
-  }
 }
 
 #if ENABLED(VALIDATE_HOMING_ENDSTOPS)
   // If the last move failed to trigger an endstop, call kill
   void Endstops::validate_homing_move() {
     if (trigger_state()) hit_on_purpose();
     else kill(PSTR(MSG_ERR_HOMING_FAILED));
   }
 #endif
 
 // Enable / disable endstop z-probe checking
 #if HAS_BED_PROBE
   void Endstops::enable_z_probe(const bool onoff) {
     z_probe_enabled = onoff;
 
-    #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-      update();
-    #endif
+    update();
   }
 #endif
 
 #if ENABLED(PINS_DEBUGGING)
   void Endstops::run_monitor() {
     if (!monitor_flag) return;
     static uint8_t monitor_count = 16;  // offset this check from the others
     monitor_count += _BV(1);            //  15 Hz
     monitor_count &= 0x7F;
     if (!monitor_count) monitor();      // report changes in endstop status

commit 4f72e041f21a5f595209ebc90dc466d910852ecc
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Nov 6 20:53:07 2018 -0600

    Use card.stopSDPrint() for completeness

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 102ba3744b..e3324d0c19 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -351,22 +351,21 @@ void Endstops::event_handler() {
       if (TEST(hit_state, Z_MIN_PROBE)) _ENDSTOP_HIT_ECHO(P, 'P');
     #endif
     SERIAL_EOL();
 
     #if ENABLED(ULTRA_LCD)
       lcd_status_printf_P(0, PSTR(MSG_LCD_ENDSTOPS " %c %c %c %c"), chrX, chrY, chrZ, chrP);
     #endif
 
     #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED) && ENABLED(SDSUPPORT)
       if (planner.abort_on_endstop_hit) {
-        card.sdprinting = false;
-        card.closefile();
+        card.stopSDPrint();
         quickstop_stepper();
         thermalManager.disable_all_heaters();
         print_job_timer.stop();
       }
     #endif
   }
   prev_hit_state = hit_state;
 }
 
 static void print_es_state(const bool is_hit, PGM_P const label=NULL) {

commit b7ca93ba37d8236cd4523b6f61120e6b9c6d0f08
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Nov 4 06:07:17 2018 -0600

    Remove dead comment

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 7049edb07c..102ba3744b 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -360,21 +360,21 @@ void Endstops::event_handler() {
       if (planner.abort_on_endstop_hit) {
         card.sdprinting = false;
         card.closefile();
         quickstop_stepper();
         thermalManager.disable_all_heaters();
         print_job_timer.stop();
       }
     #endif
   }
   prev_hit_state = hit_state;
-} // Endstops::report_state
+}
 
 static void print_es_state(const bool is_hit, PGM_P const label=NULL) {
   if (label) serialprintPGM(label);
   SERIAL_PROTOCOLPGM(": ");
   serialprintPGM(is_hit ? PSTR(MSG_ENDSTOP_HIT) : PSTR(MSG_ENDSTOP_OPEN));
   SERIAL_EOL();
 }
 
 void _O2 Endstops::M119() {
   SERIAL_PROTOCOLLNPGM(MSG_M119_REPORT);

commit aa9202260dcf1add950afdb05942f3c0e89d9af4
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Fri Oct 19 20:45:39 2018 +0200

    Fix endstop when no interrupt (#12158)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 3ac7aef31a..7049edb07c 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -271,31 +271,29 @@ void Endstops::enable(const bool onoff) {
 
   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
     update();
   #endif
 }
 
 // Disable / Enable endstops based on ENSTOPS_ONLY_FOR_HOMING and global enable
 void Endstops::not_homing() {
   enabled = enabled_globally;
 
-  #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-    // Still 'enabled'? Then endstops are always on and kept in sync.
-    // Otherwise reset 'live's variables to let axes move in both directions.
-    if (!enabled) {
-      #if ENDSTOP_NOISE_THRESHOLD
-        endstop_poll_count = 0;   // Stop filtering (MUST be done first to prevent race condition)
-        validated_live_state = 0;
-      #endif
-      live_state = 0;
-    }
-  #endif
+  // Still 'enabled'? Then endstops are always on and kept in sync.
+  // Otherwise reset 'live's variables to let axes move in both directions.
+  if (!enabled) {
+    #if ENDSTOP_NOISE_THRESHOLD
+      endstop_poll_count = 0;   // Stop filtering (MUST be done first to prevent race condition)
+      validated_live_state = 0;
+    #endif
+    live_state = 0;
+  }
 }
 
 #if ENABLED(VALIDATE_HOMING_ENDSTOPS)
   // If the last move failed to trigger an endstop, call kill
   void Endstops::validate_homing_move() {
     if (trigger_state()) hit_on_purpose();
     else kill(PSTR(MSG_ERR_HOMING_FAILED));
   }
 #endif
 

commit 71e19baf691a5252841cca5871a29d7a65b62e5f
Author: Marcio Teixeira <marcio@alephobjects.com>
Date:   Thu Oct 18 20:20:56 2018 -0600

    Fix kill => disable_all_heaters => print_job_timer.stop (#12146)
    
    - Remove `print_job_timer.stop()` from `disable_all_heaters`
    - Call `print_job_timer.stop()` for relevant `disable_all_heaters()`.
    - Split up `kill()` for watchdog interrupt safety

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 0430abb268..3ac7aef31a 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -29,20 +29,24 @@
 
 #include "../Marlin.h"
 #include "../sd/cardreader.h"
 #include "../module/temperature.h"
 #include "../lcd/ultralcd.h"
 
 #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
   #include HAL_PATH(../HAL, endstop_interrupts.h)
 #endif
 
+#if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED) && ENABLED(SDSUPPORT)
+  #include "../module/printcounter.h" // for print_job_timer
+#endif
+
 Endstops endstops;
 
 // public:
 
 bool Endstops::enabled, Endstops::enabled_globally; // Initialized by settings.load()
 volatile uint8_t Endstops::hit_state;
 
 Endstops::esbits_t Endstops::live_state = 0;
 
 #if ENDSTOP_NOISE_THRESHOLD
@@ -352,21 +356,22 @@ void Endstops::event_handler() {
 
     #if ENABLED(ULTRA_LCD)
       lcd_status_printf_P(0, PSTR(MSG_LCD_ENDSTOPS " %c %c %c %c"), chrX, chrY, chrZ, chrP);
     #endif
 
     #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED) && ENABLED(SDSUPPORT)
       if (planner.abort_on_endstop_hit) {
         card.sdprinting = false;
         card.closefile();
         quickstop_stepper();
-        thermalManager.disable_all_heaters(); // switch off all heaters.
+        thermalManager.disable_all_heaters();
+        print_job_timer.stop();
       }
     #endif
   }
   prev_hit_state = hit_state;
 } // Endstops::report_state
 
 static void print_es_state(const bool is_hit, PGM_P const label=NULL) {
   if (label) serialprintPGM(label);
   SERIAL_PROTOCOLPGM(": ");
   serialprintPGM(is_hit ? PSTR(MSG_ENDSTOP_HIT) : PSTR(MSG_ENDSTOP_OPEN));

commit 11ac75edcb34a2f90b50ca134ff40839f8c29199
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 30 23:44:33 2018 -0500

    Use PGM_P for PSTR pointers (#11977)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 38f0aae0bf..0430abb268 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -359,21 +359,21 @@ void Endstops::event_handler() {
         card.sdprinting = false;
         card.closefile();
         quickstop_stepper();
         thermalManager.disable_all_heaters(); // switch off all heaters.
       }
     #endif
   }
   prev_hit_state = hit_state;
 } // Endstops::report_state
 
-static void print_es_state(const bool is_hit, const char * const label=NULL) {
+static void print_es_state(const bool is_hit, PGM_P const label=NULL) {
   if (label) serialprintPGM(label);
   SERIAL_PROTOCOLPGM(": ");
   serialprintPGM(is_hit ? PSTR(MSG_ENDSTOP_HIT) : PSTR(MSG_ENDSTOP_OPEN));
   SERIAL_EOL();
 }
 
 void _O2 Endstops::M119() {
   SERIAL_PROTOCOLLNPGM(MSG_M119_REPORT);
   #define ES_REPORT(S) print_es_state(READ(S##_PIN) != S##_ENDSTOP_INVERTING, PSTR(MSG_##S))
   #if HAS_X_MIN

commit 23114aeb8114ae3e58e5710eca07cd5201642b9a
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Fri Sep 28 20:00:11 2018 -0400

    Fix garbled M119 output. Honor NUM_RUNOUT_SENSORS (#11948)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index a7e2a57d6e..38f0aae0bf 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -415,56 +415,40 @@ void _O2 Endstops::M119() {
   #if HAS_Z2_MAX
     ES_REPORT(Z2_MAX);
   #endif
   #if HAS_Z3_MAX
     ES_REPORT(Z3_MAX);
   #endif
   #if ENABLED(Z_MIN_PROBE_ENDSTOP)
     print_es_state(READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING, PSTR(MSG_Z_PROBE));
   #endif
   #if ENABLED(FILAMENT_RUNOUT_SENSOR)
-    #define FRS_COUNT (1 + PIN_EXISTS(FIL_RUNOUT2) + PIN_EXISTS(FIL_RUNOUT3) + PIN_EXISTS(FIL_RUNOUT4) + PIN_EXISTS(FIL_RUNOUT5) + PIN_EXISTS(FIL_RUNOUT6))
-    #if FRS_COUNT == 1
-      print_es_state(READ(FIL_RUNOUT_PIN) != FIL_RUNOUT_INVERTING, MSG_FILAMENT_RUNOUT_SENSOR);
+    #if NUM_RUNOUT_SENSORS == 1
+      print_es_state(READ(FIL_RUNOUT_PIN) != FIL_RUNOUT_INVERTING, PSTR(MSG_FILAMENT_RUNOUT_SENSOR));
     #else
-      for (uint8_t i = 1; i <=
-        #if   FRS_COUNT == 6
-          6
-        #elif FRS_COUNT == 5
-          5
-        #elif FRS_COUNT == 4
-          4
-        #elif FRS_COUNT == 3
-          3
-        #elif FRS_COUNT == 2
-          2
-        #endif
-        ; i++
-      ) {
+      for (uint8_t i = 1; i <= NUM_RUNOUT_SENSORS; i++) {
         pin_t pin;
         switch (i) {
           default: continue;
           case 1: pin = FIL_RUNOUT_PIN; break;
-          #if PIN_EXISTS(FIL_RUNOUT2)
-            case 2: pin = FIL_RUNOUT2_PIN; break;
-          #endif
-          #if PIN_EXISTS(FIL_RUNOUT3)
+          case 2: pin = FIL_RUNOUT2_PIN; break;
+          #if NUM_RUNOUT_SENSORS > 2
             case 3: pin = FIL_RUNOUT3_PIN; break;
-          #endif
-          #if PIN_EXISTS(FIL_RUNOUT4)
-            case 4: pin = FIL_RUNOUT4_PIN; break;
-          #endif
-          #if PIN_EXISTS(FIL_RUNOUT5)
-            case 5: pin = FIL_RUNOUT5_PIN; break;
-          #endif
-          #if PIN_EXISTS(FIL_RUNOUT6)
-            case 6: pin = FIL_RUNOUT6_PIN; break;
+            #if NUM_RUNOUT_SENSORS > 3
+              case 4: pin = FIL_RUNOUT4_PIN; break;
+              #if NUM_RUNOUT_SENSORS > 4
+                case 5: pin = FIL_RUNOUT5_PIN; break;
+                #if NUM_RUNOUT_SENSORS > 5
+                  case 6: pin = FIL_RUNOUT6_PIN; break;
+                #endif
+              #endif
+            #endif
           #endif
         }
         SERIAL_PROTOCOLPGM(MSG_FILAMENT_RUNOUT_SENSOR);
         if (i > 1) { SERIAL_CHAR(' '); SERIAL_CHAR('0' + i); }
         print_es_state(digitalRead(pin) != FIL_RUNOUT_INVERTING);
       }
     #endif
   #endif
 } // Endstops::M119
 

commit dc1113165601db4675036f52267f8489464107a1
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Tue Sep 25 19:56:57 2018 +0200

    [2.0.x] fix possible race condition (#11923)
    
    Fix some commits done in #11900

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index fb7a36ecb5..a7e2a57d6e 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -272,26 +272,25 @@ void Endstops::enable(const bool onoff) {
 
 // Disable / Enable endstops based on ENSTOPS_ONLY_FOR_HOMING and global enable
 void Endstops::not_homing() {
   enabled = enabled_globally;
 
   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
     // Still 'enabled'? Then endstops are always on and kept in sync.
     // Otherwise reset 'live's variables to let axes move in both directions.
     if (!enabled) {
       #if ENDSTOP_NOISE_THRESHOLD
-        endstop_poll_count = validated_live_state = 0; // Stop filtering
+        endstop_poll_count = 0;   // Stop filtering (MUST be done first to prevent race condition)
+        validated_live_state = 0;
       #endif
       live_state = 0;
     }
-  //#else
-    // When in polling endstops are always kept in sync
   #endif
 }
 
 #if ENABLED(VALIDATE_HOMING_ENDSTOPS)
   // If the last move failed to trigger an endstop, call kill
   void Endstops::validate_homing_move() {
     if (trigger_state()) hit_on_purpose();
     else kill(PSTR(MSG_ERR_HOMING_FAILED));
   }
 #endif

commit d6b9327c1119507a7369a72bc322bc6df2730fe9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Sep 25 13:50:49 2018 -0400

    Followup for Endstop Noise Threshold
    
    Followup to #11912

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 93a0001ab8..fb7a36ecb5 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -241,21 +241,21 @@ void Endstops::init() {
 
 // Called at ~1KHz from Temperature ISR: Poll endstop state if required
 void Endstops::poll() {
 
   #if ENABLED(PINS_DEBUGGING)
     run_monitor();  // report changes in endstop status
   #endif
 
   #if DISABLED(ENDSTOP_INTERRUPTS_FEATURE)
     update();
-  #elif ENABLED(ENDSTOP_NOISE_FILTER)
+  #elif ENDSTOP_NOISE_THRESHOLD
     if (endstop_poll_count) update();
   #endif
 }
 
 void Endstops::enable_globally(const bool onoff) {
   enabled_globally = enabled = onoff;
 
   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
     update();
   #endif
@@ -271,21 +271,21 @@ void Endstops::enable(const bool onoff) {
 }
 
 // Disable / Enable endstops based on ENSTOPS_ONLY_FOR_HOMING and global enable
 void Endstops::not_homing() {
   enabled = enabled_globally;
 
   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
     // Still 'enabled'? Then endstops are always on and kept in sync.
     // Otherwise reset 'live's variables to let axes move in both directions.
     if (!enabled) {
-      #if ENABLED(ENDSTOP_NOISE_FILTER)
+      #if ENDSTOP_NOISE_THRESHOLD
         endstop_poll_count = validated_live_state = 0; // Stop filtering
       #endif
       live_state = 0;
     }
   //#else
     // When in polling endstops are always kept in sync
   #endif
 }
 
 #if ENABLED(VALIDATE_HOMING_ENDSTOPS)

commit 5490a664f51c3466fc171492a7016d21876ab33a
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 24 21:59:12 2018 -0400

    Expose: Homing Validation and Endstop Noise Threshold (#11912)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index dbef281f08..93a0001ab8 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -38,21 +38,21 @@
 
 Endstops endstops;
 
 // public:
 
 bool Endstops::enabled, Endstops::enabled_globally; // Initialized by settings.load()
 volatile uint8_t Endstops::hit_state;
 
 Endstops::esbits_t Endstops::live_state = 0;
 
-#if ENABLED(ENDSTOP_NOISE_FILTER)
+#if ENDSTOP_NOISE_THRESHOLD
   Endstops::esbits_t Endstops::validated_live_state;
   uint8_t Endstops::endstop_poll_count;
 #endif
 
 #if HAS_BED_PROBE
   volatile bool Endstops::z_probe_enabled = false;
 #endif
 
 // Initialized by settings.load()
 #if ENABLED(X_DUAL_ENDSTOPS)
@@ -472,21 +472,21 @@ void _O2 Endstops::M119() {
 // The following routines are called from an ISR context. It could be the temperature ISR, the
 // endstop ISR or the Stepper ISR.
 
 #define _ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
 #define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN
 #define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_INVERTING
 
 // Check endstops - Could be called from Temperature ISR!
 void Endstops::update() {
 
-  #if DISABLED(ENDSTOP_NOISE_FILTER)
+  #if !ENDSTOP_NOISE_THRESHOLD
     if (!abort_enabled()) return;
   #endif
 
   #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT_TO(live_state, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
   #define COPY_LIVE_STATE(SRC_BIT, DST_BIT) SET_BIT_TO(live_state, DST_BIT, TEST(live_state, SRC_BIT))
 
   #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && !(CORE_IS_XY || CORE_IS_XZ)
     // If G38 command is active check Z_MIN_PROBE for ALL movement
     if (G38_move) UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
   #endif
@@ -615,34 +615,35 @@ void Endstops::update() {
         #else
           COPY_LIVE_STATE(Z_MAX, Z3_MAX);
         #endif
       #endif
     #elif DISABLED(Z_MIN_PROBE_ENDSTOP) || Z_MAX_PIN != Z_MIN_PROBE_PIN
       // If this pin isn't the bed probe it's the Z endstop
       UPDATE_ENDSTOP_BIT(Z, MAX);
     #endif
   #endif
 
-  #if ENABLED(ENDSTOP_NOISE_FILTER)
+  #if ENDSTOP_NOISE_THRESHOLD
+
     /**
      * Filtering out noise on endstops requires a delayed decision. Let's assume, due to noise,
      * that 50% of endstop signal samples are good and 50% are bad (assuming normal distribution
      * of random noise). Then the first sample has a 50% chance to be good or bad. The 2nd sample
      * also has a 50% chance to be good or bad. The chances of 2 samples both being bad becomes
      * 50% of 50%, or 25%. That was the previous implementation of Marlin endstop handling. It
      * reduces chances of bad readings in half, at the cost of 1 extra sample period, but chances
      * still exist. The only way to reduce them further is to increase the number of samples.
      * To reduce the chance to 1% (1/128th) requires 7 samples (adding 7ms of delay).
      */
     static esbits_t old_live_state;
     if (old_live_state != live_state) {
-      endstop_poll_count = 7;
+      endstop_poll_count = ENDSTOP_NOISE_THRESHOLD;
       old_live_state = live_state;
     }
     else if (endstop_poll_count && !--endstop_poll_count)
       validated_live_state = live_state;
 
     if (!abort_enabled()) return;
 
   #endif
 
   // Test the current status of an endstop

commit 18e456d38d8625ac13970fbfc4e6bdbb8adefc28
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Mon Sep 24 22:56:01 2018 +0200

    [2.0.x] fix home endstop bug (DON'T MERGE, needs discussion) (#11900)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index f8f6db3d38..dbef281f08 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -239,24 +239,24 @@ void Endstops::init() {
 
 } // Endstops::init
 
 // Called at ~1KHz from Temperature ISR: Poll endstop state if required
 void Endstops::poll() {
 
   #if ENABLED(PINS_DEBUGGING)
     run_monitor();  // report changes in endstop status
   #endif
 
-  #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE) && ENABLED(ENDSTOP_NOISE_FILTER)
-    if (endstop_poll_count) update();
-  #elif DISABLED(ENDSTOP_INTERRUPTS_FEATURE) || ENABLED(ENDSTOP_NOISE_FILTER)
+  #if DISABLED(ENDSTOP_INTERRUPTS_FEATURE)
     update();
+  #elif ENABLED(ENDSTOP_NOISE_FILTER)
+    if (endstop_poll_count) update();
   #endif
 }
 
 void Endstops::enable_globally(const bool onoff) {
   enabled_globally = enabled = onoff;
 
   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
     update();
   #endif
 }
@@ -268,21 +268,30 @@ void Endstops::enable(const bool onoff) {
   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
     update();
   #endif
 }
 
 // Disable / Enable endstops based on ENSTOPS_ONLY_FOR_HOMING and global enable
 void Endstops::not_homing() {
   enabled = enabled_globally;
 
   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-    update();
+    // Still 'enabled'? Then endstops are always on and kept in sync.
+    // Otherwise reset 'live's variables to let axes move in both directions.
+    if (!enabled) {
+      #if ENABLED(ENDSTOP_NOISE_FILTER)
+        endstop_poll_count = validated_live_state = 0; // Stop filtering
+      #endif
+      live_state = 0;
+    }
+  //#else
+    // When in polling endstops are always kept in sync
   #endif
 }
 
 #if ENABLED(VALIDATE_HOMING_ENDSTOPS)
   // If the last move failed to trigger an endstop, call kill
   void Endstops::validate_homing_move() {
     if (trigger_state()) hit_on_purpose();
     else kill(PSTR(MSG_ERR_HOMING_FAILED));
   }
 #endif
@@ -659,21 +668,21 @@ void Endstops::update() {
       if (!stepper.separate_multi_axis || dual_hit == 0b11) \
         planner.endstop_triggered(_AXIS(AXIS1)); \
     } \
   }while(0)
 
   #define PROCESS_TRIPLE_ENDSTOP(AXIS1, AXIS2, AXIS3, MINMAX) do { \
     const byte triple_hit = TEST_ENDSTOP(_ENDSTOP(AXIS1, MINMAX)) | (TEST_ENDSTOP(_ENDSTOP(AXIS2, MINMAX)) << 1) | (TEST_ENDSTOP(_ENDSTOP(AXIS3, MINMAX)) << 2); \
     if (triple_hit) { \
       _ENDSTOP_HIT(AXIS1, MINMAX); \
       /* if not performing home or if both endstops were trigged during homing... */ \
-      if (!stepper.separate_multi_axis || triple_hit == 0x7) \
+      if (!stepper.separate_multi_axis || triple_hit == 0b111) \
         planner.endstop_triggered(_AXIS(AXIS1)); \
     } \
   }while(0)
 
   #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && !(CORE_IS_XY || CORE_IS_XZ)
     // If G38 command is active check Z_MIN_PROBE for ALL movement
     if (G38_move) {
       if (TEST_ENDSTOP(_ENDSTOP(Z, MIN_PROBE))) {
         if      (stepper.axis_is_moving(X_AXIS)) { _ENDSTOP_HIT(X, MIN); planner.endstop_triggered(X_AXIS); }
         else if (stepper.axis_is_moving(Y_AXIS)) { _ENDSTOP_HIT(Y, MIN); planner.endstop_triggered(Y_AXIS); }

commit 4163c1a5140c3ef04af1f16e7aa0989893cdffce
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Fri Sep 21 16:45:12 2018 -0500

    Fix end stop and Z-probe reporting logic

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 6801c27098..f8f6db3d38 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -360,21 +360,21 @@ void Endstops::event_handler() {
 
 static void print_es_state(const bool is_hit, const char * const label=NULL) {
   if (label) serialprintPGM(label);
   SERIAL_PROTOCOLPGM(": ");
   serialprintPGM(is_hit ? PSTR(MSG_ENDSTOP_HIT) : PSTR(MSG_ENDSTOP_OPEN));
   SERIAL_EOL();
 }
 
 void _O2 Endstops::M119() {
   SERIAL_PROTOCOLLNPGM(MSG_M119_REPORT);
-  #define ES_REPORT(S) print_es_state(READ(S##_PIN) == S##_ENDSTOP_INVERTING, PSTR(MSG_##S))
+  #define ES_REPORT(S) print_es_state(READ(S##_PIN) != S##_ENDSTOP_INVERTING, PSTR(MSG_##S))
   #if HAS_X_MIN
     ES_REPORT(X_MIN);
   #endif
   #if HAS_X2_MIN
     ES_REPORT(X2_MIN);
   #endif
   #if HAS_X_MAX
     ES_REPORT(X_MAX);
   #endif
   #if HAS_X2_MAX
@@ -404,26 +404,26 @@ void _O2 Endstops::M119() {
   #if HAS_Z_MAX
     ES_REPORT(Z_MAX);
   #endif
   #if HAS_Z2_MAX
     ES_REPORT(Z2_MAX);
   #endif
   #if HAS_Z3_MAX
     ES_REPORT(Z3_MAX);
   #endif
   #if ENABLED(Z_MIN_PROBE_ENDSTOP)
-    print_es_state(READ(Z_MIN_PROBE_PIN) == Z_MIN_PROBE_ENDSTOP_INVERTING, PSTR(MSG_Z_PROBE));
+    print_es_state(READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING, PSTR(MSG_Z_PROBE));
   #endif
   #if ENABLED(FILAMENT_RUNOUT_SENSOR)
     #define FRS_COUNT (1 + PIN_EXISTS(FIL_RUNOUT2) + PIN_EXISTS(FIL_RUNOUT3) + PIN_EXISTS(FIL_RUNOUT4) + PIN_EXISTS(FIL_RUNOUT5) + PIN_EXISTS(FIL_RUNOUT6))
     #if FRS_COUNT == 1
-      print_es_state(READ(FIL_RUNOUT_PIN) == FIL_RUNOUT_INVERTING, MSG_FILAMENT_RUNOUT_SENSOR);
+      print_es_state(READ(FIL_RUNOUT_PIN) != FIL_RUNOUT_INVERTING, MSG_FILAMENT_RUNOUT_SENSOR);
     #else
       for (uint8_t i = 1; i <=
         #if   FRS_COUNT == 6
           6
         #elif FRS_COUNT == 5
           5
         #elif FRS_COUNT == 4
           4
         #elif FRS_COUNT == 3
           3
@@ -447,21 +447,21 @@ void _O2 Endstops::M119() {
           #endif
           #if PIN_EXISTS(FIL_RUNOUT5)
             case 5: pin = FIL_RUNOUT5_PIN; break;
           #endif
           #if PIN_EXISTS(FIL_RUNOUT6)
             case 6: pin = FIL_RUNOUT6_PIN; break;
           #endif
         }
         SERIAL_PROTOCOLPGM(MSG_FILAMENT_RUNOUT_SENSOR);
         if (i > 1) { SERIAL_CHAR(' '); SERIAL_CHAR('0' + i); }
-        print_es_state(digitalRead(pin) == FIL_RUNOUT_INVERTING);
+        print_es_state(digitalRead(pin) != FIL_RUNOUT_INVERTING);
       }
     #endif
   #endif
 } // Endstops::M119
 
 // The following routines are called from an ISR context. It could be the temperature ISR, the
 // endstop ISR or the Stepper ISR.
 
 #define _ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
 #define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN

commit 09a2bee8aaafb8b5a4aa45398e55f0689254f9d6
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 17 03:27:13 2018 -0500

    Support more filament runout sensors in M119 (#11851)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 7b76ea3b30..6801c27098 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -351,26 +351,30 @@ void Endstops::event_handler() {
         card.sdprinting = false;
         card.closefile();
         quickstop_stepper();
         thermalManager.disable_all_heaters(); // switch off all heaters.
       }
     #endif
   }
   prev_hit_state = hit_state;
 } // Endstops::report_state
 
-void Endstops::M119() {
+static void print_es_state(const bool is_hit, const char * const label=NULL) {
+  if (label) serialprintPGM(label);
+  SERIAL_PROTOCOLPGM(": ");
+  serialprintPGM(is_hit ? PSTR(MSG_ENDSTOP_HIT) : PSTR(MSG_ENDSTOP_OPEN));
+  SERIAL_EOL();
+}
+
+void _O2 Endstops::M119() {
   SERIAL_PROTOCOLLNPGM(MSG_M119_REPORT);
-  #define ES_REPORT(AXIS) do{ \
-    SERIAL_PROTOCOLPGM(MSG_##AXIS); \
-    SERIAL_PROTOCOLLN(((READ(AXIS##_PIN)^AXIS##_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN)); \
-  }while(0)
+  #define ES_REPORT(S) print_es_state(READ(S##_PIN) == S##_ENDSTOP_INVERTING, PSTR(MSG_##S))
   #if HAS_X_MIN
     ES_REPORT(X_MIN);
   #endif
   #if HAS_X2_MIN
     ES_REPORT(X2_MIN);
   #endif
   #if HAS_X_MAX
     ES_REPORT(X_MAX);
   #endif
   #if HAS_X2_MAX
@@ -400,26 +404,66 @@ void Endstops::M119() {
   #if HAS_Z_MAX
     ES_REPORT(Z_MAX);
   #endif
   #if HAS_Z2_MAX
     ES_REPORT(Z2_MAX);
   #endif
   #if HAS_Z3_MAX
     ES_REPORT(Z3_MAX);
   #endif
   #if ENABLED(Z_MIN_PROBE_ENDSTOP)
-    SERIAL_PROTOCOLPGM(MSG_Z_PROBE);
-    SERIAL_PROTOCOLLN(((READ(Z_MIN_PROBE_PIN)^Z_MIN_PROBE_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
+    print_es_state(READ(Z_MIN_PROBE_PIN) == Z_MIN_PROBE_ENDSTOP_INVERTING, PSTR(MSG_Z_PROBE));
   #endif
   #if ENABLED(FILAMENT_RUNOUT_SENSOR)
-    SERIAL_PROTOCOLPGM(MSG_FILAMENT_RUNOUT_SENSOR);
-    SERIAL_PROTOCOLLN(((READ(FIL_RUNOUT_PIN)^FIL_RUNOUT_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
+    #define FRS_COUNT (1 + PIN_EXISTS(FIL_RUNOUT2) + PIN_EXISTS(FIL_RUNOUT3) + PIN_EXISTS(FIL_RUNOUT4) + PIN_EXISTS(FIL_RUNOUT5) + PIN_EXISTS(FIL_RUNOUT6))
+    #if FRS_COUNT == 1
+      print_es_state(READ(FIL_RUNOUT_PIN) == FIL_RUNOUT_INVERTING, MSG_FILAMENT_RUNOUT_SENSOR);
+    #else
+      for (uint8_t i = 1; i <=
+        #if   FRS_COUNT == 6
+          6
+        #elif FRS_COUNT == 5
+          5
+        #elif FRS_COUNT == 4
+          4
+        #elif FRS_COUNT == 3
+          3
+        #elif FRS_COUNT == 2
+          2
+        #endif
+        ; i++
+      ) {
+        pin_t pin;
+        switch (i) {
+          default: continue;
+          case 1: pin = FIL_RUNOUT_PIN; break;
+          #if PIN_EXISTS(FIL_RUNOUT2)
+            case 2: pin = FIL_RUNOUT2_PIN; break;
+          #endif
+          #if PIN_EXISTS(FIL_RUNOUT3)
+            case 3: pin = FIL_RUNOUT3_PIN; break;
+          #endif
+          #if PIN_EXISTS(FIL_RUNOUT4)
+            case 4: pin = FIL_RUNOUT4_PIN; break;
+          #endif
+          #if PIN_EXISTS(FIL_RUNOUT5)
+            case 5: pin = FIL_RUNOUT5_PIN; break;
+          #endif
+          #if PIN_EXISTS(FIL_RUNOUT6)
+            case 6: pin = FIL_RUNOUT6_PIN; break;
+          #endif
+        }
+        SERIAL_PROTOCOLPGM(MSG_FILAMENT_RUNOUT_SENSOR);
+        if (i > 1) { SERIAL_CHAR(' '); SERIAL_CHAR('0' + i); }
+        print_es_state(digitalRead(pin) == FIL_RUNOUT_INVERTING);
+      }
+    #endif
   #endif
 } // Endstops::M119
 
 // The following routines are called from an ISR context. It could be the temperature ISR, the
 // endstop ISR or the Stepper ISR.
 
 #define _ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
 #define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN
 #define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_INVERTING
 

commit 1a6f2b29b8dd3bc8e6ef56d4f376f49cacfc8785
Author: Holger MuÃàller <holger@mueller-gelff.de>
Date:   Tue Jun 19 18:55:49 2018 +0200

    Add support for Triple-Z steppers/endstops

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 68886eb84f..7b76ea3b30 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -49,27 +49,30 @@ Endstops::esbits_t Endstops::live_state = 0;
   Endstops::esbits_t Endstops::validated_live_state;
   uint8_t Endstops::endstop_poll_count;
 #endif
 
 #if HAS_BED_PROBE
   volatile bool Endstops::z_probe_enabled = false;
 #endif
 
 // Initialized by settings.load()
 #if ENABLED(X_DUAL_ENDSTOPS)
-  float Endstops::x_endstop_adj;
+  float Endstops::x2_endstop_adj;
 #endif
 #if ENABLED(Y_DUAL_ENDSTOPS)
-  float Endstops::y_endstop_adj;
+  float Endstops::y2_endstop_adj;
 #endif
-#if ENABLED(Z_DUAL_ENDSTOPS)
-  float Endstops::z_endstop_adj;
+#if Z_MULTI_ENDSTOPS
+  float Endstops::z2_endstop_adj;
+#endif
+#if ENABLED(Z_TRIPLE_ENDSTOPS)
+  float Endstops::z3_endstop_adj;
 #endif
 
 /**
  * Class and Instance Methods
  */
 
 void Endstops::init() {
 
   #if HAS_X_MIN
     #if ENABLED(ENDSTOPPULLUP_XMIN)
@@ -124,20 +127,30 @@ void Endstops::init() {
   #if HAS_Z2_MIN
     #if ENABLED(ENDSTOPPULLUP_ZMIN)
       SET_INPUT_PULLUP(Z2_MIN_PIN);
     #elif ENABLED(ENDSTOPPULLDOWN_ZMIN)
       SET_INPUT_PULLDOWN(Z2_MIN_PIN);
     #else
       SET_INPUT(Z2_MIN_PIN);
     #endif
   #endif
 
+  #if HAS_Z3_MIN
+    #if ENABLED(ENDSTOPPULLUP_ZMIN)
+      SET_INPUT_PULLUP(Z3_MIN_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_ZMIN)
+      SET_INPUT_PULLDOWN(Z3_MIN_PIN);
+    #else
+      SET_INPUT(Z3_MIN_PIN);
+    #endif
+  #endif
+
   #if HAS_X_MAX
     #if ENABLED(ENDSTOPPULLUP_XMAX)
       SET_INPUT_PULLUP(X_MAX_PIN);
     #elif ENABLED(ENDSTOPPULLDOWN_XMAX)
       SET_INPUT_PULLDOWN(X_MAX_PIN);
     #else
       SET_INPUT(X_MAX_PIN);
     #endif
   #endif
 
@@ -184,20 +197,30 @@ void Endstops::init() {
   #if HAS_Z2_MAX
     #if ENABLED(ENDSTOPPULLUP_ZMAX)
       SET_INPUT_PULLUP(Z2_MAX_PIN);
     #elif ENABLED(ENDSTOPPULLDOWN_ZMAX)
       SET_INPUT_PULLDOWN(Z2_MAX_PIN);
     #else
       SET_INPUT(Z2_MAX_PIN);
     #endif
   #endif
 
+  #if HAS_Z3_MAX
+    #if ENABLED(ENDSTOPPULLUP_ZMAX)
+      SET_INPUT_PULLUP(Z3_MAX_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_ZMAX)
+      SET_INPUT_PULLDOWN(Z3_MAX_PIN);
+    #else
+      SET_INPUT(Z3_MAX_PIN);
+    #endif
+  #endif
+
   #if ENABLED(Z_MIN_PROBE_ENDSTOP)
     #if ENABLED(ENDSTOPPULLUP_ZMIN_PROBE)
       SET_INPUT_PULLUP(Z_MIN_PROBE_PIN);
     #elif ENABLED(ENDSTOPPULLDOWN_ZMIN_PROBE)
       SET_INPUT_PULLDOWN(Z_MIN_PROBE_PIN);
     #else
       SET_INPUT(Z_MIN_PROBE_PIN);
     #endif
   #endif
 
@@ -364,26 +387,32 @@ void Endstops::M119() {
   #endif
   #if HAS_Y2_MAX
     ES_REPORT(Y2_MAX);
   #endif
   #if HAS_Z_MIN
     ES_REPORT(Z_MIN);
   #endif
   #if HAS_Z2_MIN
     ES_REPORT(Z2_MIN);
   #endif
+  #if HAS_Z3_MIN
+    ES_REPORT(Z3_MIN);
+  #endif
   #if HAS_Z_MAX
     ES_REPORT(Z_MAX);
   #endif
   #if HAS_Z2_MAX
     ES_REPORT(Z2_MAX);
   #endif
+  #if HAS_Z3_MAX
+    ES_REPORT(Z3_MAX);
+  #endif
   #if ENABLED(Z_MIN_PROBE_ENDSTOP)
     SERIAL_PROTOCOLPGM(MSG_Z_PROBE);
     SERIAL_PROTOCOLLN(((READ(Z_MIN_PROBE_PIN)^Z_MIN_PROBE_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
   #endif
   #if ENABLED(FILAMENT_RUNOUT_SENSOR)
     SERIAL_PROTOCOLPGM(MSG_FILAMENT_RUNOUT_SENSOR);
     SERIAL_PROTOCOLLN(((READ(FIL_RUNOUT_PIN)^FIL_RUNOUT_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
   #endif
 } // Endstops::M119
 
@@ -485,48 +514,62 @@ void Endstops::update() {
         UPDATE_ENDSTOP_BIT(Y2, MAX);
       #else
         COPY_LIVE_STATE(Y_MAX, Y2_MAX);
       #endif
     #else
       UPDATE_ENDSTOP_BIT(Y, MAX);
     #endif
   #endif
 
   #if HAS_Z_MIN
-    #if ENABLED(Z_DUAL_ENDSTOPS)
+    #if Z_MULTI_ENDSTOPS
       UPDATE_ENDSTOP_BIT(Z, MIN);
       #if HAS_Z2_MIN
         UPDATE_ENDSTOP_BIT(Z2, MIN);
       #else
         COPY_LIVE_STATE(Z_MIN, Z2_MIN);
       #endif
+      #if ENABLED(Z_TRIPLE_ENDSTOPS)
+        #if HAS_Z3_MIN
+          UPDATE_ENDSTOP_BIT(Z3, MIN);
+        #else
+          COPY_LIVE_STATE(Z_MIN, Z3_MIN);
+        #endif
+      #endif
     #elif ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
       UPDATE_ENDSTOP_BIT(Z, MIN);
     #elif Z_HOME_DIR < 0
       UPDATE_ENDSTOP_BIT(Z, MIN);
     #endif
   #endif
 
   // When closing the gap check the enabled probe
   #if ENABLED(Z_MIN_PROBE_ENDSTOP)
     UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
   #endif
 
   #if HAS_Z_MAX
     // Check both Z dual endstops
-    #if ENABLED(Z_DUAL_ENDSTOPS)
+    #if Z_MULTI_ENDSTOPS
       UPDATE_ENDSTOP_BIT(Z, MAX);
       #if HAS_Z2_MAX
         UPDATE_ENDSTOP_BIT(Z2, MAX);
       #else
         COPY_LIVE_STATE(Z_MAX, Z2_MAX);
       #endif
+      #if ENABLED(Z_TRIPLE_ENDSTOPS)
+        #if HAS_Z3_MAX
+          UPDATE_ENDSTOP_BIT(Z3, MAX);
+        #else
+          COPY_LIVE_STATE(Z_MAX, Z3_MAX);
+        #endif
+      #endif
     #elif DISABLED(Z_MIN_PROBE_ENDSTOP) || Z_MAX_PIN != Z_MIN_PROBE_PIN
       // If this pin isn't the bed probe it's the Z endstop
       UPDATE_ENDSTOP_BIT(Z, MAX);
     #endif
   #endif
 
   #if ENABLED(ENDSTOP_NOISE_FILTER)
     /**
      * Filtering out noise on endstops requires a delayed decision. Let's assume, due to noise,
      * that 50% of endstop signal samples are good and 50% are bad (assuming normal distribution
@@ -562,21 +605,31 @@ void Endstops::update() {
       planner.endstop_triggered(_AXIS(AXIS)); \
     } \
   }while(0)
 
   // Call the endstop triggered routine for dual endstops
   #define PROCESS_DUAL_ENDSTOP(AXIS1, AXIS2, MINMAX) do { \
     const byte dual_hit = TEST_ENDSTOP(_ENDSTOP(AXIS1, MINMAX)) | (TEST_ENDSTOP(_ENDSTOP(AXIS2, MINMAX)) << 1); \
     if (dual_hit) { \
       _ENDSTOP_HIT(AXIS1, MINMAX); \
       /* if not performing home or if both endstops were trigged during homing... */ \
-      if (!stepper.homing_dual_axis || dual_hit == 0b11) \
+      if (!stepper.separate_multi_axis || dual_hit == 0b11) \
+        planner.endstop_triggered(_AXIS(AXIS1)); \
+    } \
+  }while(0)
+
+  #define PROCESS_TRIPLE_ENDSTOP(AXIS1, AXIS2, AXIS3, MINMAX) do { \
+    const byte triple_hit = TEST_ENDSTOP(_ENDSTOP(AXIS1, MINMAX)) | (TEST_ENDSTOP(_ENDSTOP(AXIS2, MINMAX)) << 1) | (TEST_ENDSTOP(_ENDSTOP(AXIS3, MINMAX)) << 2); \
+    if (triple_hit) { \
+      _ENDSTOP_HIT(AXIS1, MINMAX); \
+      /* if not performing home or if both endstops were trigged during homing... */ \
+      if (!stepper.separate_multi_axis || triple_hit == 0x7) \
         planner.endstop_triggered(_AXIS(AXIS1)); \
     } \
   }while(0)
 
   #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && !(CORE_IS_XY || CORE_IS_XZ)
     // If G38 command is active check Z_MIN_PROBE for ALL movement
     if (G38_move) {
       if (TEST_ENDSTOP(_ENDSTOP(Z, MIN_PROBE))) {
         if      (stepper.axis_is_moving(X_AXIS)) { _ENDSTOP_HIT(X, MIN); planner.endstop_triggered(X_AXIS); }
         else if (stepper.axis_is_moving(Y_AXIS)) { _ENDSTOP_HIT(Y, MIN); planner.endstop_triggered(Y_AXIS); }
@@ -625,41 +678,45 @@ void Endstops::update() {
         #else
           PROCESS_ENDSTOP(Y, MAX);
         #endif
       #endif
     }
   }
 
   if (stepper.axis_is_moving(Z_AXIS)) {
     if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
       #if HAS_Z_MIN
-        #if ENABLED(Z_DUAL_ENDSTOPS)
+        #if ENABLED(Z_TRIPLE_ENDSTOPS)
+          PROCESS_TRIPLE_ENDSTOP(Z, Z2, Z3, MIN);
+        #elif ENABLED(Z_DUAL_ENDSTOPS)
           PROCESS_DUAL_ENDSTOP(Z, Z2, MIN);
         #else
           #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
             if (z_probe_enabled) PROCESS_ENDSTOP(Z, MIN);
           #elif ENABLED(Z_MIN_PROBE_ENDSTOP)
             if (!z_probe_enabled) PROCESS_ENDSTOP(Z, MIN);
           #else
             PROCESS_ENDSTOP(Z, MIN);
           #endif
         #endif
       #endif
 
       // When closing the gap check the enabled probe
       #if ENABLED(Z_MIN_PROBE_ENDSTOP)
         if (z_probe_enabled) PROCESS_ENDSTOP(Z, MIN_PROBE);
       #endif
     }
     else { // Z +direction. Gantry up, bed down.
       #if HAS_Z_MAX
-        #if ENABLED(Z_DUAL_ENDSTOPS)
+        #if ENABLED(Z_TRIPLE_ENDSTOPS)
+          PROCESS_TRIPLE_ENDSTOP(Z, Z2, Z3, MAX);
+        #elif ENABLED(Z_DUAL_ENDSTOPS)
           PROCESS_DUAL_ENDSTOP(Z, Z2, MAX);
         #elif DISABLED(Z_MIN_PROBE_ENDSTOP) || Z_MAX_PIN != Z_MIN_PROBE_PIN
           // If this pin is not hijacked for the bed probe
           // then it belongs to the Z endstop
           PROCESS_ENDSTOP(Z, MAX);
         #endif
       #endif
     }
   }
 } // Endstops::update()
@@ -716,20 +773,26 @@ void Endstops::update() {
     #endif
     #if HAS_Y2_MAX
       if (READ(Y2_MAX_PIN)) SBI(live_state_local, Y2_MAX);
     #endif
     #if HAS_Z2_MIN
       if (READ(Z2_MIN_PIN)) SBI(live_state_local, Z2_MIN);
     #endif
     #if HAS_Z2_MAX
       if (READ(Z2_MAX_PIN)) SBI(live_state_local, Z2_MAX);
     #endif
+    #if HAS_Z3_MIN
+      if (READ(Z3_MIN_PIN)) SBI(live_state_local, Z3_MIN);
+    #endif
+    #if HAS_Z3_MAX
+      if (READ(Z3_MAX_PIN)) SBI(live_state_local, Z3_MAX);
+    #endif
 
     uint16_t endstop_change = live_state_local ^ old_live_state_local;
 
     if (endstop_change) {
       #if HAS_X_MIN
         if (TEST(endstop_change, X_MIN)) SERIAL_PROTOCOLPAIR("  X_MIN:", TEST(live_state_local, X_MIN));
       #endif
       #if HAS_X_MAX
         if (TEST(endstop_change, X_MAX)) SERIAL_PROTOCOLPAIR("  X_MAX:", TEST(live_state_local, X_MAX));
       #endif
@@ -759,18 +822,24 @@ void Endstops::update() {
       #endif
       #if HAS_Y2_MAX
         if (TEST(endstop_change, Y2_MAX)) SERIAL_PROTOCOLPAIR("  Y2_MAX:", TEST(live_state_local, Y2_MAX));
       #endif
       #if HAS_Z2_MIN
         if (TEST(endstop_change, Z2_MIN)) SERIAL_PROTOCOLPAIR("  Z2_MIN:", TEST(live_state_local, Z2_MIN));
       #endif
       #if HAS_Z2_MAX
         if (TEST(endstop_change, Z2_MAX)) SERIAL_PROTOCOLPAIR("  Z2_MAX:", TEST(live_state_local, Z2_MAX));
       #endif
+      #if HAS_Z3_MIN
+        if (TEST(endstop_change, Z3_MIN)) SERIAL_PROTOCOLPAIR("  Z3_MIN:", TEST(live_state_local, Z3_MIN));
+      #endif
+      #if HAS_Z3_MAX
+        if (TEST(endstop_change, Z3_MAX)) SERIAL_PROTOCOLPAIR("  Z3_MAX:", TEST(live_state_local, Z3_MAX));
+      #endif
       SERIAL_PROTOCOLPGM("\n\n");
       analogWrite(LED_PIN, local_LED_status);
       local_LED_status ^= 255;
       old_live_state_local = live_state_local;
     }
   }
 
 #endif // PINS_DEBUGGING

commit 79835590e3009487d606c7de8de6a7e07095ea6b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Aug 6 23:11:37 2018 -0500

    Easier to disable homing validation (#11458)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index cecd303531..68886eb84f 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -249,25 +249,27 @@ void Endstops::enable(const bool onoff) {
 
 // Disable / Enable endstops based on ENSTOPS_ONLY_FOR_HOMING and global enable
 void Endstops::not_homing() {
   enabled = enabled_globally;
 
   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
     update();
   #endif
 }
 
-// If the last move failed to trigger an endstop, call kill
-void Endstops::validate_homing_move() {
-  if (trigger_state()) hit_on_purpose();
-  else kill(PSTR(MSG_ERR_HOMING_FAILED));
-}
+#if ENABLED(VALIDATE_HOMING_ENDSTOPS)
+  // If the last move failed to trigger an endstop, call kill
+  void Endstops::validate_homing_move() {
+    if (trigger_state()) hit_on_purpose();
+    else kill(PSTR(MSG_ERR_HOMING_FAILED));
+  }
+#endif
 
 // Enable / disable endstop z-probe checking
 #if HAS_BED_PROBE
   void Endstops::enable_z_probe(const bool onoff) {
     z_probe_enabled = onoff;
 
     #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
       update();
     #endif
   }

commit 566d05006da2ef30f0409664bf21b6211e1daf83
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jul 11 17:33:26 2018 -0500

    report_state > event_handler
    
    Make the endstop report method track endstop changes on its own.

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 5e9940a090..cecd303531 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -209,21 +209,21 @@ void Endstops::init() {
   enable_globally(
     #if ENABLED(ENDSTOPS_ALWAYS_ON_DEFAULT)
       true
     #else
       false
     #endif
   );
 
 } // Endstops::init
 
-// Called from ISR: Poll endstop state if required
+// Called at ~1KHz from Temperature ISR: Poll endstop state if required
 void Endstops::poll() {
 
   #if ENABLED(PINS_DEBUGGING)
     run_monitor();  // report changes in endstop status
   #endif
 
   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE) && ENABLED(ENDSTOP_NOISE_FILTER)
     if (endstop_poll_count) update();
   #elif DISABLED(ENDSTOP_INTERRUPTS_FEATURE) || ENABLED(ENDSTOP_NOISE_FILTER)
     update();
@@ -251,22 +251,22 @@ void Endstops::enable(const bool onoff) {
 void Endstops::not_homing() {
   enabled = enabled_globally;
 
   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
     update();
   #endif
 }
 
 // If the last move failed to trigger an endstop, call kill
 void Endstops::validate_homing_move() {
-  if (!trigger_state()) kill(PSTR(MSG_ERR_HOMING_FAILED));
-  hit_on_purpose();
+  if (trigger_state()) hit_on_purpose();
+  else kill(PSTR(MSG_ERR_HOMING_FAILED));
 }
 
 // Enable / disable endstop z-probe checking
 #if HAS_BED_PROBE
   void Endstops::enable_z_probe(const bool onoff) {
     z_probe_enabled = onoff;
 
     #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
       update();
     #endif
@@ -276,22 +276,23 @@ void Endstops::validate_homing_move() {
 #if ENABLED(PINS_DEBUGGING)
   void Endstops::run_monitor() {
     if (!monitor_flag) return;
     static uint8_t monitor_count = 16;  // offset this check from the others
     monitor_count += _BV(1);            //  15 Hz
     monitor_count &= 0x7F;
     if (!monitor_count) monitor();      // report changes in endstop status
   }
 #endif
 
-void Endstops::report_state() {
-  if (hit_state) {
+void Endstops::event_handler() {
+  static uint8_t prev_hit_state; // = 0
+  if (hit_state && hit_state != prev_hit_state) {
     #if ENABLED(ULTRA_LCD)
       char chrX = ' ', chrY = ' ', chrZ = ' ', chrP = ' ';
       #define _SET_STOP_CHAR(A,C) (chr## A = C)
     #else
       #define _SET_STOP_CHAR(A,C) ;
     #endif
 
     #define _ENDSTOP_HIT_ECHO(A,C) do{ \
       SERIAL_ECHOPAIR(" " STRINGIFY(A) ":", planner.triggered_position_mm(_AXIS(A))); \
       _SET_STOP_CHAR(A,C); }while(0)
@@ -313,31 +314,30 @@ void Endstops::report_state() {
     #if ENABLED(Z_MIN_PROBE_ENDSTOP)
       #define P_AXIS Z_AXIS
       if (TEST(hit_state, Z_MIN_PROBE)) _ENDSTOP_HIT_ECHO(P, 'P');
     #endif
     SERIAL_EOL();
 
     #if ENABLED(ULTRA_LCD)
       lcd_status_printf_P(0, PSTR(MSG_LCD_ENDSTOPS " %c %c %c %c"), chrX, chrY, chrZ, chrP);
     #endif
 
-    hit_on_purpose();
-
     #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED) && ENABLED(SDSUPPORT)
       if (planner.abort_on_endstop_hit) {
         card.sdprinting = false;
         card.closefile();
         quickstop_stepper();
         thermalManager.disable_all_heaters(); // switch off all heaters.
       }
     #endif
   }
+  prev_hit_state = hit_state;
 } // Endstops::report_state
 
 void Endstops::M119() {
   SERIAL_PROTOCOLLNPGM(MSG_M119_REPORT);
   #define ES_REPORT(AXIS) do{ \
     SERIAL_PROTOCOLPGM(MSG_##AXIS); \
     SERIAL_PROTOCOLLN(((READ(AXIS##_PIN)^AXIS##_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN)); \
   }while(0)
   #if HAS_X_MIN
     ES_REPORT(X_MIN);
@@ -385,21 +385,21 @@ void Endstops::M119() {
   #endif
 } // Endstops::M119
 
 // The following routines are called from an ISR context. It could be the temperature ISR, the
 // endstop ISR or the Stepper ISR.
 
 #define _ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
 #define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN
 #define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_INVERTING
 
-// Check endstops - Could be called from ISR!
+// Check endstops - Could be called from Temperature ISR!
 void Endstops::update() {
 
   #if DISABLED(ENDSTOP_NOISE_FILTER)
     if (!abort_enabled()) return;
   #endif
 
   #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT_TO(live_state, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
   #define COPY_LIVE_STATE(SRC_BIT, DST_BIT) SET_BIT_TO(live_state, DST_BIT, TEST(live_state, SRC_BIT))
 
   #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && !(CORE_IS_XY || CORE_IS_XZ)
@@ -560,21 +560,21 @@ void Endstops::update() {
       planner.endstop_triggered(_AXIS(AXIS)); \
     } \
   }while(0)
 
   // Call the endstop triggered routine for dual endstops
   #define PROCESS_DUAL_ENDSTOP(AXIS1, AXIS2, MINMAX) do { \
     const byte dual_hit = TEST_ENDSTOP(_ENDSTOP(AXIS1, MINMAX)) | (TEST_ENDSTOP(_ENDSTOP(AXIS2, MINMAX)) << 1); \
     if (dual_hit) { \
       _ENDSTOP_HIT(AXIS1, MINMAX); \
       /* if not performing home or if both endstops were trigged during homing... */ \
-      if (!stepper.homing_dual_axis || dual_hit == 0x3) \
+      if (!stepper.homing_dual_axis || dual_hit == 0b11) \
         planner.endstop_triggered(_AXIS(AXIS1)); \
     } \
   }while(0)
 
   #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && !(CORE_IS_XY || CORE_IS_XZ)
     // If G38 command is active check Z_MIN_PROBE for ALL movement
     if (G38_move) {
       if (TEST_ENDSTOP(_ENDSTOP(Z, MIN_PROBE))) {
         if      (stepper.axis_is_moving(X_AXIS)) { _ENDSTOP_HIT(X, MIN); planner.endstop_triggered(X_AXIS); }
         else if (stepper.axis_is_moving(Y_AXIS)) { _ENDSTOP_HIT(Y, MIN); planner.endstop_triggered(Y_AXIS); }

commit c51e27d11d9ff0b7ed0c50d4895db322659023d4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jun 30 21:54:07 2018 -0500

    Do a hard kill for failed homing moves (#11161)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 6da2f68e95..5e9940a090 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -249,20 +249,26 @@ void Endstops::enable(const bool onoff) {
 
 // Disable / Enable endstops based on ENSTOPS_ONLY_FOR_HOMING and global enable
 void Endstops::not_homing() {
   enabled = enabled_globally;
 
   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
     update();
   #endif
 }
 
+// If the last move failed to trigger an endstop, call kill
+void Endstops::validate_homing_move() {
+  if (!trigger_state()) kill(PSTR(MSG_ERR_HOMING_FAILED));
+  hit_on_purpose();
+}
+
 // Enable / disable endstop z-probe checking
 #if HAS_BED_PROBE
   void Endstops::enable_z_probe(const bool onoff) {
     z_probe_enabled = onoff;
 
     #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
       update();
     #endif
   }
 #endif

commit 2421f3a47d111209aa0890f6f6710bf43056d568
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Jun 30 17:27:37 2018 -0500

    Detect endstop hits in any direction

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 21f5320f83..6da2f68e95 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -425,92 +425,92 @@ void Endstops::update() {
   #if CORE_IS_XZ || CORE_IS_YZ
     #define Z_AXIS_HEAD Z_HEAD
   #else
     #define Z_AXIS_HEAD Z_AXIS
   #endif
 
   /**
    * Check and update endstops
    */
   #if HAS_X_MIN
-    #if ENABLED(X_DUAL_ENDSTOPS) && X_HOME_DIR < 0
+    #if ENABLED(X_DUAL_ENDSTOPS)
       UPDATE_ENDSTOP_BIT(X, MIN);
       #if HAS_X2_MIN
         UPDATE_ENDSTOP_BIT(X2, MIN);
       #else
         COPY_LIVE_STATE(X_MIN, X2_MIN);
       #endif
     #else
       UPDATE_ENDSTOP_BIT(X, MIN);
     #endif
   #endif
 
   #if HAS_X_MAX
-    #if ENABLED(X_DUAL_ENDSTOPS) && X_HOME_DIR > 0
+    #if ENABLED(X_DUAL_ENDSTOPS)
       UPDATE_ENDSTOP_BIT(X, MAX);
       #if HAS_X2_MAX
         UPDATE_ENDSTOP_BIT(X2, MAX);
       #else
         COPY_LIVE_STATE(X_MAX, X2_MAX);
       #endif
     #else
       UPDATE_ENDSTOP_BIT(X, MAX);
     #endif
   #endif
 
-  #if HAS_Y_MIN && Y_HOME_DIR < 0
+  #if HAS_Y_MIN
     #if ENABLED(Y_DUAL_ENDSTOPS)
       UPDATE_ENDSTOP_BIT(Y, MIN);
       #if HAS_Y2_MIN
         UPDATE_ENDSTOP_BIT(Y2, MIN);
       #else
         COPY_LIVE_STATE(Y_MIN, Y2_MIN);
       #endif
     #else
       UPDATE_ENDSTOP_BIT(Y, MIN);
     #endif
   #endif
 
-  #if HAS_Y_MAX && Y_HOME_DIR > 0
+  #if HAS_Y_MAX
     #if ENABLED(Y_DUAL_ENDSTOPS)
       UPDATE_ENDSTOP_BIT(Y, MAX);
       #if HAS_Y2_MAX
         UPDATE_ENDSTOP_BIT(Y2, MAX);
       #else
         COPY_LIVE_STATE(Y_MAX, Y2_MAX);
       #endif
     #else
       UPDATE_ENDSTOP_BIT(Y, MAX);
     #endif
   #endif
 
   #if HAS_Z_MIN
-    #if ENABLED(Z_DUAL_ENDSTOPS) && Z_HOME_DIR < 0
+    #if ENABLED(Z_DUAL_ENDSTOPS)
       UPDATE_ENDSTOP_BIT(Z, MIN);
       #if HAS_Z2_MIN
         UPDATE_ENDSTOP_BIT(Z2, MIN);
       #else
         COPY_LIVE_STATE(Z_MIN, Z2_MIN);
       #endif
     #elif ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
       UPDATE_ENDSTOP_BIT(Z, MIN);
     #elif Z_HOME_DIR < 0
       UPDATE_ENDSTOP_BIT(Z, MIN);
     #endif
   #endif
 
   // When closing the gap check the enabled probe
   #if ENABLED(Z_MIN_PROBE_ENDSTOP)
     UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
   #endif
 
-  #if HAS_Z_MAX && Z_HOME_DIR > 0
+  #if HAS_Z_MAX
     // Check both Z dual endstops
     #if ENABLED(Z_DUAL_ENDSTOPS)
       UPDATE_ENDSTOP_BIT(Z, MAX);
       #if HAS_Z2_MAX
         UPDATE_ENDSTOP_BIT(Z2, MAX);
       #else
         COPY_LIVE_STATE(Z_MAX, Z2_MAX);
       #endif
     #elif DISABLED(Z_MIN_PROBE_ENDSTOP) || Z_MAX_PIN != Z_MIN_PROBE_PIN
       // If this pin isn't the bed probe it's the Z endstop

commit 42f99214822cee44279d34e6523b539e057de385
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 28 05:06:11 2018 -0500

    Ignore Z min endstop with separate Z-probe
    
    To allow for the case where a Z endstop (e.g., hall effect) is higher than the probe trigger point, don't check the Z min endstop during probe moves. See #11134

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 6770286aee..21f5320f83 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -622,20 +622,22 @@ void Endstops::update() {
   }
 
   if (stepper.axis_is_moving(Z_AXIS)) {
     if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
       #if HAS_Z_MIN
         #if ENABLED(Z_DUAL_ENDSTOPS)
           PROCESS_DUAL_ENDSTOP(Z, Z2, MIN);
         #else
           #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
             if (z_probe_enabled) PROCESS_ENDSTOP(Z, MIN);
+          #elif ENABLED(Z_MIN_PROBE_ENDSTOP)
+            if (!z_probe_enabled) PROCESS_ENDSTOP(Z, MIN);
           #else
             PROCESS_ENDSTOP(Z, MIN);
           #endif
         #endif
       #endif
 
       // When closing the gap check the enabled probe
       #if ENABLED(Z_MIN_PROBE_ENDSTOP)
         if (z_probe_enabled) PROCESS_ENDSTOP(Z, MIN_PROBE);
       #endif

commit 053438a3aa1b6b8318f84f4a9105d39c3a0be46a
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jun 27 04:18:57 2018 -0400

    Poll all endstops, even when stationary (#11123)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 0b3baf5dc2..6770286aee 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -422,123 +422,108 @@ void Endstops::update() {
   #else
     #define Y_AXIS_HEAD Y_AXIS
   #endif
   #if CORE_IS_XZ || CORE_IS_YZ
     #define Z_AXIS_HEAD Z_HEAD
   #else
     #define Z_AXIS_HEAD Z_AXIS
   #endif
 
   /**
-   * Check and update endstops according to conditions
+   * Check and update endstops
    */
-  if (stepper.axis_is_moving(X_AXIS)) {
-    if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
-      #if HAS_X_MIN
-        #if ENABLED(X_DUAL_ENDSTOPS) && X_HOME_DIR < 0
-          UPDATE_ENDSTOP_BIT(X, MIN);
-          #if HAS_X2_MIN
-            UPDATE_ENDSTOP_BIT(X2, MIN);
-          #else
-            COPY_LIVE_STATE(X_MIN, X2_MIN);
-          #endif
-        #else
-          if (X_MIN_TEST) UPDATE_ENDSTOP_BIT(X, MIN);
-        #endif
-      #endif
-    }
-    else { // +direction
-      #if HAS_X_MAX
-        #if ENABLED(X_DUAL_ENDSTOPS) && X_HOME_DIR > 0
-          UPDATE_ENDSTOP_BIT(X, MAX);
-          #if HAS_X2_MAX
-            UPDATE_ENDSTOP_BIT(X2, MAX);
-          #else
-            COPY_LIVE_STATE(X_MAX, X2_MAX);
-          #endif
-        #else
-          if (X_MAX_TEST) UPDATE_ENDSTOP_BIT(X, MAX);
-        #endif
+  #if HAS_X_MIN
+    #if ENABLED(X_DUAL_ENDSTOPS) && X_HOME_DIR < 0
+      UPDATE_ENDSTOP_BIT(X, MIN);
+      #if HAS_X2_MIN
+        UPDATE_ENDSTOP_BIT(X2, MIN);
+      #else
+        COPY_LIVE_STATE(X_MIN, X2_MIN);
       #endif
-    }
-  }
+    #else
+      UPDATE_ENDSTOP_BIT(X, MIN);
+    #endif
+  #endif
 
-  if (stepper.axis_is_moving(Y_AXIS)) {
-    if (stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
-      #if HAS_Y_MIN && Y_HOME_DIR < 0
-        #if ENABLED(Y_DUAL_ENDSTOPS)
-          UPDATE_ENDSTOP_BIT(Y, MIN);
-          #if HAS_Y2_MIN
-            UPDATE_ENDSTOP_BIT(Y2, MIN);
-          #else
-            COPY_LIVE_STATE(Y_MIN, Y2_MIN);
-          #endif
-        #else
-          UPDATE_ENDSTOP_BIT(Y, MIN);
-        #endif
+  #if HAS_X_MAX
+    #if ENABLED(X_DUAL_ENDSTOPS) && X_HOME_DIR > 0
+      UPDATE_ENDSTOP_BIT(X, MAX);
+      #if HAS_X2_MAX
+        UPDATE_ENDSTOP_BIT(X2, MAX);
+      #else
+        COPY_LIVE_STATE(X_MAX, X2_MAX);
       #endif
-    }
-    else { // +direction
-      #if HAS_Y_MAX && Y_HOME_DIR > 0
-        #if ENABLED(Y_DUAL_ENDSTOPS)
-          UPDATE_ENDSTOP_BIT(Y, MAX);
-          #if HAS_Y2_MAX
-            UPDATE_ENDSTOP_BIT(Y2, MAX);
-          #else
-            COPY_LIVE_STATE(Y_MAX, Y2_MAX);
-          #endif
-        #else
-          UPDATE_ENDSTOP_BIT(Y, MAX);
-        #endif
+    #else
+      UPDATE_ENDSTOP_BIT(X, MAX);
+    #endif
+  #endif
+
+  #if HAS_Y_MIN && Y_HOME_DIR < 0
+    #if ENABLED(Y_DUAL_ENDSTOPS)
+      UPDATE_ENDSTOP_BIT(Y, MIN);
+      #if HAS_Y2_MIN
+        UPDATE_ENDSTOP_BIT(Y2, MIN);
+      #else
+        COPY_LIVE_STATE(Y_MIN, Y2_MIN);
       #endif
-    }
-  }
+    #else
+      UPDATE_ENDSTOP_BIT(Y, MIN);
+    #endif
+  #endif
 
-  if (stepper.axis_is_moving(Z_AXIS)) {
-    if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
-      #if HAS_Z_MIN
-        #if ENABLED(Z_DUAL_ENDSTOPS) && Z_HOME_DIR < 0
-          UPDATE_ENDSTOP_BIT(Z, MIN);
-          #if HAS_Z2_MIN
-            UPDATE_ENDSTOP_BIT(Z2, MIN);
-          #else
-            COPY_LIVE_STATE(Z_MIN, Z2_MIN);
-          #endif
-        #elif ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
-          if (z_probe_enabled) UPDATE_ENDSTOP_BIT(Z, MIN);
-        #elif Z_HOME_DIR < 0
-          UPDATE_ENDSTOP_BIT(Z, MIN);
-        #endif
+  #if HAS_Y_MAX && Y_HOME_DIR > 0
+    #if ENABLED(Y_DUAL_ENDSTOPS)
+      UPDATE_ENDSTOP_BIT(Y, MAX);
+      #if HAS_Y2_MAX
+        UPDATE_ENDSTOP_BIT(Y2, MAX);
+      #else
+        COPY_LIVE_STATE(Y_MAX, Y2_MAX);
       #endif
+    #else
+      UPDATE_ENDSTOP_BIT(Y, MAX);
+    #endif
+  #endif
 
-      // When closing the gap check the enabled probe
-      #if ENABLED(Z_MIN_PROBE_ENDSTOP)
-        if (z_probe_enabled) UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
+  #if HAS_Z_MIN
+    #if ENABLED(Z_DUAL_ENDSTOPS) && Z_HOME_DIR < 0
+      UPDATE_ENDSTOP_BIT(Z, MIN);
+      #if HAS_Z2_MIN
+        UPDATE_ENDSTOP_BIT(Z2, MIN);
+      #else
+        COPY_LIVE_STATE(Z_MIN, Z2_MIN);
       #endif
-    }
-    else { // Z +direction. Gantry up, bed down.
-      #if HAS_Z_MAX && Z_HOME_DIR > 0
-        // Check both Z dual endstops
-        #if ENABLED(Z_DUAL_ENDSTOPS)
-          UPDATE_ENDSTOP_BIT(Z, MAX);
-          #if HAS_Z2_MAX
-            UPDATE_ENDSTOP_BIT(Z2, MAX);
-          #else
-            COPY_LIVE_STATE(Z_MAX, Z2_MAX);
-          #endif
-        #elif DISABLED(Z_MIN_PROBE_ENDSTOP) || Z_MAX_PIN != Z_MIN_PROBE_PIN
-          // If this pin isn't the bed probe it's the Z endstop
-          UPDATE_ENDSTOP_BIT(Z, MAX);
-        #endif
+    #elif ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
+      UPDATE_ENDSTOP_BIT(Z, MIN);
+    #elif Z_HOME_DIR < 0
+      UPDATE_ENDSTOP_BIT(Z, MIN);
+    #endif
+  #endif
+
+  // When closing the gap check the enabled probe
+  #if ENABLED(Z_MIN_PROBE_ENDSTOP)
+    UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
+  #endif
+
+  #if HAS_Z_MAX && Z_HOME_DIR > 0
+    // Check both Z dual endstops
+    #if ENABLED(Z_DUAL_ENDSTOPS)
+      UPDATE_ENDSTOP_BIT(Z, MAX);
+      #if HAS_Z2_MAX
+        UPDATE_ENDSTOP_BIT(Z2, MAX);
+      #else
+        COPY_LIVE_STATE(Z_MAX, Z2_MAX);
       #endif
-    }
-  }
+    #elif DISABLED(Z_MIN_PROBE_ENDSTOP) || Z_MAX_PIN != Z_MIN_PROBE_PIN
+      // If this pin isn't the bed probe it's the Z endstop
+      UPDATE_ENDSTOP_BIT(Z, MAX);
+    #endif
+  #endif
 
   #if ENABLED(ENDSTOP_NOISE_FILTER)
     /**
      * Filtering out noise on endstops requires a delayed decision. Let's assume, due to noise,
      * that 50% of endstop signal samples are good and 50% are bad (assuming normal distribution
      * of random noise). Then the first sample has a 50% chance to be good or bad. The 2nd sample
      * also has a 50% chance to be good or bad. The chances of 2 samples both being bad becomes
      * 50% of 50%, or 25%. That was the previous implementation of Marlin endstop handling. It
      * reduces chances of bad readings in half, at the cost of 1 extra sample period, but chances
      * still exist. The only way to reduce them further is to increase the number of samples.

commit 99591dc20cbe6f998850e3b42b5f13e7789ff837
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Jun 21 20:14:16 2018 -0500

    Filter endstops state at all times (#11066)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index acf0be796b..0b3baf5dc2 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -29,37 +29,31 @@
 
 #include "../Marlin.h"
 #include "../sd/cardreader.h"
 #include "../module/temperature.h"
 #include "../lcd/ultralcd.h"
 
 #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
   #include HAL_PATH(../HAL, endstop_interrupts.h)
 #endif
 
-#if HAS_BED_PROBE
-  #define ENDSTOPS_ENABLED  (enabled || z_probe_enabled)
-#else
-  #define ENDSTOPS_ENABLED  enabled
-#endif
-
 Endstops endstops;
 
 // public:
 
 bool Endstops::enabled, Endstops::enabled_globally; // Initialized by settings.load()
 volatile uint8_t Endstops::hit_state;
 
 Endstops::esbits_t Endstops::live_state = 0;
+
 #if ENABLED(ENDSTOP_NOISE_FILTER)
-  Endstops::esbits_t Endstops::old_live_state,
-                     Endstops::validated_live_state;
+  Endstops::esbits_t Endstops::validated_live_state;
   uint8_t Endstops::endstop_poll_count;
 #endif
 
 #if HAS_BED_PROBE
   volatile bool Endstops::z_probe_enabled = false;
 #endif
 
 // Initialized by settings.load()
 #if ENABLED(X_DUAL_ENDSTOPS)
   float Endstops::x_endstop_adj;
@@ -215,68 +209,67 @@ void Endstops::init() {
   enable_globally(
     #if ENABLED(ENDSTOPS_ALWAYS_ON_DEFAULT)
       true
     #else
       false
     #endif
   );
 
 } // Endstops::init
 
-// Called from ISR. A change was detected. Find out what happened!
-void Endstops::check_possible_change() { if (ENDSTOPS_ENABLED) update(); }
-
 // Called from ISR: Poll endstop state if required
 void Endstops::poll() {
 
   #if ENABLED(PINS_DEBUGGING)
     run_monitor();  // report changes in endstop status
   #endif
 
-  #if DISABLED(ENDSTOP_INTERRUPTS_FEATURE) || ENABLED(ENDSTOP_NOISE_FILTER)
-    if (ENDSTOPS_ENABLED) update();
+  #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE) && ENABLED(ENDSTOP_NOISE_FILTER)
+    if (endstop_poll_count) update();
+  #elif DISABLED(ENDSTOP_INTERRUPTS_FEATURE) || ENABLED(ENDSTOP_NOISE_FILTER)
+    update();
   #endif
 }
 
 void Endstops::enable_globally(const bool onoff) {
   enabled_globally = enabled = onoff;
 
   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-    if (onoff) update(); // If enabling, update state now
+    update();
   #endif
 }
 
 // Enable / disable endstop checking
 void Endstops::enable(const bool onoff) {
   enabled = onoff;
 
   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-    if (onoff) update(); // If enabling, update state now
+    update();
   #endif
 }
 
 // Disable / Enable endstops based on ENSTOPS_ONLY_FOR_HOMING and global enable
 void Endstops::not_homing() {
   enabled = enabled_globally;
 
   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-    if (enabled) update(); // If enabling, update state now
+    update();
   #endif
 }
 
 // Enable / disable endstop z-probe checking
 #if HAS_BED_PROBE
   void Endstops::enable_z_probe(const bool onoff) {
     z_probe_enabled = onoff;
 
     #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-      if (enabled) update(); // If enabling, update state now
+      update();
     #endif
   }
 #endif
 
 #if ENABLED(PINS_DEBUGGING)
   void Endstops::run_monitor() {
     if (!monitor_flag) return;
     static uint8_t monitor_count = 16;  // offset this check from the others
     monitor_count += _BV(1);            //  15 Hz
     monitor_count &= 0x7F;
@@ -389,24 +382,26 @@ void Endstops::M119() {
 // The following routines are called from an ISR context. It could be the temperature ISR, the
 // endstop ISR or the Stepper ISR.
 
 #define _ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
 #define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN
 #define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_INVERTING
 
 // Check endstops - Could be called from ISR!
 void Endstops::update() {
 
-  // UPDATE_ENDSTOP_BIT: set the current endstop bits for an endstop to its status
+  #if DISABLED(ENDSTOP_NOISE_FILTER)
+    if (!abort_enabled()) return;
+  #endif
+
   #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT_TO(live_state, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
-  // COPY_BIT: copy the value of SRC_BIT to DST_BIT in DST
-  #define COPY_BIT(DST, SRC_BIT, DST_BIT) SET_BIT_TO(DST, DST_BIT, TEST(DST, SRC_BIT))
+  #define COPY_LIVE_STATE(SRC_BIT, DST_BIT) SET_BIT_TO(live_state, DST_BIT, TEST(live_state, SRC_BIT))
 
   #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && !(CORE_IS_XY || CORE_IS_XZ)
     // If G38 command is active check Z_MIN_PROBE for ALL movement
     if (G38_move) UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
   #endif
 
   // With Dual X, endstops are only checked in the homing direction for the active extruder
   #if ENABLED(DUAL_X_CARRIAGE)
     #define E0_ACTIVE stepper.movement_extruder() == 0
     #define X_MIN_TEST ((X_HOME_DIR < 0 && E0_ACTIVE) || (X2_HOME_DIR < 0 && !E0_ACTIVE))
@@ -437,83 +432,83 @@ void Endstops::update() {
    * Check and update endstops according to conditions
    */
   if (stepper.axis_is_moving(X_AXIS)) {
     if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
       #if HAS_X_MIN
         #if ENABLED(X_DUAL_ENDSTOPS) && X_HOME_DIR < 0
           UPDATE_ENDSTOP_BIT(X, MIN);
           #if HAS_X2_MIN
             UPDATE_ENDSTOP_BIT(X2, MIN);
           #else
-            COPY_BIT(live_state, X_MIN, X2_MIN);
+            COPY_LIVE_STATE(X_MIN, X2_MIN);
           #endif
         #else
           if (X_MIN_TEST) UPDATE_ENDSTOP_BIT(X, MIN);
         #endif
       #endif
     }
     else { // +direction
       #if HAS_X_MAX
         #if ENABLED(X_DUAL_ENDSTOPS) && X_HOME_DIR > 0
           UPDATE_ENDSTOP_BIT(X, MAX);
           #if HAS_X2_MAX
             UPDATE_ENDSTOP_BIT(X2, MAX);
           #else
-            COPY_BIT(live_state, X_MAX, X2_MAX);
+            COPY_LIVE_STATE(X_MAX, X2_MAX);
           #endif
         #else
           if (X_MAX_TEST) UPDATE_ENDSTOP_BIT(X, MAX);
         #endif
       #endif
     }
   }
 
   if (stepper.axis_is_moving(Y_AXIS)) {
     if (stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
       #if HAS_Y_MIN && Y_HOME_DIR < 0
         #if ENABLED(Y_DUAL_ENDSTOPS)
           UPDATE_ENDSTOP_BIT(Y, MIN);
           #if HAS_Y2_MIN
             UPDATE_ENDSTOP_BIT(Y2, MIN);
           #else
-            COPY_BIT(live_state, Y_MIN, Y2_MIN);
+            COPY_LIVE_STATE(Y_MIN, Y2_MIN);
           #endif
         #else
           UPDATE_ENDSTOP_BIT(Y, MIN);
         #endif
       #endif
     }
     else { // +direction
       #if HAS_Y_MAX && Y_HOME_DIR > 0
         #if ENABLED(Y_DUAL_ENDSTOPS)
           UPDATE_ENDSTOP_BIT(Y, MAX);
           #if HAS_Y2_MAX
             UPDATE_ENDSTOP_BIT(Y2, MAX);
           #else
-            COPY_BIT(live_state, Y_MAX, Y2_MAX);
+            COPY_LIVE_STATE(Y_MAX, Y2_MAX);
           #endif
         #else
           UPDATE_ENDSTOP_BIT(Y, MAX);
         #endif
       #endif
     }
   }
 
   if (stepper.axis_is_moving(Z_AXIS)) {
     if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
       #if HAS_Z_MIN
         #if ENABLED(Z_DUAL_ENDSTOPS) && Z_HOME_DIR < 0
           UPDATE_ENDSTOP_BIT(Z, MIN);
           #if HAS_Z2_MIN
             UPDATE_ENDSTOP_BIT(Z2, MIN);
           #else
-            COPY_BIT(live_state, Z_MIN, Z2_MIN);
+            COPY_LIVE_STATE(Z_MIN, Z2_MIN);
           #endif
         #elif ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
           if (z_probe_enabled) UPDATE_ENDSTOP_BIT(Z, MIN);
         #elif Z_HOME_DIR < 0
           UPDATE_ENDSTOP_BIT(Z, MIN);
         #endif
       #endif
 
       // When closing the gap check the enabled probe
       #if ENABLED(Z_MIN_PROBE_ENDSTOP)
@@ -521,60 +516,55 @@ void Endstops::update() {
       #endif
     }
     else { // Z +direction. Gantry up, bed down.
       #if HAS_Z_MAX && Z_HOME_DIR > 0
         // Check both Z dual endstops
         #if ENABLED(Z_DUAL_ENDSTOPS)
           UPDATE_ENDSTOP_BIT(Z, MAX);
           #if HAS_Z2_MAX
             UPDATE_ENDSTOP_BIT(Z2, MAX);
           #else
-            COPY_BIT(live_state, Z_MAX, Z2_MAX);
+            COPY_LIVE_STATE(Z_MAX, Z2_MAX);
           #endif
         #elif DISABLED(Z_MIN_PROBE_ENDSTOP) || Z_MAX_PIN != Z_MIN_PROBE_PIN
           // If this pin isn't the bed probe it's the Z endstop
           UPDATE_ENDSTOP_BIT(Z, MAX);
         #endif
       #endif
     }
   }
 
-  // All endstops were updated.
   #if ENABLED(ENDSTOP_NOISE_FILTER)
-    if (old_live_state != live_state) { // We detected a change. Reinit the timeout
-      /**
-       * Filtering out noise on endstops requires a delayed decision. Let's assume, due to noise,
-       * that 50% of endstop signal samples are good and 50% are bad (assuming normal distribution
-       * of random noise). Then the first sample has a 50% chance to be good or bad. The 2nd sample
-       * also has a 50% chance to be good or bad. The chances of 2 samples both being bad becomes
-       * 50% of 50%, or 25%. That was the previous implementation of Marlin endstop handling. It
-       * reduces chances of bad readings in half, at the cost of 1 extra sample period, but chances
-       * still exist. The only way to reduce them further is to increase the number of samples.
-       * To reduce the chance to 1% (1/128th) requires 7 samples (adding 7ms of delay).
-       */
+    /**
+     * Filtering out noise on endstops requires a delayed decision. Let's assume, due to noise,
+     * that 50% of endstop signal samples are good and 50% are bad (assuming normal distribution
+     * of random noise). Then the first sample has a 50% chance to be good or bad. The 2nd sample
+     * also has a 50% chance to be good or bad. The chances of 2 samples both being bad becomes
+     * 50% of 50%, or 25%. That was the previous implementation of Marlin endstop handling. It
+     * reduces chances of bad readings in half, at the cost of 1 extra sample period, but chances
+     * still exist. The only way to reduce them further is to increase the number of samples.
+     * To reduce the chance to 1% (1/128th) requires 7 samples (adding 7ms of delay).
+     */
+    static esbits_t old_live_state;
+    if (old_live_state != live_state) {
       endstop_poll_count = 7;
       old_live_state = live_state;
     }
     else if (endstop_poll_count && !--endstop_poll_count)
       validated_live_state = live_state;
 
-  #else
-
-    // Lets accept the new endstop values as valid - We assume hardware filtering of lines
-    esbits_t validated_live_state = live_state;
+    if (!abort_enabled()) return;
 
   #endif
 
-  // Endstop readings are validated in validated_live_state
-
   // Test the current status of an endstop
-  #define TEST_ENDSTOP(ENDSTOP) (TEST(validated_live_state, ENDSTOP))
+  #define TEST_ENDSTOP(ENDSTOP) (TEST(state(), ENDSTOP))
 
   // Record endstop was hit
   #define _ENDSTOP_HIT(AXIS, MINMAX) SBI(hit_state, _ENDSTOP(AXIS, MINMAX))
 
   // Call the endstop triggered routine for single endstops
   #define PROCESS_ENDSTOP(AXIS,MINMAX) do { \
     if (TEST_ENDSTOP(_ENDSTOP(AXIS, MINMAX))) { \
       _ENDSTOP_HIT(AXIS, MINMAX); \
       planner.endstop_triggered(_AXIS(AXIS)); \
     } \

commit 4c8d6df13c70af8505c2b58796699aa74a303235
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jun 13 01:22:02 2018 -0500

    Extra insurance against endstop false positives (#11013)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index d6842a5800..acf0be796b 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -258,21 +258,21 @@ void Endstops::enable(const bool onoff) {
 void Endstops::not_homing() {
   enabled = enabled_globally;
 
   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
     if (enabled) update(); // If enabling, update state now
   #endif
 }
 
 // Enable / disable endstop z-probe checking
 #if HAS_BED_PROBE
-  void Endstops::enable_z_probe(bool onoff) {
+  void Endstops::enable_z_probe(const bool onoff) {
     z_probe_enabled = onoff;
 
     #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
       if (enabled) update(); // If enabling, update state now
     #endif
   }
 #endif
 
 #if ENABLED(PINS_DEBUGGING)
   void Endstops::run_monitor() {
@@ -432,116 +432,113 @@ void Endstops::update() {
   #else
     #define Z_AXIS_HEAD Z_AXIS
   #endif
 
   /**
    * Check and update endstops according to conditions
    */
   if (stepper.axis_is_moving(X_AXIS)) {
     if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
       #if HAS_X_MIN
-        #if ENABLED(X_DUAL_ENDSTOPS)
+        #if ENABLED(X_DUAL_ENDSTOPS) && X_HOME_DIR < 0
           UPDATE_ENDSTOP_BIT(X, MIN);
           #if HAS_X2_MIN
             UPDATE_ENDSTOP_BIT(X2, MIN);
           #else
             COPY_BIT(live_state, X_MIN, X2_MIN);
           #endif
         #else
           if (X_MIN_TEST) UPDATE_ENDSTOP_BIT(X, MIN);
         #endif
       #endif
     }
     else { // +direction
       #if HAS_X_MAX
-        #if ENABLED(X_DUAL_ENDSTOPS)
+        #if ENABLED(X_DUAL_ENDSTOPS) && X_HOME_DIR > 0
           UPDATE_ENDSTOP_BIT(X, MAX);
           #if HAS_X2_MAX
             UPDATE_ENDSTOP_BIT(X2, MAX);
           #else
             COPY_BIT(live_state, X_MAX, X2_MAX);
           #endif
         #else
           if (X_MAX_TEST) UPDATE_ENDSTOP_BIT(X, MAX);
         #endif
       #endif
     }
   }
 
   if (stepper.axis_is_moving(Y_AXIS)) {
     if (stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
-      #if HAS_Y_MIN
+      #if HAS_Y_MIN && Y_HOME_DIR < 0
         #if ENABLED(Y_DUAL_ENDSTOPS)
           UPDATE_ENDSTOP_BIT(Y, MIN);
           #if HAS_Y2_MIN
             UPDATE_ENDSTOP_BIT(Y2, MIN);
           #else
             COPY_BIT(live_state, Y_MIN, Y2_MIN);
           #endif
         #else
           UPDATE_ENDSTOP_BIT(Y, MIN);
         #endif
       #endif
     }
     else { // +direction
-      #if HAS_Y_MAX
+      #if HAS_Y_MAX && Y_HOME_DIR > 0
         #if ENABLED(Y_DUAL_ENDSTOPS)
           UPDATE_ENDSTOP_BIT(Y, MAX);
           #if HAS_Y2_MAX
             UPDATE_ENDSTOP_BIT(Y2, MAX);
           #else
             COPY_BIT(live_state, Y_MAX, Y2_MAX);
           #endif
         #else
           UPDATE_ENDSTOP_BIT(Y, MAX);
         #endif
       #endif
     }
   }
 
   if (stepper.axis_is_moving(Z_AXIS)) {
     if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
       #if HAS_Z_MIN
-        #if ENABLED(Z_DUAL_ENDSTOPS)
+        #if ENABLED(Z_DUAL_ENDSTOPS) && Z_HOME_DIR < 0
           UPDATE_ENDSTOP_BIT(Z, MIN);
           #if HAS_Z2_MIN
             UPDATE_ENDSTOP_BIT(Z2, MIN);
           #else
             COPY_BIT(live_state, Z_MIN, Z2_MIN);
           #endif
-        #else
-          #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
-            if (z_probe_enabled) UPDATE_ENDSTOP_BIT(Z, MIN);
-          #else
-            UPDATE_ENDSTOP_BIT(Z, MIN);
-          #endif
+        #elif ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
+          if (z_probe_enabled) UPDATE_ENDSTOP_BIT(Z, MIN);
+        #elif Z_HOME_DIR < 0
+          UPDATE_ENDSTOP_BIT(Z, MIN);
         #endif
       #endif
 
       // When closing the gap check the enabled probe
       #if ENABLED(Z_MIN_PROBE_ENDSTOP)
         if (z_probe_enabled) UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
       #endif
     }
     else { // Z +direction. Gantry up, bed down.
-      #if HAS_Z_MAX
+      #if HAS_Z_MAX && Z_HOME_DIR > 0
         // Check both Z dual endstops
         #if ENABLED(Z_DUAL_ENDSTOPS)
           UPDATE_ENDSTOP_BIT(Z, MAX);
           #if HAS_Z2_MAX
             UPDATE_ENDSTOP_BIT(Z2, MAX);
           #else
             COPY_BIT(live_state, Z_MAX, Z2_MAX);
           #endif
-        // If this pin is not hijacked for the bed probe
-        // then it belongs to the Z endstop
         #elif DISABLED(Z_MIN_PROBE_ENDSTOP) || Z_MAX_PIN != Z_MIN_PROBE_PIN
+          // If this pin isn't the bed probe it's the Z endstop
           UPDATE_ENDSTOP_BIT(Z, MAX);
         #endif
       #endif
     }
   }
 
   // All endstops were updated.
   #if ENABLED(ENDSTOP_NOISE_FILTER)
     if (old_live_state != live_state) { // We detected a change. Reinit the timeout
       /**

commit ad8d3150aa4d6b792b5e06a63d2645991136fc50
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Jun 2 20:39:00 2018 -0500

    Cleanup for dual endstops homing

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index ee312da2d0..d6842a5800 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -389,21 +389,20 @@ void Endstops::M119() {
 // The following routines are called from an ISR context. It could be the temperature ISR, the
 // endstop ISR or the Stepper ISR.
 
 #define _ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
 #define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN
 #define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_INVERTING
 
 // Check endstops - Could be called from ISR!
 void Endstops::update() {
 
-  #define SET_BIT_TO(N,B,TF) do{ if (TF) SBI(N,B); else CBI(N,B); }while(0)
   // UPDATE_ENDSTOP_BIT: set the current endstop bits for an endstop to its status
   #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT_TO(live_state, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
   // COPY_BIT: copy the value of SRC_BIT to DST_BIT in DST
   #define COPY_BIT(DST, SRC_BIT, DST_BIT) SET_BIT_TO(DST, DST_BIT, TEST(DST, SRC_BIT))
 
   #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && !(CORE_IS_XY || CORE_IS_XZ)
     // If G38 command is active check Z_MIN_PROBE for ALL movement
     if (G38_move) UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
   #endif
 
@@ -583,21 +582,21 @@ void Endstops::update() {
       planner.endstop_triggered(_AXIS(AXIS)); \
     } \
   }while(0)
 
   // Call the endstop triggered routine for dual endstops
   #define PROCESS_DUAL_ENDSTOP(AXIS1, AXIS2, MINMAX) do { \
     const byte dual_hit = TEST_ENDSTOP(_ENDSTOP(AXIS1, MINMAX)) | (TEST_ENDSTOP(_ENDSTOP(AXIS2, MINMAX)) << 1); \
     if (dual_hit) { \
       _ENDSTOP_HIT(AXIS1, MINMAX); \
       /* if not performing home or if both endstops were trigged during homing... */ \
-      if (!stepper.performing_homing || dual_hit == 0x3) \
+      if (!stepper.homing_dual_axis || dual_hit == 0x3) \
         planner.endstop_triggered(_AXIS(AXIS1)); \
     } \
   }while(0)
 
   #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && !(CORE_IS_XY || CORE_IS_XZ)
     // If G38 command is active check Z_MIN_PROBE for ALL movement
     if (G38_move) {
       if (TEST_ENDSTOP(_ENDSTOP(Z, MIN_PROBE))) {
         if      (stepper.axis_is_moving(X_AXIS)) { _ENDSTOP_HIT(X, MIN); planner.endstop_triggered(X_AXIS); }
         else if (stepper.axis_is_moving(Y_AXIS)) { _ENDSTOP_HIT(Y, MIN); planner.endstop_triggered(Y_AXIS); }

commit d3c02410a84b369443654ef77f925562e9b87830
Author: Eduardo Jos√© Tagle <ejtagle@hotmail.com>
Date:   Fri Jun 1 21:02:22 2018 -0300

    [2.0.x] Small assorted collection of fixes and improvements (#10911)
    
    * Misc fixes and improvements
    
    - Get rid of most critical sections on the Serial port drivers for AVR and DUE. Proper usage of FIFOs should allow interrupts to stay enabled without harm to queuing and dequeuing.
      Also, with 8-bit indices (for AVR) and up to 32-bit indices (for ARM), there is no need to protect reads and writes to those indices.
    - Simplify the XON/XOFF logic quite a bit. Much cleaner now (both for AVR and ARM)
    - Prevent a race condition (edge case) that could happen when estimating the proper value for the stepper timer (by reading it) and writing the calculated value for the time to the next ISR by disabling interrupts in those critical and small sections of the code - The problem could lead to lost steps.
    - Fix dual endstops not properly homing bug (maybe).
    
    * Set position immediately when possible

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 29ac1e7ce1..ee312da2d0 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -571,33 +571,36 @@ void Endstops::update() {
   // Endstop readings are validated in validated_live_state
 
   // Test the current status of an endstop
   #define TEST_ENDSTOP(ENDSTOP) (TEST(validated_live_state, ENDSTOP))
 
   // Record endstop was hit
   #define _ENDSTOP_HIT(AXIS, MINMAX) SBI(hit_state, _ENDSTOP(AXIS, MINMAX))
 
   // Call the endstop triggered routine for single endstops
   #define PROCESS_ENDSTOP(AXIS,MINMAX) do { \
-      if (TEST_ENDSTOP(_ENDSTOP(AXIS, MINMAX))) { \
-        _ENDSTOP_HIT(AXIS, MINMAX); \
-        planner.endstop_triggered(_AXIS(AXIS)); \
-      } \
-    }while(0)
+    if (TEST_ENDSTOP(_ENDSTOP(AXIS, MINMAX))) { \
+      _ENDSTOP_HIT(AXIS, MINMAX); \
+      planner.endstop_triggered(_AXIS(AXIS)); \
+    } \
+  }while(0)
 
-  // Call the endstop triggered routine for single endstops
+  // Call the endstop triggered routine for dual endstops
   #define PROCESS_DUAL_ENDSTOP(AXIS1, AXIS2, MINMAX) do { \
-      if (TEST_ENDSTOP(_ENDSTOP(AXIS1, MINMAX)) || TEST_ENDSTOP(_ENDSTOP(AXIS2, MINMAX))) { \
-        _ENDSTOP_HIT(AXIS1, MINMAX); \
+    const byte dual_hit = TEST_ENDSTOP(_ENDSTOP(AXIS1, MINMAX)) | (TEST_ENDSTOP(_ENDSTOP(AXIS2, MINMAX)) << 1); \
+    if (dual_hit) { \
+      _ENDSTOP_HIT(AXIS1, MINMAX); \
+      /* if not performing home or if both endstops were trigged during homing... */ \
+      if (!stepper.performing_homing || dual_hit == 0x3) \
         planner.endstop_triggered(_AXIS(AXIS1)); \
-      } \
-    }while(0)
+    } \
+  }while(0)
 
   #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && !(CORE_IS_XY || CORE_IS_XZ)
     // If G38 command is active check Z_MIN_PROBE for ALL movement
     if (G38_move) {
       if (TEST_ENDSTOP(_ENDSTOP(Z, MIN_PROBE))) {
         if      (stepper.axis_is_moving(X_AXIS)) { _ENDSTOP_HIT(X, MIN); planner.endstop_triggered(X_AXIS); }
         else if (stepper.axis_is_moving(Y_AXIS)) { _ENDSTOP_HIT(Y, MIN); planner.endstop_triggered(Y_AXIS); }
         else if (stepper.axis_is_moving(Z_AXIS)) { _ENDSTOP_HIT(Z, MIN); planner.endstop_triggered(Z_AXIS); }
         G38_endstop_hit = true;
       }

commit 7261f48872fd9adba6ac890f886a00daeb852b0c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu May 24 19:28:15 2018 -0500

    Fix reset of endstops and move state

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 319562a6a6..29ac1e7ce1 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -256,29 +256,20 @@ void Endstops::enable(const bool onoff) {
 
 // Disable / Enable endstops based on ENSTOPS_ONLY_FOR_HOMING and global enable
 void Endstops::not_homing() {
   enabled = enabled_globally;
 
   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
     if (enabled) update(); // If enabling, update state now
   #endif
 }
 
-// Clear endstops (i.e., they were hit intentionally) to suppress the report
-void Endstops::hit_on_purpose() {
-  hit_state = 0;
-
-  #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-    if (enabled) update(); // If enabling, update state now
-  #endif
-}
-
 // Enable / disable endstop z-probe checking
 #if HAS_BED_PROBE
   void Endstops::enable_z_probe(bool onoff) {
     z_probe_enabled = onoff;
 
     #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
       if (enabled) update(); // If enabling, update state now
     #endif
   }
 #endif

commit 9644d56b42de1d45b292f67cda950387fd76aa06
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu May 24 00:04:47 2018 -0500

    Patches for core motion tests

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 8c51662922..319562a6a6 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -398,25 +398,25 @@ void Endstops::M119() {
 // The following routines are called from an ISR context. It could be the temperature ISR, the
 // endstop ISR or the Stepper ISR.
 
 #define _ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
 #define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN
 #define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_INVERTING
 
 // Check endstops - Could be called from ISR!
 void Endstops::update() {
 
-  #define SET_BIT(N,B,TF) do{ if (TF) SBI(N,B); else CBI(N,B); }while(0)
+  #define SET_BIT_TO(N,B,TF) do{ if (TF) SBI(N,B); else CBI(N,B); }while(0)
   // UPDATE_ENDSTOP_BIT: set the current endstop bits for an endstop to its status
-  #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT(live_state, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
+  #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT_TO(live_state, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
   // COPY_BIT: copy the value of SRC_BIT to DST_BIT in DST
-  #define COPY_BIT(DST, SRC_BIT, DST_BIT) SET_BIT(DST, DST_BIT, TEST(DST, SRC_BIT))
+  #define COPY_BIT(DST, SRC_BIT, DST_BIT) SET_BIT_TO(DST, DST_BIT, TEST(DST, SRC_BIT))
 
   #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && !(CORE_IS_XY || CORE_IS_XZ)
     // If G38 command is active check Z_MIN_PROBE for ALL movement
     if (G38_move) UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
   #endif
 
   // With Dual X, endstops are only checked in the homing direction for the active extruder
   #if ENABLED(DUAL_X_CARRIAGE)
     #define E0_ACTIVE stepper.movement_extruder() == 0
     #define X_MIN_TEST ((X_HOME_DIR < 0 && E0_ACTIVE) || (X2_HOME_DIR < 0 && !E0_ACTIVE))
@@ -598,23 +598,23 @@ void Endstops::update() {
       if (TEST_ENDSTOP(_ENDSTOP(AXIS1, MINMAX)) || TEST_ENDSTOP(_ENDSTOP(AXIS2, MINMAX))) { \
         _ENDSTOP_HIT(AXIS1, MINMAX); \
         planner.endstop_triggered(_AXIS(AXIS1)); \
       } \
     }while(0)
 
   #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && !(CORE_IS_XY || CORE_IS_XZ)
     // If G38 command is active check Z_MIN_PROBE for ALL movement
     if (G38_move) {
       if (TEST_ENDSTOP(_ENDSTOP(Z, MIN_PROBE))) {
-        if      (stepper.axis_is_moving(_AXIS(X))) { _ENDSTOP_HIT(X, MIN); planner.endstop_triggered(_AXIS(X)); }
-        else if (stepper.axis_is_moving(_AXIS(Y))) { _ENDSTOP_HIT(Y, MIN); planner.endstop_triggered(_AXIS(Y)); }
-        else if (stepper.axis_is_moving(_AXIS(Z))) { _ENDSTOP_HIT(Z, MIN); planner.endstop_triggered(_AXIS(Z)); }
+        if      (stepper.axis_is_moving(X_AXIS)) { _ENDSTOP_HIT(X, MIN); planner.endstop_triggered(X_AXIS); }
+        else if (stepper.axis_is_moving(Y_AXIS)) { _ENDSTOP_HIT(Y, MIN); planner.endstop_triggered(Y_AXIS); }
+        else if (stepper.axis_is_moving(Z_AXIS)) { _ENDSTOP_HIT(Z, MIN); planner.endstop_triggered(Z_AXIS); }
         G38_endstop_hit = true;
       }
     }
   #endif
 
   // Now, we must signal, after validation, if an endstop limit is pressed or not
   if (stepper.axis_is_moving(X_AXIS)) {
     if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
       #if HAS_X_MIN
         #if ENABLED(X_DUAL_ENDSTOPS)

commit 3e3789da85e4d25693506df9dfd094aabf98d50e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed May 23 03:45:25 2018 -0500

    Regression: Endstops Core compatibility (#10823)
    
    Co-Authored-By: ejtagle <ejtagle@hotmail.com>

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 83b1a504db..8c51662922 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -30,23 +30,23 @@
 #include "../Marlin.h"
 #include "../sd/cardreader.h"
 #include "../module/temperature.h"
 #include "../lcd/ultralcd.h"
 
 #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
   #include HAL_PATH(../HAL, endstop_interrupts.h)
 #endif
 
 #if HAS_BED_PROBE
-  #define ENDSTOPS_ENABLED  (endstops.enabled || endstops.z_probe_enabled)
+  #define ENDSTOPS_ENABLED  (enabled || z_probe_enabled)
 #else
-  #define ENDSTOPS_ENABLED  endstops.enabled
+  #define ENDSTOPS_ENABLED  enabled
 #endif
 
 Endstops endstops;
 
 // public:
 
 bool Endstops::enabled, Endstops::enabled_globally; // Initialized by settings.load()
 volatile uint8_t Endstops::hit_state;
 
 Endstops::esbits_t Endstops::live_state = 0;
@@ -216,77 +216,76 @@ void Endstops::init() {
     #if ENABLED(ENDSTOPS_ALWAYS_ON_DEFAULT)
       true
     #else
       false
     #endif
   );
 
 } // Endstops::init
 
 // Called from ISR. A change was detected. Find out what happened!
-void Endstops::check_possible_change() { if (ENDSTOPS_ENABLED) endstops.update(); }
+void Endstops::check_possible_change() { if (ENDSTOPS_ENABLED) update(); }
 
 // Called from ISR: Poll endstop state if required
 void Endstops::poll() {
 
   #if ENABLED(PINS_DEBUGGING)
-    endstops.run_monitor();  // report changes in endstop status
+    run_monitor();  // report changes in endstop status
   #endif
 
   #if DISABLED(ENDSTOP_INTERRUPTS_FEATURE) || ENABLED(ENDSTOP_NOISE_FILTER)
-    if (ENDSTOPS_ENABLED) endstops.update();
+    if (ENDSTOPS_ENABLED) update();
   #endif
 }
 
 void Endstops::enable_globally(const bool onoff) {
   enabled_globally = enabled = onoff;
 
   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-    if (onoff) endstops.update(); // If enabling, update state now
+    if (onoff) update(); // If enabling, update state now
   #endif
 }
 
 // Enable / disable endstop checking
 void Endstops::enable(const bool onoff) {
   enabled = onoff;
 
   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-    if (onoff) endstops.update(); // If enabling, update state now
+    if (onoff) update(); // If enabling, update state now
   #endif
 }
 
-
 // Disable / Enable endstops based on ENSTOPS_ONLY_FOR_HOMING and global enable
 void Endstops::not_homing() {
   enabled = enabled_globally;
 
   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-    if (enabled) endstops.update(); // If enabling, update state now
+    if (enabled) update(); // If enabling, update state now
   #endif
 }
 
 // Clear endstops (i.e., they were hit intentionally) to suppress the report
 void Endstops::hit_on_purpose() {
   hit_state = 0;
 
   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-    if (enabled) endstops.update(); // If enabling, update state now
+    if (enabled) update(); // If enabling, update state now
   #endif
 }
 
 // Enable / disable endstop z-probe checking
 #if HAS_BED_PROBE
   void Endstops::enable_z_probe(bool onoff) {
     z_probe_enabled = onoff;
 
     #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
-      if (enabled) endstops.update(); // If enabling, update state now
+      if (enabled) update(); // If enabling, update state now
     #endif
   }
 #endif
 
 #if ENABLED(PINS_DEBUGGING)
   void Endstops::run_monitor() {
     if (!monitor_flag) return;
     static uint8_t monitor_count = 16;  // offset this check from the others
     monitor_count += _BV(1);            //  15 Hz
     monitor_count &= 0x7F;
@@ -410,103 +409,51 @@ void Endstops::update() {
   // UPDATE_ENDSTOP_BIT: set the current endstop bits for an endstop to its status
   #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT(live_state, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
   // COPY_BIT: copy the value of SRC_BIT to DST_BIT in DST
   #define COPY_BIT(DST, SRC_BIT, DST_BIT) SET_BIT(DST, DST_BIT, TEST(DST, SRC_BIT))
 
   #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && !(CORE_IS_XY || CORE_IS_XZ)
     // If G38 command is active check Z_MIN_PROBE for ALL movement
     if (G38_move) UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
   #endif
 
-  /**
-   * Define conditions for checking endstops
-   */
-
-  #if IS_CORE
-    #define S_(N) stepper.movement_non_null(CORE_AXIS_##N)
-    #define D_(N) stepper.motor_direction(CORE_AXIS_##N)
+  // With Dual X, endstops are only checked in the homing direction for the active extruder
+  #if ENABLED(DUAL_X_CARRIAGE)
+    #define E0_ACTIVE stepper.movement_extruder() == 0
+    #define X_MIN_TEST ((X_HOME_DIR < 0 && E0_ACTIVE) || (X2_HOME_DIR < 0 && !E0_ACTIVE))
+    #define X_MAX_TEST ((X_HOME_DIR > 0 && E0_ACTIVE) || (X2_HOME_DIR > 0 && !E0_ACTIVE))
+  #else
+    #define X_MIN_TEST true
+    #define X_MAX_TEST true
   #endif
 
+  // Use HEAD for core axes, AXIS for others
   #if CORE_IS_XY || CORE_IS_XZ
-    /**
-     * Head direction in -X axis for CoreXY and CoreXZ bots.
-     *
-     * If steps differ, both axes are moving.
-     * If DeltaA == -DeltaB, the movement is only in the 2nd axis (Y or Z, handled below)
-     * If DeltaA ==  DeltaB, the movement is only in the 1st axis (X)
-     */
-    #if ENABLED(COREXY) || ENABLED(COREXZ)
-      #define X_CMP ==
-    #else
-      #define X_CMP !=
-    #endif
-    #define X_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && D_(1) X_CMP D_(2)) )
     #define X_AXIS_HEAD X_HEAD
   #else
-    #define X_MOVE_TEST stepper.movement_non_null(X_AXIS)
     #define X_AXIS_HEAD X_AXIS
   #endif
-
   #if CORE_IS_XY || CORE_IS_YZ
-    /**
-     * Head direction in -Y axis for CoreXY / CoreYZ bots.
-     *
-     * If steps differ, both axes are moving
-     * If DeltaA ==  DeltaB, the movement is only in the 1st axis (X or Y)
-     * If DeltaA == -DeltaB, the movement is only in the 2nd axis (Y or Z)
-     */
-    #if ENABLED(COREYX) || ENABLED(COREYZ)
-      #define Y_CMP ==
-    #else
-      #define Y_CMP !=
-    #endif
-    #define Y_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && D_(1) Y_CMP D_(2)) )
     #define Y_AXIS_HEAD Y_HEAD
   #else
-    #define Y_MOVE_TEST stepper.movement_non_null(Y_AXIS)
     #define Y_AXIS_HEAD Y_AXIS
   #endif
-
   #if CORE_IS_XZ || CORE_IS_YZ
-    /**
-     * Head direction in -Z axis for CoreXZ or CoreYZ bots.
-     *
-     * If steps differ, both axes are moving
-     * If DeltaA ==  DeltaB, the movement is only in the 1st axis (X or Y, already handled above)
-     * If DeltaA == -DeltaB, the movement is only in the 2nd axis (Z)
-     */
-    #if ENABLED(COREZX) || ENABLED(COREZY)
-      #define Z_CMP ==
-    #else
-      #define Z_CMP !=
-    #endif
-    #define Z_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && D_(1) Z_CMP D_(2)) )
     #define Z_AXIS_HEAD Z_HEAD
   #else
-    #define Z_MOVE_TEST stepper.movement_non_null(Z_AXIS)
     #define Z_AXIS_HEAD Z_AXIS
   #endif
 
-  // With Dual X, endstops are only checked in the homing direction for the active extruder
-  #if ENABLED(DUAL_X_CARRIAGE)
-    #define E0_ACTIVE stepper.movement_extruder() == 0
-    #define X_MIN_TEST ((X_HOME_DIR < 0 && E0_ACTIVE) || (X2_HOME_DIR < 0 && !E0_ACTIVE))
-    #define X_MAX_TEST ((X_HOME_DIR > 0 && E0_ACTIVE) || (X2_HOME_DIR > 0 && !E0_ACTIVE))
-  #else
-    #define X_MIN_TEST true
-    #define X_MAX_TEST true
-  #endif
-
   /**
    * Check and update endstops according to conditions
    */
-  if (X_MOVE_TEST) {
+  if (stepper.axis_is_moving(X_AXIS)) {
     if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
       #if HAS_X_MIN
         #if ENABLED(X_DUAL_ENDSTOPS)
           UPDATE_ENDSTOP_BIT(X, MIN);
           #if HAS_X2_MIN
             UPDATE_ENDSTOP_BIT(X2, MIN);
           #else
             COPY_BIT(live_state, X_MIN, X2_MIN);
           #endif
         #else
@@ -523,21 +470,21 @@ void Endstops::update() {
           #else
             COPY_BIT(live_state, X_MAX, X2_MAX);
           #endif
         #else
           if (X_MAX_TEST) UPDATE_ENDSTOP_BIT(X, MAX);
         #endif
       #endif
     }
   }
 
-  if (Y_MOVE_TEST) {
+  if (stepper.axis_is_moving(Y_AXIS)) {
     if (stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
       #if HAS_Y_MIN
         #if ENABLED(Y_DUAL_ENDSTOPS)
           UPDATE_ENDSTOP_BIT(Y, MIN);
           #if HAS_Y2_MIN
             UPDATE_ENDSTOP_BIT(Y2, MIN);
           #else
             COPY_BIT(live_state, Y_MIN, Y2_MIN);
           #endif
         #else
@@ -554,44 +501,42 @@ void Endstops::update() {
           #else
             COPY_BIT(live_state, Y_MAX, Y2_MAX);
           #endif
         #else
           UPDATE_ENDSTOP_BIT(Y, MAX);
         #endif
       #endif
     }
   }
 
-  if (Z_MOVE_TEST) {
+  if (stepper.axis_is_moving(Z_AXIS)) {
     if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
       #if HAS_Z_MIN
         #if ENABLED(Z_DUAL_ENDSTOPS)
           UPDATE_ENDSTOP_BIT(Z, MIN);
           #if HAS_Z2_MIN
             UPDATE_ENDSTOP_BIT(Z2, MIN);
           #else
             COPY_BIT(live_state, Z_MIN, Z2_MIN);
           #endif
         #else
           #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
             if (z_probe_enabled) UPDATE_ENDSTOP_BIT(Z, MIN);
           #else
             UPDATE_ENDSTOP_BIT(Z, MIN);
           #endif
         #endif
       #endif
 
       // When closing the gap check the enabled probe
       #if ENABLED(Z_MIN_PROBE_ENDSTOP)
-        if (z_probe_enabled) {
-          UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
-        }
+        if (z_probe_enabled) UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
       #endif
     }
     else { // Z +direction. Gantry up, bed down.
       #if HAS_Z_MAX
         // Check both Z dual endstops
         #if ENABLED(Z_DUAL_ENDSTOPS)
           UPDATE_ENDSTOP_BIT(Z, MAX);
           #if HAS_Z2_MAX
             UPDATE_ENDSTOP_BIT(Z2, MAX);
           #else
@@ -653,72 +598,72 @@ void Endstops::update() {
       if (TEST_ENDSTOP(_ENDSTOP(AXIS1, MINMAX)) || TEST_ENDSTOP(_ENDSTOP(AXIS2, MINMAX))) { \
         _ENDSTOP_HIT(AXIS1, MINMAX); \
         planner.endstop_triggered(_AXIS(AXIS1)); \
       } \
     }while(0)
 
   #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && !(CORE_IS_XY || CORE_IS_XZ)
     // If G38 command is active check Z_MIN_PROBE for ALL movement
     if (G38_move) {
       if (TEST_ENDSTOP(_ENDSTOP(Z, MIN_PROBE))) {
-        if      (stepper.movement_non_null(_AXIS(X))) { _ENDSTOP_HIT(X, MIN); planner.endstop_triggered(_AXIS(X)); }
-        else if (stepper.movement_non_null(_AXIS(Y))) { _ENDSTOP_HIT(Y, MIN); planner.endstop_triggered(_AXIS(Y)); }
-        else if (stepper.movement_non_null(_AXIS(Z))) { _ENDSTOP_HIT(Z, MIN); planner.endstop_triggered(_AXIS(Z)); }
+        if      (stepper.axis_is_moving(_AXIS(X))) { _ENDSTOP_HIT(X, MIN); planner.endstop_triggered(_AXIS(X)); }
+        else if (stepper.axis_is_moving(_AXIS(Y))) { _ENDSTOP_HIT(Y, MIN); planner.endstop_triggered(_AXIS(Y)); }
+        else if (stepper.axis_is_moving(_AXIS(Z))) { _ENDSTOP_HIT(Z, MIN); planner.endstop_triggered(_AXIS(Z)); }
         G38_endstop_hit = true;
       }
     }
   #endif
 
   // Now, we must signal, after validation, if an endstop limit is pressed or not
-  if (X_MOVE_TEST) {
+  if (stepper.axis_is_moving(X_AXIS)) {
     if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
       #if HAS_X_MIN
         #if ENABLED(X_DUAL_ENDSTOPS)
           PROCESS_DUAL_ENDSTOP(X, X2, MIN);
         #else
           if (X_MIN_TEST) PROCESS_ENDSTOP(X, MIN);
         #endif
       #endif
     }
     else { // +direction
       #if HAS_X_MAX
         #if ENABLED(X_DUAL_ENDSTOPS)
           PROCESS_DUAL_ENDSTOP(X, X2, MAX);
         #else
           if (X_MAX_TEST) PROCESS_ENDSTOP(X, MAX);
         #endif
       #endif
     }
   }
 
-  if (Y_MOVE_TEST) {
+  if (stepper.axis_is_moving(Y_AXIS)) {
     if (stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
       #if HAS_Y_MIN
         #if ENABLED(Y_DUAL_ENDSTOPS)
           PROCESS_DUAL_ENDSTOP(Y, Y2, MIN);
         #else
           PROCESS_ENDSTOP(Y, MIN);
         #endif
       #endif
     }
     else { // +direction
       #if HAS_Y_MAX
         #if ENABLED(Y_DUAL_ENDSTOPS)
           PROCESS_DUAL_ENDSTOP(Y, Y2, MAX);
         #else
           PROCESS_ENDSTOP(Y, MAX);
         #endif
       #endif
     }
   }
 
-  if (Z_MOVE_TEST) {
+  if (stepper.axis_is_moving(Z_AXIS)) {
     if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
       #if HAS_Z_MIN
         #if ENABLED(Z_DUAL_ENDSTOPS)
           PROCESS_DUAL_ENDSTOP(Z, Z2, MIN);
         #else
           #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
             if (z_probe_enabled) PROCESS_ENDSTOP(Z, MIN);
           #else
             PROCESS_ENDSTOP(Z, MIN);
           #endif

commit 4b610b333e3893d8ce3c4566d01d89d70263ca04
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 22 01:56:03 2018 -0500

    Tweak G38 formatting

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index fec473e2bf..83b1a504db 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -407,23 +407,21 @@ void Endstops::M119() {
 void Endstops::update() {
 
   #define SET_BIT(N,B,TF) do{ if (TF) SBI(N,B); else CBI(N,B); }while(0)
   // UPDATE_ENDSTOP_BIT: set the current endstop bits for an endstop to its status
   #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT(live_state, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
   // COPY_BIT: copy the value of SRC_BIT to DST_BIT in DST
   #define COPY_BIT(DST, SRC_BIT, DST_BIT) SET_BIT(DST, DST_BIT, TEST(DST, SRC_BIT))
 
   #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && !(CORE_IS_XY || CORE_IS_XZ)
     // If G38 command is active check Z_MIN_PROBE for ALL movement
-    if (G38_move) {
-      UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
-    }
+    if (G38_move) UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
   #endif
 
   /**
    * Define conditions for checking endstops
    */
 
   #if IS_CORE
     #define S_(N) stepper.movement_non_null(CORE_AXIS_##N)
     #define D_(N) stepper.motor_direction(CORE_AXIS_##N)
   #endif

commit 4b2f6e3b2b0d6773cb15e55433bb243625ba71ea
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon May 21 15:51:38 2018 -0500

    [2.0.x] Add endstop noise filter (#10796)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index d354774afe..fec473e2bf 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -29,37 +29,39 @@
 
 #include "../Marlin.h"
 #include "../sd/cardreader.h"
 #include "../module/temperature.h"
 #include "../lcd/ultralcd.h"
 
 #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
   #include HAL_PATH(../HAL, endstop_interrupts.h)
 #endif
 
-// TEST_ENDSTOP: test the current status of an endstop
-#define TEST_ENDSTOP(ENDSTOP) (TEST(current_endstop_bits, ENDSTOP))
-
 #if HAS_BED_PROBE
   #define ENDSTOPS_ENABLED  (endstops.enabled || endstops.z_probe_enabled)
 #else
   #define ENDSTOPS_ENABLED  endstops.enabled
 #endif
 
 Endstops endstops;
 
 // public:
 
 bool Endstops::enabled, Endstops::enabled_globally; // Initialized by settings.load()
-volatile uint8_t Endstops::endstop_hit_bits; // use X_MIN, Y_MIN, Z_MIN and Z_MIN_PROBE as BIT value
+volatile uint8_t Endstops::hit_state;
 
-Endstops::esbits_t Endstops::current_endstop_bits = 0;
+Endstops::esbits_t Endstops::live_state = 0;
+#if ENABLED(ENDSTOP_NOISE_FILTER)
+  Endstops::esbits_t Endstops::old_live_state,
+                     Endstops::validated_live_state;
+  uint8_t Endstops::endstop_poll_count;
+#endif
 
 #if HAS_BED_PROBE
   volatile bool Endstops::z_probe_enabled = false;
 #endif
 
 // Initialized by settings.load()
 #if ENABLED(X_DUAL_ENDSTOPS)
   float Endstops::x_endstop_adj;
 #endif
 #if ENABLED(Y_DUAL_ENDSTOPS)
@@ -223,21 +225,21 @@ void Endstops::init() {
 // Called from ISR. A change was detected. Find out what happened!
 void Endstops::check_possible_change() { if (ENDSTOPS_ENABLED) endstops.update(); }
 
 // Called from ISR: Poll endstop state if required
 void Endstops::poll() {
 
   #if ENABLED(PINS_DEBUGGING)
     endstops.run_monitor();  // report changes in endstop status
   #endif
 
-  #if DISABLED(ENDSTOP_INTERRUPTS_FEATURE)
+  #if DISABLED(ENDSTOP_INTERRUPTS_FEATURE) || ENABLED(ENDSTOP_NOISE_FILTER)
     if (ENDSTOPS_ENABLED) endstops.update();
   #endif
 }
 
 void Endstops::enable_globally(const bool onoff) {
   enabled_globally = enabled = onoff;
 
   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
     if (onoff) endstops.update(); // If enabling, update state now
   #endif
@@ -257,21 +259,21 @@ void Endstops::enable(const bool onoff) {
 void Endstops::not_homing() {
   enabled = enabled_globally;
 
   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
     if (enabled) endstops.update(); // If enabling, update state now
   #endif
 }
 
 // Clear endstops (i.e., they were hit intentionally) to suppress the report
 void Endstops::hit_on_purpose() {
-  endstop_hit_bits = 0;
+  hit_state = 0;
 
   #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
     if (enabled) endstops.update(); // If enabling, update state now
   #endif
 }
 
 // Enable / disable endstop z-probe checking
 #if HAS_BED_PROBE
   void Endstops::enable_z_probe(bool onoff) {
     z_probe_enabled = onoff;
@@ -286,49 +288,49 @@ void Endstops::hit_on_purpose() {
   void Endstops::run_monitor() {
     if (!monitor_flag) return;
     static uint8_t monitor_count = 16;  // offset this check from the others
     monitor_count += _BV(1);            //  15 Hz
     monitor_count &= 0x7F;
     if (!monitor_count) monitor();      // report changes in endstop status
   }
 #endif
 
 void Endstops::report_state() {
-  if (endstop_hit_bits) {
+  if (hit_state) {
     #if ENABLED(ULTRA_LCD)
       char chrX = ' ', chrY = ' ', chrZ = ' ', chrP = ' ';
       #define _SET_STOP_CHAR(A,C) (chr## A = C)
     #else
       #define _SET_STOP_CHAR(A,C) ;
     #endif
 
     #define _ENDSTOP_HIT_ECHO(A,C) do{ \
       SERIAL_ECHOPAIR(" " STRINGIFY(A) ":", planner.triggered_position_mm(_AXIS(A))); \
       _SET_STOP_CHAR(A,C); }while(0)
 
     #define _ENDSTOP_HIT_TEST(A,C) \
-      if (TEST(endstop_hit_bits, A ##_MIN) || TEST(endstop_hit_bits, A ##_MAX)) \
+      if (TEST(hit_state, A ##_MIN) || TEST(hit_state, A ##_MAX)) \
         _ENDSTOP_HIT_ECHO(A,C)
 
     #define ENDSTOP_HIT_TEST_X() _ENDSTOP_HIT_TEST(X,'X')
     #define ENDSTOP_HIT_TEST_Y() _ENDSTOP_HIT_TEST(Y,'Y')
     #define ENDSTOP_HIT_TEST_Z() _ENDSTOP_HIT_TEST(Z,'Z')
 
     SERIAL_ECHO_START();
     SERIAL_ECHOPGM(MSG_ENDSTOPS_HIT);
     ENDSTOP_HIT_TEST_X();
     ENDSTOP_HIT_TEST_Y();
     ENDSTOP_HIT_TEST_Z();
 
     #if ENABLED(Z_MIN_PROBE_ENDSTOP)
       #define P_AXIS Z_AXIS
-      if (TEST(endstop_hit_bits, Z_MIN_PROBE)) _ENDSTOP_HIT_ECHO(P, 'P');
+      if (TEST(hit_state, Z_MIN_PROBE)) _ENDSTOP_HIT_ECHO(P, 'P');
     #endif
     SERIAL_EOL();
 
     #if ENABLED(ULTRA_LCD)
       lcd_status_printf_P(0, PSTR(MSG_LCD_ENDSTOPS " %c %c %c %c"), chrX, chrY, chrZ, chrP);
     #endif
 
     hit_on_purpose();
 
     #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED) && ENABLED(SDSUPPORT)
@@ -390,83 +392,37 @@ void Endstops::M119() {
   #endif
   #if ENABLED(FILAMENT_RUNOUT_SENSOR)
     SERIAL_PROTOCOLPGM(MSG_FILAMENT_RUNOUT_SENSOR);
     SERIAL_PROTOCOLLN(((READ(FIL_RUNOUT_PIN)^FIL_RUNOUT_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
   #endif
 } // Endstops::M119
 
 // The following routines are called from an ISR context. It could be the temperature ISR, the
 // endstop ISR or the Stepper ISR.
 
-#if ENABLED(X_DUAL_ENDSTOPS)
-  void Endstops::test_dual_x_endstops(const EndstopEnum es1, const EndstopEnum es2) {
-    const byte x_test = TEST_ENDSTOP(es1) | (TEST_ENDSTOP(es2) << 1); // bit 0 for X, bit 1 for X2
-    if (x_test && stepper.movement_non_null(X_AXIS)) {
-      SBI(endstop_hit_bits, X_MIN);
-      if (!stepper.performing_homing || (x_test == 0x3))  //if not performing home or if both endstops were trigged during homing...
-        stepper.quick_stop();
-    }
-  }
-#endif
-#if ENABLED(Y_DUAL_ENDSTOPS)
-  void Endstops::test_dual_y_endstops(const EndstopEnum es1, const EndstopEnum es2) {
-    const byte y_test = TEST_ENDSTOP(es1) | (TEST_ENDSTOP(es2) << 1); // bit 0 for Y, bit 1 for Y2
-    if (y_test && stepper.movement_non_null(Y_AXIS)) {
-      SBI(endstop_hit_bits, Y_MIN);
-      if (!stepper.performing_homing || (y_test == 0x3))  //if not performing home or if both endstops were trigged during homing...
-        stepper.quick_stop();
-    }
-  }
-#endif
-#if ENABLED(Z_DUAL_ENDSTOPS)
-  void Endstops::test_dual_z_endstops(const EndstopEnum es1, const EndstopEnum es2) {
-    const byte z_test = TEST_ENDSTOP(es1) | (TEST_ENDSTOP(es2) << 1); // bit 0 for Z, bit 1 for Z2
-    if (z_test && stepper.movement_non_null(Z_AXIS)) {
-      SBI(endstop_hit_bits, Z_MIN);
-      if (!stepper.performing_homing || (z_test == 0x3))  //if not performing home or if both endstops were trigged during homing...
-        stepper.quick_stop();
-    }
-  }
-#endif
+#define _ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
+#define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN
+#define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_INVERTING
 
 // Check endstops - Could be called from ISR!
 void Endstops::update() {
 
-  #define _ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
-  #define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN
-  #define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_INVERTING
-  #define _ENDSTOP_HIT(AXIS, MINMAX) SBI(endstop_hit_bits, _ENDSTOP(AXIS, MINMAX))
-
   #define SET_BIT(N,B,TF) do{ if (TF) SBI(N,B); else CBI(N,B); }while(0)
   // UPDATE_ENDSTOP_BIT: set the current endstop bits for an endstop to its status
-  #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT(current_endstop_bits, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
+  #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT(live_state, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
   // COPY_BIT: copy the value of SRC_BIT to DST_BIT in DST
   #define COPY_BIT(DST, SRC_BIT, DST_BIT) SET_BIT(DST, DST_BIT, TEST(DST, SRC_BIT))
 
-  #define UPDATE_ENDSTOP(AXIS,MINMAX) do { \
-      UPDATE_ENDSTOP_BIT(AXIS, MINMAX); \
-      if (TEST_ENDSTOP(_ENDSTOP(AXIS, MINMAX))) { \
-        _ENDSTOP_HIT(AXIS, MINMAX); \
-        planner.endstop_triggered(_AXIS(AXIS)); \
-      } \
-    }while(0)
-
   #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && !(CORE_IS_XY || CORE_IS_XZ)
     // If G38 command is active check Z_MIN_PROBE for ALL movement
     if (G38_move) {
       UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
-      if (TEST_ENDSTOP(_ENDSTOP(Z, MIN_PROBE))) {
-        if      (stepper.movement_non_null(_AXIS(X))) { _ENDSTOP_HIT(X, MIN); planner.endstop_triggered(_AXIS(X)); }
-        else if (stepper.movement_non_null(_AXIS(Y))) { _ENDSTOP_HIT(Y, MIN); planner.endstop_triggered(_AXIS(Y)); }
-        else if (stepper.movement_non_null(_AXIS(Z))) { _ENDSTOP_HIT(Z, MIN); planner.endstop_triggered(_AXIS(Z)); }
-        G38_endstop_hit = true;
-      }
     }
   #endif
 
   /**
    * Define conditions for checking endstops
    */
 
   #if IS_CORE
     #define S_(N) stepper.movement_non_null(CORE_AXIS_##N)
     #define D_(N) stepper.motor_direction(CORE_AXIS_##N)
@@ -546,121 +502,251 @@ void Endstops::update() {
    * Check and update endstops according to conditions
    */
   if (X_MOVE_TEST) {
     if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
       #if HAS_X_MIN
         #if ENABLED(X_DUAL_ENDSTOPS)
           UPDATE_ENDSTOP_BIT(X, MIN);
           #if HAS_X2_MIN
             UPDATE_ENDSTOP_BIT(X2, MIN);
           #else
-            COPY_BIT(current_endstop_bits, X_MIN, X2_MIN);
+            COPY_BIT(live_state, X_MIN, X2_MIN);
           #endif
-          test_dual_x_endstops(X_MIN, X2_MIN);
         #else
-          if (X_MIN_TEST) UPDATE_ENDSTOP(X, MIN);
+          if (X_MIN_TEST) UPDATE_ENDSTOP_BIT(X, MIN);
         #endif
       #endif
     }
     else { // +direction
       #if HAS_X_MAX
         #if ENABLED(X_DUAL_ENDSTOPS)
           UPDATE_ENDSTOP_BIT(X, MAX);
           #if HAS_X2_MAX
             UPDATE_ENDSTOP_BIT(X2, MAX);
           #else
-            COPY_BIT(current_endstop_bits, X_MAX, X2_MAX);
+            COPY_BIT(live_state, X_MAX, X2_MAX);
           #endif
-          test_dual_x_endstops(X_MAX, X2_MAX);
         #else
-          if (X_MAX_TEST) UPDATE_ENDSTOP(X, MAX);
+          if (X_MAX_TEST) UPDATE_ENDSTOP_BIT(X, MAX);
         #endif
       #endif
     }
   }
 
   if (Y_MOVE_TEST) {
     if (stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
       #if HAS_Y_MIN
         #if ENABLED(Y_DUAL_ENDSTOPS)
           UPDATE_ENDSTOP_BIT(Y, MIN);
           #if HAS_Y2_MIN
             UPDATE_ENDSTOP_BIT(Y2, MIN);
           #else
-            COPY_BIT(current_endstop_bits, Y_MIN, Y2_MIN);
+            COPY_BIT(live_state, Y_MIN, Y2_MIN);
           #endif
-          test_dual_y_endstops(Y_MIN, Y2_MIN);
         #else
-          UPDATE_ENDSTOP(Y, MIN);
+          UPDATE_ENDSTOP_BIT(Y, MIN);
         #endif
       #endif
     }
     else { // +direction
       #if HAS_Y_MAX
         #if ENABLED(Y_DUAL_ENDSTOPS)
           UPDATE_ENDSTOP_BIT(Y, MAX);
           #if HAS_Y2_MAX
             UPDATE_ENDSTOP_BIT(Y2, MAX);
           #else
-            COPY_BIT(current_endstop_bits, Y_MAX, Y2_MAX);
+            COPY_BIT(live_state, Y_MAX, Y2_MAX);
           #endif
-          test_dual_y_endstops(Y_MAX, Y2_MAX);
         #else
-          UPDATE_ENDSTOP(Y, MAX);
+          UPDATE_ENDSTOP_BIT(Y, MAX);
         #endif
       #endif
     }
   }
 
   if (Z_MOVE_TEST) {
     if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
       #if HAS_Z_MIN
         #if ENABLED(Z_DUAL_ENDSTOPS)
           UPDATE_ENDSTOP_BIT(Z, MIN);
           #if HAS_Z2_MIN
             UPDATE_ENDSTOP_BIT(Z2, MIN);
           #else
-            COPY_BIT(current_endstop_bits, Z_MIN, Z2_MIN);
+            COPY_BIT(live_state, Z_MIN, Z2_MIN);
           #endif
-          test_dual_z_endstops(Z_MIN, Z2_MIN);
         #else
           #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
-            if (z_probe_enabled) UPDATE_ENDSTOP(Z, MIN);
+            if (z_probe_enabled) UPDATE_ENDSTOP_BIT(Z, MIN);
           #else
-            UPDATE_ENDSTOP(Z, MIN);
+            UPDATE_ENDSTOP_BIT(Z, MIN);
           #endif
         #endif
       #endif
 
       // When closing the gap check the enabled probe
       #if ENABLED(Z_MIN_PROBE_ENDSTOP)
         if (z_probe_enabled) {
-          UPDATE_ENDSTOP(Z, MIN_PROBE);
-          if (TEST_ENDSTOP(Z_MIN_PROBE)) SBI(endstop_hit_bits, Z_MIN_PROBE);
+          UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
         }
       #endif
     }
     else { // Z +direction. Gantry up, bed down.
       #if HAS_Z_MAX
         // Check both Z dual endstops
         #if ENABLED(Z_DUAL_ENDSTOPS)
           UPDATE_ENDSTOP_BIT(Z, MAX);
           #if HAS_Z2_MAX
             UPDATE_ENDSTOP_BIT(Z2, MAX);
           #else
-            COPY_BIT(current_endstop_bits, Z_MAX, Z2_MAX);
+            COPY_BIT(live_state, Z_MAX, Z2_MAX);
           #endif
-          test_dual_z_endstops(Z_MAX, Z2_MAX);
         // If this pin is not hijacked for the bed probe
         // then it belongs to the Z endstop
         #elif DISABLED(Z_MIN_PROBE_ENDSTOP) || Z_MAX_PIN != Z_MIN_PROBE_PIN
-          UPDATE_ENDSTOP(Z, MAX);
+          UPDATE_ENDSTOP_BIT(Z, MAX);
+        #endif
+      #endif
+    }
+  }
+
+  // All endstops were updated.
+  #if ENABLED(ENDSTOP_NOISE_FILTER)
+    if (old_live_state != live_state) { // We detected a change. Reinit the timeout
+      /**
+       * Filtering out noise on endstops requires a delayed decision. Let's assume, due to noise,
+       * that 50% of endstop signal samples are good and 50% are bad (assuming normal distribution
+       * of random noise). Then the first sample has a 50% chance to be good or bad. The 2nd sample
+       * also has a 50% chance to be good or bad. The chances of 2 samples both being bad becomes
+       * 50% of 50%, or 25%. That was the previous implementation of Marlin endstop handling. It
+       * reduces chances of bad readings in half, at the cost of 1 extra sample period, but chances
+       * still exist. The only way to reduce them further is to increase the number of samples.
+       * To reduce the chance to 1% (1/128th) requires 7 samples (adding 7ms of delay).
+       */
+      endstop_poll_count = 7;
+      old_live_state = live_state;
+    }
+    else if (endstop_poll_count && !--endstop_poll_count)
+      validated_live_state = live_state;
+
+  #else
+
+    // Lets accept the new endstop values as valid - We assume hardware filtering of lines
+    esbits_t validated_live_state = live_state;
+
+  #endif
+
+  // Endstop readings are validated in validated_live_state
+
+  // Test the current status of an endstop
+  #define TEST_ENDSTOP(ENDSTOP) (TEST(validated_live_state, ENDSTOP))
+
+  // Record endstop was hit
+  #define _ENDSTOP_HIT(AXIS, MINMAX) SBI(hit_state, _ENDSTOP(AXIS, MINMAX))
+
+  // Call the endstop triggered routine for single endstops
+  #define PROCESS_ENDSTOP(AXIS,MINMAX) do { \
+      if (TEST_ENDSTOP(_ENDSTOP(AXIS, MINMAX))) { \
+        _ENDSTOP_HIT(AXIS, MINMAX); \
+        planner.endstop_triggered(_AXIS(AXIS)); \
+      } \
+    }while(0)
+
+  // Call the endstop triggered routine for single endstops
+  #define PROCESS_DUAL_ENDSTOP(AXIS1, AXIS2, MINMAX) do { \
+      if (TEST_ENDSTOP(_ENDSTOP(AXIS1, MINMAX)) || TEST_ENDSTOP(_ENDSTOP(AXIS2, MINMAX))) { \
+        _ENDSTOP_HIT(AXIS1, MINMAX); \
+        planner.endstop_triggered(_AXIS(AXIS1)); \
+      } \
+    }while(0)
+
+  #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && !(CORE_IS_XY || CORE_IS_XZ)
+    // If G38 command is active check Z_MIN_PROBE for ALL movement
+    if (G38_move) {
+      if (TEST_ENDSTOP(_ENDSTOP(Z, MIN_PROBE))) {
+        if      (stepper.movement_non_null(_AXIS(X))) { _ENDSTOP_HIT(X, MIN); planner.endstop_triggered(_AXIS(X)); }
+        else if (stepper.movement_non_null(_AXIS(Y))) { _ENDSTOP_HIT(Y, MIN); planner.endstop_triggered(_AXIS(Y)); }
+        else if (stepper.movement_non_null(_AXIS(Z))) { _ENDSTOP_HIT(Z, MIN); planner.endstop_triggered(_AXIS(Z)); }
+        G38_endstop_hit = true;
+      }
+    }
+  #endif
+
+  // Now, we must signal, after validation, if an endstop limit is pressed or not
+  if (X_MOVE_TEST) {
+    if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
+      #if HAS_X_MIN
+        #if ENABLED(X_DUAL_ENDSTOPS)
+          PROCESS_DUAL_ENDSTOP(X, X2, MIN);
+        #else
+          if (X_MIN_TEST) PROCESS_ENDSTOP(X, MIN);
+        #endif
+      #endif
+    }
+    else { // +direction
+      #if HAS_X_MAX
+        #if ENABLED(X_DUAL_ENDSTOPS)
+          PROCESS_DUAL_ENDSTOP(X, X2, MAX);
+        #else
+          if (X_MAX_TEST) PROCESS_ENDSTOP(X, MAX);
+        #endif
+      #endif
+    }
+  }
+
+  if (Y_MOVE_TEST) {
+    if (stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
+      #if HAS_Y_MIN
+        #if ENABLED(Y_DUAL_ENDSTOPS)
+          PROCESS_DUAL_ENDSTOP(Y, Y2, MIN);
+        #else
+          PROCESS_ENDSTOP(Y, MIN);
+        #endif
+      #endif
+    }
+    else { // +direction
+      #if HAS_Y_MAX
+        #if ENABLED(Y_DUAL_ENDSTOPS)
+          PROCESS_DUAL_ENDSTOP(Y, Y2, MAX);
+        #else
+          PROCESS_ENDSTOP(Y, MAX);
+        #endif
+      #endif
+    }
+  }
+
+  if (Z_MOVE_TEST) {
+    if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
+      #if HAS_Z_MIN
+        #if ENABLED(Z_DUAL_ENDSTOPS)
+          PROCESS_DUAL_ENDSTOP(Z, Z2, MIN);
+        #else
+          #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
+            if (z_probe_enabled) PROCESS_ENDSTOP(Z, MIN);
+          #else
+            PROCESS_ENDSTOP(Z, MIN);
+          #endif
+        #endif
+      #endif
+
+      // When closing the gap check the enabled probe
+      #if ENABLED(Z_MIN_PROBE_ENDSTOP)
+        if (z_probe_enabled) PROCESS_ENDSTOP(Z, MIN_PROBE);
+      #endif
+    }
+    else { // Z +direction. Gantry up, bed down.
+      #if HAS_Z_MAX
+        #if ENABLED(Z_DUAL_ENDSTOPS)
+          PROCESS_DUAL_ENDSTOP(Z, Z2, MAX);
+        #elif DISABLED(Z_MIN_PROBE_ENDSTOP) || Z_MAX_PIN != Z_MIN_PROBE_PIN
+          // If this pin is not hijacked for the bed probe
+          // then it belongs to the Z endstop
+          PROCESS_ENDSTOP(Z, MAX);
         #endif
       #endif
     }
   }
 } // Endstops::update()
 
 #if ENABLED(PINS_DEBUGGING)
 
   bool Endstops::monitor_flag = false;
 
@@ -669,104 +755,104 @@ void Endstops::update() {
    *
    * If a change is detected then the LED is toggled and
    * a message is sent out the serial port
    *
    * Yes, we could miss a rapid back & forth change but
    * that won't matter because this is all manual.
    *
    */
   void Endstops::monitor() {
 
-    static uint16_t old_endstop_bits_local = 0;
+    static uint16_t old_live_state_local = 0;
     static uint8_t local_LED_status = 0;
-    uint16_t current_endstop_bits_local = 0;
+    uint16_t live_state_local = 0;
 
     #if HAS_X_MIN
-      if (READ(X_MIN_PIN)) SBI(current_endstop_bits_local, X_MIN);
+      if (READ(X_MIN_PIN)) SBI(live_state_local, X_MIN);
     #endif
     #if HAS_X_MAX
-      if (READ(X_MAX_PIN)) SBI(current_endstop_bits_local, X_MAX);
+      if (READ(X_MAX_PIN)) SBI(live_state_local, X_MAX);
     #endif
     #if HAS_Y_MIN
-      if (READ(Y_MIN_PIN)) SBI(current_endstop_bits_local, Y_MIN);
+      if (READ(Y_MIN_PIN)) SBI(live_state_local, Y_MIN);
     #endif
     #if HAS_Y_MAX
-      if (READ(Y_MAX_PIN)) SBI(current_endstop_bits_local, Y_MAX);
+      if (READ(Y_MAX_PIN)) SBI(live_state_local, Y_MAX);
     #endif
     #if HAS_Z_MIN
-      if (READ(Z_MIN_PIN)) SBI(current_endstop_bits_local, Z_MIN);
+      if (READ(Z_MIN_PIN)) SBI(live_state_local, Z_MIN);
     #endif
     #if HAS_Z_MAX
-      if (READ(Z_MAX_PIN)) SBI(current_endstop_bits_local, Z_MAX);
+      if (READ(Z_MAX_PIN)) SBI(live_state_local, Z_MAX);
     #endif
     #if HAS_Z_MIN_PROBE_PIN
-      if (READ(Z_MIN_PROBE_PIN)) SBI(current_endstop_bits_local, Z_MIN_PROBE);
+      if (READ(Z_MIN_PROBE_PIN)) SBI(live_state_local, Z_MIN_PROBE);
     #endif
     #if HAS_X2_MIN
-      if (READ(X2_MIN_PIN)) SBI(current_endstop_bits_local, X2_MIN);
+      if (READ(X2_MIN_PIN)) SBI(live_state_local, X2_MIN);
     #endif
     #if HAS_X2_MAX
-      if (READ(X2_MAX_PIN)) SBI(current_endstop_bits_local, X2_MAX);
+      if (READ(X2_MAX_PIN)) SBI(live_state_local, X2_MAX);
     #endif
     #if HAS_Y2_MIN
-      if (READ(Y2_MIN_PIN)) SBI(current_endstop_bits_local, Y2_MIN);
+      if (READ(Y2_MIN_PIN)) SBI(live_state_local, Y2_MIN);
     #endif
     #if HAS_Y2_MAX
-      if (READ(Y2_MAX_PIN)) SBI(current_endstop_bits_local, Y2_MAX);
+      if (READ(Y2_MAX_PIN)) SBI(live_state_local, Y2_MAX);
     #endif
     #if HAS_Z2_MIN
-      if (READ(Z2_MIN_PIN)) SBI(current_endstop_bits_local, Z2_MIN);
+      if (READ(Z2_MIN_PIN)) SBI(live_state_local, Z2_MIN);
     #endif
     #if HAS_Z2_MAX
-      if (READ(Z2_MAX_PIN)) SBI(current_endstop_bits_local, Z2_MAX);
+      if (READ(Z2_MAX_PIN)) SBI(live_state_local, Z2_MAX);
     #endif
 
-    uint16_t endstop_change = current_endstop_bits_local ^ old_endstop_bits_local;
+    uint16_t endstop_change = live_state_local ^ old_live_state_local;
 
     if (endstop_change) {
       #if HAS_X_MIN
-        if (TEST(endstop_change, X_MIN)) SERIAL_PROTOCOLPAIR("  X_MIN:", TEST(current_endstop_bits_local, X_MIN));
+        if (TEST(endstop_change, X_MIN)) SERIAL_PROTOCOLPAIR("  X_MIN:", TEST(live_state_local, X_MIN));
       #endif
       #if HAS_X_MAX
-        if (TEST(endstop_change, X_MAX)) SERIAL_PROTOCOLPAIR("  X_MAX:", TEST(current_endstop_bits_local, X_MAX));
+        if (TEST(endstop_change, X_MAX)) SERIAL_PROTOCOLPAIR("  X_MAX:", TEST(live_state_local, X_MAX));
       #endif
       #if HAS_Y_MIN
-        if (TEST(endstop_change, Y_MIN)) SERIAL_PROTOCOLPAIR("  Y_MIN:", TEST(current_endstop_bits_local, Y_MIN));
+        if (TEST(endstop_change, Y_MIN)) SERIAL_PROTOCOLPAIR("  Y_MIN:", TEST(live_state_local, Y_MIN));
       #endif
       #if HAS_Y_MAX
-        if (TEST(endstop_change, Y_MAX)) SERIAL_PROTOCOLPAIR("  Y_MAX:", TEST(current_endstop_bits_local, Y_MAX));
+        if (TEST(endstop_change, Y_MAX)) SERIAL_PROTOCOLPAIR("  Y_MAX:", TEST(live_state_local, Y_MAX));
       #endif
       #if HAS_Z_MIN
-        if (TEST(endstop_change, Z_MIN)) SERIAL_PROTOCOLPAIR("  Z_MIN:", TEST(current_endstop_bits_local, Z_MIN));
+        if (TEST(endstop_change, Z_MIN)) SERIAL_PROTOCOLPAIR("  Z_MIN:", TEST(live_state_local, Z_MIN));
       #endif
       #if HAS_Z_MAX
-        if (TEST(endstop_change, Z_MAX)) SERIAL_PROTOCOLPAIR("  Z_MAX:", TEST(current_endstop_bits_local, Z_MAX));
+        if (TEST(endstop_change, Z_MAX)) SERIAL_PROTOCOLPAIR("  Z_MAX:", TEST(live_state_local, Z_MAX));
       #endif
       #if HAS_Z_MIN_PROBE_PIN
-        if (TEST(endstop_change, Z_MIN_PROBE)) SERIAL_PROTOCOLPAIR("  PROBE:", TEST(current_endstop_bits_local, Z_MIN_PROBE));
+        if (TEST(endstop_change, Z_MIN_PROBE)) SERIAL_PROTOCOLPAIR("  PROBE:", TEST(live_state_local, Z_MIN_PROBE));
       #endif
       #if HAS_X2_MIN
-        if (TEST(endstop_change, X2_MIN)) SERIAL_PROTOCOLPAIR("  X2_MIN:", TEST(current_endstop_bits_local, X2_MIN));
+        if (TEST(endstop_change, X2_MIN)) SERIAL_PROTOCOLPAIR("  X2_MIN:", TEST(live_state_local, X2_MIN));
       #endif
       #if HAS_X2_MAX
-        if (TEST(endstop_change, X2_MAX)) SERIAL_PROTOCOLPAIR("  X2_MAX:", TEST(current_endstop_bits_local, X2_MAX));
+        if (TEST(endstop_change, X2_MAX)) SERIAL_PROTOCOLPAIR("  X2_MAX:", TEST(live_state_local, X2_MAX));
       #endif
       #if HAS_Y2_MIN
-        if (TEST(endstop_change, Y2_MIN)) SERIAL_PROTOCOLPAIR("  Y2_MIN:", TEST(current_endstop_bits_local, Y2_MIN));
+        if (TEST(endstop_change, Y2_MIN)) SERIAL_PROTOCOLPAIR("  Y2_MIN:", TEST(live_state_local, Y2_MIN));
       #endif
       #if HAS_Y2_MAX
-        if (TEST(endstop_change, Y2_MAX)) SERIAL_PROTOCOLPAIR("  Y2_MAX:", TEST(current_endstop_bits_local, Y2_MAX));
+        if (TEST(endstop_change, Y2_MAX)) SERIAL_PROTOCOLPAIR("  Y2_MAX:", TEST(live_state_local, Y2_MAX));
       #endif
       #if HAS_Z2_MIN
-        if (TEST(endstop_change, Z2_MIN)) SERIAL_PROTOCOLPAIR("  Z2_MIN:", TEST(current_endstop_bits_local, Z2_MIN));
+        if (TEST(endstop_change, Z2_MIN)) SERIAL_PROTOCOLPAIR("  Z2_MIN:", TEST(live_state_local, Z2_MIN));
       #endif
       #if HAS_Z2_MAX
-        if (TEST(endstop_change, Z2_MAX)) SERIAL_PROTOCOLPAIR("  Z2_MAX:", TEST(current_endstop_bits_local, Z2_MAX));
+        if (TEST(endstop_change, Z2_MAX)) SERIAL_PROTOCOLPAIR("  Z2_MAX:", TEST(live_state_local, Z2_MAX));
       #endif
       SERIAL_PROTOCOLPGM("\n\n");
       analogWrite(LED_PIN, local_LED_status);
       local_LED_status ^= 255;
-      old_endstop_bits_local = current_endstop_bits_local;
+      old_live_state_local = live_state_local;
     }
   }
 
 #endif // PINS_DEBUGGING

commit 569df3fc0ccb8b000cc56dd55e6369008ed3f7a2
Author: etagle <ejtagle@hotmail.com>
Date:   Wed May 16 04:08:43 2018 -0300

    Fix interrupt-based endstop detection
    
    - Also implemented real endstop reading on interrupt.

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 17f9277ae4..d354774afe 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -25,32 +25,41 @@
  */
 
 #include "endstops.h"
 #include "stepper.h"
 
 #include "../Marlin.h"
 #include "../sd/cardreader.h"
 #include "../module/temperature.h"
 #include "../lcd/ultralcd.h"
 
-// TEST_ENDSTOP: test the old and the current status of an endstop
-#define TEST_ENDSTOP(ENDSTOP) (TEST(current_endstop_bits & old_endstop_bits, ENDSTOP))
+#if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
+  #include HAL_PATH(../HAL, endstop_interrupts.h)
+#endif
+
+// TEST_ENDSTOP: test the current status of an endstop
+#define TEST_ENDSTOP(ENDSTOP) (TEST(current_endstop_bits, ENDSTOP))
+
+#if HAS_BED_PROBE
+  #define ENDSTOPS_ENABLED  (endstops.enabled || endstops.z_probe_enabled)
+#else
+  #define ENDSTOPS_ENABLED  endstops.enabled
+#endif
 
 Endstops endstops;
 
 // public:
 
 bool Endstops::enabled, Endstops::enabled_globally; // Initialized by settings.load()
-volatile char Endstops::endstop_hit_bits; // use X_MIN, Y_MIN, Z_MIN and Z_MIN_PROBE as BIT value
+volatile uint8_t Endstops::endstop_hit_bits; // use X_MIN, Y_MIN, Z_MIN and Z_MIN_PROBE as BIT value
 
-Endstops::esbits_t Endstops::current_endstop_bits = 0,
-                   Endstops::old_endstop_bits = 0;
+Endstops::esbits_t Endstops::current_endstop_bits = 0;
 
 #if HAS_BED_PROBE
   volatile bool Endstops::z_probe_enabled = false;
 #endif
 
 // Initialized by settings.load()
 #if ENABLED(X_DUAL_ENDSTOPS)
   float Endstops::x_endstop_adj;
 #endif
 #if ENABLED(Y_DUAL_ENDSTOPS)
@@ -189,22 +198,107 @@ void Endstops::init() {
   #if ENABLED(Z_MIN_PROBE_ENDSTOP)
     #if ENABLED(ENDSTOPPULLUP_ZMIN_PROBE)
       SET_INPUT_PULLUP(Z_MIN_PROBE_PIN);
     #elif ENABLED(ENDSTOPPULLDOWN_ZMIN_PROBE)
       SET_INPUT_PULLDOWN(Z_MIN_PROBE_PIN);
     #else
       SET_INPUT(Z_MIN_PROBE_PIN);
     #endif
   #endif
 
+  #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
+    setup_endstop_interrupts();
+  #endif
+
+  // Enable endstops
+  enable_globally(
+    #if ENABLED(ENDSTOPS_ALWAYS_ON_DEFAULT)
+      true
+    #else
+      false
+    #endif
+  );
+
 } // Endstops::init
 
+// Called from ISR. A change was detected. Find out what happened!
+void Endstops::check_possible_change() { if (ENDSTOPS_ENABLED) endstops.update(); }
+
+// Called from ISR: Poll endstop state if required
+void Endstops::poll() {
+
+  #if ENABLED(PINS_DEBUGGING)
+    endstops.run_monitor();  // report changes in endstop status
+  #endif
+
+  #if DISABLED(ENDSTOP_INTERRUPTS_FEATURE)
+    if (ENDSTOPS_ENABLED) endstops.update();
+  #endif
+}
+
+void Endstops::enable_globally(const bool onoff) {
+  enabled_globally = enabled = onoff;
+
+  #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
+    if (onoff) endstops.update(); // If enabling, update state now
+  #endif
+}
+
+// Enable / disable endstop checking
+void Endstops::enable(const bool onoff) {
+  enabled = onoff;
+
+  #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
+    if (onoff) endstops.update(); // If enabling, update state now
+  #endif
+}
+
+
+// Disable / Enable endstops based on ENSTOPS_ONLY_FOR_HOMING and global enable
+void Endstops::not_homing() {
+  enabled = enabled_globally;
+
+  #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
+    if (enabled) endstops.update(); // If enabling, update state now
+  #endif
+}
+
+// Clear endstops (i.e., they were hit intentionally) to suppress the report
+void Endstops::hit_on_purpose() {
+  endstop_hit_bits = 0;
+
+  #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
+    if (enabled) endstops.update(); // If enabling, update state now
+  #endif
+}
+
+// Enable / disable endstop z-probe checking
+#if HAS_BED_PROBE
+  void Endstops::enable_z_probe(bool onoff) {
+    z_probe_enabled = onoff;
+
+    #if ENABLED(ENDSTOP_INTERRUPTS_FEATURE)
+      if (enabled) endstops.update(); // If enabling, update state now
+    #endif
+  }
+#endif
+
+#if ENABLED(PINS_DEBUGGING)
+  void Endstops::run_monitor() {
+    if (!monitor_flag) return;
+    static uint8_t monitor_count = 16;  // offset this check from the others
+    monitor_count += _BV(1);            //  15 Hz
+    monitor_count &= 0x7F;
+    if (!monitor_count) monitor();      // report changes in endstop status
+  }
+#endif
+
 void Endstops::report_state() {
   if (endstop_hit_bits) {
     #if ENABLED(ULTRA_LCD)
       char chrX = ' ', chrY = ' ', chrZ = ' ', chrP = ' ';
       #define _SET_STOP_CHAR(A,C) (chr## A = C)
     #else
       #define _SET_STOP_CHAR(A,C) ;
     #endif
 
     #define _ENDSTOP_HIT_ECHO(A,C) do{ \
@@ -293,52 +387,55 @@ void Endstops::M119() {
   #if ENABLED(Z_MIN_PROBE_ENDSTOP)
     SERIAL_PROTOCOLPGM(MSG_Z_PROBE);
     SERIAL_PROTOCOLLN(((READ(Z_MIN_PROBE_PIN)^Z_MIN_PROBE_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
   #endif
   #if ENABLED(FILAMENT_RUNOUT_SENSOR)
     SERIAL_PROTOCOLPGM(MSG_FILAMENT_RUNOUT_SENSOR);
     SERIAL_PROTOCOLLN(((READ(FIL_RUNOUT_PIN)^FIL_RUNOUT_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
   #endif
 } // Endstops::M119
 
+// The following routines are called from an ISR context. It could be the temperature ISR, the
+// endstop ISR or the Stepper ISR.
+
 #if ENABLED(X_DUAL_ENDSTOPS)
   void Endstops::test_dual_x_endstops(const EndstopEnum es1, const EndstopEnum es2) {
     const byte x_test = TEST_ENDSTOP(es1) | (TEST_ENDSTOP(es2) << 1); // bit 0 for X, bit 1 for X2
-    if (x_test && stepper.current_block->steps[X_AXIS] > 0) {
+    if (x_test && stepper.movement_non_null(X_AXIS)) {
       SBI(endstop_hit_bits, X_MIN);
       if (!stepper.performing_homing || (x_test == 0x3))  //if not performing home or if both endstops were trigged during homing...
-        stepper.kill_current_block();
+        stepper.quick_stop();
     }
   }
 #endif
 #if ENABLED(Y_DUAL_ENDSTOPS)
   void Endstops::test_dual_y_endstops(const EndstopEnum es1, const EndstopEnum es2) {
     const byte y_test = TEST_ENDSTOP(es1) | (TEST_ENDSTOP(es2) << 1); // bit 0 for Y, bit 1 for Y2
-    if (y_test && stepper.current_block->steps[Y_AXIS] > 0) {
+    if (y_test && stepper.movement_non_null(Y_AXIS)) {
       SBI(endstop_hit_bits, Y_MIN);
       if (!stepper.performing_homing || (y_test == 0x3))  //if not performing home or if both endstops were trigged during homing...
-        stepper.kill_current_block();
+        stepper.quick_stop();
     }
   }
 #endif
 #if ENABLED(Z_DUAL_ENDSTOPS)
   void Endstops::test_dual_z_endstops(const EndstopEnum es1, const EndstopEnum es2) {
     const byte z_test = TEST_ENDSTOP(es1) | (TEST_ENDSTOP(es2) << 1); // bit 0 for Z, bit 1 for Z2
-    if (z_test && stepper.current_block->steps[Z_AXIS] > 0) {
+    if (z_test && stepper.movement_non_null(Z_AXIS)) {
       SBI(endstop_hit_bits, Z_MIN);
       if (!stepper.performing_homing || (z_test == 0x3))  //if not performing home or if both endstops were trigged during homing...
-        stepper.kill_current_block();
+        stepper.quick_stop();
     }
   }
 #endif
 
-// Check endstops - Called from ISR!
+// Check endstops - Could be called from ISR!
 void Endstops::update() {
 
   #define _ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
   #define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN
   #define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_INVERTING
   #define _ENDSTOP_HIT(AXIS, MINMAX) SBI(endstop_hit_bits, _ENDSTOP(AXIS, MINMAX))
 
   #define SET_BIT(N,B,TF) do{ if (TF) SBI(N,B); else CBI(N,B); }while(0)
   // UPDATE_ENDSTOP_BIT: set the current endstop bits for an endstop to its status
   #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT(current_endstop_bits, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
@@ -351,230 +448,223 @@ void Endstops::update() {
         _ENDSTOP_HIT(AXIS, MINMAX); \
         planner.endstop_triggered(_AXIS(AXIS)); \
       } \
     }while(0)
 
   #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && !(CORE_IS_XY || CORE_IS_XZ)
     // If G38 command is active check Z_MIN_PROBE for ALL movement
     if (G38_move) {
       UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
       if (TEST_ENDSTOP(_ENDSTOP(Z, MIN_PROBE))) {
-        if      (stepper.current_block->steps[_AXIS(X)] > 0) { _ENDSTOP_HIT(X, MIN); planner.endstop_triggered(_AXIS(X)); }
-        else if (stepper.current_block->steps[_AXIS(Y)] > 0) { _ENDSTOP_HIT(Y, MIN); planner.endstop_triggered(_AXIS(Y)); }
-        else if (stepper.current_block->steps[_AXIS(Z)] > 0) { _ENDSTOP_HIT(Z, MIN); planner.endstop_triggered(_AXIS(Z)); }
+        if      (stepper.movement_non_null(_AXIS(X))) { _ENDSTOP_HIT(X, MIN); planner.endstop_triggered(_AXIS(X)); }
+        else if (stepper.movement_non_null(_AXIS(Y))) { _ENDSTOP_HIT(Y, MIN); planner.endstop_triggered(_AXIS(Y)); }
+        else if (stepper.movement_non_null(_AXIS(Z))) { _ENDSTOP_HIT(Z, MIN); planner.endstop_triggered(_AXIS(Z)); }
         G38_endstop_hit = true;
       }
     }
   #endif
 
   /**
    * Define conditions for checking endstops
    */
 
   #if IS_CORE
-    #define S_(N) stepper.current_block->steps[CORE_AXIS_##N]
+    #define S_(N) stepper.movement_non_null(CORE_AXIS_##N)
     #define D_(N) stepper.motor_direction(CORE_AXIS_##N)
   #endif
 
   #if CORE_IS_XY || CORE_IS_XZ
     /**
      * Head direction in -X axis for CoreXY and CoreXZ bots.
      *
      * If steps differ, both axes are moving.
      * If DeltaA == -DeltaB, the movement is only in the 2nd axis (Y or Z, handled below)
      * If DeltaA ==  DeltaB, the movement is only in the 1st axis (X)
      */
     #if ENABLED(COREXY) || ENABLED(COREXZ)
       #define X_CMP ==
     #else
       #define X_CMP !=
     #endif
     #define X_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && D_(1) X_CMP D_(2)) )
     #define X_AXIS_HEAD X_HEAD
   #else
-    #define X_MOVE_TEST stepper.current_block->steps[X_AXIS] > 0
+    #define X_MOVE_TEST stepper.movement_non_null(X_AXIS)
     #define X_AXIS_HEAD X_AXIS
   #endif
 
   #if CORE_IS_XY || CORE_IS_YZ
     /**
      * Head direction in -Y axis for CoreXY / CoreYZ bots.
      *
      * If steps differ, both axes are moving
      * If DeltaA ==  DeltaB, the movement is only in the 1st axis (X or Y)
      * If DeltaA == -DeltaB, the movement is only in the 2nd axis (Y or Z)
      */
     #if ENABLED(COREYX) || ENABLED(COREYZ)
       #define Y_CMP ==
     #else
       #define Y_CMP !=
     #endif
     #define Y_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && D_(1) Y_CMP D_(2)) )
     #define Y_AXIS_HEAD Y_HEAD
   #else
-    #define Y_MOVE_TEST stepper.current_block->steps[Y_AXIS] > 0
+    #define Y_MOVE_TEST stepper.movement_non_null(Y_AXIS)
     #define Y_AXIS_HEAD Y_AXIS
   #endif
 
   #if CORE_IS_XZ || CORE_IS_YZ
     /**
      * Head direction in -Z axis for CoreXZ or CoreYZ bots.
      *
      * If steps differ, both axes are moving
      * If DeltaA ==  DeltaB, the movement is only in the 1st axis (X or Y, already handled above)
      * If DeltaA == -DeltaB, the movement is only in the 2nd axis (Z)
      */
     #if ENABLED(COREZX) || ENABLED(COREZY)
       #define Z_CMP ==
     #else
       #define Z_CMP !=
     #endif
     #define Z_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && D_(1) Z_CMP D_(2)) )
     #define Z_AXIS_HEAD Z_HEAD
   #else
-    #define Z_MOVE_TEST stepper.current_block->steps[Z_AXIS] > 0
+    #define Z_MOVE_TEST stepper.movement_non_null(Z_AXIS)
     #define Z_AXIS_HEAD Z_AXIS
   #endif
 
   // With Dual X, endstops are only checked in the homing direction for the active extruder
   #if ENABLED(DUAL_X_CARRIAGE)
-    #define E0_ACTIVE stepper.current_block->active_extruder == 0
+    #define E0_ACTIVE stepper.movement_extruder() == 0
     #define X_MIN_TEST ((X_HOME_DIR < 0 && E0_ACTIVE) || (X2_HOME_DIR < 0 && !E0_ACTIVE))
     #define X_MAX_TEST ((X_HOME_DIR > 0 && E0_ACTIVE) || (X2_HOME_DIR > 0 && !E0_ACTIVE))
   #else
     #define X_MIN_TEST true
     #define X_MAX_TEST true
   #endif
 
   /**
    * Check and update endstops according to conditions
    */
-  if (stepper.current_block) {
-
-    if (X_MOVE_TEST) {
-      if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
-        #if HAS_X_MIN
-          #if ENABLED(X_DUAL_ENDSTOPS)
-            UPDATE_ENDSTOP_BIT(X, MIN);
-            #if HAS_X2_MIN
-              UPDATE_ENDSTOP_BIT(X2, MIN);
-            #else
-              COPY_BIT(current_endstop_bits, X_MIN, X2_MIN);
-            #endif
-            test_dual_x_endstops(X_MIN, X2_MIN);
+  if (X_MOVE_TEST) {
+    if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
+      #if HAS_X_MIN
+        #if ENABLED(X_DUAL_ENDSTOPS)
+          UPDATE_ENDSTOP_BIT(X, MIN);
+          #if HAS_X2_MIN
+            UPDATE_ENDSTOP_BIT(X2, MIN);
           #else
-            if (X_MIN_TEST) UPDATE_ENDSTOP(X, MIN);
+            COPY_BIT(current_endstop_bits, X_MIN, X2_MIN);
           #endif
+          test_dual_x_endstops(X_MIN, X2_MIN);
+        #else
+          if (X_MIN_TEST) UPDATE_ENDSTOP(X, MIN);
         #endif
-      }
-      else { // +direction
-        #if HAS_X_MAX
-          #if ENABLED(X_DUAL_ENDSTOPS)
-            UPDATE_ENDSTOP_BIT(X, MAX);
-            #if HAS_X2_MAX
-              UPDATE_ENDSTOP_BIT(X2, MAX);
-            #else
-              COPY_BIT(current_endstop_bits, X_MAX, X2_MAX);
-            #endif
-            test_dual_x_endstops(X_MAX, X2_MAX);
+      #endif
+    }
+    else { // +direction
+      #if HAS_X_MAX
+        #if ENABLED(X_DUAL_ENDSTOPS)
+          UPDATE_ENDSTOP_BIT(X, MAX);
+          #if HAS_X2_MAX
+            UPDATE_ENDSTOP_BIT(X2, MAX);
           #else
-            if (X_MAX_TEST) UPDATE_ENDSTOP(X, MAX);
+            COPY_BIT(current_endstop_bits, X_MAX, X2_MAX);
           #endif
+          test_dual_x_endstops(X_MAX, X2_MAX);
+        #else
+          if (X_MAX_TEST) UPDATE_ENDSTOP(X, MAX);
         #endif
-      }
+      #endif
     }
+  }
 
-    if (Y_MOVE_TEST) {
-      if (stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
-        #if HAS_Y_MIN
-          #if ENABLED(Y_DUAL_ENDSTOPS)
-            UPDATE_ENDSTOP_BIT(Y, MIN);
-            #if HAS_Y2_MIN
-              UPDATE_ENDSTOP_BIT(Y2, MIN);
-            #else
-              COPY_BIT(current_endstop_bits, Y_MIN, Y2_MIN);
-            #endif
-            test_dual_y_endstops(Y_MIN, Y2_MIN);
+  if (Y_MOVE_TEST) {
+    if (stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
+      #if HAS_Y_MIN
+        #if ENABLED(Y_DUAL_ENDSTOPS)
+          UPDATE_ENDSTOP_BIT(Y, MIN);
+          #if HAS_Y2_MIN
+            UPDATE_ENDSTOP_BIT(Y2, MIN);
           #else
-            UPDATE_ENDSTOP(Y, MIN);
+            COPY_BIT(current_endstop_bits, Y_MIN, Y2_MIN);
           #endif
+          test_dual_y_endstops(Y_MIN, Y2_MIN);
+        #else
+          UPDATE_ENDSTOP(Y, MIN);
         #endif
-      }
-      else { // +direction
-        #if HAS_Y_MAX
-          #if ENABLED(Y_DUAL_ENDSTOPS)
-            UPDATE_ENDSTOP_BIT(Y, MAX);
-            #if HAS_Y2_MAX
-              UPDATE_ENDSTOP_BIT(Y2, MAX);
-            #else
-              COPY_BIT(current_endstop_bits, Y_MAX, Y2_MAX);
-            #endif
-            test_dual_y_endstops(Y_MAX, Y2_MAX);
+      #endif
+    }
+    else { // +direction
+      #if HAS_Y_MAX
+        #if ENABLED(Y_DUAL_ENDSTOPS)
+          UPDATE_ENDSTOP_BIT(Y, MAX);
+          #if HAS_Y2_MAX
+            UPDATE_ENDSTOP_BIT(Y2, MAX);
           #else
-            UPDATE_ENDSTOP(Y, MAX);
+            COPY_BIT(current_endstop_bits, Y_MAX, Y2_MAX);
           #endif
+          test_dual_y_endstops(Y_MAX, Y2_MAX);
+        #else
+          UPDATE_ENDSTOP(Y, MAX);
         #endif
-      }
+      #endif
     }
+  }
 
-    if (Z_MOVE_TEST) {
-      if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
-        #if HAS_Z_MIN
-          #if ENABLED(Z_DUAL_ENDSTOPS)
-            UPDATE_ENDSTOP_BIT(Z, MIN);
-            #if HAS_Z2_MIN
-              UPDATE_ENDSTOP_BIT(Z2, MIN);
-            #else
-              COPY_BIT(current_endstop_bits, Z_MIN, Z2_MIN);
-            #endif
-            test_dual_z_endstops(Z_MIN, Z2_MIN);
+  if (Z_MOVE_TEST) {
+    if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
+      #if HAS_Z_MIN
+        #if ENABLED(Z_DUAL_ENDSTOPS)
+          UPDATE_ENDSTOP_BIT(Z, MIN);
+          #if HAS_Z2_MIN
+            UPDATE_ENDSTOP_BIT(Z2, MIN);
+          #else
+            COPY_BIT(current_endstop_bits, Z_MIN, Z2_MIN);
+          #endif
+          test_dual_z_endstops(Z_MIN, Z2_MIN);
+        #else
+          #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
+            if (z_probe_enabled) UPDATE_ENDSTOP(Z, MIN);
           #else
-            #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
-              if (z_probe_enabled) UPDATE_ENDSTOP(Z, MIN);
-            #else
-              UPDATE_ENDSTOP(Z, MIN);
-            #endif
+            UPDATE_ENDSTOP(Z, MIN);
           #endif
         #endif
+      #endif
 
-        // When closing the gap check the enabled probe
-        #if ENABLED(Z_MIN_PROBE_ENDSTOP)
-          if (z_probe_enabled) {
-            UPDATE_ENDSTOP(Z, MIN_PROBE);
-            if (TEST_ENDSTOP(Z_MIN_PROBE)) SBI(endstop_hit_bits, Z_MIN_PROBE);
-          }
-        #endif
-      }
-      else { // Z +direction. Gantry up, bed down.
-        #if HAS_Z_MAX
-          // Check both Z dual endstops
-          #if ENABLED(Z_DUAL_ENDSTOPS)
-            UPDATE_ENDSTOP_BIT(Z, MAX);
-            #if HAS_Z2_MAX
-              UPDATE_ENDSTOP_BIT(Z2, MAX);
-            #else
-              COPY_BIT(current_endstop_bits, Z_MAX, Z2_MAX);
-            #endif
-            test_dual_z_endstops(Z_MAX, Z2_MAX);
-          // If this pin is not hijacked for the bed probe
-          // then it belongs to the Z endstop
-          #elif DISABLED(Z_MIN_PROBE_ENDSTOP) || Z_MAX_PIN != Z_MIN_PROBE_PIN
-            UPDATE_ENDSTOP(Z, MAX);
+      // When closing the gap check the enabled probe
+      #if ENABLED(Z_MIN_PROBE_ENDSTOP)
+        if (z_probe_enabled) {
+          UPDATE_ENDSTOP(Z, MIN_PROBE);
+          if (TEST_ENDSTOP(Z_MIN_PROBE)) SBI(endstop_hit_bits, Z_MIN_PROBE);
+        }
+      #endif
+    }
+    else { // Z +direction. Gantry up, bed down.
+      #if HAS_Z_MAX
+        // Check both Z dual endstops
+        #if ENABLED(Z_DUAL_ENDSTOPS)
+          UPDATE_ENDSTOP_BIT(Z, MAX);
+          #if HAS_Z2_MAX
+            UPDATE_ENDSTOP_BIT(Z2, MAX);
+          #else
+            COPY_BIT(current_endstop_bits, Z_MAX, Z2_MAX);
           #endif
+          test_dual_z_endstops(Z_MAX, Z2_MAX);
+        // If this pin is not hijacked for the bed probe
+        // then it belongs to the Z endstop
+        #elif DISABLED(Z_MIN_PROBE_ENDSTOP) || Z_MAX_PIN != Z_MIN_PROBE_PIN
+          UPDATE_ENDSTOP(Z, MAX);
         #endif
-      }
+      #endif
     }
-
-  } // stepper.current_block
-
-  old_endstop_bits = current_endstop_bits;
-
+  }
 } // Endstops::update()
 
 #if ENABLED(PINS_DEBUGGING)
 
   bool Endstops::monitor_flag = false;
 
   /**
    * monitors endstops & Z probe for changes
    *
    * If a change is detected then the LED is toggled and

commit a11eb50a3eab6d58d595a67e526fb51190018db3
Author: etagle <ejtagle@hotmail.com>
Date:   Wed May 9 02:17:53 2018 -0300

    Refactor and optimize Stepper/Planner
    
    Better encapsulation and considerably reduce stepper jitter

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index f0942a3a3a..17f9277ae4 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -201,21 +201,21 @@ void Endstops::init() {
 void Endstops::report_state() {
   if (endstop_hit_bits) {
     #if ENABLED(ULTRA_LCD)
       char chrX = ' ', chrY = ' ', chrZ = ' ', chrP = ' ';
       #define _SET_STOP_CHAR(A,C) (chr## A = C)
     #else
       #define _SET_STOP_CHAR(A,C) ;
     #endif
 
     #define _ENDSTOP_HIT_ECHO(A,C) do{ \
-      SERIAL_ECHOPAIR(" " STRINGIFY(A) ":", stepper.triggered_position_mm(_AXIS(A))); \
+      SERIAL_ECHOPAIR(" " STRINGIFY(A) ":", planner.triggered_position_mm(_AXIS(A))); \
       _SET_STOP_CHAR(A,C); }while(0)
 
     #define _ENDSTOP_HIT_TEST(A,C) \
       if (TEST(endstop_hit_bits, A ##_MIN) || TEST(endstop_hit_bits, A ##_MAX)) \
         _ENDSTOP_HIT_ECHO(A,C)
 
     #define ENDSTOP_HIT_TEST_X() _ENDSTOP_HIT_TEST(X,'X')
     #define ENDSTOP_HIT_TEST_Y() _ENDSTOP_HIT_TEST(Y,'Y')
     #define ENDSTOP_HIT_TEST_Z() _ENDSTOP_HIT_TEST(Z,'Z')
 
@@ -231,21 +231,21 @@ void Endstops::report_state() {
     #endif
     SERIAL_EOL();
 
     #if ENABLED(ULTRA_LCD)
       lcd_status_printf_P(0, PSTR(MSG_LCD_ENDSTOPS " %c %c %c %c"), chrX, chrY, chrZ, chrP);
     #endif
 
     hit_on_purpose();
 
     #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED) && ENABLED(SDSUPPORT)
-      if (stepper.abort_on_endstop_hit) {
+      if (planner.abort_on_endstop_hit) {
         card.sdprinting = false;
         card.closefile();
         quickstop_stepper();
         thermalManager.disable_all_heaters(); // switch off all heaters.
       }
     #endif
   }
 } // Endstops::report_state
 
 void Endstops::M119() {
@@ -342,32 +342,32 @@ void Endstops::update() {
   #define SET_BIT(N,B,TF) do{ if (TF) SBI(N,B); else CBI(N,B); }while(0)
   // UPDATE_ENDSTOP_BIT: set the current endstop bits for an endstop to its status
   #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT(current_endstop_bits, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
   // COPY_BIT: copy the value of SRC_BIT to DST_BIT in DST
   #define COPY_BIT(DST, SRC_BIT, DST_BIT) SET_BIT(DST, DST_BIT, TEST(DST, SRC_BIT))
 
   #define UPDATE_ENDSTOP(AXIS,MINMAX) do { \
       UPDATE_ENDSTOP_BIT(AXIS, MINMAX); \
       if (TEST_ENDSTOP(_ENDSTOP(AXIS, MINMAX))) { \
         _ENDSTOP_HIT(AXIS, MINMAX); \
-        stepper.endstop_triggered(_AXIS(AXIS)); \
+        planner.endstop_triggered(_AXIS(AXIS)); \
       } \
     }while(0)
 
   #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && !(CORE_IS_XY || CORE_IS_XZ)
     // If G38 command is active check Z_MIN_PROBE for ALL movement
     if (G38_move) {
       UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
       if (TEST_ENDSTOP(_ENDSTOP(Z, MIN_PROBE))) {
-        if      (stepper.current_block->steps[_AXIS(X)] > 0) { _ENDSTOP_HIT(X, MIN); stepper.endstop_triggered(_AXIS(X)); }
-        else if (stepper.current_block->steps[_AXIS(Y)] > 0) { _ENDSTOP_HIT(Y, MIN); stepper.endstop_triggered(_AXIS(Y)); }
-        else if (stepper.current_block->steps[_AXIS(Z)] > 0) { _ENDSTOP_HIT(Z, MIN); stepper.endstop_triggered(_AXIS(Z)); }
+        if      (stepper.current_block->steps[_AXIS(X)] > 0) { _ENDSTOP_HIT(X, MIN); planner.endstop_triggered(_AXIS(X)); }
+        else if (stepper.current_block->steps[_AXIS(Y)] > 0) { _ENDSTOP_HIT(Y, MIN); planner.endstop_triggered(_AXIS(Y)); }
+        else if (stepper.current_block->steps[_AXIS(Z)] > 0) { _ENDSTOP_HIT(Z, MIN); planner.endstop_triggered(_AXIS(Z)); }
         G38_endstop_hit = true;
       }
     }
   #endif
 
   /**
    * Define conditions for checking endstops
    */
 
   #if IS_CORE

commit ba4c32eec52353159d5a5dd9c5a7402b8113a036
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 13 10:40:45 2018 -0500

    Followup to _AXIS patch

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index c7bb167b29..f0942a3a3a 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -201,21 +201,21 @@ void Endstops::init() {
 void Endstops::report_state() {
   if (endstop_hit_bits) {
     #if ENABLED(ULTRA_LCD)
       char chrX = ' ', chrY = ' ', chrZ = ' ', chrP = ' ';
       #define _SET_STOP_CHAR(A,C) (chr## A = C)
     #else
       #define _SET_STOP_CHAR(A,C) ;
     #endif
 
     #define _ENDSTOP_HIT_ECHO(A,C) do{ \
-      SERIAL_ECHOPAIR(" " STRINGIFY(A) ":", stepper.triggered_position_mm(A ##_AXIS)); \
+      SERIAL_ECHOPAIR(" " STRINGIFY(A) ":", stepper.triggered_position_mm(_AXIS(A))); \
       _SET_STOP_CHAR(A,C); }while(0)
 
     #define _ENDSTOP_HIT_TEST(A,C) \
       if (TEST(endstop_hit_bits, A ##_MIN) || TEST(endstop_hit_bits, A ##_MAX)) \
         _ENDSTOP_HIT_ECHO(A,C)
 
     #define ENDSTOP_HIT_TEST_X() _ENDSTOP_HIT_TEST(X,'X')
     #define ENDSTOP_HIT_TEST_Y() _ENDSTOP_HIT_TEST(Y,'Y')
     #define ENDSTOP_HIT_TEST_Z() _ENDSTOP_HIT_TEST(Z,'Z')
 

commit a5c6d3c7b88f90db911db79b00734dd215bf72c4
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Mar 20 04:20:45 2018 -0500

    Prevent null pointer crash in Endstops::update
    
    Thanks to Evgeny Kotsuba!

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index c6c84cee8f..c7bb167b29 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -441,133 +441,137 @@ void Endstops::update() {
     #define X_MIN_TEST ((X_HOME_DIR < 0 && E0_ACTIVE) || (X2_HOME_DIR < 0 && !E0_ACTIVE))
     #define X_MAX_TEST ((X_HOME_DIR > 0 && E0_ACTIVE) || (X2_HOME_DIR > 0 && !E0_ACTIVE))
   #else
     #define X_MIN_TEST true
     #define X_MAX_TEST true
   #endif
 
   /**
    * Check and update endstops according to conditions
    */
-  if (X_MOVE_TEST) {
-    if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
-      #if HAS_X_MIN
-        #if ENABLED(X_DUAL_ENDSTOPS)
-          UPDATE_ENDSTOP_BIT(X, MIN);
-          #if HAS_X2_MIN
-            UPDATE_ENDSTOP_BIT(X2, MIN);
+  if (stepper.current_block) {
+
+    if (X_MOVE_TEST) {
+      if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
+        #if HAS_X_MIN
+          #if ENABLED(X_DUAL_ENDSTOPS)
+            UPDATE_ENDSTOP_BIT(X, MIN);
+            #if HAS_X2_MIN
+              UPDATE_ENDSTOP_BIT(X2, MIN);
+            #else
+              COPY_BIT(current_endstop_bits, X_MIN, X2_MIN);
+            #endif
+            test_dual_x_endstops(X_MIN, X2_MIN);
           #else
-            COPY_BIT(current_endstop_bits, X_MIN, X2_MIN);
+            if (X_MIN_TEST) UPDATE_ENDSTOP(X, MIN);
           #endif
-          test_dual_x_endstops(X_MIN, X2_MIN);
-        #else
-          if (X_MIN_TEST) UPDATE_ENDSTOP(X, MIN);
         #endif
-      #endif
-    }
-    else { // +direction
-      #if HAS_X_MAX
-        #if ENABLED(X_DUAL_ENDSTOPS)
-          UPDATE_ENDSTOP_BIT(X, MAX);
-          #if HAS_X2_MAX
-            UPDATE_ENDSTOP_BIT(X2, MAX);
+      }
+      else { // +direction
+        #if HAS_X_MAX
+          #if ENABLED(X_DUAL_ENDSTOPS)
+            UPDATE_ENDSTOP_BIT(X, MAX);
+            #if HAS_X2_MAX
+              UPDATE_ENDSTOP_BIT(X2, MAX);
+            #else
+              COPY_BIT(current_endstop_bits, X_MAX, X2_MAX);
+            #endif
+            test_dual_x_endstops(X_MAX, X2_MAX);
           #else
-            COPY_BIT(current_endstop_bits, X_MAX, X2_MAX);
+            if (X_MAX_TEST) UPDATE_ENDSTOP(X, MAX);
           #endif
-          test_dual_x_endstops(X_MAX, X2_MAX);
-        #else
-          if (X_MAX_TEST) UPDATE_ENDSTOP(X, MAX);
         #endif
-      #endif
+      }
     }
-  }
 
-  if (Y_MOVE_TEST) {
-    if (stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
-      #if HAS_Y_MIN
-        #if ENABLED(Y_DUAL_ENDSTOPS)
-          UPDATE_ENDSTOP_BIT(Y, MIN);
-          #if HAS_Y2_MIN
-            UPDATE_ENDSTOP_BIT(Y2, MIN);
+    if (Y_MOVE_TEST) {
+      if (stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
+        #if HAS_Y_MIN
+          #if ENABLED(Y_DUAL_ENDSTOPS)
+            UPDATE_ENDSTOP_BIT(Y, MIN);
+            #if HAS_Y2_MIN
+              UPDATE_ENDSTOP_BIT(Y2, MIN);
+            #else
+              COPY_BIT(current_endstop_bits, Y_MIN, Y2_MIN);
+            #endif
+            test_dual_y_endstops(Y_MIN, Y2_MIN);
           #else
-            COPY_BIT(current_endstop_bits, Y_MIN, Y2_MIN);
+            UPDATE_ENDSTOP(Y, MIN);
           #endif
-          test_dual_y_endstops(Y_MIN, Y2_MIN);
-        #else
-          UPDATE_ENDSTOP(Y, MIN);
         #endif
-      #endif
-    }
-    else { // +direction
-      #if HAS_Y_MAX
-        #if ENABLED(Y_DUAL_ENDSTOPS)
-          UPDATE_ENDSTOP_BIT(Y, MAX);
-          #if HAS_Y2_MAX
-            UPDATE_ENDSTOP_BIT(Y2, MAX);
+      }
+      else { // +direction
+        #if HAS_Y_MAX
+          #if ENABLED(Y_DUAL_ENDSTOPS)
+            UPDATE_ENDSTOP_BIT(Y, MAX);
+            #if HAS_Y2_MAX
+              UPDATE_ENDSTOP_BIT(Y2, MAX);
+            #else
+              COPY_BIT(current_endstop_bits, Y_MAX, Y2_MAX);
+            #endif
+            test_dual_y_endstops(Y_MAX, Y2_MAX);
           #else
-            COPY_BIT(current_endstop_bits, Y_MAX, Y2_MAX);
+            UPDATE_ENDSTOP(Y, MAX);
           #endif
-          test_dual_y_endstops(Y_MAX, Y2_MAX);
-        #else
-          UPDATE_ENDSTOP(Y, MAX);
         #endif
-      #endif
+      }
     }
-  }
 
-  if (Z_MOVE_TEST) {
-    if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
-      #if HAS_Z_MIN
-        #if ENABLED(Z_DUAL_ENDSTOPS)
-          UPDATE_ENDSTOP_BIT(Z, MIN);
-          #if HAS_Z2_MIN
-            UPDATE_ENDSTOP_BIT(Z2, MIN);
-          #else
-            COPY_BIT(current_endstop_bits, Z_MIN, Z2_MIN);
-          #endif
-          test_dual_z_endstops(Z_MIN, Z2_MIN);
-        #else
-          #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
-            if (z_probe_enabled) UPDATE_ENDSTOP(Z, MIN);
+    if (Z_MOVE_TEST) {
+      if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
+        #if HAS_Z_MIN
+          #if ENABLED(Z_DUAL_ENDSTOPS)
+            UPDATE_ENDSTOP_BIT(Z, MIN);
+            #if HAS_Z2_MIN
+              UPDATE_ENDSTOP_BIT(Z2, MIN);
+            #else
+              COPY_BIT(current_endstop_bits, Z_MIN, Z2_MIN);
+            #endif
+            test_dual_z_endstops(Z_MIN, Z2_MIN);
           #else
-            UPDATE_ENDSTOP(Z, MIN);
+            #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
+              if (z_probe_enabled) UPDATE_ENDSTOP(Z, MIN);
+            #else
+              UPDATE_ENDSTOP(Z, MIN);
+            #endif
           #endif
         #endif
-      #endif
 
-      // When closing the gap check the enabled probe
-      #if ENABLED(Z_MIN_PROBE_ENDSTOP)
-        if (z_probe_enabled) {
-          UPDATE_ENDSTOP(Z, MIN_PROBE);
-          if (TEST_ENDSTOP(Z_MIN_PROBE)) SBI(endstop_hit_bits, Z_MIN_PROBE);
-        }
-      #endif
-    }
-    else { // Z +direction. Gantry up, bed down.
-      #if HAS_Z_MAX
-        // Check both Z dual endstops
-        #if ENABLED(Z_DUAL_ENDSTOPS)
-          UPDATE_ENDSTOP_BIT(Z, MAX);
-          #if HAS_Z2_MAX
-            UPDATE_ENDSTOP_BIT(Z2, MAX);
-          #else
-            COPY_BIT(current_endstop_bits, Z_MAX, Z2_MAX);
+        // When closing the gap check the enabled probe
+        #if ENABLED(Z_MIN_PROBE_ENDSTOP)
+          if (z_probe_enabled) {
+            UPDATE_ENDSTOP(Z, MIN_PROBE);
+            if (TEST_ENDSTOP(Z_MIN_PROBE)) SBI(endstop_hit_bits, Z_MIN_PROBE);
+          }
+        #endif
+      }
+      else { // Z +direction. Gantry up, bed down.
+        #if HAS_Z_MAX
+          // Check both Z dual endstops
+          #if ENABLED(Z_DUAL_ENDSTOPS)
+            UPDATE_ENDSTOP_BIT(Z, MAX);
+            #if HAS_Z2_MAX
+              UPDATE_ENDSTOP_BIT(Z2, MAX);
+            #else
+              COPY_BIT(current_endstop_bits, Z_MAX, Z2_MAX);
+            #endif
+            test_dual_z_endstops(Z_MAX, Z2_MAX);
+          // If this pin is not hijacked for the bed probe
+          // then it belongs to the Z endstop
+          #elif DISABLED(Z_MIN_PROBE_ENDSTOP) || Z_MAX_PIN != Z_MIN_PROBE_PIN
+            UPDATE_ENDSTOP(Z, MAX);
           #endif
-          test_dual_z_endstops(Z_MAX, Z2_MAX);
-        // If this pin is not hijacked for the bed probe
-        // then it belongs to the Z endstop
-        #elif DISABLED(Z_MIN_PROBE_ENDSTOP) || Z_MAX_PIN != Z_MIN_PROBE_PIN
-          UPDATE_ENDSTOP(Z, MAX);
         #endif
-      #endif
+      }
     }
-  }
+
+  } // stepper.current_block
 
   old_endstop_bits = current_endstop_bits;
 
 } // Endstops::update()
 
 #if ENABLED(PINS_DEBUGGING)
 
   bool Endstops::monitor_flag = false;
 
   /**

commit f10c87b442dd5a3aa0e5a327d85e5c509c2cb02b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Mar 10 05:56:04 2018 -0600

    Update Endstops class for 1.1.x parity

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 06472e112c..c6c84cee8f 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -35,40 +35,36 @@
 // TEST_ENDSTOP: test the old and the current status of an endstop
 #define TEST_ENDSTOP(ENDSTOP) (TEST(current_endstop_bits & old_endstop_bits, ENDSTOP))
 
 Endstops endstops;
 
 // public:
 
 bool Endstops::enabled, Endstops::enabled_globally; // Initialized by settings.load()
 volatile char Endstops::endstop_hit_bits; // use X_MIN, Y_MIN, Z_MIN and Z_MIN_PROBE as BIT value
 
-#if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
-  uint16_t
-#else
-  byte
-#endif
-    Endstops::current_endstop_bits = 0,
-    Endstops::old_endstop_bits = 0;
+Endstops::esbits_t Endstops::current_endstop_bits = 0,
+                   Endstops::old_endstop_bits = 0;
 
 #if HAS_BED_PROBE
   volatile bool Endstops::z_probe_enabled = false;
 #endif
 
+// Initialized by settings.load()
 #if ENABLED(X_DUAL_ENDSTOPS)
-  float Endstops::x_endstop_adj; // Initialized by settings.load()
+  float Endstops::x_endstop_adj;
 #endif
 #if ENABLED(Y_DUAL_ENDSTOPS)
-  float Endstops::y_endstop_adj; // Initialized by settings.load()
+  float Endstops::y_endstop_adj;
 #endif
 #if ENABLED(Z_DUAL_ENDSTOPS)
-  float Endstops::z_endstop_adj; // Initialized by settings.load()
+  float Endstops::z_endstop_adj;
 #endif
 
 /**
  * Class and Instance Methods
  */
 
 void Endstops::init() {
 
   #if HAS_X_MIN
     #if ENABLED(ENDSTOPPULLUP_XMIN)
@@ -348,21 +344,21 @@ void Endstops::update() {
   #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT(current_endstop_bits, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
   // COPY_BIT: copy the value of SRC_BIT to DST_BIT in DST
   #define COPY_BIT(DST, SRC_BIT, DST_BIT) SET_BIT(DST, DST_BIT, TEST(DST, SRC_BIT))
 
   #define UPDATE_ENDSTOP(AXIS,MINMAX) do { \
       UPDATE_ENDSTOP_BIT(AXIS, MINMAX); \
       if (TEST_ENDSTOP(_ENDSTOP(AXIS, MINMAX))) { \
         _ENDSTOP_HIT(AXIS, MINMAX); \
         stepper.endstop_triggered(_AXIS(AXIS)); \
       } \
-    } while(0)
+    }while(0)
 
   #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && !(CORE_IS_XY || CORE_IS_XZ)
     // If G38 command is active check Z_MIN_PROBE for ALL movement
     if (G38_move) {
       UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
       if (TEST_ENDSTOP(_ENDSTOP(Z, MIN_PROBE))) {
         if      (stepper.current_block->steps[_AXIS(X)] > 0) { _ENDSTOP_HIT(X, MIN); stepper.endstop_triggered(_AXIS(X)); }
         else if (stepper.current_block->steps[_AXIS(Y)] > 0) { _ENDSTOP_HIT(Y, MIN); stepper.endstop_triggered(_AXIS(Y)); }
         else if (stepper.current_block->steps[_AXIS(Z)] > 0) { _ENDSTOP_HIT(Z, MIN); stepper.endstop_triggered(_AXIS(Z)); }
         G38_endstop_hit = true;
@@ -445,21 +441,20 @@ void Endstops::update() {
     #define X_MIN_TEST ((X_HOME_DIR < 0 && E0_ACTIVE) || (X2_HOME_DIR < 0 && !E0_ACTIVE))
     #define X_MAX_TEST ((X_HOME_DIR > 0 && E0_ACTIVE) || (X2_HOME_DIR > 0 && !E0_ACTIVE))
   #else
     #define X_MIN_TEST true
     #define X_MAX_TEST true
   #endif
 
   /**
    * Check and update endstops according to conditions
    */
-
   if (X_MOVE_TEST) {
     if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
       #if HAS_X_MIN
         #if ENABLED(X_DUAL_ENDSTOPS)
           UPDATE_ENDSTOP_BIT(X, MIN);
           #if HAS_X2_MIN
             UPDATE_ENDSTOP_BIT(X2, MIN);
           #else
             COPY_BIT(current_endstop_bits, X_MIN, X2_MIN);
           #endif

commit 161ff9ff356e2ef608f510d28b87d28d287c05a5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Mar 9 08:54:48 2018 -0600

    Fix UPDATE_ENDSTOP for CorePQ compatibility
    
    Fixes #9939

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 9b424a95c4..06472e112c 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -344,21 +344,21 @@ void Endstops::update() {
   #define _ENDSTOP_HIT(AXIS, MINMAX) SBI(endstop_hit_bits, _ENDSTOP(AXIS, MINMAX))
 
   #define SET_BIT(N,B,TF) do{ if (TF) SBI(N,B); else CBI(N,B); }while(0)
   // UPDATE_ENDSTOP_BIT: set the current endstop bits for an endstop to its status
   #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT(current_endstop_bits, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
   // COPY_BIT: copy the value of SRC_BIT to DST_BIT in DST
   #define COPY_BIT(DST, SRC_BIT, DST_BIT) SET_BIT(DST, DST_BIT, TEST(DST, SRC_BIT))
 
   #define UPDATE_ENDSTOP(AXIS,MINMAX) do { \
       UPDATE_ENDSTOP_BIT(AXIS, MINMAX); \
-      if (TEST_ENDSTOP(_ENDSTOP(AXIS, MINMAX)) && stepper.current_block->steps[_AXIS(AXIS)] > 0) { \
+      if (TEST_ENDSTOP(_ENDSTOP(AXIS, MINMAX))) { \
         _ENDSTOP_HIT(AXIS, MINMAX); \
         stepper.endstop_triggered(_AXIS(AXIS)); \
       } \
     } while(0)
 
   #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && !(CORE_IS_XY || CORE_IS_XZ)
     // If G38 command is active check Z_MIN_PROBE for ALL movement
     if (G38_move) {
       UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
       if (TEST_ENDSTOP(_ENDSTOP(Z, MIN_PROBE))) {
@@ -475,21 +475,20 @@ void Endstops::update() {
           UPDATE_ENDSTOP_BIT(X, MAX);
           #if HAS_X2_MAX
             UPDATE_ENDSTOP_BIT(X2, MAX);
           #else
             COPY_BIT(current_endstop_bits, X_MAX, X2_MAX);
           #endif
           test_dual_x_endstops(X_MAX, X2_MAX);
         #else
           if (X_MAX_TEST) UPDATE_ENDSTOP(X, MAX);
         #endif
-
       #endif
     }
   }
 
   if (Y_MOVE_TEST) {
     if (stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
       #if HAS_Y_MIN
         #if ENABLED(Y_DUAL_ENDSTOPS)
           UPDATE_ENDSTOP_BIT(Y, MIN);
           #if HAS_Y2_MIN

commit ca55f2927ab7416c6f404cfdeade4c9d5103929c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Feb 18 19:26:23 2018 -0600

    Pulldown pin mode support (#9701)
    
    Implemented for LPC1768.

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index c57c71ff8f..9b424a95c4 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -66,116 +66,142 @@ volatile char Endstops::endstop_hit_bits; // use X_MIN, Y_MIN, Z_MIN and Z_MIN_P
 
 /**
  * Class and Instance Methods
  */
 
 void Endstops::init() {
 
   #if HAS_X_MIN
     #if ENABLED(ENDSTOPPULLUP_XMIN)
       SET_INPUT_PULLUP(X_MIN_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_XMIN)
+      SET_INPUT_PULLDOWN(X_MIN_PIN);
     #else
       SET_INPUT(X_MIN_PIN);
     #endif
   #endif
 
   #if HAS_X2_MIN
     #if ENABLED(ENDSTOPPULLUP_XMIN)
       SET_INPUT_PULLUP(X2_MIN_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_XMIN)
+      SET_INPUT_PULLDOWN(X2_MIN_PIN);
     #else
       SET_INPUT(X2_MIN_PIN);
     #endif
   #endif
 
   #if HAS_Y_MIN
     #if ENABLED(ENDSTOPPULLUP_YMIN)
       SET_INPUT_PULLUP(Y_MIN_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_YMIN)
+      SET_INPUT_PULLDOWN(Y_MIN_PIN);
     #else
       SET_INPUT(Y_MIN_PIN);
     #endif
   #endif
 
   #if HAS_Y2_MIN
     #if ENABLED(ENDSTOPPULLUP_YMIN)
       SET_INPUT_PULLUP(Y2_MIN_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_YMIN)
+      SET_INPUT_PULLDOWN(Y2_MIN_PIN);
     #else
       SET_INPUT(Y2_MIN_PIN);
     #endif
   #endif
 
   #if HAS_Z_MIN
     #if ENABLED(ENDSTOPPULLUP_ZMIN)
       SET_INPUT_PULLUP(Z_MIN_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_ZMIN)
+      SET_INPUT_PULLDOWN(Z_MIN_PIN);
     #else
       SET_INPUT(Z_MIN_PIN);
     #endif
   #endif
 
   #if HAS_Z2_MIN
     #if ENABLED(ENDSTOPPULLUP_ZMIN)
       SET_INPUT_PULLUP(Z2_MIN_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_ZMIN)
+      SET_INPUT_PULLDOWN(Z2_MIN_PIN);
     #else
       SET_INPUT(Z2_MIN_PIN);
     #endif
   #endif
 
   #if HAS_X_MAX
     #if ENABLED(ENDSTOPPULLUP_XMAX)
       SET_INPUT_PULLUP(X_MAX_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_XMAX)
+      SET_INPUT_PULLDOWN(X_MAX_PIN);
     #else
       SET_INPUT(X_MAX_PIN);
     #endif
   #endif
 
   #if HAS_X2_MAX
     #if ENABLED(ENDSTOPPULLUP_XMAX)
       SET_INPUT_PULLUP(X2_MAX_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_XMAX)
+      SET_INPUT_PULLDOWN(X2_MAX_PIN);
     #else
       SET_INPUT(X2_MAX_PIN);
     #endif
   #endif
 
   #if HAS_Y_MAX
     #if ENABLED(ENDSTOPPULLUP_YMAX)
       SET_INPUT_PULLUP(Y_MAX_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_YMAX)
+      SET_INPUT_PULLDOWN(Y_MAX_PIN);
     #else
       SET_INPUT(Y_MAX_PIN);
     #endif
   #endif
 
   #if HAS_Y2_MAX
     #if ENABLED(ENDSTOPPULLUP_YMAX)
       SET_INPUT_PULLUP(Y2_MAX_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_YMAX)
+      SET_INPUT_PULLDOWN(Y2_MAX_PIN);
     #else
       SET_INPUT(Y2_MAX_PIN);
     #endif
   #endif
 
   #if HAS_Z_MAX
     #if ENABLED(ENDSTOPPULLUP_ZMAX)
       SET_INPUT_PULLUP(Z_MAX_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_ZMAX)
+      SET_INPUT_PULLDOWN(Z_MAX_PIN);
     #else
       SET_INPUT(Z_MAX_PIN);
     #endif
   #endif
 
   #if HAS_Z2_MAX
     #if ENABLED(ENDSTOPPULLUP_ZMAX)
       SET_INPUT_PULLUP(Z2_MAX_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_ZMAX)
+      SET_INPUT_PULLDOWN(Z2_MAX_PIN);
     #else
       SET_INPUT(Z2_MAX_PIN);
     #endif
   #endif
 
   #if ENABLED(Z_MIN_PROBE_ENDSTOP)
     #if ENABLED(ENDSTOPPULLUP_ZMIN_PROBE)
       SET_INPUT_PULLUP(Z_MIN_PROBE_PIN);
+    #elif ENABLED(ENDSTOPPULLDOWN_ZMIN_PROBE)
+      SET_INPUT_PULLDOWN(Z_MIN_PROBE_PIN);
     #else
       SET_INPUT(Z_MIN_PROBE_PIN);
     #endif
   #endif
 
 } // Endstops::init
 
 void Endstops::report_state() {
   if (endstop_hit_bits) {
     #if ENABLED(ULTRA_LCD)

commit c251601916c69bf3a67bc62048c5694f03b410e5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Feb 1 23:58:35 2018 -0600

    Simplified SET_BIT, moved to endstops.cpp

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 3bc9a625dc..c57c71ff8f 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -310,20 +310,21 @@ void Endstops::M119() {
 #endif
 
 // Check endstops - Called from ISR!
 void Endstops::update() {
 
   #define _ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
   #define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN
   #define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_INVERTING
   #define _ENDSTOP_HIT(AXIS, MINMAX) SBI(endstop_hit_bits, _ENDSTOP(AXIS, MINMAX))
 
+  #define SET_BIT(N,B,TF) do{ if (TF) SBI(N,B); else CBI(N,B); }while(0)
   // UPDATE_ENDSTOP_BIT: set the current endstop bits for an endstop to its status
   #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT(current_endstop_bits, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
   // COPY_BIT: copy the value of SRC_BIT to DST_BIT in DST
   #define COPY_BIT(DST, SRC_BIT, DST_BIT) SET_BIT(DST, DST_BIT, TEST(DST, SRC_BIT))
 
   #define UPDATE_ENDSTOP(AXIS,MINMAX) do { \
       UPDATE_ENDSTOP_BIT(AXIS, MINMAX); \
       if (TEST_ENDSTOP(_ENDSTOP(AXIS, MINMAX)) && stepper.current_block->steps[_AXIS(AXIS)] > 0) { \
         _ENDSTOP_HIT(AXIS, MINMAX); \
         stepper.endstop_triggered(_AXIS(AXIS)); \

commit 441517bbe1625aa68a49aef0f98c6c4184e66dff
Author: √òystein Krog <oystein.krog@gmail.com>
Date:   Sun Jan 21 15:29:32 2018 +0100

    Fix DUAL_X_CARRIAGE endstops
    
    \#8170 fixed

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 32fed65bdc..3bc9a625dc 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -446,21 +446,21 @@ void Endstops::update() {
       #if HAS_X_MAX
         #if ENABLED(X_DUAL_ENDSTOPS)
           UPDATE_ENDSTOP_BIT(X, MAX);
           #if HAS_X2_MAX
             UPDATE_ENDSTOP_BIT(X2, MAX);
           #else
             COPY_BIT(current_endstop_bits, X_MAX, X2_MAX);
           #endif
           test_dual_x_endstops(X_MAX, X2_MAX);
         #else
-          if (X_MIN_TEST) UPDATE_ENDSTOP(X, MAX);
+          if (X_MAX_TEST) UPDATE_ENDSTOP(X, MAX);
         #endif
 
       #endif
     }
   }
 
   if (Y_MOVE_TEST) {
     if (stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
       #if HAS_Y_MIN
         #if ENABLED(Y_DUAL_ENDSTOPS)

commit 617993d0ea3fbdd1b20d1f24e019f9cea01f81eb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Nov 21 00:17:36 2017 -0600

    Patch for !!TEST (was _BV once?)

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index dae888611c..32fed65bdc 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -602,56 +602,56 @@ void Endstops::update() {
       if (READ(Z2_MIN_PIN)) SBI(current_endstop_bits_local, Z2_MIN);
     #endif
     #if HAS_Z2_MAX
       if (READ(Z2_MAX_PIN)) SBI(current_endstop_bits_local, Z2_MAX);
     #endif
 
     uint16_t endstop_change = current_endstop_bits_local ^ old_endstop_bits_local;
 
     if (endstop_change) {
       #if HAS_X_MIN
-        if (TEST(endstop_change, X_MIN)) SERIAL_PROTOCOLPAIR("  X_MIN:", !!TEST(current_endstop_bits_local, X_MIN));
+        if (TEST(endstop_change, X_MIN)) SERIAL_PROTOCOLPAIR("  X_MIN:", TEST(current_endstop_bits_local, X_MIN));
       #endif
       #if HAS_X_MAX
-        if (TEST(endstop_change, X_MAX)) SERIAL_PROTOCOLPAIR("  X_MAX:", !!TEST(current_endstop_bits_local, X_MAX));
+        if (TEST(endstop_change, X_MAX)) SERIAL_PROTOCOLPAIR("  X_MAX:", TEST(current_endstop_bits_local, X_MAX));
       #endif
       #if HAS_Y_MIN
-        if (TEST(endstop_change, Y_MIN)) SERIAL_PROTOCOLPAIR("  Y_MIN:", !!TEST(current_endstop_bits_local, Y_MIN));
+        if (TEST(endstop_change, Y_MIN)) SERIAL_PROTOCOLPAIR("  Y_MIN:", TEST(current_endstop_bits_local, Y_MIN));
       #endif
       #if HAS_Y_MAX
-        if (TEST(endstop_change, Y_MAX)) SERIAL_PROTOCOLPAIR("  Y_MAX:", !!TEST(current_endstop_bits_local, Y_MAX));
+        if (TEST(endstop_change, Y_MAX)) SERIAL_PROTOCOLPAIR("  Y_MAX:", TEST(current_endstop_bits_local, Y_MAX));
       #endif
       #if HAS_Z_MIN
-        if (TEST(endstop_change, Z_MIN)) SERIAL_PROTOCOLPAIR("  Z_MIN:", !!TEST(current_endstop_bits_local, Z_MIN));
+        if (TEST(endstop_change, Z_MIN)) SERIAL_PROTOCOLPAIR("  Z_MIN:", TEST(current_endstop_bits_local, Z_MIN));
       #endif
       #if HAS_Z_MAX
-        if (TEST(endstop_change, Z_MAX)) SERIAL_PROTOCOLPAIR("  Z_MAX:", !!TEST(current_endstop_bits_local, Z_MAX));
+        if (TEST(endstop_change, Z_MAX)) SERIAL_PROTOCOLPAIR("  Z_MAX:", TEST(current_endstop_bits_local, Z_MAX));
       #endif
       #if HAS_Z_MIN_PROBE_PIN
-        if (TEST(endstop_change, Z_MIN_PROBE)) SERIAL_PROTOCOLPAIR("  PROBE:", !!TEST(current_endstop_bits_local, Z_MIN_PROBE));
+        if (TEST(endstop_change, Z_MIN_PROBE)) SERIAL_PROTOCOLPAIR("  PROBE:", TEST(current_endstop_bits_local, Z_MIN_PROBE));
       #endif
       #if HAS_X2_MIN
-        if (TEST(endstop_change, X2_MIN)) SERIAL_PROTOCOLPAIR("  X2_MIN:", !!TEST(current_endstop_bits_local, X2_MIN));
+        if (TEST(endstop_change, X2_MIN)) SERIAL_PROTOCOLPAIR("  X2_MIN:", TEST(current_endstop_bits_local, X2_MIN));
       #endif
       #if HAS_X2_MAX
-        if (TEST(endstop_change, X2_MAX)) SERIAL_PROTOCOLPAIR("  X2_MAX:", !!TEST(current_endstop_bits_local, X2_MAX));
+        if (TEST(endstop_change, X2_MAX)) SERIAL_PROTOCOLPAIR("  X2_MAX:", TEST(current_endstop_bits_local, X2_MAX));
       #endif
       #if HAS_Y2_MIN
-        if (TEST(endstop_change, Y2_MIN)) SERIAL_PROTOCOLPAIR("  Y2_MIN:", !!TEST(current_endstop_bits_local, Y2_MIN));
+        if (TEST(endstop_change, Y2_MIN)) SERIAL_PROTOCOLPAIR("  Y2_MIN:", TEST(current_endstop_bits_local, Y2_MIN));
       #endif
       #if HAS_Y2_MAX
-        if (TEST(endstop_change, Y2_MAX)) SERIAL_PROTOCOLPAIR("  Y2_MAX:", !!TEST(current_endstop_bits_local, Y2_MAX));
+        if (TEST(endstop_change, Y2_MAX)) SERIAL_PROTOCOLPAIR("  Y2_MAX:", TEST(current_endstop_bits_local, Y2_MAX));
       #endif
       #if HAS_Z2_MIN
-        if (TEST(endstop_change, Z2_MIN)) SERIAL_PROTOCOLPAIR("  Z2_MIN:", !!TEST(current_endstop_bits_local, Z2_MIN));
+        if (TEST(endstop_change, Z2_MIN)) SERIAL_PROTOCOLPAIR("  Z2_MIN:", TEST(current_endstop_bits_local, Z2_MIN));
       #endif
       #if HAS_Z2_MAX
-        if (TEST(endstop_change, Z2_MAX)) SERIAL_PROTOCOLPAIR("  Z2_MAX:", !!TEST(current_endstop_bits_local, Z2_MAX));
+        if (TEST(endstop_change, Z2_MAX)) SERIAL_PROTOCOLPAIR("  Z2_MAX:", TEST(current_endstop_bits_local, Z2_MAX));
       #endif
       SERIAL_PROTOCOLPGM("\n\n");
       analogWrite(LED_PIN, local_LED_status);
       local_LED_status ^= 255;
       old_endstop_bits_local = current_endstop_bits_local;
     }
   }
 
 #endif // PINS_DEBUGGING

commit 723f2a77f6de40024508ea07fd7324e0987a2aa9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Oct 29 03:43:44 2017 -0500

    Implement support for Dual X and Y endstops

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index b194abd5df..dae888611c 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -35,58 +35,80 @@
 // TEST_ENDSTOP: test the old and the current status of an endstop
 #define TEST_ENDSTOP(ENDSTOP) (TEST(current_endstop_bits & old_endstop_bits, ENDSTOP))
 
 Endstops endstops;
 
 // public:
 
 bool Endstops::enabled, Endstops::enabled_globally; // Initialized by settings.load()
 volatile char Endstops::endstop_hit_bits; // use X_MIN, Y_MIN, Z_MIN and Z_MIN_PROBE as BIT value
 
-#if ENABLED(Z_DUAL_ENDSTOPS)
+#if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
   uint16_t
 #else
   byte
 #endif
     Endstops::current_endstop_bits = 0,
     Endstops::old_endstop_bits = 0;
 
 #if HAS_BED_PROBE
   volatile bool Endstops::z_probe_enabled = false;
 #endif
 
+#if ENABLED(X_DUAL_ENDSTOPS)
+  float Endstops::x_endstop_adj; // Initialized by settings.load()
+#endif
+#if ENABLED(Y_DUAL_ENDSTOPS)
+  float Endstops::y_endstop_adj; // Initialized by settings.load()
+#endif
 #if ENABLED(Z_DUAL_ENDSTOPS)
-  float Endstops::z_endstop_adj;
+  float Endstops::z_endstop_adj; // Initialized by settings.load()
 #endif
 
 /**
  * Class and Instance Methods
  */
 
 void Endstops::init() {
 
   #if HAS_X_MIN
     #if ENABLED(ENDSTOPPULLUP_XMIN)
       SET_INPUT_PULLUP(X_MIN_PIN);
     #else
       SET_INPUT(X_MIN_PIN);
     #endif
   #endif
 
+  #if HAS_X2_MIN
+    #if ENABLED(ENDSTOPPULLUP_XMIN)
+      SET_INPUT_PULLUP(X2_MIN_PIN);
+    #else
+      SET_INPUT(X2_MIN_PIN);
+    #endif
+  #endif
+
   #if HAS_Y_MIN
     #if ENABLED(ENDSTOPPULLUP_YMIN)
       SET_INPUT_PULLUP(Y_MIN_PIN);
     #else
       SET_INPUT(Y_MIN_PIN);
     #endif
   #endif
 
+  #if HAS_Y2_MIN
+    #if ENABLED(ENDSTOPPULLUP_YMIN)
+      SET_INPUT_PULLUP(Y2_MIN_PIN);
+    #else
+      SET_INPUT(Y2_MIN_PIN);
+    #endif
+  #endif
+
   #if HAS_Z_MIN
     #if ENABLED(ENDSTOPPULLUP_ZMIN)
       SET_INPUT_PULLUP(Z_MIN_PIN);
     #else
       SET_INPUT(Z_MIN_PIN);
     #endif
   #endif
 
   #if HAS_Z2_MIN
     #if ENABLED(ENDSTOPPULLUP_ZMIN)
@@ -97,28 +119,44 @@ void Endstops::init() {
   #endif
 
   #if HAS_X_MAX
     #if ENABLED(ENDSTOPPULLUP_XMAX)
       SET_INPUT_PULLUP(X_MAX_PIN);
     #else
       SET_INPUT(X_MAX_PIN);
     #endif
   #endif
 
+  #if HAS_X2_MAX
+    #if ENABLED(ENDSTOPPULLUP_XMAX)
+      SET_INPUT_PULLUP(X2_MAX_PIN);
+    #else
+      SET_INPUT(X2_MAX_PIN);
+    #endif
+  #endif
+
   #if HAS_Y_MAX
     #if ENABLED(ENDSTOPPULLUP_YMAX)
       SET_INPUT_PULLUP(Y_MAX_PIN);
     #else
       SET_INPUT(Y_MAX_PIN);
     #endif
   #endif
 
+  #if HAS_Y2_MAX
+    #if ENABLED(ENDSTOPPULLUP_YMAX)
+      SET_INPUT_PULLUP(Y2_MAX_PIN);
+    #else
+      SET_INPUT(Y2_MAX_PIN);
+    #endif
+  #endif
+
   #if HAS_Z_MAX
     #if ENABLED(ENDSTOPPULLUP_ZMAX)
       SET_INPUT_PULLUP(Z_MAX_PIN);
     #else
       SET_INPUT(Z_MAX_PIN);
     #endif
   #endif
 
   #if HAS_Z2_MAX
     #if ENABLED(ENDSTOPPULLUP_ZMAX)
@@ -183,74 +221,99 @@ void Endstops::report_state() {
         card.closefile();
         quickstop_stepper();
         thermalManager.disable_all_heaters(); // switch off all heaters.
       }
     #endif
   }
 } // Endstops::report_state
 
 void Endstops::M119() {
   SERIAL_PROTOCOLLNPGM(MSG_M119_REPORT);
+  #define ES_REPORT(AXIS) do{ \
+    SERIAL_PROTOCOLPGM(MSG_##AXIS); \
+    SERIAL_PROTOCOLLN(((READ(AXIS##_PIN)^AXIS##_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN)); \
+  }while(0)
   #if HAS_X_MIN
-    SERIAL_PROTOCOLPGM(MSG_X_MIN);
-    SERIAL_PROTOCOLLN(((READ(X_MIN_PIN)^X_MIN_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
+    ES_REPORT(X_MIN);
+  #endif
+  #if HAS_X2_MIN
+    ES_REPORT(X2_MIN);
   #endif
   #if HAS_X_MAX
-    SERIAL_PROTOCOLPGM(MSG_X_MAX);
-    SERIAL_PROTOCOLLN(((READ(X_MAX_PIN)^X_MAX_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
+    ES_REPORT(X_MAX);
+  #endif
+  #if HAS_X2_MAX
+    ES_REPORT(X2_MAX);
   #endif
   #if HAS_Y_MIN
-    SERIAL_PROTOCOLPGM(MSG_Y_MIN);
-    SERIAL_PROTOCOLLN(((READ(Y_MIN_PIN)^Y_MIN_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
+    ES_REPORT(Y_MIN);
+  #endif
+  #if HAS_Y2_MIN
+    ES_REPORT(Y2_MIN);
   #endif
   #if HAS_Y_MAX
-    SERIAL_PROTOCOLPGM(MSG_Y_MAX);
-    SERIAL_PROTOCOLLN(((READ(Y_MAX_PIN)^Y_MAX_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
+    ES_REPORT(Y_MAX);
+  #endif
+  #if HAS_Y2_MAX
+    ES_REPORT(Y2_MAX);
   #endif
   #if HAS_Z_MIN
-    SERIAL_PROTOCOLPGM(MSG_Z_MIN);
-    SERIAL_PROTOCOLLN(((READ(Z_MIN_PIN)^Z_MIN_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
+    ES_REPORT(Z_MIN);
   #endif
   #if HAS_Z2_MIN
-    SERIAL_PROTOCOLPGM(MSG_Z2_MIN);
-    SERIAL_PROTOCOLLN(((READ(Z2_MIN_PIN)^Z2_MIN_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
+    ES_REPORT(Z2_MIN);
   #endif
   #if HAS_Z_MAX
-    SERIAL_PROTOCOLPGM(MSG_Z_MAX);
-    SERIAL_PROTOCOLLN(((READ(Z_MAX_PIN)^Z_MAX_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
+    ES_REPORT(Z_MAX);
   #endif
   #if HAS_Z2_MAX
-    SERIAL_PROTOCOLPGM(MSG_Z2_MAX);
-    SERIAL_PROTOCOLLN(((READ(Z2_MAX_PIN)^Z2_MAX_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
+    ES_REPORT(Z2_MAX);
   #endif
   #if ENABLED(Z_MIN_PROBE_ENDSTOP)
     SERIAL_PROTOCOLPGM(MSG_Z_PROBE);
     SERIAL_PROTOCOLLN(((READ(Z_MIN_PROBE_PIN)^Z_MIN_PROBE_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
   #endif
   #if ENABLED(FILAMENT_RUNOUT_SENSOR)
     SERIAL_PROTOCOLPGM(MSG_FILAMENT_RUNOUT_SENSOR);
     SERIAL_PROTOCOLLN(((READ(FIL_RUNOUT_PIN)^FIL_RUNOUT_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
   #endif
 } // Endstops::M119
 
+#if ENABLED(X_DUAL_ENDSTOPS)
+  void Endstops::test_dual_x_endstops(const EndstopEnum es1, const EndstopEnum es2) {
+    const byte x_test = TEST_ENDSTOP(es1) | (TEST_ENDSTOP(es2) << 1); // bit 0 for X, bit 1 for X2
+    if (x_test && stepper.current_block->steps[X_AXIS] > 0) {
+      SBI(endstop_hit_bits, X_MIN);
+      if (!stepper.performing_homing || (x_test == 0x3))  //if not performing home or if both endstops were trigged during homing...
+        stepper.kill_current_block();
+    }
+  }
+#endif
+#if ENABLED(Y_DUAL_ENDSTOPS)
+  void Endstops::test_dual_y_endstops(const EndstopEnum es1, const EndstopEnum es2) {
+    const byte y_test = TEST_ENDSTOP(es1) | (TEST_ENDSTOP(es2) << 1); // bit 0 for Y, bit 1 for Y2
+    if (y_test && stepper.current_block->steps[Y_AXIS] > 0) {
+      SBI(endstop_hit_bits, Y_MIN);
+      if (!stepper.performing_homing || (y_test == 0x3))  //if not performing home or if both endstops were trigged during homing...
+        stepper.kill_current_block();
+    }
+  }
+#endif
 #if ENABLED(Z_DUAL_ENDSTOPS)
-
-  // Pass the result of the endstop test
   void Endstops::test_dual_z_endstops(const EndstopEnum es1, const EndstopEnum es2) {
-    byte z_test = TEST_ENDSTOP(es1) | (TEST_ENDSTOP(es2) << 1); // bit 0 for Z, bit 1 for Z2
+    const byte z_test = TEST_ENDSTOP(es1) | (TEST_ENDSTOP(es2) << 1); // bit 0 for Z, bit 1 for Z2
     if (z_test && stepper.current_block->steps[Z_AXIS] > 0) {
       SBI(endstop_hit_bits, Z_MIN);
       if (!stepper.performing_homing || (z_test == 0x3))  //if not performing home or if both endstops were trigged during homing...
         stepper.kill_current_block();
     }
   }
-
 #endif
 
 // Check endstops - Called from ISR!
 void Endstops::update() {
 
   #define _ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
   #define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN
   #define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_INVERTING
   #define _ENDSTOP_HIT(AXIS, MINMAX) SBI(endstop_hit_bits, _ENDSTOP(AXIS, MINMAX))
 
@@ -357,104 +420,131 @@ void Endstops::update() {
   #else
     #define X_MIN_TEST true
     #define X_MAX_TEST true
   #endif
 
   /**
    * Check and update endstops according to conditions
    */
 
   if (X_MOVE_TEST) {
-    if (stepper.motor_direction(X_AXIS_HEAD)) {
-      if (X_MIN_TEST) { // -direction
-        #if HAS_X_MIN
-          UPDATE_ENDSTOP(X, MIN);
+    if (stepper.motor_direction(X_AXIS_HEAD)) { // -direction
+      #if HAS_X_MIN
+        #if ENABLED(X_DUAL_ENDSTOPS)
+          UPDATE_ENDSTOP_BIT(X, MIN);
+          #if HAS_X2_MIN
+            UPDATE_ENDSTOP_BIT(X2, MIN);
+          #else
+            COPY_BIT(current_endstop_bits, X_MIN, X2_MIN);
+          #endif
+          test_dual_x_endstops(X_MIN, X2_MIN);
+        #else
+          if (X_MIN_TEST) UPDATE_ENDSTOP(X, MIN);
         #endif
-      }
+      #endif
     }
-    else if (X_MAX_TEST) { // +direction
+    else { // +direction
       #if HAS_X_MAX
-        UPDATE_ENDSTOP(X, MAX);
+        #if ENABLED(X_DUAL_ENDSTOPS)
+          UPDATE_ENDSTOP_BIT(X, MAX);
+          #if HAS_X2_MAX
+            UPDATE_ENDSTOP_BIT(X2, MAX);
+          #else
+            COPY_BIT(current_endstop_bits, X_MAX, X2_MAX);
+          #endif
+          test_dual_x_endstops(X_MAX, X2_MAX);
+        #else
+          if (X_MIN_TEST) UPDATE_ENDSTOP(X, MAX);
+        #endif
+
       #endif
     }
   }
 
   if (Y_MOVE_TEST) {
     if (stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
       #if HAS_Y_MIN
-        UPDATE_ENDSTOP(Y, MIN);
+        #if ENABLED(Y_DUAL_ENDSTOPS)
+          UPDATE_ENDSTOP_BIT(Y, MIN);
+          #if HAS_Y2_MIN
+            UPDATE_ENDSTOP_BIT(Y2, MIN);
+          #else
+            COPY_BIT(current_endstop_bits, Y_MIN, Y2_MIN);
+          #endif
+          test_dual_y_endstops(Y_MIN, Y2_MIN);
+        #else
+          UPDATE_ENDSTOP(Y, MIN);
+        #endif
       #endif
     }
     else { // +direction
       #if HAS_Y_MAX
-        UPDATE_ENDSTOP(Y, MAX);
+        #if ENABLED(Y_DUAL_ENDSTOPS)
+          UPDATE_ENDSTOP_BIT(Y, MAX);
+          #if HAS_Y2_MAX
+            UPDATE_ENDSTOP_BIT(Y2, MAX);
+          #else
+            COPY_BIT(current_endstop_bits, Y_MAX, Y2_MAX);
+          #endif
+          test_dual_y_endstops(Y_MAX, Y2_MAX);
+        #else
+          UPDATE_ENDSTOP(Y, MAX);
+        #endif
       #endif
     }
   }
 
   if (Z_MOVE_TEST) {
     if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
       #if HAS_Z_MIN
         #if ENABLED(Z_DUAL_ENDSTOPS)
-
           UPDATE_ENDSTOP_BIT(Z, MIN);
           #if HAS_Z2_MIN
             UPDATE_ENDSTOP_BIT(Z2, MIN);
           #else
             COPY_BIT(current_endstop_bits, Z_MIN, Z2_MIN);
           #endif
-
           test_dual_z_endstops(Z_MIN, Z2_MIN);
-
-        #else // !Z_DUAL_ENDSTOPS
-
+        #else
           #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
             if (z_probe_enabled) UPDATE_ENDSTOP(Z, MIN);
           #else
             UPDATE_ENDSTOP(Z, MIN);
           #endif
-
-        #endif // !Z_DUAL_ENDSTOPS
-
-      #endif // HAS_Z_MIN
+        #endif
+      #endif
 
       // When closing the gap check the enabled probe
       #if ENABLED(Z_MIN_PROBE_ENDSTOP)
         if (z_probe_enabled) {
           UPDATE_ENDSTOP(Z, MIN_PROBE);
           if (TEST_ENDSTOP(Z_MIN_PROBE)) SBI(endstop_hit_bits, Z_MIN_PROBE);
         }
       #endif
     }
     else { // Z +direction. Gantry up, bed down.
       #if HAS_Z_MAX
-
         // Check both Z dual endstops
         #if ENABLED(Z_DUAL_ENDSTOPS)
-
           UPDATE_ENDSTOP_BIT(Z, MAX);
           #if HAS_Z2_MAX
             UPDATE_ENDSTOP_BIT(Z2, MAX);
           #else
             COPY_BIT(current_endstop_bits, Z_MAX, Z2_MAX);
           #endif
-
           test_dual_z_endstops(Z_MAX, Z2_MAX);
-
         // If this pin is not hijacked for the bed probe
         // then it belongs to the Z endstop
         #elif DISABLED(Z_MIN_PROBE_ENDSTOP) || Z_MAX_PIN != Z_MIN_PROBE_PIN
-
           UPDATE_ENDSTOP(Z, MAX);
-
-        #endif // !Z_MIN_PROBE_PIN...
-      #endif // Z_MAX_PIN
+        #endif
+      #endif
     }
   }
 
   old_endstop_bits = current_endstop_bits;
 
 } // Endstops::update()
 
 #if ENABLED(PINS_DEBUGGING)
 
   bool Endstops::monitor_flag = false;
@@ -489,20 +579,32 @@ void Endstops::update() {
     #endif
     #if HAS_Z_MIN
       if (READ(Z_MIN_PIN)) SBI(current_endstop_bits_local, Z_MIN);
     #endif
     #if HAS_Z_MAX
       if (READ(Z_MAX_PIN)) SBI(current_endstop_bits_local, Z_MAX);
     #endif
     #if HAS_Z_MIN_PROBE_PIN
       if (READ(Z_MIN_PROBE_PIN)) SBI(current_endstop_bits_local, Z_MIN_PROBE);
     #endif
+    #if HAS_X2_MIN
+      if (READ(X2_MIN_PIN)) SBI(current_endstop_bits_local, X2_MIN);
+    #endif
+    #if HAS_X2_MAX
+      if (READ(X2_MAX_PIN)) SBI(current_endstop_bits_local, X2_MAX);
+    #endif
+    #if HAS_Y2_MIN
+      if (READ(Y2_MIN_PIN)) SBI(current_endstop_bits_local, Y2_MIN);
+    #endif
+    #if HAS_Y2_MAX
+      if (READ(Y2_MAX_PIN)) SBI(current_endstop_bits_local, Y2_MAX);
+    #endif
     #if HAS_Z2_MIN
       if (READ(Z2_MIN_PIN)) SBI(current_endstop_bits_local, Z2_MIN);
     #endif
     #if HAS_Z2_MAX
       if (READ(Z2_MAX_PIN)) SBI(current_endstop_bits_local, Z2_MAX);
     #endif
 
     uint16_t endstop_change = current_endstop_bits_local ^ old_endstop_bits_local;
 
     if (endstop_change) {
@@ -520,20 +622,32 @@ void Endstops::update() {
       #endif
       #if HAS_Z_MIN
         if (TEST(endstop_change, Z_MIN)) SERIAL_PROTOCOLPAIR("  Z_MIN:", !!TEST(current_endstop_bits_local, Z_MIN));
       #endif
       #if HAS_Z_MAX
         if (TEST(endstop_change, Z_MAX)) SERIAL_PROTOCOLPAIR("  Z_MAX:", !!TEST(current_endstop_bits_local, Z_MAX));
       #endif
       #if HAS_Z_MIN_PROBE_PIN
         if (TEST(endstop_change, Z_MIN_PROBE)) SERIAL_PROTOCOLPAIR("  PROBE:", !!TEST(current_endstop_bits_local, Z_MIN_PROBE));
       #endif
+      #if HAS_X2_MIN
+        if (TEST(endstop_change, X2_MIN)) SERIAL_PROTOCOLPAIR("  X2_MIN:", !!TEST(current_endstop_bits_local, X2_MIN));
+      #endif
+      #if HAS_X2_MAX
+        if (TEST(endstop_change, X2_MAX)) SERIAL_PROTOCOLPAIR("  X2_MAX:", !!TEST(current_endstop_bits_local, X2_MAX));
+      #endif
+      #if HAS_Y2_MIN
+        if (TEST(endstop_change, Y2_MIN)) SERIAL_PROTOCOLPAIR("  Y2_MIN:", !!TEST(current_endstop_bits_local, Y2_MIN));
+      #endif
+      #if HAS_Y2_MAX
+        if (TEST(endstop_change, Y2_MAX)) SERIAL_PROTOCOLPAIR("  Y2_MAX:", !!TEST(current_endstop_bits_local, Y2_MAX));
+      #endif
       #if HAS_Z2_MIN
         if (TEST(endstop_change, Z2_MIN)) SERIAL_PROTOCOLPAIR("  Z2_MIN:", !!TEST(current_endstop_bits_local, Z2_MIN));
       #endif
       #if HAS_Z2_MAX
         if (TEST(endstop_change, Z2_MAX)) SERIAL_PROTOCOLPAIR("  Z2_MAX:", !!TEST(current_endstop_bits_local, Z2_MAX));
       #endif
       SERIAL_PROTOCOLPGM("\n\n");
       analogWrite(LED_PIN, local_LED_status);
       local_LED_status ^= 255;
       old_endstop_bits_local = current_endstop_bits_local;

commit 64dfb464610e35c3a65748170b5f015ffe1bc9bd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 18 05:56:10 2017 -0500

    Move z_endstop_adj to Endstops

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 510f13df41..b194abd5df 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -47,20 +47,24 @@ volatile char Endstops::endstop_hit_bits; // use X_MIN, Y_MIN, Z_MIN and Z_MIN_P
 #else
   byte
 #endif
     Endstops::current_endstop_bits = 0,
     Endstops::old_endstop_bits = 0;
 
 #if HAS_BED_PROBE
   volatile bool Endstops::z_probe_enabled = false;
 #endif
 
+#if ENABLED(Z_DUAL_ENDSTOPS)
+  float Endstops::z_endstop_adj;
+#endif
+
 /**
  * Class and Instance Methods
  */
 
 void Endstops::init() {
 
   #if HAS_X_MIN
     #if ENABLED(ENDSTOPPULLUP_XMIN)
       SET_INPUT_PULLUP(X_MIN_PIN);
     #else

commit 2e20c53c9d3f1ef29a51db9030dd10b2be8c65fb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 18 05:55:09 2017 -0500

    Move endstop debug to Endstops

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index a7e4b7342e..510f13df41 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -443,10 +443,97 @@ void Endstops::update() {
           UPDATE_ENDSTOP(Z, MAX);
 
         #endif // !Z_MIN_PROBE_PIN...
       #endif // Z_MAX_PIN
     }
   }
 
   old_endstop_bits = current_endstop_bits;
 
 } // Endstops::update()
+
+#if ENABLED(PINS_DEBUGGING)
+
+  bool Endstops::monitor_flag = false;
+
+  /**
+   * monitors endstops & Z probe for changes
+   *
+   * If a change is detected then the LED is toggled and
+   * a message is sent out the serial port
+   *
+   * Yes, we could miss a rapid back & forth change but
+   * that won't matter because this is all manual.
+   *
+   */
+  void Endstops::monitor() {
+
+    static uint16_t old_endstop_bits_local = 0;
+    static uint8_t local_LED_status = 0;
+    uint16_t current_endstop_bits_local = 0;
+
+    #if HAS_X_MIN
+      if (READ(X_MIN_PIN)) SBI(current_endstop_bits_local, X_MIN);
+    #endif
+    #if HAS_X_MAX
+      if (READ(X_MAX_PIN)) SBI(current_endstop_bits_local, X_MAX);
+    #endif
+    #if HAS_Y_MIN
+      if (READ(Y_MIN_PIN)) SBI(current_endstop_bits_local, Y_MIN);
+    #endif
+    #if HAS_Y_MAX
+      if (READ(Y_MAX_PIN)) SBI(current_endstop_bits_local, Y_MAX);
+    #endif
+    #if HAS_Z_MIN
+      if (READ(Z_MIN_PIN)) SBI(current_endstop_bits_local, Z_MIN);
+    #endif
+    #if HAS_Z_MAX
+      if (READ(Z_MAX_PIN)) SBI(current_endstop_bits_local, Z_MAX);
+    #endif
+    #if HAS_Z_MIN_PROBE_PIN
+      if (READ(Z_MIN_PROBE_PIN)) SBI(current_endstop_bits_local, Z_MIN_PROBE);
+    #endif
+    #if HAS_Z2_MIN
+      if (READ(Z2_MIN_PIN)) SBI(current_endstop_bits_local, Z2_MIN);
+    #endif
+    #if HAS_Z2_MAX
+      if (READ(Z2_MAX_PIN)) SBI(current_endstop_bits_local, Z2_MAX);
+    #endif
+
+    uint16_t endstop_change = current_endstop_bits_local ^ old_endstop_bits_local;
+
+    if (endstop_change) {
+      #if HAS_X_MIN
+        if (TEST(endstop_change, X_MIN)) SERIAL_PROTOCOLPAIR("  X_MIN:", !!TEST(current_endstop_bits_local, X_MIN));
+      #endif
+      #if HAS_X_MAX
+        if (TEST(endstop_change, X_MAX)) SERIAL_PROTOCOLPAIR("  X_MAX:", !!TEST(current_endstop_bits_local, X_MAX));
+      #endif
+      #if HAS_Y_MIN
+        if (TEST(endstop_change, Y_MIN)) SERIAL_PROTOCOLPAIR("  Y_MIN:", !!TEST(current_endstop_bits_local, Y_MIN));
+      #endif
+      #if HAS_Y_MAX
+        if (TEST(endstop_change, Y_MAX)) SERIAL_PROTOCOLPAIR("  Y_MAX:", !!TEST(current_endstop_bits_local, Y_MAX));
+      #endif
+      #if HAS_Z_MIN
+        if (TEST(endstop_change, Z_MIN)) SERIAL_PROTOCOLPAIR("  Z_MIN:", !!TEST(current_endstop_bits_local, Z_MIN));
+      #endif
+      #if HAS_Z_MAX
+        if (TEST(endstop_change, Z_MAX)) SERIAL_PROTOCOLPAIR("  Z_MAX:", !!TEST(current_endstop_bits_local, Z_MAX));
+      #endif
+      #if HAS_Z_MIN_PROBE_PIN
+        if (TEST(endstop_change, Z_MIN_PROBE)) SERIAL_PROTOCOLPAIR("  PROBE:", !!TEST(current_endstop_bits_local, Z_MIN_PROBE));
+      #endif
+      #if HAS_Z2_MIN
+        if (TEST(endstop_change, Z2_MIN)) SERIAL_PROTOCOLPAIR("  Z2_MIN:", !!TEST(current_endstop_bits_local, Z2_MIN));
+      #endif
+      #if HAS_Z2_MAX
+        if (TEST(endstop_change, Z2_MAX)) SERIAL_PROTOCOLPAIR("  Z2_MAX:", !!TEST(current_endstop_bits_local, Z2_MAX));
+      #endif
+      SERIAL_PROTOCOLPGM("\n\n");
+      analogWrite(LED_PIN, local_LED_status);
+      local_LED_status ^= 255;
+      old_endstop_bits_local = current_endstop_bits_local;
+    }
+  }
+
+#endif // PINS_DEBUGGING

commit 3d8a0ab4b215a3869a0388e5c0ef35a6372ed7d5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 6 06:28:32 2017 -0500

    Module updates

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
index 8ff6c7668a..a7e4b7342e 100644
--- a/Marlin/src/module/endstops.cpp
+++ b/Marlin/src/module/endstops.cpp
@@ -17,26 +17,27 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
 
 /**
  * endstops.cpp - A singleton object to manage endstops
  */
 
-#include "Marlin.h"
-#include "cardreader.h"
 #include "endstops.h"
-#include "temperature.h"
 #include "stepper.h"
-#include "ultralcd.h"
+
+#include "../Marlin.h"
+#include "../sd/cardreader.h"
+#include "../module/temperature.h"
+#include "../lcd/ultralcd.h"
 
 // TEST_ENDSTOP: test the old and the current status of an endstop
 #define TEST_ENDSTOP(ENDSTOP) (TEST(current_endstop_bits & old_endstop_bits, ENDSTOP))
 
 Endstops endstops;
 
 // public:
 
 bool Endstops::enabled, Endstops::enabled_globally; // Initialized by settings.load()
 volatile char Endstops::endstop_hit_bits; // use X_MIN, Y_MIN, Z_MIN and Z_MIN_PROBE as BIT value

commit 0c9231fd04798c30830513a0cad8b204a6b9633f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 6 06:28:30 2017 -0500

    Move 'module' files

diff --git a/Marlin/src/module/endstops.cpp b/Marlin/src/module/endstops.cpp
new file mode 100644
index 0000000000..8ff6c7668a
--- /dev/null
+++ b/Marlin/src/module/endstops.cpp
@@ -0,0 +1,451 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * endstops.cpp - A singleton object to manage endstops
+ */
+
+#include "Marlin.h"
+#include "cardreader.h"
+#include "endstops.h"
+#include "temperature.h"
+#include "stepper.h"
+#include "ultralcd.h"
+
+// TEST_ENDSTOP: test the old and the current status of an endstop
+#define TEST_ENDSTOP(ENDSTOP) (TEST(current_endstop_bits & old_endstop_bits, ENDSTOP))
+
+Endstops endstops;
+
+// public:
+
+bool Endstops::enabled, Endstops::enabled_globally; // Initialized by settings.load()
+volatile char Endstops::endstop_hit_bits; // use X_MIN, Y_MIN, Z_MIN and Z_MIN_PROBE as BIT value
+
+#if ENABLED(Z_DUAL_ENDSTOPS)
+  uint16_t
+#else
+  byte
+#endif
+    Endstops::current_endstop_bits = 0,
+    Endstops::old_endstop_bits = 0;
+
+#if HAS_BED_PROBE
+  volatile bool Endstops::z_probe_enabled = false;
+#endif
+
+/**
+ * Class and Instance Methods
+ */
+
+void Endstops::init() {
+
+  #if HAS_X_MIN
+    #if ENABLED(ENDSTOPPULLUP_XMIN)
+      SET_INPUT_PULLUP(X_MIN_PIN);
+    #else
+      SET_INPUT(X_MIN_PIN);
+    #endif
+  #endif
+
+  #if HAS_Y_MIN
+    #if ENABLED(ENDSTOPPULLUP_YMIN)
+      SET_INPUT_PULLUP(Y_MIN_PIN);
+    #else
+      SET_INPUT(Y_MIN_PIN);
+    #endif
+  #endif
+
+  #if HAS_Z_MIN
+    #if ENABLED(ENDSTOPPULLUP_ZMIN)
+      SET_INPUT_PULLUP(Z_MIN_PIN);
+    #else
+      SET_INPUT(Z_MIN_PIN);
+    #endif
+  #endif
+
+  #if HAS_Z2_MIN
+    #if ENABLED(ENDSTOPPULLUP_ZMIN)
+      SET_INPUT_PULLUP(Z2_MIN_PIN);
+    #else
+      SET_INPUT(Z2_MIN_PIN);
+    #endif
+  #endif
+
+  #if HAS_X_MAX
+    #if ENABLED(ENDSTOPPULLUP_XMAX)
+      SET_INPUT_PULLUP(X_MAX_PIN);
+    #else
+      SET_INPUT(X_MAX_PIN);
+    #endif
+  #endif
+
+  #if HAS_Y_MAX
+    #if ENABLED(ENDSTOPPULLUP_YMAX)
+      SET_INPUT_PULLUP(Y_MAX_PIN);
+    #else
+      SET_INPUT(Y_MAX_PIN);
+    #endif
+  #endif
+
+  #if HAS_Z_MAX
+    #if ENABLED(ENDSTOPPULLUP_ZMAX)
+      SET_INPUT_PULLUP(Z_MAX_PIN);
+    #else
+      SET_INPUT(Z_MAX_PIN);
+    #endif
+  #endif
+
+  #if HAS_Z2_MAX
+    #if ENABLED(ENDSTOPPULLUP_ZMAX)
+      SET_INPUT_PULLUP(Z2_MAX_PIN);
+    #else
+      SET_INPUT(Z2_MAX_PIN);
+    #endif
+  #endif
+
+  #if ENABLED(Z_MIN_PROBE_ENDSTOP)
+    #if ENABLED(ENDSTOPPULLUP_ZMIN_PROBE)
+      SET_INPUT_PULLUP(Z_MIN_PROBE_PIN);
+    #else
+      SET_INPUT(Z_MIN_PROBE_PIN);
+    #endif
+  #endif
+
+} // Endstops::init
+
+void Endstops::report_state() {
+  if (endstop_hit_bits) {
+    #if ENABLED(ULTRA_LCD)
+      char chrX = ' ', chrY = ' ', chrZ = ' ', chrP = ' ';
+      #define _SET_STOP_CHAR(A,C) (chr## A = C)
+    #else
+      #define _SET_STOP_CHAR(A,C) ;
+    #endif
+
+    #define _ENDSTOP_HIT_ECHO(A,C) do{ \
+      SERIAL_ECHOPAIR(" " STRINGIFY(A) ":", stepper.triggered_position_mm(A ##_AXIS)); \
+      _SET_STOP_CHAR(A,C); }while(0)
+
+    #define _ENDSTOP_HIT_TEST(A,C) \
+      if (TEST(endstop_hit_bits, A ##_MIN) || TEST(endstop_hit_bits, A ##_MAX)) \
+        _ENDSTOP_HIT_ECHO(A,C)
+
+    #define ENDSTOP_HIT_TEST_X() _ENDSTOP_HIT_TEST(X,'X')
+    #define ENDSTOP_HIT_TEST_Y() _ENDSTOP_HIT_TEST(Y,'Y')
+    #define ENDSTOP_HIT_TEST_Z() _ENDSTOP_HIT_TEST(Z,'Z')
+
+    SERIAL_ECHO_START();
+    SERIAL_ECHOPGM(MSG_ENDSTOPS_HIT);
+    ENDSTOP_HIT_TEST_X();
+    ENDSTOP_HIT_TEST_Y();
+    ENDSTOP_HIT_TEST_Z();
+
+    #if ENABLED(Z_MIN_PROBE_ENDSTOP)
+      #define P_AXIS Z_AXIS
+      if (TEST(endstop_hit_bits, Z_MIN_PROBE)) _ENDSTOP_HIT_ECHO(P, 'P');
+    #endif
+    SERIAL_EOL();
+
+    #if ENABLED(ULTRA_LCD)
+      lcd_status_printf_P(0, PSTR(MSG_LCD_ENDSTOPS " %c %c %c %c"), chrX, chrY, chrZ, chrP);
+    #endif
+
+    hit_on_purpose();
+
+    #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED) && ENABLED(SDSUPPORT)
+      if (stepper.abort_on_endstop_hit) {
+        card.sdprinting = false;
+        card.closefile();
+        quickstop_stepper();
+        thermalManager.disable_all_heaters(); // switch off all heaters.
+      }
+    #endif
+  }
+} // Endstops::report_state
+
+void Endstops::M119() {
+  SERIAL_PROTOCOLLNPGM(MSG_M119_REPORT);
+  #if HAS_X_MIN
+    SERIAL_PROTOCOLPGM(MSG_X_MIN);
+    SERIAL_PROTOCOLLN(((READ(X_MIN_PIN)^X_MIN_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
+  #endif
+  #if HAS_X_MAX
+    SERIAL_PROTOCOLPGM(MSG_X_MAX);
+    SERIAL_PROTOCOLLN(((READ(X_MAX_PIN)^X_MAX_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
+  #endif
+  #if HAS_Y_MIN
+    SERIAL_PROTOCOLPGM(MSG_Y_MIN);
+    SERIAL_PROTOCOLLN(((READ(Y_MIN_PIN)^Y_MIN_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
+  #endif
+  #if HAS_Y_MAX
+    SERIAL_PROTOCOLPGM(MSG_Y_MAX);
+    SERIAL_PROTOCOLLN(((READ(Y_MAX_PIN)^Y_MAX_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
+  #endif
+  #if HAS_Z_MIN
+    SERIAL_PROTOCOLPGM(MSG_Z_MIN);
+    SERIAL_PROTOCOLLN(((READ(Z_MIN_PIN)^Z_MIN_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
+  #endif
+  #if HAS_Z2_MIN
+    SERIAL_PROTOCOLPGM(MSG_Z2_MIN);
+    SERIAL_PROTOCOLLN(((READ(Z2_MIN_PIN)^Z2_MIN_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
+  #endif
+  #if HAS_Z_MAX
+    SERIAL_PROTOCOLPGM(MSG_Z_MAX);
+    SERIAL_PROTOCOLLN(((READ(Z_MAX_PIN)^Z_MAX_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
+  #endif
+  #if HAS_Z2_MAX
+    SERIAL_PROTOCOLPGM(MSG_Z2_MAX);
+    SERIAL_PROTOCOLLN(((READ(Z2_MAX_PIN)^Z2_MAX_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
+  #endif
+  #if ENABLED(Z_MIN_PROBE_ENDSTOP)
+    SERIAL_PROTOCOLPGM(MSG_Z_PROBE);
+    SERIAL_PROTOCOLLN(((READ(Z_MIN_PROBE_PIN)^Z_MIN_PROBE_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
+  #endif
+  #if ENABLED(FILAMENT_RUNOUT_SENSOR)
+    SERIAL_PROTOCOLPGM(MSG_FILAMENT_RUNOUT_SENSOR);
+    SERIAL_PROTOCOLLN(((READ(FIL_RUNOUT_PIN)^FIL_RUNOUT_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
+  #endif
+} // Endstops::M119
+
+#if ENABLED(Z_DUAL_ENDSTOPS)
+
+  // Pass the result of the endstop test
+  void Endstops::test_dual_z_endstops(const EndstopEnum es1, const EndstopEnum es2) {
+    byte z_test = TEST_ENDSTOP(es1) | (TEST_ENDSTOP(es2) << 1); // bit 0 for Z, bit 1 for Z2
+    if (z_test && stepper.current_block->steps[Z_AXIS] > 0) {
+      SBI(endstop_hit_bits, Z_MIN);
+      if (!stepper.performing_homing || (z_test == 0x3))  //if not performing home or if both endstops were trigged during homing...
+        stepper.kill_current_block();
+    }
+  }
+
+#endif
+
+// Check endstops - Called from ISR!
+void Endstops::update() {
+
+  #define _ENDSTOP(AXIS, MINMAX) AXIS ##_## MINMAX
+  #define _ENDSTOP_PIN(AXIS, MINMAX) AXIS ##_## MINMAX ##_PIN
+  #define _ENDSTOP_INVERTING(AXIS, MINMAX) AXIS ##_## MINMAX ##_ENDSTOP_INVERTING
+  #define _ENDSTOP_HIT(AXIS, MINMAX) SBI(endstop_hit_bits, _ENDSTOP(AXIS, MINMAX))
+
+  // UPDATE_ENDSTOP_BIT: set the current endstop bits for an endstop to its status
+  #define UPDATE_ENDSTOP_BIT(AXIS, MINMAX) SET_BIT(current_endstop_bits, _ENDSTOP(AXIS, MINMAX), (READ(_ENDSTOP_PIN(AXIS, MINMAX)) != _ENDSTOP_INVERTING(AXIS, MINMAX)))
+  // COPY_BIT: copy the value of SRC_BIT to DST_BIT in DST
+  #define COPY_BIT(DST, SRC_BIT, DST_BIT) SET_BIT(DST, DST_BIT, TEST(DST, SRC_BIT))
+
+  #define UPDATE_ENDSTOP(AXIS,MINMAX) do { \
+      UPDATE_ENDSTOP_BIT(AXIS, MINMAX); \
+      if (TEST_ENDSTOP(_ENDSTOP(AXIS, MINMAX)) && stepper.current_block->steps[_AXIS(AXIS)] > 0) { \
+        _ENDSTOP_HIT(AXIS, MINMAX); \
+        stepper.endstop_triggered(_AXIS(AXIS)); \
+      } \
+    } while(0)
+
+  #if ENABLED(G38_PROBE_TARGET) && PIN_EXISTS(Z_MIN_PROBE) && !(CORE_IS_XY || CORE_IS_XZ)
+    // If G38 command is active check Z_MIN_PROBE for ALL movement
+    if (G38_move) {
+      UPDATE_ENDSTOP_BIT(Z, MIN_PROBE);
+      if (TEST_ENDSTOP(_ENDSTOP(Z, MIN_PROBE))) {
+        if      (stepper.current_block->steps[_AXIS(X)] > 0) { _ENDSTOP_HIT(X, MIN); stepper.endstop_triggered(_AXIS(X)); }
+        else if (stepper.current_block->steps[_AXIS(Y)] > 0) { _ENDSTOP_HIT(Y, MIN); stepper.endstop_triggered(_AXIS(Y)); }
+        else if (stepper.current_block->steps[_AXIS(Z)] > 0) { _ENDSTOP_HIT(Z, MIN); stepper.endstop_triggered(_AXIS(Z)); }
+        G38_endstop_hit = true;
+      }
+    }
+  #endif
+
+  /**
+   * Define conditions for checking endstops
+   */
+
+  #if IS_CORE
+    #define S_(N) stepper.current_block->steps[CORE_AXIS_##N]
+    #define D_(N) stepper.motor_direction(CORE_AXIS_##N)
+  #endif
+
+  #if CORE_IS_XY || CORE_IS_XZ
+    /**
+     * Head direction in -X axis for CoreXY and CoreXZ bots.
+     *
+     * If steps differ, both axes are moving.
+     * If DeltaA == -DeltaB, the movement is only in the 2nd axis (Y or Z, handled below)
+     * If DeltaA ==  DeltaB, the movement is only in the 1st axis (X)
+     */
+    #if ENABLED(COREXY) || ENABLED(COREXZ)
+      #define X_CMP ==
+    #else
+      #define X_CMP !=
+    #endif
+    #define X_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && D_(1) X_CMP D_(2)) )
+    #define X_AXIS_HEAD X_HEAD
+  #else
+    #define X_MOVE_TEST stepper.current_block->steps[X_AXIS] > 0
+    #define X_AXIS_HEAD X_AXIS
+  #endif
+
+  #if CORE_IS_XY || CORE_IS_YZ
+    /**
+     * Head direction in -Y axis for CoreXY / CoreYZ bots.
+     *
+     * If steps differ, both axes are moving
+     * If DeltaA ==  DeltaB, the movement is only in the 1st axis (X or Y)
+     * If DeltaA == -DeltaB, the movement is only in the 2nd axis (Y or Z)
+     */
+    #if ENABLED(COREYX) || ENABLED(COREYZ)
+      #define Y_CMP ==
+    #else
+      #define Y_CMP !=
+    #endif
+    #define Y_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && D_(1) Y_CMP D_(2)) )
+    #define Y_AXIS_HEAD Y_HEAD
+  #else
+    #define Y_MOVE_TEST stepper.current_block->steps[Y_AXIS] > 0
+    #define Y_AXIS_HEAD Y_AXIS
+  #endif
+
+  #if CORE_IS_XZ || CORE_IS_YZ
+    /**
+     * Head direction in -Z axis for CoreXZ or CoreYZ bots.
+     *
+     * If steps differ, both axes are moving
+     * If DeltaA ==  DeltaB, the movement is only in the 1st axis (X or Y, already handled above)
+     * If DeltaA == -DeltaB, the movement is only in the 2nd axis (Z)
+     */
+    #if ENABLED(COREZX) || ENABLED(COREZY)
+      #define Z_CMP ==
+    #else
+      #define Z_CMP !=
+    #endif
+    #define Z_MOVE_TEST ( S_(1) != S_(2) || (S_(1) > 0 && D_(1) Z_CMP D_(2)) )
+    #define Z_AXIS_HEAD Z_HEAD
+  #else
+    #define Z_MOVE_TEST stepper.current_block->steps[Z_AXIS] > 0
+    #define Z_AXIS_HEAD Z_AXIS
+  #endif
+
+  // With Dual X, endstops are only checked in the homing direction for the active extruder
+  #if ENABLED(DUAL_X_CARRIAGE)
+    #define E0_ACTIVE stepper.current_block->active_extruder == 0
+    #define X_MIN_TEST ((X_HOME_DIR < 0 && E0_ACTIVE) || (X2_HOME_DIR < 0 && !E0_ACTIVE))
+    #define X_MAX_TEST ((X_HOME_DIR > 0 && E0_ACTIVE) || (X2_HOME_DIR > 0 && !E0_ACTIVE))
+  #else
+    #define X_MIN_TEST true
+    #define X_MAX_TEST true
+  #endif
+
+  /**
+   * Check and update endstops according to conditions
+   */
+
+  if (X_MOVE_TEST) {
+    if (stepper.motor_direction(X_AXIS_HEAD)) {
+      if (X_MIN_TEST) { // -direction
+        #if HAS_X_MIN
+          UPDATE_ENDSTOP(X, MIN);
+        #endif
+      }
+    }
+    else if (X_MAX_TEST) { // +direction
+      #if HAS_X_MAX
+        UPDATE_ENDSTOP(X, MAX);
+      #endif
+    }
+  }
+
+  if (Y_MOVE_TEST) {
+    if (stepper.motor_direction(Y_AXIS_HEAD)) { // -direction
+      #if HAS_Y_MIN
+        UPDATE_ENDSTOP(Y, MIN);
+      #endif
+    }
+    else { // +direction
+      #if HAS_Y_MAX
+        UPDATE_ENDSTOP(Y, MAX);
+      #endif
+    }
+  }
+
+  if (Z_MOVE_TEST) {
+    if (stepper.motor_direction(Z_AXIS_HEAD)) { // Z -direction. Gantry down, bed up.
+      #if HAS_Z_MIN
+        #if ENABLED(Z_DUAL_ENDSTOPS)
+
+          UPDATE_ENDSTOP_BIT(Z, MIN);
+          #if HAS_Z2_MIN
+            UPDATE_ENDSTOP_BIT(Z2, MIN);
+          #else
+            COPY_BIT(current_endstop_bits, Z_MIN, Z2_MIN);
+          #endif
+
+          test_dual_z_endstops(Z_MIN, Z2_MIN);
+
+        #else // !Z_DUAL_ENDSTOPS
+
+          #if ENABLED(Z_MIN_PROBE_USES_Z_MIN_ENDSTOP_PIN)
+            if (z_probe_enabled) UPDATE_ENDSTOP(Z, MIN);
+          #else
+            UPDATE_ENDSTOP(Z, MIN);
+          #endif
+
+        #endif // !Z_DUAL_ENDSTOPS
+
+      #endif // HAS_Z_MIN
+
+      // When closing the gap check the enabled probe
+      #if ENABLED(Z_MIN_PROBE_ENDSTOP)
+        if (z_probe_enabled) {
+          UPDATE_ENDSTOP(Z, MIN_PROBE);
+          if (TEST_ENDSTOP(Z_MIN_PROBE)) SBI(endstop_hit_bits, Z_MIN_PROBE);
+        }
+      #endif
+    }
+    else { // Z +direction. Gantry up, bed down.
+      #if HAS_Z_MAX
+
+        // Check both Z dual endstops
+        #if ENABLED(Z_DUAL_ENDSTOPS)
+
+          UPDATE_ENDSTOP_BIT(Z, MAX);
+          #if HAS_Z2_MAX
+            UPDATE_ENDSTOP_BIT(Z2, MAX);
+          #else
+            COPY_BIT(current_endstop_bits, Z_MAX, Z2_MAX);
+          #endif
+
+          test_dual_z_endstops(Z_MAX, Z2_MAX);
+
+        // If this pin is not hijacked for the bed probe
+        // then it belongs to the Z endstop
+        #elif DISABLED(Z_MIN_PROBE_ENDSTOP) || Z_MAX_PIN != Z_MIN_PROBE_PIN
+
+          UPDATE_ENDSTOP(Z, MAX);
+
+        #endif // !Z_MIN_PROBE_PIN...
+      #endif // Z_MAX_PIN
+    }
+  }
+
+  old_endstop_bits = current_endstop_bits;
+
+} // Endstops::update()
