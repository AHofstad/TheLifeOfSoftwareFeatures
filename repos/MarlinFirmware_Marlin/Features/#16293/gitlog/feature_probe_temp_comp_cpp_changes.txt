commit 2ef71c6ebaa1f1b496eb369879fe22c69cf9adb4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Jun 12 16:38:14 2023 -0500

    ‚ôªÔ∏è Simplify SERIAL_ECHO (#25928)
    
    Since this increases AVR code size, try to optimize further.

diff --git a/Marlin/src/feature/probe_temp_comp.cpp b/Marlin/src/feature/probe_temp_comp.cpp
index 2b362a2186..f640a9fd2f 100644
--- a/Marlin/src/feature/probe_temp_comp.cpp
+++ b/Marlin/src/feature/probe_temp_comp.cpp
@@ -87,14 +87,9 @@ void ProbeTempComp::print_offsets() {
   for (uint8_t s = 0; s < TSI_COUNT; ++s) {
     celsius_t temp = cali_info[s].start_temp;
     for (int16_t i = -1; i < cali_info[s].measurements; ++i) {
-      SERIAL_ECHOF(
-        TERN_(PTC_BED, s == TSI_BED ? F("Bed") :)
-        TERN_(PTC_HOTEND, s == TSI_EXT ? F("Extruder") :)
-        F("Probe")
-      );
-      SERIAL_ECHOLNPGM(
-        " temp: ", temp,
-        "C; Offset: ", i < 0 ? 0.0f : sensor_z_offsets[s][i], " um"
+      SERIAL_ECHOLN(
+        TERN_(PTC_BED, s == TSI_BED ? F("Bed") :) TERN_(PTC_HOTEND, s == TSI_EXT ? F("Extruder") :) F("Probe"),
+        F(" temp: "), temp, F("C; Offset: "), i < 0 ? 0.0f : sensor_z_offsets[s][i], F(" um")
       );
       temp += cali_info[s].temp_resolution;
     }

commit 86c811660ebf0b3fcbae2f34273d4c9d0c22abc4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:30:34 2023 -0500

    üßë‚Äçüíª Remove LOOP macros (#25917)

diff --git a/Marlin/src/feature/probe_temp_comp.cpp b/Marlin/src/feature/probe_temp_comp.cpp
index b5f636e698..2b362a2186 100644
--- a/Marlin/src/feature/probe_temp_comp.cpp
+++ b/Marlin/src/feature/probe_temp_comp.cpp
@@ -66,13 +66,13 @@ float ProbeTempComp::init_measurement; // = 0.0
 bool ProbeTempComp::enabled = true;
 
 void ProbeTempComp::reset() {
-  TERN_(PTC_PROBE, LOOP_L_N(i, PTC_PROBE_COUNT) z_offsets_probe[i] = z_offsets_probe_default[i]);
-  TERN_(PTC_BED, LOOP_L_N(i, PTC_BED_COUNT) z_offsets_bed[i] = z_offsets_bed_default[i]);
-  TERN_(PTC_HOTEND, LOOP_L_N(i, PTC_HOTEND_COUNT) z_offsets_hotend[i] = z_offsets_hotend_default[i]);
+  TERN_(PTC_PROBE, for (uint8_t i = 0; i < PTC_PROBE_COUNT; ++i) z_offsets_probe[i] = z_offsets_probe_default[i]);
+  TERN_(PTC_BED, for (uint8_t i = 0; i < PTC_BED_COUNT; ++i) z_offsets_bed[i] = z_offsets_bed_default[i]);
+  TERN_(PTC_HOTEND, for (uint8_t i = 0; i < PTC_HOTEND_COUNT; ++i) z_offsets_hotend[i] = z_offsets_hotend_default[i]);
 }
 
 void ProbeTempComp::clear_offsets(const TempSensorID tsi) {
-  LOOP_L_N(i, cali_info[tsi].measurements)
+  for (uint8_t i = 0; i < cali_info[tsi].measurements; ++i)
     sensor_z_offsets[tsi][i] = 0;
   calib_idx = 0;
 }
@@ -84,7 +84,7 @@ bool ProbeTempComp::set_offset(const TempSensorID tsi, const uint8_t idx, const
 }
 
 void ProbeTempComp::print_offsets() {
-  LOOP_L_N(s, TSI_COUNT) {
+  for (uint8_t s = 0; s < TSI_COUNT; ++s) {
     celsius_t temp = cali_info[s].start_temp;
     for (int16_t i = -1; i < cali_info[s].measurements; ++i) {
       SERIAL_ECHOF(
@@ -232,7 +232,7 @@ bool ProbeTempComp::linear_regression(const TempSensorID tsi, float &k, float &d
         sum_xy = 0, sum_y = 0;
 
   float xi = static_cast<float>(start_temp);
-  LOOP_L_N(i, calib_idx) {
+  for (uint8_t i = 0; i < calib_idx; ++i) {
     const float yi = static_cast<float>(data[i]);
     xi += res_temp;
     sum_x += xi;

commit 8f8427ec8f69705e09ca226d9f16da6b82634439
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Tue Feb 22 01:15:52 2022 +0000

    ‚ö°Ô∏è Apply PTC on all probing (#23764)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/feature/probe_temp_comp.cpp b/Marlin/src/feature/probe_temp_comp.cpp
index 9a975d6763..b5f636e698 100644
--- a/Marlin/src/feature/probe_temp_comp.cpp
+++ b/Marlin/src/feature/probe_temp_comp.cpp
@@ -28,6 +28,7 @@
 
 #include "probe_temp_comp.h"
 #include <math.h>
+#include "../module/temperature.h"
 
 ProbeTempComp ptc;
 
@@ -62,6 +63,7 @@ constexpr temp_calib_t ProbeTempComp::cali_info[TSI_COUNT];
 
 uint8_t ProbeTempComp::calib_idx; // = 0
 float ProbeTempComp::init_measurement; // = 0.0
+bool ProbeTempComp::enabled = true;
 
 void ProbeTempComp::reset() {
   TERN_(PTC_PROBE, LOOP_L_N(i, PTC_PROBE_COUNT) z_offsets_probe[i] = z_offsets_probe_default[i]);
@@ -169,6 +171,13 @@ bool ProbeTempComp::finish_calibration(const TempSensorID tsi) {
   return true;
 }
 
+void ProbeTempComp::apply_compensation(float &meas_z) {
+  if (!enabled) return;
+  TERN_(PTC_BED,    compensate_measurement(TSI_BED,   thermalManager.degBed(),     meas_z));
+  TERN_(PTC_PROBE,  compensate_measurement(TSI_PROBE, thermalManager.degProbe(),   meas_z));
+  TERN_(PTC_HOTEND, compensate_measurement(TSI_EXT,   thermalManager.degHotend(0), meas_z));
+}
+
 void ProbeTempComp::compensate_measurement(const TempSensorID tsi, const celsius_t temp, float &meas_z) {
   const uint8_t measurements = cali_info[tsi].measurements;
   const celsius_t start_temp = cali_info[tsi].start_temp,

commit 296a6137cd06ce06f062767ab1b59f99ee95a094
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Mon Nov 1 23:03:50 2021 +0000

    üö∏ More flexible Probe Temperature Compensation (#23033)

diff --git a/Marlin/src/feature/probe_temp_comp.cpp b/Marlin/src/feature/probe_temp_comp.cpp
index 5f3bc985e6..9a975d6763 100644
--- a/Marlin/src/feature/probe_temp_comp.cpp
+++ b/Marlin/src/feature/probe_temp_comp.cpp
@@ -22,39 +22,53 @@
 
 #include "../inc/MarlinConfigPre.h"
 
-#if ENABLED(PROBE_TEMP_COMPENSATION)
+#if HAS_PTC
 
 //#define DEBUG_PTC   // Print extra debug output with 'M871'
 
 #include "probe_temp_comp.h"
 #include <math.h>
 
-ProbeTempComp temp_comp;
+ProbeTempComp ptc;
 
-int16_t ProbeTempComp::z_offsets_probe[cali_info_init[TSI_PROBE].measurements],  // = {0}
-        ProbeTempComp::z_offsets_bed[cali_info_init[TSI_BED].measurements];      // = {0}
+#if ENABLED(PTC_PROBE)
+  constexpr int16_t z_offsets_probe_default[PTC_PROBE_COUNT] = PTC_PROBE_ZOFFS;
+  int16_t ProbeTempComp::z_offsets_probe[PTC_PROBE_COUNT] = PTC_PROBE_ZOFFS;
+#endif
 
-#if ENABLED(USE_TEMP_EXT_COMPENSATION)
-  int16_t ProbeTempComp::z_offsets_ext[cali_info_init[TSI_EXT].measurements];    // = {0}
+#if ENABLED(PTC_BED)
+  constexpr int16_t z_offsets_bed_default[PTC_BED_COUNT] = PTC_BED_ZOFFS;
+  int16_t ProbeTempComp::z_offsets_bed[PTC_BED_COUNT] = PTC_BED_ZOFFS;
 #endif
 
-int16_t *ProbeTempComp::sensor_z_offsets[TSI_COUNT] = {
-  ProbeTempComp::z_offsets_probe, ProbeTempComp::z_offsets_bed
-  OPTARG(USE_TEMP_EXT_COMPENSATION, ProbeTempComp::z_offsets_ext)
-};
+#if ENABLED(PTC_HOTEND)
+  constexpr int16_t z_offsets_hotend_default[PTC_HOTEND_COUNT] = PTC_HOTEND_ZOFFS;
+  int16_t ProbeTempComp::z_offsets_hotend[PTC_HOTEND_COUNT] = PTC_HOTEND_ZOFFS;
+#endif
 
-const temp_calib_t ProbeTempComp::cali_info[TSI_COUNT] = {
-  cali_info_init[TSI_PROBE], cali_info_init[TSI_BED]
-  OPTARG(USE_TEMP_EXT_COMPENSATION, cali_info_init[TSI_EXT])
+int16_t *ProbeTempComp::sensor_z_offsets[TSI_COUNT] = {
+  #if ENABLED(PTC_PROBE)
+    ProbeTempComp::z_offsets_probe,
+  #endif
+  #if ENABLED(PTC_BED)
+    ProbeTempComp::z_offsets_bed,
+  #endif
+  #if ENABLED(PTC_HOTEND)
+    ProbeTempComp::z_offsets_hotend,
+  #endif
 };
 
-constexpr xyz_pos_t ProbeTempComp::park_point;
-constexpr xy_pos_t ProbeTempComp::measure_point;
-constexpr celsius_t ProbeTempComp::probe_calib_bed_temp;
+constexpr temp_calib_t ProbeTempComp::cali_info[TSI_COUNT];
 
 uint8_t ProbeTempComp::calib_idx; // = 0
 float ProbeTempComp::init_measurement; // = 0.0
 
+void ProbeTempComp::reset() {
+  TERN_(PTC_PROBE, LOOP_L_N(i, PTC_PROBE_COUNT) z_offsets_probe[i] = z_offsets_probe_default[i]);
+  TERN_(PTC_BED, LOOP_L_N(i, PTC_BED_COUNT) z_offsets_bed[i] = z_offsets_bed_default[i]);
+  TERN_(PTC_HOTEND, LOOP_L_N(i, PTC_HOTEND_COUNT) z_offsets_hotend[i] = z_offsets_hotend_default[i]);
+}
+
 void ProbeTempComp::clear_offsets(const TempSensorID tsi) {
   LOOP_L_N(i, cali_info[tsi].measurements)
     sensor_z_offsets[tsi][i] = 0;
@@ -71,10 +85,9 @@ void ProbeTempComp::print_offsets() {
   LOOP_L_N(s, TSI_COUNT) {
     celsius_t temp = cali_info[s].start_temp;
     for (int16_t i = -1; i < cali_info[s].measurements; ++i) {
-      SERIAL_ECHOF(s == TSI_BED ? F("Bed") :
-        #if ENABLED(USE_TEMP_EXT_COMPENSATION)
-          s == TSI_EXT ? F("Extruder") :
-        #endif
+      SERIAL_ECHOF(
+        TERN_(PTC_BED, s == TSI_BED ? F("Bed") :)
+        TERN_(PTC_HOTEND, s == TSI_EXT ? F("Extruder") :)
         F("Probe")
       );
       SERIAL_ECHOLNPGM(
@@ -100,21 +113,13 @@ void ProbeTempComp::prepare_new_calibration(const_float_t init_meas_z) {
 }
 
 void ProbeTempComp::push_back_new_measurement(const TempSensorID tsi, const_float_t meas_z) {
-  switch (tsi) {
-    case TSI_PROBE:
-    case TSI_BED:
-    //case TSI_EXT:
-      if (calib_idx >= cali_info[tsi].measurements) return;
-      sensor_z_offsets[tsi][calib_idx++] = static_cast<int16_t>(meas_z * 1000.0f - init_measurement * 1000.0f);
-    default: break;
-  }
+  if (calib_idx >= cali_info[tsi].measurements) return;
+  sensor_z_offsets[tsi][calib_idx++] = static_cast<int16_t>((meas_z - init_measurement) * 1000.0f);
 }
 
 bool ProbeTempComp::finish_calibration(const TempSensorID tsi) {
-  if (tsi != TSI_PROBE && tsi != TSI_BED) return false;
-
-  if (calib_idx < 3) {
-    SERIAL_ECHOLNPGM("!Insufficient measurements (min. 3).");
+  if (!calib_idx) {
+    SERIAL_ECHOLNPGM("!No measurements.");
     clear_offsets(tsi);
     return false;
   }
@@ -130,16 +135,15 @@ bool ProbeTempComp::finish_calibration(const TempSensorID tsi) {
     SERIAL_ECHOLNPGM("Got ", calib_idx, " measurements. ");
     if (linear_regression(tsi, k, d)) {
       SERIAL_ECHOPGM("Applying linear extrapolation");
-      calib_idx--;
       for (; calib_idx < measurements; ++calib_idx) {
-        const celsius_float_t temp = start_temp + float(calib_idx) * res_temp;
+        const celsius_float_t temp = start_temp + float(calib_idx + 1) * res_temp;
         data[calib_idx] = static_cast<int16_t>(k * temp + d);
       }
     }
     else {
       // Simply use the last measured value for higher temperatures
       SERIAL_ECHOPGM("Failed to extrapolate");
-      const int16_t last_val = data[calib_idx];
+      const int16_t last_val = data[calib_idx-1];
       for (; calib_idx < measurements; ++calib_idx)
         data[calib_idx] = last_val;
     }
@@ -157,7 +161,7 @@ bool ProbeTempComp::finish_calibration(const TempSensorID tsi) {
     // Restrict the max. offset difference between two probings
     if (calib_idx > 0 && ABS(data[calib_idx - 1] - data[calib_idx]) > 800) {
       SERIAL_ECHOLNPGM("!Invalid Z-offset between two probings detected (0-0.8).");
-      clear_offsets(TSI_PROBE);
+      clear_offsets(tsi);
       return false;
     }
   }
@@ -168,8 +172,8 @@ bool ProbeTempComp::finish_calibration(const TempSensorID tsi) {
 void ProbeTempComp::compensate_measurement(const TempSensorID tsi, const celsius_t temp, float &meas_z) {
   const uint8_t measurements = cali_info[tsi].measurements;
   const celsius_t start_temp = cali_info[tsi].start_temp,
-                    end_temp = cali_info[tsi].end_temp,
-                    res_temp = cali_info[tsi].temp_resolution;
+                  res_temp = cali_info[tsi].temp_resolution,
+                  end_temp = start_temp + measurements * res_temp;
   const int16_t * const data = sensor_z_offsets[tsi];
 
   // Given a data index, return { celsius, zoffset } in the form { x, y }
@@ -208,9 +212,7 @@ void ProbeTempComp::compensate_measurement(const TempSensorID tsi, const celsius
 }
 
 bool ProbeTempComp::linear_regression(const TempSensorID tsi, float &k, float &d) {
-  if (tsi != TSI_PROBE && tsi != TSI_BED) return false;
-
-  if (!WITHIN(calib_idx, 2, cali_info[tsi].measurements)) return false;
+  if (!WITHIN(calib_idx, 1, cali_info[tsi].measurements)) return false;
 
   const celsius_t start_temp = cali_info[tsi].start_temp,
                     res_temp = cali_info[tsi].temp_resolution;
@@ -243,4 +245,4 @@ bool ProbeTempComp::linear_regression(const TempSensorID tsi, float &k, float &d
   return true;
 }
 
-#endif // PROBE_TEMP_COMPENSATION
+#endif // HAS_PTC

commit 9c055621a0944e7f65051c0c72d117d13b7fe05b
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Fri Oct 22 21:56:05 2021 +0100

    üêõ Fix probe temp compensation maths (#23004)

diff --git a/Marlin/src/feature/probe_temp_comp.cpp b/Marlin/src/feature/probe_temp_comp.cpp
index 05b204ae6b..5f3bc985e6 100644
--- a/Marlin/src/feature/probe_temp_comp.cpp
+++ b/Marlin/src/feature/probe_temp_comp.cpp
@@ -24,6 +24,8 @@
 
 #if ENABLED(PROBE_TEMP_COMPENSATION)
 
+//#define DEBUG_PTC   // Print extra debug output with 'M871'
+
 #include "probe_temp_comp.h"
 #include <math.h>
 
@@ -79,9 +81,17 @@ void ProbeTempComp::print_offsets() {
         " temp: ", temp,
         "C; Offset: ", i < 0 ? 0.0f : sensor_z_offsets[s][i], " um"
       );
-      temp += cali_info[s].temp_res;
+      temp += cali_info[s].temp_resolution;
     }
   }
+  #if ENABLED(DEBUG_PTC)
+    float meas[4] = { 0, 0, 0, 0 };
+    compensate_measurement(TSI_PROBE, 27.5, meas[0]);
+    compensate_measurement(TSI_PROBE, 32.5, meas[1]);
+    compensate_measurement(TSI_PROBE, 77.5, meas[2]);
+    compensate_measurement(TSI_PROBE, 82.5, meas[3]);
+    SERIAL_ECHOLNPGM("DEBUG_PTC 27.5:", meas[0], " 32.5:", meas[1], " 77.5:", meas[2], " 82.5:", meas[3]);
+  #endif
 }
 
 void ProbeTempComp::prepare_new_calibration(const_float_t init_meas_z) {
@@ -111,7 +121,7 @@ bool ProbeTempComp::finish_calibration(const TempSensorID tsi) {
 
   const uint8_t measurements = cali_info[tsi].measurements;
   const celsius_t start_temp = cali_info[tsi].start_temp,
-                    res_temp = cali_info[tsi].temp_res;
+                    res_temp = cali_info[tsi].temp_resolution;
   int16_t * const data = sensor_z_offsets[tsi];
 
   // Extrapolate
@@ -156,46 +166,45 @@ bool ProbeTempComp::finish_calibration(const TempSensorID tsi) {
 }
 
 void ProbeTempComp::compensate_measurement(const TempSensorID tsi, const celsius_t temp, float &meas_z) {
-  if (WITHIN(temp, cali_info[tsi].start_temp, cali_info[tsi].end_temp))
-    meas_z -= get_offset_for_temperature(tsi, temp);
-}
-
-float ProbeTempComp::get_offset_for_temperature(const TempSensorID tsi, const celsius_t temp) {
   const uint8_t measurements = cali_info[tsi].measurements;
   const celsius_t start_temp = cali_info[tsi].start_temp,
-                    res_temp = cali_info[tsi].temp_res;
+                    end_temp = cali_info[tsi].end_temp,
+                    res_temp = cali_info[tsi].temp_resolution;
   const int16_t * const data = sensor_z_offsets[tsi];
 
-  auto point = [&](uint8_t i) -> xy_float_t {
-    return xy_float_t({ static_cast<float>(start_temp) + i * res_temp, static_cast<float>(data[i]) });
+  // Given a data index, return { celsius, zoffset } in the form { x, y }
+  auto tpoint = [&](uint8_t i) -> xy_float_t {
+    return xy_float_t({ static_cast<float>(start_temp) + i * res_temp, i ? static_cast<float>(data[i - 1]) : 0.0f });
   };
 
+  // Interpolate Z based on a temperature being within a given range
   auto linear_interp = [](const_float_t x, xy_float_t p1, xy_float_t p2) {
-    return (p2.y - p1.y) / (p2.x - p2.y) * (x - p1.x) + p1.y;
+    //   zoffs1 +      zoffset_per_toffset      *  toffset
+    return p1.y + (p2.y - p1.y) / (p2.x - p1.x) * (x - p1.x);
   };
 
-  // Linear interpolation
-  uint8_t idx = static_cast<uint8_t>((temp - start_temp) / res_temp);
-
   // offset in ¬µm
   float offset = 0.0f;
 
-  #if !defined(PTC_LINEAR_EXTRAPOLATION) || PTC_LINEAR_EXTRAPOLATION <= 0
-    if (idx < 0)
+  #if PTC_LINEAR_EXTRAPOLATION
+    if (temp < start_temp)
+      offset = linear_interp(temp, tpoint(0), tpoint(PTC_LINEAR_EXTRAPOLATION));
+    else if (temp >= end_temp)
+      offset = linear_interp(temp, tpoint(measurements - PTC_LINEAR_EXTRAPOLATION), tpoint(measurements));
+  #else
+    if (temp < start_temp)
       offset = 0.0f;
-    else if (idx > measurements - 2)
+    else if (temp >= end_temp)
       offset = static_cast<float>(data[measurements - 1]);
-  #else
-    if (idx < 0)
-      offset = linear_interp(temp, point(0), point(PTC_LINEAR_EXTRAPOLATION));
-    else if (idx > measurements - 2)
-      offset = linear_interp(temp, point(measurements - PTC_LINEAR_EXTRAPOLATION - 1), point(measurements - 1));
   #endif
-    else
-      offset = linear_interp(temp, point(idx), point(idx + 1));
+    else {
+      // Linear interpolation
+      const int8_t idx = static_cast<int8_t>((temp - start_temp) / res_temp);
+      offset = linear_interp(temp, tpoint(idx), tpoint(idx + 1));
+    }
 
-  // return offset in mm
-  return offset / 1000.0f;
+  // convert offset to mm and apply it
+  meas_z -= offset / 1000.0f;
 }
 
 bool ProbeTempComp::linear_regression(const TempSensorID tsi, float &k, float &d) {
@@ -204,7 +213,7 @@ bool ProbeTempComp::linear_regression(const TempSensorID tsi, float &k, float &d
   if (!WITHIN(calib_idx, 2, cali_info[tsi].measurements)) return false;
 
   const celsius_t start_temp = cali_info[tsi].start_temp,
-                    res_temp = cali_info[tsi].temp_res;
+                    res_temp = cali_info[tsi].temp_resolution;
   const int16_t * const data = sensor_z_offsets[tsi];
 
   float sum_x = start_temp,

commit 520b97083e52efdd47ab434b97823e48d85ade62
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 27 11:03:07 2021 -0500

    üé® Apply F() to serial macros

diff --git a/Marlin/src/feature/probe_temp_comp.cpp b/Marlin/src/feature/probe_temp_comp.cpp
index 68984fe756..05b204ae6b 100644
--- a/Marlin/src/feature/probe_temp_comp.cpp
+++ b/Marlin/src/feature/probe_temp_comp.cpp
@@ -69,11 +69,11 @@ void ProbeTempComp::print_offsets() {
   LOOP_L_N(s, TSI_COUNT) {
     celsius_t temp = cali_info[s].start_temp;
     for (int16_t i = -1; i < cali_info[s].measurements; ++i) {
-      SERIAL_ECHOPGM_P(s == TSI_BED ? PSTR("Bed") :
+      SERIAL_ECHOF(s == TSI_BED ? F("Bed") :
         #if ENABLED(USE_TEMP_EXT_COMPENSATION)
-          s == TSI_EXT ? PSTR("Extruder") :
+          s == TSI_EXT ? F("Extruder") :
         #endif
-        PSTR("Probe")
+        F("Probe")
       );
       SERIAL_ECHOLNPGM(
         " temp: ", temp,

commit 754b31918a73cb08c322102be5d3926d2ac59c18
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 9 04:57:05 2021 -0500

    üé® Fewer serial macros

diff --git a/Marlin/src/feature/probe_temp_comp.cpp b/Marlin/src/feature/probe_temp_comp.cpp
index 6f2dad58b9..68984fe756 100644
--- a/Marlin/src/feature/probe_temp_comp.cpp
+++ b/Marlin/src/feature/probe_temp_comp.cpp
@@ -75,7 +75,7 @@ void ProbeTempComp::print_offsets() {
         #endif
         PSTR("Probe")
       );
-      SERIAL_ECHOLNPAIR(
+      SERIAL_ECHOLNPGM(
         " temp: ", temp,
         "C; Offset: ", i < 0 ? 0.0f : sensor_z_offsets[s][i], " um"
       );
@@ -117,7 +117,7 @@ bool ProbeTempComp::finish_calibration(const TempSensorID tsi) {
   // Extrapolate
   float k, d;
   if (calib_idx < measurements) {
-    SERIAL_ECHOLNPAIR("Got ", calib_idx, " measurements. ");
+    SERIAL_ECHOLNPGM("Got ", calib_idx, " measurements. ");
     if (linear_regression(tsi, k, d)) {
       SERIAL_ECHOPGM("Applying linear extrapolation");
       calib_idx--;

commit 536cf287a6f642aa3eccd290b421b0e3869f018a
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Aug 21 18:00:55 2021 -0500

    üé® Misc code and spacing cleanup

diff --git a/Marlin/src/feature/probe_temp_comp.cpp b/Marlin/src/feature/probe_temp_comp.cpp
index e39896d4dc..6f2dad58b9 100644
--- a/Marlin/src/feature/probe_temp_comp.cpp
+++ b/Marlin/src/feature/probe_temp_comp.cpp
@@ -38,16 +38,12 @@ int16_t ProbeTempComp::z_offsets_probe[cali_info_init[TSI_PROBE].measurements],
 
 int16_t *ProbeTempComp::sensor_z_offsets[TSI_COUNT] = {
   ProbeTempComp::z_offsets_probe, ProbeTempComp::z_offsets_bed
-  #if ENABLED(USE_TEMP_EXT_COMPENSATION)
-    , ProbeTempComp::z_offsets_ext
-  #endif
+  OPTARG(USE_TEMP_EXT_COMPENSATION, ProbeTempComp::z_offsets_ext)
 };
 
 const temp_calib_t ProbeTempComp::cali_info[TSI_COUNT] = {
   cali_info_init[TSI_PROBE], cali_info_init[TSI_BED]
-  #if ENABLED(USE_TEMP_EXT_COMPENSATION)
-    , cali_info_init[TSI_EXT]
-  #endif
+  OPTARG(USE_TEMP_EXT_COMPENSATION, cali_info_init[TSI_EXT])
 };
 
 constexpr xyz_pos_t ProbeTempComp::park_point;

commit 84ca21edf76d1e2e4830b5fcc3b454db05cbe871
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jul 29 23:40:27 2021 -0500

    üé® abs => ABS

diff --git a/Marlin/src/feature/probe_temp_comp.cpp b/Marlin/src/feature/probe_temp_comp.cpp
index c9d6c6cb3f..e39896d4dc 100644
--- a/Marlin/src/feature/probe_temp_comp.cpp
+++ b/Marlin/src/feature/probe_temp_comp.cpp
@@ -143,13 +143,13 @@ bool ProbeTempComp::finish_calibration(const TempSensorID tsi) {
   // Sanity check
   for (calib_idx = 0; calib_idx < measurements; ++calib_idx) {
     // Restrict the max. offset
-    if (abs(data[calib_idx]) > 2000) {
+    if (ABS(data[calib_idx]) > 2000) {
       SERIAL_ECHOLNPGM("!Invalid Z-offset detected (0-2).");
       clear_offsets(tsi);
       return false;
     }
     // Restrict the max. offset difference between two probings
-    if (calib_idx > 0 && abs(data[calib_idx - 1] - data[calib_idx]) > 800) {
+    if (calib_idx > 0 && ABS(data[calib_idx - 1] - data[calib_idx]) > 800) {
       SERIAL_ECHOLNPGM("!Invalid Z-offset between two probings detected (0-0.8).");
       clear_offsets(TSI_PROBE);
       return false;

commit c4620bb5285438e41fa4c39229aa2a39859877ca
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Apr 23 20:19:23 2021 -0500

    Add whole-degree accessors, simplify some temperature-related features (#21685)

diff --git a/Marlin/src/feature/probe_temp_comp.cpp b/Marlin/src/feature/probe_temp_comp.cpp
index edb33da8ce..c9d6c6cb3f 100644
--- a/Marlin/src/feature/probe_temp_comp.cpp
+++ b/Marlin/src/feature/probe_temp_comp.cpp
@@ -71,7 +71,7 @@ bool ProbeTempComp::set_offset(const TempSensorID tsi, const uint8_t idx, const
 
 void ProbeTempComp::print_offsets() {
   LOOP_L_N(s, TSI_COUNT) {
-    float temp = cali_info[s].start_temp;
+    celsius_t temp = cali_info[s].start_temp;
     for (int16_t i = -1; i < cali_info[s].measurements; ++i) {
       SERIAL_ECHOPGM_P(s == TSI_BED ? PSTR("Bed") :
         #if ENABLED(USE_TEMP_EXT_COMPENSATION)
@@ -114,8 +114,8 @@ bool ProbeTempComp::finish_calibration(const TempSensorID tsi) {
   }
 
   const uint8_t measurements = cali_info[tsi].measurements;
-  const float start_temp = cali_info[tsi].start_temp,
-                res_temp = cali_info[tsi].temp_res;
+  const celsius_t start_temp = cali_info[tsi].start_temp,
+                    res_temp = cali_info[tsi].temp_res;
   int16_t * const data = sensor_z_offsets[tsi];
 
   // Extrapolate
@@ -159,19 +159,19 @@ bool ProbeTempComp::finish_calibration(const TempSensorID tsi) {
   return true;
 }
 
-void ProbeTempComp::compensate_measurement(const TempSensorID tsi, const_float_t temp, float &meas_z) {
+void ProbeTempComp::compensate_measurement(const TempSensorID tsi, const celsius_t temp, float &meas_z) {
   if (WITHIN(temp, cali_info[tsi].start_temp, cali_info[tsi].end_temp))
     meas_z -= get_offset_for_temperature(tsi, temp);
 }
 
-float ProbeTempComp::get_offset_for_temperature(const TempSensorID tsi, const_float_t temp) {
+float ProbeTempComp::get_offset_for_temperature(const TempSensorID tsi, const celsius_t temp) {
   const uint8_t measurements = cali_info[tsi].measurements;
-  const float start_temp = cali_info[tsi].start_temp,
-                res_temp = cali_info[tsi].temp_res;
+  const celsius_t start_temp = cali_info[tsi].start_temp,
+                    res_temp = cali_info[tsi].temp_res;
   const int16_t * const data = sensor_z_offsets[tsi];
 
-  auto point = [&](uint8_t i) {
-    return xy_float_t({start_temp + i*res_temp, static_cast<float>(data[i])});
+  auto point = [&](uint8_t i) -> xy_float_t {
+    return xy_float_t({ static_cast<float>(start_temp) + i * res_temp, static_cast<float>(data[i]) });
   };
 
   auto linear_interp = [](const_float_t x, xy_float_t p1, xy_float_t p2) {
@@ -207,17 +207,18 @@ bool ProbeTempComp::linear_regression(const TempSensorID tsi, float &k, float &d
 
   if (!WITHIN(calib_idx, 2, cali_info[tsi].measurements)) return false;
 
-  const float start_temp = cali_info[tsi].start_temp,
-                res_temp = cali_info[tsi].temp_res;
+  const celsius_t start_temp = cali_info[tsi].start_temp,
+                    res_temp = cali_info[tsi].temp_res;
   const int16_t * const data = sensor_z_offsets[tsi];
 
   float sum_x = start_temp,
         sum_x2 = sq(start_temp),
         sum_xy = 0, sum_y = 0;
 
+  float xi = static_cast<float>(start_temp);
   LOOP_L_N(i, calib_idx) {
-    const float xi = start_temp + (i + 1) * res_temp,
-                yi = static_cast<float>(data[i]);
+    const float yi = static_cast<float>(data[i]);
+    xi += res_temp;
     sum_x += xi;
     sum_x2 += sq(xi);
     sum_xy += xi * yi;

commit 3bddbb1110b6ca13a291de426553839b99cae102
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Apr 23 19:06:55 2021 -0500

    Clean up formatting, wrap macros

diff --git a/Marlin/src/feature/probe_temp_comp.cpp b/Marlin/src/feature/probe_temp_comp.cpp
index 68e669224c..edb33da8ce 100644
--- a/Marlin/src/feature/probe_temp_comp.cpp
+++ b/Marlin/src/feature/probe_temp_comp.cpp
@@ -181,7 +181,7 @@ float ProbeTempComp::get_offset_for_temperature(const TempSensorID tsi, const_fl
   // Linear interpolation
   uint8_t idx = static_cast<uint8_t>((temp - start_temp) / res_temp);
 
-  // offset in um
+  // offset in ¬µm
   float offset = 0.0f;
 
   #if !defined(PTC_LINEAR_EXTRAPOLATION) || PTC_LINEAR_EXTRAPOLATION <= 0

commit 72e3d2492f2085efe9c5fb0b33d67c24baf8a4bc
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Apr 23 19:14:49 2021 -0500

    Update temperature types

diff --git a/Marlin/src/feature/probe_temp_comp.cpp b/Marlin/src/feature/probe_temp_comp.cpp
index b0867817b6..68e669224c 100644
--- a/Marlin/src/feature/probe_temp_comp.cpp
+++ b/Marlin/src/feature/probe_temp_comp.cpp
@@ -52,7 +52,7 @@ const temp_calib_t ProbeTempComp::cali_info[TSI_COUNT] = {
 
 constexpr xyz_pos_t ProbeTempComp::park_point;
 constexpr xy_pos_t ProbeTempComp::measure_point;
-constexpr int ProbeTempComp::probe_calib_bed_temp;
+constexpr celsius_t ProbeTempComp::probe_calib_bed_temp;
 
 uint8_t ProbeTempComp::calib_idx; // = 0
 float ProbeTempComp::init_measurement; // = 0.0
@@ -126,7 +126,7 @@ bool ProbeTempComp::finish_calibration(const TempSensorID tsi) {
       SERIAL_ECHOPGM("Applying linear extrapolation");
       calib_idx--;
       for (; calib_idx < measurements; ++calib_idx) {
-        const float temp = start_temp + float(calib_idx) * res_temp;
+        const celsius_float_t temp = start_temp + float(calib_idx) * res_temp;
         data[calib_idx] = static_cast<int16_t>(k * temp + d);
       }
     }
@@ -174,7 +174,7 @@ float ProbeTempComp::get_offset_for_temperature(const TempSensorID tsi, const_fl
     return xy_float_t({start_temp + i*res_temp, static_cast<float>(data[i])});
   };
 
-  auto linear_interp = [](float x, xy_float_t p1, xy_float_t p2) {
+  auto linear_interp = [](const_float_t x, xy_float_t p1, xy_float_t p2) {
     return (p2.y - p1.y) / (p2.x - p2.y) * (x - p1.x) + p1.y;
   };
 

commit 62f37669dc506a6e579389ca549ce5993548944d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Apr 1 17:59:57 2021 -0500

    Replace 'const float &' with 'const_float_t' (#21505)

diff --git a/Marlin/src/feature/probe_temp_comp.cpp b/Marlin/src/feature/probe_temp_comp.cpp
index 8fdf160d0f..b0867817b6 100644
--- a/Marlin/src/feature/probe_temp_comp.cpp
+++ b/Marlin/src/feature/probe_temp_comp.cpp
@@ -88,12 +88,12 @@ void ProbeTempComp::print_offsets() {
   }
 }
 
-void ProbeTempComp::prepare_new_calibration(const float &init_meas_z) {
+void ProbeTempComp::prepare_new_calibration(const_float_t init_meas_z) {
   calib_idx = 0;
   init_measurement = init_meas_z;
 }
 
-void ProbeTempComp::push_back_new_measurement(const TempSensorID tsi, const float &meas_z) {
+void ProbeTempComp::push_back_new_measurement(const TempSensorID tsi, const_float_t meas_z) {
   switch (tsi) {
     case TSI_PROBE:
     case TSI_BED:
@@ -159,12 +159,12 @@ bool ProbeTempComp::finish_calibration(const TempSensorID tsi) {
   return true;
 }
 
-void ProbeTempComp::compensate_measurement(const TempSensorID tsi, const float &temp, float &meas_z) {
+void ProbeTempComp::compensate_measurement(const TempSensorID tsi, const_float_t temp, float &meas_z) {
   if (WITHIN(temp, cali_info[tsi].start_temp, cali_info[tsi].end_temp))
     meas_z -= get_offset_for_temperature(tsi, temp);
 }
 
-float ProbeTempComp::get_offset_for_temperature(const TempSensorID tsi, const float &temp) {
+float ProbeTempComp::get_offset_for_temperature(const TempSensorID tsi, const_float_t temp) {
   const uint8_t measurements = cali_info[tsi].measurements;
   const float start_temp = cali_info[tsi].start_temp,
                 res_temp = cali_info[tsi].temp_res;

commit dd42831cba7334c5d106ba435bdb41b6135971bb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Feb 28 19:43:46 2021 -0600

    Serial macros cleanup

diff --git a/Marlin/src/feature/probe_temp_comp.cpp b/Marlin/src/feature/probe_temp_comp.cpp
index af8039d8b1..8fdf160d0f 100644
--- a/Marlin/src/feature/probe_temp_comp.cpp
+++ b/Marlin/src/feature/probe_temp_comp.cpp
@@ -73,7 +73,7 @@ void ProbeTempComp::print_offsets() {
   LOOP_L_N(s, TSI_COUNT) {
     float temp = cali_info[s].start_temp;
     for (int16_t i = -1; i < cali_info[s].measurements; ++i) {
-      serialprintPGM(s == TSI_BED ? PSTR("Bed") :
+      SERIAL_ECHOPGM_P(s == TSI_BED ? PSTR("Bed") :
         #if ENABLED(USE_TEMP_EXT_COMPENSATION)
           s == TSI_EXT ? PSTR("Extruder") :
         #endif

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/feature/probe_temp_comp.cpp b/Marlin/src/feature/probe_temp_comp.cpp
index ad0acef04d..af8039d8b1 100644
--- a/Marlin/src/feature/probe_temp_comp.cpp
+++ b/Marlin/src/feature/probe_temp_comp.cpp
@@ -16,7 +16,7 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 

commit eef29311500dd573177afea0c9b213176d8e497b
Author: rudihorn <rh@rudi-horn.de>
Date:   Fri Jun 12 02:46:25 2020 +0100

    Fix PTC calculation (#18265)

diff --git a/Marlin/src/feature/probe_temp_comp.cpp b/Marlin/src/feature/probe_temp_comp.cpp
index c3459d2345..ad0acef04d 100644
--- a/Marlin/src/feature/probe_temp_comp.cpp
+++ b/Marlin/src/feature/probe_temp_comp.cpp
@@ -179,7 +179,7 @@ float ProbeTempComp::get_offset_for_temperature(const TempSensorID tsi, const fl
   };
 
   // Linear interpolation
-  uint8_t idx = static_cast<uint8_t>(temp - start_temp / res_temp);
+  uint8_t idx = static_cast<uint8_t>((temp - start_temp) / res_temp);
 
   // offset in um
   float offset = 0.0f;
@@ -190,9 +190,9 @@ float ProbeTempComp::get_offset_for_temperature(const TempSensorID tsi, const fl
     else if (idx > measurements - 2)
       offset = static_cast<float>(data[measurements - 1]);
   #else
-    if (idx < 0) 
+    if (idx < 0)
       offset = linear_interp(temp, point(0), point(PTC_LINEAR_EXTRAPOLATION));
-    else if (idx > measurements - 2) 
+    else if (idx > measurements - 2)
       offset = linear_interp(temp, point(measurements - PTC_LINEAR_EXTRAPOLATION - 1), point(measurements - 1));
   #endif
     else

commit 3bf990ec346b0aaa536bc1d46b668dd2b4973916
Author: rudihorn <rh@rudi-horn.de>
Date:   Thu Jun 11 00:25:17 2020 +0100

    PTC: Extend options, fix probing bugs (#18253)

diff --git a/Marlin/src/feature/probe_temp_comp.cpp b/Marlin/src/feature/probe_temp_comp.cpp
index 92ff2e9771..c3459d2345 100644
--- a/Marlin/src/feature/probe_temp_comp.cpp
+++ b/Marlin/src/feature/probe_temp_comp.cpp
@@ -165,28 +165,41 @@ void ProbeTempComp::compensate_measurement(const TempSensorID tsi, const float &
 }
 
 float ProbeTempComp::get_offset_for_temperature(const TempSensorID tsi, const float &temp) {
-
   const uint8_t measurements = cali_info[tsi].measurements;
   const float start_temp = cali_info[tsi].start_temp,
-                end_temp = cali_info[tsi].end_temp,
                 res_temp = cali_info[tsi].temp_res;
   const int16_t * const data = sensor_z_offsets[tsi];
 
-  if (temp <= start_temp) return 0.0f;
-  if (temp >= end_temp) return static_cast<float>(data[measurements - 1]) / 1000.0f;
+  auto point = [&](uint8_t i) {
+    return xy_float_t({start_temp + i*res_temp, static_cast<float>(data[i])});
+  };
+
+  auto linear_interp = [](float x, xy_float_t p1, xy_float_t p2) {
+    return (p2.y - p1.y) / (p2.x - p2.y) * (x - p1.x) + p1.y;
+  };
 
   // Linear interpolation
-  int16_t val1 = 0, val2 = data[0];
-  uint8_t idx = 0;
-  float meas_temp = start_temp + res_temp;
-  while (meas_temp < temp) {
-    if (++idx >= measurements) return static_cast<float>(val2) / 1000.0f;
-    meas_temp += res_temp;
-    val1 = val2;
-    val2 = data[idx];
-  }
-  const float factor = (meas_temp - temp) / static_cast<float>(res_temp);
-  return (static_cast<float>(val2) - static_cast<float>(val2 - val1) * factor) / 1000.0f;
+  uint8_t idx = static_cast<uint8_t>(temp - start_temp / res_temp);
+
+  // offset in um
+  float offset = 0.0f;
+
+  #if !defined(PTC_LINEAR_EXTRAPOLATION) || PTC_LINEAR_EXTRAPOLATION <= 0
+    if (idx < 0)
+      offset = 0.0f;
+    else if (idx > measurements - 2)
+      offset = static_cast<float>(data[measurements - 1]);
+  #else
+    if (idx < 0) 
+      offset = linear_interp(temp, point(0), point(PTC_LINEAR_EXTRAPOLATION));
+    else if (idx > measurements - 2) 
+      offset = linear_interp(temp, point(measurements - PTC_LINEAR_EXTRAPOLATION - 1), point(measurements - 1));
+  #endif
+    else
+      offset = linear_interp(temp, point(idx), point(idx + 1));
+
+  // return offset in mm
+  return offset / 1000.0f;
 }
 
 bool ProbeTempComp::linear_regression(const TempSensorID tsi, float &k, float &d) {

commit 8d425c672002bd90fad5f2778bd544ef69fb9e8d
Author: Eric Ptak <trouch@trouch.com>
Date:   Sun May 3 01:27:18 2020 +0200

    Fix missing ProbeTempComp refs (#17833)

diff --git a/Marlin/src/feature/probe_temp_comp.cpp b/Marlin/src/feature/probe_temp_comp.cpp
index b773536a5d..92ff2e9771 100644
--- a/Marlin/src/feature/probe_temp_comp.cpp
+++ b/Marlin/src/feature/probe_temp_comp.cpp
@@ -50,6 +50,10 @@ const temp_calib_t ProbeTempComp::cali_info[TSI_COUNT] = {
   #endif
 };
 
+constexpr xyz_pos_t ProbeTempComp::park_point;
+constexpr xy_pos_t ProbeTempComp::measure_point;
+constexpr int ProbeTempComp::probe_calib_bed_temp;
+
 uint8_t ProbeTempComp::calib_idx; // = 0
 float ProbeTempComp::init_measurement; // = 0.0
 

commit d6f39a69af1d5dbab09deeb8a35bcdc050488b83
Author: Tor-p <63096807+Tor-p@users.noreply.github.com>
Date:   Mon Apr 6 22:32:06 2020 +0200

    Fix G76 probe height / position (#17392)

diff --git a/Marlin/src/feature/probe_temp_comp.cpp b/Marlin/src/feature/probe_temp_comp.cpp
index 6b787f420a..b773536a5d 100644
--- a/Marlin/src/feature/probe_temp_comp.cpp
+++ b/Marlin/src/feature/probe_temp_comp.cpp
@@ -29,11 +29,11 @@
 
 ProbeTempComp temp_comp;
 
-int16_t ProbeTempComp::z_offsets_probe[ProbeTempComp::cali_info_init[TSI_PROBE].measurements],  // = {0}
-        ProbeTempComp::z_offsets_bed[ProbeTempComp::cali_info_init[TSI_BED].measurements];      // = {0}
+int16_t ProbeTempComp::z_offsets_probe[cali_info_init[TSI_PROBE].measurements],  // = {0}
+        ProbeTempComp::z_offsets_bed[cali_info_init[TSI_BED].measurements];      // = {0}
 
 #if ENABLED(USE_TEMP_EXT_COMPENSATION)
-  int16_t ProbeTempComp::z_offsets_ext[ProbeTempComp::cali_info_init[TSI_EXT].measurements];    // = {0}
+  int16_t ProbeTempComp::z_offsets_ext[cali_info_init[TSI_EXT].measurements];    // = {0}
 #endif
 
 int16_t *ProbeTempComp::sensor_z_offsets[TSI_COUNT] = {
@@ -44,9 +44,9 @@ int16_t *ProbeTempComp::sensor_z_offsets[TSI_COUNT] = {
 };
 
 const temp_calib_t ProbeTempComp::cali_info[TSI_COUNT] = {
-  ProbeTempComp::cali_info_init[TSI_PROBE], ProbeTempComp::cali_info_init[TSI_BED]
+  cali_info_init[TSI_PROBE], cali_info_init[TSI_BED]
   #if ENABLED(USE_TEMP_EXT_COMPENSATION)
-    , ProbeTempComp::cali_info_init[TSI_EXT]
+    , cali_info_init[TSI_EXT]
   #endif
 };
 

commit 118bd2f8b2a1f81884cb55a8fc00b708a51aa15b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 13 23:18:16 2020 -0500

    Apply loop shorthand macros (#17159)

diff --git a/Marlin/src/feature/probe_temp_comp.cpp b/Marlin/src/feature/probe_temp_comp.cpp
index 326ebb4080..6b787f420a 100644
--- a/Marlin/src/feature/probe_temp_comp.cpp
+++ b/Marlin/src/feature/probe_temp_comp.cpp
@@ -54,7 +54,7 @@ uint8_t ProbeTempComp::calib_idx; // = 0
 float ProbeTempComp::init_measurement; // = 0.0
 
 void ProbeTempComp::clear_offsets(const TempSensorID tsi) {
-  for (uint8_t i = 0; i < cali_info[tsi].measurements; ++i)
+  LOOP_L_N(i, cali_info[tsi].measurements)
     sensor_z_offsets[tsi][i] = 0;
   calib_idx = 0;
 }
@@ -66,7 +66,7 @@ bool ProbeTempComp::set_offset(const TempSensorID tsi, const uint8_t idx, const
 }
 
 void ProbeTempComp::print_offsets() {
-  for (uint8_t s = 0; s < TSI_COUNT; s++) {
+  LOOP_L_N(s, TSI_COUNT) {
     float temp = cali_info[s].start_temp;
     for (int16_t i = -1; i < cali_info[s].measurements; ++i) {
       serialprintPGM(s == TSI_BED ? PSTR("Bed") :
@@ -198,7 +198,7 @@ bool ProbeTempComp::linear_regression(const TempSensorID tsi, float &k, float &d
         sum_x2 = sq(start_temp),
         sum_xy = 0, sum_y = 0;
 
-  for (uint8_t i = 0; i < calib_idx; ++i) {
+  LOOP_L_N(i, calib_idx) {
     const float xi = start_temp + (i + 1) * res_temp,
                 yi = static_cast<float>(data[i]);
     sum_x += xi;

commit 6bead0c1b04152f6a291d851f6cd4029fe0fc616
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 13 16:29:29 2020 -0500

    Shorter paths to HAL, ExtUI (#17156)

diff --git a/Marlin/src/feature/probe_temp_comp.cpp b/Marlin/src/feature/probe_temp_comp.cpp
new file mode 100644
index 0000000000..326ebb4080
--- /dev/null
+++ b/Marlin/src/feature/probe_temp_comp.cpp
@@ -0,0 +1,223 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+#include "../inc/MarlinConfigPre.h"
+
+#if ENABLED(PROBE_TEMP_COMPENSATION)
+
+#include "probe_temp_comp.h"
+#include <math.h>
+
+ProbeTempComp temp_comp;
+
+int16_t ProbeTempComp::z_offsets_probe[ProbeTempComp::cali_info_init[TSI_PROBE].measurements],  // = {0}
+        ProbeTempComp::z_offsets_bed[ProbeTempComp::cali_info_init[TSI_BED].measurements];      // = {0}
+
+#if ENABLED(USE_TEMP_EXT_COMPENSATION)
+  int16_t ProbeTempComp::z_offsets_ext[ProbeTempComp::cali_info_init[TSI_EXT].measurements];    // = {0}
+#endif
+
+int16_t *ProbeTempComp::sensor_z_offsets[TSI_COUNT] = {
+  ProbeTempComp::z_offsets_probe, ProbeTempComp::z_offsets_bed
+  #if ENABLED(USE_TEMP_EXT_COMPENSATION)
+    , ProbeTempComp::z_offsets_ext
+  #endif
+};
+
+const temp_calib_t ProbeTempComp::cali_info[TSI_COUNT] = {
+  ProbeTempComp::cali_info_init[TSI_PROBE], ProbeTempComp::cali_info_init[TSI_BED]
+  #if ENABLED(USE_TEMP_EXT_COMPENSATION)
+    , ProbeTempComp::cali_info_init[TSI_EXT]
+  #endif
+};
+
+uint8_t ProbeTempComp::calib_idx; // = 0
+float ProbeTempComp::init_measurement; // = 0.0
+
+void ProbeTempComp::clear_offsets(const TempSensorID tsi) {
+  for (uint8_t i = 0; i < cali_info[tsi].measurements; ++i)
+    sensor_z_offsets[tsi][i] = 0;
+  calib_idx = 0;
+}
+
+bool ProbeTempComp::set_offset(const TempSensorID tsi, const uint8_t idx, const int16_t offset) {
+  if (idx >= cali_info[tsi].measurements) return false;
+  sensor_z_offsets[tsi][idx] = offset;
+  return true;
+}
+
+void ProbeTempComp::print_offsets() {
+  for (uint8_t s = 0; s < TSI_COUNT; s++) {
+    float temp = cali_info[s].start_temp;
+    for (int16_t i = -1; i < cali_info[s].measurements; ++i) {
+      serialprintPGM(s == TSI_BED ? PSTR("Bed") :
+        #if ENABLED(USE_TEMP_EXT_COMPENSATION)
+          s == TSI_EXT ? PSTR("Extruder") :
+        #endif
+        PSTR("Probe")
+      );
+      SERIAL_ECHOLNPAIR(
+        " temp: ", temp,
+        "C; Offset: ", i < 0 ? 0.0f : sensor_z_offsets[s][i], " um"
+      );
+      temp += cali_info[s].temp_res;
+    }
+  }
+}
+
+void ProbeTempComp::prepare_new_calibration(const float &init_meas_z) {
+  calib_idx = 0;
+  init_measurement = init_meas_z;
+}
+
+void ProbeTempComp::push_back_new_measurement(const TempSensorID tsi, const float &meas_z) {
+  switch (tsi) {
+    case TSI_PROBE:
+    case TSI_BED:
+    //case TSI_EXT:
+      if (calib_idx >= cali_info[tsi].measurements) return;
+      sensor_z_offsets[tsi][calib_idx++] = static_cast<int16_t>(meas_z * 1000.0f - init_measurement * 1000.0f);
+    default: break;
+  }
+}
+
+bool ProbeTempComp::finish_calibration(const TempSensorID tsi) {
+  if (tsi != TSI_PROBE && tsi != TSI_BED) return false;
+
+  if (calib_idx < 3) {
+    SERIAL_ECHOLNPGM("!Insufficient measurements (min. 3).");
+    clear_offsets(tsi);
+    return false;
+  }
+
+  const uint8_t measurements = cali_info[tsi].measurements;
+  const float start_temp = cali_info[tsi].start_temp,
+                res_temp = cali_info[tsi].temp_res;
+  int16_t * const data = sensor_z_offsets[tsi];
+
+  // Extrapolate
+  float k, d;
+  if (calib_idx < measurements) {
+    SERIAL_ECHOLNPAIR("Got ", calib_idx, " measurements. ");
+    if (linear_regression(tsi, k, d)) {
+      SERIAL_ECHOPGM("Applying linear extrapolation");
+      calib_idx--;
+      for (; calib_idx < measurements; ++calib_idx) {
+        const float temp = start_temp + float(calib_idx) * res_temp;
+        data[calib_idx] = static_cast<int16_t>(k * temp + d);
+      }
+    }
+    else {
+      // Simply use the last measured value for higher temperatures
+      SERIAL_ECHOPGM("Failed to extrapolate");
+      const int16_t last_val = data[calib_idx];
+      for (; calib_idx < measurements; ++calib_idx)
+        data[calib_idx] = last_val;
+    }
+    SERIAL_ECHOLNPGM(" for higher temperatures.");
+  }
+
+  // Sanity check
+  for (calib_idx = 0; calib_idx < measurements; ++calib_idx) {
+    // Restrict the max. offset
+    if (abs(data[calib_idx]) > 2000) {
+      SERIAL_ECHOLNPGM("!Invalid Z-offset detected (0-2).");
+      clear_offsets(tsi);
+      return false;
+    }
+    // Restrict the max. offset difference between two probings
+    if (calib_idx > 0 && abs(data[calib_idx - 1] - data[calib_idx]) > 800) {
+      SERIAL_ECHOLNPGM("!Invalid Z-offset between two probings detected (0-0.8).");
+      clear_offsets(TSI_PROBE);
+      return false;
+    }
+  }
+
+  return true;
+}
+
+void ProbeTempComp::compensate_measurement(const TempSensorID tsi, const float &temp, float &meas_z) {
+  if (WITHIN(temp, cali_info[tsi].start_temp, cali_info[tsi].end_temp))
+    meas_z -= get_offset_for_temperature(tsi, temp);
+}
+
+float ProbeTempComp::get_offset_for_temperature(const TempSensorID tsi, const float &temp) {
+
+  const uint8_t measurements = cali_info[tsi].measurements;
+  const float start_temp = cali_info[tsi].start_temp,
+                end_temp = cali_info[tsi].end_temp,
+                res_temp = cali_info[tsi].temp_res;
+  const int16_t * const data = sensor_z_offsets[tsi];
+
+  if (temp <= start_temp) return 0.0f;
+  if (temp >= end_temp) return static_cast<float>(data[measurements - 1]) / 1000.0f;
+
+  // Linear interpolation
+  int16_t val1 = 0, val2 = data[0];
+  uint8_t idx = 0;
+  float meas_temp = start_temp + res_temp;
+  while (meas_temp < temp) {
+    if (++idx >= measurements) return static_cast<float>(val2) / 1000.0f;
+    meas_temp += res_temp;
+    val1 = val2;
+    val2 = data[idx];
+  }
+  const float factor = (meas_temp - temp) / static_cast<float>(res_temp);
+  return (static_cast<float>(val2) - static_cast<float>(val2 - val1) * factor) / 1000.0f;
+}
+
+bool ProbeTempComp::linear_regression(const TempSensorID tsi, float &k, float &d) {
+  if (tsi != TSI_PROBE && tsi != TSI_BED) return false;
+
+  if (!WITHIN(calib_idx, 2, cali_info[tsi].measurements)) return false;
+
+  const float start_temp = cali_info[tsi].start_temp,
+                res_temp = cali_info[tsi].temp_res;
+  const int16_t * const data = sensor_z_offsets[tsi];
+
+  float sum_x = start_temp,
+        sum_x2 = sq(start_temp),
+        sum_xy = 0, sum_y = 0;
+
+  for (uint8_t i = 0; i < calib_idx; ++i) {
+    const float xi = start_temp + (i + 1) * res_temp,
+                yi = static_cast<float>(data[i]);
+    sum_x += xi;
+    sum_x2 += sq(xi);
+    sum_xy += xi * yi;
+    sum_y += yi;
+  }
+
+  const float denom = static_cast<float>(calib_idx + 1) * sum_x2 - sq(sum_x);
+  if (fabs(denom) <= 10e-5) {
+    // Singularity - unable to solve
+    k = d = 0.0;
+    return false;
+  }
+
+  k = (static_cast<float>(calib_idx + 1) * sum_xy - sum_x * sum_y) / denom;
+  d = (sum_y - k * sum_x) / static_cast<float>(calib_idx + 1);
+
+  return true;
+}
+
+#endif // PROBE_TEMP_COMPENSATION
