commit 5140726c7076a6ed373bf3fc8c0fbaec1ed1dd8d
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Tue Jul 16 07:01:32 2024 +1200

    ü©π Fix _MAX type warning (#27272)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 46b3493bb6..511a3aa80d 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -292,21 +292,21 @@ class Stepper {
   friend class Max7219;
   friend class FTMotion;
   friend void stepperTask(void *);
 
   public:
 
     // The minimal step rate ensures calculations stay within limits
     // and avoid the most unreasonably slow step rates.
     static constexpr uint32_t minimal_step_rate = (
       #ifdef CPU_32_BIT
-        _MAX((STEPPER_TIMER_RATE) / HAL_TIMER_TYPE_MAX, 1U) // 32-bit shouldn't go below 1
+        _MAX((uint32_t(STEPPER_TIMER_RATE) / HAL_TIMER_TYPE_MAX), 1U) // 32-bit shouldn't go below 1
       #else
         (F_CPU) / 500000U   // AVR shouldn't go below 32 (16MHz) or 40 (20MHz)
       #endif
     );
 
     #if ANY(HAS_EXTRA_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
       static bool separate_multi_axis;
     #endif
 
     #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM

commit f0bc4274f817166fcce82949d94330bd1c441c15
Author: narno2202 <130909513+narno2202@users.noreply.github.com>
Date:   Mon Jul 15 20:13:00 2024 +0200

    üßë‚Äçüíª FT Motion: Individual axis shaping, new buffer management (#26848)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 2a171bebd0..46b3493bb6 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -661,22 +661,20 @@ class Stepper {
     // Update direction states for all steppers
     static void apply_directions();
 
     // Set direction bits and update all stepper DIR states
     static void set_directions(const AxisBits bits) {
       last_direction_bits = bits;
       apply_directions();
     }
 
     #if ENABLED(FT_MOTION)
-      // Manage the planner
-      static void ftMotion_blockQueueUpdate();
       // Set current position in steps when reset flag is set in M493 and planner already synchronized
       static void ftMotion_syncPosition();
     #endif
 
     #if HAS_ZV_SHAPING
       static void set_shaping_damping_ratio(const AxisEnum axis, const_float_t zeta);
       static float get_shaping_damping_ratio(const AxisEnum axis);
       static void set_shaping_frequency(const AxisEnum axis, const_float_t freq);
       static float get_shaping_frequency(const AxisEnum axis);
     #endif

commit 228179e09bfbc3b13c4cfd1a6cbf763fa57689e7
Author: John Robertson <john@cirtech.co.uk>
Date:   Sat Jul 13 17:47:46 2024 +0100

    ü©π Clock-based planner trapezoidal nominal_rate (#26881)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 3586c23e70..2a171bebd0 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -288,20 +288,30 @@ constexpr ena_mask_t enable_overlap[] = {
 //
 // Stepper class definition
 //
 class Stepper {
   friend class Max7219;
   friend class FTMotion;
   friend void stepperTask(void *);
 
   public:
 
+    // The minimal step rate ensures calculations stay within limits
+    // and avoid the most unreasonably slow step rates.
+    static constexpr uint32_t minimal_step_rate = (
+      #ifdef CPU_32_BIT
+        _MAX((STEPPER_TIMER_RATE) / HAL_TIMER_TYPE_MAX, 1U) // 32-bit shouldn't go below 1
+      #else
+        (F_CPU) / 500000U   // AVR shouldn't go below 32 (16MHz) or 40 (20MHz)
+      #endif
+    );
+
     #if ANY(HAS_EXTRA_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
       static bool separate_multi_axis;
     #endif
 
     #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
       #if HAS_MOTOR_CURRENT_PWM
         #ifndef PWM_MOTOR_CURRENT
           #define PWM_MOTOR_CURRENT DEFAULT_PWM_MOTOR_CURRENT
         #endif
         #ifndef MOTOR_CURRENT_PWM_FREQUENCY

commit 65c19f82b9827604d1286823a655d9ecf106b6b3
Author: Mihai <299015+mh-dm@users.noreply.github.com>
Date:   Thu Jun 6 05:26:09 2024 +0300

    üîß Minimum Stepper Pulse in Nanoseconds (#27113)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 8cf6d39dea..3586c23e70 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -139,26 +139,26 @@ constexpr ena_mask_t enable_overlap[] = {
   #ifdef SHAPING_MAX_STEPRATE
     constexpr float max_step_rate = SHAPING_MAX_STEPRATE;
   #else
     #define ISALIM(I, ARR) _MIN(I, COUNT(ARR) - 1)
     constexpr float     _ISDASU[] = DEFAULT_AXIS_STEPS_PER_UNIT;
     constexpr feedRate_t _ISDMF[] = DEFAULT_MAX_FEEDRATE;
     constexpr float max_shaped_rate = TERN0(INPUT_SHAPING_X, _ISDMF[X_AXIS] * _ISDASU[X_AXIS]) +
                                       TERN0(INPUT_SHAPING_Y, _ISDMF[Y_AXIS] * _ISDASU[Y_AXIS]) +
                                       TERN0(INPUT_SHAPING_Z, _ISDMF[Z_AXIS] * _ISDASU[Z_AXIS]);
     #if defined(__AVR__) || !defined(ADAPTIVE_STEP_SMOOTHING)
-      // MIN_STEP_ISR_FREQUENCY is known at compile time on AVRs and any reduction in SRAM is welcome
+      // min_step_isr_frequency is known at compile time on AVRs and any reduction in SRAM is welcome
       template<unsigned int INDEX=DISTINCT_AXES> constexpr float max_isr_rate() {
         return _MAX(_ISDMF[ISALIM(INDEX - 1, _ISDMF)] * _ISDASU[ISALIM(INDEX - 1, _ISDASU)], max_isr_rate<INDEX - 1>());
       }
       template<> constexpr float max_isr_rate<0>() {
-        return TERN0(ADAPTIVE_STEP_SMOOTHING, MIN_STEP_ISR_FREQUENCY);
+        return TERN0(ADAPTIVE_STEP_SMOOTHING, min_step_isr_frequency);
       }
       constexpr float max_step_rate = _MIN(max_isr_rate(), max_shaped_rate);
     #else
       constexpr float max_step_rate = max_shaped_rate;
     #endif
   #endif
 
   #ifndef SHAPING_MIN_FREQ
     #define SHAPING_MIN_FREQ _MIN(__FLT_MAX__ OPTARG(INPUT_SHAPING_X, SHAPING_FREQ_X) OPTARG(INPUT_SHAPING_Y, SHAPING_FREQ_Y) OPTARG(INPUT_SHAPING_Z, SHAPING_FREQ_Z))
   #endif

commit 6b6865d068c2ebbcb6b56c965807571257d50828
Author: Jonathan Brazier <66009857+JonBr306@users.noreply.github.com>
Date:   Mon May 20 06:03:03 2024 +0100

    ‚ú® INPUT_SHAPING_Z (#27073)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 82b41290bf..8cf6d39dea 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -136,145 +136,140 @@ constexpr ena_mask_t enable_overlap[] = {
 
 #if HAS_ZV_SHAPING
 
   #ifdef SHAPING_MAX_STEPRATE
     constexpr float max_step_rate = SHAPING_MAX_STEPRATE;
   #else
     #define ISALIM(I, ARR) _MIN(I, COUNT(ARR) - 1)
     constexpr float     _ISDASU[] = DEFAULT_AXIS_STEPS_PER_UNIT;
     constexpr feedRate_t _ISDMF[] = DEFAULT_MAX_FEEDRATE;
     constexpr float max_shaped_rate = TERN0(INPUT_SHAPING_X, _ISDMF[X_AXIS] * _ISDASU[X_AXIS]) +
-                                      TERN0(INPUT_SHAPING_Y, _ISDMF[Y_AXIS] * _ISDASU[Y_AXIS]);
+                                      TERN0(INPUT_SHAPING_Y, _ISDMF[Y_AXIS] * _ISDASU[Y_AXIS]) +
+                                      TERN0(INPUT_SHAPING_Z, _ISDMF[Z_AXIS] * _ISDASU[Z_AXIS]);
     #if defined(__AVR__) || !defined(ADAPTIVE_STEP_SMOOTHING)
       // MIN_STEP_ISR_FREQUENCY is known at compile time on AVRs and any reduction in SRAM is welcome
       template<unsigned int INDEX=DISTINCT_AXES> constexpr float max_isr_rate() {
         return _MAX(_ISDMF[ISALIM(INDEX - 1, _ISDMF)] * _ISDASU[ISALIM(INDEX - 1, _ISDASU)], max_isr_rate<INDEX - 1>());
       }
       template<> constexpr float max_isr_rate<0>() {
         return TERN0(ADAPTIVE_STEP_SMOOTHING, MIN_STEP_ISR_FREQUENCY);
       }
       constexpr float max_step_rate = _MIN(max_isr_rate(), max_shaped_rate);
     #else
       constexpr float max_step_rate = max_shaped_rate;
     #endif
   #endif
 
   #ifndef SHAPING_MIN_FREQ
-    #define SHAPING_MIN_FREQ _MIN(__FLT_MAX__ OPTARG(INPUT_SHAPING_X, SHAPING_FREQ_X) OPTARG(INPUT_SHAPING_Y, SHAPING_FREQ_Y))
+    #define SHAPING_MIN_FREQ _MIN(__FLT_MAX__ OPTARG(INPUT_SHAPING_X, SHAPING_FREQ_X) OPTARG(INPUT_SHAPING_Y, SHAPING_FREQ_Y) OPTARG(INPUT_SHAPING_Z, SHAPING_FREQ_Z))
   #endif
   constexpr float shaping_min_freq = SHAPING_MIN_FREQ;
   constexpr uint16_t shaping_echoes = FLOOR(max_step_rate / shaping_min_freq / 2) + 3;
 
   typedef hal_timer_t shaping_time_t;
   enum shaping_echo_t { ECHO_NONE = 0, ECHO_FWD = 1, ECHO_BWD = 2 };
   struct shaping_echo_axis_t {
     TERN_(INPUT_SHAPING_X, shaping_echo_t x:2);
     TERN_(INPUT_SHAPING_Y, shaping_echo_t y:2);
+    TERN_(INPUT_SHAPING_Z, shaping_echo_t z:2);
   };
 
   class ShapingQueue {
     private:
       static shaping_time_t       now;
       static shaping_time_t       times[shaping_echoes];
       static shaping_echo_axis_t  echo_axes[shaping_echoes];
       static uint16_t             tail;
 
-      #if ENABLED(INPUT_SHAPING_X)
-        static shaping_time_t delay_x;    // = shaping_time_t(-1) to disable queueing
-        static shaping_time_t peek_x_val;
-        static uint16_t head_x;
-        static uint16_t _free_count_x;
-      #endif
-      #if ENABLED(INPUT_SHAPING_Y)
-        static shaping_time_t delay_y;    // = shaping_time_t(-1) to disable queueing
-        static shaping_time_t peek_y_val;
-        static uint16_t head_y;
-        static uint16_t _free_count_y;
-      #endif
+      #define SHAPING_QUEUE_AXIS_VARS(AXIS)                                                     \
+        static shaping_time_t delay_##AXIS;    /* = shaping_time_t(-1) to disable queueing*/    \
+        static shaping_time_t _peek_##AXIS;                                                     \
+        static uint16_t head_##AXIS;                                                            \
+        static uint16_t _free_count_##AXIS;
+
+      TERN_(INPUT_SHAPING_X, SHAPING_QUEUE_AXIS_VARS(x))
+      TERN_(INPUT_SHAPING_Y, SHAPING_QUEUE_AXIS_VARS(y))
+      TERN_(INPUT_SHAPING_Z, SHAPING_QUEUE_AXIS_VARS(z))
 
     public:
       static void decrement_delays(const shaping_time_t interval) {
         now += interval;
-        TERN_(INPUT_SHAPING_X, if (peek_x_val != shaping_time_t(-1)) peek_x_val -= interval);
-        TERN_(INPUT_SHAPING_Y, if (peek_y_val != shaping_time_t(-1)) peek_y_val -= interval);
+        TERN_(INPUT_SHAPING_X, if (_peek_x != shaping_time_t(-1)) _peek_x -= interval);
+        TERN_(INPUT_SHAPING_Y, if (_peek_y != shaping_time_t(-1)) _peek_y -= interval);
+        TERN_(INPUT_SHAPING_Z, if (_peek_z != shaping_time_t(-1)) _peek_z -= interval);
       }
       static void set_delay(const AxisEnum axis, const shaping_time_t delay) {
         TERN_(INPUT_SHAPING_X, if (axis == X_AXIS) delay_x = delay);
         TERN_(INPUT_SHAPING_Y, if (axis == Y_AXIS) delay_y = delay);
+        TERN_(INPUT_SHAPING_Z, if (axis == Z_AXIS) delay_z = delay);
       }
-      static void enqueue(const bool x_step, const bool x_forward, const bool y_step, const bool y_forward) {
-        #if ENABLED(INPUT_SHAPING_X)
-          if (x_step) {
-            if (head_x == tail) peek_x_val = delay_x;
-            echo_axes[tail].x = x_forward ? ECHO_FWD : ECHO_BWD;
-            _free_count_x--;
-          }
-          else {
-            echo_axes[tail].x = ECHO_NONE;
-            if (head_x != tail)
-              _free_count_x--;
-            else if (++head_x == shaping_echoes)
-              head_x = 0;
-          }
-        #endif
-        #if ENABLED(INPUT_SHAPING_Y)
-          if (y_step) {
-            if (head_y == tail) peek_y_val = delay_y;
-            echo_axes[tail].y = y_forward ? ECHO_FWD : ECHO_BWD;
-            _free_count_y--;
-          }
-          else {
-            echo_axes[tail].y = ECHO_NONE;
-            if (head_y != tail)
-              _free_count_y--;
-            else if (++head_y == shaping_echoes)
-              head_y = 0;
+
+      static void enqueue(const bool x_step, const bool x_forward, const bool y_step, const bool y_forward, const bool z_step, const bool z_forward) {
+        #define SHAPING_QUEUE_ENQUEUE(AXIS)                              \
+          if (AXIS##_step) {                                             \
+            if (head_##AXIS == tail) _peek_##AXIS = delay_##AXIS;        \
+            echo_axes[tail].AXIS = AXIS##_forward ? ECHO_FWD : ECHO_BWD; \
+            _free_count_##AXIS--;                                        \
+          }                                                              \
+          else {                                                         \
+            echo_axes[tail].AXIS = ECHO_NONE;                            \
+            if (head_##AXIS != tail)                                     \
+              _free_count_##AXIS--;                                      \
+            else if (++head_##AXIS == shaping_echoes)                    \
+              head_##AXIS = 0;                                           \
           }
-        #endif
+
+        TERN_(INPUT_SHAPING_X, SHAPING_QUEUE_ENQUEUE(x))
+        TERN_(INPUT_SHAPING_Y, SHAPING_QUEUE_ENQUEUE(y))
+        TERN_(INPUT_SHAPING_Z, SHAPING_QUEUE_ENQUEUE(z))
+
         times[tail] = now;
         if (++tail == shaping_echoes) tail = 0;
       }
+
+      #define SHAPING_QUEUE_DEQUEUE(AXIS)                                                                  \
+        bool forward = echo_axes[head_##AXIS].AXIS == ECHO_FWD;                                            \
+        do {                                                                                               \
+          _free_count_##AXIS++;                                                                            \
+          if (++head_##AXIS == shaping_echoes) head_##AXIS = 0;                                            \
+        } while (head_##AXIS != tail && echo_axes[head_##AXIS].AXIS == ECHO_NONE);                         \
+        _peek_##AXIS = head_##AXIS == tail ? shaping_time_t(-1) : times[head_##AXIS] + delay_##AXIS - now; \
+        return forward;
+
       #if ENABLED(INPUT_SHAPING_X)
-        static shaping_time_t peek_x() { return peek_x_val; }
-        static bool dequeue_x() {
-          bool forward = echo_axes[head_x].x == ECHO_FWD;
-          do {
-            _free_count_x++;
-            if (++head_x == shaping_echoes) head_x = 0;
-          } while (head_x != tail && echo_axes[head_x].x == ECHO_NONE);
-          peek_x_val = head_x == tail ? shaping_time_t(-1) : times[head_x] + delay_x - now;
-          return forward;
-        }
+        static shaping_time_t peek_x() { return _peek_x; }
+        static bool dequeue_x() { SHAPING_QUEUE_DEQUEUE(x) }
         static bool empty_x() { return head_x == tail; }
         static uint16_t free_count_x() { return _free_count_x; }
       #endif
       #if ENABLED(INPUT_SHAPING_Y)
-        static shaping_time_t peek_y() { return peek_y_val; }
-        static bool dequeue_y() {
-          bool forward = echo_axes[head_y].y == ECHO_FWD;
-          do {
-            _free_count_y++;
-            if (++head_y == shaping_echoes) head_y = 0;
-          } while (head_y != tail && echo_axes[head_y].y == ECHO_NONE);
-          peek_y_val = head_y == tail ? shaping_time_t(-1) : times[head_y] + delay_y - now;
-          return forward;
-        }
+        static shaping_time_t peek_y() { return _peek_y; }
+        static bool dequeue_y() { SHAPING_QUEUE_DEQUEUE(y) }
         static bool empty_y() { return head_y == tail; }
         static uint16_t free_count_y() { return _free_count_y; }
       #endif
+      #if ENABLED(INPUT_SHAPING_Z)
+        static shaping_time_t peek_z() { return _peek_z; }
+        static bool dequeue_z() { SHAPING_QUEUE_DEQUEUE(z) }
+        static bool empty_z() { return head_z == tail; }
+        static uint16_t free_count_z() { return _free_count_z; }
+      #endif
       static void purge() {
         const auto st = shaping_time_t(-1);
         #if ENABLED(INPUT_SHAPING_X)
-          head_x = tail; _free_count_x = shaping_echoes - 1; peek_x_val = st;
+          head_x = tail; _free_count_x = shaping_echoes - 1; _peek_x = st;
         #endif
         #if ENABLED(INPUT_SHAPING_Y)
-          head_y = tail; _free_count_y = shaping_echoes - 1; peek_y_val = st;
+          head_y = tail; _free_count_y = shaping_echoes - 1; _peek_y = st;
+        #endif
+        #if ENABLED(INPUT_SHAPING_Z)
+          head_z = tail; _free_count_z = shaping_echoes - 1; _peek_z = st;
         #endif
       }
   };
 
   struct ShapeParams {
     float frequency;
     float zeta;
     bool enabled : 1;
     bool forward : 1;
     int16_t delta_error = 0;    // delta_error for seconday bresenham mod 128
@@ -413,20 +408,23 @@ class Stepper {
       static bool bezier_2nd_half; // If B√©zier curve has been initialized or not
     #endif
 
     #if HAS_ZV_SHAPING
       #if ENABLED(INPUT_SHAPING_X)
         static ShapeParams shaping_x;
       #endif
       #if ENABLED(INPUT_SHAPING_Y)
         static ShapeParams shaping_y;
       #endif
+      #if ENABLED(INPUT_SHAPING_Z)
+        static ShapeParams shaping_z;
+      #endif
     #endif
 
     #if ENABLED(LIN_ADVANCE)
       static constexpr hal_timer_t LA_ADV_NEVER = HAL_TIMER_TYPE_MAX;
       static hal_timer_t nextAdvanceISR,
                          la_interval;      // Interval between ISR calls for LA
       static int32_t     la_delta_error,   // Analogue of delta_error.e for E steps in LA ISR
                          la_dividend,      // Analogue of advance_dividend.e for E steps in LA ISR
                          la_advance_steps; // Count of steps added to increase nozzle pressure
       static bool        la_active;        // Whether linear advance is used on the present segment.
@@ -510,21 +508,21 @@ class Stepper {
 
     // Check if the given block is busy or not - Must not be called from ISR contexts
     static bool is_block_busy(const block_t * const block);
 
     #if HAS_ZV_SHAPING
       // Check whether the stepper is processing any input shaping echoes
       static bool input_shaping_busy() {
         const bool was_on = hal.isr_state();
         hal.isr_off();
 
-        const bool result = TERN0(INPUT_SHAPING_X, !ShapingQueue::empty_x()) || TERN0(INPUT_SHAPING_Y, !ShapingQueue::empty_y());
+        const bool result = TERN0(INPUT_SHAPING_X, !ShapingQueue::empty_x()) || TERN0(INPUT_SHAPING_Y, !ShapingQueue::empty_y()) || TERN0(INPUT_SHAPING_Z, !ShapingQueue::empty_z());
 
         if (was_on) hal.isr_on();
 
         return result;
       }
     #endif
 
     // Get the position of a stepper, in steps
     static int32_t position(const AxisEnum axis);
 

commit 2fd7c2b8652a3250e1eb1dbfd96991b4b11f6257
Author: Mihai <299015+mh-dm@users.noreply.github.com>
Date:   Fri May 17 04:48:21 2024 +0300

    ‚ö°Ô∏è Fix motion smoothness (#27013)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 43d1012f10..82b41290bf 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -384,22 +384,22 @@ class Stepper {
       static uint8_t oversampling_factor; // Oversampling factor (log2(multiplier)) to increase temporal resolution of axis
     #else
       static constexpr uint8_t oversampling_factor = 0; // Without smoothing apply no shift
     #endif
 
     // Delta error variables for the Bresenham line tracer
     static xyze_long_t delta_error;
     static xyze_long_t advance_dividend;
     static uint32_t advance_divisor,
                     step_events_completed,  // The number of step events executed in the current block
-                    accelerate_until,       // The point from where we need to stop acceleration
-                    decelerate_after,       // The point from where we need to start decelerating
+                    accelerate_before,      // The count at which to start cruising
+                    decelerate_start,       // The count at which to start decelerating
                     step_event_count;       // The total event count for the current block
 
     #if ANY(HAS_MULTI_EXTRUDER, MIXING_EXTRUDER)
       static uint8_t stepper_extruder;
     #else
       static constexpr uint8_t stepper_extruder = 0;
     #endif
 
     #if ENABLED(S_CURVE_ACCELERATION)
       static int32_t bezier_A,     // A coefficient in B√©zier speed curve

commit 1da947f54806437fdff84adfdc06f48d2e3d60a3
Author: narno2202 <130909513+narno2202@users.noreply.github.com>
Date:   Thu May 9 23:57:23 2024 +0200

    ‚ö°Ô∏è FT_MOTION : Core and other refinements (#26720)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>
    Co-authored-by: Ulendo Alex <alex@ulendo.io>

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 84f85391d2..43d1012f10 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -677,20 +677,23 @@ class Stepper {
 
     // Set the current position in steps
     static void _set_position(const abce_long_t &spos);
 
     // Calculate the timing interval for the given step rate
     static hal_timer_t calc_timer_interval(uint32_t step_rate);
 
     // Calculate timing interval and steps-per-ISR for the given step rate
     static hal_timer_t calc_multistep_timer_interval(uint32_t step_rate);
 
+    // Evaluate axis motions and set bits in axis_did_move
+    static void set_axis_moved_for_current_block();
+
     #if ENABLED(NONLINEAR_EXTRUSION)
       static void calc_nonlinear_e(uint32_t step_rate);
     #endif
 
     #if ENABLED(S_CURVE_ACCELERATION)
       static void _calc_bezier_curve_coeffs(const int32_t v0, const int32_t v1, const uint32_t av);
       static int32_t _eval_bezier_curve(const uint32_t curr_step);
     #endif
 
     #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM

commit 60f2837a9804f71fa731ee2b9e7fe9cb468fc023
Author: Sophist <3001893+Sophist-UK@users.noreply.github.com>
Date:   Tue Apr 2 03:30:04 2024 +0100

    üîß Minor INPUT_SHAPING config fixes (#26882)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 6712198aae..84f85391d2 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -152,24 +152,24 @@ constexpr ena_mask_t enable_overlap[] = {
       template<> constexpr float max_isr_rate<0>() {
         return TERN0(ADAPTIVE_STEP_SMOOTHING, MIN_STEP_ISR_FREQUENCY);
       }
       constexpr float max_step_rate = _MIN(max_isr_rate(), max_shaped_rate);
     #else
       constexpr float max_step_rate = max_shaped_rate;
     #endif
   #endif
 
   #ifndef SHAPING_MIN_FREQ
-    #define SHAPING_MIN_FREQ _MIN(0x7FFFFFFFL OPTARG(INPUT_SHAPING_X, SHAPING_FREQ_X) OPTARG(INPUT_SHAPING_Y, SHAPING_FREQ_Y))
+    #define SHAPING_MIN_FREQ _MIN(__FLT_MAX__ OPTARG(INPUT_SHAPING_X, SHAPING_FREQ_X) OPTARG(INPUT_SHAPING_Y, SHAPING_FREQ_Y))
   #endif
-  constexpr uint16_t shaping_min_freq = SHAPING_MIN_FREQ,
-                     shaping_echoes = max_step_rate / shaping_min_freq / 2 + 3;
+  constexpr float shaping_min_freq = SHAPING_MIN_FREQ;
+  constexpr uint16_t shaping_echoes = FLOOR(max_step_rate / shaping_min_freq / 2) + 3;
 
   typedef hal_timer_t shaping_time_t;
   enum shaping_echo_t { ECHO_NONE = 0, ECHO_FWD = 1, ECHO_BWD = 2 };
   struct shaping_echo_axis_t {
     TERN_(INPUT_SHAPING_X, shaping_echo_t x:2);
     TERN_(INPUT_SHAPING_Y, shaping_echo_t y:2);
   };
 
   class ShapingQueue {
     private:

commit 87e94f456348e944ba4487aed436c762dd718966
Author: Andrew <18502096+classicrocker883@users.noreply.github.com>
Date:   Mon Apr 1 16:05:11 2024 -0400

    üö∏ Update ProUI Plot graph - part 2 (#26563)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 8c13831d9e..6712198aae 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -329,20 +329,26 @@ class Stepper {
     #endif
 
     #if ENABLED(FREEZE_FEATURE)
       static bool frozen;                 // Set this flag to instantly freeze motion
     #endif
 
     #if ENABLED(NONLINEAR_EXTRUSION)
       static ne_coeff_t ne;
     #endif
 
+    #if ENABLED(ADAPTIVE_STEP_SMOOTHING_TOGGLE)
+      static bool adaptive_step_smoothing_enabled;
+    #else
+      static constexpr bool adaptive_step_smoothing_enabled = true;
+    #endif
+
   private:
 
     static block_t* current_block;        // A pointer to the block currently being traced
 
     static AxisBits last_direction_bits,  // The next stepping-bits to be output
                     axis_did_move;        // Last Movement in the given direction is not null, as computed when the last movement was fetched from planner
 
     static bool abort_current_block;      // Signals to the stepper that current block should be aborted
 
     #if ENABLED(X_DUAL_ENDSTOPS)

commit 466282f322ae4f42a8f3db5e3c9765c38445fdc8
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Mar 31 18:20:37 2024 -0500

    ü©π Misc. changes from ProUI / ExtUI updates (#26928)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 99fd2d2936..8c13831d9e 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -370,21 +370,21 @@ class Stepper {
       static uint8_t steps_per_isr;
     #endif
 
     #if DISABLED(OLD_ADAPTIVE_MULTISTEPPING)
       static hal_timer_t time_spent_in_isr, time_spent_out_isr;
     #endif
 
     #if ENABLED(ADAPTIVE_STEP_SMOOTHING)
       static uint8_t oversampling_factor; // Oversampling factor (log2(multiplier)) to increase temporal resolution of axis
     #else
-      static constexpr uint8_t oversampling_factor = 0;
+      static constexpr uint8_t oversampling_factor = 0; // Without smoothing apply no shift
     #endif
 
     // Delta error variables for the Bresenham line tracer
     static xyze_long_t delta_error;
     static xyze_long_t advance_dividend;
     static uint32_t advance_divisor,
                     step_events_completed,  // The number of step events executed in the current block
                     accelerate_until,       // The point from where we need to stop acceleration
                     decelerate_after,       // The point from where we need to start decelerating
                     step_event_count;       // The total event count for the current block

commit 67d7562609986fae14d80036ad1e7a7f3aaa49d0
Author: narno2202 <130909513+narno2202@users.noreply.github.com>
Date:   Wed Dec 20 02:56:47 2023 +0100

    üêõ‚ö°Ô∏è FT_MOTION improvements (#26074)
    
    Co-Authored-By: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 2ccc9e7be9..99fd2d2936 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -648,21 +648,23 @@ class Stepper {
     static void apply_directions();
 
     // Set direction bits and update all stepper DIR states
     static void set_directions(const AxisBits bits) {
       last_direction_bits = bits;
       apply_directions();
     }
 
     #if ENABLED(FT_MOTION)
       // Manage the planner
-      static void ftMotion_BlockQueueUpdate();
+      static void ftMotion_blockQueueUpdate();
+      // Set current position in steps when reset flag is set in M493 and planner already synchronized
+      static void ftMotion_syncPosition();
     #endif
 
     #if HAS_ZV_SHAPING
       static void set_shaping_damping_ratio(const AxisEnum axis, const_float_t zeta);
       static float get_shaping_damping_ratio(const AxisEnum axis);
       static void set_shaping_frequency(const AxisEnum axis, const_float_t freq);
       static float get_shaping_frequency(const AxisEnum axis);
     #endif
 
   private:
@@ -687,17 +689,16 @@ class Stepper {
 
     #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
       static void digipot_init();
     #endif
 
     #if HAS_MICROSTEPS
       static void microstep_init();
     #endif
 
     #if ENABLED(FT_MOTION)
-      static void ftMotion_stepper(const bool applyDir, const ft_command_t command);
-      static void ftMotion_refreshAxisDidMove();
+      static void ftMotion_stepper();
     #endif
 
 };
 
 extern Stepper stepper;

commit aa0671fb32eb93d1f028764422c5fb8acc9b8fa1
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Fri Oct 27 22:10:02 2023 +0100

    ü©π Fix Input Shaping max_isr_rate with Distinct E factors (#26167)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index eb84426dc7..2ccc9e7be9 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -132,28 +132,29 @@ constexpr ena_mask_t enable_overlap[] = {
   #endif
 };
 
 //static_assert(!any_enable_overlap(), "There is some overlap.");
 
 #if HAS_ZV_SHAPING
 
   #ifdef SHAPING_MAX_STEPRATE
     constexpr float max_step_rate = SHAPING_MAX_STEPRATE;
   #else
+    #define ISALIM(I, ARR) _MIN(I, COUNT(ARR) - 1)
     constexpr float     _ISDASU[] = DEFAULT_AXIS_STEPS_PER_UNIT;
     constexpr feedRate_t _ISDMF[] = DEFAULT_MAX_FEEDRATE;
     constexpr float max_shaped_rate = TERN0(INPUT_SHAPING_X, _ISDMF[X_AXIS] * _ISDASU[X_AXIS]) +
                                       TERN0(INPUT_SHAPING_Y, _ISDMF[Y_AXIS] * _ISDASU[Y_AXIS]);
     #if defined(__AVR__) || !defined(ADAPTIVE_STEP_SMOOTHING)
       // MIN_STEP_ISR_FREQUENCY is known at compile time on AVRs and any reduction in SRAM is welcome
-      template<int INDEX=DISTINCT_AXES> constexpr float max_isr_rate() {
-        return _MAX(_ISDMF[INDEX - 1] * _ISDASU[INDEX - 1], max_isr_rate<INDEX - 1>());
+      template<unsigned int INDEX=DISTINCT_AXES> constexpr float max_isr_rate() {
+        return _MAX(_ISDMF[ISALIM(INDEX - 1, _ISDMF)] * _ISDASU[ISALIM(INDEX - 1, _ISDASU)], max_isr_rate<INDEX - 1>());
       }
       template<> constexpr float max_isr_rate<0>() {
         return TERN0(ADAPTIVE_STEP_SMOOTHING, MIN_STEP_ISR_FREQUENCY);
       }
       constexpr float max_step_rate = _MIN(max_isr_rate(), max_shaped_rate);
     #else
       constexpr float max_step_rate = max_shaped_rate;
     #endif
   #endif
 

commit e7e77d9612253cf7106cfc9e69f69e52f4083294
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Oct 12 09:44:46 2023 -0500

    üßë‚Äçüíª FxdTiCtrl => FTMotion

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 4312cfaa8b..eb84426dc7 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -287,21 +287,21 @@ constexpr ena_mask_t enable_overlap[] = {
 #if ENABLED(NONLINEAR_EXTRUSION)
   typedef struct { float A, B, C; void reset() { A = B = 0.0f; C = 1.0f; } } ne_coeff_t;
   typedef struct { int32_t A, B, C; } ne_fix_t;
 #endif
 
 //
 // Stepper class definition
 //
 class Stepper {
   friend class Max7219;
-  friend class FxdTiCtrl;
+  friend class FTMotion;
   friend void stepperTask(void *);
 
   public:
 
     #if ANY(HAS_EXTRA_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
       static bool separate_multi_axis;
     #endif
 
     #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
       #if HAS_MOTOR_CURRENT_PWM
@@ -528,21 +528,21 @@ class Stepper {
     // Report the positions of the steppers, in steps
     static void report_a_position(const xyz_long_t &pos);
     static void report_positions();
 
     // Discard current block and free any resources
     FORCE_INLINE static void discard_current_block() {
       #if ENABLED(DIRECT_STEPPING)
         if (current_block->is_page()) page_manager.free_page(current_block->page_idx);
       #endif
       current_block = nullptr;
-      axis_did_move = 0;
+      axis_did_move.reset();
       planner.release_current_block();
       TERN_(LIN_ADVANCE, la_interval = nextAdvanceISR = LA_ADV_NEVER);
     }
 
     // Quickly stop all steppers
     FORCE_INLINE static void quick_stop() { abort_current_block = true; }
 
     // The direction of a single motor. A true result indicates forward or positive motion.
     FORCE_INLINE static bool motor_direction(const AxisEnum axis) { return last_direction_bits[axis]; }
 
@@ -647,21 +647,21 @@ class Stepper {
     static void apply_directions();
 
     // Set direction bits and update all stepper DIR states
     static void set_directions(const AxisBits bits) {
       last_direction_bits = bits;
       apply_directions();
     }
 
     #if ENABLED(FT_MOTION)
       // Manage the planner
-      static void fxdTiCtrl_BlockQueueUpdate();
+      static void ftMotion_BlockQueueUpdate();
     #endif
 
     #if HAS_ZV_SHAPING
       static void set_shaping_damping_ratio(const AxisEnum axis, const_float_t zeta);
       static float get_shaping_damping_ratio(const AxisEnum axis);
       static void set_shaping_frequency(const AxisEnum axis, const_float_t freq);
       static float get_shaping_frequency(const AxisEnum axis);
     #endif
 
   private:
@@ -686,17 +686,17 @@ class Stepper {
 
     #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
       static void digipot_init();
     #endif
 
     #if HAS_MICROSTEPS
       static void microstep_init();
     #endif
 
     #if ENABLED(FT_MOTION)
-      static void fxdTiCtrl_stepper(const bool applyDir, const ft_command_t command);
-      static void fxdTiCtrl_refreshAxisDidMove();
+      static void ftMotion_stepper(const bool applyDir, const ft_command_t command);
+      static void ftMotion_refreshAxisDidMove();
     #endif
 
 };
 
 extern Stepper stepper;

commit e9b9d634c4ef5d48791de84545ef86d46909fec0
Author: Andrew Bortz <andrew@abortz.net>
Date:   Tue Oct 10 20:24:48 2023 -0700

    ‚ú® Nonlinear Extrusion Control (M592) (#26127)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 7dbb6b8b5a..4312cfaa8b 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -277,20 +277,25 @@ constexpr ena_mask_t enable_overlap[] = {
     bool enabled : 1;
     bool forward : 1;
     int16_t delta_error = 0;    // delta_error for seconday bresenham mod 128
     uint8_t factor1;
     uint8_t factor2;
     int32_t last_block_end_pos = 0;
   };
 
 #endif // HAS_ZV_SHAPING
 
+#if ENABLED(NONLINEAR_EXTRUSION)
+  typedef struct { float A, B, C; void reset() { A = B = 0.0f; C = 1.0f; } } ne_coeff_t;
+  typedef struct { int32_t A, B, C; } ne_fix_t;
+#endif
+
 //
 // Stepper class definition
 //
 class Stepper {
   friend class Max7219;
   friend class FxdTiCtrl;
   friend void stepperTask(void *);
 
   public:
 
@@ -319,20 +324,24 @@ class Stepper {
     #if HAS_MULTI_EXTRUDER
       static uint8_t last_moved_extruder;
     #else
       static constexpr uint8_t last_moved_extruder = 0;
     #endif
 
     #if ENABLED(FREEZE_FEATURE)
       static bool frozen;                 // Set this flag to instantly freeze motion
     #endif
 
+    #if ENABLED(NONLINEAR_EXTRUSION)
+      static ne_coeff_t ne;
+    #endif
+
   private:
 
     static block_t* current_block;        // A pointer to the block currently being traced
 
     static AxisBits last_direction_bits,  // The next stepping-bits to be output
                     axis_did_move;        // Last Movement in the given direction is not null, as computed when the last movement was fetched from planner
 
     static bool abort_current_block;      // Signals to the stepper that current block should be aborted
 
     #if ENABLED(X_DUAL_ENDSTOPS)
@@ -409,20 +418,26 @@ class Stepper {
     #if ENABLED(LIN_ADVANCE)
       static constexpr hal_timer_t LA_ADV_NEVER = HAL_TIMER_TYPE_MAX;
       static hal_timer_t nextAdvanceISR,
                          la_interval;      // Interval between ISR calls for LA
       static int32_t     la_delta_error,   // Analogue of delta_error.e for E steps in LA ISR
                          la_dividend,      // Analogue of advance_dividend.e for E steps in LA ISR
                          la_advance_steps; // Count of steps added to increase nozzle pressure
       static bool        la_active;        // Whether linear advance is used on the present segment.
     #endif
 
+    #if ENABLED(NONLINEAR_EXTRUSION)
+      static int32_t ne_edividend;
+      static uint32_t ne_scale;
+      static ne_fix_t ne_fix;
+    #endif
+
     #if ENABLED(BABYSTEPPING)
       static constexpr hal_timer_t BABYSTEP_NEVER = HAL_TIMER_TYPE_MAX;
       static hal_timer_t nextBabystepISR;
     #endif
 
     #if ENABLED(DIRECT_STEPPING)
       static page_step_state_t page_step_state;
     #endif
 
     static hal_timer_t ticks_nominal;
@@ -653,20 +668,24 @@ class Stepper {
 
     // Set the current position in steps
     static void _set_position(const abce_long_t &spos);
 
     // Calculate the timing interval for the given step rate
     static hal_timer_t calc_timer_interval(uint32_t step_rate);
 
     // Calculate timing interval and steps-per-ISR for the given step rate
     static hal_timer_t calc_multistep_timer_interval(uint32_t step_rate);
 
+    #if ENABLED(NONLINEAR_EXTRUSION)
+      static void calc_nonlinear_e(uint32_t step_rate);
+    #endif
+
     #if ENABLED(S_CURVE_ACCELERATION)
       static void _calc_bezier_curve_coeffs(const int32_t v0, const int32_t v1, const uint32_t av);
       static int32_t _eval_bezier_curve(const uint32_t curr_step);
     #endif
 
     #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
       static void digipot_init();
     #endif
 
     #if HAS_MICROSTEPS

commit 45193b4a1d82023f1b763c0340e40ec5b6fcc51c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jul 19 21:12:32 2023 -0500

    üî• Always use ISR for BABYSTEPPING (#26035)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 8ec4024ea6..7dbb6b8b5a 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -409,21 +409,21 @@ class Stepper {
     #if ENABLED(LIN_ADVANCE)
       static constexpr hal_timer_t LA_ADV_NEVER = HAL_TIMER_TYPE_MAX;
       static hal_timer_t nextAdvanceISR,
                          la_interval;      // Interval between ISR calls for LA
       static int32_t     la_delta_error,   // Analogue of delta_error.e for E steps in LA ISR
                          la_dividend,      // Analogue of advance_dividend.e for E steps in LA ISR
                          la_advance_steps; // Count of steps added to increase nozzle pressure
       static bool        la_active;        // Whether linear advance is used on the present segment.
     #endif
 
-    #if ENABLED(INTEGRATED_BABYSTEPPING)
+    #if ENABLED(BABYSTEPPING)
       static constexpr hal_timer_t BABYSTEP_NEVER = HAL_TIMER_TYPE_MAX;
       static hal_timer_t nextBabystepISR;
     #endif
 
     #if ENABLED(DIRECT_STEPPING)
       static page_step_state_t page_step_state;
     #endif
 
     static hal_timer_t ticks_nominal;
     #if DISABLED(S_CURVE_ACCELERATION)
@@ -468,21 +468,21 @@ class Stepper {
 
     #if HAS_ZV_SHAPING
       static void shaping_isr();
     #endif
 
     #if ENABLED(LIN_ADVANCE)
       // The Linear advance ISR phase
       static void advance_isr();
     #endif
 
-    #if ENABLED(INTEGRATED_BABYSTEPPING)
+    #if ENABLED(BABYSTEPPING)
       // The Babystepping ISR phase
       static hal_timer_t babystepping_isr();
       FORCE_INLINE static void initiateBabystepping() {
         if (nextBabystepISR == BABYSTEP_NEVER) {
           nextBabystepISR = 0;
           wake_up();
         }
       }
     #endif
 

commit f9c8703e778a10f0a2a46c199712a7555f2aca33
Author: Anson Liu <ansonl@users.noreply.github.com>
Date:   Sat Jul 1 03:19:16 2023 -0400

    ü©π Fix missing include cycles.h (#25927)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 9f49e353a7..8ec4024ea6 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -38,20 +38,21 @@
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with Grbl.  If not, see <https://www.gnu.org/licenses/>.
  */
 
 #include "../inc/MarlinConfig.h"
 
 #include "planner.h"
 #include "stepper/indirection.h"
+#include "stepper/cycles.h"
 #ifdef __AVR__
   #include "stepper/speed_lookuptable.h"
 #endif
 
 #if ENABLED(FT_MOTION)
   #include "ft_types.h"
 #endif
 
 // TODO: Review and ensure proper handling for special E axes with commands like M17/M18, stepper timeout, etc.
 #if ENABLED(MIXING_EXTRUDER)

commit ba08dcfb76804a912380603b3f69831ea0d1d6eb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Jun 3 04:40:07 2023 -0500

    üßë‚Äçüíª Fix narrowing conversions (#25924)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 9799319368..9f49e353a7 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -76,20 +76,23 @@ typedef struct {
       #if NUM_AXES
         bool NUM_AXIS_LIST(X:1, Y:1, Z:1, I:1, J:1, K:1, U:1, V:1, W:1);
       #endif
       #if E_STATES
         bool LIST_N(E_STATES, E0:1, E1:1, E2:1, E3:1, E4:1, E5:1, E6:1, E7:1);
       #endif
     };
   };
 } stepper_flags_t;
 
+typedef bits_t(NUM_AXES + E_STATES) e_axis_bits_t;
+constexpr e_axis_bits_t e_axis_mask = (_BV(E_STATES) - 1) << NUM_AXES;
+
 // All the stepper enable pins
 constexpr pin_t ena_pins[] = {
   NUM_AXIS_LIST_(X_ENABLE_PIN, Y_ENABLE_PIN, Z_ENABLE_PIN, I_ENABLE_PIN, J_ENABLE_PIN, K_ENABLE_PIN, U_ENABLE_PIN, V_ENABLE_PIN, W_ENABLE_PIN)
   LIST_N(E_STEPPERS, E0_ENABLE_PIN, E1_ENABLE_PIN, E2_ENABLE_PIN, E3_ENABLE_PIN, E4_ENABLE_PIN, E5_ENABLE_PIN, E6_ENABLE_PIN, E7_ENABLE_PIN)
 };
 
 // Index of the axis or extruder element in a combined array
 constexpr uint8_t index_of_axis(const AxisEnum axis E_OPTARG(const uint8_t eindex=0)) {
   return uint8_t(axis) + (E_TERN0(axis < NUM_AXES ? 0 : eindex));
 }

commit 2691167afe02fbbe74b0fdca2c28a49fac635741
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jun 2 14:26:02 2023 -0500

    üßë‚Äçüíª Dump BOTH and EITHER macros (#25908)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index a2c9861abc..9799319368 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -283,21 +283,21 @@ constexpr ena_mask_t enable_overlap[] = {
 //
 // Stepper class definition
 //
 class Stepper {
   friend class Max7219;
   friend class FxdTiCtrl;
   friend void stepperTask(void *);
 
   public:
 
-    #if EITHER(HAS_EXTRA_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
+    #if ANY(HAS_EXTRA_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
       static bool separate_multi_axis;
     #endif
 
     #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
       #if HAS_MOTOR_CURRENT_PWM
         #ifndef PWM_MOTOR_CURRENT
           #define PWM_MOTOR_CURRENT DEFAULT_PWM_MOTOR_CURRENT
         #endif
         #ifndef MOTOR_CURRENT_PWM_FREQUENCY
           #define MOTOR_CURRENT_PWM_FREQUENCY 31400
@@ -330,21 +330,21 @@ class Stepper {
                     axis_did_move;        // Last Movement in the given direction is not null, as computed when the last movement was fetched from planner
 
     static bool abort_current_block;      // Signals to the stepper that current block should be aborted
 
     #if ENABLED(X_DUAL_ENDSTOPS)
       static bool locked_X_motor, locked_X2_motor;
     #endif
     #if ENABLED(Y_DUAL_ENDSTOPS)
       static bool locked_Y_motor, locked_Y2_motor;
     #endif
-    #if EITHER(Z_MULTI_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
+    #if ANY(Z_MULTI_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
       static bool locked_Z_motor, locked_Z2_motor
                   #if NUM_Z_STEPPERS >= 3
                     , locked_Z3_motor
                     #if NUM_Z_STEPPERS >= 4
                       , locked_Z4_motor
                     #endif
                   #endif
                   ;
     #endif
 
@@ -368,21 +368,21 @@ class Stepper {
 
     // Delta error variables for the Bresenham line tracer
     static xyze_long_t delta_error;
     static xyze_long_t advance_dividend;
     static uint32_t advance_divisor,
                     step_events_completed,  // The number of step events executed in the current block
                     accelerate_until,       // The point from where we need to stop acceleration
                     decelerate_after,       // The point from where we need to start decelerating
                     step_event_count;       // The total event count for the current block
 
-    #if EITHER(HAS_MULTI_EXTRUDER, MIXING_EXTRUDER)
+    #if ANY(HAS_MULTI_EXTRUDER, MIXING_EXTRUDER)
       static uint8_t stepper_extruder;
     #else
       static constexpr uint8_t stepper_extruder = 0;
     #endif
 
     #if ENABLED(S_CURVE_ACCELERATION)
       static int32_t bezier_A,     // A coefficient in B√©zier speed curve
                      bezier_B,     // B coefficient in B√©zier speed curve
                      bezier_C;     // C coefficient in B√©zier speed curve
       static uint32_t bezier_F,    // F coefficient in B√©zier speed curve
@@ -540,32 +540,32 @@ class Stepper {
       static void set_digipot_value_spi(const int16_t address, const int16_t value);
       static void set_digipot_current(const uint8_t driver, const int16_t current);
     #endif
 
     #if HAS_MICROSTEPS
       static void microstep_ms(const uint8_t driver, const int8_t ms1, const int8_t ms2, const int8_t ms3);
       static void microstep_mode(const uint8_t driver, const uint8_t stepping);
       static void microstep_readings();
     #endif
 
-    #if EITHER(HAS_EXTRA_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
+    #if ANY(HAS_EXTRA_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
       FORCE_INLINE static void set_separate_multi_axis(const bool state) { separate_multi_axis = state; }
     #endif
     #if ENABLED(X_DUAL_ENDSTOPS)
       FORCE_INLINE static void set_x_lock(const bool state) { locked_X_motor = state; }
       FORCE_INLINE static void set_x2_lock(const bool state) { locked_X2_motor = state; }
     #endif
     #if ENABLED(Y_DUAL_ENDSTOPS)
       FORCE_INLINE static void set_y_lock(const bool state) { locked_Y_motor = state; }
       FORCE_INLINE static void set_y2_lock(const bool state) { locked_Y2_motor = state; }
     #endif
-    #if EITHER(Z_MULTI_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
+    #if ANY(Z_MULTI_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
       FORCE_INLINE static void set_z1_lock(const bool state) { locked_Z_motor = state; }
       FORCE_INLINE static void set_z2_lock(const bool state) { locked_Z2_motor = state; }
       #if NUM_Z_STEPPERS >= 3
         FORCE_INLINE static void set_z3_lock(const bool state) { locked_Z3_motor = state; }
         #if NUM_Z_STEPPERS >= 4
           FORCE_INLINE static void set_z4_lock(const bool state) { locked_Z4_motor = state; }
         #endif
       #endif
       static void set_all_z_lock(const bool lock, const int8_t except=-1) {
         set_z1_lock(lock ^ (except == 0));

commit 25ddde0394361c23194c0f4a8f9777d389040af3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon May 15 22:00:15 2023 -0500

    üßë‚Äçüíª Change Marlin DIR bits: 1=Forward, 0=Reverse (#25791)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 134bee7ac6..a2c9861abc 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -517,21 +517,21 @@ class Stepper {
       #endif
       current_block = nullptr;
       axis_did_move = 0;
       planner.release_current_block();
       TERN_(LIN_ADVANCE, la_interval = nextAdvanceISR = LA_ADV_NEVER);
     }
 
     // Quickly stop all steppers
     FORCE_INLINE static void quick_stop() { abort_current_block = true; }
 
-    // The direction of a single motor. A true result indicates reversed or negative motion.
+    // The direction of a single motor. A true result indicates forward or positive motion.
     FORCE_INLINE static bool motor_direction(const AxisEnum axis) { return last_direction_bits[axis]; }
 
     // The last movement direction was not null on the specified axis. Note that motor direction is not necessarily the same.
     FORCE_INLINE static bool axis_is_moving(const AxisEnum axis) { return axis_did_move[axis]; }
 
     // Handle a triggered endstop
     static void endstop_triggered(const AxisEnum axis);
 
     // Triggered position of an axis in steps
     static int32_t triggered_position(const AxisEnum axis);

commit 9cf1a8891f79f50627efa67aae85b7e19918eef2
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Wed May 10 21:19:05 2023 +1200

    ü©π Optional X followup (#25804)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index b6996aa932..134bee7ac6 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -66,21 +66,23 @@
 
 // Number of axes that could be enabled/disabled. Dual/multiple steppers are combined.
 #define ENABLE_COUNT (NUM_AXES + E_STATES)
 typedef bits_t(ENABLE_COUNT) ena_mask_t;
 
 // Axis flags type, for enabled state or other simple state
 typedef struct {
   union {
     ena_mask_t bits;
     struct {
-      bool NUM_AXIS_LIST(X:1, Y:1, Z:1, I:1, J:1, K:1, U:1, V:1, W:1);
+      #if NUM_AXES
+        bool NUM_AXIS_LIST(X:1, Y:1, Z:1, I:1, J:1, K:1, U:1, V:1, W:1);
+      #endif
       #if E_STATES
         bool LIST_N(E_STATES, E0:1, E1:1, E2:1, E3:1, E4:1, E5:1, E6:1, E7:1);
       #endif
     };
   };
 } stepper_flags_t;
 
 // All the stepper enable pins
 constexpr pin_t ena_pins[] = {
   NUM_AXIS_LIST_(X_ENABLE_PIN, Y_ENABLE_PIN, Z_ENABLE_PIN, I_ENABLE_PIN, J_ENABLE_PIN, K_ENABLE_PIN, U_ENABLE_PIN, V_ENABLE_PIN, W_ENABLE_PIN)

commit 1f9bfc5c7491d802d242623f8253b1f52c0917a3
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Wed May 10 06:59:25 2023 +1200

    üö∏ Optional X-Axis (#25418)
    
    Co-authored-by: alextrical <35117191+alextrical@users.noreply.github.com>
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 9e45ffa45f..b6996aa932 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -76,21 +76,21 @@ typedef struct {
       bool NUM_AXIS_LIST(X:1, Y:1, Z:1, I:1, J:1, K:1, U:1, V:1, W:1);
       #if E_STATES
         bool LIST_N(E_STATES, E0:1, E1:1, E2:1, E3:1, E4:1, E5:1, E6:1, E7:1);
       #endif
     };
   };
 } stepper_flags_t;
 
 // All the stepper enable pins
 constexpr pin_t ena_pins[] = {
-  NUM_AXIS_LIST(X_ENABLE_PIN, Y_ENABLE_PIN, Z_ENABLE_PIN, I_ENABLE_PIN, J_ENABLE_PIN, K_ENABLE_PIN, U_ENABLE_PIN, V_ENABLE_PIN, W_ENABLE_PIN),
+  NUM_AXIS_LIST_(X_ENABLE_PIN, Y_ENABLE_PIN, Z_ENABLE_PIN, I_ENABLE_PIN, J_ENABLE_PIN, K_ENABLE_PIN, U_ENABLE_PIN, V_ENABLE_PIN, W_ENABLE_PIN)
   LIST_N(E_STEPPERS, E0_ENABLE_PIN, E1_ENABLE_PIN, E2_ENABLE_PIN, E3_ENABLE_PIN, E4_ENABLE_PIN, E5_ENABLE_PIN, E6_ENABLE_PIN, E7_ENABLE_PIN)
 };
 
 // Index of the axis or extruder element in a combined array
 constexpr uint8_t index_of_axis(const AxisEnum axis E_OPTARG(const uint8_t eindex=0)) {
   return uint8_t(axis) + (E_TERN0(axis < NUM_AXES ? 0 : eindex));
 }
 //#define __IAX_N(N,V...)           _IAX_##N(V)
 //#define _IAX_N(N,V...)            __IAX_N(N,V)
 //#define _IAX_1(A)                 index_of_axis(A)

commit 664b35b77c0ddf9562de6e74dd253f5bb33ce6b0
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri May 5 03:03:33 2023 -0500

    üßë‚Äçüíª Replace axis_bits_t with AxisBits class (#25761)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 532db65dd9..9e45ffa45f 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -310,31 +310,31 @@ class Stepper {
     #endif
 
     // Last-moved extruder, as set when the last movement was fetched from planner
     #if HAS_MULTI_EXTRUDER
       static uint8_t last_moved_extruder;
     #else
       static constexpr uint8_t last_moved_extruder = 0;
     #endif
 
     #if ENABLED(FREEZE_FEATURE)
-      static bool frozen;                   // Set this flag to instantly freeze motion
+      static bool frozen;                 // Set this flag to instantly freeze motion
     #endif
 
   private:
 
-    static block_t* current_block;          // A pointer to the block currently being traced
+    static block_t* current_block;        // A pointer to the block currently being traced
 
-    static axis_bits_t last_direction_bits, // The next stepping-bits to be output
-                       axis_did_move;       // Last Movement in the given direction is not null, as computed when the last movement was fetched from planner
+    static AxisBits last_direction_bits,  // The next stepping-bits to be output
+                    axis_did_move;        // Last Movement in the given direction is not null, as computed when the last movement was fetched from planner
 
-    static bool abort_current_block;        // Signals to the stepper that current block should be aborted
+    static bool abort_current_block;      // Signals to the stepper that current block should be aborted
 
     #if ENABLED(X_DUAL_ENDSTOPS)
       static bool locked_X_motor, locked_X2_motor;
     #endif
     #if ENABLED(Y_DUAL_ENDSTOPS)
       static bool locked_Y_motor, locked_Y2_motor;
     #endif
     #if EITHER(Z_MULTI_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
       static bool locked_Z_motor, locked_Z2_motor
                   #if NUM_Z_STEPPERS >= 3
@@ -516,24 +516,24 @@ class Stepper {
       current_block = nullptr;
       axis_did_move = 0;
       planner.release_current_block();
       TERN_(LIN_ADVANCE, la_interval = nextAdvanceISR = LA_ADV_NEVER);
     }
 
     // Quickly stop all steppers
     FORCE_INLINE static void quick_stop() { abort_current_block = true; }
 
     // The direction of a single motor. A true result indicates reversed or negative motion.
-    FORCE_INLINE static bool motor_direction(const AxisEnum axis) { return TEST(last_direction_bits, axis); }
+    FORCE_INLINE static bool motor_direction(const AxisEnum axis) { return last_direction_bits[axis]; }
 
     // The last movement direction was not null on the specified axis. Note that motor direction is not necessarily the same.
-    FORCE_INLINE static bool axis_is_moving(const AxisEnum axis) { return TEST(axis_did_move, axis); }
+    FORCE_INLINE static bool axis_is_moving(const AxisEnum axis) { return axis_did_move[axis]; }
 
     // Handle a triggered endstop
     static void endstop_triggered(const AxisEnum axis);
 
     // Triggered position of an axis in steps
     static int32_t triggered_position(const AxisEnum axis);
 
     #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
       static void set_digipot_value_spi(const int16_t address, const int16_t value);
       static void set_digipot_current(const uint8_t driver, const int16_t current);
@@ -619,21 +619,21 @@ class Stepper {
     #define DISABLE_EXTRUDER(N) disable_extruder(E_TERN_(N))
     #define AXIS_IS_ENABLED(N,V...) axis_is_enabled(N E_OPTARG(#V))
 
     static void enable_all_steppers();
     static void disable_all_steppers();
 
     // Update direction states for all steppers
     static void apply_directions();
 
     // Set direction bits and update all stepper DIR states
-    static void set_directions(const axis_bits_t bits) {
+    static void set_directions(const AxisBits bits) {
       last_direction_bits = bits;
       apply_directions();
     }
 
     #if ENABLED(FT_MOTION)
       // Manage the planner
       static void fxdTiCtrl_BlockQueueUpdate();
     #endif
 
     #if HAS_ZV_SHAPING

commit 2538a7c4d6148d8249f5418a76c58ec483343d2b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Apr 29 21:28:12 2023 -0500

    üßë‚Äçüíª Move DIR inverting to *_DIR_WRITE

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 7a591d2954..532db65dd9 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -515,21 +515,21 @@ class Stepper {
       #endif
       current_block = nullptr;
       axis_did_move = 0;
       planner.release_current_block();
       TERN_(LIN_ADVANCE, la_interval = nextAdvanceISR = LA_ADV_NEVER);
     }
 
     // Quickly stop all steppers
     FORCE_INLINE static void quick_stop() { abort_current_block = true; }
 
-    // The direction of a single motor
+    // The direction of a single motor. A true result indicates reversed or negative motion.
     FORCE_INLINE static bool motor_direction(const AxisEnum axis) { return TEST(last_direction_bits, axis); }
 
     // The last movement direction was not null on the specified axis. Note that motor direction is not necessarily the same.
     FORCE_INLINE static bool axis_is_moving(const AxisEnum axis) { return TEST(axis_did_move, axis); }
 
     // Handle a triggered endstop
     static void endstop_triggered(const AxisEnum axis);
 
     // Triggered position of an axis in steps
     static int32_t triggered_position(const AxisEnum axis);

commit 673e6d5380017f6cb30e75a3cc0c9d7385bf2654
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 4 21:32:46 2023 -0500

    üßë‚Äçüíª Split up stepper.h header

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 14b8a96daa..7a591d2954 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -46,222 +46,20 @@
 #include "planner.h"
 #include "stepper/indirection.h"
 #ifdef __AVR__
   #include "stepper/speed_lookuptable.h"
 #endif
 
 #if ENABLED(FT_MOTION)
   #include "ft_types.h"
 #endif
 
-//
-// Estimate the amount of time the Stepper ISR will take to execute
-//
-
-/**
- * The method of calculating these cycle-constants is unclear.
- * Most of them are no longer used directly for pulse timing, and exist
- * only to estimate a maximum step rate based on the user's configuration.
- * As 32-bit processors continue to diverge, maintaining cycle counts
- * will become increasingly difficult and error-prone.
- */
-
-#ifdef CPU_32_BIT
-  /**
-   * Duration of START_TIMED_PULSE
-   *
-   * ...as measured on an LPC1768 with a scope and converted to cycles.
-   * Not applicable to other 32-bit processors, but as long as others
-   * take longer, pulses will be longer. For example the SKR Pro
-   * (stm32f407zgt6) requires ~60 cyles.
-   */
-  #define TIMER_READ_ADD_AND_STORE_CYCLES 34UL
-
-  // The base ISR
-  #define ISR_BASE_CYCLES 770UL
-
-  // Linear advance base time is 64 cycles
-  #if ENABLED(LIN_ADVANCE)
-    #define ISR_LA_BASE_CYCLES 64UL
-  #else
-    #define ISR_LA_BASE_CYCLES 0UL
-  #endif
-
-  // S curve interpolation adds 40 cycles
-  #if ENABLED(S_CURVE_ACCELERATION)
-    #ifdef STM32G0B1xx
-      #define ISR_S_CURVE_CYCLES 500UL
-    #else
-      #define ISR_S_CURVE_CYCLES 40UL
-    #endif
-  #else
-    #define ISR_S_CURVE_CYCLES 0UL
-  #endif
-
-  // Input shaping base time
-  #if HAS_ZV_SHAPING
-    #define ISR_SHAPING_BASE_CYCLES 180UL
-  #else
-    #define ISR_SHAPING_BASE_CYCLES 0UL
-  #endif
-
-  // Stepper Loop base cycles
-  #define ISR_LOOP_BASE_CYCLES 4UL
-
-  // And each stepper (start + stop pulse) takes in worst case
-  #define ISR_STEPPER_CYCLES 100UL
-
-#else
-  // Cycles to perform actions in START_TIMED_PULSE
-  #define TIMER_READ_ADD_AND_STORE_CYCLES 13UL
-
-  // The base ISR
-  #define ISR_BASE_CYCLES  882UL
-
-  // Linear advance base time is 32 cycles
-  #if ENABLED(LIN_ADVANCE)
-    #define ISR_LA_BASE_CYCLES 30UL
-  #else
-    #define ISR_LA_BASE_CYCLES 0UL
-  #endif
-
-  // S curve interpolation adds 160 cycles
-  #if ENABLED(S_CURVE_ACCELERATION)
-    #define ISR_S_CURVE_CYCLES 160UL
-  #else
-    #define ISR_S_CURVE_CYCLES 0UL
-  #endif
-
-  // Input shaping base time
-  #if HAS_ZV_SHAPING
-    #define ISR_SHAPING_BASE_CYCLES 290UL
-  #else
-    #define ISR_SHAPING_BASE_CYCLES 0UL
-  #endif
-
-  // Stepper Loop base cycles
-  #define ISR_LOOP_BASE_CYCLES 32UL
-
-  // And each stepper (start + stop pulse) takes in worst case
-  #define ISR_STEPPER_CYCLES 60UL
-
-#endif
-
-// If linear advance is disabled, the loop also handles them
-#if DISABLED(LIN_ADVANCE) && ENABLED(MIXING_EXTRUDER)
-  #define ISR_MIXING_STEPPER_CYCLES ((MIXING_STEPPERS) * (ISR_STEPPER_CYCLES))
-#else
-  #define ISR_MIXING_STEPPER_CYCLES  0UL
-#endif
-
-// Add time for each stepper
-#if HAS_X_STEP
-  #define ISR_X_STEPPER_CYCLES ISR_STEPPER_CYCLES
-#endif
-#if HAS_Y_STEP
-  #define ISR_Y_STEPPER_CYCLES ISR_STEPPER_CYCLES
-#endif
-#if HAS_Z_STEP
-  #define ISR_Z_STEPPER_CYCLES ISR_STEPPER_CYCLES
-#endif
-#if HAS_I_STEP
-  #define ISR_I_STEPPER_CYCLES ISR_STEPPER_CYCLES
-#endif
-#if HAS_J_STEP
-  #define ISR_J_STEPPER_CYCLES ISR_STEPPER_CYCLES
-#endif
-#if HAS_K_STEP
-  #define ISR_K_STEPPER_CYCLES ISR_STEPPER_CYCLES
-#endif
-#if HAS_U_STEP
-  #define ISR_U_STEPPER_CYCLES ISR_STEPPER_CYCLES
-#endif
-#if HAS_V_STEP
-  #define ISR_V_STEPPER_CYCLES ISR_STEPPER_CYCLES
-#endif
-#if HAS_W_STEP
-  #define ISR_W_STEPPER_CYCLES ISR_STEPPER_CYCLES
-#endif
-#if HAS_EXTRUDERS
-  #define ISR_E_STEPPER_CYCLES ISR_STEPPER_CYCLES // E is always interpolated, even for mixing extruders
-#endif
-
-// And the total minimum loop time, not including the base
-#define _PLUS_AXIS_CYCLES(A) + (ISR_##A##_STEPPER_CYCLES)
-#define MIN_ISR_LOOP_CYCLES (ISR_MIXING_STEPPER_CYCLES LOGICAL_AXIS_MAP(_PLUS_AXIS_CYCLES))
-
-// Calculate the minimum MPU cycles needed per pulse to enforce, limited to the max stepper rate
-#define _MIN_STEPPER_PULSE_CYCLES(N) _MAX(uint32_t((F_CPU) / (MAXIMUM_STEPPER_RATE)), ((F_CPU) / 500000UL) * (N))
-#if MINIMUM_STEPPER_PULSE
-  #define MIN_STEPPER_PULSE_CYCLES _MIN_STEPPER_PULSE_CYCLES(uint32_t(MINIMUM_STEPPER_PULSE))
-#elif HAS_DRIVER(LV8729)
-  #define MIN_STEPPER_PULSE_CYCLES uint32_t((((F_CPU) - 1) / 2000000) + 1) // 0.5¬µs, aka 500ns
-#else
-  #define MIN_STEPPER_PULSE_CYCLES _MIN_STEPPER_PULSE_CYCLES(1UL)
-#endif
-
-// Calculate the minimum pulse times (high and low)
-#if MINIMUM_STEPPER_PULSE && MAXIMUM_STEPPER_RATE
-  constexpr uint32_t _MIN_STEP_PERIOD_NS = 1000000000UL / MAXIMUM_STEPPER_RATE;
-  constexpr uint32_t _MIN_PULSE_HIGH_NS = 1000UL * MINIMUM_STEPPER_PULSE;
-  constexpr uint32_t _MIN_PULSE_LOW_NS = _MAX((_MIN_STEP_PERIOD_NS - _MIN(_MIN_STEP_PERIOD_NS, _MIN_PULSE_HIGH_NS)), _MIN_PULSE_HIGH_NS);
-#elif MINIMUM_STEPPER_PULSE
-  // Assume 50% duty cycle
-  constexpr uint32_t _MIN_PULSE_HIGH_NS = 1000UL * MINIMUM_STEPPER_PULSE;
-  constexpr uint32_t _MIN_PULSE_LOW_NS = _MIN_PULSE_HIGH_NS;
-#elif MAXIMUM_STEPPER_RATE
-  // Assume 50% duty cycle
-  constexpr uint32_t _MIN_PULSE_HIGH_NS = 500000000UL / MAXIMUM_STEPPER_RATE;
-  constexpr uint32_t _MIN_PULSE_LOW_NS = _MIN_PULSE_HIGH_NS;
-#else
-  #error "Expected at least one of MINIMUM_STEPPER_PULSE or MAXIMUM_STEPPER_RATE to be defined"
-#endif
-
-// The loop takes the base time plus the time for all the bresenham logic for 1 << R pulses plus the time
-// between pulses for ((1 << R) - 1) pulses. But the user could be enforcing a minimum time so the loop time is:
-#define ISR_LOOP_CYCLES(R) ((ISR_LOOP_BASE_CYCLES + MIN_ISR_LOOP_CYCLES + MIN_STEPPER_PULSE_CYCLES) * ((1UL << R) - 1) + _MAX(MIN_ISR_LOOP_CYCLES, MIN_STEPPER_PULSE_CYCLES))
-
-// Model input shaping as an extra loop call
-#define ISR_SHAPING_LOOP_CYCLES(R) (TERN0(HAS_ZV_SHAPING, (ISR_LOOP_BASE_CYCLES + TERN0(INPUT_SHAPING_X, ISR_X_STEPPER_CYCLES) + TERN0(INPUT_SHAPING_Y, ISR_Y_STEPPER_CYCLES)) << R))
-
-// If linear advance is enabled, then it is handled separately
-#if ENABLED(LIN_ADVANCE)
-
-  // Estimate the minimum LA loop time
-  #if ENABLED(MIXING_EXTRUDER) // ToDo: ???
-    // HELP ME: What is what?
-    // Directions are set up for MIXING_STEPPERS - like before.
-    // Finding the right stepper may last up to MIXING_STEPPERS loops in get_next_stepper().
-    //   These loops are a bit faster than advancing a bresenham counter.
-    // Always only one E stepper is stepped.
-    #define MIN_ISR_LA_LOOP_CYCLES ((MIXING_STEPPERS) * (ISR_STEPPER_CYCLES))
-  #else
-    #define MIN_ISR_LA_LOOP_CYCLES ISR_STEPPER_CYCLES
-  #endif
-
-  // And the real loop time
-  #define ISR_LA_LOOP_CYCLES _MAX(MIN_STEPPER_PULSE_CYCLES, MIN_ISR_LA_LOOP_CYCLES)
-
-#else
-  #define ISR_LA_LOOP_CYCLES 0UL
-#endif
-
-// Estimate the total ISR execution time in cycles given a step-per-ISR shift multiplier
-#define ISR_EXECUTION_CYCLES(R) ((ISR_BASE_CYCLES + ISR_S_CURVE_CYCLES + ISR_SHAPING_BASE_CYCLES + ISR_LOOP_CYCLES(R) + ISR_SHAPING_LOOP_CYCLES(R) + ISR_LA_BASE_CYCLES + ISR_LA_LOOP_CYCLES) >> R)
-
-// The maximum allowable stepping frequency when doing 1x stepping (in Hz)
-#define MAX_STEP_ISR_FREQUENCY_1X ((F_CPU) / ISR_EXECUTION_CYCLES(0))
-
-// The minimum step ISR rate used by ADAPTIVE_STEP_SMOOTHING to target 50% CPU usage
-// This does not account for the possibility of multi-stepping.
-#define MIN_STEP_ISR_FREQUENCY (MAX_STEP_ISR_FREQUENCY_1X >> 1)
-
 // TODO: Review and ensure proper handling for special E axes with commands like M17/M18, stepper timeout, etc.
 #if ENABLED(MIXING_EXTRUDER)
   #define E_STATES EXTRUDERS  // All steppers are set together for each mixer. (Currently limited to 1.)
 #elif HAS_SWITCHING_EXTRUDER
   #define E_STATES E_STEPPERS // One stepper for every two EXTRUDERS. The last extruder can be non-switching.
 #elif HAS_PRUSA_MMU2
   #define E_STATES E_STEPPERS // One E stepper shared with all EXTRUDERS, so setting any only sets one.
 #else
   #define E_STATES E_STEPPERS // One stepper for each extruder, so each can be disabled individually.
 #endif

commit 4e2b5b2523cc22700b0b71e6dc8c83fbd8a0b52b
Author: Giuliano Zaro <3684609+GMagician@users.noreply.github.com>
Date:   Fri May 5 04:30:51 2023 +0200

    ü©π Fix Extensible MMU for >8 colors (#25772)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 63285398cd..14b8a96daa 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -248,32 +248,43 @@
 // Estimate the total ISR execution time in cycles given a step-per-ISR shift multiplier
 #define ISR_EXECUTION_CYCLES(R) ((ISR_BASE_CYCLES + ISR_S_CURVE_CYCLES + ISR_SHAPING_BASE_CYCLES + ISR_LOOP_CYCLES(R) + ISR_SHAPING_LOOP_CYCLES(R) + ISR_LA_BASE_CYCLES + ISR_LA_LOOP_CYCLES) >> R)
 
 // The maximum allowable stepping frequency when doing 1x stepping (in Hz)
 #define MAX_STEP_ISR_FREQUENCY_1X ((F_CPU) / ISR_EXECUTION_CYCLES(0))
 
 // The minimum step ISR rate used by ADAPTIVE_STEP_SMOOTHING to target 50% CPU usage
 // This does not account for the possibility of multi-stepping.
 #define MIN_STEP_ISR_FREQUENCY (MAX_STEP_ISR_FREQUENCY_1X >> 1)
 
+// TODO: Review and ensure proper handling for special E axes with commands like M17/M18, stepper timeout, etc.
+#if ENABLED(MIXING_EXTRUDER)
+  #define E_STATES EXTRUDERS  // All steppers are set together for each mixer. (Currently limited to 1.)
+#elif HAS_SWITCHING_EXTRUDER
+  #define E_STATES E_STEPPERS // One stepper for every two EXTRUDERS. The last extruder can be non-switching.
+#elif HAS_PRUSA_MMU2
+  #define E_STATES E_STEPPERS // One E stepper shared with all EXTRUDERS, so setting any only sets one.
+#else
+  #define E_STATES E_STEPPERS // One stepper for each extruder, so each can be disabled individually.
+#endif
+
 // Number of axes that could be enabled/disabled. Dual/multiple steppers are combined.
-#define ENABLE_COUNT (NUM_AXES + E_STEPPERS)
+#define ENABLE_COUNT (NUM_AXES + E_STATES)
 typedef bits_t(ENABLE_COUNT) ena_mask_t;
 
 // Axis flags type, for enabled state or other simple state
 typedef struct {
   union {
     ena_mask_t bits;
     struct {
       bool NUM_AXIS_LIST(X:1, Y:1, Z:1, I:1, J:1, K:1, U:1, V:1, W:1);
-      #if HAS_EXTRUDERS
-        bool LIST_N(EXTRUDERS, E0:1, E1:1, E2:1, E3:1, E4:1, E5:1, E6:1, E7:1);
+      #if E_STATES
+        bool LIST_N(E_STATES, E0:1, E1:1, E2:1, E3:1, E4:1, E5:1, E6:1, E7:1);
       #endif
     };
   };
 } stepper_flags_t;
 
 // All the stepper enable pins
 constexpr pin_t ena_pins[] = {
   NUM_AXIS_LIST(X_ENABLE_PIN, Y_ENABLE_PIN, Z_ENABLE_PIN, I_ENABLE_PIN, J_ENABLE_PIN, K_ENABLE_PIN, U_ENABLE_PIN, V_ENABLE_PIN, W_ENABLE_PIN),
   LIST_N(E_STEPPERS, E0_ENABLE_PIN, E1_ENABLE_PIN, E2_ENABLE_PIN, E3_ENABLE_PIN, E4_ENABLE_PIN, E5_ENABLE_PIN, E6_ENABLE_PIN, E7_ENABLE_PIN)
 };

commit f0f7ec88823318c7d778e42b4dc7604120943032
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Apr 23 00:47:44 2023 -0500

    üßë‚Äçüíª Stepper::set_directions() => apply_directions()

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 4c54a5dbf9..63285398cd 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -807,26 +807,26 @@ class Stepper {
     #endif
 
     #define  ENABLE_EXTRUDER(N)  enable_extruder(E_TERN_(N))
     #define DISABLE_EXTRUDER(N) disable_extruder(E_TERN_(N))
     #define AXIS_IS_ENABLED(N,V...) axis_is_enabled(N E_OPTARG(#V))
 
     static void enable_all_steppers();
     static void disable_all_steppers();
 
     // Update direction states for all steppers
-    static void set_directions();
+    static void apply_directions();
 
     // Set direction bits and update all stepper DIR states
     static void set_directions(const axis_bits_t bits) {
       last_direction_bits = bits;
-      set_directions();
+      apply_directions();
     }
 
     #if ENABLED(FT_MOTION)
       // Manage the planner
       static void fxdTiCtrl_BlockQueueUpdate();
     #endif
 
     #if HAS_ZV_SHAPING
       static void set_shaping_damping_ratio(const AxisEnum axis, const_float_t zeta);
       static float get_shaping_damping_ratio(const AxisEnum axis);

commit c37fa3cc9097a9aa7fad5f168e335caabf23278e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 31 21:18:37 2023 -0500

    ‚ú® Fixed-Time Motion with Input Shaping by Ulendo (#25394)
    
    Co-authored-by: Ulendo Alex <alex@ulendo.io>

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 4adbb01991..4c54a5dbf9 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -42,20 +42,24 @@
  */
 
 #include "../inc/MarlinConfig.h"
 
 #include "planner.h"
 #include "stepper/indirection.h"
 #ifdef __AVR__
   #include "stepper/speed_lookuptable.h"
 #endif
 
+#if ENABLED(FT_MOTION)
+  #include "ft_types.h"
+#endif
+
 //
 // Estimate the amount of time the Stepper ISR will take to execute
 //
 
 /**
  * The method of calculating these cycle-constants is unclear.
  * Most of them are no longer used directly for pulse timing, and exist
  * only to estimate a maximum step rate based on the user's configuration.
  * As 32-bit processors continue to diverge, maintaining cycle counts
  * will become increasingly difficult and error-prone.
@@ -463,20 +467,21 @@ constexpr ena_mask_t enable_overlap[] = {
     int32_t last_block_end_pos = 0;
   };
 
 #endif // HAS_ZV_SHAPING
 
 //
 // Stepper class definition
 //
 class Stepper {
   friend class Max7219;
+  friend class FxdTiCtrl;
   friend void stepperTask(void *);
 
   public:
 
     #if EITHER(HAS_EXTRA_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
       static bool separate_multi_axis;
     #endif
 
     #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
       #if HAS_MOTOR_CURRENT_PWM
@@ -810,20 +815,25 @@ class Stepper {
 
     // Update direction states for all steppers
     static void set_directions();
 
     // Set direction bits and update all stepper DIR states
     static void set_directions(const axis_bits_t bits) {
       last_direction_bits = bits;
       set_directions();
     }
 
+    #if ENABLED(FT_MOTION)
+      // Manage the planner
+      static void fxdTiCtrl_BlockQueueUpdate();
+    #endif
+
     #if HAS_ZV_SHAPING
       static void set_shaping_damping_ratio(const AxisEnum axis, const_float_t zeta);
       static float get_shaping_damping_ratio(const AxisEnum axis);
       static void set_shaping_frequency(const AxisEnum axis, const_float_t freq);
       static float get_shaping_frequency(const AxisEnum axis);
     #endif
 
   private:
 
     // Set the current position in steps
@@ -841,13 +851,18 @@ class Stepper {
     #endif
 
     #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
       static void digipot_init();
     #endif
 
     #if HAS_MICROSTEPS
       static void microstep_init();
     #endif
 
+    #if ENABLED(FT_MOTION)
+      static void fxdTiCtrl_stepper(const bool applyDir, const ft_command_t command);
+      static void fxdTiCtrl_refreshAxisDidMove();
+    #endif
+
 };
 
 extern Stepper stepper;

commit 8cdf43f8fdf8900ad903d094d1aeb5dc651b324b
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 31 20:26:49 2023 -0500

    üé®  HAS_SHAPING => HAS_ZV_SHAPING

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 704805464c..4adbb01991 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -87,21 +87,21 @@
     #ifdef STM32G0B1xx
       #define ISR_S_CURVE_CYCLES 500UL
     #else
       #define ISR_S_CURVE_CYCLES 40UL
     #endif
   #else
     #define ISR_S_CURVE_CYCLES 0UL
   #endif
 
   // Input shaping base time
-  #if HAS_SHAPING
+  #if HAS_ZV_SHAPING
     #define ISR_SHAPING_BASE_CYCLES 180UL
   #else
     #define ISR_SHAPING_BASE_CYCLES 0UL
   #endif
 
   // Stepper Loop base cycles
   #define ISR_LOOP_BASE_CYCLES 4UL
 
   // And each stepper (start + stop pulse) takes in worst case
   #define ISR_STEPPER_CYCLES 100UL
@@ -121,21 +121,21 @@
   #endif
 
   // S curve interpolation adds 160 cycles
   #if ENABLED(S_CURVE_ACCELERATION)
     #define ISR_S_CURVE_CYCLES 160UL
   #else
     #define ISR_S_CURVE_CYCLES 0UL
   #endif
 
   // Input shaping base time
-  #if HAS_SHAPING
+  #if HAS_ZV_SHAPING
     #define ISR_SHAPING_BASE_CYCLES 290UL
   #else
     #define ISR_SHAPING_BASE_CYCLES 0UL
   #endif
 
   // Stepper Loop base cycles
   #define ISR_LOOP_BASE_CYCLES 32UL
 
   // And each stepper (start + stop pulse) takes in worst case
   #define ISR_STEPPER_CYCLES 60UL
@@ -210,21 +210,21 @@
   constexpr uint32_t _MIN_PULSE_LOW_NS = _MIN_PULSE_HIGH_NS;
 #else
   #error "Expected at least one of MINIMUM_STEPPER_PULSE or MAXIMUM_STEPPER_RATE to be defined"
 #endif
 
 // The loop takes the base time plus the time for all the bresenham logic for 1 << R pulses plus the time
 // between pulses for ((1 << R) - 1) pulses. But the user could be enforcing a minimum time so the loop time is:
 #define ISR_LOOP_CYCLES(R) ((ISR_LOOP_BASE_CYCLES + MIN_ISR_LOOP_CYCLES + MIN_STEPPER_PULSE_CYCLES) * ((1UL << R) - 1) + _MAX(MIN_ISR_LOOP_CYCLES, MIN_STEPPER_PULSE_CYCLES))
 
 // Model input shaping as an extra loop call
-#define ISR_SHAPING_LOOP_CYCLES(R) (TERN0(HAS_SHAPING, (ISR_LOOP_BASE_CYCLES + TERN0(INPUT_SHAPING_X, ISR_X_STEPPER_CYCLES) + TERN0(INPUT_SHAPING_Y, ISR_Y_STEPPER_CYCLES)) << R))
+#define ISR_SHAPING_LOOP_CYCLES(R) (TERN0(HAS_ZV_SHAPING, (ISR_LOOP_BASE_CYCLES + TERN0(INPUT_SHAPING_X, ISR_X_STEPPER_CYCLES) + TERN0(INPUT_SHAPING_Y, ISR_Y_STEPPER_CYCLES)) << R))
 
 // If linear advance is enabled, then it is handled separately
 #if ENABLED(LIN_ADVANCE)
 
   // Estimate the minimum LA loop time
   #if ENABLED(MIXING_EXTRUDER) // ToDo: ???
     // HELP ME: What is what?
     // Directions are set up for MIXING_STEPPERS - like before.
     // Finding the right stepper may last up to MIXING_STEPPERS loops in get_next_stepper().
     //   These loops are a bit faster than advancing a bresenham counter.
@@ -308,21 +308,21 @@ constexpr ena_mask_t enable_overlap[] = {
   #define _OVERLAP(N) ena_overlap(INDEX_OF_AXIS(AxisEnum(N))),
   REPEAT(NUM_AXES, _OVERLAP)
   #if HAS_EXTRUDERS
     #define _E_OVERLAP(N) ena_overlap(INDEX_OF_AXIS(E_AXIS, N)),
     REPEAT(E_STEPPERS, _E_OVERLAP)
   #endif
 };
 
 //static_assert(!any_enable_overlap(), "There is some overlap.");
 
-#if HAS_SHAPING
+#if HAS_ZV_SHAPING
 
   #ifdef SHAPING_MAX_STEPRATE
     constexpr float max_step_rate = SHAPING_MAX_STEPRATE;
   #else
     constexpr float     _ISDASU[] = DEFAULT_AXIS_STEPS_PER_UNIT;
     constexpr feedRate_t _ISDMF[] = DEFAULT_MAX_FEEDRATE;
     constexpr float max_shaped_rate = TERN0(INPUT_SHAPING_X, _ISDMF[X_AXIS] * _ISDASU[X_AXIS]) +
                                       TERN0(INPUT_SHAPING_Y, _ISDMF[Y_AXIS] * _ISDASU[Y_AXIS]);
     #if defined(__AVR__) || !defined(ADAPTIVE_STEP_SMOOTHING)
       // MIN_STEP_ISR_FREQUENCY is known at compile time on AVRs and any reduction in SRAM is welcome
@@ -456,21 +456,21 @@ constexpr ena_mask_t enable_overlap[] = {
     float frequency;
     float zeta;
     bool enabled : 1;
     bool forward : 1;
     int16_t delta_error = 0;    // delta_error for seconday bresenham mod 128
     uint8_t factor1;
     uint8_t factor2;
     int32_t last_block_end_pos = 0;
   };
 
-#endif // HAS_SHAPING
+#endif // HAS_ZV_SHAPING
 
 //
 // Stepper class definition
 //
 class Stepper {
   friend class Max7219;
   friend void stepperTask(void *);
 
   public:
 
@@ -570,21 +570,21 @@ class Stepper {
                      bezier_B,     // B coefficient in B√©zier speed curve
                      bezier_C;     // C coefficient in B√©zier speed curve
       static uint32_t bezier_F,    // F coefficient in B√©zier speed curve
                       bezier_AV;   // AV coefficient in B√©zier speed curve
       #ifdef __AVR__
         static bool A_negative;    // If A coefficient was negative
       #endif
       static bool bezier_2nd_half; // If B√©zier curve has been initialized or not
     #endif
 
-    #if HAS_SHAPING
+    #if HAS_ZV_SHAPING
       #if ENABLED(INPUT_SHAPING_X)
         static ShapeParams shaping_x;
       #endif
       #if ENABLED(INPUT_SHAPING_Y)
         static ShapeParams shaping_y;
       #endif
     #endif
 
     #if ENABLED(LIN_ADVANCE)
       static constexpr hal_timer_t LA_ADV_NEVER = HAL_TIMER_TYPE_MAX;
@@ -639,21 +639,21 @@ class Stepper {
 
     // The ISR scheduler
     static void isr();
 
     // The stepper pulse ISR phase
     static void pulse_phase_isr();
 
     // The stepper block processing ISR phase
     static hal_timer_t block_phase_isr();
 
-    #if HAS_SHAPING
+    #if HAS_ZV_SHAPING
       static void shaping_isr();
     #endif
 
     #if ENABLED(LIN_ADVANCE)
       // The Linear advance ISR phase
       static void advance_isr();
     #endif
 
     #if ENABLED(INTEGRATED_BABYSTEPPING)
       // The Babystepping ISR phase
@@ -662,21 +662,21 @@ class Stepper {
         if (nextBabystepISR == BABYSTEP_NEVER) {
           nextBabystepISR = 0;
           wake_up();
         }
       }
     #endif
 
     // Check if the given block is busy or not - Must not be called from ISR contexts
     static bool is_block_busy(const block_t * const block);
 
-    #if HAS_SHAPING
+    #if HAS_ZV_SHAPING
       // Check whether the stepper is processing any input shaping echoes
       static bool input_shaping_busy() {
         const bool was_on = hal.isr_state();
         hal.isr_off();
 
         const bool result = TERN0(INPUT_SHAPING_X, !ShapingQueue::empty_x()) || TERN0(INPUT_SHAPING_Y, !ShapingQueue::empty_y());
 
         if (was_on) hal.isr_on();
 
         return result;
@@ -810,21 +810,21 @@ class Stepper {
 
     // Update direction states for all steppers
     static void set_directions();
 
     // Set direction bits and update all stepper DIR states
     static void set_directions(const axis_bits_t bits) {
       last_direction_bits = bits;
       set_directions();
     }
 
-    #if HAS_SHAPING
+    #if HAS_ZV_SHAPING
       static void set_shaping_damping_ratio(const AxisEnum axis, const_float_t zeta);
       static float get_shaping_damping_ratio(const AxisEnum axis);
       static void set_shaping_frequency(const AxisEnum axis, const_float_t freq);
       static float get_shaping_frequency(const AxisEnum axis);
     #endif
 
   private:
 
     // Set the current position in steps
     static void _set_position(const abce_long_t &spos);

commit 3c882703619bde0d7cf292bb7dd7918f12edd23c
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Sat Mar 18 10:34:53 2023 +0000

    ‚ö°Ô∏è Smart Adaptive Multi-Stepping (#25474)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 797a72791c..704805464c 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -205,26 +205,26 @@
   constexpr uint32_t _MIN_PULSE_HIGH_NS = 1000UL * MINIMUM_STEPPER_PULSE;
   constexpr uint32_t _MIN_PULSE_LOW_NS = _MIN_PULSE_HIGH_NS;
 #elif MAXIMUM_STEPPER_RATE
   // Assume 50% duty cycle
   constexpr uint32_t _MIN_PULSE_HIGH_NS = 500000000UL / MAXIMUM_STEPPER_RATE;
   constexpr uint32_t _MIN_PULSE_LOW_NS = _MIN_PULSE_HIGH_NS;
 #else
   #error "Expected at least one of MINIMUM_STEPPER_PULSE or MAXIMUM_STEPPER_RATE to be defined"
 #endif
 
-// The loop takes the base time plus the time for all the bresenham logic for R pulses plus the time
-// between pulses for (R-1) pulses. But the user could be enforcing a minimum time so the loop time is:
+// The loop takes the base time plus the time for all the bresenham logic for 1 << R pulses plus the time
+// between pulses for ((1 << R) - 1) pulses. But the user could be enforcing a minimum time so the loop time is:
 #define ISR_LOOP_CYCLES(R) ((ISR_LOOP_BASE_CYCLES + MIN_ISR_LOOP_CYCLES + MIN_STEPPER_PULSE_CYCLES) * ((1UL << R) - 1) + _MAX(MIN_ISR_LOOP_CYCLES, MIN_STEPPER_PULSE_CYCLES))
 
 // Model input shaping as an extra loop call
-#define ISR_SHAPING_LOOP_CYCLES(R) (TERN0(HAS_SHAPING, ((ISR_LOOP_BASE_CYCLES) + TERN0(INPUT_SHAPING_X, ISR_X_STEPPER_CYCLES) + TERN0(INPUT_SHAPING_Y, ISR_Y_STEPPER_CYCLES)) << R))
+#define ISR_SHAPING_LOOP_CYCLES(R) (TERN0(HAS_SHAPING, (ISR_LOOP_BASE_CYCLES + TERN0(INPUT_SHAPING_X, ISR_X_STEPPER_CYCLES) + TERN0(INPUT_SHAPING_Y, ISR_Y_STEPPER_CYCLES)) << R))
 
 // If linear advance is enabled, then it is handled separately
 #if ENABLED(LIN_ADVANCE)
 
   // Estimate the minimum LA loop time
   #if ENABLED(MIXING_EXTRUDER) // ToDo: ???
     // HELP ME: What is what?
     // Directions are set up for MIXING_STEPPERS - like before.
     // Finding the right stepper may last up to MIXING_STEPPERS loops in get_next_stepper().
     //   These loops are a bit faster than advancing a bresenham counter.
@@ -234,38 +234,31 @@
     #define MIN_ISR_LA_LOOP_CYCLES ISR_STEPPER_CYCLES
   #endif
 
   // And the real loop time
   #define ISR_LA_LOOP_CYCLES _MAX(MIN_STEPPER_PULSE_CYCLES, MIN_ISR_LA_LOOP_CYCLES)
 
 #else
   #define ISR_LA_LOOP_CYCLES 0UL
 #endif
 
-// Now estimate the total ISR execution time in cycles given a step per ISR multiplier
-#define ISR_EXECUTION_CYCLES(R) (((ISR_BASE_CYCLES + ISR_S_CURVE_CYCLES + ISR_SHAPING_BASE_CYCLES + ISR_LOOP_CYCLES(R) + ISR_SHAPING_LOOP_CYCLES(R) + ISR_LA_BASE_CYCLES + ISR_LA_LOOP_CYCLES)) >> R)
+// Estimate the total ISR execution time in cycles given a step-per-ISR shift multiplier
+#define ISR_EXECUTION_CYCLES(R) ((ISR_BASE_CYCLES + ISR_S_CURVE_CYCLES + ISR_SHAPING_BASE_CYCLES + ISR_LOOP_CYCLES(R) + ISR_SHAPING_LOOP_CYCLES(R) + ISR_LA_BASE_CYCLES + ISR_LA_LOOP_CYCLES) >> R)
 
-// The maximum allowable stepping frequency when doing x128-x1 stepping (in Hz)
-#define MAX_STEP_ISR_FREQUENCY_128X ((F_CPU) / ISR_EXECUTION_CYCLES(7))
-#define MAX_STEP_ISR_FREQUENCY_64X  ((F_CPU) / ISR_EXECUTION_CYCLES(6))
-#define MAX_STEP_ISR_FREQUENCY_32X  ((F_CPU) / ISR_EXECUTION_CYCLES(5))
-#define MAX_STEP_ISR_FREQUENCY_16X  ((F_CPU) / ISR_EXECUTION_CYCLES(4))
-#define MAX_STEP_ISR_FREQUENCY_8X   ((F_CPU) / ISR_EXECUTION_CYCLES(3))
-#define MAX_STEP_ISR_FREQUENCY_4X   ((F_CPU) / ISR_EXECUTION_CYCLES(2))
-#define MAX_STEP_ISR_FREQUENCY_2X   ((F_CPU) / ISR_EXECUTION_CYCLES(1))
-#define MAX_STEP_ISR_FREQUENCY_1X   ((F_CPU) / ISR_EXECUTION_CYCLES(0))
+// The maximum allowable stepping frequency when doing 1x stepping (in Hz)
+#define MAX_STEP_ISR_FREQUENCY_1X ((F_CPU) / ISR_EXECUTION_CYCLES(0))
 
 // The minimum step ISR rate used by ADAPTIVE_STEP_SMOOTHING to target 50% CPU usage
 // This does not account for the possibility of multi-stepping.
-// Should a MULTISTEPPING_LIMIT of 1 should be required with ADAPTIVE_STEP_SMOOTHING?
-#define MIN_STEP_ISR_FREQUENCY (MAX_STEP_ISR_FREQUENCY_1X / 2)
+#define MIN_STEP_ISR_FREQUENCY (MAX_STEP_ISR_FREQUENCY_1X >> 1)
 
+// Number of axes that could be enabled/disabled. Dual/multiple steppers are combined.
 #define ENABLE_COUNT (NUM_AXES + E_STEPPERS)
 typedef bits_t(ENABLE_COUNT) ena_mask_t;
 
 // Axis flags type, for enabled state or other simple state
 typedef struct {
   union {
     ena_mask_t bits;
     struct {
       bool NUM_AXIS_LIST(X:1, Y:1, Z:1, I:1, J:1, K:1, U:1, V:1, W:1);
       #if HAS_EXTRUDERS
@@ -540,20 +533,24 @@ class Stepper {
     #endif
 
     static uint32_t acceleration_time, deceleration_time; // time measured in Stepper Timer ticks
 
     #if MULTISTEPPING_LIMIT == 1
       static constexpr uint8_t steps_per_isr = 1; // Count of steps to perform per Stepper ISR call
     #else
       static uint8_t steps_per_isr;
     #endif
 
+    #if DISABLED(OLD_ADAPTIVE_MULTISTEPPING)
+      static hal_timer_t time_spent_in_isr, time_spent_out_isr;
+    #endif
+
     #if ENABLED(ADAPTIVE_STEP_SMOOTHING)
       static uint8_t oversampling_factor; // Oversampling factor (log2(multiplier)) to increase temporal resolution of axis
     #else
       static constexpr uint8_t oversampling_factor = 0;
     #endif
 
     // Delta error variables for the Bresenham line tracer
     static xyze_long_t delta_error;
     static xyze_long_t advance_dividend;
     static uint32_t advance_divisor,

commit db2b8a695d2c1db99af009c3b72a60f566823484
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Mar 12 16:30:10 2023 -0500

    ‚ö°Ô∏è Update ISR cycle counts
    
    Co-Authored-By: tombrazier <68918209+tombrazier@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 820d1d9a73..797a72791c 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -104,21 +104,21 @@
   #define ISR_LOOP_BASE_CYCLES 4UL
 
   // And each stepper (start + stop pulse) takes in worst case
   #define ISR_STEPPER_CYCLES 100UL
 
 #else
   // Cycles to perform actions in START_TIMED_PULSE
   #define TIMER_READ_ADD_AND_STORE_CYCLES 13UL
 
   // The base ISR
-  #define ISR_BASE_CYCLES  996UL
+  #define ISR_BASE_CYCLES  882UL
 
   // Linear advance base time is 32 cycles
   #if ENABLED(LIN_ADVANCE)
     #define ISR_LA_BASE_CYCLES 30UL
   #else
     #define ISR_LA_BASE_CYCLES 0UL
   #endif
 
   // S curve interpolation adds 160 cycles
   #if ENABLED(S_CURVE_ACCELERATION)
@@ -131,21 +131,21 @@
   #if HAS_SHAPING
     #define ISR_SHAPING_BASE_CYCLES 290UL
   #else
     #define ISR_SHAPING_BASE_CYCLES 0UL
   #endif
 
   // Stepper Loop base cycles
   #define ISR_LOOP_BASE_CYCLES 32UL
 
   // And each stepper (start + stop pulse) takes in worst case
-  #define ISR_STEPPER_CYCLES 88UL
+  #define ISR_STEPPER_CYCLES 60UL
 
 #endif
 
 // If linear advance is disabled, the loop also handles them
 #if DISABLED(LIN_ADVANCE) && ENABLED(MIXING_EXTRUDER)
   #define ISR_MIXING_STEPPER_CYCLES ((MIXING_STEPPERS) * (ISR_STEPPER_CYCLES))
 #else
   #define ISR_MIXING_STEPPER_CYCLES  0UL
 #endif
 

commit 3365172e7c7b577d12912a7d942d3a2fa5c75f74
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 11 19:54:48 2023 -0600

    üîß Expose MULTISTEPPING_LIMIT option
    
    Co-Authored-By: tombrazier <68918209+tombrazier@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index ebd7e98aeb..820d1d9a73 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -42,23 +42,20 @@
  */
 
 #include "../inc/MarlinConfig.h"
 
 #include "planner.h"
 #include "stepper/indirection.h"
 #ifdef __AVR__
   #include "stepper/speed_lookuptable.h"
 #endif
 
-// Disable multiple steps per ISR
-//#define DISABLE_MULTI_STEPPING
-
 //
 // Estimate the amount of time the Stepper ISR will take to execute
 //
 
 /**
  * The method of calculating these cycle-constants is unclear.
  * Most of them are no longer used directly for pulse timing, and exist
  * only to estimate a maximum step rate based on the user's configuration.
  * As 32-bit processors continue to diverge, maintaining cycle counts
  * will become increasingly difficult and error-prone.
@@ -252,21 +249,21 @@
 #define MAX_STEP_ISR_FREQUENCY_64X  ((F_CPU) / ISR_EXECUTION_CYCLES(6))
 #define MAX_STEP_ISR_FREQUENCY_32X  ((F_CPU) / ISR_EXECUTION_CYCLES(5))
 #define MAX_STEP_ISR_FREQUENCY_16X  ((F_CPU) / ISR_EXECUTION_CYCLES(4))
 #define MAX_STEP_ISR_FREQUENCY_8X   ((F_CPU) / ISR_EXECUTION_CYCLES(3))
 #define MAX_STEP_ISR_FREQUENCY_4X   ((F_CPU) / ISR_EXECUTION_CYCLES(2))
 #define MAX_STEP_ISR_FREQUENCY_2X   ((F_CPU) / ISR_EXECUTION_CYCLES(1))
 #define MAX_STEP_ISR_FREQUENCY_1X   ((F_CPU) / ISR_EXECUTION_CYCLES(0))
 
 // The minimum step ISR rate used by ADAPTIVE_STEP_SMOOTHING to target 50% CPU usage
 // This does not account for the possibility of multi-stepping.
-// Perhaps DISABLE_MULTI_STEPPING should be required with ADAPTIVE_STEP_SMOOTHING.
+// Should a MULTISTEPPING_LIMIT of 1 should be required with ADAPTIVE_STEP_SMOOTHING?
 #define MIN_STEP_ISR_FREQUENCY (MAX_STEP_ISR_FREQUENCY_1X / 2)
 
 #define ENABLE_COUNT (NUM_AXES + E_STEPPERS)
 typedef bits_t(ENABLE_COUNT) ena_mask_t;
 
 // Axis flags type, for enabled state or other simple state
 typedef struct {
   union {
     ena_mask_t bits;
     struct {
@@ -536,21 +533,26 @@ class Stepper {
                   #if NUM_Z_STEPPERS >= 3
                     , locked_Z3_motor
                     #if NUM_Z_STEPPERS >= 4
                       , locked_Z4_motor
                     #endif
                   #endif
                   ;
     #endif
 
     static uint32_t acceleration_time, deceleration_time; // time measured in Stepper Timer ticks
-    static uint8_t steps_per_isr;         // Count of steps to perform per Stepper ISR call
+
+    #if MULTISTEPPING_LIMIT == 1
+      static constexpr uint8_t steps_per_isr = 1; // Count of steps to perform per Stepper ISR call
+    #else
+      static uint8_t steps_per_isr;
+    #endif
 
     #if ENABLED(ADAPTIVE_STEP_SMOOTHING)
       static uint8_t oversampling_factor; // Oversampling factor (log2(multiplier)) to increase temporal resolution of axis
     #else
       static constexpr uint8_t oversampling_factor = 0;
     #endif
 
     // Delta error variables for the Bresenham line tracer
     static xyze_long_t delta_error;
     static xyze_long_t advance_dividend;

commit 549419e08482873422675173cd9d241362b88f00
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 11 19:25:42 2023 -0600

    ‚ö°Ô∏è Set steps_per_isr in calc_multistep_timer_interval
    
    Co-Authored-By: tombrazier <68918209+tombrazier@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 731d7e6ee8..ebd7e98aeb 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -827,21 +827,21 @@ class Stepper {
 
   private:
 
     // Set the current position in steps
     static void _set_position(const abce_long_t &spos);
 
     // Calculate the timing interval for the given step rate
     static hal_timer_t calc_timer_interval(uint32_t step_rate);
 
     // Calculate timing interval and steps-per-ISR for the given step rate
-    static hal_timer_t calc_timer_interval(uint32_t step_rate, uint8_t &loops);
+    static hal_timer_t calc_multistep_timer_interval(uint32_t step_rate);
 
     #if ENABLED(S_CURVE_ACCELERATION)
       static void _calc_bezier_curve_coeffs(const int32_t v0, const int32_t v1, const uint32_t av);
       static int32_t _eval_bezier_curve(const uint32_t curr_step);
     #endif
 
     #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
       static void digipot_init();
     #endif
 

commit e4b83ad5f58772f73d9b2dcc9dcccbbc2a3e893d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 11 19:22:18 2023 -0600

    ‚ö°Ô∏è Major shaper optimization
    
    Co-Authored-By: tombrazier <68918209+tombrazier@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 61dcb3804c..731d7e6ee8 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -385,30 +385,50 @@ constexpr ena_mask_t enable_overlap[] = {
       static void decrement_delays(const shaping_time_t interval) {
         now += interval;
         TERN_(INPUT_SHAPING_X, if (peek_x_val != shaping_time_t(-1)) peek_x_val -= interval);
         TERN_(INPUT_SHAPING_Y, if (peek_y_val != shaping_time_t(-1)) peek_y_val -= interval);
       }
       static void set_delay(const AxisEnum axis, const shaping_time_t delay) {
         TERN_(INPUT_SHAPING_X, if (axis == X_AXIS) delay_x = delay);
         TERN_(INPUT_SHAPING_Y, if (axis == Y_AXIS) delay_y = delay);
       }
       static void enqueue(const bool x_step, const bool x_forward, const bool y_step, const bool y_forward) {
-        TERN_(INPUT_SHAPING_X, if (head_x == tail && x_step) peek_x_val = delay_x);
-        TERN_(INPUT_SHAPING_Y, if (head_y == tail && y_step) peek_y_val = delay_y);
+        #if ENABLED(INPUT_SHAPING_X)
+          if (x_step) {
+            if (head_x == tail) peek_x_val = delay_x;
+            echo_axes[tail].x = x_forward ? ECHO_FWD : ECHO_BWD;
+            _free_count_x--;
+          }
+          else {
+            echo_axes[tail].x = ECHO_NONE;
+            if (head_x != tail)
+              _free_count_x--;
+            else if (++head_x == shaping_echoes)
+              head_x = 0;
+          }
+        #endif
+        #if ENABLED(INPUT_SHAPING_Y)
+          if (y_step) {
+            if (head_y == tail) peek_y_val = delay_y;
+            echo_axes[tail].y = y_forward ? ECHO_FWD : ECHO_BWD;
+            _free_count_y--;
+          }
+          else {
+            echo_axes[tail].y = ECHO_NONE;
+            if (head_y != tail)
+              _free_count_y--;
+            else if (++head_y == shaping_echoes)
+              head_y = 0;
+          }
+        #endif
         times[tail] = now;
-        TERN_(INPUT_SHAPING_X, echo_axes[tail].x = x_step ? (x_forward ? ECHO_FWD : ECHO_BWD) : ECHO_NONE);
-        TERN_(INPUT_SHAPING_Y, echo_axes[tail].y = y_step ? (y_forward ? ECHO_FWD : ECHO_BWD) : ECHO_NONE);
         if (++tail == shaping_echoes) tail = 0;
-        TERN_(INPUT_SHAPING_X, _free_count_x--);
-        TERN_(INPUT_SHAPING_Y, _free_count_y--);
-        TERN_(INPUT_SHAPING_X, if (echo_axes[head_x].x == ECHO_NONE) dequeue_x());
-        TERN_(INPUT_SHAPING_Y, if (echo_axes[head_y].y == ECHO_NONE) dequeue_y());
       }
       #if ENABLED(INPUT_SHAPING_X)
         static shaping_time_t peek_x() { return peek_x_val; }
         static bool dequeue_x() {
           bool forward = echo_axes[head_x].x == ECHO_FWD;
           do {
             _free_count_x++;
             if (++head_x == shaping_echoes) head_x = 0;
           } while (head_x != tail && echo_axes[head_x].x == ECHO_NONE);
           peek_x_val = head_x == tail ? shaping_time_t(-1) : times[head_x] + delay_x - now;
@@ -438,25 +458,25 @@ constexpr ena_mask_t enable_overlap[] = {
         #endif
         #if ENABLED(INPUT_SHAPING_Y)
           head_y = tail; _free_count_y = shaping_echoes - 1; peek_y_val = st;
         #endif
       }
   };
 
   struct ShapeParams {
     float frequency;
     float zeta;
-    bool enabled;
+    bool enabled : 1;
+    bool forward : 1;
     int16_t delta_error = 0;    // delta_error for seconday bresenham mod 128
     uint8_t factor1;
     uint8_t factor2;
-    bool forward;
     int32_t last_block_end_pos = 0;
   };
 
 #endif // HAS_SHAPING
 
 //
 // Stepper class definition
 //
 class Stepper {
   friend class Max7219;

commit d554844a51691c4e88d0fab8e7893b62e090f235
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 11 19:19:36 2023 -0600

    ‚ö°Ô∏è Use cached la_active state
    
    Co-Authored-By: tombrazier <68918209+tombrazier@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 2336bfb405..61dcb3804c 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -567,20 +567,21 @@ class Stepper {
       #endif
     #endif
 
     #if ENABLED(LIN_ADVANCE)
       static constexpr hal_timer_t LA_ADV_NEVER = HAL_TIMER_TYPE_MAX;
       static hal_timer_t nextAdvanceISR,
                          la_interval;      // Interval between ISR calls for LA
       static int32_t     la_delta_error,   // Analogue of delta_error.e for E steps in LA ISR
                          la_dividend,      // Analogue of advance_dividend.e for E steps in LA ISR
                          la_advance_steps; // Count of steps added to increase nozzle pressure
+      static bool        la_active;        // Whether linear advance is used on the present segment.
     #endif
 
     #if ENABLED(INTEGRATED_BABYSTEPPING)
       static constexpr hal_timer_t BABYSTEP_NEVER = HAL_TIMER_TYPE_MAX;
       static hal_timer_t nextBabystepISR;
     #endif
 
     #if ENABLED(DIRECT_STEPPING)
       static page_step_state_t page_step_state;
     #endif

commit 194f58740a34c8aa8daebf21baf614c6f1eec518
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 11 19:08:13 2023 -0600

    ‚ö°Ô∏è Use hal_timer_t for timing vars
    
    Co-Authored-By: tombrazier <68918209+tombrazier@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 33f45b9ae1..2336bfb405 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -561,38 +561,38 @@ class Stepper {
     #if HAS_SHAPING
       #if ENABLED(INPUT_SHAPING_X)
         static ShapeParams shaping_x;
       #endif
       #if ENABLED(INPUT_SHAPING_Y)
         static ShapeParams shaping_y;
       #endif
     #endif
 
     #if ENABLED(LIN_ADVANCE)
-      static constexpr uint32_t LA_ADV_NEVER = 0xFFFFFFFF;
-      static uint32_t nextAdvanceISR,
-                      la_interval;      // Interval between ISR calls for LA
-      static int32_t  la_delta_error,   // Analogue of delta_error.e for E steps in LA ISR
-                      la_dividend,      // Analogue of advance_dividend.e for E steps in LA ISR
-                      la_advance_steps; // Count of steps added to increase nozzle pressure
+      static constexpr hal_timer_t LA_ADV_NEVER = HAL_TIMER_TYPE_MAX;
+      static hal_timer_t nextAdvanceISR,
+                         la_interval;      // Interval between ISR calls for LA
+      static int32_t     la_delta_error,   // Analogue of delta_error.e for E steps in LA ISR
+                         la_dividend,      // Analogue of advance_dividend.e for E steps in LA ISR
+                         la_advance_steps; // Count of steps added to increase nozzle pressure
     #endif
 
     #if ENABLED(INTEGRATED_BABYSTEPPING)
-      static constexpr uint32_t BABYSTEP_NEVER = 0xFFFFFFFF;
-      static uint32_t nextBabystepISR;
+      static constexpr hal_timer_t BABYSTEP_NEVER = HAL_TIMER_TYPE_MAX;
+      static hal_timer_t nextBabystepISR;
     #endif
 
     #if ENABLED(DIRECT_STEPPING)
       static page_step_state_t page_step_state;
     #endif
 
-    static int32_t ticks_nominal;
+    static hal_timer_t ticks_nominal;
     #if DISABLED(S_CURVE_ACCELERATION)
       static uint32_t acc_step_rate; // needed for deceleration start point
     #endif
 
     // Exact steps at which an endstop was triggered
     static xyz_long_t endstops_trigsteps;
 
     // Positions of stepper motors, in step units
     static xyze_long_t count_position;
 
@@ -617,34 +617,34 @@ class Stepper {
       return awake;
     }
 
     // The ISR scheduler
     static void isr();
 
     // The stepper pulse ISR phase
     static void pulse_phase_isr();
 
     // The stepper block processing ISR phase
-    static uint32_t block_phase_isr();
+    static hal_timer_t block_phase_isr();
 
     #if HAS_SHAPING
       static void shaping_isr();
     #endif
 
     #if ENABLED(LIN_ADVANCE)
       // The Linear advance ISR phase
       static void advance_isr();
     #endif
 
     #if ENABLED(INTEGRATED_BABYSTEPPING)
       // The Babystepping ISR phase
-      static uint32_t babystepping_isr();
+      static hal_timer_t babystepping_isr();
       FORCE_INLINE static void initiateBabystepping() {
         if (nextBabystepISR == BABYSTEP_NEVER) {
           nextBabystepISR = 0;
           wake_up();
         }
       }
     #endif
 
     // Check if the given block is busy or not - Must not be called from ISR contexts
     static bool is_block_busy(const block_t * const block);
@@ -803,24 +803,24 @@ class Stepper {
       static void set_shaping_frequency(const AxisEnum axis, const_float_t freq);
       static float get_shaping_frequency(const AxisEnum axis);
     #endif
 
   private:
 
     // Set the current position in steps
     static void _set_position(const abce_long_t &spos);
 
     // Calculate the timing interval for the given step rate
-    static uint32_t calc_timer_interval(uint32_t step_rate);
+    static hal_timer_t calc_timer_interval(uint32_t step_rate);
 
     // Calculate timing interval and steps-per-ISR for the given step rate
-    static uint32_t calc_timer_interval(uint32_t step_rate, uint8_t &loops);
+    static hal_timer_t calc_timer_interval(uint32_t step_rate, uint8_t &loops);
 
     #if ENABLED(S_CURVE_ACCELERATION)
       static void _calc_bezier_curve_coeffs(const int32_t v0, const int32_t v1, const uint32_t av);
       static int32_t _eval_bezier_curve(const uint32_t curr_step);
     #endif
 
     #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
       static void digipot_init();
     #endif
 

commit 4fdb0fbe8e8e8187d05bf56e8ee8e2a138120a4c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 11 19:53:32 2023 -0600

    ‚ú® MAX7219_DEBUG_MULTISTEPPING
    
    Co-Authored-By: tombrazier <68918209+tombrazier@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 3a3e45dccc..33f45b9ae1 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -452,20 +452,21 @@ constexpr ena_mask_t enable_overlap[] = {
     bool forward;
     int32_t last_block_end_pos = 0;
   };
 
 #endif // HAS_SHAPING
 
 //
 // Stepper class definition
 //
 class Stepper {
+  friend class Max7219;
   friend void stepperTask(void *);
 
   public:
 
     #if EITHER(HAS_EXTRA_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
       static bool separate_multi_axis;
     #endif
 
     #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
       #if HAS_MOTOR_CURRENT_PWM

commit f9d3939d2331b785c59924538f1d248d5ad23a58
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 11 18:51:37 2023 -0600

    üé® Cosmetic stepper updates
    
    Co-Authored-By: tombrazier <68918209+tombrazier@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 05f609c9f3..3a3e45dccc 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -210,24 +210,24 @@
 #elif MAXIMUM_STEPPER_RATE
   // Assume 50% duty cycle
   constexpr uint32_t _MIN_PULSE_HIGH_NS = 500000000UL / MAXIMUM_STEPPER_RATE;
   constexpr uint32_t _MIN_PULSE_LOW_NS = _MIN_PULSE_HIGH_NS;
 #else
   #error "Expected at least one of MINIMUM_STEPPER_PULSE or MAXIMUM_STEPPER_RATE to be defined"
 #endif
 
 // The loop takes the base time plus the time for all the bresenham logic for R pulses plus the time
 // between pulses for (R-1) pulses. But the user could be enforcing a minimum time so the loop time is:
-#define ISR_LOOP_CYCLES(R) ((ISR_LOOP_BASE_CYCLES + MIN_ISR_LOOP_CYCLES + MIN_STEPPER_PULSE_CYCLES) * (R - 1) + _MAX(MIN_ISR_LOOP_CYCLES, MIN_STEPPER_PULSE_CYCLES))
+#define ISR_LOOP_CYCLES(R) ((ISR_LOOP_BASE_CYCLES + MIN_ISR_LOOP_CYCLES + MIN_STEPPER_PULSE_CYCLES) * ((1UL << R) - 1) + _MAX(MIN_ISR_LOOP_CYCLES, MIN_STEPPER_PULSE_CYCLES))
 
 // Model input shaping as an extra loop call
-#define ISR_SHAPING_LOOP_CYCLES(R) TERN0(HAS_SHAPING, (R) * ((ISR_LOOP_BASE_CYCLES) + TERN0(INPUT_SHAPING_X, ISR_X_STEPPER_CYCLES) + TERN0(INPUT_SHAPING_Y, ISR_Y_STEPPER_CYCLES)))
+#define ISR_SHAPING_LOOP_CYCLES(R) (TERN0(HAS_SHAPING, ((ISR_LOOP_BASE_CYCLES) + TERN0(INPUT_SHAPING_X, ISR_X_STEPPER_CYCLES) + TERN0(INPUT_SHAPING_Y, ISR_Y_STEPPER_CYCLES)) << R))
 
 // If linear advance is enabled, then it is handled separately
 #if ENABLED(LIN_ADVANCE)
 
   // Estimate the minimum LA loop time
   #if ENABLED(MIXING_EXTRUDER) // ToDo: ???
     // HELP ME: What is what?
     // Directions are set up for MIXING_STEPPERS - like before.
     // Finding the right stepper may last up to MIXING_STEPPERS loops in get_next_stepper().
     //   These loops are a bit faster than advancing a bresenham counter.
@@ -238,31 +238,31 @@
   #endif
 
   // And the real loop time
   #define ISR_LA_LOOP_CYCLES _MAX(MIN_STEPPER_PULSE_CYCLES, MIN_ISR_LA_LOOP_CYCLES)
 
 #else
   #define ISR_LA_LOOP_CYCLES 0UL
 #endif
 
 // Now estimate the total ISR execution time in cycles given a step per ISR multiplier
-#define ISR_EXECUTION_CYCLES(R) (((ISR_BASE_CYCLES + ISR_S_CURVE_CYCLES + ISR_SHAPING_BASE_CYCLES + ISR_LOOP_CYCLES(R) + ISR_SHAPING_LOOP_CYCLES(R) + ISR_LA_BASE_CYCLES + ISR_LA_LOOP_CYCLES)) / (R))
+#define ISR_EXECUTION_CYCLES(R) (((ISR_BASE_CYCLES + ISR_S_CURVE_CYCLES + ISR_SHAPING_BASE_CYCLES + ISR_LOOP_CYCLES(R) + ISR_SHAPING_LOOP_CYCLES(R) + ISR_LA_BASE_CYCLES + ISR_LA_LOOP_CYCLES)) >> R)
 
 // The maximum allowable stepping frequency when doing x128-x1 stepping (in Hz)
-#define MAX_STEP_ISR_FREQUENCY_128X ((F_CPU) / ISR_EXECUTION_CYCLES(128))
-#define MAX_STEP_ISR_FREQUENCY_64X  ((F_CPU) / ISR_EXECUTION_CYCLES(64))
-#define MAX_STEP_ISR_FREQUENCY_32X  ((F_CPU) / ISR_EXECUTION_CYCLES(32))
-#define MAX_STEP_ISR_FREQUENCY_16X  ((F_CPU) / ISR_EXECUTION_CYCLES(16))
-#define MAX_STEP_ISR_FREQUENCY_8X   ((F_CPU) / ISR_EXECUTION_CYCLES(8))
-#define MAX_STEP_ISR_FREQUENCY_4X   ((F_CPU) / ISR_EXECUTION_CYCLES(4))
-#define MAX_STEP_ISR_FREQUENCY_2X   ((F_CPU) / ISR_EXECUTION_CYCLES(2))
-#define MAX_STEP_ISR_FREQUENCY_1X   ((F_CPU) / ISR_EXECUTION_CYCLES(1))
+#define MAX_STEP_ISR_FREQUENCY_128X ((F_CPU) / ISR_EXECUTION_CYCLES(7))
+#define MAX_STEP_ISR_FREQUENCY_64X  ((F_CPU) / ISR_EXECUTION_CYCLES(6))
+#define MAX_STEP_ISR_FREQUENCY_32X  ((F_CPU) / ISR_EXECUTION_CYCLES(5))
+#define MAX_STEP_ISR_FREQUENCY_16X  ((F_CPU) / ISR_EXECUTION_CYCLES(4))
+#define MAX_STEP_ISR_FREQUENCY_8X   ((F_CPU) / ISR_EXECUTION_CYCLES(3))
+#define MAX_STEP_ISR_FREQUENCY_4X   ((F_CPU) / ISR_EXECUTION_CYCLES(2))
+#define MAX_STEP_ISR_FREQUENCY_2X   ((F_CPU) / ISR_EXECUTION_CYCLES(1))
+#define MAX_STEP_ISR_FREQUENCY_1X   ((F_CPU) / ISR_EXECUTION_CYCLES(0))
 
 // The minimum step ISR rate used by ADAPTIVE_STEP_SMOOTHING to target 50% CPU usage
 // This does not account for the possibility of multi-stepping.
 // Perhaps DISABLE_MULTI_STEPPING should be required with ADAPTIVE_STEP_SMOOTHING.
 #define MIN_STEP_ISR_FREQUENCY (MAX_STEP_ISR_FREQUENCY_1X / 2)
 
 #define ENABLE_COUNT (NUM_AXES + E_STEPPERS)
 typedef bits_t(ENABLE_COUNT) ena_mask_t;
 
 // Axis flags type, for enabled state or other simple state
@@ -452,22 +452,20 @@ constexpr ena_mask_t enable_overlap[] = {
     bool forward;
     int32_t last_block_end_pos = 0;
   };
 
 #endif // HAS_SHAPING
 
 //
 // Stepper class definition
 //
 class Stepper {
-  friend class KinematicSystem;
-  friend class DeltaKinematicSystem;
   friend void stepperTask(void *);
 
   public:
 
     #if EITHER(HAS_EXTRA_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
       static bool separate_multi_axis;
     #endif
 
     #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
       #if HAS_MOTOR_CURRENT_PWM
@@ -803,22 +801,24 @@ class Stepper {
       static float get_shaping_damping_ratio(const AxisEnum axis);
       static void set_shaping_frequency(const AxisEnum axis, const_float_t freq);
       static float get_shaping_frequency(const AxisEnum axis);
     #endif
 
   private:
 
     // Set the current position in steps
     static void _set_position(const abce_long_t &spos);
 
-    // Calculate timing interval for the given step rate
+    // Calculate the timing interval for the given step rate
     static uint32_t calc_timer_interval(uint32_t step_rate);
+
+    // Calculate timing interval and steps-per-ISR for the given step rate
     static uint32_t calc_timer_interval(uint32_t step_rate, uint8_t &loops);
 
     #if ENABLED(S_CURVE_ACCELERATION)
       static void _calc_bezier_curve_coeffs(const int32_t v0, const int32_t v1, const uint32_t av);
       static int32_t _eval_bezier_curve(const uint32_t curr_step);
     #endif
 
     #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
       static void digipot_init();
     #endif

commit f0c8c9182090f8929ec4766683ec2d6902d4bc00
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Mar 3 20:44:24 2023 -0600

    üßë‚Äçüíª Width/Magnitude-based types (#25458)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index dcb9babde7..05f609c9f3 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -256,25 +256,21 @@
 #define MAX_STEP_ISR_FREQUENCY_4X   ((F_CPU) / ISR_EXECUTION_CYCLES(4))
 #define MAX_STEP_ISR_FREQUENCY_2X   ((F_CPU) / ISR_EXECUTION_CYCLES(2))
 #define MAX_STEP_ISR_FREQUENCY_1X   ((F_CPU) / ISR_EXECUTION_CYCLES(1))
 
 // The minimum step ISR rate used by ADAPTIVE_STEP_SMOOTHING to target 50% CPU usage
 // This does not account for the possibility of multi-stepping.
 // Perhaps DISABLE_MULTI_STEPPING should be required with ADAPTIVE_STEP_SMOOTHING.
 #define MIN_STEP_ISR_FREQUENCY (MAX_STEP_ISR_FREQUENCY_1X / 2)
 
 #define ENABLE_COUNT (NUM_AXES + E_STEPPERS)
-#if ENABLE_COUNT > 16
-  typedef uint32_t ena_mask_t;
-#else
-  typedef IF<(ENABLE_COUNT > 8), uint16_t, uint8_t>::type ena_mask_t;
-#endif
+typedef bits_t(ENABLE_COUNT) ena_mask_t;
 
 // Axis flags type, for enabled state or other simple state
 typedef struct {
   union {
     ena_mask_t bits;
     struct {
       bool NUM_AXIS_LIST(X:1, Y:1, Z:1, I:1, J:1, K:1, U:1, V:1, W:1);
       #if HAS_EXTRUDERS
         bool LIST_N(EXTRUDERS, E0:1, E1:1, E2:1, E3:1, E4:1, E5:1, E6:1, E7:1);
       #endif
@@ -351,21 +347,21 @@ constexpr ena_mask_t enable_overlap[] = {
       constexpr float max_step_rate = max_shaped_rate;
     #endif
   #endif
 
   #ifndef SHAPING_MIN_FREQ
     #define SHAPING_MIN_FREQ _MIN(0x7FFFFFFFL OPTARG(INPUT_SHAPING_X, SHAPING_FREQ_X) OPTARG(INPUT_SHAPING_Y, SHAPING_FREQ_Y))
   #endif
   constexpr uint16_t shaping_min_freq = SHAPING_MIN_FREQ,
                      shaping_echoes = max_step_rate / shaping_min_freq / 2 + 3;
 
-  typedef IF<ENABLED(__AVR__), uint16_t, uint32_t>::type shaping_time_t;
+  typedef hal_timer_t shaping_time_t;
   enum shaping_echo_t { ECHO_NONE = 0, ECHO_FWD = 1, ECHO_BWD = 2 };
   struct shaping_echo_axis_t {
     TERN_(INPUT_SHAPING_X, shaping_echo_t x:2);
     TERN_(INPUT_SHAPING_Y, shaping_echo_t y:2);
   };
 
   class ShapingQueue {
     private:
       static shaping_time_t       now;
       static shaping_time_t       times[shaping_echoes];

commit c1ced60db0f095b943010a3f3354a43a023bec04
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Fri Mar 3 20:37:10 2023 +0000

    üêõ Fix ISR_SHAPING_LOOP_CYCLES (#25335)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 0706451e90..dcb9babde7 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -213,21 +213,21 @@
   constexpr uint32_t _MIN_PULSE_LOW_NS = _MIN_PULSE_HIGH_NS;
 #else
   #error "Expected at least one of MINIMUM_STEPPER_PULSE or MAXIMUM_STEPPER_RATE to be defined"
 #endif
 
 // The loop takes the base time plus the time for all the bresenham logic for R pulses plus the time
 // between pulses for (R-1) pulses. But the user could be enforcing a minimum time so the loop time is:
 #define ISR_LOOP_CYCLES(R) ((ISR_LOOP_BASE_CYCLES + MIN_ISR_LOOP_CYCLES + MIN_STEPPER_PULSE_CYCLES) * (R - 1) + _MAX(MIN_ISR_LOOP_CYCLES, MIN_STEPPER_PULSE_CYCLES))
 
 // Model input shaping as an extra loop call
-#define ISR_SHAPING_LOOP_CYCLES(R) ((TERN0(HAS_SHAPING, ISR_LOOP_BASE_CYCLES) + TERN0(INPUT_SHAPING_X, ISR_X_STEPPER_CYCLES) + TERN0(INPUT_SHAPING_Y, ISR_Y_STEPPER_CYCLES)) * (R) + (MIN_ISR_LOOP_CYCLES) * (R - 1))
+#define ISR_SHAPING_LOOP_CYCLES(R) TERN0(HAS_SHAPING, (R) * ((ISR_LOOP_BASE_CYCLES) + TERN0(INPUT_SHAPING_X, ISR_X_STEPPER_CYCLES) + TERN0(INPUT_SHAPING_Y, ISR_Y_STEPPER_CYCLES)))
 
 // If linear advance is enabled, then it is handled separately
 #if ENABLED(LIN_ADVANCE)
 
   // Estimate the minimum LA loop time
   #if ENABLED(MIXING_EXTRUDER) // ToDo: ???
     // HELP ME: What is what?
     // Directions are set up for MIXING_STEPPERS - like before.
     // Finding the right stepper may last up to MIXING_STEPPERS loops in get_next_stepper().
     //   These loops are a bit faster than advancing a bresenham counter.

commit 5a8883b44f6a6fc7be43e0f50c5d7708d0e28c97
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Tue Feb 21 22:37:11 2023 +0000

    üêõ Fix AVR maths used by Stepper (#25338)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 3bbfeac9ca..0706451e90 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -107,25 +107,25 @@
   #define ISR_LOOP_BASE_CYCLES 4UL
 
   // And each stepper (start + stop pulse) takes in worst case
   #define ISR_STEPPER_CYCLES 100UL
 
 #else
   // Cycles to perform actions in START_TIMED_PULSE
   #define TIMER_READ_ADD_AND_STORE_CYCLES 13UL
 
   // The base ISR
-  #define ISR_BASE_CYCLES  1000UL
+  #define ISR_BASE_CYCLES  996UL
 
   // Linear advance base time is 32 cycles
   #if ENABLED(LIN_ADVANCE)
-    #define ISR_LA_BASE_CYCLES 32UL
+    #define ISR_LA_BASE_CYCLES 30UL
   #else
     #define ISR_LA_BASE_CYCLES 0UL
   #endif
 
   // S curve interpolation adds 160 cycles
   #if ENABLED(S_CURVE_ACCELERATION)
     #define ISR_S_CURVE_CYCLES 160UL
   #else
     #define ISR_S_CURVE_CYCLES 0UL
   #endif

commit cf02107e6a8f9a122f15b38ed6b699215ee7cf16
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed Jan 25 21:37:10 2023 -0600

    üîß Refine Input Shaping check (#25280)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index e86498e841..3bbfeac9ca 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -147,52 +147,53 @@
 
 // If linear advance is disabled, the loop also handles them
 #if DISABLED(LIN_ADVANCE) && ENABLED(MIXING_EXTRUDER)
   #define ISR_MIXING_STEPPER_CYCLES ((MIXING_STEPPERS) * (ISR_STEPPER_CYCLES))
 #else
   #define ISR_MIXING_STEPPER_CYCLES  0UL
 #endif
 
 // Add time for each stepper
 #if HAS_X_STEP
-  #define ISR_X_STEPPER_CYCLES  ISR_STEPPER_CYCLES
+  #define ISR_X_STEPPER_CYCLES ISR_STEPPER_CYCLES
 #endif
 #if HAS_Y_STEP
-  #define ISR_Y_STEPPER_CYCLES  ISR_STEPPER_CYCLES
+  #define ISR_Y_STEPPER_CYCLES ISR_STEPPER_CYCLES
 #endif
 #if HAS_Z_STEP
-  #define ISR_Z_STEPPER_CYCLES  ISR_STEPPER_CYCLES
+  #define ISR_Z_STEPPER_CYCLES ISR_STEPPER_CYCLES
 #endif
 #if HAS_I_STEP
-  #define ISR_I_STEPPER_CYCLES  ISR_STEPPER_CYCLES
+  #define ISR_I_STEPPER_CYCLES ISR_STEPPER_CYCLES
 #endif
 #if HAS_J_STEP
-  #define ISR_J_STEPPER_CYCLES  ISR_STEPPER_CYCLES
+  #define ISR_J_STEPPER_CYCLES ISR_STEPPER_CYCLES
 #endif
 #if HAS_K_STEP
-  #define ISR_K_STEPPER_CYCLES  ISR_STEPPER_CYCLES
+  #define ISR_K_STEPPER_CYCLES ISR_STEPPER_CYCLES
 #endif
 #if HAS_U_STEP
-  #define ISR_U_STEPPER_CYCLES  ISR_STEPPER_CYCLES
+  #define ISR_U_STEPPER_CYCLES ISR_STEPPER_CYCLES
 #endif
 #if HAS_V_STEP
-  #define ISR_V_STEPPER_CYCLES  ISR_STEPPER_CYCLES
+  #define ISR_V_STEPPER_CYCLES ISR_STEPPER_CYCLES
 #endif
 #if HAS_W_STEP
-  #define ISR_W_STEPPER_CYCLES  ISR_STEPPER_CYCLES
+  #define ISR_W_STEPPER_CYCLES ISR_STEPPER_CYCLES
 #endif
 #if HAS_EXTRUDERS
-  #define ISR_E_STEPPER_CYCLES  ISR_STEPPER_CYCLES    // E is always interpolated, even for mixing extruders
+  #define ISR_E_STEPPER_CYCLES ISR_STEPPER_CYCLES // E is always interpolated, even for mixing extruders
 #endif
 
 // And the total minimum loop time, not including the base
-#define MIN_ISR_LOOP_CYCLES (ISR_MIXING_STEPPER_CYCLES LOGICAL_AXIS_GANG(+ ISR_E_STEPPER_CYCLES, + ISR_X_STEPPER_CYCLES, + ISR_Y_STEPPER_CYCLES, + ISR_Z_STEPPER_CYCLES, + ISR_I_STEPPER_CYCLES, + ISR_J_STEPPER_CYCLES, + ISR_K_STEPPER_CYCLES, + ISR_U_STEPPER_CYCLES, + ISR_V_STEPPER_CYCLES, + ISR_W_STEPPER_CYCLES))
+#define _PLUS_AXIS_CYCLES(A) + (ISR_##A##_STEPPER_CYCLES)
+#define MIN_ISR_LOOP_CYCLES (ISR_MIXING_STEPPER_CYCLES LOGICAL_AXIS_MAP(_PLUS_AXIS_CYCLES))
 
 // Calculate the minimum MPU cycles needed per pulse to enforce, limited to the max stepper rate
 #define _MIN_STEPPER_PULSE_CYCLES(N) _MAX(uint32_t((F_CPU) / (MAXIMUM_STEPPER_RATE)), ((F_CPU) / 500000UL) * (N))
 #if MINIMUM_STEPPER_PULSE
   #define MIN_STEPPER_PULSE_CYCLES _MIN_STEPPER_PULSE_CYCLES(uint32_t(MINIMUM_STEPPER_PULSE))
 #elif HAS_DRIVER(LV8729)
   #define MIN_STEPPER_PULSE_CYCLES uint32_t((((F_CPU) - 1) / 2000000) + 1) // 0.5¬µs, aka 500ns
 #else
   #define MIN_STEPPER_PULSE_CYCLES _MIN_STEPPER_PULSE_CYCLES(1UL)
 #endif
@@ -795,23 +796,23 @@ class Stepper {
     // Update direction states for all steppers
     static void set_directions();
 
     // Set direction bits and update all stepper DIR states
     static void set_directions(const axis_bits_t bits) {
       last_direction_bits = bits;
       set_directions();
     }
 
     #if HAS_SHAPING
-      static void set_shaping_damping_ratio(const AxisEnum axis, const float zeta);
+      static void set_shaping_damping_ratio(const AxisEnum axis, const_float_t zeta);
       static float get_shaping_damping_ratio(const AxisEnum axis);
-      static void set_shaping_frequency(const AxisEnum axis, const float freq);
+      static void set_shaping_frequency(const AxisEnum axis, const_float_t freq);
       static float get_shaping_frequency(const AxisEnum axis);
     #endif
 
   private:
 
     // Set the current position in steps
     static void _set_position(const abce_long_t &spos);
 
     // Calculate timing interval for the given step rate
     static uint32_t calc_timer_interval(uint32_t step_rate);

commit 6d87dafc6e883ca5150210e27ce965394d3fc69f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Dec 12 16:46:50 2022 -0600

    ü©π Fix M502 init of default motion
    
    Fix regression from #25035

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index e92d478dc6..e86498e841 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -319,36 +319,35 @@ constexpr bool any_enable_overlap(const uint8_t a=0) {
 //       (e.g., CoreXY, Dual XYZ, or E with multiple steppers, etc.).
 constexpr ena_mask_t enable_overlap[] = {
   #define _OVERLAP(N) ena_overlap(INDEX_OF_AXIS(AxisEnum(N))),
   REPEAT(NUM_AXES, _OVERLAP)
   #if HAS_EXTRUDERS
     #define _E_OVERLAP(N) ena_overlap(INDEX_OF_AXIS(E_AXIS, N)),
     REPEAT(E_STEPPERS, _E_OVERLAP)
   #endif
 };
 
-constexpr float     _DASU[] = DEFAULT_AXIS_STEPS_PER_UNIT;
-constexpr feedRate_t _DMF[] = DEFAULT_MAX_FEEDRATE;
-
 //static_assert(!any_enable_overlap(), "There is some overlap.");
 
 #if HAS_SHAPING
 
   #ifdef SHAPING_MAX_STEPRATE
     constexpr float max_step_rate = SHAPING_MAX_STEPRATE;
   #else
-    constexpr float max_shaped_rate = TERN0(INPUT_SHAPING_X, _DMF[X_AXIS] * _DASU[X_AXIS]) +
-                                      TERN0(INPUT_SHAPING_Y, _DMF[Y_AXIS] * _DASU[Y_AXIS]);
+    constexpr float     _ISDASU[] = DEFAULT_AXIS_STEPS_PER_UNIT;
+    constexpr feedRate_t _ISDMF[] = DEFAULT_MAX_FEEDRATE;
+    constexpr float max_shaped_rate = TERN0(INPUT_SHAPING_X, _ISDMF[X_AXIS] * _ISDASU[X_AXIS]) +
+                                      TERN0(INPUT_SHAPING_Y, _ISDMF[Y_AXIS] * _ISDASU[Y_AXIS]);
     #if defined(__AVR__) || !defined(ADAPTIVE_STEP_SMOOTHING)
       // MIN_STEP_ISR_FREQUENCY is known at compile time on AVRs and any reduction in SRAM is welcome
       template<int INDEX=DISTINCT_AXES> constexpr float max_isr_rate() {
-        return _MAX(_DMF[INDEX - 1] * _DASU[INDEX - 1], max_isr_rate<INDEX - 1>());
+        return _MAX(_ISDMF[INDEX - 1] * _ISDASU[INDEX - 1], max_isr_rate<INDEX - 1>());
       }
       template<> constexpr float max_isr_rate<0>() {
         return TERN0(ADAPTIVE_STEP_SMOOTHING, MIN_STEP_ISR_FREQUENCY);
       }
       constexpr float max_step_rate = _MIN(max_isr_rate(), max_shaped_rate);
     #else
       constexpr float max_step_rate = max_shaped_rate;
     #endif
   #endif
 

commit b4fbe4ff5023c3dace1aead7aac84feb0b793131
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Sat Dec 10 17:28:48 2022 +0000

    ‚ö°Ô∏è Better IS buffer size calc (#25035)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 6d9814b4df..e92d478dc6 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -319,63 +319,57 @@ constexpr bool any_enable_overlap(const uint8_t a=0) {
 //       (e.g., CoreXY, Dual XYZ, or E with multiple steppers, etc.).
 constexpr ena_mask_t enable_overlap[] = {
   #define _OVERLAP(N) ena_overlap(INDEX_OF_AXIS(AxisEnum(N))),
   REPEAT(NUM_AXES, _OVERLAP)
   #if HAS_EXTRUDERS
     #define _E_OVERLAP(N) ena_overlap(INDEX_OF_AXIS(E_AXIS, N)),
     REPEAT(E_STEPPERS, _E_OVERLAP)
   #endif
 };
 
+constexpr float     _DASU[] = DEFAULT_AXIS_STEPS_PER_UNIT;
+constexpr feedRate_t _DMF[] = DEFAULT_MAX_FEEDRATE;
+
 //static_assert(!any_enable_overlap(), "There is some overlap.");
 
 #if HAS_SHAPING
 
-  // These constexpr are used to calculate the shaping queue buffer sizes
-  constexpr xyze_float_t max_feedrate = DEFAULT_MAX_FEEDRATE;
-  constexpr xyze_float_t steps_per_unit = DEFAULT_AXIS_STEPS_PER_UNIT;
-  // MIN_STEP_ISR_FREQUENCY is known at compile time on AVRs and any reduction in SRAM is welcome
-  #ifdef __AVR__
-    constexpr float max_isr_rate = _MAX(
-                                      LOGICAL_AXIS_LIST(
-                                        max_feedrate.e * steps_per_unit.e,
-                                        max_feedrate.x * steps_per_unit.x,
-                                        max_feedrate.y * steps_per_unit.y,
-                                        max_feedrate.z * steps_per_unit.z,
-                                        max_feedrate.i * steps_per_unit.i,
-                                        max_feedrate.j * steps_per_unit.j,
-                                        max_feedrate.k * steps_per_unit.k,
-                                        max_feedrate.u * steps_per_unit.u,
-                                        max_feedrate.v * steps_per_unit.v,
-                                        max_feedrate.w * steps_per_unit.w
-                                      )
-                                      OPTARG(ADAPTIVE_STEP_SMOOTHING, MIN_STEP_ISR_FREQUENCY)
-                                    );
-    constexpr float max_step_rate = _MIN(max_isr_rate,
-                                      TERN0(INPUT_SHAPING_X, max_feedrate.x * steps_per_unit.x) +
-                                      TERN0(INPUT_SHAPING_Y, max_feedrate.y * steps_per_unit.y)
-                                    );
+  #ifdef SHAPING_MAX_STEPRATE
+    constexpr float max_step_rate = SHAPING_MAX_STEPRATE;
   #else
-    constexpr float max_step_rate = TERN0(INPUT_SHAPING_X, max_feedrate.x * steps_per_unit.x) +
-                                    TERN0(INPUT_SHAPING_Y, max_feedrate.y * steps_per_unit.y);
+    constexpr float max_shaped_rate = TERN0(INPUT_SHAPING_X, _DMF[X_AXIS] * _DASU[X_AXIS]) +
+                                      TERN0(INPUT_SHAPING_Y, _DMF[Y_AXIS] * _DASU[Y_AXIS]);
+    #if defined(__AVR__) || !defined(ADAPTIVE_STEP_SMOOTHING)
+      // MIN_STEP_ISR_FREQUENCY is known at compile time on AVRs and any reduction in SRAM is welcome
+      template<int INDEX=DISTINCT_AXES> constexpr float max_isr_rate() {
+        return _MAX(_DMF[INDEX - 1] * _DASU[INDEX - 1], max_isr_rate<INDEX - 1>());
+      }
+      template<> constexpr float max_isr_rate<0>() {
+        return TERN0(ADAPTIVE_STEP_SMOOTHING, MIN_STEP_ISR_FREQUENCY);
+      }
+      constexpr float max_step_rate = _MIN(max_isr_rate(), max_shaped_rate);
+    #else
+      constexpr float max_step_rate = max_shaped_rate;
+    #endif
   #endif
-  constexpr uint16_t shaping_echoes = max_step_rate / _MIN(0x7FFFFFFFL OPTARG(INPUT_SHAPING_X, SHAPING_FREQ_X) OPTARG(INPUT_SHAPING_Y, SHAPING_FREQ_Y)) / 2 + 3;
+
+  #ifndef SHAPING_MIN_FREQ
+    #define SHAPING_MIN_FREQ _MIN(0x7FFFFFFFL OPTARG(INPUT_SHAPING_X, SHAPING_FREQ_X) OPTARG(INPUT_SHAPING_Y, SHAPING_FREQ_Y))
+  #endif
+  constexpr uint16_t shaping_min_freq = SHAPING_MIN_FREQ,
+                     shaping_echoes = max_step_rate / shaping_min_freq / 2 + 3;
 
   typedef IF<ENABLED(__AVR__), uint16_t, uint32_t>::type shaping_time_t;
   enum shaping_echo_t { ECHO_NONE = 0, ECHO_FWD = 1, ECHO_BWD = 2 };
   struct shaping_echo_axis_t {
-    #if ENABLED(INPUT_SHAPING_X)
-      shaping_echo_t x:2;
-    #endif
-    #if ENABLED(INPUT_SHAPING_Y)
-      shaping_echo_t y:2;
-    #endif
+    TERN_(INPUT_SHAPING_X, shaping_echo_t x:2);
+    TERN_(INPUT_SHAPING_Y, shaping_echo_t y:2);
   };
 
   class ShapingQueue {
     private:
       static shaping_time_t       now;
       static shaping_time_t       times[shaping_echoes];
       static shaping_echo_axis_t  echo_axes[shaping_echoes];
       static uint16_t             tail;
 
       #if ENABLED(INPUT_SHAPING_X)

commit f3108e87f1470e5d03df28f17b8cb9a8b6493ca7
Author: Chris Bagwell <chris@cnpbagwell.com>
Date:   Sun Nov 27 21:40:11 2022 -0600

    ‚ö°Ô∏è More SCURVE cycles on unoptimized cortex-m0 (#24955)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index f29bb346d1..6d9814b4df 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -80,21 +80,25 @@
 
   // Linear advance base time is 64 cycles
   #if ENABLED(LIN_ADVANCE)
     #define ISR_LA_BASE_CYCLES 64UL
   #else
     #define ISR_LA_BASE_CYCLES 0UL
   #endif
 
   // S curve interpolation adds 40 cycles
   #if ENABLED(S_CURVE_ACCELERATION)
-    #define ISR_S_CURVE_CYCLES 40UL
+    #ifdef STM32G0B1xx
+      #define ISR_S_CURVE_CYCLES 500UL
+    #else
+      #define ISR_S_CURVE_CYCLES 40UL
+    #endif
   #else
     #define ISR_S_CURVE_CYCLES 0UL
   #endif
 
   // Input shaping base time
   #if HAS_SHAPING
     #define ISR_SHAPING_BASE_CYCLES 180UL
   #else
     #define ISR_SHAPING_BASE_CYCLES 0UL
   #endif

commit 89334caa526f2d300eee834d34d06d8f837a57d5
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Mon Nov 28 03:38:15 2022 +0000

    ‚ö°Ô∏è Input Shaping improvements (#24951)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 5b634c52e4..f29bb346d1 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -68,73 +68,81 @@
   /**
    * Duration of START_TIMED_PULSE
    *
    * ...as measured on an LPC1768 with a scope and converted to cycles.
    * Not applicable to other 32-bit processors, but as long as others
    * take longer, pulses will be longer. For example the SKR Pro
    * (stm32f407zgt6) requires ~60 cyles.
    */
   #define TIMER_READ_ADD_AND_STORE_CYCLES 34UL
 
-  // The base ISR takes 792 cycles
-  #define ISR_BASE_CYCLES  792UL
+  // The base ISR
+  #define ISR_BASE_CYCLES 770UL
 
   // Linear advance base time is 64 cycles
   #if ENABLED(LIN_ADVANCE)
     #define ISR_LA_BASE_CYCLES 64UL
   #else
     #define ISR_LA_BASE_CYCLES 0UL
   #endif
 
   // S curve interpolation adds 40 cycles
   #if ENABLED(S_CURVE_ACCELERATION)
     #define ISR_S_CURVE_CYCLES 40UL
   #else
     #define ISR_S_CURVE_CYCLES 0UL
   #endif
 
+  // Input shaping base time
+  #if HAS_SHAPING
+    #define ISR_SHAPING_BASE_CYCLES 180UL
+  #else
+    #define ISR_SHAPING_BASE_CYCLES 0UL
+  #endif
+
   // Stepper Loop base cycles
   #define ISR_LOOP_BASE_CYCLES 4UL
 
-  // To start the step pulse, in the worst case takes
-  #define ISR_START_STEPPER_CYCLES 13UL
-
   // And each stepper (start + stop pulse) takes in worst case
-  #define ISR_STEPPER_CYCLES 16UL
+  #define ISR_STEPPER_CYCLES 100UL
 
 #else
   // Cycles to perform actions in START_TIMED_PULSE
   #define TIMER_READ_ADD_AND_STORE_CYCLES 13UL
 
-  // The base ISR takes 752 cycles
-  #define ISR_BASE_CYCLES  752UL
+  // The base ISR
+  #define ISR_BASE_CYCLES  1000UL
 
   // Linear advance base time is 32 cycles
   #if ENABLED(LIN_ADVANCE)
     #define ISR_LA_BASE_CYCLES 32UL
   #else
     #define ISR_LA_BASE_CYCLES 0UL
   #endif
 
   // S curve interpolation adds 160 cycles
   #if ENABLED(S_CURVE_ACCELERATION)
     #define ISR_S_CURVE_CYCLES 160UL
   #else
     #define ISR_S_CURVE_CYCLES 0UL
   #endif
 
+  // Input shaping base time
+  #if HAS_SHAPING
+    #define ISR_SHAPING_BASE_CYCLES 290UL
+  #else
+    #define ISR_SHAPING_BASE_CYCLES 0UL
+  #endif
+
   // Stepper Loop base cycles
   #define ISR_LOOP_BASE_CYCLES 32UL
 
-  // To start the step pulse, in the worst case takes
-  #define ISR_START_STEPPER_CYCLES 57UL
-
   // And each stepper (start + stop pulse) takes in worst case
   #define ISR_STEPPER_CYCLES 88UL
 
 #endif
 
 // If linear advance is disabled, the loop also handles them
 #if DISABLED(LIN_ADVANCE) && ENABLED(MIXING_EXTRUDER)
   #define ISR_MIXING_STEPPER_CYCLES ((MIXING_STEPPERS) * (ISR_STEPPER_CYCLES))
 #else
   #define ISR_MIXING_STEPPER_CYCLES  0UL
@@ -195,22 +203,26 @@
   constexpr uint32_t _MIN_PULSE_HIGH_NS = 1000UL * MINIMUM_STEPPER_PULSE;
   constexpr uint32_t _MIN_PULSE_LOW_NS = _MIN_PULSE_HIGH_NS;
 #elif MAXIMUM_STEPPER_RATE
   // Assume 50% duty cycle
   constexpr uint32_t _MIN_PULSE_HIGH_NS = 500000000UL / MAXIMUM_STEPPER_RATE;
   constexpr uint32_t _MIN_PULSE_LOW_NS = _MIN_PULSE_HIGH_NS;
 #else
   #error "Expected at least one of MINIMUM_STEPPER_PULSE or MAXIMUM_STEPPER_RATE to be defined"
 #endif
 
-// But the user could be enforcing a minimum time, so the loop time is
-#define ISR_LOOP_CYCLES (ISR_LOOP_BASE_CYCLES + _MAX(MIN_STEPPER_PULSE_CYCLES, MIN_ISR_LOOP_CYCLES))
+// The loop takes the base time plus the time for all the bresenham logic for R pulses plus the time
+// between pulses for (R-1) pulses. But the user could be enforcing a minimum time so the loop time is:
+#define ISR_LOOP_CYCLES(R) ((ISR_LOOP_BASE_CYCLES + MIN_ISR_LOOP_CYCLES + MIN_STEPPER_PULSE_CYCLES) * (R - 1) + _MAX(MIN_ISR_LOOP_CYCLES, MIN_STEPPER_PULSE_CYCLES))
+
+// Model input shaping as an extra loop call
+#define ISR_SHAPING_LOOP_CYCLES(R) ((TERN0(HAS_SHAPING, ISR_LOOP_BASE_CYCLES) + TERN0(INPUT_SHAPING_X, ISR_X_STEPPER_CYCLES) + TERN0(INPUT_SHAPING_Y, ISR_Y_STEPPER_CYCLES)) * (R) + (MIN_ISR_LOOP_CYCLES) * (R - 1))
 
 // If linear advance is enabled, then it is handled separately
 #if ENABLED(LIN_ADVANCE)
 
   // Estimate the minimum LA loop time
   #if ENABLED(MIXING_EXTRUDER) // ToDo: ???
     // HELP ME: What is what?
     // Directions are set up for MIXING_STEPPERS - like before.
     // Finding the right stepper may last up to MIXING_STEPPERS loops in get_next_stepper().
     //   These loops are a bit faster than advancing a bresenham counter.
@@ -221,21 +233,21 @@
   #endif
 
   // And the real loop time
   #define ISR_LA_LOOP_CYCLES _MAX(MIN_STEPPER_PULSE_CYCLES, MIN_ISR_LA_LOOP_CYCLES)
 
 #else
   #define ISR_LA_LOOP_CYCLES 0UL
 #endif
 
 // Now estimate the total ISR execution time in cycles given a step per ISR multiplier
-#define ISR_EXECUTION_CYCLES(R) (((ISR_BASE_CYCLES + ISR_S_CURVE_CYCLES + (ISR_LOOP_CYCLES) * (R) + ISR_LA_BASE_CYCLES + ISR_LA_LOOP_CYCLES)) / (R))
+#define ISR_EXECUTION_CYCLES(R) (((ISR_BASE_CYCLES + ISR_S_CURVE_CYCLES + ISR_SHAPING_BASE_CYCLES + ISR_LOOP_CYCLES(R) + ISR_SHAPING_LOOP_CYCLES(R) + ISR_LA_BASE_CYCLES + ISR_LA_LOOP_CYCLES)) / (R))
 
 // The maximum allowable stepping frequency when doing x128-x1 stepping (in Hz)
 #define MAX_STEP_ISR_FREQUENCY_128X ((F_CPU) / ISR_EXECUTION_CYCLES(128))
 #define MAX_STEP_ISR_FREQUENCY_64X  ((F_CPU) / ISR_EXECUTION_CYCLES(64))
 #define MAX_STEP_ISR_FREQUENCY_32X  ((F_CPU) / ISR_EXECUTION_CYCLES(32))
 #define MAX_STEP_ISR_FREQUENCY_16X  ((F_CPU) / ISR_EXECUTION_CYCLES(16))
 #define MAX_STEP_ISR_FREQUENCY_8X   ((F_CPU) / ISR_EXECUTION_CYCLES(8))
 #define MAX_STEP_ISR_FREQUENCY_4X   ((F_CPU) / ISR_EXECUTION_CYCLES(4))
 #define MAX_STEP_ISR_FREQUENCY_2X   ((F_CPU) / ISR_EXECUTION_CYCLES(2))
 #define MAX_STEP_ISR_FREQUENCY_1X   ((F_CPU) / ISR_EXECUTION_CYCLES(1))
@@ -305,130 +317,156 @@ constexpr ena_mask_t enable_overlap[] = {
   #define _OVERLAP(N) ena_overlap(INDEX_OF_AXIS(AxisEnum(N))),
   REPEAT(NUM_AXES, _OVERLAP)
   #if HAS_EXTRUDERS
     #define _E_OVERLAP(N) ena_overlap(INDEX_OF_AXIS(E_AXIS, N)),
     REPEAT(E_STEPPERS, _E_OVERLAP)
   #endif
 };
 
 //static_assert(!any_enable_overlap(), "There is some overlap.");
 
-#if ENABLED(INPUT_SHAPING)
-
-  typedef IF<ENABLED(__AVR__), uint16_t, uint32_t>::type shaping_time_t;
+#if HAS_SHAPING
 
   // These constexpr are used to calculate the shaping queue buffer sizes
   constexpr xyze_float_t max_feedrate = DEFAULT_MAX_FEEDRATE;
   constexpr xyze_float_t steps_per_unit = DEFAULT_AXIS_STEPS_PER_UNIT;
-  constexpr float max_steprate = _MAX(LOGICAL_AXIS_LIST(
-                                      max_feedrate.e * steps_per_unit.e,
-                                      max_feedrate.x * steps_per_unit.x,
-                                      max_feedrate.y * steps_per_unit.y,
-                                      max_feedrate.z * steps_per_unit.z,
-                                      max_feedrate.i * steps_per_unit.i,
-                                      max_feedrate.j * steps_per_unit.j,
-                                      max_feedrate.k * steps_per_unit.k,
-                                      max_feedrate.u * steps_per_unit.u,
-                                      max_feedrate.v * steps_per_unit.v,
-                                      max_feedrate.w * steps_per_unit.w
-                                    ));
-  constexpr uint16_t shaping_dividends = max_steprate / _MIN(0x7FFFFFFFL OPTARG(HAS_SHAPING_X, SHAPING_FREQ_X) OPTARG(HAS_SHAPING_Y, SHAPING_FREQ_Y)) / 2 + 3;
-  constexpr uint16_t shaping_segments = max_steprate / (MIN_STEPS_PER_SEGMENT) / _MIN(0x7FFFFFFFL OPTARG(HAS_SHAPING_X, SHAPING_FREQ_X) OPTARG(HAS_SHAPING_Y, SHAPING_FREQ_Y)) / 2 + 3;
-
-  class DelayTimeManager {
-    private:
-      static shaping_time_t now;
-      #ifdef HAS_SHAPING_X
-        static shaping_time_t delay_x;
-      #endif
-      #ifdef HAS_SHAPING_Y
-        static shaping_time_t delay_y;
-      #endif
-    public:
-      static void decrement_delays(const shaping_time_t interval) { now += interval; }
-      static void set_delay(const AxisEnum axis, const shaping_time_t delay) {
-        TERN_(HAS_SHAPING_X, if (axis == X_AXIS) delay_x = delay);
-        TERN_(HAS_SHAPING_Y, if (axis == Y_AXIS) delay_y = delay);
-      }
-  };
-
-  template<int SIZE>
-  class DelayQueue : public DelayTimeManager {
-    protected:
-      shaping_time_t times[SIZE];
-      uint16_t tail = 0 OPTARG(HAS_SHAPING_X, head_x = 0) OPTARG(HAS_SHAPING_Y, head_y = 0);
+  // MIN_STEP_ISR_FREQUENCY is known at compile time on AVRs and any reduction in SRAM is welcome
+  #ifdef __AVR__
+    constexpr float max_isr_rate = _MAX(
+                                      LOGICAL_AXIS_LIST(
+                                        max_feedrate.e * steps_per_unit.e,
+                                        max_feedrate.x * steps_per_unit.x,
+                                        max_feedrate.y * steps_per_unit.y,
+                                        max_feedrate.z * steps_per_unit.z,
+                                        max_feedrate.i * steps_per_unit.i,
+                                        max_feedrate.j * steps_per_unit.j,
+                                        max_feedrate.k * steps_per_unit.k,
+                                        max_feedrate.u * steps_per_unit.u,
+                                        max_feedrate.v * steps_per_unit.v,
+                                        max_feedrate.w * steps_per_unit.w
+                                      )
+                                      OPTARG(ADAPTIVE_STEP_SMOOTHING, MIN_STEP_ISR_FREQUENCY)
+                                    );
+    constexpr float max_step_rate = _MIN(max_isr_rate,
+                                      TERN0(INPUT_SHAPING_X, max_feedrate.x * steps_per_unit.x) +
+                                      TERN0(INPUT_SHAPING_Y, max_feedrate.y * steps_per_unit.y)
+                                    );
+  #else
+    constexpr float max_step_rate = TERN0(INPUT_SHAPING_X, max_feedrate.x * steps_per_unit.x) +
+                                    TERN0(INPUT_SHAPING_Y, max_feedrate.y * steps_per_unit.y);
+  #endif
+  constexpr uint16_t shaping_echoes = max_step_rate / _MIN(0x7FFFFFFFL OPTARG(INPUT_SHAPING_X, SHAPING_FREQ_X) OPTARG(INPUT_SHAPING_Y, SHAPING_FREQ_Y)) / 2 + 3;
 
-    public:
-      void enqueue() {
-        times[tail] = now;
-        if (++tail == SIZE) tail = 0;
-      }
-      #ifdef HAS_SHAPING_X
-        shaping_time_t peek_x() {
-          if (head_x != tail) return times[head_x] + delay_x - now;
-          else return shaping_time_t(-1);
-        }
-        void dequeue_x() { if (++head_x == SIZE) head_x = 0; }
-        bool empty_x() { return head_x == tail; }
-        uint16_t free_count_x() { return head_x > tail ? head_x - tail - 1 : head_x + SIZE - tail - 1; }
-      #endif
-      #ifdef HAS_SHAPING_Y
-        shaping_time_t peek_y() {
-          if (head_y != tail) return times[head_y] + delay_y - now;
-          else return shaping_time_t(-1);
-        }
-        void dequeue_y() { if (++head_y == SIZE) head_y = 0; }
-        bool empty_y() { return head_y == tail; }
-        uint16_t free_count_y() { return head_y > tail ? head_y - tail - 1 : head_y + SIZE - tail - 1; }
-      #endif
-      void purge() { auto temp = TERN_(HAS_SHAPING_X, head_x) = TERN_(HAS_SHAPING_Y, head_y) = tail; UNUSED(temp);}
+  typedef IF<ENABLED(__AVR__), uint16_t, uint32_t>::type shaping_time_t;
+  enum shaping_echo_t { ECHO_NONE = 0, ECHO_FWD = 1, ECHO_BWD = 2 };
+  struct shaping_echo_axis_t {
+    #if ENABLED(INPUT_SHAPING_X)
+      shaping_echo_t x:2;
+    #endif
+    #if ENABLED(INPUT_SHAPING_Y)
+      shaping_echo_t y:2;
+    #endif
   };
 
-  class ParamDelayQueue : public DelayQueue<shaping_segments> {
+  class ShapingQueue {
     private:
-      #ifdef HAS_SHAPING_X
-        int32_t params_x[shaping_segments];
+      static shaping_time_t       now;
+      static shaping_time_t       times[shaping_echoes];
+      static shaping_echo_axis_t  echo_axes[shaping_echoes];
+      static uint16_t             tail;
+
+      #if ENABLED(INPUT_SHAPING_X)
+        static shaping_time_t delay_x;    // = shaping_time_t(-1) to disable queueing
+        static shaping_time_t peek_x_val;
+        static uint16_t head_x;
+        static uint16_t _free_count_x;
       #endif
-      #ifdef HAS_SHAPING_Y
-        int32_t params_y[shaping_segments];
+      #if ENABLED(INPUT_SHAPING_Y)
+        static shaping_time_t delay_y;    // = shaping_time_t(-1) to disable queueing
+        static shaping_time_t peek_y_val;
+        static uint16_t head_y;
+        static uint16_t _free_count_y;
       #endif
 
     public:
-      void enqueue(const int32_t param_x, const int32_t param_y) {
-        TERN(HAS_SHAPING_X, params_x[DelayQueue<shaping_segments>::tail] = param_x, UNUSED(param_x));
-        TERN(HAS_SHAPING_Y, params_y[DelayQueue<shaping_segments>::tail] = param_y, UNUSED(param_y));
-        DelayQueue<shaping_segments>::enqueue();
+      static void decrement_delays(const shaping_time_t interval) {
+        now += interval;
+        TERN_(INPUT_SHAPING_X, if (peek_x_val != shaping_time_t(-1)) peek_x_val -= interval);
+        TERN_(INPUT_SHAPING_Y, if (peek_y_val != shaping_time_t(-1)) peek_y_val -= interval);
+      }
+      static void set_delay(const AxisEnum axis, const shaping_time_t delay) {
+        TERN_(INPUT_SHAPING_X, if (axis == X_AXIS) delay_x = delay);
+        TERN_(INPUT_SHAPING_Y, if (axis == Y_AXIS) delay_y = delay);
       }
-      #ifdef HAS_SHAPING_X
-        const int32_t dequeue_x() {
-          const int32_t result = params_x[DelayQueue<shaping_segments>::head_x];
-          DelayQueue<shaping_segments>::dequeue_x();
-          return result;
+      static void enqueue(const bool x_step, const bool x_forward, const bool y_step, const bool y_forward) {
+        TERN_(INPUT_SHAPING_X, if (head_x == tail && x_step) peek_x_val = delay_x);
+        TERN_(INPUT_SHAPING_Y, if (head_y == tail && y_step) peek_y_val = delay_y);
+        times[tail] = now;
+        TERN_(INPUT_SHAPING_X, echo_axes[tail].x = x_step ? (x_forward ? ECHO_FWD : ECHO_BWD) : ECHO_NONE);
+        TERN_(INPUT_SHAPING_Y, echo_axes[tail].y = y_step ? (y_forward ? ECHO_FWD : ECHO_BWD) : ECHO_NONE);
+        if (++tail == shaping_echoes) tail = 0;
+        TERN_(INPUT_SHAPING_X, _free_count_x--);
+        TERN_(INPUT_SHAPING_Y, _free_count_y--);
+        TERN_(INPUT_SHAPING_X, if (echo_axes[head_x].x == ECHO_NONE) dequeue_x());
+        TERN_(INPUT_SHAPING_Y, if (echo_axes[head_y].y == ECHO_NONE) dequeue_y());
+      }
+      #if ENABLED(INPUT_SHAPING_X)
+        static shaping_time_t peek_x() { return peek_x_val; }
+        static bool dequeue_x() {
+          bool forward = echo_axes[head_x].x == ECHO_FWD;
+          do {
+            _free_count_x++;
+            if (++head_x == shaping_echoes) head_x = 0;
+          } while (head_x != tail && echo_axes[head_x].x == ECHO_NONE);
+          peek_x_val = head_x == tail ? shaping_time_t(-1) : times[head_x] + delay_x - now;
+          return forward;
         }
+        static bool empty_x() { return head_x == tail; }
+        static uint16_t free_count_x() { return _free_count_x; }
       #endif
-      #ifdef HAS_SHAPING_Y
-        const int32_t dequeue_y() {
-          const int32_t result = params_y[DelayQueue<shaping_segments>::head_y];
-          DelayQueue<shaping_segments>::dequeue_y();
-          return result;
+      #if ENABLED(INPUT_SHAPING_Y)
+        static shaping_time_t peek_y() { return peek_y_val; }
+        static bool dequeue_y() {
+          bool forward = echo_axes[head_y].y == ECHO_FWD;
+          do {
+            _free_count_y++;
+            if (++head_y == shaping_echoes) head_y = 0;
+          } while (head_y != tail && echo_axes[head_y].y == ECHO_NONE);
+          peek_y_val = head_y == tail ? shaping_time_t(-1) : times[head_y] + delay_y - now;
+          return forward;
         }
+        static bool empty_y() { return head_y == tail; }
+        static uint16_t free_count_y() { return _free_count_y; }
       #endif
+      static void purge() {
+        const auto st = shaping_time_t(-1);
+        #if ENABLED(INPUT_SHAPING_X)
+          head_x = tail; _free_count_x = shaping_echoes - 1; peek_x_val = st;
+        #endif
+        #if ENABLED(INPUT_SHAPING_Y)
+          head_y = tail; _free_count_y = shaping_echoes - 1; peek_y_val = st;
+        #endif
+      }
   };
 
   struct ShapeParams {
     float frequency;
     float zeta;
-    uint8_t factor;
-    int32_t dividend;
+    bool enabled;
+    int16_t delta_error = 0;    // delta_error for seconday bresenham mod 128
+    uint8_t factor1;
+    uint8_t factor2;
+    bool forward;
+    int32_t last_block_end_pos = 0;
   };
 
-#endif // INPUT_SHAPING
+#endif // HAS_SHAPING
 
 //
 // Stepper class definition
 //
 class Stepper {
   friend class KinematicSystem;
   friend class DeltaKinematicSystem;
   friend void stepperTask(void *);
 
   public:
@@ -520,27 +558,25 @@ class Stepper {
                      bezier_B,     // B coefficient in B√©zier speed curve
                      bezier_C;     // C coefficient in B√©zier speed curve
       static uint32_t bezier_F,    // F coefficient in B√©zier speed curve
                       bezier_AV;   // AV coefficient in B√©zier speed curve
       #ifdef __AVR__
         static bool A_negative;    // If A coefficient was negative
       #endif
       static bool bezier_2nd_half; // If B√©zier curve has been initialized or not
     #endif
 
-    #if ENABLED(INPUT_SHAPING)
-      static ParamDelayQueue shaping_dividend_queue;
-      static DelayQueue<shaping_dividends> shaping_queue;
-      #if HAS_SHAPING_X
+    #if HAS_SHAPING
+      #if ENABLED(INPUT_SHAPING_X)
         static ShapeParams shaping_x;
       #endif
-      #if HAS_SHAPING_Y
+      #if ENABLED(INPUT_SHAPING_Y)
         static ShapeParams shaping_y;
       #endif
     #endif
 
     #if ENABLED(LIN_ADVANCE)
       static constexpr uint32_t LA_ADV_NEVER = 0xFFFFFFFF;
       static uint32_t nextAdvanceISR,
                       la_interval;      // Interval between ISR calls for LA
       static int32_t  la_delta_error,   // Analogue of delta_error.e for E steps in LA ISR
                       la_dividend,      // Analogue of advance_dividend.e for E steps in LA ISR
@@ -590,21 +626,21 @@ class Stepper {
 
     // The ISR scheduler
     static void isr();
 
     // The stepper pulse ISR phase
     static void pulse_phase_isr();
 
     // The stepper block processing ISR phase
     static uint32_t block_phase_isr();
 
-    #if ENABLED(INPUT_SHAPING)
+    #if HAS_SHAPING
       static void shaping_isr();
     #endif
 
     #if ENABLED(LIN_ADVANCE)
       // The Linear advance ISR phase
       static void advance_isr();
     #endif
 
     #if ENABLED(INTEGRATED_BABYSTEPPING)
       // The Babystepping ISR phase
@@ -613,20 +649,34 @@ class Stepper {
         if (nextBabystepISR == BABYSTEP_NEVER) {
           nextBabystepISR = 0;
           wake_up();
         }
       }
     #endif
 
     // Check if the given block is busy or not - Must not be called from ISR contexts
     static bool is_block_busy(const block_t * const block);
 
+    #if HAS_SHAPING
+      // Check whether the stepper is processing any input shaping echoes
+      static bool input_shaping_busy() {
+        const bool was_on = hal.isr_state();
+        hal.isr_off();
+
+        const bool result = TERN0(INPUT_SHAPING_X, !ShapingQueue::empty_x()) || TERN0(INPUT_SHAPING_Y, !ShapingQueue::empty_y());
+
+        if (was_on) hal.isr_on();
+
+        return result;
+      }
+    #endif
+
     // Get the position of a stepper, in steps
     static int32_t position(const AxisEnum axis);
 
     // Set the current position in steps
     static void set_position(const xyze_long_t &spos);
     static void set_axis_position(const AxisEnum a, const int32_t &v);
 
     // Report the positions of the steppers, in steps
     static void report_a_position(const xyz_long_t &pos);
     static void report_positions();
@@ -747,21 +797,21 @@ class Stepper {
 
     // Update direction states for all steppers
     static void set_directions();
 
     // Set direction bits and update all stepper DIR states
     static void set_directions(const axis_bits_t bits) {
       last_direction_bits = bits;
       set_directions();
     }
 
-    #if ENABLED(INPUT_SHAPING)
+    #if HAS_SHAPING
       static void set_shaping_damping_ratio(const AxisEnum axis, const float zeta);
       static float get_shaping_damping_ratio(const AxisEnum axis);
       static void set_shaping_frequency(const AxisEnum axis, const float freq);
       static float get_shaping_frequency(const AxisEnum axis);
     #endif
 
   private:
 
     // Set the current position in steps
     static void _set_position(const abce_long_t &spos);

commit a460b01c876ff39901fe55a4b66b2c62737ef46c
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Fri Oct 21 22:34:22 2022 +0100

    üöÄ ZV Input Shaping (#24797)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 729ab83266..5b634c52e4 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -305,20 +305,131 @@ constexpr ena_mask_t enable_overlap[] = {
   #define _OVERLAP(N) ena_overlap(INDEX_OF_AXIS(AxisEnum(N))),
   REPEAT(NUM_AXES, _OVERLAP)
   #if HAS_EXTRUDERS
     #define _E_OVERLAP(N) ena_overlap(INDEX_OF_AXIS(E_AXIS, N)),
     REPEAT(E_STEPPERS, _E_OVERLAP)
   #endif
 };
 
 //static_assert(!any_enable_overlap(), "There is some overlap.");
 
+#if ENABLED(INPUT_SHAPING)
+
+  typedef IF<ENABLED(__AVR__), uint16_t, uint32_t>::type shaping_time_t;
+
+  // These constexpr are used to calculate the shaping queue buffer sizes
+  constexpr xyze_float_t max_feedrate = DEFAULT_MAX_FEEDRATE;
+  constexpr xyze_float_t steps_per_unit = DEFAULT_AXIS_STEPS_PER_UNIT;
+  constexpr float max_steprate = _MAX(LOGICAL_AXIS_LIST(
+                                      max_feedrate.e * steps_per_unit.e,
+                                      max_feedrate.x * steps_per_unit.x,
+                                      max_feedrate.y * steps_per_unit.y,
+                                      max_feedrate.z * steps_per_unit.z,
+                                      max_feedrate.i * steps_per_unit.i,
+                                      max_feedrate.j * steps_per_unit.j,
+                                      max_feedrate.k * steps_per_unit.k,
+                                      max_feedrate.u * steps_per_unit.u,
+                                      max_feedrate.v * steps_per_unit.v,
+                                      max_feedrate.w * steps_per_unit.w
+                                    ));
+  constexpr uint16_t shaping_dividends = max_steprate / _MIN(0x7FFFFFFFL OPTARG(HAS_SHAPING_X, SHAPING_FREQ_X) OPTARG(HAS_SHAPING_Y, SHAPING_FREQ_Y)) / 2 + 3;
+  constexpr uint16_t shaping_segments = max_steprate / (MIN_STEPS_PER_SEGMENT) / _MIN(0x7FFFFFFFL OPTARG(HAS_SHAPING_X, SHAPING_FREQ_X) OPTARG(HAS_SHAPING_Y, SHAPING_FREQ_Y)) / 2 + 3;
+
+  class DelayTimeManager {
+    private:
+      static shaping_time_t now;
+      #ifdef HAS_SHAPING_X
+        static shaping_time_t delay_x;
+      #endif
+      #ifdef HAS_SHAPING_Y
+        static shaping_time_t delay_y;
+      #endif
+    public:
+      static void decrement_delays(const shaping_time_t interval) { now += interval; }
+      static void set_delay(const AxisEnum axis, const shaping_time_t delay) {
+        TERN_(HAS_SHAPING_X, if (axis == X_AXIS) delay_x = delay);
+        TERN_(HAS_SHAPING_Y, if (axis == Y_AXIS) delay_y = delay);
+      }
+  };
+
+  template<int SIZE>
+  class DelayQueue : public DelayTimeManager {
+    protected:
+      shaping_time_t times[SIZE];
+      uint16_t tail = 0 OPTARG(HAS_SHAPING_X, head_x = 0) OPTARG(HAS_SHAPING_Y, head_y = 0);
+
+    public:
+      void enqueue() {
+        times[tail] = now;
+        if (++tail == SIZE) tail = 0;
+      }
+      #ifdef HAS_SHAPING_X
+        shaping_time_t peek_x() {
+          if (head_x != tail) return times[head_x] + delay_x - now;
+          else return shaping_time_t(-1);
+        }
+        void dequeue_x() { if (++head_x == SIZE) head_x = 0; }
+        bool empty_x() { return head_x == tail; }
+        uint16_t free_count_x() { return head_x > tail ? head_x - tail - 1 : head_x + SIZE - tail - 1; }
+      #endif
+      #ifdef HAS_SHAPING_Y
+        shaping_time_t peek_y() {
+          if (head_y != tail) return times[head_y] + delay_y - now;
+          else return shaping_time_t(-1);
+        }
+        void dequeue_y() { if (++head_y == SIZE) head_y = 0; }
+        bool empty_y() { return head_y == tail; }
+        uint16_t free_count_y() { return head_y > tail ? head_y - tail - 1 : head_y + SIZE - tail - 1; }
+      #endif
+      void purge() { auto temp = TERN_(HAS_SHAPING_X, head_x) = TERN_(HAS_SHAPING_Y, head_y) = tail; UNUSED(temp);}
+  };
+
+  class ParamDelayQueue : public DelayQueue<shaping_segments> {
+    private:
+      #ifdef HAS_SHAPING_X
+        int32_t params_x[shaping_segments];
+      #endif
+      #ifdef HAS_SHAPING_Y
+        int32_t params_y[shaping_segments];
+      #endif
+
+    public:
+      void enqueue(const int32_t param_x, const int32_t param_y) {
+        TERN(HAS_SHAPING_X, params_x[DelayQueue<shaping_segments>::tail] = param_x, UNUSED(param_x));
+        TERN(HAS_SHAPING_Y, params_y[DelayQueue<shaping_segments>::tail] = param_y, UNUSED(param_y));
+        DelayQueue<shaping_segments>::enqueue();
+      }
+      #ifdef HAS_SHAPING_X
+        const int32_t dequeue_x() {
+          const int32_t result = params_x[DelayQueue<shaping_segments>::head_x];
+          DelayQueue<shaping_segments>::dequeue_x();
+          return result;
+        }
+      #endif
+      #ifdef HAS_SHAPING_Y
+        const int32_t dequeue_y() {
+          const int32_t result = params_y[DelayQueue<shaping_segments>::head_y];
+          DelayQueue<shaping_segments>::dequeue_y();
+          return result;
+        }
+      #endif
+  };
+
+  struct ShapeParams {
+    float frequency;
+    float zeta;
+    uint8_t factor;
+    int32_t dividend;
+  };
+
+#endif // INPUT_SHAPING
+
 //
 // Stepper class definition
 //
 class Stepper {
   friend class KinematicSystem;
   friend class DeltaKinematicSystem;
   friend void stepperTask(void *);
 
   public:
 
@@ -384,21 +495,21 @@ class Stepper {
     static uint8_t steps_per_isr;         // Count of steps to perform per Stepper ISR call
 
     #if ENABLED(ADAPTIVE_STEP_SMOOTHING)
       static uint8_t oversampling_factor; // Oversampling factor (log2(multiplier)) to increase temporal resolution of axis
     #else
       static constexpr uint8_t oversampling_factor = 0;
     #endif
 
     // Delta error variables for the Bresenham line tracer
     static xyze_long_t delta_error;
-    static xyze_ulong_t advance_dividend;
+    static xyze_long_t advance_dividend;
     static uint32_t advance_divisor,
                     step_events_completed,  // The number of step events executed in the current block
                     accelerate_until,       // The point from where we need to stop acceleration
                     decelerate_after,       // The point from where we need to start decelerating
                     step_event_count;       // The total event count for the current block
 
     #if EITHER(HAS_MULTI_EXTRUDER, MIXING_EXTRUDER)
       static uint8_t stepper_extruder;
     #else
       static constexpr uint8_t stepper_extruder = 0;
@@ -409,20 +520,31 @@ class Stepper {
                      bezier_B,     // B coefficient in B√©zier speed curve
                      bezier_C;     // C coefficient in B√©zier speed curve
       static uint32_t bezier_F,    // F coefficient in B√©zier speed curve
                       bezier_AV;   // AV coefficient in B√©zier speed curve
       #ifdef __AVR__
         static bool A_negative;    // If A coefficient was negative
       #endif
       static bool bezier_2nd_half; // If B√©zier curve has been initialized or not
     #endif
 
+    #if ENABLED(INPUT_SHAPING)
+      static ParamDelayQueue shaping_dividend_queue;
+      static DelayQueue<shaping_dividends> shaping_queue;
+      #if HAS_SHAPING_X
+        static ShapeParams shaping_x;
+      #endif
+      #if HAS_SHAPING_Y
+        static ShapeParams shaping_y;
+      #endif
+    #endif
+
     #if ENABLED(LIN_ADVANCE)
       static constexpr uint32_t LA_ADV_NEVER = 0xFFFFFFFF;
       static uint32_t nextAdvanceISR,
                       la_interval;      // Interval between ISR calls for LA
       static int32_t  la_delta_error,   // Analogue of delta_error.e for E steps in LA ISR
                       la_dividend,      // Analogue of advance_dividend.e for E steps in LA ISR
                       la_advance_steps; // Count of steps added to increase nozzle pressure
     #endif
 
     #if ENABLED(INTEGRATED_BABYSTEPPING)
@@ -468,20 +590,24 @@ class Stepper {
 
     // The ISR scheduler
     static void isr();
 
     // The stepper pulse ISR phase
     static void pulse_phase_isr();
 
     // The stepper block processing ISR phase
     static uint32_t block_phase_isr();
 
+    #if ENABLED(INPUT_SHAPING)
+      static void shaping_isr();
+    #endif
+
     #if ENABLED(LIN_ADVANCE)
       // The Linear advance ISR phase
       static void advance_isr();
     #endif
 
     #if ENABLED(INTEGRATED_BABYSTEPPING)
       // The Babystepping ISR phase
       static uint32_t babystepping_isr();
       FORCE_INLINE static void initiateBabystepping() {
         if (nextBabystepISR == BABYSTEP_NEVER) {
@@ -621,20 +747,27 @@ class Stepper {
 
     // Update direction states for all steppers
     static void set_directions();
 
     // Set direction bits and update all stepper DIR states
     static void set_directions(const axis_bits_t bits) {
       last_direction_bits = bits;
       set_directions();
     }
 
+    #if ENABLED(INPUT_SHAPING)
+      static void set_shaping_damping_ratio(const AxisEnum axis, const float zeta);
+      static float get_shaping_damping_ratio(const AxisEnum axis);
+      static void set_shaping_frequency(const AxisEnum axis, const float freq);
+      static float get_shaping_frequency(const AxisEnum axis);
+    #endif
+
   private:
 
     // Set the current position in steps
     static void _set_position(const abce_long_t &spos);
 
     // Calculate timing interval for the given step rate
     static uint32_t calc_timer_interval(uint32_t step_rate);
     static uint32_t calc_timer_interval(uint32_t step_rate, uint8_t &loops);
 
     #if ENABLED(S_CURVE_ACCELERATION)

commit 8e71f7add45782f17ce485c6a2bd9004edac156c
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Fri Sep 2 03:04:46 2022 +0100

    ‚ú® Permit Linear Advance with I2S Streaming (#24684)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index ccf342b573..729ab83266 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -311,20 +311,21 @@ constexpr ena_mask_t enable_overlap[] = {
 };
 
 //static_assert(!any_enable_overlap(), "There is some overlap.");
 
 //
 // Stepper class definition
 //
 class Stepper {
   friend class KinematicSystem;
   friend class DeltaKinematicSystem;
+  friend void stepperTask(void *);
 
   public:
 
     #if EITHER(HAS_EXTRA_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
       static bool separate_multi_axis;
     #endif
 
     #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
       #if HAS_MOTOR_CURRENT_PWM
         #ifndef PWM_MOTOR_CURRENT

commit 232a104a927988c63f8c0c53a8c2e26005166e2d
Author: tombrazier <68918209+tombrazier@users.noreply.github.com>
Date:   Sun Jul 31 03:39:48 2022 +0100

    Fix, improve Linear Advance (#24533)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index d8fb5af229..ccf342b573 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -410,24 +410,25 @@ class Stepper {
       static uint32_t bezier_F,    // F coefficient in B√©zier speed curve
                       bezier_AV;   // AV coefficient in B√©zier speed curve
       #ifdef __AVR__
         static bool A_negative;    // If A coefficient was negative
       #endif
       static bool bezier_2nd_half; // If B√©zier curve has been initialized or not
     #endif
 
     #if ENABLED(LIN_ADVANCE)
       static constexpr uint32_t LA_ADV_NEVER = 0xFFFFFFFF;
-      static uint32_t nextAdvanceISR, LA_isr_rate;
-      static uint16_t LA_current_adv_steps, LA_final_adv_steps, LA_max_adv_steps; // Copy from current executed block. Needed because current_block is set to NULL "too early".
-      static int8_t LA_steps;
-      static bool LA_use_advance_lead;
+      static uint32_t nextAdvanceISR,
+                      la_interval;      // Interval between ISR calls for LA
+      static int32_t  la_delta_error,   // Analogue of delta_error.e for E steps in LA ISR
+                      la_dividend,      // Analogue of advance_dividend.e for E steps in LA ISR
+                      la_advance_steps; // Count of steps added to increase nozzle pressure
     #endif
 
     #if ENABLED(INTEGRATED_BABYSTEPPING)
       static constexpr uint32_t BABYSTEP_NEVER = 0xFFFFFFFF;
       static uint32_t nextBabystepISR;
     #endif
 
     #if ENABLED(DIRECT_STEPPING)
       static page_step_state_t page_step_state;
     #endif
@@ -468,22 +469,21 @@ class Stepper {
     static void isr();
 
     // The stepper pulse ISR phase
     static void pulse_phase_isr();
 
     // The stepper block processing ISR phase
     static uint32_t block_phase_isr();
 
     #if ENABLED(LIN_ADVANCE)
       // The Linear advance ISR phase
-      static uint32_t advance_isr();
-      FORCE_INLINE static void initiateLA() { nextAdvanceISR = 0; }
+      static void advance_isr();
     #endif
 
     #if ENABLED(INTEGRATED_BABYSTEPPING)
       // The Babystepping ISR phase
       static uint32_t babystepping_isr();
       FORCE_INLINE static void initiateBabystepping() {
         if (nextBabystepISR == BABYSTEP_NEVER) {
           nextBabystepISR = 0;
           wake_up();
         }
@@ -505,20 +505,21 @@ class Stepper {
     static void report_positions();
 
     // Discard current block and free any resources
     FORCE_INLINE static void discard_current_block() {
       #if ENABLED(DIRECT_STEPPING)
         if (current_block->is_page()) page_manager.free_page(current_block->page_idx);
       #endif
       current_block = nullptr;
       axis_did_move = 0;
       planner.release_current_block();
+      TERN_(LIN_ADVANCE, la_interval = nextAdvanceISR = LA_ADV_NEVER);
     }
 
     // Quickly stop all steppers
     FORCE_INLINE static void quick_stop() { abort_current_block = true; }
 
     // The direction of a single motor
     FORCE_INLINE static bool motor_direction(const AxisEnum axis) { return TEST(last_direction_bits, axis); }
 
     // The last movement direction was not null on the specified axis. Note that motor direction is not necessarily the same.
     FORCE_INLINE static bool axis_is_moving(const AxisEnum axis) { return TEST(axis_did_move, axis); }
@@ -624,79 +625,23 @@ class Stepper {
     static void set_directions(const axis_bits_t bits) {
       last_direction_bits = bits;
       set_directions();
     }
 
   private:
 
     // Set the current position in steps
     static void _set_position(const abce_long_t &spos);
 
-    FORCE_INLINE static uint32_t calc_timer_interval(uint32_t step_rate, uint8_t *loops) {
-      uint32_t timer;
-
-      // Scale the frequency, as requested by the caller
-      step_rate <<= oversampling_factor;
-
-      uint8_t multistep = 1;
-      #if DISABLED(DISABLE_MULTI_STEPPING)
-
-        // The stepping frequency limits for each multistepping rate
-        static const uint32_t limit[] PROGMEM = {
-          (  MAX_STEP_ISR_FREQUENCY_1X     ),
-          (  MAX_STEP_ISR_FREQUENCY_2X >> 1),
-          (  MAX_STEP_ISR_FREQUENCY_4X >> 2),
-          (  MAX_STEP_ISR_FREQUENCY_8X >> 3),
-          ( MAX_STEP_ISR_FREQUENCY_16X >> 4),
-          ( MAX_STEP_ISR_FREQUENCY_32X >> 5),
-          ( MAX_STEP_ISR_FREQUENCY_64X >> 6),
-          (MAX_STEP_ISR_FREQUENCY_128X >> 7)
-        };
-
-        // Select the proper multistepping
-        uint8_t idx = 0;
-        while (idx < 7 && step_rate > (uint32_t)pgm_read_dword(&limit[idx])) {
-          step_rate >>= 1;
-          multistep <<= 1;
-          ++idx;
-        };
-      #else
-        NOMORE(step_rate, uint32_t(MAX_STEP_ISR_FREQUENCY_1X));
-      #endif
-      *loops = multistep;
-
-      #ifdef CPU_32_BIT
-        // In case of high-performance processor, it is able to calculate in real-time
-        timer = uint32_t(STEPPER_TIMER_RATE) / step_rate;
-      #else
-        constexpr uint32_t min_step_rate = (F_CPU) / 500000U;
-        NOLESS(step_rate, min_step_rate);
-        step_rate -= min_step_rate; // Correct for minimal speed
-        if (step_rate >= (8 * 256)) { // higher step rate
-          const uint8_t tmp_step_rate = (step_rate & 0x00FF);
-          const uint16_t table_address = (uint16_t)&speed_lookuptable_fast[(uint8_t)(step_rate >> 8)][0],
-                         gain = (uint16_t)pgm_read_word(table_address + 2);
-          timer = MultiU16X8toH16(tmp_step_rate, gain);
-          timer = (uint16_t)pgm_read_word(table_address) - timer;
-        }
-        else { // lower step rates
-          uint16_t table_address = (uint16_t)&speed_lookuptable_slow[0][0];
-          table_address += ((step_rate) >> 1) & 0xFFFC;
-          timer = (uint16_t)pgm_read_word(table_address)
-                - (((uint16_t)pgm_read_word(table_address + 2) * (uint8_t)(step_rate & 0x0007)) >> 3);
-        }
-        // (there is no need to limit the timer value here. All limits have been
-        // applied above, and AVR is able to keep up at 30khz Stepping ISR rate)
-      #endif
-
-      return timer;
-    }
+    // Calculate timing interval for the given step rate
+    static uint32_t calc_timer_interval(uint32_t step_rate);
+    static uint32_t calc_timer_interval(uint32_t step_rate, uint8_t &loops);
 
     #if ENABLED(S_CURVE_ACCELERATION)
       static void _calc_bezier_curve_coeffs(const int32_t v0, const int32_t v1, const uint32_t av);
       static int32_t _eval_bezier_curve(const uint32_t curr_step);
     #endif
 
     #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
       static void digipot_init();
     #endif
 

commit 84554083823da9eb9b67fa9154e9b1a56ea0c2d5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jul 17 22:19:24 2022 -0500

    üßë‚Äçüíª Give the simulator Stepper access

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 787599ce31..d8fb5af229 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -309,20 +309,22 @@ constexpr ena_mask_t enable_overlap[] = {
     REPEAT(E_STEPPERS, _E_OVERLAP)
   #endif
 };
 
 //static_assert(!any_enable_overlap(), "There is some overlap.");
 
 //
 // Stepper class definition
 //
 class Stepper {
+  friend class KinematicSystem;
+  friend class DeltaKinematicSystem;
 
   public:
 
     #if EITHER(HAS_EXTRA_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
       static bool separate_multi_axis;
     #endif
 
     #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
       #if HAS_MOTOR_CURRENT_PWM
         #ifndef PWM_MOTOR_CURRENT

commit 6a67ad4e4aacf7e7314f9e15fd8fe8489b73742b
Author: Mike La Spina <mike.laspina@shaw.ca>
Date:   Wed Jul 6 07:46:39 2022 -0500

    ‚ö°Ô∏è Fix and improve Inline Laser Power (#22690)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index c9a83caa7e..787599ce31 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -437,39 +437,20 @@ class Stepper {
 
     // Exact steps at which an endstop was triggered
     static xyz_long_t endstops_trigsteps;
 
     // Positions of stepper motors, in step units
     static xyze_long_t count_position;
 
     // Current stepper motor directions (+1 or -1)
     static xyze_int8_t count_direction;
 
-    #if ENABLED(LASER_POWER_INLINE_TRAPEZOID)
-
-      typedef struct {
-        bool enabled;       // Trapezoid needed flag (i.e., laser on, planner in control)
-        uint8_t cur_power;  // Current laser power
-        bool cruise_set;    // Power set up for cruising?
-
-        #if ENABLED(LASER_POWER_INLINE_TRAPEZOID_CONT)
-          uint16_t till_update;     // Countdown to the next update
-        #else
-          uint32_t last_step_count, // Step count from the last update
-                   acc_step_count;  // Bresenham counter for laser accel/decel
-        #endif
-      } stepper_laser_t;
-
-      static stepper_laser_t laser_trap;
-
-    #endif
-
   public:
     // Initialize stepper hardware
     static void init();
 
     // Interrupt Service Routine and phases
 
     // The stepper subsystem goes to sleep when it runs out of things to execute.
     // Call this to notify the subsystem that it is time to go to work.
     static void wake_up() { ENABLE_STEPPER_DRIVER_INTERRUPT(); }
 

commit 307dfb15ca88f424dcb4cf579e4542e77dfb0eaf
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Jun 26 22:24:59 2022 -0500

    ‚ôªÔ∏è Planner flags refactor

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 3b899e93e2..c9a83caa7e 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -517,22 +517,21 @@ class Stepper {
     static void set_position(const xyze_long_t &spos);
     static void set_axis_position(const AxisEnum a, const int32_t &v);
 
     // Report the positions of the steppers, in steps
     static void report_a_position(const xyz_long_t &pos);
     static void report_positions();
 
     // Discard current block and free any resources
     FORCE_INLINE static void discard_current_block() {
       #if ENABLED(DIRECT_STEPPING)
-        if (IS_PAGE(current_block))
-          page_manager.free_page(current_block->page_idx);
+        if (current_block->is_page()) page_manager.free_page(current_block->page_idx);
       #endif
       current_block = nullptr;
       axis_did_move = 0;
       planner.release_current_block();
     }
 
     // Quickly stop all steppers
     FORCE_INLINE static void quick_stop() { abort_current_block = true; }
 
     // The direction of a single motor

commit 1f322b565f409ab5068e225a4d9a929907c966f1
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu May 26 18:31:05 2022 -0500

    ‚ôªÔ∏è More updates for multi-axis

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 52b870929f..3b899e93e2 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -239,35 +239,37 @@
 #define MAX_STEP_ISR_FREQUENCY_4X   ((F_CPU) / ISR_EXECUTION_CYCLES(4))
 #define MAX_STEP_ISR_FREQUENCY_2X   ((F_CPU) / ISR_EXECUTION_CYCLES(2))
 #define MAX_STEP_ISR_FREQUENCY_1X   ((F_CPU) / ISR_EXECUTION_CYCLES(1))
 
 // The minimum step ISR rate used by ADAPTIVE_STEP_SMOOTHING to target 50% CPU usage
 // This does not account for the possibility of multi-stepping.
 // Perhaps DISABLE_MULTI_STEPPING should be required with ADAPTIVE_STEP_SMOOTHING.
 #define MIN_STEP_ISR_FREQUENCY (MAX_STEP_ISR_FREQUENCY_1X / 2)
 
 #define ENABLE_COUNT (NUM_AXES + E_STEPPERS)
-typedef IF<(ENABLE_COUNT > 8), uint16_t, uint8_t>::type ena_mask_t;
+#if ENABLE_COUNT > 16
+  typedef uint32_t ena_mask_t;
+#else
+  typedef IF<(ENABLE_COUNT > 8), uint16_t, uint8_t>::type ena_mask_t;
+#endif
 
 // Axis flags type, for enabled state or other simple state
 typedef struct {
   union {
     ena_mask_t bits;
     struct {
       bool NUM_AXIS_LIST(X:1, Y:1, Z:1, I:1, J:1, K:1, U:1, V:1, W:1);
       #if HAS_EXTRUDERS
         bool LIST_N(EXTRUDERS, E0:1, E1:1, E2:1, E3:1, E4:1, E5:1, E6:1, E7:1);
       #endif
     };
   };
-  constexpr ena_mask_t linear_bits() { return _BV(NUM_AXES) - 1; }
-  constexpr ena_mask_t e_bits() { return (_BV(EXTRUDERS) - 1) << NUM_AXES; }
 } stepper_flags_t;
 
 // All the stepper enable pins
 constexpr pin_t ena_pins[] = {
   NUM_AXIS_LIST(X_ENABLE_PIN, Y_ENABLE_PIN, Z_ENABLE_PIN, I_ENABLE_PIN, J_ENABLE_PIN, K_ENABLE_PIN, U_ENABLE_PIN, V_ENABLE_PIN, W_ENABLE_PIN),
   LIST_N(E_STEPPERS, E0_ENABLE_PIN, E1_ENABLE_PIN, E2_ENABLE_PIN, E3_ENABLE_PIN, E4_ENABLE_PIN, E5_ENABLE_PIN, E6_ENABLE_PIN, E7_ENABLE_PIN)
 };
 
 // Index of the axis or extruder element in a combined array
 constexpr uint8_t index_of_axis(const AxisEnum axis E_OPTARG(const uint8_t eindex=0)) {

commit d99185be24e035d6370c8f36851e09917d7fe342
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Sun May 22 14:32:16 2022 -0700

    üé® Fix/adjust warnings (#24225)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 09117f44c6..52b870929f 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -207,21 +207,21 @@
 
 // If linear advance is enabled, then it is handled separately
 #if ENABLED(LIN_ADVANCE)
 
   // Estimate the minimum LA loop time
   #if ENABLED(MIXING_EXTRUDER) // ToDo: ???
     // HELP ME: What is what?
     // Directions are set up for MIXING_STEPPERS - like before.
     // Finding the right stepper may last up to MIXING_STEPPERS loops in get_next_stepper().
     //   These loops are a bit faster than advancing a bresenham counter.
-    // Always only one e-stepper is stepped.
+    // Always only one E stepper is stepped.
     #define MIN_ISR_LA_LOOP_CYCLES ((MIXING_STEPPERS) * (ISR_STEPPER_CYCLES))
   #else
     #define MIN_ISR_LA_LOOP_CYCLES ISR_STEPPER_CYCLES
   #endif
 
   // And the real loop time
   #define ISR_LA_LOOP_CYCLES _MAX(MIN_STEPPER_PULSE_CYCLES, MIN_ISR_LA_LOOP_CYCLES)
 
 #else
   #define ISR_LA_LOOP_CYCLES 0UL

commit e438c77c6a5bb59966d39a6ea6aa7703ec4131a3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed May 4 19:10:14 2022 -0500

    üöö Move speed_lookuptable.h

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 47a4847b82..09117f44c6 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -39,21 +39,21 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with Grbl.  If not, see <https://www.gnu.org/licenses/>.
  */
 
 #include "../inc/MarlinConfig.h"
 
 #include "planner.h"
 #include "stepper/indirection.h"
 #ifdef __AVR__
-  #include "speed_lookuptable.h"
+  #include "stepper/speed_lookuptable.h"
 #endif
 
 // Disable multiple steps per ISR
 //#define DISABLE_MULTI_STEPPING
 
 //
 // Estimate the amount of time the Stepper ISR will take to execute
 //
 
 /**

commit df40181357b08761766067ef5012b2b3d0e34d3e
Author: Keith Bennett <13375512+thisiskeithb@users.noreply.github.com>
Date:   Wed May 4 17:25:02 2022 -0700

    üí• Num Axes and Multi-Stepper based on Driver Types (#24120)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index fbbef2bb9c..47a4847b82 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -359,23 +359,23 @@ class Stepper {
     static bool abort_current_block;        // Signals to the stepper that current block should be aborted
 
     #if ENABLED(X_DUAL_ENDSTOPS)
       static bool locked_X_motor, locked_X2_motor;
     #endif
     #if ENABLED(Y_DUAL_ENDSTOPS)
       static bool locked_Y_motor, locked_Y2_motor;
     #endif
     #if EITHER(Z_MULTI_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
       static bool locked_Z_motor, locked_Z2_motor
-                  #if NUM_Z_STEPPER_DRIVERS >= 3
+                  #if NUM_Z_STEPPERS >= 3
                     , locked_Z3_motor
-                    #if NUM_Z_STEPPER_DRIVERS >= 4
+                    #if NUM_Z_STEPPERS >= 4
                       , locked_Z4_motor
                     #endif
                   #endif
                   ;
     #endif
 
     static uint32_t acceleration_time, deceleration_time; // time measured in Stepper Timer ticks
     static uint8_t steps_per_isr;         // Count of steps to perform per Stepper ISR call
 
     #if ENABLED(ADAPTIVE_STEP_SMOOTHING)
@@ -563,32 +563,32 @@ class Stepper {
       FORCE_INLINE static void set_x_lock(const bool state) { locked_X_motor = state; }
       FORCE_INLINE static void set_x2_lock(const bool state) { locked_X2_motor = state; }
     #endif
     #if ENABLED(Y_DUAL_ENDSTOPS)
       FORCE_INLINE static void set_y_lock(const bool state) { locked_Y_motor = state; }
       FORCE_INLINE static void set_y2_lock(const bool state) { locked_Y2_motor = state; }
     #endif
     #if EITHER(Z_MULTI_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
       FORCE_INLINE static void set_z1_lock(const bool state) { locked_Z_motor = state; }
       FORCE_INLINE static void set_z2_lock(const bool state) { locked_Z2_motor = state; }
-      #if NUM_Z_STEPPER_DRIVERS >= 3
+      #if NUM_Z_STEPPERS >= 3
         FORCE_INLINE static void set_z3_lock(const bool state) { locked_Z3_motor = state; }
-        #if NUM_Z_STEPPER_DRIVERS >= 4
+        #if NUM_Z_STEPPERS >= 4
           FORCE_INLINE static void set_z4_lock(const bool state) { locked_Z4_motor = state; }
         #endif
       #endif
       static void set_all_z_lock(const bool lock, const int8_t except=-1) {
         set_z1_lock(lock ^ (except == 0));
         set_z2_lock(lock ^ (except == 1));
-        #if NUM_Z_STEPPER_DRIVERS >= 3
+        #if NUM_Z_STEPPERS >= 3
           set_z3_lock(lock ^ (except == 2));
-          #if NUM_Z_STEPPER_DRIVERS >= 4
+          #if NUM_Z_STEPPERS >= 4
             set_z4_lock(lock ^ (except == 3));
           #endif
         #endif
       }
     #endif
 
     #if ENABLED(BABYSTEPPING)
       static void do_babystep(const AxisEnum axis, const bool direction); // perform a short step with a single stepper motor, outside of any convention
     #endif
 

commit 8aaf64d9172bacff2231823ccedbe27a1a968d45
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Tue Apr 19 05:15:15 2022 +0200

    üí• Update Motor Current G-codes for extra axes (#23975)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 85172bed4c..fbbef2bb9c 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -322,21 +322,21 @@ class Stepper {
     #endif
 
     #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
       #if HAS_MOTOR_CURRENT_PWM
         #ifndef PWM_MOTOR_CURRENT
           #define PWM_MOTOR_CURRENT DEFAULT_PWM_MOTOR_CURRENT
         #endif
         #ifndef MOTOR_CURRENT_PWM_FREQUENCY
           #define MOTOR_CURRENT_PWM_FREQUENCY 31400
         #endif
-        #define MOTOR_CURRENT_COUNT NUM_AXES
+        #define MOTOR_CURRENT_COUNT 3
       #elif HAS_MOTOR_CURRENT_SPI
         static constexpr uint32_t digipot_count[] = DIGIPOT_MOTOR_CURRENT;
         #define MOTOR_CURRENT_COUNT COUNT(Stepper::digipot_count)
       #endif
       static bool initialized;
       static uint32_t motor_current_setting[MOTOR_CURRENT_COUNT]; // Initialized by settings.load()
     #endif
 
     // Last-moved extruder, as set when the last movement was fetched from planner
     #if HAS_MULTI_EXTRUDER

commit c4873a64ecd54dc0bbccb1eaeecd1b5ae2f6aef5
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Apr 3 16:14:02 2022 -0500

    üßë‚Äçüíª General and Axis-based bitfield flags (#23989)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 8cc8610fd4..85172bed4c 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -254,21 +254,21 @@ typedef struct {
     ena_mask_t bits;
     struct {
       bool NUM_AXIS_LIST(X:1, Y:1, Z:1, I:1, J:1, K:1, U:1, V:1, W:1);
       #if HAS_EXTRUDERS
         bool LIST_N(EXTRUDERS, E0:1, E1:1, E2:1, E3:1, E4:1, E5:1, E6:1, E7:1);
       #endif
     };
   };
   constexpr ena_mask_t linear_bits() { return _BV(NUM_AXES) - 1; }
   constexpr ena_mask_t e_bits() { return (_BV(EXTRUDERS) - 1) << NUM_AXES; }
-} axis_flags_t;
+} stepper_flags_t;
 
 // All the stepper enable pins
 constexpr pin_t ena_pins[] = {
   NUM_AXIS_LIST(X_ENABLE_PIN, Y_ENABLE_PIN, Z_ENABLE_PIN, I_ENABLE_PIN, J_ENABLE_PIN, K_ENABLE_PIN, U_ENABLE_PIN, V_ENABLE_PIN, W_ENABLE_PIN),
   LIST_N(E_STEPPERS, E0_ENABLE_PIN, E1_ENABLE_PIN, E2_ENABLE_PIN, E3_ENABLE_PIN, E4_ENABLE_PIN, E5_ENABLE_PIN, E6_ENABLE_PIN, E7_ENABLE_PIN)
 };
 
 // Index of the axis or extruder element in a combined array
 constexpr uint8_t index_of_axis(const AxisEnum axis E_OPTARG(const uint8_t eindex=0)) {
   return uint8_t(axis) + (E_TERN0(axis < NUM_AXES ? 0 : eindex));
@@ -589,21 +589,21 @@ class Stepper {
     #endif
 
     #if ENABLED(BABYSTEPPING)
       static void do_babystep(const AxisEnum axis, const bool direction); // perform a short step with a single stepper motor, outside of any convention
     #endif
 
     #if HAS_MOTOR_CURRENT_PWM
       static void refresh_motor_power();
     #endif
 
-    static axis_flags_t axis_enabled;   // Axis stepper(s) ENABLED states
+    static stepper_flags_t axis_enabled;  // Axis stepper(s) ENABLED states
 
     static bool axis_is_enabled(const AxisEnum axis E_OPTARG(const uint8_t eindex=0)) {
       return TEST(axis_enabled.bits, INDEX_OF_AXIS(axis, eindex));
     }
     static void mark_axis_enabled(const AxisEnum axis E_OPTARG(const uint8_t eindex=0)) {
       SBI(axis_enabled.bits, INDEX_OF_AXIS(axis, eindex));
     }
     static void mark_axis_disabled(const AxisEnum axis E_OPTARG(const uint8_t eindex=0)) {
       CBI(axis_enabled.bits, INDEX_OF_AXIS(axis, eindex));
     }

commit e5b651f407fcb743e2d00c45b0d361fb98230efb
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Fri Apr 1 07:10:38 2022 +0200

    ‚ú® Support for up to 9 axes (linear, rotary) (#23112)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 4c9fbb9556..8cc8610fd4 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -152,26 +152,35 @@
 #endif
 #if HAS_I_STEP
   #define ISR_I_STEPPER_CYCLES  ISR_STEPPER_CYCLES
 #endif
 #if HAS_J_STEP
   #define ISR_J_STEPPER_CYCLES  ISR_STEPPER_CYCLES
 #endif
 #if HAS_K_STEP
   #define ISR_K_STEPPER_CYCLES  ISR_STEPPER_CYCLES
 #endif
+#if HAS_U_STEP
+  #define ISR_U_STEPPER_CYCLES  ISR_STEPPER_CYCLES
+#endif
+#if HAS_V_STEP
+  #define ISR_V_STEPPER_CYCLES  ISR_STEPPER_CYCLES
+#endif
+#if HAS_W_STEP
+  #define ISR_W_STEPPER_CYCLES  ISR_STEPPER_CYCLES
+#endif
 #if HAS_EXTRUDERS
   #define ISR_E_STEPPER_CYCLES  ISR_STEPPER_CYCLES    // E is always interpolated, even for mixing extruders
 #endif
 
 // And the total minimum loop time, not including the base
-#define MIN_ISR_LOOP_CYCLES (ISR_MIXING_STEPPER_CYCLES LOGICAL_AXIS_GANG(+ ISR_E_STEPPER_CYCLES, + ISR_X_STEPPER_CYCLES, + ISR_Y_STEPPER_CYCLES, + ISR_Z_STEPPER_CYCLES, + ISR_I_STEPPER_CYCLES, + ISR_J_STEPPER_CYCLES, + ISR_K_STEPPER_CYCLES))
+#define MIN_ISR_LOOP_CYCLES (ISR_MIXING_STEPPER_CYCLES LOGICAL_AXIS_GANG(+ ISR_E_STEPPER_CYCLES, + ISR_X_STEPPER_CYCLES, + ISR_Y_STEPPER_CYCLES, + ISR_Z_STEPPER_CYCLES, + ISR_I_STEPPER_CYCLES, + ISR_J_STEPPER_CYCLES, + ISR_K_STEPPER_CYCLES, + ISR_U_STEPPER_CYCLES, + ISR_V_STEPPER_CYCLES, + ISR_W_STEPPER_CYCLES))
 
 // Calculate the minimum MPU cycles needed per pulse to enforce, limited to the max stepper rate
 #define _MIN_STEPPER_PULSE_CYCLES(N) _MAX(uint32_t((F_CPU) / (MAXIMUM_STEPPER_RATE)), ((F_CPU) / 500000UL) * (N))
 #if MINIMUM_STEPPER_PULSE
   #define MIN_STEPPER_PULSE_CYCLES _MIN_STEPPER_PULSE_CYCLES(uint32_t(MINIMUM_STEPPER_PULSE))
 #elif HAS_DRIVER(LV8729)
   #define MIN_STEPPER_PULSE_CYCLES uint32_t((((F_CPU) - 1) / 2000000) + 1) // 0.5¬µs, aka 500ns
 #else
   #define MIN_STEPPER_PULSE_CYCLES _MIN_STEPPER_PULSE_CYCLES(1UL)
 #endif
@@ -229,47 +238,47 @@
 #define MAX_STEP_ISR_FREQUENCY_8X   ((F_CPU) / ISR_EXECUTION_CYCLES(8))
 #define MAX_STEP_ISR_FREQUENCY_4X   ((F_CPU) / ISR_EXECUTION_CYCLES(4))
 #define MAX_STEP_ISR_FREQUENCY_2X   ((F_CPU) / ISR_EXECUTION_CYCLES(2))
 #define MAX_STEP_ISR_FREQUENCY_1X   ((F_CPU) / ISR_EXECUTION_CYCLES(1))
 
 // The minimum step ISR rate used by ADAPTIVE_STEP_SMOOTHING to target 50% CPU usage
 // This does not account for the possibility of multi-stepping.
 // Perhaps DISABLE_MULTI_STEPPING should be required with ADAPTIVE_STEP_SMOOTHING.
 #define MIN_STEP_ISR_FREQUENCY (MAX_STEP_ISR_FREQUENCY_1X / 2)
 
-#define ENABLE_COUNT (LINEAR_AXES + E_STEPPERS)
+#define ENABLE_COUNT (NUM_AXES + E_STEPPERS)
 typedef IF<(ENABLE_COUNT > 8), uint16_t, uint8_t>::type ena_mask_t;
 
 // Axis flags type, for enabled state or other simple state
 typedef struct {
   union {
     ena_mask_t bits;
     struct {
-      bool LINEAR_AXIS_LIST(X:1, Y:1, Z:1, I:1, J:1, K:1);
+      bool NUM_AXIS_LIST(X:1, Y:1, Z:1, I:1, J:1, K:1, U:1, V:1, W:1);
       #if HAS_EXTRUDERS
         bool LIST_N(EXTRUDERS, E0:1, E1:1, E2:1, E3:1, E4:1, E5:1, E6:1, E7:1);
       #endif
     };
   };
-  constexpr ena_mask_t linear_bits() { return _BV(LINEAR_AXES) - 1; }
-  constexpr ena_mask_t e_bits() { return (_BV(EXTRUDERS) - 1) << LINEAR_AXES; }
+  constexpr ena_mask_t linear_bits() { return _BV(NUM_AXES) - 1; }
+  constexpr ena_mask_t e_bits() { return (_BV(EXTRUDERS) - 1) << NUM_AXES; }
 } axis_flags_t;
 
 // All the stepper enable pins
 constexpr pin_t ena_pins[] = {
-  LINEAR_AXIS_LIST(X_ENABLE_PIN, Y_ENABLE_PIN, Z_ENABLE_PIN, I_ENABLE_PIN, J_ENABLE_PIN, K_ENABLE_PIN),
+  NUM_AXIS_LIST(X_ENABLE_PIN, Y_ENABLE_PIN, Z_ENABLE_PIN, I_ENABLE_PIN, J_ENABLE_PIN, K_ENABLE_PIN, U_ENABLE_PIN, V_ENABLE_PIN, W_ENABLE_PIN),
   LIST_N(E_STEPPERS, E0_ENABLE_PIN, E1_ENABLE_PIN, E2_ENABLE_PIN, E3_ENABLE_PIN, E4_ENABLE_PIN, E5_ENABLE_PIN, E6_ENABLE_PIN, E7_ENABLE_PIN)
 };
 
 // Index of the axis or extruder element in a combined array
 constexpr uint8_t index_of_axis(const AxisEnum axis E_OPTARG(const uint8_t eindex=0)) {
-  return uint8_t(axis) + (E_TERN0(axis < LINEAR_AXES ? 0 : eindex));
+  return uint8_t(axis) + (E_TERN0(axis < NUM_AXES ? 0 : eindex));
 }
 //#define __IAX_N(N,V...)           _IAX_##N(V)
 //#define _IAX_N(N,V...)            __IAX_N(N,V)
 //#define _IAX_1(A)                 index_of_axis(A)
 //#define _IAX_2(A,B)               index_of_axis(A E_OPTARG(B))
 //#define INDEX_OF_AXIS(V...)       _IAX_N(TWO_ARGS(V),V)
 
 #define INDEX_OF_AXIS(A,V...)     index_of_axis(A E_OPTARG(V+0))
 
 // Bit mask for a matching enable pin, or 0
@@ -285,21 +294,21 @@ constexpr ena_mask_t ena_overlap(const uint8_t a=0, const uint8_t b=0) {
 // Recursively get whether there's any overlap at all
 constexpr bool any_enable_overlap(const uint8_t a=0) {
   return a >= ENABLE_COUNT ? false : ena_overlap(a) || any_enable_overlap(a + 1);
 }
 
 // Array of axes that overlap with each
 // TODO: Consider cases where >=2 steppers are used by a linear axis or extruder
 //       (e.g., CoreXY, Dual XYZ, or E with multiple steppers, etc.).
 constexpr ena_mask_t enable_overlap[] = {
   #define _OVERLAP(N) ena_overlap(INDEX_OF_AXIS(AxisEnum(N))),
-  REPEAT(LINEAR_AXES, _OVERLAP)
+  REPEAT(NUM_AXES, _OVERLAP)
   #if HAS_EXTRUDERS
     #define _E_OVERLAP(N) ena_overlap(INDEX_OF_AXIS(E_AXIS, N)),
     REPEAT(E_STEPPERS, _E_OVERLAP)
   #endif
 };
 
 //static_assert(!any_enable_overlap(), "There is some overlap.");
 
 //
 // Stepper class definition
@@ -313,21 +322,21 @@ class Stepper {
     #endif
 
     #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
       #if HAS_MOTOR_CURRENT_PWM
         #ifndef PWM_MOTOR_CURRENT
           #define PWM_MOTOR_CURRENT DEFAULT_PWM_MOTOR_CURRENT
         #endif
         #ifndef MOTOR_CURRENT_PWM_FREQUENCY
           #define MOTOR_CURRENT_PWM_FREQUENCY 31400
         #endif
-        #define MOTOR_CURRENT_COUNT LINEAR_AXES
+        #define MOTOR_CURRENT_COUNT NUM_AXES
       #elif HAS_MOTOR_CURRENT_SPI
         static constexpr uint32_t digipot_count[] = DIGIPOT_MOTOR_CURRENT;
         #define MOTOR_CURRENT_COUNT COUNT(Stepper::digipot_count)
       #endif
       static bool initialized;
       static uint32_t motor_current_setting[MOTOR_CURRENT_COUNT]; // Initialized by settings.load()
     #endif
 
     // Last-moved extruder, as set when the last movement was fetched from planner
     #if HAS_MULTI_EXTRUDER

commit 20b5615305639c9e33907a755cee1c22cc5aa664
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Sat Mar 26 16:44:22 2022 +1300

    ‚ú® Configurable FREEZE pin state (#23944)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 99aa714ca0..4c9fbb9556 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -329,21 +329,21 @@ class Stepper {
       static uint32_t motor_current_setting[MOTOR_CURRENT_COUNT]; // Initialized by settings.load()
     #endif
 
     // Last-moved extruder, as set when the last movement was fetched from planner
     #if HAS_MULTI_EXTRUDER
       static uint8_t last_moved_extruder;
     #else
       static constexpr uint8_t last_moved_extruder = 0;
     #endif
 
-    #if HAS_FREEZE_PIN
+    #if ENABLED(FREEZE_FEATURE)
       static bool frozen;                   // Set this flag to instantly freeze motion
     #endif
 
   private:
 
     static block_t* current_block;          // A pointer to the block currently being traced
 
     static axis_bits_t last_direction_bits, // The next stepping-bits to be output
                        axis_did_move;       // Last Movement in the given direction is not null, as computed when the last movement was fetched from planner
 

commit 40481947fc1f11a01235c5c55333a4437fc45c5f
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Jan 14 03:14:13 2022 -0600

    üßë‚Äçüíª Misc. updates for extra axes (#23521)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 7967e58c35..99aa714ca0 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -313,21 +313,20 @@ class Stepper {
     #endif
 
     #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
       #if HAS_MOTOR_CURRENT_PWM
         #ifndef PWM_MOTOR_CURRENT
           #define PWM_MOTOR_CURRENT DEFAULT_PWM_MOTOR_CURRENT
         #endif
         #ifndef MOTOR_CURRENT_PWM_FREQUENCY
           #define MOTOR_CURRENT_PWM_FREQUENCY 31400
         #endif
-
         #define MOTOR_CURRENT_COUNT LINEAR_AXES
       #elif HAS_MOTOR_CURRENT_SPI
         static constexpr uint32_t digipot_count[] = DIGIPOT_MOTOR_CURRENT;
         #define MOTOR_CURRENT_COUNT COUNT(Stepper::digipot_count)
       #endif
       static bool initialized;
       static uint32_t motor_current_setting[MOTOR_CURRENT_COUNT]; // Initialized by settings.load()
     #endif
 
     // Last-moved extruder, as set when the last movement was fetched from planner

commit 2cfde39ecac13eb75f8ce933d2116d1b75db3e4b
Author: Mike La Spina <mike.laspina@shaw.ca>
Date:   Wed Jan 12 17:28:53 2022 -0600

    üêõ Fix, improve PWM on AVR (#23463)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 6b190889cd..7967e58c35 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -310,20 +310,24 @@ class Stepper {
 
     #if EITHER(HAS_EXTRA_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
       static bool separate_multi_axis;
     #endif
 
     #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
       #if HAS_MOTOR_CURRENT_PWM
         #ifndef PWM_MOTOR_CURRENT
           #define PWM_MOTOR_CURRENT DEFAULT_PWM_MOTOR_CURRENT
         #endif
+        #ifndef MOTOR_CURRENT_PWM_FREQUENCY
+          #define MOTOR_CURRENT_PWM_FREQUENCY 31400
+        #endif
+
         #define MOTOR_CURRENT_COUNT LINEAR_AXES
       #elif HAS_MOTOR_CURRENT_SPI
         static constexpr uint32_t digipot_count[] = DIGIPOT_MOTOR_CURRENT;
         #define MOTOR_CURRENT_COUNT COUNT(Stepper::digipot_count)
       #endif
       static bool initialized;
       static uint32_t motor_current_setting[MOTOR_CURRENT_COUNT]; // Initialized by settings.load()
     #endif
 
     // Last-moved extruder, as set when the last movement was fetched from planner

commit 6fb2d8a25f096d084348a6f6930f515d947474d4
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Dec 28 02:57:24 2021 -0600

    üßë‚Äçüíª Remove extraneous 'inline' hints

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index f170dd4104..6b190889cd 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -450,25 +450,25 @@ class Stepper {
     #endif
 
   public:
     // Initialize stepper hardware
     static void init();
 
     // Interrupt Service Routine and phases
 
     // The stepper subsystem goes to sleep when it runs out of things to execute.
     // Call this to notify the subsystem that it is time to go to work.
-    static inline void wake_up() { ENABLE_STEPPER_DRIVER_INTERRUPT(); }
+    static void wake_up() { ENABLE_STEPPER_DRIVER_INTERRUPT(); }
 
-    static inline bool is_awake() { return STEPPER_ISR_ENABLED(); }
+    static bool is_awake() { return STEPPER_ISR_ENABLED(); }
 
-    static inline bool suspend() {
+    static bool suspend() {
       const bool awake = is_awake();
       if (awake) DISABLE_STEPPER_DRIVER_INTERRUPT();
       return awake;
     }
 
     // The ISR scheduler
     static void isr();
 
     // The stepper pulse ISR phase
     static void pulse_phase_isr();
@@ -557,21 +557,21 @@ class Stepper {
     #endif
     #if EITHER(Z_MULTI_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
       FORCE_INLINE static void set_z1_lock(const bool state) { locked_Z_motor = state; }
       FORCE_INLINE static void set_z2_lock(const bool state) { locked_Z2_motor = state; }
       #if NUM_Z_STEPPER_DRIVERS >= 3
         FORCE_INLINE static void set_z3_lock(const bool state) { locked_Z3_motor = state; }
         #if NUM_Z_STEPPER_DRIVERS >= 4
           FORCE_INLINE static void set_z4_lock(const bool state) { locked_Z4_motor = state; }
         #endif
       #endif
-      static inline void set_all_z_lock(const bool lock, const int8_t except=-1) {
+      static void set_all_z_lock(const bool lock, const int8_t except=-1) {
         set_z1_lock(lock ^ (except == 0));
         set_z2_lock(lock ^ (except == 1));
         #if NUM_Z_STEPPER_DRIVERS >= 3
           set_z3_lock(lock ^ (except == 2));
           #if NUM_Z_STEPPER_DRIVERS >= 4
             set_z4_lock(lock ^ (except == 3));
           #endif
         #endif
       }
     #endif
@@ -579,46 +579,46 @@ class Stepper {
     #if ENABLED(BABYSTEPPING)
       static void do_babystep(const AxisEnum axis, const bool direction); // perform a short step with a single stepper motor, outside of any convention
     #endif
 
     #if HAS_MOTOR_CURRENT_PWM
       static void refresh_motor_power();
     #endif
 
     static axis_flags_t axis_enabled;   // Axis stepper(s) ENABLED states
 
-    static inline bool axis_is_enabled(const AxisEnum axis E_OPTARG(const uint8_t eindex=0)) {
+    static bool axis_is_enabled(const AxisEnum axis E_OPTARG(const uint8_t eindex=0)) {
       return TEST(axis_enabled.bits, INDEX_OF_AXIS(axis, eindex));
     }
-    static inline void mark_axis_enabled(const AxisEnum axis E_OPTARG(const uint8_t eindex=0)) {
+    static void mark_axis_enabled(const AxisEnum axis E_OPTARG(const uint8_t eindex=0)) {
       SBI(axis_enabled.bits, INDEX_OF_AXIS(axis, eindex));
     }
-    static inline void mark_axis_disabled(const AxisEnum axis E_OPTARG(const uint8_t eindex=0)) {
+    static void mark_axis_disabled(const AxisEnum axis E_OPTARG(const uint8_t eindex=0)) {
       CBI(axis_enabled.bits, INDEX_OF_AXIS(axis, eindex));
     }
-    static inline bool can_axis_disable(const AxisEnum axis E_OPTARG(const uint8_t eindex=0)) {
+    static bool can_axis_disable(const AxisEnum axis E_OPTARG(const uint8_t eindex=0)) {
       return !any_enable_overlap() || !(axis_enabled.bits & enable_overlap[INDEX_OF_AXIS(axis, eindex)]);
     }
 
     static void enable_axis(const AxisEnum axis);
     static bool disable_axis(const AxisEnum axis);
 
     #if HAS_EXTRUDERS
       static void enable_extruder(E_TERN_(const uint8_t eindex=0));
       static bool disable_extruder(E_TERN_(const uint8_t eindex=0));
       static void enable_e_steppers();
       static void disable_e_steppers();
     #else
-      static inline void enable_extruder() {}
-      static inline bool disable_extruder() { return true; }
-      static inline void enable_e_steppers() {}
-      static inline void disable_e_steppers() {}
+      static void enable_extruder() {}
+      static bool disable_extruder() { return true; }
+      static void enable_e_steppers() {}
+      static void disable_e_steppers() {}
     #endif
 
     #define  ENABLE_EXTRUDER(N)  enable_extruder(E_TERN_(N))
     #define DISABLE_EXTRUDER(N) disable_extruder(E_TERN_(N))
     #define AXIS_IS_ENABLED(N,V...) axis_is_enabled(N E_OPTARG(#V))
 
     static void enable_all_steppers();
     static void disable_all_steppers();
 
     // Update direction states for all steppers

commit b919bdbf0b4f78578964999373c8918cc523d736
Author: ellensp <530024+ellensp@users.noreply.github.com>
Date:   Mon Oct 4 19:12:19 2021 +1300

    ü©π Fix EXTRUDER 0 compile warning (#22868)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 0bfb418d40..f170dd4104 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -602,21 +602,21 @@ class Stepper {
     static void enable_axis(const AxisEnum axis);
     static bool disable_axis(const AxisEnum axis);
 
     #if HAS_EXTRUDERS
       static void enable_extruder(E_TERN_(const uint8_t eindex=0));
       static bool disable_extruder(E_TERN_(const uint8_t eindex=0));
       static void enable_e_steppers();
       static void disable_e_steppers();
     #else
       static inline void enable_extruder() {}
-      static inline bool disable_extruder() {}
+      static inline bool disable_extruder() { return true; }
       static inline void enable_e_steppers() {}
       static inline void disable_e_steppers() {}
     #endif
 
     #define  ENABLE_EXTRUDER(N)  enable_extruder(E_TERN_(N))
     #define DISABLE_EXTRUDER(N) disable_extruder(E_TERN_(N))
     #define AXIS_IS_ENABLED(N,V...) axis_is_enabled(N E_OPTARG(#V))
 
     static void enable_all_steppers();
     static void disable_all_steppers();

commit 33e0855e2c173680865aaa6c6aa93047d63fc469
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue Sep 28 01:07:51 2021 -0500

    ‚ö°Ô∏è Handle shared enable pins (#22824)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index ca88d6b6b1..0bfb418d40 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -229,20 +229,85 @@
 #define MAX_STEP_ISR_FREQUENCY_8X   ((F_CPU) / ISR_EXECUTION_CYCLES(8))
 #define MAX_STEP_ISR_FREQUENCY_4X   ((F_CPU) / ISR_EXECUTION_CYCLES(4))
 #define MAX_STEP_ISR_FREQUENCY_2X   ((F_CPU) / ISR_EXECUTION_CYCLES(2))
 #define MAX_STEP_ISR_FREQUENCY_1X   ((F_CPU) / ISR_EXECUTION_CYCLES(1))
 
 // The minimum step ISR rate used by ADAPTIVE_STEP_SMOOTHING to target 50% CPU usage
 // This does not account for the possibility of multi-stepping.
 // Perhaps DISABLE_MULTI_STEPPING should be required with ADAPTIVE_STEP_SMOOTHING.
 #define MIN_STEP_ISR_FREQUENCY (MAX_STEP_ISR_FREQUENCY_1X / 2)
 
+#define ENABLE_COUNT (LINEAR_AXES + E_STEPPERS)
+typedef IF<(ENABLE_COUNT > 8), uint16_t, uint8_t>::type ena_mask_t;
+
+// Axis flags type, for enabled state or other simple state
+typedef struct {
+  union {
+    ena_mask_t bits;
+    struct {
+      bool LINEAR_AXIS_LIST(X:1, Y:1, Z:1, I:1, J:1, K:1);
+      #if HAS_EXTRUDERS
+        bool LIST_N(EXTRUDERS, E0:1, E1:1, E2:1, E3:1, E4:1, E5:1, E6:1, E7:1);
+      #endif
+    };
+  };
+  constexpr ena_mask_t linear_bits() { return _BV(LINEAR_AXES) - 1; }
+  constexpr ena_mask_t e_bits() { return (_BV(EXTRUDERS) - 1) << LINEAR_AXES; }
+} axis_flags_t;
+
+// All the stepper enable pins
+constexpr pin_t ena_pins[] = {
+  LINEAR_AXIS_LIST(X_ENABLE_PIN, Y_ENABLE_PIN, Z_ENABLE_PIN, I_ENABLE_PIN, J_ENABLE_PIN, K_ENABLE_PIN),
+  LIST_N(E_STEPPERS, E0_ENABLE_PIN, E1_ENABLE_PIN, E2_ENABLE_PIN, E3_ENABLE_PIN, E4_ENABLE_PIN, E5_ENABLE_PIN, E6_ENABLE_PIN, E7_ENABLE_PIN)
+};
+
+// Index of the axis or extruder element in a combined array
+constexpr uint8_t index_of_axis(const AxisEnum axis E_OPTARG(const uint8_t eindex=0)) {
+  return uint8_t(axis) + (E_TERN0(axis < LINEAR_AXES ? 0 : eindex));
+}
+//#define __IAX_N(N,V...)           _IAX_##N(V)
+//#define _IAX_N(N,V...)            __IAX_N(N,V)
+//#define _IAX_1(A)                 index_of_axis(A)
+//#define _IAX_2(A,B)               index_of_axis(A E_OPTARG(B))
+//#define INDEX_OF_AXIS(V...)       _IAX_N(TWO_ARGS(V),V)
+
+#define INDEX_OF_AXIS(A,V...)     index_of_axis(A E_OPTARG(V+0))
+
+// Bit mask for a matching enable pin, or 0
+constexpr ena_mask_t ena_same(const uint8_t a, const uint8_t b) {
+  return ena_pins[a] == ena_pins[b] ? _BV(b) : 0;
+}
+
+// Recursively get the enable overlaps mask for a given linear axis or extruder
+constexpr ena_mask_t ena_overlap(const uint8_t a=0, const uint8_t b=0) {
+  return b >= ENABLE_COUNT ? 0 : (a == b ? 0 : ena_same(a, b)) | ena_overlap(a, b + 1);
+}
+
+// Recursively get whether there's any overlap at all
+constexpr bool any_enable_overlap(const uint8_t a=0) {
+  return a >= ENABLE_COUNT ? false : ena_overlap(a) || any_enable_overlap(a + 1);
+}
+
+// Array of axes that overlap with each
+// TODO: Consider cases where >=2 steppers are used by a linear axis or extruder
+//       (e.g., CoreXY, Dual XYZ, or E with multiple steppers, etc.).
+constexpr ena_mask_t enable_overlap[] = {
+  #define _OVERLAP(N) ena_overlap(INDEX_OF_AXIS(AxisEnum(N))),
+  REPEAT(LINEAR_AXES, _OVERLAP)
+  #if HAS_EXTRUDERS
+    #define _E_OVERLAP(N) ena_overlap(INDEX_OF_AXIS(E_AXIS, N)),
+    REPEAT(E_STEPPERS, _E_OVERLAP)
+  #endif
+};
+
+//static_assert(!any_enable_overlap(), "There is some overlap.");
+
 //
 // Stepper class definition
 //
 class Stepper {
 
   public:
 
     #if EITHER(HAS_EXTRA_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
       static bool separate_multi_axis;
     #endif
@@ -512,20 +577,57 @@ class Stepper {
     #endif
 
     #if ENABLED(BABYSTEPPING)
       static void do_babystep(const AxisEnum axis, const bool direction); // perform a short step with a single stepper motor, outside of any convention
     #endif
 
     #if HAS_MOTOR_CURRENT_PWM
       static void refresh_motor_power();
     #endif
 
+    static axis_flags_t axis_enabled;   // Axis stepper(s) ENABLED states
+
+    static inline bool axis_is_enabled(const AxisEnum axis E_OPTARG(const uint8_t eindex=0)) {
+      return TEST(axis_enabled.bits, INDEX_OF_AXIS(axis, eindex));
+    }
+    static inline void mark_axis_enabled(const AxisEnum axis E_OPTARG(const uint8_t eindex=0)) {
+      SBI(axis_enabled.bits, INDEX_OF_AXIS(axis, eindex));
+    }
+    static inline void mark_axis_disabled(const AxisEnum axis E_OPTARG(const uint8_t eindex=0)) {
+      CBI(axis_enabled.bits, INDEX_OF_AXIS(axis, eindex));
+    }
+    static inline bool can_axis_disable(const AxisEnum axis E_OPTARG(const uint8_t eindex=0)) {
+      return !any_enable_overlap() || !(axis_enabled.bits & enable_overlap[INDEX_OF_AXIS(axis, eindex)]);
+    }
+
+    static void enable_axis(const AxisEnum axis);
+    static bool disable_axis(const AxisEnum axis);
+
+    #if HAS_EXTRUDERS
+      static void enable_extruder(E_TERN_(const uint8_t eindex=0));
+      static bool disable_extruder(E_TERN_(const uint8_t eindex=0));
+      static void enable_e_steppers();
+      static void disable_e_steppers();
+    #else
+      static inline void enable_extruder() {}
+      static inline bool disable_extruder() {}
+      static inline void enable_e_steppers() {}
+      static inline void disable_e_steppers() {}
+    #endif
+
+    #define  ENABLE_EXTRUDER(N)  enable_extruder(E_TERN_(N))
+    #define DISABLE_EXTRUDER(N) disable_extruder(E_TERN_(N))
+    #define AXIS_IS_ENABLED(N,V...) axis_is_enabled(N E_OPTARG(#V))
+
+    static void enable_all_steppers();
+    static void disable_all_steppers();
+
     // Update direction states for all steppers
     static void set_directions();
 
     // Set direction bits and update all stepper DIR states
     static void set_directions(const axis_bits_t bits) {
       last_direction_bits = bits;
       set_directions();
     }
 
   private:

commit dc5bef62ba185461ba969db6af996ebc93a33ba7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Thu Sep 23 10:01:37 2021 -0500

    üé® Various multi-axis patches (#22823)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index d2f42b63fc..ca88d6b6b1 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -269,22 +269,22 @@ class Stepper {
     #endif
 
     #if HAS_FREEZE_PIN
       static bool frozen;                   // Set this flag to instantly freeze motion
     #endif
 
   private:
 
     static block_t* current_block;          // A pointer to the block currently being traced
 
-    static uint8_t last_direction_bits,     // The next stepping-bits to be output
-                   axis_did_move;           // Last Movement in the given direction is not null, as computed when the last movement was fetched from planner
+    static axis_bits_t last_direction_bits, // The next stepping-bits to be output
+                       axis_did_move;       // Last Movement in the given direction is not null, as computed when the last movement was fetched from planner
 
     static bool abort_current_block;        // Signals to the stepper that current block should be aborted
 
     #if ENABLED(X_DUAL_ENDSTOPS)
       static bool locked_X_motor, locked_X2_motor;
     #endif
     #if ENABLED(Y_DUAL_ENDSTOPS)
       static bool locked_Y_motor, locked_Y2_motor;
     #endif
     #if EITHER(Z_MULTI_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
@@ -516,21 +516,21 @@ class Stepper {
     #endif
 
     #if HAS_MOTOR_CURRENT_PWM
       static void refresh_motor_power();
     #endif
 
     // Update direction states for all steppers
     static void set_directions();
 
     // Set direction bits and update all stepper DIR states
-    static void set_directions(const uint8_t bits) {
+    static void set_directions(const axis_bits_t bits) {
       last_direction_bits = bits;
       set_directions();
     }
 
   private:
 
     // Set the current position in steps
     static void _set_position(const abce_long_t &spos);
 
     FORCE_INLINE static uint32_t calc_timer_interval(uint32_t step_rate, uint8_t *loops) {

commit 798a8a7a0852c12fb8640c4a531fac70fbc57eda
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 13 16:28:12 2021 -0500

    üîß SPINDLE_LASER_PWM => SPINDLE_LASER_USE_PWM

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 236ba5ee98..d2f42b63fc 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -365,25 +365,25 @@ class Stepper {
     // Current stepper motor directions (+1 or -1)
     static xyze_int8_t count_direction;
 
     #if ENABLED(LASER_POWER_INLINE_TRAPEZOID)
 
       typedef struct {
         bool enabled;       // Trapezoid needed flag (i.e., laser on, planner in control)
         uint8_t cur_power;  // Current laser power
         bool cruise_set;    // Power set up for cruising?
 
-        #if DISABLED(LASER_POWER_INLINE_TRAPEZOID_CONT)
+        #if ENABLED(LASER_POWER_INLINE_TRAPEZOID_CONT)
+          uint16_t till_update;     // Countdown to the next update
+        #else
           uint32_t last_step_count, // Step count from the last update
                    acc_step_count;  // Bresenham counter for laser accel/decel
-        #else
-          uint16_t till_update;     // Countdown to the next update
         #endif
       } stepper_laser_t;
 
       static stepper_laser_t laser_trap;
 
     #endif
 
   public:
     // Initialize stepper hardware
     static void init();

commit 7726af9c5348c1c7d0fd9a56eca87d00cd75fee6
Author: DerAndere <26200979+DerAndere1@users.noreply.github.com>
Date:   Sat Jun 5 09:18:47 2021 +0200

    üèóÔ∏è Support for up to 6 linear axes (#19112)
    
    Co-authored-by: Scott Lahteine <github@thinkyhead.com>

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 67ca6fa433..236ba5ee98 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -126,50 +126,52 @@
   #define ISR_LOOP_BASE_CYCLES 32UL
 
   // To start the step pulse, in the worst case takes
   #define ISR_START_STEPPER_CYCLES 57UL
 
   // And each stepper (start + stop pulse) takes in worst case
   #define ISR_STEPPER_CYCLES 88UL
 
 #endif
 
+// If linear advance is disabled, the loop also handles them
+#if DISABLED(LIN_ADVANCE) && ENABLED(MIXING_EXTRUDER)
+  #define ISR_MIXING_STEPPER_CYCLES ((MIXING_STEPPERS) * (ISR_STEPPER_CYCLES))
+#else
+  #define ISR_MIXING_STEPPER_CYCLES  0UL
+#endif
+
 // Add time for each stepper
 #if HAS_X_STEP
-  #define ISR_X_STEPPER_CYCLES       ISR_STEPPER_CYCLES
-#else
-  #define ISR_X_STEPPER_CYCLES       0UL
+  #define ISR_X_STEPPER_CYCLES  ISR_STEPPER_CYCLES
 #endif
 #if HAS_Y_STEP
-  #define ISR_Y_STEPPER_CYCLES       ISR_STEPPER_CYCLES
-#else
-  #define ISR_START_Y_STEPPER_CYCLES 0UL
-  #define ISR_Y_STEPPER_CYCLES       0UL
+  #define ISR_Y_STEPPER_CYCLES  ISR_STEPPER_CYCLES
 #endif
 #if HAS_Z_STEP
-  #define ISR_Z_STEPPER_CYCLES       ISR_STEPPER_CYCLES
-#else
-  #define ISR_Z_STEPPER_CYCLES       0UL
+  #define ISR_Z_STEPPER_CYCLES  ISR_STEPPER_CYCLES
 #endif
-
-// E is always interpolated, even for mixing extruders
-#define ISR_E_STEPPER_CYCLES         ISR_STEPPER_CYCLES
-
-// If linear advance is disabled, the loop also handles them
-#if DISABLED(LIN_ADVANCE) && ENABLED(MIXING_EXTRUDER)
-  #define ISR_MIXING_STEPPER_CYCLES ((MIXING_STEPPERS) * (ISR_STEPPER_CYCLES))
-#else
-  #define ISR_MIXING_STEPPER_CYCLES  0UL
+#if HAS_I_STEP
+  #define ISR_I_STEPPER_CYCLES  ISR_STEPPER_CYCLES
+#endif
+#if HAS_J_STEP
+  #define ISR_J_STEPPER_CYCLES  ISR_STEPPER_CYCLES
+#endif
+#if HAS_K_STEP
+  #define ISR_K_STEPPER_CYCLES  ISR_STEPPER_CYCLES
+#endif
+#if HAS_EXTRUDERS
+  #define ISR_E_STEPPER_CYCLES  ISR_STEPPER_CYCLES    // E is always interpolated, even for mixing extruders
 #endif
 
 // And the total minimum loop time, not including the base
-#define MIN_ISR_LOOP_CYCLES (ISR_X_STEPPER_CYCLES + ISR_Y_STEPPER_CYCLES + ISR_Z_STEPPER_CYCLES + ISR_E_STEPPER_CYCLES + ISR_MIXING_STEPPER_CYCLES)
+#define MIN_ISR_LOOP_CYCLES (ISR_MIXING_STEPPER_CYCLES LOGICAL_AXIS_GANG(+ ISR_E_STEPPER_CYCLES, + ISR_X_STEPPER_CYCLES, + ISR_Y_STEPPER_CYCLES, + ISR_Z_STEPPER_CYCLES, + ISR_I_STEPPER_CYCLES, + ISR_J_STEPPER_CYCLES, + ISR_K_STEPPER_CYCLES))
 
 // Calculate the minimum MPU cycles needed per pulse to enforce, limited to the max stepper rate
 #define _MIN_STEPPER_PULSE_CYCLES(N) _MAX(uint32_t((F_CPU) / (MAXIMUM_STEPPER_RATE)), ((F_CPU) / 500000UL) * (N))
 #if MINIMUM_STEPPER_PULSE
   #define MIN_STEPPER_PULSE_CYCLES _MIN_STEPPER_PULSE_CYCLES(uint32_t(MINIMUM_STEPPER_PULSE))
 #elif HAS_DRIVER(LV8729)
   #define MIN_STEPPER_PULSE_CYCLES uint32_t((((F_CPU) - 1) / 2000000) + 1) // 0.5¬µs, aka 500ns
 #else
   #define MIN_STEPPER_PULSE_CYCLES _MIN_STEPPER_PULSE_CYCLES(1UL)
 #endif
@@ -426,26 +428,21 @@ class Stepper {
       }
     #endif
 
     // Check if the given block is busy or not - Must not be called from ISR contexts
     static bool is_block_busy(const block_t * const block);
 
     // Get the position of a stepper, in steps
     static int32_t position(const AxisEnum axis);
 
     // Set the current position in steps
-    static void set_position(
-      LOGICAL_AXIS_LIST(const int32_t &e, const int32_t &a, const int32_t &b, const int32_t &c)
-    );
-    static inline void set_position(const xyze_long_t &abce) {
-      set_position(LOGICAL_AXIS_LIST(abce.e, abce.a, abce.b, abce.c));
-    }
+    static void set_position(const xyze_long_t &spos);
     static void set_axis_position(const AxisEnum a, const int32_t &v);
 
     // Report the positions of the steppers, in steps
     static void report_a_position(const xyz_long_t &pos);
     static void report_positions();
 
     // Discard current block and free any resources
     FORCE_INLINE static void discard_current_block() {
       #if ENABLED(DIRECT_STEPPING)
         if (IS_PAGE(current_block))
@@ -527,26 +524,21 @@ class Stepper {
 
     // Set direction bits and update all stepper DIR states
     static void set_directions(const uint8_t bits) {
       last_direction_bits = bits;
       set_directions();
     }
 
   private:
 
     // Set the current position in steps
-    static void _set_position(
-      LOGICAL_AXIS_LIST(const int32_t &e, const int32_t &a, const int32_t &b, const int32_t &c)
-    );
-    FORCE_INLINE static void _set_position(const abce_long_t &spos) {
-      _set_position(LOGICAL_AXIS_LIST(spos.e, spos.a, spos.b, spos.c));
-    }
+    static void _set_position(const abce_long_t &spos);
 
     FORCE_INLINE static uint32_t calc_timer_interval(uint32_t step_rate, uint8_t *loops) {
       uint32_t timer;
 
       // Scale the frequency, as requested by the caller
       step_rate <<= oversampling_factor;
 
       uint8_t multistep = 1;
       #if DISABLED(DISABLE_MULTI_STEPPING)
 

commit dd4990252e891cdfe56cb7d6e3bbe1e6289be649
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon May 24 16:38:57 2021 -0500

    ‚ôªÔ∏è Refactor Linear / Logical / Distinct Axes (#21953)
    
    * More patches supporting EXTRUDERS 0
    * Extend types in prep for more axes

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 020f72e9e6..67ca6fa433 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -426,22 +426,26 @@ class Stepper {
       }
     #endif
 
     // Check if the given block is busy or not - Must not be called from ISR contexts
     static bool is_block_busy(const block_t * const block);
 
     // Get the position of a stepper, in steps
     static int32_t position(const AxisEnum axis);
 
     // Set the current position in steps
-    static void set_position(const int32_t &a, const int32_t &b, const int32_t &c, const int32_t &e);
-    static inline void set_position(const xyze_long_t &abce) { set_position(abce.a, abce.b, abce.c, abce.e); }
+    static void set_position(
+      LOGICAL_AXIS_LIST(const int32_t &e, const int32_t &a, const int32_t &b, const int32_t &c)
+    );
+    static inline void set_position(const xyze_long_t &abce) {
+      set_position(LOGICAL_AXIS_LIST(abce.e, abce.a, abce.b, abce.c));
+    }
     static void set_axis_position(const AxisEnum a, const int32_t &v);
 
     // Report the positions of the steppers, in steps
     static void report_a_position(const xyz_long_t &pos);
     static void report_positions();
 
     // Discard current block and free any resources
     FORCE_INLINE static void discard_current_block() {
       #if ENABLED(DIRECT_STEPPING)
         if (IS_PAGE(current_block))
@@ -523,22 +527,26 @@ class Stepper {
 
     // Set direction bits and update all stepper DIR states
     static void set_directions(const uint8_t bits) {
       last_direction_bits = bits;
       set_directions();
     }
 
   private:
 
     // Set the current position in steps
-    static void _set_position(const int32_t &a, const int32_t &b, const int32_t &c, const int32_t &e);
-    FORCE_INLINE static void _set_position(const abce_long_t &spos) { _set_position(spos.a, spos.b, spos.c, spos.e); }
+    static void _set_position(
+      LOGICAL_AXIS_LIST(const int32_t &e, const int32_t &a, const int32_t &b, const int32_t &c)
+    );
+    FORCE_INLINE static void _set_position(const abce_long_t &spos) {
+      _set_position(LOGICAL_AXIS_LIST(spos.e, spos.a, spos.b, spos.c));
+    }
 
     FORCE_INLINE static uint32_t calc_timer_interval(uint32_t step_rate, uint8_t *loops) {
       uint32_t timer;
 
       // Scale the frequency, as requested by the caller
       step_rate <<= oversampling_factor;
 
       uint8_t multistep = 1;
       #if DISABLED(DISABLE_MULTI_STEPPING)
 

commit a6e5492b088add3589aeac168136369f21614e60
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 18 22:51:19 2021 -0500

    ‚ôªÔ∏è Refactor axis counts and loops

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 5ddd762aa9..020f72e9e6 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -243,21 +243,21 @@ class Stepper {
 
     #if EITHER(HAS_EXTRA_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
       static bool separate_multi_axis;
     #endif
 
     #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
       #if HAS_MOTOR_CURRENT_PWM
         #ifndef PWM_MOTOR_CURRENT
           #define PWM_MOTOR_CURRENT DEFAULT_PWM_MOTOR_CURRENT
         #endif
-        #define MOTOR_CURRENT_COUNT XYZ
+        #define MOTOR_CURRENT_COUNT LINEAR_AXES
       #elif HAS_MOTOR_CURRENT_SPI
         static constexpr uint32_t digipot_count[] = DIGIPOT_MOTOR_CURRENT;
         #define MOTOR_CURRENT_COUNT COUNT(Stepper::digipot_count)
       #endif
       static bool initialized;
       static uint32_t motor_current_setting[MOTOR_CURRENT_COUNT]; // Initialized by settings.load()
     #endif
 
     // Last-moved extruder, as set when the last movement was fetched from planner
     #if HAS_MULTI_EXTRUDER

commit d97c1f1c6245e2b1f3152e5a210ed840b4bdbefb
Author: Jamie <vector76@users.noreply.github.com>
Date:   Fri May 14 00:14:13 2021 -0500

    ‚ú® Instant Freeze/Resume Function (#17462)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index bbe8df146f..5ddd762aa9 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -259,20 +259,24 @@ class Stepper {
       static uint32_t motor_current_setting[MOTOR_CURRENT_COUNT]; // Initialized by settings.load()
     #endif
 
     // Last-moved extruder, as set when the last movement was fetched from planner
     #if HAS_MULTI_EXTRUDER
       static uint8_t last_moved_extruder;
     #else
       static constexpr uint8_t last_moved_extruder = 0;
     #endif
 
+    #if HAS_FREEZE_PIN
+      static bool frozen;                   // Set this flag to instantly freeze motion
+    #endif
+
   private:
 
     static block_t* current_block;          // A pointer to the block currently being traced
 
     static uint8_t last_direction_bits,     // The next stepping-bits to be output
                    axis_did_move;           // Last Movement in the given direction is not null, as computed when the last movement was fetched from planner
 
     static bool abort_current_block;        // Signals to the stepper that current block should be aborted
 
     #if ENABLED(X_DUAL_ENDSTOPS)

commit 0c8a53e507fa792b114a89fe6902f4efe4ed2fe8
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Tue May 11 10:47:32 2021 -0500

    :art: Misc. code cleanup

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index ca1781fb9c..bbe8df146f 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -243,21 +243,21 @@ class Stepper {
 
     #if EITHER(HAS_EXTRA_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
       static bool separate_multi_axis;
     #endif
 
     #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
       #if HAS_MOTOR_CURRENT_PWM
         #ifndef PWM_MOTOR_CURRENT
           #define PWM_MOTOR_CURRENT DEFAULT_PWM_MOTOR_CURRENT
         #endif
-        #define MOTOR_CURRENT_COUNT 3
+        #define MOTOR_CURRENT_COUNT XYZ
       #elif HAS_MOTOR_CURRENT_SPI
         static constexpr uint32_t digipot_count[] = DIGIPOT_MOTOR_CURRENT;
         #define MOTOR_CURRENT_COUNT COUNT(Stepper::digipot_count)
       #endif
       static bool initialized;
       static uint32_t motor_current_setting[MOTOR_CURRENT_COUNT]; // Initialized by settings.load()
     #endif
 
     // Last-moved extruder, as set when the last movement was fetched from planner
     #if HAS_MULTI_EXTRUDER

commit 3b73b115ca9366f0155986b717d4c85c31ed2f80
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Mar 29 20:36:37 2021 -0500

    Apply pointer formatting

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 639a1b2650..ca1781fb9c 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -416,21 +416,21 @@ class Stepper {
       static uint32_t babystepping_isr();
       FORCE_INLINE static void initiateBabystepping() {
         if (nextBabystepISR == BABYSTEP_NEVER) {
           nextBabystepISR = 0;
           wake_up();
         }
       }
     #endif
 
     // Check if the given block is busy or not - Must not be called from ISR contexts
-    static bool is_block_busy(const block_t* const block);
+    static bool is_block_busy(const block_t * const block);
 
     // Get the position of a stepper, in steps
     static int32_t position(const AxisEnum axis);
 
     // Set the current position in steps
     static void set_position(const int32_t &a, const int32_t &b, const int32_t &c, const int32_t &e);
     static inline void set_position(const xyze_long_t &abce) { set_position(abce.a, abce.b, abce.c, abce.e); }
     static void set_axis_position(const AxisEnum a, const int32_t &v);
 
     // Report the positions of the steppers, in steps
@@ -522,21 +522,21 @@ class Stepper {
       last_direction_bits = bits;
       set_directions();
     }
 
   private:
 
     // Set the current position in steps
     static void _set_position(const int32_t &a, const int32_t &b, const int32_t &c, const int32_t &e);
     FORCE_INLINE static void _set_position(const abce_long_t &spos) { _set_position(spos.a, spos.b, spos.c, spos.e); }
 
-    FORCE_INLINE static uint32_t calc_timer_interval(uint32_t step_rate, uint8_t* loops) {
+    FORCE_INLINE static uint32_t calc_timer_interval(uint32_t step_rate, uint8_t *loops) {
       uint32_t timer;
 
       // Scale the frequency, as requested by the caller
       step_rate <<= oversampling_factor;
 
       uint8_t multistep = 1;
       #if DISABLED(DISABLE_MULTI_STEPPING)
 
         // The stepping frequency limits for each multistepping rate
         static const uint32_t limit[] PROGMEM = {

commit 418b3e5ee26c0284561f07cf462af27971715d12
Author: nb-rapidia <43864438+nb-rapidia@users.noreply.github.com>
Date:   Fri Oct 16 14:59:55 2020 -0700

    Fix IDEX layer shift and DIR states (#19756)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 572c3f3f9b..639a1b2650 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -507,23 +507,29 @@ class Stepper {
     #endif
 
     #if ENABLED(BABYSTEPPING)
       static void do_babystep(const AxisEnum axis, const bool direction); // perform a short step with a single stepper motor, outside of any convention
     #endif
 
     #if HAS_MOTOR_CURRENT_PWM
       static void refresh_motor_power();
     #endif
 
-    // Set direction bits for all steppers
+    // Update direction states for all steppers
     static void set_directions();
 
+    // Set direction bits and update all stepper DIR states
+    static void set_directions(const uint8_t bits) {
+      last_direction_bits = bits;
+      set_directions();
+    }
+
   private:
 
     // Set the current position in steps
     static void _set_position(const int32_t &a, const int32_t &b, const int32_t &c, const int32_t &e);
     FORCE_INLINE static void _set_position(const abce_long_t &spos) { _set_position(spos.a, spos.b, spos.c, spos.e); }
 
     FORCE_INLINE static uint32_t calc_timer_interval(uint32_t step_rate, uint8_t* loops) {
       uint32_t timer;
 
       // Scale the frequency, as requested by the caller

commit 492ba2a111ce541513d4515c4af3f57ceaa897ea
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Oct 11 14:58:35 2020 -0500

    Digipots refactor / cleanup (#19690)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index da38192d8e..572c3f3f9b 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -238,26 +238,32 @@
 // Stepper class definition
 //
 class Stepper {
 
   public:
 
     #if EITHER(HAS_EXTRA_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
       static bool separate_multi_axis;
     #endif
 
-    #if HAS_MOTOR_CURRENT_PWM
-      #ifndef PWM_MOTOR_CURRENT
-        #define PWM_MOTOR_CURRENT DEFAULT_PWM_MOTOR_CURRENT
+    #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
+      #if HAS_MOTOR_CURRENT_PWM
+        #ifndef PWM_MOTOR_CURRENT
+          #define PWM_MOTOR_CURRENT DEFAULT_PWM_MOTOR_CURRENT
+        #endif
+        #define MOTOR_CURRENT_COUNT 3
+      #elif HAS_MOTOR_CURRENT_SPI
+        static constexpr uint32_t digipot_count[] = DIGIPOT_MOTOR_CURRENT;
+        #define MOTOR_CURRENT_COUNT COUNT(Stepper::digipot_count)
       #endif
-      static uint32_t motor_current_setting[3];
       static bool initialized;
+      static uint32_t motor_current_setting[MOTOR_CURRENT_COUNT]; // Initialized by settings.load()
     #endif
 
     // Last-moved extruder, as set when the last movement was fetched from planner
     #if HAS_MULTI_EXTRUDER
       static uint8_t last_moved_extruder;
     #else
       static constexpr uint8_t last_moved_extruder = 0;
     #endif
 
   private:
@@ -450,23 +456,23 @@ class Stepper {
 
     // The last movement direction was not null on the specified axis. Note that motor direction is not necessarily the same.
     FORCE_INLINE static bool axis_is_moving(const AxisEnum axis) { return TEST(axis_did_move, axis); }
 
     // Handle a triggered endstop
     static void endstop_triggered(const AxisEnum axis);
 
     // Triggered position of an axis in steps
     static int32_t triggered_position(const AxisEnum axis);
 
-    #if HAS_DIGIPOTSS || HAS_MOTOR_CURRENT_PWM
-      static void digitalPotWrite(const int16_t address, const int16_t value);
-      static void digipot_current(const uint8_t driver, const int16_t current);
+    #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
+      static void set_digipot_value_spi(const int16_t address, const int16_t value);
+      static void set_digipot_current(const uint8_t driver, const int16_t current);
     #endif
 
     #if HAS_MICROSTEPS
       static void microstep_ms(const uint8_t driver, const int8_t ms1, const int8_t ms2, const int8_t ms3);
       static void microstep_mode(const uint8_t driver, const uint8_t stepping);
       static void microstep_readings();
     #endif
 
     #if EITHER(HAS_EXTRA_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
       FORCE_INLINE static void set_separate_multi_axis(const bool state) { separate_multi_axis = state; }
@@ -575,21 +581,21 @@ class Stepper {
       #endif
 
       return timer;
     }
 
     #if ENABLED(S_CURVE_ACCELERATION)
       static void _calc_bezier_curve_coeffs(const int32_t v0, const int32_t v1, const uint32_t av);
       static int32_t _eval_bezier_curve(const uint32_t curr_step);
     #endif
 
-    #if HAS_DIGIPOTSS || HAS_MOTOR_CURRENT_PWM
+    #if HAS_MOTOR_CURRENT_SPI || HAS_MOTOR_CURRENT_PWM
       static void digipot_init();
     #endif
 
     #if HAS_MICROSTEPS
       static void microstep_init();
     #endif
 
 };
 
 extern Stepper stepper;

commit d8ed74904559aa8bdccc8b68acbccfbf1bf779d3
Author: makerbase <4164049@qq.com>
Date:   Mon Sep 21 09:55:02 2020 +0800

    Add MKS Robin E3P, improve LVGL UI (#19442)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index f83142444a..da38192d8e 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -246,36 +246,36 @@ class Stepper {
     #endif
 
     #if HAS_MOTOR_CURRENT_PWM
       #ifndef PWM_MOTOR_CURRENT
         #define PWM_MOTOR_CURRENT DEFAULT_PWM_MOTOR_CURRENT
       #endif
       static uint32_t motor_current_setting[3];
       static bool initialized;
     #endif
 
+    // Last-moved extruder, as set when the last movement was fetched from planner
+    #if HAS_MULTI_EXTRUDER
+      static uint8_t last_moved_extruder;
+    #else
+      static constexpr uint8_t last_moved_extruder = 0;
+    #endif
+
   private:
 
     static block_t* current_block;          // A pointer to the block currently being traced
 
     static uint8_t last_direction_bits,     // The next stepping-bits to be output
                    axis_did_move;           // Last Movement in the given direction is not null, as computed when the last movement was fetched from planner
 
     static bool abort_current_block;        // Signals to the stepper that current block should be aborted
 
-    // Last-moved extruder, as set when the last movement was fetched from planner
-    #if HAS_MULTI_EXTRUDER
-      static uint8_t last_moved_extruder;
-    #else
-      static constexpr uint8_t last_moved_extruder = 0;
-    #endif
-
     #if ENABLED(X_DUAL_ENDSTOPS)
       static bool locked_X_motor, locked_X2_motor;
     #endif
     #if ENABLED(Y_DUAL_ENDSTOPS)
       static bool locked_Y_motor, locked_Y2_motor;
     #endif
     #if EITHER(Z_MULTI_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
       static bool locked_Z_motor, locked_Z2_motor
                   #if NUM_Z_STEPPER_DRIVERS >= 3
                     , locked_Z3_motor

commit 76d8d1742c1d4a1efe0fd6c0645d3fc656bfd0b2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 20 18:29:08 2020 -0500

    Add multi-extruder condition

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 3b68553689..f83142444a 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -256,24 +256,24 @@ class Stepper {
   private:
 
     static block_t* current_block;          // A pointer to the block currently being traced
 
     static uint8_t last_direction_bits,     // The next stepping-bits to be output
                    axis_did_move;           // Last Movement in the given direction is not null, as computed when the last movement was fetched from planner
 
     static bool abort_current_block;        // Signals to the stepper that current block should be aborted
 
     // Last-moved extruder, as set when the last movement was fetched from planner
-    #if EXTRUDERS < 2
-      static constexpr uint8_t last_moved_extruder = 0;
-    #elif DISABLED(MIXING_EXTRUDER)
+    #if HAS_MULTI_EXTRUDER
       static uint8_t last_moved_extruder;
+    #else
+      static constexpr uint8_t last_moved_extruder = 0;
     #endif
 
     #if ENABLED(X_DUAL_ENDSTOPS)
       static bool locked_X_motor, locked_X2_motor;
     #endif
     #if ENABLED(Y_DUAL_ENDSTOPS)
       static bool locked_Y_motor, locked_Y2_motor;
     #endif
     #if EITHER(Z_MULTI_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
       static bool locked_Z_motor, locked_Z2_motor
@@ -297,21 +297,21 @@ class Stepper {
 
     // Delta error variables for the Bresenham line tracer
     static xyze_long_t delta_error;
     static xyze_ulong_t advance_dividend;
     static uint32_t advance_divisor,
                     step_events_completed,  // The number of step events executed in the current block
                     accelerate_until,       // The point from where we need to stop acceleration
                     decelerate_after,       // The point from where we need to start decelerating
                     step_event_count;       // The total event count for the current block
 
-    #if EXTRUDERS > 1 || ENABLED(MIXING_EXTRUDER)
+    #if EITHER(HAS_MULTI_EXTRUDER, MIXING_EXTRUDER)
       static uint8_t stepper_extruder;
     #else
       static constexpr uint8_t stepper_extruder = 0;
     #endif
 
     #if ENABLED(S_CURVE_ACCELERATION)
       static int32_t bezier_A,     // A coefficient in B√©zier speed curve
                      bezier_B,     // B coefficient in B√©zier speed curve
                      bezier_C;     // C coefficient in B√©zier speed curve
       static uint32_t bezier_F,    // F coefficient in B√©zier speed curve
@@ -444,25 +444,20 @@ class Stepper {
 
     // Quickly stop all steppers
     FORCE_INLINE static void quick_stop() { abort_current_block = true; }
 
     // The direction of a single motor
     FORCE_INLINE static bool motor_direction(const AxisEnum axis) { return TEST(last_direction_bits, axis); }
 
     // The last movement direction was not null on the specified axis. Note that motor direction is not necessarily the same.
     FORCE_INLINE static bool axis_is_moving(const AxisEnum axis) { return TEST(axis_did_move, axis); }
 
-    // The extruder associated to the last movement
-    FORCE_INLINE static uint8_t movement_extruder() {
-      return (EXTRUDERS > 1 && DISABLED(MIXING_EXTRUDER)) ? last_moved_extruder : 0;
-    }
-
     // Handle a triggered endstop
     static void endstop_triggered(const AxisEnum axis);
 
     // Triggered position of an axis in steps
     static int32_t triggered_position(const AxisEnum axis);
 
     #if HAS_DIGIPOTSS || HAS_MOTOR_CURRENT_PWM
       static void digitalPotWrite(const int16_t address, const int16_t value);
       static void digipot_current(const uint8_t driver, const int16_t current);
     #endif

commit 42fbd527f3bcc317ae6851aca5a45bdbf979de55
Author: Diego von Deschwanden <68632259+Diegovd@users.noreply.github.com>
Date:   Thu Jul 23 05:20:14 2020 +0200

    Fix links to secure sites (#18745)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 4665f2dc01..3b68553689 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -9,21 +9,21 @@
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
  *
  */
 #pragma once
 
 /**
  * stepper.h - stepper motor driver: executes motion plans of planner.c using the stepper motors
  * Derived from Grbl
  *
  * Copyright (c) 2009-2011 Simen Svale Skogsrud
  *
@@ -31,21 +31,21 @@
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * Grbl is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
- * along with Grbl.  If not, see <http://www.gnu.org/licenses/>.
+ * along with Grbl.  If not, see <https://www.gnu.org/licenses/>.
  */
 
 #include "../inc/MarlinConfig.h"
 
 #include "planner.h"
 #include "stepper/indirection.h"
 #ifdef __AVR__
   #include "speed_lookuptable.h"
 #endif
 

commit a847f37d43e4571ddc848172caa71e49c087eebe
Author: Jason Smith <jason.inet@gmail.com>
Date:   Sun Jul 19 19:53:29 2020 -0700

    Reduce Step Smoothing ceiling to 50% CPU usage (#18719)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 6ae5076cd2..4665f2dc01 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -222,22 +222,24 @@
 // The maximum allowable stepping frequency when doing x128-x1 stepping (in Hz)
 #define MAX_STEP_ISR_FREQUENCY_128X ((F_CPU) / ISR_EXECUTION_CYCLES(128))
 #define MAX_STEP_ISR_FREQUENCY_64X  ((F_CPU) / ISR_EXECUTION_CYCLES(64))
 #define MAX_STEP_ISR_FREQUENCY_32X  ((F_CPU) / ISR_EXECUTION_CYCLES(32))
 #define MAX_STEP_ISR_FREQUENCY_16X  ((F_CPU) / ISR_EXECUTION_CYCLES(16))
 #define MAX_STEP_ISR_FREQUENCY_8X   ((F_CPU) / ISR_EXECUTION_CYCLES(8))
 #define MAX_STEP_ISR_FREQUENCY_4X   ((F_CPU) / ISR_EXECUTION_CYCLES(4))
 #define MAX_STEP_ISR_FREQUENCY_2X   ((F_CPU) / ISR_EXECUTION_CYCLES(2))
 #define MAX_STEP_ISR_FREQUENCY_1X   ((F_CPU) / ISR_EXECUTION_CYCLES(1))
 
-// The minimum allowable frequency for step smoothing will be 1/10 of the maximum nominal frequency (in Hz)
-#define MIN_STEP_ISR_FREQUENCY MAX_STEP_ISR_FREQUENCY_1X
+// The minimum step ISR rate used by ADAPTIVE_STEP_SMOOTHING to target 50% CPU usage
+// This does not account for the possibility of multi-stepping.
+// Perhaps DISABLE_MULTI_STEPPING should be required with ADAPTIVE_STEP_SMOOTHING.
+#define MIN_STEP_ISR_FREQUENCY (MAX_STEP_ISR_FREQUENCY_1X / 2)
 
 //
 // Stepper class definition
 //
 class Stepper {
 
   public:
 
     #if EITHER(HAS_EXTRA_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
       static bool separate_multi_axis;

commit 55e519a06f47e8c29687ebf2b58cc8117be0afdf
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jul 14 21:26:09 2020 -0500

    General cleanup

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 90ca092ace..6ae5076cd2 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -184,21 +184,20 @@
   constexpr uint32_t _MIN_PULSE_HIGH_NS = 1000UL * MINIMUM_STEPPER_PULSE;
   constexpr uint32_t _MIN_PULSE_LOW_NS = _MIN_PULSE_HIGH_NS;
 #elif MAXIMUM_STEPPER_RATE
   // Assume 50% duty cycle
   constexpr uint32_t _MIN_PULSE_HIGH_NS = 500000000UL / MAXIMUM_STEPPER_RATE;
   constexpr uint32_t _MIN_PULSE_LOW_NS = _MIN_PULSE_HIGH_NS;
 #else
   #error "Expected at least one of MINIMUM_STEPPER_PULSE or MAXIMUM_STEPPER_RATE to be defined"
 #endif
 
-
 // But the user could be enforcing a minimum time, so the loop time is
 #define ISR_LOOP_CYCLES (ISR_LOOP_BASE_CYCLES + _MAX(MIN_STEPPER_PULSE_CYCLES, MIN_ISR_LOOP_CYCLES))
 
 // If linear advance is enabled, then it is handled separately
 #if ENABLED(LIN_ADVANCE)
 
   // Estimate the minimum LA loop time
   #if ENABLED(MIXING_EXTRUDER) // ToDo: ???
     // HELP ME: What is what?
     // Directions are set up for MIXING_STEPPERS - like before.
@@ -551,21 +550,21 @@ class Stepper {
         };
       #else
         NOMORE(step_rate, uint32_t(MAX_STEP_ISR_FREQUENCY_1X));
       #endif
       *loops = multistep;
 
       #ifdef CPU_32_BIT
         // In case of high-performance processor, it is able to calculate in real-time
         timer = uint32_t(STEPPER_TIMER_RATE) / step_rate;
       #else
-        constexpr uint32_t min_step_rate = F_CPU / 500000U;
+        constexpr uint32_t min_step_rate = (F_CPU) / 500000U;
         NOLESS(step_rate, min_step_rate);
         step_rate -= min_step_rate; // Correct for minimal speed
         if (step_rate >= (8 * 256)) { // higher step rate
           const uint8_t tmp_step_rate = (step_rate & 0x00FF);
           const uint16_t table_address = (uint16_t)&speed_lookuptable_fast[(uint8_t)(step_rate >> 8)][0],
                          gain = (uint16_t)pgm_read_word(table_address + 2);
           timer = MultiU16X8toH16(tmp_step_rate, gain);
           timer = (uint16_t)pgm_read_word(table_address) - timer;
         }
         else { // lower step rates

commit 0fa345f98f7223f2546a9a6808d5c67039fb3aab
Author: Luu Lac <45380455+shitcreek@users.noreply.github.com>
Date:   Mon Jun 8 19:53:39 2020 -0500

    Laser updates followup (#18237)
    
    Co-authored-by: Scott Lahteine <thinkyhead@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index bc35f55ff2..90ca092ace 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -348,33 +348,33 @@ class Stepper {
 
     // Positions of stepper motors, in step units
     static xyze_long_t count_position;
 
     // Current stepper motor directions (+1 or -1)
     static xyze_int8_t count_direction;
 
     #if ENABLED(LASER_POWER_INLINE_TRAPEZOID)
 
       typedef struct {
-        bool trap_en;       // Trapezoid needed flag (i.e., laser on, planner in control)
+        bool enabled;       // Trapezoid needed flag (i.e., laser on, planner in control)
         uint8_t cur_power;  // Current laser power
         bool cruise_set;    // Power set up for cruising?
 
         #if DISABLED(LASER_POWER_INLINE_TRAPEZOID_CONT)
           uint32_t last_step_count, // Step count from the last update
                    acc_step_count;  // Bresenham counter for laser accel/decel
         #else
           uint16_t till_update;     // Countdown to the next update
         #endif
       } stepper_laser_t;
 
-      static stepper_laser_t laser;
+      static stepper_laser_t laser_trap;
 
     #endif
 
   public:
     // Initialize stepper hardware
     static void init();
 
     // Interrupt Service Routine and phases
 
     // The stepper subsystem goes to sleep when it runs out of things to execute.

commit a1f3d2f3cd9bf8bb4da16da0e55cdb5ff264a15d
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 31 01:03:28 2020 -0500

    Move set_all_z_lock to Stepper

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 38af36db51..bc35f55ff2 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -477,28 +477,38 @@ class Stepper {
     #endif
     #if ENABLED(X_DUAL_ENDSTOPS)
       FORCE_INLINE static void set_x_lock(const bool state) { locked_X_motor = state; }
       FORCE_INLINE static void set_x2_lock(const bool state) { locked_X2_motor = state; }
     #endif
     #if ENABLED(Y_DUAL_ENDSTOPS)
       FORCE_INLINE static void set_y_lock(const bool state) { locked_Y_motor = state; }
       FORCE_INLINE static void set_y2_lock(const bool state) { locked_Y2_motor = state; }
     #endif
     #if EITHER(Z_MULTI_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
-      FORCE_INLINE static void set_z_lock(const bool state) { locked_Z_motor = state; }
+      FORCE_INLINE static void set_z1_lock(const bool state) { locked_Z_motor = state; }
       FORCE_INLINE static void set_z2_lock(const bool state) { locked_Z2_motor = state; }
       #if NUM_Z_STEPPER_DRIVERS >= 3
         FORCE_INLINE static void set_z3_lock(const bool state) { locked_Z3_motor = state; }
         #if NUM_Z_STEPPER_DRIVERS >= 4
           FORCE_INLINE static void set_z4_lock(const bool state) { locked_Z4_motor = state; }
         #endif
       #endif
+      static inline void set_all_z_lock(const bool lock, const int8_t except=-1) {
+        set_z1_lock(lock ^ (except == 0));
+        set_z2_lock(lock ^ (except == 1));
+        #if NUM_Z_STEPPER_DRIVERS >= 3
+          set_z3_lock(lock ^ (except == 2));
+          #if NUM_Z_STEPPER_DRIVERS >= 4
+            set_z4_lock(lock ^ (except == 3));
+          #endif
+        #endif
+      }
     #endif
 
     #if ENABLED(BABYSTEPPING)
       static void do_babystep(const AxisEnum axis, const bool direction); // perform a short step with a single stepper motor, outside of any convention
     #endif
 
     #if HAS_MOTOR_CURRENT_PWM
       static void refresh_motor_power();
     #endif
 

commit 2e03c7939ca351431c5c6bc727d71d8b8f7eb374
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 12 04:42:01 2020 -0500

    Simplification

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index a89d36e98f..38af36db51 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -445,25 +445,21 @@ class Stepper {
     FORCE_INLINE static void quick_stop() { abort_current_block = true; }
 
     // The direction of a single motor
     FORCE_INLINE static bool motor_direction(const AxisEnum axis) { return TEST(last_direction_bits, axis); }
 
     // The last movement direction was not null on the specified axis. Note that motor direction is not necessarily the same.
     FORCE_INLINE static bool axis_is_moving(const AxisEnum axis) { return TEST(axis_did_move, axis); }
 
     // The extruder associated to the last movement
     FORCE_INLINE static uint8_t movement_extruder() {
-      return (0
-        #if EXTRUDERS > 1 && DISABLED(MIXING_EXTRUDER)
-          + last_moved_extruder
-        #endif
-      );
+      return (EXTRUDERS > 1 && DISABLED(MIXING_EXTRUDER)) ? last_moved_extruder : 0;
     }
 
     // Handle a triggered endstop
     static void endstop_triggered(const AxisEnum axis);
 
     // Triggered position of an axis in steps
     static int32_t triggered_position(const AxisEnum axis);
 
     #if HAS_DIGIPOTSS || HAS_MOTOR_CURRENT_PWM
       static void digitalPotWrite(const int16_t address, const int16_t value);

commit 8a22ef0c83a94f742be39005f259226e005ded2d
Author: Colin Godsey <crgodsey@gmail.com>
Date:   Mon May 11 18:22:41 2020 -0600

    G6 Direct Stepping (#17853)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 793dc8745b..a89d36e98f 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -327,20 +327,24 @@ class Stepper {
       static uint16_t LA_current_adv_steps, LA_final_adv_steps, LA_max_adv_steps; // Copy from current executed block. Needed because current_block is set to NULL "too early".
       static int8_t LA_steps;
       static bool LA_use_advance_lead;
     #endif
 
     #if ENABLED(INTEGRATED_BABYSTEPPING)
       static constexpr uint32_t BABYSTEP_NEVER = 0xFFFFFFFF;
       static uint32_t nextBabystepISR;
     #endif
 
+    #if ENABLED(DIRECT_STEPPING)
+      static page_step_state_t page_step_state;
+    #endif
+
     static int32_t ticks_nominal;
     #if DISABLED(S_CURVE_ACCELERATION)
       static uint32_t acc_step_rate; // needed for deceleration start point
     #endif
 
     // Exact steps at which an endstop was triggered
     static xyz_long_t endstops_trigsteps;
 
     // Positions of stepper motors, in step units
     static xyze_long_t count_position;
@@ -419,20 +423,31 @@ class Stepper {
 
     // Set the current position in steps
     static void set_position(const int32_t &a, const int32_t &b, const int32_t &c, const int32_t &e);
     static inline void set_position(const xyze_long_t &abce) { set_position(abce.a, abce.b, abce.c, abce.e); }
     static void set_axis_position(const AxisEnum a, const int32_t &v);
 
     // Report the positions of the steppers, in steps
     static void report_a_position(const xyz_long_t &pos);
     static void report_positions();
 
+    // Discard current block and free any resources
+    FORCE_INLINE static void discard_current_block() {
+      #if ENABLED(DIRECT_STEPPING)
+        if (IS_PAGE(current_block))
+          page_manager.free_page(current_block->page_idx);
+      #endif
+      current_block = nullptr;
+      axis_did_move = 0;
+      planner.release_current_block();
+    }
+
     // Quickly stop all steppers
     FORCE_INLINE static void quick_stop() { abort_current_block = true; }
 
     // The direction of a single motor
     FORCE_INLINE static bool motor_direction(const AxisEnum axis) { return TEST(last_direction_bits, axis); }
 
     // The last movement direction was not null on the specified axis. Note that motor direction is not necessarily the same.
     FORCE_INLINE static bool axis_is_moving(const AxisEnum axis) { return TEST(axis_did_move, axis); }
 
     // The extruder associated to the last movement

commit ab2b98e4255b0b9579af9627e884ac3dfc1d30bb
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Apr 23 21:42:38 2020 -0500

    Apply composite tests

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 3876980ad0..793dc8745b 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -233,21 +233,21 @@
 // The minimum allowable frequency for step smoothing will be 1/10 of the maximum nominal frequency (in Hz)
 #define MIN_STEP_ISR_FREQUENCY MAX_STEP_ISR_FREQUENCY_1X
 
 //
 // Stepper class definition
 //
 class Stepper {
 
   public:
 
-    #if HAS_EXTRA_ENDSTOPS || ENABLED(Z_STEPPER_AUTO_ALIGN)
+    #if EITHER(HAS_EXTRA_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
       static bool separate_multi_axis;
     #endif
 
     #if HAS_MOTOR_CURRENT_PWM
       #ifndef PWM_MOTOR_CURRENT
         #define PWM_MOTOR_CURRENT DEFAULT_PWM_MOTOR_CURRENT
       #endif
       static uint32_t motor_current_setting[3];
       static bool initialized;
     #endif
@@ -454,21 +454,21 @@ class Stepper {
       static void digitalPotWrite(const int16_t address, const int16_t value);
       static void digipot_current(const uint8_t driver, const int16_t current);
     #endif
 
     #if HAS_MICROSTEPS
       static void microstep_ms(const uint8_t driver, const int8_t ms1, const int8_t ms2, const int8_t ms3);
       static void microstep_mode(const uint8_t driver, const uint8_t stepping);
       static void microstep_readings();
     #endif
 
-    #if HAS_EXTRA_ENDSTOPS || ENABLED(Z_STEPPER_AUTO_ALIGN)
+    #if EITHER(HAS_EXTRA_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
       FORCE_INLINE static void set_separate_multi_axis(const bool state) { separate_multi_axis = state; }
     #endif
     #if ENABLED(X_DUAL_ENDSTOPS)
       FORCE_INLINE static void set_x_lock(const bool state) { locked_X_motor = state; }
       FORCE_INLINE static void set_x2_lock(const bool state) { locked_X2_motor = state; }
     #endif
     #if ENABLED(Y_DUAL_ENDSTOPS)
       FORCE_INLINE static void set_y_lock(const bool state) { locked_Y_motor = state; }
       FORCE_INLINE static void set_y2_lock(const bool state) { locked_Y2_motor = state; }
     #endif

commit df8b7dfc406be095a62b5445b69c40034d418823
Author: Ben <jediminer543@users.noreply.github.com>
Date:   Fri Apr 3 01:31:08 2020 +0100

    Various Laser / Spindle improvements (#15335)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 46c6c1c16a..3876980ad0 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -332,37 +332,49 @@ class Stepper {
     #if ENABLED(INTEGRATED_BABYSTEPPING)
       static constexpr uint32_t BABYSTEP_NEVER = 0xFFFFFFFF;
       static uint32_t nextBabystepISR;
     #endif
 
     static int32_t ticks_nominal;
     #if DISABLED(S_CURVE_ACCELERATION)
       static uint32_t acc_step_rate; // needed for deceleration start point
     #endif
 
-    //
     // Exact steps at which an endstop was triggered
-    //
     static xyz_long_t endstops_trigsteps;
 
-    //
     // Positions of stepper motors, in step units
-    //
     static xyze_long_t count_position;
 
-    //
-    // Current direction of stepper motors (+1 or -1)
-    //
+    // Current stepper motor directions (+1 or -1)
     static xyze_int8_t count_direction;
 
-  public:
+    #if ENABLED(LASER_POWER_INLINE_TRAPEZOID)
+
+      typedef struct {
+        bool trap_en;       // Trapezoid needed flag (i.e., laser on, planner in control)
+        uint8_t cur_power;  // Current laser power
+        bool cruise_set;    // Power set up for cruising?
+
+        #if DISABLED(LASER_POWER_INLINE_TRAPEZOID_CONT)
+          uint32_t last_step_count, // Step count from the last update
+                   acc_step_count;  // Bresenham counter for laser accel/decel
+        #else
+          uint16_t till_update;     // Countdown to the next update
+        #endif
+      } stepper_laser_t;
 
+      static stepper_laser_t laser;
+
+    #endif
+
+  public:
     // Initialize stepper hardware
     static void init();
 
     // Interrupt Service Routine and phases
 
     // The stepper subsystem goes to sleep when it runs out of things to execute.
     // Call this to notify the subsystem that it is time to go to work.
     static inline void wake_up() { ENABLE_STEPPER_DRIVER_INTERRUPT(); }
 
     static inline bool is_awake() { return STEPPER_ISR_ENABLED(); }

commit 3a07b4412d24a6afd430f6d7e1b8c7f3c442a3c2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Mar 2 21:52:53 2020 -0600

    Asynchronous M114 and (R)ealtime position option (#17032)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 6671b946df..46c6c1c16a 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -404,20 +404,21 @@ class Stepper {
 
     // Get the position of a stepper, in steps
     static int32_t position(const AxisEnum axis);
 
     // Set the current position in steps
     static void set_position(const int32_t &a, const int32_t &b, const int32_t &c, const int32_t &e);
     static inline void set_position(const xyze_long_t &abce) { set_position(abce.a, abce.b, abce.c, abce.e); }
     static void set_axis_position(const AxisEnum a, const int32_t &v);
 
     // Report the positions of the steppers, in steps
+    static void report_a_position(const xyz_long_t &pos);
     static void report_positions();
 
     // Quickly stop all steppers
     FORCE_INLINE static void quick_stop() { abort_current_block = true; }
 
     // The direction of a single motor
     FORCE_INLINE static bool motor_direction(const AxisEnum axis) { return TEST(last_direction_bits, axis); }
 
     // The last movement direction was not null on the specified axis. Note that motor direction is not necessarily the same.
     FORCE_INLINE static bool axis_is_moving(const AxisEnum axis) { return TEST(axis_did_move, axis); }

commit 99a50743727e2076c19d8f9469090c3ddd6f9a93
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Feb 16 17:46:41 2020 -0600

    Fix babystep include, typos in stepper.cpp
    
    Fix #16881

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 9f1b9321bb..6671b946df 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -464,21 +464,21 @@ class Stepper {
       FORCE_INLINE static void set_z2_lock(const bool state) { locked_Z2_motor = state; }
       #if NUM_Z_STEPPER_DRIVERS >= 3
         FORCE_INLINE static void set_z3_lock(const bool state) { locked_Z3_motor = state; }
         #if NUM_Z_STEPPER_DRIVERS >= 4
           FORCE_INLINE static void set_z4_lock(const bool state) { locked_Z4_motor = state; }
         #endif
       #endif
     #endif
 
     #if ENABLED(BABYSTEPPING)
-      static void babystep(const AxisEnum axis, const bool direction); // perform a short step with a single stepper motor, outside of any convention
+      static void do_babystep(const AxisEnum axis, const bool direction); // perform a short step with a single stepper motor, outside of any convention
     #endif
 
     #if HAS_MOTOR_CURRENT_PWM
       static void refresh_motor_power();
     #endif
 
     // Set direction bits for all steppers
     static void set_directions();
 
   private:

commit 64a81f887a3b9fd471484dba784e11bdba88ffbb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Feb 15 21:42:28 2020 -0600

    EXPERIMENTAL integrated BABYSTEPPING (#16829)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index ed07bfd5df..9f1b9321bb 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -322,20 +322,25 @@ class Stepper {
     #endif
 
     #if ENABLED(LIN_ADVANCE)
       static constexpr uint32_t LA_ADV_NEVER = 0xFFFFFFFF;
       static uint32_t nextAdvanceISR, LA_isr_rate;
       static uint16_t LA_current_adv_steps, LA_final_adv_steps, LA_max_adv_steps; // Copy from current executed block. Needed because current_block is set to NULL "too early".
       static int8_t LA_steps;
       static bool LA_use_advance_lead;
     #endif
 
+    #if ENABLED(INTEGRATED_BABYSTEPPING)
+      static constexpr uint32_t BABYSTEP_NEVER = 0xFFFFFFFF;
+      static uint32_t nextBabystepISR;
+    #endif
+
     static int32_t ticks_nominal;
     #if DISABLED(S_CURVE_ACCELERATION)
       static uint32_t acc_step_rate; // needed for deceleration start point
     #endif
 
     //
     // Exact steps at which an endstop was triggered
     //
     static xyz_long_t endstops_trigsteps;
 
@@ -376,20 +381,31 @@ class Stepper {
 
     // The stepper block processing ISR phase
     static uint32_t block_phase_isr();
 
     #if ENABLED(LIN_ADVANCE)
       // The Linear advance ISR phase
       static uint32_t advance_isr();
       FORCE_INLINE static void initiateLA() { nextAdvanceISR = 0; }
     #endif
 
+    #if ENABLED(INTEGRATED_BABYSTEPPING)
+      // The Babystepping ISR phase
+      static uint32_t babystepping_isr();
+      FORCE_INLINE static void initiateBabystepping() {
+        if (nextBabystepISR == BABYSTEP_NEVER) {
+          nextBabystepISR = 0;
+          wake_up();
+        }
+      }
+    #endif
+
     // Check if the given block is busy or not - Must not be called from ISR contexts
     static bool is_block_busy(const block_t* const block);
 
     // Get the position of a stepper, in steps
     static int32_t position(const AxisEnum axis);
 
     // Set the current position in steps
     static void set_position(const int32_t &a, const int32_t &b, const int32_t &c, const int32_t &e);
     static inline void set_position(const xyze_long_t &abce) { set_position(abce.a, abce.b, abce.c, abce.e); }
     static void set_axis_position(const AxisEnum a, const int32_t &v);

commit 0b984519c30f453fdb5b4efb8008a07c69688824
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Feb 14 05:14:37 2020 -0600

    Clean up stepper and babystep (#16857)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 6b8d0f3628..ed07bfd5df 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -314,27 +314,27 @@ class Stepper {
                      bezier_B,     // B coefficient in B√©zier speed curve
                      bezier_C;     // C coefficient in B√©zier speed curve
       static uint32_t bezier_F,    // F coefficient in B√©zier speed curve
                       bezier_AV;   // AV coefficient in B√©zier speed curve
       #ifdef __AVR__
         static bool A_negative;    // If A coefficient was negative
       #endif
       static bool bezier_2nd_half; // If B√©zier curve has been initialized or not
     #endif
 
-    static uint32_t nextMainISR;   // time remaining for the next Step ISR
     #if ENABLED(LIN_ADVANCE)
+      static constexpr uint32_t LA_ADV_NEVER = 0xFFFFFFFF;
       static uint32_t nextAdvanceISR, LA_isr_rate;
       static uint16_t LA_current_adv_steps, LA_final_adv_steps, LA_max_adv_steps; // Copy from current executed block. Needed because current_block is set to NULL "too early".
       static int8_t LA_steps;
       static bool LA_use_advance_lead;
-    #endif // LIN_ADVANCE
+    #endif
 
     static int32_t ticks_nominal;
     #if DISABLED(S_CURVE_ACCELERATION)
       static uint32_t acc_step_rate; // needed for deceleration start point
     #endif
 
     //
     // Exact steps at which an endstop was triggered
     //
     static xyz_long_t endstops_trigsteps;
@@ -344,57 +344,66 @@ class Stepper {
     //
     static xyze_long_t count_position;
 
     //
     // Current direction of stepper motors (+1 or -1)
     //
     static xyze_int8_t count_direction;
 
   public:
 
-    //
-    // Constructor / initializer
-    //
-    Stepper() {};
-
     // Initialize stepper hardware
     static void init();
 
-    // Interrupt Service Routines
+    // Interrupt Service Routine and phases
+
+    // The stepper subsystem goes to sleep when it runs out of things to execute.
+    // Call this to notify the subsystem that it is time to go to work.
+    static inline void wake_up() { ENABLE_STEPPER_DRIVER_INTERRUPT(); }
+
+    static inline bool is_awake() { return STEPPER_ISR_ENABLED(); }
+
+    static inline bool suspend() {
+      const bool awake = is_awake();
+      if (awake) DISABLE_STEPPER_DRIVER_INTERRUPT();
+      return awake;
+    }
 
     // The ISR scheduler
     static void isr();
 
-    // The stepper pulse phase ISR
-    static void stepper_pulse_phase_isr();
+    // The stepper pulse ISR phase
+    static void pulse_phase_isr();
 
-    // The stepper block processing phase ISR
-    static uint32_t stepper_block_phase_isr();
+    // The stepper block processing ISR phase
+    static uint32_t block_phase_isr();
 
     #if ENABLED(LIN_ADVANCE)
-      // The Linear advance stepper ISR
+      // The Linear advance ISR phase
       static uint32_t advance_isr();
+      FORCE_INLINE static void initiateLA() { nextAdvanceISR = 0; }
     #endif
 
     // Check if the given block is busy or not - Must not be called from ISR contexts
     static bool is_block_busy(const block_t* const block);
 
     // Get the position of a stepper, in steps
     static int32_t position(const AxisEnum axis);
 
+    // Set the current position in steps
+    static void set_position(const int32_t &a, const int32_t &b, const int32_t &c, const int32_t &e);
+    static inline void set_position(const xyze_long_t &abce) { set_position(abce.a, abce.b, abce.c, abce.e); }
+    static void set_axis_position(const AxisEnum a, const int32_t &v);
+
     // Report the positions of the steppers, in steps
     static void report_positions();
 
-    // The stepper subsystem goes to sleep when it runs out of things to execute. Call this
-    // to notify the subsystem that it is time to go to work.
-    static void wake_up();
-
     // Quickly stop all steppers
     FORCE_INLINE static void quick_stop() { abort_current_block = true; }
 
     // The direction of a single motor
     FORCE_INLINE static bool motor_direction(const AxisEnum axis) { return TEST(last_direction_bits, axis); }
 
     // The last movement direction was not null on the specified axis. Note that motor direction is not necessarily the same.
     FORCE_INLINE static bool axis_is_moving(const AxisEnum axis) { return TEST(axis_did_move, axis); }
 
     // The extruder associated to the last movement
@@ -446,62 +455,34 @@ class Stepper {
     #endif
 
     #if ENABLED(BABYSTEPPING)
       static void babystep(const AxisEnum axis, const bool direction); // perform a short step with a single stepper motor, outside of any convention
     #endif
 
     #if HAS_MOTOR_CURRENT_PWM
       static void refresh_motor_power();
     #endif
 
-    // Set the current position in steps
-    static inline void set_position(const int32_t &a, const int32_t &b, const int32_t &c, const int32_t &e) {
-      planner.synchronize();
-      const bool was_enabled = STEPPER_ISR_ENABLED();
-      if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
-      _set_position(a, b, c, e);
-      if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
-    }
-    static inline void set_position(const xyze_long_t &abce) { set_position(abce.a, abce.b, abce.c, abce.e); }
-
-    static inline void set_axis_position(const AxisEnum a, const int32_t &v) {
-      planner.synchronize();
-
-      #ifdef __AVR__
-        // Protect the access to the position. Only required for AVR, as
-        //  any 32bit CPU offers atomic access to 32bit variables
-        const bool was_enabled = STEPPER_ISR_ENABLED();
-        if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
-      #endif
-
-      count_position[a] = v;
-
-      #ifdef __AVR__
-        // Reenable Stepper ISR
-        if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
-      #endif
-    }
-
     // Set direction bits for all steppers
     static void set_directions();
 
   private:
 
     // Set the current position in steps
     static void _set_position(const int32_t &a, const int32_t &b, const int32_t &c, const int32_t &e);
     FORCE_INLINE static void _set_position(const abce_long_t &spos) { _set_position(spos.a, spos.b, spos.c, spos.e); }
 
-    FORCE_INLINE static uint32_t calc_timer_interval(uint32_t step_rate, uint8_t scale, uint8_t* loops) {
+    FORCE_INLINE static uint32_t calc_timer_interval(uint32_t step_rate, uint8_t* loops) {
       uint32_t timer;
 
       // Scale the frequency, as requested by the caller
-      step_rate <<= scale;
+      step_rate <<= oversampling_factor;
 
       uint8_t multistep = 1;
       #if DISABLED(DISABLE_MULTI_STEPPING)
 
         // The stepping frequency limits for each multistepping rate
         static const uint32_t limit[] PROGMEM = {
           (  MAX_STEP_ISR_FREQUENCY_1X     ),
           (  MAX_STEP_ISR_FREQUENCY_2X >> 1),
           (  MAX_STEP_ISR_FREQUENCY_4X >> 2),
           (  MAX_STEP_ISR_FREQUENCY_8X >> 3),

commit bfad23d3e2e590b257ebe4317d7b14cc2dd3435c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 3 08:00:57 2020 -0600

    (c) 2020

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 808f4630d4..6b8d0f3628 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2020 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit 0fcf2b1110d9f0d362e5aab9cc73d963710e9865
Author: InsanityAutomation <38436470+InsanityAutomation@users.noreply.github.com>
Date:   Mon Jan 20 00:35:07 2020 -0500

    Quad Z stepper support (#16277)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 149a211638..808f4630d4 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -267,25 +267,29 @@ class Stepper {
     #elif DISABLED(MIXING_EXTRUDER)
       static uint8_t last_moved_extruder;
     #endif
 
     #if ENABLED(X_DUAL_ENDSTOPS)
       static bool locked_X_motor, locked_X2_motor;
     #endif
     #if ENABLED(Y_DUAL_ENDSTOPS)
       static bool locked_Y_motor, locked_Y2_motor;
     #endif
-    #if Z_MULTI_ENDSTOPS || ENABLED(Z_STEPPER_AUTO_ALIGN)
-      static bool locked_Z_motor, locked_Z2_motor;
-    #endif
-    #if ENABLED(Z_TRIPLE_ENDSTOPS) || BOTH(Z_STEPPER_AUTO_ALIGN, Z_TRIPLE_STEPPER_DRIVERS)
-      static bool locked_Z3_motor;
+    #if EITHER(Z_MULTI_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
+      static bool locked_Z_motor, locked_Z2_motor
+                  #if NUM_Z_STEPPER_DRIVERS >= 3
+                    , locked_Z3_motor
+                    #if NUM_Z_STEPPER_DRIVERS >= 4
+                      , locked_Z4_motor
+                    #endif
+                  #endif
+                  ;
     #endif
 
     static uint32_t acceleration_time, deceleration_time; // time measured in Stepper Timer ticks
     static uint8_t steps_per_isr;         // Count of steps to perform per Stepper ISR call
 
     #if ENABLED(ADAPTIVE_STEP_SMOOTHING)
       static uint8_t oversampling_factor; // Oversampling factor (log2(multiplier)) to increase temporal resolution of axis
     #else
       static constexpr uint8_t oversampling_factor = 0;
     #endif
@@ -423,26 +427,29 @@ class Stepper {
       FORCE_INLINE static void set_separate_multi_axis(const bool state) { separate_multi_axis = state; }
     #endif
     #if ENABLED(X_DUAL_ENDSTOPS)
       FORCE_INLINE static void set_x_lock(const bool state) { locked_X_motor = state; }
       FORCE_INLINE static void set_x2_lock(const bool state) { locked_X2_motor = state; }
     #endif
     #if ENABLED(Y_DUAL_ENDSTOPS)
       FORCE_INLINE static void set_y_lock(const bool state) { locked_Y_motor = state; }
       FORCE_INLINE static void set_y2_lock(const bool state) { locked_Y2_motor = state; }
     #endif
-    #if Z_MULTI_ENDSTOPS || (ENABLED(Z_STEPPER_AUTO_ALIGN) && Z_MULTI_STEPPER_DRIVERS)
+    #if EITHER(Z_MULTI_ENDSTOPS, Z_STEPPER_AUTO_ALIGN)
       FORCE_INLINE static void set_z_lock(const bool state) { locked_Z_motor = state; }
       FORCE_INLINE static void set_z2_lock(const bool state) { locked_Z2_motor = state; }
-    #endif
-    #if ENABLED(Z_TRIPLE_ENDSTOPS) || BOTH(Z_STEPPER_AUTO_ALIGN, Z_TRIPLE_STEPPER_DRIVERS)
-      FORCE_INLINE static void set_z3_lock(const bool state) { locked_Z3_motor = state; }
+      #if NUM_Z_STEPPER_DRIVERS >= 3
+        FORCE_INLINE static void set_z3_lock(const bool state) { locked_Z3_motor = state; }
+        #if NUM_Z_STEPPER_DRIVERS >= 4
+          FORCE_INLINE static void set_z4_lock(const bool state) { locked_Z4_motor = state; }
+        #endif
+      #endif
     #endif
 
     #if ENABLED(BABYSTEPPING)
       static void babystep(const AxisEnum axis, const bool direction); // perform a short step with a single stepper motor, outside of any convention
     #endif
 
     #if HAS_MOTOR_CURRENT_PWM
       static void refresh_motor_power();
     #endif
 

commit a2cda631d920547bd8b2d4c919b6a6e19e05b824
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jan 2 16:33:50 2020 -0600

    Clean up trailing whitespace

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 4a686d6f7c..149a211638 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -60,21 +60,21 @@
  * The method of calculating these cycle-constants is unclear.
  * Most of them are no longer used directly for pulse timing, and exist
  * only to estimate a maximum step rate based on the user's configuration.
  * As 32-bit processors continue to diverge, maintaining cycle counts
  * will become increasingly difficult and error-prone.
  */
 
 #ifdef CPU_32_BIT
   /**
    * Duration of START_TIMED_PULSE
-   * 
+   *
    * ...as measured on an LPC1768 with a scope and converted to cycles.
    * Not applicable to other 32-bit processors, but as long as others
    * take longer, pulses will be longer. For example the SKR Pro
    * (stm32f407zgt6) requires ~60 cyles.
    */
   #define TIMER_READ_ADD_AND_STORE_CYCLES 34UL
 
   // The base ISR takes 792 cycles
   #define ISR_BASE_CYCLES  792UL
 

commit d5bc5547eeaff6dd179b4695526897174119ecc9
Author: Jason Smith <jason.inet@gmail.com>
Date:   Sat Dec 21 16:36:25 2019 -0800

    Step timing cleanup and rounding fix (#16258)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index b3749d94d3..4a686d6f7c 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -49,21 +49,37 @@
   #include "speed_lookuptable.h"
 #endif
 
 // Disable multiple steps per ISR
 //#define DISABLE_MULTI_STEPPING
 
 //
 // Estimate the amount of time the Stepper ISR will take to execute
 //
 
+/**
+ * The method of calculating these cycle-constants is unclear.
+ * Most of them are no longer used directly for pulse timing, and exist
+ * only to estimate a maximum step rate based on the user's configuration.
+ * As 32-bit processors continue to diverge, maintaining cycle counts
+ * will become increasingly difficult and error-prone.
+ */
+
 #ifdef CPU_32_BIT
+  /**
+   * Duration of START_TIMED_PULSE
+   * 
+   * ...as measured on an LPC1768 with a scope and converted to cycles.
+   * Not applicable to other 32-bit processors, but as long as others
+   * take longer, pulses will be longer. For example the SKR Pro
+   * (stm32f407zgt6) requires ~60 cyles.
+   */
   #define TIMER_READ_ADD_AND_STORE_CYCLES 34UL
 
   // The base ISR takes 792 cycles
   #define ISR_BASE_CYCLES  792UL
 
   // Linear advance base time is 64 cycles
   #if ENABLED(LIN_ADVANCE)
     #define ISR_LA_BASE_CYCLES 64UL
   #else
     #define ISR_LA_BASE_CYCLES 0UL
@@ -79,20 +95,21 @@
   // Stepper Loop base cycles
   #define ISR_LOOP_BASE_CYCLES 4UL
 
   // To start the step pulse, in the worst case takes
   #define ISR_START_STEPPER_CYCLES 13UL
 
   // And each stepper (start + stop pulse) takes in worst case
   #define ISR_STEPPER_CYCLES 16UL
 
 #else
+  // Cycles to perform actions in START_TIMED_PULSE
   #define TIMER_READ_ADD_AND_STORE_CYCLES 13UL
 
   // The base ISR takes 752 cycles
   #define ISR_BASE_CYCLES  752UL
 
   // Linear advance base time is 32 cycles
   #if ENABLED(LIN_ADVANCE)
     #define ISR_LA_BASE_CYCLES 32UL
   #else
     #define ISR_LA_BASE_CYCLES 0UL
@@ -150,46 +167,37 @@
 // Calculate the minimum MPU cycles needed per pulse to enforce, limited to the max stepper rate
 #define _MIN_STEPPER_PULSE_CYCLES(N) _MAX(uint32_t((F_CPU) / (MAXIMUM_STEPPER_RATE)), ((F_CPU) / 500000UL) * (N))
 #if MINIMUM_STEPPER_PULSE
   #define MIN_STEPPER_PULSE_CYCLES _MIN_STEPPER_PULSE_CYCLES(uint32_t(MINIMUM_STEPPER_PULSE))
 #elif HAS_DRIVER(LV8729)
   #define MIN_STEPPER_PULSE_CYCLES uint32_t((((F_CPU) - 1) / 2000000) + 1) // 0.5¬µs, aka 500ns
 #else
   #define MIN_STEPPER_PULSE_CYCLES _MIN_STEPPER_PULSE_CYCLES(1UL)
 #endif
 
-// Calculate the minimum ticks of the PULSE timer that must elapse with the step pulse enabled
-// adding the "start stepper pulse" code section execution cycles to account for that not all
-// pulses start at the beginning of the loop, so an extra time must be added to compensate so
-// the last generated pulse (usually the extruder stepper) has the right length
+// Calculate the minimum pulse times (high and low)
 #if MINIMUM_STEPPER_PULSE && MAXIMUM_STEPPER_RATE
   constexpr uint32_t _MIN_STEP_PERIOD_NS = 1000000000UL / MAXIMUM_STEPPER_RATE;
   constexpr uint32_t _MIN_PULSE_HIGH_NS = 1000UL * MINIMUM_STEPPER_PULSE;
   constexpr uint32_t _MIN_PULSE_LOW_NS = _MAX((_MIN_STEP_PERIOD_NS - _MIN(_MIN_STEP_PERIOD_NS, _MIN_PULSE_HIGH_NS)), _MIN_PULSE_HIGH_NS);
 #elif MINIMUM_STEPPER_PULSE
   // Assume 50% duty cycle
-  constexpr uint32_t _MIN_STEP_PERIOD_NS = 1000000000UL / MAXIMUM_STEPPER_RATE;
   constexpr uint32_t _MIN_PULSE_HIGH_NS = 1000UL * MINIMUM_STEPPER_PULSE;
   constexpr uint32_t _MIN_PULSE_LOW_NS = _MIN_PULSE_HIGH_NS;
 #elif MAXIMUM_STEPPER_RATE
   // Assume 50% duty cycle
   constexpr uint32_t _MIN_PULSE_HIGH_NS = 500000000UL / MAXIMUM_STEPPER_RATE;
   constexpr uint32_t _MIN_PULSE_LOW_NS = _MIN_PULSE_HIGH_NS;
 #else
   #error "Expected at least one of MINIMUM_STEPPER_PULSE or MAXIMUM_STEPPER_RATE to be defined"
 #endif
 
-// TODO: NS_TO_PULSE_TIMER_TICKS has some rounding issues:
-//   1. PULSE_TIMER_TICKS_PER_US rounds to an integer, which loses 20% of the count for a 2.5 MHz pulse tick (such as for LPC1768)
-//   2. The math currently rounds down to the closes tick. Perhaps should round up.
-constexpr uint32_t NS_TO_PULSE_TIMER_TICKS(uint32_t NS) { return PULSE_TIMER_TICKS_PER_US * (NS) / 1000UL; }
-#define CYCLES_TO_NS(CYC) (1000UL * (CYC) / ((F_CPU) / 1000000))
 
 // But the user could be enforcing a minimum time, so the loop time is
 #define ISR_LOOP_CYCLES (ISR_LOOP_BASE_CYCLES + _MAX(MIN_STEPPER_PULSE_CYCLES, MIN_ISR_LOOP_CYCLES))
 
 // If linear advance is enabled, then it is handled separately
 #if ENABLED(LIN_ADVANCE)
 
   // Estimate the minimum LA loop time
   #if ENABLED(MIXING_EXTRUDER) // ToDo: ???
     // HELP ME: What is what?

commit 1bad8f1b172d8074272e5bae78a356e3671f7b50
Author: Jason Smith <jason.inet@gmail.com>
Date:   Thu Dec 19 00:38:48 2019 -0800

    Improve pulse timing and step reliability (#16128)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 1ab455bd06..b3749d94d3 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -50,20 +50,21 @@
 #endif
 
 // Disable multiple steps per ISR
 //#define DISABLE_MULTI_STEPPING
 
 //
 // Estimate the amount of time the Stepper ISR will take to execute
 //
 
 #ifdef CPU_32_BIT
+  #define TIMER_READ_ADD_AND_STORE_CYCLES 34UL
 
   // The base ISR takes 792 cycles
   #define ISR_BASE_CYCLES  792UL
 
   // Linear advance base time is 64 cycles
   #if ENABLED(LIN_ADVANCE)
     #define ISR_LA_BASE_CYCLES 64UL
   #else
     #define ISR_LA_BASE_CYCLES 0UL
   #endif
@@ -78,20 +79,21 @@
   // Stepper Loop base cycles
   #define ISR_LOOP_BASE_CYCLES 4UL
 
   // To start the step pulse, in the worst case takes
   #define ISR_START_STEPPER_CYCLES 13UL
 
   // And each stepper (start + stop pulse) takes in worst case
   #define ISR_STEPPER_CYCLES 16UL
 
 #else
+  #define TIMER_READ_ADD_AND_STORE_CYCLES 13UL
 
   // The base ISR takes 752 cycles
   #define ISR_BASE_CYCLES  752UL
 
   // Linear advance base time is 32 cycles
   #if ENABLED(LIN_ADVANCE)
     #define ISR_LA_BASE_CYCLES 32UL
   #else
     #define ISR_LA_BASE_CYCLES 0UL
   #endif
@@ -109,82 +111,85 @@
   // To start the step pulse, in the worst case takes
   #define ISR_START_STEPPER_CYCLES 57UL
 
   // And each stepper (start + stop pulse) takes in worst case
   #define ISR_STEPPER_CYCLES 88UL
 
 #endif
 
 // Add time for each stepper
 #if HAS_X_STEP
-  #define ISR_START_X_STEPPER_CYCLES ISR_START_STEPPER_CYCLES
   #define ISR_X_STEPPER_CYCLES       ISR_STEPPER_CYCLES
 #else
-  #define ISR_START_X_STEPPER_CYCLES 0UL
   #define ISR_X_STEPPER_CYCLES       0UL
 #endif
 #if HAS_Y_STEP
-  #define ISR_START_Y_STEPPER_CYCLES ISR_START_STEPPER_CYCLES
   #define ISR_Y_STEPPER_CYCLES       ISR_STEPPER_CYCLES
 #else
   #define ISR_START_Y_STEPPER_CYCLES 0UL
   #define ISR_Y_STEPPER_CYCLES       0UL
 #endif
 #if HAS_Z_STEP
-  #define ISR_START_Z_STEPPER_CYCLES ISR_START_STEPPER_CYCLES
   #define ISR_Z_STEPPER_CYCLES       ISR_STEPPER_CYCLES
 #else
-  #define ISR_START_Z_STEPPER_CYCLES 0UL
   #define ISR_Z_STEPPER_CYCLES       0UL
 #endif
 
 // E is always interpolated, even for mixing extruders
-#define ISR_START_E_STEPPER_CYCLES   ISR_START_STEPPER_CYCLES
 #define ISR_E_STEPPER_CYCLES         ISR_STEPPER_CYCLES
 
 // If linear advance is disabled, the loop also handles them
 #if DISABLED(LIN_ADVANCE) && ENABLED(MIXING_EXTRUDER)
-  #define ISR_START_MIXING_STEPPER_CYCLES ((MIXING_STEPPERS) * (ISR_START_STEPPER_CYCLES))
   #define ISR_MIXING_STEPPER_CYCLES ((MIXING_STEPPERS) * (ISR_STEPPER_CYCLES))
 #else
-  #define ISR_START_MIXING_STEPPER_CYCLES 0UL
   #define ISR_MIXING_STEPPER_CYCLES  0UL
 #endif
 
-// Calculate the minimum time to start all stepper pulses in the ISR loop
-#define MIN_ISR_START_LOOP_CYCLES (ISR_START_X_STEPPER_CYCLES + ISR_START_Y_STEPPER_CYCLES + ISR_START_Z_STEPPER_CYCLES + ISR_START_E_STEPPER_CYCLES + ISR_START_MIXING_STEPPER_CYCLES)
-
 // And the total minimum loop time, not including the base
 #define MIN_ISR_LOOP_CYCLES (ISR_X_STEPPER_CYCLES + ISR_Y_STEPPER_CYCLES + ISR_Z_STEPPER_CYCLES + ISR_E_STEPPER_CYCLES + ISR_MIXING_STEPPER_CYCLES)
 
 // Calculate the minimum MPU cycles needed per pulse to enforce, limited to the max stepper rate
 #define _MIN_STEPPER_PULSE_CYCLES(N) _MAX(uint32_t((F_CPU) / (MAXIMUM_STEPPER_RATE)), ((F_CPU) / 500000UL) * (N))
 #if MINIMUM_STEPPER_PULSE
   #define MIN_STEPPER_PULSE_CYCLES _MIN_STEPPER_PULSE_CYCLES(uint32_t(MINIMUM_STEPPER_PULSE))
 #elif HAS_DRIVER(LV8729)
   #define MIN_STEPPER_PULSE_CYCLES uint32_t((((F_CPU) - 1) / 2000000) + 1) // 0.5¬µs, aka 500ns
 #else
   #define MIN_STEPPER_PULSE_CYCLES _MIN_STEPPER_PULSE_CYCLES(1UL)
 #endif
 
 // Calculate the minimum ticks of the PULSE timer that must elapse with the step pulse enabled
 // adding the "start stepper pulse" code section execution cycles to account for that not all
 // pulses start at the beginning of the loop, so an extra time must be added to compensate so
 // the last generated pulse (usually the extruder stepper) has the right length
-#if HAS_DRIVER(LV8729) && MINIMUM_STEPPER_PULSE == 0
-  #define MIN_PULSE_TICKS ((((PULSE_TIMER_TICKS_PER_US) + 1) / 2) + ((MIN_ISR_START_LOOP_CYCLES) / uint32_t(PULSE_TIMER_PRESCALE)))
+#if MINIMUM_STEPPER_PULSE && MAXIMUM_STEPPER_RATE
+  constexpr uint32_t _MIN_STEP_PERIOD_NS = 1000000000UL / MAXIMUM_STEPPER_RATE;
+  constexpr uint32_t _MIN_PULSE_HIGH_NS = 1000UL * MINIMUM_STEPPER_PULSE;
+  constexpr uint32_t _MIN_PULSE_LOW_NS = _MAX((_MIN_STEP_PERIOD_NS - _MIN(_MIN_STEP_PERIOD_NS, _MIN_PULSE_HIGH_NS)), _MIN_PULSE_HIGH_NS);
+#elif MINIMUM_STEPPER_PULSE
+  // Assume 50% duty cycle
+  constexpr uint32_t _MIN_STEP_PERIOD_NS = 1000000000UL / MAXIMUM_STEPPER_RATE;
+  constexpr uint32_t _MIN_PULSE_HIGH_NS = 1000UL * MINIMUM_STEPPER_PULSE;
+  constexpr uint32_t _MIN_PULSE_LOW_NS = _MIN_PULSE_HIGH_NS;
+#elif MAXIMUM_STEPPER_RATE
+  // Assume 50% duty cycle
+  constexpr uint32_t _MIN_PULSE_HIGH_NS = 500000000UL / MAXIMUM_STEPPER_RATE;
+  constexpr uint32_t _MIN_PULSE_LOW_NS = _MIN_PULSE_HIGH_NS;
 #else
-  #define MIN_PULSE_TICKS (((PULSE_TIMER_TICKS_PER_US) * uint32_t(MINIMUM_STEPPER_PULSE)) + ((MIN_ISR_START_LOOP_CYCLES) / uint32_t(PULSE_TIMER_PRESCALE)))
+  #error "Expected at least one of MINIMUM_STEPPER_PULSE or MAXIMUM_STEPPER_RATE to be defined"
 #endif
 
-// Calculate the extra ticks of the PULSE timer between step pulses
-#define ADDED_STEP_TICKS (((MIN_STEPPER_PULSE_CYCLES) / (PULSE_TIMER_PRESCALE)) - (MIN_PULSE_TICKS))
+// TODO: NS_TO_PULSE_TIMER_TICKS has some rounding issues:
+//   1. PULSE_TIMER_TICKS_PER_US rounds to an integer, which loses 20% of the count for a 2.5 MHz pulse tick (such as for LPC1768)
+//   2. The math currently rounds down to the closes tick. Perhaps should round up.
+constexpr uint32_t NS_TO_PULSE_TIMER_TICKS(uint32_t NS) { return PULSE_TIMER_TICKS_PER_US * (NS) / 1000UL; }
+#define CYCLES_TO_NS(CYC) (1000UL * (CYC) / ((F_CPU) / 1000000))
 
 // But the user could be enforcing a minimum time, so the loop time is
 #define ISR_LOOP_CYCLES (ISR_LOOP_BASE_CYCLES + _MAX(MIN_STEPPER_PULSE_CYCLES, MIN_ISR_LOOP_CYCLES))
 
 // If linear advance is enabled, then it is handled separately
 #if ENABLED(LIN_ADVANCE)
 
   // Estimate the minimum LA loop time
   #if ENABLED(MIXING_EXTRUDER) // ToDo: ???
     // HELP ME: What is what?

commit e3fd0519b323182a3d096eca8209c4eaf56b6802
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 30 21:44:07 2019 -0500

    Reduce need for UNUSED

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 839a9a9d5e..1ab455bd06 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -330,21 +330,21 @@ class Stepper {
     //
     // Current direction of stepper motors (+1 or -1)
     //
     static xyze_int8_t count_direction;
 
   public:
 
     //
     // Constructor / initializer
     //
-    Stepper() { };
+    Stepper() {};
 
     // Initialize stepper hardware
     static void init();
 
     // Interrupt Service Routines
 
     // The ISR scheduler
     static void isr();
 
     // The stepper pulse phase ISR

commit 50e4545255605eb506c20eb107270038b0fe7bdb
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Sep 29 04:25:39 2019 -0500

    Add custom types for position (#15204)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index d098dd4484..839a9a9d5e 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -271,23 +271,23 @@ class Stepper {
     static uint32_t acceleration_time, deceleration_time; // time measured in Stepper Timer ticks
     static uint8_t steps_per_isr;         // Count of steps to perform per Stepper ISR call
 
     #if ENABLED(ADAPTIVE_STEP_SMOOTHING)
       static uint8_t oversampling_factor; // Oversampling factor (log2(multiplier)) to increase temporal resolution of axis
     #else
       static constexpr uint8_t oversampling_factor = 0;
     #endif
 
     // Delta error variables for the Bresenham line tracer
-    static int32_t delta_error[XYZE];
-    static uint32_t advance_dividend[XYZE],
-                    advance_divisor,
+    static xyze_long_t delta_error;
+    static xyze_ulong_t advance_dividend;
+    static uint32_t advance_divisor,
                     step_events_completed,  // The number of step events executed in the current block
                     accelerate_until,       // The point from where we need to stop acceleration
                     decelerate_after,       // The point from where we need to start decelerating
                     step_event_count;       // The total event count for the current block
 
     #if EXTRUDERS > 1 || ENABLED(MIXING_EXTRUDER)
       static uint8_t stepper_extruder;
     #else
       static constexpr uint8_t stepper_extruder = 0;
     #endif
@@ -313,31 +313,31 @@ class Stepper {
     #endif // LIN_ADVANCE
 
     static int32_t ticks_nominal;
     #if DISABLED(S_CURVE_ACCELERATION)
       static uint32_t acc_step_rate; // needed for deceleration start point
     #endif
 
     //
     // Exact steps at which an endstop was triggered
     //
-    static volatile int32_t endstops_trigsteps[XYZ];
+    static xyz_long_t endstops_trigsteps;
 
     //
     // Positions of stepper motors, in step units
     //
-    static volatile int32_t count_position[NUM_AXIS];
+    static xyze_long_t count_position;
 
     //
     // Current direction of stepper motors (+1 or -1)
     //
-    static int8_t count_direction[NUM_AXIS];
+    static xyze_int8_t count_direction;
 
   public:
 
     //
     // Constructor / initializer
     //
     Stepper() { };
 
     // Initialize stepper hardware
     static void init();
@@ -375,27 +375,25 @@ class Stepper {
     FORCE_INLINE static void quick_stop() { abort_current_block = true; }
 
     // The direction of a single motor
     FORCE_INLINE static bool motor_direction(const AxisEnum axis) { return TEST(last_direction_bits, axis); }
 
     // The last movement direction was not null on the specified axis. Note that motor direction is not necessarily the same.
     FORCE_INLINE static bool axis_is_moving(const AxisEnum axis) { return TEST(axis_did_move, axis); }
 
     // The extruder associated to the last movement
     FORCE_INLINE static uint8_t movement_extruder() {
-      return
-        #if ENABLED(MIXING_EXTRUDER) || EXTRUDERS < 2
-          0
-        #else
-          last_moved_extruder
+      return (0
+        #if EXTRUDERS > 1 && DISABLED(MIXING_EXTRUDER)
+          + last_moved_extruder
         #endif
-      ;
+      );
     }
 
     // Handle a triggered endstop
     static void endstop_triggered(const AxisEnum axis);
 
     // Triggered position of an axis in steps
     static int32_t triggered_position(const AxisEnum axis);
 
     #if HAS_DIGIPOTSS || HAS_MOTOR_CURRENT_PWM
       static void digitalPotWrite(const int16_t address, const int16_t value);
@@ -436,22 +434,23 @@ class Stepper {
     #endif
 
     // Set the current position in steps
     static inline void set_position(const int32_t &a, const int32_t &b, const int32_t &c, const int32_t &e) {
       planner.synchronize();
       const bool was_enabled = STEPPER_ISR_ENABLED();
       if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
       _set_position(a, b, c, e);
       if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
     }
+    static inline void set_position(const xyze_long_t &abce) { set_position(abce.a, abce.b, abce.c, abce.e); }
 
-    static inline void set_position(const AxisEnum a, const int32_t &v) {
+    static inline void set_axis_position(const AxisEnum a, const int32_t &v) {
       planner.synchronize();
 
       #ifdef __AVR__
         // Protect the access to the position. Only required for AVR, as
         //  any 32bit CPU offers atomic access to 32bit variables
         const bool was_enabled = STEPPER_ISR_ENABLED();
         if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
       #endif
 
       count_position[a] = v;
@@ -462,20 +461,21 @@ class Stepper {
       #endif
     }
 
     // Set direction bits for all steppers
     static void set_directions();
 
   private:
 
     // Set the current position in steps
     static void _set_position(const int32_t &a, const int32_t &b, const int32_t &c, const int32_t &e);
+    FORCE_INLINE static void _set_position(const abce_long_t &spos) { _set_position(spos.a, spos.b, spos.c, spos.e); }
 
     FORCE_INLINE static uint32_t calc_timer_interval(uint32_t step_rate, uint8_t scale, uint8_t* loops) {
       uint32_t timer;
 
       // Scale the frequency, as requested by the caller
       step_rate <<= scale;
 
       uint8_t multistep = 1;
       #if DISABLED(DISABLE_MULTI_STEPPING)
 

commit d63e0f6d986391ab6965665170bbfea53c876642
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Sep 16 15:01:46 2019 -0500

    Pending refactor tweaks

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index c200787d76..d098dd4484 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -36,20 +36,26 @@
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with Grbl.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #include "../inc/MarlinConfig.h"
 
+#include "planner.h"
+#include "stepper/indirection.h"
+#ifdef __AVR__
+  #include "speed_lookuptable.h"
+#endif
+
 // Disable multiple steps per ISR
 //#define DISABLE_MULTI_STEPPING
 
 //
 // Estimate the amount of time the Stepper ISR will take to execute
 //
 
 #ifdef CPU_32_BIT
 
   // The base ISR takes 792 cycles
@@ -210,30 +216,20 @@
 #define MAX_STEP_ISR_FREQUENCY_4X   ((F_CPU) / ISR_EXECUTION_CYCLES(4))
 #define MAX_STEP_ISR_FREQUENCY_2X   ((F_CPU) / ISR_EXECUTION_CYCLES(2))
 #define MAX_STEP_ISR_FREQUENCY_1X   ((F_CPU) / ISR_EXECUTION_CYCLES(1))
 
 // The minimum allowable frequency for step smoothing will be 1/10 of the maximum nominal frequency (in Hz)
 #define MIN_STEP_ISR_FREQUENCY MAX_STEP_ISR_FREQUENCY_1X
 
 //
 // Stepper class definition
 //
-
-#include "stepper/indirection.h"
-
-#ifdef __AVR__
-  #include "speed_lookuptable.h"
-#endif
-
-#include "planner.h"
-#include "../core/language.h"
-
 class Stepper {
 
   public:
 
     #if HAS_EXTRA_ENDSTOPS || ENABLED(Z_STEPPER_AUTO_ALIGN)
       static bool separate_multi_axis;
     #endif
 
     #if HAS_MOTOR_CURRENT_PWM
       #ifndef PWM_MOTOR_CURRENT

commit 465c6d92307ec613d0b2a7355ce67a60ba23fc0c
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Sep 14 03:05:10 2019 -0500

    Simpler Allen Key config. Fixes, cleanups from refactor (#15256)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index c766054b29..c200787d76 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -314,20 +314,23 @@ class Stepper {
       static uint16_t LA_current_adv_steps, LA_final_adv_steps, LA_max_adv_steps; // Copy from current executed block. Needed because current_block is set to NULL "too early".
       static int8_t LA_steps;
       static bool LA_use_advance_lead;
     #endif // LIN_ADVANCE
 
     static int32_t ticks_nominal;
     #if DISABLED(S_CURVE_ACCELERATION)
       static uint32_t acc_step_rate; // needed for deceleration start point
     #endif
 
+    //
+    // Exact steps at which an endstop was triggered
+    //
     static volatile int32_t endstops_trigsteps[XYZ];
 
     //
     // Positions of stepper motors, in step units
     //
     static volatile int32_t count_position[NUM_AXIS];
 
     //
     // Current direction of stepper motors (+1 or -1)
     //

commit 123ecfe6134df4d36faca839a01d8752b75ad92e
Author: Karl Andersson <karl@iaccess.se>
Date:   Wed Sep 4 23:57:13 2019 +0200

    Allow MINIMUM_STEPPER_PULSE override with LV8729 (#15162)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index e1d60fffce..c766054b29 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -157,21 +157,21 @@
 #elif HAS_DRIVER(LV8729)
   #define MIN_STEPPER_PULSE_CYCLES uint32_t((((F_CPU) - 1) / 2000000) + 1) // 0.5¬µs, aka 500ns
 #else
   #define MIN_STEPPER_PULSE_CYCLES _MIN_STEPPER_PULSE_CYCLES(1UL)
 #endif
 
 // Calculate the minimum ticks of the PULSE timer that must elapse with the step pulse enabled
 // adding the "start stepper pulse" code section execution cycles to account for that not all
 // pulses start at the beginning of the loop, so an extra time must be added to compensate so
 // the last generated pulse (usually the extruder stepper) has the right length
-#if HAS_DRIVER(LV8729)
+#if HAS_DRIVER(LV8729) && MINIMUM_STEPPER_PULSE == 0
   #define MIN_PULSE_TICKS ((((PULSE_TIMER_TICKS_PER_US) + 1) / 2) + ((MIN_ISR_START_LOOP_CYCLES) / uint32_t(PULSE_TIMER_PRESCALE)))
 #else
   #define MIN_PULSE_TICKS (((PULSE_TIMER_TICKS_PER_US) * uint32_t(MINIMUM_STEPPER_PULSE)) + ((MIN_ISR_START_LOOP_CYCLES) / uint32_t(PULSE_TIMER_PRESCALE)))
 #endif
 
 // Calculate the extra ticks of the PULSE timer between step pulses
 #define ADDED_STEP_TICKS (((MIN_STEPPER_PULSE_CYCLES) / (PULSE_TIMER_PRESCALE)) - (MIN_PULSE_TICKS))
 
 // But the user could be enforcing a minimum time, so the loop time is
 #define ISR_LOOP_CYCLES (ISR_LOOP_BASE_CYCLES + _MAX(MIN_STEPPER_PULSE_CYCLES, MIN_ISR_LOOP_CYCLES))

commit 586b334c2ab61240607e878390ed1d53af86da69
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Aug 31 19:44:45 2019 -0500

    Split up stepper indirection (#15111)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index eca4a75c17..e1d60fffce 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -211,21 +211,21 @@
 #define MAX_STEP_ISR_FREQUENCY_2X   ((F_CPU) / ISR_EXECUTION_CYCLES(2))
 #define MAX_STEP_ISR_FREQUENCY_1X   ((F_CPU) / ISR_EXECUTION_CYCLES(1))
 
 // The minimum allowable frequency for step smoothing will be 1/10 of the maximum nominal frequency (in Hz)
 #define MIN_STEP_ISR_FREQUENCY MAX_STEP_ISR_FREQUENCY_1X
 
 //
 // Stepper class definition
 //
 
-#include "stepper_indirection.h"
+#include "stepper/indirection.h"
 
 #ifdef __AVR__
   #include "speed_lookuptable.h"
 #endif
 
 #include "planner.h"
 #include "../core/language.h"
 
 class Stepper {
 

commit 750a16ad385dca893d482cb51d8af2ac3f8a1da1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Jul 5 18:01:21 2019 -0500

    Fix MIN/MAX function collision with macros

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 7e8b9c5e0d..eca4a75c17 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -144,21 +144,21 @@
   #define ISR_MIXING_STEPPER_CYCLES  0UL
 #endif
 
 // Calculate the minimum time to start all stepper pulses in the ISR loop
 #define MIN_ISR_START_LOOP_CYCLES (ISR_START_X_STEPPER_CYCLES + ISR_START_Y_STEPPER_CYCLES + ISR_START_Z_STEPPER_CYCLES + ISR_START_E_STEPPER_CYCLES + ISR_START_MIXING_STEPPER_CYCLES)
 
 // And the total minimum loop time, not including the base
 #define MIN_ISR_LOOP_CYCLES (ISR_X_STEPPER_CYCLES + ISR_Y_STEPPER_CYCLES + ISR_Z_STEPPER_CYCLES + ISR_E_STEPPER_CYCLES + ISR_MIXING_STEPPER_CYCLES)
 
 // Calculate the minimum MPU cycles needed per pulse to enforce, limited to the max stepper rate
-#define _MIN_STEPPER_PULSE_CYCLES(N) MAX(uint32_t((F_CPU) / (MAXIMUM_STEPPER_RATE)), ((F_CPU) / 500000UL) * (N))
+#define _MIN_STEPPER_PULSE_CYCLES(N) _MAX(uint32_t((F_CPU) / (MAXIMUM_STEPPER_RATE)), ((F_CPU) / 500000UL) * (N))
 #if MINIMUM_STEPPER_PULSE
   #define MIN_STEPPER_PULSE_CYCLES _MIN_STEPPER_PULSE_CYCLES(uint32_t(MINIMUM_STEPPER_PULSE))
 #elif HAS_DRIVER(LV8729)
   #define MIN_STEPPER_PULSE_CYCLES uint32_t((((F_CPU) - 1) / 2000000) + 1) // 0.5¬µs, aka 500ns
 #else
   #define MIN_STEPPER_PULSE_CYCLES _MIN_STEPPER_PULSE_CYCLES(1UL)
 #endif
 
 // Calculate the minimum ticks of the PULSE timer that must elapse with the step pulse enabled
 // adding the "start stepper pulse" code section execution cycles to account for that not all
@@ -167,39 +167,39 @@
 #if HAS_DRIVER(LV8729)
   #define MIN_PULSE_TICKS ((((PULSE_TIMER_TICKS_PER_US) + 1) / 2) + ((MIN_ISR_START_LOOP_CYCLES) / uint32_t(PULSE_TIMER_PRESCALE)))
 #else
   #define MIN_PULSE_TICKS (((PULSE_TIMER_TICKS_PER_US) * uint32_t(MINIMUM_STEPPER_PULSE)) + ((MIN_ISR_START_LOOP_CYCLES) / uint32_t(PULSE_TIMER_PRESCALE)))
 #endif
 
 // Calculate the extra ticks of the PULSE timer between step pulses
 #define ADDED_STEP_TICKS (((MIN_STEPPER_PULSE_CYCLES) / (PULSE_TIMER_PRESCALE)) - (MIN_PULSE_TICKS))
 
 // But the user could be enforcing a minimum time, so the loop time is
-#define ISR_LOOP_CYCLES (ISR_LOOP_BASE_CYCLES + MAX(MIN_STEPPER_PULSE_CYCLES, MIN_ISR_LOOP_CYCLES))
+#define ISR_LOOP_CYCLES (ISR_LOOP_BASE_CYCLES + _MAX(MIN_STEPPER_PULSE_CYCLES, MIN_ISR_LOOP_CYCLES))
 
 // If linear advance is enabled, then it is handled separately
 #if ENABLED(LIN_ADVANCE)
 
   // Estimate the minimum LA loop time
   #if ENABLED(MIXING_EXTRUDER) // ToDo: ???
     // HELP ME: What is what?
     // Directions are set up for MIXING_STEPPERS - like before.
     // Finding the right stepper may last up to MIXING_STEPPERS loops in get_next_stepper().
     //   These loops are a bit faster than advancing a bresenham counter.
     // Always only one e-stepper is stepped.
     #define MIN_ISR_LA_LOOP_CYCLES ((MIXING_STEPPERS) * (ISR_STEPPER_CYCLES))
   #else
     #define MIN_ISR_LA_LOOP_CYCLES ISR_STEPPER_CYCLES
   #endif
 
   // And the real loop time
-  #define ISR_LA_LOOP_CYCLES MAX(MIN_STEPPER_PULSE_CYCLES, MIN_ISR_LA_LOOP_CYCLES)
+  #define ISR_LA_LOOP_CYCLES _MAX(MIN_STEPPER_PULSE_CYCLES, MIN_ISR_LA_LOOP_CYCLES)
 
 #else
   #define ISR_LA_LOOP_CYCLES 0UL
 #endif
 
 // Now estimate the total ISR execution time in cycles given a step per ISR multiplier
 #define ISR_EXECUTION_CYCLES(R) (((ISR_BASE_CYCLES + ISR_S_CURVE_CYCLES + (ISR_LOOP_CYCLES) * (R) + ISR_LA_BASE_CYCLES + ISR_LA_LOOP_CYCLES)) / (R))
 
 // The maximum allowable stepping frequency when doing x128-x1 stepping (in Hz)
 #define MAX_STEP_ISR_FREQUENCY_128X ((F_CPU) / ISR_EXECUTION_CYCLES(128))

commit 93cd66ac1146603e8a9911fceb3c63f4351f4d8e
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Jun 27 23:57:50 2019 -0500

    Tweaky change from (C) to (c)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 17f78ae1aa..7e8b9c5e0d 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -1,16 +1,16 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (c) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
- * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.

commit 93ab16c6e4bd7768f4d8fab5b8b6e45888917ff1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu May 30 17:05:06 2019 -0500

    Remove old mixing ISR comment

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 2c8c7fc20d..17f78ae1aa 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -128,27 +128,22 @@
   #define ISR_Z_STEPPER_CYCLES       ISR_STEPPER_CYCLES
 #else
   #define ISR_START_Z_STEPPER_CYCLES 0UL
   #define ISR_Z_STEPPER_CYCLES       0UL
 #endif
 
 // E is always interpolated, even for mixing extruders
 #define ISR_START_E_STEPPER_CYCLES   ISR_START_STEPPER_CYCLES
 #define ISR_E_STEPPER_CYCLES         ISR_STEPPER_CYCLES
 
-// If linear advance is disabled, then the loop also handles them
-#if DISABLED(LIN_ADVANCE) && ENABLED(MIXING_EXTRUDER) // ToDo: ???
-  // HELP ME: What is what?
-  // Directions are set up for MIXING_STEPPERS - like before.
-  // Finding the right stepper may last up to MIXING_STEPPERS loops in get_next_stepper().
-  //   These loops are a bit faster than advancing a bresenham counter.
-  // Always only one e-stepper is stepped.
+// If linear advance is disabled, the loop also handles them
+#if DISABLED(LIN_ADVANCE) && ENABLED(MIXING_EXTRUDER)
   #define ISR_START_MIXING_STEPPER_CYCLES ((MIXING_STEPPERS) * (ISR_START_STEPPER_CYCLES))
   #define ISR_MIXING_STEPPER_CYCLES ((MIXING_STEPPERS) * (ISR_STEPPER_CYCLES))
 #else
   #define ISR_START_MIXING_STEPPER_CYCLES 0UL
   #define ISR_MIXING_STEPPER_CYCLES  0UL
 #endif
 
 // Calculate the minimum time to start all stepper pulses in the ISR loop
 #define MIN_ISR_START_LOOP_CYCLES (ISR_START_X_STEPPER_CYCLES + ISR_START_Y_STEPPER_CYCLES + ISR_START_Z_STEPPER_CYCLES + ISR_START_E_STEPPER_CYCLES + ISR_START_MIXING_STEPPER_CYCLES)
 

commit 6572848d7fc5665451a76a3064b198481fc88cc8
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu May 30 16:33:40 2019 -0500

    Fix stepper timing bug

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index b3f53fc4b6..2c8c7fc20d 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -102,35 +102,35 @@
 
   // To start the step pulse, in the worst case takes
   #define ISR_START_STEPPER_CYCLES 57UL
 
   // And each stepper (start + stop pulse) takes in worst case
   #define ISR_STEPPER_CYCLES 88UL
 
 #endif
 
 // Add time for each stepper
-#ifdef HAS_X_STEP
+#if HAS_X_STEP
   #define ISR_START_X_STEPPER_CYCLES ISR_START_STEPPER_CYCLES
   #define ISR_X_STEPPER_CYCLES       ISR_STEPPER_CYCLES
 #else
   #define ISR_START_X_STEPPER_CYCLES 0UL
   #define ISR_X_STEPPER_CYCLES       0UL
 #endif
-#ifdef HAS_Y_STEP
+#if HAS_Y_STEP
   #define ISR_START_Y_STEPPER_CYCLES ISR_START_STEPPER_CYCLES
   #define ISR_Y_STEPPER_CYCLES       ISR_STEPPER_CYCLES
 #else
   #define ISR_START_Y_STEPPER_CYCLES 0UL
   #define ISR_Y_STEPPER_CYCLES       0UL
 #endif
-#ifdef HAS_Z_STEP
+#if HAS_Z_STEP
   #define ISR_START_Z_STEPPER_CYCLES ISR_START_STEPPER_CYCLES
   #define ISR_Z_STEPPER_CYCLES       ISR_STEPPER_CYCLES
 #else
   #define ISR_START_Z_STEPPER_CYCLES 0UL
   #define ISR_Z_STEPPER_CYCLES       0UL
 #endif
 
 // E is always interpolated, even for mixing extruders
 #define ISR_START_E_STEPPER_CYCLES   ISR_START_STEPPER_CYCLES
 #define ISR_E_STEPPER_CYCLES         ISR_STEPPER_CYCLES

commit 940ff8e7c8a5919681dcd6d6e87668381010151a
Author: chai-md <48555545+chai-md@users.noreply.github.com>
Date:   Sun May 12 09:02:19 2019 +0900

    Improve LV8729 stepping (#13776)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 46bc9d706a..b3f53fc4b6 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -149,32 +149,38 @@
   #define ISR_MIXING_STEPPER_CYCLES  0UL
 #endif
 
 // Calculate the minimum time to start all stepper pulses in the ISR loop
 #define MIN_ISR_START_LOOP_CYCLES (ISR_START_X_STEPPER_CYCLES + ISR_START_Y_STEPPER_CYCLES + ISR_START_Z_STEPPER_CYCLES + ISR_START_E_STEPPER_CYCLES + ISR_START_MIXING_STEPPER_CYCLES)
 
 // And the total minimum loop time, not including the base
 #define MIN_ISR_LOOP_CYCLES (ISR_X_STEPPER_CYCLES + ISR_Y_STEPPER_CYCLES + ISR_Z_STEPPER_CYCLES + ISR_E_STEPPER_CYCLES + ISR_MIXING_STEPPER_CYCLES)
 
 // Calculate the minimum MPU cycles needed per pulse to enforce, limited to the max stepper rate
-#define _MIN_STEPPER_PULSE_CYCLES(N) MAX((unsigned long)((F_CPU) / (MAXIMUM_STEPPER_RATE)), ((F_CPU) / 500000UL) * (N))
+#define _MIN_STEPPER_PULSE_CYCLES(N) MAX(uint32_t((F_CPU) / (MAXIMUM_STEPPER_RATE)), ((F_CPU) / 500000UL) * (N))
 #if MINIMUM_STEPPER_PULSE
-  #define MIN_STEPPER_PULSE_CYCLES _MIN_STEPPER_PULSE_CYCLES((unsigned long)(MINIMUM_STEPPER_PULSE))
+  #define MIN_STEPPER_PULSE_CYCLES _MIN_STEPPER_PULSE_CYCLES(uint32_t(MINIMUM_STEPPER_PULSE))
+#elif HAS_DRIVER(LV8729)
+  #define MIN_STEPPER_PULSE_CYCLES uint32_t((((F_CPU) - 1) / 2000000) + 1) // 0.5¬µs, aka 500ns
 #else
   #define MIN_STEPPER_PULSE_CYCLES _MIN_STEPPER_PULSE_CYCLES(1UL)
 #endif
 
 // Calculate the minimum ticks of the PULSE timer that must elapse with the step pulse enabled
 // adding the "start stepper pulse" code section execution cycles to account for that not all
 // pulses start at the beginning of the loop, so an extra time must be added to compensate so
 // the last generated pulse (usually the extruder stepper) has the right length
-#define MIN_PULSE_TICKS (((PULSE_TIMER_TICKS_PER_US) * (unsigned long)(MINIMUM_STEPPER_PULSE)) + ((MIN_ISR_START_LOOP_CYCLES) / (unsigned long)(PULSE_TIMER_PRESCALE)))
+#if HAS_DRIVER(LV8729)
+  #define MIN_PULSE_TICKS ((((PULSE_TIMER_TICKS_PER_US) + 1) / 2) + ((MIN_ISR_START_LOOP_CYCLES) / uint32_t(PULSE_TIMER_PRESCALE)))
+#else
+  #define MIN_PULSE_TICKS (((PULSE_TIMER_TICKS_PER_US) * uint32_t(MINIMUM_STEPPER_PULSE)) + ((MIN_ISR_START_LOOP_CYCLES) / uint32_t(PULSE_TIMER_PRESCALE)))
+#endif
 
 // Calculate the extra ticks of the PULSE timer between step pulses
 #define ADDED_STEP_TICKS (((MIN_STEPPER_PULSE_CYCLES) / (PULSE_TIMER_PRESCALE)) - (MIN_PULSE_TICKS))
 
 // But the user could be enforcing a minimum time, so the loop time is
 #define ISR_LOOP_CYCLES (ISR_LOOP_BASE_CYCLES + MAX(MIN_STEPPER_PULSE_CYCLES, MIN_ISR_LOOP_CYCLES))
 
 // If linear advance is enabled, then it is handled separately
 #if ENABLED(LIN_ADVANCE)
 

commit 49cf92dc36424cf828436f32e72263eca39a1cc3
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Mar 16 23:43:06 2019 -0500

    Extended condition macros (#13419)
    
    Allow `ENABLED`, `DISABLED`, `PIN_EXISTS`, and `BUTTON_EXISTS` to take multiple arguments. Also add:
    - Alias `ANY(...)` for `!DISABLED(...)`
    - Alias `ANY_PIN(...)` for `PIN_EXISTS(a) || PIN_EXISTS(b) ...`
    - Alias `EITHER(A,B)` for `ANY(...)`
    - Alias `ALL(...)` and `BOTH(A,B)` for `ENABLED(...)`
    - `NONE(...)` for `DISABLED(...)`

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 38f17f498c..46bc9d706a 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -260,21 +260,21 @@ class Stepper {
 
     #if ENABLED(X_DUAL_ENDSTOPS)
       static bool locked_X_motor, locked_X2_motor;
     #endif
     #if ENABLED(Y_DUAL_ENDSTOPS)
       static bool locked_Y_motor, locked_Y2_motor;
     #endif
     #if Z_MULTI_ENDSTOPS || ENABLED(Z_STEPPER_AUTO_ALIGN)
       static bool locked_Z_motor, locked_Z2_motor;
     #endif
-    #if ENABLED(Z_TRIPLE_ENDSTOPS) || (ENABLED(Z_STEPPER_AUTO_ALIGN) && ENABLED(Z_TRIPLE_STEPPER_DRIVERS))
+    #if ENABLED(Z_TRIPLE_ENDSTOPS) || BOTH(Z_STEPPER_AUTO_ALIGN, Z_TRIPLE_STEPPER_DRIVERS)
       static bool locked_Z3_motor;
     #endif
 
     static uint32_t acceleration_time, deceleration_time; // time measured in Stepper Timer ticks
     static uint8_t steps_per_isr;         // Count of steps to perform per Stepper ISR call
 
     #if ENABLED(ADAPTIVE_STEP_SMOOTHING)
       static uint8_t oversampling_factor; // Oversampling factor (log2(multiplier)) to increase temporal resolution of axis
     #else
       static constexpr uint8_t oversampling_factor = 0;
@@ -416,21 +416,21 @@ class Stepper {
       FORCE_INLINE static void set_x2_lock(const bool state) { locked_X2_motor = state; }
     #endif
     #if ENABLED(Y_DUAL_ENDSTOPS)
       FORCE_INLINE static void set_y_lock(const bool state) { locked_Y_motor = state; }
       FORCE_INLINE static void set_y2_lock(const bool state) { locked_Y2_motor = state; }
     #endif
     #if Z_MULTI_ENDSTOPS || (ENABLED(Z_STEPPER_AUTO_ALIGN) && Z_MULTI_STEPPER_DRIVERS)
       FORCE_INLINE static void set_z_lock(const bool state) { locked_Z_motor = state; }
       FORCE_INLINE static void set_z2_lock(const bool state) { locked_Z2_motor = state; }
     #endif
-    #if ENABLED(Z_TRIPLE_ENDSTOPS) || (ENABLED(Z_STEPPER_AUTO_ALIGN) && ENABLED(Z_TRIPLE_STEPPER_DRIVERS))
+    #if ENABLED(Z_TRIPLE_ENDSTOPS) || BOTH(Z_STEPPER_AUTO_ALIGN, Z_TRIPLE_STEPPER_DRIVERS)
       FORCE_INLINE static void set_z3_lock(const bool state) { locked_Z3_motor = state; }
     #endif
 
     #if ENABLED(BABYSTEPPING)
       static void babystep(const AxisEnum axis, const bool direction); // perform a short step with a single stepper motor, outside of any convention
     #endif
 
     #if HAS_MOTOR_CURRENT_PWM
       static void refresh_motor_power();
     #endif

commit 71773b128db764afeccb3c782c5a8bdaef175042
Author: Vasily Evseenko <svpcom@gmail.com>
Date:   Sun Mar 3 02:29:02 2019 +0300

    Fix stepper use before init. Add Ultimaker2+ Extended clone config (#13284)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index a3d2bfcd9a..38f17f498c 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -232,20 +232,21 @@ class Stepper {
 
     #if HAS_EXTRA_ENDSTOPS || ENABLED(Z_STEPPER_AUTO_ALIGN)
       static bool separate_multi_axis;
     #endif
 
     #if HAS_MOTOR_CURRENT_PWM
       #ifndef PWM_MOTOR_CURRENT
         #define PWM_MOTOR_CURRENT DEFAULT_PWM_MOTOR_CURRENT
       #endif
       static uint32_t motor_current_setting[3];
+      static bool initialized;
     #endif
 
   private:
 
     static block_t* current_block;          // A pointer to the block currently being traced
 
     static uint8_t last_direction_bits,     // The next stepping-bits to be output
                    axis_did_move;           // Last Movement in the given direction is not null, as computed when the last movement was fetched from planner
 
     static bool abort_current_block;        // Signals to the stepper that current block should be aborted

commit 0feeef26048883640b37ebe3994730f31ef6e922
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Feb 12 15:06:53 2019 -0600

    Update copyright in headers

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index bf009f0d33..a3d2bfcd9a 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -1,13 +1,13 @@
 /**
  * Marlin 3D Printer Firmware
- * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ * Copyright (C) 2019 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
  *
  * Based on Sprinter and grbl.
  * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
  * (at your option) any later version.
  *
  * This program is distributed in the hope that it will be useful,

commit 1bd9a630492e0b029c39e4c885c6a1f49dc0c6ee
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Feb 6 04:59:22 2019 -0600

    Add HAS_EXTRA_ENDSTOPS macro

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index ce7c9d868a..bf009f0d33 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -223,21 +223,21 @@
   #include "speed_lookuptable.h"
 #endif
 
 #include "planner.h"
 #include "../core/language.h"
 
 class Stepper {
 
   public:
 
-    #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS || ENABLED(Z_STEPPER_AUTO_ALIGN)
+    #if HAS_EXTRA_ENDSTOPS || ENABLED(Z_STEPPER_AUTO_ALIGN)
       static bool separate_multi_axis;
     #endif
 
     #if HAS_MOTOR_CURRENT_PWM
       #ifndef PWM_MOTOR_CURRENT
         #define PWM_MOTOR_CURRENT DEFAULT_PWM_MOTOR_CURRENT
       #endif
       static uint32_t motor_current_setting[3];
     #endif
 
@@ -400,21 +400,21 @@ class Stepper {
       static void digitalPotWrite(const int16_t address, const int16_t value);
       static void digipot_current(const uint8_t driver, const int16_t current);
     #endif
 
     #if HAS_MICROSTEPS
       static void microstep_ms(const uint8_t driver, const int8_t ms1, const int8_t ms2, const int8_t ms3);
       static void microstep_mode(const uint8_t driver, const uint8_t stepping);
       static void microstep_readings();
     #endif
 
-    #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS || ENABLED(Z_STEPPER_AUTO_ALIGN)
+    #if HAS_EXTRA_ENDSTOPS || ENABLED(Z_STEPPER_AUTO_ALIGN)
       FORCE_INLINE static void set_separate_multi_axis(const bool state) { separate_multi_axis = state; }
     #endif
     #if ENABLED(X_DUAL_ENDSTOPS)
       FORCE_INLINE static void set_x_lock(const bool state) { locked_X_motor = state; }
       FORCE_INLINE static void set_x2_lock(const bool state) { locked_X2_motor = state; }
     #endif
     #if ENABLED(Y_DUAL_ENDSTOPS)
       FORCE_INLINE static void set_y_lock(const bool state) { locked_Y_motor = state; }
       FORCE_INLINE static void set_y2_lock(const bool state) { locked_Y2_motor = state; }
     #endif

commit d4d1b28a06caa57d26e300c1b814b2b8b62120cd
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Feb 4 03:41:55 2019 -0600

    Fix some include paths

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index ec8df8e949..ce7c9d868a 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -216,21 +216,21 @@
 //
 // Stepper class definition
 //
 
 #include "stepper_indirection.h"
 
 #ifdef __AVR__
   #include "speed_lookuptable.h"
 #endif
 
-#include "../module/planner.h"
+#include "planner.h"
 #include "../core/language.h"
 
 class Stepper {
 
   public:
 
     #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS || ENABLED(Z_STEPPER_AUTO_ALIGN)
       static bool separate_multi_axis;
     #endif
 

commit 95223cb28eb203201b51ca7ee58cf868b2d64d3c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Feb 2 15:34:55 2019 -0600

    Remove dead code from stepper.h
    
    These values are always supplied by `Conditionals_post.h`.

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 5f7cdc54cc..ec8df8e949 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -43,32 +43,20 @@
 
 #include "../inc/MarlinConfig.h"
 
 // Disable multiple steps per ISR
 //#define DISABLE_MULTI_STEPPING
 
 //
 // Estimate the amount of time the Stepper ISR will take to execute
 //
 
-#ifndef MINIMUM_STEPPER_PULSE
-  #define MINIMUM_STEPPER_PULSE 0UL
-#endif
-
-#ifndef MAXIMUM_STEPPER_RATE
-  #if MINIMUM_STEPPER_PULSE
-    #define MAXIMUM_STEPPER_RATE (1000000UL / (2UL * (unsigned long)(MINIMUM_STEPPER_PULSE)))
-  #else
-    #define MAXIMUM_STEPPER_RATE 500000UL
-  #endif
-#endif
-
 #ifdef CPU_32_BIT
 
   // The base ISR takes 792 cycles
   #define ISR_BASE_CYCLES  792UL
 
   // Linear advance base time is 64 cycles
   #if ENABLED(LIN_ADVANCE)
     #define ISR_LA_BASE_CYCLES 64UL
   #else
     #define ISR_LA_BASE_CYCLES 0UL

commit f5eab912ed6d336f2c37a688a0ec822ed3d42fcc
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun Nov 4 02:25:55 2018 -0600

    Apply #pragma once, misc cleanup (#12322)
    
    * Apply #pragma once in headers
    * Adjust some thermistors formatting
    * Misc cleanup and formatting

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 6304b0c503..5f7cdc54cc 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -12,20 +12,21 @@
  *
  * This program is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  *
  */
+#pragma once
 
 /**
  * stepper.h - stepper motor driver: executes motion plans of planner.c using the stepper motors
  * Derived from Grbl
  *
  * Copyright (c) 2009-2011 Simen Svale Skogsrud
  *
  * Grbl is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
@@ -33,23 +34,20 @@
  *
  * Grbl is distributed in the hope that it will be useful,
  * but WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with Grbl.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-#ifndef STEPPER_H
-#define STEPPER_H
-
 #include "../inc/MarlinConfig.h"
 
 // Disable multiple steps per ISR
 //#define DISABLE_MULTI_STEPPING
 
 //
 // Estimate the amount of time the Stepper ISR will take to execute
 //
 
 #ifndef MINIMUM_STEPPER_PULSE
@@ -552,12 +550,10 @@ class Stepper {
       static void digipot_init();
     #endif
 
     #if HAS_MICROSTEPS
       static void microstep_init();
     #endif
 
 };
 
 extern Stepper stepper;
-
-#endif // STEPPER_H

commit 31c28d0dd243331adba3debb4801fbd03f7f6ec2
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Nov 2 00:42:16 2018 -0500

    Drop pgm_read_*_near and let headers choose (#12301)
    
    - Drop `pgm_read_*_near` and let headers choose.
    - Define `USE_EXECUTE_COMMANDS_IMMEDIATE` as a conditional.
    - Add `process_subcommands_now` for SRAM-based commands.

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 9e50d2bd9e..6304b0c503 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -519,29 +519,29 @@ class Stepper {
       #ifdef CPU_32_BIT
         // In case of high-performance processor, it is able to calculate in real-time
         timer = uint32_t(STEPPER_TIMER_RATE) / step_rate;
       #else
         constexpr uint32_t min_step_rate = F_CPU / 500000U;
         NOLESS(step_rate, min_step_rate);
         step_rate -= min_step_rate; // Correct for minimal speed
         if (step_rate >= (8 * 256)) { // higher step rate
           const uint8_t tmp_step_rate = (step_rate & 0x00FF);
           const uint16_t table_address = (uint16_t)&speed_lookuptable_fast[(uint8_t)(step_rate >> 8)][0],
-                         gain = (uint16_t)pgm_read_word_near(table_address + 2);
+                         gain = (uint16_t)pgm_read_word(table_address + 2);
           timer = MultiU16X8toH16(tmp_step_rate, gain);
-          timer = (uint16_t)pgm_read_word_near(table_address) - timer;
+          timer = (uint16_t)pgm_read_word(table_address) - timer;
         }
         else { // lower step rates
           uint16_t table_address = (uint16_t)&speed_lookuptable_slow[0][0];
           table_address += ((step_rate) >> 1) & 0xFFFC;
-          timer = (uint16_t)pgm_read_word_near(table_address)
-                - (((uint16_t)pgm_read_word_near(table_address + 2) * (uint8_t)(step_rate & 0x0007)) >> 3);
+          timer = (uint16_t)pgm_read_word(table_address)
+                - (((uint16_t)pgm_read_word(table_address + 2) * (uint8_t)(step_rate & 0x0007)) >> 3);
         }
         // (there is no need to limit the timer value here. All limits have been
         // applied above, and AVR is able to keep up at 30khz Stepping ISR rate)
       #endif
 
       return timer;
     }
 
     #if ENABLED(S_CURVE_ACCELERATION)
       static void _calc_bezier_curve_coeffs(const int32_t v0, const int32_t v1, const uint32_t av);

commit 553622835911b520c6ba43bc03e71868f3972cb3
Author: TheLongAndOnly <github@mueller-gelff.de>
Date:   Mon Oct 29 20:01:36 2018 +0100

    G34 Auto-align multi-stepper Z axis (#11302)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index b9e7ead995..9e50d2bd9e 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -237,21 +237,21 @@
   #include "speed_lookuptable.h"
 #endif
 
 #include "../module/planner.h"
 #include "../core/language.h"
 
 class Stepper {
 
   public:
 
-    #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
+    #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS || ENABLED(Z_STEPPER_AUTO_ALIGN)
       static bool separate_multi_axis;
     #endif
 
     #if HAS_MOTOR_CURRENT_PWM
       #ifndef PWM_MOTOR_CURRENT
         #define PWM_MOTOR_CURRENT DEFAULT_PWM_MOTOR_CURRENT
       #endif
       static uint32_t motor_current_setting[3];
     #endif
 
@@ -270,24 +270,24 @@ class Stepper {
     #elif DISABLED(MIXING_EXTRUDER)
       static uint8_t last_moved_extruder;
     #endif
 
     #if ENABLED(X_DUAL_ENDSTOPS)
       static bool locked_X_motor, locked_X2_motor;
     #endif
     #if ENABLED(Y_DUAL_ENDSTOPS)
       static bool locked_Y_motor, locked_Y2_motor;
     #endif
-    #if Z_MULTI_ENDSTOPS
+    #if Z_MULTI_ENDSTOPS || ENABLED(Z_STEPPER_AUTO_ALIGN)
       static bool locked_Z_motor, locked_Z2_motor;
     #endif
-    #if ENABLED(Z_TRIPLE_ENDSTOPS)
+    #if ENABLED(Z_TRIPLE_ENDSTOPS) || (ENABLED(Z_STEPPER_AUTO_ALIGN) && ENABLED(Z_TRIPLE_STEPPER_DRIVERS))
       static bool locked_Z3_motor;
     #endif
 
     static uint32_t acceleration_time, deceleration_time; // time measured in Stepper Timer ticks
     static uint8_t steps_per_isr;         // Count of steps to perform per Stepper ISR call
 
     #if ENABLED(ADAPTIVE_STEP_SMOOTHING)
       static uint8_t oversampling_factor; // Oversampling factor (log2(multiplier)) to increase temporal resolution of axis
     #else
       static constexpr uint8_t oversampling_factor = 0;
@@ -414,36 +414,36 @@ class Stepper {
       static void digitalPotWrite(const int16_t address, const int16_t value);
       static void digipot_current(const uint8_t driver, const int16_t current);
     #endif
 
     #if HAS_MICROSTEPS
       static void microstep_ms(const uint8_t driver, const int8_t ms1, const int8_t ms2, const int8_t ms3);
       static void microstep_mode(const uint8_t driver, const uint8_t stepping);
       static void microstep_readings();
     #endif
 
-    #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
+    #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS || ENABLED(Z_STEPPER_AUTO_ALIGN)
       FORCE_INLINE static void set_separate_multi_axis(const bool state) { separate_multi_axis = state; }
     #endif
     #if ENABLED(X_DUAL_ENDSTOPS)
       FORCE_INLINE static void set_x_lock(const bool state) { locked_X_motor = state; }
       FORCE_INLINE static void set_x2_lock(const bool state) { locked_X2_motor = state; }
     #endif
     #if ENABLED(Y_DUAL_ENDSTOPS)
       FORCE_INLINE static void set_y_lock(const bool state) { locked_Y_motor = state; }
       FORCE_INLINE static void set_y2_lock(const bool state) { locked_Y2_motor = state; }
     #endif
-    #if Z_MULTI_ENDSTOPS
+    #if Z_MULTI_ENDSTOPS || (ENABLED(Z_STEPPER_AUTO_ALIGN) && Z_MULTI_STEPPER_DRIVERS)
       FORCE_INLINE static void set_z_lock(const bool state) { locked_Z_motor = state; }
       FORCE_INLINE static void set_z2_lock(const bool state) { locked_Z2_motor = state; }
     #endif
-    #if ENABLED(Z_TRIPLE_ENDSTOPS)
+    #if ENABLED(Z_TRIPLE_ENDSTOPS) || (ENABLED(Z_STEPPER_AUTO_ALIGN) && ENABLED(Z_TRIPLE_STEPPER_DRIVERS))
       FORCE_INLINE static void set_z3_lock(const bool state) { locked_Z3_motor = state; }
     #endif
 
     #if ENABLED(BABYSTEPPING)
       static void babystep(const AxisEnum axis, const bool direction); // perform a short step with a single stepper motor, outside of any convention
     #endif
 
     #if HAS_MOTOR_CURRENT_PWM
       static void refresh_motor_power();
     #endif

commit f56968ba0b8d4eaccbc9b0c7834cf0cd2f5872d8
Author: AnHardt <github@kitelab.de>
Date:   Tue Oct 16 10:38:57 2018 +0200

    New Continuous Filament Mixer (#12098)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 95f28dc914..b9e7ead995 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -143,21 +143,26 @@
 #else
   #define ISR_START_Z_STEPPER_CYCLES 0UL
   #define ISR_Z_STEPPER_CYCLES       0UL
 #endif
 
 // E is always interpolated, even for mixing extruders
 #define ISR_START_E_STEPPER_CYCLES   ISR_START_STEPPER_CYCLES
 #define ISR_E_STEPPER_CYCLES         ISR_STEPPER_CYCLES
 
 // If linear advance is disabled, then the loop also handles them
-#if DISABLED(LIN_ADVANCE) && ENABLED(MIXING_EXTRUDER)
+#if DISABLED(LIN_ADVANCE) && ENABLED(MIXING_EXTRUDER) // ToDo: ???
+  // HELP ME: What is what?
+  // Directions are set up for MIXING_STEPPERS - like before.
+  // Finding the right stepper may last up to MIXING_STEPPERS loops in get_next_stepper().
+  //   These loops are a bit faster than advancing a bresenham counter.
+  // Always only one e-stepper is stepped.
   #define ISR_START_MIXING_STEPPER_CYCLES ((MIXING_STEPPERS) * (ISR_START_STEPPER_CYCLES))
   #define ISR_MIXING_STEPPER_CYCLES ((MIXING_STEPPERS) * (ISR_STEPPER_CYCLES))
 #else
   #define ISR_START_MIXING_STEPPER_CYCLES 0UL
   #define ISR_MIXING_STEPPER_CYCLES  0UL
 #endif
 
 // Calculate the minimum time to start all stepper pulses in the ISR loop
 #define MIN_ISR_START_LOOP_CYCLES (ISR_START_X_STEPPER_CYCLES + ISR_START_Y_STEPPER_CYCLES + ISR_START_Z_STEPPER_CYCLES + ISR_START_E_STEPPER_CYCLES + ISR_START_MIXING_STEPPER_CYCLES)
 
@@ -181,21 +186,26 @@
 // Calculate the extra ticks of the PULSE timer between step pulses
 #define ADDED_STEP_TICKS (((MIN_STEPPER_PULSE_CYCLES) / (PULSE_TIMER_PRESCALE)) - (MIN_PULSE_TICKS))
 
 // But the user could be enforcing a minimum time, so the loop time is
 #define ISR_LOOP_CYCLES (ISR_LOOP_BASE_CYCLES + MAX(MIN_STEPPER_PULSE_CYCLES, MIN_ISR_LOOP_CYCLES))
 
 // If linear advance is enabled, then it is handled separately
 #if ENABLED(LIN_ADVANCE)
 
   // Estimate the minimum LA loop time
-  #if ENABLED(MIXING_EXTRUDER)
+  #if ENABLED(MIXING_EXTRUDER) // ToDo: ???
+    // HELP ME: What is what?
+    // Directions are set up for MIXING_STEPPERS - like before.
+    // Finding the right stepper may last up to MIXING_STEPPERS loops in get_next_stepper().
+    //   These loops are a bit faster than advancing a bresenham counter.
+    // Always only one e-stepper is stepped.
     #define MIN_ISR_LA_LOOP_CYCLES ((MIXING_STEPPERS) * (ISR_STEPPER_CYCLES))
   #else
     #define MIN_ISR_LA_LOOP_CYCLES ISR_STEPPER_CYCLES
   #endif
 
   // And the real loop time
   #define ISR_LA_LOOP_CYCLES MAX(MIN_STEPPER_PULSE_CYCLES, MIN_ISR_LA_LOOP_CYCLES)
 
 #else
   #define ISR_LA_LOOP_CYCLES 0UL
@@ -285,31 +295,24 @@ class Stepper {
 
     // Delta error variables for the Bresenham line tracer
     static int32_t delta_error[XYZE];
     static uint32_t advance_dividend[XYZE],
                     advance_divisor,
                     step_events_completed,  // The number of step events executed in the current block
                     accelerate_until,       // The point from where we need to stop acceleration
                     decelerate_after,       // The point from where we need to start decelerating
                     step_event_count;       // The total event count for the current block
 
-    // Mixing extruder mix delta_errors for bresenham tracing
-    #if ENABLED(MIXING_EXTRUDER)
-      static int32_t delta_error_m[MIXING_STEPPERS];
-      static uint32_t advance_dividend_m[MIXING_STEPPERS],
-                      advance_divisor_m;
-      #define MIXING_STEPPERS_LOOP(VAR) \
-        for (uint8_t VAR = 0; VAR < MIXING_STEPPERS; VAR++)
-    #elif EXTRUDERS > 1
-      static uint8_t active_extruder;
+    #if EXTRUDERS > 1 || ENABLED(MIXING_EXTRUDER)
+      static uint8_t stepper_extruder;
     #else
-      static constexpr uint8_t active_extruder = 0;
+      static constexpr uint8_t stepper_extruder = 0;
     #endif
 
     #if ENABLED(S_CURVE_ACCELERATION)
       static int32_t bezier_A,     // A coefficient in B√©zier speed curve
                      bezier_B,     // B coefficient in B√©zier speed curve
                      bezier_C;     // C coefficient in B√©zier speed curve
       static uint32_t bezier_F,    // F coefficient in B√©zier speed curve
                       bezier_AV;   // AV coefficient in B√©zier speed curve
       #ifdef __AVR__
         static bool A_negative;    // If A coefficient was negative

commit 45e738876ac3b08af1b702d87435899005c043bc
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu Oct 11 00:56:26 2018 -0500

    Add stepper MS3 support
    
    Co-Authored-By: TheLongAndOnly <thelongandonly@users.noreply.github.com>

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 0ebe1d6e20..95f28dc914 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -406,21 +406,21 @@ class Stepper {
 
     // Triggered position of an axis in steps
     static int32_t triggered_position(const AxisEnum axis);
 
     #if HAS_DIGIPOTSS || HAS_MOTOR_CURRENT_PWM
       static void digitalPotWrite(const int16_t address, const int16_t value);
       static void digipot_current(const uint8_t driver, const int16_t current);
     #endif
 
     #if HAS_MICROSTEPS
-      static void microstep_ms(const uint8_t driver, const int8_t ms1, const int8_t ms2);
+      static void microstep_ms(const uint8_t driver, const int8_t ms1, const int8_t ms2, const int8_t ms3);
       static void microstep_mode(const uint8_t driver, const uint8_t stepping);
       static void microstep_readings();
     #endif
 
     #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
       FORCE_INLINE static void set_separate_multi_axis(const bool state) { separate_multi_axis = state; }
     #endif
     #if ENABLED(X_DUAL_ENDSTOPS)
       FORCE_INLINE static void set_x_lock(const bool state) { locked_X_motor = state; }
       FORCE_INLINE static void set_x2_lock(const bool state) { locked_X2_motor = state; }

commit 0780913848eea5048947808dfcc9143131f094d3
Author: Roxy-3D <Roxy-3D@users.noreply.github.com>
Date:   Mon Sep 17 01:06:22 2018 -0500

    IDEX Improvements (#11848)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 2585181973..0ebe1d6e20 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -465,27 +465,24 @@ class Stepper {
       #endif
 
       count_position[a] = v;
 
       #ifdef __AVR__
         // Reenable Stepper ISR
         if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
       #endif
     }
 
-  private:
-
     // Set direction bits for all steppers
     static void set_directions();
 
-    // Allow reset_stepper_drivers to access private set_directions
-    friend void reset_stepper_drivers();
+  private:
 
     // Set the current position in steps
     static void _set_position(const int32_t &a, const int32_t &b, const int32_t &c, const int32_t &e);
 
     FORCE_INLINE static uint32_t calc_timer_interval(uint32_t step_rate, uint8_t scale, uint8_t* loops) {
       uint32_t timer;
 
       // Scale the frequency, as requested by the caller
       step_rate <<= scale;
 

commit 1a6f2b29b8dd3bc8e6ef56d4f376f49cacfc8785
Author: Holger MuÃàller <holger@mueller-gelff.de>
Date:   Tue Jun 19 18:55:49 2018 +0200

    Add support for Triple-Z steppers/endstops

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 4577b96f2f..2585181973 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -227,22 +227,22 @@
   #include "speed_lookuptable.h"
 #endif
 
 #include "../module/planner.h"
 #include "../core/language.h"
 
 class Stepper {
 
   public:
 
-    #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
-      static bool homing_dual_axis;
+    #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
+      static bool separate_multi_axis;
     #endif
 
     #if HAS_MOTOR_CURRENT_PWM
       #ifndef PWM_MOTOR_CURRENT
         #define PWM_MOTOR_CURRENT DEFAULT_PWM_MOTOR_CURRENT
       #endif
       static uint32_t motor_current_setting[3];
     #endif
 
   private:
@@ -260,23 +260,26 @@ class Stepper {
     #elif DISABLED(MIXING_EXTRUDER)
       static uint8_t last_moved_extruder;
     #endif
 
     #if ENABLED(X_DUAL_ENDSTOPS)
       static bool locked_X_motor, locked_X2_motor;
     #endif
     #if ENABLED(Y_DUAL_ENDSTOPS)
       static bool locked_Y_motor, locked_Y2_motor;
     #endif
-    #if ENABLED(Z_DUAL_ENDSTOPS)
+    #if Z_MULTI_ENDSTOPS
       static bool locked_Z_motor, locked_Z2_motor;
     #endif
+    #if ENABLED(Z_TRIPLE_ENDSTOPS)
+      static bool locked_Z3_motor;
+    #endif
 
     static uint32_t acceleration_time, deceleration_time; // time measured in Stepper Timer ticks
     static uint8_t steps_per_isr;         // Count of steps to perform per Stepper ISR call
 
     #if ENABLED(ADAPTIVE_STEP_SMOOTHING)
       static uint8_t oversampling_factor; // Oversampling factor (log2(multiplier)) to increase temporal resolution of axis
     #else
       static constexpr uint8_t oversampling_factor = 0;
     #endif
 
@@ -408,35 +411,38 @@ class Stepper {
       static void digitalPotWrite(const int16_t address, const int16_t value);
       static void digipot_current(const uint8_t driver, const int16_t current);
     #endif
 
     #if HAS_MICROSTEPS
       static void microstep_ms(const uint8_t driver, const int8_t ms1, const int8_t ms2);
       static void microstep_mode(const uint8_t driver, const uint8_t stepping);
       static void microstep_readings();
     #endif
 
-    #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
-      FORCE_INLINE static void set_homing_dual_axis(const bool state) { homing_dual_axis = state; }
+    #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || Z_MULTI_ENDSTOPS
+      FORCE_INLINE static void set_separate_multi_axis(const bool state) { separate_multi_axis = state; }
     #endif
     #if ENABLED(X_DUAL_ENDSTOPS)
       FORCE_INLINE static void set_x_lock(const bool state) { locked_X_motor = state; }
       FORCE_INLINE static void set_x2_lock(const bool state) { locked_X2_motor = state; }
     #endif
     #if ENABLED(Y_DUAL_ENDSTOPS)
       FORCE_INLINE static void set_y_lock(const bool state) { locked_Y_motor = state; }
       FORCE_INLINE static void set_y2_lock(const bool state) { locked_Y2_motor = state; }
     #endif
-    #if ENABLED(Z_DUAL_ENDSTOPS)
+    #if Z_MULTI_ENDSTOPS
       FORCE_INLINE static void set_z_lock(const bool state) { locked_Z_motor = state; }
       FORCE_INLINE static void set_z2_lock(const bool state) { locked_Z2_motor = state; }
     #endif
+    #if ENABLED(Z_TRIPLE_ENDSTOPS)
+      FORCE_INLINE static void set_z3_lock(const bool state) { locked_Z3_motor = state; }
+    #endif
 
     #if ENABLED(BABYSTEPPING)
       static void babystep(const AxisEnum axis, const bool direction); // perform a short step with a single stepper motor, outside of any convention
     #endif
 
     #if HAS_MOTOR_CURRENT_PWM
       static void refresh_motor_power();
     #endif
 
     // Set the current position in steps

commit 215eee4fe58c7cb6d61f496a9c27194865fb7317
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Sep 15 20:11:10 2018 -0500

    Use 'friend' to access set_directions

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 107147933b..4577b96f2f 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -459,24 +459,28 @@ class Stepper {
       #endif
 
       count_position[a] = v;
 
       #ifdef __AVR__
         // Reenable Stepper ISR
         if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
       #endif
     }
 
+  private:
+
     // Set direction bits for all steppers
     static void set_directions();
 
-  private:
+    // Allow reset_stepper_drivers to access private set_directions
+    friend void reset_stepper_drivers();
+
     // Set the current position in steps
     static void _set_position(const int32_t &a, const int32_t &b, const int32_t &c, const int32_t &e);
 
     FORCE_INLINE static uint32_t calc_timer_interval(uint32_t step_rate, uint8_t scale, uint8_t* loops) {
       uint32_t timer;
 
       // Scale the frequency, as requested by the caller
       step_rate <<= scale;
 
       uint8_t multistep = 1;

commit ff51e7322d76c37ebefbbde98d11c6a837a5efbd
Author: Cassiano Leal <cassianoleal@gmail.com>
Date:   Sun Sep 16 01:31:51 2018 +0100

    Fix for Stepper::set_directions() compilation error (#11838)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index bc1b9e8045..107147933b 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -459,28 +459,27 @@ class Stepper {
       #endif
 
       count_position[a] = v;
 
       #ifdef __AVR__
         // Reenable Stepper ISR
         if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
       #endif
     }
 
-  private:
+    // Set direction bits for all steppers
+    static void set_directions();
 
+  private:
     // Set the current position in steps
     static void _set_position(const int32_t &a, const int32_t &b, const int32_t &c, const int32_t &e);
 
-    // Set direction bits for all steppers
-    static void set_directions();
-
     FORCE_INLINE static uint32_t calc_timer_interval(uint32_t step_rate, uint8_t scale, uint8_t* loops) {
       uint32_t timer;
 
       // Scale the frequency, as requested by the caller
       step_rate <<= scale;
 
       uint8_t multistep = 1;
       #if DISABLED(DISABLE_MULTI_STEPPING)
 
         // The stepping frequency limits for each multistepping rate

commit d882717d98d08ba7a47234eacf291b2d82288f13
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Mon Sep 10 23:09:26 2018 -0500

    Save some PROGMEM with constexpr (#11798)
    
    When possible, make `active_extruder` a `constexpr` to save some PROGMEM.

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 7e9f9cbe17..bc1b9e8045 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -247,22 +247,25 @@ class Stepper {
 
   private:
 
     static block_t* current_block;          // A pointer to the block currently being traced
 
     static uint8_t last_direction_bits,     // The next stepping-bits to be output
                    axis_did_move;           // Last Movement in the given direction is not null, as computed when the last movement was fetched from planner
 
     static bool abort_current_block;        // Signals to the stepper that current block should be aborted
 
-    #if DISABLED(MIXING_EXTRUDER)
-      static uint8_t last_moved_extruder;   // Last-moved extruder, as set when the last movement was fetched from planner
+    // Last-moved extruder, as set when the last movement was fetched from planner
+    #if EXTRUDERS < 2
+      static constexpr uint8_t last_moved_extruder = 0;
+    #elif DISABLED(MIXING_EXTRUDER)
+      static uint8_t last_moved_extruder;
     #endif
 
     #if ENABLED(X_DUAL_ENDSTOPS)
       static bool locked_X_motor, locked_X2_motor;
     #endif
     #if ENABLED(Y_DUAL_ENDSTOPS)
       static bool locked_Y_motor, locked_Y2_motor;
     #endif
     #if ENABLED(Z_DUAL_ENDSTOPS)
       static bool locked_Z_motor, locked_Z2_motor;
@@ -286,22 +289,24 @@ class Stepper {
                     decelerate_after,       // The point from where we need to start decelerating
                     step_event_count;       // The total event count for the current block
 
     // Mixing extruder mix delta_errors for bresenham tracing
     #if ENABLED(MIXING_EXTRUDER)
       static int32_t delta_error_m[MIXING_STEPPERS];
       static uint32_t advance_dividend_m[MIXING_STEPPERS],
                       advance_divisor_m;
       #define MIXING_STEPPERS_LOOP(VAR) \
         for (uint8_t VAR = 0; VAR < MIXING_STEPPERS; VAR++)
+    #elif EXTRUDERS > 1
+      static uint8_t active_extruder;
     #else
-      static int8_t active_extruder;      // Active extruder
+      static constexpr uint8_t active_extruder = 0;
     #endif
 
     #if ENABLED(S_CURVE_ACCELERATION)
       static int32_t bezier_A,     // A coefficient in B√©zier speed curve
                      bezier_B,     // B coefficient in B√©zier speed curve
                      bezier_C;     // C coefficient in B√©zier speed curve
       static uint32_t bezier_F,    // F coefficient in B√©zier speed curve
                       bezier_AV;   // AV coefficient in B√©zier speed curve
       #ifdef __AVR__
         static bool A_negative;    // If A coefficient was negative
@@ -378,21 +383,21 @@ class Stepper {
 
     // The direction of a single motor
     FORCE_INLINE static bool motor_direction(const AxisEnum axis) { return TEST(last_direction_bits, axis); }
 
     // The last movement direction was not null on the specified axis. Note that motor direction is not necessarily the same.
     FORCE_INLINE static bool axis_is_moving(const AxisEnum axis) { return TEST(axis_did_move, axis); }
 
     // The extruder associated to the last movement
     FORCE_INLINE static uint8_t movement_extruder() {
       return
-        #if ENABLED(MIXING_EXTRUDER)
+        #if ENABLED(MIXING_EXTRUDER) || EXTRUDERS < 2
           0
         #else
           last_moved_extruder
         #endif
       ;
     }
 
     // Handle a triggered endstop
     static void endstop_triggered(const AxisEnum axis);
 

commit a4b01483650ce50e3916d4bc16553429825603ec
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Aug 13 23:55:12 2018 -0500

    Easier to find 'static inline'

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 2280bb78b8..7e9f9cbe17 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -428,29 +428,29 @@ class Stepper {
 
     #if ENABLED(BABYSTEPPING)
       static void babystep(const AxisEnum axis, const bool direction); // perform a short step with a single stepper motor, outside of any convention
     #endif
 
     #if HAS_MOTOR_CURRENT_PWM
       static void refresh_motor_power();
     #endif
 
     // Set the current position in steps
-    inline static void set_position(const int32_t &a, const int32_t &b, const int32_t &c, const int32_t &e) {
+    static inline void set_position(const int32_t &a, const int32_t &b, const int32_t &c, const int32_t &e) {
       planner.synchronize();
       const bool was_enabled = STEPPER_ISR_ENABLED();
       if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
       _set_position(a, b, c, e);
       if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
     }
 
-    inline static void set_position(const AxisEnum a, const int32_t &v) {
+    static inline void set_position(const AxisEnum a, const int32_t &v) {
       planner.synchronize();
 
       #ifdef __AVR__
         // Protect the access to the position. Only required for AVR, as
         //  any 32bit CPU offers atomic access to 32bit variables
         const bool was_enabled = STEPPER_ISR_ENABLED();
         if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
       #endif
 
       count_position[a] = v;

commit aa4cd2e861f195836e51c42fbdaa962bc3e085c5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Jun 27 21:27:36 2018 -0500

    Eliminate stepper.* signed/unsigned warnings

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 6ced24e84e..2280bb78b8 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -51,21 +51,21 @@
 //
 // Estimate the amount of time the Stepper ISR will take to execute
 //
 
 #ifndef MINIMUM_STEPPER_PULSE
   #define MINIMUM_STEPPER_PULSE 0UL
 #endif
 
 #ifndef MAXIMUM_STEPPER_RATE
   #if MINIMUM_STEPPER_PULSE
-    #define MAXIMUM_STEPPER_RATE (1000000UL / (2UL * (MINIMUM_STEPPER_PULSE)))
+    #define MAXIMUM_STEPPER_RATE (1000000UL / (2UL * (unsigned long)(MINIMUM_STEPPER_PULSE)))
   #else
     #define MAXIMUM_STEPPER_RATE 500000UL
   #endif
 #endif
 
 #ifdef CPU_32_BIT
 
   // The base ISR takes 792 cycles
   #define ISR_BASE_CYCLES  792UL
 
@@ -158,32 +158,32 @@
   #define ISR_MIXING_STEPPER_CYCLES  0UL
 #endif
 
 // Calculate the minimum time to start all stepper pulses in the ISR loop
 #define MIN_ISR_START_LOOP_CYCLES (ISR_START_X_STEPPER_CYCLES + ISR_START_Y_STEPPER_CYCLES + ISR_START_Z_STEPPER_CYCLES + ISR_START_E_STEPPER_CYCLES + ISR_START_MIXING_STEPPER_CYCLES)
 
 // And the total minimum loop time, not including the base
 #define MIN_ISR_LOOP_CYCLES (ISR_X_STEPPER_CYCLES + ISR_Y_STEPPER_CYCLES + ISR_Z_STEPPER_CYCLES + ISR_E_STEPPER_CYCLES + ISR_MIXING_STEPPER_CYCLES)
 
 // Calculate the minimum MPU cycles needed per pulse to enforce, limited to the max stepper rate
-#define _MIN_STEPPER_PULSE_CYCLES(N) MAX((F_CPU) / (MAXIMUM_STEPPER_RATE), ((F_CPU) / 500000UL) * (N))
+#define _MIN_STEPPER_PULSE_CYCLES(N) MAX((unsigned long)((F_CPU) / (MAXIMUM_STEPPER_RATE)), ((F_CPU) / 500000UL) * (N))
 #if MINIMUM_STEPPER_PULSE
-  #define MIN_STEPPER_PULSE_CYCLES _MIN_STEPPER_PULSE_CYCLES((MINIMUM_STEPPER_PULSE))
+  #define MIN_STEPPER_PULSE_CYCLES _MIN_STEPPER_PULSE_CYCLES((unsigned long)(MINIMUM_STEPPER_PULSE))
 #else
   #define MIN_STEPPER_PULSE_CYCLES _MIN_STEPPER_PULSE_CYCLES(1UL)
 #endif
 
 // Calculate the minimum ticks of the PULSE timer that must elapse with the step pulse enabled
 // adding the "start stepper pulse" code section execution cycles to account for that not all
 // pulses start at the beginning of the loop, so an extra time must be added to compensate so
 // the last generated pulse (usually the extruder stepper) has the right length
-#define MIN_PULSE_TICKS (((PULSE_TIMER_TICKS_PER_US) * (MINIMUM_STEPPER_PULSE)) + ((MIN_ISR_START_LOOP_CYCLES) / (PULSE_TIMER_PRESCALE)))
+#define MIN_PULSE_TICKS (((PULSE_TIMER_TICKS_PER_US) * (unsigned long)(MINIMUM_STEPPER_PULSE)) + ((MIN_ISR_START_LOOP_CYCLES) / (unsigned long)(PULSE_TIMER_PRESCALE)))
 
 // Calculate the extra ticks of the PULSE timer between step pulses
 #define ADDED_STEP_TICKS (((MIN_STEPPER_PULSE_CYCLES) / (PULSE_TIMER_PRESCALE)) - (MIN_PULSE_TICKS))
 
 // But the user could be enforcing a minimum time, so the loop time is
 #define ISR_LOOP_CYCLES (ISR_LOOP_BASE_CYCLES + MAX(MIN_STEPPER_PULSE_CYCLES, MIN_ISR_LOOP_CYCLES))
 
 // If linear advance is enabled, then it is handled separately
 #if ENABLED(LIN_ADVANCE)
 

commit edb21f349ad18d2948ff6c313c6d43132bad5118
Author: Eduardo Jos√© Tagle <ejtagle@hotmail.com>
Date:   Wed Jun 27 20:11:16 2018 -0300

    Fix stepper/planner block handling, race conditions (#11098)
    
    - Allow planner to alter the deceleration phase of the currently executing block.
    - Remove BUSY flag, as it is NON ATOMIC to set bits in the Stepper ISR and Planner at the same time.

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 21a76df266..6ced24e84e 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -227,35 +227,35 @@
   #include "speed_lookuptable.h"
 #endif
 
 #include "../module/planner.h"
 #include "../core/language.h"
 
 class Stepper {
 
   public:
 
-    static block_t* current_block;  // A pointer to the block currently being traced
-
     #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
       static bool homing_dual_axis;
     #endif
 
     #if HAS_MOTOR_CURRENT_PWM
       #ifndef PWM_MOTOR_CURRENT
         #define PWM_MOTOR_CURRENT DEFAULT_PWM_MOTOR_CURRENT
       #endif
       static uint32_t motor_current_setting[3];
     #endif
 
   private:
 
+    static block_t* current_block;          // A pointer to the block currently being traced
+
     static uint8_t last_direction_bits,     // The next stepping-bits to be output
                    axis_did_move;           // Last Movement in the given direction is not null, as computed when the last movement was fetched from planner
 
     static bool abort_current_block;        // Signals to the stepper that current block should be aborted
 
     #if DISABLED(MIXING_EXTRUDER)
       static uint8_t last_moved_extruder;   // Last-moved extruder, as set when the last movement was fetched from planner
     #endif
 
     #if ENABLED(X_DUAL_ENDSTOPS)
@@ -353,20 +353,23 @@ class Stepper {
     static void stepper_pulse_phase_isr();
 
     // The stepper block processing phase ISR
     static uint32_t stepper_block_phase_isr();
 
     #if ENABLED(LIN_ADVANCE)
       // The Linear advance stepper ISR
       static uint32_t advance_isr();
     #endif
 
+    // Check if the given block is busy or not - Must not be called from ISR contexts
+    static bool is_block_busy(const block_t* const block);
+
     // Get the position of a stepper, in steps
     static int32_t position(const AxisEnum axis);
 
     // Report the positions of the steppers, in steps
     static void report_positions();
 
     // The stepper subsystem goes to sleep when it runs out of things to execute. Call this
     // to notify the subsystem that it is time to go to work.
     static void wake_up();
 

commit 48a15d1c7e78eaa716bedecb80feeae780c7234a
Author: Eduardo Jos√© Tagle <ejtagle@hotmail.com>
Date:   Fri Jun 22 11:15:37 2018 -0300

    [2.0.x] Fix stepper/planner race condition and Stepper pulse timer (#11081)
    
    * Planner: Removal of some race conditions between Stepper ISR and Planner, some of them pointed out by @AnHardt, some of my own findings
    * Fixing timing on stepper pulses adding a compensation for the non-null time required to set ports.

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 38b86e39e8..21a76df266 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -46,21 +46,21 @@
 #include "../inc/MarlinConfig.h"
 
 // Disable multiple steps per ISR
 //#define DISABLE_MULTI_STEPPING
 
 //
 // Estimate the amount of time the Stepper ISR will take to execute
 //
 
 #ifndef MINIMUM_STEPPER_PULSE
-  #define MINIMUM_STEPPER_PULSE 0
+  #define MINIMUM_STEPPER_PULSE 0UL
 #endif
 
 #ifndef MAXIMUM_STEPPER_RATE
   #if MINIMUM_STEPPER_PULSE
     #define MAXIMUM_STEPPER_RATE (1000000UL / (2UL * (MINIMUM_STEPPER_PULSE)))
   #else
     #define MAXIMUM_STEPPER_RATE 500000UL
   #endif
 #endif
 
@@ -79,21 +79,24 @@
   // S curve interpolation adds 40 cycles
   #if ENABLED(S_CURVE_ACCELERATION)
     #define ISR_S_CURVE_CYCLES 40UL
   #else
     #define ISR_S_CURVE_CYCLES 0UL
   #endif
 
   // Stepper Loop base cycles
   #define ISR_LOOP_BASE_CYCLES 4UL
 
-  // And each stepper takes 16 cycles
+  // To start the step pulse, in the worst case takes
+  #define ISR_START_STEPPER_CYCLES 13UL
+
+  // And each stepper (start + stop pulse) takes in worst case
   #define ISR_STEPPER_CYCLES 16UL
 
 #else
 
   // The base ISR takes 752 cycles
   #define ISR_BASE_CYCLES  752UL
 
   // Linear advance base time is 32 cycles
   #if ENABLED(LIN_ADVANCE)
     #define ISR_LA_BASE_CYCLES 32UL
@@ -104,65 +107,86 @@
   // S curve interpolation adds 160 cycles
   #if ENABLED(S_CURVE_ACCELERATION)
     #define ISR_S_CURVE_CYCLES 160UL
   #else
     #define ISR_S_CURVE_CYCLES 0UL
   #endif
 
   // Stepper Loop base cycles
   #define ISR_LOOP_BASE_CYCLES 32UL
 
-  // And each stepper takes 88 cycles
+  // To start the step pulse, in the worst case takes
+  #define ISR_START_STEPPER_CYCLES 57UL
+
+  // And each stepper (start + stop pulse) takes in worst case
   #define ISR_STEPPER_CYCLES 88UL
 
 #endif
 
 // Add time for each stepper
 #ifdef HAS_X_STEP
-  #define ISR_X_STEPPER_CYCLES ISR_STEPPER_CYCLES
+  #define ISR_START_X_STEPPER_CYCLES ISR_START_STEPPER_CYCLES
+  #define ISR_X_STEPPER_CYCLES       ISR_STEPPER_CYCLES
 #else
-  #define ISR_X_STEPPER_CYCLES 0UL
+  #define ISR_START_X_STEPPER_CYCLES 0UL
+  #define ISR_X_STEPPER_CYCLES       0UL
 #endif
 #ifdef HAS_Y_STEP
-  #define ISR_Y_STEPPER_CYCLES ISR_STEPPER_CYCLES
+  #define ISR_START_Y_STEPPER_CYCLES ISR_START_STEPPER_CYCLES
+  #define ISR_Y_STEPPER_CYCLES       ISR_STEPPER_CYCLES
 #else
-  #define ISR_Y_STEPPER_CYCLES 0UL
+  #define ISR_START_Y_STEPPER_CYCLES 0UL
+  #define ISR_Y_STEPPER_CYCLES       0UL
 #endif
 #ifdef HAS_Z_STEP
-  #define ISR_Z_STEPPER_CYCLES ISR_STEPPER_CYCLES
+  #define ISR_START_Z_STEPPER_CYCLES ISR_START_STEPPER_CYCLES
+  #define ISR_Z_STEPPER_CYCLES       ISR_STEPPER_CYCLES
 #else
-  #define ISR_Z_STEPPER_CYCLES 0UL
+  #define ISR_START_Z_STEPPER_CYCLES 0UL
+  #define ISR_Z_STEPPER_CYCLES       0UL
 #endif
 
 // E is always interpolated, even for mixing extruders
-#define ISR_E_STEPPER_CYCLES ISR_STEPPER_CYCLES
+#define ISR_START_E_STEPPER_CYCLES   ISR_START_STEPPER_CYCLES
+#define ISR_E_STEPPER_CYCLES         ISR_STEPPER_CYCLES
 
 // If linear advance is disabled, then the loop also handles them
 #if DISABLED(LIN_ADVANCE) && ENABLED(MIXING_EXTRUDER)
+  #define ISR_START_MIXING_STEPPER_CYCLES ((MIXING_STEPPERS) * (ISR_START_STEPPER_CYCLES))
   #define ISR_MIXING_STEPPER_CYCLES ((MIXING_STEPPERS) * (ISR_STEPPER_CYCLES))
 #else
+  #define ISR_START_MIXING_STEPPER_CYCLES 0UL
   #define ISR_MIXING_STEPPER_CYCLES  0UL
 #endif
 
+// Calculate the minimum time to start all stepper pulses in the ISR loop
+#define MIN_ISR_START_LOOP_CYCLES (ISR_START_X_STEPPER_CYCLES + ISR_START_Y_STEPPER_CYCLES + ISR_START_Z_STEPPER_CYCLES + ISR_START_E_STEPPER_CYCLES + ISR_START_MIXING_STEPPER_CYCLES)
+
 // And the total minimum loop time, not including the base
 #define MIN_ISR_LOOP_CYCLES (ISR_X_STEPPER_CYCLES + ISR_Y_STEPPER_CYCLES + ISR_Z_STEPPER_CYCLES + ISR_E_STEPPER_CYCLES + ISR_MIXING_STEPPER_CYCLES)
 
 // Calculate the minimum MPU cycles needed per pulse to enforce, limited to the max stepper rate
 #define _MIN_STEPPER_PULSE_CYCLES(N) MAX((F_CPU) / (MAXIMUM_STEPPER_RATE), ((F_CPU) / 500000UL) * (N))
 #if MINIMUM_STEPPER_PULSE
-  #define MIN_STEPPER_PULSE_CYCLES _MIN_STEPPER_PULSE_CYCLES(MINIMUM_STEPPER_PULSE)
+  #define MIN_STEPPER_PULSE_CYCLES _MIN_STEPPER_PULSE_CYCLES((MINIMUM_STEPPER_PULSE))
 #else
-  #define MIN_STEPPER_PULSE_CYCLES _MIN_STEPPER_PULSE_CYCLES(1)
+  #define MIN_STEPPER_PULSE_CYCLES _MIN_STEPPER_PULSE_CYCLES(1UL)
 #endif
 
-#define MIN_PULSE_TICKS  ((PULSE_TIMER_TICKS_PER_US) * (MINIMUM_STEPPER_PULSE))
-#define ADDED_STEP_TICKS ((MIN_STEPPER_PULSE_CYCLES) / (PULSE_TIMER_PRESCALE) - MIN_PULSE_TICKS)
+// Calculate the minimum ticks of the PULSE timer that must elapse with the step pulse enabled
+// adding the "start stepper pulse" code section execution cycles to account for that not all
+// pulses start at the beginning of the loop, so an extra time must be added to compensate so
+// the last generated pulse (usually the extruder stepper) has the right length
+#define MIN_PULSE_TICKS (((PULSE_TIMER_TICKS_PER_US) * (MINIMUM_STEPPER_PULSE)) + ((MIN_ISR_START_LOOP_CYCLES) / (PULSE_TIMER_PRESCALE)))
+
+// Calculate the extra ticks of the PULSE timer between step pulses
+#define ADDED_STEP_TICKS (((MIN_STEPPER_PULSE_CYCLES) / (PULSE_TIMER_PRESCALE)) - (MIN_PULSE_TICKS))
 
 // But the user could be enforcing a minimum time, so the loop time is
 #define ISR_LOOP_CYCLES (ISR_LOOP_BASE_CYCLES + MAX(MIN_STEPPER_PULSE_CYCLES, MIN_ISR_LOOP_CYCLES))
 
 // If linear advance is enabled, then it is handled separately
 #if ENABLED(LIN_ADVANCE)
 
   // Estimate the minimum LA loop time
   #if ENABLED(MIXING_EXTRUDER)
     #define MIN_ISR_LA_LOOP_CYCLES ((MIXING_STEPPERS) * (ISR_STEPPER_CYCLES))

commit 7406f04029da76d4c6564677ed783d9fb55fba45
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jun 19 20:51:07 2018 -0500

    Use MAX (not max) in stepper.h

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index eff7a5e3e1..38b86e39e8 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -140,45 +140,45 @@
 #if DISABLED(LIN_ADVANCE) && ENABLED(MIXING_EXTRUDER)
   #define ISR_MIXING_STEPPER_CYCLES ((MIXING_STEPPERS) * (ISR_STEPPER_CYCLES))
 #else
   #define ISR_MIXING_STEPPER_CYCLES  0UL
 #endif
 
 // And the total minimum loop time, not including the base
 #define MIN_ISR_LOOP_CYCLES (ISR_X_STEPPER_CYCLES + ISR_Y_STEPPER_CYCLES + ISR_Z_STEPPER_CYCLES + ISR_E_STEPPER_CYCLES + ISR_MIXING_STEPPER_CYCLES)
 
 // Calculate the minimum MPU cycles needed per pulse to enforce, limited to the max stepper rate
-#define _MIN_STEPPER_PULSE_CYCLES(N) max((F_CPU) / (MAXIMUM_STEPPER_RATE), ((F_CPU) / 500000UL) * (N))
+#define _MIN_STEPPER_PULSE_CYCLES(N) MAX((F_CPU) / (MAXIMUM_STEPPER_RATE), ((F_CPU) / 500000UL) * (N))
 #if MINIMUM_STEPPER_PULSE
   #define MIN_STEPPER_PULSE_CYCLES _MIN_STEPPER_PULSE_CYCLES(MINIMUM_STEPPER_PULSE)
 #else
   #define MIN_STEPPER_PULSE_CYCLES _MIN_STEPPER_PULSE_CYCLES(1)
 #endif
 
 #define MIN_PULSE_TICKS  ((PULSE_TIMER_TICKS_PER_US) * (MINIMUM_STEPPER_PULSE))
 #define ADDED_STEP_TICKS ((MIN_STEPPER_PULSE_CYCLES) / (PULSE_TIMER_PRESCALE) - MIN_PULSE_TICKS)
 
 // But the user could be enforcing a minimum time, so the loop time is
-#define ISR_LOOP_CYCLES (ISR_LOOP_BASE_CYCLES + max(MIN_STEPPER_PULSE_CYCLES, MIN_ISR_LOOP_CYCLES))
+#define ISR_LOOP_CYCLES (ISR_LOOP_BASE_CYCLES + MAX(MIN_STEPPER_PULSE_CYCLES, MIN_ISR_LOOP_CYCLES))
 
 // If linear advance is enabled, then it is handled separately
 #if ENABLED(LIN_ADVANCE)
 
   // Estimate the minimum LA loop time
   #if ENABLED(MIXING_EXTRUDER)
     #define MIN_ISR_LA_LOOP_CYCLES ((MIXING_STEPPERS) * (ISR_STEPPER_CYCLES))
   #else
     #define MIN_ISR_LA_LOOP_CYCLES ISR_STEPPER_CYCLES
   #endif
 
   // And the real loop time
-  #define ISR_LA_LOOP_CYCLES max(MIN_STEPPER_PULSE_CYCLES, MIN_ISR_LA_LOOP_CYCLES)
+  #define ISR_LA_LOOP_CYCLES MAX(MIN_STEPPER_PULSE_CYCLES, MIN_ISR_LA_LOOP_CYCLES)
 
 #else
   #define ISR_LA_LOOP_CYCLES 0UL
 #endif
 
 // Now estimate the total ISR execution time in cycles given a step per ISR multiplier
 #define ISR_EXECUTION_CYCLES(R) (((ISR_BASE_CYCLES + ISR_S_CURVE_CYCLES + (ISR_LOOP_CYCLES) * (R) + ISR_LA_BASE_CYCLES + ISR_LA_LOOP_CYCLES)) / (R))
 
 // The maximum allowable stepping frequency when doing x128-x1 stepping (in Hz)
 #define MAX_STEP_ISR_FREQUENCY_128X ((F_CPU) / ISR_EXECUTION_CYCLES(128))

commit 0d79128c8d6830c967f8f6091a40dcd65d7c6a53
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jun 12 17:28:57 2018 -0500

    Localize stepper-specific defines

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 83fe45de48..eff7a5e3e1 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -36,33 +36,183 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with Grbl.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #ifndef STEPPER_H
 #define STEPPER_H
 
+#include "../inc/MarlinConfig.h"
+
+// Disable multiple steps per ISR
+//#define DISABLE_MULTI_STEPPING
+
+//
+// Estimate the amount of time the Stepper ISR will take to execute
+//
+
+#ifndef MINIMUM_STEPPER_PULSE
+  #define MINIMUM_STEPPER_PULSE 0
+#endif
+
+#ifndef MAXIMUM_STEPPER_RATE
+  #if MINIMUM_STEPPER_PULSE
+    #define MAXIMUM_STEPPER_RATE (1000000UL / (2UL * (MINIMUM_STEPPER_PULSE)))
+  #else
+    #define MAXIMUM_STEPPER_RATE 500000UL
+  #endif
+#endif
+
+#ifdef CPU_32_BIT
+
+  // The base ISR takes 792 cycles
+  #define ISR_BASE_CYCLES  792UL
+
+  // Linear advance base time is 64 cycles
+  #if ENABLED(LIN_ADVANCE)
+    #define ISR_LA_BASE_CYCLES 64UL
+  #else
+    #define ISR_LA_BASE_CYCLES 0UL
+  #endif
+
+  // S curve interpolation adds 40 cycles
+  #if ENABLED(S_CURVE_ACCELERATION)
+    #define ISR_S_CURVE_CYCLES 40UL
+  #else
+    #define ISR_S_CURVE_CYCLES 0UL
+  #endif
+
+  // Stepper Loop base cycles
+  #define ISR_LOOP_BASE_CYCLES 4UL
+
+  // And each stepper takes 16 cycles
+  #define ISR_STEPPER_CYCLES 16UL
+
+#else
+
+  // The base ISR takes 752 cycles
+  #define ISR_BASE_CYCLES  752UL
+
+  // Linear advance base time is 32 cycles
+  #if ENABLED(LIN_ADVANCE)
+    #define ISR_LA_BASE_CYCLES 32UL
+  #else
+    #define ISR_LA_BASE_CYCLES 0UL
+  #endif
+
+  // S curve interpolation adds 160 cycles
+  #if ENABLED(S_CURVE_ACCELERATION)
+    #define ISR_S_CURVE_CYCLES 160UL
+  #else
+    #define ISR_S_CURVE_CYCLES 0UL
+  #endif
+
+  // Stepper Loop base cycles
+  #define ISR_LOOP_BASE_CYCLES 32UL
+
+  // And each stepper takes 88 cycles
+  #define ISR_STEPPER_CYCLES 88UL
+
+#endif
+
+// Add time for each stepper
+#ifdef HAS_X_STEP
+  #define ISR_X_STEPPER_CYCLES ISR_STEPPER_CYCLES
+#else
+  #define ISR_X_STEPPER_CYCLES 0UL
+#endif
+#ifdef HAS_Y_STEP
+  #define ISR_Y_STEPPER_CYCLES ISR_STEPPER_CYCLES
+#else
+  #define ISR_Y_STEPPER_CYCLES 0UL
+#endif
+#ifdef HAS_Z_STEP
+  #define ISR_Z_STEPPER_CYCLES ISR_STEPPER_CYCLES
+#else
+  #define ISR_Z_STEPPER_CYCLES 0UL
+#endif
+
+// E is always interpolated, even for mixing extruders
+#define ISR_E_STEPPER_CYCLES ISR_STEPPER_CYCLES
+
+// If linear advance is disabled, then the loop also handles them
+#if DISABLED(LIN_ADVANCE) && ENABLED(MIXING_EXTRUDER)
+  #define ISR_MIXING_STEPPER_CYCLES ((MIXING_STEPPERS) * (ISR_STEPPER_CYCLES))
+#else
+  #define ISR_MIXING_STEPPER_CYCLES  0UL
+#endif
+
+// And the total minimum loop time, not including the base
+#define MIN_ISR_LOOP_CYCLES (ISR_X_STEPPER_CYCLES + ISR_Y_STEPPER_CYCLES + ISR_Z_STEPPER_CYCLES + ISR_E_STEPPER_CYCLES + ISR_MIXING_STEPPER_CYCLES)
+
+// Calculate the minimum MPU cycles needed per pulse to enforce, limited to the max stepper rate
+#define _MIN_STEPPER_PULSE_CYCLES(N) max((F_CPU) / (MAXIMUM_STEPPER_RATE), ((F_CPU) / 500000UL) * (N))
+#if MINIMUM_STEPPER_PULSE
+  #define MIN_STEPPER_PULSE_CYCLES _MIN_STEPPER_PULSE_CYCLES(MINIMUM_STEPPER_PULSE)
+#else
+  #define MIN_STEPPER_PULSE_CYCLES _MIN_STEPPER_PULSE_CYCLES(1)
+#endif
+
+#define MIN_PULSE_TICKS  ((PULSE_TIMER_TICKS_PER_US) * (MINIMUM_STEPPER_PULSE))
+#define ADDED_STEP_TICKS ((MIN_STEPPER_PULSE_CYCLES) / (PULSE_TIMER_PRESCALE) - MIN_PULSE_TICKS)
+
+// But the user could be enforcing a minimum time, so the loop time is
+#define ISR_LOOP_CYCLES (ISR_LOOP_BASE_CYCLES + max(MIN_STEPPER_PULSE_CYCLES, MIN_ISR_LOOP_CYCLES))
+
+// If linear advance is enabled, then it is handled separately
+#if ENABLED(LIN_ADVANCE)
+
+  // Estimate the minimum LA loop time
+  #if ENABLED(MIXING_EXTRUDER)
+    #define MIN_ISR_LA_LOOP_CYCLES ((MIXING_STEPPERS) * (ISR_STEPPER_CYCLES))
+  #else
+    #define MIN_ISR_LA_LOOP_CYCLES ISR_STEPPER_CYCLES
+  #endif
+
+  // And the real loop time
+  #define ISR_LA_LOOP_CYCLES max(MIN_STEPPER_PULSE_CYCLES, MIN_ISR_LA_LOOP_CYCLES)
+
+#else
+  #define ISR_LA_LOOP_CYCLES 0UL
+#endif
+
+// Now estimate the total ISR execution time in cycles given a step per ISR multiplier
+#define ISR_EXECUTION_CYCLES(R) (((ISR_BASE_CYCLES + ISR_S_CURVE_CYCLES + (ISR_LOOP_CYCLES) * (R) + ISR_LA_BASE_CYCLES + ISR_LA_LOOP_CYCLES)) / (R))
+
+// The maximum allowable stepping frequency when doing x128-x1 stepping (in Hz)
+#define MAX_STEP_ISR_FREQUENCY_128X ((F_CPU) / ISR_EXECUTION_CYCLES(128))
+#define MAX_STEP_ISR_FREQUENCY_64X  ((F_CPU) / ISR_EXECUTION_CYCLES(64))
+#define MAX_STEP_ISR_FREQUENCY_32X  ((F_CPU) / ISR_EXECUTION_CYCLES(32))
+#define MAX_STEP_ISR_FREQUENCY_16X  ((F_CPU) / ISR_EXECUTION_CYCLES(16))
+#define MAX_STEP_ISR_FREQUENCY_8X   ((F_CPU) / ISR_EXECUTION_CYCLES(8))
+#define MAX_STEP_ISR_FREQUENCY_4X   ((F_CPU) / ISR_EXECUTION_CYCLES(4))
+#define MAX_STEP_ISR_FREQUENCY_2X   ((F_CPU) / ISR_EXECUTION_CYCLES(2))
+#define MAX_STEP_ISR_FREQUENCY_1X   ((F_CPU) / ISR_EXECUTION_CYCLES(1))
+
+// The minimum allowable frequency for step smoothing will be 1/10 of the maximum nominal frequency (in Hz)
+#define MIN_STEP_ISR_FREQUENCY MAX_STEP_ISR_FREQUENCY_1X
+
+//
+// Stepper class definition
+//
+
 #include "stepper_indirection.h"
 
 #ifdef __AVR__
   #include "speed_lookuptable.h"
 #endif
 
-#include "../inc/MarlinConfig.h"
 #include "../module/planner.h"
 #include "../core/language.h"
 
-class Stepper;
-extern Stepper stepper;
-
 class Stepper {
 
   public:
 
     static block_t* current_block;  // A pointer to the block currently being traced
 
     #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
       static bool homing_dual_axis;
     #endif
 
@@ -296,39 +446,39 @@ class Stepper {
       uint32_t timer;
 
       // Scale the frequency, as requested by the caller
       step_rate <<= scale;
 
       uint8_t multistep = 1;
       #if DISABLED(DISABLE_MULTI_STEPPING)
 
         // The stepping frequency limits for each multistepping rate
         static const uint32_t limit[] PROGMEM = {
-          (  MAX_1X_STEP_ISR_FREQUENCY     ),
-          (  MAX_2X_STEP_ISR_FREQUENCY >> 1),
-          (  MAX_4X_STEP_ISR_FREQUENCY >> 2),
-          (  MAX_8X_STEP_ISR_FREQUENCY >> 3),
-          ( MAX_16X_STEP_ISR_FREQUENCY >> 4),
-          ( MAX_32X_STEP_ISR_FREQUENCY >> 5),
-          ( MAX_64X_STEP_ISR_FREQUENCY >> 6),
-          (MAX_128X_STEP_ISR_FREQUENCY >> 7)
+          (  MAX_STEP_ISR_FREQUENCY_1X     ),
+          (  MAX_STEP_ISR_FREQUENCY_2X >> 1),
+          (  MAX_STEP_ISR_FREQUENCY_4X >> 2),
+          (  MAX_STEP_ISR_FREQUENCY_8X >> 3),
+          ( MAX_STEP_ISR_FREQUENCY_16X >> 4),
+          ( MAX_STEP_ISR_FREQUENCY_32X >> 5),
+          ( MAX_STEP_ISR_FREQUENCY_64X >> 6),
+          (MAX_STEP_ISR_FREQUENCY_128X >> 7)
         };
 
         // Select the proper multistepping
         uint8_t idx = 0;
         while (idx < 7 && step_rate > (uint32_t)pgm_read_dword(&limit[idx])) {
           step_rate >>= 1;
           multistep <<= 1;
           ++idx;
         };
       #else
-        NOMORE(step_rate, uint32_t(MAX_1X_STEP_ISR_FREQUENCY));
+        NOMORE(step_rate, uint32_t(MAX_STEP_ISR_FREQUENCY_1X));
       #endif
       *loops = multistep;
 
       #ifdef CPU_32_BIT
         // In case of high-performance processor, it is able to calculate in real-time
         timer = uint32_t(STEPPER_TIMER_RATE) / step_rate;
       #else
         constexpr uint32_t min_step_rate = F_CPU / 500000U;
         NOLESS(step_rate, min_step_rate);
         step_rate -= min_step_rate; // Correct for minimal speed
@@ -360,11 +510,13 @@ class Stepper {
     #if HAS_DIGIPOTSS || HAS_MOTOR_CURRENT_PWM
       static void digipot_init();
     #endif
 
     #if HAS_MICROSTEPS
       static void microstep_init();
     #endif
 
 };
 
+extern Stepper stepper;
+
 #endif // STEPPER_H

commit 4dbec774b5839df5c0ec0b078f21bb2e07b86707
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Jun 12 16:32:22 2018 -0500

    HAL_*_TIMER_RATE => *_TIMER_RATE

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index bda5a69ec7..83fe45de48 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -320,21 +320,21 @@ class Stepper {
           multistep <<= 1;
           ++idx;
         };
       #else
         NOMORE(step_rate, uint32_t(MAX_1X_STEP_ISR_FREQUENCY));
       #endif
       *loops = multistep;
 
       #ifdef CPU_32_BIT
         // In case of high-performance processor, it is able to calculate in real-time
-        timer = uint32_t(HAL_STEPPER_TIMER_RATE) / step_rate;
+        timer = uint32_t(STEPPER_TIMER_RATE) / step_rate;
       #else
         constexpr uint32_t min_step_rate = F_CPU / 500000U;
         NOLESS(step_rate, min_step_rate);
         step_rate -= min_step_rate; // Correct for minimal speed
         if (step_rate >= (8 * 256)) { // higher step rate
           const uint8_t tmp_step_rate = (step_rate & 0x00FF);
           const uint16_t table_address = (uint16_t)&speed_lookuptable_fast[(uint8_t)(step_rate >> 8)][0],
                          gain = (uint16_t)pgm_read_word_near(table_address + 2);
           timer = MultiU16X8toH16(tmp_step_rate, gain);
           timer = (uint16_t)pgm_read_word_near(table_address) - timer;

commit 43bdd0bfe4beda8877b0445faf23f3bbcf8b20d0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Jun 11 19:12:56 2018 -0500

    Fix indent in stepper.h

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 427b97f80a..bda5a69ec7 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -262,33 +262,33 @@ class Stepper {
       planner.synchronize();
       const bool was_enabled = STEPPER_ISR_ENABLED();
       if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
       _set_position(a, b, c, e);
       if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
     }
 
     inline static void set_position(const AxisEnum a, const int32_t &v) {
       planner.synchronize();
 
-    #ifdef __AVR__
-      // Protect the access to the position. Only required for AVR, as
-      //  any 32bit CPU offers atomic access to 32bit variables
-      const bool was_enabled = STEPPER_ISR_ENABLED();
-      if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
-    #endif
+      #ifdef __AVR__
+        // Protect the access to the position. Only required for AVR, as
+        //  any 32bit CPU offers atomic access to 32bit variables
+        const bool was_enabled = STEPPER_ISR_ENABLED();
+        if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
+      #endif
 
       count_position[a] = v;
 
-    #ifdef __AVR__
-      // Reenable Stepper ISR
-      if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
-    #endif
+      #ifdef __AVR__
+        // Reenable Stepper ISR
+        if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
+      #endif
     }
 
   private:
 
     // Set the current position in steps
     static void _set_position(const int32_t &a, const int32_t &b, const int32_t &c, const int32_t &e);
 
     // Set direction bits for all steppers
     static void set_directions();
 

commit 39a7e7720d0b14e7c55b65d7da7973b528d184c7
Author: etagle <ejtagle@hotmail.com>
Date:   Sun Jun 3 00:59:21 2018 -0300

    Adaptive multiaxis step smoothing
    
    - Stepper bugs fixed
    - Support MIXING_EXTRUDER with Linear Advance
    - Miscellaneous cleanup

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 951847d54f..427b97f80a 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -69,99 +69,104 @@ class Stepper {
     #if HAS_MOTOR_CURRENT_PWM
       #ifndef PWM_MOTOR_CURRENT
         #define PWM_MOTOR_CURRENT DEFAULT_PWM_MOTOR_CURRENT
       #endif
       static uint32_t motor_current_setting[3];
     #endif
 
   private:
 
     static uint8_t last_direction_bits,     // The next stepping-bits to be output
-                   last_movement_extruder,  // Last movement extruder, as computed when the last movement was fetched from planner
                    axis_did_move;           // Last Movement in the given direction is not null, as computed when the last movement was fetched from planner
+
     static bool abort_current_block;        // Signals to the stepper that current block should be aborted
 
+    #if DISABLED(MIXING_EXTRUDER)
+      static uint8_t last_moved_extruder;   // Last-moved extruder, as set when the last movement was fetched from planner
+    #endif
+
     #if ENABLED(X_DUAL_ENDSTOPS)
       static bool locked_X_motor, locked_X2_motor;
     #endif
     #if ENABLED(Y_DUAL_ENDSTOPS)
       static bool locked_Y_motor, locked_Y2_motor;
     #endif
     #if ENABLED(Z_DUAL_ENDSTOPS)
       static bool locked_Z_motor, locked_Z2_motor;
     #endif
 
-    // Counter variables for the Bresenham line tracer
-    static int32_t counter_X, counter_Y, counter_Z, counter_E;
-    static uint32_t step_events_completed; // The number of step events executed in the current block
+    static uint32_t acceleration_time, deceleration_time; // time measured in Stepper Timer ticks
+    static uint8_t steps_per_isr;         // Count of steps to perform per Stepper ISR call
+
+    #if ENABLED(ADAPTIVE_STEP_SMOOTHING)
+      static uint8_t oversampling_factor; // Oversampling factor (log2(multiplier)) to increase temporal resolution of axis
+    #else
+      static constexpr uint8_t oversampling_factor = 0;
+    #endif
+
+    // Delta error variables for the Bresenham line tracer
+    static int32_t delta_error[XYZE];
+    static uint32_t advance_dividend[XYZE],
+                    advance_divisor,
+                    step_events_completed,  // The number of step events executed in the current block
+                    accelerate_until,       // The point from where we need to stop acceleration
+                    decelerate_after,       // The point from where we need to start decelerating
+                    step_event_count;       // The total event count for the current block
+
+    // Mixing extruder mix delta_errors for bresenham tracing
+    #if ENABLED(MIXING_EXTRUDER)
+      static int32_t delta_error_m[MIXING_STEPPERS];
+      static uint32_t advance_dividend_m[MIXING_STEPPERS],
+                      advance_divisor_m;
+      #define MIXING_STEPPERS_LOOP(VAR) \
+        for (uint8_t VAR = 0; VAR < MIXING_STEPPERS; VAR++)
+    #else
+      static int8_t active_extruder;      // Active extruder
+    #endif
 
     #if ENABLED(S_CURVE_ACCELERATION)
       static int32_t bezier_A,     // A coefficient in B√©zier speed curve
                      bezier_B,     // B coefficient in B√©zier speed curve
                      bezier_C;     // C coefficient in B√©zier speed curve
       static uint32_t bezier_F,    // F coefficient in B√©zier speed curve
                       bezier_AV;   // AV coefficient in B√©zier speed curve
       #ifdef __AVR__
         static bool A_negative;    // If A coefficient was negative
       #endif
       static bool bezier_2nd_half; // If B√©zier curve has been initialized or not
     #endif
 
     static uint32_t nextMainISR;   // time remaining for the next Step ISR
-    static bool all_steps_done;    // all steps done
-
     #if ENABLED(LIN_ADVANCE)
-
-      static uint32_t LA_decelerate_after; // Copy from current executed block. Needed because current_block is set to NULL "too early".
-      static uint32_t nextAdvanceISR, eISR_Rate;
-      static uint16_t current_adv_steps, final_adv_steps, max_adv_steps; // Copy from current executed block. Needed because current_block is set to NULL "too early".
-      static int8_t e_steps;
-      static bool use_advance_lead;
-      #if E_STEPPERS > 1
-        static int8_t LA_active_extruder; // Copy from current executed block. Needed because current_block is set to NULL "too early".
-      #else
-        static constexpr int8_t LA_active_extruder = 0;
-      #endif
-
+      static uint32_t nextAdvanceISR, LA_isr_rate;
+      static uint16_t LA_current_adv_steps, LA_final_adv_steps, LA_max_adv_steps; // Copy from current executed block. Needed because current_block is set to NULL "too early".
+      static int8_t LA_steps;
+      static bool LA_use_advance_lead;
     #endif // LIN_ADVANCE
 
-    static uint32_t acceleration_time, deceleration_time;
-    static uint8_t step_loops, step_loops_nominal;
-
-    static uint32_t ticks_nominal;
+    static int32_t ticks_nominal;
     #if DISABLED(S_CURVE_ACCELERATION)
       static uint32_t acc_step_rate; // needed for deceleration start point
     #endif
 
     static volatile int32_t endstops_trigsteps[XYZ];
-    static volatile int32_t endstops_stepsTotal, endstops_stepsDone;
 
     //
     // Positions of stepper motors, in step units
     //
     static volatile int32_t count_position[NUM_AXIS];
 
     //
     // Current direction of stepper motors (+1 or -1)
     //
     static int8_t count_direction[NUM_AXIS];
 
-    //
-    // Mixing extruder mix counters
-    //
-    #if ENABLED(MIXING_EXTRUDER)
-      static int32_t counter_m[MIXING_STEPPERS];
-      #define MIXING_STEPPERS_LOOP(VAR) \
-        for (uint8_t VAR = 0; VAR < MIXING_STEPPERS; VAR++) \
-          if (current_block->mix_event_count[VAR])
-    #endif
-
   public:
 
     //
     // Constructor / initializer
     //
     Stepper() { };
 
     // Initialize stepper hardware
     static void init();
 
@@ -194,21 +199,29 @@ class Stepper {
     // Quickly stop all steppers
     FORCE_INLINE static void quick_stop() { abort_current_block = true; }
 
     // The direction of a single motor
     FORCE_INLINE static bool motor_direction(const AxisEnum axis) { return TEST(last_direction_bits, axis); }
 
     // The last movement direction was not null on the specified axis. Note that motor direction is not necessarily the same.
     FORCE_INLINE static bool axis_is_moving(const AxisEnum axis) { return TEST(axis_did_move, axis); }
 
     // The extruder associated to the last movement
-    FORCE_INLINE static uint8_t movement_extruder() { return last_movement_extruder; }
+    FORCE_INLINE static uint8_t movement_extruder() {
+      return
+        #if ENABLED(MIXING_EXTRUDER)
+          0
+        #else
+          last_moved_extruder
+        #endif
+      ;
+    }
 
     // Handle a triggered endstop
     static void endstop_triggered(const AxisEnum axis);
 
     // Triggered position of an axis in steps
     static int32_t triggered_position(const AxisEnum axis);
 
     #if HAS_DIGIPOTSS || HAS_MOTOR_CURRENT_PWM
       static void digitalPotWrite(const int16_t address, const int16_t value);
       static void digipot_current(const uint8_t driver, const int16_t current);
@@ -272,69 +285,75 @@ class Stepper {
     }
 
   private:
 
     // Set the current position in steps
     static void _set_position(const int32_t &a, const int32_t &b, const int32_t &c, const int32_t &e);
 
     // Set direction bits for all steppers
     static void set_directions();
 
-    // Limit the speed to 10KHz for AVR
-    #ifndef STEP_DOUBLER_FREQUENCY
-      #define STEP_DOUBLER_FREQUENCY 10000
-    #endif
-
-    FORCE_INLINE static uint32_t calc_timer_interval(uint32_t step_rate) {
+    FORCE_INLINE static uint32_t calc_timer_interval(uint32_t step_rate, uint8_t scale, uint8_t* loops) {
       uint32_t timer;
 
-      NOMORE(step_rate, uint32_t(MAX_STEP_FREQUENCY));
+      // Scale the frequency, as requested by the caller
+      step_rate <<= scale;
 
+      uint8_t multistep = 1;
       #if DISABLED(DISABLE_MULTI_STEPPING)
-        if (step_rate > STEP_DOUBLER_FREQUENCY * 2) { // If steprate > (STEP_DOUBLER_FREQUENCY * 2) kHz >> step 4 times
-          step_rate >>= 2;
-          step_loops = 4;
-        }
-        else if (step_rate > STEP_DOUBLER_FREQUENCY) { // If steprate > STEP_DOUBLER_FREQUENCY kHz >> step 2 times
+
+        // The stepping frequency limits for each multistepping rate
+        static const uint32_t limit[] PROGMEM = {
+          (  MAX_1X_STEP_ISR_FREQUENCY     ),
+          (  MAX_2X_STEP_ISR_FREQUENCY >> 1),
+          (  MAX_4X_STEP_ISR_FREQUENCY >> 2),
+          (  MAX_8X_STEP_ISR_FREQUENCY >> 3),
+          ( MAX_16X_STEP_ISR_FREQUENCY >> 4),
+          ( MAX_32X_STEP_ISR_FREQUENCY >> 5),
+          ( MAX_64X_STEP_ISR_FREQUENCY >> 6),
+          (MAX_128X_STEP_ISR_FREQUENCY >> 7)
+        };
+
+        // Select the proper multistepping
+        uint8_t idx = 0;
+        while (idx < 7 && step_rate > (uint32_t)pgm_read_dword(&limit[idx])) {
           step_rate >>= 1;
-          step_loops = 2;
-        }
-        else
+          multistep <<= 1;
+          ++idx;
+        };
+      #else
+        NOMORE(step_rate, uint32_t(MAX_1X_STEP_ISR_FREQUENCY));
       #endif
-          step_loops = 1;
+      *loops = multistep;
 
       #ifdef CPU_32_BIT
         // In case of high-performance processor, it is able to calculate in real-time
-        const uint32_t min_time_per_step = (HAL_STEPPER_TIMER_RATE) / ((STEP_DOUBLER_FREQUENCY) * 2);
         timer = uint32_t(HAL_STEPPER_TIMER_RATE) / step_rate;
-        NOLESS(timer, min_time_per_step); // (STEP_DOUBLER_FREQUENCY * 2 kHz - this should never happen)
       #else
         constexpr uint32_t min_step_rate = F_CPU / 500000U;
         NOLESS(step_rate, min_step_rate);
         step_rate -= min_step_rate; // Correct for minimal speed
         if (step_rate >= (8 * 256)) { // higher step rate
           const uint8_t tmp_step_rate = (step_rate & 0x00FF);
           const uint16_t table_address = (uint16_t)&speed_lookuptable_fast[(uint8_t)(step_rate >> 8)][0],
                          gain = (uint16_t)pgm_read_word_near(table_address + 2);
           timer = MultiU16X8toH16(tmp_step_rate, gain);
           timer = (uint16_t)pgm_read_word_near(table_address) - timer;
         }
         else { // lower step rates
           uint16_t table_address = (uint16_t)&speed_lookuptable_slow[0][0];
           table_address += ((step_rate) >> 1) & 0xFFFC;
           timer = (uint16_t)pgm_read_word_near(table_address)
                 - (((uint16_t)pgm_read_word_near(table_address + 2) * (uint8_t)(step_rate & 0x0007)) >> 3);
         }
-        if (timer < 100) { // (20kHz - this should never happen)
-          timer = 100;
-          SERIAL_ECHOLNPAIR(MSG_STEPPER_TOO_HIGH, step_rate);
-        }
+        // (there is no need to limit the timer value here. All limits have been
+        // applied above, and AVR is able to keep up at 30khz Stepping ISR rate)
       #endif
 
       return timer;
     }
 
     #if ENABLED(S_CURVE_ACCELERATION)
       static void _calc_bezier_curve_coeffs(const int32_t v0, const int32_t v1, const uint32_t av);
       static int32_t _eval_bezier_curve(const uint32_t curr_step);
     #endif
 

commit ad8d3150aa4d6b792b5e06a63d2645991136fc50
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Jun 2 20:39:00 2018 -0500

    Cleanup for dual endstops homing

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index d3dd06aa5e..951847d54f 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -56,21 +56,21 @@
 class Stepper;
 extern Stepper stepper;
 
 class Stepper {
 
   public:
 
     static block_t* current_block;  // A pointer to the block currently being traced
 
     #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
-      static bool performing_homing;
+      static bool homing_dual_axis;
     #endif
 
     #if HAS_MOTOR_CURRENT_PWM
       #ifndef PWM_MOTOR_CURRENT
         #define PWM_MOTOR_CURRENT DEFAULT_PWM_MOTOR_CURRENT
       #endif
       static uint32_t motor_current_setting[3];
     #endif
 
   private:
@@ -136,21 +136,21 @@ class Stepper {
     static volatile int32_t endstops_stepsTotal, endstops_stepsDone;
 
     //
     // Positions of stepper motors, in step units
     //
     static volatile int32_t count_position[NUM_AXIS];
 
     //
     // Current direction of stepper motors (+1 or -1)
     //
-    static volatile signed char count_direction[NUM_AXIS];
+    static int8_t count_direction[NUM_AXIS];
 
     //
     // Mixing extruder mix counters
     //
     #if ENABLED(MIXING_EXTRUDER)
       static int32_t counter_m[MIXING_STEPPERS];
       #define MIXING_STEPPERS_LOOP(VAR) \
         for (uint8_t VAR = 0; VAR < MIXING_STEPPERS; VAR++) \
           if (current_block->mix_event_count[VAR])
     #endif
@@ -213,56 +213,50 @@ class Stepper {
       static void digitalPotWrite(const int16_t address, const int16_t value);
       static void digipot_current(const uint8_t driver, const int16_t current);
     #endif
 
     #if HAS_MICROSTEPS
       static void microstep_ms(const uint8_t driver, const int8_t ms1, const int8_t ms2);
       static void microstep_mode(const uint8_t driver, const uint8_t stepping);
       static void microstep_readings();
     #endif
 
+    #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
+      FORCE_INLINE static void set_homing_dual_axis(const bool state) { homing_dual_axis = state; }
+    #endif
     #if ENABLED(X_DUAL_ENDSTOPS)
-      FORCE_INLINE static void set_homing_flag_x(const bool state) { performing_homing = state; }
       FORCE_INLINE static void set_x_lock(const bool state) { locked_X_motor = state; }
       FORCE_INLINE static void set_x2_lock(const bool state) { locked_X2_motor = state; }
     #endif
     #if ENABLED(Y_DUAL_ENDSTOPS)
-      FORCE_INLINE static void set_homing_flag_y(const bool state) { performing_homing = state; }
       FORCE_INLINE static void set_y_lock(const bool state) { locked_Y_motor = state; }
       FORCE_INLINE static void set_y2_lock(const bool state) { locked_Y2_motor = state; }
     #endif
     #if ENABLED(Z_DUAL_ENDSTOPS)
-      FORCE_INLINE static void set_homing_flag_z(const bool state) { performing_homing = state; }
       FORCE_INLINE static void set_z_lock(const bool state) { locked_Z_motor = state; }
       FORCE_INLINE static void set_z2_lock(const bool state) { locked_Z2_motor = state; }
     #endif
 
     #if ENABLED(BABYSTEPPING)
       static void babystep(const AxisEnum axis, const bool direction); // perform a short step with a single stepper motor, outside of any convention
     #endif
 
     #if HAS_MOTOR_CURRENT_PWM
       static void refresh_motor_power();
     #endif
 
     // Set the current position in steps
     inline static void set_position(const int32_t &a, const int32_t &b, const int32_t &c, const int32_t &e) {
       planner.synchronize();
-
-      // Disable stepper interrupts, to ensure atomic setting of all the position variables
       const bool was_enabled = STEPPER_ISR_ENABLED();
       if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
-
-      // Set position
       _set_position(a, b, c, e);
-
-      // Reenable Stepper ISR
       if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
     }
 
     inline static void set_position(const AxisEnum a, const int32_t &v) {
       planner.synchronize();
 
     #ifdef __AVR__
       // Protect the access to the position. Only required for AVR, as
       //  any 32bit CPU offers atomic access to 32bit variables
       const bool was_enabled = STEPPER_ISR_ENABLED();

commit d3c02410a84b369443654ef77f925562e9b87830
Author: Eduardo Jos√© Tagle <ejtagle@hotmail.com>
Date:   Fri Jun 1 21:02:22 2018 -0300

    [2.0.x] Small assorted collection of fixes and improvements (#10911)
    
    * Misc fixes and improvements
    
    - Get rid of most critical sections on the Serial port drivers for AVR and DUE. Proper usage of FIFOs should allow interrupts to stay enabled without harm to queuing and dequeuing.
      Also, with 8-bit indices (for AVR) and up to 32-bit indices (for ARM), there is no need to protect reads and writes to those indices.
    - Simplify the XON/XOFF logic quite a bit. Much cleaner now (both for AVR and ARM)
    - Prevent a race condition (edge case) that could happen when estimating the proper value for the stepper timer (by reading it) and writing the calculated value for the time to the next ISR by disabling interrupts in those critical and small sections of the code - The problem could lead to lost steps.
    - Fix dual endstops not properly homing bug (maybe).
    
    * Set position immediately when possible

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 19c9d4b9b5..d3dd06aa5e 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -74,27 +74,27 @@ class Stepper {
     #endif
 
   private:
 
     static uint8_t last_direction_bits,     // The next stepping-bits to be output
                    last_movement_extruder,  // Last movement extruder, as computed when the last movement was fetched from planner
                    axis_did_move;           // Last Movement in the given direction is not null, as computed when the last movement was fetched from planner
     static bool abort_current_block;        // Signals to the stepper that current block should be aborted
 
     #if ENABLED(X_DUAL_ENDSTOPS)
-      static bool locked_x_motor, locked_x2_motor;
+      static bool locked_X_motor, locked_X2_motor;
     #endif
     #if ENABLED(Y_DUAL_ENDSTOPS)
-      static bool locked_y_motor, locked_y2_motor;
+      static bool locked_Y_motor, locked_Y2_motor;
     #endif
     #if ENABLED(Z_DUAL_ENDSTOPS)
-      static bool locked_z_motor, locked_z2_motor;
+      static bool locked_Z_motor, locked_Z2_motor;
     #endif
 
     // Counter variables for the Bresenham line tracer
     static int32_t counter_X, counter_Y, counter_Z, counter_E;
     static uint32_t step_events_completed; // The number of step events executed in the current block
 
     #if ENABLED(S_CURVE_ACCELERATION)
       static int32_t bezier_A,     // A coefficient in B√©zier speed curve
                      bezier_B,     // B coefficient in B√©zier speed curve
                      bezier_C;     // C coefficient in B√©zier speed curve
@@ -161,21 +161,21 @@ class Stepper {
     // Constructor / initializer
     //
     Stepper() { };
 
     // Initialize stepper hardware
     static void init();
 
     // Interrupt Service Routines
 
     // The ISR scheduler
-    static hal_timer_t isr_scheduler();
+    static void isr();
 
     // The stepper pulse phase ISR
     static void stepper_pulse_phase_isr();
 
     // The stepper block processing phase ISR
     static uint32_t stepper_block_phase_isr();
 
     #if ENABLED(LIN_ADVANCE)
       // The Linear advance stepper ISR
       static uint32_t advance_isr();
@@ -215,55 +215,73 @@ class Stepper {
     #endif
 
     #if HAS_MICROSTEPS
       static void microstep_ms(const uint8_t driver, const int8_t ms1, const int8_t ms2);
       static void microstep_mode(const uint8_t driver, const uint8_t stepping);
       static void microstep_readings();
     #endif
 
     #if ENABLED(X_DUAL_ENDSTOPS)
       FORCE_INLINE static void set_homing_flag_x(const bool state) { performing_homing = state; }
-      FORCE_INLINE static void set_x_lock(const bool state) { locked_x_motor = state; }
-      FORCE_INLINE static void set_x2_lock(const bool state) { locked_x2_motor = state; }
+      FORCE_INLINE static void set_x_lock(const bool state) { locked_X_motor = state; }
+      FORCE_INLINE static void set_x2_lock(const bool state) { locked_X2_motor = state; }
     #endif
     #if ENABLED(Y_DUAL_ENDSTOPS)
       FORCE_INLINE static void set_homing_flag_y(const bool state) { performing_homing = state; }
-      FORCE_INLINE static void set_y_lock(const bool state) { locked_y_motor = state; }
-      FORCE_INLINE static void set_y2_lock(const bool state) { locked_y2_motor = state; }
+      FORCE_INLINE static void set_y_lock(const bool state) { locked_Y_motor = state; }
+      FORCE_INLINE static void set_y2_lock(const bool state) { locked_Y2_motor = state; }
     #endif
     #if ENABLED(Z_DUAL_ENDSTOPS)
       FORCE_INLINE static void set_homing_flag_z(const bool state) { performing_homing = state; }
-      FORCE_INLINE static void set_z_lock(const bool state) { locked_z_motor = state; }
-      FORCE_INLINE static void set_z2_lock(const bool state) { locked_z2_motor = state; }
+      FORCE_INLINE static void set_z_lock(const bool state) { locked_Z_motor = state; }
+      FORCE_INLINE static void set_z2_lock(const bool state) { locked_Z2_motor = state; }
     #endif
 
     #if ENABLED(BABYSTEPPING)
       static void babystep(const AxisEnum axis, const bool direction); // perform a short step with a single stepper motor, outside of any convention
     #endif
 
     #if HAS_MOTOR_CURRENT_PWM
       static void refresh_motor_power();
     #endif
 
     // Set the current position in steps
     inline static void set_position(const int32_t &a, const int32_t &b, const int32_t &c, const int32_t &e) {
       planner.synchronize();
-      CRITICAL_SECTION_START;
+
+      // Disable stepper interrupts, to ensure atomic setting of all the position variables
+      const bool was_enabled = STEPPER_ISR_ENABLED();
+      if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
+
+      // Set position
       _set_position(a, b, c, e);
-      CRITICAL_SECTION_END;
+
+      // Reenable Stepper ISR
+      if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
     }
 
     inline static void set_position(const AxisEnum a, const int32_t &v) {
       planner.synchronize();
-      CRITICAL_SECTION_START;
+
+    #ifdef __AVR__
+      // Protect the access to the position. Only required for AVR, as
+      //  any 32bit CPU offers atomic access to 32bit variables
+      const bool was_enabled = STEPPER_ISR_ENABLED();
+      if (was_enabled) DISABLE_STEPPER_DRIVER_INTERRUPT();
+    #endif
+
       count_position[a] = v;
-      CRITICAL_SECTION_END;
+
+    #ifdef __AVR__
+      // Reenable Stepper ISR
+      if (was_enabled) ENABLE_STEPPER_DRIVER_INTERRUPT();
+    #endif
     }
 
   private:
 
     // Set the current position in steps
     static void _set_position(const int32_t &a, const int32_t &b, const int32_t &c, const int32_t &e);
 
     // Set direction bits for all steppers
     static void set_directions();
 

commit 6919e876561eb2729419212e7887b6d34748bc93
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon May 28 17:39:23 2018 -0500

    Minor cleanup of multi-stepping logic

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index d10b8c32ed..19c9d4b9b5 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -260,64 +260,52 @@ class Stepper {
     }
 
   private:
 
     // Set the current position in steps
     static void _set_position(const int32_t &a, const int32_t &b, const int32_t &c, const int32_t &e);
 
     // Set direction bits for all steppers
     static void set_directions();
 
+    // Limit the speed to 10KHz for AVR
+    #ifndef STEP_DOUBLER_FREQUENCY
+      #define STEP_DOUBLER_FREQUENCY 10000
+    #endif
+
     FORCE_INLINE static uint32_t calc_timer_interval(uint32_t step_rate) {
       uint32_t timer;
 
       NOMORE(step_rate, uint32_t(MAX_STEP_FREQUENCY));
 
-      // TODO: HAL: tidy this up, use Conditionals_post.h
-      #ifdef CPU_32_BIT
-        #if ENABLED(DISABLE_MULTI_STEPPING)
-          step_loops = 1;
-        #else
-          if (step_rate > STEP_DOUBLER_FREQUENCY * 2) { // If steprate > (STEP_DOUBLER_FREQUENCY * 2) kHz >> step 4 times
-            step_rate >>= 2;
-            step_loops = 4;
-          }
-          else if (step_rate > STEP_DOUBLER_FREQUENCY) { // If steprate > STEP_DOUBLER_FREQUENCY kHz >> step 2 times
-            step_rate >>= 1;
-            step_loops = 2;
-          }
-          else {
-            step_loops = 1;
-          }
-        #endif
-      #else
-        if (step_rate > 20000) { // If steprate > 20kHz >> step 4 times
+      #if DISABLED(DISABLE_MULTI_STEPPING)
+        if (step_rate > STEP_DOUBLER_FREQUENCY * 2) { // If steprate > (STEP_DOUBLER_FREQUENCY * 2) kHz >> step 4 times
           step_rate >>= 2;
           step_loops = 4;
         }
-        else if (step_rate > 10000) { // If steprate > 10kHz >> step 2 times
+        else if (step_rate > STEP_DOUBLER_FREQUENCY) { // If steprate > STEP_DOUBLER_FREQUENCY kHz >> step 2 times
           step_rate >>= 1;
           step_loops = 2;
         }
-        else {
-          step_loops = 1;
-        }
+        else
       #endif
+          step_loops = 1;
 
       #ifdef CPU_32_BIT
         // In case of high-performance processor, it is able to calculate in real-time
         const uint32_t min_time_per_step = (HAL_STEPPER_TIMER_RATE) / ((STEP_DOUBLER_FREQUENCY) * 2);
         timer = uint32_t(HAL_STEPPER_TIMER_RATE) / step_rate;
         NOLESS(timer, min_time_per_step); // (STEP_DOUBLER_FREQUENCY * 2 kHz - this should never happen)
       #else
-        NOLESS(step_rate, uint32_t(F_CPU / 500000U));
-        step_rate -= F_CPU / 500000; // Correct for minimal speed
+        constexpr uint32_t min_step_rate = F_CPU / 500000U;
+        NOLESS(step_rate, min_step_rate);
+        step_rate -= min_step_rate; // Correct for minimal speed
         if (step_rate >= (8 * 256)) { // higher step rate
           const uint8_t tmp_step_rate = (step_rate & 0x00FF);
           const uint16_t table_address = (uint16_t)&speed_lookuptable_fast[(uint8_t)(step_rate >> 8)][0],
                          gain = (uint16_t)pgm_read_word_near(table_address + 2);
           timer = MultiU16X8toH16(tmp_step_rate, gain);
           timer = (uint16_t)pgm_read_word_near(table_address) - timer;
         }
         else { // lower step rates
           uint16_t table_address = (uint16_t)&speed_lookuptable_slow[0][0];
           table_address += ((step_rate) >> 1) & 0xFFFC;

commit aaaf09bda27eff38d773b4b73925442f61d34866
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat May 26 02:02:39 2018 -0500

    BEZIER_JERK_CONTROL => S_CURVE_ACCELERATION

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 6264560ffb..d10b8c32ed 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -87,21 +87,21 @@ class Stepper {
       static bool locked_y_motor, locked_y2_motor;
     #endif
     #if ENABLED(Z_DUAL_ENDSTOPS)
       static bool locked_z_motor, locked_z2_motor;
     #endif
 
     // Counter variables for the Bresenham line tracer
     static int32_t counter_X, counter_Y, counter_Z, counter_E;
     static uint32_t step_events_completed; // The number of step events executed in the current block
 
-    #if ENABLED(BEZIER_JERK_CONTROL)
+    #if ENABLED(S_CURVE_ACCELERATION)
       static int32_t bezier_A,     // A coefficient in B√©zier speed curve
                      bezier_B,     // B coefficient in B√©zier speed curve
                      bezier_C;     // C coefficient in B√©zier speed curve
       static uint32_t bezier_F,    // F coefficient in B√©zier speed curve
                       bezier_AV;   // AV coefficient in B√©zier speed curve
       #ifdef __AVR__
         static bool A_negative;    // If A coefficient was negative
       #endif
       static bool bezier_2nd_half; // If B√©zier curve has been initialized or not
     #endif
@@ -121,21 +121,21 @@ class Stepper {
       #else
         static constexpr int8_t LA_active_extruder = 0;
       #endif
 
     #endif // LIN_ADVANCE
 
     static uint32_t acceleration_time, deceleration_time;
     static uint8_t step_loops, step_loops_nominal;
 
     static uint32_t ticks_nominal;
-    #if DISABLED(BEZIER_JERK_CONTROL)
+    #if DISABLED(S_CURVE_ACCELERATION)
       static uint32_t acc_step_rate; // needed for deceleration start point
     #endif
 
     static volatile int32_t endstops_trigsteps[XYZ];
     static volatile int32_t endstops_stepsTotal, endstops_stepsDone;
 
     //
     // Positions of stepper motors, in step units
     //
     static volatile int32_t count_position[NUM_AXIS];
@@ -326,21 +326,21 @@ class Stepper {
         }
         if (timer < 100) { // (20kHz - this should never happen)
           timer = 100;
           SERIAL_ECHOLNPAIR(MSG_STEPPER_TOO_HIGH, step_rate);
         }
       #endif
 
       return timer;
     }
 
-    #if ENABLED(BEZIER_JERK_CONTROL)
+    #if ENABLED(S_CURVE_ACCELERATION)
       static void _calc_bezier_curve_coeffs(const int32_t v0, const int32_t v1, const uint32_t av);
       static int32_t _eval_bezier_curve(const uint32_t curr_step);
     #endif
 
     #if HAS_DIGIPOTSS || HAS_MOTOR_CURRENT_PWM
       static void digipot_init();
     #endif
 
     #if HAS_MICROSTEPS
       static void microstep_init();

commit 3e3789da85e4d25693506df9dfd094aabf98d50e
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Wed May 23 03:45:25 2018 -0500

    Regression: Endstops Core compatibility (#10823)
    
    Co-Authored-By: ejtagle <ejtagle@hotmail.com>

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index c8407fb6ad..6264560ffb 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -68,24 +68,24 @@ class Stepper {
 
     #if HAS_MOTOR_CURRENT_PWM
       #ifndef PWM_MOTOR_CURRENT
         #define PWM_MOTOR_CURRENT DEFAULT_PWM_MOTOR_CURRENT
       #endif
       static uint32_t motor_current_setting[3];
     #endif
 
   private:
 
-    static uint8_t last_direction_bits,           // The next stepping-bits to be output
-                   last_movement_extruder;        // Last movement extruder, as computed when the last movement was fetched from planner
-    static bool abort_current_block,              // Signals to the stepper that current block should be aborted
-                last_movement_non_null[NUM_AXIS]; // Last Movement in the given direction is not null, as computed when the last movement was fetched from planner
+    static uint8_t last_direction_bits,     // The next stepping-bits to be output
+                   last_movement_extruder,  // Last movement extruder, as computed when the last movement was fetched from planner
+                   axis_did_move;           // Last Movement in the given direction is not null, as computed when the last movement was fetched from planner
+    static bool abort_current_block;        // Signals to the stepper that current block should be aborted
 
     #if ENABLED(X_DUAL_ENDSTOPS)
       static bool locked_x_motor, locked_x2_motor;
     #endif
     #if ENABLED(Y_DUAL_ENDSTOPS)
       static bool locked_y_motor, locked_y2_motor;
     #endif
     #if ENABLED(Z_DUAL_ENDSTOPS)
       static bool locked_z_motor, locked_z2_motor;
     #endif
@@ -191,21 +191,21 @@ class Stepper {
     // to notify the subsystem that it is time to go to work.
     static void wake_up();
 
     // Quickly stop all steppers
     FORCE_INLINE static void quick_stop() { abort_current_block = true; }
 
     // The direction of a single motor
     FORCE_INLINE static bool motor_direction(const AxisEnum axis) { return TEST(last_direction_bits, axis); }
 
     // The last movement direction was not null on the specified axis. Note that motor direction is not necessarily the same.
-    FORCE_INLINE static bool movement_non_null(const AxisEnum axis) { return last_movement_non_null[axis]; }
+    FORCE_INLINE static bool axis_is_moving(const AxisEnum axis) { return TEST(axis_did_move, axis); }
 
     // The extruder associated to the last movement
     FORCE_INLINE static uint8_t movement_extruder() { return last_movement_extruder; }
 
     // Handle a triggered endstop
     static void endstop_triggered(const AxisEnum axis);
 
     // Triggered position of an axis in steps
     static int32_t triggered_position(const AxisEnum axis);
 
@@ -319,22 +319,21 @@ class Stepper {
           timer = (uint16_t)pgm_read_word_near(table_address) - timer;
         }
         else { // lower step rates
           uint16_t table_address = (uint16_t)&speed_lookuptable_slow[0][0];
           table_address += ((step_rate) >> 1) & 0xFFFC;
           timer = (uint16_t)pgm_read_word_near(table_address)
                 - (((uint16_t)pgm_read_word_near(table_address + 2) * (uint8_t)(step_rate & 0x0007)) >> 3);
         }
         if (timer < 100) { // (20kHz - this should never happen)
           timer = 100;
-          SERIAL_ECHOPGM(MSG_STEPPER_TOO_HIGH);
-          SERIAL_ECHOLN(step_rate);
+          SERIAL_ECHOLNPAIR(MSG_STEPPER_TOO_HIGH, step_rate);
         }
       #endif
 
       return timer;
     }
 
     #if ENABLED(BEZIER_JERK_CONTROL)
       static void _calc_bezier_curve_coeffs(const int32_t v0, const int32_t v1, const uint32_t av);
       static int32_t _eval_bezier_curve(const uint32_t curr_step);
     #endif

commit 65a004564ca95b810a682f224c0b05fbf804dc8b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon May 21 15:05:17 2018 -0500

    Stepper::set_position needed for some applications

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index a251d070b5..c8407fb6ad 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -237,20 +237,35 @@ class Stepper {
     #endif
 
     #if ENABLED(BABYSTEPPING)
       static void babystep(const AxisEnum axis, const bool direction); // perform a short step with a single stepper motor, outside of any convention
     #endif
 
     #if HAS_MOTOR_CURRENT_PWM
       static void refresh_motor_power();
     #endif
 
+    // Set the current position in steps
+    inline static void set_position(const int32_t &a, const int32_t &b, const int32_t &c, const int32_t &e) {
+      planner.synchronize();
+      CRITICAL_SECTION_START;
+      _set_position(a, b, c, e);
+      CRITICAL_SECTION_END;
+    }
+
+    inline static void set_position(const AxisEnum a, const int32_t &v) {
+      planner.synchronize();
+      CRITICAL_SECTION_START;
+      count_position[a] = v;
+      CRITICAL_SECTION_END;
+    }
+
   private:
 
     // Set the current position in steps
     static void _set_position(const int32_t &a, const int32_t &b, const int32_t &c, const int32_t &e);
 
     // Set direction bits for all steppers
     static void set_directions();
 
     FORCE_INLINE static uint32_t calc_timer_interval(uint32_t step_rate) {
       uint32_t timer;

commit 435ecb6b67e285becad4e6ca8375ffc8b5cb6025
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun May 20 22:20:11 2018 -0500

    Followup to stepper/planner refactor

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index bda1bd5b07..a251d070b5 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -91,22 +91,22 @@ class Stepper {
     #endif
 
     // Counter variables for the Bresenham line tracer
     static int32_t counter_X, counter_Y, counter_Z, counter_E;
     static uint32_t step_events_completed; // The number of step events executed in the current block
 
     #if ENABLED(BEZIER_JERK_CONTROL)
       static int32_t bezier_A,     // A coefficient in B√©zier speed curve
                      bezier_B,     // B coefficient in B√©zier speed curve
                      bezier_C;     // C coefficient in B√©zier speed curve
-      static uint32_t bezier_F;    // F coefficient in B√©zier speed curve
-      static uint32_t bezier_AV;   // AV coefficient in B√©zier speed curve
+      static uint32_t bezier_F,    // F coefficient in B√©zier speed curve
+                      bezier_AV;   // AV coefficient in B√©zier speed curve
       #ifdef __AVR__
         static bool A_negative;    // If A coefficient was negative
       #endif
       static bool bezier_2nd_half; // If B√©zier curve has been initialized or not
     #endif
 
     static uint32_t nextMainISR;   // time remaining for the next Step ISR
     static bool all_steps_done;    // all steps done
 
     #if ENABLED(LIN_ADVANCE)
@@ -290,23 +290,23 @@ class Stepper {
 
       #ifdef CPU_32_BIT
         // In case of high-performance processor, it is able to calculate in real-time
         const uint32_t min_time_per_step = (HAL_STEPPER_TIMER_RATE) / ((STEP_DOUBLER_FREQUENCY) * 2);
         timer = uint32_t(HAL_STEPPER_TIMER_RATE) / step_rate;
         NOLESS(timer, min_time_per_step); // (STEP_DOUBLER_FREQUENCY * 2 kHz - this should never happen)
       #else
         NOLESS(step_rate, uint32_t(F_CPU / 500000U));
         step_rate -= F_CPU / 500000; // Correct for minimal speed
         if (step_rate >= (8 * 256)) { // higher step rate
-          uint8_t tmp_step_rate = (step_rate & 0x00FF);
-          uint16_t table_address = (uint16_t)&speed_lookuptable_fast[(uint8_t)(step_rate >> 8)][0],
-                   gain = (uint16_t)pgm_read_word_near(table_address + 2);
+          const uint8_t tmp_step_rate = (step_rate & 0x00FF);
+          const uint16_t table_address = (uint16_t)&speed_lookuptable_fast[(uint8_t)(step_rate >> 8)][0],
+                         gain = (uint16_t)pgm_read_word_near(table_address + 2);
           timer = MultiU16X8toH16(tmp_step_rate, gain);
           timer = (uint16_t)pgm_read_word_near(table_address) - timer;
         }
         else { // lower step rates
           uint16_t table_address = (uint16_t)&speed_lookuptable_slow[0][0];
           table_address += ((step_rate) >> 1) & 0xFFFC;
           timer = (uint16_t)pgm_read_word_near(table_address)
                 - (((uint16_t)pgm_read_word_near(table_address + 2) * (uint8_t)(step_rate & 0x0007)) >> 3);
         }
         if (timer < 100) { // (20kHz - this should never happen)

commit 569df3fc0ccb8b000cc56dd55e6369008ed3f7a2
Author: etagle <ejtagle@hotmail.com>
Date:   Wed May 16 04:08:43 2018 -0300

    Fix interrupt-based endstop detection
    
    - Also implemented real endstop reading on interrupt.

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 450de469ad..bda1bd5b07 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -68,21 +68,24 @@ class Stepper {
 
     #if HAS_MOTOR_CURRENT_PWM
       #ifndef PWM_MOTOR_CURRENT
         #define PWM_MOTOR_CURRENT DEFAULT_PWM_MOTOR_CURRENT
       #endif
       static uint32_t motor_current_setting[3];
     #endif
 
   private:
 
-    static uint8_t last_direction_bits;        // The next stepping-bits to be output
+    static uint8_t last_direction_bits,           // The next stepping-bits to be output
+                   last_movement_extruder;        // Last movement extruder, as computed when the last movement was fetched from planner
+    static bool abort_current_block,              // Signals to the stepper that current block should be aborted
+                last_movement_non_null[NUM_AXIS]; // Last Movement in the given direction is not null, as computed when the last movement was fetched from planner
 
     #if ENABLED(X_DUAL_ENDSTOPS)
       static bool locked_x_motor, locked_x2_motor;
     #endif
     #if ENABLED(Y_DUAL_ENDSTOPS)
       static bool locked_y_motor, locked_y2_motor;
     #endif
     #if ENABLED(Z_DUAL_ENDSTOPS)
       static bool locked_z_motor, locked_z2_motor;
     #endif
@@ -182,27 +185,30 @@ class Stepper {
     static int32_t position(const AxisEnum axis);
 
     // Report the positions of the steppers, in steps
     static void report_positions();
 
     // The stepper subsystem goes to sleep when it runs out of things to execute. Call this
     // to notify the subsystem that it is time to go to work.
     static void wake_up();
 
     // Quickly stop all steppers
-    static void quick_stop();
+    FORCE_INLINE static void quick_stop() { abort_current_block = true; }
 
     // The direction of a single motor
     FORCE_INLINE static bool motor_direction(const AxisEnum axis) { return TEST(last_direction_bits, axis); }
 
-    // Kill current block
-    static void kill_current_block();
+    // The last movement direction was not null on the specified axis. Note that motor direction is not necessarily the same.
+    FORCE_INLINE static bool movement_non_null(const AxisEnum axis) { return last_movement_non_null[axis]; }
+
+    // The extruder associated to the last movement
+    FORCE_INLINE static uint8_t movement_extruder() { return last_movement_extruder; }
 
     // Handle a triggered endstop
     static void endstop_triggered(const AxisEnum axis);
 
     // Triggered position of an axis in steps
     static int32_t triggered_position(const AxisEnum axis);
 
     #if HAS_DIGIPOTSS || HAS_MOTOR_CURRENT_PWM
       static void digitalPotWrite(const int16_t address, const int16_t value);
       static void digipot_current(const uint8_t driver, const int16_t current);
@@ -242,21 +248,21 @@ class Stepper {
 
     // Set the current position in steps
     static void _set_position(const int32_t &a, const int32_t &b, const int32_t &c, const int32_t &e);
 
     // Set direction bits for all steppers
     static void set_directions();
 
     FORCE_INLINE static uint32_t calc_timer_interval(uint32_t step_rate) {
       uint32_t timer;
 
-      NOMORE(step_rate, MAX_STEP_FREQUENCY);
+      NOMORE(step_rate, uint32_t(MAX_STEP_FREQUENCY));
 
       // TODO: HAL: tidy this up, use Conditionals_post.h
       #ifdef CPU_32_BIT
         #if ENABLED(DISABLE_MULTI_STEPPING)
           step_loops = 1;
         #else
           if (step_rate > STEP_DOUBLER_FREQUENCY * 2) { // If steprate > (STEP_DOUBLER_FREQUENCY * 2) kHz >> step 4 times
             step_rate >>= 2;
             step_loops = 4;
           }
@@ -281,21 +287,21 @@ class Stepper {
           step_loops = 1;
         }
       #endif
 
       #ifdef CPU_32_BIT
         // In case of high-performance processor, it is able to calculate in real-time
         const uint32_t min_time_per_step = (HAL_STEPPER_TIMER_RATE) / ((STEP_DOUBLER_FREQUENCY) * 2);
         timer = uint32_t(HAL_STEPPER_TIMER_RATE) / step_rate;
         NOLESS(timer, min_time_per_step); // (STEP_DOUBLER_FREQUENCY * 2 kHz - this should never happen)
       #else
-        NOLESS(step_rate, F_CPU / 500000);
+        NOLESS(step_rate, uint32_t(F_CPU / 500000U));
         step_rate -= F_CPU / 500000; // Correct for minimal speed
         if (step_rate >= (8 * 256)) { // higher step rate
           uint8_t tmp_step_rate = (step_rate & 0x00FF);
           uint16_t table_address = (uint16_t)&speed_lookuptable_fast[(uint8_t)(step_rate >> 8)][0],
                    gain = (uint16_t)pgm_read_word_near(table_address + 2);
           timer = MultiU16X8toH16(tmp_step_rate, gain);
           timer = (uint16_t)pgm_read_word_near(table_address) - timer;
         }
         else { // lower step rates
           uint16_t table_address = (uint16_t)&speed_lookuptable_slow[0][0];

commit a11eb50a3eab6d58d595a67e526fb51190018db3
Author: etagle <ejtagle@hotmail.com>
Date:   Wed May 9 02:17:53 2018 -0300

    Refactor and optimize Stepper/Planner
    
    Better encapsulation and considerably reduce stepper jitter

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 6a03ed3948..450de469ad 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -55,93 +55,85 @@
 
 class Stepper;
 extern Stepper stepper;
 
 class Stepper {
 
   public:
 
     static block_t* current_block;  // A pointer to the block currently being traced
 
-    #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
-      static bool abort_on_endstop_hit;
-    #endif
-
     #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
       static bool performing_homing;
     #endif
 
     #if HAS_MOTOR_CURRENT_PWM
       #ifndef PWM_MOTOR_CURRENT
         #define PWM_MOTOR_CURRENT DEFAULT_PWM_MOTOR_CURRENT
       #endif
       static uint32_t motor_current_setting[3];
     #endif
 
-    static int16_t cleaning_buffer_counter;
-
   private:
 
     static uint8_t last_direction_bits;        // The next stepping-bits to be output
 
     #if ENABLED(X_DUAL_ENDSTOPS)
       static bool locked_x_motor, locked_x2_motor;
     #endif
     #if ENABLED(Y_DUAL_ENDSTOPS)
       static bool locked_y_motor, locked_y2_motor;
     #endif
     #if ENABLED(Z_DUAL_ENDSTOPS)
       static bool locked_z_motor, locked_z2_motor;
     #endif
 
     // Counter variables for the Bresenham line tracer
     static int32_t counter_X, counter_Y, counter_Z, counter_E;
-    static volatile uint32_t step_events_completed; // The number of step events executed in the current block
+    static uint32_t step_events_completed; // The number of step events executed in the current block
 
     #if ENABLED(BEZIER_JERK_CONTROL)
       static int32_t bezier_A,     // A coefficient in B√©zier speed curve
                      bezier_B,     // B coefficient in B√©zier speed curve
                      bezier_C;     // C coefficient in B√©zier speed curve
       static uint32_t bezier_F;    // F coefficient in B√©zier speed curve
       static uint32_t bezier_AV;   // AV coefficient in B√©zier speed curve
       #ifdef __AVR__
         static bool A_negative;    // If A coefficient was negative
       #endif
       static bool bezier_2nd_half; // If B√©zier curve has been initialized or not
     #endif
 
+    static uint32_t nextMainISR;   // time remaining for the next Step ISR
+    static bool all_steps_done;    // all steps done
+
     #if ENABLED(LIN_ADVANCE)
 
       static uint32_t LA_decelerate_after; // Copy from current executed block. Needed because current_block is set to NULL "too early".
-      static hal_timer_t nextMainISR, nextAdvanceISR, eISR_Rate;
+      static uint32_t nextAdvanceISR, eISR_Rate;
       static uint16_t current_adv_steps, final_adv_steps, max_adv_steps; // Copy from current executed block. Needed because current_block is set to NULL "too early".
-      #define _NEXT_ISR(T) nextMainISR = T
       static int8_t e_steps;
       static bool use_advance_lead;
       #if E_STEPPERS > 1
         static int8_t LA_active_extruder; // Copy from current executed block. Needed because current_block is set to NULL "too early".
       #else
         static constexpr int8_t LA_active_extruder = 0;
       #endif
 
-    #else // !LIN_ADVANCE
-
-      #define _NEXT_ISR(T) HAL_timer_set_compare(STEP_TIMER_NUM, T);
+    #endif // LIN_ADVANCE
 
-    #endif // !LIN_ADVANCE
-
-    static int32_t acceleration_time, deceleration_time;
+    static uint32_t acceleration_time, deceleration_time;
     static uint8_t step_loops, step_loops_nominal;
 
-    static hal_timer_t OCR1A_nominal;
+    static uint32_t ticks_nominal;
     #if DISABLED(BEZIER_JERK_CONTROL)
-      static hal_timer_t acc_step_rate; // needed for deceleration start point
+      static uint32_t acc_step_rate; // needed for deceleration start point
     #endif
 
     static volatile int32_t endstops_trigsteps[XYZ];
     static volatile int32_t endstops_stepsTotal, endstops_stepsDone;
 
     //
     // Positions of stepper motors, in step units
     //
     static volatile int32_t count_position[NUM_AXIS];
 
@@ -160,102 +152,64 @@ class Stepper {
           if (current_block->mix_event_count[VAR])
     #endif
 
   public:
 
     //
     // Constructor / initializer
     //
     Stepper() { };
 
-    //
     // Initialize stepper hardware
-    //
     static void init();
 
-    //
     // Interrupt Service Routines
-    //
-
-    static void isr();
 
-    #if ENABLED(LIN_ADVANCE)
-      static void advance_isr();
-      static void advance_isr_scheduler();
-    #endif
+    // The ISR scheduler
+    static hal_timer_t isr_scheduler();
 
-    //
-    // Set the current position in steps
-    //
-    static void _set_position(const int32_t &a, const int32_t &b, const int32_t &c, const int32_t &e);
+    // The stepper pulse phase ISR
+    static void stepper_pulse_phase_isr();
 
-    FORCE_INLINE static void _set_position(const AxisEnum a, const int32_t &v) { count_position[a] = v; }
+    // The stepper block processing phase ISR
+    static uint32_t stepper_block_phase_isr();
 
-    FORCE_INLINE static void set_position(const int32_t &a, const int32_t &b, const int32_t &c, const int32_t &e) {
-      planner.synchronize();
-      CRITICAL_SECTION_START;
-      _set_position(a, b, c, e);
-      CRITICAL_SECTION_END;
-    }
-
-    static void set_position(const AxisEnum a, const int32_t &v) {
-      planner.synchronize();
-      CRITICAL_SECTION_START;
-      count_position[a] = v;
-      CRITICAL_SECTION_END;
-    }
-
-    FORCE_INLINE static void _set_e_position(const int32_t &e) { count_position[E_AXIS] = e; }
-
-    static void set_e_position(const int32_t &e) {
-      planner.synchronize();
-      CRITICAL_SECTION_START;
-      count_position[E_AXIS] = e;
-      CRITICAL_SECTION_END;
-    }
-
-    //
-    // Set direction bits for all steppers
-    //
-    static void set_directions();
+    #if ENABLED(LIN_ADVANCE)
+      // The Linear advance stepper ISR
+      static uint32_t advance_isr();
+    #endif
 
-    //
     // Get the position of a stepper, in steps
-    //
     static int32_t position(const AxisEnum axis);
 
-    //
     // Report the positions of the steppers, in steps
-    //
     static void report_positions();
 
-    //
     // The stepper subsystem goes to sleep when it runs out of things to execute. Call this
     // to notify the subsystem that it is time to go to work.
-    //
     static void wake_up();
 
-    //
-    // Wait for moves to finish and disable all steppers
-    //
-    static void finish_and_disable();
-
-    //
-    // Quickly stop all steppers and clear the blocks queue
-    //
+    // Quickly stop all steppers
     static void quick_stop();
 
-    //
     // The direction of a single motor
-    //
     FORCE_INLINE static bool motor_direction(const AxisEnum axis) { return TEST(last_direction_bits, axis); }
 
+    // Kill current block
+    static void kill_current_block();
+
+    // Handle a triggered endstop
+    static void endstop_triggered(const AxisEnum axis);
+
+    // Triggered position of an axis in steps
+    static int32_t triggered_position(const AxisEnum axis);
+
     #if HAS_DIGIPOTSS || HAS_MOTOR_CURRENT_PWM
       static void digitalPotWrite(const int16_t address, const int16_t value);
       static void digipot_current(const uint8_t driver, const int16_t current);
     #endif
 
     #if HAS_MICROSTEPS
       static void microstep_ms(const uint8_t driver, const int8_t ms1, const int8_t ms2);
       static void microstep_mode(const uint8_t driver, const uint8_t stepping);
       static void microstep_readings();
     #endif
@@ -273,48 +227,38 @@ class Stepper {
     #if ENABLED(Z_DUAL_ENDSTOPS)
       FORCE_INLINE static void set_homing_flag_z(const bool state) { performing_homing = state; }
       FORCE_INLINE static void set_z_lock(const bool state) { locked_z_motor = state; }
       FORCE_INLINE static void set_z2_lock(const bool state) { locked_z2_motor = state; }
     #endif
 
     #if ENABLED(BABYSTEPPING)
       static void babystep(const AxisEnum axis, const bool direction); // perform a short step with a single stepper motor, outside of any convention
     #endif
 
-    static inline void kill_current_block() {
-      step_events_completed = current_block->step_event_count;
-    }
-
-    //
-    // Handle a triggered endstop
-    //
-    static void endstop_triggered(const AxisEnum axis);
-
-    //
-    // Triggered position of an axis in mm (not core-savvy)
-    //
-    FORCE_INLINE static float triggered_position_mm(const AxisEnum axis) {
-      return endstops_trigsteps[axis] * planner.steps_to_mm[axis];
-    }
-
     #if HAS_MOTOR_CURRENT_PWM
       static void refresh_motor_power();
     #endif
 
   private:
 
-    FORCE_INLINE static hal_timer_t calc_timer_interval(hal_timer_t step_rate) {
-      hal_timer_t timer;
+    // Set the current position in steps
+    static void _set_position(const int32_t &a, const int32_t &b, const int32_t &c, const int32_t &e);
+
+    // Set direction bits for all steppers
+    static void set_directions();
+
+    FORCE_INLINE static uint32_t calc_timer_interval(uint32_t step_rate) {
+      uint32_t timer;
 
       NOMORE(step_rate, MAX_STEP_FREQUENCY);
 
-      // TODO: HAL: tidy this up, use condtionals_post.h
+      // TODO: HAL: tidy this up, use Conditionals_post.h
       #ifdef CPU_32_BIT
         #if ENABLED(DISABLE_MULTI_STEPPING)
           step_loops = 1;
         #else
           if (step_rate > STEP_DOUBLER_FREQUENCY * 2) { // If steprate > (STEP_DOUBLER_FREQUENCY * 2) kHz >> step 4 times
             step_rate >>= 2;
             step_loops = 4;
           }
           else if (step_rate > STEP_DOUBLER_FREQUENCY) { // If steprate > STEP_DOUBLER_FREQUENCY kHz >> step 2 times
             step_rate >>= 1;
@@ -341,30 +285,30 @@ class Stepper {
       #ifdef CPU_32_BIT
         // In case of high-performance processor, it is able to calculate in real-time
         const uint32_t min_time_per_step = (HAL_STEPPER_TIMER_RATE) / ((STEP_DOUBLER_FREQUENCY) * 2);
         timer = uint32_t(HAL_STEPPER_TIMER_RATE) / step_rate;
         NOLESS(timer, min_time_per_step); // (STEP_DOUBLER_FREQUENCY * 2 kHz - this should never happen)
       #else
         NOLESS(step_rate, F_CPU / 500000);
         step_rate -= F_CPU / 500000; // Correct for minimal speed
         if (step_rate >= (8 * 256)) { // higher step rate
           uint8_t tmp_step_rate = (step_rate & 0x00FF);
-          uint16_t table_address = (uint16_t)&speed_lookuptable_fast[(uint8_t)(step_rate >> 8)][0];
-          uint16_t gain = (uint16_t)pgm_read_word_near(table_address + 2);
+          uint16_t table_address = (uint16_t)&speed_lookuptable_fast[(uint8_t)(step_rate >> 8)][0],
+                   gain = (uint16_t)pgm_read_word_near(table_address + 2);
           timer = MultiU16X8toH16(tmp_step_rate, gain);
           timer = (uint16_t)pgm_read_word_near(table_address) - timer;
         }
         else { // lower step rates
           uint16_t table_address = (uint16_t)&speed_lookuptable_slow[0][0];
           table_address += ((step_rate) >> 1) & 0xFFFC;
-          timer = (uint16_t)pgm_read_word_near(table_address);
-          timer -= (((uint16_t)pgm_read_word_near(table_address + 2) * (uint8_t)(step_rate & 0x0007)) >> 3);
+          timer = (uint16_t)pgm_read_word_near(table_address)
+                - (((uint16_t)pgm_read_word_near(table_address + 2) * (uint8_t)(step_rate & 0x0007)) >> 3);
         }
         if (timer < 100) { // (20kHz - this should never happen)
           timer = 100;
           SERIAL_ECHOPGM(MSG_STEPPER_TOO_HIGH);
           SERIAL_ECHOLN(step_rate);
         }
       #endif
 
       return timer;
     }

commit 883b0c98808e09b2375eeb1f107ec931bb72c9ff
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sun May 13 08:10:08 2018 -0500

    Convert custom maths to inlines (#10728)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 795a93dbe2..6a03ed3948 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -333,38 +333,38 @@ class Stepper {
           step_rate >>= 1;
           step_loops = 2;
         }
         else {
           step_loops = 1;
         }
       #endif
 
       #ifdef CPU_32_BIT
         // In case of high-performance processor, it is able to calculate in real-time
-        const uint32_t MIN_TIME_PER_STEP = (HAL_STEPPER_TIMER_RATE) / ((STEP_DOUBLER_FREQUENCY) * 2);
+        const uint32_t min_time_per_step = (HAL_STEPPER_TIMER_RATE) / ((STEP_DOUBLER_FREQUENCY) * 2);
         timer = uint32_t(HAL_STEPPER_TIMER_RATE) / step_rate;
-        NOLESS(timer, MIN_TIME_PER_STEP); // (STEP_DOUBLER_FREQUENCY * 2 kHz - this should never happen)
+        NOLESS(timer, min_time_per_step); // (STEP_DOUBLER_FREQUENCY * 2 kHz - this should never happen)
       #else
         NOLESS(step_rate, F_CPU / 500000);
         step_rate -= F_CPU / 500000; // Correct for minimal speed
         if (step_rate >= (8 * 256)) { // higher step rate
-          unsigned short table_address = (unsigned short)&speed_lookuptable_fast[(unsigned char)(step_rate >> 8)][0];
-          unsigned char tmp_step_rate = (step_rate & 0x00FF);
-          unsigned short gain = (unsigned short)pgm_read_word_near(table_address + 2);
-          MultiU16X8toH16(timer, tmp_step_rate, gain);
-          timer = (unsigned short)pgm_read_word_near(table_address) - timer;
+          uint8_t tmp_step_rate = (step_rate & 0x00FF);
+          uint16_t table_address = (uint16_t)&speed_lookuptable_fast[(uint8_t)(step_rate >> 8)][0];
+          uint16_t gain = (uint16_t)pgm_read_word_near(table_address + 2);
+          timer = MultiU16X8toH16(tmp_step_rate, gain);
+          timer = (uint16_t)pgm_read_word_near(table_address) - timer;
         }
         else { // lower step rates
-          unsigned short table_address = (unsigned short)&speed_lookuptable_slow[0][0];
+          uint16_t table_address = (uint16_t)&speed_lookuptable_slow[0][0];
           table_address += ((step_rate) >> 1) & 0xFFFC;
-          timer = (unsigned short)pgm_read_word_near(table_address);
-          timer -= (((unsigned short)pgm_read_word_near(table_address + 2) * (unsigned char)(step_rate & 0x0007)) >> 3);
+          timer = (uint16_t)pgm_read_word_near(table_address);
+          timer -= (((uint16_t)pgm_read_word_near(table_address + 2) * (uint8_t)(step_rate & 0x0007)) >> 3);
         }
         if (timer < 100) { // (20kHz - this should never happen)
           timer = 100;
           SERIAL_ECHOPGM(MSG_STEPPER_TOO_HIGH);
           SERIAL_ECHOLN(step_rate);
         }
       #endif
 
       return timer;
     }

commit 8f8c6a9bc4f1c8b2d927e74339a48217d9b48ec7
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 12 09:59:11 2018 -0500

    Move get_axis_position_mm to Planner (#10718)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 0df42d24b8..795a93dbe2 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -221,32 +221,20 @@ class Stepper {
     //
     // Get the position of a stepper, in steps
     //
     static int32_t position(const AxisEnum axis);
 
     //
     // Report the positions of the steppers, in steps
     //
     static void report_positions();
 
-    //
-    // Get the position (mm) of an axis based on stepper position(s)
-    //
-    static float get_axis_position_mm(const AxisEnum axis);
-
-    //
-    // SCARA AB axes are in degrees, not mm
-    //
-    #if IS_SCARA
-      FORCE_INLINE static float get_axis_position_degrees(const AxisEnum axis) { return get_axis_position_mm(axis); }
-    #endif
-
     //
     // The stepper subsystem goes to sleep when it runs out of things to execute. Call this
     // to notify the subsystem that it is time to go to work.
     //
     static void wake_up();
 
     //
     // Wait for moves to finish and disable all steppers
     //
     static void finish_and_disable();

commit 306f0f2135e4b2aed749a0d1b870abf17d883e38
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat May 12 01:38:02 2018 -0500

    Move Stepper::synchronize to Planner (#10713)
    
    Co-Authored-By: ejtagle <ejtagle@hotmail.com>

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 5af7f87a3c..0df42d24b8 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -176,50 +176,45 @@ class Stepper {
     // Interrupt Service Routines
     //
 
     static void isr();
 
     #if ENABLED(LIN_ADVANCE)
       static void advance_isr();
       static void advance_isr_scheduler();
     #endif
 
-    //
-    // Block until all buffered steps are executed
-    //
-    static void synchronize();
-
     //
     // Set the current position in steps
     //
     static void _set_position(const int32_t &a, const int32_t &b, const int32_t &c, const int32_t &e);
 
     FORCE_INLINE static void _set_position(const AxisEnum a, const int32_t &v) { count_position[a] = v; }
 
     FORCE_INLINE static void set_position(const int32_t &a, const int32_t &b, const int32_t &c, const int32_t &e) {
-      synchronize();
+      planner.synchronize();
       CRITICAL_SECTION_START;
       _set_position(a, b, c, e);
       CRITICAL_SECTION_END;
     }
 
     static void set_position(const AxisEnum a, const int32_t &v) {
-      synchronize();
+      planner.synchronize();
       CRITICAL_SECTION_START;
       count_position[a] = v;
       CRITICAL_SECTION_END;
     }
 
     FORCE_INLINE static void _set_e_position(const int32_t &e) { count_position[E_AXIS] = e; }
 
     static void set_e_position(const int32_t &e) {
-      synchronize();
+      planner.synchronize();
       CRITICAL_SECTION_START;
       count_position[E_AXIS] = e;
       CRITICAL_SECTION_END;
     }
 
     //
     // Set direction bits for all steppers
     //
     static void set_directions();
 

commit d1b619be52c7af5c506add9ee78d4a4742e22b9c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue May 8 09:17:44 2018 -0500

    Standardize some hexadecimals

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 19bfeec685..5af7f87a3c 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -358,28 +358,28 @@ class Stepper {
       #ifdef CPU_32_BIT
         // In case of high-performance processor, it is able to calculate in real-time
         const uint32_t MIN_TIME_PER_STEP = (HAL_STEPPER_TIMER_RATE) / ((STEP_DOUBLER_FREQUENCY) * 2);
         timer = uint32_t(HAL_STEPPER_TIMER_RATE) / step_rate;
         NOLESS(timer, MIN_TIME_PER_STEP); // (STEP_DOUBLER_FREQUENCY * 2 kHz - this should never happen)
       #else
         NOLESS(step_rate, F_CPU / 500000);
         step_rate -= F_CPU / 500000; // Correct for minimal speed
         if (step_rate >= (8 * 256)) { // higher step rate
           unsigned short table_address = (unsigned short)&speed_lookuptable_fast[(unsigned char)(step_rate >> 8)][0];
-          unsigned char tmp_step_rate = (step_rate & 0x00ff);
+          unsigned char tmp_step_rate = (step_rate & 0x00FF);
           unsigned short gain = (unsigned short)pgm_read_word_near(table_address + 2);
           MultiU16X8toH16(timer, tmp_step_rate, gain);
           timer = (unsigned short)pgm_read_word_near(table_address) - timer;
         }
         else { // lower step rates
           unsigned short table_address = (unsigned short)&speed_lookuptable_slow[0][0];
-          table_address += ((step_rate) >> 1) & 0xfffc;
+          table_address += ((step_rate) >> 1) & 0xFFFC;
           timer = (unsigned short)pgm_read_word_near(table_address);
           timer -= (((unsigned short)pgm_read_word_near(table_address + 2) * (unsigned char)(step_rate & 0x0007)) >> 3);
         }
         if (timer < 100) { // (20kHz - this should never happen)
           timer = 100;
           SERIAL_ECHOPGM(MSG_STEPPER_TOO_HIGH);
           SERIAL_ECHOLN(step_rate);
         }
       #endif
 

commit af1950a63e4049c6f870fffcc12bf6e0f15dddac
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu May 3 17:45:13 2018 -0500

    Improve sync of stepper positions

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 5fad6a8f7a..19bfeec685 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -184,23 +184,46 @@ class Stepper {
     #endif
 
     //
     // Block until all buffered steps are executed
     //
     static void synchronize();
 
     //
     // Set the current position in steps
     //
-    static void set_position(const int32_t &a, const int32_t &b, const int32_t &c, const int32_t &e);
-    static void set_position(const AxisEnum &a, const int32_t &v);
-    static void set_e_position(const int32_t &e);
+    static void _set_position(const int32_t &a, const int32_t &b, const int32_t &c, const int32_t &e);
+
+    FORCE_INLINE static void _set_position(const AxisEnum a, const int32_t &v) { count_position[a] = v; }
+
+    FORCE_INLINE static void set_position(const int32_t &a, const int32_t &b, const int32_t &c, const int32_t &e) {
+      synchronize();
+      CRITICAL_SECTION_START;
+      _set_position(a, b, c, e);
+      CRITICAL_SECTION_END;
+    }
+
+    static void set_position(const AxisEnum a, const int32_t &v) {
+      synchronize();
+      CRITICAL_SECTION_START;
+      count_position[a] = v;
+      CRITICAL_SECTION_END;
+    }
+
+    FORCE_INLINE static void _set_e_position(const int32_t &e) { count_position[E_AXIS] = e; }
+
+    static void set_e_position(const int32_t &e) {
+      synchronize();
+      CRITICAL_SECTION_START;
+      count_position[E_AXIS] = e;
+      CRITICAL_SECTION_END;
+    }
 
     //
     // Set direction bits for all steppers
     //
     static void set_directions();
 
     //
     // Get the position of a stepper, in steps
     //
     static int32_t position(const AxisEnum axis);

commit 0c23792344a5134dc00446c192456bf62094c346
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Thu May 3 20:13:01 2018 -0500

    Apply int32_t to stepper

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 88bbab8743..5fad6a8f7a 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -87,21 +87,21 @@ class Stepper {
       static bool locked_x_motor, locked_x2_motor;
     #endif
     #if ENABLED(Y_DUAL_ENDSTOPS)
       static bool locked_y_motor, locked_y2_motor;
     #endif
     #if ENABLED(Z_DUAL_ENDSTOPS)
       static bool locked_z_motor, locked_z2_motor;
     #endif
 
     // Counter variables for the Bresenham line tracer
-    static long counter_X, counter_Y, counter_Z, counter_E;
+    static int32_t counter_X, counter_Y, counter_Z, counter_E;
     static volatile uint32_t step_events_completed; // The number of step events executed in the current block
 
     #if ENABLED(BEZIER_JERK_CONTROL)
       static int32_t bezier_A,     // A coefficient in B√©zier speed curve
                      bezier_B,     // B coefficient in B√©zier speed curve
                      bezier_C;     // C coefficient in B√©zier speed curve
       static uint32_t bezier_F;    // F coefficient in B√©zier speed curve
       static uint32_t bezier_AV;   // AV coefficient in B√©zier speed curve
       #ifdef __AVR__
         static bool A_negative;    // If A coefficient was negative
@@ -130,38 +130,38 @@ class Stepper {
     #endif // !LIN_ADVANCE
 
     static int32_t acceleration_time, deceleration_time;
     static uint8_t step_loops, step_loops_nominal;
 
     static hal_timer_t OCR1A_nominal;
     #if DISABLED(BEZIER_JERK_CONTROL)
       static hal_timer_t acc_step_rate; // needed for deceleration start point
     #endif
 
-    static volatile long endstops_trigsteps[XYZ];
-    static volatile long endstops_stepsTotal, endstops_stepsDone;
+    static volatile int32_t endstops_trigsteps[XYZ];
+    static volatile int32_t endstops_stepsTotal, endstops_stepsDone;
 
     //
     // Positions of stepper motors, in step units
     //
     static volatile int32_t count_position[NUM_AXIS];
 
     //
     // Current direction of stepper motors (+1 or -1)
     //
     static volatile signed char count_direction[NUM_AXIS];
 
     //
     // Mixing extruder mix counters
     //
     #if ENABLED(MIXING_EXTRUDER)
-      static long counter_m[MIXING_STEPPERS];
+      static int32_t counter_m[MIXING_STEPPERS];
       #define MIXING_STEPPERS_LOOP(VAR) \
         for (uint8_t VAR = 0; VAR < MIXING_STEPPERS; VAR++) \
           if (current_block->mix_event_count[VAR])
     #endif
 
   public:
 
     //
     // Constructor / initializer
     //
@@ -184,33 +184,33 @@ class Stepper {
     #endif
 
     //
     // Block until all buffered steps are executed
     //
     static void synchronize();
 
     //
     // Set the current position in steps
     //
-    static void set_position(const long &a, const long &b, const long &c, const long &e);
-    static void set_position(const AxisEnum &a, const long &v);
-    static void set_e_position(const long &e);
+    static void set_position(const int32_t &a, const int32_t &b, const int32_t &c, const int32_t &e);
+    static void set_position(const AxisEnum &a, const int32_t &v);
+    static void set_e_position(const int32_t &e);
 
     //
     // Set direction bits for all steppers
     //
     static void set_directions();
 
     //
     // Get the position of a stepper, in steps
     //
-    static long position(const AxisEnum axis);
+    static int32_t position(const AxisEnum axis);
 
     //
     // Report the positions of the steppers, in steps
     //
     static void report_positions();
 
     //
     // Get the position (mm) of an axis based on stepper position(s)
     //
     static float get_axis_position_mm(const AxisEnum axis);

commit 57a899a412b0d45c159423925c1f63164dcd9308
Author: Eduardo Jos√© Tagle <ejtagle@hotmail.com>
Date:   Wed Apr 11 20:13:42 2018 -0300

    [2.0.x] 6th-order jerk-controlled motion planning in real-time for AVR (#10373)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index d7fca16f2b..88bbab8743 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -91,26 +91,29 @@ class Stepper {
     #endif
     #if ENABLED(Z_DUAL_ENDSTOPS)
       static bool locked_z_motor, locked_z2_motor;
     #endif
 
     // Counter variables for the Bresenham line tracer
     static long counter_X, counter_Y, counter_Z, counter_E;
     static volatile uint32_t step_events_completed; // The number of step events executed in the current block
 
     #if ENABLED(BEZIER_JERK_CONTROL)
-      static int32_t bezier_A,        // A coefficient in B√©zier speed curve
-                     bezier_B,        // B coefficient in B√©zier speed curve
-                     bezier_C,        // C coefficient in B√©zier speed curve
-                     bezier_F;        // F coefficient in B√©zier speed curve
-      static uint32_t bezier_AV;      // AV coefficient in B√©zier speed curve
-      static bool bezier_2nd_half;    // If B√©zier curve has been initialized or not
+      static int32_t bezier_A,     // A coefficient in B√©zier speed curve
+                     bezier_B,     // B coefficient in B√©zier speed curve
+                     bezier_C;     // C coefficient in B√©zier speed curve
+      static uint32_t bezier_F;    // F coefficient in B√©zier speed curve
+      static uint32_t bezier_AV;   // AV coefficient in B√©zier speed curve
+      #ifdef __AVR__
+        static bool A_negative;    // If A coefficient was negative
+      #endif
+      static bool bezier_2nd_half; // If B√©zier curve has been initialized or not
     #endif
 
     #if ENABLED(LIN_ADVANCE)
 
       static uint32_t LA_decelerate_after; // Copy from current executed block. Needed because current_block is set to NULL "too early".
       static hal_timer_t nextMainISR, nextAdvanceISR, eISR_Rate;
       static uint16_t current_adv_steps, final_adv_steps, max_adv_steps; // Copy from current executed block. Needed because current_block is set to NULL "too early".
       #define _NEXT_ISR(T) nextMainISR = T
       static int8_t e_steps;
       static bool use_advance_lead;
@@ -354,21 +357,21 @@ class Stepper {
           timer = 100;
           SERIAL_ECHOPGM(MSG_STEPPER_TOO_HIGH);
           SERIAL_ECHOLN(step_rate);
         }
       #endif
 
       return timer;
     }
 
     #if ENABLED(BEZIER_JERK_CONTROL)
-      static void _calc_bezier_curve_coeffs(const int32_t v0, const int32_t v1, const uint32_t steps);
+      static void _calc_bezier_curve_coeffs(const int32_t v0, const int32_t v1, const uint32_t av);
       static int32_t _eval_bezier_curve(const uint32_t curr_step);
     #endif
 
     #if HAS_DIGIPOTSS || HAS_MOTOR_CURRENT_PWM
       static void digipot_init();
     #endif
 
     #if HAS_MICROSTEPS
       static void microstep_init();
     #endif

commit a29adde5c0706a572261c40a02c61e1c966928a4
Author: etagle <ejtagle@hotmail.com>
Date:   Fri Apr 6 22:48:06 2018 -0300

    Implement BEZIER_JERK_CONTROL
    
    Enable 6th-order jerk-controlled motion planning in real-time.
    Only for 32bit MCUs. (AVR simply does not have enough processing power for this!)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 568a7e792a..d7fca16f2b 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -90,53 +90,64 @@ class Stepper {
       static bool locked_y_motor, locked_y2_motor;
     #endif
     #if ENABLED(Z_DUAL_ENDSTOPS)
       static bool locked_z_motor, locked_z2_motor;
     #endif
 
     // Counter variables for the Bresenham line tracer
     static long counter_X, counter_Y, counter_Z, counter_E;
     static volatile uint32_t step_events_completed; // The number of step events executed in the current block
 
+    #if ENABLED(BEZIER_JERK_CONTROL)
+      static int32_t bezier_A,        // A coefficient in B√©zier speed curve
+                     bezier_B,        // B coefficient in B√©zier speed curve
+                     bezier_C,        // C coefficient in B√©zier speed curve
+                     bezier_F;        // F coefficient in B√©zier speed curve
+      static uint32_t bezier_AV;      // AV coefficient in B√©zier speed curve
+      static bool bezier_2nd_half;    // If B√©zier curve has been initialized or not
+    #endif
+
     #if ENABLED(LIN_ADVANCE)
 
       static uint32_t LA_decelerate_after; // Copy from current executed block. Needed because current_block is set to NULL "too early".
       static hal_timer_t nextMainISR, nextAdvanceISR, eISR_Rate;
       static uint16_t current_adv_steps, final_adv_steps, max_adv_steps; // Copy from current executed block. Needed because current_block is set to NULL "too early".
       #define _NEXT_ISR(T) nextMainISR = T
       static int8_t e_steps;
       static bool use_advance_lead;
       #if E_STEPPERS > 1
         static int8_t LA_active_extruder; // Copy from current executed block. Needed because current_block is set to NULL "too early".
       #else
         static constexpr int8_t LA_active_extruder = 0;
       #endif
 
     #else // !LIN_ADVANCE
 
       #define _NEXT_ISR(T) HAL_timer_set_compare(STEP_TIMER_NUM, T);
 
     #endif // !LIN_ADVANCE
 
-    static long acceleration_time, deceleration_time;
+    static int32_t acceleration_time, deceleration_time;
     static uint8_t step_loops, step_loops_nominal;
 
-    static hal_timer_t OCR1A_nominal,
-                       acc_step_rate; // needed for deceleration start point
+    static hal_timer_t OCR1A_nominal;
+    #if DISABLED(BEZIER_JERK_CONTROL)
+      static hal_timer_t acc_step_rate; // needed for deceleration start point
+    #endif
 
     static volatile long endstops_trigsteps[XYZ];
     static volatile long endstops_stepsTotal, endstops_stepsDone;
 
     //
     // Positions of stepper motors, in step units
     //
-    static volatile long count_position[NUM_AXIS];
+    static volatile int32_t count_position[NUM_AXIS];
 
     //
     // Current direction of stepper motors (+1 or -1)
     //
     static volatile signed char count_direction[NUM_AXIS];
 
     //
     // Mixing extruder mix counters
     //
     #if ENABLED(MIXING_EXTRUDER)
@@ -342,57 +353,24 @@ class Stepper {
         if (timer < 100) { // (20kHz - this should never happen)
           timer = 100;
           SERIAL_ECHOPGM(MSG_STEPPER_TOO_HIGH);
           SERIAL_ECHOLN(step_rate);
         }
       #endif
 
       return timer;
     }
 
-    // Initialize the trapezoid generator from the current block.
-    // Called whenever a new block begins.
-    FORCE_INLINE static void trapezoid_generator_reset() {
-
-      static int8_t last_extruder = -1;
-
-      #if ENABLED(LIN_ADVANCE)
-        #if E_STEPPERS > 1
-          if (current_block->active_extruder != last_extruder) {
-            current_adv_steps = 0; // If the now active extruder wasn't in use during the last move, its pressure is most likely gone.
-            LA_active_extruder = current_block->active_extruder;
-          }
-        #endif
-
-        if ((use_advance_lead = current_block->use_advance_lead)) {
-          LA_decelerate_after = current_block->decelerate_after;
-          final_adv_steps = current_block->final_adv_steps;
-          max_adv_steps = current_block->max_adv_steps;
-        }
-      #endif
-
-      if (current_block->direction_bits != last_direction_bits || current_block->active_extruder != last_extruder) {
-        last_direction_bits = current_block->direction_bits;
-        last_extruder = current_block->active_extruder;
-        set_directions();
-      }
-
-      deceleration_time = 0;
-      // step_rate to timer interval
-      OCR1A_nominal = calc_timer_interval(current_block->nominal_rate);
-      // make a note of the number of step loops required at nominal speed
-      step_loops_nominal = step_loops;
-      acc_step_rate = current_block->initial_rate;
-      acceleration_time = calc_timer_interval(acc_step_rate);
-      _NEXT_ISR(acceleration_time);
-
-    }
+    #if ENABLED(BEZIER_JERK_CONTROL)
+      static void _calc_bezier_curve_coeffs(const int32_t v0, const int32_t v1, const uint32_t steps);
+      static int32_t _eval_bezier_curve(const uint32_t curr_step);
+    #endif
 
     #if HAS_DIGIPOTSS || HAS_MOTOR_CURRENT_PWM
       static void digipot_init();
     #endif
 
     #if HAS_MICROSTEPS
       static void microstep_init();
     #endif
 
 };

commit 9515e5aefba9826308607ebb3f497ecfc538ca52
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Mar 7 05:49:10 2018 -0600

    Fix LA_active_extruder (static)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 28bf1ee89d..568a7e792a 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -101,21 +101,21 @@ class Stepper {
 
       static uint32_t LA_decelerate_after; // Copy from current executed block. Needed because current_block is set to NULL "too early".
       static hal_timer_t nextMainISR, nextAdvanceISR, eISR_Rate;
       static uint16_t current_adv_steps, final_adv_steps, max_adv_steps; // Copy from current executed block. Needed because current_block is set to NULL "too early".
       #define _NEXT_ISR(T) nextMainISR = T
       static int8_t e_steps;
       static bool use_advance_lead;
       #if E_STEPPERS > 1
         static int8_t LA_active_extruder; // Copy from current executed block. Needed because current_block is set to NULL "too early".
       #else
-        constexpr int8_t LA_active_extruder = 0;
+        static constexpr int8_t LA_active_extruder = 0;
       #endif
 
     #else // !LIN_ADVANCE
 
       #define _NEXT_ISR(T) HAL_timer_set_compare(STEP_TIMER_NUM, T);
 
     #endif // !LIN_ADVANCE
 
     static long acceleration_time, deceleration_time;
     static uint8_t step_loops, step_loops_nominal;

commit ca0def766e3b5bfc3710835cd9cfe7c1cdfb9c89
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Tue Mar 6 19:21:41 2018 -0600

    LIN_ADVANCE single stepper optimization

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index e976c3692d..28bf1ee89d 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -97,22 +97,26 @@ class Stepper {
     static long counter_X, counter_Y, counter_Z, counter_E;
     static volatile uint32_t step_events_completed; // The number of step events executed in the current block
 
     #if ENABLED(LIN_ADVANCE)
 
       static uint32_t LA_decelerate_after; // Copy from current executed block. Needed because current_block is set to NULL "too early".
       static hal_timer_t nextMainISR, nextAdvanceISR, eISR_Rate;
       static uint16_t current_adv_steps, final_adv_steps, max_adv_steps; // Copy from current executed block. Needed because current_block is set to NULL "too early".
       #define _NEXT_ISR(T) nextMainISR = T
       static int8_t e_steps;
-      static int8_t LA_active_extruder; // Copy from current executed block. Needed because current_block is set to NULL "too early".
       static bool use_advance_lead;
+      #if E_STEPPERS > 1
+        static int8_t LA_active_extruder; // Copy from current executed block. Needed because current_block is set to NULL "too early".
+      #else
+        constexpr int8_t LA_active_extruder = 0;
+      #endif
 
     #else // !LIN_ADVANCE
 
       #define _NEXT_ISR(T) HAL_timer_set_compare(STEP_TIMER_NUM, T);
 
     #endif // !LIN_ADVANCE
 
     static long acceleration_time, deceleration_time;
     static uint8_t step_loops, step_loops_nominal;
 
@@ -345,33 +349,32 @@ class Stepper {
       return timer;
     }
 
     // Initialize the trapezoid generator from the current block.
     // Called whenever a new block begins.
     FORCE_INLINE static void trapezoid_generator_reset() {
 
       static int8_t last_extruder = -1;
 
       #if ENABLED(LIN_ADVANCE)
-        if (current_block->active_extruder != last_extruder) {
-          current_adv_steps = 0; // If the now active extruder wasn't in use during the last move, its pressure is most likely gone.
-          LA_active_extruder = current_block->active_extruder;
-        }
+        #if E_STEPPERS > 1
+          if (current_block->active_extruder != last_extruder) {
+            current_adv_steps = 0; // If the now active extruder wasn't in use during the last move, its pressure is most likely gone.
+            LA_active_extruder = current_block->active_extruder;
+          }
+        #endif
 
-        if (current_block->use_advance_lead) {
+        if ((use_advance_lead = current_block->use_advance_lead)) {
           LA_decelerate_after = current_block->decelerate_after;
           final_adv_steps = current_block->final_adv_steps;
           max_adv_steps = current_block->max_adv_steps;
-          use_advance_lead = true;
         }
-        else
-          use_advance_lead = false;
       #endif
 
       if (current_block->direction_bits != last_direction_bits || current_block->active_extruder != last_extruder) {
         last_direction_bits = current_block->direction_bits;
         last_extruder = current_block->active_extruder;
         set_directions();
       }
 
       deceleration_time = 0;
       // step_rate to timer interval

commit 2bd252b50149c860cf37d488762abcf70a83f78d
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Fri Feb 23 00:53:29 2018 -0600

    [2.0.x] LIN_ADVANCE v1.5 (#9712)

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 0a051d6153..e976c3692d 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -91,32 +91,34 @@ class Stepper {
     #endif
     #if ENABLED(Z_DUAL_ENDSTOPS)
       static bool locked_z_motor, locked_z2_motor;
     #endif
 
     // Counter variables for the Bresenham line tracer
     static long counter_X, counter_Y, counter_Z, counter_E;
     static volatile uint32_t step_events_completed; // The number of step events executed in the current block
 
     #if ENABLED(LIN_ADVANCE)
+
+      static uint32_t LA_decelerate_after; // Copy from current executed block. Needed because current_block is set to NULL "too early".
       static hal_timer_t nextMainISR, nextAdvanceISR, eISR_Rate;
+      static uint16_t current_adv_steps, final_adv_steps, max_adv_steps; // Copy from current executed block. Needed because current_block is set to NULL "too early".
       #define _NEXT_ISR(T) nextMainISR = T
+      static int8_t e_steps;
+      static int8_t LA_active_extruder; // Copy from current executed block. Needed because current_block is set to NULL "too early".
+      static bool use_advance_lead;
+
+    #else // !LIN_ADVANCE
 
-      static volatile int e_steps[E_STEPPERS];
-      static int final_estep_rate;
-      static int current_estep_rate[E_STEPPERS]; // Actual extruder speed [steps/s]
-      static int current_adv_steps[E_STEPPERS];  // The amount of current added esteps due to advance.
-                                                 // i.e., the current amount of pressure applied
-                                                 // to the spring (=filament).
-    #else
       #define _NEXT_ISR(T) HAL_timer_set_compare(STEP_TIMER_NUM, T);
-    #endif // LIN_ADVANCE
+
+    #endif // !LIN_ADVANCE
 
     static long acceleration_time, deceleration_time;
     static uint8_t step_loops, step_loops_nominal;
 
     static hal_timer_t OCR1A_nominal,
                        acc_step_rate; // needed for deceleration start point
 
     static volatile long endstops_trigsteps[XYZ];
     static volatile long endstops_stepsTotal, endstops_stepsDone;
 
@@ -232,27 +234,25 @@ class Stepper {
       static void microstep_ms(const uint8_t driver, const int8_t ms1, const int8_t ms2);
       static void microstep_mode(const uint8_t driver, const uint8_t stepping);
       static void microstep_readings();
     #endif
 
     #if ENABLED(X_DUAL_ENDSTOPS)
       FORCE_INLINE static void set_homing_flag_x(const bool state) { performing_homing = state; }
       FORCE_INLINE static void set_x_lock(const bool state) { locked_x_motor = state; }
       FORCE_INLINE static void set_x2_lock(const bool state) { locked_x2_motor = state; }
     #endif
-
     #if ENABLED(Y_DUAL_ENDSTOPS)
       FORCE_INLINE static void set_homing_flag_y(const bool state) { performing_homing = state; }
       FORCE_INLINE static void set_y_lock(const bool state) { locked_y_motor = state; }
       FORCE_INLINE static void set_y2_lock(const bool state) { locked_y2_motor = state; }
     #endif
-
     #if ENABLED(Z_DUAL_ENDSTOPS)
       FORCE_INLINE static void set_homing_flag_z(const bool state) { performing_homing = state; }
       FORCE_INLINE static void set_z_lock(const bool state) { locked_z_motor = state; }
       FORCE_INLINE static void set_z2_lock(const bool state) { locked_z2_motor = state; }
     #endif
 
     #if ENABLED(BABYSTEPPING)
       static void babystep(const AxisEnum axis, const bool direction); // perform a short step with a single stepper motor, outside of any convention
     #endif
 
@@ -344,51 +344,51 @@ class Stepper {
 
       return timer;
     }
 
     // Initialize the trapezoid generator from the current block.
     // Called whenever a new block begins.
     FORCE_INLINE static void trapezoid_generator_reset() {
 
       static int8_t last_extruder = -1;
 
+      #if ENABLED(LIN_ADVANCE)
+        if (current_block->active_extruder != last_extruder) {
+          current_adv_steps = 0; // If the now active extruder wasn't in use during the last move, its pressure is most likely gone.
+          LA_active_extruder = current_block->active_extruder;
+        }
+
+        if (current_block->use_advance_lead) {
+          LA_decelerate_after = current_block->decelerate_after;
+          final_adv_steps = current_block->final_adv_steps;
+          max_adv_steps = current_block->max_adv_steps;
+          use_advance_lead = true;
+        }
+        else
+          use_advance_lead = false;
+      #endif
+
       if (current_block->direction_bits != last_direction_bits || current_block->active_extruder != last_extruder) {
         last_direction_bits = current_block->direction_bits;
         last_extruder = current_block->active_extruder;
         set_directions();
       }
 
       deceleration_time = 0;
       // step_rate to timer interval
       OCR1A_nominal = calc_timer_interval(current_block->nominal_rate);
       // make a note of the number of step loops required at nominal speed
       step_loops_nominal = step_loops;
       acc_step_rate = current_block->initial_rate;
       acceleration_time = calc_timer_interval(acc_step_rate);
       _NEXT_ISR(acceleration_time);
 
-      #if ENABLED(LIN_ADVANCE)
-        if (current_block->use_advance_lead) {
-          current_estep_rate[current_block->active_extruder] = ((unsigned long)acc_step_rate * current_block->abs_adv_steps_multiplier8) >> 17;
-          final_estep_rate = (current_block->nominal_rate * current_block->abs_adv_steps_multiplier8) >> 17;
-        }
-      #endif
-
-      // SERIAL_ECHO_START();
-      // SERIAL_ECHOPGM("advance :");
-      // SERIAL_ECHO(current_block->advance/256.0);
-      // SERIAL_ECHOPGM("advance rate :");
-      // SERIAL_ECHO(current_block->advance_rate/256.0);
-      // SERIAL_ECHOPGM("initial advance :");
-      // SERIAL_ECHO(current_block->initial_advance/256.0);
-      // SERIAL_ECHOPGM("final advance :");
-      // SERIAL_ECHOLN(current_block->final_advance/256.0);
     }
 
     #if HAS_DIGIPOTSS || HAS_MOTOR_CURRENT_PWM
       static void digipot_init();
     #endif
 
     #if HAS_MICROSTEPS
       static void microstep_init();
     #endif
 

commit c241da32e839f035ca8a7887675ff54d545c38b9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Feb 18 21:11:35 2018 -0600

    stepper.h parity with 1.1.x

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index c9ee8f1a67..0a051d6153 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -105,24 +105,24 @@ class Stepper {
       static int final_estep_rate;
       static int current_estep_rate[E_STEPPERS]; // Actual extruder speed [steps/s]
       static int current_adv_steps[E_STEPPERS];  // The amount of current added esteps due to advance.
                                                  // i.e., the current amount of pressure applied
                                                  // to the spring (=filament).
     #else
       #define _NEXT_ISR(T) HAL_timer_set_compare(STEP_TIMER_NUM, T);
     #endif // LIN_ADVANCE
 
     static long acceleration_time, deceleration_time;
-    //unsigned long accelerate_until, decelerate_after, acceleration_rate, initial_rate, final_rate, nominal_rate;
-    static hal_timer_t acc_step_rate; // needed for deceleration start point
     static uint8_t step_loops, step_loops_nominal;
-    static hal_timer_t OCR1A_nominal;
+
+    static hal_timer_t OCR1A_nominal,
+                       acc_step_rate; // needed for deceleration start point
 
     static volatile long endstops_trigsteps[XYZ];
     static volatile long endstops_stepsTotal, endstops_stepsDone;
 
     //
     // Positions of stepper motors, in step units
     //
     static volatile long count_position[NUM_AXIS];
 
     //

commit 03d790451f7bd523dff6c2d4689b1a0360e67689
Author: Scott Lahteine <thinkyhead@users.noreply.github.com>
Date:   Sat Feb 10 20:42:00 2018 -0600

    [2.0.x] HAL timer set/get count => set/get compare (#9581)
    
    To reduce confusion over the current timer count vs. the compare (aka "top") value. Caution: this re-uses the function name, changing its meaning.

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 73c3dd8b66..c9ee8f1a67 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -101,21 +101,21 @@ class Stepper {
       static hal_timer_t nextMainISR, nextAdvanceISR, eISR_Rate;
       #define _NEXT_ISR(T) nextMainISR = T
 
       static volatile int e_steps[E_STEPPERS];
       static int final_estep_rate;
       static int current_estep_rate[E_STEPPERS]; // Actual extruder speed [steps/s]
       static int current_adv_steps[E_STEPPERS];  // The amount of current added esteps due to advance.
                                                  // i.e., the current amount of pressure applied
                                                  // to the spring (=filament).
     #else
-      #define _NEXT_ISR(T) HAL_timer_set_count(STEP_TIMER_NUM, T);
+      #define _NEXT_ISR(T) HAL_timer_set_compare(STEP_TIMER_NUM, T);
     #endif // LIN_ADVANCE
 
     static long acceleration_time, deceleration_time;
     //unsigned long accelerate_until, decelerate_after, acceleration_rate, initial_rate, final_rate, nominal_rate;
     static hal_timer_t acc_step_rate; // needed for deceleration start point
     static uint8_t step_loops, step_loops_nominal;
     static hal_timer_t OCR1A_nominal;
 
     static volatile long endstops_trigsteps[XYZ];
     static volatile long endstops_stepsTotal, endstops_stepsDone;

commit f7efac57b7ac607405529a71b4e36a6545525c89
Author: Thomas Moore <tcm0116@gmail.com>
Date:   Sun Nov 5 08:49:38 2017 -0600

    Multi-host support

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 77e180a2a1..73c3dd8b66 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -330,22 +330,22 @@ class Stepper {
           timer = (unsigned short)pgm_read_word_near(table_address) - timer;
         }
         else { // lower step rates
           unsigned short table_address = (unsigned short)&speed_lookuptable_slow[0][0];
           table_address += ((step_rate) >> 1) & 0xfffc;
           timer = (unsigned short)pgm_read_word_near(table_address);
           timer -= (((unsigned short)pgm_read_word_near(table_address + 2) * (unsigned char)(step_rate & 0x0007)) >> 3);
         }
         if (timer < 100) { // (20kHz - this should never happen)
           timer = 100;
-          MYSERIAL.print(MSG_STEPPER_TOO_HIGH);
-          MYSERIAL.println(step_rate);
+          SERIAL_ECHOPGM(MSG_STEPPER_TOO_HIGH);
+          SERIAL_ECHOLN(step_rate);
         }
       #endif
 
       return timer;
     }
 
     // Initialize the trapezoid generator from the current block.
     // Called whenever a new block begins.
     FORCE_INLINE static void trapezoid_generator_reset() {
 

commit 8df5955da46d94539eab890a599aaa75b502ee9b
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Dec 17 02:37:35 2017 -0600

    Revert "Reset timer count before first block step"
    
    This reverts commit 5cf6a062e315e7c0936f60ba6bf11d7f8fb1f20c.

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 8b27524d83..77e180a2a1 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -355,20 +355,23 @@ class Stepper {
         last_direction_bits = current_block->direction_bits;
         last_extruder = current_block->active_extruder;
         set_directions();
       }
 
       deceleration_time = 0;
       // step_rate to timer interval
       OCR1A_nominal = calc_timer_interval(current_block->nominal_rate);
       // make a note of the number of step loops required at nominal speed
       step_loops_nominal = step_loops;
+      acc_step_rate = current_block->initial_rate;
+      acceleration_time = calc_timer_interval(acc_step_rate);
+      _NEXT_ISR(acceleration_time);
 
       #if ENABLED(LIN_ADVANCE)
         if (current_block->use_advance_lead) {
           current_estep_rate[current_block->active_extruder] = ((unsigned long)acc_step_rate * current_block->abs_adv_steps_multiplier8) >> 17;
           final_estep_rate = (current_block->nominal_rate * current_block->abs_adv_steps_multiplier8) >> 17;
         }
       #endif
 
       // SERIAL_ECHO_START();
       // SERIAL_ECHOPGM("advance :");

commit 73e32925e4b140fe23f62eeb658f807e4477d872
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Dec 9 02:10:54 2017 -0600

    References are better for array args

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index b1e73bf053..8b27524d83 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -176,37 +176,37 @@ class Stepper {
     static void set_e_position(const long &e);
 
     //
     // Set direction bits for all steppers
     //
     static void set_directions();
 
     //
     // Get the position of a stepper, in steps
     //
-    static long position(AxisEnum axis);
+    static long position(const AxisEnum axis);
 
     //
     // Report the positions of the steppers, in steps
     //
     static void report_positions();
 
     //
     // Get the position (mm) of an axis based on stepper position(s)
     //
-    static float get_axis_position_mm(AxisEnum axis);
+    static float get_axis_position_mm(const AxisEnum axis);
 
     //
     // SCARA AB axes are in degrees, not mm
     //
     #if IS_SCARA
-      FORCE_INLINE static float get_axis_position_degrees(AxisEnum axis) { return get_axis_position_mm(axis); }
+      FORCE_INLINE static float get_axis_position_degrees(const AxisEnum axis) { return get_axis_position_mm(axis); }
     #endif
 
     //
     // The stepper subsystem goes to sleep when it runs out of things to execute. Call this
     // to notify the subsystem that it is time to go to work.
     //
     static void wake_up();
 
     //
     // Wait for moves to finish and disable all steppers
@@ -214,21 +214,21 @@ class Stepper {
     static void finish_and_disable();
 
     //
     // Quickly stop all steppers and clear the blocks queue
     //
     static void quick_stop();
 
     //
     // The direction of a single motor
     //
-    FORCE_INLINE static bool motor_direction(AxisEnum axis) { return TEST(last_direction_bits, axis); }
+    FORCE_INLINE static bool motor_direction(const AxisEnum axis) { return TEST(last_direction_bits, axis); }
 
     #if HAS_DIGIPOTSS || HAS_MOTOR_CURRENT_PWM
       static void digitalPotWrite(const int16_t address, const int16_t value);
       static void digipot_current(const uint8_t driver, const int16_t current);
     #endif
 
     #if HAS_MICROSTEPS
       static void microstep_ms(const uint8_t driver, const int8_t ms1, const int8_t ms2);
       static void microstep_mode(const uint8_t driver, const uint8_t stepping);
       static void microstep_readings();
@@ -256,26 +256,26 @@ class Stepper {
       static void babystep(const AxisEnum axis, const bool direction); // perform a short step with a single stepper motor, outside of any convention
     #endif
 
     static inline void kill_current_block() {
       step_events_completed = current_block->step_event_count;
     }
 
     //
     // Handle a triggered endstop
     //
-    static void endstop_triggered(AxisEnum axis);
+    static void endstop_triggered(const AxisEnum axis);
 
     //
     // Triggered position of an axis in mm (not core-savvy)
     //
-    FORCE_INLINE static float triggered_position_mm(AxisEnum axis) {
+    FORCE_INLINE static float triggered_position_mm(const AxisEnum axis) {
       return endstops_trigsteps[axis] * planner.steps_to_mm[axis];
     }
 
     #if HAS_MOTOR_CURRENT_PWM
       static void refresh_motor_power();
     #endif
 
   private:
 
     FORCE_INLINE static hal_timer_t calc_timer_interval(hal_timer_t step_rate) {

commit 5cf6a062e315e7c0936f60ba6bf11d7f8fb1f20c
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Dec 9 18:41:15 2017 -0600

    Reset timer count before first block step

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index b15d699872..b1e73bf053 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -355,23 +355,20 @@ class Stepper {
         last_direction_bits = current_block->direction_bits;
         last_extruder = current_block->active_extruder;
         set_directions();
       }
 
       deceleration_time = 0;
       // step_rate to timer interval
       OCR1A_nominal = calc_timer_interval(current_block->nominal_rate);
       // make a note of the number of step loops required at nominal speed
       step_loops_nominal = step_loops;
-      acc_step_rate = current_block->initial_rate;
-      acceleration_time = calc_timer_interval(acc_step_rate);
-      _NEXT_ISR(acceleration_time);
 
       #if ENABLED(LIN_ADVANCE)
         if (current_block->use_advance_lead) {
           current_estep_rate[current_block->active_extruder] = ((unsigned long)acc_step_rate * current_block->abs_adv_steps_multiplier8) >> 17;
           final_estep_rate = (current_block->nominal_rate * current_block->abs_adv_steps_multiplier8) >> 17;
         }
       #endif
 
       // SERIAL_ECHO_START();
       // SERIAL_ECHOPGM("advance :");

commit 4fa65a5c25d8e4771359b0d562b631769183f5f1
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Dec 8 22:13:03 2017 -0600

    TCNT0 => HAL_timer_get_current_count
    
    Fix #8710

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 89f2301f52..b15d699872 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -271,21 +271,21 @@ class Stepper {
     FORCE_INLINE static float triggered_position_mm(AxisEnum axis) {
       return endstops_trigsteps[axis] * planner.steps_to_mm[axis];
     }
 
     #if HAS_MOTOR_CURRENT_PWM
       static void refresh_motor_power();
     #endif
 
   private:
 
-    FORCE_INLINE static hal_timer_t calc_timer(hal_timer_t step_rate) {
+    FORCE_INLINE static hal_timer_t calc_timer_interval(hal_timer_t step_rate) {
       hal_timer_t timer;
 
       NOMORE(step_rate, MAX_STEP_FREQUENCY);
 
       // TODO: HAL: tidy this up, use condtionals_post.h
       #ifdef CPU_32_BIT
         #if ENABLED(DISABLE_MULTI_STEPPING)
           step_loops = 1;
         #else
           if (step_rate > STEP_DOUBLER_FREQUENCY * 2) { // If steprate > (STEP_DOUBLER_FREQUENCY * 2) kHz >> step 4 times
@@ -352,25 +352,25 @@ class Stepper {
       static int8_t last_extruder = -1;
 
       if (current_block->direction_bits != last_direction_bits || current_block->active_extruder != last_extruder) {
         last_direction_bits = current_block->direction_bits;
         last_extruder = current_block->active_extruder;
         set_directions();
       }
 
       deceleration_time = 0;
       // step_rate to timer interval
-      OCR1A_nominal = calc_timer(current_block->nominal_rate);
+      OCR1A_nominal = calc_timer_interval(current_block->nominal_rate);
       // make a note of the number of step loops required at nominal speed
       step_loops_nominal = step_loops;
       acc_step_rate = current_block->initial_rate;
-      acceleration_time = calc_timer(acc_step_rate);
+      acceleration_time = calc_timer_interval(acc_step_rate);
       _NEXT_ISR(acceleration_time);
 
       #if ENABLED(LIN_ADVANCE)
         if (current_block->use_advance_lead) {
           current_estep_rate[current_block->active_extruder] = ((unsigned long)acc_step_rate * current_block->abs_adv_steps_multiplier8) >> 17;
           final_estep_rate = (current_block->nominal_rate * current_block->abs_adv_steps_multiplier8) >> 17;
         }
       #endif
 
       // SERIAL_ECHO_START();

commit de3d3b9cb19cce2be09b5c7c8be32a81bf2b6d97
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Fri Dec 8 00:37:09 2017 -0600

    Put FORCE_INLINE before static

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index a8e55c4d20..89f2301f52 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -192,21 +192,21 @@ class Stepper {
 
     //
     // Get the position (mm) of an axis based on stepper position(s)
     //
     static float get_axis_position_mm(AxisEnum axis);
 
     //
     // SCARA AB axes are in degrees, not mm
     //
     #if IS_SCARA
-      static FORCE_INLINE float get_axis_position_degrees(AxisEnum axis) { return get_axis_position_mm(axis); }
+      FORCE_INLINE static float get_axis_position_degrees(AxisEnum axis) { return get_axis_position_mm(axis); }
     #endif
 
     //
     // The stepper subsystem goes to sleep when it runs out of things to execute. Call this
     // to notify the subsystem that it is time to go to work.
     //
     static void wake_up();
 
     //
     // Wait for moves to finish and disable all steppers
@@ -214,78 +214,78 @@ class Stepper {
     static void finish_and_disable();
 
     //
     // Quickly stop all steppers and clear the blocks queue
     //
     static void quick_stop();
 
     //
     // The direction of a single motor
     //
-    static FORCE_INLINE bool motor_direction(AxisEnum axis) { return TEST(last_direction_bits, axis); }
+    FORCE_INLINE static bool motor_direction(AxisEnum axis) { return TEST(last_direction_bits, axis); }
 
     #if HAS_DIGIPOTSS || HAS_MOTOR_CURRENT_PWM
       static void digitalPotWrite(const int16_t address, const int16_t value);
       static void digipot_current(const uint8_t driver, const int16_t current);
     #endif
 
     #if HAS_MICROSTEPS
       static void microstep_ms(const uint8_t driver, const int8_t ms1, const int8_t ms2);
       static void microstep_mode(const uint8_t driver, const uint8_t stepping);
       static void microstep_readings();
     #endif
 
     #if ENABLED(X_DUAL_ENDSTOPS)
-      static FORCE_INLINE void set_homing_flag_x(const bool state) { performing_homing = state; }
-      static FORCE_INLINE void set_x_lock(const bool state) { locked_x_motor = state; }
-      static FORCE_INLINE void set_x2_lock(const bool state) { locked_x2_motor = state; }
+      FORCE_INLINE static void set_homing_flag_x(const bool state) { performing_homing = state; }
+      FORCE_INLINE static void set_x_lock(const bool state) { locked_x_motor = state; }
+      FORCE_INLINE static void set_x2_lock(const bool state) { locked_x2_motor = state; }
     #endif
 
     #if ENABLED(Y_DUAL_ENDSTOPS)
-      static FORCE_INLINE void set_homing_flag_y(const bool state) { performing_homing = state; }
-      static FORCE_INLINE void set_y_lock(const bool state) { locked_y_motor = state; }
-      static FORCE_INLINE void set_y2_lock(const bool state) { locked_y2_motor = state; }
+      FORCE_INLINE static void set_homing_flag_y(const bool state) { performing_homing = state; }
+      FORCE_INLINE static void set_y_lock(const bool state) { locked_y_motor = state; }
+      FORCE_INLINE static void set_y2_lock(const bool state) { locked_y2_motor = state; }
     #endif
 
     #if ENABLED(Z_DUAL_ENDSTOPS)
-      static FORCE_INLINE void set_homing_flag_z(const bool state) { performing_homing = state; }
-      static FORCE_INLINE void set_z_lock(const bool state) { locked_z_motor = state; }
-      static FORCE_INLINE void set_z2_lock(const bool state) { locked_z2_motor = state; }
+      FORCE_INLINE static void set_homing_flag_z(const bool state) { performing_homing = state; }
+      FORCE_INLINE static void set_z_lock(const bool state) { locked_z_motor = state; }
+      FORCE_INLINE static void set_z2_lock(const bool state) { locked_z2_motor = state; }
     #endif
 
     #if ENABLED(BABYSTEPPING)
       static void babystep(const AxisEnum axis, const bool direction); // perform a short step with a single stepper motor, outside of any convention
     #endif
 
     static inline void kill_current_block() {
       step_events_completed = current_block->step_event_count;
     }
 
     //
     // Handle a triggered endstop
     //
     static void endstop_triggered(AxisEnum axis);
 
     //
     // Triggered position of an axis in mm (not core-savvy)
     //
-    static FORCE_INLINE float triggered_position_mm(AxisEnum axis) {
+    FORCE_INLINE static float triggered_position_mm(AxisEnum axis) {
       return endstops_trigsteps[axis] * planner.steps_to_mm[axis];
     }
 
     #if HAS_MOTOR_CURRENT_PWM
       static void refresh_motor_power();
     #endif
 
   private:
 
-    static FORCE_INLINE hal_timer_t calc_timer(hal_timer_t step_rate) {
+    FORCE_INLINE static hal_timer_t calc_timer(hal_timer_t step_rate) {
       hal_timer_t timer;
 
       NOMORE(step_rate, MAX_STEP_FREQUENCY);
 
       // TODO: HAL: tidy this up, use condtionals_post.h
       #ifdef CPU_32_BIT
         #if ENABLED(DISABLE_MULTI_STEPPING)
           step_loops = 1;
         #else
           if (step_rate > STEP_DOUBLER_FREQUENCY * 2) { // If steprate > (STEP_DOUBLER_FREQUENCY * 2) kHz >> step 4 times
@@ -340,21 +340,21 @@ class Stepper {
           MYSERIAL.print(MSG_STEPPER_TOO_HIGH);
           MYSERIAL.println(step_rate);
         }
       #endif
 
       return timer;
     }
 
     // Initialize the trapezoid generator from the current block.
     // Called whenever a new block begins.
-    static FORCE_INLINE void trapezoid_generator_reset() {
+    FORCE_INLINE static void trapezoid_generator_reset() {
 
       static int8_t last_extruder = -1;
 
       if (current_block->direction_bits != last_direction_bits || current_block->active_extruder != last_extruder) {
         last_direction_bits = current_block->direction_bits;
         last_extruder = current_block->active_extruder;
         set_directions();
       }
 
       deceleration_time = 0;

commit 9898b969926dca060eee40dc7a92a3a31da757c0
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Dec 6 21:28:50 2017 -0600

    No lcd_map_control flag in quick_stop

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 06dac1cd04..a8e55c4d20 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -70,24 +70,25 @@ class Stepper {
       static bool performing_homing;
     #endif
 
     #if HAS_MOTOR_CURRENT_PWM
       #ifndef PWM_MOTOR_CURRENT
         #define PWM_MOTOR_CURRENT DEFAULT_PWM_MOTOR_CURRENT
       #endif
       static uint32_t motor_current_setting[3];
     #endif
 
+    static int16_t cleaning_buffer_counter;
+
   private:
 
     static uint8_t last_direction_bits;        // The next stepping-bits to be output
-    static int16_t cleaning_buffer_counter;
 
     #if ENABLED(X_DUAL_ENDSTOPS)
       static bool locked_x_motor, locked_x2_motor;
     #endif
     #if ENABLED(Y_DUAL_ENDSTOPS)
       static bool locked_y_motor, locked_y2_motor;
     #endif
     #if ENABLED(Z_DUAL_ENDSTOPS)
       static bool locked_z_motor, locked_z2_motor;
     #endif

commit 6040d4080ee347b5276f93cf09a6cfc75286dc74
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Dec 6 12:43:41 2017 -0600

    Cleanup stepper ISR. Allow cleaning for endstops.

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 9ccd884bb4..06dac1cd04 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -73,21 +73,21 @@ class Stepper {
     #if HAS_MOTOR_CURRENT_PWM
       #ifndef PWM_MOTOR_CURRENT
         #define PWM_MOTOR_CURRENT DEFAULT_PWM_MOTOR_CURRENT
       #endif
       static uint32_t motor_current_setting[3];
     #endif
 
   private:
 
     static uint8_t last_direction_bits;        // The next stepping-bits to be output
-    static uint16_t cleaning_buffer_counter;
+    static int16_t cleaning_buffer_counter;
 
     #if ENABLED(X_DUAL_ENDSTOPS)
       static bool locked_x_motor, locked_x2_motor;
     #endif
     #if ENABLED(Y_DUAL_ENDSTOPS)
       static bool locked_y_motor, locked_y2_motor;
     #endif
     #if ENABLED(Z_DUAL_ENDSTOPS)
       static bool locked_z_motor, locked_z2_motor;
     #endif

commit 22463166055c11be400a534deafb50f7b8d9db02
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Nov 5 19:31:07 2017 -0600

    Fix name collision. timer_t => hal_timer_t

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 614b648f90..9ccd884bb4 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -90,38 +90,38 @@ class Stepper {
     #endif
     #if ENABLED(Z_DUAL_ENDSTOPS)
       static bool locked_z_motor, locked_z2_motor;
     #endif
 
     // Counter variables for the Bresenham line tracer
     static long counter_X, counter_Y, counter_Z, counter_E;
     static volatile uint32_t step_events_completed; // The number of step events executed in the current block
 
     #if ENABLED(LIN_ADVANCE)
-      static timer_t nextMainISR, nextAdvanceISR, eISR_Rate;
+      static hal_timer_t nextMainISR, nextAdvanceISR, eISR_Rate;
       #define _NEXT_ISR(T) nextMainISR = T
 
       static volatile int e_steps[E_STEPPERS];
       static int final_estep_rate;
       static int current_estep_rate[E_STEPPERS]; // Actual extruder speed [steps/s]
       static int current_adv_steps[E_STEPPERS];  // The amount of current added esteps due to advance.
                                                  // i.e., the current amount of pressure applied
                                                  // to the spring (=filament).
     #else
       #define _NEXT_ISR(T) HAL_timer_set_count(STEP_TIMER_NUM, T);
     #endif // LIN_ADVANCE
 
     static long acceleration_time, deceleration_time;
     //unsigned long accelerate_until, decelerate_after, acceleration_rate, initial_rate, final_rate, nominal_rate;
-    static timer_t acc_step_rate; // needed for deceleration start point
+    static hal_timer_t acc_step_rate; // needed for deceleration start point
     static uint8_t step_loops, step_loops_nominal;
-    static timer_t OCR1A_nominal;
+    static hal_timer_t OCR1A_nominal;
 
     static volatile long endstops_trigsteps[XYZ];
     static volatile long endstops_stepsTotal, endstops_stepsDone;
 
     //
     // Positions of stepper motors, in step units
     //
     static volatile long count_position[NUM_AXIS];
 
     //
@@ -270,22 +270,22 @@ class Stepper {
     static FORCE_INLINE float triggered_position_mm(AxisEnum axis) {
       return endstops_trigsteps[axis] * planner.steps_to_mm[axis];
     }
 
     #if HAS_MOTOR_CURRENT_PWM
       static void refresh_motor_power();
     #endif
 
   private:
 
-    static FORCE_INLINE timer_t calc_timer(timer_t step_rate) {
-      timer_t timer;
+    static FORCE_INLINE hal_timer_t calc_timer(hal_timer_t step_rate) {
+      hal_timer_t timer;
 
       NOMORE(step_rate, MAX_STEP_FREQUENCY);
 
       // TODO: HAL: tidy this up, use condtionals_post.h
       #ifdef CPU_32_BIT
         #if ENABLED(DISABLE_MULTI_STEPPING)
           step_loops = 1;
         #else
           if (step_rate > STEP_DOUBLER_FREQUENCY * 2) { // If steprate > (STEP_DOUBLER_FREQUENCY * 2) kHz >> step 4 times
             step_rate >>= 2;

commit 723f2a77f6de40024508ea07fd7324e0987a2aa9
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sun Oct 29 03:43:44 2017 -0500

    Implement support for Dual X and Y endstops

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index aa11ef929b..614b648f90 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -59,36 +59,42 @@ extern Stepper stepper;
 class Stepper {
 
   public:
 
     static block_t* current_block;  // A pointer to the block currently being traced
 
     #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
       static bool abort_on_endstop_hit;
     #endif
 
-    #if ENABLED(Z_DUAL_ENDSTOPS)
+    #if ENABLED(X_DUAL_ENDSTOPS) || ENABLED(Y_DUAL_ENDSTOPS) || ENABLED(Z_DUAL_ENDSTOPS)
       static bool performing_homing;
     #endif
 
     #if HAS_MOTOR_CURRENT_PWM
       #ifndef PWM_MOTOR_CURRENT
         #define PWM_MOTOR_CURRENT DEFAULT_PWM_MOTOR_CURRENT
       #endif
       static uint32_t motor_current_setting[3];
     #endif
 
   private:
 
     static uint8_t last_direction_bits;        // The next stepping-bits to be output
     static uint16_t cleaning_buffer_counter;
 
+    #if ENABLED(X_DUAL_ENDSTOPS)
+      static bool locked_x_motor, locked_x2_motor;
+    #endif
+    #if ENABLED(Y_DUAL_ENDSTOPS)
+      static bool locked_y_motor, locked_y2_motor;
+    #endif
     #if ENABLED(Z_DUAL_ENDSTOPS)
       static bool locked_z_motor, locked_z2_motor;
     #endif
 
     // Counter variables for the Bresenham line tracer
     static long counter_X, counter_Y, counter_Z, counter_E;
     static volatile uint32_t step_events_completed; // The number of step events executed in the current block
 
     #if ENABLED(LIN_ADVANCE)
       static timer_t nextMainISR, nextAdvanceISR, eISR_Rate;
@@ -220,22 +226,34 @@ class Stepper {
       static void digitalPotWrite(const int16_t address, const int16_t value);
       static void digipot_current(const uint8_t driver, const int16_t current);
     #endif
 
     #if HAS_MICROSTEPS
       static void microstep_ms(const uint8_t driver, const int8_t ms1, const int8_t ms2);
       static void microstep_mode(const uint8_t driver, const uint8_t stepping);
       static void microstep_readings();
     #endif
 
+    #if ENABLED(X_DUAL_ENDSTOPS)
+      static FORCE_INLINE void set_homing_flag_x(const bool state) { performing_homing = state; }
+      static FORCE_INLINE void set_x_lock(const bool state) { locked_x_motor = state; }
+      static FORCE_INLINE void set_x2_lock(const bool state) { locked_x2_motor = state; }
+    #endif
+
+    #if ENABLED(Y_DUAL_ENDSTOPS)
+      static FORCE_INLINE void set_homing_flag_y(const bool state) { performing_homing = state; }
+      static FORCE_INLINE void set_y_lock(const bool state) { locked_y_motor = state; }
+      static FORCE_INLINE void set_y2_lock(const bool state) { locked_y2_motor = state; }
+    #endif
+
     #if ENABLED(Z_DUAL_ENDSTOPS)
-      static FORCE_INLINE void set_homing_flag(const bool state) { performing_homing = state; }
+      static FORCE_INLINE void set_homing_flag_z(const bool state) { performing_homing = state; }
       static FORCE_INLINE void set_z_lock(const bool state) { locked_z_motor = state; }
       static FORCE_INLINE void set_z2_lock(const bool state) { locked_z2_motor = state; }
     #endif
 
     #if ENABLED(BABYSTEPPING)
       static void babystep(const AxisEnum axis, const bool direction); // perform a short step with a single stepper motor, outside of any convention
     #endif
 
     static inline void kill_current_block() {
       step_events_completed = current_block->step_event_count;

commit 9e699811d25918fe64793824b2a2fdbccdf3b7bd
Author: Thomas Moore <tcm0116@users.noreply.github.com>
Date:   Thu Oct 26 13:37:26 2017 -0500

    Make LPC1768 pinmapping not specific to Re-ARM (#8063)
    
    * Merging early because of build failures.  See #8105
    
    * Make LPC1768 pinmapping not specific to Re-ARM
    
    * Add HAL_PIN_TYPE and LPC1768 pin features
    
    * M43 Updates
    
    * Move pin map into pinsDebug_LPC1768.h
    
    * Incorporate comments and M226
    
    * Fix persistent store compilation issues
    
    * Update pin features
    
    * Update MKS SBASE pins
    
    * Use native LPC1768 pin numbers in M42, M43, and M226

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 6ea5517364..aa11ef929b 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -84,38 +84,38 @@ class Stepper {
 
     #if ENABLED(Z_DUAL_ENDSTOPS)
       static bool locked_z_motor, locked_z2_motor;
     #endif
 
     // Counter variables for the Bresenham line tracer
     static long counter_X, counter_Y, counter_Z, counter_E;
     static volatile uint32_t step_events_completed; // The number of step events executed in the current block
 
     #if ENABLED(LIN_ADVANCE)
-      static HAL_TIMER_TYPE nextMainISR, nextAdvanceISR, eISR_Rate;
+      static timer_t nextMainISR, nextAdvanceISR, eISR_Rate;
       #define _NEXT_ISR(T) nextMainISR = T
 
       static volatile int e_steps[E_STEPPERS];
       static int final_estep_rate;
       static int current_estep_rate[E_STEPPERS]; // Actual extruder speed [steps/s]
       static int current_adv_steps[E_STEPPERS];  // The amount of current added esteps due to advance.
                                                  // i.e., the current amount of pressure applied
                                                  // to the spring (=filament).
     #else
       #define _NEXT_ISR(T) HAL_timer_set_count(STEP_TIMER_NUM, T);
     #endif // LIN_ADVANCE
 
     static long acceleration_time, deceleration_time;
     //unsigned long accelerate_until, decelerate_after, acceleration_rate, initial_rate, final_rate, nominal_rate;
-    static HAL_TIMER_TYPE acc_step_rate; // needed for deceleration start point
+    static timer_t acc_step_rate; // needed for deceleration start point
     static uint8_t step_loops, step_loops_nominal;
-    static HAL_TIMER_TYPE OCR1A_nominal;
+    static timer_t OCR1A_nominal;
 
     static volatile long endstops_trigsteps[XYZ];
     static volatile long endstops_stepsTotal, endstops_stepsDone;
 
     //
     // Positions of stepper motors, in step units
     //
     static volatile long count_position[NUM_AXIS];
 
     //
@@ -252,22 +252,22 @@ class Stepper {
     static FORCE_INLINE float triggered_position_mm(AxisEnum axis) {
       return endstops_trigsteps[axis] * planner.steps_to_mm[axis];
     }
 
     #if HAS_MOTOR_CURRENT_PWM
       static void refresh_motor_power();
     #endif
 
   private:
 
-    static FORCE_INLINE HAL_TIMER_TYPE calc_timer(HAL_TIMER_TYPE step_rate) {
-      HAL_TIMER_TYPE timer;
+    static FORCE_INLINE timer_t calc_timer(timer_t step_rate) {
+      timer_t timer;
 
       NOMORE(step_rate, MAX_STEP_FREQUENCY);
 
       // TODO: HAL: tidy this up, use condtionals_post.h
       #ifdef CPU_32_BIT
         #if ENABLED(DISABLE_MULTI_STEPPING)
           step_loops = 1;
         #else
           if (step_rate > STEP_DOUBLER_FREQUENCY * 2) { // If steprate > (STEP_DOUBLER_FREQUENCY * 2) kHz >> step 4 times
             step_rate >>= 2;

commit 26bfae58d47ae81b78af965ccc59ca63b6203869
Author: Bob-the-Kuhn <bob.kuhn@att.net>
Date:   Tue Oct 10 23:52:53 2017 -0500

    MPC4451 I2C support

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index c87c4ea1dd..6ea5517364 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -290,21 +290,21 @@ class Stepper {
           step_rate >>= 1;
           step_loops = 2;
         }
         else {
           step_loops = 1;
         }
       #endif
 
       #ifdef CPU_32_BIT
         // In case of high-performance processor, it is able to calculate in real-time
-        constexpr uint32_t MIN_TIME_PER_STEP = (HAL_STEPPER_TIMER_RATE) / ((STEP_DOUBLER_FREQUENCY) * 2);
+        const uint32_t MIN_TIME_PER_STEP = (HAL_STEPPER_TIMER_RATE) / ((STEP_DOUBLER_FREQUENCY) * 2);
         timer = uint32_t(HAL_STEPPER_TIMER_RATE) / step_rate;
         NOLESS(timer, MIN_TIME_PER_STEP); // (STEP_DOUBLER_FREQUENCY * 2 kHz - this should never happen)
       #else
         NOLESS(step_rate, F_CPU / 500000);
         step_rate -= F_CPU / 500000; // Correct for minimal speed
         if (step_rate >= (8 * 256)) { // higher step rate
           unsigned short table_address = (unsigned short)&speed_lookuptable_fast[(unsigned char)(step_rate >> 8)][0];
           unsigned char tmp_step_rate = (step_rate & 0x00ff);
           unsigned short gain = (unsigned short)pgm_read_word_near(table_address + 2);
           MultiU16X8toH16(timer, tmp_step_rate, gain);

commit 03f4891fb98c032509643b6fbc8b6d24df6630b6
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Mon Oct 9 04:25:18 2017 -0500

    Remove legacy ADVANCE feature

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index bf3c164976..c87c4ea1dd 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -83,39 +83,33 @@ class Stepper {
     static uint16_t cleaning_buffer_counter;
 
     #if ENABLED(Z_DUAL_ENDSTOPS)
       static bool locked_z_motor, locked_z2_motor;
     #endif
 
     // Counter variables for the Bresenham line tracer
     static long counter_X, counter_Y, counter_Z, counter_E;
     static volatile uint32_t step_events_completed; // The number of step events executed in the current block
 
-    #if ENABLED(ADVANCE) || ENABLED(LIN_ADVANCE)
+    #if ENABLED(LIN_ADVANCE)
       static HAL_TIMER_TYPE nextMainISR, nextAdvanceISR, eISR_Rate;
       #define _NEXT_ISR(T) nextMainISR = T
 
-      #if ENABLED(LIN_ADVANCE)
-        static volatile int e_steps[E_STEPPERS];
-        static int final_estep_rate;
-        static int current_estep_rate[E_STEPPERS]; // Actual extruder speed [steps/s]
-        static int current_adv_steps[E_STEPPERS];  // The amount of current added esteps due to advance.
-                                                   // i.e., the current amount of pressure applied
-                                                   // to the spring (=filament).
-      #else
-        static long e_steps[E_STEPPERS];
-        static long advance_rate, advance, final_advance;
-        static long old_advance;
-      #endif
+      static volatile int e_steps[E_STEPPERS];
+      static int final_estep_rate;
+      static int current_estep_rate[E_STEPPERS]; // Actual extruder speed [steps/s]
+      static int current_adv_steps[E_STEPPERS];  // The amount of current added esteps due to advance.
+                                                 // i.e., the current amount of pressure applied
+                                                 // to the spring (=filament).
     #else
       #define _NEXT_ISR(T) HAL_timer_set_count(STEP_TIMER_NUM, T);
-    #endif // ADVANCE or LIN_ADVANCE
+    #endif // LIN_ADVANCE
 
     static long acceleration_time, deceleration_time;
     //unsigned long accelerate_until, decelerate_after, acceleration_rate, initial_rate, final_rate, nominal_rate;
     static HAL_TIMER_TYPE acc_step_rate; // needed for deceleration start point
     static uint8_t step_loops, step_loops_nominal;
     static HAL_TIMER_TYPE OCR1A_nominal;
 
     static volatile long endstops_trigsteps[XYZ];
     static volatile long endstops_stepsTotal, endstops_stepsDone;
 
@@ -150,21 +144,21 @@ class Stepper {
     // Initialize stepper hardware
     //
     static void init();
 
     //
     // Interrupt Service Routines
     //
 
     static void isr();
 
-    #if ENABLED(ADVANCE) || ENABLED(LIN_ADVANCE)
+    #if ENABLED(LIN_ADVANCE)
       static void advance_isr();
       static void advance_isr_scheduler();
     #endif
 
     //
     // Block until all buffered steps are executed
     //
     static void synchronize();
 
     //
@@ -337,40 +331,20 @@ class Stepper {
     static FORCE_INLINE void trapezoid_generator_reset() {
 
       static int8_t last_extruder = -1;
 
       if (current_block->direction_bits != last_direction_bits || current_block->active_extruder != last_extruder) {
         last_direction_bits = current_block->direction_bits;
         last_extruder = current_block->active_extruder;
         set_directions();
       }
 
-      #if ENABLED(ADVANCE)
-
-        advance = current_block->initial_advance;
-        final_advance = current_block->final_advance;
-
-        // Do E steps + advance steps
-        #if ENABLED(MIXING_EXTRUDER)
-          long advance_factor = (advance >> 8) - old_advance;
-          // ...for mixing steppers proportionally
-          MIXING_STEPPERS_LOOP(j)
-            e_steps[j] += advance_factor * current_block->step_event_count / current_block->mix_event_count[j];
-        #else
-          // ...for the active extruder
-          e_steps[TOOL_E_INDEX] += ((advance >> 8) - old_advance);
-        #endif
-
-        old_advance = advance >> 8;
-
-      #endif
-
       deceleration_time = 0;
       // step_rate to timer interval
       OCR1A_nominal = calc_timer(current_block->nominal_rate);
       // make a note of the number of step loops required at nominal speed
       step_loops_nominal = step_loops;
       acc_step_rate = current_block->initial_rate;
       acceleration_time = calc_timer(acc_step_rate);
       _NEXT_ISR(acceleration_time);
 
       #if ENABLED(LIN_ADVANCE)

commit 8315a8a716d4e9146a5e60231500fa66ca23cbb3
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Sat Oct 7 13:34:25 2017 -0500

    Apply fixes for DUE
    
    Alternative to #7882. If F_CPU is greater than 1000 it can be evenly divided by 8. Over 10000, 16; over 100000, 32; over 1 million, 64; etc.

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index d4f198c18f..bf3c164976 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -296,24 +296,23 @@ class Stepper {
           step_rate >>= 1;
           step_loops = 2;
         }
         else {
           step_loops = 1;
         }
       #endif
 
       #ifdef CPU_32_BIT
         // In case of high-performance processor, it is able to calculate in real-time
-        timer = (uint32_t)(HAL_STEPPER_TIMER_RATE) / step_rate;
-        if (timer < (HAL_STEPPER_TIMER_RATE / (STEP_DOUBLER_FREQUENCY * 2))) { // (STEP_DOUBLER_FREQUENCY * 2 kHz - this should never happen)
-          timer = (HAL_STEPPER_TIMER_RATE / (STEP_DOUBLER_FREQUENCY * 2));
-        }
+        constexpr uint32_t MIN_TIME_PER_STEP = (HAL_STEPPER_TIMER_RATE) / ((STEP_DOUBLER_FREQUENCY) * 2);
+        timer = uint32_t(HAL_STEPPER_TIMER_RATE) / step_rate;
+        NOLESS(timer, MIN_TIME_PER_STEP); // (STEP_DOUBLER_FREQUENCY * 2 kHz - this should never happen)
       #else
         NOLESS(step_rate, F_CPU / 500000);
         step_rate -= F_CPU / 500000; // Correct for minimal speed
         if (step_rate >= (8 * 256)) { // higher step rate
           unsigned short table_address = (unsigned short)&speed_lookuptable_fast[(unsigned char)(step_rate >> 8)][0];
           unsigned char tmp_step_rate = (step_rate & 0x00ff);
           unsigned short gain = (unsigned short)pgm_read_word_near(table_address + 2);
           MultiU16X8toH16(timer, tmp_step_rate, gain);
           timer = (unsigned short)pgm_read_word_near(table_address) - timer;
         }

commit dff2904c0f125b806ee63b21a4b27215b389152f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 27 04:57:14 2017 -0500

    Marlin code whitespace cleanup

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 01c979b567..d4f198c18f 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -295,21 +295,21 @@ class Stepper {
         else if (step_rate > 10000) { // If steprate > 10kHz >> step 2 times
           step_rate >>= 1;
           step_loops = 2;
         }
         else {
           step_loops = 1;
         }
       #endif
 
       #ifdef CPU_32_BIT
-        // In case of high-performance processor, it is able to calculate in real-time 
+        // In case of high-performance processor, it is able to calculate in real-time
         timer = (uint32_t)(HAL_STEPPER_TIMER_RATE) / step_rate;
         if (timer < (HAL_STEPPER_TIMER_RATE / (STEP_DOUBLER_FREQUENCY * 2))) { // (STEP_DOUBLER_FREQUENCY * 2 kHz - this should never happen)
           timer = (HAL_STEPPER_TIMER_RATE / (STEP_DOUBLER_FREQUENCY * 2));
         }
       #else
         NOLESS(step_rate, F_CPU / 500000);
         step_rate -= F_CPU / 500000; // Correct for minimal speed
         if (step_rate >= (8 * 256)) { // higher step rate
           unsigned short table_address = (unsigned short)&speed_lookuptable_fast[(unsigned char)(step_rate >> 8)][0];
           unsigned char tmp_step_rate = (step_rate & 0x00ff);

commit f58ba3a64e94d5f6fa414f3e1bb4d7c1e2ddb46e
Author: Dave Johnson <davejohnson3000@gmail.com>
Date:   Sat Sep 23 21:25:28 2017 -0700

    Improve AVR arch detection
    
    Replace ARDUINO_ARCH_AVR with __AVR__ to better detect architecture for non-Arduino dev environments.  Resolves compile failure in PIO for 8-bit Teensduino targets
    
    More info:
    https://forum.pjrc.com/threads/33234-Using-Teensyduino-Selecting-Teensy-3-2-3-1-board-has-incorrect-platform-define
    http://www.atmel.com/webdoc/avrlibcreferencemanual/using_tools_1using_avr_gcc_mach_opt.html

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index 81c8f04f9b..01c979b567 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -38,21 +38,21 @@
  *
  * You should have received a copy of the GNU General Public License
  * along with Grbl.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #ifndef STEPPER_H
 #define STEPPER_H
 
 #include "stepper_indirection.h"
 
-#ifdef ARDUINO_ARCH_AVR
+#ifdef __AVR__
   #include "speed_lookuptable.h"
 #endif
 
 #include "../inc/MarlinConfig.h"
 #include "../module/planner.h"
 #include "../core/language.h"
 
 class Stepper;
 extern Stepper stepper;
 

commit 3d8a0ab4b215a3869a0388e5c0ef35a6372ed7d5
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 6 06:28:32 2017 -0500

    Module updates

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
index b46273b07c..81c8f04f9b 100644
--- a/Marlin/src/module/stepper.h
+++ b/Marlin/src/module/stepper.h
@@ -36,25 +36,29 @@
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
  *
  * You should have received a copy of the GNU General Public License
  * along with Grbl.  If not, see <http://www.gnu.org/licenses/>.
  */
 
 #ifndef STEPPER_H
 #define STEPPER_H
 
-#include "planner.h"
-#include "speed_lookuptable.h"
 #include "stepper_indirection.h"
-#include "language.h"
-#include "types.h"
+
+#ifdef ARDUINO_ARCH_AVR
+  #include "speed_lookuptable.h"
+#endif
+
+#include "../inc/MarlinConfig.h"
+#include "../module/planner.h"
+#include "../core/language.h"
 
 class Stepper;
 extern Stepper stepper;
 
 class Stepper {
 
   public:
 
     static block_t* current_block;  // A pointer to the block currently being traced
 

commit 0c9231fd04798c30830513a0cad8b204a6b9633f
Author: Scott Lahteine <github@thinkyhead.com>
Date:   Wed Sep 6 06:28:30 2017 -0500

    Move 'module' files

diff --git a/Marlin/src/module/stepper.h b/Marlin/src/module/stepper.h
new file mode 100644
index 0000000000..b46273b07c
--- /dev/null
+++ b/Marlin/src/module/stepper.h
@@ -0,0 +1,401 @@
+/**
+ * Marlin 3D Printer Firmware
+ * Copyright (C) 2016 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
+ *
+ * Based on Sprinter and grbl.
+ * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ *
+ */
+
+/**
+ * stepper.h - stepper motor driver: executes motion plans of planner.c using the stepper motors
+ * Derived from Grbl
+ *
+ * Copyright (c) 2009-2011 Simen Svale Skogsrud
+ *
+ * Grbl is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * Grbl is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with Grbl.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+#ifndef STEPPER_H
+#define STEPPER_H
+
+#include "planner.h"
+#include "speed_lookuptable.h"
+#include "stepper_indirection.h"
+#include "language.h"
+#include "types.h"
+
+class Stepper;
+extern Stepper stepper;
+
+class Stepper {
+
+  public:
+
+    static block_t* current_block;  // A pointer to the block currently being traced
+
+    #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
+      static bool abort_on_endstop_hit;
+    #endif
+
+    #if ENABLED(Z_DUAL_ENDSTOPS)
+      static bool performing_homing;
+    #endif
+
+    #if HAS_MOTOR_CURRENT_PWM
+      #ifndef PWM_MOTOR_CURRENT
+        #define PWM_MOTOR_CURRENT DEFAULT_PWM_MOTOR_CURRENT
+      #endif
+      static uint32_t motor_current_setting[3];
+    #endif
+
+  private:
+
+    static uint8_t last_direction_bits;        // The next stepping-bits to be output
+    static uint16_t cleaning_buffer_counter;
+
+    #if ENABLED(Z_DUAL_ENDSTOPS)
+      static bool locked_z_motor, locked_z2_motor;
+    #endif
+
+    // Counter variables for the Bresenham line tracer
+    static long counter_X, counter_Y, counter_Z, counter_E;
+    static volatile uint32_t step_events_completed; // The number of step events executed in the current block
+
+    #if ENABLED(ADVANCE) || ENABLED(LIN_ADVANCE)
+      static HAL_TIMER_TYPE nextMainISR, nextAdvanceISR, eISR_Rate;
+      #define _NEXT_ISR(T) nextMainISR = T
+
+      #if ENABLED(LIN_ADVANCE)
+        static volatile int e_steps[E_STEPPERS];
+        static int final_estep_rate;
+        static int current_estep_rate[E_STEPPERS]; // Actual extruder speed [steps/s]
+        static int current_adv_steps[E_STEPPERS];  // The amount of current added esteps due to advance.
+                                                   // i.e., the current amount of pressure applied
+                                                   // to the spring (=filament).
+      #else
+        static long e_steps[E_STEPPERS];
+        static long advance_rate, advance, final_advance;
+        static long old_advance;
+      #endif
+    #else
+      #define _NEXT_ISR(T) HAL_timer_set_count(STEP_TIMER_NUM, T);
+    #endif // ADVANCE or LIN_ADVANCE
+
+    static long acceleration_time, deceleration_time;
+    //unsigned long accelerate_until, decelerate_after, acceleration_rate, initial_rate, final_rate, nominal_rate;
+    static HAL_TIMER_TYPE acc_step_rate; // needed for deceleration start point
+    static uint8_t step_loops, step_loops_nominal;
+    static HAL_TIMER_TYPE OCR1A_nominal;
+
+    static volatile long endstops_trigsteps[XYZ];
+    static volatile long endstops_stepsTotal, endstops_stepsDone;
+
+    //
+    // Positions of stepper motors, in step units
+    //
+    static volatile long count_position[NUM_AXIS];
+
+    //
+    // Current direction of stepper motors (+1 or -1)
+    //
+    static volatile signed char count_direction[NUM_AXIS];
+
+    //
+    // Mixing extruder mix counters
+    //
+    #if ENABLED(MIXING_EXTRUDER)
+      static long counter_m[MIXING_STEPPERS];
+      #define MIXING_STEPPERS_LOOP(VAR) \
+        for (uint8_t VAR = 0; VAR < MIXING_STEPPERS; VAR++) \
+          if (current_block->mix_event_count[VAR])
+    #endif
+
+  public:
+
+    //
+    // Constructor / initializer
+    //
+    Stepper() { };
+
+    //
+    // Initialize stepper hardware
+    //
+    static void init();
+
+    //
+    // Interrupt Service Routines
+    //
+
+    static void isr();
+
+    #if ENABLED(ADVANCE) || ENABLED(LIN_ADVANCE)
+      static void advance_isr();
+      static void advance_isr_scheduler();
+    #endif
+
+    //
+    // Block until all buffered steps are executed
+    //
+    static void synchronize();
+
+    //
+    // Set the current position in steps
+    //
+    static void set_position(const long &a, const long &b, const long &c, const long &e);
+    static void set_position(const AxisEnum &a, const long &v);
+    static void set_e_position(const long &e);
+
+    //
+    // Set direction bits for all steppers
+    //
+    static void set_directions();
+
+    //
+    // Get the position of a stepper, in steps
+    //
+    static long position(AxisEnum axis);
+
+    //
+    // Report the positions of the steppers, in steps
+    //
+    static void report_positions();
+
+    //
+    // Get the position (mm) of an axis based on stepper position(s)
+    //
+    static float get_axis_position_mm(AxisEnum axis);
+
+    //
+    // SCARA AB axes are in degrees, not mm
+    //
+    #if IS_SCARA
+      static FORCE_INLINE float get_axis_position_degrees(AxisEnum axis) { return get_axis_position_mm(axis); }
+    #endif
+
+    //
+    // The stepper subsystem goes to sleep when it runs out of things to execute. Call this
+    // to notify the subsystem that it is time to go to work.
+    //
+    static void wake_up();
+
+    //
+    // Wait for moves to finish and disable all steppers
+    //
+    static void finish_and_disable();
+
+    //
+    // Quickly stop all steppers and clear the blocks queue
+    //
+    static void quick_stop();
+
+    //
+    // The direction of a single motor
+    //
+    static FORCE_INLINE bool motor_direction(AxisEnum axis) { return TEST(last_direction_bits, axis); }
+
+    #if HAS_DIGIPOTSS || HAS_MOTOR_CURRENT_PWM
+      static void digitalPotWrite(const int16_t address, const int16_t value);
+      static void digipot_current(const uint8_t driver, const int16_t current);
+    #endif
+
+    #if HAS_MICROSTEPS
+      static void microstep_ms(const uint8_t driver, const int8_t ms1, const int8_t ms2);
+      static void microstep_mode(const uint8_t driver, const uint8_t stepping);
+      static void microstep_readings();
+    #endif
+
+    #if ENABLED(Z_DUAL_ENDSTOPS)
+      static FORCE_INLINE void set_homing_flag(const bool state) { performing_homing = state; }
+      static FORCE_INLINE void set_z_lock(const bool state) { locked_z_motor = state; }
+      static FORCE_INLINE void set_z2_lock(const bool state) { locked_z2_motor = state; }
+    #endif
+
+    #if ENABLED(BABYSTEPPING)
+      static void babystep(const AxisEnum axis, const bool direction); // perform a short step with a single stepper motor, outside of any convention
+    #endif
+
+    static inline void kill_current_block() {
+      step_events_completed = current_block->step_event_count;
+    }
+
+    //
+    // Handle a triggered endstop
+    //
+    static void endstop_triggered(AxisEnum axis);
+
+    //
+    // Triggered position of an axis in mm (not core-savvy)
+    //
+    static FORCE_INLINE float triggered_position_mm(AxisEnum axis) {
+      return endstops_trigsteps[axis] * planner.steps_to_mm[axis];
+    }
+
+    #if HAS_MOTOR_CURRENT_PWM
+      static void refresh_motor_power();
+    #endif
+
+  private:
+
+    static FORCE_INLINE HAL_TIMER_TYPE calc_timer(HAL_TIMER_TYPE step_rate) {
+      HAL_TIMER_TYPE timer;
+
+      NOMORE(step_rate, MAX_STEP_FREQUENCY);
+
+      // TODO: HAL: tidy this up, use condtionals_post.h
+      #ifdef CPU_32_BIT
+        #if ENABLED(DISABLE_MULTI_STEPPING)
+          step_loops = 1;
+        #else
+          if (step_rate > STEP_DOUBLER_FREQUENCY * 2) { // If steprate > (STEP_DOUBLER_FREQUENCY * 2) kHz >> step 4 times
+            step_rate >>= 2;
+            step_loops = 4;
+          }
+          else if (step_rate > STEP_DOUBLER_FREQUENCY) { // If steprate > STEP_DOUBLER_FREQUENCY kHz >> step 2 times
+            step_rate >>= 1;
+            step_loops = 2;
+          }
+          else {
+            step_loops = 1;
+          }
+        #endif
+      #else
+        if (step_rate > 20000) { // If steprate > 20kHz >> step 4 times
+          step_rate >>= 2;
+          step_loops = 4;
+        }
+        else if (step_rate > 10000) { // If steprate > 10kHz >> step 2 times
+          step_rate >>= 1;
+          step_loops = 2;
+        }
+        else {
+          step_loops = 1;
+        }
+      #endif
+
+      #ifdef CPU_32_BIT
+        // In case of high-performance processor, it is able to calculate in real-time 
+        timer = (uint32_t)(HAL_STEPPER_TIMER_RATE) / step_rate;
+        if (timer < (HAL_STEPPER_TIMER_RATE / (STEP_DOUBLER_FREQUENCY * 2))) { // (STEP_DOUBLER_FREQUENCY * 2 kHz - this should never happen)
+          timer = (HAL_STEPPER_TIMER_RATE / (STEP_DOUBLER_FREQUENCY * 2));
+        }
+      #else
+        NOLESS(step_rate, F_CPU / 500000);
+        step_rate -= F_CPU / 500000; // Correct for minimal speed
+        if (step_rate >= (8 * 256)) { // higher step rate
+          unsigned short table_address = (unsigned short)&speed_lookuptable_fast[(unsigned char)(step_rate >> 8)][0];
+          unsigned char tmp_step_rate = (step_rate & 0x00ff);
+          unsigned short gain = (unsigned short)pgm_read_word_near(table_address + 2);
+          MultiU16X8toH16(timer, tmp_step_rate, gain);
+          timer = (unsigned short)pgm_read_word_near(table_address) - timer;
+        }
+        else { // lower step rates
+          unsigned short table_address = (unsigned short)&speed_lookuptable_slow[0][0];
+          table_address += ((step_rate) >> 1) & 0xfffc;
+          timer = (unsigned short)pgm_read_word_near(table_address);
+          timer -= (((unsigned short)pgm_read_word_near(table_address + 2) * (unsigned char)(step_rate & 0x0007)) >> 3);
+        }
+        if (timer < 100) { // (20kHz - this should never happen)
+          timer = 100;
+          MYSERIAL.print(MSG_STEPPER_TOO_HIGH);
+          MYSERIAL.println(step_rate);
+        }
+      #endif
+
+      return timer;
+    }
+
+    // Initialize the trapezoid generator from the current block.
+    // Called whenever a new block begins.
+    static FORCE_INLINE void trapezoid_generator_reset() {
+
+      static int8_t last_extruder = -1;
+
+      if (current_block->direction_bits != last_direction_bits || current_block->active_extruder != last_extruder) {
+        last_direction_bits = current_block->direction_bits;
+        last_extruder = current_block->active_extruder;
+        set_directions();
+      }
+
+      #if ENABLED(ADVANCE)
+
+        advance = current_block->initial_advance;
+        final_advance = current_block->final_advance;
+
+        // Do E steps + advance steps
+        #if ENABLED(MIXING_EXTRUDER)
+          long advance_factor = (advance >> 8) - old_advance;
+          // ...for mixing steppers proportionally
+          MIXING_STEPPERS_LOOP(j)
+            e_steps[j] += advance_factor * current_block->step_event_count / current_block->mix_event_count[j];
+        #else
+          // ...for the active extruder
+          e_steps[TOOL_E_INDEX] += ((advance >> 8) - old_advance);
+        #endif
+
+        old_advance = advance >> 8;
+
+      #endif
+
+      deceleration_time = 0;
+      // step_rate to timer interval
+      OCR1A_nominal = calc_timer(current_block->nominal_rate);
+      // make a note of the number of step loops required at nominal speed
+      step_loops_nominal = step_loops;
+      acc_step_rate = current_block->initial_rate;
+      acceleration_time = calc_timer(acc_step_rate);
+      _NEXT_ISR(acceleration_time);
+
+      #if ENABLED(LIN_ADVANCE)
+        if (current_block->use_advance_lead) {
+          current_estep_rate[current_block->active_extruder] = ((unsigned long)acc_step_rate * current_block->abs_adv_steps_multiplier8) >> 17;
+          final_estep_rate = (current_block->nominal_rate * current_block->abs_adv_steps_multiplier8) >> 17;
+        }
+      #endif
+
+      // SERIAL_ECHO_START();
+      // SERIAL_ECHOPGM("advance :");
+      // SERIAL_ECHO(current_block->advance/256.0);
+      // SERIAL_ECHOPGM("advance rate :");
+      // SERIAL_ECHO(current_block->advance_rate/256.0);
+      // SERIAL_ECHOPGM("initial advance :");
+      // SERIAL_ECHO(current_block->initial_advance/256.0);
+      // SERIAL_ECHOPGM("final advance :");
+      // SERIAL_ECHOLN(current_block->final_advance/256.0);
+    }
+
+    #if HAS_DIGIPOTSS || HAS_MOTOR_CURRENT_PWM
+      static void digipot_init();
+    #endif
+
+    #if HAS_MICROSTEPS
+      static void microstep_init();
+    #endif
+
+};
+
+#endif // STEPPER_H
